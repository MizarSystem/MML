:: Proof of Ford/Fulkerson's Maximum Network Flow Algorithm
::  by Gilbert Lee
:: 
:: Received February 22, 2005
:: Copyright (c) 2005 Association of Mizar Users

environ

 vocabulary AMI_1, ARYTM, ARYTM_1, ARYTM_3, BOOLE, CARD_1, CAT_1, FINSEQ_1,
      FINSET_1, FUNCOP_1, FUNCT_1, FUNCT_4, GRAPH_1, GRAPH_5, GLIB_000,
      GLIB_001, GLIB_003, GLIB_005, MATRIX_2, MSAFREE2, NAT_1, NEWTON,
      ORDINAL2, PARTFUN1, PBOOLE, POLYNOM1, PRE_TOPC, REALSET1, RELAT_1,
      RLVECT_1, SEQ_1, SEQM_3, SGRAPH1, TREES_1, UPROOTS;
 notations TARSKI, XBOOLE_0, NUMBERS, SUBSET_1, XCMPLX_0, XREAL_0, DOMAIN_1,
      REAL_1, RELAT_1, PARTFUN1, FUNCT_1, FINSEQ_1, SEQ_1, CARD_1, PBOOLE,
      CARD_FIL, FUNCT_2, GRAPH_5, ORDINAL1, ORDINAL2, POLYNOM1, UPROOTS,
      RELSET_1, FINSET_1, NAT_1, CQC_LANG, FUNCT_4, PRE_CIRC, SEQM_3, GLIB_000,
      GLIB_001, ABIAN, GLIB_002, GLIB_003;
 constructors GRAPH_5, DOMAIN_1, CARD_FIL, REAL_1, BINOP_2, AMISTD_2, PRE_CIRC,
      UPROOTS, GLIB_002, GLIB_003;
 registrations RELSET_1, FINSET_1, XREAL_0, BINARITH, INT_1, ABIAN, FINSEQ_1,
      NAT_1, FUNCOP_1, AMISTD_2, JORDAN1D, MEMBERED, ORDINAL2, POLYNOM1,
      BAGORDER, RFINSEQ, GLIB_000, GLIB_001, GLIB_002, GLIB_003;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 theorems AXIOMS, CARD_1, CARD_2, CQC_LANG, FINSEQ_1, FINSEQ_2, FINSEQ_3,
      FUNCOP_1, FUNCT_1, FUNCT_2, FUNCT_4, GLIB_000, GLIB_001, GLIB_003,
      GLIB_004, GRAPH_5, HEYTING3, INT_1, NAT_1, ORDINAL2, PBOOLE, PEPIN,
      POLYNOM1, REAL_1, RELAT_1, SEQ_1, SEQM_3, TARSKI, UPROOTS, XBOOLE_0,
      XBOOLE_1, XCMPLX_1, XREAL_0, ZFMISC_1;
 schemes BINARITH, NAT_1, SUBSET_1, FINSEQ_1, FUNCT_1, RECDEF_1, GRAPH_5;

begin ::Preliminary theorems 

registration let x be set, y be real number;
  cluster x.-->y -> real-yielding;
  coherence proof
A1: rng (x.-->y) = {y} by CQC_LANG:5; 
    y in REAL by XREAL_0:def 1; then
    rng (x.-->y) c= REAL by A1,ZFMISC_1:37;
    hence thesis by SEQ_1:def 1;
  end;
end;

registration let x be set, y be natural number;
  cluster x --> y -> natural-yielding;
  coherence proof
    now per cases;
      suppose x = {}; then
        rng (x --> y) = {} by FUNCOP_1:16;
        hence rng (x-->y) c= NAT by XBOOLE_1:2;
      end;
      suppose x <> {}; then
    B1: rng (x --> y) = {y} by FUNCOP_1:14;
        y in NAT by ORDINAL2:def 21;
        hence rng (x-->y) c= NAT by B1,ZFMISC_1:37;
      end;
    end;
    hence thesis by SEQM_3:def 8;
  end;
end;  

registration let f,g be real-yielding Function;
  cluster f +* g -> real-yielding;
  coherence proof
A1: rng (f +* g) c= rng f \/ rng g by FUNCT_4:18;
    rng f c= REAL & rng g c= REAL by SEQ_1:def 1; then
    rng f \/ rng g c= REAL by XBOOLE_1:8; then
    rng (f +* g) c= REAL by A1,XBOOLE_1:1;
    hence thesis by SEQ_1:def 1;
  end;
end;

begin ::Preliminaries definitions for Maximum Flow Algorithm

definition let G be EGraph;
  attr G is complete-elabeled means :dCMPELABEL: ::dCMPELABEL
    dom the_ELabel_of G = the_Edges_of G;
end;

registration let G be _Graph, X be ManySortedSet of the_Edges_of G;
  cluster G.set(ELabelSelector, X) -> complete-elabeled;
  coherence proof
    set G2 = G.set(ELabelSelector,X);
    the_ELabel_of G2 = G2.ELabelSelector by GLIB_003:def 8
                    .= X by GLIB_000:11; then
A1: dom the_ELabel_of G2 = the_Edges_of G by PBOOLE:def 3;
    G2 == G by GLIB_003:8; then
    the_Edges_of G2 = the_Edges_of G by GLIB_000:def 36;
    hence thesis by dCMPELABEL,A1;
  end;
end;

registration let G be _Graph, Y be non empty set,
                 X be Function of the_Edges_of G, Y;
  cluster G.set(ELabelSelector, X) -> complete-elabeled;
  coherence proof
    set G2 = G.set(ELabelSelector,X);
    the_ELabel_of G2 = G2.ELabelSelector by GLIB_003:def 8
                    .= X by GLIB_000:11; then
A1: dom the_ELabel_of G2 = the_Edges_of G by FUNCT_2:def 1;
    G2 == G by GLIB_003:8; then
    the_Edges_of G2 = the_Edges_of G by GLIB_000:def 36;
    hence thesis by dCMPELABEL,A1;
  end;
end;  

definition let GSq be EGraphSeq;
  attr GSq is complete-elabeled means :dGSEQCELABEL: ::dGSEQCELABEL
    for x being Nat holds GSq.->x is complete-elabeled;
end;

definition let G be WGraph;
  attr G is natural-weighted means :dNATWEIGHT: ::dNATWEIGHT
    the_Weight_of G is natural-yielding;
end;

definition let G be EGraph;
  attr G is natural-elabeled means :dNATELABEL: ::dNATELABEL
    the_ELabel_of G is natural-yielding;
end;

definition let GSq be WGraphSeq;
  attr GSq is natural-weighted means :dGSEQNWEIGHT: ::dGSEQNWEIGHT
    for x being Nat holds GSq.->x is natural-weighted;
end;  
  
definition let GSq be EGraphSeq;
  attr GSq is natural-elabeled means :dGSEQNELABEL: ::dGSEQNELABEL
    for x being Nat holds GSq.->x is natural-elabeled;
end;

registration
  cluster natural-weighted -> nonnegative-weighted WGraph;
  coherence proof
    let G be WGraph; assume G is natural-weighted; then
A1: the_Weight_of G is natural-yielding by dNATWEIGHT;
    now let y be set; assume
    B1: y in rng the_Weight_of G;
        rng the_Weight_of G c= NAT by A1,SEQM_3:def 8; then
        reconsider y'=y as Nat by B1;
        y' is Real & y' >= 0 by NAT_1:18; 
        hence y in Real>=0 by GRAPH_5:def 12;
    end; then
    rng the_Weight_of G c= Real>=0 by TARSKI:def 3;
    hence thesis by GLIB_003:def 14;
  end;
end;

registration
  cluster natural-elabeled -> real-elabeled EGraph;
  coherence proof
    let G be EGraph; assume G is natural-elabeled; then
    reconsider EL = the_ELabel_of G as natural-yielding Function
      by dNATELABEL;
    EL is real-yielding;
    hence thesis by GLIB_003:def 15;
  end;
end;  

registration 
  cluster finite trivial Tree-like natural-weighted
          natural-elabeled complete-elabeled real-vlabeled WEVGraph;
  existence proof
    set V = {1}; set E = {};
    reconsider S = {} as Function of E,V by FUNCT_2:55,RELAT_1:60;
    set G1 = createGraph(V,E,S,S);
    consider WL being Function of the_Edges_of G1, NAT;
    set G2 = G1.set(WeightSelector, WL);
    consider EL being Function of the_Edges_of G2, NAT;
    set G3 = G2.set(ELabelSelector, EL);
    consider VL being PartFunc of the_Vertices_of G3, REAL;
    set G4 = G3.set(VLabelSelector, VL);
    take G4;  
    thus G4 is finite & G4 is trivial & G4 is Tree-like;
A1: G4==G3 & G3==G2 & G2==G1 by GLIB_003:8;
    the_Weight_of G4 = G4.WeightSelector by GLIB_003:4
                    .= G3.WeightSelector by GLIB_003:3,GLIB_000:12
                    .= G2.WeightSelector by GLIB_003:3,GLIB_000:12
                    .= WL by GLIB_000:11;
    hence G4 is natural-weighted by dNATWEIGHT;
A5: the_ELabel_of G4 = G4.ELabelSelector by GLIB_003:4
                    .= G3.ELabelSelector by GLIB_003:3,GLIB_000:12
                    .= EL by GLIB_000:11;
    hence G4 is natural-elabeled by dNATELABEL;
    dom the_ELabel_of G4 = the_Edges_of G2 by A5,FUNCT_2:def 1
                        .= the_Edges_of G3 by A1,GLIB_000:def 36
                        .= the_Edges_of G4 by A1,GLIB_000:def 36;
    hence G4 is complete-elabeled by dCMPELABEL;
    thus G4 is real-vlabeled;
  end;
end;

registration
  cluster finite natural-weighted real-WEV natural-elabeled
          complete-elabeled WEVGraphSeq;
  existence proof
    consider G being finite natural-weighted real-WEV natural-elabeled
      complete-elabeled WEVGraph;
    set F = NAT --> G;
A1: dom F = NAT by FUNCOP_1:19; 
    reconsider F as ManySortedSet of NAT;
    now let x be Nat;
        F.x in rng F by A1,FUNCT_1:12; then
        F.x in {G} by FUNCOP_1:14;
        hence F.x is _Graph by TARSKI:def 1;
    end; then reconsider F as GraphSeq by GLIB_000:def 55;
    now let x be Nat;
        F.x in rng F by A1, FUNCT_1:12; then
        F.x in {G} by FUNCOP_1:14; then
        F.x = G by TARSKI:def 1;
        hence F.->x is [Weighted] & F.->x is [ELabeled] & F.->x is [VLabeled]
          by GLIB_000:def 59;
    end; then reconsider F as WEVGraphSeq
      by GLIB_003:def 24,GLIB_003:def 25,GLIB_003:def 26;
    take F;
    now let x be Nat;
        F.x in rng F by A1, FUNCT_1:12; then
        F.x in {G} by FUNCOP_1:14; then
        F.x = G by TARSKI:def 1;
        hence F.->x is finite & F.->x is real-WEV & F.->x is complete-elabeled
          & F.->x is natural-elabeled & F.->x is natural-weighted
          by GLIB_000:def 59;
    end;
    hence thesis by GLIB_003:def 31,dGSEQCELABEL,GLIB_000:def 60,
      dGSEQNELABEL,dGSEQNWEIGHT;
  end;
end;

registration let GSq be complete-elabeled EGraphSeq, x be Nat;
  cluster GSq.->x -> complete-elabeled;
  coherence by dGSEQCELABEL;
end;

registration let GSq be natural-elabeled EGraphSeq, x be Nat;
  cluster GSq.->x -> natural-elabeled;
  coherence by dGSEQNELABEL;
end;

registration let GSq be natural-weighted WGraphSeq, x be Nat;
  cluster GSq.->x -> natural-weighted;
  coherence by dGSEQNWEIGHT;
end;

registration let G be natural-weighted WGraph;
  cluster the_Weight_of G -> natural-yielding;
  coherence by dNATWEIGHT;
end;

registration let G be natural-elabeled EGraph;
  cluster the_ELabel_of G -> natural-yielding;
  coherence by dNATELABEL;
end;

definition let G be complete-elabeled EGraph;
  redefine func the_ELabel_of G -> ManySortedSet of the_Edges_of G;
  coherence proof
    dom the_ELabel_of G = the_Edges_of G by dCMPELABEL;
    hence thesis by PBOOLE:def 3;
  end;
end;

registration let G be natural-weighted WGraph, X be set;
  cluster G.set(ELabelSelector, X) -> natural-weighted; coherence proof
    set G2 = G.set(ELabelSelector,X);  
   the_Weight_of G2 = G2.WeightSelector by GLIB_003:4
                   .= G.WeightSelector by GLIB_003:3,GLIB_000:12
                   .= the_Weight_of G by GLIB_003:4;
    hence thesis by dNATWEIGHT;
  end;
  cluster G.set(VLabelSelector, X) -> natural-weighted; coherence proof
    set G2 = G.set(VLabelSelector,X);  
    the_Weight_of G2 = G2.WeightSelector by GLIB_003:4
                    .= G.WeightSelector by GLIB_003:3,GLIB_000:12
                    .= the_Weight_of G by GLIB_003:4;
    hence thesis by dNATWEIGHT;
  end;
end;  

registration let G be _Graph,
                 X be natural-yielding ManySortedSet of the_Edges_of G;
  cluster G.set(ELabelSelector, X) -> natural-elabeled;
  coherence proof
    set G2 = G.set(ELabelSelector, X);
    the_ELabel_of G2 = G2.ELabelSelector by GLIB_003:4
                    .= X by GLIB_000:11;
    hence thesis by dNATELABEL;
  end;
end;  

definition let G be finite real-weighted
                    real-elabeled complete-elabeled WEGraph,
               source,sink be set;
  pred G has_valid_flow_from source,sink means :dVFLOW: ::dVFLOW
     source is Vertex of G & sink is Vertex of G &
     (for e being set st e in the_Edges_of G holds
        0 <= (the_ELabel_of G).e &
             (the_ELabel_of G).e <= (the_Weight_of G).e) &
     (for v being Vertex of G st v <> source & v <> sink holds
       Sum ((the_ELabel_of G) | v.edgesIn()) =
       Sum ((the_ELabel_of G) | v.edgesOut()));
end;

definition let G be finite real-weighted real-elabeled
                    complete-elabeled WEGraph, source, sink be set; assume
 G has_valid_flow_from source,sink; ::
  func G.flow(source,sink) -> real number equals :dGFLOW: ::dGFLOW
    Sum ((the_ELabel_of G) | G.edgesInto({sink})) -
    Sum ((the_ELabel_of G) | G.edgesOutOf({sink}));
  coherence;
end;

definition let G be finite real-weighted real-elabeled
                    complete-elabeled WEGraph, source,sink be set;
  pred G has_maximum_flow_from source,sink means :dGMAXFLOW: ::dGMAXFLOW
    G has_valid_flow_from source,sink &
    for G2 being finite real-weighted real-elabeled complete-elabeled WEGraph
     st G2 == G & the_Weight_of G = the_Weight_of G2 &
        G2 has_valid_flow_from source,sink holds
        G2.flow(source,sink) <= G.flow(source,sink);
end;  

definition let G be real-weighted real-elabeled WEVGraph, e be set;
  pred e is_forward_labeling_in G means :dFORLABEL: ::dFORLABEL
    e in the_Edges_of G &
    (the_Source_of G).e in G.labeledV() &
    not (the_Target_of G).e in G.labeledV() &
    (the_ELabel_of G).e < (the_Weight_of G).e;
end;    
    
definition let G be real-elabeled EVGraph, e be set;    
  pred e is_backward_labeling_in G means :dBACKLABEL: ::dBACKLABEL
    e in the_Edges_of G &
    (the_Target_of G).e in G.labeledV() &
    not (the_Source_of G).e in G.labeledV() &
    0 < (the_ELabel_of G).e;
end;

definition let G be real-weighted real-elabeled WEGraph, W be Walk of G;
  attr W is augmenting means :dWAUGMENT: ::dWAUGMENT
   for n being odd Nat st n < len W holds
     (W.(n+1) DJoins W.n, W.(n+2), G implies
       (the_ELabel_of G).(W.(n+1)) < (the_Weight_of G).(W.(n+1))) &
     (not W.(n+1) DJoins W.n,W.(n+2), G implies
       0 < (the_ELabel_of G).(W.(n+1)));
end;

registration let G be real-weighted real-elabeled WEGraph;
  cluster trivial -> augmenting Walk of G;
  coherence proof
    let W be Walk of G; assume
A0: W is trivial;
    now let n be odd Nat; assume n < len W; then
        n < 1 by A0,GLIB_001:127;
        hence (W.(n+1) DJoins W.n, W.(n+2), G implies
          (the_ELabel_of G).(W.(n+1)) < (the_Weight_of G).(W.(n+1))) &
          (not W.(n+1) DJoins W.n,W.(n+2), G implies
          0 < (the_ELabel_of G).(W.(n+1))) by HEYTING3:1;
    end;
    hence W is augmenting by dWAUGMENT;
  end;
end;

registration let G be real-weighted real-elabeled WEGraph;
  cluster vertex-distinct augmenting Path of G;
  existence proof
    consider P being trivial Path of G;
    take P;
    thus thesis;
  end; 
end;

registration let G be real-weighted real-elabeled WEGraph,
                 W be augmenting Walk of G, m,n be Nat;
  cluster W.cut(m,n) -> augmenting;
  coherence proof
    set W2 = W.cut(m,n);
    now per cases;
      suppose
    B1: (m is odd & n is odd & m <= n & n <= len W); then
        reconsider m'=m as odd Nat;
        now let x be odd Nat; assume x < len W2; then
        C2: x in dom W2 & x+1 in dom W2 & x+2 in dom W2 by GLIB_001:13;
            set v1b = W2.x, eb = W2.(x+1), v2b = W2.(x+2);
        C3: W2.x = W.(m+x-1) & (m+x-1) in dom W &
            W2.(x+1) = W.(m+(x+1)-1) & (m+(x+1)-1) in dom W &
            W2.(x+2) = W.(m+(x+2)-1) & (m+(x+2)-1) in dom W
              by B1,C2,GLIB_001:48; then
            reconsider a = m'+x-1,a1 = m+(x+1)-1,a2=m+(x+2)-1 as Nat;
            reconsider a as odd Nat;
            set v1a = W.a, ea = W.(a+1), v2a = W.(a+2);
            a2 <= len W by C3,FINSEQ_3:27; then
        C4: m+(x+2)-1-2 < len W - 0 by REAL_1:92;
            hereby assume eb DJoins v1b,v2b,G; then
                ea DJoins v1a,v2a,G by C3;
                hence (the_ELabel_of G).eb < (the_Weight_of G).eb
                  by C3,C4,dWAUGMENT;
            end;
            assume not eb DJoins v1b,v2b,G; then
            not ea DJoins v1a,v2a,G by C3;
            hence 0 < (the_ELabel_of G).eb by C3,C4,dWAUGMENT;
        end;
        hence thesis by dWAUGMENT;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by GLIB_001:def 11;
      end;
    end;
   hence thesis;
  end;
end;

theorem ::tWAUGMENT01
  for G1,G2 being real-weighted real-elabeled WEGraph, W1 being Walk of G1,
      W2 being Walk of G2
   st W1 is augmenting & G1 == G2 & the_Weight_of G1 = the_Weight_of G2 &
      the_ELabel_of G1 = the_ELabel_of G2 & W1 = W2 holds
      W2 is augmenting proof
    let G1,G2 be real-weighted real-elabeled WEGraph, W1 be Walk of G1,
        W2 be Walk of G2; assume
A1: W1 is augmenting & G1 == G2 & the_Weight_of G1 = the_Weight_of G2 &
    the_ELabel_of G1 = the_ELabel_of G2 & W1 = W2;
    let n be odd Nat; assume
    n < len W2; then
    (W2.(n+1) DJoins W2.n, W2.(n+2), G1 implies
       (the_ELabel_of G2).(W2.(n+1)) < (the_Weight_of G2).(W2.(n+1))) &
     (not W2.(n+1) DJoins W2.n, W2.(n+2), G1 implies
       0 < (the_ELabel_of G2).(W2.(n+1))) by dWAUGMENT,A1;
    hence thesis by A1,GLIB_000:91;
end;

theorem tWAUGMENT02: ::tWAUGMENT02
  for G being real-weighted real-elabeled WEGraph,
      W being augmenting Walk of G, e,v being set 
   st not v in W.vertices() & 
      ((e DJoins W.last(),v,G & (the_ELabel_of G).e < (the_Weight_of G).e) or
       (e DJoins v,W.last(),G & 0 < (the_ELabel_of G).e))
   holds W.addEdge(e) is augmenting proof
    let G be real-weighted real-elabeled WEGraph,
        W be augmenting Walk of G, e,v be set;
    set W2 = W.addEdge(e); assume
A1: not v in W.vertices() &
    ((e DJoins W.last(),v,G & (the_ELabel_of G).e < (the_Weight_of G).e) or
     (e DJoins v,W.last(),G & 0 < (the_ELabel_of G).e));
    let n be odd Nat; assume
A2: n < len W2;
A3: e Joins W.last(),v,G by A1,GLIB_000:19;
    now per cases;
      suppose
    B1: n < len W; then
        n in dom W & n+1 in dom W & n+2 in dom W by GLIB_001:13; then
        W.n = W2.n & W.(n+1) = W2.(n+1) & W.(n+2) = W2.(n+2)
          by A3,GLIB_001:66;
        hence (W2.(n+1) DJoins W2.n, W2.(n+2), G implies
          (the_ELabel_of G).(W2.(n+1)) < (the_Weight_of G).(W2.(n+1))) &
        (not W2.(n+1) DJoins W2.n, W2.(n+2),G implies
          0 < (the_ELabel_of G).(W2.(n+1))) by B1,dWAUGMENT;
      end;
      suppose
    B1: n >= len W; 
        n+1 <= len W2 by A2,NAT_1:38; then
        n+1 <= len W + 2*1 by A3,GLIB_001:65; then
        n+1 < len W + 1+1 by REAL_1:def 5; then
        n+1 <= len W + 1 by NAT_1:38; then
        n <= len W by REAL_1:53; then
    B2: 1 <= n & n = len W by B1, HEYTING3:1, AXIOMS:21; then
        n in dom W by FINSEQ_3:27; then
    B3: W2.n = W.n by A3,GLIB_001:66
            .= W.last() by B2,GLIB_001:def 7;
    B4: W2.(n+1) = e & W2.(n+2) = v by A3,B2,GLIB_001:66;
    B5: now assume e DJoins W.last(),v,G & e DJoins v,W.last(),G; then
            (the_Source_of G).e = W.last() &
              (the_Source_of G).e = v by GLIB_000:def 16;
            hence contradiction by A1,GLIB_001:89;
        end;
        thus W2.(n+1) DJoins W2.n, W2.(n+2),G implies
          (the_ELabel_of G).(W2.(n+1)) < (the_Weight_of G).(W2.(n+1))
          by A1,B3,B4,B5;
        assume not W2.(n+1) DJoins W2.n, W2.(n+2),G;
        hence 0 < (the_ELabel_of G).(W2.(n+1)) by A1,B3,B4;
      end;
    end;
    hence thesis;
end;

begin :: Finding an Augmenting Path in a Graph
definition let G be real-weighted real-elabeled WEVGraph;
  func AP:NextBestEdges(G) -> Subset of the_Edges_of G means :dAPNEXT: ::dAPNEXT
     for e being set holds e in it iff
     (e is_forward_labeling_in G or e is_backward_labeling_in G);
  existence proof
    defpred P[set] means $1 is_forward_labeling_in G or
                         $1 is_backward_labeling_in G;
    consider IT being Subset of the_Edges_of G such that
A1: for e being set holds e in IT iff e in the_Edges_of G & P[e]
      from SUBSET_1:sch 1;
    take IT;
    let e be set;
    thus e in IT implies P[e] by A1;
    assume
A2: P[e]; then
    e in the_Edges_of G by dFORLABEL,dBACKLABEL;
    hence e in IT by A1,A2;
  end;
  uniqueness proof
    let IT1,IT2 be Subset of the_Edges_of G such that
A1: for e being set holds e in IT1 iff
    (e is_forward_labeling_in G or e is_backward_labeling_in G) and
A2: for e being set holds e in IT2 iff
    (e is_forward_labeling_in G or e is_backward_labeling_in G);
    now let e be set;
        hereby assume e in IT1; then
            (e is_forward_labeling_in G or e is_backward_labeling_in G) by A1;
            hence e in IT2 by A2;
        end;
        assume e in IT2; then
        (e is_forward_labeling_in G or e is_backward_labeling_in G) by A2;
        hence e in IT1 by A1;
    end;
    hence IT1 = IT2 by TARSKI:2;
  end;
end;

definition let G be real-weighted real-elabeled WEVGraph;
  set e = choose AP:NextBestEdges(G);
  func AP:Step(G) -> real-weighted real-elabeled WEVGraph equals :dAPSTEP: ::dAPSTEP
     G if AP:NextBestEdges(G) = {},
     G.labelVertex((the_Source_of G).e, e) if
          AP:NextBestEdges(G) <> {} &
          not (the_Source_of G).e in G.labeledV() otherwise
     G.labelVertex((the_Target_of G).e, e);
  coherence;
  consistency;
end;

registration let G be finite real-weighted real-elabeled WEVGraph;
  cluster AP:Step(G) -> finite;
  coherence proof
    set e = choose AP:NextBestEdges(G), G2 = AP:Step(G);
    now per cases;
      suppose AP:NextBestEdges(G) = {};
        hence thesis by dAPSTEP;
      end;
      suppose AP:NextBestEdges(G) <> {} &
          not (the_Source_of G).e in G.labeledV(); then
        G2 = G.labelVertex((the_Source_of G).e, e) by dAPSTEP;
        hence thesis;
      end;
      suppose AP:NextBestEdges(G)<>{} &
        (the_Source_of G).e in G.labeledV(); then
        G2 = G.labelVertex((the_Target_of G).e, e) by dAPSTEP;
        hence thesis;
      end;
   end;
   hence thesis;
  end;
end;

definition let G be real-weighted real-elabeled WEGraph, source be Vertex of G;
  func AP:CompSeq(G,source) -> real-weighted real-elabeled WEVGraphSeq means
:dAPCS: ::dAPCS
    it.->0 = G.set(VLabelSelector, source .--> 1) &
    for n being Nat holds it.->(n+1) = AP:Step(it.->n);
  existence proof
    defpred P[set,set,set] means
      ($2 is real-weighted real-elabeled WEVGraph &
        ex Gn,Gn1 being real-weighted real-elabeled WEVGraph st
          $2 = Gn & $3 = Gn1 & Gn1 = AP:Step(Gn)) or
      (not $2 is real-weighted real-elabeled WEVGraph & $2 = $3);
    now let n,x be set;
        now per cases;
          suppose
            x is real-weighted real-elabeled WEVGraph; then
            reconsider Gn=x as real-weighted real-elabeled WEVGraph;
            P[n,x,AP:Step(Gn)];
            hence ex y being set st P[n,x,y];
          end;
          suppose not x is real-weighted real-elabeled WEVGraph;
            hence ex y being set st P[n,x,y];
          end;
        end;
        hence ex y being set st P[n,x,y];
    end; then
A1: for n being Nat for x being set ex y being set st P[n,x,y];
A2: for n being Nat for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2]
      holds y1 = y2;
    consider IT being Function such that
A3: dom IT = NAT & IT.0 = G.set(VLabelSelector, source.-->1) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
      from RECDEF_1:sch 1(A1,A2);
    reconsider IT as ManySortedSet of NAT by A3, PBOOLE:def 3;
    defpred P2[Nat] means IT.$1 is real-weighted real-elabeled WEVGraph;
A4: P2[0] by A3;
A5: now let n be Nat; assume
     P2[n]; then
        consider Gn,Gn1 being real-weighted real-elabeled WEVGraph such that
    B2: IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = AP:Step(Gn) by A3;
        thus P2[n+1] by B2;
    end;
A6: for n being Nat holds P2[n] from NAT_1:sch 1(A4,A5); then
    for n being Nat holds IT.n is _Graph; then
    reconsider IT as GraphSeq by GLIB_000:def 55;
A7: now let n be Nat;
        IT.->n = IT.n by GLIB_000:def 59;
        hence IT.->n is real-weighted real-elabeled WEVGraph by A6;
    end; then
    for n being Nat holds
      IT.->n is [Weighted] & IT.->n is [ELabeled] & IT.->n is [VLabeled]; then
    reconsider IT as WEVGraphSeq
      by GLIB_003:def 24,GLIB_003:def 25,GLIB_003:def 26;
    for n being Nat holds IT.->n is real-weighted &
      IT.->n is real-elabeled by A7; then
    reconsider IT as real-weighted real-elabeled WEVGraphSeq
      by GLIB_003:def 27,GLIB_003:def 29;
    take IT;
    thus IT.->0 = G.set(VLabelSelector,source.-->1) by A3,GLIB_000:def 59;
    let n be Nat;
    IT.n is real-weighted real-elabeled WEVGraph by A6; then
    consider Gn,Gn1 being real-weighted real-elabeled WEVGraph such that
A8: IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = AP:Step(Gn) by A3;
    Gn = IT.->n & Gn1 = IT.->(n+1) by A8, GLIB_000:def 59;
    hence IT.->(n+1) = AP:Step(IT.->n) by A8;
end;
  uniqueness proof
    let IT1,IT2 be real-weighted real-elabeled WEVGraphSeq such that
A1: IT1.->0 = G.set(VLabelSelector, source.-->1) &
    for n being Nat holds IT1.->(n+1) = AP:Step(IT1.->n) and
A2: IT2.->0 = G.set(VLabelSelector, source.-->1) &
    for n being Nat holds IT2.->(n+1) = AP:Step(IT2.->n);
    defpred P[Nat] means IT1.$1 = IT2.$1;
    IT1.0 = IT2.->0 by A1,A2,GLIB_000:def 59; then
A3: P[0] by GLIB_000:def 59;
    now let n be Nat; assume P[n]; then
    B1: IT1.n = IT2.->n by GLIB_000:def 59;
        IT1.->(n+1) = AP:Step(IT1.->n) by A1
                   .= AP:Step(IT2.->n) by B1,GLIB_000:def 59
                   .= IT2.->(n+1) by A2; then
        IT1.(n+1) = IT2.->(n+1) by GLIB_000:def 59;
        hence P[n+1] by GLIB_000:def 59;
    end; then
A4: for n being Nat st P[n] holds P[n+1];
    for n being Nat holds P[n] from NAT_1:sch 1(A3,A4); then
    for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;  
  end;
end;

registration let G be finite real-weighted real-elabeled WEGraph,
               source be Vertex of G;
  cluster AP:CompSeq(G,source) -> finite;
  coherence proof
    set CS = AP:CompSeq(G,source);
    defpred P[Nat] means CS.->$1 is finite;
    CS.->0 = G.set(VLabelSelector,source.-->1) &
    for n being Nat holds CS.->(n+1) = AP:Step(CS.->n) by dAPCS; then
A2: P[0];
A3: now let n be Nat; assume
     P[n]; then
        reconsider Gn = CS.->n as finite real-weighted real-elabeled WEVGraph;
        CS.->(n+1) = AP:Step(Gn) by dAPCS;
        hence P[n+1];
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A2,A3);
    hence thesis by GLIB_000:def 60;
  end;
end;

theorem tAPCS01: ::tAPCS01
  for G being real-weighted real-elabeled WEGraph,
      source being Vertex of G holds
     G == AP:CompSeq(G,source).->0 &
     the_Weight_of G = the_Weight_of (AP:CompSeq(G,source).->0) &
     the_ELabel_of G = the_ELabel_of (AP:CompSeq(G,source).->0) &
     (AP:CompSeq(G,source).->0).labeledV() = {source} proof
    let G be real-weighted real-elabeled WEGraph, source be Vertex of G;
    set G0 = AP:CompSeq(G,source).->0;
A1: G0 = G.set(VLabelSelector, source .--> 1) by dAPCS;
    hence G == G0 by GLIB_003:8;
    thus the_Weight_of G = the_Weight_of G0 by A1,GLIB_003:13;
    thus the_ELabel_of G = the_ELabel_of G0 by A1,GLIB_003:14;
A3: the_VLabel_of G0 = G0.VLabelSelector by GLIB_003:def 9
                    .= source .--> 1 by A1,GLIB_000:11;
    dom (source.-->1) = {source} by CQC_LANG:5;
    hence G0.labeledV() = {source} by A3,GLIB_003:def 23;
end;

theorem tAPCS02: ::tAPCS02
  for G being real-weighted real-elabeled WEGraph,
      source being Vertex of G, i,j being Nat
   st i <= j holds (AP:CompSeq(G,source).->i).labeledV() c=
                   (AP:CompSeq(G,source).->j).labeledV() proof
    let G be real-weighted real-elabeled WEGraph, source be Vertex of G,
        i,j be Nat; set CS = AP:CompSeq(G,source); assume
A1: i <= j;
    defpred P[Nat] means (CS.->i).labeledV() c= (CS.->(i+$1)).labeledV();
A2: P[0];
A3: now let n be Nat; set Gn = (CS.->(i+n)), Gn1 = (CS.->(i+(n+1))); 
        set Next = AP:NextBestEdges(Gn), e = choose Next; assume
    B1: P[n];
        Gn1 = (CS.->(i+n+1)); then
    B2: Gn1 = AP:Step(Gn) by dAPCS;
        now per cases;
          suppose Next = {};
            hence P[n+1] by B1,B2,dAPSTEP;
          end;
          suppose
        C1: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV(); then
            e in Next; then
        C2: (the_Source_of Gn).e in the_Vertices_of Gn by GLIB_000:6; 
            Gn1 = Gn.labelVertex((the_Source_of Gn).e, e) by B2,C1,dAPSTEP;then
            Gn.labeledV() c= Gn1.labeledV() by C2, GLIB_003:60;
            hence P[n+1] by B1,XBOOLE_1:1;                       
          end;
          suppose
        C1: Next <> {} & (the_Source_of Gn).e in Gn.labeledV(); then
            e in Next; then
        C2: (the_Target_of Gn).e in the_Vertices_of Gn by GLIB_000:6;
            Gn1 = Gn.labelVertex((the_Target_of Gn).e, e) by B2,C1,dAPSTEP;then
            Gn.labeledV() c= Gn1.labeledV() by C2, GLIB_003:60;
            hence P[n+1] by B1,XBOOLE_1:1;
          end;
        end;
        hence P[n+1];
    end;
A4: for n being Nat holds P[n] from NAT_1:sch 1(A2,A3);
    consider k being Nat such that
A5: j = i+k by A1,NAT_1:28;
    thus thesis by A4,A5;
end;

theorem tAPCS04: ::tAPCS04
   for G being real-weighted real-elabeled WEGraph,
       source being Vertex of G, n being Nat holds
     G == AP:CompSeq(G,source).->n &
     the_Weight_of G = the_Weight_of (AP:CompSeq(G,source).->n) &
     the_ELabel_of G = the_ELabel_of (AP:CompSeq(G,source).->n) proof
    let G be real-weighted real-elabeled WEGraph,
        source be Vertex of G; set CS = AP:CompSeq(G,source);
    defpred P[Nat] means CS.->$1 == G &
      the_Weight_of (CS.->$1) = the_Weight_of G &
      the_ELabel_of (CS.->$1) = the_ELabel_of G;
A1: P[0] by tAPCS01;
A2: now let n be Nat; assume
    B1: P[n]; set Gn = CS.->n, Gn1 = CS.->(n+1);
        set Next = AP:NextBestEdges(Gn), e = choose Next;
    B2: Gn1 = AP:Step(Gn) by dAPCS;
        now per cases;
          suppose Next = {};
            hence P[n+1] by B1,B2,dAPSTEP;
          end;
          suppose Next <> {} & not (the_Source_of Gn).e in Gn.labeledV(); then
        C1: Gn1 = Gn.labelVertex((the_Source_of Gn).e,e) by B2,dAPSTEP; then
            Gn1 == Gn by GLIB_003:47;
            hence P[n+1] by B1,C1,GLIB_003:48,GLIB_003:49,GLIB_000:88;
          end;
          suppose Next <> {} & (the_Source_of Gn).e in Gn.labeledV(); then
        C1: Gn1 = Gn.labelVertex((the_Target_of Gn).e,e) by B2,dAPSTEP; then
            Gn1 == Gn by GLIB_003:47;
            hence P[n+1] by B1,C1,GLIB_003:48,GLIB_003:49,GLIB_000:88;        
          end;
        end;
        hence P[n+1];
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis;
end;     
   
definition let G be real-weighted real-elabeled WEGraph, source be Vertex of G;
  func AP:FindAugPath(G,source) -> real-weighted real-elabeled WEVGraph equals
:dAPFAUGP: ::dAPFAUGP
    AP:CompSeq(G,source).Result();
  coherence proof
    set CS = AP:CompSeq(G,source);
    CS.Result() = CS.(CS.Lifespan()) by GLIB_000:def 58
               .= CS.->(CS.Lifespan()) by GLIB_000:def 59;
    hence thesis;
  end;
end;

theorem tAPFAP01: ::tAPFAP01
  for G being finite real-weighted real-elabeled WEGraph,
      source being Vertex of G
    holds AP:CompSeq(G,source) is halting proof
    let G be finite real-weighted real-elabeled WEGraph, source be Vertex of G;
    set CS = AP:CompSeq(G,source);
    now assume
    B1: for n being Nat holds CS.n <> CS.(n+1);
        defpred P[Nat] means card (CS.->$1).labeledV() = $1+1;
        (CS.->0).labeledV() = {source} by tAPCS01; then
    B2: P[0] by CARD_1:79;
    B3: now let n be Nat; assume
        C1: P[n];
            set Gn = CS.->n, Gn1 = CS.->(n+1);
        C2: Gn1 = AP:Step(Gn) by dAPCS;
            set Next = AP:NextBestEdges(Gn), e = choose Next;
            now per cases;
              suppose Next = {}; then
                 Gn1 = Gn by C2,dAPSTEP; then
                 Gn = CS.(n+1) by GLIB_000:def 59; then
                 CS.n = CS.(n+1) by GLIB_000:def 59;
                 hence P[n+1] by B1;
              end;
              suppose
            D1: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV(); then
            D2: Gn1 = Gn.labelVertex((the_Source_of Gn).e,e) by C2,dAPSTEP;
                e in Next by D1; then
                (the_Source_of Gn).e in the_Vertices_of Gn by GLIB_000:6;
                hence P[n+1] by C1,D1,D2,GLIB_003:61;
              end;
              suppose
              D1: Next <> {} & (the_Source_of Gn).e in Gn.labeledV(); then
              D2: Gn1 = Gn.labelVertex((the_Target_of Gn).e,e) by C2,dAPSTEP;
              D3: e in Next by D1;
                  e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
                    by D1,dAPNEXT; then
              D4: not (the_Target_of Gn).e in Gn.labeledV()
                    by D1,dBACKLABEL,dFORLABEL;
                  (the_Target_of Gn).e in the_Vertices_of Gn
                    by D3,GLIB_000:6;
                  hence P[n+1] by C1,D2,D4,GLIB_003:61;
              end;
            end;
            hence P[n+1];
        end;
    B4: for n being Nat holds P[n] from NAT_1:sch 1(B2,B3);
        set x = card the_Vertices_of G;
    B5: card (CS.->x).labeledV() = card the_Vertices_of G + 1 by B4;
        (CS.->x) == G by tAPCS04; then
        the_Vertices_of G = the_Vertices_of (CS.->x) by GLIB_000:def 36; then
        1+card the_Vertices_of G<=card the_Vertices_of G+0 by B5,CARD_1:80;
        hence contradiction by REAL_1:53;
    end;
    hence CS is halting by GLIB_000:def 56;
end;

theorem tAPCS05: ::tAPCS05
  for G being finite real-weighted real-elabeled WEGraph,
      source being Vertex of G, n being Nat, v being set
      st v in (AP:CompSeq(G,source).->n).labeledV() holds
      (the_VLabel_of (AP:CompSeq(G,source).->n)).v =
      (the_VLabel_of AP:FindAugPath(G,source)).v proof
    let G be finite real-weighted real-elabeled WEGraph,source be Vertex of G,
        n be Nat, v be set;
    set CS = AP:CompSeq(G,source), FAP = AP:FindAugPath(G,source); 
    set L = CS.Lifespan(), GL = CS.->L, GL1 = CS.->(L+1); assume
A1: v in (CS.->n).labeledV();
    defpred P[Nat] means
      for v being set st v in (CS.->n).labeledV() holds
        (the_VLabel_of (CS.->n)).v = (the_VLabel_of (CS.->(n+$1))).v;
A2: P[0];
    now let k be Nat; assume
    B1: P[k]; set Gn = CS.->(n+k), Gn1 = CS.->(n+k+1);
    B2: Gn1 = AP:Step(Gn) by dAPCS;
        set Next = AP:NextBestEdges(Gn), e = choose Next;
        now per cases;
          suppose Next = {}; then
            Gn1 = Gn by B2,dAPSTEP;
            hence P[k+1] by B1;
          end;
          suppose
        C1: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV(); then
        C2: Gn1 = Gn.labelVertex((the_Source_of Gn).e, e) by B2,dAPSTEP;
            now let v be set; assume
            D1: v in (CS.->n).labeledV(); then
            D2: (the_VLabel_of (CS.->n)).v = (the_VLabel_of Gn).v by B1;
                n <= n+k by NAT_1:29; then
                (CS.->n).labeledV() c= Gn.labeledV() by tAPCS02; then
                v <> (the_Source_of Gn).e by C1,D1;
                hence (the_VLabel_of (CS.->n)).v = (the_VLabel_of Gn1).v
                  by C2,D2,GLIB_003:50;
            end;
            hence P[k+1];
          end;
          suppose
        C1: Next <> {} & (the_Source_of Gn).e in Gn.labeledV(); then
        C2: Gn1 = Gn.labelVertex((the_Target_of Gn).e, e) by B2,dAPSTEP;
        CZ: e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by C1,dAPNEXT;
            now let v be set; assume
            D1: v in (CS.->n).labeledV(); then
            D2: (the_VLabel_of (CS.->n)).v = (the_VLabel_of Gn).v by B1;
                n <= n+k by NAT_1:29; then
                (CS.->n).labeledV() c= Gn.labeledV() by tAPCS02; then
                v <> (the_Target_of Gn).e by C1,CZ,D1,dBACKLABEL,dFORLABEL;
                hence (the_VLabel_of (CS.->n)).v = (the_VLabel_of Gn1).v
                  by C2,D2,GLIB_003:50;
            end;
            hence P[k+1];
          end;
        end;
        hence P[k+1];
    end; then
A3: for k being Nat st P[k] holds P[k+1];
A4: for k being Nat holds P[k] from NAT_1:sch 1(A2,A3);
A5: FAP = CS.Result() by dAPFAUGP
       .= CS.L by GLIB_000:def 58
       .= GL by GLIB_000:def 59;
    CS is halting by tAPFAP01; then
    CS.L = CS.(L+1) by GLIB_000:def 57; then
A6: GL = CS.(L+1) by GLIB_000:def 59
      .= GL1 by GLIB_000:def 59;
    defpred P2[Nat] means GL = CS.->(L+$1);
A7: P2[0];
A8: now let k be Nat; set Gn1 = CS.->(L+k+1); assume P2[k]; then
        Gn1 = AP:Step(GL) by dAPCS
           .= GL1 by dAPCS;
        hence P2[k+1] by A6;
    end;
A9: for k being Nat holds P2[k] from NAT_1:sch 1(A7,A8);
    now per cases;
      suppose n <= CS.Lifespan(); then consider k being Nat such that
    B1: n + k = CS.Lifespan() by NAT_1:28;
        thus thesis by A1,A4,B1,A5;
      end;
      suppose CS.Lifespan() < n; then consider k being Nat such that
    B1: CS.Lifespan() + k = n by NAT_1:28;
        thus thesis by A5,A9,B1;
      end;
    end;
    hence thesis;
end;      

definition let G be finite real-weighted real-elabeled WEGraph,
               source,sink be Vertex of G;
  func AP:GetAugPath(G,source,sink) -> vertex-distinct
                                       augmenting Path of G means :dAPGETAUG: ::dAPGETAUG
    it is_Walk_from source,sink &
    for n being even Nat st n in dom it holds
      it.n = (the_VLabel_of AP:FindAugPath(G,source)).(it.(n+1)) if
    (sink in AP:FindAugPath(G,source).labeledV()) otherwise
    it = G.walkOf(source);
  existence proof 
    set CS = AP:CompSeq(G,source), FAP = AP:FindAugPath(G,source);
A1: FAP = CS.Result() by dAPFAUGP
       .= CS.(CS.Lifespan()) by GLIB_000:def 58
       .= CS.->(CS.Lifespan()) by GLIB_000:def 59;
    defpred P[Nat] means
      for v being set st v in (CS.->$1).labeledV() holds
       ex P being vertex-distinct augmenting Path of G st
          P is_Walk_from source,v &
          P.vertices() c= (CS.->$1).labeledV() &
          for n being even Nat st n in dom P holds
            P.n = (the_VLabel_of FAP).(P.(n+1));
    now let v be set; assume v in (CS.->0).labeledV(); then
        v in {source} by tAPCS01; then
    B1: v = source by TARSKI:def 1;
        set P = G.walkOf(source);
        take P;
        thus P is_Walk_from source,v by B1,GLIB_001:14;
        P.vertices() = {source} by GLIB_001:91;
        hence P.vertices() c= (CS.->0).labeledV() by tAPCS01;
        let n be even Nat; assume n in dom P; then
    B2: 1 <= n & n <= len P by FINSEQ_3:27; then
        n < len P by REAL_1:def 5;
        hence P.n = (the_VLabel_of FAP).(P.(n+1)) by B2,GLIB_001:14;
    end; then
A2: P[0];
    now let n be Nat; assume
    B1: P[n]; set Gn = CS.->n, Gn1 = CS.->(n+1);
        set Next = AP:NextBestEdges(Gn), e = choose Next;
    B2: Gn1 = AP:Step(Gn) by dAPCS;
    B3: Gn == G & the_ELabel_of Gn = the_ELabel_of G &
          the_Weight_of Gn = the_Weight_of G by tAPCS04;
        source in {source} by TARSKI:def 1; then
    B4: source in (CS.->0).labeledV() by tAPCS01;
        0 <= n by NAT_1:18; then
    BZ: (CS.->0).labeledV() c= Gn.labeledV() by tAPCS02; 
        now per cases;
          suppose Next = {}; then
             Gn1 = Gn by B2,dAPSTEP;
            hence P[n+1] by B1;
          end;
          suppose
        C1: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV(); then
        C2: Gn1 = Gn.labelVertex((the_Source_of Gn).e, e) by B2,dAPSTEP;
        CZ: e in Next by C1;
            e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by C1,dAPNEXT; then
        C3: (the_Target_of Gn).e in Gn.labeledV() &
              0 < (the_ELabel_of Gn).e by C1,dFORLABEL,dBACKLABEL;
        CY: (the_Source_of Gn).e in the_Vertices_of Gn by CZ,GLIB_000:6; then
        C4: Gn1.labeledV() = Gn.labeledV() \/ {(the_Source_of Gn).e}
              by C2,GLIB_003:59;
            now let v be set; assume
            D1: v in Gn1.labeledV();
                now per cases by D1,C4,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV(); then consider P being
                      vertex-distinct augmenting Path of G such that
                E1: P is_Walk_from source,v & P.vertices() c= Gn.labeledV() &
                    for n being even Nat st n in dom P holds
                    P.n = (the_VLabel_of FAP).(P.(n+1)) by B1;
                    take P;
                    n <= n+1 by NAT_1:29; then
                    Gn.labeledV() c= Gn1.labeledV() by tAPCS02;
                    hence P is_Walk_from source,v &
                      P.vertices()c= Gn1.labeledV() &
                      for n being even Nat st n in dom P holds
                        P.n = (the_VLabel_of FAP).(P.(n+1)) by E1,XBOOLE_1:1;
                  end;
                  suppose
                E0: v in {(the_Source_of Gn).e}; then
                E1: v = (the_Source_of Gn).e by TARSKI:def 1;
                    now per cases;
                      suppose
                    F1: source = (the_Target_of Gn).e;
                        set W2 = G.walkOf(source,e,(the_Source_of Gn).e);
                        e Joins source,(the_Source_of Gn).e,Gn
                          by CZ,F1,GLIB_000:def 15; then
                    F2: e Joins source,(the_Source_of Gn).e,G
                          by B3,GLIB_000:91; then
                    FP: W2 = <* source, e, (the_Source_of Gn).e *>
                          by GLIB_001:def 5; then
                    F3: len W2 = 3 & W2.1 = source & W2.2 = e &
                          W2.3 = (the_Source_of Gn).e by FINSEQ_1:62;
                        now let n be odd Nat; assume n < len W2; then
                            n < 2+1 by FP,FINSEQ_1:62; then
                            n <= 2*1 by NAT_1:38; then
                            n < 1+1 by REAL_1:def 5; then
                            1 <= n & n <= 1 by NAT_1:38,HEYTING3:1; then
                        G2: n = 1 by AXIOMS:21;
                            hereby assume W2.(n+1) DJoins W2.n,W2.(n+2),G; then
                                e DJoins source,(the_Source_of Gn).e,Gn
                                  by F3,G2,B3,GLIB_000:91;
                                hence (the_ELabel_of G).(W2.(n+1)) <
                                  (the_Weight_of G).(W2.(n+1))
                                  by C1,C3,GLIB_000:def 16;
                            end;
                            assume not W2.(n+1) DJoins W2.n,W2.(n+2),G;
                            thus 0 < (the_ELabel_of G).(W2.(n+1))
                              by B3,C3,FP,FINSEQ_1:62,G2;
                        end; then
                        reconsider W2 as augmenting Path of G by dWAUGMENT;
                    FZ: now let m be odd Nat; assume
                        G1: m <= len W2;
                        G2: 1 <= m by HEYTING3:1;
                            now assume m <> 1; then
                                2*0+1 < m by G2,REAL_1:def 5; then
                                1+2 <= m by GLIB_001:1;
                                hence m = 3 by F3,G1,AXIOMS:21;
                            end;
                            hence m = 1 or m = 3;
                        end;
                        now let m,n be odd Nat; assume
                        G1: m <= len W2 & n <= len W2 & W2.m = W2.n; then
                            (m = 1 or m = 3) & (n = 1 or n = 3) by FZ;
                            hence m = n by B4,BZ,C1,F3,G1;
                        end; then
                        reconsider W2 as vertex-distinct augmenting Path of G
                          by GLIB_001:def 29;
                        take W2;
                        thus W2 is_Walk_from source,v by E1,F2,GLIB_001:16;
                    F5: W2.vertices() = {source,v} by E1,F2,GLIB_001:92;
                        now let x be set; assume
                        G1: x in W2.vertices();
                            now per cases by F5,G1,TARSKI:def 2;
                              suppose x = source; then
                                x in {source} by TARSKI:def 1; then
                            H1: x in (CS.->0).labeledV() by tAPCS01;
                                0 <= n+1 by NAT_1:18; then
                                (CS.->0).labeledV() c= Gn1.labeledV()
                                  by tAPCS02;
                                hence x in Gn1.labeledV() by H1;
                              end;
                              suppose x = v;
                                hence x in Gn1.labeledV()
                                  by E0,C4,XBOOLE_0:def 2;
                              end;
                           end;
                           hence x in Gn1.labeledV();
                        end;
                        hence W2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                        let n be even Nat; assume
                        n in dom W2; then
                        1 <= n & n <= 3 by F3, FINSEQ_3:27; then
                        2*0+1 < n & n < 2*1+1 by REAL_1:def 5; then
                        1+1 <= n & n <= 2*1 by NAT_1:38; then
                        n = 2 by AXIOMS:21; then
                    F7: W2.n = e & W2.(n+1) = (the_Source_of Gn).e
                          by FP,FINSEQ_1:62; then
                        W2.(n+1) in {(the_Source_of Gn).e}
                          by TARSKI:def 1; then
                    F8: W2.(n+1) in Gn1.labeledV() by C4,XBOOLE_0:def 2;
                        (the_VLabel_of Gn1).(W2.(n+1)) = e
                          by F7,C2,CY,GLIB_003:46;
                        hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                          by F7,F8,tAPCS05;
                      end;
                      suppose source <> (the_Target_of Gn).e;
                        consider W being vertex-distinct
                                         augmenting Path of G such that
                    F2: W is_Walk_from source, (the_Target_of Gn).e &
                        W.vertices() c= Gn.labeledV() &
                        for n being even Nat st n in dom W holds
                          W.n = (the_VLabel_of FAP).(W.(n+1)) by B1,C3;
                        set W2 = W.addEdge(e);
                    F3: W.first() = source & W.last() = (the_Target_of Gn).e
                          by F2,GLIB_001:def 23; then
                        e Joins W.last(),(the_Source_of Gn).e,Gn
                          by CZ,GLIB_000:def 15; then
                    F5: e Joins W.last(),(the_Source_of Gn).e,G
                          by B3, GLIB_000:91;
                    F6: not (the_Source_of Gn).e in W.vertices() by C1,F2; then
                        reconsider W2 as vertex-distinct Walk of G
                          by F5,GLIB_001:156;
                        e DJoins (the_Source_of Gn).e,W.last(),Gn
                          by CZ,F3,GLIB_000:def 16; then
                        e DJoins (the_Source_of Gn).e,W.last(),G
                          by B3,GLIB_000:91; then
                        reconsider W2 as augmenting vertex-distinct Path of G
                          by B3,C3,F6,tWAUGMENT02;
                        take W2;
                        thus W2 is_Walk_from source,v by E1,F3,F5,GLIB_001:64;
                    F7: W2.vertices() = W.vertices() \/ {v}
                          by E1,F5,GLIB_001:96;
                        now let x be set; assume
                        G1: x in W2.vertices();
                            now per cases by F7,G1,XBOOLE_0:def 2;
                              suppose x in W.vertices(); then
                            H1: x in Gn.labeledV() by F2;
                                n <= n+1 by NAT_1:29; then
                                Gn.labeledV() c= Gn1.labeledV() by tAPCS02;
                                hence x in Gn1.labeledV() by H1;
                              end;
                              suppose x in {v};
                                hence x in Gn1.labeledV()
                                  by E1,C4,XBOOLE_0:def 2;
                              end;
                            end;
                            hence x in Gn1.labeledV();
                        end;
                        hence W2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                        let n be even Nat; assume
                        n in dom W2; then
                    F9: 1 <= n & n <= len W2 by FINSEQ_3:27;
                        now per cases;
                          suppose
                        G1: n <= len W; then
                        GZ: n in dom W by F9,FINSEQ_3:27; then
                        G2: W2.n = W.n by F5,GLIB_001:66;
                            n < len W by G1,REAL_1:def 5; then
                        G3: n+1 <= len W by NAT_1:38;
                            1 <= 1+n by NAT_1:29; then
                            n+1 in dom W by G3,FINSEQ_3:27; then
                            W2.(n+1) = W.(n+1) by F5,GLIB_001:66;
                            hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                              by G2,F2,GZ;
                          end;
                          suppose n > len W; then
                        G1: len W + 1 <= n by NAT_1:38;
                            n <= len W + 2*1 by F5,F9,GLIB_001:65; then
                            n < len W + 1+1 by REAL_1:def 5; then
                            n <= len W + 1 by NAT_1:38; then
                        G2: n = len W + 1 by G1,AXIOMS:21; then
                            n+1 = len W + (1+1); then
                        G4: W2.n = e & W2.(n+1) = v by E1,F5,G2,GLIB_001:66;
                        G5: v in Gn1.labeledV()
                              by C4,E0,XBOOLE_0:def 2;
                            (the_VLabel_of Gn1).v = e
                              by C2,CY,E1,GLIB_003:46;
                            hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                              by G4,G5,tAPCS05;
                          end;
                        end;
                        hence W2.n = (the_VLabel_of FAP).(W2.(n+1));
                      end;
                    end;
                    hence ex P being vertex-distinct augmenting Path of G st
                      P is_Walk_from source,v & P.vertices() c=Gn1.labeledV() &
                      for n being even Nat st n in dom P holds
                      P.n = (the_VLabel_of FAP).(P.(n+1));
                  end;
                end;
                hence ex P being vertex-distinct augmenting Path of G st
                  P is_Walk_from source,v & P.vertices() c=Gn1.labeledV() &
                  for n being even Nat st n in dom P holds
                    P.n = (the_VLabel_of FAP).(P.(n+1));
            end;
            hence P[n+1];
          end;
          suppose
        C1: Next <> {} & (the_Source_of Gn).e in Gn.labeledV(); then
        C2: Gn1 = Gn.labelVertex((the_Target_of Gn).e, e) by B2,dAPSTEP;
        CZ: e in Next by C1;
        CX: e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by C1,dAPNEXT; then
        C3: not (the_Target_of Gn).e in Gn.labeledV() &
              (the_ELabel_of Gn).e < (the_Weight_of Gn).e
              by C1,dBACKLABEL,dFORLABEL;
        CY: (the_Target_of Gn).e in the_Vertices_of Gn by CZ,GLIB_000:6; then
        C4: Gn1.labeledV() = Gn.labeledV() \/ {(the_Target_of Gn).e}
              by C2,GLIB_003:59;
            now let v be set; assume
            D1: v in Gn1.labeledV();
                now per cases by D1,C4,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV(); then
                    consider P being vertex-distinct
                                     augmenting Path of G such that
                E1: P is_Walk_from source,v & P.vertices() c= Gn.labeledV() &
                    for n being even Nat st n in dom P holds
                      P.n = (the_VLabel_of FAP).(P.(n+1)) by B1;
                    take P;
                    n <= n+1 by NAT_1:29; then
                    Gn.labeledV() c= Gn1.labeledV() by tAPCS02;
                    hence P is_Walk_from source,v &
                      P.vertices()c= Gn1.labeledV() &
                      for n being even Nat st n in dom P holds
                        P.n = (the_VLabel_of FAP).(P.(n+1)) by E1,XBOOLE_1:1;
                  end;
                  suppose
                E0: v in {(the_Target_of Gn).e}; then
                E1: v = (the_Target_of Gn).e by TARSKI:def 1;
                    now per cases;
                      suppose
                    F1: source = (the_Source_of Gn).e;
                        set W2 = G.walkOf(source,e,(the_Target_of Gn).e);
                        e Joins source,(the_Target_of Gn).e,Gn
                          by CZ,F1,GLIB_000:def 15; then
                    F2: e Joins source,(the_Target_of Gn).e,G
                          by B3,GLIB_000:91; then
                    FP: W2 = <* source, e, (the_Target_of Gn).e *>
                          by GLIB_001:def 5; then
                    F3: len W2 = 3 & W2.1 = source & W2.2 = e &
                          W2.3 = (the_Target_of Gn).e by FINSEQ_1:62; then
                        e DJoins W2.1,W2.(1+2),Gn by CZ,F1,GLIB_000:def 16;then
                    F4: e DJoins W2.1,W2.(1+2),G by B3,GLIB_000:91;
                        now let n be odd Nat; assume n < len W2; then
                            n < 2+1 by FP,FINSEQ_1:62; then
                            n <= 2*1 by NAT_1:38; then
                            n < 1+1 by REAL_1:def 5; then
                            1 <= n & n <= 1 by NAT_1:38,HEYTING3:1; then
                        G1: n = 1 by AXIOMS:21;
                            thus W2.(n+1) DJoins W2.n,W2.(n+2),G implies
                              (the_ELabel_of G).(W2.(n+1)) <
                              (the_Weight_of G).(W2.(n+1))
                              by C1,dBACKLABEL,dFORLABEL,CX,B3,G1,F3;
                            assume not W2.(n+1) DJoins W2.n,W2.(n+2),G;
                            hence 0 < (the_ELabel_of G).(W2.(n+1))
                              by FP,FINSEQ_1:62,F4,G1;
                        end; then
                        reconsider W2 as augmenting Path of G by dWAUGMENT;
                    FZ: now let m be odd Nat; assume
                        G1: m <= len W2;
                        G2: 1 <= m by HEYTING3:1;
                            now assume m <> 1; then
                                2*0+1 < m by G2,REAL_1:def 5; then
                                1+2 <= m by GLIB_001:1;
                                hence m = 3 by F3,G1,AXIOMS:21;
                            end;
                            hence m = 1 or m = 3;
                        end;
                        now let m,n be odd Nat; assume
                        G1: m <= len W2 & n <= len W2 & W2.m = W2.n; then
                            (m = 1 or m = 3) & (n = 1 or n = 3) by FZ;
                            hence m = n
                              by G1,F3,BZ,B4,CX,C1,dFORLABEL,dBACKLABEL;
                        end; then
                        reconsider W2 as vertex-distinct augmenting Path of G
                          by GLIB_001:def 29;
                        take W2;
                        thus W2 is_Walk_from source,v by E1,F2,GLIB_001:16;
                    F5: W2.vertices() = {source,v} by E1,F2,GLIB_001:92;
                        now let x be set; assume
                        G1: x in W2.vertices();
                            now per cases by F5,G1,TARSKI:def 2;
                              suppose x = source; then
                                x in {source} by TARSKI:def 1; then
                            H1: x in (CS.->0).labeledV() by tAPCS01;
                                0 <= n+1 by NAT_1:18; then
                                (CS.->0).labeledV() c= Gn1.labeledV()
                                  by tAPCS02;
                                hence x in Gn1.labeledV() by H1;
                              end;
                              suppose x = v;
                                hence x in Gn1.labeledV()
                                  by E0,C4,XBOOLE_0:def 2;
                              end;
                           end;
                           hence x in Gn1.labeledV();
                        end;
                        hence W2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                        let n be even Nat; assume
                        n in dom W2; then
                        1 <= n & n <= 3 by F3, FINSEQ_3:27; then
                        2*0+1 < n & n < 2*1+1 by REAL_1:def 5; then
                        1+1 <= n & n <= 2*1 by NAT_1:38; then
                        n = 2 by AXIOMS:21; then
                    F7: W2.n = e & W2.(n+1) = (the_Target_of Gn).e
                          by FP,FINSEQ_1:62; then
                        W2.(n+1) in {(the_Target_of Gn).e}
                          by TARSKI:def 1; then
                    F8: W2.(n+1) in Gn1.labeledV() by C4,XBOOLE_0:def 2;
                        (the_VLabel_of Gn1).(W2.(n+1)) = e
                          by F7,C2,CY,GLIB_003:46;
                        hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                          by F7,F8,tAPCS05;
                      end;
                      suppose source <> (the_Source_of Gn).e;
                        consider W being vertex-distinct
                                         augmenting Path of G such that
                    F2: W is_Walk_from source, (the_Source_of Gn).e &
                        W.vertices() c= Gn.labeledV() &
                        for n being even Nat st n in dom W holds
                          W.n = (the_VLabel_of FAP).(W.(n+1)) by B1,C1;
                        set W2 = W.addEdge(e);
                    F3: W.first() = source & W.last() = (the_Source_of Gn).e
                          by F2,GLIB_001:def 23; then
                        e Joins W.last(),(the_Target_of Gn).e,Gn
                          by CZ,GLIB_000:def 15; then
                    F5: e Joins W.last(),(the_Target_of Gn).e,G
                          by B3, GLIB_000:91;
                    F6: not (the_Target_of Gn).e in W.vertices()
                          by CX,F2,C1,dFORLABEL,dBACKLABEL; then
                        reconsider W2 as vertex-distinct Walk of G
                          by F5,GLIB_001:156;
                        e DJoins W.last(),(the_Target_of Gn).e,Gn
                          by CZ,F3,GLIB_000:def 16; then
                        e DJoins W.last(),(the_Target_of Gn).e,G
                          by B3,GLIB_000:91; then
                        reconsider W2 as vertex-distinct augmenting Path of G
                          by B3,C3,F6,tWAUGMENT02;
                        take W2;
                        thus W2 is_Walk_from source,v by E1,F3,F5,GLIB_001:64;
                    F7: W2.vertices() = W.vertices() \/ {v}
                          by E1,F5,GLIB_001:96;
                        now let x be set; assume
                        G1: x in W2.vertices();
                            now per cases by F7,G1,XBOOLE_0:def 2;
                              suppose x in W.vertices(); then
                            H1: x in Gn.labeledV() by F2;
                                n <= n+1 by NAT_1:29; then
                                Gn.labeledV() c= Gn1.labeledV() by tAPCS02;
                                hence x in Gn1.labeledV() by H1;
                              end;
                              suppose x in {v};
                                hence x in Gn1.labeledV()
                                  by E1,C4,XBOOLE_0:def 2;
                              end;
                            end;
                            hence x in Gn1.labeledV();
                        end;
                        hence W2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                        let n be even Nat; assume
                        n in dom W2; then
                    F9: 1 <= n & n <= len W2 by FINSEQ_3:27;
                        now per cases;
                          suppose
                        G1: n <= len W; then
                        GZ: n in dom W by F9,FINSEQ_3:27; then
                        G2: W2.n = W.n by F5,GLIB_001:66;
                            n < len W by G1,REAL_1:def 5; then
                        G3: n+1 <= len W by NAT_1:38;
                            1 <= 1+n by NAT_1:29; then
                            n+1 in dom W by G3,FINSEQ_3:27; then
                            W2.(n+1) = W.(n+1) by F5,GLIB_001:66;
                            hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                              by G2,F2,GZ;
                          end;
                          suppose n > len W; then
                        G1: len W + 1 <= n by NAT_1:38;
                            n <= len W + 2*1 by F5,F9,GLIB_001:65; then
                            n < len W + 1+1 by REAL_1:def 5; then
                            n <= len W + 1 by NAT_1:38; then
                        G2: n = len W + 1 by G1,AXIOMS:21; then
                            n+1 = len W + (1+1); then
                        G4: W2.n = e & W2.(n+1) = v by E1,F5,G2,GLIB_001:66;
                        G5: v in Gn1.labeledV()
                              by C4,E0,XBOOLE_0:def 2;
                            (the_VLabel_of Gn1).v = e
                              by C2,CY,E1,GLIB_003:46;
                            hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                              by G4,G5,tAPCS05;
                          end;
                        end;
                        hence W2.n = (the_VLabel_of FAP).(W2.(n+1));
                      end;
                    end;
                    hence ex P being vertex-distinct augmenting Path of G st
                      P is_Walk_from source,v & P.vertices() c=Gn1.labeledV() &
                      for n being even Nat st n in dom P holds
                      P.n = (the_VLabel_of FAP).(P.(n+1));
                  end;
                end;
                hence ex P being vertex-distinct augmenting Path of G st
                  P is_Walk_from source,v & P.vertices() c=Gn1.labeledV() &
                  for n being even Nat st n in dom P holds
                    P.n = (the_VLabel_of FAP).(P.(n+1));
            end;
            hence P[n+1];
          end;
        end;
        hence P[n+1];
    end; then
A3: for n being Nat st P[n] holds P[n+1];
A4: for n being Nat holds P[n] from NAT_1:sch 1(A2,A3);    
    hereby assume sink in FAP.labeledV(); then
        consider W being vertex-distinct augmenting Path of G such that
    B2: W is_Walk_from source,sink & W.vertices() c= FAP.labeledV() &
        for n being even Nat st n in dom W holds
          W.n = (the_VLabel_of FAP).((W.(n+1))) by A1,A4;
        take W;
        thus W is_Walk_from source,sink &
          for n being even Nat st n in dom W holds
            W.n = (the_VLabel_of FAP).((W.(n+1))) by B2;
    end;
    thus thesis;
  end;
  uniqueness proof
    let IT1, IT2 be vertex-distinct augmenting Path of G;
    set FAP = AP:FindAugPath(G,source), CS = AP:CompSeq(G,source);
A1: FAP = CS.Result() by dAPFAUGP
       .= CS.(CS.Lifespan()) by GLIB_000:def 58
       .= CS.->(CS.Lifespan()) by GLIB_000:def 59;
    defpred P[Nat] means
      for v being set, P1,P2 being vertex-distinct augmenting Path of G st
        v in (CS.->$1).labeledV() &
        P1 is_Walk_from source,v &
        P2 is_Walk_from source,v &
        (for n being even Nat st n in dom P1 holds
           P1.n = (the_VLabel_of FAP).(P1.(n+1))) &
        (for n being even Nat st n in dom P2 holds
           P2.n = (the_VLabel_of FAP).(P2.(n+1))) holds P1 = P2;
    set G0 = CS.->0;           
    now let v be set, P1,P2 be vertex-distinct augmenting Path of G; assume
    B1: v in G0.labeledV() &
        P1 is_Walk_from source,v &
        P2 is_Walk_from source,v &
        (for n being even Nat st n in dom P1 holds
          P1.n = (the_VLabel_of FAP).(P1.(n+1))) &
        (for n being even Nat st n in dom P2 holds
          P2.n = (the_VLabel_of FAP).(P2.(n+1)));
        v in {source} by B1,tAPCS01; then
        v = source by TARSKI:def 1; then
    B3: P1.(2*0+1) = v & P1.(len P1) = v & P2.(2*0+1) = v & P2.(len P2) = v
          by B1,GLIB_001:18;
        1 <= len P1 & 1 <= len P2 by HEYTING3:1; then
        len P1 = 1 & len P2 = 1 by B3, GLIB_001:def 29; then
        P1 = <*v*> & P2 = <*v*> by B3,FINSEQ_1:57;
        hence P1 = P2;
    end; then
A2: P[0];
    now let n be Nat; assume
    B1: P[n]; set Gn = CS.->n, Gn1 = CS.->(n+1);
    B2: Gn1 = AP:Step(Gn) by dAPCS;
    B3: G == Gn by tAPCS04;
        set Next = AP:NextBestEdges(Gn), e = choose Next;
        now per cases;
          suppose Next = {}; then
            Gn1 = Gn by B2,dAPSTEP;
            hence P[n+1] by B1;
          end;
          suppose
        C1: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV(); then
        C2: Gn1 = Gn.labelVertex((the_Source_of Gn).e,e) by B2,dAPSTEP;
        C3: e in Next by C1; then
        C4: (the_Source_of Gn).e in the_Vertices_of Gn by GLIB_000:6; then
        C5: Gn1.labeledV() = Gn.labeledV() \/ {(the_Source_of Gn).e}
              by C2,GLIB_003:59;
            e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by C1,dAPNEXT; then
        C6: (the_Target_of Gn).e in Gn.labeledV() by C1,dFORLABEL,dBACKLABEL;
            source in {source} by TARSKI:def 1; then
        C7: source in G0.labeledV() by tAPCS01;
            0 <= n by NAT_1:18; then
            G0.labeledV() c= Gn.labeledV() by tAPCS02; then
        C8: source in Gn.labeledV() by C7;
            now let v be set,P1,P2 be vertex-distinct augmenting Path of G;
                assume
            D1: v in Gn1.labeledV() & P1 is_Walk_from source,v &
                P2 is_Walk_from source,v &
                (for n being even Nat st n in dom P1 holds
                  P1.n = (the_VLabel_of FAP).(P1.(n+1))) &
                (for n being even Nat st n in dom P2 holds
                  P2.n = (the_VLabel_of FAP).(P2.(n+1))); then
            D2: P1.1 = source & P1.(len P1) = v &
                  P2.1 = source & P2.(len P2) = v by GLIB_001:18;
                now per cases by D1,C5,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV();
                     hence P1 = P2 by B1,D1;
                  end;
                  suppose
                E0: v in {(the_Source_of Gn).e}; then
                E1: v = (the_Source_of Gn).e by TARSKI:def 1;
                    v <> source by E0,C1,C8,TARSKI:def 1; then
                    P1.1 <> P1.last() & P2.1 <> P2.last() 
                      by D2,GLIB_001:def 7; then
                    P1.first() <> P1.last() & P2.first() <> P2.last()
                      by GLIB_001:def 6; then
                    P1 is non trivial & P2 is non trivial by GLIB_001:128; then
                E3: 3 <= len P1 & 3 <= len P2 by GLIB_001:126; then
                    3-2 < len P1-0 & 3-2 < len P2-0 by REAL_1:92; then
                    reconsider lenP1_1 = len P1 - 1, lenP2_1 = len P2 - 1 as
                      even Nat by INT_1:18;
                E4: 3-2 <= lenP1_1 & 3-2 <= lenP2_1 by E3,REAL_1:92;
                E5: lenP1_1+1 = len P1 & lenP2_1+1 = len P2;
                EZ: lenP1_1 < len P1-0 & lenP2_1 < len P2-0 by REAL_1:92; then
                E6: lenP1_1 in dom P1 & lenP2_1 in dom P2 by E4,FINSEQ_3:27;
                    (the_VLabel_of Gn1).v = e by E1,C2,C4,GLIB_003:46; then
                    (the_VLabel_of FAP).v = e by D1,tAPCS05; then
                E7: P1.lenP1_1 = e & P2.lenP2_1 = e by D1,E5,E6,D2; then
                    consider lenP1_2 being odd Nat such that
                E8: lenP1_2 = lenP1_1 - 1 & lenP1_1-1 in dom P1 &
                      lenP1_1+1 in dom P1 & e Joins P1.lenP1_2,v,G
                      by D2,E6,GLIB_001:10;
                    e Joins (the_Target_of Gn).e,v,Gn
                      by C3,E1,GLIB_000:def 15; then
                    e Joins (the_Target_of Gn).e,v,G
                      by B3,GLIB_000:91; then
                EA: P1.lenP1_2 = (the_Target_of Gn).e
                      by E1,E8,C1,C6,GLIB_000:18;
                    consider lenP2_2 being odd Nat such that
                EB: lenP2_2 = lenP2_1 - 1 & lenP2_1-1 in dom P2 &
                      lenP2_1+1 in dom P2 & e Joins P2.lenP2_2,v,G
                      by D2,E6,E7,GLIB_001:10;
                    e Joins (the_Target_of Gn).e,v,Gn
                           by C3,E1,GLIB_000:def 15; then
                     e Joins (the_Target_of Gn).e,v,G by B3,GLIB_000:91; then
                ED: P2.lenP2_2 = (the_Target_of Gn).e
                      by E1,EB,C1,C6,GLIB_000:18;
                    set P1A = P1.cut(2*0+1,lenP1_2);                      
                    set P2A = P2.cut(2*0+1,lenP2_2);
                EE: 1 <= lenP1_2 & 1 <= lenP2_2 by HEYTING3:1;
                EF: lenP1_2 < len P1 & lenP2_2 < len P2
                      by E8,EB,REAL_1:92,EZ; then
                EG: P1A is_Walk_from source,(the_Target_of Gn).e &
                      P2A is_Walk_from source,(the_Target_of Gn).e
                      by D2,EA,ED,EE,GLIB_001:38;
                EH: now let n be even Nat; assume
                    F1: n in dom P1A; then
                    F2: 1 <= n & n <= len P1A by FINSEQ_3:27;
                    F3: P1A.n = P1.n by EF,F1,GLIB_001:47;
                        n < len P1A by F2,REAL_1:def 5; then
                        1 <= n+1 & n+1 <= len P1A
                          by NAT_1:29,NAT_1:38; then
                        n+1 in dom P1A by FINSEQ_3:27; then
                    F4: P1A.(n+1) = P1.(n+1) by EF,GLIB_001:47;
                        len P1A = lenP1_2 by EF,GLIB_001:46; then
                        n <= len P1 by EF,F2,AXIOMS:22; then
                        n in dom P1 by F2,FINSEQ_3:27;
                        hence P1A.n = (the_VLabel_of FAP).(P1A.(n+1))
                          by D1,F3,F4;
                    end;
                EI: now let n be even Nat; assume
                    F1: n in dom P2A; then
                    F2: 1 <= n & n <= len P2A by FINSEQ_3:27;
                    F3: P2A.n = P2.n by EF,F1,GLIB_001:47;
                        n < len P2A by F2,REAL_1:def 5; then
                        1 <= n+1 & n+1 <= len P2A
                          by NAT_1:29,NAT_1:38; then
                        n+1 in dom P2A by FINSEQ_3:27; then
                    F4: P2A.(n+1) = P2.(n+1) by EF,GLIB_001:47;
                        len P2A = lenP2_2 by EF,GLIB_001:46; then
                        n <= len P2 by EF,F2,AXIOMS:22; then
                        n in dom P2 by F2,FINSEQ_3:27;
                        hence P2A.n = (the_VLabel_of FAP).(P2A.(n+1))
                          by D1,F3,F4;
                    end;
                EK: lenP1_2 + 1 = lenP1_1 & lenP2_2 + 1 = lenP2_1
                      by E8,EB;
                    lenP1_2+(1+1) = len P1 & lenP2_2+(1+1) = len P2
                      by E8,EB; then
                EL: P1.cut(lenP1_2,len P1) =
                     G.walkOf((the_Target_of Gn).e,e,v) &
                    P2.cut(lenP2_2,len P2) =
                     G.walkOf((the_Target_of Gn).e,e,v)
                       by D2,EA,ED,E7,EF,EK,GLIB_001:41;
                XN: P1A.append(P1.cut(lenP1_2,len P1))
                       = P1.cut(2*0+1, len P1) by EE,EF,GLIB_001:39
                      .= P1 by GLIB_001:40;
                    P2A.append(P2.cut(lenP2_2, len P2))
                      = P2.cut(2*0+1, len P2) by EE,EF,GLIB_001:39
                     .= P2 by GLIB_001:40;
                    hence P1 = P2 by B1,C6,EG,EH,EI,EL,XN;
                  end;
                end;
                hence P1 = P2;
            end;
            hence P[n+1];
          end;
          suppose
        C1: Next <> {} & (the_Source_of Gn).e in Gn.labeledV(); then
        C2: Gn1 = Gn.labelVertex((the_Target_of Gn).e,e) by B2,dAPSTEP;        
        C3: e in Next by C1; then
        C4: (the_Target_of Gn).e in the_Vertices_of Gn by GLIB_000:6; then
        C5: Gn1.labeledV() = Gn.labeledV() \/ {(the_Target_of Gn).e}
              by C2,GLIB_003:59;
            e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by C1,dAPNEXT; then
        C6: not (the_Target_of Gn).e in Gn.labeledV()
              by C1,dBACKLABEL,dFORLABEL;
            source in {source} by TARSKI:def 1; then
        C7: source in G0.labeledV() by tAPCS01;
            0 <= n by NAT_1:18; then
            G0.labeledV() c= Gn.labeledV() by tAPCS02; then
        C8: source in Gn.labeledV() by C7;
            now let v be set,P1,P2 be vertex-distinct augmenting Path of G;
                assume
            D1: v in Gn1.labeledV() & P1 is_Walk_from source,v &
                P2 is_Walk_from source,v &
                (for n being even Nat st n in dom P1 holds
                  P1.n = (the_VLabel_of FAP).(P1.(n+1))) &
                (for n being even Nat st n in dom P2 holds
                  P2.n = (the_VLabel_of FAP).(P2.(n+1))); then
            D2: P1.1 = source & P1.(len P1) = v &
                  P2.1 = source & P2.(len P2) = v by GLIB_001:18;
                now per cases by D1,C5,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV();
                     hence P1 = P2 by B1,D1;
                  end;
                  suppose
                E0: v in {(the_Target_of Gn).e}; then
                E1: v = (the_Target_of Gn).e by TARSKI:def 1;
                    v <> source by E0,TARSKI:def 1,C6,C8; then
                    P1.1 <> P1.last() & P2.1 <> P2.last() 
                      by D2,GLIB_001:def 7; then
                    P1.first() <> P1.last() & P2.first() <> P2.last()
                      by GLIB_001:def 6; then
                    P1 is non trivial & P2 is non trivial by GLIB_001:128; then
                E3: 3 <= len P1 & 3 <= len P2 by GLIB_001:126; then
                    3-2 < len P1-0 & 3-2 < len P2-0 by REAL_1:92; then
                    reconsider lenP1_1 = len P1 - 1, lenP2_1 = len P2 - 1 as
                      even Nat by INT_1:18;
                E4: 3-2 <= lenP1_1 & 3-2 <= lenP2_1 by E3,REAL_1:92;
                E5: lenP1_1+1 = len P1 & lenP2_1+1 = len P2;
                EZ: lenP1_1 < len P1-0 & lenP2_1 < len P2-0 by REAL_1:92; then
                E6: lenP1_1 in dom P1 & lenP2_1 in dom P2 by E4,FINSEQ_3:27;
                    (the_VLabel_of Gn1).v = e by E1,C2,C4,GLIB_003:46; then
                    (the_VLabel_of FAP).v = e by D1,tAPCS05; then
                E7: P1.lenP1_1 = e & P2.lenP2_1 = e by D1,E5,E6,D2; then
                    consider lenP1_2 being odd Nat such that
                E8: lenP1_2 = lenP1_1 - 1 & lenP1_1-1 in dom P1 &
                      lenP1_1+1 in dom P1 & e Joins P1.lenP1_2,v,G
                      by D2,E6,GLIB_001:10;
                    e Joins (the_Source_of Gn).e,v,Gn
                      by C3,E1,GLIB_000:def 15; then
                    e Joins (the_Source_of Gn).e,v,G
                      by B3,GLIB_000:91; then
                EA: P1.lenP1_2 = (the_Source_of Gn).e
                      by E1,E8,C1,C6,GLIB_000:18;
                    consider lenP2_2 being odd Nat such that
                EB: lenP2_2 = lenP2_1 - 1 & lenP2_1-1 in dom P2 &
                      lenP2_1+1 in dom P2 & e Joins P2.lenP2_2,v,G
                      by D2,E6,E7,GLIB_001:10;
                    e Joins (the_Source_of Gn).e,v,Gn
                      by C3,E1,GLIB_000:def 15; then
                    e Joins (the_Source_of Gn).e,v,G
                      by B3,GLIB_000:91; then
                ED: P2.lenP2_2 = (the_Source_of Gn).e
                      by E1,EB,C1,C6,GLIB_000:18;
                    set P1A = P1.cut(2*0+1,lenP1_2);                      
                    set P2A = P2.cut(2*0+1,lenP2_2);
                EE: 1 <= lenP1_2 & 1 <= lenP2_2 by HEYTING3:1;
                EF: lenP1_2 < len P1 & lenP2_2 < len P2
                      by E8,EB,REAL_1:92,EZ; then
                EG: P1A is_Walk_from source,(the_Source_of Gn).e &
                    P2A is_Walk_from source,(the_Source_of Gn).e
                      by EE,GLIB_001:38,D2,EA,ED;
                EH: now let n be even Nat; assume
                    F1: n in dom P1A; then
                    F2: 1 <= n & n <= len P1A by FINSEQ_3:27;
                    F3: P1A.n = P1.n by EF,F1,GLIB_001:47;
                        n < len P1A by F2,REAL_1:def 5; then
                        1 <= n+1 & n+1 <= len P1A
                          by NAT_1:29,NAT_1:38; then
                        n+1 in dom P1A by FINSEQ_3:27; then
                    F4: P1A.(n+1) = P1.(n+1) by EF,GLIB_001:47;
                        len P1A = lenP1_2 by EF,GLIB_001:46; then
                        n <= len P1 by EF,F2,AXIOMS:22; then
                        n in dom P1 by F2,FINSEQ_3:27;
                        hence P1A.n = (the_VLabel_of FAP).(P1A.(n+1))
                          by D1,F3,F4;
                    end;
                EI: now let n be even Nat; assume
                    F1: n in dom P2A; then
                    F2: 1 <= n & n <= len P2A by FINSEQ_3:27;
                    F3: P2A.n = P2.n by EF,F1,GLIB_001:47;
                        n < len P2A by F2,REAL_1:def 5; then
                        1 <= n+1 & n+1 <= len P2A
                          by NAT_1:29,NAT_1:38; then
                        n+1 in dom P2A by FINSEQ_3:27; then
                    F4: P2A.(n+1) = P2.(n+1) by EF,GLIB_001:47;
                        len P2A = lenP2_2 by EF,GLIB_001:46; then
                        n <= len P2 by EF,F2,AXIOMS:22; then
                        n in dom P2 by F2,FINSEQ_3:27;
                        hence P2A.n = (the_VLabel_of FAP).(P2A.(n+1))
                          by D1,F3,F4;
                    end;
                EK: lenP1_2 + 1 = lenP1_1 & lenP2_2 + 1 = lenP2_1
                      by E8,EB;
                    lenP1_2+(1+1) = len P1 & lenP2_2+(1+1) = len P2
                      by EB,E8; then
                EL: P1.cut(lenP1_2,len P1) =
                       G.walkOf((the_Source_of Gn).e,e,v) &
                       P2.cut(lenP2_2,len P2) =
                       G.walkOf((the_Source_of Gn).e,e,v)
                       by D2,EA,ED,E7,EF,EK,GLIB_001:41;
                XN: P1A.append(P1.cut(lenP1_2,len P1))
                       = P1.cut(2*0+1, len P1) by EE,EF,GLIB_001:39
                      .= P1 by GLIB_001:40;
                    P2A.append(P2.cut(lenP2_2, len P2))
                      = P2.cut(2*0+1, len P2) by EE,EF,GLIB_001:39
                     .= P2 by GLIB_001:40;
                    hence P1 = P2 by B1,C1,EG,EH,EI,EL,XN;
                  end;
                end;
                hence P1 = P2;
            end;
            hence P[n+1];            
          end;
        end;
        hence P[n+1];
    end; then
A3: for n being Nat st P[n] holds P[n+1];
A4: for n being Nat holds P[n] from NAT_1:sch 1(A2,A3);
    thus (sink in FAP.labeledV() &
        (IT1 is_Walk_from source,sink &
        for n being even Nat st n in dom IT1 holds
          IT1.n = (the_VLabel_of AP:FindAugPath(G,source)).(IT1.(n+1))) &
        (IT2 is_Walk_from source,sink &
        for n being even Nat st n in dom IT2 holds
          IT2.n = (the_VLabel_of AP:FindAugPath(G,source)).(IT2.(n+1))))
        implies IT1 = IT2 by A1,A4;
    thus thesis;
  end; 
  consistency;
end;

theorem tAPCS03: ::tAPCS03
  for G being real-weighted real-elabeled WEGraph,
      source being Vertex of G, n being Nat, v being set
   st v in (AP:CompSeq(G,source).->n).labeledV() holds
     ex P being Path of G
       st P is augmenting & P is_Walk_from source,v &
       P.vertices() c= (AP:CompSeq(G,source).->n).labeledV() proof
    let G be real-weighted real-elabeled WEGraph, source be Vertex of G;
    set CS = AP:CompSeq(G,source), G0 = CS.->0;
    defpred P[Nat] means
       for v being set st v in (CS.->$1).labeledV()
       holds ex P being Path of G st
         P is augmenting & P is_Walk_from source,v &
         P.vertices() c= (CS.->$1).labeledV();
    now let v be set; assume
    B1: v in G0.labeledV();
        G == G0 by tAPCS01; then
        reconsider v'=v as Vertex of G by B1,GLIB_000:def 36;
        set P = G.walkOf(v');
        take P;
        thus P is augmenting;
        v in {source} by B1,tAPCS01; then
        v = source by TARSKI:def 1;
        hence P is_Walk_from source,v by GLIB_001:14;
        P.vertices() = {v'} by GLIB_001:91;
        hence P.vertices() c= G0.labeledV() by B1, ZFMISC_1:37;
    end; then
A1: P[0];
A2: now let n be Nat; set Gn = CS.->n, Gn1 = CS.->(n+1);
        set Next = AP:NextBestEdges(Gn), e = choose Next; assume
    B1: P[n];
    B2: Gn1 = AP:Step(Gn) by dAPCS;
        now per cases;
          suppose Next = {}; then
            Gn1 = Gn by B2, dAPSTEP;
            hence P[n+1] by B1;
          end;
          suppose
        C1: Next <> {};
            set se = (the_Source_of Gn).e, te = (the_Target_of Gn).e;
            now per cases by C1,dAPNEXT;
              suppose
            D1: e is_forward_labeling_in Gn; then
            D2: e in the_Edges_of Gn & se in Gn.labeledV() &
                not te in Gn.labeledV() &
                (the_ELabel_of Gn).e < (the_Weight_of Gn).e
                  by dFORLABEL; then
            D3: Gn1 = Gn.labelVertex(te, e) by B2,C1,dAPSTEP;
                te in the_Vertices_of Gn by D2, GLIB_000:6; then
            D4: Gn1.labeledV() = Gn.labeledV() \/ {te} by D3,GLIB_003:59; then
            DZ: Gn.labeledV() c= Gn1.labeledV() by XBOOLE_1:7;
                te in {te} by TARSKI:def 1; then
            DY: te in Gn1.labeledV() by D4, XBOOLE_0:def 2;
            DX: se in Gn1.labeledV() by D2,DZ;
                let v be set; assume
            D5: v in Gn1.labeledV();
            D8: G == Gn & the_Weight_of G = the_Weight_of Gn &
                the_ELabel_of Gn = the_ELabel_of G by tAPCS04;
                e DJoins se,te,Gn by D2,GLIB_000:def 16; then
            D7: e DJoins se,te,G by D8,GLIB_000:91;
                now per cases by D4,D5,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV(); then
                    consider P being Path of G such that
                E1: P is augmenting & P is_Walk_from source,v &
                    P.vertices() c= Gn.labeledV() by B1;
                    take P;
                    thus P is augmenting & P is_Walk_from source,v &
                       P.vertices() c= Gn1.labeledV() by DZ,E1,XBOOLE_1:1;
                  end;
                  suppose v in {te}; then
                E1: v = te by TARSKI:def 1;
                    now per cases;
                      suppose
                    F1: se = source;
                        set P = G.walkOf(se,e,te);
                        take P;
                        e Joins se,te,Gn by D2,GLIB_000:def 15; then
                    F2: e Joins se,te,G by D8,GLIB_000:91;
                        now let n be odd Nat; assume n < len P; then
                            n < 2+1 by F2,GLIB_001:15; then
                            n <= 2*1 by NAT_1:38; then
                            n < 1+1 by REAL_1:def 5; then
                            1 <= n & n <= 1 by HEYTING3:1, NAT_1:38; then
                        G2: n = 1 by AXIOMS:21;
                            P = <*se,e,te*> by F2,GLIB_001:def 5; then
                        G3: P.n = se & P.(n+1) = e & P.(n+2) = te
                              by G2,FINSEQ_1:62; then
                        G4: P.(n+1) DJoins P.n,P.(n+2),Gn
                              by D2,GLIB_000:def 16;
                            thus P.(n+1) DJoins P.n,P.(n+2),G implies
                              (the_ELabel_of G).(P.(n+1)) <
                              (the_Weight_of G).(P.(n+1))
                              by D1,D8,G3,dFORLABEL;
                            assume not P.(n+1) DJoins P.n,P.(n+2),G;
                            hence 0 < (the_ELabel_of G).(P.(n+1))
                              by G4,D8,GLIB_000:91;
                        end;
                        hence P is augmenting by dWAUGMENT;
                        thus P is_Walk_from source,v by E1,F1,F2,GLIB_001:16;
                        now let x be set; assume x in P.vertices(); then
                            x in {se,te} by F2,GLIB_001:92;
                            hence x in Gn1.labeledV() by TARSKI:def 2,DY,DX;
                        end;
                        hence P.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                      end;
                      suppose
                    F1: se <> source;
                        consider P being Path of G such that
                    F2: P is augmenting & P is_Walk_from source,se &
                          P.vertices() c= Gn.labeledV() by B1,D2;
                        set P2 = P.addEdge(e);
                        e Joins se,v,Gn by D2,E1,GLIB_000:def 15; then
                    F5: e Joins se,v,G by D8,GLIB_000:91; 
                    F6: se = P.last() by F2, GLIB_001:def 23; then
                        P.first() <> P.last() by F1,F2,GLIB_001:def 23; then
                    F7: P is open by GLIB_001:def 24;
                    F8: not v in P.vertices() by E1,F2,D1,dFORLABEL; then
                        reconsider P2 as Path of G by F5,F6,F7,GLIB_001:152;
                        take P2;
                        thus P2 is augmenting
                          by E1,D2,D8,D7,F2,F6,F8,tWAUGMENT02;
                        thus P2 is_Walk_from source,v by F2,F5,GLIB_001:67;
                        now let x be set; assume x in P2.vertices(); then
                        G1: x in P.vertices()\/{te} by E1,F5,F6,GLIB_001:96;
                            now per cases by G1, XBOOLE_0:def 2;
                              suppose x in P.vertices(); then
                                x in Gn.labeledV() by F2;
                                hence x in Gn1.labeledV() by DZ;
                              end;
                              suppose x in {te};
                                hence x in Gn1.labeledV() by D4,XBOOLE_0:def 2;
                              end;
                            end;
                            hence x in Gn1.labeledV();
                        end;
                        hence P2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                      end;
                    end;
                    hence ex P being Path of G st P is augmenting &
                      P is_Walk_from source,v & P.vertices() c= Gn1.labeledV();
                  end;
                end;
                hence ex P being Path of G st P is augmenting &
                     P is_Walk_from source,v & P.vertices() c= Gn1.labeledV();
              end;
              suppose
            D1: e is_backward_labeling_in Gn; then
            D2: e in the_Edges_of Gn & te in Gn.labeledV() &
                not se in Gn.labeledV() &
                0 < (the_ELabel_of Gn).e by dBACKLABEL; then
            D3: Gn1 = Gn.labelVertex(se, e) by B2,C1,dAPSTEP;
                se in the_Vertices_of Gn by D2, GLIB_000:6; then
            D4: Gn1.labeledV() = Gn.labeledV() \/ {se} by D3,GLIB_003:59; then
            DZ: Gn.labeledV() c= Gn1.labeledV() by XBOOLE_1:7;
                se in {se} by TARSKI:def 1; then
            DY: se in Gn1.labeledV() by D4,XBOOLE_0:def 2;
            DX: te in Gn1.labeledV() by D2,DZ;
                let v be set; assume
            D5: v in Gn1.labeledV();
            D8: G == Gn & the_Weight_of G = the_Weight_of Gn &
                the_ELabel_of G = the_ELabel_of Gn by tAPCS04;
                e DJoins se,te,Gn by D2,GLIB_000:def 16; then
            D7: e DJoins se,te,G by D8,GLIB_000:91;
                now per cases by D4,D5,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV(); then
                    consider P being Path of G such that
                E1: P is augmenting & P is_Walk_from source,v &
                    P.vertices() c= Gn.labeledV() by B1;
                    take P;
                    thus P is augmenting & P is_Walk_from source,v &
                       P.vertices() c= Gn1.labeledV() by DZ,E1,XBOOLE_1:1;
                  end;
                  suppose v in {se}; then
                E1: v = se by TARSKI:def 1;
                    now per cases;
                      suppose
                    F1: te = source;
                        set P = G.walkOf(te,e,se);
                        take P;
                        e Joins te,se,Gn by D2,GLIB_000:def 15; then
                    F2: e Joins te,se,G by D8,GLIB_000:91;
                        now let n be odd Nat; assume n < len P; then
                            n < 2+1 by F2,GLIB_001:15; then
                            n <= 2*1 by NAT_1:38; then
                            n < 1+1 by REAL_1:def 5; then
                            1 <= n & n <= 1 by HEYTING3:1, NAT_1:38; then
                        G2: n = 1 by AXIOMS:21;
                            P = <*te,e,se*> by F2,GLIB_001:def 5; then
                        G3: P.n = te & P.(n+1) = e & P.(n+2) = se
                              by G2,FINSEQ_1:62; 
                            hereby assume P.(n+1) DJoins P.n,P.(n+2),G; then
                                e DJoins te,se,Gn by G3,D8,GLIB_000:91;
                                hence (the_ELabel_of G).(P.(n+1)) <
                                      (the_Weight_of G).(P.(n+1))
                                      by D2,GLIB_000:def 16;
                            end;
                            assume not P.(n+1) DJoins P.n,P.(n+2),G;
                            thus 0 < (the_ELabel_of G).(P.(n+1))
                              by D1,D8,G3,dBACKLABEL;
                        end;
                        hence P is augmenting by dWAUGMENT;
                        thus P is_Walk_from source,v by E1,F1,F2,GLIB_001:16;
                        now let x be set; assume x in P.vertices(); then
                            x in {se,te} by F2,GLIB_001:92;
                            hence x in Gn1.labeledV() by TARSKI:def 2,DY,DX;
                        end;
                        hence P.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                      end;
                      suppose
                    F1: te <> source;
                        consider P being Path of G such that
                    F2: P is augmenting & P is_Walk_from source,te &
                          P.vertices() c= Gn.labeledV() by B1,D2;
                        set P2 = P.addEdge(e);
                        e Joins te,v,Gn by D2,E1,GLIB_000:def 15; then
                    F5: e Joins te,v,G by D8,GLIB_000:91;
                    F6: te = P.last() by F2, GLIB_001:def 23; then
                        P.first() <> P.last() by F1,F2,GLIB_001:def 23; then
                    F7: P is open by GLIB_001:def 24;
                    F8: not v in P.vertices() by D1,dBACKLABEL,E1,F2; then
                        reconsider P2 as Path of G by F5,F6,F7,GLIB_001:152;
                        take P2;
                        thus P2 is augmenting
                          by D2,D8,E1,D7,F2,F6,F8,tWAUGMENT02;
                        thus P2 is_Walk_from source,v by F2,F5,GLIB_001:67;
                        now let x be set; assume x in P2.vertices(); then
                        G1: x in P.vertices()\/{se} by E1,F5,F6,GLIB_001:96;
                            now per cases by G1, XBOOLE_0:def 2;
                              suppose x in P.vertices(); then
                                x in Gn.labeledV() by F2;
                                hence x in Gn1.labeledV() by DZ;
                              end;
                              suppose x in {se};
                                hence x in Gn1.labeledV() by D4,XBOOLE_0:def 2;
                              end;
                            end;
                            hence x in Gn1.labeledV();
                        end;
                        hence P2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                      end;
                    end;
                    hence ex P being Path of G st P is augmenting &
                      P is_Walk_from source,v & P.vertices() c= Gn1.labeledV();
                  end;
                end;
                hence ex P being Path of G st P is augmenting &
                     P is_Walk_from source,v & P.vertices() c= Gn1.labeledV();
              end;
            end;
            hence P[n+1];
          end;
        end;
        hence P[n+1];
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis;
end;

theorem tAPFAP02: ::tAPFAP02 
  for G being finite real-weighted real-elabeled WEGraph,
      source being Vertex of G, v being set
   holds v in AP:FindAugPath(G,source).labeledV() iff 
      ex P being Path of G st
        P is augmenting & P is_Walk_from source,v proof
    let G be finite real-weighted real-elabeled WEGraph,
        source be Vertex of G, v be set;
    set CS = AP:CompSeq(G,source), V = AP:FindAugPath(G,source).labeledV();
A1: AP:FindAugPath(G,source) = CS.Result() by dAPFAUGP
                            .= CS.(CS.Lifespan()) by GLIB_000:def 58
                            .= CS.->(CS.Lifespan()) by GLIB_000:def 59;
    hereby assume v in AP:FindAugPath(G,source).labeledV(); then
        consider P being Path of G such that
    B1: P is augmenting & P is_Walk_from source,v &
        P.vertices() c= AP:FindAugPath(G,source).labeledV() by A1,tAPCS03;
        thus ex P being Path of G st
          P is augmenting & P is_Walk_from source,v by B1;
    end;
    given P being Path of G such that
A2: P is augmenting & P is_Walk_from source,v;
    now assume
    B1: not v in AP:FindAugPath(G,source).labeledV();
        defpred P[Nat] means
          $1 is odd & $1 <= len P & not P.$1 in V;
        P.(len P) = v by A2, GLIB_001:18; then
    B2: ex n being Nat st P[n] by B1;
        consider n being Nat such that
    B3: P[n] & for k being Nat st P[k] holds n <= k from NAT_1:sch 5(B2);
        P.(2*0+1) = source by A2, GLIB_001:18; then
        P.(2*0+1) in {source} by TARSKI:def 1; then
    B5: P.(2*0+1) in (CS.->0).labeledV() by tAPCS01;
        0 <= CS.Lifespan() by NAT_1:18; then
        (CS.->0).labeledV() c= V by A1,tAPCS02; then
    B7: n <> 1 by B3,B5;
        reconsider n'=n as odd Nat by B3;
        1 <= n by B3,HEYTING3:1; then
        1 < n by B7, REAL_1:def 5; then
        1+1 <= n by NAT_1:38; then
        reconsider n_2 = n'-2*1 as odd Nat by INT_1:18;
    B8: n_2 < n - 0 by REAL_1:92; then
    B9: n_2 < len P by B3, AXIOMS:22; then
    BA: P.n_2 in V by B3,B8;
        set Gn = CS.->(CS.Lifespan()), Gn1 = CS.->(CS.Lifespan()+1);
        set Next = AP:NextBestEdges(Gn), en = choose Next;
    BB: Gn1 = AP:Step(Gn) by dAPCS;
        AP:CompSeq(G,source) is halting by tAPFAP01; then
        CS.(CS.Lifespan()) = CS.(CS.Lifespan()+1) by GLIB_000:def 57; then
        Gn = CS.(CS.Lifespan()+1) by GLIB_000:def 59; then
    BC: Gn1 = Gn by GLIB_000:def 59;
        set e = P.(n_2+1);
    BD: P.(n_2+2) = P.n;
    BF: G == Gn &
        the_ELabel_of G = the_ELabel_of Gn &
        the_Weight_of G = the_Weight_of Gn by tAPCS04; then
    BE: the_Edges_of G = the_Edges_of Gn &
        the_Source_of G = the_Source_of Gn &
        the_Target_of G = the_Target_of Gn by GLIB_000:def 36;
    BG: e Joins P.n_2, P.n, G by BD,B9,GLIB_001:def 3; 
    Ba: now per cases;
          suppose
        C1: e DJoins P.n_2, P.n, G; then
        CZ: (the_ELabel_of G).e<(the_Weight_of G).e by A2,B9,BD,dWAUGMENT; 
        C2: e in the_Edges_of Gn & (the_Source_of Gn).e in Gn.labeledV() &
              not (the_Target_of Gn).e in Gn.labeledV()
              by A1,BA,B3,BE,C1,GLIB_000:def 16;
            e is_forward_labeling_in Gn by C2, CZ, dFORLABEL,BF;
            hence Next <> {} by dAPNEXT;
          end;
          suppose
        C1: not e DJoins P.n_2,P.n, G; then
        CZ: 0 < (the_ELabel_of G).e by A2,B9,BD,dWAUGMENT;
            e DJoins P.n,P.n_2,G by C1,BG,GLIB_000:19; then
            e in the_Edges_of Gn & not (the_Source_of Gn).e in Gn.labeledV() &
              (the_Target_of Gn).e in Gn.labeledV()
              by A1,BA,B3,GLIB_000:def 16,BE; then
            e is_backward_labeling_in Gn by CZ,dBACKLABEL,BF;
            hence Next <> {} by dAPNEXT;
          end;
        end; 
        en in Next by Ba; then
    BF: (the_Source_of Gn).en in the_Vertices_of Gn &
        (the_Target_of Gn).en in the_Vertices_of Gn by GLIB_000:6;
        now per cases; 
          suppose
        C1: not (the_Source_of Gn).en in Gn.labeledV(); then
            Gn = Gn.labelVertex((the_Source_of Gn).en,en)
              by BB,BC,Ba,dAPSTEP; then
        C3: Gn.labeledV() = Gn.labeledV() \/ {(the_Source_of Gn).en}
              by BF,GLIB_003:59;
            (the_Source_of Gn).en in {(the_Source_of Gn).en}
              by TARSKI:def 1;
            hence contradiction by C1,C3,XBOOLE_0:def 2;
          end;
          suppose
        C1: (the_Source_of Gn).en in Gn.labeledV(); then
        C2: Gn = Gn.labelVertex((the_Target_of Gn).en,en) by BB,BC,Ba,dAPSTEP;
            en is_forward_labeling_in Gn or en is_backward_labeling_in Gn
              by Ba,dAPNEXT; then
        C3: not (the_Target_of Gn).en in Gn.labeledV()
              by C1,dBACKLABEL,dFORLABEL;
        C4: Gn.labeledV() = Gn.labeledV() \/ {(the_Target_of Gn).en}
              by BF,C2,GLIB_003:59;
            (the_Target_of Gn).en in {(the_Target_of Gn).en}
              by TARSKI:def 1;
            hence contradiction by C3,C4,XBOOLE_0:def 2;
          end;
        end;
        hence contradiction;
    end; 
    hence v in AP:FindAugPath(G,source).labeledV();
end;        

theorem tAPFAP03: ::tAPFAP03
  for G being finite real-weighted real-elabeled WEGraph,
      source being Vertex of G holds
    source in AP:FindAugPath(G,source).labeledV() &      
    G == AP:FindAugPath(G,source) &
    the_Weight_of G = the_Weight_of AP:FindAugPath(G,source) &
    the_ELabel_of G = the_ELabel_of AP:FindAugPath(G,source) proof
    let G be finite real-weighted real-elabeled WEGraph, source be Vertex of G;
    set CS = AP:CompSeq(G,source), V = AP:FindAugPath(G,source).labeledV();
A1: AP:FindAugPath(G,source) = CS.Result() by dAPFAUGP
                            .= CS.(CS.Lifespan()) by GLIB_000:def 58
                            .= CS.->(CS.Lifespan()) by GLIB_000:def 59;
    (CS.->0).labeledV() = {source} by tAPCS01; then
A2: source in (CS.->0).labeledV() by TARSKI:def 1;
    0 <= CS.Lifespan() by NAT_1:19; then
    (CS.->0).labeledV() c= AP:FindAugPath(G,source).labeledV()
      by A1,tAPCS02;
    hence source in AP:FindAugPath(G,source).labeledV() by A2;
    thus thesis by A1,tAPCS04;
end;    

begin :: Ford-Fulkerson Algorithm definitions

definition let G be real-weighted real-elabeled WEGraph,
               W be augmenting Walk of G;
  func W.flowSeq() -> FinSequence of REAL means :dWFLOWSEQ: ::dWFLOWSEQ
    dom it = dom W.edgeSeq() &
    for n being Nat st n in dom it holds
     ((W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         it.n = (the_Weight_of G).(W.(2*n)) - (the_ELabel_of G).(W.(2*n))) &
      (not W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         it.n = (the_ELabel_of G).(W.(2*n))));
  existence proof
    defpred P[Nat,set] means
     (W.(2*$1) DJoins W.(2*$1-1),W.(2*$1+1),G implies
         $2 = (the_Weight_of G).(W.(2*$1)) - (the_ELabel_of G).(W.(2*$1))) &
     (not W.(2*$1) DJoins W.(2*$1-1),W.(2*$1+1),G implies
         $2 = (the_ELabel_of G).(W.(2*$1)));
A1: for k being Nat,y1,y2 being set 
     st k in Seg len W.edgeSeq() & P[k,y1] & P[k,y2] holds y1=y2;
    now let k be Nat; assume k in Seg len W.edgeSeq();
        now per cases;
          suppose W.(2*k) DJoins W.(2*k-1),W.(2*k+1),G;
            hence ex x being set st P[k,x];
          end;
          suppose not W.(2*k) DJoins W.(2*k-1),W.(2*k+1),G;
            hence ex x being set st P[k,x];            
          end;
        end;
        hence ex x being set st P[k,x];
    end; then
A2: for k being Nat st k in Seg len W.edgeSeq()
     ex x being set st P[k,x];
    consider IT being FinSequence such that
A3: dom IT = Seg len W.edgeSeq() &
    for k being Nat st k in Seg len W.edgeSeq() holds P[k,IT.k]
      from FINSEQ_1:sch 1(A1,A2);
    now let y be set; assume y in rng IT; then consider x being set such that
    B1: x in dom IT & IT.x = y by FUNCT_1:def 5;
        reconsider x as Nat by B1;
        P[x,y] by B1,A3;
        hence y in REAL;
    end; then
    rng IT c= REAL by TARSKI:def 3; then
    reconsider IT as FinSequence of REAL by FINSEQ_1:def 4;
    take IT;
    thus dom IT = dom W.edgeSeq() by A3,FINSEQ_1:def 3;
    let n be Nat; assume n in dom IT;
    hence thesis by A3;
  end;
  uniqueness proof
    let IT1,IT2 be FinSequence of REAL such that
A1: dom IT1 = dom W.edgeSeq() &
    for n being Nat st n in dom IT1 holds
     ((W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         IT1.n = (the_Weight_of G).(W.(2*n)) - (the_ELabel_of G).(W.(2*n))) &
      (not W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         IT1.n = (the_ELabel_of G).(W.(2*n)))) and
A2: dom IT2 = dom W.edgeSeq() &
    for n being Nat st n in dom IT2 holds
     ((W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         IT2.n = (the_Weight_of G).(W.(2*n)) - (the_ELabel_of G).(W.(2*n))) &
      (not W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         IT2.n = (the_ELabel_of G).(W.(2*n))));
     now let n be Nat; assume
     B1: n in dom IT1;
         now per cases;
           suppose (W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G); then
             IT1.n = (the_Weight_of G).(W.(2*n))-(the_ELabel_of G).(W.(2*n))&
             IT2.n = (the_Weight_of G).(W.(2*n))-(the_ELabel_of G).(W.(2*n))
               by A1,A2,B1;
             hence IT1.n = IT2.n;
           end;
           suppose not (W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G); then
             IT1.n = (the_ELabel_of G).(W.(2*n)) &
             IT2.n = (the_ELabel_of G).(W.(2*n)) by A1,A2,B1;
             hence IT1.n = IT2.n;
           end;
         end;
         hence IT1.n = IT2.n;
     end;
     hence IT1 = IT2 by A1,A2,FINSEQ_1:17;
  end;
end;

definition let G be real-weighted real-elabeled WEGraph,
               W be augmenting Walk of G;
  func W.tolerance() -> Real means :dWTOLERANCE: ::dWTOLERANCE
    it in rng W.flowSeq() &
    for k being Real st k in rng W.flowSeq() holds it <= k
    if W is non trivial otherwise it = 0;
  existence proof
    set D = rng W.flowSeq();  
    hereby assume W is non trivial; then
        W.edges() <> {} by GLIB_001:137; then
        rng W.edgeSeq() <> {} by GLIB_001:def 17; then
        consider y being set such that
    B2: y in rng W.edgeSeq() by XBOOLE_0:def 1;
        consider x being set such that
    B3: x in dom W.edgeSeq() & y = W.edgeSeq().x by B2,FUNCT_1:def 5;
        x in dom W.flowSeq() by B3,dWFLOWSEQ; then
        W.flowSeq().x in D by FUNCT_1:def 5; then
        reconsider D as non empty finite Subset of REAL;
        deffunc F(Real) = $1;
        consider IT being Element of D such that
    B2: for k being Element of D holds F(IT) <= F(k) from GRAPH_5:sch 2;
        reconsider IT as Real;
        take IT;
        thus IT in rng W.flowSeq();
        let k be Real; assume k in rng W.flowSeq();
        hence IT <= k by B2;
    end;
    thus thesis;
  end;
  uniqueness proof
    let IT1,IT2 be Real;
    hereby assume W is non trivial;
        assume
    B1: IT1 in rng W.flowSeq() &
        for k being Real st k in rng W.flowSeq() holds IT1 <= k; assume
    B2: IT2 in rng W.flowSeq() &
        for k being Real st k in rng W.flowSeq() holds IT2 <= k;
        IT1 <= IT2 & IT2 <= IT1 by B1,B2;
        hence IT1 = IT2 by AXIOMS:21;
    end;
    thus thesis;
  end;
  consistency;
end;

definition let G be natural-weighted natural-elabeled WEGraph,
               W be augmenting Walk of G;
   redefine func W.tolerance() -> Nat;
  coherence proof
   set IT = W.tolerance();
   now per cases;
     suppose W is non trivial; then
       IT in rng W.flowSeq() by dWTOLERANCE; then
       consider n being Nat such that
   B1: n in dom W.flowSeq() & (W.flowSeq()).n = IT by FINSEQ_2:11;
       n in dom W.edgeSeq() by B1,dWFLOWSEQ; then
       2*n in dom W by GLIB_001:79; then
   B3: 1 <= 2*n & 2*n <= len W by FINSEQ_3:27; then
       reconsider 2n_1 = 2*n-1 as odd Nat by INT_1:18;
   B4: 2n_1 < len W - 0 by B3,REAL_1:92;
   B5: 2n_1+1 = 2*n;
   B6: 2n_1+(1+1) = 2*n+1;
       now per cases;
         suppose
       C1: W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G; then
       C2: IT = (the_Weight_of G).(W.(2*n)) - (the_ELabel_of G).(W.(2*n))
             by B1,dWFLOWSEQ;
           (the_ELabel_of G).(W.(2*n)) <
           (the_Weight_of G).(W.(2*n)) by C1,B4,B5,B6,dWAUGMENT;
           hence IT is Nat by C2,INT_1:18;
         end;
         suppose not W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G; then
           IT = (the_ELabel_of G).(W.(2*n)) by B1,dWFLOWSEQ;
           hence IT is Nat;
         end;
       end;
       hence IT is Nat;
     end;
     suppose W is trivial;
       hence IT is Nat by dWTOLERANCE;
     end;
   end;
   hence IT is Nat;
 end;
end;   

definition let G be real-weighted real-elabeled WEGraph,
               P be augmenting Path of G;
  func FF:PushFlow(G,P) -> ManySortedSet of the_Edges_of G means :dFFPUSH: ::dFFPUSH
    (for e being set st e in the_Edges_of G & not e in P.edges()
      holds it.e = (the_ELabel_of G).e) &
    (for n being odd Nat st n < len P holds
      (P.(n+1) DJoins P.n, P.(n+2),G implies
       it.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
      (not P.(n+1) DJoins P.n,P.(n+2),G implies
       it.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) - P.tolerance()));
  existence proof
    defpred P[set,set] means
      ($1 in the_Edges_of G & not $1 in P.edges()
        implies $2 = (the_ELabel_of G).$1) &
      (for n being odd Nat st n < len P & $1 = P.(n+1) holds
        ((P.(n+1) DJoins P.n,P.(n+2),G) implies
         $2 = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
        (not P.(n+1) DJoins P.n,P.(n+2),G implies
         $2 = (the_ELabel_of G).(P.(n+1)) - P.tolerance()));
    now let x,y1,y2 be set; assume
    B1: x in the_Edges_of G & P[x,y1] & P[x,y2];
        now per cases;
          suppose not x in P.edges();
            hence y1 = y2 by B1;
          end;
          suppose x in P.edges(); then consider n being odd Nat such that
        C1: n < len P & P.(n+1) = x by GLIB_001:101;
            now per cases;
              suppose (P.(n+1) DJoins P.n,P.(n+2),G); then
                y1 = (the_ELabel_of G).(P.(n+1)) + P.tolerance() &
                y2 = (the_ELabel_of G).(P.(n+1)) + P.tolerance() by B1,C1;
                hence y1 = y2;
              end;
              suppose not (P.(n+1) DJoins P.n,P.(n+2),G); then
                y1 = (the_ELabel_of G).(P.(n+1)) - P.tolerance() &
                y2 = (the_ELabel_of G).(P.(n+1)) - P.tolerance() by B1,C1;
                hence y1 = y2;
              end;
            end;
            hence y1 = y2;
          end;
        end;
        hence y1 = y2;
    end; then
A1: for x,y1,y2 being set st x in the_Edges_of G & P[x,y1] & P[x,y2]
      holds y1 = y2;
    now let x be set; assume x in the_Edges_of G;
        now per cases;
          suppose
        C1: not x in P.edges();
            set y = (the_ELabel_of G).x;
            for n being odd Nat st n < len P & x = P.(n+1) holds
              ((P.(n+1) DJoins P.n,P.(n+2),G) implies
                y = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
               (not P.(n+1) DJoins P.n,P.(n+2),G implies
                y = (the_ELabel_of G).(P.(n+1)) - P.tolerance())
                by C1,GLIB_001:101;
            hence ex y being set st P[x,y];
          end;
          suppose
        C0: x in P.edges(); then consider n being odd Nat such that
        C1: n < len P & P.(n+1) = x by GLIB_001:101;
        C2: 1 <= n+1 & n+1 <= len P by C1,NAT_1:29,NAT_1:38;
            now per cases;
              suppose
            D1: (P.(n+1) DJoins P.n,P.(n+2),G);
                set y = (the_ELabel_of G).(P.(n+1)) + P.tolerance();
                now thus x in the_Edges_of G & not x in P.edges()
                      implies y = (the_ELabel_of G).x by C0;
                    let m be odd Nat such that
                E1: m < len P & P.(m+1) = x;
                    1 <= m+1 & m+1 <= len P by E1,NAT_1:29,NAT_1:38; then
                    m+1 <= n+1 & n+1 <= m+1 by C1,C2,E1,GLIB_001:139; then
                    m+1 = n+1 by AXIOMS:21; then
                E2: m = n by XCMPLX_1:2;
                    thus P.(m+1) DJoins P.m,P.(m+2),G implies y = y;
                    assume not P.(m+1) DJoins P.m,P.(m+2),G;
                    hence y = (the_ELabel_of G).(P.(m+1)) - P.tolerance()
                      by D1,E2;
                end; then
                P[x,y] by C1;
                hence ex y being set st P[x,y];                
              end;
              suppose
            D1: not (P.(n+1) DJoins P.n,P.(n+2),G);
                set y =(the_ELabel_of G).(P.(n+1)) - P.tolerance();
                now thus x in the_Edges_of G & not x in P.edges()
                      implies y = (the_ELabel_of G).x by C0;
                    let m be odd Nat such that
                E1: m < len P & P.(m+1) = x;
                    1 <= m+1 & m+1 <= len P by E1,NAT_1:29,NAT_1:38; then
                    m+1 <= n+1 & n+1 <= m+1 by C1,C2,E1,GLIB_001:139; then
                    m+1 = n+1 by AXIOMS:21; then
                    m = n by XCMPLX_1:2;
                    hence P.(m+1) DJoins P.m,P.(m+2),G implies
                      y = (the_ELabel_of G).(P.(n+1)) + P.tolerance() by D1;
                    assume not P.(m+1) DJoins P.m,P.(m+2),G;
                    thus y = (the_ELabel_of G).(P.(n+1)) - P.tolerance();
                end; then                
                P[x,y] by C1;
                hence ex y being set st P[x,y];
              end;
            end;
            hence ex y being set st P[x,y];
          end;
        end;
        hence ex y being set st P[x,y];
    end; then
A2: for x being set st x in the_Edges_of G holds
      ex y being set st P[x,y];
    consider IT being Function such that
A3: dom IT = the_Edges_of G &
    for e being set st e in the_Edges_of G holds P[e,IT.e]
      from FUNCT_1:sch 2(A1,A2);
    reconsider IT as ManySortedSet of the_Edges_of G by A3,PBOOLE:def 3;
    take IT;
    thus for e being set st e in the_Edges_of G & not e in P.edges()
      holds IT.e = (the_ELabel_of G).e by A3;
    let n be odd Nat; assume
A4: n < len P; then
    P.(n+1) Joins P.n, P.(n+2), G by GLIB_001:def 3; then
A5: P.(n+1) in the_Edges_of G by GLIB_000:def 15;
    hence P.(n+1) DJoins P.n,P.(n+2),G implies
      IT.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) + P.tolerance() by A3,A4;
    assume not P.(n+1) DJoins P.n, P.(n+2), G;
    hence IT.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) - P.tolerance()
      by A3,A4,A5;
  end;
  uniqueness proof
    let IT1,IT2 be ManySortedSet of the_Edges_of G such that
A1: (for e being set st e in the_Edges_of G & not e in P.edges()
      holds IT1.e = (the_ELabel_of G).e) &
    (for n being odd Nat st n < len P holds
      (P.(n+1) DJoins P.n, P.(n+2),G implies
       IT1.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
      (not P.(n+1) DJoins P.n,P.(n+2),G implies
       IT1.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) - P.tolerance())) and
A2: (for e being set st e in the_Edges_of G & not e in P.edges()
      holds IT2.e = (the_ELabel_of G).e) &
    (for n being odd Nat st n < len P holds
      (P.(n+1) DJoins P.n, P.(n+2),G implies
       IT2.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
      (not P.(n+1) DJoins P.n,P.(n+2),G implies
       IT2.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) - P.tolerance()));
    now let e be set; assume
    B1: e in the_Edges_of G;
        now per cases;
          suppose not e in P.edges(); then
            IT1.e = (the_ELabel_of G).e &
            IT2.e = (the_ELabel_of G).e by A1,A2,B1;
            hence IT1.e = IT2.e;
          end;
          suppose e in P.edges(); then consider n being odd Nat such that
        C1: n < len P & P.(n+1) = e by GLIB_001:101;
            now per cases;
              suppose P.(n+1) DJoins P.n,P.(n+2),G; then
                IT1.e = (the_ELabel_of G).(P.(n+1)) + P.tolerance() &
                IT2.e = (the_ELabel_of G).(P.(n+1)) + P.tolerance()
                  by A1,A2,C1;
                hence IT1.e = IT2.e;
              end;
              suppose not P.(n+1) DJoins P.n,P.(n+2),G; then
                IT1.e = (the_ELabel_of G).(P.(n+1)) - P.tolerance() &
                IT2.e = (the_ELabel_of G).(P.(n+1)) - P.tolerance()
                  by A1,A2,C1;
                hence IT1.e = IT2.e;
              end;
            end;
            hence IT1.e = IT2.e;
          end;
        end;
        hence IT1.e = IT2.e;
    end;
    hence thesis by PBOOLE:3;
  end;
end;

registration let G be real-weighted real-elabeled WEGraph,
                 P be augmenting Path of G;
  cluster FF:PushFlow(G,P) -> real-yielding;
  coherence proof
    set F = FF:PushFlow(G,P);
    now let y be set; assume y in rng F; then
        consider e being set such that
    B1: e in dom F & F.e = y by FUNCT_1:def 5;
    B2: e in the_Edges_of G by B1,PBOOLE:def 3;
        now per cases;
          suppose not e in P.edges(); then
            y = (the_ELabel_of G).e by B1,B2,dFFPUSH;
            hence y in REAL;
          end;
          suppose e in P.edges(); then consider n being odd Nat such that
        C1: n < len P & P.(n+1) = e by GLIB_001:101;
            now per cases;
              suppose P.(n+1) DJoins P.n, P.(n+2), G; then
                y = (the_ELabel_of G).(P.(n+1))+P.tolerance() by B1,C1,dFFPUSH;
                hence y in REAL;
              end;
              suppose not P.(n+1) DJoins P.n,P.(n+2),G; then
                y = (the_ELabel_of G).(P.(n+1))-P.tolerance() by B1,dFFPUSH,C1;
                hence y in REAL;                
              end;
            end;
            hence y in REAL;
          end;
       end;
       hence y in REAL;
    end; then
    rng F c= REAL by TARSKI:def 3;
    hence F is real-yielding by SEQ_1:def 1;
  end;
end;

registration let G be natural-weighted natural-elabeled WEGraph,
                 P be augmenting Path of G;
  cluster FF:PushFlow(G,P) -> natural-yielding;
  coherence proof
    set F = FF:PushFlow(G,P);
    now let y be set; assume y in rng F; then
        consider e being set such that
    B1: e in dom F & F.e = y by FUNCT_1:def 5;
    B2: e in the_Edges_of G by B1,PBOOLE:def 3;
        now per cases;
          suppose not e in P.edges(); then
            y = (the_ELabel_of G).e by B1,B2,dFFPUSH;
            hence y in NAT;
          end;
          suppose
        C0: e in P.edges(); then consider n being odd Nat such that
        C1: n < len P & P.(n+1) = e by GLIB_001:101;
        C2: P is non trivial by GLIB_001:137, C0;
            now per cases;
              suppose P.(n+1) DJoins P.n, P.(n+2), G; then
                y = (the_ELabel_of G).(P.(n+1))+P.tolerance() by B1,C1,dFFPUSH;
                hence y in NAT;
              end;
              suppose
            D1: not P.(n+1) DJoins P.n,P.(n+2),G; then
            D2: y = (the_ELabel_of G).e-P.tolerance() by B1,dFFPUSH,C1;
                set n1div2 = (n+1) div 2;                
                1 <= n+1 & n+1 <= len P by NAT_1:29,C1,NAT_1:38; then
                n1div2 in dom P.edgeSeq() & e = P.edgeSeq().n1div2
                  by C1,GLIB_001:78;then
            D4: n1div2 in dom P.flowSeq() by dWFLOWSEQ;
                2 divides n+1 by PEPIN:22; then
            D5: 2*n1div2 = n+1 by NAT_1:49; then
            D6: 2*n1div2-1 = n;
                2*n1div2+1 = n+(1+1) by D5; then
                P.flowSeq().n1div2 = (the_ELabel_of G).e
                  by C1,D1,D4,D6,dWFLOWSEQ; then
                (the_ELabel_of G).e in rng P.flowSeq() by D4,FUNCT_1:def 5;then
                P.tolerance() <= (the_ELabel_of G).e by C2,dWTOLERANCE;
                hence y in NAT by D2,INT_1:18;
              end;
            end;
            hence y in NAT;
          end;
       end;
       hence y in NAT;
    end; then
    rng F c= NAT by TARSKI:def 3;
    hence F is natural-yielding by SEQM_3:def 8;
  end;
end;

definition let G be real-weighted real-elabeled WEGraph,
               P be augmenting Path of G;
  func FF:AugmentPath(G,P) -> real-weighted real-elabeled
                              complete-elabeled WEGraph equals :dFFAUGP: ::dFFAUGP
    G.set(ELabelSelector, FF:PushFlow(G,P));
  coherence;
end;  

registration let G be finite real-weighted real-elabeled WEGraph,
               P be augmenting Path of G;
  cluster FF:AugmentPath(G,P) -> finite;
  coherence proof
     FF:AugmentPath(G,P) = G.set(ELabelSelector,FF:PushFlow(G,P))
       by dFFAUGP;
     hence thesis;
  end;
end;  

registration let G be finite nonnegative-weighted real-elabeled WEGraph,
                 P be augmenting Path of G;
  cluster FF:AugmentPath(G,P) -> nonnegative-weighted;
  coherence proof
    FF:AugmentPath(G,P) = G.set(ELabelSelector, FF:PushFlow(G,P)) by dFFAUGP;
    hence thesis;
  end;
end;

registration let G be finite natural-weighted natural-elabeled WEGraph,
                 P be augmenting Path of G;
  cluster FF:AugmentPath(G,P) -> natural-weighted natural-elabeled;
  coherence proof
    FF:AugmentPath(G,P) = G.set(ELabelSelector,FF:PushFlow(G,P)) by dFFAUGP;
    hence thesis;
  end;
end;

definition let G be finite real-weighted
                    real-elabeled complete-elabeled WEGraph,
               sink, source be Vertex of G;
  func FF:Step(G, source, sink) -> finite real-weighted real-elabeled
                                   complete-elabeled WEGraph equals :dFFSTEP: ::dFFSTEP
    FF:AugmentPath(G, AP:GetAugPath(G,source,sink))
      if sink in AP:FindAugPath(G,source).labeledV()
    otherwise G;
  coherence;
  consistency;
end;

registration let G be finite nonnegative-weighted real-elabeled
                      complete-elabeled WEGraph, source,sink be Vertex of G;
  cluster FF:Step(G,source,sink) -> nonnegative-weighted;
  coherence proof
    set P = AP:GetAugPath(G,source,sink);
    now per cases;
      suppose sink in AP:FindAugPath(G,source).labeledV(); then
        FF:Step(G,source,sink) = FF:AugmentPath(G,P) by dFFSTEP;
        hence thesis;            
      end;
      suppose not sink in AP:FindAugPath(G,source).labeledV();
        hence thesis by dFFSTEP;
      end;
    end;
    hence thesis;
  end;
end;  

registration let G be finite natural-weighted natural-elabeled
                      complete-elabeled WEGraph, source,sink be Vertex of G;
  cluster FF:Step(G,source,sink) -> natural-weighted natural-elabeled;
  coherence proof
    set P = AP:GetAugPath(G,source,sink);
    now per cases;
      suppose sink in AP:FindAugPath(G,source).labeledV(); then
        FF:Step(G,source,sink) = FF:AugmentPath(G,P) by dFFSTEP;
        hence thesis;            
      end;
      suppose not sink in AP:FindAugPath(G,source).labeledV();
        hence thesis by dFFSTEP;
      end;
    end;
    hence thesis;
  end;
end;

definition let G be finite real-weighted WGraph,
               source,sink be Vertex of G;
  func FF:CompSeq(G,source,sink) -> finite real-weighted real-elabeled
                                    complete-elabeled
                                    WEGraphSeq means :dFFCS: ::dFFCS
    it.->0 = G.set(ELabelSelector, the_Edges_of G --> 0) &
    for n being Nat holds
      ex source',sink' being Vertex of it.->n
      st source' = source & sink' = sink &
         it.->(n+1) = FF:Step(it.->n,source',sink');
  existence proof
    defpred P[set,set,set] means
    (ex Gn being finite real-weighted real-elabeled complete-elabeled
                WEGraph, source',sink' being Vertex of Gn
     st $2 = Gn & source'=source & sink'=sink &
        $3 = FF:Step(Gn,source',sink')) or
     ((not ex Gn being finite real-weighted real-elabeled complete-elabeled
                WEGraph, source',sink' being Vertex of Gn
      st $2 = Gn & source'=source & sink'=sink) & $2 = $3);
    now let n,x be set;
        now per cases;
          suppose ex Gn being finite real-weighted real-elabeled
              complete-elabeled WEGraph, source',sink' being Vertex of Gn st
              x = Gn & source'=source & sink'=sink; then
            consider Gn being finite real-weighted real-elabeled
              complete-elabeled WEGraph, source',sink' being Vertex of Gn
              such that
        C2: x = Gn & source'=source & sink'=sink;
            set y = FF:Step(Gn,source',sink');
            P[n,x,y] by C2;
            hence ex y being set st P[n,x,y];            
          end;
          suppose not ex Gn being finite real-weighted real-elabeled
            complete-elabeled WEGraph, source',sink' being Vertex of Gn st
            x = Gn & source'=source & sink'=sink;
            hence ex y being set st P[n,x,y];
          end;
        end;
        hence ex y being set st P[n,x,y];
    end; then
A1: for n being Nat for x being set ex y being set st P[n,x,y];
A2: for n being Nat for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2]
      holds y1 = y2;
    consider IT being Function such that
A3: dom IT = NAT & IT.0 = G.set(ELabelSelector, the_Edges_of G --> 0) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
      from RECDEF_1:sch 1(A1,A2);
    reconsider IT as ManySortedSet of NAT by A3, PBOOLE:def 3;
    defpred P2[Nat] means
      ex Gn being finite real-weighted real-elabeled complete-elabeled
        WEGraph st IT.$1 = Gn & Gn == G;
    reconsider E0 = the_Edges_of G --> 0 as Function of the_Edges_of G, REAL
      by FUNCOP_1:58;
    set G0 = G.set(ELabelSelector, E0);
    G0 == G by GLIB_003:8; then
A4: P2[0] by A3;
A5: now let n be Nat; assume P2[n]; then
        consider Gn being finite real-weighted real-elabeled
          complete-elabeled WEGraph such that
    B1: IT.n = Gn & Gn == G; 
        reconsider source'=source, sink'=sink as Vertex of Gn
          by B1,GLIB_000:def 36;
    B2: P[n,Gn,IT.(n+1)] by A3,B1;
        set P = AP:GetAugPath(Gn,source',sink');
        now per cases;
           suppose sink in AP:FindAugPath(Gn,source').labeledV(); then
             IT.(n+1) = FF:AugmentPath(Gn,P) by B2,dFFSTEP
                     .= Gn.set(ELabelSelector,FF:PushFlow(Gn,P)) by dFFAUGP;
             hence FF:Step(Gn,source',sink') == Gn by B2,GLIB_003:8;
           end;
           suppose not sink in AP:FindAugPath(Gn,source').labeledV();
             hence FF:Step(Gn,source',sink') == Gn by dFFSTEP;
           end;
        end; then
        FF:Step(Gn,source',sink') == G by B1,GLIB_000:88;
        hence P2[n+1] by B2;
    end;
A6: for n being Nat holds P2[n] from NAT_1:sch 1(A4,A5);
    now let n be Nat;
        consider Gn being finite real-weighted real-elabeled
                          complete-elabeled WEGraph such that
    B1: IT.n = Gn & Gn == G by A6;
        thus IT.n is _Graph by B1;
    end; then reconsider IT as GraphSeq by GLIB_000:def 55;
A7: now let n be Nat;
        IT.->n = IT.n by GLIB_000:def 59; then
        consider Gn being finite real-weighted real-elabeled
          complete-elabeled WEGraph such that
    B2: IT.->n = Gn & Gn == G by A6;
        thus IT.->n is finite real-weighted real-elabeled
          complete-elabeled WEGraph by B2;
    end; then
    for n being Nat holds
      IT.->n is [Weighted] & IT.->n is [ELabeled]; then
    reconsider IT as WEGraphSeq by GLIB_003:def 24,GLIB_003:def 25;
    for n being Nat holds IT.->n is finite & IT.->n is real-weighted &
      IT.->n is real-elabeled & IT.->n is complete-elabeled by A7; then
    reconsider IT as finite real-weighted real-elabeled
      complete-elabeled WEGraphSeq
      by GLIB_000:def 60,GLIB_003:def 27,GLIB_003:def 29,dGSEQCELABEL;
    take IT;
    thus IT.->0 = G.set(ELabelSelector,the_Edges_of G --> 0)
      by A3,GLIB_000:def 59;
    let n be Nat;
    consider Gn being finite real-weighted real-elabeled
                      complete-elabeled WEGraph such that
A8: IT.n = Gn & Gn == G by A6;
    the_Vertices_of Gn = the_Vertices_of G by A8,GLIB_000:def 36; then
    reconsider source'=source,sink'=sink as Vertex of IT.->n
      by A8,GLIB_000:def 59;
    take source',sink';
    thus source'=source & sink'=sink;
    IT.->n is finite real-weighted real-elabeled complete-elabeled WEGraph &
    source' is Vertex of IT.->n & sink' is Vertex of IT.->n & IT.->n = Gn &
    source'=source & sink'=sink by A8,GLIB_000:def 59; then
    consider X being finite real-weighted real-elabeled complete-elabeled
      WEGraph, sourceX,sinkX being Vertex of X such that
AA: X = Gn & sourceX = source & sinkX = sink &
      IT.(n+1) = FF:Step(X,sourceX,sinkX) by A3,A8;
AB: X = IT.->n & sourceX = source' & sink'= sink by A8,AA,GLIB_000:def 59;
    thus IT.->(n+1) = FF:Step(IT.->n,source',sink') by AA,AB,GLIB_000:def 59;
  end; 
  uniqueness proof
    let IT1,IT2 be finite real-weighted real-elabeled complete-elabeled
                   WEGraphSeq such that
A1: IT1.->0 = G.set(ELabelSelector, the_Edges_of G --> 0) &
    for n being Nat holds
      ex source',sink' being Vertex of IT1.->n
      st source' = source & sink' = sink &
         IT1.->(n+1) = FF:Step(IT1.->n,source',sink') and
A2: IT2.->0 = G.set(ELabelSelector, the_Edges_of G --> 0) &
    for n being Nat holds
      ex source',sink' being Vertex of IT2.->n
      st source' = source & sink' = sink &
         IT2.->(n+1) = FF:Step(IT2.->n,source',sink');
    defpred P[Nat] means IT1.$1 = IT2.$1;
    IT1.0 = IT2.->0 by A1,A2,GLIB_000:def 59; then
A3: P[0] by GLIB_000:def 59;
A4: now let n be Nat; assume P[n]; then
        IT1.n = IT2.->n by GLIB_000:def 59; then
    B2: IT1.->n = IT2.->n by GLIB_000:def 59;
        consider source1,sink1 being Vertex of IT1.->n such that
    B3: source1=source & sink1=sink &
        IT1.->(n+1) = FF:Step(IT1.->n,source1,sink1) by A1;
        consider source2,sink2 being Vertex of IT2.->n such that
    B4: source2=source & sink2 = sink &
        IT2.->(n+1) = FF:Step(IT2.->n,source2,sink2) by A2;
        IT1.->(n+1) = IT2.(n+1) by B2,B3,B4,GLIB_000:def 59;
        hence P[n+1] by GLIB_000:def 59;
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A3,A4); then
    for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

registration let G be finite nonnegative-weighted WGraph,
                 sink, source be Vertex of G;
  cluster FF:CompSeq(G,source,sink) -> nonnegative-weighted;
  coherence proof
    set CS = FF:CompSeq(G,source,sink);
    defpred P[Nat] means CS.->$1 is nonnegative-weighted;
    CS.->0 = G.set(ELabelSelector, the_Edges_of G --> 0) by dFFCS; then
A1: P[0];
A2: now let n be Nat; assume
    B1: P[n]; set Gn = CS.->n, Gn1 = CS.->(n+1);
        reconsider Gn as finite nonnegative-weighted real-elabeled
          complete-elabeled WEGraph by B1;
        consider source',sink' being Vertex of Gn such that
    B2: source'=source & sink'=sink & Gn1 = FF:Step(Gn,source',sink')
          by dFFCS;
        thus P[n+1] by B2;
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis by GLIB_003:def 28;
  end;
end;

registration let G be finite natural-weighted WGraph,
                 sink,source be Vertex of G;
  cluster FF:CompSeq(G,source,sink) -> natural-weighted natural-elabeled;
  coherence proof
    set CS = FF:CompSeq(G,source,sink);
    defpred P[Nat] means
      CS.->$1 is natural-elabeled & CS.->$1 is natural-weighted;
    CS.->0 = G.set(ELabelSelector, the_Edges_of G --> 0) by dFFCS; then
A1: P[0];
A2: now let n be Nat; assume
    B1: P[n]; set Gn = CS.->n, Gn1 = CS.->(n+1);
        reconsider Gn as finite natural-weighted natural-elabeled
          complete-elabeled WEGraph by B1;
        consider source',sink' being Vertex of Gn such that
    B2: source'=source & sink'=sink & Gn1 = FF:Step(Gn,source',sink')
          by dFFCS;
        thus P[n+1] by B2;
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis by dGSEQNWEIGHT,dGSEQNELABEL;
  end;
end;

definition let G be finite real-weighted WGraph, sink,source be Vertex of G;
  func FF:MaxFlow(G,source, sink) -> finite real-weighted real-elabeled
                                  complete-elabeled WEGraph equals :dFFMAXFLOW: ::dFFMAXFLOW
    FF:CompSeq(G,source,sink).Result();
  coherence proof
    set CS = FF:CompSeq(G,source,sink);
    CS.Result() = CS.(CS.Lifespan()) by GLIB_000:def 58
               .= CS.->(CS.Lifespan()) by GLIB_000:def 59;
    hence thesis;               
  end;
end;

begin :: Ford Fulkerson Maximum Flow Theorems

theorem tFLOW01: :: tFLOW01
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
        source, sink being set, V being Subset of the_Vertices_of G
   st G has_valid_flow_from source,sink &
      source in V & not sink in V holds
      G.flow(source,sink) =
      Sum ((the_ELabel_of G) | G.edgesDBetween(V, the_Vertices_of G \ V)) -
      Sum ((the_ELabel_of G) | G.edgesDBetween(the_Vertices_of G \ V, V)) proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set, V be Subset of the_Vertices_of G; assume
A1: G has_valid_flow_from source,sink & source in V & not sink in V;
    set EL = the_ELabel_of G, VG = the_Vertices_of G;
    defpred P[Nat] means
      for V being Subset of VG
       st card (the_Vertices_of G \ V) = $1 & source in V & not sink in V holds
       G.flow(source,sink) =
       Sum (EL | G.edgesDBetween(V, the_Vertices_of G \ V)) -
       Sum (EL | G.edgesDBetween(the_Vertices_of G \ V, V));
    now let V be Subset of the_Vertices_of G; assume
    B1: card (the_Vertices_of G \ V) = 1 & source in V & not sink in V; then
        consider v being set such that
    B2: the_Vertices_of G \ V = {v} by CARD_2:60;
        sink is Vertex of G by A1,dVFLOW; then
        sink in the_Vertices_of G \ V by B1,XBOOLE_0:def 4; then
    B3: v = sink by B2,TARSKI:def 1;
    BZ: now let x be set;
            hereby assume x in the_Vertices_of G \ {sink}; then
                x in the_Vertices_of G & not x in {sink} by XBOOLE_0:def 4;
                hence x in V by B2,B3,XBOOLE_0:def 4;
            end;
            assume
        C1: x in V; then
            not x in {sink} by B1,TARSKI:def 1;
            hence x in the_Vertices_of G \ {sink} by C1,XBOOLE_0:def 4;
        end; then
    B4: V = the_Vertices_of G \ {sink} by TARSKI:2;
        set ESS = G.edgesDBetween({sink},{sink});
        reconsider EIN = G.edgesInto({sink}) \ ESS as Subset of the_Edges_of G
          by XBOOLE_1:1;
        reconsider EOUT= G.edgesOutOf({sink})\ ESS as Subset of the_Edges_of G
          by XBOOLE_1:1;
        set EESS = (the_ELabel_of G)|ESS;
        now let e be set;
            hereby assume e in G.edgesDBetween(V, the_Vertices_of G \ V); then
                e DSJoins the_Vertices_of G \ {sink}, {sink},G
                  by B2,B3,B4,GLIB_000:def 33; then
            D2: e in the_Edges_of G &
                (the_Source_of G).e in the_Vertices_of G \ {sink} &
                (the_Target_of G).e in {sink} by GLIB_000:def 18; then
            D3: e in G.edgesInto({sink}) by GLIB_000:def 28;
                now assume e in ESS; then
                    e DSJoins {sink},{sink},G by GLIB_000:def 33; then
                    (the_Source_of G).e in {sink} by GLIB_000:def 18;
                    hence contradiction by D2,XBOOLE_0:def 4;
                end;
                hence e in EIN by D3,XBOOLE_0:def 4;
            end;
            assume
        C0: e in EIN; then
        C1: e in G.edgesInto({sink}) & not e in ESS by XBOOLE_0:def 4;
        C2: e in the_Edges_of G & (the_Target_of G).e in {sink}
              by C0,GLIB_000:def 28;
            now assume not (the_Source_of G).e in V; then
            D1: not (the_Source_of G).e in the_Vertices_of G \ {sink}
                  by BZ;
                (the_Source_of G).e in the_Vertices_of G
                  by C0,GLIB_000:6; then
                (the_Source_of G).e in {sink}
                  by D1,XBOOLE_0:def 4; then
                e DSJoins {sink},{sink},G by C2,GLIB_000:def 18;
                hence contradiction by C1,GLIB_000:def 33;
            end; then
            e DSJoins V, {sink}, G by C2,GLIB_000:def 18;
            hence e in G.edgesDBetween(V, the_Vertices_of G \ V)
              by B2,B3,GLIB_000:def 33;
        end; then
    B5: G.edgesDBetween(V, the_Vertices_of G \ V) = EIN by TARSKI:2; 
        now let e be set; assume e in ESS; then
            e DSJoins {sink},{sink},G by GLIB_000:def 33; then
            e in the_Edges_of G & (the_Target_of G).e in {sink}
              by GLIB_000:def 18;
            hence e in G.edgesInto({sink}) by GLIB_000:def 28;
        end; then
    BZ: ESS c= G.edgesInto({sink}) by TARSKI:def 3; 
    B6: ESS \/ EIN = G.edgesInto({sink}) \/ ESS by XBOOLE_1:39
                  .= G.edgesInto({sink}) by BZ,XBOOLE_1:12;
    B7: dom (EL|G.edgesInto({sink})) = G.edgesInto({sink}) & dom (EL|ESS)=ESS &
          dom (EL|EIN)=EIN & dom (EL|EOUT)=EOUT & dom (EL|G.edgesOutOf({sink}))
          = G.edgesOutOf({sink}) by PBOOLE:def 3; then
    B8: dom (EL|ESS +* EL|EIN) = ESS \/ EIN by FUNCT_4:def 1;
        now let e be set; assume
        C1: e in dom (EL|G.edgesInto({sink})); then
        C3: e in G.edgesInto({sink}) by PBOOLE:def 3;
            now per cases;
              suppose
            D1: e in ESS; then
                not e in EIN by XBOOLE_0:def 4;
                hence (EL|ESS +* EL|EIN).e = (EL|ESS).e by B7,FUNCT_4:12
                                          .= EL.e by D1,B7,FUNCT_1:70;
                  
              end;
              suppose not e in ESS; then
            D1: e in EIN by C3,XBOOLE_0:def 4;
                hence (EL|ESS +* EL|EIN).e = (EL|EIN).e by B7,FUNCT_4:14
                                          .= EL.e by D1,B7,FUNCT_1:70;
              end;
            end;
            hence (the_ELabel_of G)|G.edgesInto({sink}).e =
              ((the_ELabel_of G)|ESS +* (the_ELabel_of G)|EIN).e
              by C1,FUNCT_1:70;
        end; then
        EL|G.edgesInto({sink}) = EL|ESS +* EL|EIN by B6,B7,B8,FUNCT_1:9; then
    B9: Sum (EL|G.edgesInto({sink})) = Sum (EL|EIN) + Sum EESS by GLIB_004:3;
        now let e be set;
            hereby assume e in G.edgesDBetween(the_Vertices_of G \ V, V); then
                e DSJoins {sink},(the_Vertices_of G \ {sink}),G
                  by B2,B3,B4,GLIB_000:def 33; then
            D2: e in the_Edges_of G & (the_Source_of G).e in {sink} &
                (the_Target_of G).e in (the_Vertices_of G \ {sink})
                  by GLIB_000:def 18; then
            D3: e in G.edgesOutOf({sink}) by GLIB_000:def 29;
                now assume e in ESS; then
                    e DSJoins {sink},{sink},G by GLIB_000:def 33; then
                    (the_Target_of G).e in {sink} by GLIB_000:def 18;
                    hence contradiction by D2,XBOOLE_0:def 4;
                end; 
                hence e in EOUT by D3,XBOOLE_0:def 4;
            end;
            assume
        C0: e in EOUT; then
        C1: e in G.edgesOutOf({sink}) & not e in ESS by XBOOLE_0:def 4;
        C2: e in the_Edges_of G & (the_Source_of G).e in {sink}
              by GLIB_000:def 29,C0;
            now assume
            D1: not (the_Target_of G).e in V;
                (the_Target_of G).e in the_Vertices_of G
                  by C0,GLIB_000:6; then
                (the_Target_of G).e in {sink} by D1,B4,XBOOLE_0:def 4; then
                e DSJoins {sink},{sink},G by C2,GLIB_000:def 18;
                hence contradiction by C1,GLIB_000:def 33;
            end; then
            e DSJoins (the_Vertices_of G \ V),V,G by C2,B2,B3,GLIB_000:def 18;
            hence e in G.edgesDBetween(the_Vertices_of G \ V, V)
              by GLIB_000:def 33;
        end; then
    BB: G.edgesDBetween(the_Vertices_of G \ V, V) = EOUT by TARSKI:2;
        now let e be set; assume e in ESS; then
            e DSJoins {sink},{sink},G by GLIB_000:def 33; then
            e in the_Edges_of G & (the_Source_of G).e in {sink}
              by GLIB_000:def 18;
            hence e in G.edgesOutOf({sink}) by GLIB_000:def 29;
        end; then
    BC: ESS c= G.edgesOutOf({sink}) by TARSKI:def 3;
        ESS \/ EOUT = G.edgesOutOf({sink}) \/ ESS by XBOOLE_1:39
                   .= G.edgesOutOf({sink}) by BC,XBOOLE_1:12; then
    BD: dom (EL|ESS +* EL|EOUT) = G.edgesOutOf({sink}) by B7,FUNCT_4:def 1;
        now let e be set; assume
        C1: e in dom (EL|G.edgesOutOf({sink})); then
        C3: e in G.edgesOutOf({sink}) by PBOOLE:def 3;
            now per cases;
              suppose
            D1: e in ESS; then
                not e in EOUT by XBOOLE_0:def 4;
                hence (EL|ESS +* EL|EOUT).e = (EL|ESS).e by B7,FUNCT_4:12
                                           .= EL.e by D1,B7,FUNCT_1:70;
              end;
              suppose not e in ESS; then
            D1: e in EOUT by C3,XBOOLE_0:def 4;
                hence (EL|ESS +* EL|EOUT).e = (EL|EOUT).e by B7,FUNCT_4:14
                                           .= EL.e by D1,B7,FUNCT_1:70;
              end;
            end;
            hence EL|G.edgesOutOf({sink}).e = (EL|ESS +* EL|EOUT).e
              by C1,FUNCT_1:70;
        end; then
        EL|G.edgesOutOf({sink}) = EL|ESS +* EL|EOUT by B7,BD,FUNCT_1:9; then
        Sum (EL|G.edgesOutOf({sink})) = Sum (EL|EOUT)+Sum EESS by GLIB_004:3;
        then
        G.flow(source,sink) = Sum (EL|EIN)+Sum EESS -(Sum EESS + Sum (EL|EOUT))
                                by A1,B9,dGFLOW
                           .= Sum (EL|EIN) - Sum (EL|EOUT);
        hence G.flow(source,sink) =
          Sum (EL | G.edgesDBetween(V, the_Vertices_of G \ V)) -
          Sum (EL | G.edgesDBetween(the_Vertices_of G \ V, V)) by B5,BB;
    end; then
A2: P[1];
A3: now let n be non empty Nat; assume
    B1: P[n];
        now let V2 be Subset of VG; assume
        C1: card (VG\V2) = n+1 & source in V2 & not sink in V2;
            set x = choose ((VG \ V2) \ {sink});
            sink is Vertex of G by A1,dVFLOW; then
            sink in (VG \ V2) by C1,XBOOLE_0:def 4; then
            {sink} c= (VG \ V2) by ZFMISC_1:37; then
            card ((VG\V2)\{sink}) = n+1-card {sink} by C1,CARD_2:63
                                 .= n+1-1 by CARD_1:79
                                 .= n; then
        C3: x in (VG)\V2 & not x in {sink} by CARD_1:78,XBOOLE_0:def 4; then
        C4: x in VG & not x in V2 by XBOOLE_0:def 4;
            set V1 = V2 \/ {x};
            set EV1_V1 = G.edgesDBetween(V1, VG \ V1);
            set E_V1V1 = G.edgesDBetween(VG \ V1, V1);           
            set EV2X   = G.edgesDBetween(V2,{x});
            set EXV2   = G.edgesDBetween({x},V2);
            set EX_V1  = G.edgesDBetween({x},VG\V1);
            set E_V1X  = G.edgesDBetween(VG\V1,{x});
            {x} c= VG by C3,ZFMISC_1:37; then
            reconsider V1 as Subset of VG by XBOOLE_1:8;
        C5: VG \ V1 = (VG \ V2) \ {x} by XBOOLE_1:41;
            {x} c= VG \ V2 by C3,ZFMISC_1:37; then
        C6: card (VG \ V1) = card (VG \ V2) - card {x} by C5,CARD_2:63
                          .= n + 1 - 1 by C1,CARD_1:79
                          .= n;
        C7: source in V1 by C1,XBOOLE_0:def 2;
        Cz: x <> sink by C3,TARSKI:def 1; then
            not sink in {x} by TARSKI:def 1; then
            not sink in V1 by C1,XBOOLE_0:def 2; then
        C9: G.flow(source,sink) = Sum (EL|EV1_V1) - Sum (EL|E_V1V1)
              by B1,C6,C7;
            now let e be set;
                hereby assume e in G.edgesDBetween(V2, VG \ V2); then
                    e DSJoins V2, VG \ V2, G by GLIB_000:def 33; then
                E2: e in the_Edges_of G & (the_Source_of G).e in V2 & 
                    (the_Target_of G).e in VG \ V2 by GLIB_000:def 18; then
                E3: (the_Source_of G).e in V1 by XBOOLE_0:def 2;
                E4: now assume e in EX_V1; then
                        e DSJoins {x},VG \ V1,G by GLIB_000:def 33; then
                        (the_Source_of G).e in {x} by GLIB_000:def 18;
                        hence contradiction by E2,C4,TARSKI:def 1;
                    end; 
                    now per cases;
                      suppose (the_Target_of G).e in {x}; then
                        e DSJoins V2,{x},G by E2,GLIB_000:def 18; then
                        e in EV2X by GLIB_000:def 33; then
                        e in EV1_V1 \/ EV2X by XBOOLE_0:def 2;
                        hence e in EV1_V1 \/ EV2X \ EX_V1 by E4,XBOOLE_0:def 4;
                      end;
                      suppose not (the_Target_of G).e in {x}; then
                        (the_Target_of G).e in VG \ V1
                          by C5,E2,XBOOLE_0:def 4; then
                        e DSJoins V1, VG \ V1, G by E2,E3,GLIB_000:def 18; then
                        e in EV1_V1 by GLIB_000:def 33; then
                        e in EV1_V1 \/ EV2X by XBOOLE_0:def 2;
                        hence e in EV1_V1 \/ EV2X \ EX_V1 by E4,XBOOLE_0:def 4;
                      end;
                    end;
                    hence e in EV1_V1 \/ EV2X \ EX_V1;
                end;
                assume
            D1: e in EV1_V1 \/ EV2X \ EX_V1; then
                e in EV1_V1 \/ EV2X & not e in EX_V1 by XBOOLE_0:def 4; then
            D3: not e DSJoins {x}, VG \ V1,G by GLIB_000:def 33;
                now per cases by D1,XBOOLE_0:def 2;
                  suppose e in EV1_V1; then
                    e DSJoins V1, VG\V1, G by GLIB_000:def 33; then
                E1: e in the_Edges_of G & (the_Source_of G).e in V1 &
                    (the_Target_of G).e in VG \ V1 by GLIB_000:def 18; then
                    not (the_Source_of G).e in {x} by D3,GLIB_000:def 18; then
                    (the_Source_of G).e in V1 \ {x} by E1,XBOOLE_0:def 4; then
                E2: (the_Source_of G).e in V2 \ {x} by XBOOLE_1:40;
                    (the_Target_of G).e in VG &
                      not (the_Target_of G).e in V1 by E1, XBOOLE_0:def 4; then
                    not (the_Target_of G).e in V2 by XBOOLE_0:def 2; then
                    (the_Target_of G).e in VG \ V2 by E1,XBOOLE_0:def 4;
                    hence e DSJoins V2, VG \ V2, G by E1,E2,GLIB_000:def 18;
                  end;
                  suppose e in EV2X; then
                    e DSJoins V2, {x}, G by GLIB_000:def 33; then
                E1: e in the_Edges_of G & (the_Source_of G).e in V2 &
                    (the_Target_of G).e in {x} by GLIB_000:def 18;
                E2: (the_Target_of G).e in VG by E1, GLIB_000:6;
                    not (the_Target_of G).e in V2 by C4,E1,TARSKI:def 1; then
                    (the_Target_of G).e in VG \ V2 by E2, XBOOLE_0:def 4;
                    hence e DSJoins V2, VG \ V2, G by E1,GLIB_000:def 18;                    
                  end;
                end;
                hence e in G.edgesDBetween(V2, VG \ V2) by GLIB_000:def 33;
            end; then
        CA: G.edgesDBetween(V2, VG \ V2) = EV1_V1 \/ EV2X \ EX_V1
              by TARSKI:2; 
            reconsider EA = EV1_V1 \/ EV2X as Subset of the_Edges_of G;
            reconsider E1 = EA \ EX_V1 as Subset of the_Edges_of G
              by XBOOLE_1:1;
            reconsider EB = EA \ EV2X as Subset of the_Edges_of G
              by XBOOLE_1:1;
            reconsider EC = E_V1V1 \/ EXV2 as Subset of the_Edges_of G;
            reconsider E2 = EC \ E_V1X as Subset of the_Edges_of G
              by XBOOLE_1:1;
            reconsider ED = EC \ EXV2 as Subset of the_Edges_of G
              by XBOOLE_1:1;
            now assume EV1_V1 meets EV2X; then
            D1: EV1_V1 /\ EV2X <> {} by XBOOLE_0:def 7;
                set e = choose (EV1_V1 /\ EV2X);
                e in EV1_V1 & e in EV2X by D1,XBOOLE_0:def 3; then
                e DSJoins V1,VG\V1,G & e DSJoins V2,{x},G
                  by GLIB_000:def 33; then
                (the_Target_of G).e in VG \ V1 &
                  (the_Target_of G).e in {x} by GLIB_000:def 18; then
                not (the_Target_of G).e in V1 &
                (the_Target_of G).e in V1 by XBOOLE_0:def 2, XBOOLE_0:def 4;
                hence contradiction;
            end; then
            EV1_V1 \ EV2X = EV1_V1 by XBOOLE_1:83; then
        CB: EB = EV1_V1 by XBOOLE_1:40;
            now assume E_V1V1 meets EXV2; then
            D1: E_V1V1 /\ EXV2 <> {} by XBOOLE_0:def 7;
                set e = choose (E_V1V1 /\ EXV2);
                e in E_V1V1 & e in EXV2 by D1,XBOOLE_0:def 3; then
                e DSJoins VG\V1,V1,G & e DSJoins {x},V2,G
                  by GLIB_000:def 33; then
                (the_Source_of G).e in VG \ V1 &
                  (the_Source_of G).e in {x} by GLIB_000:def 18; then
                not (the_Source_of G).e in V1 &
                (the_Source_of G).e in V1 by XBOOLE_0:def 2, XBOOLE_0:def 4;
                hence contradiction;
            end; then
            E_V1V1 \ EXV2 = E_V1V1 by XBOOLE_1:83; then              
        CC: ED = E_V1V1 by XBOOLE_1:40;
            now let e be set; assume e in EX_V1; then
                e DSJoins {x},VG \ V1, G by GLIB_000:def 33; then
            D1: e in the_Edges_of G & (the_Source_of G).e in {x} &
                (the_Target_of G).e in VG \ V1 by GLIB_000:def 18; then
                (the_Source_of G).e in V1 by XBOOLE_0:def 2; then
                e DSJoins V1,VG \ V1, G by D1, GLIB_000:def 18;
                hence e in EV1_V1 by GLIB_000:def 33;
            end; then
            EX_V1 c= EV1_V1 by TARSKI:def 3; then
        CE: EX_V1 c= (EV1_V1 \/ EV2X) by XBOOLE_1:10;
        CF: dom (EL|EA) = EA & dom (EL|EB) = EB & dom (EL|EX_V1) = EX_V1 &
              dom (EL|EV2X)=EV2X & dom (EL|E1)=EA \ EX_V1 by PBOOLE:def 3;then
        CG: dom (EL|EX_V1 +* EL|E1) = EX_V1 \/ (EA \ EX_V1) by FUNCT_4:def 1
                                   .= EX_V1 \/ (EV1_V1 \/ EV2X) by XBOOLE_1:39
                                   .= EA by CE,XBOOLE_1:12;
            now let e be set; assume e in dom (EL|EA); then
            D1: e in EA by PBOOLE:def 3;
                now per cases;
                  suppose not e in EX_V1; then
                E1: e in E1 by D1,XBOOLE_0:def 4;
                    hence (EL|EX_V1 +* EL|E1).e = (EL|E1).e by CF,FUNCT_4:14
                                               .= EL.e by E1,FUNCT_1:72;
                  end;
                  suppose
                E1: e in EX_V1; then
                    not e in E1 by XBOOLE_0:def 4;
                    hence (EL|EX_V1 +* EL|E1).e = (EL|EX_V1).e by CF,FUNCT_4:12
                                               .= EL.e by E1, FUNCT_1:72;
                  end;
                end;
                hence (EL|EA).e = (EL|EX_V1 +* EL|E1).e by D1,FUNCT_1:72;
            end; then
            EL|EA = EL|EX_V1 +* EL|E1 by CF,CG,FUNCT_1:9; then
            Sum (EL|EA) = Sum (EL|E1) + Sum (EL|EX_V1) by GLIB_004:3; then
        CH: Sum (EL|E1) = Sum (EL|EA) - Sum (EL|EX_V1);
        CI: dom (EL|EV2X +* EL|EB) = EV2X \/ EB by CF, FUNCT_4:def 1
                                  .= EV2X \/ (EV1_V1 \/ EV2X) by XBOOLE_1:39
                                  .= EA by XBOOLE_1:6;
            now let e be set; assume e in dom (EL|EA); then
            D1: e in EA by PBOOLE:def 3;
                now per cases;
                  suppose not e in EV2X; then
                E1: e in EB by D1,XBOOLE_0:def 4;
                    hence (EL|EV2X +* EL|EB).e = (EL|EB).e by CF,FUNCT_4:14
                                               .= EL.e by E1,FUNCT_1:72;
                  end;
                  suppose
                E1: e in EV2X; then
                    not e in EB by XBOOLE_0:def 4;
                    hence (EL|EV2X +* EL|EB).e = (EL|EV2X).e by CF,FUNCT_4:12
                                               .= EL.e by E1, FUNCT_1:72;
                  end;
                end;
                hence (EL|EA).e = (EL|EV2X +* EL|EB).e by D1,FUNCT_1:72;
            end; then
            EL|EA = EL|EV2X +* EL|EB by CF,CI,FUNCT_1:9; then
        CJ: Sum (EL|EA) = Sum (EL|EV2X) + Sum (EL|EV1_V1) by CB,GLIB_004:3;
            now let e be set; assume e in E_V1X; then
                e DSJoins VG\V1,{x}, G by GLIB_000:def 33; then
            D1: e in the_Edges_of G & (the_Target_of G).e in {x} &
                (the_Source_of G).e in VG \ V1 by GLIB_000:def 18; then
                (the_Target_of G).e in V1 by XBOOLE_0:def 2; then
                e DSJoins VG\V1,V1, G by D1, GLIB_000:def 18;
                hence e in E_V1V1 by GLIB_000:def 33;
            end; then
            E_V1X c= E_V1V1 by TARSKI:def 3; then
        CK: E_V1X c= (E_V1V1 \/ EXV2) by XBOOLE_1:10;
            now let e be set;
                hereby assume e in G.edgesDBetween(VG \ V2, V2); then
                    e DSJoins VG\V2, V2, G by GLIB_000:def 33; then
                E2: e in the_Edges_of G & (the_Target_of G).e in V2 & 
                    (the_Source_of G).e in VG \ V2 by GLIB_000:def 18; then
                E3: (the_Target_of G).e in V1 by XBOOLE_0:def 2;
                E4: now assume e in E_V1X; then
                        e DSJoins VG \ V1,{x},G by GLIB_000:def 33; then
                        (the_Target_of G).e in {x} by GLIB_000:def 18;
                        hence contradiction by E2,C4,TARSKI:def 1;
                    end; 
                    now per cases;
                      suppose (the_Source_of G).e in {x}; then
                        e DSJoins {x},V2,G by E2,GLIB_000:def 18; then
                        e in EXV2 by GLIB_000:def 33; then
                        e in E_V1V1 \/ EXV2 by XBOOLE_0:def 2;
                        hence e in E_V1V1 \/ EXV2 \ E_V1X by E4,XBOOLE_0:def 4;
                      end;
                      suppose not (the_Source_of G).e in {x}; then
                        (the_Source_of G).e in VG \ V1
                          by C5,E2,XBOOLE_0:def 4; then
                        e DSJoins VG \ V1, V1, G by E2,E3,GLIB_000:def 18; then
                        e in E_V1V1 by GLIB_000:def 33; then
                        e in E_V1V1 \/ EXV2 by XBOOLE_0:def 2;
                        hence e in E_V1V1 \/ EXV2 \ E_V1X by E4,XBOOLE_0:def 4;
                      end;
                    end;
                    hence e in E_V1V1 \/ EXV2 \ E_V1X;
                end;
                assume
            D1: e in E_V1V1 \/ EXV2 \ E_V1X; then
                e in E_V1V1 \/ EXV2 & not e in E_V1X by XBOOLE_0:def 4; then
            D3: not e DSJoins VG \ V1, {x}, G by GLIB_000:def 33;
                now per cases by D1,XBOOLE_0:def 2;
                  suppose e in E_V1V1; then
                    e DSJoins VG\V1, V1, G by GLIB_000:def 33; then
                E1: e in the_Edges_of G & (the_Target_of G).e in V1 &
                    (the_Source_of G).e in VG \ V1 by GLIB_000:def 18; then
                    not (the_Target_of G).e in {x} by D3,GLIB_000:def 18; then
                    (the_Target_of G).e in V1 \ {x} by E1,XBOOLE_0:def 4; then
                E2: (the_Target_of G).e in V2 \ {x} by XBOOLE_1:40;
                    (the_Source_of G).e in VG &
                      not (the_Source_of G).e in V1 by E1, XBOOLE_0:def 4; then
                    not (the_Source_of G).e in V2 by XBOOLE_0:def 2; then
                    (the_Source_of G).e in VG \ V2 by E1,XBOOLE_0:def 4;
                    hence e DSJoins VG \ V2, V2, G by E1,E2,GLIB_000:def 18;
                  end;
                  suppose e in EXV2; then
                    e DSJoins {x},V2, G by GLIB_000:def 33; then
                E1: e in the_Edges_of G & (the_Target_of G).e in V2 &
                    (the_Source_of G).e in {x} by GLIB_000:def 18;
                E2: (the_Source_of G).e in VG by E1, GLIB_000:6;
                    not (the_Source_of G).e in V2 by E1,C4,TARSKI:def 1; then
                    (the_Source_of G).e in VG \ V2 by E2, XBOOLE_0:def 4;
                    hence e DSJoins VG \ V2, V2, G by E1,GLIB_000:def 18;                    
                  end;
                end;
                hence e in G.edgesDBetween(VG\V2,V2) by GLIB_000:def 33;
            end; then
        CL: G.edgesDBetween(VG \ V2, V2) = E2 by TARSKI:2;
        CM: dom (EL|EC) = EC & dom (EL|ED) = ED & dom (EL|E_V1X) = E_V1X &
              dom (EL|EXV2)=EXV2 & dom (EL|E2)=EC\E_V1X by PBOOLE:def 3;then
        CN: dom (EL|E_V1X +* EL|E2) = E_V1X \/ (EC \ E_V1X) by FUNCT_4:def 1
                                   .= E_V1X \/ (E_V1V1 \/ EXV2) by XBOOLE_1:39
                                   .= EC by CK,XBOOLE_1:12;
            now let e be set; assume e in dom (EL|EC); then
            D1: e in EC by PBOOLE:def 3;
                now per cases;
                  suppose not e in E_V1X; then
                E1: e in E2 by D1,XBOOLE_0:def 4;
                    hence (EL|E_V1X +* EL|E2).e = (EL|E2).e by CM,FUNCT_4:14
                                               .= EL.e by E1,FUNCT_1:72;
                  end;
                  suppose
                E1: e in E_V1X; then
                    not e in E2 by XBOOLE_0:def 4;
                    hence (EL|E_V1X +* EL|E2).e = (EL|E_V1X).e by CM,FUNCT_4:12
                                               .= EL.e by E1, FUNCT_1:72;
                  end;
                end;
                hence (EL|EC).e = (EL|E_V1X +* EL|E2).e by D1,FUNCT_1:72;
            end; then
            EL|EC = EL|E_V1X +* EL|E2 by CM,CN,FUNCT_1:9; then
            Sum (EL|EC) = Sum (EL|E2) + Sum (EL|E_V1X) by GLIB_004:3; then
        CO: Sum (EL|E2) = Sum (EL|EC) - Sum (EL|E_V1X);
        CP: dom (EL|EXV2 +* EL|ED) = EXV2 \/ ED by CM, FUNCT_4:def 1
                                  .= EXV2 \/ (E_V1V1 \/ EXV2) by XBOOLE_1:39
                                  .= EC by XBOOLE_1:6;
            now let e be set; assume e in dom (EL|EC); then
            D1: e in EC by PBOOLE:def 3;
                now per cases;
                  suppose not e in EXV2; then
                E1: e in ED by D1,XBOOLE_0:def 4;
                    hence (EL|EXV2 +* EL|ED).e = (EL|ED).e by CM,FUNCT_4:14
                                               .= EL.e by E1,FUNCT_1:72;
                  end;
                  suppose
                E1: e in EXV2; then
                    not e in ED by XBOOLE_0:def 4;
                    hence (EL|EXV2 +* EL|ED).e = (EL|EXV2).e by CM,FUNCT_4:12
                                               .= EL.e by E1, FUNCT_1:72;
                  end;
                end;
                hence (EL|EC).e = (EL|EXV2 +* EL|ED).e by D1,FUNCT_1:72;
            end; then            
            EL|EC = EL|EXV2 +* EL|ED by CM,CP,FUNCT_1:9; then
        CQ: Sum (EL|EC) = Sum (EL|EXV2) + Sum (EL|E_V1V1) by CC,GLIB_004:3;
                       
            set EX_X = G.edgesDBetween({x}, VG \ {x});
            set E_XX = G.edgesDBetween(VG \ {x}, {x});
        Ca: now let e be set;
                hereby assume e in E_XX \ EV2X; then
                    e in E_XX & not e in EV2X by XBOOLE_0:def 4; then
                E0: e DSJoins VG \ {x}, {x}, G & not e DSJoins V2, {x}, G
                      by GLIB_000:def 33; then
                E1: e in the_Edges_of G & (the_Source_of G).e in VG \ {x} &
                    (the_Target_of G).e in {x} by GLIB_000:def 18; then
                E2: not (the_Source_of G).e in V2 by E0,GLIB_000:def 18;
                    (the_Source_of G).e in VG & not (the_Source_of G).e in {x}
                      by E1, XBOOLE_0:def 4; then
                    not (the_Source_of G).e in V1 by E2,XBOOLE_0:def 2; then
                    (the_Source_of G).e in VG \ V1 by E1, XBOOLE_0:def 4; then
                    e DSJoins VG \ V1, {x}, G by E1,GLIB_000:def 18;
                    hence e in E_V1X by GLIB_000:def 33;
                end;
                assume e in E_V1X; then
                e DSJoins VG \ V1, {x}, G by GLIB_000:def 33; then
            D1: e in the_Edges_of G & (the_Source_of G).e in VG \ V1 &
                  (the_Target_of G).e in {x} by GLIB_000:def 18; then
            D2: (the_Source_of G).e in VG & not (the_Source_of G).e in V1
                  by XBOOLE_0:def 4; then
                not (the_Source_of G).e in V2 by XBOOLE_0:def 2; then
                not e DSJoins V2,{x},G by GLIB_000:def 18; then
            D3: not e in EV2X by GLIB_000:def 33;
                not (the_Source_of G).e in {x} by D2,XBOOLE_0:def 2; then
                (the_Source_of G).e in VG \ {x} by D1,XBOOLE_0:def 4; then
                e DSJoins VG \ {x}, {x}, G by D1,GLIB_000:def 18;  then
                e in E_XX by GLIB_000:def 33;
                hence e in E_XX \ EV2X by D3, XBOOLE_0:def 4;
            end; then
        CR: E_XX \ EV2X = E_V1X by TARSKI:2;
            reconsider E_V1Xb = E_XX \ EV2X as Subset of the_Edges_of G
              by Ca, TARSKI:2;
            now let e be set; assume e in EV2X; then
                e DSJoins V2,{x},G by GLIB_000:def 33; then
            D1: e in the_Edges_of G & (the_Source_of G).e in V2 &
                  (the_Target_of G).e in {x} by GLIB_000:def 18;
                not (the_Source_of G).e in {x} by D1,C4,TARSKI:def 1; then
                (the_Source_of G).e in VG \ {x} by D1,XBOOLE_0:def 4; then
                e DSJoins VG\{x}, {x}, G by D1,GLIB_000:def 18;
                hence e in E_XX by GLIB_000:def 33;
            end; then
        CT: EV2X c= E_XX by TARSKI:def 3;
        CU: dom (EL|E_XX) = E_XX & dom (EL|EV2X) = EV2X &
              dom (EL|E_V1Xb) = E_XX \ EV2X by PBOOLE:def 3; then
        CV: dom (EL|EV2X +* EL|(E_XX \ EV2X)) = EV2X \/ (E_XX \ EV2X)
                                                  by FUNCT_4:def 1
                                             .= EV2X \/ E_XX by XBOOLE_1:39
                                             .= E_XX by CT,XBOOLE_1:12;
            now let e be set; assume
            D0: e in dom (EL|E_XX); then
            D1: e in E_XX by PBOOLE:def 3;
                now per cases;
                  suppose
                E1: e in EV2X; then
                    not e in E_V1Xb by XBOOLE_0:def 4;
                    hence (EL|EV2X +* EL|E_V1Xb).e=(EL|EV2X).e by CU,FUNCT_4:12
                                                 .=EL.e by E1,FUNCT_1:72;
                  end;
                  suppose not e in EV2X; then
                E1: e in E_V1Xb by D1,XBOOLE_0:def 4;
                    hence (EL|EV2X +* EL|E_V1Xb).e = (EL|E_V1Xb).e
                                                     by CU,FUNCT_4:14
                                                 .= EL.e by E1,FUNCT_1:72;
                  end;
                end;
                hence (EL|E_XX).e = (EL|EV2X +* EL|E_V1Xb).e
                  by D0,CU,FUNCT_1:72;
            end; then
            EL|E_XX = EL|EV2X +* EL|(E_XX \ EV2X) by CU,CV,FUNCT_1:9; then
        CW: Sum (EL|EV2X) + Sum (EL|E_V1X) = Sum (EL|E_XX)
              by CR,GLIB_004:3;
        Cy: now let e be set;
                hereby assume e in EX_X \ EXV2; then
                    e in EX_X & not e in EXV2 by XBOOLE_0:def 4; then
                E0: e DSJoins {x},VG\{x}, G & not e DSJoins {x},V2,G
                      by GLIB_000:def 33; then
                E1: e in the_Edges_of G & (the_Target_of G).e in VG \ {x} &
                    (the_Source_of G).e in {x} by GLIB_000:def 18; then
                E2: not (the_Target_of G).e in V2 by E0,GLIB_000:def 18;
                    (the_Target_of G).e in VG & not (the_Target_of G).e in {x}
                      by E1, XBOOLE_0:def 4; then
                    not (the_Target_of G).e in V1 by E2,XBOOLE_0:def 2; then
                    (the_Target_of G).e in VG \ V1 by E1, XBOOLE_0:def 4; then
                    e DSJoins {x}, VG \ V1, G by E1,GLIB_000:def 18;
                    hence e in EX_V1 by GLIB_000:def 33;
                end;
                assume e in EX_V1; then
                e DSJoins {x}, VG \ V1, G by GLIB_000:def 33; then
            D1: e in the_Edges_of G & (the_Target_of G).e in VG \ V1 &
                (the_Source_of G).e in {x} by GLIB_000:def 18; then
            D2: (the_Target_of G).e in VG & not (the_Target_of G).e in V1
                  by XBOOLE_0:def 4; then
                not (the_Target_of G).e in V2 by XBOOLE_0:def 2; then
                not e DSJoins {x},V2,G by GLIB_000:def 18; then
            D3: not e in EXV2 by GLIB_000:def 33;
                not (the_Target_of G).e in {x} by D2,XBOOLE_0:def 2; then
                (the_Target_of G).e in VG \ {x} by D1,XBOOLE_0:def 4; then
                e DSJoins {x}, VG \ {x}, G by D1,GLIB_000:def 18;  then
                e in EX_X by GLIB_000:def 33;
                hence e in EX_X \ EXV2 by D3, XBOOLE_0:def 4;
            end; then
        CX: EX_X \ EXV2 = EX_V1 by TARSKI:2; 
            reconsider EX_V1b = EX_X \ EXV2 as Subset of the_Edges_of G
              by TARSKI:2,Cy;
            now let e be set; assume e in EXV2; then
                e DSJoins {x},V2,G by GLIB_000:def 33; then
            D1: e in the_Edges_of G & (the_Target_of G).e in V2 &
                  (the_Source_of G).e in {x} by GLIB_000:def 18;
                not (the_Target_of G).e in {x} by D1,C4,TARSKI:def 1; then
                (the_Target_of G).e in VG \ {x} by D1,XBOOLE_0:def 4; then
                e DSJoins {x},VG\{x}, G by D1,GLIB_000:def 18;
                hence e in EX_X by GLIB_000:def 33;
            end; then
        CZ: EXV2 c= EX_X by TARSKI:def 3;
        Ca: dom (EL|EX_X) = EX_X & dom (EL|EXV2) = EXV2 &
              dom (EL|EX_V1b) = EX_X \ EXV2 by PBOOLE:def 3; then
        Cb: dom (EL|EXV2 +* EL|(EX_X \ EXV2)) = EXV2 \/ (EX_X \ EXV2)
                                                  by FUNCT_4:def 1
                                             .= EXV2 \/ EX_X by XBOOLE_1:39
                                             .= EX_X by CZ,XBOOLE_1:12;
            now let e be set; assume
            D0: e in dom (EL|EX_X); then
            D1: e in EX_X by PBOOLE:def 3;
                now per cases;
                  suppose
                E1: e in EXV2; then
                    not e in EX_V1b by XBOOLE_0:def 4;
                    hence (EL|EXV2 +* EL|EX_V1b).e=(EL|EXV2).e by Ca,FUNCT_4:12
                                                 .=EL.e by E1,FUNCT_1:72;
                  end;
                  suppose not e in EXV2; then
                E1: e in EX_V1b by D1,XBOOLE_0:def 4;
                    hence (EL|EXV2 +* EL|EX_V1b).e = (EL|EX_V1b).e
                                                     by Ca,FUNCT_4:14
                                                  .= EL.e by E1,FUNCT_1:72;
                  end;
                end;
                hence (EL|EX_X).e = (EL|EXV2 +* EL|EX_V1b).e
                  by FUNCT_1:72,D0,Ca;
            end; then
            EL|EX_X = EL|EXV2 +* EL|(EX_X \ EXV2) by Ca,Cb,FUNCT_1:9; then
        Cc: Sum (EL|EXV2) + Sum (EL|EX_V1) = Sum (EL|EX_X) by CX, GLIB_004:3;
            reconsider x as Vertex of G by C3;
            x.edgesIn() = G.edgesDBetween(VG,{x}) &
              x.edgesOut() = G.edgesDBetween({x},VG) by GLIB_000:42; then
        Cf: Sum (EL|G.edgesDBetween(VG,{x}))= Sum (EL|G.edgesDBetween({x},VG))
              by C1,C4,A1,dVFLOW,Cz;
        Xa: now let e be set;
                hereby assume e in G.edgesDBetween(VG,{x}) \
                                   G.edgesDBetween({x},{x}); then
                    e in G.edgesDBetween(VG,{x}) &
                    not e in G.edgesDBetween({x},{x}) by XBOOLE_0:def 4; then
                E1: e DSJoins VG,{x},G & not e DSJoins {x},{x},G
                      by GLIB_000:def 33; then
                E2: e in the_Edges_of G & (the_Source_of G).e in VG &
                    (the_Target_of G).e in {x} by GLIB_000:def 18; then
                    not (the_Source_of G).e in {x} by E1,GLIB_000:def 18; then
                    (the_Source_of G).e in VG\{x} by E2,XBOOLE_0:def 4; then
                    e DSJoins VG\{x},{x},G by E2,GLIB_000:def 18;
                    hence e in E_XX by GLIB_000:def 33;
                end;
                assume e in E_XX; then
                e DSJoins VG \{x}, {x}, G by GLIB_000:def 33; then
            D1: e in the_Edges_of G & (the_Source_of G).e in VG \ {x} &
                (the_Target_of G).e in {x} by GLIB_000:def 18;
                (the_Source_of G).e in VG & not (the_Source_of G).e in {x}
                  by D1, XBOOLE_0:def 4; then
                not e DSJoins {x},{x},G by GLIB_000:def 18; then
            D3: not e in G.edgesDBetween({x},{x}) by GLIB_000:def 33;
                e DSJoins VG,{x},G by D1,GLIB_000:def 18; then
                e in G.edgesDBetween(VG,{x}) by GLIB_000:def 33;
                hence e in G.edgesDBetween(VG,{x}) \ G.edgesDBetween({x},{x})
                  by D3,XBOOLE_0:def 4;
            end; then
        Cg: G.edgesDBetween(VG,{x}) \ G.edgesDBetween({x},{x}) = E_XX
              by TARSKI:2;
            reconsider E_XXb = G.edgesDBetween(VG,{x})\G.edgesDBetween({x},{x})
              as Subset of the_Edges_of G by Xa,TARSKI:2;
        Ch: G.edgesDBetween({x},{x}) c= G.edgesDBetween(VG,{x}) by GLIB_000:41;
        Ci: dom (EL|G.edgesDBetween(VG,{x})) = G.edgesDBetween(VG,{x}) &
              dom (EL|G.edgesDBetween({x},{x})) = G.edgesDBetween({x},{x}) &
              dom (EL|E_XXb) = E_XXb by PBOOLE:def 3; then
        Cj: dom (EL|G.edgesDBetween({x},{x}) +* EL|E_XXb)
              = G.edgesDBetween({x},{x}) \/ E_XXb by FUNCT_4:def 1
             .= G.edgesDBetween({x},{x}) \/ G.edgesDBetween(VG,{x})
                by XBOOLE_1:39
             .= G.edgesDBetween(VG,{x}) by Ch,XBOOLE_1:12;
            now let e be set; assume e in dom (EL|G.edgesDBetween(VG,{x}));then
            D1: e in G.edgesDBetween(VG,{x}) by PBOOLE:def 3;
                now per cases;
                  suppose
                E1: e in G.edgesDBetween({x},{x}); then
                    not e in E_XXb by XBOOLE_0:def 4;
                    hence (EL|G.edgesDBetween({x},{x}) +* EL|E_XXb).e
                      = (EL|G.edgesDBetween({x},{x})).e by Ci,FUNCT_4:12
                     .= EL.e by E1,FUNCT_1:72;
                  end;
                  suppose not e in G.edgesDBetween({x},{x}); then
                E1: e in E_XXb by D1,XBOOLE_0:def 4;
                    hence (EL|G.edgesDBetween({x},{x}) +* EL|E_XXb).e
                      = (EL|E_XXb).e by Ci,FUNCT_4:14
                     .= EL.e by E1,FUNCT_1:72;
                  end;
                end;
                hence (EL|G.edgesDBetween(VG,{x})).e =
                  (EL|G.edgesDBetween({x},{x}) +* EL|E_XXb).e by D1,FUNCT_1:72;
            end; then
            EL|G.edgesDBetween(VG,{x}) =
              EL|G.edgesDBetween({x},{x}) +* EL|E_XXb by Ci,Cj,FUNCT_1:9; then
        Ck: Sum (EL|G.edgesDBetween(VG,{x})) =
            Sum (EL|E_XX) + Sum (EL|G.edgesDBetween({x},{x})) by Cg,GLIB_004:3;

        Xb: now let e be set;
                hereby assume e in G.edgesDBetween({x},VG) \
                                   G.edgesDBetween({x},{x}); then
                    e in G.edgesDBetween({x},VG) &
                    not e in G.edgesDBetween({x},{x}) by XBOOLE_0:def 4; then
                E1: e DSJoins {x},VG,G & not e DSJoins {x},{x},G
                      by GLIB_000:def 33; then
                E2: e in the_Edges_of G & (the_Target_of G).e in VG &
                    (the_Source_of G).e in {x} by GLIB_000:def 18; then
                    not (the_Target_of G).e in {x} by E1,GLIB_000:def 18; then
                    (the_Target_of G).e in VG\{x} by E2,XBOOLE_0:def 4; then
                    e DSJoins {x},VG\{x},G by E2,GLIB_000:def 18;
                    hence e in EX_X by GLIB_000:def 33;
                end;
                assume e in EX_X; then
                e DSJoins {x}, VG \{x}, G by GLIB_000:def 33; then
            D1: e in the_Edges_of G & (the_Target_of G).e in VG \ {x} &
                (the_Source_of G).e in {x} by GLIB_000:def 18;
                (the_Target_of G).e in VG & not (the_Target_of G).e in {x}
                  by D1, XBOOLE_0:def 4; then
                not e DSJoins {x},{x},G by GLIB_000:def 18; then
            D3: not e in G.edgesDBetween({x},{x}) by GLIB_000:def 33;
                e DSJoins {x},VG,G by D1,GLIB_000:def 18; then
                e in G.edgesDBetween({x},VG) by GLIB_000:def 33;
                hence e in G.edgesDBetween({x},VG) \ G.edgesDBetween({x},{x})
                  by D3,XBOOLE_0:def 4;
            end; then
        Cp: G.edgesDBetween({x},VG) \ G.edgesDBetween({x},{x}) = EX_X
              by TARSKI:2;
            reconsider EX_Xb = G.edgesDBetween({x},VG)\G.edgesDBetween({x},{x})
              as Subset of the_Edges_of G by Xb,TARSKI:2;
        Cm: G.edgesDBetween({x},{x}) c= G.edgesDBetween({x},VG) by GLIB_000:41;
        Cn: dom (EL|G.edgesDBetween({x},VG)) = G.edgesDBetween({x},VG) &
              dom (EL|EX_Xb) = EX_Xb by PBOOLE:def 3; then
        Cj: dom (EL|G.edgesDBetween({x},{x}) +* EL|EX_Xb)
              = G.edgesDBetween({x},{x}) \/ EX_Xb by Ci,FUNCT_4:def 1
             .= G.edgesDBetween({x},{x}) \/ G.edgesDBetween({x},VG)
                by XBOOLE_1:39
             .= G.edgesDBetween({x},VG) by Cm,XBOOLE_1:12;
            now let e be set; assume e in dom (EL|G.edgesDBetween({x},VG));then
            D1: e in G.edgesDBetween({x},VG) by PBOOLE:def 3;
                now per cases;
                  suppose
                E1: e in G.edgesDBetween({x},{x}); then
                    not e in EX_Xb by XBOOLE_0:def 4;
                    hence (EL|G.edgesDBetween({x},{x}) +* EL|EX_Xb).e
                      = (EL|G.edgesDBetween({x},{x})).e by Cn,FUNCT_4:12
                     .= EL.e by E1,FUNCT_1:72;
                  end;
                  suppose not e in G.edgesDBetween({x},{x}); then
                E1: e in EX_Xb by D1,XBOOLE_0:def 4;
                    hence (EL|G.edgesDBetween({x},{x}) +* EL|EX_Xb).e
                      = (EL|EX_Xb).e by Cn,FUNCT_4:14
                     .= EL.e by E1,FUNCT_1:72;
                  end;
                end;
                hence (EL|G.edgesDBetween({x},VG)).e =
                  (EL|G.edgesDBetween({x},{x}) +* EL|EX_Xb).e by D1,FUNCT_1:72;
            end; then
            EL|G.edgesDBetween({x},VG) =
              EL|G.edgesDBetween({x},{x}) +* EL|EX_Xb by Cn,Cj,FUNCT_1:9; then
            Sum (EL|G.edgesDBetween({x},VG)) =
              Sum (EL|EX_X) + Sum (EL|G.edgesDBetween({x},{x}))
              by Cp,GLIB_004:3; then
        Cm: Sum (EL|E_XX) = Sum (EL|EX_X) by Cf,Ck,XCMPLX_1:2;
            Sum (EL|E1) - Sum(EL|E2)
              = G.flow(source,sink) + Sum (EL|EV2X) + Sum (EL|E_V1X)
                - Sum (EL|EX_V1) - Sum (EL|EXV2) by C9,CH,CJ,CO,CQ
             .= G.flow(source,sink) + Sum (EL|G.edgesDBetween(VG \{x},{x}))
                - Sum (EL|EX_V1) - Sum (EL|EXV2) by CW,XCMPLX_1:1
             .= G.flow(source,sink) + Sum (EL|G.edgesDBetween(VG \{x},{x}))
                - Sum (EL|G.edgesDBetween({x},VG\{x})) by Cc,XCMPLX_1:36
             .= G.flow(source,sink) by Cm,XCMPLX_1:26;
            hence G.flow(source,sink) =
              Sum(EL | G.edgesDBetween(V2, VG \ V2)) -
              Sum(EL | G.edgesDBetween(VG \ V2, V2)) by CA,CL;
        end;
        hence P[n+1];
    end;
A4: for n being non empty Nat holds P[n] from BINARITH:sch 1(A2,A3);
    set n = card (VG \ V);
    now assume n = 0; then
    B1: VG \ V = {} by CARD_2:59;
        sink is Vertex of G by A1,dVFLOW;
        hence contradiction by A1,B1,XBOOLE_0:def 4;
    end;
    hence thesis by A1,A4;
end;

theorem tFLOW02: ::tFLOW02
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
      source,sink being set, V being Subset of the_Vertices_of G
   st G has_valid_flow_from source,sink &
      source in V & not sink in V holds
      G.flow(source,sink) <=
      Sum ((the_Weight_of G) | G.edgesDBetween(V,the_Vertices_of G \ V)) proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set, V be Subset of the_Vertices_of G; assume
A1: G has_valid_flow_from source,sink & source in V & not sink in V;
    set E1 = (the_ELabel_of G) | G.edgesDBetween(V, the_Vertices_of G \ V);
    set E2 = (the_ELabel_of G) | G.edgesDBetween(the_Vertices_of G \ V, V);
    set W1 = (the_Weight_of G) | G.edgesDBetween(V, the_Vertices_of G \ V);
    set B1 = EmptyBag G.edgesDBetween(the_Vertices_of G \ V, V);
A2: G.flow(source,sink) = Sum E1 - Sum E2 by A1,tFLOW01;
    now let e be set; assume
    B1: e in G.edgesDBetween(V, the_Vertices_of G\V); then
        E1.e = (the_ELabel_of G).e & W1.e = (the_Weight_of G).e by FUNCT_1:72;
        hence E1.e <= W1.e by A1, B1, dVFLOW;
    end; then
A3: Sum E1 <= Sum W1 by GLIB_004:5;
A4: Sum B1 = 0 by UPROOTS:13;
    now let e be set; assume
    B1: e in G.edgesDBetween(the_Vertices_of G \ V, V); then
        E2.e = (the_ELabel_of G).e by FUNCT_1:72; then
    B2: 0 <= E2.e by A1,B1,dVFLOW;
        B1 = G.edgesDBetween(the_Vertices_of G \ V, V)-->0
          by POLYNOM1:def 15;
        hence B1.e <= E2.e by B1,B2,FUNCOP_1:13;
    end; then
    0 <= Sum E2 by A4, GLIB_004:5; then
A5: Sum W1 - Sum E2 <= Sum W1 - 0 by REAL_1:92;
    Sum E1 - Sum E2 <= Sum W1 - Sum E2 by A3, REAL_1:49;
    hence G.flow(source,sink) <= Sum W1 by A2,A5,AXIOMS:22;
end;

theorem tFLOWAUG03: ::tFLOWAUG03
  for G being real-weighted real-elabeled WEGraph, P being augmenting Path of G
   holds G == FF:AugmentPath(G,P) &
         the_Weight_of G = the_Weight_of FF:AugmentPath(G,P) proof
    let G be real-weighted real-elabeled WEGraph, P be augmenting Path of G;
    FF:AugmentPath(G,P) = G.set(ELabelSelector, FF:PushFlow(G,P)) by dFFAUGP;
    hence thesis by GLIB_003:11, GLIB_003:8;
end;         

theorem tWTOLERANCE01: ::tWTOLERANCE01 
  for G being finite real-weighted real-elabeled WEGraph,
      W being augmenting Walk of G st W is non trivial holds
      0 < W.tolerance() proof
    let G be finite real-weighted real-elabeled WEGraph,
        W be augmenting Walk of G such that
A1: W is non trivial; set T = W.tolerance();
    T in rng W.flowSeq() & for k being Real st k in rng W.flowSeq() holds
      T <= k by A1,dWTOLERANCE; then consider n being Nat such that
A3: n in dom W.flowSeq() & T = (W.flowSeq()).n by FINSEQ_2:11;
    dom W.flowSeq() = dom W.edgeSeq() by dWFLOWSEQ; then
    2*n in dom W by A3,GLIB_001:79; then
A4: 1 <= 2*n & 2*n <= len W by FINSEQ_3:27; then
    reconsider 2n_1 = 2*n-1 as odd Nat by INT_1:18;
A5: 2*n-1 < len W - 0 by A4,REAL_1:92;
    set v1 = W.(2n_1), e = W.(2*n), v2 = W.(2*n+1);
A6: 2*n-1 + 1 = 2*n & 2*n-1 + 2 = 2*n+1;
    now per cases;
      suppose
    B1: e DJoins v1,v2,G; then
    B2: T = (the_Weight_of G).e - (the_ELabel_of G).e by A3,dWFLOWSEQ;
        (the_ELabel_of G).e < (the_Weight_of G).e by A5,A6,B1,dWAUGMENT; then
        (the_ELabel_of G).e - (the_ELabel_of G).e < T by B2,REAL_1:92;
        hence 0 < T;
      end;
      suppose
    B1: not e DJoins v1,v2,G; then
        T = (the_ELabel_of G).e by A3,dWFLOWSEQ;
        hence 0 < T by A5,A6,B1,dWAUGMENT;
      end;
    end;
    hence 0 < T;
end;
      
theorem tFLOWAUG02: ::tFLOWAUG02 
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
      source,sink being set, P being augmenting Path of G
   st source <> sink & G has_valid_flow_from source,sink &
      P is_Walk_from source,sink
   holds FF:AugmentPath(G,P) has_valid_flow_from source,sink proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set, P be augmenting Path of G; assume
A1: source <> sink & G has_valid_flow_from source,sink &
    P is_Walk_from source,sink;
    set G2 = FF:AugmentPath(G,P);
A2: G2 = G.set(ELabelSelector, FF:PushFlow(G,P)) by dFFAUGP;
A3: G2 == G & the_Weight_of G = the_Weight_of G2 by tFLOWAUG03;
    set EL1 = the_ELabel_of G, EL2 = the_ELabel_of G2;
A4: EL2 = G2.ELabelSelector by GLIB_003:def 8
       .= FF:PushFlow(G,P) by A2,GLIB_000:11;
    now source is Vertex of G & sink is Vertex of G by A1,dVFLOW;
        hence source is Vertex of G2 & sink is Vertex of G2
          by A3, GLIB_000:def 36;
        now let e be set; assume e in the_Edges_of G2; then
        C2: e in the_Edges_of G by A3,GLIB_000:def 36; then
        C3: 0 <= EL1.e & EL1.e <= (the_Weight_of G).e by A1,dVFLOW;
            now per cases;
              suppose not e in P.edges();
                 hence 0 <= (the_ELabel_of G2).e &
                    (the_ELabel_of G2).e <= (the_Weight_of G2).e
                    by A3,A4,C3,C2,dFFPUSH;
              end;
              suppose e in P.edges(); then consider n being odd Nat such that
            D1: n < len P & P.(n+1) = e by GLIB_001:101;
            D2: e Joins P.n,P.(n+2),G by D1,GLIB_001:def 3;
                P.first() = source & P.last() = sink by A1,GLIB_001:def 23;then
            DZ: P is non trivial by A1,GLIB_001:128; then
            D3: 0 < P.tolerance() by tWTOLERANCE01;
            D4: now assume e DJoins P.n,P.(n+2),G & e DJoins P.(n+2),P.n,G;then
                E1: (the_Source_of G).e = P.n & (the_Source_of G).e = P.(n+2)
                      by GLIB_000:def 16;
                E2: n + 0 < n+2 by REAL_1:67;
                    n+2 <= len P by D1, GLIB_001:1; then
                    n = 1 & n+2 = len P by E1,E2,GLIB_001:def 28; then
                    P.n = source & P.(n+2) = sink by A1,GLIB_001:18;
                    hence contradiction by E1,A1;
                end;
                set PFS = P.flowSeq(), n1div2 = (n+1) div 2;
                1 <= n+1 & n+1 <= len P by D1,NAT_1:29,NAT_1:38; then
                n1div2 in dom P.edgeSeq() & P.(n+1) = P.edgeSeq().n1div2
                  by GLIB_001:78;  then
            D6: n1div2 in dom PFS by dWFLOWSEQ; 
                2 divides n+1 by PEPIN:22; then
            D7: 2 * n1div2 = n+1 by NAT_1:49; then
            D8: 2 * n1div2 - 1 = n;
            D9: 2 * n1div2 + 1 = n + 2 by D7;
                now per cases by D2,GLIB_000:19;
                  suppose
                E1: e DJoins P.n,P.(n+2),G; then
                E2: EL1.e + P.tolerance() = EL2.e by A4,D1,dFFPUSH; 
                    0 + 0 <= EL1.e + P.tolerance() by C3,D3,REAL_1:55;
                    hence 0 <= EL2.e by E1,A4,D1,dFFPUSH;
                    PFS.n1div2 = (the_Weight_of G).e - EL1.e
                      by D1,D6,D8,D9,E1,dWFLOWSEQ; then
                    (the_Weight_of G2).e - EL1.e in rng PFS
                      by A3,D6,FUNCT_1:def 5; then
                    P.tolerance() <= (the_Weight_of G2).e - EL1.e
                      by DZ,dWTOLERANCE; then
                    EL2.e <= (the_Weight_of G2).e - EL1.e + EL1.e
                      by E2,REAL_1:55;
                    hence EL2.e <= (the_Weight_of G2).e;
                  end;
                  suppose
                E0: e DJoins P.(n+2),P.n,G; then
                E2: EL2.e = EL1.e - P.tolerance() by D4,A4,D1,dFFPUSH;
                    PFS.n1div2=EL1.e by D1,D6,D8,D9,E0,D4,dWFLOWSEQ; then
                    EL1.e in rng PFS by D6,FUNCT_1:def 5; then
                    P.tolerance() <= EL1.e by DZ,dWTOLERANCE; then
                    P.tolerance() - P.tolerance() <= EL2.e by E2,REAL_1:92;
                    hence 0 <= EL2.e;
                    EL2.e <= EL1.e - 0 by D3,E2,REAL_1:92; 
                    hence EL2.e <= (the_Weight_of G2).e by A3,C3,AXIOMS:22;
                  end;
                end;
                hence 0 <= EL2.e & EL2.e <= (the_Weight_of G2).e;
              end;
            end;
            hence 0 <= EL2.e & EL2.e <= (the_Weight_of G2).e;
        end;
        hence for e being set st e in the_Edges_of G2 holds
           0 <= EL2.e & EL2.e <= (the_Weight_of G2).e;
        let v be Vertex of G2; assume
    B1: v <> source & v <> sink;
        reconsider v'=v as Vertex of G by A3,GLIB_000:def 36;
    B3: v.edgesIn() = v'.edgesIn() & v.edgesOut() = v'.edgesOut()
          by A3,GLIB_000:99;
    B4: Sum (EL1 | v'.edgesIn()) = Sum (EL1 | v'.edgesOut())
          by A1,B1,dVFLOW;
        now per cases;
          suppose v in P.vertices(); then consider n being odd Nat such that
        C2: n <= len P & P.n = v by GLIB_001:88;
        C1: now assume n = len P; then
                v = P.last() by C2,GLIB_001:def 7
                 .= sink by A1,GLIB_001:def 23;
                hence contradiction by B1;
            end; then
        C3: n < len P by C2,REAL_1:def 5;
        C4: 1 <= n by HEYTING3:1;
        CX: now assume n = 1; then
                v = P.first() by C2,GLIB_001:def 6
                 .= source by A1,GLIB_001:def 23;
                hence contradiction by B1;
            end; then
            1 < n by C4,REAL_1:def 5; then
            1+1 <= n by NAT_1:38; then
            reconsider n_2 = n-2*1 as odd Nat by INT_1:18;
            set e1 = P.(n_2+1), e2 = P.(n+1), T = P.tolerance();
        C6: n_2 < len P - 0 by C2,REAL_1:92; then
        CV: e1 Joins P.n_2,P.(n_2+2),G by GLIB_001:def 3;
        C8: e2 Joins v,P.(n+2),G by C2,C3,GLIB_001:def 3;
        C9: P.(n_2+2) = v by C2;
        CA: now assume
            D1: P.n_2 = v;
                n_2 < n - 0 by REAL_1:92;
                hence contradiction
                  by C1,C2,D1,GLIB_001:def 28;
            end;
        CZ: now assume
            D1: v = P.(n+2);
            D2: n+0 < n+2 by REAL_1:67;
                n+2 <= len P by C3,GLIB_001:1;
                hence contradiction
                  by CX,C2,D1,D2,GLIB_001:def 28;
            end;
        CB: now assume
            D1: e1 DJoins P.n_2,v,G & e1 DJoins v,P.n_2,G; then
                P.n_2 = (the_Source_of G).e1 by GLIB_000:def 16
                     .= v by D1,GLIB_000:def 16;
                hence contradiction by CA;
            end;
        CC: now assume
            D1: e2 DJoins v,P.(n+2),G & e2 DJoins P.(n+2),v,G; then
            D2: P.n = (the_Source_of G).e2 by C2,GLIB_000:def 16
                   .= P.(n+2) by D1,GLIB_000:def 16;
            D3: n + 0 < n+2 by REAL_1:67;
                n+2 <= len P by C3,GLIB_001:1;
                hence contradiction
                  by CX,D2,D3,GLIB_001:def 28;
            end;
            n_2 < n - 0 by REAL_1:92; then
            1 <= n_2+1 & n_2+1 < n+1 & n+1 <= len P
              by NAT_1:29,REAL_1:67,C3,NAT_1:38; then
        CD: e1 <> e2 by GLIB_001:139;
        CE: now let e be set; assume
            D1: (e in v'.edgesIn() or e in v'.edgesOut()) & e <> e1 & e <> e2;
                now assume e in P.edges(); then consider v1,v2 being
                    Vertex of G, m being odd Nat such that
                E1: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                      e Joins v1,v2,G by GLIB_001:104;
                E2: m+2-2 < len P - 0 by E1,REAL_1:92;
                E3: now per cases by D1;
                      suppose e in v'.edgesIn(); then
                        (the_Target_of G).e = v by GLIB_000:59;
                        hence v1 = v or v2 = v by E1,GLIB_000:def 15;
                      end;
                      suppose e in v'.edgesOut(); then
                        (the_Source_of G).e = v by GLIB_000:61;
                        hence v1 = v or v2 = v by E1,GLIB_000:def 15;
                      end;
                    end;
                    now per cases by E3;
                      suppose
                    F1: v1 = v;
                        now per cases by REAL_1:def 5;
                          suppose m < n;
                            hence contradiction
                              by C1,C2,E1,F1,GLIB_001:def 28;
                          end;
                          suppose m = n;
                            hence contradiction by E1,D1;
                          end;
                          suppose n < m;
                            hence contradiction by E2,F1,C2,E1,GLIB_001:def 28;
                          end;
                        end;
                        hence contradiction;
                      end;
                      suppose
                    F1: v2 = v;
                        now per cases by REAL_1:def 5;
                          suppose m+2 < n;
                            hence contradiction
                              by C2,C1,E1,F1,GLIB_001:def 28;
                          end;
                          suppose m+2 = n;
                            hence contradiction by D1,E1;
                          end;
                          suppose n < m+2; 
                            hence contradiction by C2,CX,
                              E1,F1,GLIB_001:def 28;
                          end;
                        end;
                        hence contradiction;
                      end;
                    end;
                    hence contradiction;
                end;
                hence not e in P.edges();
            end;
            now per cases by C2,CV,C8,GLIB_000:19;
              suppose
            D1: e1 DJoins P.n_2,v,G & e2 DJoins v,P.(n+2),G;
                set XIN = (EL1|v'.edgesIn()) +* (e1.-->(EL1.e1 + T));
                set XOUT= (EL1|v'.edgesOut())+* (e2.-->(EL1.e2 + T));
            D3: e1 in v'.edgesIn() & e2 in v'.edgesOut()
                  by D1,GLIB_000:60,GLIB_000:62;
            D4: dom (e1.-->(EL1.e1+T)) = {e1} by CQC_LANG:5; then
            D5: dom XIN = dom (EL1|v'.edgesIn()) \/ {e1} by FUNCT_4:def 1
                       .= v'.edgesIn() \/ {e1} by PBOOLE:def 3
                       .= v'.edgesIn() by D3,ZFMISC_1:46; then
                reconsider XIN as Rbag of v'.edgesIn() by PBOOLE:def 3;
            D6: dom (e2.-->(EL1.e2+T)) = {e2} by CQC_LANG:5; then
            D7: dom XOUT = dom (EL1|v'.edgesOut())\/{e2} by FUNCT_4:def 1
                        .= v'.edgesOut() \/ {e2} by PBOOLE:def 3
                        .= v'.edgesOut() by D3,ZFMISC_1:46; then
                reconsider XOUT as Rbag of v'.edgesOut() by PBOOLE:def 3;
            D8: dom (EL2|v.edgesIn()) = v.edgesIn() by PBOOLE:def 3;
                now let e be set; assume e in dom (EL2|v.edgesIn()); then
                E1: e in v.edgesIn() by PBOOLE:def 3; then
                E3: (the_Target_of G).e = v by B3,GLIB_000:59;
                    now per cases;
                      suppose
                    F1: e = e1; then
                        e in dom (e1.-->(EL1.e1+T)) by D4,TARSKI:def 1;
                        hence XIN.e = (e1.-->(EL1.e1+T)).e1 by F1,FUNCT_4:14
                                   .= EL1.e1 + T by CQC_LANG:6
                                   .= EL2.e by A4,C6,C9,D1,F1,dFFPUSH;
                      end;
                      suppose
                    F1: e <> e1; then
                        not e in dom (e1.-->(EL1.e1+T)) by D4,TARSKI:def 1;then
                    F2: XIN.e = (EL1|v'.edgesIn()).e by FUNCT_4:12
                             .= EL1.e by B3,E1,FUNCT_1:72;
                        now assume e in P.edges(); then consider v1,v2 being
                            Vertex of G,m being odd Nat such that
                        G1: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2=P.(m+2)
                              & e Joins v1,v2,G by GLIB_001:104;
                        G2: m+2-2 < len P - 0 by G1,REAL_1:92;
                            now per cases by E3,G1,GLIB_000:def 15;
                              suppose
                            H1: v = v1;
                                now per cases by REAL_1:def 5;
                                  suppose m < n;
                                    hence contradiction by C1,C2,
                                      H1,G1,GLIB_001:def 28;
                                  end;
                                  suppose m = n; then
                                I1: P.(n+2) = P.n
                                      by G1,C2,D1,E3,GLIB_000:def 16;
                                I2: n+2-2 < n+2-0 by REAL_1:92;
                                    n+2 <= len P by C3,GLIB_001:1;
                                    hence contradiction by CX,
                                      I1,I2,GLIB_001:def 28;
                                  end;
                                  suppose n < m;
                                    hence contradiction
                                      by H1,G2,C2,G1,GLIB_001:def 28;
                                  end;
                                end;
                                hence contradiction;
                              end;
                              suppose
                            H2: v = v2;
                                now per cases by REAL_1:def 5;
                                  suppose m+2 < n;
                                    hence contradiction by C1,
                                      C2,G1,H2,GLIB_001:def 28;
                                  end;
                                  suppose m+2 = n;
                                    hence contradiction by F1,G1;
                                  end;
                                  suppose n < m+2;
                                    hence contradiction by CX,
                                      H2,C2,G1,GLIB_001:def 28;
                                  end;
                                end;
                                hence contradiction;
                              end;
                            end;
                            hence contradiction;
                        end;
                        hence EL2.e = XIN.e by F2,A4,B3,E1,dFFPUSH;
                      end;
                    end;
                    hence (EL2|v.edgesIn()).e = XIN.e by E1,FUNCT_1:72;
                end; then
            D9: Sum (EL2|v.edgesIn())=Sum XIN by B3,D5,D8,FUNCT_1:9;
            DA: dom (EL2|v.edgesOut()) = v.edgesOut() by PBOOLE:def 3;
            DB: now let e be set; assume e in dom (EL2|v.edgesOut()); then
                E1: e in v.edgesOut() by PBOOLE:def 3; then
                E3: (the_Source_of G).e = v by B3,GLIB_000:61;
                    now per cases;
                      suppose
                    F1: e = e2; then
                        e in dom (e2.-->(EL1.e2+T)) by D6,TARSKI:def 1;
                        hence XOUT.e = (e2.-->(EL1.e2+T)).e2 by F1,FUNCT_4:14
                                    .= EL1.e2 + T by CQC_LANG:6
                                    .= EL2.e by A4,C2,C3,D1,F1,dFFPUSH;
                      end;
                      suppose
                    F1: e <> e2; then
                        not e in dom (e2.-->(EL1.e2+T)) by D6,TARSKI:def 1;then
                    F2: XOUT.e = (EL1|v'.edgesOut()).e by FUNCT_4:12
                              .= EL1.e by B3,E1,FUNCT_1:72;
                        now assume e in P.edges(); then consider v1,v2 being
                            Vertex of G,m being odd Nat such that
                        G1: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2=P.(m+2)
                              & e Joins v1,v2,G by GLIB_001:104;
                        G2: m+2-2 < len P - 0 by G1,REAL_1:92;
                            now per cases by E3,G1,GLIB_000:def 15;
                              suppose
                            H1: v = v1;
                                now per cases by REAL_1:def 5;
                                  suppose m < n; 
                                    hence contradiction by C1,C2,
                                      H1,G1,GLIB_001:def 28;
                                  end;
                                  suppose m = n;
                                    hence contradiction by F1,G1;
                                  end;
                                  suppose n < m; 
                                    hence contradiction
                                      by G2,H1,C2,G1,GLIB_001:def 28;
                                  end;
                                end;
                                hence contradiction;
                              end;
                              suppose
                            H1: v = v2;
                                now per cases by REAL_1:def 5;
                                  suppose m+2 < n;
                                    hence contradiction by C1,C2,
                                      H1,G1,GLIB_001:def 28;
                                  end;
                                  suppose m+2 = n; then
                                I1: P.n_2 = P.n by G1,C2,D1,E3,GLIB_000:def 16;
                                    n_2 < n - 0 by REAL_1:92;
                                    hence contradiction
                                      by C1,C2,I1,GLIB_001:def 28;
                                  end;
                                  suppose n < m+2; 
                                    hence contradiction by CX,
                                      H1,G1,C2,GLIB_001:def 28;
                                  end;
                                end;
                                hence contradiction;
                              end;
                            end;
                            hence contradiction;
                        end;
                        hence EL2.e = XOUT.e by F2,A4,B3,E1,dFFPUSH;
                      end;
                    end;
                    hence (EL2|v.edgesOut()).e = XOUT.e by E1,FUNCT_1:72;
                end;
                Sum XIN = Sum (EL1|v'.edgesIn()) + (T + EL1.e1)
                            - (EL1|v'.edgesIn()).e1 by GLIB_004:9
                       .= Sum (EL1|v'.edgesOut()) + T + EL1.e1 - EL1.e1
                            by B4,D3,FUNCT_1:72
                       .= Sum (EL1|v'.edgesOut()) + T + EL1.e2 - EL1.e2
                       .= Sum (EL1|v'.edgesOut()) + (T + EL1.e2)
                            - (EL1|v'.edgesOut()).e2 by D3,FUNCT_1:72
                       .= Sum XOUT by GLIB_004:9;
                hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut())
                  by D9,DB,B3,D7,DA,FUNCT_1:9;
              end;
              suppose
            D1: e1 DJoins P.n_2,v,G & e2 DJoins P.(n+2),v,G; then
            D2: EL2.e1 = EL1.e1 + T & EL2.e2 = EL1.e2 - T
                  by A4,C3,C6,C9,CC,dFFPUSH;
            D3: e1 in v'.edgesIn() & e2 in v'.edgesIn() by D1,GLIB_000:60;
                set XIN1 = (EL1|v'.edgesIn())+*(e1.-->(EL1.e1+T));
                set XIN2 = XIN1 +* (e2.-->(EL1.e2-T));
            D4: dom XIN1 = dom (EL1|v'.edgesIn()) \/ dom (e1.-->(EL1.e1+T))
                             by FUNCT_4:def 1
                        .= dom (EL1|v'.edgesIn()) \/ {e1} by CQC_LANG:5
                        .= v'.edgesIn() \/ {e1} by PBOOLE:def 3
                        .= v'.edgesIn() by D3,ZFMISC_1:46; then
                reconsider XIN1 as Rbag of v'.edgesIn() by PBOOLE:def 3;
            D5: dom XIN2 = dom XIN1 \/ dom (e2.-->(EL1.e2-T)) by FUNCT_4:def 1
                        .= v'.edgesIn() \/ {e2} by D4,CQC_LANG:5
                        .= v'.edgesIn() by D3,ZFMISC_1:46; then
                reconsider XIN2 as Rbag of v'.edgesIn() by PBOOLE:def 3;
            D6: dom (EL2|v.edgesIn()) = v.edgesIn() by PBOOLE:def 3;
            D7: dom (e1.-->(EL1.e1+T)) = {e1} & dom (e2.-->(EL1.e2-T)) = {e2}
                  by CQC_LANG:5;
            X0: now let e be set; assume
                E0: e in dom (EL2|v.edgesIn()); then
                E1: e in v.edgesIn() by PBOOLE:def 3;
                E2: (EL2|v.edgesIn()).e = EL2.e by FUNCT_1:72,E0,D6;
                    now per cases;
                      suppose
                    F1: e = e1; then
                    F2: not e in dom (e2.-->(EL1.e2-T)) &
                        e in dom (e1.-->(EL1.e1+T)) by CD,D7,TARSKI:def 1; then
                        XIN2.e = XIN1.e by FUNCT_4:12
                              .= (e1.-->(EL1.e1+T)).e by F2,FUNCT_4:14
                              .= EL2.e by D2,F1,CQC_LANG:6;
                        hence (EL2|v.edgesIn()).e = XIN2.e by FUNCT_1:72,E0,D6;
                      end;
                      suppose
                    F1: e = e2; then
                        e in dom (e2.-->(EL1.e2-T)) by D7,TARSKI:def 1; then
                        XIN2.e = (e2.-->(EL1.e2-T)).e2 by F1,FUNCT_4:14
                              .= EL2.e by D2,F1,CQC_LANG:6;
                        hence (EL2|v.edgesIn()).e = XIN2.e by FUNCT_1:72,E0,D6;
                      end;
                      suppose
                    F1: e <> e1 & e <> e2; then
                    F2: not e in dom (e2.-->(EL1.e2-T)) &
                        not e in dom (e1.-->(EL1.e1+T)) by D7,TARSKI:def 1;then
                    F3: XIN2.e = XIN1.e by FUNCT_4:12
                              .= (EL1|v'.edgesIn()).e by F2,FUNCT_4:12
                              .= EL1.e by E1,B3,FUNCT_1:72;
                        not e in P.edges() by B3,CE,E1,F1;
                        hence (EL2|v.edgesIn()).e = XIN2.e
                          by E1,E2,F3,A4,B3,dFFPUSH;
                      end;
                    end;
                    hence (EL2|v.edgesIn()).e = XIN2.e;
                end;
                not e2 in dom (e1.-->(EL1.e1+T)) by CD,D7,TARSKI:def 1; then
            X2: XIN1.e2 = (EL1|v'.edgesIn()).e2 by FUNCT_4:12
                       .= EL1.e2 by D3,FUNCT_1:72;
            X5: dom (EL2|v.edgesOut()) = v.edgesOut() &
                dom (EL1|v'.edgesOut()) = v.edgesOut() by B3,PBOOLE:def 3;
                now let e be set; assume
                E0: e in dom (EL2|v.edgesOut()); then
                E1: e in v.edgesOut() by PBOOLE:def 3; 
                E2: (EL2|v.edgesOut()).e = EL2.e &
                    (EL1|v'.edgesOut()).e = EL1.e by B3,FUNCT_1:72,E0,X5;
                E3: e in the_Edges_of G &
                      (the_Source_of G).e = v by B3,E1,GLIB_000:61; then
                E4: e <> e1 by D1,GLIB_000:def 16,CA;
                    e <> e2 by E3,D1,GLIB_000:def 16,CZ; then
                    not e in P.edges() by B3,E1,CE,E4;
                    hence (EL2|v.edgesOut()).e = (EL1|v'.edgesOut()).e
                      by E2,A4,dFFPUSH,B3,E1; 
                end; then
            X4: EL2|v.edgesOut() = EL1|v'.edgesOut() by X5,FUNCT_1:9;
                Sum (EL2|v.edgesIn())
                   = Sum XIN2 by X0,B3,D5,D6,FUNCT_1:9
                  .= Sum XIN1 + (EL1.e2-T) - EL1.e2 by X2,GLIB_004:9
                  .= Sum XIN1 - (EL1.e2 - (EL1.e2 - T))
                  .= Sum (EL1|v'.edgesIn())+(EL1.e1+T)-(EL1|v'.edgesIn()).e1-T
                       by GLIB_004:9
                  .= Sum (EL1|v'.edgesIn())+T+EL1.e1-EL1.e1-T
                       by D3,FUNCT_1:72                  
                  .= Sum (EL1|v'.edgesIn());
                hence Sum (EL2|v.edgesIn()) = Sum (EL2|v.edgesOut())
                  by A1,B1,dVFLOW,X4,B3;
              end;
              suppose
            D1: e1 DJoins v,P.n_2,G & e2 DJoins v,P.(n+2),G; then
            D2: EL2.e1 = EL1.e1 - T & EL2.e2 = EL1.e2 + T
                  by A4,C3,C6,C9,CB,dFFPUSH;
            D3: e1 in v'.edgesOut() & e2 in v'.edgesOut() by D1,GLIB_000:62;
                set XOUT1 = (EL1|v'.edgesOut())+*(e1.-->(EL1.e1-T));
                set XOUT2 = XOUT1 +* (e2.-->(EL1.e2+T));
            D4: dom XOUT1 = dom (EL1|v'.edgesOut()) \/ dom (e1.-->(EL1.e1-T))
                              by FUNCT_4:def 1
                         .= dom (EL1|v'.edgesOut()) \/ {e1} by CQC_LANG:5
                         .= v'.edgesOut() \/ {e1} by PBOOLE:def 3
                         .= v'.edgesOut() by D3,ZFMISC_1:46; then
                reconsider XOUT1 as Rbag of v'.edgesOut() by PBOOLE:def 3;
            D5: dom XOUT2 = dom XOUT1\/dom (e2.-->(EL1.e2+T)) by FUNCT_4:def 1
                         .= v'.edgesOut() \/ {e2} by D4,CQC_LANG:5
                         .= v'.edgesOut() by D3,ZFMISC_1:46; then
                reconsider XOUT2 as Rbag of v'.edgesOut() by PBOOLE:def 3;
            D6: dom (EL2|v.edgesOut()) = v.edgesOut() by PBOOLE:def 3;
            D7: dom (e1.-->(EL1.e1-T)) = {e1} & dom (e2.-->(EL1.e2+T)) = {e2}
                  by CQC_LANG:5;
            d8: now let e be set; assume
                E0: e in dom (EL2|v.edgesOut()); then
                E1: e in v.edgesOut() by PBOOLE:def 3;
                E2: (EL2|v.edgesOut()).e = EL2.e by FUNCT_1:72,E0,D6;
                    now per cases;
                      suppose
                    F1: e = e1; then
                    F2: not e in dom (e2.-->(EL1.e2+T)) &
                        e in dom (e1.-->(EL1.e1-T)) by CD,D7,TARSKI:def 1; then
                        XOUT2.e = XOUT1.e by FUNCT_4:12
                               .= (e1.-->(EL1.e1-T)).e by F2,FUNCT_4:14
                               .= EL2.e by D2,F1,CQC_LANG:6;
                        hence (EL2|v.edgesOut()).e=XOUT2.e by FUNCT_1:72,E0,D6;
                      end;
                      suppose
                    F1: e = e2; then
                        e in dom (e2.-->(EL1.e2+T)) by D7,TARSKI:def 1; then
                        XOUT2.e = (e2.-->(EL1.e2+T)).e by FUNCT_4:14
                               .= EL2.e by D2,F1,CQC_LANG:6;
                        hence (EL2|v.edgesOut()).e=XOUT2.e by FUNCT_1:72,E0,D6;
                      end;
                      suppose
                    F1: e <> e1 & e <> e2; then
                    F2: not e in dom (e2.-->(EL1.e2+T)) &
                        not e in dom (e1.-->(EL1.e1-T)) by D7,TARSKI:def 1;then
                    F3: XOUT2.e = XOUT1.e by FUNCT_4:12
                               .= (EL1|v'.edgesOut()).e by F2,FUNCT_4:12
                               .= EL1.e by E1,B3,FUNCT_1:72;
                        not e in P.edges() by E1,B3,CE,F1;
                        hence (EL2|v.edgesOut()).e = XOUT2.e
                          by E2,F3,A4,E1,B3,dFFPUSH;
                      end;
                    end;
                    hence (EL2|v.edgesOut()).e = XOUT2.e;
                end;
                not e2 in dom (e1.-->(EL1.e1-T)) by CD,D7,TARSKI:def 1; then
            D9: XOUT1.e2 = (EL1|v'.edgesOut()).e2 by FUNCT_4:12
                        .= EL1.e2 by D3,FUNCT_1:72;
            DA: Sum (EL2|v.edgesOut())
                   = Sum XOUT2 by d8,B3,D5,D6,FUNCT_1:9
                  .= Sum XOUT1 + (EL1.e2+T) - EL1.e2 by D9,GLIB_004:9
                  .= Sum XOUT1 - EL1.e2 + EL1.e2 + T 
                  .= Sum (EL1|v'.edgesOut()) + (EL1.e1 - T) 
                       - (EL1|v'.edgesOut()).e1 + T by GLIB_004:9
                  .= Sum (EL1|v'.edgesOut()) + EL1.e1 - T - EL1.e1 + T
                       by D3,FUNCT_1:72
                  .= Sum (EL1|v'.edgesOut());
            DB: dom (EL2|v.edgesIn()) = v.edgesIn() &
                dom (EL1|v'.edgesIn()) = v.edgesIn() by B3,PBOOLE:def 3;
                now let e be set; assume
                E0: e in dom (EL2|v.edgesIn()); then
                E1: e in v.edgesIn() by PBOOLE:def 3;
                E2: (EL2|v.edgesIn()).e = EL2.e &
                    (EL1|v'.edgesIn()).e = EL1.e by B3,FUNCT_1:72,DB,E0;
                E3: e in the_Edges_of G &
                      (the_Target_of G).e = v by E1,B3,
                        GLIB_000:59; then
                E4: e <> e1 by D1,GLIB_000:def 16,CA;
                    e <> e2 by E3,D1,GLIB_000:def 16,CZ; then
                    not e in P.edges() by E1,B3,CE,E4;
                    hence (EL2|v.edgesIn()).e = (EL1|v'.edgesIn()).e
                      by E2,A4,E1,B3,dFFPUSH;
                end; then
                EL2|v.edgesIn() = EL1|v'.edgesIn() by DB,FUNCT_1:9;
                hence Sum (EL2|v.edgesIn()) = Sum (EL2|v.edgesOut())
                  by DA,B4,GLIB_004:7;
            end;
            suppose
            D1: e1 DJoins v,P.n_2,G & e2 DJoins P.(n+2),v,G; then
            D2: EL2.e1 = EL1.e1 - T & EL2.e2 = EL1.e2 - T
                  by A4,C3,C6,C9,CB,CC,dFFPUSH;
            D3: e1 in v'.edgesOut() & e2 in v'.edgesIn()
                  by D1,GLIB_000:60,GLIB_000:62;
                set XIN = (EL1|v'.edgesIn())+*(e2.-->(EL1.e2-T));
                set XOUT= (EL1|v'.edgesOut())+*(e1.-->(EL1.e1-T));
            D4: dom (e1.-->(EL1.e1-T)) = {e1} &
                dom (e2.-->(EL1.e2-T)) = {e2} by CQC_LANG:5; then
            D5: dom XIN = dom (EL1|v'.edgesIn()) \/ {e2} by FUNCT_4:def 1
                       .= v'.edgesIn() \/ {e2} by PBOOLE:def 3
                       .= v'.edgesIn() by D3,ZFMISC_1:46; then
                reconsider XIN as Rbag of v'.edgesIn() by PBOOLE:def 3;
            D7: dom XOUT = dom (EL1|v'.edgesOut())\/{e1} by D4,FUNCT_4:def 1
                        .= v'.edgesOut() \/ {e1} by PBOOLE:def 3
                        .= v'.edgesOut() by D3,ZFMISC_1:46; then
                reconsider XOUT as Rbag of v'.edgesOut() by PBOOLE:def 3;
            D8: dom (EL2|v.edgesIn()) = v.edgesIn() &
                dom (EL2|v.edgesOut()) = v.edgesOut() by PBOOLE:def 3;
                now let e be set; assume e in dom (EL2|v.edgesIn()); then
                E1: e in v.edgesIn() by PBOOLE:def 3; then
                E3: (the_Target_of G).e = v by B3,GLIB_000:59;
                    now per cases;
                      suppose
                    F1: e = e2; then
                        e in dom (e2.-->(EL1.e2-T)) by D4,TARSKI:def 1;
                        hence XIN.e = (e2.-->(EL1.e2-T)).e2 by F1,FUNCT_4:14
                                   .= EL2.e by D2,F1,CQC_LANG:6;
                      end;
                      suppose
                    F1: e <> e2; then
                        not e in dom (e2.-->(EL1.e2-T)) by D4,TARSKI:def 1;then
                    F2: XIN.e = (EL1|v'.edgesIn()).e by FUNCT_4:12
                             .= EL1.e by B3,E1,FUNCT_1:72;
                        e <> e1 by CA,D1,E3,GLIB_000:def 16; then
                        not e in P.edges() by B3,E1,CE,F1;
                        hence EL2.e = XIN.e by F2,A4,B3,E1,dFFPUSH;
                      end;
                    end;
                    hence XIN.e = (EL2|v.edgesIn()).e by E1,FUNCT_1:72;
                end; then
            D9: Sum (EL2|v.edgesIn())
                  = Sum XIN by B3,D5,D8,FUNCT_1:9
                 .= Sum (EL1|v'.edgesIn()) + (EL1.e2-T) - (EL1|v'.edgesIn()).e2
                      by GLIB_004:9
                 .= Sum (EL1|v'.edgesIn()) + EL1.e2 - T - EL1.e2
                      by D3,FUNCT_1:72
                 .= Sum (EL1|v'.edgesIn()) - T;
                now let e be set; assume e in dom (EL2|v.edgesOut()); then
                E1: e in v.edgesOut() by PBOOLE:def 3; then
                E3: (the_Source_of G).e = v by B3,GLIB_000:61;
                    now per cases;
                      suppose
                    F1: e = e1; then
                        e in dom (e1.-->(EL1.e1-T)) by D4,TARSKI:def 1;
                        hence XOUT.e = (e1.-->(EL1.e1-T)).e1 by F1,FUNCT_4:14
                                    .= EL2.e by D2,F1,CQC_LANG:6;
                      end;
                      suppose
                    F1: e <> e1; then
                        not e in dom (e1.-->(EL1.e1-T)) by D4,TARSKI:def 1;then
                    F2: XOUT.e = (EL1|v'.edgesOut()).e by FUNCT_4:12
                              .= EL1.e by B3,E1,FUNCT_1:72;
                        e <> e2 by CZ,D1,E3,GLIB_000:def 16; then
                        not e in P.edges() by B3,E1,CE,F1;
                        hence EL2.e = XOUT.e by F2,A4,B3,E1,dFFPUSH;
                      end;
                    end;
                    hence XOUT.e = (EL2|v.edgesOut()).e by E1,FUNCT_1:72;
                end; then
                Sum (EL2|v.edgesOut())
                  = Sum XOUT by B3,D7,D8,FUNCT_1:9
                 .= Sum (EL1|v'.edgesOut()) + (EL1.e1-T)-(EL1|v'.edgesOut()).e1
                      by GLIB_004:9
                 .= Sum (EL1|v'.edgesOut()) + EL1.e1 - T - EL1.e1
                      by D3,FUNCT_1:72
                 .= Sum (EL1|v'.edgesIn()) - T by B4;
                hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut()) by D9;
              end;
            end;
            hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut());
          end;
          suppose
        C1: not v in P.vertices();
        C3: dom (EL1|v'.edgesIn()) = v.edgesIn()
              by B3,PBOOLE:def 3; then
        C6: dom (EL1|v'.edgesIn()) = dom (EL2|v.edgesIn())
              by PBOOLE:def 3;
            now let e be set; assume
            D0: e in dom (EL1|v'.edgesIn()); then
            D2: (EL1|v'.edgesIn()).e = EL1.e &
                  (EL2|v.edgesIn()).e = EL2.e by B3,FUNCT_1:72,C3;
                now assume
                E1: e in P.edges();
                    consider x being set such that
                E2: e DJoins x,v,G2 by D0,C3,GLIB_000:60;
                    e Joins x,v,G2 by E2,GLIB_000:19; then
                    e Joins x,v,G by A3,GLIB_000:91; 
                    hence contradiction by C1,E1,GLIB_001:106;
                end;
                hence (EL1|v'.edgesIn()).e = (EL2|v.edgesIn()).e
                  by D2,A4,B3,D0,C3,dFFPUSH;
            end; then
        C7: EL1 | v'.edgesIn() = EL2 | v.edgesIn() by C6,FUNCT_1:9;
        C8: dom (EL1|v'.edgesOut()) = v.edgesOut() &
              dom (EL2|v.edgesOut()) = v.edgesOut() by B3,PBOOLE:def 3;
            now let e be set; assume
            D0: e in dom (EL1|v'.edgesOut()); then
            D1: e in v.edgesOut() by B3,PBOOLE:def 3; 
            D2: (EL1|v'.edgesOut()).e = EL1.e &
                  (EL2|v.edgesOut()).e = EL2.e by D0,C8,B3,FUNCT_1:72;
                now assume
                E1: e in P.edges();
                    consider x being set such that
                E2: e DJoins v,x,G by D1,B3,GLIB_000:62;
                    e Joins v,x,G by E2,GLIB_000:19;
                    hence contradiction by C1,E1,GLIB_001:106;
                end;
                hence (EL1|v'.edgesOut()).e = (EL2|v.edgesOut()).e
                  by D1,D2,A4,B3,dFFPUSH;
            end; then
        CZ: EL1 | v'.edgesOut() = EL2 | v.edgesOut() by C8,FUNCT_1:9;
            thus Sum (EL2|v.edgesIn())
                = Sum (EL1|v'.edgesIn()) by C7,GLIB_004:7
               .= Sum (EL2|v.edgesOut()) by B4,CZ,GLIB_004:7;
          end;
        end;
        hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut());
    end;
    hence G2 has_valid_flow_from source,sink by dVFLOW;
end;

theorem tFLOWAUG01: ::tFLOWAUG01
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
      source,sink being set, P being augmenting Path of G
   st source <> sink & G has_valid_flow_from source,sink &
      P is_Walk_from source,sink holds
     G.flow(source,sink) + P.tolerance() =
       (FF:AugmentPath(G,P)).flow(source,sink) proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set, P be augmenting Path of G such that
A1: source <> sink & G has_valid_flow_from source,sink &
      P is_Walk_from source,sink;
    set G2 = FF:AugmentPath(G,P), T = P.tolerance();
A2: G2 = G.set(ELabelSelector, FF:PushFlow(G,P)) by dFFAUGP;
    set EL1 = the_ELabel_of G, EL2 = the_ELabel_of G2;
A4: EL2 = G2.ELabelSelector by GLIB_003:def 8
       .= FF:PushFlow(G,P) by A2,GLIB_000:11;
A5: G2 has_valid_flow_from source,sink by A1,tFLOWAUG02;
    set EI1 = EL1|G.edgesInto({sink}), EO1 = EL1|G.edgesOutOf({sink});
    P.first() = source & P.last() = sink by A1,GLIB_001:def 23; then
    P is non trivial by A1,GLIB_001:128; then
    3 <= len P by GLIB_001:126; then
    2 <= len P by AXIOMS:22; then
    reconsider lenP_2 = len P - 2*1 as odd Nat by INT_1:18;
    set e1 = P.(lenP_2+1);    
A8: lenP_2 < len P - 0 by REAL_1:92; then
A9: e1 Joins P.lenP_2, P.(lenP_2+2), G by GLIB_001:def 3; then
AA: e1 in the_Edges_of G by GLIB_000:def 15;
    G2 == G by tFLOWAUG03; then
AB: G2.edgesInto({sink}) = G.edgesInto({sink}) &
    G2.edgesOutOf({sink}) = G.edgesOutOf({sink}) by GLIB_000:93;
AC: P.(len P) = sink by A1,GLIB_001:18;
    now per cases;
      suppose
    B1: e1 DJoins P.lenP_2, P.(lenP_2+2), G; then
    B2: EL2.e1 = EL1.e1 + T by A4,A8,dFFPUSH;
       (the_Target_of G).e1 = P.(lenP_2+2) by B1,GLIB_000:def 16
                            .= sink by A1,GLIB_001:18; then
        (the_Target_of G).e1 in {sink} by TARSKI:def 1; then
    B4: e1 in G.edgesInto({sink}) by AA,GLIB_000:def 28;
        set EI2 = EI1+*(e1.-->(EI1.e1 + T));
    B5: dom EI2 = dom EI1 \/ dom (e1.-->(EI1.e1 + T)) by FUNCT_4:def 1
               .= dom EI1 \/ {e1} by CQC_LANG:5
               .= G.edgesInto({sink}) \/ {e1} by PBOOLE:def 3
               .= G.edgesInto({sink}) by B4,ZFMISC_1:46; then
        reconsider EI2 as Rbag of G.edgesInto({sink}) by PBOOLE:def 3;
    B6: dom (EL2|G2.edgesInto({sink})) = G2.edgesInto({sink})
          by PBOOLE:def 3;
        now let e be set; assume
        C0: e in dom (EL2|G2.edgesInto({sink})); then
        C1: e in G2.edgesInto({sink}) by PBOOLE:def 3; 
        C2: (EL2|G2.edgesInto({sink})).e = EL2.e by C0,B6,FUNCT_1:72;
            (the_Target_of G).e in {sink} by C1,AB,
              GLIB_000:def 28; then
        C3: (the_Target_of G).e = sink by TARSKI:def 1;
            now per cases;
              suppose
            D1: e = e1; then
                e in {e1} by TARSKI:def 1; then
                e in dom (e1.-->(EI1.e1+T)) by CQC_LANG:5; then
                EI2.e = (e1.-->(EI1.e1+T)).e1 by D1,FUNCT_4:14
                     .= EI1.e1 + T by CQC_LANG:6
                     .= EL2.e1 by C1,B2,AB,D1,FUNCT_1:72;
                hence (EL2|G2.edgesInto({sink})).e = EI2.e
                  by C0,B6,FUNCT_1:72,D1;
              end;
              suppose
            D1: e <> e1; then
                not e in {e1} by TARSKI:def 1; then
                not e in dom (e1.-->(EI1.e1+T)) by CQC_LANG:5; then
            D2: EI2.e = EI1.e by FUNCT_4:12
                     .= EL1.e by C1,AB,FUNCT_1:72;
                now assume e in P.edges(); then
                    consider v1,v2 being Vertex of G,m being odd Nat such that
                E1: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                      e Joins v1,v2,G by GLIB_001:104;
                    now per cases by E1,C3,GLIB_000:def 15;
                      suppose
                    F1: v1 = sink; then
                    F2: P.m = P.(len P) by A1,GLIB_001:18,E1;
                        m+2-2 < len P - 0 by E1,REAL_1:92; then
                        m = 1 by F2,GLIB_001:def 28;
                        hence contradiction by A1,F1,GLIB_001:18,E1;
                      end;
                      suppose v2 = sink; then
                     F1: P.(m+2) = P.(len P) by A1,GLIB_001:18,E1;
                         now assume m+2 < len P; then
                             m+2 = 1 by F1,GLIB_001:def 28; then
                             m = 1-2;
                             hence contradiction by HEYTING3:1;
                         end; then
                         m + 2 = len P by E1, AXIOMS:21; 
                         hence contradiction by D1,E1,XCMPLX_1:26;
                      end;
                    end;
                    hence contradiction;
                end;
                hence (EL2|G2.edgesInto({sink})).e = EI2.e
                  by C1,C2,D2,A4,AB,dFFPUSH;
              end;
            end;
            hence (EL2|G2.edgesInto({sink})).e = EI2.e;
        end; then
    B7: Sum (EL2|G2.edgesInto({sink}))
           = Sum EI2 by AB,B5,B6,FUNCT_1:9
          .= Sum EI1 + (T + EI1.e1) - EI1.e1 by GLIB_004:9
          .= Sum EI1 + T;
    B8: dom (EL2|G2.edgesOutOf({sink})) = G2.edgesOutOf({sink}) &
        dom EO1 = G2.edgesOutOf({sink}) by AB,PBOOLE:def 3;
        now let e be set; assume
        C0: e in dom (EL2|G2.edgesOutOf({sink})); then
        C1: e in G2.edgesOutOf({sink}) by PBOOLE:def 3; then
            (the_Source_of G).e in {sink} by AB,GLIB_000:def 29; then
        C3: (the_Source_of G).e = sink by TARSKI:def 1;
            now assume e in P.edges(); then
                consider v1,v2 being Vertex of G, m being odd Nat such that
            D1: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                  e Joins v1,v2,G by GLIB_001:104;
                now per cases by C3,D1,GLIB_000:def 15;
                  suppose
                E1: v1 = sink; then
                E2: P.m = P.(len P) by A1,GLIB_001:18,D1;
                    m+2-2 < len P - 0 by D1,REAL_1:92; then
                    m = 1 by E2,GLIB_001:def 28;
                    hence contradiction by A1,D1,E1,GLIB_001:18;
                  end;
                  suppose v2 = sink; then
                E1: P.(m+2) = P.(len P) by A1,GLIB_001:18,D1;
                    now assume m+2 < len P; then
                        m+2 = 1 by E1,GLIB_001:def 28; then
                        1 <= 1-2 by HEYTING3:1;
                        hence contradiction;
                    end; then
                    m + 2 = len P by D1, AXIOMS:21; then
                    m = lenP_2 by XCMPLX_1:26; then
                E2: P.lenP_2 = sink by D1,B1,C3,GLIB_000:def 16; then
                    lenP_2 = 1 by AC,A8,GLIB_001:def 28;
                    hence contradiction by A1,E2,GLIB_001:18;
                  end;
                end;
                hence contradiction;
            end; then
            EL2.e = EL1.e by A4,C1,AB,dFFPUSH
                 .= EO1.e by AB,C1,FUNCT_1:72;
            hence (EL2|G2.edgesOutOf({sink})).e = EO1.e by FUNCT_1:72,C0,B8;
        end; then
        EL2|G2.edgesOutOf({sink}) = EO1 by B8,FUNCT_1:9; then
        Sum (EL2|G2.edgesOutOf({sink})) = Sum EO1 by GLIB_004:7;
        hence G2.flow(source,sink) = Sum EI1 + T - Sum EO1 by B7,A5,dGFLOW
                                  .= Sum EI1 - Sum EO1 + T
                                  .= G.flow(source,sink) + T by A1,dGFLOW;
      end;
      suppose
    B1: not e1 DJoins P.lenP_2, P.(lenP_2+2), G; then
    B2: EL2.e1 = EL1.e1 - T by A4,A8,dFFPUSH;
    BZ: e1 DJoins P.(lenP_2+2),P.lenP_2,G by A9,B1,GLIB_000:19; then
        (the_Source_of G).e1 = P.(lenP_2+2) by GLIB_000:def 16
                            .= sink by A1,GLIB_001:18; then
        (the_Source_of G).e1 in {sink} by TARSKI:def 1; then
    B4: e1 in G.edgesOutOf({sink}) by AA,GLIB_000:def 29;
        set EO2 = EO1+*(e1.-->(EO1.e1-T));
    B5: dom EO2 = dom EO1 \/ dom (e1.-->(EO1.e1 - T)) by FUNCT_4:def 1
               .= dom EO1 \/ {e1} by CQC_LANG:5
               .= G.edgesOutOf({sink}) \/ {e1} by PBOOLE:def 3
               .= G.edgesOutOf({sink}) by B4,ZFMISC_1:46; then
        reconsider EO2 as Rbag of G.edgesOutOf({sink}) by PBOOLE:def 3;
    B6: dom (EL2|G2.edgesOutOf({sink})) = G2.edgesOutOf({sink})
          by PBOOLE:def 3;
        now let e be set; assume
        C0: e in dom (EL2|G2.edgesOutOf({sink})); then
        C1: e in G2.edgesOutOf({sink}) by PBOOLE:def 3; 
        C2: (EL2|G2.edgesOutOf({sink})).e = EL2.e by C0,B6,FUNCT_1:72;
            (the_Source_of G).e in {sink} by AB,C1,GLIB_000:def 29; then
        C3: (the_Source_of G).e = sink by TARSKI:def 1;
            now per cases;
              suppose
            D1: e = e1; then
                e in {e1} by TARSKI:def 1; then
                e in dom (e1.-->(EO1.e1-T)) by CQC_LANG:5; then
                EO2.e = (e1.-->(EO1.e1-T)).e1 by D1,FUNCT_4:14
                     .= EO1.e1 - T by CQC_LANG:6
                     .= EL2.e by B2,AB,C1,D1,FUNCT_1:72;
                hence (EL2|G2.edgesOutOf({sink})).e = EO2.e
                  by C0,B6,FUNCT_1:72;
              end;
              suppose
            D1: e <> e1; then
                not e in {e1} by TARSKI:def 1; then
                not e in dom (e1.-->(EO1.e1-T)) by CQC_LANG:5; then
            D2: EO2.e = EO1.e by FUNCT_4:12
                     .= EL1.e by AB,C1,FUNCT_1:72;
                now assume e in P.edges(); then
                    consider v1,v2 being Vertex of G, m being odd Nat such that
                E1: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                     e Joins v1,v2,G by GLIB_001:104;
                    now per cases by C3,E1,GLIB_000:def 15;
                      suppose
                    F0: v1 = sink; then
                    F1: P.m = P.(len P) by A1,GLIB_001:18,E1;
                        m+2-2 < len P - 0 by E1,REAL_1:92; then
                        m = 1 by F1,GLIB_001:def 28;
                        hence contradiction by A1,F0,E1,GLIB_001:18;
                      end;
                      suppose v2 = sink; then
                    F1: P.(m+2) = P.(len P) by A1,GLIB_001:18,E1;
                        now assume m+2 < len P; then
                            m+2 = 1 by F1,GLIB_001:def 28; then
                            1 <= 1-2 by HEYTING3:1;
                            hence contradiction;
                        end; then
                        m + 2 = len P by E1, AXIOMS:21;
                        hence contradiction by D1,E1,XCMPLX_1:26;
                      end;
                    end;
                    hence contradiction;
                end;
                hence (EL2|G2.edgesOutOf({sink})).e = EO2.e
                  by C2,D2,A4,AB,C1,dFFPUSH;
              end;
            end;
            hence (EL2|G2.edgesOutOf({sink})).e = EO2.e;
        end; then
    B7: Sum (EL2|G2.edgesOutOf({sink}))
           = Sum EO2 by AB,B5,B6,FUNCT_1:9
          .= Sum EO1 + (EO1.e1 - T) - EO1.e1 by GLIB_004:9
          .= Sum EO1 - T;
    B8: dom (EL2|G2.edgesInto({sink})) = G2.edgesInto({sink}) &
          dom EI1 = G2.edgesInto({sink}) by AB,PBOOLE:def 3;
        now let e be set; assume
        C0: e in dom (EL2|G2.edgesInto({sink})); then
        C1: e in G2.edgesInto({sink}) by PBOOLE:def 3; then
            (the_Target_of G).e in {sink} by AB,GLIB_000:def 28; then
        C3: (the_Target_of G).e = sink by TARSKI:def 1;
            now assume e in P.edges(); then
                consider v1,v2 being Vertex of G, m being odd Nat such that
           D1: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                  e Joins v1,v2,G by GLIB_001:104;
                now per cases by C3,D1,GLIB_000:def 15;
                  suppose
                E0: v1 = sink; then
                E1: P.m = P.(len P) by A1,GLIB_001:18,D1;
                    m+2-2 < len P - 0 by D1,REAL_1:92; then
                    m = 1 by E1,GLIB_001:def 28;
                    hence contradiction by A1,E0,D1,GLIB_001:18;
                  end;
                  suppose v2 = sink; then
                E1: P.(m+2) = P.(len P) by A1,GLIB_001:18,D1;
                    now assume m+2 < len P; then
                        m+2 = 1 by E1,GLIB_001:def 28; then
                        1 <= 1-2 by HEYTING3:1;
                        hence contradiction;
                    end; then
                    m + 2 = len P by D1, AXIOMS:21; then
                    m = lenP_2 by XCMPLX_1:26; then
                E2: P.lenP_2 = sink by D1,BZ,C3,GLIB_000:def 16; then
                    lenP_2 = 1 by AC,A8,GLIB_001:def 28;
                    hence contradiction by A1,E2,GLIB_001:18;
                  end;
                end;
                hence contradiction;
            end; then
            EL2.e = EL1.e by A4,AB,C1,dFFPUSH
                 .= EI1.e by AB,C1,FUNCT_1:72;
            hence (EL2|G2.edgesInto({sink})).e = EI1.e by C0,B8,FUNCT_1:72;
        end; then
        EL2|G2.edgesInto({sink}) = EI1 by B8,FUNCT_1:9; then
        Sum (EL2|G2.edgesInto({sink})) = Sum EI1 by GLIB_004:7;
        hence G2.flow(source,sink) = Sum EI1 - (Sum EO1 - T) by B7,A5,dGFLOW
                                  .= Sum EI1 - Sum EO1 + T
                                  .= G.flow(source,sink) + T by A1,dGFLOW;
      end;
    end;
    hence thesis;
end;

theorem tFLOWCS02: ::tFLOWCS02
  for G being finite real-weighted WGraph, source,sink being Vertex of G,
      n being Nat
  holds FF:CompSeq(G,source,sink).->n == G &
  the_Weight_of G = the_Weight_of (FF:CompSeq(G,source,sink).->n)  proof
    let G be finite real-weighted WGraph, source,sink be Vertex of G;
    set CS = FF:CompSeq(G,source,sink);
    defpred P[Nat] means
      CS.->$1 == G & the_Weight_of G = the_Weight_of (CS.->$1);
    CS.->0 = G.set(ELabelSelector, the_Edges_of G --> 0)
      by dFFCS; then
A1: P[0] by GLIB_003:8,GLIB_003:11;
A2: now let n be Nat; set Gn = CS.->n, Gn1 = CS.->(n+1); assume
    B1: P[n];
        consider source',sink' being Vertex of Gn such that
    B2: source' = source & sink' = sink & Gn1 = FF:Step(Gn,source',sink')
          by dFFCS;
        now per cases;
          suppose
        C1: sink' in AP:FindAugPath(Gn,source').labeledV();
            set P = AP:GetAugPath(Gn,source',sink');
            Gn1 = FF:AugmentPath(Gn, P) by B2,C1,dFFSTEP; then
            Gn1 == Gn & the_Weight_of Gn1 = the_Weight_of Gn by tFLOWAUG03;
            hence P[n+1] by B1,GLIB_000:88;
          end;
          suppose not sink' in AP:FindAugPath(Gn,source').labeledV();
            hence P[n+1] by B1,B2, dFFSTEP;
          end;
        end;
        hence P[n+1];
    end; 
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis;
end;

theorem tFLOWCS01: ::tFLOWCS01
  for G being finite nonnegative-weighted WGraph,
              source,sink being Vertex of G, n being Nat
   st source <> sink 
    holds FF:CompSeq(G,source,sink).->n has_valid_flow_from source,sink  proof
    let G be finite nonnegative-weighted WGraph, source,sink be Vertex of G,
        n be Nat; assume
A0: source <> sink;        
    set CS = FF:CompSeq(G,source,sink); 
    defpred P[Nat] means (CS.->$1) has_valid_flow_from source,sink;
    now set G0 = CS.->0;
    B1: G0 = G.set(ELabelSelector, the_Edges_of G --> 0) by dFFCS; then
    B2: G0 == G by GLIB_003:8;
        hence source is Vertex of G0 & sink is Vertex of G0 by GLIB_000:def 36;
    B3: the_ELabel_of G0 = G0.ELabelSelector by GLIB_003:def 8
                        .= the_Edges_of G --> 0 by B1, GLIB_000:11;
        now let e be set; assume e in the_Edges_of G0; then
        C1: e in the_Edges_of G by B2, GLIB_000:def 36;
            hence 0 <= (the_ELabel_of G0).e by B3,FUNCOP_1:13;
        C3: rng the_Weight_of G0 c= Real>=0 by GLIB_003:def 14;
            dom the_Weight_of G0 = the_Edges_of G0 by GLIB_003:5
                                .= the_Edges_of G by B2,GLIB_000:def 36; then
            (the_Weight_of G0).e in rng (the_Weight_of G0)
              by C1,FUNCT_1:def 5; then
            (the_Weight_of G0).e in Real>=0 by C3; then
            consider r being Real such that
        C4: r = (the_Weight_of G0).e & r >= 0 by GRAPH_5:def 12;
            thus (the_ELabel_of G0).e <= (the_Weight_of G0).e
              by C1,B3,FUNCOP_1:13,C4;
        end; 
        hence (for e being set st e in the_Edges_of G0 holds
          0 <= (the_ELabel_of G0).e &
          (the_ELabel_of G0).e <= (the_Weight_of G0).e);
        let v be Vertex of G0; assume v <> source & v <> sink;
        set B1 = EmptyBag v.edgesIn(), B2 = EmptyBag v.edgesOut();
        set E1 = ((the_ELabel_of G0)|v.edgesIn());
        set E2 = ((the_ELabel_of G0)|v.edgesOut());
        now let e be set; assume
        C1: e in v.edgesIn(); then
            e in the_Edges_of G0; then
        C2: e in the_Edges_of G by B2,GLIB_000:def 36; 
            E1.e = (the_ELabel_of G0).e by C1,FUNCT_1:72
                .= 0 by B3,C2,FUNCOP_1:13;
            hence B1.e = E1.e by POLYNOM1:56;
        end; then
    B5: Sum E1 = Sum B1 by GLIB_004:6
              .= 0 by UPROOTS:13;
        now let e be set; assume
        C1: e in v.edgesOut(); then
            e in the_Edges_of G0; then
        C2: e in the_Edges_of G by B2,GLIB_000:def 36;
            E2.e = (the_ELabel_of G0).e by C1,FUNCT_1:72
                .= 0 by B3,C2,FUNCOP_1:13;
            hence B2.e = E2.e by POLYNOM1:56;
        end; then
        Sum E2 = Sum B2 by GLIB_004:6
              .= 0 by UPROOTS:13;
        hence Sum E1 = Sum E2 by B5;
    end; then
A1: P[0] by dVFLOW;
    now let n be Nat; set Gn = CS.->n, Gn1 = CS.->(n+1); assume
    B1: Gn has_valid_flow_from source,sink;
        consider source',sink' being Vertex of Gn such that
    B2: source'=source & sink'=sink & Gn1 = FF:Step(Gn,source',sink')
          by dFFCS;
        now per cases;
          suppose
        C1: sink in AP:FindAugPath(Gn,source').labeledV();
            set P = AP:GetAugPath(Gn,source',sink');
        C2: Gn1 = FF:AugmentPath(Gn, P) by B2,C1,dFFSTEP;
            P is_Walk_from source',sink'
              by B2,C1,dAPGETAUG;
            hence P[n+1] by C2,A0,B1,B2,tFLOWAUG02;
          end;
          suppose not sink in AP:FindAugPath(Gn,source').labeledV();
            hence P[n+1] by B1,B2,dFFSTEP;
          end;
        end;
        hence P[n+1];
    end; then
A2: for n being Nat st P[n] holds P[n+1];    
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis;
end;
  
theorem tMAXFLOW01: ::tMAXFLOW01
  for G being finite natural-weighted WGraph,source,sink being Vertex of G st
      source <> sink holds FF:CompSeq(G,source,sink) is halting  proof
    let G be finite natural-weighted WGraph, source, sink be Vertex of G;
    assume
A1: source <> sink;
    set CS = FF:CompSeq(G,source,sink);
    now assume
    B1: for n being Nat holds CS.->n <> CS.->(n+1);
        defpred P[Nat] means $1 <= (CS.->$1).flow(source,sink) &
                             (CS.->$1).flow(source,sink) is Nat;
        now set G0 = CS.->0;
            set E1 = (the_ELabel_of G0) | G0.edgesInto({sink});
            set E2 = (the_ELabel_of G0) | G0.edgesOutOf({sink});
        C1: G0 has_valid_flow_from source,sink by A1,tFLOWCS01; then
        C2: G0.flow(source,sink) = Sum E1 - Sum E2 by dGFLOW;
        C3: G0 = G.set(ELabelSelector, the_Edges_of G --> 0) by dFFCS; then
            G0 == G by GLIB_003:8; then
        C4: the_Edges_of G0 = the_Edges_of G by GLIB_000:def 36;
        C5: the_ELabel_of G0 = G0.ELabelSelector by GLIB_003:def 8
                            .= the_Edges_of G --> 0 by C3,GLIB_000:11;
            set B1 = EmptyBag G0.edgesInto({sink});
            set B2 = EmptyBag G0.edgesOutOf({sink});
            now let e be set; assume
            D1: e in G0.edgesInto({sink}); then
                E1.e = (the_ELabel_of G0).e by FUNCT_1:72;
                hence E1.e = 0 by C4,D1,C5,FUNCOP_1:13
                          .= B1.e by POLYNOM1:56;
            end; then
        C6: Sum E1 = Sum B1 by GLIB_004:6
                  .= 0 by UPROOTS:13;
            now let e be set; assume
            D1: e in G0.edgesOutOf({sink}); then
                E2.e = (the_ELabel_of G0).e by FUNCT_1:72;
                hence E2.e = 0 by C5,D1,C4,FUNCOP_1:13
                          .= B2.e by POLYNOM1:56;
            end; then
        C7: Sum E2 = Sum B2 by GLIB_004:6
                  .= 0 by UPROOTS:13;
            hence G0.flow(source,sink) = 0 - 0 by C1,dGFLOW,C6;
            thus G0.flow(source,sink) is Nat by C2,C6,C7;
        end; then
    B2: P[0];
        now let n be Nat; set Gn = CS.->n, Gn1 = CS.->(n+1); assume
        C1: n <= Gn.flow(source,sink) & Gn.flow(source,sink) is Nat;
        C2: Gn has_valid_flow_from source,sink &
              Gn1 has_valid_flow_from source,sink by A1,tFLOWCS01;
            consider source',sink' being Vertex of Gn such that
        C3: source' = source & sink' = sink &
              Gn1 = FF:Step(Gn, source',sink') by dFFCS;
        C4: now assume not sink in AP:FindAugPath(Gn,source').labeledV(); then
                Gn1 = Gn by C3, dFFSTEP;
                hence contradiction by B1;
            end; then
        C5: Gn1 = FF:AugmentPath(Gn,AP:GetAugPath(Gn,source',sink'))
              by C3,dFFSTEP;
            set P = AP:GetAugPath(Gn,source',sink');
        C6: P is_Walk_from source',sink' by C3,C4,dAPGETAUG; then
            P.first() = source' & P.last() = sink' by GLIB_001:def 23; then
            P is non trivial by A1,C3,GLIB_001:128; then
        C7: 0 < P.tolerance() by tWTOLERANCE01;
            reconsider GnF = Gn.flow(source,sink) as Nat by C1;
        C8: GnF + P.tolerance() = Gn1.flow(source,sink)
              by A1,C2,C3,C5,C6,tFLOWAUG01; then
            reconsider Gn1F = Gn1.flow(source,sink) as Nat;
            GnF + P.tolerance()-P.tolerance() < Gn1F-0 by C7,C8,REAL_1:92; then
            n < Gn1F by C1,AXIOMS:22;
            hence n+1 <= Gn1.flow(source,sink) by NAT_1:38;
            thus Gn1.flow(source,sink) is Nat by C8;
        end; then
    B3: for n being Nat st P[n] holds P[n+1];
    B4: for n being Nat holds P[n] from NAT_1:sch 1(B2,B3);
        set V = {source};
    B5: source in V & not sink in V by A1,TARSKI:def 1;
        set W1 = (the_Weight_of G)|G.edgesDBetween(V,the_Vertices_of G \ V);
        degree W1 = Sum W1; then
        reconsider N = Sum W1 as Nat;
        set Gn1 = CS.->(N+1);
        reconsider Gn1F = Gn1.flow(source,sink) as Nat by B4;
        Sum W1 + 1 <= Gn1F by B4; then
    B6: Sum W1 < Gn1.flow(source,sink) by NAT_1:38;
    B7: Gn1 == G & the_Weight_of G = the_Weight_of Gn1 by tFLOWCS02; then
        reconsider V'=V as Subset of the_Vertices_of Gn1 by GLIB_000:def 36;
        set W2 = (the_Weight_of Gn1) |
                  Gn1.edgesDBetween(V',the_Vertices_of Gn1 \ V');
        W1 = (the_Weight_of Gn1) |
               G.edgesDBetween(V', the_Vertices_of Gn1 \ V')
               by B7,GLIB_000:def 36
          .= W2 by B7, GLIB_000:93; then
    B8: Sum W1 = Sum W2 by GLIB_004:7;
        Gn1 has_valid_flow_from source,sink by A1,tFLOWCS01;
        hence contradiction by B6,B8,B5,tFLOW02;
    end;
    hence FF:CompSeq(G,source,sink) is halting by GLIB_000:def 68;
end;
      
theorem tMAXFLOW02: ::tMAXFLOW02
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
      source,sink being set 
   st source <> sink & G has_valid_flow_from source,sink &
   not ex P being augmenting Path of G st P is_Walk_from source,sink
   holds G has_maximum_flow_from source,sink  proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set; assume
A1: source <> sink & G has_valid_flow_from source,sink &
    not ex P being augmenting Path of G st P is_Walk_from source,sink;
    reconsider src = source as Vertex of G by A1,dVFLOW;
    set CS = AP:CompSeq(G,src), Gn = AP:FindAugPath(G,src), V = Gn.labeledV();
    set Gn1 = CS.->(CS.Lifespan()+1);
AX: Gn == G & the_Weight_of Gn = the_Weight_of G &
      the_ELabel_of Gn = the_ELabel_of G by tAPFAP03; then
AY: the_Vertices_of Gn = the_Vertices_of G &
    the_Edges_of Gn = the_Edges_of G &
    the_Source_of Gn = the_Source_of G &
    the_Target_of Gn = the_Target_of G by GLIB_000:def 36;
    reconsider V as Subset of the_Vertices_of G by AX,GLIB_000:def 36;
A2: source in V by tAPFAP03;
A3: sink in Gn.labeledV() iff
     ex P being Path of G st P is augmenting & P is_Walk_from src,sink
      by tAPFAP02;
    set E1 = G.edgesDBetween(V, the_Vertices_of G \ V);
    set E2 = G.edgesDBetween(the_Vertices_of G \ V, V);
A4: G.flow(source,sink) = Sum((the_ELabel_of G) | E1) -
                          Sum((the_ELabel_of G) | E2) by A1,A2,A3,tFLOW01;
    set A1 = (the_ELabel_of G)|E1, B1 = (the_Weight_of G)|E1;
A6: AP:CompSeq(G,src) is halting by tAPFAP01;
A7: Gn = CS.Result() by dAPFAUGP
      .= CS.(CS.Lifespan()) by GLIB_000:def 58
      .= CS.->(CS.Lifespan()) by GLIB_000:def 59; then
A8: Gn1 = AP:Step(Gn) by dAPCS;
A9: Gn1 = CS.(CS.Lifespan()+1) by GLIB_000:def 59
       .= CS.(CS.Lifespan()) by A6, GLIB_000:def 57
       .= Gn by A7,GLIB_000:def 59;
    set e = choose AP:NextBestEdges(Gn);
AA: now assume
    B1: AP:NextBestEdges(Gn) <> {}; then
    B2: e in AP:NextBestEdges(Gn);
        now per cases by B1,dAPNEXT;
          suppose e is_forward_labeling_in Gn; then
        C1: (the_Source_of Gn).e in V &
              not (the_Target_of Gn).e in V by dFORLABEL; then
        C2: Gn = Gn.labelVertex((the_Target_of Gn).e,e)
              by A8,A9,B1,dAPSTEP;
            (the_Target_of Gn).e in the_Vertices_of Gn
              by B2,GLIB_000:6;
            hence contradiction by C1,C2,GLIB_003:64;
          end;
          suppose e is_backward_labeling_in Gn; then
        C1: (the_Target_of Gn).e in V &
              not (the_Source_of Gn).e in V by dBACKLABEL; then
        C2: Gn = Gn.labelVertex((the_Source_of Gn).e,e)
              by A8,A9,B1,dAPSTEP;
            (the_Source_of Gn).e in the_Vertices_of Gn
              by B2,GLIB_000:6;
            hence contradiction by C1,C2,GLIB_003:64;
          end;
        end;
        hence contradiction;
    end;
X1: now let x be set; assume
    B1: x in E1; then
    B2: A1.x = (the_ELabel_of Gn).x & B1.x = (the_Weight_of Gn).x
          by AX,FUNCT_1:72;
        x DSJoins V, the_Vertices_of G \ V, G by B1,GLIB_000:def 33; then
    B4: x in the_Edges_of Gn &
        (the_Source_of Gn).x in V &
        (the_Target_of Gn).x in the_Vertices_of Gn \ V
        by AY, GLIB_000:def 18; then
    B5: not (the_Target_of Gn).x in V by XBOOLE_0:def 4;
    B6: A1.x <= B1.x by A1,B2,B4,AX,AY,dVFLOW;
        set e = choose AP:NextBestEdges(Gn);
        now assume A1.x < B1.x; then
            x is_forward_labeling_in Gn by B2,B4,B5,dFORLABEL;
            hence contradiction by AA,dAPNEXT;
        end;
        hence A1.x = B1.x by B6,AXIOMS:21;
    end;
    set A2 = (the_ELabel_of G)|E2, B2 = EmptyBag E2;
    now let x be set; assume
    B1: x in E2; then
    B2: A2.x = (the_ELabel_of Gn).x by AX,FUNCT_1:72;
        B2 = E2 --> 0 by POLYNOM1:def 15; then
    B3: B2.x = 0 by B1, FUNCOP_1:13;
        x DSJoins the_Vertices_of G \ V, V, G by B1, GLIB_000:def 33; then
    B5: x in the_Edges_of Gn &
        (the_Source_of Gn).x in the_Vertices_of Gn \ V &
        (the_Target_of Gn).x in V by AY,GLIB_000:def 18; then
    B6: not (the_Source_of Gn).x in V by XBOOLE_0:def 4;
        set e = choose AP:NextBestEdges(Gn);
        now assume 0 < A2.x; then
            x is_backward_labeling_in Gn by B2,B5,B6,dBACKLABEL;
            hence contradiction by AA,dAPNEXT;
        end;
        hence A2.x = B2.x by B3,A1,B2,B5,AX,AY,dVFLOW;
    end; then
    Sum ((the_ELabel_of G) | E2) = Sum B2 by GLIB_004:6; then
X2: Sum ((the_ELabel_of G) | E2) = 0 by UPROOTS:13;
X3: G.flow(source,sink) = Sum ((the_Weight_of G)|E1) by A4,X1,X2,GLIB_004:6;
    now let X be finite real-weighted real-elabeled complete-elabeled WEGraph;
        assume
    B1: X == G & the_Weight_of X = the_Weight_of G &
          X has_valid_flow_from source,sink; then
    B2: the_Vertices_of G = the_Vertices_of X by GLIB_000:def 36;
        reconsider V'=V as Subset of the_Vertices_of X by B1,GLIB_000:def 36;
        set E1' = X.edgesDBetween(V', the_Vertices_of X \ V');
        E1' = E1 by B2,B1, GLIB_000:93; 
        hence X.flow(source,sink) <= G.flow(source,sink)
          by B1,A2,A1,A3,tFLOW02,X3;
    end;
    hence G has_maximum_flow_from source,sink by A1,dGMAXFLOW;
 end;
  
theorem ::tMAXFLOW03
  for G being finite real-weighted WGraph, source, sink being Vertex of G holds
     G == FF:MaxFlow(G,source,sink) &
     the_Weight_of G = the_Weight_of FF:MaxFlow(G,source,sink)  proof
    let G be finite real-weighted WGraph, source,sink be Vertex of G;
    set CS = FF:CompSeq(G,source,sink);
    FF:MaxFlow(G,source,sink) = CS.Result() by dFFMAXFLOW
                             .= CS.(CS.Lifespan()) by GLIB_000:def 58
                             .= CS.->(CS.Lifespan()) by GLIB_000:def 59;
    hence thesis by tFLOWCS02;
end;

theorem ::tMAXFLOW04
  for G being finite natural-weighted WGraph, source,sink being Vertex of G
   st sink <> source holds
   FF:MaxFlow(G,source,sink) has_maximum_flow_from source,sink  proof 
    let G be finite natural-weighted WGraph, source, sink be Vertex of G;
    set CS = FF:CompSeq(G,source,sink); assume
A1: sink <> source;
A2: FF:MaxFlow(G,source,sink) = CS.Result() by dFFMAXFLOW
                             .= CS.(CS.Lifespan()) by GLIB_000:def 58
                             .= CS.->(CS.Lifespan()) by GLIB_000:def 59;
    set n = CS.Lifespan(), Gn = CS.->n, Gn1 = CS.->(n+1);
    consider source',sink' being Vertex of Gn such that
A4: source'=source & sink'=sink & Gn1 = FF:Step(Gn,source',sink') by dFFCS;
    CS is halting by A1,tMAXFLOW01; then
    CS.n = CS.(n+1) by GLIB_000:def 57; then
A5: Gn = CS.(n+1) by GLIB_000:def 59;
A6: Gn has_valid_flow_from source,sink by A1,tFLOWCS01;
    now given P being augmenting Path of Gn such that
    B1: P is_Walk_from source,sink;
    B2: sink in AP:FindAugPath(Gn,source').labeledV() by A4,B1,tAPFAP02; then
    B3: Gn1 = FF:AugmentPath(Gn, AP:GetAugPath(Gn,source',sink'))
          by A4,dFFSTEP;
        set P = AP:GetAugPath(Gn,source',sink');
    B4: P is_Walk_from source',sink'
          by A4,B2,dAPGETAUG; then
        P.first() = source' & P.last() = sink' by GLIB_001:def 23; then
        P is non trivial by A1,A4,GLIB_001:128; then
    B5: 0 < P.tolerance() by tWTOLERANCE01;
        Gn.flow(source',sink') + P.tolerance() = Gn1.flow(source,sink)
          by A1,A4,A6,B3,B4,tFLOWAUG01; then
        Gn.flow(source',sink') + P.tolerance() - P.tolerance() <
          Gn1.flow(source,sink) - 0 by B5,REAL_1:92;
        hence contradiction by A4,A5,GLIB_000:def 59;
      end;
    hence thesis by A1,A2,A6,tMAXFLOW02;
end;
