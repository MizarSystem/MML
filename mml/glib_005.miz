:: Proof of Ford/Fulkerson's Maximum Network Flow Algorithm
::  by Gilbert Lee
::
:: Received February 22, 2005
:: Copyright (c) 2005 Association of Mizar Users

environ

 vocabularies AMI_1, ARYTM, ARYTM_1, ARYTM_3, BOOLE, CARD_1, CAT_1, FINSEQ_1,
      FINSET_1, FUNCOP_1, FUNCT_1, FUNCT_4, GRAPH_1, GRAPH_5, GLIB_000,
      GLIB_001, GLIB_003, GLIB_005, MATRIX_2, MSAFREE2, NAT_1, NEWTON,
      ORDINAL2, PARTFUN1, PBOOLE, POLYNOM1, PRE_TOPC, REALSET1, RELAT_1,
      RLVECT_1, SEQ_1, SEQM_3, SGRAPH1, TREES_1, UPROOTS;
 notations TARSKI, XBOOLE_0, NUMBERS, SUBSET_1, XCMPLX_0, XXREAL_0, XREAL_0,
      DOMAIN_1, REAL_1, RELAT_1, PARTFUN1, FUNCT_1, FINSEQ_1, SEQ_1, CARD_1,
      PBOOLE, CARD_FIL, FUNCT_2, GRAPH_5, ORDINAL1, ORDINAL2, POLYNOM1,
      UPROOTS, RELSET_1, FINSET_1, NAT_1, CQC_LANG, FUNCT_4, PRE_CIRC, SEQM_3,
      GLIB_000, GLIB_001, ABIAN, GLIB_002, GLIB_003;
 constructors GRAPH_5, DOMAIN_1, CARD_FIL, REAL_1, BINOP_2, AMISTD_2, PRE_CIRC,
      UPROOTS, GLIB_002, GLIB_003, XXREAL_0;
 registrations RELSET_1, FINSET_1, XREAL_0, INT_1, ABIAN, FINSEQ_1, NAT_1,
      FUNCOP_1, AMISTD_2, JORDAN1D, MEMBERED, ORDINAL2, POLYNOM1, BAGORDER,
      RFINSEQ, GLIB_000, GLIB_001, GLIB_002, GLIB_003, XXREAL_0;
 definitions GLIB_000, GLIB_003;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 theorems CARD_1, CARD_2, CQC_LANG, FINSEQ_1, FINSEQ_2, FINSEQ_3, FUNCOP_1,
      FUNCT_1, FUNCT_2, FUNCT_4, GLIB_000, GLIB_001, GLIB_003, GLIB_004,
      GRAPH_5, HEYTING3, INT_1, NAT_1, ORDINAL2, PBOOLE, PEPIN, POLYNOM1,
      REAL_1, RELAT_1, SEQ_1, SEQM_3, TARSKI, UPROOTS, XBOOLE_0, XBOOLE_1,
      XREAL_0, ZFMISC_1, XREAL_1, XXREAL_0;
 schemes BINARITH, NAT_1, SUBSET_1, FINSEQ_1, FUNCT_1, RECDEF_1, GRAPH_5;

begin ::Preliminary theorems

registration let x be set, y be real number;
  cluster x.-->y -> real-yielding;
  coherence proof
A1: rng (x.-->y) = {y} by CQC_LANG:5;
    y in REAL by XREAL_0:def 1; then
    rng (x.-->y) c= REAL by A1,ZFMISC_1:37;
    hence thesis by SEQ_1:def 1;
  end;
end;

registration let x be set, y be natural number;
  cluster x --> y -> natural-yielding;
  coherence proof
    now per cases;
      suppose x = {}; then
        rng (x --> y) = {} by FUNCOP_1:16;
        hence rng (x-->y) c= NAT by XBOOLE_1:2;
      end;
      suppose x <> {}; then
    A1: rng (x --> y) = {y} by FUNCOP_1:14;
        y in NAT by ORDINAL2:def 21;
        hence rng (x-->y) c= NAT by A1,ZFMISC_1:37;
      end;
    end;
    hence thesis by SEQM_3:def 8;
  end;
end;

registration let f,g be real-yielding Function;
  cluster f +* g -> real-yielding;
  coherence proof
A1: rng (f +* g) c= rng f \/ rng g by FUNCT_4:18;
    rng f c= REAL & rng g c= REAL by SEQ_1:def 1; then
    rng f \/ rng g c= REAL by XBOOLE_1:8; then
    rng (f +* g) c= REAL by A1,XBOOLE_1:1;
    hence thesis by SEQ_1:def 1;
  end;
end;

begin ::Preliminaries definitions for Maximum Flow Algorithm

definition let G be EGraph;
  attr G is complete-elabeled means :Def1: ::dCMPELABEL
    dom the_ELabel_of G = the_Edges_of G;
end;

registration let G be _Graph, X be ManySortedSet of the_Edges_of G;
  cluster G.set(ELabelSelector, X) -> complete-elabeled;
  coherence proof
    set G2 = G.set(ELabelSelector,X);
    the_ELabel_of G2 = G2.ELabelSelector
                    .= X by GLIB_000:11; then
A1: dom the_ELabel_of G2 = the_Edges_of G by PBOOLE:def 3;
    G2 == G by GLIB_003:8; then
    the_Edges_of G2 = the_Edges_of G by GLIB_000:def 36;
    hence thesis by Def1,A1;
  end;
end;

registration let G be _Graph, Y be non empty set,
                 X be Function of the_Edges_of G, Y;
  cluster G.set(ELabelSelector, X) -> complete-elabeled;
  coherence proof
    set G2 = G.set(ELabelSelector,X);
    the_ELabel_of G2 = G2.ELabelSelector
                    .= X by GLIB_000:11; then
A1: dom the_ELabel_of G2 = the_Edges_of G by FUNCT_2:def 1;
    G2 == G by GLIB_003:8; then
    the_Edges_of G2 = the_Edges_of G by GLIB_000:def 36;
    hence thesis by Def1,A1;
  end;
end;

definition let GSq be EGraphSeq;
  attr GSq is complete-elabeled means :Def2: ::dGSEQCELABEL
    for x being Nat holds GSq.->x is complete-elabeled;
end;

definition let G be WGraph;
  attr G is natural-weighted means :Def3: ::dNATWEIGHT
    the_Weight_of G is natural-yielding;
end;

definition let G be EGraph;
  attr G is natural-elabeled means :Def4: ::dNATELABEL
    the_ELabel_of G is natural-yielding;
end;

definition let GSq be WGraphSeq;
  attr GSq is natural-weighted means :Def5: ::dGSEQNWEIGHT
    for x being Nat holds GSq.->x is natural-weighted;
end;

definition let GSq be EGraphSeq;
  attr GSq is natural-elabeled means :Def6: ::dGSEQNELABEL
    for x being Nat holds GSq.->x is natural-elabeled;
end;

registration
  cluster natural-weighted -> nonnegative-weighted WGraph;
  coherence proof
    let G be WGraph; assume G is natural-weighted; then
A1: the_Weight_of G is natural-yielding by Def3;
    now let y be set; assume
    A2: y in rng the_Weight_of G;
        rng the_Weight_of G c= NAT by A1,SEQM_3:def 8; then
        reconsider y'=y as Nat by A2;
        y' is Real & y' >= 0;
        hence y in Real>=0 by GRAPH_5:def 12;
    end; then
    rng the_Weight_of G c= Real>=0 by TARSKI:def 3;
    hence thesis by GLIB_003:def 14;
  end;
end;

registration
  cluster natural-elabeled -> real-elabeled EGraph;
  coherence proof
    let G be EGraph; assume G is natural-elabeled; then
    reconsider EL = the_ELabel_of G as natural-yielding Function
      by Def4;
    EL is real-yielding;
    hence thesis by GLIB_003:def 15;
  end;
end;

registration
  cluster finite trivial Tree-like natural-weighted
          natural-elabeled complete-elabeled real-vlabeled WEVGraph;
  existence proof
    set V = {1}; set E = {};
    reconsider S = {} as Function of E,V by FUNCT_2:55,RELAT_1:60;
    set G1 = createGraph(V,E,S,S);
    consider WL being Function of the_Edges_of G1, NAT;
    set G2 = G1.set(WeightSelector, WL);
    consider EL being Function of the_Edges_of G2, NAT;
    set G3 = G2.set(ELabelSelector, EL);
    consider VL being PartFunc of the_Vertices_of G3, REAL;
    set G4 = G3.set(VLabelSelector, VL);
    take G4;
    thus G4 is finite & G4 is trivial & G4 is Tree-like;
A1: G4==G3 & G3==G2 & G2==G1 by GLIB_003:8;
    the_Weight_of G4 = G4.WeightSelector
                    .= G3.WeightSelector by GLIB_000:12
                    .= G2.WeightSelector by GLIB_000:12
                    .= WL by GLIB_000:11;
    hence G4 is natural-weighted by Def3;
A2: the_ELabel_of G4 = G4.ELabelSelector
                    .= G3.ELabelSelector by GLIB_000:12
                    .= EL by GLIB_000:11;
    hence G4 is natural-elabeled by Def4;
    dom the_ELabel_of G4 = the_Edges_of G2 by A2,FUNCT_2:def 1
                        .= the_Edges_of G3 by A1,GLIB_000:def 36
                        .= the_Edges_of G4 by A1,GLIB_000:def 36;
    hence G4 is complete-elabeled by Def1;
    thus G4 is real-vlabeled;
  end;
end;

registration
  cluster finite natural-weighted real-WEV natural-elabeled
          complete-elabeled WEVGraphSeq;
  existence proof
    consider G being finite natural-weighted real-WEV natural-elabeled
      complete-elabeled WEVGraph;
    set F = NAT --> G;
A1: dom F = NAT by FUNCOP_1:19;
    reconsider F as ManySortedSet of NAT;
    now let x be Nat;
        F.x in rng F by A1,FUNCT_1:12; then
        F.x in {G} by FUNCOP_1:14;
        hence F.x is _Graph by TARSKI:def 1;
    end; then reconsider F as GraphSeq by GLIB_000:def 55;
    now let x be Nat;
        F.x in rng F by A1, FUNCT_1:12; then
        F.x in {G} by FUNCOP_1:14; then
        F.x = G by TARSKI:def 1;
        hence F.->x is [Weighted] & F.->x is [ELabeled] & F.->x is [VLabeled];
    end; then reconsider F as WEVGraphSeq
      by GLIB_003:def 24,GLIB_003:def 25,GLIB_003:def 26;
    take F;
    now let x be Nat;
        F.x in rng F by A1, FUNCT_1:12; then
        F.x in {G} by FUNCOP_1:14; then
        F.x = G by TARSKI:def 1;
        hence F.->x is finite & F.->x is real-WEV & F.->x is complete-elabeled
          & F.->x is natural-elabeled & F.->x is natural-weighted;
    end;
    hence thesis by GLIB_003:def 31,Def2,GLIB_000:def 60,
      Def6,Def5;
  end;
end;

registration let GSq be complete-elabeled EGraphSeq, x be Nat;
  cluster GSq.->x -> complete-elabeled;
  coherence by Def2;
end;

registration let GSq be natural-elabeled EGraphSeq, x be Nat;
  cluster GSq.->x -> natural-elabeled;
  coherence by Def6;
end;

registration let GSq be natural-weighted WGraphSeq, x be Nat;
  cluster GSq.->x -> natural-weighted;
  coherence by Def5;
end;

registration let G be natural-weighted WGraph;
  cluster the_Weight_of G -> natural-yielding;
  coherence by Def3;
end;

registration let G be natural-elabeled EGraph;
  cluster the_ELabel_of G -> natural-yielding;
  coherence by Def4;
end;

definition let G be complete-elabeled EGraph;
  redefine func the_ELabel_of G -> ManySortedSet of the_Edges_of G;
  coherence proof
    dom the_ELabel_of G = the_Edges_of G by Def1;
    hence thesis by PBOOLE:def 3;
  end;
end;

registration let G be natural-weighted WGraph, X be set;
  cluster G.set(ELabelSelector, X) -> natural-weighted; coherence proof
    set G2 = G.set(ELabelSelector,X);
   the_Weight_of G2 = G2.WeightSelector
                   .= G.WeightSelector by GLIB_000:12
                   .= the_Weight_of G;
    hence thesis by Def3;
  end;
  cluster G.set(VLabelSelector, X) -> natural-weighted; coherence proof
    set G2 = G.set(VLabelSelector,X);
    the_Weight_of G2 = G2.WeightSelector
                    .= G.WeightSelector by GLIB_000:12
                    .= the_Weight_of G;
    hence thesis by Def3;
  end;
end;

registration let G be _Graph,
                 X be natural-yielding ManySortedSet of the_Edges_of G;
  cluster G.set(ELabelSelector, X) -> natural-elabeled;
  coherence proof
    set G2 = G.set(ELabelSelector, X);
    the_ELabel_of G2 = G2.ELabelSelector
                    .= X by GLIB_000:11;
    hence thesis by Def4;
  end;
end;

definition let G be finite real-weighted
                    real-elabeled complete-elabeled WEGraph,
               source,sink be set;
  pred G has_valid_flow_from source,sink means :Def7: ::dVFLOW
     source is Vertex of G & sink is Vertex of G &
     (for e being set st e in the_Edges_of G holds
        0 <= (the_ELabel_of G).e &
             (the_ELabel_of G).e <= (the_Weight_of G).e) &
     (for v being Vertex of G st v <> source & v <> sink holds
       Sum ((the_ELabel_of G) | v.edgesIn()) =
       Sum ((the_ELabel_of G) | v.edgesOut()));
end;

definition let G be finite real-weighted real-elabeled
                    complete-elabeled WEGraph, source, sink be set; assume
 G has_valid_flow_from source,sink; ::
  func G.flow(source,sink) -> real number equals :Def8: ::dGFLOW
    Sum ((the_ELabel_of G) | G.edgesInto({sink})) -
    Sum ((the_ELabel_of G) | G.edgesOutOf({sink}));
  coherence;
end;

definition let G be finite real-weighted real-elabeled
                    complete-elabeled WEGraph, source,sink be set;
  pred G has_maximum_flow_from source,sink means :Def9: ::dGMAXFLOW
    G has_valid_flow_from source,sink &
    for G2 being finite real-weighted real-elabeled complete-elabeled WEGraph
     st G2 == G & the_Weight_of G = the_Weight_of G2 &
        G2 has_valid_flow_from source,sink holds
        G2.flow(source,sink) <= G.flow(source,sink);
end;

definition let G be real-weighted real-elabeled WEVGraph, e be set;
  pred e is_forward_labeling_in G means :Def10: ::dFORLABEL
    e in the_Edges_of G &
    (the_Source_of G).e in G.labeledV() &
    not (the_Target_of G).e in G.labeledV() &
    (the_ELabel_of G).e < (the_Weight_of G).e;
end;

definition let G be real-elabeled EVGraph, e be set;
  pred e is_backward_labeling_in G means :Def11: ::dBACKLABEL
    e in the_Edges_of G &
    (the_Target_of G).e in G.labeledV() &
    not (the_Source_of G).e in G.labeledV() &
    0 < (the_ELabel_of G).e;
end;

definition let G be real-weighted real-elabeled WEGraph, W be Walk of G;
  attr W is augmenting means :Def12: ::dWAUGMENT
   for n being odd Nat st n < len W holds
     (W.(n+1) DJoins W.n, W.(n+2), G implies
       (the_ELabel_of G).(W.(n+1)) < (the_Weight_of G).(W.(n+1))) &
     (not W.(n+1) DJoins W.n,W.(n+2), G implies
       0 < (the_ELabel_of G).(W.(n+1)));
end;

registration let G be real-weighted real-elabeled WEGraph;
  cluster trivial -> augmenting Walk of G;
  coherence proof
    let W be Walk of G; assume
A1: W is trivial;
    now let n be odd Nat; assume n < len W; then
        n < 1 by A1,GLIB_001:127;
        hence (W.(n+1) DJoins W.n, W.(n+2), G implies
          (the_ELabel_of G).(W.(n+1)) < (the_Weight_of G).(W.(n+1))) &
          (not W.(n+1) DJoins W.n,W.(n+2), G implies
          0 < (the_ELabel_of G).(W.(n+1))) by HEYTING3:1;
    end;
    hence W is augmenting by Def12;
  end;
end;

registration let G be real-weighted real-elabeled WEGraph;
  cluster vertex-distinct augmenting Path of G;
  existence proof
    consider P being trivial Path of G;
    take P;
    thus thesis;
  end;
end;

registration let G be real-weighted real-elabeled WEGraph,
                 W be augmenting Walk of G, m,n be Nat;
  cluster W.cut(m,n) -> augmenting;
  coherence proof
    set W2 = W.cut(m,n);
    now per cases;
      suppose
    A1: (m is odd & n is odd & m <= n & n <= len W); then
        reconsider m'=m as odd Nat;
        now let x be odd Nat; assume x < len W2; then
        A2: x in dom W2 & x+1 in dom W2 & x+2 in dom W2 by GLIB_001:13;
            set v1b = W2.x, eb = W2.(x+1), v2b = W2.(x+2);
        A3: W2.x = W.(m+x-1) & (m+x-1) in dom W &
            W2.(x+1) = W.(m+(x+1)-1) & (m+(x+1)-1) in dom W &
            W2.(x+2) = W.(m+(x+2)-1) & (m+(x+2)-1) in dom W
              by A1,A2,GLIB_001:48; then
            reconsider a = m'+x-1,a1 = m+(x+1)-1,a2=m+(x+2)-1 as Nat;
            reconsider a as odd Nat;
            set v1a = W.a, ea = W.(a+1), v2a = W.(a+2);
            a2 <= len W by A3,FINSEQ_3:27; then
        A4: m+(x+2)-1-2 < len W - 0 by REAL_1:92;
            hereby assume eb DJoins v1b,v2b,G; then
                ea DJoins v1a,v2a,G by A3;
                hence (the_ELabel_of G).eb < (the_Weight_of G).eb
                  by A3,A4,Def12;
            end;
            assume not eb DJoins v1b,v2b,G; then
            not ea DJoins v1a,v2a,G by A3;
            hence 0 < (the_ELabel_of G).eb by A3,A4,Def12;
        end;
        hence thesis by Def12;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by GLIB_001:def 11;
      end;
    end;
   hence thesis;
  end;
end;

theorem ::tWAUGMENT01
  for G1,G2 being real-weighted real-elabeled WEGraph, W1 being Walk of G1,
      W2 being Walk of G2
   st W1 is augmenting & G1 == G2 & the_Weight_of G1 = the_Weight_of G2 &
      the_ELabel_of G1 = the_ELabel_of G2 & W1 = W2 holds
      W2 is augmenting proof
    let G1,G2 be real-weighted real-elabeled WEGraph, W1 be Walk of G1,
        W2 be Walk of G2; assume
A1: W1 is augmenting & G1 == G2 & the_Weight_of G1 = the_Weight_of G2 &
    the_ELabel_of G1 = the_ELabel_of G2 & W1 = W2;
    let n be odd Nat; assume
    n < len W2; then
    (W2.(n+1) DJoins W2.n, W2.(n+2), G1 implies
       (the_ELabel_of G2).(W2.(n+1)) < (the_Weight_of G2).(W2.(n+1))) &
     (not W2.(n+1) DJoins W2.n, W2.(n+2), G1 implies
       0 < (the_ELabel_of G2).(W2.(n+1))) by Def12,A1;
    hence thesis by A1,GLIB_000:91;
end;

theorem Th2: ::tWAUGMENT02
  for G being real-weighted real-elabeled WEGraph,
      W being augmenting Walk of G, e,v being set
   st not v in W.vertices() &
      ((e DJoins W.last(),v,G & (the_ELabel_of G).e < (the_Weight_of G).e) or
       (e DJoins v,W.last(),G & 0 < (the_ELabel_of G).e))
   holds W.addEdge(e) is augmenting proof
    let G be real-weighted real-elabeled WEGraph,
        W be augmenting Walk of G, e,v be set;
    set W2 = W.addEdge(e); assume
A1: not v in W.vertices() &
    ((e DJoins W.last(),v,G & (the_ELabel_of G).e < (the_Weight_of G).e) or
     (e DJoins v,W.last(),G & 0 < (the_ELabel_of G).e));
    let n be odd Nat; assume
A2: n < len W2;
A3: e Joins W.last(),v,G by A1,GLIB_000:19;
    now per cases;
      suppose
    A4: n < len W; then
        n in dom W & n+1 in dom W & n+2 in dom W by GLIB_001:13; then
        W.n = W2.n & W.(n+1) = W2.(n+1) & W.(n+2) = W2.(n+2)
          by A3,GLIB_001:66;
        hence (W2.(n+1) DJoins W2.n, W2.(n+2), G implies
          (the_ELabel_of G).(W2.(n+1)) < (the_Weight_of G).(W2.(n+1))) &
        (not W2.(n+1) DJoins W2.n, W2.(n+2),G implies
          0 < (the_ELabel_of G).(W2.(n+1))) by A4,Def12;
      end;
      suppose
    A5: n >= len W;
        n+1 <= len W2 by A2,NAT_1:38; then
        n+1 <= len W + 2*1 by A3,GLIB_001:65; then
        n+1 < len W + 1+1 by REAL_1:def 5; then
        n+1 <= len W + 1 by NAT_1:38; then
        n <= len W by XREAL_1:8; then
    A6: 1 <= n & n = len W by A5, HEYTING3:1, XXREAL_0:1; then
        n in dom W by FINSEQ_3:27; then
    A7: W2.n = W.n by A3,GLIB_001:66
            .= W.last() by A6,GLIB_001:def 7;
    A8: W2.(n+1) = e & W2.(n+2) = v by A3,A6,GLIB_001:66;
    A9: now assume e DJoins W.last(),v,G & e DJoins v,W.last(),G; then
            (the_Source_of G).e = W.last() &
              (the_Source_of G).e = v by GLIB_000:def 16;
            hence contradiction by A1,GLIB_001:89;
        end;
        thus W2.(n+1) DJoins W2.n, W2.(n+2),G implies
          (the_ELabel_of G).(W2.(n+1)) < (the_Weight_of G).(W2.(n+1))
          by A1,A7,A8,A9;
        assume not W2.(n+1) DJoins W2.n, W2.(n+2),G;
        hence 0 < (the_ELabel_of G).(W2.(n+1)) by A1,A7,A8;
      end;
    end;
    hence thesis;
end;

begin :: Finding an Augmenting Path in a Graph
definition let G be real-weighted real-elabeled WEVGraph;
  func AP:NextBestEdges(G) -> Subset of the_Edges_of G means :Def13: ::dAPNEXT
     for e being set holds e in it iff
     (e is_forward_labeling_in G or e is_backward_labeling_in G);
  existence proof
    defpred P[set] means $1 is_forward_labeling_in G or
                         $1 is_backward_labeling_in G;
    consider IT being Subset of the_Edges_of G such that
A1: for e being set holds e in IT iff e in the_Edges_of G & P[e]
      from SUBSET_1:sch 1;
    take IT;
    let e be set;
    thus e in IT implies P[e] by A1;
    assume
A2: P[e]; then
    e in the_Edges_of G by Def10,Def11;
    hence e in IT by A1,A2;
  end;
  uniqueness proof
    let IT1,IT2 be Subset of the_Edges_of G such that
A3: for e being set holds e in IT1 iff
    (e is_forward_labeling_in G or e is_backward_labeling_in G) and
A4: for e being set holds e in IT2 iff
    (e is_forward_labeling_in G or e is_backward_labeling_in G);
    now let e be set;
        hereby assume e in IT1; then
            (e is_forward_labeling_in G or e is_backward_labeling_in G) by A3;
            hence e in IT2 by A4;
        end;
        assume e in IT2; then
        (e is_forward_labeling_in G or e is_backward_labeling_in G) by A4;
        hence e in IT1 by A3;
    end;
    hence IT1 = IT2 by TARSKI:2;
  end;
end;

definition let G be real-weighted real-elabeled WEVGraph;
  set e = choose AP:NextBestEdges(G);
  func AP:Step(G) -> real-weighted real-elabeled WEVGraph equals :Def14: ::dAPSTEP
     G if AP:NextBestEdges(G) = {},
     G.labelVertex((the_Source_of G).e, e) if
          AP:NextBestEdges(G) <> {} &
          not (the_Source_of G).e in G.labeledV() otherwise
     G.labelVertex((the_Target_of G).e, e);
  coherence;
  consistency;
end;

registration let G be finite real-weighted real-elabeled WEVGraph;
  cluster AP:Step(G) -> finite;
  coherence proof
    set e = choose AP:NextBestEdges(G), G2 = AP:Step(G);
    now per cases;
      suppose AP:NextBestEdges(G) = {};
        hence thesis by Def14;
      end;
      suppose AP:NextBestEdges(G) <> {} &
          not (the_Source_of G).e in G.labeledV(); then
        G2 = G.labelVertex((the_Source_of G).e, e) by Def14;
        hence thesis;
      end;
      suppose AP:NextBestEdges(G)<>{} &
        (the_Source_of G).e in G.labeledV(); then
        G2 = G.labelVertex((the_Target_of G).e, e) by Def14;
        hence thesis;
      end;
   end;
   hence thesis;
  end;
end;

definition let G be real-weighted real-elabeled WEGraph, source be Vertex of G;
  func AP:CompSeq(G,source) -> real-weighted real-elabeled WEVGraphSeq means
:Def15: ::dAPCS
    it.->0 = G.set(VLabelSelector, source .--> 1) &
    for n being Nat holds it.->(n+1) = AP:Step(it.->n);
  existence proof
    defpred P[set,set,set] means
      ($2 is real-weighted real-elabeled WEVGraph &
        ex Gn,Gn1 being real-weighted real-elabeled WEVGraph st
          $2 = Gn & $3 = Gn1 & Gn1 = AP:Step(Gn)) or
      (not $2 is real-weighted real-elabeled WEVGraph & $2 = $3);
    now let n,x be set;
        now per cases;
          suppose
            x is real-weighted real-elabeled WEVGraph; then
            reconsider Gn=x as real-weighted real-elabeled WEVGraph;
            P[n,x,AP:Step(Gn)];
            hence ex y being set st P[n,x,y];
          end;
          suppose not x is real-weighted real-elabeled WEVGraph;
            hence ex y being set st P[n,x,y];
          end;
        end;
        hence ex y being set st P[n,x,y];
    end; then
A1: for n being Nat for x being set ex y being set st P[n,x,y];
A2: for n being Nat for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2]
      holds y1 = y2;
    consider IT being Function such that
A3: dom IT = NAT & IT.0 = G.set(VLabelSelector, source.-->1) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
      from RECDEF_1:sch 1(A1,A2);
    reconsider IT as ManySortedSet of NAT by A3, PBOOLE:def 3;
    defpred P2[Nat] means IT.$1 is real-weighted real-elabeled WEVGraph;
A4: P2[0] by A3;
A5: now let n be Nat; assume
     P2[n]; then
        consider Gn,Gn1 being real-weighted real-elabeled WEVGraph such that
    A6: IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = AP:Step(Gn) by A3;
        thus P2[n+1] by A6;
    end;
A7: for n being Nat holds P2[n] from NAT_1:sch 1(A4,A5); then
    for n being Nat holds IT.n is _Graph; then
    reconsider IT as GraphSeq by GLIB_000:def 55;
A8: now let n be Nat;
        thus IT.->n is real-weighted real-elabeled WEVGraph by A7;
    end; then
    for n being Nat holds
      IT.->n is [Weighted] & IT.->n is [ELabeled] & IT.->n is [VLabeled]; then
    reconsider IT as WEVGraphSeq
      by GLIB_003:def 24,GLIB_003:def 25,GLIB_003:def 26;
    for n being Nat holds IT.->n is real-weighted &
      IT.->n is real-elabeled by A8; then
    reconsider IT as real-weighted real-elabeled WEVGraphSeq
      by GLIB_003:def 27,GLIB_003:def 29;
    take IT;
    thus IT.->0 = G.set(VLabelSelector,source.-->1) by A3;
    let n be Nat;
    IT.n is real-weighted real-elabeled WEVGraph by A7; then
    consider Gn,Gn1 being real-weighted real-elabeled WEVGraph such that
A9: IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = AP:Step(Gn) by A3;
    thus IT.->(n+1) = AP:Step(IT.->n) by A9;
end;
  uniqueness proof
    let IT1,IT2 be real-weighted real-elabeled WEVGraphSeq such that
A10: IT1.->0 = G.set(VLabelSelector, source.-->1) &
    for n being Nat holds IT1.->(n+1) = AP:Step(IT1.->n) and
A11: IT2.->0 = G.set(VLabelSelector, source.-->1) &
    for n being Nat holds IT2.->(n+1) = AP:Step(IT2.->n);
    defpred P[Nat] means IT1.$1 = IT2.$1;
    IT1.0 = IT2.->0 by A10,A11; then
A12: P[0];
    now let n be Nat; assume P[n]; then
    A13: IT1.n = IT2.->n;
        IT1.->(n+1) = AP:Step(IT1.->n) by A10
                   .= AP:Step(IT2.->n) by A13
                   .= IT2.->(n+1) by A11; then
        IT1.(n+1) = IT2.->(n+1);
        hence P[n+1];
    end; then
A14: for n being Nat st P[n] holds P[n+1];
    for n being Nat holds P[n] from NAT_1:sch 1(A12,A14); then
    for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

registration let G be finite real-weighted real-elabeled WEGraph,
               source be Vertex of G;
  cluster AP:CompSeq(G,source) -> finite;
  coherence proof
    set CS = AP:CompSeq(G,source);
    defpred P[Nat] means CS.->$1 is finite;
    CS.->0 = G.set(VLabelSelector,source.-->1) &
    for n being Nat holds CS.->(n+1) = AP:Step(CS.->n) by Def15; then
A1: P[0];
A2: now let n be Nat; assume
     P[n]; then
        reconsider Gn = CS.->n as finite real-weighted real-elabeled WEVGraph;
        CS.->(n+1) = AP:Step(Gn) by Def15;
        hence P[n+1];
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis by GLIB_000:def 60;
  end;
end;

theorem Th3: ::tAPCS01
  for G being real-weighted real-elabeled WEGraph,
      source being Vertex of G holds
     G == AP:CompSeq(G,source).->0 &
     the_Weight_of G = the_Weight_of (AP:CompSeq(G,source).->0) &
     the_ELabel_of G = the_ELabel_of (AP:CompSeq(G,source).->0) &
     (AP:CompSeq(G,source).->0).labeledV() = {source} proof
    let G be real-weighted real-elabeled WEGraph, source be Vertex of G;
    set G0 = AP:CompSeq(G,source).->0;
A1: G0 = G.set(VLabelSelector, source .--> 1) by Def15;
    hence G == G0 by GLIB_003:8;
    thus the_Weight_of G = the_Weight_of G0 by A1,GLIB_000:12;
    thus the_ELabel_of G = the_ELabel_of G0 by A1,GLIB_000:12;
A2: the_VLabel_of G0 = G0.VLabelSelector
                    .= source .--> 1 by A1,GLIB_000:11;
    dom (source.-->1) = {source} by CQC_LANG:5;
    hence G0.labeledV() = {source} by A2;
end;

theorem Th4: ::tAPCS02
  for G being real-weighted real-elabeled WEGraph,
      source being Vertex of G, i,j being Nat
   st i <= j holds (AP:CompSeq(G,source).->i).labeledV() c=
                   (AP:CompSeq(G,source).->j).labeledV() proof
    let G be real-weighted real-elabeled WEGraph, source be Vertex of G,
        i,j be Nat; set CS = AP:CompSeq(G,source); assume
A1: i <= j;
    defpred P[Nat] means (CS.->i).labeledV() c= (CS.->(i+$1)).labeledV();
A2: P[0];
A3: now let n be Nat; set Gn = (CS.->(i+n)), Gn1 = (CS.->(i+(n+1)));
        set Next = AP:NextBestEdges(Gn), e = choose Next; assume
    A4: P[n];
        Gn1 = (CS.->(i+n+1)); then
    A5: Gn1 = AP:Step(Gn) by Def15;
        now per cases;
          suppose Next = {};
            hence P[n+1] by A4,A5,Def14;
          end;
          suppose
        A6: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV(); then
            e in Next; then
        A7: (the_Source_of Gn).e in the_Vertices_of Gn by FUNCT_2:7;
            Gn1 = Gn.labelVertex((the_Source_of Gn).e, e) by A5,A6,Def14;then
            Gn.labeledV() c= Gn1.labeledV() by A7, GLIB_003:60;
            hence P[n+1] by A4,XBOOLE_1:1;
          end;
          suppose
        A8: Next <> {} & (the_Source_of Gn).e in Gn.labeledV(); then
            e in Next; then
        A9: (the_Target_of Gn).e in the_Vertices_of Gn by FUNCT_2:7;
            Gn1 = Gn.labelVertex((the_Target_of Gn).e, e) by A5,A8,Def14;then
            Gn.labeledV() c= Gn1.labeledV() by A9, GLIB_003:60;
            hence P[n+1] by A4,XBOOLE_1:1;
          end;
        end;
        hence P[n+1];
    end;
A10: for n being Nat holds P[n] from NAT_1:sch 1(A2,A3);
    consider k being Nat such that
A11: j = i+k by A1,NAT_1:28;
    thus thesis by A10,A11;
end;

theorem Th5: ::tAPCS04
   for G being real-weighted real-elabeled WEGraph,
       source being Vertex of G, n being Nat holds
     G == AP:CompSeq(G,source).->n &
     the_Weight_of G = the_Weight_of (AP:CompSeq(G,source).->n) &
     the_ELabel_of G = the_ELabel_of (AP:CompSeq(G,source).->n) proof
    let G be real-weighted real-elabeled WEGraph,
        source be Vertex of G; set CS = AP:CompSeq(G,source);
    defpred P[Nat] means CS.->$1 == G &
      the_Weight_of (CS.->$1) = the_Weight_of G &
      the_ELabel_of (CS.->$1) = the_ELabel_of G;
A1: P[0] by Th3;
A2: now let n be Nat; assume
    A3: P[n]; set Gn = CS.->n, Gn1 = CS.->(n+1);
        set Next = AP:NextBestEdges(Gn), e = choose Next;
    A4: Gn1 = AP:Step(Gn) by Def15;
        now per cases;
          suppose Next = {};
            hence P[n+1] by A3,A4,Def14;
          end;
          suppose Next <> {} & not (the_Source_of Gn).e in Gn.labeledV(); then
        A5: Gn1 = Gn.labelVertex((the_Source_of Gn).e,e) by A4,Def14; then
            Gn1 == Gn by GLIB_003:47;
            hence P[n+1] by A3,A5,GLIB_003:48,GLIB_003:49,GLIB_000:88;
          end;
          suppose Next <> {} & (the_Source_of Gn).e in Gn.labeledV(); then
        A6: Gn1 = Gn.labelVertex((the_Target_of Gn).e,e) by A4,Def14; then
            Gn1 == Gn by GLIB_003:47;
            hence P[n+1] by A3,A6,GLIB_003:48,GLIB_003:49,GLIB_000:88;
          end;
        end;
        hence P[n+1];
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis;
end;

definition let G be real-weighted real-elabeled WEGraph, source be Vertex of G;
  func AP:FindAugPath(G,source) -> real-weighted real-elabeled WEVGraph equals
 ::dAPFAUGP
    AP:CompSeq(G,source).Result();
  coherence proof
    set CS = AP:CompSeq(G,source);
    CS.Result() = CS.(CS.Lifespan())
               .= CS.->(CS.Lifespan());
    hence thesis;
  end;
end;

theorem Th6: ::tAPFAP01
  for G being finite real-weighted real-elabeled WEGraph,
      source being Vertex of G
    holds AP:CompSeq(G,source) is halting proof
    let G be finite real-weighted real-elabeled WEGraph, source be Vertex of G;
    set CS = AP:CompSeq(G,source);
    now assume
    A1: for n being Nat holds CS.n <> CS.(n+1);
        defpred P[Nat] means card (CS.->$1).labeledV() = $1+1;
        (CS.->0).labeledV() = {source} by Th3; then
    A2: P[0] by CARD_1:79;
    A3: now let n be Nat; assume
        A4: P[n];
            set Gn = CS.->n, Gn1 = CS.->(n+1);
        A5: Gn1 = AP:Step(Gn) by Def15;
            set Next = AP:NextBestEdges(Gn), e = choose Next;
            now per cases;
              suppose Next = {}; then
                 Gn1 = Gn by A5,Def14; then
                 Gn = CS.(n+1); then
                 CS.n = CS.(n+1);
                 hence P[n+1] by A1;
              end;
              suppose
            A6: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV(); then
            A7: Gn1 = Gn.labelVertex((the_Source_of Gn).e,e) by A5,Def14;
                e in Next by A6; then
                (the_Source_of Gn).e in the_Vertices_of Gn by FUNCT_2:7;
                hence P[n+1] by A4,A6,A7,GLIB_003:61;
              end;
              suppose
              A8: Next <> {} & (the_Source_of Gn).e in Gn.labeledV(); then
              A9: Gn1 = Gn.labelVertex((the_Target_of Gn).e,e) by A5,Def14;
              A10: e in Next by A8;
                  e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
                    by A8,Def13; then
              A11: not (the_Target_of Gn).e in Gn.labeledV()
                    by A8,Def11,Def10;
                  (the_Target_of Gn).e in the_Vertices_of Gn
                    by A10,FUNCT_2:7;
                  hence P[n+1] by A4,A9,A11,GLIB_003:61;
              end;
            end;
            hence P[n+1];
        end;
    A12: for n being Nat holds P[n] from NAT_1:sch 1(A2,A3);
        set x = card the_Vertices_of G;
    A13: card (CS.->x).labeledV() = card the_Vertices_of G + 1 by A12;
        (CS.->x) == G by Th5; then
        the_Vertices_of G = the_Vertices_of (CS.->x) by GLIB_000:def 36; then
        1+card the_Vertices_of G<=card the_Vertices_of G+0 by A13,CARD_1:80;
        hence contradiction by XREAL_1:8;
    end;
    hence CS is halting by GLIB_000:def 56;
end;

theorem Th7: ::tAPCS05
  for G being finite real-weighted real-elabeled WEGraph,
      source being Vertex of G, n being Nat, v being set
      st v in (AP:CompSeq(G,source).->n).labeledV() holds
      (the_VLabel_of (AP:CompSeq(G,source).->n)).v =
      (the_VLabel_of AP:FindAugPath(G,source)).v proof
    let G be finite real-weighted real-elabeled WEGraph,source be Vertex of G,
        n be Nat, v be set;
    set CS = AP:CompSeq(G,source), FAP = AP:FindAugPath(G,source);
    set L = CS.Lifespan(), GL = CS.->L, GL1 = CS.->(L+1); assume
A1: v in (CS.->n).labeledV();
    defpred P[Nat] means
      for v being set st v in (CS.->n).labeledV() holds
        (the_VLabel_of (CS.->n)).v = (the_VLabel_of (CS.->(n+$1))).v;
A2: P[0];
    now let k be Nat; assume
    A3: P[k]; set Gn = CS.->(n+k), Gn1 = CS.->(n+k+1);
    A4: Gn1 = AP:Step(Gn) by Def15;
        set Next = AP:NextBestEdges(Gn), e = choose Next;
        now per cases;
          suppose Next = {}; then
            Gn1 = Gn by A4,Def14;
            hence P[k+1] by A3;
          end;
          suppose
        A5: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV(); then
        A6: Gn1 = Gn.labelVertex((the_Source_of Gn).e, e) by A4,Def14;
            now let v be set; assume
            A7: v in (CS.->n).labeledV(); then
            A8: (the_VLabel_of (CS.->n)).v = (the_VLabel_of Gn).v by A3;
                n <= n+k by NAT_1:29; then
                (CS.->n).labeledV() c= Gn.labeledV() by Th4; then
                v <> (the_Source_of Gn).e by A5,A7;
                hence (the_VLabel_of (CS.->n)).v = (the_VLabel_of Gn1).v
                  by A6,A8,GLIB_003:50;
            end;
            hence P[k+1];
          end;
          suppose
        A9: Next <> {} & (the_Source_of Gn).e in Gn.labeledV(); then
        A10: Gn1 = Gn.labelVertex((the_Target_of Gn).e, e) by A4,Def14;
        A11: e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by A9,Def13;
            now let v be set; assume
            A12: v in (CS.->n).labeledV(); then
            A13: (the_VLabel_of (CS.->n)).v = (the_VLabel_of Gn).v by A3;
                n <= n+k by NAT_1:29; then
                (CS.->n).labeledV() c= Gn.labeledV() by Th4; then
                v <> (the_Target_of Gn).e by A9,A11,A12,Def11,Def10;
                hence (the_VLabel_of (CS.->n)).v = (the_VLabel_of Gn1).v
                  by A10,A13,GLIB_003:50;
            end;
            hence P[k+1];
          end;
        end;
        hence P[k+1];
    end; then
A14: for k being Nat st P[k] holds P[k+1];
A15: for k being Nat holds P[k] from NAT_1:sch 1(A2,A14);
A16: FAP = CS.Result()
       .= CS.L
       .= GL;
    CS is halting by Th6; then
    CS.L = CS.(L+1) by GLIB_000:def 57; then
A17: GL = CS.(L+1)
      .= GL1;
    defpred P2[Nat] means GL = CS.->(L+$1);
A18: P2[0];
A19: now let k be Nat; set Gn1 = CS.->(L+k+1); assume P2[k]; then
        Gn1 = AP:Step(GL) by Def15
           .= GL1 by Def15;
        hence P2[k+1] by A17;
    end;
A20: for k being Nat holds P2[k] from NAT_1:sch 1(A18,A19);
    now per cases;
      suppose n <= CS.Lifespan(); then consider k being Nat such that
    A21: n + k = CS.Lifespan() by NAT_1:28;
        thus thesis by A1,A15,A21,A16;
      end;
      suppose CS.Lifespan() < n; then consider k being Nat such that
    A22: CS.Lifespan() + k = n by NAT_1:28;
        thus thesis by A20,A22;
      end;
    end;
    hence thesis;
end;

definition let G be finite real-weighted real-elabeled WEGraph,
               source,sink be Vertex of G;
  func AP:GetAugPath(G,source,sink) -> vertex-distinct
                                       augmenting Path of G means :Def17: ::dAPGETAUG
    it is_Walk_from source,sink &
    for n being even Nat st n in dom it holds
      it.n = (the_VLabel_of AP:FindAugPath(G,source)).(it.(n+1)) if
    (sink in AP:FindAugPath(G,source).labeledV()) otherwise
    it = G.walkOf(source);
  existence proof
    set CS = AP:CompSeq(G,source), FAP = AP:FindAugPath(G,source);
A1: FAP = CS.Result()
       .= CS.(CS.Lifespan())
       .= CS.->(CS.Lifespan());
    defpred P[Nat] means
      for v being set st v in (CS.->$1).labeledV() holds
       ex P being vertex-distinct augmenting Path of G st
          P is_Walk_from source,v &
          P.vertices() c= (CS.->$1).labeledV() &
          for n being even Nat st n in dom P holds
            P.n = (the_VLabel_of FAP).(P.(n+1));
    now let v be set; assume v in (CS.->0).labeledV(); then
        v in {source} by Th3; then
    A2: v = source by TARSKI:def 1;
        set P = G.walkOf(source);
        take P;
        thus P is_Walk_from source,v by A2,GLIB_001:14;
        P.vertices() = {source} by GLIB_001:91;
        hence P.vertices() c= (CS.->0).labeledV() by Th3;
        let n be even Nat; assume n in dom P; then
    A3: 1 <= n & n <= len P by FINSEQ_3:27; then
        n < len P by REAL_1:def 5;
        hence P.n = (the_VLabel_of FAP).(P.(n+1)) by A3,GLIB_001:14;
    end; then
A4: P[0];
    now let n be Nat; assume
    A5: P[n]; set Gn = CS.->n, Gn1 = CS.->(n+1);
        set Next = AP:NextBestEdges(Gn), e = choose Next;
    A6: Gn1 = AP:Step(Gn) by Def15;
    A7: Gn == G & the_ELabel_of Gn = the_ELabel_of G &
          the_Weight_of Gn = the_Weight_of G by Th5;
        source in {source} by TARSKI:def 1; then
    A8: source in (CS.->0).labeledV() by Th3;
    A9: (CS.->0).labeledV() c= Gn.labeledV() by Th4;
        now per cases;
          suppose Next = {}; then
             Gn1 = Gn by A6,Def14;
            hence P[n+1] by A5;
          end;
          suppose
        A10: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV(); then
        A11: Gn1 = Gn.labelVertex((the_Source_of Gn).e, e) by A6,Def14;
        A12: e in Next by A10;
            e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by A10,Def13; then
        A13: (the_Target_of Gn).e in Gn.labeledV() &
              0 < (the_ELabel_of Gn).e by A10,Def10,Def11;
        A14: (the_Source_of Gn).e in the_Vertices_of Gn by A12,FUNCT_2:7; then
        A15: Gn1.labeledV() = Gn.labeledV() \/ {(the_Source_of Gn).e}
              by A11,GLIB_003:59;
            now let v be set; assume
            A16: v in Gn1.labeledV();
                now per cases by A16,A15,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV(); then consider P being
                      vertex-distinct augmenting Path of G such that
                A17: P is_Walk_from source,v & P.vertices() c= Gn.labeledV() &
                    for n being even Nat st n in dom P holds
                    P.n = (the_VLabel_of FAP).(P.(n+1)) by A5;
                    take P;
                    n <= n+1 by NAT_1:29; then
                    Gn.labeledV() c= Gn1.labeledV() by Th4;
                    hence P is_Walk_from source,v &
                      P.vertices()c= Gn1.labeledV() &
                      for n being even Nat st n in dom P holds
                        P.n = (the_VLabel_of FAP).(P.(n+1)) by A17,XBOOLE_1:1;
                  end;
                  suppose
                A18: v in {(the_Source_of Gn).e}; then
                A19: v = (the_Source_of Gn).e by TARSKI:def 1;
                    now per cases;
                      suppose
                    A20: source = (the_Target_of Gn).e;
                        set W2 = G.walkOf(source,e,(the_Source_of Gn).e);
                        e Joins source,(the_Source_of Gn).e,Gn
                          by A12,A20,GLIB_000:def 15; then
                    A21: e Joins source,(the_Source_of Gn).e,G
                          by A7,GLIB_000:91; then
                    A22: W2 = <* source, e, (the_Source_of Gn).e *>
                          by GLIB_001:def 5; then
                    A23: len W2 = 3 & W2.1 = source & W2.2 = e &
                          W2.3 = (the_Source_of Gn).e by FINSEQ_1:62;
                        now let n be odd Nat; assume n < len W2; then
                            n < 2+1 by A22,FINSEQ_1:62; then
                            n <= 2*1 by NAT_1:38; then
                            n < 1+1 by REAL_1:def 5; then
                            1 <= n & n <= 1 by NAT_1:38,HEYTING3:1; then
                        A24: n = 1 by XXREAL_0:1;
                            hereby assume W2.(n+1) DJoins W2.n,W2.(n+2),G; then
                                e DJoins source,(the_Source_of Gn).e,Gn
                                  by A23,A24,A7,GLIB_000:91;
                                hence (the_ELabel_of G).(W2.(n+1)) <
                                  (the_Weight_of G).(W2.(n+1))
                                  by A10,A13,GLIB_000:def 16;
                            end;
                            assume not W2.(n+1) DJoins W2.n,W2.(n+2),G;
                            thus 0 < (the_ELabel_of G).(W2.(n+1))
                              by A7,A13,A22,FINSEQ_1:62,A24;
                        end; then
                        reconsider W2 as augmenting Path of G by Def12;
                    A25: now let m be odd Nat; assume
                        A26: m <= len W2;
                        A27: 1 <= m by HEYTING3:1;
                            now assume m <> 1; then
                                2*0+1 < m by A27,REAL_1:def 5; then
                                1+2 <= m by GLIB_001:1;
                                hence m = 3 by A23,A26,XXREAL_0:1;
                            end;
                            hence m = 1 or m = 3;
                        end;
                        now let m,n be odd Nat; assume
                        A28: m <= len W2 & n <= len W2 & W2.m = W2.n; then
                            (m = 1 or m = 3) & (n = 1 or n = 3) by A25;
                            hence m = n by A8,A9,A10,A23,A28;
                        end; then
                        reconsider W2 as vertex-distinct augmenting Path of G
                          by GLIB_001:def 29;
                        take W2;
                        thus W2 is_Walk_from source,v by A19,A21,GLIB_001:16;
                    A29: W2.vertices() = {source,v} by A19,A21,GLIB_001:92;
                        now let x be set; assume
                        A30: x in W2.vertices();
                            now per cases by A29,A30,TARSKI:def 2;
                              suppose x = source; then
                                x in {source} by TARSKI:def 1; then
                            A31: x in (CS.->0).labeledV() by Th3;
                                (CS.->0).labeledV() c= Gn1.labeledV()
                                  by Th4;
                                hence x in Gn1.labeledV() by A31;
                              end;
                              suppose x = v;
                                hence x in Gn1.labeledV()
                                  by A18,A15,XBOOLE_0:def 2;
                              end;
                           end;
                           hence x in Gn1.labeledV();
                        end;
                        hence W2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                        let n be even Nat; assume
                        n in dom W2; then
                        1 <= n & n <= 3 by A23, FINSEQ_3:27; then
                        2*0+1 < n & n < 2*1+1 by REAL_1:def 5; then
                        1+1 <= n & n <= 2*1 by NAT_1:38; then
                        n = 2 by XXREAL_0:1; then
                    A32: W2.n = e & W2.(n+1) = (the_Source_of Gn).e
                          by A22,FINSEQ_1:62; then
                        W2.(n+1) in {(the_Source_of Gn).e}
                          by TARSKI:def 1; then
                    A33: W2.(n+1) in Gn1.labeledV() by A15,XBOOLE_0:def 2;
                        (the_VLabel_of Gn1).(W2.(n+1)) = e
                          by A32,A11,A14,GLIB_003:46;
                        hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                          by A32,A33,Th7;
                      end;
                      suppose source <> (the_Target_of Gn).e;
                        consider W being vertex-distinct
                                         augmenting Path of G such that
                    A34: W is_Walk_from source, (the_Target_of Gn).e &
                        W.vertices() c= Gn.labeledV() &
                        for n being even Nat st n in dom W holds
                          W.n = (the_VLabel_of FAP).(W.(n+1)) by A5,A13;
                        set W2 = W.addEdge(e);
                    A35: W.first() = source & W.last() = (the_Target_of Gn).e
                          by A34,GLIB_001:def 23; then
                        e Joins W.last(),(the_Source_of Gn).e,Gn
                          by A12,GLIB_000:def 15; then
                    A36: e Joins W.last(),(the_Source_of Gn).e,G
                          by A7, GLIB_000:91;
                    A37: not (the_Source_of Gn).e in W.vertices() by A10,A34;
then
                        reconsider W2 as vertex-distinct Walk of G
                          by A36,GLIB_001:156;
                        e DJoins (the_Source_of Gn).e,W.last(),Gn
                          by A12,A35,GLIB_000:def 16; then
                        e DJoins (the_Source_of Gn).e,W.last(),G
                          by A7,GLIB_000:91; then
                        reconsider W2 as augmenting vertex-distinct Path of G
                          by A7,A13,A37,Th2;
                        take W2;
                        thus W2 is_Walk_from source,v by A19,A35,A36,GLIB_001:
64;
                    A38: W2.vertices() = W.vertices() \/ {v}
                          by A19,A36,GLIB_001:96;
                        now let x be set; assume
                        A39: x in W2.vertices();
                            now per cases by A38,A39,XBOOLE_0:def 2;
                              suppose x in W.vertices(); then
                            A40: x in Gn.labeledV() by A34;
                                n <= n+1 by NAT_1:29; then
                                Gn.labeledV() c= Gn1.labeledV() by Th4;
                                hence x in Gn1.labeledV() by A40;
                              end;
                              suppose x in {v};
                                hence x in Gn1.labeledV()
                                  by A19,A15,XBOOLE_0:def 2;
                              end;
                            end;
                            hence x in Gn1.labeledV();
                        end;
                        hence W2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                        let n be even Nat; assume
                        n in dom W2; then
                    A41: 1 <= n & n <= len W2 by FINSEQ_3:27;
                        now per cases;
                          suppose
                        A42: n <= len W; then
                        A43: n in dom W by A41,FINSEQ_3:27; then
                        A44: W2.n = W.n by A36,GLIB_001:66;
                            n < len W by A42,REAL_1:def 5; then
                        A45: n+1 <= len W by NAT_1:38;
                            1 <= 1+n by NAT_1:29; then
                            n+1 in dom W by A45,FINSEQ_3:27; then
                            W2.(n+1) = W.(n+1) by A36,GLIB_001:66;
                            hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                              by A44,A34,A43;
                          end;
                          suppose n > len W; then
                        A46: len W + 1 <= n by NAT_1:38;
                            n <= len W + 2*1 by A36,A41,GLIB_001:65; then
                            n < len W + 1+1 by REAL_1:def 5; then
                            n <= len W + 1 by NAT_1:38; then
                        A47: n = len W + 1 by A46,XXREAL_0:1; then
                            n+1 = len W + (1+1); then
                        A48: W2.n = e & W2.(n+1) = v by A19,A36,A47,GLIB_001:66
;
                        A49: v in Gn1.labeledV()
                              by A15,A18,XBOOLE_0:def 2;
                            (the_VLabel_of Gn1).v = e
                              by A11,A14,A19,GLIB_003:46;
                            hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                              by A48,A49,Th7;
                          end;
                        end;
                        hence W2.n = (the_VLabel_of FAP).(W2.(n+1));
                      end;
                    end;
                    hence ex P being vertex-distinct augmenting Path of G st
                      P is_Walk_from source,v & P.vertices() c=Gn1.labeledV() &
                      for n being even Nat st n in dom P holds
                      P.n = (the_VLabel_of FAP).(P.(n+1));
                  end;
                end;
                hence ex P being vertex-distinct augmenting Path of G st
                  P is_Walk_from source,v & P.vertices() c=Gn1.labeledV() &
                  for n being even Nat st n in dom P holds
                    P.n = (the_VLabel_of FAP).(P.(n+1));
            end;
            hence P[n+1];
          end;
          suppose
        A50: Next <> {} & (the_Source_of Gn).e in Gn.labeledV(); then
        A51: Gn1 = Gn.labelVertex((the_Target_of Gn).e, e) by A6,Def14;
        A52: e in Next by A50;
        A53: e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by A50,Def13; then
        A54: not (the_Target_of Gn).e in Gn.labeledV() &
              (the_ELabel_of Gn).e < (the_Weight_of Gn).e
              by A50,Def11,Def10;
        A55: (the_Target_of Gn).e in the_Vertices_of Gn by A52,FUNCT_2:7; then
        A56: Gn1.labeledV() = Gn.labeledV() \/ {(the_Target_of Gn).e}
              by A51,GLIB_003:59;
            now let v be set; assume
            A57: v in Gn1.labeledV();
                now per cases by A57,A56,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV(); then
                    consider P being vertex-distinct
                                     augmenting Path of G such that
                A58: P is_Walk_from source,v & P.vertices() c= Gn.labeledV() &
                    for n being even Nat st n in dom P holds
                      P.n = (the_VLabel_of FAP).(P.(n+1)) by A5;
                    take P;
                    n <= n+1 by NAT_1:29; then
                    Gn.labeledV() c= Gn1.labeledV() by Th4;
                    hence P is_Walk_from source,v &
                      P.vertices()c= Gn1.labeledV() &
                      for n being even Nat st n in dom P holds
                        P.n = (the_VLabel_of FAP).(P.(n+1)) by A58,XBOOLE_1:1;
                  end;
                  suppose
                A59: v in {(the_Target_of Gn).e}; then
                A60: v = (the_Target_of Gn).e by TARSKI:def 1;
                    now per cases;
                      suppose
                    A61: source = (the_Source_of Gn).e;
                        set W2 = G.walkOf(source,e,(the_Target_of Gn).e);
                        e Joins source,(the_Target_of Gn).e,Gn
                          by A52,A61,GLIB_000:def 15; then
                    A62: e Joins source,(the_Target_of Gn).e,G
                          by A7,GLIB_000:91; then
                    A63: W2 = <* source, e, (the_Target_of Gn).e *>
                          by GLIB_001:def 5; then
                    A64: len W2 = 3 & W2.1 = source & W2.2 = e &
                          W2.3 = (the_Target_of Gn).e by FINSEQ_1:62; then
                        e DJoins W2.1,W2.(1+2),Gn by A52,A61,GLIB_000:def 16;
then
                    A65: e DJoins W2.1,W2.(1+2),G by A7,GLIB_000:91;
                        now let n be odd Nat; assume n < len W2; then
                            n < 2+1 by A63,FINSEQ_1:62; then
                            n <= 2*1 by NAT_1:38; then
                            n < 1+1 by REAL_1:def 5; then
                            1 <= n & n <= 1 by NAT_1:38,HEYTING3:1; then
                        A66: n = 1 by XXREAL_0:1;
                            thus W2.(n+1) DJoins W2.n,W2.(n+2),G implies
                              (the_ELabel_of G).(W2.(n+1)) <
                              (the_Weight_of G).(W2.(n+1))
                              by A50,Def11,Def10,A53,A7,A66,A64;
                            assume not W2.(n+1) DJoins W2.n,W2.(n+2),G;
                            hence 0 < (the_ELabel_of G).(W2.(n+1))
                              by A63,FINSEQ_1:62,A65,A66;
                        end; then
                        reconsider W2 as augmenting Path of G by Def12;
                    A67: now let m be odd Nat; assume
                        A68: m <= len W2;
                        A69: 1 <= m by HEYTING3:1;
                            now assume m <> 1; then
                                2*0+1 < m by A69,REAL_1:def 5; then
                                1+2 <= m by GLIB_001:1;
                                hence m = 3 by A64,A68,XXREAL_0:1;
                            end;
                            hence m = 1 or m = 3;
                        end;
                        now let m,n be odd Nat; assume
                        A70: m <= len W2 & n <= len W2 & W2.m = W2.n; then
                            (m = 1 or m = 3) & (n = 1 or n = 3) by A67;
                            hence m = n
                              by A70,A64,A9,A8,A53,A50,Def10,Def11;
                        end; then
                        reconsider W2 as vertex-distinct augmenting Path of G
                          by GLIB_001:def 29;
                        take W2;
                        thus W2 is_Walk_from source,v by A60,A62,GLIB_001:16;
                    A71: W2.vertices() = {source,v} by A60,A62,GLIB_001:92;
                        now let x be set; assume
                        A72: x in W2.vertices();
                            now per cases by A71,A72,TARSKI:def 2;
                              suppose x = source; then
                                x in {source} by TARSKI:def 1; then
                            A73: x in (CS.->0).labeledV() by Th3;
                                (CS.->0).labeledV() c= Gn1.labeledV()
                                  by Th4;
                                hence x in Gn1.labeledV() by A73;
                              end;
                              suppose x = v;
                                hence x in Gn1.labeledV()
                                  by A59,A56,XBOOLE_0:def 2;
                              end;
                           end;
                           hence x in Gn1.labeledV();
                        end;
                        hence W2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                        let n be even Nat; assume
                        n in dom W2; then
                        1 <= n & n <= 3 by A64, FINSEQ_3:27; then
                        2*0+1 < n & n < 2*1+1 by REAL_1:def 5; then
                        1+1 <= n & n <= 2*1 by NAT_1:38; then
                        n = 2 by XXREAL_0:1; then
                    A74: W2.n = e & W2.(n+1) = (the_Target_of Gn).e
                          by A63,FINSEQ_1:62; then
                        W2.(n+1) in {(the_Target_of Gn).e}
                          by TARSKI:def 1; then
                    A75: W2.(n+1) in Gn1.labeledV() by A56,XBOOLE_0:def 2;
                        (the_VLabel_of Gn1).(W2.(n+1)) = e
                          by A74,A51,A55,GLIB_003:46;
                        hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                          by A74,A75,Th7;
                      end;
                      suppose source <> (the_Source_of Gn).e;
                        consider W being vertex-distinct
                                         augmenting Path of G such that
                    A76: W is_Walk_from source, (the_Source_of Gn).e &
                        W.vertices() c= Gn.labeledV() &
                        for n being even Nat st n in dom W holds
                          W.n = (the_VLabel_of FAP).(W.(n+1)) by A5,A50;
                        set W2 = W.addEdge(e);
                    A77: W.first() = source & W.last() = (the_Source_of Gn).e
                          by A76,GLIB_001:def 23; then
                        e Joins W.last(),(the_Target_of Gn).e,Gn
                          by A52,GLIB_000:def 15; then
                    A78: e Joins W.last(),(the_Target_of Gn).e,G
                          by A7, GLIB_000:91;
                    A79: not (the_Target_of Gn).e in W.vertices()
                          by A53,A76,A50,Def10,Def11; then
                        reconsider W2 as vertex-distinct Walk of G
                          by A78,GLIB_001:156;
                        e DJoins W.last(),(the_Target_of Gn).e,Gn
                          by A52,A77,GLIB_000:def 16; then
                        e DJoins W.last(),(the_Target_of Gn).e,G
                          by A7,GLIB_000:91; then
                        reconsider W2 as vertex-distinct augmenting Path of G
                          by A7,A54,A79,Th2;
                        take W2;
                        thus W2 is_Walk_from source,v by A60,A77,A78,GLIB_001:
64;
                    A80: W2.vertices() = W.vertices() \/ {v}
                          by A60,A78,GLIB_001:96;
                        now let x be set; assume
                        A81: x in W2.vertices();
                            now per cases by A80,A81,XBOOLE_0:def 2;
                              suppose x in W.vertices(); then
                            A82: x in Gn.labeledV() by A76;
                                n <= n+1 by NAT_1:29; then
                                Gn.labeledV() c= Gn1.labeledV() by Th4;
                                hence x in Gn1.labeledV() by A82;
                              end;
                              suppose x in {v};
                                hence x in Gn1.labeledV()
                                  by A60,A56,XBOOLE_0:def 2;
                              end;
                            end;
                            hence x in Gn1.labeledV();
                        end;
                        hence W2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                        let n be even Nat; assume
                        n in dom W2; then
                    A83: 1 <= n & n <= len W2 by FINSEQ_3:27;
                        now per cases;
                          suppose
                        A84: n <= len W; then
                        A85: n in dom W by A83,FINSEQ_3:27; then
                        A86: W2.n = W.n by A78,GLIB_001:66;
                            n < len W by A84,REAL_1:def 5; then
                        A87: n+1 <= len W by NAT_1:38;
                            1 <= 1+n by NAT_1:29; then
                            n+1 in dom W by A87,FINSEQ_3:27; then
                            W2.(n+1) = W.(n+1) by A78,GLIB_001:66;
                            hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                              by A86,A76,A85;
                          end;
                          suppose n > len W; then
                        A88: len W + 1 <= n by NAT_1:38;
                            n <= len W + 2*1 by A78,A83,GLIB_001:65; then
                            n < len W + 1+1 by REAL_1:def 5; then
                            n <= len W + 1 by NAT_1:38; then
                        A89: n = len W + 1 by A88,XXREAL_0:1; then
                            n+1 = len W + (1+1); then
                        A90: W2.n = e & W2.(n+1) = v by A60,A78,A89,GLIB_001:66
;
                        A91: v in Gn1.labeledV()
                              by A56,A59,XBOOLE_0:def 2;
                            (the_VLabel_of Gn1).v = e
                              by A51,A55,A60,GLIB_003:46;
                            hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                              by A90,A91,Th7;
                          end;
                        end;
                        hence W2.n = (the_VLabel_of FAP).(W2.(n+1));
                      end;
                    end;
                    hence ex P being vertex-distinct augmenting Path of G st
                      P is_Walk_from source,v & P.vertices() c=Gn1.labeledV() &
                      for n being even Nat st n in dom P holds
                      P.n = (the_VLabel_of FAP).(P.(n+1));
                  end;
                end;
                hence ex P being vertex-distinct augmenting Path of G st
                  P is_Walk_from source,v & P.vertices() c=Gn1.labeledV() &
                  for n being even Nat st n in dom P holds
                    P.n = (the_VLabel_of FAP).(P.(n+1));
            end;
            hence P[n+1];
          end;
        end;
        hence P[n+1];
    end; then
A92: for n being Nat st P[n] holds P[n+1];
A93: for n being Nat holds P[n] from NAT_1:sch 1(A4,A92);
    hereby assume sink in FAP.labeledV(); then
        consider W being vertex-distinct augmenting Path of G such that
    A94: W is_Walk_from source,sink & W.vertices() c= FAP.labeledV() &
        for n being even Nat st n in dom W holds
          W.n = (the_VLabel_of FAP).((W.(n+1))) by A1,A93;
        take W;
        thus W is_Walk_from source,sink &
          for n being even Nat st n in dom W holds
            W.n = (the_VLabel_of FAP).((W.(n+1))) by A94;
    end;
    thus thesis;
  end;
  uniqueness proof
    let IT1, IT2 be vertex-distinct augmenting Path of G;
    set FAP = AP:FindAugPath(G,source), CS = AP:CompSeq(G,source);
A95: FAP = CS.Result()
       .= CS.(CS.Lifespan())
       .= CS.->(CS.Lifespan());
    defpred P[Nat] means
      for v being set, P1,P2 being vertex-distinct augmenting Path of G st
        v in (CS.->$1).labeledV() &
        P1 is_Walk_from source,v &
        P2 is_Walk_from source,v &
        (for n being even Nat st n in dom P1 holds
           P1.n = (the_VLabel_of FAP).(P1.(n+1))) &
        (for n being even Nat st n in dom P2 holds
           P2.n = (the_VLabel_of FAP).(P2.(n+1))) holds P1 = P2;
    set G0 = CS.->0;
    now let v be set, P1,P2 be vertex-distinct augmenting Path of G; assume
    A96: v in G0.labeledV() &
        P1 is_Walk_from source,v &
        P2 is_Walk_from source,v &
        (for n being even Nat st n in dom P1 holds
          P1.n = (the_VLabel_of FAP).(P1.(n+1))) &
        (for n being even Nat st n in dom P2 holds
          P2.n = (the_VLabel_of FAP).(P2.(n+1)));
        v in {source} by A96,Th3; then
        v = source by TARSKI:def 1; then
    A97: P1.(2*0+1) = v & P1.(len P1) = v & P2.(2*0+1) = v & P2.(len P2) = v
          by A96,GLIB_001:18;
        1 <= len P1 & 1 <= len P2 by HEYTING3:1; then
        len P1 = 1 & len P2 = 1 by A97, GLIB_001:def 29; then
        P1 = <*v*> & P2 = <*v*> by A97,FINSEQ_1:57;
        hence P1 = P2;
    end; then
A98: P[0];
    now let n be Nat; assume
    A99: P[n]; set Gn = CS.->n, Gn1 = CS.->(n+1);
    A100: Gn1 = AP:Step(Gn) by Def15;
    A101: G == Gn by Th5;
        set Next = AP:NextBestEdges(Gn), e = choose Next;
        now per cases;
          suppose Next = {}; then
            Gn1 = Gn by A100,Def14;
            hence P[n+1] by A99;
          end;
          suppose
        A102: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV(); then
        A103: Gn1 = Gn.labelVertex((the_Source_of Gn).e,e) by A100,Def14;
        A104: e in Next by A102; then
        A105: (the_Source_of Gn).e in the_Vertices_of Gn by FUNCT_2:7; then
        A106: Gn1.labeledV() = Gn.labeledV() \/ {(the_Source_of Gn).e}
              by A103,GLIB_003:59;
            e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by A102,Def13; then
        A107: (the_Target_of Gn).e in Gn.labeledV() by A102,Def10,Def11;
            source in {source} by TARSKI:def 1; then
        A108: source in G0.labeledV() by Th3;
            G0.labeledV() c= Gn.labeledV() by Th4; then
        A109: source in Gn.labeledV() by A108;
            now let v be set,P1,P2 be vertex-distinct augmenting Path of G;
                assume
            A110: v in Gn1.labeledV() & P1 is_Walk_from source,v &
                P2 is_Walk_from source,v &
                (for n being even Nat st n in dom P1 holds
                  P1.n = (the_VLabel_of FAP).(P1.(n+1))) &
                (for n being even Nat st n in dom P2 holds
                  P2.n = (the_VLabel_of FAP).(P2.(n+1))); then
            A111: P1.1 = source & P1.(len P1) = v &
                  P2.1 = source & P2.(len P2) = v by GLIB_001:18;
                now per cases by A110,A106,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV();
                     hence P1 = P2 by A99,A110;
                  end;
                  suppose
                A112: v in {(the_Source_of Gn).e}; then
                A113: v = (the_Source_of Gn).e by TARSKI:def 1;
                    v <> source by A112,A102,A109,TARSKI:def 1; then
                    P1.1 <> P1.last() & P2.1 <> P2.last()
                      by A111,GLIB_001:def 7; then
                    P1.first() <> P1.last() & P2.first() <> P2.last()
                      by GLIB_001:def 6; then
                    P1 is non trivial & P2 is non trivial by GLIB_001:128; then
                A114: 3 <= len P1 & 3 <= len P2 by GLIB_001:126; then
                    3-2 < len P1-0 & 3-2 < len P2-0 by REAL_1:92; then
                    reconsider lenP11 = len P1 - 1, lenP21 = len P2 - 1 as
                      even Nat by INT_1:18;
                A115: 3-2 <= lenP11 & 3-2 <= lenP21 by A114,REAL_1:92;
                A116: lenP11+1 = len P1 & lenP21+1 = len P2;
                A117: lenP11 < len P1-0 & lenP21 < len P2-0 by REAL_1:92; then
                A118: lenP11 in dom P1 & lenP21 in dom P2 by A115,FINSEQ_3:27;
                    (the_VLabel_of Gn1).v = e by A113,A103,A105,GLIB_003:46;
then
                    (the_VLabel_of FAP).v = e by A110,Th7; then
                A119: P1.lenP11 = e & P2.lenP21 = e by A110,A116,A118,A111;
then
                    consider lenP12 being odd Nat such that
                A120: lenP12 = lenP11 - 1 & lenP11-1 in dom P1 &
                      lenP11+1 in dom P1 & e Joins P1.lenP12,v,G
                      by A111,A118,GLIB_001:10;
                    e Joins (the_Target_of Gn).e,v,Gn
                      by A104,A113,GLIB_000:def 15; then
                    e Joins (the_Target_of Gn).e,v,G
                      by A101,GLIB_000:91; then
                A121: P1.lenP12 = (the_Target_of Gn).e
                      by A113,A120,A102,A107,GLIB_000:18;
                    consider lenP22 being odd Nat such that
                A122: lenP22 = lenP21 - 1 & lenP21-1 in dom P2 &
                      lenP21+1 in dom P2 & e Joins P2.lenP22,v,G
                      by A111,A118,A119,GLIB_001:10;
                    e Joins (the_Target_of Gn).e,v,Gn
                           by A104,A113,GLIB_000:def 15; then
                     e Joins (the_Target_of Gn).e,v,G by A101,GLIB_000:91; then
                A123: P2.lenP22 = (the_Target_of Gn).e
                      by A113,A122,A102,A107,GLIB_000:18;
                    set P1A = P1.cut(2*0+1,lenP12);
                    set P2A = P2.cut(2*0+1,lenP22);
                A124: 1 <= lenP12 & 1 <= lenP22 by HEYTING3:1;
                A125: lenP12 < len P1 & lenP22 < len P2
                      by A120,A122,REAL_1:92,A117; then
                A126: P1A is_Walk_from source,(the_Target_of Gn).e &
                      P2A is_Walk_from source,(the_Target_of Gn).e
                      by A111,A121,A123,A124,GLIB_001:38;
                A127: now let n be even Nat; assume
                    A128: n in dom P1A; then
                    A129: 1 <= n & n <= len P1A by FINSEQ_3:27;
                    A130: P1A.n = P1.n by A125,A128,GLIB_001:47;
                        n < len P1A by A129,REAL_1:def 5; then
                        1 <= n+1 & n+1 <= len P1A
                          by NAT_1:38; then
                        n+1 in dom P1A by FINSEQ_3:27; then
                    A131: P1A.(n+1) = P1.(n+1) by A125,GLIB_001:47;
                        len P1A = lenP12 by A125,GLIB_001:46; then
                        n <= len P1 by A125,A129,XXREAL_0:2; then
                        n in dom P1 by A129,FINSEQ_3:27;
                        hence P1A.n = (the_VLabel_of FAP).(P1A.(n+1))
                          by A110,A130,A131;
                    end;
                A132: now let n be even Nat; assume
                    A133: n in dom P2A; then
                    A134: 1 <= n & n <= len P2A by FINSEQ_3:27;
                    A135: P2A.n = P2.n by A125,A133,GLIB_001:47;
                        n < len P2A by A134,REAL_1:def 5; then
                        1 <= n+1 & n+1 <= len P2A
                          by NAT_1:38; then
                        n+1 in dom P2A by FINSEQ_3:27; then
                    A136: P2A.(n+1) = P2.(n+1) by A125,GLIB_001:47;
                        len P2A = lenP22 by A125,GLIB_001:46; then
                        n <= len P2 by A125,A134,XXREAL_0:2; then
                        n in dom P2 by A134,FINSEQ_3:27;
                        hence P2A.n = (the_VLabel_of FAP).(P2A.(n+1))
                          by A110,A135,A136;
                    end;
                A137: lenP12 + 1 = lenP11 & lenP22 + 1 = lenP21
                      by A120,A122;
                    lenP12+(1+1) = len P1 & lenP22+(1+1) = len P2
                      by A120,A122; then
                A138: P1.cut(lenP12,len P1) =
                     G.walkOf((the_Target_of Gn).e,e,v) &
                    P2.cut(lenP22,len P2) =
                     G.walkOf((the_Target_of Gn).e,e,v)
                       by A111,A121,A123,A119,A125,A137,GLIB_001:41;
                A139: P1A.append(P1.cut(lenP12,len P1))
                       = P1.cut(2*0+1, len P1) by A124,A125,GLIB_001:39
                      .= P1 by GLIB_001:40;
                    P2A.append(P2.cut(lenP22, len P2))
                      = P2.cut(2*0+1, len P2) by A124,A125,GLIB_001:39
                     .= P2 by GLIB_001:40;
                    hence P1 = P2 by A99,A107,A126,A127,A132,A138,A139;
                  end;
                end;
                hence P1 = P2;
            end;
            hence P[n+1];
          end;
          suppose
        A140: Next <> {} & (the_Source_of Gn).e in Gn.labeledV(); then
        A141: Gn1 = Gn.labelVertex((the_Target_of Gn).e,e) by A100,Def14;
        A142: e in Next by A140; then
        A143: (the_Target_of Gn).e in the_Vertices_of Gn by FUNCT_2:7; then
        A144: Gn1.labeledV() = Gn.labeledV() \/ {(the_Target_of Gn).e}
              by A141,GLIB_003:59;
            e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by A140,Def13; then
        A145: not (the_Target_of Gn).e in Gn.labeledV()
              by A140,Def11,Def10;
            source in {source} by TARSKI:def 1; then
        A146: source in G0.labeledV() by Th3;
            G0.labeledV() c= Gn.labeledV() by Th4; then
        A147: source in Gn.labeledV() by A146;
            now let v be set,P1,P2 be vertex-distinct augmenting Path of G;
                assume
            A148: v in Gn1.labeledV() & P1 is_Walk_from source,v &
                P2 is_Walk_from source,v &
                (for n being even Nat st n in dom P1 holds
                  P1.n = (the_VLabel_of FAP).(P1.(n+1))) &
                (for n being even Nat st n in dom P2 holds
                  P2.n = (the_VLabel_of FAP).(P2.(n+1))); then
            A149: P1.1 = source & P1.(len P1) = v &
                  P2.1 = source & P2.(len P2) = v by GLIB_001:18;
                now per cases by A148,A144,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV();
                     hence P1 = P2 by A99,A148;
                  end;
                  suppose
                A150: v in {(the_Target_of Gn).e}; then
                A151: v = (the_Target_of Gn).e by TARSKI:def 1;
                    v <> source by A150,TARSKI:def 1,A145,A147; then
                    P1.1 <> P1.last() & P2.1 <> P2.last()
                      by A149,GLIB_001:def 7; then
                    P1.first() <> P1.last() & P2.first() <> P2.last()
                      by GLIB_001:def 6; then
                    P1 is non trivial & P2 is non trivial by GLIB_001:128; then
                A152: 3 <= len P1 & 3 <= len P2 by GLIB_001:126; then
                    3-2 < len P1-0 & 3-2 < len P2-0 by REAL_1:92; then
                    reconsider lenP11 = len P1 - 1, lenP21 = len P2 - 1 as
                      even Nat by INT_1:18;
                A153: 3-2 <= lenP11 & 3-2 <= lenP21 by A152,REAL_1:92;
                A154: lenP11+1 = len P1 & lenP21+1 = len P2;
                A155: lenP11 < len P1-0 & lenP21 < len P2-0 by REAL_1:92; then
                A156: lenP11 in dom P1 & lenP21 in dom P2 by A153,FINSEQ_3:27;
                    (the_VLabel_of Gn1).v = e by A151,A141,A143,GLIB_003:46;
then
                    (the_VLabel_of FAP).v = e by A148,Th7; then
                A157: P1.lenP11 = e & P2.lenP21 = e by A148,A154,A156,A149;
then
                    consider lenP12 being odd Nat such that
                A158: lenP12 = lenP11 - 1 & lenP11-1 in dom P1 &
                      lenP11+1 in dom P1 & e Joins P1.lenP12,v,G
                      by A149,A156,GLIB_001:10;
                    e Joins (the_Source_of Gn).e,v,Gn
                      by A142,A151,GLIB_000:def 15; then
                    e Joins (the_Source_of Gn).e,v,G
                      by A101,GLIB_000:91; then
                A159: P1.lenP12 = (the_Source_of Gn).e
                      by A151,A158,A140,A145,GLIB_000:18;
                    consider lenP22 being odd Nat such that
                A160: lenP22 = lenP21 - 1 & lenP21-1 in dom P2 &
                      lenP21+1 in dom P2 & e Joins P2.lenP22,v,G
                      by A149,A156,A157,GLIB_001:10;
                    e Joins (the_Source_of Gn).e,v,Gn
                      by A142,A151,GLIB_000:def 15; then
                    e Joins (the_Source_of Gn).e,v,G
                      by A101,GLIB_000:91; then
                A161: P2.lenP22 = (the_Source_of Gn).e
                      by A151,A160,A140,A145,GLIB_000:18;
                    set P1A = P1.cut(2*0+1,lenP12);
                    set P2A = P2.cut(2*0+1,lenP22);
                A162: 1 <= lenP12 & 1 <= lenP22 by HEYTING3:1;
                A163: lenP12 < len P1 & lenP22 < len P2
                      by A158,A160,REAL_1:92,A155; then
                A164: P1A is_Walk_from source,(the_Source_of Gn).e &
                    P2A is_Walk_from source,(the_Source_of Gn).e
                      by A162,GLIB_001:38,A149,A159,A161;
                A165: now let n be even Nat; assume
                    A166: n in dom P1A; then
                    A167: 1 <= n & n <= len P1A by FINSEQ_3:27;
                    A168: P1A.n = P1.n by A163,A166,GLIB_001:47;
                        n < len P1A by A167,REAL_1:def 5; then
                        1 <= n+1 & n+1 <= len P1A
                          by NAT_1:38; then
                        n+1 in dom P1A by FINSEQ_3:27; then
                    A169: P1A.(n+1) = P1.(n+1) by A163,GLIB_001:47;
                        len P1A = lenP12 by A163,GLIB_001:46; then
                        n <= len P1 by A163,A167,XXREAL_0:2; then
                        n in dom P1 by A167,FINSEQ_3:27;
                        hence P1A.n = (the_VLabel_of FAP).(P1A.(n+1))
                          by A148,A168,A169;
                    end;
                A170: now let n be even Nat; assume
                    A171: n in dom P2A; then
                    A172: 1 <= n & n <= len P2A by FINSEQ_3:27;
                    A173: P2A.n = P2.n by A163,A171,GLIB_001:47;
                        n < len P2A by A172,REAL_1:def 5; then
                        1 <= n+1 & n+1 <= len P2A
                          by NAT_1:38; then
                        n+1 in dom P2A by FINSEQ_3:27; then
                    A174: P2A.(n+1) = P2.(n+1) by A163,GLIB_001:47;
                        len P2A = lenP22 by A163,GLIB_001:46; then
                        n <= len P2 by A163,A172,XXREAL_0:2; then
                        n in dom P2 by A172,FINSEQ_3:27;
                        hence P2A.n = (the_VLabel_of FAP).(P2A.(n+1))
                          by A148,A173,A174;
                    end;
                A175: lenP12 + 1 = lenP11 & lenP22 + 1 = lenP21
                      by A158,A160;
                    lenP12+(1+1) = len P1 & lenP22+(1+1) = len P2
                      by A160,A158; then
                A176: P1.cut(lenP12,len P1) =
                       G.walkOf((the_Source_of Gn).e,e,v) &
                       P2.cut(lenP22,len P2) =
                       G.walkOf((the_Source_of Gn).e,e,v)
                       by A149,A159,A161,A157,A163,A175,GLIB_001:41;
                A177: P1A.append(P1.cut(lenP12,len P1))
                       = P1.cut(2*0+1, len P1) by A162,A163,GLIB_001:39
                      .= P1 by GLIB_001:40;
                    P2A.append(P2.cut(lenP22, len P2))
                      = P2.cut(2*0+1, len P2) by A162,A163,GLIB_001:39
                     .= P2 by GLIB_001:40;
                    hence P1 = P2 by A99,A140,A164,A165,A170,A176,A177;
                  end;
                end;
                hence P1 = P2;
            end;
            hence P[n+1];
          end;
        end;
        hence P[n+1];
    end; then
A178: for n being Nat st P[n] holds P[n+1];
A179: for n being Nat holds P[n] from NAT_1:sch 1(A98,A178);
    thus (sink in FAP.labeledV() &
        (IT1 is_Walk_from source,sink &
        for n being even Nat st n in dom IT1 holds
          IT1.n = (the_VLabel_of AP:FindAugPath(G,source)).(IT1.(n+1))) &
        (IT2 is_Walk_from source,sink &
        for n being even Nat st n in dom IT2 holds
          IT2.n = (the_VLabel_of AP:FindAugPath(G,source)).(IT2.(n+1))))
        implies IT1 = IT2 by A95,A179;
    thus thesis;
  end;
  consistency;
end;

theorem Th8: ::tAPCS03
  for G being real-weighted real-elabeled WEGraph,
      source being Vertex of G, n being Nat, v being set
   st v in (AP:CompSeq(G,source).->n).labeledV() holds
     ex P being Path of G
       st P is augmenting & P is_Walk_from source,v &
       P.vertices() c= (AP:CompSeq(G,source).->n).labeledV() proof
    let G be real-weighted real-elabeled WEGraph, source be Vertex of G;
    set CS = AP:CompSeq(G,source), G0 = CS.->0;
    defpred P[Nat] means
       for v being set st v in (CS.->$1).labeledV()
       holds ex P being Path of G st
         P is augmenting & P is_Walk_from source,v &
         P.vertices() c= (CS.->$1).labeledV();
    now let v be set; assume
    A1: v in G0.labeledV();
        G == G0 by Th3; then
        reconsider v'=v as Vertex of G by A1,GLIB_000:def 36;
        set P = G.walkOf(v');
        take P;
        thus P is augmenting;
        v in {source} by A1,Th3; then
        v = source by TARSKI:def 1;
        hence P is_Walk_from source,v by GLIB_001:14;
        P.vertices() = {v'} by GLIB_001:91;
        hence P.vertices() c= G0.labeledV() by A1, ZFMISC_1:37;
    end; then
A2: P[0];
A3: now let n be Nat; set Gn = CS.->n, Gn1 = CS.->(n+1);
        set Next = AP:NextBestEdges(Gn), e = choose Next; assume
    A4: P[n];
    A5: Gn1 = AP:Step(Gn) by Def15;
        now per cases;
          suppose Next = {}; then
            Gn1 = Gn by A5, Def14;
            hence P[n+1] by A4;
          end;
          suppose
        A6: Next <> {};
            set se = (the_Source_of Gn).e, te = (the_Target_of Gn).e;
            now per cases by A6,Def13;
              suppose
            A7: e is_forward_labeling_in Gn; then
            A8: e in the_Edges_of Gn & se in Gn.labeledV() &
                not te in Gn.labeledV() &
                (the_ELabel_of Gn).e < (the_Weight_of Gn).e
                  by Def10; then
            A9: Gn1 = Gn.labelVertex(te, e) by A5,A6,Def14;
                te in the_Vertices_of Gn by A8, FUNCT_2:7; then
            A10: Gn1.labeledV() = Gn.labeledV() \/ {te} by A9,GLIB_003:59; then
            A11: Gn.labeledV() c= Gn1.labeledV() by XBOOLE_1:7;
                te in {te} by TARSKI:def 1; then
            A12: te in Gn1.labeledV() by A10, XBOOLE_0:def 2;
            A13: se in Gn1.labeledV() by A8,A11;
                let v be set; assume
            A14: v in Gn1.labeledV();
            A15: G == Gn & the_Weight_of G = the_Weight_of Gn &
                the_ELabel_of Gn = the_ELabel_of G by Th5;
                e DJoins se,te,Gn by A8,GLIB_000:def 16; then
            A16: e DJoins se,te,G by A15,GLIB_000:91;
                now per cases by A10,A14,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV(); then
                    consider P being Path of G such that
                A17: P is augmenting & P is_Walk_from source,v &
                    P.vertices() c= Gn.labeledV() by A4;
                    take P;
                    thus P is augmenting & P is_Walk_from source,v &
                       P.vertices() c= Gn1.labeledV() by A11,A17,XBOOLE_1:1;
                  end;
                  suppose v in {te}; then
                A18: v = te by TARSKI:def 1;
                    now per cases;
                      suppose
                    A19: se = source;
                        set P = G.walkOf(se,e,te);
                        take P;
                        e Joins se,te,Gn by A8,GLIB_000:def 15; then
                    A20: e Joins se,te,G by A15,GLIB_000:91;
                        now let n be odd Nat; assume n < len P; then
                            n < 2+1 by A20,GLIB_001:15; then
                            n <= 2*1 by NAT_1:38; then
                            n < 1+1 by REAL_1:def 5; then
                            1 <= n & n <= 1 by HEYTING3:1, NAT_1:38; then
                        A21: n = 1 by XXREAL_0:1;
                            P = <*se,e,te*> by A20,GLIB_001:def 5; then
                        A22: P.n = se & P.(n+1) = e & P.(n+2) = te
                              by A21,FINSEQ_1:62; then
                        A23: P.(n+1) DJoins P.n,P.(n+2),Gn
                              by A8,GLIB_000:def 16;
                            thus P.(n+1) DJoins P.n,P.(n+2),G implies
                              (the_ELabel_of G).(P.(n+1)) <
                              (the_Weight_of G).(P.(n+1))
                              by A7,A15,A22,Def10;
                            assume not P.(n+1) DJoins P.n,P.(n+2),G;
                            hence 0 < (the_ELabel_of G).(P.(n+1))
                              by A23,A15,GLIB_000:91;
                        end;
                        hence P is augmenting by Def12;
                        thus P is_Walk_from source,v by A18,A19,A20,GLIB_001:16
;
                        now let x be set; assume x in P.vertices(); then
                            x in {se,te} by A20,GLIB_001:92;
                            hence x in Gn1.labeledV() by TARSKI:def 2,A12,A13;
                        end;
                        hence P.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                      end;
                      suppose
                    A24: se <> source;
                        consider P being Path of G such that
                    A25: P is augmenting & P is_Walk_from source,se &
                          P.vertices() c= Gn.labeledV() by A4,A8;
                        set P2 = P.addEdge(e);
                        e Joins se,v,Gn by A8,A18,GLIB_000:def 15; then
                    A26: e Joins se,v,G by A15,GLIB_000:91;
                    A27: se = P.last() by A25, GLIB_001:def 23; then
                        P.first() <> P.last() by A24,A25,GLIB_001:def 23; then
                    A28: P is open by GLIB_001:def 24;
                    A29: not v in P.vertices() by A18,A25,A7,Def10; then
                        reconsider P2 as Path of G by A26,A27,A28,GLIB_001:152;
                        take P2;
                        thus P2 is augmenting
                          by A18,A8,A15,A16,A25,A27,A29,Th2;
                        thus P2 is_Walk_from source,v by A25,A26,GLIB_001:67;
                        now let x be set; assume x in P2.vertices(); then
                        A30: x in P.vertices()\/{te} by A18,A26,A27,GLIB_001:96
;
                            now per cases by A30, XBOOLE_0:def 2;
                              suppose x in P.vertices(); then
                                x in Gn.labeledV() by A25;
                                hence x in Gn1.labeledV() by A11;
                              end;
                              suppose x in {te};
                                hence x in Gn1.labeledV() by A10,XBOOLE_0:def 2
;
                              end;
                            end;
                            hence x in Gn1.labeledV();
                        end;
                        hence P2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                      end;
                    end;
                    hence ex P being Path of G st P is augmenting &
                      P is_Walk_from source,v & P.vertices() c= Gn1.labeledV();
                  end;
                end;
                hence ex P being Path of G st P is augmenting &
                     P is_Walk_from source,v & P.vertices() c= Gn1.labeledV();
              end;
              suppose
            A31: e is_backward_labeling_in Gn; then
            A32: e in the_Edges_of Gn & te in Gn.labeledV() &
                not se in Gn.labeledV() &
                0 < (the_ELabel_of Gn).e by Def11; then
            A33: Gn1 = Gn.labelVertex(se, e) by A5,A6,Def14;
                se in the_Vertices_of Gn by A32, FUNCT_2:7; then
            A34: Gn1.labeledV() = Gn.labeledV() \/ {se} by A33,GLIB_003:59;
then
            A35: Gn.labeledV() c= Gn1.labeledV() by XBOOLE_1:7;
                se in {se} by TARSKI:def 1; then
            A36: se in Gn1.labeledV() by A34,XBOOLE_0:def 2;
            A37: te in Gn1.labeledV() by A32,A35;
                let v be set; assume
            A38: v in Gn1.labeledV();
            A39: G == Gn & the_Weight_of G = the_Weight_of Gn &
                the_ELabel_of G = the_ELabel_of Gn by Th5;
                e DJoins se,te,Gn by A32,GLIB_000:def 16; then
            A40: e DJoins se,te,G by A39,GLIB_000:91;
                now per cases by A34,A38,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV(); then
                    consider P being Path of G such that
                A41: P is augmenting & P is_Walk_from source,v &
                    P.vertices() c= Gn.labeledV() by A4;
                    take P;
                    thus P is augmenting & P is_Walk_from source,v &
                       P.vertices() c= Gn1.labeledV() by A35,A41,XBOOLE_1:1;
                  end;
                  suppose v in {se}; then
                A42: v = se by TARSKI:def 1;
                    now per cases;
                      suppose
                    A43: te = source;
                        set P = G.walkOf(te,e,se);
                        take P;
                        e Joins te,se,Gn by A32,GLIB_000:def 15; then
                    A44: e Joins te,se,G by A39,GLIB_000:91;
                        now let n be odd Nat; assume n < len P; then
                            n < 2+1 by A44,GLIB_001:15; then
                            n <= 2*1 by NAT_1:38; then
                            n < 1+1 by REAL_1:def 5; then
                            1 <= n & n <= 1 by HEYTING3:1, NAT_1:38; then
                        A45: n = 1 by XXREAL_0:1;
                            P = <*te,e,se*> by A44,GLIB_001:def 5; then
                        A46: P.n = te & P.(n+1) = e & P.(n+2) = se
                              by A45,FINSEQ_1:62;
                            hereby assume P.(n+1) DJoins P.n,P.(n+2),G; then
                                e DJoins te,se,Gn by A46,A39,GLIB_000:91;
                                hence (the_ELabel_of G).(P.(n+1)) <
                                      (the_Weight_of G).(P.(n+1))
                                      by A32,GLIB_000:def 16;
                            end;
                            assume not P.(n+1) DJoins P.n,P.(n+2),G;
                            thus 0 < (the_ELabel_of G).(P.(n+1))
                              by A31,A39,A46,Def11;
                        end;
                        hence P is augmenting by Def12;
                        thus P is_Walk_from source,v by A42,A43,A44,GLIB_001:16
;
                        now let x be set; assume x in P.vertices(); then
                            x in {se,te} by A44,GLIB_001:92;
                            hence x in Gn1.labeledV() by TARSKI:def 2,A36,A37;
                        end;
                        hence P.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                      end;
                      suppose
                    A47: te <> source;
                        consider P being Path of G such that
                    A48: P is augmenting & P is_Walk_from source,te &
                          P.vertices() c= Gn.labeledV() by A4,A32;
                        set P2 = P.addEdge(e);
                        e Joins te,v,Gn by A32,A42,GLIB_000:def 15; then
                    A49: e Joins te,v,G by A39,GLIB_000:91;
                    A50: te = P.last() by A48, GLIB_001:def 23; then
                        P.first() <> P.last() by A47,A48,GLIB_001:def 23; then
                    A51: P is open by GLIB_001:def 24;
                    A52: not v in P.vertices() by A31,Def11,A42,A48; then
                        reconsider P2 as Path of G by A49,A50,A51,GLIB_001:152;
                        take P2;
                        thus P2 is augmenting
                          by A32,A39,A42,A40,A48,A50,A52,Th2;
                        thus P2 is_Walk_from source,v by A48,A49,GLIB_001:67;
                        now let x be set; assume x in P2.vertices(); then
                        A53: x in P.vertices()\/{se} by A42,A49,A50,GLIB_001:96
;
                            now per cases by A53, XBOOLE_0:def 2;
                              suppose x in P.vertices(); then
                                x in Gn.labeledV() by A48;
                                hence x in Gn1.labeledV() by A35;
                              end;
                              suppose x in {se};
                                hence x in Gn1.labeledV() by A34,XBOOLE_0:def 2
;
                              end;
                            end;
                            hence x in Gn1.labeledV();
                        end;
                        hence P2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                      end;
                    end;
                    hence ex P being Path of G st P is augmenting &
                      P is_Walk_from source,v & P.vertices() c= Gn1.labeledV();
                  end;
                end;
                hence ex P being Path of G st P is augmenting &
                     P is_Walk_from source,v & P.vertices() c= Gn1.labeledV();
              end;
            end;
            hence P[n+1];
          end;
        end;
        hence P[n+1];
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A2,A3);
    hence thesis;
end;

theorem Th9: ::tAPFAP02
  for G being finite real-weighted real-elabeled WEGraph,
      source being Vertex of G, v being set
   holds v in AP:FindAugPath(G,source).labeledV() iff
      ex P being Path of G st
        P is augmenting & P is_Walk_from source,v proof
    let G be finite real-weighted real-elabeled WEGraph,
        source be Vertex of G, v be set;
    set CS = AP:CompSeq(G,source), V = AP:FindAugPath(G,source).labeledV();
A1: AP:FindAugPath(G,source) = CS.Result()
                            .= CS.(CS.Lifespan())
                            .= CS.->(CS.Lifespan());
    hereby assume v in AP:FindAugPath(G,source).labeledV(); then
        consider P being Path of G such that
    A2: P is augmenting & P is_Walk_from source,v &
        P.vertices() c= AP:FindAugPath(G,source).labeledV() by A1,Th8;
        thus ex P being Path of G st
          P is augmenting & P is_Walk_from source,v by A2;
    end;
    given P being Path of G such that
A3: P is augmenting & P is_Walk_from source,v;
    now assume
    A4: not v in AP:FindAugPath(G,source).labeledV();
        defpred P[Nat] means
          $1 is odd & $1 <= len P & not P.$1 in V;
        P.(len P) = v by A3, GLIB_001:18; then
    A5: ex n being Nat st P[n] by A4;
        consider n being Nat such that
    A6: P[n] & for k being Nat st P[k] holds n <= k from NAT_1:sch 5(A5);
        P.(2*0+1) = source by A3, GLIB_001:18; then
        P.(2*0+1) in {source} by TARSKI:def 1; then
    A7: P.(2*0+1) in (CS.->0).labeledV() by Th3;
        (CS.->0).labeledV() c= V by A1,Th4; then
    A8: n <> 1 by A6,A7;
        reconsider n'=n as odd Nat by A6;
        1 <= n by A6,HEYTING3:1; then
        1 < n by A8, REAL_1:def 5; then
        1+1 <= n by NAT_1:38; then
        reconsider n2 = n'-2*1 as odd Nat by INT_1:18;
    A9: n2 < n - 0 by REAL_1:92; then
    A10: n2 < len P by A6, XXREAL_0:2; then
    A11: P.n2 in V by A6,A9;
        set Gn = CS.->(CS.Lifespan()), Gn1 = CS.->(CS.Lifespan()+1);
        set Next = AP:NextBestEdges(Gn), en = choose Next;
    A12: Gn1 = AP:Step(Gn) by Def15;
        AP:CompSeq(G,source) is halting by Th6; then
        CS.(CS.Lifespan()) = CS.(CS.Lifespan()+1) by GLIB_000:def 57; then
        Gn = CS.(CS.Lifespan()+1); then
    A13: Gn1 = Gn;
        set e = P.(n2+1);
    A14: P.(n2+2) = P.n;
    A15: G == Gn &
        the_ELabel_of G = the_ELabel_of Gn &
        the_Weight_of G = the_Weight_of Gn by Th5; then
    A16: the_Edges_of G = the_Edges_of Gn &
        the_Source_of G = the_Source_of Gn &
        the_Target_of G = the_Target_of Gn by GLIB_000:def 36;
    A17: e Joins P.n2, P.n, G by A14,A10,GLIB_001:def 3;
    A18: now per cases;
          suppose
        A19: e DJoins P.n2, P.n, G; then
        A20: (the_ELabel_of G).e<(the_Weight_of G).e by A3,A10,A14,Def12;
        A21: e in the_Edges_of Gn & (the_Source_of Gn).e in Gn.labeledV() &
              not (the_Target_of Gn).e in Gn.labeledV()
              by A11,A6,A16,A19,GLIB_000:def 16;
            e is_forward_labeling_in Gn by A21, A20, Def10,A15;
            hence Next <> {} by Def13;
          end;
          suppose
        A22: not e DJoins P.n2,P.n, G; then
        A23: 0 < (the_ELabel_of G).e by A3,A10,A14,Def12;
            e DJoins P.n,P.n2,G by A22,A17,GLIB_000:19; then
            e in the_Edges_of Gn & not (the_Source_of Gn).e in Gn.labeledV() &
              (the_Target_of Gn).e in Gn.labeledV()
              by A11,A6,GLIB_000:def 16,A16; then
            e is_backward_labeling_in Gn by A23,Def11,A15;
            hence Next <> {} by Def13;
          end;
        end;
        en in Next by A18; then
    A24: (the_Source_of Gn).en in the_Vertices_of Gn &
        (the_Target_of Gn).en in the_Vertices_of Gn by FUNCT_2:7;
        now per cases;
          suppose
        A25: not (the_Source_of Gn).en in Gn.labeledV(); then
            Gn = Gn.labelVertex((the_Source_of Gn).en,en)
              by A12,A13,A18,Def14; then
        A26: Gn.labeledV() = Gn.labeledV() \/ {(the_Source_of Gn).en}
              by A24,GLIB_003:59;
            (the_Source_of Gn).en in {(the_Source_of Gn).en}
              by TARSKI:def 1;
            hence contradiction by A25,A26,XBOOLE_0:def 2;
          end;
          suppose
        A27: (the_Source_of Gn).en in Gn.labeledV(); then
        A28: Gn = Gn.labelVertex((the_Target_of Gn).en,en) by A12,A13,A18,Def14
;
            en is_forward_labeling_in Gn or en is_backward_labeling_in Gn
              by A18,Def13; then
        A29: not (the_Target_of Gn).en in Gn.labeledV()
              by A27,Def11,Def10;
        A30: Gn.labeledV() = Gn.labeledV() \/ {(the_Target_of Gn).en}
              by A24,A28,GLIB_003:59;
            (the_Target_of Gn).en in {(the_Target_of Gn).en}
              by TARSKI:def 1;
            hence contradiction by A29,A30,XBOOLE_0:def 2;
          end;
        end;
        hence contradiction;
    end;
    hence v in AP:FindAugPath(G,source).labeledV();
end;

theorem Th10: ::tAPFAP03
  for G being finite real-weighted real-elabeled WEGraph,
      source being Vertex of G holds
    source in AP:FindAugPath(G,source).labeledV() &
    G == AP:FindAugPath(G,source) &
    the_Weight_of G = the_Weight_of AP:FindAugPath(G,source) &
    the_ELabel_of G = the_ELabel_of AP:FindAugPath(G,source) proof
    let G be finite real-weighted real-elabeled WEGraph, source be Vertex of G;
    set CS = AP:CompSeq(G,source), V = AP:FindAugPath(G,source).labeledV();
A1: AP:FindAugPath(G,source) = CS.Result()
                            .= CS.(CS.Lifespan())
                            .= CS.->(CS.Lifespan());
    (CS.->0).labeledV() = {source} by Th3; then
A2: source in (CS.->0).labeledV() by TARSKI:def 1;
    (CS.->0).labeledV() c= AP:FindAugPath(G,source).labeledV()
      by A1,Th4;
    hence source in AP:FindAugPath(G,source).labeledV() by A2;
    thus thesis by A1,Th5;
end;

begin :: Ford-Fulkerson Algorithm definitions

definition let G be real-weighted real-elabeled WEGraph,
               W be augmenting Walk of G;
  func W.flowSeq() -> FinSequence of REAL means :Def18: ::dWFLOWSEQ
    dom it = dom W.edgeSeq() &
    for n being Nat st n in dom it holds
     ((W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         it.n = (the_Weight_of G).(W.(2*n)) - (the_ELabel_of G).(W.(2*n))) &
      (not W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         it.n = (the_ELabel_of G).(W.(2*n))));
  existence proof
    defpred P[Nat,set] means
     (W.(2*$1) DJoins W.(2*$1-1),W.(2*$1+1),G implies
         $2 = (the_Weight_of G).(W.(2*$1)) - (the_ELabel_of G).(W.(2*$1))) &
     (not W.(2*$1) DJoins W.(2*$1-1),W.(2*$1+1),G implies
         $2 = (the_ELabel_of G).(W.(2*$1)));
A1: for k being Nat,y1,y2 being set
     st k in Seg len W.edgeSeq() & P[k,y1] & P[k,y2] holds y1=y2;
    now let k be Nat; assume k in Seg len W.edgeSeq();
        now per cases;
          suppose W.(2*k) DJoins W.(2*k-1),W.(2*k+1),G;
            hence ex x being set st P[k,x];
          end;
          suppose not W.(2*k) DJoins W.(2*k-1),W.(2*k+1),G;
            hence ex x being set st P[k,x];
          end;
        end;
        hence ex x being set st P[k,x];
    end; then
A2: for k being Nat st k in Seg len W.edgeSeq()
     ex x being set st P[k,x];
    consider IT being FinSequence such that
A3: dom IT = Seg len W.edgeSeq() &
    for k being Nat st k in Seg len W.edgeSeq() holds P[k,IT.k]
      from FINSEQ_1:sch 1(A1,A2);
    now let y be set; assume y in rng IT; then consider x being set such that
    A4: x in dom IT & IT.x = y by FUNCT_1:def 5;
        reconsider x as Nat by A4;
        P[x,y] by A4,A3;
        hence y in REAL;
    end; then
    rng IT c= REAL by TARSKI:def 3; then
    reconsider IT as FinSequence of REAL by FINSEQ_1:def 4;
    take IT;
    thus dom IT = dom W.edgeSeq() by A3,FINSEQ_1:def 3;
    let n be Nat; assume n in dom IT;
    hence thesis by A3;
  end;
  uniqueness proof
    let IT1,IT2 be FinSequence of REAL such that
A5: dom IT1 = dom W.edgeSeq() &
    for n being Nat st n in dom IT1 holds
     ((W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         IT1.n = (the_Weight_of G).(W.(2*n)) - (the_ELabel_of G).(W.(2*n))) &
      (not W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         IT1.n = (the_ELabel_of G).(W.(2*n)))) and
A6: dom IT2 = dom W.edgeSeq() &
    for n being Nat st n in dom IT2 holds
     ((W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         IT2.n = (the_Weight_of G).(W.(2*n)) - (the_ELabel_of G).(W.(2*n))) &
      (not W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         IT2.n = (the_ELabel_of G).(W.(2*n))));
     now let n be Nat; assume
     A7: n in dom IT1;
         now per cases;
           suppose (W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G); then
             IT1.n = (the_Weight_of G).(W.(2*n))-(the_ELabel_of G).(W.(2*n))&
             IT2.n = (the_Weight_of G).(W.(2*n))-(the_ELabel_of G).(W.(2*n))
               by A5,A6,A7;
             hence IT1.n = IT2.n;
           end;
           suppose not (W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G); then
             IT1.n = (the_ELabel_of G).(W.(2*n)) &
             IT2.n = (the_ELabel_of G).(W.(2*n)) by A5,A6,A7;
             hence IT1.n = IT2.n;
           end;
         end;
         hence IT1.n = IT2.n;
     end;
     hence IT1 = IT2 by A5,A6,FINSEQ_1:17;
  end;
end;

definition let G be real-weighted real-elabeled WEGraph,
               W be augmenting Walk of G;
  func W.tolerance() -> Real means :Def19: ::dWTOLERANCE
    it in rng W.flowSeq() &
    for k being Real st k in rng W.flowSeq() holds it <= k
    if W is non trivial otherwise it = 0;
  existence proof
    set D = rng W.flowSeq();
    hereby assume W is non trivial; then
        W.edges() <> {} by GLIB_001:137; then
        rng W.edgeSeq() <> {} by GLIB_001:def 17; then
        consider y being set such that
    A1: y in rng W.edgeSeq() by XBOOLE_0:def 1;
        consider x being set such that
    A2: x in dom W.edgeSeq() & y = W.edgeSeq().x by A1,FUNCT_1:def 5;
        x in dom W.flowSeq() by A2,Def18; then
        W.flowSeq().x in D by FUNCT_1:def 5; then
        reconsider D as non empty finite Subset of REAL;
        deffunc F(Real) = $1;
        consider IT being Element of D such that
    A3: for k being Element of D holds F(IT) <= F(k) from GRAPH_5:sch 2;
        reconsider IT as Real;
        take IT;
        thus IT in rng W.flowSeq();
        let k be Real; assume k in rng W.flowSeq();
        hence IT <= k by A3;
    end;
    thus thesis;
  end;
  uniqueness proof
    let IT1,IT2 be Real;
    hereby assume W is non trivial;
        assume
    A4: IT1 in rng W.flowSeq() &
        for k being Real st k in rng W.flowSeq() holds IT1 <= k; assume
    A5: IT2 in rng W.flowSeq() &
        for k being Real st k in rng W.flowSeq() holds IT2 <= k;
        IT1 <= IT2 & IT2 <= IT1 by A4,A5;
        hence IT1 = IT2 by XXREAL_0:1;
    end;
    thus thesis;
  end;
  consistency;
end;

definition let G be natural-weighted natural-elabeled WEGraph,
               W be augmenting Walk of G;
   redefine func W.tolerance() -> Nat;
  coherence proof
   set IT = W.tolerance();
   now per cases;
     suppose W is non trivial; then
       IT in rng W.flowSeq() by Def19; then
       consider n being Nat such that
   A1: n in dom W.flowSeq() & (W.flowSeq()).n = IT by FINSEQ_2:11;
       n in dom W.edgeSeq() by A1,Def18; then
       2*n in dom W by GLIB_001:79; then
   A2: 1 <= 2*n & 2*n <= len W by FINSEQ_3:27; then
       reconsider 2n1 = 2*n-1 as odd Nat by INT_1:18;
   A3: 2n1 < len W - 0 by A2,REAL_1:92;
   A4: 2n1+1 = 2*n;
   A5: 2n1+(1+1) = 2*n+1;
       now per cases;
         suppose
       A6: W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G; then
       A7: IT = (the_Weight_of G).(W.(2*n)) - (the_ELabel_of G).(W.(2*n))
             by A1,Def18;
           (the_ELabel_of G).(W.(2*n)) <
           (the_Weight_of G).(W.(2*n)) by A6,A3,A4,A5,Def12;
           hence IT is Nat by A7,INT_1:18;
         end;
         suppose not W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G; then
           IT = (the_ELabel_of G).(W.(2*n)) by A1,Def18;
           hence IT is Nat;
         end;
       end;
       hence IT is Nat;
     end;
     suppose W is trivial;
       hence IT is Nat by Def19;
     end;
   end;
   hence IT is Nat;
 end;
end;

definition let G be real-weighted real-elabeled WEGraph,
               P be augmenting Path of G;
  func FF:PushFlow(G,P) -> ManySortedSet of the_Edges_of G means :Def20: ::dFFPUSH
    (for e being set st e in the_Edges_of G & not e in P.edges()
      holds it.e = (the_ELabel_of G).e) &
    (for n being odd Nat st n < len P holds
      (P.(n+1) DJoins P.n, P.(n+2),G implies
       it.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
      (not P.(n+1) DJoins P.n,P.(n+2),G implies
       it.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) - P.tolerance()));
  existence proof
    defpred P[set,set] means
      ($1 in the_Edges_of G & not $1 in P.edges()
        implies $2 = (the_ELabel_of G).$1) &
      (for n being odd Nat st n < len P & $1 = P.(n+1) holds
        ((P.(n+1) DJoins P.n,P.(n+2),G) implies
         $2 = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
        (not P.(n+1) DJoins P.n,P.(n+2),G implies
         $2 = (the_ELabel_of G).(P.(n+1)) - P.tolerance()));
    now let x,y1,y2 be set; assume
    A1: x in the_Edges_of G & P[x,y1] & P[x,y2];
        now per cases;
          suppose not x in P.edges();
            hence y1 = y2 by A1;
          end;
          suppose x in P.edges(); then consider n being odd Nat such that
        A2: n < len P & P.(n+1) = x by GLIB_001:101;
            now per cases;
              suppose (P.(n+1) DJoins P.n,P.(n+2),G); then
                y1 = (the_ELabel_of G).(P.(n+1)) + P.tolerance() &
                y2 = (the_ELabel_of G).(P.(n+1)) + P.tolerance() by A1,A2;
                hence y1 = y2;
              end;
              suppose not (P.(n+1) DJoins P.n,P.(n+2),G); then
                y1 = (the_ELabel_of G).(P.(n+1)) - P.tolerance() &
                y2 = (the_ELabel_of G).(P.(n+1)) - P.tolerance() by A1,A2;
                hence y1 = y2;
              end;
            end;
            hence y1 = y2;
          end;
        end;
        hence y1 = y2;
    end; then
A3: for x,y1,y2 being set st x in the_Edges_of G & P[x,y1] & P[x,y2]
      holds y1 = y2;
    now let x be set; assume x in the_Edges_of G;
        now per cases;
          suppose
        A4: not x in P.edges();
            set y = (the_ELabel_of G).x;
            for n being odd Nat st n < len P & x = P.(n+1) holds
              ((P.(n+1) DJoins P.n,P.(n+2),G) implies
                y = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
               (not P.(n+1) DJoins P.n,P.(n+2),G implies
                y = (the_ELabel_of G).(P.(n+1)) - P.tolerance())
                by A4,GLIB_001:101;
            hence ex y being set st P[x,y];
          end;
          suppose
        A5: x in P.edges(); then consider n being odd Nat such that
        A6: n < len P & P.(n+1) = x by GLIB_001:101;
        A7: 1 <= n+1 & n+1 <= len P by A6,NAT_1:29,NAT_1:38;
            now per cases;
              suppose
            A8: (P.(n+1) DJoins P.n,P.(n+2),G);
                set y = (the_ELabel_of G).(P.(n+1)) + P.tolerance();
                now thus x in the_Edges_of G & not x in P.edges()
                      implies y = (the_ELabel_of G).x by A5;
                    let m be odd Nat such that
                A9: m < len P & P.(m+1) = x;
                    1 <= m+1 & m+1 <= len P by A9,NAT_1:29,NAT_1:38; then
                    m+1 <= n+1 & n+1 <= m+1 by A6,A7,A9,GLIB_001:139; then
                    m+1 = n+1 by XXREAL_0:1; then
                A10: m = n;
                    thus P.(m+1) DJoins P.m,P.(m+2),G implies y = y;
                    assume not P.(m+1) DJoins P.m,P.(m+2),G;
                    hence y = (the_ELabel_of G).(P.(m+1)) - P.tolerance()
                      by A8,A10;
                end; then
                P[x,y] by A6;
                hence ex y being set st P[x,y];
              end;
              suppose
            A11: not (P.(n+1) DJoins P.n,P.(n+2),G);
                set y =(the_ELabel_of G).(P.(n+1)) - P.tolerance();
                now thus x in the_Edges_of G & not x in P.edges()
                      implies y = (the_ELabel_of G).x by A5;
                    let m be odd Nat such that
                A12: m < len P & P.(m+1) = x;
                    1 <= m+1 & m+1 <= len P by A12,NAT_1:29,NAT_1:38; then
                    m+1 <= n+1 & n+1 <= m+1 by A6,A7,A12,GLIB_001:139; then
                    m+1 = n+1 by XXREAL_0:1; then
                    m = n;
                    hence P.(m+1) DJoins P.m,P.(m+2),G implies
                      y = (the_ELabel_of G).(P.(n+1)) + P.tolerance() by A11;
                    assume not P.(m+1) DJoins P.m,P.(m+2),G;
                    thus y = (the_ELabel_of G).(P.(n+1)) - P.tolerance();
                end; then
                P[x,y] by A6;
                hence ex y being set st P[x,y];
              end;
            end;
            hence ex y being set st P[x,y];
          end;
        end;
        hence ex y being set st P[x,y];
    end; then
A13: for x being set st x in the_Edges_of G holds
      ex y being set st P[x,y];
    consider IT being Function such that
A14: dom IT = the_Edges_of G &
    for e being set st e in the_Edges_of G holds P[e,IT.e]
      from FUNCT_1:sch 2(A3,A13);
    reconsider IT as ManySortedSet of the_Edges_of G by A14,PBOOLE:def 3;
    take IT;
    thus for e being set st e in the_Edges_of G & not e in P.edges()
      holds IT.e = (the_ELabel_of G).e by A14;
    let n be odd Nat; assume
A15: n < len P; then
    P.(n+1) Joins P.n, P.(n+2), G by GLIB_001:def 3; then
A16: P.(n+1) in the_Edges_of G by GLIB_000:def 15;
    hence P.(n+1) DJoins P.n,P.(n+2),G implies
      IT.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) + P.tolerance() by A14,A15;
    assume not P.(n+1) DJoins P.n, P.(n+2), G;
    hence IT.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) - P.tolerance()
      by A14,A15,A16;
  end;
  uniqueness proof
    let IT1,IT2 be ManySortedSet of the_Edges_of G such that
A17: (for e being set st e in the_Edges_of G & not e in P.edges()
      holds IT1.e = (the_ELabel_of G).e) &
    (for n being odd Nat st n < len P holds
      (P.(n+1) DJoins P.n, P.(n+2),G implies
       IT1.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
      (not P.(n+1) DJoins P.n,P.(n+2),G implies
       IT1.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) - P.tolerance())) and
A18: (for e being set st e in the_Edges_of G & not e in P.edges()
      holds IT2.e = (the_ELabel_of G).e) &
    (for n being odd Nat st n < len P holds
      (P.(n+1) DJoins P.n, P.(n+2),G implies
       IT2.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
      (not P.(n+1) DJoins P.n,P.(n+2),G implies
       IT2.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) - P.tolerance()));
    now let e be set; assume
    A19: e in the_Edges_of G;
        now per cases;
          suppose not e in P.edges(); then
            IT1.e = (the_ELabel_of G).e &
            IT2.e = (the_ELabel_of G).e by A17,A18,A19;
            hence IT1.e = IT2.e;
          end;
          suppose e in P.edges(); then consider n being odd Nat such that
        A20: n < len P & P.(n+1) = e by GLIB_001:101;
            now per cases;
              suppose P.(n+1) DJoins P.n,P.(n+2),G; then
                IT1.e = (the_ELabel_of G).(P.(n+1)) + P.tolerance() &
                IT2.e = (the_ELabel_of G).(P.(n+1)) + P.tolerance()
                  by A17,A18,A20;
                hence IT1.e = IT2.e;
              end;
              suppose not P.(n+1) DJoins P.n,P.(n+2),G; then
                IT1.e = (the_ELabel_of G).(P.(n+1)) - P.tolerance() &
                IT2.e = (the_ELabel_of G).(P.(n+1)) - P.tolerance()
                  by A17,A18,A20;
                hence IT1.e = IT2.e;
              end;
            end;
            hence IT1.e = IT2.e;
          end;
        end;
        hence IT1.e = IT2.e;
    end;
    hence thesis by PBOOLE:3;
  end;
end;

registration let G be real-weighted real-elabeled WEGraph,
                 P be augmenting Path of G;
  cluster FF:PushFlow(G,P) -> real-yielding;
  coherence proof
    set F = FF:PushFlow(G,P);
    now let y be set; assume y in rng F; then
        consider e being set such that
    A1: e in dom F & F.e = y by FUNCT_1:def 5;
    A2: e in the_Edges_of G by A1,PBOOLE:def 3;
        now per cases;
          suppose not e in P.edges(); then
            y = (the_ELabel_of G).e by A1,A2,Def20;
            hence y in REAL;
          end;
          suppose e in P.edges(); then consider n being odd Nat such that
        A3: n < len P & P.(n+1) = e by GLIB_001:101;
            now per cases;
              suppose P.(n+1) DJoins P.n, P.(n+2), G; then
                y = (the_ELabel_of G).(P.(n+1))+P.tolerance() by A1,A3,Def20;
                hence y in REAL;
              end;
              suppose not P.(n+1) DJoins P.n,P.(n+2),G; then
                y = (the_ELabel_of G).(P.(n+1))-P.tolerance() by A1,Def20,A3;
                hence y in REAL;
              end;
            end;
            hence y in REAL;
          end;
       end;
       hence y in REAL;
    end; then
    rng F c= REAL by TARSKI:def 3;
    hence F is real-yielding by SEQ_1:def 1;
  end;
end;

registration let G be natural-weighted natural-elabeled WEGraph,
                 P be augmenting Path of G;
  cluster FF:PushFlow(G,P) -> natural-yielding;
  coherence proof
    set F = FF:PushFlow(G,P);
    now let y be set; assume y in rng F; then
        consider e being set such that
    A1: e in dom F & F.e = y by FUNCT_1:def 5;
    A2: e in the_Edges_of G by A1,PBOOLE:def 3;
        now per cases;
          suppose not e in P.edges(); then
            y = (the_ELabel_of G).e by A1,A2,Def20;
            hence y in NAT;
          end;
          suppose
        A3: e in P.edges(); then consider n being odd Nat such that
        A4: n < len P & P.(n+1) = e by GLIB_001:101;
        A5: P is non trivial by GLIB_001:137, A3;
            now per cases;
              suppose P.(n+1) DJoins P.n, P.(n+2), G; then
                y = (the_ELabel_of G).(P.(n+1))+P.tolerance() by A1,A4,Def20;
                hence y in NAT;
              end;
              suppose
            A6: not P.(n+1) DJoins P.n,P.(n+2),G; then
            A7: y = (the_ELabel_of G).e-P.tolerance() by A1,Def20,A4;
                set n1div2 = (n+1) div 2;
                1 <= n+1 & n+1 <= len P by NAT_1:29,A4,NAT_1:38; then
                n1div2 in dom P.edgeSeq() & e = P.edgeSeq().n1div2
                  by A4,GLIB_001:78;then
            A8: n1div2 in dom P.flowSeq() by Def18;
                2 divides n+1 by PEPIN:22; then
            A9: 2*n1div2 = n+1 by NAT_1:49; then
            A10: 2*n1div2-1 = n;
                2*n1div2+1 = n+(1+1) by A9; then
                P.flowSeq().n1div2 = (the_ELabel_of G).e
                  by A4,A6,A8,A10,Def18; then
                (the_ELabel_of G).e in rng P.flowSeq() by A8,FUNCT_1:def 5;then
                P.tolerance() <= (the_ELabel_of G).e by A5,Def19;
                hence y in NAT by A7,INT_1:18;
              end;
            end;
            hence y in NAT;
          end;
       end;
       hence y in NAT;
    end; then
    rng F c= NAT by TARSKI:def 3;
    hence F is natural-yielding by SEQM_3:def 8;
  end;
end;

definition let G be real-weighted real-elabeled WEGraph,
               P be augmenting Path of G;
  func FF:AugmentPath(G,P) -> real-weighted real-elabeled
                              complete-elabeled WEGraph equals  ::dFFAUGP
    G.set(ELabelSelector, FF:PushFlow(G,P));
  coherence;
end;

registration let G be finite real-weighted real-elabeled WEGraph,
               P be augmenting Path of G;
  cluster FF:AugmentPath(G,P) -> finite;
  coherence;
end;

registration let G be finite nonnegative-weighted real-elabeled WEGraph,
                 P be augmenting Path of G;
  cluster FF:AugmentPath(G,P) -> nonnegative-weighted;
  coherence;
end;

registration let G be finite natural-weighted natural-elabeled WEGraph,
                 P be augmenting Path of G;
  cluster FF:AugmentPath(G,P) -> natural-weighted natural-elabeled;
  coherence;
end;

definition let G be finite real-weighted
                    real-elabeled complete-elabeled WEGraph,
               sink, source be Vertex of G;
  func FF:Step(G, source, sink) -> finite real-weighted real-elabeled
                                   complete-elabeled WEGraph equals :Def22: ::dFFSTEP
    FF:AugmentPath(G, AP:GetAugPath(G,source,sink))
      if sink in AP:FindAugPath(G,source).labeledV()
    otherwise G;
  coherence;
  consistency;
end;

registration let G be finite nonnegative-weighted real-elabeled
                      complete-elabeled WEGraph, source,sink be Vertex of G;
  cluster FF:Step(G,source,sink) -> nonnegative-weighted;
  coherence proof
    set P = AP:GetAugPath(G,source,sink);
    now per cases;
      suppose sink in AP:FindAugPath(G,source).labeledV(); then
        FF:Step(G,source,sink) = FF:AugmentPath(G,P) by Def22;
        hence thesis;
      end;
      suppose not sink in AP:FindAugPath(G,source).labeledV();
        hence thesis by Def22;
      end;
    end;
    hence thesis;
  end;
end;

registration let G be finite natural-weighted natural-elabeled
                      complete-elabeled WEGraph, source,sink be Vertex of G;
  cluster FF:Step(G,source,sink) -> natural-weighted natural-elabeled;
  coherence proof
    set P = AP:GetAugPath(G,source,sink);
    now per cases;
      suppose sink in AP:FindAugPath(G,source).labeledV(); then
        FF:Step(G,source,sink) = FF:AugmentPath(G,P) by Def22;
        hence thesis;
      end;
      suppose not sink in AP:FindAugPath(G,source).labeledV();
        hence thesis by Def22;
      end;
    end;
    hence thesis;
  end;
end;

definition let G be finite real-weighted WGraph,
               source,sink be Vertex of G;
  func FF:CompSeq(G,source,sink) -> finite real-weighted real-elabeled
                                    complete-elabeled
                                    WEGraphSeq means :Def23: ::dFFCS
    it.->0 = G.set(ELabelSelector, the_Edges_of G --> 0) &
    for n being Nat holds
      ex source',sink' being Vertex of it.->n
      st source' = source & sink' = sink &
         it.->(n+1) = FF:Step(it.->n,source',sink');
  existence proof
    defpred P[set,set,set] means
    (ex Gn being finite real-weighted real-elabeled complete-elabeled
                WEGraph, source',sink' being Vertex of Gn
     st $2 = Gn & source'=source & sink'=sink &
        $3 = FF:Step(Gn,source',sink')) or
     ((not ex Gn being finite real-weighted real-elabeled complete-elabeled
                WEGraph, source',sink' being Vertex of Gn
      st $2 = Gn & source'=source & sink'=sink) & $2 = $3);
    now let n,x be set;
        now per cases;
          suppose ex Gn being finite real-weighted real-elabeled
              complete-elabeled WEGraph, source',sink' being Vertex of Gn st
              x = Gn & source'=source & sink'=sink; then
            consider Gn being finite real-weighted real-elabeled
              complete-elabeled WEGraph, source',sink' being Vertex of Gn
              such that
        A1: x = Gn & source'=source & sink'=sink;
            set y = FF:Step(Gn,source',sink');
            P[n,x,y] by A1;
            hence ex y being set st P[n,x,y];
          end;
          suppose not ex Gn being finite real-weighted real-elabeled
            complete-elabeled WEGraph, source',sink' being Vertex of Gn st
            x = Gn & source'=source & sink'=sink;
            hence ex y being set st P[n,x,y];
          end;
        end;
        hence ex y being set st P[n,x,y];
    end; then
A2: for n being Nat for x being set ex y being set st P[n,x,y];
A3: for n being Nat for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2]
      holds y1 = y2;
    consider IT being Function such that
A4: dom IT = NAT & IT.0 = G.set(ELabelSelector, the_Edges_of G --> 0) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
      from RECDEF_1:sch 1(A2,A3);
    reconsider IT as ManySortedSet of NAT by A4, PBOOLE:def 3;
    defpred P2[Nat] means
      ex Gn being finite real-weighted real-elabeled complete-elabeled
        WEGraph st IT.$1 = Gn & Gn == G;
    reconsider E0 = the_Edges_of G --> 0 as Function of the_Edges_of G, REAL
      by FUNCOP_1:58;
    set G0 = G.set(ELabelSelector, E0);
    G0 == G by GLIB_003:8; then
A5: P2[0] by A4;
A6: now let n be Nat; assume P2[n]; then
        consider Gn being finite real-weighted real-elabeled
          complete-elabeled WEGraph such that
    A7: IT.n = Gn & Gn == G;
        reconsider source'=source, sink'=sink as Vertex of Gn
          by A7,GLIB_000:def 36;
    A8: P[n,Gn,IT.(n+1)] by A4,A7;
        set P = AP:GetAugPath(Gn,source',sink');
        now per cases;
           suppose sink in AP:FindAugPath(Gn,source').labeledV(); then
             IT.(n+1) = FF:AugmentPath(Gn,P) by A8,Def22
                     .= Gn.set(ELabelSelector,FF:PushFlow(Gn,P));
             hence FF:Step(Gn,source',sink') == Gn by A8,GLIB_003:8;
           end;
           suppose not sink in AP:FindAugPath(Gn,source').labeledV();
             hence FF:Step(Gn,source',sink') == Gn by Def22;
           end;
        end; then
        FF:Step(Gn,source',sink') == G by A7,GLIB_000:88;
        hence P2[n+1] by A8;
    end;
A9: for n being Nat holds P2[n] from NAT_1:sch 1(A5,A6);
    now let n be Nat;
        consider Gn being finite real-weighted real-elabeled
                          complete-elabeled WEGraph such that
    A10: IT.n = Gn & Gn == G by A9;
        thus IT.n is _Graph by A10;
    end; then reconsider IT as GraphSeq by GLIB_000:def 55;
A11: now let n be Nat;
        consider Gn being finite real-weighted real-elabeled
          complete-elabeled WEGraph such that
    A12: IT.->n = Gn & Gn == G by A9;
        thus IT.->n is finite real-weighted real-elabeled
          complete-elabeled WEGraph by A12;
    end; then
    for n being Nat holds
      IT.->n is [Weighted] & IT.->n is [ELabeled]; then
    reconsider IT as WEGraphSeq by GLIB_003:def 24,GLIB_003:def 25;
    for n being Nat holds IT.->n is finite & IT.->n is real-weighted &
      IT.->n is real-elabeled & IT.->n is complete-elabeled by A11; then
    reconsider IT as finite real-weighted real-elabeled
      complete-elabeled WEGraphSeq
      by GLIB_000:def 60,GLIB_003:def 27,GLIB_003:def 29,Def2;
    take IT;
    thus IT.->0 = G.set(ELabelSelector,the_Edges_of G --> 0)
      by A4;
    let n be Nat;
    consider Gn being finite real-weighted real-elabeled
                      complete-elabeled WEGraph such that
A13: IT.n = Gn & Gn == G by A9;
    the_Vertices_of Gn = the_Vertices_of G by A13,GLIB_000:def 36; then
    reconsider source'=source,sink'=sink as Vertex of IT.->n
      by A13;
    take source',sink';
    thus source'=source & sink'=sink;
    IT.->n is finite real-weighted real-elabeled complete-elabeled WEGraph &
    source' is Vertex of IT.->n & sink' is Vertex of IT.->n & IT.->n = Gn &
    source'=source & sink'=sink by A13; then
    consider X being finite real-weighted real-elabeled complete-elabeled
      WEGraph, sourceX,sinkX being Vertex of X such that
A14: X = Gn & sourceX = source & sinkX = sink &
      IT.(n+1) = FF:Step(X,sourceX,sinkX) by A4;
A15: X = IT.->n & sourceX = source' & sink'= sink by A13,A14;
    thus IT.->(n+1) = FF:Step(IT.->n,source',sink') by A14,A15;
  end;
  uniqueness proof
    let IT1,IT2 be finite real-weighted real-elabeled complete-elabeled
                   WEGraphSeq such that
A16: IT1.->0 = G.set(ELabelSelector, the_Edges_of G --> 0) &
    for n being Nat holds
      ex source',sink' being Vertex of IT1.->n
      st source' = source & sink' = sink &
         IT1.->(n+1) = FF:Step(IT1.->n,source',sink') and
A17: IT2.->0 = G.set(ELabelSelector, the_Edges_of G --> 0) &
    for n being Nat holds
      ex source',sink' being Vertex of IT2.->n
      st source' = source & sink' = sink &
         IT2.->(n+1) = FF:Step(IT2.->n,source',sink');
    defpred P[Nat] means IT1.$1 = IT2.$1;
    IT1.0 = IT2.->0 by A16,A17; then
A18: P[0];
A19: now let n be Nat; assume P[n]; then
        IT1.n = IT2.->n; then
    A20: IT1.->n = IT2.->n;
        consider source1,sink1 being Vertex of IT1.->n such that
    A21: source1=source & sink1=sink &
        IT1.->(n+1) = FF:Step(IT1.->n,source1,sink1) by A16;
        consider source2,sink2 being Vertex of IT2.->n such that
    A22: source2=source & sink2 = sink &
        IT2.->(n+1) = FF:Step(IT2.->n,source2,sink2) by A17;
        IT1.->(n+1) = IT2.(n+1) by A20,A21,A22;
        hence P[n+1];
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A18,A19); then
    for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

registration let G be finite nonnegative-weighted WGraph,
                 sink, source be Vertex of G;
  cluster FF:CompSeq(G,source,sink) -> nonnegative-weighted;
  coherence proof
    set CS = FF:CompSeq(G,source,sink);
    defpred P[Nat] means CS.->$1 is nonnegative-weighted;
    CS.->0 = G.set(ELabelSelector, the_Edges_of G --> 0) by Def23; then
A1: P[0];
A2: now let n be Nat; assume
    A3: P[n]; set Gn = CS.->n, Gn1 = CS.->(n+1);
        reconsider Gn as finite nonnegative-weighted real-elabeled
          complete-elabeled WEGraph by A3;
        consider source',sink' being Vertex of Gn such that
    A4: source'=source & sink'=sink & Gn1 = FF:Step(Gn,source',sink')
          by Def23;
        thus P[n+1] by A4;
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis by GLIB_003:def 28;
  end;
end;

registration let G be finite natural-weighted WGraph,
                 sink,source be Vertex of G;
  cluster FF:CompSeq(G,source,sink) -> natural-weighted natural-elabeled;
  coherence proof
    set CS = FF:CompSeq(G,source,sink);
    defpred P[Nat] means
      CS.->$1 is natural-elabeled & CS.->$1 is natural-weighted;
    CS.->0 = G.set(ELabelSelector, the_Edges_of G --> 0) by Def23; then
A1: P[0];
A2: now let n be Nat; assume
    A3: P[n]; set Gn = CS.->n, Gn1 = CS.->(n+1);
        reconsider Gn as finite natural-weighted natural-elabeled
          complete-elabeled WEGraph by A3;
        consider source',sink' being Vertex of Gn such that
    A4: source'=source & sink'=sink & Gn1 = FF:Step(Gn,source',sink')
          by Def23;
        thus P[n+1] by A4;
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis by Def5,Def6;
  end;
end;

definition let G be finite real-weighted WGraph, sink,source be Vertex of G;
  func FF:MaxFlow(G,source, sink) -> finite real-weighted real-elabeled
                                  complete-elabeled WEGraph equals  ::dFFMAXFLOW
    FF:CompSeq(G,source,sink).Result();
  coherence proof
    set CS = FF:CompSeq(G,source,sink);
    CS.Result() = CS.(CS.Lifespan())
               .= CS.->(CS.Lifespan());
    hence thesis;
  end;
end;

begin :: Ford Fulkerson Maximum Flow Theorems

theorem Th11: :: tFLOW01
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
        source, sink being set, V being Subset of the_Vertices_of G
   st G has_valid_flow_from source,sink &
      source in V & not sink in V holds
      G.flow(source,sink) =
      Sum ((the_ELabel_of G) | G.edgesDBetween(V, the_Vertices_of G \ V)) -
      Sum ((the_ELabel_of G) | G.edgesDBetween(the_Vertices_of G \ V, V)) proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set, V be Subset of the_Vertices_of G; assume
A1: G has_valid_flow_from source,sink & source in V & not sink in V;
    set EL = the_ELabel_of G, VG = the_Vertices_of G;
    defpred P[Nat] means
      for V being Subset of VG
       st card (the_Vertices_of G \ V) = $1 & source in V & not sink in V holds
       G.flow(source,sink) =
       Sum (EL | G.edgesDBetween(V, the_Vertices_of G \ V)) -
       Sum (EL | G.edgesDBetween(the_Vertices_of G \ V, V));
    now let V be Subset of the_Vertices_of G; assume
    A2: card (the_Vertices_of G \ V) = 1 & source in V & not sink in V; then
        consider v being set such that
    A3: the_Vertices_of G \ V = {v} by CARD_2:60;
        sink is Vertex of G by A1,Def7; then
        sink in the_Vertices_of G \ V by A2,XBOOLE_0:def 4; then
    A4: v = sink by A3,TARSKI:def 1;
    A5: now let x be set;
            hereby assume x in the_Vertices_of G \ {sink}; then
                x in the_Vertices_of G & not x in {sink} by XBOOLE_0:def 4;
                hence x in V by A3,A4,XBOOLE_0:def 4;
            end;
            assume
        A6: x in V; then
            not x in {sink} by A2,TARSKI:def 1;
            hence x in the_Vertices_of G \ {sink} by A6,XBOOLE_0:def 4;
        end; then
    A7: V = the_Vertices_of G \ {sink} by TARSKI:2;
        set ESS = G.edgesDBetween({sink},{sink});
        reconsider EIN = G.edgesInto({sink}) \ ESS as Subset of the_Edges_of G
          by XBOOLE_1:1;
        reconsider EOUT= G.edgesOutOf({sink})\ ESS as Subset of the_Edges_of G
          by XBOOLE_1:1;
        set EESS = (the_ELabel_of G)|ESS;
        now let e be set;
            hereby assume e in G.edgesDBetween(V, the_Vertices_of G \ V); then
                e DSJoins the_Vertices_of G \ {sink}, {sink},G
                  by A3,A4,A7,GLIB_000:def 33; then
            A8: e in the_Edges_of G &
                (the_Source_of G).e in the_Vertices_of G \ {sink} &
                (the_Target_of G).e in {sink} by GLIB_000:def 18; then
            A9: e in G.edgesInto({sink}) by GLIB_000:def 28;
                now assume e in ESS; then
                    e DSJoins {sink},{sink},G by GLIB_000:def 33; then
                    (the_Source_of G).e in {sink} by GLIB_000:def 18;
                    hence contradiction by A8,XBOOLE_0:def 4;
                end;
                hence e in EIN by A9,XBOOLE_0:def 4;
            end;
            assume
        A10: e in EIN; then
        A11: e in G.edgesInto({sink}) & not e in ESS by XBOOLE_0:def 4;
        A12: e in the_Edges_of G & (the_Target_of G).e in {sink}
              by A10,GLIB_000:def 28;
            now assume not (the_Source_of G).e in V; then
            A13: not (the_Source_of G).e in the_Vertices_of G \ {sink}
                  by A5;
                (the_Source_of G).e in the_Vertices_of G
                  by A10,FUNCT_2:7; then
                (the_Source_of G).e in {sink}
                  by A13,XBOOLE_0:def 4; then
                e DSJoins {sink},{sink},G by A12,GLIB_000:def 18;
                hence contradiction by A11,GLIB_000:def 33;
            end; then
            e DSJoins V, {sink}, G by A12,GLIB_000:def 18;
            hence e in G.edgesDBetween(V, the_Vertices_of G \ V)
              by A3,A4,GLIB_000:def 33;
        end; then
    A14: G.edgesDBetween(V, the_Vertices_of G \ V) = EIN by TARSKI:2;
        now let e be set; assume e in ESS; then
            e DSJoins {sink},{sink},G by GLIB_000:def 33; then
            e in the_Edges_of G & (the_Target_of G).e in {sink}
              by GLIB_000:def 18;
            hence e in G.edgesInto({sink}) by GLIB_000:def 28;
        end; then
    A15: ESS c= G.edgesInto({sink}) by TARSKI:def 3;
    A16: ESS \/ EIN = G.edgesInto({sink}) \/ ESS by XBOOLE_1:39
                  .= G.edgesInto({sink}) by A15,XBOOLE_1:12;
    A17: dom (EL|G.edgesInto({sink})) = G.edgesInto({sink}) & dom (EL|ESS)=ESS
&
          dom (EL|EIN)=EIN & dom (EL|EOUT)=EOUT & dom (EL|G.edgesOutOf({sink}))
          = G.edgesOutOf({sink}) by PBOOLE:def 3; then
    A18: dom (EL|ESS +* EL|EIN) = ESS \/ EIN by FUNCT_4:def 1;
        now let e be set; assume
        A19: e in dom (EL|G.edgesInto({sink})); then
        A20: e in G.edgesInto({sink}) by PBOOLE:def 3;
            now per cases;
              suppose
            A21: e in ESS; then
                not e in EIN by XBOOLE_0:def 4;
                hence (EL|ESS +* EL|EIN).e = (EL|ESS).e by A17,FUNCT_4:12
                                          .= EL.e by A21,A17,FUNCT_1:70;

              end;
              suppose not e in ESS; then
            A22: e in EIN by A20,XBOOLE_0:def 4;
                hence (EL|ESS +* EL|EIN).e = (EL|EIN).e by A17,FUNCT_4:14
                                          .= EL.e by A22,A17,FUNCT_1:70;
              end;
            end;
            hence (the_ELabel_of G)|G.edgesInto({sink}).e =
              ((the_ELabel_of G)|ESS +* (the_ELabel_of G)|EIN).e
              by A19,FUNCT_1:70;
        end; then
        EL|G.edgesInto({sink}) = EL|ESS +* EL|EIN by A16,A17,A18,FUNCT_1:9;
then
    A23: Sum (EL|G.edgesInto({sink})) = Sum (EL|EIN) + Sum EESS by GLIB_004:3;
        now let e be set;
            hereby assume e in G.edgesDBetween(the_Vertices_of G \ V, V); then
                e DSJoins {sink},(the_Vertices_of G \ {sink}),G
                  by A3,A4,A7,GLIB_000:def 33; then
            A24: e in the_Edges_of G & (the_Source_of G).e in {sink} &
                (the_Target_of G).e in (the_Vertices_of G \ {sink})
                  by GLIB_000:def 18; then
            A25: e in G.edgesOutOf({sink}) by GLIB_000:def 29;
                now assume e in ESS; then
                    e DSJoins {sink},{sink},G by GLIB_000:def 33; then
                    (the_Target_of G).e in {sink} by GLIB_000:def 18;
                    hence contradiction by A24,XBOOLE_0:def 4;
                end;
                hence e in EOUT by A25,XBOOLE_0:def 4;
            end;
            assume
        A26: e in EOUT; then
        A27: e in G.edgesOutOf({sink}) & not e in ESS by XBOOLE_0:def 4;
        A28: e in the_Edges_of G & (the_Source_of G).e in {sink}
              by GLIB_000:def 29,A26;
            now assume
            A29: not (the_Target_of G).e in V;
                (the_Target_of G).e in the_Vertices_of G
                  by A26,FUNCT_2:7; then
                (the_Target_of G).e in {sink} by A29,A7,XBOOLE_0:def 4; then
                e DSJoins {sink},{sink},G by A28,GLIB_000:def 18;
                hence contradiction by A27,GLIB_000:def 33;
            end; then
            e DSJoins (the_Vertices_of G \ V),V,G by A28,A3,A4,GLIB_000:def 18;
            hence e in G.edgesDBetween(the_Vertices_of G \ V, V)
              by GLIB_000:def 33;
        end; then
    A30: G.edgesDBetween(the_Vertices_of G \ V, V) = EOUT by TARSKI:2;
        now let e be set; assume e in ESS; then
            e DSJoins {sink},{sink},G by GLIB_000:def 33; then
            e in the_Edges_of G & (the_Source_of G).e in {sink}
              by GLIB_000:def 18;
            hence e in G.edgesOutOf({sink}) by GLIB_000:def 29;
        end; then
    A31: ESS c= G.edgesOutOf({sink}) by TARSKI:def 3;
        ESS \/ EOUT = G.edgesOutOf({sink}) \/ ESS by XBOOLE_1:39
                   .= G.edgesOutOf({sink}) by A31,XBOOLE_1:12; then
    A32: dom (EL|ESS +* EL|EOUT) = G.edgesOutOf({sink}) by A17,FUNCT_4:def 1;
        now let e be set; assume
        A33: e in dom (EL|G.edgesOutOf({sink})); then
        A34: e in G.edgesOutOf({sink}) by PBOOLE:def 3;
            now per cases;
              suppose
            A35: e in ESS; then
                not e in EOUT by XBOOLE_0:def 4;
                hence (EL|ESS +* EL|EOUT).e = (EL|ESS).e by A17,FUNCT_4:12
                                           .= EL.e by A35,A17,FUNCT_1:70;
              end;
              suppose not e in ESS; then
            A36: e in EOUT by A34,XBOOLE_0:def 4;
                hence (EL|ESS +* EL|EOUT).e = (EL|EOUT).e by A17,FUNCT_4:14
                                           .= EL.e by A36,A17,FUNCT_1:70;
              end;
            end;
            hence EL|G.edgesOutOf({sink}).e = (EL|ESS +* EL|EOUT).e
              by A33,FUNCT_1:70;
        end; then
        EL|G.edgesOutOf({sink}) = EL|ESS +* EL|EOUT by A17,A32,FUNCT_1:9; then
        Sum (EL|G.edgesOutOf({sink})) = Sum (EL|EOUT)+Sum EESS by GLIB_004:3;
        then
        G.flow(source,sink) = Sum (EL|EIN)+Sum EESS -(Sum EESS + Sum (EL|EOUT))
                                by A1,A23,Def8
                           .= Sum (EL|EIN) - Sum (EL|EOUT);
        hence G.flow(source,sink) =
          Sum (EL | G.edgesDBetween(V, the_Vertices_of G \ V)) -
          Sum (EL | G.edgesDBetween(the_Vertices_of G \ V, V)) by A14,A30;
    end; then
A37: P[1];
A38: now let n be non empty Nat; assume
    A39: P[n];
        now let V2 be Subset of VG; assume
        A40: card (VG\V2) = n+1 & source in V2 & not sink in V2;
            set x = choose ((VG \ V2) \ {sink});
            sink is Vertex of G by A1,Def7; then
            sink in (VG \ V2) by A40,XBOOLE_0:def 4; then
            {sink} c= (VG \ V2) by ZFMISC_1:37; then
            card ((VG\V2)\{sink}) = n+1-card {sink} by A40,CARD_2:63
                                 .= n+1-1 by CARD_1:79
                                 .= n; then
        A41: x in (VG)\V2 & not x in {sink} by CARD_1:78,XBOOLE_0:def 4; then
        A42: x in VG & not x in V2 by XBOOLE_0:def 4;
            set V1 = V2 \/ {x};
            set EV1V1a = G.edgesDBetween(V1, VG \ V1);
            set EV1V1b = G.edgesDBetween(VG \ V1, V1);
            set EV2X   = G.edgesDBetween(V2,{x});
            set EXV2   = G.edgesDBetween({x},V2);
            set EXV1c  = G.edgesDBetween({x},VG\V1);
            set EV1Xd  = G.edgesDBetween(VG\V1,{x});
            {x} c= VG by A41,ZFMISC_1:37; then
            reconsider V1 as Subset of VG by XBOOLE_1:8;
        A43: VG \ V1 = (VG \ V2) \ {x} by XBOOLE_1:41;
            {x} c= VG \ V2 by A41,ZFMISC_1:37; then
        A44: card (VG \ V1) = card (VG \ V2) - card {x} by A43,CARD_2:63
                          .= n + 1 - 1 by A40,CARD_1:79
                          .= n;
        A45: source in V1 by A40,XBOOLE_0:def 2;
        A46: x <> sink by A41,TARSKI:def 1; then
            not sink in {x} by TARSKI:def 1; then
            not sink in V1 by A40,XBOOLE_0:def 2; then
        A47: G.flow(source,sink) = Sum (EL|EV1V1a) - Sum (EL|EV1V1b)
              by A39,A44,A45;
            now let e be set;
                hereby assume e in G.edgesDBetween(V2, VG \ V2); then
                    e DSJoins V2, VG \ V2, G by GLIB_000:def 33; then
                A48: e in the_Edges_of G & (the_Source_of G).e in V2 &
                    (the_Target_of G).e in VG \ V2 by GLIB_000:def 18; then
                A49: (the_Source_of G).e in V1 by XBOOLE_0:def 2;
                A50: now assume e in EXV1c; then
                        e DSJoins {x},VG \ V1,G by GLIB_000:def 33; then
                        (the_Source_of G).e in {x} by GLIB_000:def 18;
                        hence contradiction by A48,A42,TARSKI:def 1;
                    end;
                    now per cases;
                      suppose (the_Target_of G).e in {x}; then
                        e DSJoins V2,{x},G by A48,GLIB_000:def 18; then
                        e in EV2X by GLIB_000:def 33; then
                        e in EV1V1a \/ EV2X by XBOOLE_0:def 2;
                        hence e in EV1V1a \/ EV2X \ EXV1c by A50,XBOOLE_0:def 4
;
                      end;
                      suppose not (the_Target_of G).e in {x}; then
                        (the_Target_of G).e in VG \ V1
                          by A43,A48,XBOOLE_0:def 4; then
                        e DSJoins V1, VG \ V1, G by A48,A49,GLIB_000:def 18;
then
                        e in EV1V1a by GLIB_000:def 33; then
                        e in EV1V1a \/ EV2X by XBOOLE_0:def 2;
                        hence e in EV1V1a \/ EV2X \ EXV1c by A50,XBOOLE_0:def 4
;
                      end;
                    end;
                    hence e in EV1V1a \/ EV2X \ EXV1c;
                end;
                assume
            A51: e in EV1V1a \/ EV2X \ EXV1c; then
                e in EV1V1a \/ EV2X & not e in EXV1c by XBOOLE_0:def 4; then
            A52: not e DSJoins {x}, VG \ V1,G by GLIB_000:def 33;
                now per cases by A51,XBOOLE_0:def 2;
                  suppose e in EV1V1a; then
                    e DSJoins V1, VG\V1, G by GLIB_000:def 33; then
                A53: e in the_Edges_of G & (the_Source_of G).e in V1 &
                    (the_Target_of G).e in VG \ V1 by GLIB_000:def 18; then
                    not (the_Source_of G).e in {x} by A52,GLIB_000:def 18; then
                    (the_Source_of G).e in V1 \ {x} by A53,XBOOLE_0:def 4; then
                A54: (the_Source_of G).e in V2 \ {x} by XBOOLE_1:40;
                    (the_Target_of G).e in VG &
                      not (the_Target_of G).e in V1 by A53, XBOOLE_0:def 4;
then
                    not (the_Target_of G).e in V2 by XBOOLE_0:def 2; then
                    (the_Target_of G).e in VG \ V2 by A53,XBOOLE_0:def 4;
                    hence e DSJoins V2, VG \ V2, G by A53,A54,GLIB_000:def 18;
                  end;
                  suppose e in EV2X; then
                    e DSJoins V2, {x}, G by GLIB_000:def 33; then
                A55: e in the_Edges_of G & (the_Source_of G).e in V2 &
                    (the_Target_of G).e in {x} by GLIB_000:def 18;
                A56: (the_Target_of G).e in VG by A55, FUNCT_2:7;
                    not (the_Target_of G).e in V2 by A42,A55,TARSKI:def 1; then
                    (the_Target_of G).e in VG \ V2 by A56, XBOOLE_0:def 4;
                    hence e DSJoins V2, VG \ V2, G by A55,GLIB_000:def 18;
                  end;
                end;
                hence e in G.edgesDBetween(V2, VG \ V2) by GLIB_000:def 33;
            end; then
        A57: G.edgesDBetween(V2, VG \ V2) = EV1V1a \/ EV2X \ EXV1c
              by TARSKI:2;
            reconsider EA = EV1V1a \/ EV2X as Subset of the_Edges_of G;
            reconsider E1 = EA \ EXV1c as Subset of the_Edges_of G
              by XBOOLE_1:1;
            reconsider EB = EA \ EV2X as Subset of the_Edges_of G
              by XBOOLE_1:1;
            reconsider EC = EV1V1b \/ EXV2 as Subset of the_Edges_of G;
            reconsider E2 = EC \ EV1Xd as Subset of the_Edges_of G
              by XBOOLE_1:1;
            reconsider ED = EC \ EXV2 as Subset of the_Edges_of G
              by XBOOLE_1:1;
            now assume EV1V1a meets EV2X; then
            A58: EV1V1a /\ EV2X <> {} by XBOOLE_0:def 7;
                set e = choose (EV1V1a /\ EV2X);
                e in EV1V1a & e in EV2X by A58,XBOOLE_0:def 3; then
                e DSJoins V1,VG\V1,G & e DSJoins V2,{x},G
                  by GLIB_000:def 33; then
                (the_Target_of G).e in VG \ V1 &
                  (the_Target_of G).e in {x} by GLIB_000:def 18; then
                not (the_Target_of G).e in V1 &
                (the_Target_of G).e in V1 by XBOOLE_0:def 2, XBOOLE_0:def 4;
                hence contradiction;
            end; then
            EV1V1a \ EV2X = EV1V1a by XBOOLE_1:83; then
        A59: EB = EV1V1a by XBOOLE_1:40;
            now assume EV1V1b meets EXV2; then
            A60: EV1V1b /\ EXV2 <> {} by XBOOLE_0:def 7;
                set e = choose (EV1V1b /\ EXV2);
                e in EV1V1b & e in EXV2 by A60,XBOOLE_0:def 3; then
                e DSJoins VG\V1,V1,G & e DSJoins {x},V2,G
                  by GLIB_000:def 33; then
                (the_Source_of G).e in VG \ V1 &
                  (the_Source_of G).e in {x} by GLIB_000:def 18; then
                not (the_Source_of G).e in V1 &
                (the_Source_of G).e in V1 by XBOOLE_0:def 2, XBOOLE_0:def 4;
                hence contradiction;
            end; then
            EV1V1b \ EXV2 = EV1V1b by XBOOLE_1:83; then
        A61: ED = EV1V1b by XBOOLE_1:40;
            now let e be set; assume e in EXV1c; then
                e DSJoins {x},VG \ V1, G by GLIB_000:def 33; then
            A62: e in the_Edges_of G & (the_Source_of G).e in {x} &
                (the_Target_of G).e in VG \ V1 by GLIB_000:def 18; then
                (the_Source_of G).e in V1 by XBOOLE_0:def 2; then
                e DSJoins V1,VG \ V1, G by A62, GLIB_000:def 18;
                hence e in EV1V1a by GLIB_000:def 33;
            end; then
            EXV1c c= EV1V1a by TARSKI:def 3; then
        A63: EXV1c c= (EV1V1a \/ EV2X) by XBOOLE_1:10;
        A64: dom (EL|EA) = EA & dom (EL|EB) = EB & dom (EL|EXV1c) = EXV1c &
              dom (EL|EV2X)=EV2X & dom (EL|E1)=EA \ EXV1c by PBOOLE:def 3;then
        A65: dom (EL|EXV1c +* EL|E1) = EXV1c \/ (EA \ EXV1c) by FUNCT_4:def 1
                                   .= EXV1c \/ (EV1V1a \/ EV2X) by XBOOLE_1:39
                                   .= EA by A63,XBOOLE_1:12;
            now let e be set; assume e in dom (EL|EA); then
            A66: e in EA by PBOOLE:def 3;
                now per cases;
                  suppose not e in EXV1c; then
                A67: e in E1 by A66,XBOOLE_0:def 4;
                    hence (EL|EXV1c +* EL|E1).e = (EL|E1).e by A64,FUNCT_4:14
                                               .= EL.e by A67,FUNCT_1:72;
                  end;
                  suppose
                A68: e in EXV1c; then
                    not e in E1 by XBOOLE_0:def 4;
                    hence (EL|EXV1c +* EL|E1).e = (EL|EXV1c).e by A64,FUNCT_4:
12
                                               .= EL.e by A68, FUNCT_1:72;
                  end;
                end;
                hence (EL|EA).e = (EL|EXV1c +* EL|E1).e by A66,FUNCT_1:72;
            end; then
            EL|EA = EL|EXV1c +* EL|E1 by A64,A65,FUNCT_1:9; then
            Sum (EL|EA) = Sum (EL|E1) + Sum (EL|EXV1c) by GLIB_004:3; then
        A69: Sum (EL|E1) = Sum (EL|EA) - Sum (EL|EXV1c);
        A70: dom (EL|EV2X +* EL|EB) = EV2X \/ EB by A64, FUNCT_4:def 1
                                  .= EV2X \/ (EV1V1a \/ EV2X) by XBOOLE_1:39
                                  .= EA by XBOOLE_1:6;
            now let e be set; assume e in dom (EL|EA); then
            A71: e in EA by PBOOLE:def 3;
                now per cases;
                  suppose not e in EV2X; then
                A72: e in EB by A71,XBOOLE_0:def 4;
                    hence (EL|EV2X +* EL|EB).e = (EL|EB).e by A64,FUNCT_4:14
                                               .= EL.e by A72,FUNCT_1:72;
                  end;
                  suppose
                A73: e in EV2X; then
                    not e in EB by XBOOLE_0:def 4;
                    hence (EL|EV2X +* EL|EB).e = (EL|EV2X).e by A64,FUNCT_4:12
                                               .= EL.e by A73, FUNCT_1:72;
                  end;
                end;
                hence (EL|EA).e = (EL|EV2X +* EL|EB).e by A71,FUNCT_1:72;
            end; then
            EL|EA = EL|EV2X +* EL|EB by A64,A70,FUNCT_1:9; then
        A74: Sum (EL|EA) = Sum (EL|EV2X) + Sum (EL|EV1V1a) by A59,GLIB_004:3;
            now let e be set; assume e in EV1Xd; then
                e DSJoins VG\V1,{x}, G by GLIB_000:def 33; then
            A75: e in the_Edges_of G & (the_Target_of G).e in {x} &
                (the_Source_of G).e in VG \ V1 by GLIB_000:def 18; then
                (the_Target_of G).e in V1 by XBOOLE_0:def 2; then
                e DSJoins VG\V1,V1, G by A75, GLIB_000:def 18;
                hence e in EV1V1b by GLIB_000:def 33;
            end; then
            EV1Xd c= EV1V1b by TARSKI:def 3; then
        A76: EV1Xd c= (EV1V1b \/ EXV2) by XBOOLE_1:10;
            now let e be set;
                hereby assume e in G.edgesDBetween(VG \ V2, V2); then
                    e DSJoins VG\V2, V2, G by GLIB_000:def 33; then
                A77: e in the_Edges_of G & (the_Target_of G).e in V2 &
                    (the_Source_of G).e in VG \ V2 by GLIB_000:def 18; then
                A78: (the_Target_of G).e in V1 by XBOOLE_0:def 2;
                A79: now assume e in EV1Xd; then
                        e DSJoins VG \ V1,{x},G by GLIB_000:def 33; then
                        (the_Target_of G).e in {x} by GLIB_000:def 18;
                        hence contradiction by A77,A42,TARSKI:def 1;
                    end;
                    now per cases;
                      suppose (the_Source_of G).e in {x}; then
                        e DSJoins {x},V2,G by A77,GLIB_000:def 18; then
                        e in EXV2 by GLIB_000:def 33; then
                        e in EV1V1b \/ EXV2 by XBOOLE_0:def 2;
                        hence e in EV1V1b \/ EXV2 \ EV1Xd by A79,XBOOLE_0:def 4
;
                      end;
                      suppose not (the_Source_of G).e in {x}; then
                        (the_Source_of G).e in VG \ V1
                          by A43,A77,XBOOLE_0:def 4; then
                        e DSJoins VG \ V1, V1, G by A77,A78,GLIB_000:def 18;
then
                        e in EV1V1b by GLIB_000:def 33; then
                        e in EV1V1b \/ EXV2 by XBOOLE_0:def 2;
                        hence e in EV1V1b \/ EXV2 \ EV1Xd by A79,XBOOLE_0:def 4
;
                      end;
                    end;
                    hence e in EV1V1b \/ EXV2 \ EV1Xd;
                end;
                assume
            A80: e in EV1V1b \/ EXV2 \ EV1Xd; then
                e in EV1V1b \/ EXV2 & not e in EV1Xd by XBOOLE_0:def 4; then
            A81: not e DSJoins VG \ V1, {x}, G by GLIB_000:def 33;
                now per cases by A80,XBOOLE_0:def 2;
                  suppose e in EV1V1b; then
                    e DSJoins VG\V1, V1, G by GLIB_000:def 33; then
                A82: e in the_Edges_of G & (the_Target_of G).e in V1 &
                    (the_Source_of G).e in VG \ V1 by GLIB_000:def 18; then
                    not (the_Target_of G).e in {x} by A81,GLIB_000:def 18; then
                    (the_Target_of G).e in V1 \ {x} by A82,XBOOLE_0:def 4; then
                A83: (the_Target_of G).e in V2 \ {x} by XBOOLE_1:40;
                    (the_Source_of G).e in VG &
                      not (the_Source_of G).e in V1 by A82, XBOOLE_0:def 4;
then
                    not (the_Source_of G).e in V2 by XBOOLE_0:def 2; then
                    (the_Source_of G).e in VG \ V2 by A82,XBOOLE_0:def 4;
                    hence e DSJoins VG \ V2, V2, G by A82,A83,GLIB_000:def 18;
                  end;
                  suppose e in EXV2; then
                    e DSJoins {x},V2, G by GLIB_000:def 33; then
                A84: e in the_Edges_of G & (the_Target_of G).e in V2 &
                    (the_Source_of G).e in {x} by GLIB_000:def 18;
                A85: (the_Source_of G).e in VG by A84, FUNCT_2:7;
                    not (the_Source_of G).e in V2 by A84,A42,TARSKI:def 1; then
                    (the_Source_of G).e in VG \ V2 by A85, XBOOLE_0:def 4;
                    hence e DSJoins VG \ V2, V2, G by A84,GLIB_000:def 18;
                  end;
                end;
                hence e in G.edgesDBetween(VG\V2,V2) by GLIB_000:def 33;
            end; then
        A86: G.edgesDBetween(VG \ V2, V2) = E2 by TARSKI:2;
        A87: dom (EL|EC) = EC & dom (EL|ED) = ED & dom (EL|EV1Xd) = EV1Xd &
              dom (EL|EXV2)=EXV2 & dom (EL|E2)=EC\EV1Xd by PBOOLE:def 3;then
        A88: dom (EL|EV1Xd +* EL|E2) = EV1Xd \/ (EC \ EV1Xd) by FUNCT_4:def 1
                                   .= EV1Xd \/ (EV1V1b \/ EXV2) by XBOOLE_1:39
                                   .= EC by A76,XBOOLE_1:12;
            now let e be set; assume e in dom (EL|EC); then
            A89: e in EC by PBOOLE:def 3;
                now per cases;
                  suppose not e in EV1Xd; then
                A90: e in E2 by A89,XBOOLE_0:def 4;
                    hence (EL|EV1Xd +* EL|E2).e = (EL|E2).e by A87,FUNCT_4:14
                                               .= EL.e by A90,FUNCT_1:72;
                  end;
                  suppose
                A91: e in EV1Xd; then
                    not e in E2 by XBOOLE_0:def 4;
                    hence (EL|EV1Xd +* EL|E2).e = (EL|EV1Xd).e by A87,FUNCT_4:
12
                                               .= EL.e by A91, FUNCT_1:72;
                  end;
                end;
                hence (EL|EC).e = (EL|EV1Xd +* EL|E2).e by A89,FUNCT_1:72;
            end; then
            EL|EC = EL|EV1Xd +* EL|E2 by A87,A88,FUNCT_1:9; then
            Sum (EL|EC) = Sum (EL|E2) + Sum (EL|EV1Xd) by GLIB_004:3; then
        A92: Sum (EL|E2) = Sum (EL|EC) - Sum (EL|EV1Xd);
        A93: dom (EL|EXV2 +* EL|ED) = EXV2 \/ ED by A87, FUNCT_4:def 1
                                  .= EXV2 \/ (EV1V1b \/ EXV2) by XBOOLE_1:39
                                  .= EC by XBOOLE_1:6;
            now let e be set; assume e in dom (EL|EC); then
            A94: e in EC by PBOOLE:def 3;
                now per cases;
                  suppose not e in EXV2; then
                A95: e in ED by A94,XBOOLE_0:def 4;
                    hence (EL|EXV2 +* EL|ED).e = (EL|ED).e by A87,FUNCT_4:14
                                               .= EL.e by A95,FUNCT_1:72;
                  end;
                  suppose
                A96: e in EXV2; then
                    not e in ED by XBOOLE_0:def 4;
                    hence (EL|EXV2 +* EL|ED).e = (EL|EXV2).e by A87,FUNCT_4:12
                                               .= EL.e by A96, FUNCT_1:72;
                  end;
                end;
                hence (EL|EC).e = (EL|EXV2 +* EL|ED).e by A94,FUNCT_1:72;
            end; then
            EL|EC = EL|EXV2 +* EL|ED by A87,A93,FUNCT_1:9; then
        A97: Sum (EL|EC) = Sum (EL|EXV2) + Sum (EL|EV1V1b) by A61,GLIB_004:3;

            set EXXe = G.edgesDBetween({x}, VG \ {x});
            set EXXf = G.edgesDBetween(VG \ {x}, {x});
        A98: now let e be set;
                hereby assume e in EXXf \ EV2X; then
                    e in EXXf & not e in EV2X by XBOOLE_0:def 4; then
                A99: e DSJoins VG \ {x}, {x}, G & not e DSJoins V2, {x}, G
                      by GLIB_000:def 33; then
                A100: e in the_Edges_of G & (the_Source_of G).e in VG \ {x} &
                    (the_Target_of G).e in {x} by GLIB_000:def 18; then
                A101: not (the_Source_of G).e in V2 by A99,GLIB_000:def 18;
                    (the_Source_of G).e in VG & not (the_Source_of G).e in {x}
                      by A100, XBOOLE_0:def 4; then
                    not (the_Source_of G).e in V1 by A101,XBOOLE_0:def 2; then
                    (the_Source_of G).e in VG \ V1 by A100, XBOOLE_0:def 4;
then
                    e DSJoins VG \ V1, {x}, G by A100,GLIB_000:def 18;
                    hence e in EV1Xd by GLIB_000:def 33;
                end;
                assume e in EV1Xd; then
                e DSJoins VG \ V1, {x}, G by GLIB_000:def 33; then
            A102: e in the_Edges_of G & (the_Source_of G).e in VG \ V1 &
                  (the_Target_of G).e in {x} by GLIB_000:def 18; then
            A103: (the_Source_of G).e in VG & not (the_Source_of G).e in V1
                  by XBOOLE_0:def 4; then
                not (the_Source_of G).e in V2 by XBOOLE_0:def 2; then
                not e DSJoins V2,{x},G by GLIB_000:def 18; then
            A104: not e in EV2X by GLIB_000:def 33;
                not (the_Source_of G).e in {x} by A103,XBOOLE_0:def 2; then
                (the_Source_of G).e in VG \ {x} by A102,XBOOLE_0:def 4; then
                e DSJoins VG \ {x}, {x}, G by A102,GLIB_000:def 18;  then
                e in EXXf by GLIB_000:def 33;
                hence e in EXXf \ EV2X by A104, XBOOLE_0:def 4;
            end; then
        A105: EXXf \ EV2X = EV1Xd by TARSKI:2;
            reconsider EV1Xdb = EXXf \ EV2X as Subset of the_Edges_of G
              by A98, TARSKI:2;
            now let e be set; assume e in EV2X; then
                e DSJoins V2,{x},G by GLIB_000:def 33; then
            A106: e in the_Edges_of G & (the_Source_of G).e in V2 &
                  (the_Target_of G).e in {x} by GLIB_000:def 18;
                not (the_Source_of G).e in {x} by A106,A42,TARSKI:def 1; then
                (the_Source_of G).e in VG \ {x} by A106,XBOOLE_0:def 4; then
                e DSJoins VG\{x}, {x}, G by A106,GLIB_000:def 18;
                hence e in EXXf by GLIB_000:def 33;
            end; then
        A107: EV2X c= EXXf by TARSKI:def 3;
        A108: dom (EL|EXXf) = EXXf & dom (EL|EV2X) = EV2X &
              dom (EL|EV1Xdb) = EXXf \ EV2X by PBOOLE:def 3; then
        A109: dom (EL|EV2X +* EL|(EXXf \ EV2X)) = EV2X \/ (EXXf \ EV2X)
                                                  by FUNCT_4:def 1
                                             .= EV2X \/ EXXf by XBOOLE_1:39
                                             .= EXXf by A107,XBOOLE_1:12;
            now let e be set; assume
            A110: e in dom (EL|EXXf); then
            A111: e in EXXf by PBOOLE:def 3;
                now per cases;
                  suppose
                A112: e in EV2X; then
                    not e in EV1Xdb by XBOOLE_0:def 4;
                    hence (EL|EV2X +* EL|EV1Xdb).e=(EL|EV2X).e by A108,FUNCT_4:
12
                                                 .=EL.e by A112,FUNCT_1:72;
                  end;
                  suppose not e in EV2X; then
                A113: e in EV1Xdb by A111,XBOOLE_0:def 4;
                    hence (EL|EV2X +* EL|EV1Xdb).e = (EL|EV1Xdb).e
                                                     by A108,FUNCT_4:14
                                                 .= EL.e by A113,FUNCT_1:72;
                  end;
                end;
                hence (EL|EXXf).e = (EL|EV2X +* EL|EV1Xdb).e
                  by A110,A108,FUNCT_1:72;
            end; then
            EL|EXXf = EL|EV2X +* EL|(EXXf \ EV2X) by A108,A109,FUNCT_1:9; then
        A114: Sum (EL|EV2X) + Sum (EL|EV1Xd) = Sum (EL|EXXf)
              by A105,GLIB_004:3;
        A115: now let e be set;
                hereby assume e in EXXe \ EXV2; then
                    e in EXXe & not e in EXV2 by XBOOLE_0:def 4; then
                A116: e DSJoins {x},VG\{x}, G & not e DSJoins {x},V2,G
                      by GLIB_000:def 33; then
                A117: e in the_Edges_of G & (the_Target_of G).e in VG \ {x} &
                    (the_Source_of G).e in {x} by GLIB_000:def 18; then
                A118: not (the_Target_of G).e in V2 by A116,GLIB_000:def 18;
                    (the_Target_of G).e in VG & not (the_Target_of G).e in {x}
                      by A117, XBOOLE_0:def 4; then
                    not (the_Target_of G).e in V1 by A118,XBOOLE_0:def 2; then
                    (the_Target_of G).e in VG \ V1 by A117, XBOOLE_0:def 4;
then
                    e DSJoins {x}, VG \ V1, G by A117,GLIB_000:def 18;
                    hence e in EXV1c by GLIB_000:def 33;
                end;
                assume e in EXV1c; then
                e DSJoins {x}, VG \ V1, G by GLIB_000:def 33; then
            A119: e in the_Edges_of G & (the_Target_of G).e in VG \ V1 &
                (the_Source_of G).e in {x} by GLIB_000:def 18; then
            A120: (the_Target_of G).e in VG & not (the_Target_of G).e in V1
                  by XBOOLE_0:def 4; then
                not (the_Target_of G).e in V2 by XBOOLE_0:def 2; then
                not e DSJoins {x},V2,G by GLIB_000:def 18; then
            A121: not e in EXV2 by GLIB_000:def 33;
                not (the_Target_of G).e in {x} by A120,XBOOLE_0:def 2; then
                (the_Target_of G).e in VG \ {x} by A119,XBOOLE_0:def 4; then
                e DSJoins {x}, VG \ {x}, G by A119,GLIB_000:def 18;  then
                e in EXXe by GLIB_000:def 33;
                hence e in EXXe \ EXV2 by A121, XBOOLE_0:def 4;
            end; then
        A122: EXXe \ EXV2 = EXV1c by TARSKI:2;
            reconsider EXV1cb = EXXe \ EXV2 as Subset of the_Edges_of G
              by TARSKI:2,A115;
            now let e be set; assume e in EXV2; then
                e DSJoins {x},V2,G by GLIB_000:def 33; then
            A123: e in the_Edges_of G & (the_Target_of G).e in V2 &
                  (the_Source_of G).e in {x} by GLIB_000:def 18;
                not (the_Target_of G).e in {x} by A123,A42,TARSKI:def 1; then
                (the_Target_of G).e in VG \ {x} by A123,XBOOLE_0:def 4; then
                e DSJoins {x},VG\{x}, G by A123,GLIB_000:def 18;
                hence e in EXXe by GLIB_000:def 33;
            end; then
        A124: EXV2 c= EXXe by TARSKI:def 3;
        A125: dom (EL|EXXe) = EXXe & dom (EL|EXV2) = EXV2 &
              dom (EL|EXV1cb) = EXXe \ EXV2 by PBOOLE:def 3; then
        A126: dom (EL|EXV2 +* EL|(EXXe \ EXV2)) = EXV2 \/ (EXXe \ EXV2)
                                                  by FUNCT_4:def 1
                                             .= EXV2 \/ EXXe by XBOOLE_1:39
                                             .= EXXe by A124,XBOOLE_1:12;
            now let e be set; assume
            A127: e in dom (EL|EXXe); then
            A128: e in EXXe by PBOOLE:def 3;
                now per cases;
                  suppose
                A129: e in EXV2; then
                    not e in EXV1cb by XBOOLE_0:def 4;
                    hence (EL|EXV2 +* EL|EXV1cb).e=(EL|EXV2).e by A125,FUNCT_4:
12
                                                 .=EL.e by A129,FUNCT_1:72;
                  end;
                  suppose not e in EXV2; then
                A130: e in EXV1cb by A128,XBOOLE_0:def 4;
                    hence (EL|EXV2 +* EL|EXV1cb).e = (EL|EXV1cb).e
                                                     by A125,FUNCT_4:14
                                                  .= EL.e by A130,FUNCT_1:72;
                  end;
                end;
                hence (EL|EXXe).e = (EL|EXV2 +* EL|EXV1cb).e
                  by FUNCT_1:72,A127,A125;
            end; then
            EL|EXXe = EL|EXV2 +* EL|(EXXe \ EXV2) by A125,A126,FUNCT_1:9; then
        A131: Sum (EL|EXV2) + Sum (EL|EXV1c) = Sum (EL|EXXe) by A122, GLIB_004:
3;
            reconsider x as Vertex of G by A41;
            x.edgesIn() = G.edgesDBetween(VG,{x}) &
              x.edgesOut() = G.edgesDBetween({x},VG) by GLIB_000:42; then
        A132: Sum (EL|G.edgesDBetween(VG,{x}))= Sum (EL|G.edgesDBetween({x},VG)
)
              by A40,A42,A1,Def7,A46;
        A133: now let e be set;
                hereby assume e in G.edgesDBetween(VG,{x}) \
                                   G.edgesDBetween({x},{x}); then
                    e in G.edgesDBetween(VG,{x}) &
                    not e in G.edgesDBetween({x},{x}) by XBOOLE_0:def 4; then
                A134: e DSJoins VG,{x},G & not e DSJoins {x},{x},G
                      by GLIB_000:def 33; then
                A135: e in the_Edges_of G & (the_Source_of G).e in VG &
                    (the_Target_of G).e in {x} by GLIB_000:def 18; then
                    not (the_Source_of G).e in {x} by A134,GLIB_000:def 18;
then
                    (the_Source_of G).e in VG\{x} by A135,XBOOLE_0:def 4; then
                    e DSJoins VG\{x},{x},G by A135,GLIB_000:def 18;
                    hence e in EXXf by GLIB_000:def 33;
                end;
                assume e in EXXf; then
                e DSJoins VG \{x}, {x}, G by GLIB_000:def 33; then
            A136: e in the_Edges_of G & (the_Source_of G).e in VG \ {x} &
                (the_Target_of G).e in {x} by GLIB_000:def 18;
                (the_Source_of G).e in VG & not (the_Source_of G).e in {x}
                  by A136, XBOOLE_0:def 4; then
                not e DSJoins {x},{x},G by GLIB_000:def 18; then
            A137: not e in G.edgesDBetween({x},{x}) by GLIB_000:def 33;
                e DSJoins VG,{x},G by A136,GLIB_000:def 18; then
                e in G.edgesDBetween(VG,{x}) by GLIB_000:def 33;
                hence e in G.edgesDBetween(VG,{x}) \ G.edgesDBetween({x},{x})
                  by A137,XBOOLE_0:def 4;
            end; then
        A138: G.edgesDBetween(VG,{x}) \ G.edgesDBetween({x},{x}) = EXXf
              by TARSKI:2;
            reconsider EXXfb = G.edgesDBetween(VG,{x})\G.edgesDBetween({x},{x})
              as Subset of the_Edges_of G by A133,TARSKI:2;
        A139: G.edgesDBetween({x},{x}) c= G.edgesDBetween(VG,{x}) by GLIB_000:
41;
        A140: dom (EL|G.edgesDBetween(VG,{x})) = G.edgesDBetween(VG,{x}) &
              dom (EL|G.edgesDBetween({x},{x})) = G.edgesDBetween({x},{x}) &
              dom (EL|EXXfb) = EXXfb by PBOOLE:def 3; then
        A141: dom (EL|G.edgesDBetween({x},{x}) +* EL|EXXfb)
              = G.edgesDBetween({x},{x}) \/ EXXfb by FUNCT_4:def 1
             .= G.edgesDBetween({x},{x}) \/ G.edgesDBetween(VG,{x})
                by XBOOLE_1:39
             .= G.edgesDBetween(VG,{x}) by A139,XBOOLE_1:12;
            now let e be set; assume e in dom (EL|G.edgesDBetween(VG,{x}));then
            A142: e in G.edgesDBetween(VG,{x}) by PBOOLE:def 3;
                now per cases;
                  suppose
                A143: e in G.edgesDBetween({x},{x}); then
                    not e in EXXfb by XBOOLE_0:def 4;
                    hence (EL|G.edgesDBetween({x},{x}) +* EL|EXXfb).e
                      = (EL|G.edgesDBetween({x},{x})).e by A140,FUNCT_4:12
                     .= EL.e by A143,FUNCT_1:72;
                  end;
                  suppose not e in G.edgesDBetween({x},{x}); then
                A144: e in EXXfb by A142,XBOOLE_0:def 4;
                    hence (EL|G.edgesDBetween({x},{x}) +* EL|EXXfb).e
                      = (EL|EXXfb).e by A140,FUNCT_4:14
                     .= EL.e by A144,FUNCT_1:72;
                  end;
                end;
                hence (EL|G.edgesDBetween(VG,{x})).e =
                  (EL|G.edgesDBetween({x},{x}) +* EL|EXXfb).e by A142,FUNCT_1:
72;
            end; then
            EL|G.edgesDBetween(VG,{x}) =
              EL|G.edgesDBetween({x},{x}) +* EL|EXXfb by A140,A141,FUNCT_1:9;
then
        A145: Sum (EL|G.edgesDBetween(VG,{x})) =
            Sum (EL|EXXf) + Sum (EL|G.edgesDBetween({x},{x})) by A138,GLIB_004:
3;

        A146: now let e be set;
                hereby assume e in G.edgesDBetween({x},VG) \
                                   G.edgesDBetween({x},{x}); then
                    e in G.edgesDBetween({x},VG) &
                    not e in G.edgesDBetween({x},{x}) by XBOOLE_0:def 4; then
                A147: e DSJoins {x},VG,G & not e DSJoins {x},{x},G
                      by GLIB_000:def 33; then
                A148: e in the_Edges_of G & (the_Target_of G).e in VG &
                    (the_Source_of G).e in {x} by GLIB_000:def 18; then
                    not (the_Target_of G).e in {x} by A147,GLIB_000:def 18;
then
                    (the_Target_of G).e in VG\{x} by A148,XBOOLE_0:def 4; then
                    e DSJoins {x},VG\{x},G by A148,GLIB_000:def 18;
                    hence e in EXXe by GLIB_000:def 33;
                end;
                assume e in EXXe; then
                e DSJoins {x}, VG \{x}, G by GLIB_000:def 33; then
            A149: e in the_Edges_of G & (the_Target_of G).e in VG \ {x} &
                (the_Source_of G).e in {x} by GLIB_000:def 18;
                (the_Target_of G).e in VG & not (the_Target_of G).e in {x}
                  by A149, XBOOLE_0:def 4; then
                not e DSJoins {x},{x},G by GLIB_000:def 18; then
            A150: not e in G.edgesDBetween({x},{x}) by GLIB_000:def 33;
                e DSJoins {x},VG,G by A149,GLIB_000:def 18; then
                e in G.edgesDBetween({x},VG) by GLIB_000:def 33;
                hence e in G.edgesDBetween({x},VG) \ G.edgesDBetween({x},{x})
                  by A150,XBOOLE_0:def 4;
            end; then
        A151: G.edgesDBetween({x},VG) \ G.edgesDBetween({x},{x}) = EXXe
              by TARSKI:2;
            reconsider EXXeb = G.edgesDBetween({x},VG)\G.edgesDBetween({x},{x})
              as Subset of the_Edges_of G by A146,TARSKI:2;
        A152: G.edgesDBetween({x},{x}) c= G.edgesDBetween({x},VG) by GLIB_000:
41;
        A153: dom (EL|G.edgesDBetween({x},VG)) = G.edgesDBetween({x},VG) &
              dom (EL|EXXeb) = EXXeb by PBOOLE:def 3; then
        A154: dom (EL|G.edgesDBetween({x},{x}) +* EL|EXXeb)
              = G.edgesDBetween({x},{x}) \/ EXXeb by A140,FUNCT_4:def 1
             .= G.edgesDBetween({x},{x}) \/ G.edgesDBetween({x},VG)
                by XBOOLE_1:39
             .= G.edgesDBetween({x},VG) by A152,XBOOLE_1:12;
            now let e be set; assume e in dom (EL|G.edgesDBetween({x},VG));then
            A155: e in G.edgesDBetween({x},VG) by PBOOLE:def 3;
                now per cases;
                  suppose
                A156: e in G.edgesDBetween({x},{x}); then
                    not e in EXXeb by XBOOLE_0:def 4;
                    hence (EL|G.edgesDBetween({x},{x}) +* EL|EXXeb).e
                      = (EL|G.edgesDBetween({x},{x})).e by A153,FUNCT_4:12
                     .= EL.e by A156,FUNCT_1:72;
                  end;
                  suppose not e in G.edgesDBetween({x},{x}); then
                A157: e in EXXeb by A155,XBOOLE_0:def 4;
                    hence (EL|G.edgesDBetween({x},{x}) +* EL|EXXeb).e
                      = (EL|EXXeb).e by A153,FUNCT_4:14
                     .= EL.e by A157,FUNCT_1:72;
                  end;
                end;
                hence (EL|G.edgesDBetween({x},VG)).e =
                  (EL|G.edgesDBetween({x},{x}) +* EL|EXXeb).e by A155,FUNCT_1:
72;
            end; then
            EL|G.edgesDBetween({x},VG) =
              EL|G.edgesDBetween({x},{x}) +* EL|EXXeb by A153,A154,FUNCT_1:9;
then
            Sum (EL|G.edgesDBetween({x},VG)) =
              Sum (EL|EXXe) + Sum (EL|G.edgesDBetween({x},{x}))
              by A151,GLIB_004:3; then
        A158: Sum (EL|EXXf) = Sum (EL|EXXe) by A132,A145;
            Sum (EL|E1) - Sum(EL|E2)
              = G.flow(source,sink) + Sum (EL|EV2X) + Sum (EL|EV1Xd)
                - Sum (EL|EXV1c) - Sum (EL|EXV2) by A47,A69,A74,A92,A97
             .= G.flow(source,sink) + Sum (EL|G.edgesDBetween(VG \{x},{x}))
                - Sum (EL|EXV1c) - Sum (EL|EXV2) by A114
             .= G.flow(source,sink) + Sum (EL|G.edgesDBetween(VG \{x},{x}))
                - Sum (EL|G.edgesDBetween({x},VG\{x})) by A131
             .= G.flow(source,sink) by A158;
            hence G.flow(source,sink) =
              Sum(EL | G.edgesDBetween(V2, VG \ V2)) -
              Sum(EL | G.edgesDBetween(VG \ V2, V2)) by A57,A86;
        end;
        hence P[n+1];
    end;
A159: for n being non empty Nat holds P[n] from BINARITH:sch 1(A37,A38);
    set n = card (VG \ V);
    now assume n = 0; then
    A160: VG \ V = {} by CARD_2:59;
        sink is Vertex of G by A1,Def7;
        hence contradiction by A1,A160,XBOOLE_0:def 4;
    end;
    hence thesis by A1,A159;
end;

theorem Th12: ::tFLOW02
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
      source,sink being set, V being Subset of the_Vertices_of G
   st G has_valid_flow_from source,sink &
      source in V & not sink in V holds
      G.flow(source,sink) <=
      Sum ((the_Weight_of G) | G.edgesDBetween(V,the_Vertices_of G \ V)) proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set, V be Subset of the_Vertices_of G; assume
A1: G has_valid_flow_from source,sink & source in V & not sink in V;
    set E1 = (the_ELabel_of G) | G.edgesDBetween(V, the_Vertices_of G \ V);
    set E2 = (the_ELabel_of G) | G.edgesDBetween(the_Vertices_of G \ V, V);
    set W1 = (the_Weight_of G) | G.edgesDBetween(V, the_Vertices_of G \ V);
    set B1 = EmptyBag G.edgesDBetween(the_Vertices_of G \ V, V);
A2: G.flow(source,sink) = Sum E1 - Sum E2 by A1,Th11;
    now let e be set; assume
    A3: e in G.edgesDBetween(V, the_Vertices_of G\V); then
        E1.e = (the_ELabel_of G).e & W1.e = (the_Weight_of G).e by FUNCT_1:72;
        hence E1.e <= W1.e by A1, A3, Def7;
    end; then
A4: Sum E1 <= Sum W1 by GLIB_004:5;
A5: Sum B1 = 0 by UPROOTS:13;
    now let e be set; assume
    A6: e in G.edgesDBetween(the_Vertices_of G \ V, V); then
        E2.e = (the_ELabel_of G).e by FUNCT_1:72; then
    A7: 0 <= E2.e by A1,A6,Def7;
        B1 = G.edgesDBetween(the_Vertices_of G \ V, V)-->0
          by POLYNOM1:def 15;
        hence B1.e <= E2.e by A6,A7,FUNCOP_1:13;
    end; then
    0 <= Sum E2 by A5, GLIB_004:5; then
A8: Sum W1 - Sum E2 <= Sum W1 - 0 by REAL_1:92;
    Sum E1 - Sum E2 <= Sum W1 - Sum E2 by A4, XREAL_1:11;
    hence G.flow(source,sink) <= Sum W1 by A2,A8,XXREAL_0:2;
end;

theorem Th13: ::tFLOWAUG03
  for G being real-weighted real-elabeled WEGraph, P being augmenting Path of G
   holds G == FF:AugmentPath(G,P) &
         the_Weight_of G = the_Weight_of FF:AugmentPath(G,P)
          by GLIB_000:12, GLIB_003:8;

theorem Th14: ::tWTOLERANCE01
  for G being finite real-weighted real-elabeled WEGraph,
      W being augmenting Walk of G st W is non trivial holds
      0 < W.tolerance() proof
    let G be finite real-weighted real-elabeled WEGraph,
        W be augmenting Walk of G such that
A1: W is non trivial; set T = W.tolerance();
    T in rng W.flowSeq() & for k being Real st k in rng W.flowSeq() holds
      T <= k by A1,Def19; then consider n being Nat such that
A2: n in dom W.flowSeq() & T = (W.flowSeq()).n by FINSEQ_2:11;
    dom W.flowSeq() = dom W.edgeSeq() by Def18; then
    2*n in dom W by A2,GLIB_001:79; then
A3: 1 <= 2*n & 2*n <= len W by FINSEQ_3:27; then
    reconsider 2n1 = 2*n-1 as odd Nat by INT_1:18;
A4: 2*n-1 < len W - 0 by A3,REAL_1:92;
    set v1 = W.(2n1), e = W.(2*n), v2 = W.(2*n+1);
A5: 2*n-1 + 1 = 2*n & 2*n-1 + 2 = 2*n+1;
    now per cases;
      suppose
    A6: e DJoins v1,v2,G; then
    A7: T = (the_Weight_of G).e - (the_ELabel_of G).e by A2,Def18;
        (the_ELabel_of G).e < (the_Weight_of G).e by A4,A5,A6,Def12; then
        (the_ELabel_of G).e - (the_ELabel_of G).e < T by A7,REAL_1:92;
        hence 0 < T;
      end;
      suppose
    A8: not e DJoins v1,v2,G; then
        T = (the_ELabel_of G).e by A2,Def18;
        hence 0 < T by A4,A5,A8,Def12;
      end;
    end;
    hence 0 < T;
end;

theorem Th15: ::tFLOWAUG02
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
      source,sink being set, P being augmenting Path of G
   st source <> sink & G has_valid_flow_from source,sink &
      P is_Walk_from source,sink
   holds FF:AugmentPath(G,P) has_valid_flow_from source,sink proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set, P be augmenting Path of G; assume
A1: source <> sink & G has_valid_flow_from source,sink &
    P is_Walk_from source,sink;
    set G2 = FF:AugmentPath(G,P);
A2: G2 == G & the_Weight_of G = the_Weight_of G2 by Th13;
    set EL1 = the_ELabel_of G, EL2 = the_ELabel_of G2;
A3: EL2 = G2.ELabelSelector
       .= FF:PushFlow(G,P) by GLIB_000:11;
    now source is Vertex of G & sink is Vertex of G by A1,Def7;
        hence source is Vertex of G2 & sink is Vertex of G2
          by A2, GLIB_000:def 36;
        now let e be set; assume e in the_Edges_of G2; then
        A4: e in the_Edges_of G by A2,GLIB_000:def 36; then
        A5: 0 <= EL1.e & EL1.e <= (the_Weight_of G).e by A1,Def7;
            now per cases;
              suppose not e in P.edges();
                 hence 0 <= (the_ELabel_of G2).e &
                    (the_ELabel_of G2).e <= (the_Weight_of G2).e
                    by A2,A3,A5,A4,Def20;
              end;
              suppose e in P.edges(); then consider n being odd Nat such that
            A6: n < len P & P.(n+1) = e by GLIB_001:101;
            A7: e Joins P.n,P.(n+2),G by A6,GLIB_001:def 3;
                P.first() = source & P.last() = sink by A1,GLIB_001:def 23;then
            A8: P is non trivial by A1,GLIB_001:128; then
            A9: 0 < P.tolerance() by Th14;
            A10: now assume e DJoins P.n,P.(n+2),G & e DJoins P.(n+2),P.n,G;
then
                A11: (the_Source_of G).e = P.n & (the_Source_of G).e = P.(n+2)
                      by GLIB_000:def 16;
                A12: n + 0 < n+2 by XREAL_1:10;
                    n+2 <= len P by A6, GLIB_001:1; then
                    n = 1 & n+2 = len P by A11,A12,GLIB_001:def 28; then
                    P.n = source & P.(n+2) = sink by A1,GLIB_001:18;
                    hence contradiction by A11,A1;
                end;
                set PFS = P.flowSeq(), n1div2 = (n+1) div 2;
                1 <= n+1 & n+1 <= len P by A6,NAT_1:29,NAT_1:38; then
                n1div2 in dom P.edgeSeq() & P.(n+1) = P.edgeSeq().n1div2
                  by GLIB_001:78;  then
            A13: n1div2 in dom PFS by Def18;
                2 divides n+1 by PEPIN:22; then
            A14: 2 * n1div2 = n+1 by NAT_1:49; then
            A15: 2 * n1div2 - 1 = n;
            A16: 2 * n1div2 + 1 = n + 2 by A14;
                now per cases by A7,GLIB_000:19;
                  suppose
                A17: e DJoins P.n,P.(n+2),G; then
                A18: EL1.e + P.tolerance() = EL2.e by A3,A6,Def20;
                    0 + 0 <= EL1.e + P.tolerance() by A5,A9,XREAL_1:9;
                    hence 0 <= EL2.e by A17,A3,A6,Def20;
                    PFS.n1div2 = (the_Weight_of G).e - EL1.e
                      by A6,A13,A15,A16,A17,Def18; then
                    (the_Weight_of G2).e - EL1.e in rng PFS
                      by A2,A13,FUNCT_1:def 5; then
                    P.tolerance() <= (the_Weight_of G2).e - EL1.e
                      by A8,Def19; then
                    EL2.e <= (the_Weight_of G2).e - EL1.e + EL1.e
                      by A18,XREAL_1:9;
                    hence EL2.e <= (the_Weight_of G2).e;
                  end;
                  suppose
                A19: e DJoins P.(n+2),P.n,G; then
                A20: EL2.e = EL1.e - P.tolerance() by A10,A3,A6,Def20;
                    PFS.n1div2=EL1.e by A6,A13,A15,A16,A19,A10,Def18; then
                    EL1.e in rng PFS by A13,FUNCT_1:def 5; then
                    P.tolerance() <= EL1.e by A8,Def19; then
                    P.tolerance() - P.tolerance() <= EL2.e by A20,REAL_1:92;
                    hence 0 <= EL2.e;
                    EL2.e <= EL1.e - 0 by A9,A20,REAL_1:92;
                    hence EL2.e <= (the_Weight_of G2).e by A2,A5,XXREAL_0:2;
                  end;
                end;
                hence 0 <= EL2.e & EL2.e <= (the_Weight_of G2).e;
              end;
            end;
            hence 0 <= EL2.e & EL2.e <= (the_Weight_of G2).e;
        end;
        hence for e being set st e in the_Edges_of G2 holds
           0 <= EL2.e & EL2.e <= (the_Weight_of G2).e;
        let v be Vertex of G2; assume
    A21: v <> source & v <> sink;
        reconsider v'=v as Vertex of G by A2,GLIB_000:def 36;
    A22: v.edgesIn() = v'.edgesIn() & v.edgesOut() = v'.edgesOut()
          by A2,GLIB_000:99;
    A23: Sum (EL1 | v'.edgesIn()) = Sum (EL1 | v'.edgesOut())
          by A1,A21,Def7;
        now per cases;
          suppose v in P.vertices(); then consider n being odd Nat such that
        A24: n <= len P & P.n = v by GLIB_001:88;
        A25: now assume n = len P; then
                v = P.last() by A24,GLIB_001:def 7
                 .= sink by A1,GLIB_001:def 23;
                hence contradiction by A21;
            end; then
        A26: n < len P by A24,REAL_1:def 5;
        A27: 1 <= n by HEYTING3:1;
        A28: now assume n = 1; then
                v = P.first() by A24,GLIB_001:def 6
                 .= source by A1,GLIB_001:def 23;
                hence contradiction by A21;
            end; then
            1 < n by A27,REAL_1:def 5; then
            1+1 <= n by NAT_1:38; then
            reconsider n2 = n-2*1 as odd Nat by INT_1:18;
            set e1 = P.(n2+1), e2 = P.(n+1), T = P.tolerance();
        A29: n2 < len P - 0 by A24,REAL_1:92; then
        A30: e1 Joins P.n2,P.(n2+2),G by GLIB_001:def 3;
        A31: e2 Joins v,P.(n+2),G by A24,A26,GLIB_001:def 3;
        A32: P.(n2+2) = v by A24;
        A33: now assume
            A34: P.n2 = v;
                n2 < n - 0 by REAL_1:92;
                hence contradiction
                  by A25,A24,A34,GLIB_001:def 28;
            end;
        A35: now assume
            A36: v = P.(n+2);
            A37: n+0 < n+2 by XREAL_1:10;
                n+2 <= len P by A26,GLIB_001:1;
                hence contradiction
                  by A28,A24,A36,A37,GLIB_001:def 28;
            end;
        A38: now assume
            A39: e1 DJoins P.n2,v,G & e1 DJoins v,P.n2,G; then
                P.n2 = (the_Source_of G).e1 by GLIB_000:def 16
                     .= v by A39,GLIB_000:def 16;
                hence contradiction by A33;
            end;
        A40: now assume
            A41: e2 DJoins v,P.(n+2),G & e2 DJoins P.(n+2),v,G; then
            A42: P.n = (the_Source_of G).e2 by A24,GLIB_000:def 16
                   .= P.(n+2) by A41,GLIB_000:def 16;
            A43: n + 0 < n+2 by XREAL_1:10;
                n+2 <= len P by A26,GLIB_001:1;
                hence contradiction
                  by A28,A42,A43,GLIB_001:def 28;
            end;
            n2 < n - 0 by REAL_1:92; then
            1 <= n2+1 & n2+1 < n+1 & n+1 <= len P
              by NAT_1:29,XREAL_1:10,A26,NAT_1:38; then
        A44: e1 <> e2 by GLIB_001:139;
        A45: now let e be set; assume
            A46: (e in v'.edgesIn() or e in v'.edgesOut()) & e <> e1 & e <> e2;
                now assume e in P.edges(); then consider v1,v2 being
                    Vertex of G, m being odd Nat such that
                A47: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                      e Joins v1,v2,G by GLIB_001:104;
                A48: m+2-2 < len P - 0 by A47,REAL_1:92;
                A49: now per cases by A46;
                      suppose e in v'.edgesIn(); then
                        (the_Target_of G).e = v by GLIB_000:59;
                        hence v1 = v or v2 = v by A47,GLIB_000:def 15;
                      end;
                      suppose e in v'.edgesOut(); then
                        (the_Source_of G).e = v by GLIB_000:61;
                        hence v1 = v or v2 = v by A47,GLIB_000:def 15;
                      end;
                    end;
                    now per cases by A49;
                      suppose
                    A50: v1 = v;
                        now per cases by REAL_1:def 5;
                          suppose m < n;
                            hence contradiction
                              by A25,A24,A47,A50,GLIB_001:def 28;
                          end;
                          suppose m = n;
                            hence contradiction by A47,A46;
                          end;
                          suppose n < m;
                            hence contradiction by A48,A50,A24,A47,GLIB_001:def
28;
                          end;
                        end;
                        hence contradiction;
                      end;
                      suppose
                    A51: v2 = v;
                        now per cases by REAL_1:def 5;
                          suppose m+2 < n;
                            hence contradiction
                              by A24,A25,A47,A51,GLIB_001:def 28;
                          end;
                          suppose m+2 = n;
                            hence contradiction by A46,A47;
                          end;
                          suppose n < m+2;
                            hence contradiction by A24,A28,
                              A47,A51,GLIB_001:def 28;
                          end;
                        end;
                        hence contradiction;
                      end;
                    end;
                    hence contradiction;
                end;
                hence not e in P.edges();
            end;
            now per cases by A24,A30,A31,GLIB_000:19;
              suppose
            A52: e1 DJoins P.n2,v,G & e2 DJoins v,P.(n+2),G;
                set XIN = (EL1|v'.edgesIn()) +* (e1.-->(EL1.e1 + T));
                set XOUT= (EL1|v'.edgesOut())+* (e2.-->(EL1.e2 + T));
            A53: e1 in v'.edgesIn() & e2 in v'.edgesOut()
                  by A52,GLIB_000:60,GLIB_000:62;
            A54: dom (e1.-->(EL1.e1+T)) = {e1} by CQC_LANG:5; then
            A55: dom XIN = dom (EL1|v'.edgesIn()) \/ {e1} by FUNCT_4:def 1
                       .= v'.edgesIn() \/ {e1} by PBOOLE:def 3
                       .= v'.edgesIn() by A53,ZFMISC_1:46; then
                reconsider XIN as Rbag of v'.edgesIn() by PBOOLE:def 3;
            A56: dom (e2.-->(EL1.e2+T)) = {e2} by CQC_LANG:5; then
            A57: dom XOUT = dom (EL1|v'.edgesOut())\/{e2} by FUNCT_4:def 1
                        .= v'.edgesOut() \/ {e2} by PBOOLE:def 3
                        .= v'.edgesOut() by A53,ZFMISC_1:46; then
                reconsider XOUT as Rbag of v'.edgesOut() by PBOOLE:def 3;
            A58: dom (EL2|v.edgesIn()) = v.edgesIn() by PBOOLE:def 3;
                now let e be set; assume e in dom (EL2|v.edgesIn()); then
                A59: e in v.edgesIn() by PBOOLE:def 3; then
                A60: (the_Target_of G).e = v by A22,GLIB_000:59;
                    now per cases;
                      suppose
                    A61: e = e1; then
                        e in dom (e1.-->(EL1.e1+T)) by A54,TARSKI:def 1;
                        hence XIN.e = (e1.-->(EL1.e1+T)).e1 by A61,FUNCT_4:14
                                   .= EL1.e1 + T by CQC_LANG:6
                                   .= EL2.e by A3,A29,A32,A52,A61,Def20;
                      end;
                      suppose
                    A62: e <> e1; then
                        not e in dom (e1.-->(EL1.e1+T)) by A54,TARSKI:def 1;
then
                    A63: XIN.e = (EL1|v'.edgesIn()).e by FUNCT_4:12
                             .= EL1.e by A22,A59,FUNCT_1:72;
                        now assume e in P.edges(); then consider v1,v2 being
                            Vertex of G,m being odd Nat such that
                        A64: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2=P.(m+2)
                              & e Joins v1,v2,G by GLIB_001:104;
                        A65: m+2-2 < len P - 0 by A64,REAL_1:92;
                            now per cases by A60,A64,GLIB_000:def 15;
                              suppose
                            A66: v = v1;
                                now per cases by REAL_1:def 5;
                                  suppose m < n;
                                    hence contradiction by A25,A24,
                                      A66,A64,GLIB_001:def 28;
                                  end;
                                  suppose m = n; then
                                A67: P.(n+2) = P.n
                                      by A64,A24,A52,A60,GLIB_000:def 16;
                                A68: n+2-2 < n+2-0 by REAL_1:92;
                                    n+2 <= len P by A26,GLIB_001:1;
                                    hence contradiction by A28,
                                      A67,A68,GLIB_001:def 28;
                                  end;
                                  suppose n < m;
                                    hence contradiction
                                      by A66,A65,A24,A64,GLIB_001:def 28;
                                  end;
                                end;
                                hence contradiction;
                              end;
                              suppose
                            A69: v = v2;
                                now per cases by REAL_1:def 5;
                                  suppose m+2 < n;
                                    hence contradiction by A25,
                                      A24,A64,A69,GLIB_001:def 28;
                                  end;
                                  suppose m+2 = n;
                                    hence contradiction by A62,A64;
                                  end;
                                  suppose n < m+2;
                                    hence contradiction by A28,
                                      A69,A24,A64,GLIB_001:def 28;
                                  end;
                                end;
                                hence contradiction;
                              end;
                            end;
                            hence contradiction;
                        end;
                        hence EL2.e = XIN.e by A63,A3,A22,A59,Def20;
                      end;
                    end;
                    hence (EL2|v.edgesIn()).e = XIN.e by A59,FUNCT_1:72;
                end; then
            A70: Sum (EL2|v.edgesIn())=Sum XIN by A22,A55,A58,FUNCT_1:9;
            A71: dom (EL2|v.edgesOut()) = v.edgesOut() by PBOOLE:def 3;
            A72: now let e be set; assume e in dom (EL2|v.edgesOut()); then
                A73: e in v.edgesOut() by PBOOLE:def 3; then
                A74: (the_Source_of G).e = v by A22,GLIB_000:61;
                    now per cases;
                      suppose
                    A75: e = e2; then
                        e in dom (e2.-->(EL1.e2+T)) by A56,TARSKI:def 1;
                        hence XOUT.e = (e2.-->(EL1.e2+T)).e2 by A75,FUNCT_4:14
                                    .= EL1.e2 + T by CQC_LANG:6
                                    .= EL2.e by A3,A24,A26,A52,A75,Def20;
                      end;
                      suppose
                    A76: e <> e2; then
                        not e in dom (e2.-->(EL1.e2+T)) by A56,TARSKI:def 1;
then
                    A77: XOUT.e = (EL1|v'.edgesOut()).e by FUNCT_4:12
                              .= EL1.e by A22,A73,FUNCT_1:72;
                        now assume e in P.edges(); then consider v1,v2 being
                            Vertex of G,m being odd Nat such that
                        A78: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2=P.(m+2)
                              & e Joins v1,v2,G by GLIB_001:104;
                        A79: m+2-2 < len P - 0 by A78,REAL_1:92;
                            now per cases by A74,A78,GLIB_000:def 15;
                              suppose
                            A80: v = v1;
                                now per cases by REAL_1:def 5;
                                  suppose m < n;
                                    hence contradiction by A25,A24,
                                      A80,A78,GLIB_001:def 28;
                                  end;
                                  suppose m = n;
                                    hence contradiction by A76,A78;
                                  end;
                                  suppose n < m;
                                    hence contradiction
                                      by A79,A80,A24,A78,GLIB_001:def 28;
                                  end;
                                end;
                                hence contradiction;
                              end;
                              suppose
                            A81: v = v2;
                                now per cases by REAL_1:def 5;
                                  suppose m+2 < n;
                                    hence contradiction by A25,A24,
                                      A81,A78,GLIB_001:def 28;
                                  end;
                                  suppose m+2 = n; then
                                A82: P.n2 = P.n by A78,A24,A52,A74,GLIB_000:def
16;
                                    n2 < n - 0 by REAL_1:92;
                                    hence contradiction
                                      by A25,A24,A82,GLIB_001:def 28;
                                  end;
                                  suppose n < m+2;
                                    hence contradiction by A28,
                                      A81,A78,A24,GLIB_001:def 28;
                                  end;
                                end;
                                hence contradiction;
                              end;
                            end;
                            hence contradiction;
                        end;
                        hence EL2.e = XOUT.e by A77,A3,A22,A73,Def20;
                      end;
                    end;
                    hence (EL2|v.edgesOut()).e = XOUT.e by A73,FUNCT_1:72;
                end;
                Sum XIN = Sum (EL1|v'.edgesIn()) + (T + EL1.e1)
                            - (EL1|v'.edgesIn()).e1 by GLIB_004:9
                       .= Sum (EL1|v'.edgesOut()) + T + EL1.e1 - EL1.e1
                            by A23,A53,FUNCT_1:72
                       .= Sum (EL1|v'.edgesOut()) + T + EL1.e2 - EL1.e2
                       .= Sum (EL1|v'.edgesOut()) + (T + EL1.e2)
                            - (EL1|v'.edgesOut()).e2 by A53,FUNCT_1:72
                       .= Sum XOUT by GLIB_004:9;
                hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut())
                  by A70,A72,A22,A57,A71,FUNCT_1:9;
              end;
              suppose
            A83: e1 DJoins P.n2,v,G & e2 DJoins P.(n+2),v,G; then
            A84: EL2.e1 = EL1.e1 + T & EL2.e2 = EL1.e2 - T
                  by A3,A26,A29,A32,A40,Def20;
            A85: e1 in v'.edgesIn() & e2 in v'.edgesIn() by A83,GLIB_000:60;
                set XIN1 = (EL1|v'.edgesIn())+*(e1.-->(EL1.e1+T));
                set XIN2 = XIN1 +* (e2.-->(EL1.e2-T));
            A86: dom XIN1 = dom (EL1|v'.edgesIn()) \/ dom (e1.-->(EL1.e1+T))
                             by FUNCT_4:def 1
                        .= dom (EL1|v'.edgesIn()) \/ {e1} by CQC_LANG:5
                        .= v'.edgesIn() \/ {e1} by PBOOLE:def 3
                        .= v'.edgesIn() by A85,ZFMISC_1:46; then
                reconsider XIN1 as Rbag of v'.edgesIn() by PBOOLE:def 3;
            A87: dom XIN2 = dom XIN1 \/ dom (e2.-->(EL1.e2-T)) by FUNCT_4:def 1
                        .= v'.edgesIn() \/ {e2} by A86,CQC_LANG:5
                        .= v'.edgesIn() by A85,ZFMISC_1:46; then
                reconsider XIN2 as Rbag of v'.edgesIn() by PBOOLE:def 3;
            A88: dom (EL2|v.edgesIn()) = v.edgesIn() by PBOOLE:def 3;
            A89: dom (e1.-->(EL1.e1+T)) = {e1} & dom (e2.-->(EL1.e2-T)) = {e2}
                  by CQC_LANG:5;
            A90: now let e be set; assume
                A91: e in dom (EL2|v.edgesIn()); then
                A92: e in v.edgesIn() by PBOOLE:def 3;
                A93: (EL2|v.edgesIn()).e = EL2.e by FUNCT_1:72,A91,A88;
                    now per cases;
                      suppose
                    A94: e = e1; then
                    A95: not e in dom (e2.-->(EL1.e2-T)) &
                        e in dom (e1.-->(EL1.e1+T)) by A44,A89,TARSKI:def 1;
then
                        XIN2.e = XIN1.e by FUNCT_4:12
                              .= (e1.-->(EL1.e1+T)).e by A95,FUNCT_4:14
                              .= EL2.e by A84,A94,CQC_LANG:6;
                        hence (EL2|v.edgesIn()).e = XIN2.e by FUNCT_1:72,A91,
A88;
                      end;
                      suppose
                    A96: e = e2; then
                        e in dom (e2.-->(EL1.e2-T)) by A89,TARSKI:def 1; then
                        XIN2.e = (e2.-->(EL1.e2-T)).e2 by A96,FUNCT_4:14
                              .= EL2.e by A84,A96,CQC_LANG:6;
                        hence (EL2|v.edgesIn()).e = XIN2.e by FUNCT_1:72,A91,
A88;
                      end;
                      suppose
                    A97: e <> e1 & e <> e2; then
                    A98: not e in dom (e2.-->(EL1.e2-T)) &
                        not e in dom (e1.-->(EL1.e1+T)) by A89,TARSKI:def 1;
then
                    A99: XIN2.e = XIN1.e by FUNCT_4:12
                              .= (EL1|v'.edgesIn()).e by A98,FUNCT_4:12
                              .= EL1.e by A92,A22,FUNCT_1:72;
                        not e in P.edges() by A22,A45,A92,A97;
                        hence (EL2|v.edgesIn()).e = XIN2.e
                          by A92,A93,A99,A3,A22,Def20;
                      end;
                    end;
                    hence (EL2|v.edgesIn()).e = XIN2.e;
                end;
                not e2 in dom (e1.-->(EL1.e1+T)) by A44,A89,TARSKI:def 1; then
            A100: XIN1.e2 = (EL1|v'.edgesIn()).e2 by FUNCT_4:12
                       .= EL1.e2 by A85,FUNCT_1:72;
            A101: dom (EL2|v.edgesOut()) = v.edgesOut() &
                dom (EL1|v'.edgesOut()) = v.edgesOut() by A22,PBOOLE:def 3;
                now let e be set; assume
                A102: e in dom (EL2|v.edgesOut()); then
                A103: e in v.edgesOut() by PBOOLE:def 3;
                A104: (EL2|v.edgesOut()).e = EL2.e &
                    (EL1|v'.edgesOut()).e = EL1.e by A22,FUNCT_1:72,A102,A101;
                A105: e in the_Edges_of G &
                      (the_Source_of G).e = v by A22,A103,GLIB_000:61; then
                A106: e <> e1 by A83,GLIB_000:def 16,A33;
                    e <> e2 by A105,A83,GLIB_000:def 16,A35; then
                    not e in P.edges() by A22,A103,A45,A106;
                    hence (EL2|v.edgesOut()).e = (EL1|v'.edgesOut()).e
                      by A104,A3,Def20,A22,A103;
                end; then
            A107: EL2|v.edgesOut() = EL1|v'.edgesOut() by A101,FUNCT_1:9;
                Sum (EL2|v.edgesIn())
                   = Sum XIN2 by A90,A22,A87,A88,FUNCT_1:9
                  .= Sum XIN1 + (EL1.e2-T) - EL1.e2 by A100,GLIB_004:9
                  .= Sum XIN1 - (EL1.e2 - (EL1.e2 - T))
                  .= Sum (EL1|v'.edgesIn())+(EL1.e1+T)-(EL1|v'.edgesIn()).e1-T
                       by GLIB_004:9
                  .= Sum (EL1|v'.edgesIn())+T+EL1.e1-EL1.e1-T
                       by A85,FUNCT_1:72
                  .= Sum (EL1|v'.edgesIn());
                hence Sum (EL2|v.edgesIn()) = Sum (EL2|v.edgesOut())
                  by A1,A21,Def7,A107,A22;
              end;
              suppose
            A108: e1 DJoins v,P.n2,G & e2 DJoins v,P.(n+2),G; then
            A109: EL2.e1 = EL1.e1 - T & EL2.e2 = EL1.e2 + T
                  by A3,A26,A29,A32,A38,Def20;
            A110: e1 in v'.edgesOut() & e2 in v'.edgesOut() by A108,GLIB_000:62
;
                set XOUT1 = (EL1|v'.edgesOut())+*(e1.-->(EL1.e1-T));
                set XOUT2 = XOUT1 +* (e2.-->(EL1.e2+T));
            A111: dom XOUT1 = dom (EL1|v'.edgesOut()) \/ dom (e1.-->(EL1.e1-T))
                              by FUNCT_4:def 1
                         .= dom (EL1|v'.edgesOut()) \/ {e1} by CQC_LANG:5
                         .= v'.edgesOut() \/ {e1} by PBOOLE:def 3
                         .= v'.edgesOut() by A110,ZFMISC_1:46; then
                reconsider XOUT1 as Rbag of v'.edgesOut() by PBOOLE:def 3;
            A112: dom XOUT2 = dom XOUT1\/dom (e2.-->(EL1.e2+T)) by FUNCT_4:def
1
                         .= v'.edgesOut() \/ {e2} by A111,CQC_LANG:5
                         .= v'.edgesOut() by A110,ZFMISC_1:46; then
                reconsider XOUT2 as Rbag of v'.edgesOut() by PBOOLE:def 3;
            A113: dom (EL2|v.edgesOut()) = v.edgesOut() by PBOOLE:def 3;
            A114: dom (e1.-->(EL1.e1-T)) = {e1} & dom (e2.-->(EL1.e2+T)) = {e2}
                  by CQC_LANG:5;
            A115: now let e be set; assume
                A116: e in dom (EL2|v.edgesOut()); then
                A117: e in v.edgesOut() by PBOOLE:def 3;
                A118: (EL2|v.edgesOut()).e = EL2.e by FUNCT_1:72,A116,A113;
                    now per cases;
                      suppose
                    A119: e = e1; then
                    A120: not e in dom (e2.-->(EL1.e2+T)) &
                        e in dom (e1.-->(EL1.e1-T)) by A44,A114,TARSKI:def 1;
then
                        XOUT2.e = XOUT1.e by FUNCT_4:12
                               .= (e1.-->(EL1.e1-T)).e by A120,FUNCT_4:14
                               .= EL2.e by A109,A119,CQC_LANG:6;
                        hence (EL2|v.edgesOut()).e=XOUT2.e by FUNCT_1:72,A116,
A113;
                      end;
                      suppose
                    A121: e = e2; then
                        e in dom (e2.-->(EL1.e2+T)) by A114,TARSKI:def 1; then
                        XOUT2.e = (e2.-->(EL1.e2+T)).e by FUNCT_4:14
                               .= EL2.e by A109,A121,CQC_LANG:6;
                        hence (EL2|v.edgesOut()).e=XOUT2.e by FUNCT_1:72,A116,
A113;
                      end;
                      suppose
                    A122: e <> e1 & e <> e2; then
                    A123: not e in dom (e2.-->(EL1.e2+T)) &
                        not e in dom (e1.-->(EL1.e1-T)) by A114,TARSKI:def 1;
then
                    A124: XOUT2.e = XOUT1.e by FUNCT_4:12
                               .= (EL1|v'.edgesOut()).e by A123,FUNCT_4:12
                               .= EL1.e by A117,A22,FUNCT_1:72;
                        not e in P.edges() by A117,A22,A45,A122;
                        hence (EL2|v.edgesOut()).e = XOUT2.e
                          by A118,A124,A3,A117,A22,Def20;
                      end;
                    end;
                    hence (EL2|v.edgesOut()).e = XOUT2.e;
                end;
                not e2 in dom (e1.-->(EL1.e1-T)) by A44,A114,TARSKI:def 1; then
            A125: XOUT1.e2 = (EL1|v'.edgesOut()).e2 by FUNCT_4:12
                        .= EL1.e2 by A110,FUNCT_1:72;
            A126: Sum (EL2|v.edgesOut())
                   = Sum XOUT2 by A115,A22,A112,A113,FUNCT_1:9
                  .= Sum XOUT1 + (EL1.e2+T) - EL1.e2 by A125,GLIB_004:9
                  .= Sum XOUT1 - EL1.e2 + EL1.e2 + T
                  .= Sum (EL1|v'.edgesOut()) + (EL1.e1 - T)
                       - (EL1|v'.edgesOut()).e1 + T by GLIB_004:9
                  .= Sum (EL1|v'.edgesOut()) + EL1.e1 - T - EL1.e1 + T
                       by A110,FUNCT_1:72
                  .= Sum (EL1|v'.edgesOut());
            A127: dom (EL2|v.edgesIn()) = v.edgesIn() &
                dom (EL1|v'.edgesIn()) = v.edgesIn() by A22,PBOOLE:def 3;
                now let e be set; assume
                A128: e in dom (EL2|v.edgesIn()); then
                A129: e in v.edgesIn() by PBOOLE:def 3;
                A130: (EL2|v.edgesIn()).e = EL2.e &
                    (EL1|v'.edgesIn()).e = EL1.e by A22,FUNCT_1:72,A127,A128;
                A131: e in the_Edges_of G &
                      (the_Target_of G).e = v by A129,A22,
                        GLIB_000:59; then
                A132: e <> e1 by A108,GLIB_000:def 16,A33;
                    e <> e2 by A131,A108,GLIB_000:def 16,A35; then
                    not e in P.edges() by A129,A22,A45,A132;
                    hence (EL2|v.edgesIn()).e = (EL1|v'.edgesIn()).e
                      by A130,A3,A129,A22,Def20;
                end; then
                EL2|v.edgesIn() = EL1|v'.edgesIn() by A127,FUNCT_1:9;
                hence Sum (EL2|v.edgesIn()) = Sum (EL2|v.edgesOut())
                  by A126,A23,GLIB_004:7;
            end;
            suppose
            A133: e1 DJoins v,P.n2,G & e2 DJoins P.(n+2),v,G; then
            A134: EL2.e1 = EL1.e1 - T & EL2.e2 = EL1.e2 - T
                  by A3,A26,A29,A32,A38,A40,Def20;
            A135: e1 in v'.edgesOut() & e2 in v'.edgesIn()
                  by A133,GLIB_000:60,GLIB_000:62;
                set XIN = (EL1|v'.edgesIn())+*(e2.-->(EL1.e2-T));
                set XOUT= (EL1|v'.edgesOut())+*(e1.-->(EL1.e1-T));
            A136: dom (e1.-->(EL1.e1-T)) = {e1} &
                dom (e2.-->(EL1.e2-T)) = {e2} by CQC_LANG:5; then
            A137: dom XIN = dom (EL1|v'.edgesIn()) \/ {e2} by FUNCT_4:def 1
                       .= v'.edgesIn() \/ {e2} by PBOOLE:def 3
                       .= v'.edgesIn() by A135,ZFMISC_1:46; then
                reconsider XIN as Rbag of v'.edgesIn() by PBOOLE:def 3;
            A138: dom XOUT = dom (EL1|v'.edgesOut())\/{e1} by A136,FUNCT_4:def
1
                        .= v'.edgesOut() \/ {e1} by PBOOLE:def 3
                        .= v'.edgesOut() by A135,ZFMISC_1:46; then
                reconsider XOUT as Rbag of v'.edgesOut() by PBOOLE:def 3;
            A139: dom (EL2|v.edgesIn()) = v.edgesIn() &
                dom (EL2|v.edgesOut()) = v.edgesOut() by PBOOLE:def 3;
                now let e be set; assume e in dom (EL2|v.edgesIn()); then
                A140: e in v.edgesIn() by PBOOLE:def 3; then
                A141: (the_Target_of G).e = v by A22,GLIB_000:59;
                    now per cases;
                      suppose
                    A142: e = e2; then
                        e in dom (e2.-->(EL1.e2-T)) by A136,TARSKI:def 1;
                        hence XIN.e = (e2.-->(EL1.e2-T)).e2 by A142,FUNCT_4:14
                                   .= EL2.e by A134,A142,CQC_LANG:6;
                      end;
                      suppose
                    A143: e <> e2; then
                        not e in dom (e2.-->(EL1.e2-T)) by A136,TARSKI:def 1;
then
                    A144: XIN.e = (EL1|v'.edgesIn()).e by FUNCT_4:12
                             .= EL1.e by A22,A140,FUNCT_1:72;
                        e <> e1 by A33,A133,A141,GLIB_000:def 16; then
                        not e in P.edges() by A22,A140,A45,A143;
                        hence EL2.e = XIN.e by A144,A3,A22,A140,Def20;
                      end;
                    end;
                    hence XIN.e = (EL2|v.edgesIn()).e by A140,FUNCT_1:72;
                end; then
            A145: Sum (EL2|v.edgesIn())
                  = Sum XIN by A22,A137,A139,FUNCT_1:9
                 .= Sum (EL1|v'.edgesIn()) + (EL1.e2-T) - (EL1|v'.edgesIn()).e2
                      by GLIB_004:9
                 .= Sum (EL1|v'.edgesIn()) + EL1.e2 - T - EL1.e2
                      by A135,FUNCT_1:72
                 .= Sum (EL1|v'.edgesIn()) - T;
                now let e be set; assume e in dom (EL2|v.edgesOut()); then
                A146: e in v.edgesOut() by PBOOLE:def 3; then
                A147: (the_Source_of G).e = v by A22,GLIB_000:61;
                    now per cases;
                      suppose
                    A148: e = e1; then
                        e in dom (e1.-->(EL1.e1-T)) by A136,TARSKI:def 1;
                        hence XOUT.e = (e1.-->(EL1.e1-T)).e1 by A148,FUNCT_4:14
                                    .= EL2.e by A134,A148,CQC_LANG:6;
                      end;
                      suppose
                    A149: e <> e1; then
                        not e in dom (e1.-->(EL1.e1-T)) by A136,TARSKI:def 1;
then
                    A150: XOUT.e = (EL1|v'.edgesOut()).e by FUNCT_4:12
                              .= EL1.e by A22,A146,FUNCT_1:72;
                        e <> e2 by A35,A133,A147,GLIB_000:def 16; then
                        not e in P.edges() by A22,A146,A45,A149;
                        hence EL2.e = XOUT.e by A150,A3,A22,A146,Def20;
                      end;
                    end;
                    hence XOUT.e = (EL2|v.edgesOut()).e by A146,FUNCT_1:72;
                end; then
                Sum (EL2|v.edgesOut())
                  = Sum XOUT by A22,A138,A139,FUNCT_1:9
                 .= Sum (EL1|v'.edgesOut()) + (EL1.e1-T)-(EL1|v'.edgesOut()).e1
                      by GLIB_004:9
                 .= Sum (EL1|v'.edgesOut()) + EL1.e1 - T - EL1.e1
                      by A135,FUNCT_1:72
                 .= Sum (EL1|v'.edgesIn()) - T by A23;
                hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut()) by
A145;
              end;
            end;
            hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut());
          end;
          suppose
        A151: not v in P.vertices();
        A152: dom (EL1|v'.edgesIn()) = v.edgesIn()
              by A22,PBOOLE:def 3; then
        A153: dom (EL1|v'.edgesIn()) = dom (EL2|v.edgesIn())
              by PBOOLE:def 3;
            now let e be set; assume
            A154: e in dom (EL1|v'.edgesIn()); then
            A155: (EL1|v'.edgesIn()).e = EL1.e &
                  (EL2|v.edgesIn()).e = EL2.e by A22,FUNCT_1:72,A152;
                now assume
                A156: e in P.edges();
                    consider x being set such that
                A157: e DJoins x,v,G2 by A154,A152,GLIB_000:60;
                    e Joins x,v,G2 by A157,GLIB_000:19; then
                    e Joins x,v,G by A2,GLIB_000:91;
                    hence contradiction by A151,A156,GLIB_001:106;
                end;
                hence (EL1|v'.edgesIn()).e = (EL2|v.edgesIn()).e
                  by A155,A3,A22,A154,A152,Def20;
            end; then
        A158: EL1 | v'.edgesIn() = EL2 | v.edgesIn() by A153,FUNCT_1:9;
        A159: dom (EL1|v'.edgesOut()) = v.edgesOut() &
              dom (EL2|v.edgesOut()) = v.edgesOut() by A22,PBOOLE:def 3;
            now let e be set; assume
            A160: e in dom (EL1|v'.edgesOut()); then
            A161: e in v.edgesOut() by A22,PBOOLE:def 3;
            A162: (EL1|v'.edgesOut()).e = EL1.e &
                  (EL2|v.edgesOut()).e = EL2.e by A160,A159,A22,FUNCT_1:72;
                now assume
                A163: e in P.edges();
                    consider x being set such that
                A164: e DJoins v,x,G by A161,A22,GLIB_000:62;
                    e Joins v,x,G by A164,GLIB_000:19;
                    hence contradiction by A151,A163,GLIB_001:106;
                end;
                hence (EL1|v'.edgesOut()).e = (EL2|v.edgesOut()).e
                  by A161,A162,A3,A22,Def20;
            end; then
        A165: EL1 | v'.edgesOut() = EL2 | v.edgesOut() by A159,FUNCT_1:9;
            thus Sum (EL2|v.edgesIn())
                = Sum (EL1|v'.edgesIn()) by A158,GLIB_004:7
               .= Sum (EL2|v.edgesOut()) by A23,A165,GLIB_004:7;
          end;
        end;
        hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut());
    end;
    hence G2 has_valid_flow_from source,sink by Def7;
end;

theorem Th16: ::tFLOWAUG01
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
      source,sink being set, P being augmenting Path of G
   st source <> sink & G has_valid_flow_from source,sink &
      P is_Walk_from source,sink holds
     G.flow(source,sink) + P.tolerance() =
       (FF:AugmentPath(G,P)).flow(source,sink) proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set, P be augmenting Path of G such that
A1: source <> sink & G has_valid_flow_from source,sink &
      P is_Walk_from source,sink;
    set G2 = FF:AugmentPath(G,P), T = P.tolerance();
    set EL1 = the_ELabel_of G, EL2 = the_ELabel_of G2;
A2: EL2 = G2.ELabelSelector
       .= FF:PushFlow(G,P) by GLIB_000:11;
A3: G2 has_valid_flow_from source,sink by A1,Th15;
    set EI1 = EL1|G.edgesInto({sink}), EO1 = EL1|G.edgesOutOf({sink});
    P.first() = source & P.last() = sink by A1,GLIB_001:def 23; then
    P is non trivial by A1,GLIB_001:128; then
    3 <= len P by GLIB_001:126; then
    2 <= len P by XXREAL_0:2; then
    reconsider lenP2g = len P - 2*1 as odd Nat by INT_1:18;
    set e1 = P.(lenP2g+1);
A4: lenP2g < len P - 0 by REAL_1:92; then
A5: e1 Joins P.lenP2g, P.(lenP2g+2), G by GLIB_001:def 3; then
A6: e1 in the_Edges_of G by GLIB_000:def 15;
    G2 == G by Th13; then
A7: G2.edgesInto({sink}) = G.edgesInto({sink}) &
    G2.edgesOutOf({sink}) = G.edgesOutOf({sink}) by GLIB_000:93;
A8: P.(len P) = sink by A1,GLIB_001:18;
    now per cases;
      suppose
    A9: e1 DJoins P.lenP2g, P.(lenP2g+2), G; then
    A10: EL2.e1 = EL1.e1 + T by A2,A4,Def20;
       (the_Target_of G).e1 = P.(lenP2g+2) by A9,GLIB_000:def 16
                            .= sink by A1,GLIB_001:18; then
        (the_Target_of G).e1 in {sink} by TARSKI:def 1; then
    A11: e1 in G.edgesInto({sink}) by A6,GLIB_000:def 28;
        set EI2 = EI1+*(e1.-->(EI1.e1 + T));
    A12: dom EI2 = dom EI1 \/ dom (e1.-->(EI1.e1 + T)) by FUNCT_4:def 1
               .= dom EI1 \/ {e1} by CQC_LANG:5
               .= G.edgesInto({sink}) \/ {e1} by PBOOLE:def 3
               .= G.edgesInto({sink}) by A11,ZFMISC_1:46; then
        reconsider EI2 as Rbag of G.edgesInto({sink}) by PBOOLE:def 3;
    A13: dom (EL2|G2.edgesInto({sink})) = G2.edgesInto({sink})
          by PBOOLE:def 3;
        now let e be set; assume
        A14: e in dom (EL2|G2.edgesInto({sink})); then
        A15: e in G2.edgesInto({sink}) by PBOOLE:def 3;
        A16: (EL2|G2.edgesInto({sink})).e = EL2.e by A14,A13,FUNCT_1:72;
            (the_Target_of G).e in {sink} by A15,A7,
              GLIB_000:def 28; then
        A17: (the_Target_of G).e = sink by TARSKI:def 1;
            now per cases;
              suppose
            A18: e = e1; then
                e in {e1} by TARSKI:def 1; then
                e in dom (e1.-->(EI1.e1+T)) by CQC_LANG:5; then
                EI2.e = (e1.-->(EI1.e1+T)).e1 by A18,FUNCT_4:14
                     .= EI1.e1 + T by CQC_LANG:6
                     .= EL2.e1 by A15,A10,A7,A18,FUNCT_1:72;
                hence (EL2|G2.edgesInto({sink})).e = EI2.e
                  by A14,A13,FUNCT_1:72,A18;
              end;
              suppose
            A19: e <> e1; then
                not e in {e1} by TARSKI:def 1; then
                not e in dom (e1.-->(EI1.e1+T)) by CQC_LANG:5; then
            A20: EI2.e = EI1.e by FUNCT_4:12
                     .= EL1.e by A15,A7,FUNCT_1:72;
                now assume e in P.edges(); then
                    consider v1,v2 being Vertex of G,m being odd Nat such that
                A21: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                      e Joins v1,v2,G by GLIB_001:104;
                    now per cases by A21,A17,GLIB_000:def 15;
                      suppose
                    A22: v1 = sink; then
                    A23: P.m = P.(len P) by A1,GLIB_001:18,A21;
                        m+2-2 < len P - 0 by A21,REAL_1:92; then
                        m = 1 by A23,GLIB_001:def 28;
                        hence contradiction by A1,A22,GLIB_001:18,A21;
                      end;
                      suppose v2 = sink; then
                     A24: P.(m+2) = P.(len P) by A1,GLIB_001:18,A21;
                         now assume m+2 < len P; then
                             m+2 = 1 by A24,GLIB_001:def 28; then
                             m = 1-2;
                             hence contradiction by HEYTING3:1;
                         end; then
                         m + 2 = len P by A21, XXREAL_0:1;
                         hence contradiction by A19,A21;
                      end;
                    end;
                    hence contradiction;
                end;
                hence (EL2|G2.edgesInto({sink})).e = EI2.e
                  by A15,A16,A20,A2,A7,Def20;
              end;
            end;
            hence (EL2|G2.edgesInto({sink})).e = EI2.e;
        end; then
    A25: Sum (EL2|G2.edgesInto({sink}))
           = Sum EI2 by A7,A12,A13,FUNCT_1:9
          .= Sum EI1 + (T + EI1.e1) - EI1.e1 by GLIB_004:9
          .= Sum EI1 + T;
    A26: dom (EL2|G2.edgesOutOf({sink})) = G2.edgesOutOf({sink}) &
        dom EO1 = G2.edgesOutOf({sink}) by A7,PBOOLE:def 3;
        now let e be set; assume
        A27: e in dom (EL2|G2.edgesOutOf({sink})); then
        A28: e in G2.edgesOutOf({sink}) by PBOOLE:def 3; then
            (the_Source_of G).e in {sink} by A7,GLIB_000:def 29; then
        A29: (the_Source_of G).e = sink by TARSKI:def 1;
            now assume e in P.edges(); then
                consider v1,v2 being Vertex of G, m being odd Nat such that
            A30: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                  e Joins v1,v2,G by GLIB_001:104;
                now per cases by A29,A30,GLIB_000:def 15;
                  suppose
                A31: v1 = sink; then
                A32: P.m = P.(len P) by A1,GLIB_001:18,A30;
                    m+2-2 < len P - 0 by A30,REAL_1:92; then
                    m = 1 by A32,GLIB_001:def 28;
                    hence contradiction by A1,A30,A31,GLIB_001:18;
                  end;
                  suppose v2 = sink; then
                A33: P.(m+2) = P.(len P) by A1,GLIB_001:18,A30;
                    now assume m+2 < len P; then
                        m+2 = 1 by A33,GLIB_001:def 28; then
                        1 <= 1-2 by HEYTING3:1;
                        hence contradiction;
                    end; then
                    m + 2 = len P by A30, XXREAL_0:1; then
                    m = lenP2g; then
                A34: P.lenP2g = sink by A30,A9,A29,GLIB_000:def 16; then
                    lenP2g = 1 by A8,A4,GLIB_001:def 28;
                    hence contradiction by A1,A34,GLIB_001:18;
                  end;
                end;
                hence contradiction;
            end; then
            EL2.e = EL1.e by A2,A28,A7,Def20
                 .= EO1.e by A7,A28,FUNCT_1:72;
            hence (EL2|G2.edgesOutOf({sink})).e = EO1.e by FUNCT_1:72,A27,A26;
        end; then
        EL2|G2.edgesOutOf({sink}) = EO1 by A26,FUNCT_1:9; then
        Sum (EL2|G2.edgesOutOf({sink})) = Sum EO1 by GLIB_004:7;
        hence G2.flow(source,sink) = Sum EI1 + T - Sum EO1 by A25,A3,Def8
                                  .= Sum EI1 - Sum EO1 + T
                                  .= G.flow(source,sink) + T by A1,Def8;
      end;
      suppose
    A35: not e1 DJoins P.lenP2g, P.(lenP2g+2), G; then
    A36: EL2.e1 = EL1.e1 - T by A2,A4,Def20;
    A37: e1 DJoins P.(lenP2g+2),P.lenP2g,G by A5,A35,GLIB_000:19; then
        (the_Source_of G).e1 = P.(lenP2g+2) by GLIB_000:def 16
                            .= sink by A1,GLIB_001:18; then
        (the_Source_of G).e1 in {sink} by TARSKI:def 1; then
    A38: e1 in G.edgesOutOf({sink}) by A6,GLIB_000:def 29;
        set EO2 = EO1+*(e1.-->(EO1.e1-T));
    A39: dom EO2 = dom EO1 \/ dom (e1.-->(EO1.e1 - T)) by FUNCT_4:def 1
               .= dom EO1 \/ {e1} by CQC_LANG:5
               .= G.edgesOutOf({sink}) \/ {e1} by PBOOLE:def 3
               .= G.edgesOutOf({sink}) by A38,ZFMISC_1:46; then
        reconsider EO2 as Rbag of G.edgesOutOf({sink}) by PBOOLE:def 3;
    A40: dom (EL2|G2.edgesOutOf({sink})) = G2.edgesOutOf({sink})
          by PBOOLE:def 3;
        now let e be set; assume
        A41: e in dom (EL2|G2.edgesOutOf({sink})); then
        A42: e in G2.edgesOutOf({sink}) by PBOOLE:def 3;
        A43: (EL2|G2.edgesOutOf({sink})).e = EL2.e by A41,A40,FUNCT_1:72;
            (the_Source_of G).e in {sink} by A7,A42,GLIB_000:def 29; then
        A44: (the_Source_of G).e = sink by TARSKI:def 1;
            now per cases;
              suppose
            A45: e = e1; then
                e in {e1} by TARSKI:def 1; then
                e in dom (e1.-->(EO1.e1-T)) by CQC_LANG:5; then
                EO2.e = (e1.-->(EO1.e1-T)).e1 by A45,FUNCT_4:14
                     .= EO1.e1 - T by CQC_LANG:6
                     .= EL2.e by A36,A7,A42,A45,FUNCT_1:72;
                hence (EL2|G2.edgesOutOf({sink})).e = EO2.e
                  by A41,A40,FUNCT_1:72;
              end;
              suppose
            A46: e <> e1; then
                not e in {e1} by TARSKI:def 1; then
                not e in dom (e1.-->(EO1.e1-T)) by CQC_LANG:5; then
            A47: EO2.e = EO1.e by FUNCT_4:12
                     .= EL1.e by A7,A42,FUNCT_1:72;
                now assume e in P.edges(); then
                    consider v1,v2 being Vertex of G, m being odd Nat such that
                A48: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                     e Joins v1,v2,G by GLIB_001:104;
                    now per cases by A44,A48,GLIB_000:def 15;
                      suppose
                    A49: v1 = sink; then
                    A50: P.m = P.(len P) by A1,GLIB_001:18,A48;
                        m+2-2 < len P - 0 by A48,REAL_1:92; then
                        m = 1 by A50,GLIB_001:def 28;
                        hence contradiction by A1,A49,A48,GLIB_001:18;
                      end;
                      suppose v2 = sink; then
                    A51: P.(m+2) = P.(len P) by A1,GLIB_001:18,A48;
                        now assume m+2 < len P; then
                            m+2 = 1 by A51,GLIB_001:def 28; then
                            1 <= 1-2 by HEYTING3:1;
                            hence contradiction;
                        end; then
                        m + 2 = len P by A48, XXREAL_0:1;
                        hence contradiction by A46,A48;
                      end;
                    end;
                    hence contradiction;
                end;
                hence (EL2|G2.edgesOutOf({sink})).e = EO2.e
                  by A43,A47,A2,A7,A42,Def20;
              end;
            end;
            hence (EL2|G2.edgesOutOf({sink})).e = EO2.e;
        end; then
    A52: Sum (EL2|G2.edgesOutOf({sink}))
           = Sum EO2 by A7,A39,A40,FUNCT_1:9
          .= Sum EO1 + (EO1.e1 - T) - EO1.e1 by GLIB_004:9
          .= Sum EO1 - T;
    A53: dom (EL2|G2.edgesInto({sink})) = G2.edgesInto({sink}) &
          dom EI1 = G2.edgesInto({sink}) by A7,PBOOLE:def 3;
        now let e be set; assume
        A54: e in dom (EL2|G2.edgesInto({sink})); then
        A55: e in G2.edgesInto({sink}) by PBOOLE:def 3; then
            (the_Target_of G).e in {sink} by A7,GLIB_000:def 28; then
        A56: (the_Target_of G).e = sink by TARSKI:def 1;
            now assume e in P.edges(); then
                consider v1,v2 being Vertex of G, m being odd Nat such that
           A57: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                  e Joins v1,v2,G by GLIB_001:104;
                now per cases by A56,A57,GLIB_000:def 15;
                  suppose
                A58: v1 = sink; then
                A59: P.m = P.(len P) by A1,GLIB_001:18,A57;
                    m+2-2 < len P - 0 by A57,REAL_1:92; then
                    m = 1 by A59,GLIB_001:def 28;
                    hence contradiction by A1,A58,A57,GLIB_001:18;
                  end;
                  suppose v2 = sink; then
                A60: P.(m+2) = P.(len P) by A1,GLIB_001:18,A57;
                    now assume m+2 < len P; then
                        m+2 = 1 by A60,GLIB_001:def 28; then
                        1 <= 1-2 by HEYTING3:1;
                        hence contradiction;
                    end; then
                    m + 2 = len P by A57, XXREAL_0:1; then
                    m = lenP2g; then
                A61: P.lenP2g = sink by A57,A37,A56,GLIB_000:def 16; then
                    lenP2g = 1 by A8,A4,GLIB_001:def 28;
                    hence contradiction by A1,A61,GLIB_001:18;
                  end;
                end;
                hence contradiction;
            end; then
            EL2.e = EL1.e by A2,A7,A55,Def20
                 .= EI1.e by A7,A55,FUNCT_1:72;
            hence (EL2|G2.edgesInto({sink})).e = EI1.e by A54,A53,FUNCT_1:72;
        end; then
        EL2|G2.edgesInto({sink}) = EI1 by A53,FUNCT_1:9; then
        Sum (EL2|G2.edgesInto({sink})) = Sum EI1 by GLIB_004:7;
        hence G2.flow(source,sink) = Sum EI1 - (Sum EO1 - T) by A52,A3,Def8
                                  .= Sum EI1 - Sum EO1 + T
                                  .= G.flow(source,sink) + T by A1,Def8;
      end;
    end;
    hence thesis;
end;

theorem Th17: ::tFLOWCS02
  for G being finite real-weighted WGraph, source,sink being Vertex of G,
      n being Nat
  holds FF:CompSeq(G,source,sink).->n == G &
  the_Weight_of G = the_Weight_of (FF:CompSeq(G,source,sink).->n)  proof
    let G be finite real-weighted WGraph, source,sink be Vertex of G;
    set CS = FF:CompSeq(G,source,sink);
    defpred P[Nat] means
      CS.->$1 == G & the_Weight_of G = the_Weight_of (CS.->$1);
    CS.->0 = G.set(ELabelSelector, the_Edges_of G --> 0)
      by Def23; then
A1: P[0] by GLIB_003:8,GLIB_000:12;
A2: now let n be Nat; set Gn = CS.->n, Gn1 = CS.->(n+1); assume
    A3: P[n];
        consider source',sink' being Vertex of Gn such that
    A4: source' = source & sink' = sink & Gn1 = FF:Step(Gn,source',sink')
          by Def23;
        now per cases;
          suppose
        A5: sink' in AP:FindAugPath(Gn,source').labeledV();
            set P = AP:GetAugPath(Gn,source',sink');
            Gn1 = FF:AugmentPath(Gn, P) by A4,A5,Def22; then
            Gn1 == Gn & the_Weight_of Gn1 = the_Weight_of Gn by Th13;
            hence P[n+1] by A3,GLIB_000:88;
          end;
          suppose not sink' in AP:FindAugPath(Gn,source').labeledV();
            hence P[n+1] by A3,A4, Def22;
          end;
        end;
        hence P[n+1];
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis;
end;

theorem Th18: ::tFLOWCS01
  for G being finite nonnegative-weighted WGraph,
              source,sink being Vertex of G, n being Nat
   st source <> sink
    holds FF:CompSeq(G,source,sink).->n has_valid_flow_from source,sink  proof
    let G be finite nonnegative-weighted WGraph, source,sink be Vertex of G,
        n be Nat; assume
A1: source <> sink;
    set CS = FF:CompSeq(G,source,sink);
    defpred P[Nat] means (CS.->$1) has_valid_flow_from source,sink;
    now set G0 = CS.->0;
    A2: G0 = G.set(ELabelSelector, the_Edges_of G --> 0) by Def23; then
    A3: G0 == G by GLIB_003:8;
        hence source is Vertex of G0 & sink is Vertex of G0 by GLIB_000:def 36;
    A4: the_ELabel_of G0 = G0.ELabelSelector
                        .= the_Edges_of G --> 0 by A2, GLIB_000:11;
        now let e be set; assume e in the_Edges_of G0; then
        A5: e in the_Edges_of G by A3, GLIB_000:def 36;
            hence 0 <= (the_ELabel_of G0).e by A4,FUNCOP_1:13;
        A6: rng the_Weight_of G0 c= Real>=0 by GLIB_003:def 14;
            dom the_Weight_of G0 = the_Edges_of G0 by PBOOLE:def 3
                                .= the_Edges_of G by A3,GLIB_000:def 36; then
            (the_Weight_of G0).e in rng (the_Weight_of G0)
              by A5,FUNCT_1:def 5; then
            (the_Weight_of G0).e in Real>=0 by A6; then
            consider r being Real such that
        A7: r = (the_Weight_of G0).e & r >= 0 by GRAPH_5:def 12;
            thus (the_ELabel_of G0).e <= (the_Weight_of G0).e
              by A5,A4,FUNCOP_1:13,A7;
        end;
        hence (for e being set st e in the_Edges_of G0 holds
          0 <= (the_ELabel_of G0).e &
          (the_ELabel_of G0).e <= (the_Weight_of G0).e);
        let v be Vertex of G0; assume v <> source & v <> sink;
        set B1 = EmptyBag v.edgesIn(), B2 = EmptyBag v.edgesOut();
        set E1 = ((the_ELabel_of G0)|v.edgesIn());
        set E2 = ((the_ELabel_of G0)|v.edgesOut());
        now let e be set; assume
        A8: e in v.edgesIn(); then
            e in the_Edges_of G0; then
        A9: e in the_Edges_of G by A3,GLIB_000:def 36;
            E1.e = (the_ELabel_of G0).e by A8,FUNCT_1:72
                .= 0 by A4,A9,FUNCOP_1:13;
            hence B1.e = E1.e by POLYNOM1:56;
        end; then
    A10: Sum E1 = Sum B1 by GLIB_004:6
              .= 0 by UPROOTS:13;
        now let e be set; assume
        A11: e in v.edgesOut(); then
            e in the_Edges_of G0; then
        A12: e in the_Edges_of G by A3,GLIB_000:def 36;
            E2.e = (the_ELabel_of G0).e by A11,FUNCT_1:72
                .= 0 by A4,A12,FUNCOP_1:13;
            hence B2.e = E2.e by POLYNOM1:56;
        end; then
        Sum E2 = Sum B2 by GLIB_004:6
              .= 0 by UPROOTS:13;
        hence Sum E1 = Sum E2 by A10;
    end; then
A13: P[0] by Def7;
    now let n be Nat; set Gn = CS.->n, Gn1 = CS.->(n+1); assume
    A14: Gn has_valid_flow_from source,sink;
        consider source',sink' being Vertex of Gn such that
    A15: source'=source & sink'=sink & Gn1 = FF:Step(Gn,source',sink')
          by Def23;
        now per cases;
          suppose
        A16: sink in AP:FindAugPath(Gn,source').labeledV();
            set P = AP:GetAugPath(Gn,source',sink');
        A17: Gn1 = FF:AugmentPath(Gn, P) by A15,A16,Def22;
            P is_Walk_from source',sink'
              by A15,A16,Def17;
            hence P[n+1] by A17,A1,A14,A15,Th15;
          end;
          suppose not sink in AP:FindAugPath(Gn,source').labeledV();
            hence P[n+1] by A14,A15,Def22;
          end;
        end;
        hence P[n+1];
    end; then
A18: for n being Nat st P[n] holds P[n+1];
    for n being Nat holds P[n] from NAT_1:sch 1(A13,A18);
    hence thesis;
end;

theorem Th19: ::tMAXFLOW01
  for G being finite natural-weighted WGraph,source,sink being Vertex of G st
      source <> sink holds FF:CompSeq(G,source,sink) is halting  proof
    let G be finite natural-weighted WGraph, source, sink be Vertex of G;
    assume
A1: source <> sink;
    set CS = FF:CompSeq(G,source,sink);
    now assume
    A2: for n being Nat holds CS.->n <> CS.->(n+1);
        defpred P[Nat] means $1 <= (CS.->$1).flow(source,sink) &
                             (CS.->$1).flow(source,sink) is Nat;
        now set G0 = CS.->0;
            set E1 = (the_ELabel_of G0) | G0.edgesInto({sink});
            set E2 = (the_ELabel_of G0) | G0.edgesOutOf({sink});
        A3: G0 has_valid_flow_from source,sink by A1,Th18; then
        A4: G0.flow(source,sink) = Sum E1 - Sum E2 by Def8;
        A5: G0 = G.set(ELabelSelector, the_Edges_of G --> 0) by Def23; then
            G0 == G by GLIB_003:8; then
        A6: the_Edges_of G0 = the_Edges_of G by GLIB_000:def 36;
        A7: the_ELabel_of G0 = G0.ELabelSelector
                            .= the_Edges_of G --> 0 by A5,GLIB_000:11;
            set B1 = EmptyBag G0.edgesInto({sink});
            set B2 = EmptyBag G0.edgesOutOf({sink});
            now let e be set; assume
            A8: e in G0.edgesInto({sink}); then
                E1.e = (the_ELabel_of G0).e by FUNCT_1:72;
                hence E1.e = 0 by A6,A8,A7,FUNCOP_1:13
                          .= B1.e by POLYNOM1:56;
            end; then
        A9: Sum E1 = Sum B1 by GLIB_004:6
                  .= 0 by UPROOTS:13;
            now let e be set; assume
            A10: e in G0.edgesOutOf({sink}); then
                E2.e = (the_ELabel_of G0).e by FUNCT_1:72;
                hence E2.e = 0 by A7,A10,A6,FUNCOP_1:13
                          .= B2.e by POLYNOM1:56;
            end; then
        A11: Sum E2 = Sum B2 by GLIB_004:6
                  .= 0 by UPROOTS:13;
            hence G0.flow(source,sink) = 0 - 0 by A3,Def8,A9;
            thus G0.flow(source,sink) is Nat by A4,A9,A11;
        end; then
    A12: P[0];
        now let n be Nat; set Gn = CS.->n, Gn1 = CS.->(n+1); assume
        A13: n <= Gn.flow(source,sink) & Gn.flow(source,sink) is Nat;
        A14: Gn has_valid_flow_from source,sink &
              Gn1 has_valid_flow_from source,sink by A1,Th18;
            consider source',sink' being Vertex of Gn such that
        A15: source' = source & sink' = sink &
              Gn1 = FF:Step(Gn, source',sink') by Def23;
        A16: now assume not sink in AP:FindAugPath(Gn,source').labeledV(); then
                Gn1 = Gn by A15, Def22;
                hence contradiction by A2;
            end; then
        A17: Gn1 = FF:AugmentPath(Gn,AP:GetAugPath(Gn,source',sink'))
              by A15,Def22;
            set P = AP:GetAugPath(Gn,source',sink');
        A18: P is_Walk_from source',sink' by A15,A16,Def17; then
            P.first() = source' & P.last() = sink' by GLIB_001:def 23; then
            P is non trivial by A1,A15,GLIB_001:128; then
        A19: 0 < P.tolerance() by Th14;
            reconsider GnF = Gn.flow(source,sink) as Nat by A13;
        A20: GnF + P.tolerance() = Gn1.flow(source,sink)
              by A1,A14,A15,A17,A18,Th16; then
            reconsider Gn1F = Gn1.flow(source,sink) as Nat;
            GnF + P.tolerance()-P.tolerance() < Gn1F-0 by A19,A20,REAL_1:92;
then
            n < Gn1F by A13,XXREAL_0:2;
            hence n+1 <= Gn1.flow(source,sink) by NAT_1:38;
            thus Gn1.flow(source,sink) is Nat by A20;
        end; then
    A21: for n being Nat st P[n] holds P[n+1];
    A22: for n being Nat holds P[n] from NAT_1:sch 1(A12,A21);
        set V = {source};
    A23: source in V & not sink in V by A1,TARSKI:def 1;
        set W1 = (the_Weight_of G)|G.edgesDBetween(V,the_Vertices_of G \ V);
        degree W1 = Sum W1; then
        reconsider N = Sum W1 as Nat;
        set Gn1 = CS.->(N+1);
        reconsider Gn1F = Gn1.flow(source,sink) as Nat by A22;
        Sum W1 + 1 <= Gn1F by A22; then
    A24: Sum W1 < Gn1.flow(source,sink) by NAT_1:38;
    A25: Gn1 == G & the_Weight_of G = the_Weight_of Gn1 by Th17; then
        reconsider V'=V as Subset of the_Vertices_of Gn1 by GLIB_000:def 36;
        set W2 = (the_Weight_of Gn1) |
                  Gn1.edgesDBetween(V',the_Vertices_of Gn1 \ V');
        W1 = (the_Weight_of Gn1) |
               G.edgesDBetween(V', the_Vertices_of Gn1 \ V')
               by A25,GLIB_000:def 36
          .= W2 by A25, GLIB_000:93; then
    A26: Sum W1 = Sum W2 by GLIB_004:7;
        Gn1 has_valid_flow_from source,sink by A1,Th18;
        hence contradiction by A24,A26,A23,Th12;
    end;
    hence FF:CompSeq(G,source,sink) is halting by GLIB_000:def 68;
end;

theorem Th20: ::tMAXFLOW02
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
      source,sink being set
   st source <> sink & G has_valid_flow_from source,sink &
   not ex P being augmenting Path of G st P is_Walk_from source,sink
   holds G has_maximum_flow_from source,sink  proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set; assume
A1: source <> sink & G has_valid_flow_from source,sink &
    not ex P being augmenting Path of G st P is_Walk_from source,sink;
    reconsider src = source as Vertex of G by A1,Def7;
    set CS = AP:CompSeq(G,src), Gn = AP:FindAugPath(G,src), V = Gn.labeledV();
    set Gn1 = CS.->(CS.Lifespan()+1);
A2: Gn == G & the_Weight_of Gn = the_Weight_of G &
      the_ELabel_of Gn = the_ELabel_of G by Th10; then
A3: the_Vertices_of Gn = the_Vertices_of G &
    the_Edges_of Gn = the_Edges_of G &
    the_Source_of Gn = the_Source_of G &
    the_Target_of Gn = the_Target_of G by GLIB_000:def 36;
    reconsider V as Subset of the_Vertices_of G by A2,GLIB_000:def 36;
A4: source in V by Th10;
A5: sink in Gn.labeledV() iff
     ex P being Path of G st P is augmenting & P is_Walk_from src,sink
      by Th9;
    set E1 = G.edgesDBetween(V, the_Vertices_of G \ V);
    set E2 = G.edgesDBetween(the_Vertices_of G \ V, V);
A6: G.flow(source,sink) = Sum((the_ELabel_of G) | E1) -
                          Sum((the_ELabel_of G) | E2) by A1,A4,A5,Th11;
    set A1 = (the_ELabel_of G)|E1, B1 = (the_Weight_of G)|E1;
A7: AP:CompSeq(G,src) is halting by Th6;
 Gn = CS.Result()
      .= CS.(CS.Lifespan())
      .= CS.->(CS.Lifespan()); then
A8: Gn1 = AP:Step(Gn) by Def15;
A9: Gn1 = CS.(CS.Lifespan()+1)
       .= CS.(CS.Lifespan()) by A7, GLIB_000:def 57
       .= Gn;
    set e = choose AP:NextBestEdges(Gn);
A10: now assume
    A11: AP:NextBestEdges(Gn) <> {}; then
    A12: e in AP:NextBestEdges(Gn);
        now per cases by A11,Def13;
          suppose e is_forward_labeling_in Gn; then
        A13: (the_Source_of Gn).e in V &
              not (the_Target_of Gn).e in V by Def10; then
        A14: Gn = Gn.labelVertex((the_Target_of Gn).e,e)
              by A8,A9,A11,Def14;
            (the_Target_of Gn).e in the_Vertices_of Gn
              by A12,FUNCT_2:7;
            hence contradiction by A13,A14,GLIB_003:64;
          end;
          suppose e is_backward_labeling_in Gn; then
        A15: (the_Target_of Gn).e in V &
              not (the_Source_of Gn).e in V by Def11; then
        A16: Gn = Gn.labelVertex((the_Source_of Gn).e,e)
              by A8,A9,A11,Def14;
            (the_Source_of Gn).e in the_Vertices_of Gn
              by A12,FUNCT_2:7;
            hence contradiction by A15,A16,GLIB_003:64;
          end;
        end;
        hence contradiction;
    end;
A17: now let x be set; assume
    A18: x in E1; then
    A19: A1.x = (the_ELabel_of Gn).x & B1.x = (the_Weight_of Gn).x
          by A2,FUNCT_1:72;
        x DSJoins V, the_Vertices_of G \ V, G by A18,GLIB_000:def 33; then
    A20: x in the_Edges_of Gn &
        (the_Source_of Gn).x in V &
        (the_Target_of Gn).x in the_Vertices_of Gn \ V
        by A3, GLIB_000:def 18; then
    A21: not (the_Target_of Gn).x in V by XBOOLE_0:def 4;
    A22: A1.x <= B1.x by A1,A19,A20,A2,A3,Def7;
        set e = choose AP:NextBestEdges(Gn);
        now assume A1.x < B1.x; then
            x is_forward_labeling_in Gn by A19,A20,A21,Def10;
            hence contradiction by A10,Def13;
        end;
        hence A1.x = B1.x by A22,XXREAL_0:1;
    end;
    set A2 = (the_ELabel_of G)|E2, B2 = EmptyBag E2;
    now let x be set; assume
    A23: x in E2; then
    A24: A2.x = (the_ELabel_of Gn).x by A2,FUNCT_1:72;
        B2 = E2 --> 0 by POLYNOM1:def 15; then
    A25: B2.x = 0 by A23, FUNCOP_1:13;
        x DSJoins the_Vertices_of G \ V, V, G by A23, GLIB_000:def 33; then
    A26: x in the_Edges_of Gn &
        (the_Source_of Gn).x in the_Vertices_of Gn \ V &
        (the_Target_of Gn).x in V by A3,GLIB_000:def 18; then
    A27: not (the_Source_of Gn).x in V by XBOOLE_0:def 4;
        set e = choose AP:NextBestEdges(Gn);
        now assume 0 < A2.x; then
            x is_backward_labeling_in Gn by A24,A26,A27,Def11;
            hence contradiction by A10,Def13;
        end;
        hence A2.x = B2.x by A25,A1,A24,A26,A2,A3,Def7;
    end; then
    Sum ((the_ELabel_of G) | E2) = Sum B2 by GLIB_004:6; then
A28: Sum ((the_ELabel_of G) | E2) = 0 by UPROOTS:13;
A29: G.flow(source,sink) = Sum ((the_Weight_of G)|E1) by A6,A17,A28,GLIB_004:6;
    now let X be finite real-weighted real-elabeled complete-elabeled WEGraph;
        assume
    A30: X == G & the_Weight_of X = the_Weight_of G &
          X has_valid_flow_from source,sink; then
    A31: the_Vertices_of G = the_Vertices_of X by GLIB_000:def 36;
        reconsider V'=V as Subset of the_Vertices_of X by A30,GLIB_000:def 36;
        set E1' = X.edgesDBetween(V', the_Vertices_of X \ V');
        E1' = E1 by A31,A30, GLIB_000:93;
        hence X.flow(source,sink) <= G.flow(source,sink)
          by A30,A4,A1,A5,Th12,A29;
    end;
    hence G has_maximum_flow_from source,sink by A1,Def9;
 end;

theorem ::tMAXFLOW03
  for G being finite real-weighted WGraph, source, sink being Vertex of G holds
     G == FF:MaxFlow(G,source,sink) &
     the_Weight_of G = the_Weight_of FF:MaxFlow(G,source,sink)  proof
    let G be finite real-weighted WGraph, source,sink be Vertex of G;
    set CS = FF:CompSeq(G,source,sink);
    FF:MaxFlow(G,source,sink) = CS.Result()
                             .= CS.(CS.Lifespan())
                             .= CS.->(CS.Lifespan());
    hence thesis by Th17;
end;

theorem ::tMAXFLOW04
  for G being finite natural-weighted WGraph, source,sink being Vertex of G
   st sink <> source holds
   FF:MaxFlow(G,source,sink) has_maximum_flow_from source,sink  proof
    let G be finite natural-weighted WGraph, source, sink be Vertex of G;
    set CS = FF:CompSeq(G,source,sink); assume
A1: sink <> source;
    set n = CS.Lifespan(), Gn = CS.->n, Gn1 = CS.->(n+1);
    consider source',sink' being Vertex of Gn such that
A2: source'=source & sink'=sink & Gn1 = FF:Step(Gn,source',sink') by Def23;
    CS is halting by A1,Th19; then
    CS.n = CS.(n+1) by GLIB_000:def 57; then
A3: Gn = CS.(n+1);
A4: Gn has_valid_flow_from source,sink by A1,Th18;
    now given P being augmenting Path of Gn such that
    A5: P is_Walk_from source,sink;
    A6: sink in AP:FindAugPath(Gn,source').labeledV() by A2,A5,Th9; then
    A7: Gn1 = FF:AugmentPath(Gn, AP:GetAugPath(Gn,source',sink'))
          by A2,Def22;
        set P = AP:GetAugPath(Gn,source',sink');
    A8: P is_Walk_from source',sink'
          by A2,A6,Def17; then
        P.first() = source' & P.last() = sink' by GLIB_001:def 23; then
        P is non trivial by A1,A2,GLIB_001:128; then
    A9: 0 < P.tolerance() by Th14;
        Gn.flow(source',sink') + P.tolerance() = Gn1.flow(source,sink)
          by A1,A2,A4,A7,A8,Th16; then
        Gn.flow(source',sink') + P.tolerance() - P.tolerance() <
          Gn1.flow(source,sink) - 0 by A9,REAL_1:92;
        hence contradiction by A2,A3;
      end;
    hence thesis by A1,A4,Th20;
end;
