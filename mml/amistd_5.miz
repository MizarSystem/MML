:: Relocable Instructions
::  by Andrzej Trybulec
::
:: Received November 20, 2010
:: Copyright (c) 2010 Association of Mizar Users

environ

 vocabularies NUMBERS, ORDINAL1, SETFAM_1, ARYTM_1, ARYTM_3, CARD_1, SUBSET_1,
      AMI_1, XBOOLE_0, RELAT_1, TARSKI, FUNCOP_1, GLIB_000, GOBOARD5,
      AMISTD_1, UNIALG_1, FUNCT_1, CARD_3, CARD_5, FRECHET, RCOMP_1, STRUCT_0,
      VALUED_1, FSM_1, FUNCT_4, FUNCT_7, TURING_1, CIRCUIT2, AMISTD_2,
      PARTFUN1, CAT_1, SCMNORM, NAT_1, RELOC, PBOOLE, AMISTD_5, COMPOS_1,
      MSUALG_1, FINSET_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, MCART_1, SETFAM_1,
      FINSET_1,
      MEMBERED, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4, PBOOLE,
      CARD_1, NUMBERS, XCMPLX_0, XXREAL_0, NAT_1, CARD_3, FINSEQ_1, FUNCOP_1,
      NAT_D, FUNCT_7, VALUED_0, VALUED_1, AFINSQ_1,
      STRUCT_0, COMPOS_1, EXTPRO_1, AMISTD_1, AMISTD_2, AMI_1;
 constructors WELLORD2, REALSET1, NAT_D, AMISTD_1, XXREAL_2, PRE_POLY,
      AFINSQ_1, ORDINAL4, RECDEF_2, VALUED_1, AMISTD_2, AMI_1, PBOOLE,
      RELSET_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1,
      XXREAL_0, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, CARD_3, REALSET1, FUNCT_7,
      STRUCT_0, AMISTD_1, CARD_1, FUNCT_4, XXREAL_2, RELSET_1, GRFUNC_1,
      FUNCT_2, ORDINAL1, AFINSQ_1, VALUED_1, VALUED_0, COMPOS_1, EXTPRO_1,
      XCMPLX_0, REAL_1, PBOOLE, AMISTD_2, AMI_1;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;
 definitions RELAT_1, FUNCT_1, WELLORD2, FUNCT_7, COMPOS_1, EXTPRO_1, YELLOW_8,
      AMISTD_1, XBOOLE_0, FUNCOP_1, CARD_3, NAT_1, AFINSQ_1, MCART_1, VALUED_1,
      TARSKI, AMISTD_2, STRUCT_0;
 theorems AMISTD_1, FUNCOP_1, FUNCT_1, FUNCT_4, GRFUNC_1, MCART_1,
      RELAT_1, SETFAM_1, TARSKI, ZFMISC_1, CARD_3, XBOOLE_0, XBOOLE_1, FUNCT_7,
      PBOOLE, PARTFUN1, RECDEF_2, VALUED_1, COMPOS_1, EXTPRO_1, ORDINAL1,
      NAT_D, AMISTD_2, AMI_1, RELSET_1, NAT_1;
 schemes NAT_1;

begin  :: Relocable instructions

theorem
  for N be with_non-empty_elements non empty set
  for S be regular J/A-independent homogeneous
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N))
  for I be Instruction of S st I is jump-only
  for k be Element of NAT holds IncAddr(I,k) is jump-only
  proof
   let N be with_non-empty_elements non empty set;
   let S be regular J/A-independent homogeneous
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
   let I be Instruction of S such that
A1:  I is jump-only;
   let k be Element of NAT;
A2:  InsCode I = InsCode IncAddr(I,k) by COMPOS_1:def 38;
    InsCode I is jump-only by A1,AMISTD_1:def 4;
   hence thesis by A2,AMISTD_1:def 4;
  end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
  realistic with_explicit_jumps
  (standard-ins IC-Ins-separated definite halting realistic
  (non empty stored-program AMI-Struct over N)),
  I be IC-relocable Instruction of S, k be Element of NAT;
 cluster IncAddr(I,k) -> IC-relocable;
 coherence
  proof
   let j,i being natural number, s being State of S;
   thus IC Exec(IncAddr(IncAddr(I,k),j),s) + i
    = IC Exec(IncAddr(I,k+j),s) + i by COMPOS_1:97
   .= IC Exec(IncAddr(I,k+j+i),IncIC(s,i)) by AMISTD_2:def 18
   .= IC Exec(IncAddr(I,k+(j+i)),IncIC(s,i))
   .= IC Exec(IncAddr(IncAddr(I,k),j+i),IncIC(s,i)) by COMPOS_1:97;
  end;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I be Instruction of S;
  attr I is relocable means
:Def1:  for j,k being natural number, s being State of S
  holds Exec(IncAddr(I,j+k),IncIC(s,k)) = IncIC(Exec(IncAddr(I,j),s),k);
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
 cluster relocable -> IC-relocable Instruction of S;
 coherence
  proof let I be Instruction of S such that
A1:  I is relocable;
   let j,k be natural number, s be State of S;
    reconsider kk=k as Element of NAT by ORDINAL1:def 13;
   thus IC Exec(IncAddr(I,j),s) + k
     = IC IncIC(Exec(IncAddr(I,j),s),kk) by COMPOS_1:54
    .= IC Exec(IncAddr(I,j+k),IncIC(s,k)) by A1,Def1;
  end;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  attr S is relocable means
:Def2: for I being Instruction of S holds I is relocable;
end;

theorem Th2:
 for N being with_non-empty_elements non empty set,
  I being Instruction of STC N, s be State of STC N,
  k being natural number
 holds Exec(I,IncIC(s,k)) = IncIC(Exec(I,s),k)
proof
 let N being with_non-empty_elements non empty set,
  I being Instruction of STC N, s be State of STC N,
  k being natural number;
 per cases by AMISTD_1:22;
 suppose
A1: InsCode I = 1;
  hence Exec(I,IncIC(s,k)) = IncIC(IncIC(s,k),1) by AMISTD_1:59
     .= IncIC(s,1+k) by COMPOS_1:162
     .= IncIC(IncIC(s,1),k) by COMPOS_1:162
     .= IncIC(Exec(I,s),k) by A1,AMISTD_1:59;
 end;
 suppose InsCode I = 0;
   then
A2:  I is halting by AMISTD_1:20;
  hence Exec(I,IncIC(s,k)) = IncIC(s,k) by EXTPRO_1:def 3
     .= IncIC(Exec(I,s),k) by A2,EXTPRO_1:def 3;
 end;
end;

definition
 let N be with_non-empty_elements non empty set;
 let S be realistic halting IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N);
 attr S is IC-recognized means
:Def3: for p being autonomic FinPartState of S st NPP p is non empty
   holds IC S in dom p;
end;

theorem Th3:
 for N being with_non-empty_elements non empty set
 for S being realistic halting IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N)
 holds S is IC-recognized iff
  for p being autonomic FinPartState of S st DataPart p <> {}
   holds IC S in dom p
proof
 let N be with_non-empty_elements non empty set;
 let S be realistic halting IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N);
 thus S is IC-recognized implies
  for p being autonomic FinPartState of S st DataPart p <> {}
   holds IC S in dom p
 proof assume
A1: S is IC-recognized;
  let p be autonomic FinPartState of S;
  assume DataPart p <> {};
   then NPP p is non empty by COMPOS_1:169,XBOOLE_1:3;
  hence thesis by A1,Def3;
 end;
 assume
A2: for p being autonomic FinPartState of S st DataPart p <> {}
   holds IC S in dom p;
  let p be autonomic FinPartState of S;
A3: dom NPP p c= {IC S} \/ dom DataPart p by COMPOS_1:171;
  assume
A4: NPP p is non empty;
  per cases;
  suppose
A5: IC S in dom NPP p;
    dom NPP p c= dom p by RELAT_1:25;
   hence IC S in dom p by A5;
  end;
  suppose not IC S in dom NPP p;
   then {IC S} misses dom NPP p by ZFMISC_1:56;
   then dom DataPart p is non empty by A4,A3,XBOOLE_1:3,73;
   then DataPart p is non empty;
  hence IC S in dom p by A2;
  end;
end;

registration
 let N be with_non-empty_elements non empty set;
 cluster Data-Locations STC N -> empty;
 coherence
  proof
    the carrier of STC N = {NAT} \/ NAT by AMISTD_1:def 11
        .= {IC STC N} \/ NAT by AMISTD_1:def 11;
   hence thesis by XBOOLE_1:37;
  end;
end;

registration
 let N be with_non-empty_elements non empty set;
 let p be PartState of STC N;
 cluster DataPart p -> empty;
 coherence;
end;

registration
 let N be with_non-empty_elements non empty set;
 cluster STC N -> IC-recognized relocable;
 coherence
  proof
    for p being autonomic FinPartState of STC N st DataPart p <> {}
     holds IC STC N in dom p;
   hence STC N is IC-recognized by Th3;
   let I be Instruction of STC N;
   let j,k be natural number, s be State of STC N;
   thus Exec(IncAddr(I,j+k),IncIC(s,k))
        = Exec(I,IncIC(s,k)) by COMPOS_1:92
       .= IncIC(Exec(I,s),k) by Th2
       .= IncIC(Exec(IncAddr(I,j),s),k) by COMPOS_1:92;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N -> proper-halt;
 coherence
  proof
   thus halt STC N is ins-loc-free;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster relocable IC-recognized proper-halt
   (regular homogeneous J/A-independent standard halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)));
 existence
  proof
   take STC N;
   thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be relocable
   (regular homogeneous J/A-independent
    halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)));
 cluster -> relocable Instruction of S;
 coherence by Def2;
end;

reserve k for natural number;

theorem Th4:
  for N be with_non-empty_elements non empty set
  for S be relocable
   (regular homogeneous J/A-independent
    halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)))
  for INS being Instruction of S, s being State of S
   holds Exec(IncAddr(INS,k),IncIC(s,k)) = IncIC(Exec(INS,s),k)
 proof
  let N be with_non-empty_elements non empty set;
  let S be relocable
   (regular homogeneous J/A-independent
    halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)));
  let INS be Instruction of S, s be State of S;
  thus Exec(IncAddr(INS,k),IncIC(s,k))
          = Exec(IncAddr(INS,(0 qua Nat)+k),IncIC(s,k))
         .= IncIC(Exec(IncAddr(INS,0),s),k) by Def1
         .= IncIC(Exec(INS,s),k) by COMPOS_1:91;
 end;

theorem Th5:
  for N be with_non-empty_elements non empty set
  for S be relocable
   (regular homogeneous J/A-independent
    halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)))
  for INS being Instruction of S, s being State of S,
      j, k being Element of NAT st IC s = j+k
 holds Exec(INS, DecIC(s,k)) = DecIC(Exec(IncAddr(INS, k), s),k)
proof
  let N be with_non-empty_elements non empty set;
  let S be relocable
   (regular homogeneous J/A-independent
    halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)));
  let INS be Instruction of S, s be State of S,
      j,k be Element of NAT such that
A1: IC s = j+k;
  set s1 = s +* Start-At(j,S);
A2: IncIC(s1,k) = s +* Start-At(IC s,S) by A1,COMPOS_1:163
     .= s by COMPOS_1:165;
A3: Exec(IncAddr(INS,k),IncIC(s1,k)) = IncIC(Exec(INS,s1),k) by Th4;
 thus Exec(INS, DecIC(s,k))
    = Exec(INS,s1) by A1,NAT_D:34
   .= Exec(INS,s1) +* Start-At(IC Exec(INS,s1),S) by COMPOS_1:165
   .= IncIC(Exec(INS,s1),k) +*
       Start-At(IC Exec(INS,s1),S) by FUNCT_4:122
   .= DecIC(Exec(IncAddr(INS, k), s),k) by A2,A3,COMPOS_1:166;
end;

registration let N be with_non-empty_elements non empty set;
 cluster relocable IC-recognized proper-halt
  (regular homogeneous J/A-independent
    Exec-preserving halting realistic     steady-programmed
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)));
 existence
  proof
   take STC N;
   thus thesis;
  end;
end;

reserve N for with_non-empty_elements non empty set,
   S for IC-recognized
    (halting realistic steady-programmed
   (standard-ins IC-Ins-separated definite realistic
  (non empty stored-program AMI-Struct over N)));

theorem Th6:
  for p being autonomic non NAT-defined FinPartState of S
   holds IC S in dom p
proof
  let p be autonomic non NAT-defined FinPartState of S;
   dom p c= the carrier of S by RELAT_1:def 18;
   then
A1: dom p = dom p /\ the carrier of S by XBOOLE_1:28
    .= dom p /\ ({IC S} \/ Data-Locations S \/ NAT) by COMPOS_1:160
    .= dom p /\ ({IC S} \/ Data-Locations S) \/ dom p /\ NAT by XBOOLE_1:23;
  not dom p c= NAT by RELAT_1:def 18;
  then dom p /\ ({IC S} \/ Data-Locations S) <> {} by A1,XBOOLE_1:17;
  then
A2: dom p /\ {IC S} \/ dom p /\ Data-Locations S <> {} by XBOOLE_1:23;
  per cases by A2;
  suppose
    dom p /\ {IC S} <> {};
    then dom p meets {IC S} by XBOOLE_0:def 7;
    hence thesis by ZFMISC_1:56;
  end;
  suppose
    dom p /\ Data-Locations S <> {};
    then DataPart p <> {} by RELAT_1:60,90;
    hence thesis by Th3;
  end;
end;

definition let N;
 let S be realistic halting IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N);
 attr S is CurIns-recognized means
:Def4: for p being autonomic non NAT-defined FinPartState of S
  for s being State of S st p c= s
 for P being (the Instructions of S)-valued ManySortedSet of NAT
       st ProgramPart p c= P
  for i being Element of NAT
   holds IC Comput(P,s,i) in dom ProgramPart p;
end;

registration let N;
 cluster STC N -> CurIns-recognized;
 coherence
proof
  let p be autonomic non NAT-defined FinPartState of STC N,
      s be State of STC N such that
A1: p c= s;
  let P be (the Instructions of STC N)-valued ManySortedSet of NAT such that
A2: ProgramPart p c= P;
  let i be Element of NAT;
  set Csi = Comput(P,s,i);
  set loc = IC Csi;
  reconsider ll = loc as Element of NAT;
  set loc1 = ll+1;
A3: loc in dom ProgramPart p iff loc in dom p /\ NAT by RELAT_1:90;
  assume not IC Comput(P,s,i) in dom ProgramPart(p);
  then
A4: not loc in dom p by A3,XBOOLE_0:def 4;
  the Instructions of STC N = {[0,0,0],[1,0,0]} by AMISTD_1:def 11;
  then
  reconsider I = [1,0,0] as Instruction of STC N by TARSKI:def 2;
  set p2 = p +* (loc .--> halt STC N);
  set p1 = p +* (loc .--> I);
A5: dom p1 = dom p \/ dom (loc .--> I) by FUNCT_4:def 1;
A6: dom (loc .--> halt STC N) = {loc} by FUNCOP_1:19;
  then
A7: loc in dom (loc .--> halt STC N) by TARSKI:def 1;
A8: dom p2 = dom p \/ dom (loc .--> halt STC N) by FUNCT_4:def 1;
  then
A9: loc in dom p2 by A7,XBOOLE_0:def 3;
  consider s2 being State of STC N such that
A10: p2 c= s2 by PBOOLE:156;
  set Cs2i = Comput(ProgramPart(s2),s2,i);
  consider s1 being State of STC N such that
A11: p1 c= s1 by PBOOLE:156;
  set Cs1i = Comput(ProgramPart(s1),s1,i);
A12: dom (loc .--> I) = {loc} by FUNCOP_1:19;
  then
A13: loc in dom (loc .--> I) by TARSKI:def 1;
  then
A14: loc in dom p1 by A5,XBOOLE_0:def 3;
  p is not autonomic
  proof
A15: now
      let x be set;
      assume
A16:  x in dom p;
      dom p misses dom (loc .--> halt STC N) by A4,A6,ZFMISC_1:56;
      then
A17:  p.x = p2.x by A16,FUNCT_4:17;
      x in dom p2 by A8,A16,XBOOLE_0:def 3;
      hence p.x = s2.x by A10,A17,GRFUNC_1:8;
    end;
    (loc .--> halt STC N).loc = halt STC N by FUNCOP_1:87;
    then p2.loc = halt STC N by A7,FUNCT_4:14;
    then s2.loc = halt STC N by A9,A10,GRFUNC_1:8;
    then
A18: Cs2i.loc = halt STC N by AMI_1:54;
    (loc .--> I).loc = I by FUNCOP_1:87;
    then p1.loc = I by A13,FUNCT_4:14;
    then
A19:  s1.loc = I by A14,A11,GRFUNC_1:8;
    take P = ProgramPart s1, Q = ProgramPart s2;
A20: now
      let x be set;
      assume
A21:  x in dom p;
      dom p misses dom (loc .--> I) by A4,A12,ZFMISC_1:56;
      then
A22:  p.x = p1.x by A21,FUNCT_4:17;
      x in dom p1 by A5,A21,XBOOLE_0:def 3;
      hence p.x = s1.x by A11,A22,GRFUNC_1:8;
    end;
dom s1 = the carrier of STC N by PARTFUN1:def 4;
    then
A23:   dom p c= dom s1 by RELAT_1:def 18;
    then
A24: p c= s1 by A20,GRFUNC_1:8;
    hence
A25:  ProgramPart p c= P by RELAT_1:105;
    dom s2 = the carrier of STC N by PARTFUN1:def 4;
    then
A26:   dom p c= dom s2 by RELAT_1:def 18;
    then
  p c= s2 by A15,GRFUNC_1:8;
    hence
A27:   ProgramPart p c= Q by RELAT_1:105;
    take s1, s2;
    thus p c= s1 by A23,A20,GRFUNC_1:8;
    then
A28: (Cs1i|dom NPP p) = (Csi|dom NPP p)
        by A1,EXTPRO_1:def 9,A25,A2;
    thus p c= s2 by A26,A15,GRFUNC_1:8;
    then
A29: (Cs1i|dom NPP p) = (Cs2i|dom NPP p) by A24,EXTPRO_1:def 9,A25,A27;
    take k = i+1;
    set Cs1k = Comput(ProgramPart(s1),s1,k);
A30:  (ProgramPart Cs1i)/.IC Cs1i = Cs1i.IC Cs1i by COMPOS_1:38;
A31: Cs1k = Following(ProgramPart s1,Cs1i) by EXTPRO_1:4
      .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by AMI_1:123;
   InsCode I = 1 by RECDEF_2:def 1;
   then
A32:  Exec(I,Cs1i).IC STC N = succ IC Cs1i by AMISTD_1:38;
A33: IC STC N in dom p by Th6;
A34: Csi.IC STC N = (Csi|dom NPP p).IC STC N by FUNCT_1:72,COMPOS_1:179,A33;
    then Cs1i.IC STC N = loc by A28,FUNCT_1:72,COMPOS_1:179,A33;
    then
A35: Cs1k.IC STC N = loc1 by A32,A31,A19,A30,AMI_1:54;
    set Cs2k = Comput(ProgramPart(s2),s2,k);
A36: Cs2k = Following(ProgramPart s2,Cs2i) by EXTPRO_1:4
      .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by AMI_1:123;
A37:  (ProgramPart Cs2i)/.IC Cs2i
 = Cs2i.IC Cs2i by COMPOS_1:38;
    Cs2i.IC STC N = loc by A28,A34,A29,FUNCT_1:72,COMPOS_1:179,A33;
    then
A38: Cs2k.IC STC N = loc by EXTPRO_1:def 3,A36,A18,A37;
    (Cs1k|dom NPP p).IC STC N = Cs1k.IC STC N &
     (Cs2k|dom NPP p).IC STC N = Cs2k.IC STC N
    by FUNCT_1:72,COMPOS_1:179,A33;
    hence thesis by A35,A38;
  end;
  hence contradiction;
end;
end;

theorem
 S is CurIns-recognized implies
 for p being autonomic non NAT-defined FinPartState of S,
     s1,s2 being State of S st p c= s1 & p c= s2
 for P1,P2 being (the Instructions of S)-valued ManySortedSet of NAT
    st ProgramPart p c= P1 & ProgramPart p c= P2
 for i being Element of NAT
 holds IC Comput(P1,s1,i) = IC Comput(P2,s2,i) &
   CurInstr(P1,Comput(P1,s1,i)) = CurInstr(P2,Comput(P2,s2,i))
proof assume
A1: S is CurIns-recognized;
  let p be autonomic non NAT-defined FinPartState of S, s1, s2 be State of
  S such that
A2: p c= s1 and
A3: p c= s2;
 let P1,P2 be (the Instructions of S)-valued ManySortedSet of NAT such that
A4: ProgramPart p c= P1 and
A5: ProgramPart p c= P2;
A6: dom ProgramPart p c= dom P1 by A4,RELAT_1:25;
A7: dom ProgramPart p c= dom P2 by A5,RELAT_1:25;
A8:  IC S in dom p by Th6;
  let i be Element of NAT;
  set Cs2i = Comput(P2,s2,i);
  set Cs1i = Comput(P1,s1,i);
A9: IC Cs1i in dom ProgramPart p by A4,A2,Def4,A1;
A10: IC Cs2i in dom ProgramPart p by A5,A3,Def4,A1;
  thus
A11: IC Cs1i = IC Cs2i
  proof
    assume
A12: IC Comput(P1,s1,i) <> IC Comput(P2,s2,i);
    (Cs1i|dom NPP p).IC S = Cs1i.IC S & (Cs2i|dom NPP p).IC S = Cs2i.IC S
    by COMPOS_1:179,A8,FUNCT_1:72;
    hence contradiction by A2,A3,A12,EXTPRO_1:def 9,A4,A5;
  end;
  thus CurInstr(P1,Comput(P1,s1,i))
   = (P1).IC Cs1i by A9,A6,PARTFUN1:def 8
  .= (ProgramPart p).IC Cs1i by A9,GRFUNC_1:8,A4
  .= (P2).IC Cs2i by A10,GRFUNC_1:8,A5,A11
  .= CurInstr(P2,Comput(P2,s2,i)) by A10,A7,PARTFUN1:def 8;
end;

reserve S for relocable IC-recognized
    (regular homogeneous J/A-independent
    Exec-preserving
     halting realistic  steady-programmed
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)));

theorem
 S is CurIns-recognized implies
  for k being Element of NAT for p being autonomic FinPartState of S
  st IC S in dom p for s being State of S st p c= s
  for i being Element of NAT
   holds Comput(ProgramPart(s +* Relocated (p,k)),s +* Relocated (p,k),i) =
    IncIC(Comput(ProgramPart(s),s,i),k) +* Reloc(ProgramPart p,k)
proof assume
A1: S is CurIns-recognized;
  let k be Element of NAT;
  let p be autonomic FinPartState of S such that
A2: IC S in dom p;
  let s be State of S such that
A4: p c= s;
A5: ProgramPart p c= ProgramPart s by A4,RELAT_1:105;
  defpred P[Element of NAT] means Comput(ProgramPart(s+*Relocated(p,k)),s+*
Relocated(p,k),$1) =
  IncIC(Comput(ProgramPart(s),s,$1),k) +* Reloc(ProgramPart p,k);
A6: for i being Element of NAT st P[i] holds P[i+1]
  proof
    let i be Element of NAT such that
A7: Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i)
 = IncIC(Comput(ProgramPart(s),s,i),k) +* Reloc(ProgramPart p,k);
    reconsider kk = IC Comput(ProgramPart(s),s,i) as Element of NAT;
    dom (Start-At (IC Comput(ProgramPart(s),s,i) +k,S)) = {IC S} by
FUNCOP_1:19;
    then
A8: IC S in dom (Start-At (IC Comput(ProgramPart(s),s,i) +k,S)) by
TARSKI:def 1;
    Reloc(ProgramPart p,k) = ProgramPart Relocated(p,k) by COMPOS_1:116;
    then not IC S in dom Reloc(ProgramPart p,k) by COMPOS_1:12;
    then
A9: IC ( Comput(ProgramPart(s),s,i) +* Start-At (IC Comput(ProgramPart(s),s,i)
+k,S) +*
    Reloc(ProgramPart p,k)) = ( Comput(ProgramPart(s),s,i) +* Start-At (
IC
    Comput(ProgramPart(s),s,i) +k,S)).IC S by FUNCT_4:12
      .= (Start-At (IC Comput(ProgramPart(s),s,i) +k,S)).IC S by A8,
FUNCT_4:14
      .= IC Comput(ProgramPart(s),s,i) + k by FUNCOP_1:87;
A10: ProgramPart(p) c= Comput(ProgramPart(s),s,i) by A4,AMI_1:99;
    p is not NAT-defined by A2,COMPOS_1:19;
    then
A11: IC Comput(ProgramPart(s),s,i) in dom ProgramPart p by A4,A5,Def4,A1;
    then
A12: IC Comput(ProgramPart(s),s,i) in dom IncAddr(ProgramPart p,k)
 by COMPOS_1:def 40;
A13: ProgramPart (s+*Relocated(p,k)) = ProgramPart
Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i) by AMI_1:123;
A14:  (ProgramPart(s+*Relocated(p,k)))/.
  IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i)
 = Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i).
 IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i)
     by A13,COMPOS_1:38;
A15: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,i) by AMI_1:123;
A16:  (ProgramPart s)/.IC Comput(ProgramPart(s),s,i)
 = Comput(ProgramPart(s),s,i).IC Comput(ProgramPart(s),s,i) by A15,COMPOS_1:38;
A17: (ProgramPart p)/.kk = (ProgramPart(p)).IC Comput(ProgramPart(s),s,i) by
A11,PARTFUN1:def 8
      .= ( Comput(ProgramPart(s),s,i)).IC Comput(ProgramPart(s),s,i) by A11,A10
,
GRFUNC_1:8;
    reconsider kk = IC Comput(ProgramPart(s),s,i) as Element of NAT;
    (IC Comput(ProgramPart(s),s,i) +k)
     in dom Reloc(ProgramPart p,k)  by A11,COMPOS_1:158;
    then
A18: CurInstr(ProgramPart(s+*Relocated(p,k)),
            Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i))
 = (Reloc(ProgramPart p,k)).(IC Comput(ProgramPart(s),s,i) +k)
  by A7,A9,A14,FUNCT_4:14
      .= Shift(IncAddr(ProgramPart p,k),k).(IC Comput(ProgramPart(s),s,i) +k)
by COMPOS_1:159
      .= IncAddr(ProgramPart p,k).kk by A12,VALUED_1:def 12
      .= IncAddr (CurInstr(ProgramPart(s),Comput(ProgramPart(s),s,i)),k)
       by A11,A17,A16,COMPOS_1:def 40;
A19: Comput(ProgramPart(s),s,i+1)
 = Following(ProgramPart s,Comput(ProgramPart(s),s,i))
& Exec(IncAddr(CurInstr(ProgramPart(s),Comput(ProgramPart(s),s,i)),k),
   IncIC(Comput(ProgramPart(s),s,i),k)
) = IncIC(Following(ProgramPart(s),Comput(ProgramPart(s),s,i)),k)
  by Th4,EXTPRO_1:4;
    thus Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i+1)
     = Following(ProgramPart (s+*Relocated(p,k)),
     Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i)) by EXTPRO_1:4
      .= IncIC(Comput(ProgramPart(s),s,i+1),k) +* Reloc(ProgramPart p,k)
             by A7,A18,A19,AMI_1:127;
  end;
A20: Comput(ProgramPart(s),s,0) = s by EXTPRO_1:3;
A21: IC p = IC s by A2,A4,GRFUNC_1:8;
  DataPart p c= p by RELAT_1:88;
  then
A22: DataPart p c= s by A4,XBOOLE_1:1;
  Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),0)
    = s +* (IncIC(NPP p,k) +* Reloc(ProgramPart p,k)) by EXTPRO_1:3
   .= s +* (DataPart p +* Start-At ((IC p) +k,S) +*
         Reloc(ProgramPart p,k)) by A2,COMPOS_1:75
   .= s +* (DataPart p +* (Start-At ((IC p) +k,S) +*
         Reloc(ProgramPart p,k))) by FUNCT_4:15
   .= s +* DataPart p +* (Start-At ((IC p) +k,S) +*
         Reloc(ProgramPart p,k)) by FUNCT_4:15
    .= s +* DataPart p +* Start-At ((IC p) +k,S) +*
     Reloc(ProgramPart p,k) by FUNCT_4:15
    .= Comput(ProgramPart(s),s,0) +* Start-At (IC Comput(ProgramPart(s),s,0) +k
,S) +* Reloc(ProgramPart p,k) by A21,A22,A20,FUNCT_4:79;
  then
A23: P[0];
  thus for i being Element of NAT holds P[i] from NAT_1:sch 1(A23,A6);
end;

theorem Th9:
 S is CurIns-recognized implies
  for k being Element of NAT
  for p being autonomic FinPartState of S st IC S in dom p
  for s being State of S st Relocated(p,k) c= s holds
  for P being (the Instructions of S)-valued ManySortedSet of NAT
   st Reloc(ProgramPart p,k) c= P
  for i being Element of NAT holds Comput(P,s,i) =
    IncIC(Comput(P+*ProgramPart p,s+*p,i),k) +* s|dom ProgramPart p
       +* Reloc(ProgramPart p,k)
proof assume
A1: S is CurIns-recognized;
  let k be Element of NAT;
  let p be autonomic FinPartState of S such that
A2: IC S in dom p;
RE: Reloc(ProgramPart p,k) = ProgramPart Relocated(p,k) by COMPOS_1:116;
  let s be State of S such that
A4: Relocated (p,k) c= s;
  let P be (the Instructions of S)-valued ManySortedSet of NAT such that
A5: Reloc(ProgramPart p,k) c= P;
  defpred Z[Element of NAT] means Comput(P,s,$1) =
   IncIC(Comput(P+*ProgramPart p,s+*p,$1),k)
     +* s|dom ProgramPart p
     +* Reloc(ProgramPart p,k);
A6: for i being Element of NAT st Z[i] holds Z[i+1]
  proof
    set sdom = s|dom ProgramPart p;
    dom ProgramPart p c= the carrier of S by RELAT_1:def 18;
    then dom ProgramPart p c= dom s by PARTFUN1:def 4;
    then
 dom ProgramPart p = dom (s|dom ProgramPart p) by RELAT_1:91;
    then rng sdom c= the Instructions of S & dom (s|dom ProgramPart p) c=
    NAT by COMPOS_1:32,RELAT_1:87;
    then reconsider
    sdom as NAT-defined FinPartState of S by RELSET_1:11;
    let i be Element of NAT such that
A7: Comput(P,s,i) =
     IncIC(Comput(P+*ProgramPart p,s+*p,i),k)
           +* s|dom ProgramPart p+* Reloc(ProgramPart p,k);
    reconsider kk = IC Comput(P+*ProgramPart p,s+*p,i) as Element of NAT;
    dom (Start-At (IC Comput(P+*ProgramPart p,s+*p,i) +k,S)) = {IC S} by
FUNCOP_1:19;
    then
A8: IC S in dom (Start-At (IC Comput(P+*ProgramPart p,s+*p,i) +k,S)) by
TARSKI:def 1;
    dom (sdom) = dom s /\ dom ProgramPart p & not IC S in dom
    ProgramPart p by COMPOS_1:12,RELAT_1:90;
    then
A9: not IC S in dom sdom by XBOOLE_0:def 4;
A10: p c= s+*p by FUNCT_4:26;
A11: ProgramPart p c= P+*ProgramPart p by FUNCT_4:26;
    p is not NAT-defined by A2,COMPOS_1:19;
    then
A12: IC Comput(P+*ProgramPart p,s+*p,i) in dom ProgramPart(p)
       by A1,Def4,A10,A11;
    then
A13: IC Comput(P+*ProgramPart p,s+*p,i) in dom IncAddr(ProgramPart p,k) by
COMPOS_1:def 40;
A14: (IC Comput(P+*ProgramPart p,s+*p,i) +k) in dom Reloc(ProgramPart p,k)
              by A12,COMPOS_1:158;
    reconsider kk = (IC Comput(P+*ProgramPart p,s+*p,i)) as Element of NAT;
 Reloc(ProgramPart p,k) = ProgramPart Relocated(p,k) by COMPOS_1:116;
    then not IC S in dom Reloc(ProgramPart p,k) by COMPOS_1:12;
    then
A15:  IC Comput(P,s,i) = ( Comput(P+*ProgramPart p,s+*p,i) +*
Start-At
    (IC Comput(P+*ProgramPart p,s+*p,i) +k,S) +* sdom).IC S by FUNCT_4:12,A7
      .= ( Comput(P+*ProgramPart p,s+*p,i) +*
       Start-At (IC Comput(P+*ProgramPart p,s+*p,i) +k,S)).IC
    S by A9,FUNCT_4:12
      .= (Start-At (IC Comput(P+*ProgramPart p,s+*p,i) +k,S)).IC S by A8,
FUNCT_4:14
      .= IC Comput(P+*ProgramPart p,s+*p,i) + k by FUNCOP_1:87;
A16: ProgramPart p c= P+*ProgramPart p by FUNCT_4:26;
A17: (ProgramPart p)/.kk = (ProgramPart p).kk by A12,PARTFUN1:def 8;
A18:  dom(P+*ProgramPart p) = NAT by PARTFUN1:def 4;
    dom P = NAT by PARTFUN1:def 4;
    then
A19: CurInstr(P,Comput(P,s,i))
     = P.IC Comput(P,s,i) by PARTFUN1:def 8
    .= Reloc(ProgramPart p,k).IC Comput(P,s,i) by A5,A14,GRFUNC_1:8,A15
      .= Shift(IncAddr(ProgramPart p,k),k).(IC Comput(P+*ProgramPart p,s+*p,i)
+k)
       by COMPOS_1:159,A15
      .= IncAddr(ProgramPart p,k).kk by A13,VALUED_1:def 12
      .= IncAddr((ProgramPart p)/.kk,k) by A12,COMPOS_1:def 40
      .= IncAddr(
          (P+*ProgramPart p).IC Comput(P+*ProgramPart p,s+*p,i)
          ,k) by A12,GRFUNC_1:8,A17,A16
      .= IncAddr(
          CurInstr(P+*ProgramPart p,Comput(P+*ProgramPart p,s+*p,i))
          ,k) by PARTFUN1:def 8,A18;
A20: Comput(P+*ProgramPart p,s+*p,i+1)
 = Following(P+*ProgramPart p,Comput(P+*ProgramPart p,s+*p,i))
 by EXTPRO_1:4;
    thus Comput(P,s,i+1)
     = Following(P,Comput(P,s,i)) by EXTPRO_1:4
      .= Exec(IncAddr(CurInstr(P+*ProgramPart p,
      Comput(P+*ProgramPart p,s+*p,i)),k),
       IncIC(Comput(P+*ProgramPart p,s+*p,i),k)
        +* sdom ) +*
        Reloc(ProgramPart p,k) by A7,A19,AMI_1:127
      .= Exec(IncAddr(CurInstr(P+*ProgramPart p,
      Comput(P+*ProgramPart p,s+*p,i)),k),
      IncIC(Comput(P+*ProgramPart p,s+*p,i),k)) +* sdom
       +* Reloc(ProgramPart p,k) by AMI_1:127
      .= IncIC(Comput(P+*ProgramPart p,s+*p,i+1),k)
     +*
    s|dom ProgramPart p +* Reloc(ProgramPart p,k) by A20,Th4;
  end;
  set IP = Start-At (IC p,S);
A21: dom Start-At(IC p,S) = {IC S} by FUNCOP_1:19;
A22: Start-At (IC p + k,S) c= Relocated (p,k) by A2,COMPOS_1:123;
  IC Comput(P+*ProgramPart p,s+*p,0) = (s +* p).IC S by EXTPRO_1:3
    .= IC p by A2,FUNCT_4:14;
  then
A23: Start-At (IC Comput(P+*ProgramPart p,s+*p,0) +k,S) c= s by A4,A22,
XBOOLE_1:1;
  set DP = DataPart p;
A24: {IC S} misses dom DataPart p by COMPOS_1:13;
  set PP = ProgramPart p;
A25: dom DataPart p misses dom ProgramPart p by COMPOS_1:15;
  set SD = s|dom ProgramPart p;
A26: s|dom ProgramPart p c= s by RELAT_1:88;
  Reloc(ProgramPart p,k) c= Relocated (p,k) by RELAT_1:88,RE;
  then
A27: Reloc(ProgramPart p,k) c= s by A4,XBOOLE_1:1;
  dom ProgramPart p c= the carrier of S by RELAT_1:def 18;
  then dom ProgramPart p c= dom s by PARTFUN1:def 4;
  then
A28: dom ProgramPart p = dom (s|dom ProgramPart p) by RELAT_1:91;
  DataPart (Relocated (p,k)) c= Relocated (p,k) by RELAT_1:88;
  then DataPart (Relocated (p,k)) c= s by A4,XBOOLE_1:1;
  then
A29: DataPart p c= s by COMPOS_1:115;
  set PR = Reloc(ProgramPart p,k);
  set IS = Start-At (IC Comput(P+*ProgramPart p,s+*p,0) +k,S);
A30: dom Start-At (IC Comput(P+*ProgramPart p,s+*p,0) +k,S) = {IC S} by
FUNCOP_1:19;
  Comput(P,s,0) = s by EXTPRO_1:3
    .= s +* PR by A27,FUNCT_4:79
    .= s +* SD +* PR by A26,FUNCT_4:79
    .= s +* PP +* SD +* PR by A28,FUNCT_4:78
    .= s +* IS +* PP +* SD +* PR by A23,FUNCT_4:79
    .= s +*(IS +* PP) +* SD +* PR by FUNCT_4:15
    .= s +*(PP +* IS) +* SD +* PR by A30,COMPOS_1:14,FUNCT_4:36
    .= (s +* PP)+* IS +* SD +* PR by FUNCT_4:15
    .= (s +* DP)+* PP +* IS +* SD +* PR by A29,FUNCT_4:79
    .= (s +*(DP +* PP))+* IS +* SD +* PR by FUNCT_4:15
    .= (s +*(PP +* DP))+* IS +* SD +* PR by A25,FUNCT_4:36
    .= (s +* PP)+* DP +* IS +* SD +* PR by FUNCT_4:15
    .=((s +* PP)+* DP) +* IP +* IS +* SD +* PR by A30,A21,FUNCT_4:78
    .= (s +*(PP +* DP))+* IP +* IS +* SD +* PR by FUNCT_4:15
    .= s +*(PP +* DP +* IP) +* IS +* SD +* PR by FUNCT_4:15
    .= s +*(PP +*(DP +* IP))+* IS +* SD +* PR by FUNCT_4:15
    .= s +*(PP +*(IP +* DP))+* IS +* SD +* PR by A21,A24,FUNCT_4:36
    .= s +*(PP +* IP +* DP) +* IS +* SD +* PR by FUNCT_4:15
    .= s +*(IP +* PP +* DP) +* IS +* SD +* PR by A21,COMPOS_1:14,FUNCT_4:36
    .= s +* p +* IS +* SD +* PR by A2,COMPOS_1:18
    .= Comput(P+*ProgramPart p,s+*p,0) +*
     Start-At (IC Comput(P+*ProgramPart p,s+*p,0) +k,S) +* s|dom
  ProgramPart p +* Reloc(ProgramPart p,k) by EXTPRO_1:3;
  then
A31: Z[0];
  thus for i being Element of NAT holds Z[i] from NAT_1:sch 1 (A31,A6 );
end;

reserve m,j for Element of NAT;

theorem Th10:
 S is CurIns-recognized implies
  for k being Element of NAT for p being FinPartState of S st IC
  S in dom p
   for s being State of S st p c= s & Relocated(p,k) is autonomic
   for P being (the Instructions of S)-valued ManySortedSet of NAT
    st ProgramPart p c= P
  holds for i being Element of NAT holds Comput(P,s,i)
   = DecIC(Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i),k)
 +* s|dom Reloc(ProgramPart p,k) +* ProgramPart (p)
proof assume
A1: S is CurIns-recognized;
  let k be Element of NAT;
  let p be FinPartState of S;
RE: Reloc(ProgramPart p,k) = ProgramPart Relocated(p,k) by COMPOS_1:116;
  assume
A3:  IC S in dom p;
  then
A4: Start-At (IC p,S) c= p by FUNCOP_1:99;
  let s be State of S such that
A5: p c= s and
A6: Relocated (p,k) is autonomic;
  let P be (the Instructions of S)-valued ManySortedSet of NAT such that
A7: ProgramPart p c= P;
A8: Start-At(IC p,S) c= s by A5,A4,XBOOLE_1:1;
  defpred Z[Element of NAT] means Comput(P,s,$1) =
   DecIC(Comput(P+*Reloc(ProgramPart p,k),s+*Relocated (p,k),$1),k)
   +* s|(dom
  Reloc(ProgramPart p,k)) +* ProgramPart p;
A9: for i being Element of NAT st Z[i] holds Z[i+1]
  proof
    reconsider pp = ProgramPart p as preProgram of S;
    set sdom = s|dom Reloc(ProgramPart p,k);
    dom Reloc(ProgramPart p,k) c= the carrier of S by RELAT_1:def 18;
    then dom Reloc(ProgramPart p,k) c= dom s by PARTFUN1:def 4;
    then
 dom Reloc(ProgramPart p,k) = dom (s|(dom Reloc(ProgramPart p,k)))
  by RELAT_1:91;
    then rng sdom c= the Instructions of S &
     dom (s|(dom Reloc(ProgramPart p,k) )) c= NAT
      by COMPOS_1:32,RELAT_1:87,RE;
    then reconsider
    sdom as NAT-defined FinPartState of S by RELSET_1:11;
    let i be Element of NAT such that
A10: Comput(P,s,i) =
       DecIC(Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i),k)
 +* s|dom
Reloc(ProgramPart p,k)
    +* ProgramPart p;
    reconsider kk = IC Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),
i) as Element of NAT;
    reconsider jk = IC Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),
i) as Element of NAT;
A11: Relocated(p,k) c= s+*Relocated(p,k) by FUNCT_4:26;
A12: Reloc(ProgramPart p,k) c= P+*Reloc(ProgramPart p,k)
       by FUNCT_4:26;
    IC S in dom Relocated(p,k) by COMPOS_1:119;
    then Relocated(p,k) is not NAT-defined by COMPOS_1:19;
    then
A13: IC Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i) in dom
          Reloc(ProgramPart p,k) by A6,A1,Def4,A11,A12,RE;
    then
A14: jk in { j+k : j in dom ProgramPart(p) } by COMPOS_1:117;
    dom sdom = dom s /\ dom Reloc(ProgramPart p,k) & not IC S in
    dom Reloc(ProgramPart p,k) by COMPOS_1:12,RELAT_1:90,RE;
    then
A15: not IC S in dom (sdom) by XBOOLE_0:def 4;
    dom (Start-At (IC Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i
) -'k,S)) = {IC S }
    by FUNCOP_1:19;
    then
A16: IC S in dom (Start-At (IC Comput(P+*Reloc(ProgramPart p,k),s+*
Relocated(p,k),i) -'k,S))
    by TARSKI:def 1;
    consider j being Element of NAT such that
A17: jk = j+k and
A18: j in dom ProgramPart(p) by A14;
A19:  dom(P+*Reloc(ProgramPart p,k)) = NAT by PARTFUN1:def 4;
A20: Reloc(ProgramPart p,k) c= P+*Reloc(ProgramPart p,k) by FUNCT_4:26;
    dom Shift(pp, k) = { m+k : m in dom pp} by VALUED_1:def 12;
    then
A21: (j+k) in dom Shift(ProgramPart(p), k) by A18;
    then
A22: IncAddr(Shift(ProgramPart p, k)/.kk,k)
    = Reloc(ProgramPart p,
    k). IC Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i) by A17,
COMPOS_1:def 40
      .= (P+*Reloc(ProgramPart p,k)).
         IC Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i)
           by A13,GRFUNC_1:8,A20
      .= CurInstr(P+*Reloc(ProgramPart p,k),
         Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i))
           by PARTFUN1:def 8,A19;
A23: j+k -' k = j by NAT_D:34;
A24:  dom P = NAT by PARTFUN1:def 4;
    not IC S in dom ProgramPart p by COMPOS_1:12;
    then
A25: IC ( DecIC(Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i),k)
     +* sdom +* ProgramPart p)
     = ( DecIC(Comput(P+*Reloc(ProgramPart p,k),s+*
    Relocated(p,k),i),k)
     +*
    sdom).IC S by FUNCT_4:12
      .= ( DecIC(Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i),k)
    ).IC S by A15,FUNCT_4:12
      .= (Start-At (IC Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),
i) -'k,S)).IC S
       by A16,FUNCT_4:14
      .= IC Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i) -' k by
FUNCOP_1:87;
    CurInstr(P,Comput(P,s,i))
     = P.IC Comput(P,s,i)
        by PARTFUN1:def 8,A24
    .= (ProgramPart p).IC Comput(P,s,i)
        by A10,A17,A18,A23,GRFUNC_1:8,A7,A25
      .= Shift(ProgramPart p, k). (IC Comput(P+*Reloc(ProgramPart p,k),s+*
Relocated(p,k),i)) by A17,A18,A23,VALUED_1:def 12,A10,A25
      .= Shift(ProgramPart p, k)/.kk by A17,A21,PARTFUN1:def 8;
    then
A26: Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i+1)
 = Following(P+*Reloc(ProgramPart p,k),
 Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i)) &
 Exec(CurInstr(P,Comput(P,s,i)),
 DecIC(Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i),k))
 = DecIC(Following(P+*Reloc(ProgramPart p,k),
 Comput(P+*Reloc(ProgramPart p,k),s +*Relocated(p,k),i)),k)
  by A17,A22,Th5,EXTPRO_1:4;
    thus Comput(P,s,i+1)
     = Following(P,Comput(P,s,i)) by EXTPRO_1:4
      .= Exec(CurInstr(P,Comput(P,s,i)),
       DecIC(Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i),k)
 +* sdom ) +* ProgramPart
    p by A10,AMI_1:127
     .= DecIC(Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),i+1),k) +*
        s|(dom Reloc(ProgramPart p,k)) +* ProgramPart p
    by A26,AMI_1:127;
  end;
A27: IC S in dom Relocated(p,k) by COMPOS_1:119;
A28: IC Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),0) = (s +*
Relocated(p,k)).IC S by EXTPRO_1:3
    .= IC Relocated(p,k) by A27,FUNCT_4:14;
  DataPart p c= p by RELAT_1:88;
  then
A29: DataPart p c= s by A5,XBOOLE_1:1;
  ProgramPart p c= p by RELAT_1:88;
  then
A30: ProgramPart p c= s by A5,XBOOLE_1:1;
  set DP = DataPart p;
  set IP = Start-At((IC p)+k,S);
A31: dom DataPart p misses dom Reloc(ProgramPart p,k) by COMPOS_1:15,RE;
  set PP = ProgramPart p;
  set IS = Start-At (IC Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k)
,0) -'k,S);
A32: dom Start-At((IC p)+k,S) = {IC S} by FUNCOP_1:19;
  set PR = Reloc(ProgramPart p,k);
  set SD = s|(dom Reloc(ProgramPart p,k));
A33: {IC S} misses dom DataPart p by COMPOS_1:13;
  dom Reloc(ProgramPart p,k) c= the carrier of S by RELAT_1:def 18;
  then dom Reloc(ProgramPart p,k) c= dom s by PARTFUN1:def 4;
  then
A34: dom Reloc(ProgramPart p,k) = dom(s|(dom Reloc(ProgramPart p,k))
  ) by RELAT_1:91;
  {IC S} misses dom Reloc(ProgramPart p,k) by COMPOS_1:14,RE;
  then
A35: {IC S} /\ dom Reloc(ProgramPart p,k) = {} by XBOOLE_0:def 7;
A36: dom Start-At (IC Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),0
) -'k,S) = {IC S} by FUNCOP_1:19;
  then
  dom(Start-At (IC Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),0)
-'k,S)) /\ dom (s|(dom
Reloc(ProgramPart p,k))) = {IC S} /\ (dom s /\
 dom Reloc(ProgramPart p,k)) by RELAT_1:90
    .= ({IC S} /\ dom Reloc(ProgramPart p,k)) /\ dom s by XBOOLE_1:16
    .= {} by A35;
  then
A37: dom(Start-At (IC Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),0
) -'k,S)) misses dom (s|
  (dom Reloc(ProgramPart p,k))) by XBOOLE_0:def 7;
A38: dom(IP +* Reloc(ProgramPart p,k)) =
     dom IP \/ dom Reloc(ProgramPart p,k) by FUNCT_4:def 1;
   dom Reloc(ProgramPart(p),k) c= NAT by RELAT_1:def 18;
   then
A39: dom Reloc(ProgramPart(p),k) misses Data-Locations S
        by COMPOS_1:51,XBOOLE_1:63;
A40:  dom IP misses dom DP by A33,FUNCOP_1:19;
   dom Reloc(ProgramPart p,k) misses dom DP by A39,XBOOLE_1:63,RELAT_1:87;
   then
A41: dom(IP +* Reloc(ProgramPart p,k)) misses dom DP by A40,A38,XBOOLE_1:70;
A42: IP +* PR +* DP = DP +* (IP +* Reloc(ProgramPart p,k)) by A41,FUNCT_4:36
      .= DP +* IP +* Reloc(ProgramPart p,k)
                    by FUNCT_4:15
      .= Relocated(p,k) by A3,COMPOS_1:75;
  Comput(P,s,0) = s by EXTPRO_1:3
    .= s +* PP by A30,FUNCT_4:79
    .= s +* Start-At(IC p,S) +* PP by A8,FUNCT_4:79
    .= s +* Start-At (IC p + k -'k,S) +* PP by NAT_D:34
    .= s +* IS +* PP by A28,A3,COMPOS_1:120
    .= s +* SD +* IS +* PP by FUNCT_4:80
    .= s +* PR +* SD +* IS +* PP by A34,FUNCT_4:78
    .= s +* PR +* (SD +* IS) +* PP by FUNCT_4:15
    .= s +* PR +* (IS +* SD) +* PP by A37,FUNCT_4:36
    .= s +* PR +* IS +* SD +* PP by FUNCT_4:15
    .= (s +* DP) +* PR +* IS +* SD +* PP by A29,FUNCT_4:79
    .= (s +*(DP +* PR))+* IS +* SD +* PP by FUNCT_4:15
    .= (s +*(PR +* DP))+* IS +* SD +* PP by A31,FUNCT_4:36
    .= (s +* PR) +* DP +* IS +* SD +* PP by FUNCT_4:15
    .=((s +* PR) +* DP) +* IP +* IS +* SD +* PP by A36,A32,FUNCT_4:78
    .= (s +*(PR +* DP))+* IP +* IS +* SD +* PP by FUNCT_4:15
    .= s +*(PR +* DP +* IP) +* IS +* SD +* PP by FUNCT_4:15
    .= s +*(PR +* (DP +* IP))+* IS +* SD +* PP by FUNCT_4:15
    .= s +*(PR +* (IP +* DP))+* IS +* SD +* PP by A32,A33,FUNCT_4:36
    .= s +*(PR +* IP +* DP) +* IS +* SD +* PP by FUNCT_4:15
    .= s +* Relocated(p,k) +* IS +* SD +* PP by A42,A32,COMPOS_1:14,FUNCT_4:36,
RE
    .= DecIC(Comput(P+*Reloc(ProgramPart p,k),s+*Relocated(p,k),0),k)
        +* s|(dom Reloc(ProgramPart p,k))
     +* ProgramPart p by EXTPRO_1:3;
  then
A43: Z[0];
  thus for i being Element of NAT holds Z[i] from NAT_1:sch 1 (A43, A9);
end;

theorem Th11:
 S is CurIns-recognized implies
  for p being FinPartState of S st IC S in dom p for k being
  Element of NAT holds p is autonomic iff Relocated (p,k) is autonomic
proof assume
A1: S is CurIns-recognized;
  let p be FinPartState of S such that
A2: IC S in dom p;
  let k be Element of NAT;
RE: Reloc(ProgramPart p,k) = ProgramPart Relocated(p,k) by COMPOS_1:116;
  hereby
    assume
A4: p is autonomic;
    thus Relocated (p,k) is autonomic
    proof
     let P,Q be (the Instructions of S)-valued ManySortedSet of NAT such that
A5:  ProgramPart Relocated(p,k) c= P and
A6:  ProgramPart Relocated(p,k) c= Q;
      let s1,s2 be State of S such that
A7:   Relocated (p,k) c= s1 and
A8:   Relocated (p,k) c= s2;
      let i be Element of NAT;
A9:   Comput(P,s1,i) =
       IncIC(Comput(P+*ProgramPart p,s1+*p,i),k)
        +* s1|dom ProgramPart p +* Reloc(ProgramPart p,k)
         by A2,A4,A7,Th9,A1,A5,RE;
      dom ProgramPart p c= the carrier of S by RELAT_1:def 18;
      then dom ProgramPart p c= dom s2 by PARTFUN1:def 4;
      then
A10:   dom(s2|dom ProgramPart p) = dom ProgramPart p by RELAT_1:91;
      dom ProgramPart p c= the carrier of S by RELAT_1:def 18;
      then dom ProgramPart p c= dom s1 by PARTFUN1:def 4;
      then
A11:   dom(s1|dom ProgramPart p) = dom ProgramPart p by RELAT_1:91;
A12:   dom (Start-At ((IC Comput(Q+*ProgramPart p,s2+*p,i))+k,S)) = {IC S}
 by FUNCOP_1:19;
      then
A13:   dom(DataPart p) misses dom (Start-At (IC Comput(Q+*ProgramPart p,s2+*p,
i) +k,S))
      by COMPOS_1:13;
A14:  dom (Start-At ((IC Comput(P+*ProgramPart p,s1+*p,i))+k,S)) = {IC S}
 by FUNCOP_1:19;
      then
A15:  dom(DataPart p) misses dom (Start-At (IC Comput(P+*ProgramPart p,s1+*p,
i) +k,S))
      by COMPOS_1:13;
A16:  Comput(Q,s2,i) =
       IncIC(Comput(Q+*ProgramPart p,s2+*p,i),k)
 +* s2|dom ProgramPart p
+* Reloc(ProgramPart p,k)
 by A2,A4,A8,Th9,A1,A6,RE;
A17:   ProgramPart p c= P+*ProgramPart p & ProgramPart p c= Q+*ProgramPart p
              by FUNCT_4:26;
      p c= s1 +* p & p c= s2 +* p by FUNCT_4:26;
      then
A18:  Comput(P+*ProgramPart p,s1+*p,i)|dom NPP p  = Comput(Q+*ProgramPart p,
s2+*p,i) |dom NPP p  by A4,EXTPRO_1:def 9,A17;
A19:  DataPart p c= NPP p by COMPOS_1:169;
A20:  dom(DataPart p) misses dom(Reloc(ProgramPart p,k))by COMPOS_1:15,RE;
      then
A21:  Comput(P,s1,i)|dom (DataPart p)
 = ( Comput(P+*ProgramPart p,s1+*p,i) +*
Start-At (IC Comput(P+*ProgramPart p,s1+*p,i) +k,S) +*
 s1|dom ProgramPart p) | dom(DataPart
      p) by A9,FUNCT_4:76
        .= ( Comput(P+*ProgramPart p,s1+*p,i) +* Start-At (IC Comput(
P+*ProgramPart p,s1+*p,i) +k,S))
      | dom(DataPart p) by A11,COMPOS_1:15,FUNCT_4:76
        .= ( Comput(P+*ProgramPart p,s1+*p,i)) | dom (DataPart p) by A15,
FUNCT_4:76
        .= ( Comput(Q+*ProgramPart p,s2+*p,i)) | dom (DataPart p) by A18,
RELAT_1:188,A19,RELAT_1:25
        .= ( Comput(Q+*ProgramPart p,s2+*p,i) +* Start-At (IC Comput(
Q+*ProgramPart p,s2+*p,i) +k,S))
      | dom(DataPart p) by A13,FUNCT_4:76
        .= ( Comput(Q+*ProgramPart p,s2+*p,i) +* Start-At (IC Comput(
Q+*ProgramPart p,s2+*p,i) +k,S)
      +* s2|dom ProgramPart p) | dom(DataPart p) by A10,COMPOS_1:15,FUNCT_4:76
        .= Comput(Q,s2,i)|dom (DataPart p)
        by A16,A20,FUNCT_4:76;
      IC S in dom NPP p by A2,COMPOS_1:179;
      then
A22:  {IC S} c= dom NPP p by ZFMISC_1:37;
A23:  Start-At (IC Comput(P+*ProgramPart p,s1+*p,i),S)
      = Comput(P+*ProgramPart p,s1+*p,i)|{IC S} by COMPOS_1:10
        .= Comput(Q+*ProgramPart p,s2+*p,i)|{IC S}
        by A18,A22,RELAT_1:188
        .= Start-At (IC Comput(Q+*ProgramPart p,s2+*p,i),S) by COMPOS_1:10;
A24:  dom (Start-At((IC p)+k,S)) = {IC S} by FUNCOP_1:19;
      then
A25:  dom (Start-At ((IC p) +k,S)) misses dom Reloc(ProgramPart p,k)
           by COMPOS_1:14,RE;
      then
A26:  Comput(P,s1,i)|dom (Start-At((IC p)+k,S))
     = ( Comput(P+*ProgramPart p,s1+*p,i)
        +* Start-At (IC Comput(P+*ProgramPart p,s1+*p,i) +k,S)
         +* s1|dom ProgramPart p) |dom (Start-At((IC p)+k,S))
          by A9,FUNCT_4:76
        .= ( Comput(P+*ProgramPart p,s1+*p,i) +* Start-At (IC Comput(
P+*ProgramPart p,s1+*p,i) +k,S))
      |dom (Start-At((IC p)+k,S)) by A24,A11,COMPOS_1:14,FUNCT_4:76
        .= Start-At (IC Comput(P+*ProgramPart p,s1+*p,i) +k,S) by A24,A14,
FUNCT_4:24
        .= Start-At (IC Comput(Q+*ProgramPart p,s2+*p,i) +k,S) by A23,
COMPOS_1:43
        .= ( Comput(Q+*ProgramPart p,s2+*p,i) +* Start-At (IC Comput(
Q+*ProgramPart p,s2+*p,i) +k,S))
      |dom (Start-At((IC p)+k,S)) by A24,A12,FUNCT_4:24
        .= ( Comput(Q+*ProgramPart p,s2+*p,i) +* Start-At (IC Comput(
Q+*ProgramPart p,s2+*p,i) +k,S)
+* s2|dom ProgramPart p) |dom (Start-At((IC p)+k,S)) by A24,A10,COMPOS_1:14
,FUNCT_4:76
        .= Comput(Q,s2,i)|dom (Start-At((IC p)+k,S))
         by A16,A25,FUNCT_4:76;
A27:  dom Start-At((IC p)+k,S) = {IC S} by FUNCOP_1:19;
A28:  dom NPP p = {IC S} \/ dom DataPart p by A2,COMPOS_1:70;
A29: Comput(P,s1,i)|dom NPP p
       = Comput(P,s1,i)|{IC S}
          \/ Comput(P,s1,i)|dom DataPart p by A28,RELAT_1:107
       .= Comput(Q,s2,i)|dom NPP p
       by A28,A27,A21,RELAT_1:107,A26;
A30:  dom IncIC(NPP p,k)
      = dom NPP p \/ dom Start-At((IC NPP p)+k,S) by FUNCT_4:def 1
     .= dom NPP p \/ dom Start-At((IC p)+k,S) by A2,COMPOS_1:72;
A31: Comput(P,s1,i)|dom IncIC(NPP p,k)
     = Comput(P,s1,i)|dom NPP p
        \/ Comput(P,s1,i)|dom Start-At((IC p)+k,S) by A30,RELAT_1:107
    .= Comput(Q,s2,i)|dom IncIC(NPP p,k)
         by A30,RELAT_1:107,A26,A29;
     thus Comput(P,s1,i)|dom NPP Relocated (p,k)
        = Comput(P,s1,i)|dom IncIC(NPP p,k) by COMPOS_1:180
       .= Comput(Q,s2,i)|dom NPP Relocated (p,k) by A31,COMPOS_1:180;

    end;
  end;
  assume
A32: Relocated (p,k) is autonomic;
    DataPart (Relocated(p,k)) c= NPP Relocated(p,k) by COMPOS_1:169;
    then DataPart p c= NPP Relocated(p,k) by COMPOS_1:115;
    then
A33: dom DataPart p c= dom NPP Relocated(p,k) by GRFUNC_1:8;
    let P,Q be (the Instructions of S)-valued ManySortedSet of NAT such that
A34: ProgramPart p c= P and
A35: ProgramPart p c= Q;
A36: Reloc(ProgramPart p,k) c= P +* Reloc(ProgramPart p,k) &
    Reloc(ProgramPart p,k) c= Q +* Reloc(ProgramPart p,k)
         by FUNCT_4:26;
    let s1,s2 be State of S such that
A37: p c= s1 and
A38: p c= s2;
    let i be Element of NAT;
A39: Comput(Q,s2,i) = DecIC(Comput(Q +* Reloc(ProgramPart p,k),s2+*
Relocated(p,k),i),k) +*
 s2|dom
Reloc(ProgramPart p,k)
 +*
    ProgramPart (p) by A2,A32,A38,Th10,A1,A35;
    dom Reloc(ProgramPart p,k) c= the carrier of S by RELAT_1:def 18;
    then dom Reloc(ProgramPart p,k) c= dom s2 by PARTFUN1:def 4;
    then
A40: dom(s2|dom Reloc(ProgramPart p,k)) =
 dom Reloc(ProgramPart p,k) by RELAT_1:91;
    dom Reloc(ProgramPart p,k) c= the carrier of S by RELAT_1:def 18;
    then dom Reloc(ProgramPart p,k) c= dom s1 by PARTFUN1:def 4;
    then
A41: dom(s1|dom Reloc(ProgramPart p,k)) = dom Reloc(ProgramPart p,k)
      by RELAT_1:91;
A42: Comput(P,s1,i)
 = DecIC(Comput(P +* Reloc(ProgramPart p,k),s1+*Relocated(p,k),i),k) +*
s1|dom
Reloc(ProgramPart p,k)
 +*
    ProgramPart (p) by A2,A32,A37,Th10,A1,A34;
    Relocated (p,k) c= s1 +* Relocated (p,k) & Relocated (p,k) c= s2 +*
    Relocated (p,k) by FUNCT_4:26;
    then
A43: Comput(P +* Reloc(ProgramPart p,k),s1+*Relocated(p,k),i)|dom
NPP Relocated (p,k)
     = Comput(Q +* Reloc(ProgramPart p,k),s2+*Relocated(p,k),i)
|dom NPP Relocated (p,k) by A32,EXTPRO_1:def 9,A36,RE;
A44: dom (Start-At ((IC Comput(Q +* Reloc(ProgramPart p,k),s2+*Relocated(p,
k),i)) -'k,S)) = {IC S} by FUNCOP_1:19;
    then
A45: dom(DataPart p) misses
 dom(Start-At (IC Comput(Q+*Reloc(ProgramPart p,k),s2+*Relocated(p,k
    ),i) -'k,S)) by COMPOS_1:13;
A46: dom (Start-At ((IC Comput(P +* Reloc(ProgramPart p,k),s1+*Relocated(p,
k),i)) -'k,S)) = {IC
    S} by FUNCOP_1:19;
    then
A47: dom(DataPart p) misses
 dom(Start-At (IC Comput(P+*Reloc(ProgramPart p,k),s1+*Relocated(p,k
    ),i) -'k,S)) by COMPOS_1:13;
A48: dom DataPart p misses dom ProgramPart p by COMPOS_1:15;
    then
A49: Comput(P,s1,i)|dom (DataPart p)
 = ( DecIC(Comput(P+*Reloc(ProgramPart p,k),s1+*Relocated(p,k)
    ,i),k)
 +* s1|dom
    Reloc(ProgramPart p,k)) | dom(DataPart p) by A42,FUNCT_4:76
      .= ( DecIC(Comput(P +* Reloc(ProgramPart p,k),s1+*Relocated(p,k),i),k)
    ) | dom(DataPart p) by A41,COMPOS_1:15,
FUNCT_4:76,RE
      .= ( Comput(P +* Reloc(ProgramPart p,k),s1+*Relocated(p,k),i)) | dom
(DataPart p) by A47,FUNCT_4:76
      .= ( Comput(Q +* Reloc(ProgramPart p,k),s2+*Relocated(p,k),i)) | dom
(DataPart p) by A43,A33,RELAT_1:188
      .= ( DecIC(Comput(Q +* Reloc(ProgramPart p,k),s2+*Relocated(p,k),i),k)
    ) | dom(DataPart p) by A45,FUNCT_4:76
      .= ( DecIC(Comput(Q +* Reloc(ProgramPart p,k),s2+*Relocated(p,k),i),k)
 +* s2|dom Reloc(ProgramPart p,k)) | dom(DataPart
    p) by A40,COMPOS_1:15,FUNCT_4:76,RE
      .= Comput(Q,s2,i)|dom (DataPart p) by A39,A48,FUNCT_4:76;
    IC S in dom Relocated (p,k) by COMPOS_1:119;
    then IC S in dom NPP Relocated (p,k) by COMPOS_1:179;
    then
A50: {IC S} c= dom NPP Relocated (p,k) by ZFMISC_1:37;
A51: Start-At (IC Comput(P +* Reloc(ProgramPart p,k),s1+*Relocated(p,k),i),
S) = Comput(P+*Reloc(ProgramPart p,k),s1+*
    Relocated(p,k),i)|{IC S} by COMPOS_1:10
      .= Comput(Q +* Reloc(ProgramPart p,k),s2+*Relocated(p,k),i)|{IC S}
by A43,A50,RELAT_1:188
      .= Start-At (IC Comput(Q +* Reloc(ProgramPart p,k),s2+*Relocated(p,k)
,i),S) by COMPOS_1:10;
A52: dom (Start-At(IC p,S)) = {IC S} by FUNCOP_1:19;
    then
A53: dom (Start-At(IC p,S)) misses dom (ProgramPart p) by COMPOS_1:14;
    then
A54: Comput(P,s1,i)|dom (Start-At(IC p,S)) = ( DecIC(Comput(
P+*Reloc(ProgramPart p,k),s1+*Relocated
    (p,k),i),k)
     +* s1|dom
    Reloc(ProgramPart p,k)) |dom (Start-At(IC p,S)) by A42,FUNCT_4:76
      .= ( DecIC(Comput(P +* Reloc(ProgramPart p,k),s1+*Relocated(p,k),i),k)
) |dom (Start-At(IC p,S)) by A52,A41,COMPOS_1:14
,FUNCT_4:76,RE
      .= Start-At (IC Comput(P +* Reloc(ProgramPart p,k),s1+*Relocated(p,k)
,i) -'k,S) by A52,A46,FUNCT_4:24
      .= Start-At (IC Comput(Q +* Reloc(ProgramPart p,k),s2+*Relocated(p,k)
,i) -'k,S)
       by A51,COMPOS_1:44
      .= ( DecIC(Comput(Q +* Reloc(ProgramPart p,k),s2+*Relocated(p,k),i),k)
    ) |dom (Start-At(IC p,S))
     by A52,A44,FUNCT_4:24
      .= ( DecIC(Comput(Q +* Reloc(ProgramPart p,k),s2+*Relocated(p,k),i),k) +*
 s2|dom Reloc(ProgramPart p,k)) |dom (Start-At
    (IC p,S)) by A52,A40,COMPOS_1:14,FUNCT_4:76,RE
      .= Comput(Q,s2,i)|dom (Start-At(IC p,S)) by A39,A53,
FUNCT_4:76;
    thus Comput(P,s1,i)|dom NPP p
     = Comput(P,s1,i)|dom(Start-At(IC p,S) +*
          DataPart p ) by A2,COMPOS_1:181
      .= Comput(P,s1,i)|(dom (Start-At(IC p,S)) \/ dom (DataPart p))
          by FUNCT_4:def 1
      .= Comput(Q,s2,i)|dom (Start-At(IC p,S)) \/
            Comput(Q,s2,i)|dom (DataPart p) by A49,A54,RELAT_1:107
      .= Comput(Q,s2,i)|(dom (Start-At(IC p,S)) \/ dom DataPart p)
           by RELAT_1:107
      .= Comput(Q,s2,i)|dom (Start-At(IC p,S) +* DataPart p) by FUNCT_4:def 1
      .= Comput(Q,s2,i)|dom NPP p by A2,COMPOS_1:181;
end;

definition let N,S;
 attr S is relocable1 means
:Def5: for k being Element of NAT, p being autonomic FinPartState of S,
      s1, s2 being State of S st IC S in dom p & p c= s1 &
       Relocated(p,k) c= s2
  for P1,P2 being (the Instructions of S)-valued ManySortedSet of NAT
   st ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2
  for i being Element of NAT
   holds IncAddr(CurInstr(P1,Comput(P1,s1,i)),k)
       = CurInstr(P2,Comput(P2,s2,i));
 attr S is relocable2 means
:Def6: for k being Element of NAT, p being autonomic FinPartState of S,
      s1, s2 being State of S st IC S in dom p & p c= s1 &
       Relocated(p,k) c= s2
  for P1,P2 being (the Instructions of S)-valued ManySortedSet of NAT
   st ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2
  for i being Element of NAT holds
   Comput(P1,s1,i)|dom DataPart p =
  Comput(P2,s2,i)|dom DataPart Relocated(p,k);
end;

Lm1: for k being Element of NAT, p being autonomic FinPartState of STC N , s1,
s2 being State of STC N st IC STC N in dom p & p c= s1 & Relocated (p,k) c= s2
for P1,P2 being (the Instructions of STC N)-valued ManySortedSet of NAT
 st ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2
for i being Element of NAT holds
 IC Comput(P1,s1,i) + k = IC Comput(P2,s2,i) &
IncAddr(CurInstr(P1,Comput(P1,s1,i)), k)
 = CurInstr(P2,Comput(P2,s2,i)) &
Comput(P1,s1,i)|(dom DataPart p qua set)
 = Comput(P2,s2,i)|(dom DataPart (Relocated(p,k)) qua set) &
DataPart Comput(P1,s1 +* DataPart s2,i) =
DataPart Comput(P2,s2,i)
proof
  let k be Element of NAT, p be autonomic FinPartState of STC N, s1,s2 be State
  of STC N such that
A1: IC STC N in dom p and
A2: p c= s1 and
A3: Relocated (p,k) c= s2;
  let P1,P2 being (the Instructions of STC N)-valued ManySortedSet of NAT
  such that
A4: ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2;
A6: Reloc(ProgramPart p,k) c= P2 by A4;
  set s3 = s1 +* DataPart s2;
  defpred Z[Element of NAT] means
   IC Comput(P1,s1,$1) + k = IC Comput(P2,s2,$1) &
 IncAddr(CurInstr(P1,Comput(P1,s1,$1)), k)
 = CurInstr(P2,Comput(P2,s2,$1)) &
  Comput(P1,s1,$1)|(dom DataPart p qua set)
   = Comput(P2,s2,$1)|(dom DataPart (Relocated (p,k))qua set) &
   DataPart Comput(P1,s3,$1)
    = DataPart Comput(P2,s2,$1);
A7: p is non NAT-defined by A1,COMPOS_1:19;
A8: for i be Element of NAT st Z[i] holds Z[i+1]
  proof
    set DPp = DataPart p;
    let i be Element of NAT such that
A9: IC Comput(P1,s1,i) + k = IC Comput(P2,s2,i) and
A10: IncAddr (CurInstr(P1,Comput(P1,s1,i)), k)
    = CurInstr(P2,Comput(P2,s2,i)) and
 Comput(P1,s1,i)|(dom DataPart p qua set)
    = Comput(P2,s2,i)|(dom DataPart (Relocated (p,k))qua set) and
 DataPart Comput(P1,s3,i)
    = DataPart Comput(P2,s2,i);
    set Cs2i1 = Comput(P2,s2,i+1);
    set Cs3i = Comput(P1,s3,i);
    set Cs2i = Comput(P2,s2,i);
    set Cs3i1 = Comput(P1,s3,i+1);
    set Cs1i1 = Comput(P1,s1,i+1);
    set Cs1i = Comput(P1,s1,i);
A11: now
      reconsider loc = IC Cs1i1 as Element of NAT;
      assume
A12:  IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,i+1);
      reconsider kk = loc as Element of NAT;
A13:  loc in dom ProgramPart p by A2,A7,Def4,A4;
A14:  loc + k in dom Reloc(ProgramPart p, k) by A13,COMPOS_1:158;
A15: dom P2 = NAT by PARTFUN1:def 4;
      dom P1 = NAT by PARTFUN1:def 4;
      then CurInstr(P1, Cs1i1) = P1.loc by PARTFUN1:def 8
        .= (ProgramPart p).loc by A13,GRFUNC_1:8,A4;

      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = Reloc(ProgramPart p,k).(loc+k) by A13,COMPOS_1:122
      .= P2.IC Comput(P2,s2,i+1) by A12,A14,A6,GRFUNC_1:8
      .= CurInstr(P2,Comput(P2,s2,i+1)) by A15,PARTFUN1:def 8;
    end;
    set I = CurInstr(P1, Cs1i);
A16: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:4
      .= Exec (CurInstr(P2, Cs2i), Cs2i);
    reconsider j = IC Cs1i as Element of NAT;
A17: Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:4
      .= Exec (CurInstr(P1, Cs1i), Cs1i);
A18:  the Instructions of STC N = {[0,0,0],[1,0,0]} by AMISTD_1:def 11;
    per cases by A18,TARSKI:def 2;
    suppose
      I = [0,0,0];
      then
A19:  I = halt STC N by AMISTD_1:def 11;
      thus IC Comput(P1,s1,i+1) + k = IC Cs1i + k
       by A17,A19,EXTPRO_1:def 3
        .= IC Comput(P2,s2,i+1) by A9,A16,A19,A10,EXTPRO_1:def 3;
      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1)) by A11;
      thus Comput(P1,s1,i+1)|(dom DataPart p qua set)
       = Comput(P2,s2,i+1)|(dom DataPart (Relocated (p,k))qua set)
;
      thus DataPart Cs3i1 = DataPart Cs2i1;
    end;
    suppose
      I = [1,0,0];
      then
A20:    InsCode I = 1 by RECDEF_2:def 1;
      then
A21:   Exec(I,Cs2i) = IncIC(Cs2i,1) by AMISTD_1:59;
      thus IC Comput(P1,s1,i+1) + k = succ IC Cs1i + k
         by A17,AMISTD_1:38,A20
        .= IC Exec(I,Cs2i) by A21,COMPOS_1:54,A9
        .= IC Comput(P2,s2,i+1) by A16,A10,COMPOS_1:92;
      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1)) by A11;
      thus Comput(P1,s1,i+1)|(dom (DataPart p) qua set)
      = Comput(P2,s2,i+1)|(dom (DataPart (Relocated (p,k)))
              qua set);

      thus DataPart Cs3i1 = DataPart Cs2i1;
    end;
  end;
A22: IC STC N in dom Relocated(p,k) by COMPOS_1:119;
  now
    thus IC Comput(P1,s1,0) + k = IC s1 + k by EXTPRO_1:3
      .= IC p + k by A1,A2,GRFUNC_1:8
      .= IC Relocated(p,k) by A1,COMPOS_1:120
      .= IC s2 by A3,A22,GRFUNC_1:8
      .= IC Comput(P2,s2,0) by EXTPRO_1:3;
    reconsider loc = IC p as Element of NAT;
A23: IC p = IC s1 by A1,A2,GRFUNC_1:8;
    then IC p = IC Comput(P1,s1,0) by EXTPRO_1:3;
    then
A24: loc in dom ProgramPart p by A2,A7,Def4,A4;
A25: (IC p) + k in dom Reloc(ProgramPart p,k) by A24,COMPOS_1:158;
A26: IC STC N in dom Relocated (p, k) by COMPOS_1:119;
A27: (ProgramPart p).IC p = P1.IC s1 by A23,A24,GRFUNC_1:8,A4;
    dom P2 = NAT by PARTFUN1:def 4;
    then
A28:  CurInstr(P2,Comput(P2,s2,0))
      = P2.IC Comput(P2,s2,0) by PARTFUN1:def 8
     .= P2.IC s2 by EXTPRO_1:3
     .= P2.(IC Relocated (p, k)) by A3,A26,GRFUNC_1:8
      .= P2.((IC p) +k) by A1,COMPOS_1:120
      .= (Reloc(ProgramPart p, k)).((IC p) +k) by A25,GRFUNC_1:8,A4;
A29:  dom P1 = NAT by PARTFUN1:def 4;
     CurInstr(P1,Comput(P1,s1,0))
       = CurInstr(P1,s1) by EXTPRO_1:3
      .= P1.IC s1 by A29,PARTFUN1:def 8;
    hence
    IncAddr(CurInstr(P1,Comput(P1,s1,0)), k)
     = CurInstr(P2,Comput(P2,s2,0))
      by A28,A24,A27,COMPOS_1:122;
    thus Comput(P1,s1,0)|(dom (DataPart p) qua set)
       = Comput(P2,s2,0)|(dom (DataPart (Relocated (p,k))) qua set);
    thus DataPart Comput(P1,s3,0)
      = DataPart Comput(P2,s2,0);
  end;
  then
A30: Z[0];
  thus for i being Element of NAT holds Z[i] from NAT_1:sch 1(A30,A8);
end;

registration let N;
 cluster STC N -> relocable1;
 coherence
  proof
   thus for k being Element of NAT, p being autonomic FinPartState of STC N,
      s1, s2 being State of STC N st IC STC N in dom p & p c= s1 &
       Relocated(p,k) c= s2
  for P1,P2 being (the Instructions of STC N)-valued ManySortedSet of NAT
   st ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2
  for i being Element of NAT
   holds IncAddr(CurInstr(P1,Comput(P1,s1,i)),k)
       = CurInstr(P2,Comput(P2,s2,i)) by Lm1;
  end;
end;

registration let N be with_non-empty_elements non empty set;
 cluster relocable1 (relocable IC-recognized proper-halt
  (regular homogeneous J/A-independent
    Exec-preserving halting realistic     steady-programmed
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N))));
 existence
  proof
   take STC N;
   thus thesis;
  end;
end;

reserve S for relocable1 (relocable IC-recognized proper-halt
    (regular homogeneous J/A-independent
    Exec-preserving
     halting realistic  steady-programmed
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N))));

theorem Th12:
  S is relocable1 proper-halt implies
  for p being autonomic FinPartState of S , k being Element of
  NAT st IC S in dom p holds p is halting iff Relocated (p,k) is halting
proof assume
 S is relocable1 proper-halt;
  let p be autonomic FinPartState of S , k be Element of NAT;
  assume
A1: IC S in dom p;
RE: Reloc(ProgramPart p,k) = ProgramPart Relocated(p,k) by COMPOS_1:116;
  hereby
    assume
A3: p is halting;
    thus Relocated (p,k) is halting
    proof
      let t be State of S;
      assume
A4:   Relocated(p,k) c= t;
      let P be (the Instructions of S)-valued ManySortedSet of NAT such that
A5:   ProgramPart Relocated(p,k) c= P;
      reconsider Q = P +* ProgramPart p
       as (the Instructions of S)-valued ManySortedSet of NAT;
      set s = t +* p;
A6:   ProgramPart p c= Q by FUNCT_4:26;
A7:   p c= t +* p by FUNCT_4:26;
      then Q halts_on s by A3,EXTPRO_1:def 10,A6;
      then consider u being Element of NAT such that
A8:   CurInstr(Q,Comput(Q,s,u))
 = halt S by EXTPRO_1:30;
      take u;
     dom P = NAT by PARTFUN1:def 4;
    hence IC Comput(P,t,u) in dom P;
      CurInstr(P,Comput(P,t,u))
       = IncAddr(halt S, k) by A1,A4,A8,Def5,A7,A5,A6,RE
        .= halt S by COMPOS_1:93;
      hence thesis;
    end;
  end;
  assume
A9: Relocated (p,k) is halting;
  let t be State of S;
  assume
A10: p c= t;
  let P be (the Instructions of S)-valued ManySortedSet of NAT such that
A11: ProgramPart p c= P;
  reconsider Q = P +* Reloc(ProgramPart p, k)
   as (the Instructions of S)-valued ManySortedSet of NAT;
  set s = t +* Relocated (p,k);
A12: Reloc(ProgramPart p,k) c= Q by FUNCT_4:26;
A13: Relocated (p,k) c= t +* Relocated (p,k) by FUNCT_4:26;
  then Q halts_on s by A9,EXTPRO_1:def 10,A12,RE;
  then consider u being Element of NAT such that
A14: CurInstr(Q,Comput(Q,s,u))
 = halt S by EXTPRO_1:30;
  take u;
   dom P = NAT by PARTFUN1:def 4;
  hence IC Comput(P,t,u) in dom P;
  IncAddr(CurInstr(P,Comput(P,t,u)), k)
   = halt S by A1,A10,A14,Def5,A13,A11,A12
  .= IncAddr(halt S,k) by COMPOS_1:93;
 hence CurInstr(P,Comput(P,t,u)) = halt S by COMPOS_1:95;
end;

theorem Th13:
 S is relocable1 relocable2 CurIns-recognized implies
  for p being halting autonomic non program-free FinPartState of S
   st IC S in dom p
  for k being Element of NAT holds DataPart(Result(ProgramPart(p),p)) =
   DataPart Result(Reloc(ProgramPart p,k),Relocated(p,k))
proof assume
A1: S is relocable1 relocable2 CurIns-recognized;
  let p be halting autonomic non program-free FinPartState of S such that
A2: IC S in dom p;
  let k be Element of NAT;
RE: Reloc(ProgramPart p,k) = ProgramPart Relocated(p,k) by COMPOS_1:116;
  consider s being State of S such that
A4: p c= s by PBOOLE:156;
A5: ProgramPart p c= ProgramPart s by A4,RELAT_1:105;
A6: Relocated(p,k) is halting autonomic by A2,Th12,Th11,A1;
  Relocated(p,k) +* Reloc(ProgramPart p,k) = Relocated(p,k) by FUNCT_4:99;
  then
A7: Relocated(p,k) is Autonomy of Reloc(ProgramPart p,k) by A6,EXTPRO_1:def 11;
  ProgramPart s halts_on s by A4,EXTPRO_1:def 10,A5;
  then consider j1 being Element of NAT such that
A8: Result(ProgramPart(s),s) = Comput(ProgramPart(s),s,j1) and
A9: CurInstr(ProgramPart s, Result(ProgramPart(s),s)) =
halt S by EXTPRO_1:def 8;
  consider t being State of S such that
A10: Relocated(p,k) c= t by PBOOLE:156;
A11: Reloc(ProgramPart p,k) c= ProgramPart t by A10,RELAT_1:105,RE;
  (ProgramPart t).(IC Comput(ProgramPart(t),t,j1))
   = t.(IC Comput(ProgramPart(t),t,j1)) by COMPOS_1:2
  .= CurInstr(ProgramPart(t),Comput(ProgramPart(t),t,j1)) by COMPOS_1:38
    .= IncAddr(CurInstr(ProgramPart(s),Comput(ProgramPart(s),s,j1)), k)
     by A2,A4,A10,Def5,A5,A11
    .= halt S by A8,A9,COMPOS_1:93;
  then
A12: Result(ProgramPart(t),t) = Comput(ProgramPart(t),t,j1) by EXTPRO_1:8;
A13: Comput(ProgramPart(t),t,j1) | dom (DataPart Relocated(p,k))
 = Comput(ProgramPart(s),s,j1) |
  dom (DataPart p) by A2,A4,A10,A1,Def6,A11,A5;
   p +* ProgramPart p = p by FUNCT_4:80;
   then p is Autonomy of ProgramPart(p) by EXTPRO_1:def 11;
  hence DataPart(Result(ProgramPart(p),p))
     = DataPart((Result(ProgramPart(s),s)) | dom NPP p)
        by A4,EXTPRO_1:def 12
    .= (Result(ProgramPart(s),s)) | (dom NPP p /\ Data-Locations S)
    by RELAT_1:100
    .= (Result(ProgramPart(s),s)) | dom (DataPart p) by COMPOS_1:182
    .= (Result(ProgramPart(t),t))|(dom NPP Relocated(p,k) /\ Data-Locations S)
    by A8,A12,A13,COMPOS_1:182
    .= ((Result(ProgramPart(t),t)) | dom NPP Relocated(p,k))|Data-Locations S
           by RELAT_1:100
    .= DataPart Result(Reloc(ProgramPart p,k),Relocated(p,k))
       by A10,EXTPRO_1:def 12,A7,RE;
end;

registration let N,S;
  let l be Element of NAT;
  let p be l-started autonomic halting FinPartState of S,
    k be Element of NAT;
  cluster Relocated(p,k) -> halting;
  coherence
   proof
     IC S in dom p by COMPOS_1:def 16;
    hence thesis by Th12;
   end;
end;

theorem
 S is CurIns-recognized relocable2 implies
  for F being PartFunc of FinPartSt S, FinPartSt S,
      l being Element of NAT,
      p being autonomic halting non program-free
       l-started FinPartState of S
        st IC S in dom p & F is data-only
  for k being Element of
   NAT holds ProgramPart p, p computes F
    iff Reloc(ProgramPart p,k), Relocated(p,k) computes F
proof assume
A1: S is CurIns-recognized relocable2;
  let F be PartFunc of FinPartSt S ,FinPartSt S ,
      l be Element of NAT,
      p be autonomic halting non program-free
         l-started FinPartState of S
  such that
A2: IC S in dom p and
A3: F is data-only;
  let k be Element of NAT;
RE: Reloc(ProgramPart p,k) = ProgramPart Relocated(p,k) by COMPOS_1:116;
  hereby
    assume
A5: ProgramPart p, p computes F;
    thus Reloc(ProgramPart p,k), Relocated(p,k) computes F
    proof
      let x be set;
      assume
A6:   x in dom F;
      then consider d1 being FinPartState of S such that
A7:   x = d1 and
A8:   p +* d1 is Autonomy of ProgramPart p and
A9:   F.d1 c= Result(ProgramPart p,p +* d1) by A5,EXTPRO_1:def 13;
      dom F c= FinPartSt S by RELAT_1:def 18;
      then reconsider d = x as FinPartState of S by A6,COMPOS_1:25;
      reconsider d as data-only FinPartState of S by A3,A6,COMPOS_1:def 24;
      dom(p +* d) = dom p \/ dom d by FUNCT_4:def 1;
      then
A10:   IC S in dom(p +* d) by A2,XBOOLE_0:def 3;
      dom d misses NAT by COMPOS_1:40;
      then
A11:    ProgramPart(p +* d)= ProgramPart p by FUNCT_4:76;
A12:   dom d misses NAT by COMPOS_1:40;
A13:   dom d misses dom Reloc(ProgramPart p,k) by A12,XBOOLE_1:63,RELAT_1:87,
RE;
A14:  Relocated(p,k) +* d +* Reloc(ProgramPart p,k)
           = Relocated(p,k) +* (d +* Reloc(ProgramPart p,k)) by FUNCT_4:15
          .= Relocated(p,k) +* (Reloc(ProgramPart p,k) +* d)
                     by A13,FUNCT_4:36
          .= Relocated(p,k) +* Reloc(ProgramPart p,k) +* d by FUNCT_4:15
          .= Relocated(p,k)+*d by FUNCT_4:80,RE;
   dom d misses NAT by COMPOS_1:40;
      then
A15:   dom d misses dom ProgramPart p by RELAT_1:87,XBOOLE_1:63;
A16: p +* d +* ProgramPart p
           = p +* (d +* ProgramPart p) by FUNCT_4:15
          .= p +* (ProgramPart p +* d) by A15,FUNCT_4:36
          .= p +* ProgramPart p +* d by FUNCT_4:15
          .= p+*d by FUNCT_4:80;
     then
A17:  p+*d is autonomic by A7,A8,EXTPRO_1:def 11;
    then
A18:   Relocated((p +* d) ,k) is autonomic
        by A10,Th11,A1;
A19:    p+*d is halting by A7,A8,EXTPRO_1:def 11,A16;
    then
A20:   DataPart(Result(ProgramPart p,p +* d1))
     = DataPart Result(Reloc(ProgramPart p,k),Relocated(p +* d,k))
        by A7,Th13,A10,A11,A17,A1
    .= DataPart Result(Reloc(ProgramPart p,k),Relocated(p,k) +* d)
            by COMPOS_1:124;
      reconsider Fs1 = F.d1 as FinPartState of S by A9;
      take d;
      thus x=d;
      Relocated(p,k) +* d = Relocated((p +* d) ,k) by COMPOS_1:124;
      hence Relocated(p,k) +* d
       is Autonomy of Reloc(ProgramPart p,k)
            by A17,A19,A18,A14,EXTPRO_1:def 11;
A21:  Fs1 is data-only by A3,A6,A7,COMPOS_1:def 24;
       then F.d1 c=
        DataPart Result(Reloc(ProgramPart p,k),Relocated(p,k) +* d)
      by A20,A9,COMPOS_1:17;
      hence F.d c= Result(Reloc(ProgramPart p,k),Relocated(p,k) +* d)
      by A7,A21,COMPOS_1:17;
    end;
  end;
  assume
A22: Reloc(ProgramPart p,k), Relocated(p,k) computes F;
  let x be set;
  assume
A23: x in dom F;
  then consider d1 being FinPartState of S such that
A24: x = d1 and
A25: Relocated(p,k) +* d1 is Autonomy of Reloc(ProgramPart p,k)
      and
A26: F.d1 c= Result(Reloc(ProgramPart p,k),Relocated (p,k) +* d1)
by A22,EXTPRO_1:def 13;
  dom F c= FinPartSt S by RELAT_1:def 18;
  then reconsider d = x as FinPartState of S by A23,COMPOS_1:25;
  reconsider d as data-only FinPartState of S by A3,A23,COMPOS_1:def 24;
  dom(p +* d) = dom p \/ dom d by FUNCT_4:def 1;
  then
A27: IC S in dom(p +* d) by A2,XBOOLE_0:def 3;
      dom d misses NAT by COMPOS_1:40;
      then
A28:    ProgramPart(p +* d)= ProgramPart p by FUNCT_4:76;
A29:   dom d misses NAT by COMPOS_1:40;
A30:   dom d misses dom Reloc(ProgramPart p,k) by A29,XBOOLE_1:63,RELAT_1:87,
RE;
A31:  Relocated(p,k) +* d +* Reloc(ProgramPart p,k)
           = Relocated(p,k) +* (d +* Reloc(ProgramPart p,k)) by FUNCT_4:15
          .= Relocated(p,k) +* (Reloc(ProgramPart p,k) +* d)
                     by A30,FUNCT_4:36
          .= Relocated(p,k) +* Reloc(ProgramPart p,k) +* d by FUNCT_4:15
          .= Relocated(p,k)+*d by FUNCT_4:80,RE;
A32: Relocated(p,k) +* d = Relocated((p +* d),k) by COMPOS_1:124;
 Relocated(p+*d,k) is autonomic by A24,A25,EXTPRO_1:def 11,A31,A32;
  then
A33: p +* d is autonomic by A27,Th11,A1;
  Relocated(p+*d,k) is halting by A24,A25,EXTPRO_1:def 11,A31,A32;
  then
A34: p +* d is halting by A27,Th12,A33;
A35: DataPart Result(Reloc(ProgramPart p,k),Relocated(p,k) +* d1)
   = DataPart Result(Reloc(ProgramPart p,k),Relocated(p +* d,k))
            by A24,COMPOS_1:124
  .= DataPart(Result(ProgramPart p,p +* d)) by A27,A33,A34,Th13,A28,A1;
  take d;
  thus x=d;
   dom d misses NAT by COMPOS_1:40;
      then
A36:   dom d misses dom ProgramPart p by RELAT_1:87,XBOOLE_1:63;
 p +* d +* ProgramPart p
           = p +* (d +* ProgramPart p) by FUNCT_4:15
          .= p +* (ProgramPart p +* d) by A36,FUNCT_4:36
          .= p +* ProgramPart p +* d by FUNCT_4:15
          .= p+*d by FUNCT_4:80;
  hence  p +* d is Autonomy of ProgramPart p by A33,A34,EXTPRO_1:def 11;
  reconsider Fs1 = F.d1 as FinPartState of S by A26;
A37: Fs1 is data-only by A3,A23,A24,COMPOS_1:def 24;
  then F.d1 c= DataPart(Result(Reloc(ProgramPart p,k),Relocated(p,k)
+* d1)) by A26,COMPOS_1:17;
  hence thesis by A24,A37,A35,COMPOS_1:17;
end;

reserve S for
  IC-recognized
    (halting realistic  steady-programmed
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)));

theorem
  S is CurIns-recognized implies
  for p being autonomic FinPartState of S st IC S in dom p holds IC
  p in dom p
proof assume
A1: S is CurIns-recognized;
 let p be autonomic FinPartState of S;
 assume
A2: IC S in dom p;
  not dom p c= NAT by A2,COMPOS_1:def 12;
  then
A3: p is non NAT-defined by RELAT_1:def 18;
  consider s being State of S such that
A4: p c= s by PBOOLE:156;
  set P = (the (the Instructions of S)-valued ManySortedSet of NAT)
         +* ProgramPart p;
A5: ProgramPart p c= P by FUNCT_4:26;
   ProgramPart p c= p by RELAT_1:88;
  then
A6:  dom ProgramPart p c= dom p by RELAT_1:25;
   IC Comput(P,s,0) in dom ProgramPart p by A4,A5,A3,A1,Def4;
  then IC s in dom ProgramPart p by EXTPRO_1:3;
  then IC s in dom p by A6;
 hence  IC p in dom p by A4,A2,GRFUNC_1:8;
end;
