:: Relocable Instructions
::  by Andrzej Trybulec
::
:: Received November 20, 2010
:: Copyright (c) 2010-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, ORDINAL1, SETFAM_1, ARYTM_1, ARYTM_3, CARD_1, SUBSET_1,
      AMI_1, XBOOLE_0, RELAT_1, TARSKI, FUNCOP_1, GLIB_000, GOBOARD5, AMISTD_1,
      UNIALG_1, FUNCT_1, CARD_5, STRUCT_0, VALUED_1, FSM_1, FUNCT_4, TURING_1,
      CIRCUIT2, AMISTD_2, PARTFUN1, SCMNORM, NAT_1, RELOC, PBOOLE, AMISTD_5,
      COMPOS_1, MSUALG_1, FINSET_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, MCART_1, SETFAM_1, MEMBERED,
      RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4, PBOOLE, FINSET_1, CARD_1,
      NUMBERS, XCMPLX_0, XXREAL_0, NAT_1, CARD_3, FINSEQ_1, FUNCOP_1, NAT_D,
      FUNCT_7, VALUED_0, VALUED_1, AFINSQ_1, STRUCT_0, MEMSTR_0, COMPOS_1,
      EXTPRO_1, AMISTD_1, AMISTD_2;
 constructors WELLORD2, REALSET1, NAT_D, AMISTD_1, XXREAL_2, PRE_POLY,
      AFINSQ_1, ORDINAL4, RECDEF_2, VALUED_1, AMISTD_2, PBOOLE, RELSET_1,
      FUNCT_7, FUNCT_4, MEMSTR_0;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1,
      XXREAL_0, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, CARD_3, REALSET1, FUNCT_7,
      STRUCT_0, AMISTD_1, CARD_1, FUNCT_4, XXREAL_2, RELSET_1, GRFUNC_1,
      FUNCT_2, ORDINAL1, AFINSQ_1, VALUED_1, VALUED_0, COMPOS_1, EXTPRO_1,
      XCMPLX_0, REAL_1, PBOOLE, AMISTD_2, MEMSTR_0;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;
 definitions RELAT_1, FUNCT_1, WELLORD2, FUNCT_7, COMPOS_1, EXTPRO_1, AMISTD_1,
      XBOOLE_0, FUNCOP_1, CARD_3, NAT_1, AFINSQ_1, MCART_1, VALUED_1, TARSKI,
      AMISTD_2, STRUCT_0, MEMSTR_0;
 theorems AMISTD_1, FUNCOP_1, FUNCT_1, FUNCT_4, GRFUNC_1, RELAT_1, TARSKI,
      ZFMISC_1, XBOOLE_0, XBOOLE_1, PBOOLE, PARTFUN1, RECDEF_2, VALUED_1,
      COMPOS_1, EXTPRO_1, ORDINAL1, NAT_D, AMISTD_2, RELSET_1, PRE_CIRC,
      MEMSTR_0;
 schemes NAT_1;

begin  :: Relocable instructions

theorem
  for N be with_non-empty_elements non empty set
  for S be regular J/A-independent homogeneous
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N
  for I be Instruction of S st I is jump-only
  for k be Element of NAT holds IncAddr(I,k) is jump-only
  proof
   let N be with_non-empty_elements non empty set;
   let S be regular J/A-independent homogeneous
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N;
   let I be Instruction of S such that
A1:  I is jump-only;
   let k be Element of NAT;
A2:  InsCode I = InsCode IncAddr(I,k) by COMPOS_1:def 17;
    InsCode I is jump-only by A1,AMISTD_1:def 2;
   hence thesis by A2,AMISTD_1:def 2;
  end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
  with_explicit_jumps
  standard-ins IC-Ins-separated halting
  non empty AMI-Struct over N,
  I be IC-relocable Instruction of S, k be Element of NAT;
 cluster IncAddr(I,k) -> IC-relocable;
 coherence
  proof
   let j,i being natural number, s being State of S;
   thus IC Exec(IncAddr(IncAddr(I,k),j),s) + i
    = IC Exec(IncAddr(I,k+j),s) + i by COMPOS_1:15
   .= IC Exec(IncAddr(I,k+j+i),IncIC(s,i)) by AMISTD_2:def 3
   .= IC Exec(IncAddr(I,k+(j+i)),IncIC(s,i))
   .= IC Exec(IncAddr(IncAddr(I,k),j+i),IncIC(s,i)) by COMPOS_1:15;
  end;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N, I be Instruction of S;
  attr I is relocable means
:Def1:  for j,k being natural number, s being State of S holds
    Exec(IncAddr(I,j+k),IncIC(s,k)) =  IncIC(Exec(IncAddr(I,j),s),k);
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N;
 cluster relocable -> IC-relocable for Instruction of S;
 coherence
  proof let I be Instruction of S such that
A1:  I is relocable;
   let j,k be natural number, s be State of S;
    reconsider kk=k as Element of NAT by ORDINAL1:def 12;
   thus IC Exec(IncAddr(I,j),s) + k
     = IC IncIC(Exec(IncAddr(I,j),s),kk) by MEMSTR_0:53
    .= IC  IncIC(Exec(IncAddr(I,j),s),kk)
    .= IC  Exec(IncAddr(I,j+k),IncIC(s,k)) by A1,Def1
    .= IC Exec(IncAddr(I,j+k),IncIC(s,k));
  end;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N;
  attr S is relocable means
:Def2: for I being Instruction of S holds I is relocable;
end;

theorem Th2:
 for N being with_non-empty_elements non empty set,
  I being Instruction of STC N, s be State of STC N,
  k being natural number
 holds Exec(I,IncIC(s,k)) = IncIC(Exec(I,s),k)
proof
 let N being with_non-empty_elements non empty set,
  I being Instruction of STC N, s be State of STC N,
  k being natural number;
 per cases by AMISTD_1:6;
 suppose
A1: InsCode I = 1;
  hence Exec(I,IncIC(s,k)) = IncIC(IncIC(s,k),1) by AMISTD_1:20
     .= IncIC(s,1+k) by MEMSTR_0:57
     .= IncIC(IncIC(s,1),k) by MEMSTR_0:57
     .= IncIC(Exec(I,s),k) by A1,AMISTD_1:20;
 end;
 suppose InsCode I = 0;
   then
A2:  I is halting by AMISTD_1:4;
  hence Exec(I,IncIC(s,k)) = IncIC(s,k) by EXTPRO_1:def 3
     .= IncIC(Exec(I,s),k) by A2,EXTPRO_1:def 3;
 end;
end;

definition
 let N be with_non-empty_elements non empty set;
 let S be halting IC-Ins-separated
   non empty AMI-Struct over N;
 attr S is IC-recognized means
:Def3:
 for q be non halt-free finite
   (the Instructions of S)-valued NAT-defined Function
 for p being q-autonomic
  FinPartState of S st  p is non empty
   holds IC S in dom p;
end;

theorem Th3:
 for N being with_non-empty_elements non empty set
 for S being halting IC-Ins-separated
   non empty AMI-Struct over N
 holds S is IC-recognized iff
  for q be non halt-free finite
   (the Instructions of S)-valued NAT-defined Function
  for p being q-autonomic
  FinPartState of S st DataPart p <> {}
   holds IC S in dom p
proof
 let N be with_non-empty_elements non empty set;
 let S be halting IC-Ins-separated
   non empty AMI-Struct over N;
 thus S is IC-recognized implies
  for q be non halt-free finite
   (the Instructions of S)-valued NAT-defined Function
  for p being q-autonomic FinPartState of S st DataPart p <> {}
   holds IC S in dom p
 proof assume
A1: S is IC-recognized;
  let q be non halt-free finite
   (the Instructions of S)-valued NAT-defined Function;
  let p be q-autonomic FinPartState of S;
  assume DataPart p <> {};
   then  p is non empty;
  hence thesis by A1,Def3;
 end;
 assume
A2: for q be non halt-free finite
    (the Instructions of S)-valued NAT-defined Function
 for p being q-autonomic FinPartState of S st DataPart p <> {}
   holds IC S in dom p;
  let q be non halt-free finite
   (the Instructions of S)-valued NAT-defined Function;
  let p be q-autonomic FinPartState of S;
A3: dom  p c= {IC S} \/ dom DataPart p by MEMSTR_0:32;
  assume
A4:  p is non empty;
  per cases;
  suppose
A5: IC S in dom  p;
   thus IC S in dom p by A5;
  end;
  suppose not IC S in dom  p;
   then {IC S} misses dom  p by ZFMISC_1:50;
   then dom DataPart p is non empty by A4,A3,XBOOLE_1:3,73;
   then DataPart p is non empty;
  hence IC S in dom p by A2;
  end;
end;

registration
 let N be with_non-empty_elements non empty set;
 cluster Data-Locations STC N -> empty;
 coherence
  proof
    the carrier of STC N = {0} by AMISTD_1:def 7
        .= {IC STC N} by AMISTD_1:def 7;
   hence thesis by XBOOLE_1:37;
  end;
end;

registration
 let N be with_non-empty_elements non empty set;
 let p be PartState of STC N;
 cluster DataPart p -> empty;
 coherence;
end;

registration
 let N be with_non-empty_elements non empty set;
 cluster STC N -> IC-recognized relocable;
 coherence
  proof
  for q be non halt-free finite
   (the Instructions of STC N)-valued NAT-defined Function
    for p being q-autonomic
     FinPartState of STC N st DataPart p <> {}
     holds IC STC N in dom p;
   hence STC N is IC-recognized by Th3;
   let I be Instruction of STC N;
   let j,k be natural number, s be State of STC N;
   thus  Exec(IncAddr(I,j+k),IncIC(s,k))
        =  Exec(I,IncIC(s,k)) by COMPOS_1:11
       .=  IncIC(Exec(I,s),k) by Th2
       .=  IncIC(Exec(IncAddr(I,j),s),k) by COMPOS_1:11;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N -> proper-halt;
 coherence
  proof
   thus halt STC N is ins-loc-free;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster relocable IC-recognized proper-halt
   for regular homogeneous J/A-independent standard halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N;
 existence
  proof
   take STC N;
   thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be relocable
   regular homogeneous J/A-independent
    halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N;
 cluster -> relocable for Instruction of S;
 coherence by Def2;
end;

reserve k for natural number;

theorem Th4:
  for N be with_non-empty_elements non empty set
  for S be relocable
   regular homogeneous J/A-independent
    halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N
  for INS being Instruction of S, s being State of S
   holds  Exec(IncAddr(INS,k),IncIC(s,k)) =  IncIC(Exec(INS,s),k)
 proof
  let N be with_non-empty_elements non empty set;
  let S be relocable
   regular homogeneous J/A-independent
    halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N;
  let INS be Instruction of S, s be State of S;
  thus  Exec(IncAddr(INS,k),IncIC(s,k))
          =  Exec(IncAddr(INS,(0 qua Nat)+k),IncIC(s,k))
         .=  IncIC(Exec(IncAddr(INS,0),s),k) by Def1
         .=  IncIC(Exec(INS,s),k) by COMPOS_1:10;
 end;

theorem Th5:
  for N be with_non-empty_elements non empty set
  for S be relocable
   regular homogeneous J/A-independent
    halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N
  for INS being Instruction of S, s being State of S,
      j, k being Element of NAT st IC s = j+k
 holds  Exec(INS, DecIC(s,k)) =  DecIC(Exec(IncAddr(INS, k), s),k)
proof
  let N be with_non-empty_elements non empty set;
  let S be relocable
   regular homogeneous J/A-independent
    halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N;
  let INS be Instruction of S, s be State of S,
      j,k be Element of NAT such that
A1: IC s = j+k;
  set s1 = s +* Start-At(j,S);
B3: IncIC(s1,k) = s +* Start-At(IC s,S) by A1,MEMSTR_0:58
     .= s by MEMSTR_0:31;
 thus  Exec(INS, DecIC(s,k))
    =  Exec(INS,s1) by A1,NAT_D:34
   .= (Exec(INS,s1) +* Start-At(IC Exec(INS,s1),S)) by MEMSTR_0:31
   .= (IncIC(Exec(INS,s1),k) +*
       Start-At(IC Exec(INS,s1),S)) by FUNCT_4:114
   .=  DecIC(IncIC(Exec(INS,s1),k),k) by MEMSTR_0:59
   .= DecIC( IncIC(Exec(INS,s1),k),k)
   .= DecIC(  Exec(IncAddr(INS, k), s),k) by B3,Th4
   .=  DecIC(Exec(IncAddr(INS, k), s),k);
end;

registration let N be with_non-empty_elements non empty set;
 cluster relocable IC-recognized proper-halt
  for regular homogeneous J/A-independent
     halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N;
 existence
  proof
   take STC N;
   thus thesis;
  end;
end;

reserve N for with_non-empty_elements non empty set,
   S for IC-recognized
    halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N;

theorem Th6:
  for q be non halt-free finite
   (the Instructions of S)-valued NAT-defined Function
  for p being q-autonomic non empty FinPartState of S
   holds IC S in dom p
proof
  let q be non halt-free finite
   (the Instructions of S)-valued NAT-defined Function;
  let p be q-autonomic non empty FinPartState of S;
A2:  dom p meets {IC S} \/ Data-Locations S by MEMSTR_0:41;
  per cases by A2,XBOOLE_1:70;
  suppose dom p meets {IC S};
    hence thesis by ZFMISC_1:50;
  end;
  suppose dom p meets Data-Locations S;
    then dom p /\ Data-Locations S <> {} by XBOOLE_0:def 7;
    then DataPart p <> {} by RELAT_1:38,61;
    hence thesis by Th3;
  end;
end;

definition let N;
 let S be halting IC-Ins-separated
   non empty AMI-Struct over N;
 attr S is CurIns-recognized means
:Def4:
 for q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function
 for p being q-autonomic non empty FinPartState of S
  for s being State of S st  p c= s
 for P being Instruction-Sequence of S
       st q c= P
  for i being Element of NAT holds IC Comput(P,s,i) in dom q;
end;

registration let N;
 cluster STC N -> CurIns-recognized;
 coherence
proof
  let q be non halt-free finite
   (the Instructions of STC N)-valued NAT-defined Function;
  let p be q-autonomic non empty FinPartState of STC N,
      s be State of STC N such that
A1:  p c= s;
  let P be Instruction-Sequence of STC N such that
A2: q c= P;
  let i be Element of NAT;
  set Csi = Comput(P,s,i);
  set loc = IC Csi;
  set loc1 = loc+1;
  assume
B4:  not IC Comput(P,s,i) in dom q;
  the Instructions of STC N = {[0,0,0],[1,0,0]} by AMISTD_1:def 7;
  then
  reconsider I = [1,0,0] as Instruction of STC N by TARSKI:def 2;
  set p1 = q +* (loc .--> I);
  set p2 = q +* (loc .--> halt STC N);
  reconsider P1 = P +* (loc .--> I)
   as Instruction-Sequence of STC N;
  reconsider P2 = P +* (loc .--> halt STC N)
   as Instruction-Sequence of STC N;
A6: dom (loc .--> halt STC N) = {loc} by FUNCOP_1:13;
  then
A7: loc in dom (loc .--> halt STC N) by TARSKI:def 1;
A12: dom (loc .--> I) = {loc} by FUNCOP_1:13;
  then
A13: loc in dom (loc .--> I) by TARSKI:def 1;
Y6: dom q misses dom (loc .--> halt STC N) by B4,A6,ZFMISC_1:50;
Y5: dom q misses dom (loc .--> I) by B4,A12,ZFMISC_1:50;
P3: p1 c= P1 by A2,FUNCT_4:123;
P4: p2 c= P2 by A2,FUNCT_4:123;
  set Cs2i = Comput(P2,s,i), Cs1i = Comput(P1,s,i);
  p is not q-autonomic
  proof
    (loc .--> halt STC N).loc = halt STC N by FUNCOP_1:72;
    then
A18:  P2.loc = halt STC N by A7,FUNCT_4:13;
    (loc .--> I).loc = I by FUNCOP_1:72;
    then
A19:  P1.loc = I by A13,FUNCT_4:13;
    take P1, P2;
    q c= p1 by Y5,FUNCT_4:32;
    hence
A25:  q c= P1 by P3,XBOOLE_1:1;
    q c= p2 by Y6,FUNCT_4:32;
    hence
A27: q c= P2 by P4,XBOOLE_1:1;
    take s, s;
    thus  p c= s by A1;
A28: (Cs1i|dom  p) = (Csi|dom  p) by A25,A2,A1,EXTPRO_1:def 10;
    thus  p c= s by A1;
A29: (Cs1i|dom  p) = (Cs2i|dom  p) by A25,A27,A1,EXTPRO_1:def 10;
    take k = i+1;
    set Cs1k = Comput(P1,s,k);
A31: Cs1k = Following(P1,Cs1i) by EXTPRO_1:3
      .= Exec (CurInstr(P1,Cs1i), Cs1i);
   InsCode I = 1 by RECDEF_2:def 1;
   then
A32:  IC Exec(I,Cs1i) = succ IC Cs1i by AMISTD_1:9;
A33: IC STC N in dom p by Th6;
A34: IC Csi = IC(Csi|dom  p) by A33,FUNCT_1:49;
    then IC Cs1i = loc by A28,A33,FUNCT_1:49;
    then
A35: IC Cs1k = loc1 by A32,A31,A19,PBOOLE:143;
    set Cs2k = Comput(P2,s,k);
A36: Cs2k = Following(P2,Cs2i) by EXTPRO_1:3
      .= Exec (CurInstr(P2,Cs2i), Cs2i);
A37:  P2/.IC Cs2i = P2.IC Cs2i by PBOOLE:143;
    IC Cs2i = loc by A28,A34,A29,A33,FUNCT_1:49;
    then
A38: IC Cs2k = loc by A36,A18,A37,EXTPRO_1:def 3;
    IC(Cs1k|dom  p) = IC Cs1k & IC(Cs2k|dom  p) = IC Cs2k
     by A33,FUNCT_1:49;
    hence thesis by A35,A38;
  end;
  hence contradiction;
end;
end;

theorem
 S is CurIns-recognized implies
 for q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function
 for p being q-autonomic non empty FinPartState of S,
     s1,s2 being State of S st  p c= s1 &  p c= s2
 for P1,P2 being Instruction-Sequence of S
    st q c= P1 & q c= P2
 for i being Element of NAT
 holds IC Comput(P1,s1,i) = IC Comput(P2,s2,i) &
   CurInstr(P1,Comput(P1,s1,i)) = CurInstr(P2,Comput(P2,s2,i))
proof assume
A1: S is CurIns-recognized;
 let q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function;
  let p be q-autonomic non empty FinPartState of S,
      s1, s2 be State of S such that
A2:  p c= s1 and
A3:  p c= s2;
 let P1,P2 be Instruction-Sequence of S such that
A4: q c= P1 and
A5: q c= P2;
A6: dom q c= dom P1 by A4,RELAT_1:11;
A7: dom q c= dom P2 by A5,RELAT_1:11;
A8:  IC S in dom p by Th6;
  let i be Element of NAT;
  set Cs2i = Comput(P2,s2,i);
  set Cs1i = Comput(P1,s1,i);
A9: IC Cs1i in dom q by A4,Def4,A1,A2;
A10: IC Cs2i in dom q by A5,Def4,A1,A3;
  thus
A11: IC Cs1i = IC Cs2i
  proof
    assume
A12: IC Comput(P1,s1,i) <> IC Comput(P2,s2,i);
    (Cs1i|dom  p).IC S = Cs1i.IC S & (Cs2i|dom  p).IC S = Cs2i.IC S
    by A8,FUNCT_1:49;
    hence contradiction by A12,A4,A5,A2,A3,EXTPRO_1:def 10;
  end;
  thus CurInstr(P1,Comput(P1,s1,i))
   = P1.IC Cs1i by A9,A6,PARTFUN1:def 6
  .= q.IC Cs1i by A9,A4,GRFUNC_1:2
  .= P2.IC Cs2i by A10,A5,A11,GRFUNC_1:2
  .= CurInstr(P2,Comput(P2,s2,i)) by A10,A7,PARTFUN1:def 6;
end;

reserve S for relocable IC-recognized proper-halt
    regular homogeneous J/A-independent
     halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N;

theorem
 S is CurIns-recognized implies
  for k being Element of NAT
 for q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function
   for p being q-autonomic FinPartState of S
  st IC S in dom p
 for s being State of S st  p c= s
 for P being Instruction-Sequence of S
   st q c= P
  for i being Element of NAT
   holds  Comput(P +* Reloc(q,k),s +* IncIC( p,k),i) =
     IncIC(Comput(P,s,i),k)
proof assume
A1: S is CurIns-recognized;
  let k be Element of NAT;
 let q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function;
 let p be q-autonomic FinPartState of S such that
A2: IC S in dom p;
B2: IC S in dom  p by A2;
  let s be State of S such that
A4:  p c= s;
  let P be Instruction-Sequence of S;
  assume
A5: q c= P;
  defpred P[Element of NAT] means
    Comput(P+*Reloc(q,k),s+*IncIC( p,k),$1) =
     IncIC(Comput(P,s,$1),k);
A6: for i being Element of NAT st P[i] holds P[i+1]
  proof
    let i be Element of NAT such that
A7:  Comput(P+*Reloc(q,k),s+*IncIC( p,k),i)
     =  IncIC(Comput(P,s,i),k);
    reconsider kk = IC Comput(P,s,i) as Element of NAT;
    dom (Start-At (IC Comput(P,s,i) +k,S)) = {IC S} by FUNCOP_1:13;
    then
A8: IC S in dom Start-At (IC Comput(P,s,i) +k,S) by TARSKI:def 1;
A9: IC (IncIC(Comput(P,s,i),k))
     = IC Start-At (IC Comput(P,s,i) +k,S) by A8,FUNCT_4:13
    .= IC Comput(P,s,i) + k by FUNCOP_1:72;
    p is not empty by A2;
    then
A11: IC Comput(P,s,i) in dom q by A5,Def4,A1,A4;
    then
A12: IC Comput(P,s,i) in dom IncAddr(q,k) by COMPOS_1:def 19;
A17: q/.kk = q.IC Comput(P,s,i) by A11,PARTFUN1:def 6
      .= P.IC Comput(P,s,i) by A11,A5,GRFUNC_1:2;
    reconsider kk = IC Comput(P,s,i) as Element of NAT;
XX:  (IC Comput(P,s,i) +k)
     in dom Reloc(q,k) by A11,COMPOS_1:46;
A18: CurInstr(P+*Reloc(q,k),
         Comput(P+*Reloc(q,k),s+*IncIC( p,k),i))
   = (P+*Reloc(q,k)).
         IC Comput(P+*Reloc(q,k),s+*IncIC( p,k),i)
             by PBOOLE:143
  .= (Reloc(q,k)).(IC Comput(P,s,i) +k)
    by A7,A9,XX,FUNCT_4:13
      .= Shift(IncAddr(q,k),k).(IC Comput(P,s,i) +k)
by COMPOS_1:34
      .= IncAddr(q,k).kk by A12,VALUED_1:def 12
      .= IncAddr((q)/.kk,k) by A11,COMPOS_1:def 19
      .= IncAddr (CurInstr(P,Comput(P,s,i)),k) by A17,PBOOLE:143;
    thus  Comput(P+*Reloc(q,k),
       s+*IncIC( p,k),i+1)
     =  Following(P+*Reloc(q,k),
         Comput(P+*Reloc(q,k),s+*IncIC( p,k),i))
              by EXTPRO_1:3
    .=  Exec(IncAddr(CurInstr(P,Comput(P,s,i)),k),IncIC(Comput(P,s,i),k))
                 by A7,A18 :::,AMISTD_2:def 20
    .=  IncIC(Following(P,Comput(P,s,i)),k) by Th4
    .=  IncIC(Comput(P,s,i+1),k) by EXTPRO_1:3;
  end;
A20: Comput(P,s,0) = s by EXTPRO_1:2;
A21: IC p = IC  p
       .= IC s by A4,B2,GRFUNC_1:2;
B22:  DataPart p c=  p by MEMSTR_0:12;
  Comput(P+*Reloc(q,k),s+*IncIC( p,k),0)
    = s+*IncIC( p,k) by EXTPRO_1:2
   .= s +* IncIC( p,k)
   .= s +* (DataPart p +* Start-At ((IC p) +k,S))
         by A2,MEMSTR_0:56
   .= s +* DataPart p +* Start-At ((IC p) +k,S)
         by FUNCT_4:14
    .= IncIC(Comput(P,s,0),k) by A21,B22,A20,A4,FUNCT_4:98,XBOOLE_1:1;
  then
A23: P[0];
  thus for i being Element of NAT holds P[i] from NAT_1:sch 1(A23,A6);
end;

theorem Th9:
 S is CurIns-recognized implies
  for k being Element of NAT
 for q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function
  for p being q-autonomic FinPartState of S st IC S in dom p
  for s being State of S st IncIC(p,k) c= s holds
  for P being Instruction-Sequence of S
   st Reloc(q,k) c= P
  for i being Element of NAT holds  Comput(P,s,i) =
     IncIC(Comput(P+*q,s+* p,i),k)
proof assume
A1: S is CurIns-recognized;
  let k be Element of NAT;
 let q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function;
  let p be q-autonomic FinPartState of S such that
A2: IC S in dom p;
B2: IC S in dom  p by A2;
  let s be State of S such that
A4: IncIC(p,k) c= s;
  let P be Instruction-Sequence of S such that
A5: Reloc(q,k) c= P;
  defpred Z[Element of NAT] means  Comput(P,s,$1) =
    IncIC(Comput(P+*q,s+* p,$1),k);
A6: for i being Element of NAT st Z[i] holds Z[i+1]
  proof
    let i be Element of NAT such that
A7:  Comput(P,s,i) =
      IncIC(Comput(P+*q,s+* p,i),k);
    reconsider kk = IC Comput(P+*q,s+* p,i) as Element of NAT;
    dom (Start-At (IC Comput(P+*q,s+* p,i) +k,S)) = {IC S} by FUNCOP_1:13;
    then
A8: IC S in dom (Start-At (IC Comput(P+*q,s+* p,i) +k,S)) by TARSKI:def 1;
A10:  p c= s+* p by FUNCT_4:25;
A11: q c= P+*q by FUNCT_4:25;
    p is not empty by A2;
    then
A12: IC Comput(P+*q,s+* p,i) in dom q by A1,Def4,A10,A11;
    then
A13: IC Comput(P+*q,s+* p,i) in dom IncAddr(q,k) by COMPOS_1:def 19;
A14: (IC Comput(P+*q,s+* p,i) +k) in dom Reloc(q,k)
              by A12,COMPOS_1:46;
    reconsider kk = (IC Comput(P+*q,s+* p,i)) as Element of NAT;
A15:  IC Comput(P,s,i)
       = IC  Comput(P,s,i)
      .= IC IncIC(Comput(P+*q,s+* p,i),k) by A7
     .= IC(Start-At (IC Comput(P+*q,s+* p,i) +k,S)) by A8,FUNCT_4:13
      .= IC Comput(P+*q,s+* p,i) + k by FUNCOP_1:72;
A16: q c= P+*q by FUNCT_4:25;
A17: (q)/.kk = (q).kk by A12,PARTFUN1:def 6;
A18:  dom(P+*q) = NAT by PARTFUN1:def 2;
    dom P = NAT by PARTFUN1:def 2;
    then
A19: CurInstr(P,Comput(P,s,i))
     = P.IC Comput(P,s,i) by PARTFUN1:def 6
    .= Reloc(q,k).IC Comput(P,s,i) by A5,A14,A15,GRFUNC_1:2
      .= Shift(IncAddr(q,k),k).
             (IC Comput(P+*q,s+* p,i)+k)
       by A15,COMPOS_1:34
      .= IncAddr(q,k).kk by A13,VALUED_1:def 12
      .= IncAddr((q)/.kk,k) by A12,COMPOS_1:def 19
      .= IncAddr(
          (P+*q).IC Comput(P+*q,s+* p,i)
          ,k) by A12,A17,A16,GRFUNC_1:2
      .= IncAddr(
          CurInstr(P+*q,Comput(P+*q,s+* p,i))
          ,k) by A18,PARTFUN1:def 6;
    thus  Comput(P,s,i+1)
       =  Following(P,Comput(P,s,i)) by EXTPRO_1:3
      .=  Exec(IncAddr(CurInstr(P+*q,
          Comput(P+*q,s+* p,i)),k),
              IncIC(Comput(P+*q,s+* p,i),k))
               by A7,A19 :::,AMISTD_2:def 20
      .=  IncIC(Following(P+*q,
         Comput(P+*q,s+* p,i)),k) by Th4
      .=  IncIC(Comput(P+*q,s+* p,i+1),k) by EXTPRO_1:3;
  end;
  set IP = Start-At (IC p,S);
A21: dom Start-At(IC p,S) = {IC S} by FUNCOP_1:13;
B22: Start-At (IC p + k,S) c= IncIC(p,k) by MEMSTR_0:55;
B23: IC Comput(P+*q,s+* p,0) = (s +*  p).IC S by EXTPRO_1:2
    .= IC  p by B2,FUNCT_4:13
    .= IC p;
  set DP = DataPart p;
  DataPart IncIC(p,k) c= IncIC(p,k) by RELAT_1:59;
  then DataPart IncIC(p,k) c= s by A4,XBOOLE_1:1;
  then
A29: DataPart p c= s by MEMSTR_0:51;
  set PR = Reloc(q,k);
  set IS = Start-At (IC Comput(P+*q,s+* p,0) +k,S);
A30: dom Start-At (IC Comput(P+*q,s+* p,0) +k,S) = {IC S} by FUNCOP_1:13;
  Comput(P,s,0) = s by EXTPRO_1:2
    .= s +* IS by B23,A4,B22,FUNCT_4:98,XBOOLE_1:1
    .= s +* DP +* IS by A29,FUNCT_4:98
    .= s+* DP +* IP +* IS by A30,A21,FUNCT_4:74
    .= s +*(DP +* IP) +* IS by FUNCT_4:14
    .= s +*  p +* IS by A2,MEMSTR_0:26
    .= IncIC(Comput(P+*q,s+* p,0),k) by EXTPRO_1:2;
  then
A31: Z[0];
  thus for i being Element of NAT holds Z[i] from NAT_1:sch 1 (A31,A6 );
end;

reserve m,j for Element of NAT;

theorem Th10:
 S is CurIns-recognized implies
  for k being Element of NAT
 for q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function
  for p being non empty FinPartState of S st IC
  S in dom p
   for s being State of S st  p c= s &
     IncIC(p,k) is Reloc(q,k)-autonomic
   for P being Instruction-Sequence of S
    st q c= P
   for i being Element of NAT holds  Comput(P,s,i)
   =  DecIC(Comput(P+*Reloc(q,k),s+*IncIC(p,k),i),k)
proof assume
A1: S is CurIns-recognized;
  let k be Element of NAT;
 let q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function;
  let p be non empty FinPartState of S;
  assume
A3:  IC S in dom p;
  then
B4: Start-At (IC p,S) c=  p by FUNCOP_1:84;
  let s be State of S such that
A5:  p c= s and
A6: IncIC(p,k) is Reloc(q,k)-autonomic;
  let P be Instruction-Sequence of S such that
A7: q c= P;
  defpred Z[Element of NAT] means  Comput(P,s,$1) =
    DecIC(Comput(P+*Reloc(q,k),s+*IncIC(p,k),$1),k);
A9: for i being Element of NAT st Z[i] holds Z[i+1]
  proof
    reconsider pp = q as preProgram of S;
    let i be Element of NAT such that
A10:  Comput(P,s,i) =
       DecIC(Comput(P+*Reloc(q,k),s+*IncIC(p,k),i),k);
    reconsider kk = IC Comput(P+*Reloc(q,k),s+*IncIC(p,k),
i) as Element of NAT;
    reconsider jk = IC Comput(P+*Reloc(q,k),s+*IncIC(p,k),
i) as Element of NAT;
A11: IncIC(p,k) c= s+*IncIC(p,k) by FUNCT_4:25;
A12: Reloc(q,k) c= P+*Reloc(q,k) by FUNCT_4:25;

A13: IC Comput(P+*Reloc(q,k),s+*IncIC(p,k),i) in dom
          Reloc(q,k) by A6,A1,Def4,A11,A12;
    then
A14: jk in { j+k : j in dom q } by COMPOS_1:33;
    dom (Start-At (IC Comput(P+*Reloc(q,k),s+*IncIC(p,k),i
) -'k,S)) = {IC S }
    by FUNCOP_1:13;
    then
A16: IC S in dom (Start-At (IC Comput(P+*Reloc(q,k),s+*
        IncIC(p,k),i) -'k,S))
    by TARSKI:def 1;
    consider j being Element of NAT such that
A17: jk = j+k and
A18: j in dom q by A14;
A19:  dom(P+*Reloc(q,k)) = NAT by PARTFUN1:def 2;
A20: Reloc(q,k) c= P+*Reloc(q,k) by FUNCT_4:25;
    dom Shift(pp, k) = { m+k : m in dom pp} by VALUED_1:def 12;
    then
A21: (j+k) in dom Shift(q, k) by A18;
    then
A22: IncAddr(Shift(q, k)/.kk,k)
    = Reloc(q,
    k). IC Comput(P+*Reloc(q,k),s+*IncIC(p,k),i) by A17,COMPOS_1:def 19
      .= (P+*Reloc(q,k)).
         IC Comput(P+*Reloc(q,k),s+*IncIC(p,k),i)
           by A13,A20,GRFUNC_1:2
      .= CurInstr(P+*Reloc(q,k),
         Comput(P+*Reloc(q,k),s+*IncIC(p,k),i))
           by A19,PARTFUN1:def 6;
A23: j+k -' k = j by NAT_D:34;
A24:  dom P = NAT by PARTFUN1:def 2;
A25: IC ( DecIC(Comput(P+*Reloc(q,k),s+*IncIC(p,k),i),k)
      )
      = (Start-At (IC Comput(P+*Reloc(q,k),s+*IncIC(p,k),
i) -'k,S)).IC S
       by A16,FUNCT_4:13
      .= IC Comput(P+*Reloc(q,k),s+*IncIC(p,k),i) -' k by FUNCOP_1:72;
    CurInstr(P,Comput(P,s,i))
     = P.IC Comput(P,s,i)
        by A24,PARTFUN1:def 6
    .= (q).IC Comput(P,s,i)
        by A10,A17,A18,A23,A7,A25,GRFUNC_1:2
    .= Shift(q, k).
        (IC Comput(P+*Reloc(q,k),s+*IncIC(p,k),i))
         by A17,A18,A23,A10,A25,VALUED_1:def 12
    .= Shift(q, k)/.kk by A17,A21,PARTFUN1:def 6;
    then
A26: Comput(P+*Reloc(q,k),s+*IncIC(p,k),i+1)
 = Following(P+*Reloc(q,k),
 Comput(P+*Reloc(q,k),s+*IncIC(p,k),i)) &
  Exec(CurInstr(P,Comput(P,s,i)),
 DecIC(Comput(P+*Reloc(q,k),s+*IncIC(p,k),i),k))
 =  DecIC(Following(P+*Reloc(q,k),
 Comput(P+*Reloc(q,k),s +*IncIC(p,k),i)),k)
  by A17,A22,Th5,EXTPRO_1:3;
    thus  Comput(P,s,i+1)
     =  Following(P,Comput(P,s,i)) by EXTPRO_1:3
    .=  DecIC(Comput(P+*Reloc(q,k),s+*IncIC(p,k),i+1),k)
    by A10,A26; :::,AMISTD_2:def 20;
  end;
B27: IC S in dom IncIC(p,k) by MEMSTR_0:52;
A28: IC Comput(P+*Reloc(q,k),s+*IncIC(p,k),0)
     = IC(s +* IncIC(p,k)) by EXTPRO_1:2
    .= IC IncIC(p,k) by B27,FUNCT_4:13;
B29: DataPart p c=  p by RELAT_1:59;
  set DP = DataPart p;
  set IP = Start-At((IC p)+k,S);
  set PP = q;
  set IS = Start-At (IC Comput(P+*Reloc(q,k),s+*IncIC(p,k),0) -'k,S);
A32: dom Start-At((IC p)+k,S) = {IC S} by FUNCOP_1:13;
  set PR = Reloc(q,k);
  set SD = s|(dom Reloc(q,k));
A33: {IC S} misses dom DataPart p by MEMSTR_0:4;
A36: dom Start-At (IC Comput(P+*Reloc(q,k),s+*IncIC(p,k),0
) -'k,S) = {IC S} by FUNCOP_1:13;
A41: dom IP misses dom DP by A33,FUNCOP_1:13;
A42: IP +* DP = DP +* IP by A41,FUNCT_4:35
      .= IncIC( p,k) by A3,MEMSTR_0:56
      .= IncIC(p,k);
   Comput(P,s,0) = s by EXTPRO_1:2
    .= s +* Start-At(IC p,S) by A5,B4,FUNCT_4:98,XBOOLE_1:1
    .= s +* Start-At (IC p + k -'k,S) by NAT_D:34
    .= s +* IS by A28,MEMSTR_0:53
    .= s +* DP +* IS by B29,A5,FUNCT_4:98,XBOOLE_1:1
    .= s +* DP +* IP +* IS by A36,A32,FUNCT_4:74
    .= s +*(DP +* IP) +* IS by FUNCT_4:14
    .= s +*(IP +* DP)+* IS by A32,A33,FUNCT_4:35
    .= DecIC(Comput(P+*Reloc(q,k),s+*IncIC(p,k),0),k)
     by A42,EXTPRO_1:2;
  then
A43: Z[0];
  thus for i being Element of NAT holds Z[i] from NAT_1:sch 1 (A43, A9);
end;

theorem Th11:
 S is CurIns-recognized implies
 for q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function
  for p being non empty FinPartState of S st IC S in dom p
  for k being Element of NAT holds
   p is q-autonomic iff IncIC(p,k) is Reloc(q,k)-autonomic
proof assume
A1: S is CurIns-recognized;
 let q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function;
  let p be non empty FinPartState of S such that
A2: IC S in dom p;
  let k be Element of NAT;
  hereby
    assume
A4: p is q-autonomic;
    thus IncIC(p,k) is Reloc(q,k)-autonomic
    proof
     let P,Q be Instruction-Sequence of S such that
A5:   Reloc(q,k) c= P and
A6:   Reloc(q,k) c= Q;
      let s1,s2 be State of S such that
A7:    IncIC(p,k) c= s1 and
A8:    IncIC(p,k) c= s2;
      let i be Element of NAT;
A12:   dom (Start-At ((IC Comput(Q+*q,s2+* p,i))+k,S)) = {IC S}
 by FUNCOP_1:13;
      then
A13:   dom(DataPart p) misses
       dom (Start-At (IC Comput(Q+*q,s2+* p,i) +k,S))
      by MEMSTR_0:4;
A14:  dom (Start-At ((IC Comput(P+*q,s1+* p,i))+k,S)) = {IC S}
 by FUNCOP_1:13;
      then
A15:  dom(DataPart p) misses
       dom (Start-At (IC Comput(P+*q,s1+* p,i) +k,S))
      by MEMSTR_0:4;
A17:   q c= P+*q & q c= Q+*q
              by FUNCT_4:25;
       p c= s1 +*  p &  p c= s2 +*  p by FUNCT_4:25;
    then
A18:  Comput(P+*q,s1+* p,i)|dom  p
    = Comput(Q+*q,s2+* p,i) |dom  p
     by A4,A17,EXTPRO_1:def 10;
A19:  DataPart p c=  p by MEMSTR_0:12;
A21:  Comput(P,s1,i)|dom (DataPart p)
        = ( Comput(P,s1,i))|dom (DataPart p)
       .= ( IncIC(Comput(P+*q,s1+* p,i),k)) | dom DataPart p
         by A2,A4,A7,Th9,A1,A5
       .= IncIC(Comput(P+*q,s1+* p,i),k) | dom (DataPart p)
       .= ( Comput(P+*q,s1+* p,i)) | dom (DataPart p)
         by A15,FUNCT_4:72
        .= ( Comput(Q+*q,s2+* p,i)) | dom (DataPart p)
         by A18,A19,RELAT_1:11,153
        .= IncIC(Comput(Q+*q,s2+* p,i),k)|dom (DataPart p)
               by A13,FUNCT_4:72
        .= ( IncIC(Comput(Q+*q,s2+* p,i),k))|dom DataPart p
        .= ( Comput(Q,s2,i))|dom (DataPart p) by A2,A4,A8,Th9,A1,A6
        .= Comput(Q,s2,i)|dom (DataPart p);
      IC S in dom  p by A2;
      then
A22:  {IC S} c= dom  p by ZFMISC_1:31;
A23:  Start-At (IC Comput(P+*q,s1+* p,i),S)
      = Comput(P+*q,s1+* p,i)|{IC S} by MEMSTR_0:18
        .= Comput(Q+*q,s2+* p,i)|{IC S}
        by A18,A22,RELAT_1:153
        .= Start-At (IC Comput(Q+*q,s2+* p,i),S) by MEMSTR_0:18;
A24:  dom (Start-At((IC p)+k,S)) = {IC S} by FUNCOP_1:13;
A26:  Comput(P,s1,i)|dom (Start-At((IC p)+k,S))
        = ( Comput(P,s1,i))|dom (Start-At((IC p)+k,S))
       .= ( IncIC(Comput(P+*q,s1+* p,i),k))|
                   dom (Start-At((IC p)+k,S))
         by A2,A4,A7,Th9,A1,A5
       .= IncIC(Comput(P+*q,s1+* p,i),k)|
              dom (Start-At((IC p)+k,S))
       .= Start-At (IC Comput(P+*q,s1+* p,i) +k,S)
         by A24,A14,FUNCT_4:23
        .= Start-At (IC Comput(Q+*q,s2+* p,i) +k,S)
              by A23,MEMSTR_0:21
        .= IncIC(Comput(Q+*q,s2+* p,i),k)|
                dom (Start-At((IC p)+k,S))
              by A24,A12,FUNCT_4:23
        .= ( IncIC(Comput(Q+*q,s2+* p,i),k))|
                dom (Start-At((IC p)+k,S))
        .= ( Comput(Q,s2,i))|dom (Start-At((IC p)+k,S))
              by A2,A4,A8,Th9,A1,A6
        .= Comput(Q,s2,i)|dom (Start-At((IC p)+k,S));
A27:  dom Start-At((IC p)+k,S) = {IC S} by FUNCOP_1:13;
A28:  dom  p = {IC S} \/ dom DataPart p by A2,MEMSTR_0:24;
A29: Comput(P,s1,i)|dom  p
       = Comput(P,s1,i)|{IC S}
          \/ Comput(P,s1,i)|dom DataPart p by A28,RELAT_1:78
       .= Comput(Q,s2,i)|dom  p
       by A28,A27,A21,A26,RELAT_1:78;
A30:  dom IncIC( p,k)
      = dom  p \/ dom Start-At((IC  p)+k,S) by FUNCT_4:def 1
     .= dom  p \/ dom Start-At((IC p)+k,S);
A31: Comput(P,s1,i)|dom IncIC( p,k)
     = Comput(P,s1,i)|dom  p
        \/ Comput(P,s1,i)|dom Start-At((IC p)+k,S) by A30,RELAT_1:78
    .= Comput(Q,s2,i)|dom IncIC( p,k)
         by A30,A26,A29,RELAT_1:78;
     thus Comput(P,s1,i)|dom  IncIC(p,k)
        = Comput(P,s1,i)|dom IncIC( p,k)
       .= Comput(Q,s2,i)|dom  IncIC(p,k) by A31;

    end;
  end;
  assume
A32: IncIC(p,k) is Reloc(q,k)-autonomic;
B33: DataPart p c= IncIC(p,k) by MEMSTR_0:62;
    let P,Q be Instruction-Sequence of S such that
A34: q c= P and
A35: q c= Q;
A36: Reloc(q,k) c= P +* Reloc(q,k) &
    Reloc(q,k) c= Q +* Reloc(q,k)
         by FUNCT_4:25;
    let s1,s2 be State of S such that
A37:  p c= s1 and
A38:  p c= s2;
    let i be Element of NAT;
     IncIC(p,k) c= s1 +*  IncIC(p,k) &
     IncIC(p,k) c= s2 +*  IncIC(p,k) by FUNCT_4:25;
    then
A43: Comput(P +* Reloc(q,k),s1+*IncIC(p,k),i)|dom  IncIC(p,k)
     = Comput(Q +* Reloc(q,k),s2+*IncIC(p,k),i)|dom  IncIC(p,k)
           by A32,A36,EXTPRO_1:def 10;
A44: dom (Start-At ((IC Comput(Q +* Reloc(q,k),s2+*IncIC(p,k),i)) -'k,S))
       = {IC S} by FUNCOP_1:13;
    then
A45: dom(DataPart p) misses
 dom(Start-At (IC Comput(Q+*Reloc(q,k),s2+*IncIC(p,k),i) -'k,S))
         by MEMSTR_0:4;
A46: dom (Start-At ((IC Comput(P +* Reloc(q,k),s1+*IncIC(p,k),i)) -'k,S))
      = {IC S} by FUNCOP_1:13;
    then
A47: dom(DataPart p) misses
     dom(Start-At (IC Comput(P+*Reloc(q,k),s1+*IncIC(p,k),i) -'k,S))
           by MEMSTR_0:4;
A49: Comput(P,s1,i)|dom (DataPart p)
    = ( Comput(P,s1,i))|dom (DataPart p)
   .= ( DecIC(Comput(P+*Reloc(q,k),s1+*IncIC(p,k),i),k))
         | dom(DataPart p) by A2,A32,A37,Th10,A1,A34
   .= ( DecIC(Comput(P+*Reloc(q,k),s1+*IncIC(p,k)
    ,i),k)) | dom(DataPart p)
      .= ( Comput(P +* Reloc(q,k),s1+*IncIC(p,k),i)) | dom
(DataPart p) by A47,FUNCT_4:72
      .= ( Comput(Q +* Reloc(q,k),s2+*IncIC(p,k),i)) | dom
(DataPart p) by A43,B33,RELAT_1:11,153
      .= DecIC(Comput(Q +* Reloc(q,k),s2+*IncIC(p,k),i),k)
     | dom(DataPart p) by A45,FUNCT_4:72
      .= ( DecIC(Comput(Q +* Reloc(q,k),
             s2+*IncIC(p,k),i),k))
     | dom(DataPart p)
      .= ( Comput(Q,s2,i))|dom (DataPart p) by A2,A32,A38,Th10,A1,A35
      .= Comput(Q,s2,i)|dom (DataPart p);
    IC S in dom  IncIC(p,k) by MEMSTR_0:52;
    then
A50: {IC S} c= dom IncIC(p,k) by ZFMISC_1:31;
A51: Start-At (IC Comput(P +* Reloc(q,k),s1+*IncIC(p,k),i),
S) = Comput(P+*Reloc(q,k),s1+*
    IncIC(p,k),i)|{IC S} by MEMSTR_0:18
      .= Comput(Q +* Reloc(q,k),s2+*IncIC(p,k),i)|{IC S}
        by A43,A50,RELAT_1:153
      .= Start-At (IC Comput(Q +* Reloc(q,k),s2+*IncIC(p,k)
,i),S) by MEMSTR_0:18;
A52: dom (Start-At(IC p,S)) = {IC S} by FUNCOP_1:13;
A54: Comput(P,s1,i)|dom (Start-At(IC p,S))
     = ( Comput(P,s1,i))|dom (Start-At(IC p,S))
    .= ( DecIC(Comput(P+*Reloc(q,k),s1+*IncIC(p,k),i),k))
         |dom (Start-At(IC p,S)) by A2,A32,A37,Th10,A1,A34
    .= ( DecIC(Comput(
P+*Reloc(q,k),s1+*IncIC(p,k),i),k)) |dom (Start-At(IC p,S))
      .= Start-At (IC Comput(P +* Reloc(q,k),s1+*IncIC(p,k)
,i) -'k,S) by A52,A46,FUNCT_4:23
      .= Start-At (IC Comput(Q +* Reloc(q,k),s2+*IncIC(p,k)
,i) -'k,S)
       by A51,MEMSTR_0:22
      .= DecIC(Comput(Q +* Reloc(q,k),s2+*IncIC(p,k),i),k)
     |dom (Start-At(IC p,S))
     by A52,A44,FUNCT_4:23
      .= ( DecIC(Comput(Q +* Reloc(q,k),
           s2+*IncIC(p,k),i),k))
     |dom (Start-At(IC p,S))
      .= ( Comput(Q,s2,i))|dom (Start-At(IC p,S))
           by A2,A32,A38,Th10,A1,A35
      .= Comput(Q,s2,i)|dom (Start-At(IC p,S));
    thus Comput(P,s1,i)|dom  p
     = Comput(P,s1,i)|dom(Start-At(IC p,S) +*
          DataPart p ) by A2,MEMSTR_0:19
      .= Comput(P,s1,i)|(dom (Start-At(IC p,S)) \/ dom (DataPart p))
          by FUNCT_4:def 1
      .= Comput(Q,s2,i)|dom (Start-At(IC p,S)) \/
            Comput(Q,s2,i)|dom (DataPart p) by A49,A54,RELAT_1:78
      .= Comput(Q,s2,i)|(dom (Start-At(IC p,S)) \/ dom DataPart p)
           by RELAT_1:78
      .= Comput(Q,s2,i)|dom (Start-At(IC p,S) +* DataPart p) by FUNCT_4:def 1
      .= Comput(Q,s2,i)|dom  p by A2,MEMSTR_0:19;
end;

definition let N,S;
 attr S is relocable1 means
:Def5: for k being Element of NAT
 for q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function
 for p being q-autonomic non empty FinPartState of S,
      s1, s2 being State of S st IC S in dom p &  p c= s1 &
       IncIC( p,k) c= s2
  for P1,P2 being Instruction-Sequence of S
   st q c= P1 & Reloc(q,k) c= P2
  for i being Element of NAT
   holds IncAddr(CurInstr(P1,Comput(P1,s1,i)),k)
       = CurInstr(P2,Comput(P2,s2,i));
 attr S is relocable2 means
:Def6: for k being Element of NAT
 for q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function
   for p being q-autonomic non empty FinPartState of S,
      s1, s2 being State of S st IC S in dom p &
       p c= s1 & IncIC( p,k) c= s2
  for P1,P2 being Instruction-Sequence of S
   st q c= P1 & Reloc(q,k) c= P2
  for i being Element of NAT holds
   Comput(P1,s1,i)|dom DataPart p = Comput(P2,s2,i)|dom DataPart p;
end;

Lm1: for k being Element of NAT
 for q be non halt-free finite
  (the Instructions of STC N)-valued NAT-defined Function
  for p being q-autonomic FinPartState of STC N , s1,
s2 being State of STC N
 st IC STC N in dom p &  p c= s1 & IncIC( p,k) c= s2
for P1,P2 being Instruction-Sequence of STC N
 st q c= P1 & Reloc(q,k) c= P2
for i being Element of NAT holds
 IC Comput(P1,s1,i) + k = IC Comput(P2,s2,i) &
IncAddr(CurInstr(P1,Comput(P1,s1,i)), k)
 = CurInstr(P2,Comput(P2,s2,i)) &
Comput(P1,s1,i)|(dom DataPart p qua set)
 = Comput(P2,s2,i)|(dom DataPart p qua set) &
DataPart Comput(P1,s1 +* DataPart s2,i) =
DataPart Comput(P2,s2,i)
proof
  let k be Element of NAT;
 let q be non halt-free finite
  (the Instructions of STC N)-valued NAT-defined Function;
  let p be q-autonomic FinPartState of STC N,
      s1,s2 be State of STC N such that
A1: IC STC N in dom p and
A2:  p c= s1 and
A3: IncIC( p,k) c= s2;
B1: IC STC N in dom  p by A1;
C1: p is non empty by A1;
  let P1,P2 being Instruction-Sequence of STC N
  such that
A4: q c= P1 & Reloc(q,k) c= P2;
  set s3 = s1 +* DataPart s2;
  defpred Z[Element of NAT] means
   IC Comput(P1,s1,$1) + k = IC Comput(P2,s2,$1) &
 IncAddr(CurInstr(P1,Comput(P1,s1,$1)), k)
 = CurInstr(P2,Comput(P2,s2,$1)) &
  Comput(P1,s1,$1)|(dom DataPart p qua set)
   = Comput(P2,s2,$1)|(dom DataPart p qua set) &
   DataPart Comput(P1,s3,$1)
    = DataPart Comput(P2,s2,$1);
A8: for i be Element of NAT st Z[i] holds Z[i+1]
  proof
    set DPp = DataPart p;
    let i be Element of NAT such that
A9: IC Comput(P1,s1,i) + k = IC Comput(P2,s2,i) and
A10: IncAddr (CurInstr(P1,Comput(P1,s1,i)), k)
    = CurInstr(P2,Comput(P2,s2,i)) and
 Comput(P1,s1,i)|(dom DataPart p qua set)
    = Comput(P2,s2,i)|(dom DataPart p qua set) and
 DataPart Comput(P1,s3,i)
    = DataPart Comput(P2,s2,i);
    set Cs2i1 = Comput(P2,s2,i+1);
    set Cs3i = Comput(P1,s3,i);
    set Cs2i = Comput(P2,s2,i);
    set Cs3i1 = Comput(P1,s3,i+1);
    set Cs1i1 = Comput(P1,s1,i+1);
    set Cs1i = Comput(P1,s1,i);
A11: now
      reconsider loc = IC Cs1i1 as Element of NAT;
      assume
A12:  IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,i+1);
      reconsider kk = loc as Element of NAT;
A13:  loc in dom q by Def4,A4,A2,C1;
A14:  loc + k in dom Reloc(q, k) by A13,COMPOS_1:46;
A15: dom P2 = NAT by PARTFUN1:def 2;
      dom P1 = NAT by PARTFUN1:def 2;
      then CurInstr(P1, Cs1i1) = P1.loc by PARTFUN1:def 6
        .= (q).loc by A13,A4,GRFUNC_1:2;

      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = Reloc(q,k).(loc+k) by A13,COMPOS_1:35
      .= P2.IC Comput(P2,s2,i+1) by A12,A14,A4,GRFUNC_1:2
      .= CurInstr(P2,Comput(P2,s2,i+1)) by A15,PARTFUN1:def 6;
    end;
    set I = CurInstr(P1, Cs1i);
A16: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:3
      .= Exec (CurInstr(P2, Cs2i), Cs2i);
    reconsider j = IC Cs1i as Element of NAT;
A17: Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:3
      .= Exec (CurInstr(P1, Cs1i), Cs1i);
A18:  the Instructions of STC N = {[0,0,0],[1,0,0]} by AMISTD_1:def 7;
    per cases by A18,TARSKI:def 2;
    suppose
      I = [0,0,0];
      then
A19:  I = halt STC N by AMISTD_1:def 7;
      thus IC Comput(P1,s1,i+1) + k = IC Cs1i + k
       by A17,A19,EXTPRO_1:def 3
        .= IC Comput(P2,s2,i+1) by A9,A16,A19,A10,EXTPRO_1:def 3;
      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1)) by A11;
      thus Comput(P1,s1,i+1)|(dom DataPart p qua set)
       = Comput(P2,s2,i+1)|(dom DataPart p qua set);
      thus DataPart Cs3i1 = DataPart Cs2i1;
    end;
    suppose
      I = [1,0,0];
      then
A20:    InsCode I = 1 by RECDEF_2:def 1;
      then
A21:   Exec(I,Cs2i) = IncIC(Cs2i,1) by AMISTD_1:20;
      thus IC Comput(P1,s1,i+1) + k = succ IC Cs1i + k
         by A17,A20,AMISTD_1:9
        .= IC Exec(I,Cs2i) by A21,A9,MEMSTR_0:53
        .= IC Comput(P2,s2,i+1) by A16,A10,COMPOS_1:11;
      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1)) by A11;
      thus Comput(P1,s1,i+1)|(dom (DataPart p) qua set)
      = Comput(P2,s2,i+1)|(dom (DataPart p)
              qua set);

      thus DataPart Cs3i1 = DataPart Cs2i1;
    end;
  end;
B22: IC STC N in dom IncIC( p,k) by MEMSTR_0:52;
  now
    thus IC Comput(P1,s1,0) + k = IC s1 + k by EXTPRO_1:2
      .= IC  p + k by A2,B1,GRFUNC_1:2
      .= IC p + k
      .= IC IncIC(p,k) by MEMSTR_0:53
      .= IC  IncIC(p,k)
      .= IC IncIC( p,k)
      .= IC s2 by A3,B22,GRFUNC_1:2
      .= IC Comput(P2,s2,0) by EXTPRO_1:2;
    reconsider loc = IC  p as Element of NAT;
A23: IC  p = IC s1 by A2,B1,GRFUNC_1:2;
    then IC  p = IC Comput(P1,s1,0) by EXTPRO_1:2;
    then
A24: loc in dom q by Def4,A4,A2,C1;
A25: (IC  p) + k in dom Reloc(q,k) by A24,COMPOS_1:46;
B26: IC STC N in dom IncIC( p,k) by MEMSTR_0:52;
A27: (q).IC  p = P1.IC s1 by A23,A24,A4,GRFUNC_1:2;
    dom P2 = NAT by PARTFUN1:def 2;
    then
A28:  CurInstr(P2,Comput(P2,s2,0))
      = P2.IC Comput(P2,s2,0) by PARTFUN1:def 6
     .= P2.IC s2 by EXTPRO_1:2
     .= P2.IC IncIC( p,k) by A3,B26,GRFUNC_1:2
     .= P2.IC  IncIC(p,k)
     .= P2.IC IncIC(p,k)
      .= P2.((IC p) +k) by MEMSTR_0:53
      .= P2.((IC  p) +k)
      .= (Reloc(q, k)).((IC  p) +k) by A25,A4,GRFUNC_1:2;
A29:  dom P1 = NAT by PARTFUN1:def 2;
     CurInstr(P1,Comput(P1,s1,0))
       = CurInstr(P1,s1) by EXTPRO_1:2
      .= P1.IC s1 by A29,PARTFUN1:def 6;
    hence
    IncAddr(CurInstr(P1,Comput(P1,s1,0)), k)
     = CurInstr(P2,Comput(P2,s2,0)) by A28,A24,A27,COMPOS_1:35;
    thus Comput(P1,s1,0)|(dom (DataPart p) qua set)
       = Comput(P2,s2,0)|(dom (DataPart p) qua set);
    thus DataPart Comput(P1,s3,0)
      = DataPart Comput(P2,s2,0);
  end;
  then
A30: Z[0];
  thus for i being Element of NAT holds Z[i] from NAT_1:sch 1(A30,A8);
end;

registration let N;
 cluster STC N -> relocable1;
 coherence
  proof
   thus for k being Element of NAT
 for q be non halt-free finite
  (the Instructions of STC N)-valued NAT-defined Function
   for p being q-autonomic non empty FinPartState of STC N,
      s1, s2 being State of STC N st IC STC N in dom p &  p c= s1 &
       IncIC( p,k) c= s2
  for P1,P2 being Instruction-Sequence of STC N
   st q c= P1 & Reloc(q,k) c= P2
  for i being Element of NAT
   holds IncAddr(CurInstr(P1,Comput(P1,s1,i)),k)
       = CurInstr(P2,Comput(P2,s2,i)) by Lm1;
  end;
end;

registration let N be with_non-empty_elements non empty set;
 cluster relocable1 for relocable IC-recognized proper-halt
  regular homogeneous J/A-independent
     halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N;
 existence
  proof
   take STC N;
   thus thesis;
  end;
end;

reserve S for relocable1 relocable IC-recognized proper-halt
    regular homogeneous J/A-independent
     halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N;

theorem Th12:
  S is relocable1 proper-halt implies
 for q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function
  for p being q-autonomic non empty FinPartState of S,
      k being Element of NAT st IC S in dom p
   holds p is q-halted iff IncIC(p,k) is Reloc(q,k)-halted
proof assume
 S is relocable1 proper-halt;
 let q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function;
  let p be q-autonomic non empty FinPartState of S,
      k be Element of NAT;
  assume
A1: IC S in dom p;
  hereby
    assume
A3: p is q-halted;
    thus IncIC(p,k) is Reloc(q,k)-halted
    proof
      let t be State of S;
      assume
A4:    IncIC(p,k) c= t;
      let P be Instruction-Sequence of S such that
A5:   Reloc(q,k) c= P;
      reconsider Q = P +* q
       as Instruction-Sequence of S;
      set s = t +* p;
A6:   q c= Q by FUNCT_4:25;
C7:   p c= t +* p by FUNCT_4:25;
      then
     p c= s;
      then Q halts_on s by A3,A6,EXTPRO_1:def 11;
      then consider u being Element of NAT such that
A8:   CurInstr(Q,Comput(Q,s,u)) = halt S by EXTPRO_1:29;
      take u;
     dom P = NAT by PARTFUN1:def 2;
    hence IC Comput(P,t,u) in dom P;
      CurInstr(P,Comput(P,t,u))
       = IncAddr(halt S, k) by A1,A4,A8,Def5,A5,A6,C7
        .= halt S by COMPOS_1:11;
      hence thesis;
    end;
  end;
  assume
A9: IncIC(p,k) is Reloc(q,k)-halted;
  let t be State of S;
  assume
A10:  p c= t;
  let P be Instruction-Sequence of S such that
A11: q c= P;
  reconsider Q = P +* Reloc(q, k)
   as Instruction-Sequence of S;
  set s = t +*  IncIC(p,k);
A12: Reloc(q,k) c= Q by FUNCT_4:25;
A13:  IncIC(p,k) c= t +*  IncIC(p,k) by FUNCT_4:25;
  then Q halts_on s by A9,A12,EXTPRO_1:def 11;
  then consider u being Element of NAT such that
A14: CurInstr(Q,Comput(Q,s,u)) = halt S by EXTPRO_1:29;
  take u;
   dom P = NAT by PARTFUN1:def 2;
  hence IC Comput(P,t,u) in dom P;
  IncAddr(CurInstr(P,Comput(P,t,u)), k)
   = halt S by A1,A10,A14,Def5,A13,A11,A12
  .= IncAddr(halt S,k) by COMPOS_1:11;
 hence CurInstr(P,Comput(P,t,u)) = halt S by COMPOS_1:13;
end;

theorem Th13:
 S is relocable1 relocable2 CurIns-recognized proper-halt implies
 for q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function
  for p being q-halted q-autonomic non empty FinPartState of S
   st IC S in dom p
  for k being Element of NAT holds DataPart(Result(q, p)) =
   DataPart Result(Reloc(q,k),IncIC( p,k))
proof assume
A1: S is relocable1 relocable2 CurIns-recognized proper-halt;
 let q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function;
  let p be q-halted q-autonomic non empty FinPartState of S
  such that
A2: IC S in dom p;
  let k be Element of NAT;
  consider s being State of S such that
A4: p c= s by PBOOLE:141;
  consider P being
   Instruction-Sequence of S
   such that
C4: q c= P by PBOOLE:145;
B4:  p c= s by A4;
A6: IncIC(p,k) is Reloc(q,k)-halted Reloc(q,k)-autonomic
          by A2,Th12,Th11,A1;
A7: IncIC( p,k) is Autonomy of Reloc(q,k)
       by A6,EXTPRO_1:def 12;
  P halts_on s by B4,C4,EXTPRO_1:def 11;
  then consider j1 being Element of NAT such that
A8: Result(P,s) = Comput(P,s,j1) and
A9: CurInstr(P, Result(P,s)) = halt S by EXTPRO_1:def 9;
  consider t being State of S such that
A10: IncIC( p,k) c= t by PBOOLE:141;
  consider Q being
   Instruction-Sequence of S
   such that
C10: Reloc(q,k) c= Q by PBOOLE:145;
B10: IncIC( p,k) c= t by A10;
  Q.(IC Comput(Q,t,j1)) = CurInstr(Q,Comput(Q,t,j1)) by PBOOLE:143
    .= IncAddr(CurInstr(P,Comput(P,s,j1)), k)
     by A2,Def5,C4,C10,B4,B10
    .= halt S by A8,A9,COMPOS_1:11;
  then
A12: Result(Q,t) = Comput(Q,t,j1) by EXTPRO_1:7;
A13: Comput(Q,t,j1) | dom DataPart p
        = Comput(P,s,j1) | dom DataPart p
         by A2,A1,Def6,C10,C4,B10,B4;
DPDP: DataPart p = DataPart IncIC( p,k) by MEMSTR_0:51;
aa:  p is Autonomy of q by EXTPRO_1:def 12;
  thus DataPart(Result(q, p))
     = DataPart((Result(P,s)) | dom  p) by A4,C4,aa,EXTPRO_1:def 13
    .= (Result(P,s)) | (dom  p /\ Data-Locations S) by RELAT_1:71
    .= (Result(P,s)) | dom DataPart p by MEMSTR_0:14
    .= (Result(Q,t))|(dom IncIC( p,k) /\ Data-Locations S)
          by A8,A12,A13,DPDP,MEMSTR_0:14
    .= ((Result(Q,t)) | dom IncIC( p,k))|Data-Locations S
           by RELAT_1:71
    .= DataPart Result(Reloc(q,k),IncIC( p,k))
       by A7,C10,B10,EXTPRO_1:def 13;
end;

registration let N,S;
  let q be non halt-free finite
   (the Instructions of S)-valued NAT-defined Function;
  let p be q-autonomic q-halted non empty FinPartState of S,
    k be Element of NAT;
  cluster IncIC(p,k) -> Reloc(q,k)-halted;
  coherence
   proof
     IC S in dom p by Th6;
    hence thesis by Th12;
   end;
end;

theorem
 S is CurIns-recognized relocable1 relocable2 proper-halt implies
  for F being data-only PartFunc of FinPartSt S, FinPartSt S,
      l being Element of NAT
 for q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function,
      p being q-autonomic q-halted non empty FinPartState of S
        st IC S in dom p
  for k being Element of
   NAT holds q,  p computes F
    iff Reloc(q,k), IncIC( p,k) computes F
proof assume
A1: S is CurIns-recognized relocable1 relocable2 proper-halt ;
  let F be data-only PartFunc of FinPartSt S ,FinPartSt S,
      l be Element of NAT;
  let q be non halt-free finite
    (the Instructions of S)-valued NAT-defined Function,
      p be q-autonomic q-halted non empty FinPartState of S
  such that
A2: IC S in dom p;
  let k be Element of NAT;
  hereby
    assume
A5: q,  p computes F;
    thus Reloc(q,k), IncIC( p,k) computes F
    proof
      let x be set;
      assume
A6:   x in dom F;
      then consider d1 being FinPartState of S such that
A7:   x = d1 and
A8:    p +* d1 is Autonomy of q and
A9:   F.d1 c= Result(q, p +* d1) by A5,EXTPRO_1:def 14;
      dom F c= FinPartSt S by RELAT_1:def 18;
      then reconsider d = x as FinPartState of S by A6,MEMSTR_0:76;
      reconsider d as data-only FinPartState of S by A6,MEMSTR_0:def 14;
      dom(p +* d) = dom p \/ dom d by FUNCT_4:def 1;
      then
A10:   IC S in dom(p +* d) by A2,XBOOLE_0:def 3;
A17:  p+*d is q-autonomic by A7,A8,EXTPRO_1:def 12;
    then
A18:   IncIC((p +* d) ,k) is Reloc(q,k)-autonomic
        by A10,Th11,A1;
A19:    p+*d is q-halted by A7,A8,EXTPRO_1:def 12;
  reconsider pd = p +* d
   as q-halted q-autonomic non empty FinPartState of S
         by A7,A8,EXTPRO_1:def 12;
A20:   DataPart(Result(q, pd))
     = DataPart Result(Reloc(q,k),IncIC((p+*d),k))
               by A1,A10,Th13
    .= DataPart Result(Reloc(q,k),IncIC(p,k) +* d)
            by MEMSTR_0:54;
      reconsider Fs1 = F.d1 as FinPartState of S by A9;
      take d;
      thus x=d;
   IncIC(p,k) +* d = IncIC(p+*d ,k) by MEMSTR_0:54;
      hence IncIC( p,k) +* d is Autonomy of Reloc(q,k)
            by A17,A19,A18,EXTPRO_1:def 12;
SS:  p +* d1 =  pd by A7;
A21:  Fs1 is data-only by A6,A7,MEMSTR_0:def 14;
      F.d1 c= DataPart Result(Reloc(q,k),IncIC(p,k) +* d)
         by A9,A21,SS,A20,MEMSTR_0:5;
      hence F.d c= Result(Reloc(q,k),IncIC( p,k) +* d)
      by A7,A21,MEMSTR_0:5;
    end;
  end;
  assume
A22: Reloc(q,k), IncIC( p,k) computes F;
  let x be set;
  assume
A23: x in dom F;
  then consider d1 being FinPartState of S such that
A24: x = d1 and
A25: IncIC(p,k) +* d1 is Autonomy of Reloc(q,k) and
A26: F.d1 c= Result(Reloc(q,k),IncIC(p,k) +* d1)
          by A22,EXTPRO_1:def 14;
  dom F c= FinPartSt S by RELAT_1:def 18;
  then reconsider d = x as FinPartState of S by A23,MEMSTR_0:76;
  reconsider d as data-only FinPartState of S by A23,MEMSTR_0:def 14;
B27: dom(p +* d) = dom p \/ dom d by FUNCT_4:def 1;
  then
A27: IC S in dom(p +* d) by A2,XBOOLE_0:def 3;
A32: IncIC(p,k) +* d = IncIC((p +* d),k) by MEMSTR_0:54;
 IncIC(p+*d,k) is Reloc(q,k)-autonomic
  by A24,A25,A32,EXTPRO_1:def 12;
  then
A33: p +* d is q-autonomic by A27,Th11,A1;
RR:  IncIC(p+*d,k) is Reloc(q,k)-halted
 by A24,A25,A32,EXTPRO_1:def 12;
A34: p +* d is q-halted by A27,Th12,A33,RR;
  reconsider pd = p +* d
   as q-halted q-autonomic non empty FinPartState of S
    by A27,Th12,A33,RR;
WR: IC S in dom pd by B27,A2,XBOOLE_0:def 3;
A35: DataPart Result(Reloc(q,k),IncIC(p,k) +* d1)
   = DataPart Result(Reloc(q,k),IncIC(p +* d,k)) by A24,MEMSTR_0:54
  .= DataPart(Result(q, p+*d)) by Th13,A1,WR;
  take d;
  thus x=d;
  thus  p +* d is Autonomy of q by A33,A34,EXTPRO_1:def 12;
  reconsider Fs1 = F.d1 as FinPartState of S by A26;
A37: Fs1 is data-only by A23,A24,MEMSTR_0:def 14;
  then F.d1 c= DataPart Result(q, p +* d)
   by A35,A26,MEMSTR_0:5;
  hence thesis by A24,A37,MEMSTR_0:5;
end;

reserve S for
  IC-recognized
    halting
   standard-ins IC-Ins-separated
  non empty AMI-Struct over N;

theorem
  S is CurIns-recognized implies
 for q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function
  for p being q-autonomic
   FinPartState of S st IC S in dom p holds IC p in dom q
proof assume
A1: S is CurIns-recognized;
 let q be non halt-free finite
  (the Instructions of S)-valued NAT-defined Function;
 let p be q-autonomic FinPartState of S;
 assume
A2: IC S in dom p;
  then
B2: p is non empty;
  consider s being State of S such that
A4: p c= s by PBOOLE:141;
B4:  p c= s by A4;
  set P = (the Instruction-Sequence of S) +* q;
A5: q c= P by FUNCT_4:25;
   IC Comput(P,s,0) in dom q by A5,A1,Def4,B4,B2;
  then IC s in dom q by EXTPRO_1:2;
 hence  IC p in dom q by A4,A2,GRFUNC_1:2;
end;
