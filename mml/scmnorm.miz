:: Normal Computers
::  by Andrzej Trybulec
::
:: Received March 3, 2008
:: Copyright (c) 2008 Association of Mizar Users

environ

 vocabularies AMI_1, ORDINAL1, NAT_1, ARYTM_3, NUMBERS, ARYTM_1, SUBSET_1,
      SETFAM_1, XBOOLE_0, VALUED_1, RELAT_1, TARSKI, STRUCT_0, FUNCT_1, FSM_1,
      CAT_1, FUNCT_4, AFINSQ_1, GLIB_000, AMISTD_2, CARD_1, FUNCOP_1, FINSET_1,
      PARTFUN1, CIRCUIT2, CARD_3, XXREAL_0, MSUALG_1, SCMNORM;
 notations TARSKI, XBOOLE_0, SETFAM_1, FINSET_1, SUBSET_1, RELAT_1, FUNCT_1,
      PARTFUN1, FUNCT_4, FUNCOP_1, CARD_1, CARD_3, AFINSQ_1, NUMBERS, VALUED_1,
      XXREAL_0, NAT_1, NAT_D, STRUCT_0, AMI_1;
 constructors NAT_D, AMI_1, XXREAL_0, AFINSQ_1, DOMAIN_1, RELSET_1, PRE_POLY;
 registrations ORDINAL1, XREAL_0, CARD_3, AMI_1, RELSET_1, XBOOLE_0, SETFAM_1,
      VALUED_1, RELAT_1, AFINSQ_1, FUNCT_1, CARD_1;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM;
 definitions NAT_1, AMI_1, FUNCOP_1, TARSKI, AFINSQ_1;
 theorems AMI_1, XBOOLE_1, FUNCT_2, CARD_3, VALUED_1, RELSET_1, FUNCT_4,
      RELAT_1, NAT_1, ORDINAL1, AFINSQ_1, CARD_1, ZFMISC_1, TARSKI, PARTFUN1,
      FUNCT_1, FUNCOP_1, XBOOLE_0;
 schemes NAT_1;

begin

definition
  let l be Element of NAT;
  redefine func succ l -> Element of NAT;
  coherence;
end;

reserve m,j for Element of NAT;

registration
  let N be set;
  let S be AMI-Struct over N;
  let p be NAT-defined (the Instructions of S)-valued Function,
      k be Element of NAT;
  cluster Shift(p,k) -> (the Instructions of S)-valued;
  coherence
  proof
A1: dom Shift(p,k) c= NAT by RELAT_1:def 18;
    dom p c= NAT by RELAT_1:def 18;
    then rng Shift(p,k) = rng p by VALUED_1:27;
    then rng Shift(p,k) c= the Instructions of S by RELAT_1:def 19;
    hence thesis by A1,RELSET_1:11;
  end;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  mode preProgram of S is
   NAT-defined (the Instructions of S)-valued FinPartState of S;
end;

registration
  let N be with_non-empty_elements set;
  let S be AMI-Struct over N;
  cluster empty FinPartState of S;
  existence
  proof
    {} is FinPartState of S by FUNCT_1:174,RELAT_1:206;
    hence thesis;
  end;
end;

registration
  let N be set;
  let S be AMI-Struct over N;
  cluster empty -> NAT-defined FinPartState of S;
  coherence;
end;

registration
  let N be set;
  let S be AMI-Struct over N;
  cluster initial preProgram of S;
  existence
  proof
    set e = {};
    reconsider e as preProgram of S by FUNCT_1:174,RELAT_1:206;
    take e;
    thus thesis;
  end;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  mode Program of S is initial preProgram of S;
end;

definition
 canceled 2;
  let N be non empty with_non-empty_elements set;
  let S be halting definite (non empty stored-program AMI-Struct over N);
  func Stop S -> Program of S equals
  <% halt S %>;
  coherence
  proof
    set s = <% halt S %>;
A2: 0 in NAT;
    NAT c= the carrier of S by AMI_1:def 3;
    then 0 in the carrier of S by A2;
    then
A3: 0 in dom the Object-Kind of S by FUNCT_2:def 1;
    reconsider l = 0 as Element of NAT;
    halt S in the Instructions of S;
    then halt S in (the Object-Kind of S).l by AMI_1:def 14;
    then s in sproduct the Object-Kind of S
     by A3,CARD_3:76;
    then reconsider s as FinPartState of S;
    dom s = 1 by AFINSQ_1:def 5;
    then dom s c= NAT by CARD_1:87,ZFMISC_1:37;
    hence thesis;
  end;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be halting definite (non empty stored-program AMI-Struct over N);
  cluster Stop S -> non empty;
  coherence;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be halting definite (non empty stored-program AMI-Struct over N);
  cluster non empty Program of S;
  existence
  proof
    take Stop S;
    thus thesis;
  end;
end;

reserve N for non empty with_non-empty_elements set,
  S for halting definite (non empty stored-program AMI-Struct over N);

canceled;

theorem
  0 in dom Stop S
proof dom Stop S = 1 by AFINSQ_1:36;
  hence thesis by CARD_1:87,TARSKI:def 1;
end;

theorem
  card Stop S = 1 by AFINSQ_1:36;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let I be initial FinPartState of S;
  cluster ProgramPart I -> initial Function;
  coherence
  proof
    ProgramPart I is initial
    proof
      let m,n be Nat such that
A1:   n in dom ProgramPart I and
A2:   m < n;
      m in NAT by ORDINAL1:def 13;
      then
A3:   m is Element of NAT;
      ProgramPart I c= I by RELAT_1:88;
      then dom ProgramPart I c= dom I by RELAT_1:25;
      then m in dom I by A1,A2,AFINSQ_1:def 13;
      hence thesis by A3,AMI_1:106;
    end;
    hence thesis;
  end;
end;

reserve N for non empty with_non-empty_elements set;

reserve i,j for Element of NAT;

canceled 4;

definition
 canceled 6;
  let N be non empty with_non-empty_elements set;
  let S be halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let f be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S such that
A1: f halts_on s;
  func Result(f,s) -> State of S means
  :Def10:
  ex k being Nat st it = Comput(f,s,k) & CurInstr(f,it) = halt S;
  uniqueness
  proof
    let s1,s2 be State of S;
    given k1 being Nat such that
A2: s1 = Comput(f,s,k1) and
A3: CurInstr(f,s1) = halt S;
    given k2 being Nat such that
A4: s2 = Comput(f,s,k2) and
A5: CurInstr(f,s2) = halt S;
    reconsider k1,k2 as Element of NAT by ORDINAL1:def 13;
    k1 <= k2 or k2 <= k1;
    hence thesis by A2,A3,A4,A5,AMI_1:52;
  end;
  correctness
  proof
    ex k being Nat st
    IC Comput(f,s,k) in dom f & CurInstr(f,Comput(f,s,k)) = halt S
    by A1,AMI_1:def 20;
    hence thesis;
  end;
end;

reserve j,k for Element of NAT;

theorem
  for S being IC-Ins-separated definite
  halting (non empty stored-program AMI-Struct over N)
  for s being State of S,
  f being finite NAT-defined (the Instructions of S)-valued Function,
  k st IC Comput(f,s,k) in dom f & f/.IC Comput(f,s,k) = halt S
  holds Result(f,s) = Comput(f,s,k)
proof
  let S be IC-Ins-separated definite
  halting (non empty stored-program AMI-Struct over N);
  let s be State of S;
  let f being finite NAT-defined (the Instructions of S)-valued Function, k;
  assume
A1: IC Comput(f,s,k) in dom f;
  assume f/.IC Comput(f,s,k) = halt S;
  then
A2: CurInstr(f,Comput(f,s,k)) = halt S;
  then f halts_on s by A1,AMI_1:def 20;
  hence thesis by A2,Def10;
end;

:: from RELOC, SCMFSA_4, SCMPDS_3, 2008.04.12, A.T. (generalized)

reserve N for with_non-empty_elements non empty set,
  S for IC-Ins-separated (non empty AMI-Struct over N),
  s for State of S;

theorem
  for l1,l2 being Element of NAT, k being Element of NAT holds
  Start-At(l1 + k,S) = Start-At(l2 +k,S) iff Start-At(l1,S) = Start-At(l2,S)
proof
  let l1,l2 be Element of NAT, k be Element of NAT;
  hereby
    assume
    Start-At(l1 + k,S) = Start-At(l2 + k,S);
    then {[IC S, l1 + k]} = IC S .--> (l2 + k) by FUNCT_4:87;
    then {[IC S, l1 + k]} = {[IC S, l2 + k]} by FUNCT_4:87;
    then [IC S, l1 + k] = [IC S, l2 + k] by ZFMISC_1:6;
    then l1 + k = l2 + k by ZFMISC_1:33;
    hence Start-At(l1,S) = Start-At(l2,S);
  end;
  assume Start-At(l1,S) = Start-At(l2,S);
  then {[IC S, l1]} = Start-At(l2,S) by FUNCT_4:87;
  then {[IC S, l1]} = {[IC S, l2]} by FUNCT_4:87;
  then [IC S, l1] = [IC S, l2] by ZFMISC_1:6;
  hence thesis by ZFMISC_1:33;
end;

theorem
  for l1,l2 being Element of NAT, k being Nat
  st Start-At(l1,S) = Start-At(l2,S)
   holds Start-At(l1 -' k,S) = Start-At(l2 -' k,S)
proof
  let l1,l2 be Element of NAT, k be Nat;
  assume Start-At(l1,S) = Start-At(l2,S);
  then {[IC S, l1]} = Start-At(l2,S) by FUNCT_4:87;
  then {[IC S, l1]} = {[IC S, l2]} by FUNCT_4:87;
  then [IC S, l1] = [IC S, l2] by ZFMISC_1:6;
  hence thesis by ZFMISC_1:33;
end;

definition
 canceled 2;
  let N,S;
  let p be PartState of S, k be Element of NAT;
  func IncrIC(p,k) -> PartState of S equals
  p +* Start-At(IC p+k,S);
  correctness;
end;

canceled;

theorem
  for p being FinPartState of S, k being Element of NAT
  holds DataPart IncrIC(p,k) = DataPart p
proof
  let p be FinPartState of S, k be Element of NAT;
  thus DataPart IncrIC(p,k)
  = DataPart p +* DataPart Start-At(IC p+k,S) by FUNCT_4:75
    .= DataPart p +* {} by AMI_1:138
    .= DataPart p by FUNCT_4:22;
end;

theorem Th13:
  Data-Locations S c= dom s
proof
  dom s = the carrier of S by PARTFUN1:def 4;
  hence thesis;
end;

theorem
  dom DataPart s = Data-Locations S
proof
  Data-Locations S c= dom s by Th13;
  hence thesis by RELAT_1:91;
end;

reserve N for non empty with_non-empty_elements set,
  S for halting definite IC-Ins-separated realistic
  (non empty stored-program AMI-Struct over N),
  p for FinPartState of S,
  l for Element of NAT,
  k for Element of NAT;

theorem Th15:
  NAT misses Data-Locations S
proof
  Data-Locations S misses {IC S} \/ NAT by XBOOLE_1:79;
  hence thesis by XBOOLE_1:70;
end;

canceled;

theorem Th17:
  IC S in dom Start-At(l,S)
proof
  dom Start-At(l,S) = {IC S} by FUNCOP_1:19;
  hence thesis by TARSKI:def 1;
end;

theorem Th18:
  IC S in dom IncrIC(p,k)
proof
A1: dom IncrIC(p,k) = dom p \/ dom Start-At(IC p+k,S) by FUNCT_4:def 1;
  IC S in dom Start-At(IC p+k,S) by Th17;
  hence thesis by A1,XBOOLE_0:def 3;
end;

theorem Th19:
  for p being FinPartState of S, k being Element of NAT
   holds IC IncrIC (p,k) = IC p + k
proof
  let p be FinPartState of S, k be Element of NAT;
    dom Start-At(IC p+k,S) = {IC S} by FUNCOP_1:19;
    then
A1: IC S in dom Start-At(IC p+k,S) by TARSKI:def 1;
  thus IC IncrIC (p,k) = IncrIC (p,k).IC S
    .= (Start-At((IC p)+k,S)).IC S by A1,FUNCT_4:14
    .= IC p +k by FUNCOP_1:87;
end;

theorem
  IncrIC(p,k).IC S = IC p + k
proof
 IC S in dom Start-At(IC p+k,S) by Th17;
  hence IncrIC(p,k).IC S = (Start-At(IC p+k,S)).IC S by FUNCT_4:14
    .= IC Start-At(IC p + k,S)
    .= IC p + k by FUNCOP_1:87;
end;

theorem Th21:
  not IC S in Data-Locations S
proof
  assume IC S in Data-Locations S;
  then not IC S in {IC S} \/ NAT by XBOOLE_0:def 5;
  then not IC S in {IC S} by XBOOLE_0:def 3;
  hence contradiction by TARSKI:def 1;
end;

theorem Th22:
  for d being data-only FinPartState of S
  holds not IC S in dom d
proof
  let d be data-only FinPartState of S;
  dom d c= Data-Locations S by AMI_1:139;
  hence thesis by Th21;
end;

theorem Th23:
  for d being data-only FinPartState of S
  holds IC (p+*d) = IC p
proof
  let d be data-only FinPartState of S;
A2: not IC S in dom d by Th22;
  thus IC(p+*d) = (p+*d).IC S
    .= p.IC S by A2,FUNCT_4:12
    .= IC p;
end;

theorem Th24:
  for d being data-only FinPartState of S
  holds d tolerates Start-At(l,S)
proof
  let d be data-only FinPartState of S;
  dom Start-At(l,S) = {IC S} by FUNCOP_1:19;
  then dom d misses dom Start-At(l,S) by Th22,ZFMISC_1:56;
  hence thesis by PARTFUN1:138;
end;

theorem
  for d being data-only FinPartState of S
  holds IncrIC(p+*d,k) = IncrIC(p,k) +* d
proof
  let d be data-only FinPartState of S;
A1: d tolerates Start-At(IC p+k,S) by Th24;
  thus IncrIC(p+*d,k) = p +* d +* Start-At(IC p+k,S) by Th23
    .= p +* (d +* Start-At(IC p+k,S)) by FUNCT_4:15
    .= p +* (Start-At(IC p+k,S) +* d) by A1,FUNCT_4:35
    .= IncrIC(p,k) +* d by FUNCT_4:15;
end;

theorem
  for d being data-only FinPartState of S,
  f being finite NAT-defined (the Instructions of S)-valued Function
  holds d tolerates f
proof
  let d be data-only FinPartState of S,
  f be finite NAT-defined (the Instructions of S)-valued Function;
A1: dom f c= NAT by RELAT_1:def 18;
  dom d c= Data-Locations S by AMI_1:139;
  then dom d misses dom f by A1,Th15,XBOOLE_1:64;
  hence thesis by PARTFUN1:138;
end;

theorem
  for d being data-only PartState of S
  holds ProgramPart IncrIC(d,k) = {}
proof
  let d be data-only PartState of S;
A1: dom IncrIC(d,k) = dom d \/ dom Start-At(IC d+k,S) by FUNCT_4:def 1;
A2: dom d c= Data-Locations S by AMI_1:139;
  NAT misses Data-Locations S by Th15;
  then
A3: dom d misses NAT by A2,XBOOLE_1:63;
  dom Start-At(IC d+k,S) misses NAT by AMI_1:134;
  then dom IncrIC(d,k) misses NAT by A1,A3,XBOOLE_1:70;
  hence thesis by RELAT_1:95;
end;

theorem :: AMI_1:55
  for S being IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S
  holds Comput(p,s,k+1) = Exec(p/.(IC Comput(p,s,k)), Comput(p,s,k))
proof
  let S being IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function;
 let s being State of S;
 thus Comput(p,s,k+1) = Following(p,Comput(p,s,k)) by AMI_1:14
    .= Exec(p/.IC Comput(p,s,k),Comput(p,s,k));
end;

theorem
  for p being FinPartState of S,k being Element of NAT holds
  Start-At(IC p+k,S) c= IncrIC (p,k)
proof
  let p be FinPartState of S, k be Element of NAT;
A1: IC IncrIC(p,k) = IC p + k by Th19;
A2: IC S in dom (IncrIC(p,k)) by Th18;
A3: Start-At(IC p+k,S) = {[IC S,IC p + k]} & [IC S,IC p + k] in
  IncrIC(p,k) by A2,A1,FUNCT_1:def 4,FUNCT_4:87;
  let x be set;
  assume
  x in Start-At(IC p+k,S);
  hence thesis by A3,TARSKI:def 1;
end;

theorem Th85:
  for S being halting IC-Ins-separated definite
(non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function,
  s being State of S,
    k being Nat st p halts_on s
  holds Result(p,s) = Comput(p,s,k) iff p halts_at IC Comput(p
,s,k)
proof
  let S be halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let p be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S, k being Nat;
  assume
Z0: p halts_on s;
   then consider n being Nat such that
G1: IC Comput(p,s,n) in dom p and
G2: CurInstr(p,Comput(p,s,n)) = halt S by AMI_1:def 20;
  hereby
    assume
Z:    Result(p,s) = Comput(p,s,k);
    consider i being Nat such that
W1:  Result(p,s) = Comput(p,s,i) and
W2:  CurInstr(p,Result(p,s)) = halt S by Z0,Def10;
    reconsider i,n as Element of NAT by ORDINAL1:def 13;
Y:  now per cases;
     suppose i <= n;
     hence Comput(p,s,i) = Comput(p,s,n) by W1,W2,AMI_1:52;
     end;
     suppose n <= i;
     hence Comput(p,s,i) = Comput(p,s,n) by G2,AMI_1:52;
     end;
    end;
    p.IC Comput(p,s,k) = halt S by Y,W2,Z,G1,W1,PARTFUN1:def 8;
    hence p halts_at IC Comput(p,s,k) by Y,G1,W1,Z,AMI_1:def 42;
  end;
  assume that
Z1: IC Comput(p,s,k) in dom p and
Z2:  p.IC Comput(p,s,k) = halt S;
X:  CurInstr(p,Comput(p,s,k)) = halt S by Z1,Z2,PARTFUN1:def 8;
    reconsider k,n as Element of NAT by ORDINAL1:def 13;
    now per cases;
     suppose n <= k;
     hence Comput(p,s,k) = Comput(p,s,n) by G2,AMI_1:52;
     end;
     suppose k <= n;
     hence Comput(p,s,k) = Comput(p,s,n) by X,AMI_1:52;
     end;
    end;
  hence thesis by G2,Def10,Z0;
end;

theorem Th87:
  for N for S being halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function,
  s being State of S, i st p halts_at IC Comput(p,s,i)
   holds Result(p,s) = Comput(p,s,i)
proof let N;
  let S be halting IC-Ins-separated definite (non empty
   stored-program AMI-Struct over N),
   p be finite NAT-defined (the Instructions of S)-valued Function,
   s be State of S, i;
  assume
A1: p halts_at IC Comput(p,s,i);
  then p halts_on s by AMI_1:83;
  hence thesis by A1,Th85;
end;

theorem Th88:
  i <= j implies for N for S being halting definite
IC-Ins-separated (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s
  being State of S st p halts_at IC Comput(p,s,i)
   holds p halts_at IC Comput(p,s,j)
proof
  assume
A1: i <= j;
  let N;
  let S be halting IC-Ins-separated definite (non empty
     stored-program AMI-Struct over N),
   p be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S;
  assume that
A3: IC Comput(p,s,i) in dom p and
A2: p.IC Comput(p,s,i) = halt S;
X: CurInstr(p,Comput(p,s,i)) = halt S by A3,A2,PARTFUN1:def 8;
  hence IC Comput(p,s,j) in dom p by A3,A1,AMI_1:52;
  thus p.IC Comput(p,s,j) = halt S by A1,A2,X,AMI_1:52;
end;

theorem :: AMI_1:89
  i <= j implies for N for S being halting IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S st p halts_at IC Comput(p,s,i)
   holds Comput(p,s,j) = Comput(p,s,i)
proof
  assume
A1: i <= j;
  let N;
  let S be halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
      p be finite NAT-defined (the Instructions of S)-valued Function,
      s be State of S;
  assume
A2: p halts_at IC Comput(p,s,i);
  then p halts_at IC Comput(p,s,j) by A1,Th88;
  hence Comput(p,s,j) = Result(p,s) by Th87
    .= Comput(p,s,i) by A2,Th87;
end;

theorem Th51:
   for N for S being halting definite
IC-Ins-separated (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S
  for k holds Comput(p,s,i+k) = Comput(p,Comput(p,s,i),k)
proof
   let N; let S being halting definite
IC-Ins-separated (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function;
 let s being State of S;
  defpred P[Element of NAT]
   means Comput(p,s,i+$1) = Comput(p,Comput(p,s,i),$1);
A1: now
    let k;
    assume
A2: P[k];
    Comput(p,s,i+(k+1)) = Comput(p,s,i+k+1)
      .= Following(p,Comput(p,s,i+k)) by AMI_1:14
      .= Comput(p,Comput(p,s,i),k+1) by A2,AMI_1:14;
    hence P[k+1];
  end;
A3: P[ 0] by AMI_1:13;
  thus for k holds P[k] from NAT_1:sch 1(A3,A1);
end;

theorem Th56:
  for N
  for S being IC-Ins-separated halting definite
(non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
for s being State of S, k
    st IC Comput(p,s,k) in dom p & p.IC Comput(p,s,k) = halt S
  holds Result(p,s) = Comput(p,s,k)
proof let N;
  let S be IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N);
  let p be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S, k;
  assume
Z1:  IC Comput(p,s,k) in dom p;
  assume
     p.IC Comput(p,s,k) = halt S;
  then
A1: CurInstr(p,Comput(p,s,k)) = halt S by Z1,PARTFUN1:def 8;
  then p halts_on s by Z1,AMI_1:def 20;
  hence thesis by A1,Def10;
end;

theorem Th57:
  for N
  for S being IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S st
  ex k st IC Comput(p,s,k) in dom p & p.IC Comput(p,s,k) = halt S
 for i holds Result(p,s) = Result(p,Comput(p,s,i))
proof let N;
  let S be  IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N);
  let p be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S;
  given k such that
A0: IC Comput(p,s,k) in dom p and
A1: p.IC Comput(p,s,k) = halt S;
  let i;
  set s9 = Comput(p,s,k);
A2: CurInstr(p,s9) = halt S by A0,A1,PARTFUN1:def 8;
  now
    per cases;
    suppose
      i <= k;
      then consider j being Nat such that
A3:   k = i + j by NAT_1:10;
      reconsider j as Element of NAT by ORDINAL1:def 13;
A4:   Comput(p,s,k) = Comput(p,Comput(p,s,i),j) by A3,Th51;
      then
A5:   p halts_on Comput(p,s,i) by A0,A2,AMI_1:def 20;
      thus Result(p,s) = s9 by A0,A1,Th56
        .= Result(p,Comput(p,s,i)) by A2,A4,A5,Def10;
    end;
    suppose
A6:   i >= k;
A7:   Comput(p,Comput(p,s,k),0) = Comput(p,s,k) by AMI_1:13;
A8:   Comput(p,s,i) = s9 by A2,A6,AMI_1:52;
      then
A9:   p halts_on Comput(p,s,i) by A0,A2,A7,AMI_1:def 20;
      thus Result(p,s) = s9 by A0,A1,Th56
        .= Result(p,Comput(p,s,i)) by A2,A8,A7,A9,Def10;
    end;
  end;
  hence thesis;
end;

theorem
  for N
  for S being IC-Ins-separated halting definite (non
empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S st
  ex k st p halts_at IC Comput(p,s,k)
   for i holds Result(p,s) = Result(p,Comput(p,s,i))
proof let N;
  let S be IC-Ins-separated halting definite (non empty
   stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function,
    s be State of S;
  given k such that
A1: p halts_at IC Comput(p,s,k);
A2: IC Comput(p,s,k) in dom p by A1,AMI_1:def 42;
  let i;
  p.IC Comput(p,s,k) = halt S by A1,AMI_1:def 42;
  hence thesis by A2,Th57;
end;

theorem
  for N
  for S being IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function,
      s being State of S holds
  p halts_on s iff ex k being Nat st p halts_at IC Comput(p,s,k)
proof let N;
  let S be IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N);
  let p be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S;
  hereby
    assume
    p halts_on s;
    then consider k being Nat such that
A0: IC Comput(p,s,k) in dom p and
A1: CurInstr(p,Comput(p,s,k)) = halt S by AMI_1:def 20;
    take k;
    p.IC Comput(p,s,k) = halt S by A1,A0,PARTFUN1:def 8;
    hence p halts_at IC Comput(p,s,k) by A0,AMI_1:def 42;
  end;
  given k being Nat such that
A2: p halts_at IC Comput(p,s,k);
  take k;
  thus
K:  IC Comput(p,s,k) in dom p by A2,AMI_1:def 42;
  thus CurInstr(p,Comput(p,s,k)) = p/.IC Comput(p,s,k)
    .= p.IC Comput(p,s,k) by K,PARTFUN1:def 8
    .= halt S by A2,AMI_1:def 42;
end;

theorem
 IC Start-At(l,S) = l by FUNCOP_1:87;
