:: Normal Computers
::  by Andrzej Trybulec
::
:: Received March 3, 2008
:: Copyright (c) 2008 Association of Mizar Users

environ

 vocabularies AMI_1, ORDINAL1, NAT_1, ARYTM_3, NUMBERS, ARYTM_1, SUBSET_1,
      SETFAM_1, XBOOLE_0, VALUED_1, RELAT_1, TARSKI, STRUCT_0, FUNCT_1, FSM_1,
      CAT_1, FUNCT_4, AFINSQ_1, GLIB_000, AMISTD_2, CARD_1, FUNCOP_1, FINSET_1,
      PARTFUN1, CIRCUIT2, CARD_3, XXREAL_0, MSUALG_1, TURING_1, SCMNORM,
      PBOOLE;
 notations TARSKI, XBOOLE_0, SETFAM_1, ORDINAL1, FINSET_1, SUBSET_1, RELAT_1,
      FUNCT_1, PBOOLE, FUNCT_2, PARTFUN1,
      FUNCT_4, FUNCOP_1, CARD_1, CARD_3, AFINSQ_1,
      NUMBERS, VALUED_1, XXREAL_0, XCMPLX_0, XREAL_0, NAT_1, NAT_D, STRUCT_0,
      AMI_1;
 constructors NAT_1, NAT_D, AMI_1, VALUED_1, XXREAL_0, AFINSQ_1, FUNCT_4,
      DOMAIN_1, PARTFUN1, WELLORD2, RELSET_1, PRE_POLY, PBOOLE;
 registrations ORDINAL1, XREAL_0, CARD_3, AMI_1, RELSET_1, XBOOLE_0, SETFAM_1,
      VALUED_1, RELAT_1, FINSET_1, AFINSQ_1, FUNCT_1, FINSEQ_1, CARD_1, NAT_1,
      GRFUNC_1, PBOOLE, FRAENKEL, FUNCT_2, FUNCT_4;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM;
 definitions NAT_1, TARSKI, XBOOLE_0, AMI_1, FUNCOP_1, RELAT_1, PBOOLE;
 theorems AMI_1, XBOOLE_1, FUNCT_2, GRFUNC_1, CARD_3, VALUED_1, RELSET_1,
      FUNCT_4, RELAT_1, NAT_1, ORDINAL1, AFINSQ_1, CARD_1, ZFMISC_1, TARSKI,
      PARTFUN1, FUNCT_1, FUNCOP_1, XBOOLE_0, PBOOLE;
 schemes NAT_1;

begin

definition
  let l be Element of NAT;
  redefine func succ l -> Element of NAT;
  coherence;
end;

reserve m,j for Element of NAT;

definition
  let N be with_non-empty_elements non empty set,
  S be definite (stored-program non empty AMI-Struct over N);
  let p be PartState of S, k be Element of NAT;
  redefine func Shift(p,k) -> PartState of S;
  coherence
  proof
    set A = { m+k:m in dom p }, B = { m:m in dom p};
    set f = Shift(p,k);
A1: dom f = A by VALUED_1:def 12;
A2: A c= NAT
    proof
      let x be set;
      assume x in A;
      then ex m st x = m+k & m in dom p;
      hence thesis;
    end;
    NAT c= the carrier of S by AMI_1:def 3;
    then
A3: dom f c= the carrier of S by A1,A2,XBOOLE_1:1;
    for x being set st x in dom f holds f.x in (the Object-Kind of S). x
    proof
      let x be set;
      assume
A4:   x in dom f;
      then x in A by VALUED_1:def 12;
      then consider m such that
A5:   x = m+k and
A6:   m in dom p;
A7:   f.x = p.m by A5,A6,VALUED_1:def 12;
      reconsider y = x as Element of NAT by A1,A2,A4;
A8:   (the Object-Kind of S).y = the Instructions of S by AMI_1:def 14;
      consider s being State of S such that
A9:   p c= s by PBOOLE:156;
A10:  ex j st ( m+k = j+k)&( j in dom p) by A1,A4,A5;
      reconsider m as Element of NAT;
      s.m in the Instructions of S;
      hence thesis by A7,A8,A9,A10,GRFUNC_1:8;
    end;
    hence thesis by A3,FUNCT_1:def 20,RELAT_1:def 18;
  end;
end;

registration
  let N be set;
  let S be AMI-Struct over N;
  let p be NAT-defined (the Instructions of S)-valued Function,
      k be Element of NAT;
  cluster Shift(p,k) -> (the Instructions of S)-valued;
  coherence
  proof
A1: dom Shift(p,k) c= NAT by RELAT_1:def 18;
    dom p c= NAT by RELAT_1:def 18;
    then rng Shift(p,k) = rng p by VALUED_1:27;
    then rng Shift(p,k) c= the Instructions of S by RELAT_1:def 19;
    hence thesis by A1,RELSET_1:11;
  end;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  mode preProgram of S is NAT-defined FinPartState of S;
end;

definition
  let F be Function;
  attr F is initial means
  :Def1:
  for m,n being Nat st n in dom F & m < n holds m in dom F;
end;

registration
  cluster empty -> initial Function;
  coherence
  proof
    let F be Function such that
A1: F is empty;
    let n be Nat;
    thus thesis by A1;
  end;
end;

registration
  let N be with_non-empty_elements set;
  let S be AMI-Struct over N;
  cluster empty FinPartState of S;
  existence
  proof
    {} is FinPartState of S by FUNCT_1:174,RELAT_1:206;
    hence thesis;
  end;
end;

registration
  let N be set;
  let S be AMI-Struct over N;
  cluster empty -> NAT-defined FinPartState of S;
  coherence
  proof
    let p be FinPartState of S;
    assume p is empty;
    hence dom p c= NAT by RELAT_1:60,XBOOLE_1:2;
  end;
end;

registration
  let N be set;
  let S be AMI-Struct over N;
  cluster initial preProgram of S;
  existence
  proof
    set e = {};
    reconsider e as preProgram of S by FUNCT_1:174,RELAT_1:206;
    take e;
    thus thesis;
  end;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  mode Program of S is initial preProgram of S;
end;

registration
  cluster -> initial XFinSequence;
  coherence
  proof
    let p be XFinSequence;
    let m,n being Nat such that
A1: n in dom p;
    assume m < n;
    then m in n by NAT_1:45;
    hence m in dom p by A1,ORDINAL1:19;
  end;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be halting definite (non empty stored-program AMI-Struct over N);
  func Stop S -> Program of S equals
  <% halt S %>;
  coherence
  proof
    set s = <% halt S %>;
A1: s = 0 .--> halt S by AFINSQ_1:def 2;
A2: 0 in NAT;
    NAT c= the carrier of S by AMI_1:def 3;
    then 0 in the carrier of S by A2;
    then
A3: 0 in dom the Object-Kind of S by FUNCT_2:def 1;
    reconsider l = 0 as Element of NAT;
    halt S in the Instructions of S;
    then halt S in (the Object-Kind of S).l by AMI_1:def 14;
    then s in sproduct the Object-Kind of S
     by A1,A3,CARD_3:76;
    then reconsider s as FinPartState of S;
    dom s = 1 by AFINSQ_1:def 5;
    then dom s c= NAT by CARD_1:87,ZFMISC_1:37;
    hence thesis by RELAT_1:def 18;
  end;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be halting definite (non empty stored-program AMI-Struct over N);
  cluster Stop S -> non empty;
  coherence;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be halting definite (non empty stored-program AMI-Struct over N);
  cluster initial NAT-defined non empty FinPartState of S;
  existence
  proof
    take Stop S;
    thus thesis;
  end;
end;

reserve N for non empty with_non-empty_elements set,
  S for halting definite (non empty stored-program AMI-Struct over N);

canceled;

theorem
  0 in dom Stop S
proof dom Stop S = 1 by AFINSQ_1:36;
  hence thesis by CARD_1:87,TARSKI:def 1;
end;

theorem
  card Stop S = 1
proof
  thus card Stop S = card dom Stop S by CARD_1:104
    .= dom Stop S by CARD_1:def 5
    .= 1 by AFINSQ_1:36;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be definite (non empty stored-program AMI-Struct over N);
  let p be FinPartState of S;
  cluster ProgramPart p ->
   finite NAT-defined (the Instructions of S)-valued Function;
  coherence
  proof
A1: dom ProgramPart p c= NAT by RELAT_1:87;
    rng ProgramPart p c= the Instructions of S
    proof
      let x be set;
      assume x in rng ProgramPart p;
      then consider y being set such that
A2:   y in dom ProgramPart p and
A3:   x = (ProgramPart p).y by FUNCT_1:def 5;
      reconsider y as Element of NAT by A1,A2;
      consider s being State of S such that
A4:   p c= s by PBOOLE:156;
      dom ProgramPart p c= dom p by RELAT_1:89;
      then p.y = s.y by A2,A4,GRFUNC_1:8;
      then p.y in the Instructions of S;
      hence thesis by A2,A3,FUNCT_1:70;
    end;
   hence thesis by A1,RELSET_1:11;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let I be initial FinPartState of S;
  cluster ProgramPart I -> initial Function;
  coherence
  proof
    ProgramPart I is initial
    proof
      let m,n be Nat such that
A1:   n in dom ProgramPart I and
A2:   m < n;
      m in NAT by ORDINAL1:def 13;
      then
A3:   m is Element of NAT;
      ProgramPart I c= I by RELAT_1:88;
      then dom ProgramPart I c= dom I by RELAT_1:25;
      then m in dom I by A1,A2,Def1;
      hence thesis by A3,AMI_1:106;
    end;
    hence thesis;
  end;
end;

definition
  canceled 4;
  let N be non empty with_non-empty_elements set;
  let S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let p be finite NAT-defined (the Instructions of S)-valued Function;
  mode Autonomy of p -> FinPartState of S means
    :Def7:
    for s1,s2 being State of S st it c= s1 & it c= s2
    for q being finite NAT-defined (the Instructions of S)-valued Function
    st p c= q
    for i being Nat holds Comput(p,s1,i)|dom it = Comput(q,s2,i)|dom it;
  existence
  proof
    reconsider a = {} as FinPartState of S by FUNCT_1:174,RELAT_1:206;
    take a;
    let s1,s2 be State of S such that a c= s1
    and a c= s2;
    let q be finite NAT-defined (the Instructions of S)-valued Function
    such that p c= q;
    let i be Nat;
    thus Comput(p,s1,i)|dom a = {}
      .= Comput(q,s2,i)|dom a;
  end;
end;

reserve N for non empty with_non-empty_elements set;

definition
  let N be non empty with_non-empty_elements set;
  let S be IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N);
  let f be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S;
  pred f halts_on s means
  :Def8:
  ex n being Nat st
  IC Comput(f,s,n) in dom f & CurInstr(f,Comput(f,s,n)) = halt S;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N);
  let f be finite NAT-defined (the Instructions of S)-valued Function;
  let p be Autonomy of f;
  attr p is halting means
  :Def9:
  for s being State of S st p c= s holds
  f halts_on s;
end;

reserve i,j for Nat;

canceled 3;

theorem Th7:
  i <= j implies for N for S being halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  f be finite NAT-defined (the Instructions of S)-valued Function
  for s being State of S st CurInstr(f,Comput(f,s,i)) = halt S
  holds Comput(f,s,j) = Comput(f,s,i)
proof
  assume i <= j;
  then consider k being Nat such that
A1: j = i + k by NAT_1:10;
  reconsider k as Element of NAT by ORDINAL1:def 13;
A2: j = i + k by A1;
  let N;
  let S be halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  f be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S such that
A3: CurInstr(f,Comput(f,s,i)) = halt S;
  defpred P[Element of NAT] means Comput(f,s,i+$1) = Comput(f,s,i);
A4: P[ 0];
A5: now
    let k be Element of NAT;
    assume
A6: P[k];
    Comput(f,s,i+(k+1)) = Comput(f,s,i+k+1)
      .= Following(f,Comput(f,s,i+k)) by AMI_1:14
      .= Comput(f,s,i) by A3,A6,AMI_1:def 8;
    hence P[k+1];
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A4,A5);
  hence thesis by A2;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let f be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S such that
A1: f halts_on s;
  func Result(f,s) -> State of S means
  :Def10:
  ex k being Nat st it = Comput(f,s,k) & CurInstr(f,it) = halt S;
  uniqueness
  proof
    let s1,s2 be State of S;
    given k1 being Nat such that
A2: s1 = Comput(f,s,k1) and
A3: CurInstr(f,s1) = halt S;
    given k2 being Nat such that
A4: s2 = Comput(f,s,k2) and
A5: CurInstr(f,s2) = halt S;
    k1 <= k2 or k2 <= k1;
    hence thesis by A2,A3,A4,A5,Th7;
  end;
  correctness
  proof
    ex k being Nat st
    IC Comput(f,s,k) in dom f & CurInstr(f,Comput(f,s,k)) = halt S by A1,Def8;
    hence thesis;
  end;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be realistic halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let f be finite NAT-defined (the Instructions of S)-valued Function;
  let p be Autonomy of f;
  assume
A1: p is halting;
  consider h being State of S such that
A2: p c= h by PBOOLE:156;
  func Result(f,p) -> FinPartState of S means
  for p9 being State of S st p c= p9 holds it = Result(f, p9)|dom p;
  existence
  proof
    reconsider R = (Result(f,h))|dom p as FinPartState of S;
    take R;
    let p9 be State of S such that
A3: p c= p9;
    f halts_on h by A1,A2,Def9;
    then consider k1 being Nat such that
A4: Result(f,h) = Comput(f,h,k1) and
A5: CurInstr(f,Result(f,h)) = halt S by Def10;
    f halts_on p9 by A1,A3,Def9;
    then consider k2 being Nat such that
A6: Result(f,p9) = Comput(f,p9,k2) and
A7: CurInstr(f,Result(f,p9)) = halt S by Def10;
    now per cases;
      suppose k1 <= k2;
        then Result(f,h) = Comput(f,h,k2) by A4,A5,Th7;
        hence thesis by A2,A3,A6,Def7;
      end;
      suppose k1 >= k2;
        then Result(f,p9) = Comput(f,p9,k1) by A6,A7,Th7;
        hence thesis by A2,A3,A4,Def7;
      end;
    end;
    hence thesis;
  end;
  correctness
  proof
    let p1,p2 be FinPartState of S such that
A8: for p9 being State of S st p c= p9 holds p1 = (Result(f,p9))|dom p and
A9: for p9 being State of S st p c= p9 holds p2 = (Result(f,p9))|dom p;
    thus p1 = (Result(f,h))|dom p by A2,A8
      .= p2 by A2,A9;
  end;
end;

definition
  let N be non empty with_non-empty_elements set;
let S be realistic halting IC-Ins-separated definite
(non empty stored-program AMI-Struct over N);
  let f be finite NAT-defined (the Instructions of S)-valued Function;
  let p be FinPartState of S, F be Function;
  pred f,p computes F means
  for s being FinPartState of S st s in dom F
  ex q being Autonomy of f st q = p +* s & q is halting & F.s c= Result(f,q);
end;

reserve j,k for Element of NAT;

theorem
  for S being IC-Ins-separated definite
  halting (non empty stored-program AMI-Struct over N)
  for s being State of S,
  f being finite NAT-defined (the Instructions of S)-valued Function,
  k st IC Comput(f,s,k) in dom f & f/.IC Comput(f,s,k) = halt S
  holds Result(f,s) = Comput(f,s,k)
proof
  let S be IC-Ins-separated definite
  halting (non empty stored-program AMI-Struct over N);
  let s be State of S;
  let f being finite NAT-defined (the Instructions of S)-valued Function, k;
  assume
A1: IC Comput(f,s,k) in dom f;
  assume f/.IC Comput(f,s,k) = halt S;
  then
A2: CurInstr(f,Comput(f,s,k)) = halt S;
  then f halts_on s by A1,Def8;
  hence thesis by A2,Def10;
end;

:: from RELOC, SCMFSA_4, SCMPDS_3, 2008.04.12, A.T. (generalized)

reserve N for with_non-empty_elements non empty set,
  S for IC-Ins-separated (non empty AMI-Struct over N),
  s for State of S;

theorem
  for l1,l2 being Element of NAT, k being Element of NAT holds
  Start-At(l1 + k,S) = Start-At(l2 +k,S) iff Start-At(l1,S) = Start-At(l2,S)
proof
  let l1,l2 be Element of NAT, k be Element of NAT;
  hereby
    assume
    Start-At(l1 + k,S) = Start-At(l2 + k,S);
    then {[IC S, l1 + k]} = IC S .--> (l2 + k) by FUNCT_4:87;
    then {[IC S, l1 + k]} = {[IC S, l2 + k]} by FUNCT_4:87;
    then [IC S, l1 + k] = [IC S, l2 + k] by ZFMISC_1:6;
    then l1 + k = l2 + k by ZFMISC_1:33;
    hence Start-At(l1,S) = Start-At(l2,S);
  end;
  assume Start-At(l1,S) = Start-At(l2,S);
  then {[IC S, l1]} = Start-At(l2,S) by FUNCT_4:87;
  then {[IC S, l1]} = {[IC S, l2]} by FUNCT_4:87;
  then [IC S, l1] = [IC S, l2] by ZFMISC_1:6;
  hence thesis by ZFMISC_1:33;
end;

theorem
  for l1,l2 being Element of NAT, k being Nat
  st Start-At(l1,S) = Start-At(l2,S)
   holds Start-At(l1 -' k,S) = Start-At(l2 -' k,S)
proof
  let l1,l2 be Element of NAT, k be Nat;
  assume Start-At(l1,S) = Start-At(l2,S);
  then {[IC S, l1]} = Start-At(l2,S) by FUNCT_4:87;
  then {[IC S, l1]} = {[IC S, l2]} by FUNCT_4:87;
  then [IC S, l1] = [IC S, l2] by ZFMISC_1:6;
  hence thesis by ZFMISC_1:33;
end;

definition
  let N,S;
  let p be FinPartState of S, k be Element of NAT;
  func IncrIC(p,k) -> FinPartState of S equals
  p +* Start-At(IC p+k,S);
  correctness;
end;

theorem
  for l being Element of NAT
  holds DataPart Start-At(l,S) = {} by AMI_1:138;

theorem
  for p being FinPartState of S, k being Element of NAT
  holds DataPart IncrIC(p,k) = DataPart p
proof
  let p be FinPartState of S, k be Element of NAT;
  thus DataPart IncrIC(p,k)
  = DataPart p +* DataPart Start-At(IC p+k,S) by FUNCT_4:75
    .= DataPart p +* {} by AMI_1:138
    .= DataPart p by FUNCT_4:22;
end;

definition
  let N,S;
  let s be State of S;
  func DataPart s -> PartState of S equals
  s | Data-Locations S;
  coherence;
end;

theorem Th13:
  Data-Locations S c= dom s
proof
  dom s = the carrier of S by PARTFUN1:def 4;
  hence thesis;
end;

theorem
  dom DataPart s = Data-Locations S
proof
  Data-Locations S c= dom s by Th13;
  hence thesis by RELAT_1:91;
end;

reserve N for non empty with_non-empty_elements set,
  S for halting definite IC-Ins-separated realistic
  (non empty stored-program AMI-Struct over N),
  p for FinPartState of S,
  l for Element of NAT,
  k for Element of NAT;

theorem Th15:
  NAT misses Data-Locations S
proof
  Data-Locations S misses {IC S} \/ NAT by XBOOLE_1:79;
  hence thesis by XBOOLE_1:70;
end;

canceled;

theorem Th17:
  IC S in dom Start-At(l,S)
proof
  dom Start-At(l,S) = {IC S} by FUNCOP_1:19;
  hence thesis by TARSKI:def 1;
end;

theorem
  IC S in dom IncrIC(p,k)
proof
A1: dom IncrIC(p,k) = dom p \/ dom Start-At(IC p+k,S) by FUNCT_4:def 1;
  IC S in dom Start-At(IC p+k,S) by Th17;
  hence thesis by A1,XBOOLE_0:def 3;
end;

theorem Th19:
  IC Start-At(l,S) = l
proof
  thus IC Start-At(l,S) = (Start-At(l,S)).IC S
    .= l by FUNCOP_1:87;
end;

theorem
  IncrIC(p,k).IC S = IC p + k
proof
 IC S in dom Start-At(IC p+k,S) by Th17;
  hence IncrIC(p,k).IC S = (Start-At(IC p+k,S)).IC S by FUNCT_4:14
    .= IC Start-At(IC p + k,S)
    .= IC p + k by Th19;
end;

theorem Th21:
  not IC S in Data-Locations S
proof
  assume IC S in Data-Locations S;
  then not IC S in {IC S} \/ NAT by XBOOLE_0:def 5;
  then not IC S in {IC S} by XBOOLE_0:def 3;
  hence contradiction by TARSKI:def 1;
end;

theorem Th22:
  for d being data-only FinPartState of S
  holds not IC S in dom d
proof
  let d be data-only FinPartState of S;
  dom d c= Data-Locations S by AMI_1:139;
  hence thesis by Th21;
end;

theorem Th23:
  for d being data-only FinPartState of S
  holds IC (p+*d) = IC p
proof
  let d be data-only FinPartState of S;
A2: not IC S in dom d by Th22;
  thus IC(p+*d) = (p+*d).IC S
    .= p.IC S by A2,FUNCT_4:12
    .= IC p;
end;

theorem Th24:
  for d being data-only FinPartState of S
  holds d tolerates Start-At(l,S)
proof
  let d be data-only FinPartState of S;
  dom Start-At(l,S) = {IC S} by FUNCOP_1:19;
  then dom d misses dom Start-At(l,S) by Th22,ZFMISC_1:56;
  hence thesis by PARTFUN1:138;
end;

theorem
  for d being data-only FinPartState of S
  holds IncrIC(p+*d,k) = IncrIC(p,k) +* d
proof
  let d be data-only FinPartState of S;
A1: d tolerates Start-At(IC p+k,S) by Th24;
  thus IncrIC(p+*d,k) = p +* d +* Start-At(IC p+k,S) by Th23
    .= p +* (d +* Start-At(IC p+k,S)) by FUNCT_4:15
    .= p +* (Start-At(IC p+k,S) +* d) by A1,FUNCT_4:35
    .= IncrIC(p,k) +* d by FUNCT_4:15;
end;

theorem
  for d being data-only FinPartState of S,
  f being finite NAT-defined (the Instructions of S)-valued Function
  holds d tolerates f
proof
  let d be data-only FinPartState of S,
  f be finite NAT-defined (the Instructions of S)-valued Function;
A1: dom f c= NAT by RELAT_1:def 18;
  dom d c= Data-Locations S by AMI_1:139;
  then dom d misses dom f by A1,Th15,XBOOLE_1:64;
  hence thesis by PARTFUN1:138;
end;

theorem
  for d being data-only FinPartState of S
  holds IncrIC(d,k)|NAT = {}
proof
  let d be data-only FinPartState of S;
A1: dom IncrIC(d,k) = dom d \/ dom Start-At(IC d+k,S) by FUNCT_4:def 1;
A2: dom d c= Data-Locations S by AMI_1:139;
  NAT misses Data-Locations S by Th15;
  then
A3: dom d misses NAT by A2,XBOOLE_1:63;
  dom Start-At(IC d+k,S) misses NAT by AMI_1:134;
  then dom IncrIC(d,k) misses NAT by A1,A3,XBOOLE_1:70;
  hence thesis by RELAT_1:95;
end;

theorem :: AMI_1:55
  for S being IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S
  holds Comput(p,s,k+1) = Exec(p/.(IC Comput(p,s,k)), Comput(p,s,k))
proof
  let S being IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function;
 let s being State of S;
 thus Comput(p,s,k+1) = Following(p,Comput(p,s,k)) by AMI_1:14
    .= Exec(p/.IC Comput(p,s,k),Comput(p,s,k));
end;

definition
  let N;
  let S be IC-Ins-separated halting
  (non empty AMI-Struct over N);
  let p be finite NAT-defined (the Instructions of S)-valued Function,
      l be set;
  pred p halts_at l means :: AMI_1:def 45
:Def15: l in dom p & p.l = halt S;
end;

theorem Th83:
  for S being IC-Ins-separated halting definite
(non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function,
    s being State of S holds p halts_on s
   iff ex i st p halts_at IC Comput(p,s,i)
proof
  let S be IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N);
  let p be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S;
  hereby
    assume
    p halts_on s;
    then consider i such that
A0: IC Comput(p,s,i) in dom p and
A1: CurInstr(p,Comput(p,s,i)) = halt S by Def8;
    take i;
    p.IC Comput(p,s,i) = halt S by A0,A1,PARTFUN1:def 8;
    hence p halts_at IC Comput(p,s,i) by A0,Def15;
  end;
  given i such that
A0: p halts_at IC Comput(p,s,i);
A2: IC Comput(p,s,i) in dom p by A0,Def15;
A3: p.IC Comput(p,s,i) = halt S by A0,Def15;
  take i;
  thus IC Comput(p,s,i) in dom p by A0,Def15;
  thus CurInstr(p,Comput(p,s,i)) = p/.IC Comput(p,s,i)
    .= halt S by A2,A3,PARTFUN1:def 8;
end;

theorem Th85:
  for S being halting IC-Ins-separated definite
(non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function,
  s being State of S,
    k being Nat st p halts_on s
  holds Result(p,s) = Comput(p,s,k) iff p halts_at IC Comput(p,s,k)
proof
  let S be halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let p be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S, k being Nat;
  assume
Z0: p halts_on s;
   then consider n being Nat such that
G1: IC Comput(p,s,n) in dom p and
G2: CurInstr(p,Comput(p,s,n)) = halt S by Def8;
  hereby
    assume
Z:    Result(p,s) = Comput(p,s,k);
    consider i such that
W1:  Result(p,s) = Comput(p,s,i) and
W2:  CurInstr(p,Result(p,s)) = halt S by Z0,Def10;
Y:  now per cases;
     suppose i <= n;
     hence Comput(p,s,i) = Comput(p,s,n) by Th7,W1,W2;
     end;
     suppose n <= i;
     hence Comput(p,s,i) = Comput(p,s,n) by Th7,G2;
     end;
    end;
    p.IC Comput(p,s,k) = halt S by Y,W2,Z,G1,W1,PARTFUN1:def 8;
    hence p halts_at IC Comput(p,s,k) by Def15,Y,G1,W1,Z;
  end;
  assume that
Z1: IC Comput(p,s,k) in dom p and
Z2:  p.IC Comput(p,s,k) = halt S;
X:  CurInstr(p,Comput(p,s,k)) = halt S by Z1,Z2,PARTFUN1:def 8;
    now per cases;
     suppose n <= k;
     hence Comput(p,s,k) = Comput(p,s,n) by Th7,G2;
     end;
     suppose k <= n;
     hence Comput(p,s,k) = Comput(p,s,n) by Th7,X;
     end;
    end;
  hence Result(p,s) = Comput(p,s,k) by G2,Def10,Z0;
end;

theorem Th87:
  for N for S being halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function,
  s being State of S, i st p halts_at IC Comput(p,s,i)
   holds Result(p,s) = Comput(p,s,i)
proof let N;
  let S be halting IC-Ins-separated definite (non empty
   stored-program AMI-Struct over N),
   p be finite NAT-defined (the Instructions of S)-valued Function,
   s be State of S, i;
  assume
A1: p halts_at IC Comput(p,s,i);
  then p halts_on s by Th83;
  hence thesis by A1,Th85;
end;

theorem Th88:
  i <= j implies for N for S being halting definite
IC-Ins-separated (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s
  being State of S st p halts_at IC Comput(p,s,i)
   holds p halts_at IC Comput(p,s,j)
proof
  assume
A1: i <= j;
  let N;
  let S be halting IC-Ins-separated definite (non empty
     stored-program AMI-Struct over N),
   p be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S;
  assume that
A3: IC Comput(p,s,i) in dom p and
A2: p.IC Comput(p,s,i) = halt S;
X: CurInstr(p,Comput(p,s,i)) = halt S by A3,A2,PARTFUN1:def 8;
  hence IC Comput(p,s,j) in dom p by A3,A1,Th7;
  thus p.IC Comput(p,s,j) = halt S by A1,A2,Th7,X;
end;

theorem :: AMI_1:89
  i <= j implies for N for S being halting IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S st p halts_at IC Comput(p,s,i)
   holds Comput(p,s,j) = Comput(p,s,i)
proof
  assume
A1: i <= j;
  let N;
  let S be halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
      p be finite NAT-defined (the Instructions of S)-valued Function,
      s be State of S;
  assume
A2: p halts_at IC Comput(p,s,i);
  then p halts_at IC Comput(p,s,j) by A1,Th88;
  hence Comput(p,s,j) = Result(p,s) by Th87
    .= Comput(p,s,i) by A2,Th87;
end;

theorem Th51:
   for N for S being halting definite
IC-Ins-separated (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S
  for k holds Comput(p,s,i+k) = Comput(p,Comput(p,s,i),k)
proof
   let N; let S being halting definite
IC-Ins-separated (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function;
 let s being State of S;
  defpred P[Element of NAT]
   means Comput(p,s,i+$1) = Comput(p,Comput(p,s,i),$1);
A1: now
    let k;
    assume
A2: P[k];
    Comput(p,s,i+(k+1)) = Comput(p,s,i+k+1)
      .= Following(p,Comput(p,s,i+k)) by AMI_1:14
      .= Comput(p,Comput(p,s,i),k+1) by A2,AMI_1:14;
    hence P[k+1];
  end;
A3: P[ 0] by AMI_1:13;
  thus for k holds P[k] from NAT_1:sch 1(A3,A1);
end;

theorem Th56:
  for N
  for S being IC-Ins-separated halting definite
(non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
for s being State of S, k
    st IC Comput(p,s,k) in dom p & p.IC Comput(p,s,k) = halt S
  holds Result(p,s) = Comput(p,s,k)
proof let N;
  let S be IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N);
  let p be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S, k;
  assume
Z1:  IC Comput(p,s,k) in dom p;
  assume
     p.IC Comput(p,s,k) = halt S;
  then
A1: CurInstr(p,Comput(p,s,k)) = halt S by Z1,PARTFUN1:def 8;
  then p halts_on s by Z1,Def8;
  hence thesis by A1,Def10;
end;

theorem Th57:
  for N
  for S being IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S st
  ex k st IC Comput(p,s,k) in dom p & p.IC Comput(p,s,k) = halt S
 for i holds Result(p,s) = Result(p,Comput(p,s,i))
proof let N;
  let S be  IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N);
  let p be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S;
  given k such that
A0: IC Comput(p,s,k) in dom p and
A1: p.IC Comput(p,s,k) = halt S;
  let i;
  set s9 = Comput(p,s,k);
A2: CurInstr(p,s9) = halt S by A0,A1,PARTFUN1:def 8;
  now
    per cases;
    suppose
      i <= k;
      then consider j being Nat such that
A3:   k = i + j by NAT_1:10;
      reconsider j as Element of NAT by ORDINAL1:def 13;
A4:   Comput(p,s,k) = Comput(p,Comput(p,s,i),j) by A3,Th51;
      then
A5:   p halts_on Comput(p,s,i) by A0,A2,Def8;
      thus Result(p,s) = s9 by A0,A1,Th56
        .= Result(p,Comput(p,s,i)) by A2,A4,A5,Def10;
    end;
    suppose
A6:   i >= k;
A7:   Comput(p,Comput(p,s,k),0) = Comput(p,s,k) by AMI_1:13;
A8:   Comput(p,s,i) = s9 by A2,A6,Th7;
      then
A9:   p halts_on Comput(p,s,i) by A0,A2,A7,Def8;
      thus Result(p,s) = s9 by A0,A1,Th56
        .= Result(p,Comput(p,s,i)) by A2,A8,A7,A9,Def10;
    end;
  end;
  hence thesis;
end;

theorem
  for N
  for S being IC-Ins-separated halting definite (non
empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S st
  ex k st p halts_at IC Comput(p,s,k)
   for i holds Result(p,s) = Result(p,Comput(p,s,i))
proof let N;
  let S be IC-Ins-separated halting definite (non empty
   stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function,
    s be State of S;
  given k such that
A1: p halts_at IC Comput(p,s,k);
A2: IC Comput(p,s,k) in dom p by A1,Def15;
  let i;
  p.IC Comput(p,s,k) = halt S by A1,Def15;
  hence thesis by A2,Th57;
end;

theorem
  for N
  for S being IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function,
      s being State of S holds
  p halts_on s iff ex k being Nat st p halts_at IC Comput(p,s,k)
proof let N;
  let S be IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N);
  let p be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S;
  hereby
    assume
    p halts_on s;
    then consider k being Nat such that
A0: IC Comput(p,s,k) in dom p and
A1: CurInstr(p,Comput(p,s,k)) = halt S by Def8;
    take k;
    p.IC Comput(p,s,k) = halt S by A1,A0,PARTFUN1:def 8;
    hence p halts_at IC Comput(p,s,k) by A0,Def15;
  end;
  given k being Nat such that
A2: p halts_at IC Comput(p,s,k);
  take k;
  thus
K:  IC Comput(p,s,k) in dom p by A2,Def15;
  thus CurInstr(p,Comput(p,s,k)) = p/.IC Comput(p,s,k)
    .= p.IC Comput(p,s,k) by K,PARTFUN1:def 8
    .= halt S by A2,Def15;
end;

