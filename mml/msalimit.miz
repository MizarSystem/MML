:: Inverse Limits of Many Sorted Algebras
::  by Adam Grabowski
::
:: Received June 11, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies AMI_1, MSUALG_1, PRALG_2, FUNCT_1, RELAT_1, FRAENKEL, CARD_3,
      RLVECT_2, PRALG_1, MSUALG_3, ALG_1, ZF_REFLE, FUNCOP_1, PBOOLE, RELAT_2,
      CQC_LANG, MCART_1, MSUALG_2, UNIALG_2, TDGROUP, BOOLE, QC_LANG1, FUNCT_2,
      FINSEQ_1, COMPLEX1, FINSEQ_4, TARSKI, FUNCT_6, FUNCT_5, NATTRA_1,
      PUA2MSS1, PARTFUN1, MSALIMIT, ORDERS_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NAT_1, MCART_1, RELAT_1,
      FUNCT_1, STRUCT_0, RELAT_2, FUNCT_2, FINSEQ_1, ORDERS_2, FUNCOP_1,
      FRAENKEL, RELSET_1, PARTFUN1, CARD_3, BINOP_1, FUNCT_5, FUNCT_6, PBOOLE,
      PRALG_1, MSUALG_1, MSUALG_2, MSUALG_3, PRE_CIRC, PRALG_2, PUA2MSS1,
      ORDERS_3;
 constructors PRE_CIRC, PRALG_1, PRALG_2, MSUALG_3, PUA2MSS1, ORDERS_3;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, FUNCT_2, FUNCOP_1,
      FRAENKEL, PBOOLE, STRUCT_0, ORDERS_2, MSUALG_1, MSUALG_2, PRALG_2,
      MSUALG_3, ORDERS_3, PRALG_3, ORDINAL1, CARD_3;
 requirements SUBSET, BOOLE;
 definitions TARSKI, XBOOLE_0, BINOP_1;
 theorems ALTCAT_1, CARD_3, FUNCOP_1, FINSEQ_1, FUNCT_1, FUNCT_2, FUNCT_5,
      FUNCT_7, MCART_1, MSUALG_1, MSUALG_2, MSUALG_3, MSUHOM_1, ORDERS_2,
      ORDERS_3, PARTFUN1, PBOOLE, PRALG_1, PRALG_2, PUA2MSS1, RELAT_1, RELAT_2,
      STRUCT_0, TARSKI, ZFMISC_1, RELSET_1, XBOOLE_0, XBOOLE_1, ORDERS_1,
      FUNCT_6;
 schemes FRAENKEL, PBOOLE, TARSKI, XBOOLE_0;

begin :: Inverse Limits of Many Sorted Algebras

reserve P for non empty Poset,
  i, j, k for Element of P;

reserve S for non void non empty ManySortedSign;

registration
  let I be non empty set, S;
  let AF be MSAlgebra-Family of I,S;
  let i be Element of I;
  let o be OperSymbol of S;
  cluster ((OPER AF).i).o -> Function-like Relation-like;
  coherence
  proof
    consider U0 being MSAlgebra over S such that
A2: U0 = AF.i & (OPER AF).i = the Charact of U0 by PRALG_2:def 18;
    thus ((OPER AF).i).o is Function-like Relation-like by A2;
  end;
end;

registration
  let I be non empty set, S;
  let AF be MSAlgebra-Family of I,S;
  let s be SortSymbol of S;
  cluster (SORTS AF).s -> functional;
  coherence
  proof
    (SORTS AF).s = product Carrier (AF,s) by PRALG_2:def 17;
    hence thesis;
  end;
end;

definition
  let P, S;
  mode OrderedAlgFam of P,S -> MSAlgebra-Family of the carrier of P,S means
    :Def1:
    ex F be ManySortedFunction of the InternalRel of P st
    for i,j,k st i >= j & j >= k ex f1 be ManySortedFunction of it.i, it.j,
    f2 be ManySortedFunction of it.j, it.k st f1 = F.(j,i) & f2 = F.(k,j) &
    F.(k,i) = f2 ** f1 & f1 is_homomorphism it.i, it.j;
  existence
  proof
    consider A be non-empty MSAlgebra over S;
    reconsider Z = (the carrier of P) --> A as
    ManySortedSet of the carrier of P;
    for i be set st i in the carrier of P holds
    Z.i is non-empty MSAlgebra over S by FUNCOP_1:13;
    then reconsider Z as MSAlgebra-Family of the carrier of P, S by
    PRALG_2:def 12;
    take Z;
    set G = (the InternalRel of P) --> id (the Sorts of A);
    dom G = the InternalRel of P by PBOOLE:def 3;
    then for ij be set st ij in dom G holds G.ij is Function by FUNCOP_1:13;
    then reconsider G as ManySortedFunction of the InternalRel of P
    by FUNCOP_1:def 6;
    take G;
    let i, j, k;
    assume i >= j & j >= k;
    then
A1: [j,i] in the InternalRel of P & [k,j] in the InternalRel of P
    by ORDERS_2:def 9;
A2: Z.i = A & Z.j = A & Z.k = A by FUNCOP_1:13;
    then consider F1 be ManySortedFunction of Z.i, Z.j such that
A3: F1 = id (the Sorts of A);
    take F1;
    consider F2 be ManySortedFunction of Z.j, Z.k such that
A4: F2 = id (the Sorts of A) by A2;
    take F2;
A5: F2 ** F1 = id (the Sorts of A) by A3,A4,MSUALG_3:3;
    reconsider T1 = the InternalRel of P as Relation of the carrier of P;
    field T1 = the carrier of P by ORDERS_1:97;
    then T1 is_transitive_in the carrier of P by RELAT_2:def 16;
    then [k,i] in T1 by A1,RELAT_2:def 8;
    hence thesis by A1,A2,A3,A4,A5,FUNCOP_1:13,MSUALG_3:9;
  end;
end;

reserve OAF for OrderedAlgFam of P, S;

definition
  let P, S, OAF;
  mode Binding of OAF -> ManySortedFunction of the InternalRel of P means
    :Def2:
    for i,j,k st i >= j & j >= k
    ex f1 be ManySortedFunction of OAF.i, OAF.j,
    f2 be ManySortedFunction of OAF.j, OAF.k st
    f1 = it.(j,i) & f2 = it.(k,j) &
    it.(k,i) = f2 ** f1 & f1 is_homomorphism OAF.i, OAF.j;
  existence by Def1;
end;

definition
  let P, S, OAF;
  let B be Binding of OAF, i,j;
  assume
A1: i >= j;
  func bind (B,i,j) -> ManySortedFunction of OAF.i, OAF.j equals
  :Def3:
  B.(j,i);
  coherence
  proof
    j >= j by ORDERS_2:24;
    then consider f1 be ManySortedFunction of OAF.i, OAF.j,
    f2 be ManySortedFunction of OAF.j, OAF.j such that
A2: f1 = B.(j,i) & f2 = B.(j,j) & B.(j,i) = f2 ** f1 &
    f1 is_homomorphism OAF.i, OAF.j by A1,Def2;
    thus thesis by A2;
  end;
end;

reserve B for Binding of OAF;

theorem Th1:
  i >= j & j >= k implies bind (B,j,k) ** bind (B,i,j) = bind (B,i,k)
proof
  assume
A1: i >= j & j >= k;
  then
A2: bind (B,j,k) = B.(k,j) & bind (B,i,j) = B.(j,i) &
  bind (B,i,k) = B.(k,i) by Def3,ORDERS_2:26;
  consider f1 be ManySortedFunction of OAF.i, OAF.j,
  f2 be ManySortedFunction of OAF.j, OAF.k such that
A3: f1 = B.(j,i) & f2 = B.(k,j) & B.(k,i) = f2 ** f1 &
  f1 is_homomorphism OAF.i, OAF.j by A1,Def2;
  thus thesis by A2,A3;
end;

definition
  let P, S, OAF;
  let IT be Binding of OAF;
  attr IT is normalized means
  :Def4:
  for i holds IT.(i,i) = id (the Sorts of OAF.i);
end;

theorem Th2:
  for P,S,OAF,B,i,j st i >= j
  for f be ManySortedFunction of OAF.i,OAF.j st f = bind (B,i,j) holds
  f is_homomorphism OAF.i,OAF.j
proof
  let P,S,OAF,B,i,j;
  assume
A1: i >= j;
  let f be ManySortedFunction of OAF.i,OAF.j;
  assume
A2: f = bind (B,i,j);
  j >= j by ORDERS_2:24;
  then consider f1 be ManySortedFunction of OAF.i, OAF.j,
  f2 be ManySortedFunction of OAF.j, OAF.j such that
A3: f1 = B.(j,i) & f2 = B.(j,j) & B.(j,i) = f2 ** f1 &
  f1 is_homomorphism OAF.i, OAF.j by A1,Def2;
  thus f is_homomorphism OAF.i,OAF.j by A1,A2,A3,Def3;
end;

definition
  let P, S, OAF, B;
  func Normalized B -> Binding of OAF means
  :Def5:
  for i, j st i >= j holds it.(j,i) = IFEQ (j, i, id (the Sorts of OAF.i),
  bind (B,i,j) ** id (the Sorts of OAF.i) );
  existence
  proof
    defpred P[set,set] means
    ex i,j st $1 = [j,i] & $2 = IFEQ (j, i, id (the Sorts of OAF.i),
    bind (B,i,j) ** id (the Sorts of OAF.i) );
    now
      let ij be set;
      assume
A1:   ij in the InternalRel of P;
      then reconsider i2 = ij`1, i1 = ij`2 as Element of P by MCART_1:10;
      reconsider i1, i2 as Element of P;
      deffunc Z(set)= IFEQ (i2, i1, id (the Sorts of OAF.i1),
      bind (B,i1,i2) ** id (the Sorts of OAF.i1) );
      consider A be ManySortedSet of the InternalRel of P such that
A2:   for ij be set st ij in the InternalRel of P holds
      A.ij = Z(ij) from PBOOLE:sch 4;
      take x = A.ij;
      take i1,i2;
      thus ij = [i2,i1] & x = IFEQ (i2, i1, id (the Sorts of OAF.i1),
      bind (B,i1,i2) ** id (the Sorts of OAF.i1) ) by A1,A2,MCART_1:23;
    end;
    then
A3: for z being set st z in the InternalRel of P ex y being set st P[z,y];
    consider A be ManySortedSet of the InternalRel of P such that
A4: for ij being set st ij in the InternalRel of P holds P[ij,A.ij]
    from PBOOLE:sch 3(A3);
    for z be set st z in dom A holds A.z is Function
    proof
      let z be set;
      assume z in dom A;
      then z in the InternalRel of P by PBOOLE:def 3;
      then consider i1,i2 be Element of P such that
A5:   z = [i2,i1] & A.z = IFEQ (i2, i1, id (the Sorts of OAF.i1),
      bind (B,i1,i2) ** id (the Sorts of OAF.i1) ) by A4;
      per cases;
      suppose i1 = i2;
        hence thesis by A5,FUNCOP_1:def 8;
      end;
      suppose i1 <> i2;
        hence thesis by A5,FUNCOP_1:def 8;
      end;
    end;
    then reconsider A as ManySortedFunction of the InternalRel of P
    by FUNCOP_1:def 6;
    now
      let i,j,k;
      assume
A6:   i >= j & j >= k;
      consider kl be set such that
A7:   kl = [j,i];
      kl in the InternalRel of P by A6,A7,ORDERS_2:def 9;
      then consider i1,j1 be Element of P such that
A8:   [j1,i1] = kl & A.kl = IFEQ (j1, i1, id (the Sorts of OAF.i1),
      bind (B,i1,j1) ** id (the Sorts of OAF.i1) ) by A4;
A9:   i1 = i & j1 = j by A7,A8,ZFMISC_1:33;
      A.(j,i) is ManySortedFunction of OAF.i,OAF.j
      proof
        per cases;
        suppose i = j;
          hence thesis by A8,A9,FUNCOP_1:def 8;
        end;
        suppose i <> j;
          hence thesis by A8,A9,FUNCOP_1:def 8;
        end;
      end;
      then reconsider f1 = A.(j,i) as ManySortedFunction of OAF.i,OAF.j;
      consider lm be set such that
A10:  lm = [k,j];
      lm in the InternalRel of P by A6,A10,ORDERS_2:def 9;
      then consider i2,j2 be Element of P such that
A11:  [j2,i2] = lm & A.lm = IFEQ (j2, i2, id (the Sorts of OAF.i2),
      bind (B,i2,j2) ** id (the Sorts of OAF.i2) ) by A4;
A12:  j2 = k & i2 = j by A10,A11,ZFMISC_1:33;
      A.(k,j) is ManySortedFunction of OAF.j,OAF.k
      proof
        per cases;
        suppose j = k;
          hence thesis by A11,A12,FUNCOP_1:def 8;
        end;
        suppose j <> k;
          hence thesis by A11,A12,FUNCOP_1:def 8;
        end;
      end;
      then reconsider f2 = A.(k,j) as ManySortedFunction of OAF.j,OAF.k;
A13:  for i,j st i = j holds A.(j,i) = id (the Sorts of OAF.i)
      proof
        let i,j;
        assume
A14:    i = j;
        then
A15:    i >= j by ORDERS_2:24;
        consider lm be set such that
A16:    lm = [j,i];
        lm in the InternalRel of P by A15,A16,ORDERS_2:def 9;
        then consider i2,j2 be Element of P such that
A17:    [j2,i2] = lm & A.lm = IFEQ (j2, i2, id (the Sorts of OAF.i2),
        bind (B,i2,j2) ** id (the Sorts of OAF.i2) ) by A4;
        i2 = i & j2 = j by A16,A17,ZFMISC_1:33;
        hence A.(j,i) = id (the Sorts of OAF.i) by A14,A17,FUNCOP_1:def 8;
      end;
A18:  for i,j st i >= j & i <> j holds A.(j,i) = bind (B,i,j)
      proof
        let i,j;
        assume
A19:    i >= j & i <> j;
        consider lm be set such that
A20:    lm = [j,i];
        lm in the InternalRel of P by A19,A20,ORDERS_2:def 9;
        then consider i2,j2 be Element of P such that
A21:    [j2,i2] = lm & A.lm = IFEQ (j2, i2, id (the Sorts of OAF.i2),
        bind (B,i2,j2) ** id (the Sorts of OAF.i2) ) by A4;
        i2 = i & j2 = j by A20,A21,ZFMISC_1:33;
        then A.(j,i) = bind (B,i,j) ** id (the Sorts of OAF.i)
        by A19,A21,FUNCOP_1:def 8;
        hence thesis by MSUALG_3:3;
      end;
A22:  A.(k,i) = f2 ** f1
      proof
        per cases;
        suppose
A23:      i = j & j = k;
          then f2 = id (the Sorts of OAF.j) by A11,A12,FUNCOP_1:def 8;
          hence thesis by A23,MSUALG_3:3;
        end;
        suppose
A24:      i = j & j <> k;
          then f1 = id (the Sorts of OAF.i) by A8,A9,FUNCOP_1:def 8;
          hence thesis by A24,MSUALG_3:3;
        end;
        suppose
A25:      i <> j & j = k;
          then f2 = id (the Sorts of OAF.j) by A11,A12,FUNCOP_1:def 8;
          hence thesis by A25,MSUALG_3:4;
        end;
        suppose
A26:      i <> j & j <> k;
          then i > j & j > k by A6,ORDERS_2:def 10;
          then
A27:      i <> k by ORDERS_2:29;
          f1 = bind (B,i,j) ** id (the Sorts of OAF.i) by A8,A9,A26,
          FUNCOP_1:def 8;
          then
A28:      f1 = bind (B,i,j) by MSUALG_3:3;
          f2 = bind (B,j,k) ** id (the Sorts of OAF.j) by A11,A12,A26,
          FUNCOP_1:def 8;
          then f2 = bind (B,j,k) by MSUALG_3:3;
          then f2 ** f1 = bind (B,i,k) by A6,A28,Th1;
          hence thesis by A6,A18,A27,ORDERS_2:26;
        end;
      end;
      f1 is_homomorphism OAF.i, OAF.j
      proof
        per cases;
        suppose
A29:      i = j;
          then A.(i,j) = id (the Sorts of OAF.i) by A13;
          hence thesis by A29,MSUALG_3:9;
        end;
        suppose i <> j;
          then A.(j,i) = bind (B,i,j) by A6,A18;
          hence thesis by A6,Th2;
        end;
      end;
      hence ex f1 be ManySortedFunction of OAF.i, OAF.j,
      f2 be ManySortedFunction of OAF.j, OAF.k st
      f1 = A.(j,i) & f2 = A.(k,j) &
      A.(k,i) = f2 ** f1 & f1 is_homomorphism OAF.i, OAF.j by A22;
    end;
    then reconsider A as Binding of OAF by Def2;
    take A;
    let i, j;
    assume
A30: i >= j;
    consider kl be set such that
A31: kl = [j,i];
    kl in the InternalRel of P by A30,A31,ORDERS_2:def 9;
    then consider i1,j1 be Element of P such that
A32: [j1,i1] = kl & A.kl = IFEQ (j1, i1, id (the Sorts of OAF.i1),
    bind (B,i1,j1) ** id (the Sorts of OAF.i1) ) by A4;
    i1 = i & j1 = j by A31,A32,ZFMISC_1:33;
    hence thesis by A32;
  end;
  uniqueness
  proof
    let N1, N2 be Binding of OAF such that
A33: for i,j st i >= j holds N1.(j,i) = IFEQ (j, i, id (the Sorts of OAF.i),
    bind (B,i,j) ** id (the Sorts of OAF.i) ) and
A34: for i,j st i >= j holds N2.(j,i) = IFEQ (j, i, id (the Sorts of OAF.i),
    bind (B,i,j) ** id (the Sorts of OAF.i) );
    now
      let ij be set;
      assume
A35:  ij in the InternalRel of P;
      then reconsider i2 = ij`1 , i1 = ij`2 as Element of P by MCART_1:10;
      reconsider i1, i2 as Element of P;
      ij = [ij`1,ij`2] by A35,MCART_1:23;
      then
A36:  i2 <= i1 by A35,ORDERS_2:def 9;
      N1.ij = N1.(i2,i1) by A35,MCART_1:23;
      then
A37:  N1.ij = IFEQ (i2, i1, id (the Sorts of OAF.i1),
      bind (B,i1,i2) ** id (the Sorts of OAF.i1) ) by A33,A36;
      N2.ij = N2.(i2,i1) by A35,MCART_1:23;
      hence N1.ij = N2.ij by A34,A36,A37;
    end;
    hence N1 = N2 by PBOOLE:3;
  end;
end;

theorem Th3:
  for i, j st i >= j & i <> j holds B.(j,i) = (Normalized B).(j,i)
proof
  let i, j;
  assume
A1: i >= j & i <> j;
  then
A2: (Normalized B).(j,i) = IFEQ (j, i, id (the Sorts of OAF.i),
  bind (B,i,j) ** id (the Sorts of OAF.i) ) by Def5;
  IFEQ (j, i, id (the Sorts of OAF.i),
  bind (B,i,j) ** id (the Sorts of OAF.i) ) =
  bind (B,i,j) ** id (the Sorts of OAF.i) by A1,FUNCOP_1:def 8;
  then (Normalized B).(j,i) = bind (B,i,j) by A2,MSUALG_3:3;
  hence thesis by A1,Def3;
end;

registration
  let P, S, OAF, B;
  cluster Normalized B -> normalized;
  coherence
  proof
    let i be Element of P;
    i >= i by ORDERS_2:24;
    then (Normalized B).(i,i) = IFEQ (i, i, id (the Sorts of OAF.i),
    bind (B,i,i) ** id (the Sorts of OAF.i) ) by Def5;
    hence thesis by FUNCOP_1:def 8;
  end;
end;

registration
  let P, S, OAF;
  cluster normalized Binding of OAF;
  existence
  proof
    consider B be Binding of OAF;
    take Normalized B;
    thus thesis;
  end;
end;

theorem
  for NB be normalized Binding of OAF
  for i, j st i >= j holds (Normalized NB).(j,i) = NB.(j,i)
proof
  let NB be normalized Binding of OAF;
  let i, j;
  assume
A1: i >= j;
  per cases;
  suppose i <> j;
    hence thesis by A1,Th3;
  end;
  suppose
A2: i = j;
    (Normalized NB).(j,i) = IFEQ (j, i, id (the Sorts of OAF.i),
    bind (NB,i,j) ** id (the Sorts of OAF.i) ) by A1,Def5;
    then (Normalized NB).(j,i) = id (the Sorts of OAF.i) by A2,FUNCOP_1:def 8;
    hence (Normalized NB).(j,i) = NB.(j,i) by A2,Def4;
  end;
end;

definition
  let P, S, OAF;
  let B be Binding of OAF;
  func InvLim B -> strict MSSubAlgebra of product OAF means
  :Def6:
  for s be SortSymbol of S for f be Element of (SORTS OAF).s holds
  f in (the Sorts of it).s iff
  for i,j st i >= j holds (bind (B,i,j).s).(f.i) = f.j;
  existence
  proof
    deffunc F(SortSymbol of S) =
    { f where f is Element of product Carrier (OAF,$1) :
    for i,j st i >= j holds (bind (B,i,j).$1).(f.i) = f.j };
    consider C be ManySortedSet of the carrier of S such that
A1: for s be SortSymbol of S holds C.s = F(s) from PBOOLE:sch 5;
    for i be set st i in the carrier of S holds C.i c= (SORTS OAF).i
    proof
      let i be set;
      assume i in the carrier of S;
      then reconsider s = i as SortSymbol of S;
      defpred P[Element of product Carrier (OAF,s)] means
      for i,j st i >= j holds (bind (B,i,j).s).($1.i) = $1.j;
A2:   (SORTS OAF).s = product Carrier (OAF,s) by PRALG_2:def 17;
      { f where f is Element of product Carrier (OAF,s) : P[f] } c=
      product Carrier (OAF,s) from FRAENKEL:sch 10;
      hence thesis by A1,A2;
    end;
    then C c= SORTS OAF by PBOOLE:def 5;
    then reconsider C as ManySortedSubset of SORTS OAF by PBOOLE:def 23;
    reconsider C as MSSubset of product OAF by PRALG_2:20;
    for o be OperSymbol of S holds C is_closed_on o
    proof
      let o be OperSymbol of S;
      rng ( (Den(o,product OAF)) | ((C# * the Arity of S).o) ) c=
      (C * the ResultSort of S).o
      proof
        let x be set;
        assume
A3:     x in rng ( (Den(o,product OAF)) | ((C# * the Arity of S).o) );
        reconsider K = ( (Den(o,product OAF)) | ((C# * the Arity of S).o) )
        as Function;
        consider y be set such that
A4:     y in dom K & x = K.y by A3,FUNCT_1:def 5;
        dom K = (dom (Den (o,product OAF))) /\ ((C# * the Arity of S).o)
        by RELAT_1:90;
        then
A5:     y in (dom (Den (o,product OAF))) & y in ((C# * the Arity of S).o)
        by A4,XBOOLE_0:def 3;
        reconsider MS = C as ManySortedSet of (the carrier of S);
A6:     the OperSymbols of S is non empty by MSUALG_1:def 5;
        dom (the Arity of S) = the OperSymbols of S by FUNCT_2:def 1;
        then y in C# . ((the Arity of S).o) by A5,A6,FUNCT_1:23;
        then y in C# . the_arity_of o by MSUALG_1:def 6;
        then
A7:     y in product (MS * the_arity_of o) by PBOOLE:def 19;
A8:     dom (the ResultSort of S) = the OperSymbols of S by FUNCT_2:def 1;
        x in Result (o,product OAF) by A3;
        then x in ((the Sorts of product OAF) * the ResultSort of S).o
        by MSUALG_1:def 10;
        then x in (the Sorts of product OAF).((the ResultSort of S).o)
        by A6,A8,FUNCT_1:23;
        then x in (SORTS OAF).((the ResultSort of S).o) by PRALG_2:20;
        then x in (SORTS OAF).(the_result_sort_of o) by MSUALG_1:def 7;
        then
A9:     x is Element of product Carrier (OAF,the_result_sort_of o)
        by PRALG_2:def 17;
        then reconsider x1 = x as Function;
        now
          let s be SortSymbol of S;
          for i,j st i >= j holds (bind (B,i,j).the_result_sort_of o).
          (x1.i) = x1.j
          proof
            let i,j;
            assume
A10:        i >= j;
A11:        Den (o,product OAF) = (the Charact of product OAF).o
            by MSUALG_1:def 11
              .= (OPS OAF).o by PRALG_2:20;
            reconsider OPE = (OPS OAF).o as Function;
            consider g be Function such that
A12:        y = g & dom g = dom (MS * the_arity_of o)
            & for t be set st t in dom (MS * the_arity_of o) holds
            g.t in (MS * the_arity_of o).t by A7,CARD_3:def 5;
            reconsider y as Function by A12;
A13:        dom y = dom (MS*the_arity_of o) by A7,CARD_3:18;
A14:        rng (the_arity_of o) c= dom MS
            proof
              let i be set;
              assume i in rng (the_arity_of o);
              then i in the carrier of S;
              hence i in dom MS by PBOOLE:def 3;
            end;
            then
A15:        dom y = dom (the_arity_of o) by A13,RELAT_1:46;
            set y1 = (commute y).i;
            reconsider Co = commute y as Function;
A16:        y
            in Funcs(Seg len (the_arity_of o),Funcs(the carrier of P,|.OAF.|))
            proof
A17:          dom y = Seg len (the_arity_of o) by A15,FINSEQ_1:def 3;
              rng y c= Funcs(the carrier of P,|.OAF.|)
              proof
                let z be set;
                assume z in rng y;
                then consider n be set such that
A18:            n in dom y & z = y.n by FUNCT_1:def 5;
A19:            n in dom (MS*the_arity_of o) by A7,A18,CARD_3:18;
                then z in (MS*the_arity_of o).n by A7,A18,CARD_3:18;
                then
A20:            z in MS.((the_arity_of o).n) by A19,FUNCT_1:22;
                n in dom (the_arity_of o) by A14,A19,RELAT_1:46;

then (the_arity_of o).n = (the_arity_of o)/.n by PARTFUN1:def 8;
                then reconsider Pa = ((the_arity_of o).n) as SortSymbol of S;
                z in { f where f is Element of product Carrier (OAF,Pa) :
                for i,j st i >=
                j holds (bind (B,i,j).Pa).(f.i) = f.j } by A1,A20;

then consider z' be Element of product Carrier(OAF,Pa) such that
A21:            z'
                = z & for i,j st i >= j holds (bind (B,i,j).Pa).(z'.i) = z'.j;
                reconsider z as Function by A21;
A22:            dom z = dom Carrier (OAF,Pa) by A21,CARD_3:18
                  .= the carrier of P by PBOOLE:def 3;
                rng z c= |.OAF.|
                proof
                  let p be set;
                  assume p in rng z;
                  then consider r be set such that
A23:              r in dom z & z.r = p by FUNCT_1:def 5;
                  dom z = dom Carrier (OAF,Pa) by A21,CARD_3:18;
                  then
A24:              p in (Carrier (OAF,Pa)).r by A21,A23,CARD_3:18;
                  reconsider r' = r as Element of P by A22,A23;
                  reconsider r' as Element of P;
                  r' in the carrier of P;
                  then consider U0 be MSAlgebra over S such that
A25:              U0 = OAF.r & (Carrier (OAF,Pa)).r = (the Sorts of U0).Pa
                  by PRALG_2:def 16;

dom (the Sorts of (OAF.r')) = the carrier of S by PBOOLE:def 3;

then (the Sorts of (OAF.r')).Pa in rng (the Sorts of (OAF.r'))
                  by FUNCT_1:def 5;

then p in union (rng the Sorts of OAF.r') by A24,A25,TARSKI:def 4;
                  then
A26:              p in |.OAF.r'.| by PRALG_2:def 13;
                  |.OAF.r'.| in
                  {|.OAF.k.| where k is Element of P:not contradiction};
                  then |.OAF.r'.| c= union {|.OAF.k.| where k is Element of
                  the carrier of P: not contradiction} by ZFMISC_1:92;
                  then |.OAF.r'.| c= |.OAF.| by PRALG_2:def 14;
                  hence p in |.OAF.| by A26;
                end;
                hence thesis by A22,FUNCT_2:def 2;
              end;
              hence thesis by A17,FUNCT_2:def 2;
            end;
            per cases;
            suppose
A27:          the_arity_of o <> {};
              then dom (the_arity_of o) <> {};
              then Seg len (the_arity_of o) <> {} by FINSEQ_1:def 3;
              then Co in Funcs(the carrier of P,Funcs (Seg len(the_arity_of o)
              , |.OAF.|)) by A16,FUNCT_6:85;
              then consider ss be Function such that
A28:          ss = Co & dom ss = the carrier of P &

rng ss c= Funcs (Seg len(the_arity_of o),|.OAF.|) by FUNCT_2:def 2;
              reconsider y1 as Function;
A29:          y1 in product ((the Sorts of OAF.i)*(the_arity_of o))
              proof
A30:            dom ((the Sorts of OAF.i)*(the_arity_of o)) =
                dom (the_arity_of o) by PRALG_2:10
                  .= Seg len (the_arity_of o) by FINSEQ_1:def 3;
                Co.i in rng Co by A28,FUNCT_1:def 5;
                then consider ts be Function such that
A31:            ts = Co.i &
                dom ts = Seg len (the_arity_of o) & rng ts c= |.OAF.|
                by A28,FUNCT_2:def 2;
                for w be set st
                w in dom ((the Sorts of OAF.i)*(the_arity_of o)) holds
                y1.w in ((the Sorts of OAF.i)*(the_arity_of o)).w
                proof
                  let w be set;
                  assume
A32:              w in dom ((the Sorts of OAF.i)*(the_arity_of o));
                  then
A33:              w in dom y by A15,A30,FINSEQ_1:def 3;
A34:              w in dom (the_arity_of o) by A30,A32,FINSEQ_1:def 3;
                  y.w in (MS*the_arity_of o).w by A7,A13,A33,CARD_3:18;
                  then
A35:              y.w in MS.((the_arity_of o).w) by A34,FUNCT_1:23;
                  dom (the_arity_of o) <> {} by A27;
                  then Seg len (the_arity_of o) <> {} by FINSEQ_1:def 3;
                  then y = commute commute y by A16,FUNCT_6:87;
                  then reconsider y as Function-yielding Function;
A36:              y.w in MS.((the_arity_of o)/.w) by A34,A35,PARTFUN1:def 8;
                  reconsider yw = y.w as Function;
                  reconsider Pi = (the_arity_of o)/.w as SortSymbol of S;
                  yw in { ff where ff is Element of product Carrier (OAF,Pi) :

for i,j st i >= j holds (bind (B,i,j).Pi).(ff.i) = ff.j } by A1,A36;

then consider jg be Element of product Carrier(OAF,Pi) such that
A37:              jg = yw & for i,j st i >= j holds
                  (bind (B,i,j).Pi).(jg.i) = jg.j;
                  dom (Carrier (OAF,(the_arity_of o)/.w)) = the carrier of P
                  by PBOOLE:def 3;
                  then
A38:              yw
                  .i in (Carrier (OAF,(the_arity_of o)/.w)).i by A37,CARD_3:18;
                  consider U0 be MSAlgebra over S such that
A39:              U0 = OAF.i & (Carrier (OAF,(the_arity_of o)/.w)).i =
                  (the Sorts of U0).((the_arity_of o)/.w) by PRALG_2:def 16;
                  (Carrier (OAF,(the_arity_of o)/.w)).i =

(the Sorts of (OAF.i)) . ((the_arity_of o).w) by A34,A39,PARTFUN1:def 8

.= ((the Sorts of (OAF.i)) * (the_arity_of o)).w by A34,FUNCT_1:23;
                  hence thesis by A16,A30,A32,A38,FUNCT_6:86;
                end;
                hence thesis by A30,A31,CARD_3:18;
              end;
A40:          for
              t be set st t in dom doms(OAF?.o) holds Co.t in (doms(OAF?.o)).t
              proof
                let t be set;
                assume t in dom doms(OAF?.o);
                then reconsider t as Element of P by PRALG_2:18;
A41:            (doms(OAF?.o)).t = Args (o,OAF.t) by PRALG_2:18;
                dom (the_arity_of o) <> {} by A27;
                then Seg len (the_arity_of o) <> {} by FINSEQ_1:def 3;

then Co in Funcs(the carrier of P,Funcs (Seg len(the_arity_of o),
                |.OAF.|)) by A16,FUNCT_6:85;
                then consider ss be Function such that
A42:            ss = Co & dom ss = the carrier of P &

rng ss c= Funcs (Seg len(the_arity_of o),|.OAF.|) by FUNCT_2:def 2;
                reconsider yt = Co.t as Function;
                Co.t in product ((the Sorts of OAF.t)*(the_arity_of o))
                proof
A43:              dom ((the Sorts of OAF.t)*(the_arity_of o)) =
                  dom (the_arity_of o) by PRALG_2:10
                    .= Seg len (the_arity_of o) by FINSEQ_1:def 3;
                  Co.t in rng Co by A42,FUNCT_1:def 5;
                  then consider ts be Function such that
A44:              ts

= Co.t & dom ts = Seg len (the_arity_of o) & rng ts c= |.OAF.|
                  by A42,FUNCT_2:def 2;
A45:              dom y = Seg len (the_arity_of o) by A15,FINSEQ_1:def 3;
                  for w be set st
                  w in dom ((the Sorts of OAF.t)*(the_arity_of o)) holds
                  yt.w in ((the Sorts of OAF.t)*(the_arity_of o)).w
                  proof
                    let w be set;
                    assume
A46:                w in dom ((the Sorts of OAF.t)*(the_arity_of o));
                    then
A47:                w in dom (the_arity_of o) by A43,FINSEQ_1:def 3;

y.w in (MS*the_arity_of o).w by A7,A13,A43,A45,A46,CARD_3:18;
                    then
A48:                y.w in MS.((the_arity_of o).w) by A47,FUNCT_1:23;
                    dom (the_arity_of o) <> {} by A27;
                    then Seg len (the_arity_of o) <> {} by FINSEQ_1:def 3;
                    then y = commute commute y by A16,FUNCT_6:87;
                    then reconsider y as Function-yielding Function;
A49:                y.w in MS.((the_arity_of o)/.w) by A47,A48,PARTFUN1:def 8;
                    reconsider yw = y.w as Function;
                    reconsider Pi = (the_arity_of o)/.w as SortSymbol of S;

yw in { ff where ff is Element of product Carrier (OAF,Pi) :

for i,j st i >= j holds (bind (B,i,j).Pi).(ff.i) = ff.j } by A1,A49;

then consider jg be Element of product Carrier(OAF,Pi) such that
A50:                jg = yw & for i,j st i >= j holds
                    (bind (B,i,j).Pi).(jg.i) = jg.j;
                    dom (Carrier (OAF,(the_arity_of o)/.w)) = the carrier of P
                    by PBOOLE:def 3;
                    then
A51:                yw

.t in (Carrier (OAF,(the_arity_of o)/.w)).t by A50,CARD_3:18;
                    consider U0 be MSAlgebra over S such that
A52:                U0 = OAF.t & (Carrier (OAF,(the_arity_of o)/.w)).t =
                    (the Sorts of U0).((the_arity_of o)/.w) by PRALG_2:def 16;
                    (Carrier (OAF,(the_arity_of o)/.w)).t =

(the Sorts of (OAF.t)) . ((the_arity_of o).w) by A47,A52,PARTFUN1:def 8

.= ((the Sorts of (OAF.t)) * (the_arity_of o)).w by A47,FUNCT_1:23;
                    hence thesis by A16,A43,A46,A51,FUNCT_6:86;
                  end;
                  hence thesis by A43,A44,CARD_3:18;
                end;
                hence thesis by A41,PRALG_2:10;
              end;
A53:          Co in product doms (OAF?.o)
              proof
                dom (the_arity_of o) <> {} by A27;
                then Seg len (the_arity_of o) <> {} by FINSEQ_1:def 3;

then Co in Funcs (the carrier of P,Funcs(Seg len (the_arity_of o),|. OAF.|))
                by A16,FUNCT_6:85;
                then consider Co' be Function such that
A54:            Co' = Co & dom Co' = the carrier of P &

rng Co' c= Funcs(Seg len (the_arity_of o),|.OAF.|) by FUNCT_2:def 2;
                dom Co = dom doms (OAF?.o) by A54,PRALG_2:18;
                hence thesis by A40,CARD_3:18;
              end;

reconsider y1' = y1 as Element of Args(o,OAF.i) by A29,PRALG_2:10;
A55:          dom (OAF?.o) = the carrier of P by PBOOLE:def 3;
A56:          bind (B,i,j) is_homomorphism OAF.i,OAF.j by A10,Th2;
A57:          OPE
              = IFEQ(the_arity_of o,{},commute(OAF?.o),Commute Frege(OAF?.o))
              by PRALG_2:def 20;
              then
A58:          y in dom Commute Frege(OAF?.o) by A5,A11,A27,FUNCOP_1:def 8;
A59:          x1 = OPE.y by A4,A11,FUNCT_1:70
                .= (Commute Frege(OAF?.o)).y by A27,A57,FUNCOP_1:def 8
                .= ((Frege (OAF?.o)).commute y) by A58,PRALG_2:def 6
                .= ((OAF?.o)..commute y) by A53,PRALG_2:def 8;
              then
A60:          x1.i = ((OAF?.o).i).((commute y).i) by A55,PRALG_1:def 17
                .= (Den(o,OAF.i)).y1 by PRALG_2:14;
              (bind (B,i,j))#y1' = (commute y).j
              proof
                dom (the_arity_of o) <> {} by A27;
                then
A61:            Seg len (the_arity_of o) <> {} by FINSEQ_1:def 3;
                then y = commute commute y by A16,FUNCT_6:87;
                then reconsider y as Function-yielding Function;
                Co in Funcs(the carrier of P,Funcs (Seg len(the_arity_of o),
                |.OAF.|)) by A16,A61,FUNCT_6:85;
                then consider ss be Function such that
A62:            ss = Co & dom ss = the carrier of P &

rng ss c= Funcs (Seg len(the_arity_of o),|.OAF.|) by FUNCT_2:def 2;
                reconsider y2 = ((commute y).j) as Function;
A63:            Co.j in rng Co by A62,FUNCT_1:def 5;
A64:            Co.i in rng Co by A62,FUNCT_1:def 5;
                consider ts be Function such that
A65:            ts
                = Co.j & dom ts = Seg len (the_arity_of o) & rng ts c= |.OAF.|
                by A62,A63,FUNCT_2:def 2;
                reconsider Two = y2 as FinSequence by A65,FINSEQ_1:def 2;
A66:            now
                  let n be Nat;
                  assume
A67:              n in dom y2;
                  then
A68:              n in dom (the_arity_of o) by A65,FINSEQ_1:def 3;
                  consider ts' be Function such that
A69:              ts' = Co.i &
                  dom ts' = Seg len (the_arity_of o) & rng ts' c= |.OAF.|
                  by A62,A64,FUNCT_2:def 2;
                  consider sT be Function such that
A70:              sT = y & dom sT = Seg len (the_arity_of o) &

rng sT c= Funcs(the carrier of P,|.OAF.|) by A16,FUNCT_2:def 2;
                  reconsider yn = y.n as Function;
A71:              (y1'.n) = yn.i by A16,A65,A67,FUNCT_6:86;
                  reconsider Pi = (the_arity_of o)/.n as SortSymbol of S;
A72:              (

the_arity_of o)/.n = (the_arity_of o).n by A68,PARTFUN1:def 8;
                  y.n in (MS*the_arity_of o).n by A7,A13,A65,A67,A70,CARD_3:18;
                  then yn in MS.Pi by A68,A72,FUNCT_1:23;

then yn in { f where f is Element of product Carrier (OAF,Pi) :

for i,j st i >= j holds (bind (B,i,j).Pi).(f.i) = f.j } by A1;

then consider yn' be Element of product Carrier(OAF,Pi) such that
A73:              yn' = yn & for i,j st i >=
                  j holds (bind (B,i,j).Pi).(yn'.i) = yn'.j;
                  now
                    thus ((bind (B,i,j))#y1').n =
                    ((bind (B,i,j)).((the_arity_of o)/.n)).(yn.i)
                    by A65,A67,A69,A71,MSUALG_3:def 8
                      .= yn.j by A10,A73;
                  end;

hence ((bind (B,i,j))#y1').n = y2.n by A16,A65,A67,FUNCT_6:86;
                end;
A74:            dom ((bind (B,i,j))#y1') = dom (the_arity_of o) by MSUALG_3:6
                  .= Seg len (the_arity_of o) by FINSEQ_1:def 3;
                then reconsider One = ((bind (B,i,j))#y1') as FinSequence
                by FINSEQ_1:def 2;
                for n be Nat st n in Seg len (the_arity_of o) holds
                One.n = Two.n by A65,A66;
                hence thesis by A65,A74,FINSEQ_1:17;
              end;
              then (Den(o,OAF.j)).((bind (B,i,j))#y1') =
              ((OAF?.o).j).((commute y).j) by PRALG_2:14
                .= x1.j by A55,A59,PRALG_1:def 17;

hence (bind (B,i,j).the_result_sort_of o).(x1.i) = x1.j by A56,A60,
              MSUALG_3:def 9;
            end;
            suppose
A75:          the_arity_of o = {};
A76:          (Den (o,product OAF)) = (the Charact of product OAF).o
              by MSUALG_1:def 11
                .= (OPS OAF).o by PRALG_2:20

.= IFEQ(the_arity_of o,{},commute(OAF?.o),Commute Frege(OAF?.o))
              by PRALG_2:def 20
                .= (commute (OAF?.o)) by A75,FUNCOP_1:def 8;
A77:          MS * {} = {};
              reconsider co = ((commute (OAF?.o)).y) as Function;
A78:          co = ((curry' uncurry (OAF?.o)).y) by FUNCT_6:def 12;
A79:          dom (OAF?.o) = the carrier of P by PBOOLE:def 3;
A80:          for d be Element of P holds x1.d = (Den (o,OAF.d)).{}
              proof
                let d be Element of P;
                reconsider g = (OAF?.o).d as Function;
                g = Den(o,OAF.d) by PRALG_2:14;
                then dom g = Args (o,OAF.d) by FUNCT_2:def 1
                  .= {{}} by A75,PRALG_2:11;
                then
A81:            y in dom g by A7,A75,CARD_3:19;
                then
A82:            [d,y] in dom (uncurry (OAF?.o)) by A79,FUNCT_5:45;

reconsider co' = ((curry' uncurry (OAF?.o)).y) as Function by A78;
A83:            co.d = co'.d by FUNCT_6:def 12
                  .= (uncurry (OAF?.o)).(d,y) by A82,FUNCT_5:29
                  .= g.y by A79,A81,FUNCT_5:45;
                x1 = (commute (OAF?.o)).y by A4,A76,FUNCT_1:70;
                then x1.d = (Den (o,OAF.d)).y by A83,PRALG_2:14
                  .= (Den (o,OAF.d)).{} by A7,A75,A77,CARD_3:19,TARSKI:def 1;
                hence thesis;
              end;
A84:          bind (B,i,j) is_homomorphism OAF.i,OAF.j by A10,Th2;
              set F = bind (B,i,j);
A85:          x1.i = Den (o,OAF.i).{} by A80;
A86:          x1.j = Den (o,OAF.j).{} by A80;
              Args(o,OAF.i) = {{}} by A75,PRALG_2:11;

then reconsider E = {} as Element of Args(o,OAF.i) by TARSKI:def 1;
A87:          (F.the_result_sort_of o).(x1.i) = Den (o,OAF.j).(F#E) by A84,A85,
              MSUALG_3:def 9;
              Args(o,OAF.j) = {{}} by A75,PRALG_2:11;

hence (F.the_result_sort_of o).(x1.i) = x1.j by A86,A87,TARSKI:def 1;
            end;
          end;
          then x in { f where f is Element of product
          Carrier (OAF,the_result_sort_of o) :
          for i,j st i >= j holds (bind (B,i,j).(the_result_sort_of o)).
          (f.i) = f.j } by A9;
          hence x in C.the_result_sort_of o by A1;
        end;
        then x in C.the_result_sort_of o;
        then
A88:    x in C.((the ResultSort of S).o) by MSUALG_1:def 7;
        dom (the ResultSort of S) = the OperSymbols of S by FUNCT_2:def 1;
        hence x in (C * the ResultSort of S).o by A6,A88,FUNCT_1:23;
      end;
      hence C is_closed_on o by MSUALG_2:def 6;
    end;
    then
A89: C is opers_closed by MSUALG_2:def 7;
    reconsider L = product OAF as non-empty MSAlgebra over S;
    reconsider C as MSSubset of L;
    set MSA = L|C;
A90: MSA = MSAlgebra (#C, Opers(L,C)#) by A89,MSUALG_2:def 16;
    now
      let s be SortSymbol of S;
      let f be Element of (SORTS OAF).s;
A91:  f is Element of product Carrier(OAF,s) by PRALG_2:def 17;
      thus f in (the Sorts of MSA).s iff
      for i,j st i >= j holds (bind (B,i,j).s).(f.i) = f.j
      proof
        hereby
          assume f in (the Sorts of MSA).s;
          then f in { g where g is Element of product Carrier (OAF,s) :
          for i,j st i >= j holds (bind (B,i,j).s).(g.i) = g.j } by A1,A90;
          then consider k be Element of product Carrier (OAF,s) such that
A92:      k = f and
A93:      for i,j st i >= j holds (bind (B,i,j).s).(k.i) = k.j;
          thus for i,j st i >= j holds (bind (B,i,j).s).(f.i) = f.j by A92,A93;
        end;
        assume for i,j st i >= j holds (bind (B,i,j).s).(f.i) = f.j;
        then f in { h where h is Element of product Carrier (OAF,s) :
        for i,j st i >= j holds (bind (B,i,j).s).(h.i) = h.j } by A91;
        hence thesis by A1,A90;
      end;
    end;
    hence thesis;
  end;
  uniqueness
  proof
    let A1,A2 be strict MSSubAlgebra of product OAF such that
A94: for s be SortSymbol of S for f be Element of (SORTS OAF).s holds
    f in (the Sorts of A1).s iff
    for i,j st i >= j holds (bind (B,i,j).s).(f.i) = f.j and
A95: for s be SortSymbol of S for f be Element of (SORTS OAF).s holds
    f in (the Sorts of A2).s iff
    for i,j st i >= j holds (bind (B,i,j).s).(f.i) = f.j;
    for s be set st s in the carrier of S holds (the Sorts of A1).s =
    (the Sorts of A2).s
    proof
      let a be set;
      assume a in the carrier of S;
      then reconsider s = a as SortSymbol of S;
      thus (the Sorts of A1).a c= (the Sorts of A2).a
      proof
        let e be set;
        assume
A96:    e in (the Sorts of A1).a;
        (the Sorts of A1) is MSSubset of product OAF by MSUALG_2:def 10;
        then (the Sorts of A1) c= the Sorts of product OAF by PBOOLE:def 23;
        then (the Sorts of A1) c= SORTS OAF by PRALG_2:20;
        then (the Sorts of A1).s c= (SORTS OAF).s by PBOOLE:def 5;
        then reconsider f = e as Element of (SORTS OAF).s by A96;
        for i,j st i >= j holds (bind (B,i,j).s).(f.i) = f.j by A94,A96;
        hence e in (the Sorts of A2).a by A95;
      end;
      let e be set;
      assume
A97:  e in (the Sorts of A2).a;
      (the Sorts of A2) is MSSubset of product OAF by MSUALG_2:def 10;
      then (the Sorts of A2) c= the Sorts of product OAF by PBOOLE:def 23;
      then (the Sorts of A2) c= SORTS OAF by PRALG_2:20;
      then (the Sorts of A2).s c= (SORTS OAF).s by PBOOLE:def 5;
      then reconsider f = e as Element of (SORTS OAF).s by A97;
      for i,j st i >= j holds (bind (B,i,j).s).(f.i) = f.j by A95,A97;
      hence e in (the Sorts of A1).a by A94;
    end;
    then the Sorts of A1 = the Sorts of A2 by PBOOLE:3;
    hence A1 = A2 by MSUALG_2:10;
  end;
end;

theorem
  for DP be discrete non empty Poset, S for OAF be OrderedAlgFam of DP,S
  for B be normalized Binding of OAF holds InvLim B = product OAF
proof
  let DP be discrete non empty Poset, S;
  let OAF be OrderedAlgFam of DP,S;
  let B be normalized Binding of OAF;
  for s be set st s in the carrier of S holds
  (the Sorts of InvLim B).s = (the Sorts of product OAF).s
  proof
    let a be set;
    assume a in the carrier of S;
    then reconsider s = a as SortSymbol of S;
    thus (the Sorts of InvLim B).a c= (the Sorts of product OAF).a
    proof
      let e be set;
      assume
A1:   e in (the Sorts of InvLim B).a;
      (the Sorts of InvLim B) is MSSubset of product OAF by MSUALG_2:def 10;

then (the Sorts of InvLim B) c= the Sorts of product OAF by PBOOLE:def 23;
      then (the Sorts of InvLim B).s c= (the Sorts of product OAF).s by
      PBOOLE:def 5;
      hence e in (the Sorts of product OAF).a by A1;
    end;
    let e be set;
    assume e in (the Sorts of product OAF).a;
    then reconsider f = e as Element of (SORTS OAF).s by PRALG_2:20;
    for i,j be Element of DP st i >= j holds (bind (B,i,j).s).(f.i) = f.j
    proof
      let i,j be Element of DP;
      assume i >= j;
      then
A2:   i = j by ORDERS_3:1;
      bind (B,i,i) = B.(i,i) by Def3,ORDERS_2:24
        .= id (the Sorts of OAF.i) by Def4;
      then
A3:   (bind (B,i,i).s) = id ((the Sorts of OAF.i).s) by MSUALG_3:def 1;
A4:   dom (Carrier (OAF,s)) = the carrier of DP by PBOOLE:def 3;
      f in (SORTS OAF).s;
      then f in product Carrier (OAF,s) by PRALG_2:def 17;
      then
A5:   f.i in (Carrier (OAF,s)).i by A4,CARD_3:18;
      consider U0 being MSAlgebra over S such that
A6:   U0 = OAF.i & (Carrier (OAF,s)).i = ((the Sorts of U0).s)
      by PRALG_2:def 16;
      thus thesis by A2,A3,A5,A6,FUNCT_1:35;
    end;
    hence e in (the Sorts of InvLim B).a by Def6;
  end;
  then
A7: the Sorts of InvLim B = the Sorts of product OAF by PBOOLE:3;
  product OAF is MSSubAlgebra of product OAF by MSUALG_2:6;
  hence thesis by A7,MSUALG_2:10;
end;

begin  :: Sets and Morphisms of Many Sorted Signatures

reserve x for set,
  A for non empty set;

definition
  let X be set;
  attr X is MSS-membered means
  :Def7:
  x in X implies x is strict non empty non void ManySortedSign;
end;

registration
  cluster non empty MSS-membered set;
  existence
  proof
    consider S be strict non empty non void ManySortedSign;
    set A = {S};
    for x be set st x in A holds
    x is strict non empty non void ManySortedSign by TARSKI:def 1;
    then A is MSS-membered by Def7;
    hence thesis;
  end;
end;

definition
  func TrivialMSSign -> strict ManySortedSign means
  :Def8:
  it is empty void;
  existence
  proof
    {} in {}* by FINSEQ_1:66;
    then reconsider f = {}-->{} as Function of {},{}* by FUNCOP_1:58;
    dom ({} --> {}) = {} & rng ({} --> {}) = {};
    then reconsider g = {} --> {} as Function of {},{} by FUNCT_2:def 1
    ,RELSET_1:11;
    take ManySortedSign(#{},{},f,g#);
    thus thesis by MSUALG_1:def 5;
  end;
  uniqueness
  proof
    let C1, C2 be strict ManySortedSign;
    assume that
A1: C1 is empty void and
A2: C2 is empty void;
    C1 = C2
    proof
A3:   the carrier of C1 = {} & the carrier of C2 = {} by A1,A2;
A4:   the OperSymbols of C1 = {} & the OperSymbols of C2 = {}
      by A1,A2,MSUALG_1:def 5;
      then reconsider RS = the ResultSort of C1, RT = the ResultSort of C2
      as Function of {},{} by A3;
A5:   RS in { id {} } & RT in { id {} } by ALTCAT_1:3,FUNCT_2:12;
      reconsider A = the Arity of C1, B = the Arity of C2 as
      Function of {}, {{}} by A3,A4,FUNCT_7:19;
A6:   A = B by FUNCT_2:66;
      the ResultSort of C1 = id {} by A5,TARSKI:def 1
        .= the ResultSort of C2 by A5,TARSKI:def 1;
      hence thesis by A3,A4,A6;
    end;
    hence thesis;
  end;
end;

registration
  cluster TrivialMSSign -> empty void;
  coherence by Def8;
end;

registration
  cluster strict empty void ManySortedSign;
  existence
  proof
    take TrivialMSSign;
    thus thesis;
  end;
end;

Lm1: for S be empty void ManySortedSign holds id the carrier of S,
id the OperSymbols of S form_morphism_between S,S
proof
  let S be empty void ManySortedSign;
  set f = id the carrier of S;
A1: rng f = the carrier of S & rng f = the OperSymbols of S
  by MSUALG_1:def 5;
A2: {}*the ResultSort of S = (the ResultSort of S)*{};
  for o be set, p be Function st
  o in the OperSymbols of S & p = (the Arity of S).o holds
  f*p = (the Arity of S).(f.o) by MSUALG_1:def 5;
  hence thesis by A1,A2,PUA2MSS1:def 13,RELAT_1:60,81;
end;

Lm2: for S be non empty void ManySortedSign
holds id the carrier of S, id the OperSymbols of S form_morphism_between S,S
proof
  let S be non empty void ManySortedSign;
  set f = id the carrier of S, g = id the OperSymbols of S;
A1: the carrier of S <> {} & the OperSymbols of S = {} by MSUALG_1:def 5;
  then
A2: dom f = the carrier of S & dom g = the OperSymbols of S &
  rng f c= the carrier of S & rng g c= the OperSymbols of S by FUNCT_2:def 1;
  dom (the ResultSort of S) = {} by A1;
  then the ResultSort of S = {};
  then
A3: f*the ResultSort of S = {} & (the ResultSort of S)*g = {};
  for o be set, p be Function st
  o in the OperSymbols of S & p = (the Arity of S).o holds
  f*p = (the Arity of S).(g.o) by MSUALG_1:def 5;
  hence thesis by A2,A3,PUA2MSS1:def 13;
end;

theorem
  for S be void ManySortedSign
  holds id the carrier of S, id the OperSymbols of S form_morphism_between S,S
proof
  let S be void ManySortedSign;
  per cases;
  suppose S is empty;
    hence thesis by Lm1;
  end;
  suppose S is non empty;
    hence thesis by Lm2;
  end;
end;

definition
  let A;
  func MSS_set A means
  :Def9:
  x in it iff
  ex S be strict non empty non void ManySortedSign st x = S &
  ( the carrier of S c= A & the OperSymbols of S c= A );
  existence
  proof
    defpred P[set,set] means
    ex S be strict non empty non void ManySortedSign st S = $2 &
    $1 = [the carrier of S, the OperSymbols of S,
    the Arity of S, the ResultSort of S];
A1: for x,y,z be set st P[x,y] & P[x,z] holds y = z
    proof
      let x,y,z be set;
      assume P[x,y] & P[x,z];

then consider S1, S2 be strict non empty non void ManySortedSign such that
A2:   S1 = y & x = [the carrier of S1, the OperSymbols of S1,
      the Arity of S1, the ResultSort of S1] & S2 = z &
      x = [the carrier of S2, the OperSymbols of S2,
      the Arity of S2, the ResultSort of S2] &
      (S2 is empty implies S2 is void);
      the carrier of S1 = the carrier of S2 &
      the OperSymbols of S1 = the OperSymbols of S2 &
      the Arity of S1 = the Arity of S2 &
      the ResultSort of S1 = the ResultSort of S2 by A2,MCART_1:33;
      hence thesis by A2;
    end;
    consider X be set such that
A3: for x holds x in X iff
    ex y be set st y in [:bool A, bool A, PFuncs(A,A*), PFuncs(A,A):]
    & P[y,x] from TARSKI:sch 1 (A1);
    take X;
    let x be set;
    thus x in X iff
    ex S be strict non empty non void ManySortedSign st x = S &
    ( the carrier of S c= A & the OperSymbols of S c= A )
    proof
      thus x in X implies
      ex S be strict non empty non void ManySortedSign st x = S &
      ( the carrier of S c= A & the OperSymbols of S c= A )
      proof
        assume x in X;
        then consider y be set such that
A4:     y in [:bool A, bool A, PFuncs(A,A*), PFuncs(A,A):] & P[y,x] by A3;
        consider S be strict non empty non void ManySortedSign such that
A5:     S = x & y = [the carrier of S, the OperSymbols of S,
        the Arity of S, the ResultSort of S] by A4;
        take S;
        the carrier of S in bool A & the OperSymbols of S in bool A
        by A4,A5,MCART_1:84;
        hence thesis by A5;
      end;
      given S be strict non empty non void ManySortedSign such that
A6:   x = S & ( the carrier of S c= A & the OperSymbols of S c= A );
      consider y be set such that
A7:   y = [the carrier of S,the OperSymbols of S,the Arity of S,
      the ResultSort of S];
      reconsider C = the carrier of S as Subset of A by A6;
A8:   C* c= A* by MSUHOM_1:2;
A9:   dom the Arity of S c= A & rng the Arity of S c= (the carrier of S)*
      by A6,FUNCT_2:def 1;
      rng the Arity of S c= A* by A8,XBOOLE_1:1;
      then
A10:  the Arity of S in PFuncs (A,A*) by A9,PARTFUN1:def 5;
A11:  dom the ResultSort of S = the OperSymbols of S by FUNCT_2:def 1;
      rng the ResultSort of S c= A by A6,XBOOLE_1:1;
      then the ResultSort of S in PFuncs (A,A) by A6,A11,PARTFUN1:def 5;
      then y in [:bool A, bool A, PFuncs(A,A*), PFuncs(A,A):]
      by A6,A7,A10,MCART_1:84;
      hence thesis by A3,A6,A7;
    end;
  end;
  uniqueness
  proof
    let A1, A2 be set such that
A12: x in A1 iff ex S be strict non empty non void ManySortedSign st x = S &
    ( the carrier of S c= A & the OperSymbols of S c= A ) and
A13: x in A2 iff ex S be strict non empty non void ManySortedSign st x = S &
    ( the carrier of S c= A & the OperSymbols of S c= A );
    thus A1 c= A2
    proof
      let x be set;
      assume x in A1;
      then ex S be strict non empty non void ManySortedSign st x = S &
      ( the carrier of S c= A & the OperSymbols of S c= A ) by A12;
      hence thesis by A13;
    end;
    thus A2 c= A1
    proof
      let x be set;
      assume x in A2;
      then ex S be strict non empty non void ManySortedSign st x = S &
      ( the carrier of S c= A & the OperSymbols of S c= A ) by A13;
      hence thesis by A12;
    end;
  end;
end;

registration
  let A;
  cluster MSS_set A -> non empty MSS-membered;
  coherence
  proof
    consider a be Element of A;
    set X = MSS_set A;
A1: {a} c= A by ZFMISC_1:37;
    a in {a} by TARSKI:def 1;
    then <*a*> in {a}* by FUNCT_7:20;
    then reconsider f = {a}--><*a*> as Function of {a},{a}* by FUNCOP_1:58;
    dom ({a} --> a) = {a} & rng ({a} --> a) c= {a} by FUNCOP_1:19;
    then reconsider g = {a} --> a as Function of {a},{a} by FUNCT_2:4;
    ManySortedSign(#{a},{a},f,g#) in X
    proof
      set SI = ManySortedSign(#{a},{a},f,g#);
      SI is non void non empty by MSUALG_1:def 5;
      hence thesis by A1,Def9;
    end;
    hence X is non empty;
    thus X is MSS-membered
    proof
      let x be set;
      assume x in X;
      then consider S be strict non empty non void ManySortedSign such that
A2:   x = S & the carrier of S c= A & the OperSymbols of S c= A by Def9;
      thus thesis by A2;
    end;
  end;
end;

definition
  let A be non empty MSS-membered set;
  redefine mode Element of A -> strict non empty non void ManySortedSign;
  coherence by Def7;
end;

definition
  let S1,S2 be ManySortedSign;
  func MSS_morph (S1,S2) means

  x in it iff
  ex f,g be Function st x = [f,g] & f,g form_morphism_between S1,S2;
  existence
  proof
    defpred P[set] means
    ex f,g be Function st $1 = [f,g] & f,g form_morphism_between S1,S2;
    consider X be set such that
A1: x in X iff x in [:PFuncs (the carrier of S1, the carrier of S2),
    PFuncs (the OperSymbols of S1, the OperSymbols of S2):] &
    P[x] from XBOOLE_0:sch 1;
    take X;
    thus x in X iff
    ex f,g be Function st x = [f,g] & f,g form_morphism_between S1,S2
    proof
      thus x in X implies
      ex f,g be Function st x = [f,g] & f,g form_morphism_between S1,S2 by A1;
      given f,g be Function such that
A2:   x = [f,g] & f,g form_morphism_between S1,S2;
      dom f = the carrier of S1 & dom g = the OperSymbols of S1 &
      rng f c= the carrier of S2 & rng g c= the OperSymbols of S2
      by A2,PUA2MSS1:def 13;
      then f in PFuncs (the carrier of S1, the carrier of S2) &
      g in PFuncs (the OperSymbols of S1, the OperSymbols of S2)
      by PARTFUN1:def 5;
      then x in [:PFuncs (the carrier of S1, the carrier of S2),
      PFuncs (the OperSymbols of S1, the OperSymbols of S2):]
      by A2,ZFMISC_1:106;
      hence thesis by A1,A2;
    end;
  end;
  uniqueness
  proof
    let A1,A2 be set;
    assume that
A3: x in A1 iff
    ex f,g be Function st x = [f,g] & f,g form_morphism_between S1,S2 and
A4: x in A2 iff
    ex f,g be Function st x = [f,g] & f,g form_morphism_between S1,S2;
    thus A1 = A2
    proof
      thus A1 c= A2
      proof
        let x;
        assume x in A1;
        then ex f,g be Function st x = [f,g] & f,g form_morphism_between S1,S2
        by A3;
        hence x in A2 by A4;
      end;
      thus A2 c= A1
      proof
        let x;
        assume x in A2;
        then ex f,g be Function st x = [f,g] & f,g form_morphism_between S1,S2
        by A4;
        hence x in A1 by A3;
      end;
    end;
  end;
end;

