:: Initialization Halting Concepts and Their Basic Properties of SCM+FSA
::  by JingChao Chen and Yatsuka Nakamura
::
:: Received June 17, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies SCMFSA6A, AMI_1, SCMFSA_2, FUNCT_1, RELAT_1, CAT_1, FUNCT_4,
      AMI_3, BOOLE, SCMFSA6B, FUNCT_7, SF_MASTR, FINSEQ_1, INT_1,
      AMI_5, RELOC, SCM_1, CARD_1, SCMFSA6C, SCMFSA7B, UNIALG_2,
      SCMFSA8B, ARYTM_1, SCMFSA8C, SCMFSA8A, SCM_HALT, CARD_3, ARYTM,
      AMISTD_2;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, RELAT_1, FINSEQ_1, FUNCT_1, FUNCT_4, FUNCT_7, CARD_3,
      STRUCT_0, AMI_1,
      SCMNORM, SCMFSA_2, FUNCOP_1, SCMFSA_4, SCMFSA6B, SCMFSA_5, SCMFSA6A,
      SF_MASTR, SCMFSA8A, SCMFSA8B, SCMFSA8C, SCMFSA7B, NAT_D, SCMFSA_3,
      SCMFSA6C, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, NAT_1, PARTFUN1, SCM_1, SCMFSA_3,
      SCMFSA_5, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B,
      SCMFSA8C, SCMNORM, SCMFSA_4, NAT_D;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, RELSET_1, FUNCOP_1, FRAENKEL,
      NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, SCMFSA_2,
      SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8C,
      SCMFSA_9, ORDINAL1, SCMNORM, FINSET_1, AMI_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCOP_1, AMI_1, XBOOLE_0, SCMFSA_2, SCMFSA8C, SCMFSA8A, SCMFSA6A,
      SCMNORM;
 theorems SF_MASTR, FUNCT_1, FUNCT_7, FUNCOP_1, RELAT_1, AMI_1, SCMFSA6A,
      FUNCT_4, ENUMSET1, AMI_3, NAT_1, TARSKI, INT_1, GRFUNC_1,
      BINARITH, SCMFSA_2, SCMFSA6B, SCMFSA7B, SCMFSA8B, SCMFSA8A, SCMFSA8C,
      SCMFSA_4, SCMFSA_5, LATTICE2, SCMFSA_3, SCMFSA6C, PRE_CIRC, FSM_1,
      XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0, VALUED_1, SCMNORM,
      CARD_3, XREAL_0;
 schemes NAT_1, SCMFSA6A;

begin

reserve m,n for Element of NAT,
  I for Program of SCM+FSA,
  s,s1,s2 for State of SCM+FSA,
  a for Int-Location,
  f for FinSeq-Location;

definition
  let I be Program of SCM+FSA;
  attr I is InitClosed means
  :Def1:
  for s being State of SCM+FSA, n being Element of NAT st Initialized I c= s
  holds IC Computation(s,n) in dom I;
  attr I is InitHalting means
  :Def2:
  Initialized I is halting;
  attr I is keepInt0_1 means
  :Def3:  ::def5
  for s being State of SCM+FSA st Initialized I c= s
  for k being Element of NAT holds (Computation(s,k)).intloc 0 = 1;
end;

theorem Th1:  ::TM001
  for x being set,i,m,n being Element of NAT st
  x in dom (((intloc i) .--> m) +* Start-At insloc n) holds
  x=intloc i or x=IC SCM+FSA
proof
  let x be set,i,m,n be Element of NAT;
  set iS = ((intloc i) .--> m) +* Start-At insloc n;
  assume
A1: x in dom iS;
A2: dom ((intloc i) .--> m) ={intloc i } by FUNCOP_1:19;
  dom(Start-At insloc n) = {IC SCM+FSA} by FUNCOP_1:19;
  then dom iS ={intloc i} \/ {IC SCM+FSA} by A2,FUNCT_4:def 1;
  then x in{intloc i} or x in {IC SCM+FSA} by A1,XBOOLE_0:def 3;
  hence thesis by TARSKI:def 1;
end;

theorem Th2:  ::TM002
  for I being Program of SCM+FSA,i,m,n being Element of NAT holds
  dom I misses dom (((intloc i) .--> m) +* Start-At insloc n)
proof
  let I be Program of SCM+FSA,i,m,n be Element of NAT;
  set iS = ((intloc i) .--> m) +* Start-At insloc n;
  assume dom I /\ dom iS <> {};
  then consider x being set such that
A1: x in dom I /\ dom iS by XBOOLE_0:def 1;
A2: x in dom I & x in dom iS by A1,XBOOLE_0:def 4;
  dom I c= NAT by AMI_1:def 40;
  then reconsider x as Instruction-Location of SCM+FSA by A2,AMI_1:def 4;
  per cases by A2,Th1;
  suppose x = intloc i;
    hence contradiction by SCMFSA_2:84;
  end;
  suppose x = IC SCM+FSA;
    hence contradiction by AMI_1:48;
  end;
end;
set iS = ((intloc 0) .--> 1) +* Start-At insloc 0;

canceled;

theorem Th4:
  Macro halt SCM+FSA is InitHalting
proof
  set m = Macro halt SCM+FSA;
  set m1 = Initialized m;
  let s be State of SCM+FSA;
  assume
A1: m1 c= s;
A3: m1=m +* iS by FUNCT_4:15;
  dom(Start-At insloc 0) = {IC SCM+FSA} by FUNCOP_1:19;
  then
A4: IC SCM+FSA in dom (Start-At insloc 0) by TARSKI:def 1;
  then
A5: IC SCM+FSA in dom m1 by FUNCT_4:13;
A7: m.insloc 0 = halt SCM+FSA by FUNCT_4:66;
A8: m c= m1 by SCMFSA6A:26;
  dom m = {insloc 0,insloc 1} by FUNCT_4:65;
  then
A9: insloc 0 in dom m by TARSKI:def 2;
  then
A10: insloc 0 in dom m1 by A3,FUNCT_4:13;
A11: IC m1 = m1.IC SCM+FSA by A5,AMI_1:def 43
    .= (Start-At insloc 0).IC SCM+FSA by A4,FUNCT_4:14
    .= insloc 0 by FUNCOP_1:87;
  take 0;
  thus CurInstr(Computation(s,0)) = CurInstr s by AMI_1:13
    .= s.IC m1 by A1,A5,AMI_1:97
    .= m1.insloc 0 by A1,A10,A11,GRFUNC_1:8
    .= halt SCM+FSA by A7,A8,A9,GRFUNC_1:8;
end;

registration
  cluster InitHalting Program of SCM+FSA;
  existence by Th4;
end;

theorem Th5:  ::TM006=HA2,HA,SCMFSA6B:19
  for I being InitHalting Program of SCM+FSA
  st Initialized I c= s holds s is halting
proof
  let I be InitHalting Program of SCM+FSA;
  assume
A1: Initialized I c= s;
  Initialized I is halting by Def2;
  hence s is halting by A1,AMI_1:def 26;
end;

theorem Th6:  ::TM007
  I +* Start-At insloc 0 c= Initialized I
proof
  set SA=Start-At insloc 0;
A1: SA c= Initialized I by FUNCT_4:26;
  I c= Initialized I by SCMFSA6A:26;
  then
A2: I \/ SA c= Initialized I by A1,XBOOLE_1:8;
  I +* SA c= I \/ SA by FUNCT_4:30;
  hence thesis by A2,XBOOLE_1:1;
end;

theorem Th7:  ::int0_1
  for I being Program of SCM+FSA,s being State of SCM+FSA st
  Initialized I c= s holds s.intloc 0 =1
proof
  let I be Program of SCM+FSA,s be State of SCM+FSA;
  assume
A1: Initialized I c= s;
A2: intloc 0 in dom Initialized I by SCMFSA6A:45;
  (Initialized I).intloc 0 = 1 by SCMFSA6A:46;
  hence thesis by A1,A2,GRFUNC_1:8;
end;

registration
  cluster paraclosed -> InitClosed Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
A1: I is paraclosed;
    set SA=Start-At insloc 0;
A2: I +* SA c= Initialized I by Th6;
    now
      let s be State of SCM+FSA, n be Element of NAT;
      assume Initialized I c= s;
      then I +* SA c=s by A2,XBOOLE_1:1;
      hence IC Computation(s,n) in dom I by A1,SCMFSA6B:def 2;
    end;
    hence thesis by Def1;
  end;
end;

registration
  cluster parahalting -> InitHalting Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume I is parahalting;
    then reconsider I as parahalting Program of SCM+FSA;
    Initialized I is halting;
    hence thesis by Def2;
  end;
end;

registration
  cluster InitHalting -> InitClosed Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
A1: I is InitHalting;
    let s be State of SCM+FSA, n be Element of NAT;
    assume
A2: Initialized I c= s;
    defpred X[Nat] means not IC Computation(s,$1) in dom I;
    assume not IC Computation(s,n) in dom I;
    then
A3: ex n be Nat st X[n];
    consider n be Nat such that
A4: X[n] and
A5: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A3);
    reconsider n as Element of NAT by ORDINAL1:def 13;
    set s2 = Computation(s,n),
    s0 = s +*(IC s2, goto IC s2), s1 = s2 +*(IC s2, goto IC s2);
    set II = Initialized I;
A6: I c= II by SCMFSA6A:26;
A7: II is halting by A1,Def2;
A8: IC s2 in NAT by AMI_1:def 4;
    II | NAT = I by SCMFSA6A:33;
    then dom I = dom II /\ NAT by RELAT_1:90;
    then not IC s2 in dom II by A4,A8,XBOOLE_0:def 4;
    then
A9: II c= s0 by A2,FUNCT_7:91;
    then
A10: s0 is halting by A7,AMI_1:def 26;
A11: s0,s equal_outside NAT by A8,FUNCT_7:28,93;
A12: I c= s0 by A6,A9,XBOOLE_1:1;
A13: I c= s by A2,A6,XBOOLE_1:1;
    for m st m < n holds IC(Computation(s,m)) in dom I by A5;
    then
A14: Computation(s0,n),s2 equal_outside NAT by A11,A12,A13,SCMFSA6B:21;
A15: s2,s1 equal_outside NAT by A8,FUNCT_7:93;
A16: s|NAT = s2|NAT by AMI_1:123;
    Computation(s0,n)|NAT = s0|NAT by AMI_1:123
      .= s1|NAT by A16,FUNCT_7:95;
    then
A17: Computation(s0,n) = s1 by A14,A15,FUNCT_7:29,92;
    s1 is not halting by SCMFSA6B:20;
    hence contradiction by A10,A17,AMI_1:93;
  end;
  cluster keepInt0_1 -> InitClosed Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
A18: I is keepInt0_1;
    let s be State of SCM+FSA, n be Element of NAT;
    assume
A19: Initialized I c= s;
A20: dom I c= NAT by AMI_1:def 40;
    defpred X[Nat] means not IC Computation(s,$1) in dom I;
    assume not IC Computation(s,n) in dom I;
    then
A21: ex n be Nat st X[n];
    consider n be Nat such that
A22: X[n] and
A23: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A21);
    reconsider n as Element of NAT by ORDINAL1:def 13;
    set FI = FirstNotUsed(I);
    set s2 = Computation(s,n), s00 = s +*(IC s2, intloc 0 := FI);
    set s0 = s00+* (FI, (s.intloc 0)+1);
    reconsider s00 as State of SCM+FSA;
    reconsider s0 as State of SCM+FSA;
    not I is keepInt0_1
    proof
      take s0;
      set IS = Initialized I;
      set iIC={intloc 0} \/ {IC SCM+FSA};
A24:  dom IS = dom I \/ {intloc 0} \/ {IC SCM+FSA} by SCMFSA6A:43
        .= dom I \/ iIC by XBOOLE_1:4;
      IC s2 <> IC SCM+FSA by AMI_1:48;
      then
A25:  not IC s2 in {IC SCM+FSA} by TARSKI:def 1;
      IC s2 <> intloc 0 by SCMFSA_2:84;
      then not IC s2 in {intloc 0} by TARSKI:def 1;
      then not IC s2 in iIC by A25,XBOOLE_0:def 3;
      then not IC s2 in dom IS by A22,A24,XBOOLE_0:def 3;
      then
A26:  IS c= s00 by A19,FUNCT_7:91;
A27:  now
        assume FI in dom I;
        then reconsider FI as Instruction-Location of SCM+FSA
        by A20,AMI_1:def 4;
        FI = FI;
        hence contradiction by SCMFSA_2:84;
      end;
      FI <> IC SCM+FSA by SCMFSA_2:81;
      then
A28:  not FI in {IC SCM+FSA} by TARSKI:def 1;
      not FI in {intloc 0} by TARSKI:def 1;
      then not FI in iIC by A28,XBOOLE_0:def 3;
      then not FI in dom IS by A24,A27,XBOOLE_0:def 3;
      hence Initialized I c= s0 by A26,FUNCT_7:91;
      then
A29:  I +*Start-At insloc 0 c= s0 by SCMFSA6B:8;
A30:  I +*Start-At insloc 0 c= s by A19,SCMFSA6B:8;
      take k = n+1;
      set s02 = Computation(s0,n);
A31:  (for m st m < n holds IC Computation(s,m) in dom I) by A23;
A32:  not FI in UsedIntLoc I by SF_MASTR:54;
A33:  not IC s2 in UsedIntLoc I
      proof
        assume not thesis;
        then IC s2 is Int-Location by SCMFSA_2:11;
        hence contradiction by SCMFSA_2:84;
      end;
A34:  s0 | UsedIntLoc I = s00 | UsedIntLoc I by FUNCT_7:94,SF_MASTR:54
        .= s | UsedIntLoc I by A33,FUNCT_7:94;
A35:  not FI in UsedInt*Loc I
      proof
        assume not thesis;
        then FI is FinSeq-Location by SCMFSA_2:12;
        hence contradiction by SCMFSA_2:83;
      end;
A36:  not IC s2 in UsedInt*Loc I
      proof
        assume not thesis;
        then IC s2 is FinSeq-Location by SCMFSA_2:12;
        hence contradiction by SCMFSA_2:85;
      end;
A37:  s.intloc 0=1 by A19,Th7;
A38:  s0 | UsedInt*Loc I = s00 | UsedInt*Loc I by A35,FUNCT_7:94
        .= s | UsedInt*Loc I by A36,FUNCT_7:94;
      then
A39:  (for m st m < n holds IC Computation(s0,m) in dom I)
      by A29,A30,A31,A34,SF_MASTR:73;
A40:  IC s02 = IC s2 by A29,A30,A31,A34,A38,SF_MASTR:73;
      FI in dom s00 by SCMFSA_2:66;
      then s0.FI = (s.intloc 0)+1 by FUNCT_7:33;
      then
A41:  s02.FI = 1+1 by A29,A32,A37,A39,SF_MASTR:69;
A42:  IC s2 in dom s by AMI_1:116;
      IC s2 <> FI & IC s2 in dom s00 by AMI_1:116,SCMFSA_2:84;
      then
A43:  s0.IC s2 = s00.IC s2 by FUNCT_7:34
        .= intloc 0 := FI by A42,FUNCT_7:33;
      Computation(s0,k) = Following s02 by AMI_1:14
        .= Exec(intloc 0 := FI, s02) by A40,A43,AMI_1:54;
      hence (Computation(s0,k)).intloc 0 <> 1 by A41,SCMFSA_2:89;
    end;
    hence contradiction by A18;
  end;
  cluster keeping_0 -> keepInt0_1 Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
A44: I is keeping_0;
    now
      let s be State of SCM+FSA;
      assume
A45:  Initialized I c= s;
      then
A46:  s.intloc 0=1 by Th7;
      I +* Start-At insloc 0 c= Initialized I by SCMFSA8C:19;
      then I +* Start-At insloc 0 c= s by A45,XBOOLE_1:1;
      hence for k being Element of NAT holds (Computation(s,k)).intloc 0 = 1
      by A44,A46,SCMFSA6B:def 4;
    end;
    hence thesis by Def3;
  end;
end;

theorem    ::TM008=SCMFSA6B:22
  for I being InitHalting Program of SCM+FSA, a being read-write Int-Location
  holds not a in UsedIntLoc I implies (IExec(I, s)).a = s.a
proof
  let I be InitHalting Program of SCM+FSA, a be read-write Int-Location;
  assume
A1: not a in UsedIntLoc I;
A2: IExec(I,s) = Result(s+*Initialized I) +* s|NAT by SCMFSA6B:def 1;
  now
    assume a in NAT;
    then reconsider a as Instruction-Location of SCM+FSA by AMI_1:def 4;
    a = a;
    hence contradiction by SCMFSA_2:84;
  end;
  then not a in dom (s|NAT) by RELAT_1:86;
  then
A3: (IExec(I, s)).a = (Result(s+*Initialized I)).a by A2,FUNCT_4:12;
A4: Initialized I c= s+*Initialized I by FUNCT_4:26;
  s+*Initialized I is halting by Th5,FUNCT_4:26;
  then consider n such that
A5: Result(s+*Initialized I) = Computation(s+*Initialized I,n)
  & CurInstr(Result(s+*Initialized I)) = halt SCM+FSA by AMI_1:def 22;
A6: I+*Start-At insloc 0 c= s+*Initialized I by FUNCT_4:26,SCMFSA6B:8;
A7: (for m st m < n holds IC Computation(s+*Initialized I,m)in dom I)
  by A4,Def1;
A8: not a in dom Initialized I & a in dom s by SCMFSA6A:48,SCMFSA_2:66;
  thus (IExec(I, s)).a = (s+*Initialized I).a by A1,A3,A5,A6,A7,SF_MASTR:69
    .= s.a by A8,FUNCT_4:12;
end;

theorem    ::TM010=SCMFSA6B:23
  for I being InitHalting Program of SCM+FSA,f being FinSeq-Location
  holds not f in UsedInt*Loc I implies (IExec(I, s)).f = s.f
proof
  let I be InitHalting Program of SCM+FSA,f be FinSeq-Location;
  assume
A1: not f in UsedInt*Loc I;
A2: IExec(I,s) = Result(s+*Initialized I) +* s|NAT by SCMFSA6B:def 1;
  now
    assume f in NAT;
    then reconsider f as Instruction-Location of SCM+FSA by AMI_1:def 4;
    f = f;
    hence contradiction by SCMFSA_2:85;
  end;
  then not f in dom (s|NAT) by RELAT_1:86;
  then
A3: (IExec(I, s)).f = (Result(s+*Initialized I)).f by A2,FUNCT_4:12;
A4: Initialized I c= s+*Initialized I by FUNCT_4:26;
  s+*Initialized I is halting by Th5,FUNCT_4:26;
  then consider n such that
A5: Result(s+*Initialized I) = Computation(s+*Initialized I,n)
  & CurInstr(Result(s+*Initialized I)) = halt SCM+FSA by AMI_1:def 22;
A6: I+*Start-At insloc 0 c= s+*Initialized I by FUNCT_4:26,SCMFSA6B:8;
A7: (for m st m < n holds IC Computation(s+*Initialized I,m)in dom I)
  by A4,Def1;
A8: not f in dom Initialized I & f in dom s by SCMFSA6A:49,SCMFSA_2:67;
  thus (IExec(I, s)).f = (s+*Initialized I).f by A1,A3,A5,A6,A7,SF_MASTR:71
    .= s.f by A8,FUNCT_4:12;
end;

registration
  let I be InitHalting Program of SCM+FSA;
  cluster Initialized I -> halting;
  coherence by Def2;
end;

registration
  cluster InitHalting -> non empty Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA such that
A1: I is InitHalting and
A2: I is empty;
    reconsider I as InitHalting Program of SCM+FSA by A1;
    deffunc U(Element of NAT) = goto insloc 0;
    deffunc V(Element of NAT) = 1;
    deffunc W(Element of NAT) = <*>INT;
    consider S be State of SCM+FSA such that
A3: IC S = insloc 0 and
A4: for i being Element of NAT holds
    S.insloc i = U(i) & S.intloc i = V(i) & S.fsloc i = W(i) from
    SCMFSA6A:sch 1;
A5: I c= S by A2,XBOOLE_1:2;
A6: intloc 0 in dom S by SCMFSA_2:66;
    S.intloc 0 = 1 by A4;
    then (intloc 0) .--> 1 c= S by A6,FUNCOP_1:88;
    then
A7: I +* ((intloc 0) .--> 1) c= S by A5,FUNCT_4:92;
    IC SCM+FSA in dom S by AMI_1:94;
    then
A8: IC SCM+FSA .--> insloc 0 c= S by A3,FUNCOP_1:88;
    Initialized I c= S by A7,A8,FUNCT_4:92;
    then
A9: S is halting by AMI_1:def 26;
    S.insloc 0 = goto insloc 0 by A4;
    hence contradiction by A3,A9,SCMFSA6B:24;
  end;
end;

theorem Th10:   ::TM012=SCMFSA6B:25
  for I being InitHalting Program of SCM+FSA holds dom I <> {}
proof
  let I be InitHalting Program of SCM+FSA;
  assume
A1: dom I = {};
  deffunc U(Element of NAT) = goto insloc 0;
  deffunc V(Element of NAT) = 1;
  deffunc W(Element of NAT) = <*>INT;
  consider s be State of SCM+FSA such that
A2: IC s = insloc 0 and
A3: for i being Element of NAT holds s.insloc i = U(i) &
  s.intloc i = V(i) & s.fsloc i = W(i) from SCMFSA6A:sch 1;
A4: dom s = Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} \/
  NAT by AMI_1:79,SCMFSA_2:8;
  then
A5: dom s = {IC SCM+FSA} \/ ((Int-Locations \/ FinSeq-Locations) \/
  NAT) by XBOOLE_1:4;
A6: dom s = FinSeq-Locations \/ {IC SCM+FSA} \/ Int-Locations \/
  (NAT) by A4,XBOOLE_1:4
    .= FinSeq-Locations \/ {IC SCM+FSA} \/
  (NAT) \/ Int-Locations by XBOOLE_1:4;
  s.insloc 0 = goto insloc 0 by A3;
  then s +*(IC s, goto IC s) = s by A2,FUNCT_7:37;
  then
A7: s is not halting by SCMFSA6B:20;
A8: {IC SCM+FSA} c= dom s by A5,XBOOLE_1:7;
  intloc 0 in Int-Locations by SCMFSA_2:9;
  then intloc 0 in dom s by A6,XBOOLE_0:def 3;
  then for x be set st x in {intloc 0} holds x in dom s by TARSKI:def 1;
  then
A9: {intloc 0} c= dom s by TARSKI:def 3;
A10: dom Initialized I = dom I \/ {intloc 0} \/ {IC SCM+FSA} by SCMFSA6A:43
    .= {intloc 0} \/ {IC SCM+FSA} by A1;
  then
A11: dom Initialized I c= dom s by A8,A9,XBOOLE_1:8;
  now
    let x be set;
    assume
A12: x in dom Initialized I;
A13: dom Initialized I = {intloc 0, IC SCM+FSA} by A10,ENUMSET1:41;
    per cases by A12,A13,TARSKI:def 2;
    suppose
A14:  x = intloc 0;
      hence (Initialized I).x = 1 by SCMFSA6A:46
        .= s.x by A3,A14;
    end;
    suppose x = IC SCM+FSA;
      hence (Initialized I).x = s.x by A2,SCMFSA6A:46;
    end;
  end;
  then Initialized I c= s by A11,GRFUNC_1:8;
  hence contradiction by A7,AMI_1:def 26;
end;

theorem Th11:  ::TM014=SCMFSA6B:26
  for I being InitHalting Program of SCM+FSA holds insloc 0 in dom I
proof
  let I be InitHalting Program of SCM+FSA;
  dom I is non empty by Th10;
  then consider x being set such that
A1: x in dom I by XBOOLE_0:def 1;
  dom I c= NAT by AMI_1:def 40;
  then reconsider x as Instruction-Location of SCM+FSA by A1,AMI_1:def 4;
  reconsider n = x as Element of NAT by ORDINAL1:def 13;
  per cases;
  suppose n = 0;
    hence insloc 0 in dom I by A1;
  end;
  suppose 0 < n;
    hence insloc 0 in dom I by A1,SCMNORM:def 1;
  end;
end;

theorem Th12:  ::TM016=SCMFSA6B:27 ::T0
  for J being InitHalting Program of SCM+FSA st Initialized J c= s1
  for n being Element of NAT st ProgramPart Relocated(J,n) c= s2 &
  IC s2 = insloc n & DataPart s1 = DataPart s2
   for i being Element of NAT holds
  IC Computation(s1,i) + n = IC Computation(s2,i) &
  IncAddr(CurInstr (Computation(s1,i)),n) = CurInstr (Computation(s2,i)) &
  DataPart Computation(s1,i) = DataPart Computation(s2,i)
proof
  let J be InitHalting Program of SCM+FSA;
  set JAt = Initialized J;
  assume
A1: JAt c= s1;
  let n be Element of NAT;
  assume that
A2: ProgramPart Relocated(J,n) c= s2 and
A3: IC s2 = insloc n and
A4: DataPart s1 = DataPart s2;
A5: J c= JAt by SCMFSA6A:26;
  then
A6: dom J c= dom JAt by GRFUNC_1:8;
  let i be Element of NAT;
  defpred P[Element of NAT] means
   IC Computation(s1,$1) + n = IC Computation(s2,$1) &
  IncAddr(CurInstr (Computation(s1,$1)),n) = CurInstr (Computation(s2,$1)) &
  DataPart Computation(s1,$1) = DataPart Computation(s2,$1);
A7: P[0]
  proof
A8: IC SCM+FSA in dom JAt by SCMFSA6A:24;
    insloc 0 in dom J by Th11;
    then insloc 0 + n in dom Relocated(J,n) by SCMFSA_5:4;
    then
A9: insloc (0 + n) in dom ProgramPart Relocated(J,n) by AMI_1:106;
    IC Computation(s1,0) = s1.IC SCM+FSA by AMI_1:13
      .= (JAt).IC SCM+FSA by A1,A8,GRFUNC_1:8
      .= insloc 0 by SCMFSA6A:46;
    hence IC Computation(s1,0) + n = IC Computation(s2,0) by A3,AMI_1:13;
A10: insloc 0 in dom J by Th11;
A11: s1.IC s1 = s1.((JAt).IC SCM+FSA) by A1,A8,GRFUNC_1:8
      .= s1.insloc 0 by SCMFSA6A:46
      .= (JAt).insloc 0 by A1,A6,A10,GRFUNC_1:8
      .= J.insloc 0 by A5,A10,GRFUNC_1:8;
    ProgramPart J = J by AMI_1:105;
    then
A12: insloc 0 in dom ProgramPart J by Th11;
    thus IncAddr(CurInstr (Computation(s1,0)),n) = IncAddr(CurInstr s1,n)
     by AMI_1:13
      .= Relocated(J,n).(insloc 0 + n) by A11,A12,SCMFSA_5:7
      .= (ProgramPart Relocated(J,n)).insloc n by FUNCT_1:72
      .= CurInstr s2 by A2,A3,A9,GRFUNC_1:8
      .= CurInstr (Computation(s2,0)) by AMI_1:13;
    thus DataPart Computation(s1,0) = DataPart s2 by A4,AMI_1:13
      .= DataPart Computation(s2,0) by AMI_1:13;
  end;
A13: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A14: P[k];
A15: Computation(s1,k+1) = Following Computation(s1,k) by AMI_1:14
      .= Exec(CurInstr Computation(s1,k),Computation(s1,k));
A16: Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
      .= Exec(CurInstr Computation(s2,k),Computation(s2,k));
    hence
A17: IC Computation(s1,k+1) + n = IC Computation(s2,k+1)
 by A14,A15,SCMFSA6A:41;
    reconsider j = CurInstr Computation(s1,k+1) as Instruction of SCM+FSA;
    reconsider l = IC Computation(s1,k+1) as Element of NAT by ORDINAL1:def 13;
A19: IC Computation(s1,k+1) in dom J by A1,Def1;
    dom ProgramPart J = dom J /\ NAT by FUNCT_1:68;
    then
A20: l in dom ProgramPart J by A19,XBOOLE_0:def 4;
A21: j = s1.IC Computation(s1,k+1) by AMI_1:54
      .= (JAt).IC Computation(s1,k+1) by A1,A6,A19,GRFUNC_1:8
      .= J.l by A5,A19,GRFUNC_1:8;
A22: IC Computation(s2,k+1) in NAT by AMI_1:def 4;
    IC Computation(s2,k+1) in dom Relocated(J,n) by A17,A19,SCMFSA_5:4;
    then IC Computation(s2,k+1) in dom Relocated(J,n) /\ NAT
     by A22,XBOOLE_0:def 4;
    then
A23: IC Computation(s2,k+1) in dom ProgramPart Relocated(J,n) by FUNCT_1:68;
    thus IncAddr(CurInstr Computation(s1,k+1),n)
    = Relocated(J,n).(l + n) by A20,A21,SCMFSA_5:7
      .= (ProgramPart Relocated(J,n)).(IC Computation(s2,k+1))
       by A17,FUNCT_1:72
      .= s2.IC Computation(s2,k+1) by A2,A23,GRFUNC_1:8
      .= CurInstr Computation(s2,k+1) by AMI_1:54;
    thus DataPart Computation(s1,k+1) = DataPart Computation(s2,k+1)
       by A14,A15,A16,SCMFSA6A:41;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A7,A13);
  hence thesis;
end;

theorem Th13:  ::TM018=MacroAt0:
  Initialized I c= s implies I c= s
proof
  assume
A1: Initialized I c= s;
A2: Initialized I =I +* iS by FUNCT_4:15;
  dom I misses dom iS by Th2;
  then I +* iS = I \/ iS by FUNCT_4:32;
  hence thesis by A1,A2,XBOOLE_1:11;
end;

theorem Th14:   :: TM020=SCMFSA6B:28 ::T13
  for I being InitHalting Program of SCM+FSA st
  Initialized I c= s1 & Initialized I c= s2 & s1,s2 equal_outside NAT holds
  for k being Element of NAT holds Computation(s1,k), Computation(s2,k)
  equal_outside NAT &
  CurInstr Computation(s1,k) = CurInstr Computation(s2,k)
proof
  let I be InitHalting Program of SCM+FSA;
  assume that
A1: Initialized I c= s1 and
A2: Initialized I c= s2 and
A3: s1,s2 equal_outside NAT;
A4: I c= s1 by A1,Th13;
A5: I c= s2 by A2,Th13;
  hereby
    let k be Element of NAT;
    for m being Element of NAT st m < k holds IC(Computation(s2,m)) in dom I
    by A2,Def1;
    hence Computation(s1,k), Computation(s2,k) equal_outside
    NAT by A3,A4,A5,SCMFSA6B:21;
    then
A6: IC Computation(s1,k) = IC Computation(s2,k) by AMI_1:121;
A7: IC Computation(s1,k) in dom I by A1,Def1;
A8: IC Computation(s2,k) in dom I by A2,Def1;
    thus CurInstr Computation(s2,k) = s2.IC Computation(s2,k) by AMI_1:54
      .= I.IC Computation(s2,k) by A5,A8,GRFUNC_1:8
      .= s1.IC Computation(s1,k) by A4,A6,A7,GRFUNC_1:8
      .= CurInstr Computation(s1,k) by AMI_1:54;
  end;
end;

theorem Th15:  ::TM022=SCMFSA6B:29 ::T14
  for I being InitHalting Program of SCM+FSA st
  Initialized I c= s1 & Initialized I c= s2 & s1,s2 equal_outside NAT holds
  LifeSpan s1 = LifeSpan s2 & Result s1, Result s2 equal_outside NAT
proof
  let I be InitHalting Program of SCM+FSA;
  assume that
A1: Initialized I c= s1 and
A2: Initialized I c= s2 and
A3: s1,s2 equal_outside NAT;
A4: s1 is halting by A1,Th5;
A5: now
    let l be Element of NAT;
    assume
A6: CurInstr Computation(s2,l) = halt SCM+FSA;
    CurInstr Computation(s1,l) = CurInstr Computation(s2,l) by A1,A2,A3,Th14;
    hence LifeSpan s1 <= l by A4,A6,AMI_1:def 46;
  end;
A7: CurInstr Computation(s2,LifeSpan s1)
  = CurInstr Computation(s1,LifeSpan s1) by A1,A2,A3,Th14
    .= halt SCM+FSA by A4,AMI_1:def 46;
  s2 is halting by A2,Th5;
  hence LifeSpan s1 = LifeSpan s2 by A5,A7,AMI_1:def 46;
  then
A8: Result s2 = Computation(s2,LifeSpan s1) by A2,Th5,AMI_1:122;
  Result s1 = Computation(s1,LifeSpan s1) by A1,Th5,AMI_1:122;
  hence Result s1, Result s2 equal_outside NAT by A1,A2,A3,A8,Th14;
end;

registration
  cluster keeping_0 InitHalting Program of SCM+FSA;
  existence
  proof
    take Macro halt SCM+FSA;
    thus thesis;
  end;
end;

registration
  cluster keepInt0_1 InitHalting Program of SCM+FSA;
  existence
  proof
    take Macro halt SCM+FSA;
    thus thesis;
  end;
end;

canceled;

theorem Th17:  ::TM026=SCMFSA6B:35
  for I being keepInt0_1 InitHalting Program of SCM+FSA
  holds IExec(I, s).intloc 0 = 1
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
A1: Initialized I c= s+*Initialized I by FUNCT_4:26;
  s+*Initialized I is halting by Th5,FUNCT_4:26;
  then consider n such that
A2: Result(s+*Initialized I) = Computation(s+*Initialized I,n)&
  CurInstr(Result(s+*Initialized I)) = halt SCM+FSA by AMI_1:def 22;
  not intloc 0 in NAT
  proof
    assume
A3: intloc 0 in NAT;
    intloc 0 in Int-Locations by SCMFSA_2:9;
    hence contradiction by A3,SCMFSA_2:13,XBOOLE_0:3;
  end;
  then
A4: not intloc 0 in dom(s|NAT) by RELAT_1:86;
  thus IExec(I, s).intloc 0 = (Result(s+*Initialized I)
  +* s|NAT).intloc 0 by SCMFSA6B:def 1
    .= (Result(s+*Initialized I)).intloc 0 by A4,FUNCT_4:12
    .= 1 by A1,A2,Def3;
end;

theorem Th18:  ::TM028=MAI1:
  for I being InitClosed Program of SCM+FSA, J being Program of SCM+FSA
  st Initialized I c= s & s is halting for m st m <= LifeSpan s
  holds Computation(s,m),Computation((s+*(I ';' J)),m) equal_outside NAT
proof
  let I be InitClosed Program of SCM+FSA, J be Program of SCM+FSA;
  assume that
A1: Initialized I c= s and
A2: s is halting;
  defpred X[Element of NAT] means
  $1 <= LifeSpan s implies Computation(s,$1),Computation((s+*(I ';' J)),$1)
  equal_outside NAT;
  Computation(s,0) = s &
   Computation((s+*(I ';' J)),0) = s+*(I ';' J) by AMI_1:13;
  then
A3: X[0] by AMI_1:120;
A4: for m st X[m] holds X[m+1]
  proof
    let m;
    assume
A5: m <= LifeSpan s implies Computation(s,m), Computation((s+*(I ';' J)),m)
    equal_outside NAT;
    assume
A6: m+1 <= LifeSpan s;
    then
A7: m < LifeSpan s by NAT_1:13;
    set sx = s+*(I ';' J);
A8: Computation(s,m+1) = Following Computation(s,m) by AMI_1:14
      .= Exec(CurInstr Computation(s,m),Computation(s,m));
A9: Computation(sx,m+1) = Following Computation(sx,m) by AMI_1:14
      .= Exec(CurInstr Computation(sx,m),Computation(sx,m));
A10: IC(Computation(s,m)) = IC(Computation(sx,m)) by A5,A6,AMI_1:121,NAT_1:13;
A11: IC Computation(s,m) in dom I by A1,Def1;
A12: I c= Computation(s,m) by A1,Th13,AMI_1:81;
A13: I ';' J c= Computation(sx,m) by AMI_1:81,FUNCT_4:26;
    dom(I ';' J)

 = dom Directed I \/ dom ProgramPart Relocated(J, card I) by FUNCT_4:def 1
      .= dom I \/ dom ProgramPart Relocated(J, card I) by FUNCT_4:105;
    then
A14: dom I c= dom(I ';' J) by XBOOLE_1:7;
A15: CurInstr(Computation(s,m)) = I.IC(Computation(s,m)) by A11,A12,GRFUNC_1:8;
    then I.IC(Computation(s,m)) <> halt SCM+FSA by A2,A7,AMI_1:def 46;
    then CurInstr(Computation(s,m)) = (I ';' J).IC(Computation(s,m))
    by A11,A15,SCMFSA6A:54
      .= CurInstr(Computation(sx,m)) by A10,A11,A13,A14,GRFUNC_1:8;
    hence  Computation( s,m+1), Computation((s+*(I ';' J)),m+1)
    equal_outside NAT by A5,A6,A8,A9,NAT_1:13,SCMFSA6A:32;
  end;
  thus for m holds X[m] from NAT_1:sch 1(A3,A4);
end;

theorem Th19:  ::TM030=IScommute:
  for i,m,n being Element of NAT holds
  s+*I+*(((intloc i) .--> m) +* Start-At insloc n) =
  s+*(((intloc i) .--> m) +* Start-At insloc n)+* I
proof
  let i,m,n be Element of NAT;
  set iS = ((intloc i) .--> m) +* Start-At insloc n;
A1: dom I misses dom iS by Th2;
  then I +* iS = I \/ iS by FUNCT_4:32
    .= iS +* I by A1,FUNCT_4:32;
  hence s+*I+* iS = s+*(iS+*I) by FUNCT_4:15
    .= s+*iS +*I by FUNCT_4:15;
end;

theorem Th20:  ::TM031:
  ((intloc 0) .--> 1) +* Start-At insloc 0 c= s implies
  Initialized I c= s +* (I +* (((intloc 0) .--> 1) +* Start-At insloc 0)) &
  s +* (I +* (((intloc 0) .--> 1) +* Start-At insloc 0)) = s +* I &
  s +* (I +* (((intloc 0) .--> 1) +* Start-At insloc 0)) +* Directed I =
  s +* Directed I
proof
  assume
A1: iS c= s;
  set sISA0 = s +* (I +* iS);
  I +* iS c= sISA0 by FUNCT_4:26;
  hence Initialized I c= sISA0 by FUNCT_4:15;
  thus sISA0 = s +*I +* iS by FUNCT_4:15
    .= s +* iS +*I by Th19
    .= s +* I by A1,FUNCT_4:79;
A2: dom Directed I = dom I by FUNCT_4:105;
  thus sISA0 +* Directed I = s +*I +* iS +* Directed I by FUNCT_4:15
    .= s +* iS +*I +* Directed I by Th19
    .= s +*I +* Directed I by A1,FUNCT_4:79
    .= s +*(I +* Directed I) by FUNCT_4:15
    .= s +*Directed I by A2,FUNCT_4:20;
end;

theorem Th21:  ::TM032=Lemma01
  for I being InitClosed Program of SCM+FSA
  st s +*I is halting & Directed I c= s &
  ((intloc 0) .--> 1) +* Start-At insloc 0 c= s holds
  IC  Computation( s,LifeSpan (s +*I) + 1) = insloc card I
proof
  let I be InitClosed Program of SCM+FSA;
  assume that
A1: s +*I is halting and
A2: Directed I c= s and
A3: iS c= s;
  set sISA0 = s +* (I +* iS);
A4: Initialized I c= sISA0 by A3,Th20;
A5: sISA0 = s +* I by A3,Th20;
  reconsider sISA0 as State of SCM+FSA;
  set s2 = sISA0 +* Directed I;
A6: s2 = s +*Directed I by A3,Th20
    .= s by A2,FUNCT_4:79;
  set m = LifeSpan sISA0;
  set A = NAT;
A7: now
    let k be Element of NAT;
    set s1 = sISA0 +* (I ';' I);
    assume
A8: k <= m;
    then
A9:  Computation( sISA0,k), Computation(s1,k) equal_outside A by A1,A4,A5,Th18;
    defpred X[Element of NAT] means
    $1 <= k implies  Computation( s1,$1),  Computation( s2,$1) equal_outside A;
A10:  Computation( s1,0) = s1 by AMI_1:13;
     Computation( s2,0) = s2 by AMI_1:13;
    then  Computation( s2,0),  Computation( s1,0) equal_outside A
    by A10,FUNCT_7:107,SCMFSA6A:42;
    then
A11: X[0] by FUNCT_7:28;
A12: for n being Element of NAT st X[n] holds X[n+1]
    proof
      let n be Element of NAT;
A13:  dom I c= dom (I ';' I) by SCMFSA6A:56;
A14:  Directed I c= I ';' I by SCMFSA6A:55;
      assume
A15:  n <= k implies  Computation( s1,n), Computation( s2,n) equal_outside A;
      assume
A16:  n + 1 <= k;
A17:  n <= n + 1 by NAT_1:12;
      then n <= k by A16,XXREAL_0:2;
      then n <= m by A8,XXREAL_0:2;
      then IC  Computation( sISA0,n) = IC  Computation( s1,n) by A1,A4,A5,Th18,
AMI_1:121;
      then
A18:  IC  Computation( s1,n) in dom I by A4,Def1;
A19:  IC  Computation( s1,n) = IC  Computation( s2,n) by A15,A16,A17,AMI_1:121
,XXREAL_0:2;
      then
A20:  IC  Computation( s2,n) in dom Directed I by A18,FUNCT_4:105;
      CurInstr  Computation( s1,n) = s1.IC  Computation( s1,n) by AMI_1:54;
      then CurInstr  Computation( s1,n)
      = (I ';' I).IC  Computation( s1,n) by A13,A18,FUNCT_4:14;
      then
A21:  CurInstr  Computation( s1,n)
      = (Directed I).IC  Computation( s1,n) by A14,A19,A20,GRFUNC_1:8;
A22:  CurInstr  Computation( s2,n) = s2.IC  Computation( s2,n) by AMI_1:54
        .= (Directed I).IC  Computation( s2,n) by A20,FUNCT_4:14;
A23:   Computation( s1,n + 1) = Following  Computation( s1,n) by AMI_1:14
        .= Exec(CurInstr  Computation( s1,n), Computation( s1,n));
       Computation( s2,n + 1) = Following  Computation( s2,n) by AMI_1:14
        .= Exec(CurInstr  Computation( s2,n), Computation( s2,n));
      hence  Computation( s1,n + 1),  Computation( s2,n + 1)
      equal_outside A by A15,A16,A17,A19,A21,A22,A23,SCMFSA6A:32,XXREAL_0:2;
    end;
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A11,A12);
    then Computation(s1,k), Computation(s2,k) equal_outside A;
    hence  Computation( sISA0,k), Computation(s2,k) equal_outside A
    by A9,FUNCT_7:29;
  end;
  set l1 = IC  Computation( sISA0,m);
A24: l1 in dom I by A4,Def1;
  then IC Computation(s2,m) in dom I by A7,AMI_1:121;
  then
A25: IC Computation(s2,m) in dom Directed I by FUNCT_4:105;
A26: l1 = IC Computation(s2,m) by A7,AMI_1:121;
  set IAt = I +* Start-At insloc 0;
  IAt c= Initialized I by Th6;
  then
A27: IAt c= sISA0 by A4,XBOOLE_1:1;
  dom I misses dom Start-At insloc 0 by SF_MASTR:64;
  then I c= I +* Start-At insloc 0 by FUNCT_4:33;
  then dom I c= dom IAt by GRFUNC_1:8;
  then sISA0.l1 = (IAt).l1 by A24,A27,GRFUNC_1:8;
  then
A28: I.l1 = sISA0.l1 by A24,SCMFSA6B:7
    .= CurInstr  Computation( sISA0,m) by AMI_1:54
    .= halt SCM+FSA by A1,A5,AMI_1:def 46;
A31: s2.l1 = (Directed I).l1 by A25,A26,FUNCT_4:14
    .= goto insloc card I by A24,A28,FUNCT_4:112;
   Computation( s2,m + 1) = Following Computation(s2,m) by AMI_1:14
    .= Exec(goto insloc card I,Computation(s2,m)) by A26,A31,AMI_1:54;
  then IC  Computation( s2,m + 1) = insloc card I by SCMFSA_2:95;
  hence IC  Computation( s,LifeSpan (s+*I) + 1) = insloc card I
  by A3,A6,Th20;
end;

theorem Th22: ::TM034=Lemma02
  for I being InitClosed Program of SCM+FSA
  st s +*I is halting & Directed I c= s &
  ((intloc 0) .--> 1) +* Start-At insloc 0 c= s holds
   DataPart Computation( s,LifeSpan (s +*I)) =
   DataPart Computation( s,LifeSpan (s +*I) + 1)
proof
  let I be InitClosed Program of SCM+FSA;
  assume that
A1: s +*I is halting and
A2: Directed I c= s and
A3: iS c= s;
  set sISA0 = s +* (I +* iS);
A4: Initialized I c= sISA0 by A3,Th20;
A5: sISA0 = s +* I by A3,Th20;
  reconsider sISA0 as State of SCM+FSA;
  set s2 = sISA0 +* Directed I;
A6: s2 = s +*Directed I by A3,Th20
    .= s by A2,FUNCT_4:79;
  set m = LifeSpan sISA0;
  set A = NAT;
A7: now
    let k be Element of NAT;
    set s1 = sISA0 +* (I ';' I);
    assume
A8: k <= m;
    then
A9:  Computation( sISA0,k), Computation(s1,k) equal_outside A by A1,A4,A5,Th18;
A10:  Computation( s1,0) = s1 by AMI_1:13;
    defpred X[Element of NAT] means
    $1 <= k implies  Computation( s1,$1),  Computation( s2,$1) equal_outside A;
     Computation( s2,0) = s2 by AMI_1:13;
    then  Computation( s2,0),  Computation( s1,0) equal_outside A
    by A10,FUNCT_7:107,SCMFSA6A:42;
    then
A11: X[0] by FUNCT_7:28;
A12: for n being Element of NAT st X[n] holds X[n+1]
    proof
      let n be Element of NAT;
A13:  dom I c= dom (I ';' I) by SCMFSA6A:56;
A14:  Directed I c= I ';' I by SCMFSA6A:55;
      assume
A15:  n <= k implies  Computation( s1,n), Computation( s2,n) equal_outside A;
      assume
A16:  n + 1 <= k;
A17:  n <= n + 1 by NAT_1:12;
      then n <= k by A16,XXREAL_0:2;
      then n <= m by A8,XXREAL_0:2;
      then IC  Computation( sISA0,n) = IC  Computation( s1,n) by A1,A4,A5,Th18,
AMI_1:121;
      then
A18:  IC  Computation( s1,n) in dom I by A4,Def1;
A19:  IC  Computation( s1,n) = IC  Computation( s2,n) by A15,A16,A17,AMI_1:121
,XXREAL_0:2;
      then
A20:  IC  Computation( s2,n) in dom Directed I by A18,FUNCT_4:105;
A21:  CurInstr  Computation( s1,n) = s1.IC  Computation( s1,n) by AMI_1:54
        .= (I ';' I).IC  Computation( s1,n) by A13,A18,FUNCT_4:14
        .= (Directed I).IC  Computation( s1,n) by A14,A19,A20,GRFUNC_1:8;
A22:  CurInstr  Computation( s2,n) = s2.IC  Computation( s2,n) by AMI_1:54
        .= (Directed I).IC  Computation( s2,n) by A20,FUNCT_4:14;
A23:   Computation( s1,n + 1) = Following  Computation( s1,n) by AMI_1:14
        .= Exec(CurInstr  Computation( s1,n), Computation( s1,n));
       Computation( s2,n + 1) = Following  Computation( s2,n) by AMI_1:14
        .= Exec(CurInstr  Computation( s2,n), Computation( s2,n));
      hence  Computation( s1,n + 1),  Computation( s2,n + 1)
      equal_outside A by A15,A16,A17,A19,A21,A22,A23,SCMFSA6A:32,XXREAL_0:2;
    end;
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A11,A12);
    then Computation(s1,k), Computation(s2,k) equal_outside A;
    hence  Computation( sISA0,k), Computation(s2,k) equal_outside A
    by A9,FUNCT_7:29;
  end;
  set l1 = IC  Computation( sISA0,m);
A24: l1 in dom I by A4,Def1;
  then IC Computation(s2,m) in dom I by A7,AMI_1:121;
  then
A25: IC Computation(s2,m) in dom Directed I by FUNCT_4:105;
A26: l1 = IC Computation(s2,m) by A7,AMI_1:121;
  set IAt = I +* Start-At insloc 0;
  IAt c= Initialized I by Th6;
  then
A27: IAt c= sISA0 by A4,XBOOLE_1:1;
  dom I misses dom Start-At insloc 0 by SF_MASTR:64;
  then I c= I +* Start-At insloc 0 by FUNCT_4:33;
  then dom I c= dom IAt by GRFUNC_1:8;
  then sISA0.l1 = (IAt).l1 by A24,A27,GRFUNC_1:8;
  then
A28: I.l1 = sISA0.l1 by A24,SCMFSA6B:7
    .= CurInstr  Computation( sISA0,m) by AMI_1:54
    .= halt SCM+FSA by A1,A5,AMI_1:def 46;
A31: s2.l1 = (Directed I).l1 by A25,A26,FUNCT_4:14
    .= goto insloc card I by A24,A28,FUNCT_4:112;
   Computation( s2,m + 1) = Following Computation(s2,m) by AMI_1:14
    .= Exec(goto insloc card I,Computation(s2,m)) by A26,A31,AMI_1:54;
  then (for a being Int-Location holds
   Computation( s2,m + 1).a = Computation(s2,m).a) &
  for f being FinSeq-Location holds
   Computation( s2,m + 1).f = Computation(s2,m).f by SCMFSA_2:95;
  hence DataPart Computation( s,LifeSpan (s +*I)) =
   DataPart Computation( s,LifeSpan (s +*I) + 1)
  by A5,A6,SCMFSA6A:38;
end;

theorem Th23: ::TM036=Lemma0
  for I being InitHalting Program of SCM+FSA st Initialized I c= s holds
  for k being Element of NAT st k <= LifeSpan s holds
  CurInstr  Computation( (s +* Directed I),k) <> halt SCM+FSA
proof
  let I be InitHalting Program of SCM+FSA;
  assume
A1: Initialized I c= s;
  then
A2: s is halting by AMI_1:def 26;
  set s2 = s +* Directed I;
  set m = LifeSpan s;
  set A = NAT;
A3: now
    let k be Element of NAT;
    set s1 = s +* (I ';' I);
    assume
A4: k <= m;
    then
A5: Computation(s,k), Computation(s1,k) equal_outside A by A1,A2,Th18;
A6:  Computation( s1,0) = s1 by AMI_1:13;
    defpred X[Element of NAT] means
    $1 <= k implies  Computation( s1,$1),  Computation( s2,$1) equal_outside A;
     Computation( s2,0) = s2 by AMI_1:13;
    then  Computation( s2,0),  Computation( s1,0) equal_outside A
    by A6,FUNCT_7:107,SCMFSA6A:42;
    then
A7: X[0] by FUNCT_7:28;
A8: for n being Element of NAT st X[n] holds X[n+1]
    proof
      let n be Element of NAT;
A9:   dom I c= dom (I ';' I) by SCMFSA6A:56;
A10:  Directed I c= I ';' I by SCMFSA6A:55;
      assume
A11:  n <= k implies  Computation( s1,n), Computation( s2,n) equal_outside A;
      assume
A12:  n + 1 <= k;
A13:  n <= n + 1 by NAT_1:12;
      then n <= k by A12,XXREAL_0:2;
      then n <= m by A4,XXREAL_0:2;

then IC Computation(s,n) = IC  Computation( s1,n) by A1,A2,Th18,AMI_1:121;
      then
A14:  IC  Computation( s1,n) in dom I by A1,Def1;
A15:  IC  Computation( s1,n) = IC  Computation( s2,n) by A11,A12,A13,AMI_1:121
,XXREAL_0:2;
      then
A16:  IC  Computation( s2,n) in dom Directed I by A14,FUNCT_4:105;
A17:  CurInstr  Computation( s1,n) = s1.IC  Computation( s1,n) by AMI_1:54
        .= (I ';' I).IC  Computation( s1,n) by A9,A14,FUNCT_4:14
        .= (Directed I).IC  Computation( s1,n) by A10,A15,A16,GRFUNC_1:8;
A18:  CurInstr  Computation( s2,n) = s2.IC  Computation( s2,n) by AMI_1:54
        .= (Directed I).IC  Computation( s2,n) by A16,FUNCT_4:14;
A19:   Computation( s1,n + 1) = Following  Computation( s1,n) by AMI_1:14
        .= Exec(CurInstr  Computation( s1,n), Computation( s1,n));
       Computation( s2,n + 1) = Following  Computation( s2,n) by AMI_1:14
        .= Exec(CurInstr  Computation( s2,n), Computation( s2,n));
      hence  Computation( s1,n + 1),  Computation( s2,n + 1)
      equal_outside A by A11,A12,A13,A15,A17,A18,A19,SCMFSA6A:32,XXREAL_0:2;
    end;
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A7,A8);
    then Computation(s1,k), Computation(s2,k) equal_outside A;
    hence Computation(s,k), Computation(s2,k) equal_outside A
    by A5,FUNCT_7:29;
  end;
  hereby
    let k be Element of NAT;
    assume
A20: k <= LifeSpan s;
    set lk = IC Computation(s,k);
A21: IC Computation(s,k) in dom I by A1,Def1;
A22: lk = IC Computation(s2,k) by A3,A20,AMI_1:121;
A23: dom I = dom Directed I by FUNCT_4:105;
    assume
A24: CurInstr  Computation( (s +* Directed I),k) = halt SCM+FSA;
A25: CurInstr Computation(s2,k) = s2.lk by A22,AMI_1:54
      .= (Directed I).lk by A21,A23,FUNCT_4:14;
    (Directed I).lk in rng Directed I by A21,A23,FUNCT_1:def 5;
    hence contradiction by A24,A25,SCMFSA6A:18;
  end;
end;

theorem Th24:
  for I being InitClosed Program of SCM+FSA st s +* Initialized I is halting
  for J being Program of SCM+FSA, k being Element of NAT
  st k <= LifeSpan (s +* Initialized I ) holds
   Computation( (s +* Initialized I),k),
   Computation( (s +* Initialized (I ';' J)),k) equal_outside NAT
proof
  let I be InitClosed Program of SCM+FSA;
  assume
A1: s +* Initialized I is halting;
  let J be Program of SCM+FSA;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized (I ';' J);
A2: Initialized I c= s1 by FUNCT_4:26;
A3: Initialized (I ';' J) c= s2 by FUNCT_4:26;
A4: s1 = s +* (I +* iS) by FUNCT_4:15
    .=s +* I +* iS by FUNCT_4:15
    .= s+*iS+*I by Th19;
A5: s2 = s +* ((I ';' J) +* iS) by FUNCT_4:15
    .=s +* (I ';' J) +* iS by FUNCT_4:15
    .= s+*iS+*(I ';' J) by Th19;
  defpred X[Element of NAT] means
  $1 <= LifeSpan s1 implies  Computation( s1,$1), Computation((s2),$1)
  equal_outside NAT;
A6: s+*iS+*I, s+*iS equal_outside NAT by AMI_1:120,FUNCT_7:28;
A7: s+*iS, s+*iS+*(I ';' J) equal_outside NAT by AMI_1:120;
   Computation( s1,0) = s1 &  Computation((s2),0) = s2 by AMI_1:13;
  then
A8: X[0] by A4,A5,A6,A7,FUNCT_7:29;
A9: for m st X[m] holds X[m+1]
  proof
    let m;
    assume
A10: m <= LifeSpan s1 implies Computation(s1,m), Computation((s2),m)
    equal_outside NAT;
    assume
A11: m+1 <= LifeSpan s1;
    then
A12: m < LifeSpan s1 by NAT_1:13;
    set sx = s2;
A13: Computation(s1,m+1) = Following Computation(s1,m) by AMI_1:14
      .= Exec(CurInstr Computation(s1,m),Computation(s1,m));
A14: Computation(sx,m+1) = Following Computation(sx,m) by AMI_1:14
      .= Exec(CurInstr Computation(sx,m),Computation(sx,m));
A15: IC(Computation(s1,m)) = IC(Computation(sx,m))
by A10,A11,AMI_1:121,NAT_1:13;
A16: IC Computation(s1,m) in dom I by A2,Def1;
A17: I c= Computation(s1,m) by A2,Th13,AMI_1:81;
A18: I ';' J c= Computation(sx,m) by A3,Th13,AMI_1:81;
    dom(I ';' J)

= dom Directed I \/ dom ProgramPart Relocated(J, card I) by FUNCT_4:def 1
      .= dom I \/ dom ProgramPart Relocated(J, card I) by FUNCT_4:105;
    then
A19: dom I c= dom(I ';' J) by XBOOLE_1:7;
A20: CurInstr(Computation(s1,m)) = I.IC(Computation(s1,m))
 by A16,A17,GRFUNC_1:8;
    then I.IC(Computation(s1,m)) <> halt SCM+FSA by A1,A12,AMI_1:def 46;
    then CurInstr(Computation(s1,m)) = (I ';' J).IC(Computation(s1,m))
    by A16,A20,SCMFSA6A:54
      .= CurInstr(Computation(sx,m)) by A15,A16,A18,A19,GRFUNC_1:8;
    hence  Computation( s1,m+1), Computation((s2),m+1)
    equal_outside NAT by A10,A11,A13,A14,NAT_1:13,SCMFSA6A:32;
  end;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A8, A9);
end;

theorem Th25: ::TM040=Th1:
  for I being keepInt0_1 InitHalting Program of SCM+FSA,
  J being InitHalting Program of SCM+FSA,
  s being State of SCM+FSA st Initialized (I ';' J) c= s holds
  IC  Computation( s,LifeSpan (s +* I) + 1) = insloc card I &
   DataPart Computation( s,LifeSpan (s +* I) + 1)
  = DataPart(Computation( (s +* I),LifeSpan (s +* I)) +* Initialized J)
  & ProgramPart Relocated(J,card I) c=
   Computation( s,LifeSpan (s +* I) + 1) &
   Computation( s,LifeSpan (s +* I) + 1).intloc 0 = 1 & s is halting &
  LifeSpan s
  = LifeSpan (s +* I) + 1 + LifeSpan (Result (s +* I) +* Initialized J) &
  (J is keeping_0 implies (Result s).intloc 0 = 1)
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s1 = s +* I;
  set s3 =  Computation( s1,LifeSpan s1) +* Initialized J;
  set m1 = LifeSpan s1;
  set m3 = LifeSpan s3;
  set D = Int-Locations \/ FinSeq-Locations;
  assume
A1: Initialized (I ';' J) c= s;
  then
A2: Initialized I c= s +* I by SCMFSA6A:52;
A3: (I ';' J) +* iS c= s by A1,FUNCT_4:15;
A4: s = s +* Initialized (I ';' J) by A1,FUNCT_4:79;
  iS c= (I ';' J) +* iS by FUNCT_4:26;
  then
A5: iS c= s by A3,XBOOLE_1:1;
  then
A6: s +* I = s +*iS +* I by FUNCT_4:79
    .= s +*I+*iS by Th19
    .= s +*(I+*iS) by FUNCT_4:15
    .= s +* Initialized I by FUNCT_4:15;
A7: s +* I is halting by A2,Th5;
A8: DataPart s3 =  DataPart Computation(s1,m1) +* DataPart(Initialized J)
          by FUNCT_4:75;
A9: now
    let x be set;
    assume x in dom DataPart Initialized J;
    then
A10: x in dom (Initialized J) /\ D by FUNCT_1:68,SCMFSA_2:127;
    then
A11: x in dom Initialized J & x in D by XBOOLE_0:def 4;
    per cases by A11,SCMFSA6A:44;
    suppose
A12:  x in dom J;
      dom J c= NAT by AMI_1:def 40;
      then reconsider l=x as Instruction-Location of SCM+FSA
      by A12,AMI_1:def 4;
      (DataPart Initialized J).l =  (DataPart Computation(s1,m1)).l
      by A11,SCMFSA6A:37;
      hence (DataPart Initialized J).x =  (DataPart Computation(s1,m1)).x;
    end;
    suppose
A13:  x = intloc 0;
      thus (DataPart Initialized J).x = (Initialized J).x
       by A11,FUNCT_1:72,SCMFSA_2:127
        .= 1 by A13,SCMFSA6A:46
        .=  Computation(s1,m1).x by A2,A13,Def3
        .=  (DataPart Computation(s1,m1)).x by A11,FUNCT_1:72,SCMFSA_2:127;
    end;
    suppose x = IC SCM+FSA;
      hence (DataPart Initialized J).x =  (DataPart Computation(s1,m1)).x
       by A10,SCMFSA6A:37,XBOOLE_0:def 4;
    end;
  end;
  Initialized J c= s3 by FUNCT_4:26;
  then dom Initialized J c= dom s3 by GRFUNC_1:8;
  then
A14: dom Initialized J c= the carrier of SCM+FSA by AMI_1:79;
  dom (DataPart Initialized J) = dom Initialized J /\ D
   by RELAT_1:90,SCMFSA_2:127;
  then dom (DataPart Initialized J) c= (the carrier of SCM+FSA) /\ D
  by A14,XBOOLE_1:26;
  then dom (DataPart Initialized J) c= dom  Computation(s1,m1) /\ D
  by AMI_1:79;
  then dom (DataPart Initialized J) c= dom DataPart Computation(s1,m1)
  by RELAT_1:90,SCMFSA_2:127;
  then DataPart Initialized J c= DataPart Computation(s1,m1) by A9,GRFUNC_1:8;
  then DataPart Computation(s1,m1) = DataPart s3 by A8,LATTICE2:8;
  then
A15: DataPart Computation(s,m1) = DataPart s3 by A4,A6,A7,Th24,SCMFSA6A:39;
A16: s3 is halting by Th5,FUNCT_4:26;
A17: dom Directed I = dom I by FUNCT_4:105;
A18: Directed I c= I ';' J by SCMFSA6A:55;
A19: I ';' J c= Initialized (I ';' J) by SCMFSA6A:26;
A20: s1 +* Directed I = s +* (I +* Directed I) by FUNCT_4:15
    .= s +* Directed I by A17,FUNCT_4:20
    .= s +* Initialized (I ';' J) +* Directed I by A1,LATTICE2:8
    .= s +* (Initialized (I ';' J) +* Directed I) by FUNCT_4:15
    .= s +* Initialized (I ';' J) by A18,A19,LATTICE2:8,XBOOLE_1:1
    .= s by A1,LATTICE2:8;
  then
A21: Directed I c= s by FUNCT_4:26; thus
A22: IC  Computation( s,LifeSpan (s +* I) + 1) = insloc card I
  by A5,A7,A20,Th21,FUNCT_4:26; thus
A23: DataPart Computation( s,m1 + 1) = DataPart s3 by A2,A5,A15,A21,Th5,Th22;
  reconsider m = m1 + 1 + m3 as Element of NAT;
  set s4 =  Computation( s,m1 + 1);
A24: Initialized J c= s3 by FUNCT_4:26;
  I ';' J c= Initialized (I ';' J) by SCMFSA6A:26;
  then
A25: I ';' J c= s by A1,XBOOLE_1:1;
  ProgramPart Relocated(J,card I) c= I ';' J by FUNCT_4:26;
  then ProgramPart Relocated(J,card I) c= s by A25,XBOOLE_1:1;
  then
A26: [ProgramPart Relocated(J,card I)] c= s4 by AMI_1:81;
  hence
     ProgramPart Relocated(J,card I) c= s4;
A27: intloc 0 in dom Initialized J by SCMFSA6A:45;
  intloc 0 in Int-Locations by SCMFSA_2:9;
  then
A28: intloc 0 in D by XBOOLE_0:def 3;
  hence s4.intloc 0 = (DataPart s3).intloc 0 by A23,FUNCT_1:72,SCMFSA_2:127
    .= s3.intloc 0 by A28,FUNCT_1:72,SCMFSA_2:127
    .= (Initialized J).intloc 0 by A27,FUNCT_4:14
    .= 1 by SCMFSA6A:46;
A29: now
    let k be Element of NAT;
    assume m1 + 1 + k < m;
    then
A30: k < m3 by XREAL_1:8;
    assume
A31: CurInstr  Computation( s,m1 + 1 + k) = halt SCM+FSA;
    IncAddr(CurInstr  Computation( s3,k),card I)
    = CurInstr  Computation( s4,k) by A22,A23,A24,A26,Th12
      .= halt SCM+FSA by A31,AMI_1:51;
    then InsCode CurInstr  Computation( s3,k) = 0 by SCMFSA_2:124,SCMFSA_4:22;
    then CurInstr  Computation( s3,k) = halt SCM+FSA by SCMFSA_2:122;
    hence contradiction by A16,A30,AMI_1:def 46;
  end;
  IncAddr(CurInstr  Computation( s3,m3),card I)
  = CurInstr  Computation( s4,m3) by A22,A23,A24,A26,Th12;
  then IncAddr(CurInstr  Computation( s3,m3),card I)
  = CurInstr  Computation( s,m1 + 1 + m3) by AMI_1:51;
  then
A32: CurInstr Computation(s,m)
  = IncAddr (halt SCM+FSA,card I) by A16,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  now
    let k be Element of NAT;
    assume
A33: k < m;
    per cases;
    suppose k <= m1;
      hence CurInstr Computation(s,k) <> halt SCM+FSA by A2,A20,Th23;
    end;
    suppose m1 < k;
      then m1 + 1 <= k by NAT_1:13;
      then consider kk being Nat such that
A34:  m1 + 1 + kk = k by NAT_1:10;
      reconsider kk as Element of NAT by ORDINAL1:def 13;
      m1+1+kk=k by A34;
      hence CurInstr Computation(s,k) <> halt SCM+FSA by A29,A33;
    end;
  end;
  then
A35: for k being Element of NAT st CurInstr Computation(s,k) = halt SCM+FSA
  holds m <= k; thus
A36: s is halting by A32,AMI_1:def 20;
  then
A37: LifeSpan s = m by A32,A35,AMI_1:def 46;
  s1 = s +* Initialized I by A1,SCMFSA6A:51;
  then Initialized I c= s1 by FUNCT_4:26;
  hence LifeSpan s
  = LifeSpan (s +* I) + 1 + LifeSpan (Result (s +* I) +* Initialized J) by A37
,Th5,AMI_1:122;
A38: Initialized J c= s3 by FUNCT_4:26;
A39: J +* Start-At insloc 0 c= s3 by FUNCT_4:26,SCMFSA6B:8;
  hereby
    assume
A40: J is keeping_0;
A41: DataPart Computation( s3,m3) = DataPart Computation( s4,m3) by A22,A23,A24
,A26,Th12;
    thus (Result s).intloc 0 = Computation(s,m).intloc 0 by A36,A37,AMI_1:122
      .=  Computation( s4,m3).intloc 0 by AMI_1:51
      .=  Computation( s3,m3).intloc 0 by A41,SCMFSA6A:38
      .= s3.intloc 0 by A39,A40,SCMFSA6B:def 4
      .= (Initialized J).intloc 0 by A27,A38,GRFUNC_1:8
      .= 1 by SCMFSA6A:46;
  end;
end;

registration
  let I be keepInt0_1 InitHalting Program of SCM+FSA,
  J be InitHalting Program of SCM+FSA;
  cluster I ';' J -> InitHalting;
  coherence
  proof
    let s be State of SCM+FSA;
    assume
A1: Initialized (I ';' J) c= s;
A2: Initialized (I ';' J) = (I ';' J) +* iS by FUNCT_4:15;
A3: s = s +* Initialized (I ';' J) by A1,FUNCT_4:79;
A4: dom I misses dom iS by Th2;
    iS c= (I ';' J) +* iS by FUNCT_4:26;
    then
A5: iS c= s by A1,A2,XBOOLE_1:1;
    then s +*iS = s by FUNCT_4:79;
    then
A6: s +* I = s +*(iS +* I) by FUNCT_4:15
      .=s +*(I +* iS) by A4,FUNCT_4:36
      .=s +* Initialized I by FUNCT_4:15;
    then
A7: Initialized I c= s +* I by FUNCT_4:26;
A8: s +* I is halting by A6,Th5,FUNCT_4:26;
    set JAt = Initialized J;
    set s1 = s +* I;
    set s3 =  Computation( s1,LifeSpan s1) +* JAt;
    set m1 = LifeSpan s1;
    set m3 = LifeSpan s3;
    set D = Int-Locations \/ FinSeq-Locations;
A9: DataPart s3 = DataPart Computation(s1,m1) +* DataPart JAt by FUNCT_4:75;
A10: now
      let x be set;
      assume x in dom DataPart JAt;
      then
A11:  x in dom (JAt) /\ D by FUNCT_1:68,SCMFSA_2:127;
      then
A12:  x in dom JAt & x in D by XBOOLE_0:def 4;
      per cases by A12,SCMFSA6A:44;
      suppose
A13:    x in dom J;
        dom J c= NAT by AMI_1:def 40;
        then reconsider l=x as Instruction-Location of SCM+FSA
        by A13,AMI_1:def 4;
        (DataPart JAt).l =  (DataPart Computation(s1,m1)).l by A12,SCMFSA6A:37;
        hence (DataPart JAt).x =  (DataPart Computation(s1,m1)).x;
      end;
      suppose
A14:    x=intloc 0;
        then x in Int-Locations by SCMFSA_2:9;
        then
A15:    x in D by XBOOLE_0:def 3;
        hence (DataPart Computation(s1,m1)).x=Computation(s1,m1).x
                by FUNCT_1:72,SCMFSA_2:127
          .=1 by A7,A14,Def3
          .=JAt.x by A14,SCMFSA6A:46
          .=(DataPart JAt).x by A15,FUNCT_1:72,SCMFSA_2:127;
      end;
      suppose x = IC SCM+FSA;
        hence (DataPart JAt).x =  (DataPart Computation(s1,m1)).x
         by A11,SCMFSA6A:37,XBOOLE_0:def 4;
      end;
    end;
A16: JAt c= s3 by FUNCT_4:26;
    then dom JAt c= dom s3 by GRFUNC_1:8;
    then
A17: dom JAt c= the carrier of SCM+FSA by AMI_1:79;
    dom DataPart JAt = dom JAt /\ D by RELAT_1:90,SCMFSA_2:127;
    then dom DataPart JAt c= (the carrier of SCM+FSA) /\ D by A17,XBOOLE_1:26;
    then dom DataPart JAt c= dom  Computation(s1,m1) /\ D by AMI_1:79;
    then dom DataPart JAt c= dom (DataPart Computation(s1,m1))
     by RELAT_1:90,SCMFSA_2:127;
    then DataPart JAt c= DataPart Computation(s1,m1) by A10,GRFUNC_1:8;
    then DataPart Computation(s1,m1) = DataPart s3 by A9,LATTICE2:8;
    then
A18: DataPart Computation(s,m1) = DataPart s3 by A3,A6,A8,Th24,SCMFSA6A:39;
A19: s3 is halting by A16,AMI_1:def 26;
A20: dom Directed I = dom I by FUNCT_4:105;
A21: Directed I c= I ';' J by SCMFSA6A:55;
    dom (I ';' J) misses dom iS by Th2;
    then
A22: I ';' J c= Initialized (I ';' J) by A2,FUNCT_4:33;
A23: s1 +* Directed I = s +* (I +* Directed I) by FUNCT_4:15
      .= s +* Directed I by A20,FUNCT_4:20
      .= s +* Initialized (I ';' J) +* Directed I by A1,LATTICE2:8
      .= s +* (Initialized (I ';' J) +* Directed I) by FUNCT_4:15
      .= s +* Initialized (I ';' J) by A21,A22,LATTICE2:8,XBOOLE_1:1
      .= s by A1,LATTICE2:8;
    then
A24: Directed I c= s by FUNCT_4:26;
A25: IC  Computation( s,LifeSpan (s +* I) + 1) = insloc card I
    by A5,A8,A23,Th21,FUNCT_4:26;
A26: DataPart Computation( s,m1 + 1) = DataPart s3 by A5,A7,A18,A24,Th5,Th22;
    reconsider m = m1 + 1 + m3 as Element of NAT;
    set s4 =  Computation( s,m1 + 1);
A27: JAt c= s3 by FUNCT_4:26;
A28: I ';' J c= s by A1,A22,XBOOLE_1:1;
    ProgramPart Relocated(J,card I) c= I ';' J by FUNCT_4:26;
    then ProgramPart Relocated(J,card I) c= s by A28,XBOOLE_1:1;
    then
A29: [ProgramPart Relocated(J,card I)] c= s4 by AMI_1:81;
    take m;
    IncAddr(CurInstr  Computation( s3,m3),card I)
    = CurInstr  Computation( s4,m3) by A25,A26,A27,A29,Th12;
    then IncAddr(CurInstr  Computation( s3,m3),card I)
    = CurInstr  Computation( s,m1 + 1 + m3) by AMI_1:51;
    hence CurInstr Computation(s,m)
    = IncAddr (halt SCM+FSA,card I) by A19,AMI_1:def 46
      .= halt SCM+FSA by SCMFSA_4:8;
  end;
end;

theorem Th26: ::TM042=Keep3
  for I being keepInt0_1 Program of SCM+FSA st s +* I is halting
  for J being InitClosed Program of SCM+FSA st Initialized (I ';' J) c= s
  for k being Element of NAT holds
   Computation( (Result(s +*I) +* Initialized J ),k) +* Start-At (IC
   Computation( (Result(s +*I) +* Initialized J ),k) + card I),
   Computation( (s +* (I ';' J)),LifeSpan (s +* I)+1+k) equal_outside NAT
proof
  let I be keepInt0_1 Program of SCM+FSA;
  assume
A1: s +* I is halting;
  let J be InitClosed Program of SCM+FSA;
  assume
A2: Initialized (I ';' J) c= s;
  set SA0 = Start-At insloc 0;
  set ISA0 = Initialized I;
  set sISA0 = s +* ISA0;
  set RI = Result(s +* ISA0);
  set JSA0 = Initialized J;
  set RIJ = RI +* JSA0;
  set sIJSA0 = s +* Initialized (I ';' J);
A3: s = sIJSA0 by A2,FUNCT_4:79;
A5: Directed I c= I ';' J by SCMFSA6A:55;
A6: sIJSA0 = s +* ((I ';' J) +* iS) by FUNCT_4:15
    .= s +*(I ';' J) +* iS by FUNCT_4:15;
  then
A7: sIJSA0 = s +*iS +*(I ';' J) by Th19;
  then
A8: (I ';' J) c= s by A3,FUNCT_4:26;
  then
A9: Directed I c= s by A5,XBOOLE_1:1;
A10: iS c= s by A3,A6,FUNCT_4:26;
A11: sISA0 = s +*(I +*iS) by FUNCT_4:15
    .= s +* I +*iS by FUNCT_4:15
    .= s +* iS +*I by Th19
    .= s +* I by A10,FUNCT_4:79;
A12: ISA0 c= sISA0 by FUNCT_4:26;
A13: sIJSA0 = s +* (I ';' J) by A7,A10,FUNCT_4:79;
A14: now
    set s1 = RIJ +* Start-At (IC RIJ + card I);
    set s2 =  Computation( sIJSA0,LifeSpan sISA0+1+0);
    thus IC s1 = IC RIJ + card I by AMI_1:111
      .= IC (RI +* (J +*(intloc 0 .--> 1)) +* SA0) + card I by FUNCT_4:15
      .= insloc 0 + card I by AMI_1:111
      .= IC s2 by A1,A3,A6,A9,A11,Th21,FUNCT_4:26;
A15: DataPart Computation(s,LifeSpan sISA0) =
     DataPart Computation( s,LifeSpan sISA0+1)
    by A1,A3,A6,A9,A11,Th22,FUNCT_4:26;
    hereby
      let a be Int-Location;
      not a in dom Start-At (IC RIJ + card I) by SCMFSA6B:9;
      then
A16:  s1.a = RIJ.a by FUNCT_4:12;
A17:   Computation( sISA0,LifeSpan sISA0).a
      =  Computation( sIJSA0,LifeSpan sISA0).a by A1,A11,Th24,SCMFSA6A:30
        .= s2.a by A3,A15,SCMFSA6A:38;
      per cases;
      suppose a <> intloc 0;
        then not a in dom JSA0 by SCMFSA6A:48;
        hence s1.a = RI.a by A16,FUNCT_4:12
          .= s2.a by A1,A11,A17,AMI_1:122;
      end;
      suppose
A18:    a = intloc 0;
        then a in dom JSA0 by SCMFSA6A:45;
        hence s1.a = JSA0.a by A16,FUNCT_4:14
          .=1 by A18,SCMFSA6A:46
          .=s2.a by A12,A17,A18,Def3;
      end;
    end;
    let f be FinSeq-Location;
A19: not f in dom JSA0 by SCMFSA6A:49;
    not f in dom Start-At (IC RIJ + card I) by SCMFSA6B:10;
    hence s1.f = RIJ.f by FUNCT_4:12
      .= RI.f by A19,FUNCT_4:12
      .=  Computation( sISA0,LifeSpan sISA0).f by A1,A11,AMI_1:122
      .=  Computation( sIJSA0,LifeSpan sISA0).f by A1,A11,Th24,SCMFSA6A:31
      .= s2.f by A3,A15,SCMFSA6A:38;
  end;
  defpred X[Element of NAT] means
   Computation( RIJ,$1) +* Start-At (IC  Computation( RIJ,$1) + card I),
   Computation( sIJSA0,LifeSpan sISA0+1+$1) equal_outside NAT;
   Computation( RIJ,0) = RIJ by AMI_1:13;
  then
A20: X[0] by A14,SCMFSA6A:28;
A21: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT;
    assume
A22:  Computation( RIJ,k) +* Start-At (IC  Computation( RIJ,k) + card I),
     Computation( sIJSA0,LifeSpan sISA0+1+k) equal_outside NAT;
    set k1 = k+1;
    set CRk =  Computation( RIJ,k);
    set CRSk = CRk +* Start-At (IC CRk + card I);
    set CIJk =  Computation( sIJSA0,LifeSpan sISA0+1+k);
    set CRk1 =  Computation( RIJ,k1);
    set CRSk1 = CRk1 +* Start-At (IC CRk1 + card I);
    set CIJk1 =  Computation( sIJSA0,LifeSpan sISA0+1+k1);
A23: IncAddr(CurInstr CRk, card I) = CurInstr CIJk
    proof
A24:  now thus CurInstr CIJk = CIJk.IC CRSk by A22,AMI_1:121
          .= CIJk.(IC CRk + card I) by AMI_1:111;
      end;
      reconsider ii = IC CRk as Element of NAT by ORDINAL1:def 13;
      JSA0 c= RIJ by FUNCT_4:26;
      then
A25:  IC CRk in dom J by Def1;
      then
A26:  ii in dom IncAddr(J, card I) by SCMFSA_4:def 6;
      then
A27:  Shift(IncAddr(J, card I), card I).(IC CRk + card I)
      = IncAddr(J, card I).ii by VALUED_1:def 12
        .= IncAddr(pi(J, ii), card I) by A25,SCMFSA_4:24;
      ProgramPart Relocated(J, card I) c= I ';' J by FUNCT_4:26;
      then
A28:  ProgramPart Relocated(J, card I) c= sIJSA0 by A3,A8,XBOOLE_1:1;
A29:  now thus ProgramPart Relocated(J, card I)
        = IncAddr([Shift(ProgramPart(J), card I)], card I) by SCMFSA_5:2
          .= IncAddr(Shift(J, card I), card I) by AMI_1:105
          .= Shift(IncAddr(J, card I), card I) by SCMFSA_4:35;
      end;
      dom Shift(IncAddr(J, card I), card I) =
      { il+card I where il is Element of NAT:
      il in dom IncAddr(J, card I)} by VALUED_1:def 12;
      then
A30:  IC CRk + card I in dom Shift(IncAddr(J, card I), card I) by A26;
A31:  now RIJ = RI +*( J +* iS) by FUNCT_4:15
          .= RI +* J +* iS by FUNCT_4:15
          .= RI +* iS +* J by Th19;
        hence J c= CRk by AMI_1:81,FUNCT_4:26;
      end;
      pi(J, ii) = J.IC CRk by A25,AMI_1:def 47
        .= CRk.IC CRk by A25,A31,GRFUNC_1:8;
      hence IncAddr(CurInstr CRk, card I)
      = sIJSA0.(IC CRk + card I) by A27,A28,A29,A30,GRFUNC_1:8
        .= CurInstr CIJk by A24,AMI_1:54;
    end;
A32: now CIJk1 = Computation( sIJSA0,LifeSpan sISA0+1+k+1);
      then CIJk1 = Following CIJk by AMI_1:14;
      hence CIJk1 = Exec(CurInstr CIJk, CIJk);
    end;
    CIJk, CRSk equal_outside NAT by A22,FUNCT_7:28;
    then Exec(CurInstr CIJk, CIJk), Exec(IncAddr(CurInstr CRk,card I), CRSk)
    equal_outside NAT by A23,SCMFSA6A:32;
    then
A33: Exec(CurInstr CIJk, CIJk),
    Following(CRk) +* Start-At (IC Following(CRk) + card I)
    equal_outside NAT by SCMFSA_4:28;
A34: now
      IC CRSk1 = IC CRk1 + card I by AMI_1:111
        .= IC Following CRk + card I by AMI_1:14;
      hence IC CRSk1 =
      IC (Following(CRk) +* Start-At (IC Following(CRk) + card I))
      by AMI_1:111
        .= IC CIJk1 by A32,A33,AMI_1:121;
    end;
A35: now
      let a be Int-Location;
      thus CRSk1.a = CRk1.a by SCMFSA_3:11
        .= (Following CRk).a by AMI_1:14
        .= (Following(CRk) +* Start-At (IC Following(CRk) + card I)).a
      by SCMFSA_3:11
        .= CIJk1.a by A32,A33,SCMFSA6A:30;
    end;
    now
      let f be FinSeq-Location;
      thus CRSk1.f = CRk1.f by SCMFSA_3:12
        .= (Following CRk).f by AMI_1:14
        .= (Following(CRk) +* Start-At (IC Following(CRk) + card I)).f
      by SCMFSA_3:12
        .= CIJk1.f by A32,A33,SCMFSA6A:31;
    end;
    hence  Computation(RIJ,k1) +* Start-At (IC  Computation( RIJ,k1) + card I),
     Computation( sIJSA0,LifeSpan sISA0+1+k1)
    equal_outside NAT by A34,A35,SCMFSA6A:28;
  end;
  for k being Element of NAT holds X[k] from NAT_1:sch 1(A20, A21);
  hence for k being Element of NAT
  holds  Computation( (Result(s +*I) +* Initialized J),k) +* Start-At (IC
   Computation( (Result(s +*I) +* Initialized J),k) + card I),
   Computation( (s +* (I ';' J)),LifeSpan (s +* I)+1+k)
  equal_outside NAT by A11,A13;
end;

theorem Th27:   ::Keep1
  for I being keepInt0_1 Program of SCM+FSA
  st not s +* Initialized I is halting
  for J being Program of SCM+FSA, k being Element of NAT
  holds  Computation( (s +* Initialized I),k),
   Computation( (s +* Initialized (I ';' J)),k) equal_outside NAT
proof
  let I be keepInt0_1 Program of SCM+FSA;
  assume
A1: not s +* Initialized I is halting;
  let J be Program of SCM+FSA;
  set s1 = s +* Initialized I;
A2: Initialized I c= s1 by FUNCT_4:26;
  set s2 = s +* Initialized (I ';' J);
A3: Initialized (I ';' J) c= s2 by FUNCT_4:26;
A4: s1 = s +* (I +* iS) by FUNCT_4:15
    .= s +* I +* iS by FUNCT_4:15
    .= s+*iS+*I by Th19;
A5: s2 = s +* ((I ';' J) +* iS) by FUNCT_4:15
    .= s +* (I ';' J) +* iS by FUNCT_4:15
    .= s+* iS +*(I ';' J) by Th19;
A6: s+*iS+*I, s+*iS equal_outside NAT by AMI_1:120,FUNCT_7:28;
  defpred X[Element of NAT] means  Computation( s1,$1), Computation((s2),$1)
  equal_outside NAT;
A7: s+*iS, s+*iS+*(I ';' J) equal_outside NAT by AMI_1:120;
   Computation( s1,0) = s1 &  Computation((s2),0) = s2 by AMI_1:13;
  then
A8: X[0] by A4,A5,A6,A7,FUNCT_7:29;
A9: for m st X[m] holds X[m+1]
  proof
    let m;
    assume
A10: Computation(s1,m), Computation((s2),m) equal_outside NAT;
    set sx = s2;
::    set CsIJ = Computation s2;
A11: Computation(s1,m+1) = Following Computation(s1,m) by AMI_1:14
      .= Exec(CurInstr Computation(s1,m),Computation(s1,m));
A12: Computation(sx,m+1) = Following Computation(sx,m) by AMI_1:14
      .= Exec(CurInstr Computation(sx,m),Computation(sx,m));
A13: IC(Computation(s1,m)) = IC(Computation(sx,m)) by A10,AMI_1:121;
A14: IC Computation(s1,m) in dom I by A2,Def1;
A15: I c= Computation(s1,m) by A2,Th13,AMI_1:81;
A16: I ';' J c= Computation(sx,m) by A3,Th13,AMI_1:81;
    dom(I ';' J)

= dom Directed I \/ dom ProgramPart Relocated(J, card I) by FUNCT_4:def 1
      .= dom I \/ dom ProgramPart Relocated(J, card I) by FUNCT_4:105;
    then
A17: dom I c= dom(I ';' J) by XBOOLE_1:7;
A18: CurInstr(Computation(s1,m)) = I.IC(Computation(s1,m))
             by A14,A15,GRFUNC_1:8;
    then I.IC(Computation(s1,m)) <> halt SCM+FSA by A1,AMI_1:def 20;
    then CurInstr(Computation(s1,m)) = (I ';' J).IC(Computation(s1,m))
    by A14,A18,SCMFSA6A:54
      .= CurInstr(Computation(sx,m)) by A13,A14,A16,A17,GRFUNC_1:8;
    hence  Computation( s1,m+1), Computation((s2),m+1)
    equal_outside NAT by A10,A11,A12,SCMFSA6A:32;
  end;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A8, A9);
end;

theorem Th28: ::TM044=T22
  for I being keepInt0_1 InitHalting Program of SCM+FSA,
  J being InitHalting Program of SCM+FSA holds
  LifeSpan (s +* Initialized (I ';' J)) = LifeSpan (s +* Initialized I) + 1
  + LifeSpan (Result (s +* Initialized I) +* Initialized J)
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  set inI=Initialized I;
  set inIJ=Initialized (I ';' J);
  set inJ=Initialized J;
  inIJ c= s +* inIJ by FUNCT_4:26;
  then
A1: LifeSpan (s +* inIJ) = LifeSpan (s +* inIJ +* I) + 1
  + LifeSpan (Result (s +* inIJ +* I) +* inJ) by Th25;
A2: inI c= s +* inI by FUNCT_4:26;
A3: inI c= s +* inIJ +* I by FUNCT_4:26,SCMFSA6A:52;
A4: s +* inIJ, s +* inIJ +* I equal_outside NAT by AMI_1:120;
  s +* inI, s +* inIJ equal_outside NAT by SCMFSA6A:53;
  then s +* inI, s +* inIJ +* I equal_outside NAT by A4,FUNCT_7:29;
  then
A5: LifeSpan (s +* inI) = LifeSpan (s +* inIJ +* I) &
  Result (s +* inI), Result (s +* inIJ +* I) equal_outside NAT by A2,A3,Th15;
  then
A6: Result (s +* inIJ +* I), Result (s +* inI)
  equal_outside NAT by FUNCT_7:28;
A7: inJ c= Result (s +* inIJ +* I) +* inJ by FUNCT_4:26;
A8: inJ c= Result (s +* inI) +* inJ by FUNCT_4:26;
  Result (s +* inIJ +* I) +* inJ, Result (s +* inI) +* inJ
  equal_outside NAT by A6,FUNCT_7:106;
  hence LifeSpan (s +* inIJ)
  = LifeSpan (s +* inI) + 1 + LifeSpan (Result (s +* inI) +* inJ)
  by A1,A5,A7,A8,Th15;
end;

theorem Th29:  ::TM046
  for I being keepInt0_1 InitHalting Program of SCM+FSA,
  J being InitHalting Program of SCM+FSA holds IExec(I ';' J,s) =
  IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I)
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  set ps = s | NAT;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized (I ';' J);
  set s3 =  Computation( s1,LifeSpan s1) +* Initialized J;
  set m1 = LifeSpan s1;
  set m3 = LifeSpan s3;
  set A = NAT;
  set D = (Int-Locations \/ FinSeq-Locations);
A1: Initialized I c= s1 by FUNCT_4:26;
A2: s1 is halting by Th5,FUNCT_4:26;
A3: Initialized (I ';' J) c= s2 by FUNCT_4:26;
  s2 = s +* ((I ';' J) +* iS) by FUNCT_4:15
    .= s +* (I ';' J) +* iS by FUNCT_4:15;
  then
A4: iS c= s2 by FUNCT_4:26;
  s2 +*(I +* iS) = s2 +*I +* iS by FUNCT_4:15
    .=s2 +* iS +* I by Th19
    .=s2 +* I by A4,FUNCT_4:79;
  then I +* iS c= s2 +* I by FUNCT_4:26;
  then Initialized I c= s2 +* I by FUNCT_4:15;
  then
A5: s2 +* I is halting by Th5;
A6: Initialized J c= s3 by FUNCT_4:26;
A7: dom ps = dom s /\ A by RELAT_1:90
    .= (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} \/ A) /\
  A by AMI_1:79,SCMFSA_2:8
    .= A by XBOOLE_1:21;
A8: Computation(s1,m1) +* Initialized J,
Computation(s1,m1) +* ps +* Initialized J
  equal_outside dom ps by FUNCT_7:31,106;
  then
A9: Computation(s1,m1) +* ps +* Initialized J,
Computation(s1,m1) +* Initialized J
  equal_outside dom ps by FUNCT_7:28;
  Result (IExec(I,s) +* Initialized J), Result s3 equal_outside A
  proof
A10: Initialized J c= IExec(I,s) +* Initialized J by FUNCT_4:26;
A11: Initialized J c= s3 by FUNCT_4:26;
    IExec(I,s) = Result (s +* Initialized I) +* ps by SCMFSA6B:def 1
      .= Computation(s1,m1) +* ps by A1,Th5,AMI_1:122;
    hence thesis by A7,A9,A10,A11,Th15;
  end;
  then
A12: Result (IExec(I,s) +* Initialized J) +* ps = Result s3 +* ps
  by A7,FUNCT_7:108;
A13: s3 = Result s1 +* Initialized J by A1,Th5,AMI_1:122;
A14: IExec(I ';' J,s)
  = Result (s +* Initialized (I ';' J)) +* ps by SCMFSA6B:def 1
    .= Computation(s2,LifeSpan s2) +* ps by A3,Th5,AMI_1:122
    .= Computation(s2,m1+1+m3) +* ps by A13,Th28;
  IExec(I,s) | A = (Result (s +* Initialized I) +* ps) | A by SCMFSA6B:def 1
    .= ps by CARD_3:99;
  then
A15: IExec(J,IExec(I,s))
  = Result (IExec(I,s) +* Initialized J) +* ps by SCMFSA6B:def 1
    .= Computation(s3,m3) +* ps by A6,A12,Th5,AMI_1:122;
A16: Initialized I c= s2 +* I by FUNCT_4:26,SCMFSA6A:52;
A17: s1,s2 equal_outside A by SCMFSA6A:53;
  s2,s2 +* I equal_outside A by AMI_1:120;
  then s1,s2 +* I equal_outside A by A17,FUNCT_7:29;
  then
A18: LifeSpan (s2 +* I) = m1 by A1,A16,Th15;
  then
A19: IC Computation(s2,m1+1) = insloc card I & DataPart Computation(s2,m1+1)
  = DataPart(Computation( (s2 +* I),m1) +* Initialized J) &
  ProgramPart Relocated(J,card I) c= Computation(s2,m1+1) &
  Computation(s2,m1+1).intloc 0 = 1 by A3,Th25;
A20: DataPart Computation( Computation(s2,m1+1),m3)
        = DataPart Computation(s3,m3) &
  IC  Computation( Computation(s2,m1+1),m3) = IC Computation(s3,m3) + card I
  proof
A21: Initialized J c= s3 by FUNCT_4:26;
A22: s1 +* (I ';' J) = s +* (Initialized I +* (I ';' J)) by FUNCT_4:15
      .= s2 by SCMFSA6A:58;
   DataPart Computation( (s2 +* I),m1)
    = DataPart Computation( ((s2 +* I) +* (I ';' J)),m1) by A5,A16,A18,Th18,
SCMFSA6A:39
      .= DataPart Computation( ((s2 +* (I +* (I ';' J)))),m1) by FUNCT_4:15
      .= DataPart Computation( (s2 +* (I ';' J)),m1) by SCMFSA6A:57
      .= DataPart Computation( (s +* (Initialized (I ';' J) +* (I ';' J))),m1)
    by FUNCT_4:15
      .= DataPart Computation(s2,m1) by LATTICE2:8,SCMFSA6A:26
      .= DataPart Computation(s1,m1) by A1,A2,A22,Th18,SCMFSA6A:39;
    then DataPart(Computation( (s2 +* I),m1) +* Initialized J)
    = DataPart Computation(s1,m1) +* DataPart Initialized J by FUNCT_4:75
      .= DataPart(Computation(s1,m1) +* Initialized J) by FUNCT_4:75;
    hence thesis by A19,A21,Th12;
  end;
A23: DataPart IExec(I ';' J,s) = DataPart IExec(J,IExec(I,s))
  proof
A24: dom ps misses D by A7,SCMFSA_2:13,14,XBOOLE_1:70;
    hence DataPart IExec(I ';' J,s)
       = DataPart Computation(s2,m1+1+m3) by A14,FUNCT_4:76,SCMFSA_2:127
      .= DataPart Computation(s3,m3) by A20,AMI_1:51
      .= DataPart IExec(J,IExec(I,s)) by A15,A24,FUNCT_4:76,SCMFSA_2:127;
  end;
A25: IExec(I,s) = Result s1 +* ps by SCMFSA6B:def 1;
A26: Result s1 = Computation(s1,m1) by A1,Th5,AMI_1:122;
A27: Initialized J c= Result s1 +* Initialized J by FUNCT_4:26;
  Initialized J c= IExec(I,s) +* Initialized J by FUNCT_4:26;
  then
A28: IC Result (Result s1 +* Initialized J)
  = IC Result (IExec(I,s) +* Initialized J)
   by A7,A8,A25,A26,A27,Th15,AMI_1:121;
A29: IC IExec(I ';' J,s) = IC Result (s +* Initialized (I ';' J))
  by SCMFSA8A:7
    .= IC Computation(s2,LifeSpan s2) by A3,Th5,AMI_1:122
    .= IC Computation(s2,m1+1+m3) by A13,Th28
    .= IC Computation(s3,m3) + card I by A20,AMI_1:51
    .= IC Result s3 + card I by A6,Th5,AMI_1:122
    .= IC Result (Result s1 +* Initialized J) + card I by A1,Th5,AMI_1:122
    .= IC IExec(J,IExec(I,s)) + card I by A28,SCMFSA8A:7;
  hereby
A30: dom IExec(I ';' J,s) = the carrier of SCM+FSA by AMI_1:79

.= dom (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I))
    by AMI_1:79;
    reconsider l = IC IExec(J,IExec(I,s)) + card I
    as Instruction-Location of SCM+FSA;
A31: dom Start-At l = {IC SCM+FSA} by FUNCOP_1:19;
    now
      let x be set;
      assume
A32:  x in dom IExec(I ';' J,s);
      per cases by A32,SCMFSA6A:35;
      suppose
A33:    x is Int-Location;
        then
A34:    IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A23,SCMFSA6A:38;
        x <> IC SCM+FSA by A33,SCMFSA_2:81;
        then not x in dom Start-At l by A31,TARSKI:def 1;
        hence IExec(I ';' J,s).x
        = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I)).x
        by A34,FUNCT_4:12;
      end;
      suppose
A35:    x is FinSeq-Location;
        then
A36:    IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A23,SCMFSA6A:38;
        x <> IC SCM+FSA by A35,SCMFSA_2:82;
        then not x in dom Start-At l by A31,TARSKI:def 1;
        hence IExec(I ';' J,s).x
        = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I)).x
        by A36,FUNCT_4:12;
      end;
      suppose
A37:    x = IC SCM+FSA;
        then x in {IC SCM+FSA} by TARSKI:def 1;
        then
A38:    x in dom Start-At l by FUNCOP_1:19;
        thus IExec(I ';' J,s).x
        = (Start-At l).IC SCM+FSA by A29,A37,FUNCOP_1:87

.= (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I)).x
        by A37,A38,FUNCT_4:14;
      end;
      suppose
A39:    x is Instruction-Location of SCM+FSA;
        IExec(I ';' J,s) | A = ps by A14,CARD_3:99
          .= IExec(J,IExec(I,s)) | A by A15,CARD_3:99;
        then
A40:    IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A39,SCMFSA6A:36;
        x <> IC SCM+FSA by A39,AMI_1:48;
        then not x in dom Start-At l by A31,TARSKI:def 1;
        hence IExec(I ';' J,s).x
        = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I)).x
        by A40,FUNCT_4:12;
      end;
    end;
    hence thesis by A30,FUNCT_1:9;
  end;
end;

registration
  let i be parahalting Instruction of SCM+FSA;
  cluster Macro i -> InitHalting;
  coherence;
end;

registration
  let i be parahalting Instruction of SCM+FSA,
  J be parahalting Program of SCM+FSA;
  cluster i ';' J -> InitHalting;
  coherence;
end;

registration
  let i be keeping_0 parahalting Instruction of SCM+FSA,
  J be InitHalting Program of SCM+FSA;
  cluster i ';' J -> InitHalting;
  coherence;
end;

registration
  let I, J be keepInt0_1 Program of SCM+FSA;
  cluster I ';' J -> keepInt0_1;
  coherence
  proof
    let s be State of SCM+FSA;
    assume
A1: Initialized (I ';' J) c= s;
    then
A2: s +* Initialized (I ';' J) = s by FUNCT_4:79;
A3: Initialized(I ';' J) = (I ';' J) +* iS by FUNCT_4:15;
    iS c= (I ';' J) +* iS by FUNCT_4:26;
    then
A4: iS c= s by A1,A3,XBOOLE_1:1;
    s +*Initialized(I ';' J) = s +*(I ';' J) +* iS by A3,FUNCT_4:15
      .= s +* iS +*(I ';' J) by Th19
      .= s +* (I ';' J) by A4,FUNCT_4:79;
    then
A5: s=s +* (I ';' J) by A1,FUNCT_4:79;
A6: Initialized I c= s +* Initialized I by FUNCT_4:26;
    per cases;
    suppose
A7:   s +* Initialized I is halting;
A8:   s +* Initialized I=s +* (I +* iS) by FUNCT_4:15
        .= s +*I +* iS by FUNCT_4:15
        .= s +* iS +* I by Th19
        .= s +* I by A4,FUNCT_4:79;
      let k be Element of NAT;
      hereby
        per cases;
        suppose
A9:       k <= LifeSpan(s +* Initialized I);
           Computation( (s +* Initialized I),k).intloc 0 = 1 by A6,Def3;
          hence  Computation(s,k).intloc 0 = 1 by A2,A7,A9,Th24,SCMFSA6A:30;
        end;
        suppose
A10:      k > LifeSpan(s +* Initialized I);
          set LS = LifeSpan(s +* Initialized I);
          consider p being Element of NAT such that
A11:      k = LS + p & 1 <= p by A10,FSM_1:1;
          consider r being Nat such that
A12:      p = 1 + r by A11,NAT_1:10;
          reconsider r as Element of NAT by ORDINAL1:def 13;
          Initialized J c= Result(s +* I) +* Initialized J by FUNCT_4:26;
          then
A13:       Computation( (Result(s +*I ) +* Initialized J),r). intloc 0 = 1 by
Def3;
          set Rr =  Computation(Result(s +* I) +* Initialized J,r);
          set Sr = Start-At (IC Computation( (Result(s +* I)
          +* Initialized J ),r) + card I);

dom Sr = {IC SCM+FSA} & intloc 0 <> IC SCM+FSA by FUNCOP_1:19,SCMFSA_2:81;
          then not intloc 0 in dom Sr by TARSKI:def 1;
          then
A14:      (Rr +* Sr).intloc 0 = Rr.intloc 0 by FUNCT_4:12;
          Rr +* Sr,  Computation( (s +* (I ';' J)),LS+1+r) equal_outside NAT
          by A1,A7,A8,Th26;

hence  Computation(s,k).intloc 0 = 1 by A5,A11,A12,A13,A14,SCMFSA6A:30;
        end;
      end;
    end;
    suppose
A15:  not s +* Initialized I is halting;
      let k be Element of NAT;
      Initialized I c= s +* Initialized I by FUNCT_4:26;
      then  Computation( (s +* Initialized I),k).intloc 0 = 1 by Def3;
      hence  Computation(s,k).intloc 0 = 1 by A2,A15,Th27,SCMFSA6A:30;
    end;
  end;
end;

registration
  let j be keeping_0 parahalting Instruction of SCM+FSA,
  I be keepInt0_1 InitHalting Program of SCM+FSA;
  cluster I ';' j -> InitHalting keepInt0_1;
  coherence;
end;

registration
  let i be keeping_0 parahalting Instruction of SCM+FSA,
  J be keepInt0_1 InitHalting Program of SCM+FSA;
  cluster i ';' J -> InitHalting keepInt0_1;
  coherence;
end;

registration
  let j be parahalting Instruction of SCM+FSA,
  I be parahalting Program of SCM+FSA;
  cluster I ';' j -> InitHalting;
  coherence;
end;

registration
  let i,j be parahalting Instruction of SCM+FSA;
  cluster i ';' j -> InitHalting;
  coherence;
end;

theorem Th30:  ::TM048
  for I being keepInt0_1 InitHalting Program of SCM+FSA,
  J being InitHalting Program of SCM+FSA
  holds IExec(I ';' J, s).a = IExec(J,IExec(I,s)).a
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA,
  J be InitHalting Program of SCM+FSA;
A1: IExec(I ';' J,s) = IExec(J,IExec(I,s)) +*
  Start-At (IC IExec(J,IExec(I,s)) + card I) by Th29;
  not a in dom Start-At (IC IExec(J,IExec(I,s)) + card I) by SCMFSA6B:9;
  hence IExec(I ';' J, s).a = IExec(J,IExec(I,s)).a by A1,FUNCT_4:12;
end;

theorem Th31:  ::TM050
  for I being keepInt0_1 InitHalting Program of SCM+FSA,
  J being InitHalting Program of SCM+FSA
  holds IExec(I ';' J, s).f = IExec(J,IExec(I,s)).f
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA,
  J be InitHalting Program of SCM+FSA;
A1: IExec(I ';' J,s) = IExec(J,IExec(I,s)) +*
  Start-At (IC IExec(J,IExec(I,s)) + card I) by Th29;
  not f in dom Start-At (IC IExec(J,IExec(I,s)) + card I) by SCMFSA6B:10;
  hence IExec(I ';' J, s).f = IExec(J,IExec(I,s)).f by A1,FUNCT_4:12;
end;

theorem Th32:
  for I be keepInt0_1 InitHalting Program of SCM+FSA,
  s be State of SCM+FSA holds
  DataPart(Initialize IExec(I,s)) = DataPart IExec(I,s)
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA, s be State of SCM+FSA;
  set IE = IExec(I,s);
  set IF = Int-Locations \/ FinSeq-Locations;
  now
A1: dom (Initialize IE) = the carrier of SCM+FSA &
    dom IE = the carrier of SCM+FSA by AMI_1:79;
    hence
A2: dom DataPart Initialize IE = dom IE /\ IF by RELAT_1:90,SCMFSA_2:127;
    let x be set;
    assume
A3: x in dom DataPart Initialize IE;
    dom Initialize IE = Int-Locations \/ FinSeq-Locations \/ ({IC SCM+FSA }
    \/ NAT) by A1,SCMFSA_2:8,XBOOLE_1:4;
    then
A4: dom DataPart Initialize IE = Int-Locations \/ FinSeq-Locations
    by A1,A2,XBOOLE_1:21;
    per cases by A3,A4,XBOOLE_0:def 3;
    suppose x in Int-Locations;
      then reconsider x' = x as Int-Location by SCMFSA_2:11;
      hereby
        per cases;
        suppose
A5:       x' is read-write;
          thus (DataPart Initialize IE).x = (Initialize IE).x
           by A3,A4,FUNCT_1:72,SCMFSA_2:127
            .= IE.x by A5,SCMFSA6C:3;
        end;
        suppose x' is read-only;
          then
A6:       x' = intloc 0 by SF_MASTR:def 5;
          thus (DataPart Initialize IE).x = (Initialize IE).x'
           by A3,A4,FUNCT_1:72,SCMFSA_2:127
            .= 1 by A6,SCMFSA6C:3
            .= IE.x by A6,Th17;
        end;
      end;
    end;
    suppose x in FinSeq-Locations;
      then reconsider x' = x as FinSeq-Location by SCMFSA_2:12;
      thus (DataPart Initialize IE).x = (Initialize IE).x'
       by A3,A4,FUNCT_1:72,SCMFSA_2:127
        .= IE.x by SCMFSA6C:3;
    end;
  end;
  hence DataPart Initialize IE = DataPart IE by FUNCT_1:68,SCMFSA_2:127;
end;

theorem Th33:  ::TM051=miI:
  for I being keepInt0_1 InitHalting Program of SCM+FSA,
  j being parahalting Instruction of SCM+FSA
  holds IExec(I ';' j, s).a = Exec(j, IExec(I, s)).a
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA,
  j be parahalting Instruction of SCM+FSA;
  set Mj = Macro j;
  set SA = Start-At (IC IExec(Mj,IExec(I,s)) + card I);
A1: not a in dom SA & a in dom IExec(Mj,IExec(I,s)) by SCMFSA6B:9,SCMFSA_2:66;
A2: DataPart Initialize IExec(I,s) = DataPart IExec(I, s) by Th32;
  a in Int-Locations by SCMFSA_2:9;
  then
A3: a in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
  thus IExec(I ';' j, s).a
    = (IExec(Mj,IExec(I,s))+*SA).a by Th29
    .= IExec(Mj, IExec(I,s)).a by A1,FUNCT_4:12
    .= Exec(j, Initialize IExec(I,s)).a by SCMFSA6C:6
    .= (DataPart Exec(j, Initialize IExec(I,s))).a
  by A3,FUNCT_1:72,SCMFSA_2:127
    .= (DataPart Exec(j, IExec(I, s))).a
  by A2,SCMFSA6C:5
    .= Exec(j, IExec(I, s)).a by A3,FUNCT_1:72,SCMFSA_2:127;
end;

theorem Th34:  ::TM053=miF
  for I being keepInt0_1 InitHalting Program of SCM+FSA,
  j being parahalting Instruction of SCM+FSA
  holds IExec(I ';' j, s).f = Exec(j, IExec(I, s)).f
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA,
  j be parahalting Instruction of SCM+FSA;
  set Mj = Macro j;
  set SA = Start-At (IC IExec(Mj,IExec(I,s)) + card I);
A1: not f in dom SA & f in dom IExec(Mj,IExec(I,s)) by SCMFSA6B:10,SCMFSA_2:67;
A2: DataPart Initialize IExec(I,s) = DataPart IExec(I, s) by Th32;
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A3: f in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
  thus IExec(I ';' j, s).f
    = (IExec(Mj,IExec(I,s))+*SA).f by Th29
    .= IExec(Mj, IExec(I,s)).f by A1,FUNCT_4:12
    .= Exec(j, Initialize IExec(I,s)).f by SCMFSA6C:6
    .= (DataPart Exec(j, Initialize IExec(I,s))).f
     by A3,FUNCT_1:72,SCMFSA_2:127
    .= (DataPart Exec(j, IExec(I, s))).f by A2,SCMFSA6C:5
    .= Exec(j, IExec(I, s)).f by A3,FUNCT_1:72,SCMFSA_2:127;
end;

definition
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  pred I is_closed_onInit s means
  :Def4: ::def3=D18
  for k being Element of NAT holds
  IC  Computation( (s +* Initialized I ),k) in dom I;
  pred I is_halting_onInit s means
  :Def5: ::def4=D18'
  s +* Initialized I is halting;
end;

theorem Th35:  ::TM052=TQ6
  for I being Program of SCM+FSA holds
  I is InitClosed iff for s being State of SCM+FSA holds I is_closed_onInit s
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is InitClosed;
    let s be State of SCM+FSA;
    Initialized I c= s +* Initialized I by FUNCT_4:26;
    then for k being Element of NAT holds
    IC  Computation( (s +* Initialized I),k) in dom I by A1,Def1;
    hence I is_closed_onInit s by Def4;
  end;
  assume
A2: for s being State of SCM+FSA holds I is_closed_onInit s;
  now
    let s be State of SCM+FSA;
    let k be Element of NAT;
    assume Initialized I c= s;
    then I is_closed_onInit s & s = s +* Initialized I by A2,FUNCT_4:79;
    hence IC Computation(s,k) in dom I by Def4;
  end;
  hence I is InitClosed by Def1;
end;

theorem Th36:  ::TM054=*TQ6'
  for I being Program of SCM+FSA holds
  I is InitHalting iff for s being State of SCM+FSA holds I is_halting_onInit s
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is InitHalting;
    let s be State of SCM+FSA;
A2: Initialized I c= s +* Initialized I by FUNCT_4:26;
    Initialized I is halting by A1;
    then s +* Initialized I is halting by A2,AMI_1:def 26;
    hence I is_halting_onInit s by Def5;
  end;
  assume
A3: for s being State of SCM+FSA holds I is_halting_onInit s;
  now
    let s be State of SCM+FSA;
    assume Initialized I c= s;
    then I is_halting_onInit s & s = s +* Initialized I by A3,FUNCT_4:79;
    hence s is halting by Def5;
  end;
  then Initialized I is halting by AMI_1:def 26;
  hence I is InitHalting by Def2;
end;

theorem Th37:  ::TM055=TQ9''(SCMFSA7B)
  for s being State of SCM+FSA, I being Program of SCM+FSA,
  a being Int-Location
  st I does_not_destroy a & I is_closed_onInit s & Initialized I c= s
  holds for k being Element of NAT holds Computation(s,k).a = s.a
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA,a be Int-Location;
  assume
A1: I does_not_destroy a;
  assume
A2: I is_closed_onInit s;
  assume
A3: Initialized I c= s;
  then
A4: s +* Initialized I = s by FUNCT_4:79;
A5: I c= s by A3,Th13;
  defpred P[Element of NAT] means Computation(s,$1).a = s.a;
A6: P[0] by AMI_1:13;
A7: now
    let k be Element of NAT;
    assume
A8: P[k];
    set l = IC Computation(s,k);
A9: l in dom I by A2,A4,Def4;
    then s.l = I.l by A5,GRFUNC_1:8;
    then s.l in rng I by A9,FUNCT_1:def 5;
    then
A10: s.l does_not_destroy a by A1,SCMFSA7B:def 4;
    thus P[k+1]
    proof
      thus  Computation( s,k + 1).a
      = (Following Computation(s,k)).a by AMI_1:14
        .= Exec(s.l,Computation(s,k)).a by AMI_1:54
        .= s.a by A8,A10,SCMFSA7B:26;
    end;
  end;
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A6,A7);
end;

registration
  cluster InitHalting good Program of SCM+FSA;
  existence
  proof
    take Stop SCM+FSA;
    thus thesis;
  end;
end;

registration
  cluster InitClosed good -> keepInt0_1 Program of SCM+FSA;
  correctness
  proof
    let I be Program of SCM+FSA;
    assume
A1: I is InitClosed good;
    then
A2: I does_not_destroy intloc 0 by SCMFSA7B:def 5;
    now
      let s be State of SCM+FSA;
      assume
A3:   Initialized I c= s;
      let k be Element of NAT;
      I is_closed_onInit s by A1,Th35;
      hence Computation(s,k).intloc 0 = s.intloc 0 by A2,A3,Th37
        .=1 by A3,Th7;
    end;
    hence I is keepInt0_1 by Def3;
  end;
end;

registration
  cluster Stop SCM+FSA -> InitHalting good;
  coherence;
end;

theorem   ::TM056=TG25
  for s being State of SCM+FSA,
  i being keeping_0 parahalting Instruction of SCM+FSA,
  J being InitHalting Program of SCM+FSA, a being Int-Location
  holds IExec(i ';' J,s).a = IExec(J,Exec(i,Initialize s)).a
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  let a be Int-Location;
  thus IExec(i ';' J,s).a
    = IExec(J,IExec(Macro i,s)).a by Th30
    .= IExec(J,Exec(i,Initialize s)).a by SCMFSA6C:6;
end;

theorem   ::TM058=TG26
  for s being State of SCM+FSA,
  i being keeping_0 parahalting Instruction of SCM+FSA,
  J being InitHalting Program of SCM+FSA, f being FinSeq-Location
  holds IExec(i ';' J,s).f = IExec(J,Exec(i,Initialize s)).f
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  let f be FinSeq-Location;
  thus IExec(i ';' J,s).f
    = IExec(J,IExec(Macro i,s)).f by Th31
    .= IExec(J,Exec(i,Initialize s)).f by SCMFSA6C:6;
end;

theorem Th40:  ::TM060
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  I is_closed_onInit s iff I is_closed_on Initialize s
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  set s1=s +* Initialized I, s2=Initialize s +* (I +* Start-At insloc 0);
A1: s1 = s2 by SCMFSA8A:13;
  I is_closed_onInit s iff
  for k be Element of NAT holds IC Computation(s1,k) in dom I by Def4;
  hence thesis by A1,SCMFSA7B:def 7;
end;

theorem Th41:  ::TM062
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  I is_halting_onInit s iff I is_halting_on Initialize s
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  set s1=s +* Initialized I, s2=Initialize s +* (I +* Start-At insloc 0);
A1: s1 = s2 by SCMFSA8A:13;
  I is_halting_onInit s iff s1 is halting by Def5;
  hence thesis by A1,SCMFSA7B:def 8;
end;

theorem   ::TM064(SCMFSA8C:17)
  for I be Program of SCM+FSA, s be State of SCM+FSA holds
  IExec(I,s) = IExec(I,Initialize s)
proof
  let I be Program of SCM+FSA,s be State of SCM+FSA;
  set sp= s|NAT;
  thus IExec(I,s) = Result(s+*Initialized I) +*sp by SCMFSA6B:def 1
    .= Result(Initialize s+*Initialized I) +*sp by SCMFSA8A:8
    .= Result(Initialize s+*Initialized I) +*
  (Initialize s) | NAT by SCMFSA8C:36
    .= IExec(I,Initialize s) by SCMFSA6B:def 1;
end;

theorem Th43: ::ThIF0_1'
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a = 0 & I is_closed_onInit s & I is_halting_onInit s holds
  if=0(a,I,J) is_closed_onInit s & if=0(a,I,J) is_halting_onInit s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  assume
A2: I is_closed_onInit s;
  assume
A3: I is_halting_onInit s;
  set Is = Initialize s;
A4: Is.a =0 by A1,SCMFSA6C:3;
A5: I is_closed_on Is by A2,Th40;
  I is_halting_on Is by A3,Th41;
  then if=0(a,I,J) is_closed_on Is &
  if=0(a,I,J) is_halting_on Is by A4,A5,SCMFSA8B:16;
  hence thesis by Th40,Th41;
end;

theorem Th44: ::ThIF0_1(@BBB8)
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a = 0 & I is_closed_onInit s & I is_halting_onInit s holds
  IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I + card J + 3)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  assume
A2: I is_closed_onInit s;
  assume
A3: I is_halting_onInit s;
  set Is = Initialize s;
A4: I is_closed_on Is by A2,Th40;
  I is_halting_on Is by A3,Th41;
  hence thesis by A1,A4,SCMFSA8B:17;
end;

theorem Th45: ::ThIF0_2'
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a <> 0 & J is_closed_onInit s & J is_halting_onInit s holds
  if=0(a,I,J) is_closed_onInit s & if=0(a,I,J) is_halting_onInit s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a <> 0;
  assume
A2: J is_closed_onInit s;
  assume
A3: J is_halting_onInit s;
  set Is = Initialize s;
A4: Is.a <> 0 by A1,SCMFSA6C:3;
A5: J is_closed_on Is by A2,Th40;
  J is_halting_on Is by A3,Th41;
  then if=0(a,I,J) is_closed_on Is &
  if=0(a,I,J) is_halting_on Is by A4,A5,SCMFSA8B:18;
  hence thesis by Th40,Th41;
end;

theorem Th46: ::ThIF0_2
  for I,J being Program of SCM+FSA, a being read-write Int-Location holds
  for s being State of SCM+FSA
  st s.a <> 0 & J is_closed_onInit s & J is_halting_onInit s holds
  IExec(if=0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card I + card J + 3)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  assume
A1: s.a <> 0;
  assume
A2: J is_closed_onInit s;
  assume
A3: J is_halting_onInit s;
  set Is = Initialize s;
A4: J is_closed_on Is by A2,Th40;
  J is_halting_on Is by A3,Th41;
  hence thesis by A1,A4,SCMFSA8B:19;
end;

theorem Th47:  ::=ThIF0
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA,
  a being read-write Int-Location holds if=0(a,I,J) is InitHalting &
  (s.a = 0 implies IExec(if=0(a,I,J),s) =
  IExec(I,s) +* Start-At insloc (card I + card J + 3)) &
  (s.a <> 0 implies IExec(if=0(a,I,J),s) =
  IExec(J,s) +* Start-At insloc (card I + card J + 3))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
A1: I is_closed_onInit s & I is_halting_onInit s by Th35,Th36;
A2: J is_closed_onInit s & J is_halting_onInit s by Th35,Th36;
  now
    let s be State of SCM+FSA;
    assume Initialized if=0(a,I,J) c= s;
    then
A3: s = s +* Initialized if=0(a,I,J) by FUNCT_4:79;
A4: I is_closed_onInit s & I is_halting_onInit s by Th35,Th36;
A5: J is_closed_onInit s & J is_halting_onInit s by Th35,Th36;
    per cases;
    suppose s.a = 0;
      then if=0(a,I,J) is_halting_onInit s by A4,Th43;
      hence s is halting by A3,Def5;
    end;
    suppose s.a <> 0;
      then if=0(a,I,J) is_halting_onInit s by A5,Th45;
      hence s is halting by A3,Def5;
    end;
  end;
  then Initialized if=0(a,I,J) is halting by AMI_1:def 26;
  hence if=0(a,I,J) is InitHalting by Def2;
  thus s.a = 0 implies IExec(if=0(a,I,J),s) =
  IExec(I,s) +* Start-At insloc (card I + card J + 3) by A1,Th44;
  thus thesis by A2,Th46;
end;

theorem  ::ThIF0'
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA,
  a being read-write Int-Location holds
  IC IExec(if=0(a,I,J),s) = insloc (card I + card J + 3) & (s.a = 0 implies
  ((for d being Int-Location holds IExec(if=0(a,I,J),s).d = IExec(I,s).d) &
  for f being FinSeq-Location holds IExec(if=0(a,I,J),s).f = IExec(I,s).f)) &
  (s.a <> 0 implies ((for d being Int-Location holds
  IExec(if=0(a,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if=0(a,I,J),s).f = IExec(J,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby per cases;
    suppose s.a = 0;
      then IExec(if=0(a,I,J),s) =
      IExec(I,s) +* Start-At insloc (card I + card J + 3) by Th47;
      hence IC IExec(if=0(a,I,J),s) = insloc (card I + card J + 3)
      by AMI_1:111;
    end;
    suppose s.a <> 0;
      then IExec(if=0(a,I,J),s) =
      IExec(J,s) +* Start-At insloc (card I + card J + 3) by Th47;
      hence IC IExec(if=0(a,I,J),s) = insloc (card I + card J + 3)
      by AMI_1:111;
    end;
  end;
  hereby
    assume s.a = 0;
    then
A1: IExec(if=0(a,I,J),s) =
    IExec(I,s) +* Start-At insloc (card I + card J + 3) by Th47;
    hereby
      let d be Int-Location;
      not d in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:9;
      hence IExec(if=0(a,I,J),s).d = IExec(I,s).d by A1,FUNCT_4:12;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:10;
    hence IExec(if=0(a,I,J),s).f = IExec(I,s).f by A1,FUNCT_4:12;
  end;
  assume s.a <> 0;
  then
A2: IExec(if=0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card I + card J + 3)
  by Th47;
  hereby
    let d be Int-Location;
    not d in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:9;
    hence IExec(if=0(a,I,J),s).d = IExec(J,s).d by A2,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:10;
  hence IExec(if=0(a,I,J),s).f = IExec(J,s).f by A2,FUNCT_4:12;
end;

theorem Th49: ::ThIFg0_1'
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a > 0 & I is_closed_onInit s & I is_halting_onInit s holds
  if>0(a,I,J) is_closed_onInit s & if>0(a,I,J) is_halting_onInit s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  assume
A2: I is_closed_onInit s;
  assume
A3: I is_halting_onInit s;
  set Is = Initialize s;
A4: Is.a >0 by A1,SCMFSA6C:3;
A5: I is_closed_on Is by A2,Th40;
  I is_halting_on Is by A3,Th41;
  then if>0(a,I,J) is_closed_on Is &
  if>0(a,I,J) is_halting_on Is by A4,A5,SCMFSA8B:22;
  hence thesis by Th40,Th41;
end;

theorem Th50: ::ThIFg0_1
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a > 0 & I is_closed_onInit s & I is_halting_onInit s holds
  IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I + card J + 3)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  assume
A2: I is_closed_onInit s;
  assume
A3: I is_halting_onInit s;
  set Is = Initialize s;
A4: I is_closed_on Is by A2,Th40;
  I is_halting_on Is by A3,Th41;
  hence thesis by A1,A4,SCMFSA8B:23;
end;

theorem Th51: ::ThIFg0_2'
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a <= 0 & J is_closed_onInit s & J is_halting_onInit s holds
  if>0(a,I,J) is_closed_onInit s & if>0(a,I,J) is_halting_onInit s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a <= 0;
  assume
A2: J is_closed_onInit s;
  assume
A3: J is_halting_onInit s;
  set Is = Initialize s;
A4: Is.a <= 0 by A1,SCMFSA6C:3;
A5: J is_closed_on Is by A2,Th40;
  J is_halting_on Is by A3,Th41;
  then if>0(a,I,J) is_closed_on Is &
  if>0(a,I,J) is_halting_on Is by A4,A5,SCMFSA8B:24;
  hence thesis by Th40,Th41;
end;

theorem Th52: ::ThIFg0_2
  for I,J being Program of SCM+FSA, a being read-write Int-Location holds
  for s being State of SCM+FSA
  st s.a <= 0 & J is_closed_onInit s & J is_halting_onInit s holds
  IExec(if>0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card I + card J + 3)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  assume
A1: s.a <= 0;
  assume
A2: J is_closed_onInit s;
  assume
A3: J is_halting_onInit s;
  set Is = Initialize s;
A4: J is_closed_on Is by A2,Th40;
  J is_halting_on Is by A3,Th41;
  hence thesis by A1,A4,SCMFSA8B:25;
end;

theorem Th53: ::ThIFg0
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA,
  a being read-write Int-Location holds if>0(a,I,J) is InitHalting &
  (s.a > 0 implies IExec(if>0(a,I,J),s) =
  IExec(I,s) +* Start-At insloc (card I + card J + 3)) &
  (s.a <= 0 implies IExec(if>0(a,I,J),s) =
  IExec(J,s) +* Start-At insloc (card I + card J + 3))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
A1: I is_closed_onInit s & I is_halting_onInit s by Th35,Th36;
A2: J is_closed_onInit s & J is_halting_onInit s by Th35,Th36;
  now
    let s be State of SCM+FSA;
    assume Initialized if>0(a,I,J) c= s;
    then
A3: s = s +* Initialized if>0(a,I,J) by FUNCT_4:79;
A4: I is_closed_onInit s & I is_halting_onInit s by Th35,Th36;
A5: J is_closed_onInit s & J is_halting_onInit s by Th35,Th36;
    per cases;
    suppose s.a > 0;
      then if>0(a,I,J) is_halting_onInit s by A4,Th49;
      hence s is halting by A3,Def5;
    end;
    suppose s.a <= 0;
      then if>0(a,I,J) is_halting_onInit s by A5,Th51;
      hence s is halting by A3,Def5;
    end;
  end;
  then Initialized if>0(a,I,J) is halting by AMI_1:def 26;
  hence if>0(a,I,J) is InitHalting by Def2;
  thus s.a > 0 implies IExec(if>0(a,I,J),s) =
  IExec(I,s) +* Start-At insloc (card I + card J + 3) by A1,Th50;
  thus thesis by A2,Th52;
end;

theorem  ::ThIFg0'
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA,
  a being read-write Int-Location holds
  IC IExec(if>0(a,I,J),s) = insloc (card I + card J + 3) & (s.a > 0 implies
  ((for d being Int-Location holds IExec(if>0(a,I,J),s).d = IExec(I,s).d) &
  for f being FinSeq-Location holds IExec(if>0(a,I,J),s).f = IExec(I,s).f)) &
  (s.a <= 0 implies ((for d being Int-Location holds
  IExec(if>0(a,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if>0(a,I,J),s).f = IExec(J,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby per cases;
    suppose s.a > 0;
      then IExec(if>0(a,I,J),s) =
      IExec(I,s) +* Start-At insloc (card I + card J + 3) by Th53;
      hence IC IExec(if>0(a,I,J),s) = insloc (card I + card J + 3)
      by AMI_1:111;
    end;
    suppose s.a <= 0;
      then IExec(if>0(a,I,J),s) =
      IExec(J,s) +* Start-At insloc (card I + card J + 3) by Th53;
      hence IC IExec(if>0(a,I,J),s) = insloc (card I + card J + 3)
      by AMI_1:111;
    end;
  end;
  hereby
    assume s.a > 0;
    then
A1: IExec(if>0(a,I,J),s) =
    IExec(I,s) +* Start-At insloc (card I + card J + 3) by Th53;
    hereby
      let d be Int-Location;
      not d in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:9;
      hence IExec(if>0(a,I,J),s).d = IExec(I,s).d by A1,FUNCT_4:12;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:10;
    hence IExec(if>0(a,I,J),s).f = IExec(I,s).f by A1,FUNCT_4:12;
  end;
  assume s.a <= 0;
  then
A2: IExec(if>0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card I + card J + 3)
  by Th53;
  hereby
    let d be Int-Location;
    not d in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:9;
    hence IExec(if>0(a,I,J),s).d = IExec(J,s).d by A2,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:10;
  hence IExec(if>0(a,I,J),s).f = IExec(J,s).f by A2,FUNCT_4:12;
end;

theorem Th55: ::ThIFl0_1
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a < 0 & I is_closed_onInit s & I is_halting_onInit s holds
  IExec(if<0(a,I,J),s) =
  IExec(I,s) +* Start-At insloc (card I + card J + card J + 7)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a < 0;
  assume
A2: I is_closed_onInit s;
  assume
A3: I is_halting_onInit s;
  set Is = Initialize s;
A4: I is_closed_on Is by A2,Th40;
  I is_halting_on Is by A3,Th41;
  hence thesis by A1,A4,SCMFSA8B:29;
end;

theorem Th56: ::ThIFl0_2
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a = 0 & J is_closed_onInit s & J is_halting_onInit s holds
  IExec(if<0(a,I,J),s) =
  IExec(J,s) +* Start-At insloc (card I + card J + card J + 7)
proof
  let s be State of SCM+FSA,I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  assume
A2: J is_closed_onInit s;
  assume
A3: J is_halting_onInit s;
  set Is = Initialize s;
A4: J is_closed_on Is by A2,Th40;
  J is_halting_on Is by A3,Th41;
  hence thesis by A1,A4,SCMFSA8B:31;
end;

theorem Th57: ::ThIFl0_3
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a > 0 & J is_closed_onInit s & J is_halting_onInit s holds
  IExec(if<0(a,I,J),s) =
  IExec(J,s) +* Start-At insloc (card I + card J + card J + 7)
proof
  let s be State of SCM+FSA,I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  assume
A2: J is_closed_onInit s;
  assume
A3: J is_halting_onInit s;
  set Is = Initialize s;
A4: J is_closed_on Is by A2,Th40;
  J is_halting_on Is by A3,Th41;
  hence thesis by A1,A4,SCMFSA8B:33;
end;

theorem Th58:  ::ThIFl0
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA,
  a being read-write Int-Location holds (if<0(a,I,J) is InitHalting &
  (s.a < 0 implies IExec(if<0(a,I,J),s) =
  IExec(I,s) +* Start-At insloc (card I + card J + card J + 7)) &
  (s.a >= 0 implies IExec(if<0(a,I,J),s) =
  IExec(J,s) +* Start-At insloc (card I + card J + card J + 7)))
proof
  let s be State of SCM+FSA,I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
A1: if<0(a,I,J) = if=0(a,J,if>0(a,J,I)) by SCMFSA8B:def 3;
  if>0(a,J,I) is InitHalting by Th53;
  hence if<0(a,I,J) is InitHalting by A1,Th47;
A2: I is_closed_onInit s & I is_halting_onInit s by Th35,Th36;
A3: J is_closed_onInit s & J is_halting_onInit s by Th35,Th36;
  thus s.a < 0 implies IExec(if<0(a,I,J),s) =
  IExec(I,s) +* Start-At insloc (card I + card J + card J + 7) by A2,Th55;
  hereby
    assume
A4: s.a >= 0;
    per cases;
    suppose s.a = 0;
      hence IExec(if<0(a,I,J),s) =
      IExec(J,s) +* Start-At insloc (card I + card J + card J + 7) by A3,Th56;
    end;
    suppose s.a <> 0;
      hence IExec(if<0(a,I,J),s) =
      IExec(J,s) +* Start-At insloc (card I + card J + card J + 7)
      by A3,A4,Th57;
    end;
  end;
end;

registration
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  cluster if=0(a,I,J) -> InitHalting;
  correctness by Th47;
  cluster if>0(a,I,J) -> InitHalting;
  correctness by Th53;
  cluster if<0(a,I,J) -> InitHalting;
  correctness by Th58;
end;

theorem Th59:  ::TM202
  for I being Program of SCM+FSA holds
  I is InitHalting iff for s being State of SCM+FSA holds
  I is_halting_on Initialize s
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is InitHalting;
    let s be State of SCM+FSA;
    I is_halting_onInit s by A1,Th36;
    hence I is_halting_on Initialize s by Th41;
  end;
  assume
A2: for s being State of SCM+FSA holds I is_halting_on Initialize s;
  now
    let s be State of SCM+FSA;
    I is_halting_on Initialize s by A2;
    hence I is_halting_onInit s by Th41;
  end;
  hence I is InitHalting by Th36;
end;

theorem Th60:  ::TM204
  for I being Program of SCM+FSA holds
  I is InitClosed iff for s being State of SCM+FSA holds
  I is_closed_on Initialize s
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is InitClosed;
    let s be State of SCM+FSA;
    I is_closed_onInit s by A1,Th35;
    hence I is_closed_on Initialize s by Th40;
  end;
  assume
A2: for s being State of SCM+FSA holds I is_closed_on Initialize s;
  now
    let s be State of SCM+FSA;
    I is_closed_on Initialize s by A2;
    hence I is_closed_onInit s by Th40;
  end;
  hence I is InitClosed by Th35;
end;

theorem Th61: ::TM206=T200724
  for s being State of SCM+FSA, I being InitHalting Program of SCM+FSA,
  a being read-write Int-Location holds
  IExec(I,s).a =  Computation( (Initialize s +* (I +* Start-At insloc 0)),
  (LifeSpan (Initialize s +* (I +* Start-At insloc 0)))).a
proof
  let s be State of SCM+FSA,I be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  I is_halting_on Initialize s by Th59;
  hence thesis by SCMFSA8C:87;
end;

theorem Th62: ::TM208=TMP29
  for s being State of SCM+FSA, I being InitHalting Program of SCM+FSA,
  a being Int-Location,k being Element of NAT st I does_not_destroy a holds
  IExec(I,s).a =  Computation( (Initialize s +* (I +* Start-At insloc 0)),k).a
proof
  let s be State of SCM+FSA,I be InitHalting Program of SCM+FSA;
  let a be Int-Location,k be Element of NAT;
  assume
A1: I does_not_destroy a;
A2: I is_halting_on Initialize s by Th59;
  I is_closed_on Initialize s by Th60;
  hence thesis by A1,A2,SCMFSA8C:89;
end;
set A = NAT;
set D = Int-Locations \/ FinSeq-Locations;

theorem Th63: ::TM209=TMP29''
  for s being State of SCM+FSA, I being InitHalting Program of SCM+FSA,
  a being Int-Location st I does_not_destroy a holds
  IExec(I,s).a = (Initialize s).a
proof
  let s be State of SCM+FSA;
  let I be InitHalting Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does_not_destroy a;
A2: DataPart Initialize s = DataPart (Initialize s +* (I +* Start-At insloc 0))
  by SCMFSA8A:11;
  thus IExec(I,s).a
  =  Computation( (Initialize s +* (I +* Start-At insloc 0)),0).a by A1,Th62
    .= (Initialize s +* (I +* Start-At insloc 0)).a by AMI_1:13
    .= (Initialize s).a by A2,SCMFSA6A:38;
end;

theorem Th64: ::TM210=TMP27
  for s be State of SCM+FSA,I be keepInt0_1 InitHalting Program of SCM+FSA,
  a being read-write Int-Location st I does_not_destroy a holds
   Computation( (Initialize s +* (I ';' SubFrom(a,intloc 0) +*
  Start-At insloc 0)),LifeSpan (Initialize s +*
  (I ';' SubFrom(a,intloc 0) +* Start-At insloc 0))).a = s.a - 1
proof
  let s be State of SCM+FSA,I be keepInt0_1 InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  set s0 = Initialize s;
  set s1 = s0 +* (I ';' SubFrom(a,intloc 0) +* Start-At insloc 0);
A2: a in dom s0 & not a in dom (I +* Start-At insloc 0)
  by SCMFSA6B:12,SCMFSA_2:66;
  IExec(I ';' SubFrom(a,intloc 0),s).a
  = Exec(SubFrom(a,intloc 0),IExec(I,s)).a by Th33
    .= IExec(I,s).a - IExec(I,s).intloc 0 by SCMFSA_2:91
    .= IExec(I,s).a - 1 by Th17
    .=  Computation( (s0 +* (I +* Start-At insloc 0)),0).a - 1 by A1,Th62
    .= (s0 +* (I +* Start-At insloc 0)).a - 1 by AMI_1:13
    .= s0.a - 1 by A2,FUNCT_4:12;
  hence  Computation( s1,LifeSpan s1).a = s0.a - 1 by Th61
    .= s.a - 1 by SCMFSA6C:3;
end;

theorem Th65: ::MAI1
  for s being State of SCM+FSA, I being InitClosed Program of SCM+FSA
  st Initialized I c= s & s is halting
  for m being Element of NAT st m <= LifeSpan s
  holds Computation(s,m), Computation( (s +* loop I),m) equal_outside NAT
proof
  let s be State of SCM+FSA,I be InitClosed Program of SCM+FSA;
  assume
A1: Initialized I c= s;
  assume
A2: s is halting;
  defpred X[Element of NAT] means
  $1 <= LifeSpan s implies Computation(s,$1), Computation((s+*loop I),$1)
  equal_outside NAT;
  Computation(s,0) = s &
   Computation((s+*loop I),0) = s+*loop I by AMI_1:13;
  then
A3: X[0] by AMI_1:120;
A4: for m st X[m] holds X[m+1]
  proof
    let m;
    assume
A5: m <= LifeSpan s implies Computation(s,m), Computation((s+*loop I),m)
    equal_outside NAT;
    assume
A6: m+1 <= LifeSpan s;
    then
A7: m < LifeSpan s by NAT_1:13;
    set sx = s+*loop I;
A8: Computation(s,m+1) = Following Computation(s,m) by AMI_1:14
      .= Exec(CurInstr Computation(s,m),Computation(s,m));
A9: Computation(sx,m+1) = Following Computation(sx,m) by AMI_1:14
      .= Exec(CurInstr Computation(sx,m),Computation(sx,m));
A10: IC(Computation(s,m)) = IC(Computation(sx,m)) by A5,A6,AMI_1:121,NAT_1:13;
A11: IC Computation(s,m) in dom I by A1,Def1;
A12: I c= Computation(s,m) by A1,Th13,AMI_1:81;
A13: loop I c= Computation(sx,m) by AMI_1:81,FUNCT_4:26;
A14: IC Computation(s,m) in dom loop I by A11,FUNCT_4:105;
A15: CurInstr(Computation(s,m)) = I.IC(Computation(s,m)) by A11,A12,GRFUNC_1:8;
    then I.IC(Computation(s,m)) <> halt SCM+FSA by A2,A7,AMI_1:def 46;
    then CurInstr(Computation(s,m)) = (loop I).IC(Computation(s,m))
    by A15,FUNCT_4:111
      .= CurInstr(Computation(sx,m)) by A10,A13,A14,GRFUNC_1:8;
    hence  Computation( s,m+1), Computation((s+*loop I),m+1)
    equal_outside NAT by A5,A6,A8,A9,NAT_1:13,SCMFSA6A:32;
  end;
  thus for m being Element of NAT holds X[m] from NAT_1:sch 1(A3,A4);
end;

theorem
  for s being State of SCM+FSA, I being InitHalting Program of SCM+FSA
  st Initialized I c= s holds for k being Element of NAT st k <= LifeSpan s
  holds CurInstr  Computation( (s +* loop I),k) <> halt SCM+FSA
proof
  let s be State of SCM+FSA;
  let I be InitHalting Program of SCM+FSA;
  assume
A1: Initialized I c= s;
  then
A2: s is halting by AMI_1:def 26;
  set s2 = s +* loop I;
  hereby
    let k be Element of NAT;
    assume
A3: k <= LifeSpan s;
    set lk = IC Computation(s,k);
A4: IC Computation(s,k) in dom I by A1,Def1;
A5: lk = IC Computation(s2,k) by A1,A2,A3,Th65,AMI_1:121;
A6: dom I = dom loop I by FUNCT_4:105;
    assume
A7: CurInstr  Computation( (s +* loop I),k) = halt SCM+FSA;
A8: CurInstr Computation(s2,k) = s2.lk by A5,AMI_1:54
      .= (loop I).lk by A4,A6,FUNCT_4:14;
    (loop I).lk in rng loop I by A4,A6,FUNCT_1:def 5;
    hence contradiction by A7,A8,SCMFSA8C:107;
  end;
end;

theorem Th67:  ::I_SI
  I c= s +* Initialized I
proof
  Initialized I c= s +* Initialized I & I c= Initialized I
  by FUNCT_4:26,SCMFSA6A:26;
  hence thesis by XBOOLE_1:1;
end;

theorem Th68: ::TMP24
  for s being State of SCM+FSA, I being Program of SCM+FSA
  st I is_closed_onInit s & I is_halting_onInit s
  for m being Element of NAT st m <= LifeSpan (s +* Initialized I)
  holds  Computation( (s +* Initialized I),m),
   Computation((s +* Initialized (loop I)),m) equal_outside NAT
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized (loop I);
  assume
A1: I is_closed_onInit s;
  assume
A2: I is_halting_onInit s;
  defpred X[Element of NAT] means $1 <= LifeSpan s1 implies
   Computation( s1,$1), Computation( s2,$1) equal_outside A;
A3: X[0]
  proof
    assume 0 <= LifeSpan s1;
A4: s +* I,s equal_outside A by AMI_1:120,FUNCT_7:28;
    s,s +* loop I equal_outside A by AMI_1:120;
    then s +* I,s +* loop I equal_outside A by A4,FUNCT_7:29;
    then s +* I +* iS,s +* loop I +* iS equal_outside A by FUNCT_7:106;
    then s +* (I +* iS),s +* loop I +* iS equal_outside A by FUNCT_4:15;
    then s +* (I +* iS),s +* (loop I +* iS) equal_outside A by FUNCT_4:15;
    then s +* (I +* iS),s2 equal_outside A by FUNCT_4:15;
    then s1,s2 equal_outside A by FUNCT_4:15;
    then s1, Computation( s2,0) equal_outside A by AMI_1:13;
    hence  Computation( s1,0), Computation( s2,0) equal_outside A by AMI_1:13;
  end;
A5: s1 is halting by A2,Def5;
A6: for m being Element of NAT st X[m] holds X[m+1]
  proof
    let m be Element of NAT;
    assume
A7: m <= LifeSpan s1 implies Computation(s1,m),Computation(s2,m)
 equal_outside A;
    assume
A8: m + 1 <= LifeSpan s1;
    then
A9: m < LifeSpan s1 by NAT_1:13;
A10: Computation(s1,m+1) = Following Computation(s1,m) by AMI_1:14
      .= Exec(CurInstr Computation(s1,m),Computation(s1,m));
A11: Computation(s2,m+1) = Following Computation(s2,m) by AMI_1:14
      .= Exec(CurInstr Computation(s2,m),Computation(s2,m));
A12: IC Computation(s1,m) = IC Computation(s2,m) by A7,A8,AMI_1:121,NAT_1:13;
A13: I c= Computation(s1,m) by Th67,AMI_1:81;
A14: loop I c= Computation(s2,m) by Th67,AMI_1:81;
A15: IC Computation(s1,m) in dom I by A1,Def4;
    then
A16: IC Computation(s1,m) in dom loop I by FUNCT_4:105;
A17: CurInstr Computation(s1,m) = I.IC Computation(s1,m) by A13,A15,GRFUNC_1:8;
    then I.IC Computation(s1,m) <> halt SCM+FSA by A5,A9,AMI_1:def 46;
    then I.IC Computation(s1,m) = (loop I).IC Computation(s1,m)
     by FUNCT_4:111;
    then CurInstr Computation(s1,m) = CurInstr Computation(s2,m)
     by A12,A14,A16,A17,GRFUNC_1:8;
    hence Computation(s1,m+1),Computation(s2,m+1) equal_outside A
     by A7,A8,A10,A11,NAT_1:13,SCMFSA6A:32;
  end;
  thus for m being Element of NAT holds X[m] from NAT_1:sch 1(A3,A6);
end;

theorem Th69: ::TMP25
  for s being State of SCM+FSA, I being Program of SCM+FSA
  st I is_closed_onInit s & I is_halting_onInit s
  for m being Element of NAT st m < LifeSpan (s +* Initialized I) holds
  CurInstr  Computation( (s +* Initialized I),m) =
  CurInstr  Computation((s +* Initialized(loop I)),m)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized(loop I);
  assume
A1: I is_closed_onInit s & I is_halting_onInit s;
  let m be Element of NAT;
  assume
A2: m < LifeSpan (s +* Initialized I);
  then
A3: IC Computation(s1,m) = IC Computation(s2,m) by A1,Th68,AMI_1:121;
A4: I c= Computation(s1,m) by Th67,AMI_1:81;
A5: loop I c= Computation(s2,m) by Th67,AMI_1:81;
A6: IC Computation(s1,m) in dom I by A1,Def4;
  then
A7: IC Computation(s1,m) in dom loop I by FUNCT_4:105;
A8: s1 is halting by A1,Def5;
A9: CurInstr Computation(s1,m) = I.IC Computation(s1,m) by A4,A6,GRFUNC_1:8;
  then I.IC Computation(s1,m) <> halt SCM+FSA by A2,A8,AMI_1:def 46;
  then I.IC Computation(s1,m) = (loop I).IC Computation(s1,m) by FUNCT_4:111;
  hence CurInstr Computation(s1,m) = CurInstr Computation(s2,m)
   by A3,A5,A7,A9,GRFUNC_1:8;
end;

theorem Th70:  ::InsLoc
  for l being Instruction-Location of SCM+FSA holds
  not l in dom (((intloc 0) .--> 1) +* Start-At insloc 0)
proof
  let l be Instruction-Location of SCM+FSA;
  assume l in dom iS;
  then l=intloc 0 or l=IC SCM+FSA by Th1;
  hence contradiction by AMI_1:48,SCMFSA_2:84;
end;

theorem Th71:  ::_TMP23
  for s being State of SCM+FSA, I being Program of SCM+FSA
  st I is_closed_onInit s & I is_halting_onInit s holds
  (CurInstr  Computation( (s +* Initialized (loop I)),
  LifeSpan (s +* Initialized I)) = goto insloc 0 &
  for m being Element of NAT st m <= LifeSpan (s +* Initialized I) holds
  CurInstr  Computation( (s +* Initialized (loop I)),m) <> halt SCM+FSA)
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized loop I;
  assume
A1: I is_closed_onInit s & I is_halting_onInit s;
  then
A2: s1 is halting by Def5;
  set k = LifeSpan s1;
A3: CurInstr Computation(s1,k) = halt SCM+FSA by A2,AMI_1:def 46;
A4: IC Computation(s1,k) = IC Computation(s2,k) by A1,Th68,AMI_1:121;
A5: IC Computation(s1,k) in dom I by A1,Def4;
  then IC Computation(s1,k) in dom (I +* iS) by FUNCT_4:13;
  then
A6: IC Computation(s1,k) in dom (Initialized I) by FUNCT_4:15;
A7: now thus CurInstr Computation(s1,k) = s1.IC Computation(s1,k) by AMI_1:54
      .= (Initialized I).IC Computation(s1,k) by A6,FUNCT_4:14
      .= (I +* iS).IC Computation(s1,k) by FUNCT_4:15
      .= I.IC Computation(s1,k) by Th70,FUNCT_4:12;
  end;
  dom loop I = dom I by FUNCT_4:105;
  then IC Computation(s1,k) in dom (loop I +* iS) by A5,FUNCT_4:13;
  then
A8: IC Computation(s1,k) in dom (Initialized loop I ) by FUNCT_4:15;
X: rng I c= the Instructions of SCM+FSA by AMI_1:118;
y: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA
                  by RELAT_1:71;
  thus
A11: CurInstr Computation(s2,LifeSpan s1) = s2.IC Computation(s1,k)
 by A4,AMI_1:54
      .= (Initialized loop I ).IC Computation(s1,k) by A8,FUNCT_4:14
      .= (loop I +* iS ).IC Computation(s1,k) by FUNCT_4:15
      .= (loop I).IC Computation(s1,k) by Th70,FUNCT_4:12
      .= (((id the Instructions of SCM+FSA) +* (halt SCM+FSA,
    goto insloc 0))* I ).IC Computation(s1,k) by X,FUNCT_7:118
      .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA,
    goto insloc 0)).halt SCM+FSA by A3,A5,A7,FUNCT_1:23
      .= goto insloc 0 by y,FUNCT_7:33;
  let m be Element of NAT;
  assume
A12: m <= LifeSpan s1;
  per cases by A12,XXREAL_0:1;
  suppose
A13: m < LifeSpan s1;
    then CurInstr Computation(s1,m) <> halt SCM+FSA by A2,AMI_1:def 46;
    hence CurInstr Computation(s2,m) <> halt SCM+FSA by A1,A13,Th69;
  end;
  suppose m = LifeSpan s1;
    hence CurInstr Computation(s2,m) <> halt SCM+FSA by A11,SCMFSA_2:47,124;
  end;
end;

theorem  ::TMP26
  for s being State of SCM+FSA, I being Program of SCM+FSA
  st I is_closed_onInit s & I is_halting_onInit s holds
  CurInstr  Computation( (s +* Initialized loop I),
  LifeSpan (s +* Initialized I)) = goto insloc 0 by Th71;

theorem Th73: ::TMP22
  for s being State of SCM+FSA, I being good InitHalting Program of SCM+FSA,
  a being read-write Int-Location st
  I does_not_destroy a & s.intloc 0 = 1 & s.a > 0 holds
  loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0)) is_pseudo-closed_on s
proof
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  assume
A2: s.intloc 0 = 1;
  assume
A3: s.a > 0;
  set P = if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0));
  reconsider I1 = I ';' SubFrom(a,intloc 0) as InitHalting Program of SCM+FSA;
  set i = a =0_goto insloc (card I1 + 3);
  defpred P[Element of NAT] means
  for s being State of SCM+FSA st s.intloc 0 = 1 & s.a = $1 & s.a > 0 holds
  ( Computation( (s +* Initialized (loop P)),
  (LifeSpan (s +* Initialized P) + 1))).a = s.a - 1 &
  ( Computation( (s +* Initialized (loop P) ),
  (LifeSpan (s +* Initialized P) + 1))).intloc 0 = 1 &
  ex k being Element of NAT st IC  Computation( (s +* Initialized(loop P)),k) =
  insloc card ProgramPart loop P & for n being Element of NAT st n < k holds
  IC  Computation( (s +* Initialized (loop P)),n) in dom loop P;
A4: P[0];
A5: for k being Element of NAT holds P[k] implies P[k + 1]
  proof
    let k be Element of NAT;
    assume
A6: P[k];
    let ss be State of SCM+FSA;
    assume
A7: ss.intloc 0 = 1;
    assume
A8: ss.a = k + 1;
    assume
A9: ss.a > 0;
    set s1 = ss +* Initialized P;
    set s2 = ss +* Initialized (loop P );
    set s3 = Computation(s2,LifeSpan s1+1);
A10: now
A11:  now thus card loop P = card dom loop P by PRE_CIRC:21
          .= card dom P by FUNCT_4:105
          .= card P by PRE_CIRC:21;
        thus card P = card Goto insloc 2 + card I1 + 4 by SCMFSA8B:14
          .= card I1 + 1 + 4 by SCMFSA8A:29
          .= card I1 + 3 + 2;
      end;
A12:  now thus P = i ';' I1 ';' Goto insloc (card Goto insloc 2 + 1) ';'
        Goto insloc 2 ';' Stop SCM+FSA by SCMFSA8B:def 1
          .= i ';' (I1 ';' Goto insloc (card Goto insloc 2 + 1)) ';'
        Goto insloc 2 ';' Stop SCM+FSA by SCMFSA6A:71
          .= i ';' (I1 ';' Goto insloc (card Goto insloc 2 + 1) ';'
        Goto insloc 2) ';' Stop SCM+FSA by SCMFSA6A:71
          .= i ';' (I1 ';' Goto insloc (card Goto insloc 2 + 1) ';'
        Goto insloc 2 ';' Stop SCM+FSA) by SCMFSA6A:71
          .= Macro i ';' (I1 ';' Goto insloc (card Goto insloc 2 + 1) ';'
        Goto insloc 2 ';' Stop SCM+FSA);
      end;
      InsCode i = 7 & InsCode halt SCM+FSA = 0 by SCMFSA_2:48,124;
      then insloc 0 in dom Macro i &
      (Macro i).insloc 0 <> halt SCM+FSA by SCMFSA6B:32,33;
      hence P.insloc 0 = (Macro i).insloc 0 by A12,SCMFSA6A:54
        .= i by SCMFSA6B:33;
      hence P.insloc 0 <> halt SCM+FSA by SCMFSA_2:48,124;
      thus insloc 0 in dom P by A11,SCMFSA6A:15;
      card ProgramPart loop P = card I1 + (3 + 2) by A11,AMI_1:105;
      hence P.insloc (card I1 + 3) = goto insloc card ProgramPart loop P by
SCMFSA8C:116;
      hence P.insloc (card I1 + 3) <> halt SCM+FSA by SCMFSA_2:47,124;
      hereby
        card I1 + 3 + 0 < card P by A11,XREAL_1:8;
        hence insloc (card I1 + 3) in dom P by SCMFSA6A:15;
      end;
    end;
A13: now
      I1 is_closed_onInit ss & I1 is_halting_onInit ss by Th35,Th36;
      hence
A14:  P is_closed_onInit ss & P is_halting_onInit ss by A9,Th45;
      Computation(s2,LifeSpan s1+1) = Following Computation(s2,LifeSpan s1)
       by AMI_1:14
        .= Exec(CurInstr Computation(s2,LifeSpan s1),
        Computation(s2,LifeSpan s1));
      hence Computation(s2,LifeSpan s1+1) =
      Exec(goto insloc 0,Computation(s2,LifeSpan s1))
      by A14,Th71;
      hence IC Computation(s2,LifeSpan s1+1)= insloc 0 by SCMFSA_2:95;
    end;
A15: now
A16:  now thus card loop P = card dom loop P by PRE_CIRC:21
          .= card dom P by FUNCT_4:105
          .= card P by PRE_CIRC:21;
        thus card P = card Goto insloc 2 + card I1 + 4 by SCMFSA8B:14
          .= card I1 + 1 + 4 by SCMFSA8A:29
          .= card I1 + 3 + 2;
      end;
      hereby
        thus insloc 0 in dom loop P by A16,SCMFSA6A:15;
        card I1 + 3 + (1 + 1) = (card I1 + 3 + 1) + 1;
        then card I1 + 3 + 1 < card P by A16,NAT_1:13;
        then card I1 + 3 < card loop P by A16,NAT_1:13;
        hence insloc (card I1 + 3) in dom loop P by SCMFSA6A:15;
      end; thus
A17:  Initialize ss +* Initialized P = ss +* Initialized P by SCMFSA8A:8;
A18:  Initialize Initialize ss = Initialize ss by SCMFSA8C:15;
      consider Is being State of SCM+FSA such that
A19:  Is = Initialize ss +* Initialized P;
A20:  Is = Initialize ss +* (P +* Start-At insloc 0) by A18,A19,SCMFSA8A:13;
A21:  I1 is_halting_onInit ss by Th36;
      then
A22:  I1 is_halting_on Initialize ss by Th41;
A23:  now
A24:    now
          let b be Int-Location;
          Computation(s1,LifeSpan s1),Computation(s2,LifeSpan s1)
           equal_outside A &
          Computation(s2,LifeSpan s1+1).b = Computation(s2,LifeSpan s1).b
           by A13,Th68,SCMFSA_2:95;
          hence Computation(s2,LifeSpan s1+1).b =
            Computation( Is,LifeSpan Is).b by A17,A19,SCMFSA6A:30;
        end;
A25:    (Initialize ss).a > 0 by A9,SCMFSA6C:3;
        I1 is_closed_onInit ss & I1 is_halting_onInit ss by Th35,Th36;
        then I1 is_closed_on Initialize ss & I1 is_halting_on Initialize ss
        by Th40,Th41;
        then
A26:    P is_halting_on Initialize ss & P is_closed_on Initialize ss
        by A25,SCMFSA8B:18;
        thus Computation(s2,LifeSpan s1+1).a =
         Computation( Is,LifeSpan Is).a by A24
          .= IExec(P,ss).a by A20,A26,SCMFSA8C:87;
A27:    P is good by SCMFSA8C:115;
        thus Computation(s2,LifeSpan s1+1).intloc 0
        =  Computation( Is,LifeSpan Is).intloc 0 by A24
          .= 1 by A20,A26,A27,SCMFSA8C:96;
      end;
      ss.a <> 0 & I1 is_closed_onInit ss by A9,Th35;
      then IExec(P,ss) = IExec(I1,ss) +* Start-At insloc (card Goto
      insloc 2 + card I1 + 3) by A21,Th46;
      then IExec(P,ss).a = IExec(I1,ss).a by SCMFSA_3:11;
      hence Computation(s2,LifeSpan s1+1).a
      =  Computation( (Initialize ss +* (I1 +* Start-At insloc 0)),
      (LifeSpan (Initialize ss +* (I1 +* Start-At insloc 0)))).a
      by A22,A23,SCMFSA8C:87
        .= ss.a - 1 by A1,Th64;
      thus Computation(s2,LifeSpan s1+1).intloc 0 = 1 by A23;
    end;
    hence s3.a = ss.a - 1 & s3.intloc 0 = 1;
    hereby per cases;
      suppose
A28:    k = 0;
        take m = LifeSpan s1 + 1 + 1 + 1;
A29:    s2 = ss +* (loop P +* Start-At insloc 0) by A7,SCMFSA8C:18;
A30:    now thus CurInstr Computation(s2,LifeSpan s1+1) = s2.insloc 0
 by A13,AMI_1:54
            .= (loop P).insloc 0 by A15,A29,SCMFSA8C:26
            .= i by A10,FUNCT_4:111;
        end;
A31:    now thus
          Computation(s2,LifeSpan s1+1+1) =
          Following Computation(s2,LifeSpan s1+1) by AMI_1:14
            .= Exec(i,Computation(s2,LifeSpan s1+1)) by A30;
        end;
        then
A32:    IC Computation(s2,LifeSpan s1+1+1)
        = insloc (card I1 + 3) by A8,A15,A28,SCMFSA_2:96;
A33:    now thus CurInstr Computation(s2,LifeSpan s1+1+1)
          = s2.insloc (card I1 + 3) by A32,AMI_1:54
            .= (loop P).insloc (card I1 + 3) by A15,A29,SCMFSA8C:26
            .= goto insloc card ProgramPart loop P by A10,FUNCT_4:111;
        end;
        Computation(s2,m) = Following Computation(s2,LifeSpan s1+1+1)
        by AMI_1:14
          .= Exec(goto insloc card ProgramPart loop P,
          Computation(s2,LifeSpan s1+1+1))
        by A33;
        hence IC Computation(s2,m) = insloc card ProgramPart loop P
        by SCMFSA_2:95;
        hereby
          let n be Element of NAT;
          assume n < m;
          then n <= LifeSpan s1 + 1 + 1 by NAT_1:13;
          then
A34:      n <= LifeSpan s1 + 1 or n = LifeSpan s1 + 1 + 1 by NAT_1:8;
          per cases by A34,NAT_1:8;
          suppose
A35:        n <= LifeSpan s1;
            I1 is_closed_onInit ss & I1 is_halting_onInit ss by Th35,Th36;
            then
A36:        P is_closed_onInit ss & P is_halting_onInit ss by A9,Th45;
            then Computation(s1,n),Computation(s2,n) equal_outside A
            by A35,Th68;
            then
A37:        IC Computation(s2,n) = IC Computation(s1,n) by SCMFSA8A:6;
            IC Computation(s1,n) in dom P by A36,Def4;
            hence IC Computation(s2,n) in dom loop P by A37,FUNCT_4:105;
          end;
          suppose n = LifeSpan s1 + 1;
            hence IC Computation(s2,n) in dom loop P by A13,A15;
          end;
          suppose n = LifeSpan s1 + 1 + 1;
            hence IC Computation(s2,n) in dom loop P
            by A8,A15,A28,A31,SCMFSA_2:96;
          end;
        end;
      end;
      suppose
A38:    k > 0;
        consider Is3 being State of SCM+FSA such that
A39:    Is3 = Initialize s3;
A40:    Is3.intloc 0 = 1 by A39,SCMFSA6C:3;
        Is3.a = k & Is3.a > 0 by A8,A15,A38,A39,SCMFSA6C:3;
        then consider m0 being Element of NAT such that
A41:    IC  Computation( (Is3 +* Initialized (loop P)),m0) =
        insloc card ProgramPart loop P and
A42:    for n being Element of NAT st n < m0 holds
        IC  Computation( (Is3 +* Initialized (loop P)),n)
        in dom loop P by A6,A40;
        take m = LifeSpan s1 + 1 + m0;
A43:    now thus
          loop P c= s2 by Th67;
          ProgramPart (loop P) c= s3 by Th67,AMI_1:99;
          then
A44:      loop P c= s3 by AMI_1:105;
          thus Initialize s3 +* Initialized loop P =
          s3 +* Initialized loop P by SCMFSA8A:8
            .= s3 +* (loop P +* iS) by FUNCT_4:15
            .= s3 +* loop P +* iS by FUNCT_4:15
            .= s3 +* iS +* loop P by Th19
            .= s3 +* ((intloc 0) .--> 1) +* Start-At insloc 0 +* loop P
          by FUNCT_4:15
            .= Initialize s3 +* loop P by SCMFSA6C:def 3
            .= s3 +* loop P by A13,A15,SCMFSA8C:14
            .= s3 by A44,FUNCT_4:79;
        end;
        hence IC Computation(s2,m) = insloc card ProgramPart loop P
        by A39,A41,AMI_1:51;
        hereby
          let n be Element of NAT;
          assume
A45:      n < m;
          I1 is_closed_onInit ss & I1 is_halting_onInit ss by Th35,Th36;
          then
A46:      P is_closed_onInit ss & P is_halting_onInit ss by A9,Th45;
          per cases by NAT_1:13;
          suppose n <= LifeSpan s1;
            then Computation(s1,n),Computation(s2,n) equal_outside A
            by A46,Th68;
            then
A47:        IC Computation(s2,n) = IC Computation(s1,n) by SCMFSA8A:6;
            IC Computation(s1,n) in dom P by A46,Def4;
            hence IC Computation(s2,n) in dom loop P by A47,FUNCT_4:105;
          end;
          suppose
A48:        LifeSpan s1 + 1 <= n;
            consider mm being Element of NAT such that
A49:        mm = n -' (LifeSpan s1 + 1);
            mm + (LifeSpan s1 + 1) = n by A48,A49,XREAL_1:237;
            then
A50:        IC Computation(s2,n) = IC  Computation( s3,mm) by AMI_1:51;
            n - (LifeSpan s1 + 1) >= 0 by A48,XREAL_1:50;
            then mm = n - (LifeSpan s1 + 1) & m0 = m - (LifeSpan s1 + 1)
            by A49,XREAL_0:def 2;
            then mm < m0 by A45,XREAL_1:11;
            hence IC Computation(s2,n) in dom loop P by A39,A42,A43,A50;
          end;
        end;
      end;
    end;
  end;
  reconsider sa = s.a as Element of NAT by A3,INT_1:16;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A4,A5);
  then P[sa];
  then
A51: ex k being Element of NAT st
  IC  Computation( (s +* Initialized(loop P)),k) =
  insloc card ProgramPart loop P & for n being Element of NAT st n < k holds
  IC  Computation( (s +* Initialized(loop P)),n) in dom loop P by A2,A3;
  s +* Initialized(loop P)= s +* (loop P +* Start-At insloc 0)
  by A2,SCMFSA8C:18;
  hence loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s by A51,SCMFSA8A:def 3;
end;

theorem
  for s being State of SCM+FSA, I being good InitHalting Program of SCM+FSA,
  a being read-write Int-Location st I does_not_destroy a & s.a > 0 holds
  Initialized loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  assume
A2: s.a > 0;
  (Initialize s).a = s.a & (Initialize s).intloc 0 = 1 by SCMFSA6C:3;
  then loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on Initialize s by A1,A2,Th73;
  hence Initialized loop if=0(a,Goto insloc 2,I ';'
  SubFrom(a,intloc 0)) is_pseudo-closed_on s by SCMFSA8C:47;
end;

theorem
  for s being State of SCM+FSA, I being good InitHalting Program of SCM+FSA,
  a being read-write Int-Location
  st I does_not_destroy a & s.intloc 0 = 1 holds
  Times(a,I) is_closed_on s & Times(a,I) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  assume
A2: s.intloc 0 = 1;
  per cases;
  suppose
A4: s.a > 0;
    Directed loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0)) =
    loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0)) by SCMFSA6A:63;
    then Directed loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0))
    is_pseudo-closed_on s by A1,A2,A4,Th73;
    hence Times(a,I) is_closed_on s & Times(a,I) is_halting_on s
    by A4,SCMFSA8C:68;
  end;
  suppose
A5: s.a <= 0;
    Stop SCM+FSA is_closed_on s & Stop SCM+FSA is_halting_on s
    by SCMFSA7B:24,25;
    hence Times(a,I) is_closed_on s & Times(a,I) is_halting_on s
    by A5,SCMFSA8B:24;
  end;
end;

theorem   ::Itime
  for I being good InitHalting Program of SCM+FSA,
  a being read-write Int-Location st I does_not_destroy a holds
  Initialized Times(a,I) is halting
proof
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  now
    let s be State of SCM+FSA;
    per cases;
    suppose s.a > 0;
      then
A3:   (Initialize s).intloc 0 = 1 & (Initialize s).a > 0 by SCMFSA6C:3;
      Directed loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0)) =
      loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0)) by SCMFSA6A:63;
      then Directed loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0))
      is_pseudo-closed_on Initialize s by A1,A3,Th73;
      then Times(a,I) is_halting_on Initialize s by A3,SCMFSA8C:68;
      hence Initialized Times(a,I) is_halting_on s by SCMFSA8C:22;
    end;
    suppose s.a <= 0;
      then
A4:   (Initialize s).a <= 0 by SCMFSA6C:3;
      Stop SCM+FSA is_closed_on Initialize s &
      Stop SCM+FSA is_halting_on Initialize s by SCMFSA7B:24,25;
      then Times(a,I) is_halting_on Initialize s by A4,SCMFSA8B:24;
      hence Initialized Times(a,I) is_halting_on s by SCMFSA8C:22;
    end;
  end;
  hence Initialized Times(a,I) is halting by SCMFSA8C:24;
end;

registration
  let a be read-write Int-Location,I be good Program of SCM+FSA;
  cluster Times(a,I) -> good;
  coherence
  proof
    set i=SubFrom(a,intloc 0);
    reconsider Mi=Macro i as good Program of SCM+FSA
     by SCMFSA7B:14,SCMFSA8C:99;
    I ';' Mi is good;
    then reconsider Ii=I ';' i as good Program of SCM+FSA;
    if>0(a,loop if=0(a,Goto insloc 2,Ii), Stop SCM+FSA) is good;
    hence thesis;
  end;
end;

theorem Th77: ::TMP22'
  for s being State of SCM+FSA, I being good InitHalting Program of SCM+FSA,
  a being read-write Int-Location st I does_not_destroy a & s.a > 0 holds
  ex s2 being State of SCM+FSA, k being Element of NAT st
  s2 = s +* Initialized (loop if=0(a,Goto insloc 2,
  I ';' SubFrom(a,intloc 0))) &
  k = LifeSpan (s +* Initialized (if=0(a,Goto insloc 2,
  I ';' SubFrom(a,intloc 0)))) + 1 & Computation(s2,k).a = s.a - 1 &
  Computation(s2,k).intloc 0 = 1 &
  (for b being read-write Int-Location st b <> a holds
  Computation(s2,k).b = IExec(I,s).b) &
  (for f being FinSeq-Location holds Computation(s2,k).f = IExec(I,s).f) &
  IC Computation(s2,k) = insloc 0 &
  for n being Element of NAT st n <= k holds IC  Computation( s2,n) in
  dom loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0))
proof
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  assume
A2: s.a > 0;
  set P = if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0));
  reconsider I1 = I ';' SubFrom(a,intloc 0) as InitHalting Program of SCM+FSA;
  set s1 = s +* Initialized P;
  take s2 = s +* Initialized loop P;
  take k = LifeSpan s1 + 1;
  thus s2 = s +* Initialized (loop if=0(a,Goto insloc 2,
  I ';' SubFrom(a,intloc 0))) &
  k = LifeSpan (s +* Initialized (if=0(a,Goto insloc 2,
  I ';' SubFrom(a,intloc 0)))) + 1;
  I1 is_closed_onInit s & I1 is_halting_onInit s by Th35,Th36;
  then
A3: P is_closed_onInit s & P is_halting_onInit s by A2,Th45;
  Computation(s2,LifeSpan s1+1) = Following Computation(s2,LifeSpan s1)
  by AMI_1:14
    .= Exec(CurInstr Computation(s2,LifeSpan s1),Computation(s2,LifeSpan s1));
  then
A4: Computation(s2,LifeSpan s1+1) =
Exec(goto insloc 0,Computation(s2,LifeSpan s1)) by A3,Th71;
  then
A5: IC Computation(s2,LifeSpan s1+1) = insloc 0 by SCMFSA_2:95;
A6: Initialize s +* Initialized P = s +* Initialized P by SCMFSA8A:8;
  set Is = Initialize s +* Initialized P;
A7: now
    let b be Int-Location;
    Computation(s1,LifeSpan s1),Computation(s2,LifeSpan s1) equal_outside A &
    Computation(s2,LifeSpan s1+1).b = Computation(s2,LifeSpan s1).b
    by A3,A4,Th68,SCMFSA_2:95;
    hence Computation(s2,LifeSpan s1+1).b =
    Computation( Is,LifeSpan Is).b by A6,SCMFSA6A:30;
  end;
  Initialize Initialize s = Initialize s by SCMFSA8C:15;
  then
A8: Is = Initialize s +* (P +* Start-At insloc 0) by SCMFSA8A:13;
A9: I1 is_halting_onInit s by Th36;
  then
A10: I1 is_halting_on Initialize s by Th41;
  I1 is_closed_onInit s & I1 is_halting_onInit s by Th35,Th36;
  then P is_halting_onInit s & P is_closed_onInit s by A2,Th45;
  then
A11: P is_halting_on Initialize s & P is_closed_on Initialize s by Th40,Th41;
A12: now
    thus Computation(s2,LifeSpan s1+1).a =  Computation( Is,LifeSpan Is).a
    by A7
      .= IExec(P,s).a by A8,A11,SCMFSA8C:87;
A13: P is good by SCMFSA8C:115;
    thus Computation(s2,LifeSpan s1+1).intloc 0
    =  Computation( Is,LifeSpan Is).intloc 0 by A7
      .= 1 by A8,A11,A13,SCMFSA8C:96;
  end;
  s.a <> 0 & I1 is_closed_onInit s by A2,Th35;
  then
A14: IExec(P,s) = IExec(I1,s) +* Start-At insloc (card Goto
  insloc 2 + card I1 + 3) by A9,Th46;
  then IExec(P,s).a = IExec(I1,s).a by SCMFSA_3:11;
  hence Computation(s2,k).a
  =  Computation( (Initialize s +* (I1 +* Start-At insloc 0)),
  (LifeSpan (Initialize s +* (I1 +* Start-At insloc 0)))).a
  by A10,A12,SCMFSA8C:87
    .= s.a - 1 by A1,Th64;
  thus Computation(s2,k).intloc 0 = 1 by A12;
  hereby
    let b be read-write Int-Location;
    assume
A15: b <> a;
    thus Computation(s2,k).b =  Computation( Is,LifeSpan Is).b by A7
      .= IExec(P,s).b by A8,A11,SCMFSA8C:87
      .= IExec(I1,s).b by A14,SCMFSA_3:11
      .= Exec(SubFrom(a,intloc 0),IExec(I,s)).b by Th33
      .= IExec(I,s).b by A15,SCMFSA_2:91;
  end;
  hereby
    let f be FinSeq-Location;
    Computation(s1,LifeSpan s1),Computation(s2,LifeSpan s1)
     equal_outside A &
    Computation(s2,LifeSpan s1+1).f = Computation(s2,LifeSpan s1).f
    by A3,A4,Th68,SCMFSA_2:95;
    hence Computation(s2,k).f =  Computation( Is,LifeSpan Is).f by A6,
SCMFSA6A:31
      .= IExec(P,s).f by A8,A11,SCMFSA8C:87
      .= IExec(I1,s).f by A14,SCMFSA_3:12
      .= Exec(SubFrom(a,intloc 0),IExec(I,s)).f by Th34
      .= IExec(I,s).f by SCMFSA_2:91;
  end;
  thus IC Computation(s2,k) = insloc 0 by A4,SCMFSA_2:95;
  hereby
    let n be Element of NAT;
    assume
A16: n <= k;
    per cases by A16,NAT_1:8;
    suppose
A17:  n <= LifeSpan s1;
      I1 is_closed_onInit s & I1 is_halting_onInit s by Th35,Th36;
      then
A18:  P is_closed_onInit s & P is_halting_onInit s by A2,Th45;
      then Computation(s1,n),Computation(s2,n) equal_outside A by A17,Th68;
      then
A19:  IC Computation(s2,n) = IC Computation(s1,n) by SCMFSA8A:6;
      IC Computation(s1,n) in dom P by A18,Def4;
      hence IC  Computation( s2,n) in dom loop P by A19,FUNCT_4:105;
    end;
    suppose
A20:  n = LifeSpan s1 + 1;
A21:  card loop P = card dom loop P by PRE_CIRC:21
        .= card dom P by FUNCT_4:105
        .= card P by PRE_CIRC:21;
      card P = card Goto insloc 2 + card I1 + 4 by SCMFSA8B:14
        .= card I1 + 1 + 4 by SCMFSA8A:29
        .= card I1 + 3 + 2;
      hence IC  Computation( s2,n) in dom loop P by A5,A20,A21,SCMFSA6A:15;
    end;
  end;
end;

theorem Th78: ::T1
  for s being State of SCM+FSA, I being good InitHalting Program of SCM+FSA,
  a being read-write Int-Location st s.intloc 0 = 1 & s.a <= 0 holds
  DataPart IExec(Times(a,I),s) = DataPart s
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.intloc 0 = 1;
  assume s.a <= 0;
  then
A2: (Initialize s).a <= 0 by SCMFSA6C:3;
  set P = if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0));
  set s0 = Initialize s;
A4: Stop SCM+FSA is_closed_on Initialize s &
  Stop SCM+FSA is_halting_on Initialize s by SCMFSA7B:24,25;
  then
A5: Times(a,I) is_closed_on Initialize s &
  Times(a,I) is_halting_on Initialize s by A2,SCMFSA8B:24;
B6:  Stop SCM+FSA is_closed_on s0 & Stop SCM+FSA is_halting_on s0
  by SCMFSA7B:24,25;
A7: s0.intloc 0 = 1 & (for a being read-write Int-Location holds s0.a = s.a) &
  for f being FinSeq-Location holds s0.f = s.f by SCMFSA6C:3;
  then
A8: DataPart IExec(Times(a,I),s)= DataPart IExec(Times(a,I),s0)
            by A5,SCMFSA8C:45
    .= DataPart IExec(Stop SCM+FSA ';' Stop SCM+FSA,s0)
          by A2,B6,A7,SCMFSA8A:37,SCMFSA8C:73;
A9: DataPart IExec(Stop SCM+FSA,s0)
  = DataPart(Initialize s0 +* Start-At insloc 0) by SCMFSA8C:38
    .= DataPart(Initialize s +* Start-At insloc 0) by SCMFSA8C:15
    .= DataPart s0 by SCMFSA8A:10;
  IExec(Stop SCM+FSA ';' Stop SCM+FSA,s0)
  = IExec(Stop SCM+FSA,IExec(Stop SCM+FSA,s0)) +*
  Start-At (IC IExec(Stop SCM+FSA,IExec(Stop SCM+FSA,s0)) +
  card Stop SCM+FSA) by SCMFSA6B:44;
  hence DataPart IExec(Times(a,I),s)
  = DataPart IExec(Stop SCM+FSA,IExec(Stop SCM+FSA,s0)) by A8,SCMFSA8A:10
    .= DataPart IExec(Stop SCM+FSA,s0) by A4,A7,A9,SCMFSA8C:46
    .= DataPart s by A1,A9,SCMFSA8C:27;
end;

theorem Th79: ::T2
  for s being State of SCM+FSA, I being good InitHalting Program of SCM+FSA,
  a being read-write Int-Location st I does_not_destroy a & s.a > 0 holds
  IExec(I ';' SubFrom(a,intloc 0),s).a = s.a - 1 &
  DataPart IExec(Times(a,I),s) =
  DataPart IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s))
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  assume
A2: s.a > 0;
  set I1 = I ';' SubFrom(a,intloc 0);
  set ss = IExec(I1,s);
  set s0 = Initialize s;
  set ss0 = Initialize ss;
  set P = if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0));
  set s21 = s0 +* (loop P ';' Stop SCM+FSA +* Start-At insloc 0);
  set s31 = ss0 +* (loop P ';' Stop SCM+FSA +* Start-At insloc 0);
A4: s0.intloc 0 = 1 & s0.a > 0 by A2,SCMFSA6C:3;
  then consider s2 be State of SCM+FSA, k be Element of NAT such that
A5: s2 = s0 +* Initialized loop P and
  k = LifeSpan (s0 +* Initialized P) + 1 and
A6: Computation(s2,k).a = s0.a - 1 and
A7: Computation(s2,k).intloc 0 = 1 and
A8: (for b being read-write Int-Location st b <> a holds
  Computation(s2,k).b = IExec(I,s0).b) and
A9: (for f being FinSeq-Location holds Computation(s2,k).f = IExec(I,s0).f)
  and
A10: IC Computation(s2,k) = insloc 0 and
A11: for n being Element of NAT st n <= k holds
  IC  Computation( s2,n) in dom loop P by A1,Th77;
A12: s2= Initialize s0 +* (loop P +* Start-At insloc 0) by A5,SCMFSA8A:13
    .= s0 +* (loop P +* Start-At insloc 0) by SCMFSA8C:15;
thus
A13: now thus ss.a = Exec(SubFrom(a,intloc 0),IExec(I,s)).a by Th33
      .= IExec(I,s).a - IExec(I,s).intloc 0 by SCMFSA_2:91
      .= IExec(I,s).a - 1 by Th17
      .= s0.a - 1 by A1,Th63
      .= s.a - 1 by SCMFSA6C:3;
  end;
A14: Directed loop P = loop P by SCMFSA6A:63;
  then
A15: Directed loop P is_pseudo-closed_on s0 by A1,A4,Th73;
A16: DataPart IExec(Times(a,I),s0)
 = DataPart IExec(loop P ';' Stop SCM+FSA,s0)
  by A1,A4,A14,Th73,SCMFSA8C:69;
  reconsider J3 = Macro SubFrom(a,intloc 0) as good Program of SCM+FSA
  by SCMFSA7B:14,SCMFSA8C:99;
A17: I1 = I ';' J3;
  I1 is_halting_onInit s & I1 is_closed_onInit s by Th35,Th36;
  then
A18: I1 is_halting_on Initialize s & I1 is_closed_on Initialize s
  by Th40,Th41;
  then
A19: ss.intloc 0 = 1 by A17,SCMFSA8C:96;
A20: now
    let b be Int-Location;
    per cases;
    suppose b = intloc 0;
      hence Computation(s2,k).b = IExec(I1,s).b by A7,A17,A18,SCMFSA8C:96;
    end;
    suppose b = a;
      hence Computation(s2,k).b = IExec(I1,s).b by A6,A13,SCMFSA6C:3;
    end;
    suppose
A21:  b <> a & b <> intloc 0;
      then reconsider bb = b as read-write Int-Location by SF_MASTR:def 5;
      thus Computation(s2,k).b = IExec(I,s0).bb by A8,A21
        .= Exec(SubFrom(a,intloc 0),IExec(I,s0)).b by A21,SCMFSA_2:91
        .= IExec(I1,s0).b by Th33
        .= IExec(I1,s).b by SCMFSA8C:17;
    end;
  end;
  now
    let f be FinSeq-Location;
    thus Computation(s2,k).f = IExec(I,s0).f by A9
      .= Exec(SubFrom(a,intloc 0),IExec(I,s0)).f by SCMFSA_2:91
      .= IExec(I1,s0).f by Th34
      .= IExec(I1,s).f by SCMFSA8C:17;
  end;
  then
A22: DataPart Computation(s2,k) = DataPart ss by A20,SCMFSA6A:38;
A23: loop P is_pseudo-closed_on s0 by A1,A4,Th73;
  insloc 0 in dom P by SCMFSA8C:54;
  then
A24: insloc 0 in dom loop P by FUNCT_4:105;
  per cases;
  suppose
A25: ss.a = 0;
    loop P c= loop P +* Start-At insloc 0 by SCMFSA8A:9;
    then
A26: dom loop P c= dom (loop P +* Start-At insloc 0) by GRFUNC_1:8;
A27: Computation(s2,k).insloc 0 = s2.insloc 0 by AMI_1:54
      .= (loop P +* Start-At insloc 0).insloc 0 by A12,A24,A26,FUNCT_4:14
      .= (loop P).insloc 0 by A24,SCMFSA6B:7;
A28: Computation(s2,k).a = 0 by A6,A13,A25,SCMFSA6C:3;
A29: Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
      .= Exec(Computation(s2,k).insloc 0,Computation(s2,k)) by A10;
A30: P.insloc 0 = a =0_goto insloc (card I1 + 3) by SCMFSA8C:55;
    then P.insloc 0 <> halt SCM+FSA & insloc 0 in dom P
    by SCMFSA8C:54,SCMFSA_2:48,124;
    then
A31: Computation(s2,k).insloc 0 = a =0_goto insloc (card I1 + 3)
by A27,A30,FUNCT_4:111;
    then InsCode Computation(s2,k).insloc 0 = 7 by SCMFSA_2:48;
    then InsCode Computation(s2,k).insloc 0 in {0,6,7,8} by ENUMSET1:def 2;
    then
A32: DataPart Computation(s2,k) = DataPart Computation(s2,k+1)
 by A29,SCMFSA8C:32;
A33: IC Computation(s2,k+1) = insloc (card I1 + 3) by A28,A29,A31,SCMFSA_2:96;
A34: card I1 + (3 + 2) = card I1 + 1 + 4
      .= card Goto insloc 2 + card I1 + 4 by SCMFSA8A:29
      .= card P by SCMFSA8B:14
      .= card dom P by PRE_CIRC:21
      .= card dom loop P by FUNCT_4:105
      .= card loop P by PRE_CIRC:21;
    then card I1 + 3 + 0 < card loop P by XREAL_1:8;
    then
A35: insloc (card I1 + 3) in dom loop P by SCMFSA6A:15;
    loop P c= loop P +* Start-At insloc 0 by SCMFSA8A:9;
    then
A36: dom loop P c= dom (loop P +* Start-At insloc 0) by GRFUNC_1:8;
A37: Computation(s2,k+1).insloc (card I1 + 3) = s2.insloc (card I1 + 3)
by AMI_1:54
      .= (loop P +* Start-At insloc 0).insloc (card I1 + 3) by A12,A35,A36,
FUNCT_4:14
      .= (loop P).insloc (card I1 + 3) by A35,SCMFSA6B:7;
A38: P.insloc (card I1 + 3) = goto insloc (card I1 + 5) by SCMFSA8C:65;
    then P.insloc (card I1 + 3) <> halt SCM+FSA by SCMFSA_2:47,124;  ::6
    then
A39: Computation(s2,k+1).insloc (card I1 + 3) = goto insloc (card I1 + 5)
    by A37,A38,FUNCT_4:111;
A40: Computation(s2,k+(1+1)) = Computation(s2,k+1+1)
      .= Following Computation(s2,k+1) by AMI_1:14
      .= Exec(Computation(s2,k+1).insloc (card I1 + 3),Computation(s2,k+1))
      by A28,A29,A31,SCMFSA_2:96;
    then
A41: IC Computation(s2,k+2) = insloc (card I1 + 5) by A39,SCMFSA_2:95
      .= insloc card ProgramPart loop P by A34,AMI_1:105;
    now
      let n be Element of NAT;
      assume
A42:  not IC  Computation( s2,n) in dom loop P;
      then k < n by A11;
      then k + 1 <= n by INT_1:20;
      then k + 1 < n by A33,A35,A42,XXREAL_0:1;
      then k + 1 + 1 <= n by INT_1:20;
      hence k + (1 + 1) <= n;
    end;
    then
A43: k + 2 = pseudo-LifeSpan(s0,loop P) by A12,A23,A41,SCMFSA8A:def 5;
    InsCode Computation(s2,k+1).insloc (card I1 + 3) = 6 by A39,SCMFSA_2:47;
    then InsCode Computation(s2,k+1).insloc (card I1 + 3) in {0,6,7,8}
    by ENUMSET1:def 2;
    then
A44: DataPart Computation(s2,k) = DataPart Computation(s2,k+2)
 by A32,A40,SCMFSA8C:32;
    thus DataPart IExec(Times(a,I),s)
       = DataPart IExec(Times(a,I),s0) by SCMFSA8C:17
      .= DataPart IExec(loop P ';' Stop SCM+FSA,s) by A16,SCMFSA8C:17
   .= DataPart(Result (s +* Initialized (loop P ';' Stop SCM+FSA)) +* s | A)
    by SCMFSA6B:def 1
      .= DataPart(Result s21 +* s | A) by SCMFSA8A:13
      .= DataPart (Result s21) by SCMFSA8C:35
      .= DataPart IExec(I1,s) by A1,A4,A12,A14,A22,A43,A44,Th73,SCMFSA8C:59
      .= DataPart IExec(Times(a,I),IExec(I1,s)) by A19,A25,Th78;
  end;
  suppose
A45: ss.a <> 0;
    s.a >= 0 + 1 by A2,INT_1:20;
    then
A46: ss.intloc 0 = 1 & ss.a > 0 by A13,A17,A18,A45,SCMFSA8C:96,XREAL_1:21;
A47: k < pseudo-LifeSpan(s0,loop P) by A11,A12,A1,A4,Th73,SCMFSA8C:2;
    then
A48:  DataPart Computation( s21,k) = DataPart ss
 by A12,A14,A15,A22,SCMFSA8C:58;
A49: now
A50:  DataPart ss0 = DataPart s31 by SCMFSA8A:11;
      hereby
        let a be Int-Location;
        per cases;
        suppose
A51:      a = intloc 0;
          thus  Computation( s21,k).a = ss.a by A48,SCMFSA6A:38
            .= 1 by A51,Th17
            .= ss0.a by A51,SCMFSA6C:3
            .= s31.a by A50,SCMFSA6A:38;
        end;
        suppose a <> intloc 0;
          then
A52:      a is read-write Int-Location by SF_MASTR:def 5;
          thus  Computation( s21,k).a = ss.a by A48,SCMFSA6A:38
            .= ss0.a by A52,SCMFSA6C:3
            .= s31.a by A50,SCMFSA6A:38;
        end;
      end;
      let f be FinSeq-Location;
      thus  Computation( s21,k).f = ss.f by A48,SCMFSA6A:38
        .= ss0.f by SCMFSA6C:3
        .= s31.f by A50,SCMFSA6A:38;
    end;
    Directed loop P = loop P by SCMFSA6A:63;
    then DataPart s0 = DataPart s21 &
    Directed loop P is_pseudo-closed_on s0 by A1,A4,Th73,SCMFSA8A:11;
    then Directed loop P is_pseudo-closed_on s21 by SCMFSA8C:52;
    then
A53: loop P ';' Stop SCM+FSA +* Start-At insloc 0 c= s21 &
    loop P ';' Stop SCM+FSA +* Start-At insloc 0 c= s31 &
    loop P ';' Stop SCM+FSA is_closed_on s21 &
    loop P ';' Stop SCM+FSA is_halting_on s21 by FUNCT_4:26,SCMFSA8C:58;
    IC  Computation( s21,k) = IC Computation(s2,k)
    by A12,A14,A15,A47,SCMFSA8C:58
      .= IC (ss0 +* (loop P ';' Stop SCM+FSA) +* Start-At insloc 0) by A10,
AMI_1:111
      .= IC s31 by FUNCT_4:15;
    then
A54:  Computation( s21,k),s31 equal_outside A by A49,SCMFSA6A:28;
    DataPart IExec(loop P ';' Stop SCM+FSA,s0)
    = DataPart IExec(loop P ';' Stop SCM+FSA,s) by SCMFSA8C:17
      .= DataPart(Result (s +* Initialized (loop P ';' Stop SCM+FSA)) +* s | A)
    by SCMFSA6B:def 1
      .= DataPart(Result s21 +* s | A) by SCMFSA8A:13
      .= DataPart(Result s21) by SCMFSA8C:35
      .= DataPart(Result s31) by A53,A54,SCMFSA6A:39,SCMFSA8C:103
      .= DataPart(Result s31 +* ss | A) by SCMFSA8C:35
      .= DataPart(Result(ss +* Initialized (loop P ';' Stop SCM+FSA)) +* ss|A)
    by SCMFSA8A:13
      .= DataPart IExec(loop P ';' Stop SCM+FSA,IExec(I1,s)) by SCMFSA6B:def 1
      .= DataPart IExec(Times(a,I),IExec(I1,s)) by A1,A14,A46,Th73,SCMFSA8C:69;
    hence DataPart IExec(Times(a,I),s) =
          DataPart IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s))
 by A16,SCMFSA8C:17;
  end;
end;

theorem    ::T03
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA,
  f be FinSeq-Location,a be read-write Int-Location st s.a <= 0 holds
  IExec(Times(a,I),s).f=s.f
proof
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA,
  f be FinSeq-Location,a be read-write Int-Location;
  assume
A1: s.a <= 0;
  set s0 = Initialize s;
  set D= Int-Locations \/ FinSeq-Locations;
A2: s0.a=s.a by SCMFSA6C:3;
A3: s0.(intloc 0)=1 by SCMFSA6C:3;
A4: DataPart IExec(Times(a,I),s) = DataPart IExec(Times(a,I),s0) by SCMFSA8C:17
    .= DataPart s0 by A1,A2,A3,Th78;
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A5: f in D by XBOOLE_0:def 3;
  hence IExec(Times(a,I),s).f= (DataPart s0).f by A4,FUNCT_1:72,SCMFSA_2:127
    .= s0.f by A5,FUNCT_1:72,SCMFSA_2:127
    .= s.f by SCMFSA6C:3;
end;

theorem    ::T04
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA,
  b be Int-Location,a be read-write Int-Location st s.a <= 0 holds
  IExec(Times(a,I),s).b=(Initialize s).b
proof
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA,
  b be Int-Location,a be read-write Int-Location;
  assume
A1: s.a <= 0;
  set s0 = Initialize s;
  set D= Int-Locations \/ FinSeq-Locations;
A2: s0.a=s.a by SCMFSA6C:3;
A3: s0.(intloc 0)=1 by SCMFSA6C:3;
A4: DataPart IExec(Times(a,I),s) = DataPart IExec(Times(a,I),s0) by SCMFSA8C:17
    .= DataPart s0 by A1,A2,A3,Th78;
  b in Int-Locations by SCMFSA_2:9;
  then
A5: b in D by XBOOLE_0:def 3;
  hence IExec(Times(a,I),s).b= (DataPart s0).b by A4,FUNCT_1:72,SCMFSA_2:127
    .= s0.b by A5,FUNCT_1:72,SCMFSA_2:127;
end;

theorem    ::T05
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA,
  f be FinSeq-Location,a be read-write Int-Location st
  I does_not_destroy a & s.a > 0 holds IExec(Times(a,I),s).f
  =IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s)).f
proof
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA,
  f be FinSeq-Location,a be read-write Int-Location;
  assume
A1: I does_not_destroy a & s.a > 0;
  set D= Int-Locations \/ FinSeq-Locations;
  set IT=IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s));
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A2: f in D by XBOOLE_0:def 3;
  hence IExec(Times(a,I),s).f=(DataPart IExec(Times(a,I),s)).f
   by FUNCT_1:72,SCMFSA_2:127
    .=(DataPart IT).f by A1,Th79
    .= IT.f by A2,FUNCT_1:72,SCMFSA_2:127;
end;

theorem    ::T06
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA,
  b be Int-Location,a be read-write Int-Location st
  I does_not_destroy a & s.a > 0 holds IExec(Times(a,I),s).b
  =IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s)).b
proof
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA,
  b be Int-Location,a be read-write Int-Location;
  assume
A1: I does_not_destroy a & s.a > 0;
  set D= Int-Locations \/ FinSeq-Locations;
  set IT=IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s));
  b in Int-Locations by SCMFSA_2:9;
  then
A2: b in D by XBOOLE_0:def 3;
  hence IExec(Times(a,I),s).b=(DataPart IExec(Times(a,I),s)).b
   by FUNCT_1:72,SCMFSA_2:127
    .=(DataPart IT).b by A1,Th79
    .= IT.b by A2,FUNCT_1:72,SCMFSA_2:127;
end;

definition
  let i be Instruction of SCM+FSA;
  attr i is good means
  :Def6:  ::defB1
  i does_not_destroy intloc 0;
end;

registration
  cluster parahalting good Instruction of SCM+FSA;
  existence
  proof
    take x=halt SCM+FSA;
    thus x is parahalting;
    x does_not_destroy intloc 0 by SCMFSA7B:11;
    hence thesis by Def6;
  end;
end;

registration
  let i be good Instruction of SCM+FSA, J be good Program of SCM+FSA;
  cluster i ';' J -> good;
  coherence
  proof
    i does_not_destroy intloc 0 by Def6;
    then reconsider Mi=Macro i as good Program of SCM+FSA by SCMFSA8C:99;
    Mi ';' J is good;
    hence thesis;
  end;
  cluster J ';' i -> good;
  coherence
  proof
    i does_not_destroy intloc 0 by Def6;
    then reconsider Mi=Macro i as good Program of SCM+FSA by SCMFSA8C:99;
    J ';' Mi is good;
    hence thesis;
  end;
end;

registration
  let i,j be good Instruction of SCM+FSA;
  cluster i ';' j -> good;
  coherence
  proof
    i does_not_destroy intloc 0 by Def6;
    then reconsider Mi=Macro i as good Program of SCM+FSA by SCMFSA8C:99;
    j does_not_destroy intloc 0 by Def6;
    then reconsider Mj=Macro j as good Program of SCM+FSA by SCMFSA8C:99;
    Mi ';' Mj is good;
    hence thesis;
  end;
end;

registration
  let a be read-write Int-Location,b be Int-Location;
  cluster a := b -> good;
  coherence
  proof
    a := b does_not_destroy intloc 0 by SCMFSA7B:12;
    hence thesis by Def6;
  end;
  cluster SubFrom(a,b) -> good;
  coherence
  proof
    SubFrom(a,b) does_not_destroy intloc 0 by SCMFSA7B:14;
    hence thesis by Def6;
  end;
end;

registration
  let a be read-write Int-Location,b be Int-Location,f be FinSeq-Location;
  cluster a:=(f,b) -> good;
  coherence
  proof
    a:=(f,b) does_not_destroy intloc 0 by SCMFSA7B:20;
    hence thesis by Def6;
  end;
end;

registration
  let a,b be Int-Location,f be FinSeq-Location;
  cluster (f,a):=b -> good;
  coherence
  proof
    (f,a):=b does_not_destroy intloc 0 by SCMFSA7B:21;
    hence thesis by Def6;
  end;
end;

registration
  let a be read-write Int-Location,f be FinSeq-Location;
  cluster a:=len f -> good;
  coherence
  proof
    a:=len f does_not_destroy intloc 0 by SCMFSA7B:22;
    hence thesis by Def6;
  end;
end;

registration
  let n be Element of NAT;
  cluster intloc (n+1) -> read-write;
  coherence
  proof
    intloc (n+1) <> intloc 0 by AMI_3:52;
    hence thesis by SF_MASTR:def 5;
  end;
end;

