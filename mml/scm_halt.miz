:: Initialization Halting Concepts and Their Basic Properties of SCM+FSA
::  by JingChao Chen and Yatsuka Nakamura
::
:: Received June 17, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMFSA_2, FSM_1, SCMFSA6A, TARSKI,
      CIRCUIT2, RELAT_1, GLIB_000, FUNCT_1, CARD_1, FUNCOP_1, FUNCT_4,
      XBOOLE_0, SCMFSA6B, NAT_1, XXREAL_0, ARYTM_3, AMI_3, FUNCT_7, SF_MASTR,
      GRAPHSP, MSUALG_1, AMISTD_2, TURING_1, STRUCT_0, VALUED_1,
      SCMFSA6C, SCMFSA7B, UNIALG_2, SCMFSA8B, ARYTM_1, SCMFSA8C, SCMFSA8A,
      SCM_HALT, PARTFUN1, SCMNORM, RELOC, PBOOLE, COMPOS_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, RELAT_1, FINSEQ_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7, PBOOLE,
      VALUED_1,
      STRUCT_0, COMPOS_1, EXTPRO_1, AMI_1, AMISTD_2, SCMFSA_2, FUNCOP_1,
      SCMFSA6B, SCMFSA6A, SF_MASTR, SCMFSA8A, SCMFSA8B,
      SFMASTR1, SCMFSA8C, SCMFSA7B,
      NAT_D, SCMFSA_3, SCMFSA6C, XXREAL_0;
 constructors SFMASTR1, DOMAIN_1, XXREAL_0, REAL_1, SCM_1, SCMFSA_3, SCMFSA6A,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA8C, AMISTD_1,
      AMISTD_2, NAT_D, RELSET_1, VALUED_1, SCMFSA7B, AMI_1, SCMFSA_9,
      AMISTD_5, PBOOLE, PRE_POLY;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SCMFSA8C, SCMFSA_9, ORDINAL1, AMI_1, RELAT_1, SCMFSA10,
      AMISTD_2, COMPOS_1, SFMASTR1, EXTPRO_1, SCMFSA_4, PBOOLE, FUNCT_4,
      FUNCT_7, PRE_POLY, STRUCT_0, FUNCOP_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_1, XBOOLE_0, SCMFSA_2,
             SCMFSA8C, SCMFSA6A, AMISTD_2;
 theorems SF_MASTR, FUNCT_1, FUNCT_7, FUNCOP_1, RELAT_1, AMI_1, SCMFSA6A,
      FUNCT_4, ENUMSET1, AMI_3, NAT_1, TARSKI, INT_1, GRFUNC_1, SCMFSA_2,
      SCMFSA6B, SCMFSA7B, SCMFSA8B, SCMFSA8A, SCMFSA8C, SCMFSA_4,
      LATTICE2, SCMFSA_3, SCMFSA6C, CARD_1, XBOOLE_0, XBOOLE_1, XREAL_1,
      ORDINAL1, XXREAL_0, VALUED_1, XREAL_0, PBOOLE, PARTFUN1, AFINSQ_1,
      FINSEQ_4, SCMFSA10, COMPOS_1, SFMASTR1, EXTPRO_1, AMISTD_2, AMISTD_5;
 schemes NAT_1;

begin

reserve m,n for Element of NAT,
  I for Program of SCM+FSA,
  s,s1,s2 for State of SCM+FSA,
  a for Int-Location,
  f for FinSeq-Location,
  p,p1,p2 for (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;

set SA0 = Start-At(0,SCM+FSA);

definition
  let I be Program of SCM+FSA;
  attr I is InitClosed means
  :Def1:
  for s being State of SCM+FSA,
      P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
       st I c= P
   for n being Element of NAT st Initialized I c= s
   holds IC Comput(P,s,n) in dom I;
  attr I is InitHalting means
  :Def2:
  Initialized I is halting;
  attr I is keepInt0_1 means
  :Def3:
  for s being State of SCM+FSA st Initialized I c= s
  for p st I c= p
  for k being Element of NAT holds (Comput(p,s,k)).intloc 0 = 1;
end;

theorem Th1:
  for x being set,i,m,n being Element of NAT st x in dom (((intloc
  i) .--> m) +* Start-At(n,SCM+FSA)) holds x=intloc i or x=IC SCM+FSA
proof
  let x be set,i,m,n be Element of NAT;
  set iS = ((intloc i) .--> m) +* Start-At(n,SCM+FSA);
  dom ((intloc i) .--> m) ={intloc i } & dom(Start-At(n,SCM+FSA)) = {IC
  SCM+FSA} by FUNCOP_1:19;
  then
A1: dom iS ={intloc i} \/ {IC SCM+FSA} by FUNCT_4:def 1;
  assume x in dom iS;
  then x in{intloc i} or x in {IC SCM+FSA} by A1,XBOOLE_0:def 3;
  hence thesis by TARSKI:def 1;
end;

theorem Th2:
  for I being Program of SCM+FSA,i,m,n being Element of NAT holds
  dom I misses dom (((intloc i) .--> m) +* Start-At(n,SCM+FSA))
proof
  let I be Program of SCM+FSA,i,m,n be Element of NAT;
  set iS = ((intloc i) .--> m) +* Start-At(n,SCM+FSA);
  assume dom I /\ dom iS <> {};
  then consider x being set such that
A1: x in dom I /\ dom iS by XBOOLE_0:def 1;
A2: x in dom iS by A1,XBOOLE_0:def 4;
A3: x in dom I by A1,XBOOLE_0:def 4;
  dom I c= NAT by RELAT_1:def 18;
  then reconsider x as Element of NAT by A3;
  per cases by A2,Th1;
  suppose
    x = intloc i;
    hence contradiction by SCMFSA_2:84;
  end;
  suppose
    x = IC SCM+FSA;
    hence contradiction by COMPOS_1:3;
  end;
end;

set iS = Initialize ((intloc 0) .--> 1);

canceled;

theorem Th4:
  Macro halt SCM+FSA is InitHalting
proof
  let s be State of SCM+FSA;
  set m = Macro halt SCM+FSA;
  set m1 = Initialized m;
  assume
A1: m1 c= s;
  let p be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  assume
A2: ProgramPart m1 c= p;
A3: ProgramPart m1 = m by SCMFSA6A:33;
A4: m1 = Initialize(m +* ((intloc 0) .--> 1)) by FUNCT_4:15;
  dom(SA0) = {IC SCM+FSA} by FUNCOP_1:19;
  then
A5: IC SCM+FSA in dom (SA0) by TARSKI:def 1;
  then
A6: IC SCM+FSA in dom m1 by FUNCT_4:13,A4;
A7: IC m1 = SA0.IC SCM+FSA by A5,FUNCT_4:14,A4
    .=  0 by FUNCOP_1:87;
  take 0;
     IC Comput(p,s,0) in NAT;
    hence IC Comput(p,s,0) in dom p by PARTFUN1:def 4;
A8: m. 0 = halt SCM+FSA & m c= m1 by FUNCT_4:66,SCMFSA6A:26;
  dom m = { 0, 1} by FUNCT_4:65;
  then
A9:  0 in dom m by TARSKI:def 2;
A10:  p/.IC s = p.IC s by PBOOLE:158;
  CurInstr(p,Comput(p,s,0))
   = CurInstr(p,s) by EXTPRO_1:3
    .= p.IC m1 by A1,A6,A10,GRFUNC_1:8
    .= m. 0 by A7,GRFUNC_1:8,A2,A3,A9
    .= halt SCM+FSA by A8;
    hence thesis;
end;

registration
  cluster InitHalting Program of SCM+FSA;
  existence by Th4;
end;

theorem Th5:
  for I being InitHalting Program of SCM+FSA st
   Initialized I c= s & I c= p
  holds p halts_on s
proof
  let I be InitHalting Program of SCM+FSA;
  assume
A1: Initialized I c= s;
  assume
A2: I c= p;
A3: ProgramPart Initialized I = I by SCMFSA6A:33;
  Initialized I is halting by Def2;
  hence thesis by A1,EXTPRO_1:def 10,A2,A3;
end;

theorem Th6:
  Initialize I c= Initialized I
proof
  Initialized I = Initialize(I +* ((intloc 0) .--> 1)) by FUNCT_4:15;
  then SA0 c= Initialized I & I c= Initialized I by FUNCT_4:26,SCMFSA6A:26;
  then
A1: I \/ SA0 c= Initialized I by XBOOLE_1:8;
  Initialize I c= I \/ SA0 by FUNCT_4:30;
  hence thesis by A1,XBOOLE_1:1;
end;

theorem Th7:
  for I being Program of SCM+FSA,s being State of SCM+FSA st
  Initialized I c= s holds s.intloc 0 =1
proof
  let I be Program of SCM+FSA,s be State of SCM+FSA;
A1: intloc 0 in dom Initialized I & (Initialized I).intloc 0 = 1 by SCMFSA6A:45
,46;
  assume Initialized I c= s;
  hence thesis by A1,GRFUNC_1:8;
end;

registration
  cluster paraclosed -> InitClosed Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
A1: I is paraclosed;
    let s be State of SCM+FSA,
      P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT such that
A2: I c= P;
   let n being Element of NAT such that
A3: Initialized I c= s;
    Initialize I c= Initialized I by Th6;
    then Initialize I c= s by A3,XBOOLE_1:1;
   hence IC Comput(P,s,n) in dom I by A1,SCMFSA6B:def 2,A2;
  end;
end;

registration
  cluster parahalting -> InitHalting Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume I is parahalting;
    then reconsider I as parahalting Program of SCM+FSA;
    Initialized I is halting;
    hence thesis by Def2;
  end;
end;

registration
  cluster InitHalting -> InitClosed Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    set II = Initialized I;
    assume I is InitHalting;
    then
A1: II is halting by Def2;
    let s be State of SCM+FSA;
    let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
    such that
A2: I c= P;
    let n be Element of NAT;
    assume
A3: Initialized I c= s;
A4: ProgramPart Initialized I = I by SCMFSA6A:33;
    defpred X[Nat] means not IC Comput(P,s,$1) in dom I;
    assume not IC Comput(P,s,n) in dom I;
    then
A5: ex n be Nat st X[n];
    consider n be Nat such that
A6: X[n] and
A7: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A5);
    reconsider n as Element of NAT by ORDINAL1:def 13;
A8: for m st m < n holds IC(Comput(P,s,m)) in dom I by A7;
    set s2 = Comput(P,s,n),
        p2 = P,
        s0 = s +*(IC s2, goto IC s2),
        p0 = P +*(IC s2, goto IC s2),
        s1 = s2+*(IC s2,goto IC s2),
        p1 = P+*(IC s2,goto IC s2);
A9: ProgramPart s = ProgramPart s2 by AMI_1:123;
A10: ProgramPart Comput(p0,s0,n) = ProgramPart s0 by AMI_1:123
      .= s1|NAT by FUNCT_7:95,A9;
A11: s0,s equal_outside NAT by FUNCT_7:28,93;
A12: s2,s1 equal_outside NAT by FUNCT_7:93;
    II | NAT = I by SCMFSA6A:33;
    then dom I = dom II /\ NAT by RELAT_1:90;
    then
   not IC s2 in dom II by A6,XBOOLE_0:def 4;
    then
A13: II c= s0 by A3,FUNCT_7:91;
    not IC s2 in dom I by A6;
    then
A14:  I c= p0 by FUNCT_7:91,A2;
    then Comput(p0,s0,n),s2 equal_outside NAT by A11,A8,AMISTD_2:66,A2;
    then Comput(p0,s0,n),s1 equal_outside NAT by A12,FUNCT_7:29;
    then
A15: Comput(p0,s0,n) = s1 by FUNCT_7:92,A10;
A16: not p1 halts_on s1 by SCMFSA6B:20;
    p0 halts_on s0 by A1,A13,EXTPRO_1:def 10,A4,A14;
    then p0 halts_on s1 by A15,EXTPRO_1:22;
    hence contradiction by A16;
  end;
  cluster keepInt0_1 -> InitClosed Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
A17: I is keepInt0_1;
    set FI = FirstNotUsed(I);
    let s be State of SCM+FSA;
    let p be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
    such that
A18: I c= p;
    let n be Element of NAT;
    assume
A19: Initialized I c= s;
    defpred X[Nat] means not IC Comput(p,s,$1) in dom I;
    assume
   not IC Comput(p,s,n) in dom I;
    then
A20: ex n be Nat st X[n];
    consider n be Nat such that
A21: X[n] and
A22: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A20);
    reconsider n as Element of NAT by ORDINAL1:def 13;
    set s2 = Comput(p,s,n), s00 = s +*(IC s2, intloc 0 := FI),
        p2 = p,
        p00 = p +*(IC s2, intloc 0 := FI);
    set s0 = s00+* (FI, (s.intloc 0)+1),
        p0 = p00;
    reconsider s00 as State of SCM+FSA;
    reconsider s0 as State of SCM+FSA;
A23: dom I c= NAT by RELAT_1:def 18;
    not I is keepInt0_1
    proof
A24: not FI in dom I by A23,SCMFSA_2:84;
      FI <> IC SCM+FSA by SCMFSA_2:81;
      then
A25:  not FI in {IC SCM+FSA} by TARSKI:def 1;
      set s02 = Comput(p0,s0,n);
      set iIC={intloc 0} \/ {IC SCM+FSA};
      set IS = Initialized I;
      take s0;
A26:  dom IS = dom I \/ {intloc 0} \/ {IC SCM+FSA} by SCMFSA6A:43
        .= dom I \/ iIC by XBOOLE_1:4;
      FI in dom s00 by SCMFSA_2:66;
      then
A27:  s0.FI = (s.intloc 0)+1 by FUNCT_7:33;
      IC s2 <> intloc 0 by SCMFSA_2:84;
      then
A28:  not IC s2 in {intloc 0} by TARSKI:def 1;
A29:  ( not FI in UsedIntLoc I)& s.intloc 0=1 by A19,Th7,SF_MASTR:54;
      IC s2 <> IC SCM+FSA by COMPOS_1:3;
      then not IC s2 in {IC SCM+FSA} by TARSKI:def 1;
      then not IC s2 in iIC by A28,XBOOLE_0:def 3;
      then not IC s2 in dom IS by A21,A26,XBOOLE_0:def 3;
      then
A30:  IS c= s00 by A19,FUNCT_7:91;
      not FI in {intloc 0} by TARSKI:def 1;
      then not FI in iIC by A25,XBOOLE_0:def 3;
      then not FI in dom IS by A26,A24,XBOOLE_0:def 3;
      hence Initialized I c= s0 by A30,FUNCT_7:91;
      then
A31:  Initialize I c= s0 by SCMFSA6B:8;
      take p0;
       not IC s2 in dom I by A21;
      hence
A32:   I c= p0 by A18,FUNCT_7:91;
A33:  not IC s2 in UsedInt*Loc I
      proof
        assume not thesis;
        then IC s2 is FinSeq-Location by SCMFSA_2:12;
        hence contradiction by SCMFSA_2:85;
      end;
      not FI in UsedInt*Loc I
      proof
        assume not thesis;
        then FI is FinSeq-Location by SCMFSA_2:12;
        hence contradiction by SCMFSA_2:83;
      end;
      then
A34:  s0 | UsedInt*Loc I = s00 | UsedInt*Loc I by FUNCT_7:94
        .= s | UsedInt*Loc I by A33,FUNCT_7:94;
A35:  not IC s2 in UsedIntLoc I
      proof
        assume not thesis;
        then IC s2 is Int-Location by SCMFSA_2:11;
        hence contradiction by SCMFSA_2:84;
      end;
A36:  s0 | UsedIntLoc I = s00 | UsedIntLoc I by FUNCT_7:94,SF_MASTR:54
        .= s | UsedIntLoc I by A35,FUNCT_7:94;
A37:  Initialize I c= s & for m st m < n
        holds IC Comput(p,s,m) in dom I by A19,A22,SCMFSA6B:8;
      then
A38:  IC s02 = IC s2 by A31,A36,A34,SF_MASTR:73,A18,A32;
      take k = n+1;
      IC s2 in NAT;
      then
A39:  IC s2 in dom p by PARTFUN1:def 4;
A40:  p0.IC s2 = p00.IC s2
        .= intloc 0 := FI by FUNCT_7:33,A39;
A41:   CurInstr(p0,s02) = p0.IC s02 by PBOOLE:158
          .= intloc 0 := FI by A38,A40;
A42:  Comput(p0,s0,k) = Following(p0,s02) by EXTPRO_1:4
        .= Exec(intloc 0 := FI, s02) by A41;
      for m st m < n holds IC Comput(p0,s0,m) in dom I
       by A31,A37,A36,A34,SF_MASTR:73,A18,A32;
      then s02.FI = 1+1 by A31,A29,A27,SF_MASTR:69,A32;
      hence thesis by A42,SCMFSA_2:89;
    end;
    hence contradiction by A17;
  end;
  cluster keeping_0 -> keepInt0_1 Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
A43: I is keeping_0;
      let s be State of SCM+FSA;
      assume
A44:  Initialized I c= s;
      let p;
      assume
A45:   I c= p;
A46:  Initialize I c= Initialized I by SCMFSA8C:19;
      let k be Element of NAT;
A47:   Initialize I c= s by A44,A46,XBOOLE_1:1;
      s.intloc 0=1 by A44,Th7;
      hence
        (Comput(p,s,k)).intloc 0 = 1
        by A43,SCMFSA6B:def 4,A45,A47;
  end;
end;

theorem
  for I being InitHalting Program of SCM+FSA, a being read-write
  Int-Location holds not a in UsedIntLoc I implies (IExec(I,p,s)).a = s.a
proof
  let I be InitHalting Program of SCM+FSA, a be read-write Int-Location;
A1: not a in dom Initialized I by SCMFSA6A:48;
  not a in NAT by SCMFSA_2:84;
  then
  IExec(I,p,s) = Result(p+*I,s+*Initialized I) +* s|NAT
& not a in dom (s|NAT) by RELAT_1:86,SCMFSA6B:def 1;
  then
A2: (IExec(I,p,s)).a = (Result(p+*I,s+*Initialized I)).a by FUNCT_4:12;
A3:  Initialized I c= s+*Initialized I by FUNCT_4:26;
  I c= p+*I by FUNCT_4:26;
  then p+*I halts_on s+*Initialized I by Th5,A3;
  then consider n such that
A4: Result(p+*I,s+*Initialized I) = Comput(p +* I,s+*
Initialized I,n) and
  CurInstr(p+*I,
Result(p+*I,s+*Initialized I))
   = halt SCM+FSA by EXTPRO_1:def 8;
A5: I c= p+* I by FUNCT_4:26;
  Initialized I c= s+*Initialized I by FUNCT_4:26;
  then
A6: Initialize I c= s+*Initialized I & for m st m < n holds IC
  Comput(p+*I,s+*Initialized I,m) in dom I by Def1,SCMFSA6B:8,A5;
  assume not a in UsedIntLoc I;
  hence (IExec(I,p,s)).a = (s+*Initialized I).a by A2,A4,A6,SF_MASTR:69,A5
    .= s.a by A1,FUNCT_4:12;
end;

theorem
  for I being InitHalting Program of SCM+FSA,f being FinSeq-Location
  holds not f in UsedInt*Loc I implies (IExec(I,p,s)).f = s.f
proof
  let I be InitHalting Program of SCM+FSA,f be FinSeq-Location;
A1: not f in dom Initialized I by SCMFSA6A:49;
  not f in NAT by SCMFSA_2:85;
  then
  IExec(I,p,s) = Result(p+*I,s+*Initialized I) +* s|NAT
& not f in dom (s|NAT) by RELAT_1:86,SCMFSA6B:def 1;
  then
A2: (IExec(I,p,s)).f = (Result(p+*I,s+*Initialized I)).
f by FUNCT_4:12;
A3:  Initialized I c= s+*Initialized I by FUNCT_4:26;
  I c= p+*I by FUNCT_4:26;
  then p+*I halts_on s+*Initialized I by Th5,A3;
  then consider n such that
A4: Result(p+*I,s+*Initialized I) = Comput(p +* I,s+*
Initialized I,n) and
  CurInstr(p+*I,
Result(p+*I,s+*Initialized I))
   = halt SCM+FSA by EXTPRO_1:def 8;
A5: I c= p +* I by FUNCT_4:26;
A6: I c= p+* I by FUNCT_4:26;
  Initialized I c= s+*Initialized I by FUNCT_4:26;
  then
A7: Initialize I c= s+*Initialized I & for m st m < n holds IC
  Comput(p+*I,s+*Initialized I,m)in dom I by Def1,SCMFSA6B:8,A5;
  assume not f in UsedInt*Loc I;
  hence (IExec(I,p,s)).f = (s+*Initialized I).f by A2,A4,A7,SF_MASTR:71,A6
    .= s.f by A1,FUNCT_4:12;
end;

registration
  let I be InitHalting Program of SCM+FSA;
  cluster Initialized I -> halting;
  coherence by Def2;
end;

registration
  cluster InitHalting -> non empty Program of SCM+FSA;
  coherence;
end;

canceled 2;

theorem Th12:
  for J being InitHalting Program of SCM+FSA
   st Initialized J c= s1 & J c= p1
  for n being Element of NAT st Reloc(J,n) c= s2 & Reloc(J,n) c= p2 &
   IC s2 = n & DataPart s1 = DataPart s2
  for i being Element of NAT holds
   IC Comput(p1,s1,i) + n = IC Comput(p2,s2,i) &
   IncAddr(CurInstr(p1,Comput(p1,s1,i)),n) = CurInstr(p2,Comput(p2,s2,i)) &
   DataPart Comput(p1,s1,i) = DataPart Comput(p2,s2,i)
proof
  let J be InitHalting Program of SCM+FSA;
  set JAt = Initialized J;
  assume that
A1: JAt c= s1 and
A2: J c= p1;
  let n be Element of NAT;
  assume that
 Reloc(J,n) c= s2 and
A3: Reloc(J,n) c= p2 and
A4: IC s2 =  n and
A5: DataPart s1 = DataPart s2;
A6: DataPart Comput(p1,s1,0) = DataPart s2 by A5,EXTPRO_1:3
    .= DataPart Comput(p2,s2,0) by EXTPRO_1:3;
  defpred P[Nat] means IC Comput(p1,s1,$1) + n = IC Comput(
p2,
s2,$1) & IncAddr(CurInstr(p1,Comput(p1,s1,$1)),n)
 = CurInstr(p2,Comput(p2,s2,$1)) &
 DataPart Comput(p1,s1,$1) = DataPart Comput(p2,s2,$1
);
A7: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
A8: Comput(p1,s1,k+1) =
Following(p1,Comput(p1,s1,k))
 by EXTPRO_1:4
      .= Exec(CurInstr(p1,Comput(p1,s1,k)),
      Comput(p1,s1,k));
    reconsider l = IC Comput(p1,s1,k+1) as Element of NAT;
    reconsider j = CurInstr(p1,
    Comput(p1,s1,k+1)) as Instruction of SCM+FSA;
A9: Comput(p2,s2,k+1) = Following(p2,
Comput(p2,s2,k)) by EXTPRO_1:4
      .= Exec(CurInstr(p2,Comput(p2,s2,k)),
      Comput(p2,s2,k));
A10: IC Comput(p1,s1,k+1) in dom J by A1,Def1,A2;
    assume
A11: P[k];
    hence
 IC Comput(p1,s1,k+1) + n = IC Comput(p2,s2,k+1)
by A8,A9,SCMFSA6A:41;
    then IC Comput(p2,s2,k+1) in NAT & IC Comput(p2,
s2,k+1) in dom
    Reloc(J,n) by A10,COMPOS_1:158;
    then
A12: IC Comput(p2,s2,k+1) in dom Reloc(J,n);
A13: l in dom J by A1,Def1,A2;
    j = p1.IC Comput(p1,s1,k+1) by PBOOLE:158
:::      .= (JAt).IC Comput(p1,s1,k+1) by A1,A7,A11,GRFUNC_1:8
      .= J.l by A10,GRFUNC_1:8,A2;
    hence IncAddr(CurInstr(p1,Comput(p1,s1,k+1)),n)
       = Reloc(J,n).(l + n) by A13,COMPOS_1:122
      .= (Reloc(J,n)).(IC Comput(p2,s2,k+1))
            by A11,A8,A9,SCMFSA6A:41
      .= p2.IC Comput(p2,s2,k+1) by A12,GRFUNC_1:8,A3
      .= CurInstr(p2,Comput(p2,s2,k+1)) by PBOOLE:158;
:::       by COMPOS_1:38;
    thus thesis by A11,A8,A9,SCMFSA6A:41;
  end;
A14:  0 in dom J by AFINSQ_1:69;
A15:  0 in dom J by AFINSQ_1:69;
A16: IC SCM+FSA in dom JAt by SCMFSA6A:24;
  then
A17: p1.IC s1 = p1.((JAt).IC SCM+FSA) by A1,GRFUNC_1:8
    .= p1. 0 by SCMFSA6A:46
:::    .= (JAt). 0 by A1,A7,A17,GRFUNC_1:8
    .= J. 0 by A15,GRFUNC_1:8,A2;
  let i be Element of NAT;
   0 in dom J by AFINSQ_1:69;
  then  0 + n in dom Reloc(J,n) by COMPOS_1:158;
  then
A18:  (0 + n) in dom Reloc(J,n);
A19: IC Comput(p1,s1,0) = s1.IC SCM+FSA by EXTPRO_1:3
    .= (JAt).IC SCM+FSA by A1,A16,GRFUNC_1:8
    .=  0 by SCMFSA6A:46;
A20: p2/.IC s2 = p2.IC s2 by PBOOLE:158;
A21: p1/.IC s1 = p1.IC s1 by PBOOLE:158;
  IncAddr(CurInstr(p1,Comput(p1,s1,0)),n)
     = IncAddr(CurInstr(p1,s1),n) by EXTPRO_1:3
    .= Reloc(J,n).( 0 + n) by A17,A14,COMPOS_1:122,A21
    .= CurInstr(p2,s2) by A4,A18,A20,GRFUNC_1:8,A3
    .= CurInstr(p2,Comput(p2,s2,0)) by EXTPRO_1:3;
  then
A22: P[0] by A4,A19,A6,EXTPRO_1:3;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A22,A7);
  hence thesis;
end;

theorem
  Initialized I c= s implies I c= s
proof
  dom I misses dom iS by Th2;
  then
A1: Initialized I =I +* iS & I +* iS = I \/ iS by FUNCT_4:15,32;
  assume Initialized I c= s;
  hence thesis by A1,XBOOLE_1:11;
end;

theorem Th14:
  for I being InitHalting Program of SCM+FSA st
   Initialized I c= s1 & Initialized I c= s2 & I c= p1 & I c= p2 &
   s1,s2 equal_outside NAT
 for k being Element of NAT holds
  Comput(p1,s1,k), Comput(p2,s2,k) equal_outside NAT &
  CurInstr(p1,Comput(p1,s1,k)) = CurInstr(p2,Comput(p2,s2,k))
proof
  let I be InitHalting Program of SCM+FSA;
  assume that
A1: Initialized I c= s1 and
A2: Initialized I c= s2 and
A3: I c= p1 and
A4: I c= p2 and
A5: s1,s2 equal_outside NAT;
    let k be Element of NAT;
A6: IC Comput(p1,s1,k) in dom I by A1,Def1,A3;
A7: IC Comput(p2,s2,k) in dom I by A2,Def1,A4;
    for m being Element of NAT st m < k holds IC(Comput(p2,s2,m))
in dom
    I by A2,Def1,A4;
    hence Comput(p1,s1,k), Comput(p2,s2,k) equal_outside NAT
     by A5,AMISTD_2:66,A3,A4;
    then
A8: IC Comput(p1,s1,k) = IC Comput(p2,s2,k) by
COMPOS_1:24;
    thus CurInstr(p2,Comput(p2,s2,k))
       = p2.IC Comput(p2,s2,k) by PBOOLE:158
      .= I.IC Comput(p2,s2,k) by A7,GRFUNC_1:8,A4
      .= p1.IC Comput(p1,s1,k) by A8,A6,GRFUNC_1:8,A3
      .= CurInstr(p1,Comput(p1,s1,k)) by PBOOLE:158;
:::      by COMPOS_1:38;
end;

theorem Th15:
  for I being InitHalting Program of SCM+FSA
   st Initialized I c= s1 & Initialized I c= s2 & I c= p1 & I c= p2 &
   s1,s2 equal_outside NAT
 holds LifeSpan(p1,s1) = LifeSpan(p2,
  s2) & Result(p1,s1), Result(p2,s2)
  equal_outside NAT
proof
  let I be InitHalting Program of SCM+FSA;
  assume that
A1: Initialized I c= s1 and
A2: Initialized I c= s2 and
A3: I c= p1 and
A4: I c= p2 and
A5: s1,s2 equal_outside NAT;
A6: p2 halts_on s2 by A2,Th5,A4;
A7: p1 halts_on s1 by A1,Th5,A3;
A8: now
    let l be Element of NAT;
    assume
A9: CurInstr(p2,Comput(p2,s2
,l)) = halt SCM+FSA;
    CurInstr(p1,Comput(p1,s1,l))
     = CurInstr(p2,Comput(p2,s2,l))
     by A1,A2,A5,Th14,A3,A4;
    hence LifeSpan(p1,s1) <= l by A7,A9,EXTPRO_1:def 14;
  end;
  CurInstr(p2,
  Comput(p2,s2,LifeSpan(p1,s1)))
    = CurInstr(p1,
   Comput(p1,s1,LifeSpan(p1,s1)))
    by A1,A2,A5,Th14,A3,A4
    .= halt SCM+FSA by A7,EXTPRO_1:def 14;
  hence
A10:  LifeSpan(p1,s1) = LifeSpan(p2,s2) by A8,A6,
EXTPRO_1:def 14;
A11: Result(p2,s2) = Comput(p2,s2,LifeSpan(p1,s1))
     by A10,A2,Th5,EXTPRO_1:23,A4;
  Result(p1,s1) = Comput(p1,s1,LifeSpan(p1,s1)) by A1,Th5,EXTPRO_1:23,A3;
  hence thesis by A1,A2,A5,A11,Th14,A3,A4;
end;

registration
  cluster keeping_0 InitHalting Program of SCM+FSA;
  existence
  proof
    take Macro halt SCM+FSA;
    thus thesis;
  end;
end;

registration
  cluster keepInt0_1 InitHalting Program of SCM+FSA;
  existence
  proof
    take Macro halt SCM+FSA;
    thus thesis;
  end;
end;

canceled;

theorem Th17:
  for I being keepInt0_1 InitHalting Program of SCM+FSA holds
  IExec(I,p,s).intloc 0 = 1
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
  not intloc 0 in NAT
  proof
A1: intloc 0 in Int-Locations by SCMFSA_2:9;
    assume intloc 0 in NAT;
    hence contradiction by A1,SCMFSA_2:13,XBOOLE_0:3;
  end;
  then
A2: not intloc 0 in dom(s|NAT) by RELAT_1:86;
A3:  Initialized I c= s+*Initialized I by FUNCT_4:26;
A4: I c= p+*I by FUNCT_4:26;
  then p+*I halts_on s+*Initialized I by Th5,A3;
  then
A5: Initialized I c= s+*Initialized I &
 ex n st Result(p +* I,s+*Initialized I) =
  Comput(p +* I,s+* Initialized I,n) &
   CurInstr(p+*I,
Result(p+*I,s+*Initialized I))
    = halt
  SCM+FSA by EXTPRO_1:def 8,FUNCT_4:26;
  thus IExec(I,p,s).intloc 0 = (Result(p+*I,s+*
Initialized I) +* s|NAT).intloc 0 by SCMFSA6B:def 1
    .= (Result(p+*I,s+*Initialized I)).intloc 0 by A2,FUNCT_4:12
    .= 1 by A5,A4,Def3;
end;

registration
 cluster InitClosed Program of SCM+FSA;
 existence
  proof
   take the paraclosed Program of SCM+FSA;
   thus thesis;
  end;
end;

theorem Th18:
  for I being InitClosed Program of SCM+FSA, J being Program of
  SCM+FSA st Initialized I c= s & I c= p &
   p halts_on s
   for m st m <= LifeSpan(p,s) holds
  Comput(p,s,m),Comput(p+*(I ';' J),(s+*(I ';' J)),
m) equal_outside NAT
proof
  let I be InitClosed Program of SCM+FSA, J be Program of SCM+FSA;
  assume that
A1: Initialized I c= s and
A2: I c= p and
A3: p halts_on s;
  defpred X[Nat] means $1 <= LifeSpan(p,s) implies Comput(
p,s,$1),
  Comput(p+*(I ';' J),(s+*(I ';' J)),$1) equal_outside NAT;
A4: for m st X[m] holds X[m+1]
  proof
    set sx = s+*(I ';' J),
        px = p+*(I ';' J);
    let m;
A5: I ';' J c= px by FUNCT_4:26;
    assume
A6: m <= LifeSpan(p,s) implies Comput(p,s,m), Comput(
p+*(I ';' J),(s+*(I ';' J
    )),m) equal_outside NAT;
    dom(I ';' J) = dom Directed I \/ dom Reloc(J, card I)
    by FUNCT_4:def 1
      .= dom I \/ dom Reloc(J, card I) by FUNCT_4:105;
    then
A7: I ';' J c= Comput(px,sx,m) & dom I c= dom(I ';' J) by AMI_1:81
,FUNCT_4:26,XBOOLE_1:7;
A8: Comput(p,s,m+1) =
Following(p,Comput(p,s,m))
by EXTPRO_1:4
      .= Exec(CurInstr(p,Comput(p,s,m)),
      Comput(p,s,m));
A9: Comput(px,sx,m+1) = Following(px,
Comput(px,sx,m)) by EXTPRO_1:4
      .= Exec(CurInstr(px,Comput(px,sx,m)),
      Comput(px,sx,m));
A10: IC Comput(p,s,m) in dom I by A1,Def1,A2;
A11:  p/.IC Comput(p,s,m) = p.IC Comput(p,s,m) by PBOOLE:158;
A12: CurInstr(p,Comput(p,s,m))
     = I.IC(Comput(p,s,m)) by A10,A11,GRFUNC_1:8,A2;
    assume
A13: m+1 <= LifeSpan(p,s);
    then
A14: IC(Comput(p,s,m)) = IC(Comput(px,sx,m)) by A6,
COMPOS_1:24,NAT_1:13;
A15:  px/.IC Comput(px,sx,m)
 = px.IC Comput(px,sx,m) by PBOOLE:158;
    m < LifeSpan(p,s) by A13,NAT_1:13;
    then I.IC(Comput(p,s,m)) <> halt SCM+FSA by A3,A12,
EXTPRO_1:def 14
;
    then CurInstr(p,Comput(p,s,m))
     = (I ';' J).IC(Comput(p,s,m)) by A10,A12,SCMFSA6A:54
    .= CurInstr(px,Comput(px,sx,m)) by A14,A10,A7,A15,GRFUNC_1:8,A5;
    hence thesis by A6,A13,A8,A9,NAT_1:13,AMISTD_2:def 20;
  end;
  Comput(p,s,0) = s & Comput(p+*(I ';' J),(s+*(I
';' J)),0) = s+*(I ';' J) by EXTPRO_1:3;
  then
A16: X[0] by FUNCT_7:132;
  thus for m holds X[m] from NAT_1:sch 1(A16,A4);
end;

theorem Th19:
  for i,m,n being Element of NAT holds s+*I+*(((intloc i) .--> m)
  +* Start-At(n,SCM+FSA)) = s+*(((intloc i) .--> m) +*
  Start-At(n,SCM+FSA))+* I
proof
  let i,m,n be Element of NAT;
  set iS = ((intloc i) .--> m) +* Start-At(n,SCM+FSA);
A1: dom I misses dom iS by Th2;
  then I +* iS = I \/ iS by FUNCT_4:32
    .= iS +* I by A1,FUNCT_4:32;
  hence s+*I+* iS = s+*(iS+*I) by FUNCT_4:15
    .= s+*iS +*I by FUNCT_4:15;
end;

theorem Th20:
  Initialize ((intloc 0) .--> 1) c= s implies
    Initialized I c= s +* (I +* (Initialize ((intloc 0) .--> 1))) &
s +* (I +* (Initialize ((intloc 0) .--> 1))) = s +* I &
 s +* (I +* (Initialize ((intloc 0) .--> 1))) +* Directed I =
  s +* Directed I
proof
  assume
A1: iS c= s;
  set sISA0 = s +* (I +* iS);
  I +* iS c= sISA0 by FUNCT_4:26;
  hence Initialized I c= sISA0 by FUNCT_4:15;
  thus sISA0 = s +*I +* iS by FUNCT_4:15
    .= s +* iS +*I by Th19
    .= s +* I by A1,FUNCT_4:79;
A2: dom Directed I = dom I by FUNCT_4:105;
  thus sISA0 +* Directed I = s +*I +* iS +* Directed I by FUNCT_4:15
    .= s +* iS +*I +* Directed I by Th19
    .= s +*I +* Directed I by A1,FUNCT_4:79
    .= s +*(I +* Directed I) by FUNCT_4:15
    .= s +*Directed I by A2,FUNCT_4:20;
end;

theorem Th21:
  for I being InitClosed Program of SCM+FSA
   st p+*I halts_on s+*I &
  Directed I c= s & Directed I c= p &
   Initialize ((intloc 0) .--> 1) c= s
   holds IC Comput(p, s,LifeSpan(p +* I,s +*I) + 1) =  card I
proof
  set A = NAT;
  let I be InitClosed Program of SCM+FSA;
  assume that
A1: p+*I halts_on s+*I and
A2: Directed I c= s and
A3: Directed I c= p and
A4: iS c= s;
  set sISA0 = s +* (I +* iS),
      pISA0 = p +* I;
A5: Initialized I c= sISA0 by A4,Th20;
A6: I c= pISA0 by FUNCT_4:26;
  set IAt = Initialize I;
A7: sISA0 = s +* I by A4,Th20;
  reconsider sISA0 as State of SCM+FSA;
  set m = LifeSpan(pISA0,sISA0);
  set l1 = IC Comput(pISA0, sISA0,m);
A8: I c= pISA0 by FUNCT_4:26;
A9: l1 in dom I by A5,Def1,A8;
  set s2 = sISA0 +* Directed I,
      p2 = pISA0 +* Directed I;
A10: Directed I c= p2 by FUNCT_4:26;
A11: now
    set s1 = sISA0 +* (I ';' I),
        p1 = pISA0 +* (I ';' I);
    let k be Element of NAT;
    defpred X[Nat] means $1 <= k implies Comput(p1, s1,$1),
    Comput(p2, s2,$1) equal_outside A;
    assume
A12: k <= m;
A13: for n being Element of NAT st X[n] holds X[n+1]
    proof
      let n be Element of NAT;
      assume
A14:  n <= k implies Comput(p1, s1,n), Comput(p2,
s2,n)
      equal_outside A;
A15:  Comput(p2, s2,n + 1) = Following(p2,
Comput(p2,s2,n)) by EXTPRO_1:4
        .= Exec(CurInstr(p2,Comput(p2,s2,n)),
        Comput(p2, s2,n));
A16:  Comput(p1, s1,n + 1) = Following(p1,
Comput(p1,s1,n)) by EXTPRO_1:4
        .= Exec(CurInstr(p1,Comput(p1,s1,n)),
        Comput(p1, s1,n));
A17:  n <= n + 1 by NAT_1:12;
      assume
A18:  n + 1 <= k;
      then
A19:  IC Comput(p1, s1,n) = IC Comput(p2, s2,n) by
A14,A17,COMPOS_1:24,XXREAL_0:2;
A20: I c= p +* I by FUNCT_4:26;
      n <= k by A18,A17,XXREAL_0:2;
      then n <= m by A12,XXREAL_0:2;
      then IC Comput(pISA0, sISA0,n)
       = IC Comput(p1, s1,n) by A1,A5,A7,Th18,COMPOS_1:24,A6;
      then
A21:  IC Comput(p1, s1,n) in dom I by A5,Def1,A20;
      then
A22:  IC Comput(p2, s2,n) in dom Directed I by A19,FUNCT_4:105;
A23:  CurInstr(p2,Comput(p2,s2,n))
         = p2.IC Comput(p2, s2,n) by PBOOLE:158
        .= (Directed I).IC Comput(p2, s2,n) by A22,FUNCT_4:14;
      dom I c= dom (I ';' I) &
      CurInstr(p1, Comput(p1,s1,n)) = p1.IC
      Comput(p1, s1,n) by SCMFSA6A:56,PBOOLE:158;
      then Directed I c= I ';' I &
      CurInstr(p1,Comput(p1,s1,n)) = (I ';' I).IC
      Comput(p1, s1,n) by A21,FUNCT_4:14,SCMFSA6A:55;
      then
      CurInstr(p1,Comput(p1,s1,n))
       = (Directed I).IC Comput(p1, s1,n) by A19,A22,GRFUNC_1:8;
      hence thesis by A14,A18,A17,A19,A23,A16,A15,AMISTD_2:def 20,XXREAL_0:2;
    end;
    Comput(p1, s1,0) = s1 & Comput(p2, s2,0) = s2
by EXTPRO_1:3;
    then Comput(p2, s2,0), Comput(p1, s1,0)
equal_outside A by FUNCT_7:107,133;
    then
A24: X[0] by FUNCT_7:28;
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A24,A13);
    then
A25: Comput(p1,s1,k), Comput(p2,s2,k) equal_outside A;
    Comput(pISA0, sISA0,k), Comput(p1,s1,k) equal_outside A
     by A1,A5,A7,A12,Th18,A6;
    hence Comput(pISA0, sISA0,k), Comput(p2,s2,k)
equal_outside A by A25,FUNCT_7:29;
  end;
  then
A26: l1 = IC Comput(p2,s2,m) by COMPOS_1:24;
A27: I.l1 = pISA0.l1 by A9,GRFUNC_1:8,A6
    .=CurInstr(pISA0,Comput(pISA0,sISA0,m)) by PBOOLE:158
    .= halt SCM+FSA by A1,A7,EXTPRO_1:def 14;
  IC Comput(p2,s2,m) in dom I by A11,A9,COMPOS_1:24;
  then IC Comput(p2,s2,m) in dom Directed I by FUNCT_4:105;
  then
A28: p2.l1 = (Directed I).l1 by A26,A10,GRFUNC_1:8
    .= goto  card I by A9,A27,FUNCT_4:112;
A29: Comput(p2, s2,m + 1)
     = Following(p2,Comput(p2,s2,m)) by EXTPRO_1:4
    .= Exec(goto  card I,Comput(p2,s2,m))
     by A26,A28,PBOOLE:158;
A30: s +* (I +* (Initialize((intloc 0) .--> 1))) = s +* I
         by A4,Th20;
    dom Directed I = dom I by FUNCT_4:105;
    then
A31: p +* I +* Directed I = p +* Directed I by FUNCT_4:78
     .= p by A3,FUNCT_4:79;
  s2 = s +*Directed I by A4,Th20
    .= s by A2,FUNCT_4:79;
  hence thesis by A29,A30,SCMFSA_2:95,A31;
end;

theorem Th22:
  for I being InitClosed Program of SCM+FSA
   st p+*I halts_on s+*I & Directed I c= s & Directed I c= p &
 Initialize ((intloc 0) .--> 1) c= s
 holds DataPart Comput(p, s,LifeSpan(p +* I,s +*I))
  = DataPart Comput(p,s,LifeSpan(p +* I,s +*I) + 1)
proof
  set A = NAT;
  let I be InitClosed Program of SCM+FSA;
  assume that
A1: p+*I halts_on s+*I and
A2: Directed I c= s and
A3: Directed I c= p and
A4: iS c= s;
  set sISA0 = s +* (I +* iS),
      pISA0 = p +* I;
A5: Initialized I c= sISA0 by A4,Th20;
A6: I c= p+*I by FUNCT_4:26;
  set IAt = Initialize I;
A7: sISA0 = s +* I by A4,Th20;
  reconsider sISA0 as State of SCM+FSA;
  set m = LifeSpan(pISA0,sISA0);
  set l1 = IC Comput(pISA0, sISA0,m);
A8: l1 in dom I by A5,Def1,A6;
  set s2 = sISA0 +* Directed I,
      p2 = pISA0 +* Directed I;
A9: now
    set s1 = sISA0 +* (I ';' I),
        p1 = pISA0 +* (I ';' I);
    let k be Element of NAT;
    defpred X[Nat] means $1 <= k implies Comput(p1, s1,$1),
    Comput(p2, s2,$1) equal_outside A;
    assume
A10: k <= m;
A11: for n being Element of NAT st X[n] holds X[n+1]
    proof
A12:  Directed I c= I ';' I by SCMFSA6A:55;
      let n be Element of NAT;
A13:  dom I c= dom (I ';' I) by SCMFSA6A:56;
      assume
A14:  n <= k implies Comput(p1, s1,n), Comput(p2,
s2,n)
      equal_outside A;
A15:  Comput(p2, s2,n + 1) = Following(p2,
Comput(p2,s2,n)) by EXTPRO_1:4
        .= Exec(CurInstr(p2,Comput(p2,s2,n)),
        Comput(p2, s2,n));
A16:  Comput(p1, s1,n + 1) = Following(p1,
Comput(p1,s1,n)) by EXTPRO_1:4
        .= Exec(CurInstr(p1,Comput(p1,s1,n)),
        Comput(p1, s1,n));
A17:  n <= n + 1 by NAT_1:12;
      assume
A18:  n + 1 <= k;
      then
A19:  IC Comput(p1, s1,n) = IC Comput(p2, s2,n) by
A14,A17,COMPOS_1:24,XXREAL_0:2;
      n <= k by A18,A17,XXREAL_0:2;
      then n <= m by A10,XXREAL_0:2;
      then IC Comput(pISA0, sISA0,n) = IC Comput(p1
, s1,n) by A1,A5,A7,Th18,COMPOS_1:24,A6;
      then
A20:  IC Comput(p1, s1,n) in dom I by A5,Def1,A6;
      then
A21:  IC Comput(p2, s2,n) in dom Directed I by A19,FUNCT_4:105;
A22:  CurInstr(p2,Comput(p2,s2,n))
         = p2.IC Comput(p2, s2,n) by PBOOLE:158
        .= (Directed I).IC Comput(p2, s2,n) by A21,FUNCT_4:14;
      CurInstr(p1,Comput(p1,s1,n))
         = p1.IC Comput(p1, s1,n) by PBOOLE:158
        .= (I ';' I).IC Comput(p1, s1,n) by A13,A20,FUNCT_4:14
        .= (Directed I).IC Comput(p1, s1,n) by A12,A19,A21,
GRFUNC_1:8;
      hence thesis by A14,A18,A17,A19,A22,A16,A15,AMISTD_2:def 20,XXREAL_0:2;
    end;
    Comput(p1, s1,0) = s1 & Comput(p2, s2,0) = s2
by EXTPRO_1:3;
    then Comput(p2, s2,0), Comput(p1, s1,0)
equal_outside A by FUNCT_7:107,133;
    then
A23: X[0] by FUNCT_7:28;
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A23,A11);
    then
A24: Comput(p1,s1,k), Comput(p2,s2,k) equal_outside A
;
    Comput(pISA0, sISA0,k), Comput(p1,s1,k)
equal_outside A by A1,A5,A7,A10,Th18,A6;
    hence Comput(pISA0, sISA0,k), Comput(p2,s2,k)
equal_outside A by A24,FUNCT_7:29;
  end;
  then
A25: l1 = IC Comput(p2,s2,m) by COMPOS_1:24;
A26: I.l1 = pISA0.l1 by A8,A6,GRFUNC_1:8
    .=CurInstr(pISA0,Comput(pISA0,sISA0,m)) by PBOOLE:158
:::     by COMPOS_1:38
    .= halt SCM+FSA by A1,A7,EXTPRO_1:def 14;
  IC Comput(p2,s2,m) in dom I by A9,A8,COMPOS_1:24;
  then IC Comput(p2,s2,m) in dom Directed I by FUNCT_4:105;
  then
A27: p2.l1 = (Directed I).l1 by A25,FUNCT_4:14
    .= goto  card I by A8,A26,FUNCT_4:112;
  Comput(p2, s2,m + 1)
     = Following(p2,Comput(p2,s2,m)) by EXTPRO_1:4
    .= Exec(goto  card I,Comput(p2,s2,m))
     by A25,A27,PBOOLE:158;
  then
A28: ( for a being Int-Location holds Comput(p2, s2,m + 1).a =
Comput(p2, s2,m). a)& for f being FinSeq-Location holds Comput(
p2, s2,m + 1).f =
  Comput(p2, s2,m).f by SCMFSA_2:95;
    dom Directed I = dom I by FUNCT_4:105;
    then
A29: p +* I +* Directed I = p +* Directed I by FUNCT_4:78
     .= p by A3,FUNCT_4:79;
  s2 = s +*Directed I by A4,Th20
    .= s by A2,FUNCT_4:79;
  hence thesis by A7,A28,SCMFSA6A:38,A29;
end;

theorem Th23:
  for I being InitHalting Program of SCM+FSA st
    Initialized I c= s & I c= p
holds for k being Element of NAT st k <= LifeSpan(p,s)
 holds CurInstr(p +* Directed I,
  Comput(p +* Directed I,(s +* Directed I),k)) <> halt SCM+FSA
proof
  set A = NAT;
  let I be InitHalting Program of SCM+FSA;
  set s2 = s +* Directed I,
      p2 = p +* Directed I;
A1: ProgramPart Initialized I = I by SCMFSA6A:33;
  set m = LifeSpan(p,s);
  assume
A2: Initialized I c= s;
  assume
A3: I c= p;
   then
A4: p halts_on s by EXTPRO_1:def 10,A2,A1;
A5: now
    set s1 = s +* (I ';' I),
        p1 = p +* (I ';' I);
    let k be Element of NAT;
    defpred X[Nat] means $1 <= k implies Comput(p1, s1,$1),
    Comput(p2, s2,$1) equal_outside A;
    assume
A6: k <= m;
A7: for n being Element of NAT st X[n] holds X[n+1]
    proof
A8:   Directed I c= I ';' I by SCMFSA6A:55;
      let n be Element of NAT;
A9:   dom I c= dom (I ';' I) by SCMFSA6A:56;
      assume
A10:   n <= k implies Comput(p1, s1,n), Comput(p2,
s2,n)
      equal_outside A;
A11:   Comput(p2, s2,n + 1) =
Following(p2,Comput(p2,s2,n)
)
 by EXTPRO_1:4
        .= Exec(CurInstr(p2,Comput(p2,s2,n)),
        Comput(p2, s2,n));
A12:  Comput(p1, s1,n + 1) =
Following(p1,Comput(p1,s1,n)
)
 by EXTPRO_1:4
        .= Exec(CurInstr(p1,Comput(p1,s1,n)),
        Comput(p1, s1,n));
A13:  n <= n + 1 by NAT_1:12;
      assume
A14:  n + 1 <= k;
      then
A15:  IC Comput(p1, s1,n) = IC Comput(p2, s2,n) by
A10,A13,COMPOS_1:24,XXREAL_0:2;
      n <= k by A14,A13,XXREAL_0:2;
      then n <= m by A6,XXREAL_0:2;
      then IC Comput(p,s,n) = IC Comput(p1, s1,n)
       by A2,A4,Th18,COMPOS_1:24,A3;
      then
A16:  IC Comput(p1, s1,n) in dom I by A2,Def1,A3;
      then
A17:  IC Comput(p2, s2,n) in dom Directed I by A15,FUNCT_4:105;
A18:  CurInstr(p2,Comput(p2,s2,n))
        = p2.IC Comput(p2, s2,n) by PBOOLE:158
        .= (Directed I).IC Comput(p2, s2,n) by A17,FUNCT_4:14;
      CurInstr(p1,Comput(p1,s1,n))
       = p1.IC Comput(p1, s1,n) by PBOOLE:158
        .= (I ';' I).IC Comput(p1, s1,n) by A9,A16,FUNCT_4:14
        .= (Directed I).IC Comput(p1, s1,n) by A8,A15,A17,GRFUNC_1:8;
      hence thesis by A10,A14,A13,A15,A18,A12,A11,AMISTD_2:def 20,XXREAL_0:2;
    end;
    Comput(p1, s1,0) = s1 & Comput(p2, s2,0) = s2
by EXTPRO_1:3;
    then Comput(p2, s2,0), Comput(p1, s1,0)
equal_outside A by FUNCT_7:107,133;
    then
A19: X[0] by FUNCT_7:28;
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A19,A7);
    then
A20: Comput(p1,s1,k), Comput(p2,s2,k) equal_outside A
;
    Comput(p,s,k), Comput(p1,s1,k) equal_outside A
by A2,A4,A6,Th18,A3;
    hence Comput(p,s,k), Comput(p2,s2,k)
equal_outside A by A20,FUNCT_7:29
;
  end;
    let k be Element of NAT;
    set lk = IC Comput(p,s,k);
A21: IC Comput(p,s,k) in dom I & dom I = dom Directed I by A2,A3,Def1
,FUNCT_4:105;
    then
A22: (Directed I).lk in rng Directed I by FUNCT_1:def 5;
    assume k <= LifeSpan(p,s);
    then lk = IC Comput(p2,s2,k) by A5,COMPOS_1:24;
    then
 A23: CurInstr(p2,Comput(p2,s2,k))
       = p2.lk by PBOOLE:158
      .= (Directed I).lk by A21,FUNCT_4:14;
    assume
    CurInstr(p +* Directed I,
     Comput(p +* Directed I, (s +* Directed I),k)) = halt
SCM+FSA;
    hence contradiction by A23,A22,SCMFSA6A:18;
end;

theorem Th24:
  for I being InitClosed Program of SCM+FSA
   st p+*I halts_on s+*Initialized I
   for J being Program of SCM+FSA, k being Element of NAT
    st k <= LifeSpan(p +* I,s +* Initialized I )
   holds Comput(p +* I, (s +* Initialized I),k),
      Comput(p +* (I ';' J), (s +* Initialized (I ';' J)),k)
       equal_outside NAT
proof
  let I be InitClosed Program of SCM+FSA;
  assume
A1: p+*I halts_on s+*Initialized I;
  set s1 = s +* Initialized I,
      p1 = p +* I;
A2: I c= p1 by FUNCT_4:26;
  let J be Program of SCM+FSA;
  set s2 = s +* Initialized (I ';' J),
      p2 = p +* (I ';' J);
  defpred X[Nat] means $1 <= LifeSpan(p1,s1) implies Comput(
p1, s1,$1
  ), Comput(p2,(s2),$1) equal_outside NAT;
A3: for m st X[m] holds X[m+1]
  proof
    dom(I ';' J) = dom Directed I \/ dom Reloc(J, card I)
    by FUNCT_4:def 1
      .= dom I \/ dom Reloc(J, card I) by FUNCT_4:105;
    then
A4: dom I c= dom(I ';' J) by XBOOLE_1:7;
    set sx = s2,
        px = p2;
A5: I ';' J c= p2 by FUNCT_4:26;
    let m;
    assume
A6: m <= LifeSpan(p1,s1) implies Comput(p1,s1,m),
Comput(p2,(s2),m)
    equal_outside NAT;
    assume
A7: m+1 <= LifeSpan(p1,s1);
    then
A8: IC(Comput(p1,s1,m)) = IC(Comput(px,sx,m)) by A6,
COMPOS_1:24,NAT_1:13;
A9: Comput(p1,s1,m+1) = Following(p1,Comput(p1,s1,m)) by EXTPRO_1:4
      .= Exec(CurInstr(p1,Comput(p1,s1,m)),
      Comput(p1,s1,m));
A10: Comput(px,sx,m+1) = Following(px,Comput(px,sx,m)) by EXTPRO_1:4
      .= Exec(CurInstr(px,Comput(px,sx,m)),Comput(px,sx,m));
    Initialized I c= s1 by FUNCT_4:26;
    then
A11: IC Comput(p1,s1,m) in dom I by Def1,A2;
A12:  p1/.IC Comput(p1,s1,m) = p1.IC Comput(p1,s1,m) by PBOOLE:158;
A13: CurInstr(p1,Comput(p1,s1,m))
    = I.IC(Comput(p1,s1,m)) by A11,A12,GRFUNC_1:8,A2;
A14:  px/.IC Comput(px,sx,m) = px.IC Comput(px,sx,m) by PBOOLE:158;
    m < LifeSpan(p1,s1) by A7,NAT_1:13;
    then I.IC(Comput(p1,s1,m)) <> halt SCM+FSA by A1,A13,
EXTPRO_1:def 14;
    then
    CurInstr(p1,Comput(p1,s1,m))
     = (I ';' J).IC(Comput(p1,s1,m)) by A11,A13,SCMFSA6A:54
    .= px.IC Comput(px,sx,m) by A8,A11,A4,GRFUNC_1:8,A5
    .= CurInstr(px,Comput(px,sx,m)) by A14;
    hence thesis by A6,A7,A9,A10,NAT_1:13,AMISTD_2:def 20;
  end;
A15: s+*iS+*I, s+*iS equal_outside NAT & s+*iS, s+*iS+*(I ';' J)
  equal_outside NAT by FUNCT_7:28,132;
A16: s2 = s +* ((I ';' J) +* iS) by FUNCT_4:15
    .=s +* (I ';' J) +* iS by FUNCT_4:15
    .= s+*iS+*(I ';' J) by Th19;
A17: Comput(p1, s1,0) = s1 & Comput(p2,(s2),0) =
s2 by EXTPRO_1:3;
  s1 = s +* (I +* iS) by FUNCT_4:15
    .=s +* I +* iS by FUNCT_4:15
    .= s+*iS+*I by Th19;
  then
A18: X[0] by A16,A15,A17,FUNCT_7:29;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A18, A3 );
end;

theorem Th25:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA, s being State of SCM+FSA st
 Initialized (I ';' J) c= s & I ';' J c= p
  holds IC Comput(p, s,LifeSpan(p +* I,s +* I) + 1) =  card I &
DataPart Comput(p, s,LifeSpan(p +* I,s +* I) + 1) =
DataPart(Comput(
p +* I, (s +* I)
  ,LifeSpan(p +* I,s +* I)) +* Initialized J) &
  Reloc(J,card I) c=
Comput(p, s,LifeSpan(p +* I,s +* I) + 1) & Comput(
p, s,
LifeSpan(p +* I,s +* I) + 1).
  intloc 0 = 1 & p halts_on s &
   LifeSpan(p,s) = LifeSpan(p +* I,s +* I) + 1 +
LifeSpan(p +* I +* J,
Result(p +* I,s +* I) +* Initialized J) & (J is keeping_0 implies
(Result(p,s)).intloc 0
  = 1)
proof
  set D = Data-Locations SCM+FSA;
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s1 = s +* I,
      p1 = p +* I;
  set s3 = Comput(p1, s1,LifeSpan(p1,s1)) +* Initialized J,
      p3 = p1 +* J;
  set m1 = LifeSpan(p1,s1);
  set m3 = LifeSpan(p3,s3);
A1: iS c= (I ';' J) +* iS by FUNCT_4:26;
A2: J c= p3 by FUNCT_4:26;
  assume
A3: Initialized (I ';' J) c= s;
  then
A4: s = s +* Initialized (I ';' J) by FUNCT_4:79;
  assume
A5: I ';' J c= p;
  then
A6: p +*(I ';' J) = p by FUNCT_4:79;
A7: I c= p1 by FUNCT_4:26;
  set s4 = Comput(p, s,m1 + 1),
      p4 = p;
A8: Directed I c= I ';' J & I ';' J c= Initialized (I ';' J) by SCMFSA6A:26,55;
   then
A9: Directed I c= p by A5,XBOOLE_1:1;
  then
A10: p = p +* Directed I by FUNCT_4:79;
  reconsider m = m1 + 1 + m3 as Element of NAT;
A11: dom Directed I = dom I by FUNCT_4:105;
A12: s1 +* Directed I = s +* (I +* Directed I) by FUNCT_4:15
    .= s +* Directed I by A11,FUNCT_4:20
    .= s +* Initialized (I ';' J) +* Directed I by A3,LATTICE2:8
    .= s +* (Initialized (I ';' J) +* Directed I) by FUNCT_4:15
    .= s +* Initialized (I ';' J) by A8,LATTICE2:8,XBOOLE_1:1
    .= s by A3,LATTICE2:8;
  then
A13: Directed I c= s by FUNCT_4:26;
A14: p1 +* Directed I = p +* (I +* Directed I) by FUNCT_4:15
    .= p +* Directed I by A11,FUNCT_4:20
    .= p by A10;
A15: Initialized J c= s3 by FUNCT_4:26;
  then dom Initialized J c= dom s3 by GRFUNC_1:8;
  then
A16: dom Initialized J c= the carrier of SCM+FSA by PARTFUN1:def 4;
A17: Reloc(J,card I) c= I ';' J by FUNCT_4:26;
  (I ';' J) +* iS c= s by A3,FUNCT_4:15;
  then
A18: iS c= s by A1,XBOOLE_1:1;
A19: Initialized I c= s +* I by A3,SCMFSA6A:52;
  I c= p+*I by FUNCT_4:26;
  then
A20: p+*I halts_on s+*I by Th5,A19;
  hence
A21: IC Comput(p, s,LifeSpan(p +* I,s +* I) + 1) = card I
     by A18,A12,Th21,FUNCT_4:26,A9;
A22: now
    let x be set;
    assume x in dom DataPart Initialized J;
    then
A23: x in dom (Initialized J) /\ D by RELAT_1:90;
    then
A24: x in dom Initialized J by XBOOLE_0:def 4;
A25: x in D by A23,XBOOLE_0:def 4;
    per cases by A24,SCMFSA6A:44;
    suppose
A26:  x in dom J;
      dom J c= NAT by RELAT_1:def 18;
      then reconsider l=x as Element of NAT by A26;
      (DataPart Initialized J).l = (DataPart Comput(p1,s1,m1)).l
by A25,SCMFSA6A:37;
      hence (DataPart Initialized J).x = (DataPart Comput(p1,s1,m1
)).x;
    end;
    suppose
A27:  x = intloc 0;
      thus (DataPart Initialized J).x = (Initialized J).x by A25,FUNCT_1:72

        .= 1 by A27,SCMFSA6A:46
        .= Comput(p1,s1,m1).x by A19,A27,Def3,A7
        .= (DataPart Comput(p1,s1,m1)).x by A25,FUNCT_1:72
;
    end;
    suppose
      x = IC SCM+FSA;
      hence
      (DataPart Initialized J).x = (DataPart Comput(p1,s1,m1)).x
by A23,SCMFSA6A:37,XBOOLE_0:def 4;
    end;
  end;
A28: Initialize J c= s3 by FUNCT_4:26,SCMFSA6B:8;
A29: p3 halts_on s3 by Th5,A2,A15;
  dom (DataPart Initialized J) = dom Initialized J /\ D by RELAT_1:90
;
  then dom (DataPart Initialized J) c= (the carrier of SCM+FSA) /\ D by A16,
XBOOLE_1:26;
  then dom (DataPart Initialized J) c= dom Comput(p1,s1,m1) /\ D
by PARTFUN1:def 4;
  then dom (DataPart Initialized J) c= dom DataPart Comput(p1,s1,
m1) by RELAT_1:90;
  then DataPart s3 = DataPart Comput(p1,s1,m1) +* DataPart(
Initialized J) &
  DataPart Initialized J c= DataPart Comput(p1,s1,m1) by A22,
FUNCT_4:75,GRFUNC_1:8;
  then
A30: DataPart Comput(p1,s1,m1) = DataPart s3 by LATTICE2:8;
  s +* I = s +*iS +* I by A18,FUNCT_4:79
    .= s +*I+*iS by Th19
    .= s +*(I+*iS) by FUNCT_4:15
    .= s +* Initialized I by FUNCT_4:15;
  then
   Comput(p1,s1,m1),Comput(p,s,m1) equal_outside NAT by A4,A20,Th24,A6;
  then DataPart Comput(p,s,m1) = DataPart s3 by A30,
COMPOS_1:138;
  hence
A31: DataPart Comput(p, s,m1 + 1) = DataPart s3
     by A18,A13,Th22,A19,Th5,A7,A9;
  I ';' J c= Initialized (I ';' J) by SCMFSA6A:26;
  then I ';' J c= s by A3,XBOOLE_1:1;
  then Reloc(J,card I) c= s by A17,XBOOLE_1:1;
  hence
A32: Reloc(J,card I) c= s4 by AMI_1:81;
A33: Reloc(J,card I) c= p4 by A17,A5,XBOOLE_1:1;
A34: intloc 0 in dom Initialized J by SCMFSA6A:45;
  intloc 0 in Int-Locations by SCMFSA_2:9;
  then
A35: intloc 0 in D by XBOOLE_0:def 3,SCMFSA_2:127;
  hence s4.intloc 0 = (DataPart s3).intloc 0 by A31,FUNCT_1:72
    .= s3.intloc 0 by A35,FUNCT_1:72
    .= (Initialized J).intloc 0 by A34,FUNCT_4:14
    .= 1 by SCMFSA6A:46;
A36: Comput(p,s,m1 + 1 + m3)
 = Comput(p,Comput(p,s,m1 + 1),m3)
 by EXTPRO_1:5;
A37: Initialized J c= s3 by FUNCT_4:26;
  then
  IncAddr(CurInstr(p3,Comput(p3,s3,m3)),card I)
   = CurInstr(p,Comput(p, s,m1 + 1 + m3))
    by A36,A21,A31,A32,Th12,A2,A33;
  then
A38: CurInstr(p,Comput(p,s,m))
 = IncAddr (halt SCM+FSA,card I) by A29,EXTPRO_1:def 14
    .= halt SCM+FSA by COMPOS_1:93;
  hence
A39: p halts_on s by EXTPRO_1:30;
A40: now
    let k be Element of NAT;
    assume m1 + 1 + k < m;
    then
A41: k < m3 by XREAL_1:8;
    assume
A42: CurInstr(p,
       Comput(p, s,m1 + 1 + k)) = halt SCM+FSA;
    IncAddr(CurInstr(p3,Comput(p3,s3,k)),card I)
     = CurInstr(p4,Comput(p,s4,k))
      by A21,A31,A37,A32,Th12,A2,A33
      .= halt SCM+FSA by A42,EXTPRO_1:5;
    then InsCode CurInstr(p3,Comput(p3,s3,k)) = 0
     by COMPOS_1:def 38,SCMFSA_2:124;
    then CurInstr(p3,Comput(p3,s3,k))
     = halt SCM+FSA by SCMFSA_2:122;
    hence contradiction by A29,A41,EXTPRO_1:def 14;
  end;
  now
    let k be Element of NAT;
    assume
A43: k < m;
    per cases;
    suppose
    k <= m1;
      hence CurInstr(p,Comput(p,s,k))
       <> halt SCM+FSA by A19,A12,Th23,A7,A14;
    end;
    suppose
      m1 < k;
      then m1 + 1 <= k by NAT_1:13;
      then consider kk being Nat such that
A44:  m1 + 1 + kk = k by NAT_1:10;
      reconsider kk as Element of NAT by ORDINAL1:def 13;
      m1+1+kk=k by A44;
      hence CurInstr(p,Comput(p,s,k))
       <> halt SCM+FSA by A40,A43;
    end;
  end;
  then
A45: for k being Element of NAT st CurInstr(p,Comput(p,s,k))
   = halt SCM+FSA
  holds m <= k;
  then
A46: LifeSpan(p,s) = m by A38,A39,EXTPRO_1:def 14;
A47: s1 = s +* Initialized I by A3,SCMFSA6A:51;
A48:  Initialized I c= s+*Initialized I by FUNCT_4:26;
  I c= p+*I by FUNCT_4:26;
  then
A49:  p1 halts_on s1 by Th5,A48,A47;
   Comput(p1, s1,LifeSpan(p1,s1))
     = Result(p +* I,s +* I) by A49,EXTPRO_1:23;
  hence LifeSpan(p,s) = LifeSpan(p +* I,s +* I) + 1 +
LifeSpan(p +* I +* J,
Result(p +* I,s +* I) +*
  Initialized J) by A45,A38,A39,EXTPRO_1:def 14;
A50: Initialized J c= s3 by FUNCT_4:26;
A51: DataPart Comput(p3, s3,m3)
 = DataPart Comput(p4, s4,m3) by A21,A31,A37,A32,Th12,A2,
        A33;
:::  hereby
    assume
A52: J is keeping_0;
    thus (Result(p,s)).intloc 0 = Comput(p,s,m).intloc 0 by A39,A46,EXTPRO_1:23
      .= Comput(p, s4,m3).intloc 0 by EXTPRO_1:5
      .= Comput(p3, s3,m3).intloc 0 by A51,SCMFSA6A:38
      .= s3.intloc 0 by A28,A52,SCMFSA6B:def 4,A2
      .= (Initialized J).intloc 0 by A34,A50,GRFUNC_1:8
      .= 1 by SCMFSA6A:46;
:::  end;
end;

registration
  let I be keepInt0_1 InitHalting Program of SCM+FSA, J be InitHalting Program
  of SCM+FSA;
  cluster I ';' J -> InitHalting;
  coherence
  proof
    set D = Data-Locations SCM+FSA;
    set JAt = Initialized J;
    let s be State of SCM+FSA;
    assume
A1: Initialized (I ';' J) c= s;
    then
A2: s = s +* Initialized (I ';' J) by FUNCT_4:79;
    let p;
    assume
A3: ProgramPart Initialized(I ';' J) c= p;
 ProgramPart Initialized(I ';' J) = (I ';' J) by SCMFSA6A:33;
   then
A4: p = p +* (I ';' J) by A3,FUNCT_4:79;
A5: ProgramPart Initialized(I ';' J) = I ';' J by SCMFSA6A:33;
A6: Initialized (I ';' J) = (I ';' J) +* iS by FUNCT_4:15;
    set s1 = s +* I,
        p1 = p +* I;
    set s3 = Comput(p1, s1,LifeSpan(p1,s1)) +* JAt,
        p3 = p1 +* J;
A7: J c= p3 by FUNCT_4:26;
    set m1 = LifeSpan(p1,s1);
    set s4 = Comput(p, s,m1 + 1);
A8: I c= p1 by FUNCT_4:26;
A9: Reloc(J,card I) c= I ';' J by FUNCT_4:26;
A10: dom I misses dom iS by Th2;
    set m3 = LifeSpan(p3,s3);
A11: dom DataPart JAt = dom JAt /\ D by RELAT_1:90;
    reconsider m = m1 + 1 + m3 as Element of NAT;
A12: dom Directed I = dom I by FUNCT_4:105;
    dom (I ';' J) misses dom iS by Th2;
    then
A13: I ';' J c= Initialized (I ';' J) by A6,FUNCT_4:33;
    then I ';' J c= s by A1,XBOOLE_1:1;
    then Reloc(J,card I) c= s by A9,XBOOLE_1:1;
    then
A14: JAt c= s3 & Reloc(J,card I) c= s4 by AMI_1:81,FUNCT_4:26;
    iS c= (I ';' J) +* iS by FUNCT_4:26;
    then
A15: iS c= s by A1,A6,XBOOLE_1:1;
    then s +*iS = s by FUNCT_4:79;
    then
A16: s +* I = s +*(iS +* I) by FUNCT_4:15
      .=s +*(I +* iS) by A10,FUNCT_4:36
      .=s +* Initialized I by FUNCT_4:15;
A17:  Initialized I c= s+*Initialized I by FUNCT_4:26;
  I c= p+*I by FUNCT_4:26;
  then
A18: p+*I halts_on s+*I by Th5,A17,A16;
A19: now
      let x be set;
      assume x in dom DataPart JAt;
      then
A20:  x in dom (JAt) /\ D by RELAT_1:90;
      then
A21:  x in dom JAt by XBOOLE_0:def 4;
A22:  x in D by A20,XBOOLE_0:def 4;
      per cases by A21,SCMFSA6A:44;
      suppose
A23:    x in dom J;
        dom J c= NAT by RELAT_1:def 18;
        then reconsider l=x as Element of NAT by A23;
        (DataPart JAt).l = (DataPart Comput(p1,s1,m1)).l by A22,
SCMFSA6A:37;
        hence (DataPart JAt).x = (DataPart Comput(p1,s1,m1)).x;
      end;
      suppose
A24:    x=intloc 0;
        then x in Int-Locations by SCMFSA_2:9;
        then
A25:    x in D by XBOOLE_0:def 3,SCMFSA_2:127;
        hence (DataPart Comput(p1,s1,m1)).x
           = Comput(p1,s1,m1).x by FUNCT_1:72
          .=1 by A16,A24,Def3,A17,A8
          .=JAt.x by A24,SCMFSA6A:46
          .=(DataPart JAt).x by A25,FUNCT_1:72;
      end;
      suppose
        x = IC SCM+FSA;
        hence (DataPart JAt).x = (DataPart Comput(p1,s1,m1)).x by
A20,SCMFSA6A:37,XBOOLE_0:def 4;
      end;
    end;
    take m;
     IC Comput(p,s,m) in NAT;
    hence IC Comput(p,s,m) in dom p by PARTFUN1:def 4;
A26: Directed I c= I ';' J by SCMFSA6A:55;
     then
A27: Directed I c= p by A3,A5,XBOOLE_1:1;
A28: s1 +* Directed I = s +* (I +* Directed I) by FUNCT_4:15
      .= s +* Directed I by A12,FUNCT_4:20
      .= s +* Initialized (I ';' J) +* Directed I by A1,LATTICE2:8
      .= s +* (Initialized (I ';' J) +* Directed I) by FUNCT_4:15
      .= s +* Initialized (I ';' J) by A26,A13,LATTICE2:8,XBOOLE_1:1
      .= s by A1,LATTICE2:8;
:::B22: p1 +* Directed I = p;
A29: JAt c= s3 by FUNCT_4:26;
    then dom JAt c= dom s3 by GRFUNC_1:8;
    then dom JAt c= the carrier of SCM+FSA by PARTFUN1:def 4;
    then dom DataPart JAt c= (the carrier of SCM+FSA) /\ D by A11,XBOOLE_1:26;
    then dom DataPart JAt c= dom Comput(p1,s1,m1) /\ D by
PARTFUN1:def 4;
    then dom DataPart JAt c= dom (DataPart Comput(p1,s1,m1)) by
RELAT_1:90;
    then DataPart s3 = DataPart Comput(p1,s1,m1) +* DataPart JAt &
DataPart
    JAt c= DataPart Comput(p1,s1,m1) by A19,FUNCT_4:75,GRFUNC_1:8;
    then
A30:   DataPart Comput(p1,s1,m1) = DataPart s3 by LATTICE2:8;

   Comput(p +* I, (s +* Initialized I),m1),
      Comput(p +* (I ';' J), (s +* Initialized (I ';' J)),m1)
       equal_outside NAT by A16,A18,Th24;
    then Comput(p1,s1,m1), Comput(p,s,m1) equal_outside NAT
      by A2,A16,A4;
    then
A31:   DataPart Comput(p,s,m1) = DataPart s3 by
COMPOS_1:138,A30;
A32:  Initialized I c= s+*Initialized I by FUNCT_4:26;
  I c= p+*I by FUNCT_4:26;
  then
  p +* I halts_on s +* I by A16,Th5,A32;
    then
A33: DataPart Comput(p, s,m1 + 1) = DataPart s3
     by A15,A28,Th22,A31,FUNCT_4:26,A27;
A34: ProgramPart JAt = J by SCMFSA6A:33;
A35: Comput(p,s,m1 + 1 + m3) = Comput(p,Comput(p,s,m1 + 1),m3) by EXTPRO_1:5;
A36: Reloc(J,card I) c= p by A9,A3,A5,XBOOLE_1:1;
 IC Comput(p, s,LifeSpan(p +* I,s +* I) + 1) = card I
     by A15,A18,A28,Th21,FUNCT_4:26,A27;
    then
A37: IncAddr(CurInstr(p3,Comput(p3,s3,m3)),card I)
          = CurInstr(p,Comput(p,s,m1 + 1 + m3))
        by A35,A33,A14,Th12,A7,A36;
    p3 halts_on s3 by A29,EXTPRO_1:def 10,A34,A7;
    then CurInstr(p,Comput(p,s,m))
     = IncAddr (halt SCM+FSA,card I) by A37,EXTPRO_1:def 14
      .= halt SCM+FSA by COMPOS_1:93;
    hence thesis;
  end;
end;

theorem Th26:
  for I being keepInt0_1 Program of SCM+FSA st p+*I halts_on s+*I
  for J being InitClosed Program of SCM+FSA st
   Initialized (I ';' J) c= s & I ';' J c= p
for k being Element of NAT holds Comput(p +* I +* J,
(Result(p +* I,s +*I) +* Initialized J ),k) +*
  Start-At (IC Comput(p +* I +* J, (
  Result(p +* I,s +*I) +* Initialized J ),k) + card I,SCM+FSA),
  Comput(p +* (I ';' J), (s +* (I ';' J)),
  LifeSpan(p +* I,s +* I)+1+k) equal_outside NAT
proof
  let I be keepInt0_1 Program of SCM+FSA;
  assume
A1: p+*I halts_on s+*I;
  set ISA0 = Initialized I;
  let J be InitClosed Program of SCM+FSA;
  set sISA0 = s +* ISA0,
      pISA0 = p +* I;
A2: I c= pISA0 by FUNCT_4:26;
A3: ISA0 c= sISA0 by FUNCT_4:26;
  set RI = Result(p +* I,s +* ISA0),
      pRI = p +* I;
  set JSA0 = Initialized J;
  set RIJ = RI +* JSA0,
      pRIJ = pRI +* J;
  set sIJSA0 = s +* Initialized (I ';' J),
      pIJSA0 = p +* (I ';' J);
  defpred X[Nat] means Comput(pRIJ, RIJ,$1) +* Start-At (IC
  Comput(pRIJ, RIJ,$1) + card I,SCM+FSA),
  Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,sISA0)+1+$1)
  equal_outside NAT;
  assume Initialized (I ';' J) c= s;
  then
A4: s = sIJSA0 by FUNCT_4:79;
  assume
A5: I ';' J c= p;
   then
A6: pIJSA0 = p by FUNCT_4:79;
A7: sIJSA0 = s +* ((I ';' J) +* iS) by FUNCT_4:15
    .= s +*(I ';' J) +* iS by FUNCT_4:15;
  then
A8: sIJSA0 = s +*iS +*(I ';' J) by Th19;
  then
A9: (I ';' J) c= s by A4,FUNCT_4:26;
A10: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT;
    set k1 = k+1;
    set CRk = Comput(pRIJ, RIJ,k);
    set CRSk = IncIC(CRk,card I);
    set CIJk = Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,
sISA0)+1+k);
    set CRk1 = Comput(pRIJ, RIJ,k1);
    set CRSk1 = CRk1 +* Start-At (IC CRk1 + card I,SCM+FSA);
    set CIJk1 = Comput(pIJSA0, sIJSA0,LifeSpan(pISA0
,sISA0)+1+k1);
    assume
A11: Comput(pRIJ, RIJ,k) +* Start-At (IC Comput(pRIJ,
RIJ,k) + card I,SCM+FSA)
    , Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,sISA0)+1+
k) equal_outside NAT
;
A12: IncAddr(CurInstr(pRIJ,CRk), card I)
 = CurInstr(pIJSA0,CIJk)
    proof
A13:   J c= pRIJ by FUNCT_4:26;
A14:   JSA0 c= RIJ by FUNCT_4:26;
A15:    Reloc(J, card I) c= I ';' J by FUNCT_4:26;
     I ';' J c= pIJSA0 by FUNCT_4:26;
     then
A16: Reloc(J, card I) c= pIJSA0 by A15,XBOOLE_1:1;
A17:  pIJSA0/.IC CIJk = pIJSA0.IC CIJk by PBOOLE:158;
     IC CIJk = IC CRSk by A11,COMPOS_1:24;
      then
A18:  CurInstr(pIJSA0,CIJk) = pIJSA0.IC CRSk by A17
        .= pIJSA0.(IC CRk + card I) by FUNCT_4:121;
      reconsider ii = IC CRk as Element of NAT;
A19:  Reloc(J, card I) = Shift(IncAddr(J, card I), card I) by COMPOS_1:121;
A20:  IC CRk in dom J by Def1,A13,A14;
      then
A21:  ii in dom IncAddr(J, card I) by COMPOS_1:def 40;
      then
A22:  Shift(IncAddr(J, card I), card I).(IC CRk + card I) = IncAddr(J,
      card I).ii by VALUED_1:def 12
        .= IncAddr(J/.ii, card I) by A20,COMPOS_1:def 40;
      dom Shift(IncAddr(J, card I), card I) = { il+card I where il is
      Element of NAT: il in dom IncAddr(J, card I)} by VALUED_1:def 12;
      then
A23:  IC CRk + card I in dom Shift(IncAddr(J, card I), card I) by A21;
A24:   J/.ii = J.IC CRk by A20,PARTFUN1:def 8
        .= pRIJ.IC CRk by A20,GRFUNC_1:8,A13;
       CurInstr(pRIJ,CRk) = pRIJ.IC CRk by PBOOLE:158;
      hence
      IncAddr(CurInstr(pRIJ,CRk), card I)
         = pIJSA0.(IC CRk + card I) by A22,A19,A23,GRFUNC_1:8,A24,A16
:::A12:  Reloc(J, card I) = Shift(IncAddr(J, card I), card I) by COMPOS_1:121;
        .= CurInstr(pIJSA0,CIJk) by A18;
    end;
    CIJk, CRSk equal_outside NAT by A11,FUNCT_7:28;
    then Exec(CurInstr(pIJSA0,CIJk), CIJk),
     Exec(IncAddr(CurInstr(pRIJ,CRk),card I), CRSk)
    equal_outside NAT by A12,AMISTD_2:def 20;
    then
A25: Exec(CurInstr(pIJSA0,CIJk), CIJk),
     IncIC(Following(pRIJ,CRk),card I)
        equal_outside NAT by AMISTD_5:4;
    CIJk1 = Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,
sISA0)+1+k+1);
    then
A26: CIJk1 = Following(pIJSA0,CIJk) by EXTPRO_1:4;
A27: now
      let a be Int-Location;
      thus CRSk1.a = CRk1.a by SCMFSA_3:11
        .= (Following(pRIJ,CRk)).a by EXTPRO_1:4
        .= (Following(pRIJ,CRk) +*
        Start-At (IC Following(pRIJ,CRk) + card I,SCM+FSA)).a
        by SCMFSA_3:11
        .= CIJk1.a by A26,A25,SCMFSA10:92;
    end;
A28: now
      let f be FinSeq-Location;
      thus CRSk1.f = CRk1.f by SCMFSA_3:12
        .= (Following(pRIJ,CRk)).f by EXTPRO_1:4
        .= (Following(pRIJ,CRk) +* Start-At (
        IC Following(pRIJ,CRk) + card I,SCM+FSA)).f
         by SCMFSA_3:12
        .= CIJk1.f by A26,A25,SCMFSA10:93;
    end;
    IC CRSk1 = IC CRk1 + card I by FUNCT_4:121
      .= IC Following(pRIJ,CRk) + card I by EXTPRO_1:4;
    then
    IC CRSk1 =
     IC (Following(pRIJ,CRk) +* Start-At (IC
     Following(pRIJ,CRk) + card I
    ,SCM+FSA)) by FUNCT_4:121
      .= IC CIJk1 by A26,A25,COMPOS_1:24;
    hence thesis by A27,A28,SCMFSA10:91;
  end;
A29: iS c= s by A4,A7,FUNCT_4:26;
  then
A30: sIJSA0 = s +* (I ';' J) by A8,FUNCT_4:79;
A31: sISA0 = s +*(I +*iS) by FUNCT_4:15
    .= s +* I +*iS by FUNCT_4:15
    .= s +* iS +*I by Th19
    .= s +* I by A29,FUNCT_4:79;
A32:  Directed I c= I ';' J by SCMFSA6A:55;
  then
A33: Directed I c= s by A9,XBOOLE_1:1;
A34: Directed I c= p by A32,A5,XBOOLE_1:1;
A35: now
    set s2 = Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,sISA0)+1+0);
    set s1 = RIJ +* Start-At (IC RIJ + card I,SCM+FSA);
A36: Initialized J = Initialize(J +* ((intloc 0) .--> 1))
    by FUNCT_4:15;
A37: RIJ = Initialize(RI +* (J +*(intloc 0 .--> 1))) by FUNCT_4:15,A36;
    thus IC s1 = IC RIJ + card I by FUNCT_4:121
    .= IC Initialize(RI +* (J +*(intloc 0 .--> 1))) + card I by A37
      .=  0 + card I by FUNCT_4:121
      .= IC s2 by A1,A4,A7,A33,A31,Th21,FUNCT_4:26,A34,A6;
A38: DataPart Comput(p,s,LifeSpan(pISA0,sISA0)) =
DataPart Comput(p, s,
    LifeSpan(pISA0,sISA0)+1) by A1,A4,A7,A33,A31,Th22,FUNCT_4:26,A34;
    hereby
      let a be Int-Location;
      not a in dom Start-At (IC RIJ + card I,SCM+FSA) by SCMFSA6B:9;
      then
A39:  s1.a = RIJ.a by FUNCT_4:12;
A40:  Comput(pISA0, sISA0,LifeSpan(pISA0,sISA0)).a =
Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,sISA0)).a
              by A1,A31,Th24,SCMFSA10:92
        .= s2.a by A4,A38,SCMFSA6A:38,A6;
      per cases;
      suppose
        a <> intloc 0;
        then not a in dom JSA0 by SCMFSA6A:48;
        hence s1.a = RI.a by A39,FUNCT_4:12
          .= s2.a by A1,A31,A40,EXTPRO_1:23;
      end;
      suppose
A41:    a = intloc 0;
        then a in dom JSA0 by SCMFSA6A:45;
        hence s1.a = JSA0.a by A39,FUNCT_4:14
          .=1 by A41,SCMFSA6A:46
          .=s2.a by A40,A41,Def3,A2,A3;
      end;
    end;
    let f be FinSeq-Location;
A42: not f in dom JSA0 by SCMFSA6A:49;
    not f in dom Start-At (IC RIJ + card I,SCM+FSA) by SCMFSA6B:10;
    hence s1.f = RIJ.f by FUNCT_4:12
      .= RI.f by A42,FUNCT_4:12
      .= Comput(pISA0, sISA0,LifeSpan(pISA0,sISA0)).f by A1,A31,EXTPRO_1:23
      .= Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,sISA0)).f
       by A1,A31,Th24,SCMFSA10:93
      .= s2.f by A4,A38,SCMFSA6A:38,A6;
  end;
  Comput(pRIJ, RIJ,0) = RIJ by EXTPRO_1:3;
  then
A43: X[0] by A35,SCMFSA10:91;
  for k being Element of NAT holds X[k] from NAT_1:sch 1(A43, A10);
  hence thesis by A31,A30;
end;

theorem Th27:
  for I being keepInt0_1 Program of SCM+FSA
   st not p+*I halts_on s+*Initialized I
 for J being Program of SCM+FSA, k being Element of NAT
  holds Comput(p +* I, (s +* Initialized I),k),
Comput(p +* (I ';' J), (s +* Initialized (I
  ';' J)),k) equal_outside NAT
proof
  let I be keepInt0_1 Program of SCM+FSA;
  assume
A1: not p+*I halts_on s+*Initialized I;
  set s1 = s +* Initialized I,
      p1 = p +* I;
A2: I c= p1 by FUNCT_4:26;
A3: Initialized I c= s1 by FUNCT_4:26;
  let J be Program of SCM+FSA;
  set s2 = s +* Initialized (I ';' J),
      p2 = p +* (I ';' J);
A4: I ';' J c= p2 by FUNCT_4:26;
  defpred X[Nat] means Comput(p1, s1,$1), Comput(p2,(s2),$1)
  equal_outside NAT;
A5: for m st X[m] holds X[m+1]
  proof
    dom(I ';' J) = dom Directed I \/ dom Reloc(J, card I)
    by FUNCT_4:def 1
      .= dom I \/ dom Reloc(J, card I) by FUNCT_4:105;
    then
A6: dom I c= dom(I ';' J) by XBOOLE_1:7;
    set sx = s2,
        px = p2;
    let m;
A7: Comput(p1,s1,m+1) = Following(p1,
Comput(p1,s1,m)) by EXTPRO_1:4
      .= Exec(CurInstr(p1,Comput(p1,s1,m)),
      Comput(p1,s1,m));
A8: Comput(px,sx,m+1) = Following(px,
Comput(px,sx,m)) by EXTPRO_1:4
      .= Exec(CurInstr(px,Comput(px,sx,m)),
      Comput(px,sx,m));
    assume
A9: Comput(p1,s1,m), Comput(p2,(s2),m)
equal_outside NAT;
    then
A10: IC(Comput(p1,s1,m)) = IC(Comput(px,sx,m)) by
COMPOS_1:24;
A11: IC Comput(p1,s1,m) in dom I by Def1,A2,A3;
A12:  p1/.IC Comput(p1,s1,m) = p1.IC Comput(p1,s1,m) by PBOOLE:158;
A13:  px/.IC Comput(px,sx,m) = px.IC Comput(px,sx,m) by PBOOLE:158;
A14: CurInstr(p1,Comput(p1,s1,m))
 = I.IC(Comput(p1,s1,m)) by A11,A12,GRFUNC_1:8,A2;
    then I.IC(Comput(p1,s1,m)) <> halt SCM+FSA by A1,EXTPRO_1:30;
    then
    CurInstr(p1,Comput(p1,s1,m))
     = (I ';' J).IC(Comput(p1,s1,m)) by A11,A14,SCMFSA6A:54
      .= CurInstr(px,Comput(px,sx,m))
      by A10,A11,A6,A13,GRFUNC_1:8,A4;
    hence thesis by A9,A7,A8,AMISTD_2:def 20;
  end;
A15: Comput(p1, s1,0) = s1 & Comput(p2,(s2),0) =
s2 by EXTPRO_1:3;
A16: s+*iS+*I, s+*iS equal_outside NAT & s+*iS, s+*iS+*(I ';' J)
  equal_outside NAT by FUNCT_7:28,132;
A17: s2 = s +* ((I ';' J) +* iS) by FUNCT_4:15
    .= s +* (I ';' J) +* iS by FUNCT_4:15
    .= s+* iS +*(I ';' J) by Th19;
  s1 = s +* (I +* iS) by FUNCT_4:15
    .= s +* I +* iS by FUNCT_4:15
    .= s+*iS+*I by Th19;
  then
A18: X[0] by A17,A16,A15,FUNCT_7:29;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A18, A5 );
end;

theorem Th28:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
  InitHalting Program of SCM+FSA holds
   LifeSpan(p +* (I ';' J),s +* Initialized (I ';' J))
     = LifeSpan(p+*I,s +* Initialized I) + 1 + LifeSpan(p +* I +* J,
           Result(p+*I,s +* Initialized I) +* Initialized J)
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  set inI=Initialized I;
  set inIJ=Initialized (I ';' J);
  set inJ=Initialized J;
A1: inJ c= Result(p+* (I ';' J)+*I,s +* inIJ +* I) +* inJ & inJ c=
Result(p +* I,s +* inI) +* inJ
  by FUNCT_4:26;
A2: J c= p +* (I ';' J) +* I +* J & J c= p +* I +* J by FUNCT_4:26;
  s +* inIJ, s +* inIJ +* I equal_outside NAT & s +* inI, s +* inIJ
  equal_outside NAT by FUNCT_7:132,SCMFSA6A:53;
  then
A3: s +* inI, s +* inIJ +* I equal_outside NAT by FUNCT_7:29;
A4: inI c= s +* inI & inI c= s +* inIJ +* I by FUNCT_4:26,SCMFSA6A:52;
A5: I c= p +* I & I c= p +* (I ';' J) +* I by FUNCT_4:26;
  then Result(p +* I,s +* inI), Result(p+* (I ';' J)+*I,s +* inIJ +* I)
   equal_outside NAT by A3,Th15,A4;
  then Result(p+* (I ';' J)+*I,s +* inIJ +* I), Result(p +* I,s +* inI)
     equal_outside NAT by FUNCT_7:28;
  then
A6: Result(p+* (I ';' J)+*I,s +* inIJ +* I) +* inJ, Result(
p +* I,s +* inI) +* inJ equal_outside
  NAT by FUNCT_7:106;
A7:  I ';' J c= p +* (I ';' J) by FUNCT_4:26;
  inIJ c= s +* inIJ by FUNCT_4:26;
  then
A8: LifeSpan(p +* (I ';' J),s +* inIJ)
    = LifeSpan(p+* (I ';' J)+*I,s +* inIJ +* I) + 1 +
    LifeSpan(p+* (I ';' J)+*I+*J,
    Result(p+* (I ';' J)+*I,s +* inIJ +* I) +* inJ) by Th25,A7;
  LifeSpan(p +* I,s +* inI) = LifeSpan(p+* (I ';' J)+*I,
  s +* inIJ +* I) by A4,A3,Th15,A5;
  hence thesis by A8,A1,A6,Th15,A2;
end;

theorem Th29:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds
 IExec(I ';' J,p,s) = IExec(J,p,IExec(I,p,s)) +*
  Start-At (IC IExec(J,p,IExec(I,p,s)) + card I,SCM+FSA)
proof
  set D = (Data-Locations SCM+FSA);
  set A = NAT;
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  set ps = s | NAT;
  set s1 = s +* Initialized I,
      p1 = p +* I;
A1: I c= p1 by FUNCT_4:26;
  set s2 = s +* Initialized (I ';' J),
      p2 = p +* (I ';' J);
A2: I ';' J c= p2 by FUNCT_4:26;
  set s3 = Comput(p1, s1,LifeSpan(p1,s1)) +* Initialized J,
      p3 = p1 +* J;
A3: Initialized J c= s3 by FUNCT_4:26;
A4: J c= p3 by FUNCT_4:26;
  set m1 = LifeSpan(p1,s1);
  set m3 = LifeSpan(p3,s3);
A5: Initialized (I ';' J) c= s2 by FUNCT_4:26;
A6: I ';' J c= p2 by FUNCT_4:26;
  s2 = s +* ((I ';' J) +* iS) by FUNCT_4:15
    .= s +* (I ';' J) +* iS by FUNCT_4:15;
  then
A7: iS c= s2 by FUNCT_4:26;
A8: s1 +* (I ';' J) = s +* (Initialized I +* (I ';' J)) by FUNCT_4:15
    .= s2 by SCMFSA6A:58;
A9:  Initialized I c= s+*Initialized I by FUNCT_4:26;
  I c= p+*I by FUNCT_4:26;
  then
A10: p1 halts_on s1 by Th5,A9;
A11: Initialized J c= s3 by FUNCT_4:26;
A12: Comput(p1,s1,m1) +* Initialized J, Comput(p1,s1,
m1) +* ps +*
  Initialized J equal_outside dom ps by FUNCT_7:31,106;
  then
A13: Comput(p1,s1,m1) +* ps +* Initialized J,
       Comput(p1,s1,m1) +*
  Initialized J equal_outside dom ps by FUNCT_7:28;
A14: IExec(I,p,s) = Result(p1,s1) +* ps & Initialized J c= Result(
p1,s1) +*
  Initialized J by FUNCT_4:26,SCMFSA6B:def 1;
A15: dom ps = dom s /\ A by RELAT_1:90
    .= (Data-Locations SCM+FSA \/ {IC SCM+FSA} \/ A) /\ A by
COMPOS_1:172
    .= A by XBOOLE_1:21;
A16: Initialized J c= IExec(I,p,s) +* Initialized J by FUNCT_4:26;
A17: J c= p +* J by FUNCT_4:26;
A18: Initialized J c= IExec(I,p,s) +* Initialized J & Initialized J c= s3 by
FUNCT_4:26;
A19: J c= p +* J & J c= p3 by FUNCT_4:26;
A20: Initialized J c= s3 by FUNCT_4:26;
A21: Initialized I c= s1 by FUNCT_4:26;
A22: I c= p1 by FUNCT_4:26;
A23: s3 = Result(p1,s1) +* Initialized J by A21,Th5,EXTPRO_1:23,A22;
          Result(p1,s1) = Comput(p1,s1,m1)
         by A21,Th5,EXTPRO_1:23,A1;
  then
A24: IC Result(p1 +* J,Result(p1,s1) +* Initialized J)
 = IC Result(p +* J,IExec(I,p,s) +*
  Initialized J) by A15,A12,A14,A16,Th15,COMPOS_1:24,A17,A4;
A25: Initialized I c= s2 +* I by FUNCT_4:26,SCMFSA6A:52;
A26: I c= p2 +* I by FUNCT_4:26;
  s1,s2 equal_outside A & s2,s2 +* I equal_outside A by FUNCT_7:132,SCMFSA6A:53
;
  then s1,s2 +* I equal_outside A by FUNCT_7:29;
  then
A27: LifeSpan(p2 +* I,s2 +* I) = m1 by A21,A25,Th15,A22,A26;
  then
A28: Reloc(J,card I) c= Comput(p2,s2,m1+1) by A5,Th25,A6;
     Reloc(J,card I) c= I ';' J by FUNCT_4:26;
     then
A29: Reloc(J,card I) c= p2 by A2,XBOOLE_1:1;
A30: I +* (I ';' J) = I ';' J by SCMFSA6A:57;
A31: s2 +* I +* (I ';' J) = s2 +* (I +* (I ';' J)) by FUNCT_4:15;
A32: s2 +* (I ';' J) = s +* (Initialized (I ';' J) +* (I ';' J)) by FUNCT_4:15;
A33: Initialized (I ';' J) +* (I ';' J) = Initialized (I ';' J)
       by LATTICE2:8,SCMFSA6A:26;
  s2 +*(I +* iS) = s2 +*I +* iS by FUNCT_4:15
    .=s2 +* iS +* I by Th19
    .=s2 +* I by A7,FUNCT_4:79;
  then I +* iS c= s2 +* I by FUNCT_4:26;
  then
A34: Initialized I c= s2 +* I by FUNCT_4:15;
A35: p2 +* I +* (I ';' J) = p2 +* (I +* (I ';' J)) by FUNCT_4:15
        .= p2 +* (I ';' J) by SCMFSA6A:57
        .= p2 by FUNCT_4:99
        .= p+*(I +* (I ';' J)) by SCMFSA6A:57
        .= p1+*(I ';' J) by FUNCT_4:15;
A36:
  Comput(p1,s1,m1),
  Comput(p2 +* I +* (I ';' J), ((s2 +* (I +*
    (I ';' J)))),m1)  equal_outside NAT
            by A21,A10,A8,Th18,A33,A32,A30,A1,A35;

:::  set m1 = LifeSpan(p1,s1);

  I c= p2+*I by FUNCT_4:26;
  then p2 +* I halts_on s2+*I by Th5,A34;
  then DataPart Comput(p2 +* I, (s2 +* I),m1)
    = DataPart Comput(p2 +* I +* (I ';' J), ((s2 +* (I +*
(I ';' J)))),m1) by A31,A25,A27,Th18,COMPOS_1:138,A26
    .= DataPart Comput(p1,s1,m1)
            by COMPOS_1:138,A36;
  then
A37: DataPart(Comput(p2 +* I, (s2 +* I),m1) +* Initialized J) =
DataPart
  Comput(p1,s1,m1) +* DataPart Initialized J by FUNCT_4:75
    .= DataPart(Comput(p1,s1,m1) +* Initialized J) by FUNCT_4:75;
A38: IC Comput(p2,s2,m1+1) =  card I &
    DataPart Comput(p2,s2,m1+1)
  = DataPart(Comput(p2 +* I, (s2 +* I),m1) +* Initialized J)
by A5,A27,Th25,A6;
  then
A39: DataPart Comput(p2, Comput(p2,s2,m1+1),m3)
 = DataPart Comput(p3,s3, m3) by A28,A11,A37,Th12,A4,A29;
A40: IC Comput(p2, Comput(p2,s2,m1+1),m3) = IC Comput(p3,s3,m3) + card I
      by A38,A28,A11,A37,Th12,A4,A29;
A41:  Initialized(I ';' J) c= s2 by FUNCT_4:26;
  (I ';' J) c= p+*(I ';' J) by FUNCT_4:26;
  then
A42: p2 halts_on s2 by Th5,A41;
A43: IExec(I ';' J,p,s) = Result(p +* (I ';' J),s +*
Initialized (I ';' J)) +* ps by SCMFSA6B:def 1
    .= Comput(p2,s2,LifeSpan(p2,s2)) +* ps by A42,
EXTPRO_1:23
    .= Comput(p2,s2,m1+1+m3) +* ps by A23,Th28;
  IExec(I,p,s) = Result(p+*I,s +* Initialized I) +* ps
by SCMFSA6B:def 1
    .= Comput(p1,s1,m1) +* ps by A21,Th5,EXTPRO_1:23,A1;
  then
  Result(p+*J,IExec(I,p,s) +* Initialized J),
Result(p3,s3) equal_outside A by A15,A13,A18,Th15,A19;
  then
A44: Result(p+*J,IExec(I,p,s) +* Initialized
J) +* ps = Result(p3,s3) +* ps by A15,FUNCT_7:108;

A45: p3 halts_on s3 by Th5,A3,A4;
  IExec(I,p,s) | A = (Result(p+*I,s +* Initialized I)
+* ps) | A by SCMFSA6B:def 1
    .= ps by PBOOLE:157;
  then
A46: IExec(J,p,IExec(I,p,s)) = Result(p+*J,
IExec(I,p,s) +* Initialized J) +* ps by SCMFSA6B:def 1
    .= Comput(p3,s3,m3) +* ps by A44,A45,EXTPRO_1:23;
A47: dom ps misses D by A15,COMPOS_1:51;
  then
A48: DataPart IExec(I ';' J,p,s) = DataPart Comput(p2,s2,m1+1+m3)
by A43,FUNCT_4:76
    .= DataPart Comput(p3,s3,m3) by A39,EXTPRO_1:5
    .= DataPart IExec(J,p,IExec(I,p,s)) by A46,A47,FUNCT_4:76;
A49: s3 = Result(p1,s1) +* Initialized J
        by A21,Th5,EXTPRO_1:23,A1;
A50: IC IExec(I ';' J,p,s) = IC Result(p+*(I ';' J),s
+* Initialized (I ';' J)) by SCMFSA8A:7
    .= IC Comput(p2,s2,LifeSpan(p2,s2)) by A5,Th5,
EXTPRO_1:23,A2
    .= IC Comput(p2,s2,m1+1+m3) by A23,Th28
    .= IC Comput(p3,s3,m3) + card I by A40,EXTPRO_1:5
    .= IC Result(p3,s3) + card I by A20,Th5,EXTPRO_1:23,A4
    .= IC IExec(J,p,IExec(I,p,s)) + card I by A24,A49,SCMFSA8A:7;
  hereby
    reconsider l = IC IExec(J,p,IExec(I,p,s)) + card I as Element of NAT;
A51: dom Start-At(l,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
A52: now
      let x be set;
      assume
A53:  x in dom IExec(I ';' J,p,s);
      per cases by A53,SCMFSA6A:35;
      suppose
A54:    x is Int-Location;
        then x <> IC SCM+FSA by SCMFSA_2:81;
        then
A55:    not x in dom Start-At(l,SCM+FSA) by A51,TARSKI:def 1;
        IExec(I ';' J,p,s).x = IExec(J,p,IExec(I,p,s)).x
          by A48,A54,SCMFSA6A:38;
        hence
        IExec(I ';' J,p,s).x
         = (IExec(J,p,IExec(I,p,s)) +* Start-At (IC IExec(J,p
        ,IExec(I,p,s)) + card I,SCM+FSA)).x by A55,FUNCT_4:12;
      end;
      suppose
A56:    x is FinSeq-Location;
        then x <> IC SCM+FSA by SCMFSA_2:82;
        then
A57:    not x in dom Start-At(l,SCM+FSA) by A51,TARSKI:def 1;
        IExec(I ';' J,p,s).x = IExec(J,p,IExec(I,p,s)).x
         by A48,A56,SCMFSA6A:38;
        hence
        IExec(I ';' J,p,s).x = (IExec(J,p,IExec(I,p,s)) +*
           Start-At (IC IExec(J,p
        ,IExec(I,p,s)) + card I,SCM+FSA)).x by A57,FUNCT_4:12;
      end;
      suppose
A58:    x = IC SCM+FSA;
        then x in {IC SCM+FSA} by TARSKI:def 1;
        then
A59:    x in dom Start-At(l,SCM+FSA) by FUNCOP_1:19;
        thus IExec(I ';' J,p,s).x = (Start-At(l,SCM+FSA)).IC SCM+FSA
         by A50,A58,
FUNCOP_1:87
          .= (IExec(J,p,IExec(I,p,s)) +*
           Start-At (IC IExec(J,p,IExec(I,p,s)) + card
        I,SCM+FSA)).x by A58,A59,FUNCT_4:14;
      end;
      suppose
A60:    x is Element of NAT;
        then x <> IC SCM+FSA by COMPOS_1:3;
        then
A61:    not x in dom Start-At(l,SCM+FSA) by A51,TARSKI:def 1;
        IExec(I ';' J,p,s) | A = ps by A43,PBOOLE:157
          .= IExec(J,p,IExec(I,p,s)) | A by A46,PBOOLE:157;
        then IExec(I ';' J,p,s).x = IExec(J,p,IExec(I,p,s)).x
         by A60,SCMFSA6A:36;
        hence
        IExec(I ';' J,p,s).x
         = (IExec(J,p,IExec(I,p,s)) +* Start-At (IC IExec(J,p
        ,IExec(I,p,s)) + card I, SCM+FSA)).x by A61,FUNCT_4:12;
      end;
    end;
    dom IExec(I ';' J,p,s) = the carrier of SCM+FSA by PARTFUN1:def 4
      .= dom (IExec(J,p,IExec(I,p,s)) +*
      Start-At (IC IExec(J,p,IExec(I,p,s)) + card
    I,SCM+FSA)) by PARTFUN1:def 4;
    hence thesis by A52,FUNCT_1:9;
  end;
end;

registration
  let i be parahalting Instruction of SCM+FSA;
  cluster Macro i -> InitHalting;
  coherence;
end;

registration
  let i be parahalting Instruction of SCM+FSA, J be parahalting Program of
  SCM+FSA;
  cluster i ';' J -> InitHalting;
  coherence;
end;

registration
  let i be keeping_0 parahalting Instruction of SCM+FSA, J be InitHalting
  Program of SCM+FSA;
  cluster i ';' J -> InitHalting;
  coherence;
end;

registration
  let I, J be keepInt0_1 Program of SCM+FSA;
  cluster I ';' J -> keepInt0_1;
  coherence
  proof
    let s be State of SCM+FSA;
A1: Initialized(I ';' J) = (I ';' J) +* iS by FUNCT_4:15;
    assume
A2: Initialized (I ';' J) c= s;
    then
A3: s +* Initialized (I ';' J) = s by FUNCT_4:79;
    let p;
    assume
A4:  I ';' J c= p;
    then
A5: p +* (I ';' J) = p by FUNCT_4:79;
    iS c= (I ';' J) +* iS by FUNCT_4:26;
    then
A6: iS c= s by A2,A1,XBOOLE_1:1;
    s +*Initialized(I ';' J) = s +*(I ';' J) +* iS by A1,FUNCT_4:15
      .= s +* iS +*(I ';' J) by Th19
      .= s +* (I ';' J) by A6,FUNCT_4:79;
    then
A7: s=s +* (I ';' J) by A2,FUNCT_4:79;
A8: I c= p +* I by FUNCT_4:26;
A9: Initialized I c= s +* Initialized I by FUNCT_4:26;
    per cases;
    suppose
A10:   p+*I halts_on s+*Initialized I;
      let k be Element of NAT;
A11:   s +* Initialized I=s +* (I +* iS) by FUNCT_4:15
        .= s +*I +* iS by FUNCT_4:15
        .= s +* iS +* I by Th19
        .= s +* I by A6,FUNCT_4:79;
:::      hereby
        per cases;
        suppose
A12:       k <= LifeSpan(p+*I,s +* Initialized I);
A13:      Comput(p +* I, (s +* Initialized I),k).intloc 0 = 1
            by Def3,A8,A9;
          Comput(p +* I, (s +* Initialized I),k),
          Comput(p,s,k) equal_outside NAT
           by A3,A10,A12,Th24,A5;
          hence :::thesis
          (Comput(p,s,k)).intloc 0 = 1
           by SCMFSA10:92,A13;
        end;
        suppose
A14:      k > LifeSpan(p+*I,s +* Initialized I);
          set LS = LifeSpan(p+*I,s +* Initialized I)
;
          consider pp being Element of NAT such that
A15:      k = LS + pp and
A16:      1 <= pp by A14,FINSEQ_4:99;
          consider r being Nat such that
A17:      pp = 1 + r by A16,NAT_1:10;
          reconsider r as Element of NAT by ORDINAL1:def 13;
          set Rr = Comput(p +* I +* J,
          Result(p +* I,s +* I) +* Initialized J,r);
          set Sr = Start-At (IC Comput(p +* I +* J,
           (Result(p +* I,s +* I) +* Initialized J
          ),r) + card I, SCM+FSA);
A18:       Initialized J c=Result(p +* I,s +*I) +* Initialized J
                      by FUNCT_4:26;
          J c= p +* I +* J by FUNCT_4:26;
          then
A19:      Comput(p +* I +* J,
           Result(p +* I,s +*I) +* Initialized J,r).intloc 0 = 1
          by Def3,A18;
          dom Sr = {IC SCM+FSA} & intloc 0 <> IC SCM+FSA by FUNCOP_1:19
,SCMFSA_2:81;
          then not intloc 0 in dom Sr by TARSKI:def 1;
          then
A20:      (Rr +* Sr).intloc 0 = Rr.intloc 0 by FUNCT_4:12;
          Rr +* Sr,
          Comput(p +* (I ';' J), (s +* (I ';' J)),LS+1+r)
           equal_outside NAT by A2,A10,A11,Th26,A4;
          hence thesis by A7,A15,A17,A19,A20,SCMFSA10:92,A5;
        end;
:::      end;
    end;
    suppose
A21:  not p+*I halts_on s+*Initialized I;
      let k be Element of NAT;
      Comput(p +* I, (s +* Initialized I),k).intloc 0 = 1
       by Def3,A8,A9;
      hence thesis by A3,A21,Th27,SCMFSA10:92,A5;
    end;
  end;
end;

registration
  let j be keeping_0 parahalting Instruction of SCM+FSA, I be keepInt0_1
  InitHalting Program of SCM+FSA;
  cluster I ';' j -> InitHalting keepInt0_1;
  coherence;
end;

registration
  let i be keeping_0 parahalting Instruction of SCM+FSA, J be keepInt0_1
  InitHalting Program of SCM+FSA;
  cluster i ';' J -> InitHalting keepInt0_1;
  coherence;
end;

registration
  let j be parahalting Instruction of SCM+FSA, I be parahalting Program of
  SCM+FSA;
  cluster I ';' j -> InitHalting;
  coherence;
end;

registration
  let i,j be parahalting Instruction of SCM+FSA;
  cluster i ';' j -> InitHalting;
  coherence;
end;

theorem Th30:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds IExec(I ';' J,p,s).a
 = IExec(J,p,IExec(I,p,s)).
  a
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA, J be InitHalting Program
  of SCM+FSA;
  IExec(I ';' J,p,s)
   = IExec(J,p,IExec(I,p,s)) +* Start-At (IC IExec(J,p,IExec(I,p,s
)) + card I, SCM+FSA) & not a in dom
Start-At (IC IExec(J,p,IExec(I,p,s)) + card I, SCM+FSA) by Th29,SCMFSA6B:9;
  hence thesis by FUNCT_4:12;
end;

theorem Th31:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds IExec(I ';' J,p,s).f
 = IExec(J,p,IExec(I,p,s)).
  f
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA, J be InitHalting Program
  of SCM+FSA;
  IExec(I ';' J,p,s) = IExec(J,p,IExec(I,p,s)) +*
  Start-At (IC IExec(J,p,IExec(I,p,s
)) + card I, SCM+FSA) & not f in dom
Start-At (IC IExec(J,p,IExec(I,p,s)) + card I, SCM+FSA) by Th29,SCMFSA6B:10;
  hence thesis by FUNCT_4:12;
end;

theorem Th32:
  for I be keepInt0_1 InitHalting Program of SCM+FSA, s be State
  of SCM+FSA holds DataPart(Initialized IExec(I,p,s)) = DataPart IExec(I,p,s)
proof
  set IF = Data-Locations SCM+FSA;
  let I be keepInt0_1 InitHalting Program of SCM+FSA, s be State of SCM+FSA;
  set IE = IExec(I,p,s);
  now
A1: dom (Initialized IE) = the carrier of SCM+FSA by PARTFUN1:def 4;
A2: dom Initialized IE
      = Data-Locations SCM+FSA \/ {IC SCM+FSA} \/ NAT by COMPOS_1:172
     .= Data-Locations SCM+FSA \/ ({IC SCM+FSA} \/ NAT) by XBOOLE_1:4;
A3: dom IE = the carrier of SCM+FSA by PARTFUN1:def 4;
    hence dom DataPart Initialized IE = dom IE /\ IF by A1,RELAT_1:90
;
    then
A4: dom DataPart Initialized IE = Data-Locations SCM+FSA
by A1,A3,A2,XBOOLE_1:21;
    let x be set;
    assume
A5: x in dom DataPart Initialized IE;
    per cases by A5,A4,XBOOLE_0:def 3,SCMFSA_2:127;
    suppose
      x in Int-Locations;
      then reconsider x9 = x as Int-Location by SCMFSA_2:11;
      hereby
        per cases;
        suppose
A6:       x9 is read-write;
          thus (DataPart Initialized IE).x = (Initialized IE).x by A5,A4,
FUNCT_1:72
            .= IE.x by A6,SCMFSA6C:3;
        end;
        suppose
          x9 is read-only;
          then
A7:       x9 = intloc 0 by SF_MASTR:def 5;
          thus (DataPart Initialized IE).x = (Initialized IE).x9 by A5,A4,
FUNCT_1:72
            .= 1 by A7,SCMFSA6C:3
            .= IE.x by A7,Th17;
        end;
      end;
    end;
    suppose
      x in FinSeq-Locations;
      then reconsider x9 = x as FinSeq-Location by SCMFSA_2:12;
      thus (DataPart Initialized IE).x = (Initialized IE).x9
      by A5,A4,FUNCT_1:72
        .= IE.x by SCMFSA6C:3;
    end;
  end;
  hence thesis by FUNCT_1:68;
end;

theorem Th33:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j,p,s).a
 = Exec(j,IExec(I,p,s)).a
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mj = Macro j;
  set SA = Start-At (IC IExec(Mj,p,IExec(I,p,s)) + card I, SCM+FSA);
A1: not a in dom SA by SCMFSA6B:9;
A2: DataPart Initialized IExec(I,p,s) = DataPart IExec(I,p,s) by Th32;
  a in Int-Locations by SCMFSA_2:9;
  then
A3: a in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
  thus IExec(I ';' j,p,s).a = (IExec(Mj,p,IExec(I,p,s))+*SA).a by Th29
    .= IExec(Mj,p,IExec(I,p,s)).a by A1,FUNCT_4:12
    .= Exec(j, Initialized IExec(I,p,s)).a by SCMFSA6C:6
    .= (DataPart Exec(j, Initialized IExec(I,p,s))).a by A3,FUNCT_1:72

    .= (DataPart Exec(j, IExec(I,p,s))).a by A2,SCMFSA6C:5
    .= Exec(j, IExec(I,p,s)).a by A3,FUNCT_1:72;
end;

theorem Th34:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j,p,s).f
 = Exec(j,
    IExec(I,p,s)).f
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mj = Macro j;
  set SA = Start-At (IC IExec(Mj,p,IExec(I,p,s)) + card I, SCM+FSA);
A1: not f in dom SA by SCMFSA6B:10;
A2: DataPart Initialized IExec(I,p,s) = DataPart IExec(I,p,s) by Th32;
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A3: f in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
  thus IExec(I ';' j,p,s).f = (IExec(Mj,p,IExec(I,p,s))+*SA).f by Th29
    .= IExec(Mj,p,IExec(I,p,s)).f by A1,FUNCT_4:12
    .= Exec(j, Initialized IExec(I,p,s)).f by SCMFSA6C:6
    .= (DataPart Exec(j, Initialized IExec(I,p,s))).f by A3,FUNCT_1:72

    .= (DataPart Exec(j, IExec(I,p,s))).f by A2,SCMFSA6C:5
    .= Exec(j, IExec(I,p,s)).f by A3,FUNCT_1:72;
end;

definition
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  let p;
  pred I is_closed_onInit s,p means
  :Def4:
  for k being Element of NAT holds IC
  Comput(p +* I,s +* Initialized I,k) in dom I;
  pred I is_halting_onInit s,p means
  :Def5:
  p+*I halts_on s+*Initialized I;
end;

theorem Th35:
  for I being Program of SCM+FSA holds I is InitClosed iff for s
  being State of SCM+FSA,p holds I is_closed_onInit s,p
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is InitClosed;
    let s be State of SCM+FSA;
    let p;
A2: I c= p+*I by FUNCT_4:26;
A3: Initialized I c= s+*Initialized I by FUNCT_4:26;
    for k being Element of NAT holds
     IC Comput(p +* I, (s +* Initialized I),k) in dom I
      by A1,Def1,A2,A3;

    hence I is_closed_onInit s,p by Def4;
  end;
  assume
A4: for s being State of SCM+FSA,p holds I is_closed_onInit s,p;
  now
    let s be State of SCM+FSA;
    let p be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
    assume
  I c= p;
     then
A5:  p +* I = p by FUNCT_4:79;
    let k be Element of NAT;
    assume Initialized I c= s;
    then
A6: s = s +* Initialized I by FUNCT_4:79;
    I is_closed_onInit s,p by A4;
    hence IC Comput(p,s,k) in dom I by A6,Def4,A5;
  end;
  hence thesis by Def1;
end;

theorem Th36:
  for I being Program of SCM+FSA holds I is InitHalting iff for s
  being State of SCM+FSA,p holds I is_halting_onInit s,p
proof
  let I be Program of SCM+FSA;
A1: ProgramPart Initialized I = I by SCMFSA6A:33;
  hereby
    assume
A2: I is InitHalting;
    let s be State of SCM+FSA;
    let p;
A3:  I c= p+*I by FUNCT_4:26;
    Initialized I c= s +* Initialized I by FUNCT_4:26;
    then p+*I halts_on s+*Initialized I
     by A2,EXTPRO_1:def 10,A3,A1;
    hence I is_halting_onInit s,p by Def5;
  end;
  assume
A4: for s being State of SCM+FSA,p holds I is_halting_onInit s,p;
  now
    let s be State of SCM+FSA;
    assume Initialized I c= s;
    then
A5: s = s +* Initialized I by FUNCT_4:79;
    let p;
    assume
  I c= p;
    then
A6:  p +* I = p by FUNCT_4:79;
    I is_halting_onInit s,p by A4;
    hence p halts_on s by A5,Def5,A6;
  end;
  then Initialized I is halting by EXTPRO_1:def 10,A1;
  hence thesis by Def2;
end;

theorem Th37:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does not destroy a & I is_closed_onInit s,p &
 Initialized I c= s & I c= p
   holds for k being Element of NAT holds Comput(p,s,k).a =
s.a
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA,a be Int-Location;
  assume
A1: I does not destroy a;
  defpred P[Nat] means Comput(p,s,$1).a = s.a;
  assume
A2: I is_closed_onInit s,p;
  assume Initialized I c= s;
  then
A3: s +* Initialized I = s by FUNCT_4:79;
  assume
A4: I c= p;
   then
A5: p +* I = p by FUNCT_4:79;
A6: now
    let k be Element of NAT;
    assume
A7: P[k];
    set l = IC Comput(p,s,k);
A8: l in dom I by A2,A3,Def4,A5;
    then p.l = I.l by GRFUNC_1:8,A4;
    then p.l in rng I by A8,FUNCT_1:def 5;
    then
A9: p.l does not destroy a by A1,SCMFSA7B:def 4;
    Comput(p, s,k + 1).a = (Following(p,
    Comput(p,s,k))).a by EXTPRO_1:4
      .= Exec(p.l,Comput(p,s,k)).a by PBOOLE:158
      .= s.a by A7,A9,SCMFSA7B:26;
    hence P[k+1];
  end;
A10: P[0] by EXTPRO_1:3;
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A10,A6);
end;

registration
  cluster InitHalting good Program of SCM+FSA;
  existence
  proof
    take Stop SCM+FSA;
    thus thesis;
  end;
end;

registration
  cluster InitClosed good -> keepInt0_1 Program of SCM+FSA;
  correctness
  proof
    let I be Program of SCM+FSA;
    assume
A1: I is InitClosed good;
    then
A2: I does not destroy intloc 0 by SCMFSA7B:def 5;
    now
      let s be State of SCM+FSA;
      assume
A3:   Initialized I c= s;
      let p;
      assume
A4:    I c= p;
      let k be Element of NAT;
      thus Comput(p,s,k).intloc 0 = s.intloc 0
           by A2,A3,Th37,A1,Th35,A4
        .=1 by A3,Th7;
    end;
    hence thesis by Def3;
  end;
end;

registration
  cluster Stop SCM+FSA -> InitHalting good;
  coherence;
end;

theorem
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being InitHalting Program of SCM+FSA, a being
  Int-Location holds IExec(i ';' J,p,s).a
   = IExec(J,p,Exec(i,Initialized s)).a
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  let a be Int-Location;
  thus IExec(i ';' J,p,s).a = IExec(J,p,IExec(Macro i,p,s)).a by Th30
    .= IExec(J,p,Exec(i,Initialized s)).a by SCMFSA6C:6;
end;

theorem
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being InitHalting Program of SCM+FSA, f being
  FinSeq-Location holds IExec(i ';' J,p,s).f
   = IExec(J,p,Exec(i,Initialized s)).f
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  let f be FinSeq-Location;
  thus IExec(i ';' J,p,s).f = IExec(J,p,IExec(Macro i,p,s)).f by Th31
    .= IExec(J,p,Exec(i,Initialized s)).f by SCMFSA6C:6;
end;

theorem Th40:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds I
  is_closed_onInit s,p iff I is_closed_on Initialized s,p
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  set s1=s +* Initialized I, s2=Initialized s +* (Initialize I),
      p1 = p +* I;
A1: ProgramPart I = I by RELAT_1:209;
A2: s1 = s2 by SCMFSA8A:13;
  I is_closed_onInit s,p iff for k be Element of NAT
   holds IC Comput(p1,s1,k) in dom I by Def4;
  hence thesis by A2,SCMFSA7B:def 7,A1;
end;

theorem Th41:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds I
  is_halting_onInit s,p iff I is_halting_on Initialized s,p
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  set s1=s +* Initialized I, s2=Initialized s +* (Initialize I),
      p1 = p +* I;
A1: ProgramPart I = I by RELAT_1:209;
A2: s1 = s2 by SCMFSA8A:13;
  I is_halting_onInit s,p iff p1 halts_on s1 by Def5;
  hence thesis by A2,SCMFSA7B:def 8,A1;
end;

theorem
  for I be Program of SCM+FSA, s be State of SCM+FSA holds IExec(I,p,s) =
  IExec(I,p,Initialized s)
proof
  let I be Program of SCM+FSA,s be State of SCM+FSA;
  set sp= s|NAT;
A1:  s+*Initialized I = Initialized s+*Initialized I by SCMFSA8A:8;
  thus IExec(I,p,s) = Result(p+*I,s+*Initialized I) +*sp
by SCMFSA6B:def 1
    .= Result(p +* I,Initialized s+*
Initialized I) +* (Initialized s) | NAT by A1,SCMFSA8C:36
    .= IExec(I,p,Initialized s) by SCMFSA6B:def 1;
end;

theorem Th43:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & I is_closed_onInit s,p & I
  is_halting_onInit s,p holds if=0(a,I,J) is_closed_onInit s,p & if=0(a,I,J)
  is_halting_onInit s,p
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set Is = Initialized s;
  assume s.a = 0;
  then
A1: Is.a =0 by SCMFSA6C:3;
  assume I is_closed_onInit s,p;
  then
A2: I is_closed_on Is,p by Th40;
  assume I is_halting_onInit s,p;
  then I is_halting_on Is,p by Th41;
  then if=0(a,I,J) is_closed_on Is,p &
   if=0(a,I,J) is_halting_on Is,p by A1,A2,
SCMFSA8B:16;
  hence thesis by Th40,Th41;
end;

theorem Th44:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & I is_closed_onInit s,p & I
is_halting_onInit s,p holds IExec(if=0(a,I,J),p,s)
 = IExec(I,p,s) +* Start-At( (card I + card J + 3),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  set Is = Initialized s;
  assume I is_closed_onInit s,p;
  then
A2: I is_closed_on Is,p by Th40;
  assume I is_halting_onInit s,p;
  then I is_halting_on Is,p by Th41;
  hence thesis by A1,A2,SCMFSA8B:17;
end;

theorem Th45:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a <> 0 & J is_closed_onInit s,p & J
  is_halting_onInit s,p holds if=0(a,I,J) is_closed_onInit s,p & if=0(a,I,J)
  is_halting_onInit s,p
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set Is = Initialized s;
  assume s.a <> 0;
  then
A1: Is.a <> 0 by SCMFSA6C:3;
  assume J is_closed_onInit s,p;
  then
A2: J is_closed_on Is,p by Th40;
  assume J is_halting_onInit s,p;
  then J is_halting_on Is,p by Th41;
  then if=0(a,I,J) is_closed_on Is,p & if=0(a,I,J) is_halting_on Is,p by A1,A2,
SCMFSA8B:18;
  hence thesis by Th40,Th41;
end;

theorem Th46:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <> 0 & J
is_closed_onInit s,p & J is_halting_onInit s,p
 holds IExec(if=0(a,I,J),p,s)
  = IExec(J,p,s) +* Start-At((card I + card J + 3),SCM+FSA)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  assume
A1: s.a <> 0;
  set Is = Initialized s;
  assume J is_closed_onInit s,p;
  then
A2: J is_closed_on Is,p by Th40;
  assume J is_halting_onInit s,p;
  then J is_halting_on Is,p by Th41;
  hence thesis by A1,A2,SCMFSA8B:19;
end;

theorem Th47:
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if=0(a,I,J) is InitHalting & (s.
  a = 0 implies IExec(if=0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((card I +
card J + 3),SCM+FSA)) &
 (s.a <> 0 implies IExec(if=0(a,I,J),p,s) = IExec(J,p,s) +* Start-At(
   (card I + card J + 3),SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
A1: ProgramPart Initialized if=0(a,I,J) = if=0(a,I,J) by SCMFSA6A:33;
  now
    let s be State of SCM+FSA;
    assume Initialized if=0(a,I,J) c= s;
    then
A2: s = s +* Initialized if=0(a,I,J) by FUNCT_4:79;
    let p;
    assume if=0(a,I,J) c= p;
    then
A3: p = p +* if=0(a,I,J) by FUNCT_4:79;
A4: J is_closed_onInit s,p & J is_halting_onInit s,p by Th35,Th36;
A5: I is_closed_onInit s,p & I is_halting_onInit s,p by Th35,Th36;
    per cases;
    suppose
      s.a = 0;
      then if=0(a,I,J) is_halting_onInit s,p by A5,Th43;
      hence p halts_on s by A2,Def5,A3;
    end;
    suppose
      s.a <> 0;
      then if=0(a,I,J) is_halting_onInit s,p by A4,Th45;
      hence p halts_on s by A2,Def5,A3;
    end;
  end;
  then Initialized if=0(a,I,J) is halting by EXTPRO_1:def 10,A1;
  hence if=0(a,I,J) is InitHalting by Def2;
  I is_closed_onInit s,p & I is_halting_onInit s,p by Th35,Th36;
  hence s.a = 0 implies IExec(if=0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((
  card I + card J + 3),SCM+FSA) by Th44;
  J is_closed_onInit s,p & J is_halting_onInit s,p by Th35,Th36;
  hence thesis by Th46;
end;

theorem
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA
, a being read-write Int-Location holds IC IExec(if=0(a,I,J),p,s) =  (card
I + card J + 3) & (s.a = 0 implies ((for d being Int-Location
 holds IExec(if=0(a,I,J),p,s).d = IExec(I,p,s).d) &
  for f being FinSeq-Location
 holds IExec(if=0(a,I,J),p,s).f = IExec(I,p,s).f)) & (s.a <> 0 implies
   ((for d being Int-Location holds
  IExec(if=0(a,I,J),p,s).d = IExec(J,p,s).d) &
  for f being FinSeq-Location holds
  IExec(if=0(a,I,J),p,s).f = IExec(J,p,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby
    per cases;
    suppose
      s.a = 0;
      then
      IExec(if=0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((card I + card
      J + 3),SCM+FSA) by Th47;
      hence IC IExec(if=0(a,I,J),p,s) =  (card I + card J + 3) by FUNCT_4:121
;
    end;
    suppose
      s.a <> 0;
      then
      IExec(if=0(a,I,J),p,s) = IExec(J,p,s) +* Start-At((card I + card
      J + 3),SCM+FSA) by Th47;
      hence IC IExec(if=0(a,I,J),p,s) =  (card I + card J + 3) by FUNCT_4:121
;
    end;
  end;
  hereby
    assume s.a = 0;
    then
A1: IExec(if=0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((card I + card J
    + 3),SCM+FSA) by Th47;
    hereby
      let d be Int-Location;
      not d in dom Start-At((card I + card J + 3),SCM+FSA)
      by SCMFSA6B:9;
      hence IExec(if=0(a,I,J),p,s).d = IExec(I,p,s).d by A1,FUNCT_4:12;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At((card I + card J + 3),SCM+FSA)
    by SCMFSA6B:10;
    hence IExec(if=0(a,I,J),p,s).f = IExec(I,p,s).f by A1,FUNCT_4:12;
  end;
  assume s.a <> 0;
  then
A2: IExec(if=0(a,I,J),p,s) = IExec(J,p,s) +* Start-At((card I + card J +
  3),SCM+FSA) by Th47;
  hereby
    let d be Int-Location;
    not d in dom Start-At((card I + card J + 3),SCM+FSA) by SCMFSA6B:9;
    hence IExec(if=0(a,I,J),p,s).d = IExec(J,p,s).d by A2,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At((card I + card J + 3),SCM+FSA) by SCMFSA6B:10;
  hence thesis by A2,FUNCT_4:12;
end;

theorem Th49:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & I is_closed_onInit s,p & I
  is_halting_onInit s,p holds if>0(a,I,J) is_closed_onInit s,p & if>0(a,I,J)
  is_halting_onInit s,p
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set Is = Initialized s;
  assume s.a > 0;
  then
A1: Is.a >0 by SCMFSA6C:3;
  assume I is_closed_onInit s,p;
  then
A2: I is_closed_on Is,p by Th40;
  assume I is_halting_onInit s,p;
  then I is_halting_on Is,p by Th41;
  then if>0(a,I,J) is_closed_on Is,p & if>0(a,I,J) is_halting_on Is,p by A1,A2,
SCMFSA8B:22;
  hence thesis by Th40,Th41;
end;

theorem Th50:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & I is_closed_onInit s,p & I
is_halting_onInit s,p holds IExec(if>0(a,I,J),p,s)
 = IExec(I,p,s) +* Start-At((card I + card J + 3),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  set Is = Initialized s;
  assume I is_closed_onInit s,p;
  then
A2: I is_closed_on Is,p by Th40;
  assume I is_halting_onInit s,p;
  then I is_halting_on Is,p by Th41;
  hence thesis by A1,A2,SCMFSA8B:23;
end;

theorem Th51:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a <= 0 & J is_closed_onInit s,p & J
  is_halting_onInit s,p holds if>0(a,I,J) is_closed_onInit s,p & if>0(a,I,J)
  is_halting_onInit s,p
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set Is = Initialized s;
  assume s.a <= 0;
  then
A1: Is.a <= 0 by SCMFSA6C:3;
  assume J is_closed_onInit s,p;
  then
A2: J is_closed_on Is,p by Th40;
  assume J is_halting_onInit s,p;
  then J is_halting_on Is,p by Th41;
  then if>0(a,I,J) is_closed_on Is,p & if>0(a,I,J) is_halting_on Is,p by A1,A2,
SCMFSA8B:24;
  hence thesis by Th40,Th41;
end;

theorem Th52:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <= 0 & J
is_closed_onInit s,p & J is_halting_onInit s,p
 holds IExec(if>0(a,I,J),p,s)
  = IExec(J,p,s) +* Start-At((card I + card J + 3),SCM+FSA)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  assume
A1: s.a <= 0;
  set Is = Initialized s;
  assume J is_closed_onInit s,p;
  then
A2: J is_closed_on Is,p by Th40;
  assume J is_halting_onInit s,p;
  then J is_halting_on Is,p by Th41;
  hence thesis by A1,A2,SCMFSA8B:25;
end;

theorem Th53:
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if>0(a,I,J) is InitHalting & (s.
  a > 0 implies IExec(if>0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((card I +
card J + 3),SCM+FSA)) &
 (s.a <= 0 implies IExec(if>0(a,I,J),p,s) = IExec(J,p,s) +* Start-At(
   (card I + card J + 3),SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
A1: ProgramPart Initialized if>0(a,I,J) = if>0(a,I,J) by SCMFSA6A:33;
  now
    let s be State of SCM+FSA;
    assume Initialized if>0(a,I,J) c= s;
    then
A2: s = s +* Initialized if>0(a,I,J) by FUNCT_4:79;
    let p;
    assume if>0(a,I,J) c= p;
    then
A3: p = p +* if>0(a,I,J) by FUNCT_4:79;
A4: J is_closed_onInit s,p & J is_halting_onInit s,p by Th35,Th36;
A5: I is_closed_onInit s,p & I is_halting_onInit s,p by Th35,Th36;
    per cases;
    suppose
      s.a > 0;
      then if>0(a,I,J) is_halting_onInit s,p by A5,Th49;
      hence p halts_on s by A2,Def5,A3;
    end;
    suppose
      s.a <= 0;
      then if>0(a,I,J) is_halting_onInit s,p by A4,Th51;
      hence p halts_on s by A2,Def5,A3;
    end;
  end;
  then Initialized if>0(a,I,J) is halting by EXTPRO_1:def 10,A1;
  hence if>0(a,I,J) is InitHalting by Def2;
  I is_closed_onInit s,p & I is_halting_onInit s,p by Th35,Th36;
  hence s.a > 0 implies IExec(if>0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((
  card I + card J + 3),SCM+FSA) by Th50;
  J is_closed_onInit s,p & J is_halting_onInit s,p by Th35,Th36;
  hence thesis by Th52;
end;

theorem
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA
, a being read-write Int-Location holds IC IExec(if>0(a,I,J),p,s) =  (card
I + card J + 3) & (s.a > 0 implies ((for d being Int-Location
 holds IExec(if>0(a,I,J),p,s).d = IExec(I,p,s).d) &
  for f being FinSeq-Location
 holds IExec(if>0(a,I,J),p,s).f
  = IExec(I,p,s).f)) & (s.a <= 0 implies ((for d being Int-Location
   holds
  IExec(if>0(a,I,J),p,s).d = IExec(J,p,s).d) & for f being FinSeq-Location
   holds
  IExec(if>0(a,I,J),p,s).f = IExec(J,p,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby
    per cases;
    suppose
      s.a > 0;
      then
      IExec(if>0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((card I + card
      J + 3),SCM+FSA) by Th53;
      hence IC IExec(if>0(a,I,J),p,s) =  (card I + card J + 3) by FUNCT_4:121
;
    end;
    suppose
      s.a <= 0;
      then
      IExec(if>0(a,I,J),p,s) = IExec(J,p,s) +* Start-At((card I + card
      J + 3),SCM+FSA) by Th53;
      hence IC IExec(if>0(a,I,J),p,s) =  (card I + card J + 3) by FUNCT_4:121
;
    end;
  end;
  hereby
    assume s.a > 0;
    then
A1: IExec(if>0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((card I + card J
    + 3),SCM+FSA) by Th53;
    hereby
      let d be Int-Location;
      not d in dom Start-At((card I + card J + 3),SCM+FSA)
      by SCMFSA6B:9;
      hence IExec(if>0(a,I,J),p,s).d = IExec(I,p,s).d by A1,FUNCT_4:12;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At((card I + card J + 3),SCM+FSA) by SCMFSA6B:10;
    hence IExec(if>0(a,I,J),p,s).f = IExec(I,p,s).f by A1,FUNCT_4:12;
  end;
  assume s.a <= 0;
  then
A2: IExec(if>0(a,I,J),p,s) = IExec(J,p,s) +* Start-At((card I + card J +
  3),SCM+FSA) by Th53;
  hereby
    let d be Int-Location;
    not d in dom Start-At((card I + card J + 3),SCM+FSA) by SCMFSA6B:9;
    hence IExec(if>0(a,I,J),p,s).d = IExec(J,p,s).d by A2,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At((card I + card J + 3),SCM+FSA) by SCMFSA6B:10;
  hence thesis by A2,FUNCT_4:12;
end;

theorem Th55:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a < 0 & I is_closed_onInit s,p & I
is_halting_onInit s,p holds IExec(if<0(a,I,J),p,s)
 = IExec(I,p,s) +* Start-At((card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a < 0;
  set Is = Initialized s;
  assume I is_closed_onInit s,p;
  then
A2: I is_closed_on Is,p by Th40;
  assume I is_halting_onInit s,p;
  then I is_halting_on Is,p by Th41;
  hence thesis by A1,A2,SCMFSA8B:29;
end;

theorem Th56:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & J is_closed_onInit s,p & J
is_halting_onInit s,p holds IExec(if<0(a,I,J),p,s) = IExec(J,p,s) +* Start-At(
  (card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA,I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  set Is = Initialized s;
  assume J is_closed_onInit s,p;
  then
A2: J is_closed_on Is,p by Th40;
  assume J is_halting_onInit s,p;
  then J is_halting_on Is,p by Th41;
  hence thesis by A1,A2,SCMFSA8B:31;
end;

theorem Th57:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & J is_closed_onInit s,p & J
is_halting_onInit s,p holds IExec(if<0(a,I,J),p,s) = IExec(J,p,s) +* Start-At(
  (card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA,I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  set Is = Initialized s;
  assume J is_closed_onInit s,p;
  then
A2: J is_closed_on Is,p by Th40;
  assume J is_halting_onInit s,p;
  then J is_halting_on Is,p by Th41;
  hence thesis by A1,A2,SCMFSA8B:33;
end;

theorem Th58:
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if<0(a,I,J) is InitHalting & (s.
  a < 0 implies IExec(if<0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((card I +
card J + card J + 7),SCM+FSA)) &
 (s.a >= 0 implies IExec(if<0(a,I,J),p,s) = IExec(J,p,s) +*
  Start-At((card I + card J + card J + 7),SCM+FSA))
proof
  let s be State of SCM+FSA,I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  if<0(a,I,J) = if=0(a,J,if>0(a,J,I)) & if>0(a,J,I) is InitHalting by Th53,
SCMFSA8B:def 3;
  hence if<0(a,I,J) is InitHalting by Th47;
  I is_closed_onInit s,p & I is_halting_onInit s,p by Th35,Th36;
  hence s.a < 0 implies IExec(if<0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((
  card I + card J + card J + 7),SCM+FSA) by Th55;
A1: J is_closed_onInit s,p & J is_halting_onInit s,p by Th35,Th36;
  hereby
    assume
A2: s.a >= 0;
    per cases;
    suppose
      s.a = 0;
      hence
      IExec(if<0(a,I,J),p,s) = IExec(J,p,s) +* Start-At((card I + card
      J + card J + 7),SCM+FSA) by A1,Th56;
    end;
    suppose
      s.a <> 0;
      hence
      IExec(if<0(a,I,J),p,s) = IExec(J,p,s) +* Start-At((card I + card
      J + card J + 7),SCM+FSA) by A1,A2,Th57;
    end;
  end;
end;

registration
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  cluster if=0(a,I,J) -> InitHalting;
  correctness by Th47;
  cluster if>0(a,I,J) -> InitHalting;
  correctness by Th53;
  cluster if<0(a,I,J) -> InitHalting;
  correctness by Th58;
end;

theorem Th59:
  for I being Program of SCM+FSA holds I is InitHalting iff for s
  being State of SCM+FSA,p holds I is_halting_on Initialized s,p
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is InitHalting;
    let s be State of SCM+FSA,p;
    I is_halting_onInit s,p by A1,Th36;
    hence I is_halting_on Initialized s,p by Th41;
  end;
  assume
A2: for s being State of SCM+FSA,p holds I is_halting_on Initialized s,p;
  now
    let s be State of SCM+FSA,p;
    I is_halting_on Initialized s,p by A2;
    hence I is_halting_onInit s,p by Th41;
  end;
  hence thesis by Th36;
end;

theorem Th60:
  for I being Program of SCM+FSA holds I is InitClosed iff for s
  being State of SCM+FSA,p holds I is_closed_on Initialized s,p
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is InitClosed;
    let s be State of SCM+FSA,p;
    I is_closed_onInit s,p by A1,Th35;
    hence I is_closed_on Initialized s,p by Th40;
  end;
  assume
A2: for s being State of SCM+FSA,p holds I is_closed_on Initialized s,p;
  now
    let s be State of SCM+FSA,p;
    I is_closed_on Initialized s,p by A2;
    hence I is_closed_onInit s,p by Th40;
  end;
  hence thesis by Th35;
end;

theorem Th61:
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being read-write Int-Location holds IExec(I,p,s).a
   = Comput(p +* I, (
  Initialized s +* (Initialize I)),
  (LifeSpan(p +* I,Initialized s +* (Initialize I)))).a
proof
  let s be State of SCM+FSA,I be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  I is_halting_on Initialized s,p by Th59;
  hence thesis by SCMFSA8C:87;
end;

theorem Th62:
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being Int-Location,k being Element of NAT st I does not destroy a
holds IExec(I,p,s).a = Comput(p +* I,
 Initialized s +* (Initialize I),k).a
proof
  let s be State of SCM+FSA,I be InitHalting Program of SCM+FSA;
  let a be Int-Location,k be Element of NAT;
  assume
A1: I does not destroy a;
  I is_halting_on Initialized s,p &
  I is_closed_on Initialized s,p by Th59,Th60;
  hence thesis by A1,SCMFSA8C:89;
end;
set A = NAT;
set D = Data-Locations SCM+FSA;

theorem Th63:
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being Int-Location st I does not destroy a
   holds IExec(I,p,s).a = (
  Initialized s).a
proof
  let s be State of SCM+FSA;
  let I be InitHalting Program of SCM+FSA;
  let a be Int-Location;
A1: DataPart Initialized s = DataPart (Initialized s +* (Initialize I))
    by SCMFSA8A:11;
  assume I does not destroy a;
  hence
  IExec(I,p,s).a = Comput(p +* I,
    Initialized s +* (Initialize I),0).a by Th62
    .= (Initialized s +* (Initialize I)).a by EXTPRO_1:3
    .= (Initialized s).a by A1,SCMFSA6A:38;
end;

theorem Th64:
  for s be State of SCM+FSA,I be keepInt0_1 InitHalting Program of
  SCM+FSA, a being read-write Int-Location st I does not destroy a holds
Comput(p +* (I ';' SubFrom(a,intloc 0)),
 Initialized s +* Initialize (I ';' SubFrom(a,intloc 0)),
 LifeSpan(p +* (I ';' SubFrom(a,intloc 0)),
   Initialized s +* Initialize (I ';' SubFrom(a,intloc 0)))).a
  = s.a - 1
proof
  let s be State of SCM+FSA,I be keepInt0_1 InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
  set s0 = Initialized s,
      p0 = p;
  set s1 = s0 +* Initialize (I ';' SubFrom(a,intloc 0)),
      p1 = p0 +* (I ';' SubFrom(a,intloc 0));
A2: not a in dom (Initialize I) by SCMFSA6B:12;
  IExec(I ';' SubFrom(a,intloc 0),p,s).a
   = Exec(SubFrom(a,intloc 0),IExec(I,p,
  s)).a by Th33
    .= IExec(I,p,s).a - IExec(I,p,s).intloc 0 by SCMFSA_2:91
    .= IExec(I,p,s).a - 1 by Th17
    .= Comput(p0 +* I, (s0 +* (Initialize I)),0).a - 1
    by A1,Th62
    .= (s0 +* (Initialize I)).a - 1 by EXTPRO_1:3
    .= s0.a - 1 by A2,FUNCT_4:12;
  hence Comput(p1, s1,LifeSpan(p1,s1)).a = s0.a - 1 by Th61
    .= s.a - 1 by SCMFSA6C:3;
end;

theorem Th65:
  for s being State of SCM+FSA, I being InitClosed Program of
SCM+FSA st Initialized I c= s & I c= p &
   p halts_on s
 for m being Element of NAT st m <=
LifeSpan(p,s) holds Comput(p,s,m), Comput(p +* loop I
, (s +* loop I),m) equal_outside
  NAT
proof
  let s be State of SCM+FSA,I be InitClosed Program of SCM+FSA;
  assume that
A1: Initialized I c= s and
A2: I c= p;
  defpred X[Nat] means $1 <= LifeSpan(p,s) implies Comput(
p,s,$1),
  Comput(p +* loop I,(s+*loop I),$1) equal_outside NAT;
  assume
A3: p halts_on s;
A4: for m st X[m] holds X[m+1]
  proof
    set sx = s+*loop I,
        px = p+*loop I;
A5: loop I c= px by FUNCT_4:26;
    let m;
    assume
A6: m <= LifeSpan(p,s) implies Comput(p,s,m), Comput(p +* loop I,(s+*loop I),
    m) equal_outside NAT;
A7: Comput(px,sx,m+1) =
Following(px,Comput(px,sx,m)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(px,Comput(px,sx,m)),
      Comput(px,sx,m));
A8: Comput(p,s,m+1) =
Following(p,Comput(p,s,m))
 by EXTPRO_1:4
      .= Exec(CurInstr(p,Comput(p,s,m))
      ,Comput(p,s,m));
A9: IC Comput(p,s,m) in dom I by A1,Def1,A2;
    then
A10: loop I c= Comput(px,sx,m) & IC Comput(p,s,m) in
dom loop I by AMI_1:81,FUNCT_4:26,105;
A11:  p/.IC Comput(p,s,m) = p.IC Comput(p,s,m) by PBOOLE:158;
A12: CurInstr(p,Comput(p,s,m))
 = I.IC(Comput(p,s,m)) by A9,A11,GRFUNC_1:8,A2;
    assume
A13: m+1 <= LifeSpan(p,s);
    then
A14: IC(Comput(p,s,m)) = IC(Comput(px,sx,m)) by A6,
COMPOS_1:24,NAT_1:13;
A15:  px/.IC Comput(px,sx,m) = px.IC Comput(px,sx,m) by PBOOLE:158;
    m < LifeSpan(p,s) by A13,NAT_1:13;
    then I.IC(Comput(p,s,m)) <> halt SCM+FSA by A3,A12,
EXTPRO_1:def 14
;
    then CurInstr(p,Comput(p,s,m))
 = (loop I).IC(Comput(p,s,m)) by A12,FUNCT_4:111
      .= CurInstr(px,Comput(px,sx,m))
       by A14,A10,A15,GRFUNC_1:8,A5;
    hence thesis by A6,A13,A8,A7,NAT_1:13,AMISTD_2:def 20;
  end;
  Comput(p,s,0) = s & Comput(p +* loop I,(s+*loop I),
0) = s+*loop I by EXTPRO_1:3;
  then
A16: X[0] by FUNCT_7:132;
  thus for m being Element of NAT holds X[m] from NAT_1:sch 1(A16, A4);
end;

theorem
  for s being State of SCM+FSA, I being InitHalting Program of SCM+FSA
st Initialized I c= s & I c= p
 holds for k being Element of NAT st k <= LifeSpan(
p,s) holds
  CurInstr(p +* loop I,
   Comput(p +* loop I, s +* loop I,k)) <> halt SCM+FSA
proof
  let s be State of SCM+FSA;
  let I be InitHalting Program of SCM+FSA;
  set s2 = s +* loop I,
      p2 = p +* loop I;
A1: ProgramPart Initialized I = I by SCMFSA6A:33;
  assume
A2: Initialized I c= s;
 assume
A3: I c= p;
  then
A4: p halts_on s by EXTPRO_1:def 10,A2,A1;
  hereby
    let k be Element of NAT;
    set lk = IC Comput(p,s,k);
A5: IC Comput(p,s,k) in dom I & dom I = dom loop I by A2,Def1,
FUNCT_4:105,A3;
    then
A6: (loop I).lk in rng loop I by FUNCT_1:def 5;
    assume k <= LifeSpan(p,s);
    then lk = IC Comput(p2,s2,k) by A2,A4,Th65,COMPOS_1:24,A3;
    then
A7: CurInstr(p2,Comput(p2,s2,k)) = p2.lk by PBOOLE:158
      .= (loop I).lk by A5,FUNCT_4:14;
    assume
    CurInstr(p +* loop I,
     Comput(p +* loop I, (s +* loop I),k)) = halt SCM+FSA;
    hence contradiction by A7,A6,SCMFSA8C:107;
  end;
end;

theorem
  I c= s +* Initialized I
proof
  Initialized I c= s +* Initialized I & I c= Initialized I by FUNCT_4:26
,SCMFSA6A:26;
  hence thesis by XBOOLE_1:1;
end;

theorem Th68:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s,p & I is_halting_onInit s,p
  for m being Element of NAT st m <=
  LifeSpan(p+*I,s +* Initialized I)
   holds Comput(p +* I, s +* Initialized I,m),
     Comput(p +* loop I,(s +* Initialized (loop I)),m)
      equal_outside NAT
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I,
      p1 = p +* I;
A1: I c= p1 by FUNCT_4:26;
  set s2 = s +* Initialized (loop I),
      p2 = p +* loop I;
A2: loop I c= p2 by FUNCT_4:26;
  assume
A3: I is_closed_onInit s,p;
  defpred X[Nat] means $1 <= LifeSpan(p1,s1) implies Comput(
p1, s1,$1
  ), Comput(p2, s2,$1) equal_outside A;
  assume I is_halting_onInit s,p;
  then
A4: p1 halts_on s1 by Def5;
A5: for m being Element of NAT st X[m] holds X[m+1]
  proof
    let m be Element of NAT;
    assume
A6: m <= LifeSpan(p1,s1) implies Comput(p1,s1,m),Comput(p2,s2,m)
    equal_outside A;
A7: IC Comput(p1,s1,m) in dom I by A3,Def4;
    then
A8: IC Comput(p1,s1,m) in dom loop I by FUNCT_4:105;
A9:  p1/.IC Comput(p1,s1,m) = p1.IC Comput(p1,s1,m) by PBOOLE:158;
A10: CurInstr(p1,Comput(p1,s1,m))
       = I.IC Comput(p1,s1,m) by A7,A9,GRFUNC_1:8,A1;
A11: Comput(p2,s2,m+1) = Following(p2,Comput(p2,s2,m)) by EXTPRO_1:4
      .= Exec(CurInstr(p2,Comput(p2,s2,m)),
      Comput(p2,s2,m));
A12: Comput(p1,s1,m+1) =
Following(p1,Comput(p1,s1,m)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(p1,Comput(p1,s1,m)),
      Comput(p1,s1,m));
    assume
A13: m + 1 <= LifeSpan(p1,s1);
    then m < LifeSpan(p1,s1) by NAT_1:13;
    then I.IC Comput(p1,s1,m) <> halt SCM+FSA by A4,A10,
EXTPRO_1:def 14;
    then
A14: I.IC Comput(p1,s1,m) = (loop I).IC Comput(p1,s1,
m) by FUNCT_4:111;
A15:  p2/.IC Comput(p2,s2,m) = p2.IC Comput(p2,s2,m) by PBOOLE:158;
    IC Comput(p1,s1,m) = IC Comput(p2,s2,m) by A6,A13
,COMPOS_1:24,NAT_1:13;
    then CurInstr(p1,Comput(p1,s1,m))
     = CurInstr(p2,Comput(p2,s2,m))
      by A8,A10,A15,A14,GRFUNC_1:8,A2;
    hence thesis by A6,A13,A12,A11,NAT_1:13,AMISTD_2:def 20;
  end;
A16: X[0]
  proof
    assume 0 <= LifeSpan(p1,s1);
    s +* I,s equal_outside A & s,s +* loop I equal_outside A by FUNCT_7:28,132;
    then s +* I,s +* loop I equal_outside A by FUNCT_7:29;
    then s +* I +* iS,s +* loop I +* iS equal_outside A by FUNCT_7:106;
    then s +* (I +* iS),s +* loop I +* iS equal_outside A by FUNCT_4:15;
    then s +* (I +* iS),s +* (loop I +* iS) equal_outside A by FUNCT_4:15;
    then s +* (I +* iS),s2 equal_outside A by FUNCT_4:15;
    then s1,s2 equal_outside A by FUNCT_4:15;
    then s1, Comput(p2, s2,0) equal_outside A by EXTPRO_1:3;
    hence thesis by EXTPRO_1:3;
  end;
  thus for m being Element of NAT holds X[m] from NAT_1:sch 1(A16, A5);
end;

theorem Th69:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s,p & I is_halting_onInit s,p
  for m being Element of NAT st m <
LifeSpan(p+*I,s +* Initialized I) holds
 CurInstr(p +* I,
  Comput(p +* I, (s +* Initialized I),m))
  = CurInstr(p +* loop I,
   Comput(p +* loop I,(s +* Initialized(loop I)),m))
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I,
      p1 = p +* I;
A1: I c= p1 by FUNCT_4:26;
  set s2 = s +* Initialized(loop I),
      p2 = p +* loop I;
A2: loop I c= p2 by FUNCT_4:26;
  assume that
A3: I is_closed_onInit s,p and
A4: I is_halting_onInit s,p;
  let m be Element of NAT;
A5: IC Comput(p1,s1,m) in dom I by A3,Def4;
  then
A6: IC Comput(p1,s1,m) in dom loop I by FUNCT_4:105;
A7:  p1/.IC Comput(p1,s1,m) = p1.IC Comput(p1,s1,m) by PBOOLE:158;
A8: CurInstr(p1,Comput(p1,s1,m))
 = I.IC Comput(p1,s1,m) by A5,A7,GRFUNC_1:8,A1;
  assume
A9: m < LifeSpan(p+*I,s +* Initialized I);
A10:  p2/.IC Comput(p2,s2,m) = p2.IC Comput(p2,s2,m) by PBOOLE:158;
  p1 halts_on s1 by A4,Def5;
  then I.IC Comput(p1,s1,m) <> halt SCM+FSA by A9,A8,
EXTPRO_1:def 14;
  then
A11: I.IC Comput(p1,s1,m) = (loop I).IC Comput(p1,s1,m
) by FUNCT_4:111;
  IC Comput(p1,s1,m) = IC Comput(p2,s2,m) by A3,A4,A9
,Th68,COMPOS_1:24;
  hence thesis by A6,A8,A11,A10,GRFUNC_1:8,A2;
end;

theorem
  for l being Element of NAT holds not l in dom (
  Initialize ((intloc 0) .--> 1))
proof
  let l be Element of NAT;
  assume l in dom iS;
  then l=intloc 0 or l=IC SCM+FSA by Th1;
  hence contradiction by COMPOS_1:3,SCMFSA_2:84;
end;

theorem Th71:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s,p & I is_halting_onInit s,p
   holds CurInstr(p +* loop I,
   Comput(p +* loop I, (s +*Initialized (loop I)),
LifeSpan(p+*I,s +* Initialized I)))
    = goto  0 & for m
  being Element of NAT st m <= LifeSpan(p+*I,s +*
Initialized I)
   holds CurInstr(p +* loop I,
  Comput(p +* loop I, (s +* Initialized (loop I)),m))
   <> halt SCM+FSA
proof
A1: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:71;
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  set s1 = s +* Initialized I,
      p1 = p +* I;
  set s2 = s +* Initialized loop I,
      p2 = p +* loop I;
A2: loop I c= p2 by FUNCT_4:26;
  assume that
A3: I is_closed_onInit s,p and
A4: I is_halting_onInit s,p;
  set k = LifeSpan(p1,s1);
A5: rng I c= the Instructions of SCM+FSA by RELAT_1:def 19;
A6: IC Comput(p1,s1,k) in dom I by A3,Def4;
A7:  dom loop I = dom I by FUNCT_4:105;
A8: CurInstr(p1,Comput(p1,s1,k))
     = p1.IC Comput(p1,s1,k) by PBOOLE:158
    .= I.IC Comput(p1,s1,k) by FUNCT_4:14,A6
:::    .= (I +* (intloc 0) .--> 1)).IC Comput(p1,s1,k) by FUNCT_4:15
    .= I.IC Comput(p1,s1,k);
A9: p1 halts_on s1 by A4,Def5;
  then
A10: CurInstr(p1,Comput(p1,
s1,k))
 = halt SCM+FSA by EXTPRO_1:def 14;
  IC Comput(p1,s1,k) = IC Comput(p2,s2,k) by A3,A4,Th68,COMPOS_1:24;
  hence
A11: CurInstr(p2,
      Comput(p2,s2,LifeSpan(p1,s1)))
     = p2.IC Comput(p1,s1,k) by PBOOLE:158
    .= (loop I).IC Comput(p1,s1,k) by GRFUNC_1:8,A2,A6,A7
    .= (((id the Instructions of SCM+FSA) +* (halt SCM+FSA, goto  0))*
  I ).IC Comput(p1,s1,k) by A5,FUNCT_7:118
    .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA, goto  0)).
  halt SCM+FSA by A10,A6,A8,FUNCT_1:23
    .= goto  0 by A1,FUNCT_7:33;
  let m be Element of NAT;
  assume
A12: m <= LifeSpan(p1,s1);
  per cases by A12,XXREAL_0:1;
  suppose
A13: m < LifeSpan(p1,s1);
    then CurInstr(p1,Comput(p1,s1,m))
     <> halt SCM+FSA by A9,EXTPRO_1:def 14;
    hence thesis by A3,A4,A13,Th69;
  end;
  suppose
    m = LifeSpan(p1,s1);
    hence thesis by A11;
  end;
end;

canceled;

theorem Th73:
  for s being State of SCM+FSA,p
  for I being good InitHalting Program
of SCM+FSA, a being read-write Int-Location st
   I does not destroy a & s.intloc 0 = 1 &
   s.a > 0 holds loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s,p
proof
  let s be State of SCM+FSA,p;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  set P = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
  reconsider I1 = I ';' SubFrom(a,intloc 0) as InitHalting Program of SCM+FSA;
  set i = a =0_goto  (card I1 + 3);
  defpred P[Nat] means for s being State of SCM+FSA,p st
   s.intloc 0 = 1 & s.a = $1 & s.a > 0
   holds Comput(p +* loop P, s +* Initialized loop P,
     LifeSpan(p +* P,s +* Initialized P) + 1).a = s.a - 1 &
     Comput(p +* loop P, s +* Initialized loop P,
      LifeSpan(p +* P,s +* Initialized P) + 1).intloc 0 = 1 &
   ex k being Element of NAT st
    IC Comput(p +* loop P,s +* Initialized loop P,k) = card loop P &
   for n being Element of NAT st n < k holds IC
    Comput(p +* loop P, s +* Initialized loop P,n) in dom loop P;
  assume
A1: I does not destroy a;
A2: for k being Element of NAT holds P[k] implies P[k + 1]
  proof
A3: now
A4:    0 in dom Macro i & (Macro i). 0 <> halt SCM+FSA by COMPOS_1:148
,COMPOS_1:147;
      P = i ';' I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA by SCMFSA8B:def 1
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1)) ';' Goto
       2 ';' Stop SCM+FSA by SCMFSA6A:71
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2) ';' Stop SCM+FSA by SCMFSA6A:71
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA) by SCMFSA6A:71
        .= Macro i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA);
      hence P. 0 = (Macro i). 0 by A4,SCMFSA6A:54
        .= i by COMPOS_1:148;
      hence P. 0 <> halt SCM+FSA;
A5:   card P = card Goto  2 + card I1 + 4 by SCMFSA8B:14
        .= card I1 + 1 + 4 by SCMFSA8A:29
        .= card I1 + 3 + 2;
      hence  0 in dom P by AFINSQ_1:70;
      card loop P = card dom loop P by CARD_1:104
        .= card dom P by FUNCT_4:105
        .= card P by CARD_1:104;
      then card loop P = card I1 + (3 + 2) by A5;
      hence P. (card I1 + 3) = goto  card loop P
      by SCMFSA8C:116;
      hence P. (card I1 + 3) <> halt SCM+FSA;
      hereby
        card I1 + 3 + 0 < card P by A5,XREAL_1:8;
        hence  (card I1 + 3) in dom P by AFINSQ_1:70;
      end;
    end;
    let k be Element of NAT;
    assume
A6: P[k];
    let ss be State of SCM+FSA;
    let pp be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
    assume ss.intloc 0 = 1;
    set s2 = ss +* Initialized loop P,
        p2 = pp +* loop P;
A7: loop P c= p2 by FUNCT_4:26;
    set s1 = ss +* Initialized P,
        p1 = pp +* P;
    assume
A8: ss.a = k + 1;
A9: Comput(p2,s2,LifeSpan(p1,s1)+1) =
Following(p2,Comput(p2,s2,LifeSpan(p1,s1)))
    by EXTPRO_1:4
      .= Exec(CurInstr(p2,
      Comput(p2,s2,LifeSpan(p1,s1))),
      Comput(p2,s2,LifeSpan(p1,s1)));
    set s3 = Comput(p2,s2,LifeSpan(p1,s1)+1),
        p3 = p2;
    assume
A10: ss.a > 0;
A11: I1 is_closed_onInit ss,pp & I1 is_halting_onInit ss,pp by Th35,Th36;
    then
A12: P is_halting_onInit ss,pp by A10,Th45;
    P is_closed_onInit ss,pp by A10,A11,Th45;
    then
A13: Comput(p2,s2,LifeSpan(p1,s1)+1) = Exec(goto  0,
Comput(p2,s2,
    LifeSpan(p1,s1))) by A12,A9,Th71;
A14: P is_closed_onInit ss,pp by A10,A11,Th45;
A15:  card P = card Goto  2 + card I1 + 4 by SCMFSA8B:14
        .= card I1 + 1 + 4 by SCMFSA8A:29
        .= card I1 + 3 + 2;
A16:  card loop P = card dom loop P by CARD_1:104
        .= card dom P by FUNCT_4:105
        .= card P by CARD_1:104;
A17: now
A18:  I1 is_halting_onInit ss,pp by Th36;
      then
A19:  I1 is_halting_on Initialized ss,pp by Th41;
      IExec(P,pp,ss) = IExec(I1,pp,ss) +* Start-At((card Goto  2 +
      card I1 + 3),SCM+FSA) by A10,A18,Th46,Th35;
      then
A20:  IExec(P,pp,ss).a = IExec(I1,pp,ss).a by SCMFSA_3:11;
      hereby
        thus  0 in dom loop P by A16,A15,AFINSQ_1:70;
        card I1 + 3 + (1 + 1) = (card I1 + 3 + 1) + 1;
        then card I1 + 3 + 1 < card P by A15,NAT_1:13;
        then card I1 + 3 < card loop P by A16,NAT_1:13;
        hence  (card I1 + 3) in dom loop P by AFINSQ_1:70;
      end;
      consider Is being State of SCM+FSA such that
A21:  Is = Initialized ss +* Initialized P;
      Initialized Initialized ss = Initialized ss by SCMFSA8C:15;
      then
A22:  Is = Initialized ss +* (Initialize P)
by A21,SCMFSA8A:13;
      I1 is_closed_onInit ss,pp by Th35;
      then
A23:  I1 is_closed_on Initialized ss,pp by Th40;
      I1 is_halting_onInit ss,pp by Th36;
      then
A24:  I1 is_halting_on Initialized ss,pp by Th41;
A25:  (Initialized ss).a > 0 by A10,SCMFSA6C:3;
      then
A26:  P is_halting_on Initialized ss,pp by A23,A24,SCMFSA8B:18;
      thus
A27:  Initialized ss +* Initialized P = ss +* Initialized P by SCMFSA8A:8;
A28:  now
        let b be Int-Location;
        Comput(p2,s2,LifeSpan(p1,s1)+1).b = Comput(p2,s2,LifeSpan(p1,s1)).b
        by A13,SCMFSA_2:95;
        hence Comput(p2,s2,LifeSpan(p1,s1)+1).b =
           Comput(pp +* P, Is,LifeSpan(pp +* P,Is)).b
        by A12,A14,A27,A21,Th68,SCMFSA10:92;
      end;
      then Comput(p2,s2,LifeSpan(p1,s1)+1).a = Comput(pp +* P
                 , Is,LifeSpan(pp +* P,Is)).a
        .= IExec(P,pp,ss).a by A22,A26,SCMFSA8C:87;
      hence Comput(p2,s2,LifeSpan(p1,s1)+1).a =
Comput(pp +* I1,
 Initialized ss +* (Initialize I1),
 LifeSpan(pp +* I1, Initialized ss +* (Initialize I1))).a
          by A19,A20,SCMFSA8C:87
        .= ss.a - 1 by A1,Th64;
A29:  P is_closed_on Initialized ss,pp by A25,A23,A24,SCMFSA8B:18;
      Comput(p2,s2,LifeSpan(p1,s1)+1).intloc 0 =
Comput(pp +* P, Is,LifeSpan(pp +* P,Is)).intloc 0 by A28
        .= 1 by A22,A26,A29,SCMFSA8C:96;
      hence Comput(p2,s2,LifeSpan(p1,s1)+1).intloc 0 = 1;
    end;
    hence s3.a = ss.a - 1 & s3.intloc 0 = 1;
A30: IC Comput(p2,s2,LifeSpan(p1,s1)+1)=  0 by A13,
SCMFSA_2:95;
    hereby
      per cases;
      suppose
A31:    k = 0;
        take m = LifeSpan(p1,s1) + 1 + 1 + 1;
A32:    CurInstr(p2,
           Comput(p2,s2,LifeSpan(p1,s1)+1))
           = p2. 0 by A30,PBOOLE:158
          .= (loop P). 0 by A17,A7,GRFUNC_1:8
          .= i by A3,FUNCT_4:111;
A33:    Comput(p2,s2,LifeSpan(p1,s1)+1+1) =
Following(p2,
Comput(p2,s2,LifeSpan(p1,s1)+1)) by EXTPRO_1:4
          .= Exec(i,Comput(p2,s2,LifeSpan(p1,s1)+1))
by A32;
        then IC Comput(p2,s2,LifeSpan(p1,s1)+1+1) =
(card I1 + 3) by A8,A17,A31,SCMFSA_2:96;
        then
A34:    CurInstr(p2,Comput(p2,s2,LifeSpan(p1,s1)+1+1)) = p2.(card I1 + 3)
             by PBOOLE:158
          .= (loop P). (card I1 + 3)
           by A17,A7,GRFUNC_1:8
          .= goto  card loop P by A3,FUNCT_4:111;
        Comput(p2,s2,m) = Following(p2,Comput(p2,s2,LifeSpan(p1,s1)+1+1))
                   by EXTPRO_1:4
          .= Exec(goto  card loop P, Comput(p2,s2,
        LifeSpan(p1,s1)+1+1)) by A34;
        hence IC Comput(p2,s2,m) =  card loop P by SCMFSA_2:95;
        hereby
          let n be Element of NAT;
          assume n < m;
          then n <= LifeSpan(p1,s1) + 1 + 1 by NAT_1:13;
          then
A35:      n <= LifeSpan(p1,s1) + 1 or n = LifeSpan(p1
,s1) + 1 + 1 by NAT_1:8;
          per cases by A35,NAT_1:8;
          suppose
A36:        n <= LifeSpan(p1,s1);
A37:        I1 is_closed_onInit ss,pp & I1 is_halting_onInit ss,pp
            by Th35,Th36;
            then
A38:        P is_closed_onInit ss,pp by A10,Th45;
            P is_halting_onInit ss,pp by A10,A37,Th45;
            then Comput(p1,s1,n),Comput(p2,s2,n)
equal_outside A by A36,A38,Th68;
            then
A39:        IC Comput(p2,s2,n) = IC Comput(p1,s1,n)
by SCMFSA8A:6;
            IC Comput(p1,s1,n) in dom P by A38,Def4;
            hence IC Comput(p2,s2,n) in dom loop P by A39,
FUNCT_4:105;
          end;
          suppose
            n = LifeSpan(p1,s1) + 1;
            hence IC Comput(p2,s2,n) in dom loop P by A13,A17,
SCMFSA_2:95;
          end;
          suppose
            n = LifeSpan(p1,s1) + 1 + 1;
            hence IC Comput(p2,s2,n) in dom loop P by A8,A17,A31
,A33,SCMFSA_2:96;
          end;
        end;
      end;
      suppose
A40:    k > 0;
        consider Is3 being State of SCM+FSA such that
A41:    Is3 = Initialized s3;
A42:     Initialized loop P c= s2 by FUNCT_4:26;
        loop P c= Initialized loop P by SCMFSA6A:26;
        then loop P c= s2 by A42,XBOOLE_1:1;
        then
        ProgramPart loop P c= s3 by AMI_1:99;
        then
A43:    loop P c= s3 by RELAT_1:209;
        Is3.intloc 0 = 1 & Is3.a = k by A8,A17,A41,SCMFSA6C:3;
        then consider m0 being Element of NAT such that
A44:    IC Comput(p3 +* loop P, (Is3 +*
Initialized (loop P)),m0) =
        card loop P and
A45:    for n being Element of NAT st n < m0
         holds IC Comput(p3 +* loop P, (
        Is3 +* Initialized (loop P)),n) in dom loop P by A6,A40;
        take m = LifeSpan(p1,s1) + 1 + m0;
A46:    Initialized s3 +* Initialized loop P = s3 +* Initialized loop P by
SCMFSA8A:8
          .= s3 +* (loop P +* iS) by FUNCT_4:15
          .= s3 +* loop P +* iS by FUNCT_4:15
          .= s3 +* iS +* loop P by Th19
          .= Initialized s3 +* loop P by FUNCT_4:15
          .= s3 +* loop P by A30,A17,SCMFSA8C:14
          .= s3 by A43,FUNCT_4:79;
A47:     p3 +* loop P = p3 by A7,FUNCT_4:79;
        hence
        IC Comput(p2,s2,m) =  card loop P by A41,A44,A46
            ,EXTPRO_1:5;
        hereby
          let n be Element of NAT;
          assume
A48:      n < m;
A49:      I1 is_closed_onInit ss,pp & I1 is_halting_onInit ss,pp by Th35,Th36;
          then
A50:      P is_closed_onInit ss,pp by A10,Th45;
A51:      P is_halting_onInit ss,pp by A10,A49,Th45;
          per cases by NAT_1:13;
          suppose
            n <= LifeSpan(p1,s1);
            then Comput(p1,s1,n),Comput(p2,s2,n)
equal_outside A by A50,A51,Th68;
            then
A52:        IC Comput(p2,s2,n) = IC Comput(p1,s1,n)
by SCMFSA8A:6;
            IC Comput(p1,s1,n) in dom P by A50,Def4;
            hence IC Comput(p2,s2,n) in dom loop P by A52,
FUNCT_4:105;
          end;
          suppose
A53:        LifeSpan(p1,s1) + 1 <= n;
            consider mm being Element of NAT such that
A54:        mm = n -' (LifeSpan(p1,s1) + 1);
            n - (LifeSpan(p1,s1) + 1) >= 0 by A53,XREAL_1:50;
            then
A55:        mm = n - (LifeSpan(p1,s1) + 1) by A54,XREAL_0:def 2;
            mm + (LifeSpan(p1,s1) + 1) = n by A53,A54,XREAL_1:237;
            then
A56:        IC Comput(p2,s2,n) = IC Comput(p2, s3,mm
) by EXTPRO_1:5;
            m0 = m - (LifeSpan(p1,s1) + 1);
            then mm < m0 by A48,A55,XREAL_1:11;
            hence IC Comput(p2,s2,n) in dom loop P by A41,A45,A46,A47
,A56;
          end;
        end;
      end;
    end;
  end;
  assume
A57: s.intloc 0 = 1;
  assume
A58: s.a > 0;
  then reconsider sa = s.a as Element of NAT by INT_1:16;
A59: P[0];
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A59,A2);
  then P[sa];
  then
A60:
   ex k being Element of NAT st
    IC Comput(p +* loop P,s +* Initialized loop P,k) = card loop P &
   for n being Element of NAT st n < k holds IC
    Comput(p +* loop P, s +* Initialized loop P,n) in dom loop P
          by A57,A58;
A61: ProgramPart loop P = loop P by RELAT_1:209;
  s +* Initialized loop P= s +* Initialize loop P by A57,SCMFSA8C:18;
  then
  ex k being Element of NAT st
   IC Comput(p +* ProgramPart loop P,
    s +* (Initialize loop P),k)
    = card ProgramPart loop P &
  for n being Element of NAT st n < k
   holds IC Comput(p +* ProgramPart loop P,
   s +* (Initialize loop P),n) in dom loop P by A60,A61;
  hence :::thesis
:::   loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
   loop P is_pseudo-closed_on s,p
  by SCMFSA8A:def 3;
end;

theorem
  for s being State of SCM+FSA, I being good InitHalting Program of
  SCM+FSA, a being read-write Int-Location st I does not destroy a & s.a > 0
  holds Initialized loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s,p
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
A2: (Initialized s).a = s.a & (Initialized s).intloc 0 = 1 by SCMFSA6C:3;
  assume s.a > 0;
  then
  loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) is_pseudo-closed_on
  Initialized s,p by A1,A2,Th73;
  hence thesis by SCMFSA8C:47;
end;

theorem
  for s being State of SCM+FSA, I being good InitHalting Program of
SCM+FSA, a being read-write Int-Location st I does not destroy a & s.intloc 0 =
  1 holds Times(a,I) is_closed_on s,p & Times(a,I) is_halting_on s,p
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
  assume
A2: s.intloc 0 = 1;
  per cases;
  suppose
A3: s.a > 0;
    Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) = loop
    if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) by SCMFSA6A:63;
    then Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
    is_pseudo-closed_on s,p by A1,A2,A3,Th73;
    hence thesis by A3,SCMFSA8C:68;
  end;
  suppose
A4: s.a <= 0;
    Stop SCM+FSA is_closed_on s,p &
    Stop SCM+FSA is_halting_on s,p by SCMFSA7B:24
,25;
    hence thesis by A4,SCMFSA8B:24;
  end;
end;

theorem
  for I being good InitHalting Program of SCM+FSA, a being read-write
  Int-Location st I does not destroy a holds Initialized Times(a,I) is halting
proof
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
  now
    let s be State of SCM+FSA,p;
    per cases;
    suppose
      s.a > 0;
      then
A2:   (Initialized s).a > 0 by SCMFSA6C:3;
      (Initialized s).intloc 0 = 1 & Directed loop if=0(a,Goto  2,I
';' SubFrom(a,intloc 0)) = loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
      by SCMFSA6A:63,SCMFSA6C:3;
      then Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
      is_pseudo-closed_on Initialized s,p by A1,A2,Th73;
      then Times(a,I) is_halting_on Initialized s,p by A2,SCMFSA8C:68;
      hence Initialized Times(a,I) is_halting_on s,p by SCMFSA8C:22;
    end;
    suppose
A3:   s.a <= 0;
A4:   Stop SCM+FSA is_closed_on Initialized s,p & Stop SCM+FSA is_halting_on
      Initialized s,p by SCMFSA7B:24,25;
      (Initialized s).a <= 0 by A3,SCMFSA6C:3;
      then Times(a,I) is_halting_on Initialized s,p by A4,SCMFSA8B:24;
      hence Initialized Times(a,I) is_halting_on s,p by SCMFSA8C:22;
    end;
  end;
  hence thesis by SCMFSA8C:24;
end;

registration
  let a be read-write Int-Location,I be good Program of SCM+FSA;
  cluster Times(a,I) -> good;
  coherence;
end;

theorem Th77:
  for s being State of SCM+FSA, I being good InitHalting Program
  of SCM+FSA, a being read-write Int-Location st I does not destroy a & s.a > 0
  ex s2 being State of SCM+FSA,
   p2 being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
   k being Element of NAT st
   s2 = s +* Initialized loop if=0(a,Goto  2, I ';' SubFrom(a,intloc 0)) &
   p2 = p +* loop if=0(a,Goto  2, I ';' SubFrom(a,intloc 0)) &
   k =
LifeSpan(p +* (if=0(a,Goto  2, I ';' SubFrom(a,intloc 0))),
   s +* Initialized (if=0(a,Goto  2, I ';' SubFrom(a,intloc 0))))
  + 1 & Comput(p2,s2,k).a = s.a - 1 & Comput(p2,s2,k)
.intloc 0 = 1 & (for b
being read-write Int-Location st b <> a holds Comput(p2,s2,k).b =
IExec(I,p,s).
  b) & (for f being FinSeq-Location holds Comput(p2,s2,k).f =
IExec(I,p,s).f) &
IC Comput(p2,s2,k) =  0 & for n being Element of NAT st n <= k
holds IC
Comput(p2, s2,n) in dom loop if=0(a,Goto  2,I ';' SubFrom(a,
intloc 0))
proof
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
  reconsider I1 = I ';' SubFrom(a,intloc 0) as InitHalting Program of SCM+FSA;
  set P = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
  assume
A2: s.a > 0;
  set Is = Initialized s +* Initialized P;
  take s2 = s +* Initialized loop P, p2 = p +* loop P;
  set s1 = s +* Initialized P,
      p1 = p +* P;
  take k = LifeSpan(p1,s1) + 1;
  thus s2 = s +* Initialized (loop if=0(a,Goto  2, I ';' SubFrom(a,
  intloc 0))) & p2 = p +* loop P &
   k = LifeSpan(p +* (if=0(a,Goto  2, I ';' SubFrom(a,intloc 0))),
  s +* Initialized (if=0(a,Goto  2, I ';' SubFrom(a,intloc 0)))) + 1;
  Initialized Initialized s = Initialized s by SCMFSA8C:15;
  then
A3: Is = Initialized s +* (Initialize P) by SCMFSA8A:13;
A4: I1 is_halting_onInit s,p by Th36;
  then
A5: I1 is_halting_on Initialized s,p by Th41;
A6: IExec(P,p,s) = IExec(I1,p,s) +* Start-At((card Goto  2 + card
  I1 + 3),SCM+FSA) by A2,A4,Th46,Th35;
  then
A7: IExec(P,p,s).a = IExec(I1,p,s).a by SCMFSA_3:11;
  I1 is_closed_onInit s,p & I1 is_halting_onInit s,p by Th35,Th36;
  then
A8: P is_closed_onInit s,p & P is_halting_onInit s,p by A2,Th45;
  Comput(p2,s2,LifeSpan(p1,s1)+1) =
  Following(p2,
  Comput(p2,s2,LifeSpan(p1,s1))) by EXTPRO_1:4
    .= Exec(CurInstr(p2,
    Comput(p2,s2,LifeSpan(p1,s1))),
    Comput(p2,s2,LifeSpan(p1,s1)));
  then
A9: Comput(p2,s2,LifeSpan(p1,s1)+1) = Exec(goto  0,
Comput(p2,s2,
  LifeSpan(p1,s1))) by A8,Th71;
A10: I1 is_closed_onInit s,p & I1 is_halting_onInit s,p by Th35,Th36;
  then P is_closed_onInit s,p by A2,Th45;
  then
A11: P is_closed_on Initialized s,p by Th40;
  P is_halting_onInit s,p by A2,A10,Th45;
  then
A12: P is_halting_on Initialized s,p by Th41;
A13: Initialized s +* Initialized P = s +* Initialized P by SCMFSA8A:8;
A14: now
    let b be Int-Location;
    Comput(p2,s2,LifeSpan(p1,s1)+1).b = Comput(
p2,s2,
LifeSpan(p1,s1)).b by A9,SCMFSA_2:95;
    hence Comput(p2,s2,LifeSpan(p1,s1)+1).b = Comput(
p +* P,
Is,LifeSpan(p +* P,Is)).b by A8,A13,Th68,SCMFSA10:92;
  end;
  then Comput(p2,s2,LifeSpan(p1,s1)+1).a = Comput(
p +* P, Is
,LifeSpan(p +* P,Is)).a
    .= IExec(P,p,s).a by A3,A12,SCMFSA8C:87;
  hence Comput(p2,s2,k).a =
  Comput(p +* I1,
   (Initialized s +* (Initialize I1)), (LifeSpan(p +* I1,
   Initialized s +* (Initialize I1)))).a by A5,A7,SCMFSA8C:87
    .= s.a - 1 by A1,Th64;
  Comput(p2,s2,LifeSpan(p1,s1)+1).intloc 0 = Comput(
p +* P,
Is,LifeSpan(p +* P,Is)).
  intloc 0 by A14
    .= 1 by A3,A12,A11,SCMFSA8C:96;
  hence Comput(p2,s2,k).intloc 0 = 1;
  hereby
    let b be read-write Int-Location;
    assume
A15: b <> a;
    thus Comput(p2,s2,k).b = Comput(p +* P, Is,
    LifeSpan(p +* P,
Is)).b by A14
      .= IExec(P,p,s).b by A3,A12,SCMFSA8C:87
      .= IExec(I1,p,s).b by A6,SCMFSA_3:11
      .= Exec(SubFrom(a,intloc 0),IExec(I,p,s)).b by Th33
      .= IExec(I,p,s).b by A15,SCMFSA_2:91;
  end;
  hereby
    let f be FinSeq-Location;
    Comput(p2,s2,LifeSpan(p1,s1)+1).f = Comput(
p2,s2,
LifeSpan(p1,s1)).f by A9,SCMFSA_2:95;
    hence Comput(p2,s2,k).f = Comput(p +* P, Is,
    LifeSpan(p +* P,Is)).f by A8,A13,Th68,SCMFSA10:93
      .= IExec(P,p,s).f by A3,A12,SCMFSA8C:87
      .= IExec(I1,p,s).f by A6,SCMFSA_3:12
      .= Exec(SubFrom(a,intloc 0),IExec(I,p,s)).f by Th34
      .= IExec(I,p,s).f by SCMFSA_2:91;
  end;
  thus IC Comput(p2,s2,k) =  0 by A9,SCMFSA_2:95;
A16: IC Comput(p2,s2,LifeSpan(p1,s1)+1) =  0 by A9,
SCMFSA_2:95;
  hereby
    let n be Element of NAT;
    assume
A17: n <= k;
    per cases by A17,NAT_1:8;
    suppose
A18:  n <= LifeSpan(p1,s1);
A19:  I1 is_closed_onInit s,p & I1 is_halting_onInit s,p by Th35,Th36;
      then
A20:  P is_closed_onInit s,p by A2,Th45;
      P is_halting_onInit s,p by A2,A19,Th45;
      then Comput(p1,s1,n),Comput(p2,s2,n)
equal_outside A by A18,A20,Th68;
      then
A21:  IC Comput(p2,s2,n) = IC Comput(p1,s1,n) by
SCMFSA8A:6;
      IC Comput(p1,s1,n) in dom P by A20,Def4;
      hence IC Comput(p2, s2,n) in dom loop P by A21,FUNCT_4:105;
    end;
    suppose
A22:  n = LifeSpan(p1,s1) + 1;
A23:  card P = card Goto  2 + card I1 + 4 by SCMFSA8B:14
        .= card I1 + 1 + 4 by SCMFSA8A:29
        .= card I1 + 3 + 2;
      card loop P = card dom loop P by CARD_1:104
        .= card dom P by FUNCT_4:105
        .= card P by CARD_1:104;
      hence IC Comput(p2, s2,n) in dom loop P by A16,A22,A23,
AFINSQ_1:70;
    end;
  end;
end;

theorem Th78:
  for s being State of SCM+FSA, I being good InitHalting Program
of SCM+FSA, a being read-write Int-Location st s.intloc 0 = 1 & s.a <= 0 holds
  DataPart IExec(Times(a,I),p,s) = DataPart s
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.intloc 0 = 1;
  set s0 = Initialized s,
      p0 = p;
A2: Stop SCM+FSA is_closed_on s0,p0 &
   Stop SCM+FSA is_halting_on s0,p0 by SCMFSA7B:24
,25;
A3: ( for a being read-write Int-Location holds s0.a = s.a)& for f being
  FinSeq-Location holds s0.f = s.f by SCMFSA6C:3;
A4: s0.intloc 0 = 1 by SCMFSA6C:3;
  assume s.a <= 0;
  then
A5: (Initialized s).a <= 0 by SCMFSA6C:3;
A6: IExec(Stop SCM+FSA ';' Stop SCM+FSA,p0,s0)
 = IExec(Stop SCM+FSA,p0,IExec(Stop SCM+FSA,p0,s0))
  +* Start-At (IC IExec(Stop SCM+FSA,p0,IExec(Stop SCM+FSA,p0,s0)) + card
  Stop SCM+FSA,SCM+FSA) by SCMFSA6B:44;
A7: DataPart IExec(Stop SCM+FSA,p0,s0) = DataPart(Initialize Initialized s0)
    by SCMFSA8C:38
    .= DataPart(Initialize Initialized s) by SCMFSA8C:15
    .= DataPart s0 by SCMFSA8A:10;
A8: Stop SCM+FSA is_closed_on Initialized s,p & Stop SCM+FSA is_halting_on
  Initialized s,p by SCMFSA7B:24,25;
  then Times(a,I) is_closed_on Initialized s,p & Times(a,I) is_halting_on
  Initialized s,p by A5,SCMFSA8B:24;
  then DataPart IExec(Times(a,I),p,s)= DataPart IExec(Times(a,I),p0,s0)
   by A4,A3,
SCMFSA8C:45
    .= DataPart
     IExec(Stop SCM+FSA ';' Stop SCM+FSA,p0,s0) by A5,A2,A4,SCMFSA8A:37
,SCMFSA8C:73;
  hence DataPart IExec(Times(a,I),p,s)
   = DataPart IExec(Stop SCM+FSA,p0,IExec(Stop SCM+FSA,p0,s0))
         by A6,SCMFSA8A:10
    .= DataPart IExec(Stop SCM+FSA,p0,s0) by A8,A4,A7,SCMFSA8C:46
    .= DataPart s by A1,A7,SCMFSA8C:27;
  set P = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
end;

theorem Th79:
  for s being State of SCM+FSA, I being good InitHalting Program
  of SCM+FSA, a being read-write Int-Location st I does not destroy a & s.a > 0
holds IExec(I ';' SubFrom(a,intloc 0),p,s).a = s.a - 1 &
 DataPart IExec(Times(a,I),p,s)
  = DataPart IExec(Times(a,I),p,IExec(I ';' SubFrom(a,intloc 0),p,s))
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
  reconsider J3 = Macro SubFrom(a,intloc 0) as good Program of SCM+FSA;
  set I1 = I ';' SubFrom(a,intloc 0);
  set ss = IExec(I1,p,s),
      pp = p;
  I1 is_closed_onInit s,p by Th35;
  then
A2: I1 is_closed_on Initialized s,p by Th40;
  I1 is_halting_onInit s,p by Th36;
  then
A3: I1 = I ';' J3 & I1 is_halting_on Initialized s,p by Th41;
  then
A4: ss.intloc 0 = 1 by A2,SCMFSA8C:96;
  set P = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
  set s0 = Initialized s,
      p0 = p;
A5: ProgramPart loop P = loop P by RELAT_1:209;
  assume
A6: s.a > 0;
  then
A7: s0.a > 0 by SCMFSA6C:3;
  then consider s2 be State of SCM+FSA,
   p2 being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
   k be Element of NAT such that
A8: s2 = s0 +* Initialized loop P and
A9: p2 = p0 +* loop P and
  k = LifeSpan(p0 +* P,s0 +* Initialized P) + 1 and
A10: Comput(p2,s2,k).a = s0.a - 1 and
A11: Comput(p2,s2,k).intloc 0 = 1 and
A12: for b being read-write Int-Location st b <> a holds Comput(p2
,s2,k
  ).b = IExec(I,p0,s0).b and
A13: for f being FinSeq-Location holds Comput(p2,s2,k).f
         = IExec(I,p0,s0).f and
A14: IC Comput(p2,s2,k) =  0 and
A15: for n being Element of NAT st n <= k holds IC Comput(p2, s2,
n) in dom loop P by A1,Th77;
A16:  loop P c= p2 by A9,FUNCT_4:26;
A17: s2= Initialized s0 +* (Initialize loop P)
by A8,SCMFSA8A:13
    .= s0 +* (Initialize loop P) by SCMFSA8C:15;
A18: now
    let f be FinSeq-Location;
    thus Comput(p2,s2,k).f = IExec(I,p0,s0).f by A13
      .= Exec(SubFrom(a,intloc 0),IExec(I,p0,s0)).f by SCMFSA_2:91
      .= IExec(I1,p0,s0).f by Th34
      .= IExec(I1,p,s).f by SCMFSA8C:17;
  end;
  thus
A19: ss.a = Exec(SubFrom(a,intloc 0),IExec(I,p,s)).a by Th33
    .= IExec(I,p,s).a - IExec(I,p,s).intloc 0 by SCMFSA_2:91
    .= IExec(I,p,s).a - 1 by Th17
    .= s0.a - 1 by A1,Th63
    .= s.a - 1 by SCMFSA6C:3;
  now
    let b be Int-Location;
    per cases;
    suppose
      b = intloc 0;
      hence Comput(p2,s2,k).b = IExec(I1,p,s).b by A11,A3,A2,
SCMFSA8C:96;
    end;
    suppose
      b = a;
      hence Comput(p2,s2,k).b = IExec(I1,p,s).b by A10,A19,SCMFSA6C:3;
    end;
    suppose
A20:  b <> a & b <> intloc 0;
      then reconsider bb = b as read-write Int-Location by SF_MASTR:def 5;
      thus Comput(p2,s2,k).b = IExec(I,p0,s0).bb by A12,A20
        .= Exec(SubFrom(a,intloc 0),IExec(I,p0,s0)).b by A20,SCMFSA_2:91
        .= IExec(I1,p0,s0).b by Th33
        .= IExec(I1,p,s).b by SCMFSA8C:17;
    end;
  end;
  then
A21: DataPart Comput(p2,s2,k) = DataPart ss by A18,SCMFSA6A:38;
  set s21 = s0 +* Initialize (loop P ';' Stop SCM+FSA),
      p21 = p0 +* (loop P ';' Stop SCM+FSA);
  set ss0 = Initialized ss;
  set s31 = ss0 +* Initialize (loop P ';' Stop SCM+FSA),
      p31 = pp +* (loop P ';' Stop SCM+FSA);
   0 in dom P by SCMFSA8C:54;
  then
A22:  0 in dom loop P by FUNCT_4:105;
A23: s0.intloc 0 = 1 by SCMFSA6C:3;
  then
A24: loop P is_pseudo-closed_on s0,p0 by A1,A7,Th73;
A25: Directed loop P = loop P by SCMFSA6A:63;
  then
A26: Directed loop P is_pseudo-closed_on s0,p0 by A1,A23,A7,Th73;
A27: DataPart IExec(Times(a,I),p0,s0)
 = DataPart IExec(loop P ';' Stop SCM+FSA,
  p0,s0) by A1,A23,A7,A25,Th73,SCMFSA8C:69;
  per cases;
  suppose
A28: ss.a = 0;
A29: P. (card I1 + 3) = goto  (card I1 + 5) by SCMFSA8C:65;
A30: card I1 + (3 + 2) = card I1 + 1 + 4
      .= card Goto  2 + card I1 + 4 by SCMFSA8A:29
      .= card P by SCMFSA8B:14
      .= card dom P by CARD_1:104
      .= card dom loop P by FUNCT_4:105
      .= card loop P by CARD_1:104;
    then card I1 + 3 + 0 < card loop P by XREAL_1:8;
    then
A31:  (card I1 + 3) in dom loop P by AFINSQ_1:70;
    p2. (card I1 + 3) = p2. (card I1 + 3)
      .= (loop P). (card I1 + 3) by A31,GRFUNC_1:8,A16;
    then
A32: p2. (card I1 + 3) = goto  (card I1 + 5)
    by A29,FUNCT_4:111;
A33: p2. 0 = p2. 0
      .= (loop P). 0 by A22,GRFUNC_1:8,A16;
A34: Comput(p2,s2,k+1) = Following(p2,Comput(p2,s2,k)) by EXTPRO_1:4
      .= Exec(p2.0,Comput(p2,s2,k)) by
       A14,PBOOLE:158;
A35: P. 0 = a =0_goto  (card I1 + 3) by SCMFSA8C:55;
A36: p2. 0 = a =0_goto  (card I1 + 3) by A33,A35,FUNCT_4:111;
    then InsCode p2. 0 = 7 by SCMFSA_2:48;
    then InsCode p2. 0 in {0,6,7,8} by ENUMSET1:def 2;
    then
A37: DataPart Comput(p2,s2,k) = DataPart Comput(p2,s2
,k+1) by A34,SCMFSA8C:32;
A38: Comput(p2,s2,k).a = 0 by A10,A19,A28,SCMFSA6C:3;
    then
A39: IC Comput(p2,s2,k+1) =  (card I1 + 3) by A34,A36,SCMFSA_2:96;
A40: now
      let n be Element of NAT;
      assume
A41:  not IC Comput(p2, s2,n) in dom loop P;
      then k < n by A15;
      then k + 1 <= n by INT_1:20;
      then k + 1 < n by A39,A31,A41,XXREAL_0:1;
      then k + 1 + 1 <= n by INT_1:20;
      hence k + (1 + 1) <= n;
    end;
A42:  p2/.IC Comput(p2,s2,k+1) = p2.IC Comput(p2,s2,k+1) by PBOOLE:158;
A43: Comput(p2,s2,k+(1+1)) = Comput(p2,s2,k+1+1)
      .= Following(p2,Comput(p2,s2,k+1))
       by EXTPRO_1:4
      .= Exec(p2. (card I1 + 3),Comput(p2,s2,k+1))
    by A38,A34,A36,A42,SCMFSA_2:96;
    then IC Comput(p2,s2,k+2) =  (card I1 + 5) by A32,SCMFSA_2:95
      .=  card loop P by A30;
    then
A44: k + 2 = pseudo-LifeSpan(s0,p0,loop P)
        by A17,A24,A40,SCMFSA8A:def 5,A9,A5;
    InsCode p2. (card I1 + 3) = 6 by A32,
SCMFSA_2:47;
    then InsCode p2. (card I1 + 3) in {0,6,7,8} by
ENUMSET1:def 2;
    then
A45: DataPart Comput(p2,s2,k) = DataPart Comput(p2,s2
,k+2) by A37,A43,SCMFSA8C:32;
A46: s21 = s +* Initialized (loop P ';' Stop SCM+FSA) by SCMFSA8A:13;
    thus DataPart IExec(Times(a,I),p,s) = DataPart IExec(Times(a,I),p0,s0) by
SCMFSA8C:17
      .= DataPart IExec(loop P ';' Stop SCM+FSA,p,s) by A27,SCMFSA8C:17
      .= DataPart(Result(p21,s21) +* s | A) by A46,SCMFSA6B:def 1
      .= DataPart (Result(p21,s21)) by COMPOS_1:82
      .= DataPart IExec(I1,p,s)
       by A1,A23,A7,A17,A25,A21,A44,A45,Th73,SCMFSA8C:59,A9
      .= DataPart IExec(Times(a,I),p,IExec(I1,p,s)) by A4,A28,Th78;
  end;
  suppose
A47: ss.a <> 0;
    s.a >= 0 + 1 by A6,INT_1:20;
    then
A48: ss.a > 0 by A19,A47,XREAL_1:21;
A49: Initialize (loop P ';' Stop SCM+FSA) c= s21 &
     Initialize (loop P ';' Stop SCM+FSA) c= s31 by FUNCT_4:26;
 loop P is_pseudo-closed_on s0,p0
 by A1,A23,A7,Th73;
  then
A50: k < pseudo-LifeSpan(s0,p0,loop P)
 by A15,A17,SCMFSA8C:2,A9,A5;
    then
A51: DataPart Comput(p21, s21,k) = DataPart ss by A17,A25,A26,A21
,SCMFSA8C:58,A9;
A52: now
A53:  DataPart ss0 = DataPart s31 by SCMFSA8A:11;
      hereby
        let a be Int-Location;
        per cases;
        suppose
A54:      a = intloc 0;
          thus Comput(p21, s21,k).a = ss.a by A51,SCMFSA6A:38
            .= 1 by A54,Th17
            .= ss0.a by A54,SCMFSA6C:3
            .= s31.a by A53,SCMFSA6A:38;
        end;
        suppose
          a <> intloc 0;
          then
A55:      a is read-write Int-Location by SF_MASTR:def 5;
          thus Comput(p21, s21,k).a = ss.a by A51,SCMFSA6A:38
            .= ss0.a by A55,SCMFSA6C:3
            .= s31.a by A53,SCMFSA6A:38;
        end;
      end;
      let f be FinSeq-Location;
      thus Comput(p21, s21,k).f = ss.f by A51,SCMFSA6A:38
        .= ss0.f by SCMFSA6C:3
        .= s31.f by A53,SCMFSA6A:38;
    end;
    IC Comput(p21, s21,k) = IC Comput(p2,s2,k) by
A17,A25,A26,A50,SCMFSA8C:58,A9
      .= IC Initialize (ss0 +* (loop P ';' Stop SCM+FSA))
       by A14,FUNCT_4:121
      .= IC s31 by FUNCT_4:15;
    then
A56: Comput(p21, s21,k),s31 equal_outside A by A52,SCMFSA10:91;
A57: ss.intloc 0 = 1 by A3,A2,SCMFSA8C:96;
    Directed loop P = loop P & DataPart s0 = DataPart s21 by SCMFSA6A:63
,SCMFSA8A:11;
    then Directed loop P is_pseudo-closed_on s21,p21
           by A1,A23,A7,Th73,SCMFSA8C:52;
    then
A58: loop P ';' Stop SCM+FSA is_closed_on s21,p21 & loop P ';' Stop SCM+FSA
    is_halting_on s21,p21 by SCMFSA8C:58;
A59:  s21 = s +* Initialized (loop P ';' Stop SCM+FSA) by SCMFSA8A:13;
A60:  s31 = ss +* Initialized (loop P ';' Stop SCM+FSA) by SCMFSA8A:13;
A61: loop P ';' Stop SCM+FSA c= p21 & loop P ';' Stop SCM+FSA c= p31
        by FUNCT_4:26;
A62:  Result(p21,s21),Result(p31,s31) equal_outside NAT
     by A49,A58,A56,SCMFSA8C:103,A61;
    DataPart IExec(loop P ';' Stop SCM+FSA,p0,s0) = DataPart IExec(loop P
    ';' Stop SCM+FSA,p,s) by SCMFSA8C:17
      .= DataPart(Result(p21,s21) +* s | A) by A59,SCMFSA6B:def 1
      .= DataPart(Result(p21,s21)) by COMPOS_1:82
      .= DataPart(Result(p31,s31)) by COMPOS_1:138
,A62
      .= DataPart(Result(p31,s31) +* ss | A) by COMPOS_1:82
      .= DataPart IExec(loop P ';' Stop SCM+FSA,p,IExec(I1,p,s))
            by A60,SCMFSA6B:def 1
      .= DataPart IExec(Times(a,I),p,IExec(I1,p,s)) by A1,A25,A57,A48,Th73,
SCMFSA8C:69;
    hence thesis by A27,SCMFSA8C:17;
  end;
end;

theorem
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, f
be FinSeq-Location,a be read-write Int-Location st s.a <= 0
 holds IExec(Times(a,I),p,s).f=s.f
proof
  set D= Data-Locations SCM+FSA;
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, f be
  FinSeq-Location,a be read-write Int-Location;
  assume
A1: s.a <= 0;
  set s0 = Initialized s,
      p0 = p;
A2: s0.a=s.a & s0.(intloc 0)=1 by SCMFSA6C:3;
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A3: f in D by XBOOLE_0:def 3,SCMFSA_2:127;
  DataPart IExec(Times(a,I),p,s) = DataPart IExec(Times(a,I),p0,s0)
   by SCMFSA8C:17
    .= DataPart s0 by A1,A2,Th78;
  hence IExec(Times(a,I),p,s).f= (DataPart s0).f by A3,FUNCT_1:72
    .= s0.f by A3,FUNCT_1:72
    .= s.f by SCMFSA6C:3;
end;

theorem
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, b
be Int-Location,a be read-write Int-Location st s.a <= 0
 holds IExec(Times(a,I),p,s).b=(Initialized s).b
proof
  set D= Data-Locations SCM+FSA;
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, b be
  Int-Location,a be read-write Int-Location;
  assume
A1: s.a <= 0;
  set s0 = Initialized s,
      p0 = p;
A2: s0.a=s.a & s0.(intloc 0)=1 by SCMFSA6C:3;
  b in Int-Locations by SCMFSA_2:9;
  then
A3: b in D by XBOOLE_0:def 3,SCMFSA_2:127;
  DataPart IExec(Times(a,I),p,s) = DataPart IExec(Times(a,I),p0,s0)
   by SCMFSA8C:17
    .= DataPart s0 by A1,A2,Th78;
  hence IExec(Times(a,I),p,s).b= (DataPart s0).b by A3,FUNCT_1:72
    .= s0.b by A3,FUNCT_1:72;
end;

theorem
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, f
be FinSeq-Location,a be read-write Int-Location st I does not destroy a & s.a >
0 holds IExec(Times(a,I),p,s).f
 =IExec(Times(a,I),p,IExec(I ';' SubFrom(a,intloc 0),p,s)).f
proof
  set D= Data-Locations SCM+FSA;
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, f be
  FinSeq-Location,a be read-write Int-Location;
  assume
A1: I does not destroy a & s.a > 0;
  set IT=IExec(Times(a,I),p,IExec(I ';' SubFrom(a,intloc 0),p,s));
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A2: f in D by XBOOLE_0:def 3,SCMFSA_2:127;
  hence IExec(Times(a,I),p,s).f=(DataPart IExec(Times(a,I),p,s)).f
   by FUNCT_1:72

    .=(DataPart IT).f by A1,Th79
    .= IT.f by A2,FUNCT_1:72;
end;

theorem
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, b
be Int-Location,a be read-write Int-Location st I does not destroy a & s.a > 0
holds IExec(Times(a,I),p,s).b
 =IExec(Times(a,I),p,IExec(I ';' SubFrom(a,intloc 0),p,s)).b
proof
  set D= Data-Locations SCM+FSA;
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, b be
  Int-Location,a be read-write Int-Location;
  assume
A1: I does not destroy a & s.a > 0;
  set IT=IExec(Times(a,I),p,IExec(I ';' SubFrom(a,intloc 0),p,s));
  b in Int-Locations by SCMFSA_2:9;
  then
A2: b in D by XBOOLE_0:def 3,SCMFSA_2:127;
  hence IExec(Times(a,I),p,s).b=(DataPart IExec(Times(a,I),p,s)).b
   by FUNCT_1:72

    .=(DataPart IT).b by A1,Th79
    .= IT.b by A2,FUNCT_1:72;
end;

definition
  let i be Instruction of SCM+FSA;
  redefine attr i is good means
  :Def6:
  i does not destroy intloc 0;
  compatibility
   proof
     rng Macro i = {i,halt SCM+FSA} by FUNCT_4:67;
     then i in rng Macro i by TARSKI:def 2;
     then
A1:  Macro i does not destroy intloc 0 implies i does not destroy intloc 0
                   by SCMFSA7B:def 4;
A2:  i does not destroy intloc 0 implies Macro i does not destroy intloc 0
      by SCMFSA8C:77;
     Macro i is good iff i is good by SFMASTR1:def 1;
    hence i is good iff i does not destroy intloc 0 by A2,A1,SCMFSA7B:def 5;
   end;
end;

registration
  cluster parahalting good Instruction of SCM+FSA;
  existence
  proof
    take x=halt SCM+FSA;
    thus x is parahalting;
    x does not destroy intloc 0 by SCMFSA7B:11;
    hence thesis by Def6;
  end;
end;

registration
  let n be Element of NAT;
  cluster intloc (n+1) -> read-write;
  coherence
  proof
    intloc (n+1) <> intloc 0 by AMI_3:52;
    hence thesis by SF_MASTR:def 5;
  end;
end;

