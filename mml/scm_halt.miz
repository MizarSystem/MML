:: Initialization Halting Concepts and Their Basic Properties of SCM+FSA
::  by JingChao Chen and Yatsuka Nakamura
::
:: Received June 17, 1998
:: Copyright (c) 1998-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMFSA_2, FSM_1, SCMFSA6A, TARSKI,
      CIRCUIT2, RELAT_1, FUNCT_1, CARD_1, FUNCOP_1, FUNCT_4,
      XBOOLE_0, SCMFSA6B, NAT_1, XXREAL_0, ARYTM_3, AMI_3, SF_MASTR, GRAPHSP,
      MSUALG_1, AMISTD_2, TURING_1, STRUCT_0, VALUED_1, SCMFSA6C, SCMFSA7B,
      UNIALG_2, SCMFSA8B, ARYTM_1, SCMFSA8C, SCMFSA8A, SCM_HALT, PARTFUN1,
      SCMNORM, RELOC, COMPOS_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, RELAT_1, FINSEQ_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7, PBOOLE,
      VALUED_1, STRUCT_0, MEMSTR_0, COMPOS_1, EXTPRO_1,
      AMISTD_1, AMISTD_2, SCMFSA_2,
      FUNCOP_1, SCMFSA6B, SCMFSA6A, SF_MASTR, SCMFSA8A, SCMFSA8B, SFMASTR1,
      SCMFSA8C, SCMFSA7B, NAT_D, SCMFSA_3, SCMFSA6C, XXREAL_0;
 constructors SFMASTR1, DOMAIN_1, XXREAL_0, REAL_1, SCM_1, SCMFSA_3, SCMFSA6A,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA8C, AMISTD_1,
      AMISTD_2, NAT_D, RELSET_1, VALUED_1, SCMFSA7B, SCMFSA_9, AMISTD_5,
      PBOOLE, PRE_POLY, MEMSTR_0;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SCMFSA8C, SCMFSA_9, ORDINAL1, RELAT_1, SCMFSA10, AMISTD_2,
      COMPOS_1, SFMASTR1, EXTPRO_1, SCMFSA_4, PBOOLE, FUNCT_4, FUNCT_7,
      PRE_POLY, STRUCT_0, FUNCOP_1, MEMSTR_0;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, XBOOLE_0, SCMFSA_2, SCMFSA8C,
      SCMFSA6A, AMISTD_2, SCMFSA7B, MEMSTR_0;
 theorems SF_MASTR, FUNCT_1, FUNCT_7, FUNCOP_1, RELAT_1, SCMFSA6A, FUNCT_4,
      ENUMSET1, AMI_3, NAT_1, TARSKI, INT_1, GRFUNC_1, SCMFSA_2, SCMFSA6B,
      SCMFSA7B, SCMFSA8B, SCMFSA8A, SCMFSA8C, SCMFSA_3, SCMFSA6C, CARD_1,
      XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0, VALUED_1, XREAL_0,
      PBOOLE, PARTFUN1, AFINSQ_1, FINSEQ_4, COMPOS_1, SFMASTR1, EXTPRO_1,
      AMISTD_2, AMISTD_5, ZFMISC_1, MEMSTR_0, AMISTD_1, STRUCT_0;
 schemes NAT_1;

begin

reserve m,n for Element of NAT,
  I for Program of SCM+FSA,
  s,s1,s2 for State of SCM+FSA,
  a for Int-Location,
  f for FinSeq-Location,
  p,p1,p2 for Instruction-Sequence of SCM+FSA;

set SA0 = Start-At(0,SCM+FSA);
set iS = Initialize ((intloc 0) .--> 1);
reconsider EP = {} as PartState of SCM+FSA by FUNCT_1:104,RELAT_1:171;
ICiS: IC iS = 0 by MEMSTR_0:def 8;
zSA0: SA0 c= iS by FUNCT_4:25;
diS: dom iS = dom ((intloc 0) .--> 1) \/ dom Start-At(0,SCM+FSA)
     by FUNCT_4:def 1
      .= {intloc 0} \/ dom Start-At(0,SCM+FSA) by FUNCOP_1:13
      .= {intloc 0} \/ {IC SCM+FSA} by FUNCOP_1:13;

definition
  let I be Program of SCM+FSA;
  attr I is InitClosed means
:Def1:
  for s being State of SCM+FSA,
      P being Instruction-Sequence of SCM+FSA
       st I c= P
   for n being Element of NAT st Initialize ((intloc 0) .--> 1) c= s
   holds IC Comput(P,s,n) in dom I;
  attr I is InitHalting means
:Def2:
  for s being State of SCM+FSA st Initialize ((intloc 0) .--> 1) c= s
  for P being Instruction-Sequence of SCM+FSA
   st I c= P
  holds P halts_on s;
  attr I is keepInt0_1 means
  :Def3:
  for s being State of SCM+FSA st Initialize ((intloc 0) .--> 1) c= s
  for p st I c= p
  for k being Element of NAT holds (Comput(p,s,k)).intloc 0 = 1;
end;

theorem
  for x being set,i,m,n being Element of NAT st x in dom (((intloc
  i) .--> m) +* Start-At(n,SCM+FSA)) holds x=intloc i or x=IC SCM+FSA
proof
  let x be set,i,m,n be Element of NAT;
  set iS = ((intloc i) .--> m) +* Start-At(n,SCM+FSA);
  dom ((intloc i) .--> m) ={intloc i } & dom(Start-At(n,SCM+FSA)) = {IC
  SCM+FSA} by FUNCOP_1:13;
  then
A1: dom iS ={intloc i} \/ {IC SCM+FSA} by FUNCT_4:def 1;
  assume x in dom iS;
  then x in{intloc i} or x in {IC SCM+FSA} by A1,XBOOLE_0:def 3;
  hence thesis by TARSKI:def 1;
end;

theorem Th4:
  Macro halt SCM+FSA is InitHalting
proof
  let s be State of SCM+FSA;
  set m = Macro halt SCM+FSA;
  set m1 = m;
  assume
A1: iS c= s;
  let p be Instruction-Sequence of SCM+FSA;
  assume
A2: m c= p;
B6: IC SCM+FSA in dom iS by MEMSTR_0:48;
  take 0;
     IC Comput(p,s,0) in NAT;
    hence IC Comput(p,s,0) in dom p by PARTFUN1:def 2;
A8: m. 0 = halt SCM+FSA by COMPOS_1:58;
  dom m = { 0, 1} by COMPOS_1:61;
  then
A9:  0 in dom m by TARSKI:def 2;
A10:  p/.IC s = p.IC s by PBOOLE:143;
  CurInstr(p,Comput(p,s,0))
   = CurInstr(p,s) by EXTPRO_1:2
    .= p.0 by ICiS,A1,A10,B6,GRFUNC_1:2
    .= halt SCM+FSA by A8,A2,A9,GRFUNC_1:2;
    hence thesis;
end;

registration
  cluster InitHalting for Program of SCM+FSA;
  existence by Th4;
end;

theorem Th7:
  for I being Program of SCM+FSA,s being State of SCM+FSA st
  Initialize ((intloc 0) .--> 1) c= s holds s.intloc 0 =1
proof
  let I be Program of SCM+FSA,s be State of SCM+FSA;
Y:  dom iS = dom((intloc 0) .--> 1) \/ dom SA0 by FUNCT_4:def 1;
    intloc 0 in dom((intloc 0) .--> 1) by FUNCOP_1:74;
    then
A1: intloc 0 in dom iS by Y,XBOOLE_0:def 3;
C:  dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    IC SCM+FSA <> intloc 0 by SCMFSA_2:56;
    then not intloc 0 in dom SA0 by C,TARSKI:def 1;
    then
B1: iS.intloc 0 = ((intloc 0) .--> 1).intloc 0 by FUNCT_4:11
      .= 1 by FUNCOP_1:72;
  assume iS c= s;
  hence thesis by A1,B1,GRFUNC_1:2;
end;

registration
  cluster paraclosed -> InitClosed for Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
A1: I is paraclosed;
    let s be State of SCM+FSA,
      P be Instruction-Sequence of SCM+FSA such that
A2: I c= P;
   let n being Element of NAT such that
A3: iS c= s;
    SA0 c= iS by FUNCT_4:25;
    then SA0 c= s by A3,XBOOLE_1:1;
    then s is 0-started by MEMSTR_0:29;
   hence IC Comput(P,s,n) in dom I by A1,A2,AMISTD_1:def 10;
  end;
end;

registration
  cluster parahalting -> InitHalting for Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
Z0:  I is parahalting;
    let s be State of SCM+FSA such that
Z1:   iS c= s;
    let P be Instruction-Sequence of SCM+FSA
    such that
Z2: I c= P;
    SA0 c= iS by FUNCT_4:25;
    then SA0 c= s by Z1,XBOOLE_1:1;
    then s is 0-started by MEMSTR_0:29;
   hence P halts_on s by Z0,Z2,AMISTD_1:def 11;
  end;
end;

registration
  cluster InitHalting -> InitClosed for Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
Z:    I is InitHalting;
    let s be State of SCM+FSA;
    let P be Instruction-Sequence of SCM+FSA
    such that
A2: I c= P;
    let n be Element of NAT;
    assume
A3: iS c= s;
    defpred X[Nat] means not IC Comput(P,s,$1) in dom I;
    assume not IC Comput(P,s,n) in dom I;
    then
A5: ex n be Nat st X[n];
    consider n be Nat such that
A6: X[n] and
A7: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A5);
    reconsider n as Element of NAT by ORDINAL1:def 12;
A8: for m st m < n holds IC(Comput(P,s,m)) in dom I by A7;
    set s2 = Comput(P,s,n),
        p2 = P,
        s0 = s,
        p0 = P +*(IC s2, goto IC s2),
        s1 = s2,
        p1 = P+*(IC s2,goto IC s2);
YY:  I c= p0 by A2,A6,FUNCT_7:89;
    then
XX:    Comput(p0,s0,n) =  s2 by A8,A2,AMISTD_2:10;
    p0 halts_on s0 by Z,Def2,A3,YY;
    then p0 halts_on Comput(p0,s0,n) by EXTPRO_1:22;
    hence contradiction by XX,SCMFSA6B:21;
  end;
  cluster keepInt0_1 -> InitClosed for Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
A17: I is keepInt0_1;
    set FI = FirstNotUsed(I);
    let s be State of SCM+FSA;
    let p be Instruction-Sequence of SCM+FSA
    such that
A18: I c= p;
    let n be Element of NAT;
    assume
A19: iS c= s;
    then
B19: SA0 c= s by zSA0,XBOOLE_1:1;
    defpred X[Nat] means not IC Comput(p,s,$1) in dom I;
    assume
   not IC Comput(p,s,n) in dom I;
    then
A20: ex n be Nat st X[n];
    consider n be Nat such that
A21: X[n] and
A22: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A20);
    reconsider n as Element of NAT by ORDINAL1:def 12;
    set s2 = Comput(p,s,n),
        p0 = p +*(IC s2, intloc 0 := FI);
    set s0 = s+* (FI, (s.intloc 0)+1);
    reconsider s as State of SCM+FSA;
    reconsider s0 as State of SCM+FSA;
    not I is keepInt0_1
    proof
      FI <> IC SCM+FSA by SCMFSA_2:56;
      then
A25:  not FI in {IC SCM+FSA} by TARSKI:def 1;
      set s02 = Comput(p0,s0,n);
      set iIC={intloc 0} \/ {IC SCM+FSA};
      take s0;
      FI in dom s by SCMFSA_2:42;
      then
A27:  s0.FI = (s.intloc 0)+1 by FUNCT_7:31;
B29:   s.intloc 0=1 by A19,Th7;
A29:   not FI in UsedIntLoc I by SF_MASTR:50;
      not FI in {intloc 0} by TARSKI:def 1;
      then not FI in dom iS by diS,A25,XBOOLE_0:def 3;
      hence iS c= s0 by A19,FUNCT_7:89;
      then
B31:  SA0 c= s0 by zSA0,XBOOLE_1:1;
      take p0;
      thus
A32:   I c= p0 by A18,A21,FUNCT_7:89;
      not FI in UsedInt*Loc I
      proof
        assume not thesis;
        then FI is FinSeq-Location by SCMFSA_2:5;
        hence contradiction by SCMFSA_2:58;
      end;
      then
A34:  s0 | UsedInt*Loc I = s | UsedInt*Loc I by FUNCT_7:92;
A36:  s0 | UsedIntLoc I = s | UsedIntLoc I by FUNCT_7:92,SF_MASTR:50;
A37:  for m st m < n
        holds IC Comput(p,s,m) in dom I by A22;
A38:  IC s02 = IC s2 by A36,A34,A18,A32,B31,A37,B19,SF_MASTR:65;
      take k = n+1;
      IC s2 in NAT;
      then
A39:  IC s2 in dom p by PARTFUN1:def 2;
A40:  p0.IC s2 = intloc 0 := FI by A39,FUNCT_7:31;
A42:  Comput(p0,s0,k) = Following(p0,s02) by EXTPRO_1:3
        .= Exec(intloc 0 := FI, s02) by A38,A40,PBOOLE:143;
      for m st m < n holds IC Comput(p0,s0,m) in dom I
       by A37,A36,A34,A18,A32,B31,B19,SF_MASTR:65;
      then s02.FI = 1+1 by A29,A27,A18,A21,B29,FUNCT_7:89,SF_MASTR:61;
      hence thesis by A42,SCMFSA_2:63;
    end;
    hence contradiction by A17;
  end;
  cluster keeping_0 -> keepInt0_1 for Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
A43: I is keeping_0;
      let s be State of SCM+FSA;
      assume
A44:  iS c= s;
      let p;
      assume
A45:   I c= p;
      let k be Element of NAT;
      SA0 c= iS by FUNCT_4:25;
      then
   SA0 c= s by A44,XBOOLE_1:1;
      then
C47:   s is 0-started by MEMSTR_0:29;
      s.intloc 0=1 by A44,Th7;
      hence (Comput(p,s,k)).intloc 0 = 1 by A43,A45,C47,SCMFSA6B:def 4;
  end;
end;

theorem
  for I being InitHalting Program of SCM+FSA, a being read-write
  Int-Location holds not a in UsedIntLoc I implies (IExec(I,p,s)).a = s.a
proof
  let I be InitHalting Program of SCM+FSA, a be read-write Int-Location;
    a <> intloc 0 & a <> IC SCM+FSA by SCMFSA_2:56;
    then
B1: not a in dom iS by SCMFSA6A:42,TARSKI:def 2;
A2: (IExec(I,p,s)).a = (Result(p+*I,Initialized s)).a by SCMFSA6B:def 1;
A3:  iS c= Initialized s by FUNCT_4:25;
  I c= p+*I by FUNCT_4:25;
  then p+*I halts_on Initialized s by Def2,A3;
  then consider n such that
A4: Result(p+*I,Initialized s) = Comput(p +* I,s+* iS,n)
    and
  CurInstr(p+*I,Result(p+*I,Initialized s))
   = halt SCM+FSA by EXTPRO_1:def 9;
A5: I c= p+* I by FUNCT_4:25;
A6: for m st m < n holds IC
   Comput(p+*I,Initialized s,m) in dom I by Def1,A5,A3;
  assume not a in UsedIntLoc I;
  hence (IExec(I,p,s)).a
     = (Initialized s).a by A2,A4,A6,FUNCT_4:25,SF_MASTR:61
    .= s.a by B1,FUNCT_4:11;
end;

theorem
  for I being InitHalting Program of SCM+FSA,f being FinSeq-Location
  holds not f in UsedInt*Loc I implies (IExec(I,p,s)).f = s.f
proof
  let I be InitHalting Program of SCM+FSA,f be FinSeq-Location;
    f <> intloc 0 & f <> IC SCM+FSA by SCMFSA_2:57,58;
    then
B1: not f in dom iS by SCMFSA6A:42,TARSKI:def 2;
A2: (IExec(I,p,s)).f = (Result(p+*I,Initialized s)).f
       by SCMFSA6B:def 1;
A3:  iS c= Initialized s by FUNCT_4:25;
  I c= p+*I by FUNCT_4:25;
  then p+*I halts_on Initialized s by Def2,A3;
  then consider n such that
A4: Result(p+*I,Initialized s) = Comput(p +* I,Initialized s,n) and
  CurInstr(p+*I,Result(p+*I,Initialized s))
   = halt SCM+FSA by EXTPRO_1:def 9;
A5: I c= p +* I by FUNCT_4:25;
A7: for m st m < n holds IC
   Comput(p+*I,Initialized s,m) in dom I by Def1,A5,A3;
  assume not f in UsedInt*Loc I;
  hence (IExec(I,p,s)).f = (Initialized s).f by A2,A4,A7,FUNCT_4:25,SF_MASTR:63
    .= s.f by B1,FUNCT_4:11;
end;

registration
  cluster InitHalting -> non empty for Program of SCM+FSA;
  coherence;
end;

theorem Th12:
  for J being InitHalting Program of SCM+FSA
   st Initialize ((intloc 0) .--> 1) c= s1 & J c= p1
  for n being Element of NAT st
  Reloc(J,n) c= p2 &
   IC s2 = n & DataPart s1 = DataPart s2
  for i being Element of NAT holds
   IC Comput(p1,s1,i) + n = IC Comput(p2,s2,i) &
   IncAddr(CurInstr(p1,Comput(p1,s1,i)),n) = CurInstr(p2,Comput(p2,s2,i)) &
   DataPart Comput(p1,s1,i) = DataPart Comput(p2,s2,i)
proof
  let J be InitHalting Program of SCM+FSA;
  assume that
A1: iS c= s1 and
A2: J c= p1;
  let n be Element of NAT;
  assume that
A3: Reloc(J,n) c= p2 and
A4: IC s2 =  n and
A5: DataPart s1 = DataPart s2;
A6: DataPart Comput(p1,s1,0) = DataPart s2 by A5,EXTPRO_1:2
    .= DataPart Comput(p2,s2,0) by EXTPRO_1:2;
  defpred P[Nat] means IC Comput(p1,s1,$1) + n = IC Comput(p2,s2,$1) &
   IncAddr(CurInstr(p1,Comput(p1,s1,$1)),n)
       = CurInstr(p2,Comput(p2,s2,$1)) &
   DataPart Comput(p1,s1,$1) = DataPart Comput(p2,s2,$1);
A7: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
A8: Comput(p1,s1,k+1) = Following(p1,Comput(p1,s1,k)) by EXTPRO_1:3
      .= Exec(CurInstr(p1,Comput(p1,s1,k)),
      Comput(p1,s1,k));
    reconsider l = IC Comput(p1,s1,k+1) as Element of NAT;
    reconsider j = CurInstr(p1,
    Comput(p1,s1,k+1)) as Instruction of SCM+FSA;
A9: Comput(p2,s2,k+1) = Following(p2,
Comput(p2,s2,k)) by EXTPRO_1:3
      .= Exec(CurInstr(p2,Comput(p2,s2,k)),
      Comput(p2,s2,k));
A10: IC Comput(p1,s1,k+1) in dom J by A1,Def1,A2;
    assume
A11: P[k];
    hence
 IC Comput(p1,s1,k+1) + n = IC Comput(p2,s2,k+1)
by A8,A9,SCMFSA6A:8;
    then
A12: IC Comput(p2,s2,k+1) in dom Reloc(J,n) by A10,COMPOS_1:46;
A13: l in dom J by A1,Def1,A2;
    j = p1.IC Comput(p1,s1,k+1) by PBOOLE:143
      .= J.l by A10,A2,GRFUNC_1:2;
    hence IncAddr(CurInstr(p1,Comput(p1,s1,k+1)),n)
       = Reloc(J,n).(l + n) by A13,COMPOS_1:35
      .= (Reloc(J,n)).(IC Comput(p2,s2,k+1))
            by A11,A8,A9,SCMFSA6A:8
      .= p2.IC Comput(p2,s2,k+1) by A12,A3,GRFUNC_1:2
      .= CurInstr(p2,Comput(p2,s2,k+1)) by PBOOLE:143;
    thus thesis by A11,A8,A9,SCMFSA6A:8;
  end;
A14:  0 in dom J by AFINSQ_1:65;
A15:  0 in dom J by AFINSQ_1:65;
B16: IC SCM+FSA in dom iS by MEMSTR_0:48;
  then
A17: p1.IC s1 = p1.IC iS by A1,GRFUNC_1:2
    .= J. 0 by A15,A2,ICiS,GRFUNC_1:2;
  let i be Element of NAT;
   0 in dom J by AFINSQ_1:65;
  then
A18:  (0 + n) in dom Reloc(J,n) by COMPOS_1:46;
A19: IC Comput(p1,s1,0) = s1.IC SCM+FSA by EXTPRO_1:2
    .=  0 by ICiS,A1,B16,GRFUNC_1:2;
A20: p2/.IC s2 = p2.IC s2 by PBOOLE:143;
A21: p1/.IC s1 = p1.IC s1 by PBOOLE:143;
  IncAddr(CurInstr(p1,Comput(p1,s1,0)),n)
     = IncAddr(CurInstr(p1,s1),n) by EXTPRO_1:2
    .= Reloc(J,n).( 0 + n) by A17,A14,A21,COMPOS_1:35
    .= CurInstr(p2,s2) by A4,A18,A20,A3,GRFUNC_1:2
    .= CurInstr(p2,Comput(p2,s2,0)) by EXTPRO_1:2;
  then
A22: P[0] by A4,A19,A6,EXTPRO_1:2;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A22,A7);
  hence thesis;
end;



theorem Th14:
  for I being InitHalting Program of SCM+FSA st
   Initialize ((intloc 0) .--> 1) c= s1 &
   Initialize ((intloc 0) .--> 1) c= s2 &
   I c= p1 & I c= p2 &
    s1 =  s2
 for k being Element of NAT holds
   Comput(p1,s1,k) =  Comput(p2,s2,k) &
  CurInstr(p1,Comput(p1,s1,k)) = CurInstr(p2,Comput(p2,s2,k))
proof
  let I be InitHalting Program of SCM+FSA;
  assume that
A1: iS c= s1 and
A2: iS c= s2 and
A3: I c= p1 and
A4: I c= p2 and
A5:  s1 =  s2;
    let k be Element of NAT;
A6: IC Comput(p1,s1,k) in dom I by A1,Def1,A3;
A7: IC Comput(p2,s2,k) in dom I by A2,Def1,A4;
    for m being Element of NAT st m < k holds IC(Comput(p2,s2,m))
in dom
    I by A2,Def1,A4;
    hence
K:   Comput(p1,s1,k) =  Comput(p2,s2,k)
     by A5,A3,A4,AMISTD_2:10;
    thus CurInstr(p2,Comput(p2,s2,k))
       = p2.IC Comput(p2,s2,k) by PBOOLE:143
      .= I.IC Comput(p2,s2,k) by A7,A4,GRFUNC_1:2
      .= p1.IC Comput(p1,s1,k) by K,A6,A3,GRFUNC_1:2
      .= CurInstr(p1,Comput(p1,s1,k)) by PBOOLE:143;
end;

theorem Th15:
  for I being InitHalting Program of SCM+FSA
   st Initialize ((intloc 0) .--> 1) c= s1 &
     Initialize ((intloc 0) .--> 1) c= s2 & I c= p1 & I c= p2 &
    s1 =  s2
 holds LifeSpan(p1,s1) = LifeSpan(p2,
  s2) &  Result(p1,s1) =  Result(p2,s2)
proof
  let I be InitHalting Program of SCM+FSA;
  assume that
A1: iS c= s1 and
A2: iS c= s2 and
A3: I c= p1 and
A4: I c= p2 and
A5:  s1 =  s2;
A6: p2 halts_on s2 by A2,Def2,A4;
A7: p1 halts_on s1 by A1,Def2,A3;
A8: now
    let l be Element of NAT;
    assume
A9: CurInstr(p2,Comput(p2,s2,l)) = halt SCM+FSA;
    CurInstr(p1,Comput(p1,s1,l)) = CurInstr(p2,Comput(p2,s2,l))
     by A1,A5,Th14,A3,A4;
    hence LifeSpan(p1,s1) <= l by A7,A9,EXTPRO_1:def 15;
  end;
  CurInstr(p2,Comput(p2,s2,LifeSpan(p1,s1)))
    = CurInstr(p1,Comput(p1,s1,LifeSpan(p1,s1))) by A1,A5,Th14,A3,A4
    .= halt SCM+FSA by A7,EXTPRO_1:def 15;
  hence
A10:  LifeSpan(p1,s1) = LifeSpan(p2,s2) by A8,A6,EXTPRO_1:def 15;
     p2 halts_on s2 by A2,Def2,A4;
     then
A11: Result(p2,s2) = Comput(p2,s2,LifeSpan(p1,s1))
     by A10,EXTPRO_1:23;
   p1 halts_on s1 by A1,Def2,A3;
   then
  Result(p1,s1) = Comput(p1,s1,LifeSpan(p1,s1)) by EXTPRO_1:23;

  hence thesis by A1,A5,A11,Th14,A3,A4;
end;

registration
  cluster keeping_0 InitHalting for Program of SCM+FSA;
  existence
  proof
    take Macro halt SCM+FSA;
    thus thesis;
  end;
end;

registration
  cluster keepInt0_1 InitHalting for Program of SCM+FSA;
  existence
  proof
    take Macro halt SCM+FSA;
    thus thesis;
  end;
end;



theorem Th17:
  for I being keepInt0_1 InitHalting Program of SCM+FSA holds
  IExec(I,p,s).intloc 0 = 1
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
A3:  iS c= Initialized s by FUNCT_4:25;
A4: I c= p+*I by FUNCT_4:25;
  then p+*I halts_on Initialized s by Def2,A3;
  then
A5: iS c= Initialized s &
 ex n st Result(p +* I,Initialized s) =
  Comput(p +* I,Initialized s,n) &
   CurInstr(p+*I,Result(p+*I,Initialized s))
    = halt SCM+FSA by EXTPRO_1:def 9,FUNCT_4:25;
  thus IExec(I,p,s).intloc 0 = (Result(p+*I,Initialized s)).intloc 0
   by SCMFSA6B:def 1
    .= 1 by A5,A4,Def3;
end;

registration
 cluster InitClosed for Program of SCM+FSA;
 existence
  proof
   take the paraclosed Program of SCM+FSA;
   thus thesis;
  end;
end;

theorem Th18:
  for I being InitClosed Program of SCM+FSA, J being Program of
  SCM+FSA st Initialize ((intloc 0) .--> 1) c= s & I c= p &
   p halts_on s
   for m st m <= LifeSpan(p,s) holds
   Comput(p,s,m) =  Comput(p+*(I ';' J),s,m)
proof
  let I be InitClosed Program of SCM+FSA, J be Program of SCM+FSA;
  assume that
A1: iS c= s and
A2: I c= p and
A3: p halts_on s;
  defpred X[Nat] means $1 <= LifeSpan(p,s) implies
    Comput(p,s,$1) =  Comput(p+*(I ';' J),s,$1);
A4: for m st X[m] holds X[m+1]
  proof
    set px = p+*(I ';' J);
    let m;
A5: I ';' J c= px by FUNCT_4:25;
    assume
A6: m <= LifeSpan(p,s) implies
       Comput(p,s,m) =  Comput(p+*(I ';' J),s,m);
    dom(I ';' J) = dom Directed I \/ dom Reloc(J, card I)
    by FUNCT_4:def 1
      .= dom I \/ dom Reloc(J, card I) by FUNCT_4:99;
    then
A7: {} c= Comput(px,s,m) & dom I c= dom(I ';' J) by XBOOLE_1:2,7;
A8: Comput(p,s,m+1) = Following(p,Comput(p,s,m)) by EXTPRO_1:3
      .= Exec(CurInstr(p,Comput(p,s,m)),Comput(p,s,m));
A9: Comput(px,s,m+1) = Following(px,Comput(px,s,m)) by EXTPRO_1:3
      .= Exec(CurInstr(px,Comput(px,s,m)),
      Comput(px,s,m));
A10: IC Comput(p,s,m) in dom I by A1,Def1,A2;
A11:  p/.IC Comput(p,s,m) = p.IC Comput(p,s,m) by PBOOLE:143;
A12: CurInstr(p,Comput(p,s,m))
     = I.IC(Comput(p,s,m)) by A10,A11,A2,GRFUNC_1:2;
    assume
A13: m+1 <= LifeSpan(p,s);
A15:  px/.IC Comput(px,s,m)
 = px.IC Comput(px,s,m) by PBOOLE:143;
    m < LifeSpan(p,s) by A13,NAT_1:13;
    then I.IC(Comput(p,s,m)) <> halt SCM+FSA by A3,A12,EXTPRO_1:def 15;
    then CurInstr(p,Comput(p,s,m))
     = (I ';' J).IC(Comput(p,s,m)) by A10,A12,SCMFSA6A:15
    .= CurInstr(px,Comput(px,s,m)) by A13,A10,A7,A15,A5,A6,GRFUNC_1:2,NAT_1:13;
    hence thesis by A6,A13,A8,A9,NAT_1:13;
  end;
  Comput(p,s,0) = s & Comput(p+*(I ';' J),s,0) = s by EXTPRO_1:2;
  then
A16: X[0];
  thus for m holds X[m] from NAT_1:sch 1(A16,A4);
end;



theorem Th21:
  for I being InitClosed Program of SCM+FSA
   st p+*I halts_on s &
   Directed I c= p &
   Initialize ((intloc 0) .--> 1) c= s
   holds IC Comput(p, s,LifeSpan(p +* I,s) + 1) =  card I
proof
  set A = NAT;
  let I be InitClosed Program of SCM+FSA;
  assume that
A1: p+*I halts_on s and
A3: Directed I c= p and
A4: iS c= s;
  set sISA0 = s +* iS,
      pISA0 = p +* I;
    set s1 = sISA0 +* EP,
        p1 = pISA0 +* (I ';' I);
P2: sISA0 = s by A4,FUNCT_4:98;
   then
P3: s1 = s by FUNCT_4:21;
A5: iS c= sISA0 by A4,FUNCT_4:98;
A6: I c= pISA0 by FUNCT_4:25;
  reconsider sISA0 as State of SCM+FSA;
  set m = LifeSpan(pISA0,sISA0);
  set l1 = IC Comput(pISA0, sISA0,m);
A8: I c= pISA0 by FUNCT_4:25;
A9: l1 in dom I by A5,Def1,A8;
  set s2 = sISA0 +* EP,
      p2 = pISA0 +* Directed I;
A10: Directed I c= p2 by FUNCT_4:25;
 now
    let k be Element of NAT;
    defpred X[Nat] means $1 <= k implies
      Comput(p1, s1,$1) =  Comput(p2, s2,$1);
    assume
A12: k <= m;
A13: for n being Element of NAT st X[n] holds X[n+1]
    proof
      let n be Element of NAT;
      assume
A14:  n <= k implies
       Comput(p1, s1,n) =  Comput(p2,s2,n);
A15:  Comput(p2, s2,n + 1) = Following(p2,Comput(p2,s2,n)) by EXTPRO_1:3
        .= Exec(CurInstr(p2,Comput(p2,s2,n)),
        Comput(p2, s2,n));
A16:  Comput(p1, s1,n + 1) = Following(p1,Comput(p1,s1,n)) by EXTPRO_1:3
        .= Exec(CurInstr(p1,Comput(p1,s1,n)),
        Comput(p1, s1,n));
A17:  n <= n + 1 by NAT_1:12;
      assume
A18:  n + 1 <= k;
A20: I c= p +* I by FUNCT_4:25;
      n <= k by A18,A17,XXREAL_0:2;
      then IC Comput(pISA0, sISA0,n)
       = IC Comput(p1, s1,n) by A1,A4,Th18,A6,P2,P3,A12,XXREAL_0:2;
      then
A21:  IC Comput(p1, s1,n) in dom I by A5,Def1,A20;
      then
A22:  IC Comput(p2, s2,n) in dom Directed I
       by A18,A14,A17,FUNCT_4:99,XXREAL_0:2;
A23:  CurInstr(p2,Comput(p2,s2,n))
         = p2.IC Comput(p2, s2,n) by PBOOLE:143
        .= (Directed I).IC Comput(p2, s2,n) by A22,FUNCT_4:13;
      dom I c= dom (I ';' I) &
      CurInstr(p1, Comput(p1,s1,n)) = p1.IC
      Comput(p1, s1,n) by PBOOLE:143,SCMFSA6A:17;
      then Directed I c= I ';' I &
      CurInstr(p1,Comput(p1,s1,n)) = (I ';' I).IC
      Comput(p1, s1,n) by A21,FUNCT_4:13,SCMFSA6A:16;
      hence thesis by A14,A18,A17,A23,A16,A15,A22,GRFUNC_1:2,XXREAL_0:2;
    end;
    Comput(p1, s1,0) = s1 & Comput(p2, s2,0) = s2 by EXTPRO_1:2;
    then
A24: X[0];
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A24,A13);
    then  Comput(p1,s1,k) =  Comput(p2,s2,k);
    hence  Comput(pISA0, sISA0,k) =  Comput(p2,s2,k)
       by A1,A4,A12,Th18,A6,P2,P3;
  end;
  then
B26:  Comput(pISA0, sISA0,m) =  Comput(p2,s2,m);
A27: I.l1 = pISA0.l1 by A9,A6,GRFUNC_1:2
    .=CurInstr(pISA0,Comput(pISA0,sISA0,m)) by PBOOLE:143
    .= halt SCM+FSA by A1,P2,EXTPRO_1:def 15;
  IC Comput(p2,s2,m) in dom Directed I by A9,B26,FUNCT_4:99;
  then
A28: p2.l1 = (Directed I).l1 by B26,A10,GRFUNC_1:2
    .= goto  card I by A9,A27,FUNCT_4:106;
A29: Comput(p2, s2,m + 1)
     = Following(p2,Comput(p2,s2,m)) by EXTPRO_1:3
    .= Exec(goto  card I,Comput(p2,s2,m)) by B26,A28,PBOOLE:143;
  set m = LifeSpan(pISA0,sISA0);
    dom Directed I = dom I by FUNCT_4:99;
    then
A31: p +* I +* Directed I = p +* Directed I by FUNCT_4:74
     .= p by A3,FUNCT_4:98;
     s2 = sISA0 by FUNCT_4:21
    .= s by A4,FUNCT_4:98;
hence
    IC Comput(p, s,LifeSpan(p +* I,s) + 1)
       = IC Comput(p2, s2,m + 1) by A31,FUNCT_4:21
      .=  card I by A29,SCMFSA_2:69;
end;

theorem Th22:
  for I being InitClosed Program of SCM+FSA
   st p+*I halts_on s & Directed I c= p &
 Initialize ((intloc 0) .--> 1) c= s
 holds DataPart Comput(p, s,LifeSpan(p +* I,s))
  = DataPart Comput(p,s,LifeSpan(p +* I,s) + 1)
proof
  set A = NAT;
  let I be InitClosed Program of SCM+FSA;
  assume that
A1: p+*I halts_on s and
A3: Directed I c= p and
A4: iS c= s;
P1: s = s +*{} by FUNCT_4:21;
  set sISA0 = s +* iS,
      pISA0 = p +* I;
  set s2 = sISA0 +* EP,
      p2 = pISA0 +* Directed I;
A5: iS c= sISA0 by FUNCT_4:25;
A6: I c= p+*I by FUNCT_4:25;
A7: sISA0 = s by A4,FUNCT_4:98;
  reconsider sISA0 as State of SCM+FSA;
  set m = LifeSpan(pISA0,sISA0);
  set l1 = IC Comput(pISA0, sISA0,m);
A8: l1 in dom I by A5,Def1,A6;
  set s2 = sISA0 +* EP,
      p2 = pISA0 +* Directed I;
 now
    set s1 = sISA0 +* EP,
        p1 = pISA0 +* (I ';' I);
    let k be Element of NAT;
    defpred X[Nat] means $1 <= k implies
      Comput(p1, s1,$1) =  Comput(p2, s2,$1);
    assume
A10: k <= m;
A11: for n being Element of NAT st X[n] holds X[n+1]
    proof
A12:  Directed I c= I ';' I by SCMFSA6A:16;
      let n be Element of NAT;
A13:  dom I c= dom (I ';' I) by SCMFSA6A:17;
      assume
A14:  n <= k implies
         Comput(p1, s1,n) =  Comput(p2,s2,n);
A15:  Comput(p2, s2,n + 1) = Following(p2,
Comput(p2,s2,n)) by EXTPRO_1:3
        .= Exec(CurInstr(p2,Comput(p2,s2,n)),
        Comput(p2, s2,n));
A16:  Comput(p1, s1,n + 1) = Following(p1,
Comput(p1,s1,n)) by EXTPRO_1:3
        .= Exec(CurInstr(p1,Comput(p1,s1,n)),
        Comput(p1, s1,n));
A17:  n <= n + 1 by NAT_1:12;
      assume
A18:  n + 1 <= k;
      n <= k by A18,A17,XXREAL_0:2;
      then  Comput(pISA0, sISA0,n) =  Comput(p1, s1,n)
       by A1,A5,Th18,A6,P1,A7,A10,XXREAL_0:2;
      then
A20:  IC Comput(p1, s1,n) in dom I by A5,Def1,A6;
      then
A21:  IC Comput(p2, s2,n) in dom Directed I
        by A18,A14,A17,FUNCT_4:99,XXREAL_0:2;
A22:  CurInstr(p2,Comput(p2,s2,n))
         = p2.IC Comput(p2, s2,n) by PBOOLE:143
        .= (Directed I).IC Comput(p2, s2,n) by A21,FUNCT_4:13;
      CurInstr(p1,Comput(p1,s1,n))
         = p1.IC Comput(p1, s1,n) by PBOOLE:143
        .= (I ';' I).IC Comput(p1, s1,n) by A13,A20,FUNCT_4:13
        .= (Directed I).IC Comput(p1, s1,n)
         by A12,A18,A21,A14,A17,GRFUNC_1:2,XXREAL_0:2;
      hence thesis by A14,A18,A17,A22,A16,A15,XXREAL_0:2;
    end;
    Comput(p1, s1,0) = s1 & Comput(p2, s2,0) = s2 by EXTPRO_1:2;
    then
A23: X[0];
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A23,A11);
    then Comput(p1,s1,k) =  Comput(p2,s2,k);
    hence Comput(pISA0, sISA0,k) =  Comput(p2,s2,k) by A1,A5,A7,A10,Th18,A6,P1;
  end;
  then
B25:  Comput(pISA0, sISA0,m) =  Comput(p2,s2,m);
A26: I.l1 = pISA0.l1 by A8,A6,GRFUNC_1:2
    .=CurInstr(pISA0,Comput(pISA0,sISA0,m)) by PBOOLE:143
    .= halt SCM+FSA by A1,A7,EXTPRO_1:def 15;
  IC Comput(p2,s2,m) in dom Directed I by A8,B25,FUNCT_4:99;
  then
A27: p2.l1 = (Directed I).l1 by B25,FUNCT_4:13
    .= goto  card I by A8,A26,FUNCT_4:106;
  Comput(p2, s2,m + 1)
     = Following(p2,Comput(p2,s2,m)) by EXTPRO_1:3
    .= Exec(goto  card I,Comput(p2,s2,m))
     by B25,A27,PBOOLE:143;
  then
A28: ( for a being Int-Location holds Comput(p2, s2,m + 1).a =
Comput(p2, s2,m). a)& for f being FinSeq-Location holds Comput(
p2, s2,m + 1).f =
  Comput(p2, s2,m).f by SCMFSA_2:69;
    dom Directed I = dom I by FUNCT_4:99;
    then
     p +* I +* Directed I = p +* Directed I by FUNCT_4:74
     .= p by A3,FUNCT_4:98;
  hence thesis by A7,A28,P1,SCMFSA6A:7;
end;

theorem Th23:
  for I being InitHalting Program of SCM+FSA st
    Initialize ((intloc 0) .--> 1) c= s & I c= p
  for k being Element of NAT st k <= LifeSpan(p,s)
   holds CurInstr(p +* Directed I,
    Comput(p +* Directed I, s,k)) <> halt SCM+FSA
proof
  set A = NAT;
  let I be InitHalting Program of SCM+FSA;
  set s2 = s +* EP,
      p2 = p +* Directed I;
  set m = LifeSpan(p,s);
E2: s2 = s by FUNCT_4:21;
  assume
A2: iS c= s;
  assume
A3: I c= p;
   then
A4: p halts_on s by A2,Def2;
A5: now
    set s1 = s +* EP,
        p1 = p +* (I ';' I);
E1: s = s1 by FUNCT_4:21;
    let k be Element of NAT;
    defpred X[Nat] means $1 <= k implies
     Comput(p1, s1,$1) =  Comput(p2, s2,$1);
    assume
A6: k <= m;
A7: for n being Element of NAT st X[n] holds X[n+1]
    proof
A8:   Directed I c= I ';' I by SCMFSA6A:16;
      let n be Element of NAT;
A9:   dom I c= dom (I ';' I) by SCMFSA6A:17;
      assume
A10:   n <= k implies
       Comput(p1, s1,n) =  Comput(p2,s2,n);
A11:   Comput(p2, s2,n + 1) = Following(p2,Comput(p2,s2,n))
 by EXTPRO_1:3
        .= Exec(CurInstr(p2,Comput(p2,s2,n)),Comput(p2, s2,n));
A12:  Comput(p1, s1,n + 1) = Following(p1,Comput(p1,s1,n)) by EXTPRO_1:3
        .= Exec(CurInstr(p1,Comput(p1,s1,n)),Comput(p1, s1,n));
A13:  n <= n + 1 by NAT_1:12;
      assume
A14:  n + 1 <= k;
      n <= k by A14,A13,XXREAL_0:2;
      then Comput(p,s,n) = Comput(p1, s1,n) by A2,A4,Th18,A3,E1,A6,XXREAL_0:2;
      then
A16:  IC Comput(p1, s1,n) in dom I by A2,Def1,A3;
      then
A17:  IC Comput(p2, s2,n) in dom Directed I
          by A14,A10,A13,FUNCT_4:99,XXREAL_0:2;
A18:  CurInstr(p2,Comput(p2,s2,n))
        = p2.IC Comput(p2, s2,n) by PBOOLE:143
        .= (Directed I).IC Comput(p2, s2,n) by A17,FUNCT_4:13;
      CurInstr(p1,Comput(p1,s1,n))
       = p1.IC Comput(p1, s1,n) by PBOOLE:143
        .= (I ';' I).IC Comput(p1, s1,n) by A9,A16,FUNCT_4:13
        .= (Directed I).IC Comput(p1, s1,n)
          by A8,A14,A17,A10,A13,GRFUNC_1:2,XXREAL_0:2;
      hence thesis by A10,A14,A13,A18,A12,A11,XXREAL_0:2;
    end;
    Comput(p1, s1,0) = s1 & Comput(p2, s2,0) = s2 by EXTPRO_1:2;
    then
A19: X[0];
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A19,A7);
    then Comput(p1,s1,k) =  Comput(p2,s2,k);
    hence  Comput(p,s,k) =  Comput(p2,s2,k) by A2,A4,A6,Th18,A3,E1;
  end;
    let k be Element of NAT;
    set lk = IC Comput(p,s,k);
A21: IC Comput(p,s,k) in dom I & dom I = dom Directed I by A2,A3,Def1,
FUNCT_4:99;
    then
A22: (Directed I).lk in rng Directed I by FUNCT_1:def 3;
    assume k <= LifeSpan(p,s);
    then lk = IC Comput(p2,s2,k) by A5;
    then
 A23: CurInstr(p2,Comput(p2,s2,k))
       = p2.lk by PBOOLE:143
      .= (Directed I).lk by A21,FUNCT_4:13;
    assume
    CurInstr(p +* Directed I,
     Comput(p +* Directed I, s,k)) = halt SCM+FSA;
    hence contradiction by A23,A22,E2,SCMFSA6A:1;
end;

theorem Th24:
  for I being InitClosed Program of SCM+FSA
   st p+*I halts_on Initialized s
   for J being Program of SCM+FSA, k being Element of NAT
    st k <= LifeSpan(p +* I,Initialized s )
   holds  Comput(p +* I, (Initialized s),k)
    =  Comput(p +* (I ';' J), (Initialized s),k)
proof
  let I be InitClosed Program of SCM+FSA;
  assume
A1: p+*I halts_on Initialized s;
  set s1 = Initialized s,
      p1 = p +* I;
A2: I c= p1 by FUNCT_4:25;
  let J be Program of SCM+FSA;
  set s2 = Initialized s,
      p2 = p +* (I ';' J);
  defpred X[Nat] means $1 <= LifeSpan(p1,s1)
   implies  Comput(p1, s1,$1) =  Comput(p2,(s2),$1);
A3: for m st X[m] holds X[m+1]
  proof
    dom(I ';' J) = dom Directed I \/ dom Reloc(J, card I)
    by FUNCT_4:def 1
      .= dom I \/ dom Reloc(J, card I) by FUNCT_4:99;
    then
A4: dom I c= dom(I ';' J) by XBOOLE_1:7;
    set sx = s2,
        px = p2;
A5: I ';' J c= p2 by FUNCT_4:25;
    let m;
    assume
A6: m <= LifeSpan(p1,s1) implies
       Comput(p1,s1,m) =  Comput(p2,(s2),m);
    assume
A7: m+1 <= LifeSpan(p1,s1);
A9: Comput(p1,s1,m+1) = Following(p1,Comput(p1,s1,m)) by EXTPRO_1:3
      .= Exec(CurInstr(p1,Comput(p1,s1,m)),
      Comput(p1,s1,m));
A10: Comput(px,sx,m+1) = Following(px,Comput(px,sx,m)) by EXTPRO_1:3
      .= Exec(CurInstr(px,Comput(px,sx,m)),Comput(px,sx,m));
    iS c= s1 by FUNCT_4:25;
    then
A11: IC Comput(p1,s1,m) in dom I by Def1,A2;
A12:  p1/.IC Comput(p1,s1,m) = p1.IC Comput(p1,s1,m) by PBOOLE:143;
A13: CurInstr(p1,Comput(p1,s1,m))
    = I.IC(Comput(p1,s1,m)) by A11,A12,A2,GRFUNC_1:2;
A14:  px/.IC Comput(px,sx,m) = px.IC Comput(px,sx,m) by PBOOLE:143;
    m < LifeSpan(p1,s1) by A7,NAT_1:13;
    then I.IC(Comput(p1,s1,m)) <> halt SCM+FSA by A1,A13,EXTPRO_1:def 15;
    then
    CurInstr(p1,Comput(p1,s1,m))
     = (I ';' J).IC(Comput(p1,s1,m)) by A11,A13,SCMFSA6A:15
    .= CurInstr(px,Comput(px,sx,m)) by A14,A7,A11,A4,A5,A6,GRFUNC_1:2,NAT_1:13;
    hence thesis by A6,A7,A9,A10,NAT_1:13;
  end;
     Comput(p1, s1,0) = s1 & Comput(p2,(s2),0) = s2 by EXTPRO_1:2;
   then
A18: X[0];
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A18, A3 );
end;

theorem Th25:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA, s being State of SCM+FSA st
 Initialize ((intloc 0) .--> 1) c= s & I ';' J c= p
  holds IC Comput(p, s,LifeSpan(p +* I,s) + 1) =  card I &
   DataPart Comput(p, s,LifeSpan(p +* I,s) + 1) =
    DataPart(Comput(p +* I, s,LifeSpan(p +* I,s))
       +* Initialize ((intloc 0) .--> 1)) &
  Reloc(J,card I) c= p &
  Comput(p, s,LifeSpan(p +* I,s) + 1).intloc 0 = 1 & p halts_on s &
   LifeSpan(p,s) = LifeSpan(p +* I,s) + 1 +
 LifeSpan(p +* I +* J,
Result(p +* I,s) +*Initialize ((intloc 0) .--> 1)) & (J is keeping_0 implies
(Result(p,s)).intloc 0 = 1)
proof
  set D = Data-Locations SCM+FSA;
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s1 = s +* EP,
      p1 = p +* I;
  set s3 = Comput(p1, s,LifeSpan(p1,s)) +* iS,
      p3 = p1 +* J;
  set m1 = LifeSpan(p1,s);
  set m3 = LifeSpan(p3,s3);
A2: J c= p3 by FUNCT_4:25;
  assume
A3: iS c= s;
  then
A4: s = Initialized s by FUNCT_4:98;
  assume
A5: I ';' J c= p;
  then
A6: p +*(I ';' J) = p by FUNCT_4:98;
A7: I c= p1 by FUNCT_4:25;
  set s4 = Comput(p, s,m1 + 1),
      p4 = p;
B9: Directed I c= I ';' J by SCMFSA6A:16;
   then
A9: Directed I c= p by A5,XBOOLE_1:1;
A10: p = p +* Directed I by A5,B9,FUNCT_4:98,XBOOLE_1:1;
  reconsider m = m1 + 1 + m3 as Element of NAT;
A11: dom Directed I = dom I by FUNCT_4:99;
A14: p1 +* Directed I = p +* (I +* Directed I) by FUNCT_4:14
    .= p by A10,A11,FUNCT_4:19;
A15: iS c= s3 by FUNCT_4:25;
  then dom iS c= dom s3 by GRFUNC_1:2;
  then
A16: dom iS c= the carrier of SCM+FSA by PARTFUN1:def 2;
A17: Reloc(J,card I) c= I ';' J by FUNCT_4:25;
JJ:  I c= p+*I by FUNCT_4:25;
  then
A20: p+*I halts_on s by Def2,A3;
  hence
A21: IC Comput(p, s,LifeSpan(p +* I,s) + 1) = card I by A3,Th21,A9;
A22: now
    let x be set;
    assume x in dom DataPart iS;
    then
A23: x in dom (iS) /\ D by RELAT_1:61;
    then
     x in dom iS by XBOOLE_0:def 4;
    then
B24: x in {IC SCM+FSA,intloc 0} by diS,ENUMSET1:1;
A25: x in D by A23,XBOOLE_0:def 4;
    per cases by B24,TARSKI:def 2;
    suppose
A27:  x = intloc 0;
      thus (DataPart iS).x
             = 1 by A27,A25,FUNCT_1:49,SCMFSA6A:43
        .= Comput(p1,s,m1).x by A27,Def3,A7,A3
        .= (DataPart Comput(p1,s,m1)).x by A25,FUNCT_1:49;
    end;
    suppose
      x = IC SCM+FSA;
      then not x in Data-Locations SCM+FSA by STRUCT_0:3;
      hence
      (DataPart iS).x = (DataPart Comput(p1,s,m1)).x by A23,XBOOLE_0:def 4;
    end;
  end;
A29: p3 halts_on s3 by Def2,A2,A15;
  dom (DataPart iS) = dom iS /\ D by RELAT_1:61;
  then dom (DataPart iS) c= (the carrier of SCM+FSA) /\ D by A16,XBOOLE_1:26;
  then dom (DataPart iS) c= dom Comput(p1,s,m1) /\ D by PARTFUN1:def 2;
  then
BB: dom (DataPart iS) c= dom DataPart Comput(p1,s,m1) by RELAT_1:61;
AA:  DataPart s3 = DataPart Comput(p1,s,m1) +* DataPart iS by FUNCT_4:71;
CC: DataPart iS c= DataPart Comput(p1,s,m1) by A22,BB,GRFUNC_1:2;
A30: DataPart Comput(p1,s,m1) = DataPart s3 by CC,AA,FUNCT_4:98;
KK: p+*I halts_on s by A3,Def2,JJ;
  DataPart Comput(p,s,m1) = DataPart s3 by A30,A4,A20,Th24,A6;
  hence
A31: DataPart Comput(p, s,m1 + 1) = DataPart s3 by A3,Th22,A9,KK;
  thus Reloc(J,card I) c= p by A5,A17,XBOOLE_1:1;
A33: Reloc(J,card I) c= p4 by A17,A5,XBOOLE_1:1;
  intloc 0 in Int-Locations by SCMFSA_2:2;
  then
A35: intloc 0 in D by SCMFSA_2:100,XBOOLE_0:def 3;
  hence s4.intloc 0 = (DataPart s3).intloc 0 by A31,FUNCT_1:49
    .= s3.intloc 0 by A35,FUNCT_1:49
    .= 1 by FUNCT_4:13,SCMFSA6A:41,43;
A36: Comput(p,s,m1 + 1 + m3) = Comput(p,Comput(p,s,m1 + 1),m3) by EXTPRO_1:4;
A37: iS c= s3 by FUNCT_4:25;
  then IncAddr(CurInstr(p3,Comput(p3,s3,m3)),card I)
   = CurInstr(p,Comput(p, s,m1 + 1 + m3))
    by A36,A21,A31,Th12,A2,A33;
  then
A38: CurInstr(p,Comput(p,s,m))
     = IncAddr (halt SCM+FSA,card I) by A29,EXTPRO_1:def 15
    .= halt SCM+FSA by COMPOS_1:11;
  hence
A39: p halts_on s by EXTPRO_1:29;
A40: now
    let k be Element of NAT;
    assume m1 + 1 + k < m;
    then
A41: k < m3 by XREAL_1:6;
    assume
A42: CurInstr(p,
       Comput(p, s,m1 + 1 + k)) = halt SCM+FSA;
    IncAddr(CurInstr(p3,Comput(p3,s3,k)),card I)
     = CurInstr(p4,Comput(p,s4,k))
      by A21,A31,A37,Th12,A2,A33
      .= halt SCM+FSA by A42,EXTPRO_1:4;
    then InsCode CurInstr(p3,Comput(p3,s3,k)) = 0
     by COMPOS_1:def 17,SCMFSA_2:97;
    then CurInstr(p3,Comput(p3,s3,k))
     = halt SCM+FSA by SCMFSA_2:95;
    hence contradiction by A29,A41,EXTPRO_1:def 15;
  end;
  now
    let k be Element of NAT;
    assume
A43: k < m;
    per cases;
    suppose k <= m1;
      hence CurInstr(p,Comput(p,s,k)) <> halt SCM+FSA
       by Th23,A14,A3,FUNCT_4:25;
    end;
    suppose
      m1 < k;
      then m1 + 1 <= k by NAT_1:13;
      then consider kk being Nat such that
A44:  m1 + 1 + kk = k by NAT_1:10;
      reconsider kk as Element of NAT by ORDINAL1:def 12;
      m1+1+kk=k by A44;
      hence CurInstr(p,Comput(p,s,k))
       <> halt SCM+FSA by A40,A43;
    end;
  end;
  then
A45: for k being Element of NAT st CurInstr(p,Comput(p,s,k))
   = halt SCM+FSA
  holds m <= k;
  then
A46: LifeSpan(p,s) = m by A38,A39,EXTPRO_1:def 15;
  I c= p+*I by FUNCT_4:25;
  then
A49:  p1 halts_on s by Def2,A3;
   Comput(p1, s,LifeSpan(p1,s))
     = Result(p +* I,s) by A49,EXTPRO_1:23;
  hence LifeSpan(p,s) = LifeSpan(p +* I,s) + 1 +
    LifeSpan(p +* I +* J,Result(p +* I,s) +* iS)
     by A45,A38,A39,EXTPRO_1:def 15;
A50: iS c= s3 by FUNCT_4:25;
A51: DataPart Comput(p3, s3,m3)
 = DataPart Comput(p4, s4,m3) by A21,A31,A37,Th12,A2,A33;
    assume
A52: J is keeping_0;
    thus (Result(p,s)).intloc 0 = Comput(p,s,m).intloc 0 by A39,A46,EXTPRO_1:23
      .= Comput(p, s4,m3).intloc 0 by EXTPRO_1:4
      .= Comput(p3, s3,m3).intloc 0 by A51,SCMFSA6A:7
      .= s3.intloc 0 by A52,A2,SCMFSA6B:def 4
      .= 1 by A50,GRFUNC_1:2,SCMFSA6A:41,43;
end;

registration
  let I be keepInt0_1 InitHalting Program of SCM+FSA, J be InitHalting Program
  of SCM+FSA;
  cluster I ';' J -> InitHalting;
  coherence
  proof
    set D = Data-Locations SCM+FSA;
    let s be State of SCM+FSA;
    assume
A1: iS c= s;
    then
A2: s = Initialized s by FUNCT_4:98;
    let p;
    assume
A3: I ';' J c= p;
A4: p = p +* (I ';' J) by A3,FUNCT_4:98;
    set p1 = p +* I;
    set s3 = Comput(p1, s,LifeSpan(p1,s)) +* iS,
        p3 = p1 +* J;
A7: J c= p3 by FUNCT_4:25;
    set m1 = LifeSpan(p1,s);
    set s4 = Comput(p, s,m1 + 1);
A8: I c= p1 by FUNCT_4:25;
A9: Reloc(J,card I) c= I ';' J by FUNCT_4:25;
    set m3 = LifeSpan(p3,s3);
A11: dom DataPart iS = dom iS /\ D by RELAT_1:61;
    reconsider m = m1 + 1 + m3 as Element of NAT;
A17:  iS c= Initialized s by FUNCT_4:25;
  I c= p+*I by FUNCT_4:25;
  then
A18: p+*I halts_on Initialized s by Def2,A17;
A19: now
      let x be set;
       DataPart iS c= iS by RELAT_1:59;
       then
AA:    dom DataPart iS c= dom iS by RELAT_1:11;
      assume
ZZ:       x in dom DataPart iS;
       then x in dom iS by AA;
       then
pc:     x in {intloc 0, IC SCM+FSA } by diS,ENUMSET1:1;
      per cases by pc,TARSKI:def 2;
      suppose
A24:    x=intloc 0;
        then x in Int-Locations by SCMFSA_2:2;
        then
A25:    x in D by SCMFSA_2:100,XBOOLE_0:def 3;
        hence (DataPart Comput(p1,s,m1)).x
           = Comput(p1,s,m1).x by FUNCT_1:49
          .= 1 by A1,A24,Def3,A8
          .=(DataPart iS).x by A25,A24,FUNCT_1:49,SCMFSA6A:43;
      end;
      suppose
S:       x = IC SCM+FSA;
         dom DataPart iS c= Data-Locations SCM+FSA by RELAT_1:58;
        hence (DataPart iS).x = (DataPart Comput(p1,s,m1)).x
              by S,ZZ,STRUCT_0:3;
      end;
    end;
    take m;
     IC Comput(p,s,m) in NAT;
    hence IC Comput(p,s,m) in dom p by PARTFUN1:def 2;
     Directed I c= I ';' J by SCMFSA6A:16;
     then
A27: Directed I c= p by A3,XBOOLE_1:1;
    iS c= s3 by FUNCT_4:25;
    then dom iS c= dom s3 by GRFUNC_1:2;
    then dom iS c= the carrier of SCM+FSA by PARTFUN1:def 2;
    then dom DataPart iS c= (the carrier of SCM+FSA) /\ D by A11,XBOOLE_1:26;
    then dom DataPart iS c= dom Comput(p1,s,m1) /\ D by PARTFUN1:def 2;
    then dom DataPart iS c= dom (DataPart Comput(p1,s,m1)) by RELAT_1:61;
    then DataPart iS c= DataPart Comput(p1,s,m1) by A19,GRFUNC_1:2;
    then
A30:   DataPart Comput(p1,s,m1)
           = DataPart Comput(p1, s,LifeSpan(p1,s)) +* DataPart iS
                   by FUNCT_4:98
          .= DataPart s3 by FUNCT_4:71;
A31:   DataPart Comput(p,s,m1) = DataPart s3 by A30,A2,A4,A18,Th24;
  I c= p+*I by FUNCT_4:25;
  then
YY:  p +* I halts_on s by A1,Def2;
    then
A33: DataPart Comput(p, s,m1 + 1) = DataPart s3 by A1,Th22,A31,A27;
A35: Comput(p,s,m1 + 1 + m3) = Comput(p,Comput(p,s,m1 + 1),m3) by EXTPRO_1:4;
A36: Reloc(J,card I) c= p by A9,A3,XBOOLE_1:1;
X:  iS c= s3 by FUNCT_4:25;
x:  IC Comput(p, s,LifeSpan(p +* I,s) + 1) =  card I by YY,A27,Th21,A1;
A37: IncAddr(CurInstr(p3,Comput(p3,s3,m3)),card I)
          = CurInstr(p,Comput(p,s,m1 + 1 + m3)) by A35,X,A7,A36,Th12,x,A33;
    p3 halts_on s3 by A7,Def2,X;
    then CurInstr(p,Comput(p,s,m))
     = IncAddr (halt SCM+FSA,card I) by A37,EXTPRO_1:def 15
      .= halt SCM+FSA by COMPOS_1:11;
    hence thesis;
  end;
end;

theorem Th26:
  for I being keepInt0_1 Program of SCM+FSA st p+*I halts_on s
  for J being InitClosed Program of SCM+FSA st
   Initialize ((intloc 0) .--> 1) c= s & I ';' J c= p
for k being Element of NAT holds (Comput(p +* I +* J,
(Result(p +* I,s) +* Initialize ((intloc 0) .--> 1)),k) +*
  Start-At (IC Comput(p +* I +* J, (
  Result(p +* I,s) +* Initialize ((intloc 0) .--> 1)),k) + card I,SCM+FSA))
  =  Comput(p +* (I ';' J), s,LifeSpan(p +* I,s)+1+k)
proof
  let I be keepInt0_1 Program of SCM+FSA;
  assume
A1: p+*I halts_on s;
  let J be InitClosed Program of SCM+FSA;
  set sISA0 = s +* iS,
      pISA0 = p +* I;
A2: I c= pISA0 by FUNCT_4:25;
A3: iS c= sISA0 by FUNCT_4:25;
  set RI = Result(p +* I,s +* iS),
      pRI = p +* I;
  set RIJ = RI +* iS,
      pRIJ = pRI +* J;
  set sIJSA0 = Initialized s,
      pIJSA0 = p +* (I ';' J);
  defpred X[Nat] means (Comput(pRIJ, RIJ,$1) +* Start-At (IC
   Comput(pRIJ, RIJ,$1) + card I,SCM+FSA))
   =  Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,sISA0)+1+$1);
  assume
B4:   iS c= s;
  then
A4: s = sIJSA0 by FUNCT_4:98;
  assume
A5: I ';' J c= p;
   then
A6: pIJSA0 = p by FUNCT_4:98;
A10: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT;
    set k1 = k+1;
    set CRk = Comput(pRIJ, RIJ,k);
    set CRSk = IncIC(CRk,card I);
    set CIJk = Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,sISA0)+1+k);
    set CRk1 = Comput(pRIJ, RIJ,k1);
    set CRSk1 = CRk1 +* Start-At (IC CRk1 + card I,SCM+FSA);
    set CIJk1 = Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,sISA0)+1+k1);
    assume
A11: (Comput(pRIJ, RIJ,k)
      +* Start-At (IC Comput(pRIJ,RIJ,k) + card I,SCM+FSA))
    =  Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,sISA0)+1+k);
A12: IncAddr(CurInstr(pRIJ,CRk), card I) = CurInstr(pIJSA0,CIJk)
    proof
A13:   J c= pRIJ by FUNCT_4:25;
A14:   iS c= RIJ by FUNCT_4:25;
A15:    Reloc(J, card I) c= I ';' J by FUNCT_4:25;
     I ';' J c= pIJSA0 by FUNCT_4:25;
     then
A16: Reloc(J, card I) c= pIJSA0 by A15,XBOOLE_1:1;
A17:  pIJSA0/.IC CIJk = pIJSA0.IC CIJk by PBOOLE:143;
A18:  CurInstr(pIJSA0,CIJk) = pIJSA0.(IC CRk + card I) by A11,A17,FUNCT_4:113;
      reconsider ii = IC CRk as Element of NAT;
A19:  Reloc(J, card I) = Shift(IncAddr(J, card I), card I) by COMPOS_1:34;
A20:  IC CRk in dom J by Def1,A13,A14;
      then
A21:  ii in dom IncAddr(J, card I) by COMPOS_1:def 19;
      then
A22:  Shift(IncAddr(J, card I), card I).(IC CRk + card I) = IncAddr(J,
      card I).ii by VALUED_1:def 12
        .= IncAddr(J/.ii, card I) by A20,COMPOS_1:def 19;
      dom Shift(IncAddr(J, card I), card I) = { il+card I where il is
      Element of NAT: il in dom IncAddr(J, card I)} by VALUED_1:def 12;
      then
A23:  IC CRk + card I in dom Shift(IncAddr(J, card I), card I) by A21;
A24:   J/.ii = J.IC CRk by A20,PARTFUN1:def 6
        .= pRIJ.IC CRk by A20,A13,GRFUNC_1:2;
       CurInstr(pRIJ,CRk) = pRIJ.IC CRk by PBOOLE:143;
      hence
      IncAddr(CurInstr(pRIJ,CRk), card I)
        = CurInstr(pIJSA0,CIJk) by A18,A22,A19,A23,A24,A16,GRFUNC_1:2;
    end;
B25:  Exec(CurInstr(pIJSA0,CIJk), CIJk)
     =  Exec(IncAddr(CurInstr(pRIJ,CRk),card I), CRSk) by A11,A12;
    then
A25:  Exec(CurInstr(pIJSA0,CIJk), CIJk)
     =  IncIC(Following(pRIJ,CRk),card I)
         by AMISTD_5:4;
    CIJk1 = Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,
sISA0)+1+k+1);
    then
A26: CIJk1 = Following(pIJSA0,CIJk) by EXTPRO_1:3;
A27: now
      let a be Int-Location;
      thus CRSk1.a = CRk1.a by SCMFSA_3:3
        .= (Following(pRIJ,CRk)).a by EXTPRO_1:3
        .= CIJk1.a by A26,A25,SCMFSA_3:3;
    end;
A28: now
      let f be FinSeq-Location;
      thus CRSk1.f = CRk1.f by SCMFSA_3:4
        .= (Following(pRIJ,CRk)).f by EXTPRO_1:3
        .= IncIC(Following(pRIJ,CRk),card I).f by SCMFSA_3:4
        .= CIJk1.f by A26,B25,AMISTD_5:4;
    end;
    IC CRSk1 = IC CRk1 + card I by FUNCT_4:113
      .= IC Following(pRIJ,CRk) + card I by EXTPRO_1:3;
    then
    IC CRSk1 =
     IC IncIC(Following(pRIJ,CRk),card I) by FUNCT_4:113
      .= IC CIJk1 by A26,B25,AMISTD_5:4;
    hence thesis by A27,A28,SCMFSA_2:61;
  end;
A31: sISA0 = s by B4,FUNCT_4:98;
A32:  Directed I c= I ';' J by SCMFSA6A:16;
A34: Directed I c= p by A32,A5,XBOOLE_1:1;
A35: now
    set s2 = Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,sISA0)+1+0);
    set s1 = IncIC(RIJ,card I);
    reconsider RIJ1 = RI +* ((intloc 0 .--> 1)) as State of SCM+FSA;
A37: RIJ = Initialize RIJ1 by FUNCT_4:14;
    thus IC s1 = IC RIJ + card I by FUNCT_4:113
      .=  0 + card I by A37,FUNCT_4:113
      .= IC s2 by A1,A31,Th21,A34,A6,FUNCT_4:25;
A38: DataPart Comput(p,s,LifeSpan(pISA0,sISA0)) =
DataPart Comput(p, s,
    LifeSpan(pISA0,sISA0)+1) by A1,A4,Th22,A34,FUNCT_4:25;
    hereby
      let a be Int-Location;
      not a in dom Start-At (IC RIJ + card I,SCM+FSA) by SCMFSA_2:102;
      then
A39:  s1.a = RIJ.a by FUNCT_4:11;
A40:  Comput(pISA0, sISA0,LifeSpan(pISA0,sISA0)).a =
       Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,sISA0)).a by A1,A31,Th24
        .= s2.a by A4,A38,A6,SCMFSA6A:7;
      per cases;
      suppose
S:     a <> intloc 0;
       a <> IC SCM+FSA by SCMFSA_2:56;
        then not a in dom iS by S,SCMFSA6A:42,TARSKI:def 2;
        hence s1.a = RI.a by A39,FUNCT_4:11
          .= s2.a by A1,A31,A40,EXTPRO_1:23;
      end;
      suppose
A41:    a = intloc 0;
        then a in dom iS by SCMFSA6A:42,TARSKI:def 2;
        hence s1.a
          = 1 by A41,A39,FUNCT_4:13,SCMFSA6A:43
          .=s2.a by A40,A41,Def3,A2,A3;
      end;
    end;
    let f be FinSeq-Location;
     f <> intloc 0 & f <> IC SCM+FSA by SCMFSA_2:57,58;
     then
A42: not f in dom iS by SCMFSA6A:42,TARSKI:def 2;
    not f in dom Start-At (IC RIJ + card I,SCM+FSA) by SCMFSA_2:103;
    hence s1.f = RIJ.f by FUNCT_4:11
      .= RI.f by A42,FUNCT_4:11
      .= Comput(pISA0, sISA0,LifeSpan(pISA0,sISA0)).f by A1,A31,EXTPRO_1:23
      .= Comput(pIJSA0, sIJSA0,LifeSpan(pISA0,sISA0)).f by A1,A31,Th24
      .= s2.f by A4,A38,A6,SCMFSA6A:7;
  end;
  Comput(pRIJ, RIJ,0) = RIJ by EXTPRO_1:2;
  then
A43: X[0] by A35,SCMFSA_2:61;
  for k being Element of NAT holds X[k] from NAT_1:sch 1(A43, A10);
  hence thesis by A31;
end;

theorem Th27:
  for I being keepInt0_1 Program of SCM+FSA
   st not p+*I halts_on Initialized s
 for J being Program of SCM+FSA, k being Element of NAT
  holds  Comput(p +* I, Initialized s,k)
   =  Comput(p +* (I ';' J), Initialized s,k)
proof
  let I be keepInt0_1 Program of SCM+FSA;
  assume
A1: not p+*I halts_on Initialized s;
  set s1 = Initialized s,
      p1 = p +* I;
A2: I c= p1 by FUNCT_4:25;
A3: iS c= s1 by FUNCT_4:25;
  let J be Program of SCM+FSA;
  set s2 = Initialized s,
      p2 = p +* (I ';' J);
A4: I ';' J c= p2 by FUNCT_4:25;
  defpred X[Nat] means  Comput(p1, s1,$1) =  Comput(p2,s2,$1);
A5: for m st X[m] holds X[m+1]
  proof
    dom(I ';' J) = dom Directed I \/ dom Reloc(J, card I)
    by FUNCT_4:def 1
      .= dom I \/ dom Reloc(J, card I) by FUNCT_4:99;
    then
A6: dom I c= dom(I ';' J) by XBOOLE_1:7;
    set sx = s2,
        px = p2;
    let m;
A7: Comput(p1,s1,m+1) = Following(p1,
Comput(p1,s1,m)) by EXTPRO_1:3
      .= Exec(CurInstr(p1,Comput(p1,s1,m)),
      Comput(p1,s1,m));
A8: Comput(px,sx,m+1) = Following(px,
Comput(px,sx,m)) by EXTPRO_1:3
      .= Exec(CurInstr(px,Comput(px,sx,m)),
      Comput(px,sx,m));
    assume
A9:  Comput(p1,s1,m) =  Comput(p2,(s2),m);
A11: IC Comput(p1,s1,m) in dom I by Def1,A2,A3;
A12:  p1/.IC Comput(p1,s1,m) = p1.IC Comput(p1,s1,m) by PBOOLE:143;
A13:  px/.IC Comput(px,sx,m) = px.IC Comput(px,sx,m) by PBOOLE:143;
A14: CurInstr(p1,Comput(p1,s1,m))
 = I.IC(Comput(p1,s1,m)) by A11,A12,A2,GRFUNC_1:2;
    then I.IC(Comput(p1,s1,m)) <> halt SCM+FSA by A1,EXTPRO_1:29;
    then
    CurInstr(p1,Comput(p1,s1,m))
     = (I ';' J).IC(Comput(p1,s1,m)) by A11,A14,SCMFSA6A:15
      .= CurInstr(px,Comput(px,sx,m))
      by A9,A11,A6,A13,A4,GRFUNC_1:2;
    hence thesis by A9,A7,A8;
  end;
A15: Comput(p1, s1,0) = s1 & Comput(p2,(s2),0) =
s2 by EXTPRO_1:2;
A18: X[0] by A15;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A18, A5 );
end;

theorem Th28:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
  InitHalting Program of SCM+FSA holds
   LifeSpan(p +* (I ';' J),Initialized s)
     = LifeSpan(p+*I,Initialized s) + 1 +
       LifeSpan(p +* I +* J,
           Result(p+*I,Initialized s)
            +*Initialize ((intloc 0) .--> 1))
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  set inI=iS;
  set inIJ=iS;
  set inJ=iS;
A1: inJ c= Result(p+* (I ';' J)+*I,s +* inIJ) +* inJ & inJ c=
Result(p +* I,s +* inI) +* inJ
  by FUNCT_4:25;
A2: J c= p +* (I ';' J) +* I +* J & J c= p +* I +* J by FUNCT_4:25;
A4: inI c= s +* inI & inI c= s +* inIJ by FUNCT_4:25;
A5: I c= p +* I & I c= p +* (I ';' J) +* I by FUNCT_4:25;
  then
A6: (Result(p+* (I ';' J)+*I,s +* inIJ) +* inJ) = (Result(
p +* I,s +* inI) +* inJ) by Th15,A4;
A7:  I ';' J c= p +* (I ';' J) by FUNCT_4:25;
  inIJ c= s +* inIJ by FUNCT_4:25;
  then
A8: LifeSpan(p +* (I ';' J),s +* inIJ)
    = LifeSpan(p+* (I ';' J)+*I,s +* inIJ) + 1 +
    LifeSpan(p+* (I ';' J)+*I+*J,
    Result(p+* (I ';' J)+*I,s +* inIJ) +* inJ) by Th25,A7;
  LifeSpan(p +* I,s +* inI) = LifeSpan(p+* (I ';' J)+*I,
  s +* inIJ) by A4,Th15,A5;
  hence thesis by A8,A1,A6,Th15,A2;
end;

theorem Th29:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds
 IExec(I ';' J,p,s) = IncIC(IExec(J,p,IExec(I,p,s)),card I)
proof
  set D = (Data-Locations SCM+FSA);
  set A = NAT;
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  set s1 = Initialized s, p1 = p +* I;
A1: I c= p1 by FUNCT_4:25;
  set p2 = p +* (I ';' J);
A2: I ';' J c= p2 by FUNCT_4:25;
  set s3 = Initialized Comput(p1, s1,LifeSpan(p1,s1)), p3 = p1 +* J;
A3: iS c= s3 by FUNCT_4:25;
A4: J c= p3 by FUNCT_4:25;
  set m1 = LifeSpan(p1,s1);
  set m3 = LifeSpan(p3,s3);
A5: iS c= s1 by FUNCT_4:25;
A6: I ';' J c= p2 by FUNCT_4:25;
A9:  iS c= Initialized s by FUNCT_4:25;
  I c= p+*I by FUNCT_4:25;
  then
A10: p1 halts_on s1 by Def2,A9;
A11: iS c= s3 by FUNCT_4:25;
A14: IExec(I,p,s) = Result(p1,s1) & iS c= Result(p1,s1) +* iS
 by FUNCT_4:25,SCMFSA6B:def 1;
A17: J c= p +* J by FUNCT_4:25;
A18: iS c= Initialized IExec(I,p,s) &
   iS c= s3 by FUNCT_4:25;
A19: J c= p +* J & J c= p3 by FUNCT_4:25;
A20: iS c= s3 by FUNCT_4:25;
A21: iS c= s1 by FUNCT_4:25;
A22: I c= p1 by FUNCT_4:25;
     p1 halts_on s1 by A21,Def2,A22;
   then
A23: s3 = Initialized Result(p1,s1) by EXTPRO_1:23;
A24: IC Result(p1 +* J,Initialized Result(p1,s1))
        = IC Result(p +* J,Initialized IExec(I,p,s)) by A14,Th15,A17,A4;
A25: iS c= s1 by FUNCT_4:25;
A26: I c= p2 +* I by FUNCT_4:25;
A27: LifeSpan(p2 +* I,s1) = m1 by A25,Th15,A22,A26;
     Reloc(J,card I) c= I ';' J by FUNCT_4:25;
     then
A29: Reloc(J,card I) c= p2 by A2,XBOOLE_1:1;
A34: iS c= s1 by FUNCT_4:25;
A35: p2 +* I +* (I ';' J) = p2 +* (I +* (I ';' J)) by FUNCT_4:14
        .= p2 +* (I ';' J) by SCMFSA6A:18
        .= p2 by FUNCT_4:93
        .= p+*(I +* (I ';' J)) by SCMFSA6A:18
        .= p1+*(I ';' J) by FUNCT_4:14;
  I c= p2+*I by FUNCT_4:25;
  then p2 +* I halts_on s1 by Def2,A34;
  then DataPart Comput(p2 +* I, s1,m1)
    = DataPart Comput(p2 +* I +* (I ';' J), s1,m1) by A25,A27,Th18,A26
    .= DataPart Comput(p1,s1,m1) by A21,A10,Th18,A1,A35;
  then
A37: DataPart(Comput(p2 +* I, s1,m1) +*iS) =
DataPart
  Comput(p1,s1,m1) +* DataPart iS by FUNCT_4:71
    .= DataPart(Comput(p1,s1,m1) +*iS) by FUNCT_4:71;
A38: IC Comput(p2,s1,m1+1) =  card I &
    DataPart Comput(p2,s1,m1+1)
  = DataPart(Comput(p2 +* I, s1,m1) +*iS)
by A5,A27,Th25,A6;
  then
A39: DataPart Comput(p2, Comput(p2,s1,m1+1),m3)
 = DataPart Comput(p3,s3, m3) by A11,A37,Th12,A4,A29;
A40: IC Comput(p2, Comput(p2,s1,m1+1),m3) = IC Comput(p3,s3,m3) + card I
      by A38,A11,A37,Th12,A4,A29;
A41:  iS c= s1 by FUNCT_4:25;
  (I ';' J) c= p+*(I ';' J) by FUNCT_4:25;
  then
A42: p2 halts_on s1 by Def2,A41;
A43: IExec(I ';' J,p,s) = Result(p +* (I ';' J),Initialized s)
 by SCMFSA6B:def 1
    .= Comput(p2,s1,LifeSpan(p2,s1)) by A42,EXTPRO_1:23
    .= Comput(p2,s1,m1+1+m3) by A23,Th28;
B43: p1 halts_on s1 by A21,Def2,A1;
  IExec(I,p,s) = Result(p+*I,Initialized s) by SCMFSA6B:def 1
    .= Comput(p1,s1,m1) by B43,EXTPRO_1:23;
  then
A44: Result(p+*J,IExec(I,p,s) +* iS) = Result(p3,s3) by A18,Th15,A19;

A45: p3 halts_on s3 by Def2,A3,A4;
A46: IExec(J,p,IExec(I,p,s)) = Result(p+*J,Initialized IExec(I,p,s))
           by SCMFSA6B:def 1
    .= Comput(p3,s3,m3) by A44,A45,EXTPRO_1:23;
A48: DataPart IExec(I ';' J,p,s)
     = DataPart IExec(J,p,IExec(I,p,s)) by A46,A39,A43,EXTPRO_1:4;
F2: p3 halts_on s3 by A20,Def2,A4;
F1: p2 halts_on s1 by A5,Def2,A2;
    p1 halts_on s1 by A21,Def2,A1;
    then
A49: s3 = Initialized Result(p1,s1) by EXTPRO_1:23;
A50: IC IExec(I ';' J,p,s)
     = IC Result(p+*(I ';' J),Initialized s) by SCMFSA6B:def 1
    .= IC Comput(p2,s1,LifeSpan(p2,s1)) by F1,EXTPRO_1:23
    .= IC Comput(p2,s1,m1+1+m3) by A23,Th28
    .= IC Comput(p3,s3,m3) + card I by A40,EXTPRO_1:4
    .= IC Result(p3,s3) + card I by F2,EXTPRO_1:23
    .= IC IExec(J,p,IExec(I,p,s)) + card I by A24,A49,SCMFSA6B:def 1;
  hereby
    reconsider l = IC IExec(J,p,IExec(I,p,s)) + card I as Element of NAT;
A51: dom Start-At(l,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:13;
A52: now
      let x be set;
      assume
A53:  x in dom IExec(I ';' J,p,s);
      per cases by A53,SCMFSA6A:5;
      suppose
A54:    x is Int-Location;
        then x <> IC SCM+FSA by SCMFSA_2:56;
        then
A55:    not x in dom Start-At(l,SCM+FSA) by A51,TARSKI:def 1;
        IExec(I ';' J,p,s).x = IExec(J,p,IExec(I,p,s)).x
          by A48,A54,SCMFSA6A:7;
        hence
        IExec(I ';' J,p,s).x
         = IncIC(IExec(J,p,IExec(I,p,s)),card I).x by A55,FUNCT_4:11;
      end;
      suppose
A56:    x is FinSeq-Location;
        then x <> IC SCM+FSA by SCMFSA_2:57;
        then
A57:    not x in dom Start-At(l,SCM+FSA) by A51,TARSKI:def 1;
        IExec(I ';' J,p,s).x = IExec(J,p,IExec(I,p,s)).x
         by A48,A56,SCMFSA6A:7;
        hence
        IExec(I ';' J,p,s).x = IncIC(IExec(J,p,IExec(I,p,s)),card I).x
         by A57,FUNCT_4:11;
      end;
      suppose
A58:    x = IC SCM+FSA;
        then x in {IC SCM+FSA} by TARSKI:def 1;
        then
A59:    x in dom Start-At(l,SCM+FSA) by FUNCOP_1:13;
        thus IExec(I ';' J,p,s).x = (Start-At(l,SCM+FSA)).IC SCM+FSA
         by A50,A58,FUNCOP_1:72
          .= IncIC(IExec(J,p,IExec(I,p,s)),card I).x by A58,A59,FUNCT_4:13;
      end;
    end;
    dom IExec(I ';' J,p,s) = the carrier of SCM+FSA by PARTFUN1:def 2
      .= dom IncIC(IExec(J,p,IExec(I,p,s)),card I) by PARTFUN1:def 2;
    hence thesis by A52,FUNCT_1:2;
  end;
end;

registration
  let i be parahalting Instruction of SCM+FSA;
  cluster Macro i -> InitHalting;
  coherence;
end;

registration
  let i be parahalting Instruction of SCM+FSA, J be parahalting Program of
  SCM+FSA;
  cluster i ';' J -> InitHalting;
  coherence;
end;

registration
  let i be keeping_0 parahalting Instruction of SCM+FSA, J be InitHalting
  Program of SCM+FSA;
  cluster i ';' J -> InitHalting;
  coherence;
end;

registration
  let I, J be keepInt0_1 Program of SCM+FSA;
  cluster I ';' J -> keepInt0_1;
  coherence
  proof
    let s be State of SCM+FSA;
    assume
A2: iS c= s;
    then
A3: Initialized s = s by FUNCT_4:98;
    let p;
    assume
A4:  I ';' J c= p;
    then
A5: p +* (I ';' J) = p by FUNCT_4:98;
A8: I c= p +* I by FUNCT_4:25;
A9: iS c= Initialized s by FUNCT_4:25;
    per cases;
    suppose
A10:   p+*I halts_on Initialized s;
      let k be Element of NAT;
A11:   Initialized s = s by A2,FUNCT_4:98;
        per cases;
        suppose
A12:       k <= LifeSpan(p+*I,Initialized s);
      Comput(p +* I, (Initialized s),k).intloc 0 = 1 by Def3,A8,A9;
          hence ::thesis
          (Comput(p,s,k)).intloc 0 = 1 by A3,A10,A12,Th24,A5;
        end;
        suppose
A14:      k > LifeSpan(p+*I,Initialized s);
          set LS = LifeSpan(p+*I,Initialized s)
;
          consider pp being Element of NAT such that
A15:      k = LS + pp and
A16:      1 <= pp by A14,FINSEQ_4:84;
          consider r being Nat such that
A17:      pp = 1 + r by A16,NAT_1:10;
          reconsider r as Element of NAT by ORDINAL1:def 12;
          set Rr = Comput(p +* I +* J,
          Result(p +* I,s) +*iS,r);
          set Sr = Start-At (IC Comput(p +* I +* J,
           (Result(p +* I,s) +*iS
          ),r) + card I, SCM+FSA);
A18:       iS c=Result(p +* I,s) +*iS
                      by FUNCT_4:25;
          J c= p +* I +* J by FUNCT_4:25;
          then
A19:      Comput(p +* I +* J,
           Result(p +* I,s) +*iS,r).intloc 0 = 1
          by Def3,A18;
          dom Sr = {IC SCM+FSA} & intloc 0 <> IC SCM+FSA by FUNCOP_1:13
,SCMFSA_2:56;
          then
B20:     not intloc 0 in dom Sr by TARSKI:def 1;
          (Rr +* Sr) =  Comput(p +* (I ';' J), (s),LS+1+r)
            by A2,A10,A11,Th26,A4;
          hence thesis by A15,A17,A19,B20,A5,FUNCT_4:11;
        end;
    end;
    suppose
A21:  not p+*I halts_on Initialized s;
      let k be Element of NAT;
      Comput(p +* I, (Initialized s),k).intloc 0 = 1 by Def3,A8,A9;
      hence thesis by A3,A5,A21,Th27;
    end;
  end;
end;

registration
  let j be keeping_0 parahalting Instruction of SCM+FSA, I be keepInt0_1
  InitHalting Program of SCM+FSA;
  cluster I ';' j -> InitHalting keepInt0_1;
  coherence;
end;

registration
  let i be keeping_0 parahalting Instruction of SCM+FSA, J be keepInt0_1
  InitHalting Program of SCM+FSA;
  cluster i ';' J -> InitHalting keepInt0_1;
  coherence;
end;

registration
  let j be parahalting Instruction of SCM+FSA, I be parahalting Program of
  SCM+FSA;
  cluster I ';' j -> InitHalting;
  coherence;
end;

registration
  let i,j be parahalting Instruction of SCM+FSA;
  cluster i ';' j -> InitHalting;
  coherence;
end;

theorem Th30:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds IExec(I ';' J,p,s).a
 = IExec(J,p,IExec(I,p,s)).a
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA, J be InitHalting Program
  of SCM+FSA;
  IExec(I ';' J,p,s)
   = IncIC(IExec(J,p,IExec(I,p,s)),card I) & not a in dom
Start-At (IC IExec(J,p,IExec(I,p,s)) + card I, SCM+FSA) by Th29,SCMFSA_2:102;
  hence thesis by FUNCT_4:11;
end;

theorem Th31:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds IExec(I ';' J,p,s).f
 = IExec(J,p,IExec(I,p,s)).f
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA, J be InitHalting Program
  of SCM+FSA;
  IExec(I ';' J,p,s) = IncIC(IExec(J,p,IExec(I,p,s)),card I) & not f in dom
Start-At (IC IExec(J,p,IExec(I,p,s)) + card I, SCM+FSA) by Th29,SCMFSA_2:103;
  hence thesis by FUNCT_4:11;
end;

theorem Th32:
  for I be keepInt0_1 InitHalting Program of SCM+FSA, s be State
  of SCM+FSA holds DataPart(Initialized IExec(I,p,s)) = DataPart IExec(I,p,s)
proof
  set IF = Data-Locations SCM+FSA;
  let I be keepInt0_1 InitHalting Program of SCM+FSA, s be State of SCM+FSA;
  set IE = IExec(I,p,s);
  now
A1: dom (Initialized IE) = the carrier of SCM+FSA by PARTFUN1:def 2;
A2: dom Initialized IE
      = Data-Locations SCM+FSA \/ {IC SCM+FSA} by MEMSTR_0:13;
A3: dom IE = the carrier of SCM+FSA by PARTFUN1:def 2;
    hence dom DataPart Initialized IE = dom IE /\ IF by A1,RELAT_1:61;
    then
A4: dom DataPart Initialized IE = Data-Locations SCM+FSA
by A1,A3,A2,XBOOLE_1:21;
    let x be set;
    assume
A5: x in dom DataPart Initialized IE;
    per cases by A5,A4,SCMFSA_2:100,XBOOLE_0:def 3;
    suppose
      x in Int-Locations;
      then reconsider x9 = x as Int-Location by SCMFSA_2:4;
      hereby
        per cases;
        suppose
A6:       x9 is read-write;
          thus (DataPart Initialized IE).x = (Initialized IE).x by A5,A4,
FUNCT_1:49
            .= IE.x by A6,SCMFSA6C:3;
        end;
        suppose
          x9 is read-only;
          then
A7:       x9 = intloc 0 by SF_MASTR:def 5;
          thus (DataPart Initialized IE).x = (Initialized IE).x9 by A5,A4,
FUNCT_1:49
            .= 1 by A7,SCMFSA6A:38
            .= IE.x by A7,Th17;
        end;
      end;
    end;
    suppose
      x in FinSeq-Locations;
      then reconsider x9 = x as FinSeq-Location by SCMFSA_2:5;
      thus (DataPart Initialized IE).x = (Initialized IE).x9
      by A5,A4,FUNCT_1:49
        .= IE.x by SCMFSA6C:3;
    end;
  end;
  hence thesis by FUNCT_1:46;
end;

theorem Th33:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j,p,s).a
 = Exec(j,IExec(I,p,s)).a
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mj = Macro j;
  set SA = Start-At (IC IExec(Mj,p,IExec(I,p,s)) + card I, SCM+FSA);
A1: not a in dom SA by SCMFSA_2:102;
A2: DataPart Initialized IExec(I,p,s) = DataPart IExec(I,p,s) by Th32;
  a in Int-Locations by SCMFSA_2:2;
  then
A3: a in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
  thus IExec(I ';' j,p,s).a = IncIC(IExec(Mj,p,IExec(I,p,s)),card I).a by Th29
    .= IExec(Mj,p,IExec(I,p,s)).a by A1,FUNCT_4:11
    .= ( Exec(j, Initialized IExec(I,p,s))).a by SCMFSA6C:5
    .= (DataPart Exec(j, Initialized IExec(I,p,s))).a by A3,FUNCT_1:49
    .= (DataPart Exec(j, IExec(I,p,s))).a by A2,SCMFSA6C:4
    .= Exec(j, IExec(I,p,s)).a by A3,FUNCT_1:49;
end;

theorem Th34:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j,p,s).f
 = Exec(j,IExec(I,p,s)).f
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mj = Macro j;
  set SA = Start-At (IC IExec(Mj,p,IExec(I,p,s)) + card I, SCM+FSA);
A1: not f in dom SA by SCMFSA_2:103;
A2: DataPart Initialized IExec(I,p,s) = DataPart IExec(I,p,s) by Th32;
  f in FinSeq-Locations by SCMFSA_2:3;
  then
A3: f in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
  thus IExec(I ';' j,p,s).f = IncIC(IExec(Mj,p,IExec(I,p,s)),card I).f by Th29
    .= IExec(Mj,p,IExec(I,p,s)).f by A1,FUNCT_4:11
    .= ( Exec(j, Initialized IExec(I,p,s))).f by SCMFSA6C:5
    .= (DataPart Exec(j, Initialized IExec(I,p,s))).f by A3,FUNCT_1:49
    .= (DataPart Exec(j, IExec(I,p,s))).f by A2,SCMFSA6C:4
    .= Exec(j, IExec(I,p,s)).f by A3,FUNCT_1:49;
end;

definition
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  let p;
  pred I is_closed_onInit s,p means
  :Def4:
  for k being Element of NAT holds IC
  Comput(p +* I,Initialized s,k) in dom I;
  pred I is_halting_onInit s,p means
  :Def5:
  p+*I halts_on Initialized s;
end;

theorem Th35:
  for I being Program of SCM+FSA holds I is InitClosed iff for s
  being State of SCM+FSA,p holds I is_closed_onInit s,p
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is InitClosed;
    let s be State of SCM+FSA;
    let p;
A2: I c= p+*I by FUNCT_4:25;
A3: iS c= Initialized s by FUNCT_4:25;
    for k being Element of NAT holds
     IC Comput(p +* I, (Initialized s),k) in dom I
      by A1,Def1,A2,A3;

    hence I is_closed_onInit s,p by Def4;
  end;
  assume
A4: for s being State of SCM+FSA,p holds I is_closed_onInit s,p;
  now
    let s be State of SCM+FSA;
    let p be Instruction-Sequence of SCM+FSA;
    assume
  I c= p;
     then
A5:  p +* I = p by FUNCT_4:98;
    let k be Element of NAT;
    assume iS c= s;
    then
A6: s = Initialized s by FUNCT_4:98;
    I is_closed_onInit s,p by A4;
    hence IC Comput(p,s,k) in dom I by A6,Def4,A5;
  end;
  hence thesis by Def1;
end;

theorem Th36:
  for I being Program of SCM+FSA holds I is InitHalting iff for s
  being State of SCM+FSA,p holds I is_halting_onInit s,p
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A2: I is InitHalting;
    let s be State of SCM+FSA;
    let p;
A3:  I c= p+*I by FUNCT_4:25;
    iS c= Initialized s by FUNCT_4:25;
    then p+*I halts_on Initialized s by A3,Def2,A2;
    hence I is_halting_onInit s,p by Def5;
  end;
  assume
A4: for s being State of SCM+FSA,p holds I is_halting_onInit s,p;
  now
    let s be State of SCM+FSA;
    assume iS c= s;
    then
A5: s = Initialized s by FUNCT_4:98;
    let p;
    assume I c= p;
    then
A6:  p +* I = p by FUNCT_4:98;
    I is_halting_onInit s,p by A4;
    hence p halts_on s by A5,Def5,A6;
  end;
  hence thesis by Def2;
end;

theorem Th37:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does not destroy a & I is_closed_onInit s,p &
 Initialize ((intloc 0) .--> 1) c= s & I c= p
   holds for k being Element of NAT holds Comput(p,s,k).a = s.a
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA,a be Int-Location;
  assume
A1: I does not destroy a;
  defpred P[Nat] means Comput(p,s,$1).a = s.a;
  assume
A2: I is_closed_onInit s,p;
  assume iS c= s;
  then
A3: Initialized s = s by FUNCT_4:98;
  assume
A4: I c= p;
   then
A5: p +* I = p by FUNCT_4:98;
A6: now
    let k be Element of NAT;
    assume
A7: P[k];
    set l = IC Comput(p,s,k);
A8: l in dom I by A2,A3,Def4,A5;
    then p.l = I.l by A4,GRFUNC_1:2;
    then p.l in rng I by A8,FUNCT_1:def 3;
    then
A9: p.l does not destroy a by A1,SCMFSA7B:def 4;
    Comput(p, s,k + 1).a = (Following(p,
    Comput(p,s,k))).a by EXTPRO_1:3
      .= Exec(p.l,Comput(p,s,k)).a by PBOOLE:143
      .= s.a by A7,A9,SCMFSA7B:20;
    hence P[k+1];
  end;
A10: P[0] by EXTPRO_1:2;
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A10,A6);
end;

registration
  cluster InitHalting good for Program of SCM+FSA;
  existence
  proof
    take Stop SCM+FSA;
    thus thesis;
  end;
end;

registration
  cluster InitClosed good -> keepInt0_1 for Program of SCM+FSA;
  correctness
  proof
    let I be Program of SCM+FSA;
    assume
A1: I is InitClosed good;
    then
A2: I does not destroy intloc 0 by SCMFSA7B:def 5;
    now
      let s be State of SCM+FSA;
      assume
A3:   iS c= s;
      let p;
      assume
A4:    I c= p;
      let k be Element of NAT;
        I is_closed_onInit s,p by A1,Th35;
      hence Comput(p,s,k).intloc 0 = s.intloc 0 by A2,A3,Th37,A4
        .=1 by A3,Th7;
    end;
    hence thesis by Def3;
  end;
end;

registration
  cluster Stop SCM+FSA -> InitHalting good;
  coherence;
end;

theorem
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being InitHalting Program of SCM+FSA, a being
  Int-Location holds IExec(i ';' J,p,s).a
   = IExec(J,p,Exec(i,Initialized s)).a
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  let a be Int-Location;
  thus IExec(i ';' J,p,s).a
     = IExec(J,p,IExec(Macro i,p,s)).a by Th30
    .= IExec(J,p,Exec(i,Initialized s)).a by SCMFSA6C:5;
end;

theorem
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being InitHalting Program of SCM+FSA, f being
  FinSeq-Location holds IExec(i ';' J,p,s).f
   = IExec(J,p,Exec(i,Initialized s)).f
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  let f be FinSeq-Location;
  thus IExec(i ';' J,p,s).f = IExec(J,p,IExec(Macro i,p,s)).f by Th31
    .= IExec(J,p,Exec(i,Initialized s)).f by SCMFSA6C:5;
end;

theorem Th40:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds I
  is_closed_onInit s,p iff I is_closed_on Initialized s,p
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
A2: Initialized s
          = s +* (Initialize iS)
         .= Initialize Initialized s by FUNCT_4:14;
   hereby assume
Z:  I is_closed_onInit s,p;
    thus I is_closed_on Initialized s,p
     proof let k be Element of NAT;
      thus IC Comput(p+*I,Initialize Initialized s,k)
          in dom I by A2,Z,Def4;
     end;
   end;
  assume
Z: I is_closed_on Initialized s,p;
  let k be Element of NAT;
  thus IC Comput(p +* I,Initialized s,k) in dom I
      by A2,Z,SCMFSA7B:def 6;
end;

theorem Th41:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds I
  is_halting_onInit s,p iff I is_halting_on Initialized s,p
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  set s1=Initialized s, p1 = p +* I;
A2: Initialized s = Initialize Initialized s by MEMSTR_0:44;
  I is_halting_onInit s,p iff p1 halts_on s1 by Def5;
  hence thesis by A2,SCMFSA7B:def 7;
end;

theorem
  for I be Program of SCM+FSA, s be State of SCM+FSA holds IExec(I,p,s) =
  IExec(I,p,Initialized s)
proof
  let I be Program of SCM+FSA,s be State of SCM+FSA;
  set sp= s|NAT;
  thus IExec(I,p,s)
     = Result(p+*I,Initialized Initialized s) by SCMFSA6B:def 1
    .= IExec(I,p,Initialized s) by SCMFSA6B:def 1;
end;

theorem Th43:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & I is_closed_onInit s,p & I
  is_halting_onInit s,p holds if=0(a,I,J) is_closed_onInit s,p & if=0(a,I,J)
  is_halting_onInit s,p
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set Is = Initialized s;
  assume s.a = 0;
  then
A1: Is.a =0 by SCMFSA6C:3;
  assume I is_closed_onInit s,p;
  then
A2: I is_closed_on Is,p by Th40;
  assume I is_halting_onInit s,p;
  then I is_halting_on Is,p by Th41;
  then if=0(a,I,J) is_closed_on Is,p &
   if=0(a,I,J) is_halting_on Is,p by A1,A2,SCMFSA8B:13;
  hence thesis by Th40,Th41;
end;

theorem Th44:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & I is_closed_onInit s,p & I
is_halting_onInit s,p holds IExec(if=0(a,I,J),p,s)
 = IExec(I,p,s) +* Start-At( (card I + card J + 3),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  set Is = Initialized s;
  assume I is_closed_onInit s,p;
  then
A2: I is_closed_on Is,p by Th40;
  assume I is_halting_onInit s,p;
  then I is_halting_on Is,p by Th41;
  hence thesis by A1,A2,SCMFSA8B:14;
end;

theorem Th45:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a <> 0 & J is_closed_onInit s,p & J
  is_halting_onInit s,p holds if=0(a,I,J) is_closed_onInit s,p & if=0(a,I,J)
  is_halting_onInit s,p
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set Is = Initialized s;
  assume s.a <> 0;
  then
A1: Is.a <> 0 by SCMFSA6C:3;
  assume J is_closed_onInit s,p;
  then
A2: J is_closed_on Is,p by Th40;
  assume J is_halting_onInit s,p;
  then J is_halting_on Is,p by Th41;
  then if=0(a,I,J) is_closed_on Is,p & if=0(a,I,J) is_halting_on Is,p by A1,A2,
SCMFSA8B:15;
  hence thesis by Th40,Th41;
end;

theorem Th46:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <> 0 & J
is_closed_onInit s,p & J is_halting_onInit s,p
 holds IExec(if=0(a,I,J),p,s)
  = IExec(J,p,s) +* Start-At((card I + card J + 3),SCM+FSA)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  assume
A1: s.a <> 0;
  set Is = Initialized s;
  assume J is_closed_onInit s,p;
  then
A2: J is_closed_on Is,p by Th40;
  assume J is_halting_onInit s,p;
  then J is_halting_on Is,p by Th41;
  hence thesis by A1,A2,SCMFSA8B:16;
end;

theorem Th47:
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if=0(a,I,J) is InitHalting & (s.
  a = 0 implies IExec(if=0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((card I +
card J + 3),SCM+FSA)) &
 (s.a <> 0 implies IExec(if=0(a,I,J),p,s) = IExec(J,p,s) +* Start-At(
   (card I + card J + 3),SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  now
    let s be State of SCM+FSA;
    assume iS c= s;
    then
A2: s = Initialized s by FUNCT_4:98;
    let p;
    assume if=0(a,I,J) c= p;
    then
A3: p = p +* if=0(a,I,J) by FUNCT_4:98;
A4: J is_closed_onInit s,p & J is_halting_onInit s,p by Th35,Th36;
A5: I is_closed_onInit s,p & I is_halting_onInit s,p by Th35,Th36;
    per cases;
    suppose
      s.a = 0;
      then if=0(a,I,J) is_halting_onInit s,p by A5,Th43;
      hence p halts_on s by A2,Def5,A3;
    end;
    suppose
      s.a <> 0;
      then if=0(a,I,J) is_halting_onInit s,p by A4,Th45;
      hence p halts_on s by A2,Def5,A3;
    end;
  end;
  hence if=0(a,I,J) is InitHalting by Def2;
  I is_closed_onInit s,p & I is_halting_onInit s,p by Th35,Th36;
  hence s.a = 0 implies IExec(if=0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((
  card I + card J + 3),SCM+FSA) by Th44;
  J is_closed_onInit s,p & J is_halting_onInit s,p by Th35,Th36;
  hence thesis by Th46;
end;

theorem
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA
, a being read-write Int-Location holds IC IExec(if=0(a,I,J),p,s) =  (card
I + card J + 3) & (s.a = 0 implies ((for d being Int-Location
 holds IExec(if=0(a,I,J),p,s).d = IExec(I,p,s).d) &
  for f being FinSeq-Location
 holds IExec(if=0(a,I,J),p,s).f = IExec(I,p,s).f)) & (s.a <> 0 implies
   ((for d being Int-Location holds
  IExec(if=0(a,I,J),p,s).d = IExec(J,p,s).d) &
  for f being FinSeq-Location holds
  IExec(if=0(a,I,J),p,s).f = IExec(J,p,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby
    per cases;
    suppose
      s.a = 0;
      then
      IExec(if=0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((card I + card
      J + 3),SCM+FSA) by Th47;
      hence IC IExec(if=0(a,I,J),p,s) =  (card I + card J + 3) by FUNCT_4:113
;
    end;
    suppose
      s.a <> 0;
      then
      IExec(if=0(a,I,J),p,s) = IExec(J,p,s) +* Start-At((card I + card
      J + 3),SCM+FSA) by Th47;
      hence IC IExec(if=0(a,I,J),p,s) =  (card I + card J + 3) by FUNCT_4:113
;
    end;
  end;
  hereby
    assume s.a = 0;
    then
A1: IExec(if=0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((card I + card J
    + 3),SCM+FSA) by Th47;
    hereby
      let d be Int-Location;
      not d in dom Start-At((card I + card J + 3),SCM+FSA)
      by SCMFSA_2:102;
      hence IExec(if=0(a,I,J),p,s).d = IExec(I,p,s).d by A1,FUNCT_4:11;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At((card I + card J + 3),SCM+FSA)
    by SCMFSA_2:103;
    hence IExec(if=0(a,I,J),p,s).f = IExec(I,p,s).f by A1,FUNCT_4:11;
  end;
  assume s.a <> 0;
  then
A2: IExec(if=0(a,I,J),p,s) = IExec(J,p,s) +* Start-At((card I + card J +
  3),SCM+FSA) by Th47;
  hereby
    let d be Int-Location;
    not d in dom Start-At((card I + card J + 3),SCM+FSA) by SCMFSA_2:102;
    hence IExec(if=0(a,I,J),p,s).d = IExec(J,p,s).d by A2,FUNCT_4:11;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At((card I + card J + 3),SCM+FSA) by SCMFSA_2:103;
  hence thesis by A2,FUNCT_4:11;
end;

theorem Th49:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & I is_closed_onInit s,p & I
  is_halting_onInit s,p holds if>0(a,I,J) is_closed_onInit s,p & if>0(a,I,J)
  is_halting_onInit s,p
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set Is = Initialized s;
  assume s.a > 0;
  then
A1: Is.a >0 by SCMFSA6C:3;
  assume I is_closed_onInit s,p;
  then
A2: I is_closed_on Is,p by Th40;
  assume I is_halting_onInit s,p;
  then I is_halting_on Is,p by Th41;
  then if>0(a,I,J) is_closed_on Is,p & if>0(a,I,J) is_halting_on Is,p by A1,A2,
SCMFSA8B:19;
  hence thesis by Th40,Th41;
end;

theorem Th50:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & I is_closed_onInit s,p & I
is_halting_onInit s,p holds IExec(if>0(a,I,J),p,s)
 = IExec(I,p,s) +* Start-At((card I + card J + 3),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  set Is = Initialized s;
  assume I is_closed_onInit s,p;
  then
A2: I is_closed_on Is,p by Th40;
  assume I is_halting_onInit s,p;
  then I is_halting_on Is,p by Th41;
  hence thesis by A1,A2,SCMFSA8B:20;
end;

theorem Th51:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a <= 0 & J is_closed_onInit s,p & J
  is_halting_onInit s,p holds if>0(a,I,J) is_closed_onInit s,p & if>0(a,I,J)
  is_halting_onInit s,p
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set Is = Initialized s;
  assume s.a <= 0;
  then
A1: Is.a <= 0 by SCMFSA6C:3;
  assume J is_closed_onInit s,p;
  then
A2: J is_closed_on Is,p by Th40;
  assume J is_halting_onInit s,p;
  then J is_halting_on Is,p by Th41;
  then if>0(a,I,J) is_closed_on Is,p & if>0(a,I,J) is_halting_on Is,p by A1,A2,
SCMFSA8B:21;
  hence thesis by Th40,Th41;
end;

theorem Th52:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <= 0 & J
is_closed_onInit s,p & J is_halting_onInit s,p
 holds IExec(if>0(a,I,J),p,s)
  = IExec(J,p,s) +* Start-At((card I + card J + 3),SCM+FSA)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  assume
A1: s.a <= 0;
  set Is = Initialized s;
  assume J is_closed_onInit s,p;
  then
A2: J is_closed_on Is,p by Th40;
  assume J is_halting_onInit s,p;
  then J is_halting_on Is,p by Th41;
  hence thesis by A1,A2,SCMFSA8B:22;
end;

theorem Th53:
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if>0(a,I,J) is InitHalting & (s.
  a > 0 implies IExec(if>0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((card I +
card J + 3),SCM+FSA)) &
 (s.a <= 0 implies IExec(if>0(a,I,J),p,s) = IExec(J,p,s) +* Start-At(
   (card I + card J + 3),SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  now
    let s be State of SCM+FSA;
    assume iS c= s;
    then
A2: s = Initialized s by FUNCT_4:98;
    let p;
    assume if>0(a,I,J) c= p;
    then
A3: p = p +* if>0(a,I,J) by FUNCT_4:98;
A4: J is_closed_onInit s,p & J is_halting_onInit s,p by Th35,Th36;
A5: I is_closed_onInit s,p & I is_halting_onInit s,p by Th35,Th36;
    per cases;
    suppose
      s.a > 0;
      then if>0(a,I,J) is_halting_onInit s,p by A5,Th49;
      hence p halts_on s by A2,Def5,A3;
    end;
    suppose
      s.a <= 0;
      then if>0(a,I,J) is_halting_onInit s,p by A4,Th51;
      hence p halts_on s by A2,Def5,A3;
    end;
  end;
  hence if>0(a,I,J) is InitHalting by Def2;
  I is_closed_onInit s,p & I is_halting_onInit s,p by Th35,Th36;
  hence s.a > 0 implies IExec(if>0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((
  card I + card J + 3),SCM+FSA) by Th50;
  J is_closed_onInit s,p & J is_halting_onInit s,p by Th35,Th36;
  hence thesis by Th52;
end;

theorem
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA
, a being read-write Int-Location holds IC IExec(if>0(a,I,J),p,s) =  (card
I + card J + 3) & (s.a > 0 implies ((for d being Int-Location
 holds IExec(if>0(a,I,J),p,s).d = IExec(I,p,s).d) &
  for f being FinSeq-Location
 holds IExec(if>0(a,I,J),p,s).f
  = IExec(I,p,s).f)) & (s.a <= 0 implies ((for d being Int-Location
   holds
  IExec(if>0(a,I,J),p,s).d = IExec(J,p,s).d) & for f being FinSeq-Location
   holds
  IExec(if>0(a,I,J),p,s).f = IExec(J,p,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby
    per cases;
    suppose
      s.a > 0;
      then
      IExec(if>0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((card I + card
      J + 3),SCM+FSA) by Th53;
      hence IC IExec(if>0(a,I,J),p,s) =  (card I + card J + 3) by FUNCT_4:113
;
    end;
    suppose
      s.a <= 0;
      then
      IExec(if>0(a,I,J),p,s) = IExec(J,p,s) +* Start-At((card I + card
      J + 3),SCM+FSA) by Th53;
      hence IC IExec(if>0(a,I,J),p,s) =  (card I + card J + 3) by FUNCT_4:113
;
    end;
  end;
  hereby
    assume s.a > 0;
    then
A1: IExec(if>0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((card I + card J
    + 3),SCM+FSA) by Th53;
    hereby
      let d be Int-Location;
      not d in dom Start-At((card I + card J + 3),SCM+FSA)
      by SCMFSA_2:102;
      hence IExec(if>0(a,I,J),p,s).d = IExec(I,p,s).d by A1,FUNCT_4:11;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At((card I + card J + 3),SCM+FSA) by SCMFSA_2:103;
    hence IExec(if>0(a,I,J),p,s).f = IExec(I,p,s).f by A1,FUNCT_4:11;
  end;
  assume s.a <= 0;
  then
A2: IExec(if>0(a,I,J),p,s) = IExec(J,p,s) +* Start-At((card I + card J +
  3),SCM+FSA) by Th53;
  hereby
    let d be Int-Location;
    not d in dom Start-At((card I + card J + 3),SCM+FSA) by SCMFSA_2:102;
    hence IExec(if>0(a,I,J),p,s).d = IExec(J,p,s).d by A2,FUNCT_4:11;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At((card I + card J + 3),SCM+FSA) by SCMFSA_2:103;
  hence thesis by A2,FUNCT_4:11;
end;

theorem Th55:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a < 0 & I is_closed_onInit s,p & I
is_halting_onInit s,p holds IExec(if<0(a,I,J),p,s)
 = IExec(I,p,s) +* Start-At((card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a < 0;
  set Is = Initialized s;
  assume I is_closed_onInit s,p;
  then
A2: I is_closed_on Is,p by Th40;
  assume I is_halting_onInit s,p;
  then I is_halting_on Is,p by Th41;
  hence thesis by A1,A2,SCMFSA8B:26;
end;

theorem Th56:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & J is_closed_onInit s,p & J
is_halting_onInit s,p holds IExec(if<0(a,I,J),p,s) = IExec(J,p,s) +* Start-At(
  (card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA,I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  set Is = Initialized s;
  assume J is_closed_onInit s,p;
  then
A2: J is_closed_on Is,p by Th40;
  assume J is_halting_onInit s,p;
  then J is_halting_on Is,p by Th41;
  hence thesis by A1,A2,SCMFSA8B:28;
end;

theorem Th57:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & J is_closed_onInit s,p & J
is_halting_onInit s,p holds IExec(if<0(a,I,J),p,s) = IExec(J,p,s) +* Start-At(
  (card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA,I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  set Is = Initialized s;
  assume J is_closed_onInit s,p;
  then
A2: J is_closed_on Is,p by Th40;
  assume J is_halting_onInit s,p;
  then J is_halting_on Is,p by Th41;
  hence thesis by A1,A2,SCMFSA8B:30;
end;

theorem Th58:
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if<0(a,I,J) is InitHalting & (s.
  a < 0 implies IExec(if<0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((card I +
card J + card J + 7),SCM+FSA)) &
 (s.a >= 0 implies IExec(if<0(a,I,J),p,s) = IExec(J,p,s) +*
  Start-At((card I + card J + card J + 7),SCM+FSA))
proof
  let s be State of SCM+FSA,I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  if<0(a,I,J) = if=0(a,J,if>0(a,J,I)) & if>0(a,J,I) is InitHalting by Th53,
SCMFSA8B:def 3;
  hence if<0(a,I,J) is InitHalting by Th47;
  I is_closed_onInit s,p & I is_halting_onInit s,p by Th35,Th36;
  hence s.a < 0 implies IExec(if<0(a,I,J),p,s) = IExec(I,p,s) +* Start-At((
  card I + card J + card J + 7),SCM+FSA) by Th55;
A1: J is_closed_onInit s,p & J is_halting_onInit s,p by Th35,Th36;
  hereby
    assume
A2: s.a >= 0;
    per cases;
    suppose
      s.a = 0;
      hence
      IExec(if<0(a,I,J),p,s) = IExec(J,p,s) +* Start-At((card I + card
      J + card J + 7),SCM+FSA) by A1,Th56;
    end;
    suppose
      s.a <> 0;
      hence
      IExec(if<0(a,I,J),p,s) = IExec(J,p,s) +* Start-At((card I + card
      J + card J + 7),SCM+FSA) by A1,A2,Th57;
    end;
  end;
end;

registration
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  cluster if=0(a,I,J) -> InitHalting;
  correctness by Th47;
  cluster if>0(a,I,J) -> InitHalting;
  correctness by Th53;
  cluster if<0(a,I,J) -> InitHalting;
  correctness by Th58;
end;

theorem Th59:
  for I being Program of SCM+FSA holds I is InitHalting iff for s
  being State of SCM+FSA,p holds I is_halting_on Initialized s,p
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is InitHalting;
    let s be State of SCM+FSA,p;
    I is_halting_onInit s,p by A1,Th36;
    hence I is_halting_on Initialized s,p by Th41;
  end;
  assume
A2: for s being State of SCM+FSA,p holds I is_halting_on Initialized s,p;
  now
    let s be State of SCM+FSA,p;
    I is_halting_on Initialized s,p by A2;
    hence I is_halting_onInit s,p by Th41;
  end;
  hence thesis by Th36;
end;

theorem Th60:
  for I being Program of SCM+FSA holds I is InitClosed iff for s
  being State of SCM+FSA,p holds I is_closed_on Initialized s,p
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is InitClosed;
    let s be State of SCM+FSA,p;
    I is_closed_onInit s,p by A1,Th35;
    hence I is_closed_on Initialized s,p by Th40;
  end;
  assume
A2: for s being State of SCM+FSA,p holds I is_closed_on Initialized s,p;
  now
    let s be State of SCM+FSA,p;
    I is_closed_on Initialized s,p by A2;
    hence I is_closed_onInit s,p by Th40;
  end;
  hence thesis by Th35;
end;

theorem Th61:
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being read-write Int-Location holds IExec(I,p,s).a
   = Comput(p +* I, Initialize Initialized s,
  LifeSpan(p +* I,Initialize Initialized s)).a
proof
  let s be State of SCM+FSA,I be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  I is_halting_on Initialized s,p by Th59;
  hence thesis by SCMFSA8C:58;
end;

theorem Th62:
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being Int-Location,k being Element of NAT st I does not destroy a
holds IExec(I,p,s).a = Comput(p +* I,
 Initialize Initialized s,k).a
proof
  let s be State of SCM+FSA,I be InitHalting Program of SCM+FSA;
  let a be Int-Location,k be Element of NAT;
  assume
A1: I does not destroy a;
  I is_halting_on Initialized s,p &
  I is_closed_on Initialized s,p by Th59,Th60;
  hence thesis by A1,SCMFSA8C:60;
end;
set A = NAT;
set D = Data-Locations SCM+FSA;

theorem Th63:
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being Int-Location st I does not destroy a
   holds IExec(I,p,s).a = (Initialized s).a
proof
  let s be State of SCM+FSA;
  let I be InitHalting Program of SCM+FSA;
  let a be Int-Location;
A1: Initialized s
        = s +* (Initialize ((intloc 0) .--> 1)+*(SA0)) by FUNCT_4:93
       .= Initialized s+*SA0 by FUNCT_4:14;
  assume I does not destroy a;
  hence
  IExec(I,p,s).a = Comput(p +* I,
    Initialize Initialized s,0).a by Th62
    .= (Initialized s).a by A1,EXTPRO_1:2;
end;

theorem Th64:
  for s be State of SCM+FSA,I be keepInt0_1 InitHalting Program of
  SCM+FSA, a being read-write Int-Location st I does not destroy a holds
Comput(p +* (I ';' SubFrom(a,intloc 0)),
 Initialize Initialized s,
 LifeSpan(p +* (I ';' SubFrom(a,intloc 0)),
 Initialize Initialized s)).a
  = s.a - 1
proof
  let s be State of SCM+FSA,I be keepInt0_1 InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
  set s0 = Initialized s,
      p0 = p;
  set s1 = Initialize s0,
      p1 = p0 +* (I ';' SubFrom(a,intloc 0));
AA: a <> IC SCM+FSA by SCMFSA_2:56;
   dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
   then
A2: not a in dom SA0 by AA,TARSKI:def 1;
  IExec(I ';' SubFrom(a,intloc 0),p,s).a
   = Exec(SubFrom(a,intloc 0),IExec(I,p,s)).a by Th33
    .= IExec(I,p,s).a - IExec(I,p,s).intloc 0 by SCMFSA_2:65
    .= IExec(I,p,s).a - 1 by Th17
    .= Comput(p0 +* I, (Initialize s0),0).a - 1
    by A1,Th62
    .= (Initialize s0).a - 1 by EXTPRO_1:2
    .= s0.a - 1 by A2,FUNCT_4:11;
  hence Comput(p1, s1,LifeSpan(p1,s1)).a = s0.a - 1 by Th61
    .= s.a - 1 by SCMFSA6C:3;
end;

theorem Th65:
  for s being State of SCM+FSA, I being InitClosed Program of
SCM+FSA st Initialize ((intloc 0) .--> 1) c= s & I c= p &
   p halts_on s
 for m being Element of NAT st m <=
     LifeSpan(p,s)
  holds  Comput(p,s,m) =  Comput(p +* loop I, s,m)
proof
  let s be State of SCM+FSA,I be InitClosed Program of SCM+FSA;
  assume that
A1: iS c= s and
A2: I c= p;
  defpred X[Nat] means $1 <= LifeSpan(p,s)
   implies  Comput(p,s,$1) =  Comput(p +* loop I,(s),$1);
  assume
A3: p halts_on s;
A4: for m st X[m] holds X[m+1]
  proof
    set sx = s,
        px = p+*loop I;
A5: loop I c= px by FUNCT_4:25;
    let m;
    assume
A6: m <= LifeSpan(p,s) implies
      Comput(p,s,m) =  Comput(p +* loop I,(s),m);
A7: Comput(px,sx,m+1) = Following(px,Comput(px,sx,m)) by EXTPRO_1:3
      .= Exec(CurInstr(px,Comput(px,sx,m)),
      Comput(px,sx,m));
A8: Comput(p,s,m+1) =
Following(p,Comput(p,s,m))
 by EXTPRO_1:3
      .= Exec(CurInstr(p,Comput(p,s,m))
      ,Comput(p,s,m));
A9: IC Comput(p,s,m) in dom I by A1,Def1,A2;
    then
A10: IC Comput(p,s,m) in dom loop I by FUNCT_4:99;
A11:  p/.IC Comput(p,s,m) = p.IC Comput(p,s,m) by PBOOLE:143;
A12: CurInstr(p,Comput(p,s,m))
 = I.IC(Comput(p,s,m)) by A9,A11,A2,GRFUNC_1:2;
    assume
A13: m+1 <= LifeSpan(p,s);
A15:  px/.IC Comput(px,sx,m) = px.IC Comput(px,sx,m) by PBOOLE:143;
    m < LifeSpan(p,s) by A13,NAT_1:13;
    then I.IC(Comput(p,s,m)) <> halt SCM+FSA by A3,A12,EXTPRO_1:def 15
;
    then CurInstr(p,Comput(p,s,m))
 = (loop I).IC(Comput(p,s,m)) by A12,FUNCT_4:105
      .= CurInstr(px,Comput(px,sx,m))
       by A13,A10,A15,A5,A6,GRFUNC_1:2,NAT_1:13;
    hence thesis by A6,A13,A8,A7,NAT_1:13;
  end;
  Comput(p,s,0) = s & Comput(p +* loop I,(s),0) = s by EXTPRO_1:2;
  then
A16: X[0];
  thus for m being Element of NAT holds X[m] from NAT_1:sch 1(A16, A4);
end;

theorem
  for s being State of SCM+FSA, I being InitHalting Program of SCM+FSA
st Initialize ((intloc 0) .--> 1) c= s & I c= p
 holds for k being Element of NAT st k <= LifeSpan(p,s) holds
  CurInstr(p +* loop I,Comput(p +* loop I, s,k)) <> halt SCM+FSA
proof
  let s be State of SCM+FSA;
  let I be InitHalting Program of SCM+FSA;
  set s2 = s,
      p2 = p +* loop I;
  assume
A2: iS c= s;
 assume
A3: I c= p;
A4: p halts_on s by Def2,A2,A3;
  hereby
    let k be Element of NAT;
    set lk = IC Comput(p,s,k);
A5: IC Comput(p,s,k) in dom I & dom I = dom loop I by A2,Def1,A3,FUNCT_4:99;
    then
A6: (loop I).lk in rng loop I by FUNCT_1:def 3;
    assume k <= LifeSpan(p,s);
    then lk = IC Comput(p2,s2,k) by A2,A4,Th65,A3;
    then
A7: CurInstr(p2,Comput(p2,s2,k)) = p2.lk by PBOOLE:143
      .= (loop I).lk by A5,FUNCT_4:13;
    assume
    CurInstr(p +* loop I,Comput(p +* loop I, s,k)) = halt SCM+FSA;
    hence contradiction by A7,A6,SCMFSA8C:75;
  end;
end;



theorem Th68:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s,p & I is_halting_onInit s,p
  for m being Element of NAT st m <=
  LifeSpan(p+*I,Initialized s)
   holds  Comput(p +* I, Initialized s,m)
     =  Comput(p +* loop I,(Initialized s),m)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = Initialized s,
      p1 = p +* I;
A1: I c= p1 by FUNCT_4:25;
  set s2 = Initialized s,
      p2 = p +* loop I;
A2: loop I c= p2 by FUNCT_4:25;
  assume
A3: I is_closed_onInit s,p;
  defpred X[Nat] means $1 <= LifeSpan(p1,s1) implies
    Comput(p1, s1,$1) =  Comput(p2, s2,$1);
  assume I is_halting_onInit s,p;
  then
A4: p1 halts_on s1 by Def5;
A5: for m being Element of NAT st X[m] holds X[m+1]
  proof
    let m be Element of NAT;
    assume
A6: m <= LifeSpan(p1,s1) implies  Comput(p1,s1,m) =  Comput(p2,s2,m);
A7: IC Comput(p1,s1,m) in dom I by A3,Def4;
    then
A8: IC Comput(p1,s1,m) in dom loop I by FUNCT_4:99;
A9:  p1/.IC Comput(p1,s1,m) = p1.IC Comput(p1,s1,m) by PBOOLE:143;
A10: CurInstr(p1,Comput(p1,s1,m))
       = I.IC Comput(p1,s1,m) by A7,A9,A1,GRFUNC_1:2;
A11: Comput(p2,s2,m+1) = Following(p2,Comput(p2,s2,m)) by EXTPRO_1:3
      .= Exec(CurInstr(p2,Comput(p2,s2,m)),
      Comput(p2,s2,m));
A12: Comput(p1,s1,m+1) =
Following(p1,Comput(p1,s1,m)
)
 by EXTPRO_1:3
      .= Exec(CurInstr(p1,Comput(p1,s1,m)),
      Comput(p1,s1,m));
    assume
A13: m + 1 <= LifeSpan(p1,s1);
    then m < LifeSpan(p1,s1) by NAT_1:13;
    then I.IC Comput(p1,s1,m) <> halt SCM+FSA by A4,A10,EXTPRO_1:def 15;
    then
A14: I.IC Comput(p1,s1,m) = (loop I).IC Comput(p1,s1,
m) by FUNCT_4:105;
A15:  p2/.IC Comput(p2,s2,m) = p2.IC Comput(p2,s2,m) by PBOOLE:143;
    thus thesis by A6,A13,A12,A11,A8,A10,A15,A14,A2,GRFUNC_1:2,NAT_1:13;
  end;
A16: X[0]
  proof
    assume 0 <= LifeSpan(p1,s1);
     s1 =  Comput(p2, s2,0) by EXTPRO_1:2;
    hence thesis by EXTPRO_1:2;
  end;
  thus for m being Element of NAT holds X[m] from NAT_1:sch 1(A16, A5);
end;

theorem Th69:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s,p & I is_halting_onInit s,p
  for m being Element of NAT st m <
LifeSpan(p+*I,Initialized s) holds
 CurInstr(p +* I,
  Comput(p +* I, (Initialized s),m))
  = CurInstr(p +* loop I,
   Comput(p +* loop I,(Initialized s),m))
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = Initialized s,
      p1 = p +* I;
A1: I c= p1 by FUNCT_4:25;
  set s2 = Initialized s,
      p2 = p +* loop I;
A2: loop I c= p2 by FUNCT_4:25;
  assume that
A3: I is_closed_onInit s,p and
A4: I is_halting_onInit s,p;
  let m be Element of NAT;
A5: IC Comput(p1,s1,m) in dom I by A3,Def4;
  then
A6: IC Comput(p1,s1,m) in dom loop I by FUNCT_4:99;
A7:  p1/.IC Comput(p1,s1,m) = p1.IC Comput(p1,s1,m) by PBOOLE:143;
A8: CurInstr(p1,Comput(p1,s1,m))
 = I.IC Comput(p1,s1,m) by A5,A7,A1,GRFUNC_1:2;
  assume
A9: m < LifeSpan(p+*I,Initialized s);
A10:  p2/.IC Comput(p2,s2,m) = p2.IC Comput(p2,s2,m) by PBOOLE:143;
  p1 halts_on s1 by A4,Def5;
  then I.IC Comput(p1,s1,m) <> halt SCM+FSA by A9,A8,EXTPRO_1:def 15;
  then
A11: I.IC Comput(p1,s1,m) = (loop I).IC Comput(p1,s1,m) by FUNCT_4:105;
   Comput(p1,s1,m) =  Comput(p2,s2,m) by A3,A4,A9,Th68;
  hence thesis by A6,A8,A11,A10,A2,GRFUNC_1:2;
end;



theorem Th71:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s,p & I is_halting_onInit s,p
   holds CurInstr(p +* loop I,
   Comput(p +* loop I, Initialized s,
LifeSpan(p+*I,Initialized s)))
    = goto  0 & for m
  being Element of NAT st
   m <= LifeSpan(p+*I,Initialized s)
   holds CurInstr(p +* loop I,Comput(p +* loop I, Initialized s,m))
   <> halt SCM+FSA
proof
A1: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:45;
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  set s1 = Initialized s,
      p1 = p +* I;
  set s2 = Initialized s,
      p2 = p +* loop I;
A2: loop I c= p2 by FUNCT_4:25;
  assume that
A3: I is_closed_onInit s,p and
A4: I is_halting_onInit s,p;
  set k = LifeSpan(p1,s1);
A5: rng I c= the Instructions of SCM+FSA by RELAT_1:def 19;
A6: IC Comput(p1,s1,k) in dom I by A3,Def4;
A7:  dom loop I = dom I by FUNCT_4:99;
A8: CurInstr(p1,Comput(p1,s1,k))
     = p1.IC Comput(p1,s1,k) by PBOOLE:143
    .= I.IC Comput(p1,s1,k) by A6,FUNCT_4:13;
A9: p1 halts_on s1 by A4,Def5;
  then
A10: CurInstr(p1,Comput(p1,s1,k)) = halt SCM+FSA by EXTPRO_1:def 15;
  IC Comput(p1,s1,k) = IC Comput(p2,s2,k) by A3,A4,Th68;
  hence
A11: CurInstr(p2,
      Comput(p2,s2,LifeSpan(p1,s1)))
     = p2.IC Comput(p1,s1,k) by PBOOLE:143
    .= (loop I).IC Comput(p1,s1,k) by A2,A6,A7,GRFUNC_1:2
    .= (((id the Instructions of SCM+FSA) +* (halt SCM+FSA, goto  0))*
  I ).IC Comput(p1,s1,k) by A5,FUNCT_7:116
    .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA, goto  0)).
  halt SCM+FSA by A10,A6,A8,FUNCT_1:13
    .= goto  0 by A1,FUNCT_7:31;
  let m be Element of NAT;
  assume
A12: m <= LifeSpan(p1,s1);
  per cases by A12,XXREAL_0:1;
  suppose
A13: m < LifeSpan(p1,s1);
    then CurInstr(p1,Comput(p1,s1,m))
     <> halt SCM+FSA by A9,EXTPRO_1:def 15;
    hence thesis by A3,A4,A13,Th69;
  end;
  suppose
    m = LifeSpan(p1,s1);
    hence thesis by A11;
  end;
end;

theorem Th73:
  for s being State of SCM+FSA,p
  for I being good InitHalting Program
of SCM+FSA, a being read-write Int-Location st
   I does not destroy a & s.intloc 0 = 1 &
   s.a > 0 holds loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s,p
proof
  let s be State of SCM+FSA,p;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  set P = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
  reconsider I1 = I ';' SubFrom(a,intloc 0) as InitHalting Program of SCM+FSA;
  set i = a =0_goto  (card I1 + 3);
  defpred P[Nat] means for s being State of SCM+FSA,p st
   s.intloc 0 = 1 & s.a = $1 & s.a > 0
   holds Comput(p +* loop P, Initialized s,
     LifeSpan(p +* P,Initialized s) + 1).a = s.a - 1 &
     Comput(p +* loop P, Initialized s,
      LifeSpan(p +* P,Initialized s) + 1).intloc 0 = 1 &
   ex k being Element of NAT st
    IC Comput(p +* loop P,Initialized s,k) = card loop P &
   for n being Element of NAT st n < k holds IC
    Comput(p +* loop P, Initialized s,n) in dom loop P;
  assume
A1: I does not destroy a;
A2: for k being Element of NAT holds P[k] implies P[k + 1]
  proof
A3: now
A4:    0 in dom Macro i & (Macro i). 0 <> halt SCM+FSA by COMPOS_1:58,60;
      P = i ';' I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA by SCMFSA8B:def 1
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1)) ';' Goto
       2 ';' Stop SCM+FSA by SCMFSA6A:29
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2) ';' Stop SCM+FSA by SCMFSA6A:29
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA) by SCMFSA6A:29
        .= Macro i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA);
      hence P. 0 = (Macro i). 0 by A4,SCMFSA6A:15
        .= i by COMPOS_1:58;
      hence P. 0 <> halt SCM+FSA;
A5:   card P = card Goto  2 + card I1 + 4 by SCMFSA8B:11
        .= card I1 + 1 + 4 by SCMFSA8A:15
        .= card I1 + 3 + 2;
      hence  0 in dom P by AFINSQ_1:66;
      card loop P = card dom loop P by CARD_1:62
        .= card dom P by FUNCT_4:99
        .= card P by CARD_1:62;
      then card loop P = card I1 + (3 + 2) by A5;
      hence P. (card I1 + 3) = goto  card loop P
      by SCMFSA8C:83;
      hence P. (card I1 + 3) <> halt SCM+FSA;
      hereby
        card I1 + 3 + 0 < card P by A5,XREAL_1:6;
        hence  (card I1 + 3) in dom P by AFINSQ_1:66;
      end;
    end;
    let k be Element of NAT;
    assume
A6: P[k];
    let ss be State of SCM+FSA;
    let pp be Instruction-Sequence of SCM+FSA;
    assume ss.intloc 0 = 1;
    set s2 = Initialized ss,
        p2 = pp +* loop P;
A7: loop P c= p2 by FUNCT_4:25;
    set s1 = Initialized ss,
        p1 = pp +* P;
    assume
A8: ss.a = k + 1;
A9: Comput(p2,s2,LifeSpan(p1,s1)+1) =
Following(p2,Comput(p2,s2,LifeSpan(p1,s1)))
    by EXTPRO_1:3
      .= Exec(CurInstr(p2,
      Comput(p2,s2,LifeSpan(p1,s1))),
      Comput(p2,s2,LifeSpan(p1,s1)));
    set s3 = Comput(p2,s2,LifeSpan(p1,s1)+1),
        p3 = p2;
    assume
A10: ss.a > 0;
A11: I1 is_closed_onInit ss,pp & I1 is_halting_onInit ss,pp by Th35,Th36;
    then
A12: P is_halting_onInit ss,pp by A10,Th45;
    P is_closed_onInit ss,pp by A10,A11,Th45;
    then
A13: Comput(p2,s2,LifeSpan(p1,s1)+1) = Exec(goto  0,
      Comput(p2,s2,LifeSpan(p1,s1))) by A12,A9,Th71;
A14: P is_closed_onInit ss,pp by A10,A11,Th45;
A15:  card P = card Goto  2 + card I1 + 4 by SCMFSA8B:11
        .= card I1 + 1 + 4 by SCMFSA8A:15
        .= card I1 + 3 + 2;
A16:  card loop P = card dom loop P by CARD_1:62
        .= card dom P by FUNCT_4:99
        .= card P by CARD_1:62;
A17: now
A18:  I1 is_halting_onInit ss,pp by Th36;
      then
A19:  I1 is_halting_on Initialized ss,pp by Th41;
      I1 is_closed_onInit ss,pp by Th35;
      then
       IExec(P,pp,ss) = IExec(I1,pp,ss) +* Start-At((card Goto  2 +
      card I1 + 3),SCM+FSA) by A10,A18,Th46;
      then
A20:  IExec(P,pp,ss).a = IExec(I1,pp,ss).a by SCMFSA_3:3;
      hereby
        thus  0 in dom loop P by A16,A15,AFINSQ_1:66;
        card I1 + 3 + (1 + 1) = (card I1 + 3 + 1) + 1;
        then card I1 + 3 + 1 < card P by A15,NAT_1:13;
        then card I1 + 3 < card loop P by A16,NAT_1:13;
        hence  (card I1 + 3) in dom loop P by AFINSQ_1:66;
      end;
      consider Is being State of SCM+FSA such that
A21:  Is = Initialized Initialized ss;
A22:  Is = Initialized ss +* (Initialize ((intloc 0) .--> 1)+*SA0)
                         by A21,FUNCT_4:93
        .= Initialized ss +* Initialize ((intloc 0) .--> 1)+*SA0
                         by FUNCT_4:14
        .= Initialize Initialized ss by FUNCT_4:93;
      I1 is_closed_onInit ss,pp by Th35;
      then
A23:  I1 is_closed_on Initialized ss,pp by Th40;
      I1 is_halting_onInit ss,pp by Th36;
      then
A24:  I1 is_halting_on Initialized ss,pp by Th41;
A25:  (Initialized ss).a > 0 by A10,SCMFSA6C:3;
      then
A26:  P is_halting_on Initialized ss,pp by A23,A24,SCMFSA8B:15;
      thus
  Initialized Initialized ss = Initialized ss;
A28:  now
        let b be Int-Location;
        Comput(p2,s2,LifeSpan(p1,s1)+1).b = Comput(p2,s2,LifeSpan(p1,s1)).b
        by A13,SCMFSA_2:69;
        hence Comput(p2,s2,LifeSpan(p1,s1)+1).b =
           Comput(pp +* P, Is,LifeSpan(pp +* P,Is)).b
        by A21,A12,A14,Th68;
      end;
      then Comput(p2,s2,LifeSpan(p1,s1)+1).a = Comput(pp +* P
                 , Is,LifeSpan(pp +* P,Is)).a
        .= IExec(P,pp,ss).a by A26,A22,SCMFSA8C:58;
      hence Comput(p2,s2,LifeSpan(p1,s1)+1).a =
        Comput(pp +* I1,Initialize Initialized ss,
             LifeSpan(pp +* I1, Initialize Initialized ss)).a
          by A19,A20,SCMFSA8C:58
        .= ss.a - 1 by A1,Th64;

A29:  P is_closed_on Initialized ss,pp by A25,A23,A24,SCMFSA8B:15;
      Comput(p2,s2,LifeSpan(p1,s1)+1).intloc 0 =
        Comput(pp +* P, Is,LifeSpan(pp +* P,Is)).intloc 0 by A28
        .= 1 by A26,A29,A22,SCMFSA8C:67;
      hence Comput(p2,s2,LifeSpan(p1,s1)+1).intloc 0 = 1;
    end;
    hence s3.a = ss.a - 1 & s3.intloc 0 = 1;
A30: IC Comput(p2,s2,LifeSpan(p1,s1)+1)=  0 by A13,SCMFSA_2:69;
      per cases;
      suppose
A31:    k = 0;
        take m = LifeSpan(p1,s1) + 1 + 1 + 1;
A32:    CurInstr(p2,
           Comput(p2,s2,LifeSpan(p1,s1)+1))
           = p2. 0 by A30,PBOOLE:143
          .= (loop P). 0 by A17,A7,GRFUNC_1:2
          .= i by A3,FUNCT_4:105;
A33:    Comput(p2,s2,LifeSpan(p1,s1)+1+1) =
Following(p2,Comput(p2,s2,LifeSpan(p1,s1)+1)) by EXTPRO_1:3
          .= Exec(i,Comput(p2,s2,LifeSpan(p1,s1)+1)) by A32;
        then IC Comput(p2,s2,LifeSpan(p1,s1)+1+1) =
          (card I1 + 3) by A8,A17,A31,SCMFSA_2:70;
        then
A34:    CurInstr(p2,Comput(p2,s2,LifeSpan(p1,s1)+1+1)) = p2.(card I1 + 3)
             by PBOOLE:143
          .= (loop P). (card I1 + 3)
           by A17,A7,GRFUNC_1:2
          .= goto  card loop P by A3,FUNCT_4:105;
        Comput(p2,s2,m) = Following(p2,Comput(p2,s2,LifeSpan(p1,s1)+1+1))
                   by EXTPRO_1:3
          .= Exec(goto  card loop P, Comput(p2,s2,
        LifeSpan(p1,s1)+1+1)) by A34;
        hence IC Comput(p2,s2,m) =  card loop P by SCMFSA_2:69;
        hereby
          let n be Element of NAT;
          assume n < m;
          then n <= LifeSpan(p1,s1) + 1 + 1 by NAT_1:13;
          then
A35:      n <= LifeSpan(p1,s1) + 1 or n = LifeSpan(p1
,s1) + 1 + 1 by NAT_1:8;
          per cases by A35,NAT_1:8;
          suppose
A36:        n <= LifeSpan(p1,s1);
A37:        I1 is_closed_onInit ss,pp & I1 is_halting_onInit ss,pp
            by Th35,Th36;
            then
A38:        P is_closed_onInit ss,pp by A10,Th45;
            P is_halting_onInit ss,pp by A10,A37,Th45;
            then
A39:        IC Comput(p2,s2,n) = IC Comput(p1,s1,n) by A36,A38,Th68;
            IC Comput(p1,s1,n) in dom P by A38,Def4;
            hence IC Comput(p2,s2,n) in dom loop P by A39,FUNCT_4:99;
          end;
          suppose
            n = LifeSpan(p1,s1) + 1;
            hence IC Comput(p2,s2,n) in dom loop P by A13,A17,SCMFSA_2:69;
          end;
          suppose
            n = LifeSpan(p1,s1) + 1 + 1;
            hence IC Comput(p2,s2,n) in dom loop P by A8,A17,A31,A33,
SCMFSA_2:70;
          end;
        end;
      end;
      suppose
A40:    k > 0;
        consider Is3 being State of SCM+FSA such that
A41:    Is3 = Initialized s3;
        consider m0 being Element of NAT such that
A44:    IC Comput(p3 +* loop P, (Is3 +* iS),m0) = card loop P and
A45:    for n being Element of NAT st n < m0
         holds IC Comput(p3 +* loop P,
        Initialized Is3,n) in dom loop P
         by A6,A40,A8,A17,A41;
        take m = LifeSpan(p1,s1) + 1 + m0;
A46:    Initialized Initialized s3 = s3 by A30,A17,SCMFSA6A:37;
A47:     p3 +* loop P = p3 by FUNCT_4:25,98;
        hence
        IC Comput(p2,s2,m) =  card loop P by A41,A44,A46,EXTPRO_1:4;
        hereby
          let n be Element of NAT;
          assume
A48:      n < m;
A49:      I1 is_closed_onInit ss,pp & I1 is_halting_onInit ss,pp by Th35,Th36;
          then
A50:      P is_closed_onInit ss,pp by A10,Th45;
A51:      P is_halting_onInit ss,pp by A10,A49,Th45;
          per cases by NAT_1:13;
          suppose
            n <= LifeSpan(p1,s1);
            then
A52:        IC Comput(p2,s2,n) = IC Comput(p1,s1,n) by A50,A51,Th68;
            IC Comput(p1,s1,n) in dom P by A50,Def4;
            hence IC Comput(p2,s2,n) in dom loop P by A52,FUNCT_4:99;
          end;
          suppose
A53:        LifeSpan(p1,s1) + 1 <= n;
            consider mm being Element of NAT such that
A54:        mm = n -' (LifeSpan(p1,s1) + 1);
            n - (LifeSpan(p1,s1) + 1) >= 0 by A53,XREAL_1:48;
            then
A55:        mm = n - (LifeSpan(p1,s1) + 1) by A54,XREAL_0:def 2;
            mm + (LifeSpan(p1,s1) + 1) = n by A53,A54,XREAL_1:235;
            then
A56:        IC Comput(p2,s2,n) = IC Comput(p2, s3,mm) by EXTPRO_1:4;
            m0 = m - (LifeSpan(p1,s1) + 1);
            then mm < m0 by A48,A55,XREAL_1:9;
            hence IC Comput(p2,s2,n) in dom loop P by A41,A45,A46,A47,A56;
          end;
        end;
      end;
  end;
  assume
A57: s.intloc 0 = 1;
  assume
A58: s.a > 0;
  then reconsider sa = s.a as Element of NAT by INT_1:3;
A59: P[0];
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A59,A2);
  then
B60:  P[sa];
X4: dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
 IC SCM+FSA <> intloc 0 by SCMFSA_2:56;
    then not intloc 0 in dom SA0 by X4,TARSKI:def 1;
    then
X1: (Initialize s).intloc 0 = 1 by A57,FUNCT_4:11;

   IC SCM+FSA in dom SA0 by X4,TARSKI:def 1;
   then
X2: IC(Initialize s) = IC SA0 by FUNCT_4:13
         .= 0 by FUNCOP_1:72;
    dom((intloc 0) .--> 1) = {intloc 0} by FUNCOP_1:13;
    then
X3: dom SA0 misses dom((intloc 0) .--> 1) by X4,SCMFSA_2:56,ZFMISC_1:11;
  Initialized s
      = s+*(SA0 +* ((intloc 0) .--> 1)) by X3,FUNCT_4:35
     .= Initialize s +* ((intloc 0) .--> 1) by FUNCT_4:14
     .= Initialize s +* ((intloc 0) .--> 1)+*SA0 by X3,FUNCT_4:115
     .= Initialized Initialize s by FUNCT_4:14
     .= Initialize s by X1,X2,SCMFSA6A:37;
  then ex k being Element of NAT st
   IC Comput(p +* loop P, Initialize s,k) = card loop P &
  for n being Element of NAT st n < k
   holds IC Comput(p +* loop P,Initialize s,n) in dom loop P by B60,A57,A58;
  hence ::thesis
   loop P is_pseudo-closed_on s,p
  by SCMFSA8A:def 2;
end;

theorem
  for s being State of SCM+FSA, I being good InitHalting Program of
  SCM+FSA, a being read-write Int-Location st I does not destroy a & s.a > 0
  holds loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on Initialized s,p
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
A2: (Initialized s).a = s.a & (Initialized s).intloc 0 = 1
      by SCMFSA6A:38,SCMFSA6C:3;
  assume s.a > 0;
  hence thesis by A1,A2,Th73;
end;

theorem
  for s being State of SCM+FSA, I being good InitHalting Program of
SCM+FSA, a being read-write Int-Location st I does not destroy a & s.intloc 0 =
  1 holds Times(a,I) is_closed_on s,p & Times(a,I) is_halting_on s,p
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
  assume
A2: s.intloc 0 = 1;
  per cases;
  suppose
A3: s.a > 0;
    Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) = loop
    if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) by SCMFSA6A:22;
    then Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
    is_pseudo-closed_on s,p by A1,A2,A3,Th73;
    hence thesis by A3,SCMFSA8C:39;
  end;
  suppose
A4: s.a <= 0;
    Stop SCM+FSA is_closed_on s,p &
    Stop SCM+FSA is_halting_on s,p by SCMFSA7B:18,19;
    hence thesis by A4,SCMFSA8B:21;
  end;
end;

theorem
  for I being good InitHalting Program of SCM+FSA, a being read-write
  Int-Location st I does not destroy a holds
     Initialize ((intloc 0) .--> 1) is Times(a,I)-halted
proof
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
  now
    let s be State of SCM+FSA,p;
    per cases;
    suppose
      s.a > 0;
      then
A2:   (Initialized s).a > 0 by SCMFSA6C:3;
      (Initialized s).intloc 0 = 1 & Directed loop if=0(a,Goto  2,I
';' SubFrom(a,intloc 0)) = loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
      by SCMFSA6A:22,38;
      then Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
      is_pseudo-closed_on Initialized s,p by A1,A2,Th73;
      hence Times(a,I) is_halting_on Initialized s,p by A2,SCMFSA8C:39;
    end;
    suppose
A3:   s.a <= 0;
A4:   Stop SCM+FSA is_closed_on Initialized s,p & Stop SCM+FSA is_halting_on
      Initialized s,p by SCMFSA7B:18,19;
      (Initialized s).a <= 0 by A3,SCMFSA6C:3;
      hence Times(a,I) is_halting_on Initialized s,p by A4,SCMFSA8B:21;
    end;
  end;
  hence thesis by SCMFSA8C:6;
end;

registration
  let a be read-write Int-Location,I be good Program of SCM+FSA;
  cluster Times(a,I) -> good;
  coherence;
end;

theorem Th77:
  for s being State of SCM+FSA, I being good InitHalting Program
  of SCM+FSA, a being read-write Int-Location st I does not destroy a & s.a > 0
  ex s2 being State of SCM+FSA,
   p2 being Instruction-Sequence of SCM+FSA,
   k being Element of NAT st
   s2 = Initialized s &
   p2 = p +* loop if=0(a,Goto 2, I ';' SubFrom(a,intloc 0)) &
   k =
LifeSpan(p +* (if=0(a,Goto 2, I ';' SubFrom(a,intloc 0))),Initialized s)
  + 1 & Comput(p2,s2,k).a = s.a - 1 & Comput(p2,s2,k)
.intloc 0 = 1 & (for b
being read-write Int-Location st b <> a holds Comput(p2,s2,k).b =
IExec(I,p,s).
  b) & (for f being FinSeq-Location holds Comput(p2,s2,k).f =
IExec(I,p,s).f) &
IC Comput(p2,s2,k) =  0 & for n being Element of NAT st n <= k
holds IC
Comput(p2, s2,n) in dom loop if=0(a,Goto 2,I ';' SubFrom(a,
intloc 0))
proof
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
  reconsider I1 = I ';' SubFrom(a,intloc 0) as InitHalting Program of SCM+FSA;
  set P = if=0(a,Goto 2,I ';' SubFrom(a,intloc 0));
  assume
A2: s.a > 0;
  set Is = Initialized Initialized s;
  take s2 = Initialized s, p2 = p +* loop P;
  set s1 = Initialized s,
      p1 = p +* P;
  take k = LifeSpan(p1,s1) + 1;
  thus s2 = Initialized s & p2 = p +* loop P &
   k = LifeSpan(p +* (if=0(a,Goto 2, I ';'
       SubFrom(a,intloc 0))),Initialized s) + 1;
A3: Is = s +* (Initialize ((intloc 0) .--> 1) +*SA0) by FUNCT_4:93
      .= Initialize Initialized s by FUNCT_4:14;
A4: I1 is_halting_onInit s,p by Th36;
  then
A5: I1 is_halting_on Initialized s,p by Th41;
    I1 is_closed_onInit s,p by Th35;
    then
A6: IExec(P,p,s) = IExec(I1,p,s) +* Start-At((card Goto 2 + card
  I1 + 3),SCM+FSA) by A2,A4,Th46;
  then
A7: IExec(P,p,s).a = IExec(I1,p,s).a by SCMFSA_3:3;
  I1 is_closed_onInit s,p & I1 is_halting_onInit s,p by Th35,Th36;
  then
A8: P is_closed_onInit s,p & P is_halting_onInit s,p by A2,Th45;
  Comput(p2,s2,LifeSpan(p1,s1)+1) =
  Following(p2,
  Comput(p2,s2,LifeSpan(p1,s1))) by EXTPRO_1:3
    .= Exec(CurInstr(p2,
    Comput(p2,s2,LifeSpan(p1,s1))),
    Comput(p2,s2,LifeSpan(p1,s1)));
  then
A9: Comput(p2,s2,LifeSpan(p1,s1)+1) = Exec(goto  0,
Comput(p2,s2,
  LifeSpan(p1,s1))) by A8,Th71;
A10: I1 is_closed_onInit s,p & I1 is_halting_onInit s,p by Th35,Th36;
  then P is_closed_onInit s,p by A2,Th45;
  then
A11: P is_closed_on Initialized s,p by Th40;
  P is_halting_onInit s,p by A2,A10,Th45;
  then
A12: P is_halting_on Initialized s,p by Th41;
XX:  Comput(p +* P, Is,LifeSpan(p +* P,Is))
     =  Comput(p +* loop P,Is,LifeSpan(p +* P,Is))
      by A8,Th68;
  Comput(p2,s2,LifeSpan(p1,s1)+1).a
     = Comput(p +* P, Is,LifeSpan(p +* P,Is)).a by XX,A9,SCMFSA_2:69
    .= IExec(P,p,s).a by A3,A12,SCMFSA8C:58;
  hence Comput(p2,s2,k).a =
  Comput(p +* I1,
   (Initialize Initialized s), (LifeSpan(p +* I1,
   Initialize Initialized s))).a by A5,A7,SCMFSA8C:58
    .= s.a - 1 by A1,Th64;
  Comput(p2,s2,LifeSpan(p1,s1)+1).intloc 0
   = Comput(p +* P,Is,LifeSpan(p +* P,Is)).intloc 0 by XX,A9,SCMFSA_2:69
    .= 1 by A12,A11,A3,SCMFSA8C:67;
  hence Comput(p2,s2,k).intloc 0 = 1;
  hereby
    let b be read-write Int-Location;
    assume
A15: b <> a;
    thus Comput(p2,s2,k).b = Comput(p +* P, Is,LifeSpan(p +* P,Is)).b
         by XX,A9,SCMFSA_2:69
      .= IExec(P,p,s).b by A3,A12,SCMFSA8C:58
      .= IExec(I1,p,s).b by A6,SCMFSA_3:3
      .= Exec(SubFrom(a,intloc 0),IExec(I,p,s)).b by Th33
      .= IExec(I,p,s).b by A15,SCMFSA_2:65;
  end;
  hereby
    let f be FinSeq-Location;
    thus Comput(p2,s2,k).f = Comput(p +* P, Is,
    LifeSpan(p +* P,Is)).f by XX,A9,SCMFSA_2:69
      .= IExec(P,p,s).f by A3,A12,SCMFSA8C:58
      .= IExec(I1,p,s).f by A6,SCMFSA_3:4
      .= Exec(SubFrom(a,intloc 0),IExec(I,p,s)).f by Th34
      .= IExec(I,p,s).f by SCMFSA_2:65;
  end;
  thus IC Comput(p2,s2,k) =  0 by A9,SCMFSA_2:69;
A16: IC Comput(p2,s2,LifeSpan(p1,s1)+1) =  0 by A9,SCMFSA_2:69;
  hereby
    let n be Element of NAT;
    assume
A17: n <= k;
    per cases by A17,NAT_1:8;
    suppose
A18:  n <= LifeSpan(p1,s1);
A19:  I1 is_closed_onInit s,p & I1 is_halting_onInit s,p by Th35,Th36;
      then
A20:  P is_closed_onInit s,p by A2,Th45;
      P is_halting_onInit s,p by A2,A19,Th45;
      then
A21:  IC Comput(p2,s2,n) = IC Comput(p1,s1,n) by A18,A20,Th68;
      IC Comput(p1,s1,n) in dom P by A20,Def4;
      hence IC Comput(p2, s2,n) in dom loop P by A21,FUNCT_4:99;
    end;
    suppose
A22:  n = LifeSpan(p1,s1) + 1;
A23:  card P = card Goto 2 + card I1 + 4 by SCMFSA8B:11
        .= card I1 + 1 + 4 by SCMFSA8A:15
        .= card I1 + 3 + 2;
      card loop P = card dom loop P by CARD_1:62
        .= card dom P by FUNCT_4:99
        .= card P by CARD_1:62;
      hence IC Comput(p2, s2,n) in dom loop P by A16,A22,A23,AFINSQ_1:66;
    end;
  end;
end;

theorem Th78:
  for s being State of SCM+FSA, I being good InitHalting Program
of SCM+FSA, a being read-write Int-Location st s.intloc 0 = 1 & s.a <= 0 holds
  DataPart IExec(Times(a,I),p,s) = DataPart s
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.intloc 0 = 1;
  set s0 = Initialized s,
      p0 = p;
A2: Stop SCM+FSA is_closed_on s0,p0 &
   Stop SCM+FSA is_halting_on s0,p0 by SCMFSA7B:18,19;
A3: ( for a being read-write Int-Location holds s0.a = s.a)& for f being
  FinSeq-Location holds s0.f = s.f by SCMFSA6C:3;
A4: s0.intloc 0 = 1 by SCMFSA6A:38;
  assume s.a <= 0;
  then
A5: (Initialized s).a <= 0 by SCMFSA6C:3;
A6: IExec(Stop SCM+FSA ';' Stop SCM+FSA,p0,s0)
 = IncIC(IExec(Stop SCM+FSA,p0,IExec(Stop SCM+FSA,p0,s0)),card Stop SCM+FSA)
         by SCMFSA6B:20;
A7: DataPart IExec(Stop SCM+FSA,p0,s0) = DataPart(Initialized s0)
    by SCMFSA8C:14
    .= DataPart s0;
A8: Stop SCM+FSA is_closed_on Initialized s,p & Stop SCM+FSA is_halting_on
  Initialized s,p by SCMFSA7B:18,19;
  then Times(a,I) is_closed_on Initialized s,p & Times(a,I) is_halting_on
  Initialized s,p by A5,SCMFSA8B:21;
  then DataPart IExec(Times(a,I),p,s)= DataPart IExec(Times(a,I),p0,s0)
   by A4,A3,SCMFSA8C:19
    .= DataPart
     IExec(Stop SCM+FSA ';' Stop SCM+FSA,p0,s0) by A5,A2,A4,SCMFSA8A:23
,SCMFSA8C:44;
  hence DataPart IExec(Times(a,I),p,s)
   = DataPart IExec(Stop SCM+FSA,p0,IExec(Stop SCM+FSA,p0,s0))
         by A6,MEMSTR_0:79
    .= DataPart IExec(Stop SCM+FSA,p0,s0) by A8,A4,A7,SCMFSA8C:20
    .= DataPart s by A1,A7,SCMFSA8C:7;
end;

theorem Th79:
  for s being State of SCM+FSA, I being good InitHalting Program
  of SCM+FSA, a being read-write Int-Location st I does not destroy a & s.a > 0
holds IExec(I ';' SubFrom(a,intloc 0),p,s).a = s.a - 1 &
 DataPart IExec(Times(a,I),p,s)
  = DataPart IExec(Times(a,I),p,IExec(I ';' SubFrom(a,intloc 0),p,s))
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
  reconsider J3 = Macro SubFrom(a,intloc 0) as good Program of SCM+FSA;
  set I1 = I ';' SubFrom(a,intloc 0);
  set ss = IExec(I1,p,s),
      pp = p;
  I1 is_closed_onInit s,p by Th35;
  then
A2: I1 is_closed_on Initialized s,p by Th40;
  I1 is_halting_onInit s,p by Th36;
  then
A3: I1 = I ';' J3 & I1 is_halting_on Initialized s,p by Th41;
  then
A4: ss.intloc 0 = 1 by A2,SCMFSA8C:67;
  set P = if=0(a,Goto 2,I ';' SubFrom(a,intloc 0));
  set s0 = Initialized s,
      p0 = p;
  assume
A6: s.a > 0;
  then
A7: s0.a > 0 by SCMFSA6C:3;
  then consider s2 be State of SCM+FSA,
   p2 being Instruction-Sequence of SCM+FSA,
   k be Element of NAT such that
A8: s2 = Initialized s0 and
A9: p2 = p0 +* loop P and
  k = LifeSpan(p0 +* P,s0+*iS) + 1 and
A10: Comput(p2,s2,k).a = s0.a - 1 and
A11: Comput(p2,s2,k).intloc 0 = 1 and
A12: for b being read-write Int-Location st b <> a
 holds Comput(p2,s2,k).b = IExec(I,p0,s0).b and
A13: for f being FinSeq-Location holds Comput(p2,s2,k).f
         = IExec(I,p0,s0).f and
A14: IC Comput(p2,s2,k) =  0 and
A15: for n being Element of NAT st n <= k
      holds IC Comput(p2, s2,n) in dom loop P by A1,Th77;
A16:  loop P c= p2 by A9,FUNCT_4:25;
A18: now
    let f be FinSeq-Location;
    thus Comput(p2,s2,k).f = IExec(I,p0,s0).f by A13
      .= Exec(SubFrom(a,intloc 0),IExec(I,p0,s0)).f by SCMFSA_2:65
      .= IExec(I1,p0,s0).f by Th34
      .= IExec(I1,p,s).f by SCMFSA8C:3;
  end;
XX2: Initialize s0
       = s0+*iS +* SA0 by FUNCT_4:93
       .= s0+*(iS +* SA0) by FUNCT_4:14
       .=s2 by A8,FUNCT_4:93;
  thus
A19: ss.a = Exec(SubFrom(a,intloc 0),IExec(I,p,s)).a by Th33
    .= IExec(I,p,s).a - IExec(I,p,s).intloc 0 by SCMFSA_2:65
    .= IExec(I,p,s).a - 1 by Th17
    .= s0.a - 1 by A1,Th63
    .= s.a - 1 by SCMFSA6C:3;
  now
    let b be Int-Location;
    per cases;
    suppose
      b = intloc 0;
      hence Comput(p2,s2,k).b = IExec(I1,p,s).b by A11,A3,A2,SCMFSA8C:67;
    end;
    suppose
      b = a;
      hence Comput(p2,s2,k).b = IExec(I1,p,s).b by A10,A19,SCMFSA6C:3;
    end;
    suppose
A20:  b <> a & b <> intloc 0;
      then reconsider bb = b as read-write Int-Location by SF_MASTR:def 5;
      thus Comput(p2,s2,k).b = IExec(I,p0,s0).bb by A12,A20
        .= Exec(SubFrom(a,intloc 0),IExec(I,p0,s0)).b by A20,SCMFSA_2:65
        .= IExec(I1,p0,s0).b by Th33
        .= IExec(I1,p,s).b by SCMFSA8C:3;
    end;
  end;
  then
A21: DataPart Comput(p2,s2,k) = DataPart ss by A18,SCMFSA6A:7;
  set s21 = Initialize s0,
      p21 = p0 +* (loop P ';' Stop SCM+FSA);
  set ss0 = Initialized ss;
  set s31 = Initialize ss0,
      p31 = pp +* (loop P ';' Stop SCM+FSA);
   0 in dom P by SCMFSA8C:25;
  then
A22:  0 in dom loop P by FUNCT_4:99;
A23: s0.intloc 0 = 1 by SCMFSA6A:38;
  then
A24: loop P is_pseudo-closed_on s0,p0 by A1,A7,Th73;
A25: Directed loop P = loop P by SCMFSA6A:22;
  then
A26: Directed loop P is_pseudo-closed_on s0,p0 by A1,A23,A7,Th73;
A27: DataPart IExec(Times(a,I),p0,s0)
 = DataPart IExec(loop P ';' Stop SCM+FSA,
  p0,s0) by A1,A23,A7,A25,Th73,SCMFSA8C:40;
  per cases;
  suppose
A28: ss.a = 0;
A29: P. (card I1 + 3) = goto  (card I1 + 5) by SCMFSA8C:36;
A30: card I1 + (3 + 2) = card I1 + 1 + 4
      .= card Goto 2 + card I1 + 4 by SCMFSA8A:15
      .= card P by SCMFSA8B:11
      .= card dom P by CARD_1:62
      .= card dom loop P by FUNCT_4:99
      .= card loop P by CARD_1:62;
    then card I1 + 3 + 0 < card loop P by XREAL_1:6;
    then
A31:  (card I1 + 3) in dom loop P by AFINSQ_1:66;
    p2. (card I1 + 3) = (loop P). (card I1 + 3) by A31,A16,GRFUNC_1:2;
    then
A32: p2. (card I1 + 3) = goto  (card I1 + 5)
    by A29,FUNCT_4:105;
A33: p2. 0 = (loop P). 0 by A22,A16,GRFUNC_1:2;
A34: Comput(p2,s2,k+1) = Following(p2,Comput(p2,s2,k)) by EXTPRO_1:3
      .= Exec(p2.0,Comput(p2,s2,k)) by A14,PBOOLE:143;
A35: P. 0 = a =0_goto  (card I1 + 3) by SCMFSA8C:26;
A36: p2. 0 = a =0_goto  (card I1 + 3) by A33,A35,FUNCT_4:105;
    then InsCode p2. 0 = 7 by SCMFSA_2:24;
    then InsCode p2. 0 in {0,6,7,8} by ENUMSET1:def 2;
    then
A37: DataPart Comput(p2,s2,k) = DataPart Comput(p2,s2,k+1) by A34,SCMFSA8C:12;
A38: Comput(p2,s2,k).a = 0 by A10,A19,A28,SCMFSA6C:3;
    then
A39: IC Comput(p2,s2,k+1) =  (card I1 + 3) by A34,A36,SCMFSA_2:70;
D44: now
      let n be Element of NAT;
      assume
A41:  not IC Comput(p2, s2,n) in dom loop P;
      then k < n by A15;
      then k + 1 <= n by INT_1:7;
      then k + 1 < n by A39,A31,A41,XXREAL_0:1;
      then k + 1 + 1 <= n by INT_1:7;
      hence k + (1 + 1) <= n;
    end;
A42:  p2/.IC Comput(p2,s2,k+1) = p2.IC Comput(p2,s2,k+1) by PBOOLE:143;
A43: Comput(p2,s2,k+(1+1)) = Comput(p2,s2,k+1+1)
      .= Following(p2,Comput(p2,s2,k+1))
       by EXTPRO_1:3
      .= Exec(p2. (card I1 + 3),Comput(p2,s2,k+1))
    by A38,A34,A36,A42,SCMFSA_2:70;
    then
B44:  IC Comput(p0 +* loop P,Initialize s0,k+2) =  card loop P
       by A9,XX2,A30,A32,SCMFSA_2:69;
A44: k + 2 = pseudo-LifeSpan(s0,p0,loop P)
          by B44,A9,XX2,A24,D44,SCMFSA8A:def 4;
    InsCode p2. (card I1 + 3) = 6 by A32,SCMFSA_2:23;
    then InsCode p2. (card I1 + 3) in {0,6,7,8} by ENUMSET1:def 2;
    then
A45: DataPart Comput(p2,s2,k) = DataPart Comput(p2,s2,k+2)
 by A37,A43,SCMFSA8C:12;
A46:  s21 = s +* (iS +*SA0) by FUNCT_4:14
         .= Initialized s by FUNCT_4:93;
uu: s2 = s0+*(iS +* SA0) by A8,FUNCT_4:93
   .= s0+*iS +* SA0 by FUNCT_4:14
   .= s0 +* SA0 by FUNCT_4:93;
    thus DataPart IExec(Times(a,I),p,s) = DataPart IExec(Times(a,I),p0,s0) by
SCMFSA8C:3
      .= DataPart IExec(loop P ';' Stop SCM+FSA,p,s) by A27,SCMFSA8C:3
      .= DataPart Result(p21,s21) by A46,SCMFSA6B:def 1
      .= DataPart IExec(I1,p,s)
       by A21,A45,uu,A25,A1,A23,A7,Th73,A9,A44,SCMFSA8C:30
      .= DataPart IExec(Times(a,I),p,IExec(I1,p,s)) by A4,A28,Th78;
  end;
  suppose
A47: ss.a <> 0;
    s.a >= 0 + 1 by A6,INT_1:7;
    then
A48: ss.a > 0 by A19,A47,XREAL_1:19;
A50: k < pseudo-LifeSpan(s0,p0,loop P) by A15,A9,A23,XX2,A1,A7,Th73,SCMFSA8C:1;
 then
A51: DataPart Comput(p21, s21,k) = DataPart ss
      by A25,A26,A21,XX2,A9,SCMFSA8C:29;
A52: now
A53:  DataPart ss0 = DataPart ss0 +* {} by FUNCT_4:21
       .= DataPart ss0 +* DataPart SA0 by MEMSTR_0:20
       .= DataPart s31 by FUNCT_4:71;
      hereby
        let a be Int-Location;
        per cases;
        suppose
A54:      a = intloc 0;
          thus Comput(p21, s21,k).a = ss.a by A51,SCMFSA6A:7
            .= 1 by A54,Th17
            .= ss0.a by A54,SCMFSA6A:38
            .= s31.a by A53,SCMFSA6A:7;
        end;
        suppose
          a <> intloc 0;
          then
A55:      a is read-write Int-Location by SF_MASTR:def 5;
          thus Comput(p21, s21,k).a = ss.a by A51,SCMFSA6A:7
            .= ss0.a by A55,SCMFSA6C:3
            .= s31.a by A53,SCMFSA6A:7;
        end;
      end;
      let f be FinSeq-Location;
      thus Comput(p21, s21,k).f = ss.f by A51,SCMFSA6A:7
        .= ss0.f by SCMFSA6C:3
        .= s31.f by A53,SCMFSA6A:7;
    end;
B56: IC Comput(p21, s21,k) = IC Comput(p2,s2,k) by A25,A26,A50,A9,XX2,
SCMFSA8C:29
      .= IC s31 by A14,FUNCT_4:113;
A57: ss.intloc 0 = 1 by A3,A2,SCMFSA8C:67;
KK:  DataPart s0 = DataPart s0 +* {} by FUNCT_4:21
       .= DataPart s0 +* DataPart SA0 by MEMSTR_0:20
       .= DataPart s21 by FUNCT_4:71;
    Directed loop P = loop P by SCMFSA6A:22;
    then Directed loop P is_pseudo-closed_on s21,p21
           by A1,A23,A7,Th73,KK,SCMFSA8C:23;
    then
A58: loop P ';' Stop SCM+FSA is_closed_on s21,p21 & loop P ';' Stop SCM+FSA
    is_halting_on s21,p21 by SCMFSA8C:29;
A59:  s21 = s +* (iS +*SA0) by FUNCT_4:14
         .= Initialized s by FUNCT_4:93;
A60:  s31 = ss +* (iS +*SA0) by FUNCT_4:14
         .= Initialized ss by FUNCT_4:93;
A61: loop P ';' Stop SCM+FSA c= p21 & loop P ';' Stop SCM+FSA c= p31
        by FUNCT_4:25;
A62:   Result(p21,s21) =  Result(p31,s31)
     by A58,B56,A61,A52,SCMFSA8C:73,SCMFSA_2:61;
    DataPart IExec(loop P ';' Stop SCM+FSA,p0,s0) = DataPart IExec(loop P
    ';' Stop SCM+FSA,p,s) by SCMFSA8C:3
      .= DataPart Result(p21,s21) by A59,SCMFSA6B:def 1
      .= DataPart(Result(p31,s31)) by A62
      .= DataPart IExec(loop P ';' Stop SCM+FSA,p,IExec(I1,p,s))
            by A60,SCMFSA6B:def 1
      .= DataPart IExec(Times(a,I),p,IExec(I1,p,s)) by A1,A25,A57,A48,Th73,
SCMFSA8C:40;
    hence thesis by A27,SCMFSA8C:3;
  end;
end;

theorem
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, f
be FinSeq-Location,a be read-write Int-Location st s.a <= 0
 holds IExec(Times(a,I),p,s).f=s.f
proof
  set D= Data-Locations SCM+FSA;
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, f be
  FinSeq-Location,a be read-write Int-Location;
  assume
A1: s.a <= 0;
  set s0 = Initialized s,
      p0 = p;
A2: s0.a=s.a & s0.(intloc 0)=1 by SCMFSA6A:38,SCMFSA6C:3;
  f in FinSeq-Locations by SCMFSA_2:3;
  then
A3: f in D by SCMFSA_2:100,XBOOLE_0:def 3;
  DataPart IExec(Times(a,I),p,s) = DataPart IExec(Times(a,I),p0,s0)
   by SCMFSA8C:3
    .= DataPart s0 by A1,A2,Th78;
  hence IExec(Times(a,I),p,s).f= (DataPart s0).f by A3,FUNCT_1:49
    .= s0.f by A3,FUNCT_1:49
    .= s.f by SCMFSA6C:3;
end;

theorem
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, b
be Int-Location,a be read-write Int-Location st s.a <= 0
 holds IExec(Times(a,I),p,s).b=(Initialized s).b
proof
  set D= Data-Locations SCM+FSA;
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, b be
  Int-Location,a be read-write Int-Location;
  assume
A1: s.a <= 0;
  set s0 = Initialized s,
      p0 = p;
A2: s0.a=s.a & s0.(intloc 0)=1 by SCMFSA6A:38,SCMFSA6C:3;
  b in Int-Locations by SCMFSA_2:2;
  then
A3: b in D by SCMFSA_2:100,XBOOLE_0:def 3;
  DataPart IExec(Times(a,I),p,s) = DataPart IExec(Times(a,I),p0,s0)
   by SCMFSA8C:3
    .= DataPart s0 by A1,A2,Th78;
  hence IExec(Times(a,I),p,s).b= (DataPart s0).b by A3,FUNCT_1:49
    .= s0.b by A3,FUNCT_1:49;
end;

theorem
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, f
be FinSeq-Location,a be read-write Int-Location st I does not destroy a & s.a >
0 holds IExec(Times(a,I),p,s).f
 =IExec(Times(a,I),p,IExec(I ';' SubFrom(a,intloc 0),p,s)).f
proof
  set D= Data-Locations SCM+FSA;
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, f be
  FinSeq-Location,a be read-write Int-Location;
  assume
A1: I does not destroy a & s.a > 0;
  set IT=IExec(Times(a,I),p,IExec(I ';' SubFrom(a,intloc 0),p,s));
  f in FinSeq-Locations by SCMFSA_2:3;
  then
A2: f in D by SCMFSA_2:100,XBOOLE_0:def 3;
  hence IExec(Times(a,I),p,s).f=(DataPart IExec(Times(a,I),p,s)).f
   by FUNCT_1:49

    .=(DataPart IT).f by A1,Th79
    .= IT.f by A2,FUNCT_1:49;
end;

theorem
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, b
be Int-Location,a be read-write Int-Location st I does not destroy a & s.a > 0
holds IExec(Times(a,I),p,s).b
 =IExec(Times(a,I),p,IExec(I ';' SubFrom(a,intloc 0),p,s)).b
proof
  set D= Data-Locations SCM+FSA;
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, b be
  Int-Location,a be read-write Int-Location;
  assume
A1: I does not destroy a & s.a > 0;
  set IT=IExec(Times(a,I),p,IExec(I ';' SubFrom(a,intloc 0),p,s));
  b in Int-Locations by SCMFSA_2:2;
  then
A2: b in D by SCMFSA_2:100,XBOOLE_0:def 3;
  hence IExec(Times(a,I),p,s).b=(DataPart IExec(Times(a,I),p,s)).b
   by FUNCT_1:49

    .=(DataPart IT).b by A1,Th79
    .= IT.b by A2,FUNCT_1:49;
end;

definition
  let i be Instruction of SCM+FSA;
  redefine attr i is good means

  i does not destroy intloc 0;
  compatibility
   proof
     rng Macro i = {i,halt SCM+FSA} by COMPOS_1:67;
     then i in rng Macro i by TARSKI:def 2;
     then
A1:  Macro i does not destroy intloc 0 implies i does not destroy intloc 0
                   by SCMFSA7B:def 4;
A2:  i does not destroy intloc 0 implies Macro i does not destroy intloc 0
      by SCMFSA8C:48;
     Macro i is good iff i is good by SFMASTR1:def 1;
    hence i is good iff i does not destroy intloc 0 by A2,A1,SCMFSA7B:def 5;
   end;
end;

registration
  let n be Element of NAT;
  cluster intloc (n+1) -> read-write;
  coherence
  proof
    intloc (n+1) <> intloc 0 by AMI_3:10;
    hence thesis by SF_MASTR:def 5;
  end;
end;

