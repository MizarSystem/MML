:: Initialization Halting Concepts and Their Basic Properties of SCM+FSA
::  by JingChao Chen and Yatsuka Nakamura
::
:: Received June 17, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMFSA_2, FSM_1, SCMFSA6A, TARSKI,
      CIRCUIT2, RELAT_1, GLIB_000, FUNCT_1, CARD_1, FUNCOP_1, FUNCT_4,
      XBOOLE_0, SCMFSA6B, NAT_1, XXREAL_0, ARYTM_3, AMI_3, FUNCT_7, SF_MASTR,
      GRAPHSP, MSUALG_1, FINSEQ_1, AMISTD_2, TURING_1, STRUCT_0, VALUED_1,
      SCMFSA6C, SCMFSA7B, UNIALG_2, SCMFSA8B, ARYTM_1, SCMFSA8C, SCMFSA8A,
      SCM_HALT, PARTFUN1, SCMNORM, RELOC;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, RELAT_1, FINSEQ_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7, VALUED_1,
      STRUCT_0, AMI_1, SCMNORM, SCMFSA_2, FUNCOP_1, SCMFSA_4, SCMFSA6B,
      SCMFSA_5, SCMFSA6A, SF_MASTR, SCMFSA8A, SCMFSA8B, SCMFSA8C, SCMFSA7B,
      NAT_D, SCMFSA_3, SCMFSA6C, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, SCM_1, SCMFSA_3, SCMFSA_5, SCMFSA6A,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA8C, SCMNORM,
      SCMFSA_4, NAT_D, RELSET_1, VALUED_1;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SCMFSA8C, SCMFSA_9, ORDINAL1, AMI_1, RELAT_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCOP_1, AMI_1, XBOOLE_0, SCMFSA_2, SCMFSA8C, SCMFSA6A, SCMFSA_5;
 theorems SF_MASTR, FUNCT_1, FUNCT_7, FUNCOP_1, RELAT_1, AMI_1, SCMFSA6A,
      FUNCT_4, ENUMSET1, AMI_3, NAT_1, TARSKI, INT_1, GRFUNC_1, SCMFSA_2,
      SCMFSA6B, SCMFSA7B, SCMFSA8B, SCMFSA8A, SCMFSA8C, SCMFSA_4, SCMFSA_5,
      LATTICE2, SCMFSA_3, SCMFSA6C, CARD_1, FSM_1, XBOOLE_0, XBOOLE_1, XREAL_1,
      ORDINAL1, XXREAL_0, VALUED_1, XREAL_0, PBOOLE, PARTFUN1, AFINSQ_1;
 schemes NAT_1, SCMFSA6A;

begin

reserve m,n for Element of NAT,
  I for Program of SCM+FSA,
  s,s1,s2 for State of
  SCM+FSA,
  a for Int-Location,
  f for FinSeq-Location;

definition
  let I be Program of SCM+FSA;
  attr I is InitClosed means
  :Def1:
  for s being State of SCM+FSA, n being
  Element of NAT st Initialized I c= s holds IC Comput(ProgramPart(s),s,n) in
dom I;
  attr I is InitHalting means
  :Def2:
  Initialized I is halting;
  attr I is keepInt0_1 means
  :Def3:
  for s being State of SCM+FSA st
Initialized I c= s for k being Element of NAT holds (Comput(ProgramPart(s),s,k)
).intloc 0
  = 1;
end;

theorem Th1:
  for x being set,i,m,n being Element of NAT st x in dom (((intloc
  i) .--> m) +* Start-At( n,SCM+FSA)) holds x=intloc i or x=IC SCM+FSA
proof
  let x be set,i,m,n be Element of NAT;
  set iS = ((intloc i) .--> m) +* Start-At( n,SCM+FSA);
  dom ((intloc i) .--> m) ={intloc i } & dom(Start-At( n,SCM+FSA)) = {IC
  SCM+FSA} by FUNCOP_1:19;
  then
A1: dom iS ={intloc i} \/ {IC SCM+FSA} by FUNCT_4:def 1;
  assume
  x in dom iS;
  then x in{intloc i} or x in {IC SCM+FSA} by A1,XBOOLE_0:def 3;
  hence thesis by TARSKI:def 1;
end;

theorem Th2:
  for I being Program of SCM+FSA,i,m,n being Element of NAT holds
  dom I misses dom (((intloc i) .--> m) +* Start-At( n,SCM+FSA))
proof
  let I be Program of SCM+FSA,i,m,n be Element of NAT;
  set iS = ((intloc i) .--> m) +* Start-At( n,SCM+FSA);
  assume
  dom I /\ dom iS <> {};
  then consider x being set such that
A1: x in dom I /\ dom iS by XBOOLE_0:def 1;
A2: x in dom iS by A1,XBOOLE_0:def 4;
A3: x in dom I by A1,XBOOLE_0:def 4;
  dom I c= NAT by RELAT_1:def 18;
  then reconsider x as Element of NAT by A3;
  per cases by A2,Th1;
  suppose
    x = intloc i;
    hence contradiction by SCMFSA_2:84;
  end;
  suppose
    x = IC SCM+FSA;
    hence contradiction by AMI_1:48;
  end;
end;
set iS = ((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA);

canceled;

theorem Th4:
  Macro halt SCM+FSA is InitHalting
proof
  let s be State of SCM+FSA;
  set m = Macro halt SCM+FSA;
  set m1 = Initialized m;
  assume
A1: m1 c= s;
  dom(Start-At( 0,SCM+FSA)) = {IC SCM+FSA} by FUNCOP_1:19;
  then
A2: IC SCM+FSA in dom (Start-At( 0,SCM+FSA)) by TARSKI:def 1;
  then
A3: IC SCM+FSA in dom m1 by FUNCT_4:13;
A4: IC m1 = m1.IC SCM+FSA
    .= (Start-At( 0,SCM+FSA)).IC SCM+FSA by A2,FUNCT_4:14
    .=  0 by FUNCOP_1:87;
  take 0;
     IC Comput(ProgramPart(s),s,0) in NAT;
    hence IC Comput(ProgramPart(s),s,0) in dom ProgramPart s by AMI_1:143;
A5: m. 0 = halt SCM+FSA & m c= m1 by FUNCT_4:66,SCMFSA6A:26;
  dom m = { 0, 1} by FUNCT_4:65;
  then
A6:  0 in dom m by TARSKI:def 2;
  m1=m +* iS by FUNCT_4:15;
  then
A7:  0 in dom m1 by A6,FUNCT_4:13;
u: Comput(ProgramPart(s),s,0) = s by AMI_1:13;
Y:  (ProgramPart s)/.IC s
 = s.IC s by AMI_1:150;
  CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,0))
   = CurInstr(ProgramPart s,s) by u
    .= s.IC m1 by A1,A3,Y,GRFUNC_1:8
    .= m1. 0 by A1,A7,A4,GRFUNC_1:8
    .= halt SCM+FSA by A5,A6,GRFUNC_1:8;
    hence thesis;
end;

registration
  cluster InitHalting Program of SCM+FSA;
  existence by Th4;
end;

theorem Th5:
  for I being InitHalting Program of SCM+FSA st Initialized I c= s
  holds ProgramPart s halts_on s
proof
  let I be InitHalting Program of SCM+FSA;
  assume
A1: Initialized I c= s;
  Initialized I is halting by Def2;
  hence thesis by A1,AMI_1:def 26;
end;

theorem Th6:
  I +* Start-At( 0,SCM+FSA) c= Initialized I
proof
  set SA=Start-At( 0,SCM+FSA);
  SA c= Initialized I & I c= Initialized I by FUNCT_4:26,SCMFSA6A:26;
  then
A1: I \/ SA c= Initialized I by XBOOLE_1:8;
  I +* SA c= I \/ SA by FUNCT_4:30;
  hence thesis by A1,XBOOLE_1:1;
end;

theorem Th7:
  for I being Program of SCM+FSA,s being State of SCM+FSA st
  Initialized I c= s holds s.intloc 0 =1
proof
  let I be Program of SCM+FSA,s be State of SCM+FSA;
A1: intloc 0 in dom Initialized I & (Initialized I).intloc 0 = 1 by SCMFSA6A:45
,46;
  assume
  Initialized I c= s;
  hence thesis by A1,GRFUNC_1:8;
end;

registration
  cluster paraclosed -> InitClosed Program of SCM+FSA;
  coherence
  proof
    set SA=Start-At( 0,SCM+FSA);
    let I be Program of SCM+FSA;
    assume
A1: I is paraclosed;
A2: I +* SA c= Initialized I by Th6;
    for s be State of SCM+FSA, n be Element of NAT
     st Initialized I c= s
     holds IC Comput(ProgramPart(s),s,n) in dom I by A1,A2,SCMFSA6B:def 2
,XBOOLE_1:1;
    hence thesis by Def1;
  end;
end;

registration
  cluster parahalting -> InitHalting Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
    I is parahalting;
    then reconsider I as parahalting Program of SCM+FSA;
    Initialized I is halting;
    hence thesis by Def2;
  end;
end;

registration
  cluster InitHalting -> InitClosed Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    set II = Initialized I;
    assume
    I is InitHalting;
    then
A1: II is halting by Def2;
    let s be State of SCM+FSA, n be Element of NAT;
    assume
A2: Initialized I c= s;
    defpred X[Nat] means not IC Comput(ProgramPart(s),s,$1) in dom I;
    assume
    not IC Comput(ProgramPart(s),s,n) in dom I;
    then
A3: ex n be Nat st X[n];
    consider n be Nat such that
A4: X[n] and
A5: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A3);
    reconsider n as Element of NAT by ORDINAL1:def 13;
A6: for m st m < n holds IC(Comput(ProgramPart(s),s,m)) in dom I by A5;
    set s2 = Comput(ProgramPart(s),s,n), s0 = s +*(IC s2, goto IC s2), s1 = s2
+*(IC s2,
    goto IC s2);
A7: ProgramPart s = ProgramPart s2 by AMI_1:123;
A8: ProgramPart Comput(ProgramPart(s0),s0,n) = ProgramPart s0 by AMI_1:123
      .= s1|NAT by A7,FUNCT_7:95;
A10: s0,s equal_outside NAT by FUNCT_7:28,93;
A11: I c= II by SCMFSA6A:26;
    then
A12: I c= s by A2,XBOOLE_1:1;
A13: s2,s1 equal_outside NAT by FUNCT_7:93;
    II | NAT = I by SCMFSA6A:33;
    then dom I = dom II /\ NAT by RELAT_1:90;
    then not IC s2 in dom II by A4,XBOOLE_0:def 4;
    then
A14: II c= s0 by A2,FUNCT_7:91;
    then I c= s0 by A11,XBOOLE_1:1;
    then Comput(ProgramPart(s0),s0,n),s2 equal_outside NAT by A10,A12,A6,
SCMFSA6B:21;
    then
A15: Comput(ProgramPart(s0),s0,n) = s1 by A13,A8,FUNCT_7:29,92;
A16: not ProgramPart s1 halts_on s1 by SCMFSA6B:20;
    ProgramPart s0 halts_on s0 by A1,A14,AMI_1:def 26;
    then ProgramPart s0 halts_on s1 by A15,AMI_1:93;
    hence contradiction by A15,A16,AMI_1:123;
  end;
  cluster keepInt0_1 -> InitClosed Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
A17: I is keepInt0_1;
    set FI = FirstNotUsed(I);
    let s be State of SCM+FSA, n be Element of NAT;
    assume
A18: Initialized I c= s;
    defpred X[Nat] means not IC Comput(ProgramPart(s),s,$1) in dom I;
    assume
    not IC Comput(ProgramPart(s),s,n) in dom I;
    then
A19: ex n be Nat st X[n];
    consider n be Nat such that
A20: X[n] and
A21: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A19);
    reconsider n as Element of NAT by ORDINAL1:def 13;
    set s2 = Comput(ProgramPart(s),s,n), s00 = s +*(IC s2, intloc 0 := FI);
    set s0 = s00+* (FI, (s.intloc 0)+1);
    reconsider s00 as State of SCM+FSA;
    reconsider s0 as State of SCM+FSA;
A22: dom I c= NAT by RELAT_1:def 18;
    not I is keepInt0_1
    proof
A23: not FI in dom I by A22,SCMFSA_2:84;
      FI <> IC SCM+FSA by SCMFSA_2:81;
      then
A24:  not FI in {IC SCM+FSA} by TARSKI:def 1;
      set s02 = Comput(ProgramPart(s0),s0,n);
      set iIC={intloc 0} \/ {IC SCM+FSA};
      set IS = Initialized I;
      take s0;
A25:  dom IS = dom I \/ {intloc 0} \/ {IC SCM+FSA} by SCMFSA6A:43
        .= dom I \/ iIC by XBOOLE_1:4;
      FI in dom s00 by SCMFSA_2:66;
      then
A26:  s0.FI = (s.intloc 0)+1 by FUNCT_7:33;
      IC s2 <> intloc 0 by SCMFSA_2:84;
      then
A27:  not IC s2 in {intloc 0} by TARSKI:def 1;
A28:  ( not FI in UsedIntLoc I)& s.intloc 0=1 by A18,Th7,SF_MASTR:54;
      IC s2 <> IC SCM+FSA by AMI_1:48;
      then not IC s2 in {IC SCM+FSA} by TARSKI:def 1;
      then not IC s2 in iIC by A27,XBOOLE_0:def 3;
      then not IC s2 in dom IS by A20,A25,XBOOLE_0:def 3;
      then
A29:  IS c= s00 by A18,FUNCT_7:91;
      not FI in {intloc 0} by TARSKI:def 1;
      then not FI in iIC by A24,XBOOLE_0:def 3;
      then not FI in dom IS by A25,A23,XBOOLE_0:def 3;
      hence Initialized I c= s0 by A29,FUNCT_7:91;
      then
A30:  I +*Start-At( 0,SCM+FSA) c= s0 by SCMFSA6B:8;
A31:  not IC s2 in UsedInt*Loc I
      proof
        assume
        not thesis;
        then IC s2 is FinSeq-Location by SCMFSA_2:12;
        hence contradiction by SCMFSA_2:85;
      end;
      not FI in UsedInt*Loc I
      proof
        assume
        not thesis;
        then FI is FinSeq-Location by SCMFSA_2:12;
        hence contradiction by SCMFSA_2:83;
      end;
      then
A32:  s0 | UsedInt*Loc I = s00 | UsedInt*Loc I by FUNCT_7:94
        .= s | UsedInt*Loc I by A31,FUNCT_7:94;
A33:  not IC s2 in UsedIntLoc I
      proof
        assume
        not thesis;
        then IC s2 is Int-Location by SCMFSA_2:11;
        hence contradiction by SCMFSA_2:84;
      end;
A34:  s0 | UsedIntLoc I = s00 | UsedIntLoc I by FUNCT_7:94,SF_MASTR:54
        .= s | UsedIntLoc I by A33,FUNCT_7:94;
A35:  I +*Start-At( 0,SCM+FSA) c= s & for m st m < n
holds IC Comput(ProgramPart(s),s,
      m) in dom I by A18,A21,SCMFSA6B:8;
      then
A36:  IC s02 = IC s2 by A30,A34,A32,SF_MASTR:73;
      take k = n+1;
A37:  IC s2 in dom s by AMI_1:116;
      IC s2 <> FI by SCMFSA_2:84;
      then
A38:  s0.IC s2 = s00.IC s2 by FUNCT_7:34
        .= intloc 0 := FI by A37,FUNCT_7:33;
Y:  (ProgramPart s02)/.IC s02
 = s02.IC s02 by AMI_1:150;
T: ProgramPart s0 = ProgramPart s02
by AMI_1:123;
A39:  Comput(ProgramPart(s0),s0,k) = Following(ProgramPart s0,s02) by AMI_1:14
        .= Exec(intloc 0 := FI, s02) by A36,A38,Y,T,AMI_1:54;
      for m st m < n holds IC Comput(ProgramPart(s0),s0,m) in dom I by A30,A35
,A34,A32,SF_MASTR:73;
      then s02.FI = 1+1 by A30,A28,A26,SF_MASTR:69;
      hence thesis by A39,SCMFSA_2:89;
    end;
    hence contradiction by A17;
  end;
  cluster keeping_0 -> keepInt0_1 Program of SCM+FSA;
  coherence
  proof
    let I be Program of SCM+FSA;
    assume
A40: I is keeping_0;
    now
      let s be State of SCM+FSA;
      assume
A41:  Initialized I c= s;
      I +* Start-At( 0,SCM+FSA) c= Initialized I by SCMFSA8C:19;
      then
A42:  I +* Start-At( 0,SCM+FSA) c= s by A41,XBOOLE_1:1;
      s.intloc 0=1 by A41,Th7;
      hence
      for k being Element of NAT holds (Comput(ProgramPart(s),s,k)).intloc 0 =
1 by A40,A42,SCMFSA6B:def 4;
    end;
    hence thesis by Def3;
  end;
end;

theorem
  for I being InitHalting Program of SCM+FSA, a being read-write
  Int-Location holds not a in UsedIntLoc I implies (IExec(I, s)).a = s.a
proof
  let I be InitHalting Program of SCM+FSA, a be read-write Int-Location;
A1: not a in dom Initialized I by SCMFSA6A:48;
  not a in NAT by SCMFSA_2:84;
  then
  IExec(I,s) = Result(ProgramPart(s+*Initialized I),s+*Initialized I) +* s|NAT
& not a in dom (s|NAT) by RELAT_1:86,SCMFSA6B:def 1;
  then
A2: (IExec(I, s)).a = (Result(ProgramPart(s+*Initialized I),s+*Initialized I)).
a by FUNCT_4:12;
  ProgramPart(s+*Initialized I) halts_on s+*Initialized I by Th5,FUNCT_4:26;
  then consider n such that
A3: Result(ProgramPart(s+*Initialized I),s+*Initialized I) = Comput(ProgramPart
(s+*Initialized I),s+*
Initialized I,n) and
  CurInstr(ProgramPart(s+*Initialized I),
Result(ProgramPart(s+*Initialized I),s+*Initialized I))
   = halt SCM+FSA by AMI_1:def 22;
  Initialized I c= s+*Initialized I by FUNCT_4:26;
  then
A4: I+*Start-At( 0,SCM+FSA) c= s+*Initialized I & for m st m < n holds IC
  Comput(ProgramPart(s+*Initialized I),s+*Initialized I,m)in dom I by Def1,
SCMFSA6B:8;
  assume
  not a in UsedIntLoc I;
  hence (IExec(I, s)).a = (s+*Initialized I).a by A2,A3,A4,SF_MASTR:69
    .= s.a by A1,FUNCT_4:12;
end;

theorem
  for I being InitHalting Program of SCM+FSA,f being FinSeq-Location
  holds not f in UsedInt*Loc I implies (IExec(I, s)).f = s.f
proof
  let I be InitHalting Program of SCM+FSA,f be FinSeq-Location;
A1: not f in dom Initialized I by SCMFSA6A:49;
  not f in NAT by SCMFSA_2:85;
  then
  IExec(I,s) = Result(ProgramPart(s+*Initialized I),s+*Initialized I) +* s|NAT
& not f in dom (s|NAT) by RELAT_1:86,SCMFSA6B:def 1;
  then
A2: (IExec(I, s)).f = (Result(ProgramPart(s+*Initialized I),s+*Initialized I)).
f by FUNCT_4:12;
  ProgramPart(s+*Initialized I) halts_on s+*Initialized I by Th5,FUNCT_4:26;
  then consider n such that
A3: Result(ProgramPart(s+*Initialized I),s+*Initialized I) = Comput(ProgramPart
(s+*Initialized I),s+*
Initialized I,n) and
  CurInstr(ProgramPart(s+*Initialized I),
Result(ProgramPart(s+*Initialized I),s+*Initialized I))
   = halt SCM+FSA by AMI_1:def 22;
  Initialized I c= s+*Initialized I by FUNCT_4:26;
  then
A4: I+*Start-At( 0,SCM+FSA) c= s+*Initialized I & for m st m < n holds IC
  Comput(ProgramPart(s+*Initialized I),s+*Initialized I,m)in dom I by Def1,
SCMFSA6B:8;
  assume
  not f in UsedInt*Loc I;
  hence (IExec(I, s)).f = (s+*Initialized I).f by A2,A3,A4,SF_MASTR:71
    .= s.f by A1,FUNCT_4:12;
end;

registration
  let I be InitHalting Program of SCM+FSA;
  cluster Initialized I -> halting;
  coherence by Def2;
end;

registration
  cluster InitHalting -> non empty Program of SCM+FSA;
  coherence
  proof
    deffunc W(Element of NAT) = <*>INT;
    deffunc V(Element of NAT) = 1;
    deffunc U(Element of NAT) = goto  0;
    let I be Program of SCM+FSA such that
A1: I is InitHalting and
A2: I is empty;
    reconsider I as InitHalting Program of SCM+FSA by A1;
    consider S be State of SCM+FSA such that
A3: IC S =  0 and
A4: for i being Element of NAT holds S. i = U(i) & S.intloc i =
    V(i) & S.fsloc i = W(i) from SCMFSA6A:sch 1;
    intloc 0 in dom S & S.intloc 0 = 1 by A4,SCMFSA_2:66;
    then
A5: (intloc 0) .--> 1 c= S by FUNCOP_1:88;
    IC SCM+FSA in dom S by AMI_1:94;
    then
A6: IC SCM+FSA .-->  0 c= S by A3,FUNCOP_1:88;
    I c= S by A2,XBOOLE_1:2;
    then I +* ((intloc 0) .--> 1) c= S by A5,FUNCT_4:92;
    then Initialized I c= S by A6,FUNCT_4:92;
    then
A7: ProgramPart S halts_on S by AMI_1:def 26;
    S. 0 = goto  0 by A4;
    hence contradiction by A3,A7,SCMFSA6B:24;
  end;
end;

canceled 2;

theorem Th12:
  for J being InitHalting Program of SCM+FSA st Initialized J c=
  s1 for n being Element of NAT st ProgramPart Relocated(J,n) c= s2 & IC s2 =
   n & DataPart s1 = DataPart s2 for i being Element of NAT holds IC
Comput(ProgramPart(s1),s1,i) + n = IC Comput(ProgramPart(s2),s2,i) &
 IncAddr(CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,i)),n)
 = CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,i)) &
 DataPart Comput(ProgramPart(s1),s1,i) = DataPart
  Comput(ProgramPart(s2),s2,i)
proof
  let J be InitHalting Program of SCM+FSA;
  set JAt = Initialized J;
  assume
A1: JAt c= s1;
  let n be Element of NAT;
  assume that
A2: ProgramPart Relocated(J,n) c= s2 and
A3: IC s2 =  n and
A4: DataPart s1 = DataPart s2;
A5: DataPart Comput(ProgramPart(s1),s1,0) = DataPart s2 by A4,AMI_1:13
    .= DataPart Comput(ProgramPart(s2),s2,0) by AMI_1:13;
  defpred P[Nat] means IC Comput(ProgramPart(s1),s1,$1) + n = IC Comput(
ProgramPart(s2),
s2,$1) & IncAddr(CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,$1)),n)
 = CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,$1)) &
 DataPart Comput(ProgramPart(s1),s1,$1) = DataPart Comput(ProgramPart(s2),s2,$1
);
A6: J c= JAt by SCMFSA6A:26;
  then
A7: dom J c= dom JAt by GRFUNC_1:8;
A8: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
A9: Comput(ProgramPart(s1),s1,k+1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,k))
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,k)),
      Comput(ProgramPart(s1),s1,k));
    reconsider l = IC Comput(ProgramPart(s1),s1,k+1) as Element of NAT;
    reconsider j = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k+1),
    Comput(ProgramPart(s1),s1,k+1)) as Instruction of SCM+FSA;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,k+1))/.IC Comput(ProgramPart(s1),s1,
k+1)
 = Comput(ProgramPart(s1),s1,k+1).IC Comput(ProgramPart(s1),s1,k+1) by
AMI_1:150;
A10: Comput(ProgramPart(s2),s2,k+1) = Following(ProgramPart s2,
Comput(ProgramPart(s2),s2,k)) by AMI_1:14
      .= Exec(CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,k)),
      Comput(ProgramPart(s2),s2,k));
A11: IC Comput(ProgramPart(s1),s1,k+1) in dom J by A1,Def1;
    assume
A12: P[k];
    hence
A13: IC Comput(ProgramPart(s1),s1,k+1) + n = IC Comput(ProgramPart(s2),s2,k+1)
by A9,A10,SCMFSA6A:41;
    then IC Comput(ProgramPart(s2),s2,k+1) in NAT & IC Comput(ProgramPart(s2),
s2,k+1) in dom
    Relocated(J,n) by A11,SCMFSA_5:4;
    then IC Comput(ProgramPart(s2),s2,k+1) in dom Relocated(J,n) /\ NAT by
XBOOLE_0:def 4;
    then
A14: IC Comput(ProgramPart(s2),s2,k+1) in dom ProgramPart Relocated(J,n) by
RELAT_1:90;
    dom ProgramPart J = dom J /\ NAT by RELAT_1:90;
    then
A15: l in dom ProgramPart J by A11,XBOOLE_0:def 4;
Z:  (ProgramPart Comput(ProgramPart(s2),s2,k+1))/.IC Comput(ProgramPart(s2),s2,
k+1)
 = Comput(ProgramPart(s2),s2,k+1).IC Comput(ProgramPart(s2),s2,k+1) by
AMI_1:150;
TX1: ProgramPart(s1) = ProgramPart Comput(ProgramPart(s1),s1,k+1)
              by AMI_1:123;
TX2: ProgramPart(s2) = ProgramPart Comput(ProgramPart(s2),s2,k+1)
              by AMI_1:123;
    j = s1.IC Comput(ProgramPart(s1),s1,k+1) by Y,AMI_1:54
      .= (JAt).IC Comput(ProgramPart(s1),s1,k+1) by A1,A7,A11,GRFUNC_1:8
      .= J.l by A6,A11,GRFUNC_1:8;
    hence IncAddr(CurInstr(ProgramPart(s1),Comput(ProgramPart(s1),s1,k+1)),n)
     = Relocated(J,n).(l + n) by A15,TX1,SCMFSA_5:7
      .= (ProgramPart Relocated(J,n)).(IC Comput(ProgramPart(s2),s2,k+1)) by
A13,FUNCT_1:72
      .= s2.IC Comput(ProgramPart(s2),s2,k+1) by A2,A14,GRFUNC_1:8
      .= CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,k+1))
       by Z,TX2,AMI_1:54;
    thus thesis by A12,A9,A10,SCMFSA6A:41;
  end;
  ProgramPart J = J by AMI_1:105;
  then
A16:  0 in dom ProgramPart J by AFINSQ_1:69;
A17:  0 in dom J by AFINSQ_1:69;
A18: IC SCM+FSA in dom JAt by SCMFSA6A:24;
  then
A19: s1.IC s1 = s1.((JAt).IC SCM+FSA) by A1,GRFUNC_1:8
    .= s1. 0 by SCMFSA6A:46
    .= (JAt). 0 by A1,A7,A17,GRFUNC_1:8
    .= J. 0 by A6,A17,GRFUNC_1:8;
  let i be Element of NAT;
   0 in dom J by AFINSQ_1:69;
  then  0 + n in dom Relocated(J,n) by SCMFSA_5:4;
  then
A20:  (0 + n) in dom ProgramPart Relocated(J,n) by AMI_1:106;
A21: IC Comput(ProgramPart(s1),s1,0) = s1.IC SCM+FSA by AMI_1:13
    .= (JAt).IC SCM+FSA by A1,A18,GRFUNC_1:8
    .=  0 by SCMFSA6A:46;
u: Comput(ProgramPart(s1),s1,0) = s1 by AMI_1:13;
v: Comput(ProgramPart(s2),s2,0) = s2 by AMI_1:13;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by AMI_1:150;
Z:  (ProgramPart s2)/.IC s2
 = s2.IC s2 by AMI_1:150;
  IncAddr(CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,0)),n)
   = IncAddr(CurInstr(ProgramPart s1,s1),n) by u
    .= Relocated(J,n).( 0 + n) by A19,A16,Y,SCMFSA_5:7
    .= (ProgramPart Relocated(J,n)). n by FUNCT_1:72
    .= CurInstr(ProgramPart s2,s2) by A2,A3,A20,Z,GRFUNC_1:8
    .= CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,0)) by v;
  then
A22: P[0] by A3,A21,A5,AMI_1:13;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A22,A8);
  hence thesis;
end;

theorem Th13:
  Initialized I c= s implies I c= s
proof
  dom I misses dom iS by Th2;
  then
A1: Initialized I =I +* iS & I +* iS = I \/ iS by FUNCT_4:15,32;
  assume
  Initialized I c= s;
  hence thesis by A1,XBOOLE_1:11;
end;

theorem Th14:
  for I being InitHalting Program of SCM+FSA st Initialized I c=
s1 & Initialized I c= s2 & s1,s2 equal_outside NAT holds for k being Element of
  NAT holds Comput(ProgramPart(s1),s1,k), Comput(ProgramPart(s2),s2,k)
equal_outside NAT &
  CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(ProgramPart(s1),s1,k
))
   = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(s2),
s2,k))
proof
  let I be InitHalting Program of SCM+FSA;
  assume that
A1: Initialized I c= s1 and
A2: Initialized I c= s2 and
A3: s1,s2 equal_outside NAT;
A4: I c= s2 by A2,Th13;
A5: I c= s1 by A1,Th13;
  hereby
    let k be Element of NAT;
A6: IC Comput(ProgramPart(s1),s1,k) in dom I by A1,Def1;
A7: IC Comput(ProgramPart(s2),s2,k) in dom I by A2,Def1;
    for m being Element of NAT st m < k holds IC(Comput(ProgramPart(s2),s2,m))
in dom
    I by A2,Def1;
    hence Comput(ProgramPart(s1),s1,k), Comput(ProgramPart(s2),s2,k)
equal_outside NAT by A3,A5,A4,SCMFSA6B:21;
    then
A8: IC Comput(ProgramPart(s1),s1,k) = IC Comput(ProgramPart(s2),s2,k) by
AMI_1:121;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(s1),s1,k))/.IC Comput(ProgramPart(s1),s1,k)
 = Comput(ProgramPart(s1),s1,k).IC Comput(ProgramPart(s1),s1,k) by AMI_1:150;
    thus CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(
s2),s2,k))
     = s2.IC Comput(ProgramPart(s2),s2,k) by Y,AMI_1:54
      .= I.IC Comput(ProgramPart(s2),s2,k) by A4,A7,GRFUNC_1:8
      .= s1.IC Comput(ProgramPart(s1),s1,k) by A5,A8,A6,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(ProgramPart(
s1),s1,k))
      by Z,AMI_1:54;
  end;
end;

theorem Th15:
  for I being InitHalting Program of SCM+FSA st Initialized I c=
s1 & Initialized I c= s2 & s1,s2 equal_outside NAT holds LifeSpan(ProgramPart(
s1),s1) = LifeSpan(ProgramPart s2,
  s2) & Result(ProgramPart(s1),s1), Result(ProgramPart(s2),s2)
  equal_outside NAT
proof
  let I be InitHalting Program of SCM+FSA;
  assume that
A1: Initialized I c= s1 and
A2: Initialized I c= s2 and
A3: s1,s2 equal_outside NAT;
A4: ProgramPart s2 halts_on s2 by A2,Th5;
A5: ProgramPart s1 halts_on s1 by A1,Th5;
A6: now
    let l be Element of NAT;
TX: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,l)
by AMI_1:123;
    assume
A7: CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2
,l)) = halt SCM+FSA;
SX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,l)
by AMI_1:123;
    CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,l))
     = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,l),
    Comput(ProgramPart(s2),s2,l))
     by A1,A2,A3,Th14,SX;
    hence LifeSpan(ProgramPart(s1),s1) <= l by A5,A7,TX,AMI_1:def 46;
  end;
TX: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1))
by AMI_1:123;
SX: ProgramPart s1 = ProgramPart
Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1
))
by AMI_1:123;
  CurInstr(ProgramPart s2,
Comput(
ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)))
   = CurInstr(ProgramPart s1,
   Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)))
    by A1,A2,A3,Th14,TX,SX
    .= halt SCM+FSA by A5,AMI_1:def 46;
  hence
K:  LifeSpan(ProgramPart(s1),s1) = LifeSpan(ProgramPart(s2),s2) by A6,A4,
AMI_1:def 46;
  ProgramPart s2 halts_on s2 by A2,Th5;
  then
A8: Result(ProgramPart(s2),s2) = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart
(s1),s1)) by K,AMI_1:122;
  ProgramPart s1 halts_on s1 by A1,Th5;
  then
  Result(ProgramPart(s1),s1) = Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(
s1),s1)) by AMI_1:122;
  hence thesis by A1,A2,A3,A8,Th14;
end;

registration
  cluster keeping_0 InitHalting Program of SCM+FSA;
  existence
  proof
    take Macro halt SCM+FSA;
    thus thesis;
  end;
end;

registration
  cluster keepInt0_1 InitHalting Program of SCM+FSA;
  existence
  proof
    take Macro halt SCM+FSA;
    thus thesis;
  end;
end;

canceled;

theorem Th17:
  for I being keepInt0_1 InitHalting Program of SCM+FSA holds
  IExec(I, s).intloc 0 = 1
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
  not intloc 0 in NAT
  proof
A1: intloc 0 in Int-Locations by SCMFSA_2:9;
    assume
    intloc 0 in NAT;
    hence contradiction by A1,SCMFSA_2:13,XBOOLE_0:3;
  end;
  then
A2: not intloc 0 in dom(s|NAT) by RELAT_1:86;
  ProgramPart(s+*Initialized I) halts_on s+*Initialized I by Th5,FUNCT_4:26;
  then
A3: Initialized I c= s+*Initialized I & ex n st Result(ProgramPart(s+*
Initialized I),s+*Initialized I) =
  Comput(ProgramPart(s+* Initialized I),s+* Initialized I,n) &
   CurInstr(ProgramPart(s+*Initialized I),
Result(ProgramPart(s+*Initialized I),s+*Initialized I))
    = halt
  SCM+FSA by AMI_1:def 22,FUNCT_4:26;
  thus IExec(I, s).intloc 0 = (Result(ProgramPart(s+*Initialized I),s+*
Initialized I) +* s|NAT).intloc 0 by SCMFSA6B:def 1
    .= (Result(ProgramPart(s+*Initialized I),s+*Initialized I)).intloc 0 by A2,
FUNCT_4:12
    .= 1 by A3,Def3;
end;

registration
 cluster InitClosed Program of SCM+FSA;
 existence
  proof
   take the paraclosed Program of SCM+FSA;
   thus thesis;
  end;
end;

theorem Th18:
  for I being InitClosed Program of SCM+FSA, J being Program of
  SCM+FSA st Initialized I c= s & ProgramPart s halts_on s
   for m st m <= LifeSpan(ProgramPart(s),s) holds
  Comput(ProgramPart(s),s,m),Comput(ProgramPart((s+*(I ';' J))),(s+*(I ';' J)),
m) equal_outside NAT
proof
  let I be InitClosed Program of SCM+FSA, J be Program of SCM+FSA;
  assume that
A1: Initialized I c= s and
A2: ProgramPart s halts_on s;
  defpred X[Nat] means $1 <= LifeSpan(ProgramPart(s),s) implies Comput(
ProgramPart(s),s,$1),
  Comput(ProgramPart((s+*(I ';' J))),(s+*(I ';' J)),$1) equal_outside NAT;
A3: for m st X[m] holds X[m+1]
  proof
    set sx = s+*(I ';' J);
    let m;
    assume
A4: m <= LifeSpan(ProgramPart(s),s) implies Comput(ProgramPart(s),s,m), Comput(
ProgramPart((s+*
(I ';' J
    ))),(s+*(I ';' J
    )),m) equal_outside NAT;
    dom(I ';' J) = dom Directed I \/ dom ProgramPart Relocated(J, card I)
    by FUNCT_4:def 1
      .= dom I \/ dom ProgramPart Relocated(J, card I) by FUNCT_4:105;
    then
A5: I ';' J c= Comput(ProgramPart(sx),sx,m) & dom I c= dom(I ';' J) by AMI_1:81
,FUNCT_4:26,XBOOLE_1:7;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m)
by AMI_1:123;
A6: Comput(ProgramPart(s),s,m+1) =
Following(ProgramPart s,Comput(ProgramPart(s),s,m))
by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s),s,m),Comput(
ProgramPart(s),s,m)),
      Comput(ProgramPart(s),s,m)) by T;
T: ProgramPart sx = ProgramPart Comput(ProgramPart(
sx),sx,m)
by AMI_1:123;
A7: Comput(ProgramPart(sx),sx,m+1) = Following(ProgramPart sx,
Comput(ProgramPart(sx),sx,m)) by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(sx),sx,m),Comput(
ProgramPart(sx),sx,m)),
      Comput(ProgramPart(sx),sx,m)) by T;
A8: IC Comput(ProgramPart(s),s,m) in dom I by A1,Def1;
Y:  (ProgramPart Comput(ProgramPart(s),s,m))/.IC Comput(ProgramPart(s),s,m)
 = Comput(ProgramPart(s),s,m).IC Comput(ProgramPart(s),s,m) by AMI_1:150;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m)
by AMI_1:123;
    I c= Comput(ProgramPart(s),s,m) by A1,Th13,AMI_1:81;
    then
A9: CurInstr(ProgramPart s,Comput(ProgramPart(s),s,m))
 = I.IC(Comput(ProgramPart(s),s,m)) by A8,Y,TX,GRFUNC_1:8;
    assume
A10: m+1 <= LifeSpan(ProgramPart(s),s);
    then
A11: IC(Comput(ProgramPart(s),s,m)) = IC(Comput(ProgramPart(sx),sx,m)) by A4,
AMI_1:121,NAT_1:13;
Y:  (ProgramPart Comput(ProgramPart(sx),sx,m))/.IC Comput(ProgramPart(sx),sx,m)
 = Comput(ProgramPart(sx),sx,m).IC Comput(ProgramPart(sx),sx,m) by AMI_1:150;
    m < LifeSpan(ProgramPart(s),s) by A10,NAT_1:13;
    then I.IC(Comput(ProgramPart(s),s,m)) <> halt SCM+FSA by A2,A9,AMI_1:def 46
;
    then CurInstr(ProgramPart Comput(ProgramPart(s),s,m),Comput(ProgramPart(s),
s,m))
     = (I ';' J).IC(Comput(ProgramPart(s),s,m)) by A8,A9,TX,SCMFSA6A:54
      .= CurInstr(ProgramPart Comput(ProgramPart(sx),sx,m),Comput(ProgramPart(
sx),sx,m))
      by A11,A8,A5,Y,GRFUNC_1:8;
    hence thesis by A4,A10,A6,A7,NAT_1:13,SCMFSA6A:32;
  end;
  Comput(ProgramPart(s),s,0) = s & Comput(ProgramPart((s+*(I ';' J))),(s+*(I
';' J)),0) = s+*(I ';' J) by AMI_1:13;
  then
A12: X[0] by FUNCT_7:132;
  thus for m holds X[m] from NAT_1:sch 1(A12,A3);
end;

theorem Th19:
  for i,m,n being Element of NAT holds s+*I+*(((intloc i) .--> m)
  +* Start-At( n,SCM+FSA)) = s+*(((intloc i) .--> m) +*
  Start-At( n,SCM+FSA))+* I
proof
  let i,m,n be Element of NAT;
  set iS = ((intloc i) .--> m) +* Start-At( n,SCM+FSA);
A1: dom I misses dom iS by Th2;
  then I +* iS = I \/ iS by FUNCT_4:32
    .= iS +* I by A1,FUNCT_4:32;
  hence s+*I+* iS = s+*(iS+*I) by FUNCT_4:15
    .= s+*iS +*I by FUNCT_4:15;
end;

theorem Th20:
  ((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA) c= s implies
Initialized I c= s +* (I +* (((intloc 0) .--> 1) +*
Start-At( 0,SCM+FSA))) &
s +* (I +* (((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA))) = s +* I &
 s +* (I +* (((
  intloc 0) .--> 1) +* Start-At( 0,SCM+FSA))) +* Directed I =
  s +* Directed I
proof
  assume
A1: iS c= s;
  set sISA0 = s +* (I +* iS);
  I +* iS c= sISA0 by FUNCT_4:26;
  hence Initialized I c= sISA0 by FUNCT_4:15;
  thus sISA0 = s +*I +* iS by FUNCT_4:15
    .= s +* iS +*I by Th19
    .= s +* I by A1,FUNCT_4:79;
A2: dom Directed I = dom I by FUNCT_4:105;
  thus sISA0 +* Directed I = s +*I +* iS +* Directed I by FUNCT_4:15
    .= s +* iS +*I +* Directed I by Th19
    .= s +*I +* Directed I by A1,FUNCT_4:79
    .= s +*(I +* Directed I) by FUNCT_4:15
    .= s +*Directed I by A2,FUNCT_4:20;
end;

theorem Th21:
  for I being InitClosed Program of SCM+FSA
   st ProgramPart(s+*I) halts_on s+*I &
  Directed I c= s & ((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA) c= s
   holds IC
  Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +*I),s +*I) + 1) =  card I
proof
  set A = NAT;
  let I be InitClosed Program of SCM+FSA;
  assume that
A1: ProgramPart(s+*I) halts_on s+*I and
A2: Directed I c= s and
A3: iS c= s;
  set sISA0 = s +* (I +* iS);
A4: Initialized I c= sISA0 by A3,Th20;
  set IAt = I +* Start-At( 0,SCM+FSA);
  dom I misses dom Start-At( 0,SCM+FSA) by SF_MASTR:64;
  then I c= I +* Start-At( 0,SCM+FSA) by FUNCT_4:33;
  then
A5: dom I c= dom IAt by GRFUNC_1:8;
A6: sISA0 = s +* I by A3,Th20;
  reconsider sISA0 as State of SCM+FSA;
  set m = LifeSpan(ProgramPart(sISA0),sISA0);
  set l1 = IC Comput(ProgramPart( sISA0), sISA0,m);
A7: l1 in dom I by A4,Def1;
  set s2 = sISA0 +* Directed I;
A8: now
    set s1 = sISA0 +* (I ';' I);
    let k be Element of NAT;
    defpred X[Nat] means $1 <= k implies Comput(ProgramPart( s1), s1,$1),
    Comput(ProgramPart( s2), s2,$1) equal_outside A;
    assume
A9: k <= m;
A10: for n being Element of NAT st X[n] holds X[n+1]
    proof
      let n be Element of NAT;
      assume
A11:  n <= k implies Comput(ProgramPart( s1), s1,n), Comput(ProgramPart( s2),
s2,n)
      equal_outside A;
T: ProgramPart s2 = ProgramPart Comput(
ProgramPart(s2),s2,n)
by AMI_1:123;
A12:  Comput(ProgramPart( s2), s2,n + 1) = Following(ProgramPart s2,
Comput(ProgramPart(s2),s2,n)) by AMI_1:14
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,n),Comput(
ProgramPart(s2),s2,n)),
        Comput(ProgramPart( s2), s2,n)) by T;
T: ProgramPart s1 = ProgramPart Comput(
ProgramPart(s1),s1,n)
by AMI_1:123;
A13:  Comput(ProgramPart( s1), s1,n + 1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,n)) by AMI_1:14
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(
ProgramPart(s1),s1,n)),
        Comput(ProgramPart( s1), s1,n)) by T;
A14:  n <= n + 1 by NAT_1:12;
      assume
A15:  n + 1 <= k;
      then
A16:  IC Comput(ProgramPart( s1), s1,n) = IC Comput(ProgramPart( s2), s2,n) by
A11,A14,AMI_1:121,XXREAL_0:2;
      n <= k by A15,A14,XXREAL_0:2;
      then n <= m by A9,XXREAL_0:2;
      then IC Comput(ProgramPart( sISA0), sISA0,n) = IC Comput(ProgramPart( s1)
, s1,n) by A1,A4,A6,Th18,AMI_1:121;
      then
A17:  IC Comput(ProgramPart( s1), s1,n) in dom I by A4,Def1;
      then
A18:  IC Comput(ProgramPart( s2), s2,n) in dom Directed I by A16,FUNCT_4:105;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,n))/.IC Comput(ProgramPart(s2),s2,n)
 = Comput(ProgramPart(s2),s2,n).IC Comput(ProgramPart(s2),s2,n) by AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(s1),s1,n))/.IC Comput(ProgramPart(s1),s1,n)
 = Comput(ProgramPart(s1),s1,n).IC Comput(ProgramPart(s1),s1,n) by AMI_1:150;
A19:  CurInstr(ProgramPart Comput(ProgramPart(s2),s2,n),Comput(ProgramPart(s2),
s2,n))
 = s2.IC Comput(ProgramPart( s2), s2,n) by Y,AMI_1:54
        .= (Directed I).IC Comput(ProgramPart( s2), s2,n) by A18,FUNCT_4:14;
      dom I c= dom (I ';' I) & CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n
),
      Comput(ProgramPart(s1),s1,n)) = s1.IC
      Comput(ProgramPart( s1), s1,n) by Z,AMI_1:54,SCMFSA6A:56;
      then Directed I c= I ';' I & CurInstr(ProgramPart Comput(ProgramPart(s1),
s1,n),
      Comput(ProgramPart(s1),s1,n)) = (I ';' I).IC
      Comput(ProgramPart( s1), s1,n) by A17,FUNCT_4:14,SCMFSA6A:55;
      then
      CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s1),
s1,n))
       = (Directed I).IC Comput(ProgramPart( s1), s1,n) by A16,A18,GRFUNC_1:8;
      hence thesis by A11,A15,A14,A16,A19,A13,A12,SCMFSA6A:32,XXREAL_0:2;
    end;
    Comput(ProgramPart( s1), s1,0) = s1 & Comput(ProgramPart( s2), s2,0) = s2
by AMI_1:13;
    then Comput(ProgramPart( s2), s2,0), Comput(ProgramPart( s1), s1,0)
equal_outside A by FUNCT_7:107,SCMFSA6A:42;
    then
A20: X[0] by FUNCT_7:28;
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A20,A10);
    then
A21: Comput(ProgramPart(s1),s1,k), Comput(ProgramPart(s2),s2,k) equal_outside A
;
    Comput(ProgramPart( sISA0), sISA0,k), Comput(ProgramPart(s1),s1,k)
equal_outside A by A1,A4,A6,A9,Th18;
    hence Comput(ProgramPart( sISA0), sISA0,k), Comput(ProgramPart(s2),s2,k)
equal_outside A by A21,FUNCT_7:29;
  end;
  then
A22: l1 = IC Comput(ProgramPart(s2),s2,m) by AMI_1:121;
Y:  (ProgramPart Comput(ProgramPart(sISA0),sISA0,m))/.IC Comput(ProgramPart(
sISA0),sISA0,m)
 = Comput(ProgramPart(sISA0),sISA0,m).IC Comput(ProgramPart(sISA0),sISA0,m) by
AMI_1:150;
TX: ProgramPart sISA0 = ProgramPart Comput(ProgramPart(sISA0),sISA0,m)
by AMI_1:123;
  IAt c= Initialized I by Th6;
  then IAt c= sISA0 by A4,XBOOLE_1:1;
  then sISA0.l1 = (IAt).l1 by A7,A5,GRFUNC_1:8;
  then
A23: I.l1 = sISA0.l1 by A7,SCMFSA6B:7
    .=CurInstr(ProgramPart sISA0,Comput(ProgramPart(sISA0),sISA0,m))
     by Y,TX,AMI_1:54
    .= halt SCM+FSA by A1,A6,AMI_1:def 46;
  IC Comput(ProgramPart(s2),s2,m) in dom I by A8,A7,AMI_1:121;
  then IC Comput(ProgramPart(s2),s2,m) in dom Directed I by FUNCT_4:105;
  then
A24: s2.l1 = (Directed I).l1 by A22,FUNCT_4:14
    .= goto  card I by A7,A23,FUNCT_4:112;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,m))/.IC Comput(ProgramPart(s2),s2,m)
 = Comput(ProgramPart(s2),s2,m).IC Comput(ProgramPart(s2),s2,m) by AMI_1:150;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,m)
by AMI_1:123;
  Comput(ProgramPart( s2), s2,m + 1) =
  Following(ProgramPart s2,Comput(ProgramPart(s2),s2,
m))
  by AMI_1:14
    .= Exec(goto  card I,Comput(ProgramPart(s2),s2,m)) by A22,A24,Y,T,AMI_1:54;
  then
A25: IC Comput(ProgramPart( s2), s2,m + 1) =  card I by SCMFSA_2:95;
X: s +* (I +* (((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA))) = s +* I
         by A3,Th20;
  s2 = s +*Directed I by A3,Th20
    .= s by A2,FUNCT_4:79;
  hence thesis by A25,X;
end;

theorem Th22:
  for I being InitClosed Program of SCM+FSA
   st ProgramPart(s+*I) halts_on s+*I &
Directed I c= s & ((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA) c= s
 holds DataPart
Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +*I),s +*I)) = DataPart Comput
(ProgramPart( s),
s,LifeSpan(ProgramPart(s +*I),s +*I) + 1
  )
proof
  set A = NAT;
  let I be InitClosed Program of SCM+FSA;
  assume that
A1: ProgramPart(s+*I) halts_on s+*I and
A2: Directed I c= s and
A3: iS c= s;
  set sISA0 = s +* (I +* iS);
A4: Initialized I c= sISA0 by A3,Th20;
  set IAt = I +* Start-At( 0,SCM+FSA);
  dom I misses dom Start-At( 0,SCM+FSA) by SF_MASTR:64;
  then I c= I +* Start-At( 0,SCM+FSA) by FUNCT_4:33;
  then
A5: dom I c= dom IAt by GRFUNC_1:8;
A6: sISA0 = s +* I by A3,Th20;
  reconsider sISA0 as State of SCM+FSA;
  set m = LifeSpan(ProgramPart(sISA0),sISA0);
  set l1 = IC Comput(ProgramPart( sISA0), sISA0,m);
A7: l1 in dom I by A4,Def1;
  set s2 = sISA0 +* Directed I;
A8: now
    set s1 = sISA0 +* (I ';' I);
    let k be Element of NAT;
    defpred X[Nat] means $1 <= k implies Comput(ProgramPart( s1), s1,$1),
    Comput(ProgramPart( s2), s2,$1) equal_outside A;
    assume
A9: k <= m;
A10: for n being Element of NAT st X[n] holds X[n+1]
    proof
A11:  Directed I c= I ';' I by SCMFSA6A:55;
      let n be Element of NAT;
A12:  dom I c= dom (I ';' I) by SCMFSA6A:56;
      assume
A13:  n <= k implies Comput(ProgramPart( s1), s1,n), Comput(ProgramPart( s2),
s2,n)
      equal_outside A;
T: ProgramPart s2 = ProgramPart Comput(
ProgramPart(s2),s2,n)
by AMI_1:123;
A14:  Comput(ProgramPart( s2), s2,n + 1) = Following(ProgramPart s2,
Comput(ProgramPart(s2),s2,n)) by AMI_1:14
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,n),Comput(
ProgramPart(s2),s2,n)),
        Comput(ProgramPart( s2), s2,n)) by T;
T: ProgramPart s1 = ProgramPart Comput(
ProgramPart(s1),s1,n)
by AMI_1:123;
A15:  Comput(ProgramPart( s1), s1,n + 1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,n)) by AMI_1:14
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(
ProgramPart(s1),s1,n)),
        Comput(ProgramPart( s1), s1,n)) by T;
A16:  n <= n + 1 by NAT_1:12;
      assume
A17:  n + 1 <= k;
      then
A18:  IC Comput(ProgramPart( s1), s1,n) = IC Comput(ProgramPart( s2), s2,n) by
A13,A16,AMI_1:121,XXREAL_0:2;
      n <= k by A17,A16,XXREAL_0:2;
      then n <= m by A9,XXREAL_0:2;
      then IC Comput(ProgramPart( sISA0), sISA0,n) = IC Comput(ProgramPart( s1)
, s1,n) by A1,A4,A6,Th18,AMI_1:121;
      then
A19:  IC Comput(ProgramPart( s1), s1,n) in dom I by A4,Def1;
      then
A20:  IC Comput(ProgramPart( s2), s2,n) in dom Directed I by A18,FUNCT_4:105;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,n))/.IC Comput(ProgramPart(s2),s2,n)
 = Comput(ProgramPart(s2),s2,n).IC Comput(ProgramPart(s2),s2,n) by AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(s1),s1,n))/.IC Comput(ProgramPart(s1),s1,n)
 = Comput(ProgramPart(s1),s1,n).IC Comput(ProgramPart(s1),s1,n) by AMI_1:150;
A21:  CurInstr(ProgramPart Comput(ProgramPart(s2),s2,n),Comput(ProgramPart(s2),
s2,n))
 = s2.IC Comput(ProgramPart( s2), s2,n) by Y,AMI_1:54
        .= (Directed I).IC Comput(ProgramPart( s2), s2,n) by A20,FUNCT_4:14;
      CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s1),
s1,n))
       = s1.IC Comput(ProgramPart( s1), s1,n) by Z,AMI_1:54
        .= (I ';' I).IC Comput(ProgramPart( s1), s1,n) by A12,A19,FUNCT_4:14
        .= (Directed I).IC Comput(ProgramPart( s1), s1,n) by A11,A18,A20,
GRFUNC_1:8;
      hence thesis by A13,A17,A16,A18,A21,A15,A14,SCMFSA6A:32,XXREAL_0:2;
    end;
    Comput(ProgramPart( s1), s1,0) = s1 & Comput(ProgramPart( s2), s2,0) = s2
by AMI_1:13;
    then Comput(ProgramPart( s2), s2,0), Comput(ProgramPart( s1), s1,0)
equal_outside A by FUNCT_7:107,SCMFSA6A:42;
    then
A22: X[0] by FUNCT_7:28;
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A22,A10);
    then
A23: Comput(ProgramPart(s1),s1,k), Comput(ProgramPart(s2),s2,k) equal_outside A
;
    Comput(ProgramPart( sISA0), sISA0,k), Comput(ProgramPart(s1),s1,k)
equal_outside A by A1,A4,A6,A9,Th18;
    hence Comput(ProgramPart( sISA0), sISA0,k), Comput(ProgramPart(s2),s2,k)
equal_outside A by A23,FUNCT_7:29;
  end;
  then
A24: l1 = IC Comput(ProgramPart(s2),s2,m) by AMI_1:121;
Y:  (ProgramPart Comput(ProgramPart(sISA0),sISA0,m))/.IC Comput(ProgramPart(
sISA0),sISA0,m)
 = Comput(ProgramPart(sISA0),sISA0,m).IC Comput(ProgramPart(sISA0),sISA0,m) by
AMI_1:150;
TX: ProgramPart sISA0 = ProgramPart Comput(ProgramPart(sISA0),sISA0,m)
by AMI_1:123;
  IAt c= Initialized I by Th6;
  then IAt c= sISA0 by A4,XBOOLE_1:1;
  then sISA0.l1 = (IAt).l1 by A7,A5,GRFUNC_1:8;
  then
A25: I.l1 = sISA0.l1 by A7,SCMFSA6B:7
    .=CurInstr(ProgramPart sISA0,Comput(ProgramPart(sISA0),sISA0,m))
     by Y,TX,AMI_1:54
    .= halt SCM+FSA by A1,A6,AMI_1:def 46;
  IC Comput(ProgramPart(s2),s2,m) in dom I by A8,A7,AMI_1:121;
  then IC Comput(ProgramPart(s2),s2,m) in dom Directed I by FUNCT_4:105;
  then
A26: s2.l1 = (Directed I).l1 by A24,FUNCT_4:14
    .= goto  card I by A7,A25,FUNCT_4:112;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,m))/.IC Comput(ProgramPart(s2),s2,m)
 = Comput(ProgramPart(s2),s2,m).IC Comput(ProgramPart(s2),s2,m) by AMI_1:150;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart
(s2),s2,m)
by AMI_1:123;
  Comput(ProgramPart( s2), s2,m + 1) = Following(ProgramPart s2,
  Comput(ProgramPart(s2),s2,m)) by AMI_1:14
    .= Exec(goto  card I,Comput(ProgramPart(s2),s2,m)) by A24,A26,Y,T,AMI_1:54;
  then
A27: ( for a being Int-Location holds Comput(ProgramPart( s2), s2,m + 1).a =
Comput(ProgramPart( s2), s2,m). a)& for f being FinSeq-Location holds Comput(
ProgramPart( s2), s2,m + 1).f =
  Comput(ProgramPart( s2), s2,m).f by SCMFSA_2:95;
  s2 = s +*Directed I by A3,Th20
    .= s by A2,FUNCT_4:79;
  hence thesis by A6,A27,SCMFSA6A:38;
end;

theorem Th23:
  for I being InitHalting Program of SCM+FSA st Initialized I c= s
holds for k being Element of NAT st k <= LifeSpan(ProgramPart(s),s)
 holds CurInstr(ProgramPart Comput(ProgramPart(
  (s +* Directed I)),
  (s +* Directed I),k),
  Comput(ProgramPart(
  (s +* Directed I)),
  (s +* Directed I),k)) <> halt SCM+FSA
proof
  set A = NAT;
  let I be InitHalting Program of SCM+FSA;
  set s2 = s +* Directed I;
  set m = LifeSpan(ProgramPart(s),s);
  assume
A1: Initialized I c= s;
  then
A2: ProgramPart s halts_on s by AMI_1:def 26;
A3: now
    set s1 = s +* (I ';' I);
    let k be Element of NAT;
    defpred X[Nat] means $1 <= k implies Comput(ProgramPart( s1), s1,$1),
    Comput(ProgramPart( s2), s2,$1) equal_outside A;
    assume
A4: k <= m;
A5: for n being Element of NAT st X[n] holds X[n+1]
    proof
A6:   Directed I c= I ';' I by SCMFSA6A:55;
      let n be Element of NAT;
A7:   dom I c= dom (I ';' I) by SCMFSA6A:56;
      assume
A8:   n <= k implies Comput(ProgramPart( s1), s1,n), Comput(ProgramPart( s2),
s2,n)
      equal_outside A;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,n)
by AMI_1:123;
A9:   Comput(ProgramPart( s2), s2,n + 1) =
Following(ProgramPart s2,Comput(ProgramPart(s2),s2,n)
)
 by AMI_1:14
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,n),Comput(
ProgramPart(s2),s2,n)),
        Comput(ProgramPart( s2), s2,n)) by T;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,n)
by AMI_1:123;
A10:  Comput(ProgramPart( s1), s1,n + 1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,n)
)
 by AMI_1:14
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(
ProgramPart(s1),s1,n)),
        Comput(ProgramPart( s1), s1,n)) by T;
A11:  n <= n + 1 by NAT_1:12;
      assume
A12:  n + 1 <= k;
      then
A13:  IC Comput(ProgramPart( s1), s1,n) = IC Comput(ProgramPart( s2), s2,n) by
A8,A11,AMI_1:121,XXREAL_0:2;
      n <= k by A12,A11,XXREAL_0:2;
      then n <= m by A4,XXREAL_0:2;
      then IC Comput(ProgramPart(s),s,n) = IC Comput(ProgramPart( s1), s1,n)
by A1,A2,Th18,AMI_1:121;
      then
A14:  IC Comput(ProgramPart( s1), s1,n) in dom I by A1,Def1;
      then
A15:  IC Comput(ProgramPart( s2), s2,n) in dom Directed I by A13,FUNCT_4:105;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,n))/.IC Comput(ProgramPart(s2),s2,n)
 = Comput(ProgramPart(s2),s2,n).IC Comput(ProgramPart(s2),s2,n) by AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(s1),s1,n))/.IC Comput(ProgramPart(s1),s1,n)
 = Comput(ProgramPart(s1),s1,n).IC Comput(ProgramPart(s1),s1,n) by AMI_1:150;
A16:  CurInstr(ProgramPart Comput(ProgramPart(s2),s2,n),Comput(ProgramPart(s2),
s2,n))
 = s2.IC Comput(ProgramPart( s2), s2,n) by Y,AMI_1:54
        .= (Directed I).IC Comput(ProgramPart( s2), s2,n) by A15,FUNCT_4:14;
      CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s1),
s1,n))
       = s1.IC Comput(ProgramPart( s1), s1,n) by Z,AMI_1:54
        .= (I ';' I).IC Comput(ProgramPart( s1), s1,n) by A7,A14,FUNCT_4:14
        .= (Directed I).IC Comput(ProgramPart( s1), s1,n) by A6,A13,A15,
GRFUNC_1:8;
      hence thesis by A8,A12,A11,A13,A16,A10,A9,SCMFSA6A:32,XXREAL_0:2;
    end;
    Comput(ProgramPart( s1), s1,0) = s1 & Comput(ProgramPart( s2), s2,0) = s2
by AMI_1:13;
    then Comput(ProgramPart( s2), s2,0), Comput(ProgramPart( s1), s1,0)
equal_outside A by FUNCT_7:107,SCMFSA6A:42;
    then
A17: X[0] by FUNCT_7:28;
    for n being Element of NAT holds X[n] from NAT_1:sch 1(A17,A5);
    then
A18: Comput(ProgramPart(s1),s1,k), Comput(ProgramPart(s2),s2,k) equal_outside A
;
    Comput(ProgramPart(s),s,k), Comput(ProgramPart(s1),s1,k) equal_outside A
by A1,A2,A4,Th18;
    hence Comput(ProgramPart(s),s,k), Comput(ProgramPart(s2),s2,k)
equal_outside A by A18,FUNCT_7:29
;
  end;
  hereby
    let k be Element of NAT;
    set lk = IC Comput(ProgramPart(s),s,k);
A19: IC Comput(ProgramPart(s),s,k) in dom I & dom I = dom Directed I by A1,Def1
,FUNCT_4:105;
    then
A20: (Directed I).lk in rng Directed I by FUNCT_1:def 5;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by AMI_1:150;
    assume
    k <= LifeSpan(ProgramPart(s),s);
    then lk = IC Comput(ProgramPart(s2),s2,k) by A3,AMI_1:121;
    then
A21: CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(s2),
s2,k))
 = s2.lk by Y,AMI_1:54
      .= (Directed I).lk by A19,FUNCT_4:14;
    assume
    CurInstr(ProgramPart Comput(ProgramPart( (s +* Directed I)), (s +* Directed
I),k),
     Comput(ProgramPart( (s +* Directed I)), (s +* Directed I),k)) = halt
SCM+FSA;
    hence contradiction by A21,A20,SCMFSA6A:18;
  end;
end;

theorem Th24:
  for I being InitClosed Program of SCM+FSA
   st ProgramPart(s+*Initialized I) halts_on s+*Initialized I
   for J being Program of SCM+FSA, k being Element of NAT st k <=
  LifeSpan(ProgramPart(s +* Initialized I ),s +* Initialized I ) holds Comput(
ProgramPart( (s +* Initialized I)
), (s +* Initialized I),k),
  Comput(ProgramPart( (s +* Initialized (I ';' J))), (s +* Initialized (I ';' J
)),k) equal_outside NAT
proof
  let I be InitClosed Program of SCM+FSA;
  assume
A1: ProgramPart(s+*Initialized I) halts_on s+*Initialized I;
  set s1 = s +* Initialized I;
  let J be Program of SCM+FSA;
  set s2 = s +* Initialized (I ';' J);
A2: Initialized I c= s1 by FUNCT_4:26;
  defpred X[Nat] means $1 <= LifeSpan(ProgramPart(s1),s1) implies Comput(
ProgramPart( s1), s1,$1
  ), Comput(ProgramPart((s2)),(s2),$1) equal_outside NAT;
A3: Initialized (I ';' J) c= s2 by FUNCT_4:26;
A4: for m st X[m] holds X[m+1]
  proof
    dom(I ';' J) = dom Directed I \/ dom ProgramPart Relocated(J, card I)
    by FUNCT_4:def 1
      .= dom I \/ dom ProgramPart Relocated(J, card I) by FUNCT_4:105;
    then
A5: dom I c= dom(I ';' J) by XBOOLE_1:7;
    set sx = s2;
    let m;
    assume
A6: m <= LifeSpan(ProgramPart(s1),s1) implies Comput(ProgramPart(s1),s1,m),
Comput(ProgramPart((
s2)),(s2),m)
    equal_outside NAT;
    assume
A7: m+1 <= LifeSpan(ProgramPart(s1),s1);
    then
A8: IC(Comput(ProgramPart(s1),s1,m)) = IC(Comput(ProgramPart(sx),sx,m)) by A6,
AMI_1:121,NAT_1:13;
A9: I ';' J c= Comput(ProgramPart(sx),sx,m) by A3,Th13,AMI_1:81;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(
s1),s1,m)
by AMI_1:123;
A10: Comput(ProgramPart(s1),s1,m+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,m)) by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(
ProgramPart(s1),s1,m)),
      Comput(ProgramPart(s1),s1,m)) by T;
T: ProgramPart sx = ProgramPart Comput(ProgramPart(
sx),sx,m)
by AMI_1:123;
A11: Comput(ProgramPart(sx),sx,m+1) = Following(ProgramPart sx,
Comput(ProgramPart(sx),sx,m)) by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(sx),sx,m),Comput(
ProgramPart(sx),sx,m)),
      Comput(ProgramPart(sx),sx,m)) by T;
A12: IC Comput(ProgramPart(s1),s1,m) in dom I by A2,Def1;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,m))/.IC Comput(ProgramPart(s1),s1,m)
 = Comput(ProgramPart(s1),s1,m).IC Comput(ProgramPart(s1),s1,m) by AMI_1:150;
TX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m)
by AMI_1:123;
    I c= Comput(ProgramPart(s1),s1,m) by A2,Th13,AMI_1:81;
    then
A13: CurInstr(ProgramPart s1,Comput(ProgramPart(s1),
s1,m))
 = I.IC(Comput(ProgramPart(s1),s1,m)) by A12,Y,TX,GRFUNC_1:8;
Y:  (ProgramPart Comput(ProgramPart(sx),sx,m))/.IC Comput(ProgramPart(sx),sx,m)
 = Comput(ProgramPart(sx),sx,m).IC Comput(ProgramPart(sx),sx,m) by AMI_1:150;
    m < LifeSpan(ProgramPart(s1),s1) by A7,NAT_1:13;
    then I.IC(Comput(ProgramPart(s1),s1,m)) <> halt SCM+FSA by A1,A13,
AMI_1:def 46;
    then
    CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(ProgramPart(s1),s1
,m))
     = (I ';' J).IC(Comput(ProgramPart(s1),s1,m)) by A12,A13,TX,SCMFSA6A:54
      .= CurInstr(ProgramPart Comput(ProgramPart(sx),sx,m),Comput(ProgramPart(
sx),sx,m))
      by A8,A12,A9,A5,Y,GRFUNC_1:8;
    hence thesis by A6,A7,A10,A11,NAT_1:13,SCMFSA6A:32;
  end;
A14: s+*iS+*I, s+*iS equal_outside NAT & s+*iS, s+*iS+*(I ';' J)
  equal_outside NAT by FUNCT_7:28,132;
A15: s2 = s +* ((I ';' J) +* iS) by FUNCT_4:15
    .=s +* (I ';' J) +* iS by FUNCT_4:15
    .= s+*iS+*(I ';' J) by Th19;
A16: Comput(ProgramPart( s1), s1,0) = s1 & Comput(ProgramPart((s2)),(s2),0) =
s2 by AMI_1:13;
  s1 = s +* (I +* iS) by FUNCT_4:15
    .=s +* I +* iS by FUNCT_4:15
    .= s+*iS+*I by Th19;
  then
A17: X[0] by A15,A14,A16,FUNCT_7:29;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A17, A4 );
end;

theorem Th25:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA, s being State of SCM+FSA st Initialized (I ';'
  J) c= s holds IC Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +* I),s +*
I) + 1) =  card I &
DataPart Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +* I),s +* I) + 1) =
DataPart(Comput(
ProgramPart( (s +* I)
  ), (s +* I)
  ,LifeSpan(ProgramPart(s +* I),s +* I)) +* Initialized J) & ProgramPart
Relocated(J,card I) c=
Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +* I),s +* I) + 1) & Comput(
ProgramPart( s), s,
LifeSpan(ProgramPart(s +* I),s +* I) + 1).
  intloc 0 = 1 & ProgramPart s halts_on s &
   LifeSpan(ProgramPart(s),s) = LifeSpan(ProgramPart(s +* I),s +* I) + 1 +
LifeSpan(ProgramPart(
Result(ProgramPart(s +* I),s +* I) +* Initialized J),
Result(ProgramPart(s +* I),s +* I) +* Initialized J) & (J is keeping_0 implies
(Result(ProgramPart(s),s)).intloc 0
  = 1)
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s1 = s +* I;
  set s3 = Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) +*
Initialized J;
  set m1 = LifeSpan(ProgramPart(s1),s1);
  set m3 = LifeSpan(ProgramPart(s3),s3);
A1: iS c= (I ';' J) +* iS by FUNCT_4:26;
  assume
A2: Initialized (I ';' J) c= s;
  then
A3: s = s +* Initialized (I ';' J) by FUNCT_4:79;
  set s4 = Comput(ProgramPart( s), s,m1 + 1);
A4: Directed I c= I ';' J & I ';' J c= Initialized (I ';' J) by SCMFSA6A:26,55;
  reconsider m = m1 + 1 + m3 as Element of NAT;
A5: dom Directed I = dom I by FUNCT_4:105;
A6: s1 +* Directed I = s +* (I +* Directed I) by FUNCT_4:15
    .= s +* Directed I by A5,FUNCT_4:20
    .= s +* Initialized (I ';' J) +* Directed I by A2,LATTICE2:8
    .= s +* (Initialized (I ';' J) +* Directed I) by FUNCT_4:15
    .= s +* Initialized (I ';' J) by A4,LATTICE2:8,XBOOLE_1:1
    .= s by A2,LATTICE2:8;
  then
A7: Directed I c= s by FUNCT_4:26;
  Initialized J c= s3 by FUNCT_4:26;
  then dom Initialized J c= dom s3 by GRFUNC_1:8;
  then
A8: dom Initialized J c= the carrier of SCM+FSA by PARTFUN1:def 4;
A9: ProgramPart Relocated(J,card I) c= I ';' J by FUNCT_4:26;
  (I ';' J) +* iS c= s by A2,FUNCT_4:15;
  then
A10: iS c= s by A1,XBOOLE_1:1;
A11: Initialized I c= s +* I by A2,SCMFSA6A:52;
  then
A12: ProgramPart(s+*I) halts_on s+*I by Th5;
  hence
A13: IC Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +* I),s +* I) + 1) =
card I by A10,A6,Th21,FUNCT_4:26;
A14: now
    let x be set;
    assume
    x in dom DataPart Initialized J;
    then
A15: x in dom (Initialized J) /\ D by RELAT_1:90,SCMFSA_2:127;
    then
A16: x in dom Initialized J by XBOOLE_0:def 4;
A17: x in D by A15,XBOOLE_0:def 4;
    per cases by A16,SCMFSA6A:44;
    suppose
A18:  x in dom J;
      dom J c= NAT by RELAT_1:def 18;
      then reconsider l=x as Element of NAT by A18;
      (DataPart Initialized J).l = (DataPart Comput(ProgramPart(s1),s1,m1)).l
by A17,SCMFSA6A:37;
      hence (DataPart Initialized J).x = (DataPart Comput(ProgramPart(s1),s1,m1
)).x;
    end;
    suppose
A19:  x = intloc 0;
      thus (DataPart Initialized J).x = (Initialized J).x by A17,FUNCT_1:72
,SCMFSA_2:127
        .= 1 by A19,SCMFSA6A:46
        .= Comput(ProgramPart(s1),s1,m1).x by A11,A19,Def3
        .= (DataPart Comput(ProgramPart(s1),s1,m1)).x by A17,FUNCT_1:72
,SCMFSA_2:127;
    end;
    suppose
      x = IC SCM+FSA;
      hence
      (DataPart Initialized J).x = (DataPart Comput(ProgramPart(s1),s1,m1)).x
by A15,SCMFSA6A:37,XBOOLE_0:def 4;
    end;
  end;
A20: J +* Start-At( 0,SCM+FSA) c= s3 by FUNCT_4:26,SCMFSA6B:8;
A21: ProgramPart s3 halts_on s3 by Th5,FUNCT_4:26;
  dom (DataPart Initialized J) = dom Initialized J /\ D by RELAT_1:90
,SCMFSA_2:127;
  then dom (DataPart Initialized J) c= (the carrier of SCM+FSA) /\ D by A8,
XBOOLE_1:26;
  then dom (DataPart Initialized J) c= dom Comput(ProgramPart(s1),s1,m1) /\ D
by PARTFUN1:def 4;
  then dom (DataPart Initialized J) c= dom DataPart Comput(ProgramPart(s1),s1,
m1) by RELAT_1:90,SCMFSA_2:127;
  then DataPart s3 = DataPart Comput(ProgramPart(s1),s1,m1) +* DataPart(
Initialized J) &
  DataPart Initialized J c= DataPart Comput(ProgramPart(s1),s1,m1) by A14,
FUNCT_4:75,GRFUNC_1:8;
  then
A22: DataPart Comput(ProgramPart(s1),s1,m1) = DataPart s3 by LATTICE2:8;
  s +* I = s +*iS +* I by A10,FUNCT_4:79
    .= s +*I+*iS by Th19
    .= s +*(I+*iS) by FUNCT_4:15
    .= s +* Initialized I by FUNCT_4:15;
  then
X: DataPart Comput(ProgramPart(s),s,m1) = DataPart s3 by A3,A12,A22,Th24,
SCMFSA6A:39;
   ProgramPart(s +* I) halts_on s +* I by A11,Th5;
  hence
A23: DataPart Comput(ProgramPart( s), s,m1 + 1) = DataPart s3 by A10,A7,Th22,X;
  I ';' J c= Initialized (I ';' J) by SCMFSA6A:26;
  then I ';' J c= s by A2,XBOOLE_1:1;
  then ProgramPart Relocated(J,card I) c= s by A9,XBOOLE_1:1;
  then
A24: ProgramPart Relocated(J,card I) c= s4 by AMI_1:81;
  hence ProgramPart Relocated(J,card I) c= s4;
A25: intloc 0 in dom Initialized J by SCMFSA6A:45;
  intloc 0 in Int-Locations by SCMFSA_2:9;
  then
A26: intloc 0 in D by XBOOLE_0:def 3;
  hence s4.intloc 0 = (DataPart s3).intloc 0 by A23,FUNCT_1:72,SCMFSA_2:127
    .= s3.intloc 0 by A26,FUNCT_1:72,SCMFSA_2:127
    .= (Initialized J).intloc 0 by A25,FUNCT_4:14
    .= 1 by SCMFSA6A:46;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m1 + 1)
by AMI_1:123;
TTX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m)
by AMI_1:123;
x: Comput(ProgramPart(s),s,m1 + 1 + m3)
 = Comput(ProgramPart(s),Comput(ProgramPart(s),s,m1 + 1),m3)
 by AMI_1:51;
TX: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,m3)
by AMI_1:123;
A27: Initialized J c= s3 by FUNCT_4:26;
  then
  IncAddr(CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,m3)),card I)
   = CurInstr(ProgramPart s4,Comput(ProgramPart(s4),s4,m3))
    by A13,A23,A24,Th12;
  then
  IncAddr(CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,m3)),card I)
   = CurInstr(ProgramPart Comput(ProgramPart( s), s,m1 + 1 + m3),
    Comput(ProgramPart( s), s,m1 + 1 + m3)) by x,T,TX;
  then
A28: CurInstr(ProgramPart s,Comput(ProgramPart(s),s,m))
 = IncAddr (halt SCM+FSA,card I) by A21,TTX,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  hence
A29: ProgramPart s halts_on s by AMI_1:146;
A30: now
    let k be Element of NAT;
    assume
    m1 + 1 + k < m;
    then
A31: k < m3 by XREAL_1:8;
    assume
A32: CurInstr(ProgramPart ( s),
       Comput(ProgramPart( s), s,m1 + 1 + k)) = halt SCM+FSA;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s
,m1+1)
by AMI_1:123;
x: Comput(ProgramPart(s),s,m1+1+k)
 = Comput(ProgramPart(s),Comput(ProgramPart(s),s,m1+1),k) by AMI_1:51;
    IncAddr(CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,k)),card I)
     = CurInstr(ProgramPart (s4),Comput(ProgramPart(s4),s4,k))
      by A13,A23,A27,A24,Th12
      .= halt SCM+FSA by A32,x,T;
    then InsCode CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,k)) = 0
     by SCMFSA_2:124,SCMFSA_4:22;
    then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,k))
     = halt SCM+FSA by SCMFSA_2:122;
    hence contradiction by A21,A31,AMI_1:def 46;
  end;
  now
    let k be Element of NAT;
    assume
A33: k < m;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k)
by AMI_1:123;
    per cases;
    suppose
      k <= m1;
      hence CurInstr(ProgramPart s,Comput(ProgramPart(s),s,k))
       <> halt SCM+FSA by A11,A6,Th23,TX;
    end;
    suppose
      m1 < k;
      then m1 + 1 <= k by NAT_1:13;
      then consider kk being Nat such that
A34:  m1 + 1 + kk = k by NAT_1:10;
      reconsider kk as Element of NAT by ORDINAL1:def 13;
      m1+1+kk=k by A34;
      hence CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,k))
       <> halt SCM+FSA by A30,A33;
    end;
  end;
  then for k being Element of NAT st CurInstr(ProgramPart (s),
  Comput(ProgramPart(s),s,k))
   = halt SCM+FSA
  holds m <= k;
  then
A35: LifeSpan(ProgramPart(s),s) = m by A28,A29,AMI_1:def 46;
  s1 = s +* Initialized I by A2,SCMFSA6A:51;
  then Initialized I c= s1 by FUNCT_4:26;
  then
X:  ProgramPart s1 halts_on s1 by Th5;
   Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1))
     = Result(ProgramPart(s +* I),s +* I) by X,AMI_1:122;
  hence LifeSpan(ProgramPart(s),s) = LifeSpan(ProgramPart(s +* I),s +* I) + 1 +
LifeSpan(ProgramPart(Result(ProgramPart(s +* I),s +* I) +*
  Initialized J),Result(ProgramPart(s +* I),s +* I) +*
  Initialized J) by A35;
A36: Initialized J c= s3 by FUNCT_4:26;
  hereby
A37: DataPart Comput(ProgramPart( s3), s3,m3) = DataPart Comput(ProgramPart( s4
), s4,m3) by A13,A23,A27,A24,Th12;
    assume
A38: J is keeping_0;
T: ProgramPart s = ProgramPart s4
by AMI_1:123;
    thus (Result(ProgramPart(s),s)).intloc 0 = Comput(ProgramPart(s),s,m).
intloc 0 by A29,A35,AMI_1:122
      .= Comput(ProgramPart( s), s4,m3).intloc 0 by AMI_1:51
      .= Comput(ProgramPart( s3), s3,m3).intloc 0 by A37,T,SCMFSA6A:38
      .= s3.intloc 0 by A20,A38,SCMFSA6B:def 4
      .= (Initialized J).intloc 0 by A25,A36,GRFUNC_1:8
      .= 1 by SCMFSA6A:46;
  end;
end;

registration
  let I be keepInt0_1 InitHalting Program of SCM+FSA, J be InitHalting Program
  of SCM+FSA;
  cluster I ';' J -> InitHalting;
  coherence
  proof
    set D = Int-Locations \/ FinSeq-Locations;
    set JAt = Initialized J;
    let s be State of SCM+FSA;
A1: Initialized (I ';' J) = (I ';' J) +* iS by FUNCT_4:15;
    set s1 = s +* I;
    set s3 = Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) +* JAt;
    set m1 = LifeSpan(ProgramPart(s1),s1);
    set s4 = Comput(ProgramPart( s), s,m1 + 1);
A2: ProgramPart Relocated(J,card I) c= I ';' J by FUNCT_4:26;
A3: dom I misses dom iS by Th2;
    set m3 = LifeSpan(ProgramPart(s3),s3);
A4: dom DataPart JAt = dom JAt /\ D by RELAT_1:90,SCMFSA_2:127;
    reconsider m = m1 + 1 + m3 as Element of NAT;
A5: dom Directed I = dom I by FUNCT_4:105;
    assume
A6: Initialized (I ';' J) c= s;
    then
A7: s = s +* Initialized (I ';' J) by FUNCT_4:79;
    dom (I ';' J) misses dom iS by Th2;
    then
A8: I ';' J c= Initialized (I ';' J) by A1,FUNCT_4:33;
    then I ';' J c= s by A6,XBOOLE_1:1;
    then ProgramPart Relocated(J,card I) c= s by A2,XBOOLE_1:1;
    then
A9: JAt c= s3 & ProgramPart Relocated(J,card I) c= s4 by AMI_1:81,FUNCT_4:26;
    iS c= (I ';' J) +* iS by FUNCT_4:26;
    then
A10: iS c= s by A6,A1,XBOOLE_1:1;
    then s +*iS = s by FUNCT_4:79;
    then
A11: s +* I = s +*(iS +* I) by FUNCT_4:15
      .=s +*(I +* iS) by A3,FUNCT_4:36
      .=s +* Initialized I by FUNCT_4:15;
    then
A12: ProgramPart(s+*I) halts_on s+*I by Th5,FUNCT_4:26;
A13: Initialized I c= s +* I by A11,FUNCT_4:26;
A14: now
      let x be set;
      assume
      x in dom DataPart JAt;
      then
A15:  x in dom (JAt) /\ D by RELAT_1:90,SCMFSA_2:127;
      then
A16:  x in dom JAt by XBOOLE_0:def 4;
A17:  x in D by A15,XBOOLE_0:def 4;
      per cases by A16,SCMFSA6A:44;
      suppose
A18:    x in dom J;
        dom J c= NAT by RELAT_1:def 18;
        then reconsider l=x as Element of NAT by A18;
        (DataPart JAt).l = (DataPart Comput(ProgramPart(s1),s1,m1)).l by A17,
SCMFSA6A:37;
        hence (DataPart JAt).x = (DataPart Comput(ProgramPart(s1),s1,m1)).x;
      end;
      suppose
A19:    x=intloc 0;
        then x in Int-Locations by SCMFSA_2:9;
        then
A20:    x in D by XBOOLE_0:def 3;
        hence (DataPart Comput(ProgramPart(s1),s1,m1)).x=Comput(ProgramPart(s1)
,s1,m1).x by FUNCT_1:72,SCMFSA_2:127
          .=1 by A13,A19,Def3
          .=JAt.x by A19,SCMFSA6A:46
          .=(DataPart JAt).x by A20,FUNCT_1:72,SCMFSA_2:127;
      end;
      suppose
        x = IC SCM+FSA;
        hence (DataPart JAt).x = (DataPart Comput(ProgramPart(s1),s1,m1)).x by
A15,SCMFSA6A:37,XBOOLE_0:def 4;
      end;
    end;
    take m;
     IC Comput(ProgramPart(s),s,m) in NAT;
    hence IC Comput(ProgramPart(s),s,m) in dom ProgramPart s by AMI_1:143;
A21: Directed I c= I ';' J by SCMFSA6A:55;
A22: s1 +* Directed I = s +* (I +* Directed I) by FUNCT_4:15
      .= s +* Directed I by A5,FUNCT_4:20
      .= s +* Initialized (I ';' J) +* Directed I by A6,LATTICE2:8
      .= s +* (Initialized (I ';' J) +* Directed I) by FUNCT_4:15
      .= s +* Initialized (I ';' J) by A21,A8,LATTICE2:8,XBOOLE_1:1
      .= s by A6,LATTICE2:8;
    then
A23: Directed I c= s by FUNCT_4:26;
A24: JAt c= s3 by FUNCT_4:26;
    then dom JAt c= dom s3 by GRFUNC_1:8;
    then dom JAt c= the carrier of SCM+FSA by PARTFUN1:def 4;
    then dom DataPart JAt c= (the carrier of SCM+FSA) /\ D by A4,XBOOLE_1:26;
    then dom DataPart JAt c= dom Comput(ProgramPart(s1),s1,m1) /\ D by
PARTFUN1:def 4;
    then dom DataPart JAt c= dom (DataPart Comput(ProgramPart(s1),s1,m1)) by
RELAT_1:90,SCMFSA_2:127;
    then DataPart s3 = DataPart Comput(ProgramPart(s1),s1,m1) +* DataPart JAt &
DataPart
    JAt c= DataPart Comput(ProgramPart(s1),s1,m1) by A14,FUNCT_4:75,GRFUNC_1:8;
    then DataPart Comput(ProgramPart(s1),s1,m1) = DataPart s3 by LATTICE2:8;
    then
X:   DataPart Comput(ProgramPart(s),s,m1) = DataPart s3 by A7,A11,A12,Th24,
SCMFSA6A:39;
    ProgramPart(s +* I) halts_on s +* I by A13,Th5;
    then
A25: DataPart Comput(ProgramPart( s), s,m1 + 1) = DataPart s3 by A10,A23,Th22,X
;
T: ProgramPart s = ProgramPart Comput(ProgramPart
(s),s,m1 + 1)
by AMI_1:123;
x: Comput(ProgramPart(s),s,m1 + 1 + m3)
 = Comput(ProgramPart(s),Comput(ProgramPart(s),s,m1 + 1),m3)
 by AMI_1:51;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m)
by AMI_1:123;
    IC Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +* I),s +* I) + 1) =
card I by A10,A12,A22,Th21,FUNCT_4:26;
    then
     IncAddr(CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,m3)),card I)
     = CurInstr(ProgramPart (s4),Comput(ProgramPart(s4),s4,m3))
      by A25,A9,Th12;
    then
A26: IncAddr(CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,m3)),card I)
 = CurInstr(ProgramPart Comput(ProgramPart(s),s,m1 + 1 + m3),
  Comput(ProgramPart(s),s,m1 + 1 + m3)) by x,T,TX;
    ProgramPart s3 halts_on s3 by A24,AMI_1:def 26;
    then CurInstr(ProgramPart s,Comput(ProgramPart(s),
s,m))
     = IncAddr (halt SCM+FSA,card I) by A26,TX,AMI_1:def 46
      .= halt SCM+FSA by SCMFSA_4:8;
    hence thesis;
  end;
end;

theorem Th26:
  for I being keepInt0_1 Program of SCM+FSA st ProgramPart(s+*I) halts_on s+*I
  for J being InitClosed Program of SCM+FSA st Initialized (I ';' J) c= s for k
being Element of NAT holds Comput(ProgramPart( (Result(ProgramPart(s +*I),s +*I
) +* Initialized J
)), (Result(ProgramPart(s +*I),s +*I) +* Initialized J ),k) +*
  Start-At (IC Comput(ProgramPart( (
  Result(ProgramPart(s +*I),s +*I) +* Initialized J )), (
  Result(ProgramPart(s +*I),s +*I) +* Initialized J ),k) + card I,SCM+FSA),
  Comput(ProgramPart( (s +* (I ';' J))), (s +* (I ';' J)),LifeSpan(ProgramPart(
s +* I),s +* I)+1+k
) equal_outside NAT
proof
  set SA0 = Start-At( 0,SCM+FSA);
  let I be keepInt0_1 Program of SCM+FSA;
  assume
A1: ProgramPart(s+*I) halts_on s+*I;
  set ISA0 = Initialized I;
  let J be InitClosed Program of SCM+FSA;
  set sISA0 = s +* ISA0;
  set RI = Result(ProgramPart(s +* ISA0),s +* ISA0);
  set JSA0 = Initialized J;
  set RIJ = RI +* JSA0;
  set sIJSA0 = s +* Initialized (I ';' J);
  defpred X[Nat] means Comput(ProgramPart( RIJ), RIJ,$1) +* Start-At (IC
  Comput(ProgramPart( RIJ), RIJ,$1) + card I,SCM+FSA),
  Comput(ProgramPart( sIJSA0), sIJSA0,LifeSpan(ProgramPart(sISA0),sISA0)+1+$1)
  equal_outside NAT;
  assume
  Initialized (I ';' J) c= s;
  then
A2: s = sIJSA0 by FUNCT_4:79;
A3: sIJSA0 = s +* ((I ';' J) +* iS) by FUNCT_4:15
    .= s +*(I ';' J) +* iS by FUNCT_4:15;
  then
A4: sIJSA0 = s +*iS +*(I ';' J) by Th19;
  then
A5: (I ';' J) c= s by A2,FUNCT_4:26;
A6: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT;
    set k1 = k+1;
    set CRk = Comput(ProgramPart( RIJ), RIJ,k);
    set CRSk = CRk +* Start-At (IC CRk + card I,SCM+FSA);
    set CIJk = Comput(ProgramPart( sIJSA0), sIJSA0,LifeSpan(ProgramPart(sISA0),
sISA0)+1+k);
    set CRk1 = Comput(ProgramPart( RIJ), RIJ,k1);
    set CRSk1 = CRk1 +* Start-At (IC CRk1 + card I,SCM+FSA);
    set CIJk1 = Comput(ProgramPart( sIJSA0), sIJSA0,LifeSpan(ProgramPart(sISA0)
,sISA0)+1+k1);
    assume
A7: Comput(ProgramPart( RIJ), RIJ,k) +* Start-At (IC Comput(ProgramPart( RIJ),
RIJ,k) + card I,SCM+FSA)
    , Comput(ProgramPart( sIJSA0), sIJSA0,LifeSpan(ProgramPart(sISA0),sISA0)+1+
k) equal_outside NAT
;
A8: IncAddr(CurInstr(ProgramPart CRk,CRk), card I)
 = CurInstr(ProgramPart CIJk,CIJk)
    proof
      RIJ = RI +*( J +* iS) by FUNCT_4:15
        .= RI +* J +* iS by FUNCT_4:15
        .= RI +* iS +* J by Th19;
      then
A9:   J c= CRk by AMI_1:81,FUNCT_4:26;
      ProgramPart Relocated(J, card I) c= I ';' J by FUNCT_4:26;
      then
A10:  ProgramPart Relocated(J, card I) c= sIJSA0 by A2,A5,XBOOLE_1:1;
Y:  (ProgramPart CIJk)/.IC CIJk
 = CIJk.IC CIJk by AMI_1:150;
A11:  CurInstr(ProgramPart CIJk,CIJk) = CIJk.IC CRSk by A7,Y,AMI_1:121
        .= CIJk.(IC CRk + card I) by FUNCT_4:121;
      reconsider ii = IC CRk as Element of NAT;
A12:  ProgramPart Relocated(J, card I)
         = Reloc(ProgramPart(J),card I) by SCMFSA_5:2
        .= Reloc(J, card I) by AMI_1:105
        .= Shift(IncAddr(J, card I), card I) by SCMFSA_4:35;
      JSA0 c= RIJ by FUNCT_4:26;
      then
A13:  IC CRk in dom J by Def1;
      then
A14:  ii in dom IncAddr(J, card I) by SCMFSA_4:def 6;
      then
A15:  Shift(IncAddr(J, card I), card I).(IC CRk + card I) = IncAddr(J,
      card I).ii by VALUED_1:def 12
        .= IncAddr(J/.ii, card I) by A13,SCMFSA_4:24;
      dom Shift(IncAddr(J, card I), card I) = { il+card I where il is
      Element of NAT: il in dom IncAddr(J, card I)} by VALUED_1:def 12;
      then
A16:  IC CRk + card I in dom Shift(IncAddr(J, card I), card I) by A14;
Y:  (ProgramPart CRk)/.IC CRk
 = CRk.IC CRk by AMI_1:150;
      J/.ii = J.IC CRk by A13,PARTFUN1:def 8
        .= CRk.IC CRk by A13,A9,GRFUNC_1:8;
      hence
      IncAddr(CurInstr(ProgramPart CRk,CRk), card I)
       = sIJSA0.(IC CRk + card I) by A15,A10,A12,A16,Y,GRFUNC_1:8
        .= CurInstr(ProgramPart CIJk,CIJk) by A11,AMI_1:54;
    end;
    CIJk, CRSk equal_outside NAT by A7,FUNCT_7:28;
    then Exec(CurInstr(ProgramPart CIJk,CIJk), CIJk),
     Exec(IncAddr(CurInstr(ProgramPart CRk,CRk),card I), CRSk)
    equal_outside NAT by A8,SCMFSA6A:32;
    then
A17: Exec(CurInstr(ProgramPart CIJk,CIJk), CIJk),
Following(ProgramPart CRk,CRk) +* Start-At (IC
Following(ProgramPart CRk,CRk) + card I,SCM+FSA)
equal_outside NAT by SCMFSA_4:28;
T: ProgramPart sIJSA0 = ProgramPart CIJk
by AMI_1:123;
    CIJk1 = Comput(ProgramPart( sIJSA0), sIJSA0,LifeSpan(ProgramPart(sISA0),
sISA0)+1+k+1);
    then
A18: CIJk1 = Following(ProgramPart sIJSA0,CIJk) by AMI_1:14;
A19: now
      let a be Int-Location;
S: ProgramPart RIJ = ProgramPart CRk
by AMI_1:123;
      thus CRSk1.a = CRk1.a by SCMFSA_3:11
        .= (Following(ProgramPart RIJ,CRk)).a by AMI_1:14
        .= (Following(ProgramPart CRk,CRk) +*
        Start-At (IC Following(ProgramPart CRk,CRk) + card I,SCM+FSA)).a
        by S,SCMFSA_3:11
        .= CIJk1.a by A18,A17,T,SCMFSA6A:30;
    end;
A20: now
      let f be FinSeq-Location;
S: ProgramPart RIJ = ProgramPart CRk
by AMI_1:123;
      thus CRSk1.f = CRk1.f by SCMFSA_3:12
        .= (Following(ProgramPart RIJ,CRk)).f by AMI_1:14
        .= (Following(ProgramPart CRk,CRk) +* Start-At (
        IC Following(ProgramPart CRk,CRk) + card I,SCM+FSA)).f
         by S,SCMFSA_3:12
        .= CIJk1.f by A18,A17,T,SCMFSA6A:31;
    end;
S: ProgramPart RIJ = ProgramPart CRk
by AMI_1:123;
    IC CRSk1 = IC CRk1 + card I by FUNCT_4:121
      .= IC Following(ProgramPart RIJ,CRk) + card I by AMI_1:14;
    then
    IC CRSk1 =
     IC (Following(ProgramPart CRk,CRk) +* Start-At (IC
     Following(ProgramPart CRk,CRk) + card I
    ,SCM+FSA)) by S,FUNCT_4:121
      .= IC CIJk1 by A18,A17,T,AMI_1:121;
    hence thesis by A19,A20,SCMFSA6A:28;
  end;
A21: iS c= s by A2,A3,FUNCT_4:26;
  then
A22: sIJSA0 = s +* (I ';' J) by A4,FUNCT_4:79;
A23: sISA0 = s +*(I +*iS) by FUNCT_4:15
    .= s +* I +*iS by FUNCT_4:15
    .= s +* iS +*I by Th19
    .= s +* I by A21,FUNCT_4:79;
  Directed I c= I ';' J by SCMFSA6A:55;
  then
A24: Directed I c= s by A5,XBOOLE_1:1;
A25: ISA0 c= sISA0 by FUNCT_4:26;
A26: now
    set s2 = Comput(ProgramPart( sIJSA0), sIJSA0,LifeSpan(ProgramPart(sISA0),
sISA0)+1+0);
    set s1 = RIJ +* Start-At (IC RIJ + card I,SCM+FSA);
    thus IC s1 = IC RIJ + card I by FUNCT_4:121
      .= IC (RI +* (J +*(intloc 0 .--> 1)) +* SA0) + card I by FUNCT_4:15
      .=  0 + card I by FUNCT_4:121
      .= IC s2 by A1,A2,A3,A24,A23,Th21,FUNCT_4:26;
A27: DataPart Comput(ProgramPart(s),s,LifeSpan(ProgramPart(sISA0),sISA0)) =
DataPart Comput(
ProgramPart( s), s,
    LifeSpan(ProgramPart(sISA0),sISA0)+1) by A1,A2,A3,A24,A23,Th22,FUNCT_4:26;
    hereby
      let a be Int-Location;
      not a in dom Start-At (IC RIJ + card I,SCM+FSA) by SCMFSA6B:9;
      then
A28:  s1.a = RIJ.a by FUNCT_4:12;
A29:  Comput(ProgramPart( sISA0), sISA0,LifeSpan(ProgramPart(sISA0),sISA0)).a =
Comput(ProgramPart(
sIJSA0), sIJSA0,LifeSpan(ProgramPart sISA0,
      sISA0)).a by A1,A23,Th24,SCMFSA6A:30
        .= s2.a by A2,A27,SCMFSA6A:38;
      per cases;
      suppose
        a <> intloc 0;
        then not a in dom JSA0 by SCMFSA6A:48;
        hence s1.a = RI.a by A28,FUNCT_4:12
          .= s2.a by A1,A23,A29,AMI_1:122;
      end;
      suppose
A30:    a = intloc 0;
        then a in dom JSA0 by SCMFSA6A:45;
        hence s1.a = JSA0.a by A28,FUNCT_4:14
          .=1 by A30,SCMFSA6A:46
          .=s2.a by A25,A29,A30,Def3;
      end;
    end;
    let f be FinSeq-Location;
A31: not f in dom JSA0 by SCMFSA6A:49;
    not f in dom Start-At (IC RIJ + card I,SCM+FSA) by SCMFSA6B:10;
    hence s1.f = RIJ.f by FUNCT_4:12
      .= RI.f by A31,FUNCT_4:12
      .= Comput(ProgramPart( sISA0), sISA0,LifeSpan(ProgramPart(sISA0),sISA0)).
f by A1,A23,AMI_1:122
      .= Comput(ProgramPart( sIJSA0), sIJSA0,LifeSpan(ProgramPart(sISA0),sISA0)
).f by A1,A23,Th24,SCMFSA6A:31
      .= s2.f by A2,A27,SCMFSA6A:38;
  end;
  Comput(ProgramPart( RIJ), RIJ,0) = RIJ by AMI_1:13;
  then
A32: X[0] by A26,SCMFSA6A:28;
  for k being Element of NAT holds X[k] from NAT_1:sch 1(A32, A6);
  hence thesis by A23,A22;
end;

theorem Th27:
  for I being keepInt0_1 Program of SCM+FSA
   st not ProgramPart(s+*Initialized I) halts_on s+*Initialized I
 for J being Program of SCM+FSA, k being Element of NAT
  holds Comput(ProgramPart( (s +* Initialized I)), (s +* Initialized I),k),
Comput(ProgramPart( (s +* Initialized (I
  ';' J))), (s +* Initialized (I
  ';' J)),k) equal_outside NAT
proof
  let I be keepInt0_1 Program of SCM+FSA;
  assume
A1: not ProgramPart(s+*Initialized I) halts_on s+*Initialized I;
  set s1 = s +* Initialized I;
  let J be Program of SCM+FSA;
A2: Initialized I c= s1 by FUNCT_4:26;
  set s2 = s +* Initialized (I ';' J);
  defpred X[Nat] means Comput(ProgramPart( s1), s1,$1), Comput(ProgramPart((s2)
),(s2),$1)
  equal_outside NAT;
A3: Initialized (I ';' J) c= s2 by FUNCT_4:26;
A4: for m st X[m] holds X[m+1]
  proof
    dom(I ';' J) = dom Directed I \/ dom ProgramPart Relocated(J, card I)
    by FUNCT_4:def 1
      .= dom I \/ dom ProgramPart Relocated(J, card I) by FUNCT_4:105;
    then
A5: dom I c= dom(I ';' J) by XBOOLE_1:7;
    set sx = s2;
    let m;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(
s1),s1,m)
by AMI_1:123;
A6: Comput(ProgramPart(s1),s1,m+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,m)) by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(
ProgramPart(s1),s1,m)),
      Comput(ProgramPart(s1),s1,m)) by T;
T: ProgramPart sx = ProgramPart Comput(ProgramPart(
sx),sx,m)
by AMI_1:123;
A7: Comput(ProgramPart(sx),sx,m+1) = Following(ProgramPart sx,
Comput(ProgramPart(sx),sx,m)) by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(sx),sx,m),Comput(
ProgramPart(sx),sx,m)),
      Comput(ProgramPart(sx),sx,m)) by T;
    assume
A8: Comput(ProgramPart(s1),s1,m), Comput(ProgramPart((s2)),(s2),m)
equal_outside NAT;
    then
A9: IC(Comput(ProgramPart(s1),s1,m)) = IC(Comput(ProgramPart(sx),sx,m)) by
AMI_1:121;
A10: I ';' J c= Comput(ProgramPart(sx),sx,m) by A3,Th13,AMI_1:81;
A11: IC Comput(ProgramPart(s1),s1,m) in dom I by A2,Def1;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,m))/.IC Comput(ProgramPart(s1),s1,m)
 = Comput(ProgramPart(s1),s1,m).IC Comput(ProgramPart(s1),s1,m) by AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(sx),sx,m))/.IC Comput(ProgramPart(sx),sx,m)
 = Comput(ProgramPart(sx),sx,m).IC Comput(ProgramPart(sx),sx,m) by AMI_1:150;
TX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m)
by AMI_1:123;
    I c= Comput(ProgramPart(s1),s1,m) by A2,Th13,AMI_1:81;
    then
A12: CurInstr(ProgramPart s1,Comput(ProgramPart(s1),
s1,m))
 = I.IC(Comput(ProgramPart(s1),s1,m)) by A11,Y,TX,GRFUNC_1:8;
    then I.IC(Comput(ProgramPart(s1),s1,m)) <> halt SCM+FSA by A1,AMI_1:146;
    then
    CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(ProgramPart(s1),s1
,m))
     = (I ';' J).IC(Comput(ProgramPart(s1),s1,m)) by A11,A12,TX,SCMFSA6A:54
      .= CurInstr(ProgramPart Comput(ProgramPart(sx),sx,m),Comput(ProgramPart(
sx),sx,m))
      by A9,A11,A10,A5,Z,GRFUNC_1:8;
    hence thesis by A8,A6,A7,SCMFSA6A:32;
  end;
A13: Comput(ProgramPart( s1), s1,0) = s1 & Comput(ProgramPart((s2)),(s2),0) =
s2 by AMI_1:13;
A14: s+*iS+*I, s+*iS equal_outside NAT & s+*iS, s+*iS+*(I ';' J)
  equal_outside NAT by FUNCT_7:28,132;
A15: s2 = s +* ((I ';' J) +* iS) by FUNCT_4:15
    .= s +* (I ';' J) +* iS by FUNCT_4:15
    .= s+* iS +*(I ';' J) by Th19;
  s1 = s +* (I +* iS) by FUNCT_4:15
    .= s +* I +* iS by FUNCT_4:15
    .= s+*iS+*I by Th19;
  then
A16: X[0] by A15,A14,A13,FUNCT_7:29;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A16, A4 );
end;

theorem Th28:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
  InitHalting Program of SCM+FSA holds LifeSpan(ProgramPart(s +* Initialized (I
';' J)),s +* Initialized (I ';' J)) =
  LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) + 1 + LifeSpan(
ProgramPart(Result(ProgramPart(s +* Initialized I),s +* Initialized I) +*
  Initialized J),Result(ProgramPart(s +* Initialized I),s +* Initialized I) +*
  Initialized J)
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  set inI=Initialized I;
  set inIJ=Initialized (I ';' J);
  set inJ=Initialized J;
A1: inJ c= Result(ProgramPart(s +* inIJ +* I),s +* inIJ +* I) +* inJ & inJ c=
Result(ProgramPart(s +* inI),s +* inI) +* inJ
  by FUNCT_4:26;
  s +* inIJ, s +* inIJ +* I equal_outside NAT & s +* inI, s +* inIJ
  equal_outside NAT by FUNCT_7:132,SCMFSA6A:53;
  then
A2: s +* inI, s +* inIJ +* I equal_outside NAT by FUNCT_7:29;
A3: inI c= s +* inI & inI c= s +* inIJ +* I by FUNCT_4:26,SCMFSA6A:52;
  then Result(ProgramPart(s +* inI),s +* inI), Result(ProgramPart(s +* inIJ +*
I),s +* inIJ +* I) equal_outside NAT by A2,Th15;
  then Result(ProgramPart(s +* inIJ +* I),s +* inIJ +* I), Result(ProgramPart(s
+* inI),s +* inI) equal_outside NAT by FUNCT_7:28;
  then
A4: Result(ProgramPart(s +* inIJ +* I),s +* inIJ +* I) +* inJ, Result(
ProgramPart(s +* inI),s +* inI) +* inJ equal_outside
  NAT by FUNCT_7:106;
  inIJ c= s +* inIJ by FUNCT_4:26;
  then
A5: LifeSpan(ProgramPart(s +* inIJ),s +* inIJ) = LifeSpan(ProgramPart(s +* inIJ
+* I),s +* inIJ +* I) + 1 + LifeSpan(ProgramPart(Result(ProgramPart(s +* inIJ
+* I),s +* inIJ +* I) +* inJ),Result(ProgramPart(s +* inIJ +* I),s +* inIJ +* I
) +* inJ) by Th25;
  LifeSpan(ProgramPart(s +* inI),s +* inI) = LifeSpan(ProgramPart(s +* inIJ +*
I),s +* inIJ +* I) by A3,A2,Th15;
  hence thesis by A5,A1,A4,Th15;
end;

theorem Th29:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds IExec(I ';' J,s) = IExec(J,IExec(I,s)) +*
  Start-At (IC IExec(J,IExec(I,s)) + card I,SCM+FSA)
proof
  set D = (Int-Locations \/ FinSeq-Locations);
  set A = NAT;
  let I be keepInt0_1 InitHalting Program of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  set ps = s | NAT;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized (I ';' J);
  set s3 = Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) +*
Initialized J;
  set m1 = LifeSpan(ProgramPart(s1),s1);
  set m3 = LifeSpan(ProgramPart(s3),s3);
A1: Initialized (I ';' J) c= s2 by FUNCT_4:26;
  s2 = s +* ((I ';' J) +* iS) by FUNCT_4:15
    .= s +* (I ';' J) +* iS by FUNCT_4:15;
  then
A2: iS c= s2 by FUNCT_4:26;
A3: s1 +* (I ';' J) = s +* (Initialized I +* (I ';' J)) by FUNCT_4:15
    .= s2 by SCMFSA6A:58;
A4: ProgramPart s1 halts_on s1 by Th5,FUNCT_4:26;
A5: Initialized J c= s3 by FUNCT_4:26;
A6: Comput(ProgramPart(s1),s1,m1) +* Initialized J, Comput(ProgramPart(s1),s1,
m1) +* ps +*
  Initialized J equal_outside dom ps by FUNCT_7:31,106;
  then
A7: Comput(ProgramPart(s1),s1,m1) +* ps +* Initialized J, Comput(ProgramPart(s1
),s1,m1) +*
  Initialized J equal_outside dom ps by FUNCT_7:28;
A8: IExec(I,s) = Result(ProgramPart(s1),s1) +* ps & Initialized J c= Result(
ProgramPart(s1),s1) +*
  Initialized J by FUNCT_4:26,SCMFSA6B:def 1;
A9: dom ps = dom s /\ A by RELAT_1:90
    .= (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} \/ A) /\ A by
PARTFUN1:def 4,SCMFSA_2:8
    .= A by XBOOLE_1:21;
A10: Initialized J c= IExec(I,s) +* Initialized J by FUNCT_4:26;
A11: Initialized J c= IExec(I,s) +* Initialized J & Initialized J c= s3 by
FUNCT_4:26;
A12: Initialized J c= s3 by FUNCT_4:26;
A13: Initialized I c= s1 by FUNCT_4:26;
  then
X:  ProgramPart s1 halts_on s1 by Th5;
  then
A14: s3 = Result(ProgramPart(s1),s1) +* Initialized J by AMI_1:122;
  Result(ProgramPart(s1),s1) = Comput(ProgramPart(s1),s1,m1) by X,AMI_1:122;
  then
A15: IC Result(ProgramPart(Result(ProgramPart s1,s1) +* Initialized J),
Result(ProgramPart s1,s1) +*
Initialized J) = IC Result(ProgramPart(IExec(I,s) +*
  Initialized J),IExec(I,s) +*
  Initialized J) by A9,A6,A8,A10,Th15,AMI_1:121;
A16: Initialized I c= s2 +* I by FUNCT_4:26,SCMFSA6A:52;
  s1,s2 equal_outside A & s2,s2 +* I equal_outside A by FUNCT_7:132,SCMFSA6A:53
;
  then s1,s2 +* I equal_outside A by FUNCT_7:29;
  then
A17: LifeSpan(ProgramPart(s2 +* I),s2 +* I) = m1 by A13,A16,Th15;
  then
A18: ProgramPart Relocated(J,card I) c= Comput(ProgramPart(s2),s2,m1+1) by A1
,Th25;
X: I +* (I ';' J) = I ';' J by SCMFSA6A:57;
X1: s2 +* I +* (I ';' J) = s2 +* (I +* (I ';' J)) by FUNCT_4:15;
X2: s2 +* (I ';' J) = s +* (Initialized (I ';' J) +* (I ';' J)) by FUNCT_4:15;
 (I ';' J) c= Initialized (I ';' J) by SCMFSA6A:26;
 then
X3: Initialized (I ';' J) +* (I ';' J) = Initialized (I ';' J) by LATTICE2:8;
  s2 +*(I +* iS) = s2 +*I +* iS by FUNCT_4:15
    .=s2 +* iS +* I by Th19
    .=s2 +* I by A2,FUNCT_4:79;
  then I +* iS c= s2 +* I by FUNCT_4:26;
  then Initialized I c= s2 +* I by FUNCT_4:15;
  then ProgramPart(s2+*I) halts_on s2+*I by Th5;
  then DataPart Comput(ProgramPart( (s2 +* I)), (s2 +* I),m1) = DataPart Comput
(ProgramPart( ((s2 +* I)
  +* (I ';' J))), ((s2 +* I)
  +* (I ';' J)),m1) by A16,A17,Th18,SCMFSA6A:39
    .= DataPart Comput(ProgramPart( ((s2 +* (I +* (I ';' J))))), ((s2 +* (I +*
(I ';' J)))),m1) by X1
    .= DataPart Comput(ProgramPart( (s2 +* (I ';' J))), (s2 +* (I ';' J)),m1)
by X
    .= DataPart Comput(ProgramPart( (s +* (Initialized (I ';' J) +* (I ';' J)))
), (s +* (Initialized (I ';' J) +* (I ';' J))),m1)
  by X2
    .= DataPart Comput(ProgramPart(s2),s2,m1) by X3
    .= DataPart Comput(ProgramPart(s1),s1,m1) by A13,A4,A3,Th18,SCMFSA6A:39;
  then
A19: DataPart(Comput(ProgramPart( (s2 +* I)), (s2 +* I),m1) +* Initialized J) =
DataPart
  Comput(ProgramPart(s1),s1,m1) +* DataPart Initialized J by FUNCT_4:75
    .= DataPart(Comput(ProgramPart(s1),s1,m1) +* Initialized J) by FUNCT_4:75;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,m1+1)
by AMI_1:123;
A20: IC Comput(ProgramPart(s2),s2,m1+1) =  card I & DataPart Comput(ProgramPart
(s2),s2,m1+1)
  = DataPart(Comput(ProgramPart( (s2 +* I)), (s2 +* I),m1) +* Initialized J)
by A1,A17,Th25;
  then
A21: DataPart Comput(ProgramPart s2, Comput(
ProgramPart(s2),s2,m1+1),m3) = DataPart Comput(ProgramPart(
  s3),
  s3, m3) by A18,A5,A19,Th12,T;
A22: IC Comput(ProgramPart s2, Comput(
ProgramPart(s2),s2,m1+1),m3) = IC Comput(ProgramPart(s3),s3,m3) + card
  I by A20,A18,A5,A19,Th12,T;
X: ProgramPart s2 halts_on s2 by A1,Th5;
Y: ProgramPart s1 halts_on s1 by A13,Th5;
A23: IExec(I ';' J,s) = Result(ProgramPart(s +* Initialized (I ';' J)),s +*
Initialized (I ';' J)) +* ps by SCMFSA6B:def 1
    .= Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2)) +* ps by X,
AMI_1:122
    .= Comput(ProgramPart(s2),s2,m1+1+m3) +* ps by A14,Th28;
  IExec(I,s) = Result(ProgramPart(s +* Initialized I),s +* Initialized I) +* ps
by SCMFSA6B:def 1
    .= Comput(ProgramPart(s1),s1,m1) +* ps by Y,AMI_1:122;
  then
  Result(ProgramPart(IExec(I,s) +* Initialized J),IExec(I,s) +* Initialized J),
Result(ProgramPart(s3),s3) equal_outside A by A9,A7,A11,Th15;
  then
A24: Result(ProgramPart(IExec(I,s) +* Initialized J),IExec(I,s) +* Initialized
J) +* ps = Result(ProgramPart(s3),s3) +* ps by A9,FUNCT_7:108;
Y: ProgramPart s3 halts_on s3 by A12,Th5;
  IExec(I,s) | A = (Result(ProgramPart(s +* Initialized I),s +* Initialized I)
+* ps) | A by SCMFSA6B:def 1
    .= ps by PBOOLE:157;
  then
A25: IExec(J,IExec(I,s)) = Result(ProgramPart(IExec(I,s) +* Initialized J),
IExec(I,s) +* Initialized J) +* ps by SCMFSA6B:def 1
    .= Comput(ProgramPart(s3),s3,m3) +* ps by A24,Y,AMI_1:122;
A26: dom ps misses D by A9,SCMFSA_2:13,14,XBOOLE_1:70;
  then
A27: DataPart IExec(I ';' J,s) = DataPart Comput(ProgramPart(s2),s2,m1+1+m3)
by A23,FUNCT_4:76,SCMFSA_2:127
    .= DataPart Comput(ProgramPart(s3),s3,m3) by A21,AMI_1:51
    .= DataPart IExec(J,IExec(I,s)) by A25,A26,FUNCT_4:76,SCMFSA_2:127;
X: ProgramPart s2 halts_on s2 by A1,Th5;
Y: ProgramPart s3 halts_on s3 by A12,Th5;
U: ProgramPart s1 halts_on s1 by A13,Th5;
XX: s3 = Result(ProgramPart s1,s1) +* Initialized J by U,AMI_1:122;
A28: IC IExec(I ';' J,s) = IC Result(ProgramPart(s +* Initialized (I ';' J)),s
+* Initialized (I ';' J)) by SCMFSA8A:7
    .= IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2)) by X,
AMI_1:122
    .= IC Comput(ProgramPart(s2),s2,m1+1+m3) by A14,Th28
    .= IC Comput(ProgramPart(s3),s3,m3) + card I by A22,AMI_1:51
    .= IC Result(ProgramPart(s3),s3) + card I by Y,AMI_1:122
    .= IC Result(ProgramPart(Result(ProgramPart s1,s1) +* Initialized J),
    Result(ProgramPart s1,s1) +*
Initialized J) + card I by XX
    .= IC IExec(J,IExec(I,s)) + card I by A15,SCMFSA8A:7;
  hereby
    reconsider l = IC IExec(J,IExec(I,s)) + card I as Element of NAT;
A29: dom Start-At(l,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
A30: now
      let x be set;
      assume
A31:  x in dom IExec(I ';' J,s);
      per cases by A31,SCMFSA6A:35;
      suppose
A32:    x is Int-Location;
        then x <> IC SCM+FSA by SCMFSA_2:81;
        then
A33:    not x in dom Start-At(l,SCM+FSA) by A29,TARSKI:def 1;
        IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A27,A32,SCMFSA6A:38;
        hence
        IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J
        ,IExec(I,s)) + card I,SCM+FSA)).x by A33,FUNCT_4:12;
      end;
      suppose
A34:    x is FinSeq-Location;
        then x <> IC SCM+FSA by SCMFSA_2:82;
        then
A35:    not x in dom Start-At(l,SCM+FSA) by A29,TARSKI:def 1;
        IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A27,A34,SCMFSA6A:38;
        hence
        IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J
        ,IExec(I,s)) + card I,SCM+FSA)).x by A35,FUNCT_4:12;
      end;
      suppose
A36:    x = IC SCM+FSA;
        then x in {IC SCM+FSA} by TARSKI:def 1;
        then
A37:    x in dom Start-At(l,SCM+FSA) by FUNCOP_1:19;
        thus IExec(I ';' J,s).x = (Start-At(l,SCM+FSA)).IC SCM+FSA by A28,A36,
FUNCOP_1:87
          .= (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card
        I,SCM+FSA)).x by A36,A37,FUNCT_4:14;
      end;
      suppose
A38:    x is Element of NAT;
        then x <> IC SCM+FSA by AMI_1:48;
        then
A39:    not x in dom Start-At(l,SCM+FSA) by A29,TARSKI:def 1;
        IExec(I ';' J,s) | A = ps by A23,PBOOLE:157
          .= IExec(J,IExec(I,s)) | A by A25,PBOOLE:157;
        then IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A38,SCMFSA6A:36;
        hence
        IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J
        ,IExec(I,s)) + card I, SCM+FSA)).x by A39,FUNCT_4:12;
      end;
    end;
    dom IExec(I ';' J,s) = the carrier of SCM+FSA by PARTFUN1:def 4
      .= dom (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card
    I,SCM+FSA)) by PARTFUN1:def 4;
    hence thesis by A30,FUNCT_1:9;
  end;
end;

registration
  let i be parahalting Instruction of SCM+FSA;
  cluster Macro i -> InitHalting;
  coherence;
end;

registration
  let i be parahalting Instruction of SCM+FSA, J be parahalting Program of
  SCM+FSA;
  cluster i ';' J -> InitHalting;
  coherence;
end;

registration
  let i be keeping_0 parahalting Instruction of SCM+FSA, J be InitHalting
  Program of SCM+FSA;
  cluster i ';' J -> InitHalting;
  coherence;
end;

registration
  let I, J be keepInt0_1 Program of SCM+FSA;
  cluster I ';' J -> keepInt0_1;
  coherence
  proof
    let s be State of SCM+FSA;
A1: Initialized(I ';' J) = (I ';' J) +* iS by FUNCT_4:15;
A2: Initialized I c= s +* Initialized I by FUNCT_4:26;
    assume
A3: Initialized (I ';' J) c= s;
    then
A4: s +* Initialized (I ';' J) = s by FUNCT_4:79;
    iS c= (I ';' J) +* iS by FUNCT_4:26;
    then
A5: iS c= s by A3,A1,XBOOLE_1:1;
    s +*Initialized(I ';' J) = s +*(I ';' J) +* iS by A1,FUNCT_4:15
      .= s +* iS +*(I ';' J) by Th19
      .= s +* (I ';' J) by A5,FUNCT_4:79;
    then
A6: s=s +* (I ';' J) by A3,FUNCT_4:79;
    per cases;
    suppose
A7:   ProgramPart(s+*Initialized I) halts_on s+*Initialized I;
      let k be Element of NAT;
A8:   s +* Initialized I=s +* (I +* iS) by FUNCT_4:15
        .= s +*I +* iS by FUNCT_4:15
        .= s +* iS +* I by Th19
        .= s +* I by A5,FUNCT_4:79;
      hereby
        per cases;
        suppose
A9:       k <= LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I);
          Comput(ProgramPart( (s +* Initialized I)), (s +* Initialized I),k).
intloc 0 = 1 by A2,Def3;
          hence thesis by A4,A7,A9,Th24,SCMFSA6A:30;
        end;
        suppose
A10:      k > LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I);
          set LS = LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I)
;
          consider p being Element of NAT such that
A11:      k = LS + p and
A12:      1 <= p by A10,FSM_1:1;
          consider r being Nat such that
A13:      p = 1 + r by A12,NAT_1:10;
          reconsider r as Element of NAT by ORDINAL1:def 13;
          set Rr = Comput(ProgramPart(Result(ProgramPart(s +* I),s +* I) +*
Initialized J),Result(ProgramPart(s
+* I),s
+* I) +* Initialized J,r);
          set Sr = Start-At (IC Comput(ProgramPart( (Result(ProgramPart(s +* I)
,s +* I) +*
Initialized J
          )), (Result(ProgramPart(s +* I),s +* I) +* Initialized J
          ),r) + card I, SCM+FSA);
          Initialized J c= Result(ProgramPart(s +* I),s +* I) +* Initialized J
by FUNCT_4:26;
          then
A14:      Comput(ProgramPart( (Result(ProgramPart(s +*I ),s +*I ) +*
Initialized J)), (Result(ProgramPart(s +*I
),s +*I
) +* Initialized J),r). intloc 0 = 1
          by Def3;
          dom Sr = {IC SCM+FSA} & intloc 0 <> IC SCM+FSA by FUNCOP_1:19
,SCMFSA_2:81;
          then not intloc 0 in dom Sr by TARSKI:def 1;
          then
A15:      (Rr +* Sr).intloc 0 = Rr.intloc 0 by FUNCT_4:12;
          Rr +* Sr, Comput(ProgramPart( (s +* (I ';' J))), (s +* (I ';' J)),LS+
1+r) equal_outside
          NAT by A3,A7,A8,Th26;
          hence thesis by A6,A11,A13,A14,A15,SCMFSA6A:30;
        end;
      end;
    end;
    suppose
A16:  not ProgramPart(s+*Initialized I) halts_on s+*Initialized I;
      let k be Element of NAT;
      Initialized I c= s +* Initialized I by FUNCT_4:26;
      then Comput(ProgramPart( (s +* Initialized I)), (s +* Initialized I),k).
intloc 0 = 1 by Def3;
      hence thesis by A4,A16,Th27,SCMFSA6A:30;
    end;
  end;
end;

registration
  let j be keeping_0 parahalting Instruction of SCM+FSA, I be keepInt0_1
  InitHalting Program of SCM+FSA;
  cluster I ';' j -> InitHalting keepInt0_1;
  coherence;
end;

registration
  let i be keeping_0 parahalting Instruction of SCM+FSA, J be keepInt0_1
  InitHalting Program of SCM+FSA;
  cluster i ';' J -> InitHalting keepInt0_1;
  coherence;
end;

registration
  let j be parahalting Instruction of SCM+FSA, I be parahalting Program of
  SCM+FSA;
  cluster I ';' j -> InitHalting;
  coherence;
end;

registration
  let i,j be parahalting Instruction of SCM+FSA;
  cluster i ';' j -> InitHalting;
  coherence;
end;

theorem Th30:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds IExec(I ';' J, s).a = IExec(J,IExec(I,s)).
  a
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA, J be InitHalting Program
  of SCM+FSA;
  IExec(I ';' J,s) = IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s
)) + card I, SCM+FSA) & not a in dom
Start-At (IC IExec(J,IExec(I,s)) + card I, SCM+FSA) by Th29,SCMFSA6B:9;
  hence thesis by FUNCT_4:12;
end;

theorem Th31:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds IExec(I ';' J, s).f = IExec(J,IExec(I,s)).
  f
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA, J be InitHalting Program
  of SCM+FSA;
  IExec(I ';' J,s) = IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s
)) + card I, SCM+FSA) & not f in dom
Start-At (IC IExec(J,IExec(I,s)) + card I, SCM+FSA) by Th29,SCMFSA6B:10;
  hence thesis by FUNCT_4:12;
end;

theorem Th32:
  for I be keepInt0_1 InitHalting Program of SCM+FSA, s be State
  of SCM+FSA holds DataPart(Initialize IExec(I,s)) = DataPart IExec(I,s)
proof
  set IF = Int-Locations \/ FinSeq-Locations;
  let I be keepInt0_1 InitHalting Program of SCM+FSA, s be State of SCM+FSA;
  set IE = IExec(I,s);
  now
A1: dom (Initialize IE) = the carrier of SCM+FSA by PARTFUN1:def 4;
    then
A2: dom Initialize IE = Int-Locations \/ FinSeq-Locations \/ ({IC SCM+FSA
    } \/ NAT) by SCMFSA_2:8,XBOOLE_1:4;
A3: dom IE = the carrier of SCM+FSA by PARTFUN1:def 4;
    hence dom DataPart Initialize IE = dom IE /\ IF by A1,RELAT_1:90
,SCMFSA_2:127;
    then
A4: dom DataPart Initialize IE = Int-Locations \/ FinSeq-Locations by A1,A3,A2,
XBOOLE_1:21;
    let x be set;
    assume
A5: x in dom DataPart Initialize IE;
    per cases by A5,A4,XBOOLE_0:def 3;
    suppose
      x in Int-Locations;
      then reconsider x9 = x as Int-Location by SCMFSA_2:11;
      hereby
        per cases;
        suppose
A6:       x9 is read-write;
          thus (DataPart Initialize IE).x = (Initialize IE).x by A5,A4,
FUNCT_1:72,SCMFSA_2:127
            .= IE.x by A6,SCMFSA6C:3;
        end;
        suppose
          x9 is read-only;
          then
A7:       x9 = intloc 0 by SF_MASTR:def 5;
          thus (DataPart Initialize IE).x = (Initialize IE).x9 by A5,A4,
FUNCT_1:72,SCMFSA_2:127
            .= 1 by A7,SCMFSA6C:3
            .= IE.x by A7,Th17;
        end;
      end;
    end;
    suppose
      x in FinSeq-Locations;
      then reconsider x9 = x as FinSeq-Location by SCMFSA_2:12;
      thus (DataPart Initialize IE).x = (Initialize IE).x9 by A5,A4,FUNCT_1:72
,SCMFSA_2:127
        .= IE.x by SCMFSA6C:3;
    end;
  end;
  hence thesis by FUNCT_1:68,SCMFSA_2:127;
end;

theorem Th33:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j, s).a = Exec(j, IExec(I,
  s)).a
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mj = Macro j;
  set SA = Start-At (IC IExec(Mj,IExec(I,s)) + card I, SCM+FSA);
A1: not a in dom SA by SCMFSA6B:9;
A2: DataPart Initialize IExec(I,s) = DataPart IExec(I, s) by Th32;
  a in Int-Locations by SCMFSA_2:9;
  then
A3: a in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
  thus IExec(I ';' j, s).a = (IExec(Mj,IExec(I,s))+*SA).a by Th29
    .= IExec(Mj, IExec(I,s)).a by A1,FUNCT_4:12
    .= Exec(j, Initialize IExec(I,s)).a by SCMFSA6C:6
    .= (DataPart Exec(j, Initialize IExec(I,s))).a by A3,FUNCT_1:72
,SCMFSA_2:127
    .= (DataPart Exec(j, IExec(I, s))).a by A2,SCMFSA6C:5
    .= Exec(j, IExec(I, s)).a by A3,FUNCT_1:72,SCMFSA_2:127;
end;

theorem Th34:
  for I being keepInt0_1 InitHalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j, s).f = Exec(j, IExec(I,
  s)).f
proof
  let I be keepInt0_1 InitHalting Program of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mj = Macro j;
  set SA = Start-At (IC IExec(Mj,IExec(I,s)) + card I, SCM+FSA);
A1: not f in dom SA by SCMFSA6B:10;
A2: DataPart Initialize IExec(I,s) = DataPart IExec(I, s) by Th32;
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A3: f in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
  thus IExec(I ';' j, s).f = (IExec(Mj,IExec(I,s))+*SA).f by Th29
    .= IExec(Mj, IExec(I,s)).f by A1,FUNCT_4:12
    .= Exec(j, Initialize IExec(I,s)).f by SCMFSA6C:6
    .= (DataPart Exec(j, Initialize IExec(I,s))).f by A3,FUNCT_1:72
,SCMFSA_2:127
    .= (DataPart Exec(j, IExec(I, s))).f by A2,SCMFSA6C:5
    .= Exec(j, IExec(I, s)).f by A3,FUNCT_1:72,SCMFSA_2:127;
end;

definition
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  pred I is_closed_onInit s means
  :Def4:
  for k being Element of NAT holds IC
  Comput(ProgramPart( (s +* Initialized I )), (s +* Initialized I ),k) in dom I
;
  pred I is_halting_onInit s means
  :Def5:
  ProgramPart(s+*Initialized I) halts_on s+*Initialized I;
end;

theorem Th35:
  for I being Program of SCM+FSA holds I is InitClosed iff for s
  being State of SCM+FSA holds I is_closed_onInit s
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is InitClosed;
    let s be State of SCM+FSA;
    Initialized I c= s +* Initialized I by FUNCT_4:26;
    then
    for k being Element of NAT holds IC Comput(ProgramPart( (s +* Initialized I
)), (s +* Initialized I),
    k) in dom I by A1,Def1;
    hence I is_closed_onInit s by Def4;
  end;
  assume
A2: for s being State of SCM+FSA holds I is_closed_onInit s;
  now
    let s be State of SCM+FSA;
    let k be Element of NAT;
    assume
    Initialized I c= s;
    then
A3: s = s +* Initialized I by FUNCT_4:79;
    I is_closed_onInit s by A2;
    hence IC Comput(ProgramPart(s),s,k) in dom I by A3,Def4;
  end;
  hence thesis by Def1;
end;

theorem Th36:
  for I being Program of SCM+FSA holds I is InitHalting iff for s
  being State of SCM+FSA holds I is_halting_onInit s
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is InitHalting;
    let s be State of SCM+FSA;
    Initialized I c= s +* Initialized I by FUNCT_4:26;
    then ProgramPart(s+*Initialized I) halts_on s+*Initialized I
     by A1,AMI_1:def 26;
    hence I is_halting_onInit s by Def5;
  end;
  assume
A2: for s being State of SCM+FSA holds I is_halting_onInit s;
  now
    let s be State of SCM+FSA;
    assume
    Initialized I c= s;
    then
A3: s = s +* Initialized I by FUNCT_4:79;
    I is_halting_onInit s by A2;
    hence ProgramPart s halts_on s by A3,Def5;
  end;
  then Initialized I is halting by AMI_1:def 26;
  hence thesis by Def2;
end;

theorem Th37:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does_not_destroy a & I is_closed_onInit s & Initialized
  I c= s holds for k being Element of NAT holds Comput(ProgramPart(s),s,k).a =
s.a
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA,a be Int-Location;
  assume
A1: I does_not_destroy a;
  defpred P[Nat] means Comput(ProgramPart(s),s,$1).a = s.a;
  assume
A2: I is_closed_onInit s;
  assume
A3: Initialized I c= s;
  then
A4: s +* Initialized I = s by FUNCT_4:79;
A5: I c= s by A3,Th13;
A6: now
    let k be Element of NAT;
    assume
A7: P[k];
    set l = IC Comput(ProgramPart(s),s,k);
A8: l in dom I by A2,A4,Def4;
    then s.l = I.l by A5,GRFUNC_1:8;
    then s.l in rng I by A8,FUNCT_1:def 5;
    then
A9: s.l does_not_destroy a by A1,SCMFSA7B:def 4;
Y:  (ProgramPart Comput(ProgramPart(s),s,k))/.IC Comput(ProgramPart(s),s,k)
 = Comput(ProgramPart(s),s,k).IC Comput(ProgramPart(s),s,k) by AMI_1:150;
T: ProgramPart s = ProgramPart Comput(
ProgramPart(s),s,k)
by AMI_1:123;
    Comput(ProgramPart( s), s,k + 1).a = (Following(ProgramPart s,
    Comput(ProgramPart(s),s,k))).a by AMI_1:14
      .= Exec(s.l,Comput(ProgramPart(s),s,k)).a by Y,T,AMI_1:54
      .= s.a by A7,A9,SCMFSA7B:26;
    hence P[k+1];
  end;
A10: P[0] by AMI_1:13;
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A10,A6);
end;

registration
  cluster InitHalting good Program of SCM+FSA;
  existence
  proof
    take Stop SCM+FSA;
    thus thesis;
  end;
end;

registration
  cluster InitClosed good -> keepInt0_1 Program of SCM+FSA;
  correctness
  proof
    let I be Program of SCM+FSA;
    assume
A1: I is InitClosed good;
    then
A2: I does_not_destroy intloc 0 by SCMFSA7B:def 5;
    now
      let s be State of SCM+FSA;
      assume
A3:   Initialized I c= s;
      let k be Element of NAT;
      I is_closed_onInit s by A1,Th35;
      hence Comput(ProgramPart(s),s,k).intloc 0 = s.intloc 0 by A2,A3,Th37
        .=1 by A3,Th7;
    end;
    hence thesis by Def3;
  end;
end;

registration
  cluster Stop SCM+FSA -> InitHalting good;
  coherence;
end;

theorem
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being InitHalting Program of SCM+FSA, a being
  Int-Location holds IExec(i ';' J,s).a = IExec(J,Exec(i,Initialize s)).a
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  let a be Int-Location;
  thus IExec(i ';' J,s).a = IExec(J,IExec(Macro i,s)).a by Th30
    .= IExec(J,Exec(i,Initialize s)).a by SCMFSA6C:6;
end;

theorem
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being InitHalting Program of SCM+FSA, f being
  FinSeq-Location holds IExec(i ';' J,s).f = IExec(J,Exec(i,Initialize s)).f
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be InitHalting Program of SCM+FSA;
  let f be FinSeq-Location;
  thus IExec(i ';' J,s).f = IExec(J,IExec(Macro i,s)).f by Th31
    .= IExec(J,Exec(i,Initialize s)).f by SCMFSA6C:6;
end;

theorem Th40:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds I
  is_closed_onInit s iff I is_closed_on Initialize s
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  set s1=s +* Initialized I, s2=Initialize s +* (I +*
  Start-At( 0,SCM+FSA));
A1: s1 = s2 by SCMFSA8A:13;
  I is_closed_onInit s iff for k be Element of NAT holds IC Comput(ProgramPart(
s1
  ),s1
  ,k) in dom I by Def4;
  hence thesis by A1,SCMFSA7B:def 7;
end;

theorem Th41:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds I
  is_halting_onInit s iff I is_halting_on Initialize s
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  set s1=s +* Initialized I, s2=Initialize s +* (I +*
  Start-At( 0,SCM+FSA));
A1: s1 = s2 by SCMFSA8A:13;
  I is_halting_onInit s iff ProgramPart s1 halts_on s1 by Def5;
  hence thesis by A1,SCMFSA7B:def 8;
end;

theorem
  for I be Program of SCM+FSA, s be State of SCM+FSA holds IExec(I,s) =
  IExec(I,Initialize s)
proof
  let I be Program of SCM+FSA,s be State of SCM+FSA;
  set sp= s|NAT;
X:  s+*Initialized I = Initialize s+*Initialized I by SCMFSA8A:8;
  thus IExec(I,s) = Result(ProgramPart(s+*Initialized I),s+*Initialized I) +*sp
by SCMFSA6B:def 1
    .= Result(ProgramPart(Initialize s+*Initialized I),Initialize s+*
Initialized I) +*sp by X
    .= Result(ProgramPart(Initialize s+*Initialized I),Initialize s+*
Initialized I) +* (Initialize s) | NAT by SCMFSA8C:36
    .= IExec(I,Initialize s) by SCMFSA6B:def 1;
end;

theorem Th43:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & I is_closed_onInit s & I
  is_halting_onInit s holds if=0(a,I,J) is_closed_onInit s & if=0(a,I,J)
  is_halting_onInit s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set Is = Initialize s;
  assume
  s.a = 0;
  then
A1: Is.a =0 by SCMFSA6C:3;
  assume
  I is_closed_onInit s;
  then
A2: I is_closed_on Is by Th40;
  assume
  I is_halting_onInit s;
  then I is_halting_on Is by Th41;
  then if=0(a,I,J) is_closed_on Is & if=0(a,I,J) is_halting_on Is by A1,A2,
SCMFSA8B:16;
  hence thesis by Th40,Th41;
end;

theorem Th44:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & I is_closed_onInit s & I
is_halting_onInit s holds IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At(
  (card I + card J + 3),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  set Is = Initialize s;
  assume
  I is_closed_onInit s;
  then
A2: I is_closed_on Is by Th40;
  assume
  I is_halting_onInit s;
  then I is_halting_on Is by Th41;
  hence thesis by A1,A2,SCMFSA8B:17;
end;

theorem Th45:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a <> 0 & J is_closed_onInit s & J
  is_halting_onInit s holds if=0(a,I,J) is_closed_onInit s & if=0(a,I,J)
  is_halting_onInit s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set Is = Initialize s;
  assume
  s.a <> 0;
  then
A1: Is.a <> 0 by SCMFSA6C:3;
  assume
  J is_closed_onInit s;
  then
A2: J is_closed_on Is by Th40;
  assume
  J is_halting_onInit s;
  then J is_halting_on Is by Th41;
  then if=0(a,I,J) is_closed_on Is & if=0(a,I,J) is_halting_on Is by A1,A2,
SCMFSA8B:18;
  hence thesis by Th40,Th41;
end;

theorem Th46:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <> 0 & J
is_closed_onInit s & J is_halting_onInit s holds IExec(if=0(a,I,J),s) = IExec(J
  ,s) +* Start-At( (card I + card J + 3),SCM+FSA)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  assume
A1: s.a <> 0;
  set Is = Initialize s;
  assume
  J is_closed_onInit s;
  then
A2: J is_closed_on Is by Th40;
  assume
  J is_halting_onInit s;
  then J is_halting_on Is by Th41;
  hence thesis by A1,A2,SCMFSA8B:19;
end;

theorem Th47:
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if=0(a,I,J) is InitHalting & (s.
  a = 0 implies IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At( (card I +
card J + 3),SCM+FSA)) &
 (s.a <> 0 implies IExec(if=0(a,I,J),s) = IExec(J,s) +* Start-At(
   (card I + card J + 3),SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  now
    let s be State of SCM+FSA;
    assume
    Initialized if=0(a,I,J) c= s;
    then
A1: s = s +* Initialized if=0(a,I,J) by FUNCT_4:79;
A2: J is_closed_onInit s & J is_halting_onInit s by Th35,Th36;
A3: I is_closed_onInit s & I is_halting_onInit s by Th35,Th36;
    per cases;
    suppose
      s.a = 0;
      then if=0(a,I,J) is_halting_onInit s by A3,Th43;
      hence ProgramPart s halts_on s by A1,Def5;
    end;
    suppose
      s.a <> 0;
      then if=0(a,I,J) is_halting_onInit s by A2,Th45;
      hence ProgramPart s halts_on s by A1,Def5;
    end;
  end;
  then Initialized if=0(a,I,J) is halting by AMI_1:def 26;
  hence if=0(a,I,J) is InitHalting by Def2;
  I is_closed_onInit s & I is_halting_onInit s by Th35,Th36;
  hence s.a = 0 implies IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At( (
  card I + card J + 3),SCM+FSA) by Th44;
  J is_closed_onInit s & J is_halting_onInit s by Th35,Th36;
  hence thesis by Th46;
end;

theorem
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA
, a being read-write Int-Location holds IC IExec(if=0(a,I,J),s) =  (card
I + card J + 3) & (s.a = 0 implies ((for d being Int-Location holds IExec(if=0(
a,I,J),s).d = IExec(I,s).d) & for f being FinSeq-Location holds IExec(if=0(a,I,
  J),s).f = IExec(I,s).f)) & (s.a <> 0 implies ((for d being Int-Location holds
  IExec(if=0(a,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if=0(a,I,J),s).f = IExec(J,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby
    per cases;
    suppose
      s.a = 0;
      then
      IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At( (card I + card
      J + 3),SCM+FSA) by Th47;
      hence IC IExec(if=0(a,I,J),s) =  (card I + card J + 3) by FUNCT_4:121
;
    end;
    suppose
      s.a <> 0;
      then
      IExec(if=0(a,I,J),s) = IExec(J,s) +* Start-At( (card I + card
      J + 3),SCM+FSA) by Th47;
      hence IC IExec(if=0(a,I,J),s) =  (card I + card J + 3) by FUNCT_4:121
;
    end;
  end;
  hereby
    assume
    s.a = 0;
    then
A1: IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At( (card I + card J
    + 3),SCM+FSA) by Th47;
    hereby
      let d be Int-Location;
      not d in dom Start-At( (card I + card J + 3),SCM+FSA)
      by SCMFSA6B:9;
      hence IExec(if=0(a,I,J),s).d = IExec(I,s).d by A1,FUNCT_4:12;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At( (card I + card J + 3),SCM+FSA)
    by SCMFSA6B:10;
    hence IExec(if=0(a,I,J),s).f = IExec(I,s).f by A1,FUNCT_4:12;
  end;
  assume
  s.a <> 0;
  then
A2: IExec(if=0(a,I,J),s) = IExec(J,s) +* Start-At( (card I + card J +
  3),SCM+FSA) by Th47;
  hereby
    let d be Int-Location;
    not d in dom Start-At( (card I + card J + 3),SCM+FSA) by SCMFSA6B:9;
    hence IExec(if=0(a,I,J),s).d = IExec(J,s).d by A2,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At( (card I + card J + 3),SCM+FSA) by SCMFSA6B:10;
  hence thesis by A2,FUNCT_4:12;
end;

theorem Th49:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & I is_closed_onInit s & I
  is_halting_onInit s holds if>0(a,I,J) is_closed_onInit s & if>0(a,I,J)
  is_halting_onInit s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set Is = Initialize s;
  assume
  s.a > 0;
  then
A1: Is.a >0 by SCMFSA6C:3;
  assume
  I is_closed_onInit s;
  then
A2: I is_closed_on Is by Th40;
  assume
  I is_halting_onInit s;
  then I is_halting_on Is by Th41;
  then if>0(a,I,J) is_closed_on Is & if>0(a,I,J) is_halting_on Is by A1,A2,
SCMFSA8B:22;
  hence thesis by Th40,Th41;
end;

theorem Th50:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & I is_closed_onInit s & I
is_halting_onInit s holds IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At(
  (card I + card J + 3),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  set Is = Initialize s;
  assume
  I is_closed_onInit s;
  then
A2: I is_closed_on Is by Th40;
  assume
  I is_halting_onInit s;
  then I is_halting_on Is by Th41;
  hence thesis by A1,A2,SCMFSA8B:23;
end;

theorem Th51:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a <= 0 & J is_closed_onInit s & J
  is_halting_onInit s holds if>0(a,I,J) is_closed_onInit s & if>0(a,I,J)
  is_halting_onInit s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set Is = Initialize s;
  assume
  s.a <= 0;
  then
A1: Is.a <= 0 by SCMFSA6C:3;
  assume
  J is_closed_onInit s;
  then
A2: J is_closed_on Is by Th40;
  assume
  J is_halting_onInit s;
  then J is_halting_on Is by Th41;
  then if>0(a,I,J) is_closed_on Is & if>0(a,I,J) is_halting_on Is by A1,A2,
SCMFSA8B:24;
  hence thesis by Th40,Th41;
end;

theorem Th52:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <= 0 & J
is_closed_onInit s & J is_halting_onInit s holds IExec(if>0(a,I,J),s) = IExec(J
  ,s) +* Start-At( (card I + card J + 3),SCM+FSA)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  assume
A1: s.a <= 0;
  set Is = Initialize s;
  assume
  J is_closed_onInit s;
  then
A2: J is_closed_on Is by Th40;
  assume
  J is_halting_onInit s;
  then J is_halting_on Is by Th41;
  hence thesis by A1,A2,SCMFSA8B:25;
end;

theorem Th53:
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if>0(a,I,J) is InitHalting & (s.
  a > 0 implies IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At( (card I +
card J + 3),SCM+FSA)) &
 (s.a <= 0 implies IExec(if>0(a,I,J),s) = IExec(J,s) +* Start-At(
   (card I + card J + 3),SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  now
    let s be State of SCM+FSA;
    assume
    Initialized if>0(a,I,J) c= s;
    then
A1: s = s +* Initialized if>0(a,I,J) by FUNCT_4:79;
A2: J is_closed_onInit s & J is_halting_onInit s by Th35,Th36;
A3: I is_closed_onInit s & I is_halting_onInit s by Th35,Th36;
    per cases;
    suppose
      s.a > 0;
      then if>0(a,I,J) is_halting_onInit s by A3,Th49;
      hence ProgramPart s halts_on s by A1,Def5;
    end;
    suppose
      s.a <= 0;
      then if>0(a,I,J) is_halting_onInit s by A2,Th51;
      hence ProgramPart s halts_on s by A1,Def5;
    end;
  end;
  then Initialized if>0(a,I,J) is halting by AMI_1:def 26;
  hence if>0(a,I,J) is InitHalting by Def2;
  I is_closed_onInit s & I is_halting_onInit s by Th35,Th36;
  hence s.a > 0 implies IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At( (
  card I + card J + 3),SCM+FSA) by Th50;
  J is_closed_onInit s & J is_halting_onInit s by Th35,Th36;
  hence thesis by Th52;
end;

theorem
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA
, a being read-write Int-Location holds IC IExec(if>0(a,I,J),s) =  (card
I + card J + 3) & (s.a > 0 implies ((for d being Int-Location holds IExec(if>0(
a,I,J),s).d = IExec(I,s).d) & for f being FinSeq-Location holds IExec(if>0(a,I,
  J),s).f = IExec(I,s).f)) & (s.a <= 0 implies ((for d being Int-Location holds
  IExec(if>0(a,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if>0(a,I,J),s).f = IExec(J,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby
    per cases;
    suppose
      s.a > 0;
      then
      IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At( (card I + card
      J + 3),SCM+FSA) by Th53;
      hence IC IExec(if>0(a,I,J),s) =  (card I + card J + 3) by FUNCT_4:121
;
    end;
    suppose
      s.a <= 0;
      then
      IExec(if>0(a,I,J),s) = IExec(J,s) +* Start-At( (card I + card
      J + 3),SCM+FSA) by Th53;
      hence IC IExec(if>0(a,I,J),s) =  (card I + card J + 3) by FUNCT_4:121
;
    end;
  end;
  hereby
    assume
    s.a > 0;
    then
A1: IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At( (card I + card J
    + 3),SCM+FSA) by Th53;
    hereby
      let d be Int-Location;
      not d in dom Start-At( (card I + card J + 3),SCM+FSA)
      by SCMFSA6B:9;
      hence IExec(if>0(a,I,J),s).d = IExec(I,s).d by A1,FUNCT_4:12;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At( (card I + card J + 3),SCM+FSA) by SCMFSA6B:10;
    hence IExec(if>0(a,I,J),s).f = IExec(I,s).f by A1,FUNCT_4:12;
  end;
  assume
  s.a <= 0;
  then
A2: IExec(if>0(a,I,J),s) = IExec(J,s) +* Start-At( (card I + card J +
  3),SCM+FSA) by Th53;
  hereby
    let d be Int-Location;
    not d in dom Start-At( (card I + card J + 3),SCM+FSA) by SCMFSA6B:9;
    hence IExec(if>0(a,I,J),s).d = IExec(J,s).d by A2,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At( (card I + card J + 3),SCM+FSA) by SCMFSA6B:10;
  hence thesis by A2,FUNCT_4:12;
end;

theorem Th55:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a < 0 & I is_closed_onInit s & I
is_halting_onInit s holds IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At(
  (card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a < 0;
  set Is = Initialize s;
  assume
  I is_closed_onInit s;
  then
A2: I is_closed_on Is by Th40;
  assume
  I is_halting_onInit s;
  then I is_halting_on Is by Th41;
  hence thesis by A1,A2,SCMFSA8B:29;
end;

theorem Th56:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & J is_closed_onInit s & J
is_halting_onInit s holds IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At(
  (card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA,I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  set Is = Initialize s;
  assume
  J is_closed_onInit s;
  then
A2: J is_closed_on Is by Th40;
  assume
  J is_halting_onInit s;
  then J is_halting_on Is by Th41;
  hence thesis by A1,A2,SCMFSA8B:31;
end;

theorem Th57:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & J is_closed_onInit s & J
is_halting_onInit s holds IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At(
  (card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA,I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  set Is = Initialize s;
  assume
  J is_closed_onInit s;
  then
A2: J is_closed_on Is by Th40;
  assume
  J is_halting_onInit s;
  then J is_halting_on Is by Th41;
  hence thesis by A1,A2,SCMFSA8B:33;
end;

theorem Th58:
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if<0(a,I,J) is InitHalting & (s.
  a < 0 implies IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At( (card I +
card J + card J + 7),SCM+FSA)) &
 (s.a >= 0 implies IExec(if<0(a,I,J),s) = IExec(J,s) +*
  Start-At( (card I + card J + card J + 7),SCM+FSA))
proof
  let s be State of SCM+FSA,I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  if<0(a,I,J) = if=0(a,J,if>0(a,J,I)) & if>0(a,J,I) is InitHalting by Th53,
SCMFSA8B:def 3;
  hence if<0(a,I,J) is InitHalting by Th47;
  I is_closed_onInit s & I is_halting_onInit s by Th35,Th36;
  hence s.a < 0 implies IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At( (
  card I + card J + card J + 7),SCM+FSA) by Th55;
A1: J is_closed_onInit s & J is_halting_onInit s by Th35,Th36;
  hereby
    assume
A2: s.a >= 0;
    per cases;
    suppose
      s.a = 0;
      hence
      IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At( (card I + card
      J + card J + 7),SCM+FSA) by A1,Th56;
    end;
    suppose
      s.a <> 0;
      hence
      IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At( (card I + card
      J + card J + 7),SCM+FSA) by A1,A2,Th57;
    end;
  end;
end;

registration
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  cluster if=0(a,I,J) -> InitHalting;
  correctness by Th47;
  cluster if>0(a,I,J) -> InitHalting;
  correctness by Th53;
  cluster if<0(a,I,J) -> InitHalting;
  correctness by Th58;
end;

theorem Th59:
  for I being Program of SCM+FSA holds I is InitHalting iff for s
  being State of SCM+FSA holds I is_halting_on Initialize s
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is InitHalting;
    let s be State of SCM+FSA;
    I is_halting_onInit s by A1,Th36;
    hence I is_halting_on Initialize s by Th41;
  end;
  assume
A2: for s being State of SCM+FSA holds I is_halting_on Initialize s;
  now
    let s be State of SCM+FSA;
    I is_halting_on Initialize s by A2;
    hence I is_halting_onInit s by Th41;
  end;
  hence thesis by Th36;
end;

theorem Th60:
  for I being Program of SCM+FSA holds I is InitClosed iff for s
  being State of SCM+FSA holds I is_closed_on Initialize s
proof
  let I be Program of SCM+FSA;
  hereby
    assume
A1: I is InitClosed;
    let s be State of SCM+FSA;
    I is_closed_onInit s by A1,Th35;
    hence I is_closed_on Initialize s by Th40;
  end;
  assume
A2: for s being State of SCM+FSA holds I is_closed_on Initialize s;
  now
    let s be State of SCM+FSA;
    I is_closed_on Initialize s by A2;
    hence I is_closed_onInit s by Th40;
  end;
  hence thesis by Th35;
end;

theorem Th61:
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being read-write Int-Location holds IExec(I,s).a = Comput(
ProgramPart( (
  Initialize s +* (I +* Start-At( 0,SCM+FSA)))), (
  Initialize s +* (I +* Start-At( 0,SCM+FSA))),
  (LifeSpan(ProgramPart(Initialize s +* (I +*
  Start-At( 0,SCM+FSA))),Initialize s +* (I +*
  Start-At( 0,SCM+FSA))))).a
proof
  let s be State of SCM+FSA,I be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  I is_halting_on Initialize s by Th59;
  hence thesis by SCMFSA8C:87;
end;

theorem Th62:
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being Int-Location,k being Element of NAT st I does_not_destroy a
holds IExec(I,s).a = Comput(ProgramPart( (Initialize s +* (I +*
Start-At( 0,SCM+FSA)))), (Initialize s +* (I +*
Start-At( 0,SCM+FSA))),k)
  .a
proof
  let s be State of SCM+FSA,I be InitHalting Program of SCM+FSA;
  let a be Int-Location,k be Element of NAT;
  assume
A1: I does_not_destroy a;
  I is_halting_on Initialize s & I is_closed_on Initialize s by Th59,Th60;
  hence thesis by A1,SCMFSA8C:89;
end;
set A = NAT;
set D = Int-Locations \/ FinSeq-Locations;

theorem Th63:
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being Int-Location st I does_not_destroy a holds IExec(I,s).a = (
  Initialize s).a
proof
  let s be State of SCM+FSA;
  let I be InitHalting Program of SCM+FSA;
  let a be Int-Location;
A1: DataPart Initialize s = DataPart (Initialize s +* (I +* Start-At(
  0,SCM+FSA))) by SCMFSA8A:11;
  assume
  I does_not_destroy a;
  hence
  IExec(I,s).a = Comput(ProgramPart( (Initialize s +* (I +*
  Start-At( 0,SCM+FSA)))), (Initialize s +* (I +*
  Start-At( 0,SCM+FSA))),
  0).a by Th62
    .= (Initialize s +* (I +* Start-At( 0,SCM+FSA))).a by AMI_1:13
    .= (Initialize s).a by A1,SCMFSA6A:38;
end;

theorem Th64:
  for s be State of SCM+FSA,I be keepInt0_1 InitHalting Program of
  SCM+FSA, a being read-write Int-Location st I does_not_destroy a holds
Comput(ProgramPart( (Initialize s +* (I ';' SubFrom(a,intloc 0) +*
Start-At( 0,SCM+FSA)))
), (Initialize s +* (I ';' SubFrom(a,intloc 0) +*
Start-At( 0,SCM+FSA)))
,LifeSpan(ProgramPart(Initialize s +* (I ';' SubFrom(a,intloc 0) +*
Start-At( 0,SCM+FSA))),Initialize s +* (I ';' SubFrom(a,intloc 0) +*
Start-At( 0,SCM+FSA)))).a
  = s.a - 1
proof
  let s be State of SCM+FSA,I be keepInt0_1 InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  set s0 = Initialize s;
  set s1 = s0 +* (I ';' SubFrom(a,intloc 0) +* Start-At( 0,SCM+FSA));
A2: not a in dom (I +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  IExec(I ';' SubFrom(a,intloc 0),s).a = Exec(SubFrom(a,intloc 0),IExec(I,
  s)).a by Th33
    .= IExec(I,s).a - IExec(I,s).intloc 0 by SCMFSA_2:91
    .= IExec(I,s).a - 1 by Th17
    .= Comput(ProgramPart( (s0 +* (I +* Start-At( 0,SCM+FSA)))), (s0 +* (I +*
Start-At( 0,SCM+FSA))),0).a - 1
    by A1,Th62
    .= (s0 +* (I +* Start-At( 0,SCM+FSA))).a - 1 by AMI_1:13
    .= s0.a - 1 by A2,FUNCT_4:12;
  hence Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)).a = s0.a - 1
by Th61
    .= s.a - 1 by SCMFSA6C:3;
end;

theorem Th65:
  for s being State of SCM+FSA, I being InitClosed Program of
SCM+FSA st Initialized I c= s & ProgramPart s halts_on s
 for m being Element of NAT st m <=
LifeSpan(ProgramPart(s),s) holds Comput(ProgramPart(s),s,m), Comput(ProgramPart
( (s +* loop I))
, (s +* loop I),m) equal_outside
  NAT
proof
  let s be State of SCM+FSA,I be InitClosed Program of SCM+FSA;
  assume
A1: Initialized I c= s;
  defpred X[Nat] means $1 <= LifeSpan(ProgramPart(s),s) implies Comput(
ProgramPart(s),s,$1),
  Comput(ProgramPart((s+*loop I)),(s+*loop I),$1) equal_outside NAT;
  assume
A2: ProgramPart s halts_on s;
A3: for m st X[m] holds X[m+1]
  proof
    set sx = s+*loop I;
    let m;
    assume
A4: m <= LifeSpan(ProgramPart(s),s) implies Comput(ProgramPart(s),s,m), Comput(
ProgramPart((s+*
loop I)),(s+*loop I),
    m) equal_outside NAT;
T: ProgramPart sx = ProgramPart Comput(ProgramPart(sx),sx,m)
by AMI_1:123;
A5: Comput(ProgramPart(sx),sx,m+1) =
Following(ProgramPart sx,Comput(ProgramPart(sx),sx,m)
)
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(sx),sx,m),Comput(
ProgramPart(sx),sx,m)),
      Comput(ProgramPart(sx),sx,m)) by T;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m)
by AMI_1:123;
A6: Comput(ProgramPart(s),s,m+1) =
Following(ProgramPart s,Comput(ProgramPart(s),s,m))
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s),s,m),Comput(
ProgramPart(s),s,m))
      ,Comput(ProgramPart(s),s,m)) by T;
A7: IC Comput(ProgramPart(s),s,m) in dom I by A1,Def1;
    then
A8: loop I c= Comput(ProgramPart(sx),sx,m) & IC Comput(ProgramPart(s),s,m) in
dom loop I by AMI_1:81,FUNCT_4:26,105;
Y:  (ProgramPart Comput(ProgramPart(s),s,m))/.IC Comput(ProgramPart(s),s,m)
 = Comput(ProgramPart(s),s,m).IC Comput(ProgramPart(s),s,m) by AMI_1:150;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m)
by AMI_1:123;
    I c= Comput(ProgramPart(s),s,m) by A1,Th13,AMI_1:81;
    then
A9: CurInstr(ProgramPart s,Comput(ProgramPart(s),s,m))
 = I.IC(Comput(ProgramPart(s),s,m)) by A7,Y,TX,GRFUNC_1:8;
    assume
A10: m+1 <= LifeSpan(ProgramPart(s),s);
    then
A11: IC(Comput(ProgramPart(s),s,m)) = IC(Comput(ProgramPart(sx),sx,m)) by A4,
AMI_1:121,NAT_1:13;
Y:  (ProgramPart Comput(ProgramPart(sx),sx,m))/.IC Comput(ProgramPart(sx),sx,m)
 = Comput(ProgramPart(sx),sx,m).IC Comput(ProgramPart(sx),sx,m) by AMI_1:150;
    m < LifeSpan(ProgramPart(s),s) by A10,NAT_1:13;
    then I.IC(Comput(ProgramPart(s),s,m)) <> halt SCM+FSA by A2,A9,AMI_1:def 46
;
    then
CurInstr(ProgramPart Comput(ProgramPart(s),s,m),Comput(ProgramPart(s),s,m))
 = (loop I).IC(Comput(ProgramPart(s),s,m)) by A9,TX,FUNCT_4:111
      .= CurInstr(ProgramPart Comput(ProgramPart(sx),sx,m),Comput(ProgramPart(
sx),sx,m))
       by A11,A8,Y,GRFUNC_1:8;
    hence thesis by A4,A10,A6,A5,NAT_1:13,SCMFSA6A:32;
  end;
  Comput(ProgramPart(s),s,0) = s & Comput(ProgramPart((s+*loop I)),(s+*loop I),
0) = s+*loop I by AMI_1:13;
  then
A12: X[0] by FUNCT_7:132;
  thus for m being Element of NAT holds X[m] from NAT_1:sch 1(A12, A3);
end;

theorem
  for s being State of SCM+FSA, I being InitHalting Program of SCM+FSA
st Initialized I c= s holds for k being Element of NAT st k <= LifeSpan(
ProgramPart(s),s) holds
  CurInstr(ProgramPart Comput(ProgramPart( (s +* loop I)), (s +* loop I),k),
   Comput(ProgramPart( (s +* loop I)), (s +* loop I),k)) <> halt SCM+FSA
proof
  let s be State of SCM+FSA;
  let I be InitHalting Program of SCM+FSA;
  set s2 = s +* loop I;
  assume
A1: Initialized I c= s;
  then
A2: ProgramPart s halts_on s by AMI_1:def 26;
  hereby
    let k be Element of NAT;
    set lk = IC Comput(ProgramPart(s),s,k);
A3: IC Comput(ProgramPart(s),s,k) in dom I & dom I = dom loop I by A1,Def1,
FUNCT_4:105;
    then
A4: (loop I).lk in rng loop I by FUNCT_1:def 5;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by AMI_1:150;
    assume
    k <= LifeSpan(ProgramPart(s),s);
    then lk = IC Comput(ProgramPart(s2),s2,k) by A1,A2,Th65,AMI_1:121;
    then
A5: CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(s2),s2
,k))
 = s2.lk by Y,AMI_1:54
      .= (loop I).lk by A3,FUNCT_4:14;
    assume
    CurInstr(ProgramPart Comput(ProgramPart( (s +* loop I)), (s +* loop I),k),
     Comput(ProgramPart( (s +* loop I)), (s +* loop I),k)) = halt SCM+FSA;
    hence contradiction by A5,A4,SCMFSA8C:107;
  end;
end;

theorem Th67:
  I c= s +* Initialized I
proof
  Initialized I c= s +* Initialized I & I c= Initialized I by FUNCT_4:26
,SCMFSA6A:26;
  hence thesis by XBOOLE_1:1;
end;

theorem Th68:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s & I is_halting_onInit s for m being Element of NAT st m <=
  LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) holds Comput(
ProgramPart( (s +* Initialized I))
, (s +* Initialized I),m),
  Comput(ProgramPart((s +* Initialized (loop I))),(s +* Initialized (loop I)),m
) equal_outside NAT
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized (loop I);
  assume
A1: I is_closed_onInit s;
  defpred X[Nat] means $1 <= LifeSpan(ProgramPart(s1),s1) implies Comput(
ProgramPart( s1), s1,$1
  ), Comput(ProgramPart( s2), s2,$1) equal_outside A;
  assume
  I is_halting_onInit s;
  then
A2: ProgramPart s1 halts_on s1 by Def5;
A3: for m being Element of NAT st X[m] holds X[m+1]
  proof
    let m be Element of NAT;
    assume
A4: m <= LifeSpan(ProgramPart(s1),s1) implies Comput(ProgramPart(s1),s1,m),
Comput(ProgramPart(s2
),s2,m)
    equal_outside A;
A5: IC Comput(ProgramPart(s1),s1,m) in dom I by A1,Def4;
    then
A6: IC Comput(ProgramPart(s1),s1,m) in dom loop I by FUNCT_4:105;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,m))/.IC Comput(ProgramPart(s1),s1,m)
 = Comput(ProgramPart(s1),s1,m).IC Comput(ProgramPart(s1),s1,m) by AMI_1:150;
    I c= Comput(ProgramPart(s1),s1,m) by Th67,AMI_1:81;
    then
A7: CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(ProgramPart(s1),s1
,m))
 = I.IC Comput(ProgramPart(s1),s1,m) by A5,Y,GRFUNC_1:8;
S: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,m)
by AMI_1:123;
A8: Comput(ProgramPart(s2),s2,m+1) =
Following(ProgramPart s2,Comput(ProgramPart(s2),s2,m)
)
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,m),Comput(
ProgramPart(s2),s2,m)),
      Comput(ProgramPart(s2),s2,m)) by S;
A9: loop I c= Comput(ProgramPart(s2),s2,m) by Th67,AMI_1:81;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m)
by AMI_1:123;
A10: Comput(ProgramPart(s1),s1,m+1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,m)
)
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(
ProgramPart(s1),s1,m)),
      Comput(ProgramPart(s1),s1,m)) by T;
    assume
A11: m + 1 <= LifeSpan(ProgramPart(s1),s1);
    then m < LifeSpan(ProgramPart(s1),s1) by NAT_1:13;
    then I.IC Comput(ProgramPart(s1),s1,m) <> halt SCM+FSA by A2,A7,T,
AMI_1:def 46;
    then
A12: I.IC Comput(ProgramPart(s1),s1,m) = (loop I).IC Comput(ProgramPart(s1),s1,
m) by FUNCT_4:111;
Z:  (ProgramPart Comput(ProgramPart(s2),s2,m))/.IC Comput(ProgramPart(s2),s2,m)
 = Comput(ProgramPart(s2),s2,m).IC Comput(ProgramPart(s2),s2,m) by AMI_1:150;
    IC Comput(ProgramPart(s1),s1,m) = IC Comput(ProgramPart(s2),s2,m) by A4,A11
,AMI_1:121,NAT_1:13;
    then CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(ProgramPart(
s1),s1,m))
     = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,m),Comput(ProgramPart(s2)
,s2,m))
      by A9,A6,A7,Z,A12,GRFUNC_1:8;
    hence thesis by A4,A11,A10,A8,NAT_1:13,SCMFSA6A:32;
  end;
A13: X[0]
  proof
    assume
    0 <= LifeSpan(ProgramPart(s1),s1);
    s +* I,s equal_outside A & s,s +* loop I equal_outside A by FUNCT_7:28,132;
    then s +* I,s +* loop I equal_outside A by FUNCT_7:29;
    then s +* I +* iS,s +* loop I +* iS equal_outside A by FUNCT_7:106;
    then s +* (I +* iS),s +* loop I +* iS equal_outside A by FUNCT_4:15;
    then s +* (I +* iS),s +* (loop I +* iS) equal_outside A by FUNCT_4:15;
    then s +* (I +* iS),s2 equal_outside A by FUNCT_4:15;
    then s1,s2 equal_outside A by FUNCT_4:15;
    then s1, Comput(ProgramPart( s2), s2,0) equal_outside A by AMI_1:13;
    hence thesis by AMI_1:13;
  end;
  thus for m being Element of NAT holds X[m] from NAT_1:sch 1(A13, A3);
end;

theorem Th69:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s & I is_halting_onInit s for m being Element of NAT st m <
LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) holds
 CurInstr(ProgramPart Comput(ProgramPart( (s +* Initialized I)), (s +*
Initialized I),m),
  Comput(ProgramPart( (s +* Initialized I)), (s +* Initialized I),m))
  = CurInstr(ProgramPart Comput(ProgramPart((s +* Initialized(loop I))),(s +*
Initialized(loop I)),m),
   Comput(ProgramPart((s +* Initialized(loop I))),(s +* Initialized(loop I)),m)
)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized(loop I);
  assume that
A1: I is_closed_onInit s and
A2: I is_halting_onInit s;
  let m be Element of NAT;
A3: IC Comput(ProgramPart(s1),s1,m) in dom I by A1,Def4;
  then
A4: IC Comput(ProgramPart(s1),s1,m) in dom loop I by FUNCT_4:105;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,m))/.IC Comput(ProgramPart(s1),s1,m)
 = Comput(ProgramPart(s1),s1,m).IC Comput(ProgramPart(s1),s1,m) by AMI_1:150;
TX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m)
by AMI_1:123;
  I c= Comput(ProgramPart(s1),s1,m) by Th67,AMI_1:81;
  then
A5: CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1
,m))
 = I.IC Comput(ProgramPart(s1),s1,m) by A3,Y,TX,GRFUNC_1:8;
A6: loop I c= Comput(ProgramPart(s2),s2,m) by Th67,AMI_1:81;
  assume
A7: m < LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I);
Z:  (ProgramPart Comput(ProgramPart(s2),s2,m))/.IC Comput(ProgramPart(s2),s2,m)
 = Comput(ProgramPart(s2),s2,m).IC Comput(ProgramPart(s2),s2,m) by AMI_1:150;
  ProgramPart s1 halts_on s1 by A2,Def5;
  then I.IC Comput(ProgramPart(s1),s1,m) <> halt SCM+FSA by A7,A5,AMI_1:def 46;
  then
A8: I.IC Comput(ProgramPart(s1),s1,m) = (loop I).IC Comput(ProgramPart(s1),s1,m
) by FUNCT_4:111;
  IC Comput(ProgramPart(s1),s1,m) = IC Comput(ProgramPart(s2),s2,m) by A1,A2,A7
,Th68,AMI_1:121;
  hence thesis by A6,A4,A5,A8,Z,TX,GRFUNC_1:8;
end;

theorem Th70:
  for l being Element of NAT holds not l in dom (
  ((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA))
proof
  let l be Element of NAT;
  assume
  l in dom iS;
  then l=intloc 0 or l=IC SCM+FSA by Th1;
  hence contradiction by AMI_1:48,SCMFSA_2:84;
end;

theorem Th71:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s & I is_halting_onInit s
   holds CurInstr(
   ProgramPart Comput(ProgramPart( (s +*Initialized (loop I))), (s +*
Initialized (loop I)),
      LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I)),
   Comput(ProgramPart( (s +*Initialized (loop I))), (s +*Initialized (loop I)),
LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I)))
    = goto  0 & for m
  being Element of NAT st m <= LifeSpan(ProgramPart(s +* Initialized I),s +*
Initialized I)
   holds CurInstr(
  ProgramPart Comput(ProgramPart( (s +* Initialized (loop I))), (s +*
Initialized (loop I)),m),
  Comput(ProgramPart( (s +* Initialized (loop I))), (s +* Initialized (loop I))
,m))
   <> halt SCM+FSA
proof
A1: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:71;
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized loop I;
  assume that
A2: I is_closed_onInit s and
A3: I is_halting_onInit s;
  set k = LifeSpan(ProgramPart(s1),s1);
A4: rng I c= the Instructions of SCM+FSA by RELAT_1:def 19;
A5: IC Comput(ProgramPart(s1),s1,k) in dom I by A2,Def4;
  then IC Comput(ProgramPart(s1),s1,k) in dom (I +* iS) by FUNCT_4:13;
  then
A6: IC Comput(ProgramPart(s1),s1,k) in dom (Initialized I) by FUNCT_4:15;
  dom loop I = dom I by FUNCT_4:105;
  then IC Comput(ProgramPart(s1),s1,k) in dom (loop I +* iS) by A5,FUNCT_4:13;
  then
A7: IC Comput(ProgramPart(s1),s1,k) in dom (Initialized loop I ) by FUNCT_4:15;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,k))/.IC Comput(ProgramPart(s1),s1,k)
 = Comput(ProgramPart(s1),s1,k).IC Comput(ProgramPart(s1),s1,k) by AMI_1:150;
A8: CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(ProgramPart(s1),s1
,k))
 = s1.IC Comput(ProgramPart(s1),s1,k) by Y,AMI_1:54
    .= (Initialized I).IC Comput(ProgramPart(s1),s1,k) by A6,FUNCT_4:14
    .= (I +* iS).IC Comput(ProgramPart(s1),s1,k) by FUNCT_4:15
    .= I.IC Comput(ProgramPart(s1),s1,k) by Th70,FUNCT_4:12;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)))/.IC
Comput(ProgramPart
(s2),s2,LifeSpan(ProgramPart(s1),s1))
 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)).IC Comput(
ProgramPart(s2),s2,LifeSpan(ProgramPart s1,
s1)) by AMI_1:150;
TX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:123;
A9: ProgramPart s1 halts_on s1 by A3,Def5;
  then
A10: CurInstr(ProgramPart s1,Comput(ProgramPart(s1),
s1,k))
 = halt SCM+FSA by AMI_1:def 46;
  IC Comput(ProgramPart(s1),s1,k) = IC Comput(ProgramPart(s2),s2,k) by A2,A3
,Th68,AMI_1:121;
  hence
A11: CurInstr(ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1
)),
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)))
 = s2.IC Comput(ProgramPart(s1),s1,k) by Y,AMI_1:54
    .= (Initialized loop I ).IC Comput(ProgramPart(s1),s1,k) by A7,FUNCT_4:14
    .= (loop I +* iS ).IC Comput(ProgramPart(s1),s1,k) by FUNCT_4:15
    .= (loop I).IC Comput(ProgramPart(s1),s1,k) by Th70,FUNCT_4:12
    .= (((id the Instructions of SCM+FSA) +* (halt SCM+FSA, goto  0))*
  I ).IC Comput(ProgramPart(s1),s1,k) by A4,FUNCT_7:118
    .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA, goto  0)).
  halt SCM+FSA by A10,A5,A8,TX,FUNCT_1:23
    .= goto  0 by A1,FUNCT_7:33;
  let m be Element of NAT;
  assume
A12: m <= LifeSpan(ProgramPart(s1),s1);
TX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m)
by AMI_1:123;
  per cases by A12,XXREAL_0:1;
  suppose
A13: m < LifeSpan(ProgramPart(s1),s1);
    then CurInstr(ProgramPart s1,Comput(ProgramPart(
s1),s1,m))
     <> halt SCM+FSA by A9,AMI_1:def 46;
    hence thesis by A2,A3,A13,Th69,TX;
  end;
  suppose
    m = LifeSpan(ProgramPart(s1),s1);
    hence thesis by A11,SCMFSA_2:47,124;
  end;
end;

canceled;

theorem Th73:
  for s being State of SCM+FSA, I being good InitHalting Program
of SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.intloc
  0 = 1 & s.a > 0 holds loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s
proof
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  set P = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
  reconsider I1 = I ';' SubFrom(a,intloc 0) as InitHalting Program of SCM+FSA;
  set i = a =0_goto  (card I1 + 3);
  defpred P[Nat] means for s being State of SCM+FSA st s.intloc 0 =
  1 & s.a = $1 & s.a > 0 holds ( Comput(ProgramPart( (s +* Initialized (loop P)
)), (s +* Initialized (loop P)), (
  LifeSpan(ProgramPart(s +* Initialized P),s +* Initialized P) + 1))).a = s.a -
1 & ( Comput(ProgramPart( (s
+*
Initialized (loop P) )), (s +*
Initialized (loop P) ), (LifeSpan(ProgramPart(s +* Initialized P),s +*
Initialized P) + 1))).intloc 0 = 1 & ex
  k being Element of NAT st IC Comput(ProgramPart( (s +* Initialized(loop P))),
(s +* Initialized(loop P)),k) =
   card ProgramPart loop P & for n being Element of NAT st n < k holds IC
  Comput(ProgramPart( (s +* Initialized (loop P))), (s +* Initialized (loop P))
,n) in dom loop P;
  assume
A1: I does_not_destroy a;
A2: for k being Element of NAT holds P[k] implies P[k + 1]
  proof
A3: now
      InsCode i = 7 by SCMFSA_2:48;
      then
A4:    0 in dom Macro i & (Macro i). 0 <> halt SCM+FSA by SCMFSA6B:32,33
,SCMFSA_2:124;
      P = i ';' I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA by SCMFSA8B:def 1
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1)) ';' Goto
       2 ';' Stop SCM+FSA by SCMFSA6A:71
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2) ';' Stop SCM+FSA by SCMFSA6A:71
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA) by SCMFSA6A:71
        .= Macro i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA);
      hence P. 0 = (Macro i). 0 by A4,SCMFSA6A:54
        .= i by SCMFSA6B:33;
      hence P. 0 <> halt SCM+FSA by SCMFSA_2:48,124;
A5:   card P = card Goto  2 + card I1 + 4 by SCMFSA8B:14
        .= card I1 + 1 + 4 by SCMFSA8A:29
        .= card I1 + 3 + 2;
      hence  0 in dom P by AFINSQ_1:70;
      card loop P = card dom loop P by CARD_1:104
        .= card dom P by FUNCT_4:105
        .= card P by CARD_1:104;
      then card ProgramPart loop P = card I1 + (3 + 2) by A5,AMI_1:105;
      hence P. (card I1 + 3) = goto  card ProgramPart loop P
      by SCMFSA8C:116;
      hence P. (card I1 + 3) <> halt SCM+FSA by SCMFSA_2:47,124;
      hereby
        card I1 + 3 + 0 < card P by A5,XREAL_1:8;
        hence  (card I1 + 3) in dom P by AFINSQ_1:70;
      end;
    end;
    let k be Element of NAT;
    assume
A6: P[k];
    let ss be State of SCM+FSA;
    assume
A7: ss.intloc 0 = 1;
    set s2 = ss +* Initialized (loop P );
    set s1 = ss +* Initialized P;
    assume
A8: ss.a = k + 1;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(
s1),s1))
by AMI_1:123;
A9: Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1) =
Following(ProgramPart s2,Comput(ProgramPart
(s2),s2,LifeSpan(ProgramPart(s1),s1)))
    by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(
ProgramPart(s1),s1)),
      Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1))), Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart s1,
    s1))) by T;
    set s3 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1);
    assume
A10: ss.a > 0;
A11: I1 is_closed_onInit ss & I1 is_halting_onInit ss by Th35,Th36;
    then
A12: P is_halting_onInit ss by A10,Th45;
    P is_closed_onInit ss by A10,A11,Th45;
    then
A13: Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1) = Exec(goto  0,
Comput(ProgramPart
(s2),s2,
    LifeSpan(ProgramPart(s1),s1))) by A12,A9,Th71;
A14: P is_closed_onInit ss by A10,A11,Th45;
A15: now
A16:  I1 is_halting_onInit ss by Th36;
      then
A17:  I1 is_halting_on Initialize ss by Th41;
      I1 is_closed_onInit ss by Th35;
      then
      IExec(P,ss) = IExec(I1,ss) +* Start-At( (card Goto  2 +
      card I1 + 3),SCM+FSA) by A10,A16,Th46;
      then
A18:  IExec(P,ss).a = IExec(I1,ss).a by SCMFSA_3:11;
A19:  card P = card Goto  2 + card I1 + 4 by SCMFSA8B:14
        .= card I1 + 1 + 4 by SCMFSA8A:29
        .= card I1 + 3 + 2;
A20:  card loop P = card dom loop P by CARD_1:104
        .= card dom P by FUNCT_4:105
        .= card P by CARD_1:104;
      hereby
        thus  0 in dom loop P by A20,A19,AFINSQ_1:70;
        card I1 + 3 + (1 + 1) = (card I1 + 3 + 1) + 1;
        then card I1 + 3 + 1 < card P by A19,NAT_1:13;
        then card I1 + 3 < card loop P by A20,NAT_1:13;
        hence  (card I1 + 3) in dom loop P by AFINSQ_1:70;
      end;
      consider Is being State of SCM+FSA such that
A21:  Is = Initialize ss +* Initialized P;
      Initialize Initialize ss = Initialize ss by SCMFSA8C:15;
      then
A22:  Is = Initialize ss +* (P +* Start-At( 0,SCM+FSA))
by A21,SCMFSA8A:13;
      I1 is_closed_onInit ss by Th35;
      then
A23:  I1 is_closed_on Initialize ss by Th40;
      I1 is_halting_onInit ss by Th36;
      then
A24:  I1 is_halting_on Initialize ss by Th41;
A25:  (Initialize ss).a > 0 by A10,SCMFSA6C:3;
      then
A26:  P is_halting_on Initialize ss by A23,A24,SCMFSA8B:18;
      thus
A27:  Initialize ss +* Initialized P = ss +* Initialized P by SCMFSA8A:8;
A28:  now
        let b be Int-Location;
        Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).b = Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)).b
        by A13,SCMFSA_2:95;
        hence Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).b =
Comput(ProgramPart(
Is), Is,LifeSpan(ProgramPart(Is),Is)).b
        by A12,A14,A27,A21,Th68,SCMFSA6A:30;
      end;
      then Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).a = Comput
(ProgramPart( Is)
, Is,LifeSpan(ProgramPart(Is),Is)).a
        .= IExec(P,ss).a by A22,A26,SCMFSA8C:87;
      hence Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).a =
Comput(ProgramPart( (
Initialize ss +* (
I1 +* Start-At( 0,SCM+FSA)))), (Initialize ss +* (
I1 +* Start-At( 0,SCM+FSA))), (LifeSpan(ProgramPart(Initialize ss +* (I1 +*
Start-At( 0,SCM+FSA)
      )),Initialize ss +* (I1 +*
Start-At( 0,SCM+FSA)
      )))).a by A17,A18,SCMFSA8C:87
        .= ss.a - 1 by A1,Th64;
A29:  P is good by SCMFSA8C:115;
A30:  P is_closed_on Initialize ss by A25,A23,A24,SCMFSA8B:18;
      Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).intloc 0 =
Comput(ProgramPart(Is), Is,LifeSpan(ProgramPart Is,Is)).intloc 0 by A28
        .= 1 by A22,A26,A30,A29,SCMFSA8C:96;
      hence Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).intloc 0
= 1;
    end;
    hence s3.a = ss.a - 1 & s3.intloc 0 = 1;
A31: IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1)=  0 by A13,
SCMFSA_2:95;
    hereby
      per cases;
      suppose
A32:    k = 0;
        take m = LifeSpan(ProgramPart(s1),s1) + 1 + 1 + 1;
A33:    s2 = ss +* (loop P +* Start-At( 0,SCM+FSA)) by A7,SCMFSA8C:18;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1))/.
IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1)
 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).IC Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)+1) by AMI_1:150;
A34:    CurInstr(ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1)
,s1)+1),
           Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1))
 = s2. 0 by A31,Y,AMI_1:54
          .= (loop P). 0 by A15,A33,SCMFSA8C:26
          .= i by A3,FUNCT_4:111;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1))/.
IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1)
 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1).
 IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1) by AMI_1:150;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(
s1),s1)+1)
by AMI_1:123;
A35:    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1) =
Following(ProgramPart s2,
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1)) by AMI_1:14
          .= Exec(i,Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1))
by A34,T;
        then IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1) =
(card I1 + 3) by A8,A15,A32,SCMFSA_2:96;
        then
A36:    CurInstr(ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1)
,s1)+1+1),
         Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1))
 = s2. (card I1 + 3
        ) by Y,AMI_1:54
          .= (loop P). (card I1 + 3) by A15,A33,SCMFSA8C:26
          .= goto  card ProgramPart loop P by A3,FUNCT_4:111;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(
s1),s1)+1+1)
by AMI_1:123;
        Comput(ProgramPart(s2),s2,m) =
        Following(ProgramPart s2,
        Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1)) by
AMI_1:14
          .= Exec(goto  card ProgramPart loop P, Comput(ProgramPart(s2),s2,
        LifeSpan(ProgramPart(s1),s1)+1+1)) by A36,T;
        hence IC Comput(ProgramPart(s2),s2,m) =  card ProgramPart loop P by
SCMFSA_2:95;
        hereby
          let n be Element of NAT;
          assume
          n < m;
          then n <= LifeSpan(ProgramPart(s1),s1) + 1 + 1 by NAT_1:13;
          then
A37:      n <= LifeSpan(ProgramPart(s1),s1) + 1 or n = LifeSpan(ProgramPart(s1)
,s1) + 1 + 1 by NAT_1:8;
          per cases by A37,NAT_1:8;
          suppose
A38:        n <= LifeSpan(ProgramPart(s1),s1);
A39:        I1 is_closed_onInit ss & I1 is_halting_onInit ss by Th35,Th36;
            then
A40:        P is_closed_onInit ss by A10,Th45;
            P is_halting_onInit ss by A10,A39,Th45;
            then Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s2),s2,n)
equal_outside A by A38,A40,Th68;
            then
A41:        IC Comput(ProgramPart(s2),s2,n) = IC Comput(ProgramPart(s1),s1,n)
by SCMFSA8A:6;
            IC Comput(ProgramPart(s1),s1,n) in dom P by A40,Def4;
            hence IC Comput(ProgramPart(s2),s2,n) in dom loop P by A41,
FUNCT_4:105;
          end;
          suppose
            n = LifeSpan(ProgramPart(s1),s1) + 1;
            hence IC Comput(ProgramPart(s2),s2,n) in dom loop P by A13,A15,
SCMFSA_2:95;
          end;
          suppose
            n = LifeSpan(ProgramPart(s1),s1) + 1 + 1;
            hence IC Comput(ProgramPart(s2),s2,n) in dom loop P by A8,A15,A32
,A35,SCMFSA_2:96;
          end;
        end;
      end;
      suppose
A42:    k > 0;
        consider Is3 being State of SCM+FSA such that
A43:    Is3 = Initialize s3;
        ProgramPart (loop P) c= s3 by Th67,AMI_1:99;
        then
A44:    loop P c= s3 by AMI_1:105;
        Is3.intloc 0 = 1 & Is3.a = k by A8,A15,A43,SCMFSA6C:3;
        then consider m0 being Element of NAT such that
A45:    IC Comput(ProgramPart( (Is3 +* Initialized (loop P))), (Is3 +*
Initialized (loop P)),m0) =
        card ProgramPart loop P and
A46:    for n being Element of NAT st n < m0 holds IC Comput(ProgramPart( (
        Is3 +* Initialized (loop P))), (
        Is3 +* Initialized (loop P)),n) in dom loop P by A6,A42;
        take m = LifeSpan(ProgramPart(s1),s1) + 1 + m0;
T: ProgramPart s3 = ProgramPart s2
by AMI_1:123;
A47:    Initialize s3 +* Initialized loop P = s3 +* Initialized loop P by
SCMFSA8A:8
          .= s3 +* (loop P +* iS) by FUNCT_4:15
          .= s3 +* loop P +* iS by FUNCT_4:15
          .= s3 +* iS +* loop P by Th19
          .= s3 +* ((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA) +*
          loop P by FUNCT_4:15
          .= Initialize s3 +* loop P by SCMFSA6C:def 3
          .= s3 +* loop P by A31,A15,SCMFSA8C:14
          .= s3 by A44,FUNCT_4:79;
        hence
        IC Comput(ProgramPart(s2),s2,m) =  card ProgramPart loop P by A43,A45,T
,AMI_1:51;
        hereby
          let n be Element of NAT;
          assume
A48:      n < m;
A49:      I1 is_closed_onInit ss & I1 is_halting_onInit ss by Th35,Th36;
          then
A50:      P is_closed_onInit ss by A10,Th45;
A51:      P is_halting_onInit ss by A10,A49,Th45;
          per cases by NAT_1:13;
          suppose
            n <= LifeSpan(ProgramPart(s1),s1);
            then Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s2),s2,n)
equal_outside A by A50,A51,Th68;
            then
A52:        IC Comput(ProgramPart(s2),s2,n) = IC Comput(ProgramPart(s1),s1,n)
by SCMFSA8A:6;
            IC Comput(ProgramPart(s1),s1,n) in dom P by A50,Def4;
            hence IC Comput(ProgramPart(s2),s2,n) in dom loop P by A52,
FUNCT_4:105;
          end;
          suppose
A53:        LifeSpan(ProgramPart(s1),s1) + 1 <= n;
            consider mm being Element of NAT such that
A54:        mm = n -' (LifeSpan(ProgramPart(s1),s1) + 1);
            n - (LifeSpan(ProgramPart(s1),s1) + 1) >= 0 by A53,XREAL_1:50;
            then
A55:        mm = n - (LifeSpan(ProgramPart(s1),s1) + 1) by A54,XREAL_0:def 2;
T: ProgramPart s2 = ProgramPart s3
by AMI_1:123;
            mm + (LifeSpan(ProgramPart(s1),s1) + 1) = n by A53,A54,XREAL_1:237;
            then
A56:        IC Comput(ProgramPart(s2),s2,n) = IC Comput(ProgramPart( s2), s3,mm
) by AMI_1:51;
            m0 = m - (LifeSpan(ProgramPart(s1),s1) + 1);
            then mm < m0 by A48,A55,XREAL_1:11;
            hence IC Comput(ProgramPart(s2),s2,n) in dom loop P by A43,A46,A47
,A56,T;
          end;
        end;
      end;
    end;
  end;
  assume
A57: s.intloc 0 = 1;
  assume
A58: s.a > 0;
  then reconsider sa = s.a as Element of NAT by INT_1:16;
A59: P[0];
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A59,A2);
  then P[sa];
  then
A60: ex k being Element of NAT st IC Comput(ProgramPart( (s +* Initialized(loop
P))
  ), (s +* Initialized(loop P))
  ,k) =  card ProgramPart loop P & for n being Element of NAT st n < k
  holds IC Comput(ProgramPart( (s +* Initialized(loop P))), (s +* Initialized(
loop P)),n) in dom loop P by A57,A58;
  s +* Initialized(loop P)= s +* (loop P +* Start-At( 0,SCM+FSA)) by A57,
SCMFSA8C:18;
  hence thesis by A60,SCMFSA8A:def 3;
end;

theorem
  for s being State of SCM+FSA, I being good InitHalting Program of
  SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.a > 0
  holds Initialized loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
A2: (Initialize s).a = s.a & (Initialize s).intloc 0 = 1 by SCMFSA6C:3;
  assume
  s.a > 0;
  then
  loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) is_pseudo-closed_on
  Initialize s by A1,A2,Th73;
  hence thesis by SCMFSA8C:47;
end;

theorem
  for s being State of SCM+FSA, I being good InitHalting Program of
SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.intloc 0 =
  1 holds Times(a,I) is_closed_on s & Times(a,I) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  assume
A2: s.intloc 0 = 1;
  per cases;
  suppose
A3: s.a > 0;
    Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) = loop
    if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) by SCMFSA6A:63;
    then Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
    is_pseudo-closed_on s by A1,A2,A3,Th73;
    hence thesis by A3,SCMFSA8C:68;
  end;
  suppose
A4: s.a <= 0;
    Stop SCM+FSA is_closed_on s & Stop SCM+FSA is_halting_on s by SCMFSA7B:24
,25;
    hence thesis by A4,SCMFSA8B:24;
  end;
end;

theorem
  for I being good InitHalting Program of SCM+FSA, a being read-write
  Int-Location st I does_not_destroy a holds Initialized Times(a,I) is halting
proof
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  now
    let s be State of SCM+FSA;
    per cases;
    suppose
      s.a > 0;
      then
A2:   (Initialize s).a > 0 by SCMFSA6C:3;
      (Initialize s).intloc 0 = 1 & Directed loop if=0(a,Goto  2,I
';' SubFrom(a,intloc 0)) = loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
      by SCMFSA6A:63,SCMFSA6C:3;
      then Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
      is_pseudo-closed_on Initialize s by A1,A2,Th73;
      then Times(a,I) is_halting_on Initialize s by A2,SCMFSA8C:68;
      hence Initialized Times(a,I) is_halting_on s by SCMFSA8C:22;
    end;
    suppose
A3:   s.a <= 0;
A4:   Stop SCM+FSA is_closed_on Initialize s & Stop SCM+FSA is_halting_on
      Initialize s by SCMFSA7B:24,25;
      (Initialize s).a <= 0 by A3,SCMFSA6C:3;
      then Times(a,I) is_halting_on Initialize s by A4,SCMFSA8B:24;
      hence Initialized Times(a,I) is_halting_on s by SCMFSA8C:22;
    end;
  end;
  hence thesis by SCMFSA8C:24;
end;

registration
  let a be read-write Int-Location,I be good Program of SCM+FSA;
  cluster Times(a,I) -> good;
  coherence
  proof
    set i=SubFrom(a,intloc 0);
    reconsider Mi=Macro i as good Program of SCM+FSA by SCMFSA7B:14,SCMFSA8C:99
;
    I ';' Mi is good;
    then reconsider Ii=I ';' i as good Program of SCM+FSA;
    if>0(a,loop if=0(a,Goto  2,Ii), Stop SCM+FSA) is good;
    hence thesis;
  end;
end;

theorem Th77:
  for s being State of SCM+FSA, I being good InitHalting Program
  of SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.a > 0
  holds ex s2 being State of SCM+FSA, k being Element of NAT st s2 = s +*
  Initialized (loop if=0(a,Goto  2, I ';' SubFrom(a,intloc 0))) & k =
LifeSpan(ProgramPart(s +* Initialized (if=0(a,Goto  2, I ';' SubFrom(a,intloc 0
)))),s +* Initialized (if=0(a,Goto  2, I ';' SubFrom(a,intloc 0))))
  + 1 & Comput(ProgramPart(s2),s2,k).a = s.a - 1 & Comput(ProgramPart(s2),s2,k)
.intloc 0 = 1 & (for b
being read-write Int-Location st b <> a holds Comput(ProgramPart(s2),s2,k).b =
IExec(I,s).
  b) & (for f being FinSeq-Location holds Comput(ProgramPart(s2),s2,k).f =
IExec(I,s).f) &
IC Comput(ProgramPart(s2),s2,k) =  0 & for n being Element of NAT st n <= k
holds IC
Comput(ProgramPart( s2), s2,n) in dom loop if=0(a,Goto  2,I ';' SubFrom(a,
intloc 0))
proof
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  reconsider I1 = I ';' SubFrom(a,intloc 0) as InitHalting Program of SCM+FSA;
  set P = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
  assume
A2: s.a > 0;
  set Is = Initialize s +* Initialized P;
  take s2 = s +* Initialized loop P;
  set s1 = s +* Initialized P;
  take k = LifeSpan(ProgramPart(s1),s1) + 1;
  thus s2 = s +* Initialized (loop if=0(a,Goto  2, I ';' SubFrom(a,
  intloc 0))) & k = LifeSpan(ProgramPart(s +* Initialized (if=0(a,Goto  2, I
';'
  SubFrom(a,intloc 0)))),s +* Initialized (if=0(a,Goto  2, I ';'
  SubFrom(a,intloc 0)))) + 1;
  Initialize Initialize s = Initialize s by SCMFSA8C:15;
  then
A3: Is = Initialize s +* (P +* Start-At( 0,SCM+FSA)) by SCMFSA8A:13;
A4: P is good by SCMFSA8C:115;
A5: I1 is_halting_onInit s by Th36;
  then
A6: I1 is_halting_on Initialize s by Th41;
  I1 is_closed_onInit s by Th35;
  then
A7: IExec(P,s) = IExec(I1,s) +* Start-At( (card Goto  2 + card
  I1 + 3),SCM+FSA) by A2,A5,Th46;
  then
A8: IExec(P,s).a = IExec(I1,s).a by SCMFSA_3:11;
  I1 is_closed_onInit s & I1 is_halting_onInit s by Th35,Th36;
  then
A9: P is_closed_onInit s & P is_halting_onInit s by A2,Th45;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(
s1),s1))
by AMI_1:123;
  Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1) =
  Following(ProgramPart s2,
  Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1))) by AMI_1:14
    .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart
(s1),s1)),
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1))),Comput(ProgramPart
(s2),s2,LifeSpan(ProgramPart s1,
s1))
  ) by T;
  then
A10: Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1) = Exec(goto  0,
Comput(ProgramPart
(s2),s2,
  LifeSpan(ProgramPart(s1),s1))) by A9,Th71;
A11: I1 is_closed_onInit s & I1 is_halting_onInit s by Th35,Th36;
  then P is_closed_onInit s by A2,Th45;
  then
A12: P is_closed_on Initialize s by Th40;
  P is_halting_onInit s by A2,A11,Th45;
  then
A13: P is_halting_on Initialize s by Th41;
A14: Initialize s +* Initialized P = s +* Initialized P by SCMFSA8A:8;
A15: now
    let b be Int-Location;
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).b = Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)).b by A10,SCMFSA_2:95;
    hence Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).b = Comput(
ProgramPart( Is),
Is,LifeSpan(ProgramPart(Is),Is)).b by A9,A14,Th68,SCMFSA6A:30;
  end;
  then Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).a = Comput(
ProgramPart( Is), Is
,LifeSpan(ProgramPart(Is),Is)).a
    .= IExec(P,s).a by A3,A13,SCMFSA8C:87;
  hence Comput(ProgramPart(s2),s2,k).a = Comput(ProgramPart( (Initialize s +* (
I1 +* Start-At(
   0,SCM+FSA)))), (Initialize s +* (I1 +* Start-At(
   0,SCM+FSA))), (LifeSpan(ProgramPart(Initialize s +* (I1 +*
  Start-At( 0,SCM+FSA))),Initialize s +* (I1 +*
  Start-At( 0,SCM+FSA))))).a by A6,A8,SCMFSA8C:87
    .= s.a - 1 by A1,Th64;
  Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).intloc 0 = Comput(
ProgramPart( Is),
Is,LifeSpan(ProgramPart(Is),Is)).
  intloc 0 by A15
    .= 1 by A3,A13,A12,A4,SCMFSA8C:96;
  hence Comput(ProgramPart(s2),s2,k).intloc 0 = 1;
  hereby
    let b be read-write Int-Location;
    assume
A16: b <> a;
    thus Comput(ProgramPart(s2),s2,k).b = Comput(ProgramPart( Is), Is,
    LifeSpan(ProgramPart Is,
Is)).b by A15
      .= IExec(P,s).b by A3,A13,SCMFSA8C:87
      .= IExec(I1,s).b by A7,SCMFSA_3:11
      .= Exec(SubFrom(a,intloc 0),IExec(I,s)).b by Th33
      .= IExec(I,s).b by A16,SCMFSA_2:91;
  end;
  hereby
    let f be FinSeq-Location;
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).f = Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)).f by A10,SCMFSA_2:95;
    hence Comput(ProgramPart(s2),s2,k).f = Comput(ProgramPart( Is), Is,
    LifeSpan(ProgramPart Is,
Is)).f by A9,A14,Th68,SCMFSA6A:31
      .= IExec(P,s).f by A3,A13,SCMFSA8C:87
      .= IExec(I1,s).f by A7,SCMFSA_3:12
      .= Exec(SubFrom(a,intloc 0),IExec(I,s)).f by Th34
      .= IExec(I,s).f by SCMFSA_2:91;
  end;
  thus IC Comput(ProgramPart(s2),s2,k) =  0 by A10,SCMFSA_2:95;
A17: IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1) =  0 by A10,
SCMFSA_2:95;
  hereby
    let n be Element of NAT;
    assume
A18: n <= k;
    per cases by A18,NAT_1:8;
    suppose
A19:  n <= LifeSpan(ProgramPart(s1),s1);
A20:  I1 is_closed_onInit s & I1 is_halting_onInit s by Th35,Th36;
      then
A21:  P is_closed_onInit s by A2,Th45;
      P is_halting_onInit s by A2,A20,Th45;
      then Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s2),s2,n)
equal_outside A by A19,A21,Th68;
      then
A22:  IC Comput(ProgramPart(s2),s2,n) = IC Comput(ProgramPart(s1),s1,n) by
SCMFSA8A:6;
      IC Comput(ProgramPart(s1),s1,n) in dom P by A21,Def4;
      hence IC Comput(ProgramPart( s2), s2,n) in dom loop P by A22,FUNCT_4:105;
    end;
    suppose
A23:  n = LifeSpan(ProgramPart(s1),s1) + 1;
A24:  card P = card Goto  2 + card I1 + 4 by SCMFSA8B:14
        .= card I1 + 1 + 4 by SCMFSA8A:29
        .= card I1 + 3 + 2;
      card loop P = card dom loop P by CARD_1:104
        .= card dom P by FUNCT_4:105
        .= card P by CARD_1:104;
      hence IC Comput(ProgramPart( s2), s2,n) in dom loop P by A17,A23,A24,
AFINSQ_1:70;
    end;
  end;
end;

theorem Th78:
  for s being State of SCM+FSA, I being good InitHalting Program
of SCM+FSA, a being read-write Int-Location st s.intloc 0 = 1 & s.a <= 0 holds
  DataPart IExec(Times(a,I),s) = DataPart s
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.intloc 0 = 1;
  set s0 = Initialize s;
A2: Stop SCM+FSA is_closed_on s0 & Stop SCM+FSA is_halting_on s0 by SCMFSA7B:24
,25;
A3: ( for a being read-write Int-Location holds s0.a = s.a)& for f being
  FinSeq-Location holds s0.f = s.f by SCMFSA6C:3;
A4: s0.intloc 0 = 1 by SCMFSA6C:3;
  assume
  s.a <= 0;
  then
A5: (Initialize s).a <= 0 by SCMFSA6C:3;
A6: IExec(Stop SCM+FSA ';' Stop SCM+FSA,s0) = IExec(Stop SCM+FSA,IExec(Stop
SCM+FSA,s0)) +* Start-At (IC IExec(Stop SCM+FSA,IExec(Stop SCM+FSA,s0)) + card
  Stop SCM+FSA,SCM+FSA) by SCMFSA6B:44;
A7: DataPart IExec(Stop SCM+FSA,s0) = DataPart(Initialize s0 +* Start-At(
   0,SCM+FSA)) by SCMFSA8C:38
    .= DataPart(Initialize s +* Start-At( 0,SCM+FSA)) by SCMFSA8C:15
    .= DataPart s0 by SCMFSA8A:10;
A8: Stop SCM+FSA is_closed_on Initialize s & Stop SCM+FSA is_halting_on
  Initialize s by SCMFSA7B:24,25;
  then Times(a,I) is_closed_on Initialize s & Times(a,I) is_halting_on
  Initialize s by A5,SCMFSA8B:24;
  then DataPart IExec(Times(a,I),s)= DataPart IExec(Times(a,I),s0) by A4,A3,
SCMFSA8C:45
    .= DataPart IExec(Stop SCM+FSA ';' Stop SCM+FSA,s0) by A5,A2,A4,SCMFSA8A:37
,SCMFSA8C:73;
  hence DataPart IExec(Times(a,I),s) = DataPart IExec(Stop SCM+FSA,IExec(Stop
  SCM+FSA,s0)) by A6,SCMFSA8A:10
    .= DataPart IExec(Stop SCM+FSA,s0) by A8,A4,A7,SCMFSA8C:46
    .= DataPart s by A1,A7,SCMFSA8C:27;
  set P = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
end;

theorem Th79:
  for s being State of SCM+FSA, I being good InitHalting Program
  of SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.a > 0
holds IExec(I ';' SubFrom(a,intloc 0),s).a = s.a - 1 & DataPart IExec(Times(a,I
  ),s) = DataPart IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s))
proof
  let s be State of SCM+FSA;
  let I be good InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  reconsider J3 = Macro SubFrom(a,intloc 0) as good Program of SCM+FSA by
SCMFSA7B:14,SCMFSA8C:99;
  set I1 = I ';' SubFrom(a,intloc 0);
  set ss = IExec(I1,s);
  I1 is_closed_onInit s by Th35;
  then
A2: I1 is_closed_on Initialize s by Th40;
  I1 is_halting_onInit s by Th36;
  then
A3: I1 = I ';' J3 & I1 is_halting_on Initialize s by Th41;
  then
A4: ss.intloc 0 = 1 by A2,SCMFSA8C:96;
  set P = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
  set s0 = Initialize s;
  assume
A5: s.a > 0;
  then
A6: s0.a > 0 by SCMFSA6C:3;
  then consider s2 be State of SCM+FSA, k be Element of NAT such that
A7: s2 = s0 +* Initialized loop P and
  k = LifeSpan(ProgramPart(s0 +* Initialized P),s0 +* Initialized P) + 1 and
A8: Comput(ProgramPart(s2),s2,k).a = s0.a - 1 and
A9: Comput(ProgramPart(s2),s2,k).intloc 0 = 1 and
A10: for b being read-write Int-Location st b <> a holds Comput(ProgramPart(s2)
,s2,k
  ).b = IExec(I,s0).b and
A11: for f being FinSeq-Location holds Comput(ProgramPart(s2),s2,k).f = IExec(I
,s0).
  f and
A12: IC Comput(ProgramPart(s2),s2,k) =  0 and
A13: for n being Element of NAT st n <= k holds IC Comput(ProgramPart( s2), s2,
n) in
  dom loop P by A1,Th77;
A14: s2= Initialize s0 +* (loop P +* Start-At( 0,SCM+FSA))
by A7,SCMFSA8A:13
    .= s0 +* (loop P +* Start-At( 0,SCM+FSA)) by SCMFSA8C:15;
A15: now
    let f be FinSeq-Location;
    thus Comput(ProgramPart(s2),s2,k).f = IExec(I,s0).f by A11
      .= Exec(SubFrom(a,intloc 0),IExec(I,s0)).f by SCMFSA_2:91
      .= IExec(I1,s0).f by Th34
      .= IExec(I1,s).f by SCMFSA8C:17;
  end;
  thus
A16: ss.a = Exec(SubFrom(a,intloc 0),IExec(I,s)).a by Th33
    .= IExec(I,s).a - IExec(I,s).intloc 0 by SCMFSA_2:91
    .= IExec(I,s).a - 1 by Th17
    .= s0.a - 1 by A1,Th63
    .= s.a - 1 by SCMFSA6C:3;
  now
    let b be Int-Location;
    per cases;
    suppose
      b = intloc 0;
      hence Comput(ProgramPart(s2),s2,k).b = IExec(I1,s).b by A9,A3,A2,
SCMFSA8C:96;
    end;
    suppose
      b = a;
      hence Comput(ProgramPart(s2),s2,k).b = IExec(I1,s).b by A8,A16,SCMFSA6C:3
;
    end;
    suppose
A17:  b <> a & b <> intloc 0;
      then reconsider bb = b as read-write Int-Location by SF_MASTR:def 5;
      thus Comput(ProgramPart(s2),s2,k).b = IExec(I,s0).bb by A10,A17
        .= Exec(SubFrom(a,intloc 0),IExec(I,s0)).b by A17,SCMFSA_2:91
        .= IExec(I1,s0).b by Th33
        .= IExec(I1,s).b by SCMFSA8C:17;
    end;
  end;
  then
A18: DataPart Comput(ProgramPart(s2),s2,k) = DataPart ss by A15,SCMFSA6A:38;
  set s21 = s0 +* (loop P ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA));
  set ss0 = Initialize ss;
  set s31 = ss0 +* (loop P ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA));
   0 in dom P by SCMFSA8C:54;
  then
A19:  0 in dom loop P by FUNCT_4:105;
A20: s0.intloc 0 = 1 by SCMFSA6C:3;
  then
A21: loop P is_pseudo-closed_on s0 by A1,A6,Th73;
A22: Directed loop P = loop P by SCMFSA6A:63;
  then
A23: Directed loop P is_pseudo-closed_on s0 by A1,A20,A6,Th73;
A24: DataPart IExec(Times(a,I),s0) = DataPart IExec(loop P ';' Stop SCM+FSA,
  s0) by A1,A20,A6,A22,Th73,SCMFSA8C:69;
  per cases;
  suppose
A25: ss.a = 0;
    loop P c= loop P +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
    then
A26: dom loop P c= dom (loop P +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
A27: P. (card I1 + 3) = goto  (card I1 + 5) by SCMFSA8C:65;
    then
A28: P. (card I1 + 3) <> halt SCM+FSA by SCMFSA_2:47,124;
A29: card I1 + (3 + 2) = card I1 + 1 + 4
      .= card Goto  2 + card I1 + 4 by SCMFSA8A:29
      .= card P by SCMFSA8B:14
      .= card dom P by CARD_1:104
      .= card dom loop P by FUNCT_4:105
      .= card loop P by CARD_1:104;
    then card I1 + 3 + 0 < card loop P by XREAL_1:8;
    then
A30:  (card I1 + 3) in dom loop P by AFINSQ_1:70;
    Comput(ProgramPart(s2),s2,k+1). (card I1 + 3) = s2. (card I1 + 3) by
AMI_1:54
      .= (loop P +* Start-At( 0,SCM+FSA)). (card I1 + 3)
      by A14,A30,A26,FUNCT_4:14
      .= (loop P). (card I1 + 3) by A30,SCMFSA6B:7;
    then
A31: Comput(ProgramPart(s2),s2,k+1). (card I1 + 3) = goto  (card I1 + 5)
    by A27,A28,FUNCT_4:111;
    loop P c= loop P +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
    then
A32: dom loop P c= dom (loop P +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
A33: Comput(ProgramPart(s2),s2,k). 0 = s2. 0 by AMI_1:54
      .= (loop P +* Start-At( 0,SCM+FSA)). 0
      by A14,A19,A32,FUNCT_4:14
      .= (loop P). 0 by A19,SCMFSA6B:7;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by AMI_1:150;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:123;
A34: Comput(ProgramPart(s2),s2,k+1) =
Following(ProgramPart s2,Comput(ProgramPart(s2),s2,k)
)
 by AMI_1:14
      .= Exec(Comput(ProgramPart(s2),s2,k). 0,Comput(ProgramPart(s2),s2,k)) by
A12,Y,T;
A35: P. 0 = a =0_goto  (card I1 + 3) by SCMFSA8C:55;
    then P. 0 <> halt SCM+FSA by SCMFSA_2:48,124;
    then
A36: Comput(ProgramPart(s2),s2,k). 0 = a =0_goto  (card I1 + 3) by A33,A35,
FUNCT_4:111;
    then InsCode Comput(ProgramPart(s2),s2,k). 0 = 7 by SCMFSA_2:48;
    then InsCode Comput(ProgramPart(s2),s2,k). 0 in {0,6,7,8} by ENUMSET1:def 2
;
    then
A37: DataPart Comput(ProgramPart(s2),s2,k) = DataPart Comput(ProgramPart(s2),s2
,k+1) by A34,SCMFSA8C:32;
A38: Comput(ProgramPart(s2),s2,k).a = 0 by A8,A16,A25,SCMFSA6C:3;
    then
A39: IC Comput(ProgramPart(s2),s2,k+1) =  (card I1 + 3) by A34,A36,SCMFSA_2:96;
A40: now
      let n be Element of NAT;
      assume
A41:  not IC Comput(ProgramPart( s2), s2,n) in dom loop P;
      then k < n by A13;
      then k + 1 <= n by INT_1:20;
      then k + 1 < n by A39,A30,A41,XXREAL_0:1;
      then k + 1 + 1 <= n by INT_1:20;
      hence k + (1 + 1) <= n;
    end;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,k+1))/.IC Comput(ProgramPart(s2),s2,
k+1)
 = Comput(ProgramPart(s2),s2,k+1).IC Comput(ProgramPart(s2),s2,k+1) by
AMI_1:150;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k+1)
by AMI_1:123;
A42: Comput(ProgramPart(s2),s2,k+(1+1)) = Comput(ProgramPart(s2),s2,k+1+1)
      .= Following(ProgramPart s2,Comput(
ProgramPart(s2),s2,k+1))
       by AMI_1:14
      .= Exec(Comput(ProgramPart(s2),s2,k+1). (card I1 + 3),Comput(ProgramPart(
s2),s2,k+1))
    by A38,A34,A36,Y,T,SCMFSA_2:96;
    then IC Comput(ProgramPart(s2),s2,k+2) =  (card I1 + 5) by A31,SCMFSA_2:95
      .=  card ProgramPart loop P by A29,AMI_1:105;
    then
A43: k + 2 = pseudo-LifeSpan(s0,loop P) by A14,A21,A40,SCMFSA8A:def 5;
    InsCode Comput(ProgramPart(s2),s2,k+1). (card I1 + 3) = 6 by A31,
SCMFSA_2:47;
    then InsCode Comput(ProgramPart(s2),s2,k+1). (card I1 + 3) in {0,6,7,8} by
ENUMSET1:def 2;
    then
A44: DataPart Comput(ProgramPart(s2),s2,k) = DataPart Comput(ProgramPart(s2),s2
,k+2) by A37,A42,SCMFSA8C:32;
X: s21 = s +* Initialized (loop P ';' Stop SCM+FSA) by SCMFSA8A:13;
    thus DataPart IExec(Times(a,I),s) = DataPart IExec(Times(a,I),s0) by
SCMFSA8C:17
      .= DataPart IExec(loop P ';' Stop SCM+FSA,s) by A24,SCMFSA8C:17
      .= DataPart(Result(ProgramPart(s +* Initialized (loop P ';' Stop SCM+FSA)
),s +* Initialized (loop P ';' Stop SCM+FSA)) +* s |
    A) by SCMFSA6B:def 1
      .= DataPart(Result(ProgramPart(s21),s21) +* s | A) by X
      .= DataPart (Result(ProgramPart(s21),s21)) by SCMFSA8C:35
      .= DataPart IExec(I1,s) by A1,A20,A6,A14,A22,A18,A43,A44,Th73,SCMFSA8C:59
      .= DataPart IExec(Times(a,I),IExec(I1,s)) by A4,A25,Th78;
  end;
  suppose
A45: ss.a <> 0;
    s.a >= 0 + 1 by A5,INT_1:20;
    then
A46: ss.a > 0 by A16,A45,XREAL_1:21;
A47: loop P ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA) c= s21 &
loop P ';' Stop
    SCM+FSA +* Start-At( 0,SCM+FSA) c= s31 by FUNCT_4:26;
A48: k < pseudo-LifeSpan(s0,loop P) by A1,A20,A6,A13,A14,Th73,SCMFSA8C:2;
    then
A49: DataPart Comput(ProgramPart( s21), s21,k) = DataPart ss by A14,A22,A23,A18
,SCMFSA8C:58;
A50: now
A51:  DataPart ss0 = DataPart s31 by SCMFSA8A:11;
      hereby
        let a be Int-Location;
        per cases;
        suppose
A52:      a = intloc 0;
          thus Comput(ProgramPart( s21), s21,k).a = ss.a by A49,SCMFSA6A:38
            .= 1 by A52,Th17
            .= ss0.a by A52,SCMFSA6C:3
            .= s31.a by A51,SCMFSA6A:38;
        end;
        suppose
          a <> intloc 0;
          then
A53:      a is read-write Int-Location by SF_MASTR:def 5;
          thus Comput(ProgramPart( s21), s21,k).a = ss.a by A49,SCMFSA6A:38
            .= ss0.a by A53,SCMFSA6C:3
            .= s31.a by A51,SCMFSA6A:38;
        end;
      end;
      let f be FinSeq-Location;
      thus Comput(ProgramPart( s21), s21,k).f = ss.f by A49,SCMFSA6A:38
        .= ss0.f by SCMFSA6C:3
        .= s31.f by A51,SCMFSA6A:38;
    end;
    IC Comput(ProgramPart( s21), s21,k) = IC Comput(ProgramPart(s2),s2,k) by
A14,A22,A23,A48,SCMFSA8C:58
      .= IC (ss0 +* (loop P ';' Stop SCM+FSA) +* Start-At( 0,SCM+FSA))
       by A12,FUNCT_4:121
      .= IC s31 by FUNCT_4:15;
    then
A54: Comput(ProgramPart( s21), s21,k),s31 equal_outside A by A50,SCMFSA6A:28;
A55: ss.intloc 0 = 1 by A3,A2,SCMFSA8C:96;
    Directed loop P = loop P & DataPart s0 = DataPart s21 by SCMFSA6A:63
,SCMFSA8A:11;
    then Directed loop P is_pseudo-closed_on s21 by A1,A20,A6,Th73,SCMFSA8C:52;
    then
A56: loop P ';' Stop SCM+FSA is_closed_on s21 & loop P ';' Stop SCM+FSA
    is_halting_on s21 by SCMFSA8C:58;
X:  s21 = s +* Initialized (loop P ';' Stop SCM+FSA) by SCMFSA8A:13;
Y:  s31 = ss +* Initialized (loop P ';' Stop SCM+FSA) by SCMFSA8A:13;
    DataPart IExec(loop P ';' Stop SCM+FSA,s0) = DataPart IExec(loop P
    ';' Stop SCM+FSA,s) by SCMFSA8C:17
      .= DataPart(Result(ProgramPart(s +* Initialized (loop P ';' Stop SCM+FSA)
),s +* Initialized (loop P ';' Stop SCM+FSA)) +* s |
    A) by SCMFSA6B:def 1
      .= DataPart(Result(ProgramPart(s21),s21) +* s | A) by X
      .= DataPart(Result(ProgramPart(s21),s21)) by SCMFSA8C:35
      .= DataPart(Result(ProgramPart(s31),s31)) by A47,A56,A54,SCMFSA6A:39
,SCMFSA8C:103
      .= DataPart(Result(ProgramPart(s31),s31) +* ss | A) by SCMFSA8C:35
      .= DataPart(Result(ProgramPart(ss +* Initialized (loop P ';' Stop SCM+FSA
)),ss +* Initialized (loop P ';' Stop SCM+FSA)) +* ss|
    A) by Y
      .= DataPart IExec(loop P ';' Stop SCM+FSA,IExec(I1,s)) by SCMFSA6B:def 1
      .= DataPart IExec(Times(a,I),IExec(I1,s)) by A1,A22,A55,A46,Th73,
SCMFSA8C:69;
    hence thesis by A24,SCMFSA8C:17;
  end;
end;

theorem
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, f
be FinSeq-Location,a be read-write Int-Location st s.a <= 0 holds IExec(Times(a
  ,I),s).f=s.f
proof
  set D= Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, f be
  FinSeq-Location,a be read-write Int-Location;
  assume
A1: s.a <= 0;
  set s0 = Initialize s;
A2: s0.a=s.a & s0.(intloc 0)=1 by SCMFSA6C:3;
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A3: f in D by XBOOLE_0:def 3;
  DataPart IExec(Times(a,I),s) = DataPart IExec(Times(a,I),s0) by SCMFSA8C:17
    .= DataPart s0 by A1,A2,Th78;
  hence IExec(Times(a,I),s).f= (DataPart s0).f by A3,FUNCT_1:72,SCMFSA_2:127
    .= s0.f by A3,FUNCT_1:72,SCMFSA_2:127
    .= s.f by SCMFSA6C:3;
end;

theorem
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, b
be Int-Location,a be read-write Int-Location st s.a <= 0 holds IExec(Times(a,I)
  ,s).b=(Initialize s).b
proof
  set D= Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, b be
  Int-Location,a be read-write Int-Location;
  assume
A1: s.a <= 0;
  set s0 = Initialize s;
A2: s0.a=s.a & s0.(intloc 0)=1 by SCMFSA6C:3;
  b in Int-Locations by SCMFSA_2:9;
  then
A3: b in D by XBOOLE_0:def 3;
  DataPart IExec(Times(a,I),s) = DataPart IExec(Times(a,I),s0) by SCMFSA8C:17
    .= DataPart s0 by A1,A2,Th78;
  hence IExec(Times(a,I),s).b= (DataPart s0).b by A3,FUNCT_1:72,SCMFSA_2:127
    .= s0.b by A3,FUNCT_1:72,SCMFSA_2:127;
end;

theorem
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, f
be FinSeq-Location,a be read-write Int-Location st I does_not_destroy a & s.a >
0 holds IExec(Times(a,I),s).f =IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0)
  ,s)).f
proof
  set D= Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, f be
  FinSeq-Location,a be read-write Int-Location;
  assume
A1: I does_not_destroy a & s.a > 0;
  set IT=IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s));
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A2: f in D by XBOOLE_0:def 3;
  hence IExec(Times(a,I),s).f=(DataPart IExec(Times(a,I),s)).f by FUNCT_1:72
,SCMFSA_2:127
    .=(DataPart IT).f by A1,Th79
    .= IT.f by A2,FUNCT_1:72,SCMFSA_2:127;
end;

theorem
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, b
be Int-Location,a be read-write Int-Location st I does_not_destroy a & s.a > 0
holds IExec(Times(a,I),s).b =IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s
  )).b
proof
  set D= Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, b be
  Int-Location,a be read-write Int-Location;
  assume
A1: I does_not_destroy a & s.a > 0;
  set IT=IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s));
  b in Int-Locations by SCMFSA_2:9;
  then
A2: b in D by XBOOLE_0:def 3;
  hence IExec(Times(a,I),s).b=(DataPart IExec(Times(a,I),s)).b by FUNCT_1:72
,SCMFSA_2:127
    .=(DataPart IT).b by A1,Th79
    .= IT.b by A2,FUNCT_1:72,SCMFSA_2:127;
end;

definition
  let i be Instruction of SCM+FSA;
  attr i is good means
  :Def6:
  i does_not_destroy intloc 0;
end;

registration
  cluster parahalting good Instruction of SCM+FSA;
  existence
  proof
    take x=halt SCM+FSA;
    thus x is parahalting;
    x does_not_destroy intloc 0 by SCMFSA7B:11;
    hence thesis by Def6;
  end;
end;

registration
  let i be good Instruction of SCM+FSA, J be good Program of SCM+FSA;
  cluster i ';' J -> good;
  coherence
  proof
    i does_not_destroy intloc 0 by Def6;
    then reconsider Mi=Macro i as good Program of SCM+FSA by SCMFSA8C:99;
    Mi ';' J is good;
    hence thesis;
  end;
  cluster J ';' i -> good;
  coherence
  proof
    i does_not_destroy intloc 0 by Def6;
    then reconsider Mi=Macro i as good Program of SCM+FSA by SCMFSA8C:99;
    J ';' Mi is good;
    hence thesis;
  end;
end;

registration
  let i,j be good Instruction of SCM+FSA;
  cluster i ';' j -> good;
  coherence
  proof
    j does_not_destroy intloc 0 by Def6;
    then reconsider Mj=Macro j as good Program of SCM+FSA by SCMFSA8C:99;
    i does_not_destroy intloc 0 by Def6;
    then reconsider Mi=Macro i as good Program of SCM+FSA by SCMFSA8C:99;
    Mi ';' Mj is good;
    hence thesis;
  end;
end;

registration
  let a be read-write Int-Location,b be Int-Location;
  cluster a := b -> good;
  coherence
  proof
    a := b does_not_destroy intloc 0 by SCMFSA7B:12;
    hence thesis by Def6;
  end;
  cluster SubFrom(a,b) -> good;
  coherence
  proof
    SubFrom(a,b) does_not_destroy intloc 0 by SCMFSA7B:14;
    hence thesis by Def6;
  end;
end;

registration
  let a be read-write Int-Location,b be Int-Location,f be FinSeq-Location;
  cluster a:=(f,b) -> good;
  coherence
  proof
    a:=(f,b) does_not_destroy intloc 0 by SCMFSA7B:20;
    hence thesis by Def6;
  end;
end;

registration
  let a,b be Int-Location,f be FinSeq-Location;
  cluster (f,a):=b -> good;
  coherence
  proof
    (f,a):=b does_not_destroy intloc 0 by SCMFSA7B:21;
    hence thesis by Def6;
  end;
end;

registration
  let a be read-write Int-Location,f be FinSeq-Location;
  cluster a:=len f -> good;
  coherence
  proof
    a:=len f does_not_destroy intloc 0 by SCMFSA7B:22;
    hence thesis by Def6;
  end;
end;

registration
  let n be Element of NAT;
  cluster intloc (n+1) -> read-write;
  coherence
  proof
    intloc (n+1) <> intloc 0 by AMI_3:52;
    hence thesis by SF_MASTR:def 5;
  end;
end;

