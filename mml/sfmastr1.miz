:: On the Composition of non-parahalting Macro Instructions
::  by Piotr Rudnicki
::
:: Received June 3, 1998
:: Copyright (c) 1998-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies AMI_1, SCMFSA_2, SCMFSA7B, SCMFSA6A, SF_MASTR, GRAPHSP, AMI_3,
      SCMFSA6B, TURING_1, AOFA_I00, SCMFSA8C, SCMFSA8B, SCMFSA8A, CARD_1,
      AMISTD_2, RELAT_1, TARSKI, XXREAL_0, ARYTM_3, FSM_1, XBOOLE_0, FUNCT_4,
      NUMBERS, SCMFSA6C, UNIALG_2, CIRCUIT2, FUNCT_1, MSUALG_1, SUBSET_1,
      NAT_1, STRUCT_0, FINSET_1, SCMFSA_1, ZFMISC_1, SCMNORM, PRE_FF, ARYTM_1,
      SFMASTR1, PARTFUN1, RELOC, PBOOLE, FUNCOP_1, COMPOS_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS,
      XCMPLX_0, FINSET_1, NAT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4,
      FUNCOP_1, PBOOLE, FUNCT_7, PRE_FF, STRUCT_0, MEMSTR_0, COMPOS_1,
      EXTPRO_1, AMISTD_1,
      AMISTD_2, SCMFSA_1, SCMFSA_2, SCMFSA6A, SCMFSA6B, SF_MASTR,
      SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B, SCMFSA8C, XXREAL_0, SEQ_4;
 constructors DOMAIN_1, SETWISEO, SEQ_4, PRE_FF, SCM_1, SCMFSA6A, SF_MASTR,
      SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA8C, RELSET_1, PRE_POLY,
      AMISTD_2, SCMFSA7B, SCMFSA_1, PBOOLE, AMISTD_1, COMPLEX1, INT_2, NAT_D,
      XXREAL_1, MEMSTR_0;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, FUNCT_1, ORDINAL1, FINSET_1,
      NUMBERS, XREAL_0, NAT_1, INT_1, MEMBERED, AMI_5, SCMFSA_2, SF_MASTR,
      SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8C, SCMFSA_9, XXREAL_2,
      RELAT_1, SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1, PBOOLE, FUNCT_4,
      FUNCOP_1, SCMFSA6A, STRUCT_0, MEMSTR_0;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions EXTPRO_1, COMPOS_1, SCMFSA_2, SCMFSA7B, FUNCOP_1, SCMFSA6A,
      MEMSTR_0;
 theorems TARSKI, ZFMISC_1, ENUMSET1, NAT_1, RELAT_1, FUNCT_1, FUNCT_2,
      LATTICE2, GRFUNC_1, SUBSET_1, FUNCT_4, PRE_FF, SCMFSA_2, MEMSTR_0,
      SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B,
      SCMFSA8C, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0,
      AMI_3, XXREAL_2, PBOOLE, PARTFUN1, COMPOS_1, EXTPRO_1, AMISTD_2;
 schemes NAT_1, DOMAIN_1, FRAENKEL, RECDEF_1;

begin :: Good instructions and good macro instructions

reserve p,P,P1,P2 for Instruction-Sequence of SCM+FSA;

definition
  let i be Instruction of SCM+FSA;
  attr i is good means
  :Def1:
  Macro i is good;
end;

registration
  let a be read-write Int-Location, b be Int-Location;
  cluster a := b -> good;
  coherence
  proof
    thus Macro (a := b) is good by SCMFSA7B:6,SCMFSA8C:70;
  end;
  cluster AddTo(a, b) -> good;
  coherence
  proof
    thus Macro AddTo(a, b) is good by SCMFSA7B:7,SCMFSA8C:70;
  end;
  cluster SubFrom(a, b) -> good;
  coherence
  proof
    thus Macro SubFrom(a, b) is good by SCMFSA7B:8,SCMFSA8C:70;
  end;
  cluster MultBy(a, b) -> good;
  coherence
  proof
    thus Macro MultBy(a, b) is good by SCMFSA7B:9,SCMFSA8C:70;
  end;
end;

registration
  cluster good parahalting for Instruction of SCM+FSA;
  existence
  proof
    set a =the  read-write Int-Location;
    a:=a is good parahalting;
    hence thesis;
  end;
end;

registration
  let a, b be read-write Int-Location;
  cluster Divide(a, b) -> good;
  coherence
  proof
    thus Macro Divide(a, b) is good by SCMFSA7B:10,SCMFSA8C:70;
  end;
end;

registration
  let l be Element of NAT;
  cluster goto l -> good;
  coherence
  proof
    thus Macro goto l is good by SCMFSA7B:11,SCMFSA8C:70;
  end;
end;

registration
  let a be Int-Location, l be Element of NAT;
  cluster a =0_goto l -> good;
  coherence
  proof
    thus Macro (a =0_goto l) is good by SCMFSA7B:12,SCMFSA8C:70;
  end;
  cluster a >0_goto l -> good;
  coherence
  proof
    thus Macro (a >0_goto l) is good by SCMFSA7B:13,SCMFSA8C:70;
  end;
end;

registration
  let a be Int-Location, f be FinSeq-Location, b be read-write Int-Location;
  cluster b := (f,a) -> good;
  coherence
  proof
    thus Macro (b := (f, a)) is good by SCMFSA7B:14,SCMFSA8C:70;
  end;
end;

registration
  let f be FinSeq-Location, b be read-write Int-Location;
  cluster b :=len f -> good;
  coherence
  proof
    thus Macro (b :=len f) is good by SCMFSA7B:16,SCMFSA8C:70;
  end;
end;

registration
  let f be FinSeq-Location, a be Int-Location;
  cluster f :=<0,...,0> a -> good;
  coherence
  proof
    thus Macro (f :=<0,...,0> a) is good by SCMFSA7B:17,SCMFSA8C:70;
  end;
  let b be Int-Location;
  cluster (f,a) := b -> good;
  coherence
  proof
    thus Macro ((f, a) := b) is good by SCMFSA7B:15,SCMFSA8C:70;
  end;
end;

registration
  let i be good Instruction of SCM+FSA;
  cluster Macro i -> good;
  coherence by Def1;
end;

registration
  let i, j be good Instruction of SCM+FSA;
  cluster i ';' j -> good;
  coherence;
end;

registration
  let i be good Instruction of SCM+FSA, I be good Program of SCM+FSA;
  cluster i ';' I -> good;
  coherence;
  cluster I ';' i -> good;
  coherence;
end;

registration
  let a, b be read-write Int-Location;
  cluster swap(a, b) -> good;
  coherence
  proof
    swap(a, b) = FirstNotUsed Macro (a := b) := a ';' (a := b) ';' (b :=
    FirstNotUsed Macro (a := b)) by SCMFSA6C:def 3;
    hence thesis;
  end;
end;

registration
  let I be good Program of SCM+FSA, a be read-write Int-Location;
  cluster Times(a, I) -> good;
  coherence
  proof
    reconsider J = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) as good
    Program of SCM+FSA;
    if>0(a, loop J, Stop SCM+FSA) is good;
    hence thesis by SCMFSA8C:def 2;
  end;
end;

theorem Th1:
  for a being Int-Location, I being Program of SCM+FSA st not a in
  UsedIntLoc I holds not I destroys a
proof
  let aa be Int-Location, I be Program of SCM+FSA such that
A1: not aa in UsedIntLoc I;
  let i be Instruction of SCM+FSA;
  assume i in rng I;
  then UsedIntLoc i c= UsedIntLoc I by SF_MASTR:19;
  then
A2: not aa in UsedIntLoc i by A1;
A5: InsCode i <= 12 by SCMFSA_2:16;
  per cases by A5,NAT_1:36;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:95;
    hence thesis by SCMFSA7B:5;
  end;
  suppose
    InsCode i = 1;
    then consider a, b be Int-Location such that
A6: i = a:=b by SCMFSA_2:30;
    UsedIntLoc i = {a, b} by A6,SF_MASTR:14;
    then a in UsedIntLoc i by TARSKI:def 2;
    hence thesis by A2,A6,SCMFSA7B:6;
  end;
  suppose
    InsCode i = 2;
    then consider a, b be Int-Location such that
A7: i = AddTo(a,b) by SCMFSA_2:31;
    UsedIntLoc i = {a, b} by A7,SF_MASTR:14;
    then a in UsedIntLoc i by TARSKI:def 2;
    hence thesis by A2,A7,SCMFSA7B:7;
  end;
  suppose
    InsCode i = 3;
    then consider a, b be Int-Location such that
A8: i = SubFrom(a, b) by SCMFSA_2:32;
    UsedIntLoc i = {a, b} by A8,SF_MASTR:14;
    then a in UsedIntLoc i by TARSKI:def 2;
    hence thesis by A2,A8,SCMFSA7B:8;
  end;
  suppose
    InsCode i = 4;
    then consider a, b be Int-Location such that
A9: i = MultBy(a, b) by SCMFSA_2:33;
    UsedIntLoc i = {a, b} by A9,SF_MASTR:14;
    then a in UsedIntLoc i by TARSKI:def 2;
    hence thesis by A2,A9,SCMFSA7B:9;
  end;
  suppose
    InsCode i = 5;
    then consider a, b be Int-Location such that
A10: i = Divide(a, b) by SCMFSA_2:34;
A11: UsedIntLoc i = {a, b} by A10,SF_MASTR:14;
    then
A12: b in UsedIntLoc i by TARSKI:def 2;
    a in UsedIntLoc i by A11,TARSKI:def 2;
    hence thesis by A2,A10,A12,SCMFSA7B:10;
  end;
  suppose
    InsCode i = 6;
    then ex l be Element of NAT st i = goto l by SCMFSA_2:35;
    hence thesis by SCMFSA7B:11;
  end;
  suppose
    InsCode i = 7;
    then
    ex l be Element of NAT, a being Int-Location st i =
    a=0_goto l by SCMFSA_2:36;
    hence thesis by SCMFSA7B:12;
  end;
  suppose
    InsCode i = 8;
    then
    ex l be Element of NAT, a being Int-Location st i =
    a>0_goto l by SCMFSA_2:37;
    hence thesis by SCMFSA7B:13;
  end;
  suppose
    InsCode i = 9;
    then consider a, b be Int-Location, f be FinSeq-Location such that
A13: i = b:=(f,a) by SCMFSA_2:38;
    UsedIntLoc i = {a, b} by A13,SF_MASTR:17;
    then b in UsedIntLoc i by TARSKI:def 2;
    hence thesis by A2,A13,SCMFSA7B:14;
  end;
  suppose
    InsCode i = 10;
    then ex a, b be Int-Location, f be FinSeq-Location st i = (f,a) :=b by
SCMFSA_2:39;
    hence thesis by SCMFSA7B:15;
  end;
  suppose
    InsCode i = 11;
    then consider a be Int-Location, f be FinSeq-Location such that
A14: i = a:=len f by SCMFSA_2:40;
    UsedIntLoc i = {a} by A14,SF_MASTR:18;
    then a in UsedIntLoc i by TARSKI:def 1;
    hence thesis by A2,A14,SCMFSA7B:16;
  end;
  suppose
    InsCode i = 12;
    then
    ex a be Int-Location, f be FinSeq-Location st i = f :=<0,...,0>a by
SCMFSA_2:41;
    hence thesis by SCMFSA7B:17;
  end;
end;

begin :: Composition of non parahalting macro instructions

reserve s, S for State of SCM+FSA,
  I, J for Program of SCM+FSA,
  Ig for good Program of SCM+FSA,
  i for good parahalting Instruction of SCM+FSA,
  j for parahalting Instruction of SCM+FSA,
  a, b for Int-Location,
  f for FinSeq-Location;

set D = Data-Locations SCM+FSA;
set SAt = Start-At(0,SCM+FSA);



theorem Th3:
  I is_halting_on Initialized S,P & I is_closed_on Initialized S,P &
  J is_closed_on IExec(I,P,S),P implies
  I ';' J is_closed_on Initialized S,P
proof
  assume that
A1: I is_halting_on Initialized S,P and
A2: I is_closed_on Initialized S,P and
A3: J is_closed_on IExec(I,P,S),P;
  set IS = Initialized S,
      PS = P;
  set s = Initialize IS,
      p = P +* (I ';' J);
A6: I ';' J c= p by FUNCT_4:25;
A7: Directed I c= I ';' J by SCMFSA6A:16;
   I ';' J c= p by FUNCT_4:25;
   then Directed I c= p by A7,XBOOLE_1:1;
   then
A8: p +* Directed I = p by FUNCT_4:98;
A9: DataPart IS = DataPart s by MEMSTR_0:79;
  then
A10: I is_closed_on s,p by A2,SCMFSA8B:3;
A11: I is_halting_on s,p by A1,A2,A9,SCMFSA8B:5;
  then
A12: p+*I halts_on Initialize s by SCMFSA7B:def 7;
  set s1 = Initialize s,
      p1 = p +* I;
  set JAt = Start-At(0,SCM+FSA);
  set s3 = Initialize Comput(p1,s1,LifeSpan(p1,s1)),
      p3 = p1+*J;
A13: J c= p3 by FUNCT_4:25;
  set m1 = LifeSpan(p1,s1);
  set IJ = I ';' J;
A15: IS.intloc 0 = 1 by SCMFSA6A:38;
  then s.intloc 0 = 1 by A9,SCMFSA6A:7;
  then
A16: Initialized s1 = s by SCMFSA8C:4;
  DataPart IExec(I,P,S) = DataPart IExec(I,P,IS) by SCMFSA8C:3
    .= DataPart IExec(I,p,s) by A1,A2,A9,A15,SCMFSA8C:20
    .= DataPart(Result(p+*I,Initialized s)) by SCMFSA6B:def 1
    .= DataPart Comput(p1,s1,LifeSpan(p1,s1)) by A16,A12,EXTPRO_1:23;
  then DataPart IExec(I,P,S) = DataPart s3 by MEMSTR_0:79;
  then
A17: J is_closed_on s3,p3 by A3,SCMFSA8B:3;
  set PPR = Reloc(J,card I);
  set s4 = Comput(p,s,m1+1);
  reconsider kk = DataPart JAt as Function;
A18: DataPart s3 = DataPart Comput(p1,s1,m1) +* kk by FUNCT_4:71;
  let k be Element of NAT;
   IC Comput(p+*Directed I, s,
    (LifeSpan(p+*I,Initialize s) + 1)) = card I
            by A10,A11,SCMFSA8A:22;
   then
A22: IC s4 =  card I by A8;
  DataPart JAt = {} by MEMSTR_0:20;
  then DataPart Comput(p1,s1,m1) = DataPart s3 by A18,FUNCT_4:98,XBOOLE_1:2;
  then
A23: DataPart s4 = DataPart s3 by A10,A11,A8,SCMFSA8A:22;
A24: PPR c= I ';' J by FUNCT_4:25;
A25: PPR c= p by A6,A24,XBOOLE_1:1;
  per cases by NAT_1:13;
  suppose
A26: k <= m1;
A27: dom I c= dom IJ by SCMFSA6A:17;
A28: IC Comput(p1,s1,k) in dom I by A10,SCMFSA7B:def 6;
     Comput(p1,s1,k) =  Comput(p, s,k)
     by A10,A11,A26,A8,SCMFSA8A:21;
    then IC Comput(p1,s1,k) = IC Comput(p, s,k);
    hence thesis by A28,A27;
  end;
  suppose
    m1+1 <= k;
    then consider i being Nat such that
A29: k = m1+1+i by NAT_1:10;
    reconsider i as Element of NAT by ORDINAL1:def 12;
    reconsider jloc = IC Comput(p3, s3,i) as Element of NAT;
A30:  s3 = Initialize s3;
    p3+*J = p3 by FUNCT_4:93;
    then
A31: IC Comput(p3, s3,i) in dom J by A17,A30,SCMFSA7B:def 6;
    dom PPR
    = { j+card I where j is Element of NAT : j in dom J } by COMPOS_1:33;
    then
A32:  (jloc+card I) in dom PPR by A31;
A33: dom PPR c= dom IJ by A24,RELAT_1:11;
    IC Comput(p3, s3,i) + card I
    = IC Comput(p, Comput(p, s,m1+1),i)
     by A22,A23,A17,A13,A25,SCMFSA8C:16
      .= IC Comput(p, s,m1+1+i) by EXTPRO_1:4;
    hence thesis by A29,A32,A33;
  end;
end;

theorem Th4: :: SCMFSA6B:27
  I is_halting_on Initialized S,P & J is_halting_on IExec(I,P,S),P & I
  is_closed_on Initialized S,P & J is_closed_on IExec(I,P,S),P implies
   I ';' J is_halting_on Initialized S,P
proof
  assume that
A1: I is_halting_on Initialized S,P and
A2: J is_halting_on IExec(I,P,S),P and
A3: I is_closed_on Initialized S,P and
A4: J is_closed_on IExec(I,P,S),P;
  set s = Initialize Initialized S,
      p = P +* (I ';' J);
A7:  I ';' J c= p by FUNCT_4:25;
   Directed I c= I ';' J by SCMFSA6A:16;
   then Directed I c= p by A7,XBOOLE_1:1;
   then
A8: p +*  Directed I = p by FUNCT_4:98;
A9: DataPart Initialized S = DataPart s by MEMSTR_0:79;
  then
A10: I is_halting_on s,p by A1,A3,SCMFSA8B:5;
  then
A11: p+*I halts_on Initialize s by SCMFSA7B:def 7;
  set s1 = Initialize s,
      p1 = p +* I;
A12: (Initialized S).intloc 0 = 1 by SCMFSA6A:38;
  then s.intloc 0 = 1 by A9,SCMFSA6A:7;
  then
A13: s1 = Initialized s by SCMFSA8C:4;
  set JAt = Start-At(0,SCM+FSA);
  set s3 = Initialize Comput(p1,s1,LifeSpan(p1,s1)),
      p3 = p1 +* J;
A14: J c= p3 by FUNCT_4:25;
  set m3 = LifeSpan(p3,s3);
A15: DataPart IExec(I,P,S) = DataPart IExec(I,P,Initialized S)
by SCMFSA8C:3
    .= DataPart IExec(I,p,s) by A1,A3,A9,A12,SCMFSA8C:20
    .= DataPart(Result(p+*I,Initialized s)) by SCMFSA6B:def 1
    .= DataPart Result(p+*I,Initialized s)
    .= DataPart Comput(p1,s1,LifeSpan(p1,s1)) by A13,A11,EXTPRO_1:23;
  then
   J is_halting_on Comput(p1,s1,LifeSpan(p1,s1)),p1 by A2,A4,SCMFSA8B:5;
  then
A16: p3 halts_on s3 by SCMFSA7B:def 7;
  DataPart IExec(I,P,S) = DataPart s3 by A15,MEMSTR_0:79;
  then
A17: J is_closed_on s3,p3 by A4,SCMFSA8B:3;
A18: Reloc(J,card I) c= I ';' J by FUNCT_4:25;
  set m1 = LifeSpan(p1,s1);
  set s4 = Comput(p,s,m1+1),
      p4 = p;
A21: Reloc(J,card I) c= p by A7,A18,XBOOLE_1:1;
  reconsider m = m1 + 1 + m3 as Element of NAT;
  reconsider kk = DataPart JAt as Function;
A22: DataPart s3 = (DataPart Comput(p1,s1,m1)) +* kk by FUNCT_4:71;
  take m;
     IC Comput(p,s,m) in NAT;
  hence IC Comput(p,s,m) in dom p by PARTFUN1:def 2;
A24: I is_closed_on s,p by A3,A9,SCMFSA8B:3;
  then
A25: IC s4 =  card I by A10,A8,SCMFSA8A:22;
A26: Comput(p,s,m1+1+m3)
 = Comput(p,Comput(p,s,m1+1),m3) by EXTPRO_1:4;
  DataPart JAt = {} by MEMSTR_0:20;
  then DataPart Comput(p1,s1,m1) = DataPart s3 by A22,FUNCT_4:98,XBOOLE_1:2;
  then DataPart s4 = DataPart s3 by A24,A10,A8,SCMFSA8A:22;
  then
  IncAddr(CurInstr(p3,Comput(p3,s3,m3)),card I)
  = CurInstr(p,Comput(p,s4,m3))
  by A25,A17,A21,A14,SCMFSA8C:16;
  then
  IncAddr(CurInstr(p3,Comput(p3,s3,m3)),card I)
   = CurInstr(p,Comput(p,s,m1+1+m3))
   by A26;
  then CurInstr(p,Comput(p,s,m))
   = IncAddr (halt SCM+FSA,card I) by A16,EXTPRO_1:def 15
    .= halt SCM+FSA by COMPOS_1:11;
 hence thesis;
end;

theorem Th5: :: SCMFSA6B:27
 for s being 0-started State of SCM+FSA
  st I is_closed_on s,p & I c= p & p halts_on s
 for m being Element of NAT st m <= LifeSpan(p,s) holds
   Comput(p, s,m) =  Comput(p+*(I ';' J),s,m)
proof
 let s be 0-started State of SCM+FSA;
  assume that
A1: I is_closed_on s,p and
A3: I c= p and
A4: p halts_on s;
A2: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
A5: p +* I = p by A3,FUNCT_4:98;
  defpred X[Element of NAT] means
    $1 <= LifeSpan(p,s) implies
     Comput(p, s,$1) =  Comput(p+*(I ';' J),s,$1);
A7: for m being Element of NAT st X[m] holds X[m+1]
  proof
    dom(I ';' J) = dom Directed I \/ dom Reloc(J, card I)
    by FUNCT_4:def 1
      .= dom I \/ dom Reloc(J, card I) by FUNCT_4:99;
    then
A8: dom I c= dom(I ';' J) by XBOOLE_1:7;
    set sIJ = s,
        pIJ = p+*(I ';' J);
A9: I ';' J c= pIJ by FUNCT_4:25;
    let m be Element of NAT;
    assume
A10: m <= LifeSpan(p,s) implies
       Comput(p, s,m) =  Comput(p+*(I ';'J),s,m);
A11: Comput(pIJ,sIJ,m+1) = Following(pIJ,Comput(pIJ,sIJ,m)) by EXTPRO_1:3;
A12: Comput(p,s,m+1) = Following(p,Comput(p,s,m)) by EXTPRO_1:3;
A13:  p/.IC Comput(p,s,m) = p.IC Comput(p,s,m) by PBOOLE:143;
    assume
A14: m+1 <= LifeSpan(p,s);
    then
A15: IC(Comput(p,s,m)) = IC(Comput(pIJ,sIJ,m)) by A10,NAT_1:13;
    s = Initialize s by A2,FUNCT_4:98;
    then
A16: IC Comput(p,s,m) in dom I by A1,A5,SCMFSA7B:def 6;
A17: CurInstr(p,Comput(p,s,m))
 = I.IC(Comput(p,s,m)) by A16,A13,A3,GRFUNC_1:2;
A18:  (pIJ)/.IC Comput(pIJ,sIJ,m)
 = pIJ.IC Comput(pIJ,sIJ,m) by PBOOLE:143;
    m < LifeSpan(p,s) by A14,NAT_1:13;
    then I.IC(Comput(p,s,m)) <> halt SCM+FSA by A4,A17,EXTPRO_1:def 15;
    then CurInstr(p,Comput(p,s,m))
     = (I ';' J).IC(Comput(p,s,m)) by A16,A17,SCMFSA6A:15
      .= CurInstr(pIJ,Comput(pIJ,sIJ,m))
       by A15,A16,A8,A18,A9,GRFUNC_1:2;
    hence thesis by A10,A14,A12,A11,NAT_1:13;
  end;
A19: Comput(p+*(I ';' J),s,0) = s by EXTPRO_1:2;
  Comput(p, s,0) = s by EXTPRO_1:2;
  then
A20: X[0] by A19;
  thus for n being Element of NAT holds X[n] from NAT_1:sch 1(A20,A7);
end;

Lm1: for I being good Program of SCM+FSA, J being Program of SCM+FSA, s being
State of SCM+FSA st s.intloc 0 = 1 & I is_halting_on s,p &
  J is_halting_on IExec(I,p,s),p & I is_closed_on s,p &
  J is_closed_on IExec(I,p,s),p & Initialize((intloc 0).-->1) c= s
    & I ';' J c= p
 holds IC Comput(p, s,LifeSpan(p+*I,s) + 1) =  card I &
  DataPart Comput(p, s,LifeSpan(p+*I,s) + 1)
  = DataPart Initialized Comput(p+*I,s,(LifeSpan(p +* I,s))) &
    Reloc(J,card I) c= p &
    Comput(p, s,LifeSpan(p+*I,s) + 1).intloc 0 = 1 &
    p halts_on s &
    LifeSpan(p,s) = LifeSpan(p+*I,s) + 1 + LifeSpan(p+*I+*J,
       Initialized Result(p+*I,s)) &
    (J is good implies (Result(p,s)).intloc 0 = 1)
proof
  let I be good Program of SCM+FSA, J be Program of SCM+FSA, s be State of
  SCM+FSA such that

A1: s.intloc 0 = 1 and
A2: I is_halting_on s,p and
A3: J is_halting_on IExec(I,p,s),p and
A4: I is_closed_on s,p and
A5: J is_closed_on IExec(I,p,s),p;
  set s1 = s,
      p1 = p +* I;
  set m1 = LifeSpan(p1,s1);
  set s4 = Comput(p,s,m1+1),
      p4 = p;
  assume
A10: Initialize((intloc 0).-->1) c= s;
  then Start-At(0,SCM+FSA) c= s by MEMSTR_0:50;
  then
A11: SAt c= s;
A12: s = s +* SAt by A11,FUNCT_4:98
    .= Initialize s;
  then
A13: p+*I halts_on s by A2,SCMFSA7B:def 7;
 assume
A14: I ';' J c= p;
 Directed I c= I ';' J by SCMFSA6A:16;
   then Directed I c= p by A14,XBOOLE_1:1;
   then
A15: p +* Directed I = p by FUNCT_4:98;
  Start-At(0,SCM+FSA) c= s by A10,MEMSTR_0:50;
  then Start-At(0,SCM+FSA) c= s;
  then s = Initialize s by FUNCT_4:98;
  hence
A17: IC s4 =  card I by A2,A4,A15,SCMFSA8A:22;
  set JAt = Start-At(0,SCM+FSA);
  set InJ = Initialize((intloc 0).-->1);
  set s3 = Initialized Comput(p1,s1,m1),
      p3 = p1 +* J;
A18: J c= p3 by FUNCT_4:25;
  reconsider kk = DataPart JAt as Function;
A19: DataPart JAt = {} by MEMSTR_0:20;
  Comput(p1,s1,m1).intloc 0 = s.intloc 0 by A4,A12,SCMFSA8C:68;
  then
A20: s3 = Initialize Comput(p1,s1,m1) by A1,SCMFSA8C:4;
  then DataPart s3 = DataPart Comput(p1,s1,m1) +* kk by FUNCT_4:71;
  then DataPart Comput(p1,s1,m1) = DataPart s3 by A19,FUNCT_4:98,XBOOLE_1:2;
 hence
A21: DataPart s4 = DataPart s3 by A2,A4,A12,A15,SCMFSA8A:22;
A22: Reloc(J,card I) c= I ';' J by FUNCT_4:25;
A23: intloc 0 in dom InJ by SCMFSA6A:41;
A24: s1 = s+*Initialize((intloc 0).-->1) by A10,FUNCT_4:98;
A25: DataPart IExec(I,p,s)
     = DataPart(Result(p+*I,Initialized s)) by SCMFSA6B:def 1
    .= DataPart Comput(p1,s1,LifeSpan(p1,s1)) by A13,A24,EXTPRO_1:23;
  then
   J is_halting_on Comput(p1,s1,LifeSpan(p1,s1)),p1
by A3,A5,SCMFSA8B:5;
  then
A26: p3 halts_on s3 by A20,SCMFSA7B:def 7;
  I ';' J c= p by A14;
  then Reloc(J,card I) c= p by A22,XBOOLE_1:1;
  then Reloc(J,card I) c= p;
  hence Reloc(J,card I) c= p;
A27: Reloc(J,card I) c= p by A14,A22,XBOOLE_1:1;
  intloc 0 in Int-Locations by SCMFSA_2:def 4;
  then
A28: intloc 0 in D by SCMFSA_2:100,XBOOLE_0:def 3;
  hence s4.intloc 0 = (DataPart s3).intloc 0 by A21,FUNCT_1:49
    .= s3.intloc 0 by A28,FUNCT_1:49
    .= 1 by SCMFSA6A:43,A23,FUNCT_4:13;
  set m3 = LifeSpan(p3,s3);
  reconsider m = m1 + 1 + m3 as Element of NAT;
A33: DataPart IExec(I,p,s) = DataPart s3 by A20,A25,MEMSTR_0:79;
  then
A34: J is_closed_on s3,p3 by A5,SCMFSA8B:3;
A35: Comput(p,s,m1+1+m3)
 = Comput(p,Comput(p,s,m1+1),m3) by EXTPRO_1:4;
  IncAddr(CurInstr(p3,Comput(p3,s3,m3)),card I)
   = CurInstr(p,Comput(p,s4,m3))
   by A34,A17,A21,A27,A18,SCMFSA8C:16;

  then
  IncAddr(CurInstr(p3,Comput(p3,s3,m3)),card I)
   = CurInstr(p,Comput(p,s,m1+1+m3))
   by A35;

  then
A37: CurInstr(p,Comput(p,s,m))
 = IncAddr (halt SCM+FSA,card I) by A26,EXTPRO_1:def 15

    .= halt SCM+FSA by COMPOS_1:11;
  hence
A38: p halts_on s by EXTPRO_1:29;
A39: now
    let k be Element of NAT;
    assume m1 + 1 + k < m;
    then
A40: k < m3 by XREAL_1:6;
A41: Comput(p,s,m1+1+k)
 = Comput(p,Comput(p,s,m1+1),k) by EXTPRO_1:4;
    assume
A42: CurInstr(p,Comput(p,s,m1+1+k))
 = halt SCM+FSA;
    IncAddr(CurInstr(p3,Comput(p3,s3,k)),card I)
      = halt SCM+FSA by A42,A41,A34,A17,A21,A27,A18,SCMFSA8C:16;

    then InsCode CurInstr(p3,Comput(p3,s3,k))
     = 0 by COMPOS_1:def 17,SCMFSA_2:97;

    then CurInstr(p3,Comput(p3,s3,k))
     = halt SCM+FSA by SCMFSA_2:95;
    hence contradiction by A26,A40,EXTPRO_1:def 15;
  end;
  now
    let k be Element of NAT;
    assume
A43: k < m;
    per cases;
    suppose
      k <= m1;

      hence CurInstr(p,Comput(p,s,k)) <>
       halt SCM+FSA by A2,A4,A12,A15,SCMFSA8A:21;

    end;
    suppose
      m1 < k;
      then m1 + 1 <= k by NAT_1:13;
      then consider kk being Nat such that
A44:  m1 + 1 + kk = k by NAT_1:10;
      reconsider kk as Element of NAT by ORDINAL1:def 12;
      m1 + 1 + kk = k by A44;
      hence CurInstr(p,Comput(p,s,k)) <>
       halt SCM+FSA by A39,A43;
    end;
  end;

  then
  for k being Element of NAT st CurInstr(p,Comput(p,s,k))
   = halt SCM+FSA
  holds m <= k;

  then
A45: LifeSpan(p,s) = m by A37,A38,EXTPRO_1:def 15;
   Comput(p+*I,s,m1)
      = Result(p+*I,s) by A13,EXTPRO_1:23;
  hence LifeSpan(p,s)
     = LifeSpan(p+*I,s) + 1 + LifeSpan(p+*I+*J,Initialized Result(p+*I,s))
  by A45;

  Start-At(0,SCM+FSA) c= s3 by FUNCT_4:25,MEMSTR_0:50;
  then
A46: Initialize s3 = s3 by FUNCT_4:98;
A47: InJ c= s3 by FUNCT_4:25;
  hereby

A48: DataPart Comput(p3, s3,m3) = DataPart Comput(p, s4,m3)
 by A34,A17,A21,A27,A18,SCMFSA8C:16;

    assume
A49: J is good;
    thus (Result(p,s)).intloc 0 = Comput(p, s,m).
intloc 0 by A38,A45,EXTPRO_1:23

      .= Comput(p, s4,m3).intloc 0 by EXTPRO_1:4
      .= Comput(p3, s3,m3).intloc 0 by A48,SCMFSA6A:7
      .= s3.intloc 0 by A5,A33,A46,A49,SCMFSA8B:3,SCMFSA8C:68
      .= 1 by SCMFSA6A:43,A23,A47,GRFUNC_1:2;
  end;
end;

theorem Th6:
  Ig is_halting_on Initialized s,p & J is_halting_on IExec(Ig,p,s),p &
  Ig is_closed_on Initialized s,p & J is_closed_on IExec(Ig,p,s),p
 implies LifeSpan(p +* (Ig ';' J),Initialized s)
 = LifeSpan(p +* Ig,Initialized s) + 1 +
   LifeSpan(p +* Ig +* J,Initialized Result(p +* Ig,Initialized s))
proof
  set I = Ig;
  assume that
A1: I is_halting_on Initialized s,p and
A2: J is_halting_on IExec(I,p,s),p and
A3: I is_closed_on Initialized s,p and
A4: J is_closed_on IExec(I,p,s),p;
  set Is = Initialized s;
A5: (Initialized s).intloc 0 = 1 by SCMFSA6A:38;
  set s1 = Initialized s, p1 = p +* I;
  set m1 = LifeSpan(p1,s1);
  set s3 = Initialized Comput(p1,s1,m1), p3 = p1 +* J;
A6: p3 +* J = p3 by FUNCT_4:93;
  s1 = Initialized Is;
  then
A8: s1 = Initialize Is by A5,SCMFSA8C:4;
  then
A9: p1 halts_on s1 by A1,SCMFSA7B:def 7;
  then
A10: s3 = Initialized Result(p1,s1) by EXTPRO_1:23;
  set s2 = Initialized s,
      p2 = p +* (I ';' J);
A11: I ';' J c= p2 by FUNCT_4:25;
A12: DataPart Is = DataPart s2;
A13: s2.intloc 0 = 1 by A5;
  set JAt = Start-At(0,SCM+FSA);
  Comput(p1,s1,m1).intloc 0 = 1 by A3,A5,A8,SCMFSA8C:68;
  then
A14: Initialized Comput(p1,s1,m1) = Initialize Comput(p1,s1,m1) by SCMFSA8C:4;
  then JAt c= s3 by FUNCT_4:25;
  then
A15: s3 = Initialize s3 by FUNCT_4:98;
  DataPart IExec(I,p,s) = DataPart(Result(p+*I,Initialized s))
          by SCMFSA6B:def 1
    .= DataPart Result(p+*I,Initialized s)
    .= DataPart Comput(p1,s1,LifeSpan(p1,s1)) by A9,EXTPRO_1:23;
  then
A16: DataPart IExec(I,p,s) = DataPart s3 by A14,MEMSTR_0:79;
  then
A17: J is_halting_on s3,p3 by A2,A4,SCMFSA8B:5;
 Initialize s2 = s2 by MEMSTR_0:44;
  then  Result(p2+*I,s2) =  Result(p1,s1)
     by A1,A3,A12,SCMFSA8C:72;
  then  Initialized Result(p2+*I,s2) =  s3 by A10;
  then
A20: DataPart Initialized Result(p2+*I,s2) = DataPart s3;
A21: DataPart IExec(I,p,s) = DataPart IExec(I,p,Is) by SCMFSA8C:3
    .= DataPart IExec(I,p2,s2) by A1,A3,A5,A12,SCMFSA8C:20;
  then
A22: J is_closed_on IExec(I,p2,s2),p2 by A2,A4,SCMFSA8B:5;
A23: Initialize((intloc 0).-->1) c= Initialized s by FUNCT_4:25;
A24: I is_closed_on s2,p2 by A3,A12,SCMFSA8B:3;
A25: J is_halting_on IExec(I,p2,s2),p2 by A2,A4,A21,SCMFSA8B:5;
  I is_halting_on s2,p2 by A1,A3,A12,SCMFSA8B:5;
  then
A26: LifeSpan(p2,s2) = LifeSpan(p2+*I,s2) + 1
        + LifeSpan(p2+*I+*J,Initialized Result(p2+*I,s2))
        by A24,A13,A22,A25,A23,Lm1,A11;
  Start-At(0,SCM+FSA) c= Initialized Result(p2+*I,s2)
       by FUNCT_4:25,MEMSTR_0:50;
  then
A27: Initialized Result(p2+*I,s2)
   = Initialize Initialized Result(p2 +* I,s2) by FUNCT_4:98;
A28: J is_closed_on s3,p3 by A4,A16,SCMFSA8B:3;
A29:  LifeSpan(p2+*I,s2) = m1 by A1,A3,A8,A12,SCMFSA8C:72;
  LifeSpan(p2+*I+*J,Initialized Result(p2+*I,s2)) = LifeSpan(p3,s3)
  by A28,A17,A15,A27,A20,A6,SCMFSA8C:72;
  hence thesis by A10,A26,A29;
end;

theorem Th7: :: Main theorem
  Ig is_halting_on Initialized s,p & J is_halting_on IExec(Ig,p,s),p & Ig
is_closed_on Initialized s,p & J is_closed_on IExec(Ig,p,s),p
implies IExec(Ig ';' J,p,s) = IExec(J,p,IExec(Ig,p,s))+*
  Start-At(IC IExec(J,p,IExec(Ig,p,s))+card Ig,SCM+FSA)
proof
  set I = Ig;
  assume that
A1: I is_halting_on Initialized s,p and
A2: J is_halting_on IExec(I,p,s),p and
A3: I is_closed_on Initialized s,p and
A4: J is_closed_on IExec(I,p,s),p;
  set Is = Initialized s, Ip = p;
A5: (Initialized s).intloc 0 = 1 by SCMFSA6A:38;
  set s1 = Initialized s, p1 = p +* I;
A6: I c= p1 by FUNCT_4:25;
  set m1 = LifeSpan(p1,s1);
  s1 = Initialized Is;
  then
A10: s1 = Initialize Is by A5,SCMFSA8C:4;
  DataPart Is = DataPart s1;
  then
A11: I is_closed_on s1,p1 by A3,SCMFSA8B:3;
  set s3 = Initialized Comput(p1,s1,m1), p3 = p1 +* J;
A12: J c= p3 by FUNCT_4:25;
A13: p1 halts_on s1 by A1,A10,SCMFSA7B:def 7;
  then
A14: s3 = Initialized Result(p1,s1) by EXTPRO_1:23;
  set s2 = Initialized s,
      p2 = p +* (I ';' J);
A15: I ';' J c= p2 by FUNCT_4:25;
  s2 = Initialized Is;
  then
A16: s2 = Initialize Is by A5,SCMFSA8C:4;
A17: DataPart Is = DataPart s2;
A18: s2.intloc 0 = 1 by A5;
A19: DataPart IExec(I,p,s) = DataPart IExec(I,p,Is) by SCMFSA8C:3
    .= DataPart IExec(I,p2,s2) by A1,A3,A5,A17,SCMFSA8C:20;
  then
A20: J is_closed_on IExec(I,p2,s2),p2 by A2,A4,SCMFSA8B:5;
  s2 = Initialize s2 by MEMSTR_0:44;
  then
A22: LifeSpan(p2+*I,s2) = m1 by A1,A3,A17,SCMFSA8C:72;
  set JAt = Start-At(0,SCM+FSA);
  Comput(p1,s1,m1).intloc 0 = 1 by A3,A5,A10,SCMFSA8C:68;
  then
A23: s3 = Initialize Comput(p1,s1,m1) by SCMFSA8C:4;
  set m3 = LifeSpan(p3,s3);
  I ';' J is_halting_on Is,Ip by A1,A2,A3,A4,Th4;
  then
A25: p2 halts_on s2 by A16,SCMFSA7B:def 7;
A26: IExec(I ';' J,p,s) = Result(p+*(I ';' J),Initialized s) by SCMFSA6B:def 1
    .= Comput(p2,s2,LifeSpan(p2,s2)) by A25,EXTPRO_1:23
    .= Comput(p2,s2,m1+1+m3) by A1,A2,A3,A4,A14,Th6;
A27: DataPart IExec(I,p,s) = DataPart Result(p+*I,Initialized s)
           by SCMFSA6B:def 1
    .= DataPart(Result(p+*I,s+*Initialize((intloc 0).-->1)))
    .= DataPart Comput(p1,s1,LifeSpan(p1,s1)) by A13,EXTPRO_1:23;
  then
   J is_halting_on Comput(p1,s1,LifeSpan(p1,s1)),p1
by A2,A4,SCMFSA8B:5;
  then
A28: p3 halts_on s3 by A23,SCMFSA7B:def 7;
  set IEJIs = IExec(J,p,IExec(I,p,s));
  set IAt = Start-At(0,SCM+FSA);
  DataPart IExec(I,p,s) = DataPart s3 by A23,A27,MEMSTR_0:79;
  then
A31: J is_closed_on s3,p3 by A4,SCMFSA8B:3;
A32: Initialize((intloc 0).-->1) c= s2 by FUNCT_4:25;
  IExec(I,p,s).intloc 0 = 1 by A1,A3,SCMFSA8C:67;
  then
A33: Initialized IExec(I,p,s) = Initialize IExec(I,p,s) by SCMFSA8C:4;
  then  Result(p1+*J,Result(p1, s1) +*
   Initialize((intloc 0).-->1)) =  Result(p+*J,IExec(I,p,s) +*
  Initialize((intloc 0).-->1)) by A2,A4,A23,A27,A14,SCMFSA8C:72;
  then
A34: IC Result(p1+*J,Initialized Result(p1, s1))
    = IC Result(p+*J,Initialized IExec(I,p,s));
A35: Result(p+*J,Initialized IExec(I,p,s)) = Result(p3,s3)
       by A2,A4,A23,A27,A33,SCMFSA8C:72;
A36: IEJIs = Result(p+*J,Initialized IExec(I,p,s)) by SCMFSA6B:def 1
    .= Comput(p3,s3,m3) by A28,A35,EXTPRO_1:23;
A37: I is_halting_on s2,p2 by A1,A3,A17,SCMFSA8B:5;
  reconsider l = IC IEJIs + card I as Element of NAT;
  reconsider s2t = s +* ((intloc 0) .--> 1) as State of SCM+FSA;
  DataPart s2 = DataPart(s2);
  then
A40: I is_closed_on s2,p2+*I by A3,SCMFSA8B:3;
A41: dom Start-At(l,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:13;
A42: I +* (I ';' J) = I ';' J by SCMFSA6A:18;
A44: p2 +* I +* (I ';' J) = p2 +* (I +* (I ';' J)) by FUNCT_4:14;
A48: I c= p2 +* I by FUNCT_4:25;
A49: p1+*(I ';' J) = p2 by A42,FUNCT_4:14;
EO:  Comput(p1,s1,m1) =  Comput(p2, s2,m1)
          by A13,A11,Th5,A6,A49;
  s2 = Initialize s2 by MEMSTR_0:44;
  then p2+*I halts_on s2 by A37,SCMFSA7B:def 7;
  then  Comput(p2+*I, s2,m1) =  Comput(p2+*I+*(I ';' J),s2,m1)
     by A40,A22,Th5,A48;
  then DataPart Comput(p2+*I, s2,m1)
     = DataPart Comput(p2+*I+*(I ';' J),s2,m1)
    .= DataPart Comput(p2+*I+*(I ';' J), s2,m1)
    .= DataPart Comput(p2+*(I ';' J), s2,m1) by A42,A44
    .= DataPart Comput(p2, s2,m1) by FUNCT_4:93
    .= DataPart Comput(p1,s1,m1)
           by EO;
  then
A50: DataPart(Comput(p2+*I, s2,m1) +* Initialize((intloc 0).-->1)) =
DataPart
  Comput(p1,s1,m1) +* DataPart (Initialize((intloc 0).-->1)) by FUNCT_4:71
    .= DataPart (Comput(p1,s1,m1) +* Initialize((intloc 0).-->1))
     by FUNCT_4:71;
A51: I is_closed_on s2,p2 by A3,A17,SCMFSA8B:3;
A52: J is_halting_on IExec(I,p2,s2),p2 by A2,A4,A19,SCMFSA8B:5;
  then
A53: DataPart Comput(p2,s2,m1+1) = DataPart Initialized Comput(p2+*I, s2,m1)
     by A32,A51,A37,A22,A18,A20,Lm1,A15;
   Reloc(J, card I) c= I ';' J by FUNCT_4:25;
   then
A54: Reloc(J, card I) c= p2 by A15,XBOOLE_1:1;
A55: IC Comput(p2,s2,m1+1) =  card I by A32,A51,A37,A22,A18,A20,A52,Lm1,A15;
  then
A56: DataPart Comput(p2, Comput(p2,s2,m1+1),m3)
   = DataPart Comput(p3,s3, m3) by A31,A50,A53,A12,A54,SCMFSA8C:16;
A58: DataPart IExec(I ';' J,p,s) = DataPart Comput(p2,s2,m1+1+m3)
by A26
    .= DataPart Comput(p3,s3,m3) by A56,EXTPRO_1:4
    .= DataPart IEJIs by A36;
A59: IC Comput(p2, Comput(p2,s2,m1+1),m3) = IC Comput(p3,s3,m3) + card
  I by A31,A50,A55,A53,A12,A54,SCMFSA8C:16;
A60: s3 = Initialized Result(p1, s1) by A13,EXTPRO_1:23;
A61: IC IExec(I ';' J,p,s)
 = IC Result(p+*(I ';' J),Initialized s) by SCMFSA6B:def 1
    .= IC Comput(p2,s2,LifeSpan(p2,s2)) by A25,EXTPRO_1:23
    .= IC Comput(p2,s2,m1+1+m3) by A1,A2,A3,A4,A14,Th6
    .= IC Comput(p3,s3,m3) + card I by A59,EXTPRO_1:4
    .= IC Result(p3,s3) + card I by A28,EXTPRO_1:23
    .= IC IEJIs + card I by A34,A60,SCMFSA6B:def 1;
A62: now
    let x be set;
    assume
A63: x in dom IExec(I ';' J,p,s);
    per cases by A63,SCMFSA6A:5;
    suppose
A64:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:56;
      then
A65:  not x in dom Start-At(l,SCM+FSA) by A41,TARSKI:def 1;
      IExec(I ';' J,p,s).x = IEJIs.x by A58,A64,SCMFSA6A:7;
      hence IExec(I ';' J,p,s).x =
       (IEJIs +* Start-At (IC IEJIs + card I,SCM+FSA)).x by A65,FUNCT_4:11;
    end;
    suppose
A66:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:57;
      then
A67:  not x in dom Start-At(l,SCM+FSA) by A41,TARSKI:def 1;
      IExec(I ';' J,p,s).x = IEJIs.x by A58,A66,SCMFSA6A:7;
      hence IExec(I ';' J,p,s).x =
       (IEJIs +* Start-At (IC IEJIs + card I,SCM+FSA)).x by A67,FUNCT_4:11;
    end;
    suppose
A68:  x = IC SCM+FSA;
      then x in {IC SCM+FSA} by TARSKI:def 1;
      then
A69:  x in dom Start-At(l,SCM+FSA) by FUNCOP_1:13;
      thus IExec(I ';' J,p,s).x = (Start-At(l,SCM+FSA)).IC SCM+FSA
      by A61,A68,FUNCOP_1:72
        .= (IEJIs +* Start-At (IC IEJIs + card I,SCM+FSA)).x
        by A68,A69,FUNCT_4:13;
    end;
  end;
  dom IExec(I ';' J,p,s) = the carrier of SCM+FSA by PARTFUN1:def 2
    .= dom (IEJIs +* Start-At (IC IEJIs + card I,SCM+FSA)) by PARTFUN1:def 2;
  hence thesis by A62,FUNCT_1:2;
end;

theorem Th8:
  (Ig is parahalting or Ig is_halting_on Initialized s,p & Ig
is_closed_on Initialized s,p) & (J is parahalting or
    J is_halting_on IExec(Ig,p,s),p
& J is_closed_on IExec(Ig,p,s),p) implies IExec(Ig ';' J,p,s).a
 = IExec(J,p,IExec(Ig,p,s)).a
proof
  set I = Ig;
  assume that
A1: I is parahalting or I is_halting_on Initialized s,p & I is_closed_on
  Initialized s,p and
A2: J is parahalting or J is_halting_on IExec(I,p,s),p & J is_closed_on
  IExec(I,p,s),p;
A3: J is_halting_on IExec(I,p,s),p by A2,SCMFSA7B:19;
A4: I is_closed_on Initialized s,p by A1,SCMFSA7B:18;
A5: not a in dom Start-At (IC IExec(J,p,IExec(I,p,s)) + card I,SCM+FSA)
by SCMFSA_2:102;
A6: J is_closed_on IExec(I,p,s),p by A2,SCMFSA7B:18;
  I is_halting_on Initialized s,p by A1,SCMFSA7B:19;
  then
  IExec(I ';' J,p,s) = IExec(J,p,IExec(I,p,s)) +*
     Start-At (IC IExec(J,p,IExec(I,p,s)) + card I,SCM+FSA) by A3,A4,A6,Th7;
  hence thesis by A5,FUNCT_4:11;
end;

theorem Th9:
  (Ig is parahalting or Ig is_halting_on Initialized s,p & Ig
is_closed_on Initialized s,p) & (J is parahalting or
 J is_halting_on IExec(Ig,p,s),p
& J is_closed_on IExec(Ig,p,s),p) implies IExec(Ig ';' J,p,s).f
 = IExec(J,p,IExec(Ig,p,s)).f
proof
  set I = Ig;
  assume that
A1: I is parahalting or I is_halting_on Initialized s,p &
   I is_closed_on Initialized s,p and
A2: J is parahalting or J is_halting_on IExec(I,p,s),p &
   J is_closed_on IExec(I,p,s),p;
A3: J is_halting_on IExec(I,p,s),p by A2,SCMFSA7B:19;
A4: I is_closed_on Initialized s,p by A1,SCMFSA7B:18;
A5: not f in dom Start-At (IC IExec(J,p,IExec(I,p,s)) + card I,SCM+FSA)
by SCMFSA_2:103;
A6: J is_closed_on IExec(I,p,s),p by A2,SCMFSA7B:18;
  I is_halting_on Initialized s,p by A1,SCMFSA7B:19;
  then
  IExec(I ';' J,p,s)
   = IExec(J,p,IExec(I,p,s)) +* Start-At (IC IExec(J,p,IExec(I,p,s
  )) + card I,SCM+FSA) by A3,A4,A6,Th7;
  hence thesis by A5,FUNCT_4:11;
end;

theorem
  (Ig is parahalting or Ig is_halting_on Initialized s,p & Ig is_closed_on
  Initialized s,p) & (J is parahalting or J is_halting_on IExec(Ig,p,s),p
   & J
is_closed_on IExec(Ig,p,s),p) implies DataPart IExec(Ig ';' J,p,s)
 = DataPart IExec
  (J,p,IExec(Ig,p,s))
proof
  set I = Ig;
  assume that
A1: I is parahalting or I is_halting_on Initialized s,p & I is_closed_on
  Initialized s,p and
A2: J is parahalting or J is_halting_on IExec(I,p,s),p & J is_closed_on
  IExec(I,p,s),p;
A3: for f holds IExec(I ';' J,p,s).f = IExec(J,p,IExec(I,p,s)).f by A1,A2,Th9;
  for a holds IExec(I ';' J,p,s).a = IExec(J,p,IExec(I,p,s)).a by A1,A2,Th8;
  hence thesis by A3,SCMFSA6A:7;
end;

theorem Th11:
  Ig is parahalting or Ig is_closed_on Initialized s,p & Ig
is_halting_on Initialized s,p implies
DataPart Initialized IExec(Ig,p,s)
= DataPart IExec(Ig,p,s)
proof
  set I = Ig;
  set IE = IExec(I,p,s);
  assume that
A1: I is parahalting or I is_closed_on Initialized s,p & I is_halting_on
  Initialized s,p;
A2: I is_halting_on Initialized s,p by A1,SCMFSA7B:19;
A3: I is_closed_on Initialized s,p by A1,SCMFSA7B:18;
  now
A4: dom ( Initialized IE) = the carrier of SCM+FSA by PARTFUN1:def 2;
A5: dom ( Initialized IE) = D \/ {IC SCM+FSA} by MEMSTR_0:13
      .= D \/ ({IC SCM+FSA});
A6: dom IE = the carrier of SCM+FSA by PARTFUN1:def 2;
    hence dom DataPart  Initialized IE = dom IE /\ D by A4,RELAT_1:61;
    then
A7: dom DataPart  Initialized IE = D by A4,A6,A5,XBOOLE_1:21;
    let x be set;
    assume
A8: x in dom DataPart  Initialized IE;
    per cases by A8,A7,SCMFSA_2:100,XBOOLE_0:def 3;
    suppose
    x in Int-Locations;
      then reconsider x9 = x as Int-Location by SCMFSA_2:4;
      hereby
        per cases;
        suppose
A9:       x9 is read-write;
          thus (DataPart  Initialized IE).x =
          ( Initialized IE).x by A8,A7,FUNCT_1:49
            .= IE.x by A9,SCMFSA6C:3;
        end;
        suppose
          x9 is read-only;
          then
A10:      x9 = intloc 0 by SF_MASTR:def 5;
          thus (DataPart  Initialized IE).x =
          ( Initialized IE).x9 by A8,A7,FUNCT_1:49
            .= 1 by A10,SCMFSA6A:38
            .= IE.x by A3,A2,A10,SCMFSA8C:67;
        end;
      end;
    end;
    suppose
    x in FinSeq-Locations;
      then reconsider x9 = x as FinSeq-Location by SCMFSA_2:5;
      thus (DataPart  Initialized IE).x = ( Initialized IE).x9
      by A8,A7,FUNCT_1:49
        .= IE.x by SCMFSA6C:3;
    end;
  end;
  hence thesis by FUNCT_1:46;
end;

theorem Th12:
  Ig is parahalting or Ig is_halting_on Initialized s,p & Ig
is_closed_on Initialized s,p implies IExec(Ig ';' j,p,s).a
= Exec(j, IExec(Ig,p,s)).a
proof
  set I = Ig;
  set Mj = Macro j;
  a in Int-Locations by SCMFSA_2:2;
  then
A1: a in D by SCMFSA_2:100,XBOOLE_0:def 3;
  assume that
A2: I is parahalting or I is_halting_on Initialized s,p & I is_closed_on
  Initialized s,p;
A3: DataPart Initialized IExec(I,p,s)
       = DataPart IExec(I,p,s) by A2,Th11;
  thus IExec(I ';' j,p,s).a = IExec(Mj,p,IExec(I,p,s)).a by A2,Th8
    .= ( IExec(Mj,p,IExec(I,p,s))).a
    .= ( Exec(j, Initialized IExec(I,p,s))).a by SCMFSA6C:5
    .= Exec(j, Initialized IExec(I,p,s)).a
    .= (DataPart Exec(j, Initialized IExec(I,p,s))).a by A1,FUNCT_1:49

    .= (DataPart Exec(j, IExec(I,p,s))).a by A3,SCMFSA6C:4
    .= Exec(j, IExec(I,p,s)).a by A1,FUNCT_1:49;
end;

theorem Th13:
  Ig is parahalting or Ig is_halting_on Initialized s,p & Ig
is_closed_on Initialized s,p implies IExec(Ig ';' j,p,s).f
= Exec(j, IExec(Ig,p,s)).f
proof
  set I = Ig;
  set Mj = Macro j;
  f in FinSeq-Locations by SCMFSA_2:3;
  then
A1: f in D by SCMFSA_2:100,XBOOLE_0:def 3;
  assume that
A2: I is parahalting or I is_halting_on Initialized s,p & I is_closed_on
  Initialized s,p;
A3: DataPart Initialized IExec(I,p,s) = DataPart IExec(I,p,s) by A2,Th11;
  thus IExec(I ';' j,p,s).f = IExec(Mj,p,IExec(I,p,s)).f by A2,Th9
    .= ( IExec(Mj,p,IExec(I,p,s))).f
    .= ( Exec(j, Initialized IExec(I,p,s))).f by SCMFSA6C:5
    .= Exec(j, Initialized IExec(I,p,s)).f
    .= (DataPart Exec(j, Initialized IExec(I,p,s))).f by A1,FUNCT_1:49

    .= (DataPart Exec(j, IExec(I,p,s))).f by A3,SCMFSA6C:4
    .= Exec(j, IExec(I,p,s)).f by A1,FUNCT_1:49;
end;

theorem
  Ig is parahalting or Ig is_halting_on Initialized s,p & Ig is_closed_on
Initialized s,p implies DataPart IExec(Ig ';' j,p,s) =
DataPart Exec(j, IExec(Ig,p,s))
proof
  set I = Ig;
  assume
A1: I is parahalting or I is_halting_on Initialized s,p & I is_closed_on
  Initialized s,p;
  then
A2: for f holds IExec(I ';' j,p,s).f = Exec(j, IExec(I,p,s)).f by Th13;
  for a holds IExec(I ';' j,p,s).a = Exec(j, IExec(I,p,s)).a by A1,Th12;
  hence thesis by A2,SCMFSA6A:7;
end;

theorem Th15:
  J is parahalting or J is_halting_on Exec(i, Initialized s),p & J
is_closed_on Exec(i, Initialized s),p implies IExec(i ';' J,p,s).a
= IExec(J,p,Exec(i,Initialized s)).a
proof
  set Mi = Macro i;
A1:  IExec(Mi,p,s) =  Exec(i,Initialized s) by SCMFSA6C:5;
  assume J is parahalting or J is_halting_on Exec(i, Initialized s),p & J
  is_closed_on Exec(i, Initialized s),p;
  then
A2: J is_halting_on Exec(i, Initialized s),p &
    J is_closed_on Exec(i, Initialized s),p by SCMFSA7B:18,19;
A3: J is_closed_on IExec(Mi,p,s),p by A2,A1;
  J is_halting_on IExec(Mi,p,s),p by A2,A1;
  hence IExec(i ';' J,p,s).a
     = IExec(J,p,IExec(Mi,p,s)).a by A3,Th8
    .= ( IExec(J,p,IExec(Mi,p,s))).a
    .= ( IExec(J,p,Exec(i,Initialized s))).a by A1
    .= IExec(J,p,Exec(i,Initialized s)).a;
end;

theorem Th16:
  J is parahalting or J is_halting_on Exec(i, Initialized s),p & J
is_closed_on Exec(i, Initialized s),p implies IExec(i ';' J,p,s).f
= IExec(J,p,Exec(i,Initialized s)).f
proof
  set Mi = Macro i;
A1:   IExec(Mi,p,s) =  Exec(i,Initialized s) by SCMFSA6C:5;
  assume J is parahalting or J is_halting_on Exec(i, Initialized s),p & J
  is_closed_on Exec(i, Initialized s),p;
  then
A2: J is_halting_on Exec(i, Initialized s),p &
    J is_closed_on Exec(i, Initialized s),p by SCMFSA7B:18,19;
A3: J is_closed_on IExec(Mi,p,s),p by A2,A1;
   J is_halting_on IExec(Mi,p,s),p by A2,A1;
  hence IExec(i ';' J,p,s).f = IExec(J,p,IExec(Mi,p,s)).f by A3,Th9
    .= ( IExec(J,p,IExec(Mi,p,s))).f
    .= ( IExec(J,p,Exec(i,Initialized s))).f by A1
    .= IExec(J,p,Exec(i,Initialized s)).f;
end;

theorem
  J is parahalting or J is_halting_on Exec(i, Initialized s),p & J
  is_closed_on Exec(i, Initialized s),p implies
  DataPart IExec(i ';' J,p,s) =
  DataPart IExec(J,p,Exec(i,Initialized s))
proof
  assume
A1: J is parahalting or J is_halting_on Exec(i, Initialized s),p & J
  is_closed_on Exec(i, Initialized s),p;
  then
A2: for f holds IExec(i ';' J,p,s).f = IExec(J,p,Exec(i,Initialized s)).f
by Th16
;
  for a holds IExec(i ';' J,p,s).a
   = IExec(J,p,Exec(i,Initialized s)).a by A1,Th15;
  hence thesis by A2,SCMFSA6A:7;
end;

begin :: Memory allocation

reserve L for finite Subset of Int-Locations,
  m, n for Element of NAT;

definition
  let d be Int-Location;
  redefine func { d } -> Subset of Int-Locations;
  coherence
  proof
    d in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
    hence thesis by SUBSET_1:33;
  end;
  let e be Int-Location;
  redefine func { d, e } -> Subset of Int-Locations;
  coherence
  proof
A1: e in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
    d in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
    hence thesis by A1,SUBSET_1:34;
  end;
  let f be Int-Location;
  redefine func { d, e, f } -> Subset of Int-Locations;
  coherence
  proof
A2: f in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
A3: e in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
    d in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
    hence thesis by A3,A2,SUBSET_1:35;
  end;
  let g be Int-Location;
  redefine func { d, e, f, g } -> Subset of Int-Locations;
  coherence
  proof
A4: g in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
A5: f in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
A6: e in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
    d in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
    hence thesis by A6,A5,A4,SUBSET_1:36;
  end;
end;

definition
  let L be finite Subset of Int-Locations;
  func RWNotIn-seq L -> Function of NAT, bool NAT means
  :Def2:
  it.0 = {k where
k is Element of NAT : not intloc k in L & k <> 0} & (for i being Element of NAT
, sn being non empty Subset of NAT st it.i = sn holds it.(i+1) = sn \ {min sn})
  & for i being Element of NAT holds it.i is infinite;
  existence
  proof
    set M = L \/ {intloc 0};
    defpred X[Element of NAT] means not intloc $1 in L & $1 <> 0;
    set sn = {k where k is Element of NAT : X[k] };
A1: sn is Subset of NAT from DOMAIN_1:sch 7;
    not Int-Locations c= M by AMI_3:27;
    then consider x being set such that
A2: x in Int-Locations and
A3: not x in M by TARSKI:def 3;
    reconsider x as Int-Location by A2,SCMFSA_2:4;
    consider k being Element of NAT such that
A4: x = intloc k by SCMFSA_2:8;
    not intloc k in {intloc 0} by A3,A4,XBOOLE_0:def 3;
    then
A5: k <> 0 by TARSKI:def 1;
    not intloc k in L by A3,A4,XBOOLE_0:def 3;
    then k in sn by A5;
    then reconsider sn as non empty Subset of NAT by A1;
    defpred P[Element of NAT, Subset of NAT, Subset of NAT] means for N being
    non empty Subset of NAT st N = $2 holds $3 = $2 \ {min N};
A6: now
      let n be Element of NAT;
      let x be Subset of NAT;
      per cases;
      suppose
        x is empty;
        then P[n, x, {} NAT];
        hence ex y being Subset of NAT st P[n,x,y];
      end;
      suppose
        x is non empty;
        then reconsider x9 = x as non empty Subset of NAT;
        now
          reconsider mx9 = {min x9} as Subset of NAT by ZFMISC_1:31;
          reconsider t = x9 \ mx9 as Subset of NAT;
          take t;
          let N be non empty Subset of NAT;
          assume N = x;
          hence t = x \ {min N};
        end;
        hence ex y being Subset of NAT st P[n,x,y];
      end;
    end;
    consider f being Function of NAT, bool NAT such that
A7: f.0 = sn and
A8: for n being (Element of NAT) holds P[n, f.n, f.(n+1)] from
    RECDEF_1:sch 2(A6);
    take f;
    thus f.0 = {v where v is Element of NAT : not intloc v in L & v <> 0} by A7
;
    thus for i be Element of NAT, sn be non empty Subset of NAT st f.i = sn
    holds f.(i+1) = sn \ {min sn} by A8;
    defpred X[Element of NAT] means f.$1 is infinite;
A9: X[0]
    proof
      deffunc U(Element of NAT) = intloc $1;
      set Isn = { U(v) where v is Element of NAT : v in sn };
      assume f.0 is finite;
      then
A10:  sn is finite by A7;
      Isn is finite from FRAENKEL:sch 21(A10);
      then reconsider Isn as finite set;
      now
        let x be set;
        hereby
          assume
A11:      x in M \/ Isn;
          per cases by A11,XBOOLE_0:def 3;
          suppose
            x in M;
            hence x in Int-Locations;
          end;
          suppose
            x in Isn;
            then ex k being Element of NAT st intloc k = x & k in sn;
            hence x in Int-Locations by SCMFSA_2:def 4;
          end;
        end;
        assume x in Int-Locations;
        then reconsider x9 = x as Int-Location by SCMFSA_2:4;
        consider i being Element of NAT such that
A12:    x9 = intloc i by SCMFSA_2:8;
        now
          assume
A13:      not x in M;
          then not x9 in {intloc 0} by XBOOLE_0:def 3;
          then
A14:      i <> 0 by A12,TARSKI:def 1;
          not intloc i in L by A12,A13,XBOOLE_0:def 3;
          then i in sn by A14;
          hence x in Isn by A12;
        end;
        hence x in M \/ Isn by XBOOLE_0:def 3;
      end;
      hence contradiction by AMI_3:27,TARSKI:1;
    end;
A15: for n st X[n] holds X[n+1]
    proof
      let n;
      assume
A16:  f.n is infinite;
      then reconsider sn = f.n as non empty Subset of NAT;
      min sn in sn by XXREAL_2:def 7;
      then
A17:  {min sn} c= sn by ZFMISC_1:31;
      assume f.(n+1) is finite;
      then reconsider sn1 = f.(n+1) as finite set;
A18:  sn1 \/ {min sn} is finite;
      f.(n+1) = sn \ {min sn} by A8;
      hence contradiction by A16,A17,A18,XBOOLE_1:45;
    end;
    thus for n being Element of NAT holds X[n] from NAT_1:sch 1(A9, A15);
  end;
  uniqueness
  proof
    let IT1, IT2 be Function of NAT, bool NAT such that
A19: IT1.0 = {k where k is Element of NAT : not intloc k in L & k <> 0
    } and
A20: for i being Element of NAT, sn being non empty Subset of NAT st
    IT1.i = sn holds IT1.(i+1) = sn \ {min sn} and
    for i being Element of NAT holds IT1.i is infinite and
A21: IT2.0 = {k where k is Element of NAT : not intloc k in L & k <> 0
    } and
A22: for i being Element of NAT, sn being non empty Subset of NAT st
    IT2.i = sn holds IT2.(i+1) = sn \ {min sn} and
A23: for i being Element of NAT holds IT2.i is infinite;
    now
      defpred X[Element of NAT] means IT1.$1 = IT2.$1;
      thus NAT = dom IT1 by FUNCT_2:def 1;
      thus NAT = dom IT2 by FUNCT_2:def 1;
A24:  for n st X[n] holds X[n+1]
      proof
        let n be Element of NAT;
        assume
A25:    IT1.n = IT2.n;
        then reconsider IT1n = IT1.n as non empty Subset of NAT by A23;
        thus IT1.(n+1) = IT1n \ {min IT1n} by A20
          .= IT2.(n+1) by A22,A25;
      end;
A26:  X[0] by A19,A21;
      for n being Element of NAT holds X[n] from NAT_1:sch 1(A26, A24);
      hence for x being set st x in NAT holds IT1.x = IT2.x;
    end;
    hence IT1 = IT2 by FUNCT_1:2;
  end;
end;

registration
  let L be finite Subset of Int-Locations, n be Element of NAT;
  cluster (RWNotIn-seq L).n -> non empty;
  coherence by Def2;
end;

theorem Th18:
  not 0 in (RWNotIn-seq L).n & for m st m in (RWNotIn-seq L).n
  holds not intloc m in L
proof
  set RL = RWNotIn-seq L;
  defpred X[Element of NAT] means not 0 in RL.$1 & for m st m in RL.$1 holds
  not intloc m in L;
A1: X[0]
  proof
A2: RL.0 = {k where k is Element of NAT : not intloc k in L & k <> 0} by Def2;
    hereby
      assume 0 in RL.0;
      then
      ex k being Element of NAT st k = 0 & (not intloc k in L)& k <> 0
      by A2;
      hence contradiction;
    end;
    let m;
    assume m in RL.0;
    then ex k being Element of NAT st k = m &(not intloc k in L)& k <> 0
    by A2;
    hence thesis;
  end;
A3: for n st X[n] holds X[n+1]
  proof
    let n such that
A4: not 0 in RL.n and
A5: for m st m in RL.n holds not intloc m in L;
    reconsider sn = RL.n as non empty Subset of NAT;
A6: RL.(n+1) = sn \ {min sn} by Def2;
    hence not 0 in RL.(n+1) by A4,XBOOLE_0:def 5;
    let m;
    assume m in RL.(n+1);
    then m in RL.n by A6,XBOOLE_0:def 5;
    hence thesis by A5;
  end;
  for n being Element of NAT holds X[n] from NAT_1:sch 1(A1, A3);
  hence thesis;
end;

theorem Th19:
  min ((RWNotIn-seq L).n) < min ((RWNotIn-seq L).(n+1))
proof
  set RL = RWNotIn-seq L;
  set sn = RL.n;
  set sn1 = RL.(n+1);
  assume
A1: min ((RWNotIn-seq L).n) >= min ((RWNotIn-seq L).(n+1));
A2: sn1 = sn \ {min sn} by Def2;
  then min sn <= min sn1 by XBOOLE_1:36,XXREAL_2:60;
  then min sn = min sn1 by A1,XXREAL_0:1;
  then
A3: min sn1 in {min sn} by TARSKI:def 1;
  min sn1 in sn1 by XXREAL_2:def 7;
  hence contradiction by A2,A3,XBOOLE_0:def 5;
end;

theorem Th20:
  n < m implies min ((RWNotIn-seq L).n) < min ((RWNotIn-seq L).m)
proof
  set RL = RWNotIn-seq L;
  now
    let n;
    defpred X[Element of NAT] means n < $1 implies min (RL.n) < min (RL.$1);
A1: for m st X[m] holds X[m+1]
    proof
      let m such that
A2:   n < m implies min (RL.n) < min (RL.m);
      assume n < m+1;
      then
A3:   n <= m by NAT_1:13;
      per cases by A3,XXREAL_0:1;
      suppose
        n = m;
        hence min (RL.n) < min (RL.(m+1)) by Th19;
      end;
      suppose
        n < m;
        hence min (RL.n) < min (RL.(m+1)) by A2,Th19,XXREAL_0:2;
      end;
    end;
A4: X[0] by NAT_1:2;
    thus for n being Element of NAT holds X[n] from NAT_1:sch 1(A4, A1);
  end;
  hence thesis;
end;

definition
  let n be Element of NAT, L be finite Subset of Int-Locations;
  func n-thRWNotIn L -> Int-Location equals
  intloc min ((RWNotIn-seq L).n);
  correctness;
end;

notation
  let n be Element of NAT, L be finite Subset of Int-Locations;
  synonym n-stRWNotIn L for n-thRWNotIn L;
  synonym n-ndRWNotIn L for n-thRWNotIn L;
  synonym n-rdRWNotIn L for n-thRWNotIn L;
end;

registration
  let n be Element of NAT, L be finite Subset of Int-Locations;
  cluster n-thRWNotIn L -> read-write;
  coherence
  proof
    set sn = (RWNotIn-seq L).n;
    set FNI = n-thRWNotIn L;
A1: min sn in sn by XXREAL_2:def 7;
    now
      assume FNI = intloc 0;
      then min ((RWNotIn-seq L).n) = 0 by AMI_3:10;
      hence contradiction by A1,Th18;
    end;
    hence thesis by SF_MASTR:def 5;
  end;
end;

theorem Th21:
  not n-thRWNotIn L in L
proof
  set FNI = n-thRWNotIn L;
  set sn = (RWNotIn-seq L).n;
  min sn in sn by XXREAL_2:def 7;
  hence thesis by Th18;
end;

theorem Th22:
  n <> m implies n-thRWNotIn L <> m-thRWNotIn L
proof
  assume n <> m;
  then n < m or m < n by XXREAL_0:1;
  then
A1: min ((RWNotIn-seq L).n) <> min ((RWNotIn-seq L).m) by Th20;
  assume n-thRWNotIn L = m-thRWNotIn L;
  hence contradiction by A1,AMI_3:10;
end;

definition
  let n be Element of NAT, p be preProgram of SCM+FSA;
  func n-thNotUsed p -> Int-Location equals
  n-thRWNotIn UsedIntLoc p;
  correctness;
end;

notation
  let n be Element of NAT, p be preProgram of SCM+FSA;
  synonym n-stNotUsed p for n-thNotUsed p;
  synonym n-ndNotUsed p for n-thNotUsed p;
  synonym n-rdNotUsed p for n-thNotUsed p;
end;

registration
  let n be Element of NAT, p be preProgram of SCM+FSA;
  cluster n-thNotUsed p -> read-write;
  coherence;
end;

begin :: A macro for the Fibonacci sequence

theorem Th23:
  a in UsedIntLoc swap(a, b) & b in UsedIntLoc swap(a, b)
proof
  set FNU = FirstNotUsed Macro (a := b);
  set i0 = FirstNotUsed Macro (a := b) := a;
  set i1 = a := b;
  set i2 = b := FirstNotUsed Macro (a := b);
A1: UsedIntLoc swap(a, b) = UsedIntLoc (i0 ';' i1 ';' i2) by SCMFSA6C:def 3
    .= (UsedIntLoc (i0 ';' i1)) \/ (UsedIntLoc i2) by SF_MASTR:30
    .= (UsedIntLoc (i0 ';' i1)) \/ {b, FNU} by SF_MASTR:14
    .= (UsedIntLoc i0) \/ (UsedIntLoc i1) \/ {b, FNU} by SF_MASTR:31
    .= (UsedIntLoc i0) \/ {a, b} \/ {b, FNU} by SF_MASTR:14
    .= {FNU, a} \/ {a, b} \/ {b, FNU} by SF_MASTR:14
    .= {FNU, a, a, b} \/ {b, FNU} by ENUMSET1:5
    .= {FNU, a, a, b, b, FNU} by ENUMSET1:14;
  hence a in UsedIntLoc swap(a, b) by ENUMSET1:def 4;
  thus thesis by A1,ENUMSET1:def 4;
end;

definition
  let N, result be Int-Location;
  func Fib_macro (N, result) -> Program of SCM+FSA equals
  2-ndRWNotIn
  UsedIntLoc swap(result, 1-stRWNotIn {N, result}) := N ';' (SubFrom(result,
result)) ';' (1-stRWNotIn {N, result} := intloc 0) ';' ((1-stRWNotIn UsedIntLoc
swap(result, 1-stRWNotIn {N, result})) := (2-ndRWNotIn UsedIntLoc swap(result,
  1-stRWNotIn {N, result}))) ';' Times(1-stRWNotIn UsedIntLoc swap(result, 1
-stRWNotIn {N, result}), AddTo(result, 1-stRWNotIn {N, result}) ';' swap(result
  , 1-stRWNotIn {N, result}) ) ';' (N := (2-ndRWNotIn UsedIntLoc swap(result, 1
  -stRWNotIn {N, result})));
  correctness;
end;
::  set next = 1-stRWNotIn {N, result};
::      local variable
::  set aux  = 1-stRWNotIn UsedIntLoc swap(result, next);
::      for the control variable of Times, must not be changed by swap
::  set N_save = 2-ndRWNotIn UsedIntLoc swap(result, next);
::      for saving and restoring N
:: - requires: N <> result
:: - does not change N
:: - note: Times allocates no memory

theorem
  for N, result being read-write Int-Location st N <> result for n being
Element of NAT
 st n = s.N holds IExec(Fib_macro(N, result),p,s).result = Fib n &
  IExec(Fib_macro(N, result),p,s).N = s.N
proof
  let N, result be read-write Int-Location such that
A1: N <> result;
  set i0 = SubFrom(result, result);
  set next = 1-stRWNotIn {N, result};
  set aux = 1-stRWNotIn UsedIntLoc swap(result, next);
  set Nsave = 2-ndRWNotIn UsedIntLoc swap(result, next);
  set i00 = Nsave := N;
  set i1 = next := intloc 0;
  set i2 = aux := Nsave;
  set i30 = AddTo (result, next);
  set I31 = swap(result, next);
  set i02 = i00 ';' i0 ';' i1 ';' i2;
  set s1 = IExec(i02,p,s),
      p1 = p;
  reconsider I301 = i30 ';' I31 as good parahalting Program of SCM+FSA;
  set I3 = Times(aux, I301);
  set i4 = N := Nsave;
  defpred P[Element of NAT] means for s1 being State of SCM+FSA st $1 = s1.aux
& s1.intloc 0 = 1 holds IExec(I3,p1,s1).Nsave = s1.Nsave &
    for m being Element of
NAT st s1.result = Fib m & s1.next = Fib (m+1)
 holds IExec(I3,p1,s1).result = Fib
  (m + $1) & IExec(I3,p1,s1).next = Fib (m + 1 + $1);
  let n be Element of NAT such that
A2: n = s.N;
  not next in {N, result} by Th21;
  then
A3: result <> next by TARSKI:def 2;
A4: Nsave <> aux by Th22;
A5: Nsave <> next by Th21,Th23;
A6: Nsave <> result by Th21,Th23;
A7: s1.aux = Exec(i2, IExec(i00 ';' i0 ';' i1,p,s)).aux by SCMFSA6C:6
    .= IExec(i00 ';' i0 ';' i1,p,s).Nsave by SCMFSA_2:63
    .= Exec(i1, IExec(i00 ';' i0,p,s)).Nsave by SCMFSA6C:6
    .= IExec(i00 ';' i0,p,s).Nsave by A5,SCMFSA_2:63
    .= Exec(i0, Exec(i00, Initialized s)).Nsave by SCMFSA6C:8
    .= Exec(i00, Initialized s).Nsave by A6,SCMFSA_2:65
    .= (Initialized s).N by SCMFSA_2:63
    .= s.N by SCMFSA6C:3;
A8: not I31 destroys aux by Th1,Th21;
A9: i02 is_closed_on Initialized s,p by SCMFSA7B:18;
A10: s1.Nsave = Exec(i2, IExec(i00 ';' i0 ';' i1,p,s)).Nsave by SCMFSA6C:6
    .= IExec(i00 ';' i0 ';' i1,p,s).Nsave by A4,SCMFSA_2:63
    .= Exec(i1, IExec(i00 ';' i0,p,s)).Nsave by SCMFSA6C:6
    .= IExec(i00 ';' i0,p,s).Nsave by A5,SCMFSA_2:63
    .= Exec(i0, Exec(i00, Initialized s)).Nsave by SCMFSA6C:8
    .= Exec(i00, Initialized s).Nsave by A6,SCMFSA_2:65
    .= (Initialized s).N by SCMFSA_2:63
    .= s.N by SCMFSA6C:3;
A11: i02 is_halting_on Initialized s,p by SCMFSA7B:19;
  reconsider i02 as good Program of SCM+FSA;
A12: not aux in UsedIntLoc I31 by Th21;
A13: result in UsedIntLoc I31 by Th23;
  then not Macro i30 destroys aux by A12,SCMFSA7B:7,SCMFSA8C:48;
  then
A14: not I301 destroys aux by A8,SCMFSA8C:52;
A15: next in UsedIntLoc I31 by Th23;
A16: now
    let n be Element of NAT such that
A17: P[n];
    thus P[n+1]
    proof
      let s1 be State of SCM+FSA such that
A18:  n+1 = s1.aux and
      s1.intloc 0 = 1;
      set s2 = IExec(I301 ';' SubFrom(aux, intloc 0),p1,s1),
          p2 = p1;
A19:  s1.aux > 0 by A18,NAT_1:3;
      then
A20:  s2.aux = n+1-1 by A14,A18,SCMFSA8C:91
        .= n;
A21:  s2.intloc 0 = Exec(SubFrom(aux, intloc 0), IExec(I301,p1,s1)).intloc
      0 by SCMFSA6C:6
        .= IExec(I301,p1,s1).intloc 0 by SCMFSA_2:65
        .= 1 by SCMFSA6B:11;
A22:  DataPart IExec(I3,p1,s1) = DataPart IExec(I3,p2,s2)
 by A14,A19,SCMFSA8C:91;
      hence IExec(I3,p1,s1).Nsave = IExec(I3,p2,s2).Nsave by SCMFSA6A:7
        .= s2.Nsave by A17,A20,A21
        .= Exec(SubFrom(aux, intloc 0), IExec(I301,p1,s1)).Nsave by SCMFSA6C:6
        .= IExec(I301,p1,s1).Nsave by A4,SCMFSA_2:65
        .= IExec(I31,p1,Exec(i30, Initialized s1)).Nsave by SCMFSA8B:9
        .= Exec(i30, Initialized s1).Nsave by Th21,SCMFSA6B:3
        .= (Initialized s1).Nsave by A6,SCMFSA_2:64
        .= s1.Nsave by SCMFSA6C:3;
      let m be Element of NAT;
      assume that
A23:  s1.result = Fib m and
A24:  s1.next = Fib (m+1);
A25:  s2.next = Exec(SubFrom(aux, intloc 0), IExec(I301,p1,s1)).next by
SCMFSA6C:6
        .= IExec(I301,p1,s1).next by A12,A15,SCMFSA_2:65
        .= IExec(I31,p1,Exec(i30, Initialized s1)).next by SCMFSA8B:9
        .= Exec(i30, Initialized s1).result by SCMFSA6C:10
        .= (Initialized s1).result + (Initialized s1).next
        by SCMFSA_2:64
        .= s1.result + (Initialized s1).next by SCMFSA6C:3
        .= s1.result + s1.next by SCMFSA6C:3
        .= Fib (m+1+1) by A23,A24,PRE_FF:1;
A26:  s2.result = Exec(SubFrom(aux, intloc 0), IExec(I301,p1,s1)).result by
SCMFSA6C:6
        .= IExec(I301,p1,s1).result by A12,A13,SCMFSA_2:65
        .= IExec(I31,p1,Exec(i30, Initialized s1)).result by SCMFSA8B:9
        .= Exec(i30, Initialized s1).next by SCMFSA6C:10
        .= (Initialized s1).next by A3,SCMFSA_2:64
        .= Fib (m+1) by A24,SCMFSA6C:3;
      thus IExec(I3,p1,s1).result = IExec(I3,p2,s2).result by A22,SCMFSA6A:7
        .= Fib (m+1+n) by A17,A20,A21,A26,A25
        .= Fib (m+(n+1));
      thus IExec(I3,p1,s1).next = IExec(I3,p2,s2).next by A22,SCMFSA6A:7
        .= Fib (m+1+1+n) by A17,A20,A21,A26,A25
        .= Fib (m+1+(n+1));
    end;
  end;
A27: s1.result = Exec(i2, IExec(i00 ';' i0 ';' i1,p,s)).result by SCMFSA6C:6
    .= IExec(i00 ';' i0 ';' i1,p,s).result by A12,A13,SCMFSA_2:63
    .= Exec(i1, IExec(i00 ';' i0,p,s)).result by SCMFSA6C:6
    .= IExec(i00 ';' i0,p,s).result by A3,SCMFSA_2:63
    .= Exec(i0, Exec(i00, Initialized s)).result by SCMFSA6C:8
    .= (Exec(i00, Initialized s)).result -
    (Exec(i00, Initialized s)).result
  by SCMFSA_2:65
    .= Fib 0 by PRE_FF:1;
A28: s1.next = Exec(i2, IExec(i00 ';' i0 ';' i1,p,s)).next by SCMFSA6C:6
    .= IExec(i00 ';' i0 ';' i1,p,s).next by A12,A15,SCMFSA_2:63
    .= Exec(i1, IExec(i00 ';' i0,p,s)).next by SCMFSA6C:6
    .= IExec(i00 ';' i0,p,s).intloc 0 by SCMFSA_2:63
    .= Exec(i0, Exec(i00, Initialized s)).intloc 0 by SCMFSA6C:8
    .= Exec(i00, Initialized s).intloc 0 by SCMFSA_2:65
    .= (Initialized s).intloc 0 by SCMFSA_2:63
    .= Fib (0+1) by PRE_FF:1,SCMFSA6A:38;
A29: s1.intloc 0 = Exec(i2, IExec(i00 ';' i0 ';' i1,p,s)).intloc 0
        by SCMFSA6C:6
    .= IExec(i00 ';' i0 ';' i1,p,s).intloc 0 by SCMFSA_2:63
    .= Exec(i1, IExec(i00 ';' i0,p,s)).intloc 0 by SCMFSA6C:6
    .= IExec(i00 ';' i0,p,s).intloc 0 by SCMFSA_2:63
    .= Exec(i0, Exec(i00, Initialized s)).intloc 0 by SCMFSA6C:8
    .= Exec(i00, Initialized s).intloc 0 by SCMFSA_2:65
    .= (Initialized s).intloc 0 by SCMFSA_2:63
    .= 1 by SCMFSA6A:38;
  then
A30: I3 is_closed_on s1,p1 by A14,SCMFSA8C:86;
A31: P[0]
  proof
    let s1 be State of SCM+FSA;
    assume that
A32: 0 = s1.aux and
A33: s1.intloc 0 = 1;
A34: DataPart IExec(I3,p1,s1) = DataPart s1 by A32,A33,SCMFSA8C:90;
    hence IExec(I3,p1,s1).Nsave = s1.Nsave by SCMFSA6A:7;
    let m be Element of NAT;
    assume that
A35: s1.result = Fib m and
A36: s1.next = Fib (m+1);
    thus IExec(I3,p1,s1).result = Fib (m + 0) by A34,A35,SCMFSA6A:7;
    thus thesis by A34,A36,SCMFSA6A:7;
  end;
A37: for n being Element of NAT holds P[n] from NAT_1:sch 1(A31, A16);
A38: I3 is_halting_on s1,p1 by A14,A29,SCMFSA8C:86;
A39: i02 ';' I3 is_closed_on Initialized s,p by A11,A30,A9,Th3;
  hence
  IExec(Fib_macro(N, result),p,s).result = Exec(i4, IExec(i02 ';' I3,p,s)).
  result by A11,A30,A38,A9,Th4,Th12
    .= IExec(i02 ';' I3,p,s).result by A1,SCMFSA_2:63
    .= IExec(I3,p1,s1).result by A30,A38,Th8
    .= Fib (0+n) by A37,A29,A27,A28,A7,A2
    .= Fib n;
  thus IExec(Fib_macro(N, result),p,s).N
         = Exec(i4, IExec(i02 ';' I3,p,s)).N by A11,A30,A38,A9,A39,Th4,Th12
    .= IExec(i02 ';' I3,p,s).Nsave by SCMFSA_2:63
    .= IExec(I3,p1,s1).Nsave by A30,A38,Th8
    .= s.N by A37,A29,A10,A7,A2;
end;

