:: On the Composition of non-parahalting Macro Instructions
::  by Piotr Rudnicki
::
:: Received June 3, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies AMI_1, SCMFSA_2, SCMFSA7B, SCMFSA6A, SF_MASTR, GRAPHSP, AMI_3,
      SCMFSA6B, TURING_1, AOFA_I00, SCMFSA8C, SCMFSA8B, SCMFSA8A, CARD_1,
      AMISTD_2, RELAT_1, TARSKI, XXREAL_0, ARYTM_3, FSM_1, XBOOLE_0, FUNCT_4,
      NUMBERS, SCMFSA6C, UNIALG_2, CIRCUIT2, FUNCT_1, MSUALG_1, SUBSET_1,
      NAT_1, FUNCT_7, STRUCT_0, FINSET_1, SCMFSA_1, ZFMISC_1, SCMNORM, PRE_FF,
      ARYTM_1, SFMASTR1, PARTFUN1;
 notations TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS,
      XCMPLX_0, FINSET_1, NAT_1, RELAT_1, FUNCT_1, PARTFUN1,
      FUNCT_2, FUNCT_4, FUNCT_7,
      PRE_FF, CARD_3, STRUCT_0, AMI_1, SCMNORM, SCMFSA_1, SCMFSA_2, SCMFSA_4,
      SCMFSA_5, SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA7B, SCMFSA8A,
      SCMFSA8B, SCMFSA8C, XXREAL_0, SEQ_4;
 constructors DOMAIN_1, SETWISEO, XXREAL_0, NAT_1, SEQ_4, PRE_FF, SCM_1,
      SCMFSA_5, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B,
      SCMFSA8C, SCMNORM, SCMFSA_4, XXREAL_2, RELSET_1, PRE_POLY, SCMFSA_1;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1,
      FINSET_1, NUMBERS, XREAL_0, NAT_1, INT_1, MEMBERED, CARD_3, AMI_5,
      SCMFSA_2, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8C,
      SCMFSA_9, XXREAL_2, SCMNORM, FUNCT_4, RELAT_1, AMI_1;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions AMI_1, SCMFSA_2, SCMFSA7B, FUNCOP_1, SCMFSA6A, SCMNORM;
 theorems TARSKI, ZFMISC_1, ENUMSET1, NAT_1, RELAT_1, FUNCT_1, FUNCT_2,
      FUNCT_7, LATTICE2, GRFUNC_1, SUBSET_1, FUNCT_4, PRE_FF, PRE_CIRC, AMI_1,
      SCMFSA_2, SCMFSA_4, SCMFSA_5, SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C,
      SCMFSA7B, SCMFSA8A, SCMFSA8B, SCMFSA8C, XBOOLE_0, XBOOLE_1, XREAL_1,
      ORDINAL1, FUNCOP_1, XXREAL_0, AMI_3, XXREAL_2, PBOOLE, PARTFUN1;
 schemes NAT_1, DOMAIN_1, FRAENKEL, RECDEF_1;

begin :: Good instructions and good macro instructions

definition
  let i be Instruction of SCM+FSA;
  attr i is good means
  :Def1:
  Macro i is good;
end;

registration
  let a be read-write Int-Location, b be Int-Location;
  cluster a := b -> good;
  coherence
  proof
    thus Macro (a := b) is good by SCMFSA7B:12,SCMFSA8C:99;
  end;
  cluster AddTo(a, b) -> good;
  coherence
  proof
    thus Macro AddTo(a, b) is good by SCMFSA7B:13,SCMFSA8C:99;
  end;
  cluster SubFrom(a, b) -> good;
  coherence
  proof
    thus Macro SubFrom(a, b) is good by SCMFSA7B:14,SCMFSA8C:99;
  end;
  cluster MultBy(a, b) -> good;
  coherence
  proof
    thus Macro MultBy(a, b) is good by SCMFSA7B:15,SCMFSA8C:99;
  end;
end;

registration
  cluster good parahalting Instruction of SCM+FSA;
  existence
  proof
    consider a, b being read-write Int-Location;
    a:=b is good parahalting;
    hence thesis;
  end;
end;

registration
  let a, b be read-write Int-Location;
  cluster Divide(a, b) -> good;
  coherence
  proof
    thus Macro Divide(a, b) is good by SCMFSA7B:16,SCMFSA8C:99;
  end;
end;

registration
  let l be Element of NAT;
  cluster goto l -> good;
  coherence
  proof
    thus Macro goto l is good by SCMFSA7B:17,SCMFSA8C:99;
  end;
end;

registration
  let a be Int-Location, l be Element of NAT;
  cluster a =0_goto l -> good;
  coherence
  proof
    thus Macro (a =0_goto l) is good by SCMFSA7B:18,SCMFSA8C:99;
  end;
  cluster a >0_goto l -> good;
  coherence
  proof
    thus Macro (a >0_goto l) is good by SCMFSA7B:19,SCMFSA8C:99;
  end;
end;

registration
  let a be Int-Location, f be FinSeq-Location, b be read-write Int-Location;
  cluster b := (f,a) -> good;
  coherence
  proof
    thus Macro (b := (f, a)) is good by SCMFSA7B:20,SCMFSA8C:99;
  end;
end;

registration
  let f be FinSeq-Location, b be read-write Int-Location;
  cluster b :=len f -> good;
  coherence
  proof
    thus Macro (b :=len f) is good by SCMFSA7B:22,SCMFSA8C:99;
  end;
end;

registration
  let f be FinSeq-Location, a be Int-Location;
  cluster f :=<0,...,0> a -> good;
  coherence
  proof
    thus Macro (f :=<0,...,0> a) is good by SCMFSA7B:23,SCMFSA8C:99;
  end;
  let b be Int-Location;
  cluster (f,a) := b -> good;
  coherence
  proof
    thus Macro ((f, a) := b) is good by SCMFSA7B:21,SCMFSA8C:99;
  end;
end;

registration
  cluster good Instruction of SCM+FSA;
  existence
  proof
    take h = halt SCM+FSA;
    Macro h is good by SCMFSA7B:11,SCMFSA8C:99;
    hence thesis by Def1;
  end;
end;

registration
  let i be good Instruction of SCM+FSA;
  cluster Macro i -> good;
  coherence by Def1;
end;

registration
  let i, j be good Instruction of SCM+FSA;
  cluster i ';' j -> good;
  coherence;
end;

registration
  let i be good Instruction of SCM+FSA, I be good Program of SCM+FSA;
  cluster i ';' I -> good;
  coherence;
  cluster I ';' i -> good;
  coherence;
end;

registration
  let a, b be read-write Int-Location;
  cluster swap(a, b) -> good;
  coherence
  proof
    swap(a, b) = FirstNotUsed Macro (a := b) := a ';' (a := b) ';' (b :=
    FirstNotUsed Macro (a := b)) by SCMFSA6C:def 4;
    hence thesis;
  end;
end;

registration
  let I be good Program of SCM+FSA, a be read-write Int-Location;
  cluster Times(a, I) -> good;
  coherence
  proof
    reconsider J = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) as good
    Program of SCM+FSA;
    if>0(a, loop J, Stop SCM+FSA) is good;
    hence thesis by SCMFSA8C:def 5;
  end;
end;

theorem Th1:
  for a being Int-Location, I being Program of SCM+FSA st not a in
  UsedIntLoc I holds I does_not_destroy a
proof
  let aa be Int-Location, I be Program of SCM+FSA such that
A1: not aa in UsedIntLoc I;
  let i be Instruction of SCM+FSA;
  assume
  i in rng I;
  then UsedIntLoc i c= UsedIntLoc I by SF_MASTR:23;
  then
A2: not aa in UsedIntLoc i by A1;
A3: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
A4: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A5: InsCode i <= 11+1 by SCMFSA_2:35;
  per cases by A5,A4,A3,NAT_1:8,33;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:122;
    hence thesis by SCMFSA7B:11;
  end;
  suppose
    InsCode i = 1;
    then consider a, b be Int-Location such that
A6: i = a:=b by SCMFSA_2:54;
    UsedIntLoc i = {a, b} by A6,SF_MASTR:18;
    then a in UsedIntLoc i by TARSKI:def 2;
    hence thesis by A2,A6,SCMFSA7B:12;
  end;
  suppose
    InsCode i = 2;
    then consider a, b be Int-Location such that
A7: i = AddTo(a,b) by SCMFSA_2:55;
    UsedIntLoc i = {a, b} by A7,SF_MASTR:18;
    then a in UsedIntLoc i by TARSKI:def 2;
    hence thesis by A2,A7,SCMFSA7B:13;
  end;
  suppose
    InsCode i = 3;
    then consider a, b be Int-Location such that
A8: i = SubFrom(a, b) by SCMFSA_2:56;
    UsedIntLoc i = {a, b} by A8,SF_MASTR:18;
    then a in UsedIntLoc i by TARSKI:def 2;
    hence thesis by A2,A8,SCMFSA7B:14;
  end;
  suppose
    InsCode i = 4;
    then consider a, b be Int-Location such that
A9: i = MultBy(a, b) by SCMFSA_2:57;
    UsedIntLoc i = {a, b} by A9,SF_MASTR:18;
    then a in UsedIntLoc i by TARSKI:def 2;
    hence thesis by A2,A9,SCMFSA7B:15;
  end;
  suppose
    InsCode i = 5;
    then consider a, b be Int-Location such that
A10: i = Divide(a, b) by SCMFSA_2:58;
A11: UsedIntLoc i = {a, b} by A10,SF_MASTR:18;
    then
A12: b in UsedIntLoc i by TARSKI:def 2;
    a in UsedIntLoc i by A11,TARSKI:def 2;
    hence thesis by A2,A10,A12,SCMFSA7B:16;
  end;
  suppose
    InsCode i = 6;
    then ex l be Element of NAT st i = goto l by SCMFSA_2:59;
    hence thesis by SCMFSA7B:17;
  end;
  suppose
    InsCode i = 7;
    then
    ex l be Element of NAT, a being Int-Location st i =
    a=0_goto l by SCMFSA_2:60;
    hence thesis by SCMFSA7B:18;
  end;
  suppose
    InsCode i = 8;
    then
    ex l be Element of NAT, a being Int-Location st i =
    a>0_goto l by SCMFSA_2:61;
    hence thesis by SCMFSA7B:19;
  end;
  suppose
    InsCode i = 9;
    then consider a, b be Int-Location, f be FinSeq-Location such that
A13: i = b:=(f,a) by SCMFSA_2:62;
    UsedIntLoc i = {a, b} by A13,SF_MASTR:21;
    then b in UsedIntLoc i by TARSKI:def 2;
    hence thesis by A2,A13,SCMFSA7B:20;
  end;
  suppose
    InsCode i = 10;
    then ex a, b be Int-Location, f be FinSeq-Location st i = (f,a) :=b by
SCMFSA_2:63;
    hence thesis by SCMFSA7B:21;
  end;
  suppose
    InsCode i = 11;
    then consider a be Int-Location, f be FinSeq-Location such that
A14: i = a:=len f by SCMFSA_2:64;
    UsedIntLoc i = {a} by A14,SF_MASTR:22;
    then a in UsedIntLoc i by TARSKI:def 1;
    hence thesis by A2,A14,SCMFSA7B:22;
  end;
  suppose
    InsCode i = 12;
    then
    ex a be Int-Location, f be FinSeq-Location st i = f :=<0,...,0>a by
SCMFSA_2:65;
    hence thesis by SCMFSA7B:23;
  end;
end;

begin :: Composition of non parahalting macro instructions

reserve s, S for State of SCM+FSA,
  I, J for Program of SCM+FSA,
  Ig for good
  Program of SCM+FSA,
  i for good parahalting Instruction of SCM+FSA,
  j for
  parahalting Instruction of SCM+FSA,
  a, b for Int-Location,
  f for
  FinSeq-Location;
set D = Int-Locations \/ FinSeq-Locations;
:: set D = Int-Locations U FinSeq-Locations;
:: NOTE:
:: The definition of parahalting seems to be too weak
:: Why do not we require for parahalting that
::           Initialized I is halting

theorem Th2:
  DataPart(I +* Start-At( 0,SCM+FSA)) = {}
proof
  set SAt = Start-At( 0,SCM+FSA);
  set IAt = I +* SAt;
  now
    let x be set;
    assume
    x in dom DataPart IAt;
    then
A1: x in dom (IAt) /\ D by RELAT_1:90,SCMFSA_2:127;
    then
A2: x in D by XBOOLE_0:def 4;
    x in dom IAt by A1,XBOOLE_0:def 4;
    then x in dom I \/ dom SAt by FUNCT_4:def 1;
    then x in dom I \/ {IC SCM+FSA} by FUNCOP_1:19;
    then
A3: x in dom I or x in {IC SCM+FSA} by XBOOLE_0:def 3;
    per cases by A3,TARSKI:def 1;
    suppose
A4:   x in dom I;
      dom I c= NAT by RELAT_1:def 18;
      then reconsider x as Element of NAT by A4;
      x in dom I by A4;
      hence contradiction by A2,SCMFSA6A:37;
    end;
    suppose
      x = IC SCM+FSA;
      hence contradiction by A1,SCMFSA6A:37,XBOOLE_0:def 4;
    end;
  end;
  then dom DataPart IAt = {} by XBOOLE_0:def 1;
  hence thesis;
end;

theorem Th3:
  I is_halting_on Initialize S & I is_closed_on Initialize S & J
  is_closed_on IExec(I, S) implies I ';' J is_closed_on Initialize S
proof
  set SAt = Start-At( 0,SCM+FSA);
  assume that
A1: I is_halting_on Initialize S and
A2: I is_closed_on Initialize S and
A3: J is_closed_on IExec(I, S);
  set IS = Initialize S;
  set s = IS +* ((I ';' J) +* SAt);
A4: DataPart IS = DataPart s by SCMFSA8A:11;
  then
A5: I is_closed_on s by A2,SCMFSA8B:6;
A6: I is_halting_on s by A1,A2,A4,SCMFSA8B:8;
  then
A7: ProgramPart(s+*(I+*SAt)) halts_on s+*(I+*SAt) by SCMFSA7B:def 8;
  set s1 = s +*(I+*SAt);
  set JAt = J +* SAt;
  set s3 = Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)) +* JAt;
  set D = Int-Locations \/ FinSeq-Locations;
  set m1 = LifeSpan(ProgramPart(s1),s1);
  set IJ = I ';' J;
  NAT misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A8: dom (s|NAT) misses D by SCMFSA8A:3;
A9: IS.intloc 0 = 1 by SCMFSA6C:3;
  then s.intloc 0 = 1 by A4,SCMFSA6A:38;
  then
A10: s1 = s +* Initialized I by SCMFSA8C:18;
  DataPart IExec(I, S) = DataPart IExec(I, IS) by SCMFSA8C:17
    .= DataPart IExec(I, s) by A1,A2,A4,A9,SCMFSA8C:46
    .= DataPart(Result(ProgramPart(s+*Initialized I),s+*Initialized I) +* s|NAT
) by SCMFSA6B:def 1
    .= DataPart Result(ProgramPart(s+*Initialized I),s+*Initialized I) by A8,
FUNCT_4:94,SCMFSA_2:127
    .= DataPart Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)) by A10
,A7,AMI_1:122;
  then DataPart IExec(I, S) = DataPart s3 by SCMFSA8A:11;
  then
A11: J is_closed_on s3 by A3,SCMFSA8B:6;
  set PPR = ProgramPart Relocated(J,card I);
  set s4 = Comput(ProgramPart(s),s,m1+1);
  reconsider kk = DataPart JAt as Function;
A12: DataPart s3 = DataPart Comput(ProgramPart(s1),s1,m1) +* kk by FUNCT_4:75;
  let k be Element of NAT;
A13: Directed I +* SAt c= (I ';' J) +* SAt by PRE_CIRC:3,SCMFSA6A:55;
  dom (I ';' J) misses dom SAt by SF_MASTR:64;
  then
A14: I ';' J c= (I ';' J) +* SAt by FUNCT_4:33;
A15: JAt c= s3 by FUNCT_4:26;
  (I ';' J) +* SAt c= s by FUNCT_4:26;
  then Directed I +* SAt c= s by A13,XBOOLE_1:1;
  then
A16: s = s +* (Directed I +* SAt) by FUNCT_4:79;
  then
A17: IC s4 =  card I by A5,A6,SCMFSA8A:36;
  DataPart JAt = {} by Th2;
  then DataPart Comput(ProgramPart(s1),s1,m1) = DataPart s3 by A12,LATTICE2:8
,XBOOLE_1:2;
  then
A18: DataPart s4 = DataPart s3 by A5,A6,A16,SCMFSA8A:36;
A19: PPR c= I ';' J by FUNCT_4:26;
  ((I ';' J) +* SAt) c= s by FUNCT_4:26;
  then I ';' J c= s by A14,XBOOLE_1:1;
  then PPR c= s by A19,XBOOLE_1:1;
  then
A20: PPR c= s4 by AMI_1:81;
  per cases by NAT_1:13;
  suppose
A21: k <= m1;
A22: dom I c= dom IJ by SCMFSA6A:56;
A23: IC Comput(ProgramPart(s1),s1,k) in dom I by A5,SCMFSA7B:def 7;
    IC Comput(ProgramPart(s1),s1,k) = IC Comput(ProgramPart( s), s,k) by A5,A6
,A16,A21,AMI_1:121,SCMFSA8A:35;
    hence thesis by A23,A22;
  end;
  suppose
    m1+1 <= k;
    then consider i being Nat such that
A24: k = m1+1+i by NAT_1:10;
    reconsider i as Element of NAT by ORDINAL1:def 13;
    reconsider jloc = IC Comput(ProgramPart( s3), s3,i) as Element of NAT;
    s3 = s3+*JAt by A15,FUNCT_4:79;
    then
A25: IC Comput(ProgramPart( s3), s3,i) in dom J by A11,SCMFSA7B:def 7;
A26: dom ProgramPart(J) = dom J by AMI_1:105;
    dom PPR = { j+card I where j is Element of NAT : j in dom ProgramPart
    (J) } by SCMFSA_5:3;
    then
A27:  (jloc+card I) in dom PPR by A25,A26;
A28: dom PPR c= dom IJ by A19,RELAT_1:25;
T: ProgramPart s = ProgramPart Comput(
ProgramPart( s), s,m1+1)
by AMI_1:123;
    IC Comput(ProgramPart( s3), s3,i) + card I = IC Comput(ProgramPart( Comput(
ProgramPart( s), s,m1+1)
    ), Comput(ProgramPart( s), s,m1+1)
    ,i) by A17,A18,A15,A11,A20,SCMFSA8C:42
      .= IC Comput(ProgramPart( s), s,m1+1+i) by T,AMI_1:51;
    hence thesis by A24,A27,A28;
  end;
end;

theorem Th4: :: SCMFSA6B:27
  I is_halting_on Initialize S & J is_halting_on IExec(I, S) & I
  is_closed_on Initialize S & J is_closed_on IExec(I, S) implies I ';' J
  is_halting_on Initialize S
proof
  set SAt = Start-At( 0,SCM+FSA);
  assume that
A1: I is_halting_on Initialize S and
A2: J is_halting_on IExec(I, S) and
A3: I is_closed_on Initialize S and
A4: J is_closed_on IExec(I, S);
  set s = (Initialize S) +* ((I ';' J) +* SAt);
A5: DataPart Initialize S = DataPart s by SCMFSA8A:11;
  then
A6: I is_halting_on s by A1,A3,SCMFSA8B:8;
  then
A7: ProgramPart(s+*(I+*SAt)) halts_on s+*(I+*SAt) by SCMFSA7B:def 8;
  set s1 = s +*(I+*SAt);
A8: (Initialize S).intloc 0 = 1 by SCMFSA6C:3;
  then s.intloc 0 = 1 by A5,SCMFSA6A:38;
  then
A9: s1 = s +* Initialized I by SCMFSA8C:18;
  set JAt = J +* SAt;
  set s3 = Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)) +* JAt;
  set D = Int-Locations \/ FinSeq-Locations;
  set m3 = LifeSpan(ProgramPart(s3),s3);
  NAT misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A10: dom (s|NAT) misses D by SCMFSA8A:3;
A11: DataPart IExec(I, S) = DataPart IExec(I, Initialize S) by SCMFSA8C:17
    .= DataPart IExec(I, s) by A1,A3,A5,A8,SCMFSA8C:46
    .= DataPart(Result(ProgramPart(s+*Initialized I),s+*Initialized I) +* s|NAT
) by SCMFSA6B:def 1
    .= DataPart(Result(ProgramPart(s+*Initialized I),s+*Initialized I)) by A10,
FUNCT_4:94,SCMFSA_2:127
    .= DataPart Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)) by A9
,A7,AMI_1:122;
  then J is_halting_on Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))
by A2,A4,SCMFSA8B:8;
  then
A12: ProgramPart s3 halts_on s3 by SCMFSA7B:def 8;
  DataPart IExec(I, S) = DataPart s3 by A11,SCMFSA8A:11;
  then
A13: J is_closed_on s3 by A4,SCMFSA8B:6;
  dom (I ';' J) misses dom SAt by SF_MASTR:64;
  then
A14: I ';' J c= (I ';' J) +* SAt by FUNCT_4:33;
A15: ProgramPart Relocated(J,card I) c= I ';' J by FUNCT_4:26;
  set m1 = LifeSpan(ProgramPart(s1),s1);
  set s4 = Comput(ProgramPart(s),s,m1+1);
A16: Directed I +* SAt c= (I ';' J) +* SAt by PRE_CIRC:3,SCMFSA6A:55;
  (I ';' J) +* SAt c= s by FUNCT_4:26;
  then Directed I +* SAt c= s by A16,XBOOLE_1:1;
  then
A17: s = s +* (Directed I +* SAt) by FUNCT_4:79;
  ((I ';' J) +* SAt) c= s by FUNCT_4:26;
  then I ';' J c= s by A14,XBOOLE_1:1;
  then ProgramPart Relocated(J,card I) c= s by A15,XBOOLE_1:1;
  then
A18: ProgramPart Relocated(J,card I) c= s4 by AMI_1:81;
  reconsider m = m1 + 1 + m3 as Element of NAT;
  reconsider kk = DataPart JAt as Function;
A19: DataPart s3 = (DataPart Comput(ProgramPart(s1),s1,m1)) +* kk by FUNCT_4:75
;
  take m;
     IC Comput(ProgramPart(s),s,m) in NAT;
    hence IC Comput(ProgramPart(s),s,m) in dom ProgramPart s by AMI_1:143;
A20: JAt c= s3 by FUNCT_4:26;
A21: I is_closed_on s by A3,A5,SCMFSA8B:6;
  then
A22: IC s4 =  card I by A6,A17,SCMFSA8A:36;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),
s,m1+1)
by AMI_1:123;
V: Comput(ProgramPart(s),s,m1+1+m3)
 = Comput(ProgramPart(s),Comput(ProgramPart(s),s,m1+1),m3) by AMI_1:51;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,m3)
by AMI_1:123;
TX4: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,m3)
by AMI_1:123;
  DataPart JAt = {} by Th2;
  then DataPart Comput(ProgramPart(s1),s1,m1) = DataPart s3 by A19,LATTICE2:8
,XBOOLE_1:2;
  then DataPart s4 = DataPart s3 by A21,A6,A17,SCMFSA8A:36;
  then
  IncAddr(CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,m3)),card I)
  = CurInstr(ProgramPart s4,Comput(ProgramPart(s4),
s4,m3))
  by A22,A20,A13,A18,TX4,TX3,SCMFSA8C:42;
  then
  IncAddr(CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,m3)),card I)
   = CurInstr(ProgramPart s,Comput(ProgramPart(s),s,m1+1+m3))
   by V,T;
  then CurInstr(ProgramPart s,Comput(ProgramPart(s),s,
m))
   = IncAddr (halt SCM+FSA,card I) by A12,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
 hence thesis;
end;

theorem Th5: :: SCMFSA6B:27
  I is_closed_on s & I +* Start-At( 0,SCM+FSA) c= s &
  ProgramPart s halts_on s
implies for m being Element of NAT st m <= LifeSpan(ProgramPart(s),s) holds
Comput(ProgramPart(
s), s,m),
  Comput(ProgramPart((s+*(I ';' J))),(s+*(I ';' J)),m) equal_outside NAT
proof
  assume that
A1: I is_closed_on s and
A2: I +* Start-At( 0,SCM+FSA) c= s and
A3: ProgramPart s halts_on s;
  defpred X[Element of NAT] means $1 <= LifeSpan(ProgramPart(s),s) implies
Comput(ProgramPart(
s), s,$1),
  Comput(ProgramPart((s+*(I ';' J))),(s+*(I ';' J)),$1) equal_outside NAT;
A4: for m being Element of NAT st X[m] holds X[m+1]
  proof
    dom(I ';' J) = dom Directed I \/ dom ProgramPart Relocated(J, card I)
    by FUNCT_4:def 1
      .= dom I \/ dom ProgramPart Relocated(J, card I) by FUNCT_4:105;
    then
A5: dom I c= dom(I ';' J) by XBOOLE_1:7;
    set sIJ = s+*(I ';' J);
    let m be Element of NAT;
    assume
A6: m <= LifeSpan(ProgramPart(s),s) implies Comput(ProgramPart( s), s,m),
Comput(ProgramPart((s
+*(I ';'
    J))),(s+*(I ';'
    J)),m) equal_outside NAT;
A7: I ';' J c= Comput(ProgramPart(sIJ),sIJ,m) by AMI_1:81,FUNCT_4:26;
T: ProgramPart sIJ = ProgramPart Comput(ProgramPart(sIJ),sIJ,m)
by AMI_1:123;
A8: Comput(ProgramPart(sIJ),sIJ,m+1) =
Following(ProgramPart sIJ,Comput(ProgramPart(sIJ),
sIJ,m))
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(sIJ),sIJ,m),Comput(
ProgramPart(sIJ),sIJ,m)),
      Comput(ProgramPart(sIJ),sIJ,m)) by T;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m)
by AMI_1:123;
A9: Comput(ProgramPart(s),s,m+1) =
Following(ProgramPart s,Comput(ProgramPart(s),s,m))
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s),s,m),Comput(
ProgramPart(s),s,m)),
      Comput(ProgramPart(s),s,m)) by T;
Y:  (ProgramPart Comput(ProgramPart(s),s,m))/.IC Comput(ProgramPart(s),s,m)
 = Comput(ProgramPart(s),s,m).IC Comput(ProgramPart(s),s,m) by AMI_1:150;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m)
by AMI_1:123;
    assume
A10: m+1 <= LifeSpan(ProgramPart(s),s);
    then
A11: IC(Comput(ProgramPart(s),s,m)) = IC(Comput(ProgramPart(sIJ),sIJ,m)) by A6,
AMI_1:121,NAT_1:13;
    s = s+*(I +* Start-At( 0,SCM+FSA)) by A2,FUNCT_4:79;
    then
A12: IC Comput(ProgramPart(s),s,m) in dom I by A1,SCMFSA7B:def 7;
    dom I misses dom Start-At( 0,SCM+FSA) by SF_MASTR:64;
    then I c= I +* Start-At( 0,SCM+FSA) by FUNCT_4:33;
    then I c= s by A2,XBOOLE_1:1;
    then I c= Comput(ProgramPart(s),s,m) by AMI_1:81;
    then
A13: CurInstr(ProgramPart s,Comput(ProgramPart(s),s,m)
)
 = I.IC(Comput(ProgramPart(s),s,m)) by A12,Y,TX,GRFUNC_1:8;
Y:  (ProgramPart Comput(ProgramPart(sIJ),sIJ,m))/.IC Comput(ProgramPart(sIJ),
sIJ,m)
 = Comput(ProgramPart(sIJ),sIJ,m).IC Comput(ProgramPart(sIJ),sIJ,m) by
AMI_1:150;
    m < LifeSpan(ProgramPart(s),s) by A10,NAT_1:13;
    then I.IC(Comput(ProgramPart(s),s,m)) <> halt SCM+FSA by A3,A13,
AMI_1:def 46;
    then CurInstr(ProgramPart Comput(ProgramPart(s),s,m),Comput(ProgramPart(s),
s,m))
     = (I ';' J).IC(Comput(ProgramPart(s),s,m)) by A12,A13,TX,SCMFSA6A:54
      .= CurInstr(ProgramPart Comput(ProgramPart(sIJ),sIJ,m),Comput(ProgramPart
(sIJ),sIJ,m))
       by A11,A12,A7,A5,Y,GRFUNC_1:8;
    hence thesis by A6,A10,A9,A8,NAT_1:13,SCMFSA6A:32;
  end;
A14: Comput(ProgramPart((s+*(I ';' J))),(s+*(I ';' J)),0) = s+*(I ';' J) by
AMI_1:13;
  Comput(ProgramPart( s), s,0) = s by AMI_1:13;
  then
A15: X[0] by A14,FUNCT_7:132;
  thus for n being Element of NAT holds X[n] from NAT_1:sch 1(A15,A4);
end;

Lm1: for I being good Program of SCM+FSA, J being Program of SCM+FSA, s being
State of SCM+FSA st s.intloc 0 = 1 & I is_halting_on s & J is_halting_on IExec(
I, s) & I is_closed_on s & J is_closed_on IExec(I, s) & Initialized (I ';' J)
c= s holds IC Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +* I),s +* I) +
1) =  card I &
DataPart
Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +* I),s +* I) + 1) = DataPart(
Comput(ProgramPart(
s +* I),s +* I,(LifeSpan(ProgramPart(
s +* I),
s +* I))) +* Initialized J) & ProgramPart Relocated(J,card I) c= Comput(
ProgramPart( s
), s
,LifeSpan(ProgramPart(s +* I),s +* I) + 1) & Comput(ProgramPart( s), s,LifeSpan
(ProgramPart(s +* I),s +* I) + 1).
intloc 0 = 1 &
ProgramPart s halts_on s & LifeSpan(ProgramPart(s),s)
 = LifeSpan(ProgramPart(s +* I),s +* I) + 1 + LifeSpan(ProgramPart(Result(
ProgramPart(s +* I),s +* I)
+* Initialized J),Result(ProgramPart(s +* I),s +* I)
+* Initialized J) & (J is good implies (Result(ProgramPart(s),s)).intloc 0 = 1)

proof
  set SAt = Start-At( 0,SCM+FSA);
  set D = Int-Locations \/ FinSeq-Locations;

  let I be good Program of SCM+FSA, J be Program of SCM+FSA, s be State of
  SCM+FSA such that

A1: s.intloc 0 = 1 and
A2: I is_halting_on s and
A3: J is_halting_on IExec(I, s) and
A4: I is_closed_on s and
A5: J is_closed_on IExec(I, s);
A6: SAt c= (I ';' J) +* SAt by FUNCT_4:26;
  set s1 = s +* I;
  set m1 = LifeSpan(ProgramPart(s1),s1);
  set s4 = Comput(ProgramPart(s),s,m1+1);
A7: Directed I +* SAt c= (I ';' J) +* SAt by PRE_CIRC:3,SCMFSA6A:55;
  assume
A8: Initialized (I ';' J) c= s;
  then (I ';' J) +* SAt c= s by SCMFSA6B:8;
  then
A9: SAt c= s by A6,XBOOLE_1:1;
  then
A10: s +* I = s +*Start-At( 0,SCM+FSA) +* I by FUNCT_4:79
    .= s +*I+*Start-At( 0,SCM+FSA) by SCMFSA6B:14
    .= s +*(I+*Start-At( 0,SCM+FSA)) by FUNCT_4:15;
  then
A11: ProgramPart(s+*I) halts_on s+*I by A2,SCMFSA7B:def 8;
  (I ';' J) +* SAt c= s by A8,SCMFSA6B:8;
  then Directed I +* SAt c= s by A7,XBOOLE_1:1;
  then
A12: s = s +* (Directed I +* SAt) by FUNCT_4:79;
  hence
A13: IC s4 =  card I by A2,A4,A10,SCMFSA8A:36;
  set JAt = J +* SAt;
  set InJ = Initialized J;
  set s3 = Comput(ProgramPart(s1),s1,m1) +* InJ;
  reconsider kk = DataPart JAt as Function;
A14: DataPart JAt = {} by Th2;
  Comput(ProgramPart(s1),s1,m1).intloc 0 = s.intloc 0 by A4,A10,SCMFSA8C:97;
  then
A15: s3 = Comput(ProgramPart(s1),s1,m1)+*JAt by A1,SCMFSA8C:18;
  then DataPart s3 = DataPart Comput(ProgramPart(s1),s1,m1) +* kk by FUNCT_4:75
;

  then DataPart Comput(ProgramPart(s1),s1,m1) = DataPart s3 by A14,LATTICE2:8
,XBOOLE_1:2;

  hence
A16: DataPart s4 = DataPart s3 by A2,A4,A10,A12,SCMFSA8A:36;
  NAT misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A17: dom (s|NAT) misses D by SCMFSA8A:3;
A18: ProgramPart Relocated(J,card I) c= I ';' J by FUNCT_4:26;
A19: intloc 0 in dom InJ by SCMFSA6A:45;
A20: s1 = s+*Initialized I by A8,SCMFSA6A:51;

A21: DataPart IExec(I, s) = DataPart(Result(ProgramPart(s+*Initialized I),s+*
Initialized I) +* s|NAT) by SCMFSA6B:def 1

    .= DataPart(Result(ProgramPart(s+*Initialized I),s+*Initialized I)) by A17,
FUNCT_4:94,SCMFSA_2:127
    .= DataPart Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)) by A11
,A20,AMI_1:122;
  then J is_halting_on Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))
by A3,A5,SCMFSA8B:8;
  then
A22: ProgramPart s3 halts_on s3 by A15,SCMFSA7B:def 8;
  I ';' J c= Initialized (I ';' J) by SCMFSA6A:26;
  then I ';' J c= s by A8,XBOOLE_1:1;
  then ProgramPart Relocated(J,card I) c= s by A18,XBOOLE_1:1;
  then
A23: ProgramPart Relocated(J,card I) c= s4 by AMI_1:81;
  hence ProgramPart Relocated(J,card I) c= s4;
  intloc 0 in Int-Locations by SCMFSA_2:def 4;
  then
A24: intloc 0 in D by XBOOLE_0:def 3;
  hence s4.intloc 0 = (DataPart s3).intloc 0 by A16,FUNCT_1:72,SCMFSA_2:127
    .= s3.intloc 0 by A24,FUNCT_1:72,SCMFSA_2:127
    .= (InJ).intloc 0 by A19,FUNCT_4:14
    .= 1 by SCMFSA6A:46;
A25: I ';' J c= Initialized (I ';' J) by SCMFSA6A:26;
  set m3 = LifeSpan(ProgramPart(s3),s3);
A26: dom Directed I = dom I by FUNCT_4:105;
  reconsider m = m1 + 1 + m3 as Element of NAT;
A27: Directed I c= I ';' J by SCMFSA6A:55;
  s1 +* Directed I = s +* (I +* Directed I) by FUNCT_4:15
    .= s +* Directed I by A26,FUNCT_4:20
    .= s +* Initialized (I ';' J) +* Directed I by A8,LATTICE2:8
    .= s +* (Initialized (I ';' J) +* Directed I) by FUNCT_4:15
    .= s +* Initialized (I ';' J) by A27,A25,LATTICE2:8,XBOOLE_1:1
    .= s by A8,LATTICE2:8;
  then Directed I c= s by FUNCT_4:26;
  then s+*Directed I = s by FUNCT_4:79;
  then s+*Directed I+*SAt = s by A9,FUNCT_4:79;
  then
A28: s+*(Directed I+*SAt) = s by FUNCT_4:15;
A29: DataPart IExec(I, s) = DataPart s3 by A15,A21,SCMFSA8A:11;
  then
A30: J is_closed_on s3 by A5,SCMFSA8B:6;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),
s,m1+1)
by AMI_1:123;
V: Comput(ProgramPart(s),s,m1+1+m3)
 = Comput(ProgramPart(s),Comput(ProgramPart(s),s,m1+1),m3) by AMI_1:51;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m1+1+m3)
by AMI_1:123;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,m3)
by AMI_1:123;
A31: JAt c= s3 by FUNCT_4:26,SCMFSA6B:8;

  then
  IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s3),s3,m3),Comput(ProgramPart
(s3),s3,m3)),card I)
   = CurInstr(ProgramPart Comput(ProgramPart(s4),s4,m3),Comput(ProgramPart(s4),
s4,m3))
   by A30,A13,A16,A23,SCMFSA8C:42;

  then
  IncAddr(CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,m3)),card I)
   = CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,m1+1+m3))
   by V,T,TX,TX3;

  then
A32: CurInstr(ProgramPart s,Comput(ProgramPart(s
),s,m))
 = IncAddr (halt SCM+FSA,card I) by A22,AMI_1:def 46

    .= halt SCM+FSA by SCMFSA_4:8;
  hence
A33: ProgramPart s halts_on s by AMI_1:146;
A34: now
    let k be Element of NAT;
    assume
    m1 + 1 + k < m;
    then
A35: k < m3 by XREAL_1:8;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s
,m1+1)
by AMI_1:123;
V: Comput(ProgramPart(s),s,m1+1+k)
 = Comput(ProgramPart(s),Comput(ProgramPart(s),s,m1+1),k) by AMI_1:51;
    assume
A36: CurInstr(ProgramPart Comput(ProgramPart(s),s,m1+1+k),Comput(ProgramPart(s)
,s,m1+1+k))
 = halt SCM+FSA;

TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:123;
    IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s3),s3,k),Comput(
ProgramPart(s3),s3,k)),card I)
     = CurInstr(ProgramPart Comput(ProgramPart(s4),s4,k),Comput(ProgramPart(s4)
,s4,k))
      by A30,A13,A16,A31,A23,SCMFSA8C:42

      .= halt SCM+FSA by A36,V,T;

    then InsCode CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,k))
     = 0 by TX3,SCMFSA_2:124,SCMFSA_4:22;

    then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,k))
     = halt SCM+FSA by SCMFSA_2:122;
    hence contradiction by A22,A35,AMI_1:def 46;
  end;
  now
    let k be Element of NAT;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k)
by AMI_1:123;
    assume
A37: k < m;
    per cases;
    suppose
      k <= m1;

      hence CurInstr(ProgramPart s,Comput(ProgramPart(s),s,k)) <>
       halt SCM+FSA by A2,A4,A10,A28,SCMFSA8A:35;

    end;
    suppose
      m1 < k;
      then m1 + 1 <= k by NAT_1:13;
      then consider kk being Nat such that
A38:  m1 + 1 + kk = k by NAT_1:10;
      reconsider kk as Element of NAT by ORDINAL1:def 13;
      m1 + 1 + kk = k by A38;
      hence CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,k)) <>
       halt SCM+FSA by A34,A37,TX;
    end;
  end;

  then
  for k being Element of NAT st CurInstr(ProgramPart (s),
  Comput(ProgramPart(s),s,k))
   = halt SCM+FSA
  holds m <= k;

  then
A39: LifeSpan(ProgramPart(s),s) = m by A32,A33,AMI_1:def 46;
   Comput(ProgramPart(s +* I),s +* I,m1)
      = Result(ProgramPart(s +* I),s +* I) by A11,AMI_1:122;
  hence LifeSpan(ProgramPart(s),s)
     = LifeSpan(ProgramPart(s +* I),s +* I) + 1 +
LifeSpan(ProgramPart(Result(ProgramPart(s +* I),s +* I) +* InJ),Result(
ProgramPart(s +* I),s +* I) +* InJ)
  by A39;

  J+*SAt c= s3 by FUNCT_4:26,SCMFSA6B:8;
  then
A40: s3 +* (J +* Start-At( 0,SCM+FSA)) = s3 by FUNCT_4:79;
A41: InJ c= s3 by FUNCT_4:26;
  hereby

A42: DataPart Comput(ProgramPart( s3), s3,m3) = DataPart Comput(ProgramPart( s4
), s4,m3) by A30,A13,A16,A31,A23,SCMFSA8C:42;

    assume
A43: J is good;

T: ProgramPart s = ProgramPart s4
by AMI_1:123;
    thus (Result(ProgramPart(s),s)).intloc 0 = Comput(ProgramPart( s), s,m).
intloc 0 by A33,A39,AMI_1:122

      .= Comput(ProgramPart( s4), s4,m3).intloc 0 by T,AMI_1:51
      .= Comput(ProgramPart( s3), s3,m3).intloc 0 by A42,SCMFSA6A:38
      .= s3.intloc 0 by A5,A29,A40,A43,SCMFSA8B:6,SCMFSA8C:97
      .= (InJ).intloc 0 by A19,A41,GRFUNC_1:8
      .= 1 by SCMFSA6A:46;
  end;
end;

theorem Th6:
  Ig is_halting_on Initialize s & J is_halting_on IExec(Ig, s) & Ig
is_closed_on Initialize s & J is_closed_on IExec(Ig, s) implies LifeSpan(
ProgramPart(s +*
Initialized (Ig ';' J)),s +*
Initialized (Ig ';' J)) = LifeSpan(ProgramPart(s +* Initialized Ig),s +*
Initialized Ig) + 1 + LifeSpan(ProgramPart(Result(ProgramPart(s +* Initialized
Ig),s +* Initialized Ig) +* Initialized J),Result(ProgramPart(s +* Initialized
Ig),s +* Initialized Ig) +* Initialized J)
proof
  set SAt = Start-At( 0,SCM+FSA);
  set D = (Int-Locations \/ FinSeq-Locations);
  set I = Ig;
  assume that
A1: I is_halting_on Initialize s and
A2: J is_halting_on IExec(I, s) and
A3: I is_closed_on Initialize s and
A4: J is_closed_on IExec(I, s);
  set Is = Initialize s;
A5: (Initialize s).intloc 0 = 1 by SCMFSA6C:3;
  set s1 = s +* Initialized I;
  set m1 = LifeSpan(ProgramPart(s1),s1);
  set s3 = Comput(ProgramPart(s1),s1,m1) +* Initialized J;
  s1 = Is +* Initialized I by SCMFSA8A:8;
  then
A6: s1 = Is+*(I+*SAt) by A5,SCMFSA8C:18;
  then
A7: ProgramPart s1 halts_on s1 by A1,SCMFSA7B:def 8;
  then
A8: s3 = Result(ProgramPart(s1),s1) +* Initialized J by AMI_1:122;
  set s2 = s +* Initialized (I ';' J);
  s2 = Is +* Initialized (I ';' J) by SCMFSA8A:8;
  then s2 = Is+*((I ';' J)+*SAt) by A5,SCMFSA8C:18;
  then
A9: DataPart Is = DataPart s2 by SCMFSA8A:11;
  then
A10: s2.intloc 0 = 1 by A5,SCMFSA6A:38;
  set JAt = J +* SAt;
  NAT misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A11: dom (s|NAT) misses D by SCMFSA8A:3;
  Comput(ProgramPart(s1),s1,m1).intloc 0 = 1 by A3,A5,A6,SCMFSA8C:97;
  then
A12: s3 = Comput(ProgramPart(s1),s1,m1)+*JAt by SCMFSA8C:18;
  then JAt c= s3 by FUNCT_4:26;
  then
A13: s3 = s3+*JAt by FUNCT_4:79;
  DataPart IExec(I, s) = DataPart(Result(ProgramPart(s+*Initialized I),s+*
Initialized I) +* s|NAT) by SCMFSA6B:def 1
    .= DataPart(Result(ProgramPart(s+*Initialized I),s+*Initialized I)) by A11,
FUNCT_4:94,SCMFSA_2:127
    .= DataPart Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)) by A7,
AMI_1:122;
  then
A14: DataPart IExec(I, s) = DataPart s3 by A12,SCMFSA8A:11;
  then
A15: J is_halting_on s3 by A2,A4,SCMFSA8B:8;
A16: Initialized I c= s2 +* I by FUNCT_4:26,SCMFSA6A:52;
  SAt c= Initialized I by FUNCT_4:26;
  then SAt c= s2+*I by A16,XBOOLE_1:1;
  then
A17: s2+*I = s2+*I+*SAt by FUNCT_4:79
    .= s2+*(I+*SAt) by FUNCT_4:15;
  then Result(ProgramPart(s2 +* I),s2 +* I), Result(ProgramPart(s1),s1)
equal_outside NAT by A1,A3,A6,A9,FUNCT_7:28,SCMFSA8C:101;
  then
A18: DataPart (Result(ProgramPart(s2 +* I),s2 +* I) +* Initialized J) =
DataPart s3 by A8,FUNCT_7:106,SCMFSA6A:39;
A19: DataPart IExec(I, s) = DataPart IExec(I, Is) by SCMFSA8C:17
    .= DataPart IExec(I, s2) by A1,A3,A5,A9,SCMFSA8C:46;
  then
A20: J is_closed_on IExec(I, s2) by A2,A4,SCMFSA8B:8;
A21: Initialized (I ';' J) c= s +* Initialized (I ';' J) by FUNCT_4:26;
A22: I is_closed_on s2 by A3,A9,SCMFSA8B:6;
A23: J is_halting_on IExec(I, s2) by A2,A4,A19,SCMFSA8B:8;
  I is_halting_on s2 by A1,A3,A9,SCMFSA8B:8;
  then
A24: LifeSpan(ProgramPart(s2),s2) = LifeSpan(ProgramPart(s2 +* I),s2 +* I) + 1
+ LifeSpan(ProgramPart(Result(ProgramPart(s2 +* I),s2 +* I) +*
  Initialized J),Result(ProgramPart(s2 +* I),s2 +* I) +*
  Initialized J) by A22,A10,A20,A23,A21,Lm1;
  set SAt = Start-At( 0,SCM+FSA);
  J +* SAt c= Result(ProgramPart(s2 +* I),s2 +* I) +* Initialized J by
FUNCT_4:26,SCMFSA6B:8;
  then
A25: Result(ProgramPart(s2 +* I),s2 +* I) +* Initialized J = Result(ProgramPart
(s2 +* I),s2 +* I) +* Initialized J
  +* (J+* SAt) by FUNCT_4:79;
A26: J is_closed_on s3 by A4,A14,SCMFSA8B:6;
  LifeSpan(ProgramPart(s2 +* I),s2 +* I) = m1 by A1,A3,A6,A9,A17,SCMFSA8C:101;
  hence thesis by A26,A15,A13,A8,A24,A25,A18,SCMFSA8C:101;
end;

theorem Th7: :: Main theorem
  Ig is_halting_on Initialize s & J is_halting_on IExec(Ig, s) & Ig
is_closed_on Initialize s & J is_closed_on IExec(Ig, s) implies IExec(Ig ';' J,
  s) = IExec(J, IExec(Ig, s))+*
  Start-At(IC IExec(J, IExec(Ig, s))+card Ig,SCM+FSA)
proof
  set SAt = Start-At( 0,SCM+FSA);
  set D = (Int-Locations \/ FinSeq-Locations);
  set I = Ig;
  assume that
A1: I is_halting_on Initialize s and
A2: J is_halting_on IExec(I, s) and
A3: I is_closed_on Initialize s and
A4: J is_closed_on IExec(I, s);
  set Is = Initialize s;
A5: (Initialize s).intloc 0 = 1 by SCMFSA6C:3;
  set s1 = s +* Initialized I;
  set m1 = LifeSpan(ProgramPart(s1),s1);
  s1 = Is +* Initialized I by SCMFSA8A:8;
  then
A6: s1 = Is+*(I+*SAt) by A5,SCMFSA8C:18;
  then DataPart Is = DataPart s1 by SCMFSA8A:11;
  then
A7: I is_closed_on s1 by A3,SCMFSA8B:6;
  set s3 = Comput(ProgramPart(s1),s1,m1) +* Initialized J;
A8: ProgramPart s1 halts_on s1 by A1,A6,SCMFSA7B:def 8;
  then
A9: s3 = Result(ProgramPart(s1),s1) +* Initialized J by AMI_1:122;
  set s2 = s +* Initialized (I ';' J);
  s2 = Is +* Initialized (I ';' J) by SCMFSA8A:8;
  then
A10: s2 = Is+*((I ';' J)+*SAt) by A5,SCMFSA8C:18;
  then
A11: DataPart Is = DataPart s2 by SCMFSA8A:11;
  then
A12: s2.intloc 0 = 1 by A5,SCMFSA6A:38;
A13: DataPart IExec(I, s) = DataPart IExec(I, Is) by SCMFSA8C:17
    .= DataPart IExec(I, s2) by A1,A3,A5,A11,SCMFSA8C:46;
  then
A14: J is_closed_on IExec(I, s2) by A2,A4,SCMFSA8B:8;
A15: Initialized I c= s2 +* I by FUNCT_4:26,SCMFSA6A:52;
  SAt c= Initialized I by FUNCT_4:26;
  then SAt c= s2+*I by A15,XBOOLE_1:1;
  then s2+*I = s2+*I+*SAt by FUNCT_4:79
    .= s2+*(I+*SAt) by FUNCT_4:15;
  then
A16: LifeSpan(ProgramPart(s2 +* I),s2 +* I) = m1 by A1,A3,A6,A11,SCMFSA8C:101;
  set JAt = J +* SAt;
  NAT misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A17: dom (s|NAT) misses D by SCMFSA8A:3;
  Comput(ProgramPart(s1),s1,m1).intloc 0 = 1 by A3,A5,A6,SCMFSA8C:97;
  then
A18: s3 = Comput(ProgramPart(s1),s1,m1)+*JAt by SCMFSA8C:18;
  set m3 = LifeSpan(ProgramPart(s3),s3);
  set ps = s | NAT;
A19: dom ps = dom s /\ NAT by RELAT_1:90
    .= (D \/ {IC SCM+FSA} \/ NAT) /\ NAT by SCMFSA6A:34
    .= NAT by XBOOLE_1:21;
  I ';' J is_halting_on Is by A1,A2,A3,A4,Th4;
  then
A20: ProgramPart s2 halts_on s2 by A10,SCMFSA7B:def 8;
A21: IExec(I ';' J, s) = Result(ProgramPart(s +* Initialized (I ';' J)),s +*
Initialized (I ';' J)) +* ps by SCMFSA6B:def 1
    .= Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))+* ps by A20,
AMI_1:122
    .= Comput(ProgramPart(s2),s2,m1+1+m3) +* ps by A1,A2,A3,A4,A9,Th6;
A22: DataPart IExec(I, s) = DataPart(Result(ProgramPart(s+*Initialized I),s+*
Initialized I) +* s|NAT) by SCMFSA6B:def 1
    .= DataPart(Result(ProgramPart(s+*Initialized I),s+*Initialized I)) by A17,
FUNCT_4:94,SCMFSA_2:127
    .= DataPart Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)) by A8,
AMI_1:122;
  then J is_halting_on Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))
by A2,A4,SCMFSA8B:8;
  then
A23: ProgramPart s3 halts_on s3 by A18,SCMFSA7B:def 8;
  set IEJIs = IExec(J, IExec(I, s));
  set IAt = I +* SAt;
A24: I +* Start-At( 0,SCM+FSA) c= s1 by FUNCT_4:26,SCMFSA6B:8;
A25: J +* Start-At( 0,SCM+FSA) c= s3 by FUNCT_4:26,SCMFSA6B:8;
  DataPart IExec(I, s) = DataPart s3 by A18,A22,SCMFSA8A:11;
  then
A26: J is_closed_on s3 by A4,SCMFSA8B:6;
A27: Initialized (I ';' J) c= s2 by FUNCT_4:26;
  IExec(I, s).intloc 0 = 1 by A1,A3,SCMFSA8C:96;
  then
A28: IExec(I, s)+*Initialized J = IExec(I,s)+*JAt by SCMFSA8C:18;
  then
A29: IC Result(ProgramPart(Result(ProgramPart s1, s1) +* Initialized J),
Result(ProgramPart s1, s1) +*
Initialized J) = IC Result(ProgramPart(IExec(I,s) +*
  Initialized J),IExec(I,s) +*
  Initialized J) by A2,A4,A18,A22,A9,AMI_1:121,SCMFSA8C:101;
  Result(ProgramPart(IExec(I,s) +* Initialized J),IExec(I,s) +* Initialized J),
Result(ProgramPart(s3),s3) equal_outside NAT by A2,A4,A18,A22,A28,SCMFSA8C:101;
  then
A30: Result(ProgramPart(IExec(I,s) +* Initialized J),IExec(I,s) +* Initialized
J) +* ps = Result(ProgramPart(s3),s3) +* ps by A19,FUNCT_7:108;
  IExec(I,s) | NAT = (Result(ProgramPart(s +* Initialized I),s +* Initialized I
) +* ps) | NAT by SCMFSA6B:def 1
    .= ps by PBOOLE:157;
  then
A31: IEJIs = Result(ProgramPart(IExec(I,s) +* Initialized J),IExec(I,s) +*
Initialized J) +* ps by SCMFSA6B:def 1
    .= Comput(ProgramPart(s3),s3,m3) +* ps by A23,A30,AMI_1:122;
A32: I is_halting_on s2 by A1,A3,A11,SCMFSA8B:8;
  reconsider l = IC IEJIs + card I as Element of NAT;
A33: s1 +* (I ';' J) = s +* (Initialized I +* (I ';' J)) by FUNCT_4:15
    .= s2 by SCMFSA6A:58;
  Initialized I c= s2 +* I by FUNCT_4:26,SCMFSA6A:52;
  then
A34: IAt c= s2 +* I by SCMFSA6B:8;
  DataPart s2 = DataPart(s2+*I) by SCMFSA8C:34;
  then
A35: I is_closed_on s2+*I by A3,A11,SCMFSA8B:6;
A36: dom Start-At(l,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
X: I +* (I ';' J) = I ';' J by SCMFSA6A:57;
X1: s2 +* I +* (I ';' J) = s2 +* (I +* (I ';' J)) by FUNCT_4:15;
X2: s2 +* (I ';' J) = s +* (Initialized (I ';' J) +* (I ';' J)) by FUNCT_4:15;
 (I ';' J) c= Initialized (I ';' J) by SCMFSA6A:26;
 then
X3: Initialized (I ';' J) +* (I ';' J) = Initialized (I ';' J) by LATTICE2:8;
  SAt c= Initialized (I ';' J) by SCMFSA6B:4;
  then SAt c= s2 by A27,XBOOLE_1:1;
  then s2+*I = s2+*SAt+*I by FUNCT_4:79
    .= s2+*I+*SAt by SCMFSA6B:14
    .= s2+*(I+*SAt) by FUNCT_4:15;
  then ProgramPart(s2+*I) halts_on s2+*I by A32,SCMFSA7B:def 8;
  then DataPart Comput(ProgramPart( (s2 +* I)), (s2 +* I),m1) = DataPart Comput
(ProgramPart( ((s2 +* I)
  +* (I ';' J))), ((s2 +* I)
  +* (I ';' J)),m1) by A35,A34,A16,Th5,SCMFSA6A:39
    .= DataPart Comput(ProgramPart( ((s2 +* (I +* (I ';' J))))), ((s2 +* (I +*
(I ';' J)))),m1) by X1
    .= DataPart Comput(ProgramPart( (s2 +* (I ';' J))), (s2 +* (I ';' J)),m1)
by X
    .= DataPart Comput(ProgramPart( (s +* (Initialized (I ';' J) +* (I ';' J)))
), (s +* (Initialized (I ';' J) +* (I ';' J))),m1)
  by X2
    .= DataPart Comput(ProgramPart( s2), s2,m1) by X3
    .= DataPart Comput(ProgramPart(s1),s1,m1) by A8,A7,A24,A33,Th5,SCMFSA6A:39;
  then
A37: DataPart(Comput(ProgramPart( (s2 +* I)), (s2 +* I),m1) +* Initialized J) =
DataPart
  Comput(ProgramPart(s1),s1,m1) +* DataPart (Initialized J) by FUNCT_4:75
    .= DataPart (Comput(ProgramPart(s1),s1,m1) +* Initialized J) by FUNCT_4:75;
A38: I is_closed_on s2 by A3,A11,SCMFSA8B:6;
A39: J is_halting_on IExec(I, s2) by A2,A4,A13,SCMFSA8B:8;
  then
A40: DataPart Comput(ProgramPart(s2),s2,m1+1) = DataPart(Comput(ProgramPart( (
s2 +* I)), (s2 +* I),m1) +*
  Initialized J) by A27,A38,A32,A16,A12,A14,Lm1;
A41: ProgramPart Relocated(J, card I) c= Comput(ProgramPart(s2),s2,m1+1) by A27
,A38,A32,A16,A12,A14,A39,Lm1;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,m1+1)
by AMI_1:123;
A42: IC Comput(ProgramPart(s2),s2,m1+1) =  card I by A27,A38,A32,A16,A12,A14
,A39,Lm1
;
  then
A43: DataPart Comput(ProgramPart( Comput(ProgramPart(s2),s2,m1+1)), Comput(
ProgramPart(s2),s2,m1+1),m3) = DataPart Comput(ProgramPart(
  s3),
  s3, m3) by A26,A37,A40,A41,A25,SCMFSA8C:42;
A44: dom ps misses D by A19,SCMFSA_2:13,14,XBOOLE_1:70;
  then
A45: DataPart IExec(I ';' J,s) = DataPart Comput(ProgramPart(s2),s2,m1+1+m3)
by A21,FUNCT_4:76,SCMFSA_2:127
    .= DataPart Comput(ProgramPart(s3),s3,m3) by A43,T,AMI_1:51
    .= DataPart IEJIs by A31,A44,FUNCT_4:76,SCMFSA_2:127;
A46: IC Comput(ProgramPart( Comput(ProgramPart(s2),s2,m1+1)), Comput(
ProgramPart(s2),s2,m1+1),m3) = IC Comput(ProgramPart(s3),s3,m3) + card
  I by A26,A37,A42,A40,A41,A25,SCMFSA8C:42;
XX: s3 = Result(ProgramPart s1, s1) +* Initialized J by A8,AMI_1:122;
A47: IC IExec(I ';' J,s) = IC Result(ProgramPart(s+*Initialized (I ';' J)),s+*
Initialized (I ';' J)) by SCMFSA8A:7
    .= IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2)) by A20,
AMI_1:122
    .= IC Comput(ProgramPart(s2),s2,m1+1+m3) by A1,A2,A3,A4,A9,Th6
    .= IC Comput(ProgramPart(s3),s3,m3) + card I by A46,T,AMI_1:51
    .= IC Result(ProgramPart(s3),s3) + card I by A23,AMI_1:122
    .= IC Result(ProgramPart(Result(ProgramPart s1, s1) +*
    Initialized J),Result(ProgramPart s1, s1) +*
Initialized J) + card I by XX
    .= IC IEJIs + card I by A29,SCMFSA8A:7;
A48: now
    let x be set;
    assume
A49: x in dom IExec(I ';' J,s);
    per cases by A49,SCMFSA6A:35;
    suppose
A50:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A51:  not x in dom Start-At(l,SCM+FSA) by A36,TARSKI:def 1;
      IExec(I ';' J,s).x = IEJIs.x by A45,A50,SCMFSA6A:38;
      hence IExec(I ';' J,s).x =
       (IEJIs +* Start-At (IC IEJIs + card I,SCM+FSA)).x by A51,FUNCT_4:12;
    end;
    suppose
A52:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A53:  not x in dom Start-At(l,SCM+FSA) by A36,TARSKI:def 1;
      IExec(I ';' J,s).x = IEJIs.x by A45,A52,SCMFSA6A:38;
      hence IExec(I ';' J,s).x =
       (IEJIs +* Start-At (IC IEJIs + card I,SCM+FSA)).x by A53,FUNCT_4:12;
    end;
    suppose
A54:  x = IC SCM+FSA;
      then x in {IC SCM+FSA} by TARSKI:def 1;
      then
A55:  x in dom Start-At(l,SCM+FSA) by FUNCOP_1:19;
      thus IExec(I ';' J,s).x = (Start-At(l,SCM+FSA)).IC SCM+FSA
      by A47,A54,FUNCOP_1:87
        .= (IEJIs +* Start-At (IC IEJIs + card I,SCM+FSA)).x
        by A54,A55,FUNCT_4:14;
    end;
    suppose
A56:  x is Element of NAT;
      then x <> IC SCM+FSA by AMI_1:48;
      then
A57:  not x in dom Start-At(l,SCM+FSA) by A36,TARSKI:def 1;
      IExec(I ';' J,s) | NAT = ps by A21,PBOOLE:157
        .= IEJIs | NAT by A31,PBOOLE:157;
      then IExec(I ';' J,s).x = IEJIs.x by A56,SCMFSA6A:36;
      hence IExec(I ';' J,s).x =
      (IEJIs +* Start-At (IC IEJIs + card I,SCM+FSA)).x by A57,FUNCT_4:12;
    end;
  end;
  dom IExec(I ';' J,s) = the carrier of SCM+FSA by PARTFUN1:def 4
    .= dom (IEJIs +* Start-At (IC IEJIs + card I,SCM+FSA)) by PARTFUN1:def 4;
  hence thesis by A48,FUNCT_1:9;
end;

theorem Th8:
  (Ig is parahalting or Ig is_halting_on Initialize s & Ig
is_closed_on Initialize s) & (J is parahalting or J is_halting_on IExec(Ig, s)
& J is_closed_on IExec(Ig, s)) implies IExec(Ig ';' J, s).a = IExec(J, IExec(Ig
  , s)).a
proof
  set I = Ig;
  assume that
A1: I is parahalting or I is_halting_on Initialize s & I is_closed_on
  Initialize s and
A2: J is parahalting or J is_halting_on IExec(I, s) & J is_closed_on
  IExec(I, s);
A3: J is_halting_on IExec(I, s) by A2,SCMFSA7B:25;
A4: I is_closed_on Initialize s by A1,SCMFSA7B:24;
A5: not a in dom Start-At (IC IExec(J,IExec(I,s)) + card I,SCM+FSA)
by SCMFSA6B:9;
A6: J is_closed_on IExec(I, s) by A2,SCMFSA7B:24;
  I is_halting_on Initialize s by A1,SCMFSA7B:25;
  then
  IExec(I ';' J,s) = IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s
  )) + card I,SCM+FSA) by A3,A4,A6,Th7;
  hence thesis by A5,FUNCT_4:12;
end;

theorem Th9:
  (Ig is parahalting or Ig is_halting_on Initialize s & Ig
is_closed_on Initialize s) & (J is parahalting or J is_halting_on IExec(Ig, s)
& J is_closed_on IExec(Ig, s)) implies IExec(Ig ';' J, s).f = IExec(J, IExec(Ig
  , s)).f
proof
  set I = Ig;
  assume that
A1: I is parahalting or I is_halting_on Initialize s & I is_closed_on
  Initialize s and
A2: J is parahalting or J is_halting_on IExec(I, s) & J is_closed_on
  IExec(I, s);
A3: J is_halting_on IExec(I, s) by A2,SCMFSA7B:25;
A4: I is_closed_on Initialize s by A1,SCMFSA7B:24;
A5: not f in dom Start-At (IC IExec(J,IExec(I,s)) + card I,SCM+FSA)
by SCMFSA6B:10;
A6: J is_closed_on IExec(I, s) by A2,SCMFSA7B:24;
  I is_halting_on Initialize s by A1,SCMFSA7B:25;
  then
  IExec(I ';' J,s) = IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s
  )) + card I,SCM+FSA) by A3,A4,A6,Th7;
  hence thesis by A5,FUNCT_4:12;
end;

theorem
  (Ig is parahalting or Ig is_halting_on Initialize s & Ig is_closed_on
  Initialize s) & (J is parahalting or J is_halting_on IExec(Ig, s) & J
is_closed_on IExec(Ig, s)) implies DataPart IExec(Ig ';' J, s) = DataPart IExec
  (J, IExec(Ig, s))
proof
  set I = Ig;
  assume that
A1: I is parahalting or I is_halting_on Initialize s & I is_closed_on
  Initialize s and
A2: J is parahalting or J is_halting_on IExec(I, s) & J is_closed_on
  IExec(I, s);
A3: for f holds IExec(I ';' J, s).f = IExec(J, IExec(I, s)).f by A1,A2,Th9;
  for a holds IExec(I ';' J, s).a = IExec(J, IExec(I, s)).a by A1,A2,Th8;
  hence thesis by A3,SCMFSA6A:38;
end;

theorem Th11:
  Ig is parahalting or Ig is_closed_on Initialize s & Ig
is_halting_on Initialize s implies DataPart Initialize IExec(Ig, s) = DataPart
  IExec(Ig, s)
proof
  set I = Ig;
  set IE = IExec(I,s);
  assume that
A1: I is parahalting or I is_closed_on Initialize s & I is_halting_on
  Initialize s;
A2: I is_halting_on Initialize s by A1,SCMFSA7B:25;
A3: I is_closed_on Initialize s by A1,SCMFSA7B:24;
  now
A4: dom (Initialize IE) = the carrier of SCM+FSA by PARTFUN1:def 4;
    then
A5: dom (Initialize IE) = D \/ ({IC SCM+FSA} \/ NAT) by SCMFSA_2:8,XBOOLE_1:4;
A6: dom IE = the carrier of SCM+FSA by PARTFUN1:def 4;
    hence dom DataPart Initialize IE = dom IE /\ D by A4,RELAT_1:90
,SCMFSA_2:127;
    then
A7: dom DataPart Initialize IE = D by A4,A6,A5,XBOOLE_1:21;
    let x be set;
    assume
A8: x in dom DataPart Initialize IE;
    per cases by A8,A7,XBOOLE_0:def 3;
    suppose
      x in Int-Locations;
      then reconsider x9 = x as Int-Location by SCMFSA_2:11;
      hereby
        per cases;
        suppose
A9:       x9 is read-write;
          thus (DataPart Initialize IE).x = (Initialize IE).x by A8,A7,
FUNCT_1:72,SCMFSA_2:127
            .= IE.x by A9,SCMFSA6C:3;
        end;
        suppose
          x9 is read-only;
          then
A10:      x9 = intloc 0 by SF_MASTR:def 5;
          thus (DataPart Initialize IE).x = (Initialize IE).x9 by A8,A7,
FUNCT_1:72,SCMFSA_2:127
            .= 1 by A10,SCMFSA6C:3
            .= IE.x by A3,A2,A10,SCMFSA8C:96;
        end;
      end;
    end;
    suppose
      x in FinSeq-Locations;
      then reconsider x9 = x as FinSeq-Location by SCMFSA_2:12;
      thus (DataPart Initialize IE).x = (Initialize IE).x9 by A8,A7,FUNCT_1:72
,SCMFSA_2:127
        .= IE.x by SCMFSA6C:3;
    end;
  end;
  hence thesis by FUNCT_1:68,SCMFSA_2:127;
end;

theorem Th12:
  Ig is parahalting or Ig is_halting_on Initialize s & Ig
is_closed_on Initialize s implies IExec(Ig ';' j, s).a = Exec(j, IExec(Ig, s)).
  a
proof
  set I = Ig;
  set Mj = Macro j;
  a in Int-Locations by SCMFSA_2:9;
  then
A1: a in D by XBOOLE_0:def 3;
  assume that
A2: I is parahalting or I is_halting_on Initialize s & I is_closed_on
  Initialize s;
A3: DataPart Initialize IExec(I,s) = DataPart IExec(I, s) by A2,Th11;
  thus IExec(I ';' j, s).a = IExec(Mj,IExec(I,s)).a by A2,Th8
    .= Exec(j, Initialize IExec(I,s)).a by SCMFSA6C:6
    .= (DataPart Exec(j, Initialize IExec(I,s))).a by A1,FUNCT_1:72
,SCMFSA_2:127
    .= (DataPart Exec(j, IExec(I, s))).a by A3,SCMFSA6C:5
    .= Exec(j, IExec(I, s)).a by A1,FUNCT_1:72,SCMFSA_2:127;
end;

theorem Th13:
  Ig is parahalting or Ig is_halting_on Initialize s & Ig
is_closed_on Initialize s implies IExec(Ig ';' j, s).f = Exec(j, IExec(Ig, s)).
  f
proof
  set I = Ig;
  set Mj = Macro j;
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A1: f in D by XBOOLE_0:def 3;
  assume that
A2: I is parahalting or I is_halting_on Initialize s & I is_closed_on
  Initialize s;
A3: DataPart Initialize IExec(I,s) = DataPart IExec(I, s) by A2,Th11;
  thus IExec(I ';' j, s).f = IExec(Mj,IExec(I,s)).f by A2,Th9
    .= Exec(j, Initialize IExec(I,s)).f by SCMFSA6C:6
    .= (DataPart Exec(j, Initialize IExec(I,s))).f by A1,FUNCT_1:72
,SCMFSA_2:127
    .= (DataPart Exec(j, IExec(I, s))).f by A3,SCMFSA6C:5
    .= Exec(j, IExec(I, s)).f by A1,FUNCT_1:72,SCMFSA_2:127;
end;

theorem
  Ig is parahalting or Ig is_halting_on Initialize s & Ig is_closed_on
Initialize s implies DataPart IExec(Ig ';' j, s) = DataPart Exec(j, IExec(Ig, s
  ))
proof
  set I = Ig;
  assume
A1: I is parahalting or I is_halting_on Initialize s & I is_closed_on
  Initialize s;
  then
A2: for f holds IExec(I ';' j, s).f = Exec(j, IExec(I, s)).f by Th13;
  for a holds IExec(I ';' j, s).a = Exec(j, IExec(I, s)).a by A1,Th12;
  hence thesis by A2,SCMFSA6A:38;
end;

theorem Th15:
  J is parahalting or J is_halting_on Exec(i, Initialize s) & J
is_closed_on Exec(i, Initialize s) implies IExec(i ';' J, s).a = IExec(J, Exec(
  i, Initialize s)).a
proof
  set Mi = Macro i;
  assume that
A1: J is parahalting or J is_halting_on Exec(i, Initialize s) & J
  is_closed_on Exec(i, Initialize s);
A2: J is_closed_on IExec(Mi, s) by A1,SCMFSA6C:6,SCMFSA7B:24;
  J is_halting_on IExec(Mi, s) by A1,SCMFSA6C:6,SCMFSA7B:25;
  hence IExec(i ';' J, s).a = IExec(J,IExec(Mi, s)).a by A2,Th8
    .= IExec(J, Exec(i, Initialize s)).a by SCMFSA6C:6;
end;

theorem Th16:
  J is parahalting or J is_halting_on Exec(i, Initialize s) & J
is_closed_on Exec(i, Initialize s) implies IExec(i ';' J, s).f = IExec(J, Exec(
  i, Initialize s)).f
proof
  set Mi = Macro i;
  assume that
A1: J is parahalting or J is_halting_on Exec(i, Initialize s) & J
  is_closed_on Exec(i, Initialize s);
A2: J is_closed_on IExec(Mi, s) by A1,SCMFSA6C:6,SCMFSA7B:24;
  J is_halting_on IExec(Mi, s) by A1,SCMFSA6C:6,SCMFSA7B:25;
  hence IExec(i ';' J, s).f = IExec(J,IExec(Mi, s)).f by A2,Th9
    .= IExec(J, Exec(i, Initialize s)).f by SCMFSA6C:6;
end;

theorem
  J is parahalting or J is_halting_on Exec(i, Initialize s) & J
  is_closed_on Exec(i, Initialize s) implies DataPart IExec(i ';' J, s) =
  DataPart IExec(J, Exec(i, Initialize s))
proof
  assume
A1: J is parahalting or J is_halting_on Exec(i, Initialize s) & J
  is_closed_on Exec(i, Initialize s);
  then
A2: for f holds IExec(i ';' J, s).f = IExec(J, Exec(i, Initialize s)).f by Th16
;
  for a holds IExec(i ';' J, s).a = IExec(J, Exec(i, Initialize s)).a by A1
,Th15;
  hence thesis by A2,SCMFSA6A:38;
end;

begin :: Memory allocation

reserve L for finite Subset of Int-Locations,
  m, n for Element of NAT;

definition
  let d be Int-Location;
  redefine func { d } -> Subset of Int-Locations;
  coherence
  proof
    d in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
    hence thesis by SUBSET_1:55;
  end;
  let e be Int-Location;
  redefine func { d, e } -> Subset of Int-Locations;
  coherence
  proof
A1: e in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
    d in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
    hence thesis by A1,SUBSET_1:56;
  end;
  let f be Int-Location;
  redefine func { d, e, f } -> Subset of Int-Locations;
  coherence
  proof
A2: f in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
A3: e in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
    d in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
    hence thesis by A3,A2,SUBSET_1:57;
  end;
  let g be Int-Location;
  redefine func { d, e, f, g } -> Subset of Int-Locations;
  coherence
  proof
A4: g in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
A5: f in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
A6: e in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
    d in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
    hence thesis by A6,A5,A4,SUBSET_1:58;
  end;
end;

definition
  let L be finite Subset of Int-Locations;
  func RWNotIn-seq L -> Function of NAT, bool NAT means
  :Def2:
  it.0 = {k where
k is Element of NAT : not intloc k in L & k <> 0} & (for i being Element of NAT
, sn being non empty Subset of NAT st it.i = sn holds it.(i+1) = sn \ {min sn})
  & for i being Element of NAT holds it.i is infinite;
  existence
  proof
    set M = L \/ {intloc 0};
    defpred X[Element of NAT] means not intloc $1 in L & $1 <> 0;
    set sn = {k where k is Element of NAT : X[k] };
A1: sn is Subset of NAT from DOMAIN_1:sch 7;
    not Int-Locations c= M;
    then consider x being set such that
A2: x in Int-Locations and
A3: not x in M by TARSKI:def 3;
    reconsider x as Int-Location by A2,SCMFSA_2:11;
    consider k being Element of NAT such that
A4: x = intloc k by SCMFSA_2:19;
    not intloc k in {intloc 0} by A3,A4,XBOOLE_0:def 3;
    then
A5: k <> 0 by TARSKI:def 1;
    not intloc k in L by A3,A4,XBOOLE_0:def 3;
    then k in sn by A5;
    then reconsider sn as non empty Subset of NAT by A1;
    defpred P[Element of NAT, Subset of NAT, Subset of NAT] means for N being
    non empty Subset of NAT st N = $2 holds $3 = $2 \ {min N};
A6: now
      let n be Element of NAT;
      let x be Subset of NAT;
      per cases;
      suppose
        x is empty;
        then P[n, x, {} NAT];
        hence ex y being Subset of NAT st P[n,x,y];
      end;
      suppose
        x is non empty;
        then reconsider x9 = x as non empty Subset of NAT;
        now
          reconsider mx9 = {min x9} as Subset of NAT by ZFMISC_1:37;
          reconsider t = x9 \ mx9 as Subset of NAT;
          take t;
          let N be non empty Subset of NAT;
          assume
          N = x;
          hence t = x \ {min N};
        end;
        hence ex y being Subset of NAT st P[n,x,y];
      end;
    end;
    consider f being Function of NAT, bool NAT such that
A7: f.0 = sn and
A8: for n being (Element of NAT) holds P[n, f.n, f.(n+1)] from
    RECDEF_1:sch 2(A6);
    take f;
    thus f.0 = {v where v is Element of NAT : not intloc v in L & v <> 0} by A7
;
    thus for i be Element of NAT, sn be non empty Subset of NAT st f.i = sn
    holds f.(i+1) = sn \ {min sn} by A8;
    defpred X[Element of NAT] means f.$1 is infinite;
A9: X[0]
    proof
      deffunc U(Element of NAT) = intloc $1;
      set Isn = { U(v) where v is Element of NAT : v in sn };
      assume
      f.0 is finite;
      then
A10:  sn is finite by A7;
      Isn is finite from FRAENKEL:sch 21(A10);
      then reconsider Isn as finite set;
      now
        let x be set;
        hereby
          assume
A11:      x in M \/ Isn;
          per cases by A11,XBOOLE_0:def 3;
          suppose
            x in M;
            hence x in Int-Locations;
          end;
          suppose
            x in Isn;
            then ex k being Element of NAT st intloc k = x & k in sn;
            hence x in Int-Locations by SCMFSA_2:def 4;
          end;
        end;
        assume
        x in Int-Locations;
        then reconsider x9 = x as Int-Location by SCMFSA_2:11;
        consider i being Element of NAT such that
A12:    x9 = intloc i by SCMFSA_2:19;
        now
          assume
A13:      not x in M;
          then not x9 in {intloc 0} by XBOOLE_0:def 3;
          then
A14:      i <> 0 by A12,TARSKI:def 1;
          not intloc i in L by A12,A13,XBOOLE_0:def 3;
          then i in sn by A14;
          hence x in Isn by A12;
        end;
        hence x in M \/ Isn by XBOOLE_0:def 3;
      end;
      hence contradiction by TARSKI:2;
    end;
A15: for n st X[n] holds X[n+1]
    proof
      let n;
      assume
A16:  f.n is infinite;
      then reconsider sn = f.n as non empty Subset of NAT;
      min sn in sn by XXREAL_2:def 7;
      then
A17:  {min sn} c= sn by ZFMISC_1:37;
      assume
      f.(n+1) is finite;
      then reconsider sn1 = f.(n+1) as finite set;
A18:  sn1 \/ {min sn} is finite;
      f.(n+1) = sn \ {min sn} by A8;
      hence contradiction by A16,A17,A18,XBOOLE_1:45;
    end;
    thus for n being Element of NAT holds X[n] from NAT_1:sch 1(A9, A15);
  end;
  uniqueness
  proof
    let IT1, IT2 be Function of NAT, bool NAT such that
A19: IT1.0 = {k where k is Element of NAT : not intloc k in L & k <> 0
    } and
A20: for i being Element of NAT, sn being non empty Subset of NAT st
    IT1.i = sn holds IT1.(i+1) = sn \ {min sn} and
    for i being Element of NAT holds IT1.i is infinite and
A21: IT2.0 = {k where k is Element of NAT : not intloc k in L & k <> 0
    } and
A22: for i being Element of NAT, sn being non empty Subset of NAT st
    IT2.i = sn holds IT2.(i+1) = sn \ {min sn} and
A23: for i being Element of NAT holds IT2.i is infinite;
    now
      defpred X[Element of NAT] means IT1.$1 = IT2.$1;
      thus NAT = dom IT1 by FUNCT_2:def 1;
      thus NAT = dom IT2 by FUNCT_2:def 1;
A24:  for n st X[n] holds X[n+1]
      proof
        let n be Element of NAT;
        assume
A25:    IT1.n = IT2.n;
        then reconsider IT1n = IT1.n as non empty Subset of NAT by A23;
        thus IT1.(n+1) = IT1n \ {min IT1n} by A20
          .= IT2.(n+1) by A22,A25;
      end;
A26:  X[0] by A19,A21;
      for n being Element of NAT holds X[n] from NAT_1:sch 1(A26, A24);
      hence for x being set st x in NAT holds IT1.x = IT2.x;
    end;
    hence IT1 = IT2 by FUNCT_1:9;
  end;
end;

registration
  let L be finite Subset of Int-Locations, n be Element of NAT;
  cluster (RWNotIn-seq L).n -> non empty;
  coherence by Def2;
end;

theorem Th18:
  not 0 in (RWNotIn-seq L).n & for m st m in (RWNotIn-seq L).n
  holds not intloc m in L
proof
  set RL = RWNotIn-seq L;
  defpred X[Element of NAT] means not 0 in RL.$1 & for m st m in RL.$1 holds
  not intloc m in L;
A1: X[0]
  proof
A2: RL.0 = {k where k is Element of NAT : not intloc k in L & k <> 0} by Def2;
    hereby
      assume
      0 in RL.0;
      then
      ex k being Element of NAT st k = 0 &( not intloc k in L)& k <> 0
      by A2;
      hence contradiction;
    end;
    let m;
    assume
    m in RL.0;
    then ex k being Element of NAT st k = m &( not intloc k in L)& k <> 0
    by A2;
    hence thesis;
  end;
A3: for n st X[n] holds X[n+1]
  proof
    let n such that
A4: not 0 in RL.n and
A5: for m st m in RL.n holds not intloc m in L;
    reconsider sn = RL.n as non empty Subset of NAT;
A6: RL.(n+1) = sn \ {min sn} by Def2;
    hence not 0 in RL.(n+1) by A4,XBOOLE_0:def 5;
    let m;
    assume
    m in RL.(n+1);
    then m in RL.n by A6,XBOOLE_0:def 5;
    hence thesis by A5;
  end;
  for n being Element of NAT holds X[n] from NAT_1:sch 1(A1, A3);
  hence thesis;
end;

theorem Th19:
  min ((RWNotIn-seq L).n) < min ((RWNotIn-seq L).(n+1))
proof
  set RL = RWNotIn-seq L;
  set sn = RL.n;
  set sn1 = RL.(n+1);
  assume
A1: min ((RWNotIn-seq L).n) >= min ((RWNotIn-seq L).(n+1));
A2: sn1 = sn \ {min sn} by Def2;
  then min sn <= min sn1 by XBOOLE_1:36,XXREAL_2:60;
  then min sn = min sn1 by A1,XXREAL_0:1;
  then
A3: min sn1 in {min sn} by TARSKI:def 1;
  min sn1 in sn1 by XXREAL_2:def 7;
  hence contradiction by A2,A3,XBOOLE_0:def 5;
end;

theorem Th20:
  n < m implies min ((RWNotIn-seq L).n) < min ((RWNotIn-seq L).m)
proof
  set RL = RWNotIn-seq L;
  now
    let n;
    defpred X[Element of NAT] means n < $1 implies min (RL.n) < min (RL.$1);
A1: for m st X[m] holds X[m+1]
    proof
      let m such that
A2:   n < m implies min (RL.n) < min (RL.m);
      assume
      n < m+1;
      then
A3:   n <= m by NAT_1:13;
      per cases by A3,XXREAL_0:1;
      suppose
        n = m;
        hence min (RL.n) < min (RL.(m+1)) by Th19;
      end;
      suppose
        n < m;
        hence min (RL.n) < min (RL.(m+1)) by A2,Th19,XXREAL_0:2;
      end;
    end;
A4: X[0] by NAT_1:2;
    thus for n being Element of NAT holds X[n] from NAT_1:sch 1(A4, A1);
  end;
  hence thesis;
end;

definition
  let n be Element of NAT, L be finite Subset of Int-Locations;
  func n-thRWNotIn L -> Int-Location equals
  intloc min ((RWNotIn-seq L).n);
  correctness;
end;

notation
  let n be Element of NAT, L be finite Subset of Int-Locations;
  synonym n-stRWNotIn L for n-thRWNotIn L;
  synonym n-ndRWNotIn L for n-thRWNotIn L;
  synonym n-rdRWNotIn L for n-thRWNotIn L;
end;

registration
  let n be Element of NAT, L be finite Subset of Int-Locations;
  cluster n-thRWNotIn L -> read-write;
  coherence
  proof
    set sn = (RWNotIn-seq L).n;
    set FNI = n-thRWNotIn L;
A1: min sn in sn by XXREAL_2:def 7;
    now
      assume
      FNI = intloc 0;
      then min ((RWNotIn-seq L).n) = 0 by AMI_3:52;
      hence contradiction by A1,Th18;
    end;
    hence thesis by SF_MASTR:def 5;
  end;
end;

theorem Th21:
  not n-thRWNotIn L in L
proof
  set FNI = n-thRWNotIn L;
  set sn = (RWNotIn-seq L).n;
  min sn in sn by XXREAL_2:def 7;
  hence thesis by Th18;
end;

theorem Th22:
  n <> m implies n-thRWNotIn L <> m-thRWNotIn L
proof
  assume
  n <> m;
  then n < m or m < n by XXREAL_0:1;
  then
A1: min ((RWNotIn-seq L).n) <> min ((RWNotIn-seq L).m) by Th20;
  assume
  n-thRWNotIn L = m-thRWNotIn L;
  hence contradiction by A1,AMI_3:52;
end;

definition
  let n be Element of NAT, p be preProgram of SCM+FSA;
  func n-thNotUsed p -> Int-Location equals
  n-thRWNotIn UsedIntLoc p;
  correctness;
end;

notation
  let n be Element of NAT, p be preProgram of SCM+FSA;
  synonym n-stNotUsed p for n-thNotUsed p;
  synonym n-ndNotUsed p for n-thNotUsed p;
  synonym n-rdNotUsed p for n-thNotUsed p;
end;

registration
  let n be Element of NAT, p be preProgram of SCM+FSA;
  cluster n-thNotUsed p -> read-write;
  coherence;
end;

begin :: A macro for the Fibonacci sequence

theorem Th23:
  a in UsedIntLoc swap(a, b) & b in UsedIntLoc swap(a, b)
proof
  set FNU = FirstNotUsed Macro (a := b);
  set i0 = FirstNotUsed Macro (a := b) := a;
  set i1 = a := b;
  set i2 = b := FirstNotUsed Macro (a := b);
A1: UsedIntLoc swap(a, b) = UsedIntLoc (i0 ';' i1 ';' i2) by SCMFSA6C:def 4
    .= (UsedIntLoc (i0 ';' i1)) \/ (UsedIntLoc i2) by SF_MASTR:34
    .= (UsedIntLoc (i0 ';' i1)) \/ {b, FNU} by SF_MASTR:18
    .= (UsedIntLoc i0) \/ (UsedIntLoc i1) \/ {b, FNU} by SF_MASTR:35
    .= (UsedIntLoc i0) \/ {a, b} \/ {b, FNU} by SF_MASTR:18
    .= {FNU, a} \/ {a, b} \/ {b, FNU} by SF_MASTR:18
    .= {FNU, a, a, b} \/ {b, FNU} by ENUMSET1:45
    .= {FNU, a, a, b, b, FNU} by ENUMSET1:54;
  hence a in UsedIntLoc swap(a, b) by ENUMSET1:def 4;
  thus thesis by A1,ENUMSET1:def 4;
end;

definition
  let N, result be Int-Location;
  func Fib_macro (N, result) -> Program of SCM+FSA equals
  2-ndRWNotIn
  UsedIntLoc swap(result, 1-stRWNotIn {N, result}) := N ';' (SubFrom(result,
result)) ';' (1-stRWNotIn {N, result} := intloc 0) ';' ((1-stRWNotIn UsedIntLoc
swap(result, 1-stRWNotIn {N, result})) := (2-ndRWNotIn UsedIntLoc swap(result,
  1-stRWNotIn {N, result}))) ';' Times( 1-stRWNotIn UsedIntLoc swap(result, 1
-stRWNotIn {N, result}), AddTo(result, 1-stRWNotIn {N, result}) ';' swap(result
  , 1-stRWNotIn {N, result}) ) ';' (N := (2-ndRWNotIn UsedIntLoc swap(result, 1
  -stRWNotIn {N, result})));
  correctness;
end;
::  set next = 1-stRWNotIn {N, result};
::      local variable
::  set aux  = 1-stRWNotIn UsedIntLoc swap(result, next);
::      for the control variable of Times, must not be changed by swap
::  set N_save = 2-ndRWNotIn UsedIntLoc swap(result, next);
::      for saving and restoring N
:: - requires: N <> result
:: - does not change N
:: - note: Times allocates no memory

theorem
  for N, result being read-write Int-Location st N <> result for n being
Element of NAT st n = s.N holds IExec(Fib_macro(N, result), s).result = Fib n &
  IExec(Fib_macro(N, result), s).N = s.N
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let N, result be read-write Int-Location such that
A1: N <> result;
  set i0 = SubFrom(result, result);
  set next = 1-stRWNotIn {N, result};
  set aux = 1-stRWNotIn UsedIntLoc swap(result, next);
  set Nsave = 2-ndRWNotIn UsedIntLoc swap(result, next);
  set i00 = Nsave := N;
  set i1 = next := intloc 0;
  set i2 = aux := Nsave;
  set i30 = AddTo (result, next);
  set I31 = swap(result, next);
  set i02 = i00 ';' i0 ';' i1 ';' i2;
  set s1 = IExec(i02, s);
  reconsider I301 = i30 ';' I31 as good parahalting Program of SCM+FSA;
  set I3 = Times( aux, I301 );
  set i4 = N := Nsave;
  defpred P[Element of NAT] means for s1 being State of SCM+FSA st $1 = s1.aux
& s1.intloc 0 = 1 holds IExec(I3, s1).Nsave = s1.Nsave & for m being Element of
NAT st s1.result = Fib m & s1.next = Fib (m+1) holds IExec(I3, s1).result = Fib
  (m + $1) & IExec(I3, s1).next = Fib (m + 1 + $1);
  let n be Element of NAT such that
A2: n = s.N;
  not next in {N, result} by Th21;
  then
A3: result <> next by TARSKI:def 2;
A4: Nsave <> aux by Th22;
A5: Nsave <> next by Th21,Th23;
A6: Nsave <> result by Th21,Th23;
A7: s1.aux = Exec(i2, IExec(i00 ';' i0 ';' i1, s)).aux by SCMFSA6C:7
    .= IExec(i00 ';' i0 ';' i1, s).Nsave by SCMFSA_2:89
    .= Exec(i1, IExec(i00 ';' i0, s)).Nsave by SCMFSA6C:7
    .= IExec(i00 ';' i0, s).Nsave by A5,SCMFSA_2:89
    .= Exec(i0, Exec(i00, Initialize s)).Nsave by SCMFSA6C:9
    .= Exec(i00, Initialize s).Nsave by A6,SCMFSA_2:91
    .= (Initialize s).N by SCMFSA_2:89
    .= s.N by SCMFSA6C:3;
A8: I31 does_not_destroy aux by Th1,Th21;
A9: i02 is_closed_on Initialize s by SCMFSA7B:24;
A10: s1.Nsave = Exec(i2, IExec(i00 ';' i0 ';' i1, s)).Nsave by SCMFSA6C:7
    .= IExec(i00 ';' i0 ';' i1, s).Nsave by A4,SCMFSA_2:89
    .= Exec(i1, IExec(i00 ';' i0, s)).Nsave by SCMFSA6C:7
    .= IExec(i00 ';' i0, s).Nsave by A5,SCMFSA_2:89
    .= Exec(i0, Exec(i00, Initialize s)).Nsave by SCMFSA6C:9
    .= Exec(i00, Initialize s).Nsave by A6,SCMFSA_2:91
    .= (Initialize s).N by SCMFSA_2:89
    .= s.N by SCMFSA6C:3;
A11: i02 is_halting_on Initialize s by SCMFSA7B:25;
  reconsider i02 as good Program of SCM+FSA;
A12: not aux in UsedIntLoc I31 by Th21;
A13: result in UsedIntLoc I31 by Th23;
  then Macro i30 does_not_destroy aux by A12,SCMFSA7B:13,SCMFSA8C:77;
  then
A14: I301 does_not_destroy aux by A8,SCMFSA8C:81;
A15: next in UsedIntLoc I31 by Th23;
A16: now
    let n be Element of NAT such that
A17: P[n];
    thus P[n+1]
    proof
      let s1 be State of SCM+FSA such that
A18:  n+1 = s1.aux and
      s1.intloc 0 = 1;
      set s2 = IExec(I301 ';' SubFrom(aux, intloc 0), s1);
A19:  s1.aux > 0 by A18,NAT_1:3;
      then
A20:  s2.aux = n+1-1 by A14,A18,SCMFSA8C:124
        .= n;
A21:  s2.intloc 0 = Exec(SubFrom(aux, intloc 0), IExec(I301, s1)).intloc
      0 by SCMFSA6C:7
        .= IExec(I301, s1).intloc 0 by SCMFSA_2:91
        .= 1 by SCMFSA6B:35;
A22:  DataPart IExec(I3, s1) = DataPart IExec(I3, s2) by A14,A19,SCMFSA8C:124;
      hence IExec(I3, s1).Nsave = IExec(I3, s2).Nsave by SCMFSA6A:38
        .= s2.Nsave by A17,A20,A21
        .= Exec(SubFrom(aux, intloc 0), IExec(I301, s1)).Nsave by SCMFSA6C:7
        .= IExec(I301, s1).Nsave by A4,SCMFSA_2:91
        .= IExec(I31, Exec(i30, Initialize s1)).Nsave by SCMFSA8B:12
        .= Exec(i30, Initialize s1).Nsave by Th21,SCMFSA6B:22
        .= (Initialize s1).Nsave by A6,SCMFSA_2:90
        .= s1.Nsave by SCMFSA6C:3;
      let m be Element of NAT;
      assume that
A23:  s1.result = Fib m and
A24:  s1.next = Fib (m+1);
A25:  s2.next = Exec(SubFrom(aux, intloc 0), IExec(I301, s1)).next by
SCMFSA6C:7
        .= IExec(I301, s1).next by A12,A15,SCMFSA_2:91
        .= IExec(I31, Exec(i30, Initialize s1)).next by SCMFSA8B:12
        .= Exec(i30, Initialize s1).result by SCMFSA6C:11
        .= (Initialize s1).result + (Initialize s1).next by SCMFSA_2:90
        .= s1.result + (Initialize s1).next by SCMFSA6C:3
        .= s1.result + s1.next by SCMFSA6C:3
        .= Fib (m+1+1) by A23,A24,PRE_FF:1;
A26:  s2.result = Exec(SubFrom(aux, intloc 0), IExec(I301, s1)).result by
SCMFSA6C:7
        .= IExec(I301, s1).result by A12,A13,SCMFSA_2:91
        .= IExec(I31, Exec(i30, Initialize s1)).result by SCMFSA8B:12
        .= Exec(i30, Initialize s1).next by SCMFSA6C:11
        .= (Initialize s1).next by A3,SCMFSA_2:90
        .= Fib (m+1) by A24,SCMFSA6C:3;
      thus IExec(I3, s1).result = IExec(I3, s2).result by A22,SCMFSA6A:38
        .= Fib (m+1+n) by A17,A20,A21,A26,A25
        .= Fib (m+(n+1));
      thus IExec(I3, s1).next = IExec(I3, s2).next by A22,SCMFSA6A:38
        .= Fib (m+1+1+n) by A17,A20,A21,A26,A25
        .= Fib (m+1+(n+1));
    end;
  end;
A27: s1.result = Exec(i2, IExec(i00 ';' i0 ';' i1, s)).result by SCMFSA6C:7
    .= IExec(i00 ';' i0 ';' i1, s).result by A12,A13,SCMFSA_2:89
    .= Exec(i1, IExec(i00 ';' i0, s)).result by SCMFSA6C:7
    .= IExec(i00 ';' i0, s).result by A3,SCMFSA_2:89
    .= Exec(i0, Exec(i00, Initialize s)).result by SCMFSA6C:9
    .= (Exec(i00, Initialize s)).result - (Exec(i00, Initialize s)).result
  by SCMFSA_2:91
    .= Fib 0 by PRE_FF:1;
A28: s1.next = Exec(i2, IExec(i00 ';' i0 ';' i1, s)).next by SCMFSA6C:7
    .= IExec(i00 ';' i0 ';' i1, s).next by A12,A15,SCMFSA_2:89
    .= Exec(i1, IExec(i00 ';' i0, s)).next by SCMFSA6C:7
    .= IExec(i00 ';' i0, s).intloc 0 by SCMFSA_2:89
    .= Exec(i0, Exec(i00, Initialize s)).intloc 0 by SCMFSA6C:9
    .= Exec(i00, Initialize s).intloc 0 by SCMFSA_2:91
    .= (Initialize s).intloc 0 by SCMFSA_2:89
    .= Fib (0+1) by PRE_FF:1,SCMFSA6C:3;
A29: s1.intloc 0 = Exec(i2, IExec(i00 ';' i0 ';' i1, s)).intloc 0 by SCMFSA6C:7
    .= IExec(i00 ';' i0 ';' i1, s).intloc 0 by SCMFSA_2:89
    .= Exec(i1, IExec(i00 ';' i0, s)).intloc 0 by SCMFSA6C:7
    .= IExec(i00 ';' i0, s).intloc 0 by SCMFSA_2:89
    .= Exec(i0, Exec(i00, Initialize s)).intloc 0 by SCMFSA6C:9
    .= Exec(i00, Initialize s).intloc 0 by SCMFSA_2:91
    .= (Initialize s).intloc 0 by SCMFSA_2:89
    .= 1 by SCMFSA6C:3;
  then
A30: I3 is_closed_on s1 by A14,SCMFSA8C:119;
A31: P[0]
  proof
    let s1 be State of SCM+FSA;
    assume that
A32: 0 = s1.aux and
A33: s1.intloc 0 = 1;
A34: DataPart IExec(I3, s1) = DataPart s1 by A32,A33,SCMFSA8C:123;
    hence IExec(I3, s1).Nsave = s1.Nsave by SCMFSA6A:38;
    let m be Element of NAT;
    assume that
A35: s1.result = Fib m and
A36: s1.next = Fib (m+1);
    thus IExec(I3, s1).result = Fib (m + 0) by A34,A35,SCMFSA6A:38;
    thus thesis by A34,A36,SCMFSA6A:38;
  end;
A37: for n being Element of NAT holds P[n] from NAT_1:sch 1(A31, A16);
A38: I3 is_halting_on s1 by A14,A29,SCMFSA8C:119;
A39: i02 ';' I3 is_closed_on Initialize s by A11,A30,A9,Th3;
  hence
  IExec(Fib_macro(N, result), s).result = Exec(i4, IExec(i02 ';' I3, s)).
  result by A11,A30,A38,A9,Th4,Th12
    .= IExec( i02 ';' I3, s).result by A1,SCMFSA_2:89
    .= IExec(I3, s1).result by A30,A38,Th8
    .= Fib (0+n) by A37,A29,A27,A28,A7,A2
    .= Fib n;
  thus IExec(Fib_macro(N, result), s).N = Exec(i4, IExec(i02 ';' I3, s)).N by
A11,A30,A38,A9,A39,Th4,Th12
    .= IExec( i02 ';' I3, s).Nsave by SCMFSA_2:89
    .= IExec(I3, s1).Nsave by A30,A38,Th8
    .= s.N by A37,A29,A10,A7,A2;
end;

