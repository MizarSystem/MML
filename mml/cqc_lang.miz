:: A Classical First Order Language
::  by Czes{\l}aw Byli\'nski
::
:: Received May 11, 1990
:: Copyright (c) 1990-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies SUBSET_1, NUMBERS, QC_LANG1, FINSEQ_1, PARTFUN1, XXREAL_0,
      FUNCT_1, RELAT_1, NAT_1, TARSKI, FUNCOP_1, QC_LANG3, XBOOLE_0, ZF_MODEL,
      FINSEQ_2, ZF_LANG, CARD_1, REALSET1, XBOOLEAN, BVFUNC_2, MARGREL1,
      CLASSES2, FUNCT_4, CQC_LANG;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, RELAT_1,
      FUNCT_1, FUNCT_2, BINOP_1, PARTFUN1, FUNCOP_1, FUNCT_4, FINSEQ_1,
      FINSEQ_2, QC_LANG1, QC_LANG2, QC_LANG3, XXREAL_0, NAT_1;
 constructors ENUMSET1, PARTFUN1, BINOP_1, FUNCOP_1, FUNCT_4, XXREAL_0,
      MEMBERED, QC_LANG2, QC_LANG3, FINSEQ_2, RELSET_1;
 registrations XBOOLE_0, RELSET_1, FUNCOP_1, FUNCT_4, MEMBERED, QC_LANG1,
      XXREAL_0, FINSEQ_2, CARD_1;
 requirements NUMERALS, SUBSET, BOOLE;
 definitions TARSKI, FUNCOP_1, FINSEQ_2, RELAT_1;
 theorems TARSKI, ENUMSET1, ZFMISC_1, FUNCT_1, FUNCT_2, FINSEQ_1, PARTFUN1,
      FUNCOP_1, QC_LANG1, QC_LANG2, QC_LANG3, FINSEQ_2, RELSET_1, FINSEQ_3,
      FUNCT_4, ORDINAL1, RELAT_1, CARD_1;
 schemes FINSEQ_1, QC_LANG1, QC_LANG3;

begin

reserve i,j,k for Element of NAT;

canceled 6;

reserve x,y for bound_QC-variable;
reserve a for free_QC-variable;
reserve p,q for Element of QC-WFF;
reserve l,l1,l2,ll for FinSequence of QC-variables;

Lm1: not x in fixed_QC-variables
proof
  consider x1,x2 being set such that
A1: x1 in {4} and
  x2 in NAT and
A2: x = [x1,x2] by QC_LANG1:def 2,ZFMISC_1:def 2;
A3: x1 = 4 by A1,TARSKI:def 1;
  assume x in fixed_QC-variables;
  then consider c1,c2 being set such that
A4: c1 in {5} and
  c2 in NAT and
A5: x = [c1,c2] by QC_LANG1:def 3,ZFMISC_1:def 2;
  c1 = 5 by A4,TARSKI:def 1;
  hence contradiction by A2,A5,A3,ZFMISC_1:33;
end;

theorem Th7:
  for x being set holds x in QC-variables iff x in
  fixed_QC-variables or x in free_QC-variables or x in bound_QC-variables
proof
  let x be set;
  thus x in QC-variables implies x in fixed_QC-variables or x in
  free_QC-variables or x in bound_QC-variables
  proof
    assume x in QC-variables;
    then consider x1,x2 being set such that
A1: x1 in {4,5,6} and
A2: x2 in NAT & x = [x1,x2] by QC_LANG1:def 1,ZFMISC_1:def 2;
    x1 = 4 or x1 = 5 or x1 = 6 by A1,ENUMSET1:def 1;
    then x1 in {4} or x1 in {5} or x1 in {6} by TARSKI:def 1;
    hence thesis by A2,QC_LANG1:def 2,def 3,def 4,ZFMISC_1:def 2;
  end;
  thus thesis;
end;

definition
  mode Substitution is PartFunc of free_QC-variables,QC-variables;
end;

reserve f for Substitution;

definition
  let l,f;
  canceled 2;
  func Subst(l,f) -> FinSequence of QC-variables means
  :Def3:
  len it = len l &
for k st 1 <= k & k <= len l holds (l.k in dom f implies it.k = f.(l.k)) & (not
  l.k in dom f implies it.k = l.k);
  existence
  proof
    defpred P[set,set] means (l.$1 in dom f implies $2 = f.(l.$1)) & (not l.$1
    in dom f implies $2 = l.$1);
A1: for k be Nat st k in Seg len l ex y being set st P[k,y]
    proof
      let k be Nat;
      assume k in Seg len l;
      l.k in dom f implies thesis;
      hence thesis;
    end;
    consider s being FinSequence such that
A2: dom s = Seg len l and
A3: for k be Nat st k in Seg len l holds P[k,s.k] from FINSEQ_1:sch 1(
    A1);
    rng s c= QC-variables
    proof
      let y be set;
      assume y in rng s;
      then consider x being set such that
A4:   x in dom s and
A5:   s.x = y by FUNCT_1:def 5;
      reconsider x as Element of NAT by A4;
A6:   now
        per cases;
        case
          l.x in dom f;
          hence s.x = f.(l.x) & f.(l.x) in QC-variables by A2,A3,A4,PARTFUN1:27
;
        end;
        case
          not l.x in dom f;
          hence s.x = l.x by A2,A3,A4;
        end;
      end;
      dom l = Seg len l by FINSEQ_1:def 3;
      hence thesis by A2,A4,A5,A6,FINSEQ_2:13;
    end;
    then reconsider s as FinSequence of QC-variables by FINSEQ_1:def 4;
    take s;
    thus len s = len l by A2,FINSEQ_1:def 3;
    let k;
    assume 1 <= k & k <= len l;
    then k in dom l by FINSEQ_3:27;
    then k in Seg len l by FINSEQ_1:def 3;
    hence thesis by A3;
  end;
  uniqueness
  proof
    let l1,l2 such that
A7: len l1 = len l and
A8: for k st 1 <= k & k <= len l holds (l.k in dom f implies l1.k = f
    .(l.k)) & (not l.k in dom f implies l1.k = l.k) and
A9: len l2 = len l and
A10: for k st 1 <= k & k <= len l holds (l.k in dom f implies l2.k = f
    .(l.k)) & (not l.k in dom f implies l2.k = l.k);
    now
      let k be Nat;
      assume
A11:  1 <= k & k <= len l;
A12:  k in NAT by ORDINAL1:def 13;
      then
A13:  not l.k in dom f implies l1.k = l.k by A8,A11;
      l.k in dom f implies l1.k = f.(l.k) by A8,A12,A11;
      hence l1.k = l2.k by A10,A12,A11,A13;
    end;
    hence thesis by A7,A9,FINSEQ_1:18;
  end;
end;

registration
  let k;
  let l be QC-variable_list of k;
  let f;
  cluster Subst(l,f) -> k-element;
  coherence
  proof
    len Subst(l,f) = len l & len l = k by Def3,CARD_1:def 13;
    hence thesis by CARD_1:def 13;
  end;
end;

canceled 2;

theorem Th10:
  a .--> x is Substitution
proof
  set f = a .--> x;
  rng f = {x} by FUNCOP_1:14;
  then
A1: rng f c= QC-variables by ZFMISC_1:37;
  dom f = {a} by FUNCOP_1:19;
  then dom f c= free_QC-variables by ZFMISC_1:37;
  hence thesis by A1,RELSET_1:11;
end;

definition
  let a,x;
  redefine func a .--> x -> Substitution;
  coherence by Th10;
end;

theorem Th11:
  f = a .--> x & ll = Subst(l,f) & 1 <= k & k <= len l implies (l.
  k = a implies ll.k = x) & (l.k <> a implies ll.k = l.k)
proof
  set f9 = a .--> x;
  assume
A1: f = a .--> x & ll = Subst(l,f) & 1 <= k & k <= len l;
  thus l.k = a implies ll.k = x
  proof
A2: f9.a = x by FUNCOP_1:87;
    assume
A3: l.k = a;
    then l.k in { a } by TARSKI:def 1;
    then l.k in dom(f9) by FUNCOP_1:19;
    hence thesis by A1,A3,A2,Def3;
  end;
  assume l.k <> a;
  then not l.k in { a } by TARSKI:def 1;
  then not l.k in dom(f9) by FUNCOP_1:19;
  hence thesis by A1,Def3;
end;

definition
  func CQC-WFF -> Subset of QC-WFF equals
  {s where s is QC-formula: Fixed s =
  {} & Free s = {} };
  coherence
  proof
    set F = {s where s is QC-formula: Fixed s = {} & Free s = {} };
    F c= QC-WFF
    proof
      let x be set;
      assume x in F;
      then ex s being QC-formula st s = x & Fixed s = {} & Free s = {};
      hence thesis;
    end;
    hence thesis;
  end;
end;

registration
  cluster CQC-WFF -> non empty;
  coherence
  proof
    VERUM in {s where s is QC-formula: Fixed s = {} & Free s = {} } by
QC_LANG3:65,76;
    hence thesis;
  end;
end;

canceled;

theorem Th13:
  p is Element of CQC-WFF iff Fixed p = {} & Free p = {}
proof
  thus p is Element of CQC-WFF implies Fixed p = {} & Free p = {}
  proof
    assume p is Element of CQC-WFF;
    then p in CQC-WFF;
    then ex s being QC-formula st s = p & Fixed s = {} & Free s = {};
    hence thesis;
  end;
  assume Fixed p = {} & Free p = {};
  then p in CQC-WFF;
  hence thesis;
end;

registration
  let k;
  cluster bound_QC-variables-valued QC-variable_list of k;
  existence
  proof
    set l = k |-> x.0;
A1: dom l = Seg k by FUNCOP_1:19;
    rng l c= QC-variables
    proof
      let y be set;
      assume y in rng l;
      then consider x being set such that
A2:   x in dom l and
A3:   l.x = y by FUNCT_1:def 5;
      y = x.0 by A1,A2,A3,FINSEQ_2:71;
      hence thesis;
    end;
    then reconsider l as QC-variable_list of k by FINSEQ_1:def 4;
    take l;
    let x be set;
    assume x in rng l;
    then consider i being set such that
A4: i in dom l and
A5: x = l.i by FUNCT_1:def 5;
    reconsider i as Element of NAT by A4;
    l.i = x.0 by A1,A4,FINSEQ_2:71;
    hence thesis by A5;
  end;
end;

definition
  let k;
  mode CQC-variable_list of k is bound_QC-variables-valued QC-variable_list of
    k;
end;

canceled;

theorem Th15:
  for l being QC-variable_list of k holds l is CQC-variable_list
of k iff { l.i : 1 <= i & i <= len l & l.i in free_QC-variables } = {} & { l.j
  : 1 <= j & j <= len l & l.j in fixed_QC-variables } = {}
proof
  let l be QC-variable_list of k;
  set FR = { l.i : 1 <= i & i <= len l & l.i in free_QC-variables };
  set FI = { l.j : 1 <= j & j <= len l & l.j in fixed_QC-variables };
  thus l is CQC-variable_list of k implies FR = {} & FI = {}
  proof
    assume l is CQC-variable_list of k;
    then reconsider l as CQC-variable_list of k;
    now
      set x =the  Element of FR;
      assume FR <> {};
      then x in FR;
      then consider i such that
      x = l.i and
A1:   1 <= i & i <= len l and
A2:   l.i in free_QC-variables;
      i in dom l by A1,FINSEQ_3:27;
      then rng l c= bound_QC-variables & l.i in rng l by FUNCT_1:def 5
,RELAT_1:def 19;
      hence contradiction by A2,QC_LANG3:42;
    end;
    hence FR = {};
    now
      set x =the  Element of FI;
      assume FI <> {};
      then x in FI;
      then consider i such that
      x = l.i and
A3:   1 <= i & i <= len l and
A4:   l.i in fixed_QC-variables;
      i in dom l by A3,FINSEQ_3:27;
      then rng l c= bound_QC-variables & l.i in rng l by FUNCT_1:def 5
,RELAT_1:def 19;
      hence contradiction by A4,QC_LANG3:41;
    end;
    hence thesis;
  end;
  assume that
A5: FR = {} and
A6: FI = {};
  l is bound_QC-variables-valued
  proof
    let x be set;
A7: rng l c= QC-variables by FINSEQ_1:def 4;
    assume x in rng l;
    then consider i being set such that
A8: i in dom l and
A9: l.i = x by FUNCT_1:def 5;
    reconsider i as Element of NAT by A8;
A10: 1 <= i & i <= len l by A8,FINSEQ_3:27;
A11: now
      assume x in fixed_QC-variables;
      then x in FI by A9,A10;
      hence contradiction by A6;
    end;
A12: now
      assume x in free_QC-variables;
      then x in FR by A9,A10;
      hence contradiction by A5;
    end;
    l.i in rng l by A8,FUNCT_1:def 5;
    hence thesis by A9,A7,A11,A12,Th7;
  end;
  hence thesis;
end;

reserve r,s for Element of CQC-WFF;

theorem
  VERUM is Element of CQC-WFF by Th13,QC_LANG3:65,76;

theorem Th17:
  for P being QC-pred_symbol of k for l being QC-variable_list of
  k holds P!l is Element of CQC-WFF iff { l.i : 1 <= i & i <= len l & l.i in
  free_QC-variables } = {} & { l.j : 1 <= j & j <= len l & l.j in
  fixed_QC-variables } = {}
proof
  let P be QC-pred_symbol of k;
  let l be QC-variable_list of k;
A1: Free(P!l) = { l.j : 1 <= j & j <= len l & l.j in free_QC-variables } by
QC_LANG3:66;
  Fixed(P!l) = { l.i : 1 <= i & i <= len l & l.i in fixed_QC-variables }
  by QC_LANG3:77;
  hence thesis by A1,Th13;
end;

definition
  canceled;
  let k;
  let P be QC-pred_symbol of k;
  let l be CQC-variable_list of k;
  redefine func P!l -> Element of CQC-WFF;
  coherence
  proof
A1: { l.j : 1 <= j & j <= len l & l.j in fixed_QC-variables } = {} by Th15;
    { l.i : 1 <= i & i <= len l & l.i in free_QC-variables } = {} by Th15;
    hence thesis by A1,Th17;
  end;
end;

theorem Th18:
  'not' p is Element of CQC-WFF iff p is Element of CQC-WFF
proof
  thus 'not' p is Element of CQC-WFF implies p is Element of CQC-WFF
  proof
    assume
A1: 'not' p is Element of CQC-WFF;
    then Free 'not' p = {} by Th13;
    then
A2: Free p = {} by QC_LANG3:67;
    Fixed 'not' p = {} by A1,Th13;
    then Fixed p = {} by QC_LANG3:78;
    hence thesis by A2,Th13;
  end;
  assume p is Element of CQC-WFF;
  then reconsider r = p as Element of CQC-WFF;
  Fixed r = {} by Th13;
  then
A3: Fixed 'not' r = {} by QC_LANG3:78;
  Free r = {} by Th13;
  then Free 'not' r = {} by QC_LANG3:67;
  hence thesis by A3,Th13;
end;

theorem Th19:
  p '&' q is Element of CQC-WFF iff p is Element of CQC-WFF & q is
  Element of CQC-WFF
proof
  thus p '&' q is Element of CQC-WFF implies p is Element of CQC-WFF & q is
  Element of CQC-WFF
  proof
    assume
A1: p '&' q is Element of CQC-WFF;
    then Fixed(p '&' q) = {} by Th13;
    then
A2: Fixed p \/ Fixed q = {} by QC_LANG3:80;
    then
A3: Fixed p = {};
    Free(p '&' q) = {} by A1,Th13;
    then
A4: Free p \/ Free q = {} by QC_LANG3:69;
    then Free p = {};
    hence thesis by A4,A2,A3,Th13;
  end;
  assume p is Element of CQC-WFF & q is Element of CQC-WFF;
  then reconsider r = p, s = q as Element of CQC-WFF;
  Fixed r = {} by Th13;
  then Fixed r \/ Fixed s = {} by Th13;
  then
A5: Fixed(r '&' s) = {} by QC_LANG3:80;
  Free r = {} by Th13;
  then Free r \/ Free s = {} by Th13;
  then Free (r '&' s) = {} by QC_LANG3:69;
  hence thesis by A5,Th13;
end;

definition
  redefine func VERUM -> Element of CQC-WFF;
  coherence by Th13,QC_LANG3:65,76;
  let r;
  redefine func 'not' r -> Element of CQC-WFF;
  coherence by Th18;
  let s;
  redefine func r '&' s -> Element of CQC-WFF;
  coherence by Th19;
end;

theorem Th20:
  r => s is Element of CQC-WFF
proof
  r => s = 'not' (r '&' 'not' s) by QC_LANG2:def 2;
  hence thesis;
end;

theorem Th21:
  r 'or' s is Element of CQC-WFF
proof
  r 'or' s = 'not' ('not' r '&' 'not' s) by QC_LANG2:def 3;
  hence thesis;
end;

theorem Th22:
  r <=> s is Element of CQC-WFF
proof
  r <=> s = (r => s) '&' (s => r) by QC_LANG2:def 4
    .= ( 'not' (r '&' 'not' s) ) '&' (s => r) by QC_LANG2:def 2
    .= ( 'not' (r '&' 'not' s) ) '&' ( 'not' (s '&' 'not' r) ) by
QC_LANG2:def 2;
  hence thesis;
end;

definition
  let r,s;
  redefine func r => s -> Element of CQC-WFF;
  coherence by Th20;
  redefine func r 'or' s -> Element of CQC-WFF;
  coherence by Th21;
  redefine func r <=> s -> Element of CQC-WFF;
  coherence by Th22;
end;

theorem Th23:
  All(x,p) is Element of CQC-WFF iff p is Element of CQC-WFF
proof
  thus All(x,p) is Element of CQC-WFF implies p is Element of CQC-WFF
  proof
    assume
A1: All(x,p) is Element of CQC-WFF;
    then Fixed All(x,p) = {} by Th13;
    then
A2: Fixed p = {} by QC_LANG3:81;
    Free All(x,p) = {} by A1,Th13;
    then Free p = {} by QC_LANG3:70;
    hence thesis by A2,Th13;
  end;
  assume
A3: p is Element of CQC-WFF;
  then Fixed p = {} by Th13;
  then
A4: Fixed All(x,p) = {} by QC_LANG3:81;
  Free p = {} by A3,Th13;
  then Free All(x,p) = {} by QC_LANG3:70;
  hence thesis by A4,Th13;
end;

definition
  let x,r;
  redefine func All(x,r) -> Element of CQC-WFF;
  coherence by Th23;
end;

theorem Th24:
  Ex(x,r) is Element of CQC-WFF
proof
  Ex(x,r) = 'not' All(x,'not' r) by QC_LANG2:def 5;
  hence thesis;
end;

definition
  let x,r;
  redefine func Ex(x,r) -> Element of CQC-WFF;
  coherence by Th24;
end;

scheme
  CQCInd { P[set] }: for r holds P[r]
provided
A1: for r,s,x,k for l being CQC-variable_list of k for P being
QC-pred_symbol of k holds P[VERUM] & P[P!l] & (P[r] implies P['not' r]) & (P[r]
& P[s] implies P[r '&' s]) & (P[r] implies P[All(x, r)])
proof
  defpred Prop[Element of QC-WFF] means $1 is Element of CQC-WFF implies P[ $1
  ];
A2: for p being Element of QC-WFF st Prop[p] holds Prop['not' p]
  proof
    let p be Element of QC-WFF;
    assume
A3: Prop[p];
    assume 'not' p is Element of CQC-WFF;
    then p is Element of CQC-WFF by Th18;
    hence thesis by A1,A3;
  end;
A4: for p,q being Element of QC-WFF st Prop[p] & Prop[q] holds Prop[p '&' q ]
  proof
    let p,q be Element of QC-WFF;
    assume
A5: ( Prop[p])& Prop[q];
    assume p '&' q is Element of CQC-WFF;
    then p is Element of CQC-WFF & q is Element of CQC-WFF by Th19;
    hence thesis by A1,A5;
  end;
A6: for k being Element of NAT, P being (QC-pred_symbol of k), l being
  QC-variable_list of k holds Prop[P!l]
  proof
    let k be Element of NAT, P be (QC-pred_symbol of k), l be QC-variable_list
    of k;
    assume
A7: P!l is Element of CQC-WFF;
    then
A8: { l.j : 1 <= j & j <= len l & l.j in fixed_QC-variables } = {} by Th17;
    { l.i : 1 <= i & i <= len l & l.i in free_QC-variables } = {} by A7,Th17;
    then l is CQC-variable_list of k by A8,Th15;
    hence thesis by A1;
  end;
A9: for x being bound_QC-variable, p being Element of QC-WFF st Prop[p]
  holds Prop[All(x, p)]
  proof
    let x be bound_QC-variable, p be Element of QC-WFF;
    assume
A10: Prop[p];
    assume All(x,p) is Element of CQC-WFF;
    then p is Element of CQC-WFF by Th23;
    hence thesis by A1,A10;
  end;
A11: Prop[VERUM] by A1;
  for p being Element of QC-WFF holds Prop[p] from QC_LANG1:sch 1 (A6,A11,
  A2,A4,A9);
  hence thesis;
end;

scheme
  CQCFuncEx { D() -> non empty set, V() -> (Element of D()), A(set,set,set) ->
(Element of D()), N(set) -> (Element of D()), C(set,set) -> (Element of D()), Q
(set,set) -> Element of D()} : ex F being Function of CQC-WFF, D() st F.VERUM =
V() & for r,s,x,k for l being CQC-variable_list of k for P being QC-pred_symbol
of k holds F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s)
  & F.All(x,r) = Q(x,F.r) proof
  deffunc q((Element of QC-WFF), Element of D()) = Q(bound_in $1,$2);
  deffunc a(Element of QC-WFF) = A(the_arity_of the_pred_symbol_of $1,
  the_pred_symbol_of $1,the_arguments_of $1);
  consider F being Function of QC-WFF, D() such that
A1: F.VERUM = V() & for p being Element of QC-WFF holds (p is atomic
implies F.p = a(p)) & (p is negative implies F.p = N(F.the_argument_of p)) & (p
  is conjunctive implies F.p = C(F.the_left_argument_of p, F.
the_right_argument_of p)) & (p is universal implies F.p = q(p, F.the_scope_of p
  )) from QC_LANG1:sch 3;
  reconsider G = F|CQC-WFF as Function of CQC-WFF,D() by FUNCT_2:38;
  take G;
  thus G.VERUM = V() by A1,FUNCT_1:72;
  let r,s,x,k;
  let l be CQC-variable_list of k;
  let P be QC-pred_symbol of k;
A2: the_arity_of P = k by QC_LANG1:35;
A3: P!l is atomic by QC_LANG1:def 17;
  then
A4: the_arguments_of (P!l) = l & the_pred_symbol_of (P!l) = P by
QC_LANG1:def 21,def 22;
  thus G.(P!l) = F.(P!l) by FUNCT_1:72
    .= A(k,P,l) by A1,A3,A4,A2;
  set r9 = G.r, s9 = G.s;
A5: r9 = F.r by FUNCT_1:72;
A6: r '&' s is conjunctive by QC_LANG1:def 19;
  then
A7: the_left_argument_of(r '&' s) = r & the_right_argument_of(r '&' s) = s
  by QC_LANG1:def 24,def 25;
A8: 'not' r is negative by QC_LANG1:def 18;
  then
A9: the_argument_of 'not' r = r by QC_LANG1:def 23;
  thus G.('not' r) = F.('not' r) by FUNCT_1:72
    .= N(r9) by A1,A5,A8,A9;
A10: s9 = F.s by FUNCT_1:72;
  thus G.(r '&' s) = F.(r '&' s) by FUNCT_1:72
    .= C(r9,s9) by A1,A5,A10,A6,A7;
A11: All(x,r) is universal by QC_LANG1:def 20;
  then
A12: bound_in All(x,r) = x & the_scope_of All(x,r) = r by QC_LANG1:def 26
,def 27;
  thus G.All(x,r) = F.All(x,r) by FUNCT_1:72
    .= Q(x,r9) by A1,A5,A11,A12;
end;

scheme
  CQCFuncUniq { D() -> non empty set, F1() -> (Function of CQC-WFF, D()), F2()
  -> (Function of CQC-WFF, D()), V() -> (Element of D()), A(set,set,set) -> (
Element of D()), N(set) -> (Element of D()), C(set,set) -> (Element of D()), Q(
  set,set) -> Element of D()} : F1() = F2()
provided
A1: F1().VERUM = V() & for r,s,x,k for l being CQC-variable_list of k
for P being QC-pred_symbol of k holds F1().(P!l) = A(k,P,l) & F1().('not' r) =
N(F1().r) & F1().(r '&' s) = C(F1().r,F1().s) & F1().All(x,r) = Q(x,F1().r) and
A2: F2().VERUM = V() & for r,s,x,k for l being CQC-variable_list of k
for P being QC-pred_symbol of k holds F2().(P!l) = A(k,P,l) & F2().('not' r) =
N(F2().r) & F2().(r '&' s) = C(F2().r,F2().s) & F2().All(x,r) = Q(x,F2().r)
proof
  defpred P[set] means F1().$1 = F2().$1;
A3: for r,s,x,k for l being CQC-variable_list of k for P being
QC-pred_symbol of k holds P[VERUM] & P[P!l] & (P[r] implies P['not' r]) & (P[r]
  & P[s] implies P[r '&' s]) & (P[r] implies P[All(x, r)])
  proof
    let r,s,x,k;
    let l be CQC-variable_list of k;
    let P be QC-pred_symbol of k;
    thus F1().VERUM = F2().VERUM by A1,A2;
    F1().(P!l) = A(k,P,l) by A1;
    hence F1().(P!l) = F2().(P!l) by A2;
    F1().('not' r) = N(F1().r) by A1;
    hence F1().r = F2().r implies F1().('not' r) = F2().('not' r) by A2;
    F1().(r '&' s) = C(F1().r,F1().s) by A1;
    hence F1().r = F2().r & F1().s = F2().s implies F1().(r '&' s) = F2().(r
    '&' s) by A2;
    F1().All(x,r) = Q(x,F1().r) by A1;
    hence thesis by A2;
  end;
  P[r] from CQCInd(A3);
  hence thesis by FUNCT_2:113;
end;

scheme
  CQCDefcorrectness { D() -> non empty set, p() -> (Element of CQC-WFF), V()
-> (Element of D()), A(set,set,set) -> (Element of D()), N(set) -> (Element of
  D()), C(set,set) -> (Element of D()), Q(set,set) -> Element of D()} : (ex d
  being Element of D() st ex F being Function of CQC-WFF, D() st d = F.p() & F.
  VERUM = V() & for r,s,x,k for l being CQC-variable_list of k for P being
QC-pred_symbol of k holds F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(r '&'
s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r) ) & for d1,d2 being Element of D() st (
ex F being Function of CQC-WFF, D() st d1 = F.p() & F.VERUM = V() & for r,s,x,k
for l being CQC-variable_list of k for P being QC-pred_symbol of k holds F.(P!l
) = A(k,P,l) & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q
(x,F.r) ) & (ex F being Function of CQC-WFF, D() st d2 = F.p() & F.VERUM = V()
& for r,s,x,k for l being CQC-variable_list of k for P being QC-pred_symbol of
k holds F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) &
  F.All(x,r) = Q(x,F.r) ) holds d1 = d2 proof
  thus ex d being Element of D() st ex F being Function of CQC-WFF, D() st d =
  F.p() & F.VERUM = V() & for r,s,x,k for l being CQC-variable_list of k for P
being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(
  r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r)
  proof
    consider F being Function of CQC-WFF, D() such that
A1: F.VERUM = V() & for r,s,x,k for l being CQC-variable_list of k for
P being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F
    .(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r) from CQCFuncEx;
    take F.p(),F;
    thus thesis by A1;
  end;
  let d1,d2 be Element of D();
  given F1 being Function of CQC-WFF, D() such that
A2: d1 = F1.p() and
A3: F1.VERUM = V() & for r,s,x,k for l being CQC-variable_list of k for
P being QC-pred_symbol of k holds F1.(P!l) = A(k,P,l) & F1.('not' r) = N(F1.r)
  & F1.(r '&' s) = C(F1.r,F1.s) & F1.All(x,r) = Q(x,F1.r);
  given F2 being Function of CQC-WFF, D() such that
A4: d2 = F2.p() and
A5: F2.VERUM = V() & for r,s,x,k for l being CQC-variable_list of k for
P being QC-pred_symbol of k holds F2.(P!l) = A(k,P,l) & F2.('not' r) = N(F2.r)
  & F2.(r '&' s) = C(F2.r,F2.s) & F2.All(x,r) = Q(x,F2.r);
  F1 = F2 from CQCFuncUniq(A3,A5);
  hence thesis by A2,A4;
end;

scheme
  CQCDefVERUM { D() -> non empty set, F(set) -> (Element of D()), V() -> (
Element of D()), A(set,set,set) -> (Element of D()), N(set) -> (Element of D())
, C(set,set) -> (Element of D()), Q(set,set) -> Element of D()} : F(VERUM) = V(
  )
provided
A1: for p being (Element of CQC-WFF), d being Element of D() holds d = F
(p) iff ex F being Function of CQC-WFF, D() st d = F.p & F.VERUM = V() & for r,
s,x,k for l being CQC-variable_list of k for P being QC-pred_symbol of k holds
F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,
r) = Q(x,F.r)
proof
  ex F being Function of CQC-WFF, D() st F.VERUM = V() & for r,s,x,k for l
being CQC-variable_list of k for P being QC-pred_symbol of k holds F.(P!l) = A(
k,P,l) & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r
  ) from CQCFuncEx;
  hence thesis by A1;
end;

scheme
  CQCDefatomic { D() -> non empty set, V() -> (Element of D()), F(set) -> (
Element of D()), A(set,set,set) -> (Element of D()), k() -> Element of NAT, P()
  -> (QC-pred_symbol of k()), l() -> (CQC-variable_list of k()), N(set) -> (
Element of D()), C(set,set) -> (Element of D()), Q(set,set) -> Element of D()}
  : F(P()!l()) = A(k(),P(),l())
provided
A1: for p being (Element of CQC-WFF), d being Element of D() holds d = F
(p) iff ex F being Function of CQC-WFF, D() st d = F.p & F.VERUM = V() & for r,
s,x,k for l being CQC-variable_list of k for P being QC-pred_symbol of k holds
F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,
r) = Q(x,F.r)
proof
  consider F being Function of CQC-WFF, D() such that
A2: F.VERUM = V() & for r,s,x,k for l being CQC-variable_list of k for P
being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(
  r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r) from CQCFuncEx;
  A(k(),P(),l()) = F.(P()!l()) by A2;
  hence thesis by A1,A2;
end;

scheme
  CQCDefnegative { D() -> non empty set, F(set) -> (Element of D()), V() -> (
Element of D()), A(set,set,set) -> (Element of D()), N(set) -> (Element of D())
  , r() -> (Element of CQC-WFF), C(set,set) -> (Element of D()), Q(set,set) ->
  Element of D()} : F('not' r()) = N(F(r()))
provided
A1: for p being (Element of CQC-WFF), d being Element of D() holds d = F
(p) iff ex F being Function of CQC-WFF, D() st d = F.p & F.VERUM = V() & for r,
s,x,k for l being CQC-variable_list of k for P being QC-pred_symbol of k holds
F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,
r) = Q(x,F.r)
proof
  consider G being Function of CQC-WFF, D() such that
A2: F(r()) = G.r() and
A3: G.VERUM = V() & for r,s,x,k for l being CQC-variable_list of k for P
being QC-pred_symbol of k holds G.(P!l) = A(k,P,l) & G.('not' r) = N(G.r) & G.(
  r '&' s) = C(G.r,G.s) & G.All(x,r) = Q(x,G.r) by A1;
  consider F being Function of CQC-WFF, D() such that
A4: F.VERUM = V() & for r,s,x,k for l being CQC-variable_list of k for P
being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(
  r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r) from CQCFuncEx;
A5: F.('not' r()) = N(F.r()) by A4;
  F = G from CQCFuncUniq(A4,A3);
  hence thesis by A1,A4,A5,A2;
end;

scheme
  QCDefconjunctive { D() -> non empty set, F(set) -> (Element of D()), V() ->
(Element of D()), A(set,set,set) -> (Element of D()), N(set) -> (Element of D()
), C(set,set) -> (Element of D()), r() -> (Element of CQC-WFF), s() -> (Element
of CQC-WFF), Q(set,set) -> Element of D()} : F(r() '&' s()) = C(F(r()), F(s()))
provided
A1: for p being (Element of CQC-WFF), d being Element of D() holds d = F
(p) iff ex F being Function of CQC-WFF, D() st d = F.p & F.VERUM = V() & for r,
s,x,k for l being CQC-variable_list of k for P being QC-pred_symbol of k holds
F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,
r) = Q(x,F.r)
proof
  consider F2 being Function of CQC-WFF, D() such that
A2: F(s()) = F2.s() and
A3: F2.VERUM = V() & for r,s,x,k for l being CQC-variable_list of k for
P being QC-pred_symbol of k holds F2.(P!l) = A(k,P,l) & F2.('not' r) = N(F2.r)
  & F2.(r '&' s) = C(F2.r,F2.s) & F2.All(x,r) = Q(x,F2.r) by A1;
  consider F1 being Function of CQC-WFF, D() such that
A4: F(r()) = F1.r() and
A5: F1.VERUM = V() & for r,s,x,k for l being CQC-variable_list of k for
P being QC-pred_symbol of k holds F1.(P!l) = A(k,P,l) & F1.('not' r) = N(F1.r)
  & F1.(r '&' s) = C(F1.r,F1.s) & F1.All(x,r) = Q(x,F1.r) by A1;
  consider F being Function of CQC-WFF, D() such that
A6: F.VERUM = V() & for r,s,x,k for l being CQC-variable_list of k for P
being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(
  r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r) from CQCFuncEx;
A7: F.(r() '&' s()) = C(F.r(),F.s()) by A6;
A8: F = F2 from CQCFuncUniq(A6,A3);
  F = F1 from CQCFuncUniq(A6,A5);
  hence thesis by A1,A6,A7,A4,A2,A8;
end;

scheme
  QCDefuniversal { D() -> non empty set, F(set) -> (Element of D()), V() -> (
Element of D()), A(set,set,set) -> (Element of D()), N(set) -> (Element of D())
  , C(set,set) -> (Element of D()), Q(set,set) -> (Element of D()), x() ->
bound_QC-variable, r() -> Element of CQC-WFF} : F(All(x(),r())) = Q(x(),F(r()))
provided
A1: for p being (Element of CQC-WFF), d being Element of D() holds d = F
(p) iff ex F being Function of CQC-WFF, D() st d = F.p & F.VERUM = V() & for r,
s,x,k for l being CQC-variable_list of k for P being QC-pred_symbol of k holds
F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,
r) = Q(x,F.r)
proof
  consider G being Function of CQC-WFF, D() such that
A2: F(r()) = G.r() and
A3: G.VERUM = V() & for r,s,x,k for l being CQC-variable_list of k for P
being QC-pred_symbol of k holds G.(P!l) = A(k,P,l) & G.('not' r) = N(G.r) & G.(
  r '&' s) = C(G.r,G.s) & G.All(x,r) = Q(x,G.r) by A1;
  consider F being Function of CQC-WFF, D() such that
A4: F.VERUM = V() & for r,s,x,k for l being CQC-variable_list of k for P
being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(
  r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r) from CQCFuncEx;
A5: F.All(x(),r()) = Q(x(),F.r()) by A4;
  F = G from CQCFuncUniq(A4,A3);
  hence thesis by A1,A4,A5,A2;
end;

Lm2: for F1,F2 being Function of QC-WFF,QC-WFF st ( for q holds F1.VERUM =
VERUM & (q is atomic implies F1.q = (the_pred_symbol_of q)!Subst(
the_arguments_of q,a.0.-->x)) & (q is negative implies F1.q = 'not' (F1.
the_argument_of q) ) & (q is conjunctive implies F1.q = (F1.
the_left_argument_of q) '&' (F1.the_right_argument_of q)) & (q is universal
implies F1.q = IFEQ(bound_in q,x,q,All(bound_in q,F1.the_scope_of q)))) & ( for
q holds F2.VERUM = VERUM & (q is atomic implies F2.q = (the_pred_symbol_of q)!
Subst(the_arguments_of q,a.0.-->x)) & (q is negative implies F2.q = 'not' (F2.
the_argument_of q) ) & (q is conjunctive implies F2.q = (F2.
the_left_argument_of q) '&' (F2.the_right_argument_of q)) & (q is universal
implies F2.q = IFEQ(bound_in q,x,q,All(bound_in q,F2.the_scope_of q)))) holds
F1 = F2
proof
  deffunc c((Element of QC-WFF), Element of QC-WFF) = $1 '&' $2;
  deffunc n(Element of QC-WFF) = 'not' ($1);
  let F1,F2 be Function of QC-WFF,QC-WFF;
  deffunc a(Element of QC-WFF) = (the_pred_symbol_of $1)!Subst(
  the_arguments_of $1,a.0.-->x);
  deffunc q((Element of QC-WFF), Element of QC-WFF) = IFEQ(bound_in $1,x,$1,
  All(bound_in $1,$2));
  assume for q holds F1.VERUM = VERUM & (q is atomic implies F1.q = a(q)) & (
q is negative implies F1.q = 'not' (F1.the_argument_of q) ) & (q is conjunctive
implies F1.q = (F1.the_left_argument_of q) '&' (F1.the_right_argument_of q)) &
  (q is universal implies F1.q = IFEQ(bound_in q,x,q,All(bound_in q,F1.
  the_scope_of q)));
  then
A1: for p being Element of QC-WFF for d1,d2 being Element of QC-WFF holds (p
  = VERUM implies F1.p = VERUM) & (p is atomic implies F1.p = a(p)) & (p is
negative & d1 = F1.the_argument_of p implies F1.p = n(d1)) & (p is conjunctive
& d1 = F1.the_left_argument_of p & d2 = F1.the_right_argument_of p implies F1.p
= c(d1,d2)) & (p is universal & d1 = F1.the_scope_of p implies F1.p = q(p,d1));
  assume for q holds F2.VERUM = VERUM & (q is atomic implies F2.q = (
  the_pred_symbol_of q)!Subst(the_arguments_of q,a.0.-->x)) & (q is negative
implies F2.q = 'not' (F2.the_argument_of q) ) & (q is conjunctive implies F2.q
  = (F2.the_left_argument_of q) '&' (F2.the_right_argument_of q)) & (q is
universal implies F2.q = IFEQ(bound_in q,x,q,All(bound_in q,F2.the_scope_of q))
  );
  then
A2: for p being Element of QC-WFF for d1,d2 being Element of QC-WFF holds (p
  = VERUM implies F2.p = VERUM) & (p is atomic implies F2.p = a(p)) & (p is
negative & d1 = F2.the_argument_of p implies F2.p = n(d1)) & (p is conjunctive
& d1 = F2.the_left_argument_of p & d2 = F2.the_right_argument_of p implies F2.p
= c(d1,d2)) & (p is universal & d1 = F2.the_scope_of p implies F2.p = q(p,d1));
  thus F1 = F2 from QC_LANG3:sch 1(A1,A2);
end;

definition
  let p,x;
  func p.x -> Element of QC-WFF means
  :Def6:
  ex F being Function of QC-WFF,
QC-WFF st it = F.p & for q holds F.VERUM = VERUM & (q is atomic implies F.q = (
  the_pred_symbol_of q)!Subst(the_arguments_of q,a.0.-->x)) & (q is negative
implies F.q = 'not' (F.the_argument_of q) ) & (q is conjunctive implies F.q = (
  F.the_left_argument_of q) '&' (F.the_right_argument_of q)) & (q is universal
  implies F.q = IFEQ(bound_in q,x,q,All(bound_in q,F.the_scope_of q)));
  existence
  proof
    deffunc q((Element of QC-WFF), Element of QC-WFF) = IFEQ(bound_in $1,x,$1,
    All(bound_in $1,$2));
    deffunc c((Element of QC-WFF), Element of QC-WFF) = $1 '&' $2;
    deffunc n(Element of QC-WFF) = 'not' ($1);
    deffunc a(Element of QC-WFF) = (the_pred_symbol_of $1)!Subst(
    the_arguments_of $1,a.0.-->x);
    consider F being Function of QC-WFF, QC-WFF such that
A1: F.VERUM = VERUM & for p being Element of QC-WFF holds (p is atomic
implies F.p = a(p)) & (p is negative implies F.p = n(F.the_argument_of p)) & (p
is conjunctive implies F.p = c(F.the_left_argument_of p,F.the_right_argument_of
p)) & (p is universal implies F.p = q(p,F.the_scope_of p)) from QC_LANG1:sch 3;
    take F.p,F;
    thus F.p = F.p;
    thus thesis by A1;
  end;
  uniqueness by Lm2;
end;

canceled 3;

theorem Th28:
  VERUM.x = VERUM
proof
  ex F being Function of QC-WFF,QC-WFF st VERUM.x = F.VERUM & for q holds
  F.VERUM = VERUM & (q is atomic implies F.q = (the_pred_symbol_of q)!Subst(
  the_arguments_of q,a.0.-->x)) & (q is negative implies F.q = 'not' (F.
the_argument_of q) ) & (q is conjunctive implies F.q = (F.the_left_argument_of
  q) '&' (F.the_right_argument_of q)) & (q is universal implies F.q = IFEQ(
  bound_in q,x,q,All(bound_in q,F.the_scope_of q))) by Def6;
  hence thesis;
end;

theorem Th29:
  p is atomic implies p.x = (the_pred_symbol_of p)!Subst(
  the_arguments_of p,a.0.-->x)
proof
  ex F being Function of QC-WFF,QC-WFF st p.x = F.p & for q holds F.VERUM
  = VERUM & (q is atomic implies F.q = (the_pred_symbol_of q)!Subst(
  the_arguments_of q,a.0.-->x)) & (q is negative implies F.q = 'not' (F.
the_argument_of q) ) & (q is conjunctive implies F.q = (F.the_left_argument_of
  q) '&' (F.the_right_argument_of q)) & (q is universal implies F.q = IFEQ(
  bound_in q,x,q,All(bound_in q,F.the_scope_of q))) by Def6;
  hence thesis;
end;

theorem Th30:
  for P being QC-pred_symbol of k for l being QC-variable_list of
  k holds (P!l).x = P!Subst(l,a.0.-->x)
proof
  let P be QC-pred_symbol of k;
  let l be QC-variable_list of k;
  reconsider P9 = P as QC-pred_symbol;
A1: P!l is atomic by QC_LANG1:def 17;
  then the_arguments_of (P!l) = l & the_pred_symbol_of (P!l) = P9 by
QC_LANG1:def 21,def 22;
  hence thesis by A1,Th29;
end;

theorem Th31:
  p is negative implies p.x = 'not'((the_argument_of p).x)
proof
  consider F being Function of QC-WFF,QC-WFF such that
A1: p.x = F.p and
A2: for q holds F.VERUM = VERUM & (q is atomic implies F.q = (
  the_pred_symbol_of q)!Subst(the_arguments_of q,a.0.-->x)) & (q is negative
implies F.q = 'not' (F.the_argument_of q) ) & (q is conjunctive implies F.q = (
  F.the_left_argument_of q) '&' (F.the_right_argument_of q)) & (q is universal
  implies F.q = IFEQ(bound_in q,x,q,All(bound_in q,F.the_scope_of q))) by Def6;
  consider G being Function of QC-WFF,QC-WFF such that
A3: (the_argument_of p).x = G.(the_argument_of p) and
A4: for q holds G.VERUM = VERUM & (q is atomic implies G.q = (
  the_pred_symbol_of q)!Subst(the_arguments_of q,a.0.-->x)) & (q is negative
implies G.q = 'not' (G.the_argument_of q) ) & (q is conjunctive implies G.q = (
  G.the_left_argument_of q) '&' (G.the_right_argument_of q)) & (q is universal
  implies G.q = IFEQ(bound_in q,x,q,All(bound_in q,G.the_scope_of q))) by Def6;
  F = G by A2,A4,Lm2;
  hence thesis by A1,A2,A3;
end;

theorem Th32:
  ('not' p).x = 'not'(p.x)
proof
  set 9p = 'not' p;
A1: 9p is negative by QC_LANG1:def 18;
  then the_argument_of 9p = p by QC_LANG1:def 23;
  hence thesis by A1,Th31;
end;

theorem Th33:
  p is conjunctive implies p.x = ((the_left_argument_of p).x) '&'
  ((the_right_argument_of p).x)
proof
  consider F being Function of QC-WFF,QC-WFF such that
A1: p.x = F.p and
A2: for q holds F.VERUM = VERUM & (q is atomic implies F.q = (
  the_pred_symbol_of q)!Subst(the_arguments_of q,a.0.-->x)) & (q is negative
implies F.q = 'not' (F.the_argument_of q) ) & (q is conjunctive implies F.q = (
  F.the_left_argument_of q) '&' (F.the_right_argument_of q)) & (q is universal
  implies F.q = IFEQ(bound_in q,x,q,All(bound_in q,F.the_scope_of q))) by Def6;
  consider F2 being Function of QC-WFF,QC-WFF such that
A3: (the_right_argument_of p).x = F2.(the_right_argument_of p) and
A4: for q holds F2.VERUM = VERUM & (q is atomic implies F2.q = (
  the_pred_symbol_of q)!Subst(the_arguments_of q,a.0.-->x)) & (q is negative
implies F2.q = 'not' (F2.the_argument_of q) ) & (q is conjunctive implies F2.q
  = (F2.the_left_argument_of q) '&' (F2.the_right_argument_of q)) & (q is
universal implies F2.q = IFEQ(bound_in q,x,q,All(bound_in q,F2.the_scope_of q))
  ) by Def6;
A5: F2 = F by A2,A4,Lm2;
  consider F1 being Function of QC-WFF,QC-WFF such that
A6: (the_left_argument_of p).x = F1.(the_left_argument_of p) and
A7: for q holds F1.VERUM = VERUM & (q is atomic implies F1.q = (
  the_pred_symbol_of q)!Subst(the_arguments_of q,a.0.-->x)) & (q is negative
implies F1.q = 'not' (F1.the_argument_of q) ) & (q is conjunctive implies F1.q
  = (F1.the_left_argument_of q) '&' (F1.the_right_argument_of q)) & (q is
universal implies F1.q = IFEQ(bound_in q,x,q,All(bound_in q,F1.the_scope_of q))
  ) by Def6;
  F1 = F by A2,A7,Lm2;
  hence thesis by A1,A2,A6,A3,A5;
end;

theorem Th34:
  (p '&' q).x = (p.x) '&' (q.x)
proof
  set pq = p '&' q;
A1: p '&' q is conjunctive by QC_LANG1:def 19;
  then the_left_argument_of pq = p & the_right_argument_of pq = q by
QC_LANG1:def 24,def 25;
  hence thesis by A1,Th33;
end;

Lm3: p is universal implies p.x = IFEQ(bound_in p,x,p,All(bound_in p,(
the_scope_of p).x))
proof
  consider F being Function of QC-WFF,QC-WFF such that
A1: p.x = F.p and
A2: for q holds F.VERUM = VERUM & (q is atomic implies F.q = (
  the_pred_symbol_of q)!Subst(the_arguments_of q,a.0.-->x)) & (q is negative
implies F.q = 'not' (F.the_argument_of q) ) & (q is conjunctive implies F.q = (
  F.the_left_argument_of q) '&' (F.the_right_argument_of q)) & (q is universal
  implies F.q = IFEQ(bound_in q,x,q,All(bound_in q,F.the_scope_of q))) by Def6;
  consider G being Function of QC-WFF,QC-WFF such that
A3: (the_scope_of p).x = G.(the_scope_of p) and
A4: for q holds G.VERUM = VERUM & (q is atomic implies G.q = (
  the_pred_symbol_of q)!Subst(the_arguments_of q,a.0.-->x)) & (q is negative
implies G.q = 'not' (G.the_argument_of q) ) & (q is conjunctive implies G.q = (
  G.the_left_argument_of q) '&' (G.the_right_argument_of q)) & (q is universal
  implies G.q = IFEQ(bound_in q,x,q,All(bound_in q,G.the_scope_of q))) by Def6;
  F = G by A2,A4,Lm2;
  hence thesis by A1,A2,A3;
end;

theorem Th35:
  p is universal & bound_in p = x implies p.x = p
proof
  assume p is universal;
  then (p.x) = IFEQ(bound_in p,x,p,All(bound_in p,(the_scope_of p).x)) by Lm3;
  hence thesis by FUNCOP_1:def 8;
end;

theorem Th36:
  p is universal & bound_in p <> x implies p.x = All(bound_in p,(
  the_scope_of p).x)
proof
  assume p is universal;
  then (p.x) = IFEQ(bound_in p,x,p,All(bound_in p,(the_scope_of p).x)) by Lm3;
  hence thesis by FUNCOP_1:def 8;
end;

theorem Th37:
  (All(x,p)).x = All(x,p)
proof
  set q = All(x,p);
A1: q is universal by QC_LANG1:def 20;
  then bound_in q = x by QC_LANG1:def 26;
  hence thesis by A1,Th35;
end;

theorem Th38:
  x<>y implies (All(x,p)).y = All(x,p.y)
proof
  set q = All(x,p);
A1: q is universal by QC_LANG1:def 20;
  then the_scope_of q = p & bound_in q = x by QC_LANG1:def 26,def 27;
  hence thesis by A1,Th36;
end;

theorem Th39:
  Free p = {} implies p.x = p
proof
  defpred P[Element of QC-WFF] means Free $1 = {} implies $1.x = $1;
A1: for p st P[p] holds P['not' p] by Th32,QC_LANG3:67;
A2: for p,q st P[p] & P[q] holds P[p '&' q]
  proof
    let p,q;
    assume
A3: ( Free p = {} implies p.x = p)&( Free q = {} implies q.x = q);
    assume Free(p '&' q) = {};
    then (Free p) \/ (Free q) = {} by QC_LANG3:69;
    hence thesis by A3,Th34;
  end;
A4: for k for P being (QC-pred_symbol of k),l being QC-variable_list of k
  holds P[P!l]
  proof
    let k;
    let P be (QC-pred_symbol of k),l be QC-variable_list of k;
    assume
A5: Free(P!l) = {};
A6: now
      let j be Nat;
      assume
A7:   1 <= j & j <= len l;
A8:   j in NAT by ORDINAL1:def 13;
      now
        assume l.j = a.0;
        then a.0 in { l.i : 1 <= i & i <= len l & l.i in free_QC-variables }
        by A8,A7;
        hence contradiction by A5,QC_LANG3:66;
      end;
      hence Subst(l,a.0.-->x).j = l.j by A8,A7,Th11;
    end;
    len Subst(l,a.0.-->x) = len l by Def3;
    then Subst(l,a.0.-->x) = l by A6,FINSEQ_1:18;
    hence thesis by Th30;
  end;
A9: for y,p st P[p] holds P[All(y, p)]
  proof
    let y,p;
    assume
A10: Free p = {} implies p.x = p;
A11: x = y implies All(y, p).x = All(y, p) by Th37;
    assume Free All(y,p) = {};
    hence thesis by A10,A11,Th38,QC_LANG3:70;
  end;
A12: P[VERUM] by Th28;
  for p holds P[p] from QC_LANG1:sch 1(A4,A12,A1,A2,A9);
  hence thesis;
end;

theorem
  r.x = r
proof
  Free r = {} by Th13;
  hence thesis by Th39;
end;

theorem
  Fixed(p.x) = Fixed p
proof
  defpred P[Element of QC-WFF] means Fixed($1.x) = Fixed $1;
A1: for p st P[p] holds P['not' p]
  proof
    let p such that
A2: Fixed (p.x) = Fixed p;
    thus Fixed(('not' p).x) = Fixed('not' (p.x)) by Th32
      .= Fixed p by A2,QC_LANG3:78
      .= Fixed 'not' p by QC_LANG3:78;
  end;
A3: for p,q st P[p] & P[q] holds P[p '&' q]
  proof
    let p,q such that
A4: Fixed(p.x) = Fixed(p) & Fixed(q.x) = Fixed q;
    thus Fixed((p '&' q).x) = Fixed((p.x) '&' (q.x)) by Th34
      .= Fixed(p) \/ Fixed(q) by A4,QC_LANG3:80
      .= Fixed (p '&' q) by QC_LANG3:80;
  end;
A5: for k for P being (QC-pred_symbol of k),l being QC-variable_list of k
  holds P[P!l]
  proof
    let k;
    let P be (QC-pred_symbol of k),l be QC-variable_list of k;
    set F1 = { l.i : 1 <= i & i <= len l & l.i in fixed_QC-variables };
    set ll = Subst(l,a.0.-->x);
    set F2 = { ll.i : 1 <= i & i <= len ll & ll.i in fixed_QC-variables };
A6: len l = len ll by Def3;
    now
      let y be set;
      thus y in F1 implies y in F2
      proof
        assume y in F1;
        then consider i such that
A7:     y = l.i and
A8:     1 <= i & i <= len l and
A9:     l.i in fixed_QC-variables;
        l.i <> a.0 by A9,QC_LANG3:40;
        then ll.i = l.i by A8,Th11;
        hence thesis by A6,A7,A8,A9;
      end;
      assume y in F2;
      then consider i such that
A10:  y = ll.i and
A11:  1 <= i & i <= len ll and
A12:  ll.i in fixed_QC-variables;
      now
        assume l.i = a.0;
        then ll.i = x by A6,A11,Th11;
        hence contradiction by A12,Lm1;
      end;
      then ll.i = l.i by A6,A11,Th11;
      hence y in F1 by A6,A10,A11,A12;
    end;
    then
A13: F1 = F2 by TARSKI:2;
    Fixed(P!l) = F1 & Fixed(P!ll) = F2 by QC_LANG3:77;
    hence thesis by A13,Th30;
  end;
A14: for y,p st P[p] holds P[All(y,p)]
  proof
    let y,p such that
A15: Fixed(p.x) = Fixed p;
    now
      assume x <> y;
      hence Fixed(All(y,p).x) = Fixed(All(y,p.x)) by Th38
        .= Fixed(p) by A15,QC_LANG3:81
        .= Fixed(All(y,p)) by QC_LANG3:81;
    end;
    hence thesis by Th37;
  end;
A16: P[VERUM] by Th28;
  for p holds P[p] from QC_LANG1:sch 1(A5,A16,A1,A3,A14);
  hence thesis;
end;

begin :: Addenda
:: from ALTCAT_1

reserve i,j,k for set;

theorem
  (i,j):->k = [i,j].-->k;

theorem
  ((i,j):->k).(i,j) = k by FUNCT_4:85;

:: from AMI_1, 2006.03.14, A.T.

theorem
  for a,b,c being set holds (a,a) --> (b,c) = a .--> c by FUNCT_4:86;

canceled;

:: from SCMPDS_9, 2006.03.26, A.T.

theorem
  for f being Function, a,b,c being set st a <> c holds (f +* (a .-->b))
  .c = f.c by FUNCT_4:88;

theorem
  for f being Function, a,b,c,d being set st a <> b holds (f +* ((a,b)
  -->(c,d))) .a = c & (f +* ((a,b)-->(c,d))) .b = d by FUNCT_4:89;
