:: Bubble Sort on SCM+FSA
::  by JingChao Chen and Yatsuka Nakamura
::
:: Received June 17, 1998
:: Copyright (c) 1998-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.
::SCMFSA6A,

environ

 vocabularies NUMBERS, SCMNORM, SCMFSA_2, AMI_1, SUBSET_1, SCMFSA7B, SCMFSA8C,
      SCMFSA8A, AMI_3, CARD_1, AMISTD_2, SCMFSA8B, TURING_1, FSM_1, GRAPHSP,
      FUNCT_1, PARTFUN1, COMPLEX1, FUNCT_4, ARYTM_3, SF_MASTR, SCMFSA6C,
      SCMFSA6B, FUNCOP_1, ORDINAL1, RELAT_1, TARSKI, XBOOLE_0, XXREAL_0,
      CIRCUIT2, NAT_1, STRUCT_0, ARYTM_1, INT_1, FINSEQ_1, FINSEQ_2, SCMFSA6A,
      FINSUB_1, CARD_3, CLASSES1, VALUED_0, MSUALG_1, SCM_HALT, SCMBSORT,
      PBOOLE, COMPOS_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, SETFAM_1, ORDINAL1, CARD_1,
      NUMBERS, XCMPLX_0, NAT_1, INT_1, RELAT_1, FINSEQ_1, FUNCT_1, COMPLEX1,
      FUNCT_2, PBOOLE, FUNCT_4, FINSEQ_2, FUNCT_7, STRUCT_0, MEMSTR_0,
      COMPOS_1, EXTPRO_1, AMISTD_2, SCMFSA_2, FUNCOP_1, FINSUB_1, CARD_3,
      PARTFUN1, SCMFSA6B, SCMFSA6C, SCMFSA6A, SF_MASTR, SCMFSA8A, SCMFSA8B,
      SCMFSA8C, CLASSES1, RFINSEQ, SCMFSA7B, NAT_D, SCM_HALT, XXREAL_0;
 constructors SETWISEO, XXREAL_0, REAL_1, AMI_3, SCMFSA6A, SF_MASTR, SCMFSA6B,
      SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA8C, SCM_HALT, SEQ_1, SCMFSA7B,
      AMISTD_2, NAT_D, CLASSES1, RELSET_1, DOMAIN_1, SFMASTR1, AMISTD_1,
      PBOOLE, PRE_POLY, SCMFSA_3, SCMFSA_7, SCMFSA_9, SCMFSA_2, XXREAL_2,
      MEMSTR_0;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, RELSET_1, FUNCOP_1, FINSUB_1,
      NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, RFINSEQ, SCMFSA_2,
      SF_MASTR, SCMFSA6C, SCMFSA7B, FINSET_1, SCMFSA8A, SCMFSA8B, SCMFSA_9,
      SCM_HALT, STRUCT_0, VALUED_0, ORDINAL1, RELAT_1, FUNCT_2, PBOOLE,
      SCMFSA10, AMISTD_2, SCMFSA6A, COMPOS_1, SFMASTR1, FUNCT_4, EXTPRO_1,
      SCMFSA8C, MEMSTR_0;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, FUNCOP_1, COMPOS_1, EXTPRO_1, XBOOLE_0, SCMFSA8C,
      SCM_HALT, MEMSTR_0;
 theorems SF_MASTR, FUNCT_1, FUNCT_7, FUNCOP_1, RELAT_1, FUNCT_2, ZFMISC_1,
      SCMFSA6A, FUNCT_4, FINSEQ_3, ENUMSET1, NAT_1, FINSEQ_1, RELSET_1, TARSKI,
      INT_1, PARTFUN1, GRFUNC_1, RFINSEQ, SCMFSA_2, SCMFSA7B, SCMFSA8B,
      SCMFSA8A, SCMFSA8C, SCMFSA6C, SCM_HALT, ABSVALUE, FINSEQ_4, XBOOLE_0,
      XBOOLE_1, SCMFSA9A, XREAL_1, ORDINAL1, XXREAL_0, NAT_D, CLASSES1, PBOOLE,
      AFINSQ_1, COMPOS_1, EXTPRO_1, MEMSTR_0;
 schemes RELSET_1, FUNCT_1, NAT_1;

begin :: Preliminaries

reserve p for preProgram of SCM+FSA,
  ic for Instruction of SCM+FSA,
  i,j,k for Element of NAT,
  fa,f for FinSeq-Location,
  a,b,da,db for Int-Location,
  la,lb for Element of NAT;
reserve p1,p2,q for Instruction-Sequence of SCM+FSA;

  set SA0 = Start-At(0,SCM+FSA);

theorem Th3:
  for I being Program of SCM+FSA,a,b being Int-Location st
  I does not destroy b & a<>b holds Times(a,I) does not destroy b
proof
  let I be Program of SCM+FSA,a,b be Int-Location;
  assume that
A1: I does not destroy b and
A2: a <> b;
  set Gi= Goto  2, Si= SubFrom(a,intloc 0), SS= Stop SCM+FSA,
  if0=if=0(a,Gi,I ';'Si);
A3: Gi does not destroy b by SCMFSA8C:57;
  I ';' Si does not destroy b by A1,A2,SCMFSA7B:8,SCMFSA8C:54;
  then if0 does not destroy b by A3,SCMFSA8C:88;
  then
A4: loop if0 does not destroy b by SCMFSA8C:74;
  SS does not destroy b by SCMFSA8C:56;
  hence thesis by A4,SCMFSA8C:88;
end;

theorem Th8:
  for s be State of SCM+FSA,f be FinSeq-Location,a,b be Int-Location
  holds Exec(b:=(f,a), s).b = (s.f)/.abs(s.a)
proof
  let s be State of SCM+FSA,f be FinSeq-Location,a,b be Int-Location;
  ex k be Element of NAT st ( k = abs(s.a))&( Exec(b:=(f,a), s)
  .b = (s.f)/.k) by SCMFSA_2:72;
  hence thesis;
end;

theorem Th9:
  for s be State of SCM+FSA,f be FinSeq-Location,a,b be Int-Location
  holds Exec((f,a):=b, s).f = s.f+*(abs(s.a),s.b)
proof
  let s be State of SCM+FSA,f be FinSeq-Location,a,b be Int-Location;
  ex k be Element of NAT st ( k = abs(s.a))&( Exec((f,a):=b, s)
  .f = s.f+*(k,s.b)) by SCMFSA_2:73;
  hence thesis;
end;

theorem Th10:
  for s be State of SCM+FSA,f be FinSeq-Location,m,n be Element of NAT,
  a be Int-Location
  st m<>n+1 holds Exec(intloc m:=(f,a), Initialized s).intloc (n+1)
  =s.intloc (n+1)
proof
  let s be State of SCM+FSA,f be FinSeq-Location,m,n be Element of NAT,
  a be Int-Location;
  assume m<>n+1;
  then intloc m<>intloc (n+1) by SCMFSA_2:101;
  hence Exec(intloc m:=(f,a), Initialized s).intloc (n+1)
  =(Initialized s).intloc (n+1) by SCMFSA_2:72
    .=s.intloc (n+1) by SCMFSA6C:3;
end;

theorem Th11:
  for s be State of SCM+FSA,m,n be Element of NAT,a be Int-Location
  st m<>n+1 holds Exec(intloc m:=a, Initialized s).intloc (n+1) =s.intloc (n+1)
proof
  let s be State of SCM+FSA,m,n be Element of NAT,a be Int-Location;
  assume m<>n+1;
  then intloc m<>intloc (n+1) by SCMFSA_2:101;
  hence Exec(intloc m:=a, Initialized s).intloc (n+1)
  =(Initialized s).intloc (n+1) by SCMFSA_2:63
    .=s.intloc (n+1) by SCMFSA6C:3;
end;

theorem Th12:
  for p being Instruction-Sequence of SCM+FSA
  for s be State of SCM+FSA, f be FinSeq-Location, a be read-write Int-Location
  holds IExec(Stop SCM+FSA,p,s).a =s.a &
     IExec(Stop SCM+FSA,p,s).f =s.f
proof
  let p being Instruction-Sequence of SCM+FSA;
  let s be State of SCM+FSA,f be FinSeq-Location,a be read-write Int-Location;
A1: Initialized s
      = s +* (((intloc 0) .--> 1) +* Start-At(0,SCM+FSA)) by SCMFSA6A:def 3
      .= Initialize(s +* ((intloc 0) .--> 1)) by FUNCT_4:14;
A2: IExec(Stop SCM+FSA,p,s)
    = Initialize (s +* ((intloc 0) .--> 1)) by A1,SCMFSA8C:14
    .=Initialized s by A1;
  hence IExec(Stop SCM+FSA,p,s).a =s.a by SCMFSA6C:3;
  thus thesis by A2,SCMFSA6C:3;
end;

reserve n for natural number;

theorem Th16:
  ic in rng p & (ic = a:=b or ic = AddTo(a, b) or ic = SubFrom(a, b) or
  ic = MultBy(a, b) or ic = Divide(a, b))
  implies a in UsedIntLoc p & b in UsedIntLoc p
proof
  assume that
A1: ic in rng p and
A2: ic = a:=b or ic = AddTo(a, b) or ic = SubFrom(a, b) or ic = MultBy(
  a, b) or ic = Divide(a, b);
A3: UsedIntLoc ic = {a, b} by A2,SF_MASTR:14;
  UsedIntLoc ic c= UsedIntLoc p by A1,SF_MASTR:19;
  hence thesis by A3,ZFMISC_1:32;
end;

theorem Th17:
  ic in rng p & (ic = a=0_goto la or ic = a>0_goto la)
  implies a in UsedIntLoc p
proof
  assume that
A1: ic in rng p and
A2: ic = a=0_goto la or ic = a>0_goto la;
A3: UsedIntLoc ic = {a} by A2,SF_MASTR:16;
  UsedIntLoc ic c= UsedIntLoc p by A1,SF_MASTR:19;
  hence thesis by A3,ZFMISC_1:31;
end;

theorem Th18:
  ic in rng p & ( ic = b := (fa, a) or ic = (fa, a) := b)
  implies a in UsedIntLoc p & b in UsedIntLoc p
proof
  assume that
A1: ic in rng p and
A2: ic = b := (fa, a) or ic = (fa, a) := b;
A3: UsedIntLoc ic = {a,b} by A2,SF_MASTR:17;
  UsedIntLoc ic c= UsedIntLoc p by A1,SF_MASTR:19;
  hence thesis by A3,ZFMISC_1:32;
end;

theorem Th19:
  ic in rng p & ( ic = b := (fa, a) or ic = (fa, a) := b)
  implies fa in UsedInt*Loc p
proof
  assume that
A1: ic in rng p and
A2: ic = b := (fa, a) or ic = (fa, a) := b;
A3: UsedInt*Loc ic = {fa} by A2,SF_MASTR:33;
  UsedInt*Loc ic c= UsedInt*Loc p by A1,SF_MASTR:35;
  hence thesis by A3,ZFMISC_1:31;
end;

theorem Th20:
  ic in rng p & (ic = a :=len fa or ic = fa :=<0,...,0>a)
  implies a in UsedIntLoc p
proof
  assume that
A1: ic in rng p and
A2: ic = a :=len fa or ic = fa :=<0,...,0>a;
A3: UsedIntLoc ic = {a} by A2,SF_MASTR:18;
  UsedIntLoc ic c= UsedIntLoc p by A1,SF_MASTR:19;
  hence thesis by A3,ZFMISC_1:31;
end;

theorem Th21:
  ic in rng p & (ic = a :=len fa or ic = fa :=<0,...,0>a)
  implies fa in UsedInt*Loc p
proof
  assume that
A1: ic in rng p and
A2: ic = a :=len fa or ic = fa :=<0,...,0>a;
A3: UsedInt*Loc ic = {fa} by A2,SF_MASTR:34;
  UsedInt*Loc ic c= UsedInt*Loc p by A1,SF_MASTR:35;
  hence thesis by A3,ZFMISC_1:31;
end;

theorem Th23:
  for t being FinPartState of SCM+FSA,p being Program of SCM+FSA,
  x being set st dom t c= Int-Locations \/ FinSeq-Locations &
  x in dom t \/ UsedInt*Loc p \/ UsedIntLoc p
  holds x is Int-Location or x is FinSeq-Location
proof
  let t be FinPartState of SCM+FSA,p be Program of SCM+FSA,x be set;
  set D1=UsedInt*Loc p;
  set D2=UsedIntLoc p;
  assume that
A1: dom t c= Int-Locations \/ FinSeq-Locations and
A2: x in dom t \/ D1 \/ D2;
  x in dom t \/ D1 or x in D2 by A2,XBOOLE_0:def 3;
  then
A3: x in dom t or x in D1 or x in D2 by XBOOLE_0:def 3;
  per cases by A1,A3,XBOOLE_0:def 3;
  suppose x in Int-Locations;
    hence thesis by SCMFSA_2:4;
  end;
  suppose x in FinSeq-Locations;
    hence thesis by SCMFSA_2:5;
  end;
  suppose x in D1;
    hence thesis by SCMFSA_2:5;
  end;
  suppose x in D2;
    hence thesis by SCMFSA_2:4;
  end;
end;

theorem Th25:
  for i,k being Element of NAT,t being FinPartState of SCM+FSA,
  p being Program of SCM+FSA, s1,s2 being State of SCM+FSA
  st k <= i & p c= p1 & p c= p2 & dom t c= Int-Locations \/ FinSeq-Locations &
  (for j holds IC Comput(p1,s1,j) in dom p &
  IC Comput(p2,s2,j) in dom p) &
  Comput(p1,s1,k).IC SCM+FSA = Comput(p2,s2,k).IC SCM+FSA &
  Comput(p1,s1,k) |(dom t \/ UsedInt*Loc p \/ UsedIntLoc p) =
  Comput(p2,s2,k) |(dom t \/ UsedInt*Loc p \/ UsedIntLoc p) holds
  Comput(p1,s1,i).IC SCM+FSA = Comput(p2,s2,i).IC SCM+FSA &
  Comput(p1,s1,i) |(dom t \/ UsedInt*Loc p \/ UsedIntLoc p) =
  Comput(p2,s2,i) |(dom t \/ UsedInt*Loc p \/ UsedIntLoc p)
proof
  let i,k;
  let t be FinPartState of SCM+FSA,p be Program of SCM+FSA,
  s1,s2 be State of SCM+FSA;
  set Dloc=dom t \/ UsedInt*Loc p \/ UsedIntLoc p;
  assume that
A1: k <= i and
A2: p c= p1 and
A3: p c= p2 and
A4: dom t c= Int-Locations \/ FinSeq-Locations and
A5: for j holds IC Comput(p1,s1,j) in dom p & IC Comput(
p2,s2,j) in
  dom p and
A6: Comput(p1,s1,k).IC SCM+FSA = Comput(p2,s2,k).IC
SCM+FSA and
A7: Comput(p1,s1,k) |Dloc = Comput(p2,s2,k)|Dloc;
  consider m being Nat such that
A8: i=k+m by A1,NAT_1:10;
  reconsider m as Element of NAT by ORDINAL1:def 12;
A9: i=k+m by A8;
A10: UsedIntLoc p c= Dloc by XBOOLE_1:7;
  Dloc=dom t \/ UsedIntLoc p \/ UsedInt*Loc p by XBOOLE_1:4;
  then
A11: UsedInt*Loc p c= Dloc by XBOOLE_1:7;
  defpred P[Nat] means
  Comput(p1, s1,k+$1).IC SCM+FSA = Comput(p2, s2,k+
$1).IC SCM+FSA &
  Comput(p1, s1,k+$1) |Dloc = Comput(p2, s2,k+$1)|
Dloc;
A12: P[ 0] by A6,A7;
A13: now
    let m be Element of NAT;
    assume
A14: P[m];
    set sk1= Comput(p1, s1,k+m);
    set sk11= Comput(p1, s1,k+(m+1));
    set i1=CurInstr(p1,sk1);
    set sk2= Comput(p2, s2,k+m);
    set sk12= Comput(p2, s2,k+(m+1));
    set i2=CurInstr(p2,sk2);
A15: IC sk1 in dom p by A5;
A16:  p2/.IC sk2 = p2.IC sk2 by PBOOLE:143;
A17:  p1/.IC sk1 = p1.IC sk1 by PBOOLE:143;
    i1 =p.IC sk1 by A2,A15,A17,GRFUNC_1:2;
    then
A19: i1 in rng p by A15,FUNCT_1:def 3;
A20: i2 =(p2 |dom p).IC sk2 by A16,A5,FUNCT_1:49
      .= (p1 |dom p).IC sk1 by A2,A3,A14,GRFUNC_1:33
      .=i1 by A17,A5,FUNCT_1:49;
A21: sk11= Comput(p1, s1,k+m+1)
      .=Following(p1,sk1) by EXTPRO_1:3
      .= Exec(i1,sk1);
A22: sk12= Comput(p2, s2,k+m+1)
      .=Following(p2,sk2) by EXTPRO_1:3
      .= Exec(i2,sk2);
A23: dom sk11 = the carrier of SCM+FSA by PARTFUN1:def 2
      .= dom sk12 by PARTFUN1:def 2;
    per cases by NAT_1:36,SCMFSA_2:16;
    suppose InsCode i1 = 0;
      then
A24:  i1=halt SCM+FSA by SCMFSA_2:95;
      then sk11=sk1 by A21,EXTPRO_1:def 3;
      hence P[m+1] by A14,A20,A22,A24,EXTPRO_1:def 3;
    end;
    suppose InsCode i1 = 1;
      then consider da,db such that
A25:  i1 = da:=db by SCMFSA_2:30;
A26:  sk11.IC SCM+FSA= succ IC sk1 by A21,A25,SCMFSA_2:63
        .= sk12.IC SCM+FSA by A14,A20,A22,A25,SCMFSA_2:63;
      now
        let x be set;
        assume
A27:    x in Dloc;
        per cases by A4,A27,Th23;
        suppose
A28:      x is Int-Location;
          per cases;
          suppose
A29:          x = da;
              then
A30:          sk12.x=sk2.db by A20,A22,A25,SCMFSA_2:63;
A31:          db in UsedIntLoc p by A19,A25,Th16;
              then sk1.db=(sk2 | Dloc).db by A10,A14,FUNCT_1:49
                .=sk2.db by A10,A31,FUNCT_1:49;
              hence sk11.x=sk12.x by A21,A25,A29,A30,SCMFSA_2:63;
          end;
          suppose
A32:          x<> da;
              then
A33:          sk12.x=sk2.x by A20,A22,A25,A28,SCMFSA_2:63;
              sk1.x=(sk2 | Dloc).x by A14,A27,FUNCT_1:49
                .=sk2.x by A27,FUNCT_1:49;
              hence sk11.x=sk12.x by A21,A25,A28,A32,A33,SCMFSA_2:63;
          end;
        end;
        suppose
A34:      x is FinSeq-Location;
          then
A35:      sk12.x=sk2.x by A20,A22,A25,SCMFSA_2:63;
          sk1.x=(sk2 | Dloc).x by A14,A27,FUNCT_1:49
            .=sk2.x by A27,FUNCT_1:49;
          hence sk11.x=sk12.x by A21,A25,A34,A35,SCMFSA_2:63;
        end;
      end;
      hence P[m+1] by A23,A26,FUNCT_1:96;
    end;
    suppose InsCode i1 = 2;
      then consider da,db such that
A36:  i1 = AddTo(da,db) by SCMFSA_2:31;
A37:  sk11.IC SCM+FSA= succ IC sk1 by A21,A36,SCMFSA_2:64
        .= sk12.IC SCM+FSA by A14,A20,A22,A36,SCMFSA_2:64;
      now
        let x be set;
        assume
A38:    x in Dloc;
        per cases by A4,A38,Th23;
        suppose
A39:      x is Int-Location;
          per cases;
          suppose
A40:          x = da;
              then
A41:          sk12.x=sk2.da+sk2.db by A20,A22,A36,SCMFSA_2:64;
A42:          da in UsedIntLoc p by A19,A36,Th16;
              then
A43:          sk1.da=(sk2 | Dloc).da by A10,A14,FUNCT_1:49
                .=sk2.da by A10,A42,FUNCT_1:49;
A44:          db in UsedIntLoc p by A19,A36,Th16;
              then sk1.db=(sk2 | Dloc).db by A10,A14,FUNCT_1:49
                .=sk2.db by A10,A44,FUNCT_1:49;
              hence sk11.x=sk12.x by A21,A36,A40,A41,A43,SCMFSA_2:64;
            end;
         suppose
A45:          x<> da;
              then
A46:          sk12.x=sk2.x by A20,A22,A36,A39,SCMFSA_2:64;
              sk1.x=(sk2 | Dloc).x by A14,A38,FUNCT_1:49
                .=sk2.x by A38,FUNCT_1:49;
              hence sk11.x=sk12.x by A21,A36,A39,A45,A46,SCMFSA_2:64;
            end;
        end;
        suppose
A47:      x is FinSeq-Location;
          then
A48:      sk12.x=sk2.x by A20,A22,A36,SCMFSA_2:64;
          sk1.x=(sk2 | Dloc).x by A14,A38,FUNCT_1:49
            .=sk2.x by A38,FUNCT_1:49;
          hence sk11.x=sk12.x by A21,A36,A47,A48,SCMFSA_2:64;
        end;
      end;
      hence P[m+1] by A23,A37,FUNCT_1:96;
    end;
    suppose InsCode i1 = 3;
      then consider da,db such that
A49:  i1 = SubFrom(da,db) by SCMFSA_2:32;
A50:  sk11.IC SCM+FSA= succ IC sk1 by A21,A49,SCMFSA_2:65
        .= sk12.IC SCM+FSA by A14,A20,A22,A49,SCMFSA_2:65;
      now
        let x be set;
        assume
A51:    x in Dloc;
        per cases by A4,A51,Th23;
        suppose
A52:      x is Int-Location;
          per cases;
           suppose
A53:          x = da;
              then
A54:          sk12.x=sk2.da-sk2.db by A20,A22,A49,SCMFSA_2:65;
A55:          da in UsedIntLoc p by A19,A49,Th16;
              then
A56:          sk1.da=(sk2 | Dloc).da by A10,A14,FUNCT_1:49
                .=sk2.da by A10,A55,FUNCT_1:49;
A57:          db in UsedIntLoc p by A19,A49,Th16;
              then sk1.db=(sk2 | Dloc).db by A10,A14,FUNCT_1:49
                .=sk2.db by A10,A57,FUNCT_1:49;
              hence sk11.x=sk12.x by A21,A49,A53,A54,A56,SCMFSA_2:65;
            end;
           suppose
A58:          x<> da;
              then
A59:          sk12.x=sk2.x by A20,A22,A49,A52,SCMFSA_2:65;
              sk1.x=(sk2 | Dloc).x by A14,A51,FUNCT_1:49
                .=sk2.x by A51,FUNCT_1:49;
              hence sk11.x=sk12.x by A21,A49,A52,A58,A59,SCMFSA_2:65;
            end;
        end;
        suppose
A60:      x is FinSeq-Location;
          then
A61:      sk12.x=sk2.x by A20,A22,A49,SCMFSA_2:65;
          sk1.x=(sk2 | Dloc).x by A14,A51,FUNCT_1:49
            .=sk2.x by A51,FUNCT_1:49;
          hence sk11.x=sk12.x by A21,A49,A60,A61,SCMFSA_2:65;
        end;
      end;
      hence P[m+1] by A23,A50,FUNCT_1:96;
    end;
    suppose InsCode i1 = 4;
      then consider da,db such that
A62:  i1 = MultBy(da,db) by SCMFSA_2:33;
A63:  sk11.IC SCM+FSA= succ IC sk1 by A21,A62,SCMFSA_2:66
        .= sk12.IC SCM+FSA by A14,A20,A22,A62,SCMFSA_2:66;
      now
        let x be set;
        assume
A64:    x in Dloc;
        per cases by A4,A64,Th23;
        suppose
A65:      x is Int-Location;
            per cases;
            suppose
A66:          x = da;
              then
A67:          sk12.x=sk2.da*sk2.db by A20,A22,A62,SCMFSA_2:66;
A68:          da in UsedIntLoc p by A19,A62,Th16;
              then
A69:          sk1.da=(sk2 | Dloc).da by A10,A14,FUNCT_1:49
                .=sk2.da by A10,A68,FUNCT_1:49;
A70:          db in UsedIntLoc p by A19,A62,Th16;
              then sk1.db=(sk2 | Dloc).db by A10,A14,FUNCT_1:49
                .=sk2.db by A10,A70,FUNCT_1:49;
              hence sk11.x=sk12.x by A21,A62,A66,A67,A69,SCMFSA_2:66;
            end;
            suppose
A71:          x<> da;
              then
A72:          sk12.x=sk2.x by A20,A22,A62,A65,SCMFSA_2:66;
              sk1.x=(sk2 | Dloc).x by A14,A64,FUNCT_1:49
                .=sk2.x by A64,FUNCT_1:49;
              hence sk11.x=sk12.x by A21,A62,A65,A71,A72,SCMFSA_2:66;
            end;
        end;
        suppose
A73:      x is FinSeq-Location;
          then
A74:      sk12.x=sk2.x by A20,A22,A62,SCMFSA_2:66;
          sk1.x=(sk2 | Dloc).x by A14,A64,FUNCT_1:49
            .=sk2.x by A64,FUNCT_1:49;
          hence sk11.x=sk12.x by A21,A62,A73,A74,SCMFSA_2:66;
        end;
      end;
      hence P[m+1] by A23,A63,FUNCT_1:96;
    end;
    suppose InsCode i1 = 5;
      then consider da,db such that
A75:  i1 = Divide(da,db) by SCMFSA_2:34;
A76:  sk11.IC SCM+FSA= succ IC sk1 by A21,A75,SCMFSA_2:67
        .= sk12.IC SCM+FSA by A14,A20,A22,A75,SCMFSA_2:67;
      now
        let x be set;
        assume
A77:    x in Dloc;
        per cases by A4,A77,Th23;
        suppose
A78:      x is Int-Location;
A79:      da in UsedIntLoc p by A19,A75,Th16;
          then
A80:      sk1.da=(sk2 | Dloc).da by A10,A14,FUNCT_1:49
            .=sk2.da by A10,A79,FUNCT_1:49;
A81:      db in UsedIntLoc p by A19,A75,Th16;
          then
A82:      sk1.db=(sk2 | Dloc).db by A10,A14,FUNCT_1:49
            .=sk2.db by A10,A81,FUNCT_1:49;
A83:      sk1.x=(sk2 | Dloc).x by A14,A77,FUNCT_1:49
            .=sk2.x by A77,FUNCT_1:49;
          now
            per cases;
            suppose
A84:          da <> db;
                per cases;
                suppose
A85:              x = da;
                  then sk11.x=sk1.da div sk1.db by A21,A75,A84,SCMFSA_2:67;
                  hence sk11.x=sk12.x by A20,A22,A75,A80,A82,A84,A85,
SCMFSA_2:67;
                end;
                suppose
A86:              x = db;
                  then sk11.x=sk1.da mod sk1.db by A21,A75,SCMFSA_2:67;
                  hence sk11.x=sk12.x by A20,A22,A75,A80,A82,A86,SCMFSA_2:67;
                end;
                suppose
A87:              x <> da & x <> db;
                  then sk11.x=sk1.x by A21,A75,A78,SCMFSA_2:67;
                  hence sk11.x=sk12.x by A20,A22,A75,A78,A83,A87,SCMFSA_2:67;
                end;
            end;
            suppose
A88:          da = db;
              now
                per cases;
                case
A89:              x = da;
                  then sk11.x=sk1.da mod sk1.da by A21,A75,A88,SCMFSA_2:68;
                  hence sk11.x=sk12.x by A20,A22,A75,A80,A88,A89,SCMFSA_2:68;
                end;
                case
A90:              x <> da;
                  then sk11.x=sk1.x by A21,A75,A78,A88,SCMFSA_2:68;
                  hence sk11.x=sk12.x by A20,A22,A75,A78,A83,A88,A90,
SCMFSA_2:68;
                end;
              end;
              hence sk11.x=sk12.x;
            end;
          end;
          hence sk11.x=sk12.x;
        end;
        suppose
A91:      x is FinSeq-Location;
          then
A92:      sk12.x=sk2.x by A20,A22,A75,SCMFSA_2:67;
          sk1.x=(sk2 | Dloc).x by A14,A77,FUNCT_1:49
            .=sk2.x by A77,FUNCT_1:49;
          hence sk11.x=sk12.x by A21,A75,A91,A92,SCMFSA_2:67;
        end;
      end;
      hence P[m+1] by A23,A76,FUNCT_1:96;
    end;
    suppose InsCode i1 = 6;
      then consider lb such that
A93:  i1 = goto lb by SCMFSA_2:35;
A94:  sk11.IC SCM+FSA=lb by A21,A93,SCMFSA_2:69
        .= sk12.IC SCM+FSA by A20,A22,A93,SCMFSA_2:69;
      now
        let x be set;
        assume
A95:    x in Dloc;
        then
A96:    sk1.x=(sk2 | Dloc).x by A14,FUNCT_1:49
          .=sk2.x by A95,FUNCT_1:49;
        per cases by A4,A95,Th23;
        suppose
A97:      x is Int-Location;
          then sk11.x=sk1.x by A21,A93,SCMFSA_2:69;
          hence sk11.x=sk12.x by A20,A22,A93,A96,A97,SCMFSA_2:69;
        end;
        suppose
A98:      x is FinSeq-Location;
          then sk11.x=sk1.x by A21,A93,SCMFSA_2:69;
          hence sk11.x=sk12.x by A20,A22,A93,A96,A98,SCMFSA_2:69;
        end;
      end;
      hence P[m+1] by A23,A94,FUNCT_1:96;
    end;
    suppose InsCode i1 = 7;
      then consider lb,da such that
A99:  i1 = da=0_goto lb by SCMFSA_2:36;
A100:  da in UsedIntLoc p by A19,A99,Th17;
      then
A101:  sk1.da=(sk2 | Dloc).da by A10,A14,FUNCT_1:49
        .=sk2.da by A10,A100,FUNCT_1:49;
A102: now
        per cases;
        suppose
A103:     sk1.da=0;
          hence sk11.IC SCM+FSA=lb by A21,A99,SCMFSA_2:70
            .= sk12.IC SCM+FSA by A20,A22,A99,A101,A103,SCMFSA_2:70;
        end;
        suppose
A104:     sk1.da<>0;
          hence sk11.IC SCM+FSA= succ IC sk2 by A14,A21,A99,SCMFSA_2:70
            .= sk12.IC SCM+FSA by A20,A22,A99,A101,A104,SCMFSA_2:70;
        end;
      end;
      now
        let x be set;
        assume
A105:   x in Dloc;
        then
A106:   sk1.x=(sk2 | Dloc).x by A14,FUNCT_1:49
          .=sk2.x by A105,FUNCT_1:49;
        per cases by A4,A105,Th23;
        suppose
A107:     x is Int-Location;
          then sk11.x=sk1.x by A21,A99,SCMFSA_2:70;
          hence sk11.x=sk12.x by A20,A22,A99,A106,A107,SCMFSA_2:70;
        end;
        suppose
A108:     x is FinSeq-Location;
          then sk11.x=sk1.x by A21,A99,SCMFSA_2:70;
          hence sk11.x=sk12.x by A20,A22,A99,A106,A108,SCMFSA_2:70;
        end;
      end;
      hence P[m+1] by A23,A102,FUNCT_1:96;
    end;
    suppose InsCode i1 = 8;
      then consider lb,da such that
A109: i1 = da>0_goto lb by SCMFSA_2:37;
A110: da in UsedIntLoc p by A19,A109,Th17;
      then
A111: sk1.da=(sk2 | Dloc).da by A10,A14,FUNCT_1:49
        .=sk2.da by A10,A110,FUNCT_1:49;
A112: now
        per cases;
        suppose
A113:     sk1.da > 0;
          hence sk11.IC SCM+FSA=lb by A21,A109,SCMFSA_2:71
            .= sk12.IC SCM+FSA by A20,A22,A109,A111,A113,SCMFSA_2:71;
        end;
        suppose
A114:     sk1.da <= 0;
          hence sk11.IC SCM+FSA=succ IC sk2 by A14,A21,A109,SCMFSA_2:71
            .= sk12.IC SCM+FSA by A20,A22,A109,A111,A114,SCMFSA_2:71;
        end;
      end;
      now
        let x be set;
        assume
A115:   x in Dloc;
        then
A116:   sk1.x=(sk2 | Dloc).x by A14,FUNCT_1:49
          .=sk2.x by A115,FUNCT_1:49;
        per cases by A4,A115,Th23;
        suppose
A117:     x is Int-Location;
          then sk11.x=sk1.x by A21,A109,SCMFSA_2:71;
          hence sk11.x=sk12.x by A20,A22,A109,A116,A117,SCMFSA_2:71;
        end;
        suppose
A118:     x is FinSeq-Location;
          then sk11.x=sk1.x by A21,A109,SCMFSA_2:71;
          hence sk11.x=sk12.x by A20,A22,A109,A116,A118,SCMFSA_2:71;
        end;
      end;
      hence P[m+1] by A23,A112,FUNCT_1:96;
    end;
    suppose InsCode i1 = 9;
      then consider a,b,fa such that
A119: i1 = b:=(fa,a) by SCMFSA_2:38;
A120: sk11.IC SCM+FSA= succ IC sk2 by A14,A21,A119,SCMFSA_2:72
        .= sk12.IC SCM+FSA by A20,A22,A119,SCMFSA_2:72;
      now
        let x be set;
        assume
A121:   x in Dloc;
        per cases by A4,A121,Th23;
        suppose
A122:     x is Int-Location;
          per cases;
          suppose
A123:         x = b;
A124:         ex k1 being Element of NAT st ( k1=abs(sk1.a))&( Exec(b:=(fa
              ,a), sk1).b=(sk1.fa)/.k1) by SCMFSA_2:72;
A125:         ex k2 being Element of NAT st ( k2=abs(sk2.a))&( Exec(b:=(fa
              ,a), sk2).b=(sk2.fa)/.k2) by SCMFSA_2:72;
A126:         a in UsedIntLoc p by A19,A119,Th18;
              then
A127:         sk1.a=(sk2 | Dloc).a by A10,A14,FUNCT_1:49
                .=sk2.a by A10,A126,FUNCT_1:49;
A128:         fa in UsedInt*Loc p by A19,A119,Th19;
              then sk1.fa=(sk2 | Dloc).fa by A11,A14,FUNCT_1:49
                .=sk2.fa by A11,A128,FUNCT_1:49;
              hence sk11.x=sk12.x by A20,A21,A22,A119,A123,A124,A125,A127;
            end;
           suppose
A129:         x<> b;
              then
A130:         sk12.x=sk2.x by A20,A22,A119,A122,SCMFSA_2:72;
              sk1.x=(sk2 | Dloc).x by A14,A121,FUNCT_1:49
                .=sk2.x by A121,FUNCT_1:49;
              hence sk11.x=sk12.x by A21,A119,A122,A129,A130,SCMFSA_2:72;
            end;
        end;
        suppose
A131:     x is FinSeq-Location;
          then
A132:     sk12.x=sk2.x by A20,A22,A119,SCMFSA_2:72;
          sk1.x=(sk2 | Dloc).x by A14,A121,FUNCT_1:49
            .=sk2.x by A121,FUNCT_1:49;
          hence sk11.x=sk12.x by A21,A119,A131,A132,SCMFSA_2:72;
        end;
      end;
      hence P[m+1] by A23,A120,FUNCT_1:96;
    end;
    suppose InsCode i1 = 10;
      then consider a,b,fa such that
A133: i1 = (fa,a):=b by SCMFSA_2:39;
A134: sk11.IC SCM+FSA= succ IC sk2 by A14,A21,A133,SCMFSA_2:73
        .= sk12.IC SCM+FSA by A20,A22,A133,SCMFSA_2:73;
      now
        let x be set;
        assume
A135:   x in Dloc;
        per cases by A4,A135,Th23;
        suppose
A136:     x is FinSeq-Location;
            per cases;
            suppose
A137:         x = fa;
A138:         ex k1 being Element of NAT st ( k1=abs(sk1.a))&( Exec((fa,a)
              :=b,sk1).fa=sk1.fa+*(k1,sk1.b)) by SCMFSA_2:73;
A139:         ex k2 being Element of NAT st ( k2=abs(sk2.a))&( Exec((fa,a)
              :=b,sk2).fa=sk2.fa+*(k2,sk2.b)) by SCMFSA_2:73;
A140:         a in UsedIntLoc p by A19,A133,Th18;
              then
A141:         sk1.a=(sk2 | Dloc).a by A10,A14,FUNCT_1:49
                .=sk2.a by A10,A140,FUNCT_1:49;
A142:         b in UsedIntLoc p by A19,A133,Th18;
              then
A143:         sk1.b=(sk2 | Dloc).b by A10,A14,FUNCT_1:49
                .=sk2.b by A10,A142,FUNCT_1:49;
A144:         fa in UsedInt*Loc p by A19,A133,Th19;
              then sk1.fa=(sk2 | Dloc).fa by A11,A14,FUNCT_1:49
                .=sk2.fa by A11,A144,FUNCT_1:49;
              hence sk11.x=sk12.x by A20,A21,A22,A133,A137,A138,A139,A141,A143;
            end;
            suppose
A145:         x<> fa;
              then
A146:         sk12.x=sk2.x by A20,A22,A133,A136,SCMFSA_2:73;
              sk1.x=(sk2 | Dloc).x by A14,A135,FUNCT_1:49
                .=sk2.x by A135,FUNCT_1:49;
              hence sk11.x=sk12.x by A21,A133,A136,A145,A146,SCMFSA_2:73;
            end;
        end;
        suppose
A147:     x is Int-Location;
          then
A148:     sk12.x=sk2.x by A20,A22,A133,SCMFSA_2:73;
          sk1.x=(sk2 | Dloc).x by A14,A135,FUNCT_1:49
            .=sk2.x by A135,FUNCT_1:49;
          hence sk11.x=sk12.x by A21,A133,A147,A148,SCMFSA_2:73;
        end;
      end;
      hence P[m+1] by A23,A134,FUNCT_1:96;
    end;
    suppose InsCode i1 = 11;
      then consider a,fa such that
A149: i1 = a:=len fa by SCMFSA_2:40;
A150: sk11.IC SCM+FSA= succ IC sk2 by A14,A21,A149,SCMFSA_2:74
        .= sk12.IC SCM+FSA by A20,A22,A149,SCMFSA_2:74;
      now
        let x be set;
        assume
A151:   x in Dloc;
        per cases by A4,A151,Th23;
        suppose
A152:     x is Int-Location;
            per cases;
           suppose
A153:         x = a;
              then
A154:         sk12.x= len(sk2.fa) by A20,A22,A149,SCMFSA_2:74;
A155:         fa in UsedInt*Loc p by A19,A149,Th21;
              then sk1.fa=(sk2 | Dloc).fa by A11,A14,FUNCT_1:49
                .=sk2.fa by A11,A155,FUNCT_1:49;
              hence sk11.x=sk12.x by A21,A149,A153,A154,SCMFSA_2:74;
            end;
           suppose
A156:         x<> a;
              then
A157:         sk12.x=sk2.x by A20,A22,A149,A152,SCMFSA_2:74;
              sk1.x=(sk2 | Dloc).x by A14,A151,FUNCT_1:49
                .=sk2.x by A151,FUNCT_1:49;
              hence sk11.x=sk12.x by A21,A149,A152,A156,A157,SCMFSA_2:74;
            end;
        end;
        suppose
A158:     x is FinSeq-Location;
          then
A159:     sk12.x=sk2.x by A20,A22,A149,SCMFSA_2:74;
          sk1.x=(sk2 | Dloc).x by A14,A151,FUNCT_1:49
            .=sk2.x by A151,FUNCT_1:49;
          hence sk11.x=sk12.x by A21,A149,A158,A159,SCMFSA_2:74;
        end;
      end;
      hence P[m+1] by A23,A150,FUNCT_1:96;
    end;
    suppose InsCode i1 = 12;
      then consider a,fa such that
A160: i1 = fa:=<0,...,0>a by SCMFSA_2:41;
A161: sk11.IC SCM+FSA=succ IC sk2 by A14,A21,A160,SCMFSA_2:75
        .= sk12.IC SCM+FSA by A20,A22,A160,SCMFSA_2:75;
      now
        let x be set;
        assume
A162:   x in Dloc;
        per cases by A4,A162,Th23;
        suppose
A163:     x is FinSeq-Location;
            per cases;
          suppose
A164:         x = fa;
A165:         ex k1 being Element of NAT st ( k1 = abs(sk1.a))&( Exec(fa
              :=<0,...,0>a, sk1).fa = k1 |-> 0) by SCMFSA_2:75;
A166:         ex k2 being Element of NAT st ( k2 = abs(sk2.a))&( Exec(fa
              :=<0,...,0>a, sk2).fa = k2 |-> 0) by SCMFSA_2:75;
A167:         a in UsedIntLoc p by A19,A160,Th20;
              then sk1.a=(sk2 | Dloc).a by A10,A14,FUNCT_1:49
                .=sk2.a by A10,A167,FUNCT_1:49;
              hence sk11.x=sk12.x by A20,A21,A22,A160,A164,A165,A166;
            end;
          suppose
A168:         x<> fa;
              then
A169:         sk12.x=sk2.x by A20,A22,A160,A163,SCMFSA_2:75;
              sk1.x=(sk2 | Dloc).x by A14,A162,FUNCT_1:49
                .=sk2.x by A162,FUNCT_1:49;
              hence sk11.x=sk12.x by A21,A160,A163,A168,A169,SCMFSA_2:75;
            end;
        end;
        suppose
A170:     x is Int-Location;
          then
A171:     sk12.x=sk2.x by A20,A22,A160,SCMFSA_2:75;
          sk1.x=(sk2 | Dloc).x by A14,A162,FUNCT_1:49
            .=sk2.x by A162,FUNCT_1:49;
          hence sk11.x=sk12.x by A21,A160,A170,A171,SCMFSA_2:75;
        end;
      end;
      hence P[m+1] by A23,A161,FUNCT_1:96;
    end;
  end;
  for m being Element of NAT holds P[m] from NAT_1:sch 1(A12,A13);
  hence thesis by A9;
end;

theorem Th26:
  for i,k being Element of NAT,p being Program of SCM+FSA,
  s1,s2 being State of SCM+FSA st k <= i & p c= p1 & p c= p2 &
  (for j holds IC Comput(p1,s1,j) in dom p &
  IC Comput(p2,s2,j) in dom p) &
  Comput(p1,s1,k).IC SCM+FSA = Comput(p2,s2,k).IC
SCM+FSA &
  Comput(p1,s1,k) | (UsedInt*Loc p \/ UsedIntLoc p) =
  Comput(p2,s2,k) | (UsedInt*Loc p \/ UsedIntLoc p) holds
  Comput(p1,s1,i).IC SCM+FSA = Comput(p2,s2,i).IC
SCM+FSA &
  Comput(p1,s1,i) |(UsedInt*Loc p \/ UsedIntLoc p) =
  Comput(p2,s2,i) |(UsedInt*Loc p \/ UsedIntLoc p)
proof
  let i,k be Element of NAT,p be Program of SCM+FSA,s1,s2 be State of SCM+FSA;
  set D= UsedInt*Loc p \/ UsedIntLoc p;
  assume that
A1: k <= i and
A2: p c= p1 and
A3: p c= p2 and
A4: for j holds IC Comput(p1,s1,j) in dom p & IC Comput(
p2,s2,j) in
  dom p and
A5: Comput(p1,s1,k).IC SCM+FSA = Comput(p2,s2,k).IC
SCM+FSA and
A6: Comput(p1,s1,k) | D = Comput(p2,s2,k) | D;
  reconsider t={} as PartState of SCM+FSA by FUNCT_1:104,RELAT_1:171;
  set D1= dom t \/ UsedInt*Loc p \/ UsedIntLoc p;
A7: dom t c= Int-Locations \/ FinSeq-Locations by RELAT_1:38,XBOOLE_1:2;
A8: D1 = D by RELAT_1:38;
  hence Comput(p1,s1,i).IC SCM+FSA = Comput(p2,s2,i).
IC SCM+FSA
  by A1,A2,A3,A4,A5,A6,A7,Th25;
  thus thesis by A1,A2,A3,A4,A5,A6,A7,A8,Th25;
end;



theorem Th29:
  for I,J being Program of SCM+FSA, a being Int-Location holds
  UsedIntLoc if=0(a,I,J) = {a} \/ UsedIntLoc I \/ UsedIntLoc J &
  UsedIntLoc if>0(a,I,J) = {a} \/ UsedIntLoc I \/ UsedIntLoc J
proof
  let I,J be Program of SCM+FSA, a be Int-Location;
  set g1= a=0_goto  (card J + 3), g2= Goto  (card I + 1),
  g3= a>0_goto  (card J + 3), SS=Stop SCM+FSA;
  thus UsedIntLoc if=0(a,I,J) =UsedIntLoc (g1 ';' J ';' g2 ';'I ';' SS)
  by SCMFSA8B:def 1
    .=UsedIntLoc (g1 ';' J ';' g2 ';'I) \/ {} by SCMFSA9A:3,SF_MASTR:27
    .=UsedIntLoc (g1 ';' J ';' g2) \/ UsedIntLoc I by SF_MASTR:27
    .=UsedIntLoc (g1 ';' J) \/ UsedIntLoc g2 \/ UsedIntLoc I by SF_MASTR:27
    .=UsedIntLoc (g1 ';' J) \/ {} \/ UsedIntLoc I by SCMFSA9A:5
    .=UsedIntLoc g1 \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:29
    .={a} \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:16
    .={a} \/ UsedIntLoc I \/ UsedIntLoc J by XBOOLE_1:4;
  thus UsedIntLoc if>0(a,I,J) =UsedIntLoc (g3 ';' J ';' g2 ';'I ';' SS)
  by SCMFSA8B:def 2
    .=UsedIntLoc (g3 ';' J ';' g2 ';'I) \/ {} by SCMFSA9A:3,SF_MASTR:27
    .=UsedIntLoc (g3 ';' J ';' g2) \/ UsedIntLoc I by SF_MASTR:27
    .=UsedIntLoc (g3 ';' J) \/ UsedIntLoc g2 \/ UsedIntLoc I by SF_MASTR:27
    .=UsedIntLoc (g3 ';' J) \/ {} \/ UsedIntLoc I by SCMFSA9A:5
    .=UsedIntLoc g3 \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:29
    .={a} \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:16
    .={a} \/ UsedIntLoc I \/ UsedIntLoc J by XBOOLE_1:4;
end;

theorem Th30:
  for I be Program of SCM+FSA,l be Element of NAT holds
  UsedIntLoc (Directed(I,l)) = UsedIntLoc I
proof
  let I be Program of SCM+FSA,l be Element of NAT;
  consider UIL being Function of the Instructions of SCM+FSA,
  Fin Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc I = Union (UIL * I) by SF_MASTR:def 2;
  consider UIL2 being Function of the Instructions of SCM+FSA,
  Fin Int-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A4: UsedIntLoc Directed(I,l) = Union (UIL2 * Directed(I,l))
  by SF_MASTR:def 2;
A5: for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL2.c by A3;
  end;
A6: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
A7: UIL.halt SCM+FSA = {} by A1,SF_MASTR:13;
A8: UIL.goto l = UsedIntLoc goto l by A1
    .= {} by SF_MASTR:15;
A9:  rng I c= the Instructions of SCM+FSA by RELAT_1:def 19;
  UIL * Directed(I,l)
    = UIL * (I +~ (halt SCM+FSA,goto l)) by SCMFSA6A:def 1
   .= UIL * (((id the Instructions of SCM+FSA) +*
       (halt SCM+FSA,goto l))*I) by A9,FUNCT_7:116
   .= UIL * ((id the Instructions of SCM+FSA) +*
  (halt SCM+FSA, goto l)) * I by RELAT_1:36
    .= UIL * I by A6,A7,A8,FUNCT_7:108;
  hence thesis by A2,A4,A5,FUNCT_2:63;
end;

theorem Th31:
  for a being Int-Location,I being Program of SCM+FSA holds
  UsedIntLoc Times(a,I) = UsedIntLoc I \/ {a,intloc 0}
proof
  let a be Int-Location,I be Program of SCM+FSA;
  set g1=Goto  2, SF=SubFrom(a,intloc 0), if0=if=0(a,g1,I ';' SF);
  thus
  UsedIntLoc Times(a,I) ={a} \/ UsedIntLoc loop if0 \/ {} by Th29,SCMFSA9A:3
    .={a} \/ UsedIntLoc if0 by Th30
    .={a} \/ ({a} \/ UsedIntLoc g1 \/ UsedIntLoc (I ';' SF)) by Th29
    .={a} \/ ({a} \/ {} \/ UsedIntLoc (I ';' SF)) by SCMFSA9A:5
    .={a} \/ {a} \/ UsedIntLoc (I ';' SF) by XBOOLE_1:4
    .=UsedIntLoc I \/ UsedIntLoc SF \/ {a} by SF_MASTR:30
    .=UsedIntLoc I \/ {a,intloc 0} \/ {a} by SF_MASTR:14
    .=UsedIntLoc I \/ ({a} \/ {a,intloc 0}) by XBOOLE_1:4
    .=UsedIntLoc I \/ {a,a,intloc 0} by ENUMSET1:2
    .=UsedIntLoc I \/ {a,intloc 0} by ENUMSET1:30;
end;



theorem Th36:
  for I be Program of SCM+FSA,l be Element of NAT holds
  UsedInt*Loc (Directed(I,l)) = UsedInt*Loc I
proof
  let I be Program of SCM+FSA,l be Element of NAT;
  consider UIL being Function of the Instructions of SCM+FSA,
  Fin FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc I = Union (UIL * I) by SF_MASTR:def 4;
  consider UIL2 being Function of the Instructions of SCM+FSA,
  Fin FinSeq-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A4: UsedInt*Loc Directed(I,l) = Union (UIL2 * Directed(I,l))
  by SF_MASTR:def 4;
A5: for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL2.c by A3;
  end;
A6: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
A7: UIL.halt SCM+FSA = UsedInt*Loc halt SCM+FSA by A1
    .= {} by SF_MASTR:32;
A8: UIL.goto l = UsedInt*Loc goto l by A1
    .= {} by SF_MASTR:32;
A9: rng I c= the Instructions of SCM+FSA by RELAT_1:def 19;
  UIL * Directed(I,l)
    = UIL * (I +~ (halt SCM+FSA,goto l)) by SCMFSA6A:def 1
   .= UIL * (((id the Instructions of SCM+FSA) +*
  (halt SCM+FSA,goto l))*I) by A9,FUNCT_7:116
    .= UIL * ((id the Instructions of SCM+FSA) +*
  (halt SCM+FSA,goto l)) * I by RELAT_1:36
    .= UIL * I by A6,A7,A8,FUNCT_7:108;
  hence thesis by A2,A4,A5,FUNCT_2:63;
end;

theorem Th37:
  for a being Int-Location,I being Program of SCM+FSA holds
  UsedInt*Loc Times(a,I) = UsedInt*Loc I
proof
  let a be Int-Location,I be Program of SCM+FSA;
  set g1=Goto  2, SF=SubFrom(a,intloc 0), if0=if=0(a,g1,I ';' SF);
  thus
  UsedInt*Loc Times(a,I) =UsedInt*Loc loop if0 \/ {} by SCMFSA9A:4,10
    .=UsedInt*Loc if0 by Th36
    .=UsedInt*Loc g1 \/ UsedInt*Loc (I ';' SF) by SCMFSA9A:8
    .={} \/ UsedInt*Loc (I ';' SF) by SCMFSA9A:6
    .=UsedInt*Loc I \/ UsedInt*Loc SF by SF_MASTR:46
    .=UsedInt*Loc I \/ {} by SF_MASTR:32
    .=UsedInt*Loc I;
end;

definition
  let f be FinSeq-Location,t be FinSequence of INT;
  redefine func f .--> t -> FinPartState of SCM+FSA;
  coherence
  proof
A1: t is Element of INT* by FINSEQ_1:def 11;
    ObjectKind f = INT* by SCMFSA_2:12;
    hence thesis by A1;
  end;
end;



theorem Th42:
  for w being FinSequence of INT,f be FinSeq-Location,I be Program of SCM+FSA
  holds dom (Initialized (f.--> w)) = {intloc 0,IC SCM+FSA,f}
proof
  let w be FinSequence of INT,f be FinSeq-Location, I be Program of SCM+FSA;
 Initialized(f .--> w) =  (f .--> w) +* Initialize ((intloc 0) .--> 1)
           by SCMFSA6A:def 3;
  then dom (Initialized(f .--> w)) =
  dom(Initialize ((intloc 0) .--> 1)) \/ dom (f.--> w) by FUNCT_4:def 1
    .=dom(Initialize ((intloc 0) .--> 1)) \/ {f} by FUNCOP_1:13
    .= { intloc 0,IC SCM+FSA } \/ {f} by SCMFSA6A:42
    .= ({ intloc 0,IC SCM+FSA } \/ {f});
  hence thesis by ENUMSET1:3;
end;



theorem Th44:
  for a being Int-Location,I being Program of SCM+FSA holds
  card Times(a,I) = card I + 12
proof
  let a be Int-Location,I be Program of SCM+FSA;
  set g1=Goto  2, SF=SubFrom(a,intloc 0), if0=if=0(a,g1,I ';' SF);
   card Stop SCM+FSA = 1 by COMPOS_1:4;
  hence card Times(a,I)= card (loop if0)+1+4 by SCMFSA8B:12
    .= card (loop if0)+(1+4)
    .= card if0 +5 by SCMFSA8A:19
    .= card (I ';' SF)+card g1+4+5 by SCMFSA8B:11
    .= card (I ';' SF)+1+4+5 by SCMFSA8A:15
    .= card I+2+1+4+5 by SCMFSA6A:34
    .= card I+12;
end;

theorem Th45:
  for i1,i2,i3 be Instruction of SCM+FSA holds card (i1 ';' i2 ';' i3)=6
proof
  let i1,i2,i3 be Instruction of SCM+FSA;
  thus card (i1 ';' i2 ';' i3) = card (i1 ';' i2) + 2 by SCMFSA6A:34
    .= 4 +2 by SCMFSA6A:35
    .= 6;
end;

theorem Th46:
  for t be FinSequence of INT,f be FinSeq-Location
  holds dom Initialize((intloc 0) .--> 1) misses dom (f .--> t)
proof
  let t be FinSequence of INT,f be FinSeq-Location;
  set x = f .--> t;
A1: dom x ={f} by FUNCOP_1:13;
  set DI=dom Initialize((intloc 0) .--> 1);
  assume DI /\ dom x <> {};
  then consider y being set such that
A3: y in DI /\ dom x by XBOOLE_0:def 1;
A4: y in DI by A3,XBOOLE_0:def 4;
  y in dom x by A3,XBOOLE_0:def 4;
  then
A5: y=f by A1,TARSKI:def 1;
  y in {intloc 0,IC SCM+FSA } by A4,SCMFSA6A:42;
  then y=intloc 0 or y=IC SCM+FSA by TARSKI:def 2;
  hence contradiction by A5,SCMFSA_2:57,58;
end;

theorem
  for w be FinSequence of INT,f be FinSeq-Location,I be Program of SCM+FSA
  holds Initialize((intloc 0) .--> 1) +* (f .--> w) is 0-started;

theorem Th48:
  for I,J being Program of SCM+FSA, k being Element of NAT,
  i being Instruction of SCM+FSA st k< card J & i = J. k holds
  (I ';' J).( (card I +k)) =IncAddr( i, card I )
proof
  let I,J be Program of SCM+FSA, k be Element of NAT,
  i be Instruction of SCM+FSA such that
A1: k< card J and
A2: i = J. k;
  set m=card I +k;
A3: m < card I + card J by A1,XREAL_1:6;
  (m -' card I) = k by NAT_D:34;
  hence thesis by A2,A3,NAT_1:11,SCMFSA8C:2;
end;



theorem Th50:
  for I,J be Program of SCM+FSA,k be Element of NAT,
  i be Instruction of SCM+FSA st
  (for n be Element of NAT holds IncAddr( i, n)=i) & i <> halt SCM+FSA &
  k= card I holds (I ';' i ';' J).( k) = i &
  (I ';' i ';' J).( (k+1)) = goto  (card I+2)
proof
  let I,J be Program of SCM+FSA, k be Element of NAT,
  i be Instruction of SCM+FSA;
  assume that
A1: for n be Element of NAT holds IncAddr( i, n)=i and
A2: i <> halt SCM+FSA and
A3: k= card I;
  set x1= k;
A4: card (I ';' i) = card I +2 by SCMFSA6A:34;
  card I + 0 < card I + 2 by XREAL_1:6;
  then
A5: x1 in dom (I ';' i) by A3,A4,AFINSQ_1:66;
A6: (Macro i).( 0) = i by COMPOS_1:58;
A7: card (Macro i) = 2 by COMPOS_1:56;
A8: (I ';' i).x1 = (I ';' Macro i). (card I+0) by A3,SCMFSA6A:def 6
    .=IncAddr( i, card I ) by A6,A7,Th48
    .=i by A1;
  thus (I ';' i ';' J).x1 = (Directed (I ';' i)).x1 by A5,SCMFSA8A:14
    .=i by A2,A5,A8,SCMFSA8A:16;
  set x2= (k+1);
  card I + 1 < card I + 2 by XREAL_1:6;
  then
A9: x2 in dom (I ';' i) by A3,A4,AFINSQ_1:66;
  (Macro i).1 = halt SCM+FSA by COMPOS_1:59;
  then (I ';' Macro i).x2 =IncAddr( halt SCM+FSA, card I ) by A3,A7,Th48;
  then
A10: (I ';' i).x2 =IncAddr( halt SCM+FSA, card I ) by SCMFSA6A:def 6
    .=halt SCM+FSA by COMPOS_1:11;
  thus (I ';' i ';' J).x2 = (Directed (I ';' i)).x2 by A9,SCMFSA8A:14
    .= goto  (card I+2) by A4,A9,A10,SCMFSA8A:16;
end;

theorem Th51:
  for I,J being Program of SCM+FSA, k being Element of NAT holds
  k= card I implies (I ';'(a:=b) ';' J).( k) = a:= b
  & (I ';'(a:=b) ';' J).( (k+1)) = goto  (card I+2)
proof
  let I,J be Program of SCM+FSA,k be Element of NAT;
  assume
A1: k= card I;
  set i=a:=b;
    for n be Element of NAT holds IncAddr(i, n)=i by COMPOS_1:11;
  hence thesis by A1,Th50;
end;

theorem Th52:
  for I,J being Program of SCM+FSA, k being Element of NAT holds
  k= card I implies (I ';'(a:=len f) ';' J).( k) = a:=len f
  & (I ';'(a:=len f) ';' J).( (k+1)) = goto  (card I+2)
proof
  let I,J be Program of SCM+FSA,k be Element of NAT;
  assume
A1: k= card I;
  set i=a:=len f;
    for n be Element of NAT holds IncAddr(i, n)=i by COMPOS_1:11;
  hence thesis by A1,Th50;
end;



theorem Th54:
  for w being FinSequence of INT,f be FinSeq-Location,s be State of SCM+FSA,
  I be Program of SCM+FSA st  Initialized(f .--> w) c= s
  holds s.f = w & s.(intloc 0) = 1
proof
  let w be FinSequence of INT,f be FinSeq-Location,
  s be State of SCM+FSA,I be Program of SCM+FSA;
  set t= f.--> w, p=Initialized t;
B0: p = t +* Initialize ((intloc 0) .--> 1) by SCMFSA6A:def 3;
  assume
A1:  p c= s;
   reconsider pt = p  as PartState of SCM+FSA;
  dom t = { f} by FUNCOP_1:13;
  then
 f in dom t by TARSKI:def 1;
  then
C3: f in dom pt by B0,FUNCT_4:12;
B3: f in dom  pt by C3;
    intloc 0 in dom p by SCMFSA6A:10;
  then
B5: intloc 0 in dom  pt;
  ex i being Element of NAT st f = fsloc i by SCMFSA_2:9;
    then f <> intloc 0 by SCMFSA_2:99;
    then not f in {intloc 0} by TARSKI:def 1;
    then
Y1: not f in dom((intloc 0) .--> 1) by FUNCOP_1:13;
Y2: dom Initialize((intloc 0) .--> 1)
     = dom ((intloc 0) .--> 1) \/ dom Start-At(0,SCM+FSA) by FUNCT_4:def 1;
    not f in dom Start-At(0,SCM+FSA) by SCMFSA_2:103;
    then
YY: not f in dom Initialize ((intloc 0) .--> 1) by Y1,Y2,XBOOLE_0:def 3;
  thus s.f = ( pt).f by A1,B3,GRFUNC_1:2
    .= pt.f
    .= t.f by B0,YY,FUNCT_4:11
    .= w by FUNCOP_1:72;
  thus s.intloc 0 = ( pt).intloc 0 by A1,B5,GRFUNC_1:2
    .=pt.intloc 0
    .=p.intloc 0
    .= (Initialize ((intloc 0) .--> 1)).intloc 0 by B0,FUNCT_4:13,SCMFSA6A:41
    .= 1 by SCMFSA6A:43;
end;

theorem Th55:
  for f being FinSeq-Location,a being Int-Location,s being State of SCM+FSA
  holds {a,IC SCM+FSA,f} c= dom s
proof
  let f be FinSeq-Location,a be Int-Location,s be State of SCM+FSA;
A1: a in dom s by SCMFSA_2:42;
  IC SCM+FSA in dom s by MEMSTR_0:2;
  then
A2: {a,IC SCM+FSA} c= dom s by A1,ZFMISC_1:32;
  f in dom s by SCMFSA_2:43;
  then { f } c= dom s by ZFMISC_1:31;
  then {a,IC SCM+FSA} \/ {f} c= dom s by A2,XBOOLE_1:8;
  hence thesis by ENUMSET1:3;
end;

theorem Th56:
  for p being Program of SCM+FSA,s being State of SCM+FSA holds
  UsedInt*Loc p \/ UsedIntLoc p c= dom s
proof
  let p be Program of SCM+FSA,s be State of SCM+FSA;
  Int-Locations c= dom(s) by SCMFSA_2:45;
  then
A1: UsedIntLoc p c= dom(s) by XBOOLE_1:1;
  FinSeq-Locations c= dom (s) by SCMFSA_2:46;
  then UsedInt*Loc p c= dom(s) by XBOOLE_1:1;
  hence thesis by A1,XBOOLE_1:8;
end;

theorem Th57:
  for p being Instruction-Sequence of SCM+FSA
  for s be State of SCM+FSA,I be Program of SCM+FSA,f be FinSeq-Location
  holds Result(p +* I,Initialized s).f = IExec(I,p,s).f
proof
  let p be Instruction-Sequence of SCM+FSA;
  let s be State of SCM+FSA,I be Program of SCM+FSA,f be FinSeq-Location;
  set D= Int-Locations \/ FinSeq-Locations;
  f in FinSeq-Locations by SCMFSA_2:3;
  then
A1: f in D by XBOOLE_0:def 3;
  hence Result(p +* I,Initialized s).f
     = (DataPart Result(p +* I,Initialized s)).f
       by FUNCT_1:49,SCMFSA_2:100
    .=(DataPart IExec(I,p,s)).f by SCMFSA8B:32
    .= IExec(I,p,s).f by A1,FUNCT_1:49,SCMFSA_2:100;
end;

:: ------   Bubble Sort Algorithm -----------------
set a0 = intloc 0;
set a1 = intloc 1;
set a2 = intloc 2;
set a3 = intloc 3;
set a4 = intloc 4;
set a5 = intloc 5;
set a6 = intloc 6;
Lm1: a0 <> a2 by SCMFSA_2:101;
Lm2: a0 <> a4 by SCMFSA_2:101;
Lm3: a0 <> a5 by SCMFSA_2:101;
Lm4: a0 <> a6 by SCMFSA_2:101;
Lm5: a1 <> a2 by SCMFSA_2:101;
Lm6: a1 <> a3 by SCMFSA_2:101;
Lm7: a1 <> a4 by SCMFSA_2:101;
Lm8: a1 <> a5 by SCMFSA_2:101;
Lm9: a1 <> a6 by SCMFSA_2:101;
Lm10: a2 <> a3 by SCMFSA_2:101;
Lm11: a2 <> a4 by SCMFSA_2:101;
Lm12: a2 <> a5 by SCMFSA_2:101;
Lm13: a2 <> a6 by SCMFSA_2:101;
Lm14: a3 <> a4 by SCMFSA_2:101;
Lm15: a3 <> a5 by SCMFSA_2:101;
Lm16: a3 <> a6 by SCMFSA_2:101;
Lm17: a4 <> a5 by SCMFSA_2:101;
Lm18: a4 <> a6 by SCMFSA_2:101;
Lm19: a5 <> a6 by SCMFSA_2:101;
set initializeWorkMem= (a2:= a0) ';' (a3:= a0) ';'
(a4:= a0) ';' (a5:= a0) ';' (a6:= a0);

:: set a0 = intloc 0;
:: set a1 = intloc 1;
:: set a2 = intloc 2;
:: set a3 = intloc 3;
:: set a4 = intloc 4;
:: set a5 = intloc 5;
:: set a6 = intloc 6;
:: set initializeWorkMem= (a2:= a0) ';' (a3:= a0) ';'
::                  (a4:= a0) ';' (a5:= a0) ';' (a6:= a0);

definition
  let f be FinSeq-Location;
  func bubble-sort f -> Program of SCM+FSA equals
  ( ((intloc 2):= (intloc 0)) ';' ((intloc 3):= (intloc 0)) ';'
  ((intloc 4):= (intloc 0)) ';' ((intloc 5):= (intloc 0)) ';'
  ((intloc 6):= (intloc 0)) ) ';' ((intloc 1):=len f) ';' Times((intloc 1),
  (intloc 2) := (intloc 1) ';' SubFrom(intloc 2,intloc 0) ';'
  ((intloc 3):=len f) ';' Times(intloc 2, (intloc 4):=(intloc 3) ';'
  SubFrom(intloc 3,intloc 0) ';' ((intloc 5):=(f,intloc 3)) ';'
  ((intloc 6):=(f,(intloc 4))) ';' SubFrom(intloc 6,intloc 5) ';'
  if>0(intloc 6,((intloc 6):=(f,intloc 4)) ';' ((f,intloc 3):=(intloc 6)) ';'
  ((f,intloc 4):=(intloc 5)),Stop SCM+FSA) ) );
  correctness;
end;

definition
  func Bubble-Sort-Algorithm -> Program of SCM+FSA equals
  bubble-sort fsloc 0;
  coherence;
end;

set b1=intloc (0+1),b2=intloc (1+1),b3=intloc (2+1),b4=intloc (3+1),
b5=intloc (4+1),b6=intloc (5+1);
set f0=fsloc 0, i1= b4:=b3, i2= SubFrom(b3,a0), i3= b5:=(f0,b3),
i4= b6:=(f0,b4), i5= SubFrom(b6,b5), i6= (f0,b3):=b6, i7= (f0,b4):=b5,
 SS= Stop SCM+FSA,
 ifc=if>0(b6,i4 ';' i6 ';' i7,SS),
 body2= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' ifc,
 T2=Times(b2,body2),
 j1= b2 := b1,
 j2= SubFrom(b2,a0), j3= b3:=len f0, Sb= j1 ';' j2 ';' j3,
 body1= Sb ';' T2,
 T1=Times(b1,body1), w2= b2:= a0, w3= b3:= a0, w4= b4:= a0,
 w5= b5:= a0, w6= b6:= a0, w7= b1:=len f0;

theorem Th58:
  for f being FinSeq-Location holds
  UsedIntLoc (bubble-sort f) = {intloc 0,intloc 1,intloc 2,intloc 3, intloc 4,
  intloc 5,intloc 6}
proof
  let f be FinSeq-Location;
  set i1= a4:=a3, i2= SubFrom(a3,a0), i3= (a5:=(f,a3)), i4= (a6:=(f,a4)),
  i5= SubFrom(a6,a5), i6= ((f,a3):=a6), i7= ((f,a4):=a5),
  ifc=if>0(a6,i4 ';' i6 ';' i7,Stop SCM+FSA), Sif= UsedIntLoc ifc,
  body2= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' ifc;
A1: Sif = {a6} \/ UsedIntLoc (i4 ';' i6 ';' i7) \/ {} by Th29,SCMFSA9A:3
    .= {a6} \/ (UsedIntLoc (i4 ';' i6) \/ UsedIntLoc i7) by SF_MASTR:30
    .= {a6} \/ (UsedIntLoc (i4 ';' i6) \/ {a4,a5}) by SF_MASTR:17
    .= {a6} \/ (UsedIntLoc i4 \/ UsedIntLoc i6 \/ {a4,a5}) by SF_MASTR:31
    .= {a6} \/ (UsedIntLoc i4 \/ {a3,a6} \/ {a4,a5}) by SF_MASTR:17
    .= {a6} \/ ({a4,a6} \/ {a3,a6} \/ {a4,a5}) by SF_MASTR:17
    .= {a6} \/ ({a4,a6,a3,a6} \/ {a4,a5}) by ENUMSET1:5
    .= {a6} \/ ({a6,a6,a3,a4} \/ {a4,a5}) by ENUMSET1:75
    .= {a6} \/ {a6,a6,a3,a4} \/ {a4,a5} by XBOOLE_1:4
    .= {a6,a6,a6,a3,a4} \/ {a4,a5} by ENUMSET1:7
    .= {a6,a3,a4} \/ {a4,a5} by ENUMSET1:38
    .= {a6,a3} \/ {a4} \/ {a4,a5} by ENUMSET1:3
    .= {a6,a3} \/ ({a4} \/ {a4,a5}) by XBOOLE_1:4
    .= {a6,a3} \/ {a4,a4,a5} by ENUMSET1:2
    .= {a4,a5} \/ {a6,a3} by ENUMSET1:30
    .= {a4,a5,a6,a3} by ENUMSET1:5
    .= {a4,a3,a6,a5} by ENUMSET1:64;
  set ui12=UsedIntLoc(i1 ';' i2);
A2: UsedIntLoc body2 = (UsedIntLoc (i1 ';' i2 ';'i3 ';'i4 ';' i5) )
  \/ Sif by SF_MASTR:27
    .= (UsedIntLoc (i1 ';' i2 ';'i3 ';' i4)) \/ (UsedIntLoc i5) \/ Sif
  by SF_MASTR:30
    .= (UsedIntLoc (i1 ';' i2 ';'i3 ';' i4)) \/ {a6,a5} \/ Sif
  by SF_MASTR:14
    .= (UsedIntLoc (i1 ';' i2 ';'i3 )) \/ (UsedIntLoc i4) \/ {a6,a5} \/ Sif
  by SF_MASTR:30
    .= (UsedIntLoc (i1 ';' i2 ';'i3)) \/ {a6,a4} \/ {a6,a5} \/ Sif
  by SF_MASTR:17
    .= ui12 \/ UsedIntLoc i3 \/ {a6,a4} \/ {a6,a5} \/ Sif by SF_MASTR:30
    .= ui12 \/ {a5,a3} \/ {a6,a4} \/ {a6,a5} \/ Sif by SF_MASTR:17
    .= ui12 \/ ({a5,a3} \/ {a6,a4}) \/ {a6,a5} \/ Sif by XBOOLE_1:4
    .= ui12 \/ {a5,a3,a6,a4} \/ {a6,a5} \/ Sif by ENUMSET1:5
    .= ui12 \/ {a4,a3,a6,a5} \/ {a6,a5} \/ Sif by ENUMSET1:75
    .= ui12 \/ ({a4,a3} \/ {a6,a5}) \/ {a6,a5} \/ Sif by ENUMSET1:5
    .= ui12 \/ {a4,a3} \/ {a6,a5} \/ {a6,a5} \/ Sif by XBOOLE_1:4
    .= ui12 \/ {a4,a3} \/ ({a6,a5} \/ {a6,a5}) \/ Sif by XBOOLE_1:4
    .= ui12 \/ ({a4,a3} \/ {a6,a5}) \/ Sif by XBOOLE_1:4
    .= ui12 \/ {a4,a3,a6,a5} \/ Sif by ENUMSET1:5
    .= ui12 \/ ({a4,a3,a6,a5} \/ Sif) by XBOOLE_1:4
    .= (UsedIntLoc i1 ) \/ (UsedIntLoc i2) \/ {a4,a3,a6,a5} by A1,SF_MASTR:31
    .= (UsedIntLoc i1 ) \/ {a3,a0} \/ {a4,a3,a6,a5} by SF_MASTR:14
    .= {a3,a4} \/ {a3,a0} \/ {a4,a3,a6,a5} by SF_MASTR:14
    .= {a3,a4,a3,a0} \/ {a4,a3,a6,a5} by ENUMSET1:5
    .= {a3,a3,a4,a0} \/ {a4,a3,a6,a5} by ENUMSET1:62
    .= {a3,a4,a0} \/ {a4,a3,a6,a5} by ENUMSET1:31
    .= {a0,a4,a3} \/ {a4,a3,a6,a5} by ENUMSET1:60
    .= {a0} \/ {a4,a3} \/ {a4,a3,a6,a5} by ENUMSET1:2
    .= {a0} \/ {a4,a3} \/ ({a4,a3} \/ {a6,a5}) by ENUMSET1:5
    .= {a0} \/ {a4,a3} \/ {a4,a3} \/ {a6,a5} by XBOOLE_1:4
    .= {a0} \/ ({a4,a3} \/ {a4,a3}) \/ {a6,a5} by XBOOLE_1:4
    .= {a0} \/ ({a4,a3} \/ {a6,a5}) by XBOOLE_1:4
    .= {a0} \/ {a4,a3,a6,a5} by ENUMSET1:5;
  set j1= a2 := a1, j2= SubFrom(a2,a0), j3= (a3:=len f),
  Sfor= UsedIntLoc Times(a2,body2),
  body1= j1 ';' j2 ';' j3 ';' Times(a2,body2);
A3: Sfor={a4,a3,a6,a5} \/ {a0} \/ {a2,a0} by A2,Th31
    .={a4,a3,a6,a5} \/ ({a0} \/ {a2,a0}) by XBOOLE_1:4
    .={a4,a3,a6,a5} \/ {a0,a0,a2} by ENUMSET1:2
    .={a4,a3,a6,a5} \/ {a0,a2} by ENUMSET1:30
    .={a4,a5,a6,a3} \/ {a0,a2} by ENUMSET1:64
    .={a4,a5,a6} \/ {a3} \/ {a0,a2} by ENUMSET1:6
    .={a4,a5,a6} \/ ({a3} \/ {a0,a2}) by XBOOLE_1:4
    .={a4,a5,a6} \/ {a0,a2,a3} by ENUMSET1:3;
  A4: UsedIntLoc body1 = UsedIntLoc (j1 ';' j2 ';'j3) \/ Sfor by SF_MASTR:27
    .= UsedIntLoc (j1 ';' j2) \/ UsedIntLoc j3 \/ Sfor by SF_MASTR:30
    .= UsedIntLoc (j1 ';' j2) \/ {a3} \/ Sfor by SF_MASTR:18
    .= UsedIntLoc j1 \/ UsedIntLoc j2 \/ {a3} \/ Sfor by SF_MASTR:31
    .= UsedIntLoc j1 \/ {a2,a0} \/ {a3} \/ Sfor by SF_MASTR:14
    .= {a2,a1} \/ {a2,a0} \/ {a3} \/ Sfor by SF_MASTR:14
    .= {a2,a1} \/ ({a0,a2} \/ {a3}) \/ Sfor by XBOOLE_1:4
    .= {a2,a1} \/ {a0,a2,a3} \/ Sfor by ENUMSET1:3
    .= {a2,a1} \/ {a0,a2,a3} \/ {a0,a2,a3} \/ {a4,a5,a6} by A3,XBOOLE_1:4
    .= {a2,a1} \/ ({a0,a2,a3} \/ {a0,a2,a3}) \/ {a4,a5,a6} by XBOOLE_1:4
    .= {a2,a1} \/ ({a0,a2} \/ {a3}) \/ {a4,a5,a6} by ENUMSET1:3
    .= {a2,a1} \/ {a0,a2} \/ {a3} \/ {a4,a5,a6} by XBOOLE_1:4
    .= {a2,a1,a0,a2} \/ {a3} \/ {a4,a5,a6} by ENUMSET1:5
    .= {a2,a2,a0,a1} \/ {a3} \/ {a4,a5,a6} by ENUMSET1:64
    .= {a2,a0,a1} \/ {a3} \/ {a4,a5,a6} by ENUMSET1:31
    .= {a0,a1,a2} \/ {a3} \/ {a4,a5,a6} by ENUMSET1:59
    .= {a0,a1,a2,a3} \/ {a4,a5,a6} by ENUMSET1:6
    .= {a0,a1,a2,a3,a4,a5,a6} by ENUMSET1:19;
  set k2= a2:= a0, k3= a3:= a0, k4= a4:= a0, k5= a5:= a0;
A5: UsedIntLoc initializeWorkMem = UsedIntLoc (k2 ';' k3 ';' k4 ';' k5)
  \/ UsedIntLoc (a6:= a0) by SF_MASTR:30
    .= UsedIntLoc (k2 ';' k3 ';' k4 ';' k5) \/ {a6,a0} by SF_MASTR:14
    .= UsedIntLoc (k2 ';' k3 ';' k4 ) \/ UsedIntLoc k5 \/ {a6,a0}
  by SF_MASTR:30
    .= UsedIntLoc (k2 ';' k3 ';' k4 ) \/ {a5,a0} \/ {a6,a0} by SF_MASTR:14
    .= UsedIntLoc (k2 ';' k3 ) \/ UsedIntLoc k4 \/ {a5,a0} \/
  {a6,a0} by SF_MASTR:30
    .= UsedIntLoc (k2 ';' k3 ) \/ {a4,a0} \/ {a5,a0} \/ {a6,a0} by SF_MASTR:14
    .= UsedIntLoc k2 \/ UsedIntLoc k3 \/ {a4,a0} \/ {a5,a0} \/ {a6,a0}
  by SF_MASTR:31
    .= UsedIntLoc k2 \/ {a3,a0} \/ {a4,a0} \/ {a5,a0} \/
  {a6,a0} by SF_MASTR:14
    .= {a2,a0} \/ {a3,a0} \/ {a4,a0} \/ {a5,a0} \/ {a6,a0} by SF_MASTR:14
    .= {a2,a0} \/ {a3,a0} \/ {a4,a0} \/ ({a5,a0} \/ {a6,a0}) by XBOOLE_1:4
    .= {a2,a0} \/ {a3,a0} \/ {a4,a0} \/ {a0,a5,a6} by ENUMSET1:87
    .= {a0,a2,a3} \/ {a4,a0} \/ {a0,a5,a6} by ENUMSET1:87
    .= {a0,a2,a3} \/ {a4,a0} \/ ({a0} \/ {a5,a6}) by ENUMSET1:2
    .= {a0,a2,a3} \/ {a4,a0} \/ {a0} \/ {a5,a6} by XBOOLE_1:4
    .= {a0,a2,a3} \/ ({a4,a0} \/ {a0}) \/ {a5,a6} by XBOOLE_1:4
    .= {a0,a2,a3} \/ {a4,a0,a0} \/ {a5,a6} by ENUMSET1:3
    .= {a0,a2,a3} \/ ({a0,a0} \/ {a4}) \/ {a5,a6} by ENUMSET1:2
    .= {a0,a2,a3} \/ {a0,a0} \/ {a4} \/ {a5,a6} by XBOOLE_1:4
    .= {a0,a0,a0,a2,a3} \/ {a4} \/ {a5,a6} by ENUMSET1:8
    .= {a0,a2,a3} \/ {a4} \/ {a5,a6} by ENUMSET1:38
    .= {a0,a2,a3,a4} \/ {a5,a6} by ENUMSET1:6
    .= {a0,a2,a3,a4,a5,a6} by ENUMSET1:14
    .= {a0} \/ {a2,a3,a4,a5,a6} by ENUMSET1:11;
  set k7=(a1:=len f), Ut=UsedIntLoc Times(a1,body1);
  thus UsedIntLoc (bubble-sort f)
  =UsedIntLoc ( initializeWorkMem ';' k7 ) \/ Ut by SF_MASTR:27
    .=UsedIntLoc initializeWorkMem \/ UsedIntLoc k7 \/ Ut by SF_MASTR:30
    .={a0} \/ {a2,a3,a4,a5,a6} \/ {a1} \/ Ut by A5,SF_MASTR:18
    .={a0} \/ {a1} \/ {a2,a3,a4,a5,a6} \/ Ut by XBOOLE_1:4
    .={a0,a1} \/ {a2,a3,a4,a5,a6} \/ Ut by ENUMSET1:1
    .={a0,a1,a2,a3,a4,a5,a6} \/ Ut by ENUMSET1:17
    .={a0,a1,a2,a3,a4,a5,a6} \/ ({a1,a0} \/ {a0,a1,a2,a3,a4,a5,a6}) by A4,Th31
    .={a0,a1,a2,a3,a4,a5,a6} \/ {a0,a1,a2,a3,a4,a5,a6} \/ {a1,a0} by XBOOLE_1:4
    .={a2,a3,a4,a5,a6} \/ {a0,a1} \/ {a0,a1} by ENUMSET1:17
    .={a2,a3,a4,a5,a6} \/ ({a0,a1} \/ {a0,a1}) by XBOOLE_1:4
    .={a0,a1,a2,a3,a4,a5,a6} by ENUMSET1:17;
end;

theorem Th59:
  for f being FinSeq-Location holds UsedInt*Loc (bubble-sort f) = {f}
proof
  let f be FinSeq-Location;
  set i1= a4:=a3, i2= SubFrom(a3,a0), i3= (a5:=(f,a3)), i4= (a6:=(f,a4)),
  i5= SubFrom(a6,a5), i6= ((f,a3):=a6), i7= ((f,a4):=a5),
  ifc=if>0(a6,i4 ';' i6 ';' i7,Stop SCM+FSA), Sif= UsedInt*Loc ifc,
  body2= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' ifc;
A1: Sif = UsedInt*Loc (i4 ';' i6 ';' i7) \/ {} by SCMFSA9A:4,10
    .= UsedInt*Loc (i4 ';' i6) \/ UsedInt*Loc i7 by SF_MASTR:46
    .= UsedInt*Loc (i4 ';' i6) \/ {f} by SF_MASTR:33
    .= UsedInt*Loc i4 \/ UsedInt*Loc i6 \/ {f} by SF_MASTR:47
    .= UsedInt*Loc i4 \/ {f} \/ {f} by SF_MASTR:33
    .= {f} \/ {f} \/ {f} by SF_MASTR:33
    .= {f};
A2: UsedInt*Loc body2 = UsedInt*Loc (i1 ';' i2 ';'i3 ';'i4 ';' i5)
  \/ Sif by SF_MASTR:43
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ';' i4) \/ UsedInt*Loc i5 \/ Sif
  by SF_MASTR:46
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ';' i4) \/ {} \/ Sif by SF_MASTR:32
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ) \/ UsedInt*Loc i4 \/ Sif by SF_MASTR:46
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ) \/ {f} \/ Sif by SF_MASTR:33
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ) \/ ({f} \/ {f}) by A1,XBOOLE_1:4
    .= UsedInt*Loc (i1 ';' i2 ) \/ UsedInt*Loc i3 \/ {f} by SF_MASTR:46
    .= UsedInt*Loc (i1 ';' i2 ) \/ {f} \/ {f} by SF_MASTR:33
    .= UsedInt*Loc i1 \/ UsedInt*Loc i2 \/ {f} \/ {f} by SF_MASTR:47
    .= UsedInt*Loc i1 \/ {} \/ {f} \/ {f} by SF_MASTR:32
    .= {} \/ {} \/ {f} \/ {f} by SF_MASTR:32
    .= {f};
  set j1= a2 := a1, j2= SubFrom(a2,a0), j3= (a3:=len f),
  Sfor= UsedInt*Loc Times(a2,body2),
  body1= j1 ';' j2 ';' j3 ';' Times(a2,body2);
A3: Sfor={f} by A2,Th37;
A4: UsedInt*Loc body1 = UsedInt*Loc (j1 ';' j2 ';'j3) \/ Sfor by SF_MASTR:43
    .= UsedInt*Loc (j1 ';' j2) \/ UsedInt*Loc j3 \/ Sfor by SF_MASTR:46
    .= UsedInt*Loc (j1 ';' j2) \/ {f} \/ Sfor by SF_MASTR:34
    .= UsedInt*Loc j1 \/ UsedInt*Loc j2 \/ {f} \/ Sfor by SF_MASTR:47
    .= {} \/ UsedInt*Loc j2 \/ {f} \/ Sfor by SF_MASTR:32
    .= {} \/ {} \/ {f} \/ Sfor by SF_MASTR:32
    .= {f} by A3;
  set k2= a2:= a0, k3= a3:= a0, k4= a4:= a0, k5= a5:= a0;
A5: UsedInt*Loc initializeWorkMem = UsedInt*Loc (k2 ';' k3 ';' k4 ';' k5)
  \/ UsedInt*Loc (a6:= a0) by SF_MASTR:46
    .= UsedInt*Loc (k2 ';' k3 ';' k4 ';' k5) \/ {} by SF_MASTR:32
    .= UsedInt*Loc (k2 ';' k3 ';' k4) \/ UsedInt*Loc k5 by SF_MASTR:46
    .= UsedInt*Loc (k2 ';' k3 ';' k4) \/ {} by SF_MASTR:32
    .= UsedInt*Loc (k2 ';' k3 ) \/ UsedInt*Loc k4 by SF_MASTR:46
    .= UsedInt*Loc (k2 ';' k3 ) \/ {} by SF_MASTR:32
    .= UsedInt*Loc k2 \/ UsedInt*Loc k3 by SF_MASTR:47
    .= UsedInt*Loc k2 \/ {} by SF_MASTR:32
    .= {} by SF_MASTR:32;
  set k7=(a1:=len f) , Ut=UsedInt*Loc Times(a1,body1);
  thus UsedInt*Loc (bubble-sort f)
  =UsedInt*Loc ( initializeWorkMem ';' k7 ) \/ Ut by SF_MASTR:43
    .=UsedInt*Loc initializeWorkMem \/ UsedInt*Loc k7 \/ Ut by SF_MASTR:46
    .={f} \/ Ut by A5,SF_MASTR:34
    .={f} \/ {f} by A4,Th37
    .={f};
end;

definition
  func Sorting-Function -> PartFunc of FinPartSt SCM+FSA,FinPartSt SCM+FSA
  means
  :Def3:
  for p,q being FinPartState of SCM+FSA holds [p,q] in it
  iff ex t being FinSequence of INT,u being FinSequence of REAL
  st t,u are_fiberwise_equipotent & u is FinSequence of INT &
  u is non-increasing & p = fsloc 0 .--> t & q = fsloc 0 .--> u;
  existence
  proof
    defpred X[set,set] means
    ex t being FinSequence of INT,u being FinSequence of REAL
    st t,u are_fiberwise_equipotent & u is FinSequence of INT &
    u is non-increasing & $1 = fsloc 0 .--> t & $2 = fsloc 0 .--> u;
A1: for x,y1,y2 being set st X[x,y1] & X[x,y2] holds y1 = y2
    proof
      let p,q1,q2 be set;
      given t1 being FinSequence of INT,u1 being FinSequence of REAL such that
A2:   t1,u1 are_fiberwise_equipotent
      and u1 is FinSequence of INT and
A3:   u1 is non-increasing and
A4:   p = fsloc 0 .--> t1 and
A5:   q1 = fsloc 0 .--> u1;
      given t2 being FinSequence of INT,u2 being FinSequence of REAL such that
A6:   t2,u2 are_fiberwise_equipotent
      and u2 is FinSequence of INT and
A7:   u2 is non-increasing and
A8:   p = fsloc 0 .--> t2 and
A9:   q2 = fsloc 0 .--> u2;
      t1=(fsloc 0 .--> t1).(fsloc 0) by FUNCOP_1:72
        .=t2 by A4,A8,FUNCOP_1:72;
      hence thesis by A2,A3,A5,A6,A7,A9,CLASSES1:76,RFINSEQ:23;
    end;
    consider f being Function such that
A10: for p,q being set holds [p,q] in f iff p in FinPartSt SCM+FSA &
    X[p,q] from FUNCT_1:sch 1(A1);
A11: dom f c= FinPartSt SCM+FSA
    proof
      let e be set;
      assume e in dom f;
      then [e,f.e] in f by FUNCT_1:1;
      hence thesis by A10;
    end;
    rng f c= FinPartSt SCM+FSA
    proof
      let q be set;
      assume q in rng f;
      then consider p being set such that
A12:  [p,q] in f by RELAT_1:def 5;
      consider t being FinSequence of INT,u being FinSequence of REAL
      such that
      t,u are_fiberwise_equipotent and
A13:  u is FinSequence of INT
      and u is non-increasing
      and p = fsloc 0 .--> t and
A14:  q = fsloc 0 .--> u by A10,A12;
      reconsider u as FinSequence of INT by A13;
      fsloc 0 .--> u is FinPartState of SCM+FSA;
      hence thesis by A14,MEMSTR_0:75;
    end;
    then reconsider f as PartFunc of FinPartSt SCM+FSA, FinPartSt SCM+FSA
    by A11,RELSET_1:4;
    take f;
    let p,q be FinPartState of SCM+FSA;
    thus [p,q] in f implies
    ex t being FinSequence of INT,u being FinSequence of REAL
    st t,u are_fiberwise_equipotent & u is FinSequence of INT &
    u is non-increasing & p = fsloc 0 .--> t & q = fsloc 0 .--> u by A10;
    given t being FinSequence of INT,u being FinSequence of REAL such that
A15: t,u are_fiberwise_equipotent and
A16: u is FinSequence of INT and
A17: u is non-increasing and
A18: p = fsloc 0 .--> t and
A19: q = fsloc 0 .--> u;
    p in FinPartSt SCM+FSA by MEMSTR_0:75;
    hence thesis by A10,A15,A16,A17,A18,A19;
  end;
  uniqueness
  proof
    let IT1,IT2 be PartFunc of FinPartSt SCM+FSA, FinPartSt SCM+FSA such that
A20: for p,q being FinPartState of SCM+FSA holds [p,q] in IT1
    iff ex t being FinSequence of INT,u being FinSequence of REAL
    st t,u are_fiberwise_equipotent & u is FinSequence of INT &
    u is non-increasing & p = fsloc 0 .--> t & q = fsloc 0 .--> u and
A21: for p,q being FinPartState of SCM+FSA holds [p,q] in IT2
    iff ex t being FinSequence of INT,u being FinSequence of REAL
    st t,u are_fiberwise_equipotent & u is FinSequence of INT &
    u is non-increasing & p = fsloc 0 .--> t & q = fsloc 0 .--> u;
    defpred X[set,set] means
    ex t being FinSequence of INT,u being FinSequence of REAL
    st t,u are_fiberwise_equipotent & u is FinSequence of INT &
    u is non-increasing & $1 = fsloc 0 .--> t & $2 = fsloc 0 .--> u;
A22: for p,q being Element of FinPartSt SCM+FSA holds [p,q] in IT1 iff X[p,q]
    proof
      let p,q be Element of FinPartSt SCM+FSA;
      reconsider p,q as FinPartState of SCM+FSA by MEMSTR_0:76;
      [p,q] in IT1 iff X[p,q] by A20;
      hence thesis;
    end;
A23: for p,q being Element of FinPartSt SCM+FSA holds [p,q] in IT2 iff X[p,q]
    proof
      let p,q be Element of FinPartSt SCM+FSA;
      reconsider p,q as FinPartState of SCM+FSA by MEMSTR_0:76;
      [p,q] in IT2 iff X[p,q] by A21;
      hence thesis;
    end;
    thus IT1 = IT2 from RELSET_1:sch 4(A22,A23);
  end;
end;

theorem Th60:
  for p being set holds p in dom Sorting-Function iff
  ex t being FinSequence of INT st p = fsloc 0 .--> t
proof
  set f=Sorting-Function;
  let p be set;
  hereby
    set q=f.p;
    assume
A1: p in dom f;
    then
A2: [p,f.p] in f by FUNCT_1:1;
    dom f c=FinPartSt SCM+FSA by RELAT_1:def 18;
    then
A3: p is FinPartState of SCM+FSA by A1,MEMSTR_0:76;
    q in FinPartSt SCM+FSA by A1,PARTFUN1:4;
    then q is FinPartState of SCM+FSA by MEMSTR_0:76;
    then consider t be FinSequence of INT,u being FinSequence of REAL such that
    t,u are_fiberwise_equipotent
    and u is FinSequence of INT
    and u is non-increasing and
A4: p = fsloc 0 .--> t
    and q = fsloc 0 .--> u
    by A2,A3,Def3;
    take t;
    thus p = fsloc 0 .--> t by A4;
  end;
  given t be FinSequence of INT such that
A5: p = fsloc 0 .--> t;
  consider u be FinSequence of REAL such that
A6: t,u are_fiberwise_equipotent and
A7: u is FinSequence of INT and
A8: u is non-increasing by RFINSEQ:33;
  reconsider u1=u as FinSequence of INT by A7;
  set q=fsloc 0 .--> u1;
  [p,q] in f by A5,A6,A8,Def3;
  hence thesis by FUNCT_1:1;
end;

theorem Th61:
  for t being FinSequence of INT holds
  ex u being FinSequence of REAL st t,u are_fiberwise_equipotent &
  u is non-increasing & u is FinSequence of INT &
  Sorting-Function.(fsloc 0 .--> t ) = fsloc 0 .--> u
proof
  let t be FinSequence of INT;
  consider u being FinSequence of REAL such that
A1: t,u are_fiberwise_equipotent and
A2: u is FinSequence of INT and
A3: u is non-increasing by RFINSEQ:33;
  reconsider u as FinSequence of INT by A2;
  set p = fsloc 0 .--> t;
  set q = fsloc 0 .--> u;
  [p, q] in Sorting-Function by A1,A3,Def3;
  then Sorting-Function.p = q by FUNCT_1:1;
  hence thesis by A1,A3;
end;

theorem Th62:
  for f being FinSeq-Location holds card (bubble-sort f) = 63
proof
  let f be FinSeq-Location;
  set i1= a4:=a3, i2= SubFrom(a3,a0), i3= (a5:=(f,a3)), i4= (a6:=(f,a4)),
  i5= SubFrom(a6,a5), i6= ((f,a3):=a6), i7= ((f,a4):=a5),
  ifc=if>0(a6,i4 ';' i6 ';' i7,Stop SCM+FSA), Cif= card ifc,
  body2= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' ifc;
   card Stop SCM+FSA = 1 by COMPOS_1:4;
   then
A1: Cif=card (i4 ';' i6 ';' i7) + 1 + 4 by SCMFSA8B:12
    .=6 + 1 + 4 by Th45
    .=11;
A2: card body2 = card (i1 ';' i2 ';' i3 ';' i4 ';' i5) + Cif by SCMFSA6A:21
    .= card (i1 ';' i2 ';' i3 ';' (i4 ';' i5))+Cif by SCMFSA6A:28
    .= card (i1 ';' i2 ';' i3) + card (i4 ';' i5)+Cif by SCMFSA6A:21
    .= 6 + card (i4 ';' i5)+Cif by Th45
    .= 6 + 4+ Cif by SCMFSA6A:35
    .=21 by A1;
  set j1= a2 := a1, j2= SubFrom(a2,a0) , j3= (a3:=len f) ,
  body1= j1 ';' j2 ';' j3 ';' Times(a2,body2);
  A3: card
 body1 = card (j1 ';' j2 ';' j3) + card Times(a2,body2) by SCMFSA6A:21
    .= 6 + card Times(a2,body2) by Th45
    .= 6 + (21 +12) by A2,Th44
    .= 39;
  set k2= a2:= a0, k3= a3:= a0, k4= a4:= a0, k5= a5:= a0, k6= a6:= a0;
A4: card initializeWorkMem
    = card (k2 ';' k3 ';' k4 ';' k5)+ 2 by SCMFSA6A:34
   .= card (k2 ';' k3 ';' k4 ) + 2+ 2 by SCMFSA6A:34
   .= card (k2 ';' k3 ';' k4 ) + 4
    .= 6 + 4 by Th45
    .= 10;
  set k7=(a1:=len f), Ct=card Times(a1,body1);
A5: Ct=39 +12 by A3,Th44;
  thus card (bubble-sort f)
    = card (initializeWorkMem ';' k7)+ Ct by SCMFSA6A:21
    .= 10 + 2 + Ct by A4,SCMFSA6A:34
    .=63 by A5;
end;

theorem Th63:
  for P being Instruction-Sequence of SCM+FSA
   st Bubble-Sort-Algorithm c= P
  for f being FinSeq-Location, k being Element of NAT st
  k < 63 holds Bubble-Sort-Algorithm.k= P.k
proof
  let P be Instruction-Sequence of SCM+FSA such that
A1: Bubble-Sort-Algorithm c= P;
  let f be FinSeq-Location, k be Element of NAT;
  assume
A2: k < 63;
  card (bubble-sort f0) = 63 by Th62;
  then k in dom Bubble-Sort-Algorithm by A2,AFINSQ_1:66;
 hence Bubble-Sort-Algorithm.k= P.k by A1,GRFUNC_1:2;
end;

Lm20:
 for P being Instruction-Sequence of SCM+FSA
   st Bubble-Sort-Algorithm c= P holds
P. 0= a2:=a0 & P. 1= goto  2 &
P. 2= a3:=a0 & P. 3= goto  4 &
P. 4= a4:=a0 & P. 5= goto  6 &
P. 6= a5:=a0 & P. 7= goto  8 &
P. 8= a6:=a0 & P. 9= goto  10 &
P. 10= a1:=len fsloc 0 & P. 11= goto  12
proof
  set f0=fsloc 0, TT=Times(a1, a2 := a1 ';' SubFrom(a2,a0) ';'
  (a3:=len f0) ';' Times(a2, a4:=a3 ';' SubFrom(a3,a0) ';' (a5:=(f0,a3)) ';'
  (a6:=(f0,a4)) ';' SubFrom(a6,a5) ';' if>0(a6,(a6:=(f0,a4)) ';'
  ((f0,a3):=a6) ';'((f0,a4):=a5),Stop SCM+FSA) ) );
  set q=Bubble-Sort-Algorithm;
  let P be Instruction-Sequence of SCM+FSA
   such that
A1: q c= P;
  set W2=a2:= a0, W3=a3:= a0, W4=a4:= a0, W5=a5:= a0, W6=a6:= a0,
  W7=a1:=len f0, T7=W7 ';' TT, T6=W6 ';' T7, T5=W5 ';' T6, T4=W4 ';' T5,
  T3=W3 ';' T4, X3=W2 ';' W3, X4=X3 ';' W4, X5=X4 ';' W5, X6=X5 ';' W6;
A2: q=X5 ';' W6 ';' T7 by SCMFSA6A:27;
  then
A3: q=X4 ';' W5 ';' T6 by SCMFSA6A:27;
  then
A4: q=X3 ';' W4 ';' T5 by SCMFSA6A:27;
  then q=W2 ';' W3 ';' T4 by SCMFSA6A:27;
  then q=W2 ';' T3 by SCMFSA6A:31;
  then
A5: q= Macro W2 ';' T3 by SCMFSA6A:def 5;
A6: q =Macro W2 ';' W3 ';' T4 by A5,SCMFSA6A:27;
A7: dom Macro W2 = { 0,  1} by COMPOS_1:61;
  then
A8:  0 in dom Macro W2 by TARSKI:def 2;
A9:  1 in dom Macro W2 by A7,TARSKI:def 2;
  thus P. 0=q. 0 by A1,Th63
    .= (Directed Macro W2). 0 by A8,A5,SCMFSA8A:14
    .= W2 by SCMFSA7B:1;
  thus P. 1=q. 1 by A1,Th63
    .= (Directed Macro W2). 1 by A9,A5,SCMFSA8A:14
    .= goto  2 by SCMFSA7B:2;
A10: card Macro W2=2 by COMPOS_1:56;
  thus P. 2=q. 2 by A1,Th63
    .= W3 by A6,A10,Th51;
  thus P. 3=q. (2+1) by A1,Th63
    .=goto  (2+2) by A6,A10,Th51
    .=goto  4;
A11: card X3 =4 by SCMFSA6A:35;
  thus P. 4=q. 4 by A1,Th63
    .= W4 by A4,A11,Th51;
  thus P. 5=q. (4+1) by A1,Th63
    .=goto (4+2) by A4,A11,Th51
    .=goto  6;
A12: card X4=6 by Th45;
  thus P. 6=q. 6 by A1,Th63
    .= W5 by A3,A12,Th51;
  thus P. 7=q. (6+1) by A1,Th63
    .=goto  (6+2) by A3,A12,Th51
    .=goto  8;
A13: card X5 = 6 + 2 by A12,SCMFSA6A:34;
  thus P. 8=q. 8 by A1,Th63
    .= W6 by A2,A13,Th51;
  thus P. 9=q. (8+1) by A1,Th63
    .=goto  (8+2) by A2,A13,Th51
    .=goto  10;
A14: card X6 = 8 + 2 by A13,SCMFSA6A:34;
  thus P. 10=q. 10 by A1,Th63
    .= W7 by A14,Th52;
  thus P. 11=q. (10+1) by A1,Th63
    .=goto  (10+2) by A14,Th52
    .=goto  12;
end;

Lm21: for s being 0-started State of SCM+FSA
 for P being Instruction-Sequence of SCM+FSA
  st Bubble-Sort-Algorithm c= P
 holds Comput(P,s,1).IC SCM+FSA =  1 &
Comput(P, s,1).a0=s.a0 & Comput(P, s,1).fsloc 0=s.fsloc 0 &
Comput(P, s,2).IC SCM+FSA =  2 &
Comput(P, s,2).a0=s.a0 & Comput(P, s,2).fsloc 0=s.fsloc 0 &
Comput(P, s,3).IC SCM+FSA =  3 &
Comput(P, s,3).a0=s.a0 & Comput(P, s,3).fsloc 0=s.fsloc 0 &
Comput(P, s,4).IC SCM+FSA =  4 &
Comput(P, s,4).a0=s.a0 & Comput(P, s,4).fsloc 0=s.fsloc 0 &
Comput(P, s,5).IC SCM+FSA =  5 &
Comput(P, s,5).a0=s.a0 & Comput(P, s,5).fsloc 0=s.fsloc 0 &
Comput(P, s,6).IC SCM+FSA =  6 &
Comput(P, s,6).a0=s.a0 & Comput(P, s,6).fsloc 0=s.fsloc 0 &
Comput(P, s,7).IC SCM+FSA =  7 &
Comput(P, s,7).a0=s.a0 & Comput(P, s,7).fsloc 0=s.fsloc 0 &
Comput(P, s,8).IC SCM+FSA =  8 &
Comput(P, s,8).a0=s.a0 & Comput(P, s,8).fsloc 0=s.fsloc 0 &
Comput(P, s,9).IC SCM+FSA =  9 &
Comput(P, s,9).a0=s.a0 & Comput(P, s,9).fsloc 0=s.fsloc 0 &
Comput(P, s,10).IC SCM+FSA =  10 &
Comput(P, s,10).a0=s.a0 & Comput(P, s,10).fsloc 0=s.fsloc 0 &
Comput(P, s,11).IC SCM+FSA =  11 &
Comput(P, s,11).a0=s.a0 & Comput(P, s,11).fsloc 0=s.fsloc 0 &
Comput(P, s,11).a1=len(s.fsloc 0) &
Comput(P, s,11).a2=s.a0 & Comput(P, s,11).a3=s.a0 &
Comput(P, s,11).a4=s.a0 & Comput(P, s,11).a5=s.a0 &
Comput(P, s,11).a6=s.a0
proof
  let s be 0-started State of SCM+FSA;
  let P be Instruction-Sequence of SCM+FSA such that
A1: Bubble-Sort-Algorithm c= P;
A2: Comput(P,s,0) = s by EXTPRO_1:2;
  then
A3: IC Comput(P,s,0) =  0 by MEMSTR_0:def 8;
  then
A4: Comput(P,s,0+1) =
    Exec((P). 0,Comput(P,s,0)) by EXTPRO_1:6
    .= Exec(a2:=a0,Comput(P,s,0)) by A1,Lm20;
  hence Comput(P,s,1).IC SCM+FSA = succ IC Comput(P,s
,0) by SCMFSA_2:63
    .=  1 by A3;
  then
A5: IC Comput(P,s,1)=  1;
A6: Comput(P,s,1).a2 =s.a0 by A2,A4,SCMFSA_2:63;
  thus
A7: Comput(P,s,1).a0 =s.a0 by A2,A4,Lm1,SCMFSA_2:63;
  thus
A8: Comput(P,s,1).(fsloc 0) =s.(fsloc 0) by A2,A4,SCMFSA_2:63;
A9: Comput(P,s,1+1)
 = Exec((P). 1,Comput(P,s,1)) by A5,EXTPRO_1:6
    .= Exec(goto  2,Comput(P,s,1)) by A1,Lm20;
  hence
A10: Comput(P,s,2).IC SCM+FSA =  2 by SCMFSA_2:69;
A11: IC Comput(P,s,2)=  2 by A9,SCMFSA_2:69;
  thus
A12: Comput(P,s,2).a0 =s.a0 by A7,A9,SCMFSA_2:69;
  thus
A13: Comput(P,s,2).(fsloc 0) =s.(fsloc 0) by A8,A9,SCMFSA_2:69;
A14: Comput(P,s,2).a2 =s.a0 by A6,A9,SCMFSA_2:69;
A15: Comput(P,s,2+1) =
 Exec((P). 2,Comput(P,s,2)) by A11,EXTPRO_1:6
    .= Exec(a3:=a0,Comput(P,s,2)) by A1,Lm20;
  hence Comput(P,s,3).IC SCM+FSA = succ IC Comput(P,s
,2) by SCMFSA_2:63
    .=  3 by A10;
  then
A16: IC Comput(P,s,3)=  3;
A17: Comput(P,s,3).a3 =s.a0 by A12,A15,SCMFSA_2:63;
  thus
A18: Comput(P,s,3).a0 =s.a0 by A12,A15,SCMFSA_2:63;
  thus
A19: Comput(P,s,3).(fsloc 0) =s.(fsloc 0) by A13,A15,SCMFSA_2:63;
A20: Comput(P,s,3).a2 =s.a0 by A14,A15,Lm10,SCMFSA_2:63;
A21: Comput(P,s,3+1) =
   Exec((P). 3,Comput(P,s,3)) by A16,EXTPRO_1:6
    .= Exec(goto  4,Comput(P,s,3)) by A1,Lm20;
  hence
A22: Comput(P,s,4).IC SCM+FSA =  4 by SCMFSA_2:69;
A23: IC Comput(P,s,4)=  4 by A21,SCMFSA_2:69;
  thus
A24: Comput(P,s,4).a0 =s.a0 by A18,A21,SCMFSA_2:69;
  thus
A25: Comput(P,s,4).(fsloc 0) =s.(fsloc 0) by A19,A21,SCMFSA_2:69;
A26: Comput(P,s,4).a2 =s.a0 by A20,A21,SCMFSA_2:69;
A27: Comput(P,s,4).a3 =s.a0 by A17,A21,SCMFSA_2:69;
A28: Comput(P,s,4+1) =
    Exec((P). 4,Comput(P,s,4)) by A23,EXTPRO_1:6
    .= Exec(a4:=a0,Comput(P,s,4)) by A1,Lm20;
  hence Comput(P,s,5).IC SCM+FSA = succ IC Comput(P,s
,4) by SCMFSA_2:63
    .=  5 by A22;
  then
A29: IC Comput(P,s,5)=  5;
A30: Comput(P,s,5).a4 =s.a0 by A24,A28,SCMFSA_2:63;
  thus
A31: Comput(P,s,5).a0 =s.a0 by A24,A28,Lm2,SCMFSA_2:63;
  thus
A32: Comput(P,s,5).(fsloc 0) =s.(fsloc 0) by A25,A28,SCMFSA_2:63;
A33: Comput(P,s,5).a2 =s.a0 by A26,A28,Lm11,SCMFSA_2:63;
A34: Comput(P,s,5).a3 =s.a0 by A27,A28,Lm14,SCMFSA_2:63;
A35: Comput(P,s,5+1)
 = Exec((P). 5,Comput(P,s,5)) by A29,EXTPRO_1:6
    .= Exec(goto  6,Comput(P,s,5)) by A1,Lm20;
  hence
A36: Comput(P,s,6).IC SCM+FSA =  6 by SCMFSA_2:69;
A37: IC Comput(P,s,6)=  6 by A35,SCMFSA_2:69;
  thus
A38: Comput(P,s,6).a0 =s.a0 by A31,A35,SCMFSA_2:69;
  thus
A39: Comput(P,s,6).(fsloc 0) =s.(fsloc 0) by A32,A35,SCMFSA_2:69;
A40: Comput(P,s,6).a2 =s.a0 by A33,A35,SCMFSA_2:69;
A41: Comput(P,s,6).a3 =s.a0 by A34,A35,SCMFSA_2:69;
A42: Comput(P,s,6).a4 =s.a0 by A30,A35,SCMFSA_2:69;
A43: Comput(P,s,6+1) =
  Exec((P). 6,Comput(P,s,6)) by A37,EXTPRO_1:6
    .= Exec(a5:=a0,Comput(P,s,6)) by A1,Lm20;
  hence Comput(P,s,7).IC SCM+FSA = succ IC Comput(P,s
,6) by SCMFSA_2:63
    .=  7 by A36;
  then
A44: IC Comput(P,s,7)=  7;
A45: Comput(P,s,7).a5 =s.a0 by A38,A43,SCMFSA_2:63;
  thus
A46: Comput(P,s,7).a0 =s.a0 by A38,A43,Lm3,SCMFSA_2:63;
  thus
A47: Comput(P,s,7).(fsloc 0) =s.(fsloc 0) by A39,A43,SCMFSA_2:63;
A48: Comput(P,s,7).a2 =s.a0 by A40,A43,Lm12,SCMFSA_2:63;
A49: Comput(P,s,7).a3 =s.a0 by A41,A43,Lm15,SCMFSA_2:63;
A50: Comput(P,s,7).a4 =s.a0 by A42,A43,Lm17,SCMFSA_2:63;
A51: Comput(P,s,7+1) =
 Exec((P). 7,Comput(P,s,7)) by A44,EXTPRO_1:6
    .= Exec(goto  8,Comput(P,s,7)) by A1,Lm20;
  hence
A52: Comput(P,s,8).IC SCM+FSA =  8 by SCMFSA_2:69;
A53: IC Comput(P,s,8)=  8 by A51,SCMFSA_2:69;
  thus
A54: Comput(P,s,8).a0 =s.a0 by A46,A51,SCMFSA_2:69;
  thus
A55: Comput(P,s,8).(fsloc 0) =s.(fsloc 0) by A47,A51,SCMFSA_2:69;
A56: Comput(P,s,8).a2 =s.a0 by A48,A51,SCMFSA_2:69;
A57: Comput(P,s,8).a3 =s.a0 by A49,A51,SCMFSA_2:69;
A58: Comput(P,s,8).a4 =s.a0 by A50,A51,SCMFSA_2:69;
A59: Comput(P,s,8).a5 =s.a0 by A45,A51,SCMFSA_2:69;
A60: Comput(P,s,8+1) =
 Exec((P). 8,Comput(P,s,8)) by A53,EXTPRO_1:6
    .= Exec(a6:=a0,Comput(P,s,8)) by A1,Lm20;
  hence Comput(P,s,9).IC SCM+FSA = succ IC Comput(P,s
,8) by SCMFSA_2:63
    .=  9 by A52;
  then
A61: IC Comput(P,s,9)=  9;
A62: Comput(P,s,9).a6 =s.a0 by A54,A60,SCMFSA_2:63;
  thus
A63: Comput(P,s,9).a0 =s.a0 by A54,A60,Lm4,SCMFSA_2:63;
  thus
A64: Comput(P,s,9).(fsloc 0) =s.(fsloc 0) by A55,A60,SCMFSA_2:63;
A65: Comput(P,s,9).a2 =s.a0 by A56,A60,Lm13,SCMFSA_2:63;
A66: Comput(P,s,9).a3 =s.a0 by A57,A60,Lm16,SCMFSA_2:63;
A67: Comput(P,s,9).a4 =s.a0 by A58,A60,Lm18,SCMFSA_2:63;
A68: Comput(P,s,9).a5 =s.a0 by A59,A60,Lm19,SCMFSA_2:63;
A69: Comput(P,s,9+1) = Exec(P.9,Comput(P,s,9)) by A61,EXTPRO_1:6
    .= Exec(goto  10,Comput(P,s,9)) by A1,Lm20;
  hence
A70: Comput(P,s,10).IC SCM+FSA =  10 by SCMFSA_2:69;
A71: IC Comput(P,s,10)=  10 by A69,SCMFSA_2:69;
  thus
A72: Comput(P,s,10).a0 =s.a0 by A63,A69,SCMFSA_2:69;
  thus
A73: Comput(P,s,10).(fsloc 0) =s.(fsloc 0) by A64,A69,SCMFSA_2:69;
A74: Comput(P,s,10).a2 =s.a0 by A65,A69,SCMFSA_2:69;
A75: Comput(P,s,10).a3 =s.a0 by A66,A69,SCMFSA_2:69;
A76: Comput(P,s,10).a4 =s.a0 by A67,A69,SCMFSA_2:69;
A77: Comput(P,s,10).a5 =s.a0 by A68,A69,SCMFSA_2:69;
A78: Comput(P,s,10).a6 =s.a0 by A62,A69,SCMFSA_2:69;
A79: Comput(P,s,10+1) = Exec(P.10,Comput(P,s,10)) by A71,EXTPRO_1:6
    .= Exec(a1:=len fsloc 0,Comput(P,s,10)) by A1,Lm20;
  hence Comput(P,s,11).IC SCM+FSA = succ IC Comput(P,s,10) by SCMFSA_2:74
    .=  11 by A70;
   a0 <> a1 by SCMFSA_2:101;
  hence Comput(P,s,11).a0 =s.a0 by A72,A79,SCMFSA_2:74;
  thus Comput(P,s,11).(fsloc 0) =s.(fsloc 0) by A73,A79,SCMFSA_2:74;
  thus Comput(P,s,11).a1 =len(s.fsloc 0) by A73,A79,SCMFSA_2:74;
  thus Comput(P,s,11).a2 =s.a0 by A74,A79,Lm5,SCMFSA_2:74;
  thus Comput(P,s,11).a3 =s.a0 by A75,A79,Lm6,SCMFSA_2:74;
  thus Comput(P,s,11).a4 =s.a0 by A76,A79,Lm7,SCMFSA_2:74;
  thus Comput(P,s,11).a5 =s.a0 by A77,A79,Lm8,SCMFSA_2:74;
  thus thesis by A78,A79,Lm9,SCMFSA_2:74;
end;

Lm22: body2 does not destroy b2
proof
A1: i1 does not destroy b2 by SCMFSA7B:6,SCMFSA_2:101;
A2: i2 does not destroy b2 by SCMFSA7B:8,SCMFSA_2:101;
A3: i3 does not destroy b2 by SCMFSA7B:14,SCMFSA_2:101;
A4: i4 does not destroy b2 by SCMFSA7B:14,SCMFSA_2:101;
A5: i6 does not destroy b2 by SCMFSA7B:15;
A6: i7 does not destroy b2 by SCMFSA7B:15;
A7: SS does not destroy b2 by SCMFSA8C:56;
  i4 ';' i6 ';' i7 does not destroy b2 by A4,A5,A6,SCMFSA8C:54,55;
  then
A8: ifc does not destroy b2 by A7,SCMFSA8C:88;
  i1 ';' i2 ';' i3 does not destroy b2 by A1,A2,A3,SCMFSA8C:54,55;
  then i1 ';' i2 ';' i3 ';' i4 does not destroy b2 by Lm13,SCMFSA7B:14
,SCMFSA8C:54;
  then i1 ';' i2 ';' i3 ';' i4 ';' i5 does not destroy b2
  by Lm13,SCMFSA7B:8,SCMFSA8C:54;
  hence thesis by A8,SCMFSA8C:52;
end;

Lm23: Times(b2,body2) is good InitHalting
proof
  thus Times(b2,body2) is good;
  let s be State of SCM+FSA such that
Z1: Initialize ((intloc 0) .--> 1) c= s;
  let P be Instruction-Sequence of SCM+FSA such that
Z2: Times(b2,body2) c= P;
ZZ2: P +* Times(b2,body2) = P by Z2,FUNCT_4:98;
X2: dom((intloc 0) .--> 1) = {intloc 0} by FUNCOP_1:13;
X1:  dom((intloc 0) .--> 1) misses {IC SCM+FSA} by X2,SCMFSA_2:56,ZFMISC_1:11;
   Start-At(0,SCM+FSA) c= Initialize ((intloc 0) .--> 1) by FUNCT_4:25;
   then
x:    s = Initialize s by Z1,FUNCT_4:98,XBOOLE_1:1;
Y2: intloc 0 in dom((intloc 0) .--> 1) by X2,TARSKI:def 1;
   dom ((intloc 0) .--> 1) misses dom Start-At(0,SCM+FSA) by X1,FUNCOP_1:13;
   then
   ((intloc 0) .--> 1) c= Initialize((intloc 0) .--> 1)
         by FUNCT_4:32;
   then ((intloc 0) .--> 1) c= s by Z1,XBOOLE_1:1;
   then
A2: s.intloc 0 = ((intloc 0) .--> 1).intloc 0 by Y2,GRFUNC_1:2
         .= 1 by FUNCOP_1:72;
  Times(b2,body2) is_halting_on s,P by Lm22,A2,SCM_HALT:62;
  hence P halts_on s by x,ZZ2,SCMFSA7B:def 7;
end;

Lm24: body2 does not destroy b1
proof
A1: i1 does not destroy b1 by SCMFSA7B:6,SCMFSA_2:101;
A2: i2 does not destroy b1 by SCMFSA7B:8,SCMFSA_2:101;
A3: i3 does not destroy b1 by SCMFSA7B:14,SCMFSA_2:101;
A4: i4 does not destroy b1 by SCMFSA7B:14,SCMFSA_2:101;
A5: i6 does not destroy b1 by SCMFSA7B:15;
A6: i7 does not destroy b1 by SCMFSA7B:15;
A7: SS does not destroy b1 by SCMFSA8C:56;
  i4 ';' i6 ';' i7 does not destroy b1 by A4,A5,A6,SCMFSA8C:54,55;
  then
A8: ifc does not destroy b1 by A7,SCMFSA8C:88;
  i1 ';' i2 ';' i3 does not destroy b1 by A1,A2,A3,SCMFSA8C:54,55;
  then i1 ';' i2 ';' i3 ';' i4 does not destroy b1 by Lm9,SCMFSA7B:14
,SCMFSA8C:54;
  then i1 ';' i2 ';' i3 ';' i4 ';' i5 does not destroy b1
  by Lm9,SCMFSA7B:8,SCMFSA8C:54;
  hence thesis by A8,SCMFSA8C:52;
end;

Lm25: body1 does not destroy b1
proof
A1: j1 does not destroy b1 by SCMFSA7B:6,SCMFSA_2:101;
A2: j2 does not destroy b1 by SCMFSA7B:8,SCMFSA_2:101;
A3: j3 does not destroy b1 by SCMFSA7B:16,SCMFSA_2:101;
A4: T2 does not destroy b1 by Lm24,Th3,SCMFSA_2:101;
  j1 ';' j2 ';' j3 does not destroy b1 by A1,A2,A3,SCMFSA8C:54,55;
  hence thesis by A4,SCMFSA8C:52;
end;

Lm26: Times(b1,body1) is good InitHalting
proof
  thus Times(b1,body1) is good;
  let s be State of SCM+FSA such that
Z1: Initialize ((intloc 0) .--> 1) c= s;
  let P be Instruction-Sequence of SCM+FSA such that
Z2: Times(b1,body1) c= P;
ZZ2: P +* Times(b1,body1) = P by Z2,FUNCT_4:98;
X2: dom((intloc 0) .--> 1) = {intloc 0} by FUNCOP_1:13;
X1:  dom((intloc 0) .--> 1) misses {IC SCM+FSA} by X2,SCMFSA_2:56,ZFMISC_1:11;
   Start-At(0,SCM+FSA) c= Initialize ((intloc 0) .--> 1) by FUNCT_4:25;
   then
x:    s = Initialize s by Z1,FUNCT_4:98,XBOOLE_1:1;
Y2: intloc 0 in dom((intloc 0) .--> 1) by X2,TARSKI:def 1;
   dom ((intloc 0) .--> 1) misses dom Start-At(0,SCM+FSA) by X1,FUNCOP_1:13;
   then ((intloc 0) .--> 1) c= Initialize((intloc 0) .--> 1) by FUNCT_4:32;
   then ((intloc 0) .--> 1) c= s by Z1,XBOOLE_1:1;
   then
A2: s.intloc 0 = ((intloc 0) .--> 1).intloc 0 by Y2,GRFUNC_1:2
         .= 1 by FUNCOP_1:72;
  reconsider TT=T2 as good InitHalting Program of SCM+FSA by Lm23;
  body1= j1 ';' j2 ';' j3 ';' TT;
  then Times(b1,body1) is_halting_on s,P by Lm25,A2,SCM_HALT:62;
  hence P halts_on s by x,ZZ2,SCMFSA7B:def 7;
end;

theorem
  bubble-sort (fsloc 0) is keepInt0_1 InitHalting by Lm26;

Lm27:
 for p be Instruction-Sequence of SCM+FSA
 for s be State of SCM+FSA holds (s.b6 > 0 implies
 IExec(ifc,p,s).f0 =
s.f0+*(abs(s.b3),(s.f0)/.abs(s.b4)) +*(abs(s.b4),s.b5)) &
(s.b6 <= 0 implies IExec(ifc,p,s).f0=s.f0)
proof
  let p be Instruction-Sequence of SCM+FSA;
  let s be State of SCM+FSA;
  set s0=Initialized s, s1=Exec(i4, s0), s2=IExec(i4 ';' i6,p,s);
A1: s0.f0=s.f0 by SCMFSA6C:3;
  s0.b4=s.b4 by SCMFSA6C:3;
  then
A2: s1.b6=(s.f0)/.abs(s.b4) by A1,Th8;
A3: s1.f0=s.f0 by A1,SCMFSA_2:72;
A4: s1.b3=s.b3 by Th10;
A5: s1.b4=s.b4 by Th10;
A6: s1.b5=s.b5 by Th10;
A7: s2.f0 =Exec(i6, s1).f0 by SCMFSA6C:9
    .=s.f0+*(abs(s.b3),(s.f0)/.abs(s.b4)) by A2,A3,A4,Th9;
A8: s2.b4=Exec(i6, s1).b4 by SCMFSA6C:8
    .=s.b4 by A5,SCMFSA_2:73;
A9: s2.b5=Exec(i6, s1).b5 by SCMFSA6C:8
    .=s.b5 by A6,SCMFSA_2:73;
  set I=i4 ';' i6 ';' i7, J=Stop SCM+FSA;
  hereby
    assume s.b6 >0;
    hence IExec(if>0(b6,I,J),p,s).f0 = IExec(I,p,s).f0 by SCM_HALT:44
      .=Exec(i7, s2).f0 by SCMFSA6C:7
      .=s.f0+*(abs(s.b3),(s.f0)/.abs(s.b4)) +*(abs(s.b4),s.b5)
    by A7,A8,A9,Th9;
  end;
  assume s.b6 <= 0;
  hence IExec(if>0(b6,I,J),p,s).f0 = IExec(J,p,s).f0 by SCM_HALT:44
    .=s.f0 by Th12;
end;

Lm28:
 for p be Instruction-Sequence of SCM+FSA
 for s be State of SCM+FSA holds IExec(ifc,p,s).b3 = s.b3
proof
  let p be Instruction-Sequence of SCM+FSA;
  let s be State of SCM+FSA;
  set s1=Exec(i4, Initialized s), s2=IExec(i4 ';' i6,p,s);
A1: s1.b3=s.b3 by Th10;
A2: s2.b3=Exec(i6, s1).b3 by SCMFSA6C:8
    .=s.b3 by A1,SCMFSA_2:73;
  per cases;
  suppose s.b6 >0;
    hence IExec(ifc,p,s).b3 = IExec(i4 ';' i6 ';' i7,p,s).b3 by SCM_HALT:44
      .=Exec(i7, s2).b3 by SCMFSA6C:6
      .=s.b3 by A2,SCMFSA_2:73;
  end;
  suppose s.b6 <= 0;
    hence IExec(ifc,p,s).b3 = IExec(Stop SCM+FSA,p,s).b3 by SCM_HALT:44
      .=s.b3 by Th12;
  end;
end;

Lm29:
 for p be Instruction-Sequence of SCM+FSA
 for s be State of SCM+FSA st s.b3 <= len (s.f0) & s.b3 >= 2 holds
IExec(body2,p,s).b3=s.b3-1 &
s.f0, IExec(body2,p,s).f0 are_fiberwise_equipotent &
( s.f0.(s.b3)=IExec(body2,p,s).f0.(s.b3) or
s.f0.(s.b3)=IExec(body2,p,s).f0.(s.b3-1)) &
( s.f0.(s.b3)=IExec(body2,p,s).f0.(s.b3) or
s.f0.(s.b3-1)=IExec(body2,p,s).f0.(s.b3)) &
( s.f0.(s.b3)=IExec(body2,p,s).f0.(s.b3-1) or
s.f0.(s.b3-1)=IExec(body2,p,s).f0.(s.b3-1)) &
(for k be set st k<>(s.b3-1) & k<>s.b3 & k in dom (s.f0) holds
s.f0.k=IExec(body2,p,s).f0.k) &
ex x1,x2 be Integer st x1=IExec(body2,p,s).f0.(s.b3-1) &
x2=IExec(body2,p,s).f0.(s.b3) & x1 >= x2
proof
  let p be Instruction-Sequence of SCM+FSA;
  let s be State of SCM+FSA;
  assume that
A1: s.b3 <= len (s.f0) and
A2: s.b3 >= 2;
A3: s.b3-1 >= 2-1 by A2,XREAL_1:9;
  then
A4: abs((s.b3-1))=s.b3-1 by ABSVALUE:def 1;
A5: s.b3-1<=len (s.f0) by A1,XREAL_1:146,XXREAL_0:2;
A6: s.b3>= 1 by A2,XXREAL_0:2;
A7: abs(s.b3)=s.b3 by A2,ABSVALUE:def 1;
  reconsider k1=s.b3-1 as Element of NAT by A3,INT_1:3;
  reconsider k2=s.b3 as Element of NAT by A2,INT_1:3;
A8: k1 in dom (s.f0) by A3,A5,FINSEQ_3:25;
  reconsider n1=s.f0.k1 as Integer;
A9: k2 in dom (s.f0) by A1,A6,FINSEQ_3:25;
  reconsider n2=s.f0.k2 as Integer;
  set s0=Initialized s, s1=Exec(i1, s0), s2=IExec(i1 ';' i2,p,s),
  s3=IExec(i1 ';' i2 ';' i3,p,s), s4=IExec(i1 ';' i2 ';' i3 ';' i4,p,s),
  s5=IExec(i1 ';' i2 ';' i3 ';' i4 ';'i5,p,s), s6=IExec(body2,p,s);
A10: s1.b4=s0.b3 by SCMFSA_2:63
    .=s.b3 by SCMFSA6C:3;
A11: s1.f0=s0.f0 by SCMFSA_2:63
    .=s.f0 by SCMFSA6C:3;
A12: s1.b3=s.b3 by Th11;
A13: s1.a0=s0.a0 by SCMFSA_2:63
    .=1 by SCMFSA6A:38;
A14: s2.f0 =Exec(i2, s1).f0 by SCMFSA6C:9
    .=s.f0 by A11,SCMFSA_2:65;
A15: s2.b3 =Exec(i2, s1).b3 by SCMFSA6C:8
    .=s.b3-1 by A12,A13,SCMFSA_2:65;
A16: s2.b4=Exec(i2, s1).b4 by SCMFSA6C:8
    .=s.b3 by A10,Lm14,SCMFSA_2:65;
A17: s3.f0 = Exec(i3, s2).f0 by SCMFSA6C:7
    .=s.f0 by A14,SCMFSA_2:72;
A18: (s.f0)/.k1=n1 by A3,A5,FINSEQ_4:15;
A19: s3.b5=Exec(i3, s2).b5 by SCMFSA6C:6
    .=n1 by A4,A14,A15,A18,Th8;
A20: s3.b4=Exec(i3, s2).b4 by SCMFSA6C:6
    .=s.b3 by A16,Lm17,SCMFSA_2:72;
A21: s3.b3=Exec(i3, s2).b3 by SCMFSA6C:6
    .=s.b3-1 by A15,Lm15,SCMFSA_2:72;
A22: s4.f0 = Exec(i4, s3).f0 by SCMFSA6C:7
    .=s.f0 by A17,SCMFSA_2:72;
A23: (s.f0)/.k2=n2 by A1,A6,FINSEQ_4:15;
A24: s4.b6=Exec(i4, s3).b6 by SCMFSA6C:6
    .=n2 by A7,A17,A20,A23,Th8;
A25: s4.b3=Exec(i4, s3).b3 by SCMFSA6C:6
    .=s.b3-1 by A21,Lm16,SCMFSA_2:72;
A26: s4.b4=Exec(i4, s3).b4 by SCMFSA6C:6
    .=s.b3 by A20,Lm18,SCMFSA_2:72;
A27: s4.b5=Exec(i4, s3).b5 by SCMFSA6C:6
    .=s.f0.(s.b3-1) by A19,Lm19,SCMFSA_2:72;
A28: s5.f0=Exec(i5, s4).f0 by SCMFSA6C:7
    .=s.f0 by A22,SCMFSA_2:65;
A29: s5.b3=Exec(i5, s4).b3 by SCMFSA6C:6
    .=s.b3-1 by A25,Lm16,SCMFSA_2:65;
A30: s5.b4=Exec(i5, s4).b4 by SCMFSA6C:6
    .=s.b3 by A26,Lm18,SCMFSA_2:65;
A31: s5.b5=Exec(i5, s4).b5 by SCMFSA6C:6
    .=n1 by A27,Lm19,SCMFSA_2:65;
A32: s5.b6=Exec(i5, s4).b6 by SCMFSA6C:6
    .=n2- n1 by A24,A27,SCMFSA_2:65;
A33: s6.f0 = IExec(ifc,p,s5).f0 by SCMFSA6C:2;
  thus s6.b3 = IExec(ifc,p,s5).b3 by SCMFSA6C:1
    .=s.b3-1 by A29,Lm28;
  per cases;
  suppose
A34: s5.b6 >0;
    then
A35: s6.f0=s.f0+*(k1,n2) +*(k2,n1) by A4,A7,A23,A28,A29,A30,A31,A33,Lm27;
A36: dom (s.f0+*(k1,n2))=dom (s.f0) by FUNCT_7:30;
    then
A37: dom (s6.f0)=dom (s.f0) by A35,FUNCT_7:30;
A38: k2 in dom (s.f0+*(k1,n2)) by A1,A6,A36,FINSEQ_3:25;
A39: s6.f0.k2=s.f0.k1 by A9,A35,A36,FUNCT_7:31;
A40: now per cases;
      suppose k1=k2;
        hence s6.f0.k1=s.f0.k2;
      end;
      suppose k1<>k2;
        hence s6.f0.k1=(s.f0+*(k1,n2)).k1 by A35,FUNCT_7:32
          .=s.f0.k2 by A8,FUNCT_7:31;
      end;
    end;
A41: now
      let k be set;
      assume that
A42:  k<>k1 and
A43:  k<>k2
      and k in dom (s.f0);
      thus s6.f0.k= (s.f0+*(k1,n2)).k by A35,A43,FUNCT_7:32
        .= s.f0.k by A42,FUNCT_7:32;
    end;
    hence s.f0, s6.f0 are_fiberwise_equipotent by A8,A9,A37,A39,A40,RFINSEQ:28;
    thus s.f0.(s.b3)=IExec(body2,p,s).f0.(s.b3) or
    s.f0.(s.b3)=IExec(body2,p,s).f0.(s.b3-1) by A40;
    thus s.f0.(s.b3)=IExec(body2,p,s).f0.(s.b3) or
    s.f0.(s.b3-1)=IExec(body2,p,s).f0.(s.b3) by A35,A38,FUNCT_7:31;
    thus s.f0.(s.b3)=IExec(body2,p,s).f0.(s.b3-1) or
    s.f0.(s.b3-1)=IExec(body2,p,s).f0.(s.b3-1) by A40;
    thus for k be set st k<>(s.b3-1) & k<>s.b3 & k in dom (s.f0) holds
    s.f0.k=s6.f0.k by A41;
A44: n2-n1+n1 > 0+n1 by A32,A34,XREAL_1:6;
    take n2,n1;
    thus thesis by A9,A35,A36,A40,A44,FUNCT_7:31;
  end;
  suppose
A45: s5.b6 <=0;
    hence s.f0,s6.f0 are_fiberwise_equipotent by A28,A33,Lm27;
    thus s.f0.(s.b3)=IExec(body2,p,s).f0.(s.b3) or
    s.f0.(s.b3)=IExec(body2,p,s).f0.(s.b3-1) by A28,A33,A45,Lm27;
    thus s.f0.(s.b3)=IExec(body2,p,s).f0.(s.b3) or
    s.f0.(s.b3-1)=IExec(body2,p,s).f0.(s.b3) by A28,A33,A45,Lm27;
    thus s.f0.(s.b3)=IExec(body2,p,s).f0.(s.b3-1) or
    s.f0.(s.b3-1)=IExec(body2,p,s).f0.(s.b3-1) by A28,A33,A45,Lm27;
    thus for k be set st k<>(s.b3-1) & k<>s.b3 & k in dom (s.f0) holds
    s.f0.k=s6.f0.k by A28,A33,A45,Lm27;
A46: n2-n1+n1 <= 0+n1 by A32,A45,XREAL_1:6;
    take n1,n2;
    thus thesis by A28,A33,A45,A46,Lm27;
  end;
end;

Lm30:
 for p be Instruction-Sequence of SCM+FSA
 for s be State of SCM+FSA st s.b2>=0 & s.b2<s.b3 & s.b3 <= len (s.f0)
holds ex k be Element of NAT st k<=s.b3 & k>=s.b3-s.b2 &
IExec(T2,p,s).f0.k = s.f0.(s.b3)
proof
  let p be Instruction-Sequence of SCM+FSA;
  let s be State of SCM+FSA;
  assume that
A1: s.b2>=0 and
A2: s.b2<s.b3 and
A3: s.b3 <= len (s.f0);
  defpred P[Nat] means
  for t be State of SCM+FSA,q st t.b2=$1 & t.b2<t.b3 & t.b3 <= len (t.f0)
  holds (for m be Element of NAT st m>t.b3 & m <= len (t.f0) holds
  t.f0.m=IExec(T2,q,t).f0.m) & ex n be Element of NAT st n<=t.b3 &
  n>=t.b3-$1 & IExec(T2,q,t).f0.n = t.f0.(t.b3);
A4: P[ 0]
  proof
    let t be State of SCM+FSA,q;
    assume that
A5: t.b2=0 and
A6: t.b2<t.b3
    and t.b3 <= len (t.f0);
    set If0=IExec(T2,q,t).f0;
    thus for m be Element of NAT st m>t.b3 & m <= len (t.f0) holds
    t.f0.m=If0.m by A5,SCM_HALT:67;
    reconsider n=t.b3 as Element of NAT by A5,A6,INT_1:3;
    take n;
    thus n<=t.b3;
    thus n>=t.b3-0;
    thus thesis by A5,SCM_HALT:67;
  end;
  set sb2=SubFrom(b2,a0);
A7: now
    let k be Element of NAT;
    assume
A8: P[k];
    now
      let t be State of SCM+FSA,q;
      assume that
A9:   t.b2=k+1 and
A10:  t.b2<t.b3 and
A11:  t.b3 <= len (t.f0);
      set t1=IExec(body2 ';'sb2,q,t), IB=IExec(body2,q,t), t2=IExec(T2,q,t1);
A12:  t1.b2= Exec(sb2, IB).b2 by SCM_HALT:23
        .=IB.b2-IB.a0 by SCMFSA_2:65
        .=IB.b2-1 by SCM_HALT:9
        .=(Initialized t).b2-1 by Lm22,SCM_HALT:53
        .=t.b2-1 by SCMFSA6C:3;
A13:  2 <= k+2 by NAT_1:11;
      k+1+1 <= t.b3 by A9,A10,INT_1:7;
      then
A14:  2 <= t.b3 by A13,XXREAL_0:2;
A15:  t1.b3=Exec(sb2, IB).b3 by SCM_HALT:23
        .=IB.b3 by Lm10,SCMFSA_2:65
        .=t.b3-1 by A11,A14,Lm29;
A16:  t.b2-1 < t.b3-1 by A10,XREAL_1:9;
A17:  t1.b2 < t1.b3 by A10,A12,A15,XREAL_1:9;
A18:  t1.f0= Exec(sb2, IB).f0 by SCM_HALT:24
        .=IB.f0 by SCMFSA_2:65;
A19:  t.f0,IB.f0 are_fiberwise_equipotent by A11,A14,Lm29;
      then
A20:  len (t.f0) = len (t1.f0) by A18,RFINSEQ:3;
      then
A21:  t1.b3 <= len (t1.f0) by A11,A15,XREAL_1:146,XXREAL_0:2;
A22:  IExec(T2,q,t).f0=t2.f0 by A9,Lm22,SCM_HALT:69;
A23:  IB.f0 =Exec(sb2, IB).f0 by SCMFSA_2:65
        .=t1.f0 by SCM_HALT:24;
      thus for m be Element of NAT st m>t.b3 & m <= len (t.f0) holds
      t.f0.m=IExec(T2,q,t).f0.m
      proof
        let m be Element of NAT;
        assume that
A24:    m>t.b3 and
A25:    m <= len (t.f0);
A26:    t.b3>t.b3-1 by XREAL_1:146;
A27:    m > t1.b3 by A15,A24,XREAL_1:146,XXREAL_0:2;
A28:    m <= len (t1.f0) by A18,A19,A25,RFINSEQ:3;
        m>=2 by A14,A24,XXREAL_0:2;
        then m>=1 by XXREAL_0:2;
        then m in dom (t.f0) by A25,FINSEQ_3:25;
        hence t.f0.m=t1.f0.m by A11,A14,A23,A24,A26,Lm29
          .=IExec(T2,q,t).f0.m by A8,A9,A12,A17,A21,A22,A27,A28;
      end;
      hereby
        reconsider n=t.b3 as Element of NAT by A9,A10,INT_1:3;
        per cases by A11,A14,Lm29;
        suppose
A29:      t.f0.(t.b3)=IExec(body2,q,t).f0.(t.b3);
          take n;
          thus n<=t.b3;
          n<=n+(k+1) by NAT_1:11;
          hence n>=t.b3-(k+1) by XREAL_1:20;
          thus IExec(T2,q,t).f0.n=t.f0.(t.b3)
          by A8,A9,A11,A12,A15,A16,A20,A21,A22,A23,A29,XREAL_1:146;
        end;
        suppose
A30:      t.f0.(t.b3)=IExec(body2,q,t).f0.(t.b3-1);
          consider m be Element of NAT such that
A31:      m<=t1.b3 and
A32:      m>=t1.b3-k and
A33:      IExec(T2,q,t1).f0.m = t1.f0.(t1.b3) by A8,A9,A12,A17,A21;
          take m;
          thus m<=t.b3 by A15,A31,XREAL_1:146,XXREAL_0:2;
          thus m>=t.b3-(k+1) by A15,A32;
          thus IExec(T2,q,t).f0.m =t.f0.(t.b3)
          by A9,A15,A23,A30,A33,Lm22,SCM_HALT:69;
        end;
      end;
    end;
    hence P[k+1];
  end;
A34: for k be Element of NAT holds P[k] from NAT_1:sch 1(A4,A7);
  reconsider i=s.b2 as Element of NAT by A1,INT_1:3;
  P[i] by A34;
  hence thesis by A2,A3;
end;

Lm31: for k be Element of NAT holds
for t be State of SCM+FSA,q st k=t.b2 & k< t.b3 & t.b3 <= len (t.f0) holds
t.f0, IExec(T2,q,t).f0 are_fiberwise_equipotent & (for m be Element of NAT
st m <(t.b3-k) & m>=1 or (m>t.b3 & m in dom (t.f0)) holds
t.f0.m=IExec(T2,q,t).f0.m) &
(for m be Element of NAT st m >= (t.b3-k) & m<=t.b3 holds
(ex x1,x2 be Integer st
x1 =IExec(T2,q,t).f0.(t.b3-k) & x2=IExec(T2,q,t).f0.m & x1 >= x2)) &
for i be Element of NAT st i>=t.b3-k & i<=t.b3 holds
ex n be Element of NAT st n>=t.b3-k & n<=t.b3 & IExec(T2,q,t).f0.i=t.f0.n
proof
  defpred P[Nat] means
  for t be State of SCM+FSA st $1=t.b2 & $1 < t.b3 & t.b3 <= len (t.f0) holds
  (t.f0, IExec(T2,q,t).f0 are_fiberwise_equipotent) & (for m be Element of NAT
  st m <(t.b3-$1) & m>=1 or (m>t.b3 & m in dom (t.f0)) holds
  t.f0.m=IExec(T2,q,t).f0.m) &
  (for m be Element of NAT st m >= (t.b3-$1) & m<=t.b3 holds
  (ex x1,x2 be Integer st
  x1 =IExec(T2,q,t).f0.(t.b3-$1) & x2=IExec(T2,q,t).f0.m & x1 >= x2)) &
  for i be Element of NAT st i>=t.b3-$1 & i<=t.b3 holds
  ex n be Element of NAT st n>=t.b3-$1 & n<=t.b3 & IExec(T2,q,t).f0.i=t.f0.n;
  now
    let t be State of SCM+FSA,q;
    assume that
A1: 0=t.b2
    and 0 < t.b3
    and t.b3 <= len (t.f0);
    set If0=IExec(T2,q,t).f0;
    thus t.f0, If0 are_fiberwise_equipotent by A1,SCM_HALT:67;
    thus for m be Element of NAT
    st m < (t.b3-0) & m>=1 or m>t.b3 & m in dom (t.f0)
    holds t.f0.m=IExec(T2,q,t).f0.m by A1,SCM_HALT:67;
    hereby
      let m be Element of NAT;
      assume that
A2:   m >= (t.b3-0) and
A3:   m<=t.b3;
A4:   m=t.b3 by A2,A3,XXREAL_0:1;
      reconsider n1=t.f0.m as Integer;
      take x1=n1,x2=n1;
      thus x1=IExec(T2,q,t).f0.(t.b3-0) by A1,A4,SCM_HALT:67;
      thus x2=If0.m by A1,SCM_HALT:67;
      thus x1 >= x2;
    end;
    let i be Element of NAT;
    assume that
A5: i>=t.b3-0 and
A6: i<=t.b3;
    take n=i;
    thus n>=t.b3-0 & n<=t.b3 by A5,A6;
    thus IExec(T2,q,t).f0.i=t.f0.n by A1,SCM_HALT:67;
  end;
  then
A7: P[ 0];
  set sb2=SubFrom(b2,a0);
A8: now
    let k be Element of NAT;
    assume
A9: P[k];
    now
      let t be State of SCM+FSA,q;
      set t1=IExec(body2 ';'sb2,q,t), IB=IExec(body2,q,t), t2=IExec(T2,q,t1);
      assume that
A10:  k+1=t.b2 and
A11:  k+1 < t.b3 and
A12:  t.b3 <= len (t.f0);
A13:  t1.b2= Exec(sb2, IB).b2 by SCM_HALT:23
        .=IB.b2-IB.a0 by SCMFSA_2:65
        .=IB.b2-1 by SCM_HALT:9
        .=(Initialized t).b2-1 by Lm22,SCM_HALT:53
        .=k+1-1 by A10,SCMFSA6C:3
        .=k;
A14:  2 <= k+2 by NAT_1:11;
      k+1+1 <= t.b3 by A11,INT_1:7;
      then
A15:  2 <= t.b3 by A14,XXREAL_0:2;
A16:  t1.b3=Exec(sb2, IB).b3 by SCM_HALT:23
        .=IB.b3 by Lm10,SCMFSA_2:65
        .=t.b3-1 by A12,A15,Lm29;
A17:  k+1-1 < t.b3-1 by A11,XREAL_1:9;
A18:  t1.f0= Exec(sb2, IB).f0 by SCM_HALT:24
        .=IB.f0 by SCMFSA_2:65;
A19:  t.f0,IB.f0 are_fiberwise_equipotent by A12,A15,Lm29;
      then
A20:  len (t.f0) = len (t1.f0) by A18,RFINSEQ:3;
A21:  t.b3 <= len (t1.f0) by A12,A18,A19,RFINSEQ:3;
A22:  t1.b3 <= len (t1.f0) by A12,A16,A20,XREAL_1:146,XXREAL_0:2;
A23:  t.b3=t1.b3+1 by A16;
A24:  t1.f0, t2.f0 are_fiberwise_equipotent by A9,A13,A16,A17,A22;
A25:  IExec(T2,q,t).f0=t2.f0 by A10,Lm22,SCM_HALT:69;
      t1.f0, IExec(T2,q,t).f0 are_fiberwise_equipotent by A10,A24,Lm22,
SCM_HALT:69;
      hence t.f0,IExec(T2,q,t).f0 are_fiberwise_equipotent
       by A18,A19,CLASSES1:76
;
A26:  t.b3-(k+1)=t1.b3-k by A16;
      consider n1,n2 be Integer such that
A27:  n1=IB.f0.(t.b3-1) and
A28:  n2=IB.f0.(t.b3) and
A29:  n1 >= n2 by A12,A15,Lm29;
A30:  IB.f0 =Exec(sb2, IB).f0 by SCMFSA_2:65
        .=t1.f0 by SCM_HALT:24;
A31:  t.b3 is Element of NAT by A11,INT_1:3;
A32:  t.b3 >= 1 by A15,XXREAL_0:2;
      then
A33:  t.b3 in dom (t1.f0) by A12,A20,A31,FINSEQ_3:25;
      hereby
        let m be Element of NAT;
        assume that
A34:    m <(t.b3-(k+1)) & m>=1 or m>t.b3 & m in dom (t.f0);
        per cases by A34;
        suppose
A35:      m < (t.b3-(k+1)) & m>=1;
A36:      t.b3-(k+1)+(k+1)=t.b3;
A37:      m+(k+1) < t.b3-(k+1)+(k+1) by A35,XREAL_1:6;
A38:      m+(k+1) < t.b3 by A35,A36,XREAL_1:6;
          m<=m+(k+1) by NAT_1:11;
          then m<=t.b3 by A37,XXREAL_0:2;
          then m<=len(t1.f0) by A12,A20,XXREAL_0:2;
          then
A39:      m in dom (t.f0) by A20,A35,FINSEQ_3:25;
A40:      m<>t.b3 by A35,A36,XREAL_1:29;
          m<>t.b3-1
          proof
            assume
A41:        m=t.b3-1;
            m+(k+1)=m+1+k;
            hence contradiction by A38,A41,NAT_1:11;
          end;
          hence t.f0.m=t1.f0.m by A12,A15,A30,A39,A40,Lm29
            .=IExec(T2,q,t).f0.m by A9,A13,A17,A22,A25,A26,A35;
        end;
        suppose
A42:      m>t.b3 & m in dom (t.f0);
          then
A43:      m in dom (t1.f0) by A18,A19,RFINSEQ:3;
A44:      t.b3>t.b3-1 by XREAL_1:146;
A45:      m >t1.b3 by A16,A42,XREAL_1:146,XXREAL_0:2;
          thus t.f0.m=t1.f0.m by A12,A15,A30,A42,A44,Lm29
            .=IExec(T2,q,t).f0.m by A9,A13,A16,A17,A22,A25,A43,A45;
        end;
      end;
      hereby
        let m be Element of NAT;
        assume that
A46:    m >= (t.b3-(k+1)) and
A47:    m<=t.b3;
        consider nn be Element of NAT such that
A48:    nn<=t1.b3 and
A49:    nn>=t1.b3-t1.b2 and
A50:    t2.f0.nn = t1.f0.(t1.b3)
        by A13,A16,A17,A22,Lm30;
        consider y1,y2 be Integer such that
A51:    y1 =t2.f0.(t1.b3-k) and
A52:    y2=t2.f0.nn and
A53:    y1 >= y2 by A9,A13,A16,A17,A22,A48,A49;
        per cases;
        suppose
A54:      m>t1.b3;
          then m>=t1.b3+1 by INT_1:7;
          then
A55:      m=t.b3 by A16,A47,XXREAL_0:1;
          take y1,n2;
          thus y1=IExec(T2,q,t).f0.(t.b3-(k+1))
           by A10,A16,A51,Lm22,SCM_HALT:69;
          thus n2=IExec(T2,q,t).f0.m by A9,A13,A16,A17,A22,A25,A28,A30,A33,A54
,A55;
          thus y1 >= n2 by A16,A27,A29,A30,A50,A52,A53,XXREAL_0:2;
        end;
        suppose m<=t1.b3;
          then consider y1,y2 be Integer such that
A56:      y1 =t2.f0.(t1.b3-k) and
A57:      y2=t2.f0.m and
A58:      y1 >= y2
          by A9,A13,A16,A17,A22,A46;
          take y1,y2;
          thus y1=IExec(T2,q,t).f0.(t.b3-(k+1))
           by A10,A16,A56,Lm22,SCM_HALT:69;
          thus y2=IExec(T2,q,t).f0.m by A10,A57,Lm22,SCM_HALT:69;
          thus y1>=y2 by A58;
        end;
      end;
      thus for i be Element of NAT st i>=t.b3-(k+1) & i<=t.b3 holds
      ex n be Element of NAT st n>=t.b3-(k+1) & n<=t.b3 &
      IExec(T2,q,t).f0.i=t.f0.n
      proof
        let i be Element of NAT;
        assume that
A59:    i>=t.b3-(k+1) and
A60:    i<=t.b3;
        per cases;
        suppose
A61:      i=t.b3;
          then
A62:      i>t1.b3 by A23,XREAL_1:29;
A63:      i in dom (t1.f0) by A21,A32,A61,FINSEQ_3:25;
            per cases by A12,A15,Lm29;
            suppose
A64:          t.f0.(t.b3)=IExec(body2,q,t).f0.(t.b3);
              reconsider n=t.b3 as Element of NAT by A11,INT_1:3;
              take n;
              thus n>=t.b3-(k+1) & n<=t.b3 by A59,A61;
              thus IExec(T2,q,t).f0.i=t.f0.n by A9,A13,A16,A17,A22,A25,A30,A61
,A62,A63,A64;
            end;
            suppose
A65:          t.f0.(t.b3-1)=IExec(body2,q,t).f0.(t.b3);
              t.b3-1>=1-1 by A32,XREAL_1:9;
              then reconsider n=t.b3-1 as Element of NAT by INT_1:3;
              take n;
              n<=n+k by NAT_1:11;
              hence n>=t.b3-(k+1) by A26,XREAL_1:20;
              thus n<=t.b3 by XREAL_1:146;
              thus IExec(T2,q,t).f0.i=t.f0.n by A9,A13,A16,A17,A22,A25,A30,A61
,A62,A63,A65;
            end;
        end;
        suppose i<>t.b3;
          then i < t.b3 by A60,XXREAL_0:1;
          then i+1 <= t.b3 by INT_1:7;
          then i<=t1.b3 by A16,XREAL_1:19;
          then consider n be Element of NAT such that
A66:      n>=t1.b3-k and
A67:      n<=t1.b3 and
A68:      t2.f0.i=t1.f0.n by A9,A13,A16,A17,A22,A59;
          thus ex n be Element of NAT st n>=t.b3-(k+1) & n<=t.b3 &
          IExec(T2,q,t).f0.i=t.f0.n
          proof
            per cases;
            suppose
A69:          n=t1.b3;
                per cases by A12,A15,Lm29;
                suppose
A70:              t.f0.(t.b3)=IExec(body2,q,t).f0.(t.b3-1);
                  reconsider m=t.b3 as Element of NAT by A11,INT_1:3;
                  take m;
                  m <= m +(k+1) by NAT_1:11;
                  hence m >= t.b3-(k+1) by XREAL_1:20;
                  thus m <= t.b3;
                  thus IExec(T2,q,t).f0.i=t.f0.m
                   by A10,A16,A30,A68,A69,A70,Lm22,SCM_HALT:69;
                end;
                suppose
A71:              t.f0.(t.b3-1)=IExec(body2,q,t).f0.(t.b3-1);
                  take n;
                  thus n>=t.b3-(k+1) by A16,A66;
                  thus n<=t.b3 by A16,A69,XREAL_1:146;
                  thus IExec(T2,q,t).f0.i=t.f0.n
                   by A10,A16,A30,A68,A69,A71,Lm22,SCM_HALT:69;
                end;
            end;
            suppose
A72:          n<>t1.b3;
A73:          t1.b3 < t.b3 by A16,XREAL_1:146;
A74:          n<t.b3 by A16,A67,XREAL_1:146,XXREAL_0:2;
              k-k < t1.b3-k by A16,A17,XREAL_1:9;
              then
A75:          n>=0+1 by A66,INT_1:7;
              n<= len (t1.f0) by A12,A20,A74,XXREAL_0:2;
              then
A76:          n in dom (t.f0) by A20,A75,FINSEQ_3:25;
              take n;
              thus n>=t.b3-(k+1) by A16,A66;
              thus n<=t.b3 by A16,A67,XREAL_1:146,XXREAL_0:2;
              thus thesis by A12,A15,A16,A25,A30,A67,A68,A72,A73,A76,Lm29;
            end;
          end;
        end;
      end;
    end;
    hence P[k + 1];
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A7,A8);
  hence thesis;
end;

Lm32:
 for p be Instruction-Sequence of SCM+FSA
 for s be State of SCM+FSA holds IExec(Sb,p,s).b2=s.b1-1 &
IExec(Sb,p,s).b3=len (s.f0) & IExec(Sb,p,s).f0=s.f0
proof
  let p be Instruction-Sequence of SCM+FSA;
  let s be State of SCM+FSA;
  set s0=Initialized s, s1=Exec(j1,s0), s2=IExec(j1 ';'j2,p,s),
  s3=IExec(j1 ';' j2 ';' j3,p,s);
A1: s1.b2=s0.b1 by SCMFSA_2:63
    .=s.b1 by SCMFSA6C:3;
A2: s1.f0=s0.f0 by SCMFSA_2:63
    .=s.f0 by SCMFSA6C:3;
A3: s1.a0=s0.a0 by SCMFSA_2:63
    .=1 by SCMFSA6A:38;
A4: s2.f0 =Exec(j2, s1).f0 by SCMFSA6C:9
    .=s.f0 by A2,SCMFSA_2:65;
A5: s2.b2 =Exec(j2, s1).b2 by SCMFSA6C:8
    .=s.b1-1 by A1,A3,SCMFSA_2:65;
  thus s3.b2 = Exec(j3, s2).b2 by SCMFSA6C:6
    .=s.b1-1 by A5,Lm10,SCMFSA_2:74;
  thus s3.b3 = Exec(j3, s2).b3 by SCMFSA6C:6
    .=len(s.f0) by A4,SCMFSA_2:74;
  thus s3.f0 = Exec(j3, s2).f0 by SCMFSA6C:7
    .=s.f0 by A4,SCMFSA_2:74;
end;

Lm33:
 for p be Instruction-Sequence of SCM+FSA
 for s be State of SCM+FSA st s.b1=len (s.f0) holds
s.f0, IExec(T1,p,s).f0 are_fiberwise_equipotent &
for i,j be Element of NAT st i>=1 & j<=len (s.f0) & i<j
for x1,x2 be Integer st x1 =IExec(T1,p,s).f0.i &
x2=IExec(T1,p,s).f0.j holds x1 >= x2
proof
  let p be Instruction-Sequence of SCM+FSA;
  let s be State of SCM+FSA;
  assume
A1: s.b1=len (s.f0);
  per cases;
  suppose
A2: len (s.f0)=0;
    hence s.f0, IExec(T1,p,s).f0 are_fiberwise_equipotent
     by A1,Lm23,SCM_HALT:67;
    thus thesis by A2;
  end;
  suppose
A3: len (s.f0)<>0;
    defpred P[Nat] means
    for t be State of SCM+FSA,q st t.b1=$1+1 & t.b1<=len (t.f0) holds
    (t.f0, IExec(T1,q,t).f0 are_fiberwise_equipotent) &
    (for i,j be Element of NAT st i>=len(t.f0)-$1 & j<=len (t.f0) & i<j
    for x1,x2 be Integer st x1 =IExec(T1,q,t).f0.i & x2=IExec(T1,q,t).f0.j
    holds x1 >= x2) & (for i be Element of NAT st i<len(t.f0)-$1 & i>=1
    holds IExec(T1,q,t).f0.i=t.f0.i) &
    (for i be Element of NAT st i>=len(t.f0)-$1 & i<=len (t.f0) holds
    ex n be Element of NAT st n>=len(t.f0)-$1 & n<=len (t.f0) &
    IExec(T1,q,t).f0.i=t.f0.n);
    set B11=SubFrom(b1,a0);
A4: P[ 0]
    proof
      let t be State of SCM+FSA,q;
      assume that
A5:   t.b1=0+1
      and t.b1 <= len (t.f0);
      set IB=IExec(body1 ';' B11,q,t);
A6:   IB.b1=1-1 by A5,Lm23,Lm25,SCM_HALT:66;
A7:   IExec(Sb,q,t).b2=1-1 by A5,Lm32;
A8:   IExec(T1,q,t).f0=IExec(T1,q,IB).f0 by A5,Lm23,Lm25,SCM_HALT:69
        .=IB.f0 by A6,Lm23,SCM_HALT:67
        .=Exec(B11,IExec(body1,q,t)).f0 by Lm23,SCM_HALT:24
        .=IExec(body1,q,t).f0 by SCMFSA_2:65
        .=IExec(T2,q,IExec(Sb,q,t)).f0 by Lm23,SCM_HALT:21
        .=IExec(Sb,q,t).f0 by A7,SCM_HALT:67
        .=t.f0 by Lm32;
      hence t.f0, IExec(T1,q,t).f0 are_fiberwise_equipotent;
      thus
      for i,j be Element of NAT st i>=len(t.f0)-0 & j<=len (t.f0) & i<j
      for x1,x2 be Integer st x1 =IExec(T1,q,t).f0.i &
      x2=IExec(T1,q,t).f0.j holds x1 >= x2 by XXREAL_0:2;
      thus for i be Element of NAT st i<len(t.f0)-0 & i>=1 holds
      IExec(T1,q,t).f0.i=t.f0.i by A8;
      let i be Element of NAT;
      assume that
A9:   i>=len(t.f0)-0 and
A10:  i<=len (t.f0);
      take n=i;
      thus n>=len(t.f0)-0 & n<=len (t.f0) by A9,A10;
      thus thesis by A8;
    end;
A11: now
      let k be Element of NAT;
      assume
A12:  P[k];
      now
        let t be State of SCM+FSA,q;
        set t1=IExec(body1 ';'B11,q,t), IB=IExec(body1,q,t), t2=IExec(T1,q,t1);
        assume that
A13:    t.b1=(k+1)+1 and
A14:    t.b1<=len (t.f0);
A15:    t1.b1= Exec(B11, IB).b1 by Lm23,SCM_HALT:23
          .=IB.b1-IB.a0 by SCMFSA_2:65
          .=IB.b1-1 by Lm23,SCM_HALT:9
          .=(Initialized t).b1-1 by Lm23,Lm25,SCM_HALT:53
          .=(k+1)+1-1 by A13,SCMFSA6C:3
          .=k+1;
        then t1.b1 < t.b1 by A13,XREAL_1:29;
        then
A16:    t1.b1 <= len (t.f0) by A14,XXREAL_0:2;
        set Ts=IExec(Sb,q,t);
A17:    Ts.b2=(k+1)+1-1 by A13,Lm32
          .=k+1;
A18:    Ts.b3=len (t.f0) by Lm32;
        then
A19:    Ts.b3=len (Ts.f0) by Lm32;
A20:    k+1 < (k+1)+1 by XREAL_1:29;
A21:    k+1 < t.b1 by A13,XREAL_1:29;
A22:    k+1 < len (t.f0) by A13,A14,A20,XXREAL_0:2;
A23:    k+1 < Ts.b3 by A14,A18,A21,XXREAL_0:2;

A24:    Ts
.f0, IExec(T2,q,Ts).f0 are_fiberwise_equipotent by A17,A18,A19,A22,Lm31;
A25:    Ts.f0=t.f0 by Lm32;
A26:    t1.f0= Exec(B11,IB).f0 by Lm23,SCM_HALT:24
          .=IB.f0 by SCMFSA_2:65
          .=IExec(T2,q,Ts).f0 by Lm23,SCM_HALT:21;
        then
A27:    t.f0,t1.f0 are_fiberwise_equipotent by A17,A18,A23,A25,Lm31;
A28:    len (t.f0) = len (t1.f0) by A24,A25,A26,RFINSEQ:3;
A29:    t1.b1 <= len (t1.f0) by A16,A27,RFINSEQ:3;
A30:    t1.f0, IExec(T1,q,t1).f0 are_fiberwise_equipotent by A12,A15,A16,A28;
A31:    IExec(T1,q,t).f0=t2.f0 by A13,Lm23,Lm25,SCM_HALT:69;
        hence t.f0,IExec(T1,q,t).f0 are_fiberwise_equipotent
        by A27,A30,CLASSES1:76;
        set lk=len(t.f0)-(k+1);
A32:    lk+1=len (t1.f0)-k by A28;
        thus for i,j be Element of NAT
        st i>=len(t.f0)-(k+1) & j<=len (t.f0) & i<j
        for x1,x2 be Integer st x1 =IExec(T1,q,t).f0.i &
        x2=IExec(T1,q,t).f0.j holds x1 >= x2
        proof
          let i,j be Element of NAT;
          assume that
A33:      i>=lk and
A34:      j<=len (t.f0) and
A35:      i<j;
          j > lk by A33,A35,XXREAL_0:2;
          then j >= len (t1.f0)-k by A32,INT_1:7;
          then consider n be Element of NAT such that
A36:      n>=len(t1.f0)-k and
A37:      n<=len (t1.f0) and
A38:      IExec(T1,q,t1).f0.j=t1.f0.n by A12,A15,A16,A28,A34;
          lk < lk +1 by XREAL_1:29;
          then
A39:      n >= Ts.b3-(k+1) by A18,A28,A36,XXREAL_0:2;
A40:      n <= Ts.b3 by A28,A37,Lm32;
          hereby
            let x1,x2 be Integer;
            assume that
A41:        x1 =IExec(T1,q,t).f0.i and
A42:        x2=IExec(T1,q,t).f0.j;
            per cases;
            suppose
A43:          i=lk;

A44:          ex y1,y2 be Integer st ( y1 =IExec(T2,q,Ts).f0.(Ts.b3-(k+1)))
              &( y2=IExec(T2,q,Ts).f0.n)&( y1 >= y2)
               by A17,A19,A23,A39,A40,Lm31;
A45:          i<len(t1.f0)-k by A32,A43,XREAL_1:29;
A46:          1<=i by A13,A14,A43,XREAL_1:19;
              i=Ts.b3-(k+1) by A43,Lm32;
              hence
              x1 >= x2 by A12,A15,A16,A26,A28,A31,A38,A41,A42,A44,A45,A46;
            end;
            suppose i<>lk;
              then i>lk by A33,XXREAL_0:1;
              then i>=len (t1.f0)-k by A32,INT_1:7;
              hence x1 >= x2 by A12,A15,A16,A28,A31,A34,A35,A41,A42;
            end;
          end;
        end;
        thus for i be Element of NAT st i<len(t.f0)-(k+1) & i>=1 holds
        IExec(T1,q,t).f0.i=t.f0.i
        proof
          let i be Element of NAT;
          assume that
A47:      i<lk and
A48:      i>=1;
          lk < lk+1 by XREAL_1:29;
          then i < len (t1.f0)-k by A28,A47,XXREAL_0:2;
          hence IExec(T1,q,t).f0.i=t1.f0.i by A12,A15,A29,A31,A48
            .=t.f0.i by A17,A18,A23,A25,A26,A47,A48,Lm31;
        end;
        thus for i be Element of NAT
        st i>=len(t.f0)-(k+1) & i<=len (t.f0) holds
        ex n be Element of NAT st n>=len(t.f0)-(k+1) & n<=len (t.f0) &
        IExec(T1,q,t).f0.i=t.f0.n
        proof
          let i be Element of NAT;
          assume that
A49:      i>=len(t.f0)-(k+1) and
A50:      i<=len (t.f0);
          per cases;
          suppose
A51:        i=lk;
            then
A52:        i < len(t1.f0)-k by A32,XREAL_1:29;
A53:        i >= 1 by A13,A14,A51,XREAL_1:19;
            consider n be Element of NAT such that
A54:        n>=Ts.b3-(k+1) and
A55:        n<=Ts.b3 and
A56:        IExec(T2,q,Ts).f0.i=Ts.f0.n
            by A17,A18,A19,A22,A49,A50,Lm31;
            take n;
            thus n>=len(t.f0)-(k+1) by A54,Lm32;
            thus n<=len(t.f0) by A55,Lm32;
            thus thesis by A12,A15,A25,A26,A29,A31,A52,A53,A56;
          end;
          suppose i<>lk;
            then i >lk by A49,XXREAL_0:1;
            then i >= len (t1.f0)-k by A32,INT_1:7;
            then consider m be Element of NAT such that
A57:        m>=len(t1.f0)-k and
A58:        m<=len (t1.f0) and
A59:        IExec(T1,q,t1).f0.i=t1.f0.m
            by A12,A15,A16,A28,A50;
            lk+1 > lk by XREAL_1:29;
            then m>Ts.b3-(k+1) by A18,A28,A57,XXREAL_0:2;
            then consider n be Element of NAT such that
A60:        n>=Ts.b3-(k+1) and
A61:        n<=Ts.b3 and
A62:        IExec(T2,q,Ts).f0.m=Ts.f0.n
            by A17,A18,A19,A22,A28,A58,Lm31;
            take n;
            thus n>=len(t.f0)-(k+1) by A60,Lm32;
            thus n<=len(t.f0) by A61,Lm32;
            thus thesis by A26,A31,A59,A62,Lm32;
          end;
        end;
      end;
      hence P[k+1];
    end;
A63: for k be Element of NAT holds P[k] from NAT_1:sch 1(A4,A11);
    s.b1>=1+0 by A1,A3,INT_1:7;
    then reconsider m=s.b1-1 as Element of NAT by INT_1:5;
A64: m+1=s.b1;
    hence s.f0, IExec(T1,p,s).f0 are_fiberwise_equipotent by A1,A63;
    len (s.f0)-m=1 by A1;
    hence thesis by A63,A64;
  end;
end;

theorem Th65:
  for p be Instruction-Sequence of SCM+FSA
  for s be State of SCM+FSA holds
  s.(fsloc 0), IExec(bubble-sort (fsloc 0),p,s).(fsloc 0)
  are_fiberwise_equipotent &
  for i,j be Element of NAT st i>=1 & j<=len (s.(fsloc 0)) & i<j
  for x1,x2 be Integer st x1 =IExec(bubble-sort (fsloc 0),p,s).(fsloc 0).i &
  x2=IExec(bubble-sort (fsloc 0),p,s).(fsloc 0).j holds x1 >= x2
proof
  let p be Instruction-Sequence of SCM+FSA;
  let s be State of SCM+FSA;
  set W27=w2 ';' w3 ';' w4 ';' w5 ';' w6 ';' w7, s0=Initialized s,
  s1=Exec(w2, s0), s2=IExec(w2 ';' w3,p,s), s3=IExec(w2 ';' w3 ';' w4,p,s),
  s4=IExec(w2 ';' w3 ';' w4 ';' w5,p,s),
  s5=IExec(w2 ';' w3 ';' w4 ';' w5 ';' w6,p,s), s6=IExec(W27,p,s);
A1: s5.f0 =Exec(w6, s4).f0 by SCMFSA6C:7
    .=s4.f0 by SCMFSA_2:63
    .=Exec(w5, s3).f0 by SCMFSA6C:7
    .=s3.f0 by SCMFSA_2:63
    .=Exec(w4, s2).f0 by SCMFSA6C:7
    .=s2.f0 by SCMFSA_2:63
    .=Exec(w3, s1).f0 by SCMFSA6C:9
    .=s1.f0 by SCMFSA_2:63
    .=s0.f0 by SCMFSA_2:63
    .=s.f0 by SCMFSA6C:3;
A2: s6.f0 =Exec(w7, s5).f0 by SCMFSA6C:7
    .=s.f0 by A1,SCMFSA_2:74;
A3: s6.b1=Exec(w7, s5).b1 by SCMFSA6C:6
    .=len (s6.f0) by A1,A2,SCMFSA_2:74;
A4: IExec(bubble-sort f0,p,s).f0=IExec(T1,p,s6).f0 by Lm26,SCM_HALT:21;
  hence s.f0, IExec(bubble-sort f0,p,s).f0 are_fiberwise_equipotent
   by A2,A3,Lm33
;
  let i,j be Element of NAT;
  assume that
A5: i>=1 and
A6: j<=len (s.f0) and
A7: i<j;
  thus thesis by A2,A3,A4,A5,A6,A7,Lm33;
end;

theorem Th66:
  for i being Element of NAT, s being State of SCM+FSA,
  P being Instruction-Sequence of SCM+FSA
   st Bubble-Sort-Algorithm c= P
  for w being FinSequence of INT
  st (Initialized ((fsloc 0) .--> w)) c= s
  holds IC Comput(P,s,i) in dom Bubble-Sort-Algorithm
proof
  set Ba=Bubble-Sort-Algorithm,
     Ib=((intloc 0) .--> 1) +* Start-At(0,SCM+FSA);
  let i be Element of NAT, s be State of SCM+FSA,
  P be Instruction-Sequence of SCM+FSA such that
A1:  Bubble-Sort-Algorithm c= P;
  let w be FinSequence of INT;
  set x = (fsloc 0) .--> w;
  assume
A2: (Initialized x) c= s;
  set BSA = Bubble-Sort-Algorithm;
   Initialized x = x +* Initialize ((intloc 0) .--> 1) by SCMFSA6A:def 3;
   then Initialize ((intloc 0) .--> 1) c= Initialized x by FUNCT_4:25;
   then Initialize ((intloc 0) .--> 1) c= s by A2,XBOOLE_1:1;
  hence thesis by Lm26,A1,SCM_HALT:def 1;
end;

theorem Th67:
  for p being Instruction-Sequence of SCM+FSA
  for s be State of SCM+FSA,t be FinSequence of INT st
  Initialize((intloc 0).-->1) +*(fsloc 0 .--> t) c= s &
  Bubble-Sort-Algorithm c= p
  ex u being FinSequence of REAL
  st t,u are_fiberwise_equipotent & u is non-increasing &
  u is FinSequence of INT & (Result(p,s)).(fsloc 0) = u
proof
  let p being Instruction-Sequence of SCM+FSA;
  let s be State of SCM+FSA,t be FinSequence of INT;
  set Ba=Bubble-Sort-Algorithm, pp=Initialize((intloc 0).-->1),
  x=fsloc 0 .--> t,
  z=IExec(bubble-sort f0,p,s).f0;
  assume that
A1: pp+*x c= s and
A2: Ba c= p;
A3: p +* Ba = p by A2,FUNCT_4:98;
  dom x = { f0} by FUNCOP_1:13;
  then
A4: f0 in dom x by TARSKI:def 1;
  then f0 in dom (pp+*x) by FUNCT_4:12;
  then
A5: s.f0=(pp+*x).f0 by A1,GRFUNC_1:2
    .=x.f0 by A4,FUNCT_4:13
    .=t by FUNCOP_1:72;
A6: s.f0, z are_fiberwise_equipotent by Th65;
  reconsider u=z as FinSequence of REAL by FINSEQ_3:117;
  take u;
  thus t, u are_fiberwise_equipotent by A5,Th65;
A7: dom (s.f0) = dom u by A6,RFINSEQ:3;
  now
    let i,j be Element of NAT;
    assume that
A8: i in dom u and
A9: j in dom u and
A10: i<j;
A11: i>=1 by A8,FINSEQ_3:25;
A12: j<=len (s.f0) by A7,A9,FINSEQ_3:25;
    reconsider y1=z.i as Integer;
    reconsider y2=z.j as Integer;
    thus u.i>=u.j by A10,A11,A12,Th65;
  end;
  hence u is non-increasing by RFINSEQ:19;
  thus u is FinSequence of INT;
  dom pp misses dom x by Th46;
  then pp c=pp+*x by FUNCT_4:32;
  then s=s+*pp by A1,FUNCT_4:98,XBOOLE_1:1;
  then s= Initialized s by SCMFSA6A:def 3;
  hence thesis by Th57,A3;
end;

theorem Th68:
  for w being FinSequence of INT holds
  Initialized ((fsloc 0) .--> w) is Bubble-Sort-Algorithm-autonomic
proof
  let w be FinSequence of INT;
  set p=Initialized((fsloc 0) .--> w), q=Bubble-Sort-Algorithm;
A3: for P,Q being Instruction-Sequence of SCM+FSA
  st q c= P & q c= Q
 for s1,s2 being State of SCM+FSA,i st  p c= s1 &  p c= s2 &
    i <= 10 holds
  Comput(P,s1,i).intloc 0 = Comput(Q,s2,i).intloc 0
&
  Comput(P,s1,i).IC SCM+FSA = Comput(Q,s2,i).IC
SCM+FSA &
  Comput(P,s1,i).fsloc 0 = Comput(Q,s2,i).fsloc 0
  proof
   let P,Q being Instruction-Sequence of SCM+FSA
   such that
A4: q c= P & q c= Q;
    let s1,s2 be State of SCM+FSA,i;
    assume that
A5:  p c= s1 and
A6:  p c= s2 and
A7: i <= 10;
A8: q c= P by A4;
A9: q c= Q by A4;
A10: Comput(P,s1,0) = s1 by EXTPRO_1:2;
A11: s1 is 0-started by A5,MEMSTR_0:17;
A12: s2 is 0-started by A6,MEMSTR_0:17;
A13: s1.intloc 0 =1 by A5,Th54
      .= s2.intloc 0 by A6,Th54;
A14: s1.fsloc 0 =w by A5,Th54
      .=s2.fsloc 0 by A6,Th54;
A15: IC s1 =  0 by A11,MEMSTR_0:def 8
      .= IC s2 by A12,MEMSTR_0:def 8;
    per cases by A7,NAT_1:34;
    suppose
A16:  i = 0;
      hence Comput(P,s1,i).intloc 0 = Comput(Q,s2,i).intloc 0
       by A10,A13,EXTPRO_1:2;
      thus
      (Comput(P,s1,i)).IC SCM+FSA = (Comput(Q,s2,i)).IC SCM+FSA
      by A10,A15,A16,EXTPRO_1:2;
      thus thesis by A10,A14,A16,EXTPRO_1:2;
    end;
    suppose
A17:  i = 1;
      hence Comput(P,s1,i).intloc 0 = s1.intloc 0 by A4,A11,Lm21
        .= Comput(Q,s2,i).intloc 0 by A4,A12,A13,A17,Lm21;
      thus (Comput(P,s1,i)).IC SCM+FSA =  1 by A4,A11,A17,Lm21
        .= (Comput(Q,s2,i)).IC SCM+FSA by A9,A12,A17,Lm21;
      thus Comput(P,s1,i).fsloc 0 = s1.fsloc 0
         by A8,A11,A17,Lm21
        .= Comput(Q,s2,i).fsloc 0 by A4,A12,A14,A17,Lm21;
    end;
    suppose
A18:  i = 2;
      hence Comput(P,s1,i).intloc 0 = s1.intloc 0
      by A8,A11,Lm21
        .= Comput(Q,s2,i).intloc 0 by A4,A12,A13,A18,Lm21;
      thus (Comput(P,s1,i)).IC SCM+FSA =  2 by A4,A11,A18,Lm21
        .= (Comput(Q,s2,i)).IC SCM+FSA by A4,A12,A18,Lm21;
      thus Comput(P,s1,i).fsloc 0 = s1.fsloc 0 by A4,A11,A18,Lm21
        .= Comput(Q,s2,i).fsloc 0 by A4,A12,A14,A18,Lm21;
    end;
    suppose
A19:  i = 3;
      hence Comput(P,s1,i).intloc 0 = s1.intloc 0 by A4,A11,Lm21
        .= Comput(Q,s2,i).intloc 0 by A4,A12,A13,A19,Lm21;
      thus (Comput(P,s1,i)).IC SCM+FSA =  3 by A4,A11,A19,Lm21
        .= (Comput(Q,s2,i)).IC SCM+FSA by A4,A12,A19,Lm21;
      thus Comput(P,s1,i).fsloc 0 = s1.fsloc 0
      by A8,A11,A19,Lm21
        .= Comput(Q,s2,i).fsloc 0 by A4,A12,A14,A19,Lm21;
    end;
    suppose
A20:  i = 4;
      hence Comput(P,s1,i).intloc 0 = s1.intloc 0
      by A8,A11,Lm21
        .= Comput(Q,s2,i).intloc 0 by A4,A12,A13,A20,Lm21;
      thus (Comput(P,s1,i)).IC SCM+FSA =  4 by A4,A11,A20,Lm21
        .= (Comput(Q,s2,i)).IC SCM+FSA by A4,A12,A20,Lm21;
      thus Comput(P,s1,i).fsloc 0 = s1.fsloc 0 by A4,A11,A20,Lm21
        .= Comput(Q,s2,i).fsloc 0 by A4,A12,A14,A20,Lm21;
    end;
    suppose
A21:  i = 5;
      hence Comput(P,s1,i).intloc 0 = s1.intloc 0
      by A8,A11,Lm21
        .= Comput(Q,s2,i).intloc 0 by A4,A12,A13,A21,Lm21;
      thus (Comput(P,s1,i)).IC SCM+FSA =  5 by A4,A11,A21,Lm21
        .= (Comput(Q,s2,i)).IC SCM+FSA by A4,A12,A21,Lm21;
      thus Comput(P,s1,i).fsloc 0 = s1.fsloc 0 by A4,A11,A21,Lm21
        .= Comput(Q,s2,i).fsloc 0 by A4,A12,A14,A21,Lm21;
    end;
    suppose
A22:  i = 6;
      hence Comput(P,s1,i).intloc 0 = s1.intloc 0 by A4,A11,Lm21
        .= Comput(Q,s2,i).intloc 0 by A4,A12,A13,A22,Lm21;
      thus (Comput(P,s1,i)).IC SCM+FSA =  6 by A4,A11,A22,Lm21
        .= (Comput(Q,s2,i)).IC SCM+FSA by A4,A12,A22,Lm21;
      thus Comput(P,s1,i).fsloc 0 = s1.fsloc 0 by A4,A11,A22,Lm21
        .= Comput(Q,s2,i).fsloc 0 by A4,A12,A14,A22,Lm21;
    end;
    suppose
A23:  i = 7;
      hence Comput(P,s1,i).intloc 0 = s1.intloc 0
      by A8,A11,Lm21
        .= Comput(Q,s2,i).intloc 0 by A4,A12,A13,A23,Lm21;
      thus (Comput(P,s1,i)).IC SCM+FSA =  7 by A4,A11,A23,Lm21
        .= (Comput(Q,s2,i)).IC SCM+FSA by A4,A12,A23,Lm21;
      thus Comput(P,s1,i).fsloc 0 = s1.fsloc 0 by A4,A11,A23,Lm21
        .= Comput(Q,s2,i).fsloc 0 by A4,A12,A14,A23,Lm21;
    end;
    suppose
A24:  i = 8;
      hence Comput(P,s1,i).intloc 0 = s1.intloc 0 by A4,A11,Lm21
        .= Comput(Q,s2,i).intloc 0 by A4,A12,A13,A24,Lm21;
      thus (Comput(P,s1,i)).IC SCM+FSA =  8 by A4,A11,A24,Lm21
        .= (Comput(Q,s2,i)).IC SCM+FSA by A4,A12,A24,Lm21;
      thus Comput(P,s1,i).fsloc 0 = s1.fsloc 0 by A4,A11,A24,Lm21
        .= Comput(Q,s2,i).fsloc 0 by A4,A12,A14,A24,Lm21;
    end;
    suppose
A25:  i = 9;
      hence Comput(P,s1,i).intloc 0 = s1.intloc 0 by A4,A11,Lm21
        .= Comput(Q,s2,i).intloc 0 by A4,A12,A13,A25,Lm21;
      thus (Comput(P,s1,i)).IC SCM+FSA =  9 by A4,A11,A25,Lm21
        .= (Comput(Q,s2,i)).IC SCM+FSA by A4,A12,A25,Lm21;
      thus Comput(P,s1,i).fsloc 0 = s1.fsloc 0 by A4,A11,A25,Lm21
        .= Comput(Q,s2,i).fsloc 0 by A4,A12,A14,A25,Lm21;
    end;
    suppose
A26:  i = 10;
      hence Comput(P,s1,i).intloc 0 = s1.intloc 0 by A4,A11,Lm21
        .= Comput(Q,s2,i).intloc 0 by A4,A12,A13,A26,Lm21;
      thus (Comput(P,s1,i)).IC SCM+FSA =  10 by A4,A11,A26,Lm21
        .= (Comput(Q,s2,i)).IC SCM+FSA by A4,A12,A26,Lm21;
      thus Comput(P,s1,i).fsloc 0 = s1.fsloc 0 by A4,A11,A26,Lm21
        .= Comput(Q,s2,i).fsloc 0 by A4,A12,A14,A26,Lm21;
    end;
  end;
  set UD={fsloc 0,a0,a1,a2,a3,a4,a5,a6}, Us=UsedInt*Loc q \/ UsedIntLoc q;
A27: UsedInt*Loc q ={fsloc 0} by Th59;
A28: UsedIntLoc q ={a0,a1,a2,a3,a4,a5,a6} by Th58;
  then
A29: Us = UD by A27,ENUMSET1:22;
A30: for P,Q being Instruction-Sequence of SCM+FSA
   st q c= P & q c= Q
  for i being Element of NAT,s1,s2 being State of SCM+FSA
  st 11 <= i &  p c= s1 &  p c= s2
  holds Comput(P,s1,i) | Us = Comput(Q,s2,i) | Us &
  Comput(P,s1,i).IC SCM+FSA = Comput(Q,s2,i).IC SCM+FSA
  proof
   let P,Q be Instruction-Sequence of SCM+FSA
   such that
A31:  q c= P & q c= Q;
    let i be Element of NAT,s1,s2 be State of SCM+FSA such that
A33: 11 <= i and
A34:  p c= s1 and
A35:  p c= s2;
    set Cs11= Comput(P, s1,11), Cs21= Comput(Q,s2,11);
A36: s1 is 0-started by A34,MEMSTR_0:17;
A37: s2 is 0-started by A35,MEMSTR_0:17;
A40: s1.intloc 0 =1 by A34,Th54
      .= s2.intloc 0 by A35,Th54;
A41: s1.fsloc 0 =w by A34,Th54
      .=s2.fsloc 0 by A35,Th54;
A42: Us c= dom(Cs11) by Th56;
A43: Us c= dom(Cs21) by Th56;
    now
      let x be set;
      assume x in Us;
      then
A44:  x in UD by A27,A28,ENUMSET1:22;
      per cases by A44,ENUMSET1:def 6;
      suppose
A45:    x = fsloc 0;
        hence Cs11.x =s1.fsloc 0 by A36,A31,Lm21
          .=Cs21.x by A37,A31,A41,A45,Lm21;
      end;
      suppose
A46:    x = a0;
        hence Cs11.x =s1.a0 by A36,A31,Lm21
          .=Cs21.x by A37,A31,A40,A46,Lm21;
      end;
      suppose
A47:    x = a1;
        hence Cs11.x=len(s1.fsloc 0) by A36,A31,Lm21
          .=Cs21.x by A37,A31,A41,A47,Lm21;
      end;
      suppose
A48:    x = a2;
        hence Cs11.x=s1.a0 by A36,A31,Lm21
          .=Cs21.x by A37,A31,A40,A48,Lm21;
      end;
      suppose
A49:    x = a3;
        hence Cs11.x=s1.a0 by A36,A31,Lm21
          .=Cs21.x by A37,A31,A40,A49,Lm21;
      end;
      suppose
A50:    x = a4;
        hence Cs11.x=s1.a0 by A36,A31,Lm21
          .=Cs21.x by A37,A31,A40,A50,Lm21;
      end;
      suppose
A51:    x = a5;
        hence Cs11.x=s1.a0 by A36,A31,Lm21
          .=Cs21.x by A37,A31,A40,A51,Lm21;
      end;
      suppose
A52:    x = a6;
        hence Cs11.x=s1.a0 by A36,A31,Lm21
          .=Cs21.x by A37,A31,A40,A52,Lm21;
      end;
    end;
    then
A53: Cs11 | Us = Cs21 | Us by A42,A43,FUNCT_1:95;
A54: Cs11.IC SCM+FSA =  11 by A36,A31,Lm21
      .=Cs21.IC SCM+FSA by A37,A31,Lm21;
A55: for i holds IC Comput(P,s1,i) in dom q by A34,Th66,A31;
    for i holds IC Comput(Q,s2,i) in dom q by A35,Th66,A31;
    hence thesis by A33,A53,A54,A55,Th26,A31;
  end;
  set DD={intloc 0,IC SCM+FSA,fsloc 0};
A56: dom p = DD by Th42;
    let P,Q be Instruction-Sequence of SCM+FSA
    such that
A57:  q c= P & q c= Q;
    let s1,s2 be State of SCM+FSA;
    assume that
A58:  p c= s1 and
A59:  p c= s2;
    let i;
    set Cs1i=Comput(P,s1,i), Cs2i=Comput(Q,s2,i);
    Initialized ((fsloc 0) .--> w)
        = ((fsloc 0) .--> w) +* Initialize ((intloc 0) .--> 1)
                by SCMFSA6A:def 3;
    then DataPart p
      = DataPart((fsloc 0) .--> w) +*
        DataPart Initialize ((intloc 0) .--> 1) by FUNCT_4:71
     .= DataPart((fsloc 0) .--> w) +*  DataPart ((intloc 0) .--> 1)
                by MEMSTR_0:45
     .= ((fsloc 0) .--> w) +*  DataPart ((intloc 0) .--> 1)
                by MEMSTR_0:7
     .= ((fsloc 0) .--> w) +*  ((intloc 0) .--> 1)
                by MEMSTR_0:7;
    then
A67: dom DataPart p
          = dom((fsloc 0) .--> w) \/ dom ((intloc 0) .--> 1) by FUNCT_4:def 1
         .= {fsloc 0} \/ dom ((intloc 0) .--> 1) by FUNCOP_1:13
         .= {fsloc 0} \/ {intloc 0} by FUNCOP_1:13
         .= {intloc 0,fsloc 0} by ENUMSET1:1;
    IC SCM+FSA in dom p by A56,ENUMSET1:def 1;
    then
A68: dom  p
      = {IC SCM+FSA} \/ dom DataPart p by MEMSTR_0:24
     .= {IC SCM+FSA,intloc 0,fsloc 0} by A67,ENUMSET1:2
     .= DD by ENUMSET1:58;
A69: DD c= dom Cs1i by Th55;
A70: DD c= dom Cs2i by Th55;
A71: intloc 0 in Us by A29,ENUMSET1:def 6;
A72: fsloc 0 in Us by A29,ENUMSET1:def 6;
A73: Us c= dom(Cs1i) by Th56;
A74: Us c= dom(Cs2i) by Th56;
A75: i>10 implies 10+1 < i+1 by XREAL_1:6;
    now
      let x be set;
      assume
A76:  x in DD;
      per cases by A76,ENUMSET1:def 1;
      suppose
A77:    x=intloc 0;
        per cases;
          suppose i<=10;
            hence Cs1i.x=Cs2i.x by A3,A58,A59,A77,A57;
          end;
          suppose i>10;
            then 11 <= i by A75,NAT_1:13;
            then Cs1i | Us = Cs2i | Us by A30,A58,A59,A57;
            hence Cs1i.x=Cs2i.x by A71,A73,A74,A77,FUNCT_1:95;
          end;
      end;
      suppose
A78:    x=IC SCM+FSA;
        per cases;
          suppose i<=10;
            hence Cs1i.x=Cs2i.x by A3,A58,A59,A78,A57;
          end;
          suppose i>10;
            then 11 <= i by A75,NAT_1:13;
            hence Cs1i.x=Cs2i.x by A30,A58,A59,A78,A57;
          end;
      end;
      suppose
A79:    x=fsloc 0;
        per cases;
          suppose i<=10;
            hence Cs1i.x=Cs2i.x by A3,A58,A59,A79,A57;
          end;
          suppose i>10;
            then 11 <= i by A75,NAT_1:13;
            then Cs1i | Us = Cs2i | Us by A30,A58,A59,A57;
            hence Cs1i.x=Cs2i.x by A72,A73,A74,A79,FUNCT_1:95;
          end;
      end;
    end;
 hence Cs1i| dom  p = Cs2i | dom  p by A68,A69,A70,FUNCT_1:95;
end;

registration
 cluster Bubble-Sort-Algorithm -> non halt-free;
 coherence;
end;

theorem
  Bubble-Sort-Algorithm, Initialize((intloc 0).-->1)
      computes Sorting-Function
proof
  let x be set;
  assume x in dom Sorting-Function;
  then consider w being FinSequence of INT such that
A1: x = fsloc 0 .--> w by Th60;
  reconsider d = x as FinPartState of SCM+FSA by A1;
  set q = Bubble-Sort-Algorithm,
   p = Initialize((intloc 0).-->1);
A3: dom d = { fsloc 0 } by A1,FUNCOP_1:13;
  take d;
  thus x = d;
X5: dom d misses {IC SCM+FSA} by A3,SCMFSA_2:57,ZFMISC_1:11;
X6: dom d misses {intloc 0} by A3,SCMFSA_2:58,ZFMISC_1:11;
    dom p = dom ((intloc 0).-->1) \/ {IC SCM+FSA} by MEMSTR_0:42
       .= {IC SCM+FSA} \/ {intloc 0} by FUNCOP_1:13;
    then
X1: dom d misses dom p by X5,X6,XBOOLE_1:70;
UU: d +* p = p +* d by X1,FUNCT_4:35;
   Initialized d = d +* p by SCMFSA6A:def 3
        .= p +* d by X1,FUNCT_4:35
        .= (p +* d)
        .= p +* d;
   then
A4: p +* d is q-autonomic by A1,Th68;
  now
    let t be State of SCM+FSA;
    assume
A6:  (p+*d) c= t;
    let P be Instruction-Sequence of SCM+FSA
    such that
A7:  q c= P;
    set bf=bubble-sort fsloc 0;
    Initialize((intloc 0).-->1) c= (p+*d) by UU,FUNCT_4:25;
    then Initialize((intloc 0).-->1) c= t by A6,XBOOLE_1:1;
   hence P halts_on t by Lm26,A7,SCM_HALT:def 2;
  end;
  then
A10: p +* d is q-halted by EXTPRO_1:def 11;
  thus
A15:  p +* d is Autonomy of q by A10,A4,EXTPRO_1:def 12;
  consider z being FinSequence of REAL such that
A16: w,z are_fiberwise_equipotent and
A17: z is non-increasing
  and z is FinSequence of INT and
A18: Sorting-Function.d = fsloc 0 .--> z by A1,Th61;
  consider t being State of SCM+FSA such that
A19: p +* d c= t by PBOOLE:141;
  consider T being Instruction-Sequence of SCM+FSA such that
B19: q c= T by PBOOLE:145;
  consider u being FinSequence of REAL such that
A20: w,u are_fiberwise_equipotent and
A21: u is non-increasing
  and
 u is FinSequence of INT and
A22: (Result(T,t)).(fsloc 0) = u by Th67,A1,A19,B19;
A23: u=z by A16,A17,A20,A21,CLASSES1:76,RFINSEQ:23;
  fsloc 0 in the carrier of SCM+FSA;
  then
A24: fsloc 0 in dom Result(T,t) by PARTFUN1:def 2;
  d c= p +* d by FUNCT_4:25;
  then
A25: dom d c= dom(p +* d) by RELAT_1:11;
A26: dom(fsloc 0 .--> z) = { fsloc 0 } by FUNCOP_1:13;
  Result(q,p +* d) = (Result(T,t))|dom(p +* d)
         by A15,A19,B19,EXTPRO_1:def 13;
 hence Sorting-Function.d c= Result(q,p+* d)
   by A3,A18,A22,A23,A24,A26,A25,FUNCT_4:85,RELAT_1:151;
end;

