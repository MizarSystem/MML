:: Bubble Sort on SCM+FSA
::  by JingChao Chen and Yatsuka Nakamura
::
:: Received June 17, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies AMI_3, AMI_1, SCMFSA_2, SCMFSA6A, SCMFSA7B, SCMFSA8B, CARD_1,
      SCMFSA8A, SCMFSA8C, FUNCT_1, FUNCT_4, CAT_1, RELAT_1, RFINSEQ,
      BOOLE, ABSVALUE, SCMFSA6C, SF_MASTR, SCMFSA6B, ORDINAL2, AMI_2, AMI_5,
      ARYTM_1, NAT_1, FINSEQ_1, FINSEQ_2, FINSUB_1, PROB_1, INT_1, RELOC,
      PARTFUN1, SCM_HALT, SCMBSORT, FINSEQ_4, ARYTM, AMISTD_2, SCMNORM;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, ORDINAL1, CARD_1, NUMBERS,
      XCMPLX_0, NAT_1, INT_1, RELAT_1, FINSEQ_1, FUNCT_1, COMPLEX1, FUNCT_2,
      FUNCT_4, FINSEQ_2, FUNCT_7, STRUCT_0, AMI_1, SCMNORM, SCMFSA_2, FUNCOP_1,
      SCMFSA_4, FINSUB_1, CARD_3, PARTFUN1, SCMFSA6B, SCMFSA6C, SCMFSA6A,
      SF_MASTR, SCMFSA8A, SCMFSA8B, SCMFSA8C, RFINSEQ, SCMFSA7B, NAT_D,
      SCM_HALT, XXREAL_0;
 constructors PARTFUN1, SETWISEO, XXREAL_0, REAL_1, NAT_1, INT_2, SEQM_3,
      RFINSEQ, AMI_5, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA8A,
      SCMFSA8B, SCMFSA8C, SCM_HALT, SEQ_1, SCMNORM, SCMFSA_4, NAT_D;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, RELSET_1, FUNCOP_1, FINSUB_1,
      FRAENKEL, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, MEMBERED, CARD_3,
      RFINSEQ, AMI_1, SCMFSA_2, SF_MASTR, SCMFSA6C, SCMFSA7B, FINSET_1,
      SCMFSA8A, SCMFSA8B, SCMFSA_9, SCM_HALT, STRUCT_0, VALUED_0, ORDINAL1,
      FINSEQ_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, FUNCOP_1, AMI_1, XBOOLE_0, SCMFSA_2, SCMFSA8A,SCMFSA8C,
      SCMFSA6A, SCMNORM;
 theorems SF_MASTR, FUNCT_1, FUNCT_7, FUNCOP_1, RELAT_1, AMI_1, FUNCT_2,
      ZFMISC_1, SCMFSA6A, FUNCT_4, FINSEQ_3, ENUMSET1, NAT_1, FINSEQ_1,
      RELSET_1, TARSKI, INT_1, PARTFUN1, GRFUNC_1, BINARITH, RFINSEQ, SCMFSA_2,
      SCMFSA6B, SCMFSA7B, SCMFSA8B, SCMFSA8A, SCMFSA8C, SCMFSA_4, SCMFSA6C,
      SCM_HALT, ABSVALUE, FINSEQ_4, XBOOLE_0, XBOOLE_1, SCMFSA9A, XREAL_1,
      ORDINAL1, SCMFSA_1, XXREAL_0, AMI_3, CARD_3, NAT_D;
 schemes RELSET_1, FUNCT_1, NAT_1;

begin :: Preliminaries

reserve p for preProgram of SCM+FSA,
  ic for Instruction of SCM+FSA,
  i,j,k for Element of NAT,
  fa,f for FinSeq-Location,
  a,b,da,db for Int-Location,
  la,lb for Instruction-Location of SCM+FSA;

canceled 2;

theorem Th3:
  for I being Program of SCM+FSA,a,b being Int-Location st
  I does_not_destroy b & a<>b holds Times(a,I) does_not_destroy b
proof
  let I be Program of SCM+FSA,a,b be Int-Location;
  assume that
A1: I does_not_destroy b and
A2: a <> b;
  set Gi= Goto insloc 2, Si= SubFrom(a,intloc 0), SS= Stop SCM+FSA,
  if0=if=0(a,Gi,I ';'Si);
A3: Gi does_not_destroy b by SCMFSA8C:86;
  I ';' Si does_not_destroy b by A1,A2,SCMFSA7B:14,SCMFSA8C:83;
  then if0 does_not_destroy b by A3,SCMFSA8C:121;
  then
A4: loop if0 does_not_destroy b by SCMFSA8C:105;
  SS does_not_destroy b by SCMFSA8C:85;
  hence thesis by A4,SCMFSA8C:121;
end;

canceled 4;

theorem Th8:
  for s be State of SCM+FSA,f be FinSeq-Location,a,b be Int-Location
  holds Exec(b:=(f,a), s).b = (s.f)/.abs(s.a)
proof
  let s be State of SCM+FSA,f be FinSeq-Location,a,b be Int-Location;
  consider k be Element of NAT such that
A1: k = abs(s.a) & Exec(b:=(f,a), s).b = (s.f)/.k by SCMFSA_2:98;
  thus thesis by A1;
end;

theorem Th9:
  for s be State of SCM+FSA,f be FinSeq-Location,a,b be Int-Location
  holds Exec((f,a):=b, s).f = s.f+*(abs(s.a),s.b)
proof
  let s be State of SCM+FSA,f be FinSeq-Location,a,b be Int-Location;
  consider k be Element of NAT such that
A1: k = abs(s.a) & Exec((f,a):=b, s).f = s.f+*(k,s.b) by SCMFSA_2:99;
  thus thesis by A1;
end;

theorem Th10:
  for s be State of SCM+FSA,f be FinSeq-Location,m,n be Element of NAT,
  a be Int-Location
  st m<>n+1 holds Exec(intloc m:=(f,a), Initialize s).intloc (n+1)
  =s.intloc (n+1)
proof
  let s be State of SCM+FSA,f be FinSeq-Location,m,n be Element of NAT,
  a be Int-Location;
  assume m<>n+1;
  then intloc m<>intloc (n+1) by AMI_3:52;
  hence Exec(intloc m:=(f,a), Initialize s).intloc (n+1)
  =(Initialize s).intloc (n+1) by SCMFSA_2:98
    .=s.intloc (n+1) by SCMFSA6C:3;
end;

theorem Th11:
  for s be State of SCM+FSA,m,n be Element of NAT,a be Int-Location
  st m<>n+1 holds Exec(intloc m:=a, Initialize s).intloc (n+1) =s.intloc (n+1)
proof
  let s be State of SCM+FSA,m,n be Element of NAT,a be Int-Location;
  assume m<>n+1;
  then intloc m<>intloc (n+1) by AMI_3:52;
  hence Exec(intloc m:=a, Initialize s).intloc (n+1)
  =(Initialize s).intloc (n+1) by SCMFSA_2:89
    .=s.intloc (n+1) by SCMFSA6C:3;
end;

theorem Th12:
  for s be State of SCM+FSA, f be FinSeq-Location, a be read-write Int-Location
  holds IExec(Stop SCM+FSA,s).a =s.a & IExec(Stop SCM+FSA,s).f =s.f
proof
  let s be State of SCM+FSA,f be FinSeq-Location,a be read-write Int-Location;
  set SA0=Start-At insloc 0;
A1: IExec(Stop SCM+FSA,s) = Initialize s +* SA0 by SCMFSA8C:38
    .= s +* ((intloc 0) .--> 1) +* SA0 +* SA0 by SCMFSA6C:def 3
    .= s +* ((intloc 0) .--> 1) +*(SA0 +* SA0) by FUNCT_4:15
    .=Initialize s by SCMFSA6C:def 3;
  hence IExec(Stop SCM+FSA,s).a =s.a by SCMFSA6C:3;
  thus IExec(Stop SCM+FSA,s).f =s.f by A1,SCMFSA6C:3;
end;

reserve n for natural number;

canceled 3;

theorem Th16:
  (ic in rng p) & (ic = a:=b or ic = AddTo(a, b) or ic = SubFrom(a, b) or
  ic = MultBy(a, b) or ic = Divide(a, b))
  implies a in UsedIntLoc p & b in UsedIntLoc p
proof
  assume
A1: (ic in rng p) & (ic = a:=b or ic = AddTo(a, b) or ic = SubFrom(a, b) or
  ic = MultBy(a, b) or ic = Divide(a, b));
  then
A2: UsedIntLoc ic = {a, b} by SF_MASTR:18;
  UsedIntLoc ic c= UsedIntLoc p by A1,SF_MASTR:23;
  hence thesis by A2,ZFMISC_1:38;
end;

theorem Th17:
  (ic in rng p) & (ic = a=0_goto la or ic = a>0_goto la)
  implies a in UsedIntLoc p
proof
  assume
A1: (ic in rng p) & (ic = a=0_goto la or ic = a>0_goto la);
  then
A2: UsedIntLoc ic = {a} by SF_MASTR:20;
  UsedIntLoc ic c= UsedIntLoc p by A1,SF_MASTR:23;
  hence thesis by A2,ZFMISC_1:37;
end;

theorem Th18:
  ic in rng p & ( ic = b := (fa, a) or ic = (fa, a) := b)
  implies a in UsedIntLoc p & b in UsedIntLoc p
proof
  assume
A1: ic in rng p & ( ic = b := (fa, a) or ic = (fa, a) := b);
  then
A2: UsedIntLoc ic = {a,b} by SF_MASTR:21;
  UsedIntLoc ic c= UsedIntLoc p by A1,SF_MASTR:23;
  hence thesis by A2,ZFMISC_1:38;
end;

theorem Th19:
  ic in rng p & ( ic = b := (fa, a) or ic = (fa, a) := b)
  implies fa in UsedInt*Loc p
proof
  assume
A1: (ic in rng p) & ( ic = b := (fa, a) or ic = (fa, a) := b);
  then
A2: UsedInt*Loc ic = {fa} by SF_MASTR:37;
  UsedInt*Loc ic c= UsedInt*Loc p by A1,SF_MASTR:39;
  hence thesis by A2,ZFMISC_1:37;
end;

theorem Th20:
  ic in rng p & (ic = a :=len fa or ic = fa :=<0,...,0>a)
  implies a in UsedIntLoc p
proof
  assume
A1: (ic in rng p) & (ic = a :=len fa or ic = fa :=<0,...,0>a);
  then
A2: UsedIntLoc ic = {a} by SF_MASTR:22;
  UsedIntLoc ic c= UsedIntLoc p by A1,SF_MASTR:23;
  hence thesis by A2,ZFMISC_1:37;
end;

theorem Th21:
  ic in rng p & (ic = a :=len fa or ic = fa :=<0,...,0>a)
  implies fa in UsedInt*Loc p
proof
  assume
A1: (ic in rng p) & (ic = a :=len fa or ic = fa :=<0,...,0>a);
  then
A2: UsedInt*Loc ic = {fa} by SF_MASTR:38;
  UsedInt*Loc ic c= UsedInt*Loc p by A1,SF_MASTR:39;
  hence thesis by A2,ZFMISC_1:37;
end;

canceled;

theorem Th23:
  for t being FinPartState of SCM+FSA,p being Program of SCM+FSA,
  x being set st dom t c= Int-Locations \/ FinSeq-Locations &
  x in dom t \/ UsedInt*Loc p \/ UsedIntLoc p
  holds x is Int-Location or x is FinSeq-Location
proof
  let t be FinPartState of SCM+FSA,p be Program of SCM+FSA,x be set;
  set D1=UsedInt*Loc p;
  set D2=UsedIntLoc p;
  assume
A1: dom t c= Int-Locations \/ FinSeq-Locations & x in dom t \/ D1 \/ D2;
  then x in dom t \/ D1 or x in D2 by XBOOLE_0:def 2;
  then
A2: x in dom t or x in D1 or x in D2 by XBOOLE_0:def 2;
  per cases by A1,A2,XBOOLE_0:def 2;
  suppose x in Int-Locations;
    hence thesis by SCMFSA_2:11;
  end;
  suppose x in FinSeq-Locations;
    hence thesis by SCMFSA_2:12;
  end;
  suppose x in D1;
    hence thesis by SCMFSA_2:12;
  end;
  suppose x in D2;
    hence thesis by SCMFSA_2:11;
  end;
end;

canceled;

theorem Th25:
  for i,k being Element of NAT,t being FinPartState of SCM+FSA,
  p being Program of SCM+FSA, s1,s2 being State of SCM+FSA
  st k <= i & p c= s1 & p c= s2 & dom t c= Int-Locations \/ FinSeq-Locations &
  (for j holds IC Computation(s1,j) in dom p &
  IC Computation(s2,j) in dom p) &
  Computation(s1,k).IC SCM+FSA = Computation(s2,k).IC SCM+FSA &
  Computation(s1,k) |(dom t \/ UsedInt*Loc p \/ UsedIntLoc p) =
  Computation(s2,k) |(dom t \/ UsedInt*Loc p \/ UsedIntLoc p) holds
  Computation(s1,i).IC SCM+FSA = Computation(s2,i).IC SCM+FSA &
  Computation(s1,i) |(dom t \/ UsedInt*Loc p \/ UsedIntLoc p) =
  Computation(s2,i) |(dom t \/ UsedInt*Loc p \/ UsedIntLoc p)
proof
  let i,k;
  let t be FinPartState of SCM+FSA,p be Program of SCM+FSA,
  s1,s2 be State of SCM+FSA;
  set Dloc=dom t \/ UsedInt*Loc p \/ UsedIntLoc p;
  assume
A1: k <= i & p c= s1 & p c= s2 & dom t c= Int-Locations \/ FinSeq-Locations &
  (for j holds IC Computation(s1,j) in dom p &
  IC Computation(s2,j) in dom p) &
  Computation(s1,k).IC SCM+FSA = Computation(s2,k).IC SCM+FSA &
  Computation(s1,k) |Dloc = Computation(s2,k)|Dloc;
  then consider m being Nat such that
A2: i=k+m by NAT_1:10;
  reconsider m as Element of NAT by ORDINAL1:def 13;
A3: i=k+m by A2;
A4: UsedIntLoc p c= Dloc by XBOOLE_1:7;
  Dloc=dom t \/ UsedIntLoc p \/ UsedInt*Loc p by XBOOLE_1:4;
  then
A5: UsedInt*Loc p c= Dloc by XBOOLE_1:7;
  defpred P[Element of NAT] means
   Computation( s1,k+$1).IC SCM+FSA =  Computation( s2,k+$1).IC SCM+FSA &
   Computation( s1,k+$1) |Dloc =  Computation( s2,k+$1)|Dloc;
A6: P[0] by A1;
A7: now
    let m be Element of NAT;
    assume
A8: P[m];
    set sk1= Computation( s1,k+m);
    set sk11= Computation( s1,k+(m+1));
    set i1=CurInstr sk1;
    set sk2= Computation( s2,k+m);
    set sk12= Computation( s2,k+(m+1));
    set i2=CurInstr sk2;
A9: IC sk1 in dom p by A1;            :: SCMFSA6B:def 2,C1=paraclosed;
    then
A10: i1 =(sk1 |dom p).IC sk1 by FUNCT_1:72;
    i1 =s1.IC sk1 by AMI_1:54
      .=p.IC sk1 by A1,A9,GRFUNC_1:8;
    then
A11: i1 in rng p by A9,FUNCT_1:def 5;
    IC sk2 in dom p by A1;              :: paraclosed
    then
A12: i2 =(sk2 |dom p).IC sk2 by FUNCT_1:72
      .=i1 by A1,A8,A10,AMI_1:124;
A13: sk11= Computation( s1,k+m+1)
      .=Following sk1 by AMI_1:14
      .= Exec(i1,sk1);
A14: sk12= Computation( s2,k+m+1)
      .=Following sk2 by AMI_1:14
      .= Exec(i2,sk2);
A15: dom sk11 = the carrier of SCM+FSA by AMI_1:79
      .= dom sk12 by AMI_1:79;
    per cases by NAT_1:37,SCMFSA_2:35;
    suppose InsCode i1 = 0;
      then
A16:  i1=halt SCM+FSA by SCMFSA_2:122;
      then sk11=sk1 by A13,AMI_1:def 8;
      hence P[m+1] by A8,A12,A14,A16,AMI_1:def 8;
    end;
    suppose InsCode i1 = 1;
      then consider da,db such that
A17:  i1 = da:=db by SCMFSA_2:54;
A18:  sk11.IC SCM+FSA= Next IC sk1 by A13,A17,SCMFSA_2:89
        .= sk12.IC SCM+FSA by A8,A12,A14,A17,SCMFSA_2:89;
      now
        let x be set;
        assume
A19:    x in Dloc;
        per cases by A1,A19,Th23;
        suppose
A20:      x is Int-Location;
          now
            per cases;
            case
A21:          x = da;
              then
A22:          sk12.x=sk2.db by A12,A14,A17,SCMFSA_2:89;
A23:          db in UsedIntLoc p by A11,A17,Th16;
              then sk1.db=(sk2 | Dloc).db by A4,A8,FUNCT_1:72
                .=sk2.db by A4,A23,FUNCT_1:72;
              hence sk11.x=sk12.x by A13,A17,A21,A22,SCMFSA_2:89;
            end;
            case
A24:          x<> da;
              then
A25:          sk12.x=sk2.x by A12,A14,A17,A20,SCMFSA_2:89;
              sk1.x=(sk2 | Dloc).x by A8,A19,FUNCT_1:72
                .=sk2.x by A19,FUNCT_1:72;
              hence sk11.x=sk12.x by A13,A17,A20,A24,A25,SCMFSA_2:89;
            end;
          end;
          hence sk11.x=sk12.x;
        end;
        suppose
A26:      x is FinSeq-Location;
          then
A27:      sk12.x=sk2.x by A12,A14,A17,SCMFSA_2:89;
          sk1.x=(sk2 | Dloc).x by A8,A19,FUNCT_1:72
            .=sk2.x by A19,FUNCT_1:72;
          hence sk11.x=sk12.x by A13,A17,A26,A27,SCMFSA_2:89;
        end;
      end;
      hence P[m+1] by A15,A18,FUNCT_1:166;
    end;
    suppose InsCode i1 = 2;
      then consider da,db such that
A28:  i1 = AddTo(da,db) by SCMFSA_2:55;
A29:  sk11.IC SCM+FSA= Next IC sk1 by A13,A28,SCMFSA_2:90
        .= sk12.IC SCM+FSA by A8,A12,A14,A28,SCMFSA_2:90;
      now
        let x be set;
        assume
A30:    x in Dloc;
        per cases by A1,A30,Th23;
        suppose
A31:      x is Int-Location;
          now
            per cases;
            case
A32:          x = da;
              then
A33:          sk12.x=sk2.da+sk2.db by A12,A14,A28,SCMFSA_2: 90;
A34:          da in UsedIntLoc p by A11,A28,Th16;
              then
A35:          sk1.da=(sk2 | Dloc).da by A4,A8,FUNCT_1:72
                .=sk2.da by A4,A34,FUNCT_1:72;
A36:          db in UsedIntLoc p by A11,A28,Th16;
              then sk1.db=(sk2 | Dloc).db by A4,A8,FUNCT_1:72
                .=sk2.db by A4,A36,FUNCT_1:72;
              hence sk11.x=sk12.x by A13,A28,A32,A33,A35,SCMFSA_2:90;
            end;
            case
A37:          x<> da;
              then
A38:          sk12.x=sk2.x by A12,A14,A28,A31,SCMFSA_2:90;
              sk1.x=(sk2 | Dloc).x by A8,A30,FUNCT_1:72
                .=sk2.x by A30,FUNCT_1:72;
              hence sk11.x=sk12.x by A13,A28,A31,A37,A38,SCMFSA_2:90;
            end;
          end;
          hence sk11.x=sk12.x;
        end;
        suppose
A39:      x is FinSeq-Location;
          then
A40:      sk12.x=sk2.x by A12,A14,A28,SCMFSA_2:90;
          sk1.x=(sk2 | Dloc).x by A8,A30,FUNCT_1:72
            .=sk2.x by A30,FUNCT_1:72;
          hence sk11.x=sk12.x by A13,A28,A39,A40,SCMFSA_2:90;
        end;
      end;
      hence P[m+1] by A15,A29,FUNCT_1:166;
    end;
    suppose InsCode i1 = 3;
      then consider da,db such that
A41:  i1 = SubFrom(da,db) by SCMFSA_2:56;
A42:  sk11.IC SCM+FSA= Next IC sk1 by A13,A41,SCMFSA_2:91
        .= sk12.IC SCM+FSA by A8,A12,A14,A41,SCMFSA_2:91;
      now
        let x be set;
        assume
A43:    x in Dloc;
        per cases by A1,A43,Th23;
        suppose
A44:      x is Int-Location;
          now
            per cases;
            case
A45:          x = da;
              then
A46:          sk12.x=sk2.da-sk2.db by A12,A14,A41,SCMFSA_2: 91;
A47:          da in UsedIntLoc p by A11,A41,Th16;
              then
A48:          sk1.da=(sk2 | Dloc).da by A4,A8,FUNCT_1:72
                .=sk2.da by A4,A47,FUNCT_1:72;
A49:          db in UsedIntLoc p by A11,A41,Th16;
              then sk1.db=(sk2 | Dloc).db by A4,A8,FUNCT_1:72
                .=sk2.db by A4,A49,FUNCT_1:72;
              hence sk11.x=sk12.x by A13,A41,A45,A46,A48,SCMFSA_2:91;
            end;
            case
A50:          x<> da;
              then
A51:          sk12.x=sk2.x by A12,A14,A41,A44,SCMFSA_2:91;
              sk1.x=(sk2 | Dloc).x by A8,A43,FUNCT_1:72
                .=sk2.x by A43,FUNCT_1:72;
              hence sk11.x=sk12.x by A13,A41,A44,A50,A51,SCMFSA_2:91;
            end;
          end;
          hence sk11.x=sk12.x;
        end;
        suppose
A52:      x is FinSeq-Location;
          then
A53:      sk12.x=sk2.x by A12,A14,A41,SCMFSA_2:91;
          sk1.x=(sk2 | Dloc).x by A8,A43,FUNCT_1:72
            .=sk2.x by A43,FUNCT_1:72;
          hence sk11.x=sk12.x by A13,A41,A52,A53,SCMFSA_2:91;
        end;
      end;
      hence P[m+1] by A15,A42,FUNCT_1:166;
    end;
    suppose InsCode i1 = 4;
      then consider da,db such that
A54:  i1 = MultBy(da,db) by SCMFSA_2:57;
A55:  sk11.IC SCM+FSA= Next IC sk1 by A13,A54,SCMFSA_2:92
        .= sk12.IC SCM+FSA by A8,A12,A14,A54,SCMFSA_2:92;
      now
        let x be set;
        assume
A56:    x in Dloc;
        per cases by A1,A56,Th23;
        suppose
A57:      x is Int-Location;
          now
            per cases;
            case
A58:          x = da;
              then
A59:          sk12.x=sk2.da*sk2.db by A12,A14,A54,SCMFSA_2: 92;
A60:          da in UsedIntLoc p by A11,A54,Th16;
              then
A61:          sk1.da=(sk2 | Dloc).da by A4,A8,FUNCT_1:72
                .=sk2.da by A4,A60,FUNCT_1:72;
A62:          db in UsedIntLoc p by A11,A54,Th16;
              then sk1.db=(sk2 | Dloc).db by A4,A8,FUNCT_1:72
                .=sk2.db by A4,A62,FUNCT_1:72;
              hence sk11.x=sk12.x by A13,A54,A58,A59,A61,SCMFSA_2:92;
            end;
            case
A63:          x<> da;
              then
A64:          sk12.x=sk2.x by A12,A14,A54,A57,SCMFSA_2:92;
              sk1.x=(sk2 | Dloc).x by A8,A56,FUNCT_1:72
                .=sk2.x by A56,FUNCT_1:72;
              hence sk11.x=sk12.x by A13,A54,A57,A63,A64,SCMFSA_2:92;
            end;
          end;
          hence sk11.x=sk12.x;
        end;
        suppose
A65:      x is FinSeq-Location;
          then
A66:      sk12.x=sk2.x by A12,A14,A54,SCMFSA_2:92;
          sk1.x=(sk2 | Dloc).x by A8,A56,FUNCT_1:72
            .=sk2.x by A56,FUNCT_1:72;
          hence sk11.x=sk12.x by A13,A54,A65,A66,SCMFSA_2:92;
        end;
      end;
      hence P[m+1] by A15,A55,FUNCT_1:166;
    end;
    suppose InsCode i1 = 5;
      then consider da,db such that
A67:  i1 = Divide(da,db) by SCMFSA_2:58;
A68:  sk11.IC SCM+FSA= Next IC sk1 by A13,A67,SCMFSA_2:93
        .= sk12.IC SCM+FSA by A8,A12,A14,A67,SCMFSA_2:93;
      now
        let x be set;
        assume
A69:    x in Dloc;
        per cases by A1,A69,Th23;
        suppose
A70:      x is Int-Location;
A71:      da in UsedIntLoc p by A11,A67,Th16;
          then
A72:      sk1.da=(sk2 | Dloc).da by A4,A8,FUNCT_1:72
            .=sk2.da by A4,A71,FUNCT_1:72;
A73:      db in UsedIntLoc p by A11,A67,Th16;
          then
A74:      sk1.db=(sk2 | Dloc).db by A4,A8,FUNCT_1:72
            .=sk2.db by A4,A73,FUNCT_1:72;
A75:      sk1.x=(sk2 | Dloc).x by A8,A69,FUNCT_1:72
            .=sk2.x by A69,FUNCT_1:72;
          now
            per cases;
            suppose
A76:          da <> db;
              now
                per cases;
                suppose
A77:              x = da;
                  then sk11.x=sk1.da div sk1.db by A13,A67,A76,SCMFSA_2:93;
                  hence sk11.x=sk12.x by A12,A14,A67,A72,A74,A76,A77,
                  SCMFSA_2:93;
                end;
                suppose
A78:              x = db;
                  then sk11.x=sk1.da mod sk1.db by A13,A67,SCMFSA_2:93;
                  hence sk11.x=sk12.x by A12,A14,A67,A72,A74,A78, SCMFSA_2:93;
                end;
                suppose
A79:              x <> da & x <> db;
                  then sk11.x=sk1.x by A13,A67,A70,SCMFSA_2:93;
                  hence sk11.x=sk12.x by A12,A14,A67,A70,A75,A79, SCMFSA_2:93;
                end;
              end;
              hence sk11.x=sk12.x;
            end;
            suppose
A80:          da = db;
              now
                per cases;
                case
A81:              x = da;
                  then sk11.x=sk1.da mod sk1.da by A13,A67,A80,SCMFSA_2:94;
                  hence sk11.x=sk12.x by A12,A14,A67,A72,A80,A81, SCMFSA_2:94;
                end;
                case
A82:              x <> da;
                  then sk11.x=sk1.x by A13,A67,A70,A80,SCMFSA_2:94;
                  hence sk11.x=sk12.x by A12,A14,A67,A70,A75,A80,A82,
                  SCMFSA_2:94;
                end;
              end;
              hence sk11.x=sk12.x;
            end;
          end;
          hence sk11.x=sk12.x;
        end;
        suppose
A83:      x is FinSeq-Location;
          then
A84:      sk12.x=sk2.x by A12,A14,A67,SCMFSA_2:93;
          sk1.x=(sk2 | Dloc).x by A8,A69,FUNCT_1:72
            .=sk2.x by A69,FUNCT_1:72;
          hence sk11.x=sk12.x by A13,A67,A83,A84,SCMFSA_2:93;
        end;
      end;
      hence P[m+1] by A15,A68,FUNCT_1:166;
    end;
    suppose InsCode i1 = 6;
      then consider lb such that
A85:  i1 = goto lb by SCMFSA_2:59;
A86:  sk11.IC SCM+FSA=lb by A13,A85,SCMFSA_2:95
        .= sk12.IC SCM+FSA by A12,A14,A85,SCMFSA_2:95;
      now
        let x be set;
        assume
A87:    x in Dloc;
        then
A88:    sk1.x=(sk2 | Dloc).x by A8,FUNCT_1:72
          .=sk2.x by A87,FUNCT_1:72;
        per cases by A1,A87,Th23;
        suppose
A89:      x is Int-Location;
          then sk11.x=sk1.x by A13,A85,SCMFSA_2:95;
          hence sk11.x=sk12.x by A12,A14,A85,A88,A89,SCMFSA_2:95;
        end;
        suppose
A90:      x is FinSeq-Location;
          then sk11.x=sk1.x by A13,A85,SCMFSA_2:95;
          hence sk11.x=sk12.x by A12,A14,A85,A88,A90,SCMFSA_2:95;
        end;
      end;
      hence P[m+1] by A15,A86,FUNCT_1:166;
    end;
    suppose InsCode i1 = 7;
      then consider lb,da such that
A91:  i1 = da=0_goto lb by SCMFSA_2:60;
A92:  da in UsedIntLoc p by A11,A91,Th17;
      then
A93:  sk1.da=(sk2 | Dloc).da by A4,A8,FUNCT_1:72
        .=sk2.da by A4,A92,FUNCT_1:72;
A94:  now
        per cases;
        suppose
A95:      sk1.da=0;
          hence sk11.IC SCM+FSA=lb by A13,A91, SCMFSA_2:96
            .= sk12.IC SCM+FSA by A12,A14,A91,A93,A95,SCMFSA_2:96;
        end;
        suppose
A96:      sk1.da<>0;
          hence sk11.IC SCM+FSA= Next IC sk2 by A8,A13,A91,SCMFSA_2:96
            .= sk12.IC SCM+FSA by A12,A14,A91,A93,A96,SCMFSA_2:96;
        end;
      end;
      now
        let x be set;
        assume
A97:    x in Dloc;
        then
A98:    sk1.x=(sk2 | Dloc).x by A8,FUNCT_1:72
          .=sk2.x by A97,FUNCT_1:72;
        per cases by A1,A97,Th23;
        suppose
A99:      x is Int-Location;
          then sk11.x=sk1.x by A13,A91,SCMFSA_2:96;
          hence sk11.x=sk12.x by A12,A14,A91,A98,A99,SCMFSA_2:96;
        end;
        suppose
A100:     x is FinSeq-Location;
          then sk11.x=sk1.x by A13,A91,SCMFSA_2:96;
          hence sk11.x=sk12.x by A12,A14,A91,A98,A100,SCMFSA_2:96;
        end;
      end;
      hence P[m+1] by A15,A94,FUNCT_1:166;
    end;
    suppose InsCode i1 = 8;
      then consider lb,da such that
A101: i1 = da>0_goto lb by SCMFSA_2:61;
A102: da in UsedIntLoc p by A11,A101,Th17;
      then
A103: sk1.da=(sk2 | Dloc).da by A4,A8,FUNCT_1:72
        .=sk2.da by A4,A102,FUNCT_1:72;
A104: now
        per cases;
        suppose
A105:     sk1.da > 0;
          hence sk11.IC SCM+FSA=lb by A13,A101, SCMFSA_2:97
            .= sk12.IC SCM+FSA by A12,A14,A101,A103,A105,SCMFSA_2:97;
        end;
        suppose
A106:     sk1.da <= 0;
          hence sk11.IC SCM+FSA=Next IC sk2 by A8,A13,A101,SCMFSA_2:97
            .= sk12.IC SCM+FSA by A12,A14,A101,A103,A106,SCMFSA_2:97;
        end;
      end;
      now
        let x be set;
        assume
A107:   x in Dloc;
        then
A108:   sk1.x=(sk2 | Dloc).x by A8,FUNCT_1:72
          .=sk2.x by A107,FUNCT_1:72;
        per cases by A1,A107,Th23;
        suppose
A109:     x is Int-Location;
          then sk11.x=sk1.x by A13,A101,SCMFSA_2:97;
          hence sk11.x=sk12.x by A12,A14,A101,A108,A109,SCMFSA_2:97;
        end;
        suppose
A110:     x is FinSeq-Location;
          then sk11.x=sk1.x by A13,A101,SCMFSA_2:97;
          hence sk11.x=sk12.x by A12,A14,A101,A108,A110,SCMFSA_2:97;
        end;
      end;
      hence P[m+1] by A15,A104,FUNCT_1:166;
    end;
    suppose InsCode i1 = 9;
      then consider a,b,fa such that
A111: i1 = b:=(fa,a) by SCMFSA_2:62;
A112: sk11.IC SCM+FSA= Next IC sk2 by A8,A13,A111,SCMFSA_2:98
        .= sk12.IC SCM+FSA by A12,A14,A111,SCMFSA_2:98;
      now
        let x be set;
        assume
A113:   x in Dloc;
        per cases by A1,A113,Th23;
        suppose
A114:     x is Int-Location;
          now
            per cases;
            case
A115:         x = b;
              consider k1 being Element of NAT such that
A116:         k1=abs(sk1.a) & Exec(b:=(fa,a), sk1).b=(sk1.fa)/.k1
              by SCMFSA_2:98;
              consider k2 being Element of NAT such that
A117:         k2=abs(sk2.a) & Exec(b:=(fa,a), sk2).b=(sk2.fa)/.k2
              by SCMFSA_2:98;
A118:         a in UsedIntLoc p by A11,A111,Th18;
              then
A119:         sk1.a=(sk2 | Dloc).a by A4,A8,FUNCT_1:72
                .=sk2.a by A4,A118,FUNCT_1:72;
A120:         fa in UsedInt*Loc p by A11,A111,Th19;
              then sk1.fa=(sk2 | Dloc).fa by A5,A8,FUNCT_1:72
                .=sk2.fa by A5,A120,FUNCT_1:72;
              hence sk11.x=sk12.x by A12,A13,A14,A111,A115,A116,A117,A119;
            end;
            case
A121:         x<> b;
              then
A122:         sk12.x=sk2.x by A12,A14,A111,A114,SCMFSA_2:98;
              sk1.x=(sk2 | Dloc).x by A8,A113,FUNCT_1:72
                .=sk2.x by A113,FUNCT_1:72;
              hence sk11.x=sk12.x by A13,A111,A114,A121,A122,SCMFSA_2:98;
            end;
          end;
          hence sk11.x=sk12.x;
        end;
        suppose
A123:     x is FinSeq-Location;
          then
A124:     sk12.x=sk2.x by A12,A14,A111,SCMFSA_2:98;
          sk1.x=(sk2 | Dloc).x by A8,A113,FUNCT_1:72
            .=sk2.x by A113,FUNCT_1:72;
          hence sk11.x=sk12.x by A13,A111,A123,A124,SCMFSA_2:98;
        end;
      end;
      hence P[m+1] by A15,A112,FUNCT_1:166;
    end;
    suppose InsCode i1 = 10;
      then consider a,b,fa such that
A125: i1 = (fa,a):=b by SCMFSA_2:63;
A126: sk11.IC SCM+FSA= Next IC sk2 by A8,A13,A125,SCMFSA_2:99
        .= sk12.IC SCM+FSA by A12,A14,A125,SCMFSA_2:99;
      now
        let x be set;
        assume
A127:   x in Dloc;
        per cases by A1,A127,Th23;
        suppose
A128:     x is FinSeq-Location;
          now
            per cases;
            case
A129:         x = fa;
              consider k1 being Element of NAT such that
A130:         k1=abs(sk1.a) & Exec((fa,a):=b,sk1).fa=sk1.fa+*(k1,sk1.b)
              by SCMFSA_2:99;
              consider k2 being Element of NAT such that
A131:         k2=abs(sk2.a) & Exec((fa,a):=b,sk2).fa=sk2.fa+*(k2,sk2.b)
              by SCMFSA_2:99;
A132:         a in UsedIntLoc p by A11,A125,Th18;
              then
A133:         sk1.a=(sk2 | Dloc).a by A4,A8,FUNCT_1:72
                .=sk2.a by A4,A132,FUNCT_1:72;
A134:         b in UsedIntLoc p by A11,A125,Th18;
              then
A135:         sk1.b=(sk2 | Dloc).b by A4,A8,FUNCT_1:72
                .=sk2.b by A4,A134,FUNCT_1:72;
A136:         fa in UsedInt*Loc p by A11,A125,Th19;
              then sk1.fa=(sk2 | Dloc).fa by A5,A8,FUNCT_1:72
                .=sk2.fa by A5,A136,FUNCT_1:72;
              hence sk11.x=sk12.x by A12,A13,A14,A125,A129,A130,A131,A133
              ,A135;
            end;
            case
A137:         x<> fa;
              then
A138:         sk12.x=sk2.x by A12,A14,A125,A128,SCMFSA_2:99;
              sk1.x=(sk2 | Dloc).x by A8,A127,FUNCT_1:72
                .=sk2.x by A127,FUNCT_1:72;
              hence sk11.x=sk12.x by A13,A125,A128,A137,A138,SCMFSA_2:99;
            end;
          end;
          hence sk11.x=sk12.x;
        end;
        suppose
A139:     x is Int-Location;
          then
A140:     sk12.x=sk2.x by A12,A14,A125,SCMFSA_2:99;
          sk1.x=(sk2 | Dloc).x by A8,A127,FUNCT_1:72
            .=sk2.x by A127,FUNCT_1:72;
          hence sk11.x=sk12.x by A13,A125,A139,A140,SCMFSA_2:99;
        end;
      end;
      hence P[m+1] by A15,A126,FUNCT_1:166;
    end;
    suppose InsCode i1 = 11;
      then consider a,fa such that
A141: i1 = a:=len fa by SCMFSA_2:64;
A142: sk11.IC SCM+FSA= Next IC sk2 by A8,A13,A141,SCMFSA_2:100
        .= sk12.IC SCM+FSA by A12,A14,A141,SCMFSA_2:100;
      now
        let x be set;
        assume
A143:   x in Dloc;
        per cases by A1,A143,Th23;
        suppose
A144:     x is Int-Location;
          now
            per cases;
            case
A145:         x = a;
              then
A146:         sk12.x= len(sk2.fa) by A12,A14,A141,SCMFSA_2: 100;
A147:         fa in UsedInt*Loc p by A11,A141,Th21;
              then sk1.fa=(sk2 | Dloc).fa by A5,A8,FUNCT_1:72
                .=sk2.fa by A5,A147,FUNCT_1:72;
              hence sk11.x=sk12.x by A13,A141,A145,A146,SCMFSA_2:100;
            end;
            case
A148:         x<> a;
              then
A149:         sk12.x=sk2.x by A12,A14,A141,A144,SCMFSA_2:100;
              sk1.x=(sk2 | Dloc).x by A8,A143,FUNCT_1:72
                .=sk2.x by A143,FUNCT_1:72;
              hence sk11.x=sk12.x by A13,A141,A144,A148,A149,SCMFSA_2:100;
            end;
          end;
          hence sk11.x=sk12.x;
        end;
        suppose
A150:     x is FinSeq-Location;
          then
A151:     sk12.x=sk2.x by A12,A14,A141,SCMFSA_2:100;
          sk1.x=(sk2 | Dloc).x by A8,A143,FUNCT_1:72
            .=sk2.x by A143,FUNCT_1:72;
          hence sk11.x=sk12.x by A13,A141,A150,A151,SCMFSA_2:100;
        end;
      end;
      hence P[m+1] by A15,A142,FUNCT_1:166;
    end;
    suppose InsCode i1 = 12;
      then consider a,fa such that
A152: i1 = fa:=<0,...,0>a by SCMFSA_2:65;
A153: sk11.IC SCM+FSA=Next IC sk2 by A8,A13,A152,SCMFSA_2:101
        .= sk12.IC SCM+FSA by A12,A14,A152,SCMFSA_2:101;
      now
        let x be set;
        assume
A154:   x in Dloc;
        per cases by A1,A154,Th23;
        suppose
A155:     x is FinSeq-Location;
          now
            per cases;
            case
A156:         x = fa;
              consider k1 being Element of NAT such that
A157:         k1 = abs(sk1.a) & Exec(fa:=<0,...,0>a, sk1).fa = k1 |-> 0
              by SCMFSA_2:101;
              consider k2 being Element of NAT such that
A158:         k2 = abs(sk2.a) & Exec(fa:=<0,...,0>a, sk2).fa = k2 |-> 0
              by SCMFSA_2:101;
A159:         a in UsedIntLoc p by A11,A152,Th20;
              then sk1.a=(sk2 | Dloc).a by A4,A8,FUNCT_1:72
                .=sk2.a by A4,A159,FUNCT_1:72;
              hence sk11.x=sk12.x by A12,A13,A14,A152,A156,A157,A158;
            end;
            case
A160:         x<> fa;
              then
A161:         sk12.x=sk2.x by A12,A14,A152,A155,SCMFSA_2:101;
              sk1.x=(sk2 | Dloc).x by A8,A154,FUNCT_1:72
                .=sk2.x by A154,FUNCT_1:72;
              hence sk11.x=sk12.x by A13,A152,A155,A160,A161,SCMFSA_2:101;
            end;
          end;
          hence sk11.x=sk12.x;
        end;
        suppose
A162:     x is Int-Location;
          then
A163:     sk12.x=sk2.x by A12,A14,A152,SCMFSA_2:101;
          sk1.x=(sk2 | Dloc).x by A8,A154,FUNCT_1:72
            .=sk2.x by A154,FUNCT_1:72;
          hence sk11.x=sk12.x by A13,A152,A162,A163,SCMFSA_2:101;
        end;
      end;
      hence P[m+1] by A15,A153,FUNCT_1:166;
    end;
  end;
  for m being Element of NAT holds P[m] from NAT_1:sch 1(A6,A7);
  hence thesis by A3;
end;

theorem Th26:
  for i,k being Element of NAT,p being Program of SCM+FSA,
  s1,s2 being State of SCM+FSA st k <= i & p c= s1 & p c= s2 &
  (for j holds IC Computation(s1,j) in dom p &
  IC Computation(s2,j) in dom p) &
  Computation(s1,k).IC SCM+FSA = Computation(s2,k).IC SCM+FSA &
  Computation(s1,k) | (UsedInt*Loc p \/ UsedIntLoc p) =
  Computation(s2,k) | (UsedInt*Loc p \/ UsedIntLoc p) holds
  Computation(s1,i).IC SCM+FSA = Computation(s2,i).IC SCM+FSA &
  Computation(s1,i) |(UsedInt*Loc p \/ UsedIntLoc p) =
  Computation(s2,i) |(UsedInt*Loc p \/ UsedIntLoc p)
proof
  let i,k be Element of NAT,p be Program of SCM+FSA,s1,s2 be State of SCM+FSA;
  set D= UsedInt*Loc p \/ UsedIntLoc p;
  assume
A1: k <= i & p c= s1 & p c= s2 &
  (for j holds IC Computation(s1,j) in dom p & IC Computation(s2,j) in dom p) &
  Computation(s1,k).IC SCM+FSA = Computation(s2,k).IC SCM+FSA &
  Computation(s1,k) | D = Computation(s2,k) | D;
  reconsider t={} as FinPartState of SCM+FSA by CARD_3:66;
  set D1= dom t \/ UsedInt*Loc p \/ UsedIntLoc p;
A2: dom t c= Int-Locations \/ FinSeq-Locations by RELAT_1:60,XBOOLE_1:2;
A3: D1 = D by RELAT_1:60;
  hence Computation(s1,i).IC SCM+FSA = Computation(s2,i).IC SCM+FSA
   by A1,A2,Th25;
  thus Computation(s1,i) | D = Computation(s2,i) | D by A1,A2,A3,Th25;
end;

canceled 2;

theorem Th29:
  for I,J being Program of SCM+FSA, a being Int-Location holds
  UsedIntLoc if=0(a,I,J) = {a} \/ UsedIntLoc I \/ UsedIntLoc J &
  UsedIntLoc if>0(a,I,J) = {a} \/ UsedIntLoc I \/ UsedIntLoc J
proof
  let I,J be Program of SCM+FSA, a be Int-Location;
  set g1= a=0_goto insloc (card J + 3), g2= Goto insloc (card I + 1),
  g3= a>0_goto insloc (card J + 3), SS=Stop SCM+FSA;
  thus UsedIntLoc if=0(a,I,J) =UsedIntLoc (g1 ';' J ';' g2 ';'I ';' SS)
  by SCMFSA8B:def 1
    .=UsedIntLoc (g1 ';' J ';' g2 ';'I) \/ {} by SCMFSA9A:9,SF_MASTR:31
    .=UsedIntLoc (g1 ';' J ';' g2) \/ UsedIntLoc I by SF_MASTR:31
    .=UsedIntLoc (g1 ';' J) \/ UsedIntLoc g2 \/ UsedIntLoc I by SF_MASTR:31
    .=UsedIntLoc (g1 ';' J) \/ {} \/ UsedIntLoc I by SCMFSA9A:11
    .=UsedIntLoc g1 \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:33
    .={a} \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:20
    .={a} \/ UsedIntLoc I \/ UsedIntLoc J by XBOOLE_1:4;
  thus UsedIntLoc if>0(a,I,J) =UsedIntLoc (g3 ';' J ';' g2 ';'I ';' SS)
  by SCMFSA8B:def 2
    .=UsedIntLoc (g3 ';' J ';' g2 ';'I) \/ {} by SCMFSA9A:9,SF_MASTR:31
    .=UsedIntLoc (g3 ';' J ';' g2) \/ UsedIntLoc I by SF_MASTR:31
    .=UsedIntLoc (g3 ';' J) \/ UsedIntLoc g2 \/ UsedIntLoc I by SF_MASTR:31
    .=UsedIntLoc (g3 ';' J) \/ {} \/ UsedIntLoc I by SCMFSA9A:11
    .=UsedIntLoc g3 \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:33
    .={a} \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:20
    .={a} \/ UsedIntLoc I \/ UsedIntLoc J by XBOOLE_1:4;
end;

theorem Th30:
  for I be Program of SCM+FSA,l be Instruction-Location of SCM+FSA holds
  UsedIntLoc (Directed(I,l)) = UsedIntLoc I
proof
  let I be Program of SCM+FSA,l be Instruction-Location of SCM+FSA;
  consider UIL being Function of the Instructions of SCM+FSA,
  Fin Int-Locations such that
A1: (for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i) &
  UsedIntLoc I = Union (UIL * I) by SF_MASTR:def 2;
  consider UIL2 being Function of the Instructions of SCM+FSA,
  Fin Int-Locations such that
A2: (for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i) &
  UsedIntLoc Directed(I,l) = Union (UIL2 * Directed(I,l)) by SF_MASTR:def 2;
A3: for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL2.c by A2;
  end;
A4: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
A6: UIL.halt SCM+FSA = {} by A1,SF_MASTR:17;
A7: UIL.goto l = UsedIntLoc goto l by A1
    .= {} by SF_MASTR:19;
  rng I c= the Instructions of SCM+FSA by AMI_1:118;
  then UIL * Directed(I,l) = UIL * (((id the Instructions of SCM+FSA) +*
  (halt SCM+FSA,goto l))*I) by FUNCT_7:118
    .= UIL * ((id the Instructions of SCM+FSA) +*
  (halt SCM+FSA, goto l)) * I by RELAT_1:55
    .= UIL * I by A4,A6,A7,FUNCT_7:110;
  hence thesis by A1,A2,A3,FUNCT_2:113;
end;

theorem Th31:
  for a being Int-Location,I being Program of SCM+FSA holds
  UsedIntLoc Times(a,I) = UsedIntLoc I \/ {a,intloc 0}
proof
  let a be Int-Location,I be Program of SCM+FSA;
  set g1=Goto insloc 2, SF=SubFrom(a,intloc 0), if0=if=0(a,g1,I ';' SF); thus
  UsedIntLoc Times(a,I) ={a} \/ UsedIntLoc loop if0 \/ {} by Th29, SCMFSA9A:9
    .={a} \/ UsedIntLoc if0 by Th30
    .={a} \/ ({a} \/ UsedIntLoc g1 \/ UsedIntLoc (I ';' SF)) by Th29
    .={a} \/ ({a} \/ {} \/ UsedIntLoc (I ';' SF)) by SCMFSA9A:11
    .={a} \/ {a} \/ UsedIntLoc (I ';' SF) by XBOOLE_1:4
    .=UsedIntLoc I \/ UsedIntLoc SF \/ {a} by SF_MASTR:34
    .=UsedIntLoc I \/ {a,intloc 0} \/ {a} by SF_MASTR:18
    .=UsedIntLoc I \/ ({a} \/ {a,intloc 0}) by XBOOLE_1:4
    .=UsedIntLoc I \/ {a,a,intloc 0} by ENUMSET1:42
    .=UsedIntLoc I \/ {a,intloc 0} by ENUMSET1:70;
end;

canceled 3;

theorem
  for I,J being Program of SCM+FSA, a being Int-Location holds
  UsedInt*Loc if=0(a,I,J) = UsedInt*Loc I \/ UsedInt*Loc J &
  UsedInt*Loc if>0(a,I,J) = UsedInt*Loc I \/ UsedInt*Loc J by SCMFSA9A:14,16;

theorem Th36:
  for I be Program of SCM+FSA,l be Instruction-Location of SCM+FSA holds
  UsedInt*Loc (Directed(I,l)) = UsedInt*Loc I
proof
  let I be Program of SCM+FSA,l be Instruction-Location of SCM+FSA;
  consider UIL being Function of the Instructions of SCM+FSA,
  Fin FinSeq-Locations such that
A1: (for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i) &
  UsedInt*Loc I = Union (UIL * I) by SF_MASTR:def 4;
  consider UIL2 being Function of the Instructions of SCM+FSA,
  Fin FinSeq-Locations such that
A2: (for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i) &
  UsedInt*Loc Directed(I,l) = Union (UIL2 * Directed(I,l)) by SF_MASTR:def 4;
A3: for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL2.c by A2;
  end;
A4: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
A6: UIL.halt SCM+FSA = UsedInt*Loc halt SCM+FSA by A1
    .= {} by SF_MASTR:36;
A7: UIL.goto l = UsedInt*Loc goto l by A1
    .= {} by SF_MASTR:36;
  rng I c= the Instructions of SCM+FSA by AMI_1:118;
  then UIL * Directed(I,l) = UIL * (((id the Instructions of SCM+FSA) +*
  (halt SCM+FSA,goto l))*I) by FUNCT_7:118
    .= UIL * ((id the Instructions of SCM+FSA) +*
  (halt SCM+FSA,goto l)) * I by RELAT_1:55
    .= UIL * I by A4,A6,A7,FUNCT_7:110;
  hence thesis by A1,A2,A3,FUNCT_2:113;
end;

theorem Th37:
  for a being Int-Location,I being Program of SCM+FSA holds
  UsedInt*Loc Times(a,I) = UsedInt*Loc I
proof
  let a be Int-Location,I be Program of SCM+FSA;
  set g1=Goto insloc 2, SF=SubFrom(a,intloc 0), if0=if=0(a,g1,I ';' SF);
  thus UsedInt*Loc Times(a,I) =UsedInt*Loc loop if0 \/ {} by SCMFSA9A:10,16
    .=UsedInt*Loc if0 by Th36
    .=UsedInt*Loc g1 \/ UsedInt*Loc (I ';' SF) by SCMFSA9A:14
    .={} \/ UsedInt*Loc (I ';' SF) by SCMFSA9A:12
    .=UsedInt*Loc I \/ UsedInt*Loc SF by SF_MASTR:50
    .=UsedInt*Loc I \/ {} by SF_MASTR:36
    .=UsedInt*Loc I;
end;

definition
  let f be FinSeq-Location,t be FinSequence of INT;
  redefine func f .--> t -> FinPartState of SCM+FSA;
  coherence
  proof
    t is Element of INT* & ObjectKind f = INT* by FINSEQ_1:def 11,SCMFSA_2:27;
    hence thesis by AMI_1:59;
  end;
end;

theorem
  for t be FinSequence of INT holds t is FinSequence of REAL by FINSEQ_3:126;

theorem Th39:
  for t being FinSequence of INT holds ex u being FinSequence of REAL
  st t,u are_fiberwise_equipotent & u is FinSequence of INT
  & u is non-increasing
proof
  let t be FinSequence of INT;
  t is FinSequence of REAL by FINSEQ_3:126;
  then consider u be non-increasing FinSequence of REAL such that
A1: t,u are_fiberwise_equipotent by RFINSEQ:35;
  take u;
  thus t,u are_fiberwise_equipotent by A1;
  rng t = rng u by A1,RFINSEQ:1;
  hence u is FinSequence of INT by FINSEQ_1:def 4;
  thus u is non-increasing;
end;

theorem Th40:
  dom( ((intloc 0) .--> 1) +* Start-At(insloc 0) ) ={intloc 0,IC SCM+FSA}
proof
  thus dom( ((intloc 0) .--> 1) +* Start-At(insloc 0) )
  =dom ((intloc 0) .--> 1) \/ dom Start-At(insloc 0) by FUNCT_4:def 1
    .=dom ((intloc 0) .--> 1) \/ {IC SCM+FSA} by FUNCOP_1:19
    .={intloc 0} \/ {IC SCM+FSA} by FUNCOP_1:19
    .={intloc 0,IC SCM+FSA} by ENUMSET1:41;
end;

theorem Th41:
  for I be Program of SCM+FSA holds
  dom (Initialized I) = dom I \/ {intloc 0,IC SCM+FSA}
proof
  let I be Program of SCM+FSA;
  thus dom(Initialized I)
    =dom(I +* (((intloc 0) .--> 1) +* Start-At(insloc 0))) by FUNCT_4:15
    .=dom I \/ { intloc 0,IC SCM+FSA } by Th40,FUNCT_4:def 1;
end;

theorem Th42:
  for w being FinSequence of INT,f be FinSeq-Location,I be Program of SCM+FSA
  holds dom (Initialized I +* (f.--> w)) = dom I \/ {intloc 0,IC SCM+FSA,f}
proof
  let w be FinSequence of INT,f be FinSeq-Location, I be Program of SCM+FSA;
  dom (Initialized I +* (f .--> w)) =
  dom(Initialized I ) \/ dom (f.--> w) by FUNCT_4:def 1
    .=dom(Initialized I ) \/ {f} by FUNCOP_1:19
    .=dom I \/ { intloc 0,IC SCM+FSA } \/ {f} by Th41
    .=dom I \/ ({ intloc 0,IC SCM+FSA } \/ {f}) by XBOOLE_1:4;
  hence thesis by ENUMSET1:43;
end;

theorem
  for l being Instruction-Location of SCM+FSA holds IC SCM+FSA <> l
proof
  let l be Instruction-Location of SCM+FSA;
  ObjectKind l = the Instructions of SCM+FSA & ObjectKind IC SCM+FSA = NAT
  by AMI_1:def 11,def 14;
  hence thesis by SCMFSA_1:13;
end;

theorem Th44:
  for a being Int-Location,I being Program of SCM+FSA holds
  card Times(a,I) = card I + 12
proof
  let a be Int-Location,I be Program of SCM+FSA;
  set g1=Goto insloc 2, SF=SubFrom(a,intloc 0), if0=if=0(a,g1,I ';' SF);
  thus card Times(a,I)= card (loop if0)+1+4 by SCMFSA8A:17,SCMFSA8B:15
    .= card (loop if0)+(1+4)
    .= card if0 +5 by SCMFSA8A:33
    .= card (I ';' SF)+card g1+4+5 by SCMFSA8B:14
    .= card (I ';' SF)+1+4+5 by SCMFSA8A:29
    .= card I + card (Macro SF)+1+4+5 by SCMFSA6A:61
    .= card I+2+1+4+5 by SCMFSA7B:6
    .= card I+12;
end;

theorem Th45:
  for i1,i2,i3 be Instruction of SCM+FSA holds card (i1 ';' i2 ';' i3)=6
proof
  let i1,i2,i3 be Instruction of SCM+FSA;
  thus card (i1 ';' i2 ';' i3)
    = card (i1 ';' i2) + card Macro i3 by SCMFSA6A:61
    .= card (i1 ';' i2) + 2 by SCMFSA7B:6
    .= card Macro i1 + card Macro i2 +2 by SCMFSA6A:61
    .= 2 + card Macro i2 +2 by SCMFSA7B:6
    .= 2 + 2 +2 by SCMFSA7B:6
    .= 6;
end;

theorem Th46:
  for t be FinSequence of INT,f be FinSeq-Location,I be Program of SCM+FSA
  holds dom (Initialized I) misses dom (f .--> t)
proof
  let t be FinSequence of INT,f be FinSeq-Location,I be Program of SCM+FSA;
  set x = f .--> t;
A1: dom x ={f} by FUNCOP_1:19;
  set DB= dom I, DI=dom (Initialized I);
A2: DI=DB \/ { intloc 0,IC SCM+FSA } by Th41;
  assume DI /\ dom x <> {};
  then consider y being set such that
A3: y in DI /\ dom x by XBOOLE_0:def 1;
A4: y in DI & y in dom x by A3,XBOOLE_0:def 3;
  then
A5: y=f by A1,TARSKI:def 1;
A6: DB c= NAT by AMI_1:def 40;
  now
    assume y in DB;
    then reconsider y as Instruction-Location of SCM+FSA by A6,AMI_1:def 4;
    y=y;
    hence contradiction by A5,SCMFSA_2:85;
  end;
  then y in {intloc 0,IC SCM+FSA } by A2,A4,XBOOLE_0:def 2;
  then y=intloc 0 or y=IC SCM+FSA by TARSKI:def 2;
  hence contradiction by A5,SCMFSA_2:82,83;
end;

theorem Th47:
  for w be FinSequence of INT,f be FinSeq-Location,I be Program of SCM+FSA
  holds Initialized I +* (f .--> w) starts_at 0
proof
  let w be FinSequence of INT,f be FinSeq-Location, I be Program of SCM+FSA;
  set p = Initialized I, s = f .--> w;
A1: dom p misses dom s by Th46;
  then
A2: p c= p +* s by FUNCT_4:33;
A3: dom p = dom I \/ {intloc 0,IC SCM+FSA} by Th41;
A4: dom p c= dom(p +* s) by A2,RELAT_1:25;
  IC SCM+FSA in {intloc 0,IC SCM+FSA } by TARSKI:def 2;
  then
A5: IC SCM+FSA in dom p by A3,XBOOLE_0:def 2;
  then
A6: not IC SCM+FSA in dom s by A1,XBOOLE_0:3; thus
  IC SCM+FSA in dom(p +* s) by A4,A5;
  thus IC(p +* s) = (p +* s).IC SCM+FSA by A4,A5,AMI_1:def 43
    .= p.IC SCM+FSA by A6,FUNCT_4:12
    .= 0 by SCMFSA6A:46;
end;

theorem Th48:
  for I,J being Program of SCM+FSA, k being Element of NAT,
  i being Instruction of SCM+FSA st k< card J & i = J.insloc k holds
  (I ';' J).(insloc (card I +k)) =IncAddr( i, card I )
proof
  let I,J be Program of SCM+FSA, k be Element of NAT,
  i be Instruction of SCM+FSA such that
A1: k< card J and
A2: i = J.insloc k;
  set m=card I +k;
A3: m < card I + card J by A1,XREAL_1:8;
  insloc(m -' card I) =insloc k by NAT_D:34;
  hence thesis by A2,A3,NAT_1:11,SCMFSA8C:13;
end;

theorem
  ic = a:=b or ic = AddTo(a, b) or ic = SubFrom(a, b) or
  ic = MultBy(a, b) or ic = Divide(a, b) or ic = goto la or ic = a=0_goto la
  or ic = a>0_goto la or ic = b := (f, a) or ic = (f, a) := b or
  ic = a :=len f or ic = f :=<0,...,0>a implies ic <> halt SCM+FSA
  by SCMFSA_2:42,43,44,45,46,47,48,49,50,51,52,53,124;

theorem Th50:
  for I,J be Program of SCM+FSA,k be Element of NAT,
  i be Instruction of SCM+FSA st
  (for n be Element of NAT holds IncAddr( i, n)=i) & i <> halt SCM+FSA &
  k= card I holds (I ';' i ';' J).(insloc k) = i &
  (I ';' i ';' J).(insloc (k+1)) = goto insloc (card I+2)
proof
  let I,J be Program of SCM+FSA, k be Element of NAT,
  i be Instruction of SCM+FSA;
  assume
A1: (for n be Element of NAT holds IncAddr( i, n)=i) & i <> halt SCM+FSA &
  k= card I;
  set x1=insloc k;
A3: card (I ';' i) = card I + card Macro i by SCMFSA6A:61
    .= card I +2 by SCMFSA7B:6;
  card I + 0 < card I + 2 by XREAL_1:8;
  then
A4: x1 in dom (I ';' i) by A1,A3,SCMFSA6A:15;
A5: (Macro i).(insloc 0) = i by SCMFSA6B:33;
A6: card (Macro i) = 2 by SCMFSA7B:6;
A7: (I ';' i).x1 = (I ';' Macro i).insloc (card I+0) by A1
    .=IncAddr( i, card I ) by A5,A6,Th48
    .=i by A1;
  thus (I ';' i ';' J).x1 = (Directed (I ';' i)).x1 by A4,SCMFSA8A:28
    .=i by A1,A4,A7,SCMFSA8A:30;
  set x2=insloc (k+1);
  card I + 1 < card I + 2 by XREAL_1:8;
  then
A8: x2 in dom (I ';' i) by A1,A3,SCMFSA6A:15;
  (Macro i).(insloc 1) = halt SCM+FSA by SCMFSA6B:33;
  then
A9: (I ';' i).x2 =IncAddr( halt SCM+FSA, card I ) by A1,A6,Th48
    .=halt SCM+FSA by SCMFSA_4:8;
  thus (I ';' i ';' J).x2 = (Directed (I ';' i)).x2 by A8,SCMFSA8A:28
    .= goto insloc (card I+2) by A3,A8,A9,SCMFSA8A:30;
end;

theorem Th51:
  for I,J being Program of SCM+FSA, k being Element of NAT holds
  k= card I implies (I ';'(a:=b) ';' J).(insloc k) = a:= b
  & (I ';'(a:=b) ';' J).(insloc (k+1)) = goto insloc (card I+2)
proof
  let I,J be Program of SCM+FSA,k be Element of NAT;
  assume
A1: k= card I;
  set i=a:=b;
A2: for n be Element of NAT holds IncAddr(i, n)=i by SCMFSA_4:9;
  i <> halt SCM+FSA by SCMFSA_2:42,124;
  hence thesis by A1,A2,Th50;
end;

theorem Th52:
  for I,J being Program of SCM+FSA, k being Element of NAT holds
  k= card I implies (I ';'(a:=len f) ';' J).(insloc k) = a:=len f
  & (I ';'(a:=len f) ';' J).(insloc (k+1)) = goto insloc (card I+2)
proof
  let I,J be Program of SCM+FSA,k be Element of NAT;
  assume
A1: k= card I;
  set i=a:=len f;
A2: for n be Element of NAT holds IncAddr(i, n)=i by SCMFSA_4:19;
  i <> halt SCM+FSA by SCMFSA_2:52,124;
  hence thesis by A1,A2,Th50;
end;

theorem Th53:
  for w being FinSequence of INT,f be FinSeq-Location,s being State of SCM+FSA,
  I be Program of SCM+FSA st Initialized I +* (f.--> w) c= s holds I c= s
proof
  let w be FinSequence of INT,f be FinSeq-Location,s be State of SCM+FSA,
  I be Program of SCM+FSA;
  set t= f .--> w, p=Initialized I;
  assume
A1: p +* t c= s;
  dom p misses dom t by Th46;
  then
A2: p c= p +* t by FUNCT_4:33;
  I c= p by SCMFSA6A:26;
  then I c= p +* t by A2,XBOOLE_1:1;
  hence I c= s by A1,XBOOLE_1:1;
end;

theorem Th54:
  for w being FinSequence of INT,f be FinSeq-Location,s be State of SCM+FSA,
  I be Program of SCM+FSA st Initialized I +* (f .--> w) c= s
  holds s.f = w & s.(intloc 0) = 1
proof
  let w be FinSequence of INT,f be FinSeq-Location,
  s be State of SCM+FSA,I be Program of SCM+FSA;
  set t= f.--> w, p=Initialized I;
  assume
A1: p +* t c= s;
A2: dom t = { f} by FUNCOP_1:19;
  then
A3: f in dom t by TARSKI:def 1;
  intloc 0 <> f by SCMFSA_2:83;
  then
A4: not intloc 0 in dom t by A2,TARSKI:def 1;
  intloc 0 in dom p by SCMFSA6A:45;
  then
A5: intloc 0 in dom (p +* t) by FUNCT_4:13;
  t c= p +* t by FUNCT_4:26;
  then t c= s by A1,XBOOLE_1:1;
  hence s.f = t.f by A3,GRFUNC_1:8
    .= w by FUNCOP_1:87;
  thus s.intloc 0 = (p +* t).intloc 0 by A1,A5,GRFUNC_1:8
    .=p.intloc 0 by A4,FUNCT_4:12
    .= 1 by SCMFSA6A:46;
end;

theorem Th55:
  for f being FinSeq-Location,a being Int-Location,s being State of SCM+FSA
  holds {a,IC SCM+FSA,f} c= dom s
proof
  let f be FinSeq-Location,a be Int-Location,s be State of SCM+FSA;
A1: a in dom s by SCMFSA_2:66;
  IC SCM+FSA in dom s by SCMFSA8B:1;
  then
A2: {a,IC SCM+FSA} c= dom s by A1,ZFMISC_1:38;
  f in dom s by SCMFSA_2:67;
  then { f } c= dom s by ZFMISC_1:37;
  then {a,IC SCM+FSA} \/ {f} c= dom s by A2,XBOOLE_1:8;
  hence thesis by ENUMSET1:43;
end;

theorem Th56:
  for p being Program of SCM+FSA,s being State of SCM+FSA holds
  UsedInt*Loc p \/ UsedIntLoc p c= dom s
proof
  let p be Program of SCM+FSA,s be State of SCM+FSA;
  Int-Locations c= dom(s) by SCMFSA_2:69;
  then
A1: UsedIntLoc p c= dom(s) by XBOOLE_1:1;
  FinSeq-Locations c= dom (s) by SCMFSA_2:70;
  then UsedInt*Loc p c= dom(s) by XBOOLE_1:1;
  hence thesis by A1,XBOOLE_1:8;
end;

theorem Th57:
  for s be State of SCM+FSA,I be Program of SCM+FSA,f be FinSeq-Location
  holds (Result (s +* Initialized I)).f = IExec(I,s).f
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA,f be FinSeq-Location;
  set D= Int-Locations \/ FinSeq-Locations;
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A1: f in D by XBOOLE_0:def 2;
  hence (Result (s +* Initialized I)).f
  = (DataPart Result (s +* Initialized I)).f by FUNCT_1:72,SCMFSA_2:127
    .=(DataPart IExec(I,s)).f by SCMFSA8B:35
    .= IExec(I,s).f by A1,FUNCT_1:72,SCMFSA_2:127;
end;

:: ------   Bubble Sort Algorithm -----------------
set a0 = intloc 0;
set a1 = intloc 1;
set a2 = intloc 2;
set a3 = intloc 3;
set a4 = intloc 4;
set a5 = intloc 5;
set a6 = intloc 6;

Lm1: a0 <> a1 & a0 <> a2 & a0 <> a3 & a0 <> a4 & a0 <> a5 & a0 <> a6 &
a1 <> a2 & a1 <> a3 & a1 <> a4 & a1 <> a5 & a1 <> a6 &
a2 <> a3 & a2 <> a4 & a2 <> a5 & a2 <> a6 & a3 <> a4 & a3 <> a5 & a3 <> a6 &
a4 <> a5 & a4 <> a6 & a5 <> a6 by AMI_3:52;
set initializeWorkMem= (a2:= a0) ';' (a3:= a0) ';'
(a4:= a0) ';' (a5:= a0) ';' (a6:= a0);

:: set a0 = intloc 0;
:: set a1 = intloc 1;
:: set a2 = intloc 2;
:: set a3 = intloc 3;
:: set a4 = intloc 4;
:: set a5 = intloc 5;
:: set a6 = intloc 6;
:: set initializeWorkMem= (a2:= a0) ';' (a3:= a0) ';'
::                  (a4:= a0) ';' (a5:= a0) ';' (a6:= a0);

definition
  let f be FinSeq-Location;
  func bubble-sort f -> Program of SCM+FSA equals
  ( ((intloc 2):= (intloc 0)) ';' ((intloc 3):= (intloc 0)) ';'
  ((intloc 4):= (intloc 0)) ';' ((intloc 5):= (intloc 0)) ';'
  ((intloc 6):= (intloc 0)) ) ';' ((intloc 1):=len f) ';' Times((intloc 1),
  (intloc 2) := (intloc 1) ';' SubFrom(intloc 2,intloc 0) ';'
  ((intloc 3):=len f) ';' Times(intloc 2, (intloc 4):=(intloc 3) ';'
  SubFrom(intloc 3,intloc 0) ';' ((intloc 5):=(f,intloc 3)) ';'
  ((intloc 6):=(f,(intloc 4))) ';' SubFrom(intloc 6,intloc 5) ';'
  if>0(intloc 6,((intloc 6):=(f,intloc 4)) ';' ((f,intloc 3):=(intloc 6)) ';'
  ((f,intloc 4):=(intloc 5)),Stop SCM+FSA) ) );
  correctness;
end;

definition
  func Bubble-Sort-Algorithm -> Program of SCM+FSA equals

  bubble-sort fsloc 0;
  coherence;
end;
set b1=intloc (0+1),b2=intloc (1+1),b3=intloc (2+1),b4=intloc (3+1),
b5=intloc (4+1),b6=intloc (5+1);
set f0=fsloc 0, i1= b4:=b3, i2= SubFrom(b3,a0), i3= b5:=(f0,b3),
i4= b6:=(f0,b4), i5= SubFrom(b6,b5), i6= (f0,b3):=b6, i7= (f0,b4):=b5,
SS= Stop SCM+FSA, ifc=if>0(b6,i4 ';' i6 ';' i7,SS),
body2= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' ifc, T2=Times(b2,body2),
j1= b2 := b1, j2= SubFrom(b2,a0), j3= b3:=len f0, Sb= j1 ';' j2 ';' j3,
body1= Sb ';' T2, T1=Times(b1,body1), w2= b2:= a0, w3= b3:= a0, w4= b4:= a0,
w5= b5:= a0, w6= b6:= a0, w7= b1:=len f0;

theorem Th58:
  for f being FinSeq-Location holds
  UsedIntLoc (bubble-sort f) = {intloc 0,intloc 1,intloc 2,intloc 3, intloc 4,
  intloc 5,intloc 6}
proof
  let f be FinSeq-Location;
  set i1= a4:=a3, i2= SubFrom(a3,a0), i3= (a5:=(f,a3)), i4= (a6:=(f,a4)),
  i5= SubFrom(a6,a5), i6= ((f,a3):=a6), i7= ((f,a4):=a5),
  ifc=if>0(a6,i4 ';' i6 ';' i7,Stop SCM+FSA), Sif= UsedIntLoc ifc,
  body2= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' ifc;
A1: Sif = {a4,a3,a6,a5}
  proof thus
    Sif = {a6} \/ UsedIntLoc (i4 ';' i6 ';' i7) \/ {} by Th29,SCMFSA9A:9
      .= {a6} \/ (UsedIntLoc (i4 ';' i6) \/ UsedIntLoc i7) by SF_MASTR:34
      .= {a6} \/ (UsedIntLoc (i4 ';' i6) \/ {a4,a5}) by SF_MASTR:21
      .= {a6} \/ (UsedIntLoc i4 \/ UsedIntLoc i6 \/ {a4,a5}) by SF_MASTR:35
      .= {a6} \/ (UsedIntLoc i4 \/ {a3,a6} \/ {a4,a5}) by SF_MASTR:21
      .= {a6} \/ ({a4,a6} \/ {a3,a6} \/ {a4,a5}) by SF_MASTR:21
      .= {a6} \/ ({a4,a6,a3,a6} \/ {a4,a5}) by ENUMSET1:45
      .= {a6} \/ ({a6,a6,a3,a4} \/ {a4,a5}) by ENUMSET1:123
      .= {a6} \/ {a6,a6,a3,a4} \/ {a4,a5} by XBOOLE_1:4
      .= {a6,a6,a6,a3,a4} \/ {a4,a5} by ENUMSET1:47
      .= {a6,a3,a4} \/ {a4,a5} by ENUMSET1:78
      .= {a6,a3} \/ {a4} \/ {a4,a5} by ENUMSET1:43
      .= {a6,a3} \/ ({a4} \/ {a4,a5}) by XBOOLE_1:4
      .= {a6,a3} \/ {a4,a4,a5} by ENUMSET1:42
      .= {a4,a5} \/ {a6,a3} by ENUMSET1:70
      .= {a4,a5,a6,a3} by ENUMSET1:45
      .= {a4,a3,a6,a5} by ENUMSET1:107;
  end;
  set ui12=UsedIntLoc(i1 ';' i2);
A2: UsedIntLoc body2 = {a0} \/ {a4,a3,a6,a5}
  proof thus
    UsedIntLoc body2 = (UsedIntLoc (i1 ';' i2 ';'i3 ';'i4 ';' i5) )
    \/ Sif by SF_MASTR:31
      .= (UsedIntLoc (i1 ';' i2 ';'i3 ';' i4)) \/ (UsedIntLoc i5) \/ Sif
    by SF_MASTR:34
      .= (UsedIntLoc (i1 ';' i2 ';'i3 ';' i4)) \/ {a6,a5} \/ Sif
    by SF_MASTR:18
      .= (UsedIntLoc (i1 ';' i2 ';'i3 )) \/ (UsedIntLoc i4) \/ {a6,a5} \/ Sif
    by SF_MASTR:34
      .= (UsedIntLoc (i1 ';' i2 ';'i3)) \/ {a6,a4} \/ {a6,a5} \/ Sif
    by SF_MASTR:21
      .= ui12 \/ UsedIntLoc i3 \/ {a6,a4} \/ {a6,a5} \/ Sif by SF_MASTR:34
      .= ui12 \/ {a5,a3} \/ {a6,a4} \/ {a6,a5} \/ Sif by SF_MASTR:21
      .= ui12 \/ ({a5,a3} \/ {a6,a4}) \/ {a6,a5} \/ Sif by XBOOLE_1:4
      .= ui12 \/ {a5,a3,a6,a4} \/ {a6,a5} \/ Sif by ENUMSET1:45
      .= ui12 \/ {a4,a3,a6,a5} \/ {a6,a5} \/ Sif by ENUMSET1:123
      .= ui12 \/ ({a4,a3} \/ {a6,a5}) \/ {a6,a5} \/ Sif by ENUMSET1:45
      .= ui12 \/ {a4,a3} \/ {a6,a5} \/ {a6,a5} \/ Sif by XBOOLE_1:4
      .= ui12 \/ {a4,a3} \/ ({a6,a5} \/ {a6,a5}) \/ Sif by XBOOLE_1:4
      .= ui12 \/ ({a4,a3} \/ {a6,a5}) \/ Sif by XBOOLE_1:4
      .= ui12 \/ {a4,a3,a6,a5} \/ Sif by ENUMSET1:45
      .= ui12 \/ ({a4,a3,a6,a5} \/ Sif) by XBOOLE_1:4
      .= (UsedIntLoc i1 ) \/ (UsedIntLoc i2) \/ {a4,a3,a6,a5} by A1,SF_MASTR:35
      .= (UsedIntLoc i1 ) \/ {a3,a0} \/ {a4,a3,a6,a5} by SF_MASTR:18
      .= {a3,a4} \/ {a3,a0} \/ {a4,a3,a6,a5} by SF_MASTR:18
      .= {a3,a4,a3,a0} \/ {a4,a3,a6,a5} by ENUMSET1:45
      .= {a3,a3,a4,a0} \/ {a4,a3,a6,a5} by ENUMSET1:104
      .= {a3,a4,a0} \/ {a4,a3,a6,a5} by ENUMSET1:71
      .= {a0,a4,a3} \/ {a4,a3,a6,a5} by ENUMSET1:102
      .= {a0} \/ {a4,a3} \/ {a4,a3,a6,a5} by ENUMSET1:42
      .= {a0} \/ {a4,a3} \/ ({a4,a3} \/ {a6,a5}) by ENUMSET1:45
      .= {a0} \/ {a4,a3} \/ {a4,a3} \/ {a6,a5} by XBOOLE_1:4
      .= {a0} \/ ({a4,a3} \/ {a4,a3}) \/ {a6,a5} by XBOOLE_1:4
      .= {a0} \/ ({a4,a3} \/ {a6,a5}) by XBOOLE_1:4
      .= {a0} \/ {a4,a3,a6,a5} by ENUMSET1:45;
  end;
  set j1= a2 := a1, j2= SubFrom(a2,a0), j3= (a3:=len f),
  Sfor= UsedIntLoc Times(a2,body2),
  body1= j1 ';' j2 ';' j3 ';' Times(a2,body2);
A3: Sfor= {a4,a5,a6} \/ {a0,a2,a3}
  proof thus
    Sfor={a4,a3,a6,a5} \/ {a0} \/ {a2,a0} by A2,Th31
      .={a4,a3,a6,a5} \/ ({a0} \/ {a2,a0}) by XBOOLE_1:4
      .={a4,a3,a6,a5} \/ {a0,a0,a2} by ENUMSET1:42
      .={a4,a3,a6,a5} \/ {a0,a2} by ENUMSET1:70
      .={a4,a5,a6,a3} \/ {a0,a2} by ENUMSET1:107
      .={a4,a5,a6} \/ {a3} \/ {a0,a2} by ENUMSET1:46
      .={a4,a5,a6} \/ ({a3} \/ {a0,a2}) by XBOOLE_1:4
      .={a4,a5,a6} \/ {a0,a2,a3} by ENUMSET1:43;
  end;
A4: UsedIntLoc body1 = {a0,a1,a2,a3,a4,a5,a6}
  proof thus
    UsedIntLoc body1 = UsedIntLoc (j1 ';' j2 ';'j3) \/ Sfor by SF_MASTR:31
      .= UsedIntLoc (j1 ';' j2) \/ UsedIntLoc j3 \/ Sfor by SF_MASTR:34
      .= UsedIntLoc (j1 ';' j2) \/ {a3} \/ Sfor by SF_MASTR:22
      .= UsedIntLoc j1 \/ UsedIntLoc j2 \/ {a3} \/ Sfor by SF_MASTR:35
      .= UsedIntLoc j1 \/ {a2,a0} \/ {a3} \/ Sfor by SF_MASTR:18
      .= {a2,a1} \/ {a2,a0} \/ {a3} \/ Sfor by SF_MASTR:18
      .= {a2,a1} \/ ({a0,a2} \/ {a3}) \/ Sfor by XBOOLE_1:4
      .= {a2,a1} \/ {a0,a2,a3} \/ Sfor by ENUMSET1:43
      .= {a2,a1} \/ {a0,a2,a3} \/ {a0,a2,a3} \/ {a4,a5,a6} by A3,XBOOLE_1:4
      .= {a2,a1} \/ ({a0,a2,a3} \/ {a0,a2,a3}) \/ {a4,a5,a6} by XBOOLE_1:4
      .= {a2,a1} \/ ({a0,a2} \/ {a3}) \/ {a4,a5,a6} by ENUMSET1:43
      .= {a2,a1} \/ {a0,a2} \/ {a3} \/ {a4,a5,a6} by XBOOLE_1:4
      .= {a2,a1,a0,a2} \/ {a3} \/ {a4,a5,a6} by ENUMSET1:45
      .= {a2,a2,a0,a1} \/ {a3} \/ {a4,a5,a6} by ENUMSET1:107
      .= {a2,a0,a1} \/ {a3} \/ {a4,a5,a6} by ENUMSET1:71
      .= {a0,a1,a2} \/ {a3} \/ {a4,a5,a6} by ENUMSET1:100
      .= {a0,a1,a2,a3} \/ {a4,a5,a6} by ENUMSET1:46
      .= {a0,a1,a2,a3,a4,a5,a6} by ENUMSET1:59;
  end;
  set k2= a2:= a0, k3= a3:= a0, k4= a4:= a0, k5= a5:= a0;
A5: UsedIntLoc initializeWorkMem = UsedIntLoc (k2 ';' k3 ';' k4 ';' k5)
  \/ UsedIntLoc (a6:= a0) by SF_MASTR:34
    .= UsedIntLoc (k2 ';' k3 ';' k4 ';' k5) \/ {a6,a0} by SF_MASTR:18
    .= UsedIntLoc (k2 ';' k3 ';' k4 ) \/ UsedIntLoc k5 \/ {a6,a0}
  by SF_MASTR:34
    .= UsedIntLoc (k2 ';' k3 ';' k4 ) \/ {a5,a0} \/ {a6,a0} by SF_MASTR:18
    .= UsedIntLoc (k2 ';' k3 ) \/ UsedIntLoc k4 \/ {a5,a0} \/
  {a6,a0} by SF_MASTR:34
    .= UsedIntLoc (k2 ';' k3 ) \/ {a4,a0} \/ {a5,a0} \/ {a6,a0} by SF_MASTR:18
    .= UsedIntLoc k2 \/ UsedIntLoc k3 \/ {a4,a0} \/ {a5,a0} \/ {a6,a0}
  by SF_MASTR:35
    .= UsedIntLoc k2 \/ {a3,a0} \/ {a4,a0} \/ {a5,a0} \/
  {a6,a0} by SF_MASTR:18
    .= {a2,a0} \/ {a3,a0} \/ {a4,a0} \/ {a5,a0} \/ {a6,a0} by SF_MASTR:18
    .= {a2,a0} \/ {a3,a0} \/ {a4,a0} \/ ({a5,a0} \/ {a6,a0}) by XBOOLE_1:4
    .= {a2,a0} \/ {a3,a0} \/ {a4,a0} \/ {a0,a5,a6} by ENUMSET1:137
    .= {a0,a2,a3} \/ {a4,a0} \/ {a0,a5,a6} by ENUMSET1:137
    .= {a0,a2,a3} \/ {a4,a0} \/ ({a0} \/ {a5,a6}) by ENUMSET1:42
    .= {a0,a2,a3} \/ {a4,a0} \/ {a0} \/ {a5,a6} by XBOOLE_1:4
    .= {a0,a2,a3} \/ ({a4,a0} \/ {a0}) \/ {a5,a6} by XBOOLE_1:4
    .= {a0,a2,a3} \/ {a4,a0,a0} \/ {a5,a6} by ENUMSET1:43
    .= {a0,a2,a3} \/ ({a0,a0} \/ {a4}) \/ {a5,a6} by ENUMSET1:42
    .= {a0,a2,a3} \/ {a0,a0} \/ {a4} \/ {a5,a6} by XBOOLE_1:4
    .= {a0,a0,a0,a2,a3} \/ {a4} \/ {a5,a6} by ENUMSET1:48
    .= {a0,a2,a3} \/ {a4} \/ {a5,a6} by ENUMSET1:78
    .= {a0,a2,a3,a4} \/ {a5,a6} by ENUMSET1:46
    .= {a0,a2,a3,a4,a5,a6} by ENUMSET1:54
    .= {a0} \/ {a2,a3,a4,a5,a6} by ENUMSET1:51;
  set k7=(a1:=len f), Ut=UsedIntLoc Times(a1,body1);
  thus UsedIntLoc (bubble-sort f)
  =UsedIntLoc ( initializeWorkMem ';' k7 ) \/ Ut by SF_MASTR:31
    .=UsedIntLoc initializeWorkMem \/ UsedIntLoc k7 \/ Ut by SF_MASTR:34
    .={a0} \/ {a2,a3,a4,a5,a6} \/ {a1} \/ Ut by A5,SF_MASTR:22
    .={a0} \/ {a1} \/ {a2,a3,a4,a5,a6} \/ Ut by XBOOLE_1:4
    .={a0,a1} \/ {a2,a3,a4,a5,a6} \/ Ut by ENUMSET1:41
    .={a0,a1,a2,a3,a4,a5,a6} \/ Ut by ENUMSET1:57
    .={a0,a1,a2,a3,a4,a5,a6} \/ ({a1,a0} \/ {a0,a1,a2,a3,a4,a5,a6}) by A4,Th31
    .={a0,a1,a2,a3,a4,a5,a6} \/ {a0,a1,a2,a3,a4,a5,a6} \/ {a1,a0} by XBOOLE_1:4
    .={a2,a3,a4,a5,a6} \/ {a0,a1} \/ {a0,a1} by ENUMSET1:57
    .={a2,a3,a4,a5,a6} \/ ({a0,a1} \/ {a0,a1}) by XBOOLE_1:4
    .={a0,a1,a2,a3,a4,a5,a6} by ENUMSET1:57;
end;

theorem Th59:
  for f being FinSeq-Location holds UsedInt*Loc (bubble-sort f) = {f}
proof
  let f be FinSeq-Location;
  set i1= a4:=a3, i2= SubFrom(a3,a0), i3= (a5:=(f,a3)), i4= (a6:=(f,a4)),
  i5= SubFrom(a6,a5), i6= ((f,a3):=a6), i7= ((f,a4):=a5),
  ifc=if>0(a6,i4 ';' i6 ';' i7,Stop SCM+FSA), Sif= UsedInt*Loc ifc,
  body2= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' ifc;
A1: Sif = UsedInt*Loc (i4 ';' i6 ';' i7) \/ {} by SCMFSA9A:10,16
    .= UsedInt*Loc (i4 ';' i6) \/ UsedInt*Loc i7 by SF_MASTR:50
    .= UsedInt*Loc (i4 ';' i6) \/ {f} by SF_MASTR:37
    .= UsedInt*Loc i4 \/ UsedInt*Loc i6 \/ {f} by SF_MASTR:51
    .= UsedInt*Loc i4 \/ {f} \/ {f} by SF_MASTR:37
    .= {f} \/ {f} \/ {f} by SF_MASTR:37
    .= {f};
A2: UsedInt*Loc body2 = UsedInt*Loc (i1 ';' i2 ';'i3 ';'i4 ';' i5)
  \/ Sif by SF_MASTR:47
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ';' i4) \/ UsedInt*Loc i5 \/ Sif
  by SF_MASTR:50
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ';' i4) \/ {} \/ Sif by SF_MASTR:36
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ) \/ UsedInt*Loc i4 \/ Sif by SF_MASTR:50
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ) \/ {f} \/ Sif by SF_MASTR:37
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ) \/ ({f} \/ {f}) by A1,XBOOLE_1:4
    .= UsedInt*Loc (i1 ';' i2 ) \/ UsedInt*Loc i3 \/ {f} by SF_MASTR:50
    .= UsedInt*Loc (i1 ';' i2 ) \/ {f} \/ {f} by SF_MASTR:37
    .= UsedInt*Loc i1 \/ UsedInt*Loc i2 \/ {f} \/ {f} by SF_MASTR:51
    .= UsedInt*Loc i1 \/ {} \/ {f} \/ {f} by SF_MASTR:36
    .= {} \/ {} \/ {f} \/ {f} by SF_MASTR:36
    .= {f};
  set j1= a2 := a1, j2= SubFrom(a2,a0), j3= (a3:=len f),
  Sfor= UsedInt*Loc Times(a2,body2),
  body1= j1 ';' j2 ';' j3 ';' Times(a2,body2);
A3: Sfor={f} by A2,Th37;
A4: UsedInt*Loc body1 = UsedInt*Loc (j1 ';' j2 ';'j3) \/ Sfor by SF_MASTR:47
    .= UsedInt*Loc (j1 ';' j2) \/ UsedInt*Loc j3 \/ Sfor by SF_MASTR:50
    .= UsedInt*Loc (j1 ';' j2) \/ {f} \/ Sfor by SF_MASTR:38
    .= UsedInt*Loc j1 \/ UsedInt*Loc j2 \/ {f} \/ Sfor by SF_MASTR:51
    .= {} \/ UsedInt*Loc j2 \/ {f} \/ Sfor by SF_MASTR:36
    .= {} \/ {} \/ {f} \/ Sfor by SF_MASTR:36
    .= {f} by A3;
  set k2= a2:= a0, k3= a3:= a0, k4= a4:= a0, k5= a5:= a0;
A5: UsedInt*Loc initializeWorkMem = UsedInt*Loc (k2 ';' k3 ';' k4 ';' k5)
  \/ UsedInt*Loc (a6:= a0) by SF_MASTR:50
    .= UsedInt*Loc (k2 ';' k3 ';' k4 ';' k5) \/ {} by SF_MASTR:36
    .= UsedInt*Loc (k2 ';' k3 ';' k4) \/ UsedInt*Loc k5 by SF_MASTR:50
    .= UsedInt*Loc (k2 ';' k3 ';' k4) \/ {} by SF_MASTR:36
    .= UsedInt*Loc (k2 ';' k3 ) \/ UsedInt*Loc k4 by SF_MASTR:50
    .= UsedInt*Loc (k2 ';' k3 ) \/ {} by SF_MASTR:36
    .= UsedInt*Loc k2 \/ UsedInt*Loc k3 by SF_MASTR:51
    .= UsedInt*Loc k2 \/ {} by SF_MASTR:36
    .= {} by SF_MASTR:36;
  set k7=(a1:=len f) , Ut=UsedInt*Loc Times(a1,body1);
  thus UsedInt*Loc (bubble-sort f)
  =UsedInt*Loc ( initializeWorkMem ';' k7 ) \/ Ut by SF_MASTR:47
    .=UsedInt*Loc initializeWorkMem \/ UsedInt*Loc k7 \/ Ut by SF_MASTR:50
    .={f} \/ Ut by A5,SF_MASTR:38
    .={f} \/ {f} by A4,Th37
    .={f};
end;

definition
  func Sorting-Function -> PartFunc of FinPartSt SCM+FSA,FinPartSt SCM+FSA
  means
  :Def3:
  for p,q being FinPartState of SCM+FSA holds [p,q] in it
  iff ex t being FinSequence of INT,u being FinSequence of REAL
  st t,u are_fiberwise_equipotent & u is FinSequence of INT &
  u is non-increasing & p = fsloc 0 .--> t & q = fsloc 0 .--> u;
  existence
  proof
    defpred X[set,set] means
    ex t being FinSequence of INT,u being FinSequence of REAL
    st t,u are_fiberwise_equipotent & u is FinSequence of INT &
    u is non-increasing & $1 = fsloc 0 .--> t & $2 = fsloc 0 .--> u;
A1: for x,y1,y2 being set st X[x,y1] & X[x,y2] holds y1 = y2
    proof
      let p,q1,q2 be set;
      given t1 being FinSequence of INT,u1 being FinSequence of REAL such that
A2:   t1,u1 are_fiberwise_equipotent & u1 is FinSequence of INT &
      u1 is non-increasing & p = fsloc 0 .--> t1 & q1 = fsloc 0 .--> u1;
      given t2 being FinSequence of INT,u2 being FinSequence of REAL such that
A3:   t2,u2 are_fiberwise_equipotent & u2 is FinSequence of INT &
      u2 is non-increasing & p = fsloc 0 .--> t2 & q2 = fsloc 0 .--> u2;
      t1=(fsloc 0 .--> t1).(fsloc 0) by FUNCOP_1:87
        .=t2 by A2,A3,FUNCOP_1:87;
      hence q1 = q2 by A2,A3,RFINSEQ:2,36;
    end;
    consider f being Function such that
A4: for p,q being set holds [p,q] in f iff p in FinPartSt SCM+FSA &
    X[p,q] from FUNCT_1:sch 1(A1);
A5: dom f c= FinPartSt SCM+FSA
    proof
      let e be set;
      assume e in dom f;
      then [e,f.e] in f by FUNCT_1:8;
      hence e in FinPartSt SCM+FSA by A4;
    end;
    rng f c= FinPartSt SCM+FSA
    proof
      let q be set;
      assume q in rng f;
      then consider p being set such that
A6:   [p,q] in f by RELAT_1:def 5;
      consider t being FinSequence of INT,u being FinSequence of REAL
      such that
A7:   t,u are_fiberwise_equipotent & u is FinSequence of INT &
      u is non-increasing & p = fsloc 0 .--> t & q = fsloc 0 .--> u by A4,A6;
      reconsider u as FinSequence of INT by A7;
      fsloc 0 .--> u is FinPartState of SCM+FSA;
      hence q in FinPartSt SCM+FSA by A7;
    end;
    then reconsider f as PartFunc of FinPartSt SCM+FSA, FinPartSt SCM+FSA
    by A5,RELSET_1:11;
    take f;
    let p,q be FinPartState of SCM+FSA;
    thus [p,q] in f implies
    ex t being FinSequence of INT,u being FinSequence of REAL
    st t,u are_fiberwise_equipotent & u is FinSequence of INT &
    u is non-increasing & p = fsloc 0 .--> t & q = fsloc 0 .--> u by A4;
    given t being FinSequence of INT,u being FinSequence of REAL such that
A8: t,u are_fiberwise_equipotent & u is FinSequence of INT &
    u is non-increasing & p = fsloc 0 .--> t & q = fsloc 0 .--> u;
    p in FinPartSt SCM+FSA;
    hence [p,q] in f by A4,A8;
  end;
  uniqueness
  proof
    let IT1,IT2 be PartFunc of FinPartSt SCM+FSA, FinPartSt SCM+FSA such that
A9: for p,q being FinPartState of SCM+FSA holds [p,q] in IT1
    iff ex t being FinSequence of INT,u being FinSequence of REAL
    st t,u are_fiberwise_equipotent & u is FinSequence of INT &
    u is non-increasing & p = fsloc 0 .--> t & q = fsloc 0 .--> u and
A10: for p,q being FinPartState of SCM+FSA holds [p,q] in IT2
    iff ex t being FinSequence of INT,u being FinSequence of REAL
    st t,u are_fiberwise_equipotent & u is FinSequence of INT &
    u is non-increasing & p = fsloc 0 .--> t & q = fsloc 0 .--> u;
    defpred X[set,set] means
    ex t being FinSequence of INT,u being FinSequence of REAL
    st t,u are_fiberwise_equipotent & u is FinSequence of INT &
    u is non-increasing & $1 = fsloc 0 .--> t & $2 = fsloc 0 .--> u;
A11: for p,q being Element of FinPartSt SCM+FSA holds [p,q] in IT1 iff X[p,q]
    proof
      let p,q be Element of FinPartSt SCM+FSA;
      reconsider p,q as FinPartState of SCM+FSA by AMI_1:125;
      [p,q] in IT1 iff X[p,q] by A9;
      hence thesis;
    end;
A12: for p,q being Element of FinPartSt SCM+FSA holds [p,q] in IT2 iff X[p,q]
    proof
      let p,q be Element of FinPartSt SCM+FSA;
      reconsider p,q as FinPartState of SCM+FSA by AMI_1:125;
      [p,q] in IT2 iff X[p,q] by A10;
      hence thesis;
    end;
    thus IT1 = IT2 from RELSET_1:sch 4(A11,A12);
  end;
end;

theorem Th60:
  for p being set holds p in dom Sorting-Function iff
  ex t being FinSequence of INT st p = fsloc 0 .--> t
proof
  set f=Sorting-Function;
  let p be set;
  hereby
    set q=f.p;
    assume
A1: p in dom f;
    then
A2: [p,f.p] in f by FUNCT_1:8;
    dom f c=FinPartSt SCM+FSA by RELSET_1:12;
    then
A3: p is FinPartState of SCM+FSA by A1,AMI_1:125;
    q in FinPartSt SCM+FSA by A1,PARTFUN1:27;
    then q is FinPartState of SCM+FSA by AMI_1:125;
    then consider t be FinSequence of INT,u being FinSequence of REAL such that
A4: t,u are_fiberwise_equipotent & u is FinSequence of INT &
    u is non-increasing & p = fsloc 0 .--> t & q = fsloc 0 .--> u
    by A2,A3,Def3;
    take t;
    thus p = fsloc 0 .--> t by A4;
  end;
  given t be FinSequence of INT such that
A5: p = fsloc 0 .--> t;
  consider u be FinSequence of REAL such that
A6: t,u are_fiberwise_equipotent & u is FinSequence of INT
  & u is non-increasing by Th39;
  reconsider u1=u as FinSequence of INT by A6;
  set q=fsloc 0 .--> u1;
  [p,q] in f by A5,A6,Def3;
  hence thesis by FUNCT_1:8;
end;

theorem Th61:
  for t being FinSequence of INT holds
  ex u being FinSequence of REAL st t,u are_fiberwise_equipotent &
  u is non-increasing & u is FinSequence of INT &
  Sorting-Function.(fsloc 0 .--> t ) = fsloc 0 .--> u
proof
  let t be FinSequence of INT;
  consider u being FinSequence of REAL such that
A1: t,u are_fiberwise_equipotent & u is FinSequence of INT &
  u is non-increasing by Th39;
  reconsider u as FinSequence of INT by A1;
  set p = fsloc 0 .--> t;
  set q = fsloc 0 .--> u;
  [p, q] in Sorting-Function by A1,Def3;
  then Sorting-Function.p = q by FUNCT_1:8;
  hence thesis by A1;
end;

theorem Th62:
  for f being FinSeq-Location holds card (bubble-sort f) = 63
proof
  let f be FinSeq-Location;
  set i1= a4:=a3, i2= SubFrom(a3,a0), i3= (a5:=(f,a3)), i4= (a6:=(f,a4)),
  i5= SubFrom(a6,a5), i6= ((f,a3):=a6), i7= ((f,a4):=a5),
  ifc=if>0(a6,i4 ';' i6 ';' i7,Stop SCM+FSA), Cif= card ifc,
  body2= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' ifc;
A1: Cif=card (i4 ';' i6 ';' i7) + 1 + 4 by SCMFSA8A:17,SCMFSA8B:15
    .=6 + 1 + 4 by Th45
    .=11;
A2: card body2 = card (i1 ';' i2 ';' i3 ';' i4 ';' i5) + Cif by SCMFSA6A:61
    .= card (i1 ';' i2 ';' i3 ';' (i4 ';' i5))+Cif by SCMFSA6A:70
    .= card (i1 ';' i2 ';' i3) + card (i4 ';' i5)+Cif by SCMFSA6A:61
    .= 6 + card (i4 ';' i5)+Cif by Th45
    .= 6 + (card Macro i4 + card Macro i5) + Cif by SCMFSA6A:61
    .= 6 + (2 + card Macro i5) + Cif by SCMFSA7B:6
    .= 6 + (2 +2)+ Cif by SCMFSA7B:6
    .=21 by A1;
  set j1= a2 := a1, j2= SubFrom(a2,a0) , j3= (a3:=len f) ,
  body1= j1 ';' j2 ';' j3 ';' Times(a2,body2);
A3: card body1 = card (j1 ';' j2 ';' j3) + card Times(a2,body2) by SCMFSA6A:61
    .= 6 + card Times(a2,body2) by Th45
    .= 6 + (21 +12) by A2,Th44
    .= 39;
  set k2= a2:= a0, k3= a3:= a0, k4= a4:= a0, k5= a5:= a0, k6= a6:= a0;
A4: card initializeWorkMem
    = card (k2 ';' k3 ';' k4 ';' k5)+ card Macro k6 by SCMFSA6A:61
    .= card (k2 ';' k3 ';' k4 ';' k5)+ 2 by SCMFSA7B:6
    .= card (k2 ';' k3 ';' k4 ) + card Macro k5+ 2 by SCMFSA6A:61
    .= 6 + card Macro k5+ 2 by Th45
    .= 6 + 2+ 2 by SCMFSA7B:6
    .= 10;
  set k7=(a1:=len f), Ct=card Times(a1,body1);
A5: Ct=39 +12 by A3,Th44;
  thus card (bubble-sort f)
    = card (initializeWorkMem ';' Macro k7)+ Ct by SCMFSA6A:61
    .= card initializeWorkMem + card Macro k7 + Ct by SCMFSA6A:61
    .= 10 + 2 + Ct by A4,SCMFSA7B:6
    .=63 by A5;
end;

theorem Th63:
  for f being FinSeq-Location, k being Element of NAT st
  k < 63 holds insloc k in dom (bubble-sort f)
proof
  let f be FinSeq-Location, k be Element of NAT;
  assume
A1: k < 63;
  card (bubble-sort f) = 63 by Th62;
  hence thesis by A1,SCMFSA6A:15;
end;

Lm2: for s being State of SCM+FSA st Bubble-Sort-Algorithm c= s holds
s.insloc 0= a2:=a0 & s.insloc 1= goto insloc 2 & s.insloc 2= a3:=a0 &
s.insloc 3= goto insloc 4 & s.insloc 4= a4:=a0 & s.insloc 5= goto insloc 6 &
s.insloc 6= a5:=a0 & s.insloc 7= goto insloc 8 & s.insloc 8= a6:=a0 &
s.insloc 9= goto insloc 10 & s.insloc 10= a1:=len fsloc 0 &
s.insloc 11= goto insloc 12
proof
  set f0=fsloc 0, TT=Times(a1, a2 := a1 ';' SubFrom(a2,a0) ';'
  (a3:=len f0) ';' Times(a2, a4:=a3 ';' SubFrom(a3,a0) ';' (a5:=(f0,a3)) ';'
  (a6:=(f0,a4)) ';' SubFrom(a6,a5) ';' if>0(a6,(a6:=(f0,a4)) ';'
  ((f0,a3):=a6) ';'((f0,a4):=a5),Stop SCM+FSA) ) );
  set q=Bubble-Sort-Algorithm, q0=bubble-sort f0;
  let s be State of SCM+FSA such that
A1: q c= s;
A2: now
    let i be Element of NAT;
    assume i< 63;
    then insloc i in dom q0 by Th63;
    hence q0.insloc i= s.insloc i by A1,GRFUNC_1:8;
  end;
  set W2=a2:= a0, W3=a3:= a0, W4=a4:= a0, W5=a5:= a0, W6=a6:= a0,
  W7=a1:=len f0, T7=W7 ';' TT, T6=W6 ';' T7, T5=W5 ';' T6, T4=W4 ';' T5,
  T3=W3 ';' T4, X3=W2 ';' W3, X4=X3 ';' W4, X5=X4 ';' W5, X6=X5 ';' W6;
A3: q0=X5 ';' W6 ';' T7 by SCMFSA6A:69;
  then
A4: q0=X4 ';' W5 ';' T6 by SCMFSA6A:69;
  then
A5: q0=X3 ';' W4 ';' T5 by SCMFSA6A:69;
  then q0=W2 ';' W3 ';' T4 by SCMFSA6A:69;
  then
B7: q0=W2 ';' T3 by SCMFSA6A:73;
A8: q0 =Macro W2 ';' W3 ';' T4 by A5,SCMFSA6A:69;
  dom Macro W2 = {insloc 0, insloc 1} by SCMFSA7B:4;
  then
A9: insloc 0 in dom Macro W2 & insloc 1 in dom Macro W2 by TARSKI:def 2;
A10: W2 <> halt SCM+FSA by SCMFSA_2:42,124;
  thus s.insloc 0=q0.insloc 0 by A2
    .= (Directed Macro W2).insloc 0 by B7,A9,SCMFSA8A:28
    .= W2 by A10,SCMFSA7B:7;
  thus s.insloc 1=q0.insloc 1 by A2
    .= (Directed Macro W2).insloc 1 by B7,A9,SCMFSA8A:28
    .= goto insloc 2 by SCMFSA7B:8;
A11: card Macro W2=2 by SCMFSA7B:6;
  thus s.insloc 2=q0.insloc 2 by A2
    .= W3 by A8,A11,Th51;
  thus s.insloc 3=q0.insloc (2+1) by A2
    .=goto insloc (2+2) by A8,A11,Th51
    .=goto insloc 4;
A12: card X3
    = card Macro W2 + card Macro W3 by SCMFSA6A:61
    .= 2 + card Macro W3 by SCMFSA7B:6
    .= 2 + 2 by SCMFSA7B:6
    .=4;
  thus s.insloc 4=q0.insloc 4 by A2
    .= W4 by A5,A12,Th51;
  thus s.insloc 5=q0.insloc (4+1) by A2
    .=goto insloc(4+2) by A5,A12,Th51
    .=goto insloc 6;
A13: card X4=6 by Th45;
  thus s.insloc 6=q0.insloc 6 by A2
    .= W5 by A4,A13,Th51;
  thus s.insloc 7=q0.insloc (6+1) by A2
    .=goto insloc (6+2) by A4,A13,Th51
    .=goto insloc 8;
A14: card X5
    = 6 + card Macro W5 by A13,SCMFSA6A:61
    .= 6 + 2 by SCMFSA7B:6;
  thus s.insloc 8=q0.insloc 8 by A2
    .= W6 by A3,A14,Th51;
  thus s.insloc 9=q0.insloc (8+1) by A2
    .=goto insloc (8+2) by A3,A14,Th51
    .=goto insloc 10;
A15: card X6
    = 8 + card Macro W6 by A14,SCMFSA6A:61
    .= 8 + 2 by SCMFSA7B:6;
  thus s.insloc 10=q0.insloc 10 by A2
    .= W7 by A15,Th52;
  thus s.insloc 11=q0.insloc (10+1) by A2
    .=goto insloc (10+2) by A15,Th52
    .=goto insloc 12;
end;

Lm3: for s being State of SCM+FSA st Bubble-Sort-Algorithm c= s &
s starts_at 0 holds  Computation( s,1).IC SCM+FSA = insloc 1 &
 Computation( s,1).a0=s.a0 &  Computation( s,1).fsloc 0=s.fsloc 0 &
 Computation( s,2).IC SCM+FSA = insloc 2 &
 Computation( s,2).a0=s.a0 &  Computation( s,2).fsloc 0=s.fsloc 0 &
 Computation( s,3).IC SCM+FSA = insloc 3 &
 Computation( s,3).a0=s.a0 &  Computation( s,3).fsloc 0=s.fsloc 0 &
 Computation( s,4).IC SCM+FSA = insloc 4 &
 Computation( s,4).a0=s.a0 &  Computation( s,4).fsloc 0=s.fsloc 0 &
 Computation( s,5).IC SCM+FSA = insloc 5 &
 Computation( s,5).a0=s.a0 &  Computation( s,5).fsloc 0=s.fsloc 0 &
 Computation( s,6).IC SCM+FSA = insloc 6 &
 Computation( s,6).a0=s.a0 &  Computation( s,6).fsloc 0=s.fsloc 0 &
 Computation( s,7).IC SCM+FSA = insloc 7 &
 Computation( s,7).a0=s.a0 &  Computation( s,7).fsloc 0=s.fsloc 0 &
 Computation( s,8).IC SCM+FSA = insloc 8 &
 Computation( s,8).a0=s.a0 &  Computation( s,8).fsloc 0=s.fsloc 0 &
 Computation( s,9).IC SCM+FSA = insloc 9 &
 Computation( s,9).a0=s.a0 &  Computation( s,9).fsloc 0=s.fsloc 0 &
 Computation( s,10).IC SCM+FSA = insloc 10 &
 Computation( s,10).a0=s.a0 &  Computation( s,10).fsloc 0=s.fsloc 0 &
 Computation( s,11).IC SCM+FSA = insloc 11 &
 Computation( s,11).a0=s.a0 &  Computation( s,11).fsloc 0=s.fsloc 0 &
 Computation( s,11).a1=len(s.fsloc 0) &
 Computation( s,11).a2=s.a0 &  Computation( s,11).a3=s.a0 &
 Computation( s,11).a4=s.a0 &  Computation( s,11).a5=s.a0 &
 Computation( s,11).a6=s.a0
proof
  let s be State of SCM+FSA such that
A1: Bubble-Sort-Algorithm c= s and
A2: s starts_at 0;
A3: Computation(s,0) = s by AMI_1:13;
  then
A4: IC Computation(s,0) = insloc 0 by A2,AMI_1:def 41;
  then
A5: Computation(s,0+1) = Exec(s.insloc 0,Computation(s,0)) by AMI_1:55
    .= Exec(a2:=a0,Computation(s,0)) by A1,Lm2;
  hence Computation(s,1).IC SCM+FSA = Next IC Computation(s,0) by SCMFSA_2:89
    .= insloc 1 by A4;
  then
A6: IC Computation(s,1)= insloc 1;
A7: Computation(s,1).a2 =s.a0 by A3,A5,SCMFSA_2:89; thus
A8: Computation(s,1).a0 =s.a0 by A3,A5,Lm1,SCMFSA_2:89; thus
A9: Computation(s,1).(fsloc 0) =s.(fsloc 0) by A3,A5,SCMFSA_2:89;
A10: Computation(s,1+1) = Exec(s.insloc 1,Computation(s,1)) by A6,AMI_1:55
    .= Exec(goto insloc 2,Computation(s,1)) by A1,Lm2;
  hence
A11: Computation(s,2).IC SCM+FSA = insloc 2 by SCMFSA_2:95;
A12: IC Computation(s,2)= insloc 2 by A10,SCMFSA_2:95; thus
A13: Computation(s,2).a0 =s.a0 by A8,A10,SCMFSA_2:95; thus
A14: Computation(s,2).(fsloc 0) =s.(fsloc 0) by A9,A10,SCMFSA_2:95;
A15: Computation(s,2).a2 =s.a0 by A7,A10,SCMFSA_2:95;
A16: Computation(s,2+1) = Exec(s.insloc 2,Computation(s,2)) by A12,AMI_1:55
    .= Exec(a3:=a0,Computation(s,2)) by A1,Lm2;
  hence Computation(s,3).IC SCM+FSA = Next IC Computation(s,2) by SCMFSA_2:89
    .= insloc 3 by A11;
  then
A17: IC Computation(s,3)= insloc 3;
A18: Computation(s,3).a3 =s.a0 by A13,A16,SCMFSA_2:89; thus
A19: Computation(s,3).a0 =s.a0 by A13,A16,Lm1,SCMFSA_2:89; thus
A20: Computation(s,3).(fsloc 0) =s.(fsloc 0) by A14,A16,SCMFSA_2:89;
A21: Computation(s,3).a2 =s.a0 by A15,A16,Lm1,SCMFSA_2:89;
A22: Computation(s,3+1) = Exec(s.insloc 3,Computation(s,3)) by A17,AMI_1:55
    .= Exec(goto insloc 4,Computation(s,3)) by A1,Lm2;
  hence
A23: Computation(s,4).IC SCM+FSA = insloc 4 by SCMFSA_2:95;
A24: IC Computation(s,4)= insloc 4 by A22,SCMFSA_2:95; thus
A25: Computation(s,4).a0 =s.a0 by A19,A22,SCMFSA_2:95; thus
A26: Computation(s,4).(fsloc 0) =s.(fsloc 0) by A20,A22,SCMFSA_2:95;
A27: Computation(s,4).a2 =s.a0 by A21,A22,SCMFSA_2:95;
A28: Computation(s,4).a3 =s.a0 by A18,A22,SCMFSA_2:95;
A29: Computation(s,4+1) = Exec(s.insloc 4,Computation(s,4)) by A24,AMI_1:55
    .= Exec(a4:=a0,Computation(s,4)) by A1,Lm2;
  hence Computation(s,5).IC SCM+FSA = Next IC Computation(s,4) by SCMFSA_2:89
    .= insloc 5 by A23;
  then
A30: IC Computation(s,5)= insloc 5;
A31: Computation(s,5).a4 =s.a0 by A25,A29,SCMFSA_2:89; thus
A32: Computation(s,5).a0 =s.a0 by A25,A29,Lm1,SCMFSA_2:89; thus
A33: Computation(s,5).(fsloc 0) =s.(fsloc 0) by A26,A29,SCMFSA_2:89;
A34: Computation(s,5).a2 =s.a0 by A27,A29,Lm1,SCMFSA_2:89;
A35: Computation(s,5).a3 =s.a0 by A28,A29,Lm1,SCMFSA_2:89;
A36: Computation(s,5+1) = Exec(s.insloc 5,Computation(s,5)) by A30,AMI_1:55
    .= Exec(goto insloc 6,Computation(s,5)) by A1,Lm2;
  hence
A37: Computation(s,6).IC SCM+FSA = insloc 6 by SCMFSA_2:95;
A38: IC Computation(s,6)= insloc 6 by A36,SCMFSA_2:95; thus
A39: Computation(s,6).a0 =s.a0 by A32,A36,SCMFSA_2:95; thus
A40: Computation(s,6).(fsloc 0) =s.(fsloc 0) by A33,A36,SCMFSA_2:95;
A41: Computation(s,6).a2 =s.a0 by A34,A36,SCMFSA_2:95;
A42: Computation(s,6).a3 =s.a0 by A35,A36,SCMFSA_2:95;
A43: Computation(s,6).a4 =s.a0 by A31,A36,SCMFSA_2:95;
A44: Computation(s,6+1) = Exec(s.insloc 6,Computation(s,6)) by A38,AMI_1:55
    .= Exec(a5:=a0,Computation(s,6)) by A1,Lm2;
  hence Computation(s,7).IC SCM+FSA = Next IC Computation(s,6) by SCMFSA_2:89
    .= insloc 7 by A37;
  then
A45: IC Computation(s,7)= insloc 7;
A46: Computation(s,7).a5 =s.a0 by A39,A44,SCMFSA_2:89; thus
A47: Computation(s,7).a0 =s.a0 by A39,A44,Lm1,SCMFSA_2:89; thus
A48: Computation(s,7).(fsloc 0) =s.(fsloc 0) by A40,A44,SCMFSA_2:89;
A49: Computation(s,7).a2 =s.a0 by A41,A44,Lm1,SCMFSA_2:89;
A50: Computation(s,7).a3 =s.a0 by A42,A44,Lm1,SCMFSA_2:89;
A51: Computation(s,7).a4 =s.a0 by A43,A44,Lm1,SCMFSA_2:89;
A52: Computation(s,7+1) = Exec(s.insloc 7,Computation(s,7)) by A45,AMI_1:55
    .= Exec(goto insloc 8,Computation(s,7)) by A1,Lm2;
  hence
A53: Computation(s,8).IC SCM+FSA = insloc 8 by SCMFSA_2:95;
A54: IC Computation(s,8)= insloc 8 by A52,SCMFSA_2:95; thus
A55: Computation(s,8).a0 =s.a0 by A47,A52,SCMFSA_2:95; thus
A56: Computation(s,8).(fsloc 0) =s.(fsloc 0) by A48,A52,SCMFSA_2:95;
A57: Computation(s,8).a2 =s.a0 by A49,A52,SCMFSA_2:95;
A58: Computation(s,8).a3 =s.a0 by A50,A52,SCMFSA_2:95;
A59: Computation(s,8).a4 =s.a0 by A51,A52,SCMFSA_2:95;
A60: Computation(s,8).a5 =s.a0 by A46,A52,SCMFSA_2:95;
A61: Computation(s,8+1) = Exec(s.insloc 8,Computation(s,8)) by A54,AMI_1:55
    .= Exec(a6:=a0,Computation(s,8)) by A1,Lm2;
  hence Computation(s,9).IC SCM+FSA = Next IC Computation(s,8) by SCMFSA_2:89
    .= insloc 9 by A53;
  then
A62: IC Computation(s,9)= insloc 9;
A63: Computation(s,9).a6 =s.a0 by A55,A61,SCMFSA_2:89; thus
A64: Computation(s,9).a0 =s.a0 by A55,A61,Lm1,SCMFSA_2:89; thus
A65: Computation(s,9).(fsloc 0) =s.(fsloc 0) by A56,A61,SCMFSA_2:89;
A66: Computation(s,9).a2 =s.a0 by A57,A61,Lm1,SCMFSA_2:89;
A67: Computation(s,9).a3 =s.a0 by A58,A61,Lm1,SCMFSA_2:89;
A68: Computation(s,9).a4 =s.a0 by A59,A61,Lm1,SCMFSA_2:89;
A69: Computation(s,9).a5 =s.a0 by A60,A61,Lm1,SCMFSA_2:89;
A70: Computation(s,9+1) = Exec(s.insloc 9,Computation(s,9)) by A62,AMI_1:55
    .= Exec(goto insloc 10,Computation(s,9)) by A1,Lm2;
  hence
A71: Computation(s,10).IC SCM+FSA = insloc 10 by SCMFSA_2:95;
A72: IC Computation(s,10)= insloc 10 by A70,SCMFSA_2:95; thus
A73: Computation(s,10).a0 =s.a0 by A64,A70,SCMFSA_2:95; thus
A74: Computation(s,10).(fsloc 0) =s.(fsloc 0) by A65,A70,SCMFSA_2:95;
A75: Computation(s,10).a2 =s.a0 by A66,A70,SCMFSA_2:95;
A76: Computation(s,10).a3 =s.a0 by A67,A70,SCMFSA_2:95;
A77: Computation(s,10).a4 =s.a0 by A68,A70,SCMFSA_2:95;
A78: Computation(s,10).a5 =s.a0 by A69,A70,SCMFSA_2:95;
A79: Computation(s,10).a6 =s.a0 by A63,A70,SCMFSA_2:95;
A80: Computation(s,10+1) = Exec(s.insloc 10,Computation(s,10)) by A72,AMI_1:55
    .= Exec(a1:=len fsloc 0,Computation(s,10)) by A1,Lm2;
  hence Computation(s,11).IC SCM+FSA = Next IC Computation(s,10)
   by SCMFSA_2:100
    .= insloc 11 by A71;
  thus Computation(s,11).a0 =s.a0 by A73,A80,Lm1,SCMFSA_2:100;
  thus Computation(s,11).(fsloc 0) =s.(fsloc 0) by A74,A80,SCMFSA_2:100;
  thus Computation(s,11).a1 =len(s.fsloc 0) by A74,A80,SCMFSA_2:100;
  thus Computation(s,11).a2 =s.a0 by A75,A80,Lm1,SCMFSA_2:100;
  thus Computation(s,11).a3 =s.a0 by A76,A80,Lm1,SCMFSA_2:100;
  thus Computation(s,11).a4 =s.a0 by A77,A80,Lm1,SCMFSA_2:100;
  thus Computation(s,11).a5 =s.a0 by A78,A80,Lm1,SCMFSA_2:100;
  thus Computation(s,11).a6 =s.a0 by A79,A80,Lm1,SCMFSA_2:100;
end;

Lm4: body2 does_not_destroy b2
proof
A1: i1 does_not_destroy b2 by AMI_3:52,SCMFSA7B:12;
A2: i2 does_not_destroy b2 by AMI_3:52,SCMFSA7B:14;
A3: i3 does_not_destroy b2 by AMI_3:52,SCMFSA7B:20;
A4: i4 does_not_destroy b2 by AMI_3:52,SCMFSA7B:20;
A5: i6 does_not_destroy b2 by SCMFSA7B:21;
A6: i7 does_not_destroy b2 by SCMFSA7B:21;
A7: SS does_not_destroy b2 by SCMFSA8C:85;
  i4 ';' i6 ';' i7 does_not_destroy b2 by A4,A5,A6,SCMFSA8C:83,84;
  then
A8: ifc does_not_destroy b2 by A7,SCMFSA8C:121;
  i1 ';' i2 ';' i3 does_not_destroy b2 by A1,A2,A3,SCMFSA8C:83,84;
  then i1 ';' i2 ';' i3 ';' i4 does_not_destroy b2 by Lm1,SCMFSA7B:20,
  SCMFSA8C:83;
  then i1 ';' i2 ';' i3 ';' i4 ';' i5 does_not_destroy b2
  by Lm1,SCMFSA7B:14,SCMFSA8C:83;
  hence thesis by A8,SCMFSA8C:81;
end;

Lm5: Times(b2,body2) is good InitHalting Program of SCM+FSA
proof
  Initialized Times(b2,body2) is halting by Lm4,SCM_HALT:76;
  hence thesis by SCM_HALT:def 2;
end;

Lm6: body2 does_not_destroy b1
proof
A1: i1 does_not_destroy b1 by AMI_3:52,SCMFSA7B:12;
A2: i2 does_not_destroy b1 by AMI_3:52,SCMFSA7B:14;
A3: i3 does_not_destroy b1 by AMI_3:52,SCMFSA7B:20;
A4: i4 does_not_destroy b1 by AMI_3:52,SCMFSA7B:20;
A5: i6 does_not_destroy b1 by SCMFSA7B:21;
A6: i7 does_not_destroy b1 by SCMFSA7B:21;
A7: SS does_not_destroy b1 by SCMFSA8C:85;
  i4 ';' i6 ';' i7 does_not_destroy b1 by A4,A5,A6,SCMFSA8C:83,84;
  then
A8: ifc does_not_destroy b1 by A7,SCMFSA8C:121;
  i1 ';' i2 ';' i3 does_not_destroy b1 by A1,A2,A3,SCMFSA8C:83,84;
  then i1 ';' i2 ';' i3 ';' i4 does_not_destroy b1 by Lm1,SCMFSA7B:20,
  SCMFSA8C:83;
  then i1 ';' i2 ';' i3 ';' i4 ';' i5 does_not_destroy b1
  by Lm1,SCMFSA7B:14,SCMFSA8C:83;
  hence thesis by A8,SCMFSA8C:81;
end;

Lm7: body1 does_not_destroy b1
proof
A1: j1 does_not_destroy b1 by AMI_3:52,SCMFSA7B:12;
A2: j2 does_not_destroy b1 by AMI_3:52,SCMFSA7B:14;
A3: j3 does_not_destroy b1 by AMI_3:52,SCMFSA7B:22;
A4: T2 does_not_destroy b1 by Lm6,Th3,AMI_3:52;
  j1 ';' j2 ';' j3 does_not_destroy b1 by A1,A2,A3,SCMFSA8C:83,84;
  hence thesis by A4,SCMFSA8C:81;
end;

Lm8: body1 is good InitHalting Program of SCM+FSA by Lm5;

Lm9: Times(b1,body1) is good InitHalting Program of SCM+FSA
proof
  reconsider TT=T2 as good InitHalting Program of SCM+FSA by Lm5;
  body1= j1 ';' j2 ';' j3 ';' TT;
  then Initialized Times(b1,body1) is halting by Lm7,SCM_HALT:76;
  hence thesis by SCM_HALT:def 2;
end;

theorem Th64:
  bubble-sort (fsloc 0) is keepInt0_1 InitHalting by Lm9;

Lm10: for s be State of SCM+FSA holds (s.b6 > 0 implies IExec(ifc,s).f0 =
s.f0+*(abs(s.b3),(s.f0)/.abs(s.b4)) +*(abs(s.b4),s.b5)) &
(s.b6 <= 0 implies IExec(ifc,s).f0=s.f0)
proof
  let s be State of SCM+FSA;
  set s0=Initialize s, s1=Exec(i4, s0), s2=IExec(i4 ';' i6, s);
A1: s0.f0=s.f0 by SCMFSA6C:3;
  s0.b4=s.b4 by SCMFSA6C:3;
  then
A2: s1.b6=(s.f0)/.abs(s.b4) by A1,Th8;
A3: s1.f0=s.f0 by A1,SCMFSA_2:98;
A4: s1.b3=s.b3 by Th10;
A5: s1.b4=s.b4 by Th10;
A6: s1.b5=s.b5 by Th10;
A7: s2.f0 =Exec(i6, s1).f0 by SCMFSA6C:10
    .=s.f0+*(abs(s.b3),(s.f0)/.abs(s.b4)) by A2,A3,A4,Th9;
A8: s2.b4=Exec(i6, s1).b4 by SCMFSA6C:9
    .=s.b4 by A5,SCMFSA_2:99;
A9: s2.b5=Exec(i6, s1).b5 by SCMFSA6C:9
    .=s.b5 by A6,SCMFSA_2:99;
  set I=i4 ';' i6 ';' i7, J=Stop SCM+FSA;
  hereby
    assume s.b6 >0;
    hence IExec(if>0(b6,I,J),s).f0 = IExec(I,s).f0 by SCM_HALT:54
      .=Exec(i7, s2).f0 by SCMFSA6C:8
      .=s.f0+*(abs(s.b3),(s.f0)/.abs(s.b4)) +*(abs(s.b4),s.b5)
    by A7,A8,A9,Th9;
  end;
  assume s.b6 <= 0;
  hence IExec(if>0(b6,I,J),s).f0 = IExec(J,s).f0 by SCM_HALT:54
    .=s.f0 by Th12;
end;

Lm11: for s be State of SCM+FSA holds IExec(ifc,s).b3 = s.b3
proof
  let s be State of SCM+FSA;
  set s1=Exec(i4, Initialize s), s2=IExec(i4 ';' i6, s);
A1: s1.b3=s.b3 by Th10;
A2: s2.b3=Exec(i6, s1).b3 by SCMFSA6C:9
    .=s.b3 by A1,SCMFSA_2:99;
  per cases;
  suppose s.b6 >0;
    hence IExec(ifc,s).b3 = IExec(i4 ';' i6 ';' i7,s).b3 by SCM_HALT:54
      .=Exec(i7, s2).b3 by SCMFSA6C:7
      .=s.b3 by A2,SCMFSA_2:99;
  end;
  suppose s.b6 <= 0;
    hence IExec(ifc,s).b3 = IExec(Stop SCM+FSA,s).b3 by SCM_HALT:54
      .=s.b3 by Th12;
  end;
end;

Lm12: for s be State of SCM+FSA st s.b3 <= len (s.f0) & s.b3 >= 2 holds
(IExec(body2,s).b3=s.b3-1) &
(s.f0, IExec(body2,s).f0 are_fiberwise_equipotent) &
( s.f0.(s.b3)=IExec(body2,s).f0.(s.b3) or
s.f0.(s.b3)=IExec(body2,s).f0.(s.b3-1)) &
( s.f0.(s.b3)=IExec(body2,s).f0.(s.b3) or
s.f0.(s.b3-1)=IExec(body2,s).f0.(s.b3)) &
( s.f0.(s.b3)=IExec(body2,s).f0.(s.b3-1) or
s.f0.(s.b3-1)=IExec(body2,s).f0.(s.b3-1)) &
(for k be set st k<>(s.b3-1) & k<>s.b3 & k in dom (s.f0) holds
s.f0.k=IExec(body2,s).f0.k) &
(ex x1,x2 be Integer st x1=IExec(body2,s).f0.(s.b3-1) &
x2=IExec(body2,s).f0.(s.b3) & x1 >= x2)
proof
  let s be State of SCM+FSA;
  assume
A1: s.b3 <= len (s.f0) & s.b3 >= 2;
  then
A2: s.b3-1 >= 2-1 by XREAL_1:11;
  then
A3: abs((s.b3-1))=s.b3-1 by ABSVALUE:def 1;
A4: s.b3-1<=len (s.f0) by A1,XREAL_1:148,XXREAL_0:2;
A5: s.b3>= 1 by A1,XXREAL_0:2;
A6: abs(s.b3)=s.b3 by A1,ABSVALUE:def 1;
  reconsider k1=s.b3-1 as Element of NAT by A2,INT_1:16;
  reconsider k2=s.b3 as Element of NAT by A1,INT_1:16;
A7: k1 in dom (s.f0) by A2,A4,FINSEQ_3:27;
  reconsider n1=s.f0.k1 as Integer;
A8: k2 in dom (s.f0) by A1,A5,FINSEQ_3:27;
  reconsider n2=s.f0.k2 as Integer;
  set s0=Initialize s, s1=Exec(i1, s0), s2=IExec(i1 ';' i2, s),
  s3=IExec(i1 ';' i2 ';' i3,s), s4=IExec(i1 ';' i2 ';' i3 ';' i4,s),
  s5=IExec(i1 ';' i2 ';' i3 ';' i4 ';'i5,s), s6=IExec(body2,s);
A9: s1.b4=s0.b3 by SCMFSA_2:89
    .=s.b3 by SCMFSA6C:3;
A10: s1.f0=s0.f0 by SCMFSA_2:89
    .=s.f0 by SCMFSA6C:3;
A11: s1.b3=s.b3 by Th11;
A12: s1.a0=s0.a0 by SCMFSA_2:89
    .=1 by SCMFSA6C:3;
A13: s2.f0 =Exec(i2, s1).f0 by SCMFSA6C:10
    .=s.f0 by A10,SCMFSA_2:91;
A14: s2.b3 =Exec(i2, s1).b3 by SCMFSA6C:9
    .=s.b3-1 by A11,A12,SCMFSA_2:91;
A15: s2.b4=Exec(i2, s1).b4 by SCMFSA6C:9
    .=s.b3 by A9,Lm1,SCMFSA_2:91;
A16: s3.f0 = Exec(i3, s2).f0 by SCMFSA6C:8
    .=s.f0 by A13,SCMFSA_2:98;
A17: (s.f0)/.k1=n1 by A2,A4,FINSEQ_4:24;
A18: s3.b5=Exec(i3, s2).b5 by SCMFSA6C:7
    .=n1 by A3,A13,A14,A17,Th8;
A19: s3.b4=Exec(i3, s2).b4 by SCMFSA6C:7
    .=s.b3 by A15,Lm1,SCMFSA_2:98;
A20: s3.b3=Exec(i3, s2).b3 by SCMFSA6C:7
    .=s.b3-1 by A14,Lm1,SCMFSA_2:98;
A21: s4.f0 = Exec(i4, s3).f0 by SCMFSA6C:8
    .=s.f0 by A16,SCMFSA_2:98;
A22: (s.f0)/.k2=n2 by A1,A5,FINSEQ_4:24;
A23: s4.b6=Exec(i4, s3).b6 by SCMFSA6C:7
    .=n2 by A6,A16,A19,A22,Th8;
A24: s4.b3=Exec(i4, s3).b3 by SCMFSA6C:7
    .=s.b3-1 by A20,Lm1,SCMFSA_2:98;
A25: s4.b4=Exec(i4, s3).b4 by SCMFSA6C:7
    .=s.b3 by A19,Lm1,SCMFSA_2:98;
A26: s4.b5=Exec(i4, s3).b5 by SCMFSA6C:7
    .=s.f0.(s.b3-1) by A18,Lm1,SCMFSA_2:98;
A27: s5.f0=Exec(i5, s4).f0 by SCMFSA6C:8
    .=s.f0 by A21,SCMFSA_2:91;
A28: s5.b3=Exec(i5, s4).b3 by SCMFSA6C:7
    .=s.b3-1 by A24,Lm1,SCMFSA_2:91;
A29: s5.b4=Exec(i5, s4).b4 by SCMFSA6C:7
    .=s.b3 by A25,Lm1,SCMFSA_2:91;
A30: s5.b5=Exec(i5, s4).b5 by SCMFSA6C:7
    .=n1 by A26,Lm1,SCMFSA_2:91;
A31: s5.b6=Exec(i5, s4).b6 by SCMFSA6C:7
    .=n2- n1 by A23,A26,SCMFSA_2:91;
A32: s6.f0 = IExec(ifc,s5).f0 by SCMFSA6C:2;
  thus s6.b3 = IExec(ifc,s5).b3 by SCMFSA6C:1
    .=s.b3-1 by A28,Lm11;
  per cases;
  suppose
A33: s5.b6 >0;
    then
A34: s6.f0=s.f0+*(k1,n2) +*(k2,n1) by A3,A6,A22,A27,A28,A29,A30,A32, Lm10;
A35: dom (s.f0+*(k1,n2))=dom (s.f0) by FUNCT_7:32;
    then
A36: dom (s6.f0)=dom (s.f0) by A34,FUNCT_7:32;
A37: k2 in dom (s.f0+*(k1,n2)) by A1,A5,A35,FINSEQ_3:27;
A38: s6.f0.k2=s.f0.k1 by A8,A34,A35,FUNCT_7:33;
A39: now per cases;
      suppose k1=k2;
        hence s6.f0.k1=s.f0.k2;
      end;
      suppose k1<>k2;
        hence s6.f0.k1=(s.f0+*(k1,n2)).k1 by A34,FUNCT_7:34
          .=s.f0.k2 by A7,FUNCT_7:33;
      end;
    end;
A40: now
      let k be set;
      assume
A41:  k<>k1 & k<>k2 & k in dom (s.f0);
      hence s6.f0.k= (s.f0+*(k1,n2)).k by A34,FUNCT_7:34
        .= s.f0.k by A41,FUNCT_7:34;
    end;
    hence s.f0, s6.f0 are_fiberwise_equipotent by A7,A8,A36,A38,A39,RFINSEQ:41;
    thus s.f0.(s.b3)=IExec(body2,s).f0.(s.b3) or
    s.f0.(s.b3)=IExec(body2,s).f0.(s.b3-1) by A39;
    thus s.f0.(s.b3)=IExec(body2,s).f0.(s.b3) or
    s.f0.(s.b3-1)=IExec(body2,s).f0.(s.b3) by A34,A37,FUNCT_7:33;
    thus s.f0.(s.b3)=IExec(body2,s).f0.(s.b3-1) or
    s.f0.(s.b3-1)=IExec(body2,s).f0.(s.b3-1) by A39;
    thus for k be set st k<>(s.b3-1) & k<>s.b3 & k in dom (s.f0) holds
    s.f0.k=s6.f0.k by A40;
A42: n2-n1+n1 > 0+n1 by A31,A33,XREAL_1:8;
    take n2,n1;
    thus thesis by A8,A34,A35,A39,A42,FUNCT_7:33;
  end;
  suppose
A43: s5.b6 <=0;
    hence s.f0,s6.f0 are_fiberwise_equipotent by A27,A32,Lm10;
    thus s.f0.(s.b3)=IExec(body2,s).f0.(s.b3) or
    s.f0.(s.b3)=IExec(body2,s).f0.(s.b3-1) by A27,A32,A43,Lm10;
    thus s.f0.(s.b3)=IExec(body2,s).f0.(s.b3) or
    s.f0.(s.b3-1)=IExec(body2,s).f0.(s.b3) by A27,A32,A43,Lm10;
    thus s.f0.(s.b3)=IExec(body2,s).f0.(s.b3-1) or
    s.f0.(s.b3-1)=IExec(body2,s).f0.(s.b3-1) by A27,A32,A43,Lm10;
    thus for k be set st k<>(s.b3-1) & k<>s.b3 & k in dom (s.f0) holds
    s.f0.k=s6.f0.k by A27,A32,A43,Lm10;
A44: n2-n1+n1 <= 0+n1 by A31,A43,XREAL_1:8;
    take n1,n2;
    thus thesis by A27,A32,A43,A44,Lm10;
  end;
end;

Lm13: for s be State of SCM+FSA st s.b2>=0 & s.b2<s.b3 & s.b3 <= len (s.f0)
holds ex k be Element of NAT st k<=s.b3 & k>=s.b3-s.b2 &
IExec(T2,s).f0.k = s.f0.(s.b3)
proof
  let s be State of SCM+FSA;
  assume
A1: s.b2>=0 & s.b2<s.b3 & s.b3 <= len (s.f0);
  defpred P[Element of NAT] means
  for t be State of SCM+FSA st t.b2=$1 & t.b2<t.b3 & t.b3 <= len (t.f0)
  holds (for m be Element of NAT st m>t.b3 & m <= len (t.f0) holds
  t.f0.m=IExec(T2,t).f0.m) & ex n be Element of NAT st n<=t.b3 &
  n>=t.b3-$1 & IExec(T2,t).f0.n = t.f0.(t.b3);
A2: P[0]
  proof
    let t be State of SCM+FSA;
    assume
A3: t.b2=0 & t.b2<t.b3 & t.b3 <= len (t.f0);
    set If0=IExec(T2,t).f0;
    thus (for m be Element of NAT st m>t.b3 & m <= len (t.f0) holds
    t.f0.m=If0.m) by A3,SCM_HALT:80;
    reconsider n=t.b3 as Element of NAT by A3,INT_1:16;
    take n;
    thus n<=t.b3;
    thus n>=t.b3-0;
    thus IExec(T2,t).f0.n = t.f0.(t.b3) by A3,SCM_HALT:80;
  end;
  set sb2=SubFrom(b2,a0);
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    now
      let t be State of SCM+FSA;
      assume
A6:   t.b2=k+1 & t.b2<t.b3 & t.b3 <= len (t.f0);
      set t1=IExec(body2 ';'sb2,t), IB=IExec(body2,t), t2=IExec(T2,t1);
A7:   t1.b2= Exec(sb2, IB).b2 by SCM_HALT:33
        .=IB.b2-IB.a0 by SCMFSA_2:91
        .=IB.b2-1 by SCM_HALT:17
        .=(Initialize t).b2-1 by Lm4,SCM_HALT:63
        .=t.b2-1 by SCMFSA6C:3;
A8:   2 <= k+2 by NAT_1:11;
      k+1+1 <= t.b3 by A6,INT_1:20;
      then
A9:   2 <= t.b3 by A8,XXREAL_0:2;
A10:  t1.b3=Exec(sb2, IB).b3 by SCM_HALT:33
        .=IB.b3 by Lm1,SCMFSA_2:91
        .=t.b3-1 by A6,A9,Lm12;
A11:  t.b2-1 < t.b3-1 by A6,XREAL_1:11;
A12:  t1.b2 < t1.b3 by A6,A7,A10,XREAL_1:11;
A13:  t1.f0= Exec(sb2, IB).f0 by SCM_HALT:34
        .=IB.f0 by SCMFSA_2:91;
A14:  t.f0,IB.f0 are_fiberwise_equipotent by A6,A9,Lm12;
      then
A15:  len (t.f0) = len (t1.f0) by A13,RFINSEQ:16;
A16:  t1.b3 < t.b3 by A10,XREAL_1:148;
A17:  t1.b3 <= len (t1.f0) by A6,A10,A15,XREAL_1:148,XXREAL_0:2;
A18:  IExec(T2,t).f0=t2.f0 by A6,Lm4,SCM_HALT:82;
A19:  IB.f0 =Exec(sb2, IB).f0 by SCMFSA_2:91
        .=t1.f0 by SCM_HALT:34;
      thus for m be Element of NAT st m>t.b3 & m <= len (t.f0) holds
      t.f0.m=IExec(T2,t).f0.m
      proof
        let m be Element of NAT;
        assume
A20:    m>t.b3 & m <= len (t.f0);
A21:    t.b3>t.b3-1 by XREAL_1:148;
A22:    m > t1.b3 by A10,A20,XREAL_1:148,XXREAL_0:2;
A23:    m <= len (t1.f0) by A13,A14,A20,RFINSEQ:16;
        m>=2 by A9,A20,XXREAL_0:2;
        then m>=1 by XXREAL_0:2;
        then m in dom (t.f0) by A20,FINSEQ_3:27;
        hence t.f0.m=t1.f0.m by A6,A9,A19,A20,A21,Lm12
          .=IExec(T2,t).f0.m by A5,A6,A7,A12,A17,A18,A22,A23;
      end;
      hereby
        reconsider n=t.b3 as Element of NAT by A6,INT_1:16;
        per cases by A6,A9,Lm12;
        suppose
A24:      t.f0.(t.b3)=IExec(body2,t).f0.(t.b3);
          take n;
          thus n<=t.b3;
          n<=n+(k+1) by NAT_1:11;
          hence n>=t.b3-(k+1) by XREAL_1:22;
          thus IExec(T2,t).f0.n=t.f0.(t.b3)
          by A5,A6,A7,A10,A11,A15,A16,A17,A18,A19,A24;
        end;
        suppose
A25:      t.f0.(t.b3)=IExec(body2,t).f0.(t.b3-1);
          consider m be Element of NAT such that
A26:      m<=t1.b3 & m>=t1.b3-k &
          IExec(T2,t1).f0.m = t1.f0.(t1.b3) by A5,A6,A7,A12,A17;
          take m;
          thus m<=t.b3 by A10,A26,XREAL_1:148,XXREAL_0:2;
          thus m>=t.b3-(k+1) by A10,A26;
          thus IExec(T2,t).f0.m =t.f0.(t.b3)
          by A6,A10,A19,A25,A26,Lm4,SCM_HALT:82;
        end;
      end;
    end;
    hence P[k+1];
  end;
A27: for k be Element of NAT holds P[k] from NAT_1:sch 1(A2,A4);
  reconsider i=s.b2 as Element of NAT by A1,INT_1:16;
  P[i] by A27;
  hence thesis by A1;
end;

Lm14: for k be Element of NAT holds (
for t be State of SCM+FSA st k=t.b2 & k< t.b3 & t.b3 <= len (t.f0) holds
(t.f0, IExec(T2,t).f0 are_fiberwise_equipotent) & (for m be Element of NAT
st m <(t.b3-k) & m>=1 or (m>t.b3 & m in dom (t.f0)) holds
t.f0.m=IExec(T2,t).f0.m) &
(for m be Element of NAT st m >= (t.b3-k) & m<=t.b3 holds
(ex x1,x2 be Integer st
x1 =IExec(T2,t).f0.(t.b3-k) & x2=IExec(T2,t).f0.m & x1 >= x2)) &
for i be Element of NAT st i>=t.b3-k & i<=t.b3 holds
ex n be Element of NAT st n>=t.b3-k & n<=t.b3 & IExec(T2,t).f0.i=t.f0.n )
proof
  defpred P[Element of NAT] means
  for t be State of SCM+FSA st $1=t.b2 & $1 < t.b3 & t.b3 <= len (t.f0) holds
  (t.f0, IExec(T2,t).f0 are_fiberwise_equipotent) & (for m be Element of NAT
  st m <(t.b3-$1) & m>=1 or (m>t.b3 & m in dom (t.f0)) holds
  t.f0.m=IExec(T2,t).f0.m) &
  (for m be Element of NAT st m >= (t.b3-$1) & m<=t.b3 holds
  (ex x1,x2 be Integer st
  x1 =IExec(T2,t).f0.(t.b3-$1) & x2=IExec(T2,t).f0.m & x1 >= x2)) &
  for i be Element of NAT st i>=t.b3-$1 & i<=t.b3 holds
  ex n be Element of NAT st n>=t.b3-$1 & n<=t.b3 & IExec(T2,t).f0.i=t.f0.n;
  now
    let t be State of SCM+FSA;
    assume
A1: 0=t.b2 & 0 < t.b3 & t.b3 <= len (t.f0);
    set If0=IExec(T2,t).f0;
    thus t.f0, If0 are_fiberwise_equipotent by A1,SCM_HALT:80;
    thus for m be Element of NAT
    st m < (t.b3-0) & m>=1 or (m>t.b3 & m in dom (t.f0))
    holds t.f0.m=IExec(T2,t).f0.m by A1,SCM_HALT:80;
    hereby
      let m be Element of NAT;
      assume
   m >= (t.b3-0) & m<=t.b3;
      then
A3:   m=t.b3 by XXREAL_0:1;
      reconsider n1=t.f0.m as Integer;
      take x1=n1,x2=n1;
      thus x1=IExec(T2,t).f0.(t.b3-0) by A1,A3,SCM_HALT:80;
      thus x2=If0.m by A1,SCM_HALT:80;
      thus x1 >= x2;
    end;
    let i be Element of NAT;
    assume
A4: i>=t.b3-0 & i<=t.b3;
    take n=i;
    thus n>=t.b3-0 & n<=t.b3 by A4;
    thus IExec(T2,t).f0.i=t.f0.n by A1,SCM_HALT:80;
  end;
  then
A5: P[0];
  set sb2=SubFrom(b2,a0);
A6: now
    let k be Element of NAT;
    assume
A7: P[k];
    now
      let t be State of SCM+FSA;
      set t1=IExec(body2 ';'sb2,t), IB=IExec(body2,t), t2=IExec(T2,t1);
      assume
A8:   k+1=t.b2 & k+1 < t.b3 & t.b3 <= len (t.f0);
A9:   t1.b2= Exec(sb2, IB).b2 by SCM_HALT:33
        .=IB.b2-IB.a0 by SCMFSA_2:91
        .=IB.b2-1 by SCM_HALT:17
        .=(Initialize t).b2-1 by Lm4,SCM_HALT:63
        .=k+1-1 by A8,SCMFSA6C:3
        .=k;
A10:  2 <= k+2 by NAT_1:11;
      k+1+1 <= t.b3 by A8,INT_1:20;
      then
A11:  2 <= t.b3 by A10,XXREAL_0:2;
A12:  t1.b3=Exec(sb2, IB).b3 by SCM_HALT:33
        .=IB.b3 by Lm1,SCMFSA_2:91
        .=t.b3-1 by A8,A11,Lm12;
A13:  k+1-1 < t.b3-1 by A8,XREAL_1:11;
A14:  t1.f0= Exec(sb2, IB).f0 by SCM_HALT:34
        .=IB.f0 by SCMFSA_2:91;
A15:  t.f0,IB.f0 are_fiberwise_equipotent by A8,A11,Lm12;
      then
A16:  len (t.f0) = len (t1.f0) by A14,RFINSEQ:16;
A17:  t.b3 <= len (t1.f0) by A8,A14,A15,RFINSEQ:16;
A18:  t1.b3 <= len (t1.f0) by A8,A12,A16,XREAL_1:148,XXREAL_0:2;
A19:  t.b3=t1.b3+1 by A12;
A20:  (t1.f0, t2.f0 are_fiberwise_equipotent) &
      (for m be Element of NAT st m < (t1.b3-k) & m>=1 or (m>t1.b3
      & m in dom (t1.f0)) holds t1.f0.m=t2.f0.m) &
      (for m be Element of NAT st m >= (t1.b3-k) & m<=t1.b3 holds (ex x1,x2
      be Integer st x1 =t2.f0.(t1.b3-k) & x2=t2.f0.m & x1 >= x2)) &
      for i be Element of NAT st i>=t1.b3-k & i<=t1.b3 holds
      ex n be Element of NAT st n>=t1.b3-k & n<=t1.b3 &
      t2.f0.i=t1.f0.n by A7,A9,A12,A13,A18;
A21:  IExec(T2,t).f0=t2.f0 by A8,Lm4,SCM_HALT:82;
      t1.f0, IExec(T2,t).f0 are_fiberwise_equipotent by A8,A20,Lm4,
      SCM_HALT:82;
      hence t.f0,IExec(T2,t).f0 are_fiberwise_equipotent by A14,A15,RFINSEQ:2;
A22:  t.b3-(k+1)=t1.b3-k by A12;
      consider n1,n2 be Integer such that
A23:  n1=IB.f0.(t.b3-1) & n2=IB.f0.(t.b3) & n1 >= n2 by A8,A11,Lm12;
A24:  IB.f0 =Exec(sb2, IB).f0 by SCMFSA_2:91
        .=t1.f0 by SCM_HALT:34;
A25:  t.b3 is Element of NAT by A8,INT_1:16;
A26:  t.b3 >= 1 by A11,XXREAL_0:2;
      then
A27:  t.b3 in dom (t1.f0) by A8,A16,A25,FINSEQ_3:27;
      hereby
        let m be Element of NAT;
        assume
A28:    m <(t.b3-(k+1)) & m>=1 or (m>t.b3 & m in dom (t.f0));
        per cases by A28;
        suppose
A29:      m < (t.b3-(k+1)) & m>=1;
A30:      t.b3-(k+1)+(k+1)=t.b3;
A31:      m+(k+1) < t.b3-(k+1)+(k+1) by A29,XREAL_1:8;
A32:      m+(k+1) < t.b3 by A29,A30,XREAL_1:8;
          m<=m+(k+1) by NAT_1:11;
          then m<=t.b3 by A31,XXREAL_0:2;
          then m<=len(t1.f0) by A8,A16,XXREAL_0:2;
          then
A33:      m in dom (t.f0) by A16,A29,FINSEQ_3:27;
A34:      m<>t.b3 by A29,A30,XREAL_1:31;
          m<>t.b3-1
          proof
            assume
A35:        m=t.b3-1;
            m+(k+1)=m+1+k;
            hence contradiction by A32,A35,NAT_1:11;
          end;
          hence t.f0.m=t1.f0.m by A8,A11,A24,A33,A34,Lm12
            .=IExec(T2,t).f0.m by A7,A9,A13,A18,A21,A22,A29;
        end;
        suppose
A36:      m>t.b3 & m in dom (t.f0);
          then
A37:      m in dom (t1.f0) by A14,A15,RFINSEQ:16;
A38:      t.b3>t.b3-1 by XREAL_1:148;
A39:      m >t1.b3 by A12,A36,XREAL_1:148,XXREAL_0:2;
          thus t.f0.m=t1.f0.m by A8,A11,A24,A36,A38,Lm12
            .=IExec(T2,t).f0.m by A7,A9,A12,A13,A18,A21,A37,A39;
        end;
      end;
      hereby
        let m be Element of NAT;
        assume
A40:    m >= (t.b3-(k+1)) & m<=t.b3;
        consider nn be Element of NAT such that
A41:    nn<=t1.b3 & nn>=t1.b3-t1.b2 & t2.f0.nn = t1.f0.(t1.b3)
        by A9,A12,A13,A18,Lm13;
        consider y1,y2 be Integer such that
A42:    y1 =t2.f0.(t1.b3-k) & y2=t2.f0.nn & y1 >= y2 by A7,A9,A12,A13,A18,A41;
        per cases;
        suppose
A43:      m>t1.b3;
          then m>=t1.b3+1 by INT_1:20;
          then
A44:      m=t.b3 by A12,A40,XXREAL_0:1;
          take y1,n2;
          thus y1=IExec(T2,t).f0.(t.b3-(k+1)) by A8,A12,A42,Lm4, SCM_HALT:82;
          thus n2=IExec(T2,t).f0.m by A7,A9,A12,A13,A18,A21,A23,A24
          ,A27,A43,A44;
          thus y1 >= n2 by A12,A23,A24,A41,A42,XXREAL_0:2;
        end;
        suppose m<=t1.b3;
          then consider y1,y2 be Integer such that
A45:      y1 =t2.f0.(t1.b3-k) & y2=t2.f0.m & y1 >= y2
          by A7,A9,A12,A13,A18,A40;
          take y1,y2;
          thus y1=IExec(T2,t).f0.(t.b3-(k+1)) by A8,A12,A45,Lm4, SCM_HALT:82;
          thus y2=IExec(T2,t).f0.m by A8,A45,Lm4,SCM_HALT:82;
          thus y1>=y2 by A45;
        end;
      end;
      thus for i be Element of NAT st i>=t.b3-(k+1) & i<=t.b3 holds
      ex n be Element of NAT st n>=t.b3-(k+1) & n<=t.b3 &
      IExec(T2,t).f0.i=t.f0.n
      proof
        let i be Element of NAT;
        assume
A46:    i>=t.b3-(k+1) & i<=t.b3;
        per cases;
        suppose
A47:      i=t.b3;
          then
A48:      i>t1.b3 by A19,XREAL_1:31;
A49:      i in dom (t1.f0) by A17,A26,A47,FINSEQ_3:27;
          hereby
            per cases by A8,A11,Lm12;
            suppose
A50:          t.f0.(t.b3)=IExec(body2,t).f0.(t.b3);
              reconsider n=t.b3 as Element of NAT by A8,INT_1:16;
              take n;
              thus n>=t.b3-(k+1) & n<=t.b3 by A46,A47;
              thus IExec(T2,t).f0.i=t.f0.n by A7,A9,A12,A13,A18,A21,A24
              ,A47,A48,A49,A50;
            end;
            suppose
A51:          t.f0.(t.b3-1)=IExec(body2,t).f0.(t.b3);
              t.b3-1>=1-1 by A26,XREAL_1:11;
              then reconsider n=t.b3-1 as Element of NAT by INT_1:16;
              take n;
              n<=n+k by NAT_1:11;
              hence n>=t.b3-(k+1) by A22,XREAL_1:22;
              thus n<=t.b3 by XREAL_1:148;
              thus IExec(T2,t).f0.i=t.f0.n by A7,A9,A12,A13,A18,A21,A24
              ,A47,A48,A49,A51;
            end;
          end;
        end;
        suppose i<>t.b3;
          then i < t.b3 by A46,XXREAL_0:1;
          then i+1 <= t.b3 by INT_1:20;
          then i<=t1.b3 by A12,XREAL_1:21;
          then consider n be Element of NAT such that
A52:      n>=t1.b3-k & n<=t1.b3 & t2.f0.i=t1.f0.n by A7,A9,A12,A13,A18,A46;
          thus ex n be Element of NAT st n>=t.b3-(k+1) & n<=t.b3 &
          IExec(T2,t).f0.i=t.f0.n
          proof
            per cases;
            suppose
A53:          n=t1.b3;
              hereby
                per cases by A8,A11,Lm12;
                suppose
A54:              t.f0.(t.b3)=IExec(body2,t).f0.(t.b3-1);
                  reconsider m=t.b3 as Element of NAT by A8,INT_1:16;
                  take m;
                  m <= m +(k+1) by NAT_1:11;
                  hence m >= t.b3-(k+1) by XREAL_1:22;
                  thus m <= t.b3;
                  thus IExec(T2,t).f0.i=t.f0.m by A8,A12,A24,A52,A53,A54,Lm4,
                  SCM_HALT:82;
                end;
                suppose
A55:              t.f0.(t.b3-1)=IExec(body2,t).f0.(t.b3-1);
                  take n;
                  thus n>=t.b3-(k+1) by A12,A52;
                  thus n<=t.b3 by A12,A53,XREAL_1:148;
                  thus IExec(T2,t).f0.i=t.f0.n by A8,A12,A24,A52,A53,A55,Lm4,
                  SCM_HALT:82;
                end;
              end;
            end;
            suppose
A56:          n<>t1.b3;
A57:          t1.b3 < t.b3 by A12,XREAL_1:148;
A58:          n<t.b3 by A12,A52,XREAL_1:148,XXREAL_0:2;
              k-k < t1.b3-k by A12,A13,XREAL_1:11;
              then
A59:          n>=1 by A52,INT_1:20;
              n<= len (t1.f0) by A8,A16,A58,XXREAL_0:2;
              then
A60:          n in dom (t.f0) by A16,A59,FINSEQ_3:27;
              take n;
              thus n>=t.b3-(k+1) by A12,A52;
              thus n<=t.b3 by A12,A52,XREAL_1:148,XXREAL_0:2;
              thus IExec(T2,t).f0.i=t.f0.n by A8,A11,A12,A21,A24,A52,A56
              ,A57,A60,Lm12;
            end;
          end;
        end;
      end;
    end;
    hence P[k + 1];
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A5,A6);
  hence thesis;
end;

Lm15: for s be State of SCM+FSA holds IExec(Sb,s).b2=s.b1-1 &
IExec(Sb,s).b3=len (s.f0) & IExec(Sb,s).f0=s.f0
proof
  let s be State of SCM+FSA;
  set s0=Initialize s, s1=Exec(j1,s0), s2=IExec(j1 ';'j2,s),
  s3=IExec(j1 ';' j2 ';' j3,s);
A1: s1.b2=s0.b1 by SCMFSA_2:89
    .=s.b1 by SCMFSA6C:3;
A2: s1.f0=s0.f0 by SCMFSA_2:89
    .=s.f0 by SCMFSA6C:3;
A3: s1.a0=s0.a0 by SCMFSA_2:89
    .=1 by SCMFSA6C:3;
A4: s2.f0 =Exec(j2, s1).f0 by SCMFSA6C:10
    .=s.f0 by A2,SCMFSA_2:91;
A5: s2.b2 =Exec(j2, s1).b2 by SCMFSA6C:9
    .=s.b1-1 by A1,A3,SCMFSA_2:91;
  thus s3.b2 = Exec(j3, s2).b2 by SCMFSA6C:7
    .=s.b1-1 by A5,Lm1,SCMFSA_2:100;
  thus s3.b3 = Exec(j3, s2).b3 by SCMFSA6C:7
    .=len(s.f0) by A4,SCMFSA_2:100;
  thus s3.f0 = Exec(j3, s2).f0 by SCMFSA6C:8
    .=s.f0 by A4,SCMFSA_2:100;
end;

Lm16: for s be State of SCM+FSA st s.b1=len (s.f0) holds
(s.f0, IExec(T1,s).f0 are_fiberwise_equipotent) &
(for i,j be Element of NAT st i>=1 & j<=len (s.f0) & i<j
for x1,x2 be Integer st x1 =IExec(T1,s).f0.i &
x2=IExec(T1,s).f0.j holds x1 >= x2)
proof
  let s be State of SCM+FSA;
  assume
A1: s.b1=len (s.f0);
  per cases;
  suppose
A2: len (s.f0)=0;
    hence s.f0, IExec(T1,s).f0 are_fiberwise_equipotent by A1,Lm8,SCM_HALT:80;
    thus thesis by A2;
  end;
  suppose
A3: len (s.f0)<>0;
    defpred P[Element of NAT] means
    for t be State of SCM+FSA st t.b1=$1+1 & t.b1<=len (t.f0) holds
    (t.f0, IExec(T1,t).f0 are_fiberwise_equipotent) &
    (for i,j be Element of NAT st i>=len(t.f0)-$1 & j<=len (t.f0) & i<j
    for x1,x2 be Integer st x1 =IExec(T1,t).f0.i & x2=IExec(T1,t).f0.j
    holds x1 >= x2) & (for i be Element of NAT st i<len(t.f0)-$1 & i>=1
    holds IExec(T1,t).f0.i=t.f0.i) &
    (for i be Element of NAT st i>=len(t.f0)-$1 & i<=len (t.f0) holds
    ex n be Element of NAT st n>=len(t.f0)-$1 & n<=len (t.f0) &
    IExec(T1,t).f0.i=t.f0.n);
    set B11=SubFrom(b1,a0);
A4: P[0]
    proof
      let t be State of SCM+FSA;
      assume
A5:   t.b1=0+1 & t.b1 <= len (t.f0);
      set IB=IExec(body1 ';' B11,t);
A6:   IB.b1=1-1 by A5,Lm7,Lm8,SCM_HALT:79;
A7:   IExec(Sb,t).b2=1-1 by A5,Lm15;
A8:   IExec(T1,t).f0=IExec(T1,IB).f0 by A5,Lm7,Lm8,SCM_HALT:82
        .=IB.f0 by A6,Lm8,SCM_HALT:80
        .=Exec(B11,IExec(body1,t)).f0 by Lm8,SCM_HALT:34
        .=IExec(body1,t).f0 by SCMFSA_2:91
        .=IExec(T2,IExec(Sb,t)).f0 by Lm5,SCM_HALT:31
        .=IExec(Sb,t).f0 by A7,SCM_HALT:80
        .=t.f0 by Lm15;
      hence t.f0, IExec(T1,t).f0 are_fiberwise_equipotent;
      thus for i,j be Element of NAT st i>=len(t.f0)-0 & j<=len (t.f0) & i<j
      for x1,x2 be Integer st x1 =IExec(T1,t).f0.i &
      x2=IExec(T1,t).f0.j holds x1 >= x2 by XXREAL_0:2;
      thus for i be Element of NAT st i<len(t.f0)-0 & i>=1 holds
      IExec(T1,t).f0.i=t.f0.i by A8;
      let i be Element of NAT;
      assume
A9:   i>=len(t.f0)-0 & i<=len (t.f0);
      take n=i;
      thus n>=len(t.f0)-0 & n<=len (t.f0) by A9;
      thus IExec(T1,t).f0.i=t.f0.n by A8;
    end;
A10: now
      let k be Element of NAT;
      assume
A11:  P[k];
      now
        let t be State of SCM+FSA;
        set t1=IExec(body1 ';'B11,t), IB=IExec(body1,t), t2=IExec(T1,t1);
        assume
A12:    t.b1=(k+1)+1 & t.b1<=len (t.f0);
A13:    t1.b1= Exec(B11, IB).b1 by Lm8,SCM_HALT:33
          .=IB.b1-IB.a0 by SCMFSA_2:91
          .=IB.b1-1 by Lm8,SCM_HALT:17
          .=(Initialize t).b1-1 by Lm7,Lm8,SCM_HALT:63
          .=(k+1)+1-1 by A12,SCMFSA6C:3
          .=k+1;
        then t1.b1 < t.b1 by A12,XREAL_1:31;
        then
A14:    t1.b1 <= len (t.f0) by A12,XXREAL_0:2;
        set Ts=IExec(Sb,t);
A15:    Ts.b2=(k+1)+1-1 by A12,Lm15
          .=k+1;
A16:    Ts.b3=len (t.f0) by Lm15;
        then
A17:    Ts.b3=len (Ts.f0) by Lm15;
A18:    k+1 < (k+1)+1 by XREAL_1:31;
A19:    k+1 < t.b1 by A12,XREAL_1:31;
A20:    k+1 < len (t.f0) by A12,A18,XXREAL_0:2;
A21:    k+1 < Ts.b3 by A12,A16,A19,XXREAL_0:2;
A22:    (Ts.f0, IExec(T2,Ts).f0 are_fiberwise_equipotent) &
        (for m be Element of NAT
        st m <(Ts.b3-(k+1)) & m>=1 or (m>Ts.b3 & m in dom (Ts.f0))
        holds Ts.f0.m=IExec(T2,Ts).f0.m) &
        (for m be Element of NAT st m >= (Ts.b3-(k+1)) & m<=Ts.b3 holds
        (ex x1,x2 be Integer st x1 =IExec(T2,Ts).f0.(Ts.b3-(k+1)) &
        x2=IExec(T2,Ts).f0.m & x1 >= x2)) &
        for i be Element of NAT st i>=Ts.b3-(k+1) & i<=Ts.b3 holds
        ex n be Element of NAT st n>=Ts.b3-(k+1) & n<=Ts.b3 &
        IExec(T2,Ts).f0.i=Ts.f0.n by A15,A16,A17,A20,Lm14;
A23:    Ts.f0=t.f0 by Lm15;
A24:    t1.f0= Exec(B11,IB).f0 by Lm8,SCM_HALT:34
          .=IB.f0 by SCMFSA_2:91
          .=IExec(T2,Ts).f0 by Lm5,SCM_HALT:31;
        then
A25:    t.f0,t1.f0 are_fiberwise_equipotent by A15,A16,A21,A23, Lm14;
A26:    len (t.f0) = len (t1.f0) by A22,A23,A24,RFINSEQ:16;
A27:    t1.b1 <= len (t1.f0) by A14,A25,RFINSEQ:16;
A28:    (t1.f0, IExec(T1,t1).f0 are_fiberwise_equipotent) &
        (for i,j be Element of NAT st i>=len(t1.f0)-k & j<=len (t1.f0) & i<j
        for x1,x2 be Integer st x1 =IExec(T1,t1).f0.i & x2=IExec(T1,t1).f0.j
        holds x1 >= x2) & (for i be Element of NAT
        st i<len(t1.f0)-k & i>=1 holds IExec(T1,t1).f0.i=t1.f0.i)&
        (for i be Element of NAT st i>=len(t1.f0)-k & i<=len (t1.f0) holds
        ex n be Element of NAT st n>=len(t1.f0)-k & n<=len (t1.f0) &
        IExec(T1,t1).f0.i=t1.f0.n) by A11,A13,A14,A26;
A29:    IExec(T1,t).f0=t2.f0 by A12,Lm7,Lm8,SCM_HALT:82;
        hence t.f0,IExec(T1,t).f0 are_fiberwise_equipotent
        by A25,A28,RFINSEQ:2;
        set lk=len(t.f0)-(k+1);
A30:    lk+1=len (t1.f0)-k by A26;
        thus for i,j be Element of NAT
        st i>=len(t.f0)-(k+1) & j<=len (t.f0) & i<j
        for x1,x2 be Integer st x1 =IExec(T1,t).f0.i &
        x2=IExec(T1,t).f0.j holds x1 >= x2
        proof
          let i,j be Element of NAT;
          assume
A31:      i>=lk & j<=len (t.f0) & i<j;
          then j > lk by XXREAL_0:2;
          then j >= len (t1.f0)-k by A30,INT_1:20;
          then consider n be Element of NAT such that
A32:      n>=len(t1.f0)-k & n<=len (t1.f0) &
          IExec(T1,t1).f0.j=t1.f0.n by A11,A13,A14,A26,A31;
          lk < lk +1 by XREAL_1:31;
          then
A33:      n >= Ts.b3-(k+1) by A16,A26,A32,XXREAL_0:2;
A34:      n <= Ts.b3 by A26,A32,Lm15;
          hereby
            let x1,x2 be Integer;
            assume
A35:        x1 =IExec(T1,t).f0.i & x2=IExec(T1,t).f0.j;
            per cases;
            suppose
A36:          i=lk;
              consider y1,y2 be Integer such that
A37:          y1 =IExec(T2,Ts).f0.(Ts.b3-(k+1)) & y2=IExec(T2,Ts).f0.n
              & y1 >= y2 by A15,A17,A21,A33,A34,Lm14;
A38:          i<len(t1.f0)-k by A30,A36,XREAL_1:31;
A39:          1<=i by A12,A36,XREAL_1:21;
              i=Ts.b3-(k+1) by A36,Lm15;
              hence x1 >= x2 by A11,A13,A14,A24,A26,A29,A32,A35,A37,A38,A39;
            end;
            suppose i<>lk;
              then i>lk by A31,XXREAL_0:1;
              then i>=len (t1.f0)-k by A30,INT_1:20;
              hence x1 >= x2 by A11,A13,A14,A26,A29,A31,A35;
            end;
          end;
        end;
        thus for i be Element of NAT st i<len(t.f0)-(k+1) & i>=1 holds
        IExec(T1,t).f0.i=t.f0.i
        proof
          let i be Element of NAT;
          assume
A40:      i<lk & i>=1;
          lk < lk+1 by XREAL_1:31;
          then i < len (t1.f0)-k by A26,A40,XXREAL_0:2;
          hence IExec(T1,t).f0.i=t1.f0.i by A11,A13,A27,A29,A40
            .=t.f0.i by A15,A16,A21,A23,A24,A40,Lm14;
        end;
        thus for i be Element of NAT
        st i>=len(t.f0)-(k+1) & i<=len (t.f0) holds
        ex n be Element of NAT st n>=len(t.f0)-(k+1) & n<=len (t.f0) &
        IExec(T1,t).f0.i=t.f0.n
        proof
          let i be Element of NAT;
          assume
A41:      i>=len(t.f0)-(k+1) & i<=len (t.f0);
          per cases;
          suppose
A42:        i=lk;
            then
A43:        i < len(t1.f0)-k by A30,XREAL_1:31;
A44:        i >= 1 by A12,A42,XREAL_1:21;
            consider n be Element of NAT such that
A45:        n>=Ts.b3-(k+1) & n<=Ts.b3 & IExec(T2,Ts).f0.i=Ts.f0.n
            by A15,A16,A17,A20,A41,Lm14;
            take n;
            thus n>=len(t.f0)-(k+1) by A45,Lm15;
            thus n<=len(t.f0) by A45,Lm15;
            thus IExec(T1,t).f0.i=t.f0.n by A11,A13,A23,A24,A27,A29,A43,A44,
            A45;
          end;
          suppose i<>lk;
            then i >lk by A41,XXREAL_0:1;
            then i >= len (t1.f0)-k by A30,INT_1:20;
            then consider m be Element of NAT such that
A46:        m>=len(t1.f0)-k & m<=len (t1.f0) & IExec(T1,t1).f0.i=t1.f0.m
            by A11,A13,A14,A26,A41;
            lk+1 > lk by XREAL_1:31;
            then m>Ts.b3-(k+1) by A16,A26,A46,XXREAL_0:2;
            then consider n be Element of NAT such that
A47:        n>=Ts.b3-(k+1) & n<=Ts.b3 & IExec(T2,Ts).f0.m=Ts.f0.n
            by A15,A16,A17,A20,A26,A46,Lm14;
            take n;
            thus n>=len(t.f0)-(k+1) by A47,Lm15;
            thus n<=len(t.f0) by A47,Lm15;
            thus IExec(T1,t).f0.i=t.f0.n by A24,A29,A46,A47,Lm15;
          end;
        end;
      end;
      hence P[k+1];
    end;
A48: for k be Element of NAT holds P[k] from NAT_1:sch 1(A4,A10);
    len (s.f0)>0 by A3;
    then s.b1>=1+0 by A1,INT_1:20;
    then reconsider m=s.b1-1 as Element of NAT by INT_1:18;
A49: m+1=s.b1;
    hence s.f0, IExec(T1,s).f0 are_fiberwise_equipotent by A1,A48;
    len (s.f0)-m=1 by A1;
    hence thesis by A48,A49;
  end;
end;

theorem Th65:
  for s be State of SCM+FSA holds
  (s.(fsloc 0), IExec(bubble-sort (fsloc 0),s).(fsloc 0)
  are_fiberwise_equipotent) &
  (for i,j be Element of NAT st i>=1 & j<=len (s.(fsloc 0)) & i<j
  for x1,x2 be Integer st x1 =IExec(bubble-sort (fsloc 0),s).(fsloc 0).i &
  x2=IExec(bubble-sort (fsloc 0),s).(fsloc 0).j holds x1 >= x2)
proof
  let s be State of SCM+FSA;
  set W27=w2 ';' w3 ';' w4 ';' w5 ';' w6 ';' w7, s0=Initialize s,
  s1=Exec(w2, s0), s2=IExec(w2 ';' w3, s), s3=IExec(w2 ';' w3 ';' w4,s),
  s4=IExec(w2 ';' w3 ';' w4 ';' w5,s),
  s5=IExec(w2 ';' w3 ';' w4 ';' w5 ';' w6,s), s6=IExec(W27,s);
A1: s5.f0 =Exec(w6, s4).f0 by SCMFSA6C:8
    .=s4.f0 by SCMFSA_2:89
    .=Exec(w5, s3).f0 by SCMFSA6C:8
    .=s3.f0 by SCMFSA_2:89
    .=Exec(w4, s2).f0 by SCMFSA6C:8
    .=s2.f0 by SCMFSA_2:89
    .=Exec(w3, s1).f0 by SCMFSA6C:10
    .=s1.f0 by SCMFSA_2:89
    .=s0.f0 by SCMFSA_2:89
    .=s.f0 by SCMFSA6C:3;
A2: s6.f0 =Exec(w7, s5).f0 by SCMFSA6C:8
    .=s.f0 by A1,SCMFSA_2:100;
A3: s6.b1=Exec(w7, s5).b1 by SCMFSA6C:7
    .=len (s6.f0) by A1,A2,SCMFSA_2:100;
A4: IExec(bubble-sort f0,s).f0=IExec(T1,s6).f0 by Lm9,SCM_HALT:31;
  hence s.f0, IExec(bubble-sort f0,s).f0 are_fiberwise_equipotent by A2,A3,
  Lm16;
  let i,j be Element of NAT;
  assume i>=1 & j<=len (s.f0) & i<j;
  hence thesis by A2,A3,A4,Lm16;
end;

theorem Th66:
  for i being Element of NAT, s being State of SCM+FSA,
  w being FinSequence of INT
  st Initialized Bubble-Sort-Algorithm +* ((fsloc 0) .--> w) c= s
  holds IC  Computation( s,i) in dom Bubble-Sort-Algorithm
proof
  set Ba=Bubble-Sort-Algorithm, Ib=Initialized Ba;
  let i be Element of NAT, s be State of SCM+FSA,w be FinSequence of INT;
  set x=((fsloc 0) .--> w);
  assume
A1: Ib +* x c= s;
  dom Ib misses dom x by Th46;
  then Ib c= Ib +* x by FUNCT_4:33;
  then
A2: Ib c= s by A1,XBOOLE_1:1;
  Ba is InitHalting Program of SCM+FSA by Th64;
  hence thesis by A2,SCM_HALT:def 1;
end;

theorem Th67:
  for s be State of SCM+FSA,t be FinSequence of INT st
  Initialized Bubble-Sort-Algorithm +*(fsloc 0 .--> t) c= s
  holds ex u being FinSequence of REAL
  st t,u are_fiberwise_equipotent & u is non-increasing &
  u is FinSequence of INT & (Result s).(fsloc 0) = u
proof
  let s be State of SCM+FSA,t be FinSequence of INT;
  set Ba=Bubble-Sort-Algorithm, p=Initialized Ba, x=fsloc 0 .--> t,
  z=IExec(bubble-sort f0,s).f0;
  assume
A1: p+*x c= s;
  dom x = { f0} by FUNCOP_1:19;
  then
A2: f0 in dom x by TARSKI:def 1;
  then f0 in dom (p+*x) by FUNCT_4:13;
  then
A3: s.f0=(p+*x).f0 by A1,GRFUNC_1:8
    .=x.f0 by A2,FUNCT_4:14
    .=t by FUNCOP_1:87;
A4: (s.f0, z are_fiberwise_equipotent) &
  (for i,j be Element of NAT st i>=1 & j<=len (s.f0) & i<j
  for x1,x2 be Integer st x1 =z.i & x2=z.j holds x1 >= x2) by Th65;
  reconsider u=z as FinSequence of REAL by FINSEQ_3:126;
  take u;
  thus t, u are_fiberwise_equipotent by A3,Th65;
A5: dom (s.f0) = dom u by A4,RFINSEQ:16;
  now
    let i,j be Element of NAT;
    assume
A6: i in dom u & j in dom u & i<j;
    then
A7: i>=1 by FINSEQ_3:27;
A8: j<=len (s.f0) by A5,A6,FINSEQ_3:27;
    reconsider y1=z.i as Integer;
    reconsider y2=z.j as Integer;
    y1 >= y2 by A6,A7,A8,Th65;
    hence u.i>=u.j;
  end;
  hence u is non-increasing by RFINSEQ:32;
  thus u is FinSequence of INT;
  dom p misses dom x by Th46;
  then p c=p+*x by FUNCT_4:33;
  then p c= s by A1,XBOOLE_1:1;
  then s=s+*p by FUNCT_4:79;
  hence (Result s).f0 =u by Th57;
end;

theorem Th68:
  for w being FinSequence of INT holds
  Initialized Bubble-Sort-Algorithm +* ((fsloc 0) .--> w) is autonomic
proof
  let w be FinSequence of INT;
  set p=Initialized Bubble-Sort-Algorithm +* ((fsloc 0) .--> w),
  q=Bubble-Sort-Algorithm;
A1: for s1,s2 being State of SCM+FSA,i st p c= s1 & p c= s2 & i <= 10 holds
  Computation(s1,i).intloc 0 = Computation(s2,i).intloc 0 &
  Computation(s1,i).IC SCM+FSA = Computation(s2,i).IC SCM+FSA &
  Computation(s1,i).fsloc 0 = Computation(s2,i).fsloc 0
  proof
    let s1,s2 be State of SCM+FSA,i;
    assume
A2: p c= s1 & p c=s2 & i <= 10;
A3: Computation(s1,0) = s1 & Computation(s2,0) = s2 by AMI_1:13;
A4: s1 starts_at 0 by A2,Th47,AMI_1:92;
A5: s2 starts_at 0 by A2,Th47,AMI_1:92;
A6: q c= s1 & q c=s2 by A2,Th53;
A7: s1.intloc 0 =1 by A2,Th54
      .= s2.intloc 0 by A2,Th54;
A8: s1.fsloc 0 =w by A2,Th54
      .=s2.fsloc 0 by A2,Th54;
A9: IC s1 = insloc 0 by A4,AMI_1:def 41
      .= IC s2 by A5,AMI_1:def 41;
    per cases by A2,NAT_1:35;
    suppose
A10:  i = 0;
      hence Computation(s1,i).intloc 0 = Computation(s2,i).intloc 0 by A3,A7;
      thus (Computation(s1,i)).IC SCM+FSA = (Computation(s2,i)).IC SCM+FSA
       by A3,A9,A10;
      thus Computation(s1,i).fsloc 0 = Computation(s2,i).fsloc 0 by A3,A8,A10;
    end;
    suppose
A11:  i = 1;
      hence Computation(s1,i).intloc 0 = s1.intloc 0 by A4,A6,Lm3
        .= Computation(s2,i).intloc 0 by A5,A6,A7,A11,Lm3;
      thus (Computation(s1,i)).IC SCM+FSA = insloc 1 by A4,A6,A11,Lm3
        .= (Computation(s2,i)).IC SCM+FSA by A5,A6,A11,Lm3;
      thus Computation(s1,i).fsloc 0 = s1.fsloc 0 by A4,A6,A11,Lm3
        .= Computation(s2,i).fsloc 0 by A5,A6,A8,A11,Lm3;
    end;
    suppose
A12:  i = 2;
      hence Computation(s1,i).intloc 0 = s1.intloc 0 by A4,A6,Lm3
        .= Computation(s2,i).intloc 0 by A5,A6,A7,A12,Lm3;
      thus (Computation(s1,i)).IC SCM+FSA = insloc 2 by A4,A6,A12,Lm3
        .= (Computation(s2,i)).IC SCM+FSA by A5,A6,A12,Lm3;
      thus Computation(s1,i).fsloc 0 = s1.fsloc 0 by A4,A6,A12,Lm3
        .= Computation(s2,i).fsloc 0 by A5,A6,A8,A12,Lm3;
    end;
    suppose
A13:  i = 3;
      hence Computation(s1,i).intloc 0 = s1.intloc 0 by A4,A6,Lm3
        .= Computation(s2,i).intloc 0 by A5,A6,A7,A13,Lm3;
      thus (Computation(s1,i)).IC SCM+FSA = insloc 3 by A4,A6,A13,Lm3
        .= (Computation(s2,i)).IC SCM+FSA by A5,A6,A13,Lm3;
      thus Computation(s1,i).fsloc 0 = s1.fsloc 0 by A4,A6,A13,Lm3
        .= Computation(s2,i).fsloc 0 by A5,A6,A8,A13,Lm3;
    end;
    suppose
A14:  i = 4;
      hence Computation(s1,i).intloc 0 = s1.intloc 0 by A4,A6,Lm3
        .= Computation(s2,i).intloc 0 by A5,A6,A7,A14,Lm3;
      thus (Computation(s1,i)).IC SCM+FSA = insloc 4 by A4,A6,A14,Lm3
        .= (Computation(s2,i)).IC SCM+FSA by A5,A6,A14,Lm3;
      thus Computation(s1,i).fsloc 0 = s1.fsloc 0 by A4,A6,A14,Lm3
        .= Computation(s2,i).fsloc 0 by A5,A6,A8,A14,Lm3;
    end;
    suppose
A15:  i = 5;
      hence Computation(s1,i).intloc 0 = s1.intloc 0 by A4,A6,Lm3
        .= Computation(s2,i).intloc 0 by A5,A6,A7,A15,Lm3;
      thus (Computation(s1,i)).IC SCM+FSA = insloc 5 by A4,A6,A15,Lm3
        .= (Computation(s2,i)).IC SCM+FSA by A5,A6,A15,Lm3;
      thus Computation(s1,i).fsloc 0 = s1.fsloc 0 by A4,A6,A15,Lm3
        .= Computation(s2,i).fsloc 0 by A5,A6,A8,A15,Lm3;
    end;
    suppose
A16:  i = 6;
      hence Computation(s1,i).intloc 0 = s1.intloc 0 by A4,A6,Lm3
        .= Computation(s2,i).intloc 0 by A5,A6,A7,A16,Lm3;
      thus (Computation(s1,i)).IC SCM+FSA = insloc 6 by A4,A6,A16,Lm3
        .= (Computation(s2,i)).IC SCM+FSA by A5,A6,A16,Lm3;
      thus Computation(s1,i).fsloc 0 = s1.fsloc 0 by A4,A6,A16,Lm3
        .= Computation(s2,i).fsloc 0 by A5,A6,A8,A16,Lm3;
    end;
    suppose
A17:  i = 7;
      hence Computation(s1,i).intloc 0 = s1.intloc 0 by A4,A6,Lm3
        .= Computation(s2,i).intloc 0 by A5,A6,A7,A17,Lm3;
      thus (Computation(s1,i)).IC SCM+FSA = insloc 7 by A4,A6,A17,Lm3
        .= (Computation(s2,i)).IC SCM+FSA by A5,A6,A17,Lm3;
      thus Computation(s1,i).fsloc 0 = s1.fsloc 0 by A4,A6,A17,Lm3
        .= Computation(s2,i).fsloc 0 by A5,A6,A8,A17,Lm3;
    end;
    suppose
A18:  i = 8;
      hence Computation(s1,i).intloc 0 = s1.intloc 0 by A4,A6,Lm3
        .= Computation(s2,i).intloc 0 by A5,A6,A7,A18,Lm3;
      thus (Computation(s1,i)).IC SCM+FSA = insloc 8 by A4,A6,A18,Lm3
        .= (Computation(s2,i)).IC SCM+FSA by A5,A6,A18,Lm3;
      thus Computation(s1,i).fsloc 0 = s1.fsloc 0 by A4,A6,A18,Lm3
        .= Computation(s2,i).fsloc 0 by A5,A6,A8,A18,Lm3;
    end;
    suppose
A19:  i = 9;
      hence Computation(s1,i).intloc 0 = s1.intloc 0 by A4,A6,Lm3
        .= Computation(s2,i).intloc 0 by A5,A6,A7,A19,Lm3;
      thus (Computation(s1,i)).IC SCM+FSA = insloc 9 by A4,A6,A19,Lm3
        .= (Computation(s2,i)).IC SCM+FSA by A5,A6,A19,Lm3;
      thus Computation(s1,i).fsloc 0 = s1.fsloc 0 by A4,A6,A19,Lm3
        .= Computation(s2,i).fsloc 0 by A5,A6,A8,A19,Lm3;
    end;
    suppose
A20:  i = 10;
      hence Computation(s1,i).intloc 0 = s1.intloc 0 by A4,A6,Lm3
        .= Computation(s2,i).intloc 0 by A5,A6,A7,A20,Lm3;
      thus (Computation(s1,i)).IC SCM+FSA = insloc 10 by A4,A6,A20,Lm3
        .= (Computation(s2,i)).IC SCM+FSA by A5,A6,A20,Lm3;
      thus Computation(s1,i).fsloc 0 = s1.fsloc 0 by A4,A6,A20,Lm3
        .= Computation(s2,i).fsloc 0 by A5,A6,A8,A20,Lm3;
    end;
  end;
  set UD={fsloc 0,a0,a1,a2,a3,a4,a5,a6}, Us=UsedInt*Loc q \/ UsedIntLoc q;
A21: UsedInt*Loc q ={fsloc 0} by Th59;
A22: UsedIntLoc q ={a0,a1,a2,a3,a4,a5,a6} by Th58;
  then
A23: Us = UD by A21,ENUMSET1:62;
A24: for i being Element of NAT,s1,s2 being State of SCM+FSA
  st 11 <= i & p c= s1 & p c= s2
  holds Computation(s1,i) | Us = Computation(s2,i) | Us &
  Computation(s1,i).IC SCM+FSA = Computation(s2,i).IC SCM+FSA
  proof
    let i be Element of NAT,s1,s2 be State of SCM+FSA such that
A25: 11 <= i and
A26: p c= s1 and
A27: p c= s2;
    set Cs11= Computation( s1,11), Cs21= Computation( s2,11);
A28: s1 starts_at 0 by A26,Th47,AMI_1:92;
A29: s2 starts_at 0 by A27,Th47,AMI_1:92;
A30: q c= s1 by A26,Th53;
A31: q c= s2 by A27,Th53;
A32: s1.intloc 0 =1 by A26,Th54
      .= s2.intloc 0 by A27,Th54;
A33: s1.fsloc 0 =w by A26,Th54
      .=s2.fsloc 0 by A27,Th54;
A34: Us c= dom(Cs11) by Th56;
A35: Us c= dom(Cs21) by Th56;
    now
      let x be set;
      assume x in Us;
      then
A36:  x in UD by A21,A22,ENUMSET1:62;
      per cases by A36,ENUMSET1:def 6;
      suppose
A37:    x = fsloc 0;
        hence Cs11.x =s1.fsloc 0 by A28,A30,Lm3
          .=Cs21.x by A29,A31,A33,A37,Lm3;
      end;
      suppose
A38:    x = a0;
        hence Cs11.x =s1.a0 by A28,A30,Lm3
          .=Cs21.x by A29,A31,A32,A38,Lm3;
      end;
      suppose
A39:    x = a1;
        hence Cs11.x=len(s1.fsloc 0) by A28,A30,Lm3
          .=Cs21.x by A29,A31,A33,A39,Lm3;
      end;
      suppose
A40:    x = a2;
        hence Cs11.x=s1.a0 by A28,A30,Lm3
          .=Cs21.x by A29,A31,A32,A40,Lm3;
      end;
      suppose
A41:    x = a3;
        hence Cs11.x=s1.a0 by A28,A30,Lm3
          .=Cs21.x by A29,A31,A32,A41,Lm3;
      end;
      suppose
A42:    x = a4;
        hence Cs11.x=s1.a0 by A28,A30,Lm3
          .=Cs21.x by A29,A31,A32,A42,Lm3;
      end;
      suppose
A43:    x = a5;
        hence Cs11.x=s1.a0 by A28,A30,Lm3
          .=Cs21.x by A29,A31,A32,A43,Lm3;
      end;
      suppose
A44:    x = a6;
        hence Cs11.x=s1.a0 by A28,A30,Lm3
          .=Cs21.x by A29,A31,A32,A44,Lm3;
      end;
    end;
    then
A45: Cs11 | Us = Cs21 | Us by A34,A35,FUNCT_1:165;
A46: Cs11.IC SCM+FSA = insloc 11 by A28,A30,Lm3
      .=Cs21.IC SCM+FSA by A29,A31,Lm3;
A47: for i holds IC Computation(s1,i) in dom q by A26,Th66;
    for i holds IC Computation(s2,i) in dom q by A27,Th66;
    hence thesis by A25,A30,A31,A45,A46,A47,Th26;
  end;
  set DD={intloc 0,IC SCM+FSA,fsloc 0};
A48: dom p = dom q \/ DD by Th42;
  now
    let s1,s2 be State of SCM+FSA,i;
    assume
A49: p c= s1 & p c=s2;
    set Cs1i=Computation(s1,i), Cs2i=Computation(s2,i);
    q c= s1 & q c=s2 by A49,Th53;
    then
A50: Cs1i | dom q = Cs2i| dom q by AMI_1:124;
A51: DD c= dom Cs1i by Th55;
A52: DD c= dom Cs2i by Th55;
    Cs1i | DD = Cs2i| DD
    proof
A53:  intloc 0 in Us by A23,ENUMSET1:def 6;
A54:  fsloc 0 in Us by A23,ENUMSET1:def 6;
A55:  Us c= dom(Cs1i) by Th56;
A56:  Us c= dom(Cs2i) by Th56;
A57:  i>10 implies 10+1 < i+1 by XREAL_1:8;
      now
        let x be set;
        assume
A58:    x in DD;
        per cases by A58,ENUMSET1:def 1;
        suppose
A59:      x=intloc 0;
          now per cases;
            suppose i<=10;
              hence Cs1i.x=Cs2i.x by A1,A49,A59;
            end;
            suppose i>10;
              then 11 <= i by A57,NAT_1:13;
              then Cs1i | Us = Cs2i | Us by A24,A49;
              hence Cs1i.x=Cs2i.x by A53,A55,A56,A59,FUNCT_1:165;
            end;
          end;
          hence Cs1i.x=Cs2i.x;
        end;
        suppose
A60:      x=IC SCM+FSA;
          now per cases;
            suppose i<=10;
              hence Cs1i.x=Cs2i.x by A1,A49,A60;
            end;
            suppose i>10;
              then 11 <= i by A57,NAT_1:13;
              hence Cs1i.x=Cs2i.x by A24,A49,A60;
            end;
          end;
          hence Cs1i.x=Cs2i.x;
        end;
        suppose
A61:      x=fsloc 0;
          now per cases;
            suppose i<=10;
              hence Cs1i.x=Cs2i.x by A1,A49,A61;
            end;
            suppose i>10;
              then 11 <= i by A57,NAT_1:13;
              then Cs1i | Us = Cs2i | Us by A24,A49;
              hence Cs1i.x=Cs2i.x by A54,A55,A56,A61,FUNCT_1:165;
            end;
          end;
          hence Cs1i.x=Cs2i.x;
        end;
      end;
      hence thesis by A51,A52,FUNCT_1:165;
    end;
    hence Cs1i| dom p = Cs2i | dom p by A48,A50,RELAT_1:185;
  end;
  then for s1,s2 being State of SCM+FSA st p c= s1 & p c= s2
  for i holds Computation(s1,i)|dom p = Computation(s2,i)|dom p;
  hence thesis by AMI_1:def 25;
end;

theorem
  Initialized Bubble-Sort-Algorithm computes Sorting-Function
proof
  let x be set;
  assume x in dom Sorting-Function;
  then consider w being FinSequence of INT such that
A1: x = fsloc 0 .--> w by Th60;
  reconsider s = x as FinPartState of SCM+FSA by A1;
  set p = Initialized Bubble-Sort-Algorithm;
A2: dom s = { fsloc 0 } by A1,FUNCOP_1:19;
  take s;
  thus x = s;
A3: p +* s is autonomic by A1,Th68;
A4: dom p misses dom s by A1,Th46;
A5: now
    let t be State of SCM+FSA;
    assume
A6: p+*s c= t;
    set bf=bubble-sort fsloc 0;
    p c=p+*s by A4,FUNCT_4:33;
    then
A7: p c= t by A6,XBOOLE_1:1;
    Initialized bf is halting by Th64;
    hence t is halting by A7,AMI_1:def 26;
  end;
  then
A8: p +* s is halting by AMI_1:def 26; thus
  p +* s is pre-program of SCM+FSA by A1,A5,Th68,AMI_1:def 26;
  consider z being FinSequence of REAL such that
A9: w,z are_fiberwise_equipotent & z is non-increasing &
  z is FinSequence of INT & Sorting-Function.s = fsloc 0 .--> z by A1,Th61;
  consider t being State of SCM+FSA such that
A10: p +* s c= t by CARD_3:97;
  consider u being FinSequence of REAL such that
A11: w,u are_fiberwise_equipotent & u is non-increasing &
  u is FinSequence of INT & (Result t).(fsloc 0) = u by A1,A10,Th67;
A12: u=z by A9,A11,RFINSEQ:2,36;
  fsloc 0 in the carrier of SCM+FSA;
  then
A13: fsloc 0 in dom Result t by AMI_1:79;
  s c= p +* s by FUNCT_4:26;
  then
A14: dom s c= dom(p +* s) by RELAT_1:25;
A15: dom(fsloc 0 .--> z) = { fsloc 0 } by FUNCOP_1:19;
  Result(p +* s) = (Result t)|dom(p +* s) by A3,A8,A10,AMI_1:def 28;
  hence Sorting-Function.s c= Result(p +* s) by A2,A9,A11,A12,A13,A14,A15,
  FUNCT_4:90,RELAT_1:186;
end;

