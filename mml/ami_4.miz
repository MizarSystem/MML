:: Euclide Algorithm
::  by Andrzej Trybulec and Yatsuka Nakamura
::
:: Received October 8, 1993
:: Copyright (c) 1993-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_3, CARD_1, NAT_1, AMI_1, FUNCOP_1,
      RELAT_1, GRAPHSP, FUNCT_4, FSM_1, FUNCT_1, XBOOLE_0, TARSKI, ARYTM_3,
      INT_1, XXREAL_0, MSUALG_1, INT_2, COMPLEX1, PARTFUN1, TURING_1, STRUCT_0,
      GLIB_000, AMI_4, ORDINAL1, SCMNORM, PBOOLE, FINSET_1, COMPOS_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, NUMBERS, RELAT_1, FUNCT_1,
      FINSET_1, INT_1, NAT_1, FUNCOP_1, INT_2, FUNCT_4, PBOOLE, STRUCT_0,
      PARTFUN1, MEMSTR_0, COMPOS_1, EXTPRO_1, AMI_3, XXREAL_0;
 constructors XXREAL_0, NAT_D, AMI_3, RELSET_1, PRE_POLY, DOMAIN_1, AMI_2,
      PBOOLE, BINOP_1, MEMSTR_0;
 registrations SETFAM_1, ORDINAL1, RELSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, CARD_3, STRUCT_0, AMI_3, XBOOLE_0, FINSET_1, FUNCT_2, MEMSTR_0,
      FUNCT_4, PBOOLE, COMPOS_1, EXTPRO_1, FUNCOP_1, RELAT_1, FUNCT_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, EXTPRO_1, TARSKI, COMPOS_1, FUNCT_4, MEMSTR_0;
 theorems INT_1, ABSVALUE, INT_2, TARSKI, ENUMSET1, NAT_1, FUNCOP_1, PARTFUN1,
      FUNCT_4, FUNCT_1, GRFUNC_1, ZFMISC_1, AMI_3, RELAT_1, RELSET_1, XBOOLE_0,
      XBOOLE_1, NEWTON, XXREAL_0, ORDINAL1, NAT_D, CARD_1, PBOOLE, COMPOS_1,
      EXTPRO_1, MEMSTR_0;
 schemes NAT_1, NAT_D, FUNCT_1, RELSET_1, NEWTON;

begin :: Preliminaries

reserve i,j,k for Element of NAT;

set a = dl.0, b = dl.1, c = dl.2;

Lm1: a <> b & b <> c by AMI_3:10;
Lm2: c <> a by AMI_3:10;

begin :: Euclide algorithm

definition
  func Euclide-Algorithm -> NAT-defined
   (the Instructions of SCM)-valued finite Function
    equals
  (0 .--> (dl.2 := dl.1)) +* ((1 .--> Divide(dl.0,dl.1)) +*
  ((2 .--> (dl.0 := dl.2)) +* ((3 .--> (dl.1 >0_goto 0)) +*
  (4 .--> halt SCM))));
  coherence;
end;

defpred P[Instruction-Sequence of SCM] means
 $1.0 = c := b & $1.1 = Divide(a,b) &
 $1.2 = a := c & $1.3 = b >0_goto 0 &
 $1 halts_at 4;
set IN0 = 0 .--> (dl.2 := b);
set IN1 = 1 .--> Divide(a,b);
set IN2 = 2 .--> (a := dl.2);
set IN3 = 3 .--> (b >0_goto 0);
set IN4 = 4 .--> halt SCM;
set EA3 = IN3 +* IN4;
set EA2 = IN2 +* EA3;
set EA1 = IN1 +* EA2;
set EA0 = IN0 +* EA1;



theorem Th4:
  dom (Euclide-Algorithm qua Function) = 5
proof
  dom IN3 = { 3 } & dom IN4 = { 4 } by FUNCOP_1:13;
  then
A1: dom EA3 = { 3 } \/ { 4 } by FUNCT_4:def 1
    .= { 3,4 } by ENUMSET1:1;
A2: dom IN1 = { 1 } by FUNCOP_1:13;
  dom IN2 = { 2 } by FUNCOP_1:13;
  then dom EA2 = { 2 } \/ { 3,4 } by A1,FUNCT_4:def 1
    .= { 2,3,4 } by ENUMSET1:2;
  then
A3: dom EA1 = { 1 } \/ { 2,3,4 } by A2,FUNCT_4:def 1
    .= { 1,2,3,4 } by ENUMSET1:4;
  dom IN0 = { 0 } by FUNCOP_1:13;
  then dom EA0 = { 0 } \/ { 1,2,3,4 } by A3,FUNCT_4:def 1
    .= 5 by CARD_1:53,ENUMSET1:7;
  hence thesis;
end;

Lm3:
 for P being Instruction-Sequence of SCM
 st Euclide-Algorithm c= P
  holds P[P]
proof
  let P be Instruction-Sequence of SCM;
  assume
A1: Euclide-Algorithm c= P;
  EA1 c= EA0 by FUNCT_4:25;
  then
A2: EA1 c= P by A1,XBOOLE_1:1;
  EA2 c= EA1 by FUNCT_4:25;
  then
A3: EA2 c= P by A2,XBOOLE_1:1;
  EA3 c= EA2 by FUNCT_4:25;
  then
A4: EA3 c= P by A3,XBOOLE_1:1;
A5: dom IN4 = { 4 } by FUNCOP_1:13;
  then
A6: not 3 in dom IN4 by TARSKI:def 1;
  dom IN3 = { 3 } by FUNCOP_1:13;
  then
A7: dom EA3 = { 3 } \/ { 4 } by A5,FUNCT_4:def 1
    .= { 3,4 } by ENUMSET1:1;
  then
A8: not 2 in dom EA3 by TARSKI:def 2;
  dom IN2 = { 2 } by FUNCOP_1:13;
  then
A9: dom EA2 = { 2 } \/ { 3,4 } by A7,FUNCT_4:def 1
    .= { 2,3,4 } by ENUMSET1:2;
  then
A10: not 1 in dom EA2 by ENUMSET1:def 1;
  dom IN1 = { 1 } by FUNCOP_1:13;
  then
A11: dom EA1 = { 1 } \/ { 2,3,4 } by A9,FUNCT_4:def 1
    .= { 1,2,3,4 } by ENUMSET1:4;
  then
A12: not 0 in dom EA1;
  0 in dom EA0 by Th4,CARD_1:53,ENUMSET1:def 3;
  hence P.0 = EA0.0 by A1,GRFUNC_1:2
    .= IN0.0 by A12,FUNCT_4:11
    .= c := b by FUNCOP_1:72;
  1 in dom EA1 by A11,ENUMSET1:def 2;
  hence P.1 = EA1.1 by A2,GRFUNC_1:2
    .= IN1.1 by A10,FUNCT_4:11
    .= Divide(a,b) by FUNCOP_1:72;
  2 in dom EA2 by A9,ENUMSET1:def 1;
  hence P.2 = EA2.2 by A3,GRFUNC_1:2
    .= IN2.2 by A8,FUNCT_4:11
    .= a := c by FUNCOP_1:72;
A13: 4 in dom IN4 by A5,TARSKI:def 1;
  3 in dom EA3 by A7,TARSKI:def 2;
  hence P.3 = EA3.3 by A4,GRFUNC_1:2
    .= IN3.3 by A6,FUNCT_4:11
    .= b >0_goto 0 by FUNCOP_1:72;
A14: 4 in dom EA3 by A7,TARSKI:def 2;
  thus P.4 = EA3.4 by A4,A14,GRFUNC_1:2
    .= IN4.4 by A13,FUNCT_4:13
    .= halt SCM by FUNCOP_1:72;
end;

begin :: Natural semantics of the program

theorem Th5:
  for s being State of SCM
  for P being Instruction-Sequence of SCM
   st Euclide-Algorithm c= P
  for k st IC Comput(P,s,k) = 0 holds IC Comput(P,s,k+1) = 1 &
  Comput(P,s,k+1).dl.0 = Comput(P,s,k).dl.0 &
  Comput(P,s,k+1).dl.1 = Comput(P,s,k).dl.1 &
  Comput(P,s,k+1).dl.2 = Comput(P,s,k).dl.1
proof
  let s be State of SCM;
  let P be Instruction-Sequence of SCM such that
A1: Euclide-Algorithm c= P;
  let k;
  assume
A2: IC Comput(P,s,k) = 0;
A3: Comput(P,s,k+1)
 = Exec(P.(IC Comput(P,s,k)),Comput(P,s,k)) by EXTPRO_1:6
    .= Exec(c := b, Comput(P,s,k)) by A1,A2,Lm3;
  hence IC Comput(P,s,k+1) = succ IC Comput(P,s,k) by AMI_3:2
    .= 1 by A2;
  thus Comput(P,s,k+1).a = Comput(P,s,k).a & Comput(P,s,k+1).b =
  Comput(P,s,k).b by A3,AMI_3:2,10;
  thus thesis by A3,AMI_3:2;
end;

theorem Th6:
  for s being State of SCM
  for P being Instruction-Sequence of SCM
   st Euclide-Algorithm c= P
  for k st IC
Comput(P,s,k) = 1 holds IC Comput(P,s,k+1) = 2 &
Comput(P,s,k+1).dl.0
  = Comput(P,s,k).dl.0 div Comput(P,s,k).dl.1 &
Comput(P,s,k+1).dl.1 =
  Comput(P,s,k).dl.0 mod Comput(P,s,k).dl.1 & Comput(P,s,k+1).dl.2 =
  Comput(P,s,k).dl.2
proof
  let s be State of SCM;
  let P be Instruction-Sequence of SCM such that
A1: Euclide-Algorithm c= P;
  let k such that
A2: IC Comput(P,s,k) = 1;
A3: Comput(P,s,k+1)
 = Exec(P.(IC Comput(P,s,k)),
Comput(P,s,k)) by EXTPRO_1:6
    .= Exec(Divide(a,b), Comput(P,s,k)) by A1,A2,Lm3;
  hence IC Comput(P,s,k+1) = succ IC Comput(P,s,k)
by AMI_3:6
    .= 2 by A2;
  thus thesis by A3,Lm1,Lm2,AMI_3:6;
end;

theorem Th7:
  for s being State of SCM
  for P being Instruction-Sequence of SCM
   st Euclide-Algorithm c= P
  for k st IC
Comput(P,s,k) = 2 holds IC Comput(P,s,k+1) = 3 &
Comput(P,s,k+1).dl.0
  = Comput(P,s,k).dl.2 & Comput(P,s,k+1).dl.1 =
Comput(P,s,k).dl.1 &
  Comput(P,s,k+1).dl.2 = Comput(P,s,k).dl.2
proof
  let s be State of SCM;
  let P be Instruction-Sequence of SCM such that
A1: Euclide-Algorithm c= P;
  let k;
  assume
A2: IC Comput(P,s,k) = 2;
A3: Comput(P,s,k+1)
 = Exec(P.(IC Comput(P,s,k)),Comput(P,s,k)) by EXTPRO_1:6
    .= Exec(a := c, Comput(P,s,k)) by A1,A2,Lm3;
  hence IC Comput(P,s,k+1) = succ IC Comput(P,s,k)
by AMI_3:2
    .= 3 by A2;
  thus Comput(P,s,k+1).a = Comput(P,s,k).c by A3,AMI_3:2;
  thus thesis by A3,AMI_3:2,10;
end;

theorem Th8:
 for s being State of SCM
  for P being Instruction-Sequence of SCM
   st Euclide-Algorithm c= P
   for k st IC
Comput(P,s,k) = 3 holds ( Comput(P,s,k).dl.1 > 0
implies IC Comput(P,s,k+1) = 0) &
( Comput(P,s,k).dl.1 <= 0 implies IC Comput(P,s,k+1) = 4) &
  Comput(P,s,k+1).dl.0 = Comput(P,s,k).dl.0 & Comput(P,s,k+1).dl.1 =
  Comput(P,s,k).dl.1
proof
  let s be State of SCM;
  let P be Instruction-Sequence of SCM such that
A1: Euclide-Algorithm c= P;
  let k;
  assume
A2: IC Comput(P,s,k) = 3;
A3: Comput(P,s,k+1)
 = Exec(P.(IC Comput(P,s,k)),Comput(P,s,k)) by EXTPRO_1:6
    .= Exec(b >0_goto 0, Comput(P,s,k)) by A1,A2,Lm3;
  hence Comput(P,s,k).b > 0 implies IC Comput(P,s,k+1) = 0 by AMI_3:9;
  thus Comput(P,s,k).b <= 0 implies IC Comput(P,s,k+1) = 4
  proof
    assume Comput(P,s,k).b <= 0;
    hence IC Comput(P,s,k+1) = succ IC Comput(P,s,k) by A3,AMI_3:9
      .= 4 by A2;
  end;
  thus thesis by A3,AMI_3:9;
end;

theorem Th9:
  for s being State of SCM
  for P being Instruction-Sequence of SCM
  st Euclide-Algorithm c= P
  for k,i st IC
  Comput(P,s,k) = 4 holds Comput(P,s,k+i) = Comput(P,s,k)
proof
  let s be State of SCM;
  let P be Instruction-Sequence of SCM such that
A1: Euclide-Algorithm c= P;
  let k,i;
  assume IC Comput(P,s,k) = 4;
  then P halts_at IC Comput(P,s,k) by A1,Lm3;
  hence thesis by EXTPRO_1:20,NAT_1:11;
end;

Lm4: for s being 0-started State of SCM
  for P being Instruction-Sequence of SCM
 st Euclide-Algorithm c= P & s.a
> 0 & s.b > 0 holds Comput(P,s,4*k).a > 0 & ( Comput(P,s,4*k).b > 0 & IC
Comput(P,s,4*k) = 0 or Comput(P,s,4*k).b = 0 & IC
Comput(P,s,4*k) = 4)
proof
  let s be 0-started State of SCM;
  let P be Instruction-Sequence of SCM such that
A1: Euclide-Algorithm c= P and
A2: s.a > 0 & s.b > 0;
A3: IC s = 0 by MEMSTR_0:def 9;

  defpred P[Element of NAT] means Comput(P,s,4*$1).a > 0 & (
Comput(P,s,
  4*$1).b > 0 & IC Comput(P,s,4*$1) = 0 or Comput(P,s,4*$1).b = 0 & IC
  Comput(P,s,4*$1) = 4);

A4: for k st P[k] holds P[k+1]
  proof
    let k;

    set c4 = Comput(P,s,4*k), c5 = Comput(P,s,4*k+1),
c6 = Comput(P,s,4*k+2), c7 = Comput(P,s,4*k+3), c8 = Comput(P,s,4*k+4);

A5: c7 = Comput(P,s,4*k+2+1);
A6: c8 = Comput(P,s,4*k+3+1);
    assume
A7: c4.a > 0;
    assume
A8: c4.b > 0 & IC c4 = 0 or c4.b = 0 & IC c4 = 4;
A9: c6 = Comput(P,s,4*k+1+1);
    now
      per cases by A8;
      case
A10:    c4.b > 0;
        then
A11:    IC c5 = 1 by A1,A8,Th5;
        then
A12:    IC c6 = 2 by A1,A9,Th6;
        then
A13:    IC c7 = 3 by A1,A5,Th7;
        then
A14:    c8.b = c7.b by A1,A6,Th8;
A15:    c7.a = c6.c & c7.b = c6.b by A1,A5,A12,Th7;
A16:    c6.b = c5.a mod c5.b & c6.c = c5.c by A1,A9,A11,Th6;
A17:    c5.b = c4.b & c5.c = c4.b by A1,A8,A10,Th5;
        c7.b > 0 implies IC c8 = 0 by A1,A6,A13,Th8;

        hence c8.a > 0 & (c8.b > 0 & IC c8 = 0 or c8.b = 0 & IC c8 = 4) by A1
,A6,A10,A17,A16,A13,A15,A14,Th8,NEWTON:64;

      end;
      case
        c4.b = 0;
        hence c8.a > 0 & c8.b = 0 & IC c8 = 4 by A1,A7,A8,Th9;
      end;
    end;
    hence thesis;
  end;
A18: P[ 0] by A3,A2,EXTPRO_1:2;
  for k holds P[k] from NAT_1:sch 1(A18,A4);
  hence thesis;
end;

Lm5: for s being 0-started State of SCM
  for P being Instruction-Sequence of SCM
 st Euclide-Algorithm c= P & s.a
> 0 & s.b > 0 holds Comput(P,s,4*k).b > 0 implies Comput(
P,s,4*(k+1)).a =
Comput(P,s,4*k).b & Comput(P,s,4*(k+1)).b = Comput(
P,s,4*k).a mod
Comput(P,s,4*k).b

proof
  let s be 0-started State of SCM;
  let P be Instruction-Sequence of SCM such that
A1: Euclide-Algorithm c= P and
A2: s.a > 0 & s.b > 0 and
A3: Comput(P,s,4*k).b > 0;

  set c4 = Comput(P,s,4*k), c5 = Comput(P,s,4*k+1),
c6 = Comput(P,s,4*k+2), c7 = Comput(P,s,4*k+3);

A4: c4.b > 0 & IC c4 = 0 or c4.b = 0 & IC c4 = 4 by A1,A2,Lm4;
  then
A5: c6 = Comput(P,s,4*k+1+1) & IC c5 = 1 by A1,A3,Th5;
  then
A6: c6.c = c5.c by A1,Th6;
A7: c7 = Comput(P,s,4*k+2+1) & IC c6 = 2 by A1,A5,Th6;

  then
A8: Comput(P,s,4*k+4) = Comput(P,s,4*k+3+1) & IC c7 =
3 by A1,Th7;

A9: c7.a = c6.c by A1,A7,Th7;
  c5.c = c4.b by A1,A3,A4,Th5;

  hence Comput(P,s,4*(k+1)).a = Comput(P,s,4*k).b by A1,A6,A8,A9,Th8;

A10: c7.b = c6.b by A1,A7,Th7;
A11: c6.b = c5.a mod c5.b by A1,A5,Th6;
  c5.a = c4.a & c5.b = c4.b by A1,A3,A4,Th5;
  hence thesis by A1,A11,A8,A10,Th8;
end;

Lm6: for s being 0-started State of SCM
  for P being Instruction-Sequence of SCM
 st Euclide-Algorithm c= P
for x,
y being Integer st s.a = x & s.b = y & x > y & y > 0 holds
 (Result(P,s)).a = x gcd y & ex k st P halts_at IC Comput(P,s,k)
proof
  let s be 0-started State of SCM;
  let P be Instruction-Sequence of SCM such that
A1: Euclide-Algorithm c= P;
  deffunc G(Element of NAT) = abs( Comput(P,s,4*$1).b);
  deffunc F(Element of NAT) = abs( Comput(P,s,4*$1).a);
  let x, y be Integer such that
A2: s.a = x and
A3: s.b = y and
A4: x > y and
A5: y > 0;
A6: now
    let k;
A7: Comput(P,s,4*k).b > 0 or Comput(P,s,4*k).b = 0
      by A1,A2,A3,A4,A5,Lm4;
    assume
A8: G(k) > 0;
    hence F(k+1) = G(k) by A1,A2,A3,A4,A5,A7,Lm5,ABSVALUE:2;
A9: Comput(P,s,4*k).a >= 0 by A1,A2,A3,A4,A5,Lm4;
    Comput(P,s,4*(k+1)).b >= 0 by A1,A2,A3,A4,A5,Lm4;
    hence G(k+1) = Comput(P,s,4*(k+1)).b by ABSVALUE:def 1

      .= Comput(P,s,4*k).a mod Comput(P,s,4*k).b by A1,A2,A3,A4,A5,A7,A8,Lm5,
ABSVALUE:2

      .= F(k) mod G(k) by A7,A9,INT_2:32;
  end;
  reconsider x9 = x, y9 = y as Element of NAT by A4,A5,INT_1:3;
A10: y9 < x9 by A4;
A11: F(0) = abs(x) by A2,EXTPRO_1:2
    .= x9 by ABSVALUE:def 1;
A12: G(0) = abs(y) by A3,EXTPRO_1:2
    .= y9 by ABSVALUE:def 1;
A13: 0 < y9 by A5;
  consider k such that
A14: F(k) = x9 gcd y9 and
A15: G(k) = 0 from NEWTON:sch 1(A13,A10,A11,A12,A6);
A16: ( Comput(P,s,4*k)).a > 0 by A1,A2,A3,A4,A5,Lm4;
  Comput(P,s,4*k).b = 0 by A15,ABSVALUE:2;
  then
A17: IC Comput(P,s,4*k) = 4 by A1,A2,A3,A4,A5,Lm4;
A18: P halts_at 4 by A1,Lm3;
  hence (Result(P,s)).a = ( Comput(P,s,4*k)).a by A17,EXTPRO_1:18
    .= x gcd y by A14,A16,ABSVALUE:def 1;
  thus thesis by A17,A18;
end;

theorem Th10:
  for s being 0-started State of SCM
  for P being Instruction-Sequence of SCM
   st Euclide-Algorithm c= P
   for x, y being Integer st s.dl.0 = x & s.dl.1 = y & x > 0 & y > 0 holds (
  Result(P,s)).dl.0 = x gcd y
proof
  let s be 0-started State of SCM;
  let P be Instruction-Sequence of SCM such that
A1: Euclide-Algorithm c= P;
  let x, y be Integer such that
A2: s.a = x & s.b = y and
A3: x > 0 and
A4: y > 0;
A5: abs y = y by A4,ABSVALUE:def 1;
  now
    per cases by XXREAL_0:1;
    case
      x > y;
      hence thesis by A1,A2,A4,Lm6;
    end;
    case
A6:   x = y;
      reconsider x9 = x, y9 = y as Element of NAT by A3,A4,INT_1:3;
      take s9 = Comput(P,s,4);
A7:   s = Comput(P,s,4*0) by EXTPRO_1:2;
A8:   s9 = Comput(P,s,4*(0+1));
      x mod y = x9 mod y9
        .= 0 by A6,NAT_D:25;
      then s9.b = 0 by A1,A2,A3,A4,A7,A8,Lm5;
      then IC s9 = 4 by A1,A2,A3,A4,A8,Lm4;
      then P halts_at IC s9 by A1,Lm3;
      hence (Result(P,s)).a = s9.a by EXTPRO_1:18
        .= y by A1,A2,A3,A4,A7,A8,Lm5
        .= x gcd y by A5,A6,NAT_D:32;
    end;
    case
A9:  y > x;
      reconsider x9 = x, y9 = y as Element of NAT by A3,A4,INT_1:3;
      take s9 = Comput(P,s,4);
A10:  s9 = Comput(P,s,4*(0+1));
A11:  s = Comput(P,s,4*0) by EXTPRO_1:2;
      then
A12:  s9.a = y by A1,A2,A3,A4,A10,Lm5;
      x mod y = x9 mod y9
        .= x9 by A9,NAT_D:24;
      then
A13:  s9.b = x by A1,A2,A3,A4,A11,A10,Lm5;
      then IC s9 = 0 by A1,A2,A3,A4,A10,Lm4;
      then
A14:  s9 is 0-started by MEMSTR_0:def 9;
      then consider k0 being Element of NAT such that
A15:  P halts_at IC Comput(P,s9,k0)
        by A3,A9,A12,A13,A1,Lm6;
A16:  P halts_at IC Comput(P,s,k0+4) by A15,EXTPRO_1:4;
      (Result(P,s9)).a = x gcd y by A3,A9,A12,A13,A14,A1,Lm6;
      hence thesis by A16,EXTPRO_1:21;
    end;
  end;
  hence thesis;
end;

definition
  func Euclide-Function -> PartFunc of FinPartSt SCM, FinPartSt SCM means
:Def2:  for p,q being FinPartState of SCM holds [p,q] in it iff ex x,y being
Integer st x > 0 & y > 0 & p = (dl.0,dl.1) --> (x,y) & q = dl.0 .--> (x gcd y);
  existence
  proof
    defpred P[set,set] means ex x,y being Integer st x > 0 & y > 0 & $1 = (a,b
    ) --> (x,y) & $2 = a .--> (x gcd y);
A1: for p,q1,q2 being set st P[p,q1] & P[p,q2] holds q1=q2
    proof
      let p,q1,q2 be set;
      given x1,y1 being Integer such that
      x1 > 0 and
      y1 > 0 and
A2:   p = (a,b) --> (x1,y1) and
A3:   q1 = a .--> (x1 gcd y1);
      given x2,y2 being Integer such that
      x2 > 0 and
      y2 > 0 and
A4:   p = (a,b) --> (x2,y2) and
A5:   q2 = a .--> (x2 gcd y2);
A6:   y1 = ((a,b) --> (x1,y1)).b by FUNCT_4:63
        .= y2 by A2,A4,FUNCT_4:63;
      x1 = ((a,b) --> (x1,y1)).a by AMI_3:10,FUNCT_4:63
        .= x2 by A2,A4,AMI_3:10,FUNCT_4:63;
      hence thesis by A3,A5,A6;
    end;
    consider f being Function such that
A7: for p,q being set holds [p,q] in f iff p in FinPartSt SCM & P[p,q]
    from FUNCT_1:sch 1(A1);
A8: rng f c= FinPartSt SCM
    proof
      let q be set;
      assume q in rng f;
      then consider p being set such that
A9:   [p,q] in f by RELAT_1:def 5;
      ex x,y being Integer st x > 0 & y > 0 &p = (a,b) --> (x,y) & q = a
      .--> (x gcd y) by A7,A9;
      hence thesis by MEMSTR_0:75;
    end;
    dom f c= FinPartSt SCM
    proof
      let e be set;
      assume e in dom f;
      then [e,f.e] in f by FUNCT_1:1;
      hence thesis by A7;
    end;
    then reconsider f as PartFunc of FinPartSt SCM, FinPartSt SCM by A8,
RELSET_1:4;
    take f;
    let p,q be FinPartState of SCM;
    thus [p,q] in f implies ex x,y being Integer st x > 0 & y > 0 & p = (a,b)
    --> (x,y) & q = a .--> (x gcd y) by A7;
    given x,y being Integer such that
A10: x > 0 & y > 0 & p = (a,b) --> (x,y) & q = a .--> (x gcd y);
    p in FinPartSt SCM by MEMSTR_0:75;
    hence thesis by A7,A10;
  end;
  uniqueness
  proof
    defpred P[set,set] means ex x,y being Integer st x > 0 & y > 0 & $1 = (a,b
    ) --> (x,y) & $2 = a .--> (x gcd y);
    let IT1,IT2 be PartFunc of FinPartSt SCM, FinPartSt SCM such that
A11: for p,q being FinPartState of SCM holds [p,q] in IT1 iff P[p,q] and
A12: for p,q being FinPartState of SCM holds [p,q] in IT2 iff P[p,q];
A13: for p,q being Element of FinPartSt SCM holds [p,q] in IT2 iff P[p,q]
    proof
      let p,q being Element of FinPartSt SCM;
      thus [p,q] in IT2 implies P[p,q]
      proof
        assume
A14:    [p,q] in IT2;
        reconsider p,q as FinPartState of SCM by MEMSTR_0:76;
        P[p,q] by A12,A14;
        hence thesis;
      end;
      thus thesis by A12;
    end;
A15: for p,q being Element of FinPartSt SCM holds [p,q] in IT1 iff P[p,q]
    proof
      let p,q being Element of FinPartSt SCM;
      thus [p,q] in IT1 implies P[p,q]
      proof
        assume
A16:    [p,q] in IT1;
        reconsider p,q as FinPartState of SCM by MEMSTR_0:76;
        P[p,q] by A11,A16;
        hence thesis;
      end;
      thus thesis by A11;
    end;
    thus IT1 = IT2 from RELSET_1:sch 4(A15,A13);
  end;
end;

theorem Th11:
  for p being set holds p in dom Euclide-Function iff ex x,y being
  Integer st x > 0 & y > 0 & p = (dl.0,dl.1) --> (x,y)
proof
  let p be set;
A1: dom Euclide-Function c= FinPartSt SCM by RELAT_1:def 18;
A2: p in dom Euclide-Function iff [p,Euclide-Function.p] in Euclide-Function
  by FUNCT_1:1;
  hereby
    assume
A3: p in dom Euclide-Function;
    then Euclide-Function.p in FinPartSt SCM by PARTFUN1:4;
    then
A4: Euclide-Function.p is FinPartState of SCM by MEMSTR_0:76;
    p is FinPartState of SCM by A1,A3,MEMSTR_0:76;
    then ex x,y being Integer st x > 0 & y > 0 & p = (a,b) --> (x,y) &
    Euclide-Function.p = a .--> (x gcd y) by A2,A3,A4,Def2;
    hence ex x,y being Integer st x > 0 & y > 0 & p = (a,b) --> (x,y);
  end;
  given x,y being Integer such that
A5: x > 0 & y > 0 & p = (a,b) --> (x,y);
  [p,a .--> (x gcd y)] in Euclide-Function by A5,Def2;
  hence thesis by FUNCT_1:1;
end;

theorem Th12:
  for i,j being Integer st i > 0 & j > 0 holds Euclide-Function.((
  dl.0,dl.1) --> (i,j)) = dl.0 .--> (i gcd j)
proof
  let i,j be Integer;
  assume i > 0 & j > 0;
  then [((a,b) --> (i,j)),a .--> (i gcd j)] in Euclide-Function by Def2;
  hence thesis by FUNCT_1:1;
end;

registration
 cluster Euclide-Algorithm -> (the Instructions of SCM)-valued;
 coherence;
end;

registration
 cluster Euclide-Algorithm -> non halt-free;
 coherence
  proof
   rng(4 .--> halt SCM) = {halt SCM} by FUNCOP_1:8;
   then
A1: halt SCM in rng(4 .--> halt SCM) by TARSKI:def 1;
  rng(4 .--> halt SCM) c= rng(((3 .--> (dl.1 >0_goto 0)) +*
  (4 .--> halt SCM))) by FUNCT_4:18;
  then
A2: halt SCM in rng(((3 .--> (dl.1 >0_goto 0)) +* (4 .--> halt SCM))) by A1;
  rng((3 .--> (dl.1 >0_goto 0)) +* (4 .--> halt SCM)) c=
   rng(((2 .--> (dl.0 := dl.2)) +* ((3 .--> (dl.1 >0_goto 0)) +*
  (4 .--> halt SCM)))) by FUNCT_4:18;
  then
A3: halt SCM in rng((2 .--> (dl.0 := dl.2)) +* ((3 .--> (dl.1 >0_goto 0)) +*
  (4 .--> halt SCM))) by A2;
  rng((2 .--> (dl.0 := dl.2)) +* ((3 .--> (dl.1 >0_goto 0)) +*
  (4 .--> halt SCM))) c=
  rng((1 .--> Divide(dl.0,dl.1)) +*
  ((2 .--> (dl.0 := dl.2)) +* ((3 .--> (dl.1 >0_goto 0)) +*
  (4 .--> halt SCM)))) by FUNCT_4:18;
  then
A4:  halt SCM in rng((1 .--> Divide(dl.0,dl.1)) +*
  ((2 .--> (dl.0 := dl.2)) +* ((3 .--> (dl.1 >0_goto 0)) +*
  (4 .--> halt SCM)))) by A3;
    rng((1 .--> Divide(dl.0,dl.1)) +*
  ((2 .--> (dl.0 := dl.2)) +* ((3 .--> (dl.1 >0_goto 0)) +*
  (4 .--> halt SCM)))) c= rng Euclide-Algorithm by FUNCT_4:18;
   then halt SCM in rng Euclide-Algorithm by A4;
   hence thesis by COMPOS_1:def 3;
  end;
end;

theorem
  Euclide-Algorithm, Start-At(0,SCM) computes Euclide-Function
proof
  set q = Euclide-Algorithm;
  set p = Start-At(0,SCM);
  let x be set;
  DataPart p = {} by MEMSTR_0:20;
  then
A6: dom DataPart p = {};
  assume x in dom Euclide-Function;
  then consider i1,i2 being Integer such that
A7: i1 > 0 and
A8: i2 > 0 and
A9: x = (a,b) --> (i1,i2) by Th11;
  x =  (a .--> i1) +* (b .--> i2) by A9;
  then reconsider d = x as FinPartState of SCM;
  consider t being State of SCM such that
A10: p +* d c= t by PBOOLE:141;
  consider T being Instruction-Sequence of SCM
    such that
C10: q c= T by PBOOLE:145;
A11: dom d = { a, b } by A9,FUNCT_4:62;
  then
A12: b in dom d by TARSKI:def 2;
A21: a in dom d by A11,TARSKI:def 2;
A22: for t being State of SCM st p +* d c= t
  holds t.a = i1 & t.b = i2
  proof
    let t be State of SCM;
    assume
Z:    p +* d c= t;
    d c= p +* d by FUNCT_4:25;
    then
A24: d c= t by Z,XBOOLE_1:1;
    hence t.a = d.a by A21,GRFUNC_1:2
      .= i1 by A9,AMI_3:10,FUNCT_4:63;
    thus t.b = d.b by A12,A24,GRFUNC_1:2
      .= i2 by A9,FUNCT_4:63;
  end;
A25: dom p = { IC SCM } by FUNCOP_1:13;
A26: now
    assume dom p meets dom d;
    then consider x being set such that
A27: x in dom p and
A28: x in dom d by XBOOLE_0:3;
A29: x = IC SCM or x = 0 or x = 1 or x = 2 or x = 3 or x = 4
      by A25,A27,TARSKI:def 1;
    x = a or x = b by A11,A28,TARSKI:def 2;
    hence contradiction by A29,AMI_3:12,13;
  end;
  then
A30: p c= p +* d by FUNCT_4:32;
A31: IC SCM in dom p by A25,TARSKI:def 1;
  dom p /\ dom d = {} by A26,XBOOLE_0:def 7;
  then
A32: not IC SCM in dom d by A31,XBOOLE_0:def 4;
    set A = { IC SCM, a,b }, C = 5;
A33: dom (p +* d) = dom( p +* d)
       .= dom  p \/ dom d by FUNCT_4:def 1
       .= {IC SCM} \/ dom DataPart p \/ dom d by A31,MEMSTR_0:24
       .= { IC SCM } \/ { a, b } by A9,A6,FUNCT_4:62
      .= A by ENUMSET1:2;
A34: dom p c= dom(p +* d) by A30,RELAT_1:11;
  IC(p +* d) = IC p by A32,FUNCT_4:11
    .= 0 by FUNCOP_1:72;
  then
A35: p +* d is 0-started by A34,A31,MEMSTR_0:def 8;
  then
A36: t is 0-started by A10,MEMSTR_0:17;
A38: p +* d is q-autonomic
  proof
    set A = { IC SCM, a,b }, C = 5;
    let P,Q being Instruction-Sequence of SCM
    such that
A39: q c= P and
A40: q c= Q;
    let s1,s2 be State of SCM such that
A41: (p +* d) c= s1 and
A42: (p +* d) c= s2;
A43: s2.a = i1 & s2.b = i2 by A22,A42;
    let k;
    defpred P[Element of NAT] means
     IC Comput(P,s1,$1) = IC Comput(Q,s2,$1) &
     Comput(P,s1,$1).a = Comput(Q,s2,$1).a &
     Comput(P,s1,$1).b = Comput(Q,s2,$1).b;
A45: Comput(P,s1,0) = s1 & Comput(Q,s2,0) = s2 by EXTPRO_1:2;
A46: s1 is 0-started by A35,A41,MEMSTR_0:17;
A47: dom( Comput(P,s1,k)) = the carrier of SCM by PARTFUN1:def 2
      .= dom( Comput(Q,s2,k)) by PARTFUN1:def 2;
A49: s2 is 0-started by A35,A42,MEMSTR_0:17;
A50: for i,j being Nat st P[4*i] & j<>0 & j<=4 holds P[4*i+j]
    proof
      let i,j be Nat;
      assume that
A51:  IC Comput(P,s1,4*i) = IC Comput(Q,s2,4*i) and
A52:  Comput(P,s1,4*i).a = Comput(Q,s2,4*i).a and
A53:  Comput(P,s1,4*i).b = Comput(Q,s2,4*i).b;
A54:  i in NAT by ORDINAL1:def 12;
      assume j <> 0 & j <= 4;
      then
A55:  j = 1 or j = 2 or j = 3 or j = 4 by NAT_1:28;
      per cases by A7,A8,A49,A40,A43,A54,Lm4;
      suppose
A56:    IC Comput(Q,s2,4*i) = 0;
A58:    ( Comput(P,s1,4*i+1)).a = Comput(P,s1,4*i).a by A39,A51,A56,Th5
          .= ( Comput(Q,s2,4*i+1)).a by A40,A52,A56,Th5;
A59:    ( Comput(P,s1,4*i+1)).dl.2 = Comput(P,s1,4*i).b by A39,A51,A56,Th5
          .= ( Comput(Q,s2,4*i+1)).dl.2 by A40,A53,A56,Th5;
A60:    ( Comput(P,s1,4*i+1)).b = Comput(P,s1,4*i).b by A39,A51,A56,Th5
          .= ( Comput(Q,s2,4*i+1)).b by A40,A53,A56,Th5;
A61:    4*i + 1 + 1 = 4*i + (1 + 1);
A62:    (4*i+2)+1 = 4*i+(2+1);
A63:    IC Comput(Q,s2,4*i+1) = 1 by A40,A56,Th5;
        then
A64:    IC Comput(Q,s2,4*i+2) = 2 by A40,A61,Th6;
        then
A65:    IC Comput(Q,s2,4*i+3) = 3 by A40,A62,Th7;
A66:    IC Comput(P,s1,4*i+1) = 1 by A39,A51,A56,Th5;
        then
A67:    ( Comput(P,s1,4*i+2)).dl.2 = ( Comput(P,s1,4*i+1)).dl.2 by A39,A61,Th6
          .= ( Comput(Q,s2,4*i+2)).dl.2 by A40,A61,A63,A59,Th6;
A68:    ( Comput(P,s1,4*i+2)).b = ( Comput(P,s1,4*i
+1)).a mod (
        Comput(P,s1,4*i+1)).b by A39,A61,A66,Th6
          .= ( Comput(Q,s2,4*i+2)).b by A40,A61,A63,A58,A60,Th6;
A69:    IC Comput(P,s1,4*i+2) = 2 by A39,A61,A66,Th6;
        then
A70:    IC Comput(P,s1,4*i+3) = 3 by A39,A62,Th7;
A71:    ( Comput(P,s1,4*i+2)).a = ( Comput(P,s1,4*i+1)).a div (
        Comput(P,s1,4*i+1)).b by A39,A61,A66,Th6
          .= ( Comput(Q,s2,4*i+2)).a by A40,A61,A63,A58,A60,Th6;
A72:    4*i + 3 + 1 = 4*i + (3 + 1);
A73:    ( Comput(P,s1,4*i+3)).a = ( Comput(P,s1,4*i+2)).dl.2 by A39,A62,A69,Th7
          .= ( Comput(Q,s2,4*i+3)).a by A40,A62,A64,A67,Th7;
A74:    ( Comput(P,s1,4*i+3)).b = ( Comput(P,s1,4*i+2)).b by A39,A62,A69,Th7
          .= ( Comput(Q,s2,4*i+3)).b by A40,A62,A64,A68,Th7;
        ( Comput(P,s1,4*i+3)).b <= 0 or ( Comput(P,s1,4*i+3)).b > 0;
        then
        IC Comput(P,s1,4*i+4) = 4 & IC Comput(Q,s2,4*i+4) = 4 or
        IC Comput(P,s1,4*i+4) = 0 & IC Comput(Q,s2,4*i+4) = 0
          by A39,A40,A72,A70,A65,A74,Th8;
        hence IC Comput(P,s1,4*i+j) = IC Comput(Q,s2,4*i+j)
           by A55,A66,A40,A56,Th5,A39,A61,Th6,A64,A70,A62,Th7;
        ( Comput(P,s1,4*i+4)).a = ( Comput(P,s1,4*i+3)).a by A39,A72,A70,Th8
          .= ( Comput(Q,s2,4*i+4)).a by A40,A72,A65,A73,Th8;
        hence
        Comput(P,s1,4*i+j).a = Comput(Q,s2,4*i+j).a by A55,A58,A71,A73;
        ( Comput(P,s1,4*i+4)).b = ( Comput(P,s1,4*i+3)).b by A39,A72,A70,Th8
          .= ( Comput(Q,s2,4*i+4)).b by A40,A72,A65,A74,Th8;
        hence thesis by A55,A60,A68,A74;
      end;
      suppose
A75:    IC Comput(Q,s2,4*i) = 4;
        then P halts_at IC Comput(P,s1,4*i)
          by A39,A51,Lm3;
        then
A76:    Comput(P,s1,4*i+j) = Comput(P,s1,4*i) by EXTPRO_1:20,NAT_1:11;
        Q halts_at IC Comput(Q,s2,4*i) by A40,A75,Lm3;
        hence thesis by A51,A52,A53,A76,EXTPRO_1:20,NAT_1:11;
      end;
    end;
    ( Comput(P,s1,0)).IC SCM = IC s1 by EXTPRO_1:2
      .= 0 by A46,MEMSTR_0:def 8
      .= IC s2 by A49,MEMSTR_0:def 8
      .= ( Comput(Q,s2,0)).IC SCM by EXTPRO_1:2;
    then
A77: P[ 0] by A22,A41,A43,A45;
A78: 4 > 0;
    P[k] from NAT_D:sch 2(A77,A78,A50);
   hence thesis by A33,A47,GRFUNC_1:31;
  end;
  take d;
  thus x = d;
A79: p +* d is q-halted
  proof
    reconsider i19 = i1, i29 = i2 as Element of NAT by A7,A8,INT_1:3;
    let t be State of SCM;
    assume
B80:  p +* d c= t;
    let P be Instruction-Sequence of SCM such that
A81:  q c= P;
    set t9 = Comput(P,t,4);
A84: t.b = i2 by A22,B80;
A85: t is 0-started & t.a = i1 by A35,A22,B80,MEMSTR_0:17;
    per cases by XXREAL_0:1;
    suppose
      i1 > i2;
      then ex k st P halts_at IC Comput(P,t,k)
       by A8,A81,A85,A84,Lm6;
      hence thesis by EXTPRO_1:16;
    end;
    suppose
A86:  i1 = i2;
A87:  i1 mod i2 = i19 mod i29
        .= 0 by A86,NAT_D:25;
A88:  t9 = Comput(P,t,4*(0+1));
      t = Comput(P,t,4*0) by EXTPRO_1:2;
      then t9.b = t.a mod t.b by A7,A8,A81,A85,A84,A88,Lm5;
      then IC t9 = 4 by A7,A8,A81,A85,A84,A87,A88,Lm4;
      then P halts_at IC t9 by A81,Lm3;
      hence thesis by EXTPRO_1:16;
    end;
    suppose
A89:  i1 < i2;
A90:  t9 = Comput(P,t,4*(0+1));
A92:  t = Comput(P,t,4*0) by EXTPRO_1:2;
      i1 mod i2 = i19 mod i29
        .= i19 by A89,NAT_D:24;
      then
A93:  t9.b = i1 by A7,A8,A81,A85,A84,A92,A90,Lm5;
      then IC t9 = 0 by A7,A8,A81,A85,A84,A90,Lm4;
      then
A94:  t9 is 0-started by MEMSTR_0:def 9;
      t9.a = i2 by A7,A8,A81,A85,A84,A92,A90,Lm5;
      then consider k0 being Element of NAT such that
A95:  P halts_at IC Comput(P,t9,k0) by A7,A89,A93,A94,A81,Lm6;
      P halts_at IC Comput(P,t,k0+4) by A95,EXTPRO_1:4;
      hence thesis by EXTPRO_1:16;
    end;
  end;
  thus
  p +* d is Autonomy of q by A38,A79,EXTPRO_1:def 12;
  then
A98: Result(q,p+*d) = Result(T,t)|dom (p+*d)
          by C10,A10,EXTPRO_1:def 13;
  a in the carrier of SCM;
  then
A99: a in dom Result(T,t) by PARTFUN1:def 2;
A101: d.a = i1 by A9,AMI_3:10,FUNCT_4:63;
A102: d.b = i2 by A9,FUNCT_4:63;
A103: d c= p +* d by FUNCT_4:25;
A104: dom d c= dom(p +* d) by A103,RELAT_1:11;
A105: d c= t by A103,A10,XBOOLE_1:1;
A106: dom d = { a, b } by A9,FUNCT_4:62;
  then
BB:  b in dom d by TARSKI:def 2;
A107: t.b = i2 by A105,A102,BB,GRFUNC_1:2;
AA: a in dom d by A106,TARSKI:def 2;
  t.a = i1 by A105,A101,AA,GRFUNC_1:2;
  then
A109: (Result(T,t)).a = i1 gcd i2
      by A7,A8,A36,A107,Th10,C10;
A111: dom(a .--> (i1 gcd i2)) = { a } by FUNCOP_1:13;
  dom(a .--> (i1 gcd i2)) c= dom d by A106,A111,ZFMISC_1:7;
   then
A112: dom(a .--> (i1 gcd i2)) c= dom(p +* d) by A104,XBOOLE_1:1;
   a .--> (i1 gcd i2) c= (Result(T,t))|dom(p +* d)
        by A112,A99,A109,FUNCT_4:85,RELAT_1:151;
  hence Euclide-Function.d c= Result(q,p+* d) by A98,A7,A8,A9,Th12;
end;

