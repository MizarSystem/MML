:: Insert Sort on SCM+FSA
::  by JingChao Chen
::
:: Received March 13, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies NUMBERS, SCMFSA7B, AMI_1, SCMFSA_2, SCMFSA6A, CARD_1, SF_MASTR,
      AMI_3, SCMNORM, RELAT_1, FUNCT_1, FUNCT_4, FUNCOP_1, FINSUB_1, CARD_3,
      SUBSET_1, TARSKI, SCMFSA8B, TURING_1, SCMFSA8A, AMISTD_2, ARYTM_3,
      VALUED_1, XBOOLE_0, FSM_1, SCMFSA_9, SCMFSA6C, SCMFSA6B, CIRCUIT2,
      GRAPHSP, MSUALG_1, SCM_HALT, FUNCT_7, XXREAL_0, UNIALG_2, NAT_1,
      SCMFSA8C, FINSEQ_1, ARYTM_1, GLIB_000, INT_1, COMPLEX1, PARTFUN1,
      CLASSES1, VALUED_0, SCMBSORT, STRUCT_0, SCMISORT, PBOOLE, ORDINAL1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      FUNCOP_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4, FUNCT_7,
      FINSEQ_1, CARD_3, VALUED_1, PBOOLE, STRUCT_0, AMI_1, SCMNORM, SCMFSA_2,
      SCMFSA_4, SCMFSA_5, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SCMFSA_9, SCMFSA8B, INT_1, SCMBSORT, FINSUB_1, SCMFSA8C,
      CLASSES1, RFINSEQ, SCM_HALT, INT_2, NAT_1, XXREAL_0;
 constructors DOMAIN_1, SETWISEO, XXREAL_0, REAL_1, NAT_1, PARTFUN1, SEQ_1,
      INT_2, SEQM_3, RFINSEQ, AMI_5, SCMFSA_5, SCMFSA6A, SCMFSA6B, SCMFSA6C,
      SCMFSA8A, SCMFSA8B, SCMFSA8C, SCMFSA_9, SFMASTR1, SCM_HALT, SCMBSORT,
      SCMNORM, CLASSES1, SCMFSA_4, RELSET_1, SCMFSA_1, PRE_POLY, PBOOLE;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, RELSET_1, FUNCOP_1, FINSUB_1,
      NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, STRUCT_0, SCMFSA_2,
      SF_MASTR, SCMFSA6C, SCMFSA8A, SCMFSA_9, SCM_HALT, VALUED_0, SCMNORM,
      ORDINAL1, FINSET_1, VALUED_1, GRFUNC_1, FUNCT_2, FUNCT_4, RELAT_1,
      PBOOLE, AMI_1;
 requirements BOOLE, REAL, NUMERALS, SUBSET, ARITHM;
 definitions AMI_1, SCMFSA_2, FUNCOP_1, SCMFSA6A, SCMNORM, PBOOLE;
 theorems SF_MASTR, FUNCT_1, FUNCT_7, FUNCOP_1, RELAT_1, AMI_1, FUNCT_2,
      SCMFSA6A, FUNCT_4, FINSEQ_3, ENUMSET1, AMI_3, NAT_1, TARSKI, INT_1,
      GRFUNC_1, RFINSEQ, SCMFSA_2, SCMFSA6B, SCMFSA7B, SCMFSA8B, SCMFSA8A,
      SCMFSA8C, SCMFSA_4, SCMFSA6C, SCM_HALT, ABSVALUE, FINSEQ_4, SCMBSORT,
      SCMFSA_9, SCMFSA_5, SCMFSA9A, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1,
      XXREAL_0, VALUED_1, CLASSES1, PBOOLE, PARTFUN1, SCMNORM;
 schemes NAT_1;

begin :: Preliminaries

registration
  let i be good Instruction of SCM+FSA;
  cluster Macro i -> good;
  coherence
  proof
    i does_not_destroy intloc 0 by SCM_HALT:def 6;
    hence thesis by SCMFSA8C:99;
  end;
end;

registration
  let a be read-write Int-Location,b be Int-Location;
  cluster AddTo(a,b) -> good;
  coherence
  proof
    AddTo(a,b) does_not_destroy intloc 0 by SCMFSA7B:13;
    hence thesis by SCM_HALT:def 6;
  end;
end;

canceled;

theorem
  for p be preProgram of SCM+FSA,l be Element of NAT,
  ic be Instruction of SCM+FSA st l in dom p & (ex pc be Instruction of SCM+FSA
st pc=p.l & UsedIntLoc pc=UsedIntLoc ic) holds UsedIntLoc p = UsedIntLoc (p+*(l
  .-->ic))
proof
  let p be preProgram of SCM+FSA,l be Element of NAT, ic be
  Instruction of SCM+FSA;
  set pl=p+*(l.-->ic);
  assume that
A1: l in dom p and
A2: ex pc be Instruction of SCM+FSA st pc=p.l & UsedIntLoc pc=
  UsedIntLoc ic;
  consider UIL being Function of the Instructions of SCM+FSA,Fin Int-Locations
  such that
A3: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A4: UsedIntLoc p = Union (UIL * p) by SF_MASTR:def 2;
  set f = UIL * p, g = UIL * pl;
  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A5: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A6: UsedIntLoc pl = Union (UIL2 * pl) by SF_MASTR:def 2;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A3
      .= UIL2.c by A5;
  end;
  then
A7: UIL=UIL2 by FUNCT_2:113;
A8: pl.l=(p+*(l,ic)).l by A1,FUNCT_7:def 3
    .=ic by A1,FUNCT_7:33;
  now
A9: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
    then rng p c= dom UIL by AMI_1:118;
    then
A10: dom f = dom p by RELAT_1:46;
A11: dom p = dom pl by A1,FUNCT_7:114;
A12: rng pl c= dom UIL by A9,AMI_1:118;
    hence dom f = dom g by A11,A10,RELAT_1:46;
    let x be set;
    assume
A13: x in dom f;
    then pl.x in rng pl by A11,A10,FUNCT_1:def 5;
    then reconsider plx = pl.x as Instruction of SCM+FSA by A12,FUNCT_2:def 1;
    per cases;
    suppose
      x<>l;
      then not x in {l} by TARSKI:def 1;
      then not x in dom (l.-->ic) by FUNCOP_1:19;
      then p.x=pl.x by FUNCT_4:12;
      hence f.x = UIL.plx by A13,FUNCT_1:22
        .= g.x by A11,A10,A13,FUNCT_1:23;
    end;
    suppose
A14:  x=l;
      thus f.x = UIL.(p.x) by A13,FUNCT_1:22
        .= UsedIntLoc plx by A2,A8,A3,A14
        .= UIL.plx by A5,A7
        .= g.x by A11,A10,A13,FUNCT_1:23;
    end;
  end;
  hence thesis by A4,A6,A7,FUNCT_1:9;
end;

theorem
  for a being Int-Location,I being Program of SCM+FSA holds if>0(a, I
  ';' Goto  0,Stop SCM+FSA).(card I +4) = goto  (card I +4)
proof
  let a be Int-Location,I be Program of SCM+FSA;
  set I4=card I +4, Lc4=I4, Gi= Goto  0, SS=Stop SCM+FSA, I1=I ';' Gi, F
=if>0(a, I1, SS), i=a>0_goto  (card SS + 3), MM=i ';' SS ';' Goto
  (card I1 + 1) ';' I, GS=Gi ';' SS;
A1: I4 < card I + 6 by XREAL_1:8;
  card F=card I +6 by SCMFSA_9:2;
  then
A2: Lc4 in dom F by A1,SCMFSA6A:15;
A3:  0 + I4 =  ( 0 + I4);
A4: Gi. 0=goto  0 by SCMFSA8A:47;
  then
A5: Gi. 0 <> halt SCM+FSA by SCMFSA_9:9;
A6:  0 in dom Gi by SCMFSA8A:47;
  then
A7: GS. 0 = (Directed Gi). 0 by SCMFSA8A:28
    .=goto  0 by A6,A4,A5,SCMFSA8A:30;
x: card Stop SCM+FSA = 1 by SCMNORM:3;
  card GS=card Gi + card SS by SCMFSA6A:61
    .=1 + 1 by SCMFSA8A:29,x
    .=2;
  then
A8:  0 in dom GS by SCMFSA6A:15;
  then  0 + I4 in { il+I4 where il is Element of NAT: il in dom GS};
  then
A9: Lc4 in dom Shift(GS,I4) by VALUED_1:def 12;
  then
A10: pi(Shift(GS,I4),Lc4) = Shift(GS,I4).( 0 +I4) by AMI_1:def 47
    .= goto  0 by A7,A8,VALUED_1:def 12;
x: card Stop SCM+FSA = 1 by SCMNORM:3;
A11: card MM = card (i ';' SS ';' Goto  (card I1 + 1)) + card I by SCMFSA6A:61
    .= card (i ';' SS) + card Goto  (card I1 + 1) + card I by SCMFSA6A:61
    .= card (i ';' SS) + 1 + card I by SCMFSA8A:29
    .= card Macro i + 1 + 1 + card I by SCMFSA6A:61,x
    .= 2 + 1 + 1 + card I by SCMFSA7B:6
    .=I4;
  then
A12: not Lc4 in dom MM by SCMFSA6A:15;
A13: F= i ';' SS ';' Goto  (card I1 + 1) ';' I1 ';' SS by SCMFSA8B:def 2
    .=MM ';' Gi ';' SS by SCMFSA6A:67
    .=MM ';' GS by SCMFSA6A:67
    .= Directed MM +* ProgramPart Relocated(GS, I4) by A11;
  then
A14: dom F = dom Directed MM \/ dom ProgramPart Relocated(GS, I4) by
FUNCT_4:def 1;
  then dom F = dom MM \/ dom ProgramPart Relocated(GS, I4) by FUNCT_4:105;
  then Lc4 in dom ProgramPart Relocated(GS, I4) by A2,A12,XBOOLE_0:def 3;
  hence F.Lc4 = (ProgramPart Relocated(GS,I4)).Lc4 by A2,A13,A14,FUNCT_4:def 1
    .= IncAddr(Shift(ProgramPart(GS),I4),I4).Lc4 by SCMFSA_5:2
    .= IncAddr(Shift(GS,I4),I4).Lc4 by AMI_1:105
    .= IncAddr(goto  0, I4 ) by A9,A10,SCMFSA_4:24
    .= goto  I4 by A3,SCMFSA_4:14;
end;

theorem
  for p be preProgram of SCM+FSA,l be Element of NAT,
  ic be Instruction of SCM+FSA st l in dom p & (ex pc be Instruction of SCM+FSA
st pc=p.l & UsedInt*Loc pc=UsedInt*Loc ic) holds UsedInt*Loc p = UsedInt*Loc (p
  +*(l.-->ic))
proof
  let p be preProgram of SCM+FSA,l be Element of NAT,ic be
  Instruction of SCM+FSA;
  set pl=p+*(l.-->ic);
  assume that
A1: l in dom p and
A2: ex pc be Instruction of SCM+FSA st pc=p.l & UsedInt*Loc pc=
  UsedInt*Loc ic;
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A4: UsedInt*Loc p = Union (UIL * p) by SF_MASTR:def 4;
  set f = UIL * p, g = UIL * pl;
  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A5: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A6: UsedInt*Loc pl = Union (UIL2 * pl) by SF_MASTR:def 4;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A3
      .= UIL2.c by A5;
  end;
  then
A7: UIL=UIL2 by FUNCT_2:113;
A8: pl.l=(p+*(l,ic)).l by A1,FUNCT_7:def 3
    .=ic by A1,FUNCT_7:33;
  now
A9: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
    then rng p c= dom UIL by AMI_1:118;
    then
A10: dom f = dom p by RELAT_1:46;
A11: dom p = dom pl by A1,FUNCT_7:114;
A12: rng pl c= dom UIL by A9,AMI_1:118;
    hence dom f = dom g by A11,A10,RELAT_1:46;
    let x be set;
    assume
A13: x in dom f;
    then pl.x in rng pl by A11,A10,FUNCT_1:def 5;
    then reconsider plx = pl.x as Instruction of SCM+FSA by A12,FUNCT_2:def 1;
    per cases;
    suppose
      x<>l;
      then not x in {l} by TARSKI:def 1;
      then not x in dom (l.-->ic) by FUNCOP_1:19;
      then p.x=pl.x by FUNCT_4:12;
      hence f.x = UIL.plx by A13,FUNCT_1:22
        .= g.x by A11,A10,A13,FUNCT_1:23;
    end;
    suppose
A14:  x=l;
      thus f.x = UIL.(p.x) by A13,FUNCT_1:22
        .= UsedInt*Loc plx by A2,A8,A3,A14
        .= UIL.plx by A5,A7
        .= g.x by A11,A10,A13,FUNCT_1:23;
    end;
  end;
  hence thesis by A4,A6,A7,FUNCT_1:9;
end;

reserve s for State of SCM+FSA,
  I for Program of SCM+FSA,
  a for read-write
  Int-Location;

reserve i,j,k,n for Element of NAT;

canceled;

theorem Th6:
  for s be State of SCM+FSA,I be Program of SCM+FSA st s.intloc 0=1
  & IC s =  0 holds s +* I = s +* Initialized I
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  assume that
A1: s.intloc 0=1 and
A2: IC s =  0;
A3: IC SCM+FSA in dom s by AMI_1:94;
  thus s +* Initialized I = s +* (I +* Start-At( 0,SCM+FSA))
  by A1,SCMFSA8C:18
    .= s +* I +* Start-At( 0,SCM+FSA) by FUNCT_4:15
    .= s +* (IC SCM+FSA .-->  0) +* I by SCMFSA6B:14
    .= s +* I by A2,A3,FUNCT_7:111;
end;

theorem Th7:
  for I being Program of SCM+FSA,a,b being Int-Location st I
  does_not_destroy b holds while>0(a,I) does_not_destroy b
proof
  let I be Program of SCM+FSA,a,b be Int-Location;
  set J= (card I +4) .--> goto  0, Gi= Goto  0, SS=Stop
  SCM+FSA, F=if>0(a, I ';' Gi, SS);
A1: Gi does_not_destroy b by SCMFSA8C:86;
A2: SS does_not_destroy b by SCMFSA8C:85;
  assume
  I does_not_destroy b;
  then I ';' Gi does_not_destroy b by A1,SCMFSA8C:81;
  then
A3: F does_not_destroy b by A2,SCMFSA8C:121;
A4: while>0(a,I) = F+*J by SCMFSA_9:def 2;
  J does_not_destroy b by SCMFSA_9:35;
  hence thesis by A3,A4,SCMFSA8A:25;
end;

canceled 2;

theorem Th10:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_halting_on Initialize s holds for a be Int-Location holds IExec(I,s).a =
Comput(ProgramPart( (Initialize s +* (I +* Start-At( 0,SCM+FSA)))), (Initialize
s +* (I +* Start-At( 0,SCM+FSA))),
(LifeSpan (Initialize
  s +* (I +* Start-At( 0,SCM+FSA))))).a
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  set s0 = Initialize s, s1 = s0 +* (I +* Start-At( 0,SCM+FSA)), A = NAT;
  assume
  I is_halting_on s0;
  then
A1: ProgramPart s1 halts_on s1 by SCMFSA7B:def 8;
  hereby
    let a be Int-Location;
    not a in A by SCMFSA_2:84;
    then not a in dom s /\ A by XBOOLE_0:def 4;
    then
A2: not a in dom (s | A) by RELAT_1:90;
    s +* Initialized I = s1 by SCMFSA8A:13;
    hence IExec(I,s).a = (Result s1 +* s | A).a by SCMFSA6B:def 1
      .= (Result s1).a by A2,FUNCT_4:12
      .= Comput(ProgramPart( s1), s1,LifeSpan s1).a by A1,AMI_1:122;
  end;
end;

theorem Th11: ::SCMFSA6B_28
  for s1,s2 be State of SCM+FSA,I be InitHalting Program of
SCM+FSA st Initialized I c= s1 & Initialized I c= s2 & s1,s2 equal_outside NAT
  holds for k be Element of NAT holds Comput(ProgramPart( s1), s1,k), Comput(
ProgramPart( s2), s2,k)
  equal_outside NAT & CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(
ProgramPart(s1),s1,k))
   = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(s2),
s2,k))
proof
  let s1,s2 be State of SCM+FSA,I be InitHalting Program of SCM+FSA;
  assume that
A1: Initialized I c= s1 and
A2: Initialized I c= s2 and
A3: s1,s2 equal_outside NAT;
A4: I c= s2 by A2,SCM_HALT:13;
A5: I c= s1 by A1,SCM_HALT:13;
  hereby
    let k be Element of NAT;
A6: IC Comput(ProgramPart(s1),s1,k) in dom I by A1,SCM_HALT:def 1;
A7: IC Comput(ProgramPart(s2),s2,k) in dom I by A2,SCM_HALT:def 1;
    for m being Element of NAT st m < k holds IC(Comput(ProgramPart(s2),s2,m))
in dom
    I by A2,SCM_HALT:def 1;
    hence Comput(ProgramPart(s1),s1,k), Comput(ProgramPart(s2),s2,k)
equal_outside NAT by A3,A5,A4,SCMFSA6B:21;
    then
A8: IC Comput(ProgramPart(s1),s1,k) = IC Comput(ProgramPart( s2), s2,k) by
AMI_1:121;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(s1),s1,k))/.IC Comput(ProgramPart(s1),s1,k)
 = Comput(ProgramPart(s1),s1,k).IC Comput(ProgramPart(s1),s1,k) by AMI_1:150;
    thus CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(
s2),s2,k))
     = s2.IC Comput(ProgramPart( s2), s2,k) by Y,AMI_1:54
      .= I.IC Comput(ProgramPart(s2),s2,k) by A4,A7,GRFUNC_1:8
      .= s1.IC Comput(ProgramPart(s1),s1,k) by A5,A8,A6,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(ProgramPart(
s1),s1,k))
      by Z,AMI_1:54;
  end;
end;

theorem Th12: ::SCMFSA6B_29
  for s1,s2 be State of SCM+FSA,I be InitHalting Program of
SCM+FSA st Initialized I c= s1 & Initialized I c= s2 & s1,s2 equal_outside NAT
  holds LifeSpan s1 = LifeSpan s2 & Result s1, Result s2 equal_outside NAT
proof
  let s1,s2 be State of SCM+FSA,I be InitHalting Program of SCM+FSA;
  assume that
A1: Initialized I c= s1 and
A2: Initialized I c= s2 and
A3: s1,s2 equal_outside NAT;
A4: ProgramPart s2 halts_on s2 by A2,SCM_HALT:5;
A5: ProgramPart s1 halts_on s1 by A1,SCM_HALT:5;
A6: now
    let l be Element of NAT;
    assume
A7: CurInstr(ProgramPart Comput(ProgramPart(s2),s2,l),Comput(ProgramPart(s2),s2
,l)) = halt SCM+FSA;
    CurInstr(ProgramPart Comput(ProgramPart(s1),s1,l),Comput(ProgramPart(s1),s1
,l))
     = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,l),
    Comput(ProgramPart(s2),s2,l))
     by A1,A2,A3,Th11;
    hence LifeSpan s1 <= l by A5,A7,AMI_1:def 46;
  end;
  CurInstr(ProgramPart Comput(ProgramPart(s2),s2,LifeSpan s1),Comput(
ProgramPart(s2),s2,LifeSpan s1))
   = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,LifeSpan s1),
   Comput(ProgramPart(s1),s1,LifeSpan s1))
    by A1,A2,A3,Th11
    .= halt SCM+FSA by A5,AMI_1:def 46;
  hence
X: LifeSpan s1 = LifeSpan s2 by A6,A4,AMI_1:def 46;
  ProgramPart s2 halts_on s2 by A2,SCM_HALT:5;
  then
A8: Result s2 = Comput(ProgramPart( s2), s2,LifeSpan s1) by X,AMI_1:122;
  ProgramPart s1 halts_on s1 by A1,SCM_HALT:5;
  then Result s1 = Comput(ProgramPart( s1), s1,LifeSpan s1) by AMI_1:122;
  hence thesis by A1,A2,A3,A8,Th11;
end;

theorem Th13: ::SCMFSA6A_49
  for I be Program of SCM+FSA, f be FinSeq-Location holds not f in
  dom I
proof
  let I be Program of SCM+FSA,f be FinSeq-Location;
A1: dom I c= NAT by RELAT_1:def 18;
  assume
  f in dom I;
  then reconsider f as Element of NAT by A1;
  f=f;
  hence contradiction by SCMFSA_2:85;
end;

theorem Th14: ::SCMFSA6A_48
  for I be Program of SCM+FSA, a be Int-Location holds not a in
  dom I
proof
  let I be Program of SCM+FSA,a be Int-Location;
A1: dom I c= NAT by RELAT_1:def 18;
  assume
  a in dom I;
  then reconsider a as Element of NAT by A1;
  a=a;
  hence contradiction by SCMFSA_2:84;
end;

begin  :: -- Basic property of while Macro ---

canceled;

theorem Th16:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location st s.a <= 0 holds while>0(a,I) is_halting_onInit
  s & while>0(a,I) is_closed_onInit s
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  let a be read-write Int-Location;
  set s0=Initialize s;
  assume
  s.a <= 0;
  then
A1: s0.a <= 0 by SCMFSA6C:3;
  then
A2: while>0(a,I) is_closed_on s0 by SCMFSA_9:43;
  while>0(a,I) is_halting_on s0 by A1,SCMFSA_9:43;
  hence thesis by A2,SCM_HALT:40,41;
end;

theorem
  for a being Int-Location, I being Program of SCM+FSA, s being State of
SCM+FSA,k being Element of NAT st I is_closed_onInit s & I is_halting_onInit s
& k < LifeSpan (s +* Initialized I) & IC Comput(ProgramPart( (s +* Initialized
while>0
  (a,I))), (s +* Initialized while>0
  (a,I)),1 + k) = IC Comput(ProgramPart( (s +* Initialized I)), (s +*
Initialized I),k) + 4 & DataPart
Comput(ProgramPart( (s +* Initialized while>0(a,I))), (s +* Initialized while>0
(a,I)),1 + k) = DataPart Comput(ProgramPart( (s
+* Initialized I)), (s
+* Initialized I),k) holds IC Comput(ProgramPart( (s +* Initialized while>0(a,I
))), (s +* Initialized while>0(a,I)),1 +
k+1) = IC Comput(ProgramPart( (s +* Initialized I)), (s +* Initialized I),k+1)
+ 4 & DataPart Comput(ProgramPart( (s
+* Initialized while>0(a,I))), (s
+* Initialized while>0(a,I)),1 + k+1) = DataPart Comput(ProgramPart( (s +*
Initialized
  I)), (s +* Initialized
  I),k+1)
proof
  let a be Int-Location,I be Program of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA,k be Element of NAT;
  set s0=Initialize s, sw = s +* Initialized while>0(a,I), sI = s +*
Initialized I, s0I= s0 +* (I +* Start-At( 0,SCM+FSA)), s0w= s0 +*
(while>0(a,I) +*
Start-At( 0,SCM+FSA)), sK1= Comput(ProgramPart( sw), sw,1 + k),
sK2= Comput(ProgramPart( sI), sI,k), l3=IC
  Comput(ProgramPart( sI), sI,k);
A1: sI=s0I by SCMFSA8A:13;
A2: sw=s0w by SCMFSA8A:13;
  assume
  I is_closed_onInit s;
  then
A3: I is_closed_on s0 by SCM_HALT:40;
  assume
  I is_halting_onInit s;
  then
A4: I is_halting_on s0 by SCM_HALT:41;
  assume
A5: k < LifeSpan sI;
  assume
A6: IC Comput(ProgramPart( sw), sw,1 + k)=l3 + 4;
  assume
A7: DataPart sK1 = DataPart sK2;
  hence IC Comput(ProgramPart( sw), sw,1 + k+1) = IC Comput(ProgramPart( sI),
sI,k+1) + 4 by A5,A6,A3,A4,A1,A2,SCMFSA_9:44;
  thus thesis by A5,A6,A7,A3,A4,A1,A2,SCMFSA_9:44;
end;

theorem
  for a being Int-Location, I being Program of SCM+FSA, s being State of
SCM+FSA st I is_closed_onInit s & I is_halting_onInit s & IC Comput(ProgramPart
( (s +*
Initialized while>0(a,I))), (s +*
Initialized while>0(a,I)),1 + LifeSpan (s +* Initialized I)) = IC Comput(
ProgramPart(
  (s +* Initialized I)),
  (s +* Initialized I),LifeSpan (s +* Initialized I)) + 4
   holds CurInstr(ProgramPart
Comput(ProgramPart((s +* Initialized while>0(a,I))),(s +* Initialized while>0(a
,I)),1 + LifeSpan (s +* Initialized I)),
Comput(ProgramPart((s +* Initialized while>0(a,I))),(s +* Initialized while>0(a
,I)),1 + LifeSpan (s +* Initialized I)))
  = goto  (card I +4)
proof
  let a be Int-Location,I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s0=Initialize s, sw = s +* Initialized while>0(a,I), sI = s +*
Initialized I, s0I= s0 +* (I +* Start-At( 0,SCM+FSA)), s0w= s0 +*
(while>0(a,I) +*
  Start-At( 0,SCM+FSA));
A1: sI=s0I by SCMFSA8A:13;
A2: sw=s0w by SCMFSA8A:13;
  assume
  I is_closed_onInit s;
  then
A3: I is_closed_on s0 by SCM_HALT:40;
  assume
  I is_halting_onInit s;
  then
A4: I is_halting_on s0 by SCM_HALT:41;
  assume
  IC Comput(ProgramPart( sw), sw,1 + LifeSpan sI) = IC Comput(ProgramPart( sI),
sI,LifeSpan sI
  ) + 4;
  hence thesis by A3,A4,A1,A2,SCMFSA_9:45;
end;

theorem Th19:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location st I is_closed_onInit s & I is_halting_onInit s &
  s.a >0 holds IC Comput(ProgramPart( (s +* Initialized while>0(a,I))), (s +*
Initialized while>0(a,I)), (LifeSpan (s +*
Initialized I) + 3)) =  0 & for k being Element of NAT st k <= LifeSpan (
s +* Initialized I) + 3 holds IC Comput(ProgramPart( (s +* Initialized while>0(
a,I))), (s +* Initialized while>0(a,I)),k
  ) in dom while>0(a,I)
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  let a be read-write Int-Location;
  set s0=Initialize s, sw = s +* Initialized while>0(a,I), sI = s +*
Initialized I, s0I= s0 +* (I +* Start-At( 0,SCM+FSA)), s0w= s0 +*
(while>0(a,I) +*
  Start-At( 0,SCM+FSA));
A1: sI=s0I by SCMFSA8A:13;
A2: sw=s0w by SCMFSA8A:13;
  assume
  I is_closed_onInit s;
  then
A3: I is_closed_on s0 by SCM_HALT:40;
  assume
  I is_halting_onInit s;
  then
A4: I is_halting_on s0 by SCM_HALT:41;
  assume
  s.a >0;
  then
A5: s0.a>0 by SCMFSA6C:3;
  hence IC Comput(ProgramPart( sw), sw,LifeSpan sI + 3) =  0 by A3,A4,A1,A2,
SCMFSA_9:47;
  thus thesis by A3,A4,A5,A1,A2,SCMFSA_9:47;
end;

theorem ::SCM_9_36
  for s being State of SCM+FSA, I being Program of SCM+FSA,a be
read-write Int-Location st I is_closed_onInit s & I is_halting_onInit s & s.a >
  0 holds for k being Element of NAT st k <= LifeSpan (s +* Initialized I) + 3
  holds IC Comput(ProgramPart( (s +* Initialized while>0(a,I))), (s +*
Initialized while>0(a,I)),k) in dom while>0(a,I)
proof
  let s be State of SCM+FSA, I be Program of SCM+FSA,a be read-write
  Int-Location;
  set s0=Initialize s, IA=I +* Start-At( 0,SCM+FSA);
  assume
A1: I is_closed_onInit s;
  now
    let k be Element of NAT;
X: s +* Initialized I = Initialize s +* (I +* Start-At( 0,SCM+FSA))
           by SCMFSA8A:13;
IC Comput(ProgramPart( (s +* Initialized I )), (s +* Initialized I ),k) in
dom I by A1,SCM_HALT:def 4;
    hence IC Comput(ProgramPart( (s0 +* IA )), (s0 +* IA ),k) in dom I by X;
  end;
  then
A2: I is_closed_on s0 by SCMFSA7B:def 7;
  assume
  I is_halting_onInit s;
  then
X:   ProgramPart(s+*Initialized I) halts_on s+*Initialized I
   by SCM_HALT:def 5;
  s +* Initialized I = Initialize s +* (I +* Start-At( 0,SCM+FSA))
  by SCMFSA8A:13;
  then ProgramPart(s0+*IA) halts_on s0+*IA by X;
  then
A3: I is_halting_on s0 by SCMFSA7B:def 8;
  assume
  s.a >0;
  then
A4: s0.a > 0 by SCMFSA6C:3;
  hereby
    let k be Element of NAT;
X: s +* Initialized while>0(a,I) =
Initialize s +* (while>0(a,I) +* Start-At( 0,SCM+FSA))
           by SCMFSA8A:13;
    assume
    k <= LifeSpan (s +* Initialized I) + 3;
    then k <= LifeSpan (s0 +* IA) + 3 by SCMFSA8A:13;
    then
    IC Comput(ProgramPart( (s0 +* (while>0(a,I) +* Start-At( 0,SCM+FSA)))), (s0
+* (while>0(a,I) +* Start-At( 0,SCM+FSA))),k)
     in dom
    while>0(a,I) by A2,A3,A4,SCMFSA_9:47;
    hence
    IC Comput(ProgramPart( (s +* Initialized while>0(a,I))), (s +* Initialized
while>0(a,I)),k) in dom while>0(a,I
    ) by X;
  end;
end;

theorem Th21: ::SCM_9_37
  for s being State of SCM+FSA, I be Program of SCM+FSA,a be
read-write Int-Location st I is_closed_onInit s & I is_halting_onInit s & s.a >
  0 holds IC Comput(ProgramPart( (s +* Initialized while>0(a,I))), (s +*
Initialized while>0(a,I)), (LifeSpan (s +*
  Initialized I) + 3)) =  0 & DataPart Comput(ProgramPart( (s +* Initialized
while>0(a,I))), (s +* Initialized
while>0(a,I)), (LifeSpan (s +* Initialized I) + 3)) = DataPart Comput(
ProgramPart( (s
  +* Initialized I)), (s
  +* Initialized I),LifeSpan (s +* Initialized I))
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA,a be read-write
  Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  set s0=Initialize s, IA=I +* Start-At( 0,SCM+FSA);
  set s1 = s0 +* (while>0(a,I) +* Start-At( 0,SCM+FSA)), s2 =
  Comput(ProgramPart( s1), s1,1),
  i = a >0_goto  4 , sI = s0 +* IA;
  defpred P[Nat] means $1 <= LifeSpan sI implies IC Comput(ProgramPart( s1), s1
,1 + $1) =
  IC Comput(ProgramPart( sI), sI,$1) + 4 & DataPart Comput(ProgramPart( s1), s1
,1 + $1) = DataPart
  Comput(ProgramPart( sI), sI,$1);
  set loc4= (card I + 4);
  set s3= Comput(ProgramPart( s1), s1,1+LifeSpan sI+1);
A1: loc4 in dom while>0(a,I) by SCMFSA_9:38;
  assume
A2: I is_closed_onInit s;
  now
    let k be Element of NAT;
X: s +* Initialized I = Initialize s +* (I +* Start-At( 0,SCM+FSA))
           by SCMFSA8A:13;
    IC Comput(ProgramPart( (s +* Initialized I )), (s +* Initialized I ),k) in
dom I by A2,SCM_HALT:def 4;
    hence IC Comput(ProgramPart( (s0 +* IA )), (s0 +* IA ),k) in dom I by X;
  end;
  then
A3: I is_closed_on s0 by SCMFSA7B:def 7;
  assume
  I is_halting_onInit s;
  then
X:  ProgramPart(s+*Initialized I) halts_on s+*Initialized I
   by SCM_HALT:def 5;
  s +* Initialized I = Initialize s +* (I +* Start-At( 0,SCM+FSA))
  by SCMFSA8A:13;
  then ProgramPart(s0+*IA) halts_on s0+*IA by X;
  then
A4: I is_halting_on s0 by SCMFSA7B:def 8;
A5: now
    let k be Element of NAT;
    assume
A6: P[k];
    now
A7:   k + 0 < k + 1 by XREAL_1:8;
      assume
      k + 1 <= LifeSpan sI;
      then k < LifeSpan sI by A7,XXREAL_0:2;
      hence IC Comput(ProgramPart( s1), s1,1 + k+1) = IC Comput(ProgramPart( sI
), sI,k+1) + 4 &
DataPart Comput(ProgramPart( s1), s1,1 + k+1) = DataPart Comput(ProgramPart( sI
), sI,k+1) by A3,A4,A6,SCMFSA_9:44;
    end;
    hence P[k + 1];
  end;
  while>0(a,I) c= while>0(a,I) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A8: dom while>0(a,I) c= dom (while>0(a,I) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
A9:  0 in dom while>0(a,I) by SCMFSA_9:10;
  then
A10: s1. 0 = (while>0(a,I) +* Start-At( 0,SCM+FSA)). 0 by A8,FUNCT_4:14
    .= while>0(a,I). 0 by A9,SCMFSA6B:7
    .= i by SCMFSA_9:11;
  IC SCM+FSA in dom (while>0(a,I) +* Start-At( 0,SCM+FSA))
  by SF_MASTR:65;
  then
A11: IC s1 = (while>0(a,I) +* Start-At( 0,SCM+FSA)).IC SCM+FSA
by FUNCT_4:14
    .=  0 by SF_MASTR:66;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by AMI_1:150;
A12: Comput(ProgramPart( s1), s1,0 + 1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by AMI_1:14
    .= Following(ProgramPart s1,s1) by AMI_1:13
    .= Exec(i,s1) by A11,A10,Y;
  then
A13: for f be FinSeq-Location holds s2.f = s1.f by SCMFSA_2:97;
  for c be Int-Location holds s2.c = s1.c by A12,SCMFSA_2:97;
  then
A14: DataPart s2 = DataPart s1 by A13,SCMFSA6A:38
    .= DataPart s0 by SCMFSA8A:11
    .= DataPart sI by SCMFSA8A:11;
  set s4= Comput(ProgramPart( s1), s1,1+LifeSpan sI+1+1);
  set s2= Comput(ProgramPart( s1), s1,1 + LifeSpan sI);
A15: LifeSpan sI+1+1+1 =LifeSpan sI+(2+1);
  not a in dom (while>0(a,I) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  then
A16: s1.a = s0.a by FUNCT_4:12;
  assume
  s.a > 0;
  then
A17: s0.a > 0 by SCMFSA6C:3;
A18: P[ 0]
  proof
    assume
    0 <= LifeSpan sI;
A19: IC SCM+FSA in dom (I +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
    IC Comput(ProgramPart( sI), sI,0) = sI.IC SCM+FSA by AMI_1:13
      .= (I +* Start-At( 0,SCM+FSA)).IC SCM+FSA by A19,FUNCT_4:14
      .=  0 by SF_MASTR:66;
    hence thesis by A17,A12,A16,A14,AMI_1:13,SCMFSA_2:97;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A18,A5);
  then
A20: P[LifeSpan sI];
T: ProgramPart s1 = ProgramPart s2
by AMI_1:144;
A21: s3 = Following(ProgramPart s1,s2) by AMI_1:14
    .= Exec(goto loc4,s2) by A3,A4,A20,T,SCMFSA_9:45;
  then
A22: for f be FinSeq-Location holds s3.f = s2.f by SCMFSA_2:95;
A23: s3.loc4 = s1.loc4 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)).loc4 by A8,A1,FUNCT_4:14
    .= while>0(a,I).loc4 by A1,SCMFSA6B:7
    .= goto  0 by SCMFSA_9:46;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
T: ProgramPart s1 = ProgramPart s3
by AMI_1:144;
A24: s4 = Following(ProgramPart s1,s3) by AMI_1:14
    .= Exec(goto  0,s3) by A21,A23,Y,T,SCMFSA_2:95;
  then
A25: for f be FinSeq-Location holds s4.f = s3.f by SCMFSA_2:95;
  for c be Int-Location holds s3.c = s2.c by A21,SCMFSA_2:95;
  then
A26: DataPart s3 = DataPart s2 by A22,SCMFSA6A:38;
X: s +* Initialized while>0(a,I)
= Initialize s +* (while>0(a,I) +* Start-At( 0,SCM+FSA))
           by SCMFSA8A:13;
A27: Comput(ProgramPart( (s +* Initialized while>0(a,I))), (s +* Initialized
while>0(a,I)), (LifeSpan (s +*
Initialized I) + 3)) = Comput(ProgramPart( s1), s1, (LifeSpan (s +* Initialized
I) + 3))
by X
    .=s4 by A15,SCMFSA8A:13;
  hence IC Comput(ProgramPart( (s +* Initialized while>0(a,I))), (s +*
Initialized while>0(a,I)), (LifeSpan (s +*
  Initialized I) + 3)) = 0 by A24,SCMFSA_2:95;
X: s +* Initialized I = Initialize s +* (I +* Start-At( 0,SCM+FSA))
           by SCMFSA8A:13;
  for c be Int-Location holds s4.c = s3.c by A24,SCMFSA_2:95;
  then DataPart s4 = DataPart s2 by A26,A25,SCMFSA6A:38;
  hence DataPart Comput(ProgramPart( (s +* Initialized while>0(a,I))), (s +*
Initialized while>0(a,I)), (LifeSpan (s +*
Initialized I) + 3)) = DataPart Comput(ProgramPart( (s +* Initialized I)), (s
+* Initialized I),LifeSpan sI)
  by A20,A27,X
    .= DataPart Comput(ProgramPart( (s +* Initialized I)), (s +* Initialized I)
, (LifeSpan (s +*
  Initialized I))) by SCMFSA8A:13;
end;

theorem
  for s be State of SCM+FSA, I be InitHalting Program of SCM+FSA, a be
  read-write Int-Location st s.a > 0 holds ex s2 be State of SCM+FSA, k be
  Element of NAT st s2 = s +* Initialized (while>0(a,I)) & k =LifeSpan (s +*
Initialized I) + 3 & IC Comput(ProgramPart( s2), s2,k) =  0 & (for b be
Int-Location
  holds Comput(ProgramPart( s2), s2,k).b = IExec(I,s).b) & for f be
FinSeq-Location holds
  Comput(ProgramPart( s2), s2,k).f = IExec(I,s).f
proof
  let s be State of SCM+FSA,I be InitHalting Program of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  set Is=Initialize s +* (I +* Start-At( 0,SCM+FSA));
  set P = while>0(a,I), s1 = s +* Initialized I;
  take s2 = s +* Initialized P;
  take k = LifeSpan s1 + 3;
  thus s2 = s +* Initialized P & k = LifeSpan s1 + 3;
A2: I is_halting_onInit s by SCM_HALT:36;
  then
X:  ProgramPart s1 halts_on s1 by SCM_HALT:def 5;
:::  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  s+* Initialized I = Initialize s +* (I +* Start-At( 0,SCM+FSA))
  by SCMFSA8A:13;
  then ProgramPart Is halts_on Is by X;
  then
A3: I is_halting_on Initialize s by SCMFSA7B:def 8;
A4: I is_closed_onInit s by SCM_HALT:35;
  hence IC ( Comput(ProgramPart( s2), s2,k))= 0 by A1,A2,Th21;
  set s4= Comput(ProgramPart( s2), s2,k), s3= Comput(ProgramPart( s1), s1,
LifeSpan s1);
X: s +* Initialized I = Initialize s +* (I +* Start-At( 0,SCM+FSA))
           by SCMFSA8A:13;
A5: s3= Comput(ProgramPart( Is), Is,LifeSpan s1) by X
    .= Comput(ProgramPart( Is), Is,LifeSpan Is) by SCMFSA8A:13;
A6: DataPart s4 = DataPart s3 by A1,A2,A4,Th21;
  hereby
    let b be Int-Location;
    thus s4.b = Comput(ProgramPart( Is), Is,LifeSpan Is).b by A5,A6,SCMFSA6A:38
      .= IExec(I,s).b by A3,Th10;
  end;
  hereby
    let f be FinSeq-Location;
    thus s4.f = Comput(ProgramPart( Is), Is,LifeSpan Is).f by A5,A6,SCMFSA6A:38
      .= IExec(I,s).f by A3,SCMFSA8C:87;
  end;
end;

definition
  let s,I,a;
  deffunc U(Nat, Element of product the Object-Kind of SCM+FSA) =
   Comput(ProgramPart(
  ($2 +* Initialized while>0(a,I))),
  ($2 +* Initialized while>0(a,I)), (LifeSpan ($2+* Initialized I) + 3));
  deffunc V(Nat, Element of product the Object-Kind of SCM+FSA) =
   down Comput(ProgramPart(
  ($2 +* Initialized while>0(a,I))),
  ($2 +* Initialized while>0(a,I)), (LifeSpan ($2+* Initialized I) + 3));
  func StepWhile>0(a,s,I) -> Function of NAT,product the Object-Kind of
  SCM+FSA means
  :Def1:
  it.0 = s & for i being Nat holds it.(i+1)= Comput(ProgramPart( (
  it.i +* Initialized while>0(a,I))), (
  it.i +* Initialized while>0(a,I)), (LifeSpan (it.i +* Initialized I) + 3));
  existence
  proof
   reconsider ss=s as
    Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
    consider f being Function of NAT,product the Object-Kind of SCM+FSA
     such that
W1:   f.0 = ss and
W2:  for i being Nat holds f.(i+1)= V(i,f.i) from NAT_1:sch 12;
   take f;
   thus f.0 = s by W1;
   let i be Nat;
    f.(i+1)= V(i,f.i) by W2;
   hence thesis;
  end;
  uniqueness
  proof
    let F1,F2 be Function of NAT,product the Object-Kind of SCM+FSA such that
B1: F1.0 = s and
B2: for i being Nat holds F1.(i+1)= U(i,F1.i) and
B3: F2.0 = s and
B4: for i being Nat holds F2.(i+1)= U(i,F2.i);
   reconsider s as Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
A1: F1.0 = s by B1;
A2: for i being Nat holds F1.(i+1)= V(i,F1.i) by B2;
A3: F2.0 = s by B3;
A4: for i being Nat holds F2.(i+1)= V(i,F2.i) by B4;
     F1 = F2 from NAT_1:sch 16(A1,A2,A3,A4);
   hence thesis;
  end;
end;

canceled 2;

theorem
  StepWhile>0(a,s,I).(k+1)=StepWhile>0(a,StepWhile>0(a,s,I).k,I).1
proof
  set sk=StepWhile>0(a,s,I).k;
  set sk0=StepWhile>0(a,sk,I).0;
  sk0=sk by Def1;
  hence
  StepWhile>0(a,s,I).(k+1) = Comput(ProgramPart((sk0 +* Initialized while>0(a,I
)
  )),(sk0 +* Initialized while>0(a,I)
  ), (LifeSpan (sk0 +* Initialized I) + 3)) by Def1
    .=StepWhile>0(a,sk,I).(0+1) by Def1
    .=StepWhile>0(a,sk,I).1;
end;

theorem Th26:
  for I being Program of SCM+FSA,a being read-write Int-Location,
  s being State of SCM+FSA holds StepWhile>0(a,s,I).(0+1)= Comput(ProgramPart(
(s +*
  Initialized while>0(a,I))), (s +*
  Initialized while>0(a,I)), (LifeSpan (s+* Initialized I) + 3))
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA;

X: StepWhile>0(a,s,I).0 = s by Def1;
thus StepWhile>0(a,s,I).(0+1)= Comput(ProgramPart( (StepWhile>0(a,s,I).0 +*
Initialized while>0(a,I))), (StepWhile>0(a,s,I).0 +*
Initialized while>0(a,I)),LifeSpan (StepWhile>0(a,s,I).0 +* Initialized I) + 3)
  by Def1
    .= Comput(ProgramPart( (s +* Initialized while>0(a,I))), (s +* Initialized
while>0(a,I)), (LifeSpan (StepWhile>0(
  a,s,I).0+* Initialized I) + 3)) by X
    .= Comput(ProgramPart( (s +* Initialized while>0(a,I))), (s +* Initialized
while>0(a,I)), (LifeSpan (s+*
  Initialized I) + 3)) by Def1;
end;

theorem Th27:
  for I be Program of SCM+FSA,a be read-write Int-Location, s be
  State of SCM+FSA,k,n be Element of NAT st IC StepWhile>0(a,s,I).k = 0 &
  StepWhile>0(a,s,I).k= Comput(ProgramPart( (s +* Initialized while>0(a,I))), (
s +* Initialized while>0(a,I)),n) &
StepWhile>0(a,s,I).k.intloc 0=1 holds StepWhile>0(a,s,I).k = StepWhile>0(a,s,I)
  .k +* Initialized while>0(a,I) & StepWhile>0(a,s,I).(k+1)= Comput(ProgramPart
( (s +*
Initialized while>0(a,I))), (s +*
Initialized while>0(a,I)), (n +(LifeSpan (StepWhile>0(a,s,I).k +* Initialized I
  ) + 3)))
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA,k,n be Element of NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  set s1 = s +* Initialized while>0(a,I);
  set sk=StepWhile>0(a,s,I).k, s0k=Initialize sk, At0=while>0(a,I) +* Start-At(
   0,SCM+FSA), s2=s0k +* At0, s3=sk +* Initialized while>0(a,I);
  assume
A1: IC sk = 0;
A2: IC SCM+FSA in dom At0 by SF_MASTR:65;
A3: IC s3 = s2.IC SCM+FSA by SCMFSA8A:13
    .= At0.IC SCM+FSA by A2,FUNCT_4:14
    .= IC sk by A1,SF_MASTR:66;
  assume
A4: sk = Comput(ProgramPart(s1),s1,n);
  then sk | NAT =s1 | NAT by AMI_1:123;
  then
A5: s3 | NAT = sk | NAT by FUNCT_4:100;
  assume
A6: sk.intloc 0=1;
T: ProgramPart s1 = ProgramPart sk
by A4,AMI_1:144;
  DataPart s3 = DataPart s2 by SCMFSA8A:13
    .= DataPart s0k by SCMFSA8A:11
    .= DataPart sk by A1,A6,SCMFSA8C:14;
  hence s3=sk by A3,A5,SCMFSA_9:29;
  hence
  StepWhile>0(a,s,I).(k+1)= Comput(ProgramPart( s1), sk,LifeSpan (sk +*
Initialized I
  ) + 3) by Def1,T
    .= Comput(ProgramPart( s1), s1,n +(LifeSpan (sk +* Initialized I) + 3)) by
A4,AMI_1:51;
end;

theorem
  for I be Program of SCM+FSA,a be read-write Int-Location, s be State
of SCM+FSA st ex f being Function of product the Object-Kind of SCM+FSA,NAT st
  (for k being Element of NAT holds ( f.(StepWhile>0(a,s,I).k) <> 0 implies f.(
  StepWhile>0(a,s,I).(k+1)) < f.(StepWhile>0(a,s,I).k) & I is_closed_onInit
StepWhile>0(a,s,I).k & I is_halting_onInit StepWhile>0(a,s,I).k) & (StepWhile>0
(a,s,I).(k+1)).intloc 0=1 & ( f.(StepWhile>0(a,s,I).k)=0 iff (StepWhile>0(a,s,I
  ).k).a <= 0 ) ) holds while>0(a,I) is_halting_onInit s & while>0(a,I)
  is_closed_onInit s
proof
  let I be Program of SCM+FSA,a be read-write Int-Location,s be State of
  SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  given f be Function of product the Object-Kind of SCM+FSA,NAT such that
A1: for k be Element of NAT holds (f.(StepWhile>0(a,s,I).k) <> 0 implies
  f.(StepWhile>0(a,s,I).(k+1)) < f.(StepWhile>0(a,s,I).k) & I is_closed_onInit
StepWhile>0(a,s,I).k & I is_halting_onInit StepWhile>0(a,s,I).k) & (StepWhile>0
(a,s,I).(k+1)).intloc 0=1 & ( f.(StepWhile>0(a,s,I).k)=0 iff (StepWhile>0(a,s,I
  ).k).a <= 0);
  set IniI=Initialized I, Iwhile=Initialized while>0(a,I), s1 = s +* Iwhile;
A2: IC SCM+FSA in dom Iwhile by SCMFSA6A:24;
  deffunc F(Nat) = f.(StepWhile>0(a,s,I).$1);
A3: for k being Nat holds F(k+1) < F(k) or F(k) = 0
  proof
    let k be Nat;
    k in NAT by ORDINAL1:def 13;
    hence thesis by A1;
  end;
  consider m being Nat such that
A4: F(m)=0 and
A5: for n being Nat st F(n) =0 holds m <= n from NAT_1:sch 17(A3);
  reconsider m as Element of NAT by ORDINAL1:def 13;
  defpred P[Element of NAT] means $1+1 <= m implies ex k st StepWhile>0(a,s,I)
  .($1+1)= Comput(ProgramPart( s1), s1,k);
A6: P[ 0]
  proof
    assume
    0+1 <= m;
    take n=(LifeSpan (s +* IniI) + 3);
    thus thesis by Th26;
  end;
A7: now
    let i be Element of NAT;
    assume
    i<m;
    then F(i)<>0 by A5;
    hence I is_closed_onInit StepWhile>0(a,s,I).i & I is_halting_onInit
    StepWhile>0(a,s,I).i by A1;
  end;
A8: now
    let k be Element of NAT;
    assume
A9: P[k];
    now
      set sk=StepWhile>0(a,s,I).k, sk1=StepWhile>0(a,s,I).(k+1);
      assume
A10:  (k+1)+ 1 <= m;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
      then consider n be Element of NAT such that
A11:  sk1 = Comput(ProgramPart(s1),s1,n) by A9,A10,XXREAL_0:2;
A12:  sk1.intloc 0=1 by A1;
      k + 0 < k+ (1+ 1) by XREAL_1:8;
      then
A13:  k < m by A10,XXREAL_0:2;
      then
A14:  I is_halting_onInit sk by A7;
      F(k) <> 0 by A5,A13;
      then
A15:  sk.a > 0 by A1;
      take m=n +(LifeSpan (sk1 +* IniI ) + 3);
A16:  sk1= Comput(ProgramPart( (sk +* Iwhile)), (sk +* Iwhile),LifeSpan (sk +*
IniI ) + 3) by Def1;
      I is_closed_onInit sk by A7,A13;
      then IC sk1 = 0 by A16,A14,A15,Th19;
      hence StepWhile>0(a,s,I).(k+1+1)= Comput(ProgramPart( s1), s1,m) by A11
,A12,Th27;
    end;
    hence P[k+1];
  end;
A17: for k being Element of NAT holds P[k] from NAT_1:sch 1(A6,A8);
  now
    per cases;
    suppose
      m=0;
      then (StepWhile>0(a,s,I).0).a <= 0 by A1,A4;
      then s.a <= 0 by Def1;
      hence thesis by Th16;
    end;
    suppose
A18:  m<>0;
      then consider i being Nat such that
A19:  m=i+1 by NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      set si=StepWhile>0(a,s,I).i, sm=StepWhile>0(a,s,I).m, sm1=sm +* Iwhile,
      sm2=sm +*(while>0(a,I) +* Start-At( 0,SCM+FSA));
A20:  i<m by A19,XREAL_1:31;
      then
A21:  I is_closed_onInit si by A7;
      i < m by A19,NAT_1:13;
      then F(i) <> 0 by A5;
      then
A22:  si.a > 0 by A1;
A23:  I is_halting_onInit si by A7,A20;
      sm= Comput(ProgramPart( (si +* Iwhile)), (si +* Iwhile), (LifeSpan (si +*
IniI) + 3)) by A19,Def1
;
      then
A24:  IC sm = 0 by A21,A23,A22,Th19;
      StepWhile>0(a,s,I).(i+1).intloc 0 = 1 by A1;
      then
A25:  sm1=sm2 by A19,SCMFSA8C:18;
      then
A26:  IC sm2 = Iwhile.IC SCM+FSA by A2,FUNCT_4:14
        .= IC sm by A24,SCMFSA6A:46;
      set p=(LifeSpan (s+* IniI) + 3);
A27:  DataPart sm2 = DataPart sm by SCMFSA8A:11;
      m=i+1 by A19;
      then consider n being Element of NAT such that
A28:  sm = Comput(ProgramPart(s1),s1,n) by A17;
      sm | NAT =s1 | NAT by A28,AMI_1:123;
      then sm2 | NAT = sm | NAT by A25,FUNCT_4:100;
      then
A29:  sm1=sm by A25,A26,A27,SCMFSA_9:29;
A30:  sm.a <= 0 by A1,A4;
      then while>0(a,I) is_halting_onInit sm by Th16;
      then ProgramPart sm1 halts_on sm1 by SCM_HALT:def 5;
      then consider j being Element of NAT such that
A31:  CurInstr(ProgramPart Comput(ProgramPart(sm),sm,j),Comput(ProgramPart(sm),
sm,j))
 = halt SCM+FSA by A29,AMI_1:146;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),
s1,n)
by AMI_1:144;
x: Comput(ProgramPart(s1),s1,j+n)
 = Comput(ProgramPart(s1),Comput(ProgramPart(s1),s1,n),j) by AMI_1:51;
      CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n+j),Comput(ProgramPart(s1
),s1,n+j))
       = halt SCM+FSA by A28,A31,x,T;
      then ProgramPart s1 halts_on s1 by AMI_1:146;
      hence while>0(a,I) is_halting_onInit s by SCM_HALT:def 5;
      now
        let q be Element of NAT;
        per cases;
        suppose
A32:      q <= p;
A33:      StepWhile>0(a,s,I).0=s by Def1;
          then
A34:      I is_halting_onInit s by A7,A18;
          F(0) <> 0 by A5,A18;
          then
A35:      s.a > 0 by A1,A33;
          I is_closed_onInit s by A7,A18,A33;
          hence IC Comput(ProgramPart( s1), s1,q) in dom while>0(a,I) by A32
,A35,A34,Th19;
        end;
        suppose
A36:      q > p;
A37:      now
            take k=p;
            thus StepWhile>0(a,s,I).1= Comput(ProgramPart( s1), s1,k) & k <= q
by A36,Th26;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 & (ex k st StepWhile>0(a,s,I).$1
          = Comput(ProgramPart( s1), s1,k) & k <= q);
A38:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A18,XREAL_1:8;
          then 1 <= m by NAT_1:13;
          then
A39:      ex t being Nat st P2[t] by A37;
          consider t being Nat such that
A40:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A38,A39);
          reconsider t as Element of NAT by ORDINAL1:def 13;
          now
            per cases;
            suppose
              t=m;
              then consider r being Element of NAT such that
A41:          sm= Comput(ProgramPart( s1), s1,r) and
A42:          r <= q by A40;
              consider x being Nat such that
A43:          q = r+x by A42,NAT_1:10;
A44:          while>0(a,I) is_closed_onInit sm by A30,Th16;
              reconsider x as Element of NAT by ORDINAL1:def 13;
T: ProgramPart s1 = ProgramPart sm1
by A29,A41,AMI_1:144;
              Comput(ProgramPart( s1), s1,q) = Comput(ProgramPart( s1), sm1,x)
by A29,A41,A43,AMI_1:51;
              hence IC Comput(ProgramPart( s1), s1,q) in dom while>0(a,I) by
A44,T,SCM_HALT:def 4;
            end;
            suppose
A45:          t<>m;
              set Dt=StepWhile>0(a,s,I).t;
A46:          t < m by A40,A45,XXREAL_0:1;
              then
A47:          I is_closed_onInit Dt by A7;
A48:          I is_halting_onInit Dt by A7,A46;
              consider y being Nat such that
A49:          t=y+1 by A40,NAT_1:6;
              reconsider y as Element of NAT by ORDINAL1:def 13;
              t=y+1 by A49;
              then
A50:          StepWhile>0(a,s,I).t.intloc 0=1 by A1;
              F(t) <> 0 by A5,A46;
              then
A51:          Dt.a > 0 by A1;
              consider z being Element of NAT such that
A52:          StepWhile>0(a,s,I).t= Comput(ProgramPart( s1), s1,z) and
A53:          z <= q by A40;
              set z2=z +(LifeSpan (Dt +* IniI) + 3);
              consider w be Nat such that
A54:          q = z+w by A53,NAT_1:10;
              set Dy=StepWhile>0(a,s,I).y;
              y+ 0 < t by A49,XREAL_1:8;
              then
A55:          y < m by A40,XXREAL_0:2;
              then
A56:          I is_closed_onInit Dy by A7;
              F(y) <> 0 by A5,A55;
              then
A57:          Dy.a > 0 by A1;
A58:          I is_halting_onInit Dy by A7,A55;
              reconsider w as Element of NAT by ORDINAL1:def 13;
              Dt= Comput(ProgramPart( (Dy +* Iwhile)), (Dy +* Iwhile), (
LifeSpan (Dy +* IniI) + 3
              )) by A49,Def1;
              then
A59:          IC Dt = 0 by A56,A58,A57,Th19;
X: Dt = Dt +* Iwhile by A50,A52,A59,Th27;
              now
                assume
A60:            z2 <= q;
A61:            now
                  take k=z2;
                  thus StepWhile>0(a,s,I).(t+1)= Comput(ProgramPart( s1), s1,k)
& k <= q
by A50,A52,A59,A60,Th27;
                end;
                t+1 <= m by A46,NAT_1:13;
                hence contradiction by A40,A61,XREAL_1:31;
              end;
              then
A62:          w < LifeSpan (Dt +* IniI) + 3 by A54,XREAL_1:8;
T: ProgramPart s1 = ProgramPart Dt
by A52,A54,AMI_1:144;
              Comput(ProgramPart( s1), s1,q) = Comput(ProgramPart(s1),Dt,w) by
A52,A54,AMI_1:51
                .= Comput(ProgramPart( (Dt +* Iwhile)), (Dt +* Iwhile),w) by X
,T;
              hence IC Comput(ProgramPart( s1), s1,q) in dom while>0(a,I) by
A62,A47,A48,A51,Th19;
            end;
          end;
          hence IC Comput(ProgramPart( s1), s1,q) in dom while>0(a,I);
        end;
      end;
      hence while>0(a,I) is_closed_onInit s by SCM_HALT:def 4;
    end;
  end;
  hence thesis;
end;

theorem Th29:
  for I be good InitHalting Program of SCM+FSA,a be read-write
Int-Location st (for s be State of SCM+FSA holds (s.a > 0 implies IExec(I, s).a
  < s.a )) holds while>0(a,I) is InitHalting
proof
  let I be good InitHalting Program of SCM+FSA,a be read-write Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  defpred P[Element of NAT] means for t be State of SCM+FSA st t.a <= $1 holds
  while>0(a,I) is_halting_onInit t;
  assume
A1: for s be State of SCM+FSA holds (s.a > 0 implies IExec(I, s).a < s.a
  );
A2: now
    let k be Element of NAT;
    assume
A3: P[k];
    now
      let t be State of SCM+FSA;
      assume
A4:   t.a <= k+1;
      per cases;
      suppose
        t.a<>k+1;
        then t.a < k+1 by A4,XXREAL_0:1;
        hence while>0(a,I) is_halting_onInit t by A3,INT_1:20;
      end;
      suppose
A5:     t.a=k+1;
        set l0=intloc 0;
        set Iwhile=Initialized while>0(a,I), tW0=t +* Iwhile, t1=t +*
Initialized I, Wt= Comput(ProgramPart( tW0), tW0,(LifeSpan t1)+ 3), A = NAT, It
= Comput(ProgramPart( t1), t1,LifeSpan t1);
A6:     I is_halting_onInit t by SCM_HALT:36;
        then
A7:     ProgramPart t1 halts_on t1 by SCM_HALT:def 5;
        not l0 in A by SCMFSA_2:84;
        then not l0 in dom t /\ A by XBOOLE_0:def 4;
        then
A8:     not l0 in dom (t | A) by RELAT_1:90;
A9:     I is_closed_onInit t by SCM_HALT:35;
        then
A10:    DataPart Wt = DataPart It by A5,A6,Th21;
        then
A11:    Wt.l0 =It.l0 by SCMFSA6A:38
          .=(Result t1).l0 by A7,AMI_1:122
          .=(Result t1 +* t | A).l0 by A8,FUNCT_4:12
          .=IExec(I,t).l0 by SCMFSA6B:def 1
          .=1 by SCM_HALT:17;
        not a in A by SCMFSA_2:84;
        then not a in dom t /\ A by XBOOLE_0:def 4;
        then
A12:    not a in dom (t | A) by RELAT_1:90;
A13:    while>0(a,I) c= Iwhile by SCMFSA6A:26;
        Iwhile c= tW0 by FUNCT_4:26;
        then while>0(a,I) c= tW0 by A13,XBOOLE_1:1;
        then while>0(a,I) c= Wt by AMI_1:81;
        then
A14:    Wt +* while>0(a,I) = Wt by FUNCT_4:79;
        Wt.a =It.a by A10,SCMFSA6A:38
          .=(Result t1).a by A7,AMI_1:122
          .=(Result t1 +* t | A).a by A12,FUNCT_4:12
          .=IExec(I,t).a by SCMFSA6B:def 1;
        then Wt.a < k+1 by A1,A5;
        then while>0(a,I) is_halting_onInit Wt by A3,INT_1:20;
        then
A15:    ProgramPart(Wt+*Iwhile) halts_on Wt+*Iwhile by SCM_HALT:def 5;
        IC Wt= 0 by A5,A9,A6,Th21;
        then
A16:    Wt +* Iwhile = Wt by A11,A14,Th6;
        now
          consider m be Element of NAT such that
A17:      CurInstr(ProgramPart Comput(ProgramPart(Wt),Wt,m),Comput(ProgramPart(
Wt),Wt,m))
 = halt SCM+FSA by A16,A15,AMI_1:146;
          take mm=((LifeSpan t1)+ 3)+m;
T: ProgramPart tW0 = ProgramPart Comput(ProgramPart(tW0),tW0,LifeSpan t1+3)
by AMI_1:144;
x: Comput(ProgramPart(tW0),tW0,(LifeSpan t1)+ 3+m)
 = Comput(ProgramPart(tW0),Comput(
ProgramPart(tW0),tW0,LifeSpan t1+3), m) by AMI_1:51;
          thus CurInstr(ProgramPart Comput(ProgramPart(tW0),tW0,mm),Comput(
ProgramPart(tW0),tW0,mm))
           = halt SCM+FSA by A17,x,T;
        end;
        then ProgramPart tW0 halts_on tW0 by AMI_1:146;
        hence while>0(a,I) is_halting_onInit t by SCM_HALT:def 5;
      end;
    end;
    hence P[k+1];
  end;
A18: P[ 0] by Th16;
A19: for k be Element of NAT holds P[k] from NAT_1:sch 1(A18,A2);
  now
    let t be State of SCM+FSA;
    per cases;
    suppose
      t.a<=0;
      hence while>0(a,I) is_halting_onInit t by Th16;
    end;
    suppose
      t.a>0;
      then reconsider n=t.a as Element of NAT by INT_1:16;
      P[n] by A19;
      hence while>0(a,I) is_halting_onInit t;
    end;
  end;
  hence thesis by SCM_HALT:36;
end;

theorem Th30:
  for I be good InitHalting Program of SCM+FSA,a be read-write
Int-Location st (for s be State of SCM+FSA holds IExec(I, s).a < s.a or IExec(I
  , s).a <= 0) holds while>0(a,I) is InitHalting
proof
  let I be good InitHalting Program of SCM+FSA,a be read-write Int-Location;
  assume
A1: for s be State of SCM+FSA holds IExec(I, s).a < s.a or IExec(I, s).a
  <= 0;
  now
    let t be State of SCM+FSA;
    assume
A2: t.a > 0;
    per cases by A1;
    suppose
      IExec(I, t).a < t.a;
      hence IExec(I, t).a < t.a;
    end;
    suppose
      IExec(I, t).a <= 0;
      hence IExec(I, t).a < t.a by A2;
    end;
  end;
  hence thesis by Th29;
end;

theorem
  for I be good InitHalting Program of SCM+FSA,a be read-write
Int-Location st ex f being Function of (product the Object-Kind of SCM+FSA),INT
st (for s,t be State of SCM+FSA holds (f.s > 0 implies f.IExec(I, s) < f.s ) &
  (DataPart s = DataPart t implies f.s=f.t) & ( f.s <= 0 iff s.a <= 0 ) ) holds
  while>0(a,I) is InitHalting
proof
  let I be good InitHalting Program of SCM+FSA,a be read-write Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  given f be Function of product the Object-Kind of SCM+FSA,INT such that
A1: for s,t be State of SCM+FSA holds (f.s > 0 implies f.IExec(I, s) < f
  .s ) & (DataPart s=DataPart t implies f.s=f.t) & ( f.s <= 0 iff s.a <= 0 );
  defpred P[Element of NAT] means for t be State of SCM+FSA st f.t <= $1 holds
  while>0(a,I) is_halting_onInit t;
A2: now
    let k be Element of NAT;
    assume
A3: P[k];
    now
      let t be State of SCM+FSA;
      assume
A4:   f.t <= k+1;
      per cases;
      suppose
        f.t<>k+1;
        then f.t < k+1 by A4,XXREAL_0:1;
        hence while>0(a,I) is_halting_onInit t by A3,INT_1:20;
      end;
      suppose
A5:     f.t=k+1;
        set l0=intloc 0;
        set Iwhile=Initialized while>0(a,I), tW0=t +* Iwhile, t1=t +*
Initialized I, Wt= Comput(ProgramPart( tW0), tW0,(LifeSpan t1)+ 3), A = NAT, It
= Comput(ProgramPart( t1), t1,LifeSpan t1);
A6:     I is_closed_onInit t by SCM_HALT:35;
A7:     while>0(a,I) c= Iwhile by SCMFSA6A:26;
        Iwhile c= tW0 by FUNCT_4:26;
        then while>0(a,I) c= tW0 by A7,XBOOLE_1:1;
        then while>0(a,I) c= Wt by AMI_1:81;
        then
A8:     Wt +* while>0(a,I) = Wt by FUNCT_4:79;
        not l0 in A by SCMFSA_2:84;
        then not l0 in dom t /\ A by XBOOLE_0:def 4;
        then
A9:     not l0 in dom (t | A) by RELAT_1:90;
A10:    I is_halting_onInit t by SCM_HALT:36;
        then
A11:    ProgramPart t1 halts_on t1 by SCM_HALT:def 5;
A12:    not t.a <= 0 by A1,A5;
        then
A13:    DataPart Wt = DataPart It by A6,A10,Th21;
        then
A14:    Wt.l0 =It.l0 by SCMFSA6A:38
          .=(Result t1).l0 by A11,AMI_1:122
          .=(Result t1 +* t | A).l0 by A9,FUNCT_4:12
          .=IExec(I,t).l0 by SCMFSA6B:def 1
          .=1 by SCM_HALT:17;
        DataPart Wt = DataPart Result t1 by A13,A11,AMI_1:122
          .= DataPart(Result t1 +* t | A) by SCMFSA8C:35
          .= DataPart IExec(I,t) by SCMFSA6B:def 1;
        then f.Wt=f.IExec(I,t) by A1;
        then f.Wt < k+1 by A1,A5;
        then while>0(a,I) is_halting_onInit Wt by A3,INT_1:20;
        then
A15:    ProgramPart(Wt+*Iwhile) halts_on Wt+*Iwhile by SCM_HALT:def 5;
        IC Wt= 0 by A12,A6,A10,Th21;
        then
A16:    Wt +* Iwhile = Wt by A14,A8,Th6;
        now
          consider m be Element of NAT such that
A17:      CurInstr(ProgramPart Comput(ProgramPart(Wt),Wt,m),Comput(ProgramPart(
Wt),Wt,m))
 = halt SCM+FSA by A16,A15,AMI_1:146;
T: ProgramPart tW0 = ProgramPart Comput(ProgramPart(tW0),tW0,LifeSpan t1+ 3)
by AMI_1:144;
x: Comput(ProgramPart(tW0),tW0,((LifeSpan t1)+ 3)+m)
 = Comput(ProgramPart(tW0),Comput(
ProgramPart(tW0),tW0,LifeSpan t1+ 3),m) by AMI_1:51;
          take mm=((LifeSpan t1)+ 3)+m;
          thus CurInstr(ProgramPart Comput(ProgramPart(tW0),tW0,mm),Comput(
ProgramPart(tW0),tW0,mm))
           = halt SCM+FSA by A17,x,T;
        end;
        then ProgramPart tW0 halts_on tW0 by AMI_1:146;
        hence while>0(a,I) is_halting_onInit t by SCM_HALT:def 5;
      end;
    end;
    hence P[k+1];
  end;
A18: P[ 0]
  proof
    let t be State of SCM+FSA;
    assume
    f.t <= 0;
    then t.a <= 0 by A1;
    hence thesis by Th16;
  end;
A19: for k be Element of NAT holds P[k] from NAT_1:sch 1(A18,A2);
  now
    let t be State of SCM+FSA;
    per cases;
    suppose
      f.t<=0;
      then t.a <= 0 by A1;
      hence while>0(a,I) is_halting_onInit t by Th16;
    end;
    suppose
      f.t>0;
      then reconsider n=f.t as Element of NAT by INT_1:16;
      P[n] by A19;
      hence while>0(a,I) is_halting_onInit t;
    end;
  end;
  hence thesis by SCM_HALT:36;
end;

theorem Th32:
  for s be State of SCM+FSA, I be Program of SCM+FSA, a be
  read-write Int-Location st s.a <= 0 holds DataPart IExec(while>0(a,I),s) =
  DataPart Initialize s
proof
  set A = NAT;
  let s be State of SCM+FSA, I be Program of SCM+FSA, a be read-write
  Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  set Is=Initialize s;
  set s1 = Is +* (while>0(a,I) +* Start-At( 0,SCM+FSA));
  set s2 = Comput(ProgramPart( s1), s1,1);
  set s3 = Comput(ProgramPart(s1),s1,2);
  set s4 = Comput(ProgramPart(s1),s1,3);
  set s5 = Comput(ProgramPart(s1),s1,4);
  set i = a >0_goto  4;
A1:  1 in dom while>0(a,I) by SCMFSA_9:10;
  while>0(a,I) c= while>0(a,I) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A2: dom while>0(a,I) c= dom (while>0(a,I) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
A3: Comput(ProgramPart(s1),s1,1). 1 = s1. 1 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)). 1
    by A2,A1,FUNCT_4:14
    .= while>0(a,I). 1 by A1,SCMFSA6B:7
    .= goto  2 by SCMFSA_9:11;
  IC SCM+FSA in dom (while>0(a,I) +* Start-At( 0,SCM+FSA))
  by SF_MASTR:65;
  then
A4: IC s1 = (while>0(a,I) +* Start-At( 0,SCM+FSA)).IC SCM+FSA
by FUNCT_4:14
    .=  0 by SF_MASTR:66;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by AMI_1:150;
A5:  0 in dom while>0(a,I) by SCMFSA_9:10;
  then
A6: s1. 0 = (while>0(a,I) +* Start-At( 0,SCM+FSA)). 0
by A2,FUNCT_4:14
    .= while>0(a,I). 0 by A5,SCMFSA6B:7
    .= i by SCMFSA_9:11;
  then
A7: CurInstr(ProgramPart s1,s1) = i by A4,Y;
A8: Comput(ProgramPart( s1), s1,0 + 1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,0)
)
 by AMI_1:14
    .= Following(ProgramPart s1,s1) by AMI_1:13
    .= Exec(i,s1) by A4,A6,Y;
  set loc5=  (card I +5);
A9:  2 in dom while>0(a,I) by SCMFSA_9:37;
A10: s3. 2 = s1. 2 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)). 2
    by A2,A9,FUNCT_4:14
    .= while>0(a,I). 2 by A9,SCMFSA6B:7
    .= goto  3 by SCMFSA_9:41;
A11: IC Is =  0 by SCMFSA6C:3;
A12: loc5 in dom while>0(a,I) by SCMFSA_9:38;
  not a in dom (while>0(a,I) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  then
A13: s1.a = Is.a by FUNCT_4:12;
A14:  3 in dom while>0(a,I) by SCMFSA_9:37;
  assume
  s.a <= 0;
  then Is.a <= 0 by SCMFSA6C:3;
  then
A15: IC Comput(ProgramPart(s1),s1,1) = succ  0 by A4,A8,A13,SCMFSA_2:97
    .=  (0 + 1);
Y:  (ProgramPart s2)/.IC s2
 = s2.IC s2 by AMI_1:150;
T: ProgramPart s1 = ProgramPart s2
by AMI_1:144;
A16: Comput(ProgramPart( s1), s1,1 + 1) = Following(ProgramPart s1,s2) by
AMI_1:14
    .= Exec(goto  2,s2) by A15,A3,Y,T;
  then
A17: IC s3 =  2 by SCMFSA_2:95;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
T: ProgramPart s1 = ProgramPart s3
by AMI_1:144;
A18: Comput(ProgramPart( s1), s1,2 + 1) = Following(ProgramPart s1,s3) by
AMI_1:14
    .= Exec(goto  3,s3) by A16,A10,Y,T,SCMFSA_2:95;
A19: s4. 3 = s1. 3 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)). 3
    by A2,A14,FUNCT_4:14
    .= while>0(a,I). 3 by A14,SCMFSA6B:7
    .= goto loc5 by SCMFSA_9:40;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
T: ProgramPart s1 = ProgramPart s4
by AMI_1:144;
A20: Comput(ProgramPart( s1), s1,3 + 1) = Following(ProgramPart s1,s4) by
AMI_1:14
    .= Exec(goto loc5,s4) by A18,A19,Y,T,SCMFSA_2:95;
Y:  (ProgramPart s5)/.IC s5
 = s5.IC s5 by AMI_1:150;
  s5.loc5 = s1.loc5 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)).loc5 by A2,A12,FUNCT_4:14
    .= while>0(a,I).loc5 by A12,SCMFSA6B:7
    .= halt SCM+FSA by SCMFSA_9:39;
  then
A21: CurInstr(ProgramPart s5,s5) = halt SCM+FSA by A20,Y,SCMFSA_2:95;
  then
A22: ProgramPart s1 halts_on s1 by AMI_1:146;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
A23: CurInstr(ProgramPart s4,s4) = goto loc5 by A18,A19,Y,SCMFSA_2:95;
  now
    let k be Element of NAT;
A24: goto loc5 <> halt SCM+FSA by SCMFSA_9:9;
u: Comput(ProgramPart(s1),s1,0) = s1 by AMI_1:13;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,k))/.IC Comput(ProgramPart(s1),s1,k)
 = Comput(ProgramPart(s1),s1,k).IC Comput(ProgramPart(s1),s1,k) by AMI_1:150;
    assume
A25: CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(ProgramPart(s1),
s1,k))
 = halt SCM+FSA;
    then
A26: k <> 2 by A17,A10,Y,SCMFSA_9:9;
    CurInstr(ProgramPart Comput(ProgramPart(s1),s1,0),Comput(ProgramPart(s1),s1
,0))
     = i by A7,u;
    then
A27: k <> 0 by A25,SCMFSA_9:8;
xx:    k <> 1 by A15,A3,A25,Y,SCMFSA_9:9;
    3<>k by A23,A25,A24;
    then 3<k by A27,A26,xx,NAT_1:28;
    hence 3+1<=k by INT_1:20;
  end;
  then
A28: LifeSpan s1 = 4 by A21,A22,AMI_1:def 46;
A29: Is +* Initialized while>0(a,I) = Initialize Is +* (while>0(a,I) +*
  Start-At( 0,SCM+FSA)) by SCMFSA8A:13
    .=s1 by SCMFSA8C:15;
  Is.intloc 0=1 by SCMFSA6C:3;
  then
A30: s1=Is+*while>0(a,I) by A29,A11,Th6;
A31: now
    let a be Int-Location;
    thus Is.a = s1.a by A30,AMI_1:120,SCMFSA6A:30
      .=s2.a by A8,SCMFSA_2:97
      .=s3.a by A16,SCMFSA_2:95
      .=s4.a by A18,SCMFSA_2:95
      .=s5.a by A20,SCMFSA_2:95;
  end;
A32: now
    let f be FinSeq-Location;
    thus Is.f = s1.f by A30,AMI_1:120,SCMFSA6A:31
      .=s2.f by A8,SCMFSA_2:97
      .=s3.f by A16,SCMFSA_2:95
      .=s4.f by A18,SCMFSA_2:95
      .=s5.f by A20,SCMFSA_2:95;
  end;
  thus DataPart IExec(while>0(a,I),s) = DataPart IExec(while>0(a,I),Is) by
SCMFSA8C:17
    .= DataPart(Result (Is +* Initialized while>0(a,I)) +* Is | A) by
SCMFSA6B:def 1
    .= DataPart(Result s1) by A29,SCMFSA8C:35
    .= DataPart s5 by A22,A28,AMI_1:122
    .= DataPart Is by A31,A32,SCMFSA6A:38;
end;

theorem Th33:
  for s be State of SCM+FSA, I be good InitHalting Program of
SCM+FSA, a be read-write Int-Location st s.a > 0 & while>0(a,I) is InitHalting
holds DataPart IExec(while>0(a,I),s) = DataPart IExec(while>0(a,I),IExec(I,s))
proof
  set A = NAT;
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, a be
  read-write Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  assume that
A1: s.a > 0 and
A2: while>0(a,I) is InitHalting;
  set ps = s | NAT, sI = s +* Initialized I, Iwhile= Initialized while>0(a,I),
sW = s +* Iwhile, s3 = Comput(ProgramPart( sI), sI,LifeSpan sI) +* Iwhile, m1 =
LifeSpan sI
  , m3 = LifeSpan s3;
A3: Iwhile c= sW by FUNCT_4:26;
  then
A4: ProgramPart sW halts_on sW by A2,AMI_1:def 26;
  set mW=LifeSpan sW;
A5: Iwhile c= s3 by FUNCT_4:26;
  then
A6: ProgramPart s3 halts_on s3 by A2,AMI_1:def 26;
A7: DataPart Comput(ProgramPart( Comput(ProgramPart(sW),sW,m1+3)), Comput(
ProgramPart(sW),sW,m1+3),m3+mW) = DataPart
  Comput(ProgramPart(s3),s3,m3)
  proof
    reconsider Wg=while>0(a,I) as good InitHalting Program of SCM+FSA by A2;
    set Cm3=Comput(ProgramPart(sW),sW,m1+3);
A8: I is_halting_onInit s by SCM_HALT:36;
A9: I is_closed_onInit s by SCM_HALT:35;
    then
A10: IC Cm3= 0 by A1,A8,Th21;
A11: DataPart Cm3 = DataPart Comput(ProgramPart(sI),sI,m1) by A1,A9,A8,Th21
      .= DataPart(Comput(ProgramPart(sI),sI,m1) +* while>0(a,I)) by SCMFSA8C:34
;
A12: now
      let f be FinSeq-Location;
A13:  not f in dom while>0(a,I) by Th13;
      not f in dom Iwhile by SCMFSA6A:49;
      hence s3.f = Comput(ProgramPart(sI),sI,m1).f by FUNCT_4:12
        .=(Comput(ProgramPart(sI),sI,m1) +* while>0(a,I)).f by A13,FUNCT_4:12
        .=Cm3.f by A11,SCMFSA6A:38;
    end;
    Wg is keepInt0_1;
    then
A14: Cm3.intloc 0 =1 by A3,SCM_HALT:def 3;
A15: now
      let b be Int-Location;
      per cases;
      suppose
A16:    b <> intloc 0;
A17:    not b in dom while>0(a,I) by Th14;
        not b in dom Iwhile by A16,SCMFSA6A:48;
        hence s3.b = Comput(ProgramPart(sI),sI,m1).b by FUNCT_4:12
          .=(Comput(ProgramPart(sI),sI,m1) +* while>0(a,I)).b by A17,FUNCT_4:12
          .=Cm3.b by A11,SCMFSA6A:38;
      end;
      suppose
        b = intloc 0;
        hence s3.b=Cm3.b by A14,FUNCT_4:26,SCM_HALT:7;
      end;
    end;
    while>0(a,I) c= Iwhile by SCMFSA6A:26;
    then while>0(a,I) c= sW by A3,XBOOLE_1:1;
    then while>0(a,I) c= Comput(ProgramPart(sW),sW,m1+3) by AMI_1:81;
    then Cm3 +* while>0(a,I) = Cm3 by FUNCT_4:79;
    then Cm3 +* Iwhile = Cm3 by A10,A14,Th6;
    then
A18: Iwhile c= Cm3 by FUNCT_4:26;
    then
A19: ProgramPart Cm3 halts_on Cm3 by A2,AMI_1:def 26;
    IC Cm3=IC s3 by A10,FUNCT_4:26,SCMFSA6B:34;
    then
A20: Cm3,s3 equal_outside A by A12,A15,SCMFSA6A:28;
    then LifeSpan Cm3 = m3 by A2,A5,A18,Th12;
    hence
    DataPart Comput(ProgramPart( Cm3), Cm3,m3+mW) = DataPart Comput(ProgramPart
( Cm3), Cm3,LifeSpan
    Cm3) by A19,AMI_1:128,NAT_1:11
      .= DataPart Result Cm3 by A19,AMI_1:122
      .= DataPart Result s3 by A2,A5,A18,A20,Th12,SCMFSA6A:39
      .= DataPart Comput(ProgramPart(s3),s3,m3) by A6,AMI_1:122;
  end;
  Initialized I c= sI by FUNCT_4:26;
  then
A21: ProgramPart sI halts_on sI by AMI_1:def 26;
A22: Iwhile c= IExec(I,s) +* Iwhile by FUNCT_4:26;
  Comput(ProgramPart(sI),sI,m1) +* Iwhile, Comput(ProgramPart(sI),sI,m1) +* ps
+* Iwhile
  equal_outside dom ps by FUNCT_7:31,106;
  then
A23: Comput(ProgramPart(sI),sI,m1) +* ps +* Iwhile, Comput(ProgramPart(sI),sI,
m1) +*Iwhile
  equal_outside dom ps by FUNCT_7:28;
A24: dom ps = dom s /\ A by RELAT_1:90
    .= (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} \/ A) /\ A by
SCMFSA6A:34
    .= A by XBOOLE_1:21;
  then
A25: dom ps misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  IExec(I,s) = Result (s +* Initialized I) +* ps by SCMFSA6B:def 1
    .= Comput(ProgramPart(sI),sI,m1) +* ps by A21,AMI_1:122;
  then
  Result (IExec(I,s) +* Iwhile),Result s3 equal_outside A by A2,A5,A24,A23,A22
,Th12;
  then
A26: Result (IExec(I,s) +* Iwhile) +* ps = Result s3 +* ps by A24,FUNCT_7:108;
  IExec(I,s) | A = (Result (s +* Initialized I) +* ps) | A by SCMFSA6B:def 1
    .= ps by PBOOLE:157;
  then
A27: IExec(while>0(a,I),IExec(I,s)) = Result (IExec(I,s) +* Iwhile) +* ps by
SCMFSA6B:def 1
    .= Comput(ProgramPart(s3),s3,m3) +* ps by A6,A26,AMI_1:122;
A28: mW <= (m1+3+m3) + mW by NAT_1:11;
T: ProgramPart sW = ProgramPart Comput(ProgramPart(sW),sW,m1+3)
by AMI_1:144;
  IExec(while>0(a,I),s) = Result (s +* Iwhile) +* ps by SCMFSA6B:def 1
    .= Comput(ProgramPart(sW),sW,mW) +* ps by A4,AMI_1:122
    .= Comput(ProgramPart(sW),sW,m1+3+(m3+mW)) +* ps by A4,A28,AMI_1:128;
  then DataPart IExec(while>0(a,I),s) = DataPart Comput(ProgramPart(sW),sW,m1+3
+(m3+mW))
  by A25,FUNCT_4:76,SCMFSA_2:127
    .= DataPart Comput(ProgramPart(s3),s3,m3) by A7,T,AMI_1:51
    .= DataPart IExec(while>0(a,I),IExec(I,s)) by A27,A25,FUNCT_4:76
,SCMFSA_2:127;
  hence
  DataPart IExec(while>0(a,I),s) = DataPart IExec(while>0(a,I),IExec(I, s
  ));
end;

theorem Th34:
  for s be State of SCM+FSA, I be Program of SCM+FSA, f be
FinSeq-Location,a be read-write Int-Location st s.a <= 0 holds IExec(while>0(a,
  I),s).f=s.f
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA, f be FinSeq-Location,a be
  read-write Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  assume
A1: s.a <= 0;
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A2: f in D by XBOOLE_0:def 3;
  hence IExec(while>0(a,I),s).f =(DataPart IExec(while>0(a,I),s)).f by
FUNCT_1:72,SCMFSA_2:127
    .= (DataPart Initialize s).f by A1,Th32
    .= (Initialize s).f by A2,FUNCT_1:72,SCMFSA_2:127
    .= s.f by SCMFSA6C:3;
end;

theorem Th35:
  for s be State of SCM+FSA, I be Program of SCM+FSA, b be
Int-Location,a be read-write Int-Location st s.a <= 0 holds IExec(while>0(a,I),
  s).b=(Initialize s).b
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA, b be Int-Location,a be
  read-write Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  assume
A1: s.a <= 0;
  b in Int-Locations by SCMFSA_2:9;
  then
A2: b in D by XBOOLE_0:def 3;
  hence IExec(while>0(a,I),s).b =(DataPart IExec(while>0(a,I),s)).b by
FUNCT_1:72,SCMFSA_2:127
    .= (DataPart Initialize s).b by A1,Th32
    .= (Initialize s).b by A2,FUNCT_1:72,SCMFSA_2:127;
end;

theorem Th36:
  for s be State of SCM+FSA, I be good InitHalting Program of
SCM+FSA, f be FinSeq-Location,a be read-write Int-Location st s.a > 0 & while>0
(a,I) is InitHalting holds IExec(while>0(a,I),s).f =IExec(while>0(a,I),IExec(I,
  s)).f
proof
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, f be
  FinSeq-Location,a be read-write Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  assume that
A1: s.a > 0 and
A2: while>0(a,I) is InitHalting;
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A3: f in D by XBOOLE_0:def 3;
  then IExec(while>0(a,I),s).f =(DataPart IExec(while>0(a,I),s)).f by
FUNCT_1:72,SCMFSA_2:127
    .=(DataPart IExec(while>0(a,I),IExec(I,s))).f by A1,A2,Th33;
  hence thesis by A3,FUNCT_1:72,SCMFSA_2:127;
end;

theorem Th37:
  for s be State of SCM+FSA, I be good InitHalting Program of
SCM+FSA, b be Int-Location,a be read-write Int-Location st s.a > 0 & while>0(a,
I) is InitHalting holds IExec(while>0(a,I),s).b =IExec(while>0(a,I),IExec(I,s))
  .b
proof
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, b be
  Int-Location,a be read-write Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  assume that
A1: s.a > 0 and
A2: while>0(a,I) is InitHalting;
  b in Int-Locations by SCMFSA_2:9;
  then
A3: b in D by XBOOLE_0:def 3;
  then IExec(while>0(a,I),s).b =(DataPart IExec(while>0(a,I),s)).b by
FUNCT_1:72,SCMFSA_2:127
    .=(DataPart IExec(while>0(a,I),IExec(I,s))).b by A1,A2,Th33;
  hence thesis by A3,FUNCT_1:72,SCMFSA_2:127;
end;

begin   ::  - Insert Sort Algorithm -
set a0 = intloc 0;
set a1 = intloc 1;
set a2 = intloc 2;
set a3 = intloc 3;
set a4 = intloc 4;
set a5 = intloc 5;
set a6 = intloc 6;

set initializeWorkMem = ((intloc 2):= intloc 0) ';' ((intloc 3):= intloc 0)
';' ((intloc 4):= intloc 0) ';' ((intloc 5):= intloc 0) ';' ((intloc 6):=
intloc 0);

definition
  let f be FinSeq-Location;
  func insert-sort f -> Program of SCM+FSA equals
  (((intloc 2):= intloc 0) ';'
((intloc 3):= intloc 0) ';' ((intloc 4):= intloc 0) ';' ((intloc 5):= intloc 0)
  ';' ((intloc 6):= intloc 0)) ';' ((intloc 1):=len f) ';' SubFrom(intloc 1,
intloc 0) ';' Times(intloc 1, (((intloc 2):=len f) ';' SubFrom(intloc 2,intloc
1) ';' ((intloc 3) := intloc 2) ';' AddTo(intloc 3,intloc 0) ';' ((intloc 6):=(
f,intloc 3)) ';' SubFrom(intloc 4,intloc 4)) ';' while>0(intloc 2, ((intloc 5)
:=(f,intloc 2)) ';' SubFrom(intloc 5,intloc 6) ';' if>0(intloc 5,Macro SubFrom(
intloc 2,intloc 2), AddTo(intloc 4,intloc 0) ';' SubFrom(intloc 2,intloc 0)) )
';' Times(intloc 4, ((intloc 2):=intloc 3) ';' SubFrom(intloc 3,intloc 0) ';' (
  (intloc 5):=(f,intloc 2)) ';' ((intloc 6):=(f,intloc 3)) ';' ((f,intloc 2):=
  intloc 6) ';'((f,intloc 3):=intloc 5) ) );
  coherence;
end;

definition
  func Insert-Sort-Algorithm -> Program of SCM+FSA equals
  insert-sort fsloc 0;
  coherence;
end;

theorem Th38:
  for f being FinSeq-Location holds UsedIntLoc (insert-sort f) = {
  intloc 0,intloc 1,intloc 2,intloc 3,intloc 4,intloc 5,intloc 6}
proof
  set m0=SubFrom(a2,a2), m1=Macro m0, m2=AddTo(a4,a0), m3=SubFrom(a2,a0), IF=
  if>0(a5, m1, m2 ';' m3), UIF = UsedIntLoc IF;
  set k2= a2:= a0, k3= a3:= a0, k4= a4:= a0, k5= a5:= a0;
  let f be FinSeq-Location;
  set i1= a2:=a3, i2= SubFrom(a3,a0), i3= a5:=(f,a2), i4= a6:=(f,a3), i5= (f,
  a2):=a6, i6= (f,a3):=a5, body3= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' i6, Ui123=
  UsedIntLoc (i1 ';' i2 ';'i3 ), Ui12=UsedIntLoc (i1 ';' i2 ), Ub3=UsedIntLoc
  body3;
A1: Ub3 = (UsedIntLoc (i1 ';' i2 ';'i3 ';'i4 ';' i5 )) \/ UsedIntLoc i6 by
SF_MASTR:34
    .= (UsedIntLoc (i1 ';' i2 ';'i3 ';'i4 ';' i5 )) \/ {a3,a5} by SF_MASTR:21
    .= (UsedIntLoc (i1 ';' i2 ';'i3 ';' i4)) \/ (UsedIntLoc i5) \/ {a3,a5}
  by SF_MASTR:34
    .= (UsedIntLoc (i1 ';' i2 ';'i3 ';' i4)) \/ {a2,a6} \/ {a3,a5} by
SF_MASTR:21
    .= Ui123 \/ (UsedIntLoc i4) \/ {a2,a6} \/ {a3,a5} by SF_MASTR:34
    .= Ui123 \/ {a6,a3} \/ {a2,a6} \/ {a3,a5} by SF_MASTR:21
    .= Ui123 \/ ({a6,a3} \/ {a2,a6}) \/ {a3,a5} by XBOOLE_1:4
    .= Ui123 \/ {a6,a3,a2,a6} \/ {a3,a5} by ENUMSET1:45
    .= Ui123 \/ {a6,a6,a2,a3} \/ {a3,a5} by ENUMSET1:107
    .= Ui123 \/ {a6,a2,a3} \/ {a3,a5} by ENUMSET1:71
    .= Ui123 \/ ({a6,a2} \/ {a3}) \/ {a3,a5} by ENUMSET1:43
    .= Ui123 \/ {a6,a2} \/ {a3} \/ {a3,a5} by XBOOLE_1:4
    .= Ui123 \/ {a6,a2} \/ ({a3} \/ {a3,a5}) by XBOOLE_1:4
    .= Ui123 \/ {a6,a2} \/ {a3,a3,a5} by ENUMSET1:42
    .= Ui123 \/ {a6,a2} \/ {a3,a5} by ENUMSET1:70
    .= Ui12 \/ (UsedIntLoc i3) \/ {a6,a2} \/ {a3,a5} by SF_MASTR:34
    .= Ui12 \/ {a5,a2} \/ {a6,a2} \/ {a3,a5} by SF_MASTR:21
    .= Ui12 \/ ({a5,a2} \/ {a6,a2}) \/ {a3,a5} by XBOOLE_1:4
    .= Ui12 \/ {a5,a2,a6,a2} \/ {a3,a5} by ENUMSET1:45
    .= Ui12 \/ {a2,a2,a6,a5} \/ {a3,a5} by ENUMSET1:123
    .= Ui12 \/ {a2,a6,a5} \/ {a3,a5} by ENUMSET1:71
    .= Ui12 \/ ({a2,a6} \/ {a5}) \/ {a3,a5} by ENUMSET1:43
    .= Ui12 \/ {a2,a6} \/ {a5} \/ {a3,a5} by XBOOLE_1:4
    .= Ui12 \/ {a2,a6} \/ ({a5} \/ {a3,a5}) by XBOOLE_1:4
    .= Ui12 \/ {a2,a6} \/ {a5,a3,a5} by ENUMSET1:43
    .= Ui12 \/ {a2,a6} \/ {a5,a5,a3} by ENUMSET1:98
    .= Ui12 \/ {a2,a6} \/ {a5,a3} by ENUMSET1:70
    .= (UsedIntLoc i1) \/ (UsedIntLoc i2) \/ {a2,a6} \/ {a5,a3} by SF_MASTR:35
    .= {a2,a3} \/ (UsedIntLoc i2) \/ {a2,a6} \/ {a5,a3} by SF_MASTR:18
    .= {a2,a3} \/ {a3,a0} \/ {a2,a6} \/ {a5,a3} by SF_MASTR:18
    .= {a2,a3,a3,a0} \/ {a2,a6} \/ {a5,a3} by ENUMSET1:45
    .= {a3,a3,a2,a0} \/ {a2,a6} \/ {a5,a3} by ENUMSET1:116
    .= {a3,a2,a0} \/ {a2,a6} \/ {a5,a3} by ENUMSET1:71
    .= {a3} \/ {a2,a0} \/ {a2,a6} \/ {a5,a3} by ENUMSET1:42
    .= {a3} \/ ({a2,a0} \/ {a2,a6}) \/ {a5,a3} by XBOOLE_1:4
    .= {a3} \/ {a2,a0,a2,a6} \/ {a5,a3} by ENUMSET1:45
    .= {a3} \/ {a2,a2,a0,a6} \/ {a5,a3} by ENUMSET1:104
    .= {a3} \/ {a2,a0,a6} \/ {a5,a3} by ENUMSET1:71
    .= {a3} \/ {a5,a3} \/ {a2,a0,a6} by XBOOLE_1:4
    .= {a3,a5,a3} \/ {a2,a0,a6} by ENUMSET1:43
    .= {a3,a3,a5} \/ {a2,a0,a6} by ENUMSET1:98
    .= {a3,a5} \/ {a2,a0,a6} by ENUMSET1:70;
  set n1=a5:=(f,a2), n2=SubFrom(a5,a6), body2=n1 ';'n2 ';' IF, Ub2=UsedIntLoc
  body2;
A2: UIF = {a5} \/ UsedIntLoc (m1) \/ UsedIntLoc(m2 ';' m3) by SCMBSORT:29
    .= {a5} \/ UsedIntLoc m0 \/ UsedIntLoc(m2 ';' m3) by SF_MASTR:32
    .= {a5} \/ {a2,a2} \/ UsedIntLoc(m2 ';' m3) by SF_MASTR:18
    .= {a5} \/ {a2,a2} \/ (UsedIntLoc m2 \/ UsedIntLoc m3) by SF_MASTR:35
    .= {a5} \/ {a2,a2} \/ ({a4,a0} \/ UsedIntLoc m3) by SF_MASTR:18
    .= {a5} \/ {a2,a2} \/ ({a4,a0} \/ {a2,a0}) by SF_MASTR:18
    .= {a5} \/ {a2} \/ ({a4,a0} \/ {a2,a0}) by ENUMSET1:69
    .= {a5} \/ {a2} \/ {a2,a0} \/ {a4,a0} by XBOOLE_1:4
    .= {a2,a5} \/ {a2,a0} \/ {a4,a0} by ENUMSET1:41
    .= {a2,a5,a2,a0} \/ {a4,a0} by ENUMSET1:45
    .= {a2,a2,a5,a0} \/ {a4,a0} by ENUMSET1:104
    .= {a2,a5,a0} \/ {a4,a0} by ENUMSET1:71
    .= {a2,a5,a0,a4,a0} by ENUMSET1:49
    .= {a2} \/ {a5,a0,a4,a0} by ENUMSET1:47
    .= {a2} \/ {a0,a0,a4,a5} by ENUMSET1:123
    .= {a2} \/ {a0,a4,a5} by ENUMSET1:71
    .= {a2,a0,a4,a5} by ENUMSET1:44
    .= {a2,a5,a4,a0} by ENUMSET1:107
    .= {a2,a5} \/ {a4,a0} by ENUMSET1:45;
  set WM=initializeWorkMem, j1=a1:=len f, j2=SubFrom(a1,a0), Uj1= UsedIntLoc (
  WM ';' j1);
A3: UsedIntLoc initializeWorkMem = UsedIntLoc (k2 ';' k3 ';' k4 ';' k5) \/
  UsedIntLoc (a6:= a0) by SF_MASTR:34
    .= UsedIntLoc (k2 ';' k3 ';' k4 ';' k5) \/ {a6,a0} by SF_MASTR:18
    .= UsedIntLoc (k2 ';' k3 ';' k4 ) \/ UsedIntLoc k5 \/ {a6,a0} by
SF_MASTR:34
    .= UsedIntLoc (k2 ';' k3 ';' k4 ) \/ {a5,a0} \/ {a6,a0} by SF_MASTR:18
    .= UsedIntLoc (k2 ';' k3 ) \/ UsedIntLoc k4 \/ {a5,a0} \/ {a6,a0} by
SF_MASTR:34
    .= UsedIntLoc (k2 ';' k3 ) \/ {a4,a0} \/ {a5,a0} \/ {a6,a0} by SF_MASTR:18
    .= UsedIntLoc k2 \/ UsedIntLoc k3 \/ {a4,a0} \/ {a5,a0} \/ {a6,a0} by
SF_MASTR:35
    .= UsedIntLoc k2 \/ {a3,a0} \/ {a4,a0} \/ {a5,a0} \/ {a6,a0} by SF_MASTR:18
    .= {a2,a0} \/ {a3,a0} \/ {a4,a0} \/ {a5,a0} \/ {a6,a0} by SF_MASTR:18
    .= {a2,a0} \/ {a3,a0} \/ {a4,a0} \/ ({a5,a0} \/ {a6,a0}) by XBOOLE_1:4
    .= {a2,a0} \/ {a3,a0} \/ {a4,a0} \/ {a0,a5,a6} by ENUMSET1:137
    .= {a0,a2,a3} \/ {a4,a0} \/ {a0,a5,a6} by ENUMSET1:137
    .= {a0,a2,a3} \/ {a4,a0} \/ ({a0} \/ {a5,a6}) by ENUMSET1:42
    .= {a0,a2,a3} \/ {a4,a0} \/ {a0} \/ {a5,a6} by XBOOLE_1:4
    .= {a0,a2,a3} \/ ({a4,a0} \/ {a0}) \/ {a5,a6} by XBOOLE_1:4
    .= {a0,a2,a3} \/ {a4,a0,a0} \/ {a5,a6} by ENUMSET1:43
    .= {a0,a2,a3} \/ ({a0,a0} \/ {a4}) \/ {a5,a6} by ENUMSET1:42
    .= {a0,a2,a3} \/ {a0,a0} \/ {a4} \/ {a5,a6} by XBOOLE_1:4
    .= {a0,a0,a0,a2,a3} \/ {a4} \/ {a5,a6} by ENUMSET1:48
    .= {a0,a2,a3} \/ {a4} \/ {a5,a6} by ENUMSET1:78
    .= {a0,a2,a3,a4} \/ {a5,a6} by ENUMSET1:46
    .= {a0,a2,a3,a4,a5,a6} by ENUMSET1:54
    .= {a0} \/ {a2,a3,a4,a5,a6} by ENUMSET1:51;
  set T3=Times(a4,body3), t1=a2:=len f, t2=SubFrom(a2,a1), t3=a3 := a2, t4=
  AddTo(a3,a0), t5=a6:=(f,a3), t6=SubFrom(a4,a4), Wg=while>0(a2,body2), t16=t1
  ';' t2 ';' t3 ';' t4 ';' t5 ';' t6, body1=t16 ';' Wg ';' T3, Ub1 =UsedIntLoc
  body1, Ut16=UsedIntLoc t16;
A4: Ut16=UsedIntLoc (t1 ';' t2 ';' t3 ';' t4 ';' t5 ) \/ UsedIntLoc t6 by
SF_MASTR:34
    .=UsedIntLoc (t1 ';' t2 ';' t3 ';' t4 ';' t5 ) \/ {a4,a4} by SF_MASTR:18
    .=UsedIntLoc (t1 ';' t2 ';' t3 ';' t4) \/ UsedIntLoc t5 \/ {a4,a4} by
SF_MASTR:34
    .=UsedIntLoc (t1 ';' t2 ';' t3 ';' t4) \/ {a3,a6} \/ {a4,a4} by SF_MASTR:21
    .=UsedIntLoc (t1 ';' t2 ';' t3) \/ UsedIntLoc t4 \/ {a3,a6} \/ {a4,a4}
  by SF_MASTR:34
    .=UsedIntLoc (t1 ';' t2 ';' t3) \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by
SF_MASTR:18
    .=UsedIntLoc (t1 ';' t2) \/ UsedIntLoc t3 \/ {a3,a0} \/ {a3,a6} \/ {a4,
  a4} by SF_MASTR:34
    .=UsedIntLoc (t1 ';' t2) \/ {a3,a2} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by
SF_MASTR:18
    .=UsedIntLoc t1 \/ UsedIntLoc t2 \/ {a3,a2} \/ {a3,a0} \/ {a3,a6} \/ {a4
  ,a4} by SF_MASTR:35
    .={a2} \/ UsedIntLoc t2 \/ {a3,a2} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by
SF_MASTR:22
    .={a2} \/ {a2,a1} \/ {a3,a2} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by
SF_MASTR:18
    .={a2,a2,a1} \/ {a3,a2} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:42
    .={a2,a1} \/ {a3,a2} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:70
    .={a2,a1,a3,a2} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:45
    .={a2,a2,a3,a1} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:107
    .={a2,a3,a1} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:71
    .={a2,a3,a1,a3,a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:49
    .={a2,a3,a1,a3} \/ {a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:50
    .={a3,a3,a1,a2} \/ {a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:123
    .={a3,a1,a2} \/ {a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:71
    .={a3,a1,a2} \/ {a0} \/ {a3,a6} \/ {a4} by ENUMSET1:69
    .={a3,a1,a2} \/ {a3,a6} \/ {a0} \/ {a4} by XBOOLE_1:4
    .={a3,a1,a2,a3,a6} \/ {a0} \/ {a4} by ENUMSET1:49
    .={a3,a1,a2,a3} \/ {a6} \/ {a0} \/ {a4} by ENUMSET1:50
    .={a3,a3,a2,a1} \/ {a6} \/ {a0} \/ {a4} by ENUMSET1:107
    .={a3,a2,a1} \/ {a6} \/ {a0} \/ {a4} by ENUMSET1:71
    .={a3,a2,a1} \/ ({a6} \/ {a0}) \/ {a4} by XBOOLE_1:4
    .={a3,a2,a1} \/ {a6,a0} \/ {a4} by ENUMSET1:41
    .={a3,a2,a1} \/ ({a6,a0} \/ {a4}) by XBOOLE_1:4
    .={a3,a2,a1} \/ {a6,a0,a4} by ENUMSET1:43
    .={a3,a2,a1} \/ {a6,a4,a0} by ENUMSET1:98;
A5: Ub2 = UsedIntLoc (n1 ';'n2) \/ UIF by SF_MASTR:31
    .= UsedIntLoc n1 \/ UsedIntLoc n2 \/ UIF by SF_MASTR:35
    .= {a2,a5} \/ UsedIntLoc n2 \/ UIF by SF_MASTR:21
    .= {a2,a5} \/ {a5,a6} \/ UIF by SF_MASTR:18
    .= {a2,a5,a5,a6} \/ UIF by ENUMSET1:45
    .= {a5,a5,a2,a6} \/ UIF by ENUMSET1:116
    .= {a5,a2,a6} \/ ({a2,a5} \/ {a4,a0}) by A2,ENUMSET1:71
    .= {a5,a2,a6} \/ {a2,a5} \/ {a4,a0} by XBOOLE_1:4
    .= {a2,a5,a5,a2,a6} \/ {a4,a0} by ENUMSET1:48
    .= {a2,a5,a5,a2} \/ {a6} \/ {a4,a0} by ENUMSET1:50
    .= {a2,a2,a5,a5} \/ {a6} \/ {a4,a0} by ENUMSET1:107
    .= {a2,a5,a5} \/ {a6} \/ {a4,a0} by ENUMSET1:71
    .= {a5,a5,a2} \/ {a6} \/ {a4,a0} by ENUMSET1:102
    .= {a5,a2} \/ {a6} \/ {a4,a0} by ENUMSET1:70
    .= {a5,a2,a6} \/ {a4,a0} by ENUMSET1:43
    .= {a5,a2,a6,a4,a0} by ENUMSET1:49;
A6: Ub1 = UsedIntLoc (t16 ';' Wg) \/ UsedIntLoc T3 by SF_MASTR:31
    .= UsedIntLoc (t16 ';' Wg) \/ (Ub3 \/ {a4,a0}) by SCMBSORT:31
    .= Ut16 \/ UsedIntLoc Wg \/ (Ub3 \/ {a4,a0}) by SF_MASTR:31
    .= Ut16 \/ ({a5,a2,a6,a4,a0} \/ {a2}) \/ (Ub3 \/ {a4,a0}) by A5,SCMFSA9A:30
    .= Ut16 \/ {a2,a5,a2,a6,a4,a0} \/ (Ub3 \/ {a4,a0}) by ENUMSET1:51
    .= Ut16 \/ ({a2,a5,a2,a6} \/ {a4,a0}) \/ (Ub3 \/ {a4,a0}) by ENUMSET1:54
    .= Ut16 \/ ({a2,a2,a5,a6} \/ {a4,a0}) \/ (Ub3 \/ {a4,a0}) by ENUMSET1:104
    .= Ut16 \/ ({a2,a5,a6} \/ {a4,a0}) \/ (Ub3 \/ {a4,a0}) by ENUMSET1:71
    .= Ut16 \/ {a2,a5,a6,a4,a0} \/ (Ub3 \/ {a4,a0}) by ENUMSET1:49
    .= Ut16 \/ ({a6,a4,a0} \/ {a2,a5}) \/ (Ub3 \/ {a4,a0}) by ENUMSET1:48
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a6,a4,a0} \/ {a2,a5} \/ (Ub3 \/ {a4,a0})
  by A4,XBOOLE_1:4
    .= {a3,a2,a1} \/ ({a6,a4,a0} \/ {a6,a4,a0}) \/ {a2,a5} \/ (Ub3 \/ {a4,a0
  }) by XBOOLE_1:4
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a2,a5} \/ ({a3,a5} \/ ({a2,a0,a6} \/ {a4
  ,a0})) by A1,XBOOLE_1:4
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a2,a5} \/ ({a3,a5} \/ {a2,a0,a6,a4,a0})
  by ENUMSET1:49
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a2,a5} \/ ({a3,a5} \/ ({a2} \/ {a0,a6,a4
  ,a0})) by ENUMSET1:47
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a2,a5} \/ ({a3,a5} \/ ({a2} \/ {a0,a0,a4
  ,a6})) by ENUMSET1:107
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a2,a5} \/ ({a3,a5} \/ ({a2} \/ {a0,a4,a6
  })) by ENUMSET1:71
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a2,a5} \/ ({a3,a5} \/ {a2,a0,a4,a6}) by
ENUMSET1:44
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a2,a5} \/ {a3,a5,a2,a0,a4,a6} by
ENUMSET1:52
    .= {a3,a2,a1} \/ {a0,a4,a6} \/ {a5,a2} \/ {a3,a5,a2,a0,a4,a6} by
ENUMSET1:102
    .= {a3,a2,a1} \/ ({a0,a4,a6} \/ {a5,a2}) \/ {a3,a5,a2,a0,a4,a6} by
XBOOLE_1:4
    .= {a3,a2,a1} \/ {a5,a2,a0,a4,a6} \/ {a3,a5,a2,a0,a4,a6} by ENUMSET1:48
    .= {a3,a2,a1} \/ {a5,a2,a0,a4,a6} \/ ({a5,a2,a0,a4,a6} \/ {a3}) by
ENUMSET1:51
    .= {a3,a2,a1} \/ {a5,a2,a0,a4,a6} \/ {a5,a2,a0,a4,a6} \/ {a3} by XBOOLE_1:4
    .= {a3,a2,a1} \/ ({a5,a2,a0,a4,a6} \/ {a5,a2,a0,a4,a6}) \/ {a3} by
XBOOLE_1:4
    .= {a3,a2,a1,a5,a2,a0,a4,a6} \/ {a3} by ENUMSET1:64
    .= {a3,a2,a1,a5,a2} \/ {a0,a4,a6} \/ {a3} by ENUMSET1:66
    .= {a3} \/ {a2,a1,a5,a2} \/ {a0,a4,a6} \/ {a3} by ENUMSET1:47
    .= {a3} \/ {a2,a2,a5,a1} \/ {a0,a4,a6} \/ {a3} by ENUMSET1:107
    .= {a3} \/ {a2,a5,a1} \/ {a0,a4,a6} \/ {a3} by ENUMSET1:71
    .= {a3,a2,a5,a1} \/ {a0,a4,a6} \/ {a3} by ENUMSET1:44
    .= {a1,a5,a2,a3} \/ {a0,a4,a6} \/ {a3} by ENUMSET1:125
    .= {a1,a5,a2,a3,a0,a4,a6} \/ {a3} by ENUMSET1:59
    .= {a1} \/ {a5,a2,a3,a0,a4,a6} \/ {a3} by ENUMSET1:56
    .= {a1} \/ ({a5,a2,a3,a0,a4} \/ {a6}) \/ {a3} by ENUMSET1:55
    .= {a1} \/ {a5,a2,a3,a0,a4} \/ {a6} \/ {a3} by XBOOLE_1:4
    .= {a1} \/ {a5,a2,a3,a0,a4} \/ {a3} \/ {a6} by XBOOLE_1:4
    .= {a1} \/ ({a5,a2,a3,a0,a4} \/ {a3}) \/ {a6} by XBOOLE_1:4
    .= {a1} \/ {a5,a2,a3,a0,a4,a3} \/ {a6} by ENUMSET1:55
    .= {a1} \/ ({a5,a2} \/ {a3,a0,a4,a3}) \/ {a6} by ENUMSET1:52
    .= {a1} \/ ({a5,a2} \/ {a3,a3,a4,a0}) \/ {a6} by ENUMSET1:107
    .= {a1} \/ ({a5,a2} \/ {a3,a4,a0}) \/ {a6} by ENUMSET1:71
    .= {a1} \/ {a5,a2,a3,a4,a0} \/ {a6} by ENUMSET1:48
    .= {a1} \/ ({a0} \/ {a5,a2,a3,a4}) \/ {a6} by ENUMSET1:50
    .= {a1} \/ {a0} \/ {a5,a2,a3,a4} \/ {a6} by XBOOLE_1:4
    .= {a0,a1} \/ {a5,a2,a3,a4} \/ {a6} by ENUMSET1:41
    .= {a0,a1} \/ {a2,a3,a4,a5} \/ {a6} by ENUMSET1:111
    .= {a0,a1,a2,a3,a4,a5} \/ {a6} by ENUMSET1:52
    .= {a0,a1,a2,a3,a4,a5,a6} by ENUMSET1:61;
  thus UsedIntLoc (insert-sort f) = UsedIntLoc (WM ';' j1 ';' j2) \/
  UsedIntLoc Times(a1,body1) by SF_MASTR:31
    .= UsedIntLoc (WM ';' j1 ';' j2) \/ (Ub1 \/ {a1,a0}) by SCMBSORT:31
    .= Uj1 \/ UsedIntLoc j2 \/ (Ub1 \/ {a1,a0}) by SF_MASTR:34
    .= Uj1 \/ {a1,a0} \/ (Ub1 \/ {a1,a0}) by SF_MASTR:18
    .= Uj1 \/ {a1,a0} \/ {a1,a0} \/ Ub1 by XBOOLE_1:4
    .= Uj1 \/ ({a1,a0} \/ {a1,a0}) \/ Ub1 by XBOOLE_1:4
    .= UsedIntLoc WM \/ UsedIntLoc j1 \/ {a1,a0} \/ Ub1 by SF_MASTR:34
    .= {a2,a3,a4,a5,a6} \/ {a0} \/ {a1} \/ {a1,a0} \/ Ub1 by A3,SF_MASTR:22
    .= {a2,a3,a4,a5,a6} \/ ({a0} \/ {a1}) \/ {a1,a0} \/ Ub1 by XBOOLE_1:4
    .= {a2,a3,a4,a5,a6} \/ {a1,a0} \/ {a1,a0} \/ Ub1 by ENUMSET1:41
    .= {a2,a3,a4,a5,a6} \/ ({a1,a0} \/ {a1,a0}) \/ Ub1 by XBOOLE_1:4
    .= {a0,a1,a2,a3,a4,a5,a6} \/ {a0,a1,a2,a3,a4,a5,a6} by A6,ENUMSET1:57
    .= {a0,a1,a2,a3,a4,a5,a6};
end;

theorem Th39:
  for f being FinSeq-Location holds UsedInt*Loc (insert-sort f) =
  {f}
proof
  set m0=SubFrom(a2,a2), m1=Macro m0, m2=AddTo(a4,a0), m3=SubFrom(a2,a0), IF=
  if>0(a5, m1, m2 ';' m3), UIF = UsedInt*Loc IF;
  set k2= a2:= a0, k3= a3:= a0, k4= a4:= a0, k5= a5:= a0;
  let f be FinSeq-Location;
  set i1= a2:=a3, i2= SubFrom(a3,a0), i3= a5:=(f,a2), i4= a6:=(f,a3), i5= (f,
  a2):=a6, i6= (f,a3):=a5, body3= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' i6, Ub3=
  UsedInt*Loc body3;
A1: Ub3 = UsedInt*Loc (i1 ';' i2 ';'i3 ';'i4 ';' i5 ) \/ UsedInt*Loc i6 by
SF_MASTR:50
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ';'i4 ';' i5 ) \/ {f} by SF_MASTR:37
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ';'i4) \/ UsedInt*Loc i5 \/ {f} by
SF_MASTR:50
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ';'i4) \/ {f} \/ {f} by SF_MASTR:37
    .= UsedInt*Loc (i1 ';' i2 ';'i3) \/ UsedInt*Loc i4 \/ {f} \/ {f} by
SF_MASTR:50
    .= UsedInt*Loc (i1 ';' i2 ';'i3) \/ {f} \/ {f} \/ {f} by SF_MASTR:37
    .= UsedInt*Loc (i1 ';' i2) \/ UsedInt*Loc i3 \/ {f} \/ {f} \/ {f} by
SF_MASTR:50
    .= UsedInt*Loc (i1 ';' i2) \/ {f} \/ {f} \/ {f} \/ {f} by SF_MASTR:37
    .= UsedInt*Loc i1 \/ UsedInt*Loc i2 \/ {f} \/ {f} \/ {f} \/ {f} by
SF_MASTR:51
    .= {} \/ UsedInt*Loc i2 \/ {f} \/ {f} \/ {f} \/ {f} by SF_MASTR:36
    .= {} \/ {f} \/ {f} \/ {f} \/ {f} by SF_MASTR:36
    .= {f};
  set n1=a5:=(f,a2), n2=SubFrom(a5,a6), body2=n1 ';'n2 ';' IF, Ub2=UsedInt*Loc
  body2;
A2: UIF = UsedInt*Loc m1 \/ UsedInt*Loc (m2 ';' m3) by SCMBSORT:35
    .= UsedInt*Loc m0 \/ UsedInt*Loc (m2 ';' m3) by SF_MASTR:48
    .= {} \/ UsedInt*Loc (m2 ';' m3) by SF_MASTR:36
    .= {} \/ (UsedInt*Loc m2 \/ UsedInt*Loc m3) by SF_MASTR:51
    .= {} \/ ({} \/ UsedInt*Loc m3) by SF_MASTR:36
    .= {} by SF_MASTR:36;
  set WM=initializeWorkMem, j1=a1:=len f, j2=SubFrom(a1,a0);
A3: UsedInt*Loc initializeWorkMem = UsedInt*Loc (k2 ';' k3 ';' k4 ';' k5) \/
  UsedInt*Loc (a6:= a0) by SF_MASTR:50
    .= UsedInt*Loc (k2 ';' k3 ';' k4 ';' k5) \/ {} by SF_MASTR:36
    .= UsedInt*Loc (k2 ';' k3 ';' k4) \/ UsedInt*Loc k5 by SF_MASTR:50
    .= UsedInt*Loc (k2 ';' k3 ';' k4) \/ {} by SF_MASTR:36
    .= UsedInt*Loc (k2 ';' k3 ) \/ UsedInt*Loc k4 by SF_MASTR:50
    .= UsedInt*Loc (k2 ';' k3 ) \/ {} by SF_MASTR:36
    .= UsedInt*Loc k2 \/ UsedInt*Loc k3 by SF_MASTR:51
    .= UsedInt*Loc k2 \/ {} by SF_MASTR:36
    .= {} by SF_MASTR:36;
  set T3=Times(a4,body3), t1=a2:=len f, t2=SubFrom(a2,a1), t3=a3 := a2, t4=
  AddTo(a3,a0), t5=a6:=(f,a3), t6=SubFrom(a4,a4), Wg=while>0(a2,body2), t16=t1
  ';' t2 ';' t3 ';' t4 ';' t5 ';' t6, body1=t16 ';' Wg ';' T3, Ub1 =UsedInt*Loc
  body1, Ut16 =UsedInt*Loc t16;
A4: Ut16= UsedInt*Loc (t1 ';'t2 ';' t3 ';' t4 ';' t5) \/ UsedInt*Loc t6 by
SF_MASTR:50
    .= UsedInt*Loc (t1 ';'t2 ';' t3 ';' t4 ';' t5) \/ {} by SF_MASTR:36
    .= UsedInt*Loc (t1 ';'t2 ';' t3 ';' t4) \/ UsedInt*Loc t5 \/ {} by
SF_MASTR:50
    .= UsedInt*Loc (t1 ';'t2 ';' t3 ';' t4) \/ {f} \/ {} by SF_MASTR:37
    .= UsedInt*Loc (t1 ';'t2 ';' t3) \/ UsedInt*Loc t4 \/ {f} \/ {} by
SF_MASTR:50
    .= UsedInt*Loc (t1 ';'t2 ';' t3) \/ {} \/ {f} \/ {} by SF_MASTR:36
    .= UsedInt*Loc (t1 ';'t2) \/ UsedInt*Loc t3 \/ {} \/ {f} \/ {} by
SF_MASTR:50
    .= UsedInt*Loc (t1 ';'t2) \/ {} \/ {} \/ {f} \/ {} by SF_MASTR:36
    .= UsedInt*Loc t1 \/ UsedInt*Loc t2 \/ {} \/ {} \/ {f} \/ {} by SF_MASTR:51
    .= {f} \/ UsedInt*Loc t2 \/ {} \/ {} \/ {f} \/ {} by SF_MASTR:38
    .= {f} \/ {f} \/ {} by SF_MASTR:36
    .= {f};
A5: Ub2 = UsedInt*Loc (n1 ';'n2) \/ UIF by SF_MASTR:47
    .= UsedInt*Loc n1 \/ UsedInt*Loc n2 \/ UIF by SF_MASTR:51
    .= {f} \/ UsedInt*Loc n2 \/ UIF by SF_MASTR:37
    .= {f} \/ {} by A2,SF_MASTR:36
    .= {f};
A6: UsedInt*Loc body1 = UsedInt*Loc (t16 ';' Wg ) \/ UsedInt*Loc T3 by
SF_MASTR:47
    .= UsedInt*Loc (t16 ';' Wg) \/ {f} by A1,SCMBSORT:37
    .= UsedInt*Loc t16 \/ UsedInt*Loc Wg \/ {f} by SF_MASTR:47
    .= {f} \/ {f} by A5,A4,SCMFSA9A:31
    .= {f};
  thus UsedInt*Loc (insert-sort f) = UsedInt*Loc (WM ';' j1 ';' j2) \/
  UsedInt*Loc Times(a1,body1) by SF_MASTR:47
    .= UsedInt*Loc (WM ';' j1 ';' j2) \/ {f} by A6,SCMBSORT:37
    .= UsedInt*Loc (WM ';' j1) \/ UsedInt*Loc j2 \/ {f} by SF_MASTR:50
    .= UsedInt*Loc (WM ';' j1) \/ {} \/ {f} by SF_MASTR:36
    .= UsedInt*Loc WM \/ UsedInt*Loc j1 \/ {} \/ {f} by SF_MASTR:50
    .= {f} \/ {f} by A3,SF_MASTR:38
    .= {f};
end;

theorem Th40:
  for k1,k2,k3,k4 being Instruction of SCM+FSA holds card( k1 ';'
  k2 ';' k3 ';' k4) =8
proof
  let k1,k2,k3,k4 be Instruction of SCM+FSA;
  thus card( k1 ';' k2 ';' k3 ';' k4) = card (k1 ';' k2 ';' k3) + card Macro
  k4 by SCMFSA6A:61
    .= card (k1 ';' k2 ';' k3)+ 2 by SCMFSA7B:6
    .= 6 + 2 by SCMBSORT:45
    .= 8;
end;

theorem Th41:
  for k1,k2,k3,k4,k5 being Instruction of SCM+FSA holds card( k1
  ';' k2 ';' k3 ';' k4 ';'k5) =10
proof
  let k1,k2,k3,k4,k5 be Instruction of SCM+FSA;
  thus card( k1 ';' k2 ';' k3 ';' k4 ';'k5) = card (k1 ';' k2 ';' k3 ';' k4)+
  card Macro k5 by SCMFSA6A:61
    .= card (k1 ';' k2 ';' k3 ';' k4)+ 2 by SCMFSA7B:6
    .= 8+ 2 by Th40
    .= 10;
end;

theorem Th42:
  for f being FinSeq-Location holds card (insert-sort f) = 82
proof
  set m1=Macro SubFrom(a2,a2), m2=AddTo(a4,a0), m3=SubFrom(a2,a0), IF=if>0(a5,
  m1, m2 ';' m3);
  let f be FinSeq-Location;
  set i1= a2:=a3, i2= SubFrom(a3,a0), i3= a5:=(f,a2), i4= a6:=(f,a3), i5= (f,
  a2):=a6, i6= (f,a3):=a5, body3= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' i6;
A1: card IF = card m1 + card (m2 ';' m3)+ 4 by SCMFSA8B:15
    .= 2 + card (m2 ';' m3)+ 4 by SCMFSA7B:6
    .= 2 + (card Macro m2 + card Macro m3)+ 4 by SCMFSA6A:61
    .= 2 + (2 + card Macro m3)+ 4 by SCMFSA7B:6
    .= 2 + (2 + 2)+ 4 by SCMFSA7B:6
    .= 10;
  set n1=a5:=(f,a2), n2=SubFrom(a5,a6), body2=n1 ';'n2 ';' IF;
A2: card body2 = card (n1 ';'n2) + card IF by SCMFSA6A:61
    .= card Macro n1 + card Macro n2 + card IF by SCMFSA6A:61
    .= 2 + card Macro n2 + card IF by SCMFSA7B:6
    .= 2 + 2 + 10 by A1,SCMFSA7B:6
    .= 14;
  set WM=initializeWorkMem, j1=a1:=len f, j2=SubFrom(a1,a0);
  set T3=Times(a4,body3), t1=a2:=len f, t2=SubFrom(a2,a1), t3=a3 := a2, t4=
  AddTo(a3,a0), t5=a6:=(f,a3), t6=SubFrom(a4,a4), Wg=while>0(a2,body2), t16=t1
  ';' t2 ';' t3 ';' t4 ';' t5 ';' t6, body1=t16 ';' Wg ';' T3;
A3: card body3 = card (i1 ';' i2 ';' i3 ';' i4 ';' i5) + card Macro i6 by
SCMFSA6A:61
    .=10 + card Macro i6 by Th41
    .=10+2 by SCMFSA7B:6
    .=12;
A4: card body1 = card (t16 ';' Wg) + card T3 by SCMFSA6A:61
    .= card t16 + card Wg + card T3 by SCMFSA6A:61
    .= card (t1 ';' t2 ';' t3 ';' t4 ';' t5) + card Macro t6 + card Wg +
  card T3 by SCMFSA6A:61
    .= 10 + card Macro t6 + card Wg + card T3 by Th41
    .= 10 + 2 + card Wg + card T3 by SCMFSA7B:6
    .= 10 + 2 + (14 + 6) + card T3 by A2,SCMFSA_9:5
    .= 10 + 2 + (14 + 6) + (12+12) by A3,SCMBSORT:44
    .= 56;
  thus card (insert-sort f) = card (WM ';' j1 ';' j2 ) + card Times(a1,body1)
  by SCMFSA6A:61
    .= card (WM ';' j1 ';' j2 ) + (56+12) by A4,SCMBSORT:44
    .= card (WM ';' j1) + card Macro j2 + (56+12) by SCMFSA6A:61
    .= card (WM ';' j1) + 2 + (56+12) by SCMFSA7B:6
    .= card WM + card Macro j1 + 2 + (56+12) by SCMFSA6A:61
    .= card WM + 2 + 2 + (56+12) by SCMFSA7B:6
    .= 10 + 2 + 2 + 68 by Th41
    .= 82;
end;

theorem Th43:
  for f being FinSeq-Location, k being Element of NAT st k < 82
  holds  k in dom (insert-sort f)
proof
  let f be FinSeq-Location, k be Element of NAT;
  assume
A1: k < 82;
  card (insert-sort f) = 82 by Th42;
  hence thesis by A1,SCMFSA6A:15;
end;

Lm1: for s being State of SCM+FSA st Insert-Sort-Algorithm c= s holds s.
0= a2:=a0 & s. 1= goto  2 & s. 2= a3:=a0 & s. 3= goto
 4 & s. 4= a4:=a0 & s. 5= goto  6 & s. 6= a5:=a0
& s. 7= goto  8 & s. 8= a6:=a0 & s. 9= goto  10 &
s. 10= a1:=len fsloc 0 & s. 11= goto  12

proof

  set f0=fsloc 0, TT=Times(a1, ((a2:=len f0) ';' SubFrom(a2,a1) ';' (a3 := a2)

';' AddTo(a3,a0) ';' (a6:=(f0,a3)) ';' SubFrom(a4,a4)) ';' while>0(a2, (a5:=(f0
  ,a2)) ';' SubFrom(a5,a6) ';' if>0(a5,Macro SubFrom(a2,a2), AddTo(a4,a0) ';'
  SubFrom(a2,a0)) ) ';' Times(a4, (a2:=a3) ';' SubFrom(a3,a0) ';' (a5:=(f0,a2))
  ';' (a6:=(f0,a3)) ';' ((f0,a2):=a6) ';'((f0,a3):=a5) ) );

  set q=Insert-Sort-Algorithm, q0=insert-sort f0;

  set W2=a2:= a0, W3=a3:= a0, W4=a4:= a0, W5=a5:= a0, W6=a6:= a0, W7=a1:=len

f0, W8=SubFrom(a1,a0), T8= W8 ';' TT, T7=W7 ';' T8, T6=W6 ';' T7, T5=W5 ';' T6,

T4=W4 ';' T5, T3=W3 ';' T4, X3=W2 ';' W3, X4=X3 ';' W4, X5=X4 ';' W5, X6=X5 ';'
  W6;

A1: W2 <> halt SCM+FSA by SCMBSORT:49;
A2: dom Macro W2 = { 0,  1} by SCMFSA7B:4;
  then
A3:  0 in dom Macro W2 by TARSKI:def 2;
A4:  1 in dom Macro W2 by A2,TARSKI:def 2;
A5: card X3 = card Macro W2 + card Macro W3 by SCMFSA6A:61
    .= 2 + card Macro W3 by SCMFSA7B:6
    .= 2 + 2 by SCMFSA7B:6
    .=4;
A6: q0=X6 ';' W7 ';' T8 by SCMFSA6A:69;
  then
A7: q0=X5 ';' W6 ';' T7 by SCMFSA6A:69;
  then
A8: q0=X4 ';' W5 ';' T6 by SCMFSA6A:69;
  then
A9: q0=X3 ';' W4 ';' T5 by SCMFSA6A:69;
  then
A10: q0 =Macro W2 ';' W3 ';' T4 by SCMFSA6A:69;
  q0=W2 ';' W3 ';' T4 by A9,SCMFSA6A:69;
  then
A11: q0=W2 ';' T3 by SCMFSA6A:73;
  let s be State of SCM+FSA such that
A12: q c= s;
A13: now
    let i be Element of NAT;
    assume
    i< 82;
    then  i in dom q0 by Th43;
    hence q0. i= s. i by A12,GRFUNC_1:8;
  end;
  hence s. 0=q0. 0
    .= (Directed Macro W2). 0 by A11,A3,SCMFSA8A:28
    .= W2 by A1,SCMFSA7B:7;
A14: card Macro W2=2 by SCMFSA7B:6;
A15: card X4=6 by SCMBSORT:45;
  then
A16: card X5 = 6 + card Macro W5 by SCMFSA6A:61
    .= 6 + 2 by SCMFSA7B:6
    .=8;
  then
A17: card X6 = 8 + card Macro W6 by SCMFSA6A:61
    .= 8 + 2 by SCMFSA7B:6
    .= 10;
  thus s. 1=q0. 1 by A13
    .= (Directed Macro W2). 1 by A11,A4,SCMFSA8A:28
    .= goto  2 by SCMFSA7B:8;
  thus s. 2=q0. 2 by A13
    .= W3 by A10,A14,SCMBSORT:51;
  thus s. 3=q0. (2+1) by A13
    .=goto  (2+2) by A10,A14,SCMBSORT:51
    .=goto  4;
  thus s. 4=q0. 4 by A13
    .= W4 by A9,A5,SCMBSORT:51;
  thus s. 5=q0. (4+1) by A13
    .=goto  (4+2) by A9,A5,SCMBSORT:51
    .=goto  6;
  thus s. 6=q0. 6 by A13
    .= W5 by A8,A15,SCMBSORT:51;
  thus s. 7=q0. (6+1) by A13
    .=goto  (6+2) by A8,A15,SCMBSORT:51
    .=goto  8;
  thus s. 8=q0. 8 by A13
    .= W6 by A7,A16,SCMBSORT:51;
  thus s. 9=q0. (8+1) by A13
    .=goto  (8+2) by A7,A16,SCMBSORT:51
    .=goto  10;
  thus s. 10=q0. 10 by A13
    .= W7 by A6,A17,SCMBSORT:52;
  thus s. 11=q0. (10+1) by A13
    .=goto  (10+2) by A6,A17,SCMBSORT:52
    .=goto  12;
end;
set f0=fsloc 0;

set b1=intloc (0+1),b2=intloc (1+1),b3=intloc (2+1),b4=intloc (3+1), b5=intloc
(4+1),b6=intloc (5+1);

set i1= b2:=b3, i2= SubFrom(b3,a0), i3= b5:=(f0,b2), i4= b6:=(f0,b3), i5= (f0,
b2):=b6, i6= (f0,b3):=b5, body3= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' i6, w2= b2
:= a0, w3= b3:= a0, w4= b4:= a0, w5= b5:= a0, w6= b6:= a0, T3=Times(b4,body3),
m0=SubFrom(b2,b2), m1=Macro m0, m2=AddTo(b4,a0), m3=SubFrom(b2,a0), IF=if>0(b5,
m1, m2 ';' m3), n1=b5:=(f0,b2), n2=SubFrom(b5,b6), body2=n1 ';'n2 ';' IF, t1=b2
:=len f0, t2=SubFrom(b2,b1), t3=b3:= b2, t4=AddTo(b3,a0), t5=b6:=(f0,b3), t6=
SubFrom(b4,b4), Wg=while>0(b2,body2), t16=t1 ';' t2 ';' t3 ';' t4 ';' t5 ';' t6
, body1=t16 ';' Wg ';' T3, WM=initializeWorkMem, j1=b1:=len f0, j2=SubFrom(b1,
a0);

Lm2: for s being State of SCM+FSA st Insert-Sort-Algorithm c= s & s starts_at
0 holds (for k being Element of NAT st k>0 & k<12 holds Comput(ProgramPart( s),
s,k).IC
SCM+FSA =  k & Comput(ProgramPart( s), s,k).a0=s.a0 & Comput(ProgramPart( s), s
,k).fsloc 0=s.
fsloc 0) & Comput(ProgramPart( s), s,11).a1=len(s.fsloc 0) & Comput(ProgramPart
( s), s,11).a2=s.a0 &
Comput(ProgramPart( s), s,11).a3=s.a0 & Comput(ProgramPart( s), s,11).a4=s.a0 &
Comput(ProgramPart( s), s,11).a5
=s.a0 & Comput(ProgramPart( s), s,11).a6=s.a0

proof
  let s be State of SCM+FSA such that
A1: Insert-Sort-Algorithm c= s and
A2: s starts_at 0;
A3: Comput(ProgramPart(s),s,0) = s by AMI_1:13;
  then
A4: IC Comput(ProgramPart(s),s,0) =  0 by A2,AMI_1:def 41;
  then
A5: Comput(ProgramPart(s),s,0+1) = Exec(s. 0,Comput(ProgramPart(s),s,0)) by
AMI_1:55
    .= Exec(a2:=a0,Comput(ProgramPart(s),s,0)) by A1,Lm1;
  then
A6: Comput(ProgramPart(s),s,1).IC SCM+FSA = succ IC Comput(ProgramPart(s),s,0)
by SCMFSA_2:89
    .=  1 by A4;
  then IC Comput(ProgramPart(s),s,1)=  1;
  then
A7: Comput(ProgramPart(s),s,1+1) = Exec(s. 1,Comput(ProgramPart(s),s,1)) by
AMI_1:55
    .= Exec(goto  2,Comput(ProgramPart(s),s,1)) by A1,Lm1;
  then
A8: Comput(ProgramPart(s),s,2).IC SCM+FSA =  2 by SCMFSA_2:95;
  IC Comput(ProgramPart(s),s,2)=  2 by A7,SCMFSA_2:95;
  then
A9: Comput(ProgramPart(s),s,2+1) = Exec(s. 2,Comput(ProgramPart(s),s,2)) by
AMI_1:55
    .= Exec(a3:=a0,Comput(ProgramPart(s),s,2)) by A1,Lm1;

  then
A10: Comput(ProgramPart(s),s,3).IC SCM+FSA = succ IC Comput(ProgramPart(s),s,2)
by SCMFSA_2:89

    .=  3 by A8;
  then IC Comput(ProgramPart(s),s,3)=  3;
  then
A11: Comput(ProgramPart(s),s,3+1) = Exec(s. 3,Comput(ProgramPart(s),s,3)) by
AMI_1:55
    .= Exec(goto  4,Comput(ProgramPart(s),s,3)) by A1,Lm1;
  then
A12: Comput(ProgramPart(s),s,4).IC SCM+FSA =  4 by SCMFSA_2:95;
A13: a2<>a0 by AMI_3:52;
  then
A14: Comput(ProgramPart(s),s,1).a0 =s.a0 by A3,A5,SCMFSA_2:89;
  then
A15: Comput(ProgramPart(s),s,2).a0 =s.a0 by A7,SCMFSA_2:95;
  then Comput(ProgramPart(s),s,3).a3 =s.a0 by A9,SCMFSA_2:89;
  then
A16: Comput(ProgramPart(s),s,4).a3 =s.a0 by A11,SCMFSA_2:95;
  IC Comput(ProgramPart(s),s,4)=  4 by A11,SCMFSA_2:95;
  then
A17: Comput(ProgramPart(s),s,4+1) = Exec(s. 4,Comput(ProgramPart(s),s,4)) by
AMI_1:55
    .= Exec(a4:=a0,Comput(ProgramPart(s),s,4)) by A1,Lm1;

  then
A18: Comput(ProgramPart(s),s,5).IC SCM+FSA = succ IC Comput(ProgramPart(s),s,4)
by SCMFSA_2:89

    .=  5 by A12;
  then IC Comput(ProgramPart(s),s,5)=  5;
  then
A19: Comput(ProgramPart(s),s,5+1) = Exec(s. 5,Comput(ProgramPart(s),s,5)) by
AMI_1:55
    .= Exec(goto  6,Comput(ProgramPart(s),s,5)) by A1,Lm1;
  then
A20: Comput(ProgramPart(s),s,6).IC SCM+FSA =  6 by SCMFSA_2:95;
  IC Comput(ProgramPart(s),s,6)=  6 by A19,SCMFSA_2:95;
  then
A21: Comput(ProgramPart(s),s,6+1) = Exec(s. 6,Comput(ProgramPart(s),s,6)) by
AMI_1:55
    .= Exec(a5:=a0,Comput(ProgramPart(s),s,6)) by A1,Lm1;

  then
A22: Comput(ProgramPart(s),s,7).IC SCM+FSA = succ IC Comput(ProgramPart(s),s,6)
by SCMFSA_2:89

    .=  7 by A20;
  then IC Comput(ProgramPart(s),s,7)=  7;
  then
A23: Comput(ProgramPart(s),s,7+1) = Exec(s. 7,Comput(ProgramPart(s),s,7)) by
AMI_1:55
    .= Exec(goto  8,Comput(ProgramPart(s),s,7)) by A1,Lm1;
  then
A24: Comput(ProgramPart(s),s,8).IC SCM+FSA =  8 by SCMFSA_2:95;
  IC Comput(ProgramPart(s),s,8)=  8 by A23,SCMFSA_2:95;
  then
A25: Comput(ProgramPart(s),s,8+1) = Exec(s. 8,Comput(ProgramPart(s),s,8)) by
AMI_1:55
    .= Exec(a6:=a0,Comput(ProgramPart(s),s,8)) by A1,Lm1;

  then
A26: Comput(ProgramPart(s),s,9).IC SCM+FSA = succ IC Comput(ProgramPart(s),s,8)
by SCMFSA_2:89

    .=  9 by A24;
  then IC Comput(ProgramPart(s),s,9)=  9;
  then
A27: Comput(ProgramPart(s),s,9+1) = Exec(s. 9,Comput(ProgramPart(s),s,9)) by
AMI_1:55
    .= Exec(goto  10,Comput(ProgramPart(s),s,9)) by A1,Lm1;
  then
A28: Comput(ProgramPart(s),s,10).IC SCM+FSA =  10 by SCMFSA_2:95;
A29: Comput(ProgramPart(s),s,1).(fsloc 0) =s.(fsloc 0) by A3,A5,SCMFSA_2:89;
  then
A30: Comput(ProgramPart(s),s,2).(fsloc 0) =s.(fsloc 0) by A7,SCMFSA_2:95;
  then
A31: Comput(ProgramPart(s),s,3).(fsloc 0) =s.(fsloc 0) by A9,SCMFSA_2:89;
  then
A32: Comput(ProgramPart(s),s,4).(fsloc 0) =s.(fsloc 0) by A11,SCMFSA_2:95;
  then
A33: Comput(ProgramPart(s),s,5).(fsloc 0) =s.(fsloc 0) by A17,SCMFSA_2:89;
  then
A34: Comput(ProgramPart(s),s,6).(fsloc 0) =s.(fsloc 0) by A19,SCMFSA_2:95;
  then
A35: Comput(ProgramPart(s),s,7).(fsloc 0) =s.(fsloc 0) by A21,SCMFSA_2:89;
  then
A36: Comput(ProgramPart(s),s,8).(fsloc 0) =s.(fsloc 0) by A23,SCMFSA_2:95;
  then
A37: Comput(ProgramPart(s),s,9).(fsloc 0) =s.(fsloc 0) by A25,SCMFSA_2:89;
  then
A38: Comput(ProgramPart(s),s,10).(fsloc 0) =s.(fsloc 0) by A27,SCMFSA_2:95;
A39: Comput(ProgramPart(s),s,3).a0 =s.a0 by A15,A9,SCMFSA_2:89;
  then
A40: Comput(ProgramPart(s),s,4).a0 =s.a0 by A11,SCMFSA_2:95;
  then Comput(ProgramPart(s),s,5).a4 =s.a0 by A17,SCMFSA_2:89;
  then
A41: Comput(ProgramPart(s),s,6).a4 =s.a0 by A19,SCMFSA_2:95;
A42: a4<>a0 by AMI_3:52;
  then
A43: Comput(ProgramPart(s),s,5).a0 =s.a0 by A40,A17,SCMFSA_2:89;
  then
A44: Comput(ProgramPart(s),s,6).a0 =s.a0 by A19,SCMFSA_2:95;
  then Comput(ProgramPart(s),s,7).a5 =s.a0 by A21,SCMFSA_2:89;
  then
A45: Comput(ProgramPart(s),s,8).a5 =s.a0 by A23,SCMFSA_2:95;
  a4<>a5 by AMI_3:52;
  then Comput(ProgramPart(s),s,7).a4 =s.a0 by A41,A21,SCMFSA_2:89;
  then
A46: Comput(ProgramPart(s),s,8).a4 =s.a0 by A23,SCMFSA_2:95;
  a4<>a6 by AMI_3:52;
  then Comput(ProgramPart(s),s,9).a4 =s.a0 by A46,A25,SCMFSA_2:89;
  then
A47: Comput(ProgramPart(s),s,10).a4 =s.a0 by A27,SCMFSA_2:95;
  a5<>a6 by AMI_3:52;
  then Comput(ProgramPart(s),s,9).a5 =s.a0 by A45,A25,SCMFSA_2:89;
  then
A48: Comput(ProgramPart(s),s,10).a5 =s.a0 by A27,SCMFSA_2:95;
A49: a5<>a0 by AMI_3:52;
  then
A50: Comput(ProgramPart(s),s,7).a0 =s.a0 by A44,A21,SCMFSA_2:89;
  then
A51: Comput(ProgramPart(s),s,8).a0 =s.a0 by A23,SCMFSA_2:95;
  then Comput(ProgramPart(s),s,9).a6 =s.a0 by A25,SCMFSA_2:89;
  then
A52: Comput(ProgramPart(s),s,10).a6 =s.a0 by A27,SCMFSA_2:95;
  IC Comput(ProgramPart(s),s,10)=  10 by A27,SCMFSA_2:95;

  then
A53: Comput(ProgramPart(s),s,10+1) = Exec(s. 10,Comput(ProgramPart(s),s,10))
by AMI_1:55

    .= Exec(a1:=len fsloc 0,Comput(ProgramPart(s),s,10)) by A1,Lm1;

  then
A54: Comput(ProgramPart(s),s,11).IC SCM+FSA = succ IC Comput(ProgramPart(s),s,
10) by SCMFSA_2:100

    .=  11 by A28;
A55: a6<>a0 by AMI_3:52;
  then
A56: Comput(ProgramPart(s),s,9).a0 =s.a0 by A51,A25,SCMFSA_2:89;
  then
A57: Comput(ProgramPart(s),s,10).a0 =s.a0 by A27,SCMFSA_2:95;
  hereby
    let k be Element of NAT;
    assume that
A58: k>0 and
A59: k<12;

    set c1= Comput(ProgramPart( s), s,k).IC SCM+FSA, d1=  k, c2= Comput(
ProgramPart( s), s,k).
    a0, d2=s.a0, c3= Comput(ProgramPart( s), s,k).fsloc 0, d3=s.fsloc 0;

    k<11+1 by A59;
    then
A60: k<=11 by NAT_1:13;
    per cases by A58,A60,NAT_1:36;
    suppose
      k = 1;
      hence c1=d1 & c2=d2 & c3=d3 by A3,A5,A6,A13,SCMFSA_2:89;
    end;
    suppose
      k = 2;
      hence c1=d1 & c2=d2 & c3=d3 by A14,A29,A7,SCMFSA_2:95;
    end;
    suppose
      k = 3;
      hence c1=d1 & c2=d2 & c3=d3 by A15,A30,A9,A10,SCMFSA_2:89;
    end;
    suppose
      k = 4;
      hence c1=d1 & c2=d2 & c3=d3 by A39,A31,A11,SCMFSA_2:95;
    end;
    suppose
      k = 5;
      hence c1=d1 & c2=d2 & c3=d3 by A40,A32,A17,A18,A42,SCMFSA_2:89;
    end;
    suppose
      k = 6;
      hence c1=d1 & c2=d2 & c3=d3 by A43,A33,A19,SCMFSA_2:95;
    end;
    suppose
      k = 7;
      hence c1=d1 & c2=d2 & c3=d3 by A44,A34,A21,A22,A49,SCMFSA_2:89;
    end;
    suppose
      k = 8;
      hence c1=d1 & c2=d2 & c3=d3 by A50,A35,A23,SCMFSA_2:95;
    end;
    suppose
      k = 9;
      hence c1=d1 & c2=d2 & c3=d3 by A51,A36,A25,A26,A55,SCMFSA_2:89;
    end;
    suppose
      k = 10;
      hence c1=d1 & c2=d2 & c3=d3 by A56,A37,A27,SCMFSA_2:95;
    end;
    suppose
      k = 11;
      hence c1=d1 & c2=d2 & c3=d3 by A57,A38,A53,A54,SCMFSA_2:100;
    end;
  end;
  thus Comput(ProgramPart(s),s,11).a1 =len(s.fsloc 0) by A38,A53,SCMFSA_2:100;
  Comput(ProgramPart(s),s,1).a2 =s.a0 by A3,A5,SCMFSA_2:89;
  then
A61: Comput(ProgramPart(s),s,2).a2 =s.a0 by A7,SCMFSA_2:95;
  a2<>a3 by AMI_3:52;
  then Comput(ProgramPart(s),s,3).a2 =s.a0 by A61,A9,SCMFSA_2:89;
  then
A62: Comput(ProgramPart(s),s,4).a2 =s.a0 by A11,SCMFSA_2:95;
  a2<>a4 by AMI_3:52;
  then Comput(ProgramPart(s),s,5).a2 =s.a0 by A62,A17,SCMFSA_2:89;
  then
A63: Comput(ProgramPart(s),s,6).a2 =s.a0 by A19,SCMFSA_2:95;
  a2<>a5 by AMI_3:52;
  then Comput(ProgramPart(s),s,7).a2 =s.a0 by A63,A21,SCMFSA_2:89;
  then
A64: Comput(ProgramPart(s),s,8).a2 =s.a0 by A23,SCMFSA_2:95;
  a2<>a6 by AMI_3:52;
  then Comput(ProgramPart(s),s,9).a2 =s.a0 by A64,A25,SCMFSA_2:89;
  then
A65: Comput(ProgramPart(s),s,10).a2 =s.a0 by A27,SCMFSA_2:95;
  a3<>a4 by AMI_3:52;
  then Comput(ProgramPart(s),s,5).a3 =s.a0 by A16,A17,SCMFSA_2:89;
  then
A66: Comput(ProgramPart(s),s,6).a3 =s.a0 by A19,SCMFSA_2:95;
  a3<>a5 by AMI_3:52;
  then Comput(ProgramPart(s),s,7).a3 =s.a0 by A66,A21,SCMFSA_2:89;
  then
A67: Comput(ProgramPart(s),s,8).a3 =s.a0 by A23,SCMFSA_2:95;
  a3<>a6 by AMI_3:52;
  then Comput(ProgramPart(s),s,9).a3 =s.a0 by A67,A25,SCMFSA_2:89;
  then
A68: Comput(ProgramPart(s),s,10).a3 =s.a0 by A27,SCMFSA_2:95;
  a2<>a1 by AMI_3:52;
  hence Comput(ProgramPart(s),s,11).a2 =s.a0 by A65,A53,SCMFSA_2:100;
  a3<>a1 by AMI_3:52;
  hence Comput(ProgramPart(s),s,11).a3 =s.a0 by A68,A53,SCMFSA_2:100;
  a4<>a1 by AMI_3:52;
  hence Comput(ProgramPart(s),s,11).a4 =s.a0 by A47,A53,SCMFSA_2:100;
  a5<>a1 by AMI_3:52;
  hence Comput(ProgramPart(s),s,11).a5 =s.a0 by A48,A53,SCMFSA_2:100;
  a6<>a1 by AMI_3:52;
  hence thesis by A52,A53,SCMFSA_2:100;
end;

Lm3: for s be State of SCM+FSA holds (s.b5>0 implies IExec(IF,s).b2 =0) & (s.
b5<=0 implies IExec(IF,s).b2 =s.b2-1)

proof
  let s be State of SCM+FSA;
  set s0=Initialize s, s1=Exec(m2, s0);
  hereby
    assume
    s.b5 > 0;
    hence IExec(IF,s).b2 = IExec(m1,s).b2 by SCM_HALT:54
      .=Exec(m0,Initialize s).b2 by SCMFSA6C:6
      .=s0.b2-s0.b2 by SCMFSA_2:91
      .=0;
  end;
  b2<>b4 by AMI_3:52;
  then
A1: s1.b2=s0.b2 by SCMFSA_2:90
    .=s.b2 by SCMFSA6C:3;
A2: s1.a0=s0.a0 by SCMFSA_2:90
    .=1 by SCMFSA6C:3;
  hereby
    assume
    s.b5 <= 0;
    hence IExec(IF,s).b2 = IExec(m2 ';' m3, s).b2 by SCM_HALT:54
      .=Exec(m3,s1).b2 by SCMFSA6C:9
      .=s.b2-1 by A1,A2,SCMFSA_2:91;
  end;
end;

Lm4: for s be State of SCM+FSA holds IExec(body2,s).b2<s.b2 or IExec(body2,s).
b2<=0

proof
  let s be State of SCM+FSA;
  set s0=Initialize s, s1=Exec(n1,s0), s2=IExec(n1 ';'n2,s);
A1: b5<>b2 by AMI_3:52;
A2: s2.b2=Exec(n2,s1).b2 by SCMFSA6C:9
    .=s1.b2 by A1,SCMFSA_2:91
    .=s0.b2 by A1,SCMFSA_2:98
    .=s.b2 by SCMFSA6C:3;
  per cases;
  suppose
A3: s2.b5>0;
    IExec(body2,s).b2=IExec(IF,s2).b2 by SCM_HALT:30
      .=0 by A3,Lm3;
    hence thesis;
  end;
  suppose
A4: s2.b5<=0;
    IExec(body2,s).b2=IExec(IF,s2).b2 by SCM_HALT:30
      .=s.b2-1 by A2,A4,Lm3;
    hence thesis by XREAL_1:148;
  end;
end;
then
Lm5: while>0(b2,body2) is good InitHalting Program of SCM+FSA by Th30;

Lm6: body3 does_not_destroy b4
proof
A1: b4 <> b6 by AMI_3:52;
A2: i3 does_not_destroy b4 by AMI_3:52,SCMFSA7B:20;
A3: i2 does_not_destroy b4 by AMI_3:52,SCMFSA7B:14;
  i1 does_not_destroy b4 by AMI_3:52,SCMFSA7B:12;
  then i1 ';' i2 ';' i3 does_not_destroy b4 by A3,A2,SCMFSA8C:83,84;

  then i1 ';' i2 ';' i3 ';' i4 does_not_destroy b4 by A1,SCMFSA7B:20
,SCMFSA8C:83;

  then i1 ';' i2 ';' i3 ';' i4 ';' i5 does_not_destroy b4 by SCMFSA7B:21
,SCMFSA8C:83;

  hence thesis by SCMFSA7B:21,SCMFSA8C:83;
end;

Lm7: body3 does_not_destroy b1
proof
A1: b1 <> b6 by AMI_3:52;
A2: i3 does_not_destroy b1 by AMI_3:52,SCMFSA7B:20;
A3: i2 does_not_destroy b1 by AMI_3:52,SCMFSA7B:14;
  i1 does_not_destroy b1 by AMI_3:52,SCMFSA7B:12;
  then i1 ';' i2 ';' i3 does_not_destroy b1 by A3,A2,SCMFSA8C:83,84;

  then i1 ';' i2 ';' i3 ';' i4 does_not_destroy b1 by A1,SCMFSA7B:20
,SCMFSA8C:83;

  then i1 ';' i2 ';' i3 ';' i4 ';' i5 does_not_destroy b1 by SCMFSA7B:21
,SCMFSA8C:83;

  hence thesis by SCMFSA7B:21,SCMFSA8C:83;
end;

Lm8: body2 does_not_destroy b1
proof
  b1 <> b2 by AMI_3:52;
  then
A1: m1 does_not_destroy b1 by SCMFSA7B:14,SCMFSA8C:77;
A2: m3 does_not_destroy b1 by AMI_3:52,SCMFSA7B:14;
  m2 does_not_destroy b1 by AMI_3:52,SCMFSA7B:13;
  then m2 ';' m3 does_not_destroy b1 by A2,SCMFSA8C:84;
  then
A3: IF does_not_destroy b1 by A1,SCMFSA8C:121;
A4: n2 does_not_destroy b1 by AMI_3:52,SCMFSA7B:14;
  n1 does_not_destroy b1 by AMI_3:52,SCMFSA7B:20;
  then n1 ';' n2 does_not_destroy b1 by A4,SCMFSA8C:84;
  hence thesis by A3,SCMFSA8C:81;
end;

Lm9: body1 does_not_destroy b1
proof
A1: t3 does_not_destroy b1 by AMI_3:52,SCMFSA7B:12;
A2: b1 <> b3 by AMI_3:52;
A3: t2 does_not_destroy b1 by AMI_3:52,SCMFSA7B:14;
  t1 does_not_destroy b1 by AMI_3:52,SCMFSA7B:22;
  then t1 ';' t2 ';' t3 does_not_destroy b1 by A3,A1,SCMFSA8C:83,84;

  then
A4: t1 ';' t2 ';' t3 ';' t4 does_not_destroy b1 by A2,SCMFSA7B:13,SCMFSA8C:83;

A5: b1 <> b4 by AMI_3:52;
  b1 <> b6 by AMI_3:52;

  then t1 ';' t2 ';' t3 ';' t4 ';' t5 does_not_destroy b1 by A4,SCMFSA7B:20
,SCMFSA8C:83;

  then
A6: t16 does_not_destroy b1 by A5,SCMFSA7B:14,SCMFSA8C:83;
  Wg does_not_destroy b1 by Lm8,Th7;
  then
A7: t16 ';' Wg does_not_destroy b1 by A6,SCMFSA8C:81;
  T3 does_not_destroy b1 by Lm7,AMI_3:52,SCMBSORT:3;
  hence thesis by A7,SCMFSA8C:81;
end;

Lm10: Times(b4,body3) is good InitHalting Program of SCM+FSA
proof
  Initialized Times(b4,body3) is halting by Lm6,SCM_HALT:76;
  hence thesis by SCM_HALT:def 2;
end;

Lm11: body1 is good InitHalting Program of SCM+FSA
proof
  reconsider TT=T3 as good InitHalting Program of SCM+FSA by Lm10;
  reconsider WT=Wg as good InitHalting Program of SCM+FSA by Lm4,Th30;

  reconsider t14=t1 ';' t2 ';' t3 ';' t4 as good InitHalting Program of
  SCM+FSA;

  reconsider t16=t14 ';' t5 ';' t6 as good InitHalting Program of SCM+FSA;
  t16 ';' WT ';' TT is good InitHalting;
  hence thesis;
end;

Lm12: Times(b1,body1) is good InitHalting Program of SCM+FSA
proof
  Initialized Times(b1,body1) is halting by Lm9,Lm11,SCM_HALT:76;
  hence thesis by SCM_HALT:def 2;
end;

theorem
  insert-sort (fsloc 0) is keepInt0_1 InitHalting by Lm12;

Lm13: for s be State of SCM+FSA holds IExec(IF,s).f0=s.f0
proof
  let s be State of SCM+FSA;
  set s0=Initialize s;
  per cases;
  suppose
    s.b5 >0;
    hence IExec(IF,s).f0 = IExec(m1,s).f0 by SCM_HALT:54
      .=Exec(m0,s0).f0 by SCMFSA6C:6
      .=s0.f0 by SCMFSA_2:91
      .=s.f0 by SCMFSA6C:3;
  end;
  suppose
    s.b5 <= 0;
    hence IExec(IF,s).f0 = IExec(m2 ';' m3, s).f0 by SCM_HALT:54
      .=Exec(m3,Exec(m2, s0)).f0 by SCMFSA6C:10
      .=Exec(m2, s0).f0 by SCMFSA_2:91
      .=s0.f0 by SCMFSA_2:90
      .=s.f0 by SCMFSA6C:3;
  end;
end;

Lm14: for s be State of SCM+FSA holds (s.b5>0 implies IExec(IF,s).b4 =s.b4) &
(s.b5<=0 implies IExec(IF,s).b4 =s.b4+1)

proof
  let s be State of SCM+FSA;
  set s0=Initialize s;
A1: b2<>b4 by AMI_3:52;
  hereby
    assume
    s.b5 > 0;
    hence IExec(IF,s).b4 = IExec(m1,s).b4 by SCM_HALT:54
      .=Exec(m0,s0).b4 by SCMFSA6C:6
      .=s0.b4 by A1,SCMFSA_2:91
      .=s.b4 by SCMFSA6C:3;
  end;
  hereby
    assume
    s.b5 <= 0;
    hence IExec(IF,s).b4 = IExec(m2 ';' m3, s).b4 by SCM_HALT:54
      .=Exec(m3,Exec(m2, s0)).b4 by SCMFSA6C:9
      .=Exec(m2, s0).b4 by A1,SCMFSA_2:91
      .=s0.b4+s0.a0 by SCMFSA_2:90
      .=s0.b4+1 by SCMFSA6C:3
      .=s.b4+1 by SCMFSA6C:3;
  end;
end;

Lm15: for a be read-write Int-Location,s be State of SCM+FSA st a<>b4 & a<>b2
holds IExec(IF,s).a = s.a

proof
  let a be read-write Int-Location,s be State of SCM+FSA;
  assume that
A1: a<>b4 and
A2: a<> b2;
  set s1=Exec(m2, Initialize s), s2=IExec(m2 ';' m3, s);
A3: s1.a= (Initialize s).a by A1,SCMFSA_2:90
    .=s.a by SCMFSA6C:3;
A4: s2.a=Exec(m3,s1).a by SCMFSA6C:9
    .=s.a by A2,A3,SCMFSA_2:91;
  per cases;
  suppose
    s.b5 >0;
    hence IExec(IF,s).a = IExec(m1,s).a by SCM_HALT:54
      .=Exec(m0,Initialize s).a by SCMFSA6C:6
      .=(Initialize s).a by A2,SCMFSA_2:91
      .=s.a by SCMFSA6C:3;
  end;
  suppose
    s.b5 <= 0;
    hence thesis by A4,SCM_HALT:54;
  end;
end;

Lm16: for t be State of SCM+FSA st t.b2 >= 1 & t.b2 <= len(t.f0) holds IExec(
body2,t).b3=t.b3 & IExec(body2,t).b6=t.b6 & IExec(body2,t).f0=t.f0 & ex x1 be
Integer st x1=t.f0.(t.b2) & ( x1-t.b6>0 implies IExec(body2,t).b2=0 & IExec(
body2,t).b4=t.b4 ) & ( x1-t.b6<=0 implies IExec(body2,t).b2=t.b2-1 & IExec(
body2,t).b4=t.b4+1 )

proof
  let s be State of SCM+FSA;
  assume that
A1: s.b2 >= 1 and
A2: s.b2 <= len(s.f0);
A3: abs(s.b2)=s.b2 by A1,ABSVALUE:def 1;
  set s0=Initialize s, s1=Exec(n1,s0), s2=IExec(n1 ';'n2,s);
A4: b4<>b3 by AMI_3:52;
  reconsider k1=s.b2 as Element of NAT by A1,INT_1:16;
  reconsider n=s.f0.k1 as Integer;
A5: (s.f0)/.k1=n by A1,A2,FINSEQ_4:24;
A6: s1.b5=(s0.f0)/.(abs(s0.b2)) by SCMBSORT:8
    .=(s0.f0)/.(abs(s.b2)) by SCMFSA6C:3
    .=n by A3,A5,SCMFSA6C:3;
A7: b2<>b3 by AMI_3:52;
A8: b5<>b6 by AMI_3:52;
  then
A9: s1.b6=s0.b6 by SCMFSA_2:98
    .=s.b6 by SCMFSA6C:3;
A10: b5<>b3 by AMI_3:52;
A11: s2.b5=Exec(n2,s1).b5 by SCMFSA6C:9
    .=n-s.b6 by A9,A6,SCMFSA_2:91;
  thus IExec(body2,s).b3=IExec(IF,s2).b3 by SCM_HALT:30
    .=s2.b3 by A4,A7,Lm15
    .=Exec(n2,s1).b3 by SCMFSA6C:9
    .=s1.b3 by A10,SCMFSA_2:91
    .=s0.b3 by A10,SCMFSA_2:98
    .=s.b3 by SCMFSA6C:3;
A12: b4<>b6 by AMI_3:52;
A13: b2<>b6 by AMI_3:52;
  thus IExec(body2,s).b6=IExec(IF,s2).b6 by SCM_HALT:30
    .=s2.b6 by A12,A13,Lm15
    .=Exec(n2,s1).b6 by SCMFSA6C:9
    .=s.b6 by A8,A9,SCMFSA_2:91;
A14: b5<>b4 by AMI_3:52;
  thus IExec(body2,s).f0=IExec(IF,s2).f0 by SCM_HALT:31
    .=s2.f0 by Lm13
    .=Exec(n2,s1).f0 by SCMFSA6C:10
    .=s1.f0 by SCMFSA_2:91
    .=s0.f0 by SCMFSA_2:98
    .=s.f0 by SCMFSA6C:3;
  take n;
A15: b5<>b2 by AMI_3:52;
  thus n=s.f0.(s.b2);
A16: s2.b4=Exec(n2,s1).b4 by SCMFSA6C:9
    .=s1.b4 by A14,SCMFSA_2:91
    .=s0.b4 by A14,SCMFSA_2:98
    .=s.b4 by SCMFSA6C:3;
  hereby
    assume
A17: n-s.b6>0;
    thus IExec(body2,s).b2=IExec(IF,s2).b2 by SCM_HALT:30
      .=0 by A11,A17,Lm3;
    thus IExec(body2,s).b4=IExec(IF,s2).b4 by SCM_HALT:30
      .=s.b4 by A16,A11,A17,Lm14;
  end;
A18: s2.b2=Exec(n2,s1).b2 by SCMFSA6C:9
    .=s1.b2 by A15,SCMFSA_2:91
    .=s0.b2 by A15,SCMFSA_2:98
    .=s.b2 by SCMFSA6C:3;
  hereby
    assume
A19: n-s.b6<=0;
    thus IExec(body2,s).b2=IExec(IF,s2).b2 by SCM_HALT:30
      .=s.b2-1 by A18,A11,A19,Lm3;
    thus IExec(body2,s).b4=IExec(IF,s2).b4 by SCM_HALT:30
      .=s.b4+1 by A16,A11,A19,Lm14;
  end;
end;

Lm17: for k be Element of NAT,s be State of SCM+FSA st s.b2=k & s.b2<=len(s.f0
) holds s.f0=IExec(Wg,s).f0 & s.b6=IExec(Wg,s).b6 & s.b3=IExec(Wg,s).b3 & (k=0
or ex n be Element of NAT,x1 be Integer st n=IExec(Wg,s).b4-s.b4 & n<=k & (k-n
>=1 implies x1=s.f0.(k-n) & x1 >= s.b6) & for i be Element of NAT st i>k-n & i<
k+1 holds ex x2 be Integer st x2=s.f0.i & x2 <= s.b6 )

proof

  defpred P[Element of NAT] means for s be State of SCM+FSA st s.b2=$1 & s.b2

<=len(s.f0) holds IExec(Wg,s).f0=s.f0 & IExec(Wg,s).b6=s.b6 & IExec(Wg,s).b3=s.

b3 & ($1=0 or ex n be Element of NAT,x1 be Integer st n=IExec(Wg,s).b4-s.b4 & n

<=$1 & ($1-n>=1 implies x1=s.f0.($1-n) & x1 >= s.b6) & (for i be Element of NAT
  st i>$1-n & i<$1+1 holds ex x2 be Integer st x2=s.f0.i & x2 <= s.b6));

A1: now
    let k be Element of NAT;
    assume
A2: P[k];
    now
      let s be State of SCM+FSA;
      assume that
A3:   s.b2=k+1 and
A4:   s.b2<=len(s.f0);
      set bs=IExec(body2,s), bs0=Initialize bs;
A5:   s.b2 >= 1+0 by A3,INT_1:20;
      then consider m be Integer such that
A6:   m=s.f0.(s.b2) and
A7:   m-s.b6>0 implies bs.b2=0 & bs.b4=s.b4 and
A8:   m-s.b6<=0 implies bs.b2=s.b2-1 & bs.b4=s.b4+1 by A4,Lm16;
      reconsider WT=Wg as good InitHalting Program of SCM+FSA by Lm4,Th30;
      per cases;
      suppose
A9:     m-s.b6>0;
        thus IExec(Wg,s).f0=IExec(WT,bs).f0 by A3,Th36
          .=bs.f0 by A7,A9,Th34
          .=s.f0 by A4,A5,Lm16;
        thus IExec(Wg,s).b6=IExec(WT,bs).b6 by A3,Th37
          .=bs0.b6 by A7,A9,Th35
          .=bs.b6 by SCMFSA6C:3
          .=s.b6 by A4,A5,Lm16;
        thus IExec(Wg,s).b3=IExec(WT,bs).b3 by A3,Th37
          .=bs0.b3 by A7,A9,Th35
          .=bs.b3 by SCMFSA6C:3
          .=s.b3 by A4,A5,Lm16;
A10:    IExec(Wg,s).b4=IExec(WT,bs).b4 by A3,Th37
          .=bs0.b4 by A7,A9,Th35
          .=s.b4 by A7,A9,SCMFSA6C:3;
        now
          take n=0;
          take x1=m;
          thus n=IExec(Wg,s).b4-s.b4 by A10;
          thus n<=k+1;

          thus k+1-n>=1 implies x1=s.f0.(k+1-n) & x1>=(0 qua Nat)+s.b6
           by A3,A6,A9,XREAL_1:21;

          thus for i be Element of NAT st i>k+1-n & i<k+1+1 ex x2 be Integer
          st x2=s.f0.i & x2 <= s.b6 by INT_1:20;

        end;

        hence
        (k+1)=0 or ex n be Element of NAT,x1 be Integer st n=IExec(Wg,s).

b4-s.b4 & n<=k+1 & (k+1-n>=1 implies x1=s.f0.(k+1-n) & x1 >= s.b6) & for i be

Element of NAT st i>k+1-n & i<k+1+1 ex x2 be Integer st x2=s.f0.i & x2 <= s.b6;

      end;
      suppose
A11:    m-s.b6<=0;
        bs.b2<k+1 by A3,A7,A8,XREAL_1:31;
        then
A12:    bs.b2<=len(s.f0) by A3,A4,XXREAL_0:2;
A13:    bs.b6=s.b6 by A4,A5,Lm16;
A14:    bs.f0=s.f0 by A4,A5,Lm16;
        thus IExec(Wg,s).f0=IExec(WT,bs).f0 by A3,Th36
          .=s.f0 by A2,A3,A8,A11,A14,A12;
        thus IExec(Wg,s).b6=IExec(WT,bs).b6 by A3,Th37
          .=s.b6 by A2,A3,A8,A11,A14,A12,A13;
        thus IExec(Wg,s).b3=IExec(WT,bs).b3 by A3,Th37
          .=bs.b3 by A2,A3,A8,A11,A14,A12
          .=s.b3 by A4,A5,Lm16;
        hereby
          per cases;
          suppose
            k<>0;
            then consider n be Element of NAT,x1 be Integer such that
A15:        n=IExec(Wg,bs).b4-bs.b4 and
A16:        n<=k and
A17:        k-n>=1 implies x1=bs.f0.(k-n) & x1 >= bs.b6 and

A18:        for i be Element of NAT st i>k-n & i<k+1 ex x2 be Integer
            st x2=bs .f0.i & x2 <= bs.b6 by A2,A3,A8,A11,A14,A12;

A19:        IExec(WT,s).b4=s.b4+(1+n) by A3,A8,A11,A15,Th37;
            now
              take n1=1+n;
              take y1=x1;
              thus n1=IExec(Wg,s).b4-s.b4 by A19;
              thus n1<=k+1 by A16,XREAL_1:8;

              thus k+1-n1>=1 implies y1=s.f0.(k+1-n1) & y1 >=s.b6 by A4,A5,A17
,Lm16;

              now
                let i be Element of NAT;
                assume that
A20:            i>k+1-n1 and
A21:            i<k+1+1;
                per cases;
                suppose
A22:              i=k+1;
                  take x2=m;
                  thus x2=s.f0.i by A3,A6,A22;
                  x2<=(0 qua Nat)+s.b6 by A11,XREAL_1:22;
                  hence x2<=s.b6;
                end;
                suppose
A23:              i<>k+1;
                  i<=k+1 by A21,INT_1:20;
                  then i<k+1 by A23,XXREAL_0:1;
                  then consider y2 be Integer such that
A24:              y2=bs.f0.i and
A25:              y2 <= bs.b6 by A18,A20;
                  take x2=y2;
                  thus x2=s.f0.i by A4,A5,A24,Lm16;
                  thus x2<=s.b6 by A4,A5,A25,Lm16;
                end;
              end;

              hence for i be Element of NAT st i>k+1-n1 & i<k+1+1 holds ex x2
              be Integer st x2=s.f0.i & x2 <= s.b6;

            end;

            hence
            k+1=0 or ex n be Element of NAT,x1 be Integer st n=IExec(Wg,s

).b4-s.b4 & n<=k+1 & (k+1-n>=1 implies x1=s.f0.(k+1-n) & x1 >= s.b6) & for i be

Element of NAT st i>k+1-n & i<k+1+1 ex x2 be Integer st x2=s.f0.i & x2 <= s.b6;

          end;
          suppose
A26:        k=0;
A27:        IExec(WT,s).b4=IExec(Wg,bs).b4 by A3,Th37
              .=bs0.b4 by A3,A7,A8,A26,Th35
              .=s.b4+1 by A8,A11,SCMFSA6C:3;
            now
              take n1=1;
              take x1=0;
              thus n1=IExec(Wg,s).b4-s.b4 by A27;
              thus n1<=k+1 by A26;
              thus k+1-n1>=1 implies x1=s.f0.(k+1-n1) & x1 >= s.b6 by A26;
              hereby
                let i be Element of NAT;
                assume that
A28:            i>k+1-n1 and
A29:            i<k+1+1;
                take x2=m;
A30:            i>=0+1 by A28,INT_1:20;
                i<=1 by A26,A29,INT_1:20;
                hence x2=s.f0.i by A3,A6,A26,A30,XXREAL_0:1;
                x2<=(0 qua Nat)+s.b6 by A11,XREAL_1:22;
                hence x2<=s.b6;
              end;
            end;

            hence
            k+1=0 or ex n be Element of NAT,x1 be Integer st n=IExec(Wg,s

).b4-s.b4 & n<=k+1 & (k+1-n>=1 implies x1=s.f0.(k+1-n) & x1 >= s.b6) & for i be

Element of NAT st i>k+1-n & i<k+1+1 ex x2 be Integer st x2=s.f0.i & x2 <= s.b6;

          end;
        end;
      end;
    end;
    hence P[k+1];
  end;
A31: P[ 0]
  proof
    let s be State of SCM+FSA;
    set s0=Initialize s;
    assume that
A32: s.b2=0 and
    s.b2<=len(s.f0);
    thus IExec(Wg,s).f0=s.f0 by A32,Th34;
    thus IExec(Wg,s).b6=s0.b6 by A32,Th35
      .=s.b6 by SCMFSA6C:3;
    thus IExec(Wg,s).b3=s0.b3 by A32,Th35
      .=s.b3 by SCMFSA6C:3;
    thus thesis;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A31,A1);
  hence thesis;
end;

Lm18: for s be State of SCM+FSA holds IExec(body3,s).b3=s.b3-1 & IExec(body3,s
).f0=s.f0+*(abs(s.b3),(s.f0)/.(abs((s.b3-1)))) +*(abs((s.b3-1)),(s.f0)/.(abs(s.
b3)))

proof
  let s be State of SCM+FSA;

  set s0=Initialize s, s1=Exec(i1,s0), s2=IExec(i1 ';' i2,s), s3=IExec(i1 ';'
  i2 ';' i3,s), s4=IExec(i1 ';' i2 ';' i3 ';' i4,s), s5=IExec(i1 ';' i2 ';' i3
  ';' i4 ';' i5,s), s6=IExec(body3,s);

A1: b6<>b3 by AMI_3:52;
A2: s1.a0=s0.a0 by SCMFSA_2:89
    .=1 by SCMFSA6C:3;
A3: b6<>b2 by AMI_3:52;
A4: b2<>b3 by AMI_3:52;
A5: b6<>b5 by AMI_3:52;
A6: b5<>b2 by AMI_3:52;
A7: s2.b2=Exec(i2,s1).b2 by SCMFSA6C:9
    .=s1.b2 by A4,SCMFSA_2:91
    .=s0.b3 by SCMFSA_2:89
    .=s.b3 by SCMFSA6C:3;
A8: s4.b2=Exec(i4,s3).b2 by SCMFSA6C:7
    .=s3.b2 by A3,SCMFSA_2:98
    .=Exec(i3,s2).b2 by SCMFSA6C:7
    .=s.b3 by A6,A7,SCMFSA_2:98;
A9: b5<>b3 by AMI_3:52;
A10: s3.b3=Exec(i3,s2).b3 by SCMFSA6C:7
    .=s2.b3 by A9,SCMFSA_2:98
    .=Exec(i2,s1).b3 by SCMFSA6C:9
    .=s1.b3-s1.a0 by SCMFSA_2:91
    .=s0.b3-s1.a0 by A4,SCMFSA_2:89
    .=s.b3-1 by A2,SCMFSA6C:3;
A11: s5.b3=Exec(i5,s4).b3 by SCMFSA6C:7
    .=s4.b3 by SCMFSA_2:99
    .=Exec(i4,s3).b3 by SCMFSA6C:7
    .=s.b3-1 by A1,A10,SCMFSA_2:98;
  thus s6.b3=Exec(i6,s5).b3 by SCMFSA6C:7
    .=s.b3-1 by A11,SCMFSA_2:99;
A12: s2.f0=Exec(i2,s1).f0 by SCMFSA6C:10
    .=s1.f0 by SCMFSA_2:91
    .=s0.f0 by SCMFSA_2:89
    .=s.f0 by SCMFSA6C:3;
A13: s3.f0=Exec(i3,s2).f0 by SCMFSA6C:8
    .=s.f0 by A12,SCMFSA_2:98;
A14: s4.f0=Exec(i4,s3).f0 by SCMFSA6C:8
    .=s.f0 by A13,SCMFSA_2:98;
A15: s4.b6=Exec(i4,s3).b6 by SCMFSA6C:7
    .=(s.f0)/.(abs((s.b3-1))) by A10,A13,SCMBSORT:8;
A16: s5.f0=Exec(i5,s4).f0 by SCMFSA6C:8
    .=s.f0+*(abs(s.b3),(s.f0)/.abs(s.b3-1)) by A14,A8,A15,SCMBSORT:9;
A17: s5.b5=Exec(i5,s4).b5 by SCMFSA6C:7
    .=s4.b5 by SCMFSA_2:99
    .=Exec(i4,s3).b5 by SCMFSA6C:7
    .=s3.b5 by A5,SCMFSA_2:98
    .=Exec(i3,s2).b5 by SCMFSA6C:7
    .=(s.f0)/.(abs(s.b3)) by A12,A7,SCMBSORT:8;
  thus s6.f0=Exec(i6,s5).f0 by SCMFSA6C:8

    .=s.f0+*(abs(s.b3),(s.f0)/.abs(s.b3-1)) +*(abs((s.b3-1)),(s.f0)/.abs(s.
  b3)) by A11,A17,A16,SCMBSORT:9;

end;

Lm19: for k be Element of NAT,s be State of SCM+FSA st s.b4=k & k<s.b3 & s.b3
<=len(s.f0) holds s.f0, IExec(T3,s).f0 are_fiberwise_equipotent & IExec(T3,s).
b3=s.b3-k & IExec(T3,s).f0.(s.b3-k)=s.f0.(s.b3) & (for i be Element of NAT st s
.b3-k<i & i<=s.b3 holds IExec(T3,s).f0.i=s.f0.(i-1)) & (for i be Element of NAT
st s.b3<i & i<=len(s.f0) holds IExec(T3,s).f0.i=s.f0.i) & for i be Element of
NAT st 1<=i & i<s.b3-k holds IExec(T3,s).f0.i=s.f0.i

proof

  defpred P[Element of NAT] means for s be State of SCM+FSA st s.b4=$1 & $1<s.
  b3 & s.b3<=len(s.f0) holds (s.f0, IExec(T3,s).f0 are_fiberwise_equipotent) &
  IExec(T3,s).b3=s.b3-$1 & IExec(T3,s).f0.(s.b3-$1)=s.f0.(s.b3) & (for i be

Element of NAT st s.b3-$1<i & i<=s.b3 holds IExec(T3,s).f0.i=s.f0.(i-1)) & (for

i be Element of NAT st s.b3<i & i<=len(s.f0) holds IExec(T3,s).f0.i=s.f0.i) & (
  for i be Element of NAT st 1<=i & i<s.b3-$1 holds IExec(T3,s).f0.i=s.f0.i);

A1: now
    set s4=SubFrom(b4,a0);
    let k be Element of NAT;
    assume
A2: P[k];
    now
A3:   b4<>b3 by AMI_3:52;
      let s be State of SCM+FSA;
      assume that
A4:   s.b4=k+1 and
A5:   k+1<s.b3 and
A6:   s.b3<=len(s.f0);
A7:   k+1-1<s.b3-1 by A5,XREAL_1:11;
      then reconsider n=s.b3-1 as Element of NAT by INT_1:16;
A8:   n<=len(s.f0) by A6,XREAL_1:148,XXREAL_0:2;
      set b3s=IExec(body3 ';'s4,s), bds=IExec(body3,s);
      set ff=s.f0, gg=bds.f0;
A9:   b3s.b4=Exec(s4,bds).b4 by SCMFSA6C:7
        .=bds.b4-bds.a0 by SCMFSA_2:91
        .=bds.b4-1 by SCMFSA6B:35
        .=(Initialize s).b4-1 by Lm6,SCMFSA8C:91
        .=k+1-1 by A4,SCMFSA6C:3
        .=k;
      reconsider m=s.b3 as Element of NAT by A5,INT_1:16;
A10:  0+1<=k+1 by XREAL_1:8;
      then
A11:  1<=m by A5,XXREAL_0:2;
A12:  abs(s.b3)=m by ABSVALUE:def 1;
      k+1+1<=m by A5,INT_1:20;
      then k+1+1-1<=n by XREAL_1:11;
      then
A13:  1<=n by A10,XXREAL_0:2;
A14:  IExec(T3,s).f0=IExec(T3,b3s).f0 by A4,Lm6,SCM_HALT:82;
A15:  b3s.b3=Exec(s4,bds).b3 by SCMFSA6C:7
        .=bds.b3 by A3,SCMFSA_2:91
        .=s.b3-1 by Lm18;
      then
A16:  b3s.b3-k=s.b3-(k+1);
      abs(s.b3-1)=n by ABSVALUE:def 1;
      then
A17:  bds.f0=s.f0+*(m,(s.f0)/.n) +*(n,(s.f0)/.m) by A12,Lm18;
      then
A18:  ff.m=gg.n by A6,A11,A13,A8,FUNCT_7:115;
A19:  b3s.f0=Exec(s4,bds).f0 by SCMFSA6C:8
        .=bds.f0 by SCMFSA_2:91;

      then
A20:  ff,b3s.f0 are_fiberwise_equipotent by A6,A11,A13,A8,A17,FUNCT_7:115;

      then
A21:  n<=len(b3s.f0) by A8,RFINSEQ:16;

      then b3s.f0,IExec(T3,b3s).f0 are_fiberwise_equipotent by A2,A9,A15,A7;

      hence ff,IExec(T3,s).f0 are_fiberwise_equipotent by A20,A14,CLASSES1:84;

      ff,gg are_fiberwise_equipotent by A6,A11,A13,A8,A17,FUNCT_7:115;
      then
A22:  len ff=len (b3s.f0) by A19,RFINSEQ:16;
      IExec(T3,b3s).b3=b3s.b3-k by A2,A9,A15,A7,A21;
      hence IExec(T3,s).b3=s.b3-(k+1) by A4,A15,Lm6,SCM_HALT:83;
      IExec(T3,b3s).f0.(b3s.b3-k) =b3s.f0.(b3s.b3) by A2,A9,A15,A7,A21;

      hence IExec(T3,s).f0.(s.b3-(k+1))=s.f0.(s.b3) by A4,A15,A19,A18,Lm6,
SCM_HALT:82;

A23:  ff.n=gg.m by A6,A11,A13,A8,A17,FUNCT_7:115;
      hereby
        let i be Element of NAT;
        assume that
A24:    s.b3-(k+1)<i and
A25:    i<=s.b3;
        per cases;
        suppose
A26:      i=s.b3;
          then
A27:      b3s.b3<i by A15,XREAL_1:148;
          thus IExec(T3,s).f0.i=IExec(T3,b3s).f0.i by A4,Lm6,SCM_HALT:82
            .=s.f0.(i-1) by A2,A6,A9,A15,A7,A19,A8,A23,A22,A26,A27;
        end;
        suppose
          i<>s.b3;
          then i<s.b3 by A25,XXREAL_0:1;
          then
A28:      i+1<=s.b3 by INT_1:20;
          then
A29:      i<=s.b3-1 by XREAL_1:21;
A30:      i<=b3s.b3 by A15,A28,XREAL_1:21;
          s.b3-(k+1)+1<=i by A24,INT_1:20;
          then
A31:      s.b3-(k+1)+1-1<=i-1 by XREAL_1:11;
A32:      k+1-(k+1)<s.b3-(k+1) by A5,XREAL_1:11;
          then reconsider i1=i-1 as Element of NAT by A31,INT_1:16;
          i-1<s.b3 by A25,XREAL_1:148,XXREAL_0:2;
          then
A33:      i1<=len (s.f0) by A6,XXREAL_0:2;
          1+0<=s.b3-(k+1) by A32,INT_1:20;
          then 1<=i-1 by A31,XXREAL_0:2;
          then
A34:      i1 in dom ff by A33,FINSEQ_3:27;
A35:      i-1<i by XREAL_1:148;
          thus IExec(T3,s).f0.i=IExec(T3,b3s).f0.i by A4,Lm6,SCM_HALT:82
            .=bds.f0.(i-1) by A2,A9,A7,A19,A8,A22,A16,A24,A30
            .=s.f0.(i-1) by A6,A11,A13,A8,A17,A25,A29,A35,A34,FUNCT_7:115;
        end;
      end;
      hereby
A36:    1<=k+1 by NAT_1:11;
        let i be Element of NAT;
        assume that
A37:    s.b3<i and
A38:    i<=len(s.f0);
A39:    n<>i by A37,XREAL_1:148;
        k+1<i by A5,A37,XXREAL_0:2;
        then 1<=i by A36,XXREAL_0:2;
        then
A40:    i in dom ff by A38,FINSEQ_3:27;
A41:    b3s.b3<i by A15,A37,XREAL_1:148,XXREAL_0:2;
        thus IExec(T3,s).f0.i=IExec(T3,b3s).f0.i by A4,Lm6,SCM_HALT:82
          .=bds.f0.i by A2,A9,A15,A7,A19,A8,A22,A38,A41
          .=s.f0.i by A6,A11,A13,A8,A17,A37,A39,A40,FUNCT_7:115;
      end;
      hereby
        let i be Element of NAT;
        assume that
A42:    1<=i and
A43:    i<s.b3-(k+1);
A44:    s.b3-1-k<=s.b3-1-0 by XREAL_1:15;
        then
A45:    i<>m by A43,XREAL_1:148,XXREAL_0:2;
        i<s.b3-1 by A43,A44,XXREAL_0:2;
        then i<s.b3 by XREAL_1:148,XXREAL_0:2;
        then i<=len (s.f0) by A6,XXREAL_0:2;
        then
A46:    i in dom ff by A42,FINSEQ_3:27;
A47:    i<b3s.b3-k by A15,A43;
        thus IExec(T3,s).f0.i=IExec(T3,b3s).f0.i by A4,Lm6,SCM_HALT:82
          .=bds.f0.i by A2,A9,A15,A7,A19,A8,A22,A42,A47
          .=s.f0.i by A6,A11,A13,A8,A17,A43,A44,A45,A46,FUNCT_7:115;
      end;
    end;
    hence P[k+1];
  end;
A48: P[ 0]
  proof
    let s be State of SCM+FSA;
    assume that
A49: s.b4=0 and
    0<s.b3 and
    s.b3<=len(s.f0);
    thus s.f0, IExec(T3,s).f0 are_fiberwise_equipotent by A49,SCM_HALT:80;
    thus IExec(T3,s).b3=(Initialize s).b3 by A49,SCM_HALT:81
      .=s.b3-0 by SCMFSA6C:3;
    thus IExec(T3,s).f0.(s.b3-0)=s.f0.(s.b3) by A49,SCM_HALT:80;

    thus for i be Element of NAT st s.b3-0<i & i<=s.b3 holds IExec(T3,s).f0.i=
    s.f0.(i-1);

    thus for i be Element of NAT st s.b3<i & i<=len(s.f0) holds IExec(T3,s).f0
    .i=s.f0.i by A49,SCM_HALT:80;

    thus thesis by A49,SCM_HALT:80;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A48,A1);
  hence thesis;
end;

Lm20: for s be State of SCM+FSA holds IExec(t16,s).b2=len(s.f0) - s.b1 & IExec
(t16,s).b3=len(s.f0) - s.b1+1 & IExec(t16,s).f0=s.f0 & IExec(t16,s).b4=0 &
IExec(t16,s).b6=(s.f0)/.(abs((len(s.f0)-s.b1+1)))

proof
  let s be State of SCM+FSA;

  set s0=Initialize s, s1=Exec(t1,s0), s2=IExec(t1 ';' t2,s), s3=IExec(t1 ';'
  t2 ';' t3,s), s4=IExec(t1 ';' t2 ';' t3 ';' t4,s), s5=IExec(t1 ';' t2 ';' t3
  ';' t4 ';' t5,s), s6=IExec(t16,s);

A1: b4<>b3 by AMI_3:52;
A2: b4<>b2 by AMI_3:52;
A3: b6<>b2 by AMI_3:52;
A4: b6<>b3 by AMI_3:52;
A5: b2<>b1 by AMI_3:52;
A6: b2<>b3 by AMI_3:52;
A7: s2.b2=Exec(t2,s1).b2 by SCMFSA6C:9
    .=s1.b2-s1.b1 by SCMFSA_2:91
    .=len(s0.f0)-s1.b1 by SCMFSA_2:100
    .=len(s0.f0)-s0.b1 by A5,SCMFSA_2:100
    .=len(s.f0)-s0.b1 by SCMFSA6C:3
    .=len(s.f0)-s.b1 by SCMFSA6C:3;
  thus s6.b2=Exec(t6,s5).b2 by SCMFSA6C:7
    .=s5.b2 by A2,SCMFSA_2:91
    .=Exec(t5,s4).b2 by SCMFSA6C:7
    .=s4.b2 by A3,SCMFSA_2:98
    .=Exec(t4,s3).b2 by SCMFSA6C:7
    .=s3.b2 by A6,SCMFSA_2:90
    .=Exec(t3,s2).b2 by SCMFSA6C:7
    .=len(s.f0)-s.b1 by A6,A7,SCMFSA_2:89;
A8: s3.a0=1 by SCMFSA6B:35;
A9: s4.b3=Exec(t4,s3).b3 by SCMFSA6C:7
    .=s3.b3+1 by A8,SCMFSA_2:90
    .=Exec(t3,s2).b3+1 by SCMFSA6C:7
    .=len(s.f0)-s.b1+1 by A7,SCMFSA_2:89;
  thus s6.b3=Exec(t6,s5).b3 by SCMFSA6C:7
    .=s5.b3 by A1,SCMFSA_2:91
    .=Exec(t5,s4).b3 by SCMFSA6C:7
    .=len(s.f0)-s.b1+1 by A4,A9,SCMFSA_2:98;
A10: b6<>b4 by AMI_3:52;
A11: s4.f0=Exec(t4,s3).f0 by SCMFSA6C:8
    .=s3.f0 by SCMFSA_2:90
    .=Exec(t3,s2).f0 by SCMFSA6C:8
    .=s2.f0 by SCMFSA_2:89
    .=Exec(t2,s1).f0 by SCMFSA6C:10
    .=s1.f0 by SCMFSA_2:91
    .=s0.f0 by SCMFSA_2:100
    .=s.f0 by SCMFSA6C:3;
  thus s6.f0=Exec(t6,s5).f0 by SCMFSA6C:8
    .=s5.f0 by SCMFSA_2:91
    .=Exec(t5,s4).f0 by SCMFSA6C:8
    .=s.f0 by A11,SCMFSA_2:98;
  thus s6.b4=Exec(t6,s5).b4 by SCMFSA6C:7
    .=s5.b4-s5.b4 by SCMFSA_2:91
    .=0;
  thus s6.b6=Exec(t6,s5).b6 by SCMFSA6C:7
    .=s5.b6 by A10,SCMFSA_2:91
    .=Exec(t5,s4).b6 by SCMFSA6C:7
    .=(s.f0)/.(abs((len(s.f0)-s.b1+1))) by A9,A11,SCMBSORT:8;
end;
set T1=Times(b1,body1);

Lm21: for s be State of SCM+FSA st s.b1=len (s.f0) -1 holds s.f0, IExec(T1,s).
f0 are_fiberwise_equipotent & for i,j be Element of NAT st i>=1 & j<=len (s.f0)
& i<j for x1,x2 be Integer st x1 =IExec(T1,s).f0.i & x2=IExec(T1,s).f0.j holds
x1 >= x2

proof

  reconsider t14=t1 ';' t2 ';' t3 ';' t4 as good InitHalting Program of
  SCM+FSA;

  reconsider t16=t14 ';' t5 ';' t6 as good InitHalting Program of SCM+FSA;
  reconsider Wt=Wg as good InitHalting Program of SCM+FSA by Lm4,Th30;
  let s be State of SCM+FSA;
  assume
A1: s.b1=len (s.f0)-1;
A2: t16 ';' Wt is good InitHalting Program of SCM+FSA;
  per cases;
  suppose
A3: len (s.f0)<=1;

    hence s.f0, IExec(T1,s).f0 are_fiberwise_equipotent by A1,Lm11,SCM_HALT:80
,XREAL_1:49;

    now
      let i,j be Element of NAT;
      assume that
A4:   i>=1 and
A5:   j<=len (s.f0) and
A6:   i<j;
      j<=1 by A3,A5,XXREAL_0:2;
      hence contradiction by A4,A6,XXREAL_0:2;
    end;
    hence thesis;
  end;
  suppose
    len (s.f0)>1;
    then 1-1<len(s.f0)-1 by XREAL_1:11;
    then reconsider m=len(s.f0)-1 as Element of NAT by INT_1:16;

    defpred P[Element of NAT] means for t be State of SCM+FSA st t.b1=$1 & t.

b1<=len(t.f0)-1 holds ((for i,j be Element of NAT st i>=1 & j<=len(t.f0)-t.b1 &

i<j for x1,x2 be Integer st x1 =t.f0.i & x2=t.f0.j holds x1 >= x2) implies (t.

f0, IExec(T1,t).f0 are_fiberwise_equipotent) & (for i,j be Element of NAT st i
    >=1 & j<=len(t.f0) & i<j for x1,x2 be Integer st x1 =IExec(T1,t).f0.i & x2=
    IExec(T1,t).f0.j holds x1 >= x2));

A7: now
      let k be Element of NAT;
      assume
A8:   P[k];
      now
        let t be State of SCM+FSA;
        assume that
A9:     t.b1=k+1 and
A10:    t.b1<=len(t.f0)-1;
        len(t.f0)<len(t.f0)+t.b1 by A9,XREAL_1:31;
        then
A11:    len(t.f0)-t.b1<len(t.f0)+t.b1-t.b1 by XREAL_1:11;
        then
A12:    len(t.f0)-t.b1+1<=len(t.f0) by INT_1:20;
        -(len (t.f0)-1) <= -t.b1 by A10,XREAL_1:26;
        then
A13:    len(t.f0)+ -(len (t.f0)-1)<=len(t.f0)+-t.b1 by XREAL_1:8;
        then reconsider k1=len(t.f0)-t.b1 as Element of NAT by INT_1:16;
        set IW=IExec(t16 ';' Wg,t), ts=IExec(t16,t);
        set B1=SubFrom(b1,a0), IB=IExec(body1 ';' B1,t);
A14:    ts.f0=t.f0 by Lm20;
A15:    ts.b2=len(t.f0)-t.b1 by Lm20;
        then ts.b2<=len(ts.f0) by A11,Lm20;
        then consider n be Element of NAT,x1 be Integer such that
A16:    n=IExec(Wg,ts).b4-ts.b4 and
A17:    n<=k1 and
A18:    k1-n>=1 implies x1=ts.f0.(k1-n) & x1 >= ts.b6 and

A19:    for i be Element of NAT st i>k1-n & i<k1+1 holds ex x2 be
        Integer st x2=ts.f0.i & x2 <= ts.b6 by A15,A13,Lm17;

A20:    k1<k1+1 by XREAL_1:31;
        then
A21:    n<k1+1 by A17,XXREAL_0:2;
        then
A22:    n-n<k1+1-n by XREAL_1:11;
        reconsider n3=t.f0.(k1+1) as Integer;
A23:    1+0<=k1+1 by INT_1:20;
A24:    IB.f0=Exec(B1,IExec(body1,t)).f0 by Lm11,SCM_HALT:34
          .=IExec(body1,t).f0 by SCMFSA_2:91
          .=IExec(T3,IW).f0 by A2,Lm10,SCM_HALT:31;
        set mm=k1+1-n;
        abs((k1+1))=k1+1 by ABSVALUE:def 1;
        then
A25:    ts.b6=(t.f0)/.(k1+1) by Lm20
          .=n3 by A12,A23,FINSEQ_4:24;
        then
A26:    k1-n>=1 implies x1=t.f0.(k1-n) & x1 >= n3 by A18,Lm20;
A27:    ts.b2=k1 by Lm20;
A28:    IW.f0=IExec(Wg,ts).f0 by Lm5,SCM_HALT:31
          .=t.f0 by A14,A11,A27,Lm17;
A29:    IW.b3=IExec(Wg,ts).b3 by Lm5,SCM_HALT:30
          .=ts.b3 by A14,A11,A27,Lm17
          .=k1+1 by Lm20;
        then
A30:    IW.b3<=len(IW.f0) by A11,A28,INT_1:20;
A31:    IW.b4=n+ts.b4 by A16,Lm5,SCM_HALT:30
          .=n+0 by Lm20
          .=n;

        then
A32:    IW.f0,IExec(T3,IW).f0 are_fiberwise_equipotent by A28,A29,A21,A12,Lm19;

A33:    n<IW.b3 by A17,A29,A20,XXREAL_0:2;

        then IW.f0, IB.f0 are_fiberwise_equipotent by A28,A24,A31,A29,A12,Lm19;

        then
A34:    len(IB.f0)=len(t.f0) by A28,RFINSEQ:16;
A35:    IB.b1=k+1-1 by A9,Lm9,Lm11,SCM_HALT:79
          .=k;
        then IB.b1<t.b1 by A9,XREAL_1:31;
        then
A36:    IB.b1<=len(IB.f0)-1 by A10,A34,XXREAL_0:2;
A37:    IExec(T3,IW).f0.mm=IW.f0.(k1+1) by A28,A31,A29,A21,A12,Lm19;
        hereby
A38:      IExec(T1,t).f0=IExec(T1,IB).f0 by A9,Lm9,Lm11,SCM_HALT:82;
          assume

A39:      for i,j be Element of NAT st i>=1 & j<=len(t.f0)-t.b1 & i<j
          for x1,x2 be Integer st x1 =t.f0.i & x2=t.f0.j holds x1 >= x2;

A40:      now
A41:        k1+1-n<=k1+1-0 by XREAL_1:15;
            then k1-n+1<=k1+1;
            then
A42:        k1-n<=k1 by XREAL_1:8;
            let i,j be Element of NAT;
            assume that
A43:        i>=1 and
A44:        j<=len(IB.f0)-IB.b1 and
A45:        i<j;
A46:        1<=j by A43,A45,XXREAL_0:2;
            len(IB.f0)-IB.b1=k1+1 by A9,A35,A34;
            then
A47:        j-1<=k1 by A44,XREAL_1:22;
A48:        1-1<=i-1 by A43,XREAL_1:11;
            then reconsider i1=i-1 as Element of NAT by INT_1:16;
A49:        i-1<j-1 by A45,XREAL_1:11;
            then reconsider j1=j-1 as Element of NAT by A48,INT_1:16;
            let y1,y2 be Integer;
            assume that
A50:        y1 =IB.f0.i and
A51:        y2=IB.f0.j;
            per cases by XXREAL_0:1;
            suppose
A52:          i<mm;
              then
A53:          y1=t.f0.i by A28,A24,A31,A29,A21,A30,A43,A50,Lm19;
              hereby
                per cases by XXREAL_0:1;
                suppose
A54:              j<mm;
                  then j<k1+1 by A41,XXREAL_0:2;
                  then
A55:              j<=k1 by INT_1:20;
                  y2=t.f0.j by A28,A24,A31,A29,A21,A30,A51,A46,A54,Lm19;
                  hence y1 >= y2 by A39,A43,A45,A53,A55;
                end;
                suppose
A56:              j>mm;
                  then mm+1<=j by INT_1:20;
                  then mm<=j1 by XREAL_1:21;
                  then
A57:              i<j1 by A52,XXREAL_0:2;

                  y2=t.f0.j1 by A9,A35,A28,A24,A31,A29,A21,A30,A34,A44,A51,A56
,Lm19;

                  hence y1 >= y2 by A39,A43,A47,A53,A57;
                end;
                suppose
A58:              j=mm;
A59:              i<k1-n+1 by A52;
                  then
A60:              i<=k1-n by INT_1:20;

A61:              y2=t.f0.(k1+1) by A28,A24,A31,A29,A33,A12,A51,A58,Lm19;

                  hereby
                    reconsider kn=k1-n as Element of NAT by A59,INT_1:16,20;
A62:                t.f0.kn=x1 by A18,A43,A60,Lm20,XXREAL_0:2;
                    per cases;
                    suppose
                      i=kn;

                      hence
                      y1>=y2 by A18,A28,A24,A31,A29,A21,A12,A25,A43,A50,A52,A61
,A62,Lm19;

                    end;
                    suppose
                      i<>kn;
                      then i<kn by A60,XXREAL_0:1;
                      then y1>=x1 by A26,A39,A43,A42,A53,XXREAL_0:2;

                      hence y1 >= y2 by A18,A28,A24,A25,A37,A43,A51,A58,A60,
XXREAL_0:2;

                    end;
                  end;
                end;
              end;
            end;
            suppose
A63:          i>mm;
              then mm+1<=i by INT_1:20;
              then 0<i1 by A22,XREAL_1:21;
              then
A64:          1+0<=i1 by INT_1:20;
              mm<j by A45,A63,XXREAL_0:2;

              then
A65:          y2=t.f0.j1 by A9,A35,A28,A24,A31,A29,A21,A30,A34,A44,A51,Lm19;

              i<=k1+1 by A9,A35,A34,A44,A45,XXREAL_0:2;
              then y1=t.f0.i1 by A28,A24,A31,A29,A21,A30,A50,A63,Lm19;
              hence y1 >= y2 by A39,A47,A49,A65,A64;
            end;
            suppose
A66:          i=mm;
              k1<k1+1 by XREAL_1:31;
              then
A67:          j1<k1+1 by A47,XXREAL_0:2;
              mm-1<j1 by A45,A66,XREAL_1:11;

              then
A68:          ex yy be Integer st yy=t.f0.j1 & yy <= n3 by A14,A19,A25,A67;

              y2=t.f0.j1 by A9,A35,A28,A24,A31,A29,A33,A30,A34,A44,A45,A51,A66
,Lm19;

              hence y1 >= y2 by A28,A24,A31,A29,A33,A30,A50,A66,A68,Lm19;
            end;
          end;

          then IB.f0, IExec(T1,IB).f0 are_fiberwise_equipotent by A8,A35,A36;

          hence t.f0, IExec(T1,t).f0 are_fiberwise_equipotent by A28,A24,A32
,A38,CLASSES1:84;

          let i,j be Element of NAT;
          assume that
A69:      i>=1 and
A70:      j<=len(t.f0) and
A71:      i<j;
          let x1,x2 be Integer;
          assume that
A72:      x1=IExec(T1,t).f0.i and
A73:      x2=IExec(T1,t).f0.j;
          j<=len(IB.f0) by A28,A24,A32,A70,RFINSEQ:16;
          hence x1>=x2 by A8,A35,A36,A40,A38,A69,A71,A72,A73;
        end;
      end;
      hence P[k+1];
    end;
A74: P[ 0]
    proof
      let t be State of SCM+FSA;
      assume that
A75:  t.b1=0 and
      t.b1 <= len (t.f0)-1;
      IExec(T1,t).f0=t.f0 by A75,Lm11,SCM_HALT:80;
      hence thesis by A75;
    end;
    for k be Element of NAT holds P[k] from NAT_1:sch 1(A74,A7);
    then
A76: P[m];

    then (for i,j be Element of NAT st i>=1 & j<=len(s.f0)-s.b1 & i<j for x1,

x2 be Integer st x1 =s.f0.i & x2=s.f0.j holds x1 >= x2) implies s.f0, IExec(T1,

s).f0 are_fiberwise_equipotent & for i,j be Element of NAT st i>=1 & j<=len(s.

f0) & i<j for x1,x2 be Integer st x1 =IExec(T1,s).f0.i & x2=IExec(T1,s).f0.j
    holds x1 >= x2 by A1;

    hence s.f0, IExec(T1,s).f0 are_fiberwise_equipotent by A1,XXREAL_0:2;

    for i,j be Element of NAT st i>=1 & j<=len(s.f0)-s.b1 & i<j for x1,
    x2 be Integer st x1 =s.f0.i & x2=s.f0.j holds x1 >= x2 by A1,XXREAL_0:2;

    hence thesis by A1,A76;
  end;
end;

theorem Th45:
  for s be State of SCM+FSA holds s.(fsloc 0), IExec(insert-sort (
fsloc 0),s).(fsloc 0) are_fiberwise_equipotent & for i,j be Element of NAT st i
>=1 & j<=len (s.(fsloc 0)) & i<j for x1,x2 be Integer st x1 =IExec(insert-sort
(fsloc 0),s).(fsloc 0).i & x2=IExec(insert-sort (fsloc 0),s).(fsloc 0).j holds
  x1 >= x2
proof
  let s be State of SCM+FSA;
  set WJ=w2 ';' w3 ';' w4 ';' w5 ';' w6 ';' j1 ';' j2, s0=Initialize s, s1=
Exec(w2, s0), s2=IExec(w2 ';' w3, s), s3=IExec(w2 ';' w3 ';' w4,s), s4=IExec(w2
';' w3 ';' w4 ';' w5,s), s5=IExec(w2 ';' w3 ';' w4 ';' w5 ';' w6,s), s6=IExec(
  w2 ';' w3 ';' w4 ';' w5 ';' w6 ';' j1,s), s7=IExec(WJ,s);
A1: s5.f0 =Exec(w6, s4).f0 by SCMFSA6C:8
    .=s4.f0 by SCMFSA_2:89
    .=Exec(w5, s3).f0 by SCMFSA6C:8
    .=s3.f0 by SCMFSA_2:89
    .=Exec(w4, s2).f0 by SCMFSA6C:8
    .=s2.f0 by SCMFSA_2:89
    .=Exec(w3, s1).f0 by SCMFSA6C:10
    .=s1.f0 by SCMFSA_2:89
    .=s0.f0 by SCMFSA_2:89
    .=s.f0 by SCMFSA6C:3;
A2: s6.f0 =Exec(j1, s5).f0 by SCMFSA6C:8
    .=s.f0 by A1,SCMFSA_2:100;
A3: IExec(WJ,s).f0 =Exec(j2, s6).f0 by SCMFSA6C:8
    .=s.f0 by A2,SCMFSA_2:91;
A4: IExec(insert-sort f0,s).f0=IExec(T1,s7).f0 by Lm12,SCM_HALT:31;
A5: s6.b1=Exec(j1, s5).b1 by SCMFSA6C:7
    .=len (s7.f0) by A1,A3,SCMFSA_2:100;
A6: s7.b1=Exec(j2, s6).b1 by SCMFSA6C:7
    .=s6.b1-s6.a0 by SCMFSA_2:91
    .=len (s7.f0) - 1 by A5,SCM_HALT:17;
  hence s.f0, IExec(insert-sort f0,s).f0 are_fiberwise_equipotent by A3,A4,Lm21
;
  let i,j be Element of NAT;
  assume that
A7: i>=1 and
A8: j<=len (s.f0) and
A9: i<j;
  thus thesis by A3,A6,A4,A7,A8,A9,Lm21;
end;

theorem Th46:
  for i being Element of NAT, s being State of SCM+FSA, w being
  FinSequence of INT st Initialized Insert-Sort-Algorithm +* ((fsloc 0) .--> w)
  c= s holds IC Comput(ProgramPart( s), s,i) in dom Insert-Sort-Algorithm
proof
  let i be Element of NAT, s be State of SCM+FSA,w be FinSequence of INT;
  set IS=Insert-Sort-Algorithm, Ii=Initialized IS;
  set x=((fsloc 0) .--> w);
  dom Ii misses dom x by SCMBSORT:46;
  then
A1: Ii c= Ii +* x by FUNCT_4:33;
  assume
  Ii +* x c= s;
  then Ii c= s by A1,XBOOLE_1:1;
  hence thesis by Lm12,SCM_HALT:def 1;
end;

theorem Th47:
  for s be State of SCM+FSA,t be FinSequence of INT st Initialized
  Insert-Sort-Algorithm +*(fsloc 0 .--> t) c= s holds ex u being FinSequence of
  REAL st t,u are_fiberwise_equipotent & u is non-increasing & u is FinSequence
  of INT & (Result s).(fsloc 0) = u
proof
  let s be State of SCM+FSA,t be FinSequence of INT;
  set Ia=Insert-Sort-Algorithm, p=Initialized Ia, x=fsloc 0 .--> t, z=IExec(
  insert-sort f0,s).f0;
  assume
A1: p+*x c= s;
  reconsider u=z as FinSequence of REAL by SCMBSORT:38;
  take u;
  dom x = { f0} by FUNCOP_1:19;
  then
A2: f0 in dom x by TARSKI:def 1;
  then f0 in dom (p+*x) by FUNCT_4:13;
  then s.f0=(p+*x).f0 by A1,GRFUNC_1:8
    .=x.f0 by A2,FUNCT_4:14
    .=t by FUNCOP_1:87;
  hence t, u are_fiberwise_equipotent by Th45;
  s.f0, z are_fiberwise_equipotent by Th45;
  then
A3: dom (s.f0) = dom u by RFINSEQ:16;
  now
    let i,j be Element of NAT;
    assume that
A4: i in dom u and
A5: j in dom u and
A6: i<j;
A7: i>=1 by A4,FINSEQ_3:27;
    j<=len (s.f0) by A3,A5,FINSEQ_3:27;
    hence u.i>=u.j by A6,A7,Th45;
    reconsider y2=z.j as Integer;
    reconsider y1=z.i as Integer;
  end;
  hence u is non-increasing by RFINSEQ:32;
  thus u is FinSequence of INT;
  dom p misses dom x by SCMBSORT:46;
  then p c=p+*x by FUNCT_4:33;
  then p c= s by A1,XBOOLE_1:1;
  then s=s+*p by FUNCT_4:79;
  hence thesis by SCMBSORT:57;
end;

theorem Th48:
  for w being FinSequence of INT holds Initialized
  Insert-Sort-Algorithm +* ((fsloc 0) .--> w) is autonomic
proof
  set DD={intloc 0,IC SCM+FSA,fsloc 0};
  let w be FinSequence of INT;
  set p=Initialized Insert-Sort-Algorithm +* ((fsloc 0) .--> w), q=
  Insert-Sort-Algorithm;
  set UD={fsloc 0,a0,a1,a2,a3,a4,a5,a6}, Us=UsedInt*Loc q \/ UsedIntLoc q;
A1: UsedIntLoc q ={a0,a1,a2,a3,a4,a5,a6} by Th38;
A2: UsedInt*Loc q ={fsloc 0} by Th39;
  then
A3: Us = UD by A1,ENUMSET1:62;
A4: for i being Element of NAT,s1,s2 being State of SCM+FSA st 11 <= i & p
  c= s1 & p c= s2 holds Comput(ProgramPart( s1), s1,i) | Us = Comput(
ProgramPart( s2), s2,i) | Us &
  Comput(ProgramPart( s1), s1,i).IC SCM+FSA = Comput(ProgramPart( s2), s2,i).IC
SCM+FSA
  proof
    let i be Element of NAT,s1,s2 be State of SCM+FSA such that
A5: 11 <= i and
A6: p c= s1 and
A7: p c= s2;
A8: s1.intloc 0 =1 by A6,SCMBSORT:54
      .= s2.intloc 0 by A7,SCMBSORT:54;
A9: s2 starts_at 0 by A7,AMI_1:92,SCMBSORT:47;
A10: q c= s2 by A7,SCMBSORT:53;
    set Cs11= Comput(ProgramPart( s1), s1,11), Cs21= Comput(ProgramPart( s2),
s2,11);
A11: s1 starts_at 0 by A6,AMI_1:92,SCMBSORT:47;
A12: q c= s1 by A6,SCMBSORT:53;
A13: s1.fsloc 0 =w by A6,SCMBSORT:54
      .=s2.fsloc 0 by A7,SCMBSORT:54;
A14: now
      let x be set;
      assume
      x in Us;
      then
A15:  x in UD by A2,A1,ENUMSET1:62;
      per cases by A15,ENUMSET1:def 6;
      suppose
A16:    x = fsloc 0;
        hence Cs11.x =s1.fsloc 0 by A11,A12,Lm2
          .=Cs21.x by A9,A10,A13,A16,Lm2;
      end;
      suppose
A17:    x = a0;
        hence Cs11.x =s1.a0 by A11,A12,Lm2
          .=Cs21.x by A9,A10,A8,A17,Lm2;
      end;
      suppose
A18:    x = a1;
        hence Cs11.x=len(s1.fsloc 0) by A11,A12,Lm2
          .=Cs21.x by A9,A10,A13,A18,Lm2;
      end;
      suppose
A19:    x = a2;
        hence Cs11.x=s1.a0 by A11,A12,Lm2
          .=Cs21.x by A9,A10,A8,A19,Lm2;
      end;
      suppose
A20:    x = a3;
        hence Cs11.x=s1.a0 by A11,A12,Lm2
          .=Cs21.x by A9,A10,A8,A20,Lm2;
      end;
      suppose
A21:    x = a4;
        hence Cs11.x=s1.a0 by A11,A12,Lm2
          .=Cs21.x by A9,A10,A8,A21,Lm2;
      end;
      suppose
A22:    x = a5;
        hence Cs11.x=s1.a0 by A11,A12,Lm2
          .=Cs21.x by A9,A10,A8,A22,Lm2;
      end;
      suppose
A23:    x = a6;
        hence Cs11.x=s1.a0 by A11,A12,Lm2
          .=Cs21.x by A9,A10,A8,A23,Lm2;
      end;
    end;
A24: for i holds IC Comput(ProgramPart( s2), s2,i) in dom q by A7,Th46;
A25: for i holds IC Comput(ProgramPart( s1), s1,i) in dom q by A6,Th46;
A26: Us c= dom(Cs21) by SCMBSORT:56;
    Us c= dom(Cs11) by SCMBSORT:56;
    then
A27: Cs11 | Us = Cs21 | Us by A26,A14,FUNCT_1:165;
    Cs11.IC SCM+FSA =  11 by A11,A12,Lm2
      .=Cs21.IC SCM+FSA by A9,A10,Lm2;
    hence thesis by A5,A12,A10,A27,A25,A24,SCMBSORT:26;
  end;
A28: for s1,s2 being State of SCM+FSA,i st p c= s1 & p c= s2 & i <= 10 holds
Comput(ProgramPart( s1), s1,i).intloc 0 = Comput(ProgramPart( s2), s2,i).intloc
0 & Comput(ProgramPart( s1), s1,i).
  IC SCM+FSA = Comput(ProgramPart( s2), s2,i).IC SCM+FSA & Comput(ProgramPart(
s1), s1,i).fsloc 0 =
  Comput(ProgramPart( s2), s2,i).fsloc 0
  proof
    let s1,s2 be State of SCM+FSA,i;
    assume that
A29: p c= s1 and
A30: p c=s2 and
A31: i <= 10;
A32: s2 starts_at 0 by A30,AMI_1:92,SCMBSORT:47;
A33: s1.fsloc 0 =w by A29,SCMBSORT:54
      .=s2.fsloc 0 by A30,SCMBSORT:54;
A34: s1.intloc 0 =1 by A29,SCMBSORT:54
      .= s2.intloc 0 by A30,SCMBSORT:54;
A35: Comput(ProgramPart(s1),s1,0) = s1 by AMI_1:13;
A36: q c=s2 by A30,SCMBSORT:53;
A37: s1 starts_at 0 by A29,AMI_1:92,SCMBSORT:47;
    then
A38: IC s1 =  0 by AMI_1:def 41
      .= IC s2 by A32,AMI_1:def 41;
A39: q c= s1 by A29,SCMBSORT:53;
    per cases by A31,NAT_1:35;
    suppose
A40:  i = 0;
      hence
      Comput(ProgramPart(s1),s1,i).intloc 0 = Comput(ProgramPart(s2),s2,i).
intloc 0 by A35,A34,AMI_1:13;
      thus (Comput(ProgramPart(s1),s1,i)).IC SCM+FSA = (Comput(ProgramPart(s2),
s2,i)).IC SCM+FSA by A35,A38,A40,AMI_1:13;
      thus thesis by A35,A33,A40,AMI_1:13;
    end;
    suppose
A41:  i = 1;
      hence Comput(ProgramPart(s1),s1,i).intloc 0 = s1.intloc 0 by A37,A39,Lm2
        .= Comput(ProgramPart(s2),s2,i).intloc 0 by A32,A36,A34,A41,Lm2;
      thus (Comput(ProgramPart(s1),s1,i)).IC SCM+FSA =  1 by A37,A39,A41,Lm2
        .= (Comput(ProgramPart(s2),s2,i)).IC SCM+FSA by A32,A36,A41,Lm2;
      thus Comput(ProgramPart(s1),s1,i).fsloc 0 = s1.fsloc 0 by A37,A39,A41,Lm2
        .= Comput(ProgramPart(s2),s2,i).fsloc 0 by A32,A36,A33,A41,Lm2;
    end;
    suppose
A42:  i = 2;
      hence Comput(ProgramPart(s1),s1,i).intloc 0 = s1.intloc 0 by A37,A39,Lm2
        .= Comput(ProgramPart(s2),s2,i).intloc 0 by A32,A36,A34,A42,Lm2;
      thus (Comput(ProgramPart(s1),s1,i)).IC SCM+FSA =  2 by A37,A39,A42,Lm2
        .= (Comput(ProgramPart(s2),s2,i)).IC SCM+FSA by A32,A36,A42,Lm2;
      thus Comput(ProgramPart(s1),s1,i).fsloc 0 = s1.fsloc 0 by A37,A39,A42,Lm2
        .= Comput(ProgramPart(s2),s2,i).fsloc 0 by A32,A36,A33,A42,Lm2;
    end;
    suppose
A43:  i = 3;
      hence Comput(ProgramPart(s1),s1,i).intloc 0 = s1.intloc 0 by A37,A39,Lm2
        .= Comput(ProgramPart(s2),s2,i).intloc 0 by A32,A36,A34,A43,Lm2;
      thus (Comput(ProgramPart(s1),s1,i)).IC SCM+FSA =  3 by A37,A39,A43,Lm2
        .= (Comput(ProgramPart(s2),s2,i)).IC SCM+FSA by A32,A36,A43,Lm2;
      thus Comput(ProgramPart(s1),s1,i).fsloc 0 = s1.fsloc 0 by A37,A39,A43,Lm2
        .= Comput(ProgramPart(s2),s2,i).fsloc 0 by A32,A36,A33,A43,Lm2;
    end;
    suppose
A44:  i = 4;
      hence Comput(ProgramPart(s1),s1,i).intloc 0 = s1.intloc 0 by A37,A39,Lm2
        .= Comput(ProgramPart(s2),s2,i).intloc 0 by A32,A36,A34,A44,Lm2;
      thus (Comput(ProgramPart(s1),s1,i)).IC SCM+FSA =  4 by A37,A39,A44,Lm2
        .= (Comput(ProgramPart(s2),s2,i)).IC SCM+FSA by A32,A36,A44,Lm2;
      thus Comput(ProgramPart(s1),s1,i).fsloc 0 = s1.fsloc 0 by A37,A39,A44,Lm2
        .= Comput(ProgramPart(s2),s2,i).fsloc 0 by A32,A36,A33,A44,Lm2;
    end;
    suppose
A45:  i = 5;
      hence Comput(ProgramPart(s1),s1,i).intloc 0 = s1.intloc 0 by A37,A39,Lm2
        .= Comput(ProgramPart(s2),s2,i).intloc 0 by A32,A36,A34,A45,Lm2;
      thus (Comput(ProgramPart(s1),s1,i)).IC SCM+FSA =  5 by A37,A39,A45,Lm2
        .= (Comput(ProgramPart(s2),s2,i)).IC SCM+FSA by A32,A36,A45,Lm2;
      thus Comput(ProgramPart(s1),s1,i).fsloc 0 = s1.fsloc 0 by A37,A39,A45,Lm2
        .= Comput(ProgramPart(s2),s2,i).fsloc 0 by A32,A36,A33,A45,Lm2;
    end;
    suppose
A46:  i = 6;
      hence Comput(ProgramPart(s1),s1,i).intloc 0 = s1.intloc 0 by A37,A39,Lm2
        .= Comput(ProgramPart(s2),s2,i).intloc 0 by A32,A36,A34,A46,Lm2;
      thus (Comput(ProgramPart(s1),s1,i)).IC SCM+FSA =  6 by A37,A39,A46,Lm2
        .= (Comput(ProgramPart(s2),s2,i)).IC SCM+FSA by A32,A36,A46,Lm2;
      thus Comput(ProgramPart(s1),s1,i).fsloc 0 = s1.fsloc 0 by A37,A39,A46,Lm2
        .= Comput(ProgramPart(s2),s2,i).fsloc 0 by A32,A36,A33,A46,Lm2;
    end;
    suppose
A47:  i = 7;
      hence Comput(ProgramPart(s1),s1,i).intloc 0 = s1.intloc 0 by A37,A39,Lm2
        .= Comput(ProgramPart(s2),s2,i).intloc 0 by A32,A36,A34,A47,Lm2;
      thus (Comput(ProgramPart(s1),s1,i)).IC SCM+FSA =  7 by A37,A39,A47,Lm2
        .= (Comput(ProgramPart(s2),s2,i)).IC SCM+FSA by A32,A36,A47,Lm2;
      thus Comput(ProgramPart(s1),s1,i).fsloc 0 = s1.fsloc 0 by A37,A39,A47,Lm2
        .= Comput(ProgramPart(s2),s2,i).fsloc 0 by A32,A36,A33,A47,Lm2;
    end;
    suppose
A48:  i = 8;
      hence Comput(ProgramPart(s1),s1,i).intloc 0 = s1.intloc 0 by A37,A39,Lm2
        .= Comput(ProgramPart(s2),s2,i).intloc 0 by A32,A36,A34,A48,Lm2;
      thus (Comput(ProgramPart(s1),s1,i)).IC SCM+FSA =  8 by A37,A39,A48,Lm2
        .= (Comput(ProgramPart(s2),s2,i)).IC SCM+FSA by A32,A36,A48,Lm2;
      thus Comput(ProgramPart(s1),s1,i).fsloc 0 = s1.fsloc 0 by A37,A39,A48,Lm2
        .= Comput(ProgramPart(s2),s2,i).fsloc 0 by A32,A36,A33,A48,Lm2;
    end;
    suppose
A49:  i = 9;
      hence Comput(ProgramPart(s1),s1,i).intloc 0 = s1.intloc 0 by A37,A39,Lm2
        .= Comput(ProgramPart(s2),s2,i).intloc 0 by A32,A36,A34,A49,Lm2;
      thus (Comput(ProgramPart(s1),s1,i)).IC SCM+FSA =  9 by A37,A39,A49,Lm2
        .= (Comput(ProgramPart(s2),s2,i)).IC SCM+FSA by A32,A36,A49,Lm2;
      thus Comput(ProgramPart(s1),s1,i).fsloc 0 = s1.fsloc 0 by A37,A39,A49,Lm2
        .= Comput(ProgramPart(s2),s2,i).fsloc 0 by A32,A36,A33,A49,Lm2;
    end;
    suppose
A50:  i = 10;
      hence Comput(ProgramPart(s1),s1,i).intloc 0 = s1.intloc 0 by A37,A39,Lm2
        .= Comput(ProgramPart(s2),s2,i).intloc 0 by A32,A36,A34,A50,Lm2;
      thus (Comput(ProgramPart(s1),s1,i)).IC SCM+FSA =  10 by A37,A39,A50,Lm2
        .= (Comput(ProgramPart(s2),s2,i)).IC SCM+FSA by A32,A36,A50,Lm2;
      thus Comput(ProgramPart(s1),s1,i).fsloc 0 = s1.fsloc 0 by A37,A39,A50,Lm2
        .= Comput(ProgramPart(s2),s2,i).fsloc 0 by A32,A36,A33,A50,Lm2;
    end;
  end;
A51: dom p = dom q \/ DD by SCMBSORT:42;
  now
    let s1,s2 be State of SCM+FSA,i;
    assume that
A52: p c= s1 and
A53: p c=s2;
    set Cs1i= Comput(ProgramPart( s1), s1,i), Cs2i= Comput(ProgramPart( s2), s2
,i);
A54: Us c= dom(Cs1i) by SCMBSORT:56;
A55: q c=s2 by A53,SCMBSORT:53;
    q c= s1 by A52,SCMBSORT:53;
    then
A56: Cs1i | dom q = Cs2i| dom q by A55,AMI_1:124;
A57: fsloc 0 in Us by A3,ENUMSET1:def 6;
A58: Us c= dom(Cs2i) by SCMBSORT:56;
A59: i>10 implies 10+1 < i+1 by XREAL_1:8;
A60: intloc 0 in Us by A3,ENUMSET1:def 6;
A61: now
      let x be set;
      assume
A62:  x in DD;
      per cases by A62,ENUMSET1:def 1;
      suppose
A63:    x=intloc 0;
        now
          per cases;
          suppose
            i<=10;
            hence Cs1i.x=Cs2i.x by A28,A52,A53,A63;
          end;
          suppose
            i>10;
            then 11 <= i by A59,NAT_1:13;
            then Cs1i | Us = Cs2i | Us by A4,A52,A53;
            hence Cs1i.x=Cs2i.x by A60,A54,A58,A63,FUNCT_1:165;
          end;
        end;
        hence Cs1i.x=Cs2i.x;
      end;
      suppose
A64:    x=IC SCM+FSA;
        now
          per cases;
          suppose
            i<=10;
            hence Cs1i.x=Cs2i.x by A28,A52,A53,A64;
          end;
          suppose
            i>10;
            then 11 <= i by A59,NAT_1:13;
            hence Cs1i.x=Cs2i.x by A4,A52,A53,A64;
          end;
        end;
        hence Cs1i.x=Cs2i.x;
      end;
      suppose
A65:    x=fsloc 0;
        now
          per cases;
          suppose
            i<=10;
            hence Cs1i.x=Cs2i.x by A28,A52,A53,A65;
          end;
          suppose
            i>10;
            then 11 <= i by A59,NAT_1:13;
            then Cs1i | Us = Cs2i | Us by A4,A52,A53;
            hence Cs1i.x=Cs2i.x by A57,A54,A58,A65,FUNCT_1:165;
          end;
        end;
        hence Cs1i.x=Cs2i.x;
      end;
    end;
A66: DD c= dom Cs2i by SCMBSORT:55;
    DD c= dom Cs1i by SCMBSORT:55;
    then Cs1i | DD = Cs2i| DD by A66,A61,FUNCT_1:165;
    hence Cs1i| dom p = Cs2i | dom p by A51,A56,RELAT_1:185;
  end;
  then for s1,s2 being State of SCM+FSA st p c= s1 & p c= s2 for i holds
  Comput(ProgramPart( s1), s1,i)|dom p = Comput(ProgramPart( s2), s2,i)|dom p;
  hence thesis by AMI_1:def 25;
end;

theorem
  Initialized Insert-Sort-Algorithm computes Sorting-Function
proof
  set p = Initialized Insert-Sort-Algorithm;
  let x be set;
  assume
  x in dom Sorting-Function;
  then consider w being FinSequence of INT such that
A1: x = fsloc 0 .--> w by SCMBSORT:60;
  reconsider s = x as FinPartState of SCM+FSA by A1;
  consider t being State of SCM+FSA such that
A2: p +* s c= t by PBOOLE:156;
A3: dom p misses dom s by A1,SCMBSORT:46;
A4: now
    set bf=insert-sort fsloc 0;
    let t be State of SCM+FSA;
    assume
A5: p+*s c= t;
    p c=p+*s by A3,FUNCT_4:33;
    then p c= t by A5,XBOOLE_1:1;
    hence ProgramPart t halts_on t by Lm12,AMI_1:def 26;
  end;
  then
A6: p +* s is halting by AMI_1:def 26;
  take s;
  thus x = s;
  s c= p +* s by FUNCT_4:26;
  then
A7: dom s c= dom(p +* s) by RELAT_1:25;
  thus p +* s is pre-program of SCM+FSA by A1,A4,Th48,AMI_1:def 26;
  fsloc 0 in the carrier of SCM+FSA;
  then
A8: fsloc 0 in dom Result t by PARTFUN1:def 4;
  p +* s is autonomic by A1,Th48;
  then
A9: Result(p +* s) = (Result t)|dom(p +* s) by A6,A2,AMI_1:def 28;
A10: dom s = { fsloc 0 } by A1,FUNCOP_1:19;
  consider u being FinSequence of REAL such that
A11: w,u are_fiberwise_equipotent and
A12: u is non-increasing and
  u is FinSequence of INT and
A13: (Result t).(fsloc 0) = u by A1,A2,Th47;
  consider z being FinSequence of REAL such that
A14: w,z are_fiberwise_equipotent and
A15: z is non-increasing and
  z is FinSequence of INT and
A16: Sorting-Function.s = fsloc 0 .--> z by A1,SCMBSORT:61;
A17: dom(fsloc 0 .--> z) = { fsloc 0 } by FUNCOP_1:19;
  u=z by A14,A15,A11,A12,CLASSES1:84,RFINSEQ:36;
  hence thesis by A10,A16,A13,A8,A7,A17,A9,FUNCT_4:90,RELAT_1:186;
end;

