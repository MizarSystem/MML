:: Insert Sort on SCM+FSA
::  by JingChao Chen
::
:: Received March 13, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies NUMBERS, SCMFSA7B, AMI_1, SCMFSA_2, SCMFSA6A, CARD_1, SF_MASTR,
      AMI_3, SCMNORM, RELAT_1, FUNCT_1, FUNCT_4, FUNCOP_1, FINSUB_1, CARD_3,
      SUBSET_1, TARSKI, SCMFSA8B, TURING_1, SCMFSA8A, AMISTD_2, ARYTM_3,
      VALUED_1, XBOOLE_0, FSM_1, SCMFSA_9, SCMFSA6C, SCMFSA6B, CIRCUIT2,
      GRAPHSP, MSUALG_1, SCM_HALT, FUNCT_7, XXREAL_0, UNIALG_2, NAT_1,
      SCMFSA8C, FINSEQ_1, ARYTM_1, GLIB_000, INT_1, COMPLEX1, PARTFUN1,
      CLASSES1, VALUED_0, SCMBSORT, STRUCT_0, SCMISORT, PBOOLE, ORDINAL1,
      RELOC;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      FUNCOP_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4, FUNCT_7,
      FINSEQ_1, CARD_3, VALUED_1, PBOOLE, STRUCT_0, COMPOS_1,
      EXTPRO_1, AMI_1,
      AMISTD_2, SCMFSA_2,
      SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SCMFSA_9, SCMFSA8B, INT_1, SCMBSORT, FINSUB_1, SCMFSA8C,
      CLASSES1, RFINSEQ, SCM_HALT, INT_2, NAT_1, XXREAL_0;
 constructors DOMAIN_1, SETWISEO, XXREAL_0, REAL_1, SEQ_1, INT_2,
      SCMFSA6A, SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA8C,
      SCMFSA_9, SFMASTR1, SCM_HALT, SCMBSORT, CLASSES1, AMISTD_2,
      RELSET_1, PRE_POLY, PBOOLE, SCMFSA7B, AMI_1, AMISTD_1;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, RELSET_1, FUNCOP_1, FINSUB_1,
      NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, STRUCT_0, SCMFSA_2,
      SF_MASTR, SCMFSA8C, SCMFSA6C, SCMFSA8A, SCMFSA_9, SCM_HALT, VALUED_0,
      ORDINAL1, FINSET_1, VALUED_1, FUNCT_2, FUNCT_4, RELAT_1, AMI_1,
      AMISTD_2, SCMFSA10, SCMFSA6A, COMPOS_1, SFMASTR1, EXTPRO_1, PBOOLE;
 requirements BOOLE, REAL, NUMERALS, SUBSET, ARITHM;
 definitions AMI_1, EXTPRO_1, COMPOS_1, FUNCOP_1, PBOOLE, AMISTD_2, SCMFSA6A;
 theorems SF_MASTR, FUNCT_1, FUNCT_7, FUNCOP_1, RELAT_1, AMI_1, FUNCT_2,
      SCMFSA6A, FUNCT_4, FINSEQ_3, ENUMSET1, NAT_1, TARSKI, INT_1,
      GRFUNC_1, RFINSEQ, SCMFSA_2, SCMFSA6B, SCMFSA7B, SCMFSA8B, SCMFSA8A,
      SCMFSA8C, SCMFSA_4, SCMFSA6C, SCM_HALT, ABSVALUE, FINSEQ_4, SCMBSORT,
      SCMFSA_9, SCMFSA9A, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1,
      XXREAL_0, VALUED_1, CLASSES1, PBOOLE, PARTFUN1, AFINSQ_1,
      ZFMISC_1, SCMFSA10, COMPOS_1, EXTPRO_1, AMISTD_2;
 schemes NAT_1;

begin :: Preliminaries

canceled;

theorem
  for p be preProgram of SCM+FSA,l be Element of NAT,
  ic be Instruction of SCM+FSA st l in dom p &
  (ex pc be Instruction of SCM+FSA st pc=p.l & UsedIntLoc pc=UsedIntLoc ic)
   holds UsedIntLoc p = UsedIntLoc (p+*(l.-->ic))
proof
  let p be preProgram of SCM+FSA,l be Element of NAT, ic be
  Instruction of SCM+FSA;
  set pl=p+*(l.-->ic);
  assume that
A1: l in dom p and
A2: ex pc be Instruction of SCM+FSA st pc=p.l & UsedIntLoc pc=
  UsedIntLoc ic;
  consider UIL being Function of the Instructions of SCM+FSA,Fin Int-Locations
  such that
A3: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A4: UsedIntLoc p = Union (UIL * p) by SF_MASTR:def 2;
  set f = UIL * p, g = UIL * pl;
  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A5: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A6: UsedIntLoc pl = Union (UIL2 * pl) by SF_MASTR:def 2;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A3
      .= UIL2.c by A5;
  end;
  then
A7: UIL=UIL2 by FUNCT_2:113;
A8: pl.l=(p+*(l,ic)).l by A1,FUNCT_7:def 3
    .=ic by A1,FUNCT_7:33;
  now
A9: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
    then rng p c= dom UIL by RELAT_1:def 19;
    then
A10: dom f = dom p by RELAT_1:46;
A11: dom p = dom pl by A1,FUNCT_7:114;
A12: rng pl c= dom UIL by A9,RELAT_1:def 19;
    hence dom f = dom g by A11,A10,RELAT_1:46;
    let x be set;
    assume
A13: x in dom f;
    then pl.x in rng pl by A11,A10,FUNCT_1:def 5;
    then reconsider plx = pl.x as Instruction of SCM+FSA by A12,FUNCT_2:def 1;
    per cases;
    suppose
      x<>l;
      then not x in {l} by TARSKI:def 1;
      then not x in dom (l.-->ic) by FUNCOP_1:19;
      then p.x=pl.x by FUNCT_4:12;
      hence f.x = UIL.plx by A13,FUNCT_1:22
        .= g.x by A11,A10,A13,FUNCT_1:23;
    end;
    suppose
A14:  x=l;
      thus f.x = UIL.(p.x) by A13,FUNCT_1:22
        .= UsedIntLoc plx by A2,A8,A3,A14
        .= UIL.plx by A5,A7
        .= g.x by A11,A10,A13,FUNCT_1:23;
    end;
  end;
  hence thesis by A4,A6,A7,FUNCT_1:9;
end;

theorem
  for a being Int-Location,I being Program of SCM+FSA
   holds if>0(a, I';' Goto  0,Stop SCM+FSA).(card I +4) = goto  (card I +4)
proof
  let a be Int-Location,I be Program of SCM+FSA;
  set I4=card I +4, Lc4=I4, Gi= Goto  0, SS=Stop SCM+FSA, I1=I ';' Gi, F
=if>0(a, I1, SS), i=a>0_goto  (card SS + 3),
      MM=i ';' SS ';' Goto (card I1 + 1) ';' I, GS=Gi ';' SS;
A1: I4 < card I + 6 by XREAL_1:8;
  card F=card I +6 by SCMFSA_9:2;
  then
A2: Lc4 in dom F by A1,AFINSQ_1:70;
A3:  0 + I4 =  ( 0 + I4);
A4: Gi. 0=goto  0 by SCMFSA8A:47;
A5:  0 in dom Gi by SCMFSA8A:47;
  then
A6: GS. 0 = (Directed Gi). 0 by SCMFSA8A:28
    .=goto  0 by A5,A4,SCMFSA8A:30;
A7: card Stop SCM+FSA = 1 by COMPOS_1:46;
  card GS=card Gi + card SS by SCMFSA6A:61
    .=1 + 1 by A7,SCMFSA8A:29
    .=2;
  then
A8:  0 in dom GS by AFINSQ_1:70;
  then  0 + I4 in { il+I4 where il is Element of NAT: il in dom GS};
  then
A9: Lc4 in dom Shift(GS,I4) by VALUED_1:def 12;
  then
A10: Shift(GS,I4)/.Lc4 = Shift(GS,I4).( 0 +I4) by PARTFUN1:def 8
    .= goto  0 by A6,A8,VALUED_1:def 12;
A11: card Stop SCM+FSA = 1 by COMPOS_1:46;
A12: card MM = card (i ';' SS ';' Goto  (card I1 + 1)) + card I by SCMFSA6A:61
    .= card (i ';' SS ';' Goto  (card I1 + 1)) + card I
    .= card (i ';' SS) + card Goto  (card I1 + 1) + card I by SCMFSA6A:61
    .= card (i ';' SS) + 1 + card I by SCMFSA8A:29
    .= 2 + 1 + 1 + card I by A11,SCMFSA6A:75
    .=I4;
  then
A13: not Lc4 in dom MM by AFINSQ_1:70;
A14: F= i ';' SS ';' Goto  (card I1 + 1) ';' I1 ';' SS by SCMFSA8B:def 2
    .=MM ';' Gi ';' SS by SCMFSA6A:67
    .=MM ';' GS by SCMFSA6A:67
    .= Directed MM +* Reloc(GS, I4) by A12,SCMFSA6A:def 5;
  then
A15: dom F = dom Directed MM \/ dom Reloc(GS, I4) by FUNCT_4:def 1;
   then dom F = dom Directed(MM, card MM) \/ dom Reloc(GS, I4)
                   by SCMFSA6A:def 2
        .= dom(MM +~ (halt SCM+FSA,goto card MM))
              \/ dom Reloc(GS, I4) by SCMFSA6A:def 1
        .= dom MM \/ dom Reloc(GS, I4) by FUNCT_4:105;
  then Lc4 in dom Reloc(GS, I4) by A2,A13,XBOOLE_0:def 3;
  hence F.Lc4 = (Reloc(GS,I4)).Lc4 by A2,A14,A15,FUNCT_4:def 1
    .= Reloc(GS,I4).Lc4
    .= Reloc(GS,I4).Lc4
    .= IncAddr(goto  0, I4 ) by A9,A10,COMPOS_1:def 40
    .= goto  I4 by A3,SCMFSA_4:14;
end;

theorem
  for p be preProgram of SCM+FSA,l be Element of NAT,
  ic be Instruction of SCM+FSA st l in dom p & (ex pc be Instruction of SCM+FSA
st pc=p.l & UsedInt*Loc pc=UsedInt*Loc ic) holds UsedInt*Loc p = UsedInt*Loc (p
  +*(l.-->ic))
proof
  let p be preProgram of SCM+FSA,l be Element of NAT,ic be
  Instruction of SCM+FSA;
  set pl=p+*(l.-->ic);
  assume that
A1: l in dom p and
A2: ex pc be Instruction of SCM+FSA st pc=p.l & UsedInt*Loc pc=
  UsedInt*Loc ic;
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A4: UsedInt*Loc p = Union (UIL * p) by SF_MASTR:def 4;
  set f = UIL * p, g = UIL * pl;
  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A5: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A6: UsedInt*Loc pl = Union (UIL2 * pl) by SF_MASTR:def 4;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A3
      .= UIL2.c by A5;
  end;
  then
A7: UIL=UIL2 by FUNCT_2:113;
A8: pl.l=(p+*(l,ic)).l by A1,FUNCT_7:def 3
    .=ic by A1,FUNCT_7:33;
  now
A9: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
    then rng p c= dom UIL by RELAT_1:def 19;
    then
A10: dom f = dom p by RELAT_1:46;
A11: dom p = dom pl by A1,FUNCT_7:114;
A12: rng pl c= dom UIL by A9,RELAT_1:def 19;
    hence dom f = dom g by A11,A10,RELAT_1:46;
    let x be set;
    assume
A13: x in dom f;
    then pl.x in rng pl by A11,A10,FUNCT_1:def 5;
    then reconsider plx = pl.x as Instruction of SCM+FSA by A12,FUNCT_2:def 1;
    per cases;
    suppose
      x<>l;
      then not x in {l} by TARSKI:def 1;
      then not x in dom (l.-->ic) by FUNCOP_1:19;
      then p.x=pl.x by FUNCT_4:12;
      hence f.x = UIL.plx by A13,FUNCT_1:22
        .= g.x by A11,A10,A13,FUNCT_1:23;
    end;
    suppose
A14:  x=l;
      thus f.x = UIL.(p.x) by A13,FUNCT_1:22
        .= UsedInt*Loc plx by A2,A8,A3,A14
        .= UIL.plx by A5,A7
        .= g.x by A11,A10,A13,FUNCT_1:23;
    end;
  end;
  hence thesis by A4,A6,A7,FUNCT_1:9;
end;

reserve s for State of SCM+FSA,
  I for Program of SCM+FSA,
  a for read-write
  Int-Location;

reserve i,j,k,n for Element of NAT;

canceled;

theorem Th6:
  for s be State of SCM+FSA,I be Program of SCM+FSA st s.intloc 0=1
  & IC s =  0 holds s +* I = s +* Initialized I
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  assume that
A1: s.intloc 0=1 and
A2: IC s =  0;
A3: IC SCM+FSA in dom s by COMPOS_1:9;
  thus s +* Initialized I = s +* Initialize I
  by A1,SCMFSA8C:18
    .= Initialize(s +* I) by FUNCT_4:15
    .= Initialize s +* I by COMPOS_1:83
    .= s +* I by A2,A3,FUNCT_7:111;
end;

theorem Th7:
  for I being Program of SCM+FSA,a,b being Int-Location st I
  does not destroy b holds while>0(a,I) does not destroy b
proof
  let I be Program of SCM+FSA,a,b be Int-Location;
  set J= (card I +4) .--> goto  0, Gi= Goto  0, SS=Stop
  SCM+FSA, F=if>0(a, I ';' Gi, SS);
A1: Gi does not destroy b by SCMFSA8C:86;
A2: SS does not destroy b by SCMFSA8C:85;
  assume I does not destroy b;
  then I ';' Gi does not destroy b by A1,SCMFSA8C:81;
  then
A3: F does not destroy b by A2,SCMFSA8C:121;
A4: while>0(a,I) = F+*J by SCMFSA_9:def 2;
  J does not destroy b by SCMFSA_9:35;
  hence thesis by A3,A4,SCMFSA8A:25;
end;

canceled 2;

reserve P,P1,P2,Q
 for (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;

theorem Th10:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_halting_on Initialized s,P holds for a be Int-Location
   holds IExec(I,P,s).a =
Comput(P +* I,(Initialized s +* (Initialize I)),
  LifeSpan(P +* I,Initialized s +* (Initialize I))).a
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  set s0 = Initialized s, s1 = s0 +* (Initialize I), A = NAT,
      P1 = P +* I;
A1: ProgramPart I = I by RELAT_1:209;
  assume I is_halting_on s0,P;
  then
A2: P1 halts_on s1 by SCMFSA7B:def 8,A1;
  hereby
    let a be Int-Location;
    not a in A by SCMFSA_2:84;
    then not a in dom s /\ A by XBOOLE_0:def 4;
    then
A3: not a in dom (s | A) by RELAT_1:90;
    s +* Initialized I = s1 by SCMFSA8A:13;
    hence IExec(I,P,s).a = (Result(P1,s1) +* s | A).a by SCMFSA6B:def 1
      .= (Result(P1,s1)).a by A3,FUNCT_4:12
      .= Comput(P1, s1,LifeSpan(P1,s1)).a by A2,EXTPRO_1:23;
  end;
end;

theorem Th11: ::SCMFSA6B_28
  for s1,s2 be State of SCM+FSA,I be InitHalting Program of
SCM+FSA st Initialized I c= s1 & Initialized I c= s2 &
 I c= P1 & I c= P2 &
 s1,s2 equal_outside NAT
 for k be Element of NAT
  holds Comput(P1, s1,k), Comput(P2, s2,k) equal_outside NAT &
   CurInstr(P1,Comput(P1,s1,k))
   = CurInstr(P2,Comput(P2,s2,k))
proof
  let s1,s2 be State of SCM+FSA,I be InitHalting Program of SCM+FSA;
  assume that
A1: Initialized I c= s1 and
A2: Initialized I c= s2 and
A3: I c= P1 and
A4: I c= P2 and
A5: s1,s2 equal_outside NAT;
  hereby
    let k be Element of NAT;
A6: IC Comput(P1,s1,k) in dom I by A1,SCM_HALT:def 1,A3;
A7: IC Comput(P2,s2,k) in dom I by A2,SCM_HALT:def 1,A4;
    for m being Element of NAT st m < k holds IC(Comput(P2,s2,m))
in dom
    I by A2,SCM_HALT:def 1,A4;
    hence Comput(P1,s1,k), Comput(P2,s2,k) equal_outside NAT
     by A5,AMISTD_2:66,A3,A4;
    then
A8: IC Comput(P1,s1,k) = IC Comput(P2, s2,k) by
COMPOS_1:24;
    thus CurInstr(P2,Comput(P2,s2,k))
     = P2.IC Comput(P2, s2,k) by PBOOLE:158
      .= I.IC Comput(P2,s2,k) by A7,GRFUNC_1:8,A4
      .= P1.IC Comput(P1,s1,k) by A8,A6,GRFUNC_1:8,A3
      .= CurInstr(P1,Comput(P1,s1,k))
      by PBOOLE:158;
  end;
end;

theorem Th12: ::SCMFSA6B_29
  for s1,s2 be State of SCM+FSA,I be InitHalting Program of
SCM+FSA st Initialized I c= s1 & Initialized I c= s2 &
    I c= P1 & I c= P2 &
     s1,s2 equal_outside NAT
  holds LifeSpan(P1,s1) = LifeSpan(P2,s2) & Result(
P1,s1), Result(P2,s2) equal_outside NAT
proof
  let s1,s2 be State of SCM+FSA,I be InitHalting Program of SCM+FSA;
  assume that
A1: Initialized I c= s1 and
A2: Initialized I c= s2 and
A3: I c= P1 and
A4: I c= P2 and
A5: s1,s2 equal_outside NAT;
A6: P2 halts_on s2 by A2,SCM_HALT:5,A4;
A7: P1 halts_on s1 by A1,SCM_HALT:5,A3;
A8: now
    let l be Element of NAT;
    assume
A9: CurInstr(P2,Comput(P2,s2,l)) = halt SCM+FSA;
    CurInstr(P1,Comput(P1,s1,l))
     = CurInstr(P2,Comput(P2,s2,l))
     by A1,A2,A5,Th11,A3,A4;
    hence LifeSpan(P1,s1) <= l by A7,A9,EXTPRO_1:def 14;
  end;
  CurInstr(P2,
Comput(P2,s2,LifeSpan(P1,s1)))
   = CurInstr(P1,
   Comput(P1,s1,LifeSpan(P1,s1)))
    by A1,A2,A5,Th11,A3,A4
    .= halt SCM+FSA by A7,EXTPRO_1:def 14;
  hence
A10: LifeSpan(P1,s1) = LifeSpan(P2,s2) by A8,A6,
EXTPRO_1:def 14;
A11: Result(P2,s2) = Comput(P2, s2,LifeSpan(
P1,s1)) by A10,A2,EXTPRO_1:23,SCM_HALT:5,A4;
  Result(P1,s1) = Comput(P1, s1,LifeSpan(
P1,s1)) by A1,EXTPRO_1:23,SCM_HALT:5,A3;
  hence thesis by A1,A2,A5,A11,Th11,A3,A4;
end;

theorem Th13: ::SCMFSA6A_49
  for I be Program of SCM+FSA, f be FinSeq-Location holds not f in
  dom I
proof
  let I be Program of SCM+FSA,f be FinSeq-Location;
A1: dom I c= NAT by RELAT_1:def 18;
  assume f in dom I;
  then reconsider f as Element of NAT by A1;
  f=f;
  hence contradiction by SCMFSA_2:85;
end;

theorem Th14: ::SCMFSA6A_48
  for I be Program of SCM+FSA, a be Int-Location holds not a in
  dom I
proof
  let I be Program of SCM+FSA,a be Int-Location;
A1: dom I c= NAT by RELAT_1:def 18;
  assume a in dom I;
  then reconsider a as Element of NAT by A1;
  a=a;
  hence contradiction by SCMFSA_2:84;
end;

begin  :: -- Basic property of while Macro ---

canceled;

theorem Th16:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location st s.a <= 0
 holds while>0(a,I) is_halting_onInit s,P &
     while>0(a,I) is_closed_onInit s,P
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  let a be read-write Int-Location;
  set s0=Initialized s;
  assume s.a <= 0;
  then
A1: s0.a <= 0 by SCMFSA6C:3;
  then
A2: while>0(a,I) is_closed_on s0,P by SCMFSA_9:43;
  while>0(a,I) is_halting_on s0,P by A1,SCMFSA_9:43;
  hence thesis by A2,SCM_HALT:40,41;
end;

theorem
  for a being Int-Location, I being Program of SCM+FSA, s being State of
SCM+FSA,k being Element of NAT st I is_closed_onInit s,P &
I is_halting_onInit s,P
& k < LifeSpan(P +* I,s +* Initialized I) &
 IC Comput(P +* while>0(a,I),
  (s +* Initialized while>0
  (a,I)),1 + k) = IC Comput(P +* I, (s +*
Initialized I),k) + 4 & DataPart
Comput(P +* while>0(a,I), (s +* Initialized while>0
(a,I)),1 + k) = DataPart Comput(P +* I, (s
+* Initialized I),k)
 holds IC Comput(P +* while>0(a,I),
 (s +* Initialized while>0(a,I)),1 +
k+1) = IC Comput(P +* I, (s +* Initialized I),k+1)
+ 4 & DataPart Comput(P +* while>0(a,I), (s
+* Initialized while>0(a,I)),1 + k+1)
 = DataPart Comput(P +* I, (s +* Initialized
  I),k+1)
proof
  let a be Int-Location,I be Program of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let s be State of SCM+FSA,k be Element of NAT;
  set s0=Initialized s, sw = s +* Initialized while>0(a,I),
      Pw = P +* while>0(a,I),
      sI = s +* Initialized I,
      PI = P +* I,
      s0I= s0 +* (Initialize I), s0w= s0 +*
(Initialize while>0(a,I)), sK1= Comput(Pw, sw,1 + k),
sK2= Comput(PI, sI,k), l3=IC
  Comput(PI, sI,k);
A1: sI=s0I by SCMFSA8A:13;
A2: sw=s0w by SCMFSA8A:13;
  assume I is_closed_onInit s,P;
  then
A3: I is_closed_on s0,P by SCM_HALT:40;
  assume I is_halting_onInit s,P;
  then
A4: I is_halting_on s0,P by SCM_HALT:41;
  assume
A5: k < LifeSpan(PI,sI);
  assume
A6: IC Comput(Pw, sw,1 + k)=l3 + 4;
  assume
A7: DataPart sK1 = DataPart sK2;
  hence IC Comput(Pw, sw,1 + k+1) = IC Comput(PI,
sI,k+1) + 4 by A5,A6,A3,A4,A1,A2,SCMFSA_9:44;
  thus thesis by A5,A6,A7,A3,A4,A1,A2,SCMFSA_9:44;
end;

theorem
  for a being Int-Location, I being Program of SCM+FSA, s being State of
SCM+FSA st I is_closed_onInit s,P & I is_halting_onInit s,P &
IC Comput(P +* while>0(a,I), (s +*
Initialized while>0(a,I)),1 + LifeSpan(P +* I,s +*
Initialized I)) = IC Comput(P +* I,
  (s +* Initialized I),LifeSpan(P +* I,s +* Initialized I)) + 4
   holds CurInstr(P +* while>0(a,I),
     Comput(P +* while>0(a,I),(s +* Initialized while>0(a,I)),
     1 + LifeSpan(P +* I,s +* Initialized I)))
  = goto  (card I +4)
proof
  let a be Int-Location,I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s0=Initialized s, sw = s +* Initialized while>0(a,I),
      Pw = P +* while>0(a,I),
      sI = s +* Initialized I,
      PI = P +* I,
      s0I= s0 +* (Initialize I), s0w= s0 +*
(Initialize while>0(a,I));
A1: sI=s0I by SCMFSA8A:13;
A2: sw=s0w by SCMFSA8A:13;
  assume I is_closed_onInit s,P;
  then
A3: I is_closed_on s0,P by SCM_HALT:40;
  assume I is_halting_onInit s,P;
  then
A4: I is_halting_on s0,P by SCM_HALT:41;
  assume
  IC Comput(Pw, sw,1 + LifeSpan(PI,sI)) = IC Comput(
PI,
sI,LifeSpan(PI,sI)
  ) + 4;
  hence thesis by A3,A4,A1,A2,SCMFSA_9:45;
end;

theorem Th19:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location st I is_closed_onInit s,P &
I is_halting_onInit s,P &
  s.a >0 holds
   IC Comput(P +* while>0(a,I),s +* Initialized while>0(a,I),
    LifeSpan(P +* I,s +* Initialized I) + 3) =  0 &
for k being Element of NAT
 st k <= LifeSpan(P +* I,s +* Initialized I) + 3
 holds IC Comput(P +* while>0(a,I),
 (s +* Initialized while>0(a,I)),k) in dom while>0(a,I)
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA;
  let a be read-write Int-Location;
  set s0=Initialized s, sw = s +* Initialized while>0(a,I),
      Pw = P +* while>0(a,I),
      sI = s +* Initialized I,
      PI = P +* I,
      s0I= s0 +* (Initialize I), s0w= s0 +*
(Initialize while>0(a,I));
A1: sI=s0I by SCMFSA8A:13;
A2: sw=s0w by SCMFSA8A:13;
  assume I is_closed_onInit s,P;
  then
A3: I is_closed_on s0,P by SCM_HALT:40;
  assume I is_halting_onInit s,P;
  then
A4: I is_halting_on s0,P by SCM_HALT:41;
  assume s.a >0;
  then
A5: s0.a>0 by SCMFSA6C:3;
  hence IC Comput(Pw, sw,LifeSpan(PI,sI) + 3) =  0
          by A3,A4,A1,A2,SCMFSA_9:47;
  thus thesis by A3,A4,A5,A1,A2,SCMFSA_9:47;
end;

theorem ::SCM_9_36
  for s being State of SCM+FSA, I being Program of SCM+FSA,a be
read-write Int-Location st I is_closed_onInit s,P &
I is_halting_onInit s,P & s.a >
  0 holds for k being Element of NAT st
   k <= LifeSpan(P +* I,s +* Initialized I) + 3
  holds IC Comput(P +* while>0(a,I), (s +*
Initialized while>0(a,I)),k) in dom while>0(a,I)
proof
  let s be State of SCM+FSA, I be Program of SCM+FSA,a be read-write
  Int-Location;
  set s0=Initialized s, IA=Initialize I;
  assume
A1: I is_closed_onInit s,P;
A2: ProgramPart I = I by RELAT_1:209;
  now
    let k be Element of NAT;
   s +* Initialized I = Initialized s +* (Initialize I)
           by SCMFSA8A:13;
    hence IC Comput(P +* I, (s0 +* IA ),k) in dom I
       by A1,SCM_HALT:def 4;
  end;
  then
A3: I is_closed_on s0,P by SCMFSA7B:def 7,A2;
  assume I is_halting_onInit s,P;
  then
A4:   P +* I halts_on s+*Initialized I by SCM_HALT:def 5;
  s +* Initialized I = Initialized s +* (Initialize I)
  by SCMFSA8A:13;
  then
A5: I is_halting_on s0,P by A4,SCMFSA7B:def 8,A2;
  assume s.a >0;
  then
A6: s0.a > 0 by SCMFSA6C:3;
  hereby
    let k be Element of NAT;
A7: s +* Initialized while>0(a,I) =
Initialized s +* (Initialize while>0(a,I))
           by SCMFSA8A:13;
A8: s +* Initialized I = s0 +* IA by SCMFSA8A:13;
    assume
    k <= LifeSpan(P +* I,s +* Initialized I) + 3;
    hence
    IC Comput(P +* while>0(a,I), (s +* Initialized
while>0(a,I)),k) in dom while>0(a,I
    ) by A7,A3,A5,A6,A8,SCMFSA_9:47;
  end;
end;

theorem Th21: ::SCM_9_37
  for s being State of SCM+FSA, I be Program of SCM+FSA,a be
read-write Int-Location st I is_closed_onInit s,P &
I is_halting_onInit s,P & s.a >
  0 holds IC Comput(P +* while>0(a,I), (s +*
Initialized while>0(a,I)), (LifeSpan(P +* I,s +*
  Initialized I) + 3)) =  0 &
   DataPart Comput(P +* while>0(a,I), (s +* Initialized
while>0(a,I)), (LifeSpan(P +* I,s +* Initialized I) +
3)) = DataPart Comput(P +* I, (s
  +* Initialized I),LifeSpan(P +* I,s +* Initialized I
))
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA,a be read-write
  Int-Location;
  set D = Data-Locations SCM+FSA;
  set s0=Initialized s, IA=Initialize I;
  set s1 = s0 +* (Initialize while>0(a,I)),
      P1 = P +* while>0(a,I),
      PI = P +* I,
      s2 = Comput(P1, s1,1),
  i = a >0_goto  4 , sI = s0 +* IA;
A1: while>0(a,I) c= P1 by FUNCT_4:26;
  defpred P[Nat] means $1 <= LifeSpan(PI,sI) implies IC Comput(
P1, s1
,1 + $1) =
  IC Comput(PI, sI,$1) + 4 & DataPart Comput(P1, s1
,1 + $1) = DataPart
  Comput(PI, sI,$1);
  set loc4= (card I + 4);
  set s3= Comput(P1, s1,1+LifeSpan(PI,sI)+1);
A2: loc4 in dom while>0(a,I) by SCMFSA_9:38;
A3: ProgramPart I = I by RELAT_1:209;
  assume
A4: I is_closed_onInit s,P;
  now
    let k be Element of NAT;
   s +* Initialized I = Initialized s +* (Initialize I)
           by SCMFSA8A:13;
    hence IC Comput(P +* I, (s0 +* IA ),k) in dom I
        by A4,SCM_HALT:def 4;
  end;
  then
A5: I is_closed_on s0,P by SCMFSA7B:def 7,A3;
  assume I is_halting_onInit s,P;
  then
A6:  P +* I halts_on s+*Initialized I
   by SCM_HALT:def 5;
  s +* Initialized I = Initialized s +* (Initialize I)
  by SCMFSA8A:13;
  then
A7: I is_halting_on s0,P by A6,SCMFSA7B:def 8,A3;
A8: now
    let k be Element of NAT;
    assume
A9: P[k];
    now
A10:   k + 0 < k + 1 by XREAL_1:8;
      assume k + 1 <= LifeSpan(PI,sI);
      then k < LifeSpan(PI,sI) by A10,XXREAL_0:2;
      hence IC Comput(P1, s1,1 + k+1)
       = IC Comput(PI, sI,k+1) + 4 &
DataPart Comput(P1, s1,1 + k+1)
 = DataPart Comput(PI, sI,k+1) by A5,A7,A9,SCMFSA_9:44;
    end;
    hence P[k + 1];
  end;
  0 in dom while>0(a,I) by SCMFSA_9:10;
  then
A11: P1. 0 = while>0(a,I). 0 by A1,GRFUNC_1:8
    .= i by SCMFSA_9:11;
  IC SCM+FSA in dom (Initialize while>0(a,I))
  by COMPOS_1:141;
  then
A12: IC s1 = IC((Initialize while>0(a,I)))
by FUNCT_4:14
    .=  0 by COMPOS_1:142;
A13: Comput(P1, s1,0 + 1) = Following(P1,Comput(P1,s1,0)) by EXTPRO_1:4
    .= Following(P1,s1) by EXTPRO_1:3
    .= Exec(i,s1) by A12,A11,PBOOLE:158;
  then
A14: for f be FinSeq-Location holds s2.f = s1.f by SCMFSA_2:97;
  for c be Int-Location holds s2.c = s1.c by A13,SCMFSA_2:97;
  then
A15: DataPart s2 = DataPart s1 by A14,SCMFSA6A:38
    .= DataPart s0 by SCMFSA8A:11
    .= DataPart sI by SCMFSA8A:11;
  set s4= Comput(P1, s1,1+LifeSpan(PI,sI)+1+1);
  set s2= Comput(P1, s1,1 + LifeSpan(PI,sI));
  not a in dom (Initialize while>0(a,I)) by SCMFSA6B:12;
  then
A16: s1.a = s0.a by FUNCT_4:12;
  assume s.a > 0;
  then
A17: s0.a > 0 by SCMFSA6C:3;
A18: P[ 0]
  proof
    assume 0 <= LifeSpan(PI,sI);
A19: IC SCM+FSA in dom (Initialize I) by COMPOS_1:141;
    IC Comput(PI, sI,0) = sI.IC SCM+FSA by EXTPRO_1:3
      .= IC(Initialize I) by A19,FUNCT_4:14
      .=  0 by COMPOS_1:142;
    hence thesis by A17,A13,A16,A15,EXTPRO_1:3,SCMFSA_2:97;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A18,A8);
  then
A20: P[LifeSpan(PI,sI)];
A21: s3 = Following(P1,s2) by EXTPRO_1:4
    .= Exec(goto loc4,s2) by A5,A7,A20,SCMFSA_9:45;
  then
A22: for f be FinSeq-Location holds s3.f = s2.f by SCMFSA_2:95;
A23: P1.loc4 = P1.loc4
    .= while>0(a,I).loc4 by A2,A1,GRFUNC_1:8
    .= goto  0 by SCMFSA_9:46;
A24:  P1/.IC s3 = P1.IC s3 by PBOOLE:158;
A25: s4 = Following(P1,s3) by EXTPRO_1:4
    .= Exec(goto  0,s3) by A21,A23,A24,SCMFSA_2:95;
  then
A26: for f be FinSeq-Location holds s4.f = s3.f by SCMFSA_2:95;
  for c be Int-Location holds s3.c = s2.c by A21,SCMFSA_2:95;
  then
A27: DataPart s3 = DataPart s2 by A22,SCMFSA6A:38;
A28: s +* Initialized while>0(a,I)
= Initialized s +* (Initialize while>0(a,I))
           by SCMFSA8A:13;
A29: sI = s +* Initialized I by SCMFSA8A:13;
A30: Comput(P +* while>0(a,I), (s +* Initialized
while>0(a,I)), (LifeSpan(P +* I,s +*
Initialized I) + 3)) = Comput(P1, s1,
(LifeSpan(P +* I,s +* Initialized I) + 3))
by A28
    .=s4 by A29;
  hence IC Comput(P +* while>0(a,I), (s +*
Initialized while>0(a,I)), (LifeSpan(P +* I,s +*
  Initialized I) + 3)) = 0 by A25,SCMFSA_2:95;
A31: s +* Initialized I = Initialized s +* (Initialize I)
           by SCMFSA8A:13;
A32: sI = s +* Initialized I by SCMFSA8A:13;
  for c be Int-Location holds s4.c = s3.c by A25,SCMFSA_2:95;
  hence DataPart Comput(P +* while>0(a,I), (s +*
Initialized while>0(a,I)), (LifeSpan(P +* I,s +*
Initialized I) + 3)) = DataPart Comput(P +* I, (s
+* Initialized I),LifeSpan(PI,sI))
  by A20,A30,A31,A27,A26,SCMFSA6A:38
    .= DataPart Comput(P +* I, (s +* Initialized I)
, (LifeSpan(P +* I,s +*
  Initialized I))) by A32;
end;

theorem
  for s be State of SCM+FSA, I be InitHalting Program of SCM+FSA, a be
  read-write Int-Location st s.a > 0 holds ex s2 be State of SCM+FSA, k be
  Element of NAT st s2 = s +* Initialized (while>0(a,I)) &
   k =LifeSpan(P +* I,s +* Initialized I) + 3 &
   IC Comput(P +* while>0(a,I), s2,k) =  0 &
    (for b be Int-Location
  holds Comput(P +* while>0(a,I), s2,k).b = IExec(I,P,s).b) &
   for f be FinSeq-Location holds
    Comput(P +* while>0(a,I), s2,k).f = IExec(I,P,s).f
proof
  let s be State of SCM+FSA,I be InitHalting Program of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  set Is=Initialized s +* (Initialize I);
  set Q = while>0(a,I), s1 = s +* Initialized I,
      P1 = P +* I;
  take s2 = s +* Initialized Q;
  set P2 = P +* Q;
  take k = LifeSpan(P1,s1) + 3;
A2: ProgramPart I = I by RELAT_1:209;
  thus s2 = s +* Initialized Q & k = LifeSpan(P1,s1) + 3;
A3: I is_halting_onInit s,P by SCM_HALT:36;
  then
A4:  P1 halts_on s1 by SCM_HALT:def 5;
  s+* Initialized I = Initialized s +* (Initialize I)
  by SCMFSA8A:13;
  then
A5: I is_halting_on Initialized s,P by A4,SCMFSA7B:def 8,A2;
A6: I is_closed_onInit s,P by SCM_HALT:35;
  hence IC ( Comput(P2, s2,k))= 0 by A1,A3,Th21;
  set s4= Comput(P2, s2,k), s3= Comput(P1, s1,
LifeSpan(P1,s1));
A7: s +* Initialized I = Initialized s +* (Initialize I)
           by SCMFSA8A:13;
A8: s1 = Is by SCMFSA8A:13;
A9: s3= Comput(P1, Is,LifeSpan(P1,s1)) by A7
    .= Comput(P1, Is,LifeSpan(P1,Is))
     by A8;
A10: DataPart s4 = DataPart s3 by A1,A3,A6,Th21;
  hereby
    let b be Int-Location;
    thus s4.b = Comput(P1, Is,LifeSpan(P1,Is)).b by
A9,A10,SCMFSA6A:38
      .= IExec(I,P,s).b by A5,Th10;
  end;
  hereby
    let f be FinSeq-Location;
    thus s4.f = Comput(P1, Is,LifeSpan(P1,Is)).f by
A9,A10,SCMFSA6A:38
      .= IExec(I,P,s).f by A5,SCMFSA8C:87;
  end;
end;

definition
  let s,I,a,P;
  deffunc U(Nat, Element of product the Object-Kind of SCM+FSA) =
   Comput(P +* while>0(a,I),($2 +* Initialized while>0(a,I)),
    (LifeSpan(P +* while>0(a,I) +* I,$2+* Initialized I) + 3));
  deffunc V(Nat, Element of product the Object-Kind of SCM+FSA) =
   down U($1,$2);
  func StepWhile>0(a,P,s,I) -> Function of NAT,product the Object-Kind of
  SCM+FSA means
  :Def1:
  it.0 = s &
   for i being Nat
    holds it.(i+1)= Comput(P +* while>0(a,I), it.i +* Initialized while>0(a,I),
     (LifeSpan(P +* while>0(a,I) +* I,it.i +* Initialized I) + 3));
  existence
  proof
   reconsider ss=s as
    Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
    consider f being Function of NAT,product the Object-Kind of SCM+FSA
     such that
A1:   f.0 = ss and
A2:  for i being Nat holds f.(i+1)= V(i,f.i) from NAT_1:sch 12;
   take f;
   thus f.0 = s by A1;
   let i be Nat;
    f.(i+1)= V(i,f.i) by A2;
   hence thesis;
  end;
  uniqueness
  proof
    let F1,F2 be Function of NAT,product the Object-Kind of SCM+FSA such that
A3: F1.0 = s and
A4: for i being Nat holds F1.(i+1)= U(i,F1.i) and
A5: F2.0 = s and
A6: for i being Nat holds F2.(i+1)= U(i,F2.i);
   reconsider s as Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
A7: F1.0 = s by A3;
A8: for i being Nat holds F1.(i+1)= V(i,F1.i) by A4;
A9: F2.0 = s by A5;
A10: for i being Nat holds F2.(i+1)= V(i,F2.i) by A6;
     F1 = F2 from NAT_1:sch 16(A7,A8,A9,A10);
   hence thesis;
  end;
end;

canceled 2;

theorem
  StepWhile>0(a,P,s,I).(k+1) =StepWhile>0(a,P,StepWhile>0(a,P,s,I).k,I).1
proof
  set sk=StepWhile>0(a,P,s,I).k;
  set sk0=StepWhile>0(a,P,sk,I).0;
  sk0=sk by Def1;
  hence
  StepWhile>0(a,P,s,I).(k+1)
   = Comput(P +* while>0(a,I),(sk0 +* Initialized while>0(a,I)),
      (LifeSpan(P +* while>0(a,I) +* I,sk0 +* Initialized I) + 3)) by Def1
    .=StepWhile>0(a,P,sk,I).(0+1) by Def1
    .=StepWhile>0(a,P,sk,I).1;
end;

theorem Th26:
  for I being Program of SCM+FSA,a being read-write Int-Location,
  s being State of SCM+FSA holds StepWhile>0(a,P,s,I).(0+1)
  = Comput(P +* while>0(a,I), s +* Initialized while>0(a,I),
   LifeSpan(P +* while>0(a,I) +* I,s+* Initialized I) + 3)
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA;
A1: StepWhile>0(a,P,s,I).0 = s by Def1;
thus StepWhile>0(a,P,s,I).(0+1)
   = Comput(P +* while>0(a,I),
     (StepWhile>0(a,P,s,I).0 +*
Initialized while>0(a,I)),
LifeSpan(P +* while>0(a,I) +* I,StepWhile>0(a,P,s,I).0 +* Initialized I) + 3)
  by Def1
    .= Comput(P +* while>0(a,I), (s +* Initialized
while>0(a,I)),
   (LifeSpan(P +* while>0(a,I) +* I,StepWhile>0(
  a,P,s,I).0+* Initialized I) + 3)) by A1
    .= Comput(P +* while>0(a,I), (s +* Initialized
while>0(a,I)), (LifeSpan(P +* while>0(a,I) +* I,s+* Initialized I) + 3)) by A1;
end;

theorem Th27:
  for I be Program of SCM+FSA,a be read-write Int-Location, s be
  State of SCM+FSA,k,n be Element of NAT st
   IC StepWhile>0(a,P,s,I).k = 0 &
  StepWhile>0(a,P,s,I).k= Comput(P +* while>0(a,I), (
s +* Initialized while>0(a,I)),n) &
StepWhile>0(a,P,s,I).k.intloc 0=1 holds
 StepWhile>0(a,P,s,I).k = StepWhile>0(a,P,s,I).k +* Initialized while>0(a,I) &
 StepWhile>0(a,P,s,I).(k+1)
  = Comput(P +* while>0(a,I), (s +*
Initialized while>0(a,I)),
(n +(LifeSpan(P +* while>0(a,I) +* I,
StepWhile>0(a,P,s,I).k +* Initialized I) + 3)))
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA,k,n be Element of NAT;
  set D = Data-Locations SCM+FSA;
  set s1 = s +* Initialized while>0(a,I),
      P1 = P +* while>0(a,I);
  set sk=StepWhile>0(a,P,s,I).k, s0k=Initialized sk,
  At0=Initialize while>0(a,I),
s2=s0k +* At0, s3=sk +* Initialized while>0(a,I);
  assume
A1: IC sk = 0;
A2: IC SCM+FSA in dom At0 by COMPOS_1:141;
A3: IC s3 = s2.IC SCM+FSA by SCMFSA8A:13
    .= IC At0 by A2,FUNCT_4:14
    .= IC sk by A1,COMPOS_1:142;
  assume
A4: sk = Comput(P1,s1,n);
   then
A5: ProgramPart sk = ProgramPart s1 by AMI_1:123;
A6: ProgramPart s3
       = ProgramPart s1 +* ProgramPart Initialized while>0(a,I)
                       by FUNCT_4:75,A5
      .= ProgramPart s +* ProgramPart Initialized while>0(a,I)
            +* ProgramPart Initialized while>0(a,I) by FUNCT_4:75
      .= ProgramPart s +* ProgramPart Initialized while>0(a,I) by FUNCT_4:99
      .= ProgramPart s1 by FUNCT_4:75;
  assume
A7: sk.intloc 0=1;
  DataPart s3 = DataPart s2 by SCMFSA8A:13
    .= DataPart s0k by SCMFSA8A:11
    .= DataPart sk by A1,A7,SCMFSA8C:14;
  hence s3=sk by A3,SCMFSA_9:29,A6,A5;
  hence
  StepWhile>0(a,P,s,I).(k+1)= Comput(P1, sk,
    LifeSpan(P1 +* I,sk +* Initialized I) + 3) by Def1
    .= Comput(P1, s1,n +(LifeSpan(P1 +* I,
    sk +* Initialized I) + 3)) by A4,EXTPRO_1:5;
end;

theorem
  for I be Program of SCM+FSA,a be read-write Int-Location, s be State
of SCM+FSA st ex f being Function of product the Object-Kind of SCM+FSA,NAT st
  (for k being Element of NAT holds ( f.(StepWhile>0(a,P,s,I).k) <> 0
   implies f.(
  StepWhile>0(a,P,s,I).(k+1)) < f.(StepWhile>0(a,P,s,I).k) &
  I is_closed_onInit StepWhile>0(a,P,s,I).k,P+*while>0(a,I) &
  I is_halting_onInit StepWhile>0(a,P,s,I).k,P+*while>0(a,I)) &
  (StepWhile>0(a,P,s,I).(k+1)).intloc 0=1 &
   ( f.(StepWhile>0(a,P,s,I).k)=0 iff (StepWhile>0(a,P,s,I).k).a <= 0 ) )
    holds while>0(a,I) is_halting_onInit s,P & while>0(a,I)
  is_closed_onInit s,P
proof
  let I be Program of SCM+FSA,a be read-write Int-Location,s be State of
  SCM+FSA;
  set D = Data-Locations SCM+FSA;
  given f be Function of product the Object-Kind of SCM+FSA,NAT such that
A1: for k be Element of NAT holds (f.(StepWhile>0(a,P,s,I).k) <> 0 implies
  f.(StepWhile>0(a,P,s,I).(k+1)) < f.(StepWhile>0(a,P,s,I).k) &
  I is_closed_onInit StepWhile>0(a,P,s,I).k,P+*while>0(a,I) &
  I is_halting_onInit StepWhile>0(a,P,s,I).k,P+*while>0(a,I)) & (StepWhile>0
(a,P,s,I).(k+1)).intloc 0=1 & ( f.(StepWhile>0(a,P,s,I).k)=0 iff
 (StepWhile>0(a,P,s,I
  ).k).a <= 0);
  set IniI=Initialized I, Iwhile=Initialized while>0(a,I), s1 = s +* Iwhile,
     P1 = P +* while>0(a,I);
A2:  P1 +* while>0(a,I) = P1 by FUNCT_4:99;
A3: IC SCM+FSA in dom Iwhile by SCMFSA6A:24;
  deffunc F(Nat) = f.(StepWhile>0(a,P,s,I).$1);
A4: for k being Nat holds F(k+1) < F(k) or F(k) = 0
  proof
    let k be Nat;
    k in NAT by ORDINAL1:def 13;
    hence thesis by A1;
  end;
  consider m being Nat such that
A5: F(m)=0 and
A6: for n being Nat st F(n) =0 holds m <= n from NAT_1:sch 17(A4);
  reconsider m as Element of NAT by ORDINAL1:def 13;
  defpred P[Element of NAT] means $1+1 <= m implies
   ex k st StepWhile>0(a,P,s,I).($1+1)= Comput(P1, s1,k);
A7: P[ 0]
  proof
    assume 0+1 <= m;
    take n=(LifeSpan(P +* while>0(a,I)+* I,s +* IniI) + 3);
    thus thesis by Th26;
  end;
A8: now
    let i be Element of NAT;
    assume i<m;
    then F(i)<>0 by A6;
    hence I is_closed_onInit StepWhile>0(a,P,s,I).i,P+*while>0(a,I) &
     I is_halting_onInit StepWhile>0(a,P,s,I).i,P+*while>0(a,I) by A1;
  end;
A9: now
    let k be Element of NAT;
    assume
A10: P[k];
    now
      set sk=StepWhile>0(a,P,s,I).k, sk1=StepWhile>0(a,P,s,I).(k+1);
      assume
A11:  (k+1)+ 1 <= m;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
      then consider n be Element of NAT such that
A12:  sk1 = Comput(P1,s1,n) by A10,A11,XXREAL_0:2;
A13:  sk1.intloc 0=1 by A1;
      k + 0 < k+ (1+ 1) by XREAL_1:8;
      then
A14:  k < m by A11,XXREAL_0:2;
      then
A15:  I is_halting_onInit sk,P1 by A8;
      F(k) <> 0 by A6,A14;
      then
A16:  sk.a > 0 by A1;
      take m=n +(LifeSpan(P +* while>0(a,I) +* I,sk1 +* IniI ) + 3);
A17:  P+*while>0(a,I) +* while>0(a,I) = P+*while>0(a,I) by FUNCT_4:99;
A18:  sk1= Comput(P +* while>0(a,I), (sk +* Iwhile),LifeSpan(
             P +* while>0(a,I) +* I,sk +* IniI ) + 3) by Def1;
      I is_closed_onInit sk,P1 by A8,A14;
      then IC sk1 = 0 by A18,A15,A16,Th19,A17;
      hence StepWhile>0(a,P,s,I).(k+1+1)= Comput(P1, s1,m) by A12
,A13,Th27;
    end;
    hence P[k+1];
  end;
A19: for k being Element of NAT holds P[k] from NAT_1:sch 1(A7,A9);
  now
    per cases;
    suppose
      m=0;
      then (StepWhile>0(a,P,s,I).0).a <= 0 by A1,A5;
      then s.a <= 0 by Def1;
      hence thesis by Th16;
    end;
    suppose
A20:  m<>0;
      then consider i being Nat such that
A21:  m=i+1 by NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      set si=StepWhile>0(a,P,s,I).i, sm=StepWhile>0(a,P,s,I).m,
      sm1=sm +* Iwhile,
      sm2=sm +*(Initialize while>0(a,I));
A22:  i<m by A21,XREAL_1:31;
      then
A23:  I is_closed_onInit si,P+*while>0(a,I) by A8;
      i < m by A21,NAT_1:13;
      then F(i) <> 0 by A6;
      then
A24:  si.a > 0 by A1;
A25:  I is_halting_onInit si,P+*while>0(a,I) by A8,A22;
      sm= Comput(P +* while>0(a,I), (si +* Iwhile), (LifeSpan(
              P +* while>0(a,I) +* I,si +* IniI) + 3)) by A21,Def1;
      then
A26:  IC sm = 0 by A23,A25,A24,Th19,A2;
      StepWhile>0(a,P,s,I).(i+1).intloc 0 = 1 by A1;
      then
A27:  sm1=sm2 by A21,SCMFSA8C:18;
      then
A28:  IC sm2 = Iwhile.IC SCM+FSA by A3,FUNCT_4:14
        .= IC sm by A26,SCMFSA6A:46;
      set p=(LifeSpan(P+*while>0(a,I) +* I,s+* IniI) + 3);
A29:  DataPart sm2 = DataPart sm by SCMFSA8A:11;
      m=i+1 by A21;
      then consider n being Element of NAT such that
A30:  sm = Comput(P1,s1,n) by A19;
  ProgramPart sm1
            = ProgramPart sm +* ProgramPart Iwhile by FUNCT_4:75
           .= ProgramPart s1 +* ProgramPart Iwhile
                               by A30,AMI_1:123
           .= ProgramPart s +* ProgramPart Iwhile +* ProgramPart Iwhile
                                  by FUNCT_4:75
           .= ProgramPart s +* ProgramPart Iwhile
                                  by FUNCT_4:99
           .= ProgramPart s1 by FUNCT_4:75
           .= ProgramPart sm by A30,AMI_1:123;
      then
A31:  sm1=sm by A27,A28,A29,SCMFSA_9:29;
A32:  sm.a <= 0 by A1,A5;
      then while>0(a,I) is_halting_onInit sm,P+*while>0(a,I) by Th16;
      then P+*while>0(a,I) halts_on sm1 by SCM_HALT:def 5,A2;
      then consider j being Element of NAT such that
A33:  CurInstr(P+*while>0(a,I),Comput(P+*while>0(a,I),sm,j))
          = halt SCM+FSA by A31,EXTPRO_1:30;
A34: Comput(P1,s1,j+n) = Comput(P1,Comput(P1,s1,n),j) by EXTPRO_1:5;
      P1 halts_on s1 by A30,A33,A34,EXTPRO_1:30;
      hence while>0(a,I) is_halting_onInit s,P by SCM_HALT:def 5;
      now
        let q be Element of NAT;
        per cases;
        suppose
A35:      q <= p;
A36:      StepWhile>0(a,P,s,I).0=s by Def1;
          then
A37:      I is_halting_onInit s,P+*while>0(a,I) by A8,A20;
          F(0) <> 0 by A6,A20;
          then
A38:      s.a > 0 by A1,A36;
          I is_closed_onInit s,P+*while>0(a,I) by A8,A20,A36;
          hence IC Comput(P1, s1,q) in dom while>0(a,I) by A35
                    ,A38,A37,Th19,A2;
        end;
        suppose
A39:      q > p;
A40:      now
            take k=p;
            thus StepWhile>0(a,P,s,I).1= Comput(P1, s1,k) & k <= q
by A39,Th26;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 &
           (ex k st StepWhile>0(a,P,s,I).$1
          = Comput(P1, s1,k) & k <= q);
A41:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A20,XREAL_1:8;
          then 1 <= m by NAT_1:13;
          then
A42:      ex t being Nat st P2[t] by A40;
          consider t being Nat such that
A43:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A41,A42);
          reconsider t as Element of NAT by ORDINAL1:def 13;
          now
            per cases;
            suppose
              t=m;
              then consider r being Element of NAT such that
A44:          sm= Comput(P1, s1,r) and
A45:          r <= q by A43;
              consider x being Nat such that
A46:          q = r+x by A45,NAT_1:10;
A47:          while>0(a,I) is_closed_onInit sm,P+*while>0(a,I) by A32,Th16;
              reconsider x as Element of NAT by ORDINAL1:def 13;
              Comput(P1, s1,q) = Comput(P1, sm1,x) by A31,A44,A46,EXTPRO_1:5;
              hence IC Comput(P1, s1,q) in dom while>0(a,I) by
                  A47,SCM_HALT:def 4,A2;
            end;
            suppose
A48:          t<>m;
              set Dt=StepWhile>0(a,P,s,I).t;
A49:          t < m by A43,A48,XXREAL_0:1;
              then
A50:          I is_closed_onInit Dt,P+*while>0(a,I) by A8;
A51:          I is_halting_onInit Dt,P+*while>0(a,I) by A8,A49;
              consider y being Nat such that
A52:          t=y+1 by A43,NAT_1:6;
              reconsider y as Element of NAT by ORDINAL1:def 13;
              t=y+1 by A52;
              then
A53:          StepWhile>0(a,P,s,I).t.intloc 0=1 by A1;
              F(t) <> 0 by A6,A49;
              then
A54:          Dt.a > 0 by A1;
              consider z being Element of NAT such that
A55:          StepWhile>0(a,P,s,I).t= Comput(P1, s1,z) and
A56:          z <= q by A43;
              set z2=z +(LifeSpan(P +* while>0(a,I) +* I,Dt +* IniI) + 3);
              consider w be Nat such that
A57:          q = z+w by A56,NAT_1:10;
              set Dy=StepWhile>0(a,P,s,I).y;
              y+ 0 < t by A52,XREAL_1:8;
              then
A58:          y < m by A43,XXREAL_0:2;
              then
A59:          I is_closed_onInit Dy,P+*while>0(a,I) by A8;
              F(y) <> 0 by A6,A58;
              then
A60:          Dy.a > 0 by A1;
A61:          I is_halting_onInit Dy,P+*while>0(a,I) by A8,A58;
              reconsider w as Element of NAT by ORDINAL1:def 13;
              Dt= Comput(P +* while>0(a,I), (Dy +* Iwhile), (
LifeSpan(P +* while>0(a,I) +* I,Dy +* IniI) + 3
              )) by A52,Def1;
              then
A62:          IC Dt = 0 by A59,A61,A60,Th19,A2;
A63: Dt = Dt +* Iwhile by A53,A55,A62,Th27;
              now
                assume
A64:            z2 <= q;
A65:            now
                  take k=z2;
                  thus StepWhile>0(a,P,s,I).(t+1)= Comput(P1, s1,k)
& k <= q
by A53,A55,A62,A64,Th27;
                end;
                t+1 <= m by A49,NAT_1:13;
                hence contradiction by A43,A65,XREAL_1:31;
              end;
              then
A66:          w < LifeSpan(P +* while>0(a,I) +* I,Dt +* IniI) + 3 by A57,
XREAL_1:8;
              Comput(P1, s1,q) = Comput(P1,Dt,w) by A55,A57,EXTPRO_1:5
                .= Comput(P +* while>0(a,I), (Dt +* Iwhile),w) by A63
;
              hence IC Comput(P1, s1,q) in dom while>0(a,I) by
A66,A50,A51,A54,Th19,A2;
            end;
          end;
          hence IC Comput(P1, s1,q) in dom while>0(a,I);
        end;
      end;
      hence while>0(a,I) is_closed_onInit s,P by SCM_HALT:def 4;
    end;
  end;
  hence thesis;
end;

theorem Th29:
  for I be good InitHalting Program of SCM+FSA,a be read-write
Int-Location st (for s be State of SCM+FSA,P holds (s.a > 0
 implies IExec(I,P,s).a
  < s.a )) holds while>0(a,I) is InitHalting
proof
  let I be good InitHalting Program of SCM+FSA,a be read-write Int-Location;
  set D = Data-Locations SCM+FSA;
  defpred P[Element of NAT] means for t be State of SCM+FSA,Q
   st t.a <= $1 holds
     while>0(a,I) is_halting_onInit t,Q;
  assume
A1: for s be State of SCM+FSA,P holds (s.a > 0 implies IExec(I,P,s).a < s.a);
A2: now
    let k be Element of NAT;
    assume
A3: P[k];
    now
      let t be State of SCM+FSA,Q;
      assume
A4:   t.a <= k+1;
      per cases;
      suppose
        t.a<>k+1;
        then t.a < k+1 by A4,XXREAL_0:1;
        hence while>0(a,I) is_halting_onInit t,Q by A3,INT_1:20;
      end;
      suppose
A5:     t.a=k+1;
        set l0=intloc 0;
        set Iwhile=Initialized while>0(a,I), tW0=t +* Iwhile,
           QW = Q +* while>0(a,I),
           t1=t +* Initialized I,
           Q1 = Q +* I,
           Wt= Comput(QW, tW0,(LifeSpan(Q1,t1))+ 3), A = NAT,
           It = Comput(Q1, t1,LifeSpan(Q1,t1));
A6:     I is_halting_onInit t,Q by SCM_HALT:36;
        then
A7:     Q1 halts_on t1 by SCM_HALT:def 5;
        not l0 in A by SCMFSA_2:84;
        then not l0 in dom t /\ A by XBOOLE_0:def 4;
        then
A8:     not l0 in dom (t | A) by RELAT_1:90;
A9:     I is_closed_onInit t,Q by SCM_HALT:35;
        then
A10:    DataPart Wt = DataPart It by A5,A6,Th21;
        then
A11:    Wt.l0 =It.l0 by SCMFSA6A:38
          .=(Result(Q1,t1)).l0 by A7,EXTPRO_1:23
          .=(Result(Q1,t1) +* t | A).l0 by A8,FUNCT_4:12
          .=IExec(I,Q,t).l0 by SCMFSA6B:def 1
          .=1 by SCM_HALT:17;
        not a in A by SCMFSA_2:84;
        then not a in dom t /\ A by XBOOLE_0:def 4;
        then
A12:    not a in dom (t | A) by RELAT_1:90;
A13:    while>0(a,I) c= Iwhile by SCMFSA6A:26;
        Iwhile c= tW0 by FUNCT_4:26;
        then while>0(a,I) c= tW0 by A13,XBOOLE_1:1;
        then while>0(a,I) c= Wt by AMI_1:81;
        then
A14:    Wt +* while>0(a,I) = Wt by FUNCT_4:79;
        Wt.a =It.a by A10,SCMFSA6A:38
          .=(Result(Q1,t1)).a by A7,EXTPRO_1:23
          .=(Result(Q1,t1) +* t | A).a by A12,FUNCT_4:12
          .=IExec(I,Q,t).a by SCMFSA6B:def 1;
        then Wt.a < k+1 by A1,A5;
        then while>0(a,I) is_halting_onInit Wt,QW by A3,INT_1:20;
        then
A15:    QW +* while>0(a,I) halts_on Wt+*Iwhile by SCM_HALT:def 5;
A16:    QW +* while>0(a,I) = QW by FUNCT_4:99;
        IC Wt= 0 by A5,A9,A6,Th21;
        then
A17:    Wt +* Iwhile = Wt by A11,A14,Th6;
        now
          consider m be Element of NAT such that
A18:      CurInstr(QW,Comput(QW,Wt,m))
             = halt SCM+FSA by A17,A15,EXTPRO_1:30,A16;
          take mm=((LifeSpan(Q1,t1))+ 3)+m;
          thus CurInstr(QW,Comput(QW,tW0,mm))
           = halt SCM+FSA by A18,EXTPRO_1:5;
        end;
        then QW halts_on tW0 by EXTPRO_1:30;
        hence while>0(a,I) is_halting_onInit t,Q by SCM_HALT:def 5;
      end;
    end;
    hence P[k+1];
  end;
A19: P[ 0] by Th16;
A20: for k be Element of NAT holds P[k] from NAT_1:sch 1(A19,A2);
  now
    let t be State of SCM+FSA;
    per cases;
    suppose
      t.a<=0;
      hence while>0(a,I) is_halting_onInit t,Q by Th16;
    end;
    suppose
      t.a>0;
      then reconsider n=t.a as Element of NAT by INT_1:16;
      P[n] by A20;
      hence while>0(a,I) is_halting_onInit t,Q;
    end;
  end;
  hence thesis by SCM_HALT:36;
end;

theorem Th30:
  for I be good InitHalting Program of SCM+FSA,a be read-write
Int-Location st (for s be State of SCM+FSA,P holds IExec(I,P,s).a < s.a or
IExec(I,P,s).a <= 0) holds while>0(a,I) is InitHalting
proof
  let I be good InitHalting Program of SCM+FSA,a be read-write Int-Location;
  assume
A1: for s be State of SCM+FSA,P holds IExec(I,P,s).a < s.a or IExec(I,P,s).a
  <= 0;
  now
    let t be State of SCM+FSA,Q;
    assume
A2: t.a > 0;
    per cases by A1;
    suppose
      IExec(I,Q,t).a < t.a;
      hence IExec(I,Q,t).a < t.a;
    end;
    suppose
      IExec(I,Q,t).a <= 0;
      hence IExec(I,Q,t).a < t.a by A2;
    end;
  end;
  hence thesis by Th29;
end;

theorem
  for I be good InitHalting Program of SCM+FSA,a be read-write
Int-Location st ex f being Function of (product the Object-Kind of SCM+FSA),INT
st (for s,t be State of SCM+FSA,P
 holds (f.s > 0 implies f.IExec(I,P,s) < f.s ) &
  (DataPart s = DataPart t implies f.s=f.t) & ( f.s <= 0 iff s.a <= 0 ) ) holds
  while>0(a,I) is InitHalting
proof
  let I be good InitHalting Program of SCM+FSA,a be read-write Int-Location;
  set D = Data-Locations SCM+FSA;
  given f be Function of product the Object-Kind of SCM+FSA,INT such that
A1: for s,t be State of SCM+FSA,P
  holds (f.s > 0 implies f.IExec(I,P,s) < f
  .s ) & (DataPart s=DataPart t implies f.s=f.t) & ( f.s <= 0 iff s.a <= 0 );
  defpred P[Element of NAT] means
   for t be State of SCM+FSA,Q st f.t <= $1 holds
     while>0(a,I) is_halting_onInit t,Q;
A2: now
    let k be Element of NAT;
    assume
A3: P[k];
    now
      let t be State of SCM+FSA,Q;
      assume
A4:   f.t <= k+1;
      per cases;
      suppose
        f.t<>k+1;
        then f.t < k+1 by A4,XXREAL_0:1;
        hence while>0(a,I) is_halting_onInit t,Q by A3,INT_1:20;
      end;
      suppose
A5:     f.t=k+1;
        set l0=intloc 0;
        set Iwhile=Initialized while>0(a,I), tW0=t +* Iwhile,
            QW = Q +* while>0(a,I),
            t1=t +* Initialized I,
            Q1 = Q +* I,
            Wt= Comput(QW, tW0,(LifeSpan(Q1,t1))
+ 3), A = NAT, It
= Comput(Q1, t1,LifeSpan(Q1,t1));
A6:     I is_closed_onInit t,Q by SCM_HALT:35;
A7:     while>0(a,I) c= Iwhile by SCMFSA6A:26;
        Iwhile c= tW0 by FUNCT_4:26;
        then while>0(a,I) c= tW0 by A7,XBOOLE_1:1;
        then while>0(a,I) c= Wt by AMI_1:81;
        then
A8:     Wt +* while>0(a,I) = Wt by FUNCT_4:79;
        not l0 in A by SCMFSA_2:84;
        then not l0 in dom t /\ A by XBOOLE_0:def 4;
        then
A9:     not l0 in dom (t | A) by RELAT_1:90;
A10:    I is_halting_onInit t,Q by SCM_HALT:36;
        then
A11:    Q1 halts_on t1 by SCM_HALT:def 5;
A12:    not t.a <= 0 by A1,A5;
        then
A13:    DataPart Wt = DataPart It by A6,A10,Th21;
        then
A14:    Wt.l0 =It.l0 by SCMFSA6A:38
          .=(Result(Q1,t1)).l0 by A11,EXTPRO_1:23
          .=(Result(Q1,t1) +* t | A).l0 by A9,FUNCT_4:12
          .=IExec(I,Q,t).l0 by SCMFSA6B:def 1
          .=1 by SCM_HALT:17;
        DataPart Wt = DataPart Result(Q1,t1) by A13,A11,
EXTPRO_1:23
          .= DataPart(Result(Q1,t1) +* t | A) by COMPOS_1:82
          .= DataPart IExec(I,Q,t) by SCMFSA6B:def 1;
        then f.Wt=f.IExec(I,Q,t) by A1;
        then f.Wt < k+1 by A1,A5;
        then while>0(a,I) is_halting_onInit Wt, QW by A3,INT_1:20;
        then
A15:    QW +* while>0(a,I) halts_on Wt+*Iwhile by SCM_HALT:def 5;
        IC Wt= 0 by A12,A6,A10,Th21;
        then
A16:    Wt +* Iwhile = Wt by A14,A8,Th6;
A17:    QW +* while>0(a,I) = QW by FUNCT_4:99;
        now
          consider m be Element of NAT such that
A18:      CurInstr(QW,Comput(QW,Wt,m))
 = halt SCM+FSA by A16,A15,EXTPRO_1:30,A17;
          take mm=((LifeSpan(Q1,t1))+ 3)+m;
          thus CurInstr(QW,Comput(QW,tW0,mm))
           = halt SCM+FSA by A18,EXTPRO_1:5;
        end;
        then QW halts_on tW0 by EXTPRO_1:30;
        hence while>0(a,I) is_halting_onInit t,Q by SCM_HALT:def 5;
      end;
    end;
    hence P[k+1];
  end;
A19: P[ 0]
  proof
    let t be State of SCM+FSA,Q;
    assume f.t <= 0;
    then t.a <= 0 by A1;
    hence thesis by Th16;
  end;
A20: for k be Element of NAT holds P[k] from NAT_1:sch 1(A19,A2);
  now
    let t be State of SCM+FSA;
    per cases;
    suppose
      f.t<=0;
      then t.a <= 0 by A1;
      hence while>0(a,I) is_halting_onInit t,Q by Th16;
    end;
    suppose
      f.t>0;
      then reconsider n=f.t as Element of NAT by INT_1:16;
      P[n] by A20;
      hence while>0(a,I) is_halting_onInit t,Q;
    end;
  end;
  hence thesis by SCM_HALT:36;
end;

theorem Th32:
  for s be State of SCM+FSA, I be Program of SCM+FSA, a be
  read-write Int-Location st s.a <= 0
   holds DataPart IExec(while>0(a,I),P,s) =
  DataPart Initialized s
proof
  set A = NAT;
  let s be State of SCM+FSA, I be Program of SCM+FSA, a be read-write
  Int-Location;
  set D = Data-Locations SCM+FSA;
  set Is=Initialized s;
  set s1 = Is +* (Initialize while>0(a,I)),
      P1 = P +* while>0(a,I);
A1: while>0(a,I) c= P1 by FUNCT_4:26;
  set s2 = Comput(P1, s1,1);
  set s3 = Comput(P1,s1,2);
  set s4 = Comput(P1,s1,3);
  set s5 = Comput(P1,s1,4);
  set i = a >0_goto  4;
A2:  1 in dom while>0(a,I) by SCMFSA_9:10;
A3: P1. 1 = P1. 1
    .= while>0(a,I). 1 by A2,A1,GRFUNC_1:8
    .= goto  2 by SCMFSA_9:11;
  IC SCM+FSA in dom (Initialize while>0(a,I))
  by COMPOS_1:141;
  then
A4: IC s1 = IC(Initialize while>0(a,I)) by FUNCT_4:14
    .=  0 by COMPOS_1:142;
  0 in dom while>0(a,I) by SCMFSA_9:10;
  then
A5: P1. 0
     = while>0(a,I). 0 by A1,GRFUNC_1:8
    .= i by SCMFSA_9:11;
  then
A6: CurInstr(P1,s1) = i by A4,PBOOLE:158;
A7: Comput(P1, s1,0 + 1) =
Following(P1,Comput(P1,s1,0)
)
 by EXTPRO_1:4
    .= Following(P1,s1) by EXTPRO_1:3
    .= Exec(i,s1) by A4,A5,PBOOLE:158;
  set loc5=  (card I +5);
A8:  2 in dom while>0(a,I) by SCMFSA_9:37;
A9: P1. 2 = P1. 2
    .= while>0(a,I). 2 by A8,A1,GRFUNC_1:8
    .= goto  3 by SCMFSA_9:41;
A10: IC Is =  0 by SCMFSA6C:3;
A11: loc5 in dom while>0(a,I) by SCMFSA_9:38;
  not a in dom (Initialize while>0(a,I)) by SCMFSA6B:12;
  then
A12: s1.a = Is.a by FUNCT_4:12;
A13:  3 in dom while>0(a,I) by SCMFSA_9:37;
  assume s.a <= 0;
  then Is.a <= 0 by SCMFSA6C:3;
  then
A14: IC Comput(P1,s1,1) = succ  0 by A4,A7,A12,SCMFSA_2:97
    .=  (0 + 1);
A15: Comput(P1, s1,1 + 1) = Following(P1,s2) by EXTPRO_1:4
    .= Exec(goto  2,s2) by A14,A3,PBOOLE:158;
  then
A16: IC s3 =  2 by SCMFSA_2:95;
A17:  P1/.IC s3 = P1.IC s3 by PBOOLE:158;
A18: Comput(P1, s1,2 + 1) = Following(P1,s3) by
EXTPRO_1:4
    .= Exec(goto  3,s3) by A15,A9,A17,SCMFSA_2:95;
A19: P1. 3 = P1. 3
    .= while>0(a,I). 3 by A13,A1,GRFUNC_1:8
    .= goto loc5 by SCMFSA_9:40;
A20:  P1/.IC s4 = P1.IC s4 by PBOOLE:158;
A21: Comput(P1, s1,3 + 1) = Following(P1,s4) by
EXTPRO_1:4
    .= Exec(goto loc5,s4) by A18,A19,A20,SCMFSA_2:95;
A22:  P1/.IC s5 = P1.IC s5 by PBOOLE:158;
  P1.loc5 = P1.loc5
    .= while>0(a,I).loc5 by A11,A1,GRFUNC_1:8
    .= halt SCM+FSA by SCMFSA_9:39;
  then
A23: CurInstr(P1,s5) = halt SCM+FSA by A21,A22,SCMFSA_2:95;
  then
A24: P1 halts_on s1 by EXTPRO_1:30;
A25:  P1/.IC s4 = P1.IC s4 by PBOOLE:158;
A26: CurInstr(P1,s4) = goto loc5 by A18,A19,A25,SCMFSA_2:95;
  now
    let k be Element of NAT;
    assume
A27: CurInstr(P1,Comput(P1,s1,k)) = halt SCM+FSA;
    then
A28: k <> 2 by A16,A9,PBOOLE:158;
A29: k <> 0 by A27,A6,EXTPRO_1:3;
A30:    k <> 1 by A14,A3,A27,PBOOLE:158;
    3<k by A29,A28,A30,A26,A27,NAT_1:28;
    hence 3+1<=k by INT_1:20;
  end;
  then
A31: LifeSpan(P1,s1) = 4 by A23,A24,EXTPRO_1:def 14;
A32: Is +* Initialized while>0(a,I) =
     Initialized Is +* (Initialize while>0(a,I)) by SCMFSA8A:13
    .=s1 by SCMFSA8C:15;
  Is.intloc 0=1 by SCMFSA6C:3;
  then
A33: s1=Is+*while>0(a,I) by A32,A10,Th6;
A34: now
    let a be Int-Location;
    thus Is.a = s1.a by A33,FUNCT_7:132,SCMFSA10:92
      .=s2.a by A7,SCMFSA_2:97
      .=s3.a by A15,SCMFSA_2:95
      .=s4.a by A18,SCMFSA_2:95
      .=s5.a by A21,SCMFSA_2:95;
  end;
A35: now
    let f be FinSeq-Location;
    thus Is.f = s1.f by A33,FUNCT_7:132,SCMFSA10:93
      .=s2.f by A7,SCMFSA_2:97
      .=s3.f by A15,SCMFSA_2:95
      .=s4.f by A18,SCMFSA_2:95
      .=s5.f by A21,SCMFSA_2:95;
  end;
  thus DataPart IExec(while>0(a,I),P,s)
   = DataPart IExec(while>0(a,I),P,Is) by
SCMFSA8C:17
    .= DataPart(Result(P +* while>0(a,I),Is +*
Initialized while>0(a,I)) +* Is | A) by SCMFSA6B:def 1
    .= DataPart(Result(P1,s1)) by A32,COMPOS_1:82
    .= DataPart s5 by A24,A31,EXTPRO_1:23
    .= DataPart Is by A34,A35,SCMFSA6A:38;
end;

theorem Th33:
  for s be State of SCM+FSA, I be good InitHalting Program of
SCM+FSA, a be read-write Int-Location st s.a > 0 & while>0(a,I) is InitHalting
holds DataPart IExec(while>0(a,I),P,s) =
 DataPart IExec(while>0(a,I),P,IExec(I,P,s))
proof
  set A = NAT;
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, a be
  read-write Int-Location;
  set D = Data-Locations SCM+FSA;
  assume that
A1: s.a > 0 and
A2: while>0(a,I) is InitHalting;
  set ps = s | NAT, sI = s +* Initialized I,
      PI = P +* I,
      Iwhile= Initialized while>0(a,I),
      sW = s +* Iwhile,
      PW = P +* while>0(a,I),
      s3 = Comput(PI, sI,LifeSpan(PI,sI)) +* Iwhile,
      P3 = PI +* while>0(a,I),
      m1 = LifeSpan(PI,sI), m3 = LifeSpan(P3,s3);
A3:  I c= PI by FUNCT_4:26;
A4:  while>0(a,I) c= P3 by FUNCT_4:26;
A5:  while>0(a,I) c= PW by FUNCT_4:26;
A6: ProgramPart Iwhile = while>0(a,I) by SCMFSA6A:33;
A7: ProgramPart Initialized I = I by SCMFSA6A:33;
A8: Iwhile c= sW by FUNCT_4:26;
  then
A9: PW halts_on sW by A2,EXTPRO_1:def 10,A5,A6;
  set mW=LifeSpan(PW,sW);
A10: Iwhile c= s3 by FUNCT_4:26;
  then
A11: P3 halts_on s3 by A2,EXTPRO_1:def 10,A4,A6;
A12: DataPart Comput(PW, Comput(PW,sW,m1+3),m3+mW) = DataPart
  Comput(P3,s3,m3)
  proof
    reconsider Wg=while>0(a,I) as good InitHalting Program of SCM+FSA by A2;
    set Cm3=Comput(PW,sW,m1+3);
A13: I is_halting_onInit s,P by SCM_HALT:36;
A14: I is_closed_onInit s,P by SCM_HALT:35;
    then
A15: IC Cm3= 0 by A1,A13,Th21;
A16: DataPart Cm3 = DataPart Comput(PI,sI,m1) by A1,A14,A13,Th21
      .= DataPart(Comput(PI,sI,m1) +* while>0(a,I)) by COMPOS_1:82;
A17: now
      let f be FinSeq-Location;
A18:  not f in dom while>0(a,I) by Th13;
      not f in dom Iwhile by SCMFSA6A:49;
      hence s3.f = Comput(PI,sI,m1).f by FUNCT_4:12
        .=(Comput(PI,sI,m1) +* while>0(a,I)).f by A18,FUNCT_4:12
        .=Cm3.f by A16,SCMFSA6A:38;
    end;
A19: Initialized Wg c= sW by FUNCT_4:26;
A20: Cm3.intloc 0 =1 by SCM_HALT:def 3,A19,A5;
A21: now
      let b be Int-Location;
      per cases;
      suppose
A22:    b <> intloc 0;
A23:    not b in dom while>0(a,I) by Th14;
        not b in dom Iwhile by A22,SCMFSA6A:48;
        hence s3.b = Comput(PI,sI,m1).b by FUNCT_4:12
          .=(Comput(PI,sI,m1) +* while>0(a,I)).b by A23,FUNCT_4:12
          .=Cm3.b by A16,SCMFSA6A:38;
      end;
      suppose
        b = intloc 0;
        hence s3.b=Cm3.b by A20,FUNCT_4:26,SCM_HALT:7;
      end;
    end;
    while>0(a,I) c= Iwhile by SCMFSA6A:26;
    then while>0(a,I) c= sW by A8,XBOOLE_1:1;
    then while>0(a,I) c= Comput(PW,sW,m1+3) by AMI_1:81;
    then Cm3 +* while>0(a,I) = Cm3 by FUNCT_4:79;
    then Cm3 +* Iwhile = Cm3 by A15,A20,Th6;
    then
A24: Iwhile c= Cm3 by FUNCT_4:26;
    then
A25: PW halts_on Cm3 by A2,EXTPRO_1:def 10,A5,A6;
    IC Cm3=IC s3 by A15,FUNCT_4:26,SCMFSA6B:34;
    then
A26: Cm3,s3 equal_outside A by A17,A21,SCMFSA10:91;
    then LifeSpan(PW,Cm3) = m3 by A2,A10,A24,Th12,A5,A4;
    hence
    DataPart Comput(PW, Cm3,m3+mW)
     = DataPart Comput(PW, Cm3,LifeSpan(PW,
    Cm3)) by A25,EXTPRO_1:25,NAT_1:11
      .= DataPart Result(PW,Cm3) by A25,EXTPRO_1:23
      .= DataPart Result(P3,s3) by A2,A10,A24,A26,Th12,COMPOS_1:138,A5,A4
      .= DataPart Comput(P3,s3,m3) by A11,EXTPRO_1:23;
  end;
  Initialized I c= sI by FUNCT_4:26;
  then
A27: P +* I halts_on sI by EXTPRO_1:def 10,A3,A7;
A28: Iwhile c= IExec(I,P,s) +* Iwhile by FUNCT_4:26;
  Comput(PI,sI,m1) +* Iwhile, Comput(PI,sI,m1) +* ps
+* Iwhile
  equal_outside dom ps by FUNCT_7:31,106;
  then
A29: Comput(PI,sI,m1) +* ps +* Iwhile, Comput(PI,sI,
m1) +*Iwhile
  equal_outside dom ps by FUNCT_7:28;
A30: dom ps = dom s /\ A by RELAT_1:90
    .= (Data-Locations SCM+FSA \/ {IC SCM+FSA} \/ A) /\ A by COMPOS_1:172
    .= A by XBOOLE_1:21;
  then
A31: dom ps misses D by COMPOS_1:51;
  IExec(I,P,s)
   = Result(P +* I,s +* Initialized I) +* ps
by SCMFSA6B:def 1
    .= Comput(PI,sI,m1) +* ps by A27,EXTPRO_1:23;
  then
  Result(PW,IExec(I,P,s) +* Iwhile),
   Result(P3,s3) equal_outside A by A2,A10,A30,A29,A28,Th12,A5,A4;
  then
A32: Result(PW,IExec(I,P,s) +* Iwhile) +* ps =
Result(P3,s3) +* ps by A30,FUNCT_7:108;
  IExec(I,P,s) | A
   = (Result(P +* I,s +* Initialized I)
+* ps) | A by SCMFSA6B:def 1
    .= ps by PBOOLE:157;
  then
A33: IExec(while>0(a,I),P,IExec(I,P,s))
 = Result(PW,
IExec(I,P,s) +* Iwhile) +* ps by SCMFSA6B:def 1
    .= Comput(P3,s3,m3) +* ps by A11,A32,EXTPRO_1:23;
A34: mW <= (m1+3+m3) + mW by NAT_1:11;
  IExec(while>0(a,I),P,s) = Result(PW,s +* Iwhile) +* ps
by SCMFSA6B:def 1
    .= Comput(PW,sW,mW) +* ps by A9,EXTPRO_1:23
    .= Comput(PW,sW,m1+3+(m3+mW)) +* ps by A9,A34,EXTPRO_1:25;
  then DataPart IExec(while>0(a,I),P,s)
   = DataPart Comput(PW,sW,m1+3
+(m3+mW))
  by A31,FUNCT_4:76
    .= DataPart Comput(P3,s3,m3) by A12,EXTPRO_1:5
    .= DataPart IExec(while>0(a,I),P,IExec(I,P,s)) by A33,A31,FUNCT_4:76
;
  hence
  DataPart IExec(while>0(a,I),P,s) =
   DataPart IExec(while>0(a,I),P,IExec(I,P,s));
end;

theorem Th34:
  for s be State of SCM+FSA, I be Program of SCM+FSA, f be
FinSeq-Location,a be read-write Int-Location st s.a <= 0
 holds IExec(while>0(a,I),P,s).f=s.f
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA, f be FinSeq-Location,a be
  read-write Int-Location;
  set D = Data-Locations SCM+FSA;
  assume
A1: s.a <= 0;
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A2: f in D by XBOOLE_0:def 3,SCMFSA_2:127;
  hence IExec(while>0(a,I),P,s).f =(DataPart IExec(while>0(a,I),P,s)).f by
FUNCT_1:72
    .= (DataPart Initialized s).f by A1,Th32
    .= (Initialized s).f by A2,FUNCT_1:72
    .= s.f by SCMFSA6C:3;
end;

theorem Th35:
  for s be State of SCM+FSA, I be Program of SCM+FSA, b be
Int-Location,a be read-write Int-Location st s.a <= 0
 holds IExec(while>0(a,I),P,s).b=(Initialized s).b
proof
  let s be State of SCM+FSA,I be Program of SCM+FSA, b be Int-Location,a be
  read-write Int-Location;
  set D = Data-Locations SCM+FSA;
  assume
A1: s.a <= 0;
  b in Int-Locations by SCMFSA_2:9;
  then
A2: b in D by XBOOLE_0:def 3,SCMFSA_2:127;
  hence IExec(while>0(a,I),P,s).b =(DataPart IExec(while>0(a,I),P,s)).b by
FUNCT_1:72
    .= (DataPart Initialized s).b by A1,Th32
    .= (Initialized s).b by A2,FUNCT_1:72;
end;

theorem Th36:
  for s be State of SCM+FSA, I be good InitHalting Program of
SCM+FSA, f be FinSeq-Location,a be read-write Int-Location st s.a > 0 & while>0
(a,I) is InitHalting
 holds IExec(while>0(a,I),P,s).f =IExec(while>0(a,I),P,IExec(I,P,
  s)).f
proof
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, f be
  FinSeq-Location,a be read-write Int-Location;
  set D = Data-Locations SCM+FSA;
  assume that
A1: s.a > 0 and
A2: while>0(a,I) is InitHalting;
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A3: f in D by XBOOLE_0:def 3,SCMFSA_2:127;
  then IExec(while>0(a,I),P,s).f =(DataPart IExec(while>0(a,I),P,s)).f by
FUNCT_1:72
    .=(DataPart IExec(while>0(a,I),P,IExec(I,P,s))).f by A1,A2,Th33;
  hence thesis by A3,FUNCT_1:72;
end;

theorem Th37:
  for s be State of SCM+FSA, I be good InitHalting Program of
SCM+FSA, b be Int-Location,a be read-write Int-Location st s.a > 0 & while>0(a,
I) is InitHalting holds IExec(while>0(a,I),P,s).b
 =IExec(while>0(a,I),P,IExec(I,P,s))
  .b
proof
  let s be State of SCM+FSA,I be good InitHalting Program of SCM+FSA, b be
  Int-Location,a be read-write Int-Location;
  set D = Data-Locations SCM+FSA;
  assume that
A1: s.a > 0 and
A2: while>0(a,I) is InitHalting;
  b in Int-Locations by SCMFSA_2:9;
  then
A3: b in D by XBOOLE_0:def 3,SCMFSA_2:127;
  then IExec(while>0(a,I),P,s).b =(DataPart IExec(while>0(a,I),P,s)).b by
FUNCT_1:72
    .=(DataPart IExec(while>0(a,I),P,IExec(I,P,s))).b by A1,A2,Th33;
  hence thesis by A3,FUNCT_1:72;
end;

begin   ::  - Insert Sort Algorithm -
set a0 = intloc 0;
set a1 = intloc 1;
set a2 = intloc 2;
set a3 = intloc 3;
set a4 = intloc 4;
set a5 = intloc 5;
set a6 = intloc 6;

set initializeWorkMem = ((intloc 2):= intloc 0) ';' ((intloc 3):= intloc 0)
';' ((intloc 4):= intloc 0) ';' ((intloc 5):= intloc 0) ';' ((intloc 6):=
intloc 0);

definition
  let f be FinSeq-Location;
  func insert-sort f -> Program of SCM+FSA equals
   (((intloc 2):= intloc 0) ';'
    ((intloc 3):= intloc 0) ';'
    ((intloc 4):= intloc 0) ';'
    ((intloc 5):= intloc 0) ';'
    ((intloc 6):= intloc 0)) ';'
    ((intloc 1):=len f) ';'
    SubFrom(intloc 1,intloc 0) ';'
    Times(intloc 1, (((intloc 2):=len f) ';'
    SubFrom(intloc 2,intloc 1) ';'
    ((intloc 3) := intloc 2) ';'
    AddTo(intloc 3,intloc 0) ';'
    ((intloc 6):=(f,intloc 3)) ';'
    SubFrom(intloc 4,intloc 4)) ';'
    while>0(intloc 2, ((intloc 5):=(f,intloc 2)) ';'
    SubFrom(intloc 5,intloc 6) ';'
    if>0(intloc 5,
       Macro SubFrom(intloc 2,intloc 2), AddTo(intloc 4,intloc 0) ';'
    SubFrom(intloc 2,intloc 0)) ) ';'
    Times(intloc 4, ((intloc 2):=intloc 3) ';'
    SubFrom(intloc 3,intloc 0) ';'
    ((intloc 5):=(f,intloc 2)) ';'
    ((intloc 6):=(f,intloc 3)) ';'
    ((f,intloc 2):= intloc 6) ';'
    ((f,intloc 3):=intloc 5) ) );
  coherence;
end;

definition
  func Insert-Sort-Algorithm -> Program of SCM+FSA equals
  insert-sort fsloc 0;
  coherence;
end;

theorem Th38:
  for f being FinSeq-Location holds UsedIntLoc (insert-sort f) = {
  intloc 0,intloc 1,intloc 2,intloc 3,intloc 4,intloc 5,intloc 6}
proof
  set m0=SubFrom(a2,a2), m1=Macro m0, m2=AddTo(a4,a0), m3=SubFrom(a2,a0),
   IF= if>0(a5, m1, m2 ';' m3), UIF = UsedIntLoc IF;
  set k2= a2:= a0, k3= a3:= a0, k4= a4:= a0, k5= a5:= a0;
  let f be FinSeq-Location;
  set i1= a2:=a3, i2= SubFrom(a3,a0), i3= a5:=(f,a2), i4= a6:=(f,a3), i5= (f,
  a2):=a6, i6= (f,a3):=a5, body3= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' i6, Ui123=
  UsedIntLoc (i1 ';' i2 ';'i3 ), Ui12=UsedIntLoc (i1 ';' i2 ), Ub3=UsedIntLoc
  body3;
A1: Ub3 = (UsedIntLoc (i1 ';' i2 ';'i3 ';'i4 ';' i5 )) \/ UsedIntLoc i6 by
SF_MASTR:34
    .= (UsedIntLoc (i1 ';' i2 ';'i3 ';'i4 ';' i5 )) \/ {a3,a5} by SF_MASTR:21
    .= (UsedIntLoc (i1 ';' i2 ';'i3 ';' i4)) \/ (UsedIntLoc i5) \/ {a3,a5}
  by SF_MASTR:34
    .= (UsedIntLoc (i1 ';' i2 ';'i3 ';' i4)) \/ {a2,a6} \/ {a3,a5} by
SF_MASTR:21
    .= Ui123 \/ (UsedIntLoc i4) \/ {a2,a6} \/ {a3,a5} by SF_MASTR:34
    .= Ui123 \/ {a6,a3} \/ {a2,a6} \/ {a3,a5} by SF_MASTR:21
    .= Ui123 \/ ({a6,a3} \/ {a2,a6}) \/ {a3,a5} by XBOOLE_1:4
    .= Ui123 \/ {a6,a3,a2,a6} \/ {a3,a5} by ENUMSET1:45
    .= Ui123 \/ {a6,a6,a2,a3} \/ {a3,a5} by ENUMSET1:107
    .= Ui123 \/ {a6,a2,a3} \/ {a3,a5} by ENUMSET1:71
    .= Ui123 \/ ({a6,a2} \/ {a3}) \/ {a3,a5} by ENUMSET1:43
    .= Ui123 \/ {a6,a2} \/ {a3} \/ {a3,a5} by XBOOLE_1:4
    .= Ui123 \/ {a6,a2} \/ ({a3} \/ {a3,a5}) by XBOOLE_1:4
    .= Ui123 \/ {a6,a2} \/ {a3,a3,a5} by ENUMSET1:42
    .= Ui123 \/ {a6,a2} \/ {a3,a5} by ENUMSET1:70
    .= Ui12 \/ (UsedIntLoc i3) \/ {a6,a2} \/ {a3,a5} by SF_MASTR:34
    .= Ui12 \/ {a5,a2} \/ {a6,a2} \/ {a3,a5} by SF_MASTR:21
    .= Ui12 \/ ({a5,a2} \/ {a6,a2}) \/ {a3,a5} by XBOOLE_1:4
    .= Ui12 \/ {a5,a2,a6,a2} \/ {a3,a5} by ENUMSET1:45
    .= Ui12 \/ {a2,a2,a6,a5} \/ {a3,a5} by ENUMSET1:123
    .= Ui12 \/ {a2,a6,a5} \/ {a3,a5} by ENUMSET1:71
    .= Ui12 \/ ({a2,a6} \/ {a5}) \/ {a3,a5} by ENUMSET1:43
    .= Ui12 \/ {a2,a6} \/ {a5} \/ {a3,a5} by XBOOLE_1:4
    .= Ui12 \/ {a2,a6} \/ ({a5} \/ {a3,a5}) by XBOOLE_1:4
    .= Ui12 \/ {a2,a6} \/ {a5,a3,a5} by ENUMSET1:43
    .= Ui12 \/ {a2,a6} \/ {a5,a5,a3} by ENUMSET1:98
    .= Ui12 \/ {a2,a6} \/ {a5,a3} by ENUMSET1:70
    .= (UsedIntLoc i1) \/ (UsedIntLoc i2) \/ {a2,a6} \/ {a5,a3} by SF_MASTR:35
    .= {a2,a3} \/ (UsedIntLoc i2) \/ {a2,a6} \/ {a5,a3} by SF_MASTR:18
    .= {a2,a3} \/ {a3,a0} \/ {a2,a6} \/ {a5,a3} by SF_MASTR:18
    .= {a2,a3,a3,a0} \/ {a2,a6} \/ {a5,a3} by ENUMSET1:45
    .= {a3,a3,a2,a0} \/ {a2,a6} \/ {a5,a3} by ENUMSET1:116
    .= {a3,a2,a0} \/ {a2,a6} \/ {a5,a3} by ENUMSET1:71
    .= {a3} \/ {a2,a0} \/ {a2,a6} \/ {a5,a3} by ENUMSET1:42
    .= {a3} \/ ({a2,a0} \/ {a2,a6}) \/ {a5,a3} by XBOOLE_1:4
    .= {a3} \/ {a2,a0,a2,a6} \/ {a5,a3} by ENUMSET1:45
    .= {a3} \/ {a2,a2,a0,a6} \/ {a5,a3} by ENUMSET1:104
    .= {a3} \/ {a2,a0,a6} \/ {a5,a3} by ENUMSET1:71
    .= {a3} \/ {a5,a3} \/ {a2,a0,a6} by XBOOLE_1:4
    .= {a3,a5,a3} \/ {a2,a0,a6} by ENUMSET1:43
    .= {a3,a3,a5} \/ {a2,a0,a6} by ENUMSET1:98
    .= {a3,a5} \/ {a2,a0,a6} by ENUMSET1:70;
  set n1=a5:=(f,a2), n2=SubFrom(a5,a6), body2=n1 ';'n2 ';' IF, Ub2=UsedIntLoc
  body2;
A2: UIF = {a5} \/ UsedIntLoc (m1) \/ UsedIntLoc(m2 ';' m3) by SCMBSORT:29
    .= {a5} \/ UsedIntLoc m0 \/ UsedIntLoc(m2 ';' m3) by SF_MASTR:32
    .= {a5} \/ {a2,a2} \/ UsedIntLoc(m2 ';' m3) by SF_MASTR:18
    .= {a5} \/ {a2,a2} \/ (UsedIntLoc m2 \/ UsedIntLoc m3) by SF_MASTR:35
    .= {a5} \/ {a2,a2} \/ ({a4,a0} \/ UsedIntLoc m3) by SF_MASTR:18
    .= {a5} \/ {a2,a2} \/ ({a4,a0} \/ {a2,a0}) by SF_MASTR:18
    .= {a5} \/ {a2} \/ ({a4,a0} \/ {a2,a0}) by ENUMSET1:69
    .= {a5} \/ {a2} \/ {a2,a0} \/ {a4,a0} by XBOOLE_1:4
    .= {a2,a5} \/ {a2,a0} \/ {a4,a0} by ENUMSET1:41
    .= {a2,a5,a2,a0} \/ {a4,a0} by ENUMSET1:45
    .= {a2,a2,a5,a0} \/ {a4,a0} by ENUMSET1:104
    .= {a2,a5,a0} \/ {a4,a0} by ENUMSET1:71
    .= {a2,a5,a0,a4,a0} by ENUMSET1:49
    .= {a2} \/ {a5,a0,a4,a0} by ENUMSET1:47
    .= {a2} \/ {a0,a0,a4,a5} by ENUMSET1:123
    .= {a2} \/ {a0,a4,a5} by ENUMSET1:71
    .= {a2,a0,a4,a5} by ENUMSET1:44
    .= {a2,a5,a4,a0} by ENUMSET1:107
    .= {a2,a5} \/ {a4,a0} by ENUMSET1:45;
  set WM=initializeWorkMem, j1=a1:=len f, j2=SubFrom(a1,a0), Uj1= UsedIntLoc (
  WM ';' j1);
A3: UsedIntLoc initializeWorkMem = UsedIntLoc (k2 ';' k3 ';' k4 ';' k5) \/
  UsedIntLoc (a6:= a0) by SF_MASTR:34
    .= UsedIntLoc (k2 ';' k3 ';' k4 ';' k5) \/ {a6,a0} by SF_MASTR:18
    .= UsedIntLoc (k2 ';' k3 ';' k4 ) \/ UsedIntLoc k5 \/ {a6,a0} by
SF_MASTR:34
    .= UsedIntLoc (k2 ';' k3 ';' k4 ) \/ {a5,a0} \/ {a6,a0} by SF_MASTR:18
    .= UsedIntLoc (k2 ';' k3 ) \/ UsedIntLoc k4 \/ {a5,a0} \/ {a6,a0} by
SF_MASTR:34
    .= UsedIntLoc (k2 ';' k3 ) \/ {a4,a0} \/ {a5,a0} \/ {a6,a0} by SF_MASTR:18
    .= UsedIntLoc k2 \/ UsedIntLoc k3 \/ {a4,a0} \/ {a5,a0} \/ {a6,a0} by
SF_MASTR:35
    .= UsedIntLoc k2 \/ {a3,a0} \/ {a4,a0} \/ {a5,a0} \/ {a6,a0} by SF_MASTR:18
    .= {a2,a0} \/ {a3,a0} \/ {a4,a0} \/ {a5,a0} \/ {a6,a0} by SF_MASTR:18
    .= {a2,a0} \/ {a3,a0} \/ {a4,a0} \/ ({a5,a0} \/ {a6,a0}) by XBOOLE_1:4
    .= {a2,a0} \/ {a3,a0} \/ {a4,a0} \/ {a0,a5,a6} by ENUMSET1:137
    .= {a0,a2,a3} \/ {a4,a0} \/ {a0,a5,a6} by ENUMSET1:137
    .= {a0,a2,a3} \/ {a4,a0} \/ ({a0} \/ {a5,a6}) by ENUMSET1:42
    .= {a0,a2,a3} \/ {a4,a0} \/ {a0} \/ {a5,a6} by XBOOLE_1:4
    .= {a0,a2,a3} \/ ({a4,a0} \/ {a0}) \/ {a5,a6} by XBOOLE_1:4
    .= {a0,a2,a3} \/ {a4,a0,a0} \/ {a5,a6} by ENUMSET1:43
    .= {a0,a2,a3} \/ ({a0,a0} \/ {a4}) \/ {a5,a6} by ENUMSET1:42
    .= {a0,a2,a3} \/ {a0,a0} \/ {a4} \/ {a5,a6} by XBOOLE_1:4
    .= {a0,a0,a0,a2,a3} \/ {a4} \/ {a5,a6} by ENUMSET1:48
    .= {a0,a2,a3} \/ {a4} \/ {a5,a6} by ENUMSET1:78
    .= {a0,a2,a3,a4} \/ {a5,a6} by ENUMSET1:46
    .= {a0,a2,a3,a4,a5,a6} by ENUMSET1:54
    .= {a0} \/ {a2,a3,a4,a5,a6} by ENUMSET1:51;
  set T3=Times(a4,body3), t1=a2:=len f, t2=SubFrom(a2,a1), t3=a3 := a2, t4=
  AddTo(a3,a0), t5=a6:=(f,a3), t6=SubFrom(a4,a4), Wg=while>0(a2,body2), t16=t1
  ';' t2 ';' t3 ';' t4 ';' t5 ';' t6, body1=t16 ';' Wg ';' T3, Ub1 =UsedIntLoc
  body1, Ut16=UsedIntLoc t16;
A4: Ut16=UsedIntLoc (t1 ';' t2 ';' t3 ';' t4 ';' t5 ) \/ UsedIntLoc t6 by
SF_MASTR:34
    .=UsedIntLoc (t1 ';' t2 ';' t3 ';' t4 ';' t5 ) \/ {a4,a4} by SF_MASTR:18
    .=UsedIntLoc (t1 ';' t2 ';' t3 ';' t4) \/ UsedIntLoc t5 \/ {a4,a4} by
SF_MASTR:34
    .=UsedIntLoc (t1 ';' t2 ';' t3 ';' t4) \/ {a3,a6} \/ {a4,a4} by SF_MASTR:21
    .=UsedIntLoc (t1 ';' t2 ';' t3) \/ UsedIntLoc t4 \/ {a3,a6} \/ {a4,a4}
  by SF_MASTR:34
    .=UsedIntLoc (t1 ';' t2 ';' t3) \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by
SF_MASTR:18
    .=UsedIntLoc (t1 ';' t2) \/ UsedIntLoc t3 \/ {a3,a0} \/ {a3,a6} \/ {a4,
  a4} by SF_MASTR:34
    .=UsedIntLoc (t1 ';' t2) \/ {a3,a2} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by
SF_MASTR:18
    .=UsedIntLoc t1 \/ UsedIntLoc t2 \/ {a3,a2} \/ {a3,a0} \/ {a3,a6} \/ {a4
  ,a4} by SF_MASTR:35
    .={a2} \/ UsedIntLoc t2 \/ {a3,a2} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by
SF_MASTR:22
    .={a2} \/ {a2,a1} \/ {a3,a2} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by
SF_MASTR:18
    .={a2,a2,a1} \/ {a3,a2} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:42
    .={a2,a1} \/ {a3,a2} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:70
    .={a2,a1,a3,a2} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:45
    .={a2,a2,a3,a1} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:107
    .={a2,a3,a1} \/ {a3,a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:71
    .={a2,a3,a1,a3,a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:49
    .={a2,a3,a1,a3} \/ {a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:50
    .={a3,a3,a1,a2} \/ {a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:123
    .={a3,a1,a2} \/ {a0} \/ {a3,a6} \/ {a4,a4} by ENUMSET1:71
    .={a3,a1,a2} \/ {a0} \/ {a3,a6} \/ {a4} by ENUMSET1:69
    .={a3,a1,a2} \/ {a3,a6} \/ {a0} \/ {a4} by XBOOLE_1:4
    .={a3,a1,a2,a3,a6} \/ {a0} \/ {a4} by ENUMSET1:49
    .={a3,a1,a2,a3} \/ {a6} \/ {a0} \/ {a4} by ENUMSET1:50
    .={a3,a3,a2,a1} \/ {a6} \/ {a0} \/ {a4} by ENUMSET1:107
    .={a3,a2,a1} \/ {a6} \/ {a0} \/ {a4} by ENUMSET1:71
    .={a3,a2,a1} \/ ({a6} \/ {a0}) \/ {a4} by XBOOLE_1:4
    .={a3,a2,a1} \/ {a6,a0} \/ {a4} by ENUMSET1:41
    .={a3,a2,a1} \/ ({a6,a0} \/ {a4}) by XBOOLE_1:4
    .={a3,a2,a1} \/ {a6,a0,a4} by ENUMSET1:43
    .={a3,a2,a1} \/ {a6,a4,a0} by ENUMSET1:98;
A5: Ub2 = UsedIntLoc (n1 ';'n2) \/ UIF by SF_MASTR:31
    .= UsedIntLoc n1 \/ UsedIntLoc n2 \/ UIF by SF_MASTR:35
    .= {a2,a5} \/ UsedIntLoc n2 \/ UIF by SF_MASTR:21
    .= {a2,a5} \/ {a5,a6} \/ UIF by SF_MASTR:18
    .= {a2,a5,a5,a6} \/ UIF by ENUMSET1:45
    .= {a5,a5,a2,a6} \/ UIF by ENUMSET1:116
    .= {a5,a2,a6} \/ ({a2,a5} \/ {a4,a0}) by A2,ENUMSET1:71
    .= {a5,a2,a6} \/ {a2,a5} \/ {a4,a0} by XBOOLE_1:4
    .= {a2,a5,a5,a2,a6} \/ {a4,a0} by ENUMSET1:48
    .= {a2,a5,a5,a2} \/ {a6} \/ {a4,a0} by ENUMSET1:50
    .= {a2,a2,a5,a5} \/ {a6} \/ {a4,a0} by ENUMSET1:107
    .= {a2,a5,a5} \/ {a6} \/ {a4,a0} by ENUMSET1:71
    .= {a5,a5,a2} \/ {a6} \/ {a4,a0} by ENUMSET1:102
    .= {a5,a2} \/ {a6} \/ {a4,a0} by ENUMSET1:70
    .= {a5,a2,a6} \/ {a4,a0} by ENUMSET1:43
    .= {a5,a2,a6,a4,a0} by ENUMSET1:49;
A6: Ub1 = UsedIntLoc (t16 ';' Wg) \/ UsedIntLoc T3 by SF_MASTR:31
    .= UsedIntLoc (t16 ';' Wg) \/ (Ub3 \/ {a4,a0}) by SCMBSORT:31
    .= Ut16 \/ UsedIntLoc Wg \/ (Ub3 \/ {a4,a0}) by SF_MASTR:31
    .= Ut16 \/ ({a5,a2,a6,a4,a0} \/ {a2}) \/ (Ub3 \/ {a4,a0}) by A5,SCMFSA9A:30
    .= Ut16 \/ {a2,a5,a2,a6,a4,a0} \/ (Ub3 \/ {a4,a0}) by ENUMSET1:51
    .= Ut16 \/ ({a2,a5,a2,a6} \/ {a4,a0}) \/ (Ub3 \/ {a4,a0}) by ENUMSET1:54
    .= Ut16 \/ ({a2,a2,a5,a6} \/ {a4,a0}) \/ (Ub3 \/ {a4,a0}) by ENUMSET1:104
    .= Ut16 \/ ({a2,a5,a6} \/ {a4,a0}) \/ (Ub3 \/ {a4,a0}) by ENUMSET1:71
    .= Ut16 \/ {a2,a5,a6,a4,a0} \/ (Ub3 \/ {a4,a0}) by ENUMSET1:49
    .= Ut16 \/ ({a6,a4,a0} \/ {a2,a5}) \/ (Ub3 \/ {a4,a0}) by ENUMSET1:48
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a6,a4,a0} \/ {a2,a5} \/ (Ub3 \/ {a4,a0})
  by A4,XBOOLE_1:4
    .= {a3,a2,a1} \/ ({a6,a4,a0} \/ {a6,a4,a0}) \/ {a2,a5} \/ (Ub3 \/ {a4,a0
  }) by XBOOLE_1:4
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a2,a5} \/ ({a3,a5} \/ ({a2,a0,a6} \/ {a4
  ,a0})) by A1,XBOOLE_1:4
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a2,a5} \/ ({a3,a5} \/ {a2,a0,a6,a4,a0})
  by ENUMSET1:49
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a2,a5} \/ ({a3,a5} \/ ({a2} \/ {a0,a6,a4
  ,a0})) by ENUMSET1:47
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a2,a5} \/ ({a3,a5} \/ ({a2} \/ {a0,a0,a4
  ,a6})) by ENUMSET1:107
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a2,a5} \/ ({a3,a5} \/ ({a2} \/ {a0,a4,a6
  })) by ENUMSET1:71
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a2,a5} \/ ({a3,a5} \/ {a2,a0,a4,a6}) by
ENUMSET1:44
    .= {a3,a2,a1} \/ {a6,a4,a0} \/ {a2,a5} \/ {a3,a5,a2,a0,a4,a6} by
ENUMSET1:52
    .= {a3,a2,a1} \/ {a0,a4,a6} \/ {a5,a2} \/ {a3,a5,a2,a0,a4,a6} by
ENUMSET1:102
    .= {a3,a2,a1} \/ ({a0,a4,a6} \/ {a5,a2}) \/ {a3,a5,a2,a0,a4,a6} by
XBOOLE_1:4
    .= {a3,a2,a1} \/ {a5,a2,a0,a4,a6} \/ {a3,a5,a2,a0,a4,a6} by ENUMSET1:48
    .= {a3,a2,a1} \/ {a5,a2,a0,a4,a6} \/ ({a5,a2,a0,a4,a6} \/ {a3}) by
ENUMSET1:51
    .= {a3,a2,a1} \/ {a5,a2,a0,a4,a6} \/ {a5,a2,a0,a4,a6} \/ {a3} by XBOOLE_1:4
    .= {a3,a2,a1} \/ ({a5,a2,a0,a4,a6} \/ {a5,a2,a0,a4,a6}) \/ {a3} by
XBOOLE_1:4
    .= {a3,a2,a1,a5,a2,a0,a4,a6} \/ {a3} by ENUMSET1:64
    .= {a3,a2,a1,a5,a2} \/ {a0,a4,a6} \/ {a3} by ENUMSET1:66
    .= {a3} \/ {a2,a1,a5,a2} \/ {a0,a4,a6} \/ {a3} by ENUMSET1:47
    .= {a3} \/ {a2,a2,a5,a1} \/ {a0,a4,a6} \/ {a3} by ENUMSET1:107
    .= {a3} \/ {a2,a5,a1} \/ {a0,a4,a6} \/ {a3} by ENUMSET1:71
    .= {a3,a2,a5,a1} \/ {a0,a4,a6} \/ {a3} by ENUMSET1:44
    .= {a1,a5,a2,a3} \/ {a0,a4,a6} \/ {a3} by ENUMSET1:125
    .= {a1,a5,a2,a3,a0,a4,a6} \/ {a3} by ENUMSET1:59
    .= {a1} \/ {a5,a2,a3,a0,a4,a6} \/ {a3} by ENUMSET1:56
    .= {a1} \/ ({a5,a2,a3,a0,a4} \/ {a6}) \/ {a3} by ENUMSET1:55
    .= {a1} \/ {a5,a2,a3,a0,a4} \/ {a6} \/ {a3} by XBOOLE_1:4
    .= {a1} \/ {a5,a2,a3,a0,a4} \/ {a3} \/ {a6} by XBOOLE_1:4
    .= {a1} \/ ({a5,a2,a3,a0,a4} \/ {a3}) \/ {a6} by XBOOLE_1:4
    .= {a1} \/ {a5,a2,a3,a0,a4,a3} \/ {a6} by ENUMSET1:55
    .= {a1} \/ ({a5,a2} \/ {a3,a0,a4,a3}) \/ {a6} by ENUMSET1:52
    .= {a1} \/ ({a5,a2} \/ {a3,a3,a4,a0}) \/ {a6} by ENUMSET1:107
    .= {a1} \/ ({a5,a2} \/ {a3,a4,a0}) \/ {a6} by ENUMSET1:71
    .= {a1} \/ {a5,a2,a3,a4,a0} \/ {a6} by ENUMSET1:48
    .= {a1} \/ ({a0} \/ {a5,a2,a3,a4}) \/ {a6} by ENUMSET1:50
    .= {a1} \/ {a0} \/ {a5,a2,a3,a4} \/ {a6} by XBOOLE_1:4
    .= {a0,a1} \/ {a5,a2,a3,a4} \/ {a6} by ENUMSET1:41
    .= {a0,a1} \/ {a2,a3,a4,a5} \/ {a6} by ENUMSET1:111
    .= {a0,a1,a2,a3,a4,a5} \/ {a6} by ENUMSET1:52
    .= {a0,a1,a2,a3,a4,a5,a6} by ENUMSET1:61;
  thus UsedIntLoc (insert-sort f) = UsedIntLoc (WM ';' j1 ';' j2) \/
  UsedIntLoc Times(a1,body1) by SF_MASTR:31
    .= UsedIntLoc (WM ';' j1 ';' j2) \/ (Ub1 \/ {a1,a0}) by SCMBSORT:31
    .= Uj1 \/ UsedIntLoc j2 \/ (Ub1 \/ {a1,a0}) by SF_MASTR:34
    .= Uj1 \/ {a1,a0} \/ (Ub1 \/ {a1,a0}) by SF_MASTR:18
    .= Uj1 \/ {a1,a0} \/ {a1,a0} \/ Ub1 by XBOOLE_1:4
    .= Uj1 \/ ({a1,a0} \/ {a1,a0}) \/ Ub1 by XBOOLE_1:4
    .= UsedIntLoc WM \/ UsedIntLoc j1 \/ {a1,a0} \/ Ub1 by SF_MASTR:34
    .= {a2,a3,a4,a5,a6} \/ {a0} \/ {a1} \/ {a1,a0} \/ Ub1 by A3,SF_MASTR:22
    .= {a2,a3,a4,a5,a6} \/ ({a0} \/ {a1}) \/ {a1,a0} \/ Ub1 by XBOOLE_1:4
    .= {a2,a3,a4,a5,a6} \/ {a1,a0} \/ {a1,a0} \/ Ub1 by ENUMSET1:41
    .= {a2,a3,a4,a5,a6} \/ ({a1,a0} \/ {a1,a0}) \/ Ub1 by XBOOLE_1:4
    .= {a0,a1,a2,a3,a4,a5,a6} \/ {a0,a1,a2,a3,a4,a5,a6} by A6,ENUMSET1:57
    .= {a0,a1,a2,a3,a4,a5,a6};
end;

theorem Th39:
  for f being FinSeq-Location holds UsedInt*Loc (insert-sort f) =
  {f}
proof
  set m0=SubFrom(a2,a2), m1=Macro m0, m2=AddTo(a4,a0), m3=SubFrom(a2,a0), IF=
  if>0(a5, m1, m2 ';' m3), UIF = UsedInt*Loc IF;
  set k2= a2:= a0, k3= a3:= a0, k4= a4:= a0, k5= a5:= a0;
  let f be FinSeq-Location;
  set i1= a2:=a3, i2= SubFrom(a3,a0), i3= a5:=(f,a2), i4= a6:=(f,a3), i5= (f,
  a2):=a6, i6= (f,a3):=a5, body3= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' i6, Ub3=
  UsedInt*Loc body3;
A1: Ub3 = UsedInt*Loc (i1 ';' i2 ';'i3 ';'i4 ';' i5 ) \/ UsedInt*Loc i6 by
SF_MASTR:50
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ';'i4 ';' i5 ) \/ {f} by SF_MASTR:37
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ';'i4) \/ UsedInt*Loc i5 \/ {f} by
SF_MASTR:50
    .= UsedInt*Loc (i1 ';' i2 ';'i3 ';'i4) \/ {f} \/ {f} by SF_MASTR:37
    .= UsedInt*Loc (i1 ';' i2 ';'i3) \/ UsedInt*Loc i4 \/ {f} \/ {f} by
SF_MASTR:50
    .= UsedInt*Loc (i1 ';' i2 ';'i3) \/ {f} \/ {f} \/ {f} by SF_MASTR:37
    .= UsedInt*Loc (i1 ';' i2) \/ UsedInt*Loc i3 \/ {f} \/ {f} \/ {f} by
SF_MASTR:50
    .= UsedInt*Loc (i1 ';' i2) \/ {f} \/ {f} \/ {f} \/ {f} by SF_MASTR:37
    .= UsedInt*Loc i1 \/ UsedInt*Loc i2 \/ {f} \/ {f} \/ {f} \/ {f} by
SF_MASTR:51
    .= {} \/ UsedInt*Loc i2 \/ {f} \/ {f} \/ {f} \/ {f} by SF_MASTR:36
    .= {} \/ {f} \/ {f} \/ {f} \/ {f} by SF_MASTR:36
    .= {f};
  set n1=a5:=(f,a2), n2=SubFrom(a5,a6), body2=n1 ';'n2 ';' IF, Ub2=UsedInt*Loc
  body2;
A2: UIF = UsedInt*Loc m1 \/ UsedInt*Loc (m2 ';' m3) by SCMFSA9A:16
    .= UsedInt*Loc m0 \/ UsedInt*Loc (m2 ';' m3) by SF_MASTR:48
    .= {} \/ UsedInt*Loc (m2 ';' m3) by SF_MASTR:36
    .= {} \/ (UsedInt*Loc m2 \/ UsedInt*Loc m3) by SF_MASTR:51
    .= {} \/ ({} \/ UsedInt*Loc m3) by SF_MASTR:36
    .= {} by SF_MASTR:36;
  set WM=initializeWorkMem, j1=a1:=len f, j2=SubFrom(a1,a0);
A3: UsedInt*Loc initializeWorkMem = UsedInt*Loc (k2 ';' k3 ';' k4 ';' k5) \/
  UsedInt*Loc (a6:= a0) by SF_MASTR:50
    .= UsedInt*Loc (k2 ';' k3 ';' k4 ';' k5) \/ {} by SF_MASTR:36
    .= UsedInt*Loc (k2 ';' k3 ';' k4) \/ UsedInt*Loc k5 by SF_MASTR:50
    .= UsedInt*Loc (k2 ';' k3 ';' k4) \/ {} by SF_MASTR:36
    .= UsedInt*Loc (k2 ';' k3 ) \/ UsedInt*Loc k4 by SF_MASTR:50
    .= UsedInt*Loc (k2 ';' k3 ) \/ {} by SF_MASTR:36
    .= UsedInt*Loc k2 \/ UsedInt*Loc k3 by SF_MASTR:51
    .= UsedInt*Loc k2 \/ {} by SF_MASTR:36
    .= {} by SF_MASTR:36;
  set T3=Times(a4,body3), t1=a2:=len f, t2=SubFrom(a2,a1), t3=a3 := a2, t4=
  AddTo(a3,a0), t5=a6:=(f,a3), t6=SubFrom(a4,a4), Wg=while>0(a2,body2), t16=t1
  ';' t2 ';' t3 ';' t4 ';' t5 ';' t6, body1=t16 ';' Wg ';' T3, Ub1 =UsedInt*Loc
  body1, Ut16 =UsedInt*Loc t16;
A4: Ut16= UsedInt*Loc (t1 ';'t2 ';' t3 ';' t4 ';' t5) \/ UsedInt*Loc t6 by
SF_MASTR:50
    .= UsedInt*Loc (t1 ';'t2 ';' t3 ';' t4 ';' t5) \/ {} by SF_MASTR:36
    .= UsedInt*Loc (t1 ';'t2 ';' t3 ';' t4) \/ UsedInt*Loc t5 \/ {} by
SF_MASTR:50
    .= UsedInt*Loc (t1 ';'t2 ';' t3 ';' t4) \/ {f} \/ {} by SF_MASTR:37
    .= UsedInt*Loc (t1 ';'t2 ';' t3) \/ UsedInt*Loc t4 \/ {f} \/ {} by
SF_MASTR:50
    .= UsedInt*Loc (t1 ';'t2 ';' t3) \/ {} \/ {f} \/ {} by SF_MASTR:36
    .= UsedInt*Loc (t1 ';'t2) \/ UsedInt*Loc t3 \/ {} \/ {f} \/ {} by
SF_MASTR:50
    .= UsedInt*Loc (t1 ';'t2) \/ {} \/ {} \/ {f} \/ {} by SF_MASTR:36
    .= UsedInt*Loc t1 \/ UsedInt*Loc t2 \/ {} \/ {} \/ {f} \/ {} by SF_MASTR:51
    .= {f} \/ UsedInt*Loc t2 \/ {} \/ {} \/ {f} \/ {} by SF_MASTR:38
    .= {f} \/ {f} \/ {} by SF_MASTR:36
    .= {f};
A5: Ub2 = UsedInt*Loc (n1 ';'n2) \/ UIF by SF_MASTR:47
    .= UsedInt*Loc n1 \/ UsedInt*Loc n2 \/ UIF by SF_MASTR:51
    .= {f} \/ UsedInt*Loc n2 \/ UIF by SF_MASTR:37
    .= {f} \/ {} by A2,SF_MASTR:36
    .= {f};
A6: UsedInt*Loc body1 = UsedInt*Loc (t16 ';' Wg ) \/ UsedInt*Loc T3 by
SF_MASTR:47
    .= UsedInt*Loc (t16 ';' Wg) \/ {f} by A1,SCMBSORT:37
    .= UsedInt*Loc t16 \/ UsedInt*Loc Wg \/ {f} by SF_MASTR:47
    .= {f} \/ {f} by A5,A4,SCMFSA9A:31
    .= {f};
  thus UsedInt*Loc (insert-sort f) = UsedInt*Loc (WM ';' j1 ';' j2) \/
  UsedInt*Loc Times(a1,body1) by SF_MASTR:47
    .= UsedInt*Loc (WM ';' j1 ';' j2) \/ {f} by A6,SCMBSORT:37
    .= UsedInt*Loc (WM ';' j1) \/ UsedInt*Loc j2 \/ {f} by SF_MASTR:50
    .= UsedInt*Loc (WM ';' j1) \/ {} \/ {f} by SF_MASTR:36
    .= UsedInt*Loc WM \/ UsedInt*Loc j1 \/ {} \/ {f} by SF_MASTR:50
    .= {f} \/ {f} by A3,SF_MASTR:38
    .= {f};
end;

theorem Th40:
  for k1,k2,k3,k4 being Instruction of SCM+FSA holds card( k1 ';'
  k2 ';' k3 ';' k4) =8
proof
  let k1,k2,k3,k4 be Instruction of SCM+FSA;
  thus card( k1 ';' k2 ';' k3 ';' k4)
     = card (k1 ';' k2 ';' k3)+ 2 by SCMFSA6A:76
    .= 6 + 2 by SCMBSORT:45
    .= 8;
end;

theorem Th41:
  for k1,k2,k3,k4,k5 being Instruction of SCM+FSA holds card( k1
  ';' k2 ';' k3 ';' k4 ';'k5) =10
proof
  let k1,k2,k3,k4,k5 be Instruction of SCM+FSA;
  thus card( k1 ';' k2 ';' k3 ';' k4 ';'k5)
     = card (k1 ';' k2 ';' k3 ';' k4)+ 2 by SCMFSA6A:76
    .= 8+ 2 by Th40
    .= 10;
end;

theorem Th42:
  for f being FinSeq-Location holds card insert-sort f = 82
proof
  set m1=Macro SubFrom(a2,a2), m2=AddTo(a4,a0), m3=SubFrom(a2,a0), IF=if>0(a5,
  m1, m2 ';' m3);
  let f be FinSeq-Location;
  set i1= a2:=a3, i2= SubFrom(a3,a0), i3= a5:=(f,a2), i4= a6:=(f,a3), i5= (f,
  a2):=a6, i6= (f,a3):=a5, body3= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' i6;
A1: card IF = card m1 + card (m2 ';' m3)+ 4 by SCMFSA8B:15
    .= 2 + card (m2 ';' m3)+ 4 by COMPOS_1:150
    .= 2 + (2 + 2)+ 4 by SCMFSA6A:77
    .= 10;
  set n1=a5:=(f,a2), n2=SubFrom(a5,a6), body2=n1 ';'n2 ';' IF;
A2: card body2 = card (n1 ';'n2) + card IF by SCMFSA6A:61
    .= 2 + 2 + 10 by A1,SCMFSA6A:77
    .= 14;
  set WM=initializeWorkMem, j1=a1:=len f, j2=SubFrom(a1,a0);
  set T3=Times(a4,body3), t1=a2:=len f, t2=SubFrom(a2,a1), t3=a3 := a2, t4=
  AddTo(a3,a0), t5=a6:=(f,a3), t6=SubFrom(a4,a4), Wg=while>0(a2,body2), t16=t1
  ';' t2 ';' t3 ';' t4 ';' t5 ';' t6, body1=t16 ';' Wg ';' T3;
A3: card body3 =
     card (i1 ';' i2 ';' i3 ';' i4 ';' i5) + 2 by SCMFSA6A:76
     .= 10+2 by Th41
    .=12;
A4: card body1 = card (t16 ';' Wg) + card T3 by SCMFSA6A:61
    .= card t16 + card Wg + card T3 by SCMFSA6A:61
    .= card (t1 ';' t2 ';' t3 ';' t4 ';' t5) + 2 + card Wg +
  card T3 by SCMFSA6A:76
    .= 10 + 2 + card Wg + card T3 by Th41
    .= 10 + 2 + card Wg + card T3
    .= 10 + 2 + (14 + 6) + card T3 by A2,SCMFSA_9:5
    .= 10 + 2 + (14 + 6) + (12+12) by A3,SCMBSORT:44
    .= 56;
  thus card (insert-sort f) = card (WM ';' j1 ';' j2 ) + card Times(a1,body1)
  by SCMFSA6A:61
    .= card (WM ';' j1 ';' j2 ) + (56+12) by A4,SCMBSORT:44
    .= card (WM ';' j1) + 2 + (56+12) by SCMFSA6A:76
    .= card WM + 2 + 2 + (56+12) by SCMFSA6A:76
    .= 10 + 2 + 2 + 68 by Th41
    .= 82;
end;

theorem Th43:
  for f being FinSeq-Location, k being Element of NAT st k < 82
  holds  k in dom (insert-sort f)
proof
  let f be FinSeq-Location, k be Element of NAT;
  assume
A1: k < 82;
  card (insert-sort f) = 82 by Th42;
  hence thesis by A1,AFINSQ_1:70;
end;

Lm1: for P st Insert-Sort-Algorithm c= P holds
 P.0= a2:=a0 &
 P.1= goto  2 &
 P.2= a3:=a0 &
 P.3= goto 4 &
 P.4= a4:=a0 &
 P.5= goto 6 &
 P.6= a5:=a0 &
 P.7= goto  8 &
 P.8= a6:=a0 &
 P.9= goto  10 &
 P.10= a1:=len fsloc 0 &
 P.11= goto  12
proof

  set f0=fsloc 0, TT=Times(a1, ((a2:=len f0) ';' SubFrom(a2,a1) ';' (a3 := a2)

';' AddTo(a3,a0) ';' (a6:=(f0,a3)) ';' SubFrom(a4,a4)) ';' while>0(a2, (a5:=(f0
  ,a2)) ';' SubFrom(a5,a6) ';' if>0(a5,Macro SubFrom(a2,a2), AddTo(a4,a0) ';'
  SubFrom(a2,a0)) ) ';' Times(a4, (a2:=a3) ';' SubFrom(a3,a0) ';' (a5:=(f0,a2))
  ';' (a6:=(f0,a3)) ';' ((f0,a2):=a6) ';'((f0,a3):=a5) ) );

  set q=Insert-Sort-Algorithm, q0=insert-sort f0;

  set W2=a2:= a0, W3=a3:= a0, W4=a4:= a0, W5=a5:= a0, W6=a6:= a0, W7=a1:=len

f0, W8=SubFrom(a1,a0), T8= W8 ';' TT, T7=W7 ';' T8, T6=W6 ';' T7, T5=W5 ';' T6,

T4=W4 ';' T5, T3=W3 ';' T4, X3=W2 ';' W3, X4=X3 ';' W4, X5=X4 ';' W5, X6=X5 ';'
  W6;
A1: dom Macro W2 = { 0,  1} by COMPOS_1:149;
  then
A2:  0 in dom Macro W2 by TARSKI:def 2;
A3:  1 in dom Macro W2 by A1,TARSKI:def 2;
A4: card X3 = 2 + 2 by SCMFSA6A:77
    .=4;
A5: q0=X6 ';' W7 ';' T8 by SCMFSA6A:69;
  then
A6: q0=X5 ';' W6 ';' T7 by SCMFSA6A:69;
  then
A7: q0=X4 ';' W5 ';' T6 by SCMFSA6A:69;
  then
A8: q0=X3 ';' W4 ';' T5 by SCMFSA6A:69;
  then
A9: q0 = W2 ';' W3 ';' T4 by SCMFSA6A:69
   .= Macro W2 ';' W3 ';' T4 by SCMFSA6A:59;
  q0=W2 ';' W3 ';' T4 by A8,SCMFSA6A:69;
  then
A10: q0=W2 ';' T3 by SCMFSA6A:73
     .= Macro W2 ';' T3 by SCMFSA6A:def 6;
  let P such that
A11: q c= P;
A12: now
    let i be Element of NAT;
    assume i< 82;
    then  i in dom q0 by Th43;
    hence q0. i= P. i by A11,GRFUNC_1:8;
  end;
  hence P. 0 = (Macro W2 ';' T3).0 by A10
    .= (Directed Macro W2). 0 by A2,SCMFSA8A:28
    .= W2 by SCMFSA7B:7;
A13: card Macro W2=2 by COMPOS_1:150;
A14: card X4=6 by SCMBSORT:45;
  then
A15: card X5 = 6 + 2 by SCMFSA6A:76
    .=8;
  then
A16: card X6 = 8 + 2 by SCMFSA6A:76
    .= 10;
  thus P. 1=q0. 1 by A12
    .= (Directed Macro W2). 1 by A10,A3,SCMFSA8A:28
    .= goto  2 by SCMFSA7B:8;
  thus P. 2=q0. 2 by A12
    .= W3 by A9,A13,SCMBSORT:51;
  thus P. 3=q0. (2+1) by A12
    .=goto  (2+2) by A9,A13,SCMBSORT:51
    .=goto  4;
  thus P. 4=q0. 4 by A12
    .= W4 by A8,A4,SCMBSORT:51;
  thus P. 5=q0. (4+1) by A12
    .=goto  (4+2) by A8,A4,SCMBSORT:51
    .=goto  6;
  thus P. 6=q0. 6 by A12
    .= W5 by A7,A14,SCMBSORT:51;
  thus P. 7=q0. (6+1) by A12
    .=goto  (6+2) by A7,A14,SCMBSORT:51
    .=goto  8;
  thus P. 8=q0. 8 by A12
    .= W6 by A6,A15,SCMBSORT:51;
  thus P. 9=q0. (8+1) by A12
    .=goto  (8+2) by A6,A15,SCMBSORT:51
    .=goto  10;
  thus P. 10=q0. 10 by A12
    .= W7 by A5,A16,SCMBSORT:52;
  thus P. 11=q0. (10+1) by A12
    .=goto  (10+2) by A5,A16,SCMBSORT:52
    .=goto  12;
end;

set f0=fsloc 0;

set b1=intloc (0+1),b2=intloc (1+1),b3=intloc (2+1),b4=intloc (3+1), b5=intloc
(4+1),b6=intloc (5+1);

set i1= b2:=b3, i2= SubFrom(b3,a0), i3= b5:=(f0,b2), i4= b6:=(f0,b3), i5= (f0,
b2):=b6, i6= (f0,b3):=b5, body3= i1 ';' i2 ';' i3 ';' i4 ';' i5 ';' i6, w2= b2
:= a0, w3= b3:= a0, w4= b4:= a0, w5= b5:= a0, w6= b6:= a0, T3=Times(b4,body3),
m0=SubFrom(b2,b2), m1=Macro m0, m2=AddTo(b4,a0), m3=SubFrom(b2,a0), IF=if>0(b5,
m1, m2 ';' m3), n1=b5:=(f0,b2), n2=SubFrom(b5,b6), body2=n1 ';'n2 ';' IF, t1=b2
:=len f0, t2=SubFrom(b2,b1), t3=b3:= b2, t4=AddTo(b3,a0), t5=b6:=(f0,b3), t6=
SubFrom(b4,b4), Wg=while>0(b2,body2), t16=t1 ';' t2 ';' t3 ';' t4 ';' t5 ';' t6
, body1=t16 ';' Wg ';' T3, WM=initializeWorkMem, j1=b1:=len f0, j2=SubFrom(b1,
a0);

Lm2: for s being 0-started State of SCM+FSA,P
     st Insert-Sort-Algorithm c= P
  holds (for k being Element of NAT st k>0 & k<12 holds
   Comput(P,s,k).IC SCM+FSA =  k &
   Comput(P, s,k).a0=s.a0 &
   Comput(P, s,k).fsloc 0=s.fsloc 0) &
   Comput(P, s,11).a1=len(s.fsloc 0) &
   Comput(P, s,11).a2=s.a0 &
   Comput(P, s,11).a3=s.a0 & Comput(P, s,11).a4=s.a0 &
   Comput(P, s,11).a5=s.a0 & Comput(P, s,11).a6=s.a0
proof
  let s be 0-started State of SCM+FSA, P such that
A1: Insert-Sort-Algorithm c= P;
A2: Comput(P,s,0) = s by EXTPRO_1:3;
  then
A3: IC Comput(P,s,0) =  0 by COMPOS_1:def 16;
  then
A4: Comput(P,s,0+1) = Exec(P.0,Comput(P,s,0)) by
EXTPRO_1:7
    .= Exec(a2:=a0,Comput(P,s,0)) by A1,Lm1;
  then
A5: Comput(P,s,1).IC SCM+FSA = succ IC Comput(P,s,0)
by SCMFSA_2:89
    .=  1 by A3;
  then IC Comput(P,s,1)=  1;
  then
A6: Comput(P,s,1+1) = Exec(P.1,Comput(P,s,1)) by
EXTPRO_1:7
    .= Exec(goto  2,Comput(P,s,1)) by A1,Lm1;
  then
A7: Comput(P,s,2).IC SCM+FSA =  2 by SCMFSA_2:95;
  IC Comput(P,s,2)=  2 by A6,SCMFSA_2:95;
  then
A8: Comput(P,s,2+1) = Exec(P.2,Comput(P,s,2)) by
EXTPRO_1:7
    .= Exec(a3:=a0,Comput(P,s,2)) by A1,Lm1;

  then
A9: Comput(P,s,3).IC SCM+FSA = succ IC Comput(P,s,2)
by SCMFSA_2:89

    .=  3 by A7;
  then IC Comput(P,s,3)=  3;
  then
A10: Comput(P,s,3+1) = Exec(P.3,Comput(P,s,3)) by
EXTPRO_1:7
    .= Exec(goto  4,Comput(P,s,3)) by A1,Lm1;
  then
A11: Comput(P,s,4).IC SCM+FSA =  4 by SCMFSA_2:95;
A12: a2<>a0 by SCMFSA_2:128;
  then
A13: Comput(P,s,1).a0 =s.a0 by A2,A4,SCMFSA_2:89;
  then
A14: Comput(P,s,2).a0 =s.a0 by A6,SCMFSA_2:95;
  then Comput(P,s,3).a3 =s.a0 by A8,SCMFSA_2:89;
  then
A15: Comput(P,s,4).a3 =s.a0 by A10,SCMFSA_2:95;
  IC Comput(P,s,4)=  4 by A10,SCMFSA_2:95;
  then
A16: Comput(P,s,4+1) = Exec(P.4,Comput(P,s,4)) by
EXTPRO_1:7
    .= Exec(a4:=a0,Comput(P,s,4)) by A1,Lm1;

  then
A17: Comput(P,s,5).IC SCM+FSA = succ IC Comput(P,s,4)
by SCMFSA_2:89

    .=  5 by A11;
  then IC Comput(P,s,5)=  5;
  then
A18: Comput(P,s,5+1) = Exec(P.5,Comput(P,s,5)) by
EXTPRO_1:7
    .= Exec(goto  6,Comput(P,s,5)) by A1,Lm1;
  then
A19: Comput(P,s,6).IC SCM+FSA =  6 by SCMFSA_2:95;
  IC Comput(P,s,6)=  6 by A18,SCMFSA_2:95;
  then
A20: Comput(P,s,6+1) = Exec(P.6,Comput(P,s,6)) by
EXTPRO_1:7
    .= Exec(a5:=a0,Comput(P,s,6)) by A1,Lm1;

  then
A21: Comput(P,s,7).IC SCM+FSA = succ IC Comput(P,s,6)
by SCMFSA_2:89

    .=  7 by A19;
  then IC Comput(P,s,7)=  7;
  then
A22: Comput(P,s,7+1) = Exec(P.7,Comput(P,s,7)) by
EXTPRO_1:7
    .= Exec(goto  8,Comput(P,s,7)) by A1,Lm1;
  then
A23: Comput(P,s,8).IC SCM+FSA =  8 by SCMFSA_2:95;
  IC Comput(P,s,8)=  8 by A22,SCMFSA_2:95;
  then
A24: Comput(P,s,8+1) = Exec(P.8,Comput(P,s,8)) by
EXTPRO_1:7
    .= Exec(a6:=a0,Comput(P,s,8)) by A1,Lm1;

  then
A25: Comput(P,s,9).IC SCM+FSA = succ IC Comput(P,s,8)
by SCMFSA_2:89

    .=  9 by A23;
  then IC Comput(P,s,9)=  9;
  then
A26: Comput(P,s,9+1) = Exec(P.9,Comput(P,s,9)) by
EXTPRO_1:7
    .= Exec(goto  10,Comput(P,s,9)) by A1,Lm1;
  then
A27: Comput(P,s,10).IC SCM+FSA =  10 by SCMFSA_2:95;
A28: Comput(P,s,1).(fsloc 0) =s.(fsloc 0) by A2,A4,SCMFSA_2:89;
  then
A29: Comput(P,s,2).(fsloc 0) =s.(fsloc 0) by A6,SCMFSA_2:95;
  then
A30: Comput(P,s,3).(fsloc 0) =s.(fsloc 0) by A8,SCMFSA_2:89;
  then
A31: Comput(P,s,4).(fsloc 0) =s.(fsloc 0) by A10,SCMFSA_2:95;
  then
A32: Comput(P,s,5).(fsloc 0) =s.(fsloc 0) by A16,SCMFSA_2:89;
  then
A33: Comput(P,s,6).(fsloc 0) =s.(fsloc 0) by A18,SCMFSA_2:95;
  then
A34: Comput(P,s,7).(fsloc 0) =s.(fsloc 0) by A20,SCMFSA_2:89;
  then
A35: Comput(P,s,8).(fsloc 0) =s.(fsloc 0) by A22,SCMFSA_2:95;
  then
A36: Comput(P,s,9).(fsloc 0) =s.(fsloc 0) by A24,SCMFSA_2:89;
  then
A37: Comput(P,s,10).(fsloc 0) =s.(fsloc 0) by A26,SCMFSA_2:95;
A38: Comput(P,s,3).a0 =s.a0 by A14,A8,SCMFSA_2:89;
  then
A39: Comput(P,s,4).a0 =s.a0 by A10,SCMFSA_2:95;
  then Comput(P,s,5).a4 =s.a0 by A16,SCMFSA_2:89;
  then
A40: Comput(P,s,6).a4 =s.a0 by A18,SCMFSA_2:95;
A41: a4<>a0 by SCMFSA_2:128;
  then
A42: Comput(P,s,5).a0 =s.a0 by A39,A16,SCMFSA_2:89;
  then
A43: Comput(P,s,6).a0 =s.a0 by A18,SCMFSA_2:95;
  then Comput(P,s,7).a5 =s.a0 by A20,SCMFSA_2:89;
  then
A44: Comput(P,s,8).a5 =s.a0 by A22,SCMFSA_2:95;
  a4<>a5 by SCMFSA_2:128;
  then Comput(P,s,7).a4 =s.a0 by A40,A20,SCMFSA_2:89;
  then
A45: Comput(P,s,8).a4 =s.a0 by A22,SCMFSA_2:95;
  a4<>a6 by SCMFSA_2:128;
  then Comput(P,s,9).a4 =s.a0 by A45,A24,SCMFSA_2:89;
  then
A46: Comput(P,s,10).a4 =s.a0 by A26,SCMFSA_2:95;
  a5<>a6 by SCMFSA_2:128;
  then Comput(P,s,9).a5 =s.a0 by A44,A24,SCMFSA_2:89;
  then
A47: Comput(P,s,10).a5 =s.a0 by A26,SCMFSA_2:95;
A48: a5<>a0 by SCMFSA_2:128;
  then
A49: Comput(P,s,7).a0 =s.a0 by A43,A20,SCMFSA_2:89;
  then
A50: Comput(P,s,8).a0 =s.a0 by A22,SCMFSA_2:95;
  then Comput(P,s,9).a6 =s.a0 by A24,SCMFSA_2:89;
  then
A51: Comput(P,s,10).a6 =s.a0 by A26,SCMFSA_2:95;
  IC Comput(P,s,10)=  10 by A26,SCMFSA_2:95;

  then
A52: Comput(P,s,10+1) = Exec(P.10,Comput(P,s,10))
by EXTPRO_1:7

    .= Exec(a1:=len fsloc 0,Comput(P,s,10)) by A1,Lm1;

  then
A53: Comput(P,s,11).IC SCM+FSA = succ IC Comput(P,s,
10) by SCMFSA_2:100

    .=  11 by A27;
A54: a6<>a0 by SCMFSA_2:128;
  then
A55: Comput(P,s,9).a0 =s.a0 by A50,A24,SCMFSA_2:89;
  then
A56: Comput(P,s,10).a0 =s.a0 by A26,SCMFSA_2:95;
  hereby
    let k be Element of NAT;
    assume that
A57: k>0 and
A58: k<12;

    set c1= Comput(P, s,k).IC SCM+FSA, d1=  k,
       c2= Comput(P, s,k).a0,
       d2=s.a0,
       c3= Comput(P, s,k).fsloc 0, d3=s.fsloc 0;

    k<11+1 by A58;
    then
A59: k<=11 by NAT_1:13;
    per cases by A57,A59,NAT_1:36;
    suppose
      k = 1;
      hence c1=d1 & c2=d2 & c3=d3 by A2,A4,A5,A12,SCMFSA_2:89;
    end;
    suppose
      k = 2;
      hence c1=d1 & c2=d2 & c3=d3 by A13,A28,A6,SCMFSA_2:95;
    end;
    suppose
      k = 3;
      hence c1=d1 & c2=d2 & c3=d3 by A14,A29,A8,A9,SCMFSA_2:89;
    end;
    suppose
      k = 4;
      hence c1=d1 & c2=d2 & c3=d3 by A38,A30,A10,SCMFSA_2:95;
    end;
    suppose
      k = 5;
      hence c1=d1 & c2=d2 & c3=d3 by A39,A31,A16,A17,A41,SCMFSA_2:89;
    end;
    suppose
      k = 6;
      hence c1=d1 & c2=d2 & c3=d3 by A42,A32,A18,SCMFSA_2:95;
    end;
    suppose
      k = 7;
      hence c1=d1 & c2=d2 & c3=d3 by A43,A33,A20,A21,A48,SCMFSA_2:89;
    end;
    suppose
      k = 8;
      hence c1=d1 & c2=d2 & c3=d3 by A49,A34,A22,SCMFSA_2:95;
    end;
    suppose
      k = 9;
      hence c1=d1 & c2=d2 & c3=d3 by A50,A35,A24,A25,A54,SCMFSA_2:89;
    end;
    suppose
      k = 10;
      hence c1=d1 & c2=d2 & c3=d3 by A55,A36,A26,SCMFSA_2:95;
    end;
    suppose
A60:     k = 11;
      hence c1=d1 by A53;
       a0 <> a1 by SCMFSA_2:128;
      hence c2=d2 by A56,A52,A60,SCMFSA_2:100;
      thus c3=d3 by A37,A52,A60,SCMFSA_2:100;
    end;
  end;
  thus Comput(P,s,11).a1 =len(s.fsloc 0) by A37,A52,SCMFSA_2:100;
  Comput(P,s,1).a2 =s.a0 by A2,A4,SCMFSA_2:89;
  then
A61: Comput(P,s,2).a2 =s.a0 by A6,SCMFSA_2:95;
  a2<>a3 by SCMFSA_2:128;
  then Comput(P,s,3).a2 =s.a0 by A61,A8,SCMFSA_2:89;
  then
A62: Comput(P,s,4).a2 =s.a0 by A10,SCMFSA_2:95;
  a2<>a4 by SCMFSA_2:128;
  then Comput(P,s,5).a2 =s.a0 by A62,A16,SCMFSA_2:89;
  then
A63: Comput(P,s,6).a2 =s.a0 by A18,SCMFSA_2:95;
  a2<>a5 by SCMFSA_2:128;
  then Comput(P,s,7).a2 =s.a0 by A63,A20,SCMFSA_2:89;
  then
A64: Comput(P,s,8).a2 =s.a0 by A22,SCMFSA_2:95;
  a2<>a6 by SCMFSA_2:128;
  then Comput(P,s,9).a2 =s.a0 by A64,A24,SCMFSA_2:89;
  then
A65: Comput(P,s,10).a2 =s.a0 by A26,SCMFSA_2:95;
  a3<>a4 by SCMFSA_2:128;
  then Comput(P,s,5).a3 =s.a0 by A15,A16,SCMFSA_2:89;
  then
A66: Comput(P,s,6).a3 =s.a0 by A18,SCMFSA_2:95;
  a3<>a5 by SCMFSA_2:128;
  then Comput(P,s,7).a3 =s.a0 by A66,A20,SCMFSA_2:89;
  then
A67: Comput(P,s,8).a3 =s.a0 by A22,SCMFSA_2:95;
  a3<>a6 by SCMFSA_2:128;
  then Comput(P,s,9).a3 =s.a0 by A67,A24,SCMFSA_2:89;
  then
A68: Comput(P,s,10).a3 =s.a0 by A26,SCMFSA_2:95;
  a2<>a1 by SCMFSA_2:128;
  hence Comput(P,s,11).a2 =s.a0 by A65,A52,SCMFSA_2:100;
  a3<>a1 by SCMFSA_2:128;
  hence Comput(P,s,11).a3 =s.a0 by A68,A52,SCMFSA_2:100;
  a4<>a1 by SCMFSA_2:128;
  hence Comput(P,s,11).a4 =s.a0 by A46,A52,SCMFSA_2:100;
  a5<>a1 by SCMFSA_2:128;
  hence Comput(P,s,11).a5 =s.a0 by A47,A52,SCMFSA_2:100;
  a6<>a1 by SCMFSA_2:128;
  hence thesis by A51,A52,SCMFSA_2:100;
end;

Lm3: for s be State of SCM+FSA
 holds (s.b5>0 implies IExec(IF,P,s).b2 =0) & (s.
b5<=0 implies IExec(IF,P,s).b2 =s.b2-1)

proof
  let s be State of SCM+FSA;
  set s0=Initialized s, s1=Exec(m2, s0);
  hereby
    assume s.b5 > 0;
    hence IExec(IF,P,s).b2 = IExec(m1,P,s).b2 by SCM_HALT:54
      .=Exec(m0,Initialized s).b2 by SCMFSA6C:6
      .=s0.b2-s0.b2 by SCMFSA_2:91
      .=0;
  end;
  b2<>b4 by SCMFSA_2:128;
  then
A1: s1.b2=s0.b2 by SCMFSA_2:90
    .=s.b2 by SCMFSA6C:3;
A2: s1.a0=s0.a0 by SCMFSA_2:90
    .=1 by SCMFSA6C:3;
  hereby
    assume s.b5 <= 0;
    hence IExec(IF,P,s).b2 = IExec(m2 ';' m3,P,s).b2 by SCM_HALT:54
      .=Exec(m3,s1).b2 by SCMFSA6C:9
      .=s.b2-1 by A1,A2,SCMFSA_2:91;
  end;
end;

Lm4: for s be State of SCM+FSA,P
 holds IExec(body2,P,s).b2<s.b2 or IExec(body2,P,s).b2<=0
proof
  let s be State of SCM+FSA,P;
  set s0=Initialized s, s1=Exec(n1,s0), s2=IExec(n1 ';'n2,P,s);
A1: b5<>b2 by SCMFSA_2:128;
A2: s2.b2=Exec(n2,s1).b2 by SCMFSA6C:9
    .=s1.b2 by A1,SCMFSA_2:91
    .=s0.b2 by A1,SCMFSA_2:98
    .=s.b2 by SCMFSA6C:3;
  per cases;
  suppose
A3: s2.b5>0;
    IExec(body2,P,s).b2=IExec(IF,P,s2).b2 by SCM_HALT:30
      .=0 by A3,Lm3;
    hence thesis;
  end;
  suppose
A4: s2.b5<=0;
    IExec(body2,P,s).b2=IExec(IF,P,s2).b2 by SCM_HALT:30
      .=s.b2-1 by A2,A4,Lm3;
    hence thesis by XREAL_1:148;
  end;
end;
then
Lm5: while>0(b2,body2) is good InitHalting Program of SCM+FSA by Th30;

Lm6: body3 does not destroy b4
proof
A1: b4 <> b6 by SCMFSA_2:128;
A2: i3 does not destroy b4 by SCMFSA7B:20,SCMFSA_2:128;
A3: i2 does not destroy b4 by SCMFSA7B:14,SCMFSA_2:128;
  i1 does not destroy b4 by SCMFSA7B:12,SCMFSA_2:128;
  then i1 ';' i2 ';' i3 does not destroy b4 by A3,A2,SCMFSA8C:83,84;

  then i1 ';' i2 ';' i3 ';' i4 does not destroy b4 by A1,SCMFSA7B:20
,SCMFSA8C:83;

  then i1 ';' i2 ';' i3 ';' i4 ';' i5 does not destroy b4 by SCMFSA7B:21
,SCMFSA8C:83;

  hence thesis by SCMFSA7B:21,SCMFSA8C:83;
end;

Lm7: body3 does not destroy b1
proof
A1: b1 <> b6 by SCMFSA_2:128;
A2: i3 does not destroy b1 by SCMFSA7B:20,SCMFSA_2:128;
A3: i2 does not destroy b1 by SCMFSA7B:14,SCMFSA_2:128;
  i1 does not destroy b1 by SCMFSA7B:12,SCMFSA_2:128;
  then i1 ';' i2 ';' i3 does not destroy b1 by A3,A2,SCMFSA8C:83,84;

  then i1 ';' i2 ';' i3 ';' i4 does not destroy b1 by A1,SCMFSA7B:20
,SCMFSA8C:83;

  then i1 ';' i2 ';' i3 ';' i4 ';' i5 does not destroy b1 by SCMFSA7B:21
,SCMFSA8C:83;

  hence thesis by SCMFSA7B:21,SCMFSA8C:83;
end;

Lm8: body2 does not destroy b1
proof
  b1 <> b2 by SCMFSA_2:128;
  then
A1: m1 does not destroy b1 by SCMFSA7B:14,SCMFSA8C:77;
A2: m3 does not destroy b1 by SCMFSA7B:14,SCMFSA_2:128;
  m2 does not destroy b1 by SCMFSA7B:13,SCMFSA_2:128;
  then m2 ';' m3 does not destroy b1 by A2,SCMFSA8C:84;
  then
A3: IF does not destroy b1 by A1,SCMFSA8C:121;
A4: n2 does not destroy b1 by SCMFSA7B:14,SCMFSA_2:128;
  n1 does not destroy b1 by SCMFSA7B:20,SCMFSA_2:128;
  then n1 ';' n2 does not destroy b1 by A4,SCMFSA8C:84;
  hence thesis by A3,SCMFSA8C:81;
end;

Lm9: body1 does not destroy b1
proof
A1: t3 does not destroy b1 by SCMFSA7B:12,SCMFSA_2:128;
A2: b1 <> b3 by SCMFSA_2:128;
A3: t2 does not destroy b1 by SCMFSA7B:14,SCMFSA_2:128;
  t1 does not destroy b1 by SCMFSA7B:22,SCMFSA_2:128;
  then t1 ';' t2 ';' t3 does not destroy b1 by A3,A1,SCMFSA8C:83,84;

  then
A4: t1 ';' t2 ';' t3 ';' t4 does not destroy b1 by A2,SCMFSA7B:13,SCMFSA8C:83;

A5: b1 <> b4 by SCMFSA_2:128;
  b1 <> b6 by SCMFSA_2:128;

  then t1 ';' t2 ';' t3 ';' t4 ';' t5 does not destroy b1 by A4,SCMFSA7B:20
,SCMFSA8C:83;

  then
A6: t16 does not destroy b1 by A5,SCMFSA7B:14,SCMFSA8C:83;
  Wg does not destroy b1 by Lm8,Th7;
  then
A7: t16 ';' Wg does not destroy b1 by A6,SCMFSA8C:81;
  T3 does not destroy b1 by Lm7,SCMBSORT:3,SCMFSA_2:128;
  hence thesis by A7,SCMFSA8C:81;
end;

Lm10: Times(b4,body3) is good InitHalting Program of SCM+FSA
proof
  Initialized Times(b4,body3) is halting by Lm6,SCM_HALT:76;
  hence thesis by SCM_HALT:def 2;
end;

Lm11: body1 is good InitHalting Program of SCM+FSA
proof
  reconsider TT=T3 as good InitHalting Program of SCM+FSA by Lm10;
  reconsider WT=Wg as good InitHalting Program of SCM+FSA by Lm4,Th30;

  reconsider t14=t1 ';' t2 ';' t3 ';' t4 as good InitHalting Program of
  SCM+FSA;

  reconsider t16=t14 ';' t5 ';' t6 as good InitHalting Program of SCM+FSA;
  t16 ';' WT ';' TT is good InitHalting;
  hence thesis;
end;

Lm12: Times(b1,body1) is good InitHalting Program of SCM+FSA
proof
  Initialized Times(b1,body1) is halting by Lm9,Lm11,SCM_HALT:76;
  hence thesis by SCM_HALT:def 2;
end;

theorem
  insert-sort (fsloc 0) is keepInt0_1 InitHalting by Lm12;

Lm13: for s be State of SCM+FSA holds IExec(IF,P,s).f0=s.f0
proof
  let s be State of SCM+FSA;
  set s0=Initialized s;
  per cases;
  suppose
    s.b5 >0;
    hence IExec(IF,P,s).f0 = IExec(m1,P,s).f0 by SCM_HALT:54
      .=Exec(m0,s0).f0 by SCMFSA6C:6
      .=s0.f0 by SCMFSA_2:91
      .=s.f0 by SCMFSA6C:3;
  end;
  suppose
    s.b5 <= 0;
    hence IExec(IF,P,s).f0 = IExec(m2 ';' m3,P,s).f0 by SCM_HALT:54
      .=Exec(m3,Exec(m2, s0)).f0 by SCMFSA6C:10
      .=Exec(m2, s0).f0 by SCMFSA_2:91
      .=s0.f0 by SCMFSA_2:90
      .=s.f0 by SCMFSA6C:3;
  end;
end;

Lm14: for s be State of SCM+FSA holds (s.b5>0 implies IExec(IF,P,s).b4 =s.b4) &
(s.b5<=0 implies IExec(IF,P,s).b4 =s.b4+1)

proof
  let s be State of SCM+FSA;
  set s0=Initialized s;
A1: b2<>b4 by SCMFSA_2:128;
  hereby
    assume s.b5 > 0;
    hence IExec(IF,P,s).b4 = IExec(m1,P,s).b4 by SCM_HALT:54
      .=Exec(m0,s0).b4 by SCMFSA6C:6
      .=s0.b4 by A1,SCMFSA_2:91
      .=s.b4 by SCMFSA6C:3;
  end;
  hereby
    assume s.b5 <= 0;
    hence IExec(IF,P,s).b4 = IExec(m2 ';' m3,P,s).b4 by SCM_HALT:54
      .=Exec(m3,Exec(m2, s0)).b4 by SCMFSA6C:9
      .=Exec(m2, s0).b4 by A1,SCMFSA_2:91
      .=s0.b4+s0.a0 by SCMFSA_2:90
      .=s0.b4+1 by SCMFSA6C:3
      .=s.b4+1 by SCMFSA6C:3;
  end;
end;

Lm15: for a be read-write Int-Location,s be State of SCM+FSA st a<>b4 & a<>b2
holds IExec(IF,P,s).a = s.a

proof
  let a be read-write Int-Location,s be State of SCM+FSA;
  assume that
A1: a<>b4 and
A2: a<> b2;
  set s1=Exec(m2,Initialized s), s2=IExec(m2 ';' m3,P,s);
A3: s1.a= (Initialized s).a by A1,SCMFSA_2:90
    .=s.a by SCMFSA6C:3;
A4: s2.a=Exec(m3,s1).a by SCMFSA6C:9
    .=s.a by A2,A3,SCMFSA_2:91;
  per cases;
  suppose
    s.b5 >0;
    hence IExec(IF,P,s).a = IExec(m1,P,s).a by SCM_HALT:54
      .=Exec(m0,Initialized s).a by SCMFSA6C:6
      .=(Initialized s).a by A2,SCMFSA_2:91
      .=s.a by SCMFSA6C:3;
  end;
  suppose
    s.b5 <= 0;
    hence thesis by A4,SCM_HALT:54;
  end;
end;

Lm16: for t be State of SCM+FSA,Q st t.b2 >= 1 & t.b2 <= len(t.f0)
 holds IExec(body2,Q,t).b3=t.b3 &
  IExec(body2,Q,t).b6=t.b6 & IExec(body2,Q,t).f0=t.f0 &
ex x1 be
Integer st x1=t.f0.(t.b2) & ( x1-t.b6>0 implies IExec(body2,Q,t).b2=0 &
IExec(body2,Q,t).b4=t.b4 ) & ( x1-t.b6<=0 implies IExec(body2,Q,t).b2=t.b2-1 &
IExec(body2,Q,t).b4=t.b4+1 )

proof
  let s be State of SCM+FSA,P;
  assume that
A1: s.b2 >= 1 and
A2: s.b2 <= len(s.f0);
A3: abs(s.b2)=s.b2 by A1,ABSVALUE:def 1;
  set s0=Initialized s, s1=Exec(n1,s0), s2=IExec(n1 ';'n2,P,s);
A4: b4<>b3 by SCMFSA_2:128;
  reconsider k1=s.b2 as Element of NAT by A1,INT_1:16;
  reconsider n=s.f0.k1 as Integer;
A5: (s.f0)/.k1=n by A1,A2,FINSEQ_4:24;
A6: s1.b5=(s0.f0)/.(abs(s0.b2)) by SCMBSORT:8
    .=(s0.f0)/.(abs(s.b2)) by SCMFSA6C:3
    .=n by A3,A5,SCMFSA6C:3;
A7: b2<>b3 by SCMFSA_2:128;
A8: b5<>b6 by SCMFSA_2:128;
  then
A9: s1.b6=s0.b6 by SCMFSA_2:98
    .=s.b6 by SCMFSA6C:3;
A10: b5<>b3 by SCMFSA_2:128;
A11: s2.b5=Exec(n2,s1).b5 by SCMFSA6C:9
    .=n-s.b6 by A9,A6,SCMFSA_2:91;
  thus IExec(body2,P,s).b3=IExec(IF,P,s2).b3 by SCM_HALT:30
    .=s2.b3 by A4,A7,Lm15
    .=Exec(n2,s1).b3 by SCMFSA6C:9
    .=s1.b3 by A10,SCMFSA_2:91
    .=s0.b3 by A10,SCMFSA_2:98
    .=s.b3 by SCMFSA6C:3;
A12: b4<>b6 by SCMFSA_2:128;
A13: b2<>b6 by SCMFSA_2:128;
  thus IExec(body2,P,s).b6=IExec(IF,P,s2).b6 by SCM_HALT:30
    .=s2.b6 by A12,A13,Lm15
    .=Exec(n2,s1).b6 by SCMFSA6C:9
    .=s.b6 by A8,A9,SCMFSA_2:91;
A14: b5<>b4 by SCMFSA_2:128;
  thus IExec(body2,P,s).f0=IExec(IF,P,s2).f0 by SCM_HALT:31
    .=s2.f0 by Lm13
    .=Exec(n2,s1).f0 by SCMFSA6C:10
    .=s1.f0 by SCMFSA_2:91
    .=s0.f0 by SCMFSA_2:98
    .=s.f0 by SCMFSA6C:3;
  take n;
A15: b5<>b2 by SCMFSA_2:128;
  thus n=s.f0.(s.b2);
A16: s2.b4=Exec(n2,s1).b4 by SCMFSA6C:9
    .=s1.b4 by A14,SCMFSA_2:91
    .=s0.b4 by A14,SCMFSA_2:98
    .=s.b4 by SCMFSA6C:3;
  hereby
    assume
A17: n-s.b6>0;
    thus IExec(body2,P,s).b2=IExec(IF,P,s2).b2 by SCM_HALT:30
      .=0 by A11,A17,Lm3;
    thus IExec(body2,P,s).b4=IExec(IF,P,s2).b4 by SCM_HALT:30
      .=s.b4 by A16,A11,A17,Lm14;
  end;
A18: s2.b2=Exec(n2,s1).b2 by SCMFSA6C:9
    .=s1.b2 by A15,SCMFSA_2:91
    .=s0.b2 by A15,SCMFSA_2:98
    .=s.b2 by SCMFSA6C:3;
  hereby
    assume
A19: n-s.b6<=0;
    thus IExec(body2,P,s).b2=IExec(IF,P,s2).b2 by SCM_HALT:30
      .=s.b2-1 by A18,A11,A19,Lm3;
    thus IExec(body2,P,s).b4=IExec(IF,P,s2).b4 by SCM_HALT:30
      .=s.b4+1 by A16,A11,A19,Lm14;
  end;
end;

Lm17: for k be Element of NAT,s be State of SCM+FSA st s.b2=k & s.b2<=len(s.f0
) holds s.f0=IExec(Wg,P,s).f0 & s.b3=IExec(Wg,P,s).b3 & (k=0
or ex n be Element of NAT,x1 be Integer
 st n=IExec(Wg,P,s).b4-s.b4 & n<=k & (k-n
>=1 implies x1=s.f0.(k-n) & x1 >= s.b6) & for i be Element of NAT st i>k-n & i<
k+1 holds ex x2 be Integer st x2=s.f0.i & x2 <= s.b6 )

proof

  defpred P[Element of NAT] means for s be State of SCM+FSA st s.b2=$1 & s.b2

<=len(s.f0) holds IExec(Wg,P,s).f0=s.f0 & IExec(Wg,P,s).b3=s.

b3 & ($1=0 or ex n be Element of NAT,x1 be Integer st
 n=IExec(Wg,P,s).b4-s.b4 & n

<=$1 & ($1-n>=1 implies x1=s.f0.($1-n) & x1 >= s.b6) & (for i be Element of NAT
  st i>$1-n & i<$1+1 holds ex x2 be Integer st x2=s.f0.i & x2 <= s.b6));

A1: now
    let k be Element of NAT;
    assume
A2: P[k];
    now
      let s be State of SCM+FSA;
      assume that
A3:   s.b2=k+1 and
A4:   s.b2<=len(s.f0);
      set bs=IExec(body2,P,s), bs0=Initialized bs;
A5:   s.b2 >= 1+0 by A3,INT_1:20;
      then consider m be Integer such that
A6:   m=s.f0.(s.b2) and
A7:   m-s.b6>0 implies bs.b2=0 & bs.b4=s.b4 and
A8:   m-s.b6<=0 implies bs.b2=s.b2-1 & bs.b4=s.b4+1 by A4,Lm16;
      reconsider WT=Wg as good InitHalting Program of SCM+FSA by Lm4,Th30;
      per cases;
      suppose
A9:     m-s.b6>0;
        thus IExec(Wg,P,s).f0=IExec(WT,P,bs).f0 by A3,Th36
          .=bs.f0 by A7,A9,Th34
          .=s.f0 by A4,A5,Lm16;
        thus IExec(Wg,P,s).b3=IExec(WT,P,bs).b3 by A3,Th37
          .=bs0.b3 by A7,A9,Th35
          .=bs.b3 by SCMFSA6C:3
          .=s.b3 by A4,A5,Lm16;
A10:    IExec(Wg,P,s).b4=IExec(WT,P,bs).b4 by A3,Th37
          .=bs0.b4 by A7,A9,Th35
          .=s.b4 by A7,A9,SCMFSA6C:3;
        now
          take n=0;
          take x1=m;
          thus n=IExec(Wg,P,s).b4-s.b4 by A10;
          thus n<=k+1;

          thus k+1-n>=1 implies x1=s.f0.(k+1-n) & x1>=(0 qua Nat)+s.b6
           by A3,A6,A9,XREAL_1:21;

          thus for i be Element of NAT st i>k+1-n & i<k+1+1 ex x2 be Integer
          st x2=s.f0.i & x2 <= s.b6 by INT_1:20;

        end;

        hence
        (k+1)=0 or ex n be Element of NAT,x1 be Integer st n=IExec(Wg,P,s).

b4-s.b4 & n<=k+1 & (k+1-n>=1 implies x1=s.f0.(k+1-n) & x1 >= s.b6) & for i be

Element of NAT st i>k+1-n & i<k+1+1 ex x2 be Integer st x2=s.f0.i & x2 <= s.b6;

      end;
      suppose
A11:    m-s.b6<=0;
        bs.b2<k+1 by A3,A7,A8,XREAL_1:31;
        then
A12:    bs.b2<=len(s.f0) by A3,A4,XXREAL_0:2;
A13:    bs.f0=s.f0 by A4,A5,Lm16;
        thus IExec(Wg,P,s).f0=IExec(WT,P,bs).f0 by A3,Th36
          .=s.f0 by A2,A3,A8,A11,A13,A12;
        thus IExec(Wg,P,s).b3=IExec(WT,P,bs).b3 by A3,Th37
          .=bs.b3 by A2,A3,A8,A11,A13,A12
          .=s.b3 by A4,A5,Lm16;
        hereby
          per cases;
          suppose
            k<>0;
            then consider n be Element of NAT,x1 be Integer such that
A14:        n=IExec(Wg,P,bs).b4-bs.b4 and
A15:        n<=k and
A16:        k-n>=1 implies x1=bs.f0.(k-n) & x1 >= bs.b6 and

A17:        for i be Element of NAT st i>k-n & i<k+1 ex x2 be Integer
            st x2=bs .f0.i & x2 <= bs.b6 by A2,A3,A8,A11,A13,A12;

A18:        IExec(WT,P,s).b4=s.b4+(1+n) by A3,A8,A11,A14,Th37;
            now
              take n1=1+n;
              take y1=x1;
              thus n1=IExec(Wg,P,s).b4-s.b4 by A18;
              thus n1<=k+1 by A15,XREAL_1:8;

              thus k+1-n1>=1 implies y1=s.f0.(k+1-n1) & y1 >=s.b6 by A4,A5,A16
,Lm16;

              now
                let i be Element of NAT;
                assume that
A19:            i>k+1-n1 and
A20:            i<k+1+1;
                per cases;
                suppose
A21:              i=k+1;
                  take x2=m;
                  thus x2=s.f0.i by A3,A6,A21;
                  x2<=(0 qua Nat)+s.b6 by A11,XREAL_1:22;
                  hence x2<=s.b6;
                end;
                suppose
A22:              i<>k+1;
                  i<=k+1 by A20,INT_1:20;
                  then i<k+1 by A22,XXREAL_0:1;
                  then consider y2 be Integer such that
A23:              y2=bs.f0.i and
A24:              y2 <= bs.b6 by A17,A19;
                  take x2=y2;
                  thus x2=s.f0.i by A4,A5,A23,Lm16;
                  thus x2<=s.b6 by A4,A5,A24,Lm16;
                end;
              end;

              hence for i be Element of NAT st i>k+1-n1 & i<k+1+1 holds ex x2
              be Integer st x2=s.f0.i & x2 <= s.b6;

            end;

            hence
            k+1=0 or ex n be Element of NAT,x1 be Integer st n=IExec(Wg,P,s

).b4-s.b4 & n<=k+1 & (k+1-n>=1 implies x1=s.f0.(k+1-n) & x1 >= s.b6) & for i be

Element of NAT st i>k+1-n & i<k+1+1 ex x2 be Integer st x2=s.f0.i & x2 <= s.b6;

          end;
          suppose
A25:        k=0;
A26:        IExec(WT,P,s).b4=IExec(Wg,P,bs).b4 by A3,Th37
              .=bs0.b4 by A3,A7,A8,A25,Th35
              .=s.b4+1 by A8,A11,SCMFSA6C:3;
            now
              take n1=1;
              take x1=0;
              thus n1=IExec(Wg,P,s).b4-s.b4 by A26;
              thus n1<=k+1 by A25;
              thus k+1-n1>=1 implies x1=s.f0.(k+1-n1) & x1 >= s.b6 by A25;
              hereby
                let i be Element of NAT;
                assume that
A27:            i>k+1-n1 and
A28:            i<k+1+1;
                take x2=m;
A29:            i>=0+1 by A27,INT_1:20;
                i<=1 by A25,A28,INT_1:20;
                hence x2=s.f0.i by A3,A6,A25,A29,XXREAL_0:1;
                x2<=(0 qua Nat)+s.b6 by A11,XREAL_1:22;
                hence x2<=s.b6;
              end;
            end;

            hence
            k+1=0 or ex n be Element of NAT,x1 be Integer st n=IExec(Wg,P,s

).b4-s.b4 & n<=k+1 & (k+1-n>=1 implies x1=s.f0.(k+1-n) & x1 >= s.b6) & for i be

Element of NAT st i>k+1-n & i<k+1+1 ex x2 be Integer st x2=s.f0.i & x2 <= s.b6;

          end;
        end;
      end;
    end;
    hence P[k+1];
  end;
A30: P[ 0]
  proof
    let s be State of SCM+FSA;
    set s0=Initialized s;
    assume that
A31: s.b2=0 and
    s.b2<=len(s.f0);
    thus IExec(Wg,P,s).f0=s.f0 by A31,Th34;
    thus IExec(Wg,P,s).b3=s0.b3 by A31,Th35
      .=s.b3 by SCMFSA6C:3;
    thus thesis;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A30,A1);
  hence thesis;
end;

Lm18: for s be State of SCM+FSA holds IExec(body3,P,s).b3=s.b3-1 &
IExec(body3,P,s).f0
=s.f0+*(abs(s.b3),(s.f0)/.(abs((s.b3-1)))) +*(abs((s.b3-1)),(s.f0)/.(abs(s.
b3)))

proof
  let s be State of SCM+FSA;

  set s0=Initialized s, s1=Exec(i1,s0), s2=IExec(i1 ';' i2,P,s),
      s3=IExec(i1 ';' i2 ';' i3,P,s), s4=IExec(i1 ';' i2 ';' i3 ';' i4,P,s),
      s5=IExec(i1 ';' i2 ';' i3 ';' i4 ';' i5,P,s), s6=IExec(body3,P,s);

A1: b6<>b3 by SCMFSA_2:128;
A2: s1.a0=s0.a0 by SCMFSA_2:89
    .=1 by SCMFSA6C:3;
A3: b6<>b2 by SCMFSA_2:128;
A4: b2<>b3 by SCMFSA_2:128;
A5: b6<>b5 by SCMFSA_2:128;
A6: b5<>b2 by SCMFSA_2:128;
A7: s2.b2=Exec(i2,s1).b2 by SCMFSA6C:9
    .=s1.b2 by A4,SCMFSA_2:91
    .=s0.b3 by SCMFSA_2:89
    .=s.b3 by SCMFSA6C:3;
A8: s4.b2=Exec(i4,s3).b2 by SCMFSA6C:7
    .=s3.b2 by A3,SCMFSA_2:98
    .=Exec(i3,s2).b2 by SCMFSA6C:7
    .=s.b3 by A6,A7,SCMFSA_2:98;
A9: b5<>b3 by SCMFSA_2:128;
A10: s3.b3=Exec(i3,s2).b3 by SCMFSA6C:7
    .=s2.b3 by A9,SCMFSA_2:98
    .=Exec(i2,s1).b3 by SCMFSA6C:9
    .=s1.b3-s1.a0 by SCMFSA_2:91
    .=s0.b3-s1.a0 by A4,SCMFSA_2:89
    .=s.b3-1 by A2,SCMFSA6C:3;
A11: s5.b3=Exec(i5,s4).b3 by SCMFSA6C:7
    .=s4.b3 by SCMFSA_2:99
    .=Exec(i4,s3).b3 by SCMFSA6C:7
    .=s.b3-1 by A1,A10,SCMFSA_2:98;
  thus s6.b3=Exec(i6,s5).b3 by SCMFSA6C:7
    .=s.b3-1 by A11,SCMFSA_2:99;
A12: s2.f0=Exec(i2,s1).f0 by SCMFSA6C:10
    .=s1.f0 by SCMFSA_2:91
    .=s0.f0 by SCMFSA_2:89
    .=s.f0 by SCMFSA6C:3;
A13: s3.f0=Exec(i3,s2).f0 by SCMFSA6C:8
    .=s.f0 by A12,SCMFSA_2:98;
A14: s4.f0=Exec(i4,s3).f0 by SCMFSA6C:8
    .=s.f0 by A13,SCMFSA_2:98;
A15: s4.b6=Exec(i4,s3).b6 by SCMFSA6C:7
    .=(s.f0)/.(abs((s.b3-1))) by A10,A13,SCMBSORT:8;
A16: s5.f0=Exec(i5,s4).f0 by SCMFSA6C:8
    .=s.f0+*(abs(s.b3),(s.f0)/.abs(s.b3-1)) by A14,A8,A15,SCMBSORT:9;
A17: s5.b5=Exec(i5,s4).b5 by SCMFSA6C:7
    .=s4.b5 by SCMFSA_2:99
    .=Exec(i4,s3).b5 by SCMFSA6C:7
    .=s3.b5 by A5,SCMFSA_2:98
    .=Exec(i3,s2).b5 by SCMFSA6C:7
    .=(s.f0)/.(abs(s.b3)) by A12,A7,SCMBSORT:8;
  thus s6.f0=Exec(i6,s5).f0 by SCMFSA6C:8

    .=s.f0+*(abs(s.b3),(s.f0)/.abs(s.b3-1)) +*(abs((s.b3-1)),(s.f0)/.abs(s.
  b3)) by A11,A17,A16,SCMBSORT:9;

end;

Lm19: for k be Element of NAT,s be State of SCM+FSA,P
 st s.b4=k & k<s.b3 & s.b3
<=len(s.f0) holds s.f0, IExec(T3,P,s).f0 are_fiberwise_equipotent &
IExec(T3,P,s).
b3=s.b3-k &
IExec(T3,P,s).f0.(s.b3-k)=s.f0.(s.b3) & (for i be Element of NAT st s
.b3-k<i & i<=s.b3 holds IExec(T3,P,s).f0.i=s.f0.(i-1)) &
 (for i be Element of NAT
st s.b3<i & i<=len(s.f0) holds IExec(T3,P,s).f0.i=s.f0.i) &
 for i be Element of
NAT st 1<=i & i<s.b3-k holds IExec(T3,P,s).f0.i=s.f0.i

proof

  defpred P[Element of NAT] means
   for s be State of SCM+FSA,P st s.b4=$1 & $1<s.
  b3 & s.b3<=len(s.f0)
   holds (s.f0, IExec(T3,P,s).f0 are_fiberwise_equipotent) &
  IExec(T3,P,s).b3=s.b3-$1 & IExec(T3,P,s).f0.(s.b3-$1)=s.f0.(s.b3) &
   (for i be

Element of NAT st s.b3-$1<i & i<=s.b3 holds IExec(T3,P,s).f0.i=s.f0.(i-1)) &
 (for

i be Element of NAT st s.b3<i & i<=len(s.f0)
 holds IExec(T3,P,s).f0.i=s.f0.i) & (
  for i be Element of NAT st 1<=i & i<s.b3-$1 holds IExec(T3,P,s).f0.i=s.f0.i);

A1: now
    set s4=SubFrom(b4,a0);
    let k be Element of NAT;
    assume
A2: P[k];
    now
A3:   b4<>b3 by SCMFSA_2:128;
      let s be State of SCM+FSA,P;
      assume that
A4:   s.b4=k+1 and
A5:   k+1<s.b3 and
A6:   s.b3<=len(s.f0);
A7:   k+1-1<s.b3-1 by A5,XREAL_1:11;
      then reconsider n=s.b3-1 as Element of NAT by INT_1:16;
A8:   n<=len(s.f0) by A6,XREAL_1:148,XXREAL_0:2;
      set b3s=IExec(body3 ';'s4,P,s), bds=IExec(body3,P,s);
      set ff=s.f0, gg=bds.f0;
A9:   b3s.b4=Exec(s4,bds).b4 by SCMFSA6C:7
        .=bds.b4-bds.a0 by SCMFSA_2:91
        .=bds.b4-1 by SCMFSA6B:35
        .=(Initialized s).b4-1 by Lm6,SCMFSA8C:91
        .=k+1-1 by A4,SCMFSA6C:3
        .=k;
      reconsider m=s.b3 as Element of NAT by A5,INT_1:16;
A10:  0+1<=k+1 by XREAL_1:8;
      then
A11:  1<=m by A5,XXREAL_0:2;
A12:  abs(s.b3)=m by ABSVALUE:def 1;
      k+1+1<=m by A5,INT_1:20;
      then k+1+1-1<=n by XREAL_1:11;
      then
A13:  1<=n by A10,XXREAL_0:2;
A14:  IExec(T3,P,s).f0=IExec(T3,P,b3s).f0 by A4,Lm6,SCM_HALT:82;
A15:  b3s.b3=Exec(s4,bds).b3 by SCMFSA6C:7
        .=bds.b3 by A3,SCMFSA_2:91
        .=s.b3-1 by Lm18;
      then
A16:  b3s.b3-k=s.b3-(k+1);
      abs(s.b3-1)=n by ABSVALUE:def 1;
      then
A17:  bds.f0=s.f0+*(m,(s.f0)/.n) +*(n,(s.f0)/.m) by A12,Lm18;
      then
A18:  ff.m=gg.n by A6,A11,A13,A8,FUNCT_7:115;
A19:  b3s.f0=Exec(s4,bds).f0 by SCMFSA6C:8
        .=bds.f0 by SCMFSA_2:91;

      then
A20:  ff,b3s.f0 are_fiberwise_equipotent by A6,A11,A13,A8,A17,FUNCT_7:115;

      then
A21:  n<=len(b3s.f0) by A8,RFINSEQ:16;

      then b3s.f0,IExec(T3,P,b3s).f0 are_fiberwise_equipotent by A2,A9,A15,A7;

      hence ff,IExec(T3,P,s).f0 are_fiberwise_equipotent
       by A20,A14,CLASSES1:84;

      ff,gg are_fiberwise_equipotent by A6,A11,A13,A8,A17,FUNCT_7:115;
      then
A22:  len ff=len (b3s.f0) by A19,RFINSEQ:16;
      IExec(T3,P,b3s).b3=b3s.b3-k by A2,A9,A15,A7,A21;
      hence IExec(T3,P,s).b3=s.b3-(k+1) by A4,A15,Lm6,SCM_HALT:83;
      IExec(T3,P,b3s).f0.(b3s.b3-k) =b3s.f0.(b3s.b3) by A2,A9,A15,A7,A21;

      hence IExec(T3,P,s).f0.(s.b3-(k+1))=s.f0.(s.b3) by A4,A15,A19,A18,Lm6,
SCM_HALT:82;

A23:  ff.n=gg.m by A6,A11,A13,A8,A17,FUNCT_7:115;
      hereby
        let i be Element of NAT;
        assume that
A24:    s.b3-(k+1)<i and
A25:    i<=s.b3;
        per cases;
        suppose
A26:      i=s.b3;
          then
A27:      b3s.b3<i by A15,XREAL_1:148;
          thus IExec(T3,P,s).f0.i=IExec(T3,P,b3s).f0.i by A4,Lm6,SCM_HALT:82
            .=s.f0.(i-1) by A2,A6,A9,A15,A7,A19,A8,A23,A22,A26,A27;
        end;
        suppose
          i<>s.b3;
          then i<s.b3 by A25,XXREAL_0:1;
          then
A28:      i+1<=s.b3 by INT_1:20;
          then
A29:      i<=s.b3-1 by XREAL_1:21;
A30:      i<=b3s.b3 by A15,A28,XREAL_1:21;
          s.b3-(k+1)+1<=i by A24,INT_1:20;
          then
A31:      s.b3-(k+1)+1-1<=i-1 by XREAL_1:11;
A32:      k+1-(k+1)<s.b3-(k+1) by A5,XREAL_1:11;
          then reconsider i1=i-1 as Element of NAT by A31,INT_1:16;
          i-1<s.b3 by A25,XREAL_1:148,XXREAL_0:2;
          then
A33:      i1<=len (s.f0) by A6,XXREAL_0:2;
          1+0<=s.b3-(k+1) by A32,INT_1:20;
          then 1<=i-1 by A31,XXREAL_0:2;
          then
A34:      i1 in dom ff by A33,FINSEQ_3:27;
A35:      i-1<i by XREAL_1:148;
          thus IExec(T3,P,s).f0.i=IExec(T3,P,b3s).f0.i by A4,Lm6,SCM_HALT:82
            .=bds.f0.(i-1) by A2,A9,A7,A19,A8,A22,A16,A24,A30
            .=s.f0.(i-1) by A6,A11,A13,A8,A17,A25,A29,A35,A34,FUNCT_7:115;
        end;
      end;
      hereby
A36:    1<=k+1 by NAT_1:11;
        let i be Element of NAT;
        assume that
A37:    s.b3<i and
A38:    i<=len(s.f0);
A39:    n<>i by A37,XREAL_1:148;
        k+1<i by A5,A37,XXREAL_0:2;
        then 1<=i by A36,XXREAL_0:2;
        then
A40:    i in dom ff by A38,FINSEQ_3:27;
A41:    b3s.b3<i by A15,A37,XREAL_1:148,XXREAL_0:2;
        thus IExec(T3,P,s).f0.i=IExec(T3,P,b3s).f0.i by A4,Lm6,SCM_HALT:82
          .=bds.f0.i by A2,A9,A15,A7,A19,A8,A22,A38,A41
          .=s.f0.i by A6,A11,A13,A8,A17,A37,A39,A40,FUNCT_7:115;
      end;
      hereby
        let i be Element of NAT;
        assume that
A42:    1<=i and
A43:    i<s.b3-(k+1);
A44:    s.b3-1-k<=s.b3-1-0 by XREAL_1:15;
        then
A45:    i<>m by A43,XREAL_1:148,XXREAL_0:2;
        i<s.b3-1 by A43,A44,XXREAL_0:2;
        then i<s.b3 by XREAL_1:148,XXREAL_0:2;
        then i<=len (s.f0) by A6,XXREAL_0:2;
        then
A46:    i in dom ff by A42,FINSEQ_3:27;
A47:    i<b3s.b3-k by A15,A43;
        thus IExec(T3,P,s).f0.i=IExec(T3,P,b3s).f0.i by A4,Lm6,SCM_HALT:82
          .=bds.f0.i by A2,A9,A15,A7,A19,A8,A22,A42,A47
          .=s.f0.i by A6,A11,A13,A8,A17,A43,A44,A45,A46,FUNCT_7:115;
      end;
    end;
    hence P[k+1];
  end;
A48: P[ 0]
  proof
    let s be State of SCM+FSA,P;
    assume that
A49: s.b4=0 and
    0<s.b3 and
    s.b3<=len(s.f0);
    thus s.f0, IExec(T3,P,s).f0 are_fiberwise_equipotent by A49,SCM_HALT:80;
    thus IExec(T3,P,s).b3=(Initialized s).b3 by A49,SCM_HALT:81
      .=s.b3-0 by SCMFSA6C:3;
    thus IExec(T3,P,s).f0.(s.b3-0)=s.f0.(s.b3) by A49,SCM_HALT:80;

    thus for i be Element of NAT st s.b3-0<i & i<=s.b3
     holds IExec(T3,P,s).f0.i=
    s.f0.(i-1);

    thus for i be Element of NAT st s.b3<i & i<=len(s.f0)
     holds IExec(T3,P,s).f0
    .i=s.f0.i by A49,SCM_HALT:80;

    thus thesis by A49,SCM_HALT:80;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A48,A1);
  hence thesis;
end;

Lm20: for s be State of SCM+FSA,P
 holds IExec(t16,P,s).b2=len(s.f0) - s.b1 &
 IExec(t16,P,s).b3=len(s.f0) - s.b1+1 &
 IExec(t16,P,s).f0=s.f0 & IExec(t16,P,s).b4=0 &
IExec(t16,P,s).b6=(s.f0)/.(abs((len(s.f0)-s.b1+1)))

proof
  let s be State of SCM+FSA,P;

  set s0=Initialized s, s1=Exec(t1,s0), s2=IExec(t1 ';' t2,P,s),
      s3=IExec(t1 ';' t2 ';' t3,P,s), s4=IExec(t1 ';' t2 ';' t3 ';' t4,P,s),
      s5=IExec(t1 ';' t2 ';' t3 ';' t4 ';' t5,P,s), s6=IExec(t16,P,s);

A1: b4<>b3 by SCMFSA_2:128;
A2: b4<>b2 by SCMFSA_2:128;
A3: b6<>b2 by SCMFSA_2:128;
A4: b6<>b3 by SCMFSA_2:128;
A5: b2<>b1 by SCMFSA_2:128;
A6: b2<>b3 by SCMFSA_2:128;
A7: s2.b2=Exec(t2,s1).b2 by SCMFSA6C:9
    .=s1.b2-s1.b1 by SCMFSA_2:91
    .=len(s0.f0)-s1.b1 by SCMFSA_2:100
    .=len(s0.f0)-s0.b1 by A5,SCMFSA_2:100
    .=len(s.f0)-s0.b1 by SCMFSA6C:3
    .=len(s.f0)-s.b1 by SCMFSA6C:3;
  thus s6.b2=Exec(t6,s5).b2 by SCMFSA6C:7
    .=s5.b2 by A2,SCMFSA_2:91
    .=Exec(t5,s4).b2 by SCMFSA6C:7
    .=s4.b2 by A3,SCMFSA_2:98
    .=Exec(t4,s3).b2 by SCMFSA6C:7
    .=s3.b2 by A6,SCMFSA_2:90
    .=Exec(t3,s2).b2 by SCMFSA6C:7
    .=len(s.f0)-s.b1 by A6,A7,SCMFSA_2:89;
A8: s3.a0=1 by SCMFSA6B:35;
A9: s4.b3=Exec(t4,s3).b3 by SCMFSA6C:7
    .=s3.b3+1 by A8,SCMFSA_2:90
    .=Exec(t3,s2).b3+1 by SCMFSA6C:7
    .=len(s.f0)-s.b1+1 by A7,SCMFSA_2:89;
  thus s6.b3=Exec(t6,s5).b3 by SCMFSA6C:7
    .=s5.b3 by A1,SCMFSA_2:91
    .=Exec(t5,s4).b3 by SCMFSA6C:7
    .=len(s.f0)-s.b1+1 by A4,A9,SCMFSA_2:98;
A10: b6<>b4 by SCMFSA_2:128;
A11: s4.f0=Exec(t4,s3).f0 by SCMFSA6C:8
    .=s3.f0 by SCMFSA_2:90
    .=Exec(t3,s2).f0 by SCMFSA6C:8
    .=s2.f0 by SCMFSA_2:89
    .=Exec(t2,s1).f0 by SCMFSA6C:10
    .=s1.f0 by SCMFSA_2:91
    .=s0.f0 by SCMFSA_2:100
    .=s.f0 by SCMFSA6C:3;
  thus s6.f0=Exec(t6,s5).f0 by SCMFSA6C:8
    .=s5.f0 by SCMFSA_2:91
    .=Exec(t5,s4).f0 by SCMFSA6C:8
    .=s.f0 by A11,SCMFSA_2:98;
  thus s6.b4=Exec(t6,s5).b4 by SCMFSA6C:7
    .=s5.b4-s5.b4 by SCMFSA_2:91
    .=0;
  thus s6.b6=Exec(t6,s5).b6 by SCMFSA6C:7
    .=s5.b6 by A10,SCMFSA_2:91
    .=Exec(t5,s4).b6 by SCMFSA6C:7
    .=(s.f0)/.(abs((len(s.f0)-s.b1+1))) by A9,A11,SCMBSORT:8;
end;
set T1=Times(b1,body1);

Lm21: for s be State of SCM+FSA,P st s.b1=len (s.f0) -1
 holds s.f0, IExec(T1,P,s).
f0 are_fiberwise_equipotent & for i,j be Element of NAT st i>=1 & j<=len (s.f0)
& i<j
 for x1,x2 be Integer st x1 =IExec(T1,P,s).f0.i & x2=IExec(T1,P,s).f0.j
 holds
x1 >= x2

proof

  reconsider t14=t1 ';' t2 ';' t3 ';' t4 as good InitHalting Program of
  SCM+FSA;

  reconsider t16=t14 ';' t5 ';' t6 as good InitHalting Program of SCM+FSA;
  reconsider Wt=Wg as good InitHalting Program of SCM+FSA by Lm4,Th30;
  let s be State of SCM+FSA,P;
  assume
A1: s.b1=len (s.f0)-1;
A2: t16 ';' Wt is good InitHalting Program of SCM+FSA;
  per cases;
  suppose
A3: len (s.f0)<=1;

    hence s.f0, IExec(T1,P,s).f0 are_fiberwise_equipotent
     by A1,Lm11,SCM_HALT:80
,XREAL_1:49;

    now
      let i,j be Element of NAT;
      assume that
A4:   i>=1 and
A5:   j<=len (s.f0) and
A6:   i<j;
      j<=1 by A3,A5,XXREAL_0:2;
      hence contradiction by A4,A6,XXREAL_0:2;
    end;
    hence thesis;
  end;
  suppose
    len (s.f0)>1;
    then 1-1<len(s.f0)-1 by XREAL_1:11;
    then reconsider m=len(s.f0)-1 as Element of NAT by INT_1:16;

    defpred P[Element of NAT] means
     for t be State of SCM+FSA,Q st t.b1=$1 & t.

b1<=len(t.f0)-1 holds ((for i,j be Element of NAT st i>=1 & j<=len(t.f0)-t.b1 &

i<j for x1,x2 be Integer st x1 =t.f0.i & x2=t.f0.j holds x1 >= x2) implies (t.

f0, IExec(T1,Q,t).f0 are_fiberwise_equipotent) &
 (for i,j be Element of NAT st i
    >=1 & j<=len(t.f0) & i<j for x1,x2 be Integer
     st x1 =IExec(T1,Q,t).f0.i & x2=
    IExec(T1,Q,t).f0.j holds x1 >= x2));

A7: now
      let k be Element of NAT;
      assume
A8:   P[k];
      now
        let t be State of SCM+FSA,Q;
        assume that
A9:     t.b1=k+1 and
A10:    t.b1<=len(t.f0)-1;
        len(t.f0)<len(t.f0)+t.b1 by A9,XREAL_1:31;
        then
A11:    len(t.f0)-t.b1<len(t.f0)+t.b1-t.b1 by XREAL_1:11;
        then
A12:    len(t.f0)-t.b1+1<=len(t.f0) by INT_1:20;
        -(len (t.f0)-1) <= -t.b1 by A10,XREAL_1:26;
        then
A13:    len(t.f0)+ -(len (t.f0)-1)<=len(t.f0)+-t.b1 by XREAL_1:8;
        then reconsider k1=len(t.f0)-t.b1 as Element of NAT by INT_1:16;
        set IW=IExec(t16 ';' Wg,Q,t), ts=IExec(t16,Q,t);
        set B1=SubFrom(b1,a0), IB=IExec(body1 ';' B1,Q,t);
A14:    ts.f0=t.f0 by Lm20;
A15:    ts.b2=len(t.f0)-t.b1 by Lm20;
        then ts.b2<=len(ts.f0) by A11,Lm20;
        then consider n be Element of NAT,x1 be Integer such that
A16:    n=IExec(Wg,Q,ts).b4-ts.b4 and
A17:    n<=k1 and
A18:    k1-n>=1 implies x1=ts.f0.(k1-n) & x1 >= ts.b6 and

A19:    for i be Element of NAT st i>k1-n & i<k1+1 holds ex x2 be
        Integer st x2=ts.f0.i & x2 <= ts.b6 by A15,A13,Lm17;

A20:    k1<k1+1 by XREAL_1:31;
        then
A21:    n<k1+1 by A17,XXREAL_0:2;
        then
A22:    n-n<k1+1-n by XREAL_1:11;
        reconsider n3=t.f0.(k1+1) as Integer;
A23:    1+0<=k1+1 by INT_1:20;
A24:    IB.f0=Exec(B1,IExec(body1,Q,t)).f0 by Lm11,SCM_HALT:34
          .=IExec(body1,Q,t).f0 by SCMFSA_2:91
          .=IExec(T3,Q,IW).f0 by A2,Lm10,SCM_HALT:31;
        set mm=k1+1-n;
        abs((k1+1))=k1+1 by ABSVALUE:def 1;
        then
A25:    ts.b6=(t.f0)/.(k1+1) by Lm20
          .=n3 by A12,A23,FINSEQ_4:24;
        then
A26:    k1-n>=1 implies x1=t.f0.(k1-n) & x1 >= n3 by A18,Lm20;
A27:    ts.b2=k1 by Lm20;
A28:    IW.f0=IExec(Wg,Q,ts).f0 by Lm5,SCM_HALT:31
          .=t.f0 by A14,A11,A27,Lm17;
A29:    IW.b3=IExec(Wg,Q,ts).b3 by Lm5,SCM_HALT:30
          .=ts.b3 by A14,A11,A27,Lm17
          .=k1+1 by Lm20;
        then
A30:    IW.b3<=len(IW.f0) by A11,A28,INT_1:20;
A31:    IW.b4=n+ts.b4 by A16,Lm5,SCM_HALT:30
          .=n+0 by Lm20
          .=n;

        then
A32:    IW.f0,IExec(T3,Q,IW).f0 are_fiberwise_equipotent
           by A28,A29,A21,A12,Lm19;

A33:    n<IW.b3 by A17,A29,A20,XXREAL_0:2;

        then IW.f0, IB.f0 are_fiberwise_equipotent by A28,A24,A31,A29,A12,Lm19;

        then
A34:    len(IB.f0)=len(t.f0) by A28,RFINSEQ:16;
A35:    IB.b1=k+1-1 by A9,Lm9,Lm11,SCM_HALT:79
          .=k;
        then IB.b1<t.b1 by A9,XREAL_1:31;
        then
A36:    IB.b1<=len(IB.f0)-1 by A10,A34,XXREAL_0:2;
A37:    IExec(T3,Q,IW).f0.mm=IW.f0.(k1+1) by A28,A31,A29,A21,A12,Lm19;
        hereby
A38:      IExec(T1,Q,t).f0=IExec(T1,Q,IB).f0 by A9,Lm9,Lm11,SCM_HALT:82;
          assume

A39:      for i,j be Element of NAT st i>=1 & j<=len(t.f0)-t.b1 & i<j
          for x1,x2 be Integer st x1 =t.f0.i & x2=t.f0.j holds x1 >= x2;

A40:      now
A41:        k1+1-n<=k1+1-0 by XREAL_1:15;
            then k1-n+1<=k1+1;
            then
A42:        k1-n<=k1 by XREAL_1:8;
            let i,j be Element of NAT;
            assume that
A43:        i>=1 and
A44:        j<=len(IB.f0)-IB.b1 and
A45:        i<j;
A46:        1<=j by A43,A45,XXREAL_0:2;
            len(IB.f0)-IB.b1=k1+1 by A9,A35,A34;
            then
A47:        j-1<=k1 by A44,XREAL_1:22;
A48:        1-1<=i-1 by A43,XREAL_1:11;
            then reconsider i1=i-1 as Element of NAT by INT_1:16;
A49:        i-1<j-1 by A45,XREAL_1:11;
            then reconsider j1=j-1 as Element of NAT by A48,INT_1:16;
            let y1,y2 be Integer;
            assume that
A50:        y1 =IB.f0.i and
A51:        y2=IB.f0.j;
            per cases by XXREAL_0:1;
            suppose
A52:          i<mm;
              then
A53:          y1=t.f0.i by A28,A24,A31,A29,A21,A30,A43,A50,Lm19;
              hereby
                per cases by XXREAL_0:1;
                suppose
A54:              j<mm;
                  then j<k1+1 by A41,XXREAL_0:2;
                  then
A55:              j<=k1 by INT_1:20;
                  y2=t.f0.j by A28,A24,A31,A29,A21,A30,A51,A46,A54,Lm19;
                  hence y1 >= y2 by A39,A43,A45,A53,A55;
                end;
                suppose
A56:              j>mm;
                  then mm+1<=j by INT_1:20;
                  then mm<=j1 by XREAL_1:21;
                  then
A57:              i<j1 by A52,XXREAL_0:2;

                  y2=t.f0.j1 by A9,A35,A28,A24,A31,A29,A21,A30,A34,A44,A51,A56
,Lm19;

                  hence y1 >= y2 by A39,A43,A47,A53,A57;
                end;
                suppose
A58:              j=mm;
A59:              i<k1-n+1 by A52;
                  then
A60:              i<=k1-n by INT_1:20;

A61:              y2=t.f0.(k1+1) by A28,A24,A31,A29,A33,A12,A51,A58,Lm19;

                  hereby
                    reconsider kn=k1-n as Element of NAT by A59,INT_1:16,20;
A62:                t.f0.kn=x1 by A18,A43,A60,Lm20,XXREAL_0:2;
                    per cases;
                    suppose
                      i=kn;

                      hence
                      y1>=y2 by A18,A28,A24,A31,A29,A21,A12,A25,A43,A50,A52,A61
,A62,Lm19;

                    end;
                    suppose
                      i<>kn;
                      then i<kn by A60,XXREAL_0:1;
                      then y1>=x1 by A26,A39,A43,A42,A53,XXREAL_0:2;

                      hence y1 >= y2 by A18,A28,A24,A25,A37,A43,A51,A58,A60,
XXREAL_0:2;

                    end;
                  end;
                end;
              end;
            end;
            suppose
A63:          i>mm;
              then mm+1<=i by INT_1:20;
              then 0<i1 by A22,XREAL_1:21;
              then
A64:          1+0<=i1 by INT_1:20;
              mm<j by A45,A63,XXREAL_0:2;

              then
A65:          y2=t.f0.j1 by A9,A35,A28,A24,A31,A29,A21,A30,A34,A44,A51,Lm19;

              i<=k1+1 by A9,A35,A34,A44,A45,XXREAL_0:2;
              then y1=t.f0.i1 by A28,A24,A31,A29,A21,A30,A50,A63,Lm19;
              hence y1 >= y2 by A39,A47,A49,A65,A64;
            end;
            suppose
A66:          i=mm;
              k1<k1+1 by XREAL_1:31;
              then
A67:          j1<k1+1 by A47,XXREAL_0:2;
              mm-1<j1 by A45,A66,XREAL_1:11;

              then
A68:          ex yy be Integer st yy=t.f0.j1 & yy <= n3 by A14,A19,A25,A67;

              y2=t.f0.j1 by A9,A35,A28,A24,A31,A29,A33,A30,A34,A44,A45,A51,A66
,Lm19;

              hence y1 >= y2 by A28,A24,A31,A29,A33,A30,A50,A66,A68,Lm19;
            end;
          end;

          then IB.f0, IExec(T1,Q,IB).f0 are_fiberwise_equipotent by A8,A35,A36;

          hence t.f0, IExec(T1,Q,t).f0 are_fiberwise_equipotent by A28,A24,A32
,A38,CLASSES1:84;

          let i,j be Element of NAT;
          assume that
A69:      i>=1 and
A70:      j<=len(t.f0) and
A71:      i<j;
          let x1,x2 be Integer;
          assume that
A72:      x1=IExec(T1,Q,t).f0.i and
A73:      x2=IExec(T1,Q,t).f0.j;
          j<=len(IB.f0) by A28,A24,A32,A70,RFINSEQ:16;
          hence x1>=x2 by A8,A35,A36,A40,A38,A69,A71,A72,A73;
        end;
      end;
      hence P[k+1];
    end;
A74: P[ 0]
    proof
      let t be State of SCM+FSA,Q;
      assume that
A75:  t.b1=0 and
      t.b1 <= len (t.f0)-1;
      IExec(T1,Q,t).f0=t.f0 by A75,Lm11,SCM_HALT:80;
      hence thesis by A75;
    end;
    for k be Element of NAT holds P[k] from NAT_1:sch 1(A74,A7);
    then
A76: P[m];

    then (for i,j be Element of NAT st i>=1 & j<=len(s.f0)-s.b1 & i<j for x1,

x2 be Integer st x1 =s.f0.i & x2=s.f0.j holds x1 >= x2) implies
 s.f0, IExec(T1,P,

s).f0 are_fiberwise_equipotent & for i,j be Element of NAT st i>=1 & j<=len(s.

f0) & i<j for x1,x2 be Integer
 st x1 =IExec(T1,P,s).f0.i & x2=IExec(T1,P,s).f0.j
    holds x1 >= x2 by A1;

    hence s.f0, IExec(T1,P,s).f0 are_fiberwise_equipotent by A1,XXREAL_0:2;

    for i,j be Element of NAT st i>=1 & j<=len(s.f0)-s.b1 & i<j for x1,
    x2 be Integer st x1 =s.f0.i & x2=s.f0.j holds x1 >= x2 by A1,XXREAL_0:2;

    hence thesis by A1,A76;
  end;
end;

theorem Th45:
  for s be State of SCM+FSA
   holds s.(fsloc 0), IExec(insert-sort (fsloc 0),P,s).(fsloc 0)
    are_fiberwise_equipotent &
 for i,j be Element of NAT st i >=1 & j<=len (s.(fsloc 0)) & i<j
 for x1,x2 be Integer st x1 =IExec(insert-sort (fsloc 0),P,s).(fsloc 0).i &
     x2=IExec(insert-sort (fsloc 0),P,s).(fsloc 0).j
  holds x1 >= x2
proof
  let s be State of SCM+FSA;
  set WJ=w2 ';' w3 ';' w4 ';' w5 ';' w6 ';' j1 ';' j2,
     s0=Initialized s,
     s1=Exec(w2, s0),
     s2=IExec(w2 ';' w3,P, s),
     s3=IExec(w2 ';' w3 ';' w4,P,s),
     s4=IExec(w2 ';' w3 ';' w4 ';' w5,P,s),
     s5=IExec(w2 ';' w3 ';' w4 ';' w5 ';' w6,P,s),
     s6=IExec(w2 ';' w3 ';' w4 ';' w5 ';' w6 ';' j1,P,s),
     s7=IExec(WJ,P,s);
A1: s5.f0 =Exec(w6, s4).f0 by SCMFSA6C:8
    .=s4.f0 by SCMFSA_2:89
    .=Exec(w5, s3).f0 by SCMFSA6C:8
    .=s3.f0 by SCMFSA_2:89
    .=Exec(w4, s2).f0 by SCMFSA6C:8
    .=s2.f0 by SCMFSA_2:89
    .=Exec(w3, s1).f0 by SCMFSA6C:10
    .=s1.f0 by SCMFSA_2:89
    .=s0.f0 by SCMFSA_2:89
    .=s.f0 by SCMFSA6C:3;
A2: s6.f0 =Exec(j1, s5).f0 by SCMFSA6C:8
    .=s.f0 by A1,SCMFSA_2:100;
A3: IExec(WJ,P,s).f0 =Exec(j2, s6).f0 by SCMFSA6C:8
    .=s.f0 by A2,SCMFSA_2:91;
A4: IExec(insert-sort f0,P,s).f0=IExec(T1,P,s7).f0 by Lm12,SCM_HALT:31;
A5: s6.b1=Exec(j1, s5).b1 by SCMFSA6C:7
    .=len (s7.f0) by A1,A3,SCMFSA_2:100;
A6: s7.b1=Exec(j2, s6).b1 by SCMFSA6C:7
    .=s6.b1-s6.a0 by SCMFSA_2:91
    .=len (s7.f0) - 1 by A5,SCM_HALT:17;
  hence s.f0, IExec(insert-sort f0,P,s).f0
   are_fiberwise_equipotent by A3,A4,Lm21;
  let i,j be Element of NAT;
  assume that
A7: i>=1 and
A8: j<=len (s.f0) and
A9: i<j;
  thus thesis by A3,A6,A4,A7,A8,A9,Lm21;
end;

theorem Th46:
  for i being Element of NAT, s being State of SCM+FSA, w being
  FinSequence of INT, P
   st Initialized Insert-Sort-Algorithm +* ((fsloc 0) .--> w)
  c= s & Insert-Sort-Algorithm c= P
   holds IC Comput(P, s,i) in dom Insert-Sort-Algorithm
proof
  let i be Element of NAT, s be State of SCM+FSA,w be FinSequence of INT,P;
  set IS=Insert-Sort-Algorithm, Ii=Initialized IS;
  set x=((fsloc 0) .--> w);
  dom Ii misses dom x by SCMBSORT:46;
  then
A1: Ii c= Ii +* x by FUNCT_4:33;
  assume
   Ii +* x c= s;
  then
A2: Ii c= s by A1,XBOOLE_1:1;
  assume
A3: IS c= P;
   IS is InitClosed by Lm12;
  hence thesis by SCM_HALT:def 1,A3,A2;
end;

theorem Th47:
  for s be State of SCM+FSA,t be FinSequence of INT, P st Initialized
  Insert-Sort-Algorithm +*(fsloc 0 .--> t) c= s &
  Insert-Sort-Algorithm c= P
   ex u being FinSequence of
  REAL st t,u are_fiberwise_equipotent & u is non-increasing & u is FinSequence
  of INT & (Result(P,s)).(fsloc 0) = u
proof
  let s be State of SCM+FSA,t be FinSequence of INT, P;
  set Ia=Insert-Sort-Algorithm, p=Initialized Ia, x=fsloc 0 .--> t,
   z=IExec(insert-sort f0,P,s).f0;
  assume that
A1: p+*x c= s and
A2: Ia c= P;
A3: P +* Ia = P by A2,FUNCT_4:79;
  reconsider u=z as FinSequence of REAL by FINSEQ_3:126;
  take u;
  dom x = { f0} by FUNCOP_1:19;
  then
A4: f0 in dom x by TARSKI:def 1;
  then f0 in dom (p+*x) by FUNCT_4:13;
  then s.f0=(p+*x).f0 by A1,GRFUNC_1:8
    .=x.f0 by A4,FUNCT_4:14
    .=t by FUNCOP_1:87;
  hence t, u are_fiberwise_equipotent by Th45;
  s.f0, z are_fiberwise_equipotent by Th45;
  then
A5: dom (s.f0) = dom u by RFINSEQ:16;
  now
    let i,j be Element of NAT;
    assume that
A6: i in dom u and
A7: j in dom u and
A8: i<j;
A9: i>=1 by A6,FINSEQ_3:27;
    j<=len (s.f0) by A5,A7,FINSEQ_3:27;
    hence u.i>=u.j by A8,A9,Th45;
    reconsider y2=z.j as Integer;
    reconsider y1=z.i as Integer;
  end;
  hence u is non-increasing by RFINSEQ:32;
  thus u is FinSequence of INT;
  dom p misses dom x by SCMBSORT:46;
  then p c=p+*x by FUNCT_4:33;
  then p c= s by A1,XBOOLE_1:1;
  then s=s+*p by FUNCT_4:79;
  hence thesis by SCMBSORT:57,A3;
end;

theorem Th48:
  for w being FinSequence of INT holds Initialized
  Insert-Sort-Algorithm +* ((fsloc 0) .--> w) is autonomic
proof
  set DD={intloc 0,IC SCM+FSA,fsloc 0};
  let w be FinSequence of INT;
  set p=Initialized Insert-Sort-Algorithm +* ((fsloc 0) .--> w),
      q=Insert-Sort-Algorithm;
  not fsloc 0 in NAT by SCMFSA10:4;
  then ProgramPart ((fsloc 0) .--> w) = {} by FUNCOP_1:91;
  then
A1: ProgramPart p
     = ProgramPart Initialized Insert-Sort-Algorithm +* {} by FUNCT_4:75
    .= ProgramPart Initialized Insert-Sort-Algorithm by FUNCT_4:22
    .= q by SCMFSA6A:33;
A2: p is 0-started by SCMBSORT:47;
  set UD={fsloc 0,a0,a1,a2,a3,a4,a5,a6}, Us=UsedInt*Loc q \/ UsedIntLoc q;
A3: UsedIntLoc q ={a0,a1,a2,a3,a4,a5,a6} by Th38;
A4: UsedInt*Loc q ={fsloc 0} by Th39;
  then
A5: Us = UD by A3,ENUMSET1:62;
A6: for i being Element of NAT,s1,s2 being State of SCM+FSA,P1,P2
 st 11 <= i & p c= s1 & p c= s2 & q c= P1 & q c= P2
  holds Comput(P1, s1,i) | Us = Comput(
P2, s2,i) | Us &
  Comput(P1, s1,i).IC SCM+FSA = Comput(P2, s2,i).IC
SCM+FSA
  proof
    let i be Element of NAT,s1,s2 be State of SCM+FSA,P1,P2 such that
A7: 11 <= i and
A8: p c= s1 and
A9: p c= s2 and
A10: q c= P1 and
A11: q c= P2;
A12: s1.intloc 0 =1 by A8,SCMBSORT:54
      .= s2.intloc 0 by A9,SCMBSORT:54;
A13: s2 is 0-started by A9,A2,COMPOS_1:8;
:::A10: q c= s2 by A7,SCMBSORT:53,B7;
    set Cs11= Comput(P1, s1,11), Cs21= Comput(P2,
s2,11);
A14: s1 is 0-started by A8,A2,COMPOS_1:8;
A15: s1.fsloc 0 =w by A8,SCMBSORT:54
      .=s2.fsloc 0 by A9,SCMBSORT:54;
A16: now
      let x be set;
      assume x in Us;
      then
A17:  x in UD by A4,A3,ENUMSET1:62;
      per cases by A17,ENUMSET1:def 6;
      suppose
A18:    x = fsloc 0;
        hence Cs11.x =s1.fsloc 0 by A14,Lm2,A10
          .=Cs21.x by A13,A15,A18,Lm2,A11;
      end;
      suppose
A19:    x = a0;
        hence Cs11.x =s1.a0 by A14,Lm2,A10
          .=Cs21.x by A13,A12,A19,Lm2,A11;
      end;
      suppose
A20:    x = a1;
        hence Cs11.x=len(s1.fsloc 0) by A14,Lm2,A10
          .=Cs21.x by A13,A15,A20,Lm2,A11;
      end;
      suppose
A21:    x = a2;
        hence Cs11.x=s1.a0 by A14,Lm2,A10
          .=Cs21.x by A13,A12,A21,Lm2,A11;
      end;
      suppose
A22:    x = a3;
        hence Cs11.x=s1.a0 by A14,Lm2,A10
          .=Cs21.x by A13,A12,A22,Lm2,A11;
      end;
      suppose
A23:    x = a4;
        hence Cs11.x=s1.a0 by A14,Lm2,A10
          .=Cs21.x by A13,A12,A23,Lm2,A11;
      end;
      suppose
A24:    x = a5;
        hence Cs11.x=s1.a0 by A14,Lm2,A10
          .=Cs21.x by A13,A12,A24,Lm2,A11;
      end;
      suppose
A25:    x = a6;
        hence Cs11.x=s1.a0 by A14,Lm2,A10
          .=Cs21.x by A13,A12,A25,Lm2,A11;
      end;
    end;
A26: for i holds IC Comput(P2, s2,i) in dom q by A9,Th46,A11;
A27: for i holds IC Comput(P1, s1,i) in dom q by A8,Th46,A10;
A28: Us c= dom(Cs21) by SCMBSORT:56;
    Us c= dom(Cs11) by SCMBSORT:56;
    then
A29: Cs11 | Us = Cs21 | Us by A28,A16,FUNCT_1:165;
    Cs11.IC SCM+FSA =  11 by A14,Lm2,A10
      .=Cs21.IC SCM+FSA by A13,Lm2,A11;
    hence thesis by A7,A29,A27,A26,SCMBSORT:26,A10,A11;
  end;
A30: for s1,s2 being State of SCM+FSA,P1,P2,i
 st p c= s1 & p c= s2 & q c= P1 & q c= P2 & i <= 10 holds
Comput(P1, s1,i).intloc 0 = Comput(P2, s2,i).intloc
0 & Comput(P1, s1,i).
  IC SCM+FSA = Comput(P2, s2,i).IC SCM+FSA &
   Comput(P1, s1,i).fsloc 0 = Comput(P2, s2,i).fsloc 0
  proof
    let s1,s2 be State of SCM+FSA,P1,P2,i;
    assume that
A31: p c= s1 and
A32: p c= s2 and
A33: q c= P1 and
A34: q c= P2 and
A35: i <= 10;
A36: s2 is 0-started by A32,A2,COMPOS_1:8;
A37: s1.fsloc 0 =w by A31,SCMBSORT:54
      .=s2.fsloc 0 by A32,SCMBSORT:54;
A38: s1.intloc 0 =1 by A31,SCMBSORT:54
      .= s2.intloc 0 by A32,SCMBSORT:54;
A39: Comput(P1,s1,0) = s1 by EXTPRO_1:3;
A40: s1 is 0-started by A31,A2,COMPOS_1:8;
    then
A41: IC s1 =  0 by COMPOS_1:def 16
      .= IC s2 by A36,COMPOS_1:def 16;
    per cases by A35,NAT_1:35;
    suppose
A42:  i = 0;
      hence
      Comput(P1,s1,i).intloc 0 = Comput(P2,s2,i).
intloc 0 by A39,A38,EXTPRO_1:3;
      thus (Comput(P1,s1,i)).IC SCM+FSA = (Comput(P2,
s2,i)).IC SCM+FSA by A39,A41,A42,EXTPRO_1:3;
      thus thesis by A39,A37,A42,EXTPRO_1:3;
    end;
    suppose
A43:  i = 1;
      hence Comput(P1,s1,i).intloc 0 = s1.intloc 0 by A40,Lm2,A33
        .= Comput(P2,s2,i).intloc 0 by A36,A38,A43,Lm2,A34;
      thus (Comput(P1,s1,i)).IC SCM+FSA =  1 by A40,A43,Lm2,A33
        .= (Comput(P2,s2,i)).IC SCM+FSA by A36,A43,Lm2,A34;
      thus Comput(P1,s1,i).fsloc 0 = s1.fsloc 0 by A40,A43,Lm2,A33
        .= Comput(P2,s2,i).fsloc 0 by A36,A37,A43,Lm2,A34;
    end;
    suppose
A44:  i = 2;
      hence Comput(P1,s1,i).intloc 0 = s1.intloc 0 by A40,Lm2,A33
        .= Comput(P2,s2,i).intloc 0 by A36,A38,A44,Lm2,A34;
      thus (Comput(P1,s1,i)).IC SCM+FSA =  2 by A40,A44,Lm2,A33
        .= (Comput(P2,s2,i)).IC SCM+FSA by A36,A44,Lm2,A34;
      thus Comput(P1,s1,i).fsloc 0 = s1.fsloc 0 by A40,A44,Lm2,A33
        .= Comput(P2,s2,i).fsloc 0 by A36,A37,A44,Lm2,A34;
    end;
    suppose
A45:  i = 3;
      hence Comput(P1,s1,i).intloc 0 = s1.intloc 0 by A40,Lm2,A33
        .= Comput(P2,s2,i).intloc 0 by A36,A38,A45,Lm2,A34;
      thus (Comput(P1,s1,i)).IC SCM+FSA =  3 by A40,A45,Lm2,A33
        .= (Comput(P2,s2,i)).IC SCM+FSA by A36,A45,Lm2,A34;
      thus Comput(P1,s1,i).fsloc 0 = s1.fsloc 0 by A40,A45,Lm2,A33
        .= Comput(P2,s2,i).fsloc 0 by A36,A37,A45,Lm2,A34;
    end;
    suppose
A46:  i = 4;
      hence Comput(P1,s1,i).intloc 0 = s1.intloc 0 by A40,Lm2,A33
        .= Comput(P2,s2,i).intloc 0 by A36,A38,A46,Lm2,A34;
      thus (Comput(P1,s1,i)).IC SCM+FSA =  4 by A40,A46,Lm2,A33
        .= (Comput(P2,s2,i)).IC SCM+FSA by A36,A46,Lm2,A34;
      thus Comput(P1,s1,i).fsloc 0 = s1.fsloc 0 by A40,A46,Lm2,A33
        .= Comput(P2,s2,i).fsloc 0 by A36,A37,A46,Lm2,A34;
    end;
    suppose
A47:  i = 5;
      hence Comput(P1,s1,i).intloc 0 = s1.intloc 0 by A40,Lm2,A33
        .= Comput(P2,s2,i).intloc 0 by A36,A38,A47,Lm2,A34;
      thus (Comput(P1,s1,i)).IC SCM+FSA =  5 by A40,A47,Lm2,A33
        .= (Comput(P2,s2,i)).IC SCM+FSA by A36,A47,Lm2,A34;
      thus Comput(P1,s1,i).fsloc 0 = s1.fsloc 0 by A40,A47,Lm2,A33
        .= Comput(P2,s2,i).fsloc 0 by A36,A37,A47,Lm2,A34;
    end;
    suppose
A48:  i = 6;
      hence Comput(P1,s1,i).intloc 0 = s1.intloc 0 by A40,Lm2,A33
        .= Comput(P2,s2,i).intloc 0 by A36,A38,A48,Lm2,A34;
      thus (Comput(P1,s1,i)).IC SCM+FSA =  6 by A40,A48,Lm2,A33
        .= (Comput(P2,s2,i)).IC SCM+FSA by A36,A48,Lm2,A34;
      thus Comput(P1,s1,i).fsloc 0 = s1.fsloc 0 by A40,A48,Lm2,A33
        .= Comput(P2,s2,i).fsloc 0 by A36,A37,A48,Lm2,A34;
    end;
    suppose
A49:  i = 7;
      hence Comput(P1,s1,i).intloc 0 = s1.intloc 0 by A40,Lm2,A33
        .= Comput(P2,s2,i).intloc 0 by A36,A38,A49,Lm2,A34;
      thus (Comput(P1,s1,i)).IC SCM+FSA =  7 by A40,A49,Lm2,A33
        .= (Comput(P2,s2,i)).IC SCM+FSA by A36,A49,Lm2,A34;
      thus Comput(P1,s1,i).fsloc 0 = s1.fsloc 0 by A40,A49,Lm2,A33
        .= Comput(P2,s2,i).fsloc 0 by A36,A37,A49,Lm2,A34;
    end;
    suppose
A50:  i = 8;
      hence Comput(P1,s1,i).intloc 0 = s1.intloc 0 by A40,Lm2,A33
        .= Comput(P2,s2,i).intloc 0 by A36,A38,A50,Lm2,A34;
      thus (Comput(P1,s1,i)).IC SCM+FSA =  8 by A40,A50,Lm2,A33
        .= (Comput(P2,s2,i)).IC SCM+FSA by A36,A50,Lm2,A34;
      thus Comput(P1,s1,i).fsloc 0 = s1.fsloc 0 by A40,A50,Lm2,A33
        .= Comput(P2,s2,i).fsloc 0 by A36,A37,A50,Lm2,A34;
    end;
    suppose
A51:  i = 9;
      hence Comput(P1,s1,i).intloc 0 = s1.intloc 0 by A40,Lm2,A33
        .= Comput(P2,s2,i).intloc 0 by A36,A38,A51,Lm2,A34;
      thus (Comput(P1,s1,i)).IC SCM+FSA =  9 by A40,A51,Lm2,A33
        .= (Comput(P2,s2,i)).IC SCM+FSA by A36,A51,Lm2,A34;
      thus Comput(P1,s1,i).fsloc 0 = s1.fsloc 0 by A40,A51,Lm2,A33
        .= Comput(P2,s2,i).fsloc 0 by A36,A37,A51,Lm2,A34;
    end;
    suppose
A52:  i = 10;
      hence Comput(P1,s1,i).intloc 0 = s1.intloc 0 by A40,Lm2,A33
        .= Comput(P2,s2,i).intloc 0 by A36,A38,A52,Lm2,A34;
      thus (Comput(P1,s1,i)).IC SCM+FSA =  10 by A40,A52,Lm2,A33
        .= (Comput(P2,s2,i)).IC SCM+FSA by A36,A52,Lm2,A34;
      thus Comput(P1,s1,i).fsloc 0 = s1.fsloc 0 by A40,A52,Lm2,A33
        .= Comput(P2,s2,i).fsloc 0 by A36,A37,A52,Lm2,A34;
    end;
  end;
A53: dom p = dom q \/ DD by SCMBSORT:42;
    fsloc 0 in FinSeq-Locations by SCMFSA_2:10;
    then
A54: fsloc 0 in Data-Locations SCM+FSA by SCMFSA_2:127,XBOOLE_0:def 3;
    intloc 0 in Int-Locations by SCMFSA_2:9;
    then
A55: intloc 0 in Data-Locations SCM+FSA by SCMFSA_2:127,XBOOLE_0:def 3;
A56: dom DataPart((fsloc 0) .--> w)
        = dom((fsloc 0) .--> w) /\ Data-Locations SCM+FSA by RELAT_1:90
       .= {fsloc 0} /\ Data-Locations SCM+FSA by FUNCOP_1:19
       .= {fsloc 0} by A54,ZFMISC_1:52;
A57: Data-Locations SCM+FSA misses NAT by COMPOS_1:51;
    dom q c= NAT by RELAT_1:def 18;
    then
A58: Data-Locations SCM+FSA misses dom q by A57,XBOOLE_1:63;
    Initialized q = Initialize(q +* ((intloc 0) .--> 1)) by FUNCT_4:15;
    then DataPart Initialized q
      = (Initialize (q +* ((intloc 0) .--> 1))) |Data-Locations SCM+FSA
              by SCMFSA6A:def 4
     .= (q +* ((intloc 0) .--> 1))|Data-Locations SCM+FSA
           +* DataPart Start-At(0,SCM+FSA) by FUNCT_4:75
     .= (q +* ((intloc 0) .--> 1))|Data-Locations SCM+FSA
            +* {} by COMPOS_1:30
     .= (q +* ((intloc 0) .--> 1))|Data-Locations SCM+FSA by FUNCT_4:22
     .= DataPart q +* ((intloc 0) .--> 1)|Data-Locations SCM+FSA by FUNCT_4:75
     .= {} +* ((intloc 0) .--> 1)|Data-Locations SCM+FSA by A58,RELAT_1:95
     .= ((intloc 0) .--> 1)|Data-Locations SCM+FSA by FUNCT_4:21;
    then
A59: dom DataPart Initialized q
       = dom((intloc 0) .--> 1) /\ Data-Locations SCM+FSA by RELAT_1:90
      .= {intloc 0} /\ Data-Locations SCM+FSA by FUNCOP_1:19
      .= {intloc 0} by A55,ZFMISC_1:52;
    DataPart p
      = DataPart Initialized q +* DataPart ((fsloc 0) .--> w) by FUNCT_4:75;
    then
A60: dom DataPart p = {fsloc 0} \/ {intloc 0} by A56,A59,FUNCT_4:def 1
         .= {intloc 0,fsloc 0} by ENUMSET1:41;
    IC SCM+FSA in DD by ENUMSET1:def 1;
    then IC SCM+FSA in dom p by A53,XBOOLE_0:def 3;
    then
A61: dom NPP p
      = {IC SCM+FSA} \/ dom DataPart p by COMPOS_1:70
     .= {IC SCM+FSA,intloc 0,fsloc 0} by A60,ENUMSET1:42
     .= DD by ENUMSET1:99;
  now
    let s1,s2 be State of SCM+FSA,P1,P2,i;
    assume that
A62: p c= s1 and
A63: p c=s2 and
A64: q c= P1 and
A65: q c=P2;
    set Cs1i= Comput(P1, s1,i), Cs2i= Comput(P2, s2,i);
A66: Us c= dom(Cs1i) by SCMBSORT:56;
A67: fsloc 0 in Us by A5,ENUMSET1:def 6;
A68: Us c= dom(Cs2i) by SCMBSORT:56;
A69: i>10 implies 10+1 < i+1 by XREAL_1:8;
A70: intloc 0 in Us by A5,ENUMSET1:def 6;
A71: now
      let x be set;
      assume
A72:  x in DD;
      per cases by A72,ENUMSET1:def 1;
      suppose
A73:    x=intloc 0;
          per cases;
          suppose
            i<=10;
            hence Cs1i.x=Cs2i.x by A30,A62,A63,A73,A64,A65;
          end;
          suppose
            i>10;
            then 11 <= i by A69,NAT_1:13;
            then Cs1i | Us = Cs2i | Us by A6,A62,A63,A64,A65;
            hence Cs1i.x=Cs2i.x by A70,A66,A68,A73,FUNCT_1:165;
          end;
      end;
      suppose
A74:    x=IC SCM+FSA;
          per cases;
          suppose
            i<=10;
            hence Cs1i.x=Cs2i.x by A30,A62,A63,A74,A64,A65;
          end;
          suppose
            i>10;
            then 11 <= i by A69,NAT_1:13;
            hence Cs1i.x=Cs2i.x by A6,A62,A63,A74,A64,A65;
          end;
      end;
      suppose
A75:    x=fsloc 0;
          per cases;
          suppose
            i<=10;
            hence Cs1i.x=Cs2i.x by A30,A62,A63,A75,A64,A65;
          end;
          suppose
            i>10;
            then 11 <= i by A69,NAT_1:13;
            then Cs1i | Us = Cs2i | Us by A6,A62,A63,A64,A65;
            hence Cs1i.x=Cs2i.x by A67,A66,A68,A75,FUNCT_1:165;
          end;
      end;
    end;
A76: DD c= dom Cs2i by SCMBSORT:55;
    DD c= dom Cs1i by SCMBSORT:55;
    then Cs1i | DD = Cs2i| DD by A76,A71,FUNCT_1:165;
    hence Cs1i| dom NPP p = Cs2i | dom NPP p by A61;
  end;
  then
  for P,Q being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
    st ProgramPart p c= P & ProgramPart p c= Q
   for s1,s2 being State of SCM+FSA st p c= s1 & p c= s2
   for i holds Comput(P,s1,i)|dom NPP p = Comput(Q,s2,i)|dom NPP p by A1;
  hence thesis by EXTPRO_1:def 9;
end;

registration
 cluster Insert-Sort-Algorithm -> non halt-free;
 coherence;
end;

theorem
  Insert-Sort-Algorithm, Initialized Insert-Sort-Algorithm
     computes Sorting-Function
proof
  set q = Insert-Sort-Algorithm,
   p = Initialized Insert-Sort-Algorithm;
A1: q c= p by SCMFSA6A:26;
  let x be set;
  assume x in dom Sorting-Function;
  then consider w being FinSequence of INT such that
A2: x = fsloc 0 .--> w by SCMBSORT:60;
  reconsider d = x as FinPartState of SCM+FSA by A2;
  consider t being State of SCM+FSA such that
A3: p +* d c= t by PBOOLE:156;
A4: dom p misses dom d by A2,SCMBSORT:46;
A5: now
    set bf=insert-sort fsloc 0;
    let t be State of SCM+FSA;
    assume
A6: p+*d c= t;
    let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
    such that
A7: ProgramPart(p+*d) c= P;
A8:  p c=p+*d by A4,FUNCT_4:33;
    then
A9:  p c= t by A6,XBOOLE_1:1;
    ProgramPart p c= ProgramPart(p+*d) by A8,RELAT_1:105;
     then
  ProgramPart p c= P by A7,XBOOLE_1:1;
    hence P halts_on t by Lm12,EXTPRO_1:def 10,A9;
  end;
  take d;
  thus x = d;
A10: dom d = { fsloc 0 } by A2,FUNCOP_1:19;
A11:
  now assume dom d meets NAT;
    then consider x being set such that
A12:  x in dom d and
A13:  x in NAT by XBOOLE_0:3;
    x = fsloc 0 by A12,A10,TARSKI:def 1;
   hence contradiction by A13,SCMFSA_2:85;
  end;
   fsloc 0 in FinSeq-Locations by SCMFSA_2:10;
   then
A14:  {fsloc 0} c= FinSeq-Locations by ZFMISC_1:37;
A15:  dom q c= NAT by RELAT_1:def 18;
  dom d misses NAT by A14,A10,SCMFSA_2:14,XBOOLE_1:63;
     then
A16:dom d misses dom q by A15,XBOOLE_1:63;
A17:   p +* d +* q
           = p +* (d +* q) by FUNCT_4:15
          .= p +* (q +* d) by A16,FUNCT_4:36
          .= p +* q +* d by FUNCT_4:15
          .= p+*d by A1,FUNCT_4:79;
   then p +* d +* q is halting autonomic by A2,A5,Th48,EXTPRO_1:def 10;
  hence
A18: p +* d is Autonomy of q by EXTPRO_1:def 11;
A19: dom d misses {IC SCM+FSA} by A10,SCMFSA_2:82,ZFMISC_1:17;
  dom d misses {IC SCM+FSA} \/ NAT by A19,A11,XBOOLE_1:70;
  then d is data-only by COMPOS_1:def 23;
  then dom d misses NAT by COMPOS_1:40;
  then
A20:  ProgramPart(p +* d)= ProgramPart p by FUNCT_4:76;
A21: p +* d is Autonomy of q by A18;
  fsloc 0 in the carrier of SCM+FSA;
  then
A22: fsloc 0 in dom Result(ProgramPart(t),t) by PARTFUN1:def 4;
A23: q = ProgramPart p by SCMFSA6A:33;
A24: Result(q,p +* d) = (Result(ProgramPart(t),t))|dom NPP(p +* d)
        by A3,A21,A23,A20,EXTPRO_1:def 12;
   q c= p +* d by A17,FUNCT_4:26;
   then q c= t by A3,XBOOLE_1:1;
   then q c= ProgramPart t by RELAT_1:210;
  then consider u being FinSequence of REAL such that
A25: w,u are_fiberwise_equipotent and
A26: u is non-increasing and
  u is FinSequence of INT and
A27: (Result(ProgramPart(t),t)).(fsloc 0) = u by A2,A3,Th47;
  consider z being FinSequence of REAL such that
A28: w,z are_fiberwise_equipotent and
A29: z is non-increasing and
  z is FinSequence of INT and
A30: Sorting-Function.d = fsloc 0 .--> z by A2,SCMBSORT:61;
  fsloc 0 in FinSeq-Locations by SCMFSA_2:10;
  then dom d c= FinSeq-Locations by A10,ZFMISC_1:37;
  then dom d c= Data-Locations SCM+FSA by SCMFSA_2:127,XBOOLE_1:10;
  then d is data-only by COMPOS_1:31;
  then NPP(p+*d) = NPP p +* d by COMPOS_1:67;
  then d c= NPP(p +* d) by FUNCT_4:26;
  then
A31: dom d c= dom NPP(p +* d) by RELAT_1:25;
A32: dom(fsloc 0 .--> z) = { fsloc 0 } by FUNCOP_1:19;
A33: u=z by A28,A29,A25,A26,CLASSES1:84,RFINSEQ:36;
 dom(fsloc 0 .--> z) c= dom NPP(p +* d)
     by A2,A32,FUNCOP_1:19,A31;
  hence thesis by A30,A24,A27,A22,A33,FUNCT_4:90,RELAT_1:186;
end;

