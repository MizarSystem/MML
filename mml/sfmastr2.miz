:: Another { \bf times } Macro Instruction
::  by Piotr Rudnicki
::
:: Received June 4, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies NUMBERS, FSM_1, SCMFSA_2, SF_MASTR, AMI_1, SCMFSA7B, SUBSET_1,
      XBOOLE_0, CARD_1, UNIALG_2, SCMFSA6B, FUNCT_1, FUNCT_4,
      SCMFSA6A, TARSKI, RELAT_1, ARYTM_3, GRAPHSP, MSUALG_1, SFMASTR1,
      TURING_1, SCMFSA_9, AMI_3, CARD_3, XXREAL_0, ARYTM_1, SCMFSA9A, COMPLEX1,
      AOFA_I00, PRE_FF, SFMASTR2, NAT_1, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, INT_2, XXREAL_0,
      RELAT_1, FUNCT_1, FUNCT_2, FUNCT_4, PRE_FF, CARD_3, COMPOS_1,
      EXTPRO_1, AMI_1,
      SCMFSA_2, SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA7B, SCMFSA_9,
      SFMASTR1, SCMFSA9A, NAT_1;
 constructors XXREAL_0, INT_2, PRE_FF, SCMFSA6A, SCMFSA6B, SCMFSA6C, SCMFSA_9,
      SFMASTR1, SCMFSA9A, RELSET_1, PRE_POLY, PBOOLE, SCMFSA8A, SCMFSA7B,
      AMI_1;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FINSET_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, SCMFSA_2, SF_MASTR, SCMFSA6B,
      SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA_9, SFMASTR1, XBOOLE_0, RELAT_1,
      FUNCT_2, AMI_1, COMPOS_1, EXTPRO_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions SCMFSA9A, SUBSET_1, SCMFSA6A, COMPOS_1, EXTPRO_1, AMI_1;
 theorems TARSKI, ZFMISC_1, ABSVALUE, NAT_1, INT_1, FUNCT_4, PRE_FF, SCMFSA_2,
      SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B,
      SCMFSA8C, SCMFSA_9, SFMASTR1, SCMFSA9A, XBOOLE_0, XBOOLE_1, XREAL_1,
      RELAT_1, XXREAL_0, FUNCT_1, AMI_1, PBOOLE, COMPOS_1, EXTPRO_1;
 schemes FUNCT_2, NAT_1;

begin :: SCM+FSA preliminaries

reserve s, s1, s2 for State of SCM+FSA,
  a, b for Int-Location,
  d for
  read-write Int-Location,
  f for FinSeq-Location,
  I for Program of SCM+FSA,
  J for
  good Program of SCM+FSA,
  k, m for Element of NAT;
set D = Int-Locations \/ FinSeq-Locations;
set SAt = Start-At( 0,SCM+FSA);

theorem Th1:
  I is_closed_on Initialized s & I is_halting_on Initialized s & not
  b in UsedIntLoc I implies IExec(I, s).b = (Initialized s).b
proof
  set a = b;
  assume that
A1: I is_closed_on Initialized s and
A2: I is_halting_on Initialized s and
A3: not a in UsedIntLoc I;
  set Is = Initialized s;
  set sI = s+*Initialized I;
A4: I+*SAt c= Initialized I & Initialized I c= sI by FUNCT_4:26,SCMFSA8C:19;
A5: ProgramPart(Is+*(I +* Start-At( 0,SCM+FSA)))
   halts_on Is+*(I +* Start-At( 0,SCM+FSA)) by A2,SCMFSA7B:def 8;
  NAT misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A6: dom ProgramPart s misses D by COMPOS_1:34;
A7: sI = Is+*(I +* SAt) by SCMFSA8A:13;
  then for m st m < (LifeSpan(ProgramPart(sI),sI)) holds IC Comput(ProgramPart(
sI),sI,m) in dom
I by A1,SCMFSA7B:def 7;
  then
A8: Comput(ProgramPart(sI),sI,LifeSpan(ProgramPart(sI),sI)).a = sI.a by A3,A4,
SF_MASTR:69,XBOOLE_1:1;
  DataPart sI = DataPart Is by SCMFSA8B:5;
  then
A9: sI.a = Is.a by SCMFSA6A:38;
  DataPart IExec(I, s) = DataPart(Result(ProgramPart(sI),sI) +* s | NAT) by
SCMFSA6B:def 1
    .= DataPart Result(ProgramPart(sI),sI) by A6,FUNCT_4:76,SCMFSA_2:127
    .= DataPart Comput(ProgramPart(sI),sI,LifeSpan(ProgramPart(sI),sI)) by A7
,A5,EXTPRO_1:23;
  hence thesis by A8,A9,SCMFSA6A:38;
end;

theorem
  I is_closed_on Initialized s & I is_halting_on Initialized s & not f in
  UsedInt*Loc I implies IExec(I, s).f = (Initialized s).f
proof
  set a = f;
  assume that
A1: I is_closed_on Initialized s and
A2: I is_halting_on Initialized s and
A3: not a in UsedInt*Loc I;
  set Is = Initialized s;
  set sI = s+*Initialized I;
A4: I+*SAt c= Initialized I & Initialized I c= sI by FUNCT_4:26,SCMFSA8C:19;
A5: ProgramPart(Is+*(I +* Start-At( 0,SCM+FSA)))
    halts_on Is+*(I +* Start-At( 0,SCM+FSA)) by A2,SCMFSA7B:def 8;
  NAT misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A6: dom ProgramPart s misses D by COMPOS_1:34;
A7: sI = Is+*(I +* SAt) by SCMFSA8A:13;
  then for m st m < (LifeSpan(ProgramPart(sI),sI)) holds IC Comput(ProgramPart(
sI),sI,m) in dom
I by A1,SCMFSA7B:def 7;
  then
A8: Comput(ProgramPart(sI),sI,LifeSpan(ProgramPart(sI),sI)).a = sI.a by A3,A4,
SF_MASTR:71,XBOOLE_1:1;
  DataPart sI = DataPart Is by SCMFSA8B:5;
  then
A9: sI.a = Is.a by SCMFSA6A:38;
  DataPart IExec(I, s) = DataPart(Result(ProgramPart(sI),sI) +* s | NAT) by
SCMFSA6B:def 1
    .= DataPart(Result(ProgramPart(sI),sI)) by A6,FUNCT_4:76,SCMFSA_2:127
    .= DataPart Comput(ProgramPart(sI),sI,LifeSpan(ProgramPart(sI),sI)) by A7
,A5,EXTPRO_1:23;
  hence thesis by A8,A9,SCMFSA6A:38;
end;

theorem Th3:
  ( I is_closed_on Initialized s & I is_halting_on Initialized s or I
is parahalting ) & (s.intloc 0 = 1 or a is read-write) & not a in UsedIntLoc I
  implies IExec(I, s).a = s.a
proof
  assume that
A1: I is_closed_on Initialized s & I is_halting_on Initialized s or I is
  parahalting and
A2: s.intloc 0 = 1 or a is read-write and
A3: not a in UsedIntLoc I;
A4: a = intloc 0 or a is read-write by SF_MASTR:def 5;
  I is_closed_on Initialized s & I is_halting_on Initialized s
  by A1,SCMFSA7B:24,25;
  hence IExec(I, s).a = (Initialized s).a by A3,Th1
    .= s.a by A2,A4,SCMFSA6C:3;
end;

theorem Th4:
  s.intloc 0 = 1 implies (I is_closed_on s iff I is_closed_on
  Initialized s)
proof
  assume s.intloc 0 = 1;
  then DataPart Initialized s = DataPart s by SCMFSA8C:27;
  hence thesis by SCMFSA8B:6;
end;

theorem Th5:
  s.intloc 0 = 1 implies ( I is_closed_on s & I is_halting_on s iff
  I is_closed_on Initialized s & I is_halting_on Initialized s)
proof
  assume s.intloc 0 = 1;
  then DataPart Initialized s = DataPart s by SCMFSA8C:27;
  hence thesis by SCMFSA8B:8;
end;

theorem Th6:
  for Iloc being Subset of Int-Locations, Floc being Subset of
  FinSeq-Locations holds s1 | (Iloc \/ Floc) = s2 | (Iloc \/ Floc) iff (for x
  being Int-Location st x in Iloc holds s1.x = s2.x) & for x being
  FinSeq-Location st x in Floc holds s1.x = s2.x
proof
  let Iloc be Subset of Int-Locations, Floc be Subset of FinSeq-Locations;
  FinSeq-Locations c= dom s1 by SCMFSA_2:70;
  then
A1: Floc c= dom s1 by XBOOLE_1:1;
  FinSeq-Locations c= dom s2 by SCMFSA_2:70;
  then
A2: Floc c= dom s2 by XBOOLE_1:1;
  Int-Locations c= dom s2 by SCMFSA_2:69;
  then
A3: Iloc c= dom s2 by XBOOLE_1:1;
  then
A4: Iloc \/ Floc c= dom s2 by A2,XBOOLE_1:8;
  Int-Locations c= dom s1 by SCMFSA_2:69;
  then
A5: Iloc c= dom s1 by XBOOLE_1:1;
  then
A6: Iloc \/ Floc c= dom s1 by A1,XBOOLE_1:8;
  hereby
    assume
A7: s1 | (Iloc \/ Floc) = s2 | (Iloc \/ Floc);
    hereby
      let x be Int-Location;
      assume x in Iloc;
      then x in Iloc \/ Floc by XBOOLE_0:def 3;
      hence s1.x = s2.x by A6,A4,A7,FUNCT_1:165;
    end;
    let x be FinSeq-Location;
    assume x in Floc;
    then x in Iloc \/ Floc by XBOOLE_0:def 3;
    hence s1.x = s2.x by A6,A4,A7,FUNCT_1:165;
  end;
  assume that
A8: for x being Int-Location st x in Iloc holds s1.x = s2.x and
A9: for x being FinSeq-Location st x in Floc holds s1.x = s2.x;
A10: now
    hereby
      let x be set;
      assume
A11:  x in Iloc;
      then reconsider x9 = x as Int-Location by SCMFSA_2:11;
      thus s1.x = s2.x9 by A8,A11
        .= s2.x;
    end;
    let x be set;
    assume
A12: x in Floc;
    then reconsider x9 = x as FinSeq-Location by SCMFSA_2:12;
    thus s1.x = s2.x9 by A9,A12
      .= s2.x;
  end;
  then
A13: s1 | Floc = s2 | Floc by A1,A2,FUNCT_1:165;
  s1 | Iloc = s2 | Iloc by A5,A3,A10,FUNCT_1:165;
  hence thesis by A13,RELAT_1:185;
end;

theorem Th7:
  for Iloc being Subset of Int-Locations holds s1 | (Iloc \/
  FinSeq-Locations) = s2 | (Iloc \/ FinSeq-Locations) iff (for x being
  Int-Location st x in Iloc holds s1.x = s2.x) & for x being FinSeq-Location
  holds s1.x = s2.x
proof
  set FSL = FinSeq-Locations;
  let Iloc be Subset of Int-Locations;
A1: (for x being FinSeq-Location holds s1.x = s2.x) implies for x being
  FinSeq-Location st x in FSL holds s1.x = s2.x;
A2: (for x being FinSeq-Location st x in FSL holds s1.x = s2.x) implies for
  x be FinSeq-Location holds s1.x = s2.x by SCMFSA_2:10;
  [#] FSL = FSL;
  hence thesis by A1,A2,Th6;
end;

begin :: Another times macro instruction

definition
  let a be Int-Location, I be Program of SCM+FSA;
  func times(a, I) -> Program of SCM+FSA equals
  (1-stRWNotIn ({a} \/
  UsedIntLoc I)) := a ';' while>0 ( 1-stRWNotIn ({a} \/ UsedIntLoc I), I ';'
  SubFrom(1-stRWNotIn ({a} \/ UsedIntLoc I), intloc 0) );
  correctness;
end;

notation
  let a be Int-Location, I be Program of SCM+FSA;
  synonym a times I for times(a, I);
end;

theorem Th8:
  {b} \/ UsedIntLoc I c= UsedIntLoc times(b, I)
proof
  set a =b;
  set aux = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  UsedIntLoc times(a,I) = UsedIntLoc (aux := a) \/ UsedIntLoc while>0(aux,
  I ';' SubFrom(aux, intloc 0)) by SF_MASTR:33
    .= {aux, a} \/ UsedIntLoc while>0(aux, I ';' SubFrom(aux, intloc 0)) by
SF_MASTR:18
    .= {aux, a} \/ ({aux} \/ UsedIntLoc (I ';' SubFrom(aux,intloc 0))) by
SCMFSA9A:30
    .= {aux, a} \/ {aux} \/ UsedIntLoc (I ';' SubFrom(aux, intloc 0)) by
XBOOLE_1:4
    .= {aux, a} \/ UsedIntLoc (I ';' SubFrom(aux, intloc 0)) by ZFMISC_1:14
    .= {aux, a} \/ ((UsedIntLoc I) \/ UsedIntLoc SubFrom(aux, intloc 0)) by
SF_MASTR:34
    .= {aux, a} \/ ((UsedIntLoc I) \/ {aux, intloc 0}) by SF_MASTR:18
    .= {aux, a} \/ (UsedIntLoc I) \/ {aux, intloc 0} by XBOOLE_1:4;
  then
A1: {aux, a} \/ UsedIntLoc I c= UsedIntLoc times(a, I) by XBOOLE_1:7;
  UsedIntLoc I c= {aux, a} \/ UsedIntLoc I by XBOOLE_1:7;
  then
A2: UsedIntLoc I c= UsedIntLoc times(a, I) by A1,XBOOLE_1:1;
  {a} c= {aux, a} & {aux, a} c= {aux, a} \/ UsedIntLoc I by XBOOLE_1:7
,ZFMISC_1:12;
  then {a} c= {aux, a} \/ UsedIntLoc I by XBOOLE_1:1;
  then {a} c= UsedIntLoc times(a, I) by A1,XBOOLE_1:1;
  hence thesis by A2,XBOOLE_1:8;
end;

theorem
  UsedInt*Loc times(b, I) = UsedInt*Loc I
proof
  set a = b;
  set aux = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  thus UsedInt*Loc times(a,I) = UsedInt*Loc(aux := a)\/ UsedInt*Loc while>0(
  aux,I ';' SubFrom(aux, intloc 0)) by SF_MASTR:49
    .= {} \/ UsedInt*Loc while>0(aux, I ';' SubFrom(aux, intloc 0)) by
SF_MASTR:36
    .= UsedInt*Loc (I ';' SubFrom(aux,intloc 0)) by SCMFSA9A:31
    .= (UsedInt*Loc I) \/ UsedInt*Loc SubFrom(aux, intloc 0) by SF_MASTR:50
    .= (UsedInt*Loc I) \/ {} by SF_MASTR:36
    .= UsedInt*Loc I;
end;

registration
  let I be good Program of SCM+FSA, a be Int-Location;
  cluster times(a, I) -> good;
  coherence;
end;

definition
  let s be State of SCM+FSA, I be Program of SCM+FSA, a be Int-Location;
  func StepTimes(a, I, s) -> Function of NAT, product the Object-Kind of
  SCM+FSA equals
  StepWhile>0(1-stRWNotIn ({a} \/ UsedIntLoc I), I ';' SubFrom(1
  -stRWNotIn ({a} \/ UsedIntLoc I), intloc 0), Exec(1-stRWNotIn ({a} \/
  UsedIntLoc I) := a, Initialized s));
  correctness;
end;

theorem Th10:
  StepTimes(a, J, s).0.intloc 0 = 1
proof
  set I = J;
  set ST = StepTimes(a, I, s);
  set au = 1-stRWNotIn({a} \/ UsedIntLoc I);
  set Is = Initialized s;
  thus ST.0.intloc 0 = Exec(au := a, Is).intloc 0 by SCMFSA_9:def 5
    .= Is.intloc 0 by SCMFSA_2:89
    .= 1 by SCMFSA6C:3;
end;

theorem Th11:
  s.intloc 0 = 1 or a is read-write implies StepTimes(a, J, s).0.(
  1-stRWNotIn ({a} \/ UsedIntLoc J)) = s.a
proof
  set I = J;
  set ST = StepTimes(a, I, s);
  set au = 1-stRWNotIn({a} \/ UsedIntLoc I);
  set Is = Initialized s;
  assume
A1: s.intloc 0 = 1 or a is read-write;
A2: a = intloc 0 or a is read-write by SF_MASTR:def 5;
  thus ST.0.au = Exec(au := a, Is).au by SCMFSA_9:def 5
    .= Is.a by SCMFSA_2:89
    .= s.a by A1,A2,SCMFSA6C:3;
end;

theorem Th12:
  StepTimes(a, J, s).k.intloc 0 = 1 & J is_closed_on StepTimes(a,
J, s).k & J is_halting_on StepTimes(a, J, s).k implies StepTimes(a, J, s).(k+1)
  .intloc 0 = 1 & (StepTimes(a, J, s).k.(1-stRWNotIn ({a} \/ UsedIntLoc J)) > 0
  implies StepTimes(a, J, s).(k+1).(1-stRWNotIn ({a} \/ UsedIntLoc J)) =
  StepTimes(a, J, s).k.(1-stRWNotIn ({a} \/ UsedIntLoc J)) - 1)
proof
  set I = J;
  assume that
A1: StepTimes(a, I, s).k.intloc 0 = 1 and
A2: I is_closed_on StepTimes(a, I, s).k & I is_halting_on StepTimes(a, I
  , s).k;
  set ST = StepTimes(a, I, s);
A3: I is_closed_on Initialized ST.k & I is_halting_on Initialized ST.k by A1,A2
,Th5;
  set au = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  set SW = StepWhile>0 (au, I ';' SubFrom(au, intloc 0), Exec(au := a,
  Initialized s));
A4: Macro SubFrom(au, intloc 0) is_closed_on IExec(I, ST.k) by SCMFSA7B:24;
  Macro SubFrom(au, intloc 0) is_halting_on IExec(I, ST.k) by SCMFSA7B:25;
  then
A5: I ';' SubFrom(au, intloc 0) is_halting_on Initialized ST.k by A3,A4,
SFMASTR1:4;
  hereby
    per cases;
    suppose
      SW.k.au <= 0;
      then DataPart SW.(k+1) = DataPart ST.k by SCMFSA9A:37;
      hence StepTimes(a, I, s).(k+1).intloc 0 = 1 by A1,SCMFSA6A:38;
    end;
    suppose
      SW.k.au > 0;
      then
      DataPart SW.(k+1) = DataPart IExec(I ';' SubFrom(au, intloc 0), ST.
      k) by A1,A3,A4,A5,SCMFSA9A:38,SFMASTR1:3;
      hence
      ST.(k+1).intloc 0 = IExec(I ';' SubFrom(au, intloc 0), ST.k).intloc
      0 by SCMFSA6A:38
        .= Exec(SubFrom(au, intloc 0), IExec(I, ST.k)).intloc 0 by A3,
SFMASTR1:12
        .= IExec(I, ST.k).intloc 0 by SCMFSA_2:91
        .= 1 by A3,SCMFSA8C:96;
    end;
  end;
  not au in {a} \/ UsedIntLoc I by SFMASTR1:21;
  then
A6: not au in UsedIntLoc I by XBOOLE_0:def 3;
  assume ST.k.au > 0;
  then DataPart SW.(k+1) = DataPart IExec(I ';' SubFrom(au, intloc 0), ST.k)
  by A1,A3,A4,A5,SCMFSA9A:38,SFMASTR1:3;
  hence ST.(k+1).au = IExec(I ';' SubFrom(au, intloc 0), ST.k).au by
SCMFSA6A:38
    .= Exec(SubFrom(au, intloc 0), IExec(I, ST.k)).au by A3,SFMASTR1:12
    .= IExec(I, ST.k).au - IExec(I, ST.k).intloc 0 by SCMFSA_2:91
    .= IExec(I, ST.k).au - 1 by A3,SCMFSA8C:96
    .= (Initialized ST.k).au - 1 by A3,A6,Th1
    .= ST.k.au - 1 by SCMFSA6C:3;
end;

theorem Th13:
  s.intloc 0 = 1 or a is read-write implies StepTimes(a, I, s).0.a
  = s.a
proof
  set ST = StepTimes(a, I, s);
  set au = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  set Is = Initialized s;
  assume
A1: s.intloc 0 = 1 or a is read-write;
A2: a = intloc 0 or a is read-write by SF_MASTR:def 5;
  a in {a} by TARSKI:def 1;
  then a in {a} \/ UsedIntLoc I by XBOOLE_0:def 3;
  then
A3: au <> a by SFMASTR1:21;
  thus ST.0.a = Exec(au := a, Is).a by SCMFSA_9:def 5
    .= Is.a by A3,SCMFSA_2:89
    .= s.a by A1,A2,SCMFSA6C:3;
end;

theorem
  StepTimes(a, I, s).0.f = s.f
proof
  set ST = StepTimes(a, I, s);
  set au = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  set Is = Initialized s;
  thus ST.0.f = Exec(au := a, Is).f by SCMFSA_9:def 5
    .= Is.f by SCMFSA_2:89
    .= s.f by SCMFSA6C:3;
end;

definition
  let s be State of SCM+FSA, a be Int-Location, I be Program of SCM+FSA;
  pred ProperTimesBody a, I, s means
  :Def3:
  for k being Element of NAT st k <
s.a holds I is_closed_on StepTimes(a,I,s).k & I is_halting_on StepTimes(a,I,s).
  k;
end;

theorem Th15:
  I is parahalting implies ProperTimesBody a, I, s
proof
  assume
A1: I is parahalting;
  then reconsider I9 = I as parahalting Program of SCM+FSA;
  let k be Element of NAT;
  assume k < s.a;
  I9 is paraclosed;
  hence I is_closed_on StepTimes(a,I,s).k by SCMFSA7B:24;
  thus thesis by A1,SCMFSA7B:25;
end;

theorem Th16:
  ProperTimesBody a, J, s implies for k st k <= s.a holds
  StepTimes(a, J, s).k.intloc 0 = 1
proof
  set I = J;
  set ST = StepTimes(a, I, s);
  set au = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  set Is = Initialized s;
  defpred X[Element of NAT] means $1 <= s.a implies ST.$1.intloc 0 = 1;
  assume
A1: ProperTimesBody a, I, s;
A2: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT;
    assume that
A3: k <= s.a implies ST.k.intloc 0 = 1 and
A4: k+1 <= s.a;
    reconsider sa = s.a as Element of NAT by A4,INT_1:16;
A5: k < sa by A4,NAT_1:13;
    then I is_closed_on ST.k & I is_halting_on ST.k by A1,Def3;
    hence thesis by A3,A5,Th12;
  end;
A6: X[0]
  proof
    assume 0 <= s.a;
    thus ST.0.intloc 0 = Exec(au := a, Is).intloc 0 by SCMFSA_9:def 5
      .= Is.intloc 0 by SCMFSA_2:89
      .= 1 by SCMFSA6C:3;
  end;
  thus for k holds X[k] from NAT_1:sch 1(A6, A2);
end;

theorem Th17:
  (s.intloc 0 = 1 or a is read-write) & ProperTimesBody a, J, s
  implies for k st k <= s.a holds StepTimes(a, J, s).k.(1-stRWNotIn({a} \/
  UsedIntLoc J))+k = s.a
proof
  set I = J;
  assume that
A1: s.intloc 0 = 1 or a is read-write and
A2: ProperTimesBody a, I, s;
  set Is = Initialized s;
  set au = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  set ST = StepTimes(a, I, s);
  set SW = StepWhile>0 (au, I ';' SubFrom(au, intloc 0), Exec(au := a, Is));
  defpred X[Nat] means $1 <= s.a implies StepTimes(a, I, s).$1.au+
  $1 = s.a;
A3: for k being Element of NAT st X[k] holds X[k+1]
  proof
    not au in {a} \/ UsedIntLoc I by SFMASTR1:21;
    then
A4: not au in UsedIntLoc I by XBOOLE_0:def 3;
    let k be Element of NAT such that
A5: k <= s.a implies ST.k.au+k = s.a and
A6: k+1 <= s.a;
    reconsider sa = s.a as Element of NAT by A6,INT_1:16;
A7: k < sa by A6,NAT_1:13;
    then
A8: ST.k.intloc 0 = 1 by A2,Th16;
A9: now
      assume SW.k.au <= 0;
      then SW.k.au+k < s.a+0 by A7,XREAL_1:10;
      hence contradiction by A5,A7;
    end;
A10: Macro SubFrom(au, intloc 0) is_closed_on IExec(I, ST.k) by SCMFSA7B:24;
A11: I is_closed_on ST.k by A2,A7,Def3;
    then
A12: I is_closed_on Initialized ST.k by A8,Th4;
    I is_halting_on ST.k by A2,A7,Def3;
    then
A13: I is_halting_on Initialized ST.k by A8,A11,Th5;
    Macro SubFrom(au, intloc 0) is_halting_on IExec(I, ST.k) by SCMFSA7B:25;
    then
    I ';' SubFrom(au, intloc 0) is_halting_on Initialized ST.k by A12,A13,A10,
SFMASTR1:4;
    then
    DataPart SW.(k+1) = DataPart IExec(I ';' SubFrom(au, intloc 0), ST.k)
    by A8,A12,A13,A10,A9,SCMFSA9A:38,SFMASTR1:3;
    then ST.(k+1).au = IExec(I ';' SubFrom(au, intloc 0), ST.k).au by
SCMFSA6A:38
      .= Exec(SubFrom(au, intloc 0), IExec(I, ST.k)).au by A12,A13,SFMASTR1:12
      .= IExec(I, ST.k).au - IExec(I, ST.k).intloc 0 by SCMFSA_2:91
      .= IExec(I, ST.k).au - 1 by A12,A13,SCMFSA8C:96
      .= (Initialized ST.k).au - 1 by A12,A13,A4,Th1
      .= ST.k.au - 1 by SCMFSA6C:3;
    hence thesis by A5,A7;
  end;
A14: a = intloc 0 or a is read-write by SF_MASTR:def 5;
A15: X[0]
  proof
    assume 0 <= s.a;
    thus ST.0.au+0 = Exec(au := a, Is).au by SCMFSA_9:def 5
      .= Is.a by SCMFSA_2:89
      .= s.a by A1,A14,SCMFSA6C:3;
  end;
  thus for k holds X[k] from NAT_1:sch 1(A15, A3);
end;

theorem Th18:
  ProperTimesBody a, J, s & 0 <= s.a & (s.intloc 0 = 1 or a is
read-write) implies for k st k >= s.a holds StepTimes(a, J, s).k.(1-stRWNotIn({
  a} \/ UsedIntLoc J)) = 0 & StepTimes(a, J, s).k.intloc 0 = 1
proof
  set I = J;
  assume that
A1: ProperTimesBody a, I, s and
A2: 0 <= s.a and
A3: s.intloc 0 = 1 or a is read-write;
  set au = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  set ST = StepTimes(a, I, s);
  set SW = StepWhile>0 (au, I ';' SubFrom(au, intloc 0), Exec(au := a,
  Initialized s));
  defpred X[Nat] means $1 >= s.a implies ST.$1.au = 0 & ST.$1.
  intloc 0 = 1;
A4: for k st X[k] holds X[k+1]
  proof
    reconsider sa = s.a as Element of NAT by A2,INT_1:16;
    let k such that
A5: k >= s.a implies ST.k.au = 0 & ST.k.intloc 0 = 1 and
A6: (k+1) >= s.a;
    per cases by A6,XXREAL_0:1;
    suppose
A7:   k+1 = sa;
      then ST.(k+1).au+(k+1) = s.a by A1,A3,Th17;
      hence ST.(k+1).au = 0 by A7;
      thus thesis by A1,A7,Th16;
    end;
    suppose
A8:   k+1 > sa;
      then
A9:   DataPart SW.(k+1) = DataPart SW.k by A5,NAT_1:13,SCMFSA9A:37;
      hence ST.(k+1).au = 0 by A5,A8,NAT_1:13,SCMFSA6A:38;
      thus thesis by A5,A8,A9,NAT_1:13,SCMFSA6A:38;
    end;
  end;
A10: X[0]
  proof
    assume
A11: 0 >= s.a;
    thus ST.0.au = ST.0.au+0
      .= 0 by A1,A2,A3,A11,Th17;
    thus thesis by A1,A2,Th16;
  end;
  thus for k holds X[k] from NAT_1:sch 1(A10, A4);
end;

theorem Th19:
  s.intloc 0 = 1 implies StepTimes(a, I, s).0 | ((UsedIntLoc I) \/
  FinSeq-Locations) = s | ((UsedIntLoc I) \/ FinSeq-Locations)
proof
  set ST = StepTimes(a, I, s);
  set au = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  set Is = Initialized s;
  set UILI = UsedIntLoc I;
  assume s.intloc 0 = 1;
  then
A1: DataPart Initialized s = DataPart s by SCMFSA8C:27;
A2: now
    let x be Int-Location;
A3: not au in {a} \/ UILI by SFMASTR1:21;
    assume x in UILI;
    then
A4: au <> x by A3,XBOOLE_0:def 3;
    thus ST.0.x = Exec(au := a, Is).x by SCMFSA_9:def 5
      .= Is.x by A4,SCMFSA_2:89
      .= s.x by A1,SCMFSA6A:38;
  end;
  now
    let x be FinSeq-Location;
    thus ST.0.x = Exec(au := a, Is).x by SCMFSA_9:def 5
      .= Is.x by SCMFSA_2:89
      .= s.x by SCMFSA6C:3;
  end;
  hence thesis by A2,Th7;
end;

theorem Th20:
  StepTimes(a, J, s).k.intloc 0 = 1 & J is_halting_on Initialized
  StepTimes(a, J, s).k & J is_closed_on Initialized StepTimes(a, J, s).k &
StepTimes(a, J, s).k.(1-stRWNotIn ({a} \/ UsedIntLoc J)) > 0 implies StepTimes(
a, J, s).(k+1) | ((UsedIntLoc J) \/ FinSeq-Locations) = IExec(J, StepTimes(a, J
  , s).k) | ((UsedIntLoc J) \/ FinSeq-Locations)
proof
  set I = J;
  set ST = StepTimes(a, I, s);
  set au = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  set SW = StepWhile>0 (au, I ';' SubFrom(au, intloc 0), Exec(au := a,
  Initialized s));
  set UILI = UsedIntLoc I;
  assume that
A1: ST.k.intloc 0 = 1 and
A2: I is_halting_on Initialized ST.k & I is_closed_on Initialized ST.k and
A3: ST.k.au > 0;
A4: Macro SubFrom(au, intloc 0) is_closed_on IExec(I, ST.k) by SCMFSA7B:24;
  Macro SubFrom(au, intloc 0) is_halting_on IExec(I, ST.k) by SCMFSA7B:25;
  then I ';' SubFrom(au, intloc 0) is_halting_on Initialized ST.k by A2,A4,
SFMASTR1:4;
  then
A5: DataPart SW.(k+1) = DataPart IExec(I ';' SubFrom(au, intloc 0), ST.k) by A1
,A2,A3,A4,SCMFSA9A:38,SFMASTR1:3;
A6: now
    let x be Int-Location;
A7: not au in {a} \/ UILI by SFMASTR1:21;
    assume x in UILI;
    then
A8: au <> x by A7,XBOOLE_0:def 3;
    thus ST.(k+1).x = IExec(I ';' SubFrom(au, intloc 0), ST.k).x by A5,
SCMFSA6A:38
      .= Exec(SubFrom(au, intloc 0), IExec(I, ST.k)).x by A2,SFMASTR1:12
      .= IExec(I, ST.k).x by A8,SCMFSA_2:91;
  end;
  now
    let x be FinSeq-Location;
    thus ST.(k+1).x = IExec(I ';' SubFrom(au, intloc 0), ST.k).x by A5,
SCMFSA6A:38
      .= Exec(SubFrom(au, intloc 0), IExec(I, ST.k)).x by A2,SFMASTR1:13
      .= IExec(I, ST.k).x by SCMFSA_2:91;
  end;
  hence thesis by A6,Th7;
end;

theorem Th21:
  (ProperTimesBody a, J, s or J is parahalting) & k < s.a & (s.
  intloc 0 = 1 or a is read-write) implies StepTimes(a, J, s).(k+1) | ((
  UsedIntLoc J) \/ FinSeq-Locations) = IExec(J, StepTimes(a, J, s).k) | ((
  UsedIntLoc J) \/ FinSeq-Locations)
proof
  set I = J;
  assume that
A1: ProperTimesBody a, I, s or I is parahalting and
A2: k < s.a and
A3: s.intloc 0 = 1 or a is read-write;
  set ST = StepTimes(a, I, s);
A4: ST.k.intloc 0 = 1 by A1,A2,Th15,Th16;
  set au = 1-stRWNotIn ({a} \/ UsedIntLoc I);
A5: ProperTimesBody a, I, s by A1,Th15;
  then
A6: ST.k.au+k = s.a by A2,A3,Th17;
A7: I is_closed_on ST.k by A2,A5,Def3;
  then
A8: I is_closed_on Initialized ST.k by A4,Th4;
A9: k-k < s.a-k by A2,XREAL_1:11;
  I is_halting_on ST.k by A2,A5,Def3;
  then I is_halting_on Initialized ST.k by A4,A7,Th5;
  hence thesis by A4,A8,A6,A9,Th20;
end;

theorem
  s.a <= 0 & s.intloc 0 = 1 implies IExec(times(a, I), s) | ((UsedIntLoc
  I) \/ FinSeq-Locations) = s | ((UsedIntLoc I) \/ FinSeq-Locations)
proof
  set FSL = FinSeq-Locations;
  assume that
A1: s.a <= 0 and
A2: s.intloc 0 = 1;
  set UILI = UsedIntLoc I;
  set au = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  set WH = while>0 ( au, I ';' SubFrom(au, intloc 0) );
  set s1 = Exec(au := a, Initialized s);
A3: a = intloc 0 or a is read-write by SF_MASTR:def 5;
A4: s1 = IExec(Macro (au := a), s) by SCMFSA6C:6;
A5: s1.au = (Initialized s).a by SCMFSA_2:89
    .= s.a by A2,A3,SCMFSA6C:3;
  then
A6: WH is_closed_on IExec(Macro (au := a), s) & WH is_halting_on IExec(Macro
  (au := a), s) by A1,A4,SCMFSA_9:43;
  s1.intloc 0 = (Initialized s).intloc 0 by SCMFSA_2:89
    .= 1 by SCMFSA6C:3;
  then
A7: DataPart IExec(WH, s1) = DataPart s1 by A1,A5,SCMFSA9A:41;
A8: now
    let x be FinSeq-Location;
    assume x in FSL;
    thus IExec(times(a, I), s).x = IExec(WH, s1).x by A4,A6,SFMASTR1:16
      .= s1.x by A7,SCMFSA6A:38
      .= (Initialized s).x by SCMFSA_2:89
      .= s.x by SCMFSA6C:3;
  end;
A9: DataPart s = DataPart Initialized s by A2,SCMFSA8C:27;
A10: now
    let x be Int-Location;
A11: not au in {a} \/ UILI by SFMASTR1:21;
    assume x in UILI;
    then
A12: au <> x by A11,XBOOLE_0:def 3;
    thus IExec(times(a, I), s).x = IExec(WH, s1).x by A4,A6,SFMASTR1:15
      .= s1.x by A7,SCMFSA6A:38
      .= (Initialized s).x by A12,SCMFSA_2:89
      .= s.x by A9,SCMFSA6A:38;
  end;
  [#] FSL = FSL;
  hence thesis by A10,A8,Th6;
end;

theorem Th23:
  s.a = k & (ProperTimesBody a, J, s or J is parahalting) & (s.
  intloc 0 = 1 or a is read-write) implies DataPart IExec(times(a, J), s) =
  DataPart StepTimes(a, J, s).k
proof
  set I = J;
  assume
A1: s.a = k;
  set ST = StepTimes(a, I, s);
  set au = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  set ISu = I ';' SubFrom(au, intloc 0);
  set s1 = Exec(au := a, Initialized s);
  set Is1 = Initialized s1;
  set SW = StepWhile>0(au, ISu, s1);
  set ISW = StepWhile>0(au, ISu, Is1);
  s1.intloc 0 = (Initialized s).intloc 0 by SCMFSA_2:89
    .= 1 by SCMFSA6C:3;
  then
A2: DataPart Is1 = DataPart s1 by SCMFSA8C:27;
  set WH = while>0 ( au, ISu );
  assume
A3: ProperTimesBody a, I, s or I is parahalting;
  then
A4: ProperTimesBody a, I, s by Th15;
  assume
A5: s.intloc 0 = 1 or a is read-write;
A6: ST = SW;
A7: ProperBodyWhile>0 au, ISu, s1
  proof
    let k be Element of NAT;
    assume SW.k.au > 0;
    then
A8: k < s.a by A1,A4,A5,A6,Th18;
    then
A9: ST.k.intloc 0 = 1 by A3,Th15,Th16;
    then
A10: DataPart ST.k = DataPart Initialized (ST.k) by SCMFSA8C:27;
A11: I is_closed_on ST.k by A4,A8,Def3;
    then
A12: I is_closed_on Initialized ST.k by A9,Th4;
    I is_halting_on ST.k by A4,A8,Def3;
    then
A13: I is_halting_on Initialized ST.k by A11,A9,Th5;
A14: Macro SubFrom(au, intloc 0) is_closed_on IExec(I, ST.k) by SCMFSA7B:24;
    then
A15: ISu is_closed_on Initialized ST.k by A12,A13,SFMASTR1:3;
    hence ISu is_closed_on SW.k by A10,SCMFSA8B:6;
    Macro SubFrom(au, intloc 0) is_halting_on IExec(I, ST.k) by SCMFSA7B:25;
    then ISu is_halting_on Initialized ST.k by A12,A13,A14,SFMASTR1:4;
    hence thesis by A10,A15,SCMFSA8B:8;
  end;
  then
A16: DataPart ISW.k = DataPart SW.k by A2,SCMFSA9A:40;
A17: WithVariantWhile>0 au, ISu, Is1
  proof
    reconsider sa = s.a as Element of NAT by A1;
    deffunc U(State of SCM+FSA) = abs($1.au);
    consider f being Function of product the Object-Kind of SCM+FSA,NAT such
    that
B18: for x being Element of product the Object-Kind of SCM+FSA holds f
    .x = U(x) from FUNCT_2:sch 4;
A18: for x being State of SCM+FSA holds f.x = U(x)
     proof let x be State of SCM+FSA;
      reconsider x as Element of product the Object-Kind of SCM+FSA
        by PBOOLE:155;
       f.x = U(x) by B18;
      hence thesis;
     end;
    take f;
    let k be Element of NAT;
    DataPart ISW.k = DataPart SW.k by A2,A7,SCMFSA9A:40;
    then
A19: ISW.k.au = SW.k.au by SCMFSA6A:38;
    DataPart ISW.(k+1) = DataPart SW.(k+1) by A2,A7,SCMFSA9A:40;
    then
A20: ISW.(k+1).au = SW.(k+1).au by SCMFSA6A:38;
    per cases;
    suppose
A21:  k < s.a;
      then
A22:  k-k < s.a-k by XREAL_1:11;
A23:  ST.k.au+k = s.a by A4,A5,A21,Th17;
A24:  k+1 <= sa by A21,NAT_1:13;
      then
A25:  (k+1)-(k+1) <= s.a-(k+1) by XREAL_1:11;
A26:  ST.(k+1).au+(k+1) = s.a by A4,A5,A24,Th17;
      then
A27:  s.a = (ST.(k+1).au+1)+k;
A28:  f.(ISW.(k+1)) = abs( ISW.(k+1).au ) by A18
        .= SW.(k+1).au by A20,A26,A25,ABSVALUE:def 1;
      f.(ISW.k) = abs( ISW.k.au ) by A18
        .= SW.k.au by A19,A23,A22,ABSVALUE:def 1;
      hence thesis by A23,A27,A28,NAT_1:13;
    end;
    suppose
      k >= s.a;
      hence thesis by A1,A4,A5,A6,A19,Th18;
    end;
  end;
A29: ProperBodyWhile>0 au, ISu, Is1
  proof
    let k be Element of NAT;
    assume
A30: ISW.k.au > 0;
A31: DataPart ISW.k = DataPart SW.k by A2,A7,SCMFSA9A:40;
    then
A32: SW.k.au = ISW.k.au by SCMFSA6A:38;
    then
A33: ISu is_closed_on SW.k by A7,A30,SCMFSA9A:def 4;
    hence ISu is_closed_on ISW.k by A31,SCMFSA8B:6;
    ISu is_halting_on SW.k by A7,A30,A32,SCMFSA9A:def 4;
    hence thesis by A31,A33,SCMFSA8B:8;
  end;
  then consider K being Element of NAT such that
A34: ExitsAtWhile>0(au, ISu, Is1) = K and
A35: ISW.K.au <= 0 and
A36: for i being Element of NAT st ISW.i.au <= 0 holds K <= i and
  DataPart Comput(ProgramPart((Is1 +* (WH +* SAt))),(Is1 +* (WH +* SAt)),(
LifeSpan(ProgramPart(Is1 +* (WH +* SAt)),Is1 +* (WH +* SAt))
  )) = DataPart ISW.K by A17,SCMFSA9A:def 6;
A37: WH is_closed_on Is1 by A29,A17,SCMFSA9A:33;
  WH is_halting_on Is1 by A29,A17,SCMFSA9A:33;
  then
A38: WH is_halting_on s1 by A2,A37,SCMFSA8B:8;
A39: DataPart IExec(WH, s1) = DataPart ISW.ExitsAtWhile>0(au, ISu, Is1) by A29
,A17,SCMFSA9A:42;
A40: DataPart ISW.K = DataPart SW.K by A2,A7,SCMFSA9A:40;
  SW.k.au = 0 by A1,A4,A5,A6,Th18;
  then ISW.k.au = 0 by A16,SCMFSA6A:38;
  then
A41: K <= k by A36;
  then
A42: SW.K.au+K = k by A1,A4,A5,A6,Th17;
  K-K <= k-K by A41,XREAL_1:11;
  then
A43: ISW.K.au = 0 by A35,A40,A42,SCMFSA6A:38;
A44: ISW.K.au+K = k by A40,A42,SCMFSA6A:38;
  now
    hereby
      let x be Int-Location;
      thus IExec(times(a, I), s).x = IExec(WH, s1).x by A2,A37,A38,SCMFSA8B:6
,SFMASTR1:15
        .= ST.k.x by A39,A34,A16,A44,A43,SCMFSA6A:38;
    end;
    let x be FinSeq-Location;
    thus IExec(times(a, I), s).x = IExec(WH, s1).x by A2,A37,A38,SCMFSA8B:6
,SFMASTR1:16
      .= ST.k.x by A39,A34,A16,A44,A43,SCMFSA6A:38;
  end;
  hence thesis by SCMFSA6A:38;
end;

theorem Th24:
  s.intloc 0 = 1 & (ProperTimesBody a, J, s or J is parahalting)
  implies times(a, J) is_closed_on s & times(a, J) is_halting_on s
proof
  set I = J;
  assume
A1: s.intloc 0 = 1;
  set taI = times(a, I);
  set ST = StepTimes(a, I, s);
  set au = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  set ISu = I ';' SubFrom(au, intloc 0);
  set WH = while>0 ( au, ISu );
  set s1 = Exec(au := a, Initialized s);
  set Is1 = Initialized s1;
  set SW = StepWhile>0(au, ISu, s1);
  set ISW = StepWhile>0(au, ISu, Is1);
A2: ST = SW;
A3: s1 = IExec(Macro (au := a), s) & Macro(au := a) is_closed_on Initialized
  s by SCMFSA6C:6,SCMFSA7B:24;
  s1.intloc 0 = (Initialized s).intloc 0 by SCMFSA_2:89
    .= 1 by SCMFSA6C:3;
  then
A4: DataPart Is1 = DataPart s1 by SCMFSA8C:27;
  assume
A5: ProperTimesBody a, I, s or I is parahalting;
  then
A6: ProperTimesBody a, I, s by Th15;
A7: Macro(au := a) is_halting_on Initialized s by SCMFSA7B:25;
  per cases;
  suppose
A8: s.a < 0;
A9: a = intloc 0 or a is read-write by SF_MASTR:def 5;
A10: s1.au = (Initialized s).a by SCMFSA_2:89
      .= s.a by A1,A9,SCMFSA6C:3;
    then
A11: WH is_closed_on s1 by A8,SCMFSA_9:43;
    then
A12: taI is_closed_on Initialized s by A3,A7,SFMASTR1:3;
    hence times(a, I) is_closed_on s by A1,Th4;
    WH is_halting_on s1 by A8,A10,SCMFSA_9:43;
    then taI is_halting_on Initialized s by A3,A7,A11,SFMASTR1:4;
    hence thesis by A1,A12,Th5;
  end;
  suppose
A13: 0 <= s.a;
A14: ProperBodyWhile>0 au, ISu, s1
    proof
      let k be Element of NAT;
      assume SW.k.au > 0;
      then
A15:  k < s.a by A1,A6,A2,A13,Th18;
      then
A16:  ST.k.intloc 0 = 1 by A5,Th15,Th16;
      then
A17:  DataPart ST.k = DataPart Initialized (ST.k) by SCMFSA8C:27;
A18:  I is_closed_on ST.k by A6,A15,Def3;
      then
A19:  I is_closed_on Initialized ST.k by A16,Th4;
      I is_halting_on ST.k by A6,A15,Def3;
      then
A20:  I is_halting_on Initialized ST.k by A18,A16,Th5;
A21:  Macro SubFrom(au, intloc 0) is_closed_on IExec(I, ST.k) by SCMFSA7B:24;
      then
A22:  ISu is_closed_on Initialized ST.k by A19,A20,SFMASTR1:3;
      hence ISu is_closed_on SW.k by A17,SCMFSA8B:6;
      Macro SubFrom(au, intloc 0) is_halting_on IExec(I, ST.k) by SCMFSA7B:25;
      then ISu is_halting_on Initialized ST.k by A19,A20,A21,SFMASTR1:4;
      hence thesis by A17,A22,SCMFSA8B:8;
    end;
A23: WithVariantWhile>0 au, ISu, Is1
    proof
      reconsider sa = s.a as Element of NAT by A13,INT_1:16;
      deffunc U(State of SCM+FSA) = abs($1.au);
      consider f being Function of product the Object-Kind of SCM+FSA,NAT such
      that
B24:  for x being Element of product the Object-Kind of SCM+FSA holds
      f.x = U(x) from FUNCT_2:sch 4;
A24: for x being State of SCM+FSA holds f.x = U(x)
     proof let x be State of SCM+FSA;
      reconsider x as Element of product the Object-Kind of SCM+FSA
        by PBOOLE:155;
       f.x = U(x) by B24;
      hence thesis;
     end;
      take f;
      let k be Element of NAT;
      DataPart ISW.k = DataPart SW.k by A4,A14,SCMFSA9A:40;
      then
A25:  ISW.k.au = SW.k.au by SCMFSA6A:38;
      DataPart ISW.(k+1) = DataPart SW.(k+1) by A4,A14,SCMFSA9A:40;
      then
A26:  ISW.(k+1).au = SW.(k+1).au by SCMFSA6A:38;
      per cases;
      suppose
A27:    k < s.a;
        then
A28:    k-k < s.a-k by XREAL_1:11;
A29:    ST.k.au+k = s.a by A1,A6,A27,Th17;
A30:    k+1 <= sa by A27,NAT_1:13;
        then
A31:    (k+1)-(k+1) <= s.a-(k+1) by XREAL_1:11;
A32:    ST.(k+1).au+(k+1) = s.a by A1,A6,A30,Th17;
        then
A33:    s.a = (ST.(k+1).au+1)+k;
A34:    f.(ISW.(k+1)) = abs( ISW.(k+1).au ) by A24
          .= SW.(k+1).au by A26,A32,A31,ABSVALUE:def 1;
        f.(ISW.k) = abs( ISW.k.au ) by A24
          .= SW.k.au by A25,A29,A28,ABSVALUE:def 1;
        hence thesis by A29,A33,A34,NAT_1:13;
      end;
      suppose
        k >= s.a;
        hence thesis by A1,A6,A2,A13,A25,Th18;
      end;
    end;
A35: ProperBodyWhile>0 au, ISu, Is1
    proof
      let k be Element of NAT;
      assume
A36:  ISW.k.au > 0;
A37:  DataPart ISW.k = DataPart SW.k by A4,A14,SCMFSA9A:40;
      then
A38:  SW.k.au = ISW.k.au by SCMFSA6A:38;
      then
A39:  ISu is_closed_on SW.k by A14,A36,SCMFSA9A:def 4;
      hence ISu is_closed_on ISW.k by A37,SCMFSA8B:6;
      ISu is_halting_on SW.k by A14,A36,A38,SCMFSA9A:def 4;
      hence thesis by A37,A39,SCMFSA8B:8;
    end;
    then
A40: WH is_closed_on s1 by A4,A23,SCMFSA8B:6,SCMFSA9A:33;
    then
A41: taI is_closed_on Initialized s by A3,A7,SFMASTR1:3;
    hence times(a, I) is_closed_on s by A1,Th4;
    WH is_closed_on Is1 & WH is_halting_on Is1 by A35,A23,SCMFSA9A:33;
    then WH is_halting_on s1 by A4,SCMFSA8B:8;
    then taI is_halting_on Initialized s by A3,A7,A40,SFMASTR1:4;
    hence thesis by A1,A41,Th5;
  end;
end;

begin :: A trivial example

definition
  let d be read-write Int-Location;
  func triv-times(d) -> Program of SCM+FSA equals
  times( d, while=0(d, Macro(d
  := d)) ';' SubFrom(d, intloc 0) );
  correctness;
end;

theorem
  s.d <= 0 implies IExec(triv-times(d), s).d = s.d
proof
  set a = d;
  assume
A1: s.a <= 0;
  set I = while=0(a, Macro(a := a)) ';' SubFrom(a, intloc 0);
  set au = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  set WH = while>0 ( au, I ';' SubFrom(au, intloc 0) );
  set s1 = Exec(au := a, Initialized s);
A2: s1.au = (Initialized s).a by SCMFSA_2:89
    .= s.a by SCMFSA6C:3;
  a in {a} by TARSKI:def 1;
  then a in {a} \/ UsedIntLoc I by XBOOLE_0:def 3;
  then
A3: au <> a by SFMASTR1:21;
  s1.intloc 0 = (Initialized s).intloc 0 by SCMFSA_2:89
    .= 1 by SCMFSA6C:3;
  then
A4: DataPart IExec(WH, s1) = DataPart s1 by A1,A2,SCMFSA9A:41;
A5: s1 = IExec(Macro (au := a), s) by SCMFSA6C:6;
  then
  WH is_closed_on IExec(Macro (au := a), s) & WH is_halting_on IExec(Macro
  (au := a), s) by A1,A2,SCMFSA_9:43;
  hence IExec(triv-times(a), s).a = IExec(WH, s1).a by A5,SFMASTR1:15
    .= s1.a by A4,SCMFSA6A:38
    .= (Initialized s).a by A3,SCMFSA_2:89
    .= s.a by SCMFSA6C:3;
end;

theorem
  0 <= s.d implies IExec(triv-times(d), s).d = 0
proof
  set a = d;
  set I1 = while=0(a, Macro(a := a));
  set i2 = SubFrom(a, intloc 0);
  set I = I1 ';' i2;
  set au = 1-stRWNotIn ({a} \/ UsedIntLoc I);
  set ST = StepTimes(a, I, s);
  defpred X[Nat] means ($1 < s.a implies I is_closed_on ST.$1 & I
is_halting_on ST.$1 & ST.$1.intloc 0 = 1) & ($1 <= s.a implies ST.$1.a+$1 = s.a
  & ST.$1.au = ST.$1.a);
  a in {a, intloc 0} by TARSKI:def 2;
  then a in UsedIntLoc SubFrom(a, intloc 0) by SF_MASTR:18;
  then a in (UsedIntLoc while=0(a, Macro(a := a))) \/ UsedIntLoc SubFrom(a,
  intloc 0) by XBOOLE_0:def 3;
  then
A1: a in UsedIntLoc I by SF_MASTR:34;
A2: for k st X[k] holds X[k+1]
  proof
    let k;
    assume that
A3: k < s.a implies I is_closed_on ST.k & I is_halting_on ST.k & ST.k
    .intloc 0 = 1 and
A4: k <= s.a implies ST.k.a+k = s.a & ST.k.au = ST.k.a;
A5: now
      assume
A6:   k < s.a;
      then
A7:   ST.k.a <> 0 by A4;
      then
A8:   DataPart IExec(I1, ST.k) = DataPart ST.k by A3,A6,SCMFSA9A:28;
A9:   I1 is_closed_on ST.k by A7,SCMFSA_9:18;
      then
A10:  I1 is_closed_on Initialized ST.k by A3,A6,Th4;
      I1 is_halting_on ST.k by A7,SCMFSA_9:18;
      then
A11:  I1 is_halting_on Initialized ST.k by A3,A6,A9,Th5;
A12:  k-k < s.a-k by A6,XREAL_1:11;
      hence ST.k.au > 0 by A4,A6;
      I is_closed_on Initialized ST.k & I is_halting_on Initialized ST.k
      by A3,A6,Th5;
      then ST.(k+1) | ((UsedIntLoc I) \/ FinSeq-Locations) = IExec(I, ST.k) |
      ((UsedIntLoc I) \/ FinSeq-Locations) by A3,A4,A6,A12,Th20;
      then ST.(k+1).a = IExec(I, ST.k).a by A1,Th7
        .= Exec(i2, IExec(I1, ST.k)).a by A10,A11,SFMASTR1:12
        .= IExec(I1, ST.k).a - IExec(I1, ST.k).intloc 0 by SCMFSA_2:91
        .= ST.k.a - IExec(I1, ST.k).intloc 0 by A8,SCMFSA6A:38
        .= ST.k.a - 1 by A3,A6,A8,SCMFSA6A:38;
      hence ST.(k+1).a+(k+1) = s.a by A4,A6;
    end;
    hereby
      assume
A13:  k+1 < s.a;
      then reconsider sa = s.a as Element of NAT by INT_1:16;
A14:  k < sa by A13,NAT_1:12;
      then
A15:  ST.(k+1).intloc 0 = 1 by A3,Th12;
A16:  ST.(k+1).a <> 0 by A5,A13,A14;
      then
A17:  I1 is_closed_on ST.(k+1) by SCMFSA_9:18;
A18:  Macro i2 is_closed_on IExec(I1, ST.(k+1)) by SCMFSA7B:24;
      I1 is_halting_on ST.(k+1) by A16,SCMFSA_9:18;
      then
A19:  I1 is_halting_on Initialized ST.(k+1) by A15,A17,Th5;
A20:  I1 is_closed_on Initialized ST.(k+1) by A15,A17,Th4;
      then
A21:  I is_closed_on Initialized ST.(k+1) by A19,A18,SFMASTR1:3;
      hence I is_closed_on ST.(k+1) by A15,Th4;
      Macro i2 is_halting_on IExec(I1, ST.(k+1)) by SCMFSA7B:25;
      then I is_halting_on Initialized ST.(k+1) by A19,A20,A18,SFMASTR1:4;
      hence I is_halting_on ST.(k+1) by A15,A21,Th5;
      thus ST.(k+1).intloc 0 =1 by A3,A14,Th12;
    end;
A22: k < k+1 by NAT_1:13;
    assume
A23: k+1 <= s.a;
    hence ST.(k+1).a+(k+1) = s.a by A5,A22,XXREAL_0:2;
    ST.(k+1).au = ST.k.a - 1 by A3,A4,A5,A23,A22,Th12,XXREAL_0:2;
    hence thesis by A4,A5,A23,A22,XXREAL_0:2;
  end;
A24: X[0]
  proof
    hereby
      assume 0 < s.a;
      then
A25:  ST.0.a <> 0 by Th13;
      then
A26:  I1 is_closed_on ST.0 by SCMFSA_9:18;
A27:  Macro i2 is_closed_on IExec(I1, ST.0) by SCMFSA7B:24;
A28:  ST.0.intloc 0 = 1 by Th10;
      I1 is_halting_on ST.0 by A25,SCMFSA_9:18;
      then
A29:  I1 is_halting_on Initialized ST.0 by A28,A26,Th5;
A30:  I1 is_closed_on Initialized ST.0 by A28,A26,Th4;
      then
A31:  I is_closed_on Initialized ST.0 by A29,A27,SFMASTR1:3;
      hence I is_closed_on ST.0 by A28,Th4;
      Macro i2 is_halting_on IExec(I1, ST.0) by SCMFSA7B:25;
      then I is_halting_on Initialized ST.0 by A29,A30,A27,SFMASTR1:4;
      hence I is_halting_on ST.0 by A28,A31,Th5;
      thus ST.0.intloc 0 = 1 by Th10;
    end;
    assume 0 <= s.a;
    thus ST.0.a+0 = s.a by Th13;
    ST.0.a = s.a by Th13;
    hence thesis by Th11;
  end;
A32: for k holds X[k] from NAT_1:sch 1(A24, A2);
A33: ProperTimesBody a, I, s
  proof
    let k;
    thus thesis by A32;
  end;
  assume 0 <= s.a;
  then reconsider k = s.a as Element of NAT by INT_1:16;
A34: StepTimes(a, I, s).k.a+k = s.a by A32;
  DataPart IExec(times(a, I), s) = DataPart StepTimes(a, I, s).k by A33,Th23;
  hence thesis by A34,SCMFSA6A:38;
end;

begin :: A macro for the Fibonacci sequence

definition
  let N, result be Int-Location;
  func Fib-macro (N, result) -> Program of SCM+FSA equals
  (1-stNotUsed times(N
  , AddTo(result, (1-stRWNotIn {N, result}))';' swap(result, 1-stRWNotIn {N,
result}))) := N ';' (SubFrom(result, result)) ';' ((1-stRWNotIn {N, result}) :=
intloc 0) ';' times(N, AddTo(result, (1-stRWNotIn {N, result})) ';' swap(result
, (1-stRWNotIn {N, result})) ) ';' (N := (1-stNotUsed times(N, AddTo(result, 1
  -stRWNotIn {N, result})';' swap(result, 1-stRWNotIn {N, result}))));
  correctness;
end;

theorem
  for N, result being read-write Int-Location st N <> result for n being
Element of NAT st n = s.N holds IExec(Fib-macro(N, result), s).result = Fib n &
  IExec(Fib-macro(N, result), s).N = s.N
proof
  let N, result be read-write Int-Location such that
A1: N <> result;
  let n be Element of NAT;
  set i1 = SubFrom(result, result);
  set next = 1-stRWNotIn {N, result};
  set Nsave = 1-stNotUsed times(N, AddTo(result, next)';'swap(result, next));
  set i0 = Nsave := N;
  set i2 = next := intloc 0;
  set i30 = AddTo (result, next);
  set I31 = swap(result, next);
  set I301 = i30 ';' I31;
  set i02 = i0 ';' i1 ';' i2;
  set s1 = IExec(i02, s);
  set I3 = times( N, I301 );
  set ST = StepTimes(N, I301, s1);
  assume
A2: n = s.N;
A3: not next in {N, result} by SFMASTR1:21;
  then
A4: next <> N by TARSKI:def 2;
A5: {N} \/ UsedIntLoc I301 c= UsedIntLoc I3 by Th8;
A6: Nsave = 1-stRWNotIn UsedIntLoc I3 by SFMASTR1:def 4;
  then
A7: not Nsave in UsedIntLoc I3 by SFMASTR1:21;
  N in {N} by TARSKI:def 1;
  then N in {N} \/ UsedIntLoc I301 by XBOOLE_0:def 3;
  then
A8: Nsave <> N by A6,A5,SFMASTR1:21;
A9: s1.N = Exec(i2, IExec(i0 ';' i1, s)).N by SCMFSA6C:7
    .= IExec(i0 ';' i1, s).N by A4,SCMFSA_2:89
    .= Exec(i1, Exec(i0, Initialized s)).N by SCMFSA6C:9
    .= Exec(i0, Initialized s).N by A1,SCMFSA_2:91
    .= (Initialized s).N by A8,SCMFSA_2:89
    .= s.N by SCMFSA6C:3;
  then
A10: DataPart IExec(I3, s1) = DataPart ST.n by A2,Th23;
  defpred P[Nat] means $1 <= s1.N implies ST.$1.result = Fib $1 &
  ST.$1.next = Fib ($1+1);
  set UIFS = UsedIntLoc I301 \/ FinSeq-Locations;
  set i4 = N := Nsave;
A11: UsedIntLoc I301 = (UsedIntLoc i30) \/ UsedIntLoc I31 by SF_MASTR:33
    .= {result, next} \/ UsedIntLoc I31 by SF_MASTR:18;
  next in {result, next} by TARSKI:def 2;
  then
A12: next in UsedIntLoc I301 by A11,XBOOLE_0:def 3;
  then next in {N} \/ UsedIntLoc I301 by XBOOLE_0:def 3;
  then
A13: Nsave <> next by A6,A5,SFMASTR1:21;
  result in {result, next} by TARSKI:def 2;
  then
A14: result in UsedIntLoc I301 by A11,XBOOLE_0:def 3;
  then result in {N} \/ UsedIntLoc I301 by XBOOLE_0:def 3;
  then
A15: Nsave <> result by A6,A5,SFMASTR1:21;
A16: next <> result by A3,TARSKI:def 2;
A17: now
    let k be Element of NAT such that
A18: P[k];
    thus P[k+1]
    proof
A19:  k < k+1 by NAT_1:13;
      assume
A20:  k+1 <= s1.N;
      then k < s1.N by A19,XXREAL_0:2;
      then
A21:  ST.(k+1) | UIFS = IExec(I301, ST.k) | UIFS by Th21;
      hence ST.(k+1).result = IExec(I301, ST.k).result by A14,Th7
        .= IExec(I31, Exec(i30, Initialized ST.k)).result by SCMFSA8B:12
        .= Exec(i30, Initialized ST.k).next by SCMFSA6C:11
        .= (Initialized ST.k).next by A16,SCMFSA_2:90
        .= Fib (k+1) by A18,A20,A19,SCMFSA6C:3,XXREAL_0:2;
      thus ST.(k+1).next = IExec(I301, ST.k).next by A12,A21,Th7
        .= IExec(I31, Exec(i30, Initialized ST.k)).next by SCMFSA8B:12
        .= Exec(i30, Initialized ST.k).result by SCMFSA6C:11
        .= (Initialized ST.k).result + (Initialized ST.k).next by SCMFSA_2:90
        .= ST.k.result + (Initialized ST.k).next by SCMFSA6C:3
        .= ST.k.result + ST.k.next by SCMFSA6C:3
        .= Fib ((k+1)+1) by A18,A20,A19,PRE_FF:1,XXREAL_0:2;
    end;
  end;
A22: s1.Nsave = Exec(i2, IExec(i0 ';' i1, s)).Nsave by SCMFSA6C:7
    .= IExec(i0 ';' i1, s).Nsave by A13,SCMFSA_2:89
    .= Exec(i1, Exec(i0, Initialized s)).Nsave by SCMFSA6C:9
    .= Exec(i0, Initialized s).Nsave by A15,SCMFSA_2:91
    .= (Initialized s).N by SCMFSA_2:89
    .= s.N by SCMFSA6C:3;
A23: i02 is_halting_on Initialized s & i02 is_closed_on Initialized s by
SCMFSA7B:24,25;
  reconsider i02 as good Program of SCM+FSA;
A24: s1.next = Exec(i2, IExec(i0 ';' i1, s)).next by SCMFSA6C:7
    .= IExec(i0 ';' i1, s).intloc 0 by SCMFSA_2:89
    .= Exec(i1, Exec(i0, Initialized s)).intloc 0 by SCMFSA6C:9
    .= Exec(i0, Initialized s).intloc 0 by SCMFSA_2:91
    .= (Initialized s).intloc 0 by SCMFSA_2:89
    .= Fib (0+1) by PRE_FF:1,SCMFSA6C:3;
A25: s1.intloc 0 = Exec(i2, IExec(i0 ';' i1, s)).intloc 0 by SCMFSA6C:7
    .= IExec(i0 ';' i1, s).intloc 0 by SCMFSA_2:89
    .= Exec(i1, Exec(i0, Initialized s)).intloc 0 by SCMFSA6C:9
    .= Exec(i0, Initialized s).intloc 0 by SCMFSA_2:91
    .= (Initialized s).intloc 0 by SCMFSA_2:89
    .= 1 by SCMFSA6C:3;
  then
A26: I3 is_closed_on s1 by Th24;
A27: s1.result = Exec(i2, IExec(i0 ';' i1, s)).result by SCMFSA6C:7
    .= IExec(i0 ';' i1, s).result by A16,SCMFSA_2:89
    .= Exec(i1, Exec(i0, Initialized s)).result by SCMFSA6C:9
    .= Exec(i0,Initialized s).result-Exec(i0, Initialized s).result by
SCMFSA_2:91
    .= Fib 0 by PRE_FF:1;
A28: P[0]
  proof
    assume 0 <= s1.N;
A29: ST.0 | UIFS = s1 | UIFS by A25,Th19;
    hence ST.0.result = Fib 0 by A14,A27,Th7;
    thus thesis by A12,A24,A29,Th7;
  end;
A30: for n being Element of NAT holds P[n] from NAT_1:sch 1(A28, A17);
A31: I3 is_halting_on s1 by A25,Th24;
  then
A32: I3 is_closed_on Initialized s1 & I3 is_halting_on Initialized s1
by A25,A26,Th5;
A33: i02 ';' I3 is_closed_on Initialized s by A26,A23,SFMASTR1:3;
  hence
  IExec(Fib-macro(N, result), s).result = Exec(i4, IExec(i02 ';' I3, s)).
  result by A26,A31,A23,SFMASTR1:4,12
    .= IExec( i02 ';' I3, s).result by A1,SCMFSA_2:89
    .= IExec(I3, s1).result by A26,A31,SFMASTR1:8
    .= ST.n.result by A10,SCMFSA6A:38
    .= Fib n by A9,A30,A2;
  thus IExec(Fib-macro(N, result), s).N = Exec(i4, IExec(i02 ';' I3, s)).N by
A26,A31,A23,A33,SFMASTR1:4,12
    .= IExec( i02 ';' I3, s).Nsave by SCMFSA_2:89
    .= IExec(I3, s1).Nsave by A26,A31,SFMASTR1:8
    .= s.N by A7,A22,A32,Th3;
end;

