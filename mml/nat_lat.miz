:: The Lattice of Natural Numbers and The Sublattice of it.
:: The Set of Prime Numbers
::  by Marek Chmur
::
:: Received April 26, 1991
:: Copyright (c) 1991 Association of Mizar Users

environ

 vocabularies ARYTM_3, QC_LANG1, BINOP_1, FUNCT_1, LATTICES, ARYTM, RELAT_1,
      BOOLE, NAT_LAT, REALSET1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XREAL_0,
      REALSET1, STRUCT_0,
      NAT_1, LATTICES, BINOP_1, RELAT_1, FUNCT_1;
 constructors NAT_1, LATTICES, BINOP_1, NEWTON, PARTFUN1, MEMBERED, REALSET1;
 registrations FINSET_1, STRUCT_0, RELSET_1, LATTICES, NAT_1, MEMBERED,
      ORDINAL2;
 requirements REAL, NUMERALS, SUBSET, BOOLE;
 definitions LATTICES, BINOP_1, REALSET1;
 theorems NEWTON, ZFMISC_1, LATTICES, BINOP_1, FUNCT_1, FUNCT_2, XBOOLE_1,
      RELAT_1;
 schemes BINOP_1, BINOP_2, SUBSET_1;

begin :: Auxiliary Theorems

 reserve n,m,l,k,i,j,s,r,t for Nat;

definition
 canceled 2;

 func hcflat-> BinOp of NAT means
 :Def3: it.(m,n)=m hcf n;
 existence proof
   deffunc O(Nat,Nat)= $1 hcf $2;
  thus ex o being BinOp of NAT st
    for a,b being Element of NAT holds o.(a,b) = O(a,b) from BINOP_1:sch 4;
 end;
 uniqueness proof
    deffunc O(Nat,Nat)= $1 hcf $2;
  thus for o1,o2 being BinOp of NAT st
    (for a,b being Element of NAT holds o1.(a,b) = O(a,b)) &
    (for a,b being Element of NAT holds o2.(a,b) = O(a,b))
  holds o1 = o2 from BINOP_2:sch 2;
 end;

 func lcmlat-> BinOp of NAT means
 :Def4: it.(m,n)=m lcm n;
 existence proof
   deffunc O(Nat,Nat)= $1 lcm $2;
  thus ex o being BinOp of NAT st
    for a,b being Element of NAT holds o.(a,b) = O(a,b) from BINOP_1:sch 4;
 end;
 uniqueness proof
    deffunc O(Nat,Nat)= $1 lcm $2;
  thus for o1,o2 being BinOp of NAT st
    (for a,b being Element of NAT holds o1.(a,b) = O(a,b)) &
    (for a,b being Element of NAT holds o2.(a,b) = O(a,b))
  holds o1 = o2 from BINOP_2:sch 2;
 end;
end;

 reserve p,q,r for Element of LattStr (# NAT, lcmlat, hcflat #);

definition let m be Element of LattStr (# NAT, lcmlat, hcflat #);
  func @m -> Nat equals
  m;
  coherence;
end;

canceled 47;

theorem
Th48: p"\/"q =@p lcm @q by Def4;

theorem
Th49: p"/\"q = @p hcf @q by Def3;

Lm1:
 for a,b being Element of LattStr (# NAT, lcmlat, hcflat #)
       holds a"\/"b = b"\/"a
 proof
  let a,b be Element of LattStr (# NAT, lcmlat, hcflat #);
  thus a"\/"b = @a lcm @b by Th48
           .= b"\/"a by Th48;
 end;

Lm2:
 for a,b being Element of LattStr (# NAT, lcmlat, hcflat #)
      holds a"/\"b = b"/\"a
 proof
  let a,b be Element of LattStr (# NAT, lcmlat, hcflat #);
  thus a"/\"b = @a hcf @b by Th49
           .= b"/\"a by Th49;
 end;

Lm3:
 for a,b,c being Element of LattStr (# NAT, lcmlat, hcflat #)
      holds a"/\"(b"/\"c) = (a"/\"b)"/\"c
 proof
  let a,b,c be Element of LattStr (# NAT, lcmlat, hcflat #);
  set l=b"/\"c;
  set k=a"/\"b;
  A1:(@b hcf @c)=l & @l=l by Th49;
  A2:@a hcf @b=k & @k=k by Th49;
  thus a"/\"(b"/\"c) = @a hcf (@b hcf @c) by A1,Th49
                .= @k hcf @c by A2,NEWTON:61
                .= (a"/\"b)"/\"c by Th49;
 end;

Lm4:
 for a,b,c being Element of LattStr (# NAT, lcmlat, hcflat #)
      holds a"\/"(b"\/"c) = (a"\/"b)"\/"c
 proof
  let a,b,c be Element of LattStr (# NAT, lcmlat, hcflat #);
  set l=b"\/"c;
  set k=a"\/"b;
  A1:(@b lcm @c)=l & @l=l by Th48;
  A2:@a lcm @b=k & @k=k by Th48;
  thus a"\/"(b"\/"c) = @a lcm (@b lcm @c) by A1,Th48
                .= @k lcm @c by A2,NEWTON:56
                .= (a"\/"b)"\/"c by Th48;
 end;

Lm5:
 for a,b being Element of LattStr (# NAT, lcmlat, hcflat #)
      holds (a"/\"b)"\/"b = b
 proof
 let a,b be Element of LattStr (# NAT, lcmlat, hcflat #);
  set k=a"/\"b;
      @a hcf @b=k & @k=k by Th49;
 hence (a"/\"b)"\/"b = (@a hcf @b) lcm @b by Th48
               .= b by NEWTON:66;
end;

Lm6:
 for a,b being Element of LattStr (# NAT, lcmlat, hcflat #)
      holds a"/\"(a"\/"b) = a
 proof
  let a,b be Element of LattStr (# NAT, lcmlat, hcflat #);
  set l=a"\/"b;
      @a lcm @b=l & @l=l by Th48;
  hence a"/\"(a"\/"b) = @a hcf (@a lcm @b) by Th49
                .= a by NEWTON:67;
 end;

canceled 2;

theorem
  for a,b being Element of LattStr (# NAT, lcmlat, hcflat #) st
    a[=b holds @a divides @b
proof
  let a,b be Element of LattStr (# NAT, lcmlat, hcflat #);
  assume a[=b;
  then a"\/"b=b by LATTICES:def 3;
  then @a lcm @b = b by Th48;
  then @a lcm @b = @b;
  hence thesis by NEWTON:57;
end;

definition
  func 0_NN -> Element of LattStr (# NAT, lcmlat, hcflat #) equals
    1;
  coherence;

  func 1_NN -> Element of LattStr (# NAT, lcmlat, hcflat #) equals
    0;
  coherence;
end;

canceled 2;

theorem Th55:
  @0_NN=1;

theorem Th56:
  for a being Element of LattStr (# NAT, lcmlat, hcflat #) holds
    0_NN"/\"a = 0_NN & a"/\"0_NN = 0_NN
proof let a be Element of LattStr (# NAT, lcmlat, hcflat #);
  thus 0_NN"/\"a = 1 hcf @a by Th49,Th55
              .= 0_NN by NEWTON:64;
  thus a"/\"0_NN = @a hcf 1 by Th49,Th55
              .= 0_NN by NEWTON:64;
end;

definition
  func Nat_Lattice -> Lattice equals
  LattStr (# NAT, lcmlat, hcflat #);
  coherence
  proof
     LattStr (# NAT, lcmlat, hcflat #) is Lattice-like
     proof
      thus (for p,q holds p"\/"q = q"\/"p) &
      (for p,q,r holds p"\/"(q"\/"r) = (p"\/"q)"\/"r) &
      (for p,q holds (p"/\"q)"\/"q = q) &
      (for p,q holds p"/\"q = q"/\"p) &
      (for p,q,r holds p"/\"(q"/\"r) = (p"/\"q)"/\"r) &
      (for p,q holds p"/\"(p"\/"q) = p) by Lm1,Lm2,Lm3,Lm4,Lm5,Lm6;
     end;
   hence thesis;
  end;
end;

registration
  cluster Nat_Lattice -> strict;
  coherence;
end;

 reserve p,q,r for Element of Nat_Lattice;

canceled 3;

theorem
  Nat_Lattice is 0_Lattice by Th56,LATTICES:def 13;

theorem Th61:
  lcmlat.(p,q)=lcmlat.(q,p)
proof
  thus lcmlat.(p,q)=q"\/"p by LATTICES:def 1
                  .=lcmlat.(q,p);
end;

theorem Th62:
  hcflat.(q,p)=hcflat.(p,q)
proof
  thus hcflat.(q,p)=p"/\"q by LATTICES:def 2
                  .=hcflat.(p,q);
end;

theorem Th63:
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(p,q),r)
proof
 set s=q"\/"r;
 thus lcmlat.(p,lcmlat.(q,r))=lcmlat.(p,s)
                       .=p"\/"s
                       .=(p"\/"q)"\/"r by Lm4
                       .=lcmlat.((p"\/"q),r)
                       .=lcmlat.(lcmlat.(p,q),r);
end;

theorem
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(q,p),r) &
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(p,r),q) &
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(r,q),p) &
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(r,p),q)
proof
set s=r"\/"q;
thus lcmlat.(p,lcmlat.(q,r)) =lcmlat.(lcmlat.(p,q),r) by Th63
                       .= lcmlat.(lcmlat.(q,p),r) by Th61;
thus A1:lcmlat.(p,lcmlat.(q,r)) = lcmlat.(p,lcmlat.(r,q)) by Th61
                       .=lcmlat.(lcmlat.(p,r),q) by Th63;
thus lcmlat.(p,lcmlat.(q,r)) = lcmlat.(p,s) by LATTICES:def 1
                       .=lcmlat.(s,p) by Th61
                       .=lcmlat.(lcmlat.(r,q),p);
thus lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(r,p),q) by A1,Th61;
end;

theorem Th65:
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(p,q),r)
proof
 set s=q"/\"r;
 thus hcflat.(p,hcflat.(q,r))=hcflat.(p,s)
                       .=p"/\"s
                       .=(p"/\"q)"/\"r by Lm3
                       .=hcflat.((p"/\"q),r)
                       .=hcflat.(hcflat.(p,q),r);
end;

theorem
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(q,p),r) &
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(p,r),q) &
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(r,q),p) &
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(r,p),q)
proof
set s=r"/\"q;
thus hcflat.(p,hcflat.(q,r)) =hcflat.(hcflat.(p,q),r) by Th65
                       .= hcflat.(hcflat.(q,p),r) by Th62;
thus A1:hcflat.(p,hcflat.(q,r)) = hcflat.(p,hcflat.(r,q)) by Th62
                       .=hcflat.(hcflat.(p,r),q) by Th65;
thus hcflat.(p,hcflat.(q,r)) = hcflat.(p,s) by LATTICES:def 2
                       .=hcflat.(s,p) by Th62
                       .=hcflat.(hcflat.(r,q),p);
thus hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(r,p),q) by A1,Th62;
end;

theorem
  hcflat.(q,lcmlat.(q,p))=q & hcflat.(lcmlat.(p,q),q)=q &
  hcflat.(q,lcmlat.(p,q))=q & hcflat.(lcmlat.(q,p),q)=q
 proof
 set s=q"\/"p;
 thus A1:hcflat.(q,lcmlat.(q,p))=hcflat.(q,s)
                              .=q"/\"s
                              .=q by Lm6;
 thus A2:hcflat.(lcmlat.(p,q),q)=hcflat.(p"\/"q,q) by LATTICES:def 1
                              .=q"/\"(q"\/"p) by LATTICES:def 2
                              .=q by Lm6;
 thus hcflat.(q,lcmlat.(p,q))=q by A1,Th61;
 thus hcflat.(lcmlat.(q,p),q)=q by A2,Th61;
end;

theorem
  lcmlat.(q,hcflat.(q,p))=q & lcmlat.(hcflat.(p,q),q)=q &
  lcmlat.(q,hcflat.(p,q))=q & lcmlat.(hcflat.(q,p),q)=q
 proof
 set r=p"/\"q;
 thus A1:lcmlat.(q,hcflat.(q,p))=lcmlat.(q,q"/\"p) by LATTICES:def 2
                              .=(p"/\"q)"\/"q by LATTICES:def 1
                              .=q by Lm5;
 thus A2:lcmlat.(hcflat.(p,q),q)=lcmlat.(r,q)
                              .=r"\/"q
                              .=q by Lm5;
 thus lcmlat.(q,hcflat.(p,q))=q by A1,Th62;
 thus lcmlat.(hcflat.(q,p),q)=q by A2,Th62;
end;

:: NATPLUS

definition
  func NATPLUS -> Subset of NAT means
:Def9: for n being Nat holds n in it iff 0 < n;
existence
 proof
  defpred P[Nat] means 0 < $1;
  consider X being Subset of NAT such that
A1: for n being Nat holds n in X iff P[n] from SUBSET_1:sch 3;
  take X;
  thus thesis by A1;
  end;
uniqueness proof
    defpred P[Nat] means 0 < $1;
thus for X1,X2 being Subset of NAT st
   (for y being Element of NAT holds y in X1 iff P[y]) &
   (for y being Element of NAT holds y in X2 iff P[y]) holds
  X1 = X2 from SUBSET_1:sch 2;
  end;
end;

registration
  cluster NATPLUS -> non empty;
  coherence
 proof
   0 < 1;
   hence thesis by Def9;
  end;
end;

definition let D be non empty set, S be non empty Subset of D,
               N be non empty Subset of S;
  redefine mode Element of N -> Element of S;
 coherence
  proof let x be Element of N;
  thus thesis;
  end;
end;

registration let D be Subset of REAL;
  cluster -> real Element of D;
  coherence;
end;

registration let D be Subset of NAT;
  cluster -> real Element of D;
  coherence;
end;

definition
  mode NatPlus is Element of NATPLUS;
end;

:: LATTICE of NATURAL NUMBERS > 0

definition
  let k be Nat such that
  A1: k>0;
  func @k->Element of NATPLUS equals
  :Def10: k;
  coherence by A1,Def9;
end;

definition
  let k be Element of NATPLUS;
  func @k -> NatPlus equals
    k;
  coherence;
end;

 reserve m,n for NatPlus;

definition
  func hcflatplus -> BinOp of NATPLUS means
 :Def12: it.(m,n) = m hcf n;
 existence
  proof
  deffunc O(Element of NATPLUS,Element of NATPLUS)= @(@$1 hcf @$2);
  consider f being BinOp of NATPLUS such that
  A1: for m,n being Element of NATPLUS holds
  f.(m,n)=O(m,n) from BINOP_1:sch 4;
  take f;
  let m,n be Element of NATPLUS;
  A2: n>0 by Def9;
  A3: @n = n & @@n = @n;
      @m = m & @@m = @m;
  then A4: f.(m,n)=@(m hcf n) by A1,A3;
      m hcf n >0 by A2,NEWTON:71;
  hence thesis by A4,Def10;
  end;
 uniqueness proof deffunc O(Element of NATPLUS,Element of NATPLUS)= $1 hcf $2;
  thus for o1,o2 being BinOp of NATPLUS st
    (for a,b being Element of NATPLUS holds o1.(a,b) = O(a,b)) &
    (for a,b being Element of NATPLUS holds o2.(a,b) = O(a,b))
  holds o1 = o2 from BINOP_2:sch 2;
  end;

  func lcmlatplus-> BinOp of NATPLUS means :Def13:
    it.(m,n)=m lcm n;
  existence
  proof
  deffunc O(Element of NATPLUS,Element of NATPLUS)= @(@$1 lcm @$2);
  consider f being BinOp of NATPLUS such that
  A5: for m,n being Element of NATPLUS holds
  f.(m,n)=O(m,n) from BINOP_1:sch 4;
  take f;
  let m,n be Element of NATPLUS;
  A6: m>0 by Def9;
  A7: n>0 by Def9;
  A8: @n = n & @@n = @n;
  @m = m & @@m = @m;
  then A9: f.(m,n)=@(m lcm n) by A5,A8;
  m lcm n >0 by A6,A7,NEWTON:73;
  hence thesis by A9,Def10;
  end;
 uniqueness proof deffunc O(Element of NATPLUS,Element of NATPLUS)= $1 lcm $2;
  thus for o1,o2 being BinOp of NATPLUS st
    (for a,b being Element of NATPLUS holds o1.(a,b) = O(a,b)) &
    (for a,b being Element of NATPLUS holds o2.(a,b) = O(a,b))
  holds o1 = o2 from BINOP_2:sch 2;
  end;
end;

 reserve p,q,r for Element of LattStr (# NATPLUS, lcmlatplus, hcflatplus #);

definition let m be Element of LattStr (# NATPLUS, lcmlatplus, hcflatplus #);
  func @m -> NatPlus equals
    m;
  coherence;
end;

theorem
Th69: p"\/"q =@p lcm @q by Def13;

theorem
Th70: p"/\"q = @p hcf @q by Def12;

Lm7:
 for a,b being Element of LattStr (# NATPLUS, lcmlatplus, hcflatplus #)
       holds a"\/"b = b"\/"a
proof
  let a,b be Element of LattStr (# NATPLUS, lcmlatplus, hcflatplus #);
  thus a"\/"b = @a lcm @b by Th69
           .= b"\/"a by Th69;
end;

Lm8:
 for a,b,c being Element of LattStr (# NATPLUS, lcmlatplus, hcflatplus #)
      holds a"\/"(b"\/"c) = (a"\/"b)"\/"c
 proof
  let a,b,c be Element of LattStr (# NATPLUS, lcmlatplus, hcflatplus #);
  set l=b"\/"c;
  set k=a"\/"b;
  A1:(@b lcm @c)=l & @l=l by Th69;
  A2:@a lcm @b=k & @k=k by Th69;
  thus a"\/"(b"\/"c) = @a lcm (@b lcm @c) by A1,Th69
                .= @k lcm @c by A2,NEWTON:56
                .= (a"\/"b)"\/"c by Th69;
 end;

Lm9:
 for a,b being Element of LattStr (# NATPLUS, lcmlatplus, hcflatplus #)
      holds (a"/\"b)"\/"b = b
 proof
 let a,b be Element of LattStr (# NATPLUS, lcmlatplus, hcflatplus #);
  set k=a"/\"b;
      @a hcf @b=k & @k=k by Th70;
 hence (a"/\"b)"\/"b = (@a hcf @b) lcm @b by Th69
               .= b by NEWTON:66;
end;

Lm10:
 for a,b being Element of LattStr (# NATPLUS, lcmlatplus, hcflatplus #)
      holds a"/\"b = b"/\"a
 proof
  let a,b be Element of LattStr (# NATPLUS, lcmlatplus, hcflatplus #);
  thus a"/\"b = @a hcf @b by Th70
           .= b"/\"a by Th70;
 end;

Lm11:
 for a,b,c being Element of LattStr (# NATPLUS, lcmlatplus, hcflatplus #)
      holds a"/\"(b"/\"c) = (a"/\"b)"/\"c
 proof
  let a,b,c be Element of LattStr (# NATPLUS, lcmlatplus, hcflatplus #);
  set l=b"/\"c;
  set k=a"/\"b;
  A1:(@b hcf @c)=l & @l=l by Th70;
  A2:@a hcf @b=k & @k=k by Th70;
  thus a"/\"(b"/\"c) = @a hcf (@b hcf @c) by A1,Th70
                .= @k hcf @c by A2,NEWTON:61
                .= (a"/\"b)"/\"c by Th70;
 end;

Lm12:
 for a,b being Element of LattStr (# NATPLUS, lcmlatplus, hcflatplus #)
      holds a"/\"(a"\/"b) = a
 proof
  let a,b be Element of LattStr (# NATPLUS, lcmlatplus, hcflatplus #);
  set l=a"\/"b;
  @a lcm @b=l & @l=l by Th69;
  hence a"/\"(a"\/"b) = @a hcf (@a lcm @b) by Th70
                .= a by NEWTON:67;
 end;

definition
  func NatPlus_Lattice -> Lattice equals
   LattStr (# NATPLUS, lcmlatplus, hcflatplus #);
  coherence
  proof
     LattStr (# NATPLUS, lcmlatplus, hcflatplus #) is Lattice-like
     proof
      thus (for p,q holds p"\/"q = q"\/"p) &
      (for p,q,r holds p"\/"(q"\/"r) = (p"\/"q)"\/"r) &
      (for p,q holds (p"/\"q)"\/"q = q) &
      (for p,q holds p"/\"q = q"/\"p) &
      (for p,q,r holds p"/\"(q"/\"r) = (p"/\"q)"/\"r) &
      (for p,q holds p"/\"(p"\/"q) = p) by Lm7,Lm8,Lm9,Lm10,Lm11,Lm12;
     end;
   hence thesis;
  end;
end;

registration
  cluster NatPlus_Lattice -> strict;
  coherence;
end;

Lm13: now let L be Lattice;
 thus the L_join of L = (the L_join of L)||the carrier of L
  proof
   [:the carrier of L, the carrier of L:]
     = dom (the L_join of L) by FUNCT_2:def 1;
   hence thesis by RELAT_1:97;
  end;
  thus the L_meet of L = (the L_meet of L)||the carrier of L
   proof
    [:the carrier of L, the carrier of L:]
     = dom (the L_meet of L) by FUNCT_2:def 1;
    hence thesis by RELAT_1:97;
   end;
end;

definition let L be Lattice;
  mode SubLattice of L -> Lattice means
 :Def16: the carrier of it c= the carrier of L &
   the L_join of it = (the L_join of L)||the carrier of it &
   the L_meet of it = (the L_meet of L)||the carrier of it;
 existence proof take L; thus thesis by Lm13; end;
end;

registration let L be Lattice;
  cluster strict SubLattice of L;
  existence
   proof set S =
     LattStr(#the carrier of L, the L_join of L, the L_meet of L#);
A1:  for a,b be Element of S,
         a',b' be Element of L st a = a' & b = b'
      holds a"\/"b = a'"\/"b' & a"/\"b = a'"/\"b';
A2:  now let a,b be Element of S;
       reconsider a' = a, b' = b as Element of L;
      thus a"\/"b = b'"\/"a' by A1
        .= b"\/"a;
     end;
A3:  now let a,b,c be Element of S;
       reconsider a' = a, b' = b, c' = c as Element of L;
      thus a"\/"(b"\/"c) = a'"\/"(b'"\/"c')
        .= (a'"\/"b')"\/"c' by LATTICES:def 5
        .= (a"\/"b)"\/"c;
     end;
A4:  now let a,b be Element of S;
       reconsider a' = a, b' = b as Element of L;
       thus (a"/\"b)"\/"b = (a'"/\"b')"\/"b'
         .= b by LATTICES:def 8;
     end;
A5:  now let a,b be Element of S;
      reconsider a' = a, b' = b as Element of L;
      thus a"/\"b = b'"/\"a' by A1
          .= b"/\"a;
     end;
A6:  now let a,b,c be Element of S;
       reconsider a' = a, b' = b, c' = c as Element of L;
       thus a"/\"(b"/\"c) = a'"/\"(b'"/\"c')
          .= (a'"/\"b')"/\"c' by LATTICES:def 7
          .= (a"/\"b)"/\"c;
     end;
     now let a,b be Element of S;
      reconsider a' = a, b' = b as Element of L;
      thus a"/\"(a"\/"b) = a'"/\"(a'"\/"b')
          .=a by LATTICES:def 9;
     end;
     then S is join-commutative join-associative meet-absorbing
        meet-commutative meet-associative join-absorbing
     by A2,A3,A4,A5,A6,LATTICES:def 4,def 5,def 6,def 7,def 8,def 9;
     then reconsider S as Lattice by LATTICES:def 10;
     the L_join of S = (the L_join of L)||the carrier of S &
     the L_meet of S = (the L_meet of L)||the carrier of S by FUNCT_2:40;
     then S is SubLattice of L by Def16;
    hence thesis;
   end;
end;

canceled 4;

theorem
  for L being Lattice holds L is SubLattice of L
proof let L be Lattice;
  thus the carrier of L c= the carrier of L;
  thus thesis by Lm13;
end;

theorem
  NatPlus_Lattice is SubLattice of Nat_Lattice
proof
A1: lcmlatplus = lcmlat||NATPLUS
  proof
A2: dom lcmlatplus = dom lcmlat /\ [:NATPLUS,NATPLUS:]
    proof
A3:  dom lcmlatplus = [:NATPLUS,NATPLUS:] by FUNCT_2:def 1;
A4:  dom lcmlat = [:NAT,NAT:] by FUNCT_2:def 1;
        [:NATPLUS,NATPLUS:] c= [:NAT,NAT:] by ZFMISC_1:119;
     hence thesis by A3,A4,XBOOLE_1:28;
    end;
    for x being set st x in dom lcmlatplus holds lcmlatplus.x = lcmlat.x
    proof let x be set;
    assume x in dom lcmlatplus;
    then A5: x in [:NATPLUS,NATPLUS:] by FUNCT_2:def 1;
    then consider y1,y2 being set such that A6: [y1,y2]=x by ZFMISC_1:102;
    y1 in NATPLUS & y2 in NATPLUS by A5,A6,ZFMISC_1:106;
    then reconsider n=y1,k=y2 as Nat;
    A7: lcmlat.(n,k) = n lcm k by Def4;
    reconsider n=y1,k=y2 as NatPlus by A5,A6,ZFMISC_1:106;
    A8: lcmlatplus.(n,k)= lcmlat.(n,k) by A7,Def13;
    lcmlatplus.(n,k)= lcmlatplus.[n,k];
    hence thesis by A6,A8;
   end;
   hence thesis by A2,FUNCT_1:68;
  end;
  hcflatplus = hcflat||NATPLUS
  proof
   A9: dom hcflatplus = dom hcflat /\ [:NATPLUS,NATPLUS:]
    proof
     A10: dom hcflatplus = [:NATPLUS,NATPLUS:] by FUNCT_2:def 1;
     A11: dom hcflat = [:NAT,NAT:] by FUNCT_2:def 1;
     [:NATPLUS,NATPLUS:] c= [:NAT,NAT:] by ZFMISC_1:119;
     hence thesis by A10,A11,XBOOLE_1:28;
    end;
    for x being set st x in dom hcflatplus holds hcflatplus.x = hcflat.x
    proof let x be set;
    assume x in dom hcflatplus;
    then A12: x in [:NATPLUS,NATPLUS:] by FUNCT_2:def 1;
    then consider y1,y2 being set such that A13: [y1,y2]=x by ZFMISC_1:102;
    y1 in NATPLUS & y2 in NATPLUS by A12,A13,ZFMISC_1:106;
    then reconsider n=y1,k=y2 as Nat;
    A14: hcflat.(n,k) = n hcf k by Def3;
    reconsider n=y1,k=y2 as NatPlus by A12,A13,ZFMISC_1:106;
    A15: hcflatplus.(n,k)= hcflat.(n,k) by A14,Def12;
    hcflatplus.(n,k)= hcflatplus.[n,k];
    hence thesis by A13,A15;
   end;
   hence thesis by A9,FUNCT_1:68;
  end;
 hence thesis by A1,Def16;
end;

