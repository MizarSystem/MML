:: The Lattice of Natural Numbers and The Sublattice of it.
:: The Set of Prime Numbers
::  by Marek Chmur
::
:: Received April 26, 1991
:: Copyright (c) 1991 Association of Mizar Users

environ

 vocabulary ARYTM_3, QC_LANG1, ARYTM_1, BINOP_1, FUNCT_1, LATTICES, ARYTM,
      RELAT_1, BOOLE, FILTER_0, FINSEQ_1, FINSET_1, CARD_1, TARSKI, NAT_1,
      NAT_LAT;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XCMPLX_0, XREAL_0,
      STRUCT_0, CARD_1, INT_2, NAT_1, LATTICES, BINOP_1, FINSEQ_1, FINSET_1,
      RELAT_1, FUNCT_1, NEWTON;
 constructors WELLORD2, INT_2, NAT_1, LATTICES, BINOP_1, NEWTON, PARTFUN1,
      MEMBERED, XBOOLE_0;
 clusters FINSET_1, RLSUB_2, STRUCT_0, XREAL_0, FINSEQ_1, RELSET_1, INT_1,
      LATTICES, NAT_1, MEMBERED, ZFMISC_1, XBOOLE_0, ORDINAL2;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, LATTICES;
 theorems INT_2, NEWTON, AXIOMS, CARD_1, ZFMISC_1, LATTICES, BINOP_1, NAT_1,
      REAL_2, REAL_1, FUNCT_1, FINSEQ_1, FINSET_1, FUNCT_2, TARSKI, CARD_2,
      INT_1, CQC_THE1, XBOOLE_0, XBOOLE_1, RELAT_1, XCMPLX_1;
 schemes NAT_1, SETWISEO, BINOP_1, BINOP_2, SUBSET_1;

begin :: Auxiliary Theorems

canceled 47;

reserve n,m,l,k,i,j,s,r,t for Nat;

definition
 canceled 2;

 func hcflat-> BinOp of NAT means
 :Def3: it.(m,n)=m hcf n;
 existence proof
   deffunc O(Nat,Nat)= $1 hcf $2;
  thus ex o being BinOp of NAT st
    for a,b being Element of NAT holds o.(a,b) = O(a,b) from BINOP_1:sch 2;
 end;
 uniqueness proof
    deffunc O(Nat,Nat)= $1 hcf $2;
  thus for o1,o2 being BinOp of NAT st
    (for a,b being Element of NAT holds o1.(a,b) = O(a,b)) &
    (for a,b being Element of NAT holds o2.(a,b) = O(a,b))
  holds o1 = o2 from BINOP_2:sch 2;
 end;

 func lcmlat-> BinOp of NAT means
 :Def4: it.(m,n)=m lcm n;
 existence proof
   deffunc O(Nat,Nat)= $1 lcm $2;
  thus ex o being BinOp of NAT st
    for a,b being Element of NAT holds o.(a,b) = O(a,b) from BINOP_1:sch 2;
 end;
 uniqueness proof
    deffunc O(Nat,Nat)= $1 lcm $2;
  thus for o1,o2 being BinOp of NAT st
    (for a,b being Element of NAT holds o1.(a,b) = O(a,b)) &
    (for a,b being Element of NAT holds o2.(a,b) = O(a,b))
  holds o1 = o2 from BINOP_2:sch 2;
 end;
end;

reserve p,q,r for Element of LattStr (# NAT, lcmlat, hcflat #);

definition
 let m be Element of LattStr (# NAT, lcmlat, hcflat #);
 func @m -> Nat equals
 :Def5: m;
 coherence;
 end;

theorem
Th48: p"\/"q =@p lcm @q
 proof
      p"\/"q = lcmlat.(p,q) & p=@p & q=@q by Def5,LATTICES:def 1;
  hence p"\/"q=@p lcm @q by Def4;
 end;

theorem
Th49: p"/\"q = @p hcf @q
 proof
      p"/\"q = hcflat.(p,q) & p=@p & q=@q by Def5,LATTICES:def 2;
  hence p"/\"q=@p hcf @q by Def3;
 end;

Lm1:
 for a,b being Element of LattStr (# NAT, lcmlat, hcflat #)
       holds a"\/"b = b"\/"a
 proof
  let a,b be Element of LattStr (# NAT, lcmlat, hcflat #);
  thus a"\/"b = @a lcm @b by Th48
           .= b"\/"a by Th48;
 end;

Lm2:
 for a,b being Element of LattStr (# NAT, lcmlat, hcflat #)
      holds a"/\"b = b"/\"a
 proof
  let a,b be Element of LattStr (# NAT, lcmlat, hcflat #);
  thus a"/\"b = @a hcf @b by Th49
           .= b"/\"a by Th49;
 end;

Lm3:
 for a,b,c being Element of LattStr (# NAT, lcmlat, hcflat #)
      holds a"/\"(b"/\"c) = (a"/\"b)"/\"c
 proof
  let a,b,c be Element of LattStr (# NAT, lcmlat, hcflat #);
  set l=b"/\"c;
  set k=a"/\"b;
  A1:(@b hcf @c)=l & @l=l by Def5,Th49;
  A2:@a hcf @b=k & @k=k by Def5,Th49;
  thus a"/\"(b"/\"c) = @a hcf (@b hcf @c) by A1,Th49
                .= @k hcf @c by A2,NEWTON:61
                .= (a"/\"b)"/\"c by Th49;
 end;

Lm4:
 for a,b,c being Element of LattStr (# NAT, lcmlat, hcflat #)
      holds a"\/"(b"\/"c) = (a"\/"b)"\/"c
 proof
  let a,b,c be Element of LattStr (# NAT, lcmlat, hcflat #);
  set l=b"\/"c;
  set k=a"\/"b;
  A1:(@b lcm @c)=l & @l=l by Def5,Th48;
  A2:@a lcm @b=k & @k=k by Def5,Th48;
  thus a"\/"(b"\/"c) = @a lcm (@b lcm @c) by A1,Th48
                .= @k lcm @c by A2,NEWTON:56
                .= (a"\/"b)"\/"c by Th48;
 end;

Lm5:
 for a,b being Element of LattStr (# NAT, lcmlat, hcflat #)
      holds (a"/\"b)"\/"b = b
 proof
 let a,b be Element of LattStr (# NAT, lcmlat, hcflat #);
  set k=a"/\"b;
  A1: @b=b by Def5;
      @a hcf @b=k & @k=k by Def5,Th49;
 hence (a"/\"b)"\/"b = (@a hcf @b) lcm @b by Th48
               .= b by A1,NEWTON:66;
end;

Lm6:
 for a,b being Element of LattStr (# NAT, lcmlat, hcflat #)
      holds a"/\"(a"\/"b) = a
 proof
  let a,b be Element of LattStr (# NAT, lcmlat, hcflat #);
  set l=a"\/"b;
  A1: @a=a by Def5;
      @a lcm @b=l & @l=l by Def5,Th48;
  hence a"/\"(a"\/"b) = @a hcf (@a lcm @b) by Th49
                .= a by A1,NEWTON:67;
 end;

canceled 2;

theorem
    for a,b being Element of LattStr (# NAT, lcmlat, hcflat #)
           holds a[=b implies @a divides @b
       proof
  let a,b be Element of LattStr (# NAT, lcmlat, hcflat #);
        assume a[=b;
        then a"\/"b=b by LATTICES:def 3;
        then @a lcm @b = b by Th48;
        then @a lcm @b = @b by Def5;
        hence thesis by NEWTON:57;
        end;

definition
 func 0_NN -> Element of LattStr (# NAT, lcmlat, hcflat #)
  equals
 :Def6: 1;
 coherence;

 func 1_NN -> Element of LattStr (# NAT, lcmlat, hcflat #)
  equals  0;
 coherence;
 end;

canceled 2;

theorem Th55:
  @0_NN=1 by Def5,Def6;

theorem Th56:
 for a being Element of LattStr (# NAT, lcmlat, hcflat #) holds
                0_NN"/\"a = 0_NN & a"/\"0_NN = 0_NN
proof let a be Element of LattStr (# NAT, lcmlat, hcflat #);
  thus 0_NN"/\"a = 1 hcf @a by Th49,Th55
              .= 0_NN by Def6,NEWTON:64;
  thus a"/\"0_NN = @a hcf 1 by Th49,Th55
              .= 0_NN by Def6,NEWTON:64;
end;

definition
 func Nat_Lattice -> Lattice equals
 :Def8: LattStr (# NAT, lcmlat, hcflat #);
 coherence
  proof
       LattStr (# NAT, lcmlat, hcflat #) is Lattice-like
     proof
      thus (for p,q holds p"\/"q = q"\/"p) &
      (for p,q,r holds p"\/"(q"\/"r) = (p"\/"q)"\/"r) &
      (for p,q holds (p"/\"q)"\/"q = q) &
      (for p,q holds p"/\"q = q"/\"p) &
      (for p,q,r holds p"/\"(q"/\"r) = (p"/\"q)"/\"r) &
      (for p,q holds p"/\"(p"\/"q) = p) by Lm1,Lm2,Lm3,Lm4,Lm5,Lm6;
     end;
   hence thesis;
  end;
end;

registration
 cluster Nat_Lattice -> strict;
 coherence by Def8;
end;

reserve p,q,r for Element of Nat_Lattice;

canceled 3;

theorem
     Nat_Lattice is 0_Lattice by Def8,Th56,LATTICES:def 13;

theorem Th61:
  lcmlat.(p,q)=lcmlat.(q,p)
proof
 thus lcmlat.(p,q)=q"\/"p by Def8,LATTICES:def 1
                 .=lcmlat.(q,p) by Def8,LATTICES:def 1;
end;

theorem Th62:
  hcflat.(q,p)=hcflat.(p,q)
proof
 thus hcflat.(q,p)=p"/\"q by Def8,LATTICES:def 2
                 .=hcflat.(p,q) by Def8,LATTICES:def 2;
end;

theorem Th63:
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(p,q),r)
proof
 set s=q"\/"r;
 thus lcmlat.(p,lcmlat.(q,r))=lcmlat.(p,s) by Def8,LATTICES:def 1
                       .=p"\/"s by Def8,LATTICES:def 1
                       .=(p"\/"q)"\/"r by Def8,Lm4
                       .=lcmlat.((p"\/"q),r) by Def8,LATTICES:def 1
                       .=lcmlat.(lcmlat.(p,q),r) by Def8,LATTICES:def 1;
end;

theorem
     lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(q,p),r) &
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(p,r),q) &
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(r,q),p) &
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(r,p),q)
proof
set s=r"\/"q;
thus lcmlat.(p,lcmlat.(q,r)) =lcmlat.(lcmlat.(p,q),r) by Th63
                       .= lcmlat.(lcmlat.(q,p),r) by Th61;
thus A1:lcmlat.(p,lcmlat.(q,r)) = lcmlat.(p,lcmlat.(r,q)) by Th61
                       .=lcmlat.(lcmlat.(p,r),q) by Th63;
thus lcmlat.(p,lcmlat.(q,r)) = lcmlat.(p,s) by Def8,LATTICES:def 1
                       .=lcmlat.(s,p) by Th61
                       .=lcmlat.(lcmlat.(r,q),p) by Def8,LATTICES:def 1;
thus lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(r,p),q) by A1,Th61;
end;

theorem Th65:
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(p,q),r)
proof
 set s=q"/\"r;
 thus hcflat.(p,hcflat.(q,r))=hcflat.(p,s) by Def8,LATTICES:def 2
                       .=p"/\"s by Def8,LATTICES:def 2
                       .=(p"/\"q)"/\"r by Def8,Lm3
                       .=hcflat.((p"/\"q),r) by Def8,LATTICES:def 2
                       .=hcflat.(hcflat.(p,q),r) by Def8,LATTICES:def 2;
end;

theorem
     hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(q,p),r) &
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(p,r),q) &
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(r,q),p) &
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(r,p),q)
proof
set s=r"/\"q;
thus hcflat.(p,hcflat.(q,r)) =hcflat.(hcflat.(p,q),r) by Th65
                       .= hcflat.(hcflat.(q,p),r) by Th62;
thus A1:hcflat.(p,hcflat.(q,r)) = hcflat.(p,hcflat.(r,q)) by Th62
                       .=hcflat.(hcflat.(p,r),q) by Th65;
thus hcflat.(p,hcflat.(q,r)) = hcflat.(p,s) by Def8,LATTICES:def 2
                       .=hcflat.(s,p) by Th62
                       .=hcflat.(hcflat.(r,q),p) by Def8,LATTICES:def 2;
thus hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(r,p),q) by A1,Th62;
end;

theorem
     hcflat.(q,lcmlat.(q,p))=q & hcflat.(lcmlat.(p,q),q)=q &
  hcflat.(q,lcmlat.(p,q))=q & hcflat.(lcmlat.(q,p),q)=q
 proof
 set s=q"\/"p;
 thus A1:hcflat.(q,lcmlat.(q,p))=hcflat.(q,s) by Def8,LATTICES:def 1
                              .=q"/\"s by Def8,LATTICES:def 2
                              .=q by Def8,Lm6;
 thus A2:hcflat.(lcmlat.(p,q),q)=hcflat.(p"\/"q,q) by Def8,LATTICES:def 1
                              .=q"/\"(q"\/"p) by Def8,LATTICES:def 2
                              .=q by Def8,Lm6;
 thus hcflat.(q,lcmlat.(p,q))=q by A1,Th61;
 thus hcflat.(lcmlat.(q,p),q)=q by A2,Th61;
end;

theorem
     lcmlat.(q,hcflat.(q,p))=q & lcmlat.(hcflat.(p,q),q)=q &
  lcmlat.(q,hcflat.(p,q))=q & lcmlat.(hcflat.(q,p),q)=q
 proof
 set r=p"/\"q;
 thus A1:lcmlat.(q,hcflat.(q,p))=lcmlat.(q,q"/\"p) by Def8,LATTICES:def 2
                              .=(p"/\"q)"\/"q by Def8,LATTICES:def 1
                              .=q by Def8,Lm5;
 thus A2:lcmlat.(hcflat.(p,q),q)=lcmlat.(r,q) by Def8,LATTICES:def 2
                              .=r"\/"q by Def8,LATTICES:def 1
                              .=q by Def8,Lm5;
 thus lcmlat.(q,hcflat.(p,q))=q by A1,Th62;
 thus lcmlat.(hcflat.(q,p),q)=q by A2,Th62;
end;

:: NATPLUS

definition
  func NATPLUS -> Subset of NAT means
:Def9: for n being Nat holds n in it iff 0 < n;
existence
 proof
  defpred _P[Nat] means 0 < $1;
  consider X being Subset of NAT such that
A1: for n being Nat holds n in X iff _P[n] from SETWISEO:sch 1;
  take X;
  thus thesis by A1;
  end;
uniqueness proof
    defpred P[Nat] means 0 < $1;
thus for X1,X2 being Subset of NAT st
   (for y being Element of NAT holds y in X1 iff P[y]) &
   (for y being Element of NAT holds y in X2 iff P[y]) holds
  X1 = X2 from SUBSET_1:sch 2;
  end;
end;

registration
  cluster NATPLUS -> non empty;
  coherence
 proof
      0 < 1;
   hence thesis by Def9;
  end;
  end;

definition let D be non empty set, S be non empty Subset of D,
               N be non empty Subset of S;
redefine mode Element of N -> Element of S;
 coherence
  proof let x be Element of N;
  thus thesis;
  end;
end;

registration let D be Subset of REAL;
  cluster -> real Element of D;
coherence;
end;

registration let D be Subset of NAT;
  cluster -> real Element of D;
coherence;
end;

definition
  mode NatPlus is Element of NATPLUS;
end;

:: LATTICE of NATURAL NUMBERS > 0

definition
 let k be Nat such that
 A1: k>0;
 func @k->Element of NATPLUS equals
 :Def10: k;
 coherence by A1,Def9;
end;

definition
 let k be Element of NATPLUS;
 func @k -> NatPlus equals :Def11:
  k;
 coherence;
 end;

reserve m,n for NatPlus;

definition
 func hcflatplus -> BinOp of NATPLUS means
 :Def12: it.(m,n) = m hcf n;
 existence
  proof
     deffunc O(Element of NATPLUS,Element of NATPLUS)= @(@$1 hcf @$2);
  consider f being BinOp of NATPLUS such that
  A1: for m,n being Element of NATPLUS holds
  f.(m,n)=O(m,n) from BINOP_1:sch 2;
  take f;
  let m,n be Element of NATPLUS;
  A2: n>0 by Def9;
  A3: @n = n & @@n = @n by Def11;
      @m = m & @@m = @m by Def11;
  then A4: f.(m,n)=@(m hcf n) by A1,A3;
      m hcf n >0 by A2,NEWTON:72;
  hence thesis by A4,Def10;
  end;
 uniqueness proof deffunc O(Element of NATPLUS,Element of NATPLUS)= $1 hcf $2;
  thus for o1,o2 being BinOp of NATPLUS st
    (for a,b being Element of NATPLUS holds o1.(a,b) = O(a,b)) &
    (for a,b being Element of NATPLUS holds o2.(a,b) = O(a,b))
  holds o1 = o2 from BINOP_2:sch 2;
  end;

 func lcmlatplus-> BinOp of NATPLUS means
 :Def13: it.(m,n)=m lcm n;
 existence
  proof
     deffunc O(Element of NATPLUS,Element of NATPLUS)= @(@$1 lcm @$2);
  consider f being BinOp of NATPLUS such that
  A5: for m,n being Element of NATPLUS holds
  f.(m,n)=O(m,n) from BINOP_1:sch 2;
  take f;
  let m,n be Element of NATPLUS;
  A6: m>0 by Def9;
  A7: n>0 by Def9;
  A8: @n = n & @@n = @n by Def11;
      @m = m & @@m = @m by Def11;
  then A9: f.(m,n)=@(m lcm n) by A5,A8;
      m lcm n >0 by A6,A7,NEWTON:73;
  hence thesis by A9,Def10;
  end;
 uniqueness proof deffunc O(Element of NATPLUS,Element of NATPLUS)= $1 lcm $2;
  thus for o1,o2 being BinOp of NATPLUS st
    (for a,b being Element of NATPLUS holds o1.(a,b) = O(a,b)) &
    (for a,b being Element of NATPLUS holds o2.(a,b) = O(a,b))
  holds o1 = o2 from BINOP_2:sch 2;
  end;
end;

reserve p,q,r for Element of LattStr
                            (# NATPLUS, lcmlatplus, hcflatplus #);

definition
 let m be Element of LattStr
                            (# NATPLUS, lcmlatplus, hcflatplus #);
 func @m->NatPlus equals
 :Def14: m;
 coherence;
 end;

theorem
Th69: p"\/"q =@p lcm @q
 proof
      p"\/"q = lcmlatplus.(p,q) & p=@p & q=@q by Def14,LATTICES:def 1;
  hence p"\/"q=@p lcm @q by Def13;
 end;

theorem
Th70: p"/\"q = @p hcf @q
 proof
      p"/\"q = hcflatplus.(p,q) & p=@p & q=@q by Def14,LATTICES:def 2;
  hence p"/\"q=@p hcf @q by Def12;
 end;

Lm7:
 for a,b being Element of LattStr
                      (# NATPLUS, lcmlatplus, hcflatplus #)
       holds a"\/"b = b"\/"a
 proof
  let a,b be Element of LattStr
                      (# NATPLUS, lcmlatplus, hcflatplus #);
  thus a"\/"b = @a lcm @b by Th69
           .= b"\/"a by Th69;
 end;

Lm8:
 for a,b,c being Element of LattStr
                         (# NATPLUS, lcmlatplus, hcflatplus #)
      holds a"\/"(b"\/"c) = (a"\/"b)"\/"c
 proof
  let a,b,c be Element of LattStr
                         (# NATPLUS, lcmlatplus, hcflatplus #);
  set l=b"\/"c;
  set k=a"\/"b;
  A1:(@b lcm @c)=l & @l=l by Def14,Th69;
  A2:@a lcm @b=k & @k=k by Def14,Th69;
  thus a"\/"(b"\/"c) = @a lcm (@b lcm @c) by A1,Th69
                .= @k lcm @c by A2,NEWTON:56
                .= (a"\/"b)"\/"c by Th69;
 end;

Lm9:
 for a,b being Element of LattStr
                         (# NATPLUS, lcmlatplus, hcflatplus #)
      holds (a"/\"b)"\/"b = b
 proof
 let a,b be Element of LattStr
                          (# NATPLUS, lcmlatplus, hcflatplus #);
  set k=a"/\"b;
  A1: @b=b by Def14;
      @a hcf @b=k & @k=k by Def14,Th70;
 hence (a"/\"b)"\/"b = (@a hcf @b) lcm @b by Th69
               .= b by A1,NEWTON:66;
end;

Lm10:
 for a,b being Element of LattStr
                       (# NATPLUS, lcmlatplus, hcflatplus #)
      holds a"/\"b = b"/\"a
 proof
  let a,b be Element of LattStr
                       (# NATPLUS, lcmlatplus, hcflatplus #);
  thus a"/\"b = @a hcf @b by Th70
           .= b"/\"a by Th70;
 end;

Lm11:
 for a,b,c being Element of LattStr
                        (# NATPLUS, lcmlatplus, hcflatplus #)
      holds a"/\"(b"/\"c) = (a"/\"b)"/\"c
 proof
  let a,b,c be Element of LattStr
                        (# NATPLUS, lcmlatplus, hcflatplus #);
  set l=b"/\"c;
  set k=a"/\"b;
  A1:(@b hcf @c)=l & @l=l by Def14,Th70;
  A2:@a hcf @b=k & @k=k by Def14,Th70;
  thus a"/\"(b"/\"c) = @a hcf (@b hcf @c) by A1,Th70
                .= @k hcf @c by A2,NEWTON:61
                .= (a"/\"b)"/\"c by Th70;
 end;

Lm12:
 for a,b being Element of LattStr
                        (# NATPLUS, lcmlatplus, hcflatplus #)
      holds a"/\"(a"\/"b) = a
 proof
  let a,b be Element of LattStr
                        (# NATPLUS, lcmlatplus, hcflatplus #);
  set l=a"\/"b;
  A1: @a=a by Def14;
      @a lcm @b=l & @l=l by Def14,Th69;
  hence a"/\"(a"\/"b) = @a hcf (@a lcm @b) by Th70
                .= a by A1,NEWTON:67;
 end;

definition
 func NatPlus_Lattice -> Lattice equals
 :Def15: LattStr (# NATPLUS, lcmlatplus, hcflatplus #);
 coherence
  proof
       LattStr (# NATPLUS, lcmlatplus, hcflatplus #) is Lattice-like
     proof
      thus (for p,q holds p"\/"q = q"\/"p) &
      (for p,q,r holds p"\/"(q"\/"r) = (p"\/"q)"\/"r) &
      (for p,q holds (p"/\"q)"\/"q = q) &
      (for p,q holds p"/\"q = q"/\"p) &
      (for p,q,r holds p"/\"(q"/\"r) = (p"/\"q)"/\"r) &
      (for p,q holds p"/\"(p"\/"q) = p) by Lm7,Lm8,Lm9,Lm10,Lm11,Lm12;
     end;
   hence thesis;
  end;
end;

registration
 cluster NatPlus_Lattice -> strict;
 coherence by Def15;
end;

reserve x,y1,y2 for set;

Lm13: now let L be Lattice;
 thus the L_join of L = (the L_join of L) | [:the carrier of L,
 the carrier of L:]
  proof
      [:the carrier of L, the carrier of L:]
   = dom (the L_join of L) by FUNCT_2:def 1;
   hence thesis by RELAT_1:97;
  end;
  thus the L_meet of L = (the L_meet of L) | [:the carrier of L,
  the carrier of L:]
   proof
       [:the carrier of L, the carrier of L:]
     = dom (the L_meet of L) by FUNCT_2:def 1;
    hence thesis by RELAT_1:97;
   end;
end;

definition let L be Lattice;
 mode SubLattice of L -> Lattice means
 :Def16: the carrier of it c= the carrier of L &
   the L_join of it = (the L_join of L) | [:the carrier of it,
   the carrier of it:] &
   the L_meet of it = (the L_meet of L) | [:the carrier of it,
   the carrier of it:];
 existence proof take L; thus thesis by Lm13; end;
end;

registration let L be Lattice;
 cluster strict SubLattice of L;
  existence
   proof set S =
     LattStr(#the carrier of L, the L_join of L, the L_meet of L#);
A1:  now let a,b be Element of S,
         a',b' be Element of L;
      assume
A2:     a = a' & b = b';
      hence a"\/"b = (the L_join of L).(a',b') by LATTICES:def 1
               .= a'"\/"b' by LATTICES:def 1;
      thus a"/\"b = (the L_meet of L).(a',b') by A2,LATTICES:def 2
               .= a'"/\"b' by LATTICES:def 2;
     end;
A3:  now let a,b be Element of S;
       reconsider a' = a, b' = b as Element of L;
      thus a"\/"b = b'"\/"a' by A1
        .= b"\/"a by A1;
     end;
A4:  now let a,b,c be Element of S;
       reconsider a' = a, b' = b, c' = c as Element of L;
A5:    a'"\/"b' = a"\/"b by A1;
          b"\/"c = b'"\/"c' by A1;
      hence a"\/"(b"\/"c) = a'"\/"(b'"\/"c') by A1
        .= (a'"\/"b')"\/"c' by LATTICES:def 5
        .= (a"\/"b)"\/"c by A1,A5;
     end;
A6:  now let a,b be Element of S;
       reconsider a' = a, b' = b as Element of L;
          a"/\"b = a'"/\"b' by A1;
      hence (a"/\"b)"\/"b = (a'"/\"b')"\/"b' by A1
         .= b by LATTICES:def 8;
     end;
A7:  now let a,b be Element of S;
       reconsider a' = a, b' = b as Element of L;
      thus a"/\"b = b'"/\"a' by A1
          .= b"/\"a by A1;
     end;
A8:  now let a,b,c be Element of S;
       reconsider a' = a, b' = b, c' = c as Element of L;
A9:    a'"/\"b' = a"/\"b by A1;
          b"/\"c = b'"/\"c' by A1;
      hence a"/\"(b"/\"c) = a'"/\"(b'"/\"c') by A1
          .= (a'"/\"b')"/\"c' by LATTICES:def 7
          .= (a"/\"b)"/\"c by A1,A9;
     end;
     now let a,b be Element of S;
       reconsider a' = a, b' = b as Element of L;
          a"\/"b = a'"\/"b' by A1;
      hence a"/\"(a"\/"b) = a'"/\"(a'"\/"b') by A1
          .=a by LATTICES:def 9;
     end;
     then S is join-commutative join-associative meet-absorbing
          meet-commutative meet-associative join-absorbing
     by A3,A4,A6,A7,A8,LATTICES:def 4,def 5,def 6,def 7,def 8,def 9;
     then reconsider S as Lattice by LATTICES:def 10;
        the L_join of S = (the L_join of L) | [:the carrier of S,
     the carrier of S:] &
     the L_meet of S = (the L_meet of L) | [:the carrier of S,
     the carrier of S:] by FUNCT_2:40;
     then S is SubLattice of L by Def16;
    hence thesis;
   end;
end;

canceled 4;

theorem
   for L being Lattice holds L is SubLattice of L
proof let L be Lattice;
 thus the carrier of L c= the carrier of L;
 thus thesis by Lm13;
end;

theorem
   NatPlus_Lattice is SubLattice of Nat_Lattice
proof
 A1: lcmlatplus = lcmlat | [: NATPLUS, NATPLUS :]
  proof
   A2: dom lcmlatplus = dom lcmlat /\ [:NATPLUS,NATPLUS:]
    proof
     A3: dom lcmlatplus = [:NATPLUS,NATPLUS:] by FUNCT_2:def 1;
     A4: dom lcmlat = [:NAT,NAT:] by FUNCT_2:def 1;
        [:NATPLUS,NATPLUS:] c= [:NAT,NAT:] by ZFMISC_1:119;
     hence thesis by A3,A4,XBOOLE_1:28;
    end;
      for x st x in dom lcmlatplus holds lcmlatplus.(x) = lcmlat.(x)
    proof let x;
    assume x in dom lcmlatplus;
    then A5: x in [:NATPLUS,NATPLUS:] by FUNCT_2:def 1;
    then consider y1,y2 such that A6: [y1,y2]=x by ZFMISC_1:102;
        y1 in NATPLUS & y2 in NATPLUS by A5,A6,ZFMISC_1:106;
    then reconsider n=y1,k=y2 as Nat;
    A7: lcmlat.(n,k) = n lcm k by Def4;
    reconsider n=y1,k=y2 as NatPlus by A5,A6,ZFMISC_1:106;
    A8: lcmlatplus.(n,k)= lcmlat.(n,k) by A7,Def13;
        lcmlatplus.(n,k)= lcmlatplus.[n,k] by BINOP_1:def 1;
    hence thesis by A6,A8,BINOP_1:def 1;
   end;
   hence thesis by A2,FUNCT_1:68;
  end;
     hcflatplus = hcflat | [:NATPLUS,NATPLUS:]
  proof
   A9: dom hcflatplus = dom hcflat /\ [:NATPLUS,NATPLUS:]
    proof
     A10: dom hcflatplus = [:NATPLUS,NATPLUS:] by FUNCT_2:def 1;
     A11: dom hcflat = [:NAT,NAT:] by FUNCT_2:def 1;
        [:NATPLUS,NATPLUS:] c= [:NAT,NAT:] by ZFMISC_1:119;
     hence thesis by A10,A11,XBOOLE_1:28;
    end;
      for x st x in dom hcflatplus holds hcflatplus.(x) = hcflat.(x)
    proof let x;
    assume x in dom hcflatplus;
    then A12: x in [:NATPLUS,NATPLUS:] by FUNCT_2:def 1;
    then consider y1,y2 such that A13: [y1,y2]=x by ZFMISC_1:102;
        y1 in NATPLUS & y2 in NATPLUS by A12,A13,ZFMISC_1:106;
    then reconsider n=y1,k=y2 as Nat;
    A14: hcflat.(n,k) = n hcf k by Def3;
    reconsider n=y1,k=y2 as NatPlus by A12,A13,ZFMISC_1:106;
    A15: hcflatplus.(n,k)= hcflat.(n,k) by A14,Def12;
        hcflatplus.(n,k)= hcflatplus.[n,k] by BINOP_1:def 1;
    hence thesis by A13,A15,BINOP_1:def 1;
   end;
   hence thesis by A9,FUNCT_1:68;
  end;
 hence thesis by A1,Def8,Def15,Def16;
end;

