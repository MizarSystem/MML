:: Products of Many Sorted Algebras
::  by Beata Madras
::
:: Received April 25, 1994
:: Copyright (c) 1994 Association of Mizar Users

environ

 vocabularies PBOOLE, MSUALG_1, FUNCT_1, RELAT_1, FRAENKEL, BOOLE, ZF_REFLE,
      CARD_3, PRALG_1, FUNCT_5, FUNCT_2, FUNCT_6, FINSEQ_4, TDGROUP, FUNCT_3,
      MCART_1, COMPLEX1, TARSKI, AMI_1, QC_LANG1, RLVECT_2, CAT_4, CQC_LANG,
      PRALG_2, FUNCOP_1, ARYTM;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1, FUNCT_2,
      BINOP_1, MCART_1, STRUCT_0, FUNCOP_1, FRAENKEL, FINSEQ_2, FUNCT_5,
      FUNCT_6, CARD_3, PBOOLE, PRALG_1, MSUALG_1;
 constructors BINOP_1, FRAENKEL, FUNCT_6, PRALG_1, MSUALG_1, VALUED_1,
      PARTFUN1, SEQ_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, FUNCOP_1, FRAENKEL,
      CARD_3, PBOOLE, STRUCT_0, MSUALG_1, VALUED_1, FUNCT_2;
 requirements BOOLE, SUBSET;
 definitions TARSKI, PBOOLE, FUNCOP_1, XBOOLE_0, BINOP_1, FUNCT_6, VALUED_1;
 theorems TARSKI, FUNCT_1, FINSEQ_1, PBOOLE, MSUALG_1, ZFMISC_1, CARD_3,
      FUNCT_2, MCART_1, FUNCOP_1, FUNCT_6, FUNCT_5, FRAENKEL, RELAT_1, PRALG_1,
      RELSET_1, XBOOLE_0, XBOOLE_1;
 schemes FUNCT_1, FUNCT_2, CLASSES1, TARSKI, PBOOLE;

begin

reserve I,J,i,j,x for set,
  S for non empty ManySortedSign;

::
:: Preliminaries
::

definition
  let X be with_common_domain functional non empty set;
  redefine mode Element of X -> ManySortedSet of (DOM X);
  coherence
  proof
    let x be Element of X;
    DOM X = dom x by CARD_3:def 12;
    hence x is ManySortedSet of (DOM X) by PBOOLE:def 3;
  end;
end;

begin

:: Operations on Functions

definition
  let F be Function;
  canceled 5;
  func Commute F -> Function means
  :Def6:
  (for x holds x in dom it iff ex f being Function st f in dom F &
  x = commute f) &
  (for f being Function st f in dom it holds it.f = F.commute f);
  existence
  proof
    defpred P[set,set] means ex f being Function st $1 = f & $2 = commute f;
A1: for x,y1,y2 being set st P[x,y1] & P[x,y2] holds y1 = y2;
    consider X being set such that
A2: for x holds x in X iff ex y being set st y in dom F & P[y,x]
    from TARSKI:sch 1(A1);

defpred P[set,set] means for f be Function st $1 = f holds $2 = F.commute f;
A3: now
      let x;
      assume x in X;
      then ex y being set st y in dom F
      & ex f being Function st y = f & x = commute f by A2;
      then reconsider f = x as Function;
      take y = F.commute f;
      thus P[x,y];
    end;
    consider G being Function such that
A4: dom G = X and
A5: for x st x in X holds P[x,G.x] from CLASSES1:sch 1(A3);
    take G;
    hereby
      let x;
      hereby
        assume x in dom G;
        then consider y being set such that
A6:     y in dom F & ex f being Function st y = f & x = commute f by A2,A4;
        reconsider f = y as Function by A6;
        take f;
        thus f in dom F & x = commute f by A6;
      end;
      thus (ex f being Function st f in dom F &
      x = commute f) implies x in dom G by A2,A4;
    end;
    thus thesis by A4,A5;
  end;
  uniqueness
  proof
    let m,n be Function such that
A7: for x holds x in dom m iff ex f being Function st f in dom F &
    x = commute f and
A8: for f being Function st f in dom m holds m.f = F.commute f and
A9: for x holds x in dom n iff ex f being Function st f in dom F &
    x = commute f and
A10: for f being Function st f in dom n holds n.f = F.commute f;
    now
      let x;
      x in dom m iff ex f being Function st f in dom F & x = commute f by A7;
      hence x in dom m iff x in dom n by A9;
    end;
    then
A11: dom m = dom n by TARSKI:2;
    now
      let x;
      assume
A12:  x in dom m;
      then consider g being Function such that g in dom F and
A13:  x = commute g by A9,A11;
      thus m.x = F.commute commute g by A8,A12,A13
        .= n.x by A10,A11,A12,A13;
    end;
    hence m = n by A11,FUNCT_1:9;
  end;
end;

canceled 7;

theorem
  for F be Function st dom F = {{}} holds Commute F = F
proof
  let F be Function;
  assume
A1: dom F = {{}};
A2: dom (Commute F) = {{}}
  proof
    thus dom (Commute F) c= {{}}
    proof
      let x;
      assume x in dom (Commute F);
      then consider f be Function such that
A3:   f in dom F & x = commute f by Def6;
      x = {} by A1,A3,FUNCT_6:88,TARSKI:def 1;
      hence x in {{}} by TARSKI:def 1;
    end;
    let x;
    assume x in {{}};
    then
A4: x = {} by TARSKI:def 1;
    {} in dom F by A1,TARSKI:def 1;
    hence thesis by A4,Def6,FUNCT_6:88;
  end;
  for x st x in {{}} holds (Commute F).x = F.x
  proof
    let x;
    assume
A5: x in {{}};
    then x = {} by TARSKI:def 1;
    hence (Commute F).x = F.x by A2,A5,Def6,FUNCT_6:88;
  end;
  hence thesis by A1,A2,FUNCT_1:9;
end;

definition
  let f be Function-yielding Function;
  canceled;
  redefine func Frege f -> ManySortedFunction of product doms f means
  :Def8:
  for g be Function st g in product doms f holds it.g = f..g;
  coherence
  proof
A1: dom Frege f = product doms f by FUNCT_6:def 7;
    Frege f is Function-yielding
    proof
      let x be set;
      assume
A2:   x in dom Frege f;
      then ex g being Function st x = g & dom g = dom doms f &
      for x st x in dom doms f holds g.x in (doms f).x by A1,CARD_3:def 5;
      then reconsider g = x as Function;
      ex h being Function st (Frege f).g = h & dom h = f"SubFuncs rng f &
      for x st x in dom h holds h.x = (uncurry f).(x,g.x)
      by A1,A2,FUNCT_6:def 7;
      hence (Frege f).x is Function;
    end;
    hence thesis by A1,PBOOLE:def 3;
  end;
  compatibility
  proof
    let F be ManySortedFunction of product doms f;
    for x being set holds x in rng f iff x in rng f & x is Function
    proof
      let y be set;
      y in rng f implies y is Function
      proof
        assume y in rng f;
        then ex x being set st x in dom f & y = f.x by FUNCT_1:def 5;
        hence y is Function;
      end;
      hence thesis;
    end;
    then
A3: SubFuncs rng f = rng f by FUNCT_6:def 1;
    thus F = Frege f implies
    for g be Function st g in product doms f holds F.g = f..g
    proof
      assume
A4:   F = Frege f;
      let g be Function;
      assume
A5:   g in product doms f;
      then consider h being Function such that
A6:   F.g = h and
A7:   dom h = f"SubFuncs rng f and
A8:   for x st x in dom h holds h.x = (uncurry f).(x,g.x) by A4,FUNCT_6:def 7;
A9:   dom h = dom f by A3,A7,RELAT_1:169;
      for x be set st x in dom f holds h.x = (f.x).(g.x)
      proof
        let x be set;
        assume
A10:    x in dom f;
        then x in dom doms f by A7,A9,FUNCT_6:def 2;
        then g.x in (doms f).x by A5,CARD_3:18;
        then
A11:    g.x in dom(f.x) by A10,FUNCT_6:31;
        thus h.x = f..(x,g.x) by A8,A9,A10
          .= (f.x).(g.x) by A10,A11,FUNCT_5:45;
      end;
      hence F.g = f..g by A6,A9,PRALG_1:def 17;
    end;
    assume
A12: for g be Function st g in product doms f holds F.g = f..g;
A13: dom F = product doms f by PBOOLE:def 3;
    for g being Function st g in product doms f ex h being Function st
    F.g = h & dom h = f"SubFuncs rng f &
    for x being set st x in dom h holds h.x = (uncurry f).(x,g.x)
    proof
      let g be Function such that
A14:  g in product doms f;
      take F.g;
      thus F.g = F.g;
      F.g = f..g by A12,A14;
      then
A15:  dom(F.g) = dom f by PRALG_1:def 17;
      hence
A16:  dom(F.g) = f"SubFuncs rng f by A3,RELAT_1:169;
      let x be set;
      assume
A17:  x in dom(F.g);
      then x in dom doms f by A16,FUNCT_6:def 2;
      then g.x in (doms f).x by A14,CARD_3:18;
      then
A18:  g.x in dom(f.x) by A15,A17,FUNCT_6:31;
      thus (F.g).x = (f..g).x by A12,A14
        .= (f.x).(g.x) by A15,A17,PRALG_1:def 17
        .= (uncurry f).(x,g.x) by A15,A17,A18,FUNCT_5:45;
    end;
    hence F = Frege f by A13,FUNCT_6:def 7;
  end;
end;

registration
  let I;
  let A,B be non-empty ManySortedSet of I;
  cluster [|A,B|] -> non-empty;
  coherence
  proof
    now
      let i;
      assume
A1:   i in I;
      then
A2:   [|A,B|].i = [:A.i,B.i:] by PBOOLE:def 21;
      A.i is non empty & B.i is non empty by A1,PBOOLE:def 16;
      hence [|A,B|].i is non empty by A2,ZFMISC_1:113;
    end;
    hence thesis by PBOOLE:def 16;
  end;
end;

theorem Th9:
  for I be non empty set, J be set, A,B be ManySortedSet of I,
  f be Function of J,I holds [|A,B|]*f = [|A*f,B*f|]
proof
  let I be non empty set, J be set, A,B be ManySortedSet of I,
  f be Function of J,I;
  for i st i in J holds ([|A,B|]*f).i = ([|A*f,B*f|]).i
  proof
    let i;
    assume
A1: i in J;
    then
A2: f.i in I by FUNCT_2:7;
A3: dom ([|A,B|]*f) = J & dom (A*f) = J & dom (B*f) = J by PBOOLE:def 3;
    hence ([|A,B|]*f).i = [|A,B|].(f.i) by A1,FUNCT_1:22
      .= [:A.(f.i),B.(f.i):] by A2,PBOOLE:def 21
      .= [:(A*f).i,B.(f.i):] by A1,A3,FUNCT_1:22
      .= [:(A*f).i,(B*f).i:] by A1,A3,FUNCT_1:22
      .= [|A*f,B*f|].i by A1,PBOOLE:def 21;
  end;
  hence thesis by PBOOLE:3;
end;

definition
  let I be non empty set,J;
  let A,B be non-empty ManySortedSet of I, p be Function of J,I*,
  r be Function of J,I, j be set, f be Function of (A# * p).j,(A*r).j,
  g be Function of (B# * p).j,(B*r).j;
  assume
A1: j in J;
  canceled;
  func [[:f,g:]] -> Function of ([|A,B|]# * p).j,([|A,B|]*r).j means
  for h be Function st h in ([|A,B|]#*p).j holds it.h = [f.(pr1 h),g.(pr2 h)];
  existence
  proof
    set Y = ([|A,B|]*r).j, X = ([|A,B|]# * p).j;
    defpred P[set,set] means
    for h be Function st h = $1 holds $2 = [f.(pr1 h),g.(pr2 h)];
A2: dom r = J & rng r c= I & dom p = J & rng p c= I*
    by FUNCT_2:def 1,RELSET_1:12;
    then
A3: r.j in rng r & p.j in rng p by A1,FUNCT_1:def 5;
    then reconsider rj = r.j as Element of I by A2;
    reconsider pj = p.j as Element of I* by A2,A3;
    dom ([|A,B|]#*p)= J & dom ([|A,B|]*r) = J by PBOOLE:def 3;
    then ([|A,B|]#*p).j = [|A,B|]#.pj & ([|A,B|]*r).j = ([|A,B|]).rj
    by A1,FUNCT_1:22;
    then
A4: X = product ([|A,B|]*pj) by PBOOLE:def 19;
A5: for x be set st x in X ex y be set st y in Y & P[x,y]
    proof
      let x be set;
      assume x in X;
      then consider h1 be Function such that
A6:   h1 = x & dom h1 = dom ([|A,B|]*pj) &
      for z be set st z in dom ([|A,B|]*pj) holds
      h1.z in ([|A,B|]*pj).z by A4,CARD_3:def 5;
      take y = [f.(pr1 h1),g.(pr2 h1)];
      dom (A#*p) = J & dom (A*r) = J & dom (B#*p) = J &
      dom (B*r) = J by PBOOLE:def 3;
      then
A7:   (A#*p).j = A#.pj & (A*r).j = A.rj & (B#*p).j = B#.pj &
      (B*r).j = B.rj by A1,FUNCT_1:22;
      then
A8:   (A#*p).j = product (A*pj) & (B#*p).j = product (B*pj) by PBOOLE:def 19;
A9:   dom f = (A#*p).j & rng f c= (A*r).j &
      dom g = (B#*p).j & rng g c= (B*r).j by A7,FUNCT_2:def 1,RELSET_1:12;
A10:  dom [|A,B|] = I & dom A = I & dom B = I by PBOOLE:def 3;
A11:  rng pj c= I by FINSEQ_1:def 4;
      then
A12:  dom h1 = dom pj by A6,A10,RELAT_1:46;
      then
A13:  dom (pr1 h1) = dom pj & dom (pr2 h1) = dom pj by MCART_1:def 12,def 13;
      then
A14:  dom (pr1 h1) = dom (A*pj) & dom (pr2 h1) = dom (B*pj)
      by A10,A11,RELAT_1:46;
      for z be set st z in dom (A*pj) holds (pr1 h1).z in (A*pj).z
      proof
        let z be set;
        assume
A15:    z in dom (A*pj);
        then
A16:    h1.z in ([|A,B|]*pj).z by A6,A12,A13,A14;
        dom ([|A,B|]*pj) = dom pj by A10,A11,RELAT_1:46;
        then
A17:    ([|A,B|]*pj).z = [|A,B|].(pj.z) by A13,A14,A15,FUNCT_1:22;
        pj.z in rng pj by A13,A14,A15,FUNCT_1:def 5;
        then h1.z in [:A.(pj.z),B.(pj.z):] by A11,A16,A17,PBOOLE:def 21;
        then consider a,b be set such that
A18:    a in A.(pj.z) & b in B.(pj.z) & h1.z = [a,b] by ZFMISC_1:def 2;
        (pr1 h1).z = (h1.z)`1 by A12,A13,A14,A15,MCART_1:def 12
          .= a by A18,MCART_1:def 1;
        hence thesis by A15,A18,FUNCT_1:22;
      end;
      then pr1 h1 in product (A*pj) by A14,CARD_3:18;
      then
A19:  f.(pr1 h1) in rng f by A8,A9,FUNCT_1:def 5;
      dom (pr2 h1) = dom pj by A12,MCART_1:def 13;
      then
A20:  dom (pr2 h1) = dom (B*pj) by A10,A11,RELAT_1:46;
      for z be set st z in dom (B*pj) holds (pr2 h1).z in (B*pj).z
      proof
        let z be set;
        assume
A21:    z in dom (B*pj);
        then
A22:    h1.z in ([|A,B|]*pj).z by A6,A12,A13,A14;
        dom ([|A,B|]*pj) = dom pj by A10,A11,RELAT_1:46;
        then
A23:    ([|A,B|]*pj).z = [|A,B|].(pj.z) by A13,A14,A21,FUNCT_1:22;
        pj.z in rng pj by A13,A14,A21,FUNCT_1:def 5;
        then h1.z in [:A.(pj.z),B.(pj.z):] by A11,A22,A23,PBOOLE:def 21;
        then consider a,b be set such that
A24:    a in A.(pj.z) & b in B.(pj.z) & h1.z = [a,b] by ZFMISC_1:def 2;
        (pr2 h1).z = (h1.z)`2 by A12,A13,A14,A21,MCART_1:def 13
          .= b by A24,MCART_1:def 2;
        hence thesis by A21,A24,FUNCT_1:22;
      end;
      then pr2 h1 in product (B*pj) by A20,CARD_3:18;
      then g.(pr2 h1) in rng g by A8,A9,FUNCT_1:def 5;
      then [f.(pr1 h1),g.(pr2 h1)] in [:(A*r).j,(B*r).j:]
      by A9,A19,ZFMISC_1:106;
      then [f.(pr1 h1),g.(pr2 h1)] in [|A*r,B*r|].j by A1,PBOOLE:def 21;
      hence y in Y by Th9;
      let h be Function;
      assume x = h;
      hence thesis by A6;
    end;
    consider F being Function of X,Y such that
A25: for x be set st x in X holds P[x,F.x] from FUNCT_2:sch 1(A5);
    take F;
    thus thesis by A25;
  end;
  uniqueness
  proof
    let x,y be Function of (([|A,B|])#*p).j,([|A,B|]*r).j such that
A26: for h be Function st h in ([|A,B|]#*p).j
    holds x.h = [f.(pr1 h),g.(pr2 h)] and
A27: for h be Function st h in ([|A,B|]#*p).j
    holds y.h = [f.(pr1 h),g.(pr2 h)];
A28: dom r = J & rng r c= I & dom p = J & rng p c= I*
    by FUNCT_2:def 1,RELSET_1:12;
    then
A29: r.j in rng r & p.j in rng p by A1,FUNCT_1:def 5;
    then reconsider rj = r.j as Element of I by A28;
    reconsider pj = p.j as Element of I* by A28,A29;
    dom ([|A,B|]#*p) = J & dom ([|A,B|]*r)=J by PBOOLE:def 3;
    then
A30: ([|A,B|]#*p).j = [|A,B|]#.pj & ([|A,B|]*r).j = ([|A,B|]).rj
    by A1,FUNCT_1:22;
    then
A31: (dom x = ([|A,B|]#*p).j) & dom y = ([|A,B|]#*p).j by FUNCT_2:def 1;
    now
      let h be set;
      assume
A32:  h in ([|A,B|]#*p).j;
      then h in product ([|A,B|]*pj) by A30,PBOOLE:def 19;
      then consider h1 be Function such that
A33:  h1 = h and dom h1 = dom ([|A,B|]*pj) &
      for z be set st z in dom ([|A,B|]*pj) holds
      h1.z in ([|A,B|]*pj).z by CARD_3:def 5;
      x.h1 = [f.(pr1 h1),g.(pr2 h1)] &
      y.h1 = [f.(pr1 h1),g.(pr2 h1)] by A26,A27,A32,A33;
      hence x.h = y.h by A33;
    end;
    hence thesis by A31,FUNCT_1:9;
  end;
end;

definition
  let I be non empty set,J;
  let A,B be non-empty ManySortedSet of I, p be Function of J,I*,
  r be Function of J,I, F be ManySortedFunction of A#*p,A*r,
  G be ManySortedFunction of B#*p,B*r;
  func [[:F,G:]] -> ManySortedFunction of [|A,B|]#*p,[|A,B|]*r means
  for j st j in J for f be Function of (A#*p).j,(A*r).j,
  g be Function of (B#*p).j,(B*r).j
  st f = F.j & g = G.j holds it.j = [[:f,g:]];
  existence
  proof
    defpred P[set,set] means for f be Function of (A#*p).$1,(A*r).$1,
    g be Function of (B#*p).$1,(B*r).$1
    st f = F.$1 & g = G.$1 holds $2 = [[:f,g:]];
A1: for j st j in J ex i st P[j,i]
    proof
      let j;
      assume
A2:   j in J;
      then reconsider f = F.j as Function of (A#*p).j,(A*r).j
      by PBOOLE:def 18;
      reconsider g = G.j as Function of (B#*p).j,(B*r).j by A2,PBOOLE:def 18;
      take [[:f,g:]];
      thus thesis;
    end;
    consider h being Function such that
A3: dom h = J & for j st j in J holds P[j,h.j] from CLASSES1:sch 1(A1);
    reconsider h as ManySortedSet of J by A3,PBOOLE:def 3;
    for j st j in dom h holds h.j is Function
    proof
      let j;
      assume
A4:   j in dom h;
      then reconsider f = F.j as Function of (A#*p).j,(A*r).j
      by A3,PBOOLE:def 18;
      reconsider g = G.j as Function of (B#*p).j,(B*r).j
      by A3,A4,PBOOLE:def 18;
      h.j = [[:f,g:]] by A3,A4;
      hence thesis;
    end;
    then reconsider h as ManySortedFunction of J by FUNCOP_1:def 6;
    for j st j in J holds h.j is Function of ([|A,B|]#*p).j,([|A,B|]*r).j
    proof
      let j;
      assume
A5:   j in J;
      then reconsider f = F.j as Function of (A#*p).j,(A*r).j
      by PBOOLE:def 18;
      reconsider g = G.j as Function of (B#*p).j,(B*r).j by A5,PBOOLE:def 18;
      h.j = [[:f,g:]] by A3,A5;
      hence thesis;
    end;
    then reconsider h as ManySortedFunction of [|A,B|]#*p,[|A,B|]*r
    by PBOOLE:def 18;
    take h;
    thus thesis by A3;
  end;
  uniqueness
  proof
    let x,y be ManySortedFunction of [|A,B|]#*p,[|A,B|]*r;
    assume that
A6: for j st j in J for f be Function of (A#*p).j,(A*r).j, g be Function of
    (B#*p).j,(B*r).j st f = F.j & g = G.j holds x.j = [[:f,g:]] and
A7: for j st j in J for f be Function of (A#*p).j,(A*r).j, g be Function of
    (B#*p).j,(B*r).j st f = F.j & g = G.j holds y.j = [[:f,g:]];
    for j be set st j in J holds x.j = y.j
    proof
      let j;
      assume
A8:   j in J;
      then reconsider f = F.j as Function of (A#*p).j,(A*r).j
      by PBOOLE:def 18;
      reconsider g = G.j as Function of (B#*p).j,(B*r).j by A8,PBOOLE:def 18;
      x.j = [[:f,g:]] & y.j = [[:f,g:]] by A6,A7,A8;
      hence thesis;
    end;
    hence thesis by PBOOLE:3;
  end;
end;

begin

::
:: Family of Many Sorted Universal Algebras
::

definition
  let I,S;
  mode MSAlgebra-Family of I,S -> ManySortedSet of I means
    :Def12:
    for i st i in I holds it.i is non-empty MSAlgebra over S;
  existence
  proof
    consider A be non-empty MSAlgebra over S;
    set f = I --> A;
    dom f = I & for i st i in I holds f.i = A by FUNCOP_1:13,19;
    then reconsider f as ManySortedSet of I by PBOOLE:def 3;
    take f;
    let i;
    assume i in I;
    hence thesis by FUNCOP_1:13;
  end;
end;

definition
  let I be non empty set, S;
  let A be MSAlgebra-Family of I,S, i be Element of I;
  redefine func A.i -> non-empty MSAlgebra over S;
  coherence by Def12;
end;

definition
  let S be non empty ManySortedSign, U1 be MSAlgebra over S;
  func |.U1.| -> set equals

  union (rng the Sorts of U1);
  coherence;
end;

registration
  let S be non empty ManySortedSign, U1 be non-empty MSAlgebra over S;
  cluster |.U1.| -> non empty;
  coherence
  proof
    consider s be SortSymbol of S;
    reconsider St = the Sorts of U1 as non-empty
    ManySortedSet of the carrier of S;
    dom (the Sorts of U1) = the carrier of S by PBOOLE:def 3;
    then
A1: (the Sorts of U1).s in rng (the Sorts of U1) by FUNCT_1:def 5;
    consider x such that
A2: x in St.s by XBOOLE_0:def 1;
    thus thesis by A1,A2,TARSKI:def 4;
  end;
end;

definition
  let I be non empty set, S be non empty ManySortedSign,
  A be MSAlgebra-Family of I,S;
  func |.A.| -> set equals
  union {|.A.i.| where i is Element of I: not contradiction};
  coherence;
end;

registration
  let I be non empty set, S be non empty ManySortedSign,
  A be MSAlgebra-Family of I,S;
  cluster |.A.| -> non empty;
  coherence
  proof
    set X = {|.A.i.| where i is Element of I: not contradiction};
    consider a be Element of I;
A1: |.A.a.| in X;
    consider x such that
A2: x in |.A.a.| by XBOOLE_0:def 1;
    thus thesis by A1,A2,TARSKI:def 4;
  end;
end;

begin

::
:: Product of Many Sorted Universal Algebras
::

theorem Th10:
  for S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  o be OperSymbol of S holds
  Args(o,U0) = product ((the Sorts of U0)*(the_arity_of o)) &
  dom ((the Sorts of U0)*(the_arity_of o)) = dom (the_arity_of o)
  & Result(o,U0) = (the Sorts of U0).(the_result_sort_of o)
proof
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  o be OperSymbol of S;
  set So = the Sorts of U0, Ar = the Arity of S, Rs = the ResultSort of S,
  ar = the_arity_of o, AS = So# * Ar, RS = So * Rs, X = the OperSymbols of S,
  Cr = the carrier of S;
A1: X <> {} by MSUALG_1:def 5;
A2: dom Ar = X & rng Ar c= Cr* by FUNCT_2:def 1,RELSET_1:12;
  then
A3: dom AS = dom Ar by PBOOLE:def 3;
  thus Args(o,U0) = AS.o by MSUALG_1:def 9
    .=(So# qua ManySortedSet of Cr*).(Ar.o) by A1,A2,A3,FUNCT_1:22
    .=((So)# qua ManySortedSet of Cr*).(the_arity_of o) by MSUALG_1:def 6
    .= product ((So)*(the_arity_of o)) by PBOOLE:def 19;
  rng ar c= Cr & dom So = Cr by FINSEQ_1:def 4,PBOOLE:def 3;
  hence dom (So*ar) = dom ar by RELAT_1:46;
A4: dom Rs = X & rng Rs c= Cr by FUNCT_2:def 1,RELSET_1:12;
  then
A5: dom RS = dom Rs by PBOOLE:def 3;
  thus Result(o,U0) = RS.o by MSUALG_1:def 10
    .= So.(Rs.o) by A1,A4,A5,FUNCT_1:22
    .= So.the_result_sort_of o by MSUALG_1:def 7;
end;

theorem Th11:
  for S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  o be OperSymbol of S st the_arity_of o = {} holds Args(o,U0) = {{}}
proof
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  o be OperSymbol of S;
  assume
A1: the_arity_of o = {};
  thus Args(o,U0) = product ((the Sorts of U0)*(the_arity_of o)) by Th10
    .= {{}} by A1,CARD_3:19,RELAT_1:62;
end;

definition
  let S;
  let U1,U2 be non-empty MSAlgebra over S;
  func [:U1,U2:] -> MSAlgebra over S equals
  MSAlgebra (# [|the Sorts of U1,the Sorts of U2|],
    [[:the Charact of U1,the Charact of U2:]] #);
  coherence;
end;

registration
  let S;
  let U1,U2 be non-empty MSAlgebra over S;
  cluster [:U1,U2:] -> strict;
  coherence;
end;

definition
  let I,S;
  let s be SortSymbol of S, A be MSAlgebra-Family of I,S;
  func Carrier (A,s) -> ManySortedSet of I means
  :Def16:
  for i be set st i in I ex U0 being MSAlgebra over S st U0 = A.i &
  it.i = (the Sorts of U0).s if I <> {} otherwise it = {};
  existence
  proof
    hereby
      assume I <> {};
      then reconsider I' = I as non empty set;
      reconsider A' = A as MSAlgebra-Family of I',S;
      deffunc F(Element of I') = (the Sorts of (A'.$1)).s;
      consider f be Function such that
A1:   dom f = I' & for i be Element of I' holds f.i = F(i) from FUNCT_1:sch 4;
      reconsider f as ManySortedSet of I by A1,PBOOLE:def 3;
      take f;
      let i be set;
      assume i in I;
      then reconsider i' = i as Element of I';
      reconsider U0 = A'.i' as MSAlgebra over S;
      take U0;
      thus U0 = A.i & f.i = (the Sorts of U0).s by A1;
    end;
    assume
A2: I = {};
    take [0]I;
    thus thesis by A2,PBOOLE:134;
  end;
  uniqueness
  proof
    let f,g be ManySortedSet of I;
    hereby
      assume I <> {};
      assume that
A3:   for i be set st i in I ex U0 being MSAlgebra over S st U0 = A.i &
      f.i = (the Sorts of U0).s and
A4:   for i be set st i in I ex U0 being MSAlgebra over S st U0 = A.i &
      g.i = (the Sorts of U0).s;
      for x be set st x in I holds f.x = g.x
      proof
        let x be set;
        assume
A5:     x in I;
        then reconsider i = x as Element of I;
        (ex U0 being MSAlgebra over S st U0 = A.i & f.i = (the Sorts of U0).s)
        &
        (ex U0 being MSAlgebra over S st U0 = A.i & g.i = (the Sorts of U0).s)
        by A3,A4,A5;
        hence thesis;
      end;
      hence f = g by PBOOLE:3;
    end;
    thus thesis;
  end;
  correctness;
end;

registration
  let I,S;
  let s be SortSymbol of S, A be MSAlgebra-Family of I,S;
  cluster Carrier (A,s) -> non-empty;
  coherence
  proof
    let x be set;
    assume
A1: x in I;
    then consider U0 being MSAlgebra over S such that
A2: U0 = A.x & Carrier (A,s).x = (the Sorts of U0).s by Def16;
    U0 is non-empty MSAlgebra over S by A1,A2,Def12;
    then the Sorts of U0 is non-empty by MSUALG_1:def 8;
    hence Carrier (A,s).x is non empty by A2,PBOOLE:def 16;
  end;
end;

definition
  let I,S;
  let A be MSAlgebra-Family of I,S;
  func SORTS(A) -> ManySortedSet of the carrier of S means
  :Def17:
  for s be SortSymbol of S holds it.s = product Carrier(A,s);
  existence
  proof
    deffunc F(SortSymbol of S) = product Carrier(A,$1);
    consider f be Function such that
A1: dom f = the carrier of S &
    for s be SortSymbol of S holds f.s = F(s) from FUNCT_1:sch 4;
    reconsider f as ManySortedSet of (the carrier of S) by A1,PBOOLE:def 3;
    take f;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let f,g be ManySortedSet of (the carrier of S);
    assume that
A2: for s be SortSymbol of S holds f.s = product Carrier(A,s) and
A3: for s be SortSymbol of S holds g.s = product Carrier(A,s);
    for x be set st x in the carrier of S holds f.x = g.x
    proof
      let x be set;
      assume x in the carrier of S;
      then reconsider x1 = x as SortSymbol of S;
      f.x1= product Carrier(A,x1) & g.x1 = product Carrier(A,x1) by A2,A3;
      hence thesis;
    end;
    hence thesis by PBOOLE:3;
  end;
end;

registration
  let I, S;
  let A be MSAlgebra-Family of I,S;
  cluster SORTS(A) -> non-empty;
  coherence
  proof
    let x be set;
    assume x in the carrier of S;
    then reconsider s = x as SortSymbol of S;
    (SORTS A).s = product Carrier(A,s) by Def17;
    hence thesis;
  end;
end;

definition
  let I;
  let S be non empty ManySortedSign, A be MSAlgebra-Family of I,S;
  func OPER(A) -> ManySortedFunction of I means
  :Def18:
  for i be set st i in I
  ex U0 being MSAlgebra over S st U0 = A.i & it.i = the Charact of U0
  if I <> {} otherwise it = {};
  existence
  proof
    hereby
      assume I <> {};
      then reconsider I' = I as non empty set;
      reconsider A' = A as MSAlgebra-Family of I',S;
      deffunc F(Element of I') = the Charact of A'.$1;
      consider X be ManySortedSet of I' such that
A1:   for i be Element of I' holds X.i = F(i) from PBOOLE:sch 5;
      for x st x in dom X holds X.x is Function
      proof
        let x;
        assume x in dom X;
        then reconsider i = x as Element of I' by PBOOLE:def 3;
        X.i = the Charact of A'.i by A1;
        hence thesis;
      end;
      then reconsider X as ManySortedFunction of I by FUNCOP_1:def 6;
      take X;
      let i be set;
      assume i in I;
      then reconsider i' = i as Element of I';
      reconsider U0 = A'.i' as MSAlgebra over S;
      take U0;
      thus U0 = A.i & X.i = the Charact of U0 by A1;
    end;
    assume
A2: I = {};
    [0]I is Function-yielding
    proof
      let i be set;
      assume i in dom[0]I;
      hence [0]I.i is Function by A2,PBOOLE:def 3;
    end;
    then reconsider f = [0]I as ManySortedFunction of I;
    take f;
    thus thesis by A2,PBOOLE:134;
  end;
  uniqueness
  proof
    let f,g be ManySortedFunction of I;
    hereby
      assume I <> {};
      assume that
A3:   for i be set st i in I
      ex U0 being MSAlgebra over S st U0 = A.i & f.i = the Charact of U0 and
A4:   for i be set st i in I
      ex U0 being MSAlgebra over S st U0 = A.i & g.i = the Charact of U0;
      for x st x in I holds f.x = g.x
      proof
        let x;
        assume
A5:     x in I;
        then reconsider i = x as Element of I;
        (ex U0 being MSAlgebra over S st U0 = A.i & f.i = the Charact of U0) &
        (ex U0 being MSAlgebra over S st U0 = A.i & g.i = the Charact of U0)
        by A3,A4,A5;
        hence thesis;
      end;
      hence f = g by PBOOLE:3;
    end;
    thus thesis;
  end;
  correctness;
end;

theorem Th12:
  for S be non empty ManySortedSign, A be MSAlgebra-Family of I,S holds
  dom uncurry (OPER A) = [:I,the OperSymbols of S:]
proof
  let S be non empty ManySortedSign, A be MSAlgebra-Family of I,S;
  per cases;
  suppose
A1: I <> {};
    thus dom uncurry (OPER A) c= [:I,the OperSymbols of S:]
    proof
      let t be set;
      assume t in dom uncurry (OPER A);
      then consider x be set,g be Function,y be set such that
A2:   t = [x,y] & x in dom (OPER A) & g = (OPER A).x & y in dom g
      by FUNCT_5:def 4;
      reconsider x as Element of I by A2,PBOOLE:def 3;
      consider U0 being MSAlgebra over S such that
A3:   U0 = A.x & (OPER A).x = the Charact of U0 by A1,Def18;
      x in I & y in the OperSymbols of S by A2,A3,PBOOLE:def 3;
      hence thesis by A2,ZFMISC_1:106;
    end;
    let x;
    assume
A4: x in [:I,the OperSymbols of S:];
    then consider y,z be set such that
A5: x = [y,z] by RELAT_1:def 1;
    reconsider y as Element of I by A4,A5,ZFMISC_1:106;
A6: z in the OperSymbols of S by A4,A5,ZFMISC_1:106;
    consider U0 being MSAlgebra over S such that
A7: U0 = A.y & (OPER A).y = the Charact of U0 by A1,Def18;
A8: dom (the Charact of U0) = the OperSymbols of S by PBOOLE:def 3;
    dom (OPER A) = I by PBOOLE:def 3;
    hence thesis by A1,A5,A6,A7,A8,FUNCT_5:def 4;
  end;
  suppose
A9: I = {};
    then OPER A = {} by PBOOLE:134;
    hence thesis by A9,FUNCT_5:50,RELAT_1:60,ZFMISC_1:113;
  end;
end;

theorem Th13:
  for I be non empty set, S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S, o be OperSymbol of S holds
  commute (OPER A) in Funcs(the OperSymbols of S,
  Funcs(I,rng uncurry (OPER A)))
proof
  let I be non empty set, S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S, o be OperSymbol of S;
  set f = uncurry (OPER A);
  the OperSymbols of S <> {} by MSUALG_1:def 5;
  then
A1: [:I,the OperSymbols of S:] <> {} by ZFMISC_1:113;
  dom f = [:I,the OperSymbols of S:] by Th12;
  then f in Funcs([:I,the OperSymbols of S:],rng f) by FUNCT_2:def 2;
  hence thesis by A1,FUNCT_6:19;
end;

definition
  let I be set, S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S, o be OperSymbol of S;
  func A?.o -> ManySortedFunction of I equals

  (commute (OPER A)).o;
  coherence
  proof
    set f = uncurry (OPER A), C = commute (OPER A);
A1: the OperSymbols of S <> {} by MSUALG_1:def 5;
A2: dom f = [:I,the OperSymbols of S:] by Th12;
    per cases;
    suppose
A3:   I <> {};
      then C in Funcs(the OperSymbols of S,Funcs(I,rng f)) by Th13;
      then consider a be Function such that
A4:   a = C & dom a = the OperSymbols of S & rng a c= Funcs(I,rng f)
      by FUNCT_2:def 2;
      C.o in rng C by A1,A4,FUNCT_1:def 5;
      then consider g be Function such that
A5:   g = C.o & dom g = I & rng g c= rng f by A4,FUNCT_2:def 2;
      reconsider g as ManySortedSet of I by A5,PBOOLE:def 3;
      for x st x in dom g holds g.x is Function
      proof
        let x;
        assume x in dom g;
        then reconsider i = x as Element of I by A5;
A6:     [i,o] in dom f by A1,A2,A3,ZFMISC_1:106;
        then
A7:     i in dom g & g.i = f.(i,o) by A5,FUNCT_5:29;
A8:     [i,o]`1 = i & [i,o]`2 = o by MCART_1:def 1,def 2;
        consider U0 being MSAlgebra over S such that
A9:     U0 = A.i & (OPER A).i = the Charact of U0 by A3,Def18;
        g.i = (the Charact of U0).o by A6,A7,A8,A9,FUNCT_5:def 4
          .= Den(o,U0) by MSUALG_1:def 11;
        hence thesis;
      end;
      hence thesis by A5,FUNCOP_1:def 6;
    end;
    suppose
A10:  I = {};
      [0]I is Function-yielding
      proof
        let i be set;
        assume i in dom[0]I;
        hence [0]I.i is Function by A10,PBOOLE:def 3;
      end;
      then reconsider f = [0]I as ManySortedFunction of I;
A11:  not o in dom {};
      f = {} by A10,PBOOLE:134
        .= (commute {}).o by A11,FUNCT_1:def 4,FUNCT_6:88
        .= (commute (OPER A)).o by A10,PBOOLE:134;
      hence thesis;
    end;
  end;
end;

theorem Th14:
  for I be non empty set, i be Element of I,
  S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S, o be OperSymbol of S holds
  (A?.o).i = Den(o,A.i)
proof
  let I be non empty set, i be Element of I,
  S be non void non empty ManySortedSign, A be MSAlgebra-Family of I,S,
  o be OperSymbol of S;
  set O = the OperSymbols of S, f = uncurry (OPER A);
A1: O <> {} by MSUALG_1:def 5;
  then
A2: [:I,O:] <> {} by ZFMISC_1:113;
A3: dom f = [:I,O:] by Th12;
  then consider g be Function such that
A4: (curry' f).o = g & dom g = I & rng g c= rng f &
  for x st x in I holds g.x = f.(x,o) by A1,A2,FUNCT_5:39;
A5: [i,o] in dom f by A1,A3,ZFMISC_1:106;
A6: i in dom g & g.i = f.(i,o) by A4;
A7: [i,o]`1 = i & [i,o]`2 = o by MCART_1:def 1,def 2;
  ex U0 being MSAlgebra over S st U0 = A.i & (OPER A).i = the Charact of U0
  by Def18;
  then g.i = (the Charact of A.i).o by A5,A6,A7,FUNCT_5:def 4
    .= Den(o,A.i) by MSUALG_1:def 11;
  hence thesis by A4;
end;

theorem
  for I be non empty set, S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S, o be OperSymbol of S, x be set
  st x in rng (Frege (A?.o)) holds x is Function
proof
  let I be non empty set, S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S, o be OperSymbol of S, x be set;
  assume x in rng (Frege (A?.o));
  then ex y be set st
  y in dom (Frege (A?.o)) & (Frege (A?.o)).y = x by FUNCT_1:def 5;
  hence thesis;
end;

theorem Th16:
  for I be non empty set, S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S, o be OperSymbol of S,
  f be Function st f in rng (Frege (A?.o)) holds
  dom f = I & for i be Element of I holds f.i in Result(o,A.i)
proof
  let I be non empty set, S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S, o be OperSymbol of S, f be Function;
  assume f in rng (Frege (A?.o));
  then consider y be set such that
A1: y in dom (Frege (A?.o)) & (Frege (A?.o)).y = f by FUNCT_1:def 5;
A2: dom (Frege (A?.o)) = product doms (A?.o) by PBOOLE:def 3;
  then consider g be Function such that
A3: g = y & dom g = dom doms (A?.o) & for i st i in dom doms (A?.o)
  holds g.i in (doms (A?.o)).i by A1,CARD_3:def 5;
A4: f = (A?.o)..g by A1,A2,A3,Def8;
  hence dom f = dom (A?.o) by PRALG_1:def 17
    .= I by PBOOLE:def 3;
A5: dom (A?.o) = I by PBOOLE:def 3;
  let i be Element of I;
A6: (A?.o).i = Den(o,A.i) by Th14;
  then
A7: f.i = Den(o,A.i).(g.i) by A4,A5,PRALG_1:def 17;
A8: SubFuncs rng (A?.o) = rng (A?.o)
  proof
    thus SubFuncs rng (A?.o) c= rng (A?.o) by FUNCT_6:27;
    let x;
    assume
A9: x in rng (A?.o);
    then ex j st j in dom (A?.o) & x = (A?.o).j by FUNCT_1:def 5;
    hence thesis by A9,FUNCT_6:def 1;
  end;
  dom doms(A?.o)= (A?.o)"(SubFuncs rng (A?.o)) by FUNCT_6:def 2
    .= dom (A?.o) by A8,RELAT_1:169;
  then g.i in (doms (A?.o)).i by A3,A5;
  then g.i in dom Den(o,A.i) by A5,A6,FUNCT_6:31;
  then f.i in rng Den(o,A.i) & rng Den(o,A.i) c= Result(o,A.i)
  by A7,FUNCT_1:def 5,RELSET_1:12;
  hence thesis;
end;

theorem Th17:
  for I be non empty set, S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S, o be OperSymbol of S,
  f be Function st f in dom (Frege (A?.o)) holds
  dom f = I & (for i be Element of I holds f.i in Args(o,A.i)) &
  rng f c= Funcs(dom(the_arity_of o),|.A.|)
proof
  let I be non empty set, S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S, o be OperSymbol of S, f be Function;
  assume
A1: f in dom (Frege (A?.o));
A2: dom (Frege (A?.o)) = product doms (A?.o) by PBOOLE:def 3;
A3: dom (A?.o) = I by PBOOLE:def 3;
A4: SubFuncs rng (A?.o) = rng (A?.o)
  proof
    thus SubFuncs rng (A?.o) c= rng (A?.o) by FUNCT_6:27;
    let x;
    assume
A5: x in rng (A?.o);
    then ex j st j in dom (A?.o) & x = (A?.o).j by FUNCT_1:def 5;
    hence thesis by A5,FUNCT_6:def 1;
  end;
A6: dom doms (A?.o) = (A?.o)"(SubFuncs rng (A?.o)) by FUNCT_6:def 2
    .= dom (A?.o) by A4,RELAT_1:169;
  hence dom f = I by A1,A2,A3,CARD_3:18; thus
A7: for i be Element of I holds f.i in Args(o,A.i)
  proof
    let i be Element of I;
A8: (A?.o).i = Den(o,A.i) by Th14;
    f.i in (doms(A?.o)).i by A1,A2,A3,A6,CARD_3:18;
    then f.i in dom Den(o,A.i) by A3,A8,FUNCT_6:31;
    hence thesis by FUNCT_2:def 1;
  end;
  let x;
  assume x in rng f;
  then consider y be set such that
A9: y in dom f & x = f.y by FUNCT_1:def 5;
  reconsider y as Element of I by A1,A2,A3,A6,A9,CARD_3:18;
A10: x in Args(o,A.y) by A7,A9;
  set X = the OperSymbols of S, AS = (the Sorts of A.y)# * the Arity of S,
  Ar = the Arity of S, Cr = the carrier of S, So = the Sorts of A.y,
  a = the_arity_of o;
A11: X <> {} by MSUALG_1:def 5;
A12: dom Ar = X & rng Ar c= Cr* by FUNCT_2:def 1,RELSET_1:12;
  then
A13: dom AS = dom Ar by PBOOLE:def 3;
  Args(o,A.y) = AS.o by MSUALG_1:def 9
    .= (So# qua ManySortedSet of Cr*).(Ar.o) by A11,A12,A13,FUNCT_1:22
    .=(So# qua ManySortedSet of Cr*).(the_arity_of o) by MSUALG_1:def 6
    .= product (So*(the_arity_of o)) by PBOOLE:def 19;
  then consider g be Function such that
A14: g = x & dom g = dom (So*a)
  & for i st i in dom (So * a) holds g.i in (So * a).i by A10,CARD_3:def 5;
A15: dom a = dom a & rng a c= Cr by FINSEQ_1:def 4;
A16: dom So = Cr by PBOOLE:def 3;
  then
A17: dom (So * a) = dom a & rng (So * a) c= rng So by A15,RELAT_1:45,46;
A18: rng g c= |.A.y.|
  proof
    let i;
    assume i in rng g;
    then consider j such that
A19: j in dom g & g.j = i by FUNCT_1:def 5;
    i in (So * a).j by A14,A19;
    then
A20: i in So.(a.j) by A14,A19,FUNCT_1:22;
    a.j in rng a by A14,A17,A19,FUNCT_1:def 5;
    then So.(a.j) in rng So by A15,A16,FUNCT_1:def 5;
    hence thesis by A20,TARSKI:def 4;
  end;
  |.A.y.| in {|.A.i.| where i is Element of I:not contradiction};
  then |.A.y.| c= union {|.A.i.| where i is Element of I: not contradiction}
  by ZFMISC_1:92;
  then rng g c= |.A.| by A18,XBOOLE_1:1;
  hence thesis by A14,A17,FUNCT_2:def 2;
end;

theorem Th18:
  for I be non empty set, S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S, o be OperSymbol of S holds
  dom doms (A?.o) = I &
  for i be Element of I holds (doms (A?.o)).i = Args(o,A.i)
proof
  let I be non empty set, S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S, o be OperSymbol of S;
A1: dom (A?.o) = I by PBOOLE:def 3;
  SubFuncs rng (A?.o) = rng (A?.o)
  proof
    thus SubFuncs rng (A?.o) c= rng (A?.o) by FUNCT_6:27;
    let x;
    assume
A2: x in rng (A?.o);
    then ex j st j in dom (A?.o) & x = (A?.o).j by FUNCT_1:def 5;
    hence thesis by A2,FUNCT_6:def 1;
  end;
  then
A3: (A?.o)"(SubFuncs rng (A?.o))= dom (A?.o) by RELAT_1:169
    .= I by PBOOLE:def 3;
  for i be Element of I holds (doms (A?.o)).i = Args(o,A.i)
  proof
    let i be Element of I;
    (A?.o).i = Den(o,A.i) by Th14;
    then (doms (A?.o)).i = dom (Den(o,A.i)) by A1,FUNCT_6:31;
    hence thesis by FUNCT_2:def 1;
  end;
  hence thesis by A3,FUNCT_6:def 2;
end;

definition
  let I;
  let S be non void non empty ManySortedSign, A be MSAlgebra-Family of I,S;
  func OPS(A) -> ManySortedFunction of
  (SORTS A)# * the Arity of S, (SORTS A) * the ResultSort of S means
  for o be OperSymbol of S holds
  it.o=IFEQ(the_arity_of o,{},commute(A?.o),Commute Frege(A?.o)) if I <> {}
  otherwise not contradiction;
  existence
  proof
    set X = the OperSymbols of S, AS = (SORTS A)# * the Arity of S,
    RS = (SORTS A) * the ResultSort of S;
    defpred P[set,set] means for o be OperSymbol of S st $1 = o holds
    $2 = IFEQ(the_arity_of o,{},commute(A?.o), Commute Frege(A?.o));
A1: for x st x in X ex y be set st P[x,y]
    proof
      let x;
      assume x in X;
      then reconsider o = x as OperSymbol of S;
      take IFEQ(the_arity_of o,{},commute(A?.o), Commute Frege (A?.o));
      let o1 be OperSymbol of S;
      assume x = o1;
      hence thesis;
    end;
    consider f being Function such that
A2: dom f = X & for x st x in X holds P[x,f.x] from CLASSES1:sch 1(A1);
    reconsider f as ManySortedSet of X by A2,PBOOLE:def 3;
    for x st x in dom f holds f.x is Function
    proof
      let x;
      assume
A3:   x in dom f;
      then reconsider o = x as OperSymbol of S by A2;
      per cases;
      suppose
A4:     the_arity_of o = {};
        f.x = IFEQ(the_arity_of o,{},commute(A?.o),
        Commute Frege(A?.o)) by A2,A3
          .= commute(A?.o) by A4,FUNCOP_1:def 8;
        hence thesis;
      end;
      suppose
A5:     the_arity_of o <> {};
        f.x = IFEQ(the_arity_of o,{},commute(A?.o),
        Commute Frege (A?.o)) by A2,A3
          .= Commute Frege (A?.o) by A5,FUNCOP_1:def 8;
        hence thesis;
      end;
    end;
    then reconsider f as ManySortedFunction of X by FUNCOP_1:def 6;
    hereby
      assume I <> {};
      then reconsider I' = I as non empty set;
      reconsider A' = A as MSAlgebra-Family of I',S;
      for x st x in X holds f.x is Function of AS.x,RS.x
      proof
        let x;
        assume
A6:     x in X;
        then reconsider o = x as OperSymbol of S;
        set C = Commute Frege (A?.o), F = Frege (A?.o), Ar = the Arity of S,
        Rs = the ResultSort of S, Cr = the carrier of S, co = commute (A?.o);
A7:     dom Ar = X & rng Ar c= Cr* by FUNCT_2:def 1,RELSET_1:12;
        then dom AS = dom Ar by PBOOLE:def 3;
        then
A8:     AS.o = ((SORTS A)# qua ManySortedSet of Cr*).(Ar.o)
        by A6,A7,FUNCT_1:22
          .=((SORTS A)# qua ManySortedSet of Cr*).(the_arity_of o)
        by MSUALG_1:def 6
          .= product ((SORTS A)*(the_arity_of o)) by PBOOLE:def 19;
        set ar = the_arity_of o;
A9:     dom ar=dom ar & rng ar c= Cr by FINSEQ_1:def 4;
        dom (SORTS A) = Cr by PBOOLE:def 3;
        then
A10:    dom ((SORTS A)*ar) = dom ar by A9,RELAT_1:46;
A11:    dom Rs = X & rng Rs c= Cr by FUNCT_2:def 1,RELSET_1:12;
        then dom RS = dom Rs by PBOOLE:def 3;
        then
A12:    RS.o = (SORTS A).(Rs.o) by A6,A11,FUNCT_1:22
          .= (SORTS A).(the_result_sort_of o) by MSUALG_1:def 7
          .= product Carrier(A,the_result_sort_of o) by Def17;
        per cases;
        suppose
A13:      the_arity_of o = {};
A14:      f.x = IFEQ(the_arity_of o,{},commute(A?.o),
          Commute Frege (A?.o))by A2,A6
            .= commute(A?.o) by A13,FUNCOP_1:def 8;
A15:      AS.o = {{}} by A8,A13,CARD_3:19,RELAT_1:62;
A16:      dom (A?.o) = I by PBOOLE:def 3;
          set rs = the_result_sort_of o;
          rng (A?.o) c= Funcs({{}},|.A'.|)
          proof
            let j;
            assume j in rng (A?.o);
            then consider a be set such that
A17:        a in dom (A?.o) & (A?.o).a = j by FUNCT_1:def 5;
            reconsider i = a as Element of I' by A17,PBOOLE:def 3;
A18:        j = Den(o,A'.i) by A17,Th14;
A19:        dom Den(o,A'.i) = Args(o,A'.i) &
            rng Den(o,A'.i) c= Result(o,A'.i) by FUNCT_2:def 1,RELSET_1:12;
A20:        Args(o,A'.i) = {{}} by A13,Th11;
            set So = the Sorts of A'.i;
A21:        Result(o,A'.i) = So.rs by Th10;
            dom (the Sorts of A'.i)=the carrier of S by PBOOLE:def 3;
            then So.rs in rng (the Sorts of A'.i) by FUNCT_1:def 5;
            then So.rs c= union rng (the Sorts of A'.i) by ZFMISC_1:92;
            then
A22:        rng Den(o,A'.i) c= |.A'.i.| by A19,A21,XBOOLE_1:1;
            |.A'.i.| in {|.A'.d.| where d is Element of I' :
            not contradiction};
            then |.A'.i.| c= union {|.A'.d.| where d is Element of I' :
            not contradiction} by ZFMISC_1:92;
            then rng Den(o,A'.i) c= |.A'.| by A22,XBOOLE_1:1;
            hence thesis by A18,A19,A20,FUNCT_2:def 2;
          end;
          then
A23:      (A?.o) in Funcs(I,Funcs({{}},|.A'.|)) by A16,FUNCT_2: def 2;
          then commute(A?.o) in Funcs({{}},Funcs(I,|.A'.|)) by FUNCT_6:85;
          then
A24:      ex h be Function st h = co & dom h = {{}} &
          rng h c= Funcs(I,|.A'.|) by FUNCT_2:def 2;
          rng co c= RS.o
          proof
            let j;
            assume
A25:        j in rng co;
            then consider a be set such that
A26:        a in dom co & co.a = j by FUNCT_1:def 5;
            reconsider h = j as Function by A26;
            ex k be Function st k = h & dom k = I & rng k c= |.A'.|
            by A24,A25,FUNCT_2:def 2;
            then
A27:        dom h = I & dom Carrier(A,rs) = I by PBOOLE:def 3;
            for b be set st b in dom Carrier(A,rs) holds
            h.b in Carrier(A,rs).b
            proof
              let b be set;
              assume b in dom Carrier(A,rs);
              then reconsider i = b as Element of I' by PBOOLE:def 3;
A28:          ex U0 being MSAlgebra over S st U0 = A.i &
              (Carrier(A,rs)).i = (the Sorts of U0).rs by Def16;
              (A?.o).i = Den (o,A'.i) by Th14;
              then
A29:          Den(o,A'.i).a = h.i by A23,A24,A26,FUNCT_6:86;
              dom Den(o,A'.i) = Args(o,A'.i) by FUNCT_2:def 1
                .= {{}} by A13,Th11;
              then Den(o,A'.i).a in rng Den(o,A'.i) &
              rng Den(o,A'.i) c= Result(o,A'.i)
              by A24,A26,FUNCT_1:def 5,RELSET_1:12;
              then h.i in Result(o,A'.i) by A29;
              hence thesis by A28,Th10;
            end;
            hence thesis by A12,A27,CARD_3:18;
          end;
          hence thesis by A14,A15,A24,FUNCT_2:4;
        end;
        suppose
A30:      the_arity_of o <> {};
A31:      f.x = IFEQ(the_arity_of o,{},commute(A?.o),
          Commute Frege (A?.o))by A2,A6
            .= Commute Frege (A?.o) by A30,FUNCOP_1:def 8;
A32:      dom ar <> {} by A30,FINSEQ_1:26;
A33:      dom C = AS.o
          proof
            thus dom C c= AS.o
            proof
              let j;
              assume j in dom C;
              then consider g be Function such that
A34:          g in dom F & j = commute g by Def6;
A35:          dom g = I' & (for i be Element of I' holds
              g.i in Args(o,A'.i)) & rng g c= Funcs(dom ar,|.A'.|)
              by A34,Th17;
              then
A36:          g in Funcs(I,Funcs(dom ar,|.A'.|)) by FUNCT_2: def 2;
              then commute g in Funcs(dom ar,Funcs(I,|.A'.|))
              by A32,FUNCT_6:85;
              then
A37:          ex h be Function st h = commute g & dom h = dom ar
              & rng h c= Funcs(I,|.A'.|) by FUNCT_2:def 2;
              set cg = commute g;
              for y be set st y in dom ((SORTS A)*ar) holds
              cg.y in ((SORTS A)*ar).y
              proof
                let y be set;
                assume
A38:            y in dom ((SORTS A)*ar);
                then ar.y in rng ar by A10,FUNCT_1:def 5;
                then reconsider s= ar.y as SortSymbol of S by A9;
A39:            ((SORTS A)*ar).y = (SORTS A).s by A38,FUNCT_1:22
                  .= product Carrier(A,s) by Def17;
A40:            dom Carrier(A,s) = I by PBOOLE:def 3;
                cg.y in rng cg by A10,A37,A38,FUNCT_1:def 5;
                then consider h be Function such that
A41:            h = cg.y & dom h = I & rng h c= |.A'.| by A37,FUNCT_2:def 2;
                for z be set st z in dom Carrier(A,s) holds
                h.z in (Carrier(A,s)).z
                proof
                  let z be set;
                  assume z in dom Carrier(A,s);
                  then reconsider i = z as Element of I' by PBOOLE:def 3;
A42:              ex U0 being MSAlgebra over S st U0 = A.i &
                  (Carrier(A,s)).i = (the Sorts of U0).s by Def16;
A43:              g.i in Args(o,A'.i) & g.i in rng g by A35,FUNCT_1:def 5;
                  then consider f be Function such that
A44:              f=g.i & dom f = dom ar & rng f c= |.A'.|
                  by A35,FUNCT_2:def 2;
A45:              dom ((the Sorts of A'.i)# * Ar) = X by PBOOLE:def 3;
A46:              Args(o,A'.i) = ((the Sorts of A'.i)# * Ar).o
                  by MSUALG_1:def 9
                    .=((the Sorts of A'.i)# qua ManySortedSet of Cr*).(Ar.o)
                  by A6,A45,FUNCT_1:22
                    .= ((the Sorts of A'.i)# qua ManySortedSet of Cr*).ar
                  by MSUALG_1:def 6
                    .= product((the Sorts of A'.i)*ar) by PBOOLE:def 19;
                  dom (the Sorts of A'.i) = Cr by PBOOLE:def 3;
                  then
A47:              dom ((the Sorts of A'.i) * ar) = dom ar by A9,RELAT_1:46;
                  then
A48:              f

.y in ((the Sorts of A'.i) * ar).y by A10,A38,A43,A44,A46,CARD_3:18;
                  ((the Sorts of A'.i) * ar).y = (the Sorts of A'.i).s by A10
                  ,A38,A47,FUNCT_1:22;
                  hence thesis by A10,A36,A38,A41,A42,A44,A48,FUNCT_6:86;
                end;
                hence thesis by A39,A40,A41,CARD_3:18;
              end;
              hence thesis by A8,A10,A34,A37,CARD_3:18;
            end;
            let i;
            assume i in AS.o;
            then consider g be Function such that
A49:        g = i & dom g = dom ((SORTS A)*ar) &
            for x st x in dom ((SORTS A)*ar) holds g.x in ((SORTS A)*ar).x
            by A8,CARD_3:def 5;
A50:        rng g c= Funcs(I,|.A'.|)
            proof
              let a be set;
              assume a in rng g;
              then consider b be set such that
A51:          b in dom g & g.b = a by FUNCT_1:def 5;
A52:          a in ((SORTS A)*ar).b by A49,A51;
              ar.b in rng ar by A10,A49,A51,FUNCT_1:def 5;
              then reconsider cr = ar.b as SortSymbol of S by A9;
              ((SORTS A)*ar).b = (SORTS A).cr by A49,A51,FUNCT_1:22
                .= product Carrier (A,cr) by Def17;
              then consider h be Function such that
A53:          h = a & dom h = dom Carrier (A,cr) &
              for j st j in dom Carrier (A,cr) holds
              h.j in (Carrier (A,cr)).j by A52,CARD_3:def 5;
A54:          dom (Carrier (A,cr)) = I by PBOOLE:def 3;
              rng h c= |.A'.|
              proof
                let j;
                assume j in rng h;
                then consider c be set such that
A55:            c in dom h & h.c = j by FUNCT_1:def 5;
                reconsider i = c as Element of I' by A53,A55,PBOOLE:def 3;
A56:            h.i in (Carrier (A,cr)).i by A53,A55;
A57:            ex U0 being MSAlgebra over S st U0 = A.i &
                (Carrier(A,cr)).i = (the Sorts of U0).cr by Def16;
                dom (the Sorts of A'.i) = the carrier of S by PBOOLE:def 3;
                then (Carrier (A,cr)).i in rng (the Sorts of A'.i)
                by A57,FUNCT_1:def 5;
                then
A58:            h.i in |.A'.i.| by A56,TARSKI:def 4;
                |.A'.i.| in {|.A'.d.| where d is Element of I' :
                not contradiction};
                hence thesis by A55,A58,TARSKI:def 4;
              end;
              hence thesis by A53,A54,FUNCT_2:def 2;
            end;
            then
A59:        g in Funcs(dom ar,Funcs(I,|.A'.|)) by A10,A49, FUNCT_2:def 2;
            then commute g in Funcs(I,Funcs(dom ar,|.A'.|)) by A32,FUNCT_6:85;
            then
A60:        ex h be Function st h = commute g & dom h = I &
            rng h c= Funcs(dom ar,|.A'.|) by FUNCT_2:def 2;
A61:        dom F = product doms (A?.o) by PBOOLE:def 3;
A62:        dom doms (A?.o) = I' &
            for i be Element of I' holds (doms (A?.o)).i = Args(o,A'.i)
            by Th18;
            for j st j in dom doms (A?.o) holds (commute g).j in doms(A?.o).j
            proof
              let j;
              assume j in dom doms (A?.o);
              then reconsider ii = j as Element of I' by Th18;
A63:          (doms (A?.o)).ii = Args(o,A'.ii) by Th18;
              set cg = commute g;
              reconsider h = cg.ii as Function;
A64:          Args(o,A'.ii) = product ((the Sorts of A'.ii)* ar) &
              dom ((the Sorts of A'.ii)*ar) = dom ar by Th10;
              h in rng cg by A60,FUNCT_1:def 5;
              then
A65:          ex s be Function st s = h & dom s = dom ar &
              rng s c= |.A'.| by A60,FUNCT_2:def 2;
              set So = the Sorts of A'.ii;
              for a be set st a in dom (So*ar) holds h.a in (So*ar).a
              proof
                let a be set;
                assume
A66:            a in dom (So*ar);
                then g.a in rng g by A10,A49,A64,FUNCT_1:def 5;
                then consider k be Function such that
A67:            k = g.a & dom k = I & rng k c= |.A'.| by A50,FUNCT_2:def 2;
A68:            k.ii = h.a by A59,A64,A66,A67,FUNCT_6:86;
                ar.a in rng ar by A64,A66,FUNCT_1:def 5;
                then reconsider s = ar.a as SortSymbol of S by A9;
A69:            (So*ar).a = So.s by A66,FUNCT_1:22;
A70:            k in ((SORTS A)*ar).a by A10,A49,A64,A66,A67;
A71:            ((SORTS A)*ar).a = (SORTS A).s by A10,A64,A66,FUNCT_1:22
                  .= product Carrier (A,s) by Def17;
A72:            ex U0 being MSAlgebra over S st U0 = A'.ii &
                (Carrier (A,s)).ii = (the Sorts of U0).s by Def16;
                dom (Carrier (A,s)) = I by PBOOLE:def 3;
                hence thesis by A68,A69,A70,A71,A72,CARD_3:18;
              end;
              hence thesis by A63,A64,A65,CARD_3:18;
            end;
            then
A73:        commute g in dom F by A60,A61,A62,CARD_3:18;
            dom ar <> {} by A30,FINSEQ_1:26;
            then commute (commute g) = g by A59,FUNCT_6:87;
            hence i in dom C by A49,A73,Def6;
          end;
          set rs = the_result_sort_of o, CA = Carrier(A,rs);
          rng C c= RS.o
          proof
            let x;
            assume x in rng C;
            then consider g be set such that
A74:        g in dom C & C.g = x by FUNCT_1:def 5;
            consider f be Function such that
A75:        f in dom Frege(A?.o) & g = commute f by A74,Def6;
            reconsider g as Function by A75;
            dom f = I' & (for i be Element of I' holds f.i in Args(o,A'.i)) &
            rng f c= Funcs(dom(the_arity_of o),|.A'.|) by A75,Th17;
            then
A76:        f in Funcs(I,Funcs(dom(the_arity_of o),|.A'.|)) by FUNCT_2:def 2;
            dom (the_arity_of o) <> {} by A30,FINSEQ_1:26;
            then commute g = f by A75,A76,FUNCT_6:87;
            then
A77:        x = F.f & F.f in rng F by A74,A75,Def6,FUNCT_1:def 5;
            then reconsider h = x as Function;
A78:        dom h=I' & for i be Element of I' holds
            h.i in Result(o,A'.i) by A77,Th16;
A79:        dom CA = I by PBOOLE:def 3;
            for j st j in dom CA holds h.j in CA.j
            proof
              let j;
              assume j in dom CA;
              then reconsider i = j as Element of I' by PBOOLE:def 3;
A80:          dom ((the Sorts of A'.i) * Rs) = dom Rs by A11,PBOOLE:def 3;
A81:          ex U0 being MSAlgebra over S st U0 = A'.i &
              CA.i = (the Sorts of U0).rs by Def16;
              Result(o,A'.i) = ((the Sorts of A'.i) * Rs).o by MSUALG_1:def 10
                .= (the Sorts of A'.i).(Rs.o) by A6,A11,A80,FUNCT_1:22
                .= CA.i by A81,MSUALG_1:def 7;
              hence thesis by A77,Th16;
            end;
            hence x in RS.o by A12,A78,A79,CARD_3:18;
          end;
          hence thesis by A31,A33,FUNCT_2:4;
        end;
      end;
      then reconsider f as ManySortedFunction of AS,RS by PBOOLE:def 18;
      take f;
      let o be OperSymbol of S;
      X <> {} by MSUALG_1:def 5;

hence f.o=IFEQ(the_arity_of o,{},commute(A?.o),Commute Frege(A?.o)) by A2;
    end;
    assume I = {};
    consider f being ManySortedFunction of
    (SORTS A)# * the Arity of S, (SORTS A) * the ResultSort of S;
    take f;
  end;
  uniqueness
  proof
    let f,g be ManySortedFunction of
    (SORTS A)# * the Arity of S, (SORTS A) * the ResultSort of S;
    hereby
      assume I <> {};
      assume that
A82:  for o be OperSymbol of S holds
      f.o = IFEQ(the_arity_of o,{},commute(A?.o), Commute Frege (A?.o)) and
A83:  for o be OperSymbol of S holds
      g.o = IFEQ(the_arity_of o,{},commute(A?.o), Commute Frege (A?.o));
      for i st i in the OperSymbols of S holds f.i = g.i
      proof
        let i;
        assume i in the OperSymbols of S;
        then reconsider o = i as Element of the OperSymbols of S;
        f.o = IFEQ(the_arity_of o,{},commute(A?.o), Commute Frege (A?.o)) &
        g.o = IFEQ(the_arity_of o,{},commute(A?.o),
        Commute Frege (A?.o)) by A82,A83;
        hence thesis;
      end;
      hence f = g by PBOOLE:3;
    end;
    assume
A84: I = {};
A85: dom f = the OperSymbols of S by PBOOLE:def 3;
A86: dom g = the OperSymbols of S by PBOOLE:def 3;
    now
      let o be set;
      assume
A87:  o in the OperSymbols of S;
      then reconsider s = (the ResultSort of S).o as SortSymbol of S by
      FUNCT_2:7;
      o in dom the ResultSort of S by A87,FUNCT_2:def 1;
      then
A88:  ((SORTS A) * the ResultSort of S).o = (SORTS A).s by FUNCT_1: 23
        .= product Carrier(A,s) by Def17
        .= { {} } by A84,Def16,CARD_3:19;
A89:  f.o is Function of
      ((SORTS A)#*the Arity of S).o,((SORTS A) * the ResultSort of S).o
      by A87,PBOOLE:def 18;
      g.o is Function of
      ((SORTS A)#*the Arity of S).o,((SORTS A) * the ResultSort of S).o
      by A87,PBOOLE:def 18;
      hence f.o = g.o by A88,A89,FUNCT_2:66;
    end;
    hence thesis by A85,A86,FUNCT_1:9;
  end;
  correctness;
end;

definition
  let I be set, S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S;
  func product A -> MSAlgebra over S equals

  MSAlgebra (# SORTS A, OPS A #);
  coherence;
end;

registration
  let I be set, S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S;
  cluster product A -> strict;
  coherence;
end;

canceled;

theorem
  for S be non void non empty ManySortedSign,
  A be MSAlgebra-Family of I,S holds the Sorts of product A = SORTS A &
  the Charact of product A = OPS A;

