:: Recognizing Chordal Graphs: Lex BFS and MCS
::  by Broderick Arneson and Piotr Rudnicki
::
:: Received November 17, 2006
:: Copyright (c) 2006 Association of Mizar Users

environ

 vocabularies AMI_1, ARYTM, ARYTM_1, BOOLE, CARD_1, CAT_1, FINSEQ_1, FINSET_1,
      FUNCOP_1, FUNCT_1, FUNCT_4, GRAPH_1, GLIB_000, GLIB_001, GLIB_002,
      GLIB_003, MATRIX_2, MSAFREE2, NEWTON, MEMBERED, ORDINAL1, ORDINAL2,
      PARTFUN1, PBOOLE, POLYNOM1, PRE_TOPC, SQUARE_1, DICKSON, REALSET1,
      RELAT_1, RELAT_2, SEQM_3, CHORD, BAGORDER, UPROOTS, TOPGEN_1, FINSEQ_4,
      NAT_1, ARYTM_3, WELLORD1, ALGSEQ_1, LEXBFS, CARD_FIN;
 notations TARSKI, XBOOLE_0, ZFMISC_1, NUMBERS, SUBSET_1, XXREAL_0, XREAL_0,
      RELAT_1, RELAT_2, WELLORD1, MEMBERED, PARTFUN1, FUNCT_1, FUNCT_2,
      BINARITH, PBOOLE, ORDINAL1, CARD_1, SEQM_3, POLYNOM1, FINSET_1, XCMPLX_0,
      NAT_1, NAT_D, FUNCOP_1, FUNCT_4, GLIB_000, GLIB_001, GLIB_002, PRE_CIRC,
      GLIB_003, BAGORDER, TERMORD, UPROOTS, CHORD, FINSEQ_1, FINSEQ_4,
      DOMAIN_1, ABIAN, RELSET_1;
 constructors WELLORD1, DOMAIN_1, FUNCT_4, XXREAL_0, NAT_D, PRE_CIRC, BAGORDER,
      TERMORD, UPROOTS, GLIB_002, GLIB_003, CHORD;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      FINSET_1, XXREAL_0, XREAL_0, NAT_1, INT_1, MEMBERED, FINSEQ_1, PRE_CIRC,
      GLIB_000, ABIAN, POLYNOM1, HEYTING3, BAGORDER, TERMORD, CARD_FIN,
      GLIB_001, GLIB_002, GLIB_003, CHORD;
 requirements NUMERALS, SUBSET, BOOLE, REAL, ARITHM;
 definitions GLIB_000, GLIB_001, GLIB_003, FINSEQ_1, FUNCOP_1;
 theorems AXIOMS, CARD_1, CARD_2, CARD_4, FUNCOP_1, FINSEQ_1, FINSEQ_2,
      FINSEQ_3, FINSET_1, FUNCT_1, FUNCT_2, FUNCT_4, GLIB_000, GLIB_001,
      GLIB_002, GLIB_003, HEYTING3, INT_1, NAT_1, BAGORDER, TERMORD, ORDINAL1,
      PARTFUN1, PBOOLE, REAL_1, RELAT_1, RELSET_1, TARSKI, XBOOLE_0, XBOOLE_1,
      XREAL_1, ZFMISC_1, PEPIN, ENUMSET1, SEQM_3, CHORD, BINARITH, NECKLACE,
      FINSEQ_4, WELLORD1, UPROOTS, KNASTER, CARD_FIN, POLYNOM1, ORDINAL3,
      TREES_1, PRE_CIRC, MEMBERED, NAT_2, XXREAL_0, NAT_D;
 schemes BINARITH, NAT_1, FUNCT_1, RECDEF_1, FINSEQ_4, FRAENKEL;

begin :: Preliminaries

:: More general than GRAPH_2:4

theorem
 for A,B being Element of NAT, X being non empty set
for F being Function of NAT, X st F is one-to-one
  holds Card {F.w where w is Element of NAT: A <= w & w <= A + B} = B+1
proof let A,B be Element of NAT, X be non empty set;
    let F be Function of NAT, X such that
A1: F is one-to-one;
    defpred P[Element of NAT] means
       Card { F.w where w is Element of NAT: A<= w & w<=A+$1 } = $1+1;
A2: dom F = NAT by FUNCT_2:def 1;
     now let x be set;
      hereby assume x in { F.w where w is Element of NAT: A <= w & w <= A+0};
       then consider w being Element of NAT such that
    A3: F.w = x & A<=w & w<=A+0;
       w = A by A3,XXREAL_0:1;
      hence x in {F.A} by A3,TARSKI:def 1; end;
      assume x in {F.A};
      then x = F.A by TARSKI:def 1;
      hence x in {F.w where w is Element of NAT: A<=w & w<=A+0};
    end;
    then {F.w where w is Element of NAT: A<=w & w<=A+0} = {F.A}
            by TARSKI:2;
then A4: P[0] by CARD_1:79;
A5: for k being Element of NAT st P[k] holds P[k+1] proof
let k be Element of NAT
such that A6: P[k];
        set Fwk  = {F.w where w is Element of NAT: A<=w & w<=A+k};
        set Fwk1 = {F.w where w is Element of NAT: A<=w & w<=A+k+1};
         Card Fwk is finite by A6,CARD_1:69;
        then reconsider Fwk as finite set by CARD_4:1;
         now assume F.(A+k+1) in Fwk;
            then consider w being Element of NAT such that
        A7: F.(A+k+1) = F.w & A <= w & w <= A+k;
             A+k+1 = w by A1,A2,A7,FUNCT_1:def 8;
          hence contradiction by A7,NAT_1:13;
        end;
    then A8: card (Fwk \/ {F.(A+k+1)}) = (k+1)+1 by A6,CARD_2:54;
         now let x be set;
          hereby assume x in Fwk1;
              then consider w being Element of NAT such that
          A9: x = F.w & A <= w & w<=A+k+1;
          A10: w = A+k+1 or w < A+k+1 by A9,REAL_1:def 5;
              per cases by A10,NAT_1:13;
              suppose w = A+k+1;
                then x in {F.(A+k+1)} by A9,TARSKI:def 1;
                hence x in Fwk \/ {F.(A+k+1)} by XBOOLE_0:def 2; end;
              suppose w <= A + k; then x in Fwk by A9;
                hence x in Fwk \/ {F.(A+k+1)} by XBOOLE_0:def 2; end;
          end;
          assume A11: x in Fwk \/ {F.(A+k+1)};
          per cases by A11,XBOOLE_0:def 2;
          suppose x in Fwk;
            then consider w being Element of NAT such that
        A12: x = F.w & A <= w & w<=A+k;
             w <= A+k+1 by A12,NAT_1:13;
            hence x in Fwk1 by A12; end;
          suppose x in {F.(A+k+1)};
        then A13: x = F.(A+k+1) by TARSKI:def 1;
             A <= A+(k+1) by NAT_1:11;
            hence x in Fwk1 by A13; end;
        end;
      hence P[k+1] by A8,TARSKI:2;
    end;
     for k being Element of NAT holds P[k] from NAT_1:sch 1(A4,A5);
  hence thesis;
end;

Lm1:
for a,b,c being real number st a < b holds c-b+1 < c-a+1
proof let a,b,c be real number;
  assume a < b;
  then c-b < c-a by XREAL_1:12;
 hence c-b+1 < c-a+1 by XREAL_1:8;
end;

theorem Th2:
for n,m,k being natural number st m <= k & n < m holds k -' m < k -' n
proof let n,m,k be Nat such that A1: m <= k and A2: n < m;
    n < k by A1,A2,XXREAL_0:2;
then A3: k -' n = k - n by BINARITH:50;
    k - m < k - n by A2,XREAL_1:17;
  hence k -' m < k -' n by A1,A3,BINARITH:50;
end;

theorem Th3:
for n,k being natural number st n < k holds k -' (n+1) + 1 = k -' n
proof let n,k be Nat such that A1: n < k;
A2: k -' n = k - n by A1,BINARITH:50;
    n+1 <= k by A1,NAT_1:13;
   then k -' (n+1) = k - (n+1) by BINARITH:50;
  hence k -' (n+1) + 1 = k -' n by A2;
end;

theorem Th4: :: Div00
for n,m,k being natural number st k <> 0 holds (n + m*k) div k = (n div k) + m
proof
  let n,m,k be natural number; assume
A1: k <> 0;
    m*k mod k = 0 by NAT_D:13;
 hence (n + m*k) div k = (n div k) + (m*k div k) by NAT_D:19
 .= (n div k) + m by A1,NAT_D:18;
end;

definition let S be set;
  attr S is with_finite-elements means                   :Def1:
    for x being Element of S holds x is finite;
end;

registration
  cluster non empty with_finite-elements set;
  existence proof set x = {1};
    take x;
    thus x is non empty;
  for y be Element of x holds y is finite by ORDINAL3:18,TARSKI:def 1;
    hence x is with_finite-elements by Def1;
  end;
  cluster non empty finite with_finite-elements Subset of bool NAT;
  existence proof
    set x = {{1}};
    reconsider x as Subset of bool NAT;
    take x;
    thus x is non empty;
    thus x is finite;
     for y being Element of x holds y is finite by TARSKI:def 1;
    hence x is with_finite-elements by Def1;
  end;
end;

registration let S be with_finite-elements set;
  cluster -> finite Element of S;
  coherence by Def1;
end;

definition  let f,g be Function;
  func f .\/ g -> Function means                 : Def2:
    dom it = dom f \/ dom g &
    for x being set st x in dom f \/ dom g holds it.x = f.x \/ g.x;
  existence proof
    deffunc A() = dom f \/ dom g;
    defpred P[set,set] means f.$1 \/ g.$1 = $2;
A1: for x,y1,y2 being set st x in A() & P[x,y1] & P[x,y2] holds y1 = y2;
A2: for x being set st x in A() ex y being set st P[x,y];
     ex f being Function st dom f = A() &
    for x being set st x in A() holds P[x,f.x] from FUNCT_1:sch 2(A1,A2);
    then consider IT being Function such that
A3: dom IT = A() and
A4: for x being set st x in A() holds P[x,IT.x];
    take IT;
    thus dom IT = dom f \/ dom g by A3;
    thus for x being set st x in dom f \/ dom g holds IT.x = f.x \/ g.x by A4;
  end;
  uniqueness proof
    let IT1,IT2 be Function such that
A5: dom IT1 = dom f \/ dom g and
A6: for x being set st x in dom f \/ dom g holds IT1.x = f.x \/ g.x and
A7: dom IT2 = dom f \/ dom g and
A8: for x being set st x in dom f \/ dom g holds IT2.x = f.x \/ g.x;
     now let x be set such that A9: x in dom IT1;
         IT1.x = f.x \/ g.x by A5,A6,A9;
      hence IT1.x = IT2.x by A5,A8,A9;
    end;
  hence IT1 = IT2 by A5,A7,FUNCT_1:9;
  end;
end;

theorem Th5:
for m,n,k being natural number holds
  m in ((Seg k) \ Seg (k -' n)) iff k -' n < m & m <= k
proof let m,n,k be Nat;
  hereby assume m in ((Seg k) \ Seg (k -' n));
then A1: m in Seg k & not m in Seg (k -' n) by XBOOLE_0:def 4;
    then 1 <= m & m <= k by FINSEQ_1:3;
    hence k -' n < m & m <= k by A1;
  end;
  assume
A2: k -' n < m & m <= k;
then A3: not m in Seg (k -' n) by FINSEQ_1:3;
     0+1 <= m by A2,NAT_1:13;
    then m in Seg k by A2,FINSEQ_1:3;
  hence m in ((Seg k) \ Seg (k -' n)) by A3,XBOOLE_0:def 4;
end;

theorem Th6:
for n,k,m being natural number st n <= m holds
  ((Seg k) \ Seg (k -' n)) c= ((Seg k) \ Seg (k -' m))
proof let n,k,m be Nat such that A1: n <= m;
  per cases;
  suppose k < m;
then A2:  Seg (k -' m) = {} by FINSEQ_1:4,NAT_2:10;
     for x be set st x in ((Seg k)\Seg(k-'n))holds x in Seg k by XBOOLE_0:def 4
;
     hence thesis by A2,TARSKI:def 3; end;
  suppose A3: m <= k;
     now let x be set such that A4: x in ((Seg k) \ Seg (k -' n));
        reconsider y = x as Element of NAT by A4;
    A5: k -' n < y & y <= k by A4,Th5;
      per cases by A1,REAL_1:def 5;
      suppose m = n;
      hence x in ((Seg k) \ Seg (k -' m)) by A4; end;
      suppose n < m;
        then k -' m < k -' n by A3,Th2;
        then k -' m < y & y <= k by A5,XXREAL_0:2;
      hence x in ((Seg k) \ Seg (k -' m)) by Th5; end;
    end;
    hence thesis by TARSKI:def 3; end;
end;

theorem Th7:
for n,k being natural number st n < k holds
  ((Seg k) \ Seg (k -' n)) \/ {k -' n} = (Seg k) \ Seg (k -' (n+1))
proof let n, k be Nat such that A1: n < k;
    set Sn  = (Seg k) \ Seg (k -' n);
    set Sn1 = (Seg k) \ Seg (k -' (n+1));
     now let x be set such that A2: x in Sn \/ {k -' n};
      per cases by A2,XBOOLE_0:def 2;
      suppose A3: x in Sn;
         n <= n+1 by NAT_1:13;
        then Sn c= Sn1 by Th6;
      hence x in Sn1 by A3; end;
      suppose A4: x in {k -' n};
    then A5: x = k -' n by TARSKI:def 1;
        reconsider y = x as Nat by A4,TARSKI:def 1;
         now assume y = 0;
          then k - n + n = 0 + n by A1,A5,BINARITH:50;
          hence contradiction by A1;
        end; then 0 < y;
    then A6: 0+1 <= y & y <= k by A5,BINARITH:52,NAT_1:13;
    A7: n+1 <= k by A1,NAT_1:13;
         n < n + 1 by NAT_1:13;
        then k -' (n+1) < k -' n by A7,Th2;
      hence x in Sn1 by A5,A6,Th5; end;
    end;
then A8:  Sn \/ {k -' n} c= Sn1 by TARSKI:def 3;
     now let x be set such that A9: x in Sn1;
        reconsider y = x as Element of NAT by A9;
    A10: k -' (n+1) < y & y <= k by A9,Th5;
     k -' (n+1) + 1 = k -' n by A1,Th3;
    then A11: k -' n <= y by A10,NAT_1:13;
      per cases by A11,REAL_1:def 5;
      suppose k -' n = y;
        then y in {k -' n} by TARSKI:def 1;
      hence x in Sn \/ {k -' n} by XBOOLE_0:def 2; end;
      suppose k -' n < y;
        then y in Sn by A10,Th5;
      hence x in Sn \/ {k -' n} by XBOOLE_0:def 2; end;
    end; then Sn1 c= Sn \/ {k -' n} by TARSKI:def 3;
  hence thesis by A8,XBOOLE_0:def 10;
end;

definition let f be Relation;
  attr f is natsubset-yielding means                         :Def3:
    rng f c= bool NAT;
end;

Lm2:
for F being Function st
  (for x being set st x in rng F holds x is finite)
holds F is finite-yielding
proof let F be Function such that
A1: for x being set st x in rng F holds x is finite;
   now let y be set;
  per cases;
  suppose y in dom F;
    then F.y in rng F by FUNCT_1:12;
    hence F.y is finite by A1; end;
  suppose not y in dom F;
    hence F.y is finite by FUNCT_1:def 4; end;
  end;
  hence F is finite-yielding by CARD_FIN:def 3;
end;

Lm3:
for F being finite-yielding Function, x being set st x in rng F
  holds x is finite
proof let F be finite-yielding Function;
  let x be set such that A1: x in rng F;
  consider y being set such that
A2: y in dom F & x = F.y by A1,FUNCT_1:def 5;
  thus x is finite by A2;
end;

registration
  cluster finite-yielding natsubset-yielding Function;
  existence proof
    set F = NAT --> {};
A1: dom F = NAT & rng F = {{}} by FUNCOP_1:14,19;
    take F;
     now let x be set such that A2: x in rng F;
         x = {} by A1,A2,TARSKI:def 1;
        then x c= NAT by XBOOLE_1:2;
      hence x in bool NAT;
    end;
then A3: rng F c= bool NAT by TARSKI:def 3;
     for x be set st x in rng F holds x is finite by A1,TARSKI:def 1;
    hence F is finite-yielding by Lm2;
    thus  F is natsubset-yielding by A3,Def3;
  end;
end;

definition let f be finite-yielding natsubset-yielding Function, x be set;
  redefine func f.x -> finite Subset of NAT;
  coherence proof
  per cases;
  suppose x in dom f;
then A1: f.x in rng f by FUNCT_1:12;
     rng f c= bool NAT by Def3;
    hence f.x is finite Subset of NAT by A1; end;
  suppose not x in dom f;
    then f.x = {} by FUNCT_1:def 4;
    hence f.x is finite Subset of NAT by XBOOLE_1:2; end;
  end;
end;

theorem Th8:
for X being Ordinal, a, b be finite Subset of X st a <> b
  holds (a,1)-bag <> (b,1)-bag
proof let X be Ordinal, a,b be finite Subset of X such that
A1: a <> b;
    assume A2: (a,1)-bag = (b,1)-bag;
     now let x be set;
       x in a iff (b,1)-bag.x = 1 by A2,UPROOTS:8,9;
      hence x in a iff x in b by UPROOTS:8,9;
    end;
  hence contradiction by A1,TARSKI:2;
end;

definition let F be natural-yielding Function, S be set, k be natural number;
   func F.incSubset(S,k) -> natural-yielding Function means   :Def4:
   dom it = dom F &
   for y being set holds (y in S & y in dom F implies it.y = F.y + k) &
                         (not y in S implies it.y = F.y);
  existence proof
    deffunc G(set) = F.$1 + k;
    consider H being Function such that
A1: dom H = S /\ dom F and
A2: for x being set st x in (S /\ dom F) holds H.x = G(x) from FUNCT_1:sch 3;
A3: rng F c= NAT by SEQM_3:def 8;
     now let x be set such that A4: x in rng H;
        consider y being set such that
    A5: y in dom H & H.y = x by A4,FUNCT_1:def 5;
         H.y = F.y + k by A1,A2,A5;
      hence x in NAT by A5;
    end;
    then rng H c= NAT by TARSKI:def 3;
then A6: rng F \/ rng H c= NAT by A3,XBOOLE_1:8;
     rng (F+*H) c= rng F \/ rng H by FUNCT_4:18;
    then rng (F+*H) c= NAT by A6,XBOOLE_1:1;
    then reconsider IT = F+*H as natural-yielding Function by SEQM_3:def 8;
    take IT;
     dom IT = dom F \/ (S /\ dom F) by A1,FUNCT_4:def 1;
  hence dom IT = dom F by XBOOLE_1:22;
     now let y be set;
    A7: now assume A8: y in S & y in dom F;
        then A9: y in S /\ dom F by XBOOLE_0:def 3;
             y in dom H by A1,A8,XBOOLE_0:def 3;
            then IT.y = H.y by FUNCT_4:14;
          hence IT.y = F.y + k by A2,A9;
        end;
         now assume not y in S;
            then not y in dom H by A1,XBOOLE_0:def 3;
          hence IT.y = F.y by FUNCT_4:12;
        end;
      hence (y in S & y in dom F implies IT.y = F.y + k) &
            (not y in S implies IT.y = F.y) by A7;
    end;
    hence thesis;
  end;
  uniqueness proof
    let IT1,IT2 be natural-yielding Function such that
A10: dom IT1 = dom F & for y being set holds
      (y in S & y in dom F implies IT1.y = F.y + k) &
      (not y in S implies IT1.y = F.y) and
A11: dom IT2 = dom F & for y being set holds
      (y in S & y in dom F implies IT2.y = F.y + k) &
      (not y in S implies IT2.y = F.y);
     now let x be set such that A12: x in dom IT1;
      per cases by A10,A12;
      suppose x in S & x in dom F;
        then IT1.x = F.x + k & IT2.x = F.x + k by A10,A11;
      hence IT1.x = IT2.x; end;
      suppose not x in S;
        then IT1.x = F.x & IT2.x = F.x by A10,A11;
      hence IT1.x = IT2.x; end;
    end;
    hence thesis by A10,A11,FUNCT_1:9;
  end;
end;

definition let n be Ordinal, T be connected TermOrder of n,
           B be non empty finite Subset of Bags n;
  func max(B,T) -> bag of n means                                  :Def5:
     it in B & for x being bag of n st x in B holds x <= it,T;
  existence proof
    consider p being FinSequence such that
A1: rng p = B by FINSEQ_1:73;
  defpred P[Nat] means
  $1 <= len p implies
  (ex a being Nat, A being bag of n st a in dom p & a <= $1 & p.a = A &
      (for c being Nat, C being bag of n st c in dom p & c <= $1 & p.c = C
           holds C <= A, T));
     p <> {} by A1,FINSEQ_1:27;
then A2: 0 <> len p by FINSEQ_1:25;
A3: P[1] proof
    A4: 1 in dom p by A1,FINSEQ_3:34;
        then p.1 in B by A1,FUNCT_1:def 5;
        then reconsider A = p.1 as bag of n by POLYNOM1:def 14;
         now let c be Nat, C be bag of n such that
        A5: c in dom p & c <= 1 & p.c = C;
             1 <= c by A5,FINSEQ_3:27;
            then C = A by A5,XXREAL_0:1;
          hence C <= A,T by TERMORD:6;
        end;
      hence P[1] by A4;
    end;
A6: for k being non empty Element of NAT st P[k] holds P[k+1] proof
        let k be non empty Element of NAT such that A7: P[k];
      per cases;
      suppose A8: k < len p;
        then consider a being Nat, A being bag of n such that
    A9: a in dom p & a <= k & p.a = A and
    A10: for c being Nat, C being bag of n st c in dom p & c <= k & p.c = C
          holds C <= A,T by A7;
    A11: k+1 <= len p by A8,NAT_1:13;
         1 <= k+1 by CHORD:1;
    then A12: k+1 in dom p by A11,FINSEQ_3:27;
        then p.(k+1) in B by A1,FUNCT_1:def 5;
        then reconsider Ck = p.(k+1) as bag of n by POLYNOM1:def 14;
        set m = max(A,Ck,T);
    A13: A <= m,T & Ck <= m,T by TERMORD:14;
        per cases by TERMORD:12;
        suppose A14: m = A;
        A15: a in dom p & a <= k+1 & p.a = A by A9,NAT_1:13;
             now let c be Nat,C be bag of n such that
            A16: c in dom p & c <= k+1 & p.c = C;
              per cases by A16,REAL_1:def 5;
              suppose c = k+1;
              hence C <= m,T by A16,TERMORD:14; end;
              suppose c < k+1;
                then c <= k by NAT_1:13;
                then C <= A,T by A10,A16;
              hence C <= m,T by A13,TERMORD:8; end;
            end;
          hence P[k+1] by A14,A15; end;
        suppose A17: m = Ck;
           now let c be Nat, C be bag of n such that
          A18: c in dom p & c <= k+1 & p.c = C;
            per cases by A18,REAL_1:def 5;
            suppose c = k+1;
            hence C <= m,T by A18,TERMORD:14; end;
            suppose c < k+1;
              then c <= k by NAT_1:13;
              then C <= A,T by A10,A18;
            hence C <= m,T by A13,TERMORD:8; end;
          end;
          hence P[k+1] by A12,A17; end;
        end;
      suppose k >= len p;
      hence P[k+1] by NAT_1:13; end;
    end;
 for k being non empty Element of NAT holds P[k]
        from BINARITH:sch 1(A3,A6);
    then consider a being Nat, A being bag of n such that
A19: a in dom p & a <= len p & p.a = A and
A20: for c being Nat, C being bag of n st c in dom p & c <= len p & p.c = C
      holds C <= A, T by A2;
    take A;
  thus A in B by A1,A19,FUNCT_1:def 5;
     now let x be bag of n such that A21: x in B;
        consider y being Nat such that
    A22: y in dom p & p.y = x by A1,A21,FINSEQ_2:11;
         y <= len p by A22,FINSEQ_3:27;
      hence x <= A,T by A20,A22;
    end;
  hence thesis;
  end;
  uniqueness proof
    let IT1,IT2 be bag of n such that
A23: IT1 in B and
A24: for x being bag of n st x in B holds x <= IT1,T and
A25: IT2 in B and
A26: for x being bag of n st x in B holds x <= IT2,T;
A27: IT2 <= IT1,T by A24,A25;
 IT1 <= IT2,T by A23,A26;
  hence IT1 = IT2 by A27,TERMORD:7;
  end;
end;

registration let O be Ordinal;
  cluster InvLexOrder O -> connected;
  coherence proof
     InvLexOrder O is well-ordering by BAGORDER:26;
    hence InvLexOrder O is connected by WELLORD1:def 4;
  end;
end;

begin :: Miscellany on graphs

registration let G be _Graph;
  cluster non empty one-to-one VertexSeq of G;
  existence proof
    set v = choose the_Vertices_of G, IT = <*v*>;
    reconsider IT as FinSequence of the_Vertices_of G;
     for n be Element of NAT st 1 <= n & n < len IT
      holds ex e being set st e Joins IT.n, IT.(n+1), G by FINSEQ_1:57;
    then reconsider IT as VertexSeq of G by GLIB_001:def 1;
    take IT;
    thus IT is non empty;
    thus IT is one-to-one by FINSEQ_3:102;
  end;
end;

definition
  let G be _Graph, V being non empty VertexSeq of G;
  mode Walk of V -> Walk of G means                  :Def6:
  it.vertexSeq() = V;
  existence proof
   set tVG = the_Vertices_of G;   set tEG = the_Edges_of G;
    now assume len V < 1;
       then len V = 0 by NAT_1:14;
       hence contradiction by FINSEQ_1:25;
   end; then 2*len V >= 2*1 & 2>=1 by XREAL_1:66;
then A1: 2*len V >= 1 by XXREAL_0:2;
then A2: 2*len V - 1 >= 1 - 1 by XREAL_1:15;
    defpred P[Element of NAT,set] means
    ($1 is odd implies $2 = V.(($1+1) div 2)) &
    ($1 is even implies $2 Joins V.($1 div 2),V.($1 div 2 + 1),G);
    deffunc N() = 2*len V -' 1;
    deffunc D() = the_Vertices_of G \/ the_Edges_of G;
A3: for n being Element of NAT st n in Seg N()
        ex d being Element of D() st P[n,d] proof
        let n be Element of NAT such that A4: n in Seg N();
    A5: 1 <= n & n <= 2*len V -' 1 by A4,FINSEQ_1:3;
         2*len V -' 1 = 2*len V - 1 by A2,BINARITH:def 3;
    then A6: n+1 <= 2*len V - 1 + 1 by A5,XREAL_1:9;
        per cases;
        suppose n is odd;
            then reconsider n as odd Element of NAT;
            set m = (n+1) div 2;
             2 divides n+1 by PEPIN:22;
        then A7: 2*m = n+1 by NAT_D:3;
            then 0 <> m;
            then 0 < m;
            then 0+1 <= m & m <= len V by A6,A7,NAT_1:13,XREAL_1:70;
            then m in dom V by FINSEQ_3:27;
            then V.m in rng V by FUNCT_1:12;
            then reconsider Vm=V.m as Element of tVG \/ tEG by XBOOLE_0:def 2;
            take Vm;
          thus thesis; end;
        suppose n is even;
            then reconsider n as even Element of NAT;
            set m = n div 2;
             2 divides n by PEPIN:22;
        then A8: 2*m = n by NAT_D:3;
        A9: now assume m < 1; then m = 0 by NAT_1:14;
                 hence contradiction by A4,A8,FINSEQ_1:3;
            end;
             now assume m >= len V;
                 then n >= 2*len V by A8,XREAL_1:66;
                 hence contradiction by A6,XREAL_1:41;
            end;
            then consider e being set such that
        A10: e Joins V.m,V.(m+1),G by A9,GLIB_001:def 1;
             e in tEG by A10,GLIB_000:def 15;
            then reconsider e as Element of tVG \/ tEG by XBOOLE_0:def 2;
            take e;
          thus thesis by A10; end;
    end;
   consider f being FinSequence of D() such that
A11: len f = N() and
A12: for n being Element of NAT st n in Seg N() holds P[n,f/.n]
        from FINSEQ_4:sch 1(A3);
A13: len f = 2*len V - 1 by A2,A11,BINARITH:def 3;
    len f <> 2*0 by A2,A11,BINARITH:def 3;
   then f <> {} by FINSEQ_1:25;
   then rng f <> {} by FINSEQ_1:27;
then A14: 1 in dom f by FINSEQ_3:34;
then A15: 1 in Seg (len f) by FINSEQ_1:def 3;
    rng V <> {};
then A16: 1 in dom V by FINSEQ_3:34;
    (1+1) div 2 = (2*1) div 2 .= 1 by NAT_D:18;
   then f/.1 = V.(2*0+1) by A11,A12,A15;
   then f/.1 in rng V by A16,FUNCT_1:12;
   then f/.1 in the_Vertices_of G;
then A17: f.1 in the_Vertices_of G by A14,PARTFUN1:def 8;
 now let n be odd Element of NAT such that
   A18: n < len f;
   A19: 1 <= n by HEYTING3:1;
       then 1 <= n+1 & n+1 <= len f by A18,NAT_1:13;
   then A20: n+1 in Seg len f;
   A21: n in Seg len f by A18,A19;
    len f is odd by A2,A11,BINARITH:def 3;
       then 1 <= n+2 & n+2 <= len f by A18,CHORD:4,XREAL_1:40;
   then A22: n+2 in Seg len f;
   A23: f/.(n+1) Joins V.((n+1) div 2), V.((n+1) div 2 + 1),G by A11,A12,A20;
        n+1 in dom f by A20,FINSEQ_1:def 3;
   then A24: f.(n+1) Joins V.((n+1) div 2),V.((n+1) div 2 +1),G by A23,
PARTFUN1:def 8;
        f/.n = V.((n+1) div 2) & n in dom f by A11,A12,A21,FINSEQ_1:def 3;
   then A25: f.n = V.((n+1) div 2) by PARTFUN1:def 8;
   A26: P[n+2*1,f/.(n+2)] by A11,A12,A22;
   A27: ((n+1) + 2*1) div 2 = (n+1) div 2 + 1 by Th4;
        n+2 in dom f by A22,FINSEQ_1:def 3;
     hence f.(n+1) Joins f.n,f.(n+2),G by A24,A25,A26,A27,PARTFUN1:def 8;
   end;
   then reconsider f as Walk of G by A13,A17,GLIB_001:def 3;
   take f;
A28: len f + 1 = 2*len V by A1,A11,BINARITH:53;
A29: len f + 1 = 2*len f.vertexSeq() by GLIB_001:def 14;
    now let k be Nat such that
   A30: 1 <= k & k <= len f.vertexSeq();
        2*1 <= 2*k by A30,XREAL_1:66;
       then 2-1 <= 2*k-1 by XREAL_1:15;
       then reconsider 2k1 = 2*k - 1 as odd Element of NAT by INT_1:16;
   A31: (f.vertexSeq()).k = f.2k1 by A30,GLIB_001:def 14;
   reconsider k1=k as Element of NAT by ORDINAL1:def 13;
   2 divides 2*k1 by PEPIN:22;
   then 2*k = 2*(2*k div 2) by NAT_D:3;
   then A32: (2k1 + 1) div 2 = k;
        k in dom f.vertexSeq() by A30,FINSEQ_3:27;
   then A33: 2k1 in dom f by GLIB_001:74;
       then 2k1 in Seg (2*len V -' 1) by A11,FINSEQ_1:def 3;
       then f/.2k1 = V.k by A12,A32;
     hence (f.vertexSeq()).k = V.k by A31,A33,PARTFUN1:def 8;
   end;
   hence thesis by A28,A29,FINSEQ_1:18;
  end;
end;

registration
  let G be _Graph, V being non empty one-to-one VertexSeq of G;
  cluster -> Path-like Walk of V;
  correctness proof
    let W be Walk of V;
A1: W.vertexSeq() = V by Def6;
     now let m,n be odd Element of NAT such that
    A2: m <= len W & n <= len W and
    A3: W.m = W.n;
        set mk = (m+1) div 2;
        set nk = (n+1) div 2;
    A4: 2*mk - 1 = m & 1 <= mk & mk <= len V by A1,A2,GLIB_001:69;
    A5: 2*nk - 1 = n & 1 <= nk & nk <= len V by A1,A2,GLIB_001:69;
         W.vertexAt(n) = V.nk by A1,A2,GLIB_001:73;
    then A6: W.n = V.nk by A2,GLIB_001:def 8;
         W.vertexAt(m) = V.mk by A1,A2,GLIB_001:73;
    then A7: W.m = V.mk by A2,GLIB_001:def 8;
         nk in dom V & mk in dom V by A4,A5,FINSEQ_3:27;
      hence m = n by A3,A4,A5,A6,A7,FUNCT_1:def 8;
    end;
   hence W is Path-like by GLIB_001:147;
  end;
end;

Lm4: :: PathLike05
for G being _Graph, W being Walk of G, e,v being set
  st e Joins W.last(),v,G
 holds W.addEdge(e).length() = W.length() + 1
proof let G be _Graph, W be Walk of G, e,v be set such that
A1: e Joins W.last(),v,G;
A2: W.addEdge(e).edgeSeq() = W.edgeSeq()^<*e*> by A1,GLIB_001:83;
    len <*e*> = 1 by FINSEQ_1:56;
  hence W.addEdge(e).length() = W.length()+1 by A2,FINSEQ_1:35;
end;

Lm5: :: PathLike06
for G being _Graph, W being Walk of G
 holds W.length() = W.reverse().length()
proof let G be _Graph, W be Walk of G;
A1: len W = len W.reverse() by GLIB_001:22;
 len W = 2*W.length() + 1 by GLIB_001:113;
   then 2*W.length()+1-1 = 2*W.reverse().length()+1-1 by A1,GLIB_001:113;
  hence W.length() = W.reverse().length();
end;

Lm6: :: PathLike10
for G being _Graph, W being Walk of G for e,x being set st e Joins W.last(),x,G
for n being natural number st n in dom W
 holds W.addEdge(e).n = W.n & n in dom W.addEdge(e)
proof let G be _Graph, W be Walk of G;
  let e,x be set such that A1: e Joins W.last(),x,G;
  let n be Nat such that A2: n in dom W;
A3: len W.addEdge(e) = len W + 2 by A1,GLIB_001:65;
     1 <= n & n <= len W & len W < len W + 2 by A2,FINSEQ_3:27,XREAL_1:31;
then A4: 1 <= n & n <= len W + 2 by XXREAL_0:2;
  thus W.addEdge(e).n = W.n by A1,A2,GLIB_001:66;
  thus n in dom W.addEdge(e) by A3,A4,FINSEQ_3:27;
end;

theorem :: PathLike20
 for G being _Graph, W1,W2 being Walk of G
 st W1 is trivial & W1.last() = W2.first() holds W1.append(W2) = W2
proof let G be _Graph, W1,W2 be Walk of G such that
A1: W1 is trivial & W1.last() = W2.first();
A2: len W1 = 1 by A1,GLIB_001:127;
then A3: len W1.append(W2) + 1 = 1 + len W2 by A1,GLIB_001:29;
     now let k be Nat such that
    A4: 1 <= k & k <= len W1.append(W2);
    A5: 1-1 <= k-1 by A4,XREAL_1:11;
         k-1 < k by XREAL_1:46;
    then A6: 0 <= k-1 & k-1 < len W2 by A3,A4,A5,XXREAL_0:2;
        reconsider k1 = k-1 as Element of NAT by A5,INT_1:16;
         W1.append(W2).(1 + k1) = W2.(k1+1) by A1,A2,A6,GLIB_001:34;
      hence W1.append(W2).k = W2.k;
    end;
  hence thesis by A3,FINSEQ_1:18;
end;

theorem
 for G, H being _Graph, A, B, C being set,
    G1 being (inducedSubgraph of G,A), H1 being (inducedSubgraph of H,B),
    G2 being (inducedSubgraph of G1,C), H2 being (inducedSubgraph of H1,C)
 st G == H & A c= B & C c= A & C is non empty Subset of the_Vertices_of G
  holds G2 == H2
proof let G,H be _Graph, A,B,C be set,
    G1 be (inducedSubgraph of  G,A), H1 be (inducedSubgraph of  H,B),
    G2 be (inducedSubgraph of G1,C), H2 be (inducedSubgraph of H1,C) such that
A1: G == H and
A2: A c= B & C c= A and
A3: C is non empty Subset of the_Vertices_of G;
A4: the_Vertices_of G = the_Vertices_of H by A1,GLIB_000:def 36;
A5: C c= B by A2,XBOOLE_1:1;
  per cases;
  suppose A6: A is non empty Subset of the_Vertices_of G &
              B is non empty Subset of the_Vertices_of G;
then A7: G2 is inducedSubgraph of G,C by A2,A3,CHORD:29;
A8: H2 is inducedSubgraph of H,C by A3,A4,A5,A6,CHORD:29;
     G.edgesBetween(C) = H.edgesBetween(C) by A1,GLIB_000:93;
    then H2 is inducedSubgraph of G,C by A1,A8,GLIB_000:98;
  hence thesis by A7,GLIB_000:96; end;
  suppose A9: not A is non empty Subset of the_Vertices_of G &
                  B is non empty Subset of the_Vertices_of G;
then A10: G1 == G by GLIB_000:def 39;
    then G.edgesBetween(C) = G1.edgesBetween(C) by GLIB_000:93;
then A11: G2 is inducedSubgraph of G,C by A10,GLIB_000:98;
A12: H2 is inducedSubgraph of H,C by A3,A4,A5,A9,CHORD:29;
     G.edgesBetween(C) = H.edgesBetween(C) by A1,GLIB_000:93;
    then H2 is inducedSubgraph of G,C by A1,A12,GLIB_000:98;
  hence thesis by A11,GLIB_000:96; end;
  suppose A13: A is non empty Subset of the_Vertices_of G &
          not B is non empty Subset of the_Vertices_of G;
    then H1 == H by A4,GLIB_000:def 39;
then A14: H1 == G by A1,GLIB_000:88;
    then G.edgesBetween(C) = H1.edgesBetween(C) by GLIB_000:93;
then A15: H2 is inducedSubgraph of G,C by A14,GLIB_000:98;
     G2 is inducedSubgraph of G,C by A2,A3,A13,CHORD:29;
  hence thesis by A15,GLIB_000:96; end;
  suppose not A is non empty Subset of the_Vertices_of G &
          not B is non empty Subset of the_Vertices_of G;
then A16: G1 == G & H1 == H by A4,GLIB_000:def 39;
    then H1 == G by A1,GLIB_000:88;
then A17: H1 == G1 by A16,GLIB_000:88;
    then G1.edgesBetween(C) = H1.edgesBetween(C) by GLIB_000:93;
    then H2 is inducedSubgraph of G1,C by A17,GLIB_000:98;
  hence thesis by GLIB_000:96;
end;
end;

definition let G be VGraph;
  attr G is natural-vlabeled means                                  :Def7:
    the_VLabel_of G is natural-yielding;
end;

begin :: Graphs with two vertex labels

definition
  func V2LabelSelector -> natural number equals  8;
  coherence;
end;

definition let G be GraphStruct;
  attr G is [V2Labeled] means :Def9: ::dV2LABELED
    V2LabelSelector in dom G &
    ex f being Function st G.V2LabelSelector = f & dom f c= the_Vertices_of G;
end;

registration
  cluster [Graph-like] [Weighted] [ELabeled] [VLabeled] [V2Labeled]
          GraphStruct;
  existence proof
    set V5 = {1}, E3 = {};
    consider S1 being Function of E3,V5;
    consider W1 being ManySortedSet of E3;
    consider EL8 being PartFunc of E3,REAL;
    consider VL6 being PartFunc of V5,REAL;
    set G=<*V5*>^<*E3*>^<*S1*>^<*S1*>^<*W1*>^<*EL8*>^<*VL6*>^<*VL6*>;
A1: len G = 8 & G.1 = V5 & G.2 = E3 & G.3 = S1 & G.4 = S1 & G.5 = W1 &
      G.6 = EL8 & G.7 = VL6 & G.8 = VL6 by FINSEQ_1:91;
    then dom G = Seg 8 by FINSEQ_1:def 3;
    then reconsider G as GraphStruct by GLIB_000:def 1;
    take G;
     dom G = Seg 8 by A1,FINSEQ_1:def 3;
then A2: VertexSelector in dom G & EdgeSelector in dom G & SourceSelector in
dom G &
    TargetSelector in dom G & WeightSelector in dom G &
    ELabelSelector in dom G & VLabelSelector in dom G &
    V2LabelSelector in dom G;
A3: the_Vertices_of G = V5 & the_Edges_of G = E3 & the_Source_of G = S1 &
    the_Target_of G = S1 & G.WeightSelector = W1 & G.ELabelSelector = EL8 &
      G.VLabelSelector = VL6 & G.V2LabelSelector = VL6 by FINSEQ_1:91;
     dom EL8 c= E3 & dom VL6 c= V5;
    hence thesis by A2,A3,Def9,GLIB_000:def 11,GLIB_003:def 4,def 5,def 6;
 end;
end;

definition
  mode V2Graph is [V2Labeled] _Graph;
  mode VVGraph is [VLabeled] [V2Labeled] _Graph;
end;

definition let G be V2Graph;
  func the_V2Label_of G -> Function equals  G.V2LabelSelector;
  coherence proof
    consider f being Function such that
A1: G.V2LabelSelector = f & dom f c= the_Vertices_of G by Def9;
    thus thesis by A1;
  end;
end;

theorem Th11:
for G being V2Graph holds dom the_V2Label_of G c= the_Vertices_of G
proof let G be V2Graph;
    consider f being Function such that
A1: G.V2LabelSelector = f & dom f c= the_Vertices_of G by Def9;
  thus thesis by A1;
end;

registration let G be _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> [Graph-like]; coherence proof
     not V2LabelSelector in _GraphSelectors by ENUMSET1:def 2;
    hence thesis by GLIB_000:13;
  end;
end;

theorem Th12:
for G being _Graph, X being set holds G.set(V2LabelSelector, X) == G
proof
    let G be _Graph, X be set; set GS = _GraphSelectors;
    set G2 = G.set(V2LabelSelector,X);
     not V2LabelSelector in GS by ENUMSET1:def 2;
    then the_Vertices_of G2 = the_Vertices_of G &
    the_Edges_of G2 = the_Edges_of G &
    the_Source_of G2 = the_Source_of G &
    the_Target_of G2 = the_Target_of G by GLIB_000:13;
    hence G2 == G by GLIB_000:def 36;
end;

registration let G be finite _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> finite; coherence proof
     G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_000:92;
  end;
end;

registration let G be loopless _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> loopless; coherence proof
     G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_000:92;
  end;
end;

registration let G be trivial _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> trivial; coherence proof
     G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_000:92;
  end;
end;

registration let G be non trivial _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> non trivial; coherence proof
     G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_000:92;
  end;
end;

registration let G be non-multi _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> non-multi; coherence proof
     G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_000:92;
  end;
end;

registration let G be non-Dmulti _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> non-Dmulti; coherence proof
     G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_000:92;
  end;
end;

registration let G be connected _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> connected; coherence proof
     G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_002:8;
  end;
end;

registration let G be acyclic _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> acyclic; coherence proof
     G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_002:44;
  end;
end;

registration let G be VGraph, X be set;
  cluster G.set(V2LabelSelector, X) -> [VLabeled]; coherence proof
    set G1 = G.set(V2LabelSelector,X);
A1: dom G c= dom G1 by FUNCT_4:11;
A2: VLabelSelector in dom G by GLIB_003:def 6;
     G == G1 by Th12;
then A3: the_Vertices_of G = the_Vertices_of G1 by GLIB_000:def 36;
A4: G1.VLabelSelector = the_VLabel_of G by GLIB_000:12;
     dom the_VLabel_of G c= the_Vertices_of G by GLIB_003:7;
    hence thesis by A1,A2,A3,A4,GLIB_003:def 6;
  end;
end;

registration let G be EGraph, X be set;
  cluster G.set(V2LabelSelector, X) -> [ELabeled]; coherence proof
    set G1 = G.set(V2LabelSelector,X);
A1: dom G c= dom G1 by FUNCT_4:11;
A2: ELabelSelector in dom G by GLIB_003:def 5;
     G == G1 by Th12;
then A3: the_Edges_of G = the_Edges_of G1 by GLIB_000:def 36;
A4: G1.ELabelSelector = the_ELabel_of G by GLIB_000:12;
     dom the_ELabel_of G c= the_Edges_of G by GLIB_003:6;
    hence thesis by A1,A2,A3,A4,GLIB_003:def 5;
  end;
end;

registration let G be WGraph, X be set;
  cluster G.set(V2LabelSelector, X) -> [Weighted]; coherence proof
    set G1 = G.set(V2LabelSelector,X);
A1: dom G c= dom G1 by FUNCT_4:11;
A2: WeightSelector in dom G by GLIB_003:def 4;
A3: G == G1 by Th12;
A4: G1.WeightSelector = the_Weight_of G by GLIB_000:12;
     the_Edges_of G = the_Edges_of G1 by A3,GLIB_000:def 36;
    hence thesis by A1,A2,A4,GLIB_003:def 4;
  end;
end;

registration let G be V2Graph, X be set;
  cluster G.set(VLabelSelector, X) -> [V2Labeled]; coherence proof
    set G1 = G.set(VLabelSelector,X);
A1: dom G c= dom G1 by FUNCT_4:11;
A2: V2LabelSelector in dom G by Def9;
 G == G1 by GLIB_003:8;
then A3: the_Vertices_of G = the_Vertices_of G1 by GLIB_000:def 36;
A4: G1.V2LabelSelector = the_V2Label_of G by GLIB_000:12;
     dom the_V2Label_of G c= the_Vertices_of G by Th11;
    hence thesis by A1,A2,A3,A4,Def9;
  end;
end;

registration let G be _Graph, Y be set, X be PartFunc of the_Vertices_of G,Y;
  cluster G.set(V2LabelSelector,  X) -> [V2Labeled]; coherence proof
    set G1 = G.set(V2LabelSelector,X);
A1: dom G1 = dom G \/ {V2LabelSelector} by GLIB_000:9;
     V2LabelSelector in {V2LabelSelector} by TARSKI:def 1;
    hence V2LabelSelector in dom G1 by A1,XBOOLE_0:def 2;
     G == G1 by Th12;
then A2: the_Vertices_of G = the_Vertices_of G1 by GLIB_000:def 36;
A3: G1.V2LabelSelector = X by GLIB_000:11;
     dom X c= the_Vertices_of G;
    hence thesis by A2,A3;
  end;
end;

registration let G be _Graph, X be ManySortedSet of the_Vertices_of G;
  cluster G.set(V2LabelSelector,  X) -> [V2Labeled]; coherence proof
    set G1 = G.set(V2LabelSelector,X);
A1: dom G1 = dom G \/ {V2LabelSelector} by GLIB_000:9;
     V2LabelSelector in {V2LabelSelector} by TARSKI:def 1;
    hence V2LabelSelector in dom G1 by A1,XBOOLE_0:def 2;
     G == G1 by Th12;
then A2: the_Vertices_of G = the_Vertices_of G1 by GLIB_000:def 36;
A3: G1.V2LabelSelector = X by GLIB_000:11;
     dom X = the_Vertices_of G by PBOOLE:def 3;
    hence thesis by A2,A3;
  end;
end;

registration let G be _Graph;
  cluster G.set(V2LabelSelector, {}) -> [V2Labeled]; coherence proof
    reconsider X ={} as PartFunc of the_Vertices_of G,{} by PARTFUN1:56;
     G.set(V2LabelSelector, X) is [V2Labeled];
    hence thesis;
  end;
end;

definition let G be V2Graph;
  attr G is natural-v2labeled means                                 :Def11:
    the_V2Label_of G is natural-yielding;
  attr G is finite-v2labeled means                                  :Def12:
    the_V2Label_of G is finite-yielding;
  attr G is natsubset-v2labeled means                               :Def13:
    the_V2Label_of G is natsubset-yielding;
end;

registration
  cluster finite natural-vlabeled finite-v2labeled natsubset-v2labeled chordal
          ([Weighted] [ELabeled] [VLabeled] [V2Labeled] _Graph);
  existence proof
    set V5 = {1}, E3 = {};
    consider S1 being Function of E3,V5;
    consider W1 being ManySortedSet of E3;
    consider EL8 being PartFunc of E3,REAL;
    consider VL6 being PartFunc of V5,REAL;
    reconsider FF = {} as Function;
    set G=<*V5*>^<*E3*>^<*S1*>^<*S1*>^<*W1*>^<*EL8*>^<*FF*>^<*FF*>;
A1: len G = 8 & G.1 = V5 & G.2 = E3 & G.3 = S1 & G.4 = S1 & G.5 = W1 &
      G.6 = EL8 & G.7 = FF & G.8 = FF by FINSEQ_1:91;
    then dom G = Seg 8 by FINSEQ_1:def 3;
    then reconsider G as GraphStruct by GLIB_000:def 1;
     dom G = Seg 8 by A1,FINSEQ_1:def 3;
then A2: VertexSelector in dom G & EdgeSelector in dom G & SourceSelector in
dom G &
    TargetSelector in dom G & WeightSelector in dom G &
    ELabelSelector in dom G & VLabelSelector in dom G &
    V2LabelSelector in dom G;
A3: the_Vertices_of G = V5 & the_Edges_of G = E3 & the_Source_of G = S1 &
    the_Target_of G = S1 & G.WeightSelector = W1 & G.ELabelSelector = EL8 &
      G.VLabelSelector = FF & G.V2LabelSelector = FF by FINSEQ_1:91;
     dom EL8 c= E3 & dom VL6 c= V5 & dom FF c= V5 by RELAT_1:60,XBOOLE_1:2;
    then reconsider G as [Weighted] [ELabeled] [VLabeled] [V2Labeled] _Graph
      by A2,A3,Def9,GLIB_000:def 11,GLIB_003:def 4,def 5,def 6;
    take G;

   thus A4: G is finite by A3,GLIB_000:def 19;
     the_VLabel_of G is natural-yielding by FINSEQ_1:91;
   hence G is natural-vlabeled by Def7;
A5: rng FF c= bool NAT by RELAT_1:60,XBOOLE_1:2;
     for x be set st x in rng FF holds x is finite by RELAT_1:60;
    then A6: the_V2Label_of G is finite-yielding &
         the_V2Label_of G is natsubset-yielding
         by A3,A5,Def3,Lm2;
   hence G is finite-v2labeled by Def12;
   thus G is natsubset-v2labeled by A6,Def13;
    reconsider x = 1 as Vertex of G by A3,TARSKI:def 1;
     the_Vertices_of G = {x} by FINSEQ_1:91;
    then G.order() = 1 by A4,GLIB_000:30;
    then reconsider H=G as trivial _Graph by A4,GLIB_000:29;
     H is chordal;
   hence G is chordal;
  end;

  cluster finite natural-vlabeled natural-v2labeled chordal
          ([Weighted] [ELabeled] [VLabeled] [V2Labeled] _Graph);
  existence proof
    set V5 = {1}, E3 = {};
    consider S1 being Function of E3,V5;
    consider W1 being ManySortedSet of E3;
    consider EL8 being PartFunc of E3,REAL;
    consider VL6 being PartFunc of V5,REAL;
    reconsider FF = {} as Function;
    set G=<*V5*>^<*E3*>^<*S1*>^<*S1*>^<*W1*>^<*EL8*>^<*FF*>^<*FF*>;
A7: len G = 8 & G.1 = V5 & G.2 = E3 & G.3 = S1 & G.4 = S1 & G.5 = W1 &
      G.6 = EL8 & G.7 = FF & G.8 = FF by FINSEQ_1:91;
    then dom G = Seg 8 by FINSEQ_1:def 3;
    then reconsider G as GraphStruct by GLIB_000:def 1;

     dom G = Seg 8 by A7,FINSEQ_1:def 3;
then A8: VertexSelector in dom G & EdgeSelector in dom G & SourceSelector in
dom G &
    TargetSelector in dom G & WeightSelector in dom G &
    ELabelSelector in dom G & VLabelSelector in dom G &
    V2LabelSelector in dom G;
A9: the_Vertices_of G = V5 & the_Edges_of G = E3 & the_Source_of G = S1 &
    the_Target_of G = S1 & G.WeightSelector = W1 & G.ELabelSelector = EL8 &
      G.VLabelSelector = FF & G.V2LabelSelector = FF by FINSEQ_1:91;
     dom EL8 c= E3 & dom VL6 c= V5 & dom FF c= V5 by RELAT_1:60,XBOOLE_1:2;
    then reconsider G as [Weighted] [ELabeled] [VLabeled] [V2Labeled] _Graph
      by A8,A9,Def9,GLIB_000:def 11,GLIB_003:def 4,def 5,def 6;
    take G;

   thus A10: G is finite by A9,GLIB_000:def 19;
     the_VLabel_of G is natural-yielding by FINSEQ_1:91;
   hence G is natural-vlabeled by Def7;
     the_V2Label_of G is natural-yielding by FINSEQ_1:91;
   hence G is natural-v2labeled by Def11;
    reconsider x = 1 as Vertex of G by A9,TARSKI:def 1;
     the_Vertices_of G = {x} by FINSEQ_1:91;
    then G.order() = 1 by A10,GLIB_000:30;
    then reconsider H=G as trivial _Graph by A10,GLIB_000:29;
     H is chordal;
   hence G is chordal;
  end;
end;

registration let G be natural-vlabeled VGraph;
  cluster the_VLabel_of G -> natural-yielding;
  coherence by Def7;
end;

registration let G be natural-v2labeled V2Graph;
  cluster the_V2Label_of G -> natural-yielding;
  coherence by Def11;
end;

registration let G be finite-v2labeled V2Graph;
  cluster the_V2Label_of G -> finite-yielding;
  coherence by Def12;
end;

registration let G be natsubset-v2labeled V2Graph;
  cluster the_V2Label_of G -> natsubset-yielding;
  coherence by Def13;
end;

registration let G be VVGraph, v,x be set;
  cluster G.labelVertex(v,x) -> [V2Labeled];
  coherence proof
  per cases;
  suppose v in the_Vertices_of G;
    then G.labelVertex(v,x) = G.set(VLabelSelector, the_VLabel_of G +* (v.-->x
))
      by GLIB_003:def 22;
    hence thesis; end;
  suppose not v in the_Vertices_of G;
    hence thesis by GLIB_003:def 22;
  end;
  end;
end;

theorem Th13:
for G being VVGraph, v,x being set
 holds the_V2Label_of G = the_V2Label_of G.labelVertex(v,x)
proof let G be VVGraph, v,x be set; set G2 = G.labelVertex(v,x);
  per cases;
  suppose v in the_Vertices_of G;
  then G2 = G.set(VLabelSelector, the_VLabel_of G +* (v.-->x))
        by GLIB_003:def 22;
    hence the_V2Label_of G = the_V2Label_of G2 by GLIB_000:12; end;
  suppose not v in the_Vertices_of G;
  hence thesis by GLIB_003:def 22; end;
end;

registration
  let G be natural-vlabeled VVGraph, v be set, x be natural number;
  cluster G.labelVertex(v,x) -> natural-vlabeled;
  coherence proof
    set GG = G.labelVertex(v,x);     set VLG = the_VLabel_of G;
    set VL = the_VLabel_of GG;       set f  = v.-->x;
A1: dom f = {v} & rng f = {x} by FUNCOP_1:14,19;
     x in NAT by ORDINAL1:def 13;
then A2: rng f c= NAT by A1,ZFMISC_1:37;
A3: rng VLG c= NAT by SEQM_3:def 8;
    per cases;
    suppose v in the_Vertices_of G;
      then GG = G.set(VLabelSelector, VLG +* f) by GLIB_003:def 22;
      then GG.VLabelSelector = VLG +* f by GLIB_000:11;
  then A4: rng VL c= rng VLG \/ rng f by FUNCT_4:18;
       rng VLG \/ rng f c= NAT by A2,A3,XBOOLE_1:8;
      then rng VL c= NAT by A4,XBOOLE_1:1;
      then VL is natural-yielding by SEQM_3:def 8;
     hence thesis by Def7; end;
    suppose not v in the_Vertices_of G;
     hence thesis by GLIB_003:def 22; end;
  end;
end;

registration
  let G be natural-v2labeled VVGraph, v be set, x be natural number;
  cluster G.labelVertex(v,x) -> natural-v2labeled;
  coherence proof
     the_V2Label_of (G.labelVertex(v,x)) = the_V2Label_of G by Th13;
   hence thesis by Def11;
  end;
end;

registration
  let G be finite-v2labeled VVGraph, v be set, x be natural number;
  cluster G.labelVertex(v,x) -> finite-v2labeled;
  coherence proof
     the_V2Label_of (G.labelVertex(v,x)) = the_V2Label_of G by Th13;
   hence thesis by Def12;
  end;
end;

registration
  let G be natsubset-v2labeled VVGraph, v be set, x be natural number;
  cluster G.labelVertex(v,x) -> natsubset-v2labeled;
  coherence proof
     the_V2Label_of (G.labelVertex(v,x)) = the_V2Label_of G by Th13;
   hence thesis by Def13;
  end;
end;

:: Subgraphs and inheritence

registration let G be _Graph;
  cluster [VLabeled] [V2Labeled] Subgraph of G;
  existence proof
    consider V being PartFunc of the_Vertices_of G, REAL;
    set G2 = G.set(VLabelSelector, V);
    consider V2 being PartFunc of the_Vertices_of G2, REAL;
    set G3 = G2.set(V2LabelSelector, V2);
     G == G2 & G2 == G3 by Th12,GLIB_003:8;
    then G == G3 by GLIB_000:88;
    then G3 is Subgraph of G by GLIB_000:90;
    hence thesis;
  end;
end;

definition let G be V2Graph, G2 be [V2Labeled] Subgraph of G;
  attr G2 is v2label-inheriting means                          :Def14:
    the_V2Label_of G2 = (the_V2Label_of G) | the_Vertices_of G2;
end;

registration let G be V2Graph;
  cluster v2label-inheriting ([V2Labeled] Subgraph of G);
  existence proof
    reconsider H = G as [V2Labeled] Subgraph of G by GLIB_000:43;
    take H;
     dom the_V2Label_of G c= the_Vertices_of G by Th11;
    then the_V2Label_of H = (the_V2Label_of G) | the_Vertices_of G by
RELAT_1:97;
    hence H is v2label-inheriting by Def14;
  end;
end;

definition let G be V2Graph;
  mode V2Subgraph of G is v2label-inheriting ([V2Labeled] Subgraph of G);
end;

registration let G be VVGraph;
  cluster vlabel-inheriting v2label-inheriting
          ([VLabeled] [V2Labeled] Subgraph of G);
  existence proof
    reconsider H = G as [VLabeled] [V2Labeled] Subgraph of G by GLIB_000:43;
    take H;
     dom the_VLabel_of G c= the_Vertices_of G by GLIB_003:7;
    then the_VLabel_of H = (the_VLabel_of G) | the_Vertices_of G by RELAT_1:97
;
    hence H is vlabel-inheriting by GLIB_003:def 12;
     dom the_V2Label_of G c= the_Vertices_of G by Th11;
    then the_V2Label_of H = (the_V2Label_of G) | the_Vertices_of G by
RELAT_1:97;
    hence H is v2label-inheriting by Def14;
  end;
end;

definition let G be VVGraph;
  mode VVSubgraph of G is vlabel-inheriting v2label-inheriting
                           ([VLabeled] [V2Labeled] Subgraph of G);
end;

registration let G be natural-vlabeled VGraph;
  cluster -> natural-vlabeled VSubgraph of G;
  coherence proof
    let H be VSubgraph of G;
A1: rng (the_VLabel_of G) c= NAT by SEQM_3:def 8;
     the_VLabel_of H = (the_VLabel_of G) | the_Vertices_of H
        by GLIB_003:def 12;
    then rng (the_VLabel_of H) c= rng (the_VLabel_of G) by RELAT_1:99;
    then rng (the_VLabel_of H) c= NAT by A1,XBOOLE_1:1;
    then the_VLabel_of H is natural-yielding by SEQM_3:def 8;
   hence thesis by Def7;
 end;
end;

registration
  let G be _Graph, V,E be set;
 cluster [Weighted] [ELabeled] [VLabeled] [V2Labeled] inducedSubgraph of G,V,E;
  existence proof
     now per cases;
    suppose
    A1: V is non empty Subset of the_Vertices_of G &
        E c= G.edgesBetween(V);
        consider X being inducedSubgraph of G,V,E;
        consider W being ManySortedSet of the_Edges_of X;
        set G2 = X.set(WeightSelector, W);
        consider EL being PartFunc of the_Edges_of G2, REAL;
        set G3 = G2.set(ELabelSelector, EL);
        consider VL being PartFunc of the_Vertices_of G3, REAL;
        set G4 = G3.set(VLabelSelector, VL);
        consider V2L being PartFunc of the_Vertices_of G4, REAL;
        set G5 = G4.set(V2LabelSelector, V2L);
    A2: X == G2 & G2 == G3 & G3 == G4 & G4 == G5 by Th12,GLIB_003:8;
        then X == G3 by GLIB_000:88;
        then X == G4 by A2,GLIB_000:88;
    then A3: X == G5 by A2,GLIB_000:88;
        then G5 is Subgraph of X by GLIB_000:90;
        then reconsider G5 as Subgraph of G by GLIB_000:46;
         the_Vertices_of X = V & the_Edges_of X = E by A1,GLIB_000:def 39;
        then the_Vertices_of G5 = V & the_Edges_of G5=E by A3,GLIB_000:def 36;
        then G5 is inducedSubgraph of G,V,E by A1,GLIB_000:def 39;
      hence thesis; end;
    suppose
    A4: not (V is non empty Subset of the_Vertices_of G &
        E c= G.edgesBetween(V));
        consider W being ManySortedSet of the_Edges_of G;
        set G2 = G.set(WeightSelector, W);
        consider EL being PartFunc of the_Edges_of G2, REAL;
        set G3 = G2.set(ELabelSelector, EL);
        consider VL being PartFunc of the_Vertices_of G3, REAL;
        set G4 = G3.set(VLabelSelector, VL);
        consider V2L being PartFunc of the_Vertices_of G4, REAL;
        set G5 = G4.set(V2LabelSelector, V2L);
    A5: G == G2 & G2 == G3 & G3 == G4 & G4 == G5 by Th12,GLIB_003:8;
        then G == G3 by GLIB_000:88;
        then G == G4 by A5,GLIB_000:88;
    then A6: G == G5 by A5,GLIB_000:88;
        then reconsider G5 as Subgraph of G by GLIB_000:90;
         G5 is inducedSubgraph of G,V,E by A4,A6,GLIB_000:def 39;
      hence thesis; end;
    end;
    hence thesis;
  end;
end;

registration
  let G be VVGraph, V, E being set;
  cluster vlabel-inheriting v2label-inheriting
     ([VLabeled] [V2Labeled] inducedSubgraph of G,V,E);
  existence proof
     now per cases;
    suppose
    A1: V is non empty Subset of the_Vertices_of G &
        E c= G.edgesBetween(V);
        consider X being [VLabeled] [V2Labeled] inducedSubgraph of G,V,E;
        set VL = (the_VLabel_of G) | the_Vertices_of X;
        reconsider VL'=VL as PartFunc of dom VL, rng VL by PARTFUN1:24;
         dom VL c= the_Vertices_of X by RELAT_1:87;
        then reconsider VL' as PartFunc of the_Vertices_of X, rng VL by
PARTFUN1:28;
        set G1 = X.set(VLabelSelector, VL');
    A2: X == G1 by GLIB_003:8;
        set V2L = (the_V2Label_of G) | the_Vertices_of G1;
        reconsider V2L'=V2L as PartFunc of dom V2L, rng V2L by PARTFUN1:24;
         dom V2L c= the_Vertices_of G1 by RELAT_1:87;
        then reconsider V2L' as PartFunc of the_Vertices_of G1, rng V2L
          by PARTFUN1:28;
        set G2 = G1.set(V2LabelSelector, V2L');
    A3: G2 == G1 by Th12;
    then A4: G2 == X by A2,GLIB_000:88;
        then G2 is Subgraph of X by GLIB_000:90;
        then reconsider G2 as Subgraph of G by GLIB_000:46;
    A5: the_Vertices_of G2 = the_Vertices_of X by A4,GLIB_000:def 36
                          .= V by A1,GLIB_000:def 39;
         the_Edges_of G2 = the_Edges_of X by A4,GLIB_000:def 36
                       .= E by A1,GLIB_000:def 39;
        then reconsider G2 as [VLabeled] [V2Labeled] inducedSubgraph of G,V,E
          by A1,A5,GLIB_000:def 39;
        take G2;
         the_VLabel_of G2  = G1.VLabelSelector by GLIB_000:12
                         .= VL by GLIB_000:11
                         .= (the_VLabel_of G)|the_Vertices_of G2
                           by A4,GLIB_000:def 36;
        hence G2 is vlabel-inheriting by GLIB_003:def 12;
         the_V2Label_of G2 = V2L by GLIB_000:11
                         .= (the_V2Label_of G)|the_Vertices_of G2
                             by A3,GLIB_000:def 36;
        hence G2 is v2label-inheriting by Def14; end;
    suppose
    A6: not (V is non empty Subset of the_Vertices_of G &
        E c= G.edgesBetween(V));
        reconsider GG = G as Subgraph of G by GLIB_000:43;
        reconsider GG as [VLabeled] [V2Labeled] inducedSubgraph of G,V,E
          by A6,GLIB_000:def 39;
        take GG;
         dom the_VLabel_of G c= the_Vertices_of G by GLIB_003:7;
        then the_VLabel_of G = (the_VLabel_of G) | the_Vertices_of G by
RELAT_1:97;
      hence GG is vlabel-inheriting by GLIB_003:def 12;
         dom the_V2Label_of G c= the_Vertices_of G by Th11;
      then the_V2Label_of G = (the_V2Label_of G) | the_Vertices_of G by
RELAT_1:97;
      hence GG is v2label-inheriting by Def14; end;
    end;
    hence thesis;
  end;
end;

definition let G be VVGraph, V,E be set;
  mode inducedVVSubgraph of G,V,E is vlabel-inheriting v2label-inheriting
       ([VLabeled] [V2Labeled] inducedSubgraph of G,V,E);
end;

definition let G be VVGraph, V be set;
  mode inducedVVSubgraph of G,V is inducedVVSubgraph of G,V,G.edgesBetween(V);
end;

begin :: More on Graph Sequences

:::::::::::::: this should go into glib
definition let s be ManySortedSet of NAT;
  attr s is iterative means                 :Def15: ::dGSITERATIVE:
    for k, n being natural number st s.k = s.n holds s.(k+1) = s.(n+1);
end;

definition let GS be ManySortedSet of NAT;
  attr GS is eventually-constant means          :Def16:
    ex n being natural number
     st for m being natural number st n <= m holds GS.n = GS.m;
end;

registration
  cluster halting iterative eventually-constant ManySortedSet of NAT;
  existence proof
    set Fa = NAT --> 1;
    reconsider F=Fa as ManySortedSet of NAT;
    take F;
 F.0 = 1 by FUNCOP_1:13;
    then F.0 = F.(0+1) by FUNCOP_1:13;
  hence F is halting by GLIB_000:def 56;
     now let n,k be natural number such that F.n = F.k;
       F.(n+1) = 1 & F.(k+1) = 1 by FUNCOP_1:13;
      hence F.(n+1) = F.(k+1);
    end;
  hence F is iterative by Def15;
     now let n be natural number such that 0 <= n;
         n in NAT by ORDINAL1:def 13;
        then F.0 = 1 & F.n = 1 by FUNCOP_1:13;
      hence F.0 = F.n;
    end;
  hence F is eventually-constant by Def16;
  end;
end;

theorem Th14:
for Gs being ManySortedSet of NAT
  st Gs is halting & Gs is iterative holds Gs is eventually-constant
proof let Gs be ManySortedSet of NAT such that
A1: Gs is halting & Gs is iterative;
    set GL = Gs.Lifespan();
    defpred P[Nat] means Gs.GL = Gs.(GL+$1);
A2: P[0];
A3: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A4: P[k];
         Gs.(GL+1) = Gs.(GL+k+1) by A1,A4,Def15;
      hence P[k+1] by A1,GLIB_000:def 57;
    end;
A5: for k being Nat holds P[k] from NAT_1:sch 2(A2,A3);
     now let n be natural number such that A6: GL <= n;
       ex i being Nat st GL + i = n by A6,NAT_1:10;
     hence Gs.GL = Gs.n by A5;
    end;
  hence Gs is eventually-constant by Def16;
end;

registration
  cluster halting iterative -> eventually-constant ManySortedSet of NAT;
  coherence by Th14;
end;

theorem Th15:
for Gs being ManySortedSet of NAT
  st Gs is eventually-constant holds Gs is halting
proof let Gs be ManySortedSet of NAT such that
A1: Gs is eventually-constant;
    consider n being natural number such that
A2: for m being natural number
      st n <= m holds Gs.n = Gs.m by A1,Def16;
     n <= n+1 by NAT_1:13;
then Gs.n = Gs.(n+1) by A2;
  hence Gs is halting by GLIB_000:def 56;
end;

registration
  cluster eventually-constant -> halting ManySortedSet of NAT;
  coherence by Th15;
end;

theorem Th16:
for Gs being iterative eventually-constant ManySortedSet of NAT
for n being natural number st Gs.Lifespan() <= n
  holds Gs.(Gs.Lifespan()) = Gs.n
proof let Gs be iterative eventually-constant ManySortedSet of NAT;
    set GL = Gs.Lifespan();
    let n be natural number such that A1: GL <= n;
    defpred P[Nat] means Gs.GL = Gs.(GL+$1);
A2: P[0];
A3: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A4: P[k];
         Gs.(GL+1) = Gs.(GL+k+1) by A4,Def15;
      hence P[k+1] by GLIB_000:def 57;
    end;
A5: for k being Nat holds P[k] from NAT_1:sch 2(A2,A3);
     ex i being Nat st GL + i = n by A1,NAT_1:10;
  hence Gs.n = Gs.GL by A5;
end;

theorem Th17:
for Gs being iterative eventually-constant ManySortedSet of NAT
for n,m being natural number st Gs.Lifespan() <= n & n <= m
  holds Gs.m = Gs.n
proof let Gs be iterative eventually-constant ManySortedSet of NAT;
  let n,m be natural number such that
A1: Gs.Lifespan() <= n & n <= m;
     Gs.Lifespan() <= m by A1,XXREAL_0:2;
    then Gs.(Gs.Lifespan()) = Gs.m by Th16;
  hence thesis by A1,Th16;
end;

definition let GS be VGraphSeq;
  attr GS is natural-vlabeled means                :Def17: ::dGSEQVNATVL:
    for x being natural number holds GS.x is natural-vlabeled;
end;

definition let GS be GraphSeq;
  attr GS is chordal means                        :Def18: ::dGSEQCHORDAL
    for x being natural number holds GS.x is chordal;
  attr GS is fixed-vertices means                       :Def19:
    for n,m being natural number holds
       (the_Vertices_of (GS.n)) = (the_Vertices_of (GS.m));
  attr GS is [V2Labeled] means                   :Def20: ::dGSEQV2LABEL
    for x being natural number holds GS.x is [V2Labeled];
end;

registration
  cluster [Weighted] [ELabeled] [VLabeled] [V2Labeled] GraphSeq;
  existence proof
    consider G being [Weighted] [ELabeled] [VLabeled] [V2Labeled] _Graph;
    set F = NAT --> G;
A1: dom F = NAT by FUNCOP_1:19;
    reconsider F as ManySortedSet of NAT;
     now let x be Nat;
       x in NAT by ORDINAL1:def 13; then
         F.x in rng F by A1,FUNCT_1:12;
        then F.x in {G} by FUNCOP_1:14;
        hence F.x is _Graph by TARSKI:def 1;
    end; then reconsider F as GraphSeq by GLIB_000:def 55;
    take F;
     now let x be Nat;
         x in NAT by ORDINAL1:def 13;
        then F.x in rng F by A1,FUNCT_1:12;
        then F.x in {G} by FUNCOP_1:14;
        hence F.x is [Weighted] & F.x is [ELabeled] &
              F.x is [VLabeled] & F.x is [V2Labeled] by TARSKI:def 1;
    end;
    hence F is [Weighted] & F is [ELabeled] &
          F is [VLabeled] & F is [V2Labeled]
      by Def20,GLIB_003:def 24,def 25,def 26;
  end;
end;

definition
  mode V2GraphSeq is [V2Labeled] GraphSeq;
  mode VVGraphSeq is [VLabeled] [V2Labeled] GraphSeq;
end;

registration let GSq be V2GraphSeq, x be natural number;
  cluster GSq.x -> [V2Labeled] _Graph;
  coherence by Def20;
end;

definition let GSq be V2GraphSeq;
   attr GSq is natural-v2labeled means              :Def21: ::dGSEQNATV2L
     for x being natural number holds GSq.x is natural-v2labeled;
   attr GSq is finite-v2labeled means     :Def22: ::dGSEQNATSUB
     for x being natural number holds GSq.x is finite-v2labeled;
   attr GSq is natsubset-v2labeled means     :Def23: ::dGSEQNATSUB
     for x being natural number holds GSq.x is natsubset-v2labeled;

end;

registration
  cluster finite natural-vlabeled finite-v2labeled natsubset-v2labeled chordal
          ([Weighted] [ELabeled] [VLabeled] [V2Labeled] GraphSeq);
  existence proof
    consider G being finite natural-vlabeled
             finite-v2labeled natsubset-v2labeled chordal
            ([Weighted] [ELabeled] [VLabeled] [V2Labeled] _Graph);
    set F = NAT --> G;
A1: dom F = NAT by FUNCOP_1:19;
    reconsider F as ManySortedSet of NAT;
     now let x be Nat;
       x in NAT by ORDINAL1:def 13; then
         F.x in rng F by A1,FUNCT_1:12;
        then F.x in {G} by FUNCOP_1:14;
        hence F.x is _Graph by TARSKI:def 1;
    end; then reconsider F as GraphSeq by GLIB_000:def 55;
     now let x be Nat;
         x in NAT by ORDINAL1:def 13;
        then F.x in rng F by A1,FUNCT_1:12;
        then F.x in {G} by FUNCOP_1:14;
        hence F.x is [Weighted] & F.x is [ELabeled] &
              F.x is [VLabeled] & F.x is [V2Labeled] by TARSKI:def 1;
    end;
    then reconsider F as [Weighted] [ELabeled] [VLabeled] [V2Labeled] GraphSeq
    by Def20,GLIB_003:def 24,def 25,def 26;
    take F;
     now let x be Nat;
       x in NAT by ORDINAL1:def 13;
      then F.x in rng F by A1,FUNCT_1:12;
      then F.x in {G} by FUNCOP_1:14;
      hence F.x is finite & F.x is natural-vlabeled &
       F.x is finite-v2labeled &
       F.x is natsubset-v2labeled &
       F.x is chordal by TARSKI:def 1;
    end;
    hence F is finite & F is natural-vlabeled &
          F is finite-v2labeled &
          F is natsubset-v2labeled & F is chordal
      by Def17,Def18,Def22,Def23,GLIB_000:def 60;
  end;

  cluster finite natural-vlabeled natural-v2labeled chordal
          ([Weighted] [ELabeled] [VLabeled] [V2Labeled] GraphSeq);
  existence proof
    consider G being finite natural-vlabeled natural-v2labeled chordal
          ([Weighted] [ELabeled] [VLabeled] [V2Labeled] _Graph);
    set F = NAT --> G;
A2: dom F = NAT by FUNCOP_1:19;
    reconsider F as ManySortedSet of NAT;
     now let x be Nat;
       x in NAT by ORDINAL1:def 13; then
         F.x in rng F by A2,FUNCT_1:12;
        then F.x in {G} by FUNCOP_1:14;
        hence F.x is _Graph by TARSKI:def 1;
    end; then reconsider F as GraphSeq by GLIB_000:def 55;
     now let x be Nat;
         x in NAT by ORDINAL1:def 13;
        then F.x in rng F by A2,FUNCT_1:12;
        then F.x in {G} by FUNCOP_1:14;
        hence F.x is [Weighted] & F.x is [ELabeled] &
              F.x is [VLabeled] & F.x is [V2Labeled] by TARSKI:def 1;
    end;
   then reconsider F as [Weighted] [ELabeled] [VLabeled] [V2Labeled] GraphSeq
   by Def20,GLIB_003:def 24,def 25,def 26;
    take F;
     now let x be Nat;
         x in NAT by ORDINAL1:def 13;
      then F.x in rng F by A2,FUNCT_1:12;
      then F.x in {G} by FUNCOP_1:14;
      hence F.x is finite & F.x is natural-vlabeled &
            F.x is natural-v2labeled & F.x is chordal by TARSKI:def 1;
    end;
    hence F is finite & F is natural-vlabeled &
          F is natural-v2labeled & F is chordal
      by Def17,Def18,Def21,GLIB_000:def 60;
  end;
end;

definition let Gs be VGraphSeq, x be natural number;
  redefine func Gs.x -> VGraph;
  coherence by GLIB_003:def 26;
end;

registration let GSq be natural-vlabeled VGraphSeq, x be natural number;
  cluster GSq.x -> natural-vlabeled VGraph;
  coherence by Def17;
end;

registration let GSq be natural-v2labeled V2GraphSeq, x be natural number;
  cluster GSq.x -> natural-v2labeled V2Graph;
  coherence by Def21;
end;

registration
  let GSq be finite-v2labeled V2GraphSeq, x be natural number;
  cluster GSq.x -> finite-v2labeled V2Graph;
  coherence by Def22;
end;

registration
  let GSq be natsubset-v2labeled V2GraphSeq, x be natural number;
  cluster GSq.x -> natsubset-v2labeled V2Graph;
  coherence by Def23;
end;

registration let GSq be chordal GraphSeq, x be natural number;
  cluster GSq.x -> chordal _Graph;
  coherence by Def18;
end;

definition let Gs be VGraphSeq, n being natural number;
  redefine func Gs.n -> VGraph;
  coherence proof
   thus Gs.n is VGraph;
  end;
end;

registration let Gs be finite VGraphSeq, n be natural number;
  cluster Gs.n -> finite VGraph;
  coherence by GLIB_000:def 60;
end;


definition let Gs be VVGraphSeq, n being natural number;
  redefine func Gs.n -> VVGraph;
  coherence proof
   thus Gs.n is VVGraph by Def20;
  end;
end;

registration let Gs be finite VVGraphSeq, n be natural number;
  cluster Gs.n -> finite VVGraph;
  coherence by GLIB_000:def 60;
end;

registration let Gs be chordal VVGraphSeq, n be natural number;
  cluster Gs.n -> chordal VVGraph;
  coherence by Def18;
end;

registration let Gs be natural-vlabeled VVGraphSeq, n be natural number;
  cluster Gs.n -> natural-vlabeled VVGraph;
  coherence by Def17;
end;

registration let Gs be finite-v2labeled VVGraphSeq,
                 n be natural number;
  cluster Gs.n -> finite-v2labeled VVGraph;
  coherence by Def22;
end;

registration let Gs be natsubset-v2labeled VVGraphSeq,
                 n be natural number;
  cluster Gs.n -> natsubset-v2labeled VVGraph;
  coherence by Def23;
end;

registration let Gs be natural-v2labeled VVGraphSeq, n be natural number;
  cluster Gs.n -> natural-v2labeled VVGraph;
  coherence by Def21;
end;

begin :: Vertices numbering sequences

definition let GS be VGraphSeq;

  attr GS is vlabel-initially-empty means  :Def24: ::dVLINITEMPTY
    the_VLabel_of (GS.0) = {};

  attr GS is adds-one-at-a-step means :Def25: ::dVLNUMBERSONE
    for n being natural number st n < GS.Lifespan() holds
     (ex w being set st not w in dom (the_VLabel_of (GS.n)) &
       the_VLabel_of (GS.(n+1)) =
       (the_VLabel_of (GS.n)) +* (w .--> (GS.Lifespan()-'n)));
end;

definition let GS be VGraphSeq;
  attr GS is vlabel-numbering means                          :Def26:
  GS is iterative
        eventually-constant
        finite
        fixed-vertices
        natural-vlabeled
        vlabel-initially-empty
        adds-one-at-a-step;
end;

Lm7:
ex GS being VGraphSeq st
   GS is iterative &
   GS is eventually-constant &
   GS is finite &
   GS is fixed-vertices &
   GS is natural-vlabeled & GS is vlabel-initially-empty &
   GS is adds-one-at-a-step
proof
  consider v being set, E being finite set, S,T being Function of E,{v};
  set Ga = createGraph({v}, E, S, T);

  set vl = v .--> 1;

A1: the_Vertices_of Ga = {v} by GLIB_000:8;

   dom vl = {v} & rng vl = {1} by FUNCOP_1:14,19;
  then dom vl c= the_Vertices_of Ga & rng vl c= NAT by GLIB_000:8;
  then reconsider vl as PartFunc of the_Vertices_of Ga, NAT by RELSET_1:11;
  set Gb = Ga.set(VLabelSelector, vl);
  set G0 = Ga.set(VLabelSelector, {});
  set Fa = NAT --> Gb;
  set F = Fa +* (0 .--> G0);
A2: the_Vertices_of Gb = {v} & the_Vertices_of G0 = {v} by A1,GLIB_000:12;
A3: the_VLabel_of Gb = vl & the_VLabel_of G0 = {} by GLIB_000:11;

     rng vl c= NAT;
then A4: the_VLabel_of Gb is natural-yielding by A3,SEQM_3:def 8;
 the_VLabel_of G0 is natural-yielding by GLIB_000:11;

then A5: Gb is natural-vlabeled & G0 is natural-vlabeled by A4,Def7;
   dom Fa = NAT by FUNCOP_1:19;
  then dom F = NAT \/ dom (0 .--> G0) by FUNCT_4:def 1;
  then dom F = NAT \/ {0} by FUNCOP_1:19;
  then dom F = NAT by XBOOLE_1:12;
  then reconsider F as ManySortedSet of NAT by PBOOLE:def 3;

A6: dom (0 .--> G0) = {0} & 0 in {0} by FUNCOP_1:19,TARSKI:def 1;
then A7: F.0 = (0 .--> G0).0 by FUNCT_4:14;
then A8: F.0 = G0 by FUNCOP_1:87;
A9: for n being Nat st 1 <= n holds F.n = Gb proof
      let n be Nat such that A10: 1 <= n;
         not n in dom (0 .--> G0) by A6,A10,TARSKI:def 1;
    then A11: F.n = Fa.n by FUNCT_4:12;
         n in NAT by ORDINAL1:def 13;
      hence F.n = Gb by A11,FUNCOP_1:13;
    end;

A12: now let n be Nat;
      per cases;
      suppose n <= 0;
        then n = 0;
      hence F.n = G0 or F.n = Gb by A7,FUNCOP_1:87; end;
      suppose n > 0; then n >= 0+1 by NAT_1:13;
      hence F.n = G0 or F.n = Gb by A9; end;
    end;
  then for n being Nat holds F.n is _Graph;
  then reconsider F as GraphSeq by GLIB_000:def 55;
   for n being Nat holds F.n is [VLabeled] by A12;
  then reconsider F as VGraphSeq by GLIB_003:def 26;
  take F;
A13: now let n be Nat;
      per cases;
      suppose n <= 0; then n = 0;
      hence F.n = G0 or F.n = Gb by A7,FUNCOP_1:87; end;
      suppose n > 0; then n >= 0+1 by NAT_1:13;
      hence F.n = G0 or F.n = Gb by A9; end;
    end;
A14: F.1 = Gb & F.2 = Gb by A9;
then A15: F.1 = F.(1+1);
 then A16: F is halting by GLIB_000:def 56;

     now let k,n be natural number such that F.k = F.n;
         k+1 >= 1+0 by XREAL_1:9;
    then A20: F.(k+1) = Gb by A9;
         n+1 >= 1+0 by XREAL_1:9;
      hence F.(k+1) = F.(n+1) by A9,A20;
    end;
    hence A21: F is iterative by Def15;

A22:now let n be Nat such that A23: F.n = F.(n+1);
      assume n < 1; then n < 0+1;
        then 0 <= n & n <= 0 by NAT_1:13;
        then n = 0;
      hence contradiction by A3,A8,A9,A23;
    end;

  thus F is eventually-constant by A16,A21,Th14;

     for n being Nat holds F.n is finite by A13;
  hence F is finite by GLIB_000:def 60;
     now let n,m be Nat;
         (the_Vertices_of (F.n)) = {v} by A2,A13;
      hence (the_Vertices_of (F.n)) = (the_Vertices_of (F.m)) by A2,A13;
    end;
  hence F is fixed-vertices by Def19;
     for n be Nat holds F.n is natural-vlabeled by A5,A13;
  hence F is natural-vlabeled by Def17;
     the_VLabel_of (F.0) = {} by A8,GLIB_000:11;
  hence F is vlabel-initially-empty by Def24;

     for n being Nat st n < F.Lifespan() holds
      (ex w being set st not w in dom (the_VLabel_of (F.n)) &
        the_VLabel_of (F.(n+1)) =
        (the_VLabel_of (F.n)) +* (w .--> (F.Lifespan()-'n))) proof
         let n be Nat such that A24: n < F.Lifespan();
          n < 0+1 by A15,A16,A22,A24,GLIB_000:def 57;
         then n <= 0 & 0 <= n by NAT_1:13;
     then A25: n = 0;
         take v;
      F.Lifespan() - 0 = 1 - 0 by A15,A16,A22,GLIB_000:def 57;
         then F.Lifespan() -' n = 1 by A25,BINARITH:def 3;
       hence thesis by A3,A8,A14,A25,FUNCT_4:21,RELAT_1:60;
    end;
  hence thesis by Def25;
end;

registration
  cluster iterative eventually-constant finite
          fixed-vertices natural-vlabeled vlabel-initially-empty
          adds-one-at-a-step VGraphSeq;
  existence by Lm7;
end;

registration
  cluster vlabel-numbering VGraphSeq;
  existence proof
   consider GS being iterative eventually-constant finite
          fixed-vertices natural-vlabeled vlabel-initially-empty
          adds-one-at-a-step VGraphSeq;
   take GS;
   thus GS is vlabel-numbering by Def26;
  end;
end;

registration
  cluster vlabel-numbering -> iterative VGraphSeq;
  correctness by Def26;
  cluster vlabel-numbering -> eventually-constant VGraphSeq;
  correctness by Def26;
  cluster vlabel-numbering -> finite VGraphSeq;
  correctness by Def26;
  cluster vlabel-numbering -> fixed-vertices VGraphSeq;
  correctness by Def26;
  cluster vlabel-numbering -> natural-vlabeled VGraphSeq;
  correctness by Def26;
  cluster vlabel-numbering -> vlabel-initially-empty VGraphSeq;
  correctness by Def26;
  cluster vlabel-numbering -> adds-one-at-a-step VGraphSeq;
  correctness by Def26;
end;

definition
  mode VLabelNumberingSeq is vlabel-numbering VGraphSeq;
end;

definition let GS be VLabelNumberingSeq, n be natural number;
  func GS.PickedAt(n) -> set means                             :Def27:
    it = choose (the_Vertices_of (GS.0)) if n >= GS.Lifespan() otherwise
    not it in dom (the_VLabel_of (GS.n)) & the_VLabel_of (GS.(n+1)) =
        (the_VLabel_of (GS.n)) +* (it .--> (GS.Lifespan()-'n));
  existence proof
  per cases;
  suppose n >= GS.Lifespan();
    hence thesis; end;
  suppose n < GS.Lifespan();
    then consider w being set such that
 A1: not w in dom (the_VLabel_of (GS.n)) and
 A2: the_VLabel_of (GS.(n+1)) =
    (the_VLabel_of (GS.n)) +* (w .--> (GS.Lifespan()-'n)) by Def25;
   thus thesis by A1,A2; end;
  end;
  uniqueness proof
    let IT1,IT2 be set;
    thus n >= GS.Lifespan() &
      IT1 = choose (the_Vertices_of (GS.0)) &
      IT2 = choose (the_Vertices_of (GS.0)) implies IT1 = IT2;
    set VLN = the_VLabel_of (GS.n);
    set VL1 = the_VLabel_of (GS.(n+1));
    assume n < GS.Lifespan();
    assume A3: not IT1 in dom VLN & VL1 = VLN +* (IT1 .--> (GS.Lifespan()-'n));
    assume A4: not IT2 in dom VLN & VL1 = VLN +* (IT2 .--> (GS.Lifespan()-'n));
    set f1 = IT1 .--> (GS.Lifespan()-'n);
    set f2 = IT2 .--> (GS.Lifespan()-'n);
 A5: dom f1 = {IT1} & rng f1 = {GS.Lifespan()-'n} by FUNCOP_1:14,19;
 A6: dom f2 = {IT2} & rng f2 = {GS.Lifespan()-'n} by FUNCOP_1:14,19;
 A7: dom VL1 = dom VLN \/ {IT1} by A3,A5,FUNCT_4:def 1;
 A8: dom VL1 = dom VLN \/ {IT2} by A4,A6,FUNCT_4:def 1;
     now assume IT1 <> IT2;
        then not IT1 in {IT2} by TARSKI:def 1;
    then A9: not IT1 in dom VL1 by A3,A8,XBOOLE_0:def 2;
         IT1 in {IT1} by TARSKI:def 1;
      hence contradiction by A7,A9,XBOOLE_0:def 2;
    end;
   hence IT1 = IT2;
  end;
  consistency;
end;

theorem Th18:
for GS being VLabelNumberingSeq,
    n being natural number st n < GS.Lifespan()
  holds GS.PickedAt(n) in (GS.(n+1)).labeledV() &
        (GS.(n+1)).labeledV() = (GS.n).labeledV() \/ {GS.PickedAt(n)}
proof let GS be VLabelNumberingSeq, n be Nat such that
A1: n < GS.Lifespan();
    set CSN = GS.n;     set VLN = the_VLabel_of CSN;
    set CN1 = GS.(n+1); set VN1 = the_VLabel_of CN1;
A2: VN1 = VLN +* (GS.PickedAt(n) .--> (GS.Lifespan() -' n)) by A1,Def27;
    set f = (GS.PickedAt(n)) .--> (GS.Lifespan() -' n);
A3: dom f = {GS.PickedAt(n)} & rng f = {GS.Lifespan()-'n} by FUNCOP_1:14,19;
then A4: dom VN1 = dom VLN \/ {GS.PickedAt(n)} by A2,FUNCT_4:def 1;
     GS.PickedAt(n) in {GS.PickedAt(n)} by TARSKI:def 1;
  hence GS.PickedAt(n) in CN1.labeledV()
      by A4,XBOOLE_0:def 2;
  thus CN1.labeledV() = CSN.labeledV() \/ {GS.PickedAt(n)}
      by A2,A3,FUNCT_4:def 1;
end;

theorem Th19:
for GS being VLabelNumberingSeq, n
    being natural number st n < GS.Lifespan()
  holds (the_VLabel_of (GS.(n+1))).(GS.PickedAt(n)) = GS.Lifespan()-'n
proof let GS be VLabelNumberingSeq, n be Nat such that
A1: n < GS.Lifespan();
    set CSN = GS.n;     set VLN = the_VLabel_of CSN;
    set CN1 = GS.(n+1); set VN1 = the_VLabel_of CN1;
    set w = GS.PickedAt(n);
A2: VN1 = VLN +* (w .--> (GS.Lifespan() -' n)) by A1,Def27;
    set f  = w .--> (GS.Lifespan() -' n);
     dom f = {w} & rng f = {GS.Lifespan() -' n} by FUNCOP_1:14,19;
then A3: w in dom f by TARSKI:def 1;
     f.w = GS.Lifespan() -' n by FUNCOP_1:87;
  hence VN1.w = GS.Lifespan() -' n by A2,A3,FUNCT_4:14;
end;

theorem
 for GS being VLabelNumberingSeq, n being natural number
 st n <= GS.Lifespan() holds card ((GS.n).labeledV()) = n
proof let GS be VLabelNumberingSeq, n be Nat such that
A1: n <= GS.Lifespan();
 defpred P[Nat] means
  $1 <= GS.Lifespan() implies card dom the_VLabel_of (GS.$1) = $1;
 A2: for k being Nat
     st k < GS.Lifespan() & card dom the_VLabel_of (GS.k) = k
      holds card dom the_VLabel_of (GS.(k+1)) = k+1
    proof let k be Nat such that
    A3: k < GS.Lifespan() & card dom the_VLabel_of (GS.k) = k;
        set CSK = GS.k;      set VLK = the_VLabel_of CSK;
        set CK1 = GS.(k+1);  set VK1 = the_VLabel_of CK1;
        set w = GS.PickedAt(k);
    A4: VK1 = VLK +* (w .--> (GS.Lifespan()-'k)) by A3,Def27;
        set wf  = w .--> (GS.Lifespan() -' k);
         dom wf = {w} & rng wf = {GS.Lifespan() -' k} by FUNCOP_1:14,19;
    then A5: dom VK1 = dom VLK \/ {w} by A4,FUNCT_4:def 1;
         not w in dom VLK by A3,Def27;
      hence thesis by A3,A5,CARD_2:54;
    end;
A6: P[0] by Def24,CARD_1:78,RELAT_1:60;
A7: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A8: P[k];
      per cases;
      suppose k < GS.Lifespan();
        hence P[k+1] by A2,A8;
      end;
      suppose k >= GS.Lifespan();
        hence P[k+1] by NAT_1:13;
      end;
      end;
       for k being Nat holds P[k] from NAT_1:sch 2(A6,A7);
  hence card (GS.n).labeledV() = n by A1;
end;

theorem Th21:
for GS being VLabelNumberingSeq, n being natural number holds
  rng the_VLabel_of (GS.n) = (Seg GS.Lifespan()) \ Seg (GS.Lifespan()-'n)
proof let GS be VLabelNumberingSeq, n be Nat;
    set CSN = GS.n;             set VLN = the_VLabel_of CSN;
    set CSO = GS.GS.Lifespan(); set VLO = the_VLabel_of CSO;
    set GN = GS.Lifespan();
    defpred P[Nat] means $1 <= GN implies
     rng the_VLabel_of (GS.$1) = (Seg GN) \ Seg (GN-'$1);
A1: P[0] proof
        set CS0 = GS.0;   set VL0 = the_VLabel_of CS0;
    A2: rng VL0 = {} by Def24,RELAT_1:60;
         GN -' 0 = GN - 0 by BINARITH:50;
      hence P[0] by A2,XBOOLE_1:37;
    end;
A3: for k being Nat st P[k] holds P[k+1] proof
      let k be Nat such that A4: P[k];
      set CSK = GS.k;     set VLK = the_VLabel_of CSK;
      set CK1 = GS.(k+1); set VK1 = the_VLabel_of CK1;
      per cases;
      suppose k+1 <= GN;
    then A5: k < GN by NAT_1:13;
        set w = GS.PickedAt(k);
    A6: VK1 = VLK +* (w .--> (GN -' k)) by A5,Def27;
        set wf  = w .--> (GN -' k);
    A7: dom wf = {w} & rng wf = {GN -' k} by FUNCOP_1:14,19;
         not w in dom VLK by A5,Def27;
        then dom wf misses dom VLK by A7,ZFMISC_1:56;
        then rng VK1 = rng VLK \/ {GN -' k} by A6,A7,NECKLACE:7;
        hence P[k+1] by A4,A5,Th7;
      end;
      suppose GN < k+1;
      hence P[k+1]; end;
    end;
A8: for k being Nat holds P[k] from NAT_1:sch 2(A1,A3);
  per cases;
  suppose n <= GN;
  hence rng VLN = (Seg GN) \ Seg (GN -' n) by A8; end;
  suppose A9: GN < n;
    then GN - n < n - n by XREAL_1:11;
then GN -' n = 0 by BINARITH:def 3;
then A10: GN -' GN = GN -' n by BINARITH:51;
     CSO = CSN by A9,Th16;
  hence rng VLN = (Seg GN) \ Seg (GN -' n) by A8,A10; end;
end;

theorem Th22:
for GS being VLabelNumberingSeq, n being natural number, x being set
  holds (the_VLabel_of (GS.n)).x <= GS.Lifespan() &
        ((x in (GS.n).labeledV()) implies 1 <= (the_VLabel_of (GS.n)).x)
proof let GS be VLabelNumberingSeq, n be Nat, x be set;
  set CSN = GS.n;  set VLN = the_VLabel_of CSN;
A1:now per cases;
    suppose not x in dom VLN;
      then VLN.x = 0 by FUNCT_1:def 4;
    hence VLN.x <= GS.Lifespan(); end;
    suppose x in dom VLN;
      then VLN.x in rng VLN by FUNCT_1:def 5;
      then VLN.x in (Seg GS.Lifespan()) \ Seg (GS.Lifespan() -'n ) by Th21;
    hence VLN.x <= GS.Lifespan() by Th5; end;
  end;
   now assume x in (GS.n).labeledV();
      then VLN.x in rng VLN by FUNCT_1:def 5;
      then VLN.x in (Seg GS.Lifespan()) \ Seg (GS.Lifespan() -'n ) by Th21;
  then GS.Lifespan() -' n < VLN.x by Th5;
      then 0+1 <= VLN.x by NAT_1:13;
    hence 1 <= VLN.x;
  end;
  hence thesis by A1;
end;

theorem Th23:
for GS being VLabelNumberingSeq, n,m being natural number
 st GS.Lifespan() -' n < m & m <= GS.Lifespan()
  ex v being Vertex of GS.n
   st v in (GS.n).labeledV() & (the_VLabel_of (GS.n)).v = m
proof let GS be VLabelNumberingSeq, n,m be Nat such that
A1: GS.Lifespan() -' n < m & m <= GS.Lifespan();
    set CSN = GS.n; set VLN = the_VLabel_of CSN;
     m in (Seg GS.Lifespan()) \ Seg (GS.Lifespan()-'n) by A1,Th5;
    then m in rng VLN by Th21;
    then consider v being set such that
A2: v in dom VLN and
A3: m = VLN.v by FUNCT_1:def 5;
    take v;
     dom VLN c= the_Vertices_of CSN by GLIB_003:7;
  hence v is Vertex of CSN by A2;
  thus v in CSN.labeledV() by A2;
  thus VLN.v = m by A3;
end;

theorem Th24:
for GS being VLabelNumberingSeq, m,n being natural number st m <= n
  holds the_VLabel_of (GS.m) c= the_VLabel_of (GS.n)
proof let GS be VLabelNumberingSeq, m,n be Nat such that A1: m <= n;
    set CSM = GS.m; set VLM = the_VLabel_of CSM;
    set CSN = GS.n; set VLN = the_VLabel_of CSN;
    defpred P[Nat] means VLM c= the_VLabel_of (GS.(m+$1));
 A2: now let k be Nat;
        set CSK = GS.k;     set VLK = the_VLabel_of CSK;
        set CK1 = GS.(k+1); set VK1 = the_VLabel_of CK1;
      per cases;
      suppose A3: k < GS.Lifespan();
        set w = GS.PickedAt(k);
    A4: VK1 = VLK +* (w .--> (GS.Lifespan()-'k)) by A3,Def27;
        set wf  = w .--> (GS.Lifespan() -' k);
    A5: dom wf = {w} & rng wf = {GS.Lifespan() -' k} by FUNCOP_1:14,19;
         not w in dom VLK by A3,Def27;
        then dom wf misses dom VLK by A5,ZFMISC_1:56;
      hence VLK c= VK1 by A4,FUNCT_4:33; end;
      suppose A6: GS.Lifespan() <= k;
        k <= k+1 by NAT_1:13;
      hence VLK c= VK1 by A6,Th17; end;
    end;
A7: P[0];
A8: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A9: P[k];
         the_VLabel_of (GS.(m+k)) c=
        the_VLabel_of (GS.(m+k+1)) by A2;
      hence P[k+1] by A9,XBOOLE_1:1;
    end;
A10: for k being Nat holds P[k] from NAT_1:sch 2(A7,A8);
     ex j being Nat st n = m + j by A1,NAT_1:10;
  hence VLM c= VLN by A10;
end;

theorem Th25:
for GS being VLabelNumberingSeq, n being natural number
 holds the_VLabel_of (GS.n) is one-to-one
proof let GS be VLabelNumberingSeq, n be Nat;
    defpred P[Nat] means
      the_VLabel_of (GS.$1) is one-to-one;
A1: P[0] by Def24;
A2: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A3: P[k];
        set CSK = GS.k;     set VLK = the_VLabel_of CSK;
        set CK1 = GS.(k+1); set VL1 = the_VLabel_of CK1;
        set GN = GS.Lifespan();
        set w = GS.PickedAt(k);
      per cases;
      suppose k < GN;
    then A4: VL1 = VLK +* (w .--> (GN -' k)) by Def27;
        set wf  = w .--> (GN -' k);
    A5: dom wf = {w} & rng wf = {GN -' k} by FUNCOP_1:14,19;
         now assume A6: GN -' k in rng VLK;
             rng VLK = (Seg GN) \ Seg (GN -' k) by Th21;
          hence contradiction by A6,Th5;
        end;
    then A7: rng wf misses rng VLK by A5,ZFMISC_1:56;
         now let x1,x2 be set such that
        A8: x1 in dom wf & x2 in dom wf and wf.x1 = wf.x2;
             x1 = w & x2 = w by A5,A8,TARSKI:def 1;
          hence x1 = x2;
        end;
        then wf is one-to-one by FUNCT_1:def 8;
      hence P[k+1] by A3,A4,A7,KNASTER:1;
    end;
      suppose A9: k >= GN;
         k <= k+1 by NAT_1:13;
        hence P[k+1] by A3,A9,Th17; end;
    end;
     for k being Nat holds P[k] from NAT_1:sch 2(A1,A2);
  hence thesis;
end;

theorem Th26:
for GS being VLabelNumberingSeq, m,n being natural number
for v being set st v in (GS.m).labeledV() & v in (GS.n).labeledV()
  holds (the_VLabel_of (GS.m)).v = (the_VLabel_of (GS.n)).v
proof let GS be VLabelNumberingSeq, m,n be Nat;
    let v be set such that
A1: v in (GS.m).labeledV() and
A2: v in (GS.n).labeledV();
    set VLM = the_VLabel_of (GS.m);    set VLN = the_VLabel_of (GS.n);
A3: [v,VLM.v] in VLM by A1,FUNCT_1:def 4;
A4: [v,VLN.v] in VLN by A2,FUNCT_1:def 4;
  per cases;
  suppose m <= n;
    then VLM c= VLN by Th24;
  hence VLM.v = VLN.v by A2,A3,FUNCT_1:def 4; end;
  suppose m > n;
    then VLN c= VLM by Th24;
  hence VLM.v = VLN.v by A1,A4,FUNCT_1:def 4; end;
end;

theorem Th27:
for GS being VLabelNumberingSeq, v being set, m,n being natural number
 st (v in (GS.m).labeledV() & (the_VLabel_of (GS.m)).v = n)
  holds GS.PickedAt(GS.Lifespan()-'n) = v
proof let GS be VLabelNumberingSeq, v be set, m,n be Nat;
    set CSM = GS.m;                set VLM = the_VLabel_of CSM;
    set j = GS.Lifespan() -' n;
    set CSJ = GS.j;     set VLJ = the_VLabel_of CSJ;
    set CJ1 = GS.(j+1); set VJ1 = the_VLabel_of CJ1;
    assume A1: v in CSM.labeledV() & VLM.v = n;
then A2: 1 <= n & n <= GS.Lifespan() by Th22;
A3: 0 < n by A1,Th22;
A4: GS.Lifespan() -' n = GS.Lifespan() - n by A2,BINARITH:50;
then A5: j < GS.Lifespan() by A3,XREAL_1:46;
    set w = GS.PickedAt(j);
A6: w in CJ1.labeledV() by A5,Th18;
     GS.Lifespan() -' j = GS.Lifespan() - (GS.Lifespan() - n)
    by A4,A5,BINARITH:50;
then A7: VJ1.w = n by A5,Th19;
A8: VLM is one-to-one by Th25;
  per cases;
  suppose A9: m <= j;
    then m + n <= GS.Lifespan() - n + n by A4,XREAL_1:8;
then A10: n + m - m <= GS.Lifespan() - m by XREAL_1:11;
     m <= GS.Lifespan() by A5,A9,XXREAL_0:2;
then A11: GS.Lifespan() - m = GS.Lifespan() -' m by BINARITH:50;
A12: n in rng VLM by A1,FUNCT_1:def 5;
     rng VLM = (Seg GS.Lifespan()) \ Seg (GS.Lifespan() -' m) by Th21;
    hence v = GS.PickedAt(j) by A10,A11,A12,Th5;
  end;
  suppose j < m; then j+1 <= m by NAT_1:13;
then A13: VJ1 c= VLM by Th24;
then A14: dom VJ1 c= dom VLM by RELAT_1:25;
     [w,n] in VJ1 by A6,A7,FUNCT_1:def 4;
    then VLM.w = n by A6,A13,A14,FUNCT_1:def 4;
    hence v = GS.PickedAt(j) by A1,A6,A8,A14,FUNCT_1:def 8;
  end;
end;

theorem Th28:
for GS being VLabelNumberingSeq, m,n being natural number
 st n < GS.Lifespan() & n < m
   holds GS.PickedAt(n) in (GS.m).labeledV() &
         (the_VLabel_of (GS.m)).(GS.PickedAt(n)) = GS.Lifespan() -' n
proof let GS be VLabelNumberingSeq, m,n be Nat such that
A1: n < GS.Lifespan() and A2: n < m;
    set v = GS.PickedAt(n);
    set CN1 = GS.(n+1); set VN1 = the_VLabel_of CN1;
    set CSM = GS.m;     set VLM = the_VLabel_of CSM;
A3: v in CN1.labeledV() by A1,Th18;
A4: VN1.v = GS.Lifespan() -' n by A1,Th19;
     n+1 <= m by A2,NAT_1:13;
    then VN1 c= VLM by Th24;
    then dom VN1 c= dom VLM by RELAT_1:25;
  hence v in CSM.labeledV() by A3;
  hence VLM.v = GS.Lifespan() -' n by A3,A4,Th26;
end;

:: Inequalities relating the vlabel and the current iteration
theorem Th29:
for GS being VLabelNumberingSeq, m being natural number, v being set
  st v in (GS.m).labeledV()
   holds GS.Lifespan() -' (the_VLabel_of (GS.m)).v < m &
         GS.Lifespan() -' m < (the_VLabel_of (GS.m)).v
proof let GS be VLabelNumberingSeq, m be Nat, v be set;
    set CSM = GS.m; set VLM = the_VLabel_of (GS.m);
    set j = GS.Lifespan() -' VLM.v;
    set CSJ = GS.j; set VLJ = the_VLabel_of (GS.j);
    assume A1: v in CSM.labeledV();
then A2: GS.PickedAt(j) = v by Th27;
A3: 1 <= VLM.v & VLM.v <= GS.Lifespan() by A1,Th22;
A4: 0 < VLM.v by A1,Th22;
     j = GS.Lifespan() - VLM.v by A3,BINARITH:50;
then A5: j < GS.Lifespan() by A4,XREAL_1:46;
A6: now per cases;
      suppose m <= j;
        then VLM c= VLJ by Th24;
        then dom VLM c= dom VLJ by RELAT_1:25;
      hence GS.Lifespan() -' VLM.v < m by A1,A2,A5,Def27; end;
      suppose m > j;
      hence GS.Lifespan() -' VLM.v < m; end;
    end;
     now per cases;
      suppose A7: GS.Lifespan() - m >= 0;
         GS.Lifespan() - VLM.v < m by A3,A6,BINARITH:50;
        then GS.Lifespan() - VLM.v + VLM.v < m + VLM.v by XREAL_1:8;
        then GS.Lifespan() - m  < VLM.v + m - m by XREAL_1:11;
      hence GS.Lifespan() -'m < VLM.v by A7,BINARITH:def 3; end;
      suppose GS.Lifespan() - m < 0;
      hence GS.Lifespan() -'m < VLM.v by A4,BINARITH:def 3;
    end;
    end;
  hence thesis by A6;
end;

:: If a vertex has a larger vlabel than we do at some point in the
:: algorithm, then it must have been in the vlabel when we were picked
theorem Th30:
for GS being VLabelNumberingSeq
for i being natural number, a,b being set
 st a in (GS.i).labeledV() & b in (GS.i).labeledV() &
    (the_VLabel_of (GS.i)).a < (the_VLabel_of (GS.i)).b
  holds b in (GS.(GS.Lifespan() -' (the_VLabel_of (GS.i)).a)).labeledV()
proof let GS be VLabelNumberingSeq;
    let i be Nat, a,b be set such that
A1: a in (GS.i).labeledV() and
A2: b in (GS.i).labeledV() and
A3: (the_VLabel_of (GS.i)).a < (the_VLabel_of (GS.i)).b;
    set CSI = GS.i; set VLI = the_VLabel_of CSI;
    set j = GS.Lifespan() -' VLI.a;
    set CSJ = GS.j; set VLJ = the_VLabel_of CSJ;    set GN = GS.Lifespan();
     VLI.a <= GN by Th22;
then A4: GN -' VLI.a = GN - VLI.a by BINARITH:50;
     GN -' VLI.a <= GN by BINARITH:52;
then A5: GN -' j = GN - (GN - VLI.a) by A4,BINARITH:50;
     VLI.b <= GN by Th22;
    then consider w being Vertex of CSJ such that
A6: w in CSJ.labeledV() and
A7: VLJ.w = VLI.b by A3,A5,Th23;
     now assume j >= i;
        then VLI c= VLJ by Th24;
    then A8: dom VLI c= dom VLJ by RELAT_1:25;
    A9: a = GS.PickedAt(j) by A1,Th27;
     0 < VLI.a by A1,Th22;
        then j < GN by A4,XREAL_1:46;
       hence contradiction by A1,A8,A9,Def27;
    end;
then A10: VLJ c= VLI by Th24;
     [w,VLI.b] in VLJ by A6,A7,FUNCT_1:8;
then A11:w in dom VLI & VLI.w = VLI.b by A10,FUNCT_1:8;
     VLI is one-to-one by Th25;
  hence b in CSJ.labeledV() by A2,A6,A11,FUNCT_1:def 8;
end;

theorem Th31:
for GS being VLabelNumberingSeq
for i being natural number, a,b being set
 st a in (GS.i).labeledV() & b in (GS.i).labeledV() &
    (the_VLabel_of (GS.i)).a < (the_VLabel_of (GS.i)).b
 holds not a in (GS.(GS.Lifespan() -' (the_VLabel_of (GS.i)).b)).labeledV()
proof let GS be VLabelNumberingSeq;
    let i be Nat, a,b be set such that
A1: a in (GS.i).labeledV() and b in (GS.i).labeledV() and
A2: (the_VLabel_of (GS.i)).a < (the_VLabel_of (GS.i)).b;
    set CSI = GS.i; set VLI = the_VLabel_of CSI;
    set GN = GS.Lifespan();    set k = GN -' VLI.a;    set j = GN -' VLI.b;
    set CSJ = GS.j; set VLJ = the_VLabel_of CSJ;
    set CSK = GS.k; set VLK = the_VLabel_of CSK;
     VLI.b <= GN by Th22;
then A3: j = GN - VLI.b by BINARITH:50;
     VLI.a <= GN by Th22;
then A4: k = GN - VLI.a by BINARITH:50;
     1 <= VLI.a by A1,Th22;
then A5: k < GN by A4,XREAL_1:46;
    assume
A6: a in CSJ.labeledV();
A7: GS.PickedAt(k) = a by A1,Th27;
     j < k by A2,A3,A4,XREAL_1:17;
    then VLJ c= VLK by Th24;
    then dom VLJ c= dom VLK by RELAT_1:25;
  hence contradiction by A5,A6,A7,Def27;
end;

begin :: Lexicographical Breadth-First Search

definition let G be _Graph;
  func LexBFS:Init(G) ->
                  natural-vlabeled finite-v2labeled natsubset-v2labeled
                  VVGraph equals
     G.set(VLabelSelector, {}).set(V2LabelSelector, the_Vertices_of G --> {});
  coherence proof
    set G1 = G.set(VLabelSelector, {});    set g  = the_Vertices_of G --> {};
A1: G1 == G by GLIB_003:8;
     dom g = the_Vertices_of G by FUNCOP_1:19;
    then dom g = the_Vertices_of G1 by A1,GLIB_000:def 36;
    then reconsider f = g as PartFunc of the_Vertices_of G1, rng g by
PARTFUN1:24;
    set G2 = G1.set(V2LabelSelector, f);
A2: the_V2Label_of G2 = f by GLIB_000:11;
 the_VLabel_of G2 = the_VLabel_of G1 by GLIB_000:12;
then A3: the_VLabel_of G2 is natural-yielding by GLIB_000:11;
A4: rng the_V2Label_of G2 = {{}} by A2,FUNCOP_1:14;
     now let x be set such that A5: x in rng the_V2Label_of G2;
         x = {} by A4,A5,TARSKI:def 1;
        then x c= NAT by XBOOLE_1:2;
      hence x in bool NAT;
    end;
then A6: rng the_V2Label_of G2 is Subset of bool NAT by TARSKI:def 3;
     for x be set st x in rng the_V2Label_of G2 holds x is finite
      by A4,TARSKI:def 1;
    then the_V2Label_of G2 is finite-yielding &
         the_V2Label_of G2 is natsubset-yielding
         by A6,Def3,Lm2;
  hence thesis by A3,Def7,Def12,Def13;
 end;
end;

definition let G be finite _Graph;
  redefine func LexBFS:Init(G)
                -> finite natural-vlabeled
                   finite-v2labeled natsubset-v2labeled VVGraph;
  coherence;
end;

definition let G be finite finite-v2labeled natsubset-v2labeled VVGraph;
  assume A1: dom the_V2Label_of G = the_Vertices_of G;
  func LexBFS:PickUnnumbered(G) -> Vertex of G means :Def29:
  it = choose the_Vertices_of G if dom the_VLabel_of G = the_Vertices_of G
  otherwise
  ex S being non empty finite Subset of bool NAT,
     B being non empty finite Subset of Bags NAT,
     F being Function
  st S = rng F &
     F = ((the_V2Label_of G) | (the_Vertices_of G \ dom the_VLabel_of G)) &
     (for x being finite Subset of NAT holds x in S implies ((x,1)-bag in B)) &
     (for x being set holds x in B implies
            ex y being finite Subset of NAT st y in S & x = (y,1)-bag) &
   it = choose (F " {support max(B,InvLexOrder NAT)});
  existence proof
  set VLG = the_VLabel_of G;    set V2G = the_V2Label_of G;
  set VG = the_Vertices_of G;   set F = V2G | (VG \ dom VLG);  set S = rng F;
  per cases;
  suppose dom VLG = VG;
  hence thesis; end;
  suppose A2: dom VLG <> VG;
A3: dom F c= dom V2G & rng F c= rng V2G by RELAT_1:89,99;
A4: dom F c= the_Vertices_of G by A1,RELAT_1:89;
A5: dom VLG c= VG by GLIB_003:7;
     dom F = dom V2G /\ (VG \ dom VLG) by FUNCT_1:68;
then A6: dom F = (VG /\ VG) \ dom VLG by A1,XBOOLE_1:49;
A7:now assume dom F = {};
      then VG c= dom VLG by A6,XBOOLE_1:37;
     hence contradiction by A2,A5,XBOOLE_0:def 10;
    end;
then A8: S is non empty by RELAT_1:65;
A9: now let x be set such that A10: x in S;
    A11: x in rng V2G by A3,A10;
         rng V2G c= bool NAT by Def3;
        hence x in bool NAT by A11;
        thus x is finite by A10,Lm3;
    end;
then A12: for x being set holds x in S implies x in bool NAT;
A13: for x being Element of S holds x is finite by A8,Lm3;
     dom F is finite by A4,FINSET_1:13;
    then reconsider S as non empty finite with_finite-elements Subset of bool
NAT
       by A7,A12,A13,Def1,FINSET_1:26,RELAT_1:65,TARSKI:def 3;
    deffunc A() = S;
    deffunc F(finite Subset of NAT) = ($1,1)-bag;
    deffunc W() = S;
A14: W() is finite;
    set B = {F(x) where x is Element of A(): x in W()};
A15: B is finite from FRAENKEL:sch 21(A14);
    consider z being set such that
A16: z in S by XBOOLE_0:def 1;
    reconsider z as finite Subset of NAT by A9,A16;
A17: (z,1)-bag in B by A16;
 now let x be set such that A18: x in B;
        consider y being Element of S such that
    A19: x = (y,1)-bag & y in S by A18;
      thus x in Bags NAT by A19;
    end;
    then reconsider B as non empty finite Subset of Bags NAT
       by A15,A17,TARSKI:def 3;
A20: for x being finite Subset of NAT holds x in S implies ((x,1)-bag in B);
A21: for x being set holds x in B implies
      ex y being finite Subset of NAT st y in S & x = (y,1)-bag proof
      let x be set such that A22: x in B;
      consider y being Element of S such that
    A23: x = (y,1)-bag & y in S by A22;
      thus thesis by A23;
    end;
    set mw = max(B,InvLexOrder NAT);    set IT = choose (F " {support mw});
     mw in B by Def5;
    then consider y being finite Subset of NAT such that
A24: y in S & mw = (y,1)-bag by A21;
 y = support mw by A24,UPROOTS:10;
then F " {support mw} is non empty by A24,FUNCT_1:142;
    then IT in dom F by FUNCT_1:def 13;
    then reconsider IT as Vertex of G by A4;
    ex S being non empty finite Subset of bool NAT,
      B being non empty finite Subset of Bags NAT,
      F being Function
   st S = rng F &
      F = ((the_V2Label_of G) | (the_Vertices_of G \ dom the_VLabel_of G)) &
     (for x being finite Subset of NAT holds x in S implies ((x,1)-bag in B)) &
      (for x being set holds x in B implies
             ex y being finite Subset of NAT st y in S & x = (y,1)-bag) &
    IT = choose (F " {support max(B,InvLexOrder NAT)})
    & IT is Vertex of G by A20,A21;
     hence thesis; end;
  end;
  uniqueness proof
    set VLG = the_VLabel_of G;    set V2G = the_V2Label_of G;
    set VG = the_Vertices_of G;
    let IT1, IT2 be Vertex of G;
    thus dom VLG = VG & IT1 = choose VG & IT2 = choose VG implies IT1=IT2;
    assume dom VLG <> VG;
    assume
     ex S1 being non empty finite Subset of bool NAT,
     B1 being non empty finite Subset of Bags NAT,
     F1 being Function  st S1 = rng F1 & F1 = (V2G | (VG \ dom VLG)) &
   (for x being finite Subset of NAT holds x in S1 implies ((x,1)-bag in B1)) &
    (for x being set holds x in B1 implies
            ex y being finite Subset of NAT st y in S1 & x = (y,1)-bag) &
    IT1 = choose (F1 " {support max(B1,InvLexOrder NAT)});
    then consider S1 being non empty finite Subset of bool NAT,
             B1 being non empty finite Subset of Bags NAT,
             F1 being Function such that
A25: S1 = rng F1 & F1 = (V2G | (VG \ dom VLG)) &
   (for x being finite Subset of NAT holds x in S1 implies ((x,1)-bag in B1)) &
   (for x being set holds x in B1 implies
            ex y being finite Subset of NAT st y in S1 & x = (y,1)-bag) &
    IT1 = choose (F1 " {support max(B1,InvLexOrder NAT)});
    assume
     ex S2 being non empty finite Subset of bool NAT,
     B2 being non empty finite Subset of Bags NAT,
     F2 being Function  st S2 = rng F2 &
     F2 = (V2G | (VG \ dom VLG)) &
   (for x being finite Subset of NAT holds x in S2 implies ((x,1)-bag in B2)) &
   (for x being set holds x in B2 implies
            ex y being finite Subset of NAT st y in S2 & x = (y,1)-bag) &
    IT2 = choose (F2 " {support max(B2,InvLexOrder NAT)});
    then consider S2 being non empty finite Subset of bool NAT,
             B2 being non empty finite Subset of Bags NAT,
             F2 being Function such that
A26: S2 = rng F2 & F2 = (V2G | (VG \ dom VLG)) &
   (for x being finite Subset of NAT holds x in S2 implies ((x,1)-bag in B2)) &
   (for x being set holds x in B2 implies
            ex y being finite Subset of NAT st y in S2 & x = (y,1)-bag) &
    IT2 = choose (F2 " {support max(B2,InvLexOrder NAT)});
     now let x be set such that A27: x in B1;
       ex y being finite Subset of NAT st y in S1 & x = (y,1)-bag by A25,A27;
     hence x in B2 by A25,A26;
    end;
then A28:  B1 c= B2 by TARSKI:def 3;
     now let x be set such that A29: x in B2;
       ex y being finite Subset of NAT st y in S2 & x = (y,1)-bag by A26,A29;
     hence x in B1 by A25,A26;
    end; then B2 c= B1 by TARSKI:def 3;
    hence IT1 = IT2 by A25,A26,A28,XBOOLE_0:def 10;
  end;
  consistency;
end;

definition let G be VVGraph, v be set, k be natural number;
 func LexBFS:LabelAdjacent(G, v, k) -> VVGraph equals
  G.set(V2LabelSelector, (the_V2Label_of G) .\/
                        ((G.AdjacentSet({v}) \ dom the_VLabel_of G)-->{k}));
  coherence proof
    set VLG = the_VLabel_of G;
    set f = (G.AdjacentSet({v}) \ dom VLG) --> {k};
    set H = G.set(V2LabelSelector, (the_V2Label_of G) .\/ f);
    set F = (the_V2Label_of G) .\/ f;
A1: dom the_V2Label_of G c= the_Vertices_of G by Th11;
 G.AdjacentSet({v}) \ dom VLG c= the_Vertices_of G;
then A2: dom f c= the_Vertices_of G by FUNCOP_1:19;
     dom F = dom the_V2Label_of G \/ dom f by Def2;
then A3: dom F c= the_Vertices_of G by A1,A2,XBOOLE_1:8;
     F is PartFunc of dom F, rng F by PARTFUN1:24;
    then reconsider g = F as PartFunc of the_Vertices_of G, rng F by A3,
PARTFUN1:28;
     G.set(V2LabelSelector, g) is [V2Labeled];
   hence thesis;
 end;
end;

theorem Th32:
for G being VVGraph, v,x being set, k being natural number
 st not x in G.AdjacentSet({v})
  holds (the_V2Label_of G).x = (the_V2Label_of LexBFS:LabelAdjacent(G,v,k)).x
proof let G be VVGraph, v,x be set, k be Nat such that
A1: not x in G.AdjacentSet({v});
    set GL = LexBFS:LabelAdjacent(G,v,k);     set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;                set V2G = the_V2Label_of G;
    set f = (G.AdjacentSet({v}) \ dom VLG) -->{k};
     dom f = G.AdjacentSet({v}) \ dom VLG by FUNCOP_1:19;
then A2: not x in dom f by A1,XBOOLE_0:def 4;
then A3: f.x = {} by FUNCT_1:def 4;
A4: V2 = V2G .\/ f by GLIB_000:11;
  per cases;
  suppose x in dom V2G;
    then x in dom V2G \/ dom f by XBOOLE_0:def 2;
    then V2.x = V2G.x \/ {} by A3,A4,Def2;
  hence V2.x = V2G.x; end;
  suppose A5: not x in dom V2G;
then A6: V2G.x = {} by FUNCT_1:def 4;
     not x in dom V2G \/ dom f by A2,A5,XBOOLE_0:def 2;
    then not x in dom V2 by A4,Def2;
  hence V2.x = V2G.x by A6,FUNCT_1:def 4; end;
end;

theorem Th33:
for G being VVGraph, v,x being set, k being natural number
 st x in dom (the_VLabel_of G) holds
   (the_V2Label_of G).x = (the_V2Label_of LexBFS:LabelAdjacent(G,v,k)).x
proof let G be VVGraph, v,x be set, k be Nat such that
A1: x in dom (the_VLabel_of G);
    set GL = LexBFS:LabelAdjacent(G,v,k);    set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;               set V2G = the_V2Label_of G;
    set f = (G.AdjacentSet({v}) \ dom VLG) -->{k};
     dom f = G.AdjacentSet({v}) \ dom VLG by FUNCOP_1:19;
then A2: not x in dom f by A1,XBOOLE_0:def 4;
then A3: f.x = {} by FUNCT_1:def 4;
A4: V2 = V2G .\/ f by GLIB_000:11;
  per cases;
  suppose x in dom V2G;
    then x in dom V2G \/ dom f by XBOOLE_0:def 2;
    then V2.x = V2G.x \/ {} by A3,A4,Def2;
  hence V2.x = V2G.x; end;
  suppose A5: not x in dom V2G;
then A6: V2G.x = {} by FUNCT_1:def 4;
     not x in dom V2G \/ dom f by A2,A5,XBOOLE_0:def 2;
    then not x in dom V2 by A4,Def2;
  hence V2.x = V2G.x by A6,FUNCT_1:def 4; end;
end;

theorem Th34:
for G being VVGraph, v,x being set, k being natural number
 st x in G.AdjacentSet({v}) & not x in dom (the_VLabel_of G)
  holds (the_V2Label_of LexBFS:LabelAdjacent(G,v,k)).x =
        (the_V2Label_of G).x \/ {k}
proof let G be VVGraph, v,x be set, k be Nat such that
A1: x in G.AdjacentSet({v}) and
A2: not x in dom (the_VLabel_of G);
    set GL = LexBFS:LabelAdjacent(G,v,k);    set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;    set V2G = the_V2Label_of G;
    set f = (G.AdjacentSet({v}) \ dom VLG) -->{k};
A3: dom f = G.AdjacentSet({v}) \ dom VLG by FUNCOP_1:19;
then A4: x in dom f by A1,A2,XBOOLE_0:def 4;
then A5: f.x = {k} by A3,FUNCOP_1:13;
A6: V2 = V2G .\/ f by GLIB_000:11;
     x in dom V2G \/ dom f by A4,XBOOLE_0:def 2;
  hence V2.x = V2G.x \/ {k} by A5,A6,Def2;
end;

theorem Th35:
for G being VVGraph, v being set, k being natural number
 st dom (the_V2Label_of G) = the_Vertices_of G
  holds dom (the_V2Label_of LexBFS:LabelAdjacent(G,v,k)) = the_Vertices_of G
proof let G be VVGraph, v be set, k be Nat such that
A1: dom (the_V2Label_of G) = the_Vertices_of G;
    set GL = LexBFS:LabelAdjacent(G,v,k);    set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;    set V2G = the_V2Label_of G;
    set f = (G.AdjacentSet({v}) \ dom VLG) -->{k};
 G.AdjacentSet({v}) \ dom VLG c= the_Vertices_of G;
then A2: dom f c= the_Vertices_of G by FUNCOP_1:19;
     V2 = V2G .\/ f by GLIB_000:11;
    then dom V2 = dom V2G \/ dom f by Def2;
  hence dom V2 = the_Vertices_of G by A1,A2,XBOOLE_1:12;
end;

definition let G be finite natural-vlabeled finite-v2labeled
                    natsubset-v2labeled VVGraph,
               v be Vertex of G, k be natural number;
  redefine func LexBFS:LabelAdjacent(G, v, k) ->
                    finite natural-vlabeled
                    finite-v2labeled natsubset-v2labeled VVGraph;
  coherence proof
    set IT = LexBFS:LabelAdjacent(G, v, k);
    set VL = the_VLabel_of IT;    set V2 = the_V2Label_of IT;
    set VLG = the_VLabel_of G;    set V2G = the_V2Label_of G;
A1: the_VLabel_of IT = the_VLabel_of G by GLIB_000:12;
     now let x be set such that A2: x in rng V2;
        consider y being set such that
         y in dom V2 and
    A3: V2.y = x by A2,FUNCT_1:def 5;
        per cases;
        suppose A4: not y in G.AdjacentSet({v}) or y in dom VLG;
         now per cases by A4;
            suppose not y in G.AdjacentSet({v});
              hence V2.y = V2G.y by Th32; end;
            suppose y in dom VLG;
              hence V2.y = V2G.y by Th33; end;
          end;
          hence x in bool NAT by A3;
        end;
        suppose y in G.AdjacentSet({v}) & not y in dom VLG;
       then A5: V2.y = V2G.y \/ {k} by Th34;
            k in NAT by ORDINAL1:def 13;
       then A6: {k} c= NAT by ZFMISC_1:37;
              V2.y c= NAT by A5,A6,XBOOLE_1:8;
            hence x in bool NAT by A3; 
        end;
    end;
then A7: rng V2 is Subset of bool NAT by TARSKI:def 3;
     now let x be set such that A8: x in rng V2;
        consider y being set such that
          y in dom V2 and
    A9: V2.y = x by A8,FUNCT_1:def 5;
        per cases;
        suppose A10: not y in G.AdjacentSet({v}) or y in dom VLG;
         now per cases by A10;
            suppose not y in G.AdjacentSet({v});
              hence V2.y = V2G.y by Th32; end;
            suppose y in dom VLG;
              hence V2.y = V2G.y by Th33; end;
          end;
          hence x is finite by A9;
        end;
        suppose y in G.AdjacentSet({v}) & not y in dom VLG;
          then V2.y = V2G.y \/ {k} by Th34;
          hence x is finite by A9;
       end;
    end;
    then V2 is finite-yielding &
         V2 is natsubset-yielding by A7,Def3,Lm2;
  hence IT is finite natural-vlabeled
              finite-v2labeled natsubset-v2labeled VVGraph
     by A1,Def7,Def12,Def13;
 end;
end;

definition let G be finite natural-vlabeled
                    finite-v2labeled natsubset-v2labeled VVGraph,
               v be Vertex of G, n be natural number;
   func LexBFS:Update(G, v, n) ->
             finite natural-vlabeled
             finite-v2labeled natsubset-v2labeled VVGraph equals
      LexBFS:LabelAdjacent(G.labelVertex(v, G.order()-'n), v, G.order()-'n);
   coherence proof set k = G.order()-'n;
      reconsider Gl = G.labelVertex(v, k) as
         finite natural-vlabeled
         finite-v2labeled natsubset-v2labeled VVGraph;
       Gl == G by GLIB_003:47;
      then reconsider vv = v as Vertex of Gl by GLIB_000:def 36;
       LexBFS:LabelAdjacent(Gl, vv, k) is
         finite natural-vlabeled finite-v2labeled natsubset-v2labeled VVGraph;
      hence thesis;
   end;
end;

definition let G be finite natural-vlabeled
                    finite-v2labeled natsubset-v2labeled VVGraph;
  func LexBFS:Step(G) ->
           finite natural-vlabeled
           finite-v2labeled natsubset-v2labeled VVGraph equals
  :Def32: G if G.order() <= card (dom the_VLabel_of G)
                otherwise LexBFS:Update(G,
                                        LexBFS:PickUnnumbered(G),
                                        card (dom the_VLabel_of G));
  coherence; consistency;
end;

definition let G be finite _Graph;
  func LexBFS:CSeq(G) ->
       finite natural-vlabeled
       finite-v2labeled natsubset-v2labeled VVGraphSeq means
:Def33: it.0 = LexBFS:Init(G) &
           for n being natural number holds it.(n+1) = LexBFS:Step(it.n);
  existence proof
     defpred P[set,set,set] means
      ($2 is finite natural-vlabeled
             finite-v2labeled natsubset-v2labeled VVGraph & $1 is Nat &
          ex nn being Nat,Gn,Gn1 being finite natural-vlabeled
                                      finite-v2labeled
                                      natsubset-v2labeled VVGraph st
          $1 = nn & $2 = Gn & $3 = Gn1 & Gn1 = LexBFS:Step(Gn)) or
      ((not $2 is finite natural-vlabeled
        finite-v2labeled natsubset-v2labeled VVGraph or
        not $1 is Nat) & $2 = $3);

     now let n,x be set;
         now per cases;
        suppose A1: x is finite natural-vlabeled
                         finite-v2labeled
                         natsubset-v2labeled VVGraph & n is Nat;
            then reconsider Gn=x as finite natural-vlabeled
                                    finite-v2labeled
                                    natsubset-v2labeled VVGraph;
            reconsider nn = n as Nat by A1;
            reconsider xx=x as finite natural-vlabeled
                         finite-v2labeled
                         natsubset-v2labeled VVGraph by A1;
            consider SGn being finite natural-vlabeled
                 finite-v2labeled
                 natsubset-v2labeled VVGraph such that
        A2: SGn = LexBFS:Step(Gn);
            thus ex y being set st P[n,x,y] by A1,A2; end;
        suppose not x is finite natural-vlabeled
                         finite-v2labeled
                         natsubset-v2labeled VVGraph or not n is Nat;
            hence ex y being set st P[n,x,y]; end;
        end;
        hence ex y being set st P[n,x,y];
    end;
then A3: for n being Element of NAT for x being set ex y being set st P[n,x,y];
A4: for n being Element of NAT for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2]
    holds y1 = y2;
    consider IT being Function such that
A5: dom IT = NAT &
    IT.0 = LexBFS:Init(G) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
      from RECDEF_1:sch 1(A3,A4);

    reconsider IT as ManySortedSet of NAT by A5,PBOOLE:def 3;
    defpred P2[Nat] means IT.$1 is finite natural-vlabeled
                                   finite-v2labeled
                                   natsubset-v2labeled VVGraph;
A6: P2[0] by A5;
A7: now let n be Nat;
A8: n in NAT by ORDINAL1:def 13;
      assume P2[n];
        then ex nn being Nat,
                 Gn,Gn1 being finite natural-vlabeled
                 finite-v2labeled
              natsubset-v2labeled VVGraph st
        n = nn & IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = LexBFS:Step(Gn) by A5,A8;
    hence P2[n+1];
    end;
A9: for n being Nat holds P2[n] from NAT_1:sch 2(A6,A7);
    then for n being Nat holds IT.n is _Graph;
    then reconsider IT as GraphSeq by GLIB_000:def 55;
     for n being Nat holds
      IT.n is [VLabeled] & IT.n is [V2Labeled] by A9;
    then reconsider IT as VVGraphSeq by Def20,GLIB_003:def 26;

     for n being Nat holds IT.n is finite natural-vlabeled
                 finite-v2labeled natsubset-v2labeled by A9;
    then reconsider IT as finite natural-vlabeled
               finite-v2labeled natsubset-v2labeled VVGraphSeq
           by Def17,Def22,Def23,GLIB_000:def 60;
    take IT;
    thus IT.0 = LexBFS:Init(G) by A5;
    let n be Nat;
 n in NAT by ORDINAL1:def 13;
    then consider nn being Nat,
             Gn,Gn1 being finite natural-vlabeled
             finite-v2labeled natsubset-v2labeled VVGraph such that
A10: n = nn & IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = LexBFS:Step(Gn)
         by A5;
    thus IT.(n+1) = LexBFS:Step(IT.n) by A10;
  end;

  uniqueness proof
    let IT1,IT2 be finite natural-vlabeled
                   finite-v2labeled natsubset-v2labeled
                   VVGraphSeq such that
A11: IT1.0 = LexBFS:Init(G) &
    for n being Nat holds IT1.(n+1) = LexBFS:Step(IT1.n) and
A12: IT2.0 = LexBFS:Init(G) &
    for n being Nat holds IT2.(n+1) = LexBFS:Step(IT2.n);
    defpred P[Nat] means IT1.$1 = IT2.$1;
A13: P[0] by A11,A12;
     now let n be Nat; assume P[n];
        then IT1.(n+1) = LexBFS:Step(IT2.n) by A11
                   .= IT2.(n+1) by A12;
        hence P[n+1];
    end;
then A14: for n being Element of NAT st P[n] holds P[n+1];
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A13,A14);
    then for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

theorem Th36:
for G being finite _Graph holds LexBFS:CSeq(G) is iterative
proof let G be finite _Graph;
  set CS = LexBFS:CSeq(G);
  let k,n be natural number such that A1: CS.k = CS.n;
   CS.(k+1) = LexBFS:Step(CS.k) by Def33;
  hence CS.(k+1) = CS.(n+1) by A1,Def33;
end;

registration let G be finite _Graph;
  cluster LexBFS:CSeq(G) -> iterative;
  coherence by Th36;
end;

theorem Th37: :: tLexBFSINIT01:
for G being _Graph holds the_VLabel_of LexBFS:Init(G) = {}
proof let G be _Graph;
    set G1 = G.set(VLabelSelector, {});
    set G2 = G1.set(V2LabelSelector, the_Vertices_of G --> {});
     the_VLabel_of G2 = the_VLabel_of G1 by GLIB_000:12;
  hence the_VLabel_of LexBFS:Init(G) = {} by GLIB_000:11;
end;

theorem Th38: :: tLexBFSINIT02:
for G being _Graph, v being set
  holds dom the_V2Label_of LexBFS:Init(G) = the_Vertices_of G &
        (the_V2Label_of LexBFS:Init(G)).v = {}
proof let G be _Graph, v be set;
    set G1 = G.set(VLabelSelector, {});
    set g  = the_Vertices_of G --> {};
A1: G1 == G by GLIB_003:8;
A2: dom g = the_Vertices_of G by FUNCOP_1:19;
    then dom g = the_Vertices_of G1 by A1,GLIB_000:def 36;
    then reconsider f = g as PartFunc of the_Vertices_of G1, rng g by
PARTFUN1:24;
    set G2 = G1.set(V2LabelSelector, f);
A3: now let x be set; per cases;
     suppose x in dom f; hence f.x = {} by A2,FUNCOP_1:13; end;
     suppose not x in dom f; hence f.x = {} by FUNCT_1:def 4; end;
    end;
A4: the_V2Label_of G2 = f by GLIB_000:11;
  thus dom the_V2Label_of LexBFS:Init(G) =the_Vertices_of G by A2,GLIB_000:11;
  thus (the_V2Label_of LexBFS:Init(G)).v = {} by A3,A4;
end;

theorem Th39: :: tLexBFSINIT03:
for G being _Graph holds G == LexBFS:Init(G)
proof let G be _Graph;
    set G1 = G.set(VLabelSelector, {});
    set G2 = G1.set(V2LabelSelector, the_Vertices_of G --> {});
A1: G == G1 by GLIB_003:8;
     G1 == G2 by Th12;
  hence thesis by A1,GLIB_000:88;
end;

:: the vertex picked has the largest v2label
theorem Th40: :: tLexBFSPick01:
for G being finite finite-v2labeled natsubset-v2labeled VVGraph, x being set
 st not x in dom the_VLabel_of G &
    dom the_V2Label_of G = the_Vertices_of G &
    dom the_VLabel_of G <> the_Vertices_of G
 holds ((the_V2Label_of G).x,1)-bag <=
       ((the_V2Label_of G).(LexBFS:PickUnnumbered(G)),1)-bag, InvLexOrder NAT
proof let G be finite finite-v2labeled natsubset-v2labeled VVGraph,
      x be set such that
A1: not x in dom the_VLabel_of G and
A2: dom the_V2Label_of G = the_Vertices_of G and
A3: dom the_VLabel_of G <> the_Vertices_of G;
    set w = LexBFS:PickUnnumbered(G);
    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
    set VG = the_Vertices_of G;
    consider S being non empty finite Subset of bool NAT,
             B being non empty finite Subset of Bags NAT,
             F being Function such that
A4: S = rng F and
A5: F = V2G | (VG \ dom VLG) and
A6: for x being finite Subset of NAT holds x in S implies (x,1)-bag in B and
A7: for x being set holds x in B implies
            ex y being finite Subset of NAT st y in S & x = (y,1)-bag and
A8: w = choose (F " {support max(B,InvLexOrder NAT)}) by A2,A3,Def29;
    set mw = max(B,InvLexOrder NAT);
     mw in B by Def5;
    then consider y being finite Subset of NAT such that
A9: y in S & mw = (y,1)-bag by A7;
A10: y = support mw by A9,UPROOTS:10;
then F " {support mw} is non empty by A4,A9,FUNCT_1:142;
then A11: w in dom F & F.w in {support mw} by A8,FUNCT_1:def 13;
then V2G.w = F.w by A5,FUNCT_1:70;
then A12: (V2G.w,1)-bag = mw by A9,A10,A11,TARSKI:def 1;
A13: dom F = dom V2G /\ (VG \ dom VLG) by A5,FUNCT_1:68;
  per cases;
  suppose x in the_Vertices_of G;
  then x in VG \ dom VLG by A1,XBOOLE_0:def 4;
  then A14: x in dom F by A2,A13,XBOOLE_0:def 3;
  then A15: F.x = V2G.x by A5,FUNCT_1:70;
       F.x in S by A4,A14,FUNCT_1:def 5;
      then (V2G.x,1)-bag in B by A6,A15;
    hence (V2G.x,1)-bag <= (V2G.w,1)-bag, InvLexOrder NAT by A12,Def5;end;
  suppose not x in the_Vertices_of G;
    then V2G.x = {} by A2,FUNCT_1:def 4;
    then (V2G.x,1)-bag = EmptyBag NAT by UPROOTS:11;
    hence (V2G.x,1)-bag <= (V2G.w,1)-bag, InvLexOrder NAT by TERMORD:9; end;
end;

:: the vertex picked is not currently in the vlabel
theorem Th41: :: tLexBFSPick02:
for G being finite finite-v2labeled natsubset-v2labeled VVGraph
 st dom the_V2Label_of G = the_Vertices_of G &
    dom the_VLabel_of G <> the_Vertices_of G
 holds not LexBFS:PickUnnumbered(G) in dom the_VLabel_of G
proof let G be finite finite-v2labeled natsubset-v2labeled VVGraph such that
A1: dom the_V2Label_of G = the_Vertices_of G and
A2: dom the_VLabel_of G <> the_Vertices_of G;
    set w = LexBFS:PickUnnumbered(G);
    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
    set VG = the_Vertices_of G;
    assume A3: w in dom VLG;
    consider S being non empty finite Subset of bool NAT,
             B being non empty finite Subset of Bags NAT,
             F being Function such that
A4: S = rng F and
A5: F = V2G | (VG \ dom VLG) and
     for x being finite Subset of NAT holds x in S implies (x,1)-bag in B and
A6: for x being set holds x in B implies
            ex y being finite Subset of NAT st y in S & x = (y,1)-bag and
A7: w = choose (F " {support max(B,InvLexOrder NAT)}) by A1,A2,Def29;
    set mw = max(B,InvLexOrder NAT);
     mw in B by Def5;
    then consider y being finite Subset of NAT such that
A8: y in S & mw = (y,1)-bag by A6;
 y = support mw by A8,UPROOTS:10;
then F " {support mw} is non empty by A4,A8,FUNCT_1:142;
then A9: w in dom F by A7,FUNCT_1:def 13;
A10: dom F = dom V2G /\ (VG \ dom VLG) by A5,FUNCT_1:68;
     not w in VG \ dom VLG by A3,XBOOLE_0:def 4;
  hence contradiction by A9,A10,XBOOLE_0:def 3;
end;

theorem Th42:
for G being finite _Graph, n being natural number
  holds (LexBFS:CSeq(G)).n == G
proof let G be finite _Graph, n be Nat;
    defpred P[Nat] means (LexBFS:CSeq(G)).$1 == G;
     (LexBFS:CSeq(G)).0 = LexBFS:Init(G) by Def33;
then A1: P[0] by Th39;
A2: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A3: P[k];
        set CSK = (LexBFS:CSeq(G)).k;
        set CK1 = (LexBFS:CSeq(G)).(k+1);
        set w   = LexBFS:PickUnnumbered(CSK);
        set kk  = G.order() -' card (dom the_VLabel_of CSK);
    A4: CSK.order() = G.order() by A3,GLIB_000:93;
    A5: CK1 = LexBFS:Step(CSK) by Def33;
      per cases;
      suppose card (dom the_VLabel_of CSK) < G.order();
    then A6: CK1 = LexBFS:Update(CSK, w, card (dom the_VLabel_of CSK))
                by A4,A5,Def32;
        set CC = CSK.labelVertex(w,kk);
    A7: CK1 == CC by A4,A6,Th12;
         CC == CSK by GLIB_003:47;
        then CK1 == CSK by A7,GLIB_000:88;
      hence P[k+1] by A3,GLIB_000:88; end;
      suppose G.order() <= card (dom the_VLabel_of CSK);
      hence P[k+1] by A3,A4,A5,Def32;  end;
    end;
     for k being Nat holds P[k] from NAT_1:sch 2(A1,A2);
  hence (LexBFS:CSeq(G)).n == G;
end;

:: show lexbfs has static vertices
theorem Th43:
for G being finite _Graph, m,n being natural number
  holds (LexBFS:CSeq(G)).m == (LexBFS:CSeq(G)).n
proof let G be finite _Graph, m,n be Nat;
A1: (LexBFS:CSeq(G)).m == G by Th42;
     (LexBFS:CSeq(G)).n == G by Th42;
  hence (LexBFS:CSeq(G)).m == (LexBFS:CSeq(G)).n by A1,GLIB_000:88;
end;

theorem Th44:
for G being finite _Graph, n being natural number
 st card (dom the_VLabel_of ((LexBFS:CSeq(G)).n)) < G.order()
holds
   the_VLabel_of ((LexBFS:CSeq(G)).(n+1)) =
   (the_VLabel_of ((LexBFS:CSeq(G)).n)) +*
   (LexBFS:PickUnnumbered((LexBFS:CSeq(G)).n) .-->
      (G.order()-'(card (dom the_VLabel_of ((LexBFS:CSeq(G)).n)))))
proof let G be finite _Graph, n be Nat such that
A1: card (dom the_VLabel_of (LexBFS:CSeq(G)).n) < G.order();
    set CSN = (LexBFS:CSeq(G)).n;     set VLN = the_VLabel_of CSN;
    set CN1 = (LexBFS:CSeq(G)).(n+1); set VN1 = the_VLabel_of CN1;
    set w   = LexBFS:PickUnnumbered(CSN);
    set k   = G.order() -' card (dom the_VLabel_of CSN);
     G == CSN by Th42;
then A2: CSN.order() = G.order() by GLIB_000:93;
     CN1 = LexBFS:Step(CSN) by Def33;
    then CN1 = LexBFS:Update(CSN, w, card (dom VLN)) by A1,A2,Def32;
    then VN1 = the_VLabel_of CSN.labelVertex(w, k) by A2,GLIB_000:12;
  hence thesis by GLIB_003:45;
end;

theorem Th45:
for G being finite _Graph, n being natural number
 holds dom (the_V2Label_of ((LexBFS:CSeq(G)).n)) =
            the_Vertices_of ((LexBFS:CSeq(G)).n)
proof let G be finite _Graph, n be Nat;
  set CSN = (LexBFS:CSeq(G)).n;
  set V2N = the_V2Label_of CSN;
  defpred P[Nat] means
     dom (the_V2Label_of ((LexBFS:CSeq(G)).$1)) =
        the_Vertices_of ((LexBFS:CSeq(G)).$1);
A1: (LexBFS:CSeq(G)).0 == G by Th42;
     (LexBFS:CSeq(G)).0 = LexBFS:Init(G) by Def33;
    then dom (the_V2Label_of ((LexBFS:CSeq(G)).0)) = the_Vertices_of G
        by Th38;
then A2: P[0] by A1,GLIB_000:def 36;
A3: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A4: P[k];
        set CSK = (LexBFS:CSeq(G)).k;
        set VLK = the_VLabel_of CSK;
        set V2K = the_V2Label_of CSK;
        set CK1 = (LexBFS:CSeq(G)).(k+1);
        set V21 = the_V2Label_of CK1;
        set w   = LexBFS:PickUnnumbered(CSK);
        set m   = G.order() -' (card (dom VLK));
    A5: CSK == CK1 by Th43;
         G == CSK by Th42;
    then A6: CSK.order() = G.order() by GLIB_000:93;
      per cases;
      suppose A7: card (dom VLK) < G.order();
         CK1 = LexBFS:Step(CSK) by Def33;
    then A8: CK1 = LexBFS:Update(CSK, w, card (dom VLK)) by A6,A7,Def32;
        set CSlv = CSK.labelVertex(w,m);
        set V2v  = the_V2Label_of CSlv;
    A9: CSlv == CSK by GLIB_003:47;
    then A10: CSlv == CK1 by A5,GLIB_000:88;
         dom V2v = the_Vertices_of CSK by A4,Th13;
        then dom V2v = the_Vertices_of CSlv by A9,GLIB_000:def 36;
        then dom V21 = the_Vertices_of CSlv by A6,A8,Th35;
      hence P[k+1] by A10,GLIB_000:def 36; end;
      suppose A11: G.order() <= card (dom VLK);
         CK1 = LexBFS:Step(CSK) by Def33;
        then CSK = CK1 by A6,A11,Def32;
      hence P[k+1] by A4; end;
    end;
     for k being Nat holds P[k] from NAT_1:sch 2(A2,A3);
  hence dom V2N = the_Vertices_of CSN;
end;

theorem Th46:
for G being finite _Graph, n being natural number st n <= G.order()
 holds card dom the_VLabel_of ((LexBFS:CSeq(G)).n) = n
proof let G be finite _Graph, n be Nat such that A1: n <= G.order();
 defpred P[Nat] means
  $1 <= G.order() implies card dom the_VLabel_of ((LexBFS:CSeq(G)).$1) = $1;
 A2: for k being Nat
     st k < G.order() & card dom the_VLabel_of ((LexBFS:CSeq(G)).k) = k
     holds  card dom the_VLabel_of ((LexBFS:CSeq(G)).(k+1)) = k+1
    proof let k be Nat such that
    A3: k < G.order() & card dom the_VLabel_of ((LexBFS:CSeq(G)).k) = k;
        set CSK = (LexBFS:CSeq(G)).k;        set VLK = the_VLabel_of CSK;
        set CK1 = (LexBFS:CSeq(G)).(k+1);    set VK1 = the_VLabel_of CK1;
         CSK == G by Th42;
    then A4: the_Vertices_of CSK = the_Vertices_of G by GLIB_000:def 36;
        set w = LexBFS:PickUnnumbered(CSK);
    A5: VK1 = VLK +* (w .--> (G.order()-'k)) by A3,Th44;
        set wf  = w .--> (G.order() -' k);
         dom wf = {w} & rng wf = {G.order() -' k} by FUNCOP_1:14,19;
    then A6: dom VK1 = dom VLK \/ {w} by A5,FUNCT_4:def 1;
         dom the_V2Label_of CSK = the_Vertices_of CSK by Th45;
        then not w in dom VLK by A3,A4,Th41;
      hence thesis by A3,A6,CARD_2:54;
    end;
     (LexBFS:CSeq(G)).0 = LexBFS:Init(G) by Def33;
then A7: P[0] by Th37,CARD_1:78,RELAT_1:60;
A8: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A9: P[k];
      per cases;
      suppose k < G.order();
        hence P[k+1] by A2,A9; end;
      suppose k >= G.order();
        hence P[k+1] by NAT_1:13; end;
      end;
     for k being Nat holds P[k] from NAT_1:sch 2(A7,A8);
 hence card dom the_VLabel_of ((LexBFS:CSeq(G)).n) = n by A1;
end;

theorem Th47:
for G being finite _Graph, n being natural number st G.order() <= n
  holds (LexBFS:CSeq(G)).(G.order()) = (LexBFS:CSeq(G)).n
proof let G be finite _Graph, n be natural number such that
A1: G.order() <= n;
    set CS = LexBFS:CSeq(G);
    defpred V[Nat] means
      G.order() = (card (dom the_VLabel_of CS.(G.order()+$1)));
A2: V[0] by Th46;
A3: for k being Nat st V[k] holds V[k+1] proof
      let k be Nat such that A4: V[k];
        set CSK = (LexBFS:CSeq(G)).(G.order()+k);
        set VLK = the_VLabel_of CSK;
        set CK1 = (LexBFS:CSeq(G)).(G.order()+k+1);
        set VL1 = the_VLabel_of CK1;
         G == CSK by Th42;
    then A5: card dom VLK = CSK.order() by A4,GLIB_000:93;
         CK1 = LexBFS:Step(CSK) by Def33;
      hence V[k+1] by A4,A5,Def32;
    end;
A6: for k being Nat holds V[k] from NAT_1:sch 2(A2,A3);
    defpred P[Nat] means
     (CS.(G.order())) = (CS.(G.order()+$1));
A7: P[0];
A8: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A9: P[k];
        set CSK = (LexBFS:CSeq(G)).(G.order()+k);
        set VLK = the_VLabel_of CSK;
        set CK1 = (LexBFS:CSeq(G)).(G.order()+k+1);
        set VL1 = the_VLabel_of CK1;
         G == CSK by Th42;
        then CSK.order() = G.order() by GLIB_000:93;
    then A10: card dom VLK = CSK.order() by A6;
         CK1 = LexBFS:Step(CSK) by Def33;
      hence P[k+1] by A9,A10,Def32;
    end;
A11: for k being Nat holds P[k] from NAT_1:sch 2(A7,A8);
     ex i being Nat st G.order() + i = n by A1,NAT_1:10;
  hence thesis by A11;
end;

theorem Th48:
for G being finite _Graph, m,n being natural number st G.order() <= m & m <= n
  holds (LexBFS:CSeq(G)).m = (LexBFS:CSeq(G)).n
proof let G be finite _Graph, m,n be Nat such that
A1: G.order() <= m & m <= n;
A2: G.order() <= n by A1,XXREAL_0:2;
     (LexBFS:CSeq(G)).m = (LexBFS:CSeq(G)).(G.order()) by A1,Th47;
  hence (LexBFS:CSeq(G)).m = (LexBFS:CSeq(G)).n by A2,Th47;
end;

theorem Th49:
for G being finite _Graph holds LexBFS:CSeq(G) is eventually-constant
proof let G be finite _Graph;
  take G.order();
  let m be Nat such that A1: G.order() <= m;
  thus (LexBFS:CSeq(G)).(G.order()) = (LexBFS:CSeq(G)).m by A1,Th47;
end;

registration let G be finite _Graph;
  cluster LexBFS:CSeq(G) -> eventually-constant;
  coherence by Th49;
end;

theorem Th50:
for G being finite _Graph, n being natural number holds
    dom the_VLabel_of((LexBFS:CSeq(G)).n) = the_Vertices_of((LexBFS:CSeq(G)).n)
iff G.order() <= n
proof let G be finite _Graph, n be Nat;
    set CSN = (LexBFS:CSeq(G)).n; set VLN = the_VLabel_of ((LexBFS:CSeq(G)).n);
    set CSO = (LexBFS:CSeq(G)).G.order(); set VLO = the_VLabel_of CSO;
A1: CSN == G by Th42;
then A2: the_Vertices_of CSN = the_Vertices_of G by GLIB_000:def 36;
A3: CSO == G by Th42;
then A4: the_Vertices_of CSO = the_Vertices_of G by GLIB_000:def 36;
    thus not dom VLN = the_Vertices_of CSN or not n < G.order()
       by A2,Th46;
  assume A5: G.order() <= n;
A6: dom VLO c= the_Vertices_of CSO by GLIB_003:7;
     card dom VLO = card the_Vertices_of CSO by A4,Th46;
then A7: dom VLO = the_Vertices_of CSO by A6,CARD_FIN:1;
A8: dom VLO = dom VLN by A5,Th48;
     CSN == CSO by A1,A3,GLIB_000:88;
  hence dom VLN = the_Vertices_of CSN by A7,A8,GLIB_000:def 36;
end;

theorem Th51:
for G being finite _Graph holds (LexBFS:CSeq(G)).Lifespan() = G.order()
proof
    let G be finite _Graph;
    set CS = LexBFS:CSeq(G);
     G.order() <= G.order()+1 by NAT_1:13;
then A1: CS.(G.order()) = CS.(G.order()+1) by Th47;
     for n being Nat st CS.n = CS.(n+1) holds G.order() <= n proof
        let n be Nat such that A2: CS.n = CS.(n+1);
        assume A3: n < G.order();
        set VLN = the_VLabel_of (CS.n);
        set VN1 = the_VLabel_of (CS.(n+1));
        set w   = LexBFS:PickUnnumbered(CS.n);
        set j = card (dom VLN);
    A4: dom the_V2Label_of (CS.n) = the_Vertices_of (CS.n) by Th45;
         dom VLN <> the_Vertices_of (CS.n) by A3,Th50;
    then A5: not w in dom VLN by A4,Th41;
     j < G.order() by A3,Th46;
    then A6: VN1 = VLN +* (w .--> (G.order() -' j)) by Th44;
        set wf  = w .--> (G.order() -' j);
         dom wf = {w} & rng wf = {G.order() -' j} by FUNCOP_1:14,19;
    then A7: dom VN1 = dom VLN \/ {w} by A6,FUNCT_4:def 1;
         w in {w} by TARSKI:def 1;
      hence contradiction by A2,A5,A7,XBOOLE_0:def 2;
    end;
  hence thesis by A1,GLIB_000:def 57;
end;

registration let G be finite chordal _Graph, i be natural number;
  cluster (LexBFS:CSeq(G)).i -> chordal VVGraph;
  coherence proof
       (LexBFS:CSeq(G)).i == G by Th42;
    hence (LexBFS:CSeq(G)).i is chordal VVGraph by CHORD:95;
  end;
end;

registration
  let G be finite chordal _Graph;
  cluster LexBFS:CSeq(G) -> chordal;
  correctness proof thus for x be Nat holds (LexBFS:CSeq(G)).x is chordal;
  end;
end;

theorem Th52:
for G being finite _Graph holds LexBFS:CSeq(G) is vlabel-numbering
proof let G be finite _Graph;
    set GS = LexBFS:CSeq(G);
     now let n,m be Nat;  (GS.n) == (GS.m) by Th43;
      hence (the_Vertices_of (GS.n)) =
            (the_Vertices_of (GS.m)) by GLIB_000:def 36;
    end;
then A1: GS is fixed-vertices by Def19;
     GS.0 = LexBFS:Init(G) by Def33;
    then the_VLabel_of (GS.0) = {} by Th37;
then A2: GS is vlabel-initially-empty by Def24;
A3: GS.Lifespan() = G.order() by Th51;
     now let n be Nat such that A4: n < GS.Lifespan();
    A5: n = card dom the_VLabel_of (GS.n) by A3,A4,Th46;
        set w = LexBFS:PickUnnumbered(GS.n);
    A6: dom the_V2Label_of (GS.n) = the_Vertices_of (GS.n) by Th45;
        dom the_VLabel_of (GS.n) <> the_Vertices_of (GS.n)
         by A3,A4,Th50;
    then A7: not w in dom (the_VLabel_of (GS.n)) by A6,Th41;
          the_VLabel_of (GS.(n+1)) =
        (the_VLabel_of (GS.n)) +* (w .--> (GS.Lifespan()-'n))
               by A3,A4,A5,Th44;
      hence (ex w being set st not w in dom (the_VLabel_of (GS.n)) &
         the_VLabel_of (GS.(n+1)) =
        (the_VLabel_of (GS.n)) +* (w .--> (GS.Lifespan()-'n))) by A7;
    end; then GS is adds-one-at-a-step by Def25;
  hence thesis by A1,A2,Def26;
end;

registration let G be finite _Graph;
  cluster LexBFS:CSeq(G) -> vlabel-numbering;
  coherence by Th52;
end;

theorem Th53:
for G being finite _Graph, n being natural number st n < G.order()
  holds (LexBFS:CSeq(G)).PickedAt(n) =
        LexBFS:PickUnnumbered((LexBFS:CSeq(G)).n)
proof let G be finite _Graph, n be Nat such that A1: n < G.order();
    set GS = LexBFS:CSeq(G);
    set CSN = GS.n;
    set CS1 = GS.(n+1);
    set PA = GS.PickedAt(n);
    set PU = LexBFS:PickUnnumbered(CSN);
    set VLN = the_VLabel_of CSN;
    set VL1 = the_VLabel_of CS1;
A2: GS.Lifespan() = G.order() by Th51;
then A3: not PA in dom VLN & VL1 = VLN +* (PA .--> (GS.Lifespan()-'n))
       by A1,Def27;
     n = card dom VLN by A1,Th46;
then A4: VL1 = VLN +* (PU .--> (GS.Lifespan()-'n)) by A1,A2,Th44;
    set f1 = PA .--> (GS.Lifespan()-'n);
    set f2 = PU .--> (GS.Lifespan()-'n);
 A5: dom f1 = {PA} & rng f1 = {GS.Lifespan()-'n} by FUNCOP_1:14,19;
 A6: dom f2 = {PU} & rng f2 = {GS.Lifespan()-'n} by FUNCOP_1:14,19;
 A7: dom VL1 = dom VLN \/ {PA} by A3,A5,FUNCT_4:def 1;
 A8: dom VL1 = dom VLN \/ {PU} by A4,A6,FUNCT_4:def 1;
     now assume PA <> PU;
        then not PA in {PU} by TARSKI:def 1;
    then A9: not PA in dom VL1 by A3,A8,XBOOLE_0:def 2;
         PA in {PA} by TARSKI:def 1;
      hence contradiction by A7,A9,XBOOLE_0:def 2;
    end;
  hence PA = PU;
end;

theorem Th54:
for G being finite _Graph, n being natural number st n < G.order()
 ex w being Vertex of (LexBFS:CSeq(G)).n
   st w = LexBFS:PickUnnumbered((LexBFS:CSeq(G)).n) &
   for v being set holds
    ((v in G.AdjacentSet({w}) &
      not v in dom (the_VLabel_of ((LexBFS:CSeq(G)).n))
       implies
        (the_V2Label_of ((LexBFS:CSeq(G)).(n+1))).v =
        (the_V2Label_of ((LexBFS:CSeq(G)).n)).v \/ {G.order() -' n}) &
    ((not v in G.AdjacentSet({w}) or
          v in dom (the_VLabel_of ((LexBFS:CSeq(G)).n)))
       implies
        (the_V2Label_of ((LexBFS:CSeq(G)).(n+1))).v =
        (the_V2Label_of ((LexBFS:CSeq(G)).n)).v))
proof let G be finite _Graph, n be Nat such that
A1: n < G.order();
    set CSN = (LexBFS:CSeq(G)).n;      set VLN = the_VLabel_of CSN;
    set V2N = the_V2Label_of CSN;    set CN1 = (LexBFS:CSeq(G)).(n+1);
    set VN1 = the_VLabel_of CN1;    set V21 = the_V2Label_of CN1;
    set w   = LexBFS:PickUnnumbered(CSN);
    set k   = G.order() -' n;
A2: card dom VLN = n by A1,Th46;
     G == CSN by Th42;
then A3: CSN.order() = G.order() by GLIB_000:93;
     CN1 = LexBFS:Step(CSN) by Def33;
then A4: CN1 = LexBFS:Update(CSN, w, n) by A1,A2,A3,Def32;

    set CSlv = CSN.labelVertex(w,k);    set VLv  = the_VLabel_of CSlv;
    set V2v  = the_V2Label_of CSlv;

A5: CSN == CSlv by GLIB_003:47;
     CSN == G by Th42;
then A6: CSlv == G by A5,GLIB_000:88;
A7: CSlv.labeledV() = CSN.labeledV() \/ {w} by GLIB_003:59;
A8: V2v = V2N by Th13;
A9: dom VLN c= dom VLv by A7,XBOOLE_1:7;
A10: now let v be set;
        assume A11: v in G.AdjacentSet({w}) & not v in dom VLN;
    then A12: v in CSlv.AdjacentSet({w}) by A6,CHORD:51;
         not v in {w} by A11,CHORD:49;
        then not v in dom VLv by A7,A11,XBOOLE_0:def 2;
      hence V21.v = V2N.v \/ {k} by A3,A4,A8,A12,Th34;
    end;
A13: now let v be set;
      assume A14: not v in G.AdjacentSet({w}) or v in dom VLN;
      per cases by A14;
      suppose not v in G.AdjacentSet({w});
        then not v in CSlv.AdjacentSet({w}) by A6,CHORD:51;
      hence V21.v = V2N.v by A3,A4,A8,Th32; end;
      suppose v in dom VLN;
      hence V21.v = V2N.v by A3,A4,A8,A9,Th33; end;
    end;
    take w;
  thus thesis by A10,A13;
end;

theorem Th55:
for G being finite _Graph, i being natural number, v being set holds
(the_V2Label_of ((LexBFS:CSeq(G)).i)).v c= (Seg G.order()) \ Seg (G.order()-'i)
proof let G be finite _Graph, i be Nat, v be set;
  set CSI = (LexBFS:CSeq(G)).i;   set V2I = the_V2Label_of CSI;
  set CSO = (LexBFS:CSeq(G)).(G.order());  set V2O = the_V2Label_of CSO;
  defpred P[Nat] means $1 <= G.order() implies
    (the_V2Label_of ((LexBFS:CSeq(G)).$1)).v c=
       (Seg G.order()) \ Seg (G.order() -' $1);
A1: P[0] proof
        set CS0 = (LexBFS:CSeq(G)).0; set V20 = the_V2Label_of CS0;
         CS0 = LexBFS:Init(G) by Def33;
        then V20.v = {} by Th38;
      hence P[0] by XBOOLE_1:2;
    end;
A2: for k being Nat st P[k] holds P[k+1] proof
      let k be Nat such that A3: P[k];
      set CSK = (LexBFS:CSeq(G)).k;      set V2K = the_V2Label_of CSK;
      set VLK = the_VLabel_of CSK;      set CK1 = (LexBFS:CSeq(G)).(k+1);
      set V21 = the_V2Label_of CK1;
      per cases;
      suppose k+1 <= G.order();
  then A4: k < G.order() by NAT_1:13;
          then consider w being Vertex of CSK such that
            w = LexBFS:PickUnnumbered(CSK) and
      A5: for v being set holds
            ((v in G.AdjacentSet({w}) & not v in dom VLK
                implies V21.v = V2K.v \/ {G.order() -' k}) &
             (not v in G.AdjacentSet({w}) or v in dom VLK
                implies V21.v = V2K.v)) by Th54;
          per cases;
          suppose v in G.AdjacentSet({w}) & not v in dom VLK;
        then A6: V21.v = V2K.v \/ {G.order() -' k} by A5;
             ((Seg G.order()) \ Seg (G.order() -' k)) \/ {G.order() -' k} =
            (Seg G.order()) \ Seg (G.order() -' (k+1)) by A4,Th7;
          hence P[k+1] by A3,A6,NAT_1:13,XBOOLE_1:9; end;
          suppose not v in G.AdjacentSet({w}) or v in dom VLK;
        then A7: V21.v = V2K.v by A5;
             k <= k+1 by NAT_1:13;
            then (Seg G.order()) \ Seg (G.order() -' k) c=
            (Seg G.order()) \ Seg (G.order() -' (k+1)) by Th6;
          hence P[k+1] by A3,A7,NAT_1:13,XBOOLE_1:1; end;
      end;
      suppose G.order() < k+1;
      hence P[k+1]; end;
    end;
A8: for k being Nat holds P[k] from NAT_1:sch 2(A1,A2);
  per cases;
  suppose i <= G.order();
    hence V2I.v c= (Seg G.order()) \ Seg (G.order() -' i) by A8; end;
  suppose A9: i > G.order();
    then G.order() - i < i - i by XREAL_1:11;
then G.order() -' i = 0 by BINARITH:def 3;
then A10: G.order() -' G.order() = G.order() -' i by BINARITH:51;
     V2O = V2I by A9,Th48;
  hence V2I.v c= (Seg G.order()) \ Seg (G.order() -' i) by A8,A10; end;
end;

:: LexBFS: Property L1
theorem Th56:
for G being finite _Graph, x being set, i,j being natural number st i <= j
 holds    (the_V2Label_of ((LexBFS:CSeq(G)).i)).x
       c= (the_V2Label_of ((LexBFS:CSeq(G)).j)).x
proof let G be finite _Graph, x be set, i,j be Nat such that
A1: i <= j;
  set CSI = (LexBFS:CSeq(G)).i;   set V2I = the_V2Label_of CSI;
  set CSJ = (LexBFS:CSeq(G)).j;   set V2J = the_V2Label_of CSJ;
  defpred P[Nat] means
    (the_V2Label_of ((LexBFS:CSeq(G)).i)).x c=
    (the_V2Label_of ((LexBFS:CSeq(G)).(i+$1))).x;
A2: P[0];
A3: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A4: P[k];
        set CSK = (LexBFS:CSeq(G)).(i+k);
        set V2K = the_V2Label_of CSK;
        set VLK = the_VLabel_of CSK;
        set CK1 = (LexBFS:CSeq(G)).(i+k+1);
        set V21 = the_V2Label_of CK1;
        per cases;
        suppose i+k+1 <= G.order();
          then i+k < G.order() by NAT_1:13;
          then consider w being Vertex of CSK such that
            w = LexBFS:PickUnnumbered(CSK) and
      A5: for v being set holds
            (v in G.AdjacentSet({w}) & not v in dom VLK
               implies V21.v = V2K.v \/ {G.order() -' (i+k)}) &
            (not v in G.AdjacentSet({w}) or v in dom VLK
               implies V21.v = V2K.v) by Th54;
          per cases;
          suppose x in G.AdjacentSet({w}) & not x in dom VLK;
            then V21.x = V2K.x \/ {G.order() -' (i+k)} by A5;
            then V2K.x c= V21.x by XBOOLE_1:7;
            hence P[k+1] by A4,XBOOLE_1:1;end;
          suppose not x in G.AdjacentSet({w}) or x in dom VLK;
          hence P[k+1] by A4,A5; end;
        end;
        suppose G.order() < i+k+1;
      then A6: G.order() <= i+k by NAT_1:13;
           i+k <= i+k+1 by NAT_1:13;
        hence P[k+1] by A4,A6,Th48; end;
    end;
A7: for k being Nat holds P[k] from NAT_1:sch 2(A2,A3);
     ex k being Nat st j = i+k by A1,NAT_1:10;
  hence V2I.x c= V2J.x by A7;
end;

theorem Th57:
for G being finite _Graph, m,n being natural number, x, y being set
 st n < G.order() & n < m & y = LexBFS:PickUnnumbered((LexBFS:CSeq(G)).n) &
    not x in dom (the_VLabel_of ((LexBFS:CSeq(G)).n)) & x in G.AdjacentSet({y})
  holds (G.order() -' n) in (the_V2Label_of ((LexBFS:CSeq(G)).m)).x
proof let G be finite _Graph;
    let m,n be Nat, x, y be set such that
A1: n < G.order() and
A2: n < m;
    set CSN = (LexBFS:CSeq(G)).n;    set VLN = the_VLabel_of CSN;
    set V2N = the_V2Label_of CSN;    set CSM = (LexBFS:CSeq(G)).m;
    set VLM = the_VLabel_of CSM;     set V2M = the_V2Label_of CSM;
    assume that
A3: y = LexBFS:PickUnnumbered(CSN) and
A4: not x in dom VLN and
A5: x in G.AdjacentSet({y});
    set CN1 = (LexBFS:CSeq(G)).(n+1);    set VN1 = the_VLabel_of CN1;
    set V21 = the_V2Label_of CN1;
    consider w being Vertex of CSN such that
A6: w = LexBFS:PickUnnumbered(CSN) and
A7: for v being set holds
    (v in G.AdjacentSet({w}) & not v in dom VLN
      implies V21.v = V2N.v \/ {G.order() -' n}) &
    (not v in G.AdjacentSet({w}) or v in dom VLN implies V21.v = V2N.v)
      by A1,Th54;
A8: V21.x = V2N.x \/ {G.order() -' n} by A3,A4,A5,A6,A7;
     G.order() -' n in {G.order() -' n} by TARSKI:def 1;
then A9: G.order() -' n in V21.x by A8,XBOOLE_0:def 2;
     n+1 <= m by A2,NAT_1:13;
    then V21.x c= V2M.x by Th56;
  hence G.order() -' n in V2M.x by A9;
end;

theorem Th58:
for G being finite _Graph, m,n being natural number st m < n
for x being set
 st not G.order()-'m in (the_V2Label_of ((LexBFS:CSeq(G)).(m+1))).x
  holds not G.order()-'m in (the_V2Label_of ((LexBFS:CSeq(G)).n)).x
proof let G be finite _Graph, m,n be Nat such that
A1: m < n;
    set CSM = (LexBFS:CSeq(G)).(m+1);    set V2M = the_V2Label_of CSM;
    set CSN = (LexBFS:CSeq(G)).n;        set V2N = the_V2Label_of CSN;
    let x be set such that
A2: not G.order() -' m in V2M.x;
  defpred P[Nat] means
    not G.order() -' m in (the_V2Label_of ((LexBFS:CSeq(G)).(m+1+$1))).x;
A3: P[0] by A2;
A4: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A5: P[k];
        set CSK = (LexBFS:CSeq(G)).(m+1+k);
        set VLK = the_VLabel_of CSK;
        set V2K = the_V2Label_of CSK;
        set CK1 = (LexBFS:CSeq(G)).(m+1+k+1);
        set V21 = the_V2Label_of CK1;
         now per cases;
          suppose A6: m+1+k < G.order();
            then consider w being Vertex of CSK such that
            w = LexBFS:PickUnnumbered(CSK) and
        A7: for v being set holds
            ((v in G.AdjacentSet({w}) & not v in dom VLK)
              implies V21.v = V2K.v  \/ {G.order() -' (m+1+k)}) &
            ((not v in G.AdjacentSet({w}) or v in dom VLK)
              implies V21.v = V2K.v) by Th54;
            per cases;
            suppose x in G.AdjacentSet({w}) & not x in dom VLK;
          then A8: V21.x = V2K.x \/ {G.order() -' (m+1+k)} by A7;
               m < m+1 & m+1 <= m+1+k by NAT_1:11,XREAL_1:41;
              then m < m+1+k by XXREAL_0:2;
              then G.order() -' m > G.order() -' (m+1+k) by A6,Th2;
              then not G.order() -' m in {G.order() -' (m+1+k)} by TARSKI:def 1
;
            hence not G.order() -' m in V21.x by A5,A8,XBOOLE_0:def 2; end;
            suppose not x in G.AdjacentSet({w}) or x in dom VLK;
            hence not G.order() -' m in V21.x by A5,A7; end;
          end;
          suppose A9: G.order() <= m+1+k;
             m+1+k <= m+1+k+1 by NAT_1:13;
            hence not G.order() -' m in V21.x by A5,A9,Th48; end;
          end;
      hence P[k+1];
    end;
A10: for k being Nat holds P[k] from NAT_1:sch 2(A3,A4);
     m+1 <= n by A1,NAT_1:13;
    then ex j being Nat st m+1+j = n by NAT_1:10;
  hence not G.order() -' m in V2N.x by A10;
end;

:: More general version of the above:
:: if the value added during step k doesn't appear in a later step (n),
:: then that value cannot appear in an even later step (m)
theorem Th59:
for G being finite _Graph, m,n,k being natural number st k < n & n <= m
for x being set
 st not G.order()-'k in (the_V2Label_of ((LexBFS:CSeq(G)).n)).x
  holds not G.order()-'k in (the_V2Label_of ((LexBFS:CSeq(G)).m)).x
proof let G be finite _Graph, m,n,k be Nat such that
A1: k < n and
A2: n <= m;
    set CSN = (LexBFS:CSeq(G)).n;
    set V2N = the_V2Label_of CSN;
    set CSM = (LexBFS:CSeq(G)).m;
    set V2M = the_V2Label_of CSM;
    let x be set such that
A3: not G.order() -' k in V2N.x;
    V2M.x c= (Seg G.order()) \ Seg (G.order() -' m) by Th55;
    set CSK = (LexBFS:CSeq(G)).k;
    set V2K = the_V2Label_of CSK;
    set CK1 = (LexBFS:CSeq(G)).(k+1);
    set V21 = the_V2Label_of CK1;
     k+1 <= n by A1,NAT_1:13;
    then V21.x c= V2N.x by Th56;
then A6: not G.order() -' k in V21.x by A3;
     k < m by A1,A2,XXREAL_0:2;
  hence not G.order() -' k in V2M.x by A6,Th58;
end;

:: relates a value in a vertex's v2label to the vertex chosen at that time
theorem Th60:
for G being finite _Graph, m,n being natural number
for x being Vertex of ((LexBFS:CSeq(G)).m)
  st n in (the_V2Label_of ((LexBFS:CSeq(G)).m)).x
    ex y being Vertex of ((LexBFS:CSeq(G)).m)
     st ((LexBFS:PickUnnumbered((LexBFS:CSeq(G)).(G.order()-'n))) = y &
        not y in dom (the_VLabel_of ((LexBFS:CSeq(G)).(G.order()-'n))) &
        x in G.AdjacentSet({y}))
proof let G be finite _Graph, m, n be Nat;
    set CSM = (LexBFS:CSeq(G)).m;
    set VLM = the_VLabel_of CSM;
    set V2M = the_V2Label_of CSM;
    set CSN = (LexBFS:CSeq(G)).(G.order() -' n);
    set VLN = the_VLabel_of CSN;
    set V2N = the_V2Label_of CSN;
    set on1 = G.order() -' n + 1;
    set CN1 = (LexBFS:CSeq(G)).on1;
    set V21 = the_V2Label_of CN1;

A1: dom V2N = the_Vertices_of CSN by Th45;

    let x be Vertex of CSM such that A2: n in V2M.x;
    assume
A3: not ex y being Vertex of CSM st
           LexBFS:PickUnnumbered(CSN) = y &
           not y in dom VLN & x in G.AdjacentSet({y});
     V2M.x c= (Seg G.order()) \ Seg (G.order() -' m) by Th55;
then A4: G.order() -' m < n & n <= G.order() by A2,Th5;
then A5: G.order() -' n = G.order() - n by BINARITH:50;
then A6:  G.order() -' n < G.order() by A4,XREAL_1:46;
then A7: G.order() -' (G.order() -' n) = G.order() - (G.order() - n)
      by A5,BINARITH:50;
 V2N.x c= (Seg G.order()) \ Seg (G.order() -' (G.order() -' n)) by Th55;
then A8: not n in V2N.x by A7,Th5;
    consider w being Vertex of CSN such that
A9: w = LexBFS:PickUnnumbered(CSN) and
A10: for v being set holds
    ((v in G.AdjacentSet({w}) & not v in dom VLN implies V21.v = V2N.v\/{n}) &
     (not v in G.AdjacentSet({w}) or v in dom VLN implies V21.v = V2N.v))
        by A6,A7,Th54;
     CSM == CSN by Th43;
    then reconsider wm = w as Vertex of CSM by GLIB_000:def 36;
     dom VLN <> the_Vertices_of CSN by A6,Th50;
    then not wm in dom VLN by A1,A9,Th41;
    then not x in G.AdjacentSet({w}) by A3,A9;
then A11: not n in V21.x by A8,A10;
A12: now per cases;
    suppose m <= G.order();
      then G.order() -' m = G.order() - m by BINARITH:50;
      then G.order() - m + m < n + m by A4,XREAL_1:8;
      then G.order() - n < m + n - n by XREAL_1:11;
      hence on1 <= m by A5,NAT_1:13; end;
    suppose G.order() < m;
      then G.order() -' n < m by A6,XXREAL_0:2;
      hence on1 <= m by NAT_1:13; end;
    end;
     G.order() -' n < on1 by XREAL_1:41;
  hence contradiction by A2,A7,A11,A12,Th59;
end;

definition let Gs be finite natural-vlabeled VVGraphSeq;
  redefine func Gs.Result() -> finite natural-vlabeled VVGraph;
  coherence proof
     Gs.(Gs.Lifespan()) is finite natural-vlabeled VVGraph;
  hence Gs.Result() is finite natural-vlabeled VVGraph;
  end;
end;

theorem Th61:
for G being finite _Graph holds
    ((LexBFS:CSeq(G)).Result()).labeledV() = the_Vertices_of G
proof let G be finite _Graph;
    set CS = LexBFS:CSeq(G);
    set CSO = CS.(G.order());
A1: CSO == G by Th42;
A2: CS.Result() = CSO by Th51;
     CSO.labeledV() = the_Vertices_of CSO by Th50;
  hence thesis by A1,A2,GLIB_000:def 36;
end;

theorem Th62: :: tLexBFS05:
for G being finite _Graph
 holds (the_VLabel_of (LexBFS:CSeq(G)).Result())" is VertexScheme of G
proof
    let G be finite _Graph;
    set CS = LexBFS:CSeq(G);    set CSO = CS.(G.order());
    set VLO = the_VLabel_of CSO;
A1: CSO == G by Th42;
A2: CSO = (LexBFS:CSeq(G)).Result() by Th51;
A3: VLO is one-to-one by Th25;
     dom VLO = the_Vertices_of CSO by Th50;
then A4: dom VLO = the_Vertices_of G by A1,GLIB_000:def 36;
     CS.Lifespan() = G.order() by Th51;
    then rng VLO = (Seg G.order()) \ Seg (G.order() -' G.order()) by Th21
           .= (Seg G.order()) \ Seg 0 by BINARITH:51
           .= Seg G.order() by FINSEQ_1:4;
then A5: rng (VLO") = the_Vertices_of G &
    dom (VLO") = Seg G.order() by A3,A4,FUNCT_1:55;
    then VLO" is FinSequence by FINSEQ_1:def 2;
then A6: VLO" is FinSequence of the_Vertices_of G by A5,FINSEQ_1:def 4;
     VLO" is one-to-one by A3,FUNCT_1:62;
  hence thesis by A2,A5,A6,CHORD:def 12;
end;

:: A vertex with a vlabel of k must have had the largest v2label when chosen
theorem Th63:
for G being finite _Graph, i,j being natural number,
    a,b being Vertex of (LexBFS:CSeq(G)).i
 st a in dom the_VLabel_of ((LexBFS:CSeq(G)).i) &
    b in dom the_VLabel_of ((LexBFS:CSeq(G)).i) &
    (the_VLabel_of ((LexBFS:CSeq(G)).i)).a <
                                      (the_VLabel_of ((LexBFS:CSeq(G)).i)).b &
    j = G.order() -' (the_VLabel_of ((LexBFS:CSeq(G)).i)).b
  holds ((the_V2Label_of ((LexBFS:CSeq(G)).j)).a,1)-bag <=
        ((the_V2Label_of ((LexBFS:CSeq(G)).j)).b,1)-bag, InvLexOrder NAT
proof
    let G be finite _Graph;
    let i,j be Nat, a,b be Vertex of (LexBFS:CSeq(G)).i such that
A1: a in dom the_VLabel_of ((LexBFS:CSeq(G)).i) and
A2: b in dom the_VLabel_of ((LexBFS:CSeq(G)).i) and
A3: (the_VLabel_of ((LexBFS:CSeq(G)).i)).a <
    (the_VLabel_of ((LexBFS:CSeq(G)).i)).b and
A4: j = G.order() -' (the_VLabel_of ((LexBFS:CSeq(G)).i)).b;
    set CSI = (LexBFS:CSeq(G)).i;    set CSJ = (LexBFS:CSeq(G)).j;
    set VLI = the_VLabel_of ((LexBFS:CSeq(G)).i);
    set VLJ = the_VLabel_of ((LexBFS:CSeq(G)).j);
    set V2I = the_V2Label_of ((LexBFS:CSeq(G)).i);
    set V2J = the_V2Label_of ((LexBFS:CSeq(G)).j);
A5: a in CSI.labeledV() by A1;
A6: b in CSI.labeledV() by A2;
A7: G.order() = (LexBFS:CSeq(G)).Lifespan() by Th51;
    then VLI.b <= G.order() by Th22;
then A8: G.order() -' VLI.b = G.order() - VLI.b by BINARITH:50;
then A9: j < G.order() by A3,A4,XREAL_1:46;
     G.order() -' VLI.b <= G.order() by BINARITH:52;
then A10:G.order() -' j = G.order() - (G.order() - VLI.b) by A4,A8,BINARITH:50;
     (LexBFS:CSeq(G)).PickedAt(j) = b by A4,A6,A7,Th27;
then A11: LexBFS:PickUnnumbered(CSJ) = b by A9,Th53;
A12: dom V2J = the_Vertices_of CSJ by Th45;
     CSI == CSJ & a in the_Vertices_of CSI by Th43;
then A13: a in the_Vertices_of CSJ by GLIB_000:def 36;
     now assume a in dom VLJ;
    then A14: a in CSJ.labeledV();
        then VLI.b < VLJ.a by A7,A10,Th29;
      hence contradiction by A3,A5,A14,Th26;
    end;
  hence (V2J.a,1)-bag <= (V2J.b,1)-bag, InvLexOrder NAT
       by A11,A12,A13,Th40;
end;

:: Any value in our v2label corresponds to a vertex that we are
:: adjacent to in our in our vlabel
theorem Th64:
for G being finite _Graph, i,j being natural number,
    v being Vertex of (LexBFS:CSeq(G)).i
 st j in (the_V2Label_of ((LexBFS:CSeq(G)).i)).v
  ex w being Vertex of (LexBFS:CSeq(G)).i st
     w in dom the_VLabel_of ((LexBFS:CSeq(G)).i) &
     (the_VLabel_of ((LexBFS:CSeq(G)).i)).w = j & v in G.AdjacentSet{w}
proof let G be finite _Graph, i,j be Nat;
    let v be Vertex of (LexBFS:CSeq(G)).i;
    set CSI = (LexBFS:CSeq(G)).i;    set VLI = the_VLabel_of CSI;
    set V2I = the_V2Label_of CSI;       set n = G.order() -' j;
    set CSN = (LexBFS:CSeq(G)).n;    set VLN = the_VLabel_of CSN;
    assume A1: j in V2I.v;
    then consider w being Vertex of CSI such that
A2: LexBFS:PickUnnumbered(CSN) = w and
     not w in dom VLN and
A3: v in G.AdjacentSet({w}) by Th60;
     V2I.v c= Seg G.order() \ Seg (G.order() -' i) by Th55;
then A4: G.order() -' i < j & j <= G.order() by A1,Th5;
    then G.order() -' j = G.order() - j by BINARITH:50;
then A5: n < G.order() by A4,XREAL_1:46;
then A6: G.order() -' n = G.order() - n by BINARITH:50;
A7: G.order() - n = G.order() - (G.order() - j) by A4,BINARITH:50;
A8: G.order() = (LexBFS:CSeq(G)).Lifespan() by Th51;
A9: w = (LexBFS:CSeq(G)).PickedAt(n) by A2,A5,Th53;
     now 
       G.order() - i < G.order() - n by A4,A7,BINARITH:def 3;
      then G.order() - i + i < G.order() - n + i by XREAL_1:8;
      then G.order() + n < G.order() + i - n + n by XREAL_1:8;
      then n + G.order() - G.order() < i + G.order() - G.order() by XREAL_1:11
;
      hence n < i;
    end;
    then w in CSI.labeledV() & VLI.w = G.order()-'n by A5,A8,A9,Th28;
    hence ex w being Vertex of CSI st w in dom VLI & VLI.w = j &
         v in G.AdjacentSet({w}) by A3,A6,A7;
end;

definition let G be natural-vlabeled VGraph;
  attr G is with_property_L3 means                               :Def34:
for a,b,c being Vertex of G st a in dom the_VLabel_of G &
    b in dom the_VLabel_of G & c in dom the_VLabel_of G &
    (the_VLabel_of G).a < (the_VLabel_of G).b &
    (the_VLabel_of G).b < (the_VLabel_of G).c &
    a,c are_adjacent & not b,c are_adjacent
  ex d being Vertex of G st d in dom the_VLabel_of G &
     (the_VLabel_of G).c < (the_VLabel_of G).d &
     b,d are_adjacent & not a,d are_adjacent &
     for e being Vertex of G
       st e <> d & e,b are_adjacent & not e,a are_adjacent
        holds (the_VLabel_of G).e < (the_VLabel_of G).d;
end;

theorem Th65:
for G being finite _Graph, n being natural number
  holds (LexBFS:CSeq(G)).n is with_property_L3
proof let G be finite _Graph, i be Nat;
    set CSi = (LexBFS:CSeq(G)).i;  set VLi = the_VLabel_of CSi;
     now let a, b, c be Vertex of CSi such that
A1: a in dom VLi & b in dom VLi & c in dom VLi &
    VLi.a < VLi.b & VLi.b < VLi.c &
    a,c are_adjacent & not b,c are_adjacent;
A2: CSi == G by Th42;
A3: (LexBFS:CSeq(G)).Lifespan() = G.order() by Th51;
A4: CSi.labeledV() <> {} by A1;

A5: VLi.a < VLi.c by A1,XXREAL_0:2;
    reconsider ag = a, bg = b, cg = c as Vertex of G by A2,GLIB_000:def 36;
     now assume
    A6: for d being Vertex of CSi st d in dom VLi & VLi.c < VLi.d &
            d,b are_adjacent holds d,a are_adjacent;
        reconsider ai = a, bi = b, ci = c as Vertex of CSi;
        set k = G.order() -' VLi.bi;    set CSb = (LexBFS:CSeq(G)).k;
        set VLb = the_VLabel_of CSb;
   A7: CSb == G by Th42;
   then A8: CSb == CSi by A2,GLIB_000:88;
        then reconsider ab = a, bb = b as Vertex of CSb by GLIB_000:def 36;
        reconsider cb = c as Vertex of CSb by A8,GLIB_000:def 36;
        reconsider sbb = (the_V2Label_of CSb).bb, sba = (the_V2Label_of CSb).ab
            as finite Subset of NAT;
   A9: (Seg G.order()) \ Seg (G.order() -' k) c= Seg G.order() by XBOOLE_1:36;
         sbb c= (Seg G.order()) \ Seg (G.order() -' k) by Th55;
    then A10: sbb c= Seg G.order() by A9,XBOOLE_1:1;
         sba c= (Seg G.order()) \ Seg (G.order() -' k) by Th55;
    then A11: sba c= Seg G.order() by A9,XBOOLE_1:1;
    A12: not bb,cb are_adjacent & ab,cb are_adjacent by A1,A8,CHORD:44;
         then not b in CSb.AdjacentSet({cb}) by CHORD:52;
  then A13: not b in G.AdjacentSet({cg}) by A7,CHORD:51;
          a in CSb.AdjacentSet({cb}) by A1,A12,CHORD:52;
  then A14: a in G.AdjacentSet({cg}) by A7,CHORD:51;
  A15: c in CSi.labeledV()&b in CSi.labeledV() & VLi.bi < VLi.ci by A1;
   then A16: cb in CSb.labeledV() by A3,Th30;
        set kc = G.order() -' VLi.c;
        set CSc = (LexBFS:CSeq(G)).kc;
        set VLc = the_VLabel_of CSc;
   A17: 1 <= VLi.c & VLi.c <= G.order() by A3,A15,Th22;
   then A18: G.order() -' VLi.c = G.order() - VLi.c by BINARITH:50;
   then A19: kc < G.order() by A1,XREAL_1:46;
   A20: kc < k by A1,A17,Th2;
         ci in CSi.labeledV() by A1;
        then (LexBFS:CSeq(G)).PickedAt(kc) = cb by A3,Th27;
   then A21: cb = LexBFS:PickUnnumbered(CSc) by A19,Th53;
   A22: G.order() -' kc = G.order() - (G.order() - VLi.c)
             by A18,A19,BINARITH:50;
         now assume A23: a in dom VLc;
        then A24: VLc.a in rng VLc by FUNCT_1:def 5;
             rng VLc=(Seg G.order()) \ Seg (G.order()-'kc) by A3,Th21;
        then A25: VLi.c < VLc.a by A22,A24,Th5;
             a in CSc.labeledV() & a in CSi.labeledV() & VLi.a < VLi.c
                  by A1,A23,XXREAL_0:2;
          hence contradiction by A25,Th26;
        end;
        then VLi.c in sba by A14,A19,A20,A21,A22,Th57;
    then A26: VLb.cb in sba by A15,A16,Th26;
    A27: now assume VLb.cb in sbb;
            then consider z being Vertex of CSb such that
        A28: z in dom VLb and
        A29: VLb.z = VLb.cb and
        A30: bb in G.AdjacentSet({z}) by Th64;
             VLb is one-to-one by Th25;
          hence contradiction by A13,A16,A28,A29,A30,FUNCT_1:def 8;
        end;
    then A31: (sbb,1)-bag <> (sba,1)-bag by A26,Th8;
    A32: (sba,1)-bag <= (sbb,1)-bag, InvLexOrder NAT by A1,Th63;

        set j = (the_VLabel_of CSb).cb;
     (sbb,1)-bag.j = 0 by A27,UPROOTS:8;
    then A33: (sbb,1)-bag.j < (sba,1)-bag.j by A26,UPROOTS:9;
         [(sbb,1)-bag,(sba,1)-bag] in InvLexOrder NAT proof
        per cases;
        suppose for k being Ordinal st j in k & k in NAT
                  holds (sbb,1)-bag.k = (sba,1)-bag.k;
       hence [(sbb,1)-bag,(sba,1)-bag] in InvLexOrder NAT by A33,BAGORDER:def 8
;
        end;
        suppose not for k being Ordinal st j in k & k in NAT
                  holds (sbb,1)-bag.k = (sba,1)-bag.k;
            then consider qq being Ordinal such that
        A34: j in qq & qq in NAT and
        A35: (sbb,1)-bag.qq <> (sba,1)-bag.qq;

            defpred M[Nat] means
                j in $1 & (sbb,1)-bag.$1 <> (sba,1)-bag.$1;

            reconsider q = qq as Element of NAT by A34;
            ex k being Element of NAT st M[k] by A34,A35;
            then
        A36: ex k being Nat st M[k];
        A37: for k being Nat st M[k] holds k <= G.order() proof
                let k be Nat such that A38: M[k];
                k in NAT by ORDINAL1:def 13;
                then consider ok being Ordinal such that
            A39: ok = k and
                 j in ok & ok in NAT and
            A40: (sbb,1)-bag.ok <> (sba,1)-bag.ok by A38;
                 k in sba or not k in sba;
            then A41:(sba,1)-bag.k = 1 or (sba,1)-bag.k = 0 by UPROOTS:8,9;
               per cases;
               suppose not ok in sbb;
                 then ok in sba by A39,A40,A41,UPROOTS:8;
                 hence k <= G.order() by A11,A39,FINSEQ_1:3; end;
               suppose ok in sbb;
                 hence k <= G.order() by A10,A39,FINSEQ_1:3; end;
            end;
            consider mm being Nat such that
       A42: M[mm] and
       A43: for i being Nat st M[i] holds i <= mm
                  from NAT_1:sch 6(A37,A36);
            reconsider mm as Element of NAT by ORDINAL1:def 13;
             j in {y where y is Element of NAT : y < mm} by A42,AXIOMS:30;
            then consider jy being Element of NAT such that
       A44: jy = j & jy < mm;
             mm in sbb or not mm in sbb;
       then A45: (sbb,1)-bag.mm = 0 or (sbb,1)-bag.mm = 1 by UPROOTS:8,9;

         now assume A46: (sbb,1)-bag.mm = 1;
                then mm in sbb by UPROOTS:8;
                then consider z being Vertex of CSb such that
            A47: z in dom (the_VLabel_of CSb) and
            A48: (the_VLabel_of CSb).z = mm and
            A49: b in G.AdjacentSet({z}) by Th64;
                 k < i by A3,A15,Th29;
            then A50: the_VLabel_of CSb c= the_VLabel_of CSi by Th24;
            then A51:  dom (the_VLabel_of CSb) c= dom the_VLabel_of CSi
                   by RELAT_1:25;
                then z in dom the_VLabel_of CSi by A47;
                then reconsider zi = z as Vertex of CSi by A4;
           A52: [z,mm] in the_VLabel_of CSb by A47,A48,FUNCT_1:def 4;
           then A53: VLi.z = mm by A47,A50,A51,FUNCT_1:def 4;
           A54: [cb,j] in the_VLabel_of CSb by A16,FUNCT_1:def 4;
           then A55: VLi.cb = j by A1,A50,FUNCT_1:def 4;
            A56: VLi.c < VLi.zi by A1,A44,A50,A53,A54,FUNCT_1:def 4;
                reconsider zg = z as Vertex of G by A7,GLIB_000:def 36;
                 bb in CSb.AdjacentSet({z}) by A7,A49,CHORD:51;
                then bb,z are_adjacent by CHORD:52;
                then zi,bi are_adjacent by A8,CHORD:44;
                then zi,ai are_adjacent by A6,A44,A47,A51,A53,A55;
           then z,ab are_adjacent by A8,CHORD:44;
                then a in CSb.AdjacentSet({zg}) by A5,A56,CHORD:52;
           then A57: a in G.AdjacentSet({zg}) by A7,CHORD:51;
                set kc = G.order() -' VLi.z;
                set CSc = (LexBFS:CSeq(G)).kc;
                set VLc = the_VLabel_of CSc;
           A58: VLi.c < VLi.z by A44,A47,A50,A51,A52,A55,FUNCT_1:def 4;
           A59: VLi.b < VLi.z by A1,A44,A53,A55,XXREAL_0:2;
           A60: z in CSi.labeledV() by A47,A51;
           then A61: 1 <= VLi.z & VLi.z <= G.order() by A3,Th22;
          A62: 0 < VLi.z by A60,Th22;
           A63: G.order() -' VLi.z = G.order() - VLi.z
                    by A61,BINARITH:50;
           then A64: kc < G.order() by A62,XREAL_1:46;
           A65: kc < k by A59,A61,Th2;
                 z = (LexBFS:CSeq(G)).PickedAt(kc) by A3,A60,Th27;
           then A66: z = LexBFS:PickUnnumbered(CSc) by A64,Th53;
           A67: G.order() -' kc = G.order() - (G.order() - VLi.z)
                    by A63,A64,BINARITH:50;
                 now assume A68: a in dom VLc;
                then A69: VLc.a in rng VLc by FUNCT_1:def 5;
                     rng VLc=(Seg G.order())\ Seg (G.order()-'kc)
                          by A3,Th21;
                then A70: VLi.z < VLc.a by A67,A69,Th5;
                     a in dom VLi & VLi.a < VLi.c by A1,XXREAL_0:2;
                then A71: VLi.a < VLi.z by A58,XXREAL_0:2;
                     a in CSc.labeledV() & a in CSi.labeledV() by A1,A68;
                  hence contradiction by A70,A71,Th26;
                end;
                then G.order() -' kc in sba by A57,A64,A65,A66,Th57;
              hence contradiction by A42,A46,A53,A67,UPROOTS:9;
            end;
        then A72: (sbb,1)-bag.mm < (sba,1)-bag.mm by A42,A45;
             now let k be Ordinal such that
            A73: mm in k & k in NAT;
                reconsider kk = k as Element of NAT by A73;
                assume A74: (sbb,1)-bag.k <> (sba,1)-bag.k;
            A75: j in k by A42,A73,ORDINAL1:19;
                 mm in {y where y is Element of NAT : y < kk}
                   by A73,AXIOMS:30;
                then consider mmy being Element of NAT such that
            A76: mmy = mm & mmy < kk;
              thus contradiction by A43,A74,A75,A76;
            end;
            hence [(sbb,1)-bag,(sba,1)-bag] in InvLexOrder NAT
               by A72,BAGORDER:def 8; end;
        end;
        then (sbb,1)-bag <= (sba,1)-bag, InvLexOrder NAT by TERMORD:def 2;
    then (sbb,1)-bag < (sba,1)-bag, InvLexOrder NAT by A31,TERMORD:def 3;
      hence contradiction by A32,TERMORD:5;
    end;
    then consider x being Vertex of CSi such that
A77: x in dom VLi & VLi.c < VLi.x & x,b are_adjacent & not x,a are_adjacent;

    defpred P[Nat] means
     ex v being Vertex of CSi st v in dom VLi &
        b,v are_adjacent & not a,v are_adjacent &
        VLi.c < VLi.v & VLi.v = $1;

A78: ex k being Nat st P[k] by A77;
A79: for k being Nat st P[k] holds k <= G.order() proof
        let k be Nat such that A80: P[k];
        consider v being Vertex of CSi such that
    A81: v in dom VLi & v,b are_adjacent & not v,a are_adjacent and
    A82: VLi.c < VLi.v & VLi.v = k by A80;
         k in rng the_VLabel_of CSi by A81,A82,FUNCT_1:def 5;
    then A83: k in (Seg G.order()) \ Seg (G.order()-'i) by A3,Th21;
         (Seg G.order()) \ Seg (G.order()-'i) c= Seg G.order() by XBOOLE_1:36;
      hence k <= G.order() by A83,FINSEQ_1:3;
    end;
     ex k being Nat st P[k] &
       for n being Nat st P[n] holds n <= k
       from NAT_1:sch 6(A79,A78);
    then consider k being Nat such that
A84: P[k] and
A85: for n being Nat st P[n] holds n <= k;
    consider v being Vertex of CSi such that
A86: v in dom VLi & b,v are_adjacent & not a,v are_adjacent and
A87: VLi.c < VLi.v and
A88: VLi.v = k by A84;

     for d being Vertex of CSi
       st d <> v & d,b are_adjacent & not d,a are_adjacent
        holds  VLi.d < VLi.v
    proof let d be Vertex of CSi such that
    A89: d <> v & d,b are_adjacent & not d,a are_adjacent;
      per cases;
      suppose VLi.d <= VLi.c;
        hence VLi.d < VLi.v by A87,XXREAL_0:2; end;
      suppose A90: VLi.c < VLi.d;
   A91: d in dom VLi by FUNCT_1:def 4,A90;
    then A92: VLi.d <= k by A85,A89,A90;
         VLi is one-to-one by Th25;
        then VLi.d <> VLi.v by A86,A89,A91,FUNCT_1:def 8;
      hence VLi.d < VLi.v by A88,A92,REAL_1:def 5; end;
    end;
    hence ex d being Vertex of CSi st
    d in dom VLi & VLi.c < VLi.d & b,d are_adjacent & not a,d are_adjacent &
     for e being Vertex of CSi
       st e <> d & e,b are_adjacent & not e,a are_adjacent
        holds VLi.e < VLi.d by A86,A87;
    end;
  hence thesis by Def34;
end;

theorem Th66: :: Theorem 4.3, Golumbic p. 86
for G being finite chordal natural-vlabeled VGraph
  st G is with_property_L3 & dom the_VLabel_of G = the_Vertices_of G
   for V being VertexScheme of G st V" = the_VLabel_of G holds V is perfect
proof let G be finite chordal natural-vlabeled VGraph such that
A1: G is with_property_L3 and
A2: dom the_VLabel_of G = the_Vertices_of G;
     let V be VertexScheme of G such that
A3: V" = the_VLabel_of G;
     assume not V is perfect;
     then consider k being non empty Nat such that
 A4: k <= len V and
 A5: not for H being inducedSubgraph of G, V.followSet(k)
   for v being Vertex of H st v = V.k holds v is simplicial by CHORD:def 13;
    consider HH being (inducedSubgraph of G,V.followSet(k)),
              hv being Vertex of HH such that
 A6: hv = V.k and
 A7: not hv is simplicial by A5;
A8: 0+1 <= k by NAT_1:13;

     set VLG = the_VLabel_of G;
A9: V is one-to-one by CHORD:def 12;
then A10: VLG is one-to-one by A3,FUNCT_1:62;
A11:  rng V = the_Vertices_of G by CHORD:def 12;
     consider ha,hb being Vertex of HH such that
 A12: ha<>hb & hv<>ha & hv<>hb and
 A13: hv,ha are_adjacent and
 A14: hv,hb are_adjacent and
 A15: not ha,hb are_adjacent by A7,CHORD:69;

A16: V.followSet(k) is non empty Subset of the_Vertices_of G
        by A4,CHORD:107;
then A17: the_Vertices_of HH = V.followSet(k) by GLIB_000:def 39;
      hv in the_Vertices_of HH & ha in the_Vertices_of HH &
     hb in the_Vertices_of HH;
     then reconsider v=hv,aa=ha,bb=hb as Vertex of G;
A18:
    for x,y being Vertex of G, i,j being Nat st i in dom V & j in dom V &
        V/.i = x & V/.j = y holds i < j iff VLG.x < VLG.y
    proof let x,y being Vertex of G;
        let i,j be Nat such that A19: i in dom V & j in dom V and
    A20: V/.i = x & V/.j = y;
    A21: V.i = x & V.j = y by A19,A20,PARTFUN1:def 8;
    then A22: VLG.y = j by A3,A9,A19,FUNCT_1:56;
        hence i<j implies VLG.x < VLG.y by A3,A9,A19,A21,FUNCT_1:56;
        thus VLG.x < VLG.y implies i < j by A3,A9,A19,A21,A22,FUNCT_1:56;
    end;

     now A23: VLG.aa <> VLG.bb by A2,A10,A12,FUNCT_1:def 8;
      per cases by A23,REAL_1:def 5;
       suppose A24: VLG.aa < VLG.bb;
         take aa, bb;
         thus aa in V.followSet(k) by A17;
         thus VLG.aa < VLG.bb by A24;
         thus v,aa are_adjacent by A13,A16,CHORD:45;
         thus v,bb are_adjacent by A14,A16,CHORD:45;
         thus not aa,bb are_adjacent by A15,A16,CHORD:45;
       end;
       suppose A25: VLG.aa > VLG.bb;
         take bb, aa;
         thus bb in V.followSet(k) by A17;
         thus VLG.aa > VLG.bb by A25;
         thus v,bb are_adjacent by A14,A16,CHORD:45;
         thus v,aa are_adjacent by A13,A16,CHORD:45;
         thus not bb,aa are_adjacent by A15,A16,CHORD:45;
       end;
     end;
     then consider a,bb being Vertex of G such that
  A26: a in V.followSet(k) and
  A27: VLG.a < VLG.bb and
  A28: v,a are_adjacent and
  A29: v,bb are_adjacent and
  A30: not a,bb are_adjacent;

     defpred Q[Nat] means  $1 in dom V & VLG.a < VLG.(V/.$1) &
     a <> V/.$1 & v,V/.$1 are_adjacent & not a,V/.$1 are_adjacent;
 A31: for k being Nat st Q[k] holds k <= len V by FINSEQ_3:27;
 A32: ex k being Nat st Q[k] proof
        consider mbb being set such that
   A33: mbb in dom V & bb = V.mbb by A11,FUNCT_1:def 5;
        reconsider mbb as Element of NAT by A33;
        take mbb;
        thus mbb in dom V by A33;
        thus VLG.a < VLG.(V/.mbb) by A27,A33,PARTFUN1:def 8;
        thus a <> V/.mbb by A27,A33,PARTFUN1:def 8;
        thus v,V/.mbb are_adjacent by A29,A33,PARTFUN1:def 8;
        thus not a,V/.mbb are_adjacent by A30,A33,PARTFUN1:def 8;
     end;
     consider mb being Nat such that
 A34: Q[mb] and
      for n being Nat st Q[n] holds n <= mb
         from NAT_1:sch 6(A31,A32);

     reconsider v,a,b = V/.mb as Vertex of G;
A35: v <> b by A28,A34;

A36: k in dom V by A4,A8,FINSEQ_3:27;
then A37: v = V/.k by A6,PARTFUN1:def 8;
     consider ma being set such that
A38: ma in dom V & a = V.ma by A11,FUNCT_1:def 5;
     reconsider ma as Element of NAT by A38;
A39: a = V/.ma by A38,PARTFUN1:def 8;

A40: now assume ma <= k;
     then A41: ma < k by A6,A29,A30,A38,REAL_1:def 5;
          a in the_Vertices_of G;
         then a in rng V & V is one-to-one by CHORD:def 12;
         then a..V >= k by A26,A36,CHORD:16;
         then a..V > ma by A41,XXREAL_0:2;
       hence contradiction by A38,FINSEQ_4:34;
     end;

   defpred R[Nat] means
    ex P being Walk of G, v1,v2,v3,v4 being Vertex of G st
      P is Path-like & P is open & P is chordless & P.length() = $1-1 &
       v1 = P.(len P-2) & v2 = P.3 & v3 = P.last() & v4 = P.first() &
       VLG.v4 > VLG.v3 & VLG.v3 > VLG.v2 & VLG.v2 > VLG.v1 &
       (for x being set st x in P.vertices() holds VLG.x <= VLG.v4) &
       for x being Vertex of G
         st x <> v4 & x,v2 are_adjacent & not x,v1 are_adjacent
           holds VLG.x < VLG.v4;

A42: VLG.v < VLG.a by A18,A36,A37,A38,A39,A40;

 A43: R[4] proof
         consider c being Vertex of G such that
     A44: c in dom VLG & VLG.b < VLG.c and
     A45: c,a are_adjacent & not c,v are_adjacent and
     A46: for x being Vertex of G
           st x <> c & x,a are_adjacent & not x,v are_adjacent
             holds VLG.x < VLG.c by A1,A2,A34,A42,Def34;

         consider P being Path of G,e1,e2 being set such that
     A47: P is open & len P = 5 & P.length() = 2 and
    A48: e1 Joins b,v,G & e2 Joins v,a,G & P.edges() = {e1,e2} &
         P.vertices() = {b,v,a} and
     A49: P.1 = b & P.3 = v & P.5 = a by A28,A34,A35,CHORD:47;
          P.first() = b & P.last() = a
             by A47,A49;
     then A50: P is chordless by A34,A47,CHORD:90;
         consider e being set such that
     A51: e Joins P.last(),c,G by A45,A47,A49,CHORD:def 3;

         set Qr = P.addEdge(e);
         set Q = Qr.reverse();
     A52: Qr.length() = 2+1 by A47,A51,Lm4;
     A53: len Qr = 5+2 by A47,A51,GLIB_001:65;
          1 in dom P & 3 in dom P & 5 in dom P by A47,FINSEQ_3:27;
     then A54: Qr.1 = b & Qr.3 = v & Qr.5 = a by A49,A51,GLIB_001:66;
     A55: Qr.last() = c by A51,GLIB_001:64;

     A56: now let x be set such that A57: x in P.vertices();
           per cases by A48,A57,ENUMSET1:def 1;
           suppose x = b; hence VLG.x <= VLG.b; end;
           suppose x = v; hence VLG.x <= VLG.b by A34,A42,XXREAL_0:2; end;
           suppose x = a; hence VLG.x <= VLG.b by A34; end;
         end;
     then A58: not c in P.vertices() by A44;
       not ex e being set st e Joins P.(len P-2),c,G by A45,A47,A49,CHORD:def 3
;
        then Qr is Path-like & Qr is open & Qr is chordless
                 by A47,A50,A51,A58,CHORD:97;
     then A59: Q is Path-like & Q is open & Q is chordless
                 by CHORD:91,GLIB_001:121,149;
     A60: 1 in dom Qr & 3 in dom Qr & 5 in dom Qr & 7 in dom Qr
             by A53,FINSEQ_3:27;
     A61: Q.length() = (3+1)-1 by A52,Lm5;
     A62: dom Q = dom Qr & len Q = len Qr by GLIB_001:22;
          v = Q.(7-3+1) &  a = Q.(7-5+1) & b = Q.(len Qr-1+1) &
         c = Q.(7-7+1) by A53,A54,A55,A60,GLIB_001:25;
     then A63: v = Q.(len Q-2) & a = Q.3 &  b = Q.last() &
         c = Q.first() by A53,A62;
     A64: VLG.c > VLG.b & VLG.b > VLG.a & VLG.a > VLG.v
               by A18,A34,A36,A37,A38,A39,A40,A44;
          now let x be set such that A65: x in Q.vertices();
              x in Qr.vertices() by A65,GLIB_001:93;
         then A66: x in P.vertices() \/ {c} by A51,GLIB_001:96;
           per cases by A66,XBOOLE_0:def 2;
           suppose x in P.vertices(); then VLG.x <= VLG.b by A56;
           hence VLG.x <= VLG.c by A44,XXREAL_0:2; end;
           suppose x in {c}; hence VLG.x <= VLG.c by TARSKI:def 1; end;
         end;
       hence thesis by A46,A59,A61,A63,A64;
     end;

 A67: for k being Nat st 4 <= k & R[k] holds R[k+1] proof
         let kk be Nat such that A68: 4 <= kk and A69: R[kk];
         reconsider k=kk as non empty Nat by A68;
         consider P being Walk of G, v1,v2,v3,v4 being Vertex of G such that
     A70: P is Path-like & P is open & P is chordless & P.length() = k-1 and
     A71: v1 = P.(len P-2) & v2 = P.3 & v3 = P.last() & v4 = P.first() and
     A72: VLG.v4 > VLG.v3 & VLG.v3 > VLG.v2 & VLG.v2 > VLG.v1 and
    A73: for x being set st x in P.vertices() holds VLG.x <= VLG.v4 and
     A74: for x being Vertex of G
           st x <> v4 & x,v2 are_adjacent & not x,v1 are_adjacent
            holds VLG.x < VLG.v4 by A69;

     A75: len P = 2*(k-1) + 1 by A70,GLIB_001:113;
          2*k >= 2*4 by A68,XREAL_1:66;
     then A76: 2*k-1 >= 8-1 by XREAL_1:11;
         then 2*0+1 < 2*1+1 & 3 < len P by A75,XXREAL_0:2;
         then consider ez being set such that
     A77: ez Joins P.1,P.3,G by A70,CHORD:92;
          now let e be set such that A78: e Joins v4,v3,G;
              2*0+1 < len P by A75,A76,XXREAL_0:2;
         then 1+2 = len P by A70,A71,A78,CHORD:92;
            hence contradiction by A68,A75;
         end;
     then v4,v2 are_adjacent & not v4,v3 are_adjacent by A71,A77,CHORD:def 3;

         then consider v5 being Vertex of G such that
     A79: v5 in dom VLG & VLG.v4 < VLG.v5 and
     A80: v5,v3 are_adjacent & not v5,v2 are_adjacent and
     A81: for x being Vertex of G
           st x <> v5 & x,v3 are_adjacent & not x,v2 are_adjacent
           holds VLG.x < VLG.v5 by A1,A2,A72,Def34;

     A82: now assume A83: v5,v1 are_adjacent;
              VLG.v2 < VLG.v4 by A72,XXREAL_0:2;
         then VLG.v1 < VLG.v2 & VLG.v2 < VLG.v5 by A72,A79,XXREAL_0:2;
             then consider v6 being Vertex of G such that
         A84: v6 in dom VLG & VLG.v5 < VLG.v6 and
         A85: v6,v2 are_adjacent & not v6,v1 are_adjacent and
              for x being Vertex of G
              st x <> v6 & x,v2 are_adjacent & not x,v1 are_adjacent
                holds VLG.x < VLG.v6 by A1,A2,A80,A83,Def34;
              VLG.v6 < VLG.v4 by A74,A79,A84,A85;
           hence contradiction by A79,A84,XXREAL_0:2;
         end;
         consider e being set such that
     A86: e Joins P.last(),v5,G by A71,A80,CHORD:def 3;
         set Qr = P.addEdge(e);
         set Q = Qr.reverse();
     A87: Qr.length() = k-1+1 by A70,A86,Lm4;
     A88: len Qr = len P + 2 by A86,GLIB_001:65;
          1 <= len P by A75,A76,XXREAL_0:2;
         then P.(len Qr-2) = v3 & len P in dom P by A71,A88,FINSEQ_3:27;
     then A89: v3 = Qr.(len Qr - 2) & len Qr-2 in dom Qr by A86,A88,Lm6;
          1 <= 3 & 3 <= len P by A75,A76,XXREAL_0:2;
         then 3 in dom P by FINSEQ_3:27;
     then A90: v2 = Qr.3 & 3 in dom Qr by A71,A86,Lm6;
     A91: v4 = Qr.first() & v5 = Qr.last() by A71,A86,GLIB_001:64;
    A92: not v5 in P.vertices() by A73,A79;
     not ex e being set st e Joins P.(len P-2),v5,G by A71,A82,CHORD:def 3;
         then Qr is Path-like & Qr is open & Qr is chordless
             by A70,A86,A92,CHORD:97;
     then A93: Q is Path-like & Q is open & Q is chordless
                 by CHORD:91,GLIB_001:121,149;
     A94: Q.length() = (k+1)-1 by A87,Lm5;
     A95: len Q = len Qr by GLIB_001:22;
         then v2 = Q.(len Q-3+1) & v3 = Q.(len Q-(len Qr-2)+1)
            by A89,A90,GLIB_001:25;
     then A96: v2 = Q.(len Q-2) & v3 = Q.3 & v4 = Q.last() & v5 = Q.first()
          by A91,A95,GLIB_001:23;
      now let x be set such that A97: x in Q.vertices();
              x in Qr.vertices() by A97,GLIB_001:93;
         then A98: x in P.vertices() \/ {v5} by A86,GLIB_001:96;
           per cases by A98,XBOOLE_0:def 2;
           suppose x in P.vertices(); then VLG.x <= VLG.v4 by A73;
             hence VLG.x <= VLG.v5 by A79,XXREAL_0:2; end;
           suppose x in {v5};
             hence VLG.x <= VLG.v5 by TARSKI:def 1; end;
         end;
       hence thesis by A72,A79,A81,A93,A94,A96;
     end;
A99: for i being Nat st 4 <= i holds R[i] from NAT_1:sch 8(A43,A67);
     4 <= 11 & 11 <= 11+G.order() by NAT_1:11;
    then 4 <= G.order()+11 by XXREAL_0:2;
    then R[G.order()+11] by A99;
    then consider P being Walk of G, v1,v2,v3,v4 being Vertex of G such that
A100: P is Path-like & P is open & P is chordless and
A101: P.length() = (G.order()+11)-1 and
     v1 = P.(len P-2) & v2 = P.3 & v3 = P.last() & v4 = P.first() and
     VLG.v4 > VLG.v3 & VLG.v3 > VLG.v2 & VLG.v2 > VLG.v1 and
     for x being Vertex of G
       st x <> v4 & x,v2 are_adjacent & not x,v1 are_adjacent
         holds VLG.x < VLG.v4;
    len P = 2*(G.order()+10)+1 by A101,GLIB_001:113;
   then 2*G.order()+21 + 1 = 2*len P.vertexSeq() by GLIB_001:def 14;
   then G.order() + 11 <= G.order() + 1 by A100,GLIB_001:155;
  hence contradiction by XREAL_1:10;
end;

theorem :: Theorem 4.3, Golumbic p. 86
 for G being finite chordal VVGraph holds
  (the_VLabel_of (LexBFS:CSeq(G)).Result())" is perfect VertexScheme of G
proof let G be finite chordal VVGraph;
   set Hh = (LexBFS:CSeq(G)).Result();
   reconsider H = Hh as finite chordal
                        natural-vlabeled VVGraph by Def18;
A1: H == G by Th42;
A2: H is with_property_L3 by Th65;
    H.labeledV() = the_Vertices_of G by Th61;
then A3: dom the_VLabel_of H = the_Vertices_of H by A1,GLIB_000:def 36;
   set V = (the_VLabel_of H)";
    V is VertexScheme of G by Th62;
   then reconsider Vh=V as VertexScheme of H by A1,CHORD:106;
    the_VLabel_of H is one-to-one by Th25;
then V" = the_VLabel_of H by FUNCT_1:65;
   then Vh is perfect by A2,A3,Th66;
  hence (the_VLabel_of Hh)" is perfect VertexScheme of G by A1,CHORD:110;
end;

begin :: The Maximum Cardinality Search algorithm

definition let G be finite _Graph;
  func MCS:Init(G) -> finite natural-vlabeled natural-v2labeled VVGraph equals
     G.set(VLabelSelector, {}).set(V2LabelSelector, the_Vertices_of G --> 0);
  coherence proof
    set G1 = G.set(VLabelSelector, {});
    set g  = the_Vertices_of G --> {};
A1: G1 == G by GLIB_003:8;
     dom g = the_Vertices_of G by FUNCOP_1:19;
    then dom g = the_Vertices_of G1 by A1,GLIB_000:def 36;
    then reconsider f = g as PartFunc of the_Vertices_of G1, rng g by
PARTFUN1:24;
    set G2 = G1.set(V2LabelSelector, f);
A2: the_V2Label_of G2 = f by GLIB_000:11;
 the_VLabel_of G2 = the_VLabel_of G1 by GLIB_000:12;
then A3: the_VLabel_of G2 is natural-yielding by GLIB_000:11;
     rng the_V2Label_of G2 = {0} by A2,FUNCOP_1:14;
    then the_V2Label_of G2 is natural-yielding by SEQM_3:def 8;
  hence thesis by A3,Def7,Def11;
 end;
end;

definition let G be finite natural-v2labeled VVGraph;
  assume A1: dom the_V2Label_of G = the_Vertices_of G;
  func MCS:PickUnnumbered(G) -> Vertex of G means :Def36:
  it = choose the_Vertices_of G if dom the_VLabel_of G = the_Vertices_of G
  otherwise ex S being finite non empty natural-membered set, F being Function
             st S = rng F
           & F = (the_V2Label_of G) | (the_Vertices_of G \ dom the_VLabel_of G)
           & it = choose (F " {max S});
  existence proof
    set VLG = the_VLabel_of G;     set V2G = the_V2Label_of G;
    set VG = the_Vertices_of G;    set F = V2G | (VG \ dom VLG);
    set S = rng F;
  per cases;
  suppose dom VLG = VG;
  hence thesis; end;
  suppose A2: dom VLG <> VG;
A3: dom F c= dom V2G & rng F c= rng V2G by RELAT_1:89,99;
A4: dom F c= the_Vertices_of G by A1,RELAT_1:89;
A5: dom VLG c= VG by GLIB_003:7;
     dom F = dom V2G /\ (VG \ dom VLG) by FUNCT_1:68;
then A6: dom F = (VG /\ VG) \ dom VLG by A1,XBOOLE_1:49;
A7: now assume dom F = {};
      then VG c= dom VLG by A6,XBOOLE_1:37;
     hence contradiction by A2,A5,XBOOLE_0:def 10;
    end;
A8: now let x be set such that A9: x in S;
    A10: x in rng V2G by A3,A9;
         rng V2G c= NAT by SEQM_3:def 8;
        hence x is natural by A10,ORDINAL1:def 13;
    end;
     dom F is finite by A4,FINSET_1:13;
    then reconsider S as non empty finite natural-membered set
      by A7,A8,FINSET_1:26,MEMBERED:def 6,RELAT_1:65;
    set IT = choose (F " {max S});
    set y = max S;
 y in S by PRE_CIRC:def 1;
then F " {max S} is non empty by FUNCT_1:142;
    then IT in dom F by FUNCT_1:def 13;
    then reconsider IT as Vertex of G by A4;
   ex S being finite non empty natural-membered set, F being Function
  st S = rng F &
     F = ((the_V2Label_of G) | (the_Vertices_of G \ dom the_VLabel_of G)) &
   IT = choose (F " {max S}) & IT is Vertex of G;
     hence thesis; end;
  end;
  uniqueness;
  consistency;
end;

definition let G be finite natural-v2labeled VVGraph, v be set;
 func MCS:LabelAdjacent(G, v) -> finite natural-v2labeled VVGraph equals
  G.set(V2LabelSelector, (the_V2Label_of G).incSubset(G.AdjacentSet({v})
                                                   \ dom (the_VLabel_of G),1));
  coherence proof
    set VLG = the_VLabel_of G;   set V2G = the_V2Label_of G;
    set f = V2G.incSubset(G.AdjacentSet({v})\ dom VLG,1);
    set H = G.set(V2LabelSelector, f);
 dom the_V2Label_of G c= the_Vertices_of G by Th11;
then A1: dom f c= the_Vertices_of G by Def4;
     f is PartFunc of dom f, rng f by PARTFUN1:24;
    then reconsider g = f as PartFunc of the_Vertices_of G, rng f by A1,
PARTFUN1:28;
 G.set(V2LabelSelector, g) is [V2Labeled];
    then reconsider H as finite VVGraph;
    set V2 = the_V2Label_of H;
 V2 = g by GLIB_000:11;
then A2: dom V2 = dom V2G by Def4;
A3: now let x be set such that
   A4: not x in G.AdjacentSet({v});
   A5: V2 = V2G.incSubset(G.AdjacentSet({v})\dom VLG,1) by GLIB_000:11;
        not x in G.AdjacentSet({v}) \ dom VLG by A4,XBOOLE_0:def 4;
     hence V2.x = V2G.x by A5,Def4;
   end;
A6: now let x be set such that
   A7: x in dom VLG;
   A8: V2 = V2G.incSubset(G.AdjacentSet({v})\dom VLG,1) by GLIB_000:11;
        not x in G.AdjacentSet({v}) \ dom VLG by A7,XBOOLE_0:def 4;
      hence V2.x = V2G.x by A8,Def4;
   end;
A9: now let x be set such that
   A10: x in dom V2G & x in G.AdjacentSet({v}) and
   A11: not x in dom VLG;
   A12: V2 = V2G.incSubset(G.AdjacentSet({v})\dom VLG,1) by GLIB_000:11;
        x in G.AdjacentSet({v}) \ dom VLG by A10,A11,XBOOLE_0:def 4;
     hence V2.x = V2G.x + 1 by A10,A12,Def4;
   end;
     now let x be set such that A13: x in rng V2;
        consider y being set such that
    A14: y in dom V2 and
    A15: V2.y = x by A13,FUNCT_1:def 5;
        per cases;
        suppose A16: not y in G.AdjacentSet({v}) or y in dom VLG;
         now per cases by A16;
            suppose not y in G.AdjacentSet({v});
              hence V2.y = V2G.y by A3; end;
            suppose y in dom VLG;
              hence V2.y = V2G.y by A6; end;
          end;
          hence x in NAT by A15;
        end;
        suppose y in G.AdjacentSet({v}) & not y in dom VLG;
        then V2.y = V2G.y + 1 by A2,A9,A14;
        hence x in NAT by A15; end;
    end;
    then rng V2 c= NAT by TARSKI:def 3;
    then V2 is natural-yielding by SEQM_3:def 8;
  hence G.set(V2LabelSelector, f) is finite natural-v2labeled VVGraph
   by Def11;
 end;
end;

definition let G be finite natural-vlabeled natural-v2labeled VVGraph,
               v be Vertex of G;
  redefine func MCS:LabelAdjacent(G, v) -> finite natural-vlabeled
                                           natural-v2labeled VVGraph;
  coherence proof
    set IT = MCS:LabelAdjacent(G, v);     set VL = the_VLabel_of IT;
    set V2 = the_V2Label_of IT;    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
     the_VLabel_of IT = the_VLabel_of G by GLIB_000:12;
  hence IT is finite natural-vlabeled natural-v2labeled VVGraph by Def7;
 end;
end;

definition
  let G be finite natural-vlabeled natural-v2labeled VVGraph,
      v be Vertex of G, n be natural number;
  func MCS:Update(G, v, n) -> finite natural-vlabeled natural-v2labeled
                              VVGraph equals
        MCS:LabelAdjacent(G.labelVertex(v, G.order()-'n), v);
   coherence proof  set k = G.order()-'n;
      reconsider Gl = G.labelVertex(v, k) as
         finite natural-vlabeled natural-v2labeled VVGraph;
       Gl == G by GLIB_003:47;
      then reconsider vv = v as Vertex of Gl by GLIB_000:def 36;
       MCS:LabelAdjacent(Gl, vv) is
         finite natural-vlabeled natural-v2labeled VVGraph;
      hence thesis;
   end;
end;

definition let G be finite natural-vlabeled natural-v2labeled VVGraph;
  func MCS:Step(G)
       -> finite natural-vlabeled natural-v2labeled VVGraph equals
          :Def39: G if G.order() <= card (dom the_VLabel_of G)
                  otherwise MCS:Update(G,
                                       MCS:PickUnnumbered(G),
                                       card (dom the_VLabel_of G));
  coherence; consistency;
end;

definition let G be finite _Graph;
  func MCS:CSeq(G)
       -> finite natural-vlabeled natural-v2labeled VVGraphSeq means
       :Def40: it.0 = MCS:Init(G) &
              for n being natural number holds it.(n+1) = MCS:Step(it.n);
  existence proof
     defpred P[set,set,set] means
      ($2 is finite natural-vlabeled natural-v2labeled VVGraph & $1 is Nat &
          ex nn being Nat,Gn,Gn1 being finite natural-vlabeled
                                       natural-v2labeled VVGraph st
          $1 = nn & $2 = Gn & $3 = Gn1 & Gn1 = MCS:Step(Gn)) or
      ((not $2 is finite natural-vlabeled natural-v2labeled VVGraph or
        not $1 is Nat) & $2 = $3);

     now let n,x be set;
         now per cases;
        suppose A1: x is finite natural-vlabeled natural-v2labeled VVGraph
                  & n is Nat;
          then reconsider Gn=x as finite natural-vlabeled natural-v2labeled
VVGraph;
          reconsider nn = n as Nat by A1;
          consider SGn being finite natural-vlabeled
                             natural-v2labeled VVGraph such that
      A2: SGn = MCS:Step(Gn);
         thus ex y being set st P[n,x,y] by A1,A2;
        end;
        suppose not x is finite natural-vlabeled
                                natural-v2labeled VVGraph or not n is Nat;
            hence ex y being set st P[n,x,y]; end;
        end;
        hence ex y being set st P[n,x,y];
    end;
then A3: for n being Element of NAT for x being set ex y being set st P[n,x,y];
A4: for n being Element of NAT for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2]
    holds y1 = y2;
    consider IT being Function such that
A5: dom IT = NAT & IT.0 = MCS:Init(G) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
      from RECDEF_1:sch 1(A3,A4);
    reconsider IT as ManySortedSet of NAT by A5,PBOOLE:def 3;
    defpred P2[Nat] means IT.$1 is finite natural-vlabeled
                                          natural-v2labeled VVGraph;
A6: P2[0] by A5;
A7: now let n be Nat;
A8:   n in NAT by ORDINAL1:def 13;
      assume P2[n];
         then ex nn being Nat, Gn,Gn1 being finite natural-vlabeled
                 natural-v2labeled VVGraph st
     n = nn & IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = MCS:Step(Gn) by A5,A8;
        hence P2[n+1];
    end;
A9: for n being Nat holds P2[n] from NAT_1:sch 2(A6,A7);
    then for n being Nat holds IT.n is _Graph;
    then reconsider IT as GraphSeq by GLIB_000:def 55;
     for n being Nat holds IT.n is [VLabeled] & IT.n is [V2Labeled] by A9;
    then reconsider IT as VVGraphSeq by Def20,GLIB_003:def 26;
     for n being Nat holds IT.n is finite natural-vlabeled
                                    natural-v2labeled by A9;
    then reconsider IT as finite natural-vlabeled natural-v2labeled VVGraphSeq
           by Def17,Def21,GLIB_000:def 60;
    take IT;
    thus IT.0 = MCS:Init(G) by A5;
    let n be Nat;
 n in NAT by ORDINAL1:def 13;
    then consider nn being Nat,
             Gn,Gn1 being finite natural-vlabeled
             natural-v2labeled VVGraph such that
A10: n = nn & IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = MCS:Step(Gn) by A5;
    thus IT.(n+1) = MCS:Step(IT.n) by A10;
  end;
  uniqueness proof
    let IT1,IT2 be finite natural-vlabeled natural-v2labeled
                   VVGraphSeq such that
A11: IT1.0 = MCS:Init(G) &
    for n being Nat holds IT1.(n+1) = MCS:Step(IT1.n) and
A12: IT2.0 = MCS:Init(G) &
    for n being Nat holds IT2.(n+1) = MCS:Step(IT2.n);
    defpred P[Nat] means IT1.$1 = IT2.$1;
A13: P[0] by A11,A12;
     now let n be Nat; assume P[n];
        then IT1.(n+1) = MCS:Step(IT2.n) by A11
                   .= IT2.(n+1) by A12;
     hence P[n+1];
    end;
then A14: for n being Element of NAT st P[n] holds P[n+1];
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A13,A14);
    then for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

theorem Th68:
for G being finite _Graph holds MCS:CSeq(G) is iterative
proof let G be finite _Graph;
  set CS = MCS:CSeq(G);
  let k,n be natural number;
   CS.(k+1) = MCS:Step(CS.k) by Def40;
  hence thesis by Def40;
end;

registration let G be finite _Graph;
  cluster MCS:CSeq(G) -> iterative;
  coherence by Th68;
end;

theorem Th69:
for G being finite _Graph holds the_VLabel_of MCS:Init(G) = {}
proof let G be finite _Graph;
    set G1 = G.set(VLabelSelector, {});
    set G2 = G1.set(V2LabelSelector, the_Vertices_of G --> {});
    the_VLabel_of G2 = the_VLabel_of G1 by GLIB_000:12;
  hence the_VLabel_of MCS:Init(G) = {} by GLIB_000:11;
end;

theorem Th70:
for G being finite _Graph, v being set
  holds dom the_V2Label_of MCS:Init(G) = the_Vertices_of G &
        (the_V2Label_of MCS:Init(G)).v = 0
proof let G be finite _Graph, v be set;
    set G1 = G.set(VLabelSelector, {});
    set g  = the_Vertices_of G --> {};
A1: G1 == G by GLIB_003:8;
A2: dom g = the_Vertices_of G by FUNCOP_1:19;
    then dom g = the_Vertices_of G1 by A1,GLIB_000:def 36;
    then reconsider f = g as PartFunc of the_Vertices_of G1, rng g by
PARTFUN1:24;
    set G2 = G1.set(V2LabelSelector, f);
A3: now let x be set; per cases;
     suppose x in dom f; hence f.x = {} by A2,FUNCOP_1:13; end;
     suppose not x in dom f; hence f.x = {} by FUNCT_1:def 4; end;
    end;
  thus dom the_V2Label_of MCS:Init(G) = the_Vertices_of G by A2,GLIB_000:11;
    the_V2Label_of G2 = f by GLIB_000:11;
  hence (the_V2Label_of MCS:Init(G)).v = 0 by A3;
end;

theorem Th71:
for G being finite _Graph holds G == MCS:Init(G)
proof let G be finite _Graph;
    set G1 = G.set(VLabelSelector, {});
    set G2 = G1.set(V2LabelSelector, the_Vertices_of G --> 0);
A1: G == G1 by GLIB_003:8;
     G1 == G2 by Th12;
  hence thesis by A1,GLIB_000:88;
end;

theorem Th72:
for G being finite natural-v2labeled VVGraph, x being set
 st not x in dom the_VLabel_of G &
    dom the_V2Label_of G = the_Vertices_of G &
    dom the_VLabel_of G <> the_Vertices_of G
 holds (the_V2Label_of G).x <= (the_V2Label_of G).(MCS:PickUnnumbered(G))
proof let G be finite natural-v2labeled VVGraph, x be set such that
A1: not x in dom the_VLabel_of G and
A2: dom the_V2Label_of G = the_Vertices_of G and
A3: dom the_VLabel_of G <> the_Vertices_of G;
    set w = MCS:PickUnnumbered(G);    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;      set VG = the_Vertices_of G;
    consider S being finite non empty natural-membered set,
             F being Function such that
A4: S = rng F and
A5: F = V2G | (VG \ dom VLG) and
A6: w = choose (F " {max S}) by A2,A3,Def36;
    set y = max S;
     y in rng F by A4,PRE_CIRC:def 1;
then F " {max S} is non empty by FUNCT_1:142;
then A7: w in dom F & F.w in {max S} by A6,FUNCT_1:def 13;
then V2G.w = F.w by A5,FUNCT_1:70;
then A8: V2G.w = y by A7,TARSKI:def 1;
A9: dom F = dom V2G /\ (VG \ dom VLG) by A5,FUNCT_1:68;
  per cases;
  suppose x in the_Vertices_of G;
  then x in VG \ dom VLG by A1,XBOOLE_0:def 4;
  then A10: x in dom F by A2,A9,XBOOLE_0:def 3;
  then A11: F.x = V2G.x by A5,FUNCT_1:70;
       F.x in S by A4,A10,FUNCT_1:def 5;
    hence V2G.x <= V2G.w by A8,A11,PRE_CIRC:def 1; end;
  suppose not x in the_Vertices_of G;
    hence V2G.x <= V2G.w by A2,FUNCT_1:def 4; end;
end;

theorem Th73:
for G being finite natural-v2labeled VVGraph
 st dom the_V2Label_of G = the_Vertices_of G &
    dom the_VLabel_of G <> the_Vertices_of G
 holds not MCS:PickUnnumbered(G) in dom the_VLabel_of G
proof let G be finite natural-v2labeled VVGraph such that
A1: dom the_V2Label_of G = the_Vertices_of G and
A2: dom the_VLabel_of G <> the_Vertices_of G;
    set w = MCS:PickUnnumbered(G);
    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
    set VG = the_Vertices_of G;
    assume A3: w in dom VLG;
    consider S being finite non empty natural-membered set,
             F being Function such that
A4: S = rng F and
A5: F = V2G | (VG \ dom VLG) and
A6: w = choose (F " {max S}) by A1,A2,Def36;
    set y = max S;
     y in rng F by A4,PRE_CIRC:def 1;
then F " {max S} is non empty by FUNCT_1:142;
then A7: w in dom F by A6,FUNCT_1:def 13;
A8: dom F = dom V2G /\ (VG \ dom VLG) by A5,FUNCT_1:68;
     not w in VG \ dom VLG by A3,XBOOLE_0:def 4;
  hence contradiction by A7,A8,XBOOLE_0:def 3;
end;

theorem Th74:
for G being finite natural-v2labeled VVGraph, v,x being set
 st not x in G.AdjacentSet({v})
  holds (the_V2Label_of G).x = (the_V2Label_of (MCS:LabelAdjacent(G,v))).x
proof let G be finite natural-v2labeled VVGraph, v,x be set such that
A1: not x in G.AdjacentSet({v});
    set GL = MCS:LabelAdjacent(G,v);
    set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
A2: V2 = V2G.incSubset(G.AdjacentSet({v})\dom VLG,1) by GLIB_000:11;
   not x in G.AdjacentSet({v}) \ dom VLG by A1,XBOOLE_0:def 4;
  hence V2.x = V2G.x by A2,Def4;
end;

theorem Th75:
for G being finite natural-v2labeled VVGraph, v,x being set
 st x in dom (the_VLabel_of G)
  holds (the_V2Label_of G).x = (the_V2Label_of (MCS:LabelAdjacent(G,v))).x
proof let G be finite natural-v2labeled VVGraph, v,x be set such that
A1: x in dom (the_VLabel_of G);
    set GL = MCS:LabelAdjacent(G,v);
    set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
A2: V2 = V2G.incSubset(G.AdjacentSet({v})\dom VLG,1) by GLIB_000:11;
     not x in G.AdjacentSet({v}) \ dom VLG by A1,XBOOLE_0:def 4;
  hence V2.x = V2G.x by A2,Def4;
end;

theorem Th76:
for G being finite natural-v2labeled VVGraph, v,x being set
 st x in dom the_V2Label_of G &
    x in G.AdjacentSet{v} & not x in dom the_VLabel_of G
  holds (the_V2Label_of (MCS:LabelAdjacent(G,v))).x = (the_V2Label_of G).x + 1
proof let G be finite natural-v2labeled VVGraph, v,x be set such that
A1: x in dom (the_V2Label_of G) & x in G.AdjacentSet({v}) and
A2: not x in dom (the_VLabel_of G);
    set GL = MCS:LabelAdjacent(G,v);
    set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
A3: V2 = V2G.incSubset(G.AdjacentSet({v})\dom VLG,1) by GLIB_000:11;
     x in G.AdjacentSet({v}) \ dom VLG by A1,A2,XBOOLE_0:def 4;
  hence V2.x = V2G.x + 1 by A1,A3,Def4;
end;

theorem Th77:
for G being finite natural-v2labeled VVGraph, v being set
 st dom (the_V2Label_of G) = the_Vertices_of G
  holds dom (the_V2Label_of (MCS:LabelAdjacent(G,v))) = the_Vertices_of G
proof let G be finite natural-v2labeled VVGraph, v be set such that
A1: dom (the_V2Label_of G) = the_Vertices_of G;
    set GL = MCS:LabelAdjacent(G,v);
    set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
     V2 = V2G.incSubset(G.AdjacentSet({v})\dom VLG,1) by GLIB_000:11;
  hence dom V2 = the_Vertices_of G by A1,Def4;
end;

theorem Th78:
for G being finite _Graph, n being natural number holds (MCS:CSeq(G)).n == G
proof let G be finite _Graph, n be Nat;
    defpred P[Nat] means (MCS:CSeq(G)).$1 == G;
     (MCS:CSeq(G)).0 = MCS:Init(G) by Def40;
then A1: P[0] by Th71;
A2: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A3: P[k];
        set CSK = (MCS:CSeq(G)).k;         set CK1 = (MCS:CSeq(G)).(k+1);
        set w   = MCS:PickUnnumbered(CSK);
        set kk  = G.order() -' card (dom the_VLabel_of CSK);
    A4: CSK.order() = G.order() by A3,GLIB_000:93;
    A5: CK1 = MCS:Step(CSK) by Def40;
      per cases;
      suppose card (dom the_VLabel_of CSK) < G.order();
        then CK1 = MCS:Update(CSK, w, card (dom the_VLabel_of CSK))
             by A4,A5,Def39;
    then A6: CK1 = MCS:LabelAdjacent(CSK.labelVertex(w,kk),w) by A3,GLIB_000:93
;
        set CC = CSK.labelVertex(w,kk);
    A7: CK1 == CC by A6,Th12;
         CC == CSK by GLIB_003:47;
        then CK1 == CSK by A7,GLIB_000:88;
      hence P[k+1] by A3,GLIB_000:88; end;
      suppose G.order() <= card (dom the_VLabel_of CSK);
      hence P[k+1] by A3,A4,A5,Def39; end;
    end;
     for k being Nat holds P[k] from NAT_1:sch 2(A1,A2);
  hence (MCS:CSeq(G)).n == G;
end;

theorem Th79:
for G being finite _Graph, m, n being natural number
 holds (MCS:CSeq(G)).m == (MCS:CSeq(G)).n
proof let G be finite _Graph, m,n be Nat;
A1: (MCS:CSeq(G)).m == G by Th78;
     (MCS:CSeq(G)).n == G by Th78;
  hence (MCS:CSeq(G)).m == (MCS:CSeq(G)).n by A1,GLIB_000:88;
end;

registration let G be finite chordal _Graph, n be natural number;
  cluster (MCS:CSeq(G)).n -> chordal VVGraph;
  coherence proof (MCS:CSeq(G)).n == G by Th78;
    hence (MCS:CSeq(G)).n is chordal VVGraph by CHORD:95;
  end;
end;

registration let G be finite chordal _Graph;
  cluster MCS:CSeq(G) -> chordal;
  correctness proof
    thus for x be Nat holds (MCS:CSeq(G)).x is chordal;
  end;
end;

theorem Th80:
for G being finite _Graph, n being natural number holds
  dom (the_V2Label_of ((MCS:CSeq(G)).n)) = the_Vertices_of ((MCS:CSeq(G)).n)
proof let G be finite _Graph, n be Nat;
  set CSN = (MCS:CSeq(G)).n;  set V2N = the_V2Label_of CSN;
  defpred P[Nat] means
     dom (the_V2Label_of ((MCS:CSeq(G)).$1)) =
        the_Vertices_of ((MCS:CSeq(G)).$1);
A1: (MCS:CSeq(G)).0 == G by Th78;
     (MCS:CSeq(G)).0 = MCS:Init(G) by Def40;
    then dom (the_V2Label_of ((MCS:CSeq(G)).0)) = the_Vertices_of G
        by Th70;
then A2: P[0] by A1,GLIB_000:def 36;
A3: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A4: P[k];
        set CSK = (MCS:CSeq(G)).k;        set V2K = the_V2Label_of CSK;
        set CK1 = (MCS:CSeq(G)).(k+1);    set V21 = the_V2Label_of CK1;
        set w   = MCS:PickUnnumbered(CSK);
        set m   = G.order() -' (card (dom the_VLabel_of CSK));
    A5: CSK == CK1 by Th79;
    A6: G == CSK by Th78;
    then A7: CSK.order() = G.order() by GLIB_000:93;
       per cases;
      suppose A8: card (dom the_VLabel_of CSK) < G.order();
         CK1 = MCS:Step(CSK) by Def40;
        then CK1 = MCS:Update(CSK, w, card (dom the_VLabel_of CSK))
              by A7,A8,Def39;
    then A9: CK1 = MCS:LabelAdjacent(CSK.labelVertex(w,m),w) by A6,GLIB_000:93;
        set CSlv = CSK.labelVertex(w,m);
        set V2v  = the_V2Label_of CSlv;
    A10: CSlv == CSK by GLIB_003:47;
    then A11: CSlv == CK1 by A5,GLIB_000:88;
         dom V2v = the_Vertices_of CSK by A4,Th13;
        then dom V2v = the_Vertices_of CSlv by A10,GLIB_000:def 36;
        then dom V21 = the_Vertices_of CSlv by A9,Th77;
      hence P[k+1] by A11,GLIB_000:def 36; end;
      suppose A12: G.order() <= card (dom the_VLabel_of CSK);
         CK1 = MCS:Step(CSK) by Def40;
        then CSK = CK1 by A7,A12,Def39;
      hence P[k+1] by A4; end;
    end;
     for k being Nat holds P[k] from NAT_1:sch 2(A2,A3);
  hence dom V2N = the_Vertices_of CSN;
end;

theorem Th81:
for G being finite _Graph, n being natural number
  st card (dom the_VLabel_of ((MCS:CSeq(G)).n)) < G.order()
 holds the_VLabel_of ((MCS:CSeq(G)).(n+1)) =
       (the_VLabel_of ((MCS:CSeq(G)).n)) +*
                  (MCS:PickUnnumbered((MCS:CSeq(G)).n) .-->
                  (G.order()-'(card (dom the_VLabel_of ((MCS:CSeq(G)).n)))))
proof let G be finite _Graph, n be Nat such that
A1: card (dom the_VLabel_of ((MCS:CSeq(G)).n)) < G.order();
    set CSN = (MCS:CSeq(G)).n;     set VLN = the_VLabel_of CSN;
    set CN1 = (MCS:CSeq(G)).(n+1); set VN1 = the_VLabel_of CN1;
    set w   = MCS:PickUnnumbered(CSN);
    set k   = G.order() -' card (dom VLN);
     G == CSN by Th78;
then A2: CSN.order() = G.order() by GLIB_000:93;
     CN1 = MCS:Step(CSN) by Def40;
    then CN1 = MCS:Update(CSN, w, card (dom VLN)) by A1,A2,Def39;
    then VN1 = the_VLabel_of CSN.labelVertex(w,k) by A2,GLIB_000:12;
  hence thesis by GLIB_003:45;
end;

theorem Th82:
for G being finite _Graph, n being natural number st n <= G.order()
 holds card dom the_VLabel_of ((MCS:CSeq(G)).n) = n
proof let G be finite _Graph, n be Nat such that A1: n <= G.order();
 defpred P[Nat] means
  $1 <= G.order() implies card dom the_VLabel_of ((MCS:CSeq(G)).$1) = $1;
 A2: for k being Element of NAT
     st k < G.order() & card dom the_VLabel_of ((MCS:CSeq(G)).k) = k
     holds  card dom the_VLabel_of ((MCS:CSeq(G)).(k+1)) = k+1
    proof let k be Element of NAT such that
    A3: k < G.order() & card dom the_VLabel_of ((MCS:CSeq(G)).k) = k;
        set CSK = (MCS:CSeq(G)).k;        set VLK = the_VLabel_of CSK;
        set CK1 = (MCS:CSeq(G)).(k+1);    set VK1 = the_VLabel_of CK1;
         CSK == G by Th78;
    then A4: dom VLK <> the_Vertices_of CSK by A3,GLIB_000:def 36;
        set w = MCS:PickUnnumbered(CSK);
    A5: VK1 = VLK +* (w .--> (G.order()-'k)) by A3,Th81;
        set wf  = w .--> (G.order() -' k);
         dom wf = {w} & rng wf = {G.order() -' k} by FUNCOP_1:14,19;
    then A6: dom VK1 = dom VLK \/ {w} by A5,FUNCT_4:def 1;
         dom the_V2Label_of CSK = the_Vertices_of CSK by Th80;
        then not w in dom VLK by A4,Th73;
      hence thesis by A3,A6,CARD_2:54;
    end;
     (MCS:CSeq(G)).0 = MCS:Init(G) by Def40;
then A7: P[0] by Th69,CARD_1:78,RELAT_1:60;
A8: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A9: P[k];
      per cases;
      suppose k < G.order();
      hence P[k+1] by A2,A9; end;
      suppose k >= G.order();
      hence P[k+1] by NAT_1:13; end;
    end;
     for k being Nat holds P[k] from NAT_1:sch 2(A7,A8);
  hence card dom the_VLabel_of ((MCS:CSeq(G)).n) = n by A1;
end;

theorem Th83:
for G being finite _Graph, n being natural number st G.order() <= n
  holds (MCS:CSeq(G)).(G.order()) = (MCS:CSeq(G)).n
proof let G be finite _Graph, n be natural number such that
A1: G.order() <= n;

    set CS = MCS:CSeq(G);
    defpred V[Nat] means
      G.order() = (card (dom the_VLabel_of CS.(G.order()+$1)));
A2: V[0] by Th82;
A3: for k being Nat st V[k] holds V[k+1] proof
      let k be Nat such that A4: V[k];
        set CSK = (MCS:CSeq(G)).(G.order()+k);
        set CK1 = (MCS:CSeq(G)).(G.order()+k+1);
         G == CSK by Th78;
    then A5: card dom the_VLabel_of CSK = CSK.order() by A4,GLIB_000:93;
         CK1 = MCS:Step(CSK) by Def40;
      hence V[k+1] by A4,A5,Def39;
    end;
A6: for k being Nat holds V[k] from NAT_1:sch 2(A2,A3);
    defpred P[Nat] means
     (CS.(G.order())) = (CS.(G.order()+$1));
A7: P[0];
A8: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A9: P[k];
        set CSK = (MCS:CSeq(G)).(G.order()+k);
        set VLK = the_VLabel_of CSK;
        set CK1 = (MCS:CSeq(G)).(G.order()+k+1);
        set VL1 = the_VLabel_of CK1;
         G == CSK by Th78;
        then CSK.order() = G.order() by GLIB_000:93;
    then A10: card dom VLK = CSK.order() by A6;
         CK1 = MCS:Step(CSK) by Def40;
      hence P[k+1] by A9,A10,Def39;
    end;
A11: for k being Nat holds P[k] from NAT_1:sch 2(A7,A8);
     ex i being Nat st G.order() + i = n by A1,NAT_1:10;
  hence thesis by A11;
end;

theorem Th84:
for G being finite _Graph, m,n being natural number st G.order() <= m & m <= n
  holds (MCS:CSeq(G)).m = (MCS:CSeq(G)).n
proof let G be finite _Graph, m,n be Nat such that
A1: G.order() <= m & m <= n;
A2: G.order() <= n by A1,XXREAL_0:2;
     (MCS:CSeq(G)).m = (MCS:CSeq(G)).(G.order()) by A1,Th83;
  hence (MCS:CSeq(G)).m = (MCS:CSeq(G)).n by A2,Th83;
end;

theorem Th85:
for G being finite _Graph holds MCS:CSeq(G) is eventually-constant
proof let G be finite _Graph;
  take G.order();
  let m be Nat such that A1: G.order() <= m;
  thus (MCS:CSeq(G)).(G.order()) = (MCS:CSeq(G)).m by A1,Th83;
end;

registration let G be finite _Graph;
  cluster MCS:CSeq(G) -> eventually-constant;
  coherence by Th85;
end;

theorem Th86:
for G being finite _Graph, n being natural number holds
       dom the_VLabel_of ((MCS:CSeq(G)).n) = the_Vertices_of ((MCS:CSeq(G)).n)
   iff G.order() <= n
proof let G be finite _Graph, n be Nat;
    set CSN = (MCS:CSeq(G)).n;    set VLN = the_VLabel_of ((MCS:CSeq(G)).n);
    set CSO = (MCS:CSeq(G)).G.order();    set VLO = the_VLabel_of CSO;
A1: CSN == G by Th78;
then A2: the_Vertices_of CSN = the_Vertices_of G by GLIB_000:def 36;
A3: CSO == G by Th78;
then A4: the_Vertices_of CSO = the_Vertices_of G by GLIB_000:def 36;
    thus dom VLN = the_Vertices_of CSN implies not n < G.order()
           by A2,Th82;
  assume A5: G.order() <= n;
A6: dom VLO c= the_Vertices_of CSO by GLIB_003:7;
     card dom VLO = card the_Vertices_of CSO by A4,Th82;
then A7: dom VLO = the_Vertices_of CSO by A6,CARD_FIN:1;
A8: dom VLO = dom VLN by A5,Th84;
     CSN == CSO by A1,A3,GLIB_000:88;
  hence dom VLN = the_Vertices_of CSN by A7,A8,GLIB_000:def 36;
end;

theorem Th87:
for G being finite _Graph holds (MCS:CSeq(G)).Lifespan() = G.order()
proof
    let G be finite _Graph;
    set CS = MCS:CSeq(G);
     G.order() <= G.order()+1 by NAT_1:13;
then A1: CS.(G.order()) = CS.(G.order()+1) by Th83;
     for n being Nat st CS.n = CS.(n+1) holds G.order() <= n proof
        let n be Nat such that A2: CS.n = CS.(n+1);
        assume A3: n < G.order();
        set VLN = the_VLabel_of (CS.n);
        set VN1 = the_VLabel_of (CS.(n+1));
        set w   = MCS:PickUnnumbered(CS.n);
        set j = card (dom VLN);
    A4: dom the_V2Label_of (CS.n) = the_Vertices_of (CS.n) by Th80;
         dom VLN <> the_Vertices_of (CS.n) by A3,Th86;
    then A5: not w in dom VLN by A4,Th73;
     j < G.order() by A3,Th82;
    then A6: VN1 = VLN +* (w .--> (G.order() -' j)) by Th81;
        set wf  = w .--> (G.order() -' j);
         dom wf = {w} & rng wf = {G.order() -' j} by FUNCOP_1:14,19;
    then A7: dom VN1 = dom VLN \/ {w} by A6,FUNCT_4:def 1;
         w in {w} by TARSKI:def 1;
      hence contradiction by A2,A5,A7,XBOOLE_0:def 2;
    end;
  hence thesis by A1,GLIB_000:def 57;
end;

theorem Th88:
for G being finite _Graph holds MCS:CSeq(G) is vlabel-numbering
proof let G be finite _Graph;
    set GS = MCS:CSeq(G);
A1: GS is fixed-vertices
    proof let n,m be Nat;  (GS.n) == (GS.m) by Th79;
      hence (the_Vertices_of (GS.n)) =
            (the_Vertices_of (GS.m)) by GLIB_000:def 36;
    end;
     GS.0 = MCS:Init(G) by Def40;
    then the_VLabel_of (GS.0) = {} by Th69;
then A2: GS is vlabel-initially-empty by Def24;
A3: GS.Lifespan() = G.order() by Th87;
     now let n be Nat such that A4: n < GS.Lifespan();
     reconsider w = MCS:PickUnnumbered(GS.n) as set;
    take w;
    A5: dom the_V2Label_of (GS.n) = the_Vertices_of (GS.n) by Th80;
        dom the_VLabel_of (GS.n) <> the_Vertices_of (GS.n)
         by A3,A4,Th86;
    hence not w in dom (the_VLabel_of (GS.n)) by A5,Th73;
      n = card dom the_VLabel_of (GS.n) by A3,A4,Th82;
    hence the_VLabel_of (GS.(n+1)) =
        (the_VLabel_of (GS.n)) +* (w .--> (GS.Lifespan()-'n))
               by A3,A4,Th81;
   end; then GS is adds-one-at-a-step by Def25;
  hence thesis by A1,A2,Def26;
end;

registration let G be finite _Graph;
  cluster MCS:CSeq(G) -> vlabel-numbering;
  coherence by Th88;
end;

theorem Th89:
for G being finite _Graph, n being natural number st n < G.order()
  holds (MCS:CSeq(G)).PickedAt(n) = MCS:PickUnnumbered((MCS:CSeq(G)).n)
proof let G be finite _Graph, n be Nat such that A1: n < G.order();
    set GS = MCS:CSeq(G);
    set CSN = GS.n;
    set CS1 = GS.(n+1);
    set PA = GS.PickedAt(n);
    set PU = MCS:PickUnnumbered(CSN);
    set VLN = the_VLabel_of CSN;
    set VL1 = the_VLabel_of CS1;
A2: GS.Lifespan() = G.order() by Th87;
then A3: not PA in dom VLN & VL1 = VLN +* (PA .--> (GS.Lifespan()-'n))
       by A1,Def27;
     n = card dom VLN by A1,Th82;
then A4: VL1 = VLN +* (PU .--> (GS.Lifespan()-'n)) by A1,A2,Th81;
    set f1 = PA .--> (GS.Lifespan()-'n);
    set f2 = PU .--> (GS.Lifespan()-'n);
 A5: dom f1 = {PA} & rng f1 = {GS.Lifespan()-'n} by FUNCOP_1:14,19;
 A6: dom f2 = {PU} & rng f2 = {GS.Lifespan()-'n} by FUNCOP_1:14,19;
 A7: dom VL1 = dom VLN \/ {PA} by A3,A5,FUNCT_4:def 1;
 A8: dom VL1 = dom VLN \/ {PU} by A4,A6,FUNCT_4:def 1;
     now assume PA <> PU;
        then not PA in {PU} by TARSKI:def 1;
    then A9: not PA in dom VL1 by A3,A8,XBOOLE_0:def 2;
         PA in {PA} by TARSKI:def 1;
      hence contradiction by A7,A9,XBOOLE_0:def 2;
    end;
  hence PA = PU;
end;

theorem Th90:
for G being finite _Graph, n being natural number st n < G.order()
 ex w being Vertex of (MCS:CSeq(G)).n
   st w = MCS:PickUnnumbered((MCS:CSeq(G)).n) &
   for v being set holds
    (v in G.AdjacentSet({w}) & not v in dom (the_VLabel_of ((MCS:CSeq(G)).n))
       implies (the_V2Label_of ((MCS:CSeq(G)).(n+1))).v =
                                     (the_V2Label_of ((MCS:CSeq(G)).n)).v + 1)
  & (not v in G.AdjacentSet({w}) or v in dom (the_VLabel_of ((MCS:CSeq(G)).n))
       implies (the_V2Label_of ((MCS:CSeq(G)).(n+1))).v =
                                         (the_V2Label_of ((MCS:CSeq(G)).n)).v)
proof let G be finite _Graph, n be Nat such that
A1: n < G.order();
    set CSN = (MCS:CSeq(G)).n;         set VLN = the_VLabel_of CSN;
    set V2N = the_V2Label_of CSN;      set CN1 = (MCS:CSeq(G)).(n+1);
    set VN1 = the_VLabel_of CN1;       set V21 = the_V2Label_of CN1;
    set w   = MCS:PickUnnumbered(CSN);
    set k   = G.order() -' n;
A2: n = card dom VLN by A1,Th82;
A3: G == CSN by Th78;
then A4: CSN.order() = G.order() by GLIB_000:93;
A5: CN1 = MCS:Step(CSN) by Def40
       .= MCS:Update(CSN, w, n) by A1,A2,A4,Def39
       .= MCS:LabelAdjacent(CSN.labelVertex(w,k),w) by A3,GLIB_000:93;
    set CSlv = CSN.labelVertex(w,k);
    set VLv  = the_VLabel_of CSlv;
    set V2v  = the_V2Label_of CSlv;
A6: CSN == CSlv by GLIB_003:47;
     CSN == G by Th78;
then A7: CSlv == G by A6,GLIB_000:88;
A8: CSlv.labeledV() = CSN.labeledV() \/ {w} by GLIB_003:59;
A9: V2v = V2N by Th13;
A10: dom VLN c= dom VLv by A8,XBOOLE_1:7;
A11: dom V2N = the_Vertices_of CSN by Th80;
A12: now let v be set;
        assume A13: v in G.AdjacentSet({w}) & not v in dom VLN;
    then A14: v in CSlv.AdjacentSet({w}) by A7,CHORD:51;
    A15: dom V2v = the_Vertices_of G & v in the_Vertices_of G
              by A3,A9,A11,A13,GLIB_000:def 36;
         not v in {w} by A13,CHORD:49;
        then not v in dom VLv by A8,A13,XBOOLE_0:def 2;
      hence V21.v = V2N.v + 1 by A5,A9,A14,A15,Th76;
    end;
A16: now let v be set;
      assume A17: not v in G.AdjacentSet({w}) or v in dom VLN;
      per cases by A17;
      suppose not v in G.AdjacentSet({w});
        then not v in CSlv.AdjacentSet({w}) by A7,CHORD:51;
       hence V21.v = V2N.v by A5,A9,Th74; end;
      suppose v in dom VLN;
      hence V21.v = V2N.v by A5,A9,A10,Th75; end;
    end;
    take w;
  thus thesis by A12,A16;
end;

theorem Th91:
for G being finite _Graph, n being natural number, x being set
 st not x in (dom the_VLabel_of ((MCS:CSeq(G)).n))
  holds (the_V2Label_of ((MCS:CSeq(G)).n)).x =
        card (G.AdjacentSet({x}) /\ (dom the_VLabel_of ((MCS:CSeq(G)).n)))
proof let G be finite _Graph, n be Nat;
     set CN  = (MCS:CSeq(G)).n;    set VLN = the_VLabel_of CN;
     set VL2 = the_V2Label_of CN;
    let x be set such that A1: not x in dom VLN;
    defpred P[Nat] means
    for x being set st not x in dom (the_VLabel_of ((MCS:CSeq(G)).$1))
      holds (the_V2Label_of ((MCS:CSeq(G)).$1)).x =
        card (G.AdjacentSet({x}) /\ (dom the_VLabel_of ((MCS:CSeq(G)).$1)));
     now let x be set;
        set C0 = (MCS:CSeq(G)).0;        set VL0 = the_VLabel_of C0;
        set V20 = the_V2Label_of C0;
        assume not x in dom VL0;
    A2: C0 = MCS:Init(G) by Def40;
        then dom VL0 = {} by Th69,RELAT_1:60;
      hence V20.x = card (G.AdjacentSet({x}) /\ dom VL0)
         by A2,Th70,CARD_1:78;
    end;
then A3: P[0];
A4: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A5: P[k];
        set CSK = (MCS:CSeq(G)).k;        set VLK = the_VLabel_of CSK;
        set VK2 = the_V2Label_of CSK;     set CS1 = (MCS:CSeq(G)).(k+1);
        set VL1 = the_VLabel_of CS1;      set V12 = the_V2Label_of CS1;
    A6: k <= k+1 by XREAL_1:40;
      per cases;
      suppose G.order() <= k;
     then VLK = VL1 & VK2 = V12 by A6,Th84;
      hence P[k+1] by A5; end;
      suppose A7: k < G.order();
        then consider w being Vertex of CSK such that
    A8: w = MCS:PickUnnumbered(CSK) and
    A9: for v being set holds
        (v in G.AdjacentSet({w}) & not v in dom VLK
           implies V12.v = VK2.v + 1) &
        (not v in G.AdjacentSet({w}) or v in dom VLK
           implies V12.v = VK2.v) by Th90;

   A10: G.order() = (MCS:CSeq(G)).Lifespan() by Th87;
         w = (MCS:CSeq(G)).PickedAt(k) by A7,A8,Th89;
    then A11: CS1.labeledV() = CSK.labeledV() \/ {w} by A7,A10,Th18;

         now let x be set such that A12: not x in dom VL1;
        A13: not x in dom VLK by A11,A12,XBOOLE_0:def 2;
        then A14: card (G.AdjacentSet({x}) /\ dom VLK) = VK2.x by A5;
          per cases;
          suppose A15: x in G.AdjacentSet({w}) & not x in dom VLK;
        then A16: V12.x = VK2.x + 1 by A9;
            set GAS = G.AdjacentSet({x});
        A17: w in GAS by A15,CHORD:53;
        A18: dom VK2 = the_Vertices_of CSK by Th80;
             dom VLK <> the_Vertices_of CSK by A7,Th86;
            then not w in dom VLK by A8,A18,Th73;
        then A19: not w in GAS /\ dom VLK by XBOOLE_0:def 3;
        A20: {w} c= GAS by A17,ZFMISC_1:37;
          GAS /\ dom VL1 = (GAS /\ dom VLK) \/ (GAS /\ {w}) by A11,XBOOLE_1:23
                       .= (GAS /\ dom VLK) \/ {w} by A20,XBOOLE_1:28;
          hence card (G.AdjacentSet({x}) /\ dom VL1) = V12.x by A14,A16,A19,
CARD_2:54; end;
          suppose A21: not x in G.AdjacentSet({w}) or x in dom VLK;
        then A22: V12.x = VK2.x by A9;
            set GAS = G.AdjacentSet({x});
        A23: not w in GAS by A11,A12,A21,CHORD:53,XBOOLE_0:def 2;
             GAS /\ {w} c= {w} by XBOOLE_1:17;
            then GAS /\ {w} in bool {w};
        then A24: GAS /\ {w} in { {}, {w} } by ZFMISC_1:30;
        A25: now assume GAS /\ {w} = {w};
                then w in GAS /\ {w} by TARSKI:def 1;
              hence contradiction by A23,XBOOLE_0:def 3;
            end;
            GAS /\ dom VL1 = (GAS /\ dom VLK) \/ (GAS /\ {w}) by A11,
XBOOLE_1:23
                         .= (GAS /\ dom VLK) \/ {} by A24,A25,TARSKI:def 2
                         .= GAS /\ dom VLK;
          hence card (G.AdjacentSet({x}) /\ dom VL1) = V12.x by A5,A13,A22;
          end;
        end;
      hence P[k+1]; end;
    end;
     for k being Nat holds P[k] from NAT_1:sch 2(A3,A4);
  hence VL2.x = card (G.AdjacentSet({x}) /\ dom VLN) by A1;
end;

definition let G be natural-vlabeled VGraph;
  attr G is with_property_T means                                  :Def41:
for a,b,c being Vertex of G st a in dom the_VLabel_of G &
    b in dom the_VLabel_of G & c in dom the_VLabel_of G &
    (the_VLabel_of G).a < (the_VLabel_of G).b &
    (the_VLabel_of G).b < (the_VLabel_of G).c &
    a,c are_adjacent & not b,c are_adjacent
  ex d being Vertex of G st d in dom the_VLabel_of G &
     (the_VLabel_of G).b < (the_VLabel_of G).d &
     b,d are_adjacent & not a,d are_adjacent;
end;

theorem
 for G being finite _Graph, n being natural number
  holds (MCS:CSeq(G)).n is with_property_T
proof let G be finite _Graph, n be Nat;
    set CN  = (MCS:CSeq(G)).n;    set VLN = the_VLabel_of CN;
     now let a,b,c be Vertex of CN such that
A1: a in dom VLN & b in dom VLN & c in dom VLN and
A2: VLN.a < VLN.b & VLN.b < VLN.c and
A3: a,c are_adjacent & not b,c are_adjacent;
A4: G == CN by Th78;
A5: G.order() = (MCS:CSeq(G)).Lifespan() by Th87;
A6: a in CN.labeledV() & b in CN.labeledV() & c in CN.labeledV()
          by A1;
     now assume A7: for d being Vertex of CN st d in dom VLN & VLN.b < VLN.d &
                   b,d are_adjacent holds a,d are_adjacent;
        set bn  = G.order() -' VLN.b;        set CSB = (MCS:CSeq(G)).bn;
        set VLB = the_VLabel_of CSB;         set VL2 = the_V2Label_of CSB;
         bn < n by A5,A6,Th29;
        then VLB c= VLN by Th24;
    then A8: dom VLB c= dom VLN by RELAT_1:25;
         VLN.b <= G.order() by A5,Th22;
    then A9: G.order() -' VLN.b = G.order() - VLN.b by BINARITH:50;
    A10: G.order() -' VLN.b <= G.order() by BINARITH:52;
         VLN.b = G.order() - (G.order() -' VLN.b) by A9;
    then A11: VLN.b = G.order() -' (G.order() -' VLN.b) by A10,BINARITH:50;
    A12: dom VL2 = the_Vertices_of CSB by Th80;
         1 <= VLN.b by A6,Th22;
   then A13: bn < G.order() by A9,XREAL_1:46;
    then A14: dom VLB <> the_Vertices_of CSB by Th86;
   A15: b = (MCS:CSeq(G)).PickedAt(bn) by A5,A6,Th27;
    then A16: b = MCS:PickUnnumbered(CSB) by A13,Th89;
         now assume a in dom VLB;
        then A17: a in CSB.labeledV();
            then VLN.b < VLB.a by A5,A11,Th29;
          hence contradiction by A2,A6,A17,Th26;
        end;
    then A18: VL2.b >= VL2.a by A12,A14,A16,Th72;
         not b in dom VLB by A12,A14,A16,Th73;
    then A19: VL2.b = card (G.AdjacentSet({b}) /\ dom VLB) by Th91;
         not a in CSB.labeledV() by A2,A5,A6,Th31;
    then A20: VL2.a = card (G.AdjacentSet({a}) /\ dom VLB) by Th91;
    A21: c in CSB.labeledV() by A2,A5,A6,Th30;
         c in CN.AdjacentSet({a}) by A2,A3,CHORD:52;
        then c in G.AdjacentSet({a}) by A4,CHORD:51;
    then A22: c in (G.AdjacentSet({a}) /\ dom VLB) by A21,XBOOLE_0:def 3;
         not c in CN.AdjacentSet({b}) by A3,CHORD:52;
        then not c in G.AdjacentSet({b}) by A4,CHORD:51;
    then A23: not c in (G.AdjacentSet({b}) /\ dom VLB) by XBOOLE_0:def 3;
         now let x be set such that A24: x in G.AdjacentSet({b}) /\ dom VLB;
        A25: x in dom VLB by A24,XBOOLE_0:def 3;
        then A26: x in dom VLN by A8;
       A27: x in CSB.labeledV() by A24,XBOOLE_0:def 3;
             dom VLN c= the_Vertices_of CN by GLIB_003:7;
            then reconsider d = x as Vertex of CN by A26;
            set CSB1 = (MCS:CSeq(G)).(bn+1);
            set VLB1 = the_VLabel_of CSB1;
             b in CSB1.labeledV() by A5,A13,A15,Th18;
        then A28: VLN.b = VLB1.b & VLN.d = VLB.d by A6,A8,A27,Th26;
             bn < bn+1 by XREAL_1:41;
            then VLB c= VLB1 by Th24;
            then dom VLB c= dom VLB1 by RELAT_1:25;
            then d in CSB1.labeledV() by A25;
        then A29: VLB.d = VLB1.d by A27,Th26;
             VLB.d in rng VLB by A25,FUNCT_1:def 5;
            then VLB.d in (Seg G.order() \ Seg (G.order() -' bn)) by A5,Th21;
            then G.order() -' bn < VLB1.d by A29,Th5;
        then A30: VLN.b < VLN.d by A5,A13,A15,A28,A29,Th19;
             d in G.AdjacentSet({b}) by A24,XBOOLE_0:def 3;
            then d in CN.AdjacentSet({b}) by A4,CHORD:51;
            then b <> d & b,d are_adjacent by CHORD:52;
        then a,d are_adjacent by A7,A8,A25,A30;
            then d in CN.AdjacentSet({a}) by A2,A30,CHORD:52;
            then x in G.AdjacentSet({a}) by A4,CHORD:51;
          hence x in G.AdjacentSet({a}) /\ dom VLB by A25,XBOOLE_0:def 3;
        end;
        then (G.AdjacentSet({b}) /\ dom VLB) c=
        (G.AdjacentSet({a}) /\ dom VLB) by TARSKI:def 3;
        then (G.AdjacentSet({b}) /\ dom VLB) c<
        (G.AdjacentSet({a}) /\ dom VLB) by A22,A23,XBOOLE_0:def 8;
      hence contradiction by A18,A19,A20,TREES_1:24;
    end;
    hence ex d being Vertex of CN st
    d in dom VLN & VLN.b < VLN.d & b,d are_adjacent & not a,d are_adjacent;
    end;
  hence thesis by Def41;
end;

theorem  :: LexBFS also has property T
 for G being finite _Graph
  holds (LexBFS:CSeq(G)).Result() is with_property_T
proof let G be finite _Graph;
    set CS = LexBFS:CSeq(G);  set G = CS.Result();
A1: G is with_property_L3 by Th65;
     now let a,b,c be Vertex of G such that A2: a in dom the_VLabel_of G &
        b in dom the_VLabel_of G & c in dom the_VLabel_of G &
        (the_VLabel_of G).a < (the_VLabel_of G).b &
        (the_VLabel_of G).b < (the_VLabel_of G).c &
        a,c are_adjacent & not b,c are_adjacent;
        consider d being Vertex of G such that
    A3: d in dom the_VLabel_of G &
        (the_VLabel_of G).c < (the_VLabel_of G).d &
        b,d are_adjacent & not a,d are_adjacent &
        for e being Vertex of G
          st e <> d & e,b are_adjacent & not e,a are_adjacent
           holds (the_VLabel_of G).e < (the_VLabel_of G).d
             by A1,A2,Def34;
      take d;
      thus d in dom the_VLabel_of G by A3;
      thus (the_VLabel_of G).b < (the_VLabel_of G).d by A2,A3,XXREAL_0:2;
      thus b,d are_adjacent by A3;
      thus not a,d are_adjacent by A3;
    end;
  hence CS.Result() is with_property_T by Def41;
end;

theorem :: Tarjan (SIAM Journal of Computing; 13(3):August 1984)
 for G being finite chordal natural-vlabeled VGraph
  st G is with_property_T & dom the_VLabel_of G = the_Vertices_of G
   for V being VertexScheme of G st V" = the_VLabel_of G holds V is perfect
proof
    let G be finite chordal natural-vlabeled VGraph such that
A1: G is with_property_T and
A2: dom the_VLabel_of G = the_Vertices_of G;
    set VLG = the_VLabel_of G;
    let V be VertexScheme of G such that
A3: V" = VLG;
A4:V is one-to-one by CHORD:def 12;
then A5: VLG is one-to-one by A3,FUNCT_1:62;
A6: VLG" = V by A3,A4,FUNCT_1:65;
len V = card the_Vertices_of G by CHORD:104;
    then dom V = Seg G.order() by FINSEQ_1:def 3;
then A7: rng VLG = Seg G.order() by A3,A4,FUNCT_1:55;
    defpred Q[Path of G] means
      len $1 >= 5 & $1 is open & $1 is chordless &
      VLG.($1.first()) > VLG.($1.last()) &
      VLG.($1.last()) > VLG.($1.3) &
      ex i being odd Element of NAT st 1 < i & i < len $1 &
   (for j,k being odd Element of NAT st i <= j & j < k & k <= len $1 holds
         VLG.($1.j) < VLG.($1.k)) &
   (for j,k being odd Element of NAT st 1 <= j & j < k & k <= i holds
        VLG.($1.j) > VLG.($1.k));

A8: now let R being Path of G such that A9: Q[R];
        defpred M[Nat] means
          ex P being Path of G st Q[P] & VLG.(P.last()) = $1;
    A10: for k being Nat st M[k] holds k <= G.order() proof
            let k be Nat such that A11: M[k];
            consider P being Path of G such that
        A12: Q[P] & VLG.(P.last()) = k by A11;
             VLG.(P.last()) in Seg G.order() by A2,A7,FUNCT_1:def 5;
          hence k <= G.order() by A12,FINSEQ_1:3;
        end;
    A13: ex k being Nat st M[k] by A9;
        consider k being Nat such that A14: M[k] and
    A15: for n being Nat st M[n] holds n <= k
              from NAT_1:sch 6(A10,A13);
        consider P being Path of G such that
    A16: Q[P] & VLG.(P.last()) = k by A14;

        consider i being odd Element of NAT such that
    A17: 1 < i & i < len P and
    A18: for j,k being odd Element of NAT st i <= j & j < k & k <= len P
          holds VLG.(P.j) < VLG.(P.k) and
    A19: for j,k being odd Element of NAT st 1 <= j & j < k & k <= i holds
           VLG.(P.j) > VLG.(P.k) by A16;

        reconsider c = P.first() as Vertex of G;
        reconsider b = P.last() as Vertex of G;
         3 <= len P by A16,XXREAL_0:2;
        then P.3 = P.vertexAt(2*1+1) by GLIB_001:def 8;
        then reconsider a = P.3 as Vertex of G;

   A20: 2*0+1 < 2*1+1 & 3 < len P by A16,XXREAL_0:2;
        then consider ez being set such that
    A21: ez Joins P.1,P.3,G by A16,CHORD:92;
    A22: c,a are_adjacent by A21,CHORD:def 3;
   A23: now let e be set such that A24: e Joins c,b,G;
             2*0+1 < len P by A16,XXREAL_0:2;
            then (ex e being set st e Joins P.1,P.(len P),G) iff 1+2=len P
               by A16,CHORD:92;
           hence contradiction by A16,A24;
        end;
    then A25: not b,c are_adjacent by CHORD:def 3;

        then consider d being Vertex of G such that
    A26: d in dom VLG & VLG.b < VLG.d and
    A27: b,d are_adjacent & not a,d are_adjacent by A1,A2,A16,A22,Def41;
    A28: d <> c by A23,A27,CHORD:def 3;
    A29: VLG.a < VLG.d by A16,A26,XXREAL_0:2;

    A30: now assume d in P.vertices();
            then consider dn being odd Element of NAT such that
        A31: dn <= len P & P.dn = d by GLIB_001:88;
        A32: dn < len P by A26,A31,REAL_1:def 5;
             dn <> 1 & 1 <= dn by A23,A27,A31,CHORD:2,def 3;
            then 2*0+1 < dn by REAL_1:def 5;
            then 1+2 <= dn & dn <> 3 by A16,A26,A31,CHORD:4;
        then A33: 2*1+1 < dn by REAL_1:def 5;
          per cases;
          suppose i <= dn; hence contradiction by A18,A26,A31,A32; end;
          suppose dn < i;  hence contradiction by A19,A29,A31,A33; end;
        end;
    A34: VLG.d <> VLG.c by A2,A5,A25,A27,FUNCT_1:def 8;

        defpred Mi[Nat] means
          $1 is odd & 3 < $1 & $1 <= len P &
            ex e being set st e Joins P.$1,d,G;

        consider el being set such that
    A35: el Joins P.last(),d,G by A27,CHORD:def 3;
    A36: ex k being Nat st Mi[k] by A20,A35;
         ex j being Nat st Mi[j] &
        for n being Nat st Mi[n] holds j <= n
           from NAT_1:sch 5(A36);
        then consider j being Nat such that
    A37: j is odd & 3 < j & j <= len P & ex e being set st e Joins P.j,d,G and
    A38: for i being Nat st Mi[i] holds j <= i;
        reconsider j as odd Element of NAT by A37,ORDINAL1:def 13;
        consider e being set such that
    A39: e Joins P.j,d,G by A37;
   A40: 2*0+1 <= j by CHORD:2;

        reconsider C = P.cut(1,j) as Path of G;

   A41: len C + 1 = j + 1 by A37,A40,GLIB_001:37;
    A42: C.first() = P.first() & C.last() = P.j by A37,A40,GLIB_001:38;
         C.vertices() c= P.vertices() by A37,A40,GLIB_001:95;
    then A43: not d in C.vertices() by A30;
    A44: e Joins C.last(),d,G by A37,A39,A40,GLIB_001:38;
    A45: now let n be odd Element of NAT such that
        A46: n <= j;  1 <= n by CHORD:2;
            then n in dom C by A41,A46,FINSEQ_3:27;
            then C.n = P.(1 + n - 1) by A37,A40,GLIB_001:48;
          hence C.n = P.n;
        end;
         2*0+1 < j by A37,XXREAL_0:2;
    then A47: C is open chordless by A16,A37,CHORD:93;
         2*1+1 < j by A37;
    then A48: C.3 = a & 3 in dom C by A41,A45,FINSEQ_3:27;
    A49: now let f be set such that A50: f Joins C.(len C-2),d,G;
           len C > 2*1+1 by A37,A41; then A51: len C >= 3+2 by CHORD:4;
           len C <> 5 by A27,A48,A50,CHORD:def 3;
          then len C > 5 by A51,REAL_1:def 5;
        then A52: 3+2-2 < len C-2 by XREAL_1:11;
            then 0 < len C-2*1;
        then reconsider cc = len C - 2 as odd Element of NAT by INT_1:16;
        A53: 3 < cc & cc < len C by A52,XREAL_1:46;
        then A54: cc < len P by A37,A41,XXREAL_0:2;
             f Joins P.cc,d,G by A41,A45,A50,A53;
          hence contradiction by A38,A41,A53,A54;
        end;
        :: building the path
        then reconsider D = C.addEdge(e) as Path of G by A43,A44,A47,CHORD:97;
    A55: D is open & D is chordless by A43,A44,A47,A49,CHORD:97;
   A56: len D = len C + 2 by A39,A42,GLIB_001:65;
    then A57: len D >= 3+2 by A37,A41,XREAL_1:9;
    A58: D.first() = c & D.last() = d by A39,A42,GLIB_001:64;
    A59: D.3 = a by A39,A42,A48,GLIB_001:66;

    A60: now let n be odd Nat such that A61: n <= j;
             1 <= n by CHORD:2; then n in dom C by A41,A61,FINSEQ_3:27;
          hence C.n = D.n by A44,GLIB_001:66;
        end;
    A62: ex i being odd Element of NAT st 1 < i & i < len D &
    (for j,k being odd Element of NAT st i <= j & j < k & k <= len D holds
        VLG.(D.j) < VLG.(D.k)) &
    (for j,k being odd Element of NAT st 1 <= j & j < k & k <= i holds
        VLG.(D.j) > VLG.(D.k)) proof
          per cases;
          suppose A63: j <= i;
            take j;
        A64: now let e,f be odd Element of NAT such that
            A65: j <= e & e < f & f <= len D;
                 e < j + 2*1 by A41,A56,A65,XXREAL_0:2;
                then e <= j + 2 - 2 by CHORD:3;
            then A66: e = j by A65,XXREAL_0:1;
                then D.e = C.j by A60;
            then A67: D.e = P.j by A45;
                 len C + 2 <= f by A41,A65,A66,CHORD:4;
            then A68: D.f = d by A56,A58,A65,XXREAL_0:1;
                 1 < 2*1+1 & 3 < j by A37;
                then VLG.(P.3) > VLG.(P.j) by A19,A63;
              hence VLG.(D.e) < VLG.(D.f) by A29,A67,A68,XXREAL_0:2;
            end;
             now let e,f be odd Element of NAT such that
            A69: 1 <= e & e < f & f <= j;
                 e <= j by A69,XXREAL_0:2; then e <= j & D.e = C.e by A60;
            then A70: D.e = P.e by A45;
                 D.f = C.f by A60,A69;
            then A71: D.f = P.f by A45,A69;
                f <= i by A63,A69,XXREAL_0:2;
              hence VLG.(D.e) > VLG.(D.f) by A19,A69,A70,A71;
            end;
          hence thesis by A37,A41,A56,A64,XREAL_1:31,XXREAL_0:2; end;
          suppose A72: i < j;
            take i;
       A73: len D > j by A41,A56,XREAL_1:31;
        A74: now let e,f be odd Element of NAT such that
            A75: i <= e & e < f & f <= len D;
                 e < j + 2*1 by A41,A56,A75,XXREAL_0:2;
            then A76: e <= j + 2 - 2 by CHORD:3;
           then A77: D.e = C.e by A60;
            then A78: D.e = P.e by A45,A76;
            A79: e <= len P by A37,A76,XXREAL_0:2;
              per cases by A75,REAL_1:def 5;
              suppose A80: f = len D;
                 now per cases by A79,REAL_1:def 5;
                  suppose e = len P;
                  hence VLG.(D.e) <= VLG.b by A45,A76,A77; end;
                  suppose e < len P;
                    hence VLG.(D.e) <= VLG.b by A18,A75,A78; end;
                end;
               hence VLG.(D.e) < VLG.(D.f) by A26,A58,A80,XXREAL_0:2; end;
               suppose f < len D;
            then A81: f <= j + 2 - 2 by A41,A56,CHORD:3;
                then D.f = C.f by A60;
            then A82: D.f = P.f by A45,A81;
                 i <= e & e < f & f <= len P by A37,A75,A81,XXREAL_0:2;
              hence VLG.(D.e) < VLG.(D.f) by A18,A78,A82; end;
            end;
             now let e,f be odd Element of NAT such that
            A83: 1 <= e & e < f & f <= i;
                 e <= i by A83,XXREAL_0:2;
                then e <= j by A72,XXREAL_0:2; then e <= j & D.e = C.e by A60
;
            then A84: D.e = P.e by A45;
                 f <= j by A72,A83,XXREAL_0:2;
                then f <= j & D.f = C.f by A60;
                then D.f = P.f by A45;
              hence VLG.(D.e) > VLG.(D.f) by A19,A83,A84;
            end;
          hence thesis by A17,A72,A73,A74,XXREAL_0:2; end;
        end;

      :: 1 --> 3 --> ... --> j --> d has Q, d > b
      then VLG.c <= VLG.d by A15,A16,A26,A29,A55,A57,A58,A59;
        then A85: VLG.c < VLG.d by A34,REAL_1:def 5;
        reconsider R = D.reverse() as Path of G;
    A86: R.first() = d & R.last() = c by A58,GLIB_001:23;
    then A87: R is open & R is chordless by A28,A55,CHORD:91,GLIB_001:def 24;
    A88: len R >= 3+2 by A57,GLIB_001:22;
        then 3 <= len R by XXREAL_0:2;
        then 3 in dom R by FINSEQ_3:27;
        then R.3 = D.(len D - 3 + 1) by GLIB_001:26;
   then A89: R.3 = C.j by A41,A56,A60;
         now per cases;
          suppose A90: i < j;
             now per cases by A37,REAL_1:def 5;
              suppose j = len P;
              hence VLG.(P.j) <= VLG.b; end;
              suppose j < len P;
              hence VLG.(P.j) <= VLG.b by A18,A90; end;
            end;
          hence VLG.(P.j) < VLG.c by A16,XXREAL_0:2; end;
          suppose i >= j;
            then 1 < 2*1+1 & 3 < j & j <= i by A37;
            then VLG.(P.j) < VLG.(P.3) by A19;
            then VLG.(P.j) < VLG.b by A16,XXREAL_0:2;
          hence VLG.(P.j) < VLG.c by A16,XXREAL_0:2; end;
        end;
    then A91: VLG.(R.last()) > VLG.(R.3) by A45,A86,A89;
    A92: for n being odd Element of NAT st n <= len R
           holds R.n = D.(len D - n + 1) & len D - n + 1 is Element of NAT
        proof
           let n be odd Element of NAT such that A93: n <= len R;
            1 <= n by CHORD:2;
        then A94:n in dom R by A93,FINSEQ_3:27;
           hence R.n = D.(len D - n + 1) by GLIB_001:26;
            len D - n + 1 in dom D by A94,GLIB_001:26;
         hence len D - n + 1 is Element of NAT;
        end;
      ex i being odd Element of NAT st 1 < i & i < len R &
      (for j,k being odd Element of NAT st i <= j & j < k & k <= len R holds
          VLG.(R.j) < VLG.(R.k)) &
      (for j,k being odd Element of NAT st 1 <= j & j < k & k <= i holds
          VLG.(R.j) > VLG.(R.k)) proof
            consider i being odd Element of NAT such that
        A95: 1 < i & i < len D and
    A96: for j,k being odd Element of NAT st i <= j & j < k & k <= len D holds
             VLG.(D.j) < VLG.(D.k) and
    A97: for j,k being odd Element of NAT st 1 <= j & j < k & k <= i holds
             VLG.(D.j) > VLG.(D.k) by A62;
            set ir = len D - i + 1;
             len D - 1 > len D - i by A95,XREAL_1:17;
       then A98: len D - 1 + 1 > len D - i + 1 by XREAL_1:10;
             len D - len D < len D - i by A95,XREAL_1:17;
        then A99:0 + 1 < len D - i + 1 by XREAL_1:10;
         then A100:1 < ir & ir < len R by A98,GLIB_001:22;
            reconsider ir as odd Element of NAT by A99,INT_1:16;
            take ir;
         A101:now let j,k be odd Element of NAT such that
            A102: ir <= j & j < k & k <= len R;
                set jr = len D - j + 1;
                set kr = len D - k + 1;
           A103: 1 < j & j <= len R by A99,A102,XXREAL_0:2;
           then A104: R.j = D.jr by A92;
                reconsider jr as odd Element of NAT by A92,A103;
           A105: R.k = D.kr by A92,A102;
                reconsider kr as odd Element of NAT by A92,A102;
                  i + j >= len D - i + 1 + i by A102,XREAL_1:9;
                 then i + j - j >= len D + 1 - j by XREAL_1:11;
                 then 1 <= kr & kr < jr & jr <= i by A102,Lm1,CHORD:2;
              hence VLG.(R.j) < VLG.(R.k) by A97,A104,A105;
            end;
             now let ja,k be odd Element of NAT such that
            A106: 1 <= ja & ja < k & k <= ir;
                 set jr = len D - ja + 1;
                 set kr = len D - k + 1;
            A107: 1 < k & k <= len R by A100,A106,XXREAL_0:2;
                  i + k <= len D - i + 1 + i by A106,XREAL_1:9;
                 then i + k - k <= len D + 1 - k by XREAL_1:11;
            then A108: i <= kr & kr < jr by A106,Lm1;
                 reconsider kr as odd Element of NAT by A92,A107;
            A109: ja <= len R by A106,A107,XXREAL_0:2;
            then A110: R.ja = D.jr by A92;
                 reconsider jr as odd Element of NAT by A92,A109;
                  len D - ja <= len D - 1 by A106,XREAL_1:12;
                 then jr <= len D - 1 + 1 by XREAL_1:9;
                 then VLG.(D.kr) < VLG.(D.jr) by A96,A108;
               hence VLG.(R.ja) > VLG.(R.k) by A92,A107,A110;
            end;
          hence thesis by A98,A99,A101,GLIB_001:22;
        end;
      hence contradiction by A15,A16,A85,A86,A87,A88,A91; end;
A111: rng V = dom VLG & dom V = rng VLG by A3,A4,A5,A6,FUNCT_1:54;
     now let a,b,c be Vertex of G such that
    A112: b<>c & a,b are_adjacent & a,c are_adjacent;
      let va,vb,vc be Nat such that
    A113: va in dom V & vb in dom V & vc in dom V and
    A114: V.va = a & V.vb = b & V.vc = c & va < vb & va < vc;
    assume
A115:   not b,c are_adjacent;
    A116: a = V.(VLG.a) & b = V.(VLG.b) & c = V.(VLG.c)
            by A2,A5,A6,FUNCT_1:56;
      a in dom VLG & b in dom VLG & c in dom VLG by A111,A113,A114,
FUNCT_1:def 5;
     then VLG.a in dom V & VLG.b in dom V & VLG.c in dom V by A111,
FUNCT_1:def 5;
    then A117: VLG.a = va & VLG.b = vb & VLG.c = vc by A4,A113,A114,A116,
FUNCT_1:def 8;
     per cases by A112,A116,REAL_1:def 5;
     suppose A118: VLG.b < VLG.c;
        consider P being Path of G, e1, e2 being set such that
    A119: P is open & len P = 5 & P.length() = 2 and
         e1 Joins c,a,G & e2 Joins a,b,G & P.edges() = {e1,e2} and
         P.vertices() = {c,a,b} and
    A120: P.1 = c & P.3 = a & P.5 = b by A112,A114,A117,CHORD:47;
    A121: P.first() = c & P.last() = b by A119,A120;
   A122: now let j,k be odd Element of NAT such that
        A123: 3 <= j & j < k & k <= len P;
             j < 5 by A119,A123,XXREAL_0:2;
            then j < 6 by XXREAL_0:2;
        then A124: j = 1 or j = 3 or j = 5 by CHORD:8;
             3 < k & k < 6 by A119,A123,XXREAL_0:2;
          hence VLG.(P.j) < VLG.(P.k) by A114,A117,A119,A120,A123,A124,CHORD:8;
        end;
   A125: now let j,k be odd Element of NAT such that
        A126: 1 <= j & j < k & k <= 3;
             j < 3 by A126,XXREAL_0:2;
            then j < 4 by XXREAL_0:2;
        then A127: j = 1 by A126,CHORD:7;
             k < 4 by A126,XXREAL_0:2;
          hence VLG.(P.j) > VLG.(P.k) by A114,A117,A120,A126,A127,CHORD:7;
        end;
         2*1+1 is odd;
       then Q[P] by A115,A118,A119,A121,A122,A125,CHORD:90;
      hence contradiction by A8; end;
     suppose A128: VLG.c < VLG.b;
        consider P being Path of G, e1, e2 being set such that
    A129: P is open & len P = 5 & P.length() = 2 and
         e1 Joins b,a,G & e2 Joins a,c,G & P.edges() = {e1,e2} and
         P.vertices() = {b,a,c} and
    A130: P.1 = b & P.3 = a & P.5 = c by A112,A114,A117,CHORD:47;
    A131: P.first() = b & P.last() = c by A129,A130;
   A132: now let j,k be odd Element of NAT such that
        A133: 3 <= j & j < k & k <= len P;
             j < 5 by A129,A133,XXREAL_0:2;
            then j < 6 by XXREAL_0:2;
        then A134: j = 1 or j = 3 or j = 5 by CHORD:8;
             3 < k & k < 6 by A129,A133,XXREAL_0:2;
          hence VLG.(P.j) < VLG.(P.k) by A114,A117,A129,A130,A133,A134,CHORD:8;
        end;
   A135: now let j,k be odd Element of NAT such that
        A136: 1 <= j & j < k & k <= 3;
         j < 3 by A136,XXREAL_0:2;
            then j < 4 by XXREAL_0:2;
        then A137: j = 1 by A136,CHORD:7;
             k < 4 by A136,XXREAL_0:2;
          hence VLG.(P.j) > VLG.(P.k) by A114,A117,A130,A136,A137,CHORD:7;
        end;
         2*1+1 is odd;
       then Q[P] by A115,A128,A129,A131,A132,A135,CHORD:90;
      hence contradiction by A8; end;
    end;
  hence V is perfect by CHORD:109;
end;
