:: Recognizing Chordal Graphs: Lex BFS and MCS
::  by Broderick Arneson and Piotr Rudnicki
::
:: Received November 17, 2006
:: Copyright (c) 2006 Association of Mizar Users

environ

 vocabularies AMI_1, ARYTM, ARYTM_1, BOOLE, CARD_1, CAT_1, FINSEQ_1, FINSET_1,
      FUNCOP_1, FUNCT_1, FUNCT_4, GRAPH_1, GLIB_000, GLIB_001, GLIB_002,
      GLIB_003, MATRIX_2, MSAFREE2, NEWTON, MEMBERED, ORDINAL1, ORDINAL2,
      PARTFUN1, PBOOLE, POLYNOM1, PRE_TOPC, SQUARE_1, DICKSON, REALSET1,
      RELAT_1, RELAT_2, SEQM_3, CHORD, BAGORDER, UPROOTS, TOPGEN_1, FINSEQ_4,
      NAT_1, ARYTM_3, WELLORD1, ALGSEQ_1, LEXBFS, CARD_FIN;
 notations TARSKI, XBOOLE_0, ZFMISC_1, NUMBERS, SUBSET_1, XXREAL_0, XREAL_0,
      RELAT_1, RELAT_2, WELLORD1, MEMBERED, PARTFUN1, FUNCT_1, FUNCT_2,
      BINARITH, PBOOLE, ORDINAL1, CARD_1, SEQM_3, POLYNOM1, FINSET_1, XCMPLX_0,
      NAT_1, CQC_LANG, FUNCT_4, GLIB_000, GLIB_001, GLIB_002, PRE_CIRC,
      GLIB_003, BAGORDER, TERMORD, UPROOTS, CHORD, FINSEQ_1, FINSEQ_4,
      DOMAIN_1, ABIAN, RELSET_1;
 constructors DOMAIN_1, AMISTD_2, UPROOTS, BAGORDER, TERMORD, GLIB_002,
      GLIB_003, CHORD, WELLORD1, PRE_CIRC, XXREAL_0, CARD_FIN;
 registrations RELSET_1, FINSET_1, NAT_1, INT_1, GLIB_000, GLIB_001, GLIB_002,
      GLIB_003, CARD_FIN, CHORD, POLYNOM1, FINSEQ_1, FUNCT_1, XREAL_0, TERMORD,
      BAGORDER, XBOOLE_0, ABIAN, PRE_CIRC, MEMBERED, ORDINAL1, HEYTING3,
      XXREAL_0;
 requirements NUMERALS, SUBSET, BOOLE, REAL, ARITHM;
 definitions GLIB_000, GLIB_001, GLIB_002, GLIB_003, FINSEQ_1;
 theorems AXIOMS, CARD_1, CARD_2, CARD_4, CQC_LANG, FINSEQ_1, FINSEQ_2,
      FINSEQ_3, FINSET_1, FUNCOP_1, FUNCT_1, FUNCT_2, FUNCT_4, GLIB_000,
      GLIB_001, GLIB_002, GLIB_003, HEYTING3, INT_1, NAT_1, BAGORDER, TERMORD,
      ORDINAL1, PARTFUN1, PBOOLE, REAL_1, RELAT_1, RELSET_1, SCM_1, TARSKI,
      XBOOLE_0, XBOOLE_1, XREAL_1, ZFMISC_1, PEPIN, ENUMSET1, SEQM_3, CHORD,
      BINARITH, NECKLACE, FINSEQ_4, WELLORD1, UPROOTS, KNASTER, CARD_FIN,
      POLYNOM1, ORDINAL3, TREES_1, PRE_CIRC, MEMBERED, NAT_2;
 schemes BINARITH, NAT_1, FUNCT_1, RECDEF_1, GOBOARD1, FRAENKEL;

begin :: Preliminaries

:: More general than GRAPH_2:4

theorem
for A,B being Element of NAT, X being non empty set
for F being Function of NAT, X st F is one-to-one
  holds Card {F.w where w is Element of NAT: A <= w & w <= A + B} = B+1
proof let A,B be Element of NAT, X be non empty set;
    let F be Function of NAT, X such that
A1: F is one-to-one;
    defpred P[Element of NAT] means
       Card { F.w where w is Element of NAT: A<= w & w<=A+$1 } = $1+1;
A2: dom F = NAT by FUNCT_2:def 1;
    now let x be set;
      hereby assume x in { F.w where w is Element of NAT: A <= w & w <= A+0};
       then consider w being Element of NAT such that
    A3: F.w = x & A<=w & w<=A+0;
      w = A by A3,XREAL_1:1;
      hence x in {F.A} by A3,TARSKI:def 1; end;
      assume x in {F.A}; then
      x = F.A by TARSKI:def 1;
      hence x in {F.w where w is Element of NAT: A<=w & w<=A+0};
    end; then
    {F.w where w is Element of NAT: A<=w & w<=A+0} = {F.A}
            by TARSKI:2; then
A4: P[0] by CARD_1:79;
A5: for k being Element of NAT st P[k] holds P[k+1] proof
let k be Element of NAT
such that A6: P[k];
        set Fwk  = {F.w where w is Element of NAT: A<=w & w<=A+k};
        set Fwk1 = {F.w where w is Element of NAT: A<=w & w<=A+k+1};
        Card Fwk is finite by A6,CARD_1:69; then
        reconsider Fwk as finite set by CARD_4:1;
        now assume F.(A+k+1) in Fwk; then
            consider w being Element of NAT such that
        A7: F.(A+k+1) = F.w & A <= w & w <= A+k;
            A+k+1 = w by A7,A1,A2,FUNCT_1:def 8;
          hence contradiction by A7,NAT_1:38;
        end; then
    A8: card (Fwk \/ {F.(A+k+1)}) = (k+1)+1 by A6,CARD_2:54;
        now let x be set;
          hereby assume x in Fwk1; then
              consider w being Element of NAT such that
          A9: x = F.w & A <= w & w<=A+k+1;
          A10: w = A+k+1 or w < A+k+1 by A9,REAL_1:def 5;
              per cases by A10,NAT_1:38;
              suppose w = A+k+1; then
                x in {F.(A+k+1)} by A9,TARSKI:def 1;
                hence x in Fwk \/ {F.(A+k+1)} by XBOOLE_0:def 2; end;
              suppose w <= A + k; then x in Fwk by A9;
                hence x in Fwk \/ {F.(A+k+1)} by XBOOLE_0:def 2; end;
          end;
          assume A11: x in Fwk \/ {F.(A+k+1)};
          per cases by A11,XBOOLE_0:def 2;
          suppose x in Fwk; then
            consider w being Element of NAT such that
        A12: x = F.w & A <= w & w<=A+k;
            w <= A+k+1 by A12,NAT_1:38;
            hence x in Fwk1 by A12; end;
          suppose x in {F.(A+k+1)}; then
        A13: x = F.(A+k+1) by TARSKI:def 1;
            A <= A+(k+1) by NAT_1:29;
            hence x in Fwk1 by A13; end;
        end;
      hence P[k+1] by A8,TARSKI:2;
    end;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A4,A5);
  hence thesis;
end;

Lm1:
for a,b,c being real number st a < b holds c-b+1 < c-a+1
proof let a,b,c be real number;
  assume a < b; then
  c-b < c-a by XREAL_1:12;
 hence c-b+1 < c-a+1 by XREAL_1:8;
end;

theorem Th2:
for n,m,k being natural number st m <= k & n < m holds k -' m < k -' n
proof let n,m,k be Nat such that A1: m <= k and A2: n < m;
   n < k by A1,A2,XREAL_1:2; then
A3: k -' n = k - n by BINARITH:50;
   k - m < k - n by A2,XREAL_1:17;
  hence k -' m < k -' n by A1,A3,BINARITH:50;
end;

theorem Th3:
for n,k being natural number st n < k holds k -' (n+1) + 1 = k -' n
proof let n,k be Nat such that A1: n < k;
A2: k -' n = k - n by A1,BINARITH:50;
   n+1 <= k by A1,NAT_1:38; then
   k -' (n+1) = k - (n+1) by BINARITH:50;
  hence k -' (n+1) + 1 = k -' n by A2;
end;

theorem Th4: :: Div00
for n,m,k being natural number st k <> 0 holds (n + m*k) div k = (n div k) + m
proof
  let n,m,k be natural number; assume
A1: k <> 0;
   m*k mod k = 0 by NAT_1:63;
 hence (n + m*k) div k = (n div k) + (m*k div k) by NAT_1:69
 .= (n div k) + m by A1, NAT_1:68;
end;

definition let S be set;
  attr S is with_finite-elements means                   :Def1:
    for x being Element of S holds x is finite;
end;

registration
  cluster non empty with_finite-elements set;
  existence proof set x = {1};
    take x;
    thus x is non empty;
 for y be Element of x holds y is finite by TARSKI:def 1,ORDINAL3:18;
    hence x is with_finite-elements by Def1;
  end;
  cluster non empty finite with_finite-elements Subset of bool NAT;
  existence proof
    set x = {{1}};
    reconsider x as Subset of bool NAT;
    take x;
    thus x is non empty;
    thus x is finite;
    for y being Element of x holds y is finite by TARSKI:def 1;
    hence x is with_finite-elements by Def1;
  end;
end;

registration let S be with_finite-elements set;
  cluster -> finite Element of S;
  coherence by Def1;
end;

definition  let f,g be Function;
  func f .\/ g -> Function means                 : Def2:
    dom it = dom f \/ dom g &
    for x being set st x in dom f \/ dom g holds it.x = f.x \/ g.x;
  existence proof
    deffunc A() = dom f \/ dom g;
    defpred P[set,set] means f.$1 \/ g.$1 = $2;
A1: for x,y1,y2 being set st x in A() & P[x,y1] & P[x,y2] holds y1 = y2;
A2: for x being set st x in A() ex y being set st P[x,y];
    ex f being Function st dom f = A() &
    for x being set st x in A() holds P[x,f.x] from FUNCT_1:sch 2(A1,A2);
    then consider IT being Function such that
A3: dom IT = A() and
A4: for x being set st x in A() holds P[x,IT.x];
    take IT;
    thus dom IT = dom f \/ dom g by A3;
    thus for x being set st x in dom f \/ dom g holds IT.x = f.x \/ g.x by A4;
  end;
  uniqueness proof
    let IT1,IT2 be Function such that
A5: dom IT1 = dom f \/ dom g and
A6: for x being set st x in dom f \/ dom g holds IT1.x = f.x \/ g.x and
A7: dom IT2 = dom f \/ dom g and
A8: for x being set st x in dom f \/ dom g holds IT2.x = f.x \/ g.x;
    now let x be set such that A9: x in dom IT1;
        IT1.x = f.x \/ g.x by A9,A5,A6;
      hence IT1.x = IT2.x by A5,A9,A8;
    end;
  hence IT1 = IT2 by A5,A7,FUNCT_1:9;
  end;
end;

theorem Th5:
for m,n,k being natural number holds
  m in ((Seg k) \ Seg (k -' n)) iff k -' n < m & m <= k
proof let m,n,k be Nat;
  hereby assume m in ((Seg k) \ Seg (k -' n)); then
A1: m in Seg k & not m in Seg (k -' n) by XBOOLE_0:def 4; then
    1 <= m & m <= k by FINSEQ_1:3;
    hence k -' n < m & m <= k by A1;
  end;
  assume
A2: k -' n < m & m <= k;
A3: not m in Seg (k -' n) by A2,FINSEQ_1:3;
    0+1 <= m by A2,NAT_1:38; then
    m in Seg k by A2,FINSEQ_1:3;
  hence m in ((Seg k) \ Seg (k -' n)) by A3,XBOOLE_0:def 4;
end;

theorem Th6:
for n,k,m being natural number st n <= m holds
  ((Seg k) \ Seg (k -' n)) c= ((Seg k) \ Seg (k -' m))
proof let n,k,m be Nat such that A1: n <= m;
  per cases;
  suppose k < m; then
A2:  Seg (k -' m) = {} by NAT_2:10,FINSEQ_1:4;
    for x be set st x in ((Seg k)\Seg(k-'n))holds x in Seg k by XBOOLE_0:def 4;
     hence thesis by A2,TARSKI:def 3; end;
  suppose A3: m <= k;
    now let x be set such that A4: x in ((Seg k) \ Seg (k -' n));
        reconsider y = x as Element of NAT by A4;
    A5: k -' n < y & y <= k by A4,Th5;
      per cases by A1,REAL_1:def 5;
      suppose m = n;
      hence x in ((Seg k) \ Seg (k -' m)) by A4; end;
      suppose n < m; then
        k -' m < k -' n by A3,Th2; then
        k -' m < y & y <= k by A5,XREAL_1:2;
      hence x in ((Seg k) \ Seg (k -' m)) by Th5; end;
    end;
    hence thesis by TARSKI:def 3; end;
end;

theorem Th7:
for n,k being natural number st n < k holds
  ((Seg k) \ Seg (k -' n)) \/ {k -' n} = (Seg k) \ Seg (k -' (n+1))
proof let n, k be Nat such that A1: n < k;
    set Sn  = (Seg k) \ Seg (k -' n);
    set Sn1 = (Seg k) \ Seg (k -' (n+1));
    now let x be set such that A2: x in Sn \/ {k -' n};
      per cases by A2,XBOOLE_0:def 2;
      suppose A3: x in Sn;
        n <= n+1 by NAT_1:38; then
        Sn c= Sn1 by Th6;
      hence x in Sn1 by A3; end;
      suppose A4: x in {k -' n}; then
    A5: x = k -' n by TARSKI:def 1;
        reconsider y = x as Nat by A4,TARSKI:def 1;
        now assume y = 0; then
          k - n + n = 0 + n by A1,BINARITH:50,A5;
          hence contradiction by A1;
        end; then 0 < y; then
    A6: 0+1 <= y & y <= k by A5,BINARITH:52,NAT_1:38;
    A7: n+1 <= k by A1,NAT_1:38;
        n < n + 1 by NAT_1:38; then
        k -' (n+1) < k -' n by A7,Th2;
      hence x in Sn1 by A5,A6,Th5; end;
    end; then
A8:  Sn \/ {k -' n} c= Sn1 by TARSKI:def 3;
    now let x be set such that A9: x in Sn1;
        reconsider y = x as Element of NAT by A9;
    A10: k -' (n+1) < y & y <= k by A9,Th5;
    A11: k -' (n+1) + 1 = k -' n by A1,Th3;
    A12: k -' n <= y by A10,A11,NAT_1:38;
      per cases by A12,REAL_1:def 5;
      suppose k -' n = y; then
        y in {k -' n} by TARSKI:def 1;
      hence x in Sn \/ {k -' n} by XBOOLE_0:def 2; end;
      suppose k -' n < y; then
        y in Sn by A10,Th5;
      hence x in Sn \/ {k -' n} by XBOOLE_0:def 2; end;
    end; then Sn1 c= Sn \/ {k -' n} by TARSKI:def 3;
  hence thesis by A8,XBOOLE_0:def 10;
end;

definition let f be Relation;
  attr f is natsubset-yielding means                         :Def3:
    rng f c= bool NAT;
end;

Lm2:
for F being Function st
  (for x being set st x in rng F holds x is finite)
holds F is finite-yielding
proof let F be Function such that
A1: for x being set st x in rng F holds x is finite;
  now let y be set;
  per cases;
  suppose y in dom F; then
    F.y in rng F by FUNCT_1:12;
    hence F.y is finite by A1; end;
  suppose not y in dom F;
    hence F.y is finite by FUNCT_1:def 4; end;
  end;
  hence F is finite-yielding by CARD_FIN:def 3;
end;

Lm3:
for F being finite-yielding Function, x being set st x in rng F
  holds x is finite
proof let F be finite-yielding Function;
  let x be set such that A1: x in rng F;
  consider y being set such that
A2: y in dom F & x = F.y by A1, FUNCT_1:def 5;
  thus x is finite by A2;
end;

registration
  cluster finite-yielding natsubset-yielding Function;
  existence proof
    set F = NAT --> {};
A1: dom F = NAT & rng F = {{}} by FUNCOP_1:14,FUNCOP_1:19;
    take F;
    now let x be set such that A2: x in rng F;
        x = {} by A1,A2,TARSKI:def 1; then
        x c= NAT by XBOOLE_1:2;
      hence x in bool NAT;
    end; then
A3: rng F c= bool NAT by TARSKI:def 3;
    for x be set st x in rng F holds x is finite by A1,TARSKI:def 1;
    hence F is finite-yielding by Lm2;
    thus  F is natsubset-yielding by A3,Def3;
  end;
end;

definition let f be finite-yielding natsubset-yielding Function, x be set;
  redefine func f.x -> finite Subset of NAT;
  coherence proof
  per cases;
  suppose x in dom f; then
A1: f.x in rng f by FUNCT_1:12;
    rng f c= bool NAT by Def3;
    hence f.x is finite Subset of NAT by A1; end;
  suppose not x in dom f; then
    f.x = {} by FUNCT_1:def 4;
    hence f.x is finite Subset of NAT by XBOOLE_1:2; end;
  end;
end;

theorem Th8:
for X being Ordinal, a, b be finite Subset of X st a <> b
  holds (a,1)-bag <> (b,1)-bag
proof let X be Ordinal, a,b be finite Subset of X such that
A1: a <> b;
    assume A2: (a,1)-bag = (b,1)-bag;
    now let x be set;
      x in a iff (b,1)-bag.x = 1 by A2, UPROOTS:8,UPROOTS:9;
      hence x in a iff x in b by UPROOTS:8,UPROOTS:9;
    end;
  hence contradiction by A1,TARSKI:2;
end;

definition let F be natural-yielding Function, S be set, k be natural number;
   func F.incSubset(S,k) -> natural-yielding Function means   :Def4:
   dom it = dom F &
   for y being set holds (y in S & y in dom F implies it.y = F.y + k) &
                         (not y in S implies it.y = F.y);
  existence proof
    deffunc G(set) = F.$1 + k;
    consider H being Function such that
A1: dom H = S /\ dom F and
A2: for x being set st x in (S /\ dom F) holds H.x = G(x) from FUNCT_1:sch 3;
A3: rng F c= NAT by SEQM_3:def 8;
    now let x be set such that A4: x in rng H;
        consider y being set such that
    A5: y in dom H & H.y = x by A4,FUNCT_1:def 5;
        H.y = F.y + k by A5,A1,A2;
      hence x in NAT by A5, ORDINAL1:def 13;
    end; then
    rng H c= NAT by TARSKI:def 3; then
A6: rng F \/ rng H c= NAT by A3,XBOOLE_1:8;
    rng (F+*H) c= rng F \/ rng H by FUNCT_4:18; then
    rng (F+*H) c= NAT by A6,XBOOLE_1:1; then
    reconsider IT = F+*H as natural-yielding Function by SEQM_3:def 8;
    take IT;
    dom IT = dom F \/ (S /\ dom F) by A1,FUNCT_4:def 1;
  hence dom IT = dom F by XBOOLE_1:22;
    now let y be set;
    A7: now assume A8: y in S & y in dom F; then
        A9: y in S /\ dom F by XBOOLE_0:def 3;
            y in dom H by A8,A1,XBOOLE_0:def 3; then
            IT.y = H.y by FUNCT_4:14;
          hence IT.y = F.y + k by A2,A9;
        end;
        now assume not y in S; then
            not y in dom H by A1,XBOOLE_0:def 3;
          hence IT.y = F.y by FUNCT_4:12;
        end;
      hence (y in S & y in dom F implies IT.y = F.y + k) &
            (not y in S implies IT.y = F.y) by A7;
    end;
    hence thesis;
  end;
  uniqueness proof
    let IT1,IT2 be natural-yielding Function such that
A10: dom IT1 = dom F & for y being set holds
      (y in S & y in dom F implies IT1.y = F.y + k) &
      (not y in S implies IT1.y = F.y) and
A11: dom IT2 = dom F & for y being set holds
      (y in S & y in dom F implies IT2.y = F.y + k) &
      (not y in S implies IT2.y = F.y);
    now let x be set such that A12: x in dom IT1;
      per cases by A12,A10;
      suppose x in S & x in dom F; then
        IT1.x = F.x + k & IT2.x = F.x + k by A10,A11;
      hence IT1.x = IT2.x; end;
      suppose not x in S; then
        IT1.x = F.x & IT2.x = F.x by A10,A11;
      hence IT1.x = IT2.x; end;
    end;
    hence thesis by A10,A11,FUNCT_1:9;
  end;
end;

definition let n be Ordinal, T be connected TermOrder of n,
           B be non empty finite Subset of Bags n;
  func max(B,T) -> bag of n means                                  :Def5:
     it in B & for x being bag of n st x in B holds x <= it,T;
  existence proof
    consider p being FinSequence such that
A1: rng p = B by FINSEQ_1:73;
  defpred P[Nat] means
  $1 <= len p implies
  (ex a being Nat, A being bag of n st a in dom p & a <= $1 & p.a = A &
      (for c being Nat, C being bag of n st c in dom p & c <= $1 & p.c = C
           holds C <= A, T));
    p <> {} by A1,FINSEQ_1:27; then
A2: 0 <> len p by FINSEQ_1:25;
A3: P[1] proof
    A4: 1 in dom p by A1,FINSEQ_3:34; then
        p.1 in B by A1,FUNCT_1:def 5; then
        reconsider A = p.1 as bag of n by POLYNOM1:def 14;
        now let c be Nat, C be bag of n such that
        A5: c in dom p & c <= 1 & p.c = C;
            1 <= c by A5,FINSEQ_3:27; then
            C = A by A5,XREAL_1:1;
          hence C <= A,T by TERMORD:6;
        end;
      hence P[1] by A4;
    end;
A6: for k being non empty Element of NAT st P[k] holds P[k+1] proof
        let k be non empty Element of NAT such that A7: P[k];
      per cases;
      suppose A8: k < len p; then
        consider a being Nat, A being bag of n such that
    A9: a in dom p & a <= k & p.a = A and
    A10: for c being Nat, C being bag of n st c in dom p & c <= k & p.c = C
          holds C <= A,T by A7;
    A11: k+1 <= len p by A8,NAT_1:38;
        1 <= k+1 by CHORD:1; then
    A12: k+1 in dom p by A11,FINSEQ_3:27; then
        p.(k+1) in B by A1,FUNCT_1:def 5; then
        reconsider Ck = p.(k+1) as bag of n by POLYNOM1:def 14;
        set m = max(A,Ck,T);
    A13: A <= m,T & Ck <= m,T by TERMORD:14;
        per cases by TERMORD:12;
        suppose A14: m = A;
        A15: a in dom p & a <= k+1 & p.a = A by A9,NAT_1:38;
            now let c be Nat,C be bag of n such that
            A16: c in dom p & c <= k+1 & p.c = C;
              per cases by A16,REAL_1:def 5;
              suppose c = k+1;
              hence C <= m,T by A16,TERMORD:14; end;
              suppose c < k+1; then
                c <= k by NAT_1:38; then
                C <= A,T by A16,A10;
              hence C <= m,T by A13,TERMORD:8; end;
            end;
          hence P[k+1] by A14,A15; end;
        suppose A17: m = Ck;
          now let c be Nat, C be bag of n such that
          A18: c in dom p & c <= k+1 & p.c = C;
            per cases by A18,REAL_1:def 5;
            suppose c = k+1;
            hence C <= m,T by A18,TERMORD:14; end;
            suppose c < k+1; then
              c <= k by NAT_1:38; then
              C <= A,T by A18,A10;
            hence C <= m,T by A13,TERMORD:8; end;
          end;
          hence P[k+1] by A17,A12; end;
        end;
      suppose k >= len p;
      hence P[k+1] by NAT_1:38; end;
    end;
A19: for k being non empty Element of NAT holds P[k]
        from BINARITH:sch 1(A3,A6);
    consider a being Nat, A being bag of n such that
A20: a in dom p & a <= len p & p.a = A and
A21: for c being Nat, C being bag of n st c in dom p & c <= len p & p.c = C
      holds C <= A, T by A2,A19;
    take A;
  thus A in B by A20,A1,FUNCT_1:def 5;
    now let x be bag of n such that A22: x in B;
        consider y being Element of NAT such that
    A23: y in dom p & p.y = x by A1,A22,FINSEQ_2:11;
        y <= len p by A23,FINSEQ_3:27;
      hence x <= A,T by A23,A21;
    end;
  hence thesis;
  end;
  uniqueness proof
    let IT1,IT2 be bag of n such that
A24: IT1 in B and
A25: for x being bag of n st x in B holds x <= IT1,T and
A26: IT2 in B and
A27: for x being bag of n st x in B holds x <= IT2,T;
A28: IT2 <= IT1,T by A25,A26;
A29: IT1 <= IT2,T by A24,A27;
  thus IT1 = IT2 by A28,A29,TERMORD:7;
  end;
end;

registration let O be Ordinal;
  cluster InvLexOrder O -> connected;
  coherence proof
    InvLexOrder O is well-ordering by BAGORDER:26;
    hence InvLexOrder O is connected by WELLORD1:def 4;
  end;
end;

begin :: Miscellany on graphs

registration let G be _Graph;
  cluster non empty one-to-one VertexSeq of G;
  existence proof
    set v = choose the_Vertices_of G, IT = <*v*>;
    reconsider IT as FinSequence of the_Vertices_of G;
    for n be Element of NAT st 1 <= n & n < len IT
      holds ex e being set st e Joins IT.n, IT.(n+1), G by FINSEQ_1:57;
    then reconsider IT as VertexSeq of G by GLIB_001:def 1;
    take IT;
    thus IT is non empty;
    thus IT is one-to-one by FINSEQ_3:102;
  end;
end;

definition
  let G be _Graph, V being non empty VertexSeq of G;
  mode Walk of V -> Walk of G means                  :Def6:
  it.vertexSeq() = V;
  existence proof
   set tVG = the_Vertices_of G;   set tEG = the_Edges_of G;
   now assume len V < 1; then
       len V = 0 by NAT_1:39;
       hence contradiction by FINSEQ_1:25;
   end; then 2*len V >= 2*1 & 2>=1 by XREAL_1:66; then
A1: 2*len V >= 1 by XREAL_1:2; then
A2: 2*len V - 1 >= 1 - 1 by XREAL_1:15;
    defpred P[Element of NAT,set] means
    ($1 is odd implies $2 = V.(($1+1) div 2)) &
    ($1 is even implies $2 Joins V.($1 div 2),V.($1 div 2 + 1),G);
    deffunc N() = 2*len V -' 1;
    deffunc D() = the_Vertices_of G \/ the_Edges_of G;
A3: for n being Element of NAT st n in Seg N()
        ex d being Element of D() st P[n,d] proof
        let n be Element of NAT such that A4: n in Seg N();
    A5: 1 <= n & n <= 2*len V -' 1 by A4,FINSEQ_1:3;
        2*len V -' 1 = 2*len V - 1 by A2,BINARITH:def 3; then
    A6: n+1 <= 2*len V - 1 + 1 by A5,XREAL_1:9;
        per cases;
        suppose n is odd; then
            reconsider n as odd Element of NAT;
            set m = (n+1) div 2;
            2 divides n+1 by PEPIN:22; then
        A7: 2*m = n+1 by NAT_1:49;
            0 <> m by A7; then
            0 < m; then
            0+1 <= m & m <= len V by NAT_1:38,A7,A6,XREAL_1:70; then
            m in dom V by FINSEQ_3:27; then
            V.m in rng V by FUNCT_1:12; then
            reconsider Vm=V.m as Element of tVG \/ tEG by XBOOLE_0:def 2;
            take Vm;
          thus thesis; end;
        suppose n is even; then
            reconsider n as even Element of NAT;
            set m = n div 2;
            2 divides n by PEPIN:22; then
        A8: 2*m = n by NAT_1:49;
        A9: now assume m < 1; then m = 0 by NAT_1:39;
                 hence contradiction by A4, FINSEQ_1:3,A8;
            end;
            now assume m >= len V; then
                 n >= 2*len V by A8,XREAL_1:66;
                 hence contradiction by A6,XREAL_1:41;
            end; then
            consider e being set such that
        A10: e Joins V.m,V.(m+1),G by A9,GLIB_001:def 1;
            e in tEG by A10,GLIB_000:def 15; then
            reconsider e as Element of tVG \/ tEG by XBOOLE_0:def 2;
            take e;
          thus thesis by A10; end;
    end;
   consider f being FinSequence of D() such that
A11: len f = N() and
A12: for n being Element of NAT st n in Seg N() holds P[n,f/.n]
        from GOBOARD1:sch 1(A3);
A13: len f = 2*len V - 1 by A11,A2,BINARITH:def 3;
   len f <> 2*0 by A11,A2,BINARITH:def 3; then
   f <> {} by FINSEQ_1:25; then
   rng f <> {} by FINSEQ_1:27; then
A14: 1 in dom f by FINSEQ_3:34; then
A15: 1 in Seg (len f) by FINSEQ_1:def 3;
   rng V <> {} by FINSEQ_1:27; then
A16: 1 in dom V by FINSEQ_3:34;
   (1+1) div 2 = (2*1) div 2 .= 1 by NAT_1:68; then
   f/.1 = V.(2*0+1) by A12,A11,A15; then
   f/.1 in rng V by A16,FUNCT_1:12; then
   f/.1 in the_Vertices_of G; then
A17: f.1 in the_Vertices_of G by A14,FINSEQ_4:def 4;
A18: now let n be odd Element of NAT such that
   A19: n < len f;
   A20: 1 <= n by HEYTING3:1; then
       1 <= n+1 & n+1 <= len f by A19,NAT_1:38; then
   A21: n+1 in Seg len f;
   A22: n in Seg len f by A20,A19;
   A23: len f is odd by A11,A2,BINARITH:def 3;
       1 <= n+2 & n+2 <= len f by A23, A19,XREAL_1:40, CHORD:4; then
   A24: n+2 in Seg len f;
   A25: f/.(n+1) Joins V.((n+1) div 2), V.((n+1) div 2 + 1),G by A11,A12,A21;
       n+1 in dom f by A21,FINSEQ_1:def 3; then
   A26: f.(n+1) Joins V.((n+1) div 2),V.((n+1) div 2 +1),G by A25
,FINSEQ_4:def 4;
       f/.n = V.((n+1) div 2) & n in dom f by A11,A12,A22,FINSEQ_1:def 3; then
   A27: f.n = V.((n+1) div 2) by FINSEQ_4:def 4;
   A28: P[n+2*1,f/.(n+2)] by A11,A12,A24;
   A29: ((n+1) + 2*1) div 2 = (n+1) div 2 + 1 by Th4;
       n+2 in dom f by A24,FINSEQ_1:def 3;
     hence f.(n+1) Joins f.n,f.(n+2),G by A26,A27,A28,A29,FINSEQ_4:def 4;
   end;
   reconsider f as Walk of G by A13,A17,A18,GLIB_001:def 3;
   take f;
A30: len f + 1 = 2*len V by A11,A1,BINARITH:53;
A31: len f + 1 = 2*len f.vertexSeq() by GLIB_001:def 14;
   now let k be Element of NAT such that
   A32: 1 <= k & k <= len f.vertexSeq();
       2*1 <= 2*k by A32,XREAL_1:66; then
       2-1 <= 2*k-1 by XREAL_1:15; then
       reconsider 2k1 = 2*k - 1 as odd Element of NAT by INT_1:16;
   A33: (f.vertexSeq()).k = f.2k1 by A32,GLIB_001:def 14;
       2 divides 2*k by PEPIN:22; then
       2*k = 2*(2*k div 2) by NAT_1:49; then
   A34: (2k1 + 1) div 2 = k;
       k in dom f.vertexSeq() by A32,FINSEQ_3:27; then
   A35: 2k1 in dom f by GLIB_001:74; then
       2k1 in Seg (2*len V -' 1) by A11,FINSEQ_1:def 3; then
       f/.2k1 = V.k by A12,A34;
     hence (f.vertexSeq()).k = V.k by A33,A35,FINSEQ_4:def 4;
   end;
   hence thesis by A31,A30,FINSEQ_1:18;
  end;
end;

registration
  let G be _Graph, V being non empty one-to-one VertexSeq of G;
  cluster -> Path-like Walk of V;
  correctness proof
    let W be Walk of V;
A1: W.vertexSeq() = V by Def6;
    now let m,n be odd Element of NAT such that
    A2: m <= len W & n <= len W and
    A3: W.m = W.n;
        set mk = (m+1) div 2;
        set nk = (n+1) div 2;
    A4: 2*mk - 1 = m & 1 <= mk & mk <= len V by A2,A1,GLIB_001:69;
    A5: 2*nk - 1 = n & 1 <= nk & nk <= len V by A2,A1,GLIB_001:69;
        W.vertexAt(n) = V.nk by A1,A2,GLIB_001:73; then
    A6: W.n = V.nk by A2,GLIB_001:def 8;
        W.vertexAt(m) = V.mk by A1,A2,GLIB_001:73; then
    A7: W.m = V.mk by A2,GLIB_001:def 8;
        nk in dom V & mk in dom V by A4,A5,FINSEQ_3:27;
      hence m = n by A4,A5, A6,A7,A3,FUNCT_1:def 8;
    end;
   hence W is Path-like by GLIB_001:147;
  end;
end;

Lm4: :: PathLike05
for G being _Graph, W being Walk of G, e,v being set
  st e Joins W.last(),v,G
 holds W.addEdge(e).length() = W.length() + 1
proof let G be _Graph, W be Walk of G, e,v be set such that
A1: e Joins W.last(),v,G;
A2: W.addEdge(e).edgeSeq() = W.edgeSeq()^<*e*> by A1,GLIB_001:83;
   len <*e*> = 1 by FINSEQ_1:56;
  hence W.addEdge(e).length() = W.length()+1 by A2, FINSEQ_1:35;
end;

Lm5: :: PathLike06
for G being _Graph, W being Walk of G
 holds W.length() = W.reverse().length()
proof let G be _Graph, W be Walk of G;
A1: len W = len W.reverse() by GLIB_001:22;
A2: len W = 2*W.length() + 1 by GLIB_001:113;
   2*W.length()+1-1 = 2*W.reverse().length()+1-1 by A1,A2,GLIB_001:113;
  hence W.length() = W.reverse().length();
end;

Lm6: :: PathLike10
for G being _Graph, W being Walk of G for e,x being set st e Joins W.last(),x,G
for n being natural number st n in dom W
 holds W.addEdge(e).n = W.n & n in dom W.addEdge(e)
proof let G be _Graph, W be Walk of G;
  let e,x be set such that A1: e Joins W.last(),x,G;
  let n be Nat such that A2: n in dom W;
A3: len W.addEdge(e) = len W + 2 by A1,GLIB_001:65;
    1 <= n & n <= len W & len W < len W + 2 by A2,FINSEQ_3:27,XREAL_1:31; then
A4: 1 <= n & n <= len W + 2 by XREAL_1:2;
  thus W.addEdge(e).n = W.n by A1,A2,GLIB_001:66;
  thus n in dom W.addEdge(e) by A4,A3,FINSEQ_3:27;
end;

theorem :: PathLike20
for G being _Graph, W1,W2 being Walk of G
 st W1 is trivial & W1.last() = W2.first() holds W1.append(W2) = W2
proof let G be _Graph, W1,W2 be Walk of G such that
A1: W1 is trivial & W1.last() = W2.first();
A2: len W1 = 1 by A1,GLIB_001:127;  then
A3: len W1.append(W2) + 1 = 1 + len W2 by A1,GLIB_001:29;
    now let k be Element of NAT such that
    A4: 1 <= k & k <= len W1.append(W2);
    A5: 1-1 <= k-1 by A4,XREAL_1:11;
        k-1 < k by XREAL_1:46; then
    A6: 0 <= k-1 & k-1 < len W2 by A3,A5,A4,XREAL_1:2;
        reconsider k1 = k-1 as Element of NAT by A5,INT_1:16;
        W1.append(W2).(1 + k1) = W2.(k1+1) by A1,A2,A6,GLIB_001:34;
      hence W1.append(W2).k = W2.k;
    end;
  hence thesis by A3, FINSEQ_1:18;
end;

theorem
for G, H being _Graph, A, B, C being set,
    G1 being (inducedSubgraph of G,A), H1 being (inducedSubgraph of H,B),
    G2 being (inducedSubgraph of G1,C), H2 being (inducedSubgraph of H1,C)
 st G == H & A c= B & C c= A & C is non empty Subset of the_Vertices_of G
  holds G2 == H2
proof let G,H be _Graph, A,B,C be set,
    G1 be (inducedSubgraph of  G,A), H1 be (inducedSubgraph of  H,B),
    G2 be (inducedSubgraph of G1,C), H2 be (inducedSubgraph of H1,C) such that
A1: G == H and
A2: A c= B & C c= A and
A3: C is non empty Subset of the_Vertices_of G;
A4: the_Vertices_of G = the_Vertices_of H by A1,GLIB_000:def 36;
A5: C c= B by A2,XBOOLE_1:1;
  per cases;
  suppose A6: A is non empty Subset of the_Vertices_of G &
              B is non empty Subset of the_Vertices_of G;
A7: G2 is inducedSubgraph of G,C by A6,A2,A3,CHORD:29;
A8: H2 is inducedSubgraph of H,C by A6,A4,A5,A3,CHORD:29;
    G.edgesBetween(C) = H.edgesBetween(C) by A1,GLIB_000:93; then
    H2 is inducedSubgraph of G,C by A1,A8,GLIB_000:98;
  hence thesis by A7,GLIB_000:96; end;
  suppose A9: not A is non empty Subset of the_Vertices_of G &
                  B is non empty Subset of the_Vertices_of G; then
A10: G1 == G by GLIB_000:def 39; then
    G.edgesBetween(C) = G1.edgesBetween(C) by GLIB_000:93; then
A11: G2 is inducedSubgraph of G,C by A10,GLIB_000:98;
A12: H2 is inducedSubgraph of H,C by A9,A4,A5,A3,CHORD:29;
    G.edgesBetween(C) = H.edgesBetween(C) by A1,GLIB_000:93; then
    H2 is inducedSubgraph of G,C by A1,A12,GLIB_000:98;
  hence thesis by A11,GLIB_000:96; end;
  suppose A13: A is non empty Subset of the_Vertices_of G &
          not B is non empty Subset of the_Vertices_of G; then
    H1 == H by A4,GLIB_000:def 39; then
A14: H1 == G by A1,GLIB_000:88; then
    G.edgesBetween(C) = H1.edgesBetween(C) by GLIB_000:93; then
A15: H2 is inducedSubgraph of G,C by A14,GLIB_000:98;
    G2 is inducedSubgraph of G,C by A13,A2,A3,CHORD:29;
  hence thesis by A15,GLIB_000:96; end;
  suppose not A is non empty Subset of the_Vertices_of G &
          not B is non empty Subset of the_Vertices_of G; then
A16: G1 == G & H1 == H by A4,GLIB_000:def 39; then
    H1 == G by A1,GLIB_000:88; then
A17: H1 == G1 by A16,GLIB_000:88; then
    G1.edgesBetween(C) = H1.edgesBetween(C) by GLIB_000:93; then
    H2 is inducedSubgraph of G1,C by A17,GLIB_000:98;
  hence thesis by GLIB_000:96;
end;
end;

definition let G be VGraph;
  attr G is natural-vlabeled means                                  :Def7:
    the_VLabel_of G is natural-yielding;
end;

begin :: Graphs with two vertex labels

definition
  func V2LabelSelector -> natural number equals 8;
  coherence;
end;

definition let G be GraphStruct;
  attr G is [V2Labeled] means :Def9: ::dV2LABELED
    V2LabelSelector in dom G &
    ex f being Function st G.V2LabelSelector = f & dom f c= the_Vertices_of G;
end;

registration
  cluster [Graph-like] [Weighted] [ELabeled] [VLabeled] [V2Labeled]
          GraphStruct;
  existence proof
    set V5 = {1}, E3 = {};
    consider S1 being Function of E3,V5;
    consider W1 being ManySortedSet of E3;
    consider EL8 being PartFunc of E3,REAL;
    consider VL6 being PartFunc of V5,REAL;
    set G=<*V5*>^<*E3*>^<*S1*>^<*S1*>^<*W1*>^<*EL8*>^<*VL6*>^<*VL6*>;
A1: len G = 8 & G.1 = V5 & G.2 = E3 & G.3 = S1 & G.4 = S1 & G.5 = W1 &
      G.6 = EL8 & G.7 = VL6 & G.8 = VL6 by SCM_1:12; then
    dom G = Seg 8 by FINSEQ_1:def 3; then
    reconsider G as GraphStruct by GLIB_000:def 1;
    take G;
    dom G = Seg 8 by A1, FINSEQ_1:def 3; then
A2: VertexSelector in dom G & EdgeSelector in dom G & SourceSelector in dom G &
    TargetSelector in dom G & WeightSelector in dom G &
    ELabelSelector in dom G & VLabelSelector in dom G &
    V2LabelSelector in dom G;
A3: the_Vertices_of G = V5 & the_Edges_of G = E3 & the_Source_of G = S1 &
    the_Target_of G = S1 & G.WeightSelector = W1 & G.ELabelSelector = EL8 &
      G.VLabelSelector = VL6 & G.V2LabelSelector = VL6 by SCM_1:12;
    dom EL8 c= E3 & dom VL6 c= V5;
    hence thesis by A2,A3,GLIB_000:def 11,GLIB_003:def 4,
                    GLIB_003:def 5,GLIB_003:def 6, Def9;
 end;
end;

definition
  mode V2Graph is [V2Labeled] _Graph;
  mode VVGraph is [VLabeled] [V2Labeled] _Graph;
end;

definition let G be V2Graph;
  func the_V2Label_of G -> Function equals G.V2LabelSelector;
  coherence proof
    consider f being Function such that
A1: G.V2LabelSelector = f & dom f c= the_Vertices_of G by Def9;
    thus thesis by A1;
  end;
end;

theorem Th11:
for G being V2Graph holds dom the_V2Label_of G c= the_Vertices_of G
proof let G be V2Graph;
    consider f being Function such that
A1: G.V2LabelSelector = f & dom f c= the_Vertices_of G by Def9;
  thus thesis by A1;
end;

registration let G be _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> [Graph-like]; coherence proof
    not V2LabelSelector in _GraphSelectors by GLIB_000:2;
    hence thesis by GLIB_000:13;
  end;
end;

theorem Th12:
for G being _Graph, X being set holds G.set(V2LabelSelector, X) == G
proof
    let G be _Graph, X be set; set GS = _GraphSelectors;
    set G2 = G.set(V2LabelSelector,X);
    not V2LabelSelector in GS by GLIB_000:2;then
    the_Vertices_of G2 = the_Vertices_of G &
    the_Edges_of G2 = the_Edges_of G &
    the_Source_of G2 = the_Source_of G &
    the_Target_of G2 = the_Target_of G by GLIB_000:13;
    hence G2 == G by GLIB_000:def 36;
end;

registration let G be finite _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> finite; coherence proof
    G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_000:92;
  end;
end;

registration let G be loopless _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> loopless; coherence proof
    G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_000:92;
  end;
end;

registration let G be trivial _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> trivial; coherence proof
    G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_000:92;
  end;
end;

registration let G be non trivial _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> non trivial; coherence proof
    G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_000:92;
  end;
end;

registration let G be non-multi _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> non-multi; coherence proof
    G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_000:92;
  end;
end;

registration let G be non-Dmulti _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> non-Dmulti; coherence proof
    G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_000:92;
  end;
end;

registration let G be connected _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> connected; coherence proof
    G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_002:8;
  end;
end;

registration let G be acyclic _Graph, X be set;
  cluster G.set(V2LabelSelector,  X) -> acyclic; coherence proof
    G.set(V2LabelSelector, X) == G by Th12;
    hence thesis by GLIB_002:44;
  end;
end;

registration let G be VGraph, X be set;
  cluster G.set(V2LabelSelector, X) -> [VLabeled]; coherence proof
    set G1 = G.set(V2LabelSelector,X);
A1: dom G c= dom G1 by GLIB_000:10;
A2: VLabelSelector in dom G by GLIB_003:def 6;
    G == G1 by Th12; then
A3: the_Vertices_of G = the_Vertices_of G1 by GLIB_000:def 36;
A4: G1.VLabelSelector = the_VLabel_of G by GLIB_000:12;
    dom the_VLabel_of G c= the_Vertices_of G by GLIB_003:7;
    hence thesis by A2,A1,A3,A4,GLIB_003:def 6;
  end;
end;

registration let G be EGraph, X be set;
  cluster G.set(V2LabelSelector, X) -> [ELabeled]; coherence proof
    set G1 = G.set(V2LabelSelector,X);
A1: dom G c= dom G1 by GLIB_000:10;
A2: ELabelSelector in dom G by GLIB_003:def 5;
    G == G1 by Th12; then
A3: the_Edges_of G = the_Edges_of G1 by GLIB_000:def 36;
A4: G1.ELabelSelector = the_ELabel_of G by GLIB_000:12;
    dom the_ELabel_of G c= the_Edges_of G by GLIB_003:6;
    hence thesis by A2,A1,A3,A4,GLIB_003:def 5;
  end;
end;

registration let G be WGraph, X be set;
  cluster G.set(V2LabelSelector, X) -> [Weighted]; coherence proof
    set G1 = G.set(V2LabelSelector,X);
A1: dom G c= dom G1 by GLIB_000:10;
A2: WeightSelector in dom G by GLIB_003:def 4;
A3: G == G1 by Th12;
A4: G1.WeightSelector = the_Weight_of G by GLIB_000:12;
    the_Edges_of G = the_Edges_of G1 by A3,GLIB_000:def 36;
    hence thesis by A2,A1,A4,GLIB_003:def 4;
  end;
end;

registration let G be V2Graph, X be set;
  cluster G.set(VLabelSelector, X) -> [V2Labeled]; coherence proof
    set G1 = G.set(VLabelSelector,X);
A1: dom G c= dom G1 by GLIB_000:10;
A2: V2LabelSelector in dom G by Def9;
A3: G == G1 by GLIB_003:8;
A4: the_Vertices_of G = the_Vertices_of G1 by A3,GLIB_000:def 36;
A5: G1.V2LabelSelector = the_V2Label_of G by GLIB_000:12;
    dom the_V2Label_of G c= the_Vertices_of G by Th11;
    hence thesis by A2,A1,A5,A4,Def9;
  end;
end;

registration let G be _Graph, Y be set, X be PartFunc of the_Vertices_of G,Y;
  cluster G.set(V2LabelSelector,  X) -> [V2Labeled]; coherence proof
    set G1 = G.set(V2LabelSelector,X);
A1: dom G1 = dom G \/ {V2LabelSelector} by GLIB_000:9;
    V2LabelSelector in {V2LabelSelector} by TARSKI:def 1;
    hence V2LabelSelector in dom G1 by A1,XBOOLE_0:def 2;
    G == G1 by Th12; then
A2: the_Vertices_of G = the_Vertices_of G1 by GLIB_000:def 36;
A3: G1.V2LabelSelector = X by GLIB_000:11;
    dom X c= the_Vertices_of G;
    hence thesis by A2, A3;
  end;
end;

registration let G be _Graph, X be ManySortedSet of the_Vertices_of G;
  cluster G.set(V2LabelSelector,  X) -> [V2Labeled]; coherence proof
    set G1 = G.set(V2LabelSelector,X);
A1: dom G1 = dom G \/ {V2LabelSelector} by GLIB_000:9;
    V2LabelSelector in {V2LabelSelector} by TARSKI:def 1;
    hence V2LabelSelector in dom G1 by A1,XBOOLE_0:def 2;
    G == G1 by Th12; then
A2: the_Vertices_of G = the_Vertices_of G1 by GLIB_000:def 36;
A3: G1.V2LabelSelector = X by GLIB_000:11;
    dom X = the_Vertices_of G by PBOOLE:def 3;
    hence thesis by A2, A3;
  end;
end;

registration let G be _Graph;
  cluster G.set(V2LabelSelector, {}) -> [V2Labeled]; coherence proof
    reconsider X ={} as PartFunc of the_Vertices_of G,{} by PARTFUN1:56;
    G.set(V2LabelSelector, X) is [V2Labeled];
    hence thesis;
  end;
end;

definition let G be V2Graph;
  attr G is natural-v2labeled means                                 :Def11:
    the_V2Label_of G is natural-yielding;
  attr G is finite-v2labeled means                                  :Def12:
    the_V2Label_of G is finite-yielding;
  attr G is natsubset-v2labeled means                               :Def13:
    the_V2Label_of G is natsubset-yielding;
end;

registration
  cluster finite natural-vlabeled finite-v2labeled natsubset-v2labeled chordal
          ([Weighted] [ELabeled] [VLabeled] [V2Labeled] _Graph);
  existence proof
    set V5 = {1}, E3 = {};
    consider S1 being Function of E3,V5;
    consider W1 being ManySortedSet of E3;
    consider EL8 being PartFunc of E3,REAL;
    consider VL6 being PartFunc of V5,REAL;
    reconsider FF = {} as Function;
    set G=<*V5*>^<*E3*>^<*S1*>^<*S1*>^<*W1*>^<*EL8*>^<*FF*>^<*FF*>;
A1: len G = 8 & G.1 = V5 & G.2 = E3 & G.3 = S1 & G.4 = S1 & G.5 = W1 &
      G.6 = EL8 & G.7 = FF & G.8 = FF by SCM_1:12; then
    dom G = Seg 8 by FINSEQ_1:def 3; then
    reconsider G as GraphStruct by GLIB_000:def 1;
    dom G = Seg 8 by A1, FINSEQ_1:def 3; then
A2: VertexSelector in dom G & EdgeSelector in dom G & SourceSelector in dom G &
    TargetSelector in dom G & WeightSelector in dom G &
    ELabelSelector in dom G & VLabelSelector in dom G &
    V2LabelSelector in dom G;
A3: the_Vertices_of G = V5 & the_Edges_of G = E3 & the_Source_of G = S1 &
    the_Target_of G = S1 & G.WeightSelector = W1 & G.ELabelSelector = EL8 &
      G.VLabelSelector = FF & G.V2LabelSelector = FF by SCM_1:12;
    dom EL8 c= E3 & dom VL6 c= V5 & dom FF c= V5 by XBOOLE_1:2, RELAT_1:60;
    then reconsider G as [Weighted] [ELabeled] [VLabeled] [V2Labeled] _Graph
      by A2,A3,GLIB_000:def 11,GLIB_003:def 4,
               GLIB_003:def 5,GLIB_003:def 6, Def9;
    take G;

   thus A4: G is finite by A3,GLIB_000:def 19;
    the_VLabel_of G is natural-yielding by SCM_1:12;
   hence G is natural-vlabeled by Def7;
A5: rng FF c= bool NAT by RELAT_1:60,XBOOLE_1:2;
    for x be set st x in rng FF holds x is finite by RELAT_1:60;
    then A6: the_V2Label_of G is finite-yielding &
         the_V2Label_of G is natsubset-yielding
         by A3, A5,Def3,Lm2;
   hence G is finite-v2labeled by Def12;
   thus G is natsubset-v2labeled by A6,Def13;
    reconsider x = 1 as Vertex of G by A3,TARSKI:def 1;
    the_Vertices_of G = {x} by SCM_1:12; then
    G.order() = 1 by A4,GLIB_000:30; then
    reconsider H=G as trivial _Graph by A4,GLIB_000:29;
    H is chordal;
   hence G is chordal;
  end;

  cluster finite natural-vlabeled natural-v2labeled chordal
          ([Weighted] [ELabeled] [VLabeled] [V2Labeled] _Graph);
  existence proof
    set V5 = {1}, E3 = {};
    consider S1 being Function of E3,V5;
    consider W1 being ManySortedSet of E3;
    consider EL8 being PartFunc of E3,REAL;
    consider VL6 being PartFunc of V5,REAL;
    reconsider FF = {} as Function;
    set G=<*V5*>^<*E3*>^<*S1*>^<*S1*>^<*W1*>^<*EL8*>^<*FF*>^<*FF*>;
A7: len G = 8 & G.1 = V5 & G.2 = E3 & G.3 = S1 & G.4 = S1 & G.5 = W1 &
      G.6 = EL8 & G.7 = FF & G.8 = FF by SCM_1:12; then
    dom G = Seg 8 by FINSEQ_1:def 3; then
    reconsider G as GraphStruct by GLIB_000:def 1;

    dom G = Seg 8 by A7, FINSEQ_1:def 3; then
A8: VertexSelector in dom G & EdgeSelector in dom G & SourceSelector in dom G &
    TargetSelector in dom G & WeightSelector in dom G &
    ELabelSelector in dom G & VLabelSelector in dom G &
    V2LabelSelector in dom G;
A9: the_Vertices_of G = V5 & the_Edges_of G = E3 & the_Source_of G = S1 &
    the_Target_of G = S1 & G.WeightSelector = W1 & G.ELabelSelector = EL8 &
      G.VLabelSelector = FF & G.V2LabelSelector = FF by SCM_1:12;
    dom EL8 c= E3 & dom VL6 c= V5 & dom FF c= V5 by XBOOLE_1:2, RELAT_1:60;
    then reconsider G as [Weighted] [ELabeled] [VLabeled] [V2Labeled] _Graph
      by A8,A9,GLIB_000:def 11,GLIB_003:def 4,
               GLIB_003:def 5,GLIB_003:def 6, Def9;
    take G;

   thus A10: G is finite by A9,GLIB_000:def 19;
    the_VLabel_of G is natural-yielding by SCM_1:12;
   hence G is natural-vlabeled by Def7;
    the_V2Label_of G is natural-yielding by SCM_1:12;
   hence G is natural-v2labeled by Def11;
    reconsider x = 1 as Vertex of G by A9,TARSKI:def 1;
    the_Vertices_of G = {x} by SCM_1:12; then
    G.order() = 1 by A10,GLIB_000:30; then
    reconsider H=G as trivial _Graph by A10,GLIB_000:29;
    H is chordal;
   hence G is chordal;
  end;
end;

registration let G be natural-vlabeled VGraph;
  cluster the_VLabel_of G -> natural-yielding;
  coherence by Def7;
end;

registration let G be natural-v2labeled V2Graph;
  cluster the_V2Label_of G -> natural-yielding;
  coherence by Def11;
end;

registration let G be finite-v2labeled V2Graph;
  cluster the_V2Label_of G -> finite-yielding;
  coherence by Def12;
end;

registration let G be natsubset-v2labeled V2Graph;
  cluster the_V2Label_of G -> natsubset-yielding;
  coherence by Def13;
end;

registration let G be VVGraph, v,x be set;
  cluster G.labelVertex(v,x) -> [V2Labeled];
  coherence proof
  per cases;
  suppose v in the_Vertices_of G; then
    G.labelVertex(v,x) = G.set(VLabelSelector, the_VLabel_of G +* (v.-->x))
      by GLIB_003:def 22;
    hence thesis; end;
  suppose not v in the_Vertices_of G;
    hence thesis by GLIB_003:def 22;
  end;
  end;
end;

theorem Th13:
for G being VVGraph, v,x being set
 holds the_V2Label_of G = the_V2Label_of G.labelVertex(v,x)
proof let G be VVGraph, v,x be set; set G2 = G.labelVertex(v,x);
  per cases;
  suppose v in the_Vertices_of G; then
  A1: G2 = G.set(VLabelSelector, the_VLabel_of G +* (v.-->x))
        by GLIB_003:def 22;
    thus the_V2Label_of G = the_V2Label_of G2 by A1, GLIB_000:12; end;
  suppose not v in the_Vertices_of G;
  hence thesis by GLIB_003:def 22; end;
end;

registration
  let G be natural-vlabeled VVGraph, v be set, x be natural number;
  cluster G.labelVertex(v,x) -> natural-vlabeled;
  coherence proof
    set GG = G.labelVertex(v,x);     set VLG = the_VLabel_of G;
    set VL = the_VLabel_of GG;       set f  = v.-->x;
A1: dom f = {v} & rng f = {x} by CQC_LANG:5;
    x in NAT by ORDINAL1:def 13; then
A2: rng f c= NAT by A1,ZFMISC_1:37;
A3: rng VLG c= NAT by SEQM_3:def 8;
    per cases;
    suppose v in the_Vertices_of G; then
      GG = G.set(VLabelSelector, VLG +* f) by GLIB_003:def 22; then
      GG.VLabelSelector = VLG +* f by GLIB_000:11; then
  A4: rng VL c= rng VLG \/ rng f by FUNCT_4:18;
      rng VLG \/ rng f c= NAT by A2,A3,XBOOLE_1:8; then
      rng VL c= NAT by A4,XBOOLE_1:1; then
      VL is natural-yielding by SEQM_3:def 8;
     hence thesis by Def7; end;
    suppose not v in the_Vertices_of G;
     hence thesis by GLIB_003:def 22; end;
  end;
end;

registration
  let G be natural-v2labeled VVGraph, v be set, x be natural number;
  cluster G.labelVertex(v,x) -> natural-v2labeled;
  coherence proof
    the_V2Label_of (G.labelVertex(v,x)) = the_V2Label_of G by Th13;
   hence thesis by Def11;
  end;
end;

registration
  let G be finite-v2labeled VVGraph, v be set, x be natural number;
  cluster G.labelVertex(v,x) -> finite-v2labeled;
  coherence proof
    the_V2Label_of (G.labelVertex(v,x)) = the_V2Label_of G by Th13;
   hence thesis by Def12;
  end;
end;

registration
  let G be natsubset-v2labeled VVGraph, v be set, x be natural number;
  cluster G.labelVertex(v,x) -> natsubset-v2labeled;
  coherence proof
    the_V2Label_of (G.labelVertex(v,x)) = the_V2Label_of G by Th13;
   hence thesis by Def13;
  end;
end;

:: Subgraphs and inheritence

registration let G be _Graph;
  cluster [VLabeled] [V2Labeled] Subgraph of G;
  existence proof
    consider V being PartFunc of the_Vertices_of G, REAL;
    set G2 = G.set(VLabelSelector, V);
    consider V2 being PartFunc of the_Vertices_of G2, REAL;
    set G3 = G2.set(V2LabelSelector, V2);
    G == G2 & G2 == G3 by GLIB_003:8,Th12; then
    G == G3 by GLIB_000:88; then
    G3 is Subgraph of G by GLIB_000:90;
    hence thesis;
  end;
end;

definition let G be V2Graph, G2 be [V2Labeled] Subgraph of G;
  attr G2 is v2label-inheriting means                          :Def14:
    the_V2Label_of G2 = (the_V2Label_of G) | the_Vertices_of G2;
end;

registration let G be V2Graph;
  cluster v2label-inheriting ([V2Labeled] Subgraph of G);
  existence proof
    reconsider H = G as [V2Labeled] Subgraph of G by GLIB_000:43;
    take H;
    dom the_V2Label_of G c= the_Vertices_of G by Th11; then
    the_V2Label_of H = (the_V2Label_of G) | the_Vertices_of G by RELAT_1:97;
    hence H is v2label-inheriting by Def14;
  end;
end;

definition let G be V2Graph;
  mode V2Subgraph of G is v2label-inheriting ([V2Labeled] Subgraph of G);
end;

registration let G be VVGraph;
  cluster vlabel-inheriting v2label-inheriting
          ([VLabeled] [V2Labeled] Subgraph of G);
  existence proof
    reconsider H = G as [VLabeled] [V2Labeled] Subgraph of G by GLIB_000:43;
    take H;
    dom the_VLabel_of G c= the_Vertices_of G by GLIB_003:7; then
    the_VLabel_of H = (the_VLabel_of G) | the_Vertices_of G by RELAT_1:97;
    hence H is vlabel-inheriting by GLIB_003:def 12;
    dom the_V2Label_of G c= the_Vertices_of G by Th11; then
    the_V2Label_of H = (the_V2Label_of G) | the_Vertices_of G by RELAT_1:97;
    hence H is v2label-inheriting by Def14;
  end;
end;

definition let G be VVGraph;
  mode VVSubgraph of G is vlabel-inheriting v2label-inheriting
                           ([VLabeled] [V2Labeled] Subgraph of G);
end;

registration let G be natural-vlabeled VGraph;
  cluster -> natural-vlabeled VSubgraph of G;
  coherence proof
    let H be VSubgraph of G;
A1: rng (the_VLabel_of G) c= NAT by SEQM_3:def 8;
    the_VLabel_of H = (the_VLabel_of G) | the_Vertices_of H
        by GLIB_003:def 12; then
    rng (the_VLabel_of H) c= rng (the_VLabel_of G) by RELAT_1:99; then
    rng (the_VLabel_of H) c= NAT by A1,XBOOLE_1:1; then
    the_VLabel_of H is natural-yielding by SEQM_3:def 8;
   hence thesis by Def7;
 end;
end;

registration
  let G be _Graph, V,E be set;
 cluster [Weighted] [ELabeled] [VLabeled] [V2Labeled] inducedSubgraph of G,V,E;
  existence proof
    now per cases;
    suppose
    A1: V is non empty Subset of the_Vertices_of G &
        E c= G.edgesBetween(V);
        consider X being inducedSubgraph of G,V,E;
        consider W being ManySortedSet of the_Edges_of X;
        set G2 = X.set(WeightSelector, W);
        consider EL being PartFunc of the_Edges_of G2, REAL;
        set G3 = G2.set(ELabelSelector, EL);
        consider VL being PartFunc of the_Vertices_of G3, REAL;
        set G4 = G3.set(VLabelSelector, VL);
        consider V2L being PartFunc of the_Vertices_of G4, REAL;
        set G5 = G4.set(V2LabelSelector, V2L);
    A2: X == G2 & G2 == G3 & G3 == G4 & G4 == G5 by GLIB_003:8,Th12; then
        X == G3 by GLIB_000:88; then
        X == G4 by A2,GLIB_000:88; then
    A3: X == G5 by A2,GLIB_000:88; then
        G5 is Subgraph of X by GLIB_000:90; then
        reconsider G5 as Subgraph of G by GLIB_000:46;
        the_Vertices_of X = V & the_Edges_of X = E by A1,GLIB_000:def 39; then
        the_Vertices_of G5 = V & the_Edges_of G5=E by A3,GLIB_000:def 36; then
        G5 is inducedSubgraph of G,V,E by A1,GLIB_000:def 39;
      hence thesis; end;
    suppose
    A4: not (V is non empty Subset of the_Vertices_of G &
        E c= G.edgesBetween(V));
        consider W being ManySortedSet of the_Edges_of G;
        set G2 = G.set(WeightSelector, W);
        consider EL being PartFunc of the_Edges_of G2, REAL;
        set G3 = G2.set(ELabelSelector, EL);
        consider VL being PartFunc of the_Vertices_of G3, REAL;
        set G4 = G3.set(VLabelSelector, VL);
        consider V2L being PartFunc of the_Vertices_of G4, REAL;
        set G5 = G4.set(V2LabelSelector, V2L);
    A5: G == G2 & G2 == G3 & G3 == G4 & G4 == G5 by GLIB_003:8,Th12; then
        G == G3 by GLIB_000:88; then
        G == G4 by A5, GLIB_000:88; then
    A6: G == G5 by A5, GLIB_000:88; then
        reconsider G5 as Subgraph of G by GLIB_000:90;
        G5 is inducedSubgraph of G,V,E by A4,A6,GLIB_000:def 39;
      hence thesis; end;
    end;
    hence thesis;
  end;
end;

registration
  let G be VVGraph, V, E being set;
  cluster vlabel-inheriting v2label-inheriting
     ([VLabeled] [V2Labeled] inducedSubgraph of G,V,E);
  existence proof
    now per cases;
    suppose
    A1: V is non empty Subset of the_Vertices_of G &
        E c= G.edgesBetween(V);
        consider X being [VLabeled] [V2Labeled] inducedSubgraph of G,V,E;
        set VL = (the_VLabel_of G) | the_Vertices_of X;
        reconsider VL'=VL as PartFunc of dom VL, rng VL by PARTFUN1:24;
        dom VL c= the_Vertices_of X by RELAT_1:87; then
        reconsider VL' as PartFunc of the_Vertices_of X, rng VL by PARTFUN1:28;
        set G1 = X.set(VLabelSelector, VL');
    A2: X == G1 by GLIB_003:8;
        set V2L = (the_V2Label_of G) | the_Vertices_of G1;
        reconsider V2L'=V2L as PartFunc of dom V2L, rng V2L by PARTFUN1:24;
        dom V2L c= the_Vertices_of G1 by RELAT_1:87; then
        reconsider V2L' as PartFunc of the_Vertices_of G1, rng V2L
          by PARTFUN1:28;
        set G2 = G1.set(V2LabelSelector, V2L');
    A3: G2 == G1 by Th12; then
    A4: G2 == X by A2, GLIB_000:88; then
        G2 is Subgraph of X by GLIB_000:90; then
        reconsider G2 as Subgraph of G by GLIB_000:46;
    A5: the_Vertices_of G2 = the_Vertices_of X by A4, GLIB_000:def 36
                          .= V by A1, GLIB_000:def 39;
        the_Edges_of G2 = the_Edges_of X by A4, GLIB_000:def 36
                       .= E by A1, GLIB_000:def 39; then
        reconsider G2 as [VLabeled] [V2Labeled] inducedSubgraph of G,V,E
          by A1,A5,GLIB_000:def 39;
        take G2;
        the_VLabel_of G2  = G1.VLabelSelector by GLIB_000:12
                         .= VL by GLIB_000:11
                         .= (the_VLabel_of G)|the_Vertices_of G2
                           by A4,GLIB_000:def 36;
        hence G2 is vlabel-inheriting by GLIB_003:def 12;
        the_V2Label_of G2 = V2L by GLIB_000:11
                         .= (the_V2Label_of G)|the_Vertices_of G2
                             by A3,GLIB_000:def 36;
        hence G2 is v2label-inheriting by Def14; end;
    suppose
    A6: not (V is non empty Subset of the_Vertices_of G &
        E c= G.edgesBetween(V));
        reconsider GG = G as Subgraph of G by GLIB_000:43;
        reconsider GG as [VLabeled] [V2Labeled] inducedSubgraph of G,V,E
          by A6,GLIB_000:def 39;
        take GG;
        dom the_VLabel_of G c= the_Vertices_of G by GLIB_003:7; then
        the_VLabel_of G = (the_VLabel_of G) | the_Vertices_of G by RELAT_1:97;
      hence GG is vlabel-inheriting by GLIB_003:def 12;
        dom the_V2Label_of G c= the_Vertices_of G by Th11; then
      the_V2Label_of G = (the_V2Label_of G) | the_Vertices_of G by RELAT_1:97;
      hence GG is v2label-inheriting by Def14; end;
    end;
    hence thesis;
  end;
end;

definition let G be VVGraph, V,E be set;
  mode inducedVVSubgraph of G,V,E is vlabel-inheriting v2label-inheriting
       ([VLabeled] [V2Labeled] inducedSubgraph of G,V,E);
end;

definition let G be VVGraph, V be set;
  mode inducedVVSubgraph of G,V is inducedVVSubgraph of G,V,G.edgesBetween(V);
end;

begin :: More on Graph Sequences

:::::::::::::: this should go into glib
definition let s be ManySortedSet of NAT;
  attr s is iterative means                 :Def15: ::dGSITERATIVE:
    for k, n being natural number st s.k = s.n holds s.(k+1) = s.(n+1);
end;

definition let GS be ManySortedSet of NAT;
  attr GS is eventually-constant means          :Def16:
    ex n being natural number
     st for m being natural number st n <= m holds GS.n = GS.m;
end;

registration
  cluster halting iterative eventually-constant ManySortedSet of NAT;
  existence proof
    set Fa = NAT --> 1;
    reconsider F=Fa as ManySortedSet of NAT;
    take F;
A1: F.0 = 1 by FUNCOP_1:13;
    F.0 = F.(0+1) by A1,FUNCOP_1:13;
  hence F is halting by GLIB_000:def 56;
    now let n,k be natural number such that F.n = F.k;
        n+1 in NAT & k+1 in NAT by ORDINAL1:def 13; then
        F.(n+1) = 1 & F.(k+1) = 1 by FUNCOP_1:13;
      hence F.(n+1) = F.(k+1);
    end;
  hence F is iterative by Def15;
    now let n be natural number such that 0 <= n;
        n in NAT by ORDINAL1:def 13; then
        F.0 = 1 & F.n = 1 by FUNCOP_1:13;
      hence F.0 = F.n;
    end;
  hence F is eventually-constant by Def16;
  end;
end;

theorem Th14:
for Gs being ManySortedSet of NAT
  st Gs is halting & Gs is iterative holds Gs is eventually-constant
proof let Gs be ManySortedSet of NAT such that
A1: Gs is halting & Gs is iterative;
    set GL = Gs.Lifespan();
    defpred P[Nat] means Gs.GL = Gs.(GL+$1);
A2: P[0];
A3: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A4: P[k];
        Gs.(GL+1) = Gs.(GL+k+1) by A4,A1,Def15;
      hence P[k+1] by A1,GLIB_000:def 57;
    end;
A5: for k being Nat holds P[k] from NAT_1:sch 2(A2,A3);
    now let n be natural number such that A6: GL <= n;
      ex i being Nat st GL + i = n by A6,NAT_1:28;
     hence Gs.GL = Gs.n by A5;
    end;
  hence Gs is eventually-constant by Def16;
end;

registration
  cluster halting iterative -> eventually-constant ManySortedSet of NAT;
  coherence by Th14;
end;

theorem Th15:
for Gs being ManySortedSet of NAT
  st Gs is eventually-constant holds Gs is halting
proof let Gs be ManySortedSet of NAT such that
A1: Gs is eventually-constant;
    consider n being natural number such that
A2: for m being natural number
      st n <= m holds Gs.n = Gs.m by A1,Def16;
    n <= n+1 by NAT_1:38; then
A3: Gs.n = Gs.(n+1) by A2;
    n in NAT by ORDINAL1:def 13;
  hence Gs is halting by A3,GLIB_000:def 56;
end;

registration
  cluster eventually-constant -> halting ManySortedSet of NAT;
  coherence by Th15;
end;

theorem Th16:
for Gs being iterative eventually-constant ManySortedSet of NAT
for n being natural number st Gs.Lifespan() <= n
  holds Gs.(Gs.Lifespan()) = Gs.n
proof let Gs be iterative eventually-constant ManySortedSet of NAT;
    set GL = Gs.Lifespan();
    let n be natural number such that A1: GL <= n;
    defpred P[Nat] means Gs.GL = Gs.(GL+$1);
A2: P[0];
A3: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A4: P[k];
        Gs.(GL+1) = Gs.(GL+k+1) by A4,Def15;
      hence P[k+1] by GLIB_000:def 57;
    end;
A5: for k being Nat holds P[k] from NAT_1:sch 2(A2,A3);
    ex i being Nat st GL + i = n by A1,NAT_1:28;
  hence  Gs.n = Gs.GL by A5;
end;

theorem Th17:
for Gs being iterative eventually-constant ManySortedSet of NAT
for n,m being natural number st Gs.Lifespan() <= n & n <= m
  holds Gs.m = Gs.n
proof let Gs be iterative eventually-constant ManySortedSet of NAT;
  let n,m be natural number such that
A1: Gs.Lifespan() <= n & n <= m;
    Gs.Lifespan() <= m by A1,XREAL_1:2; then
    Gs.(Gs.Lifespan()) = Gs.m by Th16;
  hence thesis by A1,Th16;
end;

definition let GS be VGraphSeq;
  attr GS is natural-vlabeled means                :Def17: ::dGSEQVNATVL:
    for x being natural number holds GS.x is natural-vlabeled;
end;

definition let GS be GraphSeq;
  attr GS is chordal means                        :Def18: ::dGSEQCHORDAL
    for x being natural number holds GS.x is chordal;
  attr GS is fixed-vertices means                       :Def19:
    for n,m being natural number holds
       (the_Vertices_of (GS.n)) = (the_Vertices_of (GS.m));
  attr GS is [V2Labeled] means                   :Def20: ::dGSEQV2LABEL
    for x being natural number holds GS.x is [V2Labeled];
end;

registration
  cluster [Weighted] [ELabeled] [VLabeled] [V2Labeled] GraphSeq;
  existence proof
    consider G being [Weighted] [ELabeled] [VLabeled] [V2Labeled] _Graph;
    set F = NAT --> G;
A1: dom F = NAT by FUNCOP_1:19;
    reconsider F as ManySortedSet of NAT;
    now let x be Element of NAT;
        F.x in rng F by A1, FUNCT_1:12; then
        F.x in {G} by FUNCOP_1:14;
        hence F.x is _Graph by TARSKI:def 1;
    end; then reconsider F as GraphSeq by GLIB_000:def 55;
    take F;
    now let x be Nat;
        x in NAT by ORDINAL1:def 13; then
        F.x in rng F by A1, FUNCT_1:12; then
        F.x in {G} by FUNCOP_1:14;
        hence F.x is [Weighted] & F.x is [ELabeled] &
              F.x is [VLabeled] & F.x is [V2Labeled] by TARSKI:def 1;
    end;
    hence F is [Weighted] & F is [ELabeled] &
          F is [VLabeled] & F is [V2Labeled]
      by GLIB_003:def 24, GLIB_003:def 25, GLIB_003:def 26,Def20;
  end;
end;

definition
  mode V2GraphSeq is [V2Labeled] GraphSeq;
  mode VVGraphSeq is [VLabeled] [V2Labeled] GraphSeq;
end;

registration let GSq be V2GraphSeq, x be natural number;
  cluster GSq.x -> [V2Labeled] _Graph;
  coherence by Def20;
end;

definition let GSq be V2GraphSeq;
   attr GSq is natural-v2labeled means              :Def21: ::dGSEQNATV2L
     for x being natural number holds GSq.x is natural-v2labeled;
   attr GSq is finite-v2labeled means     :Def22: ::dGSEQNATSUB
     for x being natural number holds GSq.x is finite-v2labeled;
   attr GSq is natsubset-v2labeled means     :Def23: ::dGSEQNATSUB
     for x being natural number holds GSq.x is natsubset-v2labeled;

end;

registration
  cluster finite natural-vlabeled finite-v2labeled natsubset-v2labeled chordal
          ([Weighted] [ELabeled] [VLabeled] [V2Labeled] GraphSeq);
  existence proof
    consider G being finite natural-vlabeled
             finite-v2labeled natsubset-v2labeled chordal
            ([Weighted] [ELabeled] [VLabeled] [V2Labeled] _Graph);
    set F = NAT --> G;
A1: dom F = NAT by FUNCOP_1:19;
    reconsider F as ManySortedSet of NAT;
    now let x be Element of NAT;
        F.x in rng F by A1, FUNCT_1:12; then
        F.x in {G} by FUNCOP_1:14;
        hence F.x is _Graph by TARSKI:def 1;
    end; then reconsider F as GraphSeq by GLIB_000:def 55;
    now let x be Nat;
        x in NAT by ORDINAL1:def 13; then
        F.x in rng F by A1, FUNCT_1:12; then
        F.x in {G} by FUNCOP_1:14;
        hence F.x is [Weighted] & F.x is [ELabeled] &
              F.x is [VLabeled] & F.x is [V2Labeled] by TARSKI:def 1;
    end;
    then reconsider F as [Weighted] [ELabeled] [VLabeled] [V2Labeled] GraphSeq
    by GLIB_003:def 24, GLIB_003:def 25, GLIB_003:def 26,Def20;
    take F;
    now let x be Nat;
      x in NAT by ORDINAL1:def 13; then
      F.x in rng F by A1,FUNCT_1:12; then
      F.x in {G} by FUNCOP_1:14;
      hence F.x is finite & F.x is natural-vlabeled &
       F.x is finite-v2labeled &
       F.x is natsubset-v2labeled &
       F.x is chordal by TARSKI:def 1;
    end;
    hence F is finite & F is natural-vlabeled &
          F is finite-v2labeled &
          F is natsubset-v2labeled & F is chordal
      by GLIB_000:def 60, Def17, Def23, Def18, Def22;
  end;

  cluster finite natural-vlabeled natural-v2labeled chordal
          ([Weighted] [ELabeled] [VLabeled] [V2Labeled] GraphSeq);
  existence proof
    consider G being finite natural-vlabeled natural-v2labeled chordal
          ([Weighted] [ELabeled] [VLabeled] [V2Labeled] _Graph);
    set F = NAT --> G;
A2: dom F = NAT by FUNCOP_1:19;
    reconsider F as ManySortedSet of NAT;
    now let x be Element of NAT;
        F.x in rng F by A2, FUNCT_1:12; then
        F.x in {G} by FUNCOP_1:14;
        hence F.x is _Graph by TARSKI:def 1;
    end; then reconsider F as GraphSeq by GLIB_000:def 55;
    now let x be Nat;
        x in NAT by ORDINAL1:def 13; then
        F.x in rng F by A2, FUNCT_1:12; then
        F.x in {G} by FUNCOP_1:14;
        hence F.x is [Weighted] & F.x is [ELabeled] &
              F.x is [VLabeled] & F.x is [V2Labeled] by TARSKI:def 1;
    end;
   then reconsider F as [Weighted] [ELabeled] [VLabeled] [V2Labeled] GraphSeq
   by GLIB_003:def 24, GLIB_003:def 25, GLIB_003:def 26,Def20;
    take F;
    now let x be Nat;
        x in NAT by ORDINAL1:def 13; then
      F.x in rng F by A2,FUNCT_1:12; then
      F.x in {G} by FUNCOP_1:14;
      hence F.x is finite & F.x is natural-vlabeled &
            F.x is natural-v2labeled & F.x is chordal by TARSKI:def 1;
    end;
    hence F is finite & F is natural-vlabeled &
          F is natural-v2labeled & F is chordal
      by GLIB_000:def 60, Def17, Def21, Def18;
  end;
end;

definition let Gs be VGraphSeq, x be natural number;
  redefine func Gs.x -> VGraph;
  coherence by GLIB_003:def 26;
end;

registration let GSq be natural-vlabeled VGraphSeq, x be natural number;
  cluster GSq.x -> natural-vlabeled VGraph;
  coherence by Def17;
end;

registration let GSq be natural-v2labeled V2GraphSeq, x be natural number;
  cluster GSq.x -> natural-v2labeled V2Graph;
  coherence by Def21;
end;

registration
  let GSq be finite-v2labeled V2GraphSeq, x be natural number;
  cluster GSq.x -> finite-v2labeled V2Graph;
  coherence by Def22;
end;

registration
  let GSq be natsubset-v2labeled V2GraphSeq, x be natural number;
  cluster GSq.x -> natsubset-v2labeled V2Graph;
  coherence by Def23;
end;

registration let GSq be chordal GraphSeq, x be natural number;
  cluster GSq.x -> chordal _Graph;
  coherence by Def18;
end;

definition let Gs be VGraphSeq, n being natural number;
  redefine func Gs.n -> VGraph;
  coherence proof
   thus Gs.n is VGraph;
  end;
end;

registration let Gs be finite VGraphSeq, n be natural number;
  cluster Gs.n -> finite VGraph;
  coherence by GLIB_000:def 60;
end;


definition let Gs be VVGraphSeq, n being natural number;
  redefine func Gs.n -> VVGraph;
  coherence proof
   thus Gs.n is VVGraph by Def20;
  end;
end;

registration let Gs be finite VVGraphSeq, n be natural number;
  cluster Gs.n -> finite VVGraph;
  coherence by GLIB_000:def 60;
end;

registration let Gs be chordal VVGraphSeq, n be natural number;
  cluster Gs.n -> chordal VVGraph;
  coherence by Def18;
end;

registration let Gs be natural-vlabeled VVGraphSeq, n be natural number;
  cluster Gs.n -> natural-vlabeled VVGraph;
  coherence by Def17;
end;

registration let Gs be finite-v2labeled VVGraphSeq,
                 n be natural number;
  cluster Gs.n -> finite-v2labeled VVGraph;
  coherence by Def22;
end;

registration let Gs be natsubset-v2labeled VVGraphSeq,
                 n be natural number;
  cluster Gs.n -> natsubset-v2labeled VVGraph;
  coherence by Def23;
end;

registration let Gs be natural-v2labeled VVGraphSeq, n be natural number;
  cluster Gs.n -> natural-v2labeled VVGraph;
  coherence by Def21;
end;

begin :: Vertices numbering sequences

definition let GS be VGraphSeq;

  attr GS is vlabel-initially-empty means  :Def24: ::dVLINITEMPTY
    the_VLabel_of (GS.0) = {};

  attr GS is adds-one-at-a-step means :Def25: ::dVLNUMBERSONE
    for n being natural number st n < GS.Lifespan() holds
     (ex w being set st not w in dom (the_VLabel_of (GS.n)) &
       the_VLabel_of (GS.(n+1)) =
       (the_VLabel_of (GS.n)) +* (w .--> (GS.Lifespan()-'n)));
end;

definition let GS be VGraphSeq;
  attr GS is vlabel-numbering means                          :Def26:
  GS is iterative
        eventually-constant
        finite
        fixed-vertices
        natural-vlabeled
        vlabel-initially-empty
        adds-one-at-a-step;
end;

Lm7:
ex GS being VGraphSeq st
   GS is iterative &
   GS is eventually-constant &
   GS is finite &
   GS is fixed-vertices &
   GS is natural-vlabeled & GS is vlabel-initially-empty &
   GS is adds-one-at-a-step
proof
  consider v being set, E being finite set, S,T being Function of E,{v};
  set Ga = createGraph({v}, E, S, T);

  set vl = v .--> 1;

A1: the_Vertices_of Ga = {v} by GLIB_000:8;

  dom vl = {v} & rng vl = {1} by CQC_LANG:5; then
  dom vl c= the_Vertices_of Ga & rng vl c= NAT by GLIB_000:8; then
  reconsider vl as PartFunc of the_Vertices_of Ga, NAT by RELSET_1:11;
  set Gb = Ga.set(VLabelSelector, vl);
  set G0 = Ga.set(VLabelSelector, {});
  set Fa = NAT --> Gb;
  set F = Fa +* (0 .--> G0);
A2: the_Vertices_of Gb = {v} & the_Vertices_of G0 = {v} by A1,GLIB_000:12;
A3: the_VLabel_of Gb = vl & the_VLabel_of G0 = {} by GLIB_000:11;
A4: Gb <> G0 by A3,CQC_LANG:5,RELAT_1:60;

    rng vl c= NAT; then
A5: the_VLabel_of Gb is natural-yielding by A3,SEQM_3:def 8;
A6: the_VLabel_of G0 is natural-yielding by GLIB_000:11;

A7: Gb is natural-vlabeled & G0 is natural-vlabeled by A5,A6,Def7;
  dom Fa = NAT by FUNCOP_1:19; then
  dom F = NAT \/ dom (0 .--> G0) by FUNCT_4:def 1; then
  dom F = NAT \/ {0} by CQC_LANG:5; then
  dom F = NAT by XBOOLE_1:12; then
  reconsider F as ManySortedSet of NAT by PBOOLE:def 3;

A8: dom (0 .--> G0) = {0} & 0 in {0} by TARSKI:def 1,CQC_LANG:5; then
A9: F.0 = (0 .--> G0).0 by FUNCT_4:14; then
A10: F.0 = G0 by CQC_LANG:6;
A11: for n being Nat st 1 <= n holds F.n = Gb proof
      let n be Nat such that A12: 1 <= n;
        not n in dom (0 .--> G0) by A12,A8,TARSKI:def 1; then
    A13: F.n = Fa.n by FUNCT_4:12;
        n in NAT by ORDINAL1:def 13;
      hence F.n = Gb by A13,FUNCOP_1:13;
    end;

A14: now let n be Nat;
      per cases;
      suppose n <= 0; then
        n = 0;
      hence F.n = G0 or F.n = Gb by A9,CQC_LANG:6; end;
      suppose n > 0; then n >= 0+1 by NAT_1:38;
      hence F.n = G0 or F.n = Gb by A11; end;
    end;
  for n being Element of NAT holds F.n is _Graph by A14; then
  reconsider F as GraphSeq by GLIB_000:def 55;
  for n being Nat holds F.n is [VLabeled] by A14; then
  reconsider F as VGraphSeq by GLIB_003:def 26;
  take F;
A15: now let n be Nat;
      per cases;
      suppose n <= 0; then n = 0;
      hence F.n = G0 or F.n = Gb by A9,CQC_LANG:6; end;
      suppose n > 0; then n >= 0+1 by NAT_1:38;
      hence F.n = G0 or F.n = Gb by A11; end;
    end;
A16: F.1 = Gb & F.2 = Gb by A11; then
A17: F.1 = F.(1+1); then
 A18: F is halting by GLIB_000:def 56;

    now let k,n be natural number such that A19: F.k = F.n;
      per cases;
      suppose k = 0; then
    A20: F.k = G0 by A9,CQC_LANG:6;
        0+1 <= k+1 by XREAL_1:9; then
    A21: F.(k+1) = Gb by A11;
        n < 1 by A11,A19,A20,A4;
        then n = 0 by NAT_1:39;
      hence F.(k+1) = F.(n+1) by A11,A21; end;
      suppose k > 0;
        k+1 >= 1+0 by XREAL_1:9; then
    A22: F.(k+1) = Gb by A11;
        n+1 >= 1+0 by XREAL_1:9;
      hence F.(k+1) = F.(n+1) by A11,A22; end;
    end;
    hence A23: F is iterative by Def15;

A24:now let n be Element of NAT such that A25: F.n = F.(n+1);
      assume n < 1; then n < 0+1; then
        0 <= n & n <= 0 by NAT_1:38; then
        n = 0;
      hence contradiction by A25,A10,A11,A4;
    end;

  thus F is eventually-constant by A18,A23,Th14;

    for n being Nat holds F.n is finite by A15;
  hence F is finite by GLIB_000:def 60;
    now let n,m be Nat;
        (the_Vertices_of (F.n)) = {v} by A2,A15;
      hence (the_Vertices_of (F.n)) = (the_Vertices_of (F.m)) by A2,A15;
    end;
  hence F is fixed-vertices by Def19;
    for n be Nat holds F.n is natural-vlabeled by A7,A15;
  hence F is natural-vlabeled by Def17;
    the_VLabel_of (F.0) = {} by GLIB_000:11,A10;
  hence F is vlabel-initially-empty by Def24;

    for n being Nat st n < F.Lifespan() holds
      (ex w being set st not w in dom (the_VLabel_of (F.n)) &
        the_VLabel_of (F.(n+1)) =
        (the_VLabel_of (F.n)) +* (w .--> (F.Lifespan()-'n))) proof
         let n be Nat such that A26: n < F.Lifespan();
         n < 0+1 by A24,A18,A17,GLIB_000:def 57,A26; then
         n <= 0 & 0 <= n by NAT_1:38; then
     A27: n = 0;
         take v;
     A28: F.Lifespan() - 0 = 1 - 0 by A24,A18,A17,GLIB_000:def 57;
         F.Lifespan() -' n = 1 by A27,A28,BINARITH:def 3;
       hence thesis by A3,A16,A27,A10,FUNCT_4:21,RELAT_1:60;
    end;
  hence thesis by Def25;
end;

registration
  cluster iterative eventually-constant finite
          fixed-vertices natural-vlabeled vlabel-initially-empty
          adds-one-at-a-step VGraphSeq;
  existence by Lm7;
end;

registration
  cluster vlabel-numbering VGraphSeq;
  existence proof
   consider GS being iterative eventually-constant finite
          fixed-vertices natural-vlabeled vlabel-initially-empty
          adds-one-at-a-step VGraphSeq;
   take GS;
   thus GS is vlabel-numbering by Def26;
  end;
end;

registration
  cluster vlabel-numbering -> iterative VGraphSeq;
  correctness by Def26;
  cluster vlabel-numbering -> eventually-constant VGraphSeq;
  correctness by Def26;
  cluster vlabel-numbering -> finite VGraphSeq;
  correctness by Def26;
  cluster vlabel-numbering -> fixed-vertices VGraphSeq;
  correctness by Def26;
  cluster vlabel-numbering -> natural-vlabeled VGraphSeq;
  correctness by Def26;
  cluster vlabel-numbering -> vlabel-initially-empty VGraphSeq;
  correctness by Def26;
  cluster vlabel-numbering -> adds-one-at-a-step VGraphSeq;
  correctness by Def26;
end;

definition
  mode VLabelNumberingSeq is vlabel-numbering VGraphSeq;
end;

definition let GS be VLabelNumberingSeq, n be natural number;
  func GS.PickedAt(n) -> set means                             :Def27:
    it = choose (the_Vertices_of (GS.0)) if n >= GS.Lifespan() otherwise
    not it in dom (the_VLabel_of (GS.n)) & the_VLabel_of (GS.(n+1)) =
        (the_VLabel_of (GS.n)) +* (it .--> (GS.Lifespan()-'n));
  existence proof
  per cases;
  suppose n >= GS.Lifespan();
    hence thesis; end;
  suppose n < GS.Lifespan(); then
    consider w being set such that
 A1: not w in dom (the_VLabel_of (GS.n)) and
 A2: the_VLabel_of (GS.(n+1)) =
    (the_VLabel_of (GS.n)) +* (w .--> (GS.Lifespan()-'n)) by Def25;
   thus thesis by A1,A2; end;
  end;
  uniqueness proof
    let IT1,IT2 be set;
    thus n >= GS.Lifespan() &
      IT1 = choose (the_Vertices_of (GS.0)) &
      IT2 = choose (the_Vertices_of (GS.0)) implies IT1 = IT2;
    set VLN = the_VLabel_of (GS.n);
    set VL1 = the_VLabel_of (GS.(n+1));
    assume n < GS.Lifespan();
    assume A3: not IT1 in dom VLN & VL1 = VLN +* (IT1 .--> (GS.Lifespan()-'n));
    assume A4: not IT2 in dom VLN & VL1 = VLN +* (IT2 .--> (GS.Lifespan()-'n));
    set f1 = IT1 .--> (GS.Lifespan()-'n);
    set f2 = IT2 .--> (GS.Lifespan()-'n);
 A5: dom f1 = {IT1} & rng f1 = {GS.Lifespan()-'n} by CQC_LANG:5;
 A6: dom f2 = {IT2} & rng f2 = {GS.Lifespan()-'n} by CQC_LANG:5;
 A7: dom VL1 = dom VLN \/ {IT1} by A3,A5,FUNCT_4:def 1;
 A8: dom VL1 = dom VLN \/ {IT2} by A4,A6,FUNCT_4:def 1;
    now assume IT1 <> IT2; then
        not IT1 in {IT2} by TARSKI:def 1; then
    A9: not IT1 in dom VL1 by A3,A8,XBOOLE_0:def 2;
        IT1 in {IT1} by TARSKI:def 1;
      hence contradiction by A9, A7,XBOOLE_0:def 2;
    end;
   hence IT1 = IT2;
  end;
  consistency;
end;

theorem Th18:
for GS being VLabelNumberingSeq,
    n being natural number st n < GS.Lifespan()
  holds GS.PickedAt(n) in (GS.(n+1)).labeledV() &
        (GS.(n+1)).labeledV() = (GS.n).labeledV() \/ {GS.PickedAt(n)}
proof let GS be VLabelNumberingSeq, n be Nat such that
A1: n < GS.Lifespan();
    set CSN = GS.n;     set VLN = the_VLabel_of CSN;
    set CN1 = GS.(n+1); set VN1 = the_VLabel_of CN1;
A2: VN1 = VLN +* (GS.PickedAt(n) .--> (GS.Lifespan() -' n)) by A1,Def27;
    set f = (GS.PickedAt(n)) .--> (GS.Lifespan() -' n);
A3: dom f = {GS.PickedAt(n)} & rng f = {GS.Lifespan()-'n} by CQC_LANG:5;then
A4: dom VN1 = dom VLN \/ {GS.PickedAt(n)} by A2,FUNCT_4:def 1;
    GS.PickedAt(n) in {GS.PickedAt(n)} by TARSKI:def 1;
  hence GS.PickedAt(n) in CN1.labeledV()
      by A4,XBOOLE_0:def 2;
  thus CN1.labeledV() = CSN.labeledV() \/ {GS.PickedAt(n)}
      by A3,A2,FUNCT_4:def 1;
end;

theorem Th19:
for GS being VLabelNumberingSeq, n
    being natural number st n < GS.Lifespan()
  holds (the_VLabel_of (GS.(n+1))).(GS.PickedAt(n)) = GS.Lifespan()-'n
proof let GS be VLabelNumberingSeq, n be Nat such that
A1: n < GS.Lifespan();
    set CSN = GS.n;     set VLN = the_VLabel_of CSN;
    set CN1 = GS.(n+1); set VN1 = the_VLabel_of CN1;
    set w = GS.PickedAt(n);
A2: VN1 = VLN +* (w .--> (GS.Lifespan() -' n)) by A1,Def27;
    set f  = w .--> (GS.Lifespan() -' n);
    dom f = {w} & rng f = {GS.Lifespan() -' n} by CQC_LANG:5; then
A3: w in dom f by TARSKI:def 1;
    f.w = GS.Lifespan() -' n by CQC_LANG:6;
  hence VN1.w = GS.Lifespan() -' n by A2,A3,FUNCT_4:14;
end;

theorem
for GS being VLabelNumberingSeq, n being natural number
 st n <= GS.Lifespan() holds card ((GS.n).labeledV()) = n
proof let GS be VLabelNumberingSeq, n be Nat such that
A1: n <= GS.Lifespan();
 defpred P[Nat] means
  $1 <= GS.Lifespan() implies card dom the_VLabel_of (GS.$1) = $1;
 A2: for k being Nat
     st k < GS.Lifespan() & card dom the_VLabel_of (GS.k) = k
      holds card dom the_VLabel_of (GS.(k+1)) = k+1
    proof let k be Nat such that
    A3: k < GS.Lifespan() & card dom the_VLabel_of (GS.k) = k;
        set CSK = GS.k;      set VLK = the_VLabel_of CSK;
        set CK1 = GS.(k+1);  set VK1 = the_VLabel_of CK1;
        set w = GS.PickedAt(k);
    A4: VK1 = VLK +* (w .--> (GS.Lifespan()-'k)) by A3,Def27;
        set wf  = w .--> (GS.Lifespan() -' k);
        dom wf = {w} & rng wf = {GS.Lifespan() -' k} by CQC_LANG:5; then
    A5: dom VK1 = dom VLK \/ {w} by A4,FUNCT_4:def 1;
        not w in dom VLK by A3,Def27;
      hence thesis by A3,A5,CARD_2:54;
    end;
A6: P[0] by CARD_1:78, RELAT_1:60, Def24;
A7: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A8: P[k];
      per cases;
      suppose k < GS.Lifespan();
        hence P[k+1] by A8,A2;
      end;
      suppose k >= GS.Lifespan();
        hence P[k+1] by NAT_1:38;
      end;
      end;
      for k being Nat holds P[k] from NAT_1:sch 2(A6,A7);
  hence card (GS.n).labeledV() = n by A1;
end;

theorem Th21:
for GS being VLabelNumberingSeq, n being natural number holds
  rng the_VLabel_of (GS.n) = (Seg GS.Lifespan()) \ Seg (GS.Lifespan()-'n)
proof let GS be VLabelNumberingSeq, n be Nat;
    set CSN = GS.n;             set VLN = the_VLabel_of CSN;
    set CSO = GS.GS.Lifespan(); set VLO = the_VLabel_of CSO;
    set GN = GS.Lifespan();
    defpred P[Nat] means $1 <= GN implies
     rng the_VLabel_of (GS.$1) = (Seg GN) \ Seg (GN-'$1);
A1: P[0] proof
        set CS0 = GS.0;   set VL0 = the_VLabel_of CS0;
    A2: rng VL0 = {} by RELAT_1:60, Def24;
        GN -' 0 = GN - 0 by BINARITH:50;
      hence P[0] by A2, XBOOLE_1:37;
    end;
A3: for k being Nat st P[k] holds P[k+1] proof
      let k be Nat such that A4: P[k];
      set CSK = GS.k;     set VLK = the_VLabel_of CSK;
      set CK1 = GS.(k+1); set VK1 = the_VLabel_of CK1;
      per cases;
      suppose k+1 <= GN; then
    A5: k < GN by NAT_1:38;
        set w = GS.PickedAt(k);
    A6: VK1 = VLK +* (w .--> (GN -' k)) by A5,Def27;
        set wf  = w .--> (GN -' k);
    A7: dom wf = {w} & rng wf = {GN -' k} by CQC_LANG:5;
        not w in dom VLK by A5, Def27; then
        dom wf misses dom VLK by A7,ZFMISC_1:56; then
        rng VK1 = rng VLK \/ {GN -' k} by A6,A7,NECKLACE:7;
        hence P[k+1] by A5,A4,Th7;
      end;
      suppose GN < k+1;
      hence P[k+1]; end;
    end;
A8: for k being Nat holds P[k] from NAT_1:sch 2(A1,A3);
  per cases;
  suppose n <= GN;
  hence rng VLN = (Seg GN) \ Seg (GN -' n) by A8; end;
  suppose A9: GN < n; then
    GN - n < n - n by XREAL_1:11; then
A10: GN -' n = 0 by BINARITH:def 3;
A11: GN -' GN = GN -' n by A10, BINARITH:51;
    CSO = CSN by A9,Th16;
  hence rng VLN = (Seg GN) \ Seg (GN -' n) by A11, A8; end;
end;

theorem Th22:
for GS being VLabelNumberingSeq, n being natural number, x being set
  holds (the_VLabel_of (GS.n)).x <= GS.Lifespan() &
        ((x in (GS.n).labeledV()) implies 1 <= (the_VLabel_of (GS.n)).x)
proof let GS be VLabelNumberingSeq, n be Nat, x be set;
  set CSN = GS.n;  set VLN = the_VLabel_of CSN;
A1:now per cases;
    suppose not x in dom VLN; then
      VLN.x = 0 by FUNCT_1:def 4;
    hence VLN.x <= GS.Lifespan(); end;
    suppose x in dom VLN; then
      VLN.x in rng VLN by FUNCT_1:def 5; then
      VLN.x in (Seg GS.Lifespan()) \ Seg (GS.Lifespan() -'n ) by Th21;
    hence VLN.x <= GS.Lifespan() by Th5; end;
  end;
  now assume x in (GS.n).labeledV(); then
      VLN.x in rng VLN by FUNCT_1:def 5; then
      VLN.x in (Seg GS.Lifespan()) \ Seg (GS.Lifespan() -'n ) by Th21; then
  A2: GS.Lifespan() -' n < VLN.x by Th5;
      0+1 <= VLN.x by A2,NAT_1:38;
    hence 1 <= VLN.x;
  end;
  hence thesis by A1;
end;

theorem Th23:
for GS being VLabelNumberingSeq, n,m being natural number
 st GS.Lifespan() -' n < m & m <= GS.Lifespan()
  ex v being Vertex of GS.n
   st v in (GS.n).labeledV() & (the_VLabel_of (GS.n)).v = m
proof let GS be VLabelNumberingSeq, n,m be Nat such that
A1: GS.Lifespan() -' n < m & m <= GS.Lifespan();
    set CSN = GS.n; set VLN = the_VLabel_of CSN;
    m in (Seg GS.Lifespan()) \ Seg (GS.Lifespan()-'n) by A1,Th5; then
    m in rng VLN by Th21; then
    consider v being set such that
A2: v in dom VLN and
A3: m = VLN.v by FUNCT_1:def 5;
    take v;
    dom VLN c= the_Vertices_of CSN by GLIB_003:7;
  hence v is Vertex of CSN by A2;
  thus v in CSN.labeledV() by A2;
  thus VLN.v = m by A3;
end;

theorem Th24:
for GS being VLabelNumberingSeq, m,n being natural number st m <= n
  holds the_VLabel_of (GS.m) c= the_VLabel_of (GS.n)
proof let GS be VLabelNumberingSeq, m,n be Nat such that A1: m <= n;
    set CSM = GS.m; set VLM = the_VLabel_of CSM;
    set CSN = GS.n; set VLN = the_VLabel_of CSN;
    defpred P[Nat] means VLM c= the_VLabel_of (GS.(m+$1));
 A2: now let k be Nat;
        set CSK = GS.k;     set VLK = the_VLabel_of CSK;
        set CK1 = GS.(k+1); set VK1 = the_VLabel_of CK1;
      per cases;
      suppose A3: k < GS.Lifespan();
        set w = GS.PickedAt(k);
    A4: VK1 = VLK +* (w .--> (GS.Lifespan()-'k)) by A3,Def27;
        set wf  = w .--> (GS.Lifespan() -' k);
    A5: dom wf = {w} & rng wf = {GS.Lifespan() -' k} by CQC_LANG:5;
        not w in dom VLK by A3,Def27; then
        dom wf misses dom VLK by A5,ZFMISC_1:56;
      hence VLK c= VK1 by A4,FUNCT_4:33; end;
      suppose A6: GS.Lifespan() <= k;
       k <= k+1 by NAT_1:38;
      hence VLK c= VK1 by A6,Th17; end;
    end;
A7: P[0];
A8: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A9: P[k];
        the_VLabel_of (GS.(m+k)) c=
        the_VLabel_of (GS.(m+k+1)) by A2;
      hence P[k+1] by A9,XBOOLE_1:1;
    end;
A10: for k being Nat holds P[k] from NAT_1:sch 2(A7,A8);
    ex j being Nat st n = m + j by A1,NAT_1:28;
  hence VLM c= VLN by A10;
end;

theorem Th25:
for GS being VLabelNumberingSeq, n being natural number
 holds the_VLabel_of (GS.n) is one-to-one
proof let GS be VLabelNumberingSeq, n be Nat;
    defpred P[Nat] means
      the_VLabel_of (GS.$1) is one-to-one;
A1: P[0] by Def24;
A2: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A3: P[k];
        set CSK = GS.k;     set VLK = the_VLabel_of CSK;
        set CK1 = GS.(k+1); set VL1 = the_VLabel_of CK1;
        set GN = GS.Lifespan();
        set w = GS.PickedAt(k);
      per cases;
      suppose k < GN; then
    A4: VL1 = VLK +* (w .--> (GN -' k)) by Def27;
        set wf  = w .--> (GN -' k);
    A5: dom wf = {w} & rng wf = {GN -' k} by CQC_LANG:5;
        now assume A6: GN -' k in rng VLK;
            rng VLK = (Seg GN) \ Seg (GN -' k) by Th21;
          hence contradiction by A6,Th5;
        end; then
    A7: rng wf misses rng VLK by A5,ZFMISC_1:56;
        now let x1,x2 be set such that
        A8: x1 in dom wf & x2 in dom wf and wf.x1 = wf.x2;
            x1 = w & x2 = w by A5,A8,TARSKI:def 1;
          hence x1 = x2;
        end; then
        wf is one-to-one by FUNCT_1:def 8;
      hence P[k+1] by A3, A4,A7,KNASTER:1;
    end;
      suppose A9: k >= GN;
        k <= k+1 by NAT_1:38;
        hence P[k+1] by Th17,A3, A9; end;
    end;
    for k being Nat holds P[k] from NAT_1:sch 2(A1,A2);
  hence thesis;
end;

theorem Th26:
for GS being VLabelNumberingSeq, m,n being natural number
for v being set st v in (GS.m).labeledV() & v in (GS.n).labeledV()
  holds (the_VLabel_of (GS.m)).v = (the_VLabel_of (GS.n)).v
proof let GS be VLabelNumberingSeq, m,n be Nat;
    let v be set such that
A1: v in (GS.m).labeledV() and
A2: v in (GS.n).labeledV();
    set VLM = the_VLabel_of (GS.m);    set VLN = the_VLabel_of (GS.n);
A3: [v,VLM.v] in VLM by A1,FUNCT_1:def 4;
A4: [v,VLN.v] in VLN by A2,FUNCT_1:def 4;
  per cases;
  suppose m <= n; then
    VLM c= VLN by Th24;
  hence VLM.v = VLN.v by A2,A3,FUNCT_1:def 4; end;
  suppose m > n; then
    VLN c= VLM by Th24;
  hence VLM.v = VLN.v by A1,A4,FUNCT_1:def 4; end;
end;

theorem Th27:
for GS being VLabelNumberingSeq, v being set, m,n being natural number
 st (v in (GS.m).labeledV() & (the_VLabel_of (GS.m)).v = n)
  holds GS.PickedAt(GS.Lifespan()-'n) = v
proof let GS be VLabelNumberingSeq, v be set, m,n be Nat;
    set CSM = GS.m;                set VLM = the_VLabel_of CSM;
    set j = GS.Lifespan() -' n;
    set CSJ = GS.j;     set VLJ = the_VLabel_of CSJ;
    set CJ1 = GS.(j+1); set VJ1 = the_VLabel_of CJ1;
    assume A1: v in CSM.labeledV() & VLM.v = n;
A2: 1 <= n & n <= GS.Lifespan() by A1,Th22;
A3: 0 < n by A1,Th22;
A4: GS.Lifespan() -' n = GS.Lifespan() - n by A2, BINARITH:50; then
A5: j < GS.Lifespan() by A3,XREAL_1:46;
    set w = GS.PickedAt(j);
A6: w in CJ1.labeledV() by A5,Th18;
    GS.Lifespan() -' j = GS.Lifespan() - (GS.Lifespan() - n)
    by A4, A5,BINARITH:50; then
A7: VJ1.w = n by A5,Th19;
A8: VLM is one-to-one by Th25;
  per cases;
  suppose A9: m <= j; then
    m + n <= GS.Lifespan() - n + n by A4, XREAL_1:8; then
A10: n + m - m <= GS.Lifespan() - m by XREAL_1:11;
    m <= GS.Lifespan() by A9,A5,XREAL_1:2; then
A11: GS.Lifespan() - m = GS.Lifespan() -' m by BINARITH:50;
A12: n in rng VLM by A1,FUNCT_1:def 5;
    rng VLM = (Seg GS.Lifespan()) \ Seg (GS.Lifespan() -' m) by Th21;
    hence v = GS.PickedAt(j) by A10, A11, A12,Th5;
  end;
  suppose j < m; then j+1 <= m by NAT_1:38; then
A13: VJ1 c= VLM by Th24; then
A14: dom VJ1 c= dom VLM by RELAT_1:25;
    [w,n] in VJ1 by A6,A7,FUNCT_1:def 4; then
    VLM.w = n by A13, A14,A6,FUNCT_1:def 4;
    hence v = GS.PickedAt(j) by A1,A14,A6,A8,FUNCT_1:def 8;
  end;
end;

theorem Th28:
for GS being VLabelNumberingSeq, m,n being natural number
 st n < GS.Lifespan() & n < m
   holds GS.PickedAt(n) in (GS.m).labeledV() &
         (the_VLabel_of (GS.m)).(GS.PickedAt(n)) = GS.Lifespan() -' n
proof let GS be VLabelNumberingSeq, m,n be Nat such that
A1: n < GS.Lifespan() and A2: n < m;
    set v = GS.PickedAt(n);
    set CN1 = GS.(n+1); set VN1 = the_VLabel_of CN1;
    set CSM = GS.m;     set VLM = the_VLabel_of CSM;
A3: v in CN1.labeledV() by A1,Th18;
A4: VN1.v = GS.Lifespan() -' n by A1,Th19;
    n+1 <= m by A2,NAT_1:38; then
    VN1 c= VLM by Th24; then
    dom VN1 c= dom VLM by RELAT_1:25;
  hence v in CSM.labeledV() by A3;
  hence VLM.v = GS.Lifespan() -' n by A3,A4,Th26;
end;

:: Inequalities relating the vlabel and the current iteration
theorem Th29:
for GS being VLabelNumberingSeq, m being natural number, v being set
  st v in (GS.m).labeledV()
   holds GS.Lifespan() -' (the_VLabel_of (GS.m)).v < m &
         GS.Lifespan() -' m < (the_VLabel_of (GS.m)).v
proof let GS be VLabelNumberingSeq, m be Nat, v be set;
    set CSM = GS.m; set VLM = the_VLabel_of (GS.m);
    set j = GS.Lifespan() -' VLM.v;
    set CSJ = GS.j; set VLJ = the_VLabel_of (GS.j);
    assume A1: v in CSM.labeledV(); then
A2: GS.PickedAt(j) = v by Th27;
A3: 1 <= VLM.v & VLM.v <= GS.Lifespan() by A1,Th22;
A4: 0 < VLM.v by A1,Th22;
    j = GS.Lifespan() - VLM.v by A3,BINARITH:50; then
A5: j < GS.Lifespan() by A4,XREAL_1:46;
A6: now per cases;
      suppose m <= j; then
        VLM c= VLJ by Th24; then
        dom VLM c= dom VLJ by RELAT_1:25;
      hence GS.Lifespan() -' VLM.v < m by A1,A5,A2,Def27; end;
      suppose m > j;
      hence GS.Lifespan() -' VLM.v < m; end;
    end;
    now per cases;
      suppose A7: GS.Lifespan() - m >= 0;
        GS.Lifespan() - VLM.v < m by A6, A3,BINARITH:50; then
        GS.Lifespan() - VLM.v + VLM.v < m + VLM.v by XREAL_1:8; then
        GS.Lifespan() - m  < VLM.v + m - m by XREAL_1:11;
      hence GS.Lifespan() -'m < VLM.v by A7,BINARITH:def 3; end;
      suppose GS.Lifespan() - m < 0;
      hence GS.Lifespan() -'m < VLM.v by A4, BINARITH:def 3;
    end;
    end;
  hence thesis by A6;
end;

:: If a vertex has a larger vlabel than we do at some point in the
:: algorithm, then it must have been in the vlabel when we were picked
theorem Th30:
for GS being VLabelNumberingSeq
for i being natural number, a,b being set
 st a in (GS.i).labeledV() & b in (GS.i).labeledV() &
    (the_VLabel_of (GS.i)).a < (the_VLabel_of (GS.i)).b
  holds b in (GS.(GS.Lifespan() -' (the_VLabel_of (GS.i)).a)).labeledV()
proof let GS be VLabelNumberingSeq;
    let i be Nat, a,b be set such that
A1: a in (GS.i).labeledV() and
A2: b in (GS.i).labeledV() and
A3: (the_VLabel_of (GS.i)).a < (the_VLabel_of (GS.i)).b;
    set CSI = GS.i; set VLI = the_VLabel_of CSI;
    set j = GS.Lifespan() -' VLI.a;
    set CSJ = GS.j; set VLJ = the_VLabel_of CSJ;    set GN = GS.Lifespan();
    VLI.a <= GN by Th22; then
A4: GN -' VLI.a = GN - VLI.a by BINARITH:50;
    GN -' VLI.a <= GN by BINARITH:52; then
A5: GN -' j = GN - (GN - VLI.a) by A4,BINARITH:50;
    VLI.b <= GN by Th22; then
    consider w being Vertex of CSJ such that
A6: w in CSJ.labeledV() and
A7: VLJ.w = VLI.b by A5,A3,Th23;
    now assume j >= i; then
        VLI c= VLJ by Th24; then
    A8: dom VLI c= dom VLJ by RELAT_1:25;
    A9: a = GS.PickedAt(j) by A1,Th27;
    A10: 0 < VLI.a by A1,Th22;
        j < GN by A10,A4, XREAL_1:46;
       hence contradiction by A8,A9,A1,Def27;
    end; then
A11: VLJ c= VLI by Th24;
    [w,VLI.b] in VLJ by A7,A6, FUNCT_1:8; then
A12:w in dom VLI & VLI.w = VLI.b by A11, FUNCT_1:8;
    VLI is one-to-one by Th25;
  hence b in CSJ.labeledV() by A6, A12,A2,FUNCT_1:def 8;
end;

theorem Th31:
for GS being VLabelNumberingSeq
for i being natural number, a,b being set
 st a in (GS.i).labeledV() & b in (GS.i).labeledV() &
    (the_VLabel_of (GS.i)).a < (the_VLabel_of (GS.i)).b
 holds not a in (GS.(GS.Lifespan() -' (the_VLabel_of (GS.i)).b)).labeledV()
proof let GS be VLabelNumberingSeq;
    let i be Nat, a,b be set such that
A1: a in (GS.i).labeledV() and b in (GS.i).labeledV() and
A2: (the_VLabel_of (GS.i)).a < (the_VLabel_of (GS.i)).b;
    set CSI = GS.i; set VLI = the_VLabel_of CSI;
    set GN = GS.Lifespan();    set k = GN -' VLI.a;    set j = GN -' VLI.b;
    set CSJ = GS.j; set VLJ = the_VLabel_of CSJ;
    set CSK = GS.k; set VLK = the_VLabel_of CSK;
    VLI.b <= GN by Th22; then
A3: j = GN - VLI.b by BINARITH:50;
    VLI.a <= GN by Th22; then
A4: k = GN - VLI.a by BINARITH:50;
    1 <= VLI.a by A1,Th22; then
A5: k < GN by A4,XREAL_1:46;
    assume
A6: a in CSJ.labeledV();
A7: GS.PickedAt(k) = a by A1,Th27;
    j < k by A3,A4,A2,XREAL_1:17; then
    VLJ c= VLK by Th24; then
    dom VLJ c= dom VLK by RELAT_1:25;
  hence contradiction by A7,Def27,A5,A6;
end;

begin :: Lexicographical Breadth-First Search

definition let G be _Graph;
  func LexBFS:Init(G) ->
                  natural-vlabeled finite-v2labeled natsubset-v2labeled
                  VVGraph equals
    G.set(VLabelSelector, {}).set(V2LabelSelector, the_Vertices_of G --> {});
  coherence proof
    set G1 = G.set(VLabelSelector, {});    set g  = the_Vertices_of G --> {};
A1: G1 == G by GLIB_003:8;
    dom g = the_Vertices_of G by FUNCOP_1:19; then
    dom g = the_Vertices_of G1 by A1,GLIB_000:def 36; then
    reconsider f = g as PartFunc of the_Vertices_of G1, rng g by PARTFUN1:24;
    set G2 = G1.set(V2LabelSelector, f);
A2: the_V2Label_of G2 = f by GLIB_000:11;
A3: the_VLabel_of G2 = the_VLabel_of G1 by GLIB_000:12;
A4: the_VLabel_of G2 is natural-yielding by A3,GLIB_000:11;
A5: rng the_V2Label_of G2 = {{}} by A2,FUNCOP_1:14;
    now let x be set such that A6: x in rng the_V2Label_of G2;
        x = {} by A5,A6,TARSKI:def 1; then
        x c= NAT by XBOOLE_1:2;
      hence x in bool NAT;
    end; then
A7: rng the_V2Label_of G2 is Subset of bool NAT by TARSKI:def 3;
    for x be set st x in rng the_V2Label_of G2 holds x is finite
      by A5,TARSKI:def 1;
    then the_V2Label_of G2 is finite-yielding &
         the_V2Label_of G2 is natsubset-yielding
         by A7,Def3,Lm2;
  hence thesis by Def7,A4,Def12,Def13;
 end;
end;

definition let G be finite _Graph;
  redefine func LexBFS:Init(G)
                -> finite natural-vlabeled
                   finite-v2labeled natsubset-v2labeled VVGraph;
  coherence;
end;

definition let G be finite finite-v2labeled natsubset-v2labeled VVGraph;
  assume A1: dom the_V2Label_of G = the_Vertices_of G;
  func LexBFS:PickUnnumbered(G) -> Vertex of G means :Def29:
  it = choose the_Vertices_of G if dom the_VLabel_of G = the_Vertices_of G
  otherwise
  ex S being non empty finite Subset of bool NAT,
     B being non empty finite Subset of Bags NAT,
     F being Function
  st S = rng F &
     F = ((the_V2Label_of G) | (the_Vertices_of G \ dom the_VLabel_of G)) &
     (for x being finite Subset of NAT holds x in S implies ((x,1)-bag in B)) &
     (for x being set holds x in B implies
            ex y being finite Subset of NAT st y in S & x = (y,1)-bag) &
   it = choose (F " {support max(B,InvLexOrder NAT)});
  existence proof
  set VLG = the_VLabel_of G;    set V2G = the_V2Label_of G;
  set VG = the_Vertices_of G;   set F = V2G | (VG \ dom VLG);  set S = rng F;
  per cases;
  suppose dom VLG = VG;
  hence thesis; end;
  suppose A2: dom VLG <> VG;
A3: dom F c= dom V2G & rng F c= rng V2G by RELAT_1:89,99;
A4: dom F c= the_Vertices_of G by A1,RELAT_1:89;
A5: dom VLG c= VG by GLIB_003:7;
    dom F = dom V2G /\ (VG \ dom VLG) by FUNCT_1:68; then
A6: dom F = (VG /\ VG) \ dom VLG by A1,XBOOLE_1:49;
A7:now assume dom F = {}; then
      VG c= dom VLG by A6,XBOOLE_1:37;
     hence contradiction by A2,A5,XBOOLE_0:def 10;
    end; then
A8: S is non empty by RELAT_1:65;
A9: now let x be set such that A10: x in S;
    A11: x in rng V2G by A3,A10;
        rng V2G c= bool NAT by Def3;
        hence x in bool NAT by A11;
        thus x is finite by A10,Lm3;
    end; then
A12: for x being set holds x in S implies x in bool NAT;
A13: for x being Element of S holds x is finite by Lm3,A8;
    dom F is finite by A4,FINSET_1:13; then
    reconsider S as non empty finite with_finite-elements Subset of bool NAT
       by A7,RELAT_1:65,A12,TARSKI:def 3,A13,Def1,FINSET_1:26;
    deffunc A() = S;
    deffunc F(finite Subset of NAT) = ($1,1)-bag;
    deffunc W() = S;
A14: W() is finite;
    set B = {F(x) where x is Element of A(): x in W()};
A15: B is finite from FRAENKEL:sch 21(A14);
    consider z being set such that
A16: z in S by XBOOLE_0:def 1;
    reconsider z as finite Subset of NAT by A16,A9;
A17: (z,1)-bag in B by A16;
A18: now let x be set such that A19: x in B;
        consider y being Element of S such that
    A20: x = (y,1)-bag & y in S by A19;
      thus x in Bags NAT by A20;
    end;
    reconsider B as non empty finite Subset of Bags NAT
       by A17, A18, A15, TARSKI:def 3;
A21: for x being finite Subset of NAT holds x in S implies ((x,1)-bag in B);
A22: for x being set holds x in B implies
      ex y being finite Subset of NAT st y in S & x = (y,1)-bag proof
      let x be set such that A23: x in B;
      consider y being Element of S such that
    A24: x = (y,1)-bag & y in S by A23;
      thus thesis by A24;
    end;
    set mw = max(B,InvLexOrder NAT);    set IT = choose (F " {support mw});
    mw in B by Def5; then
    consider y being finite Subset of NAT such that
A25: y in S & mw = (y,1)-bag by A22;
A26: y = support mw by A25,UPROOTS:10;
A27: F " {support mw} is non empty by A25,A26,FUNCT_1:142;
    IT in dom F by A27,FUNCT_1:def 13; then
    reconsider IT as Vertex of G by A4;
   ex S being non empty finite Subset of bool NAT,
      B being non empty finite Subset of Bags NAT,
      F being Function
   st S = rng F &
      F = ((the_V2Label_of G) | (the_Vertices_of G \ dom the_VLabel_of G)) &
     (for x being finite Subset of NAT holds x in S implies ((x,1)-bag in B)) &
      (for x being set holds x in B implies
             ex y being finite Subset of NAT st y in S & x = (y,1)-bag) &
    IT = choose (F " {support max(B,InvLexOrder NAT)})
    & IT is Vertex of G by A21,A22;
     hence thesis; end;
  end;
  uniqueness proof
    set VLG = the_VLabel_of G;    set V2G = the_V2Label_of G;
    set VG = the_Vertices_of G;
    let IT1, IT2 be Vertex of G;
    thus dom VLG = VG & IT1 = choose VG & IT2 = choose VG implies IT1=IT2;
    assume dom VLG <> VG;
    assume
    ex S1 being non empty finite Subset of bool NAT,
     B1 being non empty finite Subset of Bags NAT,
     F1 being Function  st S1 = rng F1 & F1 = (V2G | (VG \ dom VLG)) &
   (for x being finite Subset of NAT holds x in S1 implies ((x,1)-bag in B1)) &
    (for x being set holds x in B1 implies
            ex y being finite Subset of NAT st y in S1 & x = (y,1)-bag) &
    IT1 = choose (F1 " {support max(B1,InvLexOrder NAT)}); then
    consider S1 being non empty finite Subset of bool NAT,
             B1 being non empty finite Subset of Bags NAT,
             F1 being Function such that
A28: S1 = rng F1 & F1 = (V2G | (VG \ dom VLG)) &
   (for x being finite Subset of NAT holds x in S1 implies ((x,1)-bag in B1)) &
   (for x being set holds x in B1 implies
            ex y being finite Subset of NAT st y in S1 & x = (y,1)-bag) &
    IT1 = choose (F1 " {support max(B1,InvLexOrder NAT)});
    assume
    ex S2 being non empty finite Subset of bool NAT,
     B2 being non empty finite Subset of Bags NAT,
     F2 being Function  st S2 = rng F2 &
     F2 = (V2G | (VG \ dom VLG)) &
   (for x being finite Subset of NAT holds x in S2 implies ((x,1)-bag in B2)) &
   (for x being set holds x in B2 implies
            ex y being finite Subset of NAT st y in S2 & x = (y,1)-bag) &
    IT2 = choose (F2 " {support max(B2,InvLexOrder NAT)}); then
    consider S2 being non empty finite Subset of bool NAT,
             B2 being non empty finite Subset of Bags NAT,
             F2 being Function such that
A29: S2 = rng F2 & F2 = (V2G | (VG \ dom VLG)) &
   (for x being finite Subset of NAT holds x in S2 implies ((x,1)-bag in B2)) &
   (for x being set holds x in B2 implies
            ex y being finite Subset of NAT st y in S2 & x = (y,1)-bag) &
    IT2 = choose (F2 " {support max(B2,InvLexOrder NAT)});
    now let x be set such that A30: x in B1;
      ex y being finite Subset of NAT st y in S1 & x = (y,1)-bag by A28,A30;
     hence x in B2 by A28,A29;
    end; then
A31:  B1 c= B2 by TARSKI:def 3;
    now let x be set such that A32: x in B2;
      ex y being finite Subset of NAT st y in S2 & x = (y,1)-bag by A29,A32;
     hence x in B1 by A28,A29;
    end; then B2 c= B1 by TARSKI:def 3;
    hence IT1 = IT2 by A28,A29,A31,XBOOLE_0:def 10;
  end;
  consistency;
end;

definition let G be VVGraph, v be set, k be natural number;
 func LexBFS:LabelAdjacent(G, v, k) -> VVGraph equals
 G.set(V2LabelSelector, (the_V2Label_of G) .\/
                        ((G.AdjacentSet({v}) \ dom the_VLabel_of G)-->{k}));
  coherence proof
    set VLG = the_VLabel_of G;
    set f = (G.AdjacentSet({v}) \ dom VLG) --> {k};
    set H = G.set(V2LabelSelector, (the_V2Label_of G) .\/ f);
    set F = (the_V2Label_of G) .\/ f;
A1: dom the_V2Label_of G c= the_Vertices_of G by Th11;
A2: G.AdjacentSet({v}) \ dom VLG c= the_Vertices_of G;
A3: dom f c= the_Vertices_of G by A2, FUNCOP_1:19;
    dom F = dom the_V2Label_of G \/ dom f by Def2; then
A4: dom F c= the_Vertices_of G by A1,A3,XBOOLE_1:8;
    F is PartFunc of dom F, rng F by PARTFUN1:24; then
    reconsider g = F as PartFunc of the_Vertices_of G, rng F by A4,PARTFUN1:28;
    G.set(V2LabelSelector, g) is [V2Labeled];
   hence thesis;
 end;
end;

theorem Th32:
for G being VVGraph, v,x being set, k being natural number
 st not x in G.AdjacentSet({v})
  holds (the_V2Label_of G).x = (the_V2Label_of LexBFS:LabelAdjacent(G,v,k)).x
proof let G be VVGraph, v,x be set, k be Nat such that
A1: not x in G.AdjacentSet({v});
    set GL = LexBFS:LabelAdjacent(G,v,k);     set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;                set V2G = the_V2Label_of G;
    set f = (G.AdjacentSet({v}) \ dom VLG) -->{k};
    dom f = G.AdjacentSet({v}) \ dom VLG by FUNCOP_1:19; then
A2: not x in dom f by A1,XBOOLE_0:def 4; then
A3: f.x = {} by FUNCT_1:def 4;
A4: V2 = V2G .\/ f by GLIB_000:11;
  per cases;
  suppose x in dom V2G; then
    x in dom V2G \/ dom f by XBOOLE_0:def 2; then
    V2.x = V2G.x \/ {} by A3,A4,Def2;
  hence V2.x = V2G.x; end;
  suppose A5: not x in dom V2G; then
A6: V2G.x = {} by FUNCT_1:def 4;
    not x in dom V2G \/ dom f by A2,A5,XBOOLE_0:def 2; then
    not x in dom V2 by A4,Def2;
  hence V2.x = V2G.x by A6, FUNCT_1:def 4; end;
end;

theorem Th33:
for G being VVGraph, v,x being set, k being natural number
 st x in dom (the_VLabel_of G) holds
   (the_V2Label_of G).x = (the_V2Label_of LexBFS:LabelAdjacent(G,v,k)).x
proof let G be VVGraph, v,x be set, k be Nat such that
A1: x in dom (the_VLabel_of G);
    set GL = LexBFS:LabelAdjacent(G,v,k);    set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;               set V2G = the_V2Label_of G;
    set f = (G.AdjacentSet({v}) \ dom VLG) -->{k};
    dom f = G.AdjacentSet({v}) \ dom VLG by FUNCOP_1:19; then
A2: not x in dom f by A1,XBOOLE_0:def 4; then
A3: f.x = {} by FUNCT_1:def 4;
A4: V2 = V2G .\/ f by GLIB_000:11;
  per cases;
  suppose x in dom V2G; then
    x in dom V2G \/ dom f by XBOOLE_0:def 2; then
    V2.x = V2G.x \/ {} by A3,A4,Def2;
  hence V2.x = V2G.x; end;
  suppose A5: not x in dom V2G; then
A6: V2G.x = {} by FUNCT_1:def 4;
    not x in dom V2G \/ dom f by A2,A5,XBOOLE_0:def 2; then
    not x in dom V2 by A4,Def2;
  hence V2.x = V2G.x by A6, FUNCT_1:def 4; end;
end;

theorem Th34:
for G being VVGraph, v,x being set, k being natural number
 st x in G.AdjacentSet({v}) & not x in dom (the_VLabel_of G)
  holds (the_V2Label_of LexBFS:LabelAdjacent(G,v,k)).x =
        (the_V2Label_of G).x \/ {k}
proof let G be VVGraph, v,x be set, k be Nat such that
A1: x in G.AdjacentSet({v}) and
A2: not x in dom (the_VLabel_of G);
    set GL = LexBFS:LabelAdjacent(G,v,k);    set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;    set V2G = the_V2Label_of G;
    set f = (G.AdjacentSet({v}) \ dom VLG) -->{k};
A3: dom f = G.AdjacentSet({v}) \ dom VLG by FUNCOP_1:19; then
A4: x in dom f by A1,A2,XBOOLE_0:def 4; then
A5: f.x = {k} by A3,FUNCOP_1:13;
A6: V2 = V2G .\/ f by GLIB_000:11;
    x in dom V2G \/ dom f by A4,XBOOLE_0:def 2;
  hence V2.x = V2G.x \/ {k} by A5,A6,Def2;
end;

theorem Th35:
for G being VVGraph, v being set, k being natural number
 st dom (the_V2Label_of G) = the_Vertices_of G
  holds dom (the_V2Label_of LexBFS:LabelAdjacent(G,v,k)) = the_Vertices_of G
proof let G be VVGraph, v be set, k be Nat such that
A1: dom (the_V2Label_of G) = the_Vertices_of G;
    set GL = LexBFS:LabelAdjacent(G,v,k);    set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;    set V2G = the_V2Label_of G;
    set f = (G.AdjacentSet({v}) \ dom VLG) -->{k};
A2: G.AdjacentSet({v}) \ dom VLG c= the_Vertices_of G;
A3: dom f c= the_Vertices_of G by A2, FUNCOP_1:19;
    V2 = V2G .\/ f by GLIB_000:11; then
    dom V2 = dom V2G \/ dom f by Def2;
  hence dom V2 = the_Vertices_of G by A1,A3,XBOOLE_1:12;
end;

definition let G be finite natural-vlabeled finite-v2labeled
                    natsubset-v2labeled VVGraph,
               v be Vertex of G, k be natural number;
  redefine func LexBFS:LabelAdjacent(G, v, k) ->
                    finite natural-vlabeled
                    finite-v2labeled natsubset-v2labeled VVGraph;
  coherence proof
    set IT = LexBFS:LabelAdjacent(G, v, k);
    set VL = the_VLabel_of IT;    set V2 = the_V2Label_of IT;
    set VLG = the_VLabel_of G;    set V2G = the_V2Label_of G;
A1: the_VLabel_of IT = the_VLabel_of G by GLIB_000:12;
    now let x be set such that A2: x in rng V2;
        consider y being set such that
        y in dom V2 and
    A3: V2.y = x by A2, FUNCT_1:def 5;
        per cases;
        suppose A4: not y in G.AdjacentSet({v}) or y in dom VLG;
        now per cases by A4;
            suppose not y in G.AdjacentSet({v});
              hence V2.y = V2G.y by Th32; end;
            suppose y in dom VLG;
              hence V2.y = V2G.y by Th33; end;
          end;
          hence x in bool NAT by A3;
        end;
        suppose y in G.AdjacentSet({v}) & not y in dom VLG; then
       A5: V2.y = V2G.y \/ {k} by Th34;
           k in NAT by ORDINAL1:def 13; then
       A6: {k} c= NAT by ZFMISC_1:37;
           per cases;
           suppose not y in dom V2G; then
             V2G.y = {} by FUNCT_1:def 4;
             hence x in bool NAT by A3,A5,A6; end;
           suppose y in dom V2G;
             V2.y c= NAT by A5,A6,XBOOLE_1:8;
            hence x in bool NAT by A3; end;
        end;
    end; then
A7: rng V2 is Subset of bool NAT by TARSKI:def 3;
    now let x be set such that A8: x in rng V2;
        consider y being set such that
         y in dom V2 and
    A9: V2.y = x by A8, FUNCT_1:def 5;
        per cases;
        suppose A10: not y in G.AdjacentSet({v}) or y in dom VLG;
        now per cases by A10;
            suppose not y in G.AdjacentSet({v});
              hence V2.y = V2G.y by Th32; end;
            suppose y in dom VLG;
              hence V2.y = V2G.y by Th33; end;
          end;
          hence x is finite by A9;
        end;
        suppose y in G.AdjacentSet({v}) & not y in dom VLG; then
          V2.y = V2G.y \/ {k} by Th34;
          hence x is finite by A9;
       end;
    end;
    then V2 is finite-yielding &
         V2 is natsubset-yielding by A7,Def3,Lm2;
  hence IT is finite natural-vlabeled
              finite-v2labeled natsubset-v2labeled VVGraph
     by A1,Def7,Def12, Def13;
 end;
end;

definition let G be finite natural-vlabeled
                    finite-v2labeled natsubset-v2labeled VVGraph,
               v be Vertex of G, n be natural number;
   func LexBFS:Update(G, v, n) ->
             finite natural-vlabeled
             finite-v2labeled natsubset-v2labeled VVGraph equals
     LexBFS:LabelAdjacent(G.labelVertex(v, G.order()-'n), v, G.order()-'n);
   coherence proof  set k = G.order()-'n;
      reconsider Gl = G.labelVertex(v, k) as
         finite natural-vlabeled
         finite-v2labeled natsubset-v2labeled VVGraph;
      Gl == G by GLIB_003:47; then
      reconsider vv = v as Vertex of Gl by GLIB_000:def 36;
      LexBFS:LabelAdjacent(Gl, vv, k) is
         finite natural-vlabeled finite-v2labeled natsubset-v2labeled VVGraph;
      hence thesis;
   end;
end;

definition let G be finite natural-vlabeled
                    finite-v2labeled natsubset-v2labeled VVGraph;
  func LexBFS:Step(G) ->
           finite natural-vlabeled
           finite-v2labeled natsubset-v2labeled VVGraph equals
  :Def32: G if G.order() <= card (dom the_VLabel_of G)
                otherwise LexBFS:Update(G,
                                        LexBFS:PickUnnumbered(G),
                                        card (dom the_VLabel_of G));
  coherence; consistency;
end;

definition let G be finite _Graph;
  func LexBFS:CSeq(G) ->
       finite natural-vlabeled
       finite-v2labeled natsubset-v2labeled VVGraphSeq means
:Def33: it.0 = LexBFS:Init(G) &
           for n being natural number holds it.(n+1) = LexBFS:Step(it.n);
  existence proof
     defpred P[set,set,set] means
      ($2 is finite natural-vlabeled
             finite-v2labeled natsubset-v2labeled VVGraph & $1 is Nat &
          ex nn being Nat,Gn,Gn1 being finite natural-vlabeled
                                      finite-v2labeled
                                      natsubset-v2labeled VVGraph st
          $1 = nn & $2 = Gn & $3 = Gn1 & Gn1 = LexBFS:Step(Gn)) or
      ((not $2 is finite natural-vlabeled
        finite-v2labeled natsubset-v2labeled VVGraph or
        not $1 is Nat) & $2 = $3);

    now let n,x be set;
        now per cases;
        suppose A1: x is finite natural-vlabeled
                         finite-v2labeled
                         natsubset-v2labeled VVGraph & n is Nat;
            then reconsider Gn=x as finite natural-vlabeled
                                    finite-v2labeled
                                    natsubset-v2labeled VVGraph;
            reconsider nn = n as Nat by A1;
            reconsider xx=x as finite natural-vlabeled
                         finite-v2labeled
                         natsubset-v2labeled VVGraph by A1;
            consider SGn being finite natural-vlabeled
                 finite-v2labeled
                 natsubset-v2labeled VVGraph such that
        A2: SGn = LexBFS:Step(Gn);
            thus ex y being set st P[n,x,y] by A1,A2; end;
        suppose not x is finite natural-vlabeled
                         finite-v2labeled
                         natsubset-v2labeled VVGraph or not n is Nat;
            hence ex y being set st P[n,x,y]; end;
        end;
        hence ex y being set st P[n,x,y];
    end; then
A3: for n being Element of NAT for x being set ex y being set st P[n,x,y];
A4: for n being Element of NAT for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2]
    holds y1 = y2;
    consider IT being Function such that
A5: dom IT = NAT &
    IT.0 = LexBFS:Init(G) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
      from RECDEF_1:sch 1(A3,A4);

    reconsider IT as ManySortedSet of NAT by A5, PBOOLE:def 3;
    defpred P2[Nat] means IT.$1 is finite natural-vlabeled
                                   finite-v2labeled
                                   natsubset-v2labeled VVGraph;
A6: P2[0] by A5;
A7: now let n be Element of NAT; assume P2[n]; then
        consider nn being Nat,
                 Gn,Gn1 being finite natural-vlabeled
                 finite-v2labeled
                 natsubset-v2labeled VVGraph such that
    A8: n = nn & IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = LexBFS:Step(Gn) by A5;
        thus P2[n+1] by A8;
    end;
A9: for n being Element of NAT holds P2[n] from NAT_1:sch 1(A6,A7); then
    for n being Element of NAT holds IT.n is _Graph; then
    reconsider IT as GraphSeq by GLIB_000:def 55;
    for n being Nat holds
      IT.n is [VLabeled] & IT.n is [V2Labeled] proof
      let n be Nat;
      n in NAT by ORDINAL1:def 13;
      hence IT.n is [VLabeled] & IT.n is [V2Labeled] by A9;
    end; then
    reconsider IT as VVGraphSeq by GLIB_003:def 26, Def20;

    for n being Nat holds IT.n is finite natural-vlabeled
                 finite-v2labeled natsubset-v2labeled proof
       let n be Nat;
       n in NAT by ORDINAL1:def 13;
       hence IT.n is finite natural-vlabeled
                 finite-v2labeled natsubset-v2labeled by A9;
    end; then
    reconsider IT as finite natural-vlabeled
               finite-v2labeled natsubset-v2labeled VVGraphSeq
           by GLIB_000:def 60, Def17, Def23, Def22;
    take IT;
    thus IT.0 = LexBFS:Init(G) by A5;
    let n be Nat;
A10: n in NAT by ORDINAL1:def 13;
    consider nn being Nat,
             Gn,Gn1 being finite natural-vlabeled
             finite-v2labeled natsubset-v2labeled VVGraph such that
A11: n = nn & IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = LexBFS:Step(Gn)
         by A5,A10;
    thus IT.(n+1) = LexBFS:Step(IT.n) by A11;
  end;

  uniqueness proof
    let IT1,IT2 be finite natural-vlabeled
                   finite-v2labeled natsubset-v2labeled
                   VVGraphSeq such that
A12: IT1.0 = LexBFS:Init(G) &
    for n being Nat holds IT1.(n+1) = LexBFS:Step(IT1.n) and
A13: IT2.0 = LexBFS:Init(G) &
    for n being Nat holds IT2.(n+1) = LexBFS:Step(IT2.n);
    defpred P[Nat] means IT1.$1 = IT2.$1;
A14: P[0] by A12,A13;
    now let n be Nat; assume P[n]; then
        IT1.(n+1) = LexBFS:Step(IT2.n) by A12
                   .= IT2.(n+1) by A13;
        hence P[n+1];
    end; then
A15: for n being Element of NAT st P[n] holds P[n+1];
    for n being Element of NAT holds P[n] from NAT_1:sch 1(A14,A15); then
    for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

theorem Th36:
for G being finite _Graph holds LexBFS:CSeq(G) is iterative
proof let G be finite _Graph;
  set CS = LexBFS:CSeq(G);
  let k,n be natural number such that A1: CS.k = CS.n;
  CS.(k+1) = LexBFS:Step(CS.k) by Def33;
  hence CS.(k+1) = CS.(n+1) by A1,Def33;
end;

registration let G be finite _Graph;
  cluster LexBFS:CSeq(G) -> iterative;
  coherence by Th36;
end;

theorem Th37: :: tLexBFSINIT01:
for G being _Graph holds the_VLabel_of LexBFS:Init(G) = {}
proof let G be _Graph;
    set G1 = G.set(VLabelSelector, {});
    set G2 = G1.set(V2LabelSelector, the_Vertices_of G --> {});
    the_VLabel_of G2 = the_VLabel_of G1 by GLIB_000:12;
  hence the_VLabel_of LexBFS:Init(G) = {} by GLIB_000:11;
end;

theorem Th38: :: tLexBFSINIT02:
for G being _Graph, v being set
  holds dom the_V2Label_of LexBFS:Init(G) = the_Vertices_of G &
        (the_V2Label_of LexBFS:Init(G)).v = {}
proof let G be _Graph, v be set;
    set G1 = G.set(VLabelSelector, {});
    set g  = the_Vertices_of G --> {};
A1: G1 == G by GLIB_003:8;
A2: dom g = the_Vertices_of G by FUNCOP_1:19; then
    dom g = the_Vertices_of G1 by A1,GLIB_000:def 36; then
    reconsider f = g as PartFunc of the_Vertices_of G1, rng g by PARTFUN1:24;
    set G2 = G1.set(V2LabelSelector, f);
A3: now let x be set; per cases;
     suppose x in dom f; hence f.x = {} by A2,FUNCOP_1:13; end;
     suppose not x in dom f; hence f.x = {} by FUNCT_1:def 4; end;
    end;
A4: the_V2Label_of G2 = f by GLIB_000:11;
  thus dom the_V2Label_of LexBFS:Init(G) =the_Vertices_of G by A2,GLIB_000:11;
  thus (the_V2Label_of LexBFS:Init(G)).v = {} by A4,A3;
end;

theorem Th39: :: tLexBFSINIT03:
for G being _Graph holds G == LexBFS:Init(G)
proof let G be _Graph;
    set G1 = G.set(VLabelSelector, {});
    set G2 = G1.set(V2LabelSelector, the_Vertices_of G --> {});
A1: G == G1 by GLIB_003:8;
    G1 == G2 by Th12;
  hence thesis by A1,GLIB_000:88;
end;

:: the vertex picked has the largest v2label
theorem Th40: :: tLexBFSPick01:
for G being finite finite-v2labeled natsubset-v2labeled VVGraph, x being set
 st not x in dom the_VLabel_of G &
    dom the_V2Label_of G = the_Vertices_of G &
    dom the_VLabel_of G <> the_Vertices_of G
 holds ((the_V2Label_of G).x,1)-bag <=
       ((the_V2Label_of G).(LexBFS:PickUnnumbered(G)),1)-bag, InvLexOrder NAT
proof let G be finite finite-v2labeled natsubset-v2labeled VVGraph,
      x be set such that
A1: not x in dom the_VLabel_of G and
A2: dom the_V2Label_of G = the_Vertices_of G and
A3: dom the_VLabel_of G <> the_Vertices_of G;
    set w = LexBFS:PickUnnumbered(G);
    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
    set VG = the_Vertices_of G;
    consider S being non empty finite Subset of bool NAT,
             B being non empty finite Subset of Bags NAT,
             F being Function such that
A4: S = rng F and
A5: F = V2G | (VG \ dom VLG) and
A6: for x being finite Subset of NAT holds x in S implies (x,1)-bag in B and
A7: for x being set holds x in B implies
            ex y being finite Subset of NAT st y in S & x = (y,1)-bag and
A8: w = choose (F " {support max(B,InvLexOrder NAT)}) by A3,A2,Def29;
    set mw = max(B,InvLexOrder NAT);
    mw in B by Def5; then
    consider y being finite Subset of NAT such that
A9: y in S & mw = (y,1)-bag by A7;
A10: y = support mw by A9,UPROOTS:10;
A11: F " {support mw} is non empty by A10, A9,A4, FUNCT_1:142;
A12: w in dom F & F.w in {support mw} by A11, A8,FUNCT_1:def 13; then
A13: V2G.w = F.w by A5,FUNCT_1:70;
A14: (V2G.w,1)-bag = mw by A9, A13,A10, A12,TARSKI:def 1;
A15: dom F = dom V2G /\ (VG \ dom VLG) by A5,FUNCT_1:68;
  per cases;
  suppose x in the_Vertices_of G; then
  A16: x in VG \ dom VLG by A1,XBOOLE_0:def 4;
  A17: x in dom F by A2,A16,A15,XBOOLE_0:def 3; then
  A18: F.x = V2G.x by A5,FUNCT_1:70;
      F.x in S by A17,A4,FUNCT_1:def 5; then
      (V2G.x,1)-bag in B by A6,A18;
    hence (V2G.x,1)-bag <= (V2G.w,1)-bag, InvLexOrder NAT by A14,Def5;end;
  suppose not x in the_Vertices_of G; then
    V2G.x = {} by A2, FUNCT_1:def 4; then
    (V2G.x,1)-bag = EmptyBag NAT by UPROOTS:11;
    hence (V2G.x,1)-bag <= (V2G.w,1)-bag, InvLexOrder NAT by TERMORD:9; end;
end;

:: the vertex picked is not currently in the vlabel
theorem Th41: :: tLexBFSPick02:
for G being finite finite-v2labeled natsubset-v2labeled VVGraph
 st dom the_V2Label_of G = the_Vertices_of G &
    dom the_VLabel_of G <> the_Vertices_of G
 holds not LexBFS:PickUnnumbered(G) in dom the_VLabel_of G
proof let G be finite finite-v2labeled natsubset-v2labeled VVGraph such that
A1: dom the_V2Label_of G = the_Vertices_of G and
A2: dom the_VLabel_of G <> the_Vertices_of G;
    set w = LexBFS:PickUnnumbered(G);
    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
    set VG = the_Vertices_of G;
    assume A3: w in dom VLG;
    consider S being non empty finite Subset of bool NAT,
             B being non empty finite Subset of Bags NAT,
             F being Function such that
A4: S = rng F and
A5: F = V2G | (VG \ dom VLG) and
    for x being finite Subset of NAT holds x in S implies (x,1)-bag in B and
A6: for x being set holds x in B implies
            ex y being finite Subset of NAT st y in S & x = (y,1)-bag and
A7: w = choose (F " {support max(B,InvLexOrder NAT)}) by A2,A1,Def29;
    set mw = max(B,InvLexOrder NAT);
    mw in B by Def5; then
    consider y being finite Subset of NAT such that
A8: y in S & mw = (y,1)-bag by A6;
A9: y = support mw by A8,UPROOTS:10;
A10: F " {support mw} is non empty by A8,A4,A9,FUNCT_1:142;
A11: w in dom F by FUNCT_1:def 13, A7, A10;
A12: dom F = dom V2G /\ (VG \ dom VLG) by A5,FUNCT_1:68;
    not w in VG \ dom VLG by A3,XBOOLE_0:def 4;
  hence contradiction by A11, A12,XBOOLE_0:def 3;
end;

theorem Th42:
for G being finite _Graph, n being natural number
  holds (LexBFS:CSeq(G)).n == G
proof let G be finite _Graph, n be Nat;
    defpred P[Nat] means (LexBFS:CSeq(G)).$1 == G;
    (LexBFS:CSeq(G)).0 = LexBFS:Init(G) by Def33; then
A1: P[0] by Th39;
A2: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A3: P[k];
        set CSK = (LexBFS:CSeq(G)).k;
        set CK1 = (LexBFS:CSeq(G)).(k+1);
        set w   = LexBFS:PickUnnumbered(CSK);
        set kk  = G.order() -' card (dom the_VLabel_of CSK);
    A4: CSK.order() = G.order() by A3, GLIB_000:93;
    A5: CK1 = LexBFS:Step(CSK) by Def33;
      per cases;
      suppose card (dom the_VLabel_of CSK) < G.order(); then
    A6: CK1 = LexBFS:Update(CSK, w, card (dom the_VLabel_of CSK))
                by A4,A5,Def32;
        set CC = CSK.labelVertex(w,kk);
    A7: CK1 == CC by A6,A4,Th12;
        CC == CSK by GLIB_003:47; then
        CK1 == CSK by A7,GLIB_000:88;
      hence P[k+1] by A3,GLIB_000:88; end;
      suppose G.order() <= card (dom the_VLabel_of CSK);
      hence P[k+1] by A3, A4,A5,Def32;  end;
    end;
    for k being Nat holds P[k] from NAT_1:sch 2(A1,A2);
  hence (LexBFS:CSeq(G)).n == G;
end;

:: show lexbfs has static vertices
theorem Th43:
for G being finite _Graph, m,n being natural number
  holds (LexBFS:CSeq(G)).m == (LexBFS:CSeq(G)).n
proof let G be finite _Graph, m,n be Nat;
A1: (LexBFS:CSeq(G)).m == G by Th42;
    (LexBFS:CSeq(G)).n == G by Th42;
  hence (LexBFS:CSeq(G)).m == (LexBFS:CSeq(G)).n by A1,GLIB_000:88;
end;

theorem Th44:
for G being finite _Graph, n being natural number
 st card (dom the_VLabel_of ((LexBFS:CSeq(G)).n)) < G.order()
holds
   the_VLabel_of ((LexBFS:CSeq(G)).(n+1)) =
   (the_VLabel_of ((LexBFS:CSeq(G)).n)) +*
   (LexBFS:PickUnnumbered((LexBFS:CSeq(G)).n) .-->
      (G.order()-'(card (dom the_VLabel_of ((LexBFS:CSeq(G)).n)))))
proof let G be finite _Graph, n be Nat such that
A1: card (dom the_VLabel_of (LexBFS:CSeq(G)).n) < G.order();
    set CSN = (LexBFS:CSeq(G)).n;     set VLN = the_VLabel_of CSN;
    set CN1 = (LexBFS:CSeq(G)).(n+1); set VN1 = the_VLabel_of CN1;
    set w   = LexBFS:PickUnnumbered(CSN);
    set k   = G.order() -' card (dom the_VLabel_of CSN);
    G == CSN by Th42; then
A2: CSN.order() = G.order() by GLIB_000:93;
    CN1 = LexBFS:Step(CSN) by Def33; then
    CN1 = LexBFS:Update(CSN, w, card (dom VLN)) by A1,A2,Def32; then
    VN1 = the_VLabel_of CSN.labelVertex(w, k) by A2, GLIB_000:12;
  hence thesis by GLIB_003:45;
end;

theorem Th45:
for G being finite _Graph, n being natural number
 holds dom (the_V2Label_of ((LexBFS:CSeq(G)).n)) =
            the_Vertices_of ((LexBFS:CSeq(G)).n)
proof let G be finite _Graph, n be Nat;
  set CSN = (LexBFS:CSeq(G)).n;
  set V2N = the_V2Label_of CSN;
  defpred P[Nat] means
     dom (the_V2Label_of ((LexBFS:CSeq(G)).$1)) =
        the_Vertices_of ((LexBFS:CSeq(G)).$1);
A1: (LexBFS:CSeq(G)).0 == G by Th42;
    (LexBFS:CSeq(G)).0 = LexBFS:Init(G) by Def33; then
    dom (the_V2Label_of ((LexBFS:CSeq(G)).0)) = the_Vertices_of G
        by Th38;then
A2: P[0] by A1,GLIB_000:def 36;
A3: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A4: P[k];
        set CSK = (LexBFS:CSeq(G)).k;
        set VLK = the_VLabel_of CSK;
        set V2K = the_V2Label_of CSK;
        set CK1 = (LexBFS:CSeq(G)).(k+1);
        set V21 = the_V2Label_of CK1;
        set w   = LexBFS:PickUnnumbered(CSK);
        set m   = G.order() -' (card (dom VLK));
    A5: CSK == CK1 by Th43;
        G == CSK by Th42; then
    A6: CSK.order() = G.order() by GLIB_000:93;
      per cases;
      suppose A7: card (dom VLK) < G.order();
        CK1 = LexBFS:Step(CSK) by Def33; then
    A8: CK1 = LexBFS:Update(CSK, w, card (dom VLK)) by A7,A6,Def32;
        set CSlv = CSK.labelVertex(w,m);
        set V2v  = the_V2Label_of CSlv;
    A9: CSlv == CSK by GLIB_003:47; then
    A10: CSlv == CK1 by A5,GLIB_000:88;
        dom V2v = the_Vertices_of CSK by A4, Th13; then
        dom V2v = the_Vertices_of CSlv by A9,GLIB_000:def 36; then
        dom V21 = the_Vertices_of CSlv by A8,A6,Th35;
      hence P[k+1] by A10,GLIB_000:def 36; end;
      suppose A11: G.order() <= card (dom VLK);
        CK1 = LexBFS:Step(CSK) by Def33; then
        CSK = CK1 by A6,A11,Def32;
      hence P[k+1] by A4; end;
    end;
    for k being Nat holds P[k] from NAT_1:sch 2(A2,A3);
  hence dom V2N = the_Vertices_of CSN;
end;

theorem Th46:
for G being finite _Graph, n being natural number st n <= G.order()
 holds card dom the_VLabel_of ((LexBFS:CSeq(G)).n) = n
proof let G be finite _Graph, n be Nat such that A1: n <= G.order();
 defpred P[Nat] means
  $1 <= G.order() implies card dom the_VLabel_of ((LexBFS:CSeq(G)).$1) = $1;
 A2: for k being Nat
     st k < G.order() & card dom the_VLabel_of ((LexBFS:CSeq(G)).k) = k
     holds  card dom the_VLabel_of ((LexBFS:CSeq(G)).(k+1)) = k+1
    proof let k be Nat such that
    A3: k < G.order() & card dom the_VLabel_of ((LexBFS:CSeq(G)).k) = k;
        set CSK = (LexBFS:CSeq(G)).k;        set VLK = the_VLabel_of CSK;
        set CK1 = (LexBFS:CSeq(G)).(k+1);    set VK1 = the_VLabel_of CK1;
        CSK == G by Th42; then
    A4: the_Vertices_of CSK = the_Vertices_of G by GLIB_000:def 36;
        set w = LexBFS:PickUnnumbered(CSK);
    A5: VK1 = VLK +* (w .--> (G.order()-'k)) by A3,Th44;
        set wf  = w .--> (G.order() -' k);
        dom wf = {w} & rng wf = {G.order() -' k} by CQC_LANG:5; then
    A6: dom VK1 = dom VLK \/ {w} by A5,FUNCT_4:def 1;
        dom the_V2Label_of CSK = the_Vertices_of CSK by Th45; then
        not w in dom VLK by A3, A4,Th41;
      hence thesis by A3,A6,CARD_2:54;
    end;
    (LexBFS:CSeq(G)).0 = LexBFS:Init(G) by Def33; then
A7: P[0] by CARD_1:78, Th37, RELAT_1:60;
A8: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A9: P[k];
      per cases;
      suppose k < G.order();
        hence P[k+1] by A9,A2; end;
      suppose k >= G.order();
        hence P[k+1] by NAT_1:38; end;
      end;
    for k being Nat holds P[k] from NAT_1:sch 2(A7,A8);
 hence card dom the_VLabel_of ((LexBFS:CSeq(G)).n) = n by A1;
end;

theorem Th47:
for G being finite _Graph, n being natural number st G.order() <= n
  holds (LexBFS:CSeq(G)).(G.order()) = (LexBFS:CSeq(G)).n
proof let G be finite _Graph, n be natural number such that
A1: G.order() <= n;
    set CS = LexBFS:CSeq(G);
    defpred V[Nat] means
      G.order() = (card (dom the_VLabel_of CS.(G.order()+$1)));
A2: V[0] by Th46;
A3: for k being Nat st V[k] holds V[k+1] proof
      let k be Nat such that A4: V[k];
        set CSK = (LexBFS:CSeq(G)).(G.order()+k);
        set VLK = the_VLabel_of CSK;
        set CK1 = (LexBFS:CSeq(G)).(G.order()+k+1);
        set VL1 = the_VLabel_of CK1;
        G == CSK by Th42; then
    A5: card dom VLK = CSK.order() by A4,GLIB_000:93;
        CK1 = LexBFS:Step(CSK) by Def33;
      hence V[k+1] by A4,A5,Def32;
    end;
A6: for k being Nat holds V[k] from NAT_1:sch 2(A2,A3);
    defpred P[Nat] means
     (CS.(G.order())) = (CS.(G.order()+$1));
A7: P[0];
A8: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A9: P[k];
        set CSK = (LexBFS:CSeq(G)).(G.order()+k);
        set VLK = the_VLabel_of CSK;
        set CK1 = (LexBFS:CSeq(G)).(G.order()+k+1);
        set VL1 = the_VLabel_of CK1;
        G == CSK by Th42; then
        CSK.order() = G.order() by GLIB_000:93; then
    A10: card dom VLK = CSK.order() by A6;
        CK1 = LexBFS:Step(CSK) by Def33;
      hence P[k+1] by A9,A10,Def32;
    end;
A11: for k being Nat holds P[k] from NAT_1:sch 2(A7,A8);
    ex i being Nat st G.order() + i = n by A1,NAT_1:28;
  hence thesis by A11;
end;

theorem Th48:
for G being finite _Graph, m,n being natural number st G.order() <= m & m <= n
  holds (LexBFS:CSeq(G)).m = (LexBFS:CSeq(G)).n
proof let G be finite _Graph, m,n be Nat such that
A1: G.order() <= m & m <= n;
A2: G.order() <= n by A1,XREAL_1:2;
    (LexBFS:CSeq(G)).m = (LexBFS:CSeq(G)).(G.order()) by A1,Th47;
  hence (LexBFS:CSeq(G)).m = (LexBFS:CSeq(G)).n by A2,Th47;
end;

theorem Th49:
for G being finite _Graph holds LexBFS:CSeq(G) is eventually-constant
proof let G be finite _Graph;
  take G.order();
  let m be Nat such that A1: G.order() <= m;
  thus (LexBFS:CSeq(G)).(G.order()) = (LexBFS:CSeq(G)).m by A1,Th47;
end;

registration let G be finite _Graph;
  cluster LexBFS:CSeq(G) -> eventually-constant;
  coherence by Th49;
end;

theorem Th50:
for G being finite _Graph, n being natural number holds
    dom the_VLabel_of((LexBFS:CSeq(G)).n) = the_Vertices_of((LexBFS:CSeq(G)).n)
iff G.order() <= n
proof let G be finite _Graph, n be Nat;
    set CSN = (LexBFS:CSeq(G)).n; set VLN = the_VLabel_of ((LexBFS:CSeq(G)).n);
    set CSO = (LexBFS:CSeq(G)).G.order(); set VLO = the_VLabel_of CSO;
A1: CSN == G by Th42; then
A2: the_Vertices_of CSN = the_Vertices_of G by GLIB_000:def 36;
A3: CSO == G by Th42; then
A4: the_Vertices_of CSO = the_Vertices_of G by GLIB_000:def 36;
    thus not dom VLN = the_Vertices_of CSN or not n < G.order()
       by A2, Th46;
  assume A5: G.order() <= n;
A6: dom VLO c= the_Vertices_of CSO by GLIB_003:7;
    card dom VLO = card the_Vertices_of CSO by A4, Th46; then
A7: dom VLO = the_Vertices_of CSO by A6,CARD_FIN:1;
A8: dom VLO = dom VLN by A5,Th48;
    CSN == CSO by A1,A3,GLIB_000:88;
  hence dom VLN = the_Vertices_of CSN by A7,A8, GLIB_000:def 36;
end;

theorem Th51:
for G being finite _Graph holds (LexBFS:CSeq(G)).Lifespan() = G.order()
proof
    let G be finite _Graph;
    set CS = LexBFS:CSeq(G);
    G.order() <= G.order()+1 by NAT_1:38; then
A1: CS.(G.order()) = CS.(G.order()+1) by Th47;
    for n being Element of NAT st CS.n = CS.(n+1) holds G.order() <= n proof
        let n be Element of NAT such that  A2: CS.n = CS.(n+1);
        assume A3: n < G.order();
        set VLN = the_VLabel_of (CS.n);
        set VN1 = the_VLabel_of (CS.(n+1));
        set w   = LexBFS:PickUnnumbered(CS.n);
        set j = card (dom VLN);
    A4: dom the_V2Label_of (CS.n) = the_Vertices_of (CS.n) by Th45;
        dom VLN <> the_Vertices_of (CS.n) by A3,Th50; then
    A5: not w in dom VLN by A4,Th41;
    A6: j < G.order() by A3,Th46;
    A7: VN1 = VLN +* (w .--> (G.order() -' j)) by A6,Th44;
        set wf  = w .--> (G.order() -' j);
        dom wf = {w} & rng wf = {G.order() -' j} by CQC_LANG:5; then
    A8: dom VN1 = dom VLN \/ {w} by A7,FUNCT_4:def 1;
        w in {w} by TARSKI:def 1;
      hence contradiction by A2,A5,A8,XBOOLE_0:def 2;
    end;
  hence thesis by A1,GLIB_000:def 57;
end;

registration let G be finite chordal _Graph, i be natural number;
  cluster (LexBFS:CSeq(G)).i -> chordal VVGraph;
  coherence proof
      (LexBFS:CSeq(G)).i == G by Th42;
    hence (LexBFS:CSeq(G)).i is chordal VVGraph by CHORD:95;
  end;
end;

registration
  let G be finite chordal _Graph;
  cluster LexBFS:CSeq(G) -> chordal;
  correctness proof  thus for x be Nat holds (LexBFS:CSeq(G)).x is chordal;
  end;
end;

theorem Th52:
for G being finite _Graph holds LexBFS:CSeq(G) is vlabel-numbering
proof let G be finite _Graph;
    set GS = LexBFS:CSeq(G);
    now let n,m be Nat; (GS.n) == (GS.m) by Th43;
      hence (the_Vertices_of (GS.n)) =
            (the_Vertices_of (GS.m)) by GLIB_000:def 36;
    end; then
A1: GS is fixed-vertices by Def19;
    GS.0 = LexBFS:Init(G) by Def33; then
    the_VLabel_of (GS.0) = {} by Th37; then
A2: GS is vlabel-initially-empty by Def24;
A3: GS.Lifespan() = G.order() by Th51;
    now let n be Nat such that A4: n < GS.Lifespan();
    A5: n = card dom the_VLabel_of (GS.n) by A4,A3,Th46;
        set w = LexBFS:PickUnnumbered(GS.n);
    A6: dom the_V2Label_of (GS.n) = the_Vertices_of (GS.n) by Th45;
       dom the_VLabel_of (GS.n) <> the_Vertices_of (GS.n)
         by A4,A3,Th50; then
    A7: not w in dom (the_VLabel_of (GS.n)) by A6,Th41;
         the_VLabel_of (GS.(n+1)) =
        (the_VLabel_of (GS.n)) +* (w .--> (GS.Lifespan()-'n))
               by A4,A3,A5,Th44;
      hence (ex w being set st not w in dom (the_VLabel_of (GS.n)) &
         the_VLabel_of (GS.(n+1)) =
        (the_VLabel_of (GS.n)) +* (w .--> (GS.Lifespan()-'n))) by A7;
    end; then GS is adds-one-at-a-step by Def25;
  hence thesis by A1,A2,Def26;
end;

registration let G be finite _Graph;
  cluster LexBFS:CSeq(G) -> vlabel-numbering;
  coherence by Th52;
end;

theorem Th53:
for G being finite _Graph, n being natural number st n < G.order()
  holds (LexBFS:CSeq(G)).PickedAt(n) =
        LexBFS:PickUnnumbered((LexBFS:CSeq(G)).n)
proof let G be finite _Graph, n be Nat such that A1: n < G.order();
    set GS = LexBFS:CSeq(G);
    set CSN = GS.n;
    set CS1 = GS.(n+1);
    set PA = GS.PickedAt(n);
    set PU = LexBFS:PickUnnumbered(CSN);
    set VLN = the_VLabel_of CSN;
    set VL1 = the_VLabel_of CS1;
A2: GS.Lifespan() = G.order() by Th51; then
A3: not PA in dom VLN & VL1 = VLN +* (PA .--> (GS.Lifespan()-'n))
       by A1,Def27;
    n = card dom VLN by A1,Th46; then
A4: VL1 = VLN +* (PU .--> (GS.Lifespan()-'n)) by A1,A2,Th44;
    set f1 = PA .--> (GS.Lifespan()-'n);
    set f2 = PU .--> (GS.Lifespan()-'n);
 A5: dom f1 = {PA} & rng f1 = {GS.Lifespan()-'n} by CQC_LANG:5;
 A6: dom f2 = {PU} & rng f2 = {GS.Lifespan()-'n} by CQC_LANG:5;
 A7: dom VL1 = dom VLN \/ {PA} by A3,A5,FUNCT_4:def 1;
 A8: dom VL1 = dom VLN \/ {PU} by A4,A6,FUNCT_4:def 1;
    now assume PA <> PU; then
        not PA in {PU} by TARSKI:def 1; then
    A9: not PA in dom VL1 by A3,A8,XBOOLE_0:def 2;
        PA in {PA} by TARSKI:def 1;
      hence contradiction by A9, A7,XBOOLE_0:def 2;
    end;
  hence PA = PU;
end;

theorem Th54:
for G being finite _Graph, n being natural number st n < G.order()
 ex w being Vertex of (LexBFS:CSeq(G)).n
   st w = LexBFS:PickUnnumbered((LexBFS:CSeq(G)).n) &
   for v being set holds
    ((v in G.AdjacentSet({w}) &
      not v in dom (the_VLabel_of ((LexBFS:CSeq(G)).n))
       implies
        (the_V2Label_of ((LexBFS:CSeq(G)).(n+1))).v =
        (the_V2Label_of ((LexBFS:CSeq(G)).n)).v \/ {G.order() -' n}) &
    ((not v in G.AdjacentSet({w}) or
          v in dom (the_VLabel_of ((LexBFS:CSeq(G)).n)))
       implies
        (the_V2Label_of ((LexBFS:CSeq(G)).(n+1))).v =
        (the_V2Label_of ((LexBFS:CSeq(G)).n)).v))
proof let G be finite _Graph, n be Nat such that
A1: n < G.order();
    set CSN = (LexBFS:CSeq(G)).n;      set VLN = the_VLabel_of CSN;
    set V2N = the_V2Label_of CSN;    set CN1 = (LexBFS:CSeq(G)).(n+1);
    set VN1 = the_VLabel_of CN1;    set V21 = the_V2Label_of CN1;
    set w   = LexBFS:PickUnnumbered(CSN);
    set k   = G.order() -' n;
A2: card dom VLN = n by A1,Th46;
    G == CSN by Th42; then
A3: CSN.order() = G.order() by GLIB_000:93;
    CN1 = LexBFS:Step(CSN) by Def33; then
A4: CN1 = LexBFS:Update(CSN, w, n) by A2,A1,A3,Def32;

    set CSlv = CSN.labelVertex(w,k);    set VLv  = the_VLabel_of CSlv;
    set V2v  = the_V2Label_of CSlv;

A5: CSN == CSlv by GLIB_003:47;
    CSN == G by Th42; then
A6: CSlv == G by A5,GLIB_000:88;
A7: CSlv.labeledV() = CSN.labeledV() \/ {w} by GLIB_003:59;
A8: V2v = V2N by Th13;
A9: dom VLN c= dom VLv by A7,XBOOLE_1:7;
A10: now let v be set;
        assume A11: v in G.AdjacentSet({w}) & not v in dom VLN; then
    A12: v in CSlv.AdjacentSet({w}) by A6,CHORD:51;
        not v in {w} by A11,CHORD:49; then
        not v in dom VLv by A7,A11,XBOOLE_0:def 2;
      hence   V21.v = V2N.v \/ {k} by A8,A4, A3, A12,Th34;
    end;
A13: now let v be set;
      assume A14: not v in G.AdjacentSet({w}) or v in dom VLN;
      per cases by A14;
      suppose not v in G.AdjacentSet({w}); then
        not v in CSlv.AdjacentSet({w}) by A6,CHORD:51;
      hence V21.v = V2N.v by A8, A4, A3,Th32; end;
      suppose v in dom VLN;
      hence V21.v = V2N.v by A8, A4,A3, A9, Th33; end;
    end;
    take w;
  thus thesis by A10,A13;
end;

theorem Th55:
for G being finite _Graph, i being natural number, v being set holds
(the_V2Label_of ((LexBFS:CSeq(G)).i)).v c= (Seg G.order()) \ Seg (G.order()-'i)
proof let G be finite _Graph, i be Nat, v be set;
  set CSI = (LexBFS:CSeq(G)).i;   set V2I = the_V2Label_of CSI;
  set CSO = (LexBFS:CSeq(G)).(G.order());  set V2O = the_V2Label_of CSO;
  defpred P[Nat] means $1 <= G.order() implies
    (the_V2Label_of ((LexBFS:CSeq(G)).$1)).v c=
       (Seg G.order()) \ Seg (G.order() -' $1);
A1: P[0] proof
        set CS0 = (LexBFS:CSeq(G)).0; set V20 = the_V2Label_of CS0;
        CS0 = LexBFS:Init(G) by Def33; then
        V20.v = {} by Th38;
      hence P[0] by XBOOLE_1:2;
    end;
A2: for k being Nat st P[k] holds P[k+1] proof
      let k be Nat such that A3: P[k];
      set CSK = (LexBFS:CSeq(G)).k;      set V2K = the_V2Label_of CSK;
      set VLK = the_VLabel_of CSK;      set CK1 = (LexBFS:CSeq(G)).(k+1);
      set V21 = the_V2Label_of CK1;
      per cases;
      suppose k+1 <= G.order(); then
  A4: k < G.order() by NAT_1:38;
          consider w being Vertex of CSK such that
           w = LexBFS:PickUnnumbered(CSK) and
      A5: for v being set holds
            ((v in G.AdjacentSet({w}) & not v in dom VLK
                implies V21.v = V2K.v \/ {G.order() -' k}) &
             (not v in G.AdjacentSet({w}) or v in dom VLK
                implies V21.v = V2K.v)) by A4,Th54;
          per cases;
          suppose v in G.AdjacentSet({w}) & not v in dom VLK; then
        A6: V21.v = V2K.v \/ {G.order() -' k} by A5;
            ((Seg G.order()) \ Seg (G.order() -' k)) \/ {G.order() -' k} =
            (Seg G.order()) \ Seg (G.order() -' (k+1)) by A4,Th7;
          hence P[k+1] by A6,NAT_1:38,A3,XBOOLE_1:9; end;
          suppose not v in G.AdjacentSet({w}) or v in dom VLK; then
        A7: V21.v = V2K.v by A5;
            k <= k+1 by NAT_1:38; then
            (Seg G.order()) \ Seg (G.order() -' k) c=
            (Seg G.order()) \ Seg (G.order() -' (k+1)) by Th6;
          hence P[k+1] by A7,NAT_1:38,A3,XBOOLE_1:1; end;
      end;
      suppose G.order() < k+1;
      hence P[k+1]; end;
    end;
A8: for k being Nat holds P[k] from NAT_1:sch 2(A1,A2);
  per cases;
  suppose i <= G.order();
    hence V2I.v c= (Seg G.order()) \ Seg (G.order() -' i) by A8; end;
  suppose A9: i > G.order(); then
    G.order() - i < i - i by XREAL_1:11; then
A10: G.order() -' i = 0 by BINARITH:def 3;
A11: G.order() -' G.order() = G.order() -' i by A10,BINARITH:51;
    V2O = V2I by A9,Th48;
  hence V2I.v c= (Seg G.order()) \ Seg (G.order() -' i) by A11, A8; end;
end;

:: LexBFS: Property L1
theorem Th56:
for G being finite _Graph, x being set, i,j being natural number st i <= j
 holds    (the_V2Label_of ((LexBFS:CSeq(G)).i)).x
       c= (the_V2Label_of ((LexBFS:CSeq(G)).j)).x
proof let G be finite _Graph, x be set, i,j be Nat such that
A1: i <= j;
  set CSI = (LexBFS:CSeq(G)).i;   set V2I = the_V2Label_of CSI;
  set CSJ = (LexBFS:CSeq(G)).j;   set V2J = the_V2Label_of CSJ;
  defpred P[Nat] means
    (the_V2Label_of ((LexBFS:CSeq(G)).i)).x c=
    (the_V2Label_of ((LexBFS:CSeq(G)).(i+$1))).x;
A2: P[0];
A3: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A4: P[k];
        set CSK = (LexBFS:CSeq(G)).(i+k);
        set V2K = the_V2Label_of CSK;
        set VLK = the_VLabel_of CSK;
        set CK1 = (LexBFS:CSeq(G)).(i+k+1);
        set V21 = the_V2Label_of CK1;
        per cases;
        suppose i+k+1 <= G.order(); then
          i+k < G.order() by NAT_1:38; then
          consider w being Vertex of CSK such that
           w = LexBFS:PickUnnumbered(CSK) and
      A5: for v being set holds
            (v in G.AdjacentSet({w}) & not v in dom VLK
               implies V21.v = V2K.v \/ {G.order() -' (i+k)}) &
            (not v in G.AdjacentSet({w}) or v in dom VLK
               implies V21.v = V2K.v) by Th54;
          per cases;
          suppose x in G.AdjacentSet({w}) & not x in dom VLK; then
            V21.x = V2K.x \/ {G.order() -' (i+k)} by A5; then
            V2K.x c= V21.x by XBOOLE_1:7;
            hence P[k+1] by A4,XBOOLE_1:1;end;
          suppose not x in G.AdjacentSet({w}) or x in dom VLK;
          hence P[k+1] by A4, A5; end;
        end;
        suppose G.order() < i+k+1; then
      A6: G.order() <= i+k by NAT_1:38;
          i+k <= i+k+1 by NAT_1:38;
        hence P[k+1] by A4, A6,Th48; end;
    end;
A7: for k being Nat holds P[k] from NAT_1:sch 2(A2,A3);
    ex k being Nat st j = i+k by A1,NAT_1:28;
  hence V2I.x c= V2J.x by A7;
end;

theorem Th57:
for G being finite _Graph, m,n being natural number, x, y being set
 st n < G.order() & n < m & y = LexBFS:PickUnnumbered((LexBFS:CSeq(G)).n) &
    not x in dom (the_VLabel_of ((LexBFS:CSeq(G)).n)) & x in G.AdjacentSet({y})
  holds (G.order() -' n) in (the_V2Label_of ((LexBFS:CSeq(G)).m)).x
proof let G be finite _Graph;
    let m,n be Nat, x, y be set such that
A1: n < G.order() and
A2: n < m;
    set CSN = (LexBFS:CSeq(G)).n;    set VLN = the_VLabel_of CSN;
    set V2N = the_V2Label_of CSN;    set CSM = (LexBFS:CSeq(G)).m;
    set VLM = the_VLabel_of CSM;     set V2M = the_V2Label_of CSM;
    assume that
A3: y = LexBFS:PickUnnumbered(CSN) and
A4: not x in dom VLN and
A5: x in G.AdjacentSet({y});
    set CN1 = (LexBFS:CSeq(G)).(n+1);    set VN1 = the_VLabel_of CN1;
    set V21 = the_V2Label_of CN1;
    consider w being Vertex of CSN such that
A6: w = LexBFS:PickUnnumbered(CSN) and
A7: for v being set holds
    (v in G.AdjacentSet({w}) & not v in dom VLN
      implies V21.v = V2N.v \/ {G.order() -' n}) &
    (not v in G.AdjacentSet({w}) or v in dom VLN implies V21.v = V2N.v)
      by A1,Th54;
A8: V21.x = V2N.x \/ {G.order() -' n} by A7,A4,A5, A3, A6;
    G.order() -' n in {G.order() -' n} by TARSKI:def 1; then
A9: G.order() -' n in V21.x by A8,XBOOLE_0:def 2;
    n+1 <= m by A2,NAT_1:38; then
    V21.x c= V2M.x by Th56;
  hence G.order() -' n in V2M.x by A9;
end;

theorem Th58:
for G being finite _Graph, m,n being natural number st m < n
for x being set
 st not G.order()-'m in (the_V2Label_of ((LexBFS:CSeq(G)).(m+1))).x
  holds not G.order()-'m in (the_V2Label_of ((LexBFS:CSeq(G)).n)).x
proof let G be finite _Graph, m,n be Nat such that
A1: m < n;
    set CSM = (LexBFS:CSeq(G)).(m+1);    set V2M = the_V2Label_of CSM;
    set CSN = (LexBFS:CSeq(G)).n;        set V2N = the_V2Label_of CSN;
    let x be set such that
A2: not G.order() -' m in V2M.x;
  defpred P[Nat] means
    not G.order() -' m in (the_V2Label_of ((LexBFS:CSeq(G)).(m+1+$1))).x;
A3: P[0] by A2;
A4: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A5: P[k];
        set CSK = (LexBFS:CSeq(G)).(m+1+k);
        set VLK = the_VLabel_of CSK;
        set V2K = the_V2Label_of CSK;
        set CK1 = (LexBFS:CSeq(G)).(m+1+k+1);
        set V21 = the_V2Label_of CK1;
        now per cases;
          suppose A6: m+1+k < G.order(); then
            consider w being Vertex of CSK such that
           w = LexBFS:PickUnnumbered(CSK) and
        A7: for v being set holds
            ((v in G.AdjacentSet({w}) & not v in dom VLK)
              implies V21.v = V2K.v  \/ {G.order() -' (m+1+k)}) &
            ((not v in G.AdjacentSet({w}) or v in dom VLK)
              implies V21.v = V2K.v) by Th54;
            per cases;
            suppose x in G.AdjacentSet({w}) & not x in dom VLK; then
          A8: V21.x = V2K.x \/ {G.order() -' (m+1+k)} by A7;
              m < m+1 & m+1 <= m+1+k by XREAL_1:41,NAT_1:29; then
              m < m+1+k by XREAL_1:2; then
              G.order() -' m > G.order() -' (m+1+k) by A6,Th2; then
              not G.order() -' m in {G.order() -' (m+1+k)} by TARSKI:def 1;
            hence not G.order() -' m in V21.x by A5,A8,XBOOLE_0:def 2; end;
            suppose not x in G.AdjacentSet({w}) or x in dom VLK;
            hence not G.order() -' m in V21.x by A5, A7; end;
          end;
          suppose A9: G.order() <= m+1+k;
            m+1+k <= m+1+k+1 by NAT_1:38;
            hence not G.order() -' m in V21.x by A5, A9,Th48; end;
          end;
      hence P[k+1];
    end;
A10: for k being Nat holds P[k] from NAT_1:sch 2(A3,A4);
    m+1 <= n by A1,NAT_1:38; then
    ex j being Nat st m+1+j = n by NAT_1:28;
  hence not G.order() -' m in V2N.x by A10;
end;

:: More general version of the above:
:: if the value added during step k doesn't appear in a later step (n),
:: then that value cannot appear in an even later step (m)
theorem Th59:
for G being finite _Graph, m,n,k being natural number st k < n & n <= m
for x being set
 st not G.order()-'k in (the_V2Label_of ((LexBFS:CSeq(G)).n)).x
  holds not G.order()-'k in (the_V2Label_of ((LexBFS:CSeq(G)).m)).x
proof let G be finite _Graph, m,n,k be Nat such that
A1: k < n and
A2: n <= m;
    set CSN = (LexBFS:CSeq(G)).n;
    set V2N = the_V2Label_of CSN;
    set CSM = (LexBFS:CSeq(G)).m;
    set V2M = the_V2Label_of CSM;
    let x be set such that
A3: not G.order() -' k in V2N.x;
A4: V2M.x c= (Seg G.order()) \ Seg (G.order() -' m) by Th55;
  per cases;
  suppose A5: G.order() <= k;
  now per cases by A5,REAL_1:def 5;
      suppose G.order() = k;
      hence G.order() -' k = 0 by BINARITH:51; end;
      suppose G.order() < k; then
        G.order() - k < k - k by XREAL_1:11;
      hence G.order() -' k = 0 by BINARITH:def 3; end;
    end;
  hence not G.order() -' k in V2M.x by Th5,A4; end;
  suppose k < G.order();
    set CSK = (LexBFS:CSeq(G)).k;
    set V2K = the_V2Label_of CSK;
    set CK1 = (LexBFS:CSeq(G)).(k+1);
    set V21 = the_V2Label_of CK1;
    k+1 <= n by A1,NAT_1:38; then
    V21.x c= V2N.x by Th56; then
A6: not G.order() -' k in V21.x by A3;
    k < m by A1,A2,XREAL_1:2;
  hence not G.order() -' k in V2M.x by A6,Th58; end;
end;

:: relates a value in a vertex's v2label to the vertex chosen at that time
theorem Th60:
for G being finite _Graph, m,n being natural number
for x being Vertex of ((LexBFS:CSeq(G)).m)
  st n in (the_V2Label_of ((LexBFS:CSeq(G)).m)).x
    ex y being Vertex of ((LexBFS:CSeq(G)).m)
     st ((LexBFS:PickUnnumbered((LexBFS:CSeq(G)).(G.order()-'n))) = y &
        not y in dom (the_VLabel_of ((LexBFS:CSeq(G)).(G.order()-'n))) &
        x in G.AdjacentSet({y}))
proof let G be finite _Graph, m, n be Nat;
    set CSM = (LexBFS:CSeq(G)).m;
    set VLM = the_VLabel_of CSM;
    set V2M = the_V2Label_of CSM;
    set CSN = (LexBFS:CSeq(G)).(G.order() -' n);
    set VLN = the_VLabel_of CSN;
    set V2N = the_V2Label_of CSN;
    set on1 = G.order() -' n + 1;
    set CN1 = (LexBFS:CSeq(G)).on1;
    set V21 = the_V2Label_of CN1;

A1: dom V2N = the_Vertices_of CSN by Th45;

    let x be Vertex of CSM such that A2: n in V2M.x;
    assume
A3: not ex y being Vertex of CSM st
           LexBFS:PickUnnumbered(CSN) = y &
           not y in dom VLN & x in G.AdjacentSet({y});
    V2M.x c= (Seg G.order()) \ Seg (G.order() -' m) by Th55; then
A4: G.order() -' m < n & n <= G.order() by A2,Th5;
A5: G.order() -' n = G.order() - n by A4,BINARITH:50; then
A6:  G.order() -' n < G.order() by A4,XREAL_1:46; then
A7: G.order() -' (G.order() -' n) = G.order() - (G.order() - n)
      by A5,BINARITH:50;
A8: V2N.x c= (Seg G.order()) \ Seg (G.order() -' (G.order() -' n)) by Th55;
A9: not n in V2N.x by A8,Th5, A7;
    consider w being Vertex of CSN such that
A10: w = LexBFS:PickUnnumbered(CSN) and
A11: for v being set holds
    ((v in G.AdjacentSet({w}) & not v in dom VLN implies V21.v = V2N.v\/{n}) &
     (not v in G.AdjacentSet({w}) or v in dom VLN implies V21.v = V2N.v))
        by A6,A7,Th54;
    CSM == CSN by Th43; then
    reconsider wm = w as Vertex of CSM by GLIB_000:def 36;
    dom VLN <> the_Vertices_of CSN by A6,Th50; then
    not wm in dom VLN by A10,A1,Th41; then
    not x in G.AdjacentSet({w}) by A10,A3; then
A12: not n in V21.x by A9, A11;
A13: now per cases;
    suppose m <= G.order(); then
      G.order() -' m = G.order() - m by BINARITH:50; then
      G.order() - m + m < n + m by A4,XREAL_1:8; then
      G.order() - n < m + n - n by XREAL_1:11;
      hence on1 <= m by A5, NAT_1:38; end;
    suppose G.order() < m; then
      G.order() -' n < m by A6,XREAL_1:2;
      hence on1 <= m by NAT_1:38; end;
    end;
    G.order() -' n < on1 by XREAL_1:41;
  hence contradiction by A2, A7,A12,A13,Th59;
end;

definition let Gs be finite natural-vlabeled VVGraphSeq;
  redefine func Gs.Result() -> finite natural-vlabeled VVGraph;
  coherence proof
    Gs.(Gs.Lifespan()) is finite natural-vlabeled VVGraph;
  hence Gs.Result() is finite natural-vlabeled VVGraph;
  end;
end;

theorem Th61:
for G being finite _Graph holds
    ((LexBFS:CSeq(G)).Result()).labeledV() = the_Vertices_of G
proof let G be finite _Graph;
    set CS = LexBFS:CSeq(G);
    set CSO = CS.(G.order());
A1: CSO == G by Th42;
A2: CS.Result() = CSO by Th51;
    CSO.labeledV() = the_Vertices_of CSO by Th50;
  hence thesis by A1,A2,GLIB_000:def 36;
end;

theorem Th62: :: tLexBFS05:
for G being finite _Graph
 holds (the_VLabel_of (LexBFS:CSeq(G)).Result())" is VertexScheme of G
proof
    let G be finite _Graph;
    set CS = LexBFS:CSeq(G);    set CSO = CS.(G.order());
    set VLO = the_VLabel_of CSO;
A1: CSO == G by Th42;
A2: CSO = (LexBFS:CSeq(G)).Result() by Th51;
A3: VLO is one-to-one by Th25;
    dom VLO = the_Vertices_of CSO by Th50; then
A4: dom VLO = the_Vertices_of G by A1,GLIB_000:def 36;
    CS.Lifespan() = G.order() by Th51; then
    rng VLO = (Seg G.order()) \ Seg (G.order() -' G.order()) by Th21
           .= (Seg G.order()) \ Seg 0 by BINARITH:51
           .= Seg G.order() by FINSEQ_1:4; then
A5: rng (VLO") = the_Vertices_of G &
    dom (VLO") = Seg G.order() by A3,A4,FUNCT_1:55; then
    VLO" is FinSequence by FINSEQ_1:def 2; then
A6: VLO" is FinSequence of the_Vertices_of G by A5,FINSEQ_1:def 4;
    VLO" is one-to-one by A3,FUNCT_1:62;
  hence thesis by A2, A5,A6,CHORD:def 12;
end;

:: A vertex with a vlabel of k must have had the largest v2label when chosen
theorem Th63:
for G being finite _Graph, i,j being natural number,
    a,b being Vertex of (LexBFS:CSeq(G)).i
 st a in dom the_VLabel_of ((LexBFS:CSeq(G)).i) &
    b in dom the_VLabel_of ((LexBFS:CSeq(G)).i) &
    (the_VLabel_of ((LexBFS:CSeq(G)).i)).a <
                                      (the_VLabel_of ((LexBFS:CSeq(G)).i)).b &
    j = G.order() -' (the_VLabel_of ((LexBFS:CSeq(G)).i)).b
  holds ((the_V2Label_of ((LexBFS:CSeq(G)).j)).a,1)-bag <=
        ((the_V2Label_of ((LexBFS:CSeq(G)).j)).b,1)-bag, InvLexOrder NAT
proof
    let G be finite _Graph;
    let i,j be Nat, a,b be Vertex of (LexBFS:CSeq(G)).i such that
A1: a in dom the_VLabel_of ((LexBFS:CSeq(G)).i) and
A2: b in dom the_VLabel_of ((LexBFS:CSeq(G)).i) and
A3: (the_VLabel_of ((LexBFS:CSeq(G)).i)).a <
    (the_VLabel_of ((LexBFS:CSeq(G)).i)).b and
A4: j = G.order() -' (the_VLabel_of ((LexBFS:CSeq(G)).i)).b;
    set CSI = (LexBFS:CSeq(G)).i;    set CSJ = (LexBFS:CSeq(G)).j;
    set VLI = the_VLabel_of ((LexBFS:CSeq(G)).i);
    set VLJ = the_VLabel_of ((LexBFS:CSeq(G)).j);
    set V2I = the_V2Label_of ((LexBFS:CSeq(G)).i);
    set V2J = the_V2Label_of ((LexBFS:CSeq(G)).j);
A5: a in CSI.labeledV() by A1;
A6: b in CSI.labeledV() by A2;
A7: G.order() = (LexBFS:CSeq(G)).Lifespan() by Th51;
    VLI.b <= G.order() by A7,Th22; then
A8: G.order() -' VLI.b = G.order() - VLI.b by BINARITH:50;
A9: j < G.order() by A3,XREAL_1:46,A8,A4;
    G.order() -' VLI.b <= G.order() by BINARITH:52; then
A10:G.order() -' j = G.order() - (G.order() - VLI.b) by A4,A8,BINARITH:50;
    (LexBFS:CSeq(G)).PickedAt(j) = b by A4,A7,A6,Th27; then
A11: LexBFS:PickUnnumbered(CSJ) = b by A9,Th53;
A12: dom V2J = the_Vertices_of CSJ by Th45;
    CSI == CSJ & a in the_Vertices_of CSI by Th43; then
A13: a in the_Vertices_of CSJ by GLIB_000:def 36;
    now assume a in dom VLJ; then
    A14: a in CSJ.labeledV();
        VLI.b < VLJ.a by A10, A7,A14,Th29;
      hence contradiction by A3, Th26,A14,A5;
    end;
  hence (V2J.a,1)-bag <= (V2J.b,1)-bag, InvLexOrder NAT
       by A13, A11,A12,Th40;
end;

:: Any value in our v2label corresponds to a vertex that we are
:: adjacent to in our in our vlabel
theorem Th64:
for G being finite _Graph, i,j being natural number,
    v being Vertex of (LexBFS:CSeq(G)).i
 st j in (the_V2Label_of ((LexBFS:CSeq(G)).i)).v
  ex w being Vertex of (LexBFS:CSeq(G)).i st
     w in dom the_VLabel_of ((LexBFS:CSeq(G)).i) &
     (the_VLabel_of ((LexBFS:CSeq(G)).i)).w = j & v in G.AdjacentSet{w}
proof let G be finite _Graph, i,j be Nat;
    let v be Vertex of (LexBFS:CSeq(G)).i;
    set CSI = (LexBFS:CSeq(G)).i;    set VLI = the_VLabel_of CSI;
    set V2I = the_V2Label_of CSI;       set n = G.order() -' j;
    set CSN = (LexBFS:CSeq(G)).n;    set VLN = the_VLabel_of CSN;
    assume A1: j in V2I.v; then
    consider w being Vertex of CSI such that
A2: LexBFS:PickUnnumbered(CSN) = w and
    not w in dom VLN and
A3: v in G.AdjacentSet({w}) by Th60;
    V2I.v c= Seg G.order() \ Seg (G.order() -' i) by Th55; then
A4: G.order() -' i < j & j <= G.order() by A1,Th5;
    G.order() -' j = G.order() - j by A4,BINARITH:50; then
A5: n < G.order() by A4,XREAL_1:46; then
A6: G.order() -' n = G.order() - n by BINARITH:50;
A7: G.order() - n = G.order() - (G.order() - j) by A4,BINARITH:50;
A8: G.order() = (LexBFS:CSeq(G)).Lifespan() by Th51;
A9: w = (LexBFS:CSeq(G)).PickedAt(n) by A2,A5,Th53;
    now per cases;
    suppose G.order() - i >= 0;
      G.order() - i < G.order() - n by A4,A7,BINARITH:def 3; then
      G.order() - i + i < G.order() - n + i by XREAL_1:8; then
      G.order() + n < G.order() + i - n + n by XREAL_1:8; then
      n + G.order() - G.order() < i + G.order() - G.order() by XREAL_1:11;
      hence n < i; end;
    suppose G.order() - i < 0; then
      G.order() - i + i < 0 + i by XREAL_1:8;
      hence n < i by A5,XREAL_1:2; end;
    end; then
    w in CSI.labeledV() & VLI.w = G.order()-'n by A5,A8,A9,Th28;
    hence ex w being Vertex of CSI st w in dom VLI & VLI.w = j &
         v in G.AdjacentSet({w}) by A3, A7, A6;
end;

definition let G be natural-vlabeled VGraph;
  attr G is with_property_L3 means                               :Def34:
for a,b,c being Vertex of G st a in dom the_VLabel_of G &
    b in dom the_VLabel_of G & c in dom the_VLabel_of G &
    (the_VLabel_of G).a < (the_VLabel_of G).b &
    (the_VLabel_of G).b < (the_VLabel_of G).c &
    a,c are_adjacent & not b,c are_adjacent
  ex d being Vertex of G st d in dom the_VLabel_of G &
     (the_VLabel_of G).c < (the_VLabel_of G).d &
     b,d are_adjacent & not a,d are_adjacent &
     for e being Vertex of G
       st e <> d & e,b are_adjacent & not e,a are_adjacent
        holds (the_VLabel_of G).e < (the_VLabel_of G).d;
end;

theorem Th65:
for G being finite _Graph, n being natural number
  holds (LexBFS:CSeq(G)).n is with_property_L3
proof let G be finite _Graph, i be Nat;
    set CSi = (LexBFS:CSeq(G)).i;  set VLi = the_VLabel_of CSi;
    now let a, b, c be Vertex of CSi such that
A1: a in dom VLi & b in dom VLi & c in dom VLi &
    VLi.a < VLi.b & VLi.b < VLi.c &
    a,c are_adjacent & not b,c are_adjacent;
A2: CSi == G by Th42;
A3: (LexBFS:CSeq(G)).Lifespan() = G.order() by Th51;
A4: CSi.labeledV() <> {} by A1;

A5: VLi.a < VLi.c by A1,XREAL_1:2;
    reconsider ag = a, bg = b, cg = c as Vertex of G by A2,GLIB_000:def 36;
    now assume
    A6: for d being Vertex of CSi st d in dom VLi & VLi.c < VLi.d &
            d,b are_adjacent holds d,a are_adjacent;
        reconsider ai = a, bi = b, ci = c as Vertex of CSi;
        set k = G.order() -' VLi.bi;    set CSb = (LexBFS:CSeq(G)).k;
        set VLb = the_VLabel_of CSb;
   A7: CSb == G by Th42; then
   A8: CSb == CSi by A2, GLIB_000:88;
        reconsider ab = a, bb = b as Vertex of CSb by A8,GLIB_000:def 36;
        reconsider cb = c as Vertex of CSb by A8,GLIB_000:def 36;
        reconsider sbb = (the_V2Label_of CSb).bb, sba = (the_V2Label_of CSb).ab
            as finite Subset of NAT;
   A9: (Seg G.order()) \ Seg (G.order() -' k) c= Seg G.order() by XBOOLE_1:36;
        sbb c= (Seg G.order()) \ Seg (G.order() -' k) by Th55; then
    A10: sbb c= Seg G.order() by A9,XBOOLE_1:1;
        sba c= (Seg G.order()) \ Seg (G.order() -' k) by Th55; then
    A11: sba c= Seg G.order() by A9,XBOOLE_1:1;
    A12: not bb,cb are_adjacent & ab,cb are_adjacent by A1,A8,CHORD:44;
         not b in CSb.AdjacentSet({cb}) by A12,CHORD:52; then
  A13: not b in G.AdjacentSet({cg}) by A7,CHORD:51;
         a in CSb.AdjacentSet({cb}) by A12,A1,CHORD:52; then
  A14: a in G.AdjacentSet({cg}) by A7,CHORD:51;
  A15: c in CSi.labeledV()&b in CSi.labeledV() & VLi.bi < VLi.ci by A1;then
   A16: cb in CSb.labeledV() by A3,Th30;
        set kc = G.order() -' VLi.c;
        set CSc = (LexBFS:CSeq(G)).kc;
        set VLc = the_VLabel_of CSc;
   A17: 1 <= VLi.c & VLi.c <= G.order() by A15,A3,Th22;
   A18: G.order() -' VLi.c = G.order() - VLi.c by A17, BINARITH:50; then
   A19: kc < G.order() by A1,XREAL_1:46;
   A20: kc < k by A17,A1,Th2;
        ci in CSi.labeledV() by A1; then
        (LexBFS:CSeq(G)).PickedAt(kc) = cb by A3,Th27; then
   A21: cb = LexBFS:PickUnnumbered(CSc) by A19,Th53;
   A22: G.order() -' kc = G.order() - (G.order() - VLi.c)
             by A18, A19,BINARITH:50;
        now assume A23: a in dom VLc; then
        A24: VLc.a in rng VLc by FUNCT_1:def 5;
            rng VLc=(Seg G.order()) \ Seg (G.order()-'kc) by A3,Th21;then
        A25: VLi.c < VLc.a by A22, A24,Th5;
            a in CSc.labeledV() & a in CSi.labeledV() & VLi.a < VLi.c
                  by A23,A1,XREAL_1:2;
          hence contradiction by A25, Th26;
        end; then
        VLi.c in sba by A22, A14,A19,A20,A21,Th57; then
    A26: VLb.cb in sba by A16,A15,Th26;
    A27: now assume VLb.cb in sbb; then
            consider z being Vertex of CSb such that
        A28: z in dom VLb and
        A29: VLb.z = VLb.cb and
        A30: bb in G.AdjacentSet({z}) by Th64;
            VLb is one-to-one by Th25;
          hence contradiction by A13,A30,A16,A28,A29,FUNCT_1:def 8;
        end;
    A31: (sbb,1)-bag <> (sba,1)-bag by A26,A27,Th8;
    A32: (sba,1)-bag <= (sbb,1)-bag, InvLexOrder NAT by A1,Th63;

        set j = (the_VLabel_of CSb).cb;
    A33: (sbb,1)-bag.j = 0 by A27,UPROOTS:8;
    A34: (sbb,1)-bag.j < (sba,1)-bag.j by A33,A26,UPROOTS:9;
        [(sbb,1)-bag,(sba,1)-bag] in InvLexOrder NAT proof
        per cases;
        suppose for k being Ordinal st j in k & k in NAT
                  holds (sbb,1)-bag.k = (sba,1)-bag.k;
       hence [(sbb,1)-bag,(sba,1)-bag] in InvLexOrder NAT by A34
,BAGORDER:def 8;
        end;
        suppose not for k being Ordinal st j in k & k in NAT
                  holds (sbb,1)-bag.k = (sba,1)-bag.k;
            then consider qq being Ordinal such that
        A35: j in qq & qq in NAT and
        A36: (sbb,1)-bag.qq <> (sba,1)-bag.qq;

            defpred M[Nat] means
                j in $1 & (sbb,1)-bag.$1 <> (sba,1)-bag.$1;

            reconsider q = qq as Element of NAT by A35;
        A37: ex k being Element of NAT st M[k] by A35,A36;
        A38: for k being Element of NAT st M[k] holds k <= G.order() proof
                let k be Element of NAT such that A39: M[k];
                consider ok being Ordinal such that
            A40: ok = k and
                j in ok & ok in NAT and
            A41: (sbb,1)-bag.ok <> (sba,1)-bag.ok by A39;
                k in sba or not k in sba; then
            A42:(sba,1)-bag.k = 1 or (sba,1)-bag.k = 0 by UPROOTS:8,UPROOTS:9;
               per cases;
               suppose not ok in sbb; then
                 ok in sba by A41,A42,A40,UPROOTS:8;
                 hence k <= G.order() by A40,FINSEQ_1:3, A11; end;
               suppose ok in sbb;
                 hence k <= G.order() by A10, A40,FINSEQ_1:3; end;
            end;
            consider mm being Element of NAT such that
       A43: M[mm] and
       A44: for i being Element of NAT st M[i] holds i <= mm
                  from NAT_1:sch 6(A38,A37);
            j in {y where y is Element of NAT : y < mm} by A43,AXIOMS:30;then
            consider jy being Element of NAT such that
       A45: jy = j & jy < mm;
            mm in sbb or not mm in sbb; then
       A46: (sbb,1)-bag.mm = 0 or (sbb,1)-bag.mm = 1 by UPROOTS:8,UPROOTS:9;

        A47: now assume A48: (sbb,1)-bag.mm = 1; then
                mm in sbb by UPROOTS:8; then
                consider z being Vertex of CSb such that
            A49: z in dom (the_VLabel_of CSb) and
            A50: (the_VLabel_of CSb).z = mm and
            A51: b in G.AdjacentSet({z}) by Th64;
                k < i by Th29,A15,A3; then
            A52: the_VLabel_of CSb c= the_VLabel_of CSi by Th24; then
            A53:  dom (the_VLabel_of CSb) c= dom the_VLabel_of CSi
                   by RELAT_1:25; then
                z in dom the_VLabel_of CSi by A49; then
                reconsider zi = z as Vertex of CSi by A4;
           A54: [z,mm] in the_VLabel_of CSb by A49,A50,FUNCT_1:def 4; then
           A55: VLi.z = mm by A52,A53,A49,FUNCT_1:def 4;
           A56: [cb,j] in the_VLabel_of CSb by A16,FUNCT_1:def 4; then
           A57: VLi.cb = j by A52,A1,FUNCT_1:def 4;
            A58: VLi.c < VLi.zi by A56,A52,A1,FUNCT_1:def 4,A45,A55;
                reconsider zg = z as Vertex of G by A7,GLIB_000:def 36;
                bb in CSb.AdjacentSet({z}) by A7,A51, CHORD:51; then
                bb,z are_adjacent by CHORD:52; then
                zi,bi are_adjacent by A8,CHORD:44; then
                zi,ai are_adjacent by A6,A57,A45,A55,A53,A49; then
           A59: z,ab are_adjacent by A8,CHORD:44;
                a in CSb.AdjacentSet({zg}) by A5,A58,A59,CHORD:52; then
           A60: a in G.AdjacentSet({zg}) by A7,CHORD:51;
                set kc = G.order() -' VLi.z;
                set CSc = (LexBFS:CSeq(G)).kc;
                set VLc = the_VLabel_of CSc;
           A61: VLi.c < VLi.z by A54,A52,A53,A49,FUNCT_1:def 4,A57,A45;
           A62: VLi.b < VLi.z by A1,XREAL_1:2,A55,A57,A45;
           A63: z in CSi.labeledV() by A53,A49; then
           A64: 1 <= VLi.z & VLi.z <= G.order() by A3,Th22;
          A65: 0 < VLi.z by A63,Th22;
           A66: G.order() -' VLi.z = G.order() - VLi.z
                    by A64, BINARITH:50; then
           A67: kc < G.order() by A65,XREAL_1:46;
           A68: kc < k by A64,A62,Th2;
                z = (LexBFS:CSeq(G)).PickedAt(kc) by A63,A3,Th27; then
           A69: z = LexBFS:PickUnnumbered(CSc) by A67,Th53;
           A70: G.order() -' kc = G.order() - (G.order() - VLi.z)
                    by A66, A67,BINARITH:50;
                now assume A71: a in dom VLc; then
                A72: VLc.a in rng VLc by FUNCT_1:def 5;
                    rng VLc=(Seg G.order())\ Seg (G.order()-'kc)
                          by A3,Th21; then
                A73: VLi.z < VLc.a by A70, A72,Th5;
                    a in dom VLi & VLi.a < VLi.c by A1,XREAL_1:2; then
                A74: VLi.a < VLi.z by A61,XREAL_1:2;
                    a in CSc.labeledV() & a in CSi.labeledV() by A71,A1;
                  hence contradiction by A73,A74, Th26;
                end; then
                G.order() -' kc in sba by A67,A68,A69,A60,Th57;
              hence contradiction by A48,A43,A70,A55,UPROOTS:9;
            end;
        A75: (sbb,1)-bag.mm < (sba,1)-bag.mm by A47,A46,A43;
            now let k be Ordinal such that
            A76: mm in k & k in NAT;
                reconsider kk = k as Element of NAT by A76;
                assume A77: (sbb,1)-bag.k <> (sba,1)-bag.k;
            A78: j in k by A76,A43,ORDINAL1:19;
                mm in {y where y is Element of NAT : y < kk}
                   by A76,AXIOMS:30; then
                consider mmy being Element of NAT such that
            A79: mmy = mm & mmy < kk;
              thus contradiction by A78,A44,A77,A79;
            end;
            hence [(sbb,1)-bag,(sba,1)-bag] in InvLexOrder NAT
               by A75,BAGORDER:def 8; end;
        end; then
        (sbb,1)-bag <= (sba,1)-bag, InvLexOrder NAT by TERMORD:def 2; then
    A80: (sbb,1)-bag < (sba,1)-bag, InvLexOrder NAT by A31,TERMORD:def 3;
      thus contradiction by A80, A32, TERMORD:5;
    end; then
    consider x being Vertex of CSi such that
A81: x in dom VLi & VLi.c < VLi.x & x,b are_adjacent & not x,a are_adjacent;

    defpred P[Nat] means
     ex v being Vertex of CSi st v in dom VLi &
        b,v are_adjacent & not a,v are_adjacent &
        VLi.c < VLi.v & VLi.v = $1;

A82: ex k being Element of NAT st P[k] by A81;
A83: for k being Element of NAT st P[k] holds k <= G.order() proof
        let k be Element of NAT such that A84: P[k];
        consider v being Vertex of CSi such that
    A85: v in dom VLi & v,b are_adjacent & not v,a are_adjacent and
    A86: VLi.c < VLi.v & VLi.v = k by A84;
        k in rng the_VLabel_of CSi by A85,A86,FUNCT_1:def 5; then
    A87: k in (Seg G.order()) \ Seg (G.order()-'i) by A3,Th21;
        (Seg G.order()) \ Seg (G.order()-'i) c= Seg G.order() by XBOOLE_1:36;
      hence k <= G.order() by A87,FINSEQ_1:3;
    end;
    ex k being Element of NAT st P[k] &
       for n being Element of NAT st P[n] holds n <= k
       from NAT_1:sch 6(A83,A82); then
    consider k being Element of NAT such that
A88: P[k] and
A89: for n being Element of NAT st P[n] holds n <= k;
    consider v being Vertex of CSi such that
A90: v in dom VLi & b,v are_adjacent & not a,v are_adjacent and
A91: VLi.c < VLi.v and
A92: VLi.v = k by A88;

    for d being Vertex of CSi
       st d <> v & d,b are_adjacent & not d,a are_adjacent
        holds  VLi.d < VLi.v
    proof let d be Vertex of CSi such that
    A93: d <> v & d,b are_adjacent & not d,a are_adjacent;
      per cases;
      suppose VLi.d <= VLi.c;
        hence VLi.d < VLi.v by A91,XREAL_1:2; end;
      suppose A94: VLi.c < VLi.d;
   A95: now assume not d in dom VLi; then
          VLi.d = 0 by FUNCT_1:def 4;
          hence contradiction by A94;
        end;
    A96: VLi.d <= k by A95,A94,A93,A89;
        VLi is one-to-one by Th25; then
        VLi.d <> VLi.v by A93,A95,A90,FUNCT_1:def 8;
      hence VLi.d < VLi.v by A92,A96,REAL_1:def 5; end;
    end;
    hence ex d being Vertex of CSi st
    d in dom VLi & VLi.c < VLi.d & b,d are_adjacent & not a,d are_adjacent &
     for e being Vertex of CSi
       st e <> d & e,b are_adjacent & not e,a are_adjacent
        holds VLi.e < VLi.d by A90,A91;
    end;
  hence thesis by Def34;
end;

theorem Th66: :: Theorem 4.3, Golumbic p. 86
for G being finite chordal natural-vlabeled VGraph
  st G is with_property_L3 & dom the_VLabel_of G = the_Vertices_of G
   for V being VertexScheme of G st V" = the_VLabel_of G holds V is perfect
proof let G be finite chordal natural-vlabeled VGraph such that
A1: G is with_property_L3 and
A2: dom the_VLabel_of G = the_Vertices_of G;
     let V be VertexScheme of G such that
A3: V" = the_VLabel_of G;
     assume not V is perfect;
     then consider k being non empty Nat such that
 A4: k <= len V and
 A5: not for H being inducedSubgraph of G, V.followSet(k)
   for v being Vertex of H st v = V.k holds v is simplicial by CHORD:def 13;
    consider HH being (inducedSubgraph of G,V.followSet(k)),
              hv being Vertex of HH such that
 A6: hv = V.k and
 A7: not hv is simplicial by A5;
A8: 0+1 <= k by NAT_1:38;

     set VLG = the_VLabel_of G;
A9: V is one-to-one by CHORD:def 12; then
A10: VLG is one-to-one by A3,FUNCT_1:62;
A11:  rng V = the_Vertices_of G by CHORD:def 12;
     consider ha,hb being Vertex of HH such that
 A12: ha<>hb & hv<>ha & hv<>hb and
 A13: hv,ha are_adjacent and
 A14: hv,hb are_adjacent and
 A15: not ha,hb are_adjacent by A7,CHORD:69;

A16: V.followSet(k) is non empty Subset of the_Vertices_of G
        by A4,CHORD:107; then
A17: the_Vertices_of HH = V.followSet(k) by GLIB_000:def 39;
     hv in the_Vertices_of HH & ha in the_Vertices_of HH &
     hb in the_Vertices_of HH; then
     reconsider v=hv,aa=ha,bb=hb as Vertex of G;
A18:
    for x,y being Vertex of G, i,j being Nat st i in dom V & j in dom V &
        V/.i = x & V/.j = y holds i < j iff VLG.x < VLG.y
    proof let x,y being Vertex of G;
        let i,j be Nat such that A19: i in dom V & j in dom V and
    A20: V/.i = x & V/.j = y;
    A21: V.i = x & V.j = y by A19,A20,FINSEQ_4:def 4;
    A22: VLG.y = j by A19,A9,A3,A21,FUNCT_1:56;
        thus i<j implies VLG.x < VLG.y by A19,A9,A3,A21,FUNCT_1:56,A22;
        thus VLG.x < VLG.y implies i < j by A19,A9,A3,A21,FUNCT_1:56,A22;
    end;

    now A23: VLG.aa <> VLG.bb by A12, A10, A2, FUNCT_1:def 8;
      per cases by A23, REAL_1:def 5;
       suppose A24: VLG.aa < VLG.bb;
         take aa, bb;
         thus aa in V.followSet(k) by A17;
         thus VLG.aa < VLG.bb by A24;
         thus v,aa are_adjacent by A13,A16,CHORD:45;
         thus v,bb are_adjacent by A14,A16,CHORD:45;
         thus not aa,bb are_adjacent by A15,A16,CHORD:45;
       end;
       suppose A25: VLG.aa > VLG.bb;
         take bb, aa;
         thus bb in V.followSet(k) by A17;
         thus VLG.aa > VLG.bb by A25;
         thus v,bb are_adjacent by A14,A16,CHORD:45;
         thus v,aa are_adjacent by A13,A16,CHORD:45;
         thus not bb,aa are_adjacent by A15,A16,CHORD:45;
       end;
     end; then
     consider a,bb being Vertex of G such that
  A26: a in V.followSet(k) and
  A27: VLG.a < VLG.bb and
  A28: v,a are_adjacent and
  A29: v,bb are_adjacent and
  A30: not a,bb are_adjacent;

     defpred Q[Nat] means  $1 in dom V & VLG.a < VLG.(V/.$1) &
     a <> V/.$1 & v,V/.$1 are_adjacent & not a,V/.$1 are_adjacent;
 A31: for k being Element of NAT st Q[k] holds k <= len V by FINSEQ_3:27;
 A32: ex k being Element of NAT st Q[k] proof
        consider mbb being set such that
   A33: mbb in dom V & bb = V.mbb by A11,FUNCT_1:def 5;
        reconsider mbb as Element of NAT by A33;
        take mbb;
        thus mbb in dom V by A33;
        thus VLG.a < VLG.(V/.mbb) by A33,FINSEQ_4:def 4,A27;
        thus a <> V/.mbb by A33,FINSEQ_4:def 4,A27;
        thus v,V/.mbb are_adjacent by A33,FINSEQ_4:def 4,A29;
        thus not a,V/.mbb are_adjacent by A33,FINSEQ_4:def 4,A30;
     end;
     consider mb being Element of NAT such that
 A34: Q[mb] and
     for n being Element of NAT st Q[n] holds n <= mb
         from NAT_1:sch 6(A31,A32);

     reconsider v,a,b = V/.mb as Vertex of G;
A35: v <> b by A34, A28;

A36: k in dom V by A4,A8,FINSEQ_3:27; then
A37: v = V/.k by A6,FINSEQ_4:def 4;
     consider ma being set such that
A38: ma in dom V & a = V.ma by A11,FUNCT_1:def 5;
     reconsider ma as Element of NAT by A38;
A39: a = V/.ma by A38,FINSEQ_4:def 4;

A40: now assume ma <= k; then
     A41: ma < k by REAL_1:def 5,A29,A30,A6,A38;
         a in the_Vertices_of G; then
         a in rng V & V is one-to-one by CHORD:def 12; then
         a..V >= k by A36,A26,CHORD:16; then
         a..V > ma by A41,XREAL_1:2;
       hence contradiction by A38,FINSEQ_4:34;
     end;

   defpred R[Nat] means
    ex P being Walk of G, v1,v2,v3,v4 being Vertex of G st
      P is Path-like & P is open & P is chordless & P.length() = $1-1 &
       v1 = P.(len P-2) & v2 = P.3 & v3 = P.last() & v4 = P.first() &
       VLG.v4 > VLG.v3 & VLG.v3 > VLG.v2 & VLG.v2 > VLG.v1 &
       (for x being set st x in P.vertices() holds VLG.x <= VLG.v4) &
       for x being Vertex of G
         st x <> v4 & x,v2 are_adjacent & not x,v1 are_adjacent
           holds VLG.x < VLG.v4;

A42: VLG.v < VLG.a by A39,A37,A36,A38,A18,A40;

 A43: R[4] proof
         consider c being Vertex of G such that
     A44: c in dom VLG & VLG.b < VLG.c and
     A45: c,a are_adjacent & not c,v are_adjacent and
     A46: for x being Vertex of G
           st x <> c & x,a are_adjacent & not x,v are_adjacent
             holds VLG.x < VLG.c by A2,A42,A34,A1,Def34;

         consider P being Path of G,e1,e2 being set such that
     A47: P is open & len P = 5 & P.length() = 2 and
    A48: e1 Joins b,v,G & e2 Joins v,a,G & P.edges() = {e1,e2} &
         P.vertices() = {b,v,a} and
     A49: P.1 = b & P.3 = v & P.5 = a by A28,A34,A35,CHORD:47;
         P.first() = b & P.last() = a
             by A49,A47; then
     A50: P is chordless by A34,A47,CHORD:90;
         consider e being set such that
     A51: e Joins P.last(),c,G by A45,A49,A47,CHORD:def 3;

         set Qr = P.addEdge(e);
         set Q = Qr.reverse();
     A52: Qr.length() = 2+1 by A51,A47,Lm4;
     A53: len Qr = 5+2 by A51,A47,GLIB_001:65;
         1 in dom P & 3 in dom P & 5 in dom P by A47,FINSEQ_3:27; then
     A54: Qr.1 = b & Qr.3 = v & Qr.5 = a by A51,A49,GLIB_001:66;
     A55: Qr.last() = c by A51,GLIB_001:64;

     A56: now let x be set such that A57: x in P.vertices();
           per cases by A57,A48,ENUMSET1:def 1;
           suppose x = b; hence VLG.x <= VLG.b; end;
           suppose x = v; hence VLG.x <= VLG.b by A42,A34,XREAL_1:2; end;
           suppose x = a; hence VLG.x <= VLG.b by A34; end;
         end;
     A58: not c in P.vertices() by A44,A56;
      not ex e being set st e Joins P.(len P-2),c,G by A49,A47,A45,CHORD:def 3;
        then Qr is Path-like & Qr is open & Qr is chordless
                 by A47,A58,A50,A51,CHORD:97; then
     A59: Q is Path-like & Q is open & Q is chordless
                 by CHORD:91,GLIB_001:121,149;
     A60: 1 in dom Qr & 3 in dom Qr & 5 in dom Qr & 7 in dom Qr
             by A53,FINSEQ_3:27;
     A61: Q.length() = (3+1)-1 by A52,Lm5;
     A62: dom Q = dom Qr & len Q = len Qr by GLIB_001:22;
         v = Q.(7-3+1) &  a = Q.(7-5+1) & b = Q.(len Qr-1+1) &
         c = Q.(7-7+1) by A55,A54,A60,A53,GLIB_001:25; then
     A63: v = Q.(len Q-2) & a = Q.3 &  b = Q.last() &
         c = Q.first() by A62,A53;
     A64: VLG.c > VLG.b & VLG.b > VLG.a & VLG.a > VLG.v
               by A39,A37,A36,A38,A18,A40,A34,A44;
         now let x be set such that A65: x in Q.vertices();
             x in Qr.vertices() by A65,GLIB_001:93; then
         A66: x in P.vertices() \/ {c} by A51,GLIB_001:96;
           per cases by A66,XBOOLE_0:def 2;
           suppose x in P.vertices(); then VLG.x <= VLG.b by A56;
           hence VLG.x <= VLG.c by A44,XREAL_1:2; end;
           suppose x in {c}; hence VLG.x <= VLG.c by TARSKI:def 1; end;
         end;
       hence thesis by A59,A61,A63,A64,A46;
     end;

 A67: for k being Element of NAT st 4 <= k & R[k] holds R[k+1] proof
         let kk be Element of NAT such that A68: 4 <= kk and A69: R[kk];
         reconsider k=kk as non empty Nat by A68;
         consider P being Walk of G, v1,v2,v3,v4 being Vertex of G such that
     A70: P is Path-like & P is open & P is chordless & P.length() = k-1 and
     A71: v1 = P.(len P-2) & v2 = P.3 & v3 = P.last() & v4 = P.first() and
     A72: VLG.v4 > VLG.v3 & VLG.v3 > VLG.v2 & VLG.v2 > VLG.v1 and
    A73: for x being set st x in P.vertices() holds VLG.x <= VLG.v4 and
     A74: for x being Vertex of G
           st x <> v4 & x,v2 are_adjacent & not x,v1 are_adjacent
            holds VLG.x < VLG.v4 by A69;

     A75: len P = 2*(k-1) + 1 by A70,GLIB_001:113;
         2*k >= 2*4 by A68,XREAL_1:66; then
     A76: 2*k-1 >= 8-1 by XREAL_1:11;
         2*0+1 < 2*1+1 & 3 < len P by A76,A75,XREAL_1:2; then
         consider ez being set such that
     A77: ez Joins P.1,P.3,G by A70,CHORD:92;
         now let e be set such that A78: e Joins v4,v3,G;
             2*0+1 < len P by A76,A75,XREAL_1:2; then
         A79: 1+2 = len P by A71,A78,A70,CHORD:92;
            thus contradiction by A68,A75,A79;
         end; then
     A80: v4,v2 are_adjacent & not v4,v3 are_adjacent by A77,A71,CHORD:def 3;

         consider v5 being Vertex of G such that
     A81: v5 in dom VLG & VLG.v4 < VLG.v5 and
     A82: v5,v3 are_adjacent & not v5,v2 are_adjacent and
     A83: for x being Vertex of G
           st x <> v5 & x,v3 are_adjacent & not x,v2 are_adjacent
           holds VLG.x < VLG.v5 by A72,A80,A1,A2,Def34;

     A84: now assume A85: v5,v1 are_adjacent;
             VLG.v2 < VLG.v4 by A72,XREAL_1:2; then
         A86: VLG.v1 < VLG.v2 & VLG.v2 < VLG.v5 by A72,A81,XREAL_1:2;
             consider v6 being Vertex of G such that
         A87: v6 in dom VLG & VLG.v5 < VLG.v6 and
         A88: v6,v2 are_adjacent & not v6,v1 are_adjacent and
             for x being Vertex of G
              st x <> v6 & x,v2 are_adjacent & not x,v1 are_adjacent
                holds VLG.x < VLG.v6 by A85,A82,A86,A1,A2,Def34;
             VLG.v6 < VLG.v4 by A88,A87,A74,A81;
           hence contradiction by A87,A81,XREAL_1:2;
         end;
         consider e being set such that
     A89: e Joins P.last(),v5,G by A71,A82,CHORD:def 3;
         set Qr = P.addEdge(e);
         set Q = Qr.reverse();
     A90: Qr.length() = k-1+1 by A89,A70,Lm4;
     A91: len Qr = len P + 2 by A89,GLIB_001:65;
         1 <= len P by A76,A75,XREAL_1:2; then
         P.(len Qr-2) = v3 & len P in dom P by A91,A71,FINSEQ_3:27; then
     A92: v3 = Qr.(len Qr - 2) & len Qr-2 in dom Qr by A91,A89,Lm6;
         1 <= 3 & 3 <= len P by A76,A75,XREAL_1:2; then
         3 in dom P by FINSEQ_3:27; then
     A93: v2 = Qr.3 & 3 in dom Qr by A89,A71,Lm6;
     A94: v4 = Qr.first() & v5 = Qr.last() by A71,A89,GLIB_001:64;
    A95: not v5 in P.vertices() by A73, A81;
    not ex e being set st e Joins P.(len P-2),v5,G by A71,A84,CHORD:def 3; then
         Qr is Path-like & Qr is open & Qr is chordless
             by A70,A89,A95,CHORD:97; then
     A96: Q is Path-like & Q is open & Q is chordless
                 by CHORD:91,GLIB_001:121,149;
     A97: Q.length() = (k+1)-1 by A90,Lm5;
     A98: len Q = len Qr by GLIB_001:22; then
         v2 = Q.(len Q-3+1) & v3 = Q.(len Q-(len Qr-2)+1)
            by A93,A92,GLIB_001:25; then
     A99: v2 = Q.(len Q-2) & v3 = Q.3 & v4 = Q.last() & v5 = Q.first()
          by A98,A94,GLIB_001:23;
     A100: now let x be set such that A101: x in Q.vertices();
             x in Qr.vertices() by A101,GLIB_001:93; then
         A102: x in P.vertices() \/ {v5} by A89,GLIB_001:96;
           per cases by A102,XBOOLE_0:def 2;
           suppose x in P.vertices(); then VLG.x <= VLG.v4 by A73;
             hence VLG.x <= VLG.v5 by A81,XREAL_1:2; end;
           suppose x in {v5};
             hence VLG.x <= VLG.v5 by TARSKI:def 1; end;
         end;
       thus thesis by A96,A97,A99,A72,A81,A83,A100;
     end;
A103: for i being Element of NAT st 4 <= i holds R[i] from NAT_1:sch 9(A43,A67
);
    4 <= 11 & 11 <= 11+G.order() by NAT_1:29; then
    4 <= G.order()+11 by XREAL_1:2; then
    R[G.order()+11] by A103; then
    consider P being Walk of G, v1,v2,v3,v4 being Vertex of G such that
A104: P is Path-like & P is open & P is chordless and
A105: P.length() = (G.order()+11)-1 and
    v1 = P.(len P-2) & v2 = P.3 & v3 = P.last() & v4 = P.first() and
    VLG.v4 > VLG.v3 & VLG.v3 > VLG.v2 & VLG.v2 > VLG.v1 and
    for x being Vertex of G
       st x <> v4 & x,v2 are_adjacent & not x,v1 are_adjacent
         holds VLG.x < VLG.v4;
   len P = 2*(G.order()+10)+1 by A105,GLIB_001:113; then
   2*G.order()+21 + 1 = 2*len P.vertexSeq() by GLIB_001:def 14; then
   G.order() + 11 <= G.order() + 1 by A104,GLIB_001:155;
  hence contradiction by XREAL_1:10;
end;

theorem :: Theorem 4.3, Golumbic p. 86
for G being finite chordal VVGraph holds
  (the_VLabel_of (LexBFS:CSeq(G)).Result())" is perfect VertexScheme of G
proof let G be finite chordal VVGraph;
   set Hh = (LexBFS:CSeq(G)).Result();
   reconsider H = Hh as finite chordal
                        natural-vlabeled VVGraph by Def18;
A1: H == G by Th42;
A2: H is with_property_L3 by Th65;
   H.labeledV() = the_Vertices_of G by Th61; then
A3: dom the_VLabel_of H = the_Vertices_of H by A1,GLIB_000:def 36;
   set V = (the_VLabel_of H)";
   V is VertexScheme of G by Th62; then
   reconsider Vh=V as VertexScheme of H by A1, CHORD:106;
   the_VLabel_of H is one-to-one by Th25; then
A4: V" = the_VLabel_of H by FUNCT_1:65;
   Vh is perfect by Th66,A2,A3,A4;
  hence (the_VLabel_of Hh)" is perfect VertexScheme of G by A1,CHORD:110;
end;

begin :: The Maximum Cardinality Search algorithm

definition let G be finite _Graph;
  func MCS:Init(G) -> finite natural-vlabeled natural-v2labeled VVGraph equals
    G.set(VLabelSelector, {}).set(V2LabelSelector, the_Vertices_of G --> 0);
  coherence proof
    set G1 = G.set(VLabelSelector, {});
    set g  = the_Vertices_of G --> {};
A1: G1 == G by GLIB_003:8;
    dom g = the_Vertices_of G by FUNCOP_1:19; then
    dom g = the_Vertices_of G1 by A1,GLIB_000:def 36; then
    reconsider f = g as PartFunc of the_Vertices_of G1, rng g by PARTFUN1:24;
    set G2 = G1.set(V2LabelSelector, f);
A2: the_V2Label_of G2 = f by GLIB_000:11;
A3: the_VLabel_of G2 = the_VLabel_of G1 by GLIB_000:12;
A4: the_VLabel_of G2 is natural-yielding by A3,GLIB_000:11;
    rng the_V2Label_of G2 = {0} by A2,FUNCOP_1:14;
    then the_V2Label_of G2 is natural-yielding by SEQM_3:def 8;
  hence thesis by A4,Def7,Def11;
 end;
end;

definition let G be finite natural-v2labeled VVGraph;
  assume A1: dom the_V2Label_of G = the_Vertices_of G;
  func MCS:PickUnnumbered(G) -> Vertex of G means :Def36:
  it = choose the_Vertices_of G if dom the_VLabel_of G = the_Vertices_of G
  otherwise ex S being finite non empty natural-membered set, F being Function
             st S = rng F
           & F = (the_V2Label_of G) | (the_Vertices_of G \ dom the_VLabel_of G)
           & it = choose (F " {max S});
  existence proof
    set VLG = the_VLabel_of G;     set V2G = the_V2Label_of G;
    set VG = the_Vertices_of G;    set F = V2G | (VG \ dom VLG);
    set S = rng F;
  per cases;
  suppose dom VLG = VG;
  hence thesis; end;
  suppose A2: dom VLG <> VG;
A3: dom F c= dom V2G & rng F c= rng V2G by RELAT_1:89,99;
A4: dom F c= the_Vertices_of G by A1,RELAT_1:89;
A5: dom VLG c= VG by GLIB_003:7;
    dom F = dom V2G /\ (VG \ dom VLG) by FUNCT_1:68; then
A6: dom F = (VG /\ VG) \ dom VLG by A1,XBOOLE_1:49;
A7: now assume dom F = {}; then
      VG c= dom VLG by A6,XBOOLE_1:37;
     hence contradiction by A2,A5,XBOOLE_0:def 10;
    end;
A8: now let x be set such that A9: x in S;
    A10: x in rng V2G by A3,A9;
        rng V2G c= NAT by SEQM_3:def 8;
        hence x is natural by A10, ORDINAL1:def 13;
    end;
    dom F is finite by A4,FINSET_1:13; then
    reconsider S as non empty finite natural-membered set
      by A7,RELAT_1:65,A8,MEMBERED:def 5,FINSET_1:26;
    set IT = choose (F " {max S});
    set y = max S;
A11: y in S by PRE_CIRC:def 1;
A12: F " {max S} is non empty by A11,FUNCT_1:142;
    IT in dom F by A12,FUNCT_1:def 13; then
    reconsider IT as Vertex of G by A4;
  ex S being finite non empty natural-membered set, F being Function
  st S = rng F &
     F = ((the_V2Label_of G) | (the_Vertices_of G \ dom the_VLabel_of G)) &
   IT = choose (F " {max S}) & IT is Vertex of G;
     hence thesis; end;
  end;
  uniqueness;
  consistency;
end;

definition let G be finite natural-v2labeled VVGraph, v be set;
 func MCS:LabelAdjacent(G, v) -> finite natural-v2labeled VVGraph equals
 G.set(V2LabelSelector, (the_V2Label_of G).incSubset(G.AdjacentSet({v})
                                                   \ dom (the_VLabel_of G),1));
  coherence proof
    set VLG = the_VLabel_of G;   set V2G = the_V2Label_of G;
    set f = V2G.incSubset(G.AdjacentSet({v})\ dom VLG,1);
    set H = G.set(V2LabelSelector, f);
A1: dom the_V2Label_of G c= the_Vertices_of G by Th11;
A2: dom f c= the_Vertices_of G by A1, Def4;
    f is PartFunc of dom f, rng f by PARTFUN1:24; then
    reconsider g = f as PartFunc of the_Vertices_of G, rng f by A2,PARTFUN1:28;
A3: G.set(V2LabelSelector, g) is [V2Labeled];
    reconsider H as finite VVGraph by A3;
    set V2 = the_V2Label_of H;
A4: V2 = g by GLIB_000:11;
A5: dom V2 = dom V2G by A4,Def4;
A6: now let x be set such that
   A7: not x in G.AdjacentSet({v});
   A8: V2 = V2G.incSubset(G.AdjacentSet({v})\dom VLG,1) by GLIB_000:11;
       not x in G.AdjacentSet({v}) \ dom VLG by A7,XBOOLE_0:def 4;
     hence V2.x = V2G.x by A8,Def4;
   end;
A9: now let x be set such that
   A10: x in dom VLG;
   A11: V2 = V2G.incSubset(G.AdjacentSet({v})\dom VLG,1) by GLIB_000:11;
       not x in G.AdjacentSet({v}) \ dom VLG by A10,XBOOLE_0:def 4;
      hence V2.x = V2G.x by A11,Def4;
   end;
A12: now let x be set such that
   A13: x in dom V2G & x in G.AdjacentSet({v}) and
   A14: not x in dom VLG;
   A15: V2 = V2G.incSubset(G.AdjacentSet({v})\dom VLG,1) by GLIB_000:11;
       x in G.AdjacentSet({v}) \ dom VLG by A13,A14,XBOOLE_0:def 4;
     hence V2.x = V2G.x + 1 by A13,A15,Def4;
   end;
    now let x be set such that A16: x in rng V2;
        consider y being set such that
    A17: y in dom V2 and
    A18: V2.y = x by A16, FUNCT_1:def 5;
        per cases;
        suppose A19: not y in G.AdjacentSet({v}) or y in dom VLG;
        now per cases by A19;
            suppose not y in G.AdjacentSet({v});
              hence V2.y = V2G.y by A6; end;
            suppose y in dom VLG;
              hence V2.y = V2G.y by A9; end;
          end;
          hence x in NAT by A18;
        end;
        suppose y in G.AdjacentSet({v}) & not y in dom VLG; then
        V2.y = V2G.y + 1 by A17,A5,A12;
        hence x in NAT by A18; end;
    end; then
    rng V2 c= NAT by TARSKI:def 3; then
    V2 is natural-yielding by SEQM_3:def 8;
  hence G.set(V2LabelSelector, f) is finite natural-v2labeled VVGraph
   by Def11;
 end;
end;

definition let G be finite natural-vlabeled natural-v2labeled VVGraph,
               v be Vertex of G;
  redefine func MCS:LabelAdjacent(G, v) -> finite natural-vlabeled
                                           natural-v2labeled VVGraph;
  coherence proof
    set IT = MCS:LabelAdjacent(G, v);     set VL = the_VLabel_of IT;
    set V2 = the_V2Label_of IT;    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
    the_VLabel_of IT = the_VLabel_of G by GLIB_000:12;
  hence IT is finite natural-vlabeled natural-v2labeled VVGraph by Def7;
 end;
end;

definition
  let G be finite natural-vlabeled natural-v2labeled VVGraph,
      v be Vertex of G, n be natural number;
  func MCS:Update(G, v, n) -> finite natural-vlabeled natural-v2labeled
                              VVGraph equals
       MCS:LabelAdjacent(G.labelVertex(v, G.order()-'n), v);
   coherence proof   set k = G.order()-'n;
      reconsider Gl = G.labelVertex(v, k) as
         finite natural-vlabeled natural-v2labeled VVGraph;
      Gl == G by GLIB_003:47; then
      reconsider vv = v as Vertex of Gl by GLIB_000:def 36;
      MCS:LabelAdjacent(Gl, vv) is
         finite natural-vlabeled natural-v2labeled VVGraph;
      hence thesis;
   end;
end;

definition let G be finite natural-vlabeled natural-v2labeled VVGraph;
  func MCS:Step(G)
       -> finite natural-vlabeled natural-v2labeled VVGraph equals
          :Def39: G if G.order() <= card (dom the_VLabel_of G)
                  otherwise MCS:Update(G,
                                       MCS:PickUnnumbered(G),
                                       card (dom the_VLabel_of G));
  coherence; consistency;
end;

definition let G be finite _Graph;
  func MCS:CSeq(G)
       -> finite natural-vlabeled natural-v2labeled VVGraphSeq means
       :Def40: it.0 = MCS:Init(G) &
              for n being natural number holds it.(n+1) = MCS:Step(it.n);
  existence proof
     defpred P[set,set,set] means
      ($2 is finite natural-vlabeled natural-v2labeled VVGraph & $1 is Nat &
          ex nn being Nat,Gn,Gn1 being finite natural-vlabeled
                                       natural-v2labeled VVGraph st
          $1 = nn & $2 = Gn & $3 = Gn1 & Gn1 = MCS:Step(Gn)) or
      ((not $2 is finite natural-vlabeled natural-v2labeled VVGraph or
        not $1 is Nat) & $2 = $3);

    now let n,x be set;
        now per cases;
        suppose A1: x is finite natural-vlabeled natural-v2labeled VVGraph
                  & n is Nat; then
          reconsider Gn=x as finite natural-vlabeled natural-v2labeled VVGraph;
          reconsider nn = n as Nat by A1;
          consider SGn being finite natural-vlabeled
                             natural-v2labeled VVGraph such that
      A2: SGn = MCS:Step(Gn);
         thus ex y being set st P[n,x,y] by A1,A2;
        end;
        suppose not x is finite natural-vlabeled
                                natural-v2labeled VVGraph or not n is Nat;
            hence ex y being set st P[n,x,y]; end;
        end;
        hence ex y being set st P[n,x,y];
    end; then
A3: for n being Element of NAT for x being set ex y being set st P[n,x,y];
A4: for n being Element of NAT for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2]
    holds y1 = y2;
    consider IT being Function such that
A5: dom IT = NAT & IT.0 = MCS:Init(G) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
      from RECDEF_1:sch 1(A3,A4);
    reconsider IT as ManySortedSet of NAT by A5, PBOOLE:def 3;
    defpred P2[Nat] means IT.$1 is finite natural-vlabeled
                                          natural-v2labeled VVGraph;
A6: P2[0] by A5;
A7: now let n be Element of NAT; assume P2[n]; then
         consider nn being Nat, Gn,Gn1 being finite natural-vlabeled
                 natural-v2labeled VVGraph such that
    A8: n = nn & IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = MCS:Step(Gn) by A5;
        thus P2[n+1] by A8;
    end;
A9: for n being Element of NAT holds P2[n] from NAT_1:sch 1(A6,A7); then
    for n being Element of NAT holds IT.n is _Graph; then
    reconsider IT as GraphSeq by GLIB_000:def 55;

    for n being Nat holds IT.n is [VLabeled] & IT.n is [V2Labeled]
    proof let n be Nat;
        n in NAT by ORDINAL1:def 13;
      hence IT.n is [VLabeled] & IT.n is [V2Labeled] by A9;
    end; then
    reconsider IT as VVGraphSeq by GLIB_003:def 26, Def20;
    for n being Nat holds IT.n is finite natural-vlabeled
                                    natural-v2labeled
    proof let n be Nat;
      n in NAT by ORDINAL1:def 13;
      hence IT.n is finite natural-vlabeled natural-v2labeled by A9;
    end; then
    reconsider IT as finite natural-vlabeled natural-v2labeled VVGraphSeq
           by GLIB_000:def 60, Def17, Def21;
    take IT;
    thus IT.0 = MCS:Init(G) by A5;
    let n be Nat;
A10: n in NAT by ORDINAL1:def 13;
    consider nn being Nat,
             Gn,Gn1 being finite natural-vlabeled
             natural-v2labeled VVGraph such that
A11: n = nn & IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = MCS:Step(Gn) by A5,A10;
    thus IT.(n+1) = MCS:Step(IT.n) by A11;
  end;
  uniqueness proof
    let IT1,IT2 be finite natural-vlabeled natural-v2labeled
                   VVGraphSeq such that
A12: IT1.0 = MCS:Init(G) &
    for n being Nat holds IT1.(n+1) = MCS:Step(IT1.n) and
A13: IT2.0 = MCS:Init(G) &
    for n being Nat holds IT2.(n+1) = MCS:Step(IT2.n);
    defpred P[Nat] means IT1.$1 = IT2.$1;
A14: P[0] by A12,A13;
    now let n be Nat; assume P[n]; then
        IT1.(n+1) = MCS:Step(IT2.n) by A12
                   .= IT2.(n+1) by A13;
     hence P[n+1];
    end; then
A15: for n being Element of NAT st P[n] holds P[n+1];
    for n being Element of NAT holds P[n] from NAT_1:sch 1(A14,A15); then
    for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

theorem Th68:
for G being finite _Graph holds MCS:CSeq(G) is iterative
proof let G be finite _Graph;
  set CS = MCS:CSeq(G);
  let k,n be natural number;
  CS.(k+1) = MCS:Step(CS.k) by Def40;
  hence thesis by Def40;
end;

registration let G be finite _Graph;
  cluster MCS:CSeq(G) -> iterative;
  coherence by Th68;
end;

theorem Th69:
for G being finite _Graph holds the_VLabel_of MCS:Init(G) = {}
proof let G be finite _Graph;
    set G1 = G.set(VLabelSelector, {});
    set G2 = G1.set(V2LabelSelector, the_Vertices_of G --> {});
   the_VLabel_of G2 = the_VLabel_of G1 by GLIB_000:12;
  hence the_VLabel_of MCS:Init(G) = {} by GLIB_000:11;
end;

theorem Th70:
for G being finite _Graph, v being set
  holds dom the_V2Label_of MCS:Init(G) = the_Vertices_of G &
        (the_V2Label_of MCS:Init(G)).v = 0
proof let G be finite _Graph, v be set;
    set G1 = G.set(VLabelSelector, {});
    set g  = the_Vertices_of G --> {};
A1: G1 == G by GLIB_003:8;
A2: dom g = the_Vertices_of G by FUNCOP_1:19; then
    dom g = the_Vertices_of G1 by A1,GLIB_000:def 36; then
    reconsider f = g as PartFunc of the_Vertices_of G1, rng g by PARTFUN1:24;
    set G2 = G1.set(V2LabelSelector, f);
A3: now let x be set; per cases;
     suppose x in dom f; hence f.x = {} by A2,FUNCOP_1:13; end;
     suppose not x in dom f; hence f.x = {} by FUNCT_1:def 4; end;
    end;
  thus dom the_V2Label_of MCS:Init(G) = the_Vertices_of G by GLIB_000:11,A2;
   the_V2Label_of G2 = f by GLIB_000:11;
  hence (the_V2Label_of MCS:Init(G)).v = 0 by A3;
end;

theorem Th71:
for G being finite _Graph holds G == MCS:Init(G)
proof let G be finite _Graph;
    set G1 = G.set(VLabelSelector, {});
    set G2 = G1.set(V2LabelSelector, the_Vertices_of G --> 0);
A1: G == G1 by GLIB_003:8;
    G1 == G2 by Th12;
  hence thesis by A1,GLIB_000:88;
end;

theorem Th72:
for G being finite natural-v2labeled VVGraph, x being set
 st not x in dom the_VLabel_of G &
    dom the_V2Label_of G = the_Vertices_of G &
    dom the_VLabel_of G <> the_Vertices_of G
 holds (the_V2Label_of G).x <= (the_V2Label_of G).(MCS:PickUnnumbered(G))
proof let G be finite natural-v2labeled VVGraph, x be set such that
A1: not x in dom the_VLabel_of G and
A2: dom the_V2Label_of G = the_Vertices_of G and
A3: dom the_VLabel_of G <> the_Vertices_of G;
    set w = MCS:PickUnnumbered(G);    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;      set VG = the_Vertices_of G;
    consider S being finite non empty natural-membered set,
             F being Function such that
A4: S = rng F and
A5: F = V2G | (VG \ dom VLG) and
A6: w = choose (F " {max S}) by A3,A2,Def36;
    set y = max S;
    y in rng F by A4, PRE_CIRC:def 1; then
A7: F " {max S} is non empty by FUNCT_1:142;
A8: w in dom F & F.w in {max S} by A6, A7, FUNCT_1:def 13; then
A9: V2G.w = F.w by A5,FUNCT_1:70;
A10: V2G.w = y by A9,A8,TARSKI:def 1;
A11: dom F = dom V2G /\ (VG \ dom VLG) by A5,FUNCT_1:68;
  per cases;
  suppose x in the_Vertices_of G; then
  A12: x in VG \ dom VLG by A1,XBOOLE_0:def 4;
  A13: x in dom F by A2,A12,A11,XBOOLE_0:def 3; then
  A14: F.x = V2G.x by A5,FUNCT_1:70;
      F.x in S by A13,A4,FUNCT_1:def 5;
    hence V2G.x <= V2G.w by A10,PRE_CIRC:def 1,A14; end;
  suppose not x in the_Vertices_of G;
    hence V2G.x <= V2G.w by NAT_1:18,A2,FUNCT_1:def 4; end;
end;

theorem Th73:
for G being finite natural-v2labeled VVGraph
 st dom the_V2Label_of G = the_Vertices_of G &
    dom the_VLabel_of G <> the_Vertices_of G
 holds not MCS:PickUnnumbered(G) in dom the_VLabel_of G
proof let G be finite natural-v2labeled VVGraph such that
A1: dom the_V2Label_of G = the_Vertices_of G and
A2: dom the_VLabel_of G <> the_Vertices_of G;
    set w = MCS:PickUnnumbered(G);
    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
    set VG = the_Vertices_of G;
    assume A3: w in dom VLG;
    consider S being finite non empty natural-membered set,
             F being Function such that
A4: S = rng F and
A5: F = V2G | (VG \ dom VLG) and
A6: w = choose (F " {max S}) by A2,A1,Def36;
    set y = max S;
    y in rng F by A4, PRE_CIRC:def 1; then
A7: F " {max S} is non empty by FUNCT_1:142;
A8: w in dom F by A6, A7, FUNCT_1:def 13;
A9: dom F = dom V2G /\ (VG \ dom VLG) by A5,FUNCT_1:68;
    not w in VG \ dom VLG by A3,XBOOLE_0:def 4;
  hence contradiction by A8, A9,XBOOLE_0:def 3;
end;

theorem Th74:
for G being finite natural-v2labeled VVGraph, v,x being set
 st not x in G.AdjacentSet({v})
  holds (the_V2Label_of G).x = (the_V2Label_of (MCS:LabelAdjacent(G,v))).x
proof let G be finite natural-v2labeled VVGraph, v,x be set such that
A1: not x in G.AdjacentSet({v});
    set GL = MCS:LabelAdjacent(G,v);
    set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
A2: V2 = V2G.incSubset(G.AdjacentSet({v})\dom VLG,1) by GLIB_000:11;
  not x in G.AdjacentSet({v}) \ dom VLG by A1,XBOOLE_0:def 4;
  hence V2.x = V2G.x by A2,Def4;
end;

theorem Th75:
for G being finite natural-v2labeled VVGraph, v,x being set
 st x in dom (the_VLabel_of G)
  holds (the_V2Label_of G).x = (the_V2Label_of (MCS:LabelAdjacent(G,v))).x
proof let G be finite natural-v2labeled VVGraph, v,x be set such that
A1: x in dom (the_VLabel_of G);
    set GL = MCS:LabelAdjacent(G,v);
    set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
A2: V2 = V2G.incSubset(G.AdjacentSet({v})\dom VLG,1) by GLIB_000:11;
    not x in G.AdjacentSet({v}) \ dom VLG by A1,XBOOLE_0:def 4;
  hence V2.x = V2G.x by A2,Def4;
end;

theorem Th76:
for G being finite natural-v2labeled VVGraph, v,x being set
 st x in dom the_V2Label_of G &
    x in G.AdjacentSet{v} & not x in dom the_VLabel_of G
  holds (the_V2Label_of (MCS:LabelAdjacent(G,v))).x = (the_V2Label_of G).x + 1
proof let G be finite natural-v2labeled VVGraph, v,x be set such that
A1: x in dom (the_V2Label_of G) & x in G.AdjacentSet({v}) and
A2: not x in dom (the_VLabel_of G);
    set GL = MCS:LabelAdjacent(G,v);
    set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
A3: V2 = V2G.incSubset(G.AdjacentSet({v})\dom VLG,1) by GLIB_000:11;
    x in G.AdjacentSet({v}) \ dom VLG by A1,A2,XBOOLE_0:def 4;
  hence V2.x = V2G.x + 1 by A1,A3,Def4;
end;

theorem Th77:
for G being finite natural-v2labeled VVGraph, v being set
 st dom (the_V2Label_of G) = the_Vertices_of G
  holds dom (the_V2Label_of (MCS:LabelAdjacent(G,v))) = the_Vertices_of G
proof let G be finite natural-v2labeled VVGraph, v be set such that
A1: dom (the_V2Label_of G) = the_Vertices_of G;
    set GL = MCS:LabelAdjacent(G,v);
    set V2 = the_V2Label_of GL;
    set VLG = the_VLabel_of G;
    set V2G = the_V2Label_of G;
    V2 = V2G.incSubset(G.AdjacentSet({v})\dom VLG,1) by GLIB_000:11;
  hence dom V2 = the_Vertices_of G by A1, Def4;
end;

theorem Th78:
for G being finite _Graph, n being natural number holds (MCS:CSeq(G)).n == G
proof let G be finite _Graph, n be Nat;
    defpred P[Nat] means (MCS:CSeq(G)).$1 == G;
    (MCS:CSeq(G)).0 = MCS:Init(G) by Def40; then
A1: P[0] by Th71;
A2: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A3: P[k];
        set CSK = (MCS:CSeq(G)).k;         set CK1 = (MCS:CSeq(G)).(k+1);
        set w   = MCS:PickUnnumbered(CSK);
        set kk  = G.order() -' card (dom the_VLabel_of CSK);
    A4: CSK.order() = G.order() by A3, GLIB_000:93;
    A5: CK1 = MCS:Step(CSK) by Def40;
      per cases;
      suppose card (dom the_VLabel_of CSK) < G.order(); then
        CK1 = MCS:Update(CSK, w, card (dom the_VLabel_of CSK))
             by A4,A5,Def39; then
    A6: CK1 = MCS:LabelAdjacent(CSK.labelVertex(w,kk),w) by A3, GLIB_000:93;
        set CC = CSK.labelVertex(w,kk);
    A7: CK1 == CC by A6, Th12;
        CC == CSK by GLIB_003:47; then
        CK1 == CSK by A7,GLIB_000:88;
      hence P[k+1] by A3,GLIB_000:88; end;
      suppose G.order() <= card (dom the_VLabel_of CSK);
      hence P[k+1] by A3, A4,A5,Def39; end;
    end;
    for k being Nat holds P[k] from NAT_1:sch 2(A1,A2);
  hence (MCS:CSeq(G)).n == G;
end;

theorem Th79:
for G being finite _Graph, m, n being natural number
 holds (MCS:CSeq(G)).m == (MCS:CSeq(G)).n
proof let G be finite _Graph, m,n be Nat;
A1: (MCS:CSeq(G)).m == G by Th78;
    (MCS:CSeq(G)).n == G by Th78;
  hence (MCS:CSeq(G)).m == (MCS:CSeq(G)).n by A1,GLIB_000:88;
end;

registration let G be finite chordal _Graph, n be natural number;
  cluster (MCS:CSeq(G)).n -> chordal VVGraph;
  coherence proof (MCS:CSeq(G)).n == G by Th78;
    hence (MCS:CSeq(G)).n is chordal VVGraph by CHORD:95;
  end;
end;

registration let G be finite chordal _Graph;
  cluster MCS:CSeq(G) -> chordal;
  correctness proof
    thus for x be Nat holds (MCS:CSeq(G)).x is chordal;
  end;
end;

theorem Th80:
for G being finite _Graph, n being natural number holds
  dom (the_V2Label_of ((MCS:CSeq(G)).n)) = the_Vertices_of ((MCS:CSeq(G)).n)
proof let G be finite _Graph, n be Nat;
  set CSN = (MCS:CSeq(G)).n;  set V2N = the_V2Label_of CSN;
  defpred P[Nat] means
     dom (the_V2Label_of ((MCS:CSeq(G)).$1)) =
        the_Vertices_of ((MCS:CSeq(G)).$1);
A1: (MCS:CSeq(G)).0 == G by Th78;
    (MCS:CSeq(G)).0 = MCS:Init(G) by Def40; then
    dom (the_V2Label_of ((MCS:CSeq(G)).0)) = the_Vertices_of G
        by Th70;then
A2: P[0] by A1,GLIB_000:def 36;
A3: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A4: P[k];
        set CSK = (MCS:CSeq(G)).k;        set V2K = the_V2Label_of CSK;
        set CK1 = (MCS:CSeq(G)).(k+1);    set V21 = the_V2Label_of CK1;
        set w   = MCS:PickUnnumbered(CSK);
        set m   = G.order() -' (card (dom the_VLabel_of CSK));
    A5: CSK == CK1 by Th79;
    A6: G == CSK by Th78; then
    A7: CSK.order() = G.order() by GLIB_000:93;
       per cases;
      suppose A8: card (dom the_VLabel_of CSK) < G.order();
        CK1 = MCS:Step(CSK) by Def40; then
        CK1 = MCS:Update(CSK, w, card (dom the_VLabel_of CSK))
              by A8,A7,Def39; then
    A9: CK1 = MCS:LabelAdjacent(CSK.labelVertex(w,m),w) by A6,GLIB_000:93;
        set CSlv = CSK.labelVertex(w,m);
        set V2v  = the_V2Label_of CSlv;
    A10: CSlv == CSK by GLIB_003:47; then
    A11: CSlv == CK1 by A5,GLIB_000:88;
        dom V2v = the_Vertices_of CSK by A4,Th13; then
        dom V2v = the_Vertices_of CSlv by A10,GLIB_000:def 36; then
        dom V21 = the_Vertices_of CSlv by A9,Th77;
      hence P[k+1] by A11,GLIB_000:def 36; end;
      suppose A12: G.order() <= card (dom the_VLabel_of CSK);
        CK1 = MCS:Step(CSK) by Def40; then
        CSK = CK1 by A7,A12,Def39;
      hence P[k+1] by A4; end;
    end;
    for k being Nat holds P[k] from NAT_1:sch 2(A2,A3);
  hence dom V2N = the_Vertices_of CSN;
end;

theorem Th81:
for G being finite _Graph, n being natural number
  st card (dom the_VLabel_of ((MCS:CSeq(G)).n)) < G.order()
 holds the_VLabel_of ((MCS:CSeq(G)).(n+1)) =
       (the_VLabel_of ((MCS:CSeq(G)).n)) +*
                  (MCS:PickUnnumbered((MCS:CSeq(G)).n) .-->
                  (G.order()-'(card (dom the_VLabel_of ((MCS:CSeq(G)).n)))))
proof let G be finite _Graph, n be Nat such that
A1: card (dom the_VLabel_of ((MCS:CSeq(G)).n)) < G.order();
    set CSN = (MCS:CSeq(G)).n;     set VLN = the_VLabel_of CSN;
    set CN1 = (MCS:CSeq(G)).(n+1); set VN1 = the_VLabel_of CN1;
    set w   = MCS:PickUnnumbered(CSN);
    set k   = G.order() -' card (dom VLN);
    G == CSN by Th78; then
A2: CSN.order() = G.order() by GLIB_000:93;
    CN1 = MCS:Step(CSN) by Def40; then
    CN1 = MCS:Update(CSN, w, card (dom VLN)) by A1,A2,Def39; then
    VN1 = the_VLabel_of CSN.labelVertex(w,k) by A2, GLIB_000:12;
  hence thesis by GLIB_003:45;
end;

theorem Th82:
for G being finite _Graph, n being natural number st n <= G.order()
 holds card dom the_VLabel_of ((MCS:CSeq(G)).n) = n
proof let G be finite _Graph, n be Nat such that A1: n <= G.order();
 defpred P[Nat] means
  $1 <= G.order() implies card dom the_VLabel_of ((MCS:CSeq(G)).$1) = $1;
 A2: for k being Element of NAT
     st k < G.order() & card dom the_VLabel_of ((MCS:CSeq(G)).k) = k
     holds  card dom the_VLabel_of ((MCS:CSeq(G)).(k+1)) = k+1
    proof let k be Element of NAT such that
    A3: k < G.order() & card dom the_VLabel_of ((MCS:CSeq(G)).k) = k;
        set CSK = (MCS:CSeq(G)).k;        set VLK = the_VLabel_of CSK;
        set CK1 = (MCS:CSeq(G)).(k+1);    set VK1 = the_VLabel_of CK1;
        CSK == G by Th78; then
    A4: dom VLK <> the_Vertices_of CSK by A3, GLIB_000:def 36;
        set w = MCS:PickUnnumbered(CSK);
    A5: VK1 = VLK +* (w .--> (G.order()-'k)) by A3,Th81;
        set wf  = w .--> (G.order() -' k);
        dom wf = {w} & rng wf = {G.order() -' k} by CQC_LANG:5; then
    A6: dom VK1 = dom VLK \/ {w} by A5,FUNCT_4:def 1;
        dom the_V2Label_of CSK = the_Vertices_of CSK by Th80; then
        not w in dom VLK by A4,Th73;
      hence thesis by A3,A6,CARD_2:54;
    end;
    (MCS:CSeq(G)).0 = MCS:Init(G) by Def40; then
A7: P[0] by CARD_1:78, RELAT_1:60,Th69;
A8: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A9: P[k];
      per cases;
      suppose k < G.order();
      hence P[k+1] by A9,A2; end;
      suppose k >= G.order();
      hence P[k+1] by NAT_1:38; end;
    end;
    for k being Nat holds P[k] from NAT_1:sch 2(A7,A8);
  hence card dom the_VLabel_of ((MCS:CSeq(G)).n) = n by A1;
end;

theorem Th83:
for G being finite _Graph, n being natural number st G.order() <= n
  holds (MCS:CSeq(G)).(G.order()) = (MCS:CSeq(G)).n
proof let G be finite _Graph, n be natural number such that
A1: G.order() <= n;

    set CS = MCS:CSeq(G);
    defpred V[Nat] means
      G.order() = (card (dom the_VLabel_of CS.(G.order()+$1)));
A2: V[0] by Th82;
A3: for k being Nat st V[k] holds V[k+1] proof
      let k be Nat such that A4: V[k];
        set CSK = (MCS:CSeq(G)).(G.order()+k);
        set CK1 = (MCS:CSeq(G)).(G.order()+k+1);
        G == CSK by Th78; then
    A5: card dom the_VLabel_of CSK = CSK.order() by A4,GLIB_000:93;
        CK1 = MCS:Step(CSK) by Def40;
      hence V[k+1] by A4,A5,Def39;
    end;
A6: for k being Nat holds V[k] from NAT_1:sch 2(A2,A3);
    defpred P[Nat] means
     (CS.(G.order())) = (CS.(G.order()+$1));
A7: P[0];
A8: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A9: P[k];
        set CSK = (MCS:CSeq(G)).(G.order()+k);
        set VLK = the_VLabel_of CSK;
        set CK1 = (MCS:CSeq(G)).(G.order()+k+1);
        set VL1 = the_VLabel_of CK1;
        G == CSK by Th78; then
        CSK.order() = G.order() by GLIB_000:93; then
    A10: card dom VLK = CSK.order() by A6;
        CK1 = MCS:Step(CSK) by Def40;
      hence P[k+1] by A9,A10,Def39;
    end;
A11: for k being Nat holds P[k] from NAT_1:sch 2(A7,A8);
    ex i being Nat st G.order() + i = n by A1,NAT_1:28;
  hence thesis by A11;
end;

theorem Th84:
for G being finite _Graph, m,n being natural number st G.order() <= m & m <= n
  holds (MCS:CSeq(G)).m = (MCS:CSeq(G)).n
proof let G be finite _Graph, m,n be Nat such that
A1: G.order() <= m & m <= n;
A2: G.order() <= n by A1,XREAL_1:2;
    (MCS:CSeq(G)).m = (MCS:CSeq(G)).(G.order()) by A1,Th83;
  hence (MCS:CSeq(G)).m = (MCS:CSeq(G)).n by A2,Th83;
end;

theorem Th85:
for G being finite _Graph holds MCS:CSeq(G) is eventually-constant
proof let G be finite _Graph;
  take G.order();
  let m be Nat such that A1: G.order() <= m;
  thus (MCS:CSeq(G)).(G.order()) = (MCS:CSeq(G)).m by A1,Th83;
end;

registration let G be finite _Graph;
  cluster MCS:CSeq(G) -> eventually-constant;
  coherence by Th85;
end;

theorem Th86:
for G being finite _Graph, n being natural number holds
       dom the_VLabel_of ((MCS:CSeq(G)).n) = the_Vertices_of ((MCS:CSeq(G)).n)
   iff G.order() <= n
proof let G be finite _Graph, n be Nat;
    set CSN = (MCS:CSeq(G)).n;    set VLN = the_VLabel_of ((MCS:CSeq(G)).n);
    set CSO = (MCS:CSeq(G)).G.order();    set VLO = the_VLabel_of CSO;
A1: CSN == G by Th78; then
A2: the_Vertices_of CSN = the_Vertices_of G by GLIB_000:def 36;
A3: CSO == G by Th78; then
A4: the_Vertices_of CSO = the_Vertices_of G by GLIB_000:def 36;
    thus dom VLN = the_Vertices_of CSN implies not n < G.order()
           by A2, Th82;
  assume A5: G.order() <= n;
A6: dom VLO c= the_Vertices_of CSO by GLIB_003:7;
    card dom VLO = card the_Vertices_of CSO by A4, Th82; then
A7: dom VLO = the_Vertices_of CSO by A6,CARD_FIN:1;
A8: dom VLO = dom VLN by A5,Th84;
    CSN == CSO by A1,A3,GLIB_000:88;
  hence dom VLN = the_Vertices_of CSN by A7,A8, GLIB_000:def 36;
end;

theorem Th87:
for G being finite _Graph holds (MCS:CSeq(G)).Lifespan() = G.order()
proof
    let G be finite _Graph;
    set CS = MCS:CSeq(G);
    G.order() <= G.order()+1 by NAT_1:38; then
A1: CS.(G.order()) = CS.(G.order()+1) by Th83;
    for n being Element of NAT st CS.n = CS.(n+1) holds G.order() <= n proof
        let n be Element of NAT such that  A2: CS.n = CS.(n+1);
        assume A3: n < G.order();
        set VLN = the_VLabel_of (CS.n);
        set VN1 = the_VLabel_of (CS.(n+1));
        set w   = MCS:PickUnnumbered(CS.n);
        set j = card (dom VLN);
    A4: dom the_V2Label_of (CS.n) = the_Vertices_of (CS.n) by Th80;
        dom VLN <> the_Vertices_of (CS.n) by A3,Th86; then
    A5: not w in dom VLN by A4,Th73;
    A6: j < G.order() by A3,Th82;
    A7: VN1 = VLN +* (w .--> (G.order() -' j)) by A6,Th81;
        set wf  = w .--> (G.order() -' j);
        dom wf = {w} & rng wf = {G.order() -' j} by CQC_LANG:5; then
    A8: dom VN1 = dom VLN \/ {w} by A7,FUNCT_4:def 1;
        w in {w} by TARSKI:def 1;
      hence contradiction by A2,A5,A8,XBOOLE_0:def 2;
    end;
  hence thesis by A1,GLIB_000:def 57;
end;

theorem Th88:
for G being finite _Graph holds MCS:CSeq(G) is vlabel-numbering
proof let G be finite _Graph;
    set GS = MCS:CSeq(G);
A1: GS is fixed-vertices
    proof let n,m be Nat; (GS.n) == (GS.m) by Th79;
      hence (the_Vertices_of (GS.n)) =
            (the_Vertices_of (GS.m)) by GLIB_000:def 36;
    end;
    GS.0 = MCS:Init(G) by Def40; then
    the_VLabel_of (GS.0) = {} by Th69; then
A2: GS is vlabel-initially-empty by Def24;
A3: GS.Lifespan() = G.order() by Th87;
    now let n be Nat such that A4: n < GS.Lifespan();
     reconsider w = MCS:PickUnnumbered(GS.n) as set;
    take w;
    A5: dom the_V2Label_of (GS.n) = the_Vertices_of (GS.n) by Th80;
       dom the_VLabel_of (GS.n) <> the_Vertices_of (GS.n)
         by A4,A3,Th86;
    hence not w in dom (the_VLabel_of (GS.n)) by A5,Th73;
     n = card dom the_VLabel_of (GS.n) by A4,A3,Th82;
    hence the_VLabel_of (GS.(n+1)) =
        (the_VLabel_of (GS.n)) +* (w .--> (GS.Lifespan()-'n))
               by A4,A3,Th81;
   end; then GS is adds-one-at-a-step by Def25;
  hence thesis by A1,A2,Def26;
end;

registration let G be finite _Graph;
  cluster MCS:CSeq(G) -> vlabel-numbering;
  coherence by Th88;
end;

theorem Th89:
for G being finite _Graph, n being natural number st n < G.order()
  holds (MCS:CSeq(G)).PickedAt(n) = MCS:PickUnnumbered((MCS:CSeq(G)).n)
proof let G be finite _Graph, n be Nat such that A1: n < G.order();
    set GS = MCS:CSeq(G);
    set CSN = GS.n;
    set CS1 = GS.(n+1);
    set PA = GS.PickedAt(n);
    set PU = MCS:PickUnnumbered(CSN);
    set VLN = the_VLabel_of CSN;
    set VL1 = the_VLabel_of CS1;
A2: GS.Lifespan() = G.order() by Th87; then
A3: not PA in dom VLN & VL1 = VLN +* (PA .--> (GS.Lifespan()-'n))
       by A1,Def27;
    n = card dom VLN by A1,Th82; then
A4: VL1 = VLN +* (PU .--> (GS.Lifespan()-'n)) by A1,A2,Th81;
    set f1 = PA .--> (GS.Lifespan()-'n);
    set f2 = PU .--> (GS.Lifespan()-'n);
 A5: dom f1 = {PA} & rng f1 = {GS.Lifespan()-'n} by CQC_LANG:5;
 A6: dom f2 = {PU} & rng f2 = {GS.Lifespan()-'n} by CQC_LANG:5;
 A7: dom VL1 = dom VLN \/ {PA} by A3,A5,FUNCT_4:def 1;
 A8: dom VL1 = dom VLN \/ {PU} by A4,A6,FUNCT_4:def 1;
    now assume PA <> PU; then
        not PA in {PU} by TARSKI:def 1; then
    A9: not PA in dom VL1 by A3,A8,XBOOLE_0:def 2;
        PA in {PA} by TARSKI:def 1;
      hence contradiction by A9, A7,XBOOLE_0:def 2;
    end;
  hence PA = PU;
end;

theorem Th90:
for G being finite _Graph, n being natural number st n < G.order()
 ex w being Vertex of (MCS:CSeq(G)).n
   st w = MCS:PickUnnumbered((MCS:CSeq(G)).n) &
   for v being set holds
    (v in G.AdjacentSet({w}) & not v in dom (the_VLabel_of ((MCS:CSeq(G)).n))
       implies (the_V2Label_of ((MCS:CSeq(G)).(n+1))).v =
                                     (the_V2Label_of ((MCS:CSeq(G)).n)).v + 1)
  & (not v in G.AdjacentSet({w}) or v in dom (the_VLabel_of ((MCS:CSeq(G)).n))
       implies (the_V2Label_of ((MCS:CSeq(G)).(n+1))).v =
                                         (the_V2Label_of ((MCS:CSeq(G)).n)).v)
proof let G be finite _Graph, n be Nat such that
A1: n < G.order();
    set CSN = (MCS:CSeq(G)).n;         set VLN = the_VLabel_of CSN;
    set V2N = the_V2Label_of CSN;      set CN1 = (MCS:CSeq(G)).(n+1);
    set VN1 = the_VLabel_of CN1;       set V21 = the_V2Label_of CN1;
    set w   = MCS:PickUnnumbered(CSN);
    set k   = G.order() -' n;
A2: n = card dom VLN by A1,Th82;
A3: G == CSN by Th78; then
A4: CSN.order() = G.order() by GLIB_000:93;
A5: CN1 = MCS:Step(CSN) by Def40
       .= MCS:Update(CSN, w, n) by A1,A4,A2,Def39
       .= MCS:LabelAdjacent(CSN.labelVertex(w,k),w) by A3, GLIB_000:93;
    set CSlv = CSN.labelVertex(w,k);
    set VLv  = the_VLabel_of CSlv;
    set V2v  = the_V2Label_of CSlv;
A6: CSN == CSlv by GLIB_003:47;
    CSN == G by Th78; then
A7: CSlv == G by A6,GLIB_000:88;
A8: CSlv.labeledV() = CSN.labeledV() \/ {w} by GLIB_003:59;
A9: V2v = V2N by Th13;
A10: dom VLN c= dom VLv by A8,XBOOLE_1:7;
A11: dom V2N = the_Vertices_of CSN by Th80;
A12: now let v be set;
        assume A13: v in G.AdjacentSet({w}) & not v in dom VLN; then
    A14: v in CSlv.AdjacentSet({w}) by A7,CHORD:51;
    A15: dom V2v = the_Vertices_of G & v in the_Vertices_of G
              by A11,A9, A3,A13,GLIB_000:def 36;
        not v in {w} by A13,CHORD:49; then
        not v in dom VLv by A8,A13,XBOOLE_0:def 2;
      hence   V21.v = V2N.v + 1 by A9, A5, A14,A15,Th76;
    end;
A16: now let v be set;
      assume A17: not v in G.AdjacentSet({w}) or v in dom VLN;
      per cases by A17;
      suppose not v in G.AdjacentSet({w}); then
        not v in CSlv.AdjacentSet({w}) by A7,CHORD:51;
       hence V21.v = V2N.v by A9, A5, Th74; end;
      suppose v in dom VLN;
      hence V21.v = V2N.v by A9,A5,A10,Th75; end;
    end;
    take w;
  thus thesis by A12,A16;
end;

theorem Th91:
for G being finite _Graph, n being natural number, x being set
 st not x in (dom the_VLabel_of ((MCS:CSeq(G)).n))
  holds (the_V2Label_of ((MCS:CSeq(G)).n)).x =
        card (G.AdjacentSet({x}) /\ (dom the_VLabel_of ((MCS:CSeq(G)).n)))
proof let G be finite _Graph, n be Nat;
     set CN  = (MCS:CSeq(G)).n;    set VLN = the_VLabel_of CN;
     set VL2 = the_V2Label_of CN;
    let x be set such that A1: not x in dom VLN;
    defpred P[Nat] means
    for x being set st not x in dom (the_VLabel_of ((MCS:CSeq(G)).$1))
      holds (the_V2Label_of ((MCS:CSeq(G)).$1)).x =
        card (G.AdjacentSet({x}) /\ (dom the_VLabel_of ((MCS:CSeq(G)).$1)));
    now let x be set;
        set C0 = (MCS:CSeq(G)).0;        set VL0 = the_VLabel_of C0;
        set V20 = the_V2Label_of C0;
        assume not x in dom VL0;
    A2: C0 = MCS:Init(G) by Def40; then
        dom VL0 = {} by RELAT_1:60, Th69;
      hence V20.x = card (G.AdjacentSet({x}) /\ dom VL0)
         by A2,CARD_1:78,Th70;
    end; then
A3: P[0];
A4: for k being Nat st P[k] holds P[k+1] proof
        let k be Nat such that A5: P[k];
        set CSK = (MCS:CSeq(G)).k;        set VLK = the_VLabel_of CSK;
        set VK2 = the_V2Label_of CSK;     set CS1 = (MCS:CSeq(G)).(k+1);
        set VL1 = the_VLabel_of CS1;      set V12 = the_V2Label_of CS1;
    A6: k <= k+1 by XREAL_1:40;
      per cases;
      suppose G.order() <= k; then
     VLK = VL1 & VK2 = V12 by A6,Th84;
      hence P[k+1] by A5; end;
      suppose A7: k < G.order(); then
        consider w being Vertex of CSK such that
    A8: w = MCS:PickUnnumbered(CSK) and
    A9: for v being set holds
        (v in G.AdjacentSet({w}) & not v in dom VLK
           implies V12.v = VK2.v + 1) &
        (not v in G.AdjacentSet({w}) or v in dom VLK
           implies V12.v = VK2.v) by Th90;

   A10: G.order() = (MCS:CSeq(G)).Lifespan() by Th87;
        w = (MCS:CSeq(G)).PickedAt(k) by A7,A8,Th89; then
    A11: CS1.labeledV() = CSK.labeledV() \/ {w} by A7,A10,Th18;

        now let x be set such that A12: not x in dom VL1;
        A13: not x in dom VLK by A12,A11,XBOOLE_0:def 2; then
        A14: card (G.AdjacentSet({x}) /\ dom VLK) = VK2.x by A5;
          per cases;
          suppose A15: x in G.AdjacentSet({w}) & not x in dom VLK; then
        A16: V12.x = VK2.x + 1 by A9;
            set GAS = G.AdjacentSet({x});
        A17: w in GAS by CHORD:53,A15;
        A18: dom VK2 = the_Vertices_of CSK by Th80;
            dom VLK <> the_Vertices_of CSK by A7,Th86; then
            not w in dom VLK by A8,A18,Th73; then
        A19: not w in GAS /\ dom VLK by XBOOLE_0:def 3;
        A20: {w} c= GAS by A17,ZFMISC_1:37;
         GAS /\ dom VL1 = (GAS /\ dom VLK) \/ (GAS /\ {w}) by A11, XBOOLE_1:23
                       .= (GAS /\ dom VLK) \/ {w} by A20,XBOOLE_1:28;
          hence card (G.AdjacentSet({x}) /\ dom VL1) = V12.x by A14,A16,
                      A19,CARD_2:54; end;
          suppose A21: not x in G.AdjacentSet({w}) or x in dom VLK; then
        A22: V12.x = VK2.x by A9;
            set GAS = G.AdjacentSet({x});
        A23: not w in GAS by CHORD:53, A21,A12,A11,XBOOLE_0:def 2;
            GAS /\ {w} c= {w} by XBOOLE_1:17; then
            GAS /\ {w} in bool {w}; then
        A24: GAS /\ {w} in { {}, {w} } by ZFMISC_1:30;
        A25: now assume GAS /\ {w} = {w}; then
                w in GAS /\ {w} by TARSKI:def 1;
              hence contradiction by A23,XBOOLE_0:def 3;
            end;
           GAS /\ dom VL1 = (GAS /\ dom VLK) \/ (GAS /\ {w}) by A11
, XBOOLE_1:23
                         .= (GAS /\ dom VLK) \/ {} by A25,A24,TARSKI:def 2
                         .= GAS /\ dom VLK;
          hence card (G.AdjacentSet({x}) /\ dom VL1) = V12.x by A13,A5,A22;
          end;
        end;
      hence P[k+1]; end;
    end;
    for k being Nat holds P[k] from NAT_1:sch 2(A3,A4);
  hence VL2.x = card (G.AdjacentSet({x}) /\ dom VLN) by A1;
end;

definition let G be natural-vlabeled VGraph;
  attr G is with_property_T means                                  :Def41:
for a,b,c being Vertex of G st a in dom the_VLabel_of G &
    b in dom the_VLabel_of G & c in dom the_VLabel_of G &
    (the_VLabel_of G).a < (the_VLabel_of G).b &
    (the_VLabel_of G).b < (the_VLabel_of G).c &
    a,c are_adjacent & not b,c are_adjacent
  ex d being Vertex of G st d in dom the_VLabel_of G &
     (the_VLabel_of G).b < (the_VLabel_of G).d &
     b,d are_adjacent & not a,d are_adjacent;
end;

theorem
for G being finite _Graph, n being natural number
  holds (MCS:CSeq(G)).n is with_property_T
proof let G be finite _Graph, n be Nat;
    set CN  = (MCS:CSeq(G)).n;    set VLN = the_VLabel_of CN;
    now let a,b,c be Vertex of CN such that
A1: a in dom VLN & b in dom VLN & c in dom VLN and
A2: VLN.a < VLN.b & VLN.b < VLN.c and
A3: a,c are_adjacent & not b,c are_adjacent;
A4: G == CN by Th78;
A5: G.order() = (MCS:CSeq(G)).Lifespan() by Th87;
A6: a in CN.labeledV() & b in CN.labeledV() & c in CN.labeledV()
          by A1;
    now assume A7: for d being Vertex of CN st d in dom VLN & VLN.b < VLN.d &
                   b,d are_adjacent holds a,d are_adjacent;
        set bn  = G.order() -' VLN.b;        set CSB = (MCS:CSeq(G)).bn;
        set VLB = the_VLabel_of CSB;         set VL2 = the_V2Label_of CSB;
        bn < n by A6,A5,Th29; then
        VLB c= VLN by Th24; then
    A8: dom VLB c= dom VLN by RELAT_1:25;
        VLN.b <= G.order() by A5,Th22; then
    A9: G.order() -' VLN.b = G.order() - VLN.b by BINARITH:50;
    A10: G.order() -' VLN.b <= G.order() by BINARITH:52;
        VLN.b = G.order() - (G.order() -' VLN.b) by A9; then
    A11: VLN.b = G.order() -' (G.order() -' VLN.b) by A10,BINARITH:50;
    A12: dom VL2 = the_Vertices_of CSB by Th80;
        1 <= VLN.b by A6,Th22; then
   A13: bn < G.order() by A9, XREAL_1:46; then
    A14: dom VLB <> the_Vertices_of CSB by Th86;
   A15: b = (MCS:CSeq(G)).PickedAt(bn) by A5,A6,Th27; then
    A16: b = MCS:PickUnnumbered(CSB) by A13,Th89;
        now assume a in dom VLB; then
        A17: a in CSB.labeledV(); then
            VLN.b < VLB.a by A11, A5,Th29;
          hence contradiction by A2, A17,A6,Th26;
        end; then
    A18: VL2.b >= VL2.a by A12,A14,A16,Th72;
        not b in dom VLB by A12,A14,A16,Th73; then
    A19: VL2.b = card (G.AdjacentSet({b}) /\ dom VLB) by Th91;
        not a in CSB.labeledV() by A5,A6,A2,Th31; then
    A20: VL2.a = card (G.AdjacentSet({a}) /\ dom VLB) by Th91;
    A21: c in CSB.labeledV() by A5,A6,A2,Th30;
        c in CN.AdjacentSet({a}) by A2,A3,CHORD:52; then
        c in G.AdjacentSet({a}) by A4,CHORD:51; then
    A22: c in (G.AdjacentSet({a}) /\ dom VLB) by A21,XBOOLE_0:def 3;
        not c in CN.AdjacentSet({b}) by A3,CHORD:52; then
        not c in G.AdjacentSet({b}) by A4,CHORD:51; then
    A23: not c in (G.AdjacentSet({b}) /\ dom VLB) by XBOOLE_0:def 3;
        now let x be set such that A24: x in G.AdjacentSet({b}) /\ dom VLB;
        A25: x in dom VLB by A24,XBOOLE_0:def 3; then
        A26: x in dom VLN by A8;
       A27: x in CSB.labeledV() by A24,XBOOLE_0:def 3;
            dom VLN c= the_Vertices_of CN by GLIB_003:7; then
            reconsider d = x as Vertex of CN by A26;
            set CSB1 = (MCS:CSeq(G)).(bn+1);
            set VLB1 = the_VLabel_of CSB1;
            b in CSB1.labeledV() by A5,A13,A15,Th18; then
        A28: VLN.b = VLB1.b & VLN.d = VLB.d by A6,A27,A8,Th26;
            bn < bn+1 by XREAL_1:41; then
            VLB c= VLB1 by Th24; then
            dom VLB c= dom VLB1 by RELAT_1:25; then
            d in CSB1.labeledV() by A25; then
        A29: VLB.d = VLB1.d by A27,Th26;
            VLB.d in rng VLB by A25,FUNCT_1:def 5; then
            VLB.d in (Seg G.order() \ Seg (G.order() -' bn)) by A5,Th21;
            then G.order() -' bn < VLB1.d by A29, Th5; then
        A30: VLN.b < VLN.d by A28,A29,A5,A13,A15,Th19;
            d in G.AdjacentSet({b}) by A24,XBOOLE_0:def 3; then
            d in CN.AdjacentSet({b}) by A4,CHORD:51; then
            b <> d & b,d are_adjacent by CHORD:52; then
        A31: a,d are_adjacent by A25,A8,A30,A7;
            d in CN.AdjacentSet({a}) by A31,CHORD:52,A30,A2; then
            x in G.AdjacentSet({a}) by A4,CHORD:51;
          hence x in G.AdjacentSet({a}) /\ dom VLB by A25,XBOOLE_0:def 3;
        end; then
        (G.AdjacentSet({b}) /\ dom VLB) c=
        (G.AdjacentSet({a}) /\ dom VLB) by TARSKI:def 3; then
        (G.AdjacentSet({b}) /\ dom VLB) c<
        (G.AdjacentSet({a}) /\ dom VLB) by A22,A23,XBOOLE_0:def 8;
      hence contradiction by A18, A19,A20, TREES_1:24;
    end;
    hence ex d being Vertex of CN st
    d in dom VLN & VLN.b < VLN.d & b,d are_adjacent & not a,d are_adjacent;
    end;
  hence thesis by Def41;
end;

theorem  :: LexBFS also has property T
for G being finite _Graph
  holds (LexBFS:CSeq(G)).Result() is with_property_T
proof let G be finite _Graph;
    set CS = LexBFS:CSeq(G);  set G = CS.Result();
A1: G is with_property_L3 by Th65;
    now let a,b,c be Vertex of G such that A2: a in dom the_VLabel_of G &
        b in dom the_VLabel_of G & c in dom the_VLabel_of G &
        (the_VLabel_of G).a < (the_VLabel_of G).b &
        (the_VLabel_of G).b < (the_VLabel_of G).c &
        a,c are_adjacent & not b,c are_adjacent;
        consider d being Vertex of G such that
    A3: d in dom the_VLabel_of G &
        (the_VLabel_of G).c < (the_VLabel_of G).d &
        b,d are_adjacent & not a,d are_adjacent &
        for e being Vertex of G
          st e <> d & e,b are_adjacent & not e,a are_adjacent
           holds (the_VLabel_of G).e < (the_VLabel_of G).d
             by A1,A2,Def34;
      take d;
      thus d in dom the_VLabel_of G by A3;
      thus (the_VLabel_of G).b < (the_VLabel_of G).d by A2,A3,XREAL_1:2;
      thus b,d are_adjacent by A3;
      thus not a,d are_adjacent by A3;
    end;
  hence CS.Result() is with_property_T by Def41;
end;

theorem :: Tarjan (SIAM Journal of Computing; 13(3):August 1984)
for G being finite chordal natural-vlabeled VGraph
  st G is with_property_T & dom the_VLabel_of G = the_Vertices_of G
   for V being VertexScheme of G st V" = the_VLabel_of G holds V is perfect
proof
    let G be finite chordal natural-vlabeled VGraph such that
A1: G is with_property_T and
A2: dom the_VLabel_of G = the_Vertices_of G;
    set VLG = the_VLabel_of G;
    let V be VertexScheme of G such that
A3: V" = VLG;
A4:V is one-to-one by CHORD:def 12;
A5: VLG is one-to-one by A3,A4,FUNCT_1:62;
A6: VLG" = V by A3,A4,FUNCT_1:65;
A7:len V = card the_Vertices_of G by CHORD:104;
    dom V = Seg G.order() by A7, FINSEQ_1:def 3; then
A8: rng VLG = Seg G.order() by A3,A4,FUNCT_1:55;
    defpred Q[Path of G] means
      len $1 >= 5 & $1 is open & $1 is chordless &
      VLG.($1.first()) > VLG.($1.last()) &
      VLG.($1.last()) > VLG.($1.3) &
      ex i being odd Element of NAT st 1 < i & i < len $1 &
   (for j,k being odd Element of NAT st i <= j & j < k & k <= len $1 holds
         VLG.($1.j) < VLG.($1.k)) &
   (for j,k being odd Element of NAT st 1 <= j & j < k & k <= i holds
        VLG.($1.j) > VLG.($1.k));

A9: now let R being Path of G such that A10: Q[R];
        defpred M[Nat] means
          ex P being Path of G st Q[P] & VLG.(P.last()) = $1;
    A11: for k being Element of NAT st M[k] holds k <= G.order() proof
            let k be Element of NAT such that A12: M[k];
            consider P being Path of G such that
        A13: Q[P] & VLG.(P.last()) = k by A12;
            VLG.(P.last()) in Seg G.order() by A2,A8,FUNCT_1:def 5;
          hence k <= G.order() by A13,FINSEQ_1:3;
        end;
    A14: ex k being Element of NAT st M[k] by A10;
        consider k being Element of NAT such that A15: M[k] and
    A16: for n being Element of NAT st M[n] holds n <= k
              from NAT_1:sch 6(A11,A14);
        consider P being Path of G such that
    A17: Q[P] & VLG.(P.last()) = k by A15;

        consider i being odd Element of NAT such that
    A18: 1 < i & i < len P and
    A19: for j,k being odd Element of NAT st i <= j & j < k & k <= len P
          holds VLG.(P.j) < VLG.(P.k) and
    A20: for j,k being odd Element of NAT st 1 <= j & j < k & k <= i holds
           VLG.(P.j) > VLG.(P.k) by A17;

        reconsider c = P.first() as Vertex of G;
        reconsider b = P.last() as Vertex of G;
        3 <= len P by A17,XREAL_1:2; then
        P.3 = P.vertexAt(2*1+1) by GLIB_001:def 8; then
        reconsider a = P.3 as Vertex of G;

   A21: 2*0+1 < 2*1+1 & 3 < len P by A17,XREAL_1:2; then
        consider ez being set such that
    A22: ez Joins P.1,P.3,G by A17,CHORD:92;
    A23: c,a are_adjacent by A22,CHORD:def 3;
   A24: now let e be set such that A25: e Joins c,b,G;
            2*0+1 < len P by A17,XREAL_1:2; then
            (ex e being set st e Joins P.1,P.(len P),G) iff 1+2=len P
               by A17,CHORD:92;
           hence contradiction by A17,A25;
        end; then
    A26: not b,c are_adjacent by CHORD:def 3;

        consider d being Vertex of G such that
    A27: d in dom VLG & VLG.b < VLG.d and
    A28: b,d are_adjacent & not a,d are_adjacent by A1,A2,A23,A26,A17,Def41;
    A29: d <> c by A28,A24,CHORD:def 3;
    A30: VLG.a < VLG.d by A17,A27,XREAL_1:2;

    A31: now assume d in P.vertices(); then
            consider dn being odd Element of NAT such that
        A32: dn <= len P & P.dn = d by GLIB_001:88;
        A33: dn < len P by A27,A32,REAL_1:def 5;
            dn <> 1 & 1 <= dn by A32,A28,A24,CHORD:def 3,CHORD:2; then
            2*0+1 < dn by REAL_1:def 5; then
            1+2 <= dn & dn <> 3 by A32,A17,A27,CHORD:4; then
        A34: 2*1+1 < dn by REAL_1:def 5;
          per cases;
          suppose i <= dn; hence contradiction by A27,A32,A33,A19; end;
          suppose dn < i;  hence contradiction by A30,A32,A34,A20; end;
        end;
    A35: VLG.d <> VLG.c by A28,A26,A2,A5,FUNCT_1:def 8;

        defpred Mi[Nat] means
          $1 is odd & 3 < $1 & $1 <= len P &
            ex e being set st e Joins P.$1,d,G;

        consider el being set such that
    A36: el Joins P.last(),d,G by A28,CHORD:def 3;
    A37: ex k being Element of NAT st Mi[k] by A21, A36;
        ex j being Element of NAT st Mi[j] &
        for n being Element of NAT st Mi[n] holds j <= n
           from NAT_1:sch 5(A37); then
        consider j being Element of NAT such that
    A38: j is odd & 3 < j & j <= len P & ex e being set st e Joins P.j,d,G and
    A39: for i being Element of NAT st Mi[i] holds j <= i;
        reconsider j as odd Element of NAT by A38;
        consider e being set such that
    A40: e Joins P.j,d,G by A38;
   A41: 2*0+1 <= j by CHORD:2;

        reconsider C = P.cut(1,j) as Path of G;

   A42: len C + 1 = j + 1 by A38,A41,GLIB_001:37;
    A43: C.first() = P.first() & C.last() = P.j by A41,A38,GLIB_001:38;
        C.vertices() c= P.vertices() by A38,A41,GLIB_001:95; then
    A44: not d in C.vertices() by A31;
    A45: e Joins C.last(),d,G by A41,A38,GLIB_001:38,A40;
    A46: now let n be odd Element of NAT such that
        A47: n <= j; 1 <= n by CHORD:2; then
            n in dom C by A47,A42,FINSEQ_3:27; then
            C.n = P.(1 + n - 1) by A38,A41,GLIB_001:48;
          hence C.n = P.n;
        end;
        2*0+1 < j by A38,XREAL_1:2; then
    A48: C is open chordless by A38,A17,CHORD:93;
        2*1+1 < j by A38; then
    A49: C.3 = a & 3 in dom C by A46,A42,FINSEQ_3:27;
    A50: now let f be set such that A51: f Joins C.(len C-2),d,G;
          len C > 2*1+1 by A38,A42; then A52: len C >= 3+2 by CHORD:4;
          len C <> 5 by A28,A51,A49,CHORD:def 3;
          then len C > 5 by A52,REAL_1:def 5; then
        A53: 3+2-2 < len C-2 by XREAL_1:11;
            then 0 < len C-2*1;
        then reconsider cc = len C - 2 as odd Element of NAT by INT_1:16;
        A54: 3 < cc & cc < len C by A53,XREAL_1:46; then
        A55: cc < len P by A42,A38,XREAL_1:2;
            f Joins P.cc,d,G by A46,A51,A54,A42;
          hence contradiction by A54,A55,A39,A42;
        end;
        :: building the path
        reconsider D = C.addEdge(e) as Path of G by A48,A44,A45,A50,CHORD:97;
    A56: D is open & D is chordless by A48,A44,A45,A50,CHORD:97;
   A57: len D = len C + 2 by A43,A40,GLIB_001:65; then
    A58: len D >= 3+2 by A38,A42,XREAL_1:9;
    A59: D.first() = c & D.last() = d by A43,A40,GLIB_001:64;
    A60: D.3 = a by A49,A43,A40,GLIB_001:66;

    A61: now let n be odd Nat such that A62: n <= j;
            1 <= n by CHORD:2; then n in dom C by A42,A62,FINSEQ_3:27;
          hence C.n = D.n by A45,GLIB_001:66;
        end;
    A63: ex i being odd Element of NAT st 1 < i & i < len D &
    (for j,k being odd Element of NAT st i <= j & j < k & k <= len D holds
        VLG.(D.j) < VLG.(D.k)) &
    (for j,k being odd Element of NAT st 1 <= j & j < k & k <= i holds
        VLG.(D.j) > VLG.(D.k)) proof
          per cases;
          suppose A64: j <= i;
            take j;
        A65: now let e,f be odd Element of NAT such that
            A66: j <= e & e < f & f <= len D;
                e < j + 2*1 by A66,A57,A42,XREAL_1:2; then
                e <= j + 2 - 2 by CHORD:3; then
            A67: e = j by A66,XREAL_1:1; then
                D.e = C.j by A61; then
            A68: D.e = P.j by A46;
                len C + 2 <= f by A66,A67,A42,CHORD:4;  then
            A69: D.f = d by A59, A57,A66,XREAL_1:1;
                1 < 2*1+1 & 3 < j by A38; then
                VLG.(P.3) > VLG.(P.j) by A64,A20;
              hence VLG.(D.e) < VLG.(D.f) by A68,A69,A30,XREAL_1:2;
            end;
            now let e,f be odd Element of NAT such that
            A70: 1 <= e & e < f & f <= j;
                e <= j by A70,XREAL_1:2; then e <= j & D.e = C.e by A61; then
            A71: D.e = P.e by A46;
                D.f = C.f by A70,A61; then
            A72: D.f = P.f by A70,A46;
               f <= i by A70,A64,XREAL_1:2;
              hence VLG.(D.e) > VLG.(D.f) by A70,A71,A72,A20;
            end;
          hence thesis by A38,A57,A42,XREAL_1:2,XREAL_1:31,A65; end;
          suppose A73: i < j;
            take i;
       A74: len D > j by A57,A42,XREAL_1:31;
        A75: now let e,f be odd Element of NAT such that
            A76: i <= e & e < f & f <= len D;
                e < j + 2*1 by A76,A57,A42,XREAL_1:2; then
            A77: e <= j + 2 - 2 by CHORD:3; then
           A78: D.e = C.e by A61; then
            A79: D.e = P.e by A77,A46;
            A80: e <= len P by A77,A38,XREAL_1:2;
              per cases by A76,REAL_1:def 5;
              suppose A81: f = len D;
                now per cases by A80,REAL_1:def 5;
                  suppose e = len P;
                  hence VLG.(D.e) <= VLG.b by A78,A77,A46; end;
                  suppose e < len P;
                    hence VLG.(D.e) <= VLG.b by A79, A76,A19; end;
                end;
               hence VLG.(D.e) < VLG.(D.f) by A81,A59,A27,XREAL_1:2; end;
               suppose f < len D; then
            A82: f <= j + 2 - 2 by A57,A42,CHORD:3; then
                D.f = C.f by A61; then
            A83: D.f = P.f by A82,A46;
                i <= e & e < f & f <= len P by A76,A82,A38,XREAL_1:2;
              hence VLG.(D.e) < VLG.(D.f) by A79,A83,A19; end;
            end;
            now let e,f be odd Element of NAT such that
            A84: 1 <= e & e < f & f <= i;
                e <= i by A84,XREAL_1:2; then
                e <= j by XREAL_1:2,A73; then e <= j & D.e = C.e by A61; then
            A85: D.e = P.e by A46;
                f <= j by A84,A73,XREAL_1:2; then
                f <= j & D.f = C.f by A61; then
                D.f = P.f by A46;
              hence VLG.(D.e) > VLG.(D.f) by A84,A85,A20;
            end;
          hence thesis by A74,A18,A73,XREAL_1:2,A75; end;
        end;

      :: 1 --> 3 --> ... --> j --> d has Q, d > b
      VLG.c <= VLG.d by A17,A16,A27,A56,A59,A58,A60,A30,A63;
        then
    A86: VLG.c < VLG.d by A35,REAL_1:def 5;
        reconsider R = D.reverse() as Path of G;
    A87: R.first() = d & R.last() = c by A59,GLIB_001:23; then
    A88: R is open & R is chordless by A56,CHORD:91,A29,GLIB_001:def 24;
    A89: len R >= 3+2 by A58,GLIB_001:22;
        then 3 <= len R by XREAL_1:2; then
        3 in dom R by FINSEQ_3:27; then
        R.3 = D.(len D - 3 + 1) by GLIB_001:26; then
   A90: R.3 = C.j by A61,A42,A57;
        now per cases;
          suppose A91: i < j;
            now per cases by A38,REAL_1:def 5;
              suppose j = len P;
              hence VLG.(P.j) <= VLG.b; end;
              suppose j < len P;
              hence VLG.(P.j) <= VLG.b by A91,A19; end;
            end;
          hence VLG.(P.j) < VLG.c by A17,XREAL_1:2; end;
          suppose i >= j; then
            1 < 2*1+1 & 3 < j & j <= i by A38; then
            VLG.(P.j) < VLG.(P.3) by A20; then
            VLG.(P.j) < VLG.b by A17,XREAL_1:2;
          hence VLG.(P.j) < VLG.c by A17,XREAL_1:2; end;
        end; then
    A92: VLG.(R.last()) > VLG.(R.3) by A90,A46,A87;
    A93: for n being odd Element of NAT st n <= len R
           holds R.n = D.(len D - n + 1) & len D - n + 1 is Element of NAT
        proof
           let n be odd Element of NAT such that A94: n <= len R;
           1 <= n by CHORD:2; then
        A95:n in dom R by A94,FINSEQ_3:27;
           hence R.n = D.(len D - n + 1) by GLIB_001:26;
           len D - n + 1 in dom D by A95,GLIB_001:26;
         hence len D - n + 1 is Element of NAT;
        end;
     ex i being odd Element of NAT st 1 < i & i < len R &
      (for j,k being odd Element of NAT st i <= j & j < k & k <= len R holds
          VLG.(R.j) < VLG.(R.k)) &
      (for j,k being odd Element of NAT st 1 <= j & j < k & k <= i holds
          VLG.(R.j) > VLG.(R.k)) proof
            consider i being odd Element of NAT such that
        A96: 1 < i & i < len D and
    A97: for j,k being odd Element of NAT st i <= j & j < k & k <= len D holds
             VLG.(D.j) < VLG.(D.k) and
    A98: for j,k being odd Element of NAT st 1 <= j & j < k & k <= i holds
             VLG.(D.j) > VLG.(D.k) by A63;
            set ir = len D - i + 1;
            len D - 1 > len D - i by A96,XREAL_1:17; then
       A99: len D - 1 + 1 > len D - i + 1 by XREAL_1:10;
            len D - len D < len D - i by A96,XREAL_1:17; then
        A100:0 + 1 < len D - i + 1 by XREAL_1:10; then
         A101:1 < ir & ir < len R by A99,GLIB_001:22;
            reconsider ir as odd Element of NAT by A100,INT_1:16;
            take ir;
         A102:now let j,k be odd Element of NAT such that
            A103: ir <= j & j < k & k <= len R;
                set jr = len D - j + 1;
                set kr = len D - k + 1;
           A104: 1 < j & j <= len R by A100,A103,XREAL_1:2; then
           A105: R.j = D.jr by A93;
                reconsider jr as odd Element of NAT by A104,A93;
           A106: R.k = D.kr by A93,A103;
                reconsider kr as odd Element of NAT by A103,A93;
                 i + j >= len D - i + 1 + i by XREAL_1:9,A103; then
                 i + j - j >= len D + 1 - j by XREAL_1:11; then
                 1 <= kr & kr < jr & jr <= i by CHORD:2,Lm1,A103;
              hence VLG.(R.j) < VLG.(R.k) by A98,A105,A106;
            end;
            now let ja,k be odd Element of NAT such that
            A107: 1 <= ja & ja < k & k <= ir;
                 set jr = len D - ja + 1;
                 set kr = len D - k + 1;
            A108: 1 < k & k <= len R by A101,A107,XREAL_1:2;
                 i + k <= len D - i + 1 + i by XREAL_1:9,A107; then
                 i + k - k <= len D + 1 - k by XREAL_1:11; then
            A109: i <= kr & kr < jr by A107,Lm1;
                 reconsider kr as odd Element of NAT by A108,A93;
            A110: ja <= len R by A107,A108,XREAL_1:2; then
            A111: R.ja = D.jr by A93;
                 reconsider jr as odd Element of NAT by A110,A93;
                 len D - ja <= len D - 1 by A107,XREAL_1:12; then
                 jr <= len D - 1 + 1 by XREAL_1:9; then
                 VLG.(D.kr) < VLG.(D.jr) by A109,A97;
               hence VLG.(R.ja) > VLG.(R.k) by A108,A93,A111;
            end;
          hence thesis by A100,A99,GLIB_001:22,A102;
        end;
      hence contradiction by A16, A17,A87,A88,A89,A86,A92; end;
A112: rng V = dom VLG & dom V = rng VLG by A3,A4,A5,A6,FUNCT_1:54;
    now let a,b,c be Vertex of G such that
    A113: b<>c & a,b are_adjacent & a,c are_adjacent;
      let va,vb,vc be Nat such that
    A114: va in dom V & vb in dom V & vc in dom V and
    A115: V.va = a & V.vb = b & V.vc = c & va < vb & va < vc;
    assume
A116:   not b,c are_adjacent;
    A117: a = V.(VLG.a) & b = V.(VLG.b) & c = V.(VLG.c)
            by A2,A5,A6,FUNCT_1:56;
     a in dom VLG & b in dom VLG & c in dom VLG by A112,A114,A115
,FUNCT_1:def 5;then
     VLG.a in dom V & VLG.b in dom V & VLG.c in dom V by A112
,FUNCT_1:def 5;then
    A118: VLG.a = va & VLG.b = vb & VLG.c = vc by A115,A114,A4,A117
,FUNCT_1:def 8;
     per cases by A117,A113,REAL_1:def 5;
     suppose A119: VLG.b < VLG.c;
        consider P being Path of G, e1, e2 being set such that
    A120: P is open & len P = 5 & P.length() = 2 and
        e1 Joins c,a,G & e2 Joins a,b,G & P.edges() = {e1,e2} and
        P.vertices() = {c,a,b} and
    A121: P.1 = c & P.3 = a & P.5 = b by A113,A118,A115,CHORD:47;
    A122: P.first() = c & P.last() = b by A120,A121;
   A123: now let j,k be odd Element of NAT such that
        A124: 3 <= j & j < k & k <= len P;
            j < 5 by A124,A120,XREAL_1:2; then
            j < 6 by XREAL_1:2; then
        A125: j = 1 or j = 3 or j = 5 by CHORD:8;
            3 < k & k < 6 by A120,A124,XREAL_1:2;
          hence VLG.(P.j) < VLG.(P.k) by A125,A124,A120,A121,A118,A115,CHORD:8;
        end;
   A126: now let j,k be odd Element of NAT such that
        A127: 1 <= j & j < k & k <= 3;
            j < 3 by A127,XREAL_1:2; then
            j < 4 by XREAL_1:2; then
        A128: j = 1 by A127,CHORD:7;
            k < 4 by A127,XREAL_1:2;
          hence VLG.(P.j) > VLG.(P.k) by A128,A121,A118,A115,A127,CHORD:7;
        end;
        2*1+1 is odd; then
       Q[P] by A119,A123,A126,A120,A122,CHORD:90,A116;
      hence contradiction by A9; end;
     suppose A129: VLG.c < VLG.b;
        consider P being Path of G, e1, e2 being set such that
    A130: P is open & len P = 5 & P.length() = 2 and
        e1 Joins b,a,G & e2 Joins a,c,G & P.edges() = {e1,e2} and
        P.vertices() = {b,a,c} and
    A131: P.1 = b & P.3 = a & P.5 = c by A113,A118,A115,CHORD:47;
    A132: P.first() = b & P.last() = c by A130,A131;
   A133: now let j,k be odd Element of NAT such that
        A134: 3 <= j & j < k & k <= len P;
            j < 5 by A134,A130,XREAL_1:2; then
            j < 6 by XREAL_1:2; then
        A135: j = 1 or j = 3 or j = 5 by CHORD:8;
            3 < k & k < 6 by A130,A134,XREAL_1:2;
          hence VLG.(P.j) < VLG.(P.k) by A135,A134,A130,A131,A118,A115,CHORD:8;
        end;
   A136: now let j,k be odd Element of NAT such that
        A137: 1 <= j & j < k & k <= 3;
        j < 3 by A137,XREAL_1:2; then
            j < 4 by XREAL_1:2; then
        A138: j = 1 by A137,CHORD:7;
            k < 4 by A137,XREAL_1:2;
          hence VLG.(P.j) > VLG.(P.k) by A138,A131,A118,A115,A137,CHORD:7;
        end;
        2*1+1 is odd; then
       Q[P] by A129,A133,A136,A130,A132,CHORD:90,A116;
      hence contradiction by A9; end;
    end;
  hence V is perfect by CHORD:109;
end;
