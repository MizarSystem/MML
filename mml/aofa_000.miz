:: Mizar Analysis of Algorithms: Preliminaries
::  by Grzegorz Bancerek
::
:: Received July 9, 2007
:: Copyright (c) 2007 Association of Mizar Users

environ

 vocabularies AOFA_000, UNIALG_1, FUNCT_1, BINOP_1, GROUP_1, FINSEQ_1, RELAT_1,
      BINTREE1, FUNCT_2, PARTFUN1, COMPUT_1, BOOLE, MSUALG_1, FUNCT_7,
      ZF_REFLE, SUPINF_1, RLVECT_1, FUNCOP_1, FUNCT_4, ARYTM, PROB_1, TARSKI,
      TREES_4, FINSEQ_2, ARYTM_1, FINSET_1, CQC_LANG, SUBSET_1, FUNCT_3,
      VECTSP_1, SETFAM_1, FREEALG, FINSEQ_4, DTCONSTR, CARD_1, TREES_2, LANG1,
      TDGROUP, TREES_3, RAT_1, TREES_1, MEMBERED, SQUARE_1, WELLORD1, INCPROJ,
      FACIRC_1, UNIALG_2, PRELAMB, FUNCT_5, CQC_SIM1, ALG_1, ORDINAL2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ENUMSET1, SETFAM_1, ORDINAL1,
      MEMBERED, RELAT_1, FUNCT_1, RELSET_1, PARTFUN1, FUNCT_2, FINSET_1, LANG1,
      FINSEQ_1, BINOP_1, CARD_1, CARD_3, FRAENKEL, FINSEQ_2, PRE_CIRC,
      FACIRC_1, NUMBERS, XCMPLX_0, XXREAL_0, XREAL_0, TREES_1, TREES_2,
      TREES_3, NAT_1, BINARITH, WSIERP_1, SUPINF_1, MESFUNC1, FUNCOP_1,
      FUNCT_4, FUNCT_5, FUNCT_7, ABIAN, CAT_2, BORSUK_1, MARGREL1, STRUCT_0,
      UNIALG_1, UNIALG_2, ALG_1, FREEALG, PUA2MSS1, COMPUT_1, SUPINF_2,
      TREES_4, DTCONSTR, FINSEQ_4;
 constructors PUA2MSS1, COMPUT_1, BINARITH, REAL_1, BORSUK_1, SUPINF_2,
      FINSEQ_4, POLYNOM1, FACIRC_1, ALG_1, FREEALG, FINSEQOP, WSIERP_1,
      PRE_CIRC, WELLORD2, CAT_2, ABIAN, MESFUNC1;
 registrations FUNCT_1, FUNCOP_1, FINSEQ_2, FUNCT_2, FINSEQ_1, UNIALG_1, NAT_1,
      STRUCT_0, PUA2MSS1, DTCONSTR, FREEALG, FUNCT_7, CARD_4, CARD_5, SUBSET_1,
      XXREAL_0, XREAL_0, TREES_2, TREES_3, MEMBERED, XBOOLE_0, FINSET_1,
      TREES_1, PRE_CIRC, FACIRC_1, RELAT_1;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;
 definitions SUBSET_1, TREES_4, SUPINF_2, MEMBERED, TARSKI, PUA2MSS1, FUNCT_1,
      MESFUNC1, FREEALG, RELAT_1, FINSEQ_1, UNIALG_1, UNIALG_2, COMPUT_1,
      BINOP_1, XBOOLE_0;
 theorems XBOOLE_1, ZFMISC_1, RELAT_1, RELSET_1, FUNCT_2, FUNCOP_1, CATALG_1,
      COMPUT_1, UNIALG_1, FINSEQ_1, FINSEQ_2, TARSKI, XBOOLE_0, FINSEQ_3,
      XREAL_1, FUNCT_7, NAT_1, ORDINAL1, PARTFUN1, FUNCT_3, BINARITH, DTCONSTR,
      FUNCT_4, FREEALG, TREES_4, FUNCT_1, LANG1, CARD_2, CARD_1, CARD_4,
      CARD_5, TREES_3, PRE_CIRC, ENUMSET1, FINSEQ_5, WELLORD2, GROUP_7,
      UNIALG_2, FINSET_1, STIRL2_1, JORDAN16, ALTCAT_1, FUNCT_5, FUNCT_6,
      MSUALG_1, ALG_1, XREAL_0, XXREAL_0, SETFAM_1, MSUALG_8, SUPINF_2,
      POLYNOM1;
 schemes NAT_1, FUNCT_1, RECDEF_1, FINSEQ_2, CIRCCMB3, PRE_CIRC, WELLORD2,
      XBOOLE_0, CLASSES1, ALTCAT_2, FINSEQ_1;

begin :: Binary operations, orbits, and iterations

notation
  let x,y be set;
  antonym x nin y for x in y;
end;

theorem Th1:
  for f,g,h being Function
  for A being set st A c= dom f & A c= dom g & rng h c= A &
    for x being set st x in A holds f.x = g.x
  holds f*h = g*h
  proof
    let f,g,h be Function;
    let A be set such that
A1: A c= dom f and
A2: A c= dom g and
A3: rng h c= A and
A4: for x being set st x in A holds f.x = g.x;
     rng h c= dom f & rng h c= dom g by A1,A2,A3,XBOOLE_1:1;
then A5: dom (f*h) = dom h & dom (g*h) = dom h by RELAT_1:46;
     now
      let x be set; assume x in dom h;
      then (f*h).x = f.(h.x) & (g*h).x = g.(h.x) & h.x in rng h
      by FUNCT_1:12,23;
      hence (f*h).x = (g*h).x by A3,A4;
    end;
    hence f*h = g*h by A5,FUNCT_1:9;
  end;

registration
  let x,y be non empty set;
  cluster <*x,y*> -> non-empty;
  coherence
  proof
    assume {} in rng <*x,y*>;
    then {} in {x,y} by FINSEQ_2:147;
    hence thesis by TARSKI:def 2;
  end;
end;

registration
  let p,q be non-empty FinSequence;
  cluster p^q -> non-empty;
  coherence
  proof
    assume {} in rng (p^q);
    then {} in (rng p) \/ rng q by FINSEQ_1:44;
    then {} in rng p or {} in rng q by XBOOLE_0:def 2;
    hence thesis by RELAT_1:def 9;
  end;
end;

definition
  let f be homogeneous Function;
  let x be set;
  pred x is_a_unity_wrt f means:
Def1:
  for y,z being set st <*y,z*> in dom f or <*z,y*> in dom f
  holds <*x,y*> in dom f & f.<*x,y*> = y &
        <*y,x*> in dom f & f.<*y,x*> = y;
end;

definition
  let f be homogeneous Function;
  attr f is associative means:
Def2:
  for x,y,z being set st <*x,y*> in dom f & <*y,z*> in dom f &
  <*f.<*x,y*>,z*> in dom f & <*x,f.<*y,z*>*> in dom f
  holds f.<*f.<*x,y*>,z*> = f.<*x,f.<*y,z*>*>;
  attr f is unital means:
Def3:
  ex x being set st x is_a_unity_wrt f;
end;

definition
  let X be set;
  let Y be non empty set;
  let Z be FinSequenceSet of X;
  let y be Element of Y;
  redefine func Z --> y -> PartFunc of X*,Y;
  coherence
  proof
     dom (Z --> y) = Z & Z c= X* & rng (Z --> y) c= {y}
    by COMPUT_1:13,FUNCOP_1:19;
    hence thesis by RELSET_1:11;
  end;
end;

registration
  let X be non empty set;
  let x be Element of X;
  let n be Nat;
  cluster (n-tuples_on X) --> x ->
  non empty quasi_total homogeneous PartFunc of X*, X;
  coherence
  proof
    reconsider m = n as Element of NAT by ORDINAL1:def 13;
    set f = (n-tuples_on X) --> x;
A1: m-tuples_on X c= X* & rng f c= X &
    dom f = m-tuples_on X by CATALG_1:6,FUNCOP_1:19;
    then reconsider f as non empty homogeneous PartFunc of X*, X
    by COMPUT_1:19,RELAT_1:60;
     arity f = m by A1,COMPUT_1:27;
    hence thesis by A1,COMPUT_1:25;
  end;
end;

theorem Th2:
  for X being non empty set, x being Element of X
  for n being Nat holds arity ((n-tuples_on X) --> x) = n
  proof
    let X be non empty set;
    let x be Element of X;
    let n be Nat;
    reconsider m = n as Element of NAT by ORDINAL1:def 13;
    set f = (n-tuples_on X) --> x;
     dom f = m-tuples_on X by FUNCOP_1:19;
    hence arity f = n by COMPUT_1:27;
  end;

Lm1: now let X be non empty set;
        let x be Element of X;
        thus (0-tuples_on X) --> x is nullary
        proof
          thus arity ((0-tuples_on X) --> x) = 0 by Th2;
        end;
        thus (1-tuples_on X) --> x is unary
        proof
          thus arity ((1-tuples_on X) --> x) = 1 by Th2;
        end;
        thus (2-tuples_on X) --> x is binary
        proof
          thus arity ((2-tuples_on X) --> x) = 2 by Th2;
        end;
        thus (3-tuples_on X) --> x is ternary
        proof
          thus arity ((3-tuples_on X) --> x) = 3 by Th2;
        end;
      end;

registration
  let X be non empty set;
  let x be Element of X;
  cluster (0-tuples_on X) --> x -> nullary (homogeneous PartFunc of X*, X);
  coherence by Lm1;
  cluster (1-tuples_on X) --> x -> unary (homogeneous PartFunc of X*, X);
  coherence by Lm1;
  cluster (2-tuples_on X) --> x -> binary (homogeneous PartFunc of X*, X);
  coherence by Lm1;
  cluster (3-tuples_on X) --> x -> ternary (homogeneous PartFunc of X*, X);
  coherence by Lm1;
end;

registration
  let X be non empty set;
  cluster binary associative unital
  (non empty quasi_total homogeneous PartFunc of X*, X);
  existence
  proof
    consider x being Element of X;
    deffunc F((Element of X), Element of X) = IFEQ($1,x,$2,$1);
     (ex f being Function of 2-tuples_on X, X st
    for x,y being Element of X holds f.<*x,y*> = F(x,y)) &
    for f1,f2 being Function of 2-tuples_on X, X st
    (for x,y being Element of X holds f1.<*x,y*> = F(x,y)) &
    (for x,y being Element of X holds f2.<*x,y*> = F(x,y))
    holds f1 = f2  from CIRCCMB3:sch 7;
    then consider f being Function of 2-tuples_on X, X such that
A1: for a,b being Element of X holds f.<*a,b*> = IFEQ(a,x,b,a);
A2: 2-tuples_on X c= X* & rng f c= X &
    dom f = 2-tuples_on X by CATALG_1:6,FUNCT_2:def 1;
    then reconsider f as non empty homogeneous PartFunc of X*, X
    by COMPUT_1:19,RELSET_1:11;
     arity f = 2 by A2,COMPUT_1:27;
    then reconsider f as non empty quasi_total homogeneous PartFunc of X*, X
      by A2,COMPUT_1:25;
    take f;
    thus arity f = 2 by A2,COMPUT_1:27;
    hereby let u,y,z be set;
      assume <*u,y*> in dom f & <*y,z*> in dom f;
      then reconsider u' = u, y' = y, z' = z as Element of X by A2,CATALG_1:11;
      assume <*f.<*u,y*>,z*> in dom f & <*u,f.<*y,z*>*> in dom f;
A3:   (u = x implies IFEQ(u,x,y,u) = y) & (u <> x implies IFEQ(u,x,y,u) = u) &
      (u = x implies IFEQ(u,x,IFEQ(y,x,z,y),u) = IFEQ(y,x,z,y)) &
      (u <> x implies IFEQ(u,x,IFEQ(y,x,z,y),u) = u) &
      (u <> x implies IFEQ(u,x,z,u) = u) by FUNCOP_1:def 8;
      thus f.<*f.<*u,y*>,z*> = f.<*IFEQ(u',x,y',u'),z'*> by A1
      .= IFEQ(IFEQ(u,x,y,u),x,z,IFEQ(u,x,y,u)) by A1
      .= f.<*u',IFEQ(y',x,z',y')*> by A1,A3
      .= f.<*u,f.<*y,z*>*> by A1;
    end;
    take x; let y,z be set;
    assume <*y,z*> in dom f or <*z,y*> in dom f;
    then reconsider y' = y, z' = z as Element of X by A2,CATALG_1:11;
     <*x,y'*> in 2-tuples_on X by CATALG_1:10;
    hence <*x,y*> in dom f by FUNCT_2:def 1;
    thus f.<*x,y*> = IFEQ(x,x,y',x) by A1 .= y by FUNCOP_1:def 8;
     <*y',x*> in 2-tuples_on X by CATALG_1:10;
    hence <*y,x*> in dom f by FUNCT_2:def 1;
A4: x = y or x <> y;
    thus f.<*y,x*> = IFEQ(y',x,x,y') by A1 .= y by A4,FUNCOP_1:def 8;
  end;
  cluster nullary (non empty quasi_total homogeneous PartFunc of X*, X);
  existence
  proof
    consider x being Element of X;
    set f = (0-tuples_on X) --> x;
    take f; thus arity f = 0 by Th2;
  end;
  cluster ternary (non empty quasi_total homogeneous PartFunc of X*, X);
  existence
  proof
    consider x being Element of X;
    set f = (3-tuples_on X) --> x;
    take f; thus arity f = 3 by Th2;
  end;
end;

theorem Th3:
  for X being non empty set
  for p being FinSequence of FinTrees X
  for x,t being set st t in rng p
  holds t <> x-tree p
  proof
    let X be non empty set;
    let p be FinSequence of FinTrees X;
    let x,t be set;
    assume
A1: t in rng p;
    then reconsider T = t as Element of FinTrees X;
    reconsider A = dom T as finite Tree;
    defpred P[set] means not contradiction;
    deffunc F(Element of A) = len $1;
     {F(e) where e is Element of A: P[e]} is finite from PRE_CIRC:sch 1;
    then reconsider B = {F(e) where e is Element of A: P[e]} as finite set;
    consider e being Element of A;
A2: F(e) in B;
     B is real-membered
    proof
      let a be set; assume a in B;
      then ex e being Element of A st a = F(e);
      hence a is real;
    end;
    then reconsider B as non empty finite real-membered set by A2;
     max B in B by PRE_CIRC:def 1;
    then consider e being Element of A such that
A3: max B = len e;
    consider i being set such that
A4: i in dom p & t = p.i by A1,FUNCT_1:def 5;
    reconsider i as Nat by A4,ORDINAL1:def 13;
     i >= 1 by A4,FINSEQ_3:27;
    then consider j being Nat such that
A5: i = 1+j by NAT_1:10;
     i <= len p by A4,FINSEQ_3:27;
    then j < len p & j in NAT by A5,NAT_1:13,ORDINAL1:def 13;
then A6: <*j*>^e in dom (x-tree p) by A4,A5,TREES_4:11;
     len (<*j*>^e) = 1+len e by FINSEQ_5:8;
    then len (<*j*>^e) > max B by A3,NAT_1:13;
    then len (<*j*>^e) nin B by PRE_CIRC:def 1;
    hence t <> x-tree p by A6;
  end;

definition
  let f,g be Function;
  let X be set;
  func (f,X)+*g -> Function equals  g+*(f|X);
  coherence;
end;

theorem Th4:
  for f,g being Function, x,X being set holds
  x in X & X c= dom f implies ((f,X)+*g).x = f.x
  proof
    let f,g be Function;
    let x,X be set;
    assume
A1: x in X;
    assume X c= dom f;
    then x in dom f & dom (f|X) = dom f /\ X by A1,FUNCT_1:68;
then A2: x in dom (f|X) by A1,XBOOLE_0:def 3;
    then (f|X).x = f.x by FUNCT_1:68;
    hence ((f,X)+*g).x = f.x by A2,FUNCT_4:14;
  end;

theorem Th5:
  for f,g being Function, x,X being set holds
  x nin X & x in dom g implies ((f,X)+*g).x = g.x
  proof
    let f,g be Function;
    let x,X be set;
    assume x nin X;
    then x nin dom f /\ X by XBOOLE_0:def 3;
    then x nin dom (f|X) by FUNCT_1:68;
    hence thesis by FUNCT_4:12;
  end;

definition
  let X,Y be non empty set;
  let f,g be Element of Funcs(X,Y);
  let A be set;
  redefine func (f,A)+*g -> Element of Funcs(X,Y);
  coherence
  proof
 dom f = X & dom g = X & rng f c= Y & rng g c= Y by FUNCT_2:169;
    then dom g \/ dom (f|A) = X by XBOOLE_1:12;
then A1: dom ((f,A)+*g) = X by FUNCT_4:def 1;
     rng ((f,A)+*g) c= rng g \/ rng (f|A) & rng g \/ rng (f|A) c= Y \/ Y
    by FUNCT_4:18;
    then rng ((f,A)+*g) c= Y by XBOOLE_1:1;
    hence thesis by A1,FUNCT_2:def 2;
  end;
end;

definition
  let X,Y,Z be non empty set;
  let f be Element of Funcs(X,Y);
  let g be Element of Funcs(Y,Z);
  redefine func g*f -> Element of Funcs(X,Z);
  coherence
  proof
     g*f is Function of X,Z;
    hence thesis by FUNCT_2:11;
  end;
end;

definition
  let f be Function;
  let x be set;
  func f orbit x equals
   {iter(f,n).x where n is Element of NAT: x in dom iter(f,n)};
  coherence;
end;

theorem Th6:
  for f being Function, x being set st x in dom f
  holds x in f orbit x
  proof
    let f be Function;
    let x be set; assume
     x in dom f;
then A1: x in dom f \/ rng f & iter(f,0) = id (dom f \/ rng f)
    by FUNCT_7:70,XBOOLE_0:def 2;
    then iter(f,0).x = x & dom iter(f,0) = dom f \/ rng f by FUNCT_1:34;
    hence x in f orbit x by A1;
  end;

theorem
   for f being Function, x,y being set
  st rng f c= dom f & y in f orbit x holds f.y in f orbit x
  proof
    let f be Function;
    let x,y be set; assume
A1: rng f c= dom f;
    assume y in f orbit x;
    then consider n being Element of NAT such that
A2: y = iter(f,n).x & x in dom iter(f,n);
A3: iter(f,n+1) = f*iter(f,n) by FUNCT_7:73;
then A4: f.y = iter(f,n+1).x by A2,FUNCT_1:23;
     y in rng iter(f,n) & rng iter(f,n) c= dom f \/ rng f &
    dom f \/ rng f = dom f by A1,A2,FUNCT_1:def 5,FUNCT_7:74,XBOOLE_1:12;
    then x in dom iter(f,n+1) by A2,A3,FUNCT_1:21;
    hence f.y in f orbit x by A4;
  end;

theorem
   for f being Function, x being set st x in dom f holds f.x in f orbit x
  proof
    let f be Function;
    let x be set;
    assume
A1: x in dom f;
     iter(f,1) = f by FUNCT_7:72;
    hence f.x in f orbit x by A1;
  end;

theorem Th9:
  for f being Function, x being set st x in dom f & f.x in dom f
  holds f orbit (f.x) c= f orbit x
  proof
    let f be Function;
    let x be set;
    assume
A1: x in dom f & f.x in dom f;
    let a be set; assume a in f orbit (f.x);
    then consider n being Element of NAT such that
A2: a = iter(f,n).(f.x) & f.x in dom iter(f,n);
     iter(f,n+1) = iter(f,n)*f by FUNCT_7:71;
    then a = iter(f,n+1).x & x in dom iter(f,n+1) by A1,A2,FUNCT_1:21,23;
    hence thesis;
  end;

definition
  let f be Function such that
A1: rng f c= dom f;
  let A be set;
  let x be set;
    defpred T[Nat] means
    for a being set st a in dom f holds a in dom iter(f,$1);
A2: dom f \/ rng f = dom f by A1,XBOOLE_1:12;
    then iter(f,0) = id dom f by FUNCT_7:70;
then A3: T[0] by FUNCT_1:34;
A4: now let i be Element of NAT; assume
A5:   T[i];
      thus T[i+1]
      proof
        let a be set;
        assume a in dom f;
then A6:     a in dom iter(f,i) by A5;
then A7:     iter(f,i).a in rng iter(f,i) & rng iter(f,i) c= dom f
        by A2,FUNCT_1:def 5,FUNCT_7:74;
         iter(f,i+1) = f*iter(f,i) by FUNCT_7:73;
        hence thesis by A6,A7,FUNCT_1:21;
      end;
    end;
A8: for i being Element of NAT holds T[i] from NAT_1:sch 1(A3,A4);
  func (A,x) iter f -> Function means
   dom it = dom f &
  for a being set st a in dom f holds
    (f orbit a c= A implies it.a = x) &
    for n being Nat st iter(f,n).a nin A &
       for i being Nat st i < n holds iter(f,i).a in A
    holds it.a = iter(f,n).a;
  existence
  proof
    defpred P[set] means f orbit $1 c= A;
    consider Z being set such that
A9: for a being set holds a in Z iff a in dom f & P[a] from XBOOLE_0:sch 1;
A10: Z c= dom f
    proof
      let a be set; thus thesis by A9;
    end;
    defpred Q[set,set] means
    ex n being Nat st $2 = iter(f,n).$1 & $2 nin A &
    for i being Nat st i < n holds iter(f,i).$1 in A;
A11: for a being set st a in (dom f) \ Z ex b being set st Q[a,b]
    proof
      let a be set; assume a in (dom f) \ Z;
      then a in dom f & a nin Z by XBOOLE_0:def 4;
      then not f orbit a c= A by A9;
      then consider y being set such that
A12:   y in f orbit a & y nin A by TARSKI:def 3;
      consider n1 being Element of NAT such that
A13:   y = iter(f,n1).a & a in dom iter(f,n1) by A12;
      defpred R[Nat] means iter(f,$1).a nin A;
A14:   ex n being Element of NAT st R[n] by A12,A13;
      consider n being Element of NAT such that
A15:   R[n] and
A16:   for m being Element of NAT st R[m] holds n <= m from NAT_1:sch 5(A14);
      take b = iter(f,n).a, n; thus b = iter(f,n).a & b nin A by A15;
      let i be Nat;  i in NAT by ORDINAL1:def 13;
      hence thesis by A16;
    end;
    consider h being Function such that
A17: dom h = (dom f) \ Z and
A18: for a being set st a in (dom f) \ Z holds Q[a,h.a] from CLASSES1:sch 1(A11
);
    take g = (Z-->x)+*h;
     dom (Z-->x) = Z by FUNCOP_1:19;
    hence dom g = Z \/ (dom f \ Z) by A17,FUNCT_4:def 1
    .= dom f by A10,XBOOLE_1:45;
    let a be set; assume
A19: a in dom f;
    hereby assume f orbit a c= A;
      then a in Z by A9,A19;
      then a nin dom f \ Z & (Z-->x).a = x by FUNCOP_1:13,XBOOLE_0:def 4;
      hence g.a = x by A17,FUNCT_4:12;
    end;
    let n be Nat; assume
A20: iter(f,n).a nin A & for i being Nat st i < n holds iter(f,i).a in A;
A21: n in NAT by ORDINAL1:def 13;
    then a in dom iter(f,n) by A8,A19;
    then iter(f,n).a in f orbit a by A21;
    then not f orbit a c= A by A20;
    then a nin Z by A9;
then A22: a in dom f \ Z by A19,XBOOLE_0:def 4;
    then consider n2 being Nat such that
A23: h.a = iter(f,n2).a & h.a nin A &
    for i being Nat st i < n2 holds iter(f,i).a in A by A18;
     n <= n2 & n2 <= n by A20,A23;
    then n = n2 by XXREAL_0:1;
    hence g.a = iter(f,n).a by A17,A22,A23,FUNCT_4:14;
  end;
  uniqueness
  proof
    let f1,f2 be Function such that
A24: dom f1 = dom f and
A25: for a being set st a in dom f holds
    (f orbit a c= A implies f1.a = x) &
    for n being Nat st iter(f,n).a nin A &
       for i being Nat st i < n holds iter(f,i).a in A
    holds f1.a = iter(f,n).a and
A26: dom f2 = dom f and
A27: for a being set st a in dom f holds
    (f orbit a c= A implies f2.a = x) &
    for n being Nat st iter(f,n).a nin A &
       for i being Nat st i < n holds iter(f,i).a in A
    holds f2.a = iter(f,n).a;
     now let a be set; assume
A28:   a in dom f;
      per cases;
      suppose
A29:     f orbit a c= A;
        hence f1.a = x by A25,A28 .= f2.a by A27,A28,A29;
      end;
      suppose not f orbit a c= A;
        then consider y being set such that
A30:     y in f orbit a & y nin A by TARSKI:def 3;
        consider n1 being Element of NAT such that
A31:     y = iter(f,n1).a & a in dom iter(f,n1) by A30;
        defpred R[Nat] means iter(f,$1).a nin A;
A32:     ex n being Element of NAT st R[n] by A30,A31;
        consider n being Element of NAT such that
A33:     R[n] and
A34:     for m being Element of NAT st R[m] holds n <= m from NAT_1:sch 5(A32);
A35:     now let i be Nat;
           i in NAT by ORDINAL1:def 13;
          hence i < n implies iter(f,i).a in A by A34;
        end;
        hence f1.a = iter(f,n).a by A25,A28,A33 .= f2.a by A27,A28,A33,A35;
      end;
    end;
    hence thesis by A24,A26,FUNCT_1:9;
  end;
end;

definition
  let f be Function such that
A1: rng f c= dom f;
  let A be set;
  let g be Function;
    defpred T[Nat] means
    for a being set st a in dom f holds a in dom iter(f,$1);
A2: dom f \/ rng f = dom f by A1,XBOOLE_1:12;
    then iter(f,0) = id dom f by FUNCT_7:70;
then A3: T[0] by FUNCT_1:34;
A4: now let i be Element of NAT; assume
A5:   T[i];
      thus T[i+1]
      proof
        let a be set;
        assume a in dom f;
then A6:     a in dom iter(f,i) by A5;
then A7:     iter(f,i).a in rng iter(f,i) & rng iter(f,i) c= dom f
        by A2,FUNCT_1:def 5,FUNCT_7:74;
         iter(f,i+1) = f*iter(f,i) by FUNCT_7:73;
        hence thesis by A6,A7,FUNCT_1:21;
      end;
    end;
A8: for i being Element of NAT holds T[i] from NAT_1:sch 1(A3,A4);
  func (A,g) iter f -> Function means:
Def7:
  dom it = dom f &
  for a being set st a in dom f holds
    (f orbit a c= A implies it.a = g.a) &
    for n being Nat st iter(f,n).a nin A &
       for i being Nat st i < n holds iter(f,i).a in A
    holds it.a = iter(f,n).a;
  existence
  proof
    defpred P[set] means f orbit $1 c= A;
    consider Z being set such that
A9: for a being set holds a in Z iff a in dom f & P[a] from XBOOLE_0:sch 1;
A10: Z c= dom f
    proof
      let a be set; thus thesis by A9;
    end;
    defpred Q[set,set] means
    ex n being Nat st $2 = iter(f,n).$1 & $2 nin A &
    for i being Nat st i < n holds iter(f,i).$1 in A;
A11: for a being set st a in (dom f) \ Z ex b being set st Q[a,b]
    proof
      let a be set; assume a in (dom f) \ Z;
      then a in dom f & a nin Z by XBOOLE_0:def 4;
      then not f orbit a c= A by A9;
      then consider y being set such that
A12:   y in f orbit a & y nin A by TARSKI:def 3;
      consider n1 being Element of NAT such that
A13:   y = iter(f,n1).a & a in dom iter(f,n1) by A12;
      defpred R[Nat] means iter(f,$1).a nin A;
A14:   ex n being Element of NAT st R[n] by A12,A13;
      consider n being Element of NAT such that
A15:   R[n] and
A16:   for m being Element of NAT st R[m] holds n <= m from NAT_1:sch 5(A14);
      take b = iter(f,n).a, n; thus b = iter(f,n).a & b nin A by A15;
      let i be Nat;  i in NAT by ORDINAL1:def 13;
      hence thesis by A16;
    end;
    consider h being Function such that
A17: dom h = (dom f) \ Z and
A18: for a being set st a in (dom f) \ Z holds Q[a,h.a] from CLASSES1:sch 1(A11
);
    take i = (Z-->0)+*(g|Z)+*h;
A19: dom(g|Z) c= Z by RELAT_1:87;
     dom (Z-->0) = Z by FUNCOP_1:19;
    then dom ((Z-->0)+*(g|Z)) = Z \/ dom(g|Z) by FUNCT_4:def 1
    .= Z by A19,XBOOLE_1:12;
    hence dom i = Z \/ (dom f \ Z) by A17,FUNCT_4:def 1
    .= dom f by A10,XBOOLE_1:45;
    let a be set; assume
A20: a in dom f;
    hereby assume f orbit a c= A;
then A21:   a in Z by A9,A20;
      then a nin dom f \ Z & (Z-->0).a = 0 by FUNCOP_1:13,XBOOLE_0:def 4;
then A22:   i.a = ((Z-->0)+*(g|Z)).a by A17,FUNCT_4:12;
      per cases;
      suppose a in dom(g|Z);
        then i.a = (g|Z).a by A22,FUNCT_4:14;
        hence i.a = g.a by A21,FUNCT_1:72;
      end;
      suppose a nin dom(g|Z);
        then i.a = (Z-->0).a & (Z-->0).a = 0 & a nin dom g
        by A21,A22,FUNCOP_1:13,FUNCT_4:12,RELAT_1:86;
        hence i.a = g.a by FUNCT_1:def 4;
      end;
    end;
    let n be Nat; reconsider n' = n as Element of NAT by ORDINAL1:def 13;
    assume
A23: iter(f,n).a nin A & for i being Nat st i < n holds iter(f,i).a in A;
     a in dom iter(f,n') by A8,A20;
    then iter(f,n).a in f orbit a;
    then not f orbit a c= A by A23;
    then a nin Z by A9;
then A24: a in dom f \ Z by A20,XBOOLE_0:def 4;
    then consider n2 being Nat such that
A25: h.a = iter(f,n2).a & h.a nin A &
    for i being Nat st i < n2 holds iter(f,i).a in A by A18;
     n <= n2 & n2 <= n by A23,A25;
    then n = n2 by XXREAL_0:1;
    hence i.a = iter(f,n).a by A17,A24,A25,FUNCT_4:14;
  end;
  uniqueness
  proof
    let f1,f2 be Function such that
A26: dom f1 = dom f and
A27: for a being set st a in dom f holds
    (f orbit a c= A implies f1.a = g.a) &
    for n being Nat st iter(f,n).a nin A &
       for i being Nat st i < n holds iter(f,i).a in A
    holds f1.a = iter(f,n).a and
A28: dom f2 = dom f and
A29: for a being set st a in dom f holds
    (f orbit a c= A implies f2.a = g.a) &
    for n being Nat st iter(f,n).a nin A &
       for i being Nat st i < n holds iter(f,i).a in A
    holds f2.a = iter(f,n).a;
     now let a be set; assume
A30:   a in dom f;
      per cases;
      suppose
A31:     f orbit a c= A;
        hence f1.a = g.a by A27,A30 .= f2.a by A29,A30,A31;
      end;
      suppose not f orbit a c= A;
        then consider y being set such that
A32:     y in f orbit a & y nin A by TARSKI:def 3;
        consider n1 being Element of NAT such that
A33:     y = iter(f,n1).a & a in dom iter(f,n1) by A32;
        defpred R[Nat] means iter(f,$1).a nin A;
A34:     ex n being Element of NAT st R[n] by A32,A33;
        consider n being Element of NAT such that
A35:     R[n] and
A36:     for m being Element of NAT st R[m] holds n <= m from NAT_1:sch 5(A34);
A37:     now let i be Nat;  i in NAT by ORDINAL1:def 13;
          hence i < n implies iter(f,i).a in A by A36;
        end;
        hence f1.a = iter(f,n).a by A27,A30,A35 .= f2.a by A29,A30,A35,A37;
      end;
    end;
    hence thesis by A26,A28,FUNCT_1:9;
  end;
end;

theorem Th10:
  for f,g being Function, a,A being set
  st rng f c= dom f & a in dom f holds
  not f orbit a c= A implies
  ex n being Nat st ((A,g) iter f).a = iter(f,n).a & iter(f,n).a nin A &
  for i being Nat st i < n holds iter(f,i).a in A
  proof
    let f,g be Function;
    let a,A be set;
    assume
A1: rng f c= dom f;
    assume
A2: a in dom f;
    assume not f orbit a c= A;
    then consider y being set such that
A3: y in f orbit a & y nin A by TARSKI:def 3;
    consider n1 being Element of NAT such that
A4: y = iter(f,n1).a & a in dom iter(f,n1) by A3;
    defpred R[Nat] means iter(f,$1).a nin A;
A5: ex n being Element of NAT st R[n] by A3,A4;
    consider n being Element of NAT such that
A6: R[n] and
A7: for m being Element of NAT st R[m] holds n <= m from NAT_1:sch 5(A5);
A8: now let i being Nat;  i in NAT by ORDINAL1:def 13;
      hence i < n implies iter(f,i).a in A by A7;
    end;
    take n;
    thus ((A,g) iter f).a = iter(f,n).a by A1,A2,A6,A8,Def7;
    thus thesis by A6,A8;
  end;

theorem Th11:
  for f,g being Function, a,A being set
  st rng f c= dom f & a in dom f & g*f = g holds
  a in A implies ((A,g) iter f).a = ((A,g) iter f).(f.a)
  proof
    let f,g be Function;
    let a,A be set;
    assume
A1: rng f c= dom f & a in dom f & g*f = g & a in A;
then A2: f.a in rng f by FUNCT_1:def 5;
then A3: f orbit (f.a) c= f orbit a by A1,Th9;
    per cases;
    suppose
A4:   f orbit a c= A;
      then f orbit (f.a) c= A by A3,XBOOLE_1:1;
      then ((A,g) iter f).(f.a) = g.(f.a) by A1,A2,Def7 .= g.a by A1,FUNCT_1:23
;
      hence ((A,g) iter f).a = ((A,g) iter f).(f.a) by A1,A4,Def7;
    end;
    suppose not f orbit a c= A;
      then consider n being Nat such that
A5:   ((A,g) iter f).a = iter(f,n).a & iter(f,n).a nin A &
      for i being Nat st i < n holds iter(f,i).a in A by A1,Th10;
       dom f \/ rng f = dom f by A1,XBOOLE_1:12;
      then iter(f,0) = id dom f by FUNCT_7:70;
      then n <> 0 by A1,A5,FUNCT_1:35;
      then n > 0;
      then n >= 0+1 by NAT_1:13;
      then consider i being Nat such that
A6:   n = 1+i by NAT_1:10;
       iter(f,n) = iter(f,i)*f by A6,FUNCT_7:71;
then A7:   iter(f,n).a = iter(f,i).(f.a) by A1,FUNCT_1:23;
       now let j be Nat; assume j < i;
        then j+1 < n by A6,XREAL_1:10;
        then iter(f,j+1) = iter(f,j)*f & iter(f,j+1).a in A by A5,FUNCT_7:71;
        hence iter(f,j).(f.a) in A by A1,FUNCT_1:23;
      end;
      hence ((A,g) iter f).a = ((A,g) iter f).(f.a) by A1,A2,A5,A7,Def7;
    end;
  end;

theorem Th12:
  for f,g being Function, a,A being set
  st rng f c= dom f & a in dom f holds
  a nin A implies ((A,g) iter f).a = a
  proof
    let f,g be Function;
    let a,A be set;
    assume
A1: rng f c= dom f & a in dom f & a nin A;
    then dom f \/ rng f = dom f by XBOOLE_1:12;
    then iter(f,0) = id dom f by FUNCT_7:70;
then A2: a = iter(f,0).a by A1,FUNCT_1:35;
     for i being Nat st i < 0 holds iter(f,i).a in A;
    hence ((A,g) iter f).a = a by A1,A2,Def7;
  end;

definition
  let X be non empty set;
  let f be Element of Funcs(X,X);
  let A be set;
  let g be Element of Funcs(X,X);
  redefine func (A,g) iter f -> Element of Funcs(X,X);
  coherence
  proof
A1: dom f = X & rng f c= X by FUNCT_2:def 1;
then A2: dom ((A,g) iter f) = dom f by Def7;
     rng ((A,g) iter f) c= X
    proof
      let a be set; assume a in rng ((A,g) iter f);
      then consider b being set such that
A3:   b in dom ((A,g) iter f) & a = ((A,g) iter f).b by FUNCT_1:def 5;
      reconsider b as Element of X by A1,A3,Def7;
      per cases;
      suppose f orbit b c= A;
        then a = g.b by A1,A3,Def7;
        hence a in X;
      end;
      suppose not f orbit b c= A;
        then consider n being Nat such that
A4:     ((A,g) iter f).b = iter(f,n).b & iter(f,n).b nin A &
        for i being Nat st i < n holds iter(f,i).b in A by A1,Th10;
A5:     n in NAT by ORDINAL1:def 13;
        then dom iter(f,n) = dom f by A1,FUNCT_7:76;
        then rng iter(f,n) c= X & a in rng iter(f,n)
        by A1,A3,A4,A5,FUNCT_1:12,FUNCT_7:76;
        hence a in X;
      end;
    end;
    hence thesis by A1,A2,FUNCT_2:def 2;
  end;
end;

begin :: Free universal algebras

theorem Th13:
  for X being non empty set, S being non empty FinSequence of NAT
  ex A being Universal_Algebra st the carrier of A = X & signature A = S
  proof
    let X be non empty set;
    let S be non empty FinSequence of NAT;
A1: dom S = Seg len S & rng S c= NAT by FINSEQ_1:def 3,def 4;
    consider x being Element of X;
    defpred P[set,set] means
    ex i,j being Nat st $1 = i & j = S.i & $2 = (j-tuples_on X)--> x;
A2: for y being set st y in dom S ex z being set st P[y,z]
    proof
      let y be set; assume y in dom S;
      then reconsider i = y as Element of NAT;
      reconsider j = S.i as Element of NAT;
      take z = (j-tuples_on X)--> x, i, j; thus thesis;
    end;
    consider ch being Function such that
A3: dom ch = dom S & for y being set st y in dom S holds P[y,ch.y]
    from CLASSES1:sch 1(A2);
    reconsider ch as FinSequence by A1,A3,FINSEQ_1:def 2;
     rng ch c= PFuncs(X*,X)
    proof
      let y be set; assume y in rng ch;
      then consider xi being set such that
A4:   xi in dom ch & y = ch.xi by FUNCT_1:def 5;
      consider i,j being Nat such that
A5:   xi = i & j = S.i & y = (j-tuples_on X)--> x by A3,A4;
       dom ((j-tuples_on X)--> x) = (j-tuples_on X) &
      rng ((j-tuples_on X)--> x) c= {x} by FUNCOP_1:19;
      hence thesis by A5,PARTFUN1:def 5;
    end;
    then reconsider ch as PFuncFinSequence of X by FINSEQ_1:def 4;
    set A = UAStr(#X,ch#);
A6: A is quasi_total
    proof
      let n be Nat, h be PartFunc of (the carrier of A)*, the carrier of A;
      assume n in dom the charact of A & h = (the charact of A).n;
      then ex i,j being Nat st n = i & j = S.i & h = (j-tuples_on X)--> x by A3
;
      hence thesis;
    end;
A7: A is non-empty
    proof
      thus the charact of A <> {} by A3,RELAT_1:60;
      assume {} in rng the charact of A;
      then consider a being set such that
A8:   a in dom ch & {} = ch.a by FUNCT_1:def 5;
       ex i,j being Nat st a = i & j = S.i & {} = (j-tuples_on X)--> x by A3,A8
;
      hence thesis;
    end;
     A is partial
    proof
      let n be Nat, h be PartFunc of (the carrier of A)*, the carrier of A;
      assume n in dom the charact of A & h = (the charact of A).n;
      then ex i,j being Nat st n = i & j = S.i & h = (j-tuples_on X)--> x by A3
;
      hence thesis;
    end;
    then reconsider A as Universal_Algebra by A6,A7;
    take A;
    thus the carrier of A = X;
A9: len ch = len S by A3,FINSEQ_3:31;
     now let n be Nat such that
A10:   n in dom S;
      let h be homogeneous non empty PartFunc of (the carrier of A)*,
      the carrier of A; assume h = (the charact of A).n;
      then consider i,j being Nat such that
A11:   n = i & j = S.i & h = (j-tuples_on X)--> x by A3,A10;
      consider z being Element of j-tuples_on X;
       dom h = j-tuples_on X & len z = j by A11,FINSEQ_2:109,FUNCOP_1:19;
      hence S.n = arity h by A11,UNIALG_1:def 10;
    end;
    hence signature A = S by A9,UNIALG_1:def 11;
  end;

theorem Th14:
  for S being non empty FinSequence of NAT
  ex A being Universal_Algebra st the carrier of A = NAT & signature A = S &
  for i,j being Nat st i in dom S & j = S.i
  holds (the charact of A).i = (j-tuples_on NAT) --> i
  proof set X = NAT;
    let S be non empty FinSequence of NAT;
A1: dom S = Seg len S & rng S c= NAT by FINSEQ_1:def 3,def 4;
    defpred P[set,set] means
    ex i,j being Element of NAT st $1 = i & j = S.i & $2 = (j-tuples_on X)-->i;
A2: for y being set st y in dom S ex z being set st P[y,z]
    proof
      let y be set; assume y in dom S;
      then reconsider i = y as Element of NAT;
      reconsider j = S.i as Element of NAT;
      take z = (j-tuples_on X)--> i, i, j; thus thesis;
    end;
    consider ch being Function such that
A3: dom ch = dom S & for y being set st y in dom S holds P[y,ch.y]
    from CLASSES1:sch 1(A2);
    reconsider ch as FinSequence by A1,A3,FINSEQ_1:def 2;
     rng ch c= PFuncs(X*,X)
    proof
      let y be set; assume y in rng ch;
      then consider xi being set such that
A4:   xi in dom ch & y = ch.xi by FUNCT_1:def 5;
      consider i,j being Element of NAT such that
A5:   xi = i & j = S.i & y = (j-tuples_on X)--> i by A3,A4;
       dom ((j-tuples_on X)--> i) = (j-tuples_on X) &
      rng ((j-tuples_on X)--> i) c= {i} by FUNCOP_1:19;
      hence thesis by A5,PARTFUN1:def 5;
    end;
    then reconsider ch as PFuncFinSequence of X by FINSEQ_1:def 4;
    set A = UAStr(#X,ch#);
A6: A is quasi_total
    proof
      let n be Nat, h be PartFunc of (the carrier of A)*, the carrier of A;
      assume n in dom the charact of A & h = (the charact of A).n;
      then ex i,j being Element of NAT st
      n = i & j = S.i & h = (j-tuples_on X)--> i by A3;
      hence thesis;
    end;
A7: A is non-empty
    proof
      thus the charact of A <> {} by A3,RELAT_1:60;
      assume {} in rng the charact of A;
      then consider a being set such that
A8:   a in dom ch & {} = ch.a by FUNCT_1:def 5;
       ex i,j being Element of NAT st
      a = i & j = S.i & {} = (j-tuples_on X)--> i by A3,A8;
      hence thesis;
    end;
     A is partial
    proof
      let n be Nat, h be PartFunc of (the carrier of A)*, the carrier of A;
      assume n in dom the charact of A & h = (the charact of A).n;
      then ex i,j being Element of NAT st
      n = i & j = S.i & h = (j-tuples_on X)--> i by A3;
      hence thesis;
    end;
    then reconsider A as Universal_Algebra by A6,A7;
    take A;
    thus the carrier of A = X;
A9: len ch = len S by A3,FINSEQ_3:31;
     now let n be Nat such that
A10:   n in dom S;
      let h be homogeneous non empty PartFunc of (the carrier of A)*,
      the carrier of A; assume h = (the charact of A).n;
      then consider i,j being Element of NAT such that
A11:   n = i & j = S.i & h = (j-tuples_on X)--> i by A3,A10;
      consider z being Element of j-tuples_on X;
       dom h = j-tuples_on X & len z = j by A11,FINSEQ_2:109,FUNCOP_1:19;
      hence S.n = arity h by A11,UNIALG_1:def 10;
    end;
    hence signature A = S by A9,UNIALG_1:def 11;
    consider A being Universal_Algebra;
    let i,j be Nat;
    assume i in dom S;
    then ex i1,j being Element of NAT st
    i = i1 & j = S.i1 & ch.i = (j-tuples_on X)--> i1 by A3;
    hence thesis;
  end;

theorem
   for S being non empty FinSequence of NAT
  for i,j being Nat st i in dom S & j = S.i
  for X being non empty set, f being Function of j-tuples_on X, X
  ex A being Universal_Algebra st the carrier of A = X & signature A = S &
  (the charact of A).i = f
  proof
    let S be non empty FinSequence of NAT;
    let i,j be Nat;
    reconsider i' = i, j' = j as Element of NAT by ORDINAL1:def 13;
    assume
A1: i in dom S & j = S.i;
    let X be non empty set;
    consider A0 being Universal_Algebra such that
A2: the carrier of A0 = X & signature A0 = S by Th13;
    let f be Function of j-tuples_on X, X;
     j'-tuples_on X c= X* by CATALG_1:6;
    then reconsider f0 = f as PartFunc of X*,X by RELSET_1:15;
    consider z being Element of j-tuples_on X;
A3: dom f0 = j-tuples_on X by FUNCT_2:def 1;
     f0 is homogeneous
    proof
      let x,y be FinSequence;
      assume x in dom f0 & y in dom f0;
      then len x = j & len y = j by A3,FINSEQ_2:109;
      hence len x = len y;
    end;
    then reconsider f0 as homogeneous non empty PartFunc of X*,X;
A4: len z = j by FINSEQ_2:109;
then A5: arity f0 = j by A3,UNIALG_1:def 10;
    set ch = (the charact of A0)+*(i,f0);
     f0 in PFuncs(X*, X) by PARTFUN1:119;
    then {f0} c= PFuncs(X*,X) & rng the charact of A0 c= PFuncs(X*,X)
    by A2,ZFMISC_1:37;
    then rng ch c= (rng the charact of A0) \/ {f0} &
    (rng the charact of A0) \/ {f0} c= PFuncs(X*, X)
    by POLYNOM1:6,XBOOLE_1:8;
    then rng ch c= PFuncs(X*, X) by XBOOLE_1:1;
    then reconsider ch as FinSequence of PFuncs(X*,X) by FINSEQ_1:def 4;
A6: dom ch = dom the charact of A0 by FUNCT_7:32;
    set A = UAStr(#X,ch#);
A7: A is quasi_total
    proof
      let n be Nat, h be PartFunc of (the carrier of A)*, the carrier of A;
      assume
A8:   n in dom the charact of A & h = (the charact of A).n;
      then (n = i implies h = f0) & (n <> i implies h = (the charact of A0).n)
&
      the charact of A0 is quasi_total by A6,FUNCT_7:33,34;
      hence thesis by A2,A3,A5,A6,A8,COMPUT_1:25,UNIALG_1:def 5;
    end;
A9: A is non-empty
    proof
      thus the charact of A <> {} by A6,RELAT_1:60;
      assume {} in rng the charact of A;
      then consider a being set such that
A10:   a in dom ch & {} = ch.a by FUNCT_1:def 5;
      reconsider a as Element of NAT by A10;
       (a = i implies {} = f0) & (a <> i implies {} = (the charact of A0).a) &
      {} nin rng the charact of A0 by A6,A10,FUNCT_7:33,34,RELAT_1:def 9;
      hence thesis by A6,A10,FUNCT_1:def 5;
    end;
     A is partial
    proof
      let n be Nat, h be PartFunc of (the carrier of A)*, the carrier of A;
      assume n in dom the charact of A & h = (the charact of A).n;
      then (n = i implies h = f0) & (n <> i implies h = (the charact of A0).n)
&
      the charact of A0 is homogeneous by A6,FUNCT_7:33,34;
      hence thesis;
    end;
    then reconsider A as Universal_Algebra by A7,A9;
    take A;
    thus the carrier of A = X;
A11: len S = len the charact of A0 by A2,UNIALG_1:def 11;
then A12: dom S = dom the charact of A0 by FINSEQ_3:31;
A13: len S = len the charact of A by A6,A11,FINSEQ_3:31;
     now let n be Nat;
      assume
A14:   n in dom S;
      let h be homogeneous non empty PartFunc of (the carrier of A )*,
      the carrier of A;
      assume h = (the charact of A).n;
      then (n = i implies h = f0) & (n <> i implies h = (the charact of A0).n)
      by A12,A14,FUNCT_7:33,34;
      hence S.n = arity h by A1,A2,A3,A4,A14,UNIALG_1:def 10,def 11;
    end;
    hence signature A = S by A13,UNIALG_1:def 11;
    thus (the charact of A).i = f by A1,A12,FUNCT_7:33;
  end;

registration
  let f be non empty FinSequence of NAT;
  let D be non empty disjoint_with_NAT set;
  cluster -> Relation-like Function-like Element of FreeUnivAlgNSG(f,D);
  coherence
  proof
    let x be Element of FreeUnivAlgNSG(f,D);
     x is Element of TS(DTConUA(f,D));
    hence thesis;
  end;
end;

registration
  let f be non empty FinSequence of NAT;
  let D be non empty disjoint_with_NAT set;
  cluster -> DecoratedTree-like Element of FreeUnivAlgNSG(f,D);
  coherence
  proof
    let x be Element of FreeUnivAlgNSG(f,D);
     x is Element of TS(DTConUA(f,D));
    hence thesis;
  end;
  cluster -> DTree-yielding FinSequence of FreeUnivAlgNSG(f,D);
  coherence
  proof
    let p be FinSequence of FreeUnivAlgNSG(f,D);
     p is Element of (TS(DTConUA(f,D)))* by FINSEQ_1:def 11;
    hence thesis;
  end;
end;

theorem Th16:
  for G being non empty DTConstrStr
  for t being set st t in TS G
  holds
   (ex d being Symbol of G st d in Terminals G & t = root-tree d) or
   (ex o being Symbol of G, p being FinSequence of TS G
    st o ==> roots p & t = o-tree p)
  proof
    let G be non empty DTConstrStr;
    let t be set;
    assume that
A1: t in TS G and
A2: not ex d being Symbol of G st d in Terminals G & t = root-tree d and
A3: not ex o being Symbol of G, p being FinSequence of TS G
    st o ==> roots p & t = o-tree p;
A4: (TS G) \ {t} c= TS G by XBOOLE_1:36;
    reconsider Y = (TS G) \ {t} as Subset of FinTrees the carrier of G;
A5: now let d be Symbol of G;
      assume d in Terminals G;
      then root-tree d in TS G & root-tree d <> t by A2,DTCONSTR:def 4;
      hence root-tree d in Y by ZFMISC_1:64;
    end;
     now let o be Symbol of G, p be FinSequence of Y;
       rng p c= Y by FINSEQ_1:def 4;
      then rng p c= TS G by A4,XBOOLE_1:1;
      then reconsider q = p as FinSequence of TS G by FINSEQ_1:def 4;
      assume o ==> roots p;
      then o-tree q in TS G & t <> o-tree q by A3,DTCONSTR:def 4;
      hence o-tree p in Y by ZFMISC_1:64;
    end;
    then TS G c= Y by A5,DTCONSTR:def 4;
    then t nin {t} by A1,XBOOLE_0:def 4;
    hence contradiction by TARSKI:def 1;
  end;

theorem Th17:
  for X being disjoint_with_NAT non empty set
  for S being non empty FinSequence of NAT
  for i being Nat st i in dom S
  for p being FinSequence of FreeUnivAlgNSG(S,X) st len p = S.i holds
  Den(In(i, dom the charact of FreeUnivAlgNSG(S,X)),FreeUnivAlgNSG(S,X)).p
  = i-tree p
  proof
    let X be disjoint_with_NAT non empty set;
    let S be non empty FinSequence of NAT;
    reconsider S' = S as non empty FinSequence of omega;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let i be Nat;
    assume
A1: i in dom S;
then A2: S'/.i = S.i by PARTFUN1:def 8;
    let p be FinSequence of A;
    assume len p = S.i;
    then p is Element of (S'/.i)-tuples_on TS G by A2,FINSEQ_2:110;
    then p in (S'/.i)-tuples_on TS G;
then A3: p in dom FreeOpNSG(i,S,X) by A1,FREEALG:def 11;
     len the charact of A = len S by FREEALG:def 12;
    then dom the charact of A = dom S by FINSEQ_3:31;
    then In(i, dom the charact of A) = i by A1,FUNCT_7:def 1;
    hence Den(In(i, dom the charact of A), A).p
        = FreeOpNSG(i,S,X).p by A1,FREEALG:def 12
       .= Sym(i,S,X)-tree p by A1,A3,FREEALG:def 11
       .= i-tree p by A1,FREEALG:def 10;
  end;

definition
  let A be non-empty UAStr;
  let B be Subset of A;
  let n be Nat;
  func B|^n -> Subset of A means:
Def8:
  ex F being Function of NAT, bool the carrier of A st it = F.n & F.0 = B &
  for n being Nat holds F.(n+1) = F.n \/
  {Den(o,A).p where o is (Element of dom the charact of A),
  p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= F.n};
  existence
  proof
    defpred P[set,set,set] means
    $3 = $2 \/ {Den(o,A).p where o is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= $2};
A1: for n being Element of NAT
    for B1 being Subset of A ex B2 being Subset of A st P[n,B1,B2]
    proof
      let n be Element of NAT, B1 be Subset of A;
      set B2 = B1 \/ {Den(o,A).p where o is (Element of dom the charact of A),
      p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B1};
       B2 c= the carrier of A
      proof
        let x be set; assume
A2:     x in B2 & not x in the carrier of A;
         x in B1 implies x in the carrier of A;
        then x in {Den(o,A).p where o is (Element of dom the charact of A),
        p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B1}
        by A2,XBOOLE_0:def 2;
        then consider o being (Element of dom the charact of A), p being
        Element of (the carrier of A)* such that
A3:     x = Den(o,A).p & p in dom Den(o,A) & rng p c= B1;
         x in rng Den(o,A) by A3,FUNCT_1:def 5;
        hence contradiction by A2;
      end;
      then reconsider B2 as Subset of A;
      take B2;
      thus P[n,B1,B2];
    end;
    consider F being Function of NAT, bool the carrier of A such that
A4: F.0 = B & for n being Element of NAT holds P[n,F.n,F.(n+1)]
    from RECDEF_1:sch 2(A1);
    reconsider n' = n as Element of NAT by ORDINAL1:def 13;
    take a = F.n', F; thus a = F.n & F.0 = B by A4;
    let n be Nat;  n in NAT by ORDINAL1:def 13;
    hence thesis by A4;
  end;
  uniqueness
  proof
    let C1,C2 be Subset of A;
    deffunc Rec(set,set) = $2 \/
    {Den(o,A).p where o is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= $2};
    given F1 being Function of NAT, bool the carrier of A such that
A5: C1 = F1.n and
A6: F1.0 = B & for n being Nat holds F1.(n+1) = Rec(n,F1.n);
    given F2 being Function of NAT, bool the carrier of A such that
A7: C2 = F2.n and
A8: F2.0 = B & for n being Nat holds F2.(n+1) = Rec(n,F2.n);
A9: dom F1 = NAT & F1.0 = B & for n being Element of NAT
    holds F1.(n+1) = Rec(n,F1.n) by A6,FUNCT_2:def 1;
A10: dom F2 = NAT & F2.0 = B & for n being Element of NAT
    holds F2.(n+1) = Rec(n,F2.n) by A8,FUNCT_2:def 1;
     F1 = F2 from RECDEF_1:sch 11(A9,A10);
    hence thesis by A5,A7;
  end;
end;

theorem Th18:
  for A being Universal_Algebra, B being Subset of A
  holds B|^0 = B
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
     ex F being Function of NAT, bool the carrier of A st B|^0 = F.0 & F.0 = B
&
    for n being Nat holds F.(n+1) = F.n \/ {Den(o,A).p where o is (Element of
    dom the charact of A), p is Element of (the carrier of A)*: p in dom
    Den(o,A) & rng p c= F.n} by Def8;
    hence B|^0 = B;
  end;

theorem Th19:
  for A being Universal_Algebra, B being Subset of A
  for n being Nat
  holds B|^(n+1) = (B|^n) \/ {Den(o,A).p
  where o is (Element of dom the charact of A),
  p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B|^n}
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    let n be Nat;
    deffunc Rec(set,set) = $2 \/
    {Den(o,A).p where o is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= $2};
    consider F1 being Function of NAT, bool the carrier of A such that
A1: B|^(n) = F1.(n) and
A2: F1.0 = B & for n being Nat holds F1.(n+1) = Rec(n,F1.n) by Def8;
    consider F2 being Function of NAT, bool the carrier of A such that
A3: B|^(n+1) = F2.(n+1) and
A4: F2.0 = B & for n being Nat holds F2.(n+1) = Rec(n,F2.n) by Def8;
A5: dom F1 = NAT & F1.0 = B & for n being Element of NAT
    holds F1.(n+1) = Rec(n,F1.n) by A2,FUNCT_2:def 1;
A6: dom F2 = NAT & F2.0 = B & for n being Element of NAT
    holds F2.(n+1) = Rec(n,F2.n) by A4,FUNCT_2:def 1;
     F1 = F2 from RECDEF_1:sch 11(A5,A6);
    hence thesis by A1,A2,A3;
  end;

theorem Th20:
  for A being Universal_Algebra, B being Subset of A
  for n being Nat
  for x being set
  holds x in B|^(n+1) iff x in B|^n or
  ex o being Element of dom the charact of A st
  ex p being Element of (the carrier of A)*
  st x = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^n
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    let n be Nat;
    set Z = {Den(o,A).p where o is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B|^n};
    let x be set;
     B|^(n+1) = (B|^n) \/ Z by Th19;
    then x in B|^(n+1) iff  x in B|^n or x in Z by XBOOLE_0:def 2;
    hence thesis;
  end;

theorem Th21:
  for A being Universal_Algebra, B being Subset of A
  for n,m being Nat st n <= m
  holds B|^n c= B|^m
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    let n,m be Nat;
    assume n <= m;
    then consider i being Nat such that
A1: m = n+i by NAT_1:10;
    defpred P[Nat] means B|^n c= B|^(n+$1);
A2: P[0];
A3: now
      let i be Nat; assume
A4:   P[i];
      deffunc Rec(set,set) = $2 \/
      {Den(o,A).p where o is (Element of dom the charact of A),
      p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= $2};
       B|^(n+i+1) = Rec(n,B|^(n+i)) by Th19;
      then B|^(n+i) c= B|^(n+(i+1)) by XBOOLE_1:7;
      hence P[i+1] by A4,XBOOLE_1:1;
    end;
     for i being Nat holds P[i] from NAT_1:sch 2(A2,A3);
    hence B|^n c= B|^m by A1;
  end;

theorem Th22:
  for A being Universal_Algebra
  for B1,B2 being Subset of A st B1 c= B2
  for n being Nat holds B1|^n c= B2|^n
  proof
    let A be Universal_Algebra;
    let B1,B2 be Subset of A such that
A1: B1 c= B2;
    defpred P[Nat] means B1|^$1 c= B2|^$1;
     B1|^0 = B1 by Th18;
then A2: P[0] by A1,Th18;
A3: now let n be Nat;
      assume
A4:   P[n];
      thus P[n+1]
      proof
        let x be set; assume
A5:     x in B1|^(n+1) & x nin B2|^(n+1);
        then reconsider a = x as Element of A;
         a nin B1|^n by A4,A5,Th20;
        then consider o being (Element of dom the charact of A),
        p being Element of (the carrier of A)* such that
A6:     a = Den(o,A).p & p in dom Den(o,A) & rng p c= B1|^n by A5,Th20;
         rng p c= B2|^n by A4,A6,XBOOLE_1:1;
        hence contradiction by A5,A6,Th20;
      end;
    end;
     for n being Nat holds P[n] from NAT_1:sch 2(A2,A3);
    hence thesis;
  end;

theorem Th23:
  for A being Universal_Algebra, B being Subset of A
  for n being Nat
  for x being set
  holds x in B|^(n+1) iff x in B or
  ex o being Element of dom the charact of A st
  ex p being Element of (the carrier of A)*
  st x = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^n
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    defpred P[Nat] means for x being set st x in B|^($1+1) holds x in B or
    ex o being Element of dom the charact of A st
    ex p being Element of (the carrier of A)*
    st x = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^$1;
A1: B|^0 = B by Th18;
then A2: P[0] by Th20;
A3: now let n be Nat such that
A4:   P[n];
      thus P[n+1]
      proof
        let x be set;
        assume x in B|^(n+1+1);
then A5:     x in B|^(n+1) or ex o being Element of dom the charact of A st
        ex p being Element of (the carrier of A)*
        st x = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^(n+1)
        by Th20;
         now given o being (Element of dom the charact of A),
          p being Element of (the carrier of A)* such that
A6:       x = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^n;
          take o,p;  n <= n+1 by NAT_1:13;
          then B|^n c= B|^(n+1) by Th21;
          hence x = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^(n+1)
          by A6,XBOOLE_1:1;
        end;
        hence thesis by A4,A5;
      end;
    end;
A7: for n being Nat holds P[n] from NAT_1:sch 2(A2,A3);
    let n be Nat;
    let x be set;
     B c= B|^n by A1,Th21;
    hence thesis by A7,Th20;
  end;

scheme MaxVal{A() -> non empty set, B() -> set, P[set,set]}:
  ex n being Nat st
  for x being Element of A() st x in B() holds P[x,n]
  provided
A1: B() is finite
  and
A2: for x being Element of A() st x in B() ex n being Nat st P[x,n]
  and
A3: for x being Element of A()
  for n,m being Nat st P[x,n] & n <= m holds P[x,m]
  proof
A4: for x being set st x in A()/\B() ex y being set st y in NAT & P[x,y]
    proof
      let x be set;
      assume
A5:   x in A()/\B();
      then reconsider x as Element of A() by XBOOLE_0:def 3;
       x in B() by A5,XBOOLE_0:def 3;
      then consider n being Nat such that
A6:   P[x,n] by A2;
       n is Element of NAT by ORDINAL1:def 13;
      hence thesis by A6;
    end;
    consider f being Function such that
A7: dom f = A()/\B() & rng f c= NAT and
A8: for x being set st x in A()/\B() holds P[x,f.x] from WELLORD2:sch 1(A4);
     dom f is finite by A1,A7,FINSET_1:15;
    then reconsider Z = rng f as finite Subset of NAT by A7,FINSET_1:26;
    consider n being Element of NAT such that
A9: for i being Element of NAT st i in Z holds i <= n by STIRL2_1:66;
    take n; let x be Element of A();
    assume x in B();
then A10: x in A()/\B() by XBOOLE_0:def 3;
then A11: f.x in rng f by A7,FUNCT_1:def 5;
    then reconsider i = f.x as Element of NAT by A7;
     i <= n & P[x,i] by A8,A9,A10,A11;
    hence thesis by A3;
  end;

theorem Th24:
  for A being Universal_Algebra, B being Subset of A
  ex C being Subset of A
  st C = union {B|^n where n is Element of NAT: not contradiction} &
  C is opers_closed
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    set X = {B|^n where n is Element of NAT: not contradiction};
    set C = union X;
A1: union bool the carrier of A = the carrier of A by ZFMISC_1:99;
     X c= bool the carrier of A
    proof
      let x be set; assume x in X;
      then ex n being Element of NAT st x = B|^n;
      hence thesis;
    end;
    then reconsider C as Subset of A by A1,ZFMISC_1:95;
    take C; thus C = union {B|^n where n is Element of NAT: not contradiction}
;
    let o be Element of Operations A;
    consider s being set such that
A2: s in dom the charact of A & o = (the charact of A).s by FUNCT_1:def 5;
    reconsider s as OperSymbol of A by A2;
A3: dom o = (arity o)-tuples_on the carrier of A by UNIALG_2:2;
    let p be FinSequence of C;
    assume len p = arity o;
    then p is Element of dom Den(s,A) by A2,A3,FINSEQ_2:110;
then A4: p in dom Den(s,A) by A2,A3;
    defpred P[set,Nat] means $1 in B|^$2;
A5: rng p is finite;
A6: for x being Element of A st x in rng p ex n being Nat st P[x,n]
    proof
      let x be Element of A;
      assume
A7:   x in rng p;
       rng p c= C by FINSEQ_1:def 4;
      then consider Y being set such that
A8:   x in Y & Y in X by A7,TARSKI:def 4;
      consider n being Element of NAT such that
A9:   Y = B|^n by A8;
      take n;
      thus P[x,n] by A8,A9;
    end;
A10: for x being Element of A
    for n,m being Nat st P[x,n] & n <= m holds P[x,m]
    proof
      let x be Element of A;
      let n,m be Nat;
      assume
A11:   P[x,n];
      assume n <= m;
      then B|^n c= B|^m by Th21;
      hence thesis by A11;
    end;
    consider n being Nat such that
A12: for x being Element of A st x in rng p holds P[x,n] from MaxVal(A5,A6,A10)
;
     rng p c= B|^n
    proof
      let x be set; assume
   x in rng p;
      hence thesis by A12;
    end;
    then Den(s,A).p in {Den(a,A).r where a is (Element of dom the charact of A
),
    r is Element of (the carrier of A)*: r in dom Den(a,A) & rng r c= B|^n}
    by A4;
    then o.p in (B|^n)\/{Den(a,A).r where a is (Element of dom the charact of
A),
    r is Element of (the carrier of A)*: r in dom Den(a,A) & rng r c= B|^n} &
    n+1 in NAT by A2,ORDINAL1:def 13,XBOOLE_0:def 2;
    then o.p in B|^(n+1) & B|^(n+1) in X by Th19;
    hence o.p in C by TARSKI:def 4;
  end;

theorem Th25:
  for A being Universal_Algebra, B,C being Subset of A
  st C is opers_closed & B c= C
  holds union {B|^n where n is Element of NAT: not contradiction} c= C
  proof
    let A be Universal_Algebra;
    let B,C be Subset of A;
    assume
A1: C is opers_closed;
    assume
A2: B c= C;
    let z be set; assume
     z in union {B|^n where n is Element of NAT: not contradiction};
    then consider Y being set such that
A3: z in Y & Y in {B|^n where n is Element of NAT: not contradiction}
    by TARSKI:def 4;
    consider n being Element of NAT such that
A4: Y = B|^n by A3;
    defpred P[Nat] means B|^$1 c= C;
A5: P[0] by A2,Th18;
A6: now let n be Nat;
      assume
A7:   P[n];
      thus P[n+1]
      proof let x be set;
        assume
A8:     x in B|^(n+1) & x nin C;
        then x in (B|^n)\/{Den(o,A).p where o is (Element of dom the charact
of A),
        p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B|^n}
        by Th19;
        then x in B|^n or
        x in {Den(o,A).p where o is (Element of dom the charact of A),
        p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B|^n}
        by XBOOLE_0:def 2;
        then consider o being (Element of dom the charact of A), p being
Element
        of (the carrier of A)* such that
A9:     x = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^n by A7,A8;
         rng p c= C by A7,A9,XBOOLE_1:1;
        then reconsider p as FinSequence of C by FINSEQ_1:def 4;
        reconsider oo = Den(o,A) as Element of Operations A;
         len p = arity oo & C is_closed_on oo
        by A1,A9,UNIALG_1:def 10,UNIALG_2:def 5;
        hence thesis by A8,A9,UNIALG_2:def 4;
      end;
    end;
     for n being Nat holds P[n] from NAT_1:sch 2(A5,A6);
    then P[n];
    hence thesis by A3,A4;
  end;

definition
  let A be Universal_Algebra;
  func Generators A -> Subset of A equals  (the carrier of A) \
  union {rng o where o is Element of Operations A: not contradiction};
  coherence;
end;

theorem Th26:
  for A being Universal_Algebra, a being Element of A holds
  a in Generators A iff not ex o being Element of Operations A st a in rng o
  proof
    let A be Universal_Algebra;
    set Z = {rng o where o is Element of Operations A: not contradiction};
    let a be Element of A;
    hereby
      assume a in Generators A;
then A1:   a nin union Z by XBOOLE_0:def 4;
      given o being Element of Operations A such that
A2:   a in rng o;
       rng o in Z;
      hence contradiction by A1,A2,TARSKI:def 4;
    end;
    assume
A3: not ex o being Element of Operations A st a in rng o;
    assume a nin Generators A;
    then a in union Z by XBOOLE_0:def 4;
    then consider X being set such that
A4: a in X & X in Z by TARSKI:def 4;
     ex o being Element of Operations A st X = rng o by A4;
    hence contradiction by A3,A4;
  end;

theorem
   for A being Universal_Algebra
  for B being Subset of A st B is opers_closed
  holds Constants A c= B
  proof
    let A be Universal_Algebra;
    let B be Subset of A such that
A1: B is opers_closed;
    let x be set; assume x in Constants A;
    then consider a being Element of A such that
A2: x = a & ex o being Element of Operations A st arity o = 0 & a in rng o;
    consider o being Element of Operations A such that
A3: arity o = 0 & a in rng o by A2;
    consider s being set such that
A4: s in dom o & a = o.s by A3,FUNCT_1:def 5;
    consider z being set such that
A5: z in dom the charact of A & o = (the charact of A).z by FUNCT_1:def 5;
    reconsider z as Element of dom the charact of A by A5;
A6: dom o = 0-tuples_on the carrier of A by A3,UNIALG_2:2;
    reconsider s as Element of (the carrier of A)* by A4;
A7: len s = 0 by A4,A6,FINSEQ_2:109;
    then s = {} by FINSEQ_1:25;
    then rng s c= B by RELAT_1:60,XBOOLE_1:2;
    then s is FinSequence of B & B is_closed_on o
    by A1,FINSEQ_1:def 4,UNIALG_2:def 5;
    hence x in B by A2,A3,A4,A7,UNIALG_2:def 4;
  end;

theorem Th28:
  for A being Universal_Algebra st Constants A = {}
  holds {} A is opers_closed
  proof
    let A be Universal_Algebra such that
A1: Constants A = {};
    let o be Element of Operations A;
    let s be FinSequence of {} A;
    assume
A2: len s = arity o;
A3: {} A c= the carrier of A & rng s c= {} A by FINSEQ_1:def 4;
     s is Element of (arity o)-tuples_on the carrier of A &
    dom o = (arity o)-tuples_on the carrier of A
    by A2,FINSEQ_2:110,UNIALG_2:2;
then A4: o.s in rng o by FUNCT_1:def 5;
    then reconsider a = o.s as Element of A;
     a nin Constants A by A1;
    then arity o <> 0 by A4;
    then s <> {} by A2,FINSEQ_1:25;
    then rng s <> {} by RELAT_1:64;
    hence thesis by A3,XBOOLE_1:3;
  end;

theorem
   for A being Universal_Algebra st Constants A = {}
  for G being GeneratorSet of A
  holds G <> {}
  proof
    let A be Universal_Algebra such that
A1: Constants A = {};
    let G be GeneratorSet of A;
    assume
A2: G = {};
    then G = {} A;
    then G is opers_closed & G c= G & the carrier of A <> {} by A1,Th28;
    hence thesis by A2,FREEALG:def 5;
  end;

theorem Th30:
  for A being Universal_Algebra
  for G being Subset of A
  holds G is GeneratorSet of A iff
  for I being Element of A ex n being Nat st I in G|^n
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    set X = {B|^n where n is Element of NAT: not contradiction};
    consider C being Subset of A such that
A1: C = union X & C is opers_closed by Th24;
     B|^0 = B by Th18;
    then B in X;
then A2: B c= C by A1,ZFMISC_1:92;
    consider o being Element of Operations A;
    thus B is GeneratorSet of A implies for I being Element of A
    ex n being Nat st I in B|^n
    proof
      assume
       for D being Subset of A st D is opers_closed & B c= D
      holds D = the carrier of A;
then A3:   C = the carrier of A by A1,A2;
      let I be Element of A;
      consider Y being set such that
A4:   I in Y & Y in X by A1,A3,TARSKI:def 4;
       ex n being Element of NAT st Y = B|^n by A4;
      hence thesis by A4;
    end;
    assume
A5: for I being Element of A ex n being Nat st I in B|^n;
    let D be Subset of A; assume
     D is opers_closed & B c= D;
then A6: union X c= D by Th25;
    thus D c= the carrier of A;
    let x be set; assume x in the carrier of A;
    then reconsider I = x as Element of A;
    consider n being Nat such that
A7: I in B|^n by A5;
    reconsider n as Element of NAT by ORDINAL1:def 13;
     B|^n in X;
    then I in union X by A7,TARSKI:def 4;
    hence thesis by A6;
  end;

theorem Th31:
  for A being Universal_Algebra
  for B being Subset of A
  for G being GeneratorSet of A st G c= B
  holds B is GeneratorSet of A
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    let G be GeneratorSet of A such that
A1: G c= B;
     now let a be Element of A;
      consider n being Nat such that
A2:   a in G|^n by Th30;
      take n;
       G|^n c= B|^n by A1,Th22;
      hence a in B|^n by A2;
    end;
    hence thesis by Th30;
  end;

theorem Th32:
  for A being Universal_Algebra
  for G being GeneratorSet of A
  for a being Element of A
  st not ex o being Element of Operations A st a in rng o
  holds a in G
  proof
    let A be Universal_Algebra;
    let G be GeneratorSet of A;
    let a be Element of A;
    assume
A1: for o being Element of Operations A holds a nin rng o;
    defpred P[Nat] means a nin G|^$1;
    assume a nin G;
then A2: P[0] by Th18;
A3: now let n be Nat;
      assume
A4:   P[n];
      thus P[n+1]
      proof
        assume a in G|^(n+1);
        then a in (G|^n) \/ {Den(o,A).p
        where o is (Element of dom the charact of A),
        p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= G|^n}
        by Th19;
        then a in {Den(o,A).p where o is (Element of dom the charact of A),
        p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= G|^n}
        by A4,XBOOLE_0:def 2;
        then consider o being (Element of dom the charact of A), p being
Element of
        (the carrier of A)* such that
A5:     a = Den(o,A).p & p in dom Den(o,A) & rng p c= G|^n;
         Den(o,A) in Operations A & a in rng Den(o,A) by A5,FUNCT_1:def 5;
        hence contradiction by A1;
      end;
    end;
     for n being Nat holds P[n] from NAT_1:sch 2(A2,A3);
    hence contradiction by Th30;
  end;

theorem
   for A being Universal_Algebra, G being GeneratorSet of A
  holds Generators A c= G
  proof
    let A be Universal_Algebra;
    let G be GeneratorSet of A;
    let a be set; assume
A1:   a in Generators A;
then A2: a nin union {rng o where o is Element of
    Operations A: not contradiction} by XBOOLE_0:def 4;
    reconsider I = a as Element of A by A1;
    assume a nin G;
    then consider o0 being Element of Operations A such that
A3: I in rng o0 by Th32;
     rng o0 in {rng o where o is Element of Operations A: not contradiction};
    hence contradiction by A2,A3,TARSKI:def 4;
  end;

theorem Th34:
  for A being free Universal_Algebra
  for G being free GeneratorSet of A
  holds G = Generators A
  proof
    let A be free Universal_Algebra;
    let G be free GeneratorSet of A;
    reconsider S = signature A as non empty FinSequence of NAT by MSUALG_1:9;
    consider B being Universal_Algebra such that
A1: the carrier of B = NAT & signature B = S and
A2: for i,j being Nat st i in dom S & j = S.i
    holds (the charact of B).i = (j-tuples_on NAT) --> i by Th14;
    reconsider f = G --> 0 as Function of G, the carrier of B by A1;
     A,B are_similar by A1,UNIALG_2:def 2;
    then consider h being Function of A,B such that
A3: h is_homomorphism A,B & h|G = f by FREEALG:def 6;
     len S = len the charact of B & len S = len the charact of A
    by A1,UNIALG_1:def 11;
then A4: dom S = dom the charact of B & dom S = dom the charact of A by
FINSEQ_3:31;
    thus G c= Generators A
    proof
      let a be set; assume
A5:   a in G; then reconsider I = a as Element of A;
      assume not thesis;
      then I in union {rng o where o is Element of Operations A: not
contradiction}
      by XBOOLE_0:def 4;
      then consider Y being set such that
A6:   I in Y & Y in{rng o where o is Element of Operations A:not contradiction}
      by TARSKI:def 4;
      consider o being Element of Operations A such that
A7:   Y = rng o by A6;
      consider i being set such that
A8:   i in dom the charact of A & o = (the charact of A).i by FUNCT_1:def 5;
      reconsider i as Element of NAT by A8;
      reconsider j = S.i as Element of NAT;
      reconsider o2 = (the charact of B).i as Element of Operations B
      by A4,A8,FUNCT_1:def 5;
      consider x being set such that
A9:   x in dom o & I = o.x by A6,A7,FUNCT_1:def 5;
A10:   dom o = (arity o)-tuples_on the carrier of A by UNIALG_2:2;
      reconsider x as FinSequence of A by A9,FINSEQ_1:def 11;
      reconsider hx = h*x as FinSequence of NAT by A1;
       len (h*x) = len x by FINSEQ_2:37 .= arity o by A9,A10,FINSEQ_2:109
      .= j by A4,A8,UNIALG_1:def 11;
then A11:   hx is Element of j-tuples_on NAT by FINSEQ_2:110;
       0 = f.I by A5,FUNCOP_1:13
      .= h.(o.x) by A3,A5,A9,FUNCT_1:72
      .= o2.(h*x) by A3,A8,A9,ALG_1:def 1
      .= ((j-tuples_on NAT) --> i).(h*x) by A2,A4,A8
      .= i by A11,FUNCOP_1:13;
      hence contradiction by A8,FINSEQ_3:27;
    end;
    let a be set; assume A12: a in Generators A;
then A13: a in the carrier of A & a nin union {rng o where o is Element of
      Operations A: not contradiction} by XBOOLE_0:def 4;
    reconsider I = a as Element of A by A12;
    assume a nin G;
    then consider o0 being Element of Operations A such that
A14: I in rng o0 by Th32;
     rng o0 in {rng o where o is Element of Operations A: not contradiction};
    hence contradiction by A13,A14,TARSKI:def 4;
  end;

registration
  let A be free Universal_Algebra;
  cluster Generators A -> free GeneratorSet of A;
  coherence
  proof
    consider G being free GeneratorSet of A;
     Generators A = G by Th34;
    hence thesis;
  end;
end;

definition
  let A be free Universal_Algebra;
  redefine func Generators A -> GeneratorSet of A;
  coherence
  proof
    consider G being free GeneratorSet of A;
     Generators A = G by Th34;
    hence thesis;
  end;
end;

registration
  let A,B be set;
  cluster [:A,B:] -> disjoint_with_NAT;
  coherence
  proof
     now
      let z be set;
      assume z in [:A,B:] & z in NAT;
      then z is Element of NAT &
      ex a,b being set st a in A & b in B & z = [a,b] by ZFMISC_1:def 2;
      hence contradiction;
    end;
    hence [:A,B:] misses NAT by XBOOLE_0:3;
  end;
end;

theorem
   for A being free Universal_Algebra
  for G being GeneratorSet of A
  for B being Universal_Algebra
  for h1,h2 being Function of A,B
  st h1 is_homomorphism A,B & h2 is_homomorphism A,B & h1|G = h2|G
  holds h1 = h2
  proof
    let A be free Universal_Algebra;
    let G be GeneratorSet of A;
    let B be Universal_Algebra;
    let h1,h2 be Function of A,B such that
A1: h1 is_homomorphism A,B & h2 is_homomorphism A,B & h1|G = h2|G;
    defpred P[Nat] means
    for a being Element of A st a in G|^$1 holds h1.a = h2.a;
A2: P[0]
    proof let a be Element of A;
      assume a in G|^0; then a in G by Th18;
      then h1.a = (h1|G).a & h2.a = (h2|G).a by FUNCT_1:72;
      hence thesis by A1;
    end;
A3: for n being Nat st P[n] holds P[n+1]
    proof
      let n be Nat such that
A4:   P[n];
      let a be Element of A; assume
A5:   a in G|^(n+1) & h1.a <> h2.a;
      then a nin G|^n by A4;
      then consider o being (Element of dom the charact of A),
      p being Element of (the carrier of A)* such that
A6:   a = Den(o,A).p & p in dom Den(o,A) & rng p c= G|^n by A5,Th20;
       A,B are_similar by A1,ALG_1:def 1;
      then len the charact of A = len the charact of B by UNIALG_2:3;
      then reconsider o' = o as Element of dom the charact of B by FINSEQ_3:31;
       Operations A = rng the charact of A &
      Operations B = rng the charact of B;
then A7:   h1.a = Den(o',B).(h1*p) & h2.a = Den(o',B).(h2*p) by A1,A6,
ALG_1:def 1;
       now
         dom h1 = the carrier of A & dom h2 = the carrier of A by FUNCT_2:def 1
;
        hence G|^n c= dom h1 & G|^n c= dom h2;
        let x be set; assume x in G|^n;
        hence h1.x = h2.x by A4;
      end;
      hence thesis by A5,A6,A7,Th1;
    end;
A8: for n being Nat holds P[n] from NAT_1:sch 2(A2,A3);
     now let a be Element of A;
       ex n being Nat st a in G|^n by Th30;
      hence h1.a = h2.a by A8;
    end;
    hence h1 = h2 by FUNCT_2:113;
  end;

Lm2:
  for A being free Universal_Algebra
  for o1,o2 being OperSymbol of A
  for p1,p2 being FinSequence st p1 in dom Den(o1,A) & p2 in dom Den(o2,A)
  holds Den(o1,A).p1 = Den(o2,A).p2 implies o1 = o2
  proof
    let A be free Universal_Algebra;
    consider G being free GeneratorSet of A;
    let o1,o2 be OperSymbol of A;
    let p1,p2 be FinSequence such that
A1: p1 in dom Den(o1,A) & p2 in dom Den(o2,A) and
A2: Den(o1,A).p1 = Den(o2,A).p2;
    reconsider S = signature A as non empty FinSequence of NAT by MSUALG_1:9;
    consider B being Universal_Algebra such that
A3: the carrier of B = NAT & signature B = S and
A4: for i,j being Nat st i in dom S & j = S.i
    holds (the charact of B).i = (j-tuples_on NAT) --> i by Th14;
    reconsider f = G --> 0 as Function of G, the carrier of B by A3;
     A,B are_similar by A3,UNIALG_2:def 2;
    then consider h being Function of A,B such that
A5: h is_homomorphism A,B & h|G = f by FREEALG:def 6;
A6: len S = len the charact of B & len S = len the charact of A
    by A3,UNIALG_1:def 11;
then A7: dom S = dom the charact of B & dom S = dom the charact of A
      by FINSEQ_3:31;
    reconsider b1 = o1, b2 = o2 as OperSymbol of B by A6,FINSEQ_3:31;
     o1 in dom the charact of A & o2 in dom the charact of A &
    dom the charact of A = Seg len the charact of A by FINSEQ_1:def 3;
    then reconsider n1 = o1, n2 = o2 as Element of NAT;
    reconsider j1 = S.n1, j2 = S.n2 as Element of NAT;
    reconsider x1 = p1, x2 = p2 as FinSequence of A by A1,FINSEQ_1:def 11;
    reconsider h1 = h*x1, h2 = h*x2 as FinSequence of NAT by A3;
    reconsider oo1 = Den(o1,A), oo2 = Den(o2,A) as Element of Operations A;
A8: dom oo1 = (arity oo1)-tuples_on the carrier of A &
    dom oo2 = (arity oo2)-tuples_on the carrier of A by UNIALG_2:2;
    then len x1 = arity oo1 by A1,FINSEQ_2:109
    .= j1 by A7,UNIALG_1:def 11;
    then len h1 = j1 by FINSEQ_2:37;
then A9: h1 is Element of j1-tuples_on NAT by FINSEQ_2:110;
     len x2 = arity oo2 by A1,A8,FINSEQ_2:109
    .= j2 by A7,UNIALG_1:def 11;
    then len h2 = j2 by FINSEQ_2:37;
then A10: h2 is Element of j2-tuples_on NAT by FINSEQ_2:110;
     Den(o1,A) = (the charact of A).n1 & Den(o1,A) is Element of Operations A &
    Den(b1,B) = (the charact of B).n1 & Den(b1,B) is Element of Operations B &
    Den(o2,A) = (the charact of A).n2 & Den(o2,A) is Element of Operations A &
    Den(b2,B) = (the charact of B).n2 & Den(b2,B) is Element of Operations B;
    then A11: h.(Den(o1,A).x1) = Den(b1,B).h1 & h.(Den(o2,A).x2) = Den(b2,B).h2
    by A1,A5,ALG_1:def 1;
     Den(b1,B) = (j1-tuples_on NAT)-->n1 & Den(b2,B) = (j2-tuples_on NAT)-->n2
    by A4,A7;
    then Den(b1,B).h1 = n1 & Den(b2,B).h2 = n2 by A9,A10,FUNCOP_1:13;
    hence o1 = o2 by A2,A11;
  end;

theorem Th36:
  for A being free Universal_Algebra
  for o1,o2 being OperSymbol of A
  for p1,p2 being FinSequence st p1 in dom Den(o1,A) & p2 in dom Den(o2,A)
  holds Den(o1,A).p1 = Den(o2,A).p2 implies o1 = o2 & p1 = p2
  proof
    let A be free Universal_Algebra;
    consider G being free GeneratorSet of A;
    let o1,o2 be OperSymbol of A;
    let p1,p2 be FinSequence such that
A1: p1 in dom Den(o1,A) & p2 in dom Den(o2,A) and
A2: Den(o1,A).p1 = Den(o2,A).p2;
    thus
A3: o1 = o2 by A1,A2,Lm2;
    reconsider S = signature A as non empty FinSequence of NAT by MSUALG_1:9;
    reconsider oo1 = Den(o1,A), oo2 = Den(o2,A) as Element of Operations A;
    set RNG = {rng o where o is Element of Operations A: not contradiction};
    set G' = G \/ {the carrier of A};
    reconsider G' as non empty set;
    deffunc F(set) = root-tree [0,$1];
    consider g being Function such that
A4: dom g = G & for x being set st x in G holds g.x = F(x) from FUNCT_1:sch 3;
    set X = [:{0},G':];
    set B = FreeUnivAlgNSG(S,X);
A5: signature B = S by FREEALG:4;
A6: Terminals DTConUA(S,[:{0},G':]) = [:{0},G':] by FREEALG:3;
     rng g c= FreeGenSetNSG(S,[:{0},G':])
    proof
      let b be set; assume b in rng g;
      then consider a being set such that
A7:   a in dom g & b = g.a by FUNCT_1:def 5;
      reconsider a as Element of A by A4,A7;
       a in G' & 0 in {0} by A4,A7,TARSKI:def 1,XBOOLE_0:def 2;
then A8:   [0,a] in [:{0},G':] by ZFMISC_1:106;
      then reconsider s = [0,a] as Symbol of DTConUA(S,[:{0},G':]) by A6;
       root-tree s in FreeGenSetNSG(S,[:{0},G':]) by A6,A8;
      hence thesis by A4,A7;
    end;
    then rng g c= the carrier of B by XBOOLE_1:1;
    then reconsider g  as Function of G, the carrier of B by A4,FUNCT_2:4;
     signature B = S by FREEALG:4;
    then A,B are_similar by UNIALG_2:def 2;
    then consider h being Function of A,B such that
A9: h is_homomorphism A,B & h|G = g by FREEALG:def 6;
    defpred G[Nat] means
    for a1,a2 being set st a1 in G|^$1 & a2 in G|^$1 & h.a1 = h.a2
    holds a1 = a2;
A10: G|^0 = G by Th18;
A11: len S = len the charact of B & len S = len the charact of A
    by A5,UNIALG_1:def 11;
then A12: dom S = dom the charact of B & dom S = dom the charact of A
    by FINSEQ_3:31;
A13: now let o be Element of dom the charact of A;
      let p be FinSequence of A such that
A14:   p in dom Den(o,A);
      reconsider q = p as FinSequence of A;
      reconsider hq = h*q as FinSequence of B;
      reconsider op = Den(o,A) as Element of Operations A;
      reconsider on = o as Element of NAT;
      reconsider o' = on as OperSymbol of B by A11,FINSEQ_3:31;
      reconsider op' = Den(o',B) as Element of Operations B;
       S.o' in rng S & rng S c= NAT by A12,FINSEQ_1:def 4,FUNCT_1:12;
      then reconsider j = S.o' as Element of NAT;
       dom op = (arity op)-tuples_on the carrier of A by UNIALG_2:2;
then A15:   len p = arity op by A14,FINSEQ_2:109 .= j by A12,UNIALG_1:def 11;
      hence len p = S.o & len (h*p) = S.o by FINSEQ_2:37;
A16:   h.(op.q) = op'.hq by A9,A14,ALG_1:def 1;
A17:   In(o', dom the charact of B) = o' by FUNCT_7:def 1;
       o' in dom S & len hq = S.o' by A12,A15,FINSEQ_2:37;
      hence h.(Den(o,A).p) = o-tree (h*p) by A16,A17,Th17;
    end;
A18: G[0]
    proof
      let a1,a2 be set; assume
A19:   a1 in G|^0 & a2 in G|^0 & h.a1 = h.a2;
      then h.a1 = g.a1 & h.a2 = g.a2 by A9,A10,FUNCT_1:72;
      then h.a1 = F(a1) & h.a2 = F(a2) by A4,A10,A19;
      then [0,a1] = [0,a2] by A19,TREES_4:4;
      hence a1 = a2 by ZFMISC_1:33;
    end;
A20: now
      let o be Element of dom the charact of A;
      let p be Element of (the carrier of A)*;
      assume p in dom Den(o,A);
then A21:   h.(Den(o,A).p) = o-tree(h*p) by A13;
      let x be set; assume
A22:   x in G;
then A23:   h.x = g.x by A9,FUNCT_1:72 .= F(x) by A4,A22;
      assume h.(Den(o,A).p) = h.x;
      then o = [0,x] & o is Element of NAT by A21,A23,TREES_4:17;
      hence contradiction;
    end;
A24: for k being Nat st G[k] holds G[k+1]
    proof
      let k be Nat such that
A25:   G[k];
      defpred Gk[set] means
      ex o being Element of dom the charact of A st
      ex p being Element of (the carrier of A)*
      st $1 = Den(o,A).p & p in dom Den(o,A) & rng p c= G|^k;
      let a1,a2 be set; assume
A26:   a1 in G|^(k+1) & a2 in G|^(k+1) & h.a1 = h.a2;
      per cases by A26,Th23;
      suppose
A27:     a1 in G & a2 in G;
        then h.a1 = g.a1 & h.a2 = g.a2 by A9,FUNCT_1:72;
        then h.a1 = F(a1) & h.a2 = F(a2) by A4,A27;
        then [0,a1] = [0,a2] by A26,TREES_4:4;
        hence a1 = a2 by ZFMISC_1:33;
      end;
      suppose
A28:     Gk[a1] & Gk[a2];
        then consider b1 being (Element of dom the charact of A),
        q1 being Element of (the carrier of A)* such that
A29:     a1 = Den(b1,A).q1 & q1 in dom Den(b1,A) & rng q1 c= G|^k;
        consider b2 being (Element of dom the charact of A),
        q2 being Element of (the carrier of A)* such that
A30:     a2 = Den(b2,A).q2 & q2 in dom Den(b2,A) & rng q2 c= G|^k by A28;
         b1-tree(h*q1) = h.a1 by A13,A29 .= b2-tree(h*q2) by A13,A26,A30;
then A31:     b1 = b2 & h*q1 = h*q2 by TREES_4:15;
         len q1 = S.b1 & len q2 = S.b2 by A13,A29,A30;
then A32:     dom q1 = Seg len q1 & dom q2 = Seg len q1 by A31,FINSEQ_1:def 3;
         now let j be Nat;
          assume
A33:       j in dom q1;
          then q1.j in rng q1 & q2.j in rng q2 by A32,FUNCT_1:12;
          then q1.j in G|^k & q2.j in G|^k & h.(q1.j) = (h*q1).j &
          h.(q2.j) = (h*q2).j by A29,A30,A32,A33,FUNCT_1:23;
          hence q1.j = q2.j by A25,A31;
        end;
        hence a1 = a2 by A29,A30,A31,A32,FINSEQ_1:17;
      end;
      suppose
         a1 in G & Gk[a2] or Gk[a1] & a2 in G;
        hence a1 = a2 by A20,A26;
      end;
    end;
A34: for k being Nat holds G[k] from NAT_1:sch 2(A18,A24);
    reconsider q1 = p1, q2 = p2 as FinSequence of A by A1,FINSEQ_1:def 11;
     o1-tree(h*q1) = h.(Den(o1,A).p1) by A1,A13
    .= o2-tree(h*q2) by A1,A2,A13;
then A35: h*p1 = h*p2 by TREES_4:15;
     len q1 = S.o1 & len q2 = S.o2 by A1,A13;
then A36: dom q1 = Seg len q1 & dom q2 = Seg len q1 by A3,FINSEQ_1:def 3;
     now let j be Nat;
      assume
A37:   j in dom q1;
then A38:   q1.j in rng q1 & q2.j in rng q2 by A36,FUNCT_1:12;
      then consider n1 being Nat such that
A39:   q1.j in G|^n1 by Th30;
      consider n2 being Nat such that
A40:   q2.j in G|^n2 by A38,Th30;
      reconsider k = max(n1,n2) as Nat by XXREAL_0:16;
       n1 <= k & n2 <= k by XXREAL_0:25;
      then G|^n1 c= G|^k & G|^n2 c= G|^k by Th21;
      then q1.j in G|^k & q2.j in G|^k & h.(q1.j) = (h*q1).j &
      h.(q2.j) = (h*q2).j & G[k] by A34,A36,A37,A39,A40,FUNCT_1:23;
      hence q1.j = q2.j by A35;
    end;
    hence p1 = p2 by A36,FINSEQ_1:17;
  end;

theorem
   for A being free Universal_Algebra
  for o1,o2 being Element of Operations A
  for p1,p2 being FinSequence st p1 in dom o1 & p2 in dom o2
  holds o1.p1 = o2.p2 implies o1 = o2 & p1 = p2
  proof
    let A be free Universal_Algebra;
    let o1,o2 be Element of Operations A;
    consider a1 being set such that
A1: a1 in dom the charact of A & o1 = (the charact of A).a1 by FUNCT_1:def 5;
    consider a2 being set such that
A2: a2 in dom the charact of A & o2 = (the charact of A).a2 by FUNCT_1:def 5;
    reconsider a1,a2 as OperSymbol of A by A1,A2;
A3: o1 = Den(a1,A) & o2 = Den(a2,A) by A1,A2;
    let p1,p2 be FinSequence;
    assume p1 in dom o1 & p2 in dom o2 & o1.p1 = o2.p2;
    hence thesis by A3,Th36;
  end;

theorem Th38:
  for A being free Universal_Algebra
  for o being OperSymbol of A
  for p being FinSequence st p in dom Den(o,A)
  for a being set st a in rng p
  holds a <> Den(o,A).p
  proof
    let A be free Universal_Algebra;
    let o be OperSymbol of A;
    let p be FinSequence such that
A1: p in dom Den(o,A);
    let a be set such that
A2: a in rng p & a = Den(o,A).p;
    reconsider p as FinSequence of A by A1,FINSEQ_1:def 11;
     a in rng p by A2;
    then reconsider a as Element of A;
    set G = Generators A;
    consider n being Nat such that
A3: a in G|^n by Th30;
    reconsider n as Element of NAT by ORDINAL1:def 13;
    defpred P[Nat] means ex a being (Element of A), o being OperSymbol of A st
    ex p being FinSequence of A st
    p in dom Den(o,A) & a in rng p & a = Den(o,A).p & a in G|^$1;
     a in rng p & a in G|^n by A2,A3;
then A4: ex n being Element of NAT st P[n] by A1,A2;
    consider n being Element of NAT such that
A5: P[n] & for m being Element of NAT st P[m] holds n <= m
    from NAT_1:sch 5(A4);
    consider a being (Element of A), o being OperSymbol of A,
    p being FinSequence of A such that
A6: p in dom Den(o,A) & a in rng p & a = Den(o,A).p & a in G|^n by A5;
    reconsider op = Den(o,A) as Element of Operations A;
     a in rng op by A6,FUNCT_1:12;
    then a nin G by Th26;
    then n <> 0 by A6,Th18;
    then consider k being Nat such that
A7: n = k+1 by NAT_1:6;
    reconsider k as Element of NAT by ORDINAL1:def 13;
A8: k < n by A7,NAT_1:13;
    then a nin G|^k by A5,A6;
    then consider o' being (Element of dom the charact of A),
    p' being Element of (the carrier of A)* such that
A9: a = Den(o',A).p' & p' in dom Den(o',A) & rng p' c= G|^k by A6,A7,Th20;
     p' = p by A6,A9,Th36;
    hence contradiction by A5,A6,A8,A9;
  end;

theorem Th39:
  for A being free Universal_Algebra
  for G being GeneratorSet of A
  for o being OperSymbol of A
  st for o' being OperSymbol of A, p being FinSequence
     st p in dom Den(o',A) & Den(o',A).p in G holds o' <> o
  for p being FinSequence st p in dom Den(o,A)
  for n being Nat st Den(o,A).p in G|^(n+1)
  holds rng p c= G|^n
  proof
    let A be free Universal_Algebra;
    let G be GeneratorSet of A;
    let o be OperSymbol of A such that
A1: for o' being OperSymbol of A, p being FinSequence
    st p in dom Den(o',A) & Den(o',A).p in G holds o' <> o;
    let p be FinSequence such that
A2: p in dom Den(o,A);
    let n be Nat such that
A3: Den(o,A).p in G|^(n+1) & not rng p c= G|^n;
    reconsider p as FinSequence of A by A2,FINSEQ_1:def 11;
    defpred P[Nat] means
    ex p being FinSequence of A st
    p in dom Den(o,A) & Den(o,A).p in G|^($1+1) & not rng p c= G|^$1;
     p is FinSequence of A & n is Element of NAT by ORDINAL1:def 13;
then A4: ex n being Element of NAT st P[n] by A2,A3;
    consider n being Element of NAT such that
A5: P[n] & for m being Element of NAT st P[m] holds n <= m
    from NAT_1:sch 5(A4);
    consider p being FinSequence of A such that
A6: p in dom Den(o,A) & Den(o,A).p in G|^(n+1) & not rng p c= G|^n by A5;
    set a = Den(o,A).p;
     now assume
A7:   a in G|^n;
       a nin G by A1,A6;
      then n <> 0 by A7,Th18;
      then consider k being Nat such that
A8:   n = k+1 by NAT_1:6;
      reconsider k as Element of NAT by ORDINAL1:def 13;
A9:   k < n by A8,NAT_1:13;
      then G|^k c= G|^n by Th21;
      then not rng p c= G|^k by A6,XBOOLE_1:1;
      hence contradiction by A5,A6,A7,A8,A9;
    end;
    then ex o' being (Element of dom the charact of A),
    p' being Element of (the carrier of A)* st
    a = Den(o',A).p' & p' in dom Den(o',A) & rng p' c= G|^n by A6,Th20;
    hence contradiction by A6,Th36;
  end;

theorem
   for A being free Universal_Algebra
  for o being OperSymbol of A
  for p being FinSequence st p in dom Den(o,A)
  for n being Nat st Den(o,A).p in (Generators A)|^(n+1)
  holds rng p c= (Generators A)|^n
  proof
    let A be free Universal_Algebra;
    set G = Generators A;
    let o be OperSymbol of A;
     now let o' be OperSymbol of A, p be FinSequence;
      reconsider op = Den(o',A) as Element of Operations A;
      assume p in dom Den(o',A);
      then op.p in rng op by FUNCT_1:12;
      hence Den(o',A).p in G implies o' <> o by Th26;
    end;
    hence thesis by Th39;
  end;

begin :: If-while Algebra

definition
  let S be non empty UAStr;
  attr S is with_empty-instruction means:
Def10:
  1 in dom the charact of S &
  (the charact of S).1 is nullary (non empty homogeneous
  quasi_total PartFunc of (the carrier of S)*, the carrier of S);
  attr S is with_catenation means:
Def11:
  2 in dom the charact of S &
  (the charact of S).2 is binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S);
  attr S is with_if-instruction means:
Def12:
  3 in dom the charact of S &
  (the charact of S).3 is ternary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S);
  attr S is with_while-instruction means:
Def13:
  4 in dom the charact of S &
  (the charact of S).4 is binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S);
  attr S is associative means:
Def14:
  (the charact of S).2 is binary associative (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S);
end;

definition
  let S be non-empty UAStr;
  attr S is unital means:
Def15:
  ex f being binary (non empty homogeneous
   quasi_total PartFunc of (the carrier of S)*, the carrier of S)
  st f = (the charact of S).2 &
     Den(In(1, dom the charact of S), S).({}) is_a_unity_wrt f;
end;

theorem Th41:
  for X being non empty set, x being Element of X
  for c being binary associative unital
    (non empty quasi_total homogeneous PartFunc of X*, X)
  st x is_a_unity_wrt c
  for i being ternary
    (non empty quasi_total homogeneous PartFunc of X*, X)
  for w being binary
    (non empty quasi_total homogeneous PartFunc of X*, X)
  ex S being non-empty strict UAStr st
  the carrier of S = X &
  the charact of S = <*(0-tuples_on X)-->x,c*>^<*i,w*> &
  S is with_empty-instruction with_catenation unital associative
       with_if-instruction with_while-instruction
       quasi_total partial
  proof
    let X be non empty set;
    let x be Element of X;
    let c be binary associative unital (non empty quasi_total homogeneous
    PartFunc of X*, X);
    assume
A1: x is_a_unity_wrt c;
    let i be ternary (non empty quasi_total homogeneous PartFunc of X*, X);
    let w be binary (non empty quasi_total homogeneous PartFunc of X*, X);
    set Y = 0-tuples_on X;
    set e = Y --> x;
    reconsider e as nullary
    (non empty quasi_total homogeneous PartFunc of X*, X) by Lm1;
    set char = <*e,c*>^<*i,w*>;
    reconsider ec = <*e,c*> as non empty FinSequence;
A2: ec^<*i,w*> is non empty;
     char is PFuncFinSequence of X
    proof
      let a be set;
      assume a in rng char;
      then a in rng <*e,c*> \/ rng <*i,w*> by FINSEQ_1:44;
      then a in rng <*e,c*> or a in rng <*i,w*> by XBOOLE_0:def 2;
      then a in {e,c} or a in {i,w} by FINSEQ_2:147;
      then a = e or a = c or a = i or a = w by TARSKI:def 2;
      hence a in PFuncs(X*, X) by PARTFUN1:119;
    end;
    then reconsider char as non empty non-empty PFuncFinSequence of X by A2;
    reconsider S = UAStr(#X, char#) as non-empty strict UAStr
    by UNIALG_1:def 9;
    take S;
    thus the carrier of S = X;
    thus the charact of S = <*(0-tuples_on X)-->x,c*>^<*i,w*>;
A3: len <*e,c*> = 2 & len <*i,w*> = 2 by FINSEQ_1:61;
    then len char = 2+2 by FINSEQ_1:35;
then A4: dom char = Seg 4 by FINSEQ_1:def 3;
    reconsider e as nullary (non empty homogeneous
    PartFunc of (the carrier of S)*, the carrier of S);
    reconsider c as binary associative (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S);
A5: <*e,c*>.1 = e & <*e,c*>.2 = c & <*i,w*>.1 = i & <*i,w*>.2 = w
    by FINSEQ_1:61;
    thus 1 in dom the charact of S by A4;
     dom <*e,c*> = Seg 2 by FINSEQ_3:29;
then A6: 1 in dom <*e,c*> & 2 in dom <*e,c*>;
then A7: e =  (the charact of S).1 & c = (the charact of S).2 by A5,
FINSEQ_1:def 7;
    thus (the charact of S).1 is nullary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S)
     by A5,A6,FINSEQ_1:def 7;
    thus 2 in dom the charact of S by A4;
    thus (the charact of S).2 is binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S)
    by A5,A6,FINSEQ_1:def 7;
    thus S is unital
    proof take c;
      thus c = (the charact of S).2 by A5,A6,FINSEQ_1:def 7;
       1 in dom the charact of S by A4;
      then Y = {{}} & In(1, dom the charact of S) = 1
      by COMPUT_1:8,FUNCT_7:def 1;
      then {} in Y & e = Den(In(1, dom the charact of S),S)
      by A5,A6,FINSEQ_1:def 7,TARSKI:def 1;
      hence Den(In(1, dom the charact of S),S).({}) is_a_unity_wrt c
      by A1,FUNCOP_1:13;
    end;
    thus (the charact of S).2 is binary associative (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S)
    by A5,A6,FINSEQ_1:def 7;
    thus 3 in dom the charact of S by A4;
     dom <*i,w*> = Seg 2 by FINSEQ_3:29;
    then 1 in dom <*i,w*> & 2 in dom <*i,w*>;
then A8: char.(2+1) = i & char.(2+2) = w by A3,A5,FINSEQ_1:def 7;
    hence (the charact of S).3 is ternary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S);
    thus 4 in dom the charact of S by A4;
    thus (the charact of S).4 is binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S) by A8;
    thus S is quasi_total
    proof
      let i be Nat, h be PartFunc of (the carrier of S)*, the carrier of S;
      assume i in dom the charact of S;

      hence thesis by A4,A7,A8,ENUMSET1:def 2,FINSEQ_3:2;
    end;
    let i be Nat, h be PartFunc of (the carrier of S)*, the carrier of S;
    assume
A9: i in dom the charact of S & h = (the charact of S).i;
    let p1,p2 be FinSequence;
     i = 1 or i = 2 or i = 3 or i = 4 by A4,A9,ENUMSET1:def 2,FINSEQ_3:2;
    hence thesis by A7,A8,A9,UNIALG_1:def 1;
  end;

registration
  cluster with_empty-instruction with_catenation with_if-instruction
  with_while-instruction unital associative
  (quasi_total partial non-empty strict UAStr);
  existence
  proof
    consider X being non empty set;
    consider c being binary associative unital
    (non empty quasi_total homogeneous PartFunc of X*, X);
    consider a being Element of X;
    consider x being set such that
A1: x is_a_unity_wrt c by Def3;
     arity c = 2 by COMPUT_1:def 26;
then A2: dom c = 2-tuples_on X by COMPUT_1:25;
    then <*a,a*> in dom c by CATALG_1:10;
    then <*a,x*> in dom c by A1,Def1;
    then reconsider x as Element of X by A2,CATALG_1:11;
    consider i being ternary
    (non empty quasi_total homogeneous PartFunc of X*, X);
    consider w being binary
    (non empty quasi_total homogeneous PartFunc of X*, X);
     ex S being non-empty strict UAStr st
    the carrier of S = X &
    the charact of S = <*(0-tuples_on X)-->x,c*>^<*i,w*> &
    S is with_empty-instruction with_catenation unital associative
    with_if-instruction with_while-instruction quasi_total partial
    by A1,Th41;
    hence thesis;
  end;
end;

definition
  mode preIfWhileAlgebra is with_empty-instruction
  with_catenation with_if-instruction with_while-instruction
  Universal_Algebra;
end;

reserve A for preIfWhileAlgebra,
  C,I,J for Element of A;
reserve S for non empty set, T for Subset of S,
  s for Element of S;

definition
  let A be non empty UAStr;
  mode Algorithm of A is Element of A;
end;

theorem Th42:
  for A being with_empty-instruction (non-empty UAStr)
  holds dom Den(In(1, dom the charact of A), A) = {{}}
  proof
    let A be with_empty-instruction (non-empty UAStr);
    reconsider e = (the charact of A).1 as nullary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def10;
    consider a being Element of A;
     1 in dom the charact of A by Def10;
then A1: Den(In(1, dom the charact of A), A) = e by FUNCT_7:def 1;
     arity e = 0 by COMPUT_1:def 24;
    then dom e = 0-tuples_on the carrier of A by COMPUT_1:25;
    hence dom Den(In(1, dom the charact of A), A) = {{}} by A1,COMPUT_1:8;
  end;

definition
  let A be with_empty-instruction (non-empty UAStr);
  func EmptyIns A -> Algorithm of A equals
   Den(In(1, dom the charact of A), A).{};
  coherence
  proof
    reconsider e = (the charact of A).1 as nullary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def10;
    consider a being Element of A;
     1 in dom the charact of A by Def10;
then A1: Den(In(1, dom the charact of A), A) = e by FUNCT_7:def 1;
    then dom e = {{}} by Th42;
    then {} in dom e by TARSKI:def 1;
    hence thesis by A1,PARTFUN1:27;
   end;
end;

theorem
   for A being with_empty-instruction Universal_Algebra
  for o being Element of Operations A
  st o = Den(In(1, dom the charact of A), A)
  holds arity o = 0 & EmptyIns A in rng o
  proof
    let A be with_empty-instruction Universal_Algebra;
    let o be Element of Operations A such that
A1: o = Den(In(1, dom the charact of A), A);
A2: dom Den(In(1, dom the charact of A), A) = {{}} by Th42;
A3: <*>the carrier of A in {{}} by TARSKI:def 1;
    hence arity o = len (<*>the carrier of A) by A1,A2,UNIALG_1:def 10
    .= 0 by FINSEQ_1:25;
    thus thesis by A1,A2,A3,FUNCT_1:def 5;
  end;

theorem Th44:
  for A being with_catenation (non-empty UAStr)
  holds dom Den(In(2, dom the charact of A), A) = 2-tuples_on the carrier of A
  proof
    let A be with_catenation (non-empty UAStr);
    reconsider f = (the charact of A).2 as binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def11;
     2 in dom the charact of A by Def11;
then A1: Den(In(2, dom the charact of A), A) = f by FUNCT_7:def 1;
     arity f = 2 by COMPUT_1:def 26;
    hence thesis by A1,COMPUT_1:25;
  end;

definition
  let A be with_catenation (non-empty UAStr);
  let I1,I2 be Algorithm of A;
  func I1 \; I2 -> Algorithm of A equals
   Den(In(2, dom the charact of A), A).<*I1,I2*>;
  coherence
  proof
    reconsider f = (the charact of A).2 as binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def11;
     2 in dom the charact of A by Def11;
then A1: Den(In(2, dom the charact of A), A) = f by FUNCT_7:def 1;
    then dom f = 2-tuples_on the carrier of A by Th44;
    then <*I1,I2*> in dom f by CATALG_1:10;
    hence thesis by A1,PARTFUN1:27;
  end;
end;

theorem
   for A being with_empty-instruction with_catenation unital (non-empty UAStr)
  for I being Element of A holds
  EmptyIns A\;I = I & I\;EmptyIns A = I
  proof
    let A be with_empty-instruction with_catenation unital (non-empty UAStr);
    let I be Element of A;
    consider f being binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) such that
A1: f = (the charact of A).2 and
A2: Den(In(1, dom the charact of A), A).({}) is_a_unity_wrt f by Def15;
     2 in dom the charact of A & arity f = 2
    by Def11,COMPUT_1:def 26;
    then dom f = 2-tuples_on the carrier of A & In(2, dom the charact of A) =
2
    by COMPUT_1:25,FUNCT_7:def 1;
    then EmptyIns A\;I = f.(<*EmptyIns A, I*>) & <*I,I*> in dom f &
    I\;EmptyIns A = f.(<*I, EmptyIns A*>)
    by A1,CATALG_1:10;
    hence thesis by A2,Def1;
  end;

theorem
   for A being associative with_catenation (non-empty UAStr)
  for I1,I2,I3 being Element of A holds
  (I1\;I2)\;I3 = I1\;(I2\;I3)
  proof
    let A be associative with_catenation (non-empty UAStr);
    let I1,I2,I3 be Element of A;
    reconsider f = (the charact of A).2 as
    binary associative (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def14;
     2 in dom the charact of A & arity f = 2 by Def11,COMPUT_1:def 26;
    then dom f = 2-tuples_on the carrier of A & In(2, dom the charact of A) =
2
    by COMPUT_1:25,FUNCT_7:def 1;
    then I1\;I2 = f.(<*I1,I2*>) & I2\;I3 = f.(<*I2,I3*>) &
    (I1\;I2)\;I3 = f.(<*I1\;I2,I3*>) & I1\;(I2\;I3) = f.(<*I1,I2\;I3*>) &
    <*I1,I2*> in dom f & <*I2,I3*> in dom f & <*I1,I2\;I3*> in dom f &
    <*I1\;I2,I3*> in dom f by CATALG_1:10;
    hence (I1\;I2)\;I3 = I1\;(I2\;I3) by Def2;
  end;

theorem Th47:
  for A being with_if-instruction (non-empty UAStr)
  holds dom Den(In(3, dom the charact of A), A) = 3-tuples_on the carrier of A
  proof
    let A be with_if-instruction (non-empty UAStr);
    reconsider f = (the charact of A).3 as ternary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def12;
     3 in dom the charact of A & 3 in Seg 3 by Def12;
then A1: Den(In(3, dom the charact of A), A) = f by FUNCT_7:def 1;
     arity f = 3 by COMPUT_1:def 27;
    hence thesis by A1,COMPUT_1:25;
  end;

definition
  let A be with_if-instruction (non-empty UAStr);
  let C,I1,I2 be Algorithm of A;
  func if-then-else(C,I1,I2) -> Algorithm of A equals
   Den(In(3, dom the charact of A), A).<*C,I1,I2*>;
  coherence
  proof
    reconsider f = (the charact of A).3 as ternary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def12;
     3 in dom the charact of A & 3 in Seg 3 by Def12;
then A1: Den(In(3, dom the charact of A), A) = f by FUNCT_7:def 1;
     arity f = 3 by COMPUT_1:def 27;
    then dom f = 3-tuples_on the carrier of A by COMPUT_1:25;
    then <*C,I1,I2*> in dom f by CATALG_1:12;
    hence thesis by A1,PARTFUN1:27;
  end;
end;

definition
  let A be with_empty-instruction with_if-instruction (non-empty UAStr);
  let C,I be Algorithm of A;
  func if-then(C,I) -> Algorithm of A equals
   if-then-else(C,I,EmptyIns A);
  coherence;
end;

theorem Th48:
  for A being with_while-instruction (non-empty UAStr)
  holds dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A
  proof
    let A be with_while-instruction (non-empty UAStr);
    reconsider f = (the charact of A).4 as binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def13;
     4 in dom the charact of A by Def13;
then A1: Den(In(4, dom the charact of A), A) = f by FUNCT_7:def 1;
     arity f = 2 by COMPUT_1:def 26;
    hence thesis by A1,COMPUT_1:25;
  end;

definition
  let A be with_while-instruction (non-empty UAStr);
  let C,I be Algorithm of A;
  func while(C,I) -> Algorithm of A equals
   Den(In(4, dom the charact of A), A).<*C,I*>;
  coherence
  proof
    reconsider f = (the charact of A).4 as binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def13;
     4 in dom the charact of A by Def13;
then A1: Den(In(4, dom the charact of A), A) = f by FUNCT_7:def 1;
     arity f = 2 by COMPUT_1:def 26;
    then dom f = 2-tuples_on the carrier of A by COMPUT_1:25;
    then <*C,I*> in dom f by CATALG_1:10;
    hence thesis by A1,PARTFUN1:27;
  end;
end;

definition
  let A be preIfWhileAlgebra;
  let I0,C,I,J be Element of A;
  func for-do(I0,C,J,I) -> Element of A equals
   I0\;while(C,I\;J);
  coherence;
end;

definition
  let A be preIfWhileAlgebra;
  func ElementaryInstructions A -> Subset of A equals
   (the carrier of A)
  \ {EmptyIns A}
  \ rng Den(In(3, dom the charact of A), A)
  \ rng Den(In(4, dom the charact of A), A)
  \ {I1 \; I2 where I1,I2 is Algorithm of A: I1 <> I1\;I2 & I2 <> I1\;I2};
  coherence;
end;

theorem Th49:
  for A being preIfWhileAlgebra holds EmptyIns A nin ElementaryInstructions A
  proof
    let A be preIfWhileAlgebra;
    set I = EmptyIns A;
     I in {I} by TARSKI:def 1;
    then I nin (the carrier of A)\{I} by XBOOLE_0:def 4;
    then I nin (the carrier of A) \ {EmptyIns A}
    \ rng Den(In(3, dom the charact of A), A) by XBOOLE_0:def 4;
    then I nin (the carrier of A) \ {EmptyIns A}
    \ rng Den(In(3, dom the charact of A), A)
    \ rng Den(In(4, dom the charact of A), A) by XBOOLE_0:def 4;
    hence I nin ElementaryInstructions A by XBOOLE_0:def 4;
  end;

theorem Th50:
  for A being preIfWhileAlgebra
  for I1,I2 being Element of A st I1 <> I1\;I2 & I2 <> I1\;I2
   holds I1\;I2 nin ElementaryInstructions A
  proof
    let A be preIfWhileAlgebra;
    let I1,I2 be Element of A;
    assume I1 <> I1\;I2 & I2 <> I1\;I2;
    then I1\;I2 in {J1 \; J2 where J1,J2 is Algorithm of A:
    J1 <> J1\;J2 & J2 <> J1\;J2};
    hence I1\;I2 nin ElementaryInstructions A by XBOOLE_0:def 4;
  end;

theorem Th51:
  for A being preIfWhileAlgebra
  for C,I1,I2 being Element of A
  holds if-then-else(C,I1,I2) nin ElementaryInstructions A
  proof
    let A be preIfWhileAlgebra;
    let C,I1,I2 be Element of A;
    set I = if-then-else(C,I1,I2);
    reconsider f = (the charact of A).3 as ternary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def12;
     3 in dom the charact of A by Def12;
    then In(3, dom the charact of A) = 3 by FUNCT_7:def 1;
    then dom Den(In(3, dom the charact of A), A)
    = (arity f)-tuples_on the carrier of A by COMPUT_1:25
    .= 3-tuples_on the carrier of A by COMPUT_1:def 27;
    then <*C,I1,I2*> in dom Den(In(3, dom the charact of A), A) by CATALG_1:12
;
    then I in rng Den(In(3, dom the charact of A), A) by FUNCT_1:def 5;
    then I nin (the carrier of A) \ {EmptyIns A}
    \ rng Den(In(3, dom the charact of A), A) by XBOOLE_0:def 4;
    then I nin (the carrier of A) \ {EmptyIns A}
    \ rng Den(In(3, dom the charact of A), A)
    \ rng Den(In(4, dom the charact of A), A) by XBOOLE_0:def 4;
    hence if-then-else(C,I1,I2) nin ElementaryInstructions A by XBOOLE_0:def 4;
  end;

theorem Th52:
  for A being preIfWhileAlgebra
  for C,I being Element of A
  holds while(C,I) nin ElementaryInstructions A
  proof
    let A be preIfWhileAlgebra;
    let C,I1 be Element of A;
    set I = while(C,I1);
    reconsider f = (the charact of A).4 as binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def13;
     4 in dom the charact of A by Def13;
    then In(4, dom the charact of A) = 4 by FUNCT_7:def 1;
    then dom Den(In(4, dom the charact of A), A)
    = (arity f)-tuples_on the carrier of A by COMPUT_1:25
    .= 2-tuples_on the carrier of A by COMPUT_1:def 26;
    then <*C,I1*> in dom Den(In(4, dom the charact of A), A) by CATALG_1:10;
    then I in rng Den(In(4, dom the charact of A), A) by FUNCT_1:def 5;
    then I nin (the carrier of A) \ {EmptyIns A}
    \ rng Den(In(3, dom the charact of A), A)
    \ rng Den(In(4, dom the charact of A), A) by XBOOLE_0:def 4;
    hence I nin ElementaryInstructions A by XBOOLE_0:def 4;
  end;

theorem Th53:
  for A being preIfWhileAlgebra
  for I being Element of A
  st I nin ElementaryInstructions A
  holds I = EmptyIns A or
  (ex I1,I2 being Element of A st I = I1\;I2 & I1 <> I1\;I2 & I2 <> I1\;I2) or
  (ex C,I1,I2 being Element of A st I = if-then-else(C,I1,I2)) or
  (ex C,J being Element of A st I = while(C,J))
  proof
    let A be preIfWhileAlgebra;
    let I be Element of A such that
A1: I nin ElementaryInstructions A and
A2: I <> EmptyIns A and
A3: for I1,I2 being Element of A st I = I1\;I2 & I1 <> I1\;I2 holds
    I2 = I1\;I2 and
A4: for C,I1,I2 being Element of A holds I <> if-then-else(C,I1,I2) and
A5: for C,J being Element of A holds I <> while(C,J);
A6: now assume I in rng Den(In(3, dom the charact of A), A);
      then consider x being set such that
A7:   x in dom Den(In(3, dom the charact of A), A) &
      I = Den(In(3, dom the charact of A), A).x by FUNCT_1:def 5;
      reconsider f = (the charact of A).3 as ternary (non empty homogeneous
      quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def12;
       3 in dom the charact of A by Def12;
      then In(3, dom the charact of A) = 3 by FUNCT_7:def 1;
      then dom Den(In(3, dom the charact of A), A)
      = (arity f)-tuples_on the carrier of A by COMPUT_1:25
      .= 3-tuples_on the carrier of A by COMPUT_1:def 27;
      then consider C,I1,I2 be set such that
A8:   C in the carrier of A & I1 in the carrier of A & I2 in the carrier of A &
      x = <*C,I1,I2*> by A7,CATALG_1:12;
      reconsider C,I1,I2 as Element of A by A8;
       I = if-then-else(C,I1,I2) by A7,A8;
      hence contradiction by A4;
    end;
A9: now assume I in rng Den(In(4, dom the charact of A), A);
      then consider x being set such that
A10:   x in dom Den(In(4, dom the charact of A), A) &
      I = Den(In(4, dom the charact of A), A).x by FUNCT_1:def 5;
      reconsider f = (the charact of A).4 as binary (non empty homogeneous
      quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def13;
       4 in dom the charact of A by Def13;
      then In(4, dom the charact of A) = 4 by FUNCT_7:def 1;
      then dom Den(In(4, dom the charact of A), A)
      = (arity f)-tuples_on the carrier of A by COMPUT_1:25
      .= 2-tuples_on the carrier of A by COMPUT_1:def 26;
      then consider C,J be set such that
A11:   C in the carrier of A & J in the carrier of A &
      x = <*C,J*> by A10,CATALG_1:10;
      reconsider C,J as Element of A by A11;
       I = while(C,J) by A10,A11;
      hence contradiction by A5;
    end;
A12: I nin {I1\;I2 where I1,I2 is Algorithm of A: I1 <> I1\;I2 & I2 <> I1\;I2}
    by A3;
     I in (the carrier of A)
    \ {EmptyIns A} by A2,ZFMISC_1:64;
    then I in (the carrier of A)
    \ {EmptyIns A}
    \ rng Den(In(3, dom the charact of A), A) by A6,XBOOLE_0:def 4;
    then I in (the carrier of A)
    \ {EmptyIns A}
    \ rng Den(In(3, dom the charact of A), A)
    \ rng Den(In(4, dom the charact of A), A) by A9,XBOOLE_0:def 4;
    hence contradiction by A1,A12,XBOOLE_0:def 4;
  end;

definition
  let A be preIfWhileAlgebra;
  attr A is infinite means:
Def23:
  ElementaryInstructions A is infinite;
  attr A is degenerated means:
Def24:
  (ex I1,I2 being Element of A st
  I1 <> EmptyIns A & I1\;I2 = I2 or I2 <> EmptyIns A & I1\;I2 = I1 or
  (I1 <> EmptyIns A or I2 <> EmptyIns A) & I1\;I2 = EmptyIns A) or
  (ex C,I1,I2 being Element of A st if-then-else(C,I1,I2) = EmptyIns A) or
  (ex C,I being Element of A st while(C,I) = EmptyIns A) or
  (ex I1,I2,C,J1,J2 being Element of A st I1 <> EmptyIns A & I2 <> EmptyIns A &
  I1\;I2 = if-then-else(C,J1,J2)) or
  (ex I1,I2,C,J being Element of A st I1 <> EmptyIns A & I2 <> EmptyIns A &
  I1\;I2 = while(C,J)) or
  (ex C1,I1,I2,C2,J being Element of A st
  if-then-else(C1,I1,I2) = while(C2,J));
  attr A is well_founded means:
Def25:
  ElementaryInstructions A is GeneratorSet of A;
end;

definition
  func ECIW-signature -> non empty FinSequence of NAT equals
   <*0, 2*>^<*3, 2*>;
  coherence
  proof
    reconsider 02 = <*0,2*> as non empty FinSequence of NAT;
     02^<*3,2*> is non empty;
    hence thesis;
  end;
end;

theorem Th54:
  len ECIW-signature = 4 & dom ECIW-signature = Seg 4 &
  ECIW-signature.1 = 0 & ECIW-signature.2 = 2 &
  ECIW-signature.3 = 3 & ECIW-signature.4 = 2
  proof set S = ECIW-signature;
A1: len <*0,2*> = 2 & len <*3,2*> = 2 by FINSEQ_1:61;
then A2: len S = 2+2 & dom <*0,2*> = Seg 2 & dom <*3,2*> = Seg 2
    by FINSEQ_1:35,def 3;
then A3: 1 in dom <*3,2*> & <*3,2*>.1 = 3 & 2 in dom <*3,2*> & <*3,2*>.2 = 2 &
    2+1 = 3 & 2+2 = 4 by FINSEQ_1:61;
     1 in dom <*0,2*> & <*0,2*>.1 = 0 & 2 in dom <*0,2*> & <*0,2*>.2 = 2
      by A2,FINSEQ_1:61;
    hence thesis by A1,A3,FINSEQ_1:35,def 7;
  end;

definition
  let A be partial non-empty non empty UAStr;
  attr A is ECIW-strict means:
Def27:
   signature A = ECIW-signature;
end;

theorem Th55:
  for A being partial non-empty non empty UAStr st A is ECIW-strict
  for o being OperSymbol of A
  holds o = 1 or o = 2 or o = 3 or o = 4
  proof
    let A be partial non-empty non empty UAStr;
    assume signature A = ECIW-signature;
    then 4 = len the charact of A by Th54,UNIALG_1:def 11;
    then dom the charact of A = Seg 4 by FINSEQ_1:def 3;
    hence thesis by ENUMSET1:def 2,FINSEQ_3:2;
  end;

registration
  let X be disjoint_with_NAT non empty set;
  cluster FreeUnivAlgNSG(ECIW-signature,X) -> with_empty-instruction
  with_catenation with_if-instruction with_while-instruction;
  coherence
  proof set S = FreeUnivAlgNSG(ECIW-signature,X);
    set char = ECIW-signature;
A1: len <*0,2*> = 2 & len <*3,2*> = 2 by FINSEQ_1:61;
then A2: len char = 2+2 & len the charact of S = len char & dom <*0,2*> = Seg 2
&
    dom <*3,2*> = Seg 2 by FINSEQ_1:35,def 3,FREEALG:def 12;
then A3: dom the charact of S = Seg 4 & dom char = Seg 4 by FINSEQ_1:def 3;
    hence 1 in dom the charact of S;
then A4: (the charact of S).1 = FreeOpNSG(1,char,X) by FREEALG:def 12;
A5: 1 in dom char & 2 in dom char & 3 in dom char & 4 in dom char by A3;
    reconsider D = TS(DTConUA(char,X)) as non empty set;
    reconsider char as non empty FinSequence of omega;
    set o = FreeOpNSG(1,char,X);
A6: 1 in dom <*0,2*> & <*0,2*>.1 = 0 & 2 in dom <*0,2*> & <*0,2*>.2 = 2
    by A2,FINSEQ_1:61;
    then char.1 = 0 by FINSEQ_1:def 7;
    then char/.1 = 0 & the carrier of S = D by A5,PARTFUN1:def 8;
then A7: dom o = 0-tuples_on the carrier of S by A5,FREEALG:def 11;
    reconsider o as homogeneous non empty quasi_total PartFunc of D*, D;
     arity o = 0 by A7,COMPUT_1:28;
    hence (the charact of S).1 is nullary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S)
    by A4,COMPUT_1:def 24;
    thus 2 in dom the charact of S by A3;
then A8: (the charact of S).2 = FreeOpNSG(2,char,X) by FREEALG:def 12;
    set o = FreeOpNSG(2,char,X);
     char.2 = 2 by A6,FINSEQ_1:def 7;
    then (char qua FinSequence of omega)/.2 = 2 by A5,PARTFUN1:def 8;
then A9: dom o = 2-tuples_on the carrier of S by A5,FREEALG:def 11;
    reconsider o as homogeneous non empty quasi_total PartFunc of D*, D;
     arity o = 2 by A9,COMPUT_1:28;
    hence (the charact of S).2 is binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S)
    by A8,COMPUT_1:def 26;
    thus 3 in dom the charact of S by A3;
then A10: (the charact of S).3 = FreeOpNSG(3,char,X) by FREEALG:def 12;
    set o = FreeOpNSG(3,char,X);
A11: 1 in dom <*3,2*> & <*3,2*>.1 = 3 & 2 in dom <*3,2*> & <*3,2*>.2 = 2
    by A2,FINSEQ_1:61;
    then char.(2+1) = 3 by A1,FINSEQ_1:def 7;
    then (char qua FinSequence of omega)/.3 = 3
    by A5,PARTFUN1:def 8;
then A12: dom o = 3-tuples_on the carrier of S by A5,FREEALG:def 11;
    reconsider o as homogeneous non empty quasi_total PartFunc of D*, D;
     arity o = 3 by A12,COMPUT_1:28;
    hence (the charact of S).3 is ternary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S)
    by A10,COMPUT_1:def 27;
    thus 4 in dom the charact of S by A3;
then A13: (the charact of S).4 = FreeOpNSG(4,char,X) by FREEALG:def 12;
    set o = FreeOpNSG(4,char,X);
     char.(2+2) = 2 by A1,A11,FINSEQ_1:def 7;
    then (char qua FinSequence of omega)/.4 = 2 by A5,PARTFUN1:def 8;
then A14: dom o = 2-tuples_on the carrier of S by A5,FREEALG:def 11;
    reconsider o as homogeneous non empty quasi_total PartFunc of D*, D;
     arity o = 2 by A14,COMPUT_1:28;
    hence (the charact of S).4 is binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S)
    by A13,COMPUT_1:def 26;
  end;
end;

theorem Th56:
  for X being disjoint_with_NAT non empty set
  for I being Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds
    (ex x being Element of X st I = root-tree x) or
    (ex n being Nat, p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X)
     st n in Seg 4 & I = n-tree p & len p = ECIW-signature.n)
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    let I be Element of FreeUnivAlgNSG(S,X) such that
A1: not ex x being Element of X st I = root-tree x;
     Terminals DTConUA(S,X) = X by FREEALG:3;
    then not ex d being Symbol of G st d in Terminals G & I = root-tree d
    by A1;
    then consider o being Symbol of G, p being FinSequence of TS G such that
A2: o ==> roots p & I = o-tree p by Th16;
A3: NonTerminals G = {s where s is Symbol of G:
    ex n being FinSequence st s ==> n} by LANG1:def 3;
then A4: o in NonTerminals G by A2;
A5: NonTerminals G = Seg 4 by Th54,FREEALG:2;
    then reconsider n = o as Element of NAT by A4;
    reconsider p as FinSequence of FreeUnivAlgNSG(ECIW-signature,X);
    take n, p;
    thus n in Seg 4 by A2,A3,A5;
    thus I = n-tree p by A2;
A6: [n, roots p] in the Rules of G by A2,LANG1:def 1;
then A7: roots p in (the carrier of G)* by ZFMISC_1:106;
     dom p = dom roots p by TREES_3:def 18;
    hence len p = Card dom roots p by PRE_CIRC:21
       .= len roots p by PRE_CIRC:21
       .= S.n by A6,A7,FREEALG:def 8;
  end;

theorem Th57:
  for X being disjoint_with_NAT non empty set
  holds EmptyIns FreeUnivAlgNSG(ECIW-signature,X) = 1-tree {}
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    reconsider s = S as non empty FinSequence of omega;
    set A = FreeUnivAlgNSG(S,X);
A1: 1 in dom the charact of A by Def10;
    reconsider f = (the charact of A).1 as nullary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def10;
A2: f = FreeOpNSG(1,S,X) by A1,FREEALG:def 12;
A3: 1 in dom S by Th54;
then A4: s/.1 = S.1 by PARTFUN1:def 8;
A5: dom FreeOpNSG(1,S,X) = (s/.1)-tuples_on TS(DTConUA(S,X))
    by A3,FREEALG:def 11
    .= {{}} by A4,Th54,COMPUT_1:8;
A6: {} in {{}} & {} = <*> TS(DTConUA(S,X)) by TARSKI:def 1;
    thus EmptyIns A = f.{} by A1,FUNCT_7:def 1
    .= Sym(1,S,X)-tree({}) by A2,A3,A5,A6,FREEALG:def 11
    .= 1-tree {} by A3,FREEALG:def 10;
  end;

theorem Th58:
  for X being disjoint_with_NAT non empty set
  for p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X)
  st 1-tree p is Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds p = {}
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let p be FinSequence of A; assume
     1-tree p is Element of A;
    then reconsider I = 1-tree p as Element of A;
    per cases by Th56;
    suppose ex x being Element of X st I = root-tree x;
      then consider x being Element of X such that
A1:   1-tree p = root-tree x;
       1-tree p = x-tree(<*>TS G) by A1,TREES_4:20;
      hence thesis by TREES_4:15;
    end;
    suppose
       ex n being Nat, p being FinSequence of A
      st n in Seg 4 & I = n-tree p & len p = S.n;
      then consider n being Nat, q being FinSequence of A such that
A2:   n in Seg 4 & I = n-tree q & len q = S.n;
       n = 1 & q = p by A2,TREES_4:15;
      hence p = {} by A2,Th54,FINSEQ_1:25;
    end;
  end;

theorem Th59:
  for X being disjoint_with_NAT non empty set
  for I1,I2 being Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds I1\;I2 = 2-tree(I1,I2)
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    reconsider s = S as non empty FinSequence of omega;
    set A = FreeUnivAlgNSG(S,X);
    let I1,I2 be Element of A;
A1: 2 in dom the charact of A by Def11;
    reconsider f = (the charact of A).2 as binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def11;
A2: f = FreeOpNSG(2,S,X) by A1,FREEALG:def 12;
A3: 2 in dom S by Th54;
then s/.2 = S.2 by PARTFUN1:def 8;
then A4: dom FreeOpNSG(2,S,X) = 2-tuples_on TS(DTConUA(S,X))
    by A3,Th54,FREEALG:def 11;
A5: <*I1,I2*> in 2-tuples_on TS(DTConUA(S,X)) by CATALG_1:10;
    thus I1\;I2 = f.<*I1,I2*> by A1,FUNCT_7:def 1
    .= Sym(2,S,X)-tree(<*I1,I2*>) by A2,A3,A4,A5,FREEALG:def 11
    .= 2-tree (I1,I2) by A3,FREEALG:def 10;
  end;

theorem Th60:
  for X being disjoint_with_NAT non empty set
  for p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X)
  st 2-tree p is Element of FreeUnivAlgNSG(ECIW-signature,X)
  ex I1,I2 being Element of FreeUnivAlgNSG(ECIW-signature,X)
  st p = <*I1,I2*>
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let p be FinSequence of A; assume
     2-tree p is Element of A;
    then reconsider I = 2-tree p as Element of A;
    per cases by Th56;
    suppose ex x being Element of X st I = root-tree x;
      then consider x being Element of X such that
A1:   2-tree p = root-tree x;
       2-tree p = x-tree(<*>TS G) by A1,TREES_4:20;
      then 2 = x by TREES_4:15;
      then X meets NAT by XBOOLE_0:3;
      hence thesis by FREEALG:def 1;
    end;
    suppose
       ex n being Nat, p being FinSequence of A
      st n in Seg 4 & I = n-tree p & len p = S.n;
      then consider n being Nat, q being FinSequence of A such that
A2:   n in Seg 4 & I = n-tree q & len q = S.n;
A3:   n = 2 & q = p by A2,TREES_4:15;
      then p = <*p.1,p.2*> by A2,Th54,FINSEQ_1:61;
      then rng p = {p.1,p.2} by FINSEQ_2:147;
      then reconsider I1 = p.1, I2 = p.2 as Element of A by ZFMISC_1:38;
      take I1,I2; thus thesis by A2,A3,Th54,FINSEQ_1:61;
    end;
  end;

theorem Th61:
  for X being disjoint_with_NAT non empty set
  for I1,I2 being Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds I1\;I2 <> I1 & I1\;I2 <> I2
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let I1,I2 be Element of A;
    set p = <*I1,I2*>;
     rng p c= FinTrees the carrier of G by XBOOLE_1:1;
then A1: p is FinSequence of FinTrees the carrier of G by FINSEQ_1:def 4;
     rng p = {I1,I2} by FINSEQ_2:147;
then A2: I1 in rng p & I2 in rng p by TARSKI:def 2;
     I1\;I2 = 2-tree(I1,I2) by Th59 .= 2-tree<*I1,I2*>;
    hence thesis by A1,A2,Th3;
  end;

theorem
   for X being disjoint_with_NAT non empty set
  for I1,I2,J1,J2 being Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds I1\;I2 = J1\;J2 implies I1 = J1 & I2 = J2
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let I1,I2,J1,J2 be Element of A;
     I1\;I2 = 2-tree(I1,I2) & J1\;J2 = 2-tree(J1,J2) by Th59;
    then I1\;I2 = J1\;J2 implies <*I1,I2*> = <*J1,J2*> by TREES_4:15;
    hence thesis by GROUP_7:2;
  end;

theorem Th63:
  for X being disjoint_with_NAT non empty set
  for C,I1,I2 being Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds if-then-else(C,I1,I2) = 3-tree<*C,I1,I2*>
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    reconsider s = S as non empty FinSequence of omega;
    set A = FreeUnivAlgNSG(S,X);
    let C,I1,I2 be Element of A;
A1: 3 in dom the charact of A by Def12;
    reconsider f = (the charact of A).3 as ternary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def12;
A2: f = FreeOpNSG(3,S,X) by A1,FREEALG:def 12;
A3: 3 in dom S by Th54;
then s/.3 = S.3 by PARTFUN1:def 8;
then A4: dom FreeOpNSG(3,S,X) = 3-tuples_on TS(DTConUA(S,X))
    by A3,Th54,FREEALG:def 11;
A5: <*C,I1,I2*> in 3-tuples_on TS(DTConUA(S,X)) by CATALG_1:12;
    thus if-then-else(C,I1,I2)
     = f.<*C,I1,I2*> by A1,FUNCT_7:def 1
    .= Sym(3,S,X)-tree(<*C,I1,I2*>) by A2,A3,A4,A5,FREEALG:def 11
    .= 3-tree <*C,I1,I2*> by A3,FREEALG:def 10;
  end;

theorem Th64:
  for X being disjoint_with_NAT non empty set
  for p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X)
  st 3-tree p is Element of FreeUnivAlgNSG(ECIW-signature,X)
  ex C,I1,I2 being Element of FreeUnivAlgNSG(ECIW-signature,X)
  st p = <*C,I1,I2*>
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let p be FinSequence of A; assume
     3-tree p is Element of A;
    then reconsider I = 3-tree p as Element of A;
    per cases by Th56;
    suppose ex x being Element of X st I = root-tree x;
      then consider x being Element of X such that
A1:   3-tree p = root-tree x;
       3-tree p = x-tree(<*>TS G) by A1,TREES_4:20;
      then 3 = x by TREES_4:15;
      then X meets NAT by XBOOLE_0:3;
      hence thesis by FREEALG:def 1;
    end;
    suppose
       ex n being Nat, p being FinSequence of A
      st n in Seg 4 & I = n-tree p & len p = S.n;
      then consider n being Nat, q being FinSequence of A such that
A2:   n in Seg 4 & I = n-tree q & len q = S.n;
A3:   n = 3 & q = p by A2,TREES_4:15;
      then p =<*p.1,p.2,p.3*> by A2,Th54,FINSEQ_1:62;
      then rng p = {p.1,p.2,p.3} by FINSEQ_2:148;
      then p.1 in {p.1,p.2,p.3} & p.2 in {p.1,p.2,p.3} & p.3 in {p.1,p.2,p.3}
&
      {p.1,p.2,p.3} c= the carrier of A by ENUMSET1:def 1;
      then reconsider C = p.1, I1 = p.2, I2 = p.3 as Element of A;
      take C,I1,I2; thus thesis by A2,A3,Th54,FINSEQ_1:62;
    end;
  end;

theorem
   for X being disjoint_with_NAT non empty set
  for C1,C2,I1,I2,J1,J2 being Element of FreeUnivAlgNSG(ECIW-signature,X)
  st if-then-else(C1,I1,I2) = if-then-else(C2,J1,J2)
  holds C1 = C2 & I1 = J1 & I2 = J2
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let C1,C2,I1,I2,J1,J2 be Element of A;
     if-then-else(C1,I1,I2) = 3-tree<*C1,I1,I2*> &
    if-then-else(C2,J1,J2) = 3-tree<*C2,J1,J2*> by Th63;
    then if-then-else(C1,I1,I2) = if-then-else(C2,J1,J2)
    implies <*C1,I1,I2*> = <*C2,J1,J2*> by TREES_4:15;
    hence thesis by GROUP_7:3;
  end;

theorem Th66:
  for X being disjoint_with_NAT non empty set
  for C,I being Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds while(C,I) = 4-tree(C,I)
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    reconsider s = S as non empty FinSequence of omega;
    set A = FreeUnivAlgNSG(S,X);
    let C,I be Element of A;
A1: 4 in dom the charact of A by Def13;
    reconsider f = (the charact of A).4 as binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by Def13;
A2: f = FreeOpNSG(4,S,X) by A1,FREEALG:def 12;
A3: 4 in dom S by Th54;
then s/.4 = S.4 by PARTFUN1:def 8;
then A4: dom FreeOpNSG(4,S,X) = 2-tuples_on TS(DTConUA(S,X))
    by A3,Th54,FREEALG:def 11;
A5: <*C,I*> in 2-tuples_on TS(DTConUA(S,X)) by CATALG_1:10;
    thus while(C,I)
     = f.<*C,I*> by A1,FUNCT_7:def 1
    .= Sym(4,S,X)-tree(<*C,I*>) by A2,A3,A4,A5,FREEALG:def 11
    .= 4-tree(C,I) by A3,FREEALG:def 10;
  end;

theorem Th67:
  for X being disjoint_with_NAT non empty set
  for p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X)
  st 4-tree p is Element of FreeUnivAlgNSG(ECIW-signature,X)
  ex C,I being Element of FreeUnivAlgNSG(ECIW-signature,X)
  st p = <*C,I*>
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let p be FinSequence of A; assume
     4-tree p is Element of A;
    then reconsider I = 4-tree p as Element of A;
    per cases by Th56;
    suppose ex x being Element of X st I = root-tree x;
      then consider x being Element of X such that
A1:   4-tree p = root-tree x;
       4-tree p = x-tree(<*>TS G) by A1,TREES_4:20;
      then 4 = x by TREES_4:15;
      then X meets NAT by XBOOLE_0:3;
      hence thesis by FREEALG:def 1;
    end;
    suppose
       ex n being Nat, p being FinSequence of A
      st n in Seg 4 & I = n-tree p & len p = S.n;
      then consider n being Nat, q being FinSequence of A such that
A2:   n in Seg 4 & I = n-tree q & len q = S.n;
A3:   n = 4 & q = p by A2,TREES_4:15;
      then p = <*p.1,p.2*> by A2,Th54,FINSEQ_1:61;
      then rng p = {p.1,p.2} by FINSEQ_2:147;
      then reconsider I1 = p.1, I2 = p.2 as Element of A by ZFMISC_1:38;
      take I1,I2; thus thesis by A2,A3,Th54,FINSEQ_1:61;
    end;
  end;

theorem Th68:
  for X being disjoint_with_NAT non empty set
  for I being Element of FreeUnivAlgNSG(ECIW-signature,X)
  st I in ElementaryInstructions FreeUnivAlgNSG(ECIW-signature,X)
  ex x being Element of X st I = x-tree {}
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S, X);
    let I be Element of FreeUnivAlgNSG(ECIW-signature,X) such that
A1: I in ElementaryInstructions FreeUnivAlgNSG(ECIW-signature,X);
    per cases by Th56;
    suppose
       ex x being Element of X st I = root-tree x;
      then consider x being Element of X such that
A2:   I = root-tree x;
       root-tree x = x-tree {} by TREES_4:20;
      hence thesis by A2;
    end;
    suppose
       ex n being Nat, p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X)
      st n in Seg 4 & I = n-tree p & len p = S.n;
      then consider n being Nat,
      p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X) such that
A3:   n in Seg 4 & I = n-tree p & len p = S.n;
      per cases by A3,ENUMSET1:def 2,FINSEQ_3:2;
      suppose
A4:     n = 1;
        then p = {} by A3,Th58;
        then I = EmptyIns A by A3,A4,Th57;
        hence thesis by A1,Th49;
      end;
      suppose
A5:     n = 2;
        then consider I1,I2 being Element of A such that
A6:     p = <*I1,I2*> by A3,Th60;
A7:     I = n-tree(I1,I2) by A3,A6 .= I1\;I2 by A5,Th59;
        then I <> I1 & I <> I2 by Th61;
        hence thesis by A1,A7,Th50;
      end;
      suppose
A8:     n = 3;
        then consider C,I1,I2 being Element of A such that
A9:     p = <*C,I1,I2*> by A3,Th64;
         I = if-then-else(C,I1,I2) by A3,A8,A9,Th63;
        hence thesis by A1,Th51;
      end;
      suppose
A10:     n = 4;
        then consider C,I' being Element of A such that
A11:     p = <*C,I'*> by A3,Th67;
         I = n-tree(C,I') by A3,A11 .= while(C,I') by A10,Th66;
        hence thesis by A1,Th52;
      end;
    end;
  end;

theorem
   for X being disjoint_with_NAT non empty set
  for p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X)
  for x being Element of X
  st x-tree p is Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds p = {}
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S, X);
    let p be FinSequence of FreeUnivAlgNSG(ECIW-signature,X);
    let x be Element of X;
    assume x-tree p is Element of FreeUnivAlgNSG(ECIW-signature,X);
    then reconsider I = x-tree p as Element of A;
     now given n being Nat, p being FinSequence of A such that
A1:   n in Seg 4 & I = n-tree p & len p = ECIW-signature.n;
       x = n & X misses NAT & n in NAT by A1,FREEALG:def 1,TREES_4:15;
      hence contradiction by XBOOLE_0:3;
    end;
    then consider y being Element of X such that
A2: I = root-tree y by Th56;
     x-tree p = y-tree {} & {} is DTree-yielding by A2,TREES_3:23,TREES_4:20;
    hence p = {} by TREES_4:15;
  end;

theorem Th70:
  for X being disjoint_with_NAT non empty set
  holds ElementaryInstructions FreeUnivAlgNSG(ECIW-signature,X) =
  FreeGenSetNSG(ECIW-signature,X) &
  Card X = Card FreeGenSetNSG(ECIW-signature,X)
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
A1: X = Terminals G by FREEALG:3;
    set A = FreeUnivAlgNSG(S, X);
    thus ElementaryInstructions A = FreeGenSetNSG(S, X)
    proof
      thus ElementaryInstructions A c= FreeGenSetNSG(S, X)
      proof
        let x be set;
        assume x in ElementaryInstructions A;
        then consider y being Element of X such that
A2:     x = y-tree {} by Th68;
        reconsider y as Symbol of G by XBOOLE_0:def 2;
         x = root-tree y  by A2,TREES_4:20;
        hence thesis by A1;
      end;
      let x be set; assume
A3:   x in FreeGenSetNSG(S,X);
      then reconsider I = x as Element of A;
      consider y being Symbol of G such that
A4:   x = root-tree y & y in Terminals G by A3;
A5:   x = y-tree {} & {} is DTree-yielding by A4,TREES_3:23,TREES_4:20;
      assume
A6:   x nin ElementaryInstructions A;
      per cases by A6,Th53;
      suppose I = EmptyIns A;
        then x = 1-tree {} by Th57;
        then y = 1 & X misses NAT by A5,FREEALG:def 1,TREES_4:15;
        hence thesis by A1,A4,XBOOLE_0:3;
      end;
      suppose ex I1,I2 being Element of A st
        I = I1\;I2 & I1 <> I1\;I2 & I2 <> I1\;I2;
        then consider I1,I2 be Element of A such that
A7:     I = I1\;I2;
         x = 2-tree(I1,I2) by A7,Th59 .= 2-tree<*I1,I2*>;
        hence thesis by A5,TREES_4:15;
      end;
      suppose ex C,I1,I2 being Element of A st I = if-then-else(C,I1,I2);
        then consider C,I1,I2 be Element of A such that
A8:     I = if-then-else(C,I1,I2);
         x = 3-tree<*C,I1,I2*> by A8,Th63;
        hence thesis by A5,TREES_4:15;
      end;
      suppose ex C,J being Element of A st I = while(C,J);
        then consider C,J be Element of A such that
A9:     I = while(C,J);
         x = 4-tree(C,J) by A9,Th66 .= 4-tree<*C,J*>;
        hence thesis by A5,TREES_4:15;
      end;
    end;
    deffunc F(set) = root-tree $1;
    consider f being Function such that
A10: dom f = X & for x being Element of X holds f.x = F(x) from FUNCT_1:sch 4;
A11: rng f = FreeGenSetNSG(S,X)
    proof
      thus rng f c= FreeGenSetNSG(S,X)
      proof let a be set;
        assume a in rng f;
        then consider x being set such that
A12:     x in X & a = f.x by A10,FUNCT_1:def 5;
        reconsider s = x as Symbol of G by A12,XBOOLE_0:def 2;
         s in X & a = F(x) by A10,A12;
        hence thesis by A1;
      end;
      let a be set; assume a in FreeGenSetNSG(S,X);
      then consider s being Symbol of G such that
A13:   a = root-tree s & s in X by A1;
      reconsider s as Element of X by A13;
       f.s = a by A10,A13;
      hence thesis by A10,FUNCT_1:def 5;
    end;
     f is one-to-one
    proof
      let a,b be set;
      assume a in dom f & b in dom f;
      then reconsider x = a, y = b as Element of X by A10;
      assume f.a = f.b;
      then F(x) = f.b by A10 .= F(y) by A10;
      hence thesis by TREES_4:4;
    end;
    then X, FreeGenSetNSG(S,X) are_equipotent by A10,A11,WELLORD2:def 4;
    hence Card X = Card FreeGenSetNSG(S,X) by CARD_1:21;
  end;

registration
  cluster infinite disjoint_with_NAT set;
  existence
  proof take X = [:NAT,{0}:];
     Card X = Card NAT by CARD_2:13;
    then Card X nin NAT by CARD_1:84;
    hence X is infinite by CARD_4:3;
     now let x be set; assume x in X;
      then consider a,b being set such that
A1:   a in NAT & b in {0} & x = [a,b] by ZFMISC_1:def 2;
      assume x in NAT;
      then x is Element of NAT & [a,b] is pair;
      hence contradiction by A1;
    end;
    hence X misses NAT by XBOOLE_0:3;
  end;
end;

registration
  let X be infinite disjoint_with_NAT set;
  cluster FreeUnivAlgNSG(ECIW-signature,X) -> infinite;
  coherence
  proof
     ElementaryInstructions FreeUnivAlgNSG(ECIW-signature,X) =
    FreeGenSetNSG(ECIW-signature,X) &
    Card X = Card FreeGenSetNSG(ECIW-signature,X) by Th70;
    then Card ElementaryInstructions FreeUnivAlgNSG(ECIW-signature,X) is
infinite
    by CARD_4:1;
    hence ElementaryInstructions FreeUnivAlgNSG(ECIW-signature,X) is infinite
    by CARD_4:1;
  end;
end;

registration
  let X be disjoint_with_NAT non empty set;
  cluster FreeUnivAlgNSG(ECIW-signature,X) -> ECIW-strict;
  coherence
  proof
    thus signature FreeUnivAlgNSG(ECIW-signature,X) = ECIW-signature
    by FREEALG:4;
  end;
end;

theorem Th71:
  for A being preIfWhileAlgebra
  holds Generators A c= ElementaryInstructions A
  proof
    let A be preIfWhileAlgebra;
    let x be set; assume
A1: x in Generators A & x nin ElementaryInstructions A;
    then reconsider x as Element of A;
     dom Den(In(1, dom the charact of A), A) = {{}} by Th42;
then A2: {} in dom Den(In(1, dom the charact of A),A) by TARSKI:def 1;
    per cases by A1,Th53;
    suppose x = EmptyIns A;
      then x in rng Den(In(1, dom the charact of A), A) by A2,FUNCT_1:12;
      hence contradiction by A1,Th26;
    end;
    suppose
       ex I1,I2 being Element of A st x = I1\;I2 & I1 <> I1\;I2 & I2 <> I1\;I2;
      then consider I1,I2 being Element of A such that
A3:   x = I1\;I2 & I1 <> I1\;I2 & I2 <> I1\;I2;
       dom Den(In(2, dom the charact of A), A) = 2-tuples_on the carrier of A
      by Th44;
      then <*I1,I2*> in dom Den(In(2, dom the charact of A),A) by CATALG_1:10;
      then x in rng Den(In(2, dom the charact of A),A) by A3,FUNCT_1:12;
      hence contradiction by A1,Th26;
    end;
    suppose
       ex C,I1,I2 being Element of A st x = if-then-else(C,I1,I2);
      then consider C,I1,I2 being Element of A such that
A4:   x = if-then-else(C,I1,I2);
       dom Den(In(3, dom the charact of A), A) = 3-tuples_on the carrier of A
      by Th47;
      then <*C,I1,I2*> in dom Den(In(3, dom the charact of A),A)
      by CATALG_1:12;
      then x in rng Den(In(3, dom the charact of A),A) by A4,FUNCT_1:12;
      hence contradiction by A1,Th26;
    end;
    suppose
       ex C,J being Element of A st x = while(C,J);
      then consider C,J being Element of A such that
A5:   x = while(C,J);
       dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A
      by Th48;
      then <*C,J*> in dom Den(In(4, dom the charact of A),A) by CATALG_1:10;
      then x in rng Den(In(4, dom the charact of A),A) by A5,FUNCT_1:12;
      hence contradiction by A1,Th26;
    end;
  end;

theorem Th72:
  for A being preIfWhileAlgebra st A is free
  for C,I1,I2 being Element of A
  holds EmptyIns A <> I1\;I2 & EmptyIns A <> if-then-else(C,I1,I2) &
  EmptyIns A <> while(C,I1)
  proof
    let A be preIfWhileAlgebra such that
A1: A is free;
    let C,I1,I2 be Element of A;
     1 in dom the charact of A by Def10;
then A2: dom Den(In(1, dom the charact of A), A) = {{}} &
    In(1, dom the charact of A) = 1 by Th42,FUNCT_7:def 1;
     2 in dom the charact of A by Def11;
then A3: dom Den(In(2, dom the charact of A), A) = 2-tuples_on the carrier of A
&
    In(2, dom the charact of A) = 2 by Th44,FUNCT_7:def 1;
     3 in dom the charact of A by Def12;
then A4: dom Den(In(3, dom the charact of A), A) = 3-tuples_on the carrier of A
&
    In(3, dom the charact of A) = 3 by Th47,FUNCT_7:def 1;
     4 in dom the charact of A by Def13;
then A5: dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A
&
    In(4, dom the charact of A) = 4 by Th48,FUNCT_7:def 1;
A6: {} in {{}} by TARSKI:def 1;
     <*I1,I2*> in 2-tuples_on the carrier of A by CATALG_1:10;
    hence EmptyIns A <> I1\;I2 by A1,A2,A3,A6,Th36;
     <*C,I1,I2*> in 3-tuples_on the carrier of A by CATALG_1:12;
    hence EmptyIns A <> if-then-else(C,I1,I2) by A1,A2,A4,A6,Th36;
     <*C,I1*> in 2-tuples_on the carrier of A by CATALG_1:10;
    hence EmptyIns A <> while(C,I1) by A1,A2,A5,A6,Th36;
  end;

theorem Th73:
  for A being preIfWhileAlgebra st A is free
  for I1,I2,C,J1,J2 being Element of A
  holds I1\;I2 <> I1 & I1\;I2 <> I2 &
  (I1\;I2 = J1\;J2 implies I1 = J1 & I2 = J2) &
  I1\;I2 <> if-then-else(C,J1,J2) & I1\;I2 <> while(C,J1)
  proof
    let A be preIfWhileAlgebra such that
A1: A is free;
    let I1,I2,C,J1,J2 be Element of A;
     2 in dom the charact of A by Def11;
then A2: dom Den(In(2, dom the charact of A), A) = 2-tuples_on the carrier of A
&
    In(2, dom the charact of A) = 2 by Th44,FUNCT_7:def 1;
     3 in dom the charact of A by Def12;
then A3: dom Den(In(3, dom the charact of A), A) = 3-tuples_on the carrier of A
&
    In(3, dom the charact of A) = 3 by Th47,FUNCT_7:def 1;
     4 in dom the charact of A by Def13;
then A4: dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A
&
    In(4, dom the charact of A) = 4 by Th48,FUNCT_7:def 1;
A5: <*I1,I2*> in 2-tuples_on the carrier of A &
    <*J1,J2*> in 2-tuples_on the carrier of A by CATALG_1:10;
     rng <*I1,I2*> = {I1,I2} by FINSEQ_2:147;
    then I1 in rng <*I1,I2*> & I2 in rng <*I1,I2*> by TARSKI:def 2;
    hence I1\;I2 <> I1 & I1\;I2 <> I2 by A1,A2,A5,Th38;
    hereby
      assume I1\;I2 = J1\;J2;
      then <*I1,I2*> = <*J1,J2*> by A1,A2,A5,Th36;
      hence I1 = J1 & I2 = J2 by GROUP_7:2;
    end;
     <*C,J1,J2*> in 3-tuples_on the carrier of A by CATALG_1:12;
    hence I1\;I2 <> if-then-else(C,J1,J2) by A1,A2,A3,A5,Th36;
     <*C,J1*> in 2-tuples_on the carrier of A by CATALG_1:10;
    hence I1\;I2 <> while(C,J1) by A1,A2,A4,A5,Th36;
  end;

theorem Th74:
  for A being preIfWhileAlgebra st A is free
  for C,I1,I2,D,J1,J2 being Element of A
  holds if-then-else(C,I1,I2) <> C & if-then-else(C,I1,I2) <> I1 &
  if-then-else(C,I1,I2) <> I2 & if-then-else(C,I1,I2) <> while(D,J1) &
  (if-then-else(C,I1,I2) = if-then-else(D,J1,J2) implies C=D & I1=J1 & I2=J2)
  proof
    let A be preIfWhileAlgebra such that
A1: A is free;
    let C,I1,I2,D,J1,J2 be Element of A;
     3 in dom the charact of A by Def12;
then A2: dom Den(In(3, dom the charact of A), A) = 3-tuples_on the carrier of A
&
    In(3, dom the charact of A) = 3 by Th47,FUNCT_7:def 1;
     4 in dom the charact of A by Def13;
then A3: dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A
&
    In(4, dom the charact of A) = 4 by Th48,FUNCT_7:def 1;
A4: <*C,I1,I2*> in 3-tuples_on the carrier of A &
    <*D,J1,J2*> in 3-tuples_on the carrier of A by CATALG_1:12;
     rng <*C,I1,I2*> = {C,I1,I2} by FINSEQ_2:148;
    then C in rng <*C,I1,I2*> & I1 in rng <*C,I1,I2*> & I2 in rng <*C,I1,I2*>
    by ENUMSET1:def 1;
    hence if-then-else(C,I1,I2) <> C & if-then-else(C,I1,I2) <> I1 &
    if-then-else(C,I1,I2) <> I2 by A1,A2,A4,Th38;
     <*D,J1*> in 2-tuples_on the carrier of A by CATALG_1:10;
    hence if-then-else(C,I1,I2) <> while(D,J1) by A1,A2,A3,A4,Th36;
    assume if-then-else(C,I1,I2) = if-then-else(D,J1,J2);
    then <*C,I1,I2*> = <*D,J1,J2*> by A1,A2,A4,Th36;
    hence thesis by GROUP_7:3;
  end;

theorem Th75:
  for A being preIfWhileAlgebra st A is  free
  for C,I,D,J being Element of A
  holds while(C,I) <> C & while(C,I) <> I &
  (while(C,I) = while(D,J) implies C = D & I = J)
  proof
    let A be preIfWhileAlgebra such that
A1: A is free;
    let C,I,D,J be Element of A;
     4 in dom the charact of A by Def13;
then A2: dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A
&
    In(4, dom the charact of A) = 4 by Th48,FUNCT_7:def 1;
A3: <*C,I*> in 2-tuples_on the carrier of A &
    <*D,J*> in 2-tuples_on the carrier of A by CATALG_1:10;
     rng <*C,I*> = {C,I} by FINSEQ_2:147;
    then C in rng <*C,I*> & I in rng <*C,I*> by TARSKI:def 2;
    hence while(C,I) <> C & while(C,I) <> I by A1,A2,A3,Th38;
    assume while(C,I) = while(D,J);
    then <*C,I*> = <*D,J*> by A1,A2,A3,Th36;
    hence thesis by GROUP_7:2;
  end;

registration
  cluster free -> well_founded non degenerated preIfWhileAlgebra;
  coherence
  proof
    let A be preIfWhileAlgebra; assume
A1: A is free; then reconsider A' = A as free Universal_Algebra;
    consider G being free GeneratorSet of A';
A2: Generators A = G by Th34;
     Generators A c= ElementaryInstructions A by Th71;
    hence ElementaryInstructions A is GeneratorSet of A by A2,Th31;
    thus not ex I1,I2 be Element of A st I1 <> EmptyIns A & I1\;I2 = I2 or
    I2 <> EmptyIns A & I1\;I2 = I1 or
    (I1 <> EmptyIns A or I2 <> EmptyIns A) & I1\;I2 = EmptyIns A
    by A1,Th72,Th73;
    thus thesis by A1,Th72,Th73,Th74;
  end;
end;

registration
  cluster infinite non degenerated well_founded ECIW-strict free
  strict preIfWhileAlgebra;
  existence
  proof
    consider X being infinite disjoint_with_NAT set;
    take S = FreeUnivAlgNSG(ECIW-signature,X);
    thus thesis;
  end;
end;

definition
  mode IfWhileAlgebra is
  non degenerated well_founded ECIW-strict preIfWhileAlgebra;
end;

registration
  let A be infinite preIfWhileAlgebra;
  cluster ElementaryInstructions A -> infinite;
  coherence by Def23;
end;

theorem Th76:
  for A being preIfWhileAlgebra
  for B being Subset of A
  for n being Nat holds
  EmptyIns A in B|^(n+1) &
  for C,I1,I2 being Element of A
  st C in B|^n & I1 in B|^n & I2 in B|^n
  holds I1\;I2 in B|^(n+1) & if-then-else(C,I1,I2) in B|^(n+1) &
  while(C,I1) in B|^(n+1)
  proof
    let A be preIfWhileAlgebra;
    let B be Subset of A;
    let n be Nat;
    set X = {Den(o,A).p where o is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B|^n};
A1: B|^(n+1) = B|^n \/ X by Th19;
    reconsider pe = <*>the carrier of A as Element of (the carrier of A)*
    by FINSEQ_1:def 11;
     pe in {{}} & rng pe = {} & dom Den(In(1, dom the charact of A), A) = {{}}
&
    {} c= B|^n by Th42,RELAT_1:60,TARSKI:def 1,XBOOLE_1:2;
    then EmptyIns A in X;
    hence EmptyIns A in B|^(n+1) by A1,XBOOLE_0:def 2;
    let C,I1,I2 be Element of A;
    assume
A2: C in B|^n;
    assume
A3: I1 in B|^n;
    assume
A4: I2 in B|^n;
    then <*I1,I2*> in 2-tuples_on the carrier of A &
    rng <*I1,I2*> = {I1,I2} &
    dom Den(In(2, dom the charact of A), A) = 2-tuples_on the carrier of A &
    {I1,I2} c= B|^n by A3,Th44,CATALG_1:10,FINSEQ_2:147,ZFMISC_1:38;
    then I1\;I2 in X;
    hence I1\;I2 in B|^(n+1) by A1,XBOOLE_0:def 2;
     <*C,I1,I2*> in 3-tuples_on the carrier of A &
    rng <*C,I1,I2*> = {C,I1,I2} &
    dom Den(In(3, dom the charact of A), A) = 3-tuples_on the carrier of A &
    {C,I1,I2} c= B|^n
    by A2,A3,A4,Th47,CATALG_1:12,FINSEQ_2:148,JORDAN16:2;
    then if-then-else(C,I1,I2) in X;
    hence if-then-else(C,I1,I2) in B|^(n+1) by A1,XBOOLE_0:def 2;
     <*C,I1*> in 2-tuples_on the carrier of A &
    rng <*C,I1*> = {C,I1} &
    dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A &
    {C,I1} c= B|^n by A2,A3,Th48,CATALG_1:10,FINSEQ_2:147,ZFMISC_1:38;
    then while(C,I1) in X;
    hence while(C,I1) in B|^(n+1) by A1,XBOOLE_0:def 2;
  end;

theorem Th77:
  for A being ECIW-strict preIfWhileAlgebra
  for x being set, n being Nat st x in (ElementaryInstructions A)|^(n+1)
  holds x in (ElementaryInstructions A)|^n or x = EmptyIns A or
  (ex I1,I2 being Element of A st x = I1\;I2 &
  I1 in (ElementaryInstructions A)|^n & I2 in (ElementaryInstructions A)|^n) or
  (ex C,I1,I2 being Element of A st x = if-then-else(C,I1,I2) &
  C in (ElementaryInstructions A)|^n &
  I1 in (ElementaryInstructions A)|^n & I2 in (ElementaryInstructions A)|^n) or
  (ex C,I being Element of A st x = while(C,I) &
  C in (ElementaryInstructions A)|^n & I in (ElementaryInstructions A)|^n)
  proof
    let A be ECIW-strict preIfWhileAlgebra;
    set B = ElementaryInstructions A;
    let x be set;
    let n be Nat;
    assume
A1: x in B|^(n+1);
    then reconsider I = x as Element of A;
    assume
A2: x nin B|^n;
    assume
A3: x <> EmptyIns A;
    assume
A4: not ex I1,I2 being Element of A st x = I1\;I2 & I1 in B|^n & I2 in B|^n;
    assume
A5: not ex C,I1,I2 being Element of A st x = if-then-else(C,I1,I2) &
    C in B|^n & I1 in B|^n & I2 in B|^n;
     B|^(n+1) = B|^n\/{Den(o,A).p where o is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B|^n}
    by Th19;
    then x in {Den(o,A).p where o is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B|^n}
    by A1,A2,XBOOLE_0:def 2;
    then consider o being (Element of dom the charact of A),
    p being Element of (the carrier of A)* such that
A6: I = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^n;
    reconsider no = o as Element of NAT;
    reconsider oo = Den(o,A) as Element of Operations A;
     len signature A = len the charact of A by UNIALG_1:def 11;
then A7: dom signature A = dom the charact of A by FINSEQ_3:31;
A8: len p = arity oo by A6,UNIALG_1:def 10
    .= (signature A).no by A7,UNIALG_1:def 11
    .= ECIW-signature.o by Def27;
A9: In(o,dom the charact of A) = o by FUNCT_7:def 1;
A10: 1 in Seg 2 & 2 in Seg 2 & 1 in Seg 3 & 2 in Seg 3 & 3 in Seg 3;
    per cases by Th55;
    suppose  o = 1;
      hence thesis by A3,A6,A8,A9,Th54,FINSEQ_1:25;
    end;
    suppose
A11:   o = 2;
then A12:   p = <*p.1,p.2*> & dom p = Seg 2 by A8,Th54,FINSEQ_1:61,def 3;
then A13:   p.1 in rng p & p.2 in rng p by A10,FUNCT_1:def 5;
      then reconsider I1 = p.1, I2 = p.2 as Element of A;
       I = I1\;I2 by A6,A11,A12,FUNCT_7:def 1;
      hence thesis by A4,A6,A13;
    end;
    suppose
A14:   o = 3;
then A15:   p = <*p.1,p.2,p.3*> & dom p = Seg 3 by A8,Th54,FINSEQ_1:62,def 3;
then A16:   p.1 in rng p & p.2 in rng p & p.3 in rng p by A10,FUNCT_1:def 5;
      then reconsider C = p.1, I1 = p.2, I2 = p.3 as Element of A;
       I = if-then-else(C,I1,I2) by A6,A14,A15,FUNCT_7:def 1;
      hence thesis by A5,A6,A16;
    end;
    suppose
A17:   o = 4;
then A18:   p = <*p.1,p.2*> & dom p = Seg 2 by A8,Th54,FINSEQ_1:61,def 3;
then A19:   p.1 in rng p & p.2 in rng p by A10,FUNCT_1:def 5;
      then reconsider I1 = p.1, I2 = p.2 as Element of A;
       I = while(I1,I2) by A6,A17,A18,FUNCT_7:def 1;
      hence thesis by A6,A19;
    end;
  end;

theorem
   for A being Universal_Algebra
  for B being Subset of A
  holds Constants A c= B|^1
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    let x be set; assume x in Constants A;
    then consider a being Element of A such that
A1: x = a & ex o being Element of Operations A st arity o = 0 & a in rng o;
    consider o being Element of Operations A such that
A2: arity o = 0 & a in rng o by A1;
    consider s being set such that
A3: s in dom o & a = o.s by A2,FUNCT_1:def 5;
    consider z being set such that
A4: z in dom the charact of A & o = (the charact of A).z by FUNCT_1:def 5;
    reconsider z as Element of dom the charact of A by A4;
A5: Den(z,A) = o by A4;
A6: s is Element of 0-tuples_on the carrier of A by A2,A3,UNIALG_2:2;
    reconsider s as Element of (the carrier of A)* by A3;
     len s = 0 by A6,FINSEQ_2:109;
    then s = {} by FINSEQ_1:25;
    then rng s c= B by RELAT_1:60,XBOOLE_1:2;
then A7: x in {Den(r,A).p where r is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(r,A) & rng p c= B}
    by A1,A3,A5;
     B|^0 = B by Th18;
    then B|^(0+1) = B \/ {Den(r,A).p where r is (Element of dom the charact of
A),
    p is Element of (the carrier of A)*: p in dom Den(r,A) & rng p c= B}
    by Th19;
    hence x in B|^1 by A7,XBOOLE_0:def 2;
  end;

theorem Th79:
  for A being preIfWhileAlgebra
  holds A is well_founded iff
  for I being Element of A ex n being Nat st I in (ElementaryInstructions A)|^n
  proof
    let A be preIfWhileAlgebra;
    set B = ElementaryInstructions A;
     A is well_founded iff B is GeneratorSet of A by Def25;
    hence thesis by Th30;
  end;

scheme StructInd{
    A() -> well_founded ECIW-strict preIfWhileAlgebra,
    I() -> (Element of A()),
    P[set]
  }:
  P[I()]
  provided
A1: for I being Element of A() st I in ElementaryInstructions A()
    holds P[I] and
A2: P[EmptyIns A()] and
A3: for I1,I2 being Element of A() st P[I1] & P[I2] holds P[I1\;I2] and
A4: for C,I1,I2 being Element of A() st P[C] & P[I1] & P[I2]
    holds P[if-then-else(C,I1,I2)] and
A5: for C,I being Element of A() st P[C] & P[I] holds P[while(C,I)]
  proof set A = A();
    consider n being Nat such that
A6: I() in (ElementaryInstructions A())|^n by Th79;
    defpred Q[Nat] means for I being Element of A()
    st I in (ElementaryInstructions A())|^$1 holds P[I];
     (ElementaryInstructions A())|^0 = ElementaryInstructions A() by Th18;
then A7: Q[0] by A1;
A8: now let n be Nat; assume
A9:   Q[n];
      thus Q[n+1]
      proof
        let I be Element of A(); assume
A10:     I in (ElementaryInstructions A())|^(n+1);
        per cases by A10,Th77;
        suppose I in (ElementaryInstructions A)|^n;
          hence P[I] by A9;
        end;
        suppose I = EmptyIns A;
          hence P[I] by A2;
        end;
        suppose ex I1,I2 being Element of A st I = I1\;I2 &
          I1 in (ElementaryInstructions A)|^n &
          I2 in (ElementaryInstructions A)|^n;
          then consider I1,I2 being Element of A such that
A11:       I = I1\;I2 & I1 in (ElementaryInstructions A)|^n &
          I2 in (ElementaryInstructions A)|^n;
           P[I1] & P[I2] by A9,A11;
          hence P[I] by A3,A11;
        end;
        suppose ex C,I1,I2 being Element of A st I = if-then-else(C,I1,I2) &
          C in (ElementaryInstructions A)|^n &
          I1 in (ElementaryInstructions A)|^n &
          I2 in (ElementaryInstructions A)|^n;
          then consider C,I1,I2 being Element of A such that
A12:       I = if-then-else(C,I1,I2) &
          C in (ElementaryInstructions A)|^n &
          I1 in (ElementaryInstructions A)|^n &
          I2 in (ElementaryInstructions A)|^n;
           P[C] & P[I1] & P[I2] by A9,A12;
          hence P[I] by A4,A12;
        end;
        suppose ex C,J being Element of A st I = while(C,J) &
          C in (ElementaryInstructions A)|^n &
          J in (ElementaryInstructions A)|^n;
          then consider C,J being Element of A such that
A13:       I = while(C,J) &
          C in (ElementaryInstructions A)|^n &
          J in (ElementaryInstructions A)|^n;
           P[C] & P[J] by A9,A13;
          hence P[I] by A5,A13;
        end;
      end;
    end;
     for n being Nat holds Q[n] from NAT_1:sch 2(A7,A8);
    hence thesis by A6;
  end;

begin :: Execution function

definition
  let A be preIfWhileAlgebra;
  let S be non empty set; :: states
  let f be Function of [:S, the carrier of A:], S;
  attr f is satisfying_empty-instruction means:
Def28:
  for s being Element of S holds f.(s, EmptyIns A) = s;

  attr f is satisfying_catenation means:
Def29:
  for s being Element of S
  for I1,I2 being Element of A holds
  f.(s,I1 \; I2) = f.(f.(s,I1),I2);
end;

definition
  let A be preIfWhileAlgebra;
  let S be non empty set; :: states
  let T be Subset of S;   :: true states
  let f be Function of [:S, the carrier of A:], S;
  pred f satisfies_if_wrt T means:
Def30:
  for s being Element of S for C, I1,I2 being Element of A holds
  (f.(s,C) in T implies f.(s,if-then-else(C,I1,I2)) = f.(f.(s,C),I1)) &
  (f.(s,C) nin T implies f.(s,if-then-else(C,I1,I2)) = f.(f.(s,C),I2));

  pred f satisfies_while_wrt T means:
Def31:
  for s being Element of S for C, I being Element of A holds
  (f.(s,C) in T implies f.(s,while(C,I)) = f.(f.(f.(s,C),I),while(C,I))) &
  (f.(s,C) nin T implies f.(s,while(C,I)) = f.(s,C));
end;

theorem
   for f being Function of [:S, the carrier of A:], S
  st f is satisfying_empty-instruction & f satisfies_if_wrt T
  for s being Element of S holds
  f.(s,C) nin T implies f.(s,if-then(C,I)) = f.(s,C)
  proof let f be Function of [:S, the carrier of A:], S such that
A1: f is satisfying_empty-instruction and
A2: f satisfies_if_wrt T;
    let s be Element of S;
    assume f.(s,C) nin T;
    hence f.(s,if-then(C,I)) = f.(f.(s,C),EmptyIns A) by A2,Def30
    .= f.(s,C) by A1,Def28;
  end;

theorem Th81:
  pr1(S, the carrier of A) is satisfying_empty-instruction &
  pr1(S, the carrier of A) is satisfying_catenation &
  pr1(S, the carrier of A) satisfies_if_wrt T &
  pr1(S, the carrier of A) satisfies_while_wrt T
  proof
    set f = pr1(S, the carrier of A);
    thus for s being Element of S holds f.(s, EmptyIns A) = s by FUNCT_3:def 5
;
    hereby let s be Element of S;
      let I1,I2 be Element of A;
      thus f.(s,I1 \; I2) = s by FUNCT_3:def 5
      .= f.(s,I1) by FUNCT_3:def 5 .= f.(f.(s,I1),I2) by FUNCT_3:def 5;
    end;
    hereby let s be Element of S;
      let C, I1,I2 be Element of A;
       f.(s,if-then-else(C,I1,I2)) = s by FUNCT_3:def 5
      .= f.(s,C) by FUNCT_3:def 5;
      hence (f.(s,C) in T implies f.(s,if-then-else(C,I1,I2)) = f.(f.(s,C),I1))
      & (f.(s,C) nin T implies f.(s,if-then-else(C,I1,I2)) = f.(f.(s,C),I2))
      by FUNCT_3:def 5;
    end;
    let s be Element of S;
    let C, I be Element of A;
     f.(s,while(C,I)) = s & f.(s,C) = s & f.(s,I) = s by FUNCT_3:def 5;
    hence thesis;
  end;

definition
  let A be preIfWhileAlgebra;
  let S be non empty set; :: states
  let T be Subset of S;   :: true states
  mode ExecutionFunction of A,S,T -> Function of [:S, the carrier of A:], S
  means:
Def32:
  it is satisfying_empty-instruction &
  it is satisfying_catenation &
  it satisfies_if_wrt T &
  it satisfies_while_wrt T;
  existence
  proof
    take f = pr1(S, the carrier of A);
    thus thesis by Th81;
  end;
end;

registration
  let A be preIfWhileAlgebra;
  let S be non empty set; :: states
  let T be Subset of S;   :: true states
  cluster -> satisfying_empty-instruction satisfying_catenation
  ExecutionFunction of A,S,T;
  coherence by Def32;
end;

definition
  let A be preIfWhileAlgebra;
  let I be Element of A;
  let S be non empty set; :: states
  let s be Element of S;
  let T be Subset of S;   :: true states
  let f be ExecutionFunction of A, S, T;
:: iteration of I started in s terminates wrt f
  pred f iteration_terminates_for I,s means:
Def33:
  ex r being non empty FinSequence of S st r.1 = s & r.len r nin T &
  for i being Nat st 1 <= i & i < len r
  holds r.i in T & r.(i+1) = f.(r.i, I);
end;

definition
  let A be preIfWhileAlgebra;
  let I be Element of A;
  let S be non empty set; :: states
  let s be Element of S;
  let T be Subset of S;   :: true states
  let f be ExecutionFunction of A, S, T;
  func iteration-degree(I,s,f) -> R_eal means:
Def34:
  ex r being non empty FinSequence of S st
  it = (len r)-1 & r.1 = s & r.len r nin T &
  for i being Nat st 1 <= i & i < len r holds r.i in T & r.(i+1) = f.(r.i, I)
  if f iteration_terminates_for I,s
  otherwise it = +infty;
  correctness
  proof
A1: now assume f iteration_terminates_for I,s;
      then consider r being non empty FinSequence of S such that
A2:   r.1 = s & r.len r nin T & for i being Nat st 1 <= i & i < len r
      holds r.i in T & r.(i+1) = f.(r.i, I) by Def33;
      reconsider x = (len r)-1 as R_eal by XXREAL_0:def 1;
      take x, r;
      thus x = (len r)-1 & r.1 = s & r.len r nin T &
      for i being Nat st 1 <= i & i < len r
      holds r.i in T & r.(i+1) = f.(r.i, I) by A2;
    end;
     now let d1, d2 be R_eal;
      given r1 being non empty FinSequence of S such that
A3:   d1 = (len r1)-1 & r1.1 = s & r1.len r1 nin T &
      for i being Nat st 1 <= i & i < len r1 holds
      r1.i in T & r1.(i+1) = f.(r1.i, I);
      given r2 being non empty FinSequence of S such that
A4:   d2 = (len r2)-1 & r2.1 = s & r2.len r2 nin T &
      for i being Nat st 1 <= i & i < len r2 holds
      r2.i in T & r2.(i+1) = f.(r2.i, I);
      defpred P[Nat] means
      $1 < len r1 implies $1 < len r2 & r1.($1+1) = r2.($1+1);
       len r2 <> 0 by FINSEQ_1:25;
then A5:   P[0] by A3,A4;
A6:   now let i be Element of NAT; assume
A7:     P[i];
        thus P[i+1]
        proof assume
A8:       i+1 < len r1;
A9:       1 <= i+1 by NAT_1:11;
then A10:       r1.(i+1+1) = f.(r1.(i+1), I) & r1.(i+1) in T & i+1 <= len r2
          by A3,A7,A8,NAT_1:13;
          hence i+1 < len r2 by A4,A7,A8,NAT_1:13,XXREAL_0:1;
          hence r1.(i+1+1) = r2.(i+1+1) by A4,A7,A8,A9,A10,NAT_1:13;
        end;
      end;
A11:   for i being Element of NAT holds P[i] from NAT_1:sch 1(A5,A6);
       len r1 <> 0 by FINSEQ_1:25;
      then consider i being Nat such that
A12:   len r1 = i+1 by NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
       i < len r1 by A12,NAT_1:13;
      then i < len r2 & r1.len r1 = r2.len r1 & 1 <= len r1 by A11,A12,NAT_1:11
;
      then len r1 <= len r2 & len r2 <= len r1 by A3,A4,A12,NAT_1:13;
      hence d1 = d2 by A3,A4,XXREAL_0:1;
    end;
    hence thesis by A1;
  end;
end;

reserve f for ExecutionFunction of A,S,T;

theorem
   f iteration_terminates_for I,s iff iteration-degree(I,s,f) < +infty
  proof
    hereby assume f iteration_terminates_for I,s;
      then consider r being non empty FinSequence of S such that
A1:   iteration-degree(I,s,f) = (len r)-1 & r.1 = s & r.len r nin T &
      for i being Nat st 1 <= i & i < len r
      holds r.i in T & r.(i+1) = f.(r.i, I) by Def34;
       (len r)-1 in REAL by XREAL_0:def 1;
      hence iteration-degree(I,s,f) < +infty by A1,XXREAL_0:9;
   end;
    thus thesis by Def34;
  end;

theorem Th83:
  s nin T implies f iteration_terminates_for I,s & iteration-degree(I,s,f) = 0
  proof assume
A1: s nin T;
    set r = <*s*>;
A2:   r.1 = s & len r = 1 by FINSEQ_1:57;
A3:   for i being Nat st 1 <= i & i < len r
      holds r.i in T & r.(i+1) = f.(r.i, I) by FINSEQ_1:57;
A4: 1-1 = 0.;
    thus f iteration_terminates_for I,s
    proof
      take r = <*s*>; thus thesis by A1,A2;
    end;
    hence thesis by A1,A2,A3,A4,Def34;
  end;

theorem
   s in T implies
  (f iteration_terminates_for I,s iff f iteration_terminates_for I, f.(s,I)) &
  iteration-degree(I,s,f) = 1.+iteration-degree(I,f.(s,I),f)
  proof assume
A1: s in T;
    thus
A2: f iteration_terminates_for I,s iff f iteration_terminates_for I, f.(s,I)
    proof
      thus f iteration_terminates_for I,s implies
      f iteration_terminates_for I, f.(s,I)
      proof given r being non empty FinSequence of S such that
A3:     r.1 = s & r.len r nin T and
A4:     for i being Nat st 1 <= i & i < len r
        holds r.i in T & r.(i+1) = f.(r.i, I);
        consider r1 being (Element of S), q being FinSequence of S such that
A5:     r1 = r.1 & r = <*r1*>^q by FINSEQ_3:111;
A6:     len r = 1+len q by A5,FINSEQ_5:8;
then A7:     len q <> 0 by A1,A3;
        then reconsider q as non empty FinSequence of S by FINSEQ_1:25;
         len r <> 1 & len r >= 1 & len q > 0 by A6,A7,NAT_1:11;
then A8:     1 < len r & len q >= 0+1 by NAT_1:13,XXREAL_0:1;
        take q;
A9:     len <*r1*> = 1 & 1 in dom q by A8,FINSEQ_1:57,FINSEQ_3:27;
        hence q.1 = r.(1+1) by A5,FINSEQ_1:def 7 .= f.(s,I) by A3,A4,A8;
         len q in dom q by A8,FINSEQ_3:27;
        hence q.len q nin T by A3,A5,A6,A9,FINSEQ_1:def 7;
        let i be Nat; assume
A10:     1 <= i & i < len q;
         i in NAT by ORDINAL1:def 13;
        then i in dom q & 1 <= i+1 & i+1 < len r & i+1 in dom q
        by A6,A10,MSUALG_8:1,NAT_1:11,XREAL_1:8;
        then r.(i+1) = q.i & r.(i+1+1) = q.(i+1) & r.(i+1) in T &
        r.(i+1+1) = f.(r.(i+1), I) by A4,A5,A9,FINSEQ_1:def 7;
        hence thesis;
      end;
      given q being non empty FinSequence of S such that
A11:   q.1 = f.(s,I) & q.len q nin T and
A12:   for i being Nat st 1 <= i & i < len q
      holds q.i in T & q.(i+1) = f.(q.i, I);
      take r = <*s*>^q;
A13:   len <*s*> = 1 by FINSEQ_1:57;
      thus
A14:   r.1 = s by FINSEQ_1:58;
A15:   len r = 1+len q by FINSEQ_5:8;
       len q <> 0 by FINSEQ_1:25;
      then len q > 0;
then A16:   0+1 <= len q by NAT_1:13;
      then len q in dom q by FINSEQ_3:27;
      hence r.len r nin T by A11,A13,A15,FINSEQ_1:def 7;
      let i be Nat; assume
A17:   1 <= i & i < len r;
      then consider j being Nat such that
A18:   i = 1+j by NAT_1:10;
      per cases;
      suppose
A19:     j = 0;
         1 in dom q by A16,FINSEQ_3:27;
        hence thesis by A1,A11,A13,A14,A18,A19,FINSEQ_1:def 7;
      end;
      suppose j > 0;
then A20:     j >= 0+1 & j < len q & j in NAT
        by A15,A17,A18,NAT_1:13,ORDINAL1:def 13,XREAL_1:8;
        then j in dom q & 1 <= j+1 & j+1 < len r & j+1 in dom q
        by A15,MSUALG_8:1,XREAL_1:8;
        then r.(j+1) = q.j & r.(j+1+1) = q.(j+1) & q.j in T &
        q.(j+1) = f.(q.j, I) by A12,A13,A20,FINSEQ_1:def 7;
        hence thesis by A18;
      end;
    end;
    per cases by A2;
    suppose not f iteration_terminates_for I,s;
      then iteration-degree(I,s,f) = +infty &
      iteration-degree(I,f.(s,I),f) = +infty  by A2,Def34;
      hence thesis by SUPINF_2:def 2;
    end;
    suppose
A21:   f iteration_terminates_for I,f.(s,I);
      then consider q being non empty FinSequence of S such that
A22:   iteration-degree(I,f.(s,I),f) = (len q)-1 and
A23:   q.1 = f.(s,I) & q.len q nin T and
A24:   for i being Nat st 1 <= i & i < len q
      holds q.i in T & q.(i+1) = f.(q.i, I) by Def34;
      set r = <*s*>^q;
A25:   len <*s*> = 1 by FINSEQ_1:57;
A26:   r.1 = s by FINSEQ_1:58;
A27:   len r = 1+len q by FINSEQ_5:8;
      then 1+((len q)-1) = len q & (len r)-1 = len q & (len q)-1 in REAL &
      1 in REAL & (len r)-1 in ExtREAL by XREAL_0:def 1,XXREAL_0:def 1;
then A28:   (len r)-1 = 1.+iteration-degree(I,f.(s,I),f) by A22,SUPINF_2:def 2;
       len q <> 0 by FINSEQ_1:25;
      then len q > 0;
then A29:   0+1 <= len q by NAT_1:13;
      then len q in dom q by FINSEQ_3:27;
then A30:   r.len r nin T by A23,A25,A27,FINSEQ_1:def 7;
       now let i be Nat; assume
A31:     1 <= i & i < len r;
        then consider j being Nat such that
A32:     i = 1+j by NAT_1:10;
        per cases;
        suppose
A33:       j = 0;
           1 in dom q by A29,FINSEQ_3:27;
          hence r.i in T & r.(i+1) = f.(r.i,I)
          by A1,A23,A25,A26,A32,A33,FINSEQ_1:def 7;
        end;
        suppose j > 0;
then A34:       j >= 0+1 & j < len q & j in NAT
          by A27,A31,A32,NAT_1:13,ORDINAL1:def 13,XREAL_1:8;
          then j in dom q & 1 <= j+1 & j+1 < len r & j+1 in dom q
          by A27,MSUALG_8:1,XREAL_1:8;
          then r.(j+1) = q.j & r.(j+1+1) = q.(j+1) & q.j in T &
          q.(j+1) = f.(q.j, I) by A24,A25,A34,FINSEQ_1:def 7;
          hence r.i in T & r.(i+1) = f.(r.i,I) by A32;
        end;
      end;
      hence thesis by A2,A21,A26,A28,A30,Def34;
    end;
  end;

theorem
   iteration-degree(I,s,f) >= 0
  proof per cases;
    suppose not f iteration_terminates_for I,s;
      hence thesis by Def34;
    end;
    suppose f iteration_terminates_for I,s;
      then consider r being non empty FinSequence of S such that
A1:   iteration-degree(I,s,f) = (len r)-1 and
       r.1 = s & r.len r nin T &
      for i being Nat st 1 <= i & i < len r
      holds r.i in T & r.(i+1) = f.(r.i, I) by Def34;
       len r <> 0 by FINSEQ_1:25;
      then ex i being Nat st  len r = i+1 by NAT_1:6;
      hence thesis by A1;
    end;
  end;

scheme Termination
  {A() -> preIfWhileAlgebra,
   I() -> (Element of A()),
   S() -> non empty set,
   s() -> (Element of S()),
   T() -> Subset of S(),
   f() -> ExecutionFunction of A(),S(),T(),
   F(set) -> Nat, P[set]
  }:
  f() iteration_terminates_for I(),s()
  provided
A1: s() in T() iff P[s()] and
A2: for s being Element of S() st P[s]
   holds (P[f().(s,I())] iff f().(s,I()) in T()) & F(f().(s,I())) < F(s)
  proof
    per cases;
    suppose
       s() nin T();
      hence thesis by Th83;
    end;
    suppose
A3:    s() in T();
      deffunc F(set,set) = f().(In($2,S()),I());
      consider f being Function of NAT,S() such that
A4:   f.0 = s() and
A5:   for i being Element of NAT holds f.(i+1) = F(i,f.i)
      from RECDEF_1:sch 4;
      defpred Q[Nat] means ex i being Element of NAT st F(f.i) = $1;
       F(f.0) in NAT by ORDINAL1:def 13;
then A6:   ex j being Element of NAT st Q[j];
      consider j being Element of NAT such that
A7:   Q[j] & for i being Element of NAT st Q[i] holds j <= i
      from NAT_1:sch 5(A6);
      consider i0 being Element of NAT such that
A8:   F(f.i0) = j by A7;
      defpred R[Element of NAT] means not P[f.$1];
       In(f.i0,S()) = f.i0 by FUNCT_7:def 1;
      then f.(i0+1) = f().(f.i0,I()) by A5;
      then F(f.(i0+1)) in NAT & (P[f.i0] implies F(f.(i0+1)) < j)
      by A2,A8,ORDINAL1:def 13;
then A9:   ex i being Element of NAT st R[i] by A7;
      consider j being Element of NAT such that
A10:   R[j] & for i being Element of NAT st R[i] holds j <= i
      from NAT_1:sch 5(A9);
      deffunc G(Nat) = f.($1-'1);
      consider p being FinSequence of S() such that
A11:   len p = j+1 &
      for i being Nat st i in Seg (j+1) holds p.i = G(i)
      from FINSEQ_2:sch 1;
      reconsider p as non empty FinSequence of S() by A11,FINSEQ_1:25;
      take p;
A12:   1 <= j+1 by NAT_1:11;
      then 1 in Seg(j+1);
      hence p.1 = G(1) by A11 .= s() by A4,BINARITH:51;
       len p in Seg(j+1) by A11,A12;
then A13:   p.len p = G(j+1) by A11 .= f.j by BINARITH:39;
       j <> 0 by A1,A3,A4,A10;
      then j > 0;
      then j >= 0+1 by NAT_1:13;
      then consider j' being Nat such that
A14:   j = 1+j' by NAT_1:10;
      reconsider j' as Element of NAT by ORDINAL1:def 13;
A15:   f.j = f().(In(f.j',S()),I()) by A5,A14;
       j' < j by A14,NAT_1:13;
      then P[f.j'] & In(f.j',S()) = f.j' by A10,FUNCT_7:def 1;
      hence p.len p nin T() by A2,A10,A13,A15;
      let i be Nat; assume
A16:   1 <= i & i < len p;
      then i+1 >= 1 & i+1 <= len p by NAT_1:13;
      then i in Seg(j+1) & i+1 in Seg(j+1) by A11,A16,FINSEQ_1:3;
then A17:   p.i = G(i) & p.(i+1) = G(i+1) by A11;
      consider i' being Nat such that
A18:   i = 1+i' by A16,NAT_1:10;
      reconsider i' as Element of NAT by ORDINAL1:def 13;
       i <= j by A11,A16,NAT_1:13;
then A19:   i' < j by A18,NAT_1:13;
then A20:   P[f.i'] & i-'1 = i' & i+1-'1 = i & In(f.i',S()) = f.i'
      by A10,A18,BINARITH:39,FUNCT_7:def 1;
       now assume i' <> 0;
        then i' > 0;
        then i' >= 0+1 by NAT_1:13;
        then consider i'' being Nat such that
A21:     i' = 1+i'' by NAT_1:10;
        reconsider i'' as Element of NAT by ORDINAL1:def 13;
         i'' <= i' by A21,NAT_1:11;
        then i'' < j by A19,XXREAL_0:2;
        then P[f.i''] & In(f.i'',S()) = f.i'' & f.i' = F(i'',f.i'')
        by A5,A10,A21,FUNCT_7:def 1;
        hence p.i in T() by A2,A17,A20;
      end;
      hence p.i in T() & p.(i+1) = f().(p.i, I()) by A3,A4,A5,A17,A18,A20;
    end;
  end;

scheme Termination2
  {A() -> preIfWhileAlgebra,
   I() -> (Element of A()),
   S() -> non empty set,
   s() -> (Element of S()),
   T() -> Subset of S(),
   f() -> ExecutionFunction of A(),S(),T(),
   F(set) -> Nat, P,R[set]
  }:
  f() iteration_terminates_for I(),s()
  provided
A1: P[s()] and
A2: s() in T() iff R[s()] and
A3: for s being Element of S() st P[s] & s in T() & R[s]
   holds P[f().(s, I())] & (R[f().(s,I())] iff f().(s,I()) in T()) &
   F(f().(s,I())) < F(s)
  proof
    per cases;
    suppose
       s() nin T();
      hence thesis by Th83;
    end;
    suppose
A4:   s() in T();
      deffunc F(set,set) = f().(In($2,S()),I());
      consider f being Function of NAT,S() such that
A5:   f.0 = s() and
A6:   for i being Element of NAT holds f.(i+1) = F(i,f.i)
      from RECDEF_1:sch 4;
      defpred Q[Nat] means ex i being Element of NAT st F(f.i) = $1;
       F(f.0) in NAT by ORDINAL1:def 13;
then A7:   ex j being Element of NAT st Q[j];
      consider j being Element of NAT such that
A8:   Q[j] & for i being Element of NAT st Q[i] holds j <= i
      from NAT_1:sch 5(A7);
      consider i0 being Element of NAT such that
A9:   F(f.i0) = j by A8;
      defpred notR[Element of NAT] means not (P[f.$1] & f.$1 in T() & R[f.$1]);
       In(f.i0,S()) = f.i0 by FUNCT_7:def 1;
      then f.(i0+1) = f().(f.i0,I()) by A6;
      then F(f.(i0+1)) in NAT & (not notR[i0] implies F(f.(i0+1)) < j)
      by A3,A9,ORDINAL1:def 13;
then A10:   ex i being Element of NAT st notR[i] by A8;
      consider j being Element of NAT such that
A11:   notR[j] & for i being Element of NAT st notR[i] holds j <= i
      from NAT_1:sch 5(A10);
      deffunc G(Nat) = f.($1-'1);
      consider p being FinSequence of S() such that
A12:   len p = j+1 &
      for i being Nat st i in Seg (j+1) holds p.i = G(i)
      from FINSEQ_2:sch 1;
      reconsider p as non empty FinSequence of S() by A12,FINSEQ_1:25;
      take p;
A13:   1 <= j+1 by NAT_1:11;
      then 1 in Seg(j+1);
      hence p.1 = G(1) by A12 .= s() by A5,BINARITH:51;
       len p in Seg(j+1) by A12,A13;
then A14:   p.len p = G(j+1) by A12 .= f.j by BINARITH:39;
       j <> 0 by A1,A2,A4,A5,A11;
      then j > 0;
      then j >= 0+1 by NAT_1:13;
      then consider j' being Nat such that
A15:   j = 1+j' by NAT_1:10;
      reconsider j' as Element of NAT by ORDINAL1:def 13;
A16:   f.j = f().(In(f.j',S()),I()) by A6,A15;
       j' < j by A15,NAT_1:13;
      then R[f.j'] & f.j' in T() & P[f.j'] & In(f.j',S()) = f.j'
      by A11,FUNCT_7:def 1;
      hence p.len p nin T() by A3,A11,A14,A16;
      let i be Nat; assume
A17:   1 <= i & i < len p;
      then i+1 >= 1 & i+1 <= len p by NAT_1:13;
      then i in Seg(j+1) & i+1 in Seg(j+1) by A12,A17,FINSEQ_1:3;
then A18:   p.i = G(i) & p.(i+1) = G(i+1) by A12;
      consider i' being Nat such that
A19:   i = 1+i' by A17,NAT_1:10;
      reconsider i' as Element of NAT by ORDINAL1:def 13;
       i <= j by A12,A17,NAT_1:13;
      then i' < j by A19,NAT_1:13;
then   P[f.i'] & f.i' in T() & R[f.i'] & i-'1 = i' & i+1-'1 = i &
      In(f.i',S()) = f.i' by A11,A19,BINARITH:39,FUNCT_7:def 1;
      hence p.i in T() & p.(i+1) = f().(p.i, I()) by A6,A18,A19;
    end;
  end;

theorem Th86:
  for r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
    for i being Nat st 1 <= i & i < len r
    holds r.i in T & r.(i+1) = f.(r.i, I \; C)
  holds f.(s, while(C,I)) = r.len r
  proof
A1: f satisfies_while_wrt T by Def32;
    let r be non empty FinSequence of S;
    assume
A2: r.1 = f.(s,C);
    assume
A3: r.len r nin T;
    assume
A4: for i being Nat st 1 <= i & i < len r
    holds r.i in T & r.(i+1) = f.(r.i, I \; C);
    defpred P[Nat] means
    (len r)-$1 in dom r implies
    for q being Element of S st f.(q,C) = r.((len r)-$1)
    holds f.(q, while(C,I)) = r.len r;
A5: P[0] by A1,A3,Def31;
A6: for i being Nat st P[i] holds P[i+1]
    proof let i be Nat such that
A7:   P[i] and
A8:   (len r)-(i+1) in dom r;
      reconsider j = (len r)-(i+1) as Element of NAT by A8;
       j+1+i = len r;
then A9:   1 <= j+1 & j+1 <= len r by NAT_1:11;
then A10:   1 <= j & j < len r & (len r)-i in dom r by A8,FINSEQ_3:27,NAT_1:13;
then A11:   r.(j+1) = f.(r.j, I\;C) by A4;
      let q be Element of S; assume
A12:   f.(q,C) = r.((len r)-(i+1));
then A13:   f.(q,C) in T by A4,A10;
       r.(j+1) = f.(f.(f.(q,C), I), C) by A11,A12,Def29;
      then f.(f.(f.(q,C), I), while(C,I)) = r.len r by A7,A9,FINSEQ_3:27;
      hence thesis by A1,A13,Def31;
    end;
A14: for i being Nat holds P[i] from NAT_1:sch 2(A5,A6);
     len r <> 0 by FINSEQ_1:25;
    then len r > 0;
then A15: len r >= 0+1 by NAT_1:13;
    then consider i being Nat such that
A16: len r = 1+i by NAT_1:10;
     P[i] & (len r)-i = 1 & 1 in dom r by A14,A15,A16,FINSEQ_3:27;
    hence thesis by A2;
  end;

theorem Th87:
  for I being Element of A
  for s being Element of S holds
  not f iteration_terminates_for I,s iff (curry' f).I orbit s c= T
  proof
    let I be Element of A;
    let s be Element of S;
    set g = (curry' f).I;
    hereby assume
A1:   not f iteration_terminates_for I,s;
      thus g orbit s c= T
      proof
        let x be set; assume x in g orbit s;
        then consider n being Element of NAT such that
A2:     x = iter(g, n).s & s in dom iter(g, n);
        defpred P[Nat] means iter(g,$1).s nin T;
        assume x nin T;
then A3:     ex n being Element of NAT st P[n] by A2;
        consider n being Element of NAT such that
A4:     P[n] & for m being Element of NAT st P[m] holds n <= m
        from NAT_1:sch 5(A3);
        deffunc F(Nat) = iter(g,$1-'1).s;
        consider r being FinSequence such that
A5:     len r = n+1 &
        for k being Nat st k in Seg(n+1) holds r.k = F(k)
        from FINSEQ_1:sch 2;
A6:     dom r = Seg(n+1) by A5,FINSEQ_1:def 3;
     rng r c= S
        proof
          let a be set;
          assume a in rng r;
          then consider b being set such that
A7:       b in dom r & a = r.b by FUNCT_1:def 5;
          reconsider b as Element of NAT by A7;
           iter(g,b-'1) is Function of S,S &
          r.b = iter(g,b-'1).s by A5,A6,A7;
          hence thesis by A7;
        end;
        then reconsider r as non empty FinSequence of S by A5,FINSEQ_1:25,def 4
;
         1 <= n+1 by NAT_1:11;
        then 1 in Seg(n+1) & n+1 in Seg(n+1);
        then 1-'1 = 0 & n+1-'1 = n & iter(g,0) = id S & r.1 = F(1) &
        r.len r = F(n+1) by A5,BINARITH:39,51,FUNCT_7:86;
then A8:     r.1 = s & r.len r nin T by A4,FUNCT_1:34;
         now let i be Nat such that
A9:       1 <= i & i < len r;
          consider j being Nat such that
A10:       i = 1+j by A9,NAT_1:10;
          reconsider j as Element of NAT by ORDINAL1:def 13;
A11:       i-'1 = j & (i+1)-'1 = i by A10,BINARITH:39;
           dom curry' f = the carrier of A & dom g = S by FUNCT_2:def 1;
then A12:       g.(iter(g,j).s) = f.(iter(g,j).s, I) & iter(g,i) = g*iter(g,j)
          by A10,FUNCT_5:41,FUNCT_7:73;
           1 <= i+1 & i+1 <= n+1 by A5,A9,NAT_1:13;
          then i-'1 < n & i in Seg(n+1) & i+1 in Seg(n+1)
          by A5,A9,A10,A11,FINSEQ_1:3,XREAL_1:8;
          then r.i = iter(g,i-'1).s & r.(i+1) = iter(g,i).s & not P[i-'1]
          by A4,A5,A11;
          hence r.i in T & r.(i+1) = f.(r.i, I) by A11,A12,FUNCT_2:21;
        end;
        hence contradiction by A1,A8,Def33;
      end;
    end;
    assume
A13: (curry' f).I orbit s c= T;
    given r being non empty FinSequence of S such that
A14: r.1 = s & r.len r nin T and
A15: for i being Nat st 1 <= i & i < len r
    holds r.i in T & r.(i+1) = f.(r.i, I);
    defpred P[Nat] means
    $1+1 <= len r implies r.($1+1) in (curry' f).I orbit s;
     dom g = S by FUNCT_2:def 1;
then A16: P[0] by A14,Th6;
A17: for i being Nat st P[i] holds P[i+1]
    proof
      let i be Nat such that
A18:   P[i] & i+1+1 <= len r;
A19:   1 <= i+1 & i+1 < len r by A18,NAT_1:11,13;
      then i+1 in dom r by FINSEQ_3:27;
      then r.(i+1) in rng r & rng r c= S & dom f = [:S, the carrier of A:]
      by FUNCT_1:12,FUNCT_2:def 1;
then A20:   [r.(i+1), I] in dom f by ZFMISC_1:106;
      consider n being Element of NAT such that
A21:   r.(i+1) = iter((curry' f).I,n).s & s in dom iter((curry' f).I,n)
      by A18,NAT_1:13;
A22:   r.(i+1+1) = f.(r.(i+1), I) by A15,A19
      .= (curry' f).I.(r.(i+1)) by A20,FUNCT_5:29
      .= (g*iter(g,n)).s by A21,FUNCT_2:21
      .= iter((curry' f).I,n+1).s by FUNCT_7:73;
       dom iter(g,n+1) = S by FUNCT_2:def 1;
      hence r.(i+1+1) in g orbit s by A22;
    end;
     len r <> 0 by FINSEQ_1:25;
    then consider i being Nat such that
A23: len r = i+1 by NAT_1:6;
     for n being Nat holds P[n] from NAT_1:sch 2(A16,A17);
    then r.(i+1) in g orbit s by A23;
    hence contradiction by A13,A14,A23;
  end;

scheme InvariantSch
  {A() -> preIfWhileAlgebra,
   C,I() -> (Element of A()),
   S() -> non empty set,
   s() -> (Element of S()),
   T() -> Subset of S(),
   f() -> ExecutionFunction of A(),S(),T(),
   P,R[set]
  }:
  P[f().(s(),while(C(),I()))] & not R[f().(s(),while(C(),I()))]
provided
A1: P[s()] and
A2: f() iteration_terminates_for I()\;C(), f().(s(),C()) and
A3: for s being Element of S() st P[s] & s in T() & R[s]
   holds P[f().(s,I())] and
A4: for s being Element of S() st P[s] holds
   P[f().(s,C())] & (f().(s,C()) in T() iff R[f().(s,C())])
  proof
    consider r being non empty FinSequence of S() such that
A5: r.1 = f().(s(),C()) & r.len r nin T() &
    for i being Nat st 1 <= i & i < len r
    holds r.i in T() & r.(i+1) = f().(r.i, I()\;C()) by A2,Def33;
A6: f().(s(), while(C(),I())) = r.len r by A5,Th86;
    defpred Q[Nat] means $1+1 in dom r implies P[r.($1+1)] &
    ($1+1 < len r implies R[r.($1+1)]) &
    ex q being Element of S() st P[q] & r.($1+1) = f().(q,C());
     0+1 < len r implies r.(0+1) in T() by A5;
then A7: Q[0] by A1,A4,A5;
A8: for n being Nat st Q[n] holds Q[n+1]
    proof let n be Nat; assume
A9:   Q[n]; assume
A10:   n+1+1 in dom r;
then A11:   n+1+1 <= len r by FINSEQ_3:27;
then A12:   n+1+1 >= 1 & n+1 >= 1 & n+1 < len r by NAT_1:11,13;
then A13:   n+1 in dom r & r.(n+1) in T() & r.(n+1+1) = f().(r.(n+1), I()\;C())
      by A5,FINSEQ_3:27;
      then reconsider q1 = r.(n+1), q2 = r.(n+1+1) as Element of S()
      by A10,DTCONSTR:2;
      reconsider q3 = f().(q1,I()) as Element of S();
A14:   q2 = f().(q3, C()) by A13,Def29;
A15:   P[q3] by A3,A9,A11,A13,NAT_1:13;
      hence P[r.(n+1+1)] by A4,A14;
      hereby
        assume n+1+1 < len r;
        then r.(n+1+1) in T() by A5,A12;
        hence R[r.(n+1+1)] by A4,A14,A15;
      end;
      take q3;  thus thesis by A3,A9,A11,A13,Def29,NAT_1:13;
    end;
A16: for n being Nat holds Q[n] from NAT_1:sch 2(A7,A8);
     len r <> 0 by FINSEQ_1:25;
    then len r > 0;
then A17: len r >= 0+1 by NAT_1:13;
    then consider j being Nat such that
A18: len r = 1+j by NAT_1:10;
A19: j+1 in dom r by A17,A18,FINSEQ_3:27;
    hence P[f().(s(),while(C(),I()))] by A6,A16,A18;
     ex q being Element of S() st P[q] & r.(j+1) = f().(q, C()) by A16,A19;
    hence thesis by A4,A5,A6,A18;
  end;

scheme coInvariantSch
  {A() -> preIfWhileAlgebra,
   C,I() -> (Element of A()),
   S() -> non empty set,
   s() -> (Element of S()),
   T() -> Subset of S(),
   f() -> ExecutionFunction of A(),S(),T(),
   P[set]
  }:
  P[s()]
provided
A1: P[f().(s(),while(C(),I()))] and
A2: f() iteration_terminates_for I()\;C(), f().(s(),C()) and
A3: for s being Element of S() st P[f().(f().(s,C()),I())] & f().(s,C()) in T()
   holds P[f().(s,C())] and
A4: for s being Element of S() st P[f().(s,C())] holds P[s]
  proof
    consider r being non empty FinSequence of S() such that
A5: r.1 = f().(s(),C()) & r.len r nin T() &
    for i being Nat st 1 <= i & i < len r
    holds r.i in T() & r.(i+1) = f().(r.i, I()\;C()) by A2,Def33;
    defpred Q[Nat] means (len r)-$1 in dom r implies P[r.((len r)-$1)];
    defpred R[Nat] means $1+1 in dom r implies
    ex q being Element of S() st r.($1+1) = f().(q,C());
A6: R[0] by A5;
A7: for n being Nat st R[n] holds R[n+1]
    proof
      let n be Nat; assume R[n]; assume
A8:   n+1+1 in dom r;
      then n+1+1 <= len r by FINSEQ_3:27;
      then n+1 >= 1 & n+1 < len r by NAT_1:11,13;
then A9:   n+1 in dom r & r.(n+1) in T() & r.(n+1+1) = f().(r.(n+1), I()\;C())
      by A5,FINSEQ_3:27;
      then reconsider q1 = r.(n+1), q2 = r.(n+1+1) as Element of S()
      by A8,DTCONSTR:2;
      reconsider q3 = f().(q1,I()) as Element of S();
      take q3; thus thesis by A9,Def29;
    end;
A10: Q[0] by A1,A5,Th86;
A11: for n being Nat st Q[n] holds Q[n+1]
    proof let n be Nat; assume
A12:   Q[n]; assume
A13:   (len r)-(n+1) in dom r;
      then reconsider j = (len r)-(n+1) as Element of NAT;
A14:   j >= 1 by A13,FINSEQ_3:27;
       n+1 >= 0+1 by NAT_1:13;
      then j <= (len r)-1 by XREAL_1:12;
then A15:   j+1 <= (len r)-1+1 & 1 <= 1+j by NAT_1:11,XREAL_1:8;
then A16:   j < len r by NAT_1:13;
then A17:   j+1 in dom r & r.j in T() & r.(j+1) = f().(r.j, I()\;C())
      by A5,A14,A15,FINSEQ_3:27;
      then reconsider q1 = r.j, q2 = r.(j+1) as Element of S() by DTCONSTR:2;
      reconsider q' = f().(q1, I()) as Element of S();
      consider j' being Nat such that
A18:   j = 1+j' by A14,NAT_1:10;
       for n being Nat holds R[n] from NAT_1:sch 2(A6,A7);
      then consider qq being Element of S() such that
A19:   r.(j'+1) = f().(qq,C()) by A13,A18;
       q2 = f().(q', C()) & P[q2] by A12,A17,Def29;
      then P[f().(f().(qq,C()),I())] & f().(qq,C()) in T()
        by A4,A5,A14,A16,A18,A19;
      hence P[r.((len r)-(n+1))] by A3,A18,A19;
    end;
A20: for n being Nat holds Q[n] from NAT_1:sch 2(A10,A11);
     len r <> 0 by FINSEQ_1:25;
    then len r > 0;
then A21: len r >= 0+1 by NAT_1:13;
    then consider j being Nat such that
A22: len r = 1+j by NAT_1:10;
     (len r)-j in dom r by A21,A22,FINSEQ_3:27;
    then P[r.1] by A20,A22;
    hence P[s()] by A4,A5;
  end;

theorem Th88:
  for A being free preIfWhileAlgebra
  for I1,I2 being Element of A
  for n being Nat st I1\;I2 in (ElementaryInstructions A)|^n
  ex i being Nat st n = i+1 &
  I1 in (ElementaryInstructions A)|^i & I2 in (ElementaryInstructions A)|^i
  proof
    let A be free preIfWhileAlgebra;
    set B = ElementaryInstructions A;
A1: B is GeneratorSet of A by Def25;
    let I1,I2 be Element of A;
     I1\;I2 <> I1 & I1\;I2 <> I2 by Th73;
    then I1\;I2 nin B by Th50;
then A2: I1\;I2 nin B|^0 by Th18;
    let n be Nat;
    assume
A3: I1\;I2 in B|^n; then n > 0 by A2,NAT_1:3;
    then n >= 0+1 by NAT_1:13;
    then consider i being Nat such that
A4: n = 1+i by NAT_1:10;
    take i;
    thus n = i+1 by A4;
A5: dom Den(In(2, dom the charact of A), A) = 2-tuples_on the carrier of A
    by Th44;
A6: for o being OperSymbol of A, p being FinSequence st p in dom Den(o,A)
    holds Den(o,A).p in B implies o <> In(2, dom the charact of A)
    proof
      let o be OperSymbol of A;
      let p be FinSequence;
      assume
A7:   p in dom Den(o,A) & Den(o,A).p in B &
      o = In(2, dom the charact of A);
      then consider a,b being set such that
A8:   a in the carrier of A & b in the carrier of A & p = <*a,b*>
      by A5,CATALG_1:10;
      reconsider a,b as Element of A by A8;
       Den(o,A).p = a\;b & a\;b <> a & a\;b <> b by A7,A8,Th73;
      hence contradiction by A7,Th50;
    end;
     <*I1,I2*> in dom Den(In(2, dom the charact of A),A) by A5,CATALG_1:10;
    then rng <*I1,I2*> c= B|^i by A1,A3,A4,A6,Th39;
    then {I1,I2} c= B|^i by FINSEQ_2:147;
    hence thesis by ZFMISC_1:38;
  end;

theorem Th89:
  for A being free preIfWhileAlgebra
  for C,I1,I2 being Element of A
  for n being Nat st if-then-else(C,I1,I2) in (ElementaryInstructions A)|^n
  ex i being Nat st n = i+1 & C in (ElementaryInstructions A)|^i &
  I1 in (ElementaryInstructions A)|^i & I2 in (ElementaryInstructions A)|^i
  proof
    let A be free preIfWhileAlgebra;
    set B = ElementaryInstructions A;
A1: B is GeneratorSet of A by Def25;
    let C,I1,I2 be Element of A;
     if-then-else(C,I1,I2) nin B by Th51;
then A2: if-then-else(C,I1,I2) nin B|^0 by Th18;
    let n be Nat;
    assume
A3: if-then-else(C,I1,I2) in B|^n;
    then consider i being Nat such that
A4: n = i+1 by A2,NAT_1:6;
    take i;
    thus n = i+1 by A4;
A5: dom Den(In(3, dom the charact of A), A) = 3-tuples_on the carrier of A
    by Th47;
A6: for o being OperSymbol of A, p being FinSequence st p in dom Den(o,A)
    holds Den(o,A).p in B implies o <> In(3, dom the charact of A)
    proof
      let o be OperSymbol of A;
      let p be FinSequence;
      assume
A7:   p in dom Den(o,A) & Den(o,A).p in B &
      o = In(3, dom the charact of A);
      then consider a,b,c being set such that
A8:   a in the carrier of A & b in the carrier of A & c in the carrier of A &
      p = <*a,b,c*> by A5,CATALG_1:12;
      reconsider a,b,c as Element of A by A8;
       Den(o,A).p = if-then-else(a,b,c) by A7,A8;
      hence contradiction by A7,Th51;
    end;
     <*C,I1,I2*> in dom Den(In(3, dom the charact of A),A)
    by A5,CATALG_1:12;
    then rng <*C,I1,I2*> c= B|^i by A1,A3,A4,A6,Th39;
    then {C,I1,I2} c= B|^i & C in {C,I1,I2} & I1 in {C,I1,I2} & I2 in {C,I1,I2
}
    by ENUMSET1:def 1,FINSEQ_2:148;
    hence thesis;
  end;

theorem Th90:
  for A being free preIfWhileAlgebra
  for C,I being Element of A
  for n being Nat st while(C,I) in (ElementaryInstructions A)|^n
  ex i being Nat st n = i+1 &
  C in (ElementaryInstructions A)|^i & I in (ElementaryInstructions A)|^i
  proof
    let A be free preIfWhileAlgebra;
    set B = ElementaryInstructions A;
A1: B is GeneratorSet of A by Def25;
    let C,I be Element of A;
     while(C,I) nin B by Th52;
then A2: while(C,I) nin B|^0 by Th18;
    let n be Nat;
    assume
A3: while(C,I) in B|^n;
    then consider i being Nat such that
A4: n = i+1 by A2,NAT_1:6;
    take i;
    thus n = i+1 by A4;
A5: dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A
    by Th48;
A6: for o being OperSymbol of A, p being FinSequence st p in dom Den(o,A)
    holds Den(o,A).p in B implies o <> In(4, dom the charact of A)
    proof
      let o be OperSymbol of A;
      let p be FinSequence;
      assume
A7:   p in dom Den(o,A) & Den(o,A).p in B &
      o = In(4, dom the charact of A);
      then consider a,b being set such that
A8:   a in the carrier of A & b in the carrier of A & p = <*a,b*>
      by A5,CATALG_1:10;
      reconsider a,b as Element of A by A8;
       Den(o,A).p = while(a,b) by A7,A8;
      hence contradiction by A7,Th52;
    end;
     <*C,I*> in dom Den(In(4, dom the charact of A),A) by A5,CATALG_1:10;
    then rng <*C,I*> c= B|^i by A1,A3,A4,A6,Th39;
    then {C,I} c= B|^i by FINSEQ_2:147;
    hence thesis by ZFMISC_1:38;
  end;

begin :: Existence and uniqueness of execution function and termination

scheme IndDef {A() -> free ECIW-strict preIfWhileAlgebra,
  S() -> non empty set,
  Emp() -> (Element of S()),
  ElemF(set) -> set,
  ConF, WhiF(set,set) -> (Element of S()),
  IfF(set,set,set) -> Element of S()}:
  ex f being Function of the carrier of A(), S() st
   (for I being Element of A() st I in ElementaryInstructions A()
     holds f.I = ElemF(I)) &
   f.EmptyIns A() = Emp() &
   (for I1,I2 being Element of A() holds f.(I1\;I2) = ConF(f.I1,f.I2)) &
   (for C,I1,I2 being Element of A()
     holds f.if-then-else(C,I1,I2) = IfF(f.C,f.I1,f.I2)) &
   (for C,I being Element of A() holds f.while(C,I) = WhiF(f.C,f.I))
  provided
A1: for I being Element of A() st I in ElementaryInstructions A()
     holds ElemF(I) in S()
  proof
    set B = ElementaryInstructions A();
A2: B|^0 = B by Th18;
    set FB = {[I,ElemF(I)] where I is Element of A(): I in B};
    deffunc CF(Nat,set) = {[I1\;I2, ConF(fI1,fI2)]
    where I1,I2 is (Element of A()),fI1,fI2 is Element of S():
    I1 in B|^$1 & I2 in B|^$1 & [I1,fI1] in $2 & [I2,fI2] in $2};
    deffunc IF(Nat,set) = {[if-then-else(C,I1,I2), IfF(fC,fI1,fI2)]
    where C,I1,I2 is (Element of A()),fC,fI1,fI2 is (Element of S()):
    C in B|^$1 & I1 in B|^$1 & I2 in B|^$1 &
    [C,fC] in $2 & [I1,fI1] in $2 & [I2,fI2] in $2};
    deffunc WF(Nat,set) = {[while(C,I), WhiF(gC,gI)]
    where C,I is (Element of A()),gC,gI is Element of S():
    C in B|^$1 & I in B|^$1 & [C,gC] in $2 & [I,gI] in $2};
    deffunc F(Nat,set) = $2 \/ {[EmptyIns A(), Emp()]} \/
    CF($1,$2) \/ IF($1,$2) \/ WF($1,$2);
    consider FF being Function such that
A3: dom FF = NAT & FF.0 = FB and
A4: for n being Element of NAT holds FF.(n+1) = F(n,FF.n) from RECDEF_1:sch 3;
    set f = Union FF;
A5: for n,m being Nat st n <= m holds FF.n c= FF.m
    proof
      let n,m be Nat;
      assume n <= m;
      then consider i being Nat such that
A6:   m = n+i by NAT_1:10;
      reconsider i as Element of NAT by ORDINAL1:def 13;
A7:   m = n+i by A6;
      defpred I[Nat] means FF.n c= FF.(n+$1);
A8:   I[0];
A9:   now let i be Element of NAT;
        reconsider n' =n as Element of NAT by ORDINAL1:def 13;
         FF.(n'+i+1) = F(n'+i, FF.(n'+i)) by A4
        .= FF.(n+i) \/ {[EmptyIns A(), Emp()]} \/ CF(n+i, FF.(n+i)) \/
        (IF(n+i, FF.(n+i)) \/ WF(n+i, FF.(n+i))) by XBOOLE_1:4
        .= FF.(n+i) \/ {[EmptyIns A(), Emp()]} \/ (CF(n+i, FF.(n+i)) \/
        (IF(n+i, FF.(n+i)) \/ WF(n+i, FF.(n+i)))) by XBOOLE_1:4
        .= FF.(n+i) \/ ({[EmptyIns A(), Emp()]} \/ (CF(n+i, FF.(n+i)) \/
        (IF(n+i, FF.(n+i)) \/ WF(n+i, FF.(n+i))))) by XBOOLE_1:4;
        then FF.(n+i) c= FF.(n+i+1) by XBOOLE_1:7;
        hence I[i] implies I[i+1] by XBOOLE_1:1;
      end;
       for i being Element of NAT holds I[i] from NAT_1:sch 1(A8,A9);
      hence FF.n c= FF.m by A7;
    end;
    defpred P[Nat] means
    ex g being Function of B|^$1, S() st g = FF.$1 &
    (EmptyIns A() in B|^$1 implies g.EmptyIns A() = Emp()) &
    (for I1,I2 being Element of A() st I1\;I2 in B|^$1
    holds g.(I1\;I2) = ConF(g.I1,g.I2)) &
    (for C,I1,I2 being Element of A() st if-then-else(C,I1,I2) in B|^$1
    holds g.if-then-else(C,I1,I2) = IfF(g.C,g.I1,g.I2)) &
    (for C,I being Element of A() st while(C,I) in B|^$1
    holds g.while(C,I) = WhiF(g.C,g.I));
    defpred p[set] means $1 in B;
    reconsider f0 = {[I,ElemF(I)] where I is Element of A(): p[I]} as Function
    from ALTCAT_2:sch 1;
A10: dom f0 = B
    proof
      thus dom f0 c= B
      proof
        let x be set; assume x in dom f0;
        then [x,f0.x] in f0 by FUNCT_1:def 4;
        then ex I being Element of A() st [x,f0.x] = [I,ElemF(I)] & p[I];
        hence thesis by ZFMISC_1:33;
      end;
      let x be set; assume
A11:   x in B;
      then reconsider I = x as Element of A();
       [I,ElemF(I)] in f0 by A11;
      hence thesis by RELAT_1:def 4;
    end;
     rng f0 c= S()
    proof
      let y be set;
      assume y in rng f0;
      then consider x being set such that
A12:   [x,y] in f0 by RELAT_1:def 5;
      consider I being Element of A() such that
A13:   [x,y] = [I,ElemF(I)] & p[I] by A12;
       y = ElemF(I) by A13,ZFMISC_1:33;
      hence thesis by A1,A13;
    end;
    then reconsider f0 as Function of B|^0, S() by A2,A10,FUNCT_2:4;
A14: P[0]
    proof
      take f0; thus f0 = FF.0 by A3;
       now let I1,I2 be Element of A();
         I1\;I2 <> I1 & I1\;I2 <> I2 by Th73;
        hence I1\;I2 nin B by Th50;
      end;
      hence thesis by A2,Th49,Th51,Th52;
    end;
A15: for i being Element of NAT st P[i] holds P[i+1]
    proof
      let i be Element of NAT;
      given g being Function of B|^i, S() such that
A16:   g = FF.i &
      (EmptyIns A() in B|^i implies g.EmptyIns A() = Emp()) &
      (for I1,I2 being Element of A() st I1\;I2 in B|^i
      holds g.(I1\;I2) = ConF(g.I1,g.I2)) &
      (for C,I1,I2 being Element of A() st if-then-else(C,I1,I2) in B|^i
      holds g.if-then-else(C,I1,I2) = IfF(g.C,g.I1,g.I2)) &
      (for C,I being Element of A() st while(C,I) in B|^i
      holds g.while(C,I) = WhiF(g.C,g.I));
      set h = FF.(i+1);
       i < i+1 by NAT_1:13;
then A17:   h = F(i, g) & dom g = B|^i & B|^i c= B|^(i+1)
      by A4,A16,Th21,FUNCT_2:def 1;
A18:   now
        let x be set;
        assume x in h;
        then x in g \/ {[EmptyIns A(), Emp()]} \/ CF(i, g) \/ IF(i, g) or
        x in WF(i, g) by A17,XBOOLE_0:def 2;
        then x in g \/ {[EmptyIns A(), Emp()]} \/ CF(i, g) or x in IF(i, g) or
        x in WF(i, g) by XBOOLE_0:def 2;
        then x in g \/ {[EmptyIns A(), Emp()]} or x in CF(i,g) or x in IF(i, g
) or
        x in WF(i, g) by XBOOLE_0:def 2;
        hence x in g or x in {[EmptyIns A(), Emp()]} or x in CF(i,g) or
        x in IF(i, g) or x in WF(i, g) by XBOOLE_0:def 2;
      end;
       h is Relation-like
      proof
        let x be set;
        assume x in h;
        then x in g or x in {[EmptyIns A(), Emp()]} or
        x in CF(i,g) or x in IF(i,g) or x in WF(i,g) by A18;
        then (ex a,b being set st x = [a,b]) or x = [EmptyIns A(), Emp()] or
        (ex I1,I2 being (Element of A()), fI1,fI2 being Element of S() st
        x = [I1\;I2, ConF(fI1,fI2)] & I1 in B|^i & I2 in B|^i &
        [I1,fI1] in g & [I2,fI2] in g) or
        (ex C,I1,I2 being (Element of A()),a,b,c being Element of S() st
        x = [if-then-else(C,I1,I2), IfF(a,b,c)] & C in B|^i & I1 in B|^i &
        I2 in B|^i & [C,a] in g & [I1,b] in g & [I2,c] in g) or
        (ex C,I being (Element of A()), a,b being Element of S() st
        x = [while(C,I), WhiF(a,b)] & C in B|^i & I in B|^i & [C,a] in g &
        [I,b] in g) by RELAT_1:def 1;
        hence thesis;
      end;
      then reconsider h as Relation;
       h is Function-like
      proof
        let x,y1,y2 be set; set x1 = [x,y1], x2 = [x,y2];
        assume
A19:     [x,y1] in h;
        assume
A20:     [x,y2] in h;
        per cases by A18,A19;
        suppose
A21:       x1 in g;
then A22:       x in dom g & y1 = g.x by FUNCT_1:8;
          per cases by A18,A20;
          suppose x2 in g;
            hence thesis by A21,FUNCT_1:def 1;
          end;
          suppose x2 in {[EmptyIns A(), Emp()]};
            then x2 = [EmptyIns A(), Emp()] by TARSKI:def 1;
            then x = EmptyIns A() & y2 = Emp() by ZFMISC_1:33;
            hence thesis by A16,A22;
          end;
          suppose x2 in CF(i,g);
            then consider J1,J2 being (Element of A()), gJ1,gJ2 being Element
of S()
            such that
A23:        x2 = [J1\;J2, ConF(gJ1,gJ2)] & J1 in B|^i & J2 in B|^i &
            [J1,gJ1] in g & [J2,gJ2] in g;
             x = J1\;J2 & y2 = ConF(gJ1,gJ2) & g.J1 = gJ1 & g.J2 = gJ2
            by A23,FUNCT_1:8,ZFMISC_1:33;
            hence thesis by A16,A22;
          end;
          suppose x2 in IF(i,g);
            then consider D,J1,J2 being (Element of A()), a,b,c being Element
of S()
            such that
A24:        x2 = [if-then-else(D,J1,J2), IfF(a,b,c)] & D in B|^i & J1 in B|^i &
            J2 in B|^i & [D,a] in g & [J1,b] in g & [J2,c] in g;
             x = if-then-else(D,J1,J2) & y2 = IfF(a,b,c) & g.D = a & g.J1 = b &
            g.J2 = c by A24,FUNCT_1:8,ZFMISC_1:33;
            hence thesis by A16,A22;
          end;
          suppose x2 in WF(i,g);
            then consider D,J being (Element of A()), a,b being Element of S()
            such that
A25:        x2 = [while(D,J), WhiF(a,b)] & D in B|^i & J in B|^i & [D,a] in g &
            [J,b] in g;
             x = while(D,J) & y2 = WhiF(a,b) & g.D = a & g.J = b
            by A25,FUNCT_1:8,ZFMISC_1:33;
            hence thesis by A16,A22;
          end;
        end;
        suppose x1 in {[EmptyIns A(), Emp()]};
then A26:       x1 = [EmptyIns A(), Emp()] by TARSKI:def 1;
then A27:       x = EmptyIns A() & y1 = Emp() by ZFMISC_1:33;
          per cases by A18,A20;
          suppose x2 in g;
            then x in dom g & y2 = g.x by FUNCT_1:8;
            hence thesis by A16,A27;
          end;
          suppose x2 in {[EmptyIns A(), Emp()]};
            then x2 = [EmptyIns A(), Emp()] by TARSKI:def 1;
            hence thesis by A26,ZFMISC_1:33;
          end;
          suppose x2 in CF(i,g);
            then consider J1,J2 being (Element of A()), a,b being Element of S(
)
            such that
A28:        x2 = [J1\;J2, ConF(a,b)] & J1 in B|^i & J2 in B|^i &
            [J1,a] in g & [J2,b] in g;
             x = J1\;J2 by A28,ZFMISC_1:33;
            hence thesis by A27,Th72;
          end;
          suppose x2 in IF(i,g);
            then consider D,J1,J2 being (Element of A()),a,b,c being Element of
S()
            such that
A29:        x2 = [if-then-else(D,J1,J2), IfF(a,b,c)] & D in B|^i & J1 in B|^i &
            J2 in B|^i & [D,a] in g & [J1,b] in g & [J2,c] in g;
             x = if-then-else(D,J1,J2) by A29,ZFMISC_1:33;
            hence thesis by A27,Def24;
          end;
          suppose x2 in WF(i,g);
            then consider D,J being (Element of A()),a,b being Element of S()
            such that
A30:        x2 = [while(D,J), WhiF(a,b)] & D in B|^i & J in B|^i & [D,a] in g &
            [J,b] in g;
             x = while(D,J) by A30,ZFMISC_1:33;
            hence thesis by A27,Def24;
          end;
        end;
        suppose x1 in CF(i,g);
          then consider I1,I2 being (Element of A()), gI1,gI2 being Element of
S()
          such that
A31:       x1 = [I1\;I2, ConF(gI1,gI2)] & I1 in B|^i & I2 in B|^i &
          [I1,gI1] in g & [I2,gI2] in g;
A32:       x = I1\;I2 & y1 = ConF(gI1,gI2) & g.I1 = gI1 & g.I2 = gI2
          by A31,FUNCT_1:8,ZFMISC_1:33;
          per cases by A18,A20;
          suppose x2 in g;
            then x in dom g & y2 = g.x by FUNCT_1:8;
            hence thesis by A16,A32;
          end;
          suppose x2 in {[EmptyIns A(), Emp()]};
            then x2 = [EmptyIns A(), Emp()] by TARSKI:def 1;
            then x = EmptyIns A() & y2 = Emp() by ZFMISC_1:33;
            hence thesis by A32,Th72;
          end;
          suppose x2 in CF(i,g);
            then consider J1,J2 being (Element of A()), a,b being Element of S(
)
            such that
A33:        x2 = [J1\;J2, ConF(a,b)] & J1 in B|^i & J2 in B|^i & [J1,a] in g &
            [J2,b] in g;
A34:        x = J1\;J2 & y2 = ConF(a,b) & g.J1 = a & g.J2 = b
            by A33,FUNCT_1:8,ZFMISC_1:33;
            then I1 = J1 & I2 = J2 by A32,Th73;
            hence thesis by A32,A34;
          end;
          suppose x2 in IF(i,g);
            then consider D,J1,J2 being (Element of A()),a,b,c being Element of
S()
            such that
A35:        x2 = [if-then-else(D,J1,J2), IfF(a,b,c)] & D in B|^i &
            J1 in B|^i & J2 in B|^i & [D,a] in g & [J1,b] in g & [J2,c] in g;
             x = if-then-else(D,J1,J2) by A35,ZFMISC_1:33;
            hence thesis by A32,Th73;
          end;
          suppose x2 in WF(i,g);
            then consider D,J being (Element of A()),a,b being Element of S()
            such that
A36:        x2 = [while(D,J), WhiF(a,b)] & D in B|^i & J in B|^i &
            [D,a] in g & [J,b] in g;
             x = while(D,J) by A36,ZFMISC_1:33;
            hence thesis by A32,Th73;
          end;
        end;
        suppose x1 in IF(i,g);
          then consider C,I1,I2 being (Element of A()), gC,gI1,gI2 being
          Element of S() such that
A37:       x1 = [if-then-else(C,I1,I2), IfF(gC,gI1,gI2)] & C in B|^i &
          I1 in B|^i & I2 in B|^i & [C,gC] in g & [I1,gI1] in g &
          [I2,gI2] in g;
A38:       x = if-then-else(C,I1,I2) & y1 = IfF(gC,gI1,gI2) & g.I1 = gI1 &
          g.I2 = gI2 & g.C = gC by A37,FUNCT_1:8,ZFMISC_1:33;
          per cases by A18,A20;
          suppose x2 in g;
            then x in dom g & y2 = g.x by FUNCT_1:8;
            hence thesis by A16,A38;
          end;
          suppose x2 in {[EmptyIns A(), Emp()]};
            then x2 = [EmptyIns A(), Emp()] by TARSKI:def 1;
            then x = EmptyIns A() & y2 = Emp() by ZFMISC_1:33;
            hence thesis by A38,Th72;
          end;
          suppose x2 in CF(i,g);
            then consider J1,J2 being (Element of A()),a,b being Element of S()
            such that
A39:        x2 = [J1\;J2, ConF(a,b)] & J1 in B|^i & J2 in B|^i &
            [J1,a] in g & [J2,b] in g;
             x = J1\;J2 by A39,ZFMISC_1:33;
            hence thesis by A38,Th73;
          end;
          suppose x2 in IF(i,g);
            then consider D,J1,J2 being (Element of A()),a,b,c being Element of
S()
            such that
A40:        x2 = [if-then-else(D,J1,J2), IfF(a,b,c)] & D in B|^i &
            J1 in B|^i & J2 in B|^i & [D,a] in g & [J1,b] in g & [J2,c] in g;
A41:        x = if-then-else(D,J1,J2) & y2 = IfF(a,b,c) & g.D = a & g.J1 = b &
            g.J2 = c by A40,FUNCT_1:8,ZFMISC_1:33;
            then C = D & I1 = J1 & I2 = J2 by A38,Th74;
            hence thesis by A38,A41;
          end;
          suppose x2 in WF(i,g);
            then consider D,J being (Element of A()),a,b being Element of S()
            such that
A42:        x2 = [while(D,J), WhiF(a,b)] & D in B|^i & J in B|^i &
            [D,a] in g & [J,b] in g;
             x = while(D,J) by A42,ZFMISC_1:33;
            hence thesis by A38,Th74;
          end;
        end;
        suppose x1 in WF(i,g);
          then consider C,I being (Element of A()), gC,gI being Element of S()
          such that
A43:       x1 = [while(C,I), WhiF(gC,gI)] & C in B|^i & I in B|^i &
          [C,gC] in g & [I,gI] in g;
A44:       x = while(C,I) & y1 = WhiF(gC,gI) & g.C = gC & g.I = gI
          by A43,FUNCT_1:8,ZFMISC_1:33;
          per cases by A18,A20;
          suppose x2 in g;
            then x in dom g & y2 = g.x by FUNCT_1:8;
            hence thesis by A16,A44;
          end;
          suppose x2 in {[EmptyIns A(), Emp()]};
            then x2 = [EmptyIns A(), Emp()] by TARSKI:def 1;
            then x = EmptyIns A() & y2 = Emp() by ZFMISC_1:33;
            hence thesis by A44,Th72;
          end;
          suppose x2 in CF(i,g);
            then consider J1,J2 being (Element of A()),a,b being Element of S()
            such that
A45:        x2 = [J1\;J2, ConF(a,b)] & J1 in B|^i & J2 in B|^i &
            [J1,a] in g & [J2,b] in g;
             x = J1\;J2 by A45,ZFMISC_1:33;
            hence thesis by A44,Th73;
          end;
          suppose x2 in IF(i,g);
            then consider D,J1,J2 being (Element of A()), a,b,c being Element
of S()
            such that
A46:        x2 = [if-then-else(D,J1,J2), IfF(a,b,c)] & D in B|^i &
            J1 in B|^i & J2 in B|^i & [D,a] in g & [J1,b] in g & [J2,c] in g;
             x = if-then-else(D,J1,J2) by A46,ZFMISC_1:33;
            hence thesis by A44,Th74;
          end;
          suppose x2 in WF(i,g);
            then consider D,J being (Element of A()),a,b being Element of S()
            such that
A47:        x2 = [while(D,J), WhiF(a,b)] & D in B|^i & J in B|^i &
            [D,a] in g & [J,b] in g;
A48:        x = while(D,J) & y2 = WhiF(a,b) & g.D = a & g.J = b
            by A47,FUNCT_1:8,ZFMISC_1:33;
            then D = C & J = I by A44,Th75;
            hence thesis by A44,A48;
          end;
        end;
      end;
      then reconsider h as Function;
A49:   dom h = B|^(i+1)
      proof
        thus dom h c= B|^(i+1)
        proof
          let a be set; set ah = [a,h.a];
          assume a in dom h;
then A50:       [a,h.a] in h by FUNCT_1:def 4;
          per cases by A18,A50;
          suppose ah in g;
            then a in dom g by FUNCT_1:8;
            hence a in B|^(i+1) by A17;
          end;
          suppose ah in {[EmptyIns A(), Emp()]};
            then ah = [EmptyIns A(), Emp()] by TARSKI:def 1;
            then a = EmptyIns A() by ZFMISC_1:33;
            hence thesis by Th76;
          end;
          suppose ah in CF(i,g);
            then consider I,J being (Element of A()),e,b being Element of S()
such
            that
A51:         ah = [I\;J, ConF(e,b)] & I in B|^i & J in B|^i & [I,e] in g &
            [J,b] in g;
             a = I\;J by A51,ZFMISC_1:33;
            hence thesis by A51,Th76;
          end;
          suppose ah in IF(i,g);
            then consider C,I,J being (Element of A()),e,b,c being Element of S
()
            such that
A52:         ah = [if-then-else(C,I,J), IfF(e,b,c)] & C in B|^i & I in B|^i &
            J in B|^i & [C,e] in g & [I,b] in g & [J,c] in g;
             a = if-then-else(C,I,J) by A52,ZFMISC_1:33;
            hence thesis by A52,Th76;
          end;
          suppose ah in WF(i,g);
            then consider I,J being (Element of A()),e,b being Element of S()
such
            that
A53:         ah = [while(I,J), WhiF(e,b)] & I in B|^i & J in B|^i & [I,e] in g
&
            [J,b] in g;
             a = while(I,J) by A53,ZFMISC_1:33;
            hence thesis by A53,Th76;
          end;
        end;
        let x be set; assume
A54:     x in B|^(i+1);
        per cases by A54,Th77;
        suppose x in B|^i;
          then [x,g.x] in g by A17,FUNCT_1:def 4;
          then [x,g.x] in g \/ {[EmptyIns A(), Emp()]} by XBOOLE_0:def 2;
          then [x,g.x] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g)
          by XBOOLE_0:def 2;
          then [x,g.x] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g) \/ IF(i,g)
          by XBOOLE_0:def 2;
          then [x,g.x] in h by A17,XBOOLE_0:def 2;
          hence thesis by RELAT_1:def 4;
        end;
        suppose x = EmptyIns A();
          then [x,Emp()] in {[EmptyIns A(), Emp()]} by TARSKI:def 1;
          then [x,Emp()] in g \/ {[EmptyIns A(), Emp()]} by XBOOLE_0:def 2;
          then [x,Emp()] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g)
          by XBOOLE_0:def 2;
          then [x,Emp()] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g) \/ IF(i,g)
          by XBOOLE_0:def 2;
          then [x,Emp()] in h by A17,XBOOLE_0:def 2;
          hence thesis by RELAT_1:def 4;
        end;
        suppose
           ex I1,I2 being Element of A() st x = I1\;I2 &
          I1 in B|^i & I2 in B|^i;
          then consider I1,I2 being Element of A() such that
A55:       x = I1\;I2 & I1 in B|^i & I2 in B|^i;
          reconsider a = g.I1, b = g.I2 as Element of S() by A55,FUNCT_2:7;
           [I1,a] in g & [I2,b] in g by A17,A55,FUNCT_1:def 4;
          then [x,ConF(a,b)] in CF(i,g) by A55;
          then [x,ConF(a,b)] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g)
          by XBOOLE_0:def 2;
          then [x,ConF(a,b)] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g) \/ IF(
i,g)
          by XBOOLE_0:def 2;
          then [x,ConF(a,b)] in h by A17,XBOOLE_0:def 2;
          hence thesis by RELAT_1:def 4;
        end;
        suppose
           ex C,I1,I2 being Element of A() st x = if-then-else(C,I1,I2) &
          C in B|^i & I1 in B|^i & I2 in B|^i;
          then consider C,I1,I2 being Element of A() such that
A56:       x = if-then-else(C,I1,I2) & C in B|^i & I1 in B|^i & I2 in B|^i;
          reconsider a = g.I1, b = g.I2, c = g.C as Element of S()
          by A56,FUNCT_2:7;
           [I1,a] in g & [I2,b] in g & [C,c] in g by A17,A56,FUNCT_1:def 4;
          then [x,IfF(c,a,b)] in IF(i,g) by A56;
          then [x,IfF(c,a,b)] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g) \/ IF
(i,g)
          by XBOOLE_0:def 2;
          then [x,IfF(c,a,b)] in h by A17,XBOOLE_0:def 2;
          hence thesis by RELAT_1:def 4;
        end;
        suppose
           ex C,I being Element of A() st
          x = while(C,I) & C in B|^i & I in B|^i;
          then consider C,I being Element of A() such that
A57:       x = while(C,I) & C in B|^i & I in B|^i;
          reconsider a = g.C, b = g.I as Element of S() by A57,FUNCT_2:7;
           [C,a] in g & [I,b] in g by A17,A57,FUNCT_1:def 4;
          then [x,WhiF(a,b)] in WF(i,g) by A57;
          then [x,WhiF(a,b)] in h by A17,XBOOLE_0:def 2;
          hence thesis by RELAT_1:def 4;
        end;
      end;
       rng h c= S()
      proof
        let a be set;
        assume a in rng h;
        then consider x being set such that
A58:     [x,a] in h by RELAT_1:def 5;
        set ah = [x,a];
        per cases by A18,A58;
        suppose ah in g;
          hence a in S() by ZFMISC_1:106;
        end;
        suppose ah in {[EmptyIns A(), Emp()]};
          then ah = [EmptyIns A(), Emp()] by TARSKI:def 1;
          then a = Emp() by ZFMISC_1:33;
          hence thesis;
        end;
        suppose ah in CF(i,g);
          then consider I,J being (Element of A()),e,b being Element of S()
such
          that
A59:       ah = [I\;J, ConF(e,b)] & I in B|^i & J in B|^i & [I,e] in g &
          [J,b] in g;
           a = ConF(e,b) by A59,ZFMISC_1:33;
          hence thesis;
        end;
        suppose ah in IF(i,g);
          then consider C,I,J being (Element of A()),e,b,c being Element of S()
          such that
A60:       ah = [if-then-else(C,I,J), IfF(e,b,c)] & C in B|^i & I in B|^i &
          J in B|^i & [C,e] in g & [I,b] in g & [J,c] in g;
           a = IfF(e,b,c) by A60,ZFMISC_1:33;
          hence thesis;
        end;
        suppose ah in WF(i,g);
          then consider I,J being (Element of A()),e,b being Element of S()
such
          that
A61:       ah = [while(I,J), WhiF(e,b)] & I in B|^i & J in B|^i & [I,e] in g &
          [J,b] in g;
           a = WhiF(e,b) by A61,ZFMISC_1:33;
          hence thesis;
        end;
      end;
      then reconsider h as Function of B|^(i+1), S() by A49,FUNCT_2:4;
       h = g\/{[EmptyIns A(), Emp()]}\/CF(i,g)\/(IF(i,g)\/WF(i,g))
      by A17,XBOOLE_1:4
      .= g\/{[EmptyIns A(), Emp()]}\/(CF(i,g)\/(IF(i,g)\/WF(i,g)))
      by XBOOLE_1:4
      .= g\/({[EmptyIns A(), Emp()]}\/(CF(i,g)\/(IF(i,g)\/WF(i,g))))
      by XBOOLE_1:4;
then A62:   g c= h by XBOOLE_1:7;
      take h; thus h = FF.(i+1);
      hereby set x = EmptyIns A(); assume x in B|^(i+1);
         [x,Emp()] in {[EmptyIns A(), Emp()]} by TARSKI:def 1;
        then [x,Emp()] in g \/ {[EmptyIns A(), Emp()]} by XBOOLE_0:def 2;
        then [x,Emp()] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g)
        by XBOOLE_0:def 2;
        then [x,Emp()] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g) \/ IF(i,g)
        by XBOOLE_0:def 2;
        then [x,Emp()] in h by A17,XBOOLE_0:def 2;
        hence h.EmptyIns A() = Emp() by FUNCT_1:8;
      end;
      hereby let I1,I2 be Element of A();
        set x = I1\;I2; set y = ConF(h.I1,h.I2);
        assume I1\;I2 in B|^(i+1);
        then consider i0 being Nat such that
A63:     i+1 = i0+1 & I1 in B|^i0 & I2 in B|^i0 by Th88;
        reconsider gI1 = g.I1, gI2 = g.I2 as Element of S() by A63,FUNCT_2:7;
A64:     [I1,gI1] in g & [I2,gI2] in g by A17,A63,FUNCT_1:def 4;
        then g.I1 = h.I1 & g.I2 = h.I2 by A62,FUNCT_1:8;
        then [x,y] in CF(i,g) by A63,A64;
        then [x,y] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g)
        by XBOOLE_0:def 2;
        then [x,y] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g) \/ IF(i,g)
        by XBOOLE_0:def 2;
        then [x,y] in h by A17,XBOOLE_0:def 2;
        hence h.(I1\;I2) = ConF(h.I1,h.I2) by FUNCT_1:8;
      end;
      hereby let C,I1,I2 be Element of A();
        set x = if-then-else(C,I1,I2); set y = IfF(h.C,h.I1,h.I2);
        assume if-then-else(C,I1,I2) in B|^(i+1);
        then consider i0 being Nat such that
A65:     i+1 = i0+1 & C in B|^i0 & I1 in B|^i0 & I2 in B|^i0 by Th89;
        reconsider gC = g.C, gI1 = g.I1, gI2 = g.I2 as Element of S()
        by A65,FUNCT_2:7;
A66:     [C,gC] in g & [I1,gI1] in g & [I2,gI2] in g
        by A17,A65,FUNCT_1:def 4;
        then g.C = h.C & g.I1 = h.I1 & g.I2 = h.I2 by A62,FUNCT_1:8;
        then [x,y] in IF(i,g) by A65,A66;
        then [x,y] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g) \/ IF(i,g)
        by XBOOLE_0:def 2;
        then [x,y] in h by A17,XBOOLE_0:def 2;
        hence h.if-then-else(C,I1,I2) = IfF(h.C,h.I1,h.I2) by FUNCT_1:8;
      end;
      let C,I be Element of A();
      set x = while(C,I); set y = WhiF(h.C,h.I);
      assume while(C,I) in B|^(i+1);
      then consider i0 being Nat such that
A67:   i+1 = i0+1 & C in B|^i0 & I in B|^i0 by Th90;
      reconsider gC = g.C, gI = g.I as Element of S() by A67,FUNCT_2:7;
A68:   [C,gC] in g & [I,gI] in g by A17,A67,FUNCT_1:def 4;
      then g.C = h.C & g.I = h.I by A62,FUNCT_1:8;
      then [x,y] in WF(i,g) by A67,A68;
      then [x,y] in h by A17,XBOOLE_0:def 2;
      hence h.while(C,I) = WhiF(h.C,h.I) by FUNCT_1:8;
    end;
A69: for i being Element of NAT holds P[i] from NAT_1:sch 1(A14,A15);
     f is Relation-like Function-like
    proof
      hereby let x be set;
        assume x in f;
        then consider n being set such that
A70:     n in dom FF & x in FF.n by CARD_5:10;
        reconsider n as Element of NAT by A3,A70;
         P[n] by A69;
        hence ex a,b being set st x = [a,b] by A70,RELAT_1:def 1;
      end;
      let x,y1,y2 be set;
      assume [x,y1] in f;
      then consider n1 being set such that
A71:   n1 in dom FF & [x,y1] in FF.n1 by CARD_5:10;
      assume [x,y2] in f;
      then consider n2 being set such that
A72:   n2 in dom FF & [x,y2] in FF.n2 by CARD_5:10;
      reconsider n1,n2 as Element of NAT by A3,A71,A72;
       n1 <= n2 or n2 <= n1;
      then FF.n1 c= FF.n2 or FF.n2 c= FF.n1 by A5;
      then [x,y1] in FF.n2 & P[n2] or
      [x,y2] in FF.n1 & P[n1] by A69,A71,A72;
      hence y1 = y2 by A71,A72,FUNCT_1:def 1;
    end;
    then reconsider f as Function;
A73: dom f = the carrier of A()
    proof
      thus dom f c= the carrier of A()
      proof let x be set;
        assume x in dom f;
        then [x,f.x] in f by FUNCT_1:def 4;
        then consider n being set such that
A74:     n in dom FF & [x,f.x] in FF.n by CARD_5:10;
        reconsider n as Element of NAT by A3,A74;
         P[n] by A69;
        then x in B|^n by A74,ZFMISC_1:106;
        hence thesis;
      end;
      let x be set; assume x in the carrier of A();
      then reconsider I = x as Element of A();
      consider n being Nat such that
A75:   I in B|^n by Th79;
      reconsider n as Element of NAT by ORDINAL1:def 13;
       P[n] by A69;
      then reconsider g = FF.n as Function of B|^n, S();
       dom g = B|^n by FUNCT_2:def 1;
      then [I,g.I] in g by A75,FUNCT_1:def 4;
      then [I,g.I] in f by A3,CARD_5:10;
      hence x in dom f by RELAT_1:def 4;
    end;
     rng f c= S()
    proof
      let b be set; assume b in rng f;
      then consider a being set such that
A76:   a in dom f & b = f.a by FUNCT_1:def 5;
      reconsider a as Element of A() by A73,A76;
      consider n being Nat such that
A77:   a in B|^n by Th79;
      reconsider n as Element of NAT by ORDINAL1:def 13;
       P[n] by A69;
      then reconsider g = FF.n as Function of B|^n, S();
A78:   dom g = B|^n by FUNCT_2:def 1;
      then [a,g.a] in g by A77,FUNCT_1:def 4;
      then [a,g.a] in f by A3,CARD_5:10;
      then b = g.a & g.a in rng g & rng g c= S()
      by A76,A77,A78,FUNCT_1:8,12;
      hence b in S();
    end;
    then reconsider f as Function of the carrier of A(), S() by A73,FUNCT_2:4;
    take f;
    hereby let I be Element of A(); assume
       I in ElementaryInstructions A();
      then [I,ElemF(I)] in FF.0 by A3;
      then [I,ElemF(I)] in f by A3,CARD_5:10;
      hence f.I = ElemF(I) by FUNCT_1:8;
    end;
A79: now let n be Nat;
      let I be Element of A();
      let g be Function of B|^n, S();
      assume
A80:   I in B|^n & g = FF.n;
       dom g = B|^n by FUNCT_2:def 1;
      then [I,g.I] in g & n in NAT by A80,FUNCT_1:def 4,ORDINAL1:def 13;
      then [I,g.I] in f by A3,A80,CARD_5:10;
      hence g.I = f.I by FUNCT_1:8;
    end;
    consider n0 being Nat such that
A81: EmptyIns A() in B|^n0 by Th79;
    reconsider n0 as Element of NAT by ORDINAL1:def 13;
    consider g0 being Function of B|^n0, S() such that
A82: g0 = FF.n0 & (EmptyIns A() in B|^n0 implies g0.EmptyIns A() = Emp()) and
     (for I1,I2 being Element of A() st I1\;I2 in B|^n0
    holds g0.(I1\;I2) = ConF(g0.I1,g0.I2)) &
    (for C,I1,I2 being Element of A() st if-then-else(C,I1,I2) in B|^n0
    holds g0.if-then-else(C,I1,I2) = IfF(g0.C,g0.I1,g0.I2)) &
    (for C,I being Element of A() st while(C,I) in B|^n0
    holds g0.while(C,I) = WhiF(g0.C,g0.I)) by A69;
     dom g0 = B|^n0 by FUNCT_2:def 1;
    then [EmptyIns A(), Emp()] in g0 by A81,A82,FUNCT_1:def 4;
    then [EmptyIns A(), Emp()] in f by A3,A82,CARD_5:10;
    hence f.EmptyIns A() = Emp() by FUNCT_1:8;
    hereby let I1,I2 be Element of A();
      consider n0 being Nat such that
A83:   I1\;I2 in B|^n0 by Th79;
      reconsider n0 as Element of NAT by ORDINAL1:def 13;
      consider g0 being Function of B|^n0, S() such that
A84:   g0 = FF.n0 and
       (EmptyIns A() in B|^n0 implies g0.EmptyIns A() = Emp()) and
A85:   (for I1,I2 being Element of A() st I1\;I2 in B|^n0
      holds g0.(I1\;I2) = ConF(g0.I1,g0.I2)) and
       (for C,I1,I2 being Element of A() st if-then-else(C,I1,I2) in B|^n0
      holds g0.if-then-else(C,I1,I2) = IfF(g0.C,g0.I1,g0.I2)) &
      (for C,I being Element of A() st while(C,I) in B|^n0
      holds g0.while(C,I) = WhiF(g0.C,g0.I)) by A69;
      consider i0 being Nat such that
A86:   n0 = i0+1 & I1 in B|^i0 & I2 in B|^i0 by A83,Th88;
       n0 > i0 by A86,NAT_1:13;
      then B|^i0 c= B|^n0 by Th21;
      then dom g0 = B|^n0 & g0.I1 = f.I1 & g0.I2 = f.I2
      by A79,A84,A86,FUNCT_2:def 1;
      then [I1\;I2, g0.(I1\;I2)] in g0 & g0.(I1\;I2) = ConF(f.I1,f.I2)
      by A83,A85,FUNCT_1:8;
      then [I1\;I2, ConF(f.I1,f.I2)] in f by A3,A84,CARD_5:10;
      hence f.(I1\;I2) = ConF(f.I1,f.I2) by FUNCT_1:8;
    end;
    hereby let C,I1,I2 be Element of A();
      set IF = if-then-else(C,I1,I2);
      consider n0 being Nat such that
A87:   IF in B|^n0 by Th79;
      reconsider n0 as Element of NAT by ORDINAL1:def 13;
      consider g0 being Function of B|^n0, S() such that
A88:   g0 = FF.n0 and
       (EmptyIns A() in B|^n0 implies g0.EmptyIns A() = Emp()) and
       (for I1,I2 being Element of A() st I1\;I2 in B|^n0
      holds g0.(I1\;I2) = ConF(g0.I1,g0.I2)) and
A89:   (for C,I1,I2 being Element of A() st if-then-else(C,I1,I2) in B|^n0
      holds g0.if-then-else(C,I1,I2) = IfF(g0.C,g0.I1,g0.I2)) and
       (for C,I being Element of A() st while(C,I) in B|^n0
      holds g0.while(C,I) = WhiF(g0.C,g0.I)) by A69;
      consider i0 being Nat such that
A90:   n0 = i0+1 & C in B|^i0 & I1 in B|^i0 & I2 in B|^i0 by A87,Th89;
       n0 > i0 by A90,NAT_1:13;
      then B|^i0 c= B|^n0 by Th21;
      then dom g0 = B|^n0 & g0.C = f.C & g0.I1 = f.I1 & g0.I2 = f.I2
      by A79,A88,A90,FUNCT_2:def 1;
      then [IF, g0.IF] in g0 & g0.IF = IfF(f.C,f.I1,f.I2)by A87,A89,FUNCT_1:8;
      then [IF, IfF(f.C,f.I1,f.I2)] in f by A3,A88,CARD_5:10;
      hence f.if-then-else(C,I1,I2) = IfF(f.C,f.I1,f.I2) by FUNCT_1:8;
    end;
    let C,I be Element of A();
    set WH = while(C,I);
    consider n0 being Nat such that
A91: WH in B|^n0 by Th79;
    reconsider n0 as Element of NAT by ORDINAL1:def 13;
    consider g0 being Function of B|^n0, S() such that
A92: g0 = FF.n0 and
     (EmptyIns A() in B|^n0 implies g0.EmptyIns A() = Emp()) and
     (for I1,I2 being Element of A() st I1\;I2 in B|^n0
    holds g0.(I1\;I2) = ConF(g0.I1,g0.I2)) and
     (for C,I1,I2 being Element of A() st if-then-else(C,I1,I2) in B|^n0
    holds g0.if-then-else(C,I1,I2) = IfF(g0.C,g0.I1,g0.I2)) and
A93: (for C,I being Element of A() st while(C,I) in B|^n0
    holds g0.while(C,I) = WhiF(g0.C,g0.I)) by A69;
    consider i0 being Nat such that
A94: n0 = i0+1 & C in B|^i0 & I in B|^i0 by A91,Th90;
     n0 > i0 by A94,NAT_1:13;
    then B|^i0 c= B|^n0 by Th21;
    then dom g0 = B|^n0 & g0.C = f.C & g0.I = f.I
    by A79,A92,A94,FUNCT_2:def 1;
    then [WH, g0.WH] in g0 & g0.WH = WhiF(f.C,f.I) by A91,A93,FUNCT_1:8;
    then [WH, WhiF(f.C,f.I)] in f by A3,A92,CARD_5:10;
    hence f.while(C,I) = WhiF(f.C,f.I) by FUNCT_1:8;
  end;

theorem
   for A being free ECIW-strict preIfWhileAlgebra
  for g being Function of [:S, ElementaryInstructions A:], S
  for s0 being Element of S
  ex f being ExecutionFunction of A, S, T
  st f|[:S, ElementaryInstructions A:] = g &
    for s being Element of S
    for C,I being Element of A st not f iteration_terminates_for I\;C, f.(s,C)
    holds f.(s, while(C,I)) = s0
  proof
    let A be free ECIW-strict preIfWhileAlgebra;
    let g be Function of [:S, ElementaryInstructions A:], S;
    let s0 be Element of S;
    reconsider Ss0 = S-->s0 as Element of Funcs(S,S);
    set Z = Funcs(S,S);
    deffunc ElemF(Element of A)
    = (curry' g).$1;
A1: for I being Element of A st I in ElementaryInstructions A
    holds ElemF(I) in Z
    proof
      let I be Element of A;
      assume
A2:   I in ElementaryInstructions A;
      then reconsider B = ElementaryInstructions A as non empty set;
      reconsider I as Element of B by A2;
      reconsider g as Function of [:S,B:],S;
       (curry' g).I is Element of Z;
      hence thesis;
    end;
    reconsider idS = id S as Element of Z by ALTCAT_1:2;
    deffunc ConF((Element of Z), Element of Z)
    = $2*$1 qua Element of Z;
    deffunc IfF((Element of Z), (Element of Z), Element of Z)
    = (($2,T)+*$3)*$1 qua Element of Z;
    deffunc WhiF((Element of Z), Element of Z)
    = ((T,Ss0) iter ($1*$2))*$1 qua Element of Z;
    consider h being Function of the carrier of A, Z such that
A3: for I being Element of A st I in ElementaryInstructions A
    holds h.I = ElemF(I) and
A4: h.EmptyIns A = idS and
A5: for I1,I2 being Element of A holds h.(I1\;I2) = ConF(h.I1,h.I2) and
A6: for C,I1,I2 being Element of A
    holds h.if-then-else(C,I1,I2) = IfF(h.C,h.I1,h.I2) and
A7: for C,I being Element of A holds h.while(C,I) = WhiF(h.C,h.I)
    from IndDef(A1);
     h in Funcs(the carrier of A, Z) by FUNCT_2:11;
    then uncurry' h in Funcs([:S, the carrier of A:], S) by FUNCT_6:20;
    then reconsider f = uncurry' h as Function of [:S, the carrier of A:], S
    by FUNCT_2:121;
A8: dom h = the carrier of A & dom idS = S by FUNCT_2:def 1;
A9: f is satisfying_empty-instruction
    proof
      let s be Element of S;
       idS.s = s by FUNCT_1:35;
      hence f.(s, EmptyIns A) = s by A4,A8,FUNCT_5:46;
    end;
A10: f is satisfying_catenation
    proof
      let s be Element of S;
      let I1,I2 be Element of A;
A11:   dom (h.(I1\;I2)) = S & dom (h.I1) = S & dom (h.I2) = S by FUNCT_2:def 1;
      hence f.(s,I1 \; I2) = (h.(I1\;I2)).s by A8,FUNCT_5:46
      .= ((h.I2)*(h.I1)).s by A5 .= (h.I2).((h.I1).s) by FUNCT_2:21
      .= (h.I2).(f.(s,I1)) by A8,A11,FUNCT_5:46
      .= f.(f.(s,I1),I2) by A8,A11,FUNCT_5:46;
    end;
A12: f satisfies_if_wrt T
    proof
      let s be Element of S;
      let C, I1,I2 be Element of A;
A13:   dom (h.if-then-else(C,I1,I2)) = S & dom (h.C) = S & dom (h.I1) = S &
      dom (h.I2) = S by FUNCT_2:def 1;
then A14:   f.(s,if-then-else(C,I1,I2))
      = (h.if-then-else(C,I1,I2)).s by A8,FUNCT_5:46
      .= IfF(h.C,h.I1,h.I2).s by A6
      .= ((h.I1,T)+*(h.I2)).((h.C).s) by FUNCT_2:21;
A15:   f.(s,C) = (h.C).s by A8,A13,FUNCT_5:46;
      hereby
        assume f.(s,C) in T;
        hence f.(s,if-then-else(C,I1,I2)) = (h.I1).(f.(s,C)) by A13,A14,A15,Th4
        .= f.(f.(s,C),I1) by A8,A13,FUNCT_5:46;
      end;
      assume f.(s,C) nin T;
      hence f.(s,if-then-else(C,I1,I2)) = (h.I2).(f.(s,C)) by A13,A14,A15,Th5
      .= f.(f.(s,C),I2) by A8,A13,FUNCT_5:46;
    end;
     f satisfies_while_wrt T
    proof
      let s be Element of S;
      let C, I be Element of A;
A16:   dom (h.while(C,I)) = S & dom (h.C) = S & dom (h.I) = S &
      dom ((h.C)*(h.I)) = S by FUNCT_2:def 1;
then A17:   f.(s,while(C,I)) = (h.while(C,I)).s by A8,FUNCT_5:46
      .= WhiF(h.C,h.I).s by A7
      .= ((T,Ss0) iter ((h.C)*(h.I))).((h.C).s) by FUNCT_2:21;
A18:   f.(s,C) = (h.C).s by A8,A16,FUNCT_5:46;
A19:   rng ((h.C)*(h.I)) c= S;
       now let z be Element of S;
        thus (Ss0*((h.C)*(h.I))).z = Ss0.(((h.C)*(h.I)).z) by FUNCT_2:21
        .= s0 by FUNCOP_1:13
        .= Ss0.z by FUNCOP_1:13;
      end;
then A20:   Ss0*((h.C)*(h.I)) = Ss0 by FUNCT_2:113;
      hereby
        assume f.(s,C) in T;
        hence f.(s,while(C,I))
        = ((T,Ss0) iter ((h.C)*(h.I))).(((h.C)*(h.I)).(f.(s,C)))
        by A16,A17,A18,A19,A20,Th11
        .= ((T,Ss0) iter ((h.C)*(h.I))).((h.C).((h.I).(f.(s,C))))
        by FUNCT_2:21
        .= (((T,Ss0) iter ((h.C)*(h.I)))*(h.C)).((h.I).(f.(s,C)))
        by FUNCT_2:21
        .= (((T,Ss0) iter ((h.C)*(h.I)))*(h.C)).(f.(f.(s,C),I))
        by A8,A16,FUNCT_5:46
        .= (h.while(C,I)).(f.(f.(s,C),I)) by A7
        .= f.(f.(f.(s,C),I),while(C,I)) by A8,A16,FUNCT_5:46;
      end;
      thus thesis by A16,A17,A18,A19,Th12;
    end;
    then reconsider f as ExecutionFunction of A, S, T by A9,A10,A12,Def32;
    take f;
     dom f = [:S, the carrier of A:] by FUNCT_2:def 1;
    then [:S, ElementaryInstructions A:] c= dom f by ZFMISC_1:118;
then A21: dom g = [:S, ElementaryInstructions A:] &
    dom f /\ [:S, ElementaryInstructions A:] = [:S, ElementaryInstructions A:]
    by FUNCT_2:def 1,XBOOLE_1:28;
     now
      let a be set; assume
A22:   a in dom g;
      then consider s,I being set such that
A23:   s in S & I in ElementaryInstructions A & a = [s,I] by ZFMISC_1:def 2;
      reconsider s as Element of S by A23;
      reconsider I as Element of A by A23;
      reconsider EI = (curry' g).I as Element of Z by A1,A23;
       g in Funcs([:S, ElementaryInstructions A:], S) by FUNCT_2:11;
      then curry' g in Funcs(ElementaryInstructions A, Z) by A22,FUNCT_6:19;
then A24:   dom curry' g = ElementaryInstructions A & dom EI = S & dom (h.I) =
S
      by FUNCT_2:169;
      thus g.a = g.(s,I) by A23 .= EI.s by A23,A24,FUNCT_5:41
      .= (h.I).s by A3,A23 .= f.(s,I) by A8,A24,FUNCT_5:46 .= f.a by A23;
    end;
    hence f|[:S, ElementaryInstructions A:] = g by A21,FUNCT_1:68;
    let s be Element of S;
    let C,I be Element of A;
    assume
A25: not f iteration_terminates_for I\;C, f.(s,C);
A26: dom (h.while(C,I)) = S & dom (h.C) = S & dom (h.I) = S &
    dom ((h.C)*(h.I)) = S by FUNCT_2:def 1;
then A27: f.(s,while(C,I)) = (h.while(C,I)).s by A8,FUNCT_5:46
    .= WhiF(h.C,h.I).s by A7
    .= ((T,Ss0) iter ((h.C)*(h.I))).((h.C).s) by FUNCT_2:21;
A28: f.(s,C) = (h.C).s by A8,A26,FUNCT_5:46;
A29: rng ((h.C)*(h.I)) c= S;
     rng h c= Z;
    then h = curry' f by FUNCT_5:55;
    then (curry' f).(I\;C) = (h.C)*(h.I) by A5;
    then (h.C)*(h.I) orbit f.(s,C) c= T by A25,Th87;
    hence f.(s, while(C,I)) = Ss0.(f.(s,C))  by A26,A27,A28,A29,Def7
    .= s0 by FUNCOP_1:13;
  end;

theorem
   for A being free ECIW-strict preIfWhileAlgebra
  for g being Function of [:S, ElementaryInstructions A:], S
  for F being Function of Funcs(S,S), Funcs(S,S)
  st for h being Element of Funcs(S,S) holds (F.h)*h = F.h
  ex f being ExecutionFunction of A, S, T
  st f|[:S, ElementaryInstructions A:] = g &
  for C,I being Element of A
  for s being Element of S st not f iteration_terminates_for I\;C, f.(s, C)
  holds f.(s, while(C, I)) = F.((curry' f).(I\;C)).(f.(s,C))
  proof
    let A be free ECIW-strict preIfWhileAlgebra;
    let g be Function of [:S, ElementaryInstructions A:], S;
    consider s0 being Element of S;
    let F being Function of Funcs(S,S), Funcs(S,S) such that
A1: for h being Element of Funcs(S,S) holds (F.h)*h = F.h;
    set Z = Funcs(S,S);
    deffunc ElemF(Element of A)
    = (curry' g).$1;
A2: for I being Element of A st I in ElementaryInstructions A
    holds ElemF(I) in Z
    proof
      let I be Element of A;
      assume
A3:   I in ElementaryInstructions A;
      then reconsider B = ElementaryInstructions A as non empty set;
      reconsider I as Element of B by A3;
      reconsider g as Function of [:S,B:],S;
       (curry' g).I is Element of Z;
      hence thesis;
    end;
    reconsider idS = id S as Element of Z by ALTCAT_1:2;
    deffunc ConF((Element of Z), Element of Z)
    = $2*$1 qua Element of Z;
    deffunc IfF((Element of Z), (Element of Z), Element of Z)
    = (($2,T)+*$3)*$1 qua Element of Z;
    deffunc WhiF((Element of Z), Element of Z)
    = ((T, F.($1*$2)) iter ($1*$2))*$1 qua Element of Z;

    consider h being Function of the carrier of A, Z such that
A4: for I being Element of A st I in ElementaryInstructions A
    holds h.I = ElemF(I) and
A5: h.EmptyIns A = idS and
A6: for I1,I2 being Element of A holds h.(I1\;I2) = ConF(h.I1,h.I2) and
A7: for C,I1,I2 being Element of A
    holds h.if-then-else(C,I1,I2) = IfF(h.C,h.I1,h.I2) and
A8: for C,I being Element of A holds h.while(C,I) = WhiF(h.C,h.I)
    from IndDef(A2);
     h in Funcs(the carrier of A, Z) by FUNCT_2:11;
    then uncurry' h in Funcs([:S, the carrier of A:], S) by FUNCT_6:20;
    then reconsider f = uncurry' h as Function of [:S, the carrier of A:], S
    by FUNCT_2:121;
A9: dom h = the carrier of A & dom idS = S by FUNCT_2:def 1;
A10: f is satisfying_empty-instruction
    proof
      let s be Element of S;
       idS.s = s by FUNCT_1:35;
      hence f.(s, EmptyIns A) = s by A5,A9,FUNCT_5:46;
    end;
A11: f is satisfying_catenation
    proof
      let s be Element of S;
      let I1,I2 be Element of A;
A12:   dom (h.(I1\;I2)) = S & dom (h.I1) = S & dom (h.I2) = S by FUNCT_2:def 1;
      hence f.(s,I1 \; I2) = (h.(I1\;I2)).s by A9,FUNCT_5:46
      .= ((h.I2)*(h.I1)).s by A6 .= (h.I2).((h.I1).s) by FUNCT_2:21
      .= (h.I2).(f.(s,I1)) by A9,A12,FUNCT_5:46
      .= f.(f.(s,I1),I2) by A9,A12,FUNCT_5:46;
    end;
A13: f satisfies_if_wrt T
    proof
      let s be Element of S;
      let C, I1,I2 be Element of A;
A14:   dom (h.if-then-else(C,I1,I2)) = S & dom (h.C) = S & dom (h.I1) = S &
      dom (h.I2) = S by FUNCT_2:def 1;
then A15:   f.(s,if-then-else(C,I1,I2))
      = (h.if-then-else(C,I1,I2)).s by A9,FUNCT_5:46
      .= IfF(h.C,h.I1,h.I2).s by A7
      .= ((h.I1,T)+*(h.I2)).((h.C).s) by FUNCT_2:21;
A16:   f.(s,C) = (h.C).s by A9,A14,FUNCT_5:46;
      hereby
        assume f.(s,C) in T;
        hence f.(s,if-then-else(C,I1,I2)) = (h.I1).(f.(s,C)) by A14,A15,A16,Th4
        .= f.(f.(s,C),I1) by A9,A14,FUNCT_5:46;
      end;
      assume f.(s,C) nin T;
      hence f.(s,if-then-else(C,I1,I2)) = (h.I2).(f.(s,C)) by A14,A15,A16,Th5
      .= f.(f.(s,C),I2) by A9,A14,FUNCT_5:46;
    end;
     f satisfies_while_wrt T
    proof
      let s be Element of S;
      let C, I be Element of A;
A17:   dom (h.while(C,I)) = S & dom (h.C) = S & dom (h.I) = S &
      dom ((h.C)*(h.I)) = S by FUNCT_2:def 1;
then A18:   f.(s,while(C,I)) = (h.while(C,I)).s by A9,FUNCT_5:46
      .= WhiF(h.C,h.I).s by A8
      .= ((T,F.((h.C)*(h.I))) iter ((h.C)*(h.I))).((h.C).s) by FUNCT_2:21;
A19:   f.(s,C) = (h.C).s by A9,A17,FUNCT_5:46;
A20:   rng ((h.C)*(h.I)) c= S;
A21:   (F.((h.C)*(h.I)))*((h.C)*(h.I)) = F.((h.C)*(h.I)) by A1;
      hereby
        assume f.(s,C) in T;
        hence f.(s,while(C,I))
        = ((T,F.((h.C)*(h.I))) iter ((h.C)*(h.I))).(((h.C)*(h.I)).(f.(s,C)))
        by A17,A18,A19,A20,A21,Th11
        .= ((T,F.((h.C)*(h.I))) iter ((h.C)*(h.I))).((h.C).((h.I).(f.(s,C))))
        by FUNCT_2:21
        .= (((T,F.((h.C)*(h.I))) iter ((h.C)*(h.I)))*(h.C)).((h.I).(f.(s,C)))
        by FUNCT_2:21
        .= (((T,F.((h.C)*(h.I))) iter ((h.C)*(h.I)))*(h.C)).(f.(f.(s,C),I))
        by A9,A17,FUNCT_5:46
        .= (h.while(C,I)).(f.(f.(s,C),I)) by A8
        .= f.(f.(f.(s,C),I),while(C,I)) by A9,A17,FUNCT_5:46;
      end;
      thus thesis by A17,A18,A19,A20,Th12;
    end;
    then reconsider f as ExecutionFunction of A, S, T by A10,A11,A13,Def32;
    take f;
     dom f = [:S, the carrier of A:] by FUNCT_2:def 1;
    then [:S, ElementaryInstructions A:] c= dom f by ZFMISC_1:118;
then A22: dom g = [:S, ElementaryInstructions A:] &
    dom f /\ [:S, ElementaryInstructions A:] = [:S, ElementaryInstructions A:]
    by FUNCT_2:def 1,XBOOLE_1:28;
     now
      let a be set; assume
A23:   a in dom g;
      then consider s,I being set such that
A24:   s in S & I in ElementaryInstructions A & a = [s,I] by ZFMISC_1:def 2;
      reconsider s as Element of S by A24;
      reconsider I as Element of A by A24;
      reconsider EI = (curry' g).I as Element of Z by A2,A24;
       g in Funcs([:S, ElementaryInstructions A:], S) by FUNCT_2:11;
      then curry' g in Funcs(ElementaryInstructions A, Z) by A23,FUNCT_6:19;
then A25:   dom curry' g = ElementaryInstructions A & dom EI = S & dom (h.I) =
S
      by FUNCT_2:169;
      thus g.a = g.(s,I) by A24 .= EI.s by A24,A25,FUNCT_5:41
      .= (h.I).s by A4,A24 .= f.(s,I) by A9,A25,FUNCT_5:46 .= f.a by A24;
    end;
    hence f|[:S, ElementaryInstructions A:] = g by A22,FUNCT_1:68;
    let C,I be Element of A;
    let s be Element of S;
    assume
A26: not f iteration_terminates_for I\;C, f.(s,C);
A27: dom (h.while(C,I)) = S & dom (h.C) = S & dom (h.I) = S &
    dom ((h.C)*(h.I)) = S by FUNCT_2:def 1;
then A28: f.(s,while(C,I)) = (h.while(C,I)).s by A9,FUNCT_5:46
    .= WhiF(h.C,h.I).s by A8
    .= ((T,F.((h.C)*(h.I))) iter ((h.C)*(h.I))).((h.C).s) by FUNCT_2:21;
A29: f.(s,C) = (h.C).s by A9,A27,FUNCT_5:46;
A30: rng ((h.C)*(h.I)) c= S;
     rng h c= Z;
    then h = curry' f by FUNCT_5:55;
then A31: (curry' f).(I\;C) = (h.C)*(h.I) by A6;
    then (h.C)*(h.I) orbit f.(s,C) c= T by A26,Th87;
    hence f.(s, while(C, I)) = F.((curry' f).(I\;C)).(f.(s,C))
    by A27,A28,A29,A30,A31,Def7;
  end;

theorem
   for A being free ECIW-strict preIfWhileAlgebra
  for f1,f2 being ExecutionFunction of A, S, T
  st f1|[:S, ElementaryInstructions A:] = f2|[:S, ElementaryInstructions A:] &
     for s being Element of S
     for C,I being Element of A
     st not f1 iteration_terminates_for I\;C, f1.(s,C)
     holds f1.(s, while(C,I)) = f2.(s, while(C,I))
  holds f1 = f2
  proof
    let A be free ECIW-strict preIfWhileAlgebra;
    let f1,f2 be ExecutionFunction of A, S, T;
    assume
A1: f1|[:S, ElementaryInstructions A:] = f2|[:S, ElementaryInstructions A:];
    set g = f1|[:S, ElementaryInstructions A:];
    assume
A2: for s being Element of S
    for C,I being Element of A
    st not f1 iteration_terminates_for I\;C, f1.(s,C)
    holds f1.(s, while(C,I)) = f2.(s, while(C,I));
    defpred P[set] means
    for s being Element of S holds f1.(s, $1) = f2.(s, $1);
A3: for I being Element of A st I in ElementaryInstructions A holds P[I]
    proof
      let I be Element of A such that
A4:   I in ElementaryInstructions A;
      let s be Element of S;
A5:   [s,I] in [:S, ElementaryInstructions A:] by A4,ZFMISC_1:106;
      hence f1.(s,I) = g.[s,I] by FUNCT_1:72 .= f2.(s,I) by A1,A5,FUNCT_1:72;
    end;
A6: P[EmptyIns A]
    proof
      let s be Element of S;
      thus f1.(s, EmptyIns A) = s by Def28 .= f2.(s, EmptyIns A) by Def28;
    end;
A7: for I1,I2 being Element of A st P[I1] & P[I2] holds P[I1\;I2]
    proof
      let I1,I2 be Element of A such that
A8:   P[I1] & P[I2];
      let s be Element of S;
      thus f1.(s, I1\;I2) = f1.(f1.(s, I1), I2) by Def29
      .= f1.(f2.(s, I1), I2) by A8
      .= f2.(f2.(s, I1), I2) by A8
      .= f2.(s, I1\;I2) by Def29;
    end;
A9: for C,I1,I2 being Element of A st P[C] & P[I1] & P[I2]
    holds P[if-then-else(C,I1,I2)]
    proof
      let C,I1,I2 be Element of A such that
A10:   P[C] & P[I1] & P[I2];
      let s be Element of S;
A11:   f1 satisfies_if_wrt T & f2 satisfies_if_wrt T by Def32;
A12:   f1.(s, C) = f2.(s, C) by A10;
      per cases;
      suppose
A13:     f1.(s,C) in T;
        hence f1.(s, if-then-else(C,I1,I2)) = f1.(f1.(s, C), I1) by A11,Def30
        .= f2.(f1.(s, C), I1) by A10
        .= f2.(s, if-then-else(C,I1,I2)) by A11,A12,A13,Def30;
      end;
      suppose
A14:     f1.(s,C) nin T;
        hence f1.(s, if-then-else(C,I1,I2)) = f1.(f1.(s, C), I2) by A11,Def30
        .= f2.(f1.(s, C), I2) by A10
        .= f2.(s, if-then-else(C,I1,I2)) by A11,A12,A14,Def30;
      end;
    end;
A15: for C,I being Element of A st P[C] & P[I] holds P[while(C,I)]
    proof
      let C,I be Element of A such that
A16:   P[C] & P[I];
      let s be Element of S;
       now assume f1 iteration_terminates_for I\;C, f1.(s,C);
        then consider r being non empty FinSequence of S such that
A17:     r.1 = f1.(s, C) & r.len r nin T and
A18:     for i being Nat st 1 <= i & i < len r
        holds r.i in T & r.(i+1) = f1.(r.i, I\;C) by Def33;
A19:     f1.(s, C) = f2.(s, C) by A16;
A20:     now
          let i be Nat;
          assume
A21:       1 <= i & i < len r;
          hence r.i in T by A18;
          then reconsider si = r.i as Element of S;
          thus r.(i+1) = f1.(si, I\;C) by A18,A21
          .= f1.(f1.(si,I),C) by Def29
          .= f1.(f2.(si,I),C) by A16
          .= f2.(f2.(si,I),C) by A16
          .= f2.(r.i, I\;C) by Def29;
        end;
        thus f1.(s, while(C,I)) = r.len r by A17,A18,Th86
        .= f2.(s, while(C,I)) by A17,A19,A20,Th86;
      end;
      hence thesis by A2;
    end;
     now
      let sI be Element of [:S, the carrier of A:];
      consider s,I being set such that
A22:   s in S & I in the carrier of A & sI = [s,I] by ZFMISC_1:def 2;
      reconsider I as Element of A by A22;
      reconsider s as Element of S by A22;
       P[I] from StructInd(A3,A6,A7,A9,A15);
      then f1.(s,I) = f2.(s,I);
      hence f1.sI = f2.sI by A22;
    end;
    hence f1 = f2 by FUNCT_2:113;
  end;

definition
  let A be preIfWhileAlgebra;
  let S be non empty set;
  let T be Subset of S;
  let f be ExecutionFunction of A, S, T;
    defpred Q[set] means
    [:S, ElementaryInstructions A:] c= $1 & [:S, {EmptyIns A}:] c= $1 &
    for s being Element of S
    for C,I,J being Element of A holds
    ([s,I] in $1 & [f.(s,I), J] in $1 implies [s, I\;J] in $1) &
    ([s,C] in $1 & [f.(s,C), I] in $1 & f.(s, C) in T
    implies [s, if-then-else(C,I,J)] in $1) &
    ([s,C] in $1 & [f.(s,C), J] in $1 & f.(s, C) nin T
    implies [s, if-then-else(C,I,J)] in $1) &
    ([s,C] in $1 &
     (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
     for i being Nat st 1 <= i & i < len r
     holds r.i in T & [r.i, I\;C] in $1 & r.(i+1) = f.(r.i, I\;C))
    implies [s, while(C,I)] in $1);

  func TerminatingPrograms(A,S,T,f) -> Subset of [:S, the carrier of A:] means:
Def35:
  ([:S, ElementaryInstructions A:] c= it & [:S, {EmptyIns A}:] c= it &
   for s being Element of S
   for C,I,J being Element of A holds
   ([s,I] in it & [f.(s,I), J] in it implies [s, I\;J] in it) &
   ([s,C] in it & [f.(s,C), I] in it & f.(s, C) in T
   implies [s, if-then-else(C,I,J)] in it) &
   ([s,C] in it & [f.(s,C), J] in it & f.(s, C) nin T
   implies [s, if-then-else(C,I,J)] in it) &
   ([s,C] in it &
    (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
    for i being Nat st 1 <= i & i < len r
    holds r.i in T & [r.i, I\;C] in it & r.(i+1) = f.(r.i, I\;C))
    implies [s, while(C,I)] in it)
  ) &
  for P being Subset of [:S, the carrier of A:] st
    [:S, ElementaryInstructions A:] c= P & [:S, {EmptyIns A}:] c= P &
    for s being Element of S
    for C,I,J being Element of A holds
    ([s,I] in P & [f.(s,I), J] in P implies [s, I\;J] in P) &
    ([s,C] in P & [f.(s,C), I] in P & f.(s, C) in T
    implies [s, if-then-else(C,I,J)] in P) &
    ([s,C] in P & [f.(s,C), J] in P & f.(s, C) nin T
    implies [s, if-then-else(C,I,J)] in P) &
    ([s,C] in P &
     (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
     for i being Nat st 1 <= i & i < len r
     holds r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C))
     implies [s, while(C,I)] in P)
  holds it c= P;
  existence
  proof
    set QQ = {Z where Z is Subset of [:S, the carrier of A:]: Q[Z]};
    set IT = meet QQ;
     Q[ [#] [:S, the carrier of A:] ]
    proof set Y = [#] [:S, the carrier of A:];
       {EmptyIns A} c= the carrier of A by ZFMISC_1:37;
      hence [:S, ElementaryInstructions A:] c= Y & [:S, {EmptyIns A}:] c= Y
      by ZFMISC_1:118;
      thus for s being Element of S
      for C,I,J being Element of A holds
      ([s,I] in Y & [f.(s,I), J] in Y implies [s, I\;J] in Y) &
      ([s,C] in Y & [f.(s,C), I] in Y & f.(s, C) in T
      implies [s, if-then-else(C,I,J)] in Y) &
      ([s,C] in Y & [f.(s,C), J] in Y & f.(s, C) nin T
      implies [s, if-then-else(C,I,J)] in Y) &
      ([s,C] in Y &
      (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
      for i being Nat st 1 <= i & i < len r
      holds r.i in T & [r.i, I\;C] in Y & r.(i+1) = f.(r.i, I\;C))
      implies [s, while(C,I)] in Y)
      by ZFMISC_1:106;
    end;
then A1: [:S, the carrier of A:] in QQ;
    then reconsider IT as Subset of [:S, the carrier of A:] by SETFAM_1:4;
    take IT;
     now
      let a be set;
      assume a in QQ;
      then ex Z being Subset of [:S, the carrier of A:] st a = Z & Q[Z];
      hence [:S, ElementaryInstructions A:] c= a;
    end;
    hence [:S, ElementaryInstructions A:] c= IT by A1,SETFAM_1:6;
     now
      let a be set;
      assume a in QQ;
      then ex Z being Subset of [:S, the carrier of A:] st a = Z & Q[Z];
      hence [:S, {EmptyIns A}:] c= a;
    end;
    hence [:S, {EmptyIns A}:] c= IT by A1,SETFAM_1:6;
    hereby
      let s be Element of S;
      let C,I,J be Element of A;
      hereby assume
A2:     [s,I] in IT & [f.(s,I), J] in IT;
         now let a be set;
          assume a in QQ;
          then [s,I] in a & [f.(s,I), J] in a &
          ex Z being Subset of [:S, the carrier of A:] st a = Z & Q[Z]
          by A2,SETFAM_1:def 1;
          hence [s, I\;J] in a;
        end;
        hence [s, I\;J] in IT by A1,SETFAM_1:def 1;
      end;
      hereby assume
A3:     [s,C] in IT & [f.(s,C), I] in IT & f.(s, C) in T;
         now let a be set;
          assume a in QQ;
          then [s,C] in a & [f.(s,C), I] in a &
          ex Z being Subset of [:S, the carrier of A:] st a = Z & Q[Z]
          by A3,SETFAM_1:def 1;
          hence [s, if-then-else(C,I,J)] in a by A3;
        end;
        hence [s, if-then-else(C,I,J)] in IT by A1,SETFAM_1:def 1;
      end;
      hereby assume
A4:     [s,C] in IT & [f.(s,C), J] in IT & f.(s, C) nin T;
         now let a be set;
          assume a in QQ;
          then [s,C] in a & [f.(s,C), J] in a &
          ex Z being Subset of [:S, the carrier of A:] st a = Z & Q[Z]
          by A4,SETFAM_1:def 1;
          hence [s, if-then-else(C,I,J)] in a by A4;
        end;
        hence [s, if-then-else(C,I,J)] in IT by A1,SETFAM_1:def 1;
      end;
      assume
A5:   [s,C] in IT;
      given r being non empty FinSequence of S such that
A6:   r.1 = f.(s,C) & r.len r nin T &
      for i being Nat st 1 <= i & i < len r
      holds r.i in T & [r.i, I\;C] in IT & r.(i+1) = f.(r.i, I\;C);
       now let a be set;
        assume
A7:     a in QQ;
A8:     now
          let i be Nat; assume 1 <= i & i < len r;
          then r.i in T & [r.i, I\;C] in IT & r.(i+1) = f.(r.i, I\;C) by A6;
          hence r.i in T & [r.i, I\;C] in a & r.(i+1) = f.(r.i, I\;C)
          by A7,SETFAM_1:def 1;
        end;
         [s,C] in a &
        ex Z being Subset of [:S, the carrier of A:] st a = Z & Q[Z]
        by A5,A7,SETFAM_1:def 1;
        hence [s, while(C,I)] in a by A6,A8;
      end;
      hence [s, while(C,I)] in IT by A1,SETFAM_1:def 1;
    end;
    let Y be Subset of [:S, the carrier of A:];
    assume Q[Y];
    then Y in QQ;
    hence thesis by SETFAM_1:4;
  end;
  uniqueness
  proof
    let Y1,Y2 being Subset of [:S, the carrier of A:] such that
A9: Q[Y1] and
A10: for Y being Subset of [:S, the carrier of A:] st Q[Y] holds Y1 c= Y and
A11: Q[Y2] and
A12: for Y being Subset of [:S, the carrier of A:] st Q[Y] holds Y2 c= Y;
    thus Y1 c= Y2 by A10,A11;
    thus thesis by A9,A12;
  end;
end;

definition
  let A be preIfWhileAlgebra;
  let I be Element of A;
  attr I is absolutely-terminating means:
Def36:
  for S being non empty set, s being Element of S
  for T being Subset of S
  for f being ExecutionFunction of A, S, T
  holds [s,I] in TerminatingPrograms(A,S,T,f);
end;

theorem Th94:
  I in ElementaryInstructions A implies [s, I] in TerminatingPrograms(A,S,T,f)
  proof assume
     I in ElementaryInstructions A;
    then [s, I] in [:S, ElementaryInstructions A:] &
    [:S, ElementaryInstructions A:] c= TerminatingPrograms(A,S,T,f)
    by Def35,ZFMISC_1:106;
    hence thesis;
  end;

theorem
   I in ElementaryInstructions A implies I is absolutely-terminating
  proof assume
A1: I in ElementaryInstructions A;
    let S;
    thus thesis by A1,Th94;
  end;

theorem Th96:
  [s, EmptyIns A] in TerminatingPrograms(A,S,T,f)
  proof set I = EmptyIns A;
     I in {I} by TARSKI:def 1;
    then [s, I] in [:S, {I}:] & [:S, {I}:] c= TerminatingPrograms(A,S,T,f)
      by Def35,ZFMISC_1:106;
    hence thesis;
  end;

registration
  let A;
  cluster EmptyIns A -> absolutely-terminating;
  coherence
  proof let S;
    thus thesis by Th96;
  end;
end;

registration
  let A;
  cluster absolutely-terminating Element of A;
  existence
  proof
    take EmptyIns A;
    thus thesis;
  end;
end;

theorem Th97:
  A is free & [s, I\;J] in TerminatingPrograms(A,S,T,f) implies
  [s,I] in TerminatingPrograms(A,S,T,f) &
  [f.(s,I), J] in TerminatingPrograms(A,S,T,f)
  proof set TP = TerminatingPrograms(A,S,T,f);
    assume
A1: A is free & [s, I\;J] in TP;
    reconsider P = TP \ {[s, I\;J]} as Subset of [:S, the carrier of A:];
A2: [:S, ElementaryInstructions A:] c= P
    proof
      let x,y be set; assume
A3:   [x,y] in [:S, ElementaryInstructions A:];
      then I <> I\;J & J <> I\;J & y in ElementaryInstructions A
      by A1,Th73,ZFMISC_1:106;
      then y <> I\;J by Th50;
      then [:S, ElementaryInstructions A:] c= TP &
      [x,y] <> [s, I\;J] by Def35,ZFMISC_1:33;
      then [x,y] nin {[s, I\;J]} & [x,y] in TP
      by A3,TARSKI:def 1;
      hence thesis by XBOOLE_0:def 4;
    end;
A4: [:S, {EmptyIns A}:] c= P
    proof
      let x,y be set; assume
A5:   [x,y] in [:S, {EmptyIns A}:];
      then y in {EmptyIns A} by ZFMISC_1:106;
      then y = EmptyIns A by TARSKI:def 1;
      then y <> I\;J by A1,Th72;
      then [:S, {EmptyIns A}:] c= TP &
      [x,y] <> [s, I\;J] by Def35,ZFMISC_1:33;
      then [x,y] nin {[s, I\;J]} & [x,y] in TP
      by A5,TARSKI:def 1;
      hence thesis by XBOOLE_0:def 4;
    end;
    set rr = s, IJ = I\;J;
A6: now let s be Element of S;
      let C,I,J be Element of A;
      hereby assume
A7:     [s,C] in P & [f.(s,C), I] in P & f.(s, C) in T;
        then [s,C] in TP & [f.(s,C), I] in TP & IJ <> if-then-else(C,I,J)
        by A1,Th73,ZFMISC_1:64;
        then [s, if-then-else(C,I,J)] in TP & [rr,IJ] <> [s, if-then-else(C,I,
J)]
        by A7,Def35,ZFMISC_1:33;
        hence [s, if-then-else(C,I,J)] in P by ZFMISC_1:64;
      end;
      hereby assume
A8:     [s,C] in P & [f.(s,C), J] in P & f.(s, C) nin T;
        then [s,C] in TP & [f.(s,C), J] in TP & IJ <> if-then-else(C,I,J)
        by A1,Th73,ZFMISC_1:64;
        then [s, if-then-else(C,I,J)] in TP & [rr,IJ] <> [s, if-then-else(C,I,
J)]
        by A8,Def35,ZFMISC_1:33;
        hence [s, if-then-else(C,I,J)] in P by ZFMISC_1:64;
      end;
      assume
A9:   [s,C] in P;
      given r being non empty FinSequence of S such that
A10:   r.1 = f.(s,C) & r.len r nin T and
A11:   for i being Nat st 1 <= i & i < len r
      holds r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C);
A12:   now let i be Nat; assume 1 <= i & i < len r;
        then r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C) by A11;
        hence r.i in T & [r.i, I\;C] in TP & r.(i+1) = f.(r.i, I\;C)
        by ZFMISC_1:64;
      end;
       [s,C] in TP & while(C,I) <> IJ by A1,A9,Th73,ZFMISC_1:64;
      then [s, while(C,I)] in TP & [s, while(C,I)] <> [rr,IJ]
      by A10,A12,Def35,ZFMISC_1:33;
      hence [s, while(C,I)] in P by ZFMISC_1:64;
    end;
    hereby assume
A13:   [rr,I] nin TP;
       now let q be Element of S;
        let C,I',J' be Element of A;
        assume [q,I'] in P & [f.(q,I'), J'] in P;
then A14:     [q,I'] in TP &
        [f.(q,I'), J'] in TP by ZFMISC_1:64;
        then q <> rr or I'\;J' <> I\;J by A1,A13,Th73;
        then [q, I'\;J'] in TP & [q,I'\;J'] <> [rr,I\;J]
        by A14,Def35,ZFMISC_1:33;
        hence [q, I'\;J'] in P by ZFMISC_1:64;
      end;
      then for s being Element of S
      for C,I,J being Element of A holds
      ([s,I] in P & [f.(s,I), J] in P implies [s, I\;J] in P) &
      ([s,C] in P & [f.(s,C), I] in P & f.(s, C) in T
      implies [s, if-then-else(C,I,J)] in P) &
      ([s,C] in P & [f.(s,C), J] in P & f.(s, C) nin T
      implies [s, if-then-else(C,I,J)] in P) &
      ([s,C] in P &
      (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
      for i being Nat st 1 <= i & i < len r
      holds r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C))
      implies [s, while(C,I)] in P) by A6;
      then TP c= P by A2,A4,Def35;
      hence contradiction by A1,ZFMISC_1:64;
    end;
    assume
A15: [f.(s,I), J] nin TP;
     now let q be Element of S;
      let C,I',J' be Element of A;
      assume
A16:   [q,I'] in P & [f.(q,I'), J'] in P;
then A17:   [q,I'] in TP & [f.(q,I'), J'] in TP by ZFMISC_1:64;
       f.(q,I') <> f.(s,I) or J' <> J by A15,A16,ZFMISC_1:64;
      then q <> s or I'\;J' <> I\;J by A1,Th73;
      then [q, I'\;J'] in TP & [q,I'\;J'] <> [rr,I\;J]
      by A17,Def35,ZFMISC_1:33;
      hence [q, I'\;J'] in P by ZFMISC_1:64;
    end;
    then for s being Element of S
    for C,I,J being Element of A holds
    ([s,I] in P & [f.(s,I), J] in P implies [s, I\;J] in P) &
    ([s,C] in P & [f.(s,C), I] in P & f.(s, C) in T
    implies [s, if-then-else(C,I,J)] in P) &
    ([s,C] in P & [f.(s,C), J] in P & f.(s, C) nin T
    implies [s, if-then-else(C,I,J)] in P) &
    ([s,C] in P &
    (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
    for i being Nat st 1 <= i & i < len r
    holds r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C))
    implies [s, while(C,I)] in P) by A6;
    then TP c= P by A2,A4,Def35;
    hence contradiction by A1,ZFMISC_1:64;
  end;

registration
  let A;
  let I,J be absolutely-terminating Element of A;
  cluster I\;J -> absolutely-terminating;
  coherence
  proof let S,s,T,f;
     [s,I] in TerminatingPrograms(A,S,T,f) &
    [f.(s,I),J] in TerminatingPrograms(A,S,T,f) by Def36;
    hence thesis by Def35;
  end;
end;

theorem Th98:
  A is free & [s, if-then-else(C,I,J)] in TerminatingPrograms(A,S,T,f)
  implies [s,C] in TerminatingPrograms(A,S,T,f) &
  (f.(s,C) in T implies [f.(s,C), I] in TerminatingPrograms(A,S,T,f)) &
  (f.(s,C) nin T implies [f.(s,C), J] in TerminatingPrograms(A,S,T,f))
  proof set TP = TerminatingPrograms(A,S,T,f);
    set rr = s, IJ = if-then-else(C,I,J);
    assume
A1: A is free & [s, IJ] in TP;
    reconsider P = TP \ {[s, IJ]} as Subset of [:S, the carrier of A:];
A2: [:S, ElementaryInstructions A:] c= P
    proof
      let x,y be set; assume
A3:   [x,y] in [:S, ElementaryInstructions A:];
      then y in ElementaryInstructions A by ZFMISC_1:106;
      then y <> IJ by Th51;
      then [:S, ElementaryInstructions A:] c= TP &
      [x,y] <> [s, IJ] by Def35,ZFMISC_1:33;
      then [x,y] nin {[s, IJ]} & [x,y] in TP
      by A3,TARSKI:def 1;
      hence thesis by XBOOLE_0:def 4;
    end;
A4: [:S, {EmptyIns A}:] c= P
    proof
      let x,y be set; assume
A5:   [x,y] in [:S, {EmptyIns A}:];
      then y in {EmptyIns A} by ZFMISC_1:106;
      then y = EmptyIns A by TARSKI:def 1;
      then y <> IJ by A1,Th72;
      then [:S, {EmptyIns A}:] c= TP & [x,y] <> [s, IJ]
      by Def35,ZFMISC_1:33;
      then [x,y] nin {[s, IJ]} & [x,y] in TP by A5,TARSKI:def 1;
      hence thesis by XBOOLE_0:def 4;
    end;
A6: now let s be Element of S;
      let C,I,J be Element of A;
      hereby assume [s,I] in P & [f.(s,I), J] in P;
        then [s,I] in TP & [f.(s,I), J] in TP & IJ <> I\;J
        by A1,Th73,ZFMISC_1:64;
        then [s, I\;J] in TP & [rr,IJ] <> [s, I\;J] by Def35,ZFMISC_1:33;
        hence [s, I\;J] in P by ZFMISC_1:64;
      end;
      assume
A7:   [s,C] in P;
      given r being non empty FinSequence of S such that
A8:   r.1 = f.(s,C) & r.len r nin T and
A9:   for i being Nat st 1 <= i & i < len r
      holds r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C);
A10:   now let i be Nat; assume 1 <= i & i < len r;
        then r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C) by A9;
        hence r.i in T & [r.i, I\;C] in TP & r.(i+1) = f.(r.i, I\;C)
          by ZFMISC_1:64;
      end;
       [s,C] in TP & while(C,I) <> IJ by A1,A7,Th74,ZFMISC_1:64;
      then [s, while(C,I)] in TP & [s, while(C,I)] <> [rr,IJ]
      by A8,A10,Def35,ZFMISC_1:33;
      hence [s, while(C,I)] in P by ZFMISC_1:64;
    end;
    hereby assume
A11:   [s,C] nin TerminatingPrograms(A,S,T,f);
A12:   now let s be Element of S;
        let C',I,J be Element of A;
        assume
A13:     [s,C'] in P & [f.(s,C'), I] in P & f.(s, C') in T;
then A14:     [s,C'] in TP & [f.(s,C'), I] in TP by ZFMISC_1:64;
        then (IJ <> if-then-else(C',I,J) or rr <> s) by A1,A11,Th74;
        then [s, if-then-else(C',I,J)] in TP & [rr,IJ] <> [s, if-then-else(C',
I,J)]
        by A13,A14,Def35,ZFMISC_1:33;
        hence [s, if-then-else(C',I,J)] in P by ZFMISC_1:64;
      end;
       now let s be Element of S;
        let C',I,J be Element of A;
        assume
A15:     [s,C'] in P & [f.(s,C'), J] in P & f.(s, C') nin T;
then A16:     [s,C'] in TP & [f.(s,C'), J] in TP by ZFMISC_1:64;
        then (IJ <> if-then-else(C',I,J) or rr <> s) by A1,A11,Th74;
        then [s, if-then-else(C',I,J)] in TP & [rr,IJ] <> [s, if-then-else(C',
I,J)]
        by A15,A16,Def35,ZFMISC_1:33;
        hence [s, if-then-else(C',I,J)] in P by ZFMISC_1:64;
      end;
      then TP c= P by A2,A4,A6,A12,Def35;
      hence contradiction by A1,ZFMISC_1:64;
    end;
    thus (f.(s,C) in T implies [f.(s,C), I] in TerminatingPrograms(A,S,T,f))
    proof assume
A17:   f.(s,C) in T & [f.(s,C), I] nin TP;
A18:   now let s be Element of S;
        let C',I',J be Element of A;
        assume
A19:     [s,C'] in P & [f.(s,C'), I'] in P & f.(s, C') in T;
then A20:     [s,C'] in TP & [f.(s,C'), I'] in TP by ZFMISC_1:64;
         f.(s,C') <> f.(rr,C) or I <> I' by A17,A19,ZFMISC_1:64;
        then (IJ <> if-then-else(C',I',J) or rr <> s) by A1,Th74;
        then [s,if-then-else(C',I',J)] in TP & [rr,IJ] <> [s,if-then-else(C',
I',J)]
        by A19,A20,Def35,ZFMISC_1:33;
        hence [s, if-then-else(C',I',J)] in P by ZFMISC_1:64;
      end;
       now let s be Element of S;
        let C',I,J' be Element of A;
        assume
A21:     [s,C'] in P & [f.(s,C'), J'] in P & f.(s, C') nin T;
then A22:     [s,C'] in TP & [f.(s,C'), J'] in TP by ZFMISC_1:64;
         (IJ <> if-then-else(C',I,J') or rr <> s) by A1,A17,A21,Th74;
        then [s,if-then-else(C',I,J')] in TP & [rr,IJ] <> [s,if-then-else(C',I
,J')]
        by A21,A22,Def35,ZFMISC_1:33;
        hence [s, if-then-else(C',I,J')] in P by ZFMISC_1:64;
      end;
      then TP c= P by A2,A4,A6,A18,Def35;
      hence contradiction by A1,ZFMISC_1:64;
    end;
    assume
A23: f.(s,C) nin T & [f.(s,C), J] nin TP;
A24: now let s be Element of S;
      let C',I',J be Element of A;
      assume
A25:   [s,C'] in P & [f.(s,C'), I'] in P & f.(s, C') in T;
then A26:   [s,C'] in TP & [f.(s,C'), I'] in TP by ZFMISC_1:64;
       (IJ <> if-then-else(C',I',J) or rr <> s) by A1,A23,A25,Th74;
      then [s,if-then-else(C',I',J)] in TP & [rr,IJ] <> [s,if-then-else(C',I',
J)]
      by A25,A26,Def35,ZFMISC_1:33;
      hence [s, if-then-else(C',I',J)] in P by ZFMISC_1:64;
    end;
     now let s be Element of S;
      let C',I,J' be Element of A;
      assume
A27:   [s,C'] in P & [f.(s,C'), J'] in P & f.(s, C') nin T;
then A28:   [s,C'] in TP & [f.(s,C'), J'] in TP by ZFMISC_1:64;
       f.(s,C') <> f.(rr,C) or J <> J' by A23,A27,ZFMISC_1:64;
      then (IJ <> if-then-else(C',I,J') or rr <> s) by A1,Th74;
      then [s,if-then-else(C',I,J')] in TP & [rr,IJ] <> [s,if-then-else(C',I,
J')]
      by A27,A28,Def35,ZFMISC_1:33;
      hence [s, if-then-else(C',I,J')] in P by ZFMISC_1:64;
    end;
    then TP c= P by A2,A4,A6,A24,Def35;
    hence contradiction by A1,ZFMISC_1:64;
  end;

registration
  let A;
  let C,I,J be absolutely-terminating Element of A;
  cluster if-then-else(C,I,J) -> absolutely-terminating;
  coherence
  proof let S,s,T,f;
     [s,C] in TerminatingPrograms(A,S,T,f) & (f.(s,C) in T or f.(s,C) nin T) &
    [f.(s,C),I] in TerminatingPrograms(A,S,T,f) &
    [f.(s,C),J] in TerminatingPrograms(A,S,T,f) by Def36;
    hence thesis by Def35;
  end;
end;

theorem Th99:
  A is free & [s, while(C,I)] in TerminatingPrograms(A,S,T,f)
  implies [s,C] in TerminatingPrograms(A,S,T,f) &
  ex r being non empty FinSequence of S st
     r.1 = f.(s,C) & r.len r nin T &
     for i being Nat st 1 <= i & i < len r
     holds r.i in T & [r.i, I\;C] in TerminatingPrograms(A,S,T,f) &
      r.(i+1) = f.(r.i, I\;C)
  proof set TP = TerminatingPrograms(A,S,T,f);
    set rr = s, IJ = while(C,I);
    assume
A1: A is free & [s, IJ] in TP;
    reconsider P = TP \ {[s, IJ]} as Subset of [:S, the carrier of A:];
A2: [:S, ElementaryInstructions A:] c= P
    proof
      let x,y be set; assume
A3:   [x,y] in [:S, ElementaryInstructions A:];
      then y in ElementaryInstructions A by ZFMISC_1:106;
      then y <> IJ by Th52;
      then [:S, ElementaryInstructions A:] c= TP &
      [x,y] <> [s, IJ] by Def35,ZFMISC_1:33;
      then [x,y] nin {[s, IJ]} & [x,y] in TP
      by A3,TARSKI:def 1;
      hence thesis by XBOOLE_0:def 4;
    end;
A4: [:S, {EmptyIns A}:] c= P
    proof
      let x,y be set; assume
A5:   [x,y] in [:S, {EmptyIns A}:];
      then y in {EmptyIns A} by ZFMISC_1:106;
      then y = EmptyIns A by TARSKI:def 1;
      then y <> IJ by A1,Th72;
      then [:S, {EmptyIns A}:] c= TP &
      [x,y] <> [s, IJ] by Def35,ZFMISC_1:33;
      then [x,y] nin {[s, IJ]} & [x,y] in TP
      by A5,TARSKI:def 1;
      hence thesis by XBOOLE_0:def 4;
    end;
A6: now let s be Element of S;
      let C,I,J be Element of A;
      hereby assume [s,I] in P & [f.(s,I), J] in P;
        then [s,I] in TP & [f.(s,I), J] in TP & IJ <> I\;J
        by A1,Th73,ZFMISC_1:64;
        then [s, I\;J] in TP & [rr,IJ] <> [s, I\;J] by Def35,ZFMISC_1:33;
        hence [s, I\;J] in P by ZFMISC_1:64;
      end;
      hereby assume
A7:     [s,C] in P & [f.(s,C), I] in P & f.(s, C) in T;
        then [s,C] in TP & [f.(s,C), I] in TP & IJ <> if-then-else(C,I,J)
        by A1,Th74,ZFMISC_1:64;
        then [s, if-then-else(C,I,J)] in TP & [rr,IJ] <> [s, if-then-else(C,I,
J)]
        by A7,Def35,ZFMISC_1:33;
        hence [s, if-then-else(C,I,J)] in P by ZFMISC_1:64;
      end;
      hereby assume
A8:     [s,C] in P & [f.(s,C), J] in P & f.(s, C) nin T;
        then [s,C] in TP & [f.(s,C), J] in TP & IJ <> if-then-else(C,I,J)
        by A1,Th74,ZFMISC_1:64;
        then [s, if-then-else(C,I,J)] in TP & [rr,IJ] <> [s, if-then-else(C,I,
J)]
        by A8,Def35,ZFMISC_1:33;
        hence [s, if-then-else(C,I,J)] in P by ZFMISC_1:64;
      end;
    end;
    hereby assume
A9:   [s,C] nin TerminatingPrograms(A,S,T,f);
       now let s be Element of S;
        let C',I',J be Element of A;
        assume
A10:     [s,C'] in P;
        given r being non empty FinSequence of S such that
A11:     r.1 = f.(s,C') & r.len r nin T and
A12:     for i being Nat st 1 <= i & i < len r
        holds r.i in T & [r.i, I'\;C'] in P & r.(i+1) = f.(r.i, I'\;C');
A13:     now let i be Nat; assume 1 <= i & i < len r;
          then r.i in T & [r.i, I'\;C'] in P & r.(i+1) = f.(r.i, I'\;C') by A12
;
          hence r.i in T & [r.i, I'\;C'] in TP & r.(i+1) = f.(r.i, I'\;C')
          by ZFMISC_1:64;
        end;
A14:     [s,C'] in TP by A10,ZFMISC_1:64;
        then while(C',I') <> IJ or s <> rr by A1,A9,Th75;
        then [s, while(C',I')] in TP & [s, while(C',I')] <> [rr,IJ]
        by A11,A13,A14,Def35,ZFMISC_1:33;
        hence [s, while(C',I')] in P by ZFMISC_1:64;
      end;
      then for s being Element of S
      for C,I,J being Element of A holds
      ([s,I] in P & [f.(s,I), J] in P implies [s, I\;J] in P) &
      ([s,C] in P & [f.(s,C), I] in P & f.(s, C) in T
      implies [s, if-then-else(C,I,J)] in P) &
      ([s,C] in P & [f.(s,C), J] in P & f.(s, C) nin T
      implies [s, if-then-else(C,I,J)] in P) &
      ([s,C] in P &
      (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
      for i being Nat st 1 <= i & i < len r
      holds r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C))
      implies [s, while(C,I)] in P) by A6;
      then TP c= P by A2,A4,Def35;
      hence contradiction by A1,ZFMISC_1:64;
    end;
    assume
A15: not ex r being non empty FinSequence of S st
    r.1 = f.(rr,C) & r.len r nin T &
    for i being Nat st 1 <= i & i < len r
    holds r.i in T & [r.i, I\;C] in TP & r.(i+1) = f.(r.i, I\;C);
     now let s be Element of S;
      let C',I',J be Element of A; assume
A16:   [s,C'] in P;
      given r being non empty FinSequence of S such that
A17:   r.1 = f.(s,C') & r.len r nin T and
A18:   for i being Nat st 1 <= i & i < len r
      holds r.i in T & [r.i, I'\;C'] in P & r.(i+1) = f.(r.i, I'\;C');
A19:   now let i be Nat; assume 1 <= i & i < len r;
        then r.i in T & [r.i, I'\;C'] in P & r.(i+1) = f.(r.i, I'\;C') by A18;
        hence r.i in T & [r.i, I'\;C'] in TP & r.(i+1) = f.(r.i, I'\;C')
        by ZFMISC_1:64;
      end;
A20:   [s,C'] in TP by A16,ZFMISC_1:64;
       I <> I' or C <> C' or s <> rr by A15,A17,A19;
      then while(C',I') <> IJ or s <> rr by A1,Th75;
      then [s, while(C',I')] in TP & [s, while(C',I')] <> [rr,IJ]
      by A17,A19,A20,Def35,ZFMISC_1:33;
      hence [s, while(C',I')] in P by ZFMISC_1:64;
    end;
    then for s being Element of S
    for C,I,J being Element of A holds
    ([s,I] in P & [f.(s,I), J] in P implies [s, I\;J] in P) &
    ([s,C] in P & [f.(s,C), I] in P & f.(s, C) in T
    implies [s, if-then-else(C,I,J)] in P) &
    ([s,C] in P & [f.(s,C), J] in P & f.(s, C) nin T
    implies [s, if-then-else(C,I,J)] in P) &
    ([s,C] in P &
    (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
    for i being Nat st 1 <= i & i < len r
    holds r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C))
    implies [s, while(C,I)] in P) by A6;
    then TP c= P by A2,A4,Def35;
    hence contradiction by A1,ZFMISC_1:64;
  end;

theorem
   A is free & [s, while(C,I)] in TerminatingPrograms(A,S,T,f) & f.(s,C) in T
  implies [f.(s,C), I] in TerminatingPrograms(A,S,T,f)
  proof set TP = TerminatingPrograms(A,S,T,f);
    set rr = s, IJ = while(C,I);
    assume
A1: A is free & [s, IJ] in TP & f.(s,C) in T;
    then consider r being non empty FinSequence of S such that
A2: r.1 = f.(s,C) & r.len r nin T and
A3: for i being Nat st 1 <= i & i < len r
    holds r.i in T & [r.i, I\;C] in TP & r.(i+1) = f.(r.i, I\;C) by Th99;
     len r <> 0 by FINSEQ_1:25;
    then len r >= 1 by NAT_1:14;
    then 1 < len r by A1,A2,XXREAL_0:1;
    then [r.1, I\;C] in TP by A3;
    hence [f.(s,C), I] in TP by A1,A2,Th97;
  end;

theorem
   for C,I being absolutely-terminating Element of A
  st f iteration_terminates_for I\;C, f.(s,C)
  holds [s, while(C,I)] in TerminatingPrograms(A,S,T,f)
  proof
    let C,I be absolutely-terminating Element of A;
    given r being non empty FinSequence of S such that
A1: r.1 = f.(s,C) & r.len r nin T and
A2: for i being Nat st 1 <= i & i < len r
    holds r.i in T & r.(i+1) = f.(r.i, I\;C);
A3: now let i be Nat; assume
A4:   1 <= i & i < len r;
      hence r.i in T by A2;
      hence [r.i, I\;C] in TerminatingPrograms(A,S,T,f) &
      r.(i+1) = f.(r.i, I\;C) by A2,A4,Def36;
    end;
     [s,C] in TerminatingPrograms(A,S,T,f) by Def36;
    hence [s, while(C,I)] in TerminatingPrograms(A,S,T,f) by A1,A3,Def35;
  end;

Lm3:
  for A being free ECIW-strict preIfWhileAlgebra
  for f1,f2 being ExecutionFunction of A, S, T
  st f1|[:S, ElementaryInstructions A:] = f2|[:S, ElementaryInstructions A:]
  for I being Element of A
  for s being Element of S st [s,I] in TerminatingPrograms(A,S,T,f1)
  holds [s,I] in TerminatingPrograms(A,S,T,f2) & f1.(s,I) = f2.(s,I)
  proof
    let A be free ECIW-strict preIfWhileAlgebra;
    let f1,f2 be ExecutionFunction of A, S, T such that
A1: f1|[:S, ElementaryInstructions A:] = f2|[:S, ElementaryInstructions A:];
    set g = f1|[:S, ElementaryInstructions A:];
    set TP1 = TerminatingPrograms(A,S,T,f1);
    set TP2 = TerminatingPrograms(A,S,T,f2);
    defpred P[Element of A] means
    for s st [s,$1] in TP1 holds [s,$1] in TP2 & f1.(s,$1) = f2.(s,$1);
A2: for I being Element of A st I in ElementaryInstructions A
    holds P[I]
    proof
      let I be Element of A; assume
A3:   I in ElementaryInstructions A;
      let s be Element of S; assume [s,I] in TP1;
      thus [s,I] in TP2 by A3,Th94;
A4:   [s,I] in [:S, ElementaryInstructions A:] by A3,ZFMISC_1:106;
      hence f1.(s,I) = g.[s,I] by FUNCT_1:72 .= f2.(s,I) by A1,A4,FUNCT_1:72;
    end;
A5: P[EmptyIns A]
    proof let s be Element of S;
       f1.(s,EmptyIns A) = s by Def28;
      hence thesis by Def28,Th96;
    end;
A6: for I1,I2 being Element of A st P[I1] & P[I2] holds P[I1\;I2]
    proof
      let I1,I2 be Element of A such that
A7:   P[I1] & P[I2];
      let s be Element of S; assume
       [s, I1\;I2] in TP1;
      then [s, I1] in TP1 & [f1.(s,I1),I2] in TP1 by Th97;
      then [s, I1] in TP2 & [f1.(s,I1),I2] in TP2 & f1.(s,I1) = f2.(s,I1) &
      f1.(f1.(s,I1),I2) = f2.(f1.(s,I1),I2) & f1.(f1.(s,I1),I2) = f1.(s,I1\;I2)
      by A7,Def29;
      hence thesis by Def29,Def35;
    end;
A8: for C,I1,I2 being Element of A st P[C] & P[I1] & P[I2]
    holds P[if-then-else(C,I1,I2)]
    proof
      let C,I1,I2 be Element of A such that
A9:   P[C] & P[I1] & P[I2];
A10:   f1 satisfies_if_wrt T & f2 satisfies_if_wrt T by Def32;
      set J = if-then-else(C,I1,I2);
      let s be Element of S; assume [s, J] in TP1;
      then [s, C] in TP1 & (f1.(s,C) in T implies [f1.(s,C),I1] in TP1) &
      (f1.(s,C) nin T implies [f1.(s,C),I2] in TP1) by Th98;
      then [s, C] in TP2 & f1.(s,C) = f2.(s,C) &
      (f1.(s,C) in T implies [f1.(s,C),I1] in TP2 &
      f1.(f1.(s,C),I1) = f2.(f1.(s,C),I1) & f1.(s,J) = f1.(f1.(s,C),I1)) &
      (f1.(s,C) nin T implies [f1.(s,C),I2] in TP2 &
      f1.(f1.(s,C),I2) = f2.(f1.(s,C),I2) & f1.(s,J) = f1.(f1.(s,C),I2)) &
      (f1.(s,C) in T or f1.(s,C) nin T) by A9,A10,Def30;
      hence thesis by A10,Def30,Def35;
    end;
A11: for C,I being Element of A st P[C] & P[I] holds P[while(C,I)]
    proof
      let C,I be Element of A such that
A12:   P[C] & P[I];
      set J = while(C,I);
      let s be Element of S; assume
A13:   [s, J] in TP1;
      then [s, C] in TP1 by Th99;
then A14:   [s, C] in TP2 & f1.(s,C) = f2.(s,C) by A12;
      consider r being non empty FinSequence of S such that
A15:   r.1 = f1.(s,C) & r.len r nin T and
A16:   for i being Nat st 1 <= i & i < len r holds
      r.i in T & [r.i, I\;C] in TP1 & r.(i+1) = f1.(r.i, I\;C) by A13,Th99;
       for i being Nat st 1 <= i & i < len r holds
      r.i in T & r.(i+1) = f1.(r.i, I\;C) by A16;
then A17:   f1.(s,J) = r.len r by A15,Th86;
      defpred Q[Nat] means 1 <= $1 & $1 < len r implies
      r.$1 in T & [r.$1, I\;C] in TP2 & r.($1+1) = f2.(r.$1, I\;C);
A18:   for i being Nat holds Q[i]
      proof let i be Nat;
        assume
A19:       1 <= i & i < len r;
        hence A20:      r.i in T by A16;
        then reconsider ri = r.i as Element of S;
A21:     [r.i, I\;C] in TP1 by A16,A19;
        hence [r.i, I\;C] in TP2 by A6,A12,A20;
A22:     [ri, I] in TP1 & [f1.(ri,I),C] in TP1 by A21,Th97;
        thus r.(i+1) = f1.(r.i, I\;C) by A16,A19
        .= f1.(f1.(ri,I),C) by Def29
        .= f2.(f1.(ri,I),C) by A12,A22
        .= f2.(f2.(ri,I),C) by A12,A22
        .= f2.(r.i, I\;C) by Def29;
      end;
      then for i being Nat st 1 <= i & i < len r holds
      r.i in T & r.(i+1) = f2.(r.i, I\;C);
      hence thesis by A14,A15,A17,A18,Def35,Th86;
    end;
    let I be Element of A;
    thus P[I] from StructInd(A2,A5,A6,A8,A11);
  end;

theorem
   for A being free ECIW-strict preIfWhileAlgebra
  for f1,f2 being ExecutionFunction of A, S, T
  st f1|[:S, ElementaryInstructions A:] = f2|[:S, ElementaryInstructions A:]
  holds TerminatingPrograms(A,S,T,f1) = TerminatingPrograms(A,S,T,f2)
  proof
    let A be free ECIW-strict preIfWhileAlgebra;
    let f1,f2 be ExecutionFunction of A, S, T;
    assume
A1: f1|[:S, ElementaryInstructions A:] = f2|[:S, ElementaryInstructions A:];
    set g = f1|[:S, ElementaryInstructions A:];
    set TP1 = TerminatingPrograms(A,S,T,f1);
    set TP2 = TerminatingPrograms(A,S,T,f2);
    thus TP1 c= TP2
    proof
      let q,I be set; assume
A2:   [q,I] in TP1;
      then q is Element of S & I is Element of A by ZFMISC_1:106;
      hence thesis by A1,A2,Lm3;
    end;
    let q,I be set; assume
A3: [q,I] in TP2;
    then q is Element of S & I is Element of A by ZFMISC_1:106;
    hence thesis by A1,A3,Lm3;
  end;

theorem
   for A being free ECIW-strict preIfWhileAlgebra
  for f1,f2 being ExecutionFunction of A, S, T
  st f1|[:S, ElementaryInstructions A:] = f2|[:S, ElementaryInstructions A:]
  for s being Element of S
  for I being Element of A st [s,I] in TerminatingPrograms(A,S,T,f1)
  holds f1.(s, I) = f2.(s, I) by Lm3;
