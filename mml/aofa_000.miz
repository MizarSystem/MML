:: Mizar Analysis of Algorithms: Preliminaries
::  by Grzegorz Bancerek
:: 
:: Received July 9, 2007
:: Copyright (c) 2007 Association of Mizar Users

environ

 vocabularies AOFA_000, UNIALG_1, FUNCT_1, BINOP_1, GROUP_1, FINSEQ_1, RELAT_1,
      BINTREE1, FUNCT_2, PARTFUN1, COMPUT_1, BOOLE, MSUALG_1, FUNCT_7,
      ZF_REFLE, SUPINF_1, RLVECT_1, FUNCOP_1, FUNCT_4, ARYTM, PROB_1, TARSKI,
      TREES_4, FINSEQ_2, ARYTM_1, FINSET_1, CQC_LANG, SUBSET_1, FUNCT_3,
      VECTSP_1, SETFAM_1, FREEALG, FINSEQ_4, DTCONSTR, CARD_1, TREES_2, LANG1,
      TDGROUP, TREES_3, RAT_1, TREES_1, MEMBERED, SQUARE_1, WELLORD1, INCPROJ,
      FACIRC_1, UNIALG_2, PRELAMB, FUNCT_5, CQC_SIM1, ALG_1, ORDINAL2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, PRE_TOPC, ENUMSET1, SETFAM_1,
      ORDINAL1, MEMBERED, RELAT_1, FUNCT_1, RELSET_1, PARTFUN1, FUNCT_2,
      FUNCT_3, FINSET_1, CQC_LANG, LANG1, MSAFREE1, FINSEQ_1, SEQ_1, SEQM_3,
      BINOP_1, CARD_1, CARD_3, FRAENKEL, PROB_2, FINSEQ_2, FINSEQOP, PBOOLE,
      PZFMISC1, PRE_FF, PRE_CIRC, FACIRC_1, NUMBERS, XCMPLX_0, XXREAL_0,
      XREAL_0, TREES_1, TREES_2, TREES_3, NAT_1, BINARITH, WSIERP_1, SUPINF_1,
      MESFUNC1, FUNCOP_1, FUNCT_4, FUNCT_5, FUNCT_7, ABIAN, CAT_2, BORSUK_1,
      MARGREL1, STRUCT_0, UNIALG_1, UNIALG_2, ALG_1, FREEALG, PUA2MSS1,
      COMPUT_1, SUPINF_2, TREES_4, DTCONSTR, MSUALG_1, MSAFREE, MSATERM,
      MSUALG_3, FINSEQ_4;
 constructors ORDINAL2, FINSEQ_1, UNIALG_1, PUA2MSS1, COMPUT_1, FUNCT_7,
      BINOP_1, BINARITH, REAL_1, BORSUK_1, SUPINF_1, SUPINF_2, POLYNOM1,
      CATALG_1, MSATERM, MSAFREE3, PROB_2, MSAFREE1, MSUALG_3, CQC_LANG,
      FACIRC_1, CARD_4, AMI_2, FUNCT_3, ALG_1, FREEALG, FINSEQ_4, FINSOP_1,
      ORDERS_1, PZFMISC1, PRE_FF, INT_2, ABSVALUE, FUNCT_5, FINSEQOP, WSIERP_1,
      ENUMSET1, PRE_CIRC, WELLORD2, UNIALG_2, CAT_2, ABIAN, SETFAM_1, EXTREAL1,
      MARGREL1, MESFUNC1;
 registrations ZFMISC_1, RELSET_1, FUNCT_1, FUNCOP_1, FINSEQ_2, FRAENKEL,
      FUNCT_2, FINSEQ_1, UNIALG_1, COMPUT_1, NUMBERS, NAT_1, ORDINAL2,
      STRUCT_0, PUA2MSS1, SUPINF_1, PBOOLE, MSUALG_1, INSTALG1, MSATERM,
      MSAFREE1, MSAFREE3, MSUALG_2, PRALG_1, DTCONSTR, FREEALG, FUNCT_7, INT_1,
      CARD_4, WAYBEL12, CARD_5, SUBSET_1, ORDERS_1, CARD_3, SEQ_1, XXREAL_0,
      XREAL_0, TOPGEN_4, TREES_2, TREES_3, TREES_4, MEMBERED, XBOOLE_0,
      FINSET_1, TREES_1, PRE_CIRC, FACIRC_1, RELAT_1, PRE_TOPC;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;
 definitions SUBSET_1, XCMPLX_0, PZFMISC1, TREES_4, SUPINF_1, SUPINF_2,
      MEMBERED, FINSEQ_2, TARSKI, PUA2MSS1, SEQ_1, FINSEQ_4, FUNCT_1, MESFUNC1,
      FREEALG, RELAT_1, FINSEQ_1, UNIALG_1, UNIALG_2, COMPUT_1, BINOP_1,
      ORDERS_1, XBOOLE_0, STRUCT_0;
 theorems XBOOLE_1, ZFMISC_1, RELAT_1, RELSET_1, FUNCT_2, FUNCOP_1, CATALG_1,
      COMPUT_1, UNIALG_1, FINSEQ_1, FINSEQ_2, TARSKI, XBOOLE_0, FINSEQ_3,
      XREAL_1, FUNCT_7, NAT_1, ORDINAL1, PARTFUN1, FUNCT_3, BINARITH, DTCONSTR,
      FUNCT_4, FREEALG, FINSEQ_4, TREES_4, FUNCT_1, LANG1, CARD_2, CARD_1,
      CARD_4, CARD_5, TREES_3, PRE_CIRC, ENUMSET1, FINSEQ_5, WELLORD2, GROUP_7,
      UNIALG_2, FINSET_1, STIRL2_1, JORDAN16, ALTCAT_1, FUNCT_5, FUNCT_6,
      MSUALG_1, ALG_1, XREAL_0, XXREAL_0, SETFAM_1, MSUALG_8, SUPINF_2,
      POLYNOM1;
 schemes NAT_1, FUNCT_1, RECDEF_1, FINSEQ_2, CIRCCMB3, PRE_CIRC, WELLORD2,
      XBOOLE_0, CLASSES1, ALTCAT_2, FINSEQ_1;

begin :: Binary operations, orbits, and iterations

notation
  let x,y be set;
  antonym x nin y for x in y;
end;

theorem LemFunc:
  for f,g,h being Function
  for A being set st A c= dom f & A c= dom g & rng h c= A &
    for x being set st x in A holds f.x = g.x
  holds f*h = g*h
  proof
    let f,g,h be Function;
    let A be set such that
00: A c= dom f and
01: A c= dom g and
02: rng h c= A and
03: for x being set st x in A holds f.x = g.x;
    rng h c= dom f & rng h c= dom g by 00,01,02,XBOOLE_1:1; then
04: dom (f*h) = dom h & dom (g*h) = dom h by RELAT_1:46;
    now
      let x be set; assume x in dom h; then
      (f*h).x = f.(h.x) & (g*h).x = g.(h.x) & h.x in rng h
      by FUNCT_1:12,23;
      hence (f*h).x = (g*h).x by 02,03;
    end;
    hence f*h = g*h by 04,FUNCT_1:9;
  end;

registration
  let x,y be non empty set;
  cluster <*x,y*> -> non-empty;
  coherence
  proof
    assume {} in rng <*x,y*>; then
    {} in {x,y} by FINSEQ_2:147;
    hence thesis by TARSKI:def 2;
  end;
end;

registration
  let p,q be non-empty FinSequence;
  cluster p^q -> non-empty;
  coherence
  proof
    assume {} in rng (p^q); then
    {} in (rng p) \/ rng q by FINSEQ_1:44; then
    {} in rng p or {} in rng q by XBOOLE_0:def 2;
    hence thesis by RELAT_1:def 9;
  end;
end;

definition
  let f be homogeneous Function;
  let x be set;
  pred x is_a_unity_wrt f means:
UNITY:
  for y,z being set st <*y,z*> in dom f or <*z,y*> in dom f
  holds <*x,y*> in dom f & f.<*x,y*> = y &
        <*y,x*> in dom f & f.<*y,x*> = y;
end;

definition
  let f be homogeneous Function;
  attr f is associative means:
ASSOC:
  for x,y,z being set st <*x,y*> in dom f & <*y,z*> in dom f &
  <*f.<*x,y*>,z*> in dom f & <*x,f.<*y,z*>*> in dom f
  holds f.<*f.<*x,y*>,z*> = f.<*x,f.<*y,z*>*>;
  attr f is unital means:
UNITAL:
  ex x being set st x is_a_unity_wrt f;
end;

definition
  let X be set;
  let Y be non empty set;
  let Z be FinSequenceSet of X;
  let y be Element of Y;
  redefine func Z --> y -> PartFunc of X*,Y;
  coherence
  proof
    dom (Z --> y) = Z & Z c= X* & rng (Z --> y) c= {y}
    by FUNCOP_1:19,COMPUT_1:13;
    hence thesis by RELSET_1:11;
  end;
end;

registration
  let X be non empty set;
  let x be Element of X;
  let n be Nat;
  cluster (n-tuples_on X) --> x ->
  non empty quasi_total homogeneous PartFunc of X*, X;
  coherence
  proof
    reconsider m = n as Element of NAT by ORDINAL1:def 13;
    set f = (n-tuples_on X) --> x;
A1: m-tuples_on X c= X* & rng f c= X &
    dom f = m-tuples_on X by CATALG_1:6,FUNCOP_1:19; then
    reconsider f as non empty homogeneous PartFunc of X*, X
    by RELAT_1:60,COMPUT_1:19;
    arity f = m by A1,COMPUT_1:27;
    hence thesis by A1,COMPUT_1:25;
  end;
end;

theorem Lem1:
  for X being non empty set, x being Element of X
  for n being Nat holds arity ((n-tuples_on X) --> x) = n
  proof
    let X be non empty set;
    let x be Element of X;
    let n be Nat;
    reconsider m = n as Element of NAT by ORDINAL1:def 13;
    set f = (n-tuples_on X) --> x;
    dom f = m-tuples_on X by FUNCOP_1:19;
    hence arity f = n by COMPUT_1:27;
  end;

Lem2: now let X be non empty set;
        let x be Element of X;
        thus (0-tuples_on X) --> x is nullary
        proof
          thus arity ((0-tuples_on X) --> x) = 0 by Lem1;
        end;
        thus (1-tuples_on X) --> x is unary
        proof
          thus arity ((1-tuples_on X) --> x) = 1 by Lem1;
        end;
        thus (2-tuples_on X) --> x is binary
        proof
          thus arity ((2-tuples_on X) --> x) = 2 by Lem1;
        end;
        thus (3-tuples_on X) --> x is ternary
        proof
          thus arity ((3-tuples_on X) --> x) = 3 by Lem1;
        end;
      end;

registration
  let X be non empty set;
  let x be Element of X;
  cluster (0-tuples_on X) --> x -> nullary (homogeneous PartFunc of X*, X);
  coherence by Lem2;
  cluster (1-tuples_on X) --> x -> unary (homogeneous PartFunc of X*, X);
  coherence by Lem2;
  cluster (2-tuples_on X) --> x -> binary (homogeneous PartFunc of X*, X);
  coherence by Lem2;
  cluster (3-tuples_on X) --> x -> ternary (homogeneous PartFunc of X*, X);
  coherence by Lem2;
end;

registration
  let X be non empty set;
  cluster binary associative unital
  (non empty quasi_total homogeneous PartFunc of X*, X);
  existence
  proof
    consider x being Element of X;
    deffunc F((Element of X), Element of X) = IFEQ($1,x,$2,$1);
    (ex f being Function of 2-tuples_on X, X st
    for x,y being Element of X holds f.<*x,y*> = F(x,y)) &
    for f1,f2 being Function of 2-tuples_on X, X st
    (for x,y being Element of X holds f1.<*x,y*> = F(x,y)) &
    (for x,y being Element of X holds f2.<*x,y*> = F(x,y))
    holds f1 = f2  from CIRCCMB3:sch 7; then
    consider f being Function of 2-tuples_on X, X such that
A0: for a,b being Element of X holds f.<*a,b*> = IFEQ(a,x,b,a);
A1: 2-tuples_on X c= X* & rng f c= X &
    dom f = 2-tuples_on X by CATALG_1:6,FUNCT_2:def 1; then
    reconsider f as non empty homogeneous PartFunc of X*, X
    by RELSET_1:11,COMPUT_1:19;
    arity f = 2 by A1,COMPUT_1:27; then
    reconsider f as non empty quasi_total homogeneous PartFunc of X*, X
      by A1,COMPUT_1:25;
    take f;
    thus arity f = 2 by A1,COMPUT_1:27;
    hereby let u,y,z be set;
      assume <*u,y*> in dom f & <*y,z*> in dom f; then
      reconsider u' = u, y' = y, z' = z as Element of X by A1,CATALG_1:11;
      assume <*f.<*u,y*>,z*> in dom f & <*u,f.<*y,z*>*> in dom f;
A3:   (u = x implies IFEQ(u,x,y,u) = y) & (u <> x implies IFEQ(u,x,y,u) = u) &
      (u = x implies IFEQ(u,x,IFEQ(y,x,z,y),u) = IFEQ(y,x,z,y)) &
      (u <> x implies IFEQ(u,x,IFEQ(y,x,z,y),u) = u) &
      (u <> x implies IFEQ(u,x,z,u) = u) by FUNCOP_1:def 8;
      thus f.<*f.<*u,y*>,z*> = f.<*IFEQ(u',x,y',u'),z'*> by A0
      .= IFEQ(IFEQ(u,x,y,u),x,z,IFEQ(u,x,y,u)) by A0
      .= f.<*u',IFEQ(y',x,z',y')*> by A0,A3
      .= f.<*u,f.<*y,z*>*> by A0;
    end;
    take x; let y,z be set;
    assume <*y,z*> in dom f or <*z,y*> in dom f; then
    reconsider y' = y, z' = z as Element of X by A1,CATALG_1:11;
    <*x,y'*> in 2-tuples_on X by CATALG_1:10;
    hence <*x,y*> in dom f by FUNCT_2:def 1;
    thus f.<*x,y*> = IFEQ(x,x,y',x) by A0 .= y by FUNCOP_1:def 8;
    <*y',x*> in 2-tuples_on X by CATALG_1:10;
    hence <*y,x*> in dom f by FUNCT_2:def 1;
A4: x = y or x <> y;
    thus f.<*y,x*> = IFEQ(y',x,x,y') by A0 .= y by A4,FUNCOP_1:def 8;
  end;
  cluster nullary (non empty quasi_total homogeneous PartFunc of X*, X);
  existence
  proof
    consider x being Element of X;
    set f = (0-tuples_on X) --> x;
    take f; thus arity f = 0 by Lem1;
  end;
  cluster ternary (non empty quasi_total homogeneous PartFunc of X*, X);
  existence
  proof
    consider x being Element of X;
    set f = (3-tuples_on X) --> x;
    take f; thus arity f = 3 by Lem1;
  end;
end;

theorem Th17:
  for X being non empty set
  for p being FinSequence of FinTrees X
  for x,t being set st t in rng p
  holds t <> x-tree p
  proof
    let X be non empty set;
    let p be FinSequence of FinTrees X;
    let x,t be set;
    assume
A1: t in rng p; then
    reconsider T = t as Element of FinTrees X;
    reconsider A = dom T as finite Tree;
    defpred P[set] means not contradiction;
    deffunc F(Element of A) = len $1;
    {F(e) where e is Element of A: P[e]} is finite from PRE_CIRC:sch 1; then
    reconsider B = {F(e) where e is Element of A: P[e]} as finite set;
    consider e being Element of A;
A2: F(e) in B;
    B is real-membered
    proof
      let a be set; assume a in B; then
      ex e being Element of A st a = F(e);
      hence a is real;
    end; then
    reconsider B as non empty finite real-membered set by A2;
    max B in B by PRE_CIRC:def 1; then
    consider e being Element of A such that
A3: max B = len e;
    consider i being set such that
A4: i in dom p & t = p.i by A1,FUNCT_1:def 5;
    reconsider i as Nat by A4,ORDINAL1:def 13;
    i >= 1 by A4,FINSEQ_3:27; then
    consider j being Nat such that
A5: i = 1+j by NAT_1:10;
    i <= len p by A4,FINSEQ_3:27; then
    j < len p & j in NAT by A5,NAT_1:13,ORDINAL1:def 13; then
A6: <*j*>^e in dom (x-tree p) by A4,A5,TREES_4:11;
    len (<*j*>^e) = 1+len e by FINSEQ_5:8; then
    len (<*j*>^e) > max B by A3,NAT_1:13; then
    len (<*j*>^e) nin B by PRE_CIRC:def 1;
    hence t <> x-tree p by A6;
  end;

definition
  let f,g be Function;
  let X be set;
  func (f,X)+*g -> Function equals g+*(f|X);
  coherence;
end;

theorem LemII:
  for f,g being Function, x,X being set holds
  x in X & X c= dom f implies ((f,X)+*g).x = f.x
  proof
    let f,g be Function;
    let x,X be set;
    assume
A0: x in X;
    assume X c= dom f; then
    x in dom f & dom (f|X) = dom f /\ X by A0,FUNCT_1:68; then
A2: x in dom (f|X) by A0,XBOOLE_0:def 3; then
    (f|X).x = f.x by FUNCT_1:68;
    hence ((f,X)+*g).x = f.x by A2,FUNCT_4:14;
  end;

theorem LemIII:
  for f,g being Function, x,X being set holds
  x nin X & x in dom g implies ((f,X)+*g).x = g.x
  proof
    let f,g be Function;
    let x,X be set;
    assume x nin X; then
    x nin dom f /\ X by XBOOLE_0:def 3; then
    x nin dom (f|X) by FUNCT_1:68;
    hence thesis by FUNCT_4:12;
  end;

definition
  let X,Y be non empty set;
  let f,g be Element of Funcs(X,Y);
  let A be set;
  redefine func (f,A)+*g -> Element of Funcs(X,Y);
  coherence
  proof
A1: dom f = X & dom g = X & rng f c= Y & rng g c= Y by FUNCT_2:169;
    dom g \/ dom (f|A) = X by A1,XBOOLE_1:12; then
A2: dom ((f,A)+*g) = X by FUNCT_4:def 1;
    rng ((f,A)+*g) c= rng g \/ rng (f|A) & rng g \/ rng (f|A) c= Y \/ Y
    by FUNCT_4:18; then
    rng ((f,A)+*g) c= Y by XBOOLE_1:1;
    hence thesis by A2,FUNCT_2:def 2;
  end;
end;

definition
  let X,Y,Z be non empty set;
  let f be Element of Funcs(X,Y);
  let g be Element of Funcs(Y,Z);
  redefine func g*f -> Element of Funcs(X,Z);
  coherence
  proof
    g*f is Function of X,Z;
    hence thesis by FUNCT_2:11;
  end;
end;

definition
  let f be Function;
  let x be set;
  func f orbit x equals
  {iter(f,n).x where n is Element of NAT: x in dom iter(f,n)};
  coherence;
end;

theorem LemO1:
  for f being Function, x being set st x in dom f
  holds x in f orbit x
  proof
    let f be Function;
    let x be set; assume
    x in dom f; then
A0: x in dom f \/ rng f & iter(f,0) = id (dom f \/ rng f)
    by XBOOLE_0:def 2,FUNCT_7:70; then
    iter(f,0).x = x & dom iter(f,0) = dom f \/ rng f by FUNCT_1:34;
    hence x in f orbit x by A0;
  end;

theorem
  for f being Function, x,y being set
  st rng f c= dom f & y in f orbit x holds f.y in f orbit x
  proof
    let f be Function;
    let x,y be set; assume
A0: rng f c= dom f;
    assume y in f orbit x; then
    consider n being Element of NAT such that
A1: y = iter(f,n).x & x in dom iter(f,n);
A3: iter(f,n+1) = f*iter(f,n) by FUNCT_7:73; then
A2: f.y = iter(f,n+1).x by A1,FUNCT_1:23;
    y in rng iter(f,n) & rng iter(f,n) c= dom f \/ rng f &
    dom f \/ rng f = dom f by A0,A1,XBOOLE_1:12,FUNCT_7:74,FUNCT_1:def 5; then
    x in dom iter(f,n+1) by A1,A3,FUNCT_1:21;
    hence f.y in f orbit x by A2;
  end;

theorem
  for f being Function, x being set st x in dom f holds f.x in f orbit x
  proof
    let f be Function;
    let x be set;
    assume
A0: x in dom f;
    iter(f,1) = f by FUNCT_7:72;
    hence f.x in f orbit x by A0;
  end;

theorem LemO4:
  for f being Function, x being set st x in dom f & f.x in dom f
  holds f orbit (f.x) c= f orbit x
  proof
    let f be Function;
    let x be set;
    assume
A0: x in dom f & f.x in dom f;
    let a be set; assume a in f orbit (f.x); then
    consider n being Element of NAT such that
A1: a = iter(f,n).(f.x) & f.x in dom iter(f,n);
    iter(f,n+1) = iter(f,n)*f by FUNCT_7:71; then
    a = iter(f,n+1).x & x in dom iter(f,n+1) by A0,A1,FUNCT_1:21,23;
    hence thesis;
  end;

definition
  let f be Function such that
A: rng f c= dom f;
  let A be set;
  let x be set;
    defpred T[Nat] means
    for a being set st a in dom f holds a in dom iter(f,$1);
C0: dom f \/ rng f = dom f by A,XBOOLE_1:12; then
    iter(f,0) = id dom f by FUNCT_7:70; then
C1: T[0] by FUNCT_1:34;
C2: now let i be Element of NAT; assume
C3:   T[i];
      thus T[i+1]
      proof
        let a be set;
        assume a in dom f; then
C7:     a in dom iter(f,i) by C3; then
C4:     iter(f,i).a in rng iter(f,i) & rng iter(f,i) c= dom f
        by C0,FUNCT_1:def 5,FUNCT_7:74;
        iter(f,i+1) = f*iter(f,i) by FUNCT_7:73;
        hence thesis by C7,C4,FUNCT_1:21;
      end;
    end;
C5: for i being Element of NAT holds T[i] from NAT_1:sch 1(C1,C2);
  func (A,x) iter f -> Function means
  dom it = dom f &
  for a being set st a in dom f holds
    (f orbit a c= A implies it.a = x) &
    for n being Nat st iter(f,n).a nin A &
       for i being Nat st i < n holds iter(f,i).a in A
    holds it.a = iter(f,n).a;
  existence
  proof
    defpred P[set] means f orbit $1 c= A;
    consider Z being set such that
A1: for a being set holds a in Z iff a in dom f & P[a] from XBOOLE_0:sch 1;
B1: Z c= dom f
    proof
      let a be set; thus thesis by A1;
    end;
    defpred Q[set,set] means
    ex n being Nat st $2 = iter(f,n).$1 & $2 nin A &
    for i being Nat st i < n holds iter(f,i).$1 in A;
A2: for a being set st a in (dom f) \ Z ex b being set st Q[a,b]
    proof
      let a be set; assume a in (dom f) \ Z; then
      a in dom f & a nin Z by XBOOLE_0:def 4; then
      not f orbit a c= A by A1; then
      consider y being set such that
B3:   y in f orbit a & y nin A by TARSKI:def 3;
      consider n1 being Element of NAT such that
B4:   y = iter(f,n1).a & a in dom iter(f,n1) by B3;
      defpred R[Nat] means iter(f,$1).a nin A;
B5:   ex n being Element of NAT st R[n] by B3,B4;
      consider n being Element of NAT such that
B6:   R[n] and
B7:   for m being Element of NAT st R[m] holds n <= m from NAT_1:sch 5(B5);
      take b = iter(f,n).a, n; thus b = iter(f,n).a & b nin A by B6;
      let i be Nat; i in NAT by ORDINAL1:def 13;
      hence thesis by B7;
    end;
    consider h being Function such that
A3: dom h = (dom f) \ Z and
A4: for a being set st a in (dom f) \ Z holds Q[a,h.a] from CLASSES1:sch 1(A2);
    take g = (Z-->x)+*h;
    dom (Z-->x) = Z by FUNCOP_1:19;
    hence dom g = Z \/ (dom f \ Z) by A3,FUNCT_4:def 1
    .= dom f by B1,XBOOLE_1:45;
    let a be set; assume
A6: a in dom f;
    hereby assume f orbit a c= A; then
      a in Z by A6,A1; then
      a nin dom f \ Z & (Z-->x).a = x by XBOOLE_0:def 4,FUNCOP_1:13;
      hence g.a = x by A3,FUNCT_4:12;
    end;
    let n be Nat; assume
A7: iter(f,n).a nin A & for i being Nat st i < n holds iter(f,i).a in A;
N1: n in NAT by ORDINAL1:def 13; then
    a in dom iter(f,n) by A6,C5; then
    iter(f,n).a in f orbit a by N1; then
    not f orbit a c= A by A7; then
    a nin Z by A1; then
A8: a in dom f \ Z by A6,XBOOLE_0:def 4; then
    consider n2 being Nat such that
A9: h.a = iter(f,n2).a & h.a nin A &
    for i being Nat st i < n2 holds iter(f,i).a in A by A4;
    n <= n2 & n2 <= n by A7,A9; then
    n = n2 by XXREAL_0:1;
    hence g.a = iter(f,n).a by A3,A8,A9,FUNCT_4:14;
  end;
  uniqueness
  proof
    let f1,f2 be Function such that
A1: dom f1 = dom f and
B1: for a being set st a in dom f holds
    (f orbit a c= A implies f1.a = x) &
    for n being Nat st iter(f,n).a nin A &
       for i being Nat st i < n holds iter(f,i).a in A
    holds f1.a = iter(f,n).a and
A2: dom f2 = dom f and
B2: for a being set st a in dom f holds
    (f orbit a c= A implies f2.a = x) &
    for n being Nat st iter(f,n).a nin A &
       for i being Nat st i < n holds iter(f,i).a in A
    holds f2.a = iter(f,n).a;
    now let a be set; assume
A3:   a in dom f;
      per cases;
      suppose
A4:     f orbit a c= A;
        hence f1.a = x by B1,A3 .= f2.a by B2,A3,A4;
      end;
      suppose not f orbit a c= A; then
        consider y being set such that
A5:     y in f orbit a & y nin A by TARSKI:def 3;
        consider n1 being Element of NAT such that
A6:     y = iter(f,n1).a & a in dom iter(f,n1) by A5;
        defpred R[Nat] means iter(f,$1).a nin A;
A7:     ex n being Element of NAT st R[n] by A5,A6;
        consider n being Element of NAT such that
A8:     R[n] and
A9:     for m being Element of NAT st R[m] holds n <= m from NAT_1:sch 5(A7);
B9:     now let i be Nat;
          i in NAT by ORDINAL1:def 13;
          hence i < n implies iter(f,i).a in A by A9;
        end;
        hence f1.a = iter(f,n).a by B1,A3,A8 .= f2.a by B2,A3,A8,B9;
      end;
    end;
    hence thesis by A1,A2,FUNCT_1:9;
  end;
end;

definition
  let f be Function such that
A: rng f c= dom f;
  let A be set;
  let g be Function;
    defpred T[Nat] means
    for a being set st a in dom f holds a in dom iter(f,$1);
C0: dom f \/ rng f = dom f by A,XBOOLE_1:12; then
    iter(f,0) = id dom f by FUNCT_7:70; then
C1: T[0] by FUNCT_1:34;
C2: now let i be Element of NAT; assume
C3:   T[i];
      thus T[i+1]
      proof
        let a be set;
        assume a in dom f; then
C7:     a in dom iter(f,i) by C3; then
C4:     iter(f,i).a in rng iter(f,i) & rng iter(f,i) c= dom f
        by C0,FUNCT_1:def 5,FUNCT_7:74;
        iter(f,i+1) = f*iter(f,i) by FUNCT_7:73;
        hence thesis by C7,C4,FUNCT_1:21;
      end;
    end;
C5: for i being Element of NAT holds T[i] from NAT_1:sch 1(C1,C2);
  func (A,g) iter f -> Function means:
ITER2:
  dom it = dom f &
  for a being set st a in dom f holds
    (f orbit a c= A implies it.a = g.a) &
    for n being Nat st iter(f,n).a nin A &
       for i being Nat st i < n holds iter(f,i).a in A
    holds it.a = iter(f,n).a;
  existence
  proof
    defpred P[set] means f orbit $1 c= A;
    consider Z being set such that
A1: for a being set holds a in Z iff a in dom f & P[a] from XBOOLE_0:sch 1;
B1: Z c= dom f
    proof
      let a be set; thus thesis by A1;
    end;
    defpred Q[set,set] means
    ex n being Nat st $2 = iter(f,n).$1 & $2 nin A &
    for i being Nat st i < n holds iter(f,i).$1 in A;
A2: for a being set st a in (dom f) \ Z ex b being set st Q[a,b]
    proof
      let a be set; assume a in (dom f) \ Z; then
      a in dom f & a nin Z by XBOOLE_0:def 4; then
      not f orbit a c= A by A1; then
      consider y being set such that
B3:   y in f orbit a & y nin A by TARSKI:def 3;
      consider n1 being Element of NAT such that
B4:   y = iter(f,n1).a & a in dom iter(f,n1) by B3;
      defpred R[Nat] means iter(f,$1).a nin A;
B5:   ex n being Element of NAT st R[n] by B3,B4;
      consider n being Element of NAT such that
B6:   R[n] and
B7:   for m being Element of NAT st R[m] holds n <= m from NAT_1:sch 5(B5);
      take b = iter(f,n).a, n; thus b = iter(f,n).a & b nin A by B6;
      let i be Nat; i in NAT by ORDINAL1:def 13;
      hence thesis by B7;
    end;
    consider h being Function such that
A3: dom h = (dom f) \ Z and
A4: for a being set st a in (dom f) \ Z holds Q[a,h.a] from CLASSES1:sch 1(A2);
    take i = (Z-->0)+*(g|Z)+*h;
B8: dom(g|Z) c= Z by RELAT_1:87;
    dom (Z-->0) = Z by FUNCOP_1:19; then
    dom ((Z-->0)+*(g|Z)) = Z \/ dom(g|Z) by FUNCT_4:def 1
    .= Z by B8,XBOOLE_1:12;
    hence dom i = Z \/ (dom f \ Z) by A3,FUNCT_4:def 1
    .= dom f by B1,XBOOLE_1:45;
    let a be set; assume
A6: a in dom f;
    hereby assume f orbit a c= A; then
C1:   a in Z by A6,A1; then
      a nin dom f \ Z & (Z-->0).a = 0 by XBOOLE_0:def 4,FUNCOP_1:13; then
C2:   i.a = ((Z-->0)+*(g|Z)).a by A3,FUNCT_4:12;
      per cases;
      suppose a in dom(g|Z); then
        i.a = (g|Z).a by C2,FUNCT_4:14;
        hence i.a = g.a by C1,FUNCT_1:72;
      end;
      suppose a nin dom(g|Z); then
        i.a = (Z-->0).a & (Z-->0).a = 0 & a nin dom g
        by C1,C2,FUNCT_4:12,FUNCOP_1:13,RELAT_1:86;
        hence i.a = g.a by FUNCT_1:def 4;
      end;
    end;
    let n be Nat; reconsider n' = n as Element of NAT by ORDINAL1:def 13;
    assume
A7: iter(f,n).a nin A & for i being Nat st i < n holds iter(f,i).a in A;
    a in dom iter(f,n') by A6,C5; then
    iter(f,n).a in f orbit a; then
    not f orbit a c= A by A7; then
    a nin Z by A1; then
A8: a in dom f \ Z by A6,XBOOLE_0:def 4; then
    consider n2 being Nat such that
A9: h.a = iter(f,n2).a & h.a nin A &
    for i being Nat st i < n2 holds iter(f,i).a in A by A4;
    n <= n2 & n2 <= n by A7,A9; then
    n = n2 by XXREAL_0:1;
    hence i.a = iter(f,n).a by A3,A8,A9,FUNCT_4:14;
  end;
  uniqueness
  proof
    let f1,f2 be Function such that
A1: dom f1 = dom f and
B1: for a being set st a in dom f holds
    (f orbit a c= A implies f1.a = g.a) &
    for n being Nat st iter(f,n).a nin A &
       for i being Nat st i < n holds iter(f,i).a in A
    holds f1.a = iter(f,n).a and
A2: dom f2 = dom f and
B2: for a being set st a in dom f holds
    (f orbit a c= A implies f2.a = g.a) &
    for n being Nat st iter(f,n).a nin A &
       for i being Nat st i < n holds iter(f,i).a in A
    holds f2.a = iter(f,n).a;
    now let a be set; assume
A3:   a in dom f;
      per cases;
      suppose
A4:     f orbit a c= A;
        hence f1.a = g.a by B1,A3 .= f2.a by B2,A3,A4;
      end;
      suppose not f orbit a c= A; then
        consider y being set such that
A5:     y in f orbit a & y nin A by TARSKI:def 3;
        consider n1 being Element of NAT such that
A6:     y = iter(f,n1).a & a in dom iter(f,n1) by A5;
        defpred R[Nat] means iter(f,$1).a nin A;
A7:     ex n being Element of NAT st R[n] by A5,A6;
        consider n being Element of NAT such that
A8:     R[n] and
A9:     for m being Element of NAT st R[m] holds n <= m from NAT_1:sch 5(A7);
B9:     now let i be Nat; i in NAT by ORDINAL1:def 13;
          hence i < n implies iter(f,i).a in A by A9;
        end;
        hence f1.a = iter(f,n).a by B1,A3,A8 .= f2.a by B2,A3,A8,B9;
      end;
    end;
    hence thesis by A1,A2,FUNCT_1:9;
  end;
end;

theorem LemW0:
  for f,g being Function, a,A being set
  st rng f c= dom f & a in dom f holds
  not f orbit a c= A implies
  ex n being Nat st ((A,g) iter f).a = iter(f,n).a & iter(f,n).a nin A &
  for i being Nat st i < n holds iter(f,i).a in A
  proof
    let f,g be Function;
    let a,A be set;
    assume
A0: rng f c= dom f;
    assume
A1: a in dom f;
    assume not f orbit a c= A; then
    consider y being set such that
A5: y in f orbit a & y nin A by TARSKI:def 3;
    consider n1 being Element of NAT such that
A6: y = iter(f,n1).a & a in dom iter(f,n1) by A5;
    defpred R[Nat] means iter(f,$1).a nin A;
A7: ex n being Element of NAT st R[n] by A5,A6;
    consider n being Element of NAT such that
A8: R[n] and
A9: for m being Element of NAT st R[m] holds n <= m from NAT_1:sch 5(A7);
A2: now let i being Nat; i in NAT by ORDINAL1:def 13;
      hence i < n implies iter(f,i).a in A by A9;
    end;
    take n;
    thus ((A,g) iter f).a = iter(f,n).a by A0,A1,A8,A2,ITER2;
    thus thesis by A8,A2;
  end;

theorem LemWI:
  for f,g being Function, a,A being set
  st rng f c= dom f & a in dom f & g*f = g holds
  a in A implies ((A,g) iter f).a = ((A,g) iter f).(f.a)
  proof
    let f,g be Function;
    let a,A be set;
    assume
A0: rng f c= dom f & a in dom f & g*f = g & a in A; then
A3: f.a in rng f by FUNCT_1:def 5; then
A1: f orbit (f.a) c= f orbit a by A0,LemO4;
    per cases;
    suppose
A2:   f orbit a c= A; then
      f orbit (f.a) c= A by A1,XBOOLE_1:1; then
      ((A,g) iter f).(f.a) = g.(f.a) by A0,A3,ITER2 .= g.a by A0,FUNCT_1:23;
      hence ((A,g) iter f).a = ((A,g) iter f).(f.a) by A0,A2,ITER2;
    end;
    suppose not f orbit a c= A; then
      consider n being Nat such that
A4:   ((A,g) iter f).a = iter(f,n).a & iter(f,n).a nin A &
      for i being Nat st i < n holds iter(f,i).a in A by A0,LemW0;
      dom f \/ rng f = dom f by A0,XBOOLE_1:12; then
      iter(f,0) = id dom f by FUNCT_7:70; then
      n <> 0 by A0,A4,FUNCT_1:35; then
      n > 0; then
      n >= 0+1 by NAT_1:13; then
      consider i being Nat such that
A6:   n = 1+i by NAT_1:10;
      iter(f,n) = iter(f,i)*f by A6,FUNCT_7:71; then
A7:   iter(f,n).a = iter(f,i).(f.a) by A0,FUNCT_1:23;
      now let j be Nat; assume j < i; then
        j+1 < n by A6,XREAL_1:10; then
        iter(f,j+1) = iter(f,j)*f & iter(f,j+1).a in A by A4,FUNCT_7:71;
        hence iter(f,j).(f.a) in A by A0,FUNCT_1:23;
      end;
      hence ((A,g) iter f).a = ((A,g) iter f).(f.a) by A0,A3,A4,A7,ITER2;
    end;
  end;

theorem LemWII:
  for f,g being Function, a,A being set
  st rng f c= dom f & a in dom f holds
  a nin A implies ((A,g) iter f).a = a
  proof
    let f,g be Function;
    let a,A be set;
    assume
A0: rng f c= dom f & a in dom f & a nin A; then
    dom f \/ rng f = dom f by XBOOLE_1:12; then
    iter(f,0) = id dom f by FUNCT_7:70; then
A1: a = iter(f,0).a by A0,FUNCT_1:35;
    for i being Nat st i < 0 holds iter(f,i).a in A;
    hence ((A,g) iter f).a = a by A0,A1,ITER2;
  end;

definition
  let X be non empty set;
  let f be Element of Funcs(X,X);
  let A be set;
  let g be Element of Funcs(X,X);
  redefine func (A,g) iter f -> Element of Funcs(X,X);
  coherence
  proof
A1: dom f = X & rng f c= X by FUNCT_2:def 1; then
A2: dom ((A,g) iter f) = dom f by ITER2;
    rng ((A,g) iter f) c= X
    proof
      let a be set; assume a in rng ((A,g) iter f); then
      consider b being set such that
A3:   b in dom ((A,g) iter f) & a = ((A,g) iter f).b by FUNCT_1:def 5;
      reconsider b as Element of X by A1,ITER2,A3;
      per cases;
      suppose f orbit b c= A; then
        a = g.b by A1,A3,ITER2;
        hence a in X;
      end;
      suppose not f orbit b c= A; then
        consider n being Nat such that
A4:     ((A,g) iter f).b = iter(f,n).b & iter(f,n).b nin A &
        for i being Nat st i < n holds iter(f,i).b in A by A1,LemW0;
A5:     n in NAT by ORDINAL1:def 13; then
        dom iter(f,n) = dom f by A1,FUNCT_7:76; then
        rng iter(f,n) c= X & a in rng iter(f,n)
        by A1,A3,A4,A5,FUNCT_7:76,FUNCT_1:12;
        hence a in X;
      end;
    end;
    hence thesis by A1,A2,FUNCT_2:def 2;
  end;
end;

begin :: Free universal algebras

theorem ExUA1:
  for X being non empty set, S being non empty FinSequence of NAT
  ex A being Universal_Algebra st the carrier of A = X & signature A = S
  proof
    let X be non empty set;
    let S be non empty FinSequence of NAT;
A2: dom S = Seg len S & rng S c= NAT by FINSEQ_1:def 3,def 4;
    consider x being Element of X;
    defpred P[set,set] means
    ex i,j being Nat st $1 = i & j = S.i & $2 = (j-tuples_on X)--> x;
A0: for y being set st y in dom S ex z being set st P[y,z]
    proof
      let y be set; assume y in dom S; then
      reconsider i = y as Element of NAT;
      reconsider j = S.i as Element of NAT;
      take z = (j-tuples_on X)--> x, i, j; thus thesis;
    end;
    consider ch being Function such that
A1: dom ch = dom S & for y being set st y in dom S holds P[y,ch.y]
    from CLASSES1:sch 1(A0);
    reconsider ch as FinSequence by A1,A2,FINSEQ_1:def 2;
    rng ch c= PFuncs(X*,X)
    proof
      let y be set; assume y in rng ch; then
      consider xi being set such that
01:   xi in dom ch & y = ch.xi by FUNCT_1:def 5;
      consider i,j being Nat such that
02:   xi = i & j = S.i & y = (j-tuples_on X)--> x by A1,01;
      dom ((j-tuples_on X)--> x) = (j-tuples_on X) &
      rng ((j-tuples_on X)--> x) c= {x} by FUNCOP_1:19;
      hence thesis by 02,PARTFUN1:def 5;
    end; then
    reconsider ch as PFuncFinSequence of X by FINSEQ_1:def 4;
    set A = UAStr(#X,ch#);
A3: A is quasi_total
    proof
      let n be Nat, h be PartFunc of (the carrier of A)*, the carrier of A;
      assume n in dom the charact of A & h = (the charact of A).n; then
      ex i,j being Nat st n = i & j = S.i & h = (j-tuples_on X)--> x by A1;
      hence thesis;
    end;
A4: A is non-empty
    proof
      thus the charact of A <> {} by A1,RELAT_1:60;
      assume {} in rng the charact of A; then
      consider a being set such that
03:   a in dom ch & {} = ch.a by FUNCT_1:def 5;
      ex i,j being Nat st a = i & j = S.i & {} = (j-tuples_on X)--> x by 03,A1;
      hence thesis;
    end;
    A is partial
    proof
      let n be Nat, h be PartFunc of (the carrier of A)*, the carrier of A;
      assume n in dom the charact of A & h = (the charact of A).n; then
      ex i,j being Nat st n = i & j = S.i & h = (j-tuples_on X)--> x by A1;
      hence thesis;
    end; then
    reconsider A as Universal_Algebra by A3,A4;
    take A;
    thus the carrier of A = X;
A5: len ch = len S by A1,FINSEQ_3:31;
    now let n be Nat such that
04:   n in dom S;
      let h be homogeneous non empty PartFunc of (the carrier of A)*,
      the carrier of A; assume h = (the charact of A).n; then
      consider i,j being Nat such that
05:   n = i & j = S.i & h = (j-tuples_on X)--> x by A1,04;
      consider z being Element of j-tuples_on X;
      dom h = j-tuples_on X & len z = j by 05,FUNCOP_1:19,FINSEQ_2:109;
      hence S.n = arity h by 05,UNIALG_1:def 10;
    end;
    hence signature A = S by A5,UNIALG_1:def 11;
  end;

theorem ExUA2:
  for S being non empty FinSequence of NAT
  ex A being Universal_Algebra st the carrier of A = NAT & signature A = S &
  for i,j being Nat st i in dom S & j = S.i
  holds (the charact of A).i = (j-tuples_on NAT) --> i
  proof set X = NAT;
    let S be non empty FinSequence of NAT;
A2: dom S = Seg len S & rng S c= NAT by FINSEQ_1:def 3,def 4;
    defpred P[set,set] means
    ex i,j being Element of NAT st $1 = i & j = S.i & $2 = (j-tuples_on X)-->i;
A0: for y being set st y in dom S ex z being set st P[y,z]
    proof
      let y be set; assume y in dom S; then
      reconsider i = y as Element of NAT;
      reconsider j = S.i as Element of NAT;
      take z = (j-tuples_on X)--> i, i, j; thus thesis;
    end;
    consider ch being Function such that
A1: dom ch = dom S & for y being set st y in dom S holds P[y,ch.y]
    from CLASSES1:sch 1(A0);
    reconsider ch as FinSequence by A1,A2,FINSEQ_1:def 2;
    rng ch c= PFuncs(X*,X)
    proof
      let y be set; assume y in rng ch; then
      consider xi being set such that
01:   xi in dom ch & y = ch.xi by FUNCT_1:def 5;
      consider i,j being Element of NAT such that
02:   xi = i & j = S.i & y = (j-tuples_on X)--> i by A1,01;
      dom ((j-tuples_on X)--> i) = (j-tuples_on X) &
      rng ((j-tuples_on X)--> i) c= {i} by FUNCOP_1:19;
      hence thesis by 02,PARTFUN1:def 5;
    end; then
    reconsider ch as PFuncFinSequence of X by FINSEQ_1:def 4;
    set A = UAStr(#X,ch#);
A3: A is quasi_total
    proof
      let n be Nat, h be PartFunc of (the carrier of A)*, the carrier of A;
      assume n in dom the charact of A & h = (the charact of A).n; then
      ex i,j being Element of NAT st
      n = i & j = S.i & h = (j-tuples_on X)--> i by A1;
      hence thesis;
    end;
A4: A is non-empty
    proof
      thus the charact of A <> {} by A1,RELAT_1:60;
      assume {} in rng the charact of A; then
      consider a being set such that
03:   a in dom ch & {} = ch.a by FUNCT_1:def 5;
      ex i,j being Element of NAT st
      a = i & j = S.i & {} = (j-tuples_on X)--> i by 03,A1;
      hence thesis;
    end;
    A is partial
    proof
      let n be Nat, h be PartFunc of (the carrier of A)*, the carrier of A;
      assume n in dom the charact of A & h = (the charact of A).n; then
      ex i,j being Element of NAT st
      n = i & j = S.i & h = (j-tuples_on X)--> i by A1;
      hence thesis;
    end; then
    reconsider A as Universal_Algebra by A3,A4;
    take A;
    thus the carrier of A = X;
A5: len ch = len S by A1,FINSEQ_3:31;
    now let n be Nat such that
04:   n in dom S;
      let h be homogeneous non empty PartFunc of (the carrier of A)*,
      the carrier of A; assume h = (the charact of A).n; then
      consider i,j being Element of NAT such that
05:   n = i & j = S.i & h = (j-tuples_on X)--> i by A1,04;
      consider z being Element of j-tuples_on X;
      dom h = j-tuples_on X & len z = j by 05,FUNCOP_1:19,FINSEQ_2:109;
      hence S.n = arity h by 05,UNIALG_1:def 10;
    end;
    hence signature A = S by A5,UNIALG_1:def 11;
    consider A being Universal_Algebra;
    let i,j be Nat;
    assume i in dom S; then
    ex i1,j being Element of NAT st
    i = i1 & j = S.i1 & ch.i = (j-tuples_on X)--> i1 by A1;
    hence thesis;
  end;

theorem
  for S being non empty FinSequence of NAT
  for i,j being Nat st i in dom S & j = S.i
  for X being non empty set, f being Function of j-tuples_on X, X
  ex A being Universal_Algebra st the carrier of A = X & signature A = S &
  (the charact of A).i = f
  proof
    let S be non empty FinSequence of NAT;
    let i,j be Nat;
    reconsider i' = i, j' = j as Element of NAT by ORDINAL1:def 13;
    assume
01: i in dom S & j = S.i;
    let X be non empty set;
    consider A0 being Universal_Algebra such that
00: the carrier of A0 = X & signature A0 = S by ExUA1;
    let f be Function of j-tuples_on X, X;
    j'-tuples_on X c= X* by CATALG_1:6; then
    reconsider f0 = f as PartFunc of X*,X by RELSET_1:15;
    consider z being Element of j-tuples_on X;
A0: dom f0 = j-tuples_on X by FUNCT_2:def 1;
    f0 is homogeneous
    proof
      let x,y be FinSequence;
      assume x in dom f0 & y in dom f0; then
      len x = j & len y = j by A0,FINSEQ_2:109;
      hence len x = len y;
    end; then
    reconsider f0 as homogeneous non empty PartFunc of X*,X;
0A: len z = j by FINSEQ_2:109; then
A5: arity f0 = j by A0,UNIALG_1:def 10;
    set ch = (the charact of A0)+*(i,f0);
    f0 in PFuncs(X*, X) by PARTFUN1:119; then
    {f0} c= PFuncs(X*,X) & rng the charact of A0 c= PFuncs(X*,X)
    by 00,ZFMISC_1:37; then
    rng ch c= (rng the charact of A0) \/ {f0} &
    (rng the charact of A0) \/ {f0} c= PFuncs(X*, X)
    by XBOOLE_1:8,POLYNOM1:6; then
    rng ch c= PFuncs(X*, X) by XBOOLE_1:1; then
    reconsider ch as FinSequence of PFuncs(X*,X) by FINSEQ_1:def 4;
A2: dom ch = dom the charact of A0 by FUNCT_7:32;
    set A = UAStr(#X,ch#);
A3: A is quasi_total
    proof
      let n be Nat, h be PartFunc of (the carrier of A)*, the carrier of A;
      assume
02:   n in dom the charact of A & h = (the charact of A).n; then
      (n = i implies h = f0) & (n <> i implies h = (the charact of A0).n) &
      the charact of A0 is quasi_total by A2,FUNCT_7:33,34;
      hence thesis by 00,A5,A0,COMPUT_1:25,02,A2,UNIALG_1:def 5;
    end;
A4: A is non-empty
    proof
      thus the charact of A <> {} by A2,RELAT_1:60;
      assume {} in rng the charact of A; then
      consider a being set such that
03:   a in dom ch & {} = ch.a by FUNCT_1:def 5;
      reconsider a as Element of NAT by 03;
      (a = i implies {} = f0) & (a <> i implies {} = (the charact of A0).a) &
      {} nin rng the charact of A0 by 03,A2,FUNCT_7:33,34,RELAT_1:def 9;
      hence thesis by A2,03,FUNCT_1:def 5;
    end;
    A is partial
    proof
      let n be Nat, h be PartFunc of (the carrier of A)*, the carrier of A;
      assume n in dom the charact of A & h = (the charact of A).n; then
      (n = i implies h = f0) & (n <> i implies h = (the charact of A0).n) &
      the charact of A0 is homogeneous by A2,FUNCT_7:33,34;
      hence thesis;
    end; then
    reconsider A as Universal_Algebra by A3,A4;
    take A;
    thus the carrier of A = X;
05: len S = len the charact of A0 by 00,UNIALG_1:def 11; then
06: dom S = dom the charact of A0 by FINSEQ_3:31;
07: len S = len the charact of A by 05,A2,FINSEQ_3:31;
    now let n be Nat;
      assume
08:   n in dom S;
      let h be homogeneous non empty PartFunc of (the carrier of A )*,
      the carrier of A;
      assume h = (the charact of A).n; then
      (n = i implies h = f0) & (n <> i implies h = (the charact of A0).n)
      by 06,08,FUNCT_7:33,34;
      hence S.n = arity h by 00,01,08,0A,A0,UNIALG_1:def 10,def 11;
    end;
    hence signature A = S by 07,UNIALG_1:def 11;
    thus (the charact of A).i = f by 01,06,FUNCT_7:33;
  end;

registration
  let f be non empty FinSequence of NAT;
  let D be non empty disjoint_with_NAT set;
  cluster -> Relation-like Function-like Element of FreeUnivAlgNSG(f,D);
  coherence
  proof
    let x be Element of FreeUnivAlgNSG(f,D);
    x is Element of TS(DTConUA(f,D));
    hence thesis;
  end;
end;

registration
  let f be non empty FinSequence of NAT;
  let D be non empty disjoint_with_NAT set;
  cluster -> DecoratedTree-like Element of FreeUnivAlgNSG(f,D);
  coherence
  proof
    let x be Element of FreeUnivAlgNSG(f,D);
    x is Element of TS(DTConUA(f,D));
    hence thesis;
  end;
  cluster -> DTree-yielding FinSequence of FreeUnivAlgNSG(f,D);
  coherence
  proof
    let p be FinSequence of FreeUnivAlgNSG(f,D);
    p is Element of (TS(DTConUA(f,D)))* by FINSEQ_1:def 11;
    hence thesis;
  end;
end;

theorem Th19:
  for G being non empty DTConstrStr
  for t being set st t in TS G
  holds
   (ex d being Symbol of G st d in Terminals G & t = root-tree d) or
   (ex o being Symbol of G, p being FinSequence of TS G
    st o ==> roots p & t = o-tree p)
  proof
    let G be non empty DTConstrStr;
    let t be set;
    assume that
00: t in TS G and
01: not ex d being Symbol of G st d in Terminals G & t = root-tree d and
02: not ex o being Symbol of G, p being FinSequence of TS G
    st o ==> roots p & t = o-tree p;
04: (TS G) \ {t} c= TS G by XBOOLE_1:36;
    reconsider Y = (TS G) \ {t} as Subset of FinTrees the carrier of G;
03: now let d be Symbol of G;
      assume d in Terminals G; then
      root-tree d in TS G & root-tree d <> t by 01,DTCONSTR:def 4;
      hence root-tree d in Y by ZFMISC_1:64;
    end;
    now let o be Symbol of G, p be FinSequence of Y;
      rng p c= Y by FINSEQ_1:def 4; then
      rng p c= TS G by 04,XBOOLE_1:1; then
      reconsider q = p as FinSequence of TS G by FINSEQ_1:def 4;
      assume o ==> roots p; then
      o-tree q in TS G & t <> o-tree q by 02,DTCONSTR:def 4;
      hence o-tree p in Y by ZFMISC_1:64;
    end; then
    TS G c= Y by 03,DTCONSTR:def 4; then
    t nin {t} by 00,XBOOLE_0:def 4;
    hence contradiction by TARSKI:def 1;
  end;

theorem Th18:
  for X being disjoint_with_NAT non empty set
  for S being non empty FinSequence of NAT
  for i being Nat st i in dom S
  for p being FinSequence of FreeUnivAlgNSG(S,X) st len p = S.i holds
  Den(In(i, dom the charact of FreeUnivAlgNSG(S,X)),FreeUnivAlgNSG(S,X)).p
  = i-tree p
  proof
    let X be disjoint_with_NAT non empty set;
    let S be non empty FinSequence of NAT;
    reconsider S' = S as non empty FinSequence of omega;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let i be Nat;
    assume
A0: i in dom S; then
A1: S'/.i = S.i by FINSEQ_4:def 4;
    let p be FinSequence of A;
    assume len p = S.i; then
    p is Element of (S'/.i)-tuples_on TS G by A1,FINSEQ_2:110; then
    p in (S'/.i)-tuples_on TS G; then
A5: p in dom FreeOpNSG(i,S,X) by A0,FREEALG:def 11;
    len the charact of A = len S by FREEALG:def 12; then
    dom the charact of A = dom S by FINSEQ_3:31; then
    In(i, dom the charact of A) = i by A0,FUNCT_7:def 1;
    hence Den(In(i, dom the charact of A), A).p
        = FreeOpNSG(i,S,X).p by A0,FREEALG:def 12
       .= Sym(i,S,X)-tree p by A0,A5,FREEALG:def 11
       .= i-tree p by A0,FREEALG:def 10;
  end;

definition
  let A be non-empty UAStr;
  let B be Subset of A;
  let n be Nat;
  func B|^n -> Subset of A means:
POWER:
  ex F being Function of NAT, bool the carrier of A st it = F.n & F.0 = B &
  for n being Nat holds F.(n+1) = F.n \/
  {Den(o,A).p where o is (Element of dom the charact of A),
  p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= F.n};
  existence
  proof
    defpred P[set,set,set] means
    $3 = $2 \/ {Den(o,A).p where o is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= $2};
A0: for n being Element of NAT
    for B1 being Subset of A ex B2 being Subset of A st P[n,B1,B2]
    proof
      let n be Element of NAT, B1 be Subset of A;
      set B2 = B1 \/ {Den(o,A).p where o is (Element of dom the charact of A),
      p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B1};
      B2 c= the carrier of A
      proof
        let x be set; assume
A2:     x in B2 & not x in the carrier of A;
        x in B1 implies x in the carrier of A; then
        x in {Den(o,A).p where o is (Element of dom the charact of A),
        p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B1}
        by A2,XBOOLE_0:def 2; then
        consider o being (Element of dom the charact of A), p being
        Element of (the carrier of A)* such that
A3:     x = Den(o,A).p & p in dom Den(o,A) & rng p c= B1;
        x in rng Den(o,A) by A3,FUNCT_1:def 5;
        hence contradiction by A2;
      end; then
      reconsider B2 as Subset of A;
      take B2;
      thus P[n,B1,B2];
    end;
    consider F being Function of NAT, bool the carrier of A such that
A1: F.0 = B & for n being Element of NAT holds P[n,F.n,F.(n+1)]
    from RECDEF_1:sch 2(A0);
    reconsider n' = n as Element of NAT by ORDINAL1:def 13;
    take a = F.n', F; thus a = F.n & F.0 = B by A1;
    let n be Nat; n in NAT by ORDINAL1:def 13;
    hence thesis by A1;
  end;
  uniqueness
  proof
    let C1,C2 be Subset of A;
    deffunc Rec(set,set) = $2 \/
    {Den(o,A).p where o is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= $2};
    given F1 being Function of NAT, bool the carrier of A such that
A1: C1 = F1.n and
B1: F1.0 = B & for n being Nat holds F1.(n+1) = Rec(n,F1.n);
    given F2 being Function of NAT, bool the carrier of A such that
A2: C2 = F2.n and
B2: F2.0 = B & for n being Nat holds F2.(n+1) = Rec(n,F2.n);
C1: dom F1 = NAT & F1.0 = B & for n being Element of NAT
    holds F1.(n+1) = Rec(n,F1.n) by B1,FUNCT_2:def 1;
C2: dom F2 = NAT & F2.0 = B & for n being Element of NAT
    holds F2.(n+1) = Rec(n,F2.n) by B2,FUNCT_2:def 1;
    F1 = F2 from RECDEF_1:sch 11(C1,C2);
    hence thesis by A1,A2;
  end;
end;

theorem ThA0:
  for A being Universal_Algebra, B being Subset of A
  holds B|^0 = B
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    ex F being Function of NAT, bool the carrier of A st B|^0 = F.0 & F.0 = B &
    for n being Nat holds F.(n+1) = F.n \/ {Den(o,A).p where o is (Element of
    dom the charact of A), p is Element of (the carrier of A)*: p in dom
    Den(o,A) & rng p c= F.n} by POWER;
    hence B|^0 = B;
  end;

theorem ThA4:
  for A being Universal_Algebra, B being Subset of A
  for n being Nat
  holds B|^(n+1) = (B|^n) \/ {Den(o,A).p
  where o is (Element of dom the charact of A),
  p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B|^n}
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    let n be Nat;
    deffunc Rec(set,set) = $2 \/
    {Den(o,A).p where o is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= $2};
    consider F1 being Function of NAT, bool the carrier of A such that
B0: B|^(n) = F1.(n) and
B1: F1.0 = B & for n being Nat holds F1.(n+1) = Rec(n,F1.n) by POWER;
    consider F2 being Function of NAT, bool the carrier of A such that
B3: B|^(n+1) = F2.(n+1) and
B2: F2.0 = B & for n being Nat holds F2.(n+1) = Rec(n,F2.n) by POWER;
C1: dom F1 = NAT & F1.0 = B & for n being Element of NAT
    holds F1.(n+1) = Rec(n,F1.n) by B1,FUNCT_2:def 1;
C2: dom F2 = NAT & F2.0 = B & for n being Element of NAT
    holds F2.(n+1) = Rec(n,F2.n) by B2,FUNCT_2:def 1;
    F1 = F2 from RECDEF_1:sch 11(C1,C2);
    hence thesis by B0,B1,B3;
  end;

theorem ThA4':
  for A being Universal_Algebra, B being Subset of A
  for n being Nat
  for x being set
  holds x in B|^(n+1) iff x in B|^n or
  ex o being Element of dom the charact of A st
  ex p being Element of (the carrier of A)*
  st x = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^n
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    let n be Nat;
    set Z = {Den(o,A).p where o is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B|^n};
    let x be set;
    B|^(n+1) = (B|^n) \/ Z by ThA4; then
    x in B|^(n+1) iff  x in B|^n or x in Z by XBOOLE_0:def 2;
    hence thesis;
  end;

theorem ThA3:
  for A being Universal_Algebra, B being Subset of A
  for n,m being Nat st n <= m
  holds B|^n c= B|^m
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    let n,m be Nat;
    assume n <= m; then
    consider i being Nat such that
A1: m = n+i by NAT_1:10;
    defpred P[Nat] means B|^n c= B|^(n+$1);
A2: P[0];
A3: now
      let i be Nat; assume
A4:   P[i];
      deffunc Rec(set,set) = $2 \/
      {Den(o,A).p where o is (Element of dom the charact of A),
      p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= $2};
      B|^(n+i+1) = Rec(n,B|^(n+i)) by ThA4; then
      B|^(n+i) c= B|^(n+(i+1)) by XBOOLE_1:7;
      hence P[i+1] by A4,XBOOLE_1:1;
    end;
    for i being Nat holds P[i] from NAT_1:sch 2(A2,A3);
    hence B|^n c= B|^m by A1;
  end;

theorem ThA33:
  for A being Universal_Algebra
  for B1,B2 being Subset of A st B1 c= B2
  for n being Nat holds B1|^n c= B2|^n
  proof
    let A be Universal_Algebra;
    let B1,B2 be Subset of A such that
01: B1 c= B2;
    defpred P[Nat] means B1|^$1 c= B2|^$1;
    B1|^0 = B1 by ThA0; then
A0: P[0] by 01,ThA0;
AI: now let n be Nat;
      assume
AZ:   P[n];
      thus P[n+1]
      proof
        let x be set; assume
A1:     x in B1|^(n+1) & x nin B2|^(n+1); then
        reconsider a = x as Element of A;
        a nin B1|^n by A1,ThA4',AZ; then
        consider o being (Element of dom the charact of A),
        p being Element of (the carrier of A)* such that
A2:     a = Den(o,A).p & p in dom Den(o,A) & rng p c= B1|^n by A1,ThA4';
        rng p c= B2|^n by AZ,A2,XBOOLE_1:1;
        hence contradiction by A1,A2,ThA4';
      end;
    end;
    for n being Nat holds P[n] from NAT_1:sch 2(A0,AI);
    hence thesis;
  end;

theorem ThA4'':
  for A being Universal_Algebra, B being Subset of A
  for n being Nat
  for x being set
  holds x in B|^(n+1) iff x in B or
  ex o being Element of dom the charact of A st
  ex p being Element of (the carrier of A)*
  st x = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^n
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    defpred P[Nat] means for x being set st x in B|^($1+1) holds x in B or
    ex o being Element of dom the charact of A st
    ex p being Element of (the carrier of A)*
    st x = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^$1;
C0: B|^0 = B by ThA0; then
A0: P[0] by ThA4';
A1: now let n be Nat such that
B1:   P[n];
      thus P[n+1]
      proof
        let x be set;
        assume x in B|^(n+1+1); then
B2:     x in B|^(n+1) or ex o being Element of dom the charact of A st
        ex p being Element of (the carrier of A)*
        st x = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^(n+1)
        by ThA4';
        now given o being (Element of dom the charact of A),
          p being Element of (the carrier of A)* such that
B3:       x = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^n;
          take o,p; n <= n+1 by NAT_1:13; then
          B|^n c= B|^(n+1) by ThA3;
          hence x = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^(n+1)
          by B3,XBOOLE_1:1;
        end;
        hence thesis by B1,B2;
      end;
    end;
AA: for n being Nat holds P[n] from NAT_1:sch 2(A0,A1);
    let n be Nat;
    let x be set;
    B c= B|^n by C0,ThA3;
    hence thesis by AA,ThA4';
  end;

scheme MaxVal{A() -> non empty set, B() -> set, P[set,set]}:
  ex n being Nat st
  for x being Element of A() st x in B() holds P[x,n]
  provided
P1: B() is finite
  and
P2: for x being Element of A() st x in B() ex n being Nat st P[x,n]
  and
P3: for x being Element of A()
  for n,m being Nat st P[x,n] & n <= m holds P[x,m]
  proof
A1: for x being set st x in A()/\B() ex y being set st y in NAT & P[x,y]
    proof
      let x be set;
      assume
00:   x in A()/\B(); then
      reconsider x as Element of A() by XBOOLE_0:def 3;
      x in B() by 00,XBOOLE_0:def 3; then
      consider n being Nat such that
01:   P[x,n] by P2;
      n is Element of NAT by ORDINAL1:def 13;
      hence thesis by 01;
    end;
    consider f being Function such that
A2: dom f = A()/\B() & rng f c= NAT and
A3: for x being set st x in A()/\B() holds P[x,f.x] from WELLORD2:sch 1(A1);
    dom f is finite by A2,P1,FINSET_1:15; then
    reconsider Z = rng f as finite Subset of NAT by A2,FINSET_1:26;
    consider n being Element of NAT such that
A4: for i being Element of NAT st i in Z holds i <= n by STIRL2_1:66;
    take n; let x be Element of A();
    assume x in B(); then
A5: x in A()/\B() by XBOOLE_0:def 3; then
A6: f.x in rng f by A2,FUNCT_1:def 5; then
    reconsider i = f.x as Element of NAT by A2;
    i <= n & P[x,i] by A3,A5,A4,A6;
    hence thesis by P3;
  end;

theorem ThA1:
  for A being Universal_Algebra, B being Subset of A
  ex C being Subset of A
  st C = union {B|^n where n is Element of NAT: not contradiction} &
  C is opers_closed
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    set X = {B|^n where n is Element of NAT: not contradiction};
    set C = union X;
A0: union bool the carrier of A = the carrier of A by ZFMISC_1:99;
    X c= bool the carrier of A
    proof
      let x be set; assume x in X; then
      ex n being Element of NAT st x = B|^n;
      hence thesis;
    end; then
    reconsider C as Subset of A by A0,ZFMISC_1:95;
    take C; thus C = union {B|^n where n is Element of NAT: not contradiction};
    let o be Element of Operations A;
    consider s being set such that
A1: s in dom the charact of A & o = (the charact of A).s by FUNCT_1:def 5;
    reconsider s as OperSymbol of A by A1;
A2: dom o = (arity o)-tuples_on the carrier of A by UNIALG_2:2;
    let p be FinSequence of C;
    assume len p = arity o; then
    p is Element of dom Den(s,A) by A2,A1,FINSEQ_2:110; then
A9: p in dom Den(s,A) by A2,A1;
    defpred P[set,Nat] means $1 in B|^$2;
A4: rng p is finite;
A5: for x being Element of A st x in rng p ex n being Nat st P[x,n]
    proof
      let x be Element of A;
      assume
01:   x in rng p;
      rng p c= C by FINSEQ_1:def 4; then
      consider Y being set such that
02:   x in Y & Y in X by 01,TARSKI:def 4;
      consider n being Element of NAT such that
03:   Y = B|^n by 02;
      take n;
      thus P[x,n] by 02,03;
    end;
A6: for x being Element of A
    for n,m being Nat st P[x,n] & n <= m holds P[x,m]
    proof
      let x be Element of A;
      let n,m be Nat;
      assume
01:   P[x,n];
      assume n <= m; then
      B|^n c= B|^m by ThA3;
      hence thesis by 01;
    end;
    consider n being Nat such that
A7: for x being Element of A st x in rng p holds P[x,n] from MaxVal(A4,A5,A6);
    rng p c= B|^n
    proof
      let x be set; assume
B0:   x in rng p;
      thus thesis by A7,B0;
    end; then
    Den(s,A).p in {Den(a,A).r where a is (Element of dom the charact of A),
    r is Element of (the carrier of A)*: r in dom Den(a,A) & rng r c= B|^n}
    by A9; then
    o.p in (B|^n)\/{Den(a,A).r where a is (Element of dom the charact of A),
    r is Element of (the carrier of A)*: r in dom Den(a,A) & rng r c= B|^n} &
    n+1 in NAT by A1,XBOOLE_0:def 2,ORDINAL1:def 13; then
    o.p in B|^(n+1) & B|^(n+1) in X by ThA4;
    hence o.p in C by TARSKI:def 4;
  end;
  
theorem ThA2:
  for A being Universal_Algebra, B,C being Subset of A
  st C is opers_closed & B c= C
  holds union {B|^n where n is Element of NAT: not contradiction} c= C
  proof
    let A be Universal_Algebra;
    let B,C be Subset of A;
    assume
00: C is opers_closed;
    assume
01: B c= C;
    let z be set; assume
    z in union {B|^n where n is Element of NAT: not contradiction}; then
    consider Y being set such that
05: z in Y & Y in {B|^n where n is Element of NAT: not contradiction}
    by TARSKI:def 4;
    consider n being Element of NAT such that
06: Y = B|^n by 05;
    defpred P[Nat] means B|^$1 c= C;
02: P[0] by 01,ThA0;
03: now let n be Nat;
      assume
04:   P[n];
      thus P[n+1]
      proof let x be set;
        assume
A1:     x in B|^(n+1) & x nin C; then
        x in (B|^n)\/{Den(o,A).p where o is (Element of dom the charact of A),
        p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B|^n}
        by ThA4; then
        x in B|^n or
        x in {Den(o,A).p where o is (Element of dom the charact of A),
        p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B|^n}
        by XBOOLE_0:def 2; then
        consider o being (Element of dom the charact of A), p being Element
        of (the carrier of A)* such that
A2:     x = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^n by A1,04;
        rng p c= C by A2,04,XBOOLE_1:1; then
        reconsider p as FinSequence of C by FINSEQ_1:def 4;
        reconsider oo = Den(o,A) as Element of Operations A;
        len p = arity oo & C is_closed_on oo
        by 00,A2,UNIALG_1:def 10,UNIALG_2:def 5;
        hence thesis by A1,A2,UNIALG_2:def 4;
      end;
    end;
    for n being Nat holds P[n] from NAT_1:sch 2(02,03); then
    P[n];
    hence thesis by 05,06;
  end;

definition
  let A be Universal_Algebra;
  func Generators A -> Subset of A equals (the carrier of A) \
  union {rng o where o is Element of Operations A: not contradiction};
  coherence;
end;

theorem LemG:
  for A being Universal_Algebra, a being Element of A holds
  a in Generators A iff not ex o being Element of Operations A st a in rng o
  proof
    let A be Universal_Algebra;
    set Z = {rng o where o is Element of Operations A: not contradiction};
    let a be Element of A;
    hereby 
      assume a in Generators A; then
00:   a nin union Z by XBOOLE_0:def 4;
      given o being Element of Operations A such that
01:   a in rng o;
      rng o in Z;
      hence contradiction by 00,01,TARSKI:def 4;
    end;
    assume
02: not ex o being Element of Operations A st a in rng o;
    assume a nin Generators A; then
    a in union Z by XBOOLE_0:def 4; then
    consider X being set such that
03: a in X & X in Z by TARSKI:def 4;
    ex o being Element of Operations A st X = rng o by 03;
    hence contradiction by 02,03;
  end;

theorem
  for A being Universal_Algebra
  for B being Subset of A st B is opers_closed
  holds Constants A c= B
  proof
    let A be Universal_Algebra;
    let B be Subset of A such that
A0: B is opers_closed;
    let x be set; assume x in Constants A; then
    consider a being Element of A such that
A1: x = a & ex o being Element of Operations A st arity o = 0 & a in rng o;
    consider o being Element of Operations A such that
A2: arity o = 0 & a in rng o by A1;
    consider s being set such that
A3: s in dom o & a = o.s by A2,FUNCT_1:def 5;
    consider z being set such that
A4: z in dom the charact of A & o = (the charact of A).z by FUNCT_1:def 5;
    reconsider z as Element of dom the charact of A by A4;
A6: dom o = 0-tuples_on the carrier of A by A2,UNIALG_2:2;
    reconsider s as Element of (the carrier of A)* by A3;
A7: len s = 0 by A3,A6,FINSEQ_2:109; then
    s = {} by FINSEQ_1:25; then
    rng s c= B by XBOOLE_1:2,RELAT_1:60; then
    s is FinSequence of B & B is_closed_on o
    by FINSEQ_1:def 4,A0,UNIALG_2:def 5;
    hence x in B by A1,A2,A3,A7,UNIALG_2:def 4;
  end;

theorem Lem01:
  for A being Universal_Algebra st Constants A = {}
  holds {} A is opers_closed
  proof
    let A be Universal_Algebra such that
A1: Constants A = {};
    let o be Element of Operations A;
    let s be FinSequence of {} A;
    assume
A2: len s = arity o;
A4: {} A c= the carrier of A & rng s c= {} A by FINSEQ_1:def 4;
    s is Element of (arity o)-tuples_on the carrier of A &
    dom o = (arity o)-tuples_on the carrier of A
    by A2,FINSEQ_2:110,UNIALG_2:2; then
A3: o.s in rng o by FUNCT_1:def 5; then
    reconsider a = o.s as Element of A;
    a nin Constants A by A1; then
    arity o <> 0 by A3; then
    s <> {} by A2,FINSEQ_1:25; then
    rng s <> {} by RELAT_1:64;
    hence thesis by A4,XBOOLE_1:3;
  end;

theorem
  for A being Universal_Algebra st Constants A = {}
  for G being GeneratorSet of A
  holds G <> {}
  proof
    let A be Universal_Algebra such that
00: Constants A = {};
    let G be GeneratorSet of A;
    assume
01: G = {}; then
    G = {} A; then
    G is opers_closed & G c= G & the carrier of A <> {} by 00,Lem01;
    hence thesis by 01,FREEALG:def 5;
  end;

theorem ThA60:
  for A being Universal_Algebra
  for G being Subset of A
  holds G is GeneratorSet of A iff
  for I being Element of A ex n being Nat st I in G|^n
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    set X = {B|^n where n is Element of NAT: not contradiction};
    consider C being Subset of A such that
A1: C = union X & C is opers_closed by ThA1;
    B|^0 = B by ThA0; then
    B in X; then
A2: B c= C by A1,ZFMISC_1:92;
    consider o being Element of Operations A;
    thus B is GeneratorSet of A implies for I being Element of A
    ex n being Nat st I in B|^n
    proof
      assume
      for D being Subset of A st D is opers_closed & B c= D
      holds D = the carrier of A; then
02:   C = the carrier of A by A1,A2;
      let I be Element of A;
      consider Y being set such that
03:   I in Y & Y in X by 02,A1,TARSKI:def 4;
      ex n being Element of NAT st Y = B|^n by 03;
      hence thesis by 03;
    end;
    assume
01: for I being Element of A ex n being Nat st I in B|^n;
    let D be Subset of A; assume
    D is opers_closed & B c= D; then
02: union X c= D by ThA2;
    thus D c= the carrier of A;
    let x be set; assume x in the carrier of A; then
    reconsider I = x as Element of A;
    consider n being Nat such that
03: I in B|^n by 01;
    reconsider n as Element of NAT by ORDINAL1:def 13;
    B|^n in X; then
    I in union X by 03,TARSKI:def 4;
    hence thesis by 02;
  end;

theorem LemG1:
  for A being Universal_Algebra
  for B being Subset of A
  for G being GeneratorSet of A st G c= B
  holds B is GeneratorSet of A
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    let G be GeneratorSet of A such that
A0: G c= B;
    now let a be Element of A;
      consider n being Nat such that
A1:   a in G|^n by ThA60;
      take n;
      G|^n c= B|^n by A0,ThA33;
      hence a in B|^n by A1; 
    end;
    hence thesis by ThA60;
  end;

theorem Free0:
  for A being Universal_Algebra
  for G being GeneratorSet of A
  for a being Element of A
  st not ex o being Element of Operations A st a in rng o
  holds a in G
  proof
    let A be Universal_Algebra;
    let G be GeneratorSet of A;
    let a be Element of A;
    assume
00: for o being Element of Operations A holds a nin rng o;
    defpred P[Nat] means a nin G|^$1;
    assume a nin G; then
01: P[0] by ThA0;
02: now let n be Nat;
      assume
A1:   P[n];
      thus P[n+1]
      proof
        assume a in G|^(n+1); then
        a in (G|^n) \/ {Den(o,A).p
        where o is (Element of dom the charact of A),
        p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= G|^n}
        by ThA4; then
        a in {Den(o,A).p where o is (Element of dom the charact of A),
        p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= G|^n}
        by A1,XBOOLE_0:def 2; then
        consider o being (Element of dom the charact of A), p being Element of
        (the carrier of A)* such that
A2:     a = Den(o,A).p & p in dom Den(o,A) & rng p c= G|^n;
        Den(o,A) in Operations A & a in rng Den(o,A) by A2,FUNCT_1:def 5;
        hence contradiction by 00;
      end;
    end;
    for n being Nat holds P[n] from NAT_1:sch 2(01,02);
    hence contradiction by ThA60;
  end;

theorem
  for A being Universal_Algebra, G being GeneratorSet of A
  holds Generators A c= G
  proof
    let A be Universal_Algebra;
    let G be GeneratorSet of A;
    let a be set; assume
Z:   a in Generators A; then
A1: a nin union {rng o where o is Element of
    Operations A: not contradiction} by XBOOLE_0:def 4;
    reconsider I = a as Element of A by Z;
    assume a nin G; then
    consider o0 being Element of Operations A such that
A2: I in rng o0 by Free0;
    rng o0 in {rng o where o is Element of Operations A: not contradiction};
    hence contradiction by A1,A2,TARSKI:def 4;
  end;

theorem Free1:
  for A being free Universal_Algebra
  for G being free GeneratorSet of A
  holds G = Generators A
  proof
    let A be free Universal_Algebra;
    let G be free GeneratorSet of A;
    reconsider S = signature A as non empty FinSequence of NAT by MSUALG_1:9;
    consider B being Universal_Algebra such that
A1: the carrier of B = NAT & signature B = S and
A2: for i,j being Nat st i in dom S & j = S.i
    holds (the charact of B).i = (j-tuples_on NAT) --> i by ExUA2;
    reconsider f = G --> 0 as Function of G, the carrier of B by A1;
    A,B are_similar by A1,UNIALG_2:def 2; then
    consider h being Function of A,B such that
A3: h is_homomorphism A,B & h|G = f by FREEALG:def 6;
    len S = len the charact of B & len S = len the charact of A
    by A1,UNIALG_1:def 11; then
B2: dom S = dom the charact of B & dom S = dom the charact of A by FINSEQ_3:31;
    thus G c= Generators A
    proof
      let a be set; assume
A4:   a in G; then reconsider I = a as Element of A;
      assume not thesis; then
      I in union {rng o where o is Element of Operations A: not contradiction}
      by XBOOLE_0:def 4; then
      consider Y being set such that
A5:   I in Y & Y in{rng o where o is Element of Operations A:not contradiction}
      by TARSKI:def 4;
      consider o being Element of Operations A such that
A6:   Y = rng o by A5;
      consider i being set such that
A7:   i in dom the charact of A & o = (the charact of A).i by FUNCT_1:def 5;
      reconsider i as Element of NAT by A7;
      reconsider j = S.i as Element of NAT;
      reconsider o2 = (the charact of B).i as Element of Operations B
      by B2,A7,FUNCT_1:def 5;
      consider x being set such that
A8:   x in dom o & I = o.x by A5,A6,FUNCT_1:def 5;
B3:   dom o = (arity o)-tuples_on the carrier of A by UNIALG_2:2;
      reconsider x as FinSequence of A by A8,FINSEQ_1:def 11;
      reconsider hx = h*x as FinSequence of NAT by A1;
      len (h*x) = len x by FINSEQ_2:37 .= arity o by B3,A8,FINSEQ_2:109
      .= j by B2,A7,UNIALG_1:def 11; then
A9:   hx is Element of j-tuples_on NAT by FINSEQ_2:110;
      0 = f.I by A4,FUNCOP_1:13
      .= h.(o.x) by A3,A4,A8,FUNCT_1:72
      .= o2.(h*x) by A3,A7,A8,ALG_1:def 1
      .= ((j-tuples_on NAT) --> i).(h*x) by A2,B2,A7
      .= i by A9,FUNCOP_1:13;
      hence contradiction by A7,FINSEQ_3:27;
    end;
    let a be set; assume a1: a in Generators A; then
A1: a in the carrier of A & a nin union {rng o where o is Element of
      Operations A: not contradiction} by XBOOLE_0:def 4;
    reconsider I = a as Element of A by a1;
    assume a nin G; then
    consider o0 being Element of Operations A such that
A2: I in rng o0 by Free0;
    rng o0 in {rng o where o is Element of Operations A: not contradiction};
    hence contradiction by A1,A2,TARSKI:def 4;
  end;

registration
  let A be free Universal_Algebra;
  cluster Generators A -> free GeneratorSet of A;
  coherence
  proof
    consider G being free GeneratorSet of A;
    Generators A = G by Free1;
    hence thesis;
  end;
end;

definition
  let A be free Universal_Algebra;
  redefine func Generators A -> GeneratorSet of A;
  coherence
  proof
    consider G being free GeneratorSet of A;
    Generators A = G by Free1;
    hence thesis;
  end;
end;

registration
  let A,B be set;
  cluster [:A,B:] -> disjoint_with_NAT;
  coherence
  proof
    now
      let z be set;
      assume z in [:A,B:] & z in NAT; then
      z is Element of NAT &
      ex a,b being set st a in A & b in B & z = [a,b] by ZFMISC_1:def 2;
      hence contradiction;
    end;
    hence [:A,B:] misses NAT by XBOOLE_0:3;
  end;
end;

theorem
  for A being free Universal_Algebra
  for G being GeneratorSet of A
  for B being Universal_Algebra
  for h1,h2 being Function of A,B
  st h1 is_homomorphism A,B & h2 is_homomorphism A,B & h1|G = h2|G
  holds h1 = h2
  proof
    let A be free Universal_Algebra;
    let G be GeneratorSet of A;
    let B be Universal_Algebra;
    let h1,h2 be Function of A,B such that
01: h1 is_homomorphism A,B & h2 is_homomorphism A,B & h1|G = h2|G;
    defpred P[Nat] means
    for a being Element of A st a in G|^$1 holds h1.a = h2.a;
A0: P[0]
    proof let a be Element of A;
      assume a in G|^0; then a in G by ThA0; then
      h1.a = (h1|G).a & h2.a = (h2|G).a by FUNCT_1:72;
      hence thesis by 01;
    end;
AI: for n being Nat st P[n] holds P[n+1]
    proof
      let n be Nat such that
A1:   P[n];
      let a be Element of A; assume
A2:   a in G|^(n+1) & h1.a <> h2.a; then
      a nin G|^n by A1; then
      consider o being (Element of dom the charact of A),
      p being Element of (the carrier of A)* such that
A3:   a = Den(o,A).p & p in dom Den(o,A) & rng p c= G|^n by A2,ThA4';
      A,B are_similar by 01,ALG_1:def 1; then
      len the charact of A = len the charact of B by UNIALG_2:3; then
      reconsider o' = o as Element of dom the charact of B by FINSEQ_3:31;
      Operations A = rng the charact of A &
      Operations B = rng the charact of B; then
A4:   h1.a = Den(o',B).(h1*p) & h2.a = Den(o',B).(h2*p) by A3,01,ALG_1:def 1;
      now
        dom h1 = the carrier of A & dom h2 = the carrier of A by FUNCT_2:def 1;
        hence G|^n c= dom h1 & G|^n c= dom h2;
        let x be set; assume x in G|^n;
        hence h1.x = h2.x by A1;
      end;
      hence thesis by A2,A4,A3,LemFunc;
    end;
TT: for n being Nat holds P[n] from NAT_1:sch 2(A0,AI);
    now let a be Element of A;
      ex n being Nat st a in G|^n by ThA60;
      hence h1.a = h2.a by TT;
    end;
    hence h1 = h2 by FUNCT_2:113;
  end;

preFree2:
  for A being free Universal_Algebra
  for o1,o2 being OperSymbol of A
  for p1,p2 being FinSequence st p1 in dom Den(o1,A) & p2 in dom Den(o2,A)
  holds Den(o1,A).p1 = Den(o2,A).p2 implies o1 = o2
  proof
    let A be free Universal_Algebra;
    consider G being free GeneratorSet of A;
    let o1,o2 be OperSymbol of A;
    let p1,p2 be FinSequence such that
00: p1 in dom Den(o1,A) & p2 in dom Den(o2,A) and
01: Den(o1,A).p1 = Den(o2,A).p2;
    reconsider S = signature A as non empty FinSequence of NAT by MSUALG_1:9;
    consider B being Universal_Algebra such that
A1: the carrier of B = NAT & signature B = S and
A2: for i,j being Nat st i in dom S & j = S.i
    holds (the charact of B).i = (j-tuples_on NAT) --> i by ExUA2;
    reconsider f = G --> 0 as Function of G, the carrier of B by A1;
    A,B are_similar by A1,UNIALG_2:def 2; then
    consider h being Function of A,B such that
A3: h is_homomorphism A,B & h|G = f by FREEALG:def 6;
b2: len S = len the charact of B & len S = len the charact of A
    by A1,UNIALG_1:def 11; then
B2: dom S = dom the charact of B & dom S = dom the charact of A
      by FINSEQ_3:31;
    reconsider b1 = o1, b2 = o2 as OperSymbol of B by b2,FINSEQ_3:31;
    o1 in dom the charact of A & o2 in dom the charact of A &
    dom the charact of A = Seg len the charact of A by FINSEQ_1:def 3; then
    reconsider n1 = o1, n2 = o2 as Element of NAT;
    reconsider j1 = S.n1, j2 = S.n2 as Element of NAT;
    reconsider x1 = p1, x2 = p2 as FinSequence of A by 00,FINSEQ_1:def 11;
    reconsider h1 = h*x1, h2 = h*x2 as FinSequence of NAT by A1;
    reconsider oo1 = Den(o1,A), oo2 = Den(o2,A) as Element of Operations A;
B3: dom oo1 = (arity oo1)-tuples_on the carrier of A &
    dom oo2 = (arity oo2)-tuples_on the carrier of A by UNIALG_2:2;
    len x1 = arity oo1 by B3,00,FINSEQ_2:109
    .= j1 by B2,UNIALG_1:def 11; then
    len h1 = j1 by FINSEQ_2:37; then
B4: h1 is Element of j1-tuples_on NAT by FINSEQ_2:110;
    len x2 = arity oo2 by B3,00,FINSEQ_2:109
    .= j2 by B2,UNIALG_1:def 11; then
    len h2 = j2 by FINSEQ_2:37; then
B5: h2 is Element of j2-tuples_on NAT by FINSEQ_2:110;
    Den(o1,A) = (the charact of A).n1 & Den(o1,A) is Element of Operations A &
    Den(b1,B) = (the charact of B).n1 & Den(b1,B) is Element of Operations B &
    Den(o2,A) = (the charact of A).n2 & Den(o2,A) is Element of Operations A &
    Den(b2,B) = (the charact of B).n2 & Den(b2,B) is Element of Operations B;
    then
B6: h.(Den(o1,A).x1) = Den(b1,B).h1 & h.(Den(o2,A).x2) = Den(b2,B).h2
    by 00,A3,ALG_1:def 1;
    Den(b1,B) = (j1-tuples_on NAT)-->n1 & Den(b2,B) = (j2-tuples_on NAT)-->n2
    by A2,B2; then
    Den(b1,B).h1 = n1 & Den(b2,B).h2 = n2 by B4,B5,FUNCOP_1:13;
    hence o1 = o2 by 01,B6;
  end;

theorem Free2:
  for A being free Universal_Algebra
  for o1,o2 being OperSymbol of A
  for p1,p2 being FinSequence st p1 in dom Den(o1,A) & p2 in dom Den(o2,A)
  holds Den(o1,A).p1 = Den(o2,A).p2 implies o1 = o2 & p1 = p2
  proof
    let A be free Universal_Algebra;
    consider G being free GeneratorSet of A;
    let o1,o2 be OperSymbol of A;
    let p1,p2 be FinSequence such that
00: p1 in dom Den(o1,A) & p2 in dom Den(o2,A) and
01: Den(o1,A).p1 = Den(o2,A).p2;
    thus
B7: o1 = o2 by 00,01,preFree2;
    reconsider S = signature A as non empty FinSequence of NAT by MSUALG_1:9;
    reconsider oo1 = Den(o1,A), oo2 = Den(o2,A) as Element of Operations A;
    set RNG = {rng o where o is Element of Operations A: not contradiction};
    set G' = G \/ {the carrier of A};
    reconsider G' as non empty set;
    deffunc F(set) = root-tree [0,$1];
    consider g being Function such that
G1: dom g = G & for x being set st x in G holds g.x = F(x) from FUNCT_1:sch 3;
    set X = [:{0},G':];
    set B = FreeUnivAlgNSG(S,X);
A1: signature B = S by FREEALG:4;
F1: Terminals DTConUA(S,[:{0},G':]) = [:{0},G':] by FREEALG:3;
    rng g c= FreeGenSetNSG(S,[:{0},G':])
    proof
      let b be set; assume b in rng g; then
      consider a being set such that
01:   a in dom g & b = g.a by FUNCT_1:def 5;
      reconsider a as Element of A by G1,01;
      a in G' & 0 in {0} by G1,01,XBOOLE_0:def 2,TARSKI:def 1; then
F2:   [0,a] in [:{0},G':] by ZFMISC_1:106; then
      reconsider s = [0,a] as Symbol of DTConUA(S,[:{0},G':]) by F1;
      root-tree s in FreeGenSetNSG(S,[:{0},G':]) by F1,F2;
      hence thesis by G1,01;
    end; then
    rng g c= the carrier of B by XBOOLE_1:1; then
    reconsider g  as Function of G, the carrier of B by G1,FUNCT_2:4;
    signature B = S by FREEALG:4; then
    A,B are_similar by UNIALG_2:def 2; then
    consider h being Function of A,B such that
A3: h is_homomorphism A,B & h|G = g by FREEALG:def 6;
    defpred G[Nat] means
    for a1,a2 being set st a1 in G|^$1 & a2 in G|^$1 & h.a1 = h.a2
    holds a1 = a2;
G0: G|^0 = G by ThA0;
b2: len S = len the charact of B & len S = len the charact of A
    by A1,UNIALG_1:def 11; then
B2: dom S = dom the charact of B & dom S = dom the charact of A
    by FINSEQ_3:31;
X1: now let o be Element of dom the charact of A;
      let p be FinSequence of A such that
01:   p in dom Den(o,A);
      reconsider q = p as FinSequence of A;
      reconsider hq = h*q as FinSequence of B;
      reconsider op = Den(o,A) as Element of Operations A;
      reconsider on = o as Element of NAT;
      reconsider o' = on as OperSymbol of B by b2,FINSEQ_3:31;
      reconsider op' = Den(o',B) as Element of Operations B;
      S.o' in rng S & rng S c= NAT by B2,FUNCT_1:12,FINSEQ_1:def 4; then
      reconsider j = S.o' as Element of NAT;
      dom op = (arity op)-tuples_on the carrier of A by UNIALG_2:2; then
B5:   len p = arity op by 01,FINSEQ_2:109 .= j by B2,UNIALG_1:def 11;
      hence len p = S.o & len (h*p) = S.o by FINSEQ_2:37;
B6:   h.(op.q) = op'.hq by 01,A3,ALG_1:def 1;
B4:   In(o', dom the charact of B) = o' by FUNCT_7:def 1;
      o' in dom S & len hq = S.o' by B2,B5,FINSEQ_2:37;
      hence h.(Den(o,A).p) = o-tree (h*p) by B4,B6,Th18;
    end;
G3: G[0]
    proof
      let a1,a2 be set; assume
08:   a1 in G|^0 & a2 in G|^0 & h.a1 = h.a2; then
      h.a1 = g.a1 & h.a2 = g.a2 by G0,A3,FUNCT_1:72; then
      h.a1 = F(a1) & h.a2 = F(a2) by 08,G0,G1; then
      [0,a1] = [0,a2] by 08,TREES_4:4;
      hence a1 = a2 by ZFMISC_1:33;
    end;
X2: now
      let o be Element of dom the charact of A;
      let p be Element of (the carrier of A)*;
      assume p in dom Den(o,A); then
D3:   h.(Den(o,A).p) = o-tree(h*p) by X1;
      let x be set; assume
D1:   x in G; then
D2:   h.x = g.x by A3,FUNCT_1:72 .= F(x) by D1,G1;
      assume h.(Den(o,A).p) = h.x; then
      o = [0,x] & o is Element of NAT by D2,D3,TREES_4:17;
      hence contradiction;
    end;
G4: for k being Nat st G[k] holds G[k+1]
    proof
      let k be Nat such that
01:   G[k];
      defpred Gk[set] means
      ex o being Element of dom the charact of A st
      ex p being Element of (the carrier of A)*
      st $1 = Den(o,A).p & p in dom Den(o,A) & rng p c= G|^k;
      let a1,a2 be set; assume
08:   a1 in G|^(k+1) & a2 in G|^(k+1) & h.a1 = h.a2;
      per cases by 08,ThA4'';
      suppose
09:     a1 in G & a2 in G; then
        h.a1 = g.a1 & h.a2 = g.a2 by A3,FUNCT_1:72; then
        h.a1 = F(a1) & h.a2 = F(a2) by 09,G1; then
        [0,a1] = [0,a2] by 08,TREES_4:4;
        hence a1 = a2 by ZFMISC_1:33;
      end;
      suppose
09:     Gk[a1] & Gk[a2]; then
        consider b1 being (Element of dom the charact of A),
        q1 being Element of (the carrier of A)* such that
0C:     a1 = Den(b1,A).q1 & q1 in dom Den(b1,A) & rng q1 c= G|^k;
        consider b2 being (Element of dom the charact of A),
        q2 being Element of (the carrier of A)* such that
0D:     a2 = Den(b2,A).q2 & q2 in dom Den(b2,A) & rng q2 c= G|^k by 09;
        b1-tree(h*q1) = h.a1 by X1,0C .= b2-tree(h*q2) by X1,0D,08; then
0F:     b1 = b2 & h*q1 = h*q2 by TREES_4:15;
        len q1 = S.b1 & len q2 = S.b2 by 0C,0D,X1; then
0G:     dom q1 = Seg len q1 & dom q2 = Seg len q1 by 0F,FINSEQ_1:def 3;
        now let j be Element of NAT;
          assume
0H:       j in dom q1; then
          q1.j in rng q1 & q2.j in rng q2 by 0G,FUNCT_1:12; then
          q1.j in G|^k & q2.j in G|^k & h.(q1.j) = (h*q1).j &
          h.(q2.j) = (h*q2).j by 0C,0D,0G,0H,FUNCT_1:23;
          hence q1.j = q2.j by 01,0F;
        end;
        hence a1 = a2 by 0C,0D,0F,0G,FINSEQ_1:17;
      end;
      suppose
        a1 in G & Gk[a2] or Gk[a1] & a2 in G;
        hence a1 = a2 by 08,X2;
      end;
    end;
G5: for k being Nat holds G[k] from NAT_1:sch 2(G3,G4);
    reconsider q1 = p1, q2 = p2 as FinSequence of A by 00,FINSEQ_1:def 11;
    o1-tree(h*q1) = h.(Den(o1,A).p1) by 00,X1
    .= o2-tree(h*q2) by 01,00,X1; then
0F: h*p1 = h*p2 by TREES_4:15;
    len q1 = S.o1 & len q2 = S.o2 by 00,X1; then
0G: dom q1 = Seg len q1 & dom q2 = Seg len q1 by B7,FINSEQ_1:def 3;
    now let j be Element of NAT;
      assume
0H:   j in dom q1; then
0I:   q1.j in rng q1 & q2.j in rng q2 by 0G,FUNCT_1:12; then
      consider n1 being Nat such that
N1:   q1.j in G|^n1 by ThA60;
      consider n2 being Nat such that
N2:   q2.j in G|^n2 by 0I,ThA60;
      reconsider k = max(n1,n2) as Nat by XXREAL_0:16;
      n1 <= k & n2 <= k by XXREAL_0:25; then
      G|^n1 c= G|^k & G|^n2 c= G|^k by ThA3; then
      q1.j in G|^k & q2.j in G|^k & h.(q1.j) = (h*q1).j &
      h.(q2.j) = (h*q2).j & G[k] by G5,N1,N2,0G,0H,FUNCT_1:23;
      hence q1.j = q2.j by 0F;
    end;
    hence p1 = p2 by 0G,FINSEQ_1:17;
  end;

theorem
  for A being free Universal_Algebra
  for o1,o2 being Element of Operations A
  for p1,p2 being FinSequence st p1 in dom o1 & p2 in dom o2
  holds o1.p1 = o2.p2 implies o1 = o2 & p1 = p2
  proof
    let A be free Universal_Algebra;
    let o1,o2 be Element of Operations A;
    consider a1 being set such that
01: a1 in dom the charact of A & o1 = (the charact of A).a1 by FUNCT_1:def 5;
    consider a2 being set such that
02: a2 in dom the charact of A & o2 = (the charact of A).a2 by FUNCT_1:def 5;
    reconsider a1,a2 as OperSymbol of A by 01,02;
03: o1 = Den(a1,A) & o2 = Den(a2,A) by 01,02;
    let p1,p2 be FinSequence;
    assume p1 in dom o1 & p2 in dom o2 & o1.p1 = o2.p2;
    hence thesis by 03,Free2;
  end;

theorem Free4:
  for A being free Universal_Algebra
  for o being OperSymbol of A
  for p being FinSequence st p in dom Den(o,A)
  for a being set st a in rng p
  holds a <> Den(o,A).p
  proof
    let A be free Universal_Algebra;
    let o be OperSymbol of A;
    let p be FinSequence such that
A0: p in dom Den(o,A);
    let a be set such that
A1: a in rng p & a = Den(o,A).p;
    reconsider p as FinSequence of A by A0,FINSEQ_1:def 11;
    a in rng p by A1; then
    reconsider a as Element of A;
    set G = Generators A;
    consider n being Nat such that
A2: a in G|^n by ThA60;
    reconsider n as Element of NAT by ORDINAL1:def 13;
    defpred P[Nat] means ex a being (Element of A), o being OperSymbol of A st
    ex p being FinSequence of A st
    p in dom Den(o,A) & a in rng p & a = Den(o,A).p & a in G|^$1;
    a in rng p & a in G|^n by A1,A2; then
A3: ex n being Element of NAT st P[n] by A0,A1;
    consider n being Element of NAT such that
A4: P[n] & for m being Element of NAT st P[m] holds n <= m
    from NAT_1:sch 5(A3);
    consider a being (Element of A), o being OperSymbol of A,
    p being FinSequence of A such that
A5: p in dom Den(o,A) & a in rng p & a = Den(o,A).p & a in G|^n by A4;
    reconsider op = Den(o,A) as Element of Operations A;
    a in rng op by A5,FUNCT_1:12; then
    a nin G by LemG; then
    n <> 0 by A5,ThA0; then
    consider k being Nat such that
A6: n = k+1 by NAT_1:6;
    reconsider k as Element of NAT by ORDINAL1:def 13;
A8: k < n by A6,NAT_1:13; then
    a nin G|^k by A4,A5; then
    consider o' being (Element of dom the charact of A),
    p' being Element of (the carrier of A)* such that
A7: a = Den(o',A).p' & p' in dom Den(o',A) & rng p' c= G|^k by A5,A6,ThA4';
    p' = p by A5,A7,Free2;
    hence contradiction by A4,A5,A7,A8;
  end;

theorem Free5:
  for A being free Universal_Algebra
  for G being GeneratorSet of A
  for o being OperSymbol of A
  st for o' being OperSymbol of A, p being FinSequence
     st p in dom Den(o',A) & Den(o',A).p in G holds o' <> o
  for p being FinSequence st p in dom Den(o,A)
  for n being Nat st Den(o,A).p in G|^(n+1)
  holds rng p c= G|^n
  proof
    let A be free Universal_Algebra;
    let G be GeneratorSet of A;
    let o be OperSymbol of A such that
00: for o' being OperSymbol of A, p being FinSequence
    st p in dom Den(o',A) & Den(o',A).p in G holds o' <> o;
    let p be FinSequence such that
A0: p in dom Den(o,A);
    let n be Nat such that
A1: Den(o,A).p in G|^(n+1) & not rng p c= G|^n;
    reconsider p as FinSequence of A by A0,FINSEQ_1:def 11;
    defpred P[Nat] means
    ex p being FinSequence of A st
    p in dom Den(o,A) & Den(o,A).p in G|^($1+1) & not rng p c= G|^$1;
    p is FinSequence of A & n is Element of NAT by ORDINAL1:def 13; then
A3: ex n being Element of NAT st P[n] by A0,A1;
    consider n being Element of NAT such that
A4: P[n] & for m being Element of NAT st P[m] holds n <= m
    from NAT_1:sch 5(A3);
    consider p being FinSequence of A such that
A5: p in dom Den(o,A) & Den(o,A).p in G|^(n+1) & not rng p c= G|^n by A4;
    set a = Den(o,A).p;
    now assume
A6:   a in G|^n;
      a nin G by 00,A5; then
      n <> 0 by A6,ThA0; then
      consider k being Nat such that
A9:   n = k+1 by NAT_1:6;
      reconsider k as Element of NAT by ORDINAL1:def 13;
BB:   k < n by A9,NAT_1:13; then
      G|^k c= G|^n by ThA3; then
      not rng p c= G|^k by A5,XBOOLE_1:1;
      hence contradiction by A4,A5,A6,A9,BB;
    end; then
    ex o' being (Element of dom the charact of A),
    p' being Element of (the carrier of A)* st
    a = Den(o',A).p' & p' in dom Den(o',A) & rng p' c= G|^n by A5,ThA4';
    hence contradiction by A5,Free2;
  end;

theorem
  for A being free Universal_Algebra
  for o being OperSymbol of A
  for p being FinSequence st p in dom Den(o,A)
  for n being Nat st Den(o,A).p in (Generators A)|^(n+1)
  holds rng p c= (Generators A)|^n
  proof
    let A be free Universal_Algebra;
    set G = Generators A;
    let o be OperSymbol of A;
    now let o' be OperSymbol of A, p be FinSequence;
      reconsider op = Den(o',A) as Element of Operations A;
      assume p in dom Den(o',A); then
      op.p in rng op by FUNCT_1:12;
      hence Den(o',A).p in G implies o' <> o by LemG;
    end;
    hence thesis by Free5;
  end;

begin :: If-while Algebra

definition
  let S be non empty UAStr;
  attr S is with_empty-instruction means:
DEF0:
  1 in dom the charact of S &
  (the charact of S).1 is nullary (non empty homogeneous
  quasi_total PartFunc of (the carrier of S)*, the carrier of S);
  attr S is with_catenation means:
DEF1:
  2 in dom the charact of S &
  (the charact of S).2 is binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S);
  attr S is with_if-instruction means:
DEF2:
  3 in dom the charact of S &
  (the charact of S).3 is ternary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S);
  attr S is with_while-instruction means:
DEF3:
  4 in dom the charact of S &
  (the charact of S).4 is binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S);
  attr S is associative means:
DEF4:
  (the charact of S).2 is binary associative (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S);
end;

definition
  let S be non-empty UAStr;
  attr S is unital means:
DEF5:
  ex f being binary (non empty homogeneous
   quasi_total PartFunc of (the carrier of S)*, the carrier of S)
  st f = (the charact of S).2 &
     Den(In(1, dom the charact of S), S).({}) is_a_unity_wrt f;
end;

theorem Th0:
  for X being non empty set, x being Element of X
  for c being binary associative unital
    (non empty quasi_total homogeneous PartFunc of X*, X)
  st x is_a_unity_wrt c
  for i being ternary
    (non empty quasi_total homogeneous PartFunc of X*, X)
  for w being binary
    (non empty quasi_total homogeneous PartFunc of X*, X)
  ex S being non-empty strict UAStr st
  the carrier of S = X &
  the charact of S = <*(0-tuples_on X)-->x,c*>^<*i,w*> &
  S is with_empty-instruction with_catenation unital associative
       with_if-instruction with_while-instruction
       quasi_total partial
  proof
    let X be non empty set;
    let x be Element of X;
    let c be binary associative unital (non empty quasi_total homogeneous
    PartFunc of X*, X);
    assume
A1: x is_a_unity_wrt c;
    let i be ternary (non empty quasi_total homogeneous PartFunc of X*, X);
    let w be binary (non empty quasi_total homogeneous PartFunc of X*, X);
    set Y = 0-tuples_on X;
    set e = Y --> x;
    reconsider e as nullary
    (non empty quasi_total homogeneous PartFunc of X*, X) by Lem2;
    set char = <*e,c*>^<*i,w*>;
    reconsider ec = <*e,c*> as non empty FinSequence;
B1: ec^<*i,w*> is non empty;
    char is PFuncFinSequence of X
    proof
      let a be set;
      assume a in rng char; then
      a in rng <*e,c*> \/ rng <*i,w*> by FINSEQ_1:44; then
      a in rng <*e,c*> or a in rng <*i,w*> by XBOOLE_0:def 2; then
      a in {e,c} or a in {i,w} by FINSEQ_2:147; then
      a = e or a = c or a = i or a = w by TARSKI:def 2;
      hence a in PFuncs(X*, X) by PARTFUN1:119;
    end; then
    reconsider char as non empty non-empty PFuncFinSequence of X by B1;
    reconsider S = UAStr(#X, char#) as non-empty strict UAStr
    by UNIALG_1:def 9;
    take S;
    thus the carrier of S = X;
    thus the charact of S = <*(0-tuples_on X)-->x,c*>^<*i,w*>;
A6: len <*e,c*> = 2 & len <*i,w*> = 2 by FINSEQ_1:61; then
    len char = 2+2 by FINSEQ_1:35; then
A3: dom char = Seg 4 by FINSEQ_1:def 3;
    reconsider e as nullary (non empty homogeneous
    PartFunc of (the carrier of S)*, the carrier of S);
    reconsider c as binary associative (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S);
A4: <*e,c*>.1 = e & <*e,c*>.2 = c & <*i,w*>.1 = i & <*i,w*>.2 = w
    by FINSEQ_1:61;
    thus 1 in dom the charact of S by A3;
    dom <*e,c*> = Seg 2 by FINSEQ_3:29; then
A7: 1 in dom <*e,c*> & 2 in dom <*e,c*>; then
A9: e =  (the charact of S).1 & c = (the charact of S).2 by A4,FINSEQ_1:def 7;
    thus (the charact of S).1 is nullary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S)
     by A4,A7,FINSEQ_1:def 7;
    thus 2 in dom the charact of S by A3;
    thus (the charact of S).2 is binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S)
    by A7,A4,FINSEQ_1:def 7;
    thus S is unital
    proof take c;
      thus c = (the charact of S).2 by A7,A4,FINSEQ_1:def 7;
      1 in dom the charact of S by A3; then
      Y = {{}} & In(1, dom the charact of S) = 1
      by FUNCT_7:def 1,COMPUT_1:8; then
      {} in Y & e = Den(In(1, dom the charact of S),S)
      by A7,A4,FINSEQ_1:def 7,TARSKI:def 1;
      hence Den(In(1, dom the charact of S),S).({}) is_a_unity_wrt c
      by A1,FUNCOP_1:13;
    end;
    thus (the charact of S).2 is binary associative (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S)
    by A7,A4,FINSEQ_1:def 7;
    thus 3 in dom the charact of S by A3;
    dom <*i,w*> = Seg 2 by FINSEQ_3:29; then
    1 in dom <*i,w*> & 2 in dom <*i,w*>; then
A5: char.(2+1) = i & char.(2+2) = w by A6,A4,FINSEQ_1:def 7;
    hence (the charact of S).3 is ternary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S);
    thus 4 in dom the charact of S by A3;
    thus (the charact of S).4 is binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S) by A5;
    thus S is quasi_total
    proof
      let i be Nat, h be PartFunc of (the carrier of S)*, the carrier of S;
      assume i in dom the charact of S;

      hence thesis by A9,A5,A3,FINSEQ_3:2,ENUMSET1:def 2;
    end;
    let i be Nat, h be PartFunc of (the carrier of S)*, the carrier of S;
    assume
A8: i in dom the charact of S & h = (the charact of S).i;
    let p1,p2 be FinSequence;
    i = 1 or i = 2 or i = 3 or i = 4 by A3,A8,FINSEQ_3:2,ENUMSET1:def 2;
    hence thesis by A9,A5,A8,UNIALG_1:def 1;
  end;

registration
  cluster with_empty-instruction with_catenation with_if-instruction
  with_while-instruction unital associative
  (quasi_total partial non-empty strict UAStr);
  existence
  proof
    consider X being non empty set;
    consider c being binary associative unital
    (non empty quasi_total homogeneous PartFunc of X*, X);
    consider a being Element of X;
    consider x being set such that
A1: x is_a_unity_wrt c by UNITAL;
    arity c = 2 by COMPUT_1:def 26; then
A2: dom c = 2-tuples_on X by COMPUT_1:25; then
    <*a,a*> in dom c by CATALG_1:10; then
    <*a,x*> in dom c by A1,UNITY; then
    reconsider x as Element of X by A2,CATALG_1:11;
    consider i being ternary
    (non empty quasi_total homogeneous PartFunc of X*, X);
    consider w being binary
    (non empty quasi_total homogeneous PartFunc of X*, X);
    ex S being non-empty strict UAStr st
    the carrier of S = X &
    the charact of S = <*(0-tuples_on X)-->x,c*>^<*i,w*> &
    S is with_empty-instruction with_catenation unital associative
    with_if-instruction with_while-instruction quasi_total partial
    by A1,Th0;
    hence thesis;
  end;
end;

definition
  mode preIfWhileAlgebra is with_empty-instruction
  with_catenation with_if-instruction with_while-instruction
  Universal_Algebra;
end;

reserve A for preIfWhileAlgebra,
  C,I,J for Element of A;
reserve S for non empty set, T for Subset of S,
  s for Element of S;

definition
  let A be non empty UAStr;
  mode Algorithm of A is Element of A;
end;

theorem LemE:
  for A being with_empty-instruction (non-empty UAStr)
  holds dom Den(In(1, dom the charact of A), A) = {{}}
  proof
    let A be with_empty-instruction (non-empty UAStr);
    reconsider e = (the charact of A).1 as nullary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF0;
    consider a being Element of A;
    1 in dom the charact of A by DEF0; then
A2: Den(In(1, dom the charact of A), A) = e by FUNCT_7:def 1;
    arity e = 0 by COMPUT_1:def 24; then
    dom e = 0-tuples_on the carrier of A by COMPUT_1:25;
    hence dom Den(In(1, dom the charact of A), A) = {{}} by A2,COMPUT_1:8;
  end;

definition
  let A be with_empty-instruction (non-empty UAStr);
  func EmptyIns A -> Algorithm of A equals
  Den(In(1, dom the charact of A), A).{};
  coherence
  proof
    reconsider e = (the charact of A).1 as nullary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF0;
    consider a being Element of A;
    1 in dom the charact of A by DEF0; then
A2: Den(In(1, dom the charact of A), A) = e by FUNCT_7:def 1;
    dom e = {{}} by A2,LemE; then
    {} in dom e by TARSKI:def 1;
    hence thesis by A2,PARTFUN1:27;
   end;
end;

theorem
  for A being with_empty-instruction Universal_Algebra
  for o being Element of Operations A
  st o = Den(In(1, dom the charact of A), A)
  holds arity o = 0 & EmptyIns A in rng o
  proof
    let A be with_empty-instruction Universal_Algebra;
    let o be Element of Operations A such that
A1: o = Den(In(1, dom the charact of A), A);
A2: dom Den(In(1, dom the charact of A), A) = {{}} by LemE;
A3: <*>the carrier of A in {{}} by TARSKI:def 1;
    hence arity o = len (<*>the carrier of A) by A1,A2,UNIALG_1:def 10
    .= 0 by FINSEQ_1:25;
    thus thesis by A1,A2,A3,FUNCT_1:def 5;
  end;

theorem LemC:
  for A being with_catenation (non-empty UAStr)
  holds dom Den(In(2, dom the charact of A), A) = 2-tuples_on the carrier of A
  proof
    let A be with_catenation (non-empty UAStr);
    reconsider f = (the charact of A).2 as binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF1;
    2 in dom the charact of A by DEF1; then
A2: Den(In(2, dom the charact of A), A) = f by FUNCT_7:def 1;
    arity f = 2 by COMPUT_1:def 26;
    hence thesis by A2,COMPUT_1:25;
  end;

definition
  let A be with_catenation (non-empty UAStr);
  let I1,I2 be Algorithm of A;
  func I1 \; I2 -> Algorithm of A equals
  Den(In(2, dom the charact of A), A).<*I1,I2*>;
  coherence
  proof
    reconsider f = (the charact of A).2 as binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF1;
    2 in dom the charact of A by DEF1; then
A2: Den(In(2, dom the charact of A), A) = f by FUNCT_7:def 1;
    dom f = 2-tuples_on the carrier of A by A2,LemC; then
    <*I1,I2*> in dom f by CATALG_1:10;
    hence thesis by A2,PARTFUN1:27;
  end;
end;

theorem
  for A being with_empty-instruction with_catenation unital (non-empty UAStr)
  for I being Element of A holds
  EmptyIns A\;I = I & I\;EmptyIns A = I
  proof
    let A be with_empty-instruction with_catenation unital (non-empty UAStr);
    let I be Element of A;
    consider f being binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) such that
A1: f = (the charact of A).2 and
A2: Den(In(1, dom the charact of A), A).({}) is_a_unity_wrt f by DEF5;
    2 in dom the charact of A & arity f = 2
    by DEF1,COMPUT_1:def 26; then
    dom f = 2-tuples_on the carrier of A & In(2, dom the charact of A) = 2
    by COMPUT_1:25,FUNCT_7:def 1; then
    EmptyIns A\;I = f.(<*EmptyIns A, I*>) & <*I,I*> in dom f &
    I\;EmptyIns A = f.(<*I, EmptyIns A*>)
    by A1,CATALG_1:10;
    hence thesis by A2,UNITY;
  end;

theorem
  for A being associative with_catenation (non-empty UAStr)
  for I1,I2,I3 being Element of A holds
  (I1\;I2)\;I3 = I1\;(I2\;I3)
  proof
    let A be associative with_catenation (non-empty UAStr);
    let I1,I2,I3 be Element of A;
    reconsider f = (the charact of A).2 as
    binary associative (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF4;
    2 in dom the charact of A & arity f = 2 by DEF1,COMPUT_1:def 26; then
    dom f = 2-tuples_on the carrier of A & In(2, dom the charact of A) = 2
    by COMPUT_1:25,FUNCT_7:def 1; then
    I1\;I2 = f.(<*I1,I2*>) & I2\;I3 = f.(<*I2,I3*>) &
    (I1\;I2)\;I3 = f.(<*I1\;I2,I3*>) & I1\;(I2\;I3) = f.(<*I1,I2\;I3*>) &
    <*I1,I2*> in dom f & <*I2,I3*> in dom f & <*I1,I2\;I3*> in dom f &
    <*I1\;I2,I3*> in dom f by CATALG_1:10;
    hence(I1\;I2)\;I3 = I1\;(I2\;I3) by ASSOC;
  end;

theorem LemI:
  for A being with_if-instruction (non-empty UAStr)
  holds dom Den(In(3, dom the charact of A), A) = 3-tuples_on the carrier of A
  proof
    let A be with_if-instruction (non-empty UAStr);
    reconsider f = (the charact of A).3 as ternary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF2;
    3 in dom the charact of A & 3 in Seg 3 by DEF2; then
A1: Den(In(3, dom the charact of A), A) = f by FUNCT_7:def 1;
    arity f = 3 by COMPUT_1:def 27;
    hence thesis by A1,COMPUT_1:25;
  end;

definition
  let A be with_if-instruction (non-empty UAStr);
  let C,I1,I2 be Algorithm of A;
  func if-then-else(C,I1,I2) -> Algorithm of A equals
  Den(In(3, dom the charact of A), A).<*C,I1,I2*>;
  coherence
  proof
    reconsider f = (the charact of A).3 as ternary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF2;
    3 in dom the charact of A & 3 in Seg 3 by DEF2; then
A1: Den(In(3, dom the charact of A), A) = f by FUNCT_7:def 1;
    arity f = 3 by COMPUT_1:def 27; then
    dom f = 3-tuples_on the carrier of A by COMPUT_1:25; then
    <*C,I1,I2*> in dom f by CATALG_1:12;
    hence thesis by A1,PARTFUN1:27;
  end;
end;

definition
  let A be with_empty-instruction with_if-instruction (non-empty UAStr);
  let C,I be Algorithm of A;
  func if-then(C,I) -> Algorithm of A equals
  if-then-else(C,I,EmptyIns A);
  coherence;
end;

theorem LemW:
  for A being with_while-instruction (non-empty UAStr)
  holds dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A
  proof
    let A be with_while-instruction (non-empty UAStr);
    reconsider f = (the charact of A).4 as binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF3;
    4 in dom the charact of A by DEF3; then
A2: Den(In(4, dom the charact of A), A) = f by FUNCT_7:def 1;
    arity f = 2 by COMPUT_1:def 26;
    hence thesis by A2,COMPUT_1:25;
  end;

definition
  let A be with_while-instruction (non-empty UAStr);
  let C,I be Algorithm of A;
  func while(C,I) -> Algorithm of A equals
  Den(In(4, dom the charact of A), A).<*C,I*>;
  coherence
  proof
    reconsider f = (the charact of A).4 as binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF3;
    4 in dom the charact of A by DEF3; then
A1: Den(In(4, dom the charact of A), A) = f by FUNCT_7:def 1;
    arity f = 2 by COMPUT_1:def 26; then
    dom f = 2-tuples_on the carrier of A by COMPUT_1:25; then
    <*C,I*> in dom f by CATALG_1:10;
    hence thesis by A1,PARTFUN1:27;
  end;
end;

definition
  let A be preIfWhileAlgebra;
  let I0,C,I,J be Element of A;
  func for-do(I0,C,J,I) -> Element of A equals
  I0\;while(C,I\;J);
  coherence;
end;

definition
  let A be preIfWhileAlgebra;
  func ElementaryInstructions A -> Subset of A equals
  (the carrier of A)
  \ {EmptyIns A}
  \ rng Den(In(3, dom the charact of A), A)
  \ rng Den(In(4, dom the charact of A), A)
  \ {I1 \; I2 where I1,I2 is Algorithm of A: I1 <> I1\;I2 & I2 <> I1\;I2};
  coherence;
end;

theorem Th0A:
  for A being preIfWhileAlgebra holds EmptyIns A nin ElementaryInstructions A
  proof
    let A be preIfWhileAlgebra;
    set I = EmptyIns A;
    I in {I} by TARSKI:def 1; then
    I nin (the carrier of A)\{I} by XBOOLE_0:def 4; then
    I nin (the carrier of A) \ {EmptyIns A}
    \ rng Den(In(3, dom the charact of A), A) by XBOOLE_0:def 4; then
    I nin (the carrier of A) \ {EmptyIns A}
    \ rng Den(In(3, dom the charact of A), A)
    \ rng Den(In(4, dom the charact of A), A) by XBOOLE_0:def 4;
    hence I nin ElementaryInstructions A by XBOOLE_0:def 4;
  end;

theorem Th0B:
  for A being preIfWhileAlgebra 
  for I1,I2 being Element of A st I1 <> I1\;I2 & I2 <> I1\;I2
   holds I1\;I2 nin ElementaryInstructions A
  proof
    let A be preIfWhileAlgebra;
    let I1,I2 be Element of A;
    assume I1 <> I1\;I2 & I2 <> I1\;I2; then
    I1\;I2 in {J1 \; J2 where J1,J2 is Algorithm of A:
    J1 <> J1\;J2 & J2 <> J1\;J2};
    hence I1\;I2 nin ElementaryInstructions A by XBOOLE_0:def 4;
  end;

theorem Th0C:
  for A being preIfWhileAlgebra 
  for C,I1,I2 being Element of A
  holds if-then-else(C,I1,I2) nin ElementaryInstructions A
  proof
    let A be preIfWhileAlgebra;
    let C,I1,I2 be Element of A;
    set I = if-then-else(C,I1,I2);
    reconsider f = (the charact of A).3 as ternary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF2;
    3 in dom the charact of A by DEF2; then
    In(3, dom the charact of A) = 3 by FUNCT_7:def 1; then
    dom Den(In(3, dom the charact of A), A)
    = (arity f)-tuples_on the carrier of A by COMPUT_1:25
    .= 3-tuples_on the carrier of A by COMPUT_1:def 27; then
    <*C,I1,I2*> in dom Den(In(3, dom the charact of A), A) by CATALG_1:12; then
    I in rng Den(In(3, dom the charact of A), A) by FUNCT_1:def 5; then
    I nin (the carrier of A) \ {EmptyIns A}
    \ rng Den(In(3, dom the charact of A), A) by XBOOLE_0:def 4; then
    I nin (the carrier of A) \ {EmptyIns A}
    \ rng Den(In(3, dom the charact of A), A)
    \ rng Den(In(4, dom the charact of A), A) by XBOOLE_0:def 4;
    hence if-then-else(C,I1,I2) nin ElementaryInstructions A by XBOOLE_0:def 4;
  end;

theorem Th0D:
  for A being preIfWhileAlgebra 
  for C,I being Element of A
  holds while(C,I) nin ElementaryInstructions A
  proof
    let A be preIfWhileAlgebra;
    let C,I1 be Element of A;
    set I = while(C,I1);
    reconsider f = (the charact of A).4 as binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF3;
    4 in dom the charact of A by DEF3; then
    In(4, dom the charact of A) = 4 by FUNCT_7:def 1; then
    dom Den(In(4, dom the charact of A), A)
    = (arity f)-tuples_on the carrier of A by COMPUT_1:25
    .= 2-tuples_on the carrier of A by COMPUT_1:def 26; then
    <*C,I1*> in dom Den(In(4, dom the charact of A), A) by CATALG_1:10; then
    I in rng Den(In(4, dom the charact of A), A) by FUNCT_1:def 5; then
    I nin (the carrier of A) \ {EmptyIns A}
    \ rng Den(In(3, dom the charact of A), A)
    \ rng Den(In(4, dom the charact of A), A) by XBOOLE_0:def 4;
    hence I nin ElementaryInstructions A by XBOOLE_0:def 4;
  end;

theorem Th26:
  for A being preIfWhileAlgebra
  for I being Element of A
  st I nin ElementaryInstructions A
  holds I = EmptyIns A or
  (ex I1,I2 being Element of A st I = I1\;I2 & I1 <> I1\;I2 & I2 <> I1\;I2) or
  (ex C,I1,I2 being Element of A st I = if-then-else(C,I1,I2)) or
  (ex C,J being Element of A st I = while(C,J))
  proof
    let A be preIfWhileAlgebra;
    let I be Element of A such that
00: I nin ElementaryInstructions A and
01: I <> EmptyIns A and
02: for I1,I2 being Element of A st I = I1\;I2 & I1 <> I1\;I2 holds
    I2 = I1\;I2 and
03: for C,I1,I2 being Element of A holds I <> if-then-else(C,I1,I2) and
04: for C,J being Element of A holds I <> while(C,J);
05: now assume I in rng Den(In(3, dom the charact of A), A); then
      consider x being set such that
A1:   x in dom Den(In(3, dom the charact of A), A) &
      I = Den(In(3, dom the charact of A), A).x by FUNCT_1:def 5;
      reconsider f = (the charact of A).3 as ternary (non empty homogeneous
      quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF2;
      3 in dom the charact of A by DEF2; then
      In(3, dom the charact of A) = 3 by FUNCT_7:def 1; then
      dom Den(In(3, dom the charact of A), A)
      = (arity f)-tuples_on the carrier of A by COMPUT_1:25
      .= 3-tuples_on the carrier of A by COMPUT_1:def 27; then
      consider C,I1,I2 be set such that
A2:   C in the carrier of A & I1 in the carrier of A & I2 in the carrier of A &
      x = <*C,I1,I2*> by A1,CATALG_1:12;
      reconsider C,I1,I2 as Element of A by A2;
      I = if-then-else(C,I1,I2) by A1,A2;
      hence contradiction by 03;
    end;
06: now assume I in rng Den(In(4, dom the charact of A), A); then
      consider x being set such that
A1:   x in dom Den(In(4, dom the charact of A), A) &
      I = Den(In(4, dom the charact of A), A).x by FUNCT_1:def 5;
      reconsider f = (the charact of A).4 as binary (non empty homogeneous
      quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF3;
      4 in dom the charact of A by DEF3; then
      In(4, dom the charact of A) = 4 by FUNCT_7:def 1; then
      dom Den(In(4, dom the charact of A), A)
      = (arity f)-tuples_on the carrier of A by COMPUT_1:25
      .= 2-tuples_on the carrier of A by COMPUT_1:def 26; then
      consider C,J be set such that
A2:   C in the carrier of A & J in the carrier of A &
      x = <*C,J*> by A1,CATALG_1:10;
      reconsider C,J as Element of A by A2;
      I = while(C,J) by A1,A2;
      hence contradiction by 04;
    end;
07: I nin {I1\;I2 where I1,I2 is Algorithm of A: I1 <> I1\;I2 & I2 <> I1\;I2}
    by 02;
    I in (the carrier of A)
    \ {EmptyIns A} by 01,ZFMISC_1:64; then
    I in (the carrier of A)
    \ {EmptyIns A}
    \ rng Den(In(3, dom the charact of A), A) by 05,XBOOLE_0:def 4; then
    I in (the carrier of A)
    \ {EmptyIns A}
    \ rng Den(In(3, dom the charact of A), A)
    \ rng Den(In(4, dom the charact of A), A) by 06,XBOOLE_0:def 4;
    hence contradiction by 00,07,XBOOLE_0:def 4;
  end;

definition
  let A be preIfWhileAlgebra;
  attr A is infinite means:
INFINITE:
  ElementaryInstructions A is infinite;
  attr A is degenerated means:
DEG:
  (ex I1,I2 being Element of A st
  I1 <> EmptyIns A & I1\;I2 = I2 or I2 <> EmptyIns A & I1\;I2 = I1 or
  (I1 <> EmptyIns A or I2 <> EmptyIns A) & I1\;I2 = EmptyIns A) or
  (ex C,I1,I2 being Element of A st if-then-else(C,I1,I2) = EmptyIns A) or
  (ex C,I being Element of A st while(C,I) = EmptyIns A) or
  (ex I1,I2,C,J1,J2 being Element of A st I1 <> EmptyIns A & I2 <> EmptyIns A &
  I1\;I2 = if-then-else(C,J1,J2)) or
  (ex I1,I2,C,J being Element of A st I1 <> EmptyIns A & I2 <> EmptyIns A &
  I1\;I2 = while(C,J)) or
  (ex C1,I1,I2,C2,J being Element of A st
  if-then-else(C1,I1,I2) = while(C2,J));
  attr A is well_founded means:
WELLFOUND:
  ElementaryInstructions A is GeneratorSet of A;
end;

definition
  func ECIW-signature -> non empty FinSequence of NAT equals
  <*0, 2*>^<*3, 2*>;
  coherence
  proof
    reconsider 02 = <*0,2*> as non empty FinSequence;
    02^<*3,2*> is non empty;
    hence thesis;
  end;
end;

theorem ECIW:
  len ECIW-signature = 4 & dom ECIW-signature = Seg 4 &
  ECIW-signature.1 = 0 & ECIW-signature.2 = 2 &
  ECIW-signature.3 = 3 & ECIW-signature.4 = 2
  proof set S = ECIW-signature;
A0: len <*0,2*> = 2 & len <*3,2*> = 2 by FINSEQ_1:61; then
A1: len S = 2+2 & dom <*0,2*> = Seg 2 & dom <*3,2*> = Seg 2
    by FINSEQ_1:def 3,35;
A6: 1 in dom <*3,2*> & <*3,2*>.1 = 3 & 2 in dom <*3,2*> & <*3,2*>.2 = 2 &
    2+1 = 3 & 2+2 = 4 by A1,FINSEQ_1:61;
    1 in dom <*0,2*> & <*0,2*>.1 = 0 & 2 in dom <*0,2*> & <*0,2*>.2 = 2
      by A1,FINSEQ_1:61;
    hence thesis by A0,FINSEQ_1:35,A6,FINSEQ_1:def 7;
  end;

definition
  let A be partial non-empty non empty UAStr;
  attr A is ECIW-strict means:
DefECIW:
   signature A = ECIW-signature;
end;

theorem ThECIW:
  for A being partial non-empty non empty UAStr st A is ECIW-strict
  for o being OperSymbol of A
  holds o = 1 or o = 2 or o = 3 or o = 4
  proof
    let A be partial non-empty non empty UAStr;
    assume signature A = ECIW-signature; then
    4 = len the charact of A by ECIW,UNIALG_1:def 11; then
    dom the charact of A = Seg 4 by FINSEQ_1:def 3;
    hence thesis by ENUMSET1:def 2,FINSEQ_3:2;
  end;

registration
  let X be disjoint_with_NAT non empty set;
  cluster FreeUnivAlgNSG(ECIW-signature,X) -> with_empty-instruction
  with_catenation with_if-instruction with_while-instruction;
  coherence
  proof set S = FreeUnivAlgNSG(ECIW-signature,X);
    set char = ECIW-signature;
A0: len <*0,2*> = 2 & len <*3,2*> = 2 by FINSEQ_1:61; then
A1: len char = 2+2 & len the charact of S = len char & dom <*0,2*> = Seg 2 &
    dom <*3,2*> = Seg 2 by FINSEQ_1:def 3,35,FREEALG:def 12; then
A2: dom the charact of S = Seg 4 & dom char = Seg 4 by FINSEQ_1:def 3;
    hence 1 in dom the charact of S; then
A3: (the charact of S).1 = FreeOpNSG(1,char,X) by FREEALG:def 12;
A4: 1 in dom char & 2 in dom char & 3 in dom char & 4 in dom char by A2;
    reconsider D = TS(DTConUA(char,X)) as non empty set;
    reconsider char as non empty FinSequence of omega;
    set o = FreeOpNSG(1,char,X);
A6: 1 in dom <*0,2*> & <*0,2*>.1 = 0 & 2 in dom <*0,2*> & <*0,2*>.2 = 2
    by A1,FINSEQ_1:61; then
    char.1 = 0 by FINSEQ_1:def 7; then
    char/.1 = 0 & the carrier of S = D by A4,FINSEQ_4:def 4; then
A5: dom o = 0-tuples_on the carrier of S by A4,FREEALG:def 11;
    reconsider o as homogeneous non empty quasi_total PartFunc of D*, D;
    arity o = 0 by A5,COMPUT_1:28;
    hence (the charact of S).1 is nullary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S)
    by A3,COMPUT_1:def 24;
    thus 2 in dom the charact of S by A2; then
A3: (the charact of S).2 = FreeOpNSG(2,char,X) by FREEALG:def 12;
    set o = FreeOpNSG(2,char,X);
    char.2 = 2 by A6,FINSEQ_1:def 7; then
    (char qua FinSequence of omega)/.2 = 2 by A4,FINSEQ_4:def 4; then
A5: dom o = 2-tuples_on the carrier of S by A4,FREEALG:def 11;
    reconsider o as homogeneous non empty quasi_total PartFunc of D*, D;
    arity o = 2 by A5,COMPUT_1:28;
    hence (the charact of S).2 is binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S)
    by A3,COMPUT_1:def 26;
    thus 3 in dom the charact of S by A2; then
A3: (the charact of S).3 = FreeOpNSG(3,char,X) by FREEALG:def 12;
    set o = FreeOpNSG(3,char,X);
A6: 1 in dom <*3,2*> & <*3,2*>.1 = 3 & 2 in dom <*3,2*> & <*3,2*>.2 = 2
    by A1,FINSEQ_1:61; then
    char.(2+1) = 3 by A0,FINSEQ_1:def 7; then
    (char qua FinSequence of omega)/.3 = 3
    by A4,FINSEQ_4:def 4; then
A5: dom o = 3-tuples_on the carrier of S by A4,FREEALG:def 11;
    reconsider o as homogeneous non empty quasi_total PartFunc of D*, D;
    arity o = 3 by A5,COMPUT_1:28;
    hence (the charact of S).3 is ternary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S)
    by A3,COMPUT_1:def 27;
    thus 4 in dom the charact of S by A2; then
A3: (the charact of S).4 = FreeOpNSG(4,char,X) by FREEALG:def 12;
    set o = FreeOpNSG(4,char,X);
    char.(2+2) = 2 by A0,A6,FINSEQ_1:def 7; then
    (char qua FinSequence of omega)/.4 = 2 by A4,FINSEQ_4:def 4; then
A5: dom o = 2-tuples_on the carrier of S by A4,FREEALG:def 11;
    reconsider o as homogeneous non empty quasi_total PartFunc of D*, D;
    arity o = 2 by A5,COMPUT_1:28;
    hence (the charact of S).4 is binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of S)*, the carrier of S)
    by A3,COMPUT_1:def 26;
  end;
end;

theorem Th20:
  for X being disjoint_with_NAT non empty set
  for I being Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds
    (ex x being Element of X st I = root-tree x) or
    (ex n being Nat, p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X)
     st n in Seg 4 & I = n-tree p & len p = ECIW-signature.n)
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    let I be Element of FreeUnivAlgNSG(S,X) such that
A1: not ex x being Element of X st I = root-tree x;
    Terminals DTConUA(S,X) = X by FREEALG:3; then
    not ex d being Symbol of G st d in Terminals G & I = root-tree d
    by A1; then
    consider o being Symbol of G, p being FinSequence of TS G such that
A2: o ==> roots p & I = o-tree p by Th19;
A7: NonTerminals G = {s where s is Symbol of G:
    ex n being FinSequence st s ==> n} by LANG1:def 3; then
A3: o in NonTerminals G by A2;
A4: NonTerminals G = Seg 4 by ECIW,FREEALG:2; then
    reconsider n = o as Element of NAT by A3;
    reconsider p as FinSequence of FreeUnivAlgNSG(ECIW-signature,X);
    take n, p;
    thus n in Seg 4 by A2,A7,A4;
    thus I = n-tree p by A2;
A5: [n, roots p] in the Rules of G by A2,LANG1:def 1; then
A6: roots p in (the carrier of G)* by ZFMISC_1:106;
    dom p = dom roots p by TREES_3:def 18;
    hence len p = Card dom roots p by PRE_CIRC:21
       .= len roots p by PRE_CIRC:21
       .= S.n by A5,A6,FREEALG:def 8;
  end;

theorem Th21:
  for X being disjoint_with_NAT non empty set
  holds EmptyIns FreeUnivAlgNSG(ECIW-signature,X) = 1-tree {}
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    reconsider s = S as non empty FinSequence of omega;
    set A = FreeUnivAlgNSG(S,X);
A0: 1 in dom the charact of A by DEF0;
    reconsider f = (the charact of A).1 as nullary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF0;
A1: f = FreeOpNSG(1,S,X) by A0,FREEALG:def 12;
A5: 1 in dom S by ECIW; then
A2: s/.1 = S.1 by FINSEQ_4:def 4;
A3: dom FreeOpNSG(1,S,X) = (s/.1)-tuples_on TS(DTConUA(S,X))
    by A5,FREEALG:def 11
    .= {{}} by A2,ECIW,COMPUT_1:8;
A4: {} in {{}} & {} = <*> TS(DTConUA(S,X)) by TARSKI:def 1;
    thus EmptyIns A = f.{} by A0,FUNCT_7:def 1
    .= Sym(1,S,X)-tree({}) by A1,A3,A4,A5,FREEALG:def 11
    .= 1-tree {} by A5,FREEALG:def 10;
  end;

theorem Th21':
  for X being disjoint_with_NAT non empty set
  for p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X)
  st 1-tree p is Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds p = {}
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let p be FinSequence of A; assume
    1-tree p is Element of A; then
    reconsider I = 1-tree p as Element of A;
    per cases by Th20;
    suppose ex x being Element of X st I = root-tree x; then
      consider x being Element of X such that
A1:   1-tree p = root-tree x;
      1-tree p = x-tree(<*>TS G) by A1,TREES_4:20;
      hence thesis by TREES_4:15;
    end;
    suppose
      ex n being Nat, p being FinSequence of A
      st n in Seg 4 & I = n-tree p & len p = S.n; then
      consider n being Nat, q being FinSequence of A such that
A2:   n in Seg 4 & I = n-tree q & len q = S.n;
      n = 1 & q = p by A2,TREES_4:15;
      hence p = {} by A2,ECIW,FINSEQ_1:25;
    end;
  end;

theorem Th22:
  for X being disjoint_with_NAT non empty set
  for I1,I2 being Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds I1\;I2 = 2-tree(I1,I2)
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    reconsider s = S as non empty FinSequence of omega;
    set A = FreeUnivAlgNSG(S,X);
    let I1,I2 be Element of A;
A0: 2 in dom the charact of A by DEF1;
    reconsider f = (the charact of A).2 as binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF1;
A1: f = FreeOpNSG(2,S,X) by A0,FREEALG:def 12;
A5: 2 in dom S by ECIW; then
A2: s/.2 = S.2 by FINSEQ_4:def 4;
A3: dom FreeOpNSG(2,S,X) = 2-tuples_on TS(DTConUA(S,X))
    by A2,A5,ECIW,FREEALG:def 11;
A4: <*I1,I2*> in 2-tuples_on TS(DTConUA(S,X)) by CATALG_1:10;
    thus I1\;I2 = f.<*I1,I2*> by A0,FUNCT_7:def 1
    .= Sym(2,S,X)-tree(<*I1,I2*>) by A1,A3,A4,A5,FREEALG:def 11
    .= 2-tree (I1,I2) by A5,FREEALG:def 10;
  end;

theorem Th22':
  for X being disjoint_with_NAT non empty set
  for p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X)
  st 2-tree p is Element of FreeUnivAlgNSG(ECIW-signature,X)
  ex I1,I2 being Element of FreeUnivAlgNSG(ECIW-signature,X)
  st p = <*I1,I2*>
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let p be FinSequence of A; assume
    2-tree p is Element of A; then
    reconsider I = 2-tree p as Element of A;
    per cases by Th20;
    suppose ex x being Element of X st I = root-tree x; then
      consider x being Element of X such that
A1:   2-tree p = root-tree x;
      2-tree p = x-tree(<*>TS G) by A1,TREES_4:20; then
      2 = x by TREES_4:15; then
      X meets NAT by XBOOLE_0:3;
      hence thesis by FREEALG:def 1;
    end;
    suppose
      ex n being Nat, p being FinSequence of A
      st n in Seg 4 & I = n-tree p & len p = S.n; then
      consider n being Nat, q being FinSequence of A such that
A2:   n in Seg 4 & I = n-tree q & len q = S.n;
a3:   n = 2 & q = p by A2,TREES_4:15; then
      p = <*p.1,p.2*> by A2,ECIW,FINSEQ_1:61; then
      rng p = {p.1,p.2} by FINSEQ_2:147; then
      reconsider I1 = p.1, I2 = p.2 as Element of A by ZFMISC_1:38;
      take I1,I2; thus thesis by a3,A2,ECIW,FINSEQ_1:61;
    end;
  end;

theorem Th22A:
  for X being disjoint_with_NAT non empty set
  for I1,I2 being Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds I1\;I2 <> I1 & I1\;I2 <> I2
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let I1,I2 be Element of A;
    set p = <*I1,I2*>;
    rng p c= FinTrees the carrier of G by XBOOLE_1:1; then
A1: p is FinSequence of FinTrees the carrier of G by FINSEQ_1:def 4;
    rng p = {I1,I2} by FINSEQ_2:147; then
A2: I1 in rng p & I2 in rng p by TARSKI:def 2;
    I1\;I2 = 2-tree(I1,I2) by Th22 .= 2-tree<*I1,I2*>;
    hence thesis by A1,A2,Th17;
  end;

theorem
  for X being disjoint_with_NAT non empty set
  for I1,I2,J1,J2 being Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds I1\;I2 = J1\;J2 implies I1 = J1 & I2 = J2
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let I1,I2,J1,J2 be Element of A;
    I1\;I2 = 2-tree(I1,I2) & J1\;J2 = 2-tree(J1,J2) by Th22; then
    I1\;I2 = J1\;J2 implies <*I1,I2*> = <*J1,J2*> by TREES_4:15;
    hence thesis by GROUP_7:2;
  end;

theorem Th23:
  for X being disjoint_with_NAT non empty set
  for C,I1,I2 being Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds if-then-else(C,I1,I2) = 3-tree<*C,I1,I2*>
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    reconsider s = S as non empty FinSequence of omega;
    set A = FreeUnivAlgNSG(S,X);
    let C,I1,I2 be Element of A;
A0: 3 in dom the charact of A by DEF2;
    reconsider f = (the charact of A).3 as ternary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF2;
A1: f = FreeOpNSG(3,S,X) by A0,FREEALG:def 12;
A5: 3 in dom S by ECIW; then
A2: s/.3 = S.3 by FINSEQ_4:def 4;
A3: dom FreeOpNSG(3,S,X) = 3-tuples_on TS(DTConUA(S,X))
    by A2,A5,ECIW,FREEALG:def 11;
A4: <*C,I1,I2*> in 3-tuples_on TS(DTConUA(S,X)) by CATALG_1:12;
    thus if-then-else(C,I1,I2)
     = f.<*C,I1,I2*> by A0,FUNCT_7:def 1
    .= Sym(3,S,X)-tree(<*C,I1,I2*>) by A1,A3,A4,A5,FREEALG:def 11
    .= 3-tree <*C,I1,I2*> by A5,FREEALG:def 10;
  end;

theorem Th23':
  for X being disjoint_with_NAT non empty set
  for p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X)
  st 3-tree p is Element of FreeUnivAlgNSG(ECIW-signature,X)
  ex C,I1,I2 being Element of FreeUnivAlgNSG(ECIW-signature,X)
  st p = <*C,I1,I2*>
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let p be FinSequence of A; assume
    3-tree p is Element of A; then
    reconsider I = 3-tree p as Element of A;
    per cases by Th20;
    suppose ex x being Element of X st I = root-tree x; then
      consider x being Element of X such that
A1:   3-tree p = root-tree x;
      3-tree p = x-tree(<*>TS G) by A1,TREES_4:20; then
      3 = x by TREES_4:15; then
      X meets NAT by XBOOLE_0:3;
      hence thesis by FREEALG:def 1;
    end;
    suppose
      ex n being Nat, p being FinSequence of A
      st n in Seg 4 & I = n-tree p & len p = S.n; then
      consider n being Nat, q being FinSequence of A such that
A2:   n in Seg 4 & I = n-tree q & len q = S.n;
a3:   n = 3 & q = p by A2,TREES_4:15; then
      p =<*p.1,p.2,p.3*> by A2,ECIW,FINSEQ_1:62; then
      rng p = {p.1,p.2,p.3} by FINSEQ_2:148; then
      p.1 in {p.1,p.2,p.3} & p.2 in {p.1,p.2,p.3} & p.3 in {p.1,p.2,p.3} &
      {p.1,p.2,p.3} c= the carrier of A by ENUMSET1:def 1; then
      reconsider C = p.1, I1 = p.2, I2 = p.3 as Element of A;
      take C,I1,I2; thus thesis by a3,A2,ECIW,FINSEQ_1:62;
    end;
  end;

theorem
  for X being disjoint_with_NAT non empty set
  for C1,C2,I1,I2,J1,J2 being Element of FreeUnivAlgNSG(ECIW-signature,X)
  st if-then-else(C1,I1,I2) = if-then-else(C2,J1,J2)
  holds C1 = C2 & I1 = J1 & I2 = J2
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let C1,C2,I1,I2,J1,J2 be Element of A;
    if-then-else(C1,I1,I2) = 3-tree<*C1,I1,I2*> &
    if-then-else(C2,J1,J2) = 3-tree<*C2,J1,J2*> by Th23; then
    if-then-else(C1,I1,I2) = if-then-else(C2,J1,J2)
    implies <*C1,I1,I2*> = <*C2,J1,J2*> by TREES_4:15;
    hence thesis by GROUP_7:3;
  end;

theorem Th24:
  for X being disjoint_with_NAT non empty set
  for C,I being Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds while(C,I) = 4-tree(C,I)
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    reconsider s = S as non empty FinSequence of omega;
    set A = FreeUnivAlgNSG(S,X);
    let C,I be Element of A;
A0: 4 in dom the charact of A by DEF3;
    reconsider f = (the charact of A).4 as binary (non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A) by DEF3;
A1: f = FreeOpNSG(4,S,X) by A0,FREEALG:def 12;
A5: 4 in dom S by ECIW; then
A2: s/.4 = S.4 by FINSEQ_4:def 4;
A3: dom FreeOpNSG(4,S,X) = 2-tuples_on TS(DTConUA(S,X))
    by A2,A5,ECIW,FREEALG:def 11;
A4: <*C,I*> in 2-tuples_on TS(DTConUA(S,X)) by CATALG_1:10;
    thus while(C,I)
     = f.<*C,I*> by A0,FUNCT_7:def 1
    .= Sym(4,S,X)-tree(<*C,I*>) by A1,A3,A4,A5,FREEALG:def 11
    .= 4-tree(C,I) by A5,FREEALG:def 10;
  end;

theorem Th24':
  for X being disjoint_with_NAT non empty set
  for p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X)
  st 4-tree p is Element of FreeUnivAlgNSG(ECIW-signature,X)
  ex C,I being Element of FreeUnivAlgNSG(ECIW-signature,X)
  st p = <*C,I*>
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S,X);
    let p be FinSequence of A; assume
    4-tree p is Element of A; then
    reconsider I = 4-tree p as Element of A;
    per cases by Th20;
    suppose ex x being Element of X st I = root-tree x; then
      consider x being Element of X such that
A1:   4-tree p = root-tree x;
      4-tree p = x-tree(<*>TS G) by A1,TREES_4:20; then
      4 = x by TREES_4:15; then
      X meets NAT by XBOOLE_0:3;
      hence thesis by FREEALG:def 1;
    end;
    suppose
      ex n being Nat, p being FinSequence of A
      st n in Seg 4 & I = n-tree p & len p = S.n; then
      consider n being Nat, q being FinSequence of A such that
A2:   n in Seg 4 & I = n-tree q & len q = S.n;
a3:   n = 4 & q = p by A2,TREES_4:15; then
      p = <*p.1,p.2*> by A2,ECIW,FINSEQ_1:61; then
      rng p = {p.1,p.2} by FINSEQ_2:147; then
      reconsider I1 = p.1, I2 = p.2 as Element of A by ZFMISC_1:38;
      take I1,I2; thus thesis by a3,A2,ECIW,FINSEQ_1:61;
    end;
  end;

theorem Th25:
  for X being disjoint_with_NAT non empty set
  for I being Element of FreeUnivAlgNSG(ECIW-signature,X)
  st I in ElementaryInstructions FreeUnivAlgNSG(ECIW-signature,X)
  ex x being Element of X st I = x-tree {}
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S, X);
    let I be Element of FreeUnivAlgNSG(ECIW-signature,X) such that
A0: I in ElementaryInstructions FreeUnivAlgNSG(ECIW-signature,X);
    per cases by Th20;
    suppose
      ex x being Element of X st I = root-tree x; then
      consider x being Element of X such that
A1:   I = root-tree x;
      root-tree x = x-tree {} by TREES_4:20;
      hence thesis by A1;
    end;
    suppose
      ex n being Nat, p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X)
      st n in Seg 4 & I = n-tree p & len p = S.n; then
      consider n being Nat,
      p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X) such that
A1:   n in Seg 4 & I = n-tree p & len p = S.n;
      per cases by A1,FINSEQ_3:2,ENUMSET1:def 2;
      suppose
A3:     n = 1; then
        p = {} by A1,Th21'; then
        I = EmptyIns A by A1,A3,Th21;
        hence thesis by A0,Th0A;
      end;
      suppose
A3:     n = 2; then
        consider I1,I2 being Element of A such that
A4:     p = <*I1,I2*> by A1,Th22';
A5:     I = n-tree(I1,I2) by A1,A4 .= I1\;I2 by A3,Th22; then
        I <> I1 & I <> I2 by Th22A;
        hence thesis by A0,A5,Th0B;
      end;
      suppose
A3:     n = 3; then
        consider C,I1,I2 being Element of A such that
A4:     p = <*C,I1,I2*> by A1,Th23';
        I = if-then-else(C,I1,I2) by A1,A3,A4,Th23;
        hence thesis by A0,Th0C;
      end;
      suppose
A3:     n = 4; then
        consider C,I' being Element of A such that
A4:     p = <*C,I'*> by A1,Th24';
        I = n-tree(C,I') by A1,A4 .= while(C,I') by A3,Th24;
        hence thesis by A0,Th0D;
      end;
    end;
  end;

theorem
  for X being disjoint_with_NAT non empty set
  for p being FinSequence of FreeUnivAlgNSG(ECIW-signature,X)
  for x being Element of X
  st x-tree p is Element of FreeUnivAlgNSG(ECIW-signature,X)
  holds p = {}
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
    set A = FreeUnivAlgNSG(S, X);
    let p be FinSequence of FreeUnivAlgNSG(ECIW-signature,X);
    let x be Element of X;
    assume x-tree p is Element of FreeUnivAlgNSG(ECIW-signature,X); then
    reconsider I = x-tree p as Element of A;
    now given n being Nat, p being FinSequence of A such that
A2:   n in Seg 4 & I = n-tree p & len p = ECIW-signature.n;
      x = n & X misses NAT & n in NAT by A2,TREES_4:15,FREEALG:def 1;
      hence contradiction by XBOOLE_0:3;
    end; then
    consider y being Element of X such that
A3: I = root-tree y by Th20;
    x-tree p = y-tree {} & {} is DTree-yielding by A3,TREES_4:20,TREES_3:23;
    hence p = {} by TREES_4:15;
  end;

theorem ThFree:
  for X being disjoint_with_NAT non empty set
  holds ElementaryInstructions FreeUnivAlgNSG(ECIW-signature,X) =
  FreeGenSetNSG(ECIW-signature,X) &
  Card X = Card FreeGenSetNSG(ECIW-signature,X)
  proof
    let X be disjoint_with_NAT non empty set;
    set S = ECIW-signature;
    set G = DTConUA(S,X);
A0: X = Terminals G by FREEALG:3;
    set A = FreeUnivAlgNSG(S, X);
    thus ElementaryInstructions A = FreeGenSetNSG(S, X)
    proof
      thus ElementaryInstructions A c= FreeGenSetNSG(S, X)
      proof
        let x be set;
        assume x in ElementaryInstructions A; then
        consider y being Element of X such that
A1:     x = y-tree {} by Th25;
        reconsider y as Symbol of G by XBOOLE_0:def 2;
        x = root-tree y  by A1,TREES_4:20;
        hence thesis by A0;
      end;
      let x be set; assume
AA:   x in FreeGenSetNSG(S,X); then
      reconsider I = x as Element of A;
      consider y being Symbol of G such that
A2:   x = root-tree y & y in Terminals G by AA;
A4:   x = y-tree {} & {} is DTree-yielding by A2,TREES_3:23,TREES_4:20;
      assume
AB:   x nin ElementaryInstructions A;
      per cases by AB,Th26;
      suppose I = EmptyIns A; then
        x = 1-tree {} by Th21; then
        y = 1 & X misses NAT by FREEALG:def 1,A4,TREES_4:15;
        hence thesis by A0,A2,XBOOLE_0:3;
      end;
      suppose ex I1,I2 being Element of A st
        I = I1\;I2 & I1 <> I1\;I2 & I2 <> I1\;I2; then
        consider I1,I2 be Element of A such that
A5:     I = I1\;I2;
        x = 2-tree(I1,I2) by A5,Th22 .= 2-tree<*I1,I2*>;
        hence thesis by A4,TREES_4:15;
      end;
      suppose ex C,I1,I2 being Element of A st I = if-then-else(C,I1,I2); then
        consider C,I1,I2 be Element of A such that
A5:     I = if-then-else(C,I1,I2);
        x = 3-tree<*C,I1,I2*> by A5,Th23;
        hence thesis by A4,TREES_4:15;
      end;
      suppose ex C,J being Element of A st I = while(C,J); then
        consider C,J be Element of A such that
A5:     I = while(C,J);
        x = 4-tree(C,J) by A5,Th24 .= 4-tree<*C,J*>;
        hence thesis by A4,TREES_4:15;
      end;
    end;
    deffunc F(set) = root-tree $1;
    consider f being Function such that
A1: dom f = X & for x being Element of X holds f.x = F(x) from FUNCT_1:sch 4;
A2: rng f = FreeGenSetNSG(S,X)
    proof
      thus rng f c= FreeGenSetNSG(S,X)
      proof let a be set;
        assume a in rng f; then
        consider x being set such that
D1:     x in X & a = f.x by A1,FUNCT_1:def 5;
        reconsider s = x as Symbol of G by D1,XBOOLE_0:def 2;
        s in X & a = F(x) by A1,D1;
        hence thesis by A0;
      end;
      let a be set; assume a in FreeGenSetNSG(S,X); then
      consider s being Symbol of G such that
B1:   a = root-tree s & s in X by A0;
      reconsider s as Element of X by B1;
      f.s = a by A1,B1;
      hence thesis by A1,FUNCT_1:def 5;
    end;
    f is one-to-one
    proof
      let a,b be set;
      assume a in dom f & b in dom f; then
      reconsider x = a, y = b as Element of X by A1;
      assume f.a = f.b; then
      F(x) = f.b by A1 .= F(y) by A1;
      hence thesis by TREES_4:4;
    end; then
    X, FreeGenSetNSG(S,X) are_equipotent by A1,A2,WELLORD2:def 4;
    hence Card X = Card FreeGenSetNSG(S,X) by CARD_1:21;
  end;

registration
  cluster infinite disjoint_with_NAT set;
  existence
  proof take X = [:NAT,{0}:];
    Card X = Card NAT by CARD_2:13; then
    Card X nin NAT by CARD_1:84;
    hence X is infinite by CARD_4:3;
    now let x be set; assume x in X; then
      consider a,b being set such that
A1:   a in NAT & b in {0} & x = [a,b] by ZFMISC_1:def 2;
      assume x in NAT; then
      x is Element of NAT & [a,b] is pair;
      hence contradiction by A1;
    end;
    hence X misses NAT by XBOOLE_0:3;
  end;
end;

registration
  let X be infinite disjoint_with_NAT set;
  cluster FreeUnivAlgNSG(ECIW-signature,X) -> infinite;
  coherence
  proof
    ElementaryInstructions FreeUnivAlgNSG(ECIW-signature,X) =
    FreeGenSetNSG(ECIW-signature,X) &
    Card X = Card FreeGenSetNSG(ECIW-signature,X) by ThFree; then
    Card ElementaryInstructions FreeUnivAlgNSG(ECIW-signature,X) is infinite
    by CARD_4:1;
    hence ElementaryInstructions FreeUnivAlgNSG(ECIW-signature,X) is infinite
    by CARD_4:1;
  end;
end;

registration
  let X be disjoint_with_NAT non empty set;
  cluster FreeUnivAlgNSG(ECIW-signature,X) -> ECIW-strict;
  coherence
  proof
    thus signature FreeUnivAlgNSG(ECIW-signature,X) = ECIW-signature
    by FREEALG:4;
  end;
end;

theorem LemG3:
  for A being preIfWhileAlgebra
  holds Generators A c= ElementaryInstructions A
  proof
    let A be preIfWhileAlgebra;
    let x be set; assume
01: x in Generators A & x nin ElementaryInstructions A; then
    reconsider x as Element of A;
    dom Den(In(1, dom the charact of A), A) = {{}} by LemE; then
A1: {} in dom Den(In(1, dom the charact of A),A) by TARSKI:def 1;
    per cases by 01,Th26;
    suppose x = EmptyIns A; then
      x in rng Den(In(1, dom the charact of A), A) by A1,FUNCT_1:12;
      hence contradiction by 01,LemG;
    end;
    suppose
      ex I1,I2 being Element of A st x = I1\;I2 & I1 <> I1\;I2 & I2 <> I1\;I2;
      then consider I1,I2 being Element of A such that
B2:   x = I1\;I2 & I1 <> I1\;I2 & I2 <> I1\;I2;
      dom Den(In(2, dom the charact of A), A) = 2-tuples_on the carrier of A
      by LemC; then
      <*I1,I2*> in dom Den(In(2, dom the charact of A),A) by CATALG_1:10; then
      x in rng Den(In(2, dom the charact of A),A) by B2,FUNCT_1:12;
      hence contradiction by 01,LemG;
    end;
    suppose
      ex C,I1,I2 being Element of A st x = if-then-else(C,I1,I2); then
      consider C,I1,I2 being Element of A such that
B3:   x = if-then-else(C,I1,I2);
      dom Den(In(3, dom the charact of A), A) = 3-tuples_on the carrier of A
      by LemI; then
      <*C,I1,I2*> in dom Den(In(3, dom the charact of A),A)
      by CATALG_1:12; then
      x in rng Den(In(3, dom the charact of A),A) by B3,FUNCT_1:12;
      hence contradiction by 01,LemG;
    end;
    suppose
      ex C,J being Element of A st x = while(C,J); then
      consider C,J being Element of A such that
B4:   x = while(C,J);
      dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A
      by LemW; then
      <*C,J*> in dom Den(In(4, dom the charact of A),A) by CATALG_1:10; then
      x in rng Den(In(4, dom the charact of A),A) by B4,FUNCT_1:12;
      hence contradiction by 01,LemG;
    end;
  end;

theorem ThFE:
  for A being preIfWhileAlgebra st A is free
  for C,I1,I2 being Element of A
  holds EmptyIns A <> I1\;I2 & EmptyIns A <> if-then-else(C,I1,I2) &
  EmptyIns A <> while(C,I1)
  proof
    let A be preIfWhileAlgebra such that
A0: A is free;
    let C,I1,I2 be Element of A;
    1 in dom the charact of A by DEF0; then
A1: dom Den(In(1, dom the charact of A), A) = {{}} &
    In(1, dom the charact of A) = 1 by LemE,FUNCT_7:def 1;
    2 in dom the charact of A by DEF1; then
A2: dom Den(In(2, dom the charact of A), A) = 2-tuples_on the carrier of A &
    In(2, dom the charact of A) = 2 by LemC,FUNCT_7:def 1;
    3 in dom the charact of A by DEF2; then
A3: dom Den(In(3, dom the charact of A), A) = 3-tuples_on the carrier of A &
    In(3, dom the charact of A) = 3 by LemI,FUNCT_7:def 1;
    4 in dom the charact of A by DEF3; then
A4: dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A &
    In(4, dom the charact of A) = 4 by LemW,FUNCT_7:def 1;
A5: {} in {{}} by TARSKI:def 1;
    <*I1,I2*> in 2-tuples_on the carrier of A by CATALG_1:10;
    hence EmptyIns A <> I1\;I2 by A0,A1,A2,A5,Free2;
    <*C,I1,I2*> in 3-tuples_on the carrier of A by CATALG_1:12;
    hence EmptyIns A <> if-then-else(C,I1,I2) by A0,A1,A3,A5,Free2;
    <*C,I1*> in 2-tuples_on the carrier of A by CATALG_1:10;
    hence EmptyIns A <> while(C,I1) by A0,A1,A4,A5,Free2;
  end;

theorem ThFC:
  for A being preIfWhileAlgebra st A is free
  for I1,I2,C,J1,J2 being Element of A
  holds I1\;I2 <> I1 & I1\;I2 <> I2 &
  (I1\;I2 = J1\;J2 implies I1 = J1 & I2 = J2) &
  I1\;I2 <> if-then-else(C,J1,J2) & I1\;I2 <> while(C,J1)
  proof
    let A be preIfWhileAlgebra such that
A0: A is free;
    let I1,I2,C,J1,J2 be Element of A;
    2 in dom the charact of A by DEF1; then
A2: dom Den(In(2, dom the charact of A), A) = 2-tuples_on the carrier of A &
    In(2, dom the charact of A) = 2 by LemC,FUNCT_7:def 1;
    3 in dom the charact of A by DEF2; then
A3: dom Den(In(3, dom the charact of A), A) = 3-tuples_on the carrier of A &
    In(3, dom the charact of A) = 3 by LemI,FUNCT_7:def 1;
    4 in dom the charact of A by DEF3; then
A4: dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A &
    In(4, dom the charact of A) = 4 by LemW,FUNCT_7:def 1;
A5: <*I1,I2*> in 2-tuples_on the carrier of A &
    <*J1,J2*> in 2-tuples_on the carrier of A by CATALG_1:10;
    rng <*I1,I2*> = {I1,I2} by FINSEQ_2:147; then
    I1 in rng <*I1,I2*> & I2 in rng <*I1,I2*> by TARSKI:def 2;
    hence I1\;I2 <> I1 & I1\;I2 <> I2 by A0,A2,A5,Free4;
    hereby
      assume I1\;I2 = J1\;J2; then
      <*I1,I2*> = <*J1,J2*> by A0,A2,A5,Free2;
      hence I1 = J1 & I2 = J2 by GROUP_7:2;
    end;
    <*C,J1,J2*> in 3-tuples_on the carrier of A by CATALG_1:12;
    hence I1\;I2 <> if-then-else(C,J1,J2) by A0,A2,A3,A5,Free2;
    <*C,J1*> in 2-tuples_on the carrier of A by CATALG_1:10;
    hence I1\;I2 <> while(C,J1) by A0,A2,A4,A5,Free2;
  end;

theorem ThFI:
  for A being preIfWhileAlgebra st A is free
  for C,I1,I2,D,J1,J2 being Element of A
  holds if-then-else(C,I1,I2) <> C & if-then-else(C,I1,I2) <> I1 &
  if-then-else(C,I1,I2) <> I2 & if-then-else(C,I1,I2) <> while(D,J1) &
  (if-then-else(C,I1,I2) = if-then-else(D,J1,J2) implies C=D & I1=J1 & I2=J2)
  proof
    let A be preIfWhileAlgebra such that
A0: A is free;
    let C,I1,I2,D,J1,J2 be Element of A;
    3 in dom the charact of A by DEF2; then
A3: dom Den(In(3, dom the charact of A), A) = 3-tuples_on the carrier of A &
    In(3, dom the charact of A) = 3 by LemI,FUNCT_7:def 1;
    4 in dom the charact of A by DEF3; then
A4: dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A &
    In(4, dom the charact of A) = 4 by LemW,FUNCT_7:def 1;
A5: <*C,I1,I2*> in 3-tuples_on the carrier of A &
    <*D,J1,J2*> in 3-tuples_on the carrier of A by CATALG_1:12;
    rng <*C,I1,I2*> = {C,I1,I2} by FINSEQ_2:148; then
    C in rng <*C,I1,I2*> & I1 in rng <*C,I1,I2*> & I2 in rng <*C,I1,I2*>
    by ENUMSET1:def 1;
    hence if-then-else(C,I1,I2) <> C & if-then-else(C,I1,I2) <> I1 &
    if-then-else(C,I1,I2) <> I2 by A0,A3,A5,Free4;
    <*D,J1*> in 2-tuples_on the carrier of A by CATALG_1:10;
    hence if-then-else(C,I1,I2) <> while(D,J1) by A0,A3,A4,A5,Free2;
    assume if-then-else(C,I1,I2) = if-then-else(D,J1,J2); then
    <*C,I1,I2*> = <*D,J1,J2*> by A0,A3,A5,Free2;
    hence thesis by GROUP_7:3;
  end;

theorem ThFW:
  for A being preIfWhileAlgebra st A is  free
  for C,I,D,J being Element of A
  holds while(C,I) <> C & while(C,I) <> I &
  (while(C,I) = while(D,J) implies C = D & I = J)
  proof
    let A be preIfWhileAlgebra such that
A0: A is free;
    let C,I,D,J be Element of A;
    4 in dom the charact of A by DEF3; then
A4: dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A &
    In(4, dom the charact of A) = 4 by LemW,FUNCT_7:def 1;
A5: <*C,I*> in 2-tuples_on the carrier of A &
    <*D,J*> in 2-tuples_on the carrier of A by CATALG_1:10;
    rng <*C,I*> = {C,I} by FINSEQ_2:147; then
    C in rng <*C,I*> & I in rng <*C,I*> by TARSKI:def 2;
    hence while(C,I) <> C & while(C,I) <> I by A0,A4,A5,Free4;
    assume while(C,I) = while(D,J); then
    <*C,I*> = <*D,J*> by A0,A4,A5,Free2;
    hence thesis by GROUP_7:2;
  end;

registration
  cluster free -> well_founded non degenerated preIfWhileAlgebra;
  coherence
  proof
    let A be preIfWhileAlgebra; assume
A0: A is free; then reconsider A' = A as free Universal_Algebra;
    consider G being free GeneratorSet of A';
CC: Generators A = G by Free1;
    Generators A c= ElementaryInstructions A by LemG3;
    hence ElementaryInstructions A is GeneratorSet of A by CC,LemG1;
    thus not ex I1,I2 be Element of A st I1 <> EmptyIns A & I1\;I2 = I2 or
    I2 <> EmptyIns A & I1\;I2 = I1 or
    (I1 <> EmptyIns A or I2 <> EmptyIns A) & I1\;I2 = EmptyIns A
    by A0,ThFE,ThFC;
    thus thesis by A0,ThFE,ThFC,ThFI;
  end;
end;

registration
  cluster infinite non degenerated well_founded ECIW-strict free
  strict preIfWhileAlgebra;
  existence
  proof
    consider X being infinite disjoint_with_NAT set;
    take S = FreeUnivAlgNSG(ECIW-signature,X);
    thus thesis;
  end;
end;

definition
  mode IfWhileAlgebra is
  non degenerated well_founded ECIW-strict preIfWhileAlgebra;
end;

registration
  let A be infinite preIfWhileAlgebra;
  cluster ElementaryInstructions A -> infinite;
  coherence by INFINITE;
end;

theorem ThA7:
  for A being preIfWhileAlgebra
  for B being Subset of A
  for n being Nat holds
  EmptyIns A in B|^(n+1) &
  for C,I1,I2 being Element of A
  st C in B|^n & I1 in B|^n & I2 in B|^n
  holds I1\;I2 in B|^(n+1) & if-then-else(C,I1,I2) in B|^(n+1) &
  while(C,I1) in B|^(n+1)
  proof
    let A be preIfWhileAlgebra;
    let B be Subset of A;
    let n be Nat;
    set X = {Den(o,A).p where o is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B|^n};
A1: B|^(n+1) = B|^n \/ X by ThA4;
    reconsider pe = <*>the carrier of A as Element of (the carrier of A)*
    by FINSEQ_1:def 11;
    pe in {{}} & rng pe = {} & dom Den(In(1, dom the charact of A), A) = {{}} &
    {} c= B|^n by LemE,TARSKI:def 1,XBOOLE_1:2,RELAT_1:60; then
    EmptyIns A in X;
    hence EmptyIns A in B|^(n+1) by A1,XBOOLE_0:def 2;
    let C,I1,I2 be Element of A;
    assume
00: C in B|^n;
    assume
01: I1 in B|^n;
    assume
02: I2 in B|^n;
    <*I1,I2*> in 2-tuples_on the carrier of A &
    rng <*I1,I2*> = {I1,I2} &
    dom Den(In(2, dom the charact of A), A) = 2-tuples_on the carrier of A &
    {I1,I2} c= B|^n by 01,02,LemC,ZFMISC_1:38,FINSEQ_2:147,CATALG_1:10; then
    I1\;I2 in X;
    hence I1\;I2 in B|^(n+1) by A1,XBOOLE_0:def 2;
    <*C,I1,I2*> in 3-tuples_on the carrier of A &
    rng <*C,I1,I2*> = {C,I1,I2} &
    dom Den(In(3, dom the charact of A), A) = 3-tuples_on the carrier of A &
    {C,I1,I2} c= B|^n
    by 00,01,02,LemI,JORDAN16:2,FINSEQ_2:148,CATALG_1:12; then
    if-then-else(C,I1,I2) in X;
    hence if-then-else(C,I1,I2) in B|^(n+1) by A1,XBOOLE_0:def 2;
    <*C,I1*> in 2-tuples_on the carrier of A &
    rng <*C,I1*> = {C,I1} &
    dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A &
    {C,I1} c= B|^n by 00,01,LemW,ZFMISC_1:38,FINSEQ_2:147,CATALG_1:10; then
    while(C,I1) in X;
    hence while(C,I1) in B|^(n+1) by A1,XBOOLE_0:def 2;
  end;

theorem ThA5:
  for A being ECIW-strict preIfWhileAlgebra
  for x being set, n being Nat st x in (ElementaryInstructions A)|^(n+1)
  holds x in (ElementaryInstructions A)|^n or x = EmptyIns A or
  (ex I1,I2 being Element of A st x = I1\;I2 &
  I1 in (ElementaryInstructions A)|^n & I2 in (ElementaryInstructions A)|^n) or
  (ex C,I1,I2 being Element of A st x = if-then-else(C,I1,I2) &
  C in (ElementaryInstructions A)|^n &
  I1 in (ElementaryInstructions A)|^n & I2 in (ElementaryInstructions A)|^n) or
  (ex C,I being Element of A st x = while(C,I) &
  C in (ElementaryInstructions A)|^n & I in (ElementaryInstructions A)|^n)
  proof
    let A be ECIW-strict preIfWhileAlgebra;
    set B = ElementaryInstructions A;
    let x be set;
    let n be Nat;
    assume
00: x in B|^(n+1); then
    reconsider I = x as Element of A;
    assume
01: x nin B|^n;
    assume
02: x <> EmptyIns A;
    assume
03: not ex I1,I2 being Element of A st x = I1\;I2 & I1 in B|^n & I2 in B|^n;
    assume
04: not ex C,I1,I2 being Element of A st x = if-then-else(C,I1,I2) &
    C in B|^n & I1 in B|^n & I2 in B|^n;
    B|^(n+1) = B|^n\/{Den(o,A).p where o is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B|^n}
    by ThA4; then
    x in {Den(o,A).p where o is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(o,A) & rng p c= B|^n}
    by 00,01,XBOOLE_0:def 2; then
    consider o being (Element of dom the charact of A),
    p being Element of (the carrier of A)* such that
05: I = Den(o,A).p & p in dom Den(o,A) & rng p c= B|^n;
    reconsider no = o as Element of NAT;
    reconsider oo = Den(o,A) as Element of Operations A;
    len signature A = len the charact of A by UNIALG_1:def 11; then
06: dom signature A = dom the charact of A by FINSEQ_3:31;
07: len p = arity oo by 05,UNIALG_1:def 10
    .= (signature A).no by 06,UNIALG_1:def 11
    .= ECIW-signature.o by DefECIW;
08: In(o,dom the charact of A) = o by FUNCT_7:def 1;
09: 1 in Seg 2 & 2 in Seg 2 & 1 in Seg 3 & 2 in Seg 3 & 3 in Seg 3;
    per cases by ThECIW;
    suppose  o = 1;
      hence thesis by 02,05,08,07,ECIW,FINSEQ_1:25;
    end;
    suppose
A2:   o = 2; then
A3:   p = <*p.1,p.2*> & dom p = Seg 2 by 07,ECIW,FINSEQ_1:def 3,61; then
A4:   p.1 in rng p & p.2 in rng p by 09,FUNCT_1:def 5; then
      reconsider I1 = p.1, I2 = p.2 as Element of A;
      I = I1\;I2 by 05,A2,A3,FUNCT_7:def 1;
      hence thesis by 03,05,A4;
    end;
    suppose
A2:   o = 3; then
A3:   p = <*p.1,p.2,p.3*> & dom p = Seg 3 by 07,ECIW,FINSEQ_1:def 3,62; then
A4:   p.1 in rng p & p.2 in rng p & p.3 in rng p by 09,FUNCT_1:def 5; then
      reconsider C = p.1, I1 = p.2, I2 = p.3 as Element of A;
      I = if-then-else(C,I1,I2) by 05,A2,A3,FUNCT_7:def 1;
      hence thesis by 04,05,A4;
    end;
    suppose
A2:   o = 4; then
A3:   p = <*p.1,p.2*> & dom p = Seg 2 by 07,ECIW,FINSEQ_1:def 3,61; then
A4:   p.1 in rng p & p.2 in rng p by 09,FUNCT_1:def 5; then
      reconsider I1 = p.1, I2 = p.2 as Element of A;
      I = while(I1,I2) by 05,A2,A3,FUNCT_7:def 1;
      hence thesis by 05,A4;
    end;
  end;

theorem
  for A being Universal_Algebra
  for B being Subset of A
  holds Constants A c= B|^1
  proof
    let A be Universal_Algebra;
    let B be Subset of A;
    let x be set; assume x in Constants A; then
    consider a being Element of A such that
A1: x = a & ex o being Element of Operations A st arity o = 0 & a in rng o;
    consider o being Element of Operations A such that
A2: arity o = 0 & a in rng o by A1;
    consider s being set such that
A3: s in dom o & a = o.s by A2,FUNCT_1:def 5;
    consider z being set such that
A4: z in dom the charact of A & o = (the charact of A).z by FUNCT_1:def 5;
    reconsider z as Element of dom the charact of A by A4;
A5: Den(z,A) = o by A4;
A6: s is Element of 0-tuples_on the carrier of A by A3,A2,UNIALG_2:2;
    reconsider s as Element of (the carrier of A)* by A3;
    len s = 0 by A6,FINSEQ_2:109; then
    s = {} by FINSEQ_1:25; then
    rng s c= B by XBOOLE_1:2,RELAT_1:60; then
A7: x in {Den(r,A).p where r is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(r,A) & rng p c= B}
    by A1,A3,A5;
    B|^0 = B by ThA0; then
    B|^(0+1) = B \/ {Den(r,A).p where r is (Element of dom the charact of A),
    p is Element of (the carrier of A)*: p in dom Den(r,A) & rng p c= B}
    by ThA4;
    hence x in B|^1 by A7,XBOOLE_0:def 2;
  end;

theorem ThA6:
  for A being preIfWhileAlgebra
  holds A is well_founded iff
  for I being Element of A ex n being Nat st I in (ElementaryInstructions A)|^n
  proof
    let A be preIfWhileAlgebra;
    set B = ElementaryInstructions A;
    A is well_founded iff B is GeneratorSet of A by WELLFOUND;
    hence thesis by ThA60;
  end;

scheme StructInd{
    A() -> well_founded ECIW-strict preIfWhileAlgebra,
    I() -> (Element of A()),
    P[set]
  }:
  P[I()]
  provided
A0: for I being Element of A() st I in ElementaryInstructions A()
    holds P[I] and
A1: P[EmptyIns A()] and
A2: for I1,I2 being Element of A() st P[I1] & P[I2] holds P[I1\;I2] and
A3: for C,I1,I2 being Element of A() st P[C] & P[I1] & P[I2]
    holds P[if-then-else(C,I1,I2)] and
A4: for C,I being Element of A() st P[C] & P[I] holds P[while(C,I)]
  proof set A = A();
    consider n being Nat such that
A5: I() in (ElementaryInstructions A())|^n by ThA6;
    defpred Q[Nat] means for I being Element of A()
    st I in (ElementaryInstructions A())|^$1 holds P[I];
    (ElementaryInstructions A())|^0 = ElementaryInstructions A() by ThA0; then
B0: Q[0] by A0;
B1: now let n be Nat; assume
B2:   Q[n];
      thus Q[n+1]
      proof
        let I be Element of A(); assume
B3:     I in (ElementaryInstructions A())|^(n+1);
        per cases by B3,ThA5;
        suppose I in (ElementaryInstructions A)|^n;
          hence P[I] by B2;
        end;
        suppose I = EmptyIns A;
          hence P[I] by A1;
        end;
        suppose ex I1,I2 being Element of A st I = I1\;I2 &
          I1 in (ElementaryInstructions A)|^n &
          I2 in (ElementaryInstructions A)|^n; then
          consider I1,I2 being Element of A such that
B4:       I = I1\;I2 & I1 in (ElementaryInstructions A)|^n &
          I2 in (ElementaryInstructions A)|^n;
          P[I1] & P[I2] by B4,B2;
          hence P[I] by B4,A2;
        end;
        suppose ex C,I1,I2 being Element of A st I = if-then-else(C,I1,I2) &
          C in (ElementaryInstructions A)|^n &
          I1 in (ElementaryInstructions A)|^n &
          I2 in (ElementaryInstructions A)|^n; then
          consider C,I1,I2 being Element of A such that
B5:       I = if-then-else(C,I1,I2) &
          C in (ElementaryInstructions A)|^n &
          I1 in (ElementaryInstructions A)|^n &
          I2 in (ElementaryInstructions A)|^n;
          P[C] & P[I1] & P[I2] by B5,B2;
          hence P[I] by B5,A3;
        end;
        suppose ex C,J being Element of A st I = while(C,J) &
          C in (ElementaryInstructions A)|^n &
          J in (ElementaryInstructions A)|^n; then
          consider C,J being Element of A such that
B6:       I = while(C,J) &
          C in (ElementaryInstructions A)|^n &
          J in (ElementaryInstructions A)|^n;
          P[C] & P[J] by B6,B2;
          hence P[I] by B6,A4;
        end;
      end;
    end;
    for n being Nat holds Q[n] from NAT_1:sch 2(B0,B1);
    hence thesis by A5;
  end;

begin :: Execution function

definition
  let A be preIfWhileAlgebra;
  let S be non empty set; :: states
  let f be Function of [:S, the carrier of A:], S;
  attr f is satisfying_empty-instruction means:
EMP:
  for s being Element of S holds f.(s, EmptyIns A) = s;

  attr f is satisfying_catenation means:
CAT:
  for s being Element of S
  for I1,I2 being Element of A holds
  f.(s,I1 \; I2) = f.(f.(s,I1),I2);
end;

definition
  let A be preIfWhileAlgebra;
  let S be non empty set; :: states
  let T be Subset of S;   :: true states
  let f be Function of [:S, the carrier of A:], S;
  pred f satisfies_if_wrt T means:
IF:
  for s being Element of S for C, I1,I2 being Element of A holds
  (f.(s,C) in T implies f.(s,if-then-else(C,I1,I2)) = f.(f.(s,C),I1)) &
  (f.(s,C) nin T implies f.(s,if-then-else(C,I1,I2)) = f.(f.(s,C),I2));

  pred f satisfies_while_wrt T means:
WHILE:
  for s being Element of S for C, I being Element of A holds
  (f.(s,C) in T implies f.(s,while(C,I)) = f.(f.(f.(s,C),I),while(C,I))) &
  (f.(s,C) nin T implies f.(s,while(C,I)) = f.(s,C));
end;

theorem
  for f being Function of [:S, the carrier of A:], S
  st f is satisfying_empty-instruction & f satisfies_if_wrt T
  for s being Element of S holds
  f.(s,C) nin T implies f.(s,if-then(C,I)) = f.(s,C)
  proof let f be Function of [:S, the carrier of A:], S such that
Z0: f is satisfying_empty-instruction and
Z1: f satisfies_if_wrt T;
    let s be Element of S;
    assume f.(s,C) nin T;
    hence f.(s,if-then(C,I)) = f.(f.(s,C),EmptyIns A) by IF,Z1
    .= f.(s,C) by EMP,Z0;
  end;

theorem Th1:
  pr1(S, the carrier of A) is satisfying_empty-instruction &
  pr1(S, the carrier of A) is satisfying_catenation &
  pr1(S, the carrier of A) satisfies_if_wrt T &
  pr1(S, the carrier of A) satisfies_while_wrt T
  proof
    set f = pr1(S, the carrier of A);
    thus for s being Element of S holds f.(s, EmptyIns A) = s by FUNCT_3:def 5;
    hereby let s be Element of S;
      let I1,I2 be Element of A;
      thus f.(s,I1 \; I2) = s by FUNCT_3:def 5
      .= f.(s,I1) by FUNCT_3:def 5 .= f.(f.(s,I1),I2) by FUNCT_3:def 5;
    end;
    hereby let s be Element of S;
      let C, I1,I2 be Element of A;
      f.(s,if-then-else(C,I1,I2)) = s by FUNCT_3:def 5
      .= f.(s,C) by FUNCT_3:def 5;
      hence (f.(s,C) in T implies f.(s,if-then-else(C,I1,I2)) = f.(f.(s,C),I1))
      & (f.(s,C) nin T implies f.(s,if-then-else(C,I1,I2)) = f.(f.(s,C),I2))
      by FUNCT_3:def 5;
    end;
    let s be Element of S;
    let C, I be Element of A;
    f.(s,while(C,I)) = s & f.(s,C) = s & f.(s,I) = s by FUNCT_3:def 5;
    hence thesis;
  end;

definition
  let A be preIfWhileAlgebra;
  let S be non empty set; :: states
  let T be Subset of S;   :: true states
  mode ExecutionFunction of A,S,T -> Function of [:S, the carrier of A:], S
  means:
EXEC:
  it is satisfying_empty-instruction &
  it is satisfying_catenation &
  it satisfies_if_wrt T &
  it satisfies_while_wrt T;
  existence
  proof
    take f = pr1(S, the carrier of A);
    thus thesis by Th1;
  end;
end;

registration
  let A be preIfWhileAlgebra;
  let S be non empty set; :: states
  let T be Subset of S;   :: true states
  cluster -> satisfying_empty-instruction satisfying_catenation
  ExecutionFunction of A,S,T;
  coherence by EXEC;
end;

definition
  let A be preIfWhileAlgebra;
  let I be Element of A;
  let S be non empty set; :: states
  let s be Element of S;
  let T be Subset of S;   :: true states
  let f be ExecutionFunction of A, S, T;
:: iteration of I started in s terminates wrt f
  pred f iteration_terminates_for I,s means:
TERMINATION:
  ex r being non empty FinSequence of S st r.1 = s & r.len r nin T &
  for i being Nat st 1 <= i & i < len r
  holds r.i in T & r.(i+1) = f.(r.i, I);
end;

definition
  let A be preIfWhileAlgebra;
  let I be Element of A;
  let S be non empty set; :: states
  let s be Element of S;
  let T be Subset of S;   :: true states
  let f be ExecutionFunction of A, S, T;
  func iteration-degree(I,s,f) -> R_eal means:
TERMDEG:
  ex r being non empty FinSequence of S st
  it = (len r)-1 & r.1 = s & r.len r nin T &
  for i being Nat st 1 <= i & i < len r holds r.i in T & r.(i+1) = f.(r.i, I)
  if f iteration_terminates_for I,s
  otherwise it = +infty;
  correctness
  proof
A0: now assume f iteration_terminates_for I,s; then
      consider r being non empty FinSequence of S such that
B1:   r.1 = s & r.len r nin T & for i being Nat st 1 <= i & i < len r
      holds r.i in T & r.(i+1) = f.(r.i, I) by TERMINATION;
      reconsider x = (len r)-1 as R_eal by XXREAL_0:def 1;
      take x, r;
      thus x = (len r)-1 & r.1 = s & r.len r nin T &
      for i being Nat st 1 <= i & i < len r
      holds r.i in T & r.(i+1) = f.(r.i, I) by B1;
    end;
    now let d1, d2 be R_eal;
      given r1 being non empty FinSequence of S such that
A1:   d1 = (len r1)-1 & r1.1 = s & r1.len r1 nin T &
      for i being Nat st 1 <= i & i < len r1 holds
      r1.i in T & r1.(i+1) = f.(r1.i, I);
      given r2 being non empty FinSequence of S such that
A2:   d2 = (len r2)-1 & r2.1 = s & r2.len r2 nin T &
      for i being Nat st 1 <= i & i < len r2 holds
      r2.i in T & r2.(i+1) = f.(r2.i, I);
      defpred P[Nat] means
      $1 < len r1 implies $1 < len r2 & r1.($1+1) = r2.($1+1);
      len r2 <> 0 by FINSEQ_1:25; then
A3:   P[0] by A1,A2;
A4:   now let i be Element of NAT; assume
01:     P[i];
        thus P[i+1]
        proof assume
02:       i+1 < len r1;
05:       1 <= i+1 by NAT_1:11; then
06:       r1.(i+1+1) = f.(r1.(i+1), I) & r1.(i+1) in T & i+1 <= len r2
          by A1,01,02,NAT_1:13;
          hence i+1 < len r2 by A2,01,02,NAT_1:13,XXREAL_0:1;
          hence r1.(i+1+1) = r2.(i+1+1) by A2,01,02,NAT_1:13,05,06;
        end;
      end;
A5:   for i being Element of NAT holds P[i] from NAT_1:sch 1(A3,A4);
      len r1 <> 0 by FINSEQ_1:25; then
      consider i being Nat such that
A6:   len r1 = i+1 by NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      i < len r1 by A6,NAT_1:13; then
      i < len r2 & r1.len r1 = r2.len r1 & 1 <= len r1 by A5,A6,NAT_1:11; then
      len r1 <= len r2 & len r2 <= len r1 by A1,A2,A6,NAT_1:13;
      hence d1 = d2 by A1,A2,XXREAL_0:1;
    end;
    hence thesis by A0;
  end;
end;

reserve f for ExecutionFunction of A,S,T;

theorem
  f iteration_terminates_for I,s iff iteration-degree(I,s,f) < +infty
  proof
    hereby assume f iteration_terminates_for I,s; then
      consider r being non empty FinSequence of S such that
A1:   iteration-degree(I,s,f) = (len r)-1 & r.1 = s & r.len r nin T &
      for i being Nat st 1 <= i & i < len r
      holds r.i in T & r.(i+1) = f.(r.i, I) by TERMDEG;
      (len r)-1 in REAL by XREAL_0:def 1;
      hence iteration-degree(I,s,f) < +infty by A1,XXREAL_0:9;
   end;
    thus thesis by TERMDEG;
  end;

theorem ThTer0:
  s nin T implies f iteration_terminates_for I,s & iteration-degree(I,s,f) = 0
  proof assume
00: s nin T;
    set r = <*s*>;
01:   r.1 = s & len r = 1 by FINSEQ_1:57;
B2:   for i being Nat st 1 <= i & i < len r
      holds r.i in T & r.(i+1) = f.(r.i, I) by FINSEQ_1:57;
A2: 1-1 = 0.;
    thus f iteration_terminates_for I,s
    proof
      take r = <*s*>; thus thesis by 00,01;
    end;
    hence thesis by 00,B2,A2,TERMDEG,01;
  end;

theorem
  s in T implies
  (f iteration_terminates_for I,s iff f iteration_terminates_for I, f.(s,I)) &
  iteration-degree(I,s,f) = 1.+iteration-degree(I,f.(s,I),f)
  proof assume
A0: s in T;
    thus
AA: f iteration_terminates_for I,s iff f iteration_terminates_for I, f.(s,I)
    proof
      thus f iteration_terminates_for I,s implies
      f iteration_terminates_for I, f.(s,I)
      proof given r being non empty FinSequence of S such that
A1:     r.1 = s & r.len r nin T and
A2:     for i being Nat st 1 <= i & i < len r
        holds r.i in T & r.(i+1) = f.(r.i, I);
        consider r1 being (Element of S), q being FinSequence of S such that
A3:     r1 = r.1 & r = <*r1*>^q by FINSEQ_3:111;
A4:     len r = 1+len q by A3,FINSEQ_5:8; then
A6:     len q <> 0 by A0,A1; then
        reconsider q as non empty FinSequence of S by FINSEQ_1:25;
        len r <> 1 & len r >= 1 & len q > 0 by A6,A4,NAT_1:11; then
A5:     1 < len r & len q >= 0+1 by XXREAL_0:1,NAT_1:13;
        take q;
A7:     len <*r1*> = 1 & 1 in dom q by A5,FINSEQ_1:57,FINSEQ_3:27;
        hence q.1 = r.(1+1) by A3,FINSEQ_1:def 7 .= f.(s,I) by A1,A2,A5;
        len q in dom q by A5,FINSEQ_3:27;
        hence q.len q nin T by A1,A3,A4,A7,FINSEQ_1:def 7;
        let i be Nat; assume
A8:     1 <= i & i < len q;
        i in NAT by ORDINAL1:def 13; then
        i in dom q & 1 <= i+1 & i+1 < len r & i+1 in dom q
        by A4,A8,NAT_1:11,XREAL_1:8,MSUALG_8:1; then
        r.(i+1) = q.i & r.(i+1+1) = q.(i+1) & r.(i+1) in T &
        r.(i+1+1) = f.(r.(i+1), I) by A3,A7,A2,FINSEQ_1:def 7;
        hence thesis;
      end;
      given q being non empty FinSequence of S such that
A1:   q.1 = f.(s,I) & q.len q nin T and
A2:   for i being Nat st 1 <= i & i < len q
      holds q.i in T & q.(i+1) = f.(q.i, I);
      take r = <*s*>^q;
A7:   len <*s*> = 1 by FINSEQ_1:57;
      thus
B1:   r.1 = s by FINSEQ_1:58;
A4:   len r = 1+len q by FINSEQ_5:8;
      len q <> 0 by FINSEQ_1:25; then
      len q > 0; then
A5:   0+1 <= len q by NAT_1:13; then
      len q in dom q by FINSEQ_3:27;
      hence r.len r nin T by A1,A7,A4,FINSEQ_1:def 7;
      let i be Nat; assume
A8:   1 <= i & i < len r; then
      consider j being Nat such that
A3:   i = 1+j by NAT_1:10;
      per cases;
      suppose
A6:     j = 0;
        1 in dom q by A5,FINSEQ_3:27;
        hence thesis by A0,A1,A3,B1,A6,A7,FINSEQ_1:def 7;
      end;
      suppose j > 0; then
A6:     j >= 0+1 & j < len q & j in NAT
        by A4,A8,A3,NAT_1:13,ORDINAL1:def 13,XREAL_1:8; then
        j in dom q & 1 <= j+1 & j+1 < len r & j+1 in dom q
        by A4,XREAL_1:8,MSUALG_8:1; then
        r.(j+1) = q.j & r.(j+1+1) = q.(j+1) & q.j in T &
        q.(j+1) = f.(q.j, I) by A7,A2,A6,FINSEQ_1:def 7;
        hence thesis by A3;
      end;
    end;
    per cases by AA;
    suppose not f iteration_terminates_for I,s; then
      iteration-degree(I,s,f) = +infty &
      iteration-degree(I,f.(s,I),f) = +infty  by AA,TERMDEG;
      hence thesis by SUPINF_2:def 2;
    end;
    suppose
AZ:   f iteration_terminates_for I,f.(s,I); then
      consider q being non empty FinSequence of S such that
AB:   iteration-degree(I,f.(s,I),f) = (len q)-1 and
A1:   q.1 = f.(s,I) & q.len q nin T and
A2:   for i being Nat st 1 <= i & i < len q
      holds q.i in T & q.(i+1) = f.(q.i, I) by TERMDEG;
      set r = <*s*>^q;
A7:   len <*s*> = 1 by FINSEQ_1:57;
B1:   r.1 = s by FINSEQ_1:58;
A4:   len r = 1+len q by FINSEQ_5:8; then
      1+((len q)-1) = len q & (len r)-1 = len q & (len q)-1 in REAL &
      1 in REAL & (len r)-1 in ExtREAL by XREAL_0:def 1,XXREAL_0:def 1; then
AC:   (len r)-1 = 1.+iteration-degree(I,f.(s,I),f) by AB,SUPINF_2:def 2;
      len q <> 0 by FINSEQ_1:25; then
      len q > 0; then
A5:   0+1 <= len q by NAT_1:13; then
      len q in dom q by FINSEQ_3:27; then
B2:   r.len r nin T by A1,A7,A4,FINSEQ_1:def 7;
      now let i be Nat; assume
A8:     1 <= i & i < len r; then
        consider j being Nat such that
A3:     i = 1+j by NAT_1:10;
        per cases;
        suppose
A6:       j = 0;
          1 in dom q by A5,FINSEQ_3:27;
          hence r.i in T & r.(i+1) = f.(r.i,I)
          by A0,A1,A3,B1,A6,A7,FINSEQ_1:def 7;
        end;
        suppose j > 0; then
A6:       j >= 0+1 & j < len q & j in NAT
          by A4,A8,A3,NAT_1:13,ORDINAL1:def 13,XREAL_1:8; then
          j in dom q & 1 <= j+1 & j+1 < len r & j+1 in dom q
          by A4,XREAL_1:8,MSUALG_8:1; then
          r.(j+1) = q.j & r.(j+1+1) = q.(j+1) & q.j in T &
          q.(j+1) = f.(q.j, I) by A7,A2,A6,FINSEQ_1:def 7;
          hence r.i in T & r.(i+1) = f.(r.i,I) by A3;
        end;
      end;
      hence thesis by B1,B2,AA,AC,AZ,TERMDEG;
    end;
  end;

theorem
  iteration-degree(I,s,f) >= 0
  proof per cases;
    suppose not f iteration_terminates_for I,s;
      hence thesis by TERMDEG;
    end;
    suppose f iteration_terminates_for I,s; then
      consider r being non empty FinSequence of S such that
A0:   iteration-degree(I,s,f) = (len r)-1 and
      r.1 = s & r.len r nin T &
      for i being Nat st 1 <= i & i < len r
      holds r.i in T & r.(i+1) = f.(r.i, I) by TERMDEG;
      len r <> 0 by FINSEQ_1:25; then
      ex i being Nat st  len r = i+1 by NAT_1:6;
      hence thesis by A0;
    end;
  end;

scheme Termination
  {A() -> preIfWhileAlgebra,
   I() -> (Element of A()),
   S() -> non empty set,
   s() -> (Element of S()),
   T() -> Subset of S(),
   f() -> ExecutionFunction of A(),S(),T(),
   F(set) -> Nat, P[set]
  }:
  f() iteration_terminates_for I(),s()
  provided
I: s() in T() iff P[s()] and
C: for s being Element of S() st P[s]
   holds (P[f().(s,I())] iff f().(s,I()) in T()) & F(f().(s,I())) < F(s)
  proof
    per cases;
    suppose
      s() nin T();
      hence thesis by ThTer0;
    end;
    suppose
A:    s() in T();
      deffunc F(set,set) = f().(In($2,S()),I());
      consider f being Function of NAT,S() such that
A1:   f.0 = s() and
A2:   for i being Element of NAT holds f.(i+1) = F(i,f.i)
      from RECDEF_1:sch 4;
      defpred Q[Nat] means ex i being Element of NAT st F(f.i) = $1;
      F(f.0) in NAT by ORDINAL1:def 13; then
A3:   ex j being Element of NAT st Q[j];
      consider j being Element of NAT such that
A4:   Q[j] & for i being Element of NAT st Q[i] holds j <= i
      from NAT_1:sch 5(A3);
      consider i0 being Element of NAT such that
A5:   F(f.i0) = j by A4;
      defpred R[Element of NAT] means not P[f.$1];
      In(f.i0,S()) = f.i0 by FUNCT_7:def 1; then
      f.(i0+1) = f().(f.i0,I()) by A2; then
      F(f.(i0+1)) in NAT & (P[f.i0] implies F(f.(i0+1)) < j)
      by A5,C,ORDINAL1:def 13; then
A6:   ex i being Element of NAT st R[i] by A4;
      consider j being Element of NAT such that
A7:   R[j] & for i being Element of NAT st R[i] holds j <= i
      from NAT_1:sch 5(A6);
      deffunc G(Nat) = f.($1-'1);
      consider p being FinSequence of S() such that
A8:   len p = j+1 &
      for i being Element of NAT st i in Seg (j+1) holds p.i = G(i)
      from FINSEQ_2:sch 1;
      reconsider p as non empty FinSequence of S() by A8,FINSEQ_1:25;
      take p;
A9:   1 <= j+1 by NAT_1:11; then
      1 in Seg(j+1);
      hence p.1 = G(1) by A8 .= s() by A1,BINARITH:51;
      len p in Seg(j+1) by A8,A9; then
A9:   p.len p = G(j+1) by A8 .= f.j by BINARITH:39;
      j <> 0 by A,I,A1,A7; then
      j > 0; then
      j >= 0+1 by NAT_1:13; then
      consider j' being Nat such that
B1:   j = 1+j' by NAT_1:10;
      reconsider j' as Element of NAT by ORDINAL1:def 13;
B2:   f.j = f().(In(f.j',S()),I()) by B1,A2;
      j' < j by B1,NAT_1:13; then
      P[f.j'] & In(f.j',S()) = f.j' by A7,FUNCT_7:def 1;
      hence p.len p nin T() by C,B2,A7,A9;
      let i be Nat; assume
B3:   1 <= i & i < len p; then
      i+1 >= 1 & i+1 <= len p by NAT_1:13; then
      i in Seg(j+1) & i+1 in Seg(j+1) by B3,A8,FINSEQ_1:3; then
B4:   p.i = G(i) & p.(i+1) = G(i+1) by A8;
      consider i' being Nat such that
B5:   i = 1+i' by B3,NAT_1:10;
      reconsider i' as Element of NAT by ORDINAL1:def 13;
      i <= j by A8,B3,NAT_1:13; then
B8:   i' < j by B5,NAT_1:13; then
B6:   P[f.i'] & i-'1 = i' & i+1-'1 = i & In(f.i',S()) = f.i'
      by A7,B5,BINARITH:39,FUNCT_7:def 1;
      now assume i' <> 0; then
        i' > 0; then
        i' >= 0+1 by NAT_1:13; then
        consider i'' being Nat such that
B7:     i' = 1+i'' by NAT_1:10;
        reconsider i'' as Element of NAT by ORDINAL1:def 13;
        i'' <= i' by B7,NAT_1:11; then
        i'' < j by B8,XXREAL_0:2; then
        P[f.i''] & In(f.i'',S()) = f.i'' & f.i' = F(i'',f.i'')
        by A2,A7,B7,FUNCT_7:def 1;
        hence p.i in T() by B4,B6,C;
      end;
      hence p.i in T() & p.(i+1) = f().(p.i, I()) by A,A1,A2,B4,B5,B6;
    end;
  end;

scheme Termination2
  {A() -> preIfWhileAlgebra,
   I() -> (Element of A()),
   S() -> non empty set,
   s() -> (Element of S()),
   T() -> Subset of S(),
   f() -> ExecutionFunction of A(),S(),T(),
   F(set) -> Nat, P,R[set]
  }:
  f() iteration_terminates_for I(),s()
  provided
A: P[s()] and
I: s() in T() iff R[s()] and
C: for s being Element of S() st P[s] & s in T() & R[s]
   holds P[f().(s, I())] & (R[f().(s,I())] iff f().(s,I()) in T()) &
   F(f().(s,I())) < F(s)
  proof
    per cases;
    suppose
      s() nin T();
      hence thesis by ThTer0;
    end;
    suppose
A0:   s() in T();
      deffunc F(set,set) = f().(In($2,S()),I());
      consider f being Function of NAT,S() such that
A1:   f.0 = s() and
A2:   for i being Element of NAT holds f.(i+1) = F(i,f.i)
      from RECDEF_1:sch 4;
      defpred Q[Nat] means ex i being Element of NAT st F(f.i) = $1;
      F(f.0) in NAT by ORDINAL1:def 13; then
A3:   ex j being Element of NAT st Q[j];
      consider j being Element of NAT such that
A4:   Q[j] & for i being Element of NAT st Q[i] holds j <= i
      from NAT_1:sch 5(A3);
      consider i0 being Element of NAT such that
A5:   F(f.i0) = j by A4;
      defpred notR[Element of NAT] means not (P[f.$1] & f.$1 in T() & R[f.$1]);
      In(f.i0,S()) = f.i0 by FUNCT_7:def 1; then
      f.(i0+1) = f().(f.i0,I()) by A2; then
      F(f.(i0+1)) in NAT & (not notR[i0] implies F(f.(i0+1)) < j)
      by A5,C,ORDINAL1:def 13; then
A6:   ex i being Element of NAT st notR[i] by A4;
      consider j being Element of NAT such that
A7:   notR[j] & for i being Element of NAT st notR[i] holds j <= i
      from NAT_1:sch 5(A6);
      deffunc G(Nat) = f.($1-'1);
      consider p being FinSequence of S() such that
A8:   len p = j+1 &
      for i being Element of NAT st i in Seg (j+1) holds p.i = G(i)
      from FINSEQ_2:sch 1;
      reconsider p as non empty FinSequence of S() by A8,FINSEQ_1:25;
      take p;
A9:   1 <= j+1 by NAT_1:11; then
      1 in Seg(j+1);
      hence p.1 = G(1) by A8 .= s() by A1,BINARITH:51;
      len p in Seg(j+1) by A8,A9; then
A9:   p.len p = G(j+1) by A8 .= f.j by BINARITH:39;
      j <> 0 by A,A0,I,A1,A7; then
      j > 0; then
      j >= 0+1 by NAT_1:13; then
      consider j' being Nat such that
B1:   j = 1+j' by NAT_1:10;
      reconsider j' as Element of NAT by ORDINAL1:def 13;
B2:   f.j = f().(In(f.j',S()),I()) by B1,A2;
      j' < j by B1,NAT_1:13; then
      R[f.j'] & f.j' in T() & P[f.j'] & In(f.j',S()) = f.j'
      by A7,FUNCT_7:def 1;
      hence p.len p nin T() by C,B2,A7,A9;
      let i be Nat; assume
B3:   1 <= i & i < len p; then
      i+1 >= 1 & i+1 <= len p by NAT_1:13; then
      i in Seg(j+1) & i+1 in Seg(j+1) by B3,A8,FINSEQ_1:3; then
B4:   p.i = G(i) & p.(i+1) = G(i+1) by A8;
      consider i' being Nat such that
B5:   i = 1+i' by B3,NAT_1:10;
      reconsider i' as Element of NAT by ORDINAL1:def 13;
      i <= j by A8,B3,NAT_1:13; then
      i' < j by B5,NAT_1:13; then
B6:   P[f.i'] & f.i' in T() & R[f.i'] & i-'1 = i' & i+1-'1 = i &
      In(f.i',S()) = f.i' by A7,B5,BINARITH:39,FUNCT_7:def 1;
      thus p.i in T() & p.(i+1) = f().(p.i, I()) by A2,B4,B5,B6;
    end;
  end;

theorem ThW1:
  for r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
    for i being Nat st 1 <= i & i < len r
    holds r.i in T & r.(i+1) = f.(r.i, I \; C)
  holds f.(s, while(C,I)) = r.len r
  proof
Z0: f satisfies_while_wrt T by EXEC;
    let r be non empty FinSequence of S;
    assume
00: r.1 = f.(s,C);
    assume
01: r.len r nin T;
    assume
02: for i being Nat st 1 <= i & i < len r
    holds r.i in T & r.(i+1) = f.(r.i, I \; C);
    defpred P[Nat] means
    (len r)-$1 in dom r implies
    for q being Element of S st f.(q,C) = r.((len r)-$1)
    holds f.(q, while(C,I)) = r.len r;
03: P[0] by 01,Z0,WHILE;
04: for i being Nat st P[i] holds P[i+1]
    proof let i be Nat such that
A1:   P[i] and
A2:   (len r)-(i+1) in dom r;
      reconsider j = (len r)-(i+1) as Element of NAT by A2;
      j+1+i = len r; then
a3:   1 <= j+1 & j+1 <= len r by NAT_1:11; then
A3:   1 <= j & j < len r & (len r)-i in dom r by A2,NAT_1:13,FINSEQ_3:27; then
A4:   r.(j+1) = f.(r.j, I\;C) by 02;
      let q be Element of S; assume
A5:   f.(q,C) = r.((len r)-(i+1)); then
A6:   f.(q,C) in T by 02,A3;
      r.(j+1) = f.(f.(f.(q,C), I), C) by A4,A5,CAT; then
      f.(f.(f.(q,C), I), while(C,I)) = r.len r by A1,a3,FINSEQ_3:27;
      hence thesis by A6,Z0,WHILE;
    end;
05: for i being Nat holds P[i] from NAT_1:sch 2(03,04);
    len r <> 0 by FINSEQ_1:25; then
    len r > 0; then
Z1: len r >= 0+1 by NAT_1:13; then
    consider i being Nat such that
Z2: len r = 1+i by NAT_1:10;
    P[i] & (len r)-i = 1 & 1 in dom r by Z2,05,Z1,FINSEQ_3:27;
    hence thesis by 00;
  end;

theorem ThTer2:
  for I being Element of A
  for s being Element of S holds
  not f iteration_terminates_for I,s iff (curry' f).I orbit s c= T
  proof
    let I be Element of A;
    let s be Element of S;
    set g = (curry' f).I;
    hereby assume
01:   not f iteration_terminates_for I,s;
      thus g orbit s c= T
      proof
        let x be set; assume x in g orbit s; then
        consider n being Element of NAT such that
0A:     x = iter(g, n).s & s in dom iter(g, n);
        defpred P[Nat] means iter(g,$1).s nin T;
        assume x nin T; then
0B:     ex n being Element of NAT st P[n] by 0A;
        consider n being Element of NAT such that
0C:     P[n] & for m being Element of NAT st P[m] holds n <= m
        from NAT_1:sch 5(0B);
        deffunc F(Nat) = iter(g,$1-'1).s;
        consider r being FinSequence such that
0D:     len r = n+1 &
        for k being Element of NAT st k in Seg(n+1) holds r.k = F(k)
        from FINSEQ_1:sch 2;
0G:     dom r = Seg(n+1) by 0D,FINSEQ_1:def 3;
0E:     rng r c= S
        proof
          let a be set;
          assume a in rng r; then
          consider b being set such that
A1:       b in dom r & a = r.b by FUNCT_1:def 5;
          reconsider b as Element of NAT by A1;
          iter(g,b-'1) is Function of S,S &
          r.b = iter(g,b-'1).s by 0D,0G,A1;
          hence thesis by A1;
        end;
        reconsider r as non empty FinSequence of S by 0D,0E,FINSEQ_1:25,def 4;
        1 <= n+1 by NAT_1:11; then
        1 in Seg(n+1) & n+1 in Seg(n+1); then
        1-'1 = 0 & n+1-'1 = n & iter(g,0) = id S & r.1 = F(1) &
        r.len r = F(n+1) by 0D,FUNCT_7:86,BINARITH:39,51; then
0F:     r.1 = s & r.len r nin T by 0C,FUNCT_1:34;
        now let i be Nat such that
A2:       1 <= i & i < len r;
          consider j being Nat such that
A3:       i = 1+j by A2,NAT_1:10;
          reconsider j as Element of NAT by ORDINAL1:def 13;
A4:       i-'1 = j & (i+1)-'1 = i by A3,BINARITH:39;
          dom curry' f = the carrier of A & dom g = S by FUNCT_2:def 1; then
A5:       g.(iter(g,j).s) = f.(iter(g,j).s, I) & iter(g,i) = g*iter(g,j)
          by A3,FUNCT_7:73,FUNCT_5:41;
          1 <= i+1 & i+1 <= n+1 by 0D,A2,NAT_1:13; then
          i-'1 < n & i in Seg(n+1) & i+1 in Seg(n+1)
          by 0D,A2,A3,A4,XREAL_1:8,FINSEQ_1:3; then
          r.i = iter(g,i-'1).s & r.(i+1) = iter(g,i).s & not P[i-'1]
          by 0C,0D,A4;
          hence r.i in T & r.(i+1) = f.(r.i, I) by A4,A5,FUNCT_2:21;
        end;
        hence contradiction by 01,0F,TERMINATION;
      end;
    end;
    assume
02: (curry' f).I orbit s c= T;
    given r being non empty FinSequence of S such that
03: r.1 = s & r.len r nin T and
04: for i being Nat st 1 <= i & i < len r
    holds r.i in T & r.(i+1) = f.(r.i, I);
    defpred P[Nat] means
    $1+1 <= len r implies r.($1+1) in (curry' f).I orbit s;
    dom g = S by FUNCT_2:def 1; then
05: P[0] by 03,LemO1;
06: for i being Nat st P[i] holds P[i+1]
    proof
      let i be Nat such that
C1:   P[i] & i+1+1 <= len r;
C2:   1 <= i+1 & i+1 < len r by C1,NAT_1:11,13; then
      i+1 in dom r by FINSEQ_3:27; then
      r.(i+1) in rng r & rng r c= S & dom f = [:S, the carrier of A:]
      by FUNCT_1:12,FUNCT_2:def 1; then
C3:   [r.(i+1), I] in dom f by ZFMISC_1:106;
      consider n being Element of NAT such that
C4:   r.(i+1) = iter((curry' f).I,n).s & s in dom iter((curry' f).I,n)
      by C1,NAT_1:13;
C5:   r.(i+1+1) = f.(r.(i+1), I) by C2,04
      .= (curry' f).I.(r.(i+1)) by C3,FUNCT_5:29
      .= (g*iter(g,n)).s by C4,FUNCT_2:21
      .= iter((curry' f).I,n+1).s by FUNCT_7:73;
      dom iter(g,n+1) = S by FUNCT_2:def 1;
      hence r.(i+1+1) in g orbit s by C5;
    end;
    len r <> 0 by FINSEQ_1:25; then
    consider i being Nat such that
07: len r = i+1 by NAT_1:6;
    for n being Nat holds P[n] from NAT_1:sch 2(05,06); then
    r.(i+1) in g orbit s by 07;
    hence contradiction by 07,03,02;
  end;

scheme InvariantSch
  {A() -> preIfWhileAlgebra,
   C,I() -> (Element of A()),
   S() -> non empty set,
   s() -> (Element of S()),
   T() -> Subset of S(),
   f() -> ExecutionFunction of A(),S(),T(),
   P,R[set]
  }:
  P[f().(s(),while(C(),I()))] & not R[f().(s(),while(C(),I()))]
provided
A: P[s()] and
C: f() iteration_terminates_for I()\;C(), f().(s(),C()) and
D: for s being Element of S() st P[s] & s in T() & R[s]
   holds P[f().(s,I())] and
E: for s being Element of S() st P[s] holds
   P[f().(s,C())] & (f().(s,C()) in T() iff R[f().(s,C())])
  proof
    consider r being non empty FinSequence of S() such that
A1: r.1 = f().(s(),C()) & r.len r nin T() &
    for i being Nat st 1 <= i & i < len r
    holds r.i in T() & r.(i+1) = f().(r.i, I()\;C()) by C,TERMINATION;
A2: f().(s(), while(C(),I())) = r.len r by A1,ThW1;
    defpred Q[Nat] means $1+1 in dom r implies P[r.($1+1)] &
    ($1+1 < len r implies R[r.($1+1)]) &
    ex q being Element of S() st P[q] & r.($1+1) = f().(q,C());
    0+1 < len r implies r.(0+1) in T() by A1; then
A3: Q[0] by A,E,A1;
A4: for n being Nat st Q[n] holds Q[n+1]
    proof let n be Nat; assume
00:   Q[n]; assume
01:   n+1+1 in dom r; then
o6:   n+1+1 <= len r by FINSEQ_3:27; then
06:   n+1+1 >= 1 & n+1 >= 1 & n+1 < len r by NAT_1:11,13; then
02:   n+1 in dom r & r.(n+1) in T() & r.(n+1+1) = f().(r.(n+1), I()\;C())
      by A1,FINSEQ_3:27; then
      reconsider q1 = r.(n+1), q2 = r.(n+1+1) as Element of S()
      by 01,DTCONSTR:2;
      reconsider q3 = f().(q1,I()) as Element of S();
04:   q2 = f().(q3, C()) by 02,CAT;
05:   P[q3] by 00,02,o6,D,NAT_1:13;
      hence P[r.(n+1+1)] by E,04;
      hereby
        assume n+1+1 < len r; then
        r.(n+1+1) in T() by A1,06;
        hence R[r.(n+1+1)] by E,05,04;
      end;
      take q3;  thus thesis by 02,CAT,00,o6,D,NAT_1:13;
    end;
A5: for n being Nat holds Q[n] from NAT_1:sch 2(A3,A4);
    len r <> 0 by FINSEQ_1:25; then
    len r > 0; then
A7: len r >= 0+1 by NAT_1:13; then
    consider j being Nat such that
A6: len r = 1+j by NAT_1:10;
A8: j+1 in dom r by A7,A6,FINSEQ_3:27;
    hence P[f().(s(),while(C(),I()))] by A2,A5,A6;
    ex q being Element of S() st P[q] & r.(j+1) = f().(q, C()) by A5,A8;
    hence thesis by A1,A2,A6,E;
  end;

scheme coInvariantSch
  {A() -> preIfWhileAlgebra,
   C,I() -> (Element of A()),
   S() -> non empty set,
   s() -> (Element of S()),
   T() -> Subset of S(),
   f() -> ExecutionFunction of A(),S(),T(),
   P[set]
  }:
  P[s()]
provided
A: P[f().(s(),while(C(),I()))] and
C: f() iteration_terminates_for I()\;C(), f().(s(),C()) and
D: for s being Element of S() st P[f().(f().(s,C()),I())] & f().(s,C()) in T()
   holds P[f().(s,C())] and
E: for s being Element of S() st P[f().(s,C())] holds P[s]
  proof
    consider r being non empty FinSequence of S() such that
A1: r.1 = f().(s(),C()) & r.len r nin T() &
    for i being Nat st 1 <= i & i < len r
    holds r.i in T() & r.(i+1) = f().(r.i, I()\;C()) by C,TERMINATION;
    defpred Q[Nat] means (len r)-$1 in dom r implies P[r.((len r)-$1)];
    defpred R[Nat] means $1+1 in dom r implies
    ex q being Element of S() st r.($1+1) = f().(q,C());
R0: R[0] by A1;
R1: for n being Nat st R[n] holds R[n+1]
    proof
      let n be Nat; assume R[n]; assume
01:   n+1+1 in dom r; then
      n+1+1 <= len r by FINSEQ_3:27; then
      n+1 >= 1 & n+1 < len r by NAT_1:11,13; then
02:   n+1 in dom r & r.(n+1) in T() & r.(n+1+1) = f().(r.(n+1), I()\;C())
      by A1,FINSEQ_3:27; then
      reconsider q1 = r.(n+1), q2 = r.(n+1+1) as Element of S()
      by 01,DTCONSTR:2;
      reconsider q3 = f().(q1,I()) as Element of S();
      take q3; thus thesis by 02,CAT;
    end;
A3: Q[0] by A,A1,ThW1;
A4: for n being Nat st Q[n] holds Q[n+1]
    proof let n be Nat; assume
00:   Q[n]; assume
01:   (len r)-(n+1) in dom r; then
      reconsider j = (len r)-(n+1) as Element of NAT;
06:   j >= 1 by 01,FINSEQ_3:27;
      n+1 >= 0+1 by NAT_1:13; then
      j <= (len r)-1 by XREAL_1:12; then
07:   j+1 <= (len r)-1+1 & 1 <= 1+j by XREAL_1:8,NAT_1:11; then
o2:   j < len r by NAT_1:13; then
02:   j+1 in dom r & r.j in T() & r.(j+1) = f().(r.j, I()\;C())
      by 06,07,A1,FINSEQ_3:27; then
      reconsider q1 = r.j, q2 = r.(j+1) as Element of S() by DTCONSTR:2;
      reconsider q' = f().(q1, I()) as Element of S();
      consider j' being Nat such that
03:   j = 1+j' by 06,NAT_1:10;
      for n being Nat holds R[n] from NAT_1:sch 2(R0,R1); then
      consider qq being Element of S() such that
04:   r.(j'+1) = f().(qq,C()) by 01,03;
      q2 = f().(q', C()) & P[q2] by 00,02,CAT; then
      P[f().(f().(qq,C()),I())] & f().(qq,C()) in T()
        by 03,04,o2,E,06,A1;
      hence P[r.((len r)-(n+1))] by 03,04,D;
    end;
A5: for n being Nat holds Q[n] from NAT_1:sch 2(A3,A4);
    len r <> 0 by FINSEQ_1:25; then
    len r > 0; then
A7: len r >= 0+1 by NAT_1:13; then
    consider j being Nat such that
A6: len r = 1+j by NAT_1:10;
    (len r)-j in dom r by A7,A6,FINSEQ_3:27; then
    P[r.1] by A5,A6;
    hence P[s()] by A1,E;
  end;

theorem ThA9C:
  for A being free preIfWhileAlgebra
  for I1,I2 being Element of A
  for n being Nat st I1\;I2 in (ElementaryInstructions A)|^n
  ex i being Nat st n = i+1 &
  I1 in (ElementaryInstructions A)|^i & I2 in (ElementaryInstructions A)|^i
  proof
    let A be free preIfWhileAlgebra;
    set B = ElementaryInstructions A;
00: B is GeneratorSet of A by WELLFOUND;
    let I1,I2 be Element of A;
    I1\;I2 <> I1 & I1\;I2 <> I2 by ThFC; then
    I1\;I2 nin B by Th0B; then
01: I1\;I2 nin B|^0 by ThA0;
    let n be Nat;
    assume
02: I1\;I2 in B|^n; then n > 0 by 01,NAT_1:3; then
    n >= 0+1 by NAT_1:13; then
    consider i being Nat such that
03: n = 1+i by NAT_1:10;
    take i;
    thus n = i+1 by 03;
05: dom Den(In(2, dom the charact of A), A) = 2-tuples_on the carrier of A
    by LemC;
04: for o being OperSymbol of A, p being FinSequence st p in dom Den(o,A)
    holds Den(o,A).p in B implies o <> In(2, dom the charact of A)
    proof
      let o be OperSymbol of A;
      let p be FinSequence;
      assume
06:   p in dom Den(o,A) & Den(o,A).p in B &
      o = In(2, dom the charact of A); then
      consider a,b being set such that
07:   a in the carrier of A & b in the carrier of A & p = <*a,b*>
      by 05,CATALG_1:10;
      reconsider a,b as Element of A by 07;
      Den(o,A).p = a\;b & a\;b <> a & a\;b <> b by 06,07,ThFC;
      hence contradiction by 06,Th0B;
    end;
    <*I1,I2*> in dom Den(In(2, dom the charact of A),A) by 05,CATALG_1:10; then
    rng <*I1,I2*> c= B|^i by 00,02,03,04,Free5; then
    {I1,I2} c= B|^i by FINSEQ_2:147;
    hence thesis by ZFMISC_1:38;
  end;
  
theorem ThA9I:
  for A being free preIfWhileAlgebra
  for C,I1,I2 being Element of A
  for n being Nat st if-then-else(C,I1,I2) in (ElementaryInstructions A)|^n
  ex i being Nat st n = i+1 & C in (ElementaryInstructions A)|^i &
  I1 in (ElementaryInstructions A)|^i & I2 in (ElementaryInstructions A)|^i
  proof
    let A be free preIfWhileAlgebra;
    set B = ElementaryInstructions A;
00: B is GeneratorSet of A by WELLFOUND;
    let C,I1,I2 be Element of A;
    if-then-else(C,I1,I2) nin B by Th0C; then
01: if-then-else(C,I1,I2) nin B|^0 by ThA0;
    let n be Nat;
    assume
02: if-then-else(C,I1,I2) in B|^n; then
    consider i being Nat such that
03: n = i+1 by 01,NAT_1:6;
    take i;
    thus n = i+1 by 03;
05: dom Den(In(3, dom the charact of A), A) = 3-tuples_on the carrier of A
    by LemI;
04: for o being OperSymbol of A, p being FinSequence st p in dom Den(o,A)
    holds Den(o,A).p in B implies o <> In(3, dom the charact of A)
    proof
      let o be OperSymbol of A;
      let p be FinSequence;
      assume
06:   p in dom Den(o,A) & Den(o,A).p in B &
      o = In(3, dom the charact of A); then
      consider a,b,c being set such that
07:   a in the carrier of A & b in the carrier of A & c in the carrier of A &
      p = <*a,b,c*> by 05,CATALG_1:12;
      reconsider a,b,c as Element of A by 07;
      Den(o,A).p = if-then-else(a,b,c) by 06,07;
      hence contradiction by 06,Th0C;
    end;
    <*C,I1,I2*> in dom Den(In(3, dom the charact of A),A)
    by 05,CATALG_1:12; then
    rng <*C,I1,I2*> c= B|^i by 00,02,03,04,Free5; then
    {C,I1,I2} c= B|^i & C in {C,I1,I2} & I1 in {C,I1,I2} & I2 in {C,I1,I2}
    by FINSEQ_2:148,ENUMSET1:def 1;
    hence thesis;
  end;
  
theorem ThA9W:
  for A being free preIfWhileAlgebra
  for C,I being Element of A
  for n being Nat st while(C,I) in (ElementaryInstructions A)|^n
  ex i being Nat st n = i+1 &
  C in (ElementaryInstructions A)|^i & I in (ElementaryInstructions A)|^i
  proof
    let A be free preIfWhileAlgebra;
    set B = ElementaryInstructions A;
00: B is GeneratorSet of A by WELLFOUND;
    let C,I be Element of A;
    while(C,I) nin B by Th0D; then
01: while(C,I) nin B|^0 by ThA0;
    let n be Nat;
    assume
02: while(C,I) in B|^n; then
    consider i being Nat such that
03: n = i+1 by 01,NAT_1:6;
    take i;
    thus n = i+1 by 03;
05: dom Den(In(4, dom the charact of A), A) = 2-tuples_on the carrier of A
    by LemW;
04: for o being OperSymbol of A, p being FinSequence st p in dom Den(o,A)
    holds Den(o,A).p in B implies o <> In(4, dom the charact of A)
    proof
      let o be OperSymbol of A;
      let p be FinSequence;
      assume
06:   p in dom Den(o,A) & Den(o,A).p in B &
      o = In(4, dom the charact of A); then
      consider a,b being set such that
07:   a in the carrier of A & b in the carrier of A & p = <*a,b*>
      by 05,CATALG_1:10;
      reconsider a,b as Element of A by 07;
      Den(o,A).p = while(a,b) by 06,07;
      hence contradiction by 06,Th0D;
    end;
    <*C,I*> in dom Den(In(4, dom the charact of A),A) by 05,CATALG_1:10; then
    rng <*C,I*> c= B|^i by 00,02,03,04,Free5; then
    {C,I} c= B|^i by FINSEQ_2:147;
    hence thesis by ZFMISC_1:38;
  end;

begin :: Existence and uniqueness of execution function and termination

scheme IndDef {A() -> free ECIW-strict preIfWhileAlgebra,
  S() -> non empty set,
  Emp() -> (Element of S()),
  ElemF(set) -> set,
  ConF, WhiF(set,set) -> (Element of S()),
  IfF(set,set,set) -> Element of S()}:
  ex f being Function of the carrier of A(), S() st
   (for I being Element of A() st I in ElementaryInstructions A()
     holds f.I = ElemF(I)) &
   f.EmptyIns A() = Emp() &
   (for I1,I2 being Element of A() holds f.(I1\;I2) = ConF(f.I1,f.I2)) &
   (for C,I1,I2 being Element of A()
     holds f.if-then-else(C,I1,I2) = IfF(f.C,f.I1,f.I2)) &
   (for C,I being Element of A() holds f.while(C,I) = WhiF(f.C,f.I))
  provided
A: for I being Element of A() st I in ElementaryInstructions A()
     holds ElemF(I) in S()
  proof
    set B = ElementaryInstructions A();
Z0: B|^0 = B by ThA0;
    set FB = {[I,ElemF(I)] where I is Element of A(): I in B};
    deffunc CF(Nat,set) = {[I1\;I2, ConF(fI1,fI2)]
    where I1,I2 is (Element of A()),fI1,fI2 is Element of S():
    I1 in B|^$1 & I2 in B|^$1 & [I1,fI1] in $2 & [I2,fI2] in $2};
    deffunc IF(Nat,set) = {[if-then-else(C,I1,I2), IfF(fC,fI1,fI2)]
    where C,I1,I2 is (Element of A()),fC,fI1,fI2 is (Element of S()):
    C in B|^$1 & I1 in B|^$1 & I2 in B|^$1 &
    [C,fC] in $2 & [I1,fI1] in $2 & [I2,fI2] in $2};
    deffunc WF(Nat,set) = {[while(C,I), WhiF(gC,gI)]
    where C,I is (Element of A()),gC,gI is Element of S():
    C in B|^$1 & I in B|^$1 & [C,gC] in $2 & [I,gI] in $2};
    deffunc F(Nat,set) = $2 \/ {[EmptyIns A(), Emp()]} \/
    CF($1,$2) \/ IF($1,$2) \/ WF($1,$2);
    consider FF being Function such that
A0: dom FF = NAT & FF.0 = FB and
A1: for n being Element of NAT holds FF.(n+1) = F(n,FF.n) from RECDEF_1:sch 3;
    set f = Union FF;
A2: for n,m being Nat st n <= m holds FF.n c= FF.m
    proof
      let n,m be Nat;
      assume n <= m; then
      consider i being Nat such that
00:   m = n+i by NAT_1:10;
      reconsider i as Element of NAT by ORDINAL1:def 13;
0A:   m = n+i by 00;
      defpred I[Nat] means FF.n c= FF.(n+$1);
01:   I[0];
02:   now let i be Element of NAT;
        reconsider n' =n as Element of NAT by ORDINAL1:def 13;
        FF.(n'+i+1) = F(n'+i, FF.(n'+i)) by A1
        .= FF.(n+i) \/ {[EmptyIns A(), Emp()]} \/ CF(n+i, FF.(n+i)) \/
        (IF(n+i, FF.(n+i)) \/ WF(n+i, FF.(n+i))) by XBOOLE_1:4
        .= FF.(n+i) \/ {[EmptyIns A(), Emp()]} \/ (CF(n+i, FF.(n+i)) \/
        (IF(n+i, FF.(n+i)) \/ WF(n+i, FF.(n+i)))) by XBOOLE_1:4
        .= FF.(n+i) \/ ({[EmptyIns A(), Emp()]} \/ (CF(n+i, FF.(n+i)) \/
        (IF(n+i, FF.(n+i)) \/ WF(n+i, FF.(n+i))))) by XBOOLE_1:4; then
        FF.(n+i) c= FF.(n+i+1) by XBOOLE_1:7;
        hence I[i] implies I[i+1] by XBOOLE_1:1;
      end;
      for i being Element of NAT holds I[i] from NAT_1:sch 1(01,02);
      hence FF.n c= FF.m by 0A;
    end;
    defpred P[Nat] means
    ex g being Function of B|^$1, S() st g = FF.$1 &
    (EmptyIns A() in B|^$1 implies g.EmptyIns A() = Emp()) &
    (for I1,I2 being Element of A() st I1\;I2 in B|^$1
    holds g.(I1\;I2) = ConF(g.I1,g.I2)) &
    (for C,I1,I2 being Element of A() st if-then-else(C,I1,I2) in B|^$1
    holds g.if-then-else(C,I1,I2) = IfF(g.C,g.I1,g.I2)) &
    (for C,I being Element of A() st while(C,I) in B|^$1
    holds g.while(C,I) = WhiF(g.C,g.I));
    defpred p[set] means $1 in B;
    reconsider f0 = {[I,ElemF(I)] where I is Element of A(): p[I]} as Function
    from ALTCAT_2:sch 1;
B0: dom f0 = B
    proof
      thus dom f0 c= B
      proof
        let x be set; assume x in dom f0; then
        [x,f0.x] in f0 by FUNCT_1:def 4; then
        ex I being Element of A() st [x,f0.x] = [I,ElemF(I)] & p[I];
        hence thesis by ZFMISC_1:33;
      end;
      let x be set; assume
01:   x in B; then
      reconsider I = x as Element of A();
      [I,ElemF(I)] in f0 by 01;
      hence thesis by RELAT_1:def 4;
    end;
    rng f0 c= S()
    proof
      let y be set;
      assume y in rng f0; then
      consider x being set such that
01:   [x,y] in f0 by RELAT_1:def 5;
      consider I being Element of A() such that
02:   [x,y] = [I,ElemF(I)] & p[I] by 01;
      y = ElemF(I) by 02,ZFMISC_1:33;
      hence thesis by A,02;
    end; then
    reconsider f0 as Function of B|^0, S() by Z0,B0,FUNCT_2:4;
B1: P[0]
    proof
      take f0; thus f0 = FF.0 by A0;
      now let I1,I2 be Element of A();
        I1\;I2 <> I1 & I1\;I2 <> I2 by ThFC;
        hence I1\;I2 nin B by Th0B;
      end;
      hence thesis by Z0,Th0A,Th0C,Th0D;
    end;
B2: for i being Element of NAT st P[i] holds P[i+1]
    proof
      let i be Element of NAT;
      given g being Function of B|^i, S() such that
00:   g = FF.i &
      (EmptyIns A() in B|^i implies g.EmptyIns A() = Emp()) &
      (for I1,I2 being Element of A() st I1\;I2 in B|^i
      holds g.(I1\;I2) = ConF(g.I1,g.I2)) &
      (for C,I1,I2 being Element of A() st if-then-else(C,I1,I2) in B|^i
      holds g.if-then-else(C,I1,I2) = IfF(g.C,g.I1,g.I2)) &
      (for C,I being Element of A() st while(C,I) in B|^i
      holds g.while(C,I) = WhiF(g.C,g.I));
      set h = FF.(i+1);
      i < i+1 by NAT_1:13; then
01:   h = F(i, g) & dom g = B|^i & B|^i c= B|^(i+1)
      by A1,00,ThA3,FUNCT_2:def 1;
02:   now
        let x be set;
        assume x in h; then
        x in g \/ {[EmptyIns A(), Emp()]} \/ CF(i, g) \/ IF(i, g) or
        x in WF(i, g) by 01,XBOOLE_0:def 2; then
        x in g \/ {[EmptyIns A(), Emp()]} \/ CF(i, g) or x in IF(i, g) or
        x in WF(i, g) by XBOOLE_0:def 2; then
        x in g \/ {[EmptyIns A(), Emp()]} or x in CF(i,g) or x in IF(i, g) or
        x in WF(i, g) by XBOOLE_0:def 2;
        hence x in g or x in {[EmptyIns A(), Emp()]} or x in CF(i,g) or
        x in IF(i, g) or x in WF(i, g) by XBOOLE_0:def 2;
      end;
      h is Relation-like
      proof
        let x be set;
        assume x in h; then
        x in g or x in {[EmptyIns A(), Emp()]} or
        x in CF(i,g) or x in IF(i,g) or x in WF(i,g) by 02; then
        (ex a,b being set st x = [a,b]) or x = [EmptyIns A(), Emp()] or
        (ex I1,I2 being (Element of A()), fI1,fI2 being Element of S() st
        x = [I1\;I2, ConF(fI1,fI2)] & I1 in B|^i & I2 in B|^i &
        [I1,fI1] in g & [I2,fI2] in g) or
        (ex C,I1,I2 being (Element of A()),a,b,c being Element of S() st
        x = [if-then-else(C,I1,I2), IfF(a,b,c)] & C in B|^i & I1 in B|^i &
        I2 in B|^i & [C,a] in g & [I1,b] in g & [I2,c] in g) or
        (ex C,I being (Element of A()), a,b being Element of S() st
        x = [while(C,I), WhiF(a,b)] & C in B|^i & I in B|^i & [C,a] in g &
        [I,b] in g) by RELAT_1:def 1;
        hence thesis;
      end; then
      reconsider h as Relation;
      h is Function-like
      proof
        let x,y1,y2 be set; set x1 = [x,y1], x2 = [x,y2];
        assume
03:     [x,y1] in h;
        assume
04:     [x,y2] in h;
        per cases by 02,03;
        suppose
C1:       x1 in g; then
05:       x in dom g & y1 = g.x by FUNCT_1:8;
          per cases by 02,04;
          suppose x2 in g;
            hence thesis by C1,FUNCT_1:def 1;
          end;
          suppose x2 in {[EmptyIns A(), Emp()]}; then
            x2 = [EmptyIns A(), Emp()] by TARSKI:def 1; then
            x = EmptyIns A() & y2 = Emp() by ZFMISC_1:33;
            hence thesis by 00,05;
          end;
          suppose x2 in CF(i,g); then
            consider J1,J2 being (Element of A()), gJ1,gJ2 being Element of S()
            such that
C13:        x2 = [J1\;J2, ConF(gJ1,gJ2)] & J1 in B|^i & J2 in B|^i &
            [J1,gJ1] in g & [J2,gJ2] in g;
            x = J1\;J2 & y2 = ConF(gJ1,gJ2) & g.J1 = gJ1 & g.J2 = gJ2
            by C13,ZFMISC_1:33,FUNCT_1:8;
            hence thesis by 00,05;
          end;
          suppose x2 in IF(i,g); then
            consider D,J1,J2 being (Element of A()), a,b,c being Element of S()
            such that
C14:        x2 = [if-then-else(D,J1,J2), IfF(a,b,c)] & D in B|^i & J1 in B|^i &
            J2 in B|^i & [D,a] in g & [J1,b] in g & [J2,c] in g;
            x = if-then-else(D,J1,J2) & y2 = IfF(a,b,c) & g.D = a & g.J1 = b &
            g.J2 = c by C14,ZFMISC_1:33,FUNCT_1:8;
            hence thesis by 00,05;
          end;
          suppose x2 in WF(i,g); then
            consider D,J being (Element of A()), a,b being Element of S()
            such that
C15:        x2 = [while(D,J), WhiF(a,b)] & D in B|^i & J in B|^i & [D,a] in g &
            [J,b] in g;
            x = while(D,J) & y2 = WhiF(a,b) & g.D = a & g.J = b
            by C15,ZFMISC_1:33,FUNCT_1:8;
            hence thesis by 00,05;
          end;
        end;
        suppose x1 in {[EmptyIns A(), Emp()]}; then
c2:       x1 = [EmptyIns A(), Emp()] by TARSKI:def 1; then
C2:       x = EmptyIns A() & y1 = Emp() by ZFMISC_1:33;
          per cases by 02,04;
          suppose x2 in g; then
            x in dom g & y2 = g.x by FUNCT_1:8;
            hence thesis by C2,00;
          end;
          suppose x2 in {[EmptyIns A(), Emp()]}; then
            x2 = [EmptyIns A(), Emp()] by TARSKI:def 1;
            hence thesis by c2,ZFMISC_1:33;
          end;
          suppose x2 in CF(i,g); then
            consider J1,J2 being (Element of A()), a,b being Element of S()
            such that
C23:        x2 = [J1\;J2, ConF(a,b)] & J1 in B|^i & J2 in B|^i &
            [J1,a] in g & [J2,b] in g;
            x = J1\;J2 by C23,ZFMISC_1:33;
            hence thesis by C2,ThFE;
          end;
          suppose x2 in IF(i,g); then
            consider D,J1,J2 being (Element of A()),a,b,c being Element of S()
            such that
C24:        x2 = [if-then-else(D,J1,J2), IfF(a,b,c)] & D in B|^i & J1 in B|^i &
            J2 in B|^i & [D,a] in g & [J1,b] in g & [J2,c] in g;
            x = if-then-else(D,J1,J2) by C24,ZFMISC_1:33;
            hence thesis by C2,DEG;
          end;
          suppose x2 in WF(i,g); then
            consider D,J being (Element of A()),a,b being Element of S()
            such that
C25:        x2 = [while(D,J), WhiF(a,b)] & D in B|^i & J in B|^i & [D,a] in g &
            [J,b] in g;
            x = while(D,J) by C25,ZFMISC_1:33;
            hence thesis by C2,DEG;
          end;
        end;
        suppose x1 in CF(i,g); then
          consider I1,I2 being (Element of A()), gI1,gI2 being Element of S()
          such that
C3:       x1 = [I1\;I2, ConF(gI1,gI2)] & I1 in B|^i & I2 in B|^i &
          [I1,gI1] in g & [I2,gI2] in g;
D3:       x = I1\;I2 & y1 = ConF(gI1,gI2) & g.I1 = gI1 & g.I2 = gI2
          by C3,ZFMISC_1:33,FUNCT_1:8;
          per cases by 02,04;
          suppose x2 in g; then
            x in dom g & y2 = g.x by FUNCT_1:8;
            hence thesis by D3,00;
          end;
          suppose x2 in {[EmptyIns A(), Emp()]}; then
            x2 = [EmptyIns A(), Emp()] by TARSKI:def 1; then
            x = EmptyIns A() & y2 = Emp() by ZFMISC_1:33;
            hence thesis by D3,ThFE;
          end;
          suppose x2 in CF(i,g); then
            consider J1,J2 being (Element of A()), a,b being Element of S()
            such that
C33:        x2 = [J1\;J2, ConF(a,b)] & J1 in B|^i & J2 in B|^i & [J1,a] in g &
            [J2,b] in g;
D33:        x = J1\;J2 & y2 = ConF(a,b) & g.J1 = a & g.J2 = b
            by C33,ZFMISC_1:33,FUNCT_1:8; then
            I1 = J1 & I2 = J2 by D3,ThFC;
            hence thesis by D3,D33;
          end;
          suppose x2 in IF(i,g); then
            consider D,J1,J2 being (Element of A()),a,b,c being Element of S()
            such that
C34:        x2 = [if-then-else(D,J1,J2), IfF(a,b,c)] & D in B|^i &
            J1 in B|^i & J2 in B|^i & [D,a] in g & [J1,b] in g & [J2,c] in g;
            x = if-then-else(D,J1,J2) by C34,ZFMISC_1:33;
            hence thesis by D3,ThFC;
          end;
          suppose x2 in WF(i,g); then
            consider D,J being (Element of A()),a,b being Element of S()
            such that
C35:        x2 = [while(D,J), WhiF(a,b)] & D in B|^i & J in B|^i &
            [D,a] in g & [J,b] in g;
            x = while(D,J) by C35,ZFMISC_1:33;
            hence thesis by D3,ThFC;
          end;
        end;
        suppose x1 in IF(i,g); then
          consider C,I1,I2 being (Element of A()), gC,gI1,gI2 being
          Element of S() such that
C4:       x1 = [if-then-else(C,I1,I2), IfF(gC,gI1,gI2)] & C in B|^i &
          I1 in B|^i & I2 in B|^i & [C,gC] in g & [I1,gI1] in g &
          [I2,gI2] in g;
D4:       x = if-then-else(C,I1,I2) & y1 = IfF(gC,gI1,gI2) & g.I1 = gI1 &
          g.I2 = gI2 & g.C = gC by C4,ZFMISC_1:33,FUNCT_1:8;
          per cases by 02,04;
          suppose x2 in g; then
            x in dom g & y2 = g.x by FUNCT_1:8;
            hence thesis by D4,00;
          end;
          suppose x2 in {[EmptyIns A(), Emp()]}; then
            x2 = [EmptyIns A(), Emp()] by TARSKI:def 1; then
            x = EmptyIns A() & y2 = Emp() by ZFMISC_1:33;
            hence thesis by D4,ThFE;
          end;
          suppose x2 in CF(i,g); then
            consider J1,J2 being (Element of A()),a,b being Element of S()
            such that
C43:        x2 = [J1\;J2, ConF(a,b)] & J1 in B|^i & J2 in B|^i &
            [J1,a] in g & [J2,b] in g;
            x = J1\;J2 by C43,ZFMISC_1:33;
            hence thesis by D4,ThFC;
          end;
          suppose x2 in IF(i,g); then
            consider D,J1,J2 being (Element of A()),a,b,c being Element of S()
            such that
C44:        x2 = [if-then-else(D,J1,J2), IfF(a,b,c)] & D in B|^i &
            J1 in B|^i & J2 in B|^i & [D,a] in g & [J1,b] in g & [J2,c] in g;
D44:        x = if-then-else(D,J1,J2) & y2 = IfF(a,b,c) & g.D = a & g.J1 = b &
            g.J2 = c by C44,ZFMISC_1:33,FUNCT_1:8; then
            C = D & I1 = J1 & I2 = J2 by D4,ThFI;
            hence thesis by D4,D44;
          end;
          suppose x2 in WF(i,g); then
            consider D,J being (Element of A()),a,b being Element of S()
            such that
C45:        x2 = [while(D,J), WhiF(a,b)] & D in B|^i & J in B|^i &
            [D,a] in g & [J,b] in g;
            x = while(D,J) by C45,ZFMISC_1:33;
            hence thesis by D4,ThFI;
          end;
        end;
        suppose x1 in WF(i,g); then
          consider C,I being (Element of A()), gC,gI being Element of S()
          such that
C5:       x1 = [while(C,I), WhiF(gC,gI)] & C in B|^i & I in B|^i &
          [C,gC] in g & [I,gI] in g;
D5:       x = while(C,I) & y1 = WhiF(gC,gI) & g.C = gC & g.I = gI
          by C5,ZFMISC_1:33,FUNCT_1:8;
          per cases by 02,04;
          suppose x2 in g; then
            x in dom g & y2 = g.x by FUNCT_1:8;
            hence thesis by D5,00;
          end;
          suppose x2 in {[EmptyIns A(), Emp()]}; then
            x2 = [EmptyIns A(), Emp()] by TARSKI:def 1; then
            x = EmptyIns A() & y2 = Emp() by ZFMISC_1:33;
            hence thesis by D5,ThFE;
          end;
          suppose x2 in CF(i,g); then
            consider J1,J2 being (Element of A()),a,b being Element of S()
            such that
C53:        x2 = [J1\;J2, ConF(a,b)] & J1 in B|^i & J2 in B|^i &
            [J1,a] in g & [J2,b] in g;
            x = J1\;J2 by C53,ZFMISC_1:33;
            hence thesis by D5,ThFC;
          end;
          suppose x2 in IF(i,g); then
            consider D,J1,J2 being (Element of A()), a,b,c being Element of S()
            such that
C54:        x2 = [if-then-else(D,J1,J2), IfF(a,b,c)] & D in B|^i &
            J1 in B|^i & J2 in B|^i & [D,a] in g & [J1,b] in g & [J2,c] in g;
            x = if-then-else(D,J1,J2) by C54,ZFMISC_1:33;
            hence thesis by D5,ThFI;
          end;
          suppose x2 in WF(i,g); then
            consider D,J being (Element of A()),a,b being Element of S()
            such that
C55:        x2 = [while(D,J), WhiF(a,b)] & D in B|^i & J in B|^i &
            [D,a] in g & [J,b] in g;
D55:        x = while(D,J) & y2 = WhiF(a,b) & g.D = a & g.J = b
            by C55,ZFMISC_1:33,FUNCT_1:8; then
            D = C & J = I by D5,ThFW;
            hence thesis by D5,D55;
          end;
        end;
      end; then
      reconsider h as Function;
D1:   dom h = B|^(i+1)
      proof
        thus dom h c= B|^(i+1)
        proof
          let a be set; set ah = [a,h.a];
          assume a in dom h; then
03:       [a,h.a] in h by FUNCT_1:def 4;
          per cases by 02,03;
          suppose ah in g; then
            a in dom g by FUNCT_1:8;
            hence a in B|^(i+1) by 01;
          end;
          suppose ah in {[EmptyIns A(), Emp()]}; then
            ah = [EmptyIns A(), Emp()] by TARSKI:def 1; then
            a = EmptyIns A() by ZFMISC_1:33;
            hence thesis by ThA7;
          end;
          suppose ah in CF(i,g); then
            consider I,J being (Element of A()),e,b being Element of S() such
            that
04:         ah = [I\;J, ConF(e,b)] & I in B|^i & J in B|^i & [I,e] in g &
            [J,b] in g;
            a = I\;J by 04,ZFMISC_1:33;
            hence thesis by 04,ThA7;
          end;
          suppose ah in IF(i,g); then
            consider C,I,J being (Element of A()),e,b,c being Element of S()
            such that
04:         ah = [if-then-else(C,I,J), IfF(e,b,c)] & C in B|^i & I in B|^i &
            J in B|^i & [C,e] in g & [I,b] in g & [J,c] in g;
            a = if-then-else(C,I,J) by 04,ZFMISC_1:33;
            hence thesis by 04,ThA7;
          end;
          suppose ah in WF(i,g); then
            consider I,J being (Element of A()),e,b being Element of S() such
            that
04:         ah = [while(I,J), WhiF(e,b)] & I in B|^i & J in B|^i & [I,e] in g &
            [J,b] in g;
            a = while(I,J) by 04,ZFMISC_1:33;
            hence thesis by 04,ThA7;
          end;
        end;
        let x be set; assume
05:     x in B|^(i+1);
        per cases by 05,ThA5;
        suppose x in B|^i; then
          [x,g.x] in g by 01,FUNCT_1:def 4; then
          [x,g.x] in g \/ {[EmptyIns A(), Emp()]} by XBOOLE_0:def 2; then
          [x,g.x] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g)
          by XBOOLE_0:def 2; then
          [x,g.x] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g) \/ IF(i,g)
          by XBOOLE_0:def 2; then
          [x,g.x] in h by 01,XBOOLE_0:def 2;
          hence thesis by RELAT_1:def 4;
        end;
        suppose x = EmptyIns A(); then
          [x,Emp()] in {[EmptyIns A(), Emp()]} by TARSKI:def 1; then
          [x,Emp()] in g \/ {[EmptyIns A(), Emp()]} by XBOOLE_0:def 2; then
          [x,Emp()] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g)
          by XBOOLE_0:def 2; then
          [x,Emp()] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g) \/ IF(i,g)
          by XBOOLE_0:def 2; then
          [x,Emp()] in h by 01,XBOOLE_0:def 2;
          hence thesis by RELAT_1:def 4;
        end;
        suppose
          ex I1,I2 being Element of A() st x = I1\;I2 &
          I1 in B|^i & I2 in B|^i; then
          consider I1,I2 being Element of A() such that
06:       x = I1\;I2 & I1 in B|^i & I2 in B|^i;
          reconsider a = g.I1, b = g.I2 as Element of S() by 06,FUNCT_2:7;
          [I1,a] in g & [I2,b] in g by 01,06,FUNCT_1:def 4; then
          [x,ConF(a,b)] in CF(i,g) by 06; then
          [x,ConF(a,b)] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g)
          by XBOOLE_0:def 2; then
          [x,ConF(a,b)] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g) \/ IF(i,g)
          by XBOOLE_0:def 2; then
          [x,ConF(a,b)] in h by 01,XBOOLE_0:def 2;
          hence thesis by RELAT_1:def 4;
        end;
        suppose
          ex C,I1,I2 being Element of A() st x = if-then-else(C,I1,I2) &
          C in B|^i & I1 in B|^i & I2 in B|^i; then
          consider C,I1,I2 being Element of A() such that
07:       x = if-then-else(C,I1,I2) & C in B|^i & I1 in B|^i & I2 in B|^i;
          reconsider a = g.I1, b = g.I2, c = g.C as Element of S()
          by 07,FUNCT_2:7;
          [I1,a] in g & [I2,b] in g & [C,c] in g by 01,07,FUNCT_1:def 4; then
          [x,IfF(c,a,b)] in IF(i,g) by 07; then
          [x,IfF(c,a,b)] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g) \/ IF(i,g)
          by XBOOLE_0:def 2; then
          [x,IfF(c,a,b)] in h by 01,XBOOLE_0:def 2;
          hence thesis by RELAT_1:def 4;
        end;
        suppose
          ex C,I being Element of A() st
          x = while(C,I) & C in B|^i & I in B|^i; then
          consider C,I being Element of A() such that
08:       x = while(C,I) & C in B|^i & I in B|^i;
          reconsider a = g.C, b = g.I as Element of S() by 08,FUNCT_2:7;
          [C,a] in g & [I,b] in g by 01,08,FUNCT_1:def 4; then
          [x,WhiF(a,b)] in WF(i,g) by 08; then
          [x,WhiF(a,b)] in h by 01,XBOOLE_0:def 2;
          hence thesis by RELAT_1:def 4;
        end;
      end;
      rng h c= S()
      proof
        let a be set;
        assume a in rng h; then
        consider x being set such that
03:     [x,a] in h by RELAT_1:def 5;
        set ah = [x,a];
        per cases by 02,03;
        suppose ah in g;
          hence a in S() by ZFMISC_1:106;
        end;
        suppose ah in {[EmptyIns A(), Emp()]}; then
          ah = [EmptyIns A(), Emp()] by TARSKI:def 1; then
          a = Emp() by ZFMISC_1:33;
          hence thesis;
        end;
        suppose ah in CF(i,g); then
          consider I,J being (Element of A()),e,b being Element of S() such
          that
04:       ah = [I\;J, ConF(e,b)] & I in B|^i & J in B|^i & [I,e] in g &
          [J,b] in g;
          a = ConF(e,b) by 04,ZFMISC_1:33;
          hence thesis;
        end;
        suppose ah in IF(i,g); then
          consider C,I,J being (Element of A()),e,b,c being Element of S()
          such that
04:       ah = [if-then-else(C,I,J), IfF(e,b,c)] & C in B|^i & I in B|^i &
          J in B|^i & [C,e] in g & [I,b] in g & [J,c] in g;
          a = IfF(e,b,c) by 04,ZFMISC_1:33;
          hence thesis;
        end;
        suppose ah in WF(i,g); then
          consider I,J being (Element of A()),e,b being Element of S() such
          that
04:       ah = [while(I,J), WhiF(e,b)] & I in B|^i & J in B|^i & [I,e] in g &
          [J,b] in g;
          a = WhiF(e,b) by 04,ZFMISC_1:33;
          hence thesis;
        end;
      end; then
      reconsider h as Function of B|^(i+1), S() by D1,FUNCT_2:4;
      h = g\/{[EmptyIns A(), Emp()]}\/CF(i,g)\/(IF(i,g)\/WF(i,g))
      by 01,XBOOLE_1:4
      .= g\/{[EmptyIns A(), Emp()]}\/(CF(i,g)\/(IF(i,g)\/WF(i,g)))
      by XBOOLE_1:4
      .= g\/({[EmptyIns A(), Emp()]}\/(CF(i,g)\/(IF(i,g)\/WF(i,g))))
      by XBOOLE_1:4; then
0A:   g c= h by XBOOLE_1:7;
      take h; thus h = FF.(i+1);
      hereby set x = EmptyIns A(); assume x in B|^(i+1);
        [x,Emp()] in {[EmptyIns A(), Emp()]} by TARSKI:def 1; then
        [x,Emp()] in g \/ {[EmptyIns A(), Emp()]} by XBOOLE_0:def 2; then
        [x,Emp()] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g)
        by XBOOLE_0:def 2; then
        [x,Emp()] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g) \/ IF(i,g)
        by XBOOLE_0:def 2; then
        [x,Emp()] in h by 01,XBOOLE_0:def 2;
        hence h.EmptyIns A() = Emp() by FUNCT_1:8;
      end;
      hereby let I1,I2 be Element of A();
        set x = I1\;I2; set y = ConF(h.I1,h.I2);
        assume I1\;I2 in B|^(i+1); then
        consider i0 being Nat such that
04:     i+1 = i0+1 & I1 in B|^i0 & I2 in B|^i0 by ThA9C;
        reconsider gI1 = g.I1, gI2 = g.I2 as Element of S() by 04,FUNCT_2:7;
06:     [I1,gI1] in g & [I2,gI2] in g by 01,04,FUNCT_1:def 4; then
        g.I1 = h.I1 & g.I2 = h.I2 by 0A,FUNCT_1:8; then
        [x,y] in CF(i,g) by 04,06; then
        [x,y] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g)
        by XBOOLE_0:def 2; then
        [x,y] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g) \/ IF(i,g)
        by XBOOLE_0:def 2; then
        [x,y] in h by 01,XBOOLE_0:def 2;
        hence h.(I1\;I2) = ConF(h.I1,h.I2) by FUNCT_1:8;
      end;
      hereby let C,I1,I2 be Element of A();
        set x = if-then-else(C,I1,I2); set y = IfF(h.C,h.I1,h.I2);
        assume if-then-else(C,I1,I2) in B|^(i+1); then
        consider i0 being Nat such that
04:     i+1 = i0+1 & C in B|^i0 & I1 in B|^i0 & I2 in B|^i0 by ThA9I;
        reconsider gC = g.C, gI1 = g.I1, gI2 = g.I2 as Element of S()
        by 04,FUNCT_2:7;
06:     [C,gC] in g & [I1,gI1] in g & [I2,gI2] in g
        by 01,04,FUNCT_1:def 4; then
        g.C = h.C & g.I1 = h.I1 & g.I2 = h.I2 by 0A,FUNCT_1:8; then
        [x,y] in IF(i,g) by 04,06; then
        [x,y] in g \/ {[EmptyIns A(), Emp()]} \/ CF(i,g) \/ IF(i,g)
        by XBOOLE_0:def 2; then
        [x,y] in h by 01,XBOOLE_0:def 2;
        hence h.if-then-else(C,I1,I2) = IfF(h.C,h.I1,h.I2) by FUNCT_1:8;
      end;
      let C,I be Element of A();
      set x = while(C,I); set y = WhiF(h.C,h.I);
      assume while(C,I) in B|^(i+1); then
      consider i0 being Nat such that
04:   i+1 = i0+1 & C in B|^i0 & I in B|^i0 by ThA9W;
      reconsider gC = g.C, gI = g.I as Element of S() by 04,FUNCT_2:7;
06:   [C,gC] in g & [I,gI] in g by 01,04,FUNCT_1:def 4; then
      g.C = h.C & g.I = h.I by 0A,FUNCT_1:8; then
      [x,y] in WF(i,g) by 04,06; then
      [x,y] in h by 01,XBOOLE_0:def 2;
      hence h.while(C,I) = WhiF(h.C,h.I) by FUNCT_1:8;
    end;
B3: for i being Element of NAT holds P[i] from NAT_1:sch 1(B1,B2);
    f is Relation-like Function-like
    proof
      hereby let x be set;
        assume x in f; then
        consider n being set such that
C1:     n in dom FF & x in FF.n by CARD_5:10;
        reconsider n as Element of NAT by A0,C1;
        P[n] by B3;
        hence ex a,b being set st x = [a,b] by C1,RELAT_1:def 1;
      end;
      let x,y1,y2 be set;
      assume [x,y1] in f; then
      consider n1 being set such that
C1:   n1 in dom FF & [x,y1] in FF.n1 by CARD_5:10;
      assume [x,y2] in f; then
      consider n2 being set such that
C2:   n2 in dom FF & [x,y2] in FF.n2 by CARD_5:10;
      reconsider n1,n2 as Element of NAT by A0,C1,C2;
      n1 <= n2 or n2 <= n1; then
      FF.n1 c= FF.n2 or FF.n2 c= FF.n1 by A2; then
      [x,y1] in FF.n2 & P[n2] or
      [x,y2] in FF.n1 & P[n1] by C1,C2,B3;
      hence y1 = y2 by C1,C2,FUNCT_1:def 1;
    end; then
    reconsider f as Function;
A3: dom f = the carrier of A()
    proof
      thus dom f c= the carrier of A()
      proof let x be set;
        assume x in dom f; then
        [x,f.x] in f by FUNCT_1:def 4; then
        consider n being set such that
01:     n in dom FF & [x,f.x] in FF.n by CARD_5:10;
        reconsider n as Element of NAT by A0,01;
        P[n] by B3; then
        x in B|^n by 01,ZFMISC_1:106;
        hence thesis;
      end;
      let x be set; assume x in the carrier of A(); then
      reconsider I = x as Element of A();
      consider n being Nat such that
01:   I in B|^n by ThA6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
      P[n] by B3; then
      reconsider g = FF.n as Function of B|^n, S();
      dom g = B|^n by FUNCT_2:def 1; then
      [I,g.I] in g by 01,FUNCT_1:def 4; then
      [I,g.I] in f by A0,CARD_5:10;
      hence x in dom f by RELAT_1:def 4;
    end;
    rng f c= S()
    proof
      let b be set; assume b in rng f; then
      consider a being set such that
01:   a in dom f & b = f.a by FUNCT_1:def 5;
      reconsider a as Element of A() by A3,01;
      consider n being Nat such that
02:   a in B|^n by ThA6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
      P[n] by B3; then
      reconsider g = FF.n as Function of B|^n, S();
03:   dom g = B|^n by FUNCT_2:def 1; then
      [a,g.a] in g by 02,FUNCT_1:def 4; then
      [a,g.a] in f by A0,CARD_5:10; then
      b = g.a & g.a in rng g & rng g c= S()
      by 01,02,03,FUNCT_1:8,12;
      hence b in S();
    end; then
    reconsider f as Function of the carrier of A(), S() by A3,FUNCT_2:4;
    take f;
    hereby let I be Element of A(); assume
      I in ElementaryInstructions A(); then
      [I,ElemF(I)] in FF.0 by A0; then
      [I,ElemF(I)] in f by A0,CARD_5:10;
      hence f.I = ElemF(I) by FUNCT_1:8;
    end;
II: now let n be Nat;
      let I be Element of A();
      let g be Function of B|^n, S();
      assume
01:   I in B|^n & g = FF.n;
      dom g = B|^n by FUNCT_2:def 1; then
      [I,g.I] in g & n in NAT by 01,FUNCT_1:def 4,ORDINAL1:def 13; then
      [I,g.I] in f by A0,01,CARD_5:10;
      hence g.I = f.I by FUNCT_1:8;
    end;
    consider n0 being Nat such that
01: EmptyIns A() in B|^n0 by ThA6;
    reconsider n0 as Element of NAT by ORDINAL1:def 13;
    consider g0 being Function of B|^n0, S() such that
02: g0 = FF.n0 & (EmptyIns A() in B|^n0 implies g0.EmptyIns A() = Emp()) and
    (for I1,I2 being Element of A() st I1\;I2 in B|^n0
    holds g0.(I1\;I2) = ConF(g0.I1,g0.I2)) &
    (for C,I1,I2 being Element of A() st if-then-else(C,I1,I2) in B|^n0
    holds g0.if-then-else(C,I1,I2) = IfF(g0.C,g0.I1,g0.I2)) &
    (for C,I being Element of A() st while(C,I) in B|^n0
    holds g0.while(C,I) = WhiF(g0.C,g0.I)) by B3;
    dom g0 = B|^n0 by FUNCT_2:def 1; then
    [EmptyIns A(), Emp()] in g0 by 01,02,FUNCT_1:def 4; then
    [EmptyIns A(), Emp()] in f by A0,02,CARD_5:10;
    hence f.EmptyIns A() = Emp() by FUNCT_1:8;
    hereby let I1,I2 be Element of A();
      consider n0 being Nat such that
01:   I1\;I2 in B|^n0 by ThA6;
      reconsider n0 as Element of NAT by ORDINAL1:def 13;
      consider g0 being Function of B|^n0, S() such that
03:   g0 = FF.n0 and
      (EmptyIns A() in B|^n0 implies g0.EmptyIns A() = Emp()) and
02:   (for I1,I2 being Element of A() st I1\;I2 in B|^n0
      holds g0.(I1\;I2) = ConF(g0.I1,g0.I2)) and
      (for C,I1,I2 being Element of A() st if-then-else(C,I1,I2) in B|^n0
      holds g0.if-then-else(C,I1,I2) = IfF(g0.C,g0.I1,g0.I2)) &
      (for C,I being Element of A() st while(C,I) in B|^n0
      holds g0.while(C,I) = WhiF(g0.C,g0.I)) by B3;
      consider i0 being Nat such that
04:   n0 = i0+1 & I1 in B|^i0 & I2 in B|^i0 by 01,ThA9C;
      n0 > i0 by 04,NAT_1:13; then
      B|^i0 c= B|^n0 by ThA3; then
      dom g0 = B|^n0 & g0.I1 = f.I1 & g0.I2 = f.I2
      by II,03,04,FUNCT_2:def 1; then
      [I1\;I2, g0.(I1\;I2)] in g0 & g0.(I1\;I2) = ConF(f.I1,f.I2)
      by 01,02,FUNCT_1:8; then
      [I1\;I2, ConF(f.I1,f.I2)] in f by A0,03,CARD_5:10;
      hence f.(I1\;I2) = ConF(f.I1,f.I2) by FUNCT_1:8;
    end;
    hereby let C,I1,I2 be Element of A();
      set IF = if-then-else(C,I1,I2);
      consider n0 being Nat such that
01:   IF in B|^n0 by ThA6;
      reconsider n0 as Element of NAT by ORDINAL1:def 13;
      consider g0 being Function of B|^n0, S() such that
03:   g0 = FF.n0 and
      (EmptyIns A() in B|^n0 implies g0.EmptyIns A() = Emp()) and
      (for I1,I2 being Element of A() st I1\;I2 in B|^n0
      holds g0.(I1\;I2) = ConF(g0.I1,g0.I2)) and
02:   (for C,I1,I2 being Element of A() st if-then-else(C,I1,I2) in B|^n0
      holds g0.if-then-else(C,I1,I2) = IfF(g0.C,g0.I1,g0.I2)) and
      (for C,I being Element of A() st while(C,I) in B|^n0
      holds g0.while(C,I) = WhiF(g0.C,g0.I)) by B3;
      consider i0 being Nat such that
04:   n0 = i0+1 & C in B|^i0 & I1 in B|^i0 & I2 in B|^i0 by 01,ThA9I;
      n0 > i0 by 04,NAT_1:13; then
      B|^i0 c= B|^n0 by ThA3; then
      dom g0 = B|^n0 & g0.C = f.C & g0.I1 = f.I1 & g0.I2 = f.I2
      by II,03,04,FUNCT_2:def 1; then
      [IF, g0.IF] in g0 & g0.IF = IfF(f.C,f.I1,f.I2)by 01,02,FUNCT_1:8; then
      [IF, IfF(f.C,f.I1,f.I2)] in f by A0,03,CARD_5:10;
      hence f.if-then-else(C,I1,I2) = IfF(f.C,f.I1,f.I2) by FUNCT_1:8;
    end;
    let C,I be Element of A();
    set WH = while(C,I);
    consider n0 being Nat such that
01: WH in B|^n0 by ThA6;
    reconsider n0 as Element of NAT by ORDINAL1:def 13;
    consider g0 being Function of B|^n0, S() such that
03: g0 = FF.n0 and
    (EmptyIns A() in B|^n0 implies g0.EmptyIns A() = Emp()) and
    (for I1,I2 being Element of A() st I1\;I2 in B|^n0
    holds g0.(I1\;I2) = ConF(g0.I1,g0.I2)) and
    (for C,I1,I2 being Element of A() st if-then-else(C,I1,I2) in B|^n0
    holds g0.if-then-else(C,I1,I2) = IfF(g0.C,g0.I1,g0.I2)) and
02: (for C,I being Element of A() st while(C,I) in B|^n0
    holds g0.while(C,I) = WhiF(g0.C,g0.I)) by B3;
    consider i0 being Nat such that
04: n0 = i0+1 & C in B|^i0 & I in B|^i0 by 01,ThA9W;
    n0 > i0 by 04,NAT_1:13; then
    B|^i0 c= B|^n0 by ThA3; then
    dom g0 = B|^n0 & g0.C = f.C & g0.I = f.I
    by II,03,04,FUNCT_2:def 1; then
    [WH, g0.WH] in g0 & g0.WH = WhiF(f.C,f.I) by 01,02,FUNCT_1:8; then
    [WH, WhiF(f.C,f.I)] in f by A0,03,CARD_5:10;
    hence f.while(C,I) = WhiF(f.C,f.I) by FUNCT_1:8;
  end;

theorem
  for A being free ECIW-strict preIfWhileAlgebra
  for g being Function of [:S, ElementaryInstructions A:], S
  for s0 being Element of S
  ex f being ExecutionFunction of A, S, T
  st f|[:S, ElementaryInstructions A:] = g &
    for s being Element of S
    for C,I being Element of A st not f iteration_terminates_for I\;C, f.(s,C)
    holds f.(s, while(C,I)) = s0
  proof
    let A be free ECIW-strict preIfWhileAlgebra;
    let g be Function of [:S, ElementaryInstructions A:], S;
    let s0 be Element of S;
    reconsider Ss0 = S-->s0 as Element of Funcs(S,S);
    set Z = Funcs(S,S);
    deffunc ElemF(Element of A)
    = (curry' g).$1;
A2: for I being Element of A st I in ElementaryInstructions A
    holds ElemF(I) in Z
    proof
      let I be Element of A;
      assume
A0:   I in ElementaryInstructions A; then
      reconsider B = ElementaryInstructions A as non empty set;
      reconsider I as Element of B by A0;
      reconsider g as Function of [:S,B:],S;
      (curry' g).I is Element of Z;
      hence thesis;
    end;
    reconsider idS = id S as Element of Z by ALTCAT_1:2;
    deffunc ConF((Element of Z), Element of Z)
    = $2*$1 qua Element of Z;
    deffunc IfF((Element of Z), (Element of Z), Element of Z)
    = (($2,T)+*$3)*$1 qua Element of Z;
    deffunc WhiF((Element of Z), Element of Z)
    = ((T,Ss0) iter ($1*$2))*$1 qua Element of Z;
    consider h being Function of the carrier of A, Z such that
A3: for I being Element of A st I in ElementaryInstructions A
    holds h.I = ElemF(I) and
A4: h.EmptyIns A = idS and
A5: for I1,I2 being Element of A holds h.(I1\;I2) = ConF(h.I1,h.I2) and
A6: for C,I1,I2 being Element of A
    holds h.if-then-else(C,I1,I2) = IfF(h.C,h.I1,h.I2) and
A7: for C,I being Element of A holds h.while(C,I) = WhiF(h.C,h.I)
    from IndDef(A2);
    h in Funcs(the carrier of A, Z) by FUNCT_2:11; then
    uncurry' h in Funcs([:S, the carrier of A:], S) by FUNCT_6:20; then
    reconsider f = uncurry' h as Function of [:S, the carrier of A:], S
    by FUNCT_2:121;
B0: dom h = the carrier of A & dom idS = S by FUNCT_2:def 1;
B1: f is satisfying_empty-instruction
    proof
      let s be Element of S;
      idS.s = s by FUNCT_1:35;
      hence f.(s, EmptyIns A) = s by A4,B0,FUNCT_5:46;
    end;
B2: f is satisfying_catenation
    proof
      let s be Element of S;
      let I1,I2 be Element of A;
C1:   dom (h.(I1\;I2)) = S & dom (h.I1) = S & dom (h.I2) = S by FUNCT_2:def 1;
      hence f.(s,I1 \; I2) = (h.(I1\;I2)).s by B0,FUNCT_5:46
      .= ((h.I2)*(h.I1)).s by A5 .= (h.I2).((h.I1).s) by FUNCT_2:21
      .= (h.I2).(f.(s,I1)) by B0,C1,FUNCT_5:46
      .= f.(f.(s,I1),I2) by B0,C1,FUNCT_5:46;
    end;
B3: f satisfies_if_wrt T
    proof
      let s be Element of S;
      let C, I1,I2 be Element of A;
C2:   dom (h.if-then-else(C,I1,I2)) = S & dom (h.C) = S & dom (h.I1) = S &
      dom (h.I2) = S by FUNCT_2:def 1; then
C3:   f.(s,if-then-else(C,I1,I2))
      = (h.if-then-else(C,I1,I2)).s by B0,FUNCT_5:46
      .= IfF(h.C,h.I1,h.I2).s by A6
      .= ((h.I1,T)+*(h.I2)).((h.C).s) by FUNCT_2:21;
C4:   f.(s,C) = (h.C).s by B0,C2,FUNCT_5:46;
      hereby
        assume f.(s,C) in T;
        hence f.(s,if-then-else(C,I1,I2)) = (h.I1).(f.(s,C)) by C2,C3,C4,LemII
        .= f.(f.(s,C),I1) by B0,C2,FUNCT_5:46;
      end;
      assume f.(s,C) nin T;
      hence f.(s,if-then-else(C,I1,I2)) = (h.I2).(f.(s,C)) by C2,C3,C4,LemIII
      .= f.(f.(s,C),I2) by B0,C2,FUNCT_5:46;
    end;
    f satisfies_while_wrt T
    proof
      let s be Element of S;
      let C, I be Element of A;
C2:   dom (h.while(C,I)) = S & dom (h.C) = S & dom (h.I) = S &
      dom ((h.C)*(h.I)) = S by FUNCT_2:def 1; then
C3:   f.(s,while(C,I)) = (h.while(C,I)).s by B0,FUNCT_5:46
      .= WhiF(h.C,h.I).s by A7
      .= ((T,Ss0) iter ((h.C)*(h.I))).((h.C).s) by FUNCT_2:21;
C4:   f.(s,C) = (h.C).s by B0,C2,FUNCT_5:46;
C5:   rng ((h.C)*(h.I)) c= S;
      now let z be Element of S;
        thus (Ss0*((h.C)*(h.I))).z = Ss0.(((h.C)*(h.I)).z) by FUNCT_2:21
        .= s0 by FUNCOP_1:13
        .= Ss0.z by FUNCOP_1:13;
      end; then
C6:   Ss0*((h.C)*(h.I)) = Ss0 by FUNCT_2:113;
      hereby
        assume f.(s,C) in T;
        hence f.(s,while(C,I))
        = ((T,Ss0) iter ((h.C)*(h.I))).(((h.C)*(h.I)).(f.(s,C)))
        by C2,C3,C4,C5,C6,LemWI
        .= ((T,Ss0) iter ((h.C)*(h.I))).((h.C).((h.I).(f.(s,C))))
        by FUNCT_2:21
        .= (((T,Ss0) iter ((h.C)*(h.I)))*(h.C)).((h.I).(f.(s,C)))
        by FUNCT_2:21
        .= (((T,Ss0) iter ((h.C)*(h.I)))*(h.C)).(f.(f.(s,C),I))
        by B0,C2,FUNCT_5:46
        .= (h.while(C,I)).(f.(f.(s,C),I)) by A7
        .= f.(f.(f.(s,C),I),while(C,I)) by B0,C2,FUNCT_5:46;
      end;
      thus thesis by C2,C3,C4,C5,LemWII;
    end; then
    reconsider f as ExecutionFunction of A, S, T by B1,B2,B3,EXEC;
    take f;
    dom f = [:S, the carrier of A:] by FUNCT_2:def 1; then
    [:S, ElementaryInstructions A:] c= dom f by ZFMISC_1:118; then
A9: dom g = [:S, ElementaryInstructions A:] &
    dom f /\ [:S, ElementaryInstructions A:] = [:S, ElementaryInstructions A:]
    by XBOOLE_1:28,FUNCT_2:def 1;
    now
      let a be set; assume
D0:   a in dom g; then
      consider s,I being set such that
D1:   s in S & I in ElementaryInstructions A & a = [s,I] by ZFMISC_1:def 2;
      reconsider s as Element of S by D1;
      reconsider I as Element of A by D1;
      reconsider EI = (curry' g).I as Element of Z by D1,A2;
      g in Funcs([:S, ElementaryInstructions A:], S) by FUNCT_2:11; then
      curry' g in Funcs(ElementaryInstructions A, Z) by D0,FUNCT_6:19; then
D2:   dom curry' g = ElementaryInstructions A & dom EI = S & dom (h.I) = S
      by FUNCT_2:169;
      thus g.a = g.(s,I) by D1 .= EI.s by D1,D2,FUNCT_5:41
      .= (h.I).s by D1,A3 .= f.(s,I) by B0,D2,FUNCT_5:46 .= f.a by D1;
    end;
    hence f|[:S, ElementaryInstructions A:] = g by A9,FUNCT_1:68;
    let s be Element of S;
    let C,I be Element of A;
    assume
00: not f iteration_terminates_for I\;C, f.(s,C);
C2: dom (h.while(C,I)) = S & dom (h.C) = S & dom (h.I) = S &
    dom ((h.C)*(h.I)) = S by FUNCT_2:def 1; then
C3: f.(s,while(C,I)) = (h.while(C,I)).s by B0,FUNCT_5:46
    .= WhiF(h.C,h.I).s by A7
    .= ((T,Ss0) iter ((h.C)*(h.I))).((h.C).s) by FUNCT_2:21;
C4: f.(s,C) = (h.C).s by B0,C2,FUNCT_5:46;
C5: rng ((h.C)*(h.I)) c= S;
    rng h c= Z; then
    h = curry' f by FUNCT_5:55; then
    (curry' f).(I\;C) = (h.C)*(h.I) by A5; then
    (h.C)*(h.I) orbit f.(s,C) c= T by 00,ThTer2;
    hence f.(s, while(C,I)) = Ss0.(f.(s,C))  by C2,C3,C4,C5,ITER2
    .= s0 by FUNCOP_1:13;
  end;

theorem
  for A being free ECIW-strict preIfWhileAlgebra
  for g being Function of [:S, ElementaryInstructions A:], S
  for F being Function of Funcs(S,S), Funcs(S,S)
  st for h being Element of Funcs(S,S) holds (F.h)*h = F.h
  ex f being ExecutionFunction of A, S, T
  st f|[:S, ElementaryInstructions A:] = g &
  for C,I being Element of A
  for s being Element of S st not f iteration_terminates_for I\;C, f.(s, C)
  holds f.(s, while(C, I)) = F.((curry' f).(I\;C)).(f.(s,C))
  proof
    let A be free ECIW-strict preIfWhileAlgebra;
    let g be Function of [:S, ElementaryInstructions A:], S;
    consider s0 being Element of S;
    let F being Function of Funcs(S,S), Funcs(S,S) such that
AF: for h being Element of Funcs(S,S) holds (F.h)*h = F.h;
    set Z = Funcs(S,S);
    deffunc ElemF(Element of A)
    = (curry' g).$1;
A2: for I being Element of A st I in ElementaryInstructions A
    holds ElemF(I) in Z
    proof
      let I be Element of A;
      assume
A0:   I in ElementaryInstructions A; then
      reconsider B = ElementaryInstructions A as non empty set;
      reconsider I as Element of B by A0;
      reconsider g as Function of [:S,B:],S;
      (curry' g).I is Element of Z;
      hence thesis;
    end;
    reconsider idS = id S as Element of Z by ALTCAT_1:2;
    deffunc ConF((Element of Z), Element of Z)
    = $2*$1 qua Element of Z;
    deffunc IfF((Element of Z), (Element of Z), Element of Z)
    = (($2,T)+*$3)*$1 qua Element of Z;
    deffunc WhiF((Element of Z), Element of Z)
    = ((T, F.($1*$2)) iter ($1*$2))*$1 qua Element of Z;

    consider h being Function of the carrier of A, Z such that
A3: for I being Element of A st I in ElementaryInstructions A
    holds h.I = ElemF(I) and
A4: h.EmptyIns A = idS and
A5: for I1,I2 being Element of A holds h.(I1\;I2) = ConF(h.I1,h.I2) and
A6: for C,I1,I2 being Element of A
    holds h.if-then-else(C,I1,I2) = IfF(h.C,h.I1,h.I2) and
A7: for C,I being Element of A holds h.while(C,I) = WhiF(h.C,h.I)
    from IndDef(A2);
    h in Funcs(the carrier of A, Z) by FUNCT_2:11; then
    uncurry' h in Funcs([:S, the carrier of A:], S) by FUNCT_6:20; then
    reconsider f = uncurry' h as Function of [:S, the carrier of A:], S
    by FUNCT_2:121;
B0: dom h = the carrier of A & dom idS = S by FUNCT_2:def 1;
B1: f is satisfying_empty-instruction
    proof
      let s be Element of S;
      idS.s = s by FUNCT_1:35;
      hence f.(s, EmptyIns A) = s by A4,B0,FUNCT_5:46;
    end;
B2: f is satisfying_catenation
    proof
      let s be Element of S;
      let I1,I2 be Element of A;
C1:   dom (h.(I1\;I2)) = S & dom (h.I1) = S & dom (h.I2) = S by FUNCT_2:def 1;
      hence f.(s,I1 \; I2) = (h.(I1\;I2)).s by B0,FUNCT_5:46
      .= ((h.I2)*(h.I1)).s by A5 .= (h.I2).((h.I1).s) by FUNCT_2:21
      .= (h.I2).(f.(s,I1)) by B0,C1,FUNCT_5:46
      .= f.(f.(s,I1),I2) by B0,C1,FUNCT_5:46;
    end;
B3: f satisfies_if_wrt T
    proof
      let s be Element of S;
      let C, I1,I2 be Element of A;
C2:   dom (h.if-then-else(C,I1,I2)) = S & dom (h.C) = S & dom (h.I1) = S &
      dom (h.I2) = S by FUNCT_2:def 1; then
C3:   f.(s,if-then-else(C,I1,I2))
      = (h.if-then-else(C,I1,I2)).s by B0,FUNCT_5:46
      .= IfF(h.C,h.I1,h.I2).s by A6
      .= ((h.I1,T)+*(h.I2)).((h.C).s) by FUNCT_2:21;
C4:   f.(s,C) = (h.C).s by B0,C2,FUNCT_5:46;
      hereby
        assume f.(s,C) in T;
        hence f.(s,if-then-else(C,I1,I2)) = (h.I1).(f.(s,C)) by C2,C3,C4,LemII
        .= f.(f.(s,C),I1) by B0,C2,FUNCT_5:46;
      end;
      assume f.(s,C) nin T;
      hence f.(s,if-then-else(C,I1,I2)) = (h.I2).(f.(s,C)) by C2,C3,C4,LemIII
      .= f.(f.(s,C),I2) by B0,C2,FUNCT_5:46;
    end;
    f satisfies_while_wrt T
    proof
      let s be Element of S;
      let C, I be Element of A;
C2:   dom (h.while(C,I)) = S & dom (h.C) = S & dom (h.I) = S &
      dom ((h.C)*(h.I)) = S by FUNCT_2:def 1; then
C3:   f.(s,while(C,I)) = (h.while(C,I)).s by B0,FUNCT_5:46
      .= WhiF(h.C,h.I).s by A7
      .= ((T,F.((h.C)*(h.I))) iter ((h.C)*(h.I))).((h.C).s) by FUNCT_2:21;
C4:   f.(s,C) = (h.C).s by B0,C2,FUNCT_5:46;
C5:   rng ((h.C)*(h.I)) c= S;
C6:   (F.((h.C)*(h.I)))*((h.C)*(h.I)) = F.((h.C)*(h.I)) by AF;
      hereby
        assume f.(s,C) in T;
        hence f.(s,while(C,I))
        = ((T,F.((h.C)*(h.I))) iter ((h.C)*(h.I))).(((h.C)*(h.I)).(f.(s,C)))
        by C2,C3,C4,C5,C6,LemWI
        .= ((T,F.((h.C)*(h.I))) iter ((h.C)*(h.I))).((h.C).((h.I).(f.(s,C))))
        by FUNCT_2:21
        .= (((T,F.((h.C)*(h.I))) iter ((h.C)*(h.I)))*(h.C)).((h.I).(f.(s,C)))
        by FUNCT_2:21
        .= (((T,F.((h.C)*(h.I))) iter ((h.C)*(h.I)))*(h.C)).(f.(f.(s,C),I))
        by B0,C2,FUNCT_5:46
        .= (h.while(C,I)).(f.(f.(s,C),I)) by A7
        .= f.(f.(f.(s,C),I),while(C,I)) by B0,C2,FUNCT_5:46;
      end;
      thus thesis by C2,C3,C4,C5,LemWII;
    end; then
    reconsider f as ExecutionFunction of A, S, T by B1,B2,B3,EXEC;
    take f;
    dom f = [:S, the carrier of A:] by FUNCT_2:def 1; then
    [:S, ElementaryInstructions A:] c= dom f by ZFMISC_1:118; then
A9: dom g = [:S, ElementaryInstructions A:] &
    dom f /\ [:S, ElementaryInstructions A:] = [:S, ElementaryInstructions A:]
    by XBOOLE_1:28,FUNCT_2:def 1;
    now
      let a be set; assume
D0:   a in dom g; then
      consider s,I being set such that
D1:   s in S & I in ElementaryInstructions A & a = [s,I] by ZFMISC_1:def 2;
      reconsider s as Element of S by D1;
      reconsider I as Element of A by D1;
      reconsider EI = (curry' g).I as Element of Z by D1,A2;
      g in Funcs([:S, ElementaryInstructions A:], S) by FUNCT_2:11; then
      curry' g in Funcs(ElementaryInstructions A, Z) by D0,FUNCT_6:19; then
D2:   dom curry' g = ElementaryInstructions A & dom EI = S & dom (h.I) = S
      by FUNCT_2:169;
      thus g.a = g.(s,I) by D1 .= EI.s by D1,D2,FUNCT_5:41
      .= (h.I).s by D1,A3 .= f.(s,I) by B0,D2,FUNCT_5:46 .= f.a by D1;
    end;
    hence f|[:S, ElementaryInstructions A:] = g by A9,FUNCT_1:68;
    let C,I be Element of A;
    let s be Element of S;
    assume
00: not f iteration_terminates_for I\;C, f.(s,C);
C2: dom (h.while(C,I)) = S & dom (h.C) = S & dom (h.I) = S &
    dom ((h.C)*(h.I)) = S by FUNCT_2:def 1; then
C3: f.(s,while(C,I)) = (h.while(C,I)).s by B0,FUNCT_5:46
    .= WhiF(h.C,h.I).s by A7
    .= ((T,F.((h.C)*(h.I))) iter ((h.C)*(h.I))).((h.C).s) by FUNCT_2:21;
C4: f.(s,C) = (h.C).s by B0,C2,FUNCT_5:46;
C5: rng ((h.C)*(h.I)) c= S;
    rng h c= Z; then
    h = curry' f by FUNCT_5:55; then
C6: (curry' f).(I\;C) = (h.C)*(h.I) by A5; then
    (h.C)*(h.I) orbit f.(s,C) c= T by 00,ThTer2;
    hence f.(s, while(C, I)) = F.((curry' f).(I\;C)).(f.(s,C))
    by C6,C2,C3,C4,C5,ITER2;
  end;

theorem
  for A being free ECIW-strict preIfWhileAlgebra
  for f1,f2 being ExecutionFunction of A, S, T
  st f1|[:S, ElementaryInstructions A:] = f2|[:S, ElementaryInstructions A:] &
     for s being Element of S
     for C,I being Element of A
     st not f1 iteration_terminates_for I\;C, f1.(s,C)
     holds f1.(s, while(C,I)) = f2.(s, while(C,I))
  holds f1 = f2
  proof
    let A be free ECIW-strict preIfWhileAlgebra;
    let f1,f2 be ExecutionFunction of A, S, T;
    assume
A1: f1|[:S, ElementaryInstructions A:] = f2|[:S, ElementaryInstructions A:];
    set g = f1|[:S, ElementaryInstructions A:];
    assume
A2: for s being Element of S
    for C,I being Element of A
    st not f1 iteration_terminates_for I\;C, f1.(s,C)
    holds f1.(s, while(C,I)) = f2.(s, while(C,I));
    defpred P[set] means
    for s being Element of S holds f1.(s, $1) = f2.(s, $1);
B0: for I being Element of A st I in ElementaryInstructions A holds P[I]
    proof
      let I be Element of A such that
00:   I in ElementaryInstructions A;
      let s be Element of S;
01:   [s,I] in [:S, ElementaryInstructions A:] by 00,ZFMISC_1:106;
      hence f1.(s,I) = g.[s,I] by FUNCT_1:72 .= f2.(s,I) by 01,A1,FUNCT_1:72;
    end;
B1: P[EmptyIns A]
    proof
      let s be Element of S;
      thus f1.(s, EmptyIns A) = s by EMP .= f2.(s, EmptyIns A) by EMP;
    end;
B2: for I1,I2 being Element of A st P[I1] & P[I2] holds P[I1\;I2]
    proof
      let I1,I2 be Element of A such that
03:   P[I1] & P[I2];
      let s be Element of S;
      thus f1.(s, I1\;I2) = f1.(f1.(s, I1), I2) by CAT
      .= f1.(f2.(s, I1), I2) by 03
      .= f2.(f2.(s, I1), I2) by 03
      .= f2.(s, I1\;I2) by CAT;
    end;
B3: for C,I1,I2 being Element of A st P[C] & P[I1] & P[I2]
    holds P[if-then-else(C,I1,I2)]
    proof
      let C,I1,I2 be Element of A such that
05:   P[C] & P[I1] & P[I2];
      let s be Element of S;
06:   f1 satisfies_if_wrt T & f2 satisfies_if_wrt T by EXEC;
07:   f1.(s, C) = f2.(s, C) by 05;
      per cases;
      suppose
08:     f1.(s,C) in T;
        hence f1.(s, if-then-else(C,I1,I2)) = f1.(f1.(s, C), I1) by 06,IF
        .= f2.(f1.(s, C), I1) by 05
        .= f2.(s, if-then-else(C,I1,I2)) by 06,07,08,IF;
      end;
      suppose
08:     f1.(s,C) nin T;
        hence f1.(s, if-then-else(C,I1,I2)) = f1.(f1.(s, C), I2) by 06,IF
        .= f2.(f1.(s, C), I2) by 05
        .= f2.(s, if-then-else(C,I1,I2)) by 06,07,08,IF;
      end;
    end;
B4: for C,I being Element of A st P[C] & P[I] holds P[while(C,I)]
    proof
      let C,I be Element of A such that
09:   P[C] & P[I];
      let s be Element of S;
      now assume f1 iteration_terminates_for I\;C, f1.(s,C); then
        consider r being non empty FinSequence of S such that
Z1:     r.1 = f1.(s, C) & r.len r nin T and
Z2:     for i being Nat st 1 <= i & i < len r
        holds r.i in T & r.(i+1) = f1.(r.i, I\;C) by TERMINATION;
Z6:     f1.(s, C) = f2.(s, C) by 09;
Z4:     now
          let i be Nat;
          assume
C2:       1 <= i & i < len r;
          hence r.i in T by Z2; then
          reconsider si = r.i as Element of S;
          thus r.(i+1) = f1.(si, I\;C) by Z2,C2
          .= f1.(f1.(si,I),C) by CAT
          .= f1.(f2.(si,I),C) by 09
          .= f2.(f2.(si,I),C) by 09
          .= f2.(r.i, I\;C) by CAT;
        end;
        thus f1.(s, while(C,I)) = r.len r by Z1,Z2,ThW1
        .= f2.(s, while(C,I)) by Z1,Z4,Z6,ThW1;
      end;
      hence thesis by A2;
    end;
    now
      let sI be Element of [:S, the carrier of A:];
      consider s,I being set such that
C1:   s in S & I in the carrier of A & sI = [s,I] by ZFMISC_1:def 2;
      reconsider I as Element of A by C1;
      reconsider s as Element of S by C1;
      P[I] from StructInd(B0,B1,B2,B3,B4); then
      f1.(s,I) = f2.(s,I);
      hence f1.sI = f2.sI by C1;
    end;
    hence f1 = f2 by FUNCT_2:113;
  end;

definition
  let A be preIfWhileAlgebra;
  let S be non empty set;
  let T be Subset of S;
  let f be ExecutionFunction of A, S, T;
    defpred Q[set] means
    [:S, ElementaryInstructions A:] c= $1 & [:S, {EmptyIns A}:] c= $1 &
    for s being Element of S
    for C,I,J being Element of A holds
    ([s,I] in $1 & [f.(s,I), J] in $1 implies [s, I\;J] in $1) &
    ([s,C] in $1 & [f.(s,C), I] in $1 & f.(s, C) in T
    implies [s, if-then-else(C,I,J)] in $1) &
    ([s,C] in $1 & [f.(s,C), J] in $1 & f.(s, C) nin T
    implies [s, if-then-else(C,I,J)] in $1) &
    ([s,C] in $1 & 
     (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
     for i being Nat st 1 <= i & i < len r
     holds r.i in T & [r.i, I\;C] in $1 & r.(i+1) = f.(r.i, I\;C))
    implies [s, while(C,I)] in $1);

  func TerminatingPrograms(A,S,T,f) -> Subset of [:S, the carrier of A:] means:
TERMPROG:
  ([:S, ElementaryInstructions A:] c= it & [:S, {EmptyIns A}:] c= it &
   for s being Element of S
   for C,I,J being Element of A holds
   ([s,I] in it & [f.(s,I), J] in it implies [s, I\;J] in it) &
   ([s,C] in it & [f.(s,C), I] in it & f.(s, C) in T
   implies [s, if-then-else(C,I,J)] in it) &
   ([s,C] in it & [f.(s,C), J] in it & f.(s, C) nin T
   implies [s, if-then-else(C,I,J)] in it) &
   ([s,C] in it &
    (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
    for i being Nat st 1 <= i & i < len r
    holds r.i in T & [r.i, I\;C] in it & r.(i+1) = f.(r.i, I\;C))
    implies [s, while(C,I)] in it)
  ) &
  for P being Subset of [:S, the carrier of A:] st
    [:S, ElementaryInstructions A:] c= P & [:S, {EmptyIns A}:] c= P &
    for s being Element of S
    for C,I,J being Element of A holds
    ([s,I] in P & [f.(s,I), J] in P implies [s, I\;J] in P) &
    ([s,C] in P & [f.(s,C), I] in P & f.(s, C) in T
    implies [s, if-then-else(C,I,J)] in P) &
    ([s,C] in P & [f.(s,C), J] in P & f.(s, C) nin T
    implies [s, if-then-else(C,I,J)] in P) &
    ([s,C] in P &
     (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
     for i being Nat st 1 <= i & i < len r
     holds r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C))
     implies [s, while(C,I)] in P)
  holds it c= P;
  existence
  proof
    set QQ = {Z where Z is Subset of [:S, the carrier of A:]: Q[Z]};
    set IT = meet QQ;
    Q[ [#] [:S, the carrier of A:] ]
    proof set Y = [#] [:S, the carrier of A:];
      {EmptyIns A} c= the carrier of A by ZFMISC_1:37;
      hence [:S, ElementaryInstructions A:] c= Y & [:S, {EmptyIns A}:] c= Y
      by ZFMISC_1:118;
      thus for s being Element of S
      for C,I,J being Element of A holds
      ([s,I] in Y & [f.(s,I), J] in Y implies [s, I\;J] in Y) &
      ([s,C] in Y & [f.(s,C), I] in Y & f.(s, C) in T
      implies [s, if-then-else(C,I,J)] in Y) &
      ([s,C] in Y & [f.(s,C), J] in Y & f.(s, C) nin T
      implies [s, if-then-else(C,I,J)] in Y) &
      ([s,C] in Y &
      (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
      for i being Nat st 1 <= i & i < len r
      holds r.i in T & [r.i, I\;C] in Y & r.(i+1) = f.(r.i, I\;C))
      implies [s, while(C,I)] in Y)
      by ZFMISC_1:106;
    end; then
A1: [:S, the carrier of A:] in QQ; then
    reconsider IT as Subset of [:S, the carrier of A:] by SETFAM_1:4;
    take IT;
    now
      let a be set;
      assume a in QQ; then
      ex Z being Subset of [:S, the carrier of A:] st a = Z & Q[Z];
      hence [:S, ElementaryInstructions A:] c= a;
    end;
    hence [:S, ElementaryInstructions A:] c= IT by A1,SETFAM_1:6;
    now
      let a be set;
      assume a in QQ; then
      ex Z being Subset of [:S, the carrier of A:] st a = Z & Q[Z];
      hence [:S, {EmptyIns A}:] c= a;
    end;
    hence [:S, {EmptyIns A}:] c= IT by A1,SETFAM_1:6;
    hereby
      let s be Element of S;
      let C,I,J be Element of A;
      hereby assume
01:     [s,I] in IT & [f.(s,I), J] in IT;
        now let a be set;
          assume a in QQ; then
          [s,I] in a & [f.(s,I), J] in a &
          ex Z being Subset of [:S, the carrier of A:] st a = Z & Q[Z]
          by 01,SETFAM_1:def 1;
          hence [s, I\;J] in a;
        end;
        hence [s, I\;J] in IT by A1,SETFAM_1:def 1;
      end;
      hereby assume
02:     [s,C] in IT & [f.(s,C), I] in IT & f.(s, C) in T;
        now let a be set;
          assume a in QQ; then
          [s,C] in a & [f.(s,C), I] in a &
          ex Z being Subset of [:S, the carrier of A:] st a = Z & Q[Z]
          by 02,SETFAM_1:def 1;
          hence [s, if-then-else(C,I,J)] in a by 02;
        end;
        hence [s, if-then-else(C,I,J)] in IT by A1,SETFAM_1:def 1;
      end;
      hereby assume
03:     [s,C] in IT & [f.(s,C), J] in IT & f.(s, C) nin T;
        now let a be set;
          assume a in QQ; then
          [s,C] in a & [f.(s,C), J] in a &
          ex Z being Subset of [:S, the carrier of A:] st a = Z & Q[Z]
          by 03,SETFAM_1:def 1;
          hence [s, if-then-else(C,I,J)] in a by 03;
        end;
        hence [s, if-then-else(C,I,J)] in IT by A1,SETFAM_1:def 1;
      end;
      assume
04:   [s,C] in IT;
      given r being non empty FinSequence of S such that
05:   r.1 = f.(s,C) & r.len r nin T &
      for i being Nat st 1 <= i & i < len r
      holds r.i in T & [r.i, I\;C] in IT & r.(i+1) = f.(r.i, I\;C);
      now let a be set;
        assume
06:     a in QQ;
07:     now
          let i be Nat; assume 1 <= i & i < len r; then
          r.i in T & [r.i, I\;C] in IT & r.(i+1) = f.(r.i, I\;C) by 05;
          hence r.i in T & [r.i, I\;C] in a & r.(i+1) = f.(r.i, I\;C)
          by 06,SETFAM_1:def 1;
        end;
        [s,C] in a &
        ex Z being Subset of [:S, the carrier of A:] st a = Z & Q[Z]
        by 04,06,SETFAM_1:def 1;
        hence [s, while(C,I)] in a by 05,07;
      end;
      hence [s, while(C,I)] in IT by A1,SETFAM_1:def 1;
    end;
    let Y be Subset of [:S, the carrier of A:];
    assume Q[Y]; then
    Y in QQ;
    hence thesis by SETFAM_1:4;
  end;
  uniqueness
  proof
    let Y1,Y2 being Subset of [:S, the carrier of A:] such that
A1: Q[Y1] and
B1: for Y being Subset of [:S, the carrier of A:] st Q[Y] holds Y1 c= Y and
A2: Q[Y2] and
B2: for Y being Subset of [:S, the carrier of A:] st Q[Y] holds Y2 c= Y;
    thus Y1 c= Y2 by A2,B1;
    thus thesis by A1,B2;
  end;
end;

definition
  let A be preIfWhileAlgebra;
  let I be Element of A;
  attr I is absolutely-terminating means:
ABT:
  for S being non empty set, s being Element of S
  for T being Subset of S
  for f being ExecutionFunction of A, S, T
  holds [s,I] in TerminatingPrograms(A,S,T,f);
end;

theorem Th42:
  I in ElementaryInstructions A implies [s, I] in TerminatingPrograms(A,S,T,f)
  proof assume
    I in ElementaryInstructions A; then
    [s, I] in [:S, ElementaryInstructions A:] &
    [:S, ElementaryInstructions A:] c= TerminatingPrograms(A,S,T,f)
    by TERMPROG,ZFMISC_1:106;
    hence thesis;
  end;

theorem
  I in ElementaryInstructions A implies I is absolutely-terminating
  proof assume
A0: I in ElementaryInstructions A;
    let S;
    thus thesis by A0,Th42;
  end;

theorem Th43:
  [s, EmptyIns A] in TerminatingPrograms(A,S,T,f)
  proof set I = EmptyIns A;
    I in {I} by TARSKI:def 1; then
    [s, I] in [:S, {I}:] & [:S, {I}:] c= TerminatingPrograms(A,S,T,f)
      by TERMPROG,ZFMISC_1:106;
    hence thesis;
  end;

registration
  let A;
  cluster EmptyIns A -> absolutely-terminating;
  coherence
  proof let S;
    thus thesis by Th43;
  end;
end;

registration
  let A;
  cluster absolutely-terminating Element of A;
  existence
  proof
    take EmptyIns A;
    thus thesis;
  end;
end;

theorem Th41:
  A is free & [s, I\;J] in TerminatingPrograms(A,S,T,f) implies
  [s,I] in TerminatingPrograms(A,S,T,f) &
  [f.(s,I), J] in TerminatingPrograms(A,S,T,f)
  proof set TP = TerminatingPrograms(A,S,T,f);
    assume
A0: A is free & [s, I\;J] in TP;
    reconsider P = TP \ {[s, I\;J]} as Subset of [:S, the carrier of A:];
A1: [:S, ElementaryInstructions A:] c= P
    proof
      let x,y be set; assume
00:   [x,y] in [:S, ElementaryInstructions A:]; then
      I <> I\;J & J <> I\;J & y in ElementaryInstructions A
      by A0,ThFC,ZFMISC_1:106; then
      y <> I\;J by Th0B; then
      [:S, ElementaryInstructions A:] c= TP &
      [x,y] <> [s, I\;J] by TERMPROG,ZFMISC_1:33; then
      [x,y] nin {[s, I\;J]} & [x,y] in TP
      by 00,TARSKI:def 1;
      hence thesis by XBOOLE_0:def 4;
    end;
A2: [:S, {EmptyIns A}:] c= P
    proof
      let x,y be set; assume
00:   [x,y] in [:S, {EmptyIns A}:]; then
      y in {EmptyIns A} by ZFMISC_1:106; then
      y = EmptyIns A by TARSKI:def 1; then
      y <> I\;J by A0,ThFE; then
      [:S, {EmptyIns A}:] c= TP &
      [x,y] <> [s, I\;J] by TERMPROG,ZFMISC_1:33; then
      [x,y] nin {[s, I\;J]} & [x,y] in TP
      by 00,TARSKI:def 1;
      hence thesis by XBOOLE_0:def 4;
    end;
    set rr = s, IJ = I\;J;
A3: now let s be Element of S;
      let C,I,J be Element of A;
      hereby assume
00:     [s,C] in P & [f.(s,C), I] in P & f.(s, C) in T; then
        [s,C] in TP & [f.(s,C), I] in TP & IJ <> if-then-else(C,I,J)
        by A0,ThFC,ZFMISC_1:64; then
        [s, if-then-else(C,I,J)] in TP & [rr,IJ] <> [s, if-then-else(C,I,J)]
        by 00,TERMPROG,ZFMISC_1:33;
        hence [s, if-then-else(C,I,J)] in P by ZFMISC_1:64;
      end;
      hereby assume
00:     [s,C] in P & [f.(s,C), J] in P & f.(s, C) nin T; then
        [s,C] in TP & [f.(s,C), J] in TP & IJ <> if-then-else(C,I,J)
        by A0,ThFC,ZFMISC_1:64; then
        [s, if-then-else(C,I,J)] in TP & [rr,IJ] <> [s, if-then-else(C,I,J)]
        by 00,TERMPROG,ZFMISC_1:33;
        hence [s, if-then-else(C,I,J)] in P by ZFMISC_1:64;
      end;
      assume
00:   [s,C] in P;
      given r being non empty FinSequence of S such that
01:   r.1 = f.(s,C) & r.len r nin T and
02:   for i being Nat st 1 <= i & i < len r
      holds r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C);
03:   now let i be Nat; assume 1 <= i & i < len r; then
        r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C) by 02;
        hence r.i in T & [r.i, I\;C] in TP & r.(i+1) = f.(r.i, I\;C)
        by ZFMISC_1:64;
      end;
      [s,C] in TP & while(C,I) <> IJ by A0,ThFC,00,ZFMISC_1:64; then
      [s, while(C,I)] in TP & [s, while(C,I)] <> [rr,IJ]
      by 01,03,TERMPROG,ZFMISC_1:33;
      hence [s, while(C,I)] in P by ZFMISC_1:64;
    end;
    hereby assume
00:   [rr,I] nin TP;
      now let q be Element of S;
        let C,I',J' be Element of A;
        assume [q,I'] in P & [f.(q,I'), J'] in P; then
01:     [q,I'] in TP & 
        [f.(q,I'), J'] in TP by ZFMISC_1:64; then
        q <> rr or I'\;J' <> I\;J by 00,A0,ThFC; then
        [q, I'\;J'] in TP & [q,I'\;J'] <> [rr,I\;J]
        by 01,TERMPROG,ZFMISC_1:33;
        hence [q, I'\;J'] in P by ZFMISC_1:64;
      end; then
      for s being Element of S
      for C,I,J being Element of A holds
      ([s,I] in P & [f.(s,I), J] in P implies [s, I\;J] in P) &
      ([s,C] in P & [f.(s,C), I] in P & f.(s, C) in T
      implies [s, if-then-else(C,I,J)] in P) &
      ([s,C] in P & [f.(s,C), J] in P & f.(s, C) nin T
      implies [s, if-then-else(C,I,J)] in P) &
      ([s,C] in P &
      (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
      for i being Nat st 1 <= i & i < len r
      holds r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C))
      implies [s, while(C,I)] in P) by A3; then
      TP c= P by A1,A2,TERMPROG;
      hence contradiction by A0,ZFMISC_1:64;
    end;
    assume
00: [f.(s,I), J] nin TP;
    now let q be Element of S;
      let C,I',J' be Element of A;
      assume
02:   [q,I'] in P & [f.(q,I'), J'] in P; then
01:   [q,I'] in TP & [f.(q,I'), J'] in TP by ZFMISC_1:64;
      f.(q,I') <> f.(s,I) or J' <> J by 00,02,ZFMISC_1:64; then
      q <> s or I'\;J' <> I\;J by A0,ThFC; then
      [q, I'\;J'] in TP & [q,I'\;J'] <> [rr,I\;J]
      by 01,TERMPROG,ZFMISC_1:33;
      hence [q, I'\;J'] in P by ZFMISC_1:64;
    end; then
    for s being Element of S
    for C,I,J being Element of A holds
    ([s,I] in P & [f.(s,I), J] in P implies [s, I\;J] in P) &
    ([s,C] in P & [f.(s,C), I] in P & f.(s, C) in T
    implies [s, if-then-else(C,I,J)] in P) &
    ([s,C] in P & [f.(s,C), J] in P & f.(s, C) nin T
    implies [s, if-then-else(C,I,J)] in P) &
    ([s,C] in P &
    (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
    for i being Nat st 1 <= i & i < len r
    holds r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C))
    implies [s, while(C,I)] in P) by A3; then
    TP c= P by A1,A2,TERMPROG;
    hence contradiction by A0,ZFMISC_1:64;
  end;

registration
  let A;
  let I,J be absolutely-terminating Element of A;
  cluster I\;J -> absolutely-terminating;
  coherence
  proof let S,s,T,f;
    [s,I] in TerminatingPrograms(A,S,T,f) &
    [f.(s,I),J] in TerminatingPrograms(A,S,T,f) by ABT;
    hence thesis by TERMPROG;
  end;
end;

theorem Th44:
  A is free & [s, if-then-else(C,I,J)] in TerminatingPrograms(A,S,T,f)
  implies [s,C] in TerminatingPrograms(A,S,T,f) &
  (f.(s,C) in T implies [f.(s,C), I] in TerminatingPrograms(A,S,T,f)) &
  (f.(s,C) nin T implies [f.(s,C), J] in TerminatingPrograms(A,S,T,f))
  proof set TP = TerminatingPrograms(A,S,T,f);
    set rr = s, IJ = if-then-else(C,I,J);
    assume
A0: A is free & [s, IJ] in TP;
    reconsider P = TP \ {[s, IJ]} as Subset of [:S, the carrier of A:];
A1: [:S, ElementaryInstructions A:] c= P
    proof
      let x,y be set; assume
00:   [x,y] in [:S, ElementaryInstructions A:]; then
      y in ElementaryInstructions A by ZFMISC_1:106; then
      y <> IJ by Th0C; then
      [:S, ElementaryInstructions A:] c= TP &
      [x,y] <> [s, IJ] by TERMPROG,ZFMISC_1:33; then
      [x,y] nin {[s, IJ]} & [x,y] in TP
      by 00,TARSKI:def 1;
      hence thesis by XBOOLE_0:def 4;
    end;
A2: [:S, {EmptyIns A}:] c= P
    proof
      let x,y be set; assume
00:   [x,y] in [:S, {EmptyIns A}:]; then
      y in {EmptyIns A} by ZFMISC_1:106; then
      y = EmptyIns A by TARSKI:def 1; then
      y <> IJ by A0,ThFE; then
      [:S, {EmptyIns A}:] c= TP & [x,y] <> [s, IJ]
      by TERMPROG,ZFMISC_1:33; then
      [x,y] nin {[s, IJ]} & [x,y] in TP by 00,TARSKI:def 1;
      hence thesis by XBOOLE_0:def 4;
    end;
A3: now let s be Element of S;
      let C,I,J be Element of A;
      hereby assume [s,I] in P & [f.(s,I), J] in P; then
        [s,I] in TP & [f.(s,I), J] in TP & IJ <> I\;J
        by A0,ThFC,ZFMISC_1:64; then
        [s, I\;J] in TP & [rr,IJ] <> [s, I\;J] by TERMPROG,ZFMISC_1:33;
        hence [s, I\;J] in P by ZFMISC_1:64;
      end;
      assume
00:   [s,C] in P;
      given r being non empty FinSequence of S such that
01:   r.1 = f.(s,C) & r.len r nin T and
02:   for i being Nat st 1 <= i & i < len r
      holds r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C);
03:   now let i be Nat; assume 1 <= i & i < len r; then
        r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C) by 02;
        hence r.i in T & [r.i, I\;C] in TP & r.(i+1) = f.(r.i, I\;C)
          by ZFMISC_1:64;
      end;
      [s,C] in TP & while(C,I) <> IJ by A0,ThFI,00,ZFMISC_1:64; then
      [s, while(C,I)] in TP & [s, while(C,I)] <> [rr,IJ]
      by 01,03,TERMPROG,ZFMISC_1:33;
      hence [s, while(C,I)] in P by ZFMISC_1:64;
    end;
    hereby assume
00:   [s,C] nin TerminatingPrograms(A,S,T,f);
01:   now let s be Element of S;
        let C',I,J be Element of A;
        assume
02:     [s,C'] in P & [f.(s,C'), I] in P & f.(s, C') in T; then
03:     [s,C'] in TP & [f.(s,C'), I] in TP by ZFMISC_1:64; then
        (IJ <> if-then-else(C',I,J) or rr <> s) by 00,A0,ThFI; then
        [s, if-then-else(C',I,J)] in TP & [rr,IJ] <> [s, if-then-else(C',I,J)]
        by 02,03,TERMPROG,ZFMISC_1:33;
        hence [s, if-then-else(C',I,J)] in P by ZFMISC_1:64;
      end;
      now let s be Element of S;
        let C',I,J be Element of A;
        assume
02:     [s,C'] in P & [f.(s,C'), J] in P & f.(s, C') nin T; then
03:     [s,C'] in TP & [f.(s,C'), J] in TP by ZFMISC_1:64; then
        (IJ <> if-then-else(C',I,J) or rr <> s) by 00,A0,ThFI; then
        [s, if-then-else(C',I,J)] in TP & [rr,IJ] <> [s, if-then-else(C',I,J)]
        by 02,03,TERMPROG,ZFMISC_1:33;
        hence [s, if-then-else(C',I,J)] in P by ZFMISC_1:64;
      end; then
      TP c= P by 01,A3,A1,A2,TERMPROG;
      hence contradiction by A0,ZFMISC_1:64;
    end;
    thus (f.(s,C) in T implies [f.(s,C), I] in TerminatingPrograms(A,S,T,f))
    proof assume
00:   f.(s,C) in T & [f.(s,C), I] nin TP;
01:   now let s be Element of S;
        let C',I',J be Element of A;
        assume
02:     [s,C'] in P & [f.(s,C'), I'] in P & f.(s, C') in T; then
03:     [s,C'] in TP & [f.(s,C'), I'] in TP by ZFMISC_1:64;
        f.(s,C') <> f.(rr,C) or I <> I' by 02,00,ZFMISC_1:64; then
        (IJ <> if-then-else(C',I',J) or rr <> s) by A0,ThFI; then
        [s,if-then-else(C',I',J)] in TP & [rr,IJ] <> [s,if-then-else(C',I',J)]
        by 02,03,TERMPROG,ZFMISC_1:33;
        hence [s, if-then-else(C',I',J)] in P by ZFMISC_1:64;
      end;
      now let s be Element of S;
        let C',I,J' be Element of A;
        assume
02:     [s,C'] in P & [f.(s,C'), J'] in P & f.(s, C') nin T; then
03:     [s,C'] in TP & [f.(s,C'), J'] in TP by ZFMISC_1:64;
        (IJ <> if-then-else(C',I,J') or rr <> s) by 00,02,A0,ThFI; then
        [s,if-then-else(C',I,J')] in TP & [rr,IJ] <> [s,if-then-else(C',I,J')]
        by 02,03,TERMPROG,ZFMISC_1:33;
        hence [s, if-then-else(C',I,J')] in P by ZFMISC_1:64;
      end; then
      TP c= P by 01,A1,A2,A3,TERMPROG;
      hence contradiction by A0,ZFMISC_1:64;
    end;
    assume
00: f.(s,C) nin T & [f.(s,C), J] nin TP;
01: now let s be Element of S;
      let C',I',J be Element of A;
      assume
02:   [s,C'] in P & [f.(s,C'), I'] in P & f.(s, C') in T; then
03:   [s,C'] in TP & [f.(s,C'), I'] in TP by ZFMISC_1:64;
      (IJ <> if-then-else(C',I',J) or rr <> s) by 00,02,A0,ThFI; then
      [s,if-then-else(C',I',J)] in TP & [rr,IJ] <> [s,if-then-else(C',I',J)]
      by 02,03,TERMPROG,ZFMISC_1:33;
      hence [s, if-then-else(C',I',J)] in P by ZFMISC_1:64;
    end;
    now let s be Element of S;
      let C',I,J' be Element of A;
      assume
02:   [s,C'] in P & [f.(s,C'), J'] in P & f.(s, C') nin T; then
03:   [s,C'] in TP & [f.(s,C'), J'] in TP by ZFMISC_1:64;
      f.(s,C') <> f.(rr,C) or J <> J' by 00,02,ZFMISC_1:64; then
      (IJ <> if-then-else(C',I,J') or rr <> s) by A0,ThFI; then
      [s,if-then-else(C',I,J')] in TP & [rr,IJ] <> [s,if-then-else(C',I,J')]
      by 02,03,TERMPROG,ZFMISC_1:33;
      hence [s, if-then-else(C',I,J')] in P by ZFMISC_1:64;
    end; then
    TP c= P by 01,A1,A2,A3,TERMPROG;
    hence contradiction by A0,ZFMISC_1:64;
  end;

registration
  let A;
  let C,I,J be absolutely-terminating Element of A;
  cluster if-then-else(C,I,J) -> absolutely-terminating;
  coherence
  proof let S,s,T,f;
    [s,C] in TerminatingPrograms(A,S,T,f) & (f.(s,C) in T or f.(s,C) nin T) &
    [f.(s,C),I] in TerminatingPrograms(A,S,T,f) &
    [f.(s,C),J] in TerminatingPrograms(A,S,T,f) by ABT;
    hence thesis by TERMPROG;
  end;
end;

theorem Th45:
  A is free & [s, while(C,I)] in TerminatingPrograms(A,S,T,f)
  implies [s,C] in TerminatingPrograms(A,S,T,f) &
  ex r being non empty FinSequence of S st
     r.1 = f.(s,C) & r.len r nin T &
     for i being Nat st 1 <= i & i < len r
     holds r.i in T & [r.i, I\;C] in TerminatingPrograms(A,S,T,f) &
      r.(i+1) = f.(r.i, I\;C)
  proof set TP = TerminatingPrograms(A,S,T,f);
    set rr = s, IJ = while(C,I);
    assume
A0: A is free & [s, IJ] in TP;
    reconsider P = TP \ {[s, IJ]} as Subset of [:S, the carrier of A:];
A1: [:S, ElementaryInstructions A:] c= P
    proof
      let x,y be set; assume
00:   [x,y] in [:S, ElementaryInstructions A:]; then
      y in ElementaryInstructions A by ZFMISC_1:106; then
      y <> IJ by Th0D; then
      [:S, ElementaryInstructions A:] c= TP &
      [x,y] <> [s, IJ] by TERMPROG,ZFMISC_1:33; then
      [x,y] nin {[s, IJ]} & [x,y] in TP
      by 00,TARSKI:def 1;
      hence thesis by XBOOLE_0:def 4;
    end;
A2: [:S, {EmptyIns A}:] c= P
    proof
      let x,y be set; assume
00:   [x,y] in [:S, {EmptyIns A}:]; then
      y in {EmptyIns A} by ZFMISC_1:106; then
      y = EmptyIns A by TARSKI:def 1; then
      y <> IJ by A0,ThFE; then
      [:S, {EmptyIns A}:] c= TP &
      [x,y] <> [s, IJ] by TERMPROG,ZFMISC_1:33; then
      [x,y] nin {[s, IJ]} & [x,y] in TP
      by 00,TARSKI:def 1;
      hence thesis by XBOOLE_0:def 4;
    end;
A3: now let s be Element of S;
      let C,I,J be Element of A;
      hereby assume [s,I] in P & [f.(s,I), J] in P; then
        [s,I] in TP & [f.(s,I), J] in TP & IJ <> I\;J
        by A0,ThFC,ZFMISC_1:64; then
        [s, I\;J] in TP & [rr,IJ] <> [s, I\;J] by TERMPROG,ZFMISC_1:33;
        hence [s, I\;J] in P by ZFMISC_1:64;
      end;
      hereby assume
00:     [s,C] in P & [f.(s,C), I] in P & f.(s, C) in T; then
        [s,C] in TP & [f.(s,C), I] in TP & IJ <> if-then-else(C,I,J)
        by A0,ThFI,ZFMISC_1:64; then
        [s, if-then-else(C,I,J)] in TP & [rr,IJ] <> [s, if-then-else(C,I,J)]
        by 00,TERMPROG,ZFMISC_1:33;
        hence [s, if-then-else(C,I,J)] in P by ZFMISC_1:64;
      end;
      hereby assume
00:     [s,C] in P & [f.(s,C), J] in P & f.(s, C) nin T; then
        [s,C] in TP & [f.(s,C), J] in TP & IJ <> if-then-else(C,I,J)
        by A0,ThFI,ZFMISC_1:64; then
        [s, if-then-else(C,I,J)] in TP & [rr,IJ] <> [s, if-then-else(C,I,J)]
        by 00,TERMPROG,ZFMISC_1:33;
        hence [s, if-then-else(C,I,J)] in P by ZFMISC_1:64;
      end;
    end;
    hereby assume
05:   [s,C] nin TerminatingPrograms(A,S,T,f);
      now let s be Element of S;
        let C',I',J be Element of A;
        assume
00:     [s,C'] in P;
        given r being non empty FinSequence of S such that
01:     r.1 = f.(s,C') & r.len r nin T and
02:     for i being Nat st 1 <= i & i < len r
        holds r.i in T & [r.i, I'\;C'] in P & r.(i+1) = f.(r.i, I'\;C');
03:     now let i be Nat; assume 1 <= i & i < len r; then
          r.i in T & [r.i, I'\;C'] in P & r.(i+1) = f.(r.i, I'\;C') by 02;
          hence r.i in T & [r.i, I'\;C'] in TP & r.(i+1) = f.(r.i, I'\;C')
          by ZFMISC_1:64;
        end;
04:     [s,C'] in TP by 00,ZFMISC_1:64;
        while(C',I') <> IJ or s <> rr by 04,05,A0,ThFW; then
        [s, while(C',I')] in TP & [s, while(C',I')] <> [rr,IJ]
        by 01,03,04,TERMPROG,ZFMISC_1:33;
        hence [s, while(C',I')] in P by ZFMISC_1:64;
      end; then
      for s being Element of S
      for C,I,J being Element of A holds
      ([s,I] in P & [f.(s,I), J] in P implies [s, I\;J] in P) &
      ([s,C] in P & [f.(s,C), I] in P & f.(s, C) in T
      implies [s, if-then-else(C,I,J)] in P) &
      ([s,C] in P & [f.(s,C), J] in P & f.(s, C) nin T
      implies [s, if-then-else(C,I,J)] in P) &
      ([s,C] in P &
      (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
      for i being Nat st 1 <= i & i < len r
      holds r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C))
      implies [s, while(C,I)] in P) by A3; then
      TP c= P by A1,A2,TERMPROG;
      hence contradiction by A0,ZFMISC_1:64;
    end;
    assume
BB: not ex r being non empty FinSequence of S st
    r.1 = f.(rr,C) & r.len r nin T &
    for i being Nat st 1 <= i & i < len r
    holds r.i in T & [r.i, I\;C] in TP & r.(i+1) = f.(r.i, I\;C);
    now let s be Element of S;
      let C',I',J be Element of A; assume
00:   [s,C'] in P;
      given r being non empty FinSequence of S such that
01:   r.1 = f.(s,C') & r.len r nin T and
02:   for i being Nat st 1 <= i & i < len r
      holds r.i in T & [r.i, I'\;C'] in P & r.(i+1) = f.(r.i, I'\;C');
03:   now let i be Nat; assume 1 <= i & i < len r; then
        r.i in T & [r.i, I'\;C'] in P & r.(i+1) = f.(r.i, I'\;C') by 02;
        hence r.i in T & [r.i, I'\;C'] in TP & r.(i+1) = f.(r.i, I'\;C')
        by ZFMISC_1:64;
      end;
04:   [s,C'] in TP by 00,ZFMISC_1:64;
      I <> I' or C <> C' or s <> rr by BB,01,03; then
      while(C',I') <> IJ or s <> rr by A0,ThFW; then
      [s, while(C',I')] in TP & [s, while(C',I')] <> [rr,IJ]
      by 01,03,04,TERMPROG,ZFMISC_1:33;
      hence [s, while(C',I')] in P by ZFMISC_1:64;
    end; then
    for s being Element of S
    for C,I,J being Element of A holds
    ([s,I] in P & [f.(s,I), J] in P implies [s, I\;J] in P) &
    ([s,C] in P & [f.(s,C), I] in P & f.(s, C) in T
    implies [s, if-then-else(C,I,J)] in P) &
    ([s,C] in P & [f.(s,C), J] in P & f.(s, C) nin T
    implies [s, if-then-else(C,I,J)] in P) &
    ([s,C] in P &
    (ex r being non empty FinSequence of S st r.1 = f.(s,C) & r.len r nin T &
    for i being Nat st 1 <= i & i < len r
    holds r.i in T & [r.i, I\;C] in P & r.(i+1) = f.(r.i, I\;C))
    implies [s, while(C,I)] in P) by A3; then
    TP c= P by A1,A2,TERMPROG;
    hence contradiction by A0,ZFMISC_1:64;
  end;

theorem
  A is free & [s, while(C,I)] in TerminatingPrograms(A,S,T,f) & f.(s,C) in T
  implies [f.(s,C), I] in TerminatingPrograms(A,S,T,f)
  proof set TP = TerminatingPrograms(A,S,T,f);
    set rr = s, IJ = while(C,I);
    assume
A0: A is free & [s, IJ] in TP & f.(s,C) in T; then
    consider r being non empty FinSequence of S such that
01: r.1 = f.(s,C) & r.len r nin T and
02: for i being Nat st 1 <= i & i < len r
    holds r.i in T & [r.i, I\;C] in TP & r.(i+1) = f.(r.i, I\;C) by Th45;
    len r <> 0 by FINSEQ_1:25; then
    len r >= 1 by NAT_1:14; then
    1 < len r by A0,01,XXREAL_0:1; then
    [r.1, I\;C] in TP by 02;
    hence [f.(s,C), I] in TP by A0,01,Th41;
  end;

theorem
  for C,I being absolutely-terminating Element of A
  st f iteration_terminates_for I\;C, f.(s,C)
  holds [s, while(C,I)] in TerminatingPrograms(A,S,T,f)
  proof
    let C,I be absolutely-terminating Element of A;
    given r being non empty FinSequence of S such that
A0: r.1 = f.(s,C) & r.len r nin T and
A1: for i being Nat st 1 <= i & i < len r
    holds r.i in T & r.(i+1) = f.(r.i, I\;C);
A2: now let i be Nat; assume
A3:   1 <= i & i < len r;
      hence r.i in T by A1;
      hence [r.i, I\;C] in TerminatingPrograms(A,S,T,f) &
      r.(i+1) = f.(r.i, I\;C) by A1,A3,ABT;
    end;
    [s,C] in TerminatingPrograms(A,S,T,f) by ABT;
    hence [s, while(C,I)] in TerminatingPrograms(A,S,T,f) by A0,A2,TERMPROG;
  end;

LemA:
  for A being free ECIW-strict preIfWhileAlgebra
  for f1,f2 being ExecutionFunction of A, S, T
  st f1|[:S, ElementaryInstructions A:] = f2|[:S, ElementaryInstructions A:]
  for I being Element of A
  for s being Element of S st [s,I] in TerminatingPrograms(A,S,T,f1)
  holds [s,I] in TerminatingPrograms(A,S,T,f2) & f1.(s,I) = f2.(s,I)
  proof
    let A be free ECIW-strict preIfWhileAlgebra;
    let f1,f2 be ExecutionFunction of A, S, T such that
Z0: f1|[:S, ElementaryInstructions A:] = f2|[:S, ElementaryInstructions A:];
    set g = f1|[:S, ElementaryInstructions A:];
    set TP1 = TerminatingPrograms(A,S,T,f1);
    set TP2 = TerminatingPrograms(A,S,T,f2);
    defpred P[Element of A] means
    for s st [s,$1] in TP1 holds [s,$1] in TP2 & f1.(s,$1) = f2.(s,$1);
A0: for I being Element of A st I in ElementaryInstructions A
    holds P[I]
    proof
      let I be Element of A; assume
00:   I in ElementaryInstructions A;
      let s be Element of S; assume [s,I] in TP1;
      thus [s,I] in TP2 by 00,Th42;
01:   [s,I] in [:S, ElementaryInstructions A:] by 00,ZFMISC_1:106;
      hence f1.(s,I) = g.[s,I] by FUNCT_1:72 .= f2.(s,I) by Z0,01,FUNCT_1:72;
    end;
A1: P[EmptyIns A]
    proof let s be Element of S;
      f1.(s,EmptyIns A) = s by EMP;
      hence thesis by Th43,EMP;
    end;
A2: for I1,I2 being Element of A st P[I1] & P[I2] holds P[I1\;I2]
    proof
      let I1,I2 be Element of A such that
00:   P[I1] & P[I2];
      let s be Element of S; assume
      [s, I1\;I2] in TP1; then
      [s, I1] in TP1 & [f1.(s,I1),I2] in TP1 by Th41; then
      [s, I1] in TP2 & [f1.(s,I1),I2] in TP2 & f1.(s,I1) = f2.(s,I1) &
      f1.(f1.(s,I1),I2) = f2.(f1.(s,I1),I2) & f1.(f1.(s,I1),I2) = f1.(s,I1\;I2)
      by 00,CAT;
      hence thesis by TERMPROG,CAT;
    end;
A3: for C,I1,I2 being Element of A st P[C] & P[I1] & P[I2]
    holds P[if-then-else(C,I1,I2)]
    proof
      let C,I1,I2 be Element of A such that
00:   P[C] & P[I1] & P[I2];
01:   f1 satisfies_if_wrt T & f2 satisfies_if_wrt T by EXEC;
      set J = if-then-else(C,I1,I2);
      let s be Element of S; assume [s, J] in TP1; then
      [s, C] in TP1 & (f1.(s,C) in T implies [f1.(s,C),I1] in TP1) &
      (f1.(s,C) nin T implies [f1.(s,C),I2] in TP1) by Th44; then
      [s, C] in TP2 & f1.(s,C) = f2.(s,C) &
      (f1.(s,C) in T implies [f1.(s,C),I1] in TP2 &
      f1.(f1.(s,C),I1) = f2.(f1.(s,C),I1) & f1.(s,J) = f1.(f1.(s,C),I1)) &
      (f1.(s,C) nin T implies [f1.(s,C),I2] in TP2 &
      f1.(f1.(s,C),I2) = f2.(f1.(s,C),I2) & f1.(s,J) = f1.(f1.(s,C),I2)) &
      (f1.(s,C) in T or f1.(s,C) nin T) by 00,01,IF;
      hence thesis by TERMPROG,01,IF;
    end;
A4: for C,I being Element of A st P[C] & P[I] holds P[while(C,I)]
    proof
      let C,I be Element of A such that
00:   P[C] & P[I];
      set J = while(C,I);
      let s be Element of S; assume
01:   [s, J] in TP1; then
      [s, C] in TP1 by Th45; then
02:   [s, C] in TP2 & f1.(s,C) = f2.(s,C) by 00;
      consider r being non empty FinSequence of S such that
03:   r.1 = f1.(s,C) & r.len r nin T and
04:   for i being Nat st 1 <= i & i < len r holds
      r.i in T & [r.i, I\;C] in TP1 & r.(i+1) = f1.(r.i, I\;C) by 01,Th45;
      for i being Nat st 1 <= i & i < len r holds
      r.i in T & r.(i+1) = f1.(r.i, I\;C) by 04; then
08:   f1.(s,J) = r.len r by 03,ThW1;
      defpred Q[Nat] means 1 <= $1 & $1 < len r implies
      r.$1 in T & [r.$1, I\;C] in TP2 & r.($1+1) = f2.(r.$1, I\;C);
09:   for i being Nat holds Q[i]
      proof let i be Nat;
        assume
Z:       1 <= i & i < len r;
        hence
05:      r.i in T by 04;
        then reconsider ri = r.i as Element of S;
06:     [r.i, I\;C] in TP1 by Z,04;
        hence [r.i, I\;C] in TP2 by 00,05,A2;
C2:     [ri, I] in TP1 & [f1.(ri,I),C] in TP1 by 06,Th41;
        thus r.(i+1) = f1.(r.i, I\;C) by Z,04
        .= f1.(f1.(ri,I),C) by CAT
        .= f2.(f1.(ri,I),C) by 00,C2
        .= f2.(f2.(ri,I),C) by 00,C2
        .= f2.(r.i, I\;C) by CAT;
      end; then
      for i being Nat st 1 <= i & i < len r holds
      r.i in T & r.(i+1) = f2.(r.i, I\;C);
      hence thesis by 02,03,08,09,ThW1,TERMPROG;
    end;
    let I be Element of A;
    thus P[I] from StructInd(A0,A1,A2,A3,A4);
  end;

theorem
  for A being free ECIW-strict preIfWhileAlgebra
  for f1,f2 being ExecutionFunction of A, S, T
  st f1|[:S, ElementaryInstructions A:] = f2|[:S, ElementaryInstructions A:]
  holds TerminatingPrograms(A,S,T,f1) = TerminatingPrograms(A,S,T,f2)
  proof
    let A be free ECIW-strict preIfWhileAlgebra;
    let f1,f2 be ExecutionFunction of A, S, T;
    assume
A1: f1|[:S, ElementaryInstructions A:] = f2|[:S, ElementaryInstructions A:];
    set g = f1|[:S, ElementaryInstructions A:];
    set TP1 = TerminatingPrograms(A,S,T,f1);
    set TP2 = TerminatingPrograms(A,S,T,f2);
    thus TP1 c= TP2
    proof
      let q,I be set; assume
Z1:   [q,I] in TP1; then
      q is Element of S & I is Element of A by ZFMISC_1:106;
      hence thesis by A1,Z1,LemA;
    end;
    let q,I be set; assume
Z2: [q,I] in TP2; then
    q is Element of S & I is Element of A by ZFMISC_1:106;
    hence thesis by A1,Z2,LemA;
  end;

theorem
  for A being free ECIW-strict preIfWhileAlgebra
  for f1,f2 being ExecutionFunction of A, S, T
  st f1|[:S, ElementaryInstructions A:] = f2|[:S, ElementaryInstructions A:]
  for s being Element of S
  for I being Element of A st [s,I] in TerminatingPrograms(A,S,T,f1)
  holds f1.(s, I) = f2.(s, I) by LemA;
