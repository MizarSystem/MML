:: Multivariate polynomials with arbitrary number of variables
::  by Piotr Rudnicki and Andrzej Trybulec
::
:: Received September 22, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies MONOID_0, FUNCT_1, VECTSP_1, RELAT_1, BINOP_1, FUNCOP_1,
      PARTFUN1, ARYTM_1, RLVECT_1, FINSEQ_1, BOOLE, FUNCT_4, CAT_1, PBOOLE,
      CARD_1, FINSEQ_2, ORDERS_2, WELLORD1, ORDERS_1, RELAT_2, FINSET_1,
      TRIANG_1, MATRLIN, MEASURE6, SQUARE_1, CARD_3, REALSET1, GROUP_1,
      ALGSTR_1, LATTICES, DTCONSTR, MSUALG_3, ALGSEQ_1, ORDINAL1, ARYTM_3,
      FUNCT_2, FRAENKEL, FINSUB_1, SETWISEO, TARSKI, RFINSEQ, POLYNOM1,
      FVSUM_1, FINSEQ_4, VECTSP_2, ARYTM, ALGSTR_0, VALUED_0, ORDINAL2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS, ORDERS_1,
      RELAT_1, XCMPLX_0, RELAT_2, FUNCT_1, PBOOLE, RELSET_1, FINSET_1,
      FINSUB_1, SETWISEO, ORDINAL1, PARTFUN1, FUNCT_2, BINOP_2, FINSEQ_1,
      FINSEQ_4, STRUCT_0, ALGSTR_0, FUNCT_3, XXREAL_0, BINOP_1, FUNCT_4, NAT_1,
      XREAL_0, ALGSTR_1, RLVECT_1, FINSEQ_2, WELLORD1, SEQM_3, CARD_3, GROUP_1,
      VECTSP_1, TRIANG_1, WSIERP_1, FUNCOP_1, FUNCT_7, DTCONSTR,
      NAT_D, BINARITH, MATRLIN, CLASSES1, RFINSEQ, FVSUM_1, VALUED_0, VALUED_1,
      RECDEF_1;
 constructors WELLORD2, BINOP_1, SETWISEO, CARD_3, FINSEQOP, FINSOP_1,
      FINSEQ_4, RFINSEQ, RFUNCT_3, NAT_D, WSIERP_1, FUNCT_7, ALGSTR_1, FVSUM_1,
      DTCONSTR, MATRLIN, TRIANG_1, RECDEF_1, BINOP_2, CLASSES1, BINARITH,
      RELSET_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      ORDINAL3, FINSET_1, FRAENKEL, XXREAL_0, XREAL_0, NAT_1, BINOP_2, CARD_1,
      MEMBERED, FINSEQ_1, FINSEQ_2, CARD_3, STRUCT_0, VECTSP_1, ALGSTR_1,
      CIRCCOMB, HEYTING2, GOBRD13, VALUED_0, VALUED_1, RELSET_1, FUNCT_2;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, XBOOLE_0, RLVECT_1, FUNCT_1, VECTSP_1, MATRLIN, CARD_3,
      RELAT_2, PBOOLE, RELSET_1, WELLORD2, RELAT_1, GROUP_1, BINOP_1,
      FINSEQ_2, STRUCT_0, VALUED_0, ALGSTR_0, FUNCOP_1;
 theorems FUNCT_1, FINSET_1, FINSEQ_3, FINSEQ_4, ZFMISC_1, FINSEQ_1, FUNCT_2,
      RLVECT_1, VECTSP_1, FUNCOP_1, TARSKI, FUNCT_7, BINOP_1, RELAT_1, MATRLIN,
      FINSEQ_2, CARD_3, RFINSEQ, DTCONSTR, GROUP_7, RELSET_1, CARD_1, ORDINAL1,
      RVSUM_1, FINSEQ_5, NAT_1, PBOOLE, NAT_2, SUBSET_1, ORDERS_1, WELLSET1,
      WELLORD1, RELAT_2, FVSUM_1, FUNCT_3, TRIANG_1, PRE_CIRC, ORDINAL3,
      SETWISEO, SETWOP_2, CARD_2, FUNCT_5, FINSUB_1, GROUP_1, PARTFUN2,
      XBOOLE_0, XBOOLE_1, RLVECT_2, PARTFUN1, BINOP_2, XREAL_1, XXREAL_0,
      VALUED_0, VALUED_1, NAT_D;
 schemes FRAENKEL, SETWISEO, FUNCT_2, FINSEQ_2, FINSEQ_1, PBOOLE, RELSET_1,
      FINSEQ_4, ORDINAL1, FUNCT_7, SUBSET_1, XBOOLE_0, BINOP_1;

begin

canceled 3;

theorem Th4:
  for X being set, R being Relation st field R c= X holds R is Relation of X
proof
  let X be set, R be Relation;
  assume
A1: field R c= X;
  R c= [:X,X:]
  proof let x,y be set;
  assume [x,y] in R;
  then x in field R & y in field R by RELAT_1:30;
  hence thesis by A1,ZFMISC_1:def 2;
  end;
  hence thesis;
end;

theorem Th5:
  for K being non empty addLoopStr, p1,p2 be FinSequence of the carrier of K
  st dom p1 = dom p2 holds dom(p1+p2) = dom p1
proof
  let K be non empty addLoopStr, p1,p2 be FinSequence of the carrier of K;
  assume
A1: dom p1 = dom p2;
A2: rng <:p1,p2:> c= [:rng p1,rng p2:] by FUNCT_3:71;
A3: [:rng p1,rng p2:] c= [:the carrier of K,the carrier of K:]
  by ZFMISC_1:119;
A4: [:the carrier of K,the carrier of K:] = dom (the addF of K)
  by FUNCT_2:def 1;
  thus dom (p1+p2) = dom ((the addF of K).:(p1,p2)) by FVSUM_1:def 3
    .= dom ((the addF of K)*<:p1,p2:>)
    .= dom <:p1,p2:> by A2,A3,A4,RELAT_1:46,XBOOLE_1:1
    .= dom p1 /\ dom p2 by FUNCT_3:def 8
    .= dom p1 by A1;
end;

registration
  let X be set, f be ManySortedSet of X, x, y be set;
  cluster f+*(x,y) -> X-defined;
  coherence
  proof
    dom (f+*(x,y)) = dom f by FUNCT_7:32
      .= X by PARTFUN1:def 4;
   hence thesis by RELAT_1:def 18;
  end;
end;

registration
  let X be set, f be ManySortedSet of X, x, y be set;
  cluster f+*(x,y) -> total (X-defined Function);
  coherence
  proof
    dom (f+*(x,y)) = dom f by FUNCT_7:32
      .= X by PARTFUN1:def 4;
   hence thesis by PARTFUN1:def 4;
  end;
end;

canceled;

theorem Th7:
  for f being one-to-one Function holds card f = card rng f
proof
  let f be one-to-one Function;
A1: card rng f c= card dom f by CARD_2:80;
A2: card rng (f") c= card dom (f") by CARD_2:80;
  rng f = dom(f") & dom f = rng(f") by FUNCT_1:55;
  then card rng f = card dom f by A1,A2,XBOOLE_0:def 10;
  hence thesis by CARD_1:104;
end;

definition
  let A be set;
  let X be set, D be FinSequence-DOMAIN of A, p be PartFunc of X,D, i be set;
  redefine func p/.i -> Element of D;
  coherence;
end;

registration
  let X be set;
  cluster being_linear-order well-ordering Order of X;
  existence
  proof consider R being Relation such that
A1: R is well-ordering and
A2: field R = X by WELLSET1:9;
    reconsider R as Relation of X by A2,Th4;
A3: R is reflexive & R is transitive & R is antisymmetric &
    R is connected & R is well_founded by A1,WELLORD1:def 4;
    then R is_reflexive_in X by A2,RELAT_2:def 9;
    then dom R = X by ORDERS_1:98;
    then reconsider R as Order of X by A1,PARTFUN1:def 4,WELLORD1:def 4;
    take R;
    thus thesis by A1,A3,ORDERS_1:def 5;
  end;
end;

theorem Th8:
  for X being non empty set, A being non empty finite Subset of X,
  R being Order of X, x being Element of X st x in A & R linearly_orders A &
  for y being Element of X st y in A holds [x,y] in R
  holds (SgmX (R,A))/.1 = x
proof
  let X be non empty set, A be non empty finite Subset of X,
  R be Order of X, x be Element of X;
  assume that
A1: x in A and
A2: R linearly_orders A and
A3: for y being Element of X st y in A holds [x,y] in R and
A4: SgmX (R,A)/.1 <> x;
A5: A = rng SgmX (R,A) by A2,TRIANG_1:def 2;
  then consider i being Element of NAT such that
A6: i in dom SgmX (R,A) and
A7: SgmX (R,A)/.i = x by A1,PARTFUN2:4;
  1 <= i by A6,FINSEQ_3:27;
  then
A8: 1 < i by A4,A7,XXREAL_0:1;
  SgmX (R,A) is non empty by A2,RELAT_1:60,TRIANG_1:def 2;
  then
A9: 1 in dom SgmX (R,A) by FINSEQ_5:6;
  then
A10: [SgmX (R,A)/.1, x] in R by A2,A6,A7,A8,TRIANG_1:def 2;
  SgmX (R,A)/.1 in A by A5,A9,PARTFUN2:4;
  then
A11: [x, SgmX (R,A)/.1] in R by A3;
  field R = X by ORDERS_1:97;
  then R is_antisymmetric_in X by RELAT_2:def 12;
  hence contradiction by A4,A10,A11,RELAT_2:def 4;
end;

theorem Th9:
  for X being non empty set, A being non empty finite Subset of X,
  R being Order of X, x being Element of X st x in A & R linearly_orders A &
  for y being Element of X st y in A holds [y,x] in R
  holds SgmX (R,A)/.len SgmX (R,A) = x
proof
  let X be non empty set, A be non empty finite Subset of X,
  R be Order of X, x be Element of X;
  assume that
A1: x in A and
A2: R linearly_orders A and
A3: for y being Element of X st y in A holds [y,x] in R and
A4: SgmX (R,A)/.len SgmX (R,A) <> x;
A5: A = rng SgmX (R,A) by A2,TRIANG_1:def 2;
  then consider i being Element of NAT such that
A6: i in dom SgmX (R,A) and
A7: SgmX (R,A)/.i = x by A1,PARTFUN2:4;
  set L = len SgmX (R,A);
  i <= L by A6,FINSEQ_3:27;
  then
A8: i < L by A4,A7,XXREAL_0:1;
  SgmX (R,A) is non empty by A2,RELAT_1:60,TRIANG_1:def 2;
  then
A9: L in dom SgmX (R,A) by FINSEQ_5:6;
  then
A10: [x, SgmX (R,A)/.L] in R by A2,A6,A7,A8,TRIANG_1:def 2;
  SgmX (R,A)/.L in A by A5,A9,PARTFUN2:4;
  then
A11: [SgmX (R,A)/.L,x] in R by A3;
  field R = X by ORDERS_1:97;
  then R is_antisymmetric_in X by RELAT_2:def 12;
  hence contradiction by A4,A10,A11,RELAT_2:def 4;
end;

registration
  let X be non empty set, A be non empty finite Subset of X,
  R be being_linear-order Order of X;
  cluster SgmX(R, A) -> non empty one-to-one;
  coherence
  proof
    field R = X by ORDERS_1:100;
    then R linearly_orders A by ORDERS_1:133,134;
    hence thesis by RELAT_1:60,TRIANG_1:8,def 2;
  end;
end;

registration
  cluster empty -> FinSequence-yielding Function;
  coherence
  proof let F be Function such that
Z:  F is empty;
    let x be set; thus thesis by Z;
  end;
end;

definition
  let F, G be FinSequence-yielding FinSequence;
  redefine func F^^G -> FinSequence-yielding FinSequence;
  coherence
  proof
    dom (F^^G) = dom F /\ dom G by MATRLIN:def 2
      .= Seg len F /\ dom G by FINSEQ_1:def 3
      .= Seg len F /\ Seg len G by FINSEQ_1:def 3
      .= Seg min(len F, len G) by FINSEQ_2:2;
    hence thesis by FINSEQ_1:def 2;
  end;
end;

registration
  let i be Element of NAT, f be FinSequence;
  cluster i |-> f -> FinSequence-yielding;
  coherence
  proof
    let x be set;
    assume x in dom (i |-> f);
    then x in Seg i by FUNCOP_1:19;
    hence thesis by FUNCOP_1:13;
  end;
end;

registration
  let F be FinSequence-yielding FinSequence, x be set;
  cluster F.x -> FinSequence-like;
  coherence
  proof
    per cases;
    suppose not x in dom F;
      hence thesis by FUNCT_1:def 4;
    end;
    suppose x in dom F;
      hence thesis by MATRLIN:def 1;
    end;
  end;
end;

registration
  let F be FinSequence;
  cluster Card F -> FinSequence-like;
  coherence
  proof dom Card F = dom F by CARD_3:def 2
      .= Seg len F by FINSEQ_1:def 3;
    hence thesis by FINSEQ_1:def 2;
  end;
end;

registration
  cluster Cardinal-yielding FinSequence;
  existence
  proof
    take {};
    {} is Cardinal-yielding
    proof
      let x be set; thus thesis;
    end;
    hence thesis;
  end;
end;

theorem Th10:
  for f being Function holds
  f is Cardinal-yielding iff for y being set st y in rng f holds y is Cardinal
proof
  let f be Function;
  hereby
    assume
A1: f is Cardinal-yielding;
    let y be set;
    assume y in rng f;
    then ex x being set st x in dom f & y = f.x by FUNCT_1:def 5;
    hence y is Cardinal by A1,CARD_3:def 1;
  end;
  assume
A2: for y being set st y in rng f holds y is Cardinal;
  let x be set;
  assume x in dom f;
  then f.x in rng f by FUNCT_1:def 5;
  hence thesis by A2;
end;

registration
  let F, G be Cardinal-yielding FinSequence;
  cluster F^G -> Cardinal-yielding;
  coherence
  proof
A1: rng (F^G) = rng F \/ rng G by FINSEQ_1:44;
    now
      let y be set;
      assume y in rng (F^G);
      then y in rng F or y in rng G by A1,XBOOLE_0:def 3;
      hence y is Cardinal by Th10;
    end;
    hence thesis by Th10;
  end;
end;

registration
  cluster -> Cardinal-yielding FinSequence of NAT;
  coherence
  proof
    let f be FinSequence of NAT;
    let x be set;
    assume x in dom f;
    thus thesis;
  end;
end;

registration
  cluster Cardinal-yielding FinSequence of NAT;
  existence
  proof
    take <*>NAT; thus thesis;
  end;
end;

definition
  let D be set;
  let F be FinSequence of D*;
  redefine func Card F -> Cardinal-yielding FinSequence of NAT;
  coherence
  proof
    rng Card F c= NAT
    proof
      let y be set;
      assume y in rng Card F;
      then consider x being set such that
A1:   x in dom Card F & y = (Card F).x by FUNCT_1:def 5;
A2:   x in dom F by A1,CARD_3:def 2;
      reconsider Fx = F.x as finite set;
      y = card Fx by A1,A2,CARD_3:def 2;
      hence thesis;
    end;
    hence thesis by FINSEQ_1:def 4;
  end;
end;

registration
  let F be FinSequence of NAT, i be Element of NAT;
  cluster F|i -> Cardinal-yielding;
  coherence;
end;

theorem Th11:
  for F being Function, X being set holds Card (F|X) = (Card F)|X
proof
  let F be Function, X be set;
A1: dom ((Card F)|X) = dom (Card F) /\ X by RELAT_1:90
    .= dom F /\ X by CARD_3:def 2
    .= dom (F|X) by RELAT_1:90;
  now
    let x be set;
    assume
A2: x in dom (F|X);
A3: dom (F|X) c= dom F by RELAT_1:89;
    thus ((Card F)|X).x = (Card F).x by A1,A2,FUNCT_1:70
      .= card (F.x) by A2,A3,CARD_3:def 2
      .= card ((F|X).x) by A2,FUNCT_1:70;
  end;
  hence thesis by A1,CARD_3:def 2;
end;

registration
  let F be empty Function;
  cluster Card F -> empty;
  coherence
  proof dom F is empty;
    then dom Card F is empty by CARD_3:def 2;
    hence thesis;
  end;
end;

theorem Th12:
  for p being set holds Card <*p*> = <*card p*>
proof
  let p be set;
  set Cp = <*card p*>;
A1: dom Cp = {1} by FINSEQ_1:4,55;
  now
    let x be set;
    assume x in dom Cp;
    then x = 1 by A1,TARSKI:def 1;
    hence Cp.x is Cardinal by FINSEQ_1:57;
  end;
  then reconsider Cp as Cardinal-Function by CARD_3:def 1;
A2: dom <*p*> = {1} by FINSEQ_1:4,55;
  now
    let x be set;
    assume x in dom <*p*>;
    then
A3: x = 1 by A2,TARSKI:def 1;
    hence <*card p*>.x = card p by FINSEQ_1:57
      .= card (<*p*>.x) by A3,FINSEQ_1:57;
  end;
  then Card <*p*> = Cp by A1,A2,CARD_3:def 2;
  hence thesis;
end;

theorem Th13:
  for F, G be FinSequence holds Card (F^G) = Card F ^ Card G
proof
  let F, G be FinSequence;
A1: dom Card F = dom F by CARD_3:def 2;
A2: dom Card G = dom G by CARD_3:def 2;
A3: len Card F = len F by A1,FINSEQ_3:31;
A4: len Card G = len G by A2,FINSEQ_3:31;
A5: dom (Card F ^ Card G) = Seg (len Card F + len Card G) by FINSEQ_1:def 7
    .= dom (F ^ G) by A3,A4,FINSEQ_1:def 7;
  now
    let x be set;
    assume
A6: x in dom (F^G);
    then
A7: x in Seg (len F + len G) by FINSEQ_1:def 7;
    reconsider k = x as Element of NAT by A6;
A8: 1 <= k & k <= len F + len G by A7,FINSEQ_1:3;
    per cases;
    suppose k <= len F;
      then
A9:   k in dom F by A8,FINSEQ_3:27;
      hence (Card F ^ Card G).x = (Card F).k by A1,FINSEQ_1:def 7
        .= card (F.k) by A9,CARD_3:def 2
        .= card ((F^G).x) by A9,FINSEQ_1:def 7;
    end;
    suppose len F < k;
      then not k in dom F by FINSEQ_3:27;
      then consider n being Nat such that
A10:  n in dom G & k = len F + n by A6,FINSEQ_1:38;
      thus (Card F ^ Card G).x = (Card G).n by A2,A3,A10,FINSEQ_1:def 7
        .= card (G.n) by A10,CARD_3:def 2
        .= card ((F^G).x) by A10,FINSEQ_1:def 7;
    end;
  end;
  hence thesis by A5,CARD_3:def 2;
end;

registration
  let X be set;
  cluster <*>X -> FinSequence-yielding;
  coherence;
end;

registration
  let f be FinSequence;
  cluster <*f*> -> FinSequence-yielding;
  coherence
  proof
    let x be set;
    assume x in dom <*f*>;
    then x in {1} by FINSEQ_1:4,55;
    then x = 1 by TARSKI:def 1;
    hence thesis by FINSEQ_1:57;
  end;
end;

theorem Th14:
  for f being Function holds f is FinSequence-yielding
  iff for y being set st y in rng f holds y is FinSequence
proof
  let f be Function;
  hereby
    assume
A1: f is FinSequence-yielding;
    let y be set;
    assume y in rng f;
    then ex x being set st x in dom f & y = f.x by FUNCT_1:def 5;
    hence y is FinSequence by A1,MATRLIN:def 1;
  end;
  assume
A2: for y being set st y in rng f holds y is FinSequence;
  let x be set;
  assume x in dom f;
  then f.x in rng f by FUNCT_1:def 5;
  hence thesis by A2;
end;

registration
  let F, G be FinSequence-yielding FinSequence;
  cluster F^G -> FinSequence-yielding;
  coherence
  proof
A1: rng (F^G) = rng F \/ rng G by FINSEQ_1:44;
    now
      let y be set;
      assume y in rng (F^G);
      then y in rng F or y in rng G by A1,XBOOLE_0:def 3;
      hence y is FinSequence by Th14;
    end;
    hence thesis by Th14;
  end;
end;

theorem Th15:
  for L being non empty addLoopStr, F being FinSequence of (the carrier of L)*
  holds dom Sum F = dom F
proof
  let L be non empty addLoopStr, F be FinSequence of (the carrier of L)*;
  len Sum F = len F by MATRLIN:def 8;
  hence thesis by FINSEQ_3:31;
end;

theorem Th16:
  for L being non empty addLoopStr, F being FinSequence of (the carrier of L)*
  holds Sum (<*>((the carrier of L)*)) = <*>(the carrier of L)
proof
  let L be non empty addLoopStr, F be FinSequence of (the carrier of L)*;
  dom Sum (<*>((the carrier of L)*)) = dom (<*>((the carrier of L)*
  )) by Th15;
  hence thesis;
end;

theorem Th17:
  for L being non empty addLoopStr, p being Element of (the carrier of L)*
  holds <*Sum p*> = Sum<*p*>
proof
  let L be non empty addLoopStr, p be Element of (the carrier of L)*;
A1: dom <*Sum p*> = Seg 1 by FINSEQ_1:55
    .= dom <*p*> by FINSEQ_1:55;
  then
A2: len <*Sum p*> = len <*p*> by FINSEQ_3:31;
  now
    let i be Nat;
    assume i in dom<*p*>;
    then i in {1} by FINSEQ_1:4,55;
    then
A3: i = 1 by TARSKI:def 1;
    hence <*Sum p*>/.i = Sum p by FINSEQ_4:25
      .= Sum(<*p*>/.i) by A3,FINSEQ_4:25;
  end;
  hence thesis by A1,A2,MATRLIN:def 8;
end;

theorem Th18:

for L being non empty addLoopStr, F,G being FinSequence of (the carrier of L)*
  holds Sum(F^G) = Sum F ^ Sum G
proof
  let L be non empty addLoopStr, F, G be FinSequence of (the carrier of L)*;
A1: dom Sum F = dom F by Th15;
A2: dom Sum G = dom G by Th15;
A3: len Sum F = len F by A1,FINSEQ_3:31;
A4: len (Sum F^Sum G) = len Sum F + len Sum G by FINSEQ_1:35
    .= len F + len Sum G by A1,FINSEQ_3:31
    .= len F + len G by A2,FINSEQ_3:31
    .= len (F^G) by FINSEQ_1:35;
  then
A5: dom (Sum F^Sum G) = dom (F^G) by FINSEQ_3:31;
  now
    let i be Nat such that
A6: i in dom (F^G);
    per cases by A6,FINSEQ_1:38;
    suppose
A7:   i in dom F;
      thus (Sum F^Sum G)/.i = (Sum F^Sum G).i by A5,A6,PARTFUN1:def 8
        .= (Sum F).i by A1,A7,FINSEQ_1:def 7
        .= (Sum F)/.i by A1,A7,PARTFUN1:def 8
        .= Sum (F/.i) by A1,A7,MATRLIN:def 8
        .= Sum((F^G)/.i) by A7,FINSEQ_4:83;
    end;
    suppose ex n being Nat st n in dom G & i = len F + n;
      then consider n being Nat such that
A8:   n in dom G and
A9:   i = len F + n;
      thus (Sum F^Sum G)/.i = (Sum F^Sum G).i by A5,A6,PARTFUN1:def 8
        .= (Sum G).n by A2,A3,A8,A9,FINSEQ_1:def 7
        .= (Sum G)/.n by A2,A8,PARTFUN1:def 8
        .= Sum(G/.n) by A2,A8,MATRLIN:def 8
        .= Sum((F^G)/.i) by A8,A9,FINSEQ_4:84;
    end;
  end;
  hence thesis by A4,A5,MATRLIN:def 8;
end;

definition
  let L be non empty multMagma, p be FinSequence of the carrier of L,
  a be Element of L;
  canceled;
  redefine func a*p -> FinSequence of the carrier of L means
  :Def2:
  dom it = dom p &
  for i being set st i in dom p holds it/.i = a*(p/.i);
  compatibility
  proof
    set F = a*p;
A1: F = (a multfield)*p by FVSUM_1:def 6;
A2: rng p c= dom (a multfield)
    proof
      let x be set;
      dom (a multfield) = the carrier of L by FUNCT_2:def 1;
      hence thesis;
    end;
    then
A3: dom F = dom p by A1,RELAT_1:46;
A4: for i being set st i in dom p holds F/.i = a*(p/.i)
    proof
      let i be set;
      assume
A5:   i in dom p;
      F.i = ((a multfield)*p).i by FVSUM_1:def 6
        .= (a multfield).(p.i) by A5,FUNCT_1:23
        .= (a multfield).(p/.i) by A5,PARTFUN1:def 8
        .= a * (p/.i) by FVSUM_1:61;
      hence thesis by A3,A5,PARTFUN1:def 8;
    end;
    now
      let G be FinSequence of the carrier of L;
      assume
A6:   dom G = dom p & for i being set st i in dom p holds G/.i = a*(p/.i);
      set R = (a multfield)*p;
A7:   rng p c= the carrier of L;
      dom (a multfield) = the carrier of L by FUNCT_2:def 1;
      then
A8:   dom G = dom R by A6,A7,RELAT_1:46;
      for k being set st k in dom G holds G.k = R.k
      proof
        let k be set;
        assume
A9:     k in dom G;
        then G.k = G/.k by PARTFUN1:def 8
          .= a*(p/.k) by A6,A9
          .= (a multfield).(p/.k) by FVSUM_1:61
          .= (a multfield).(p.k) by A6,A9,PARTFUN1:def 8
          .= R.k by A6,A9,FUNCT_1:23;
        hence thesis;
      end;
      then G = R by A8,FUNCT_1:9;
      hence G = a * p by FVSUM_1:def 6;
    end;
    hence thesis by A1,A2,A4,RELAT_1:46;
  end;
  correctness;
end;

definition
  let L be non empty multMagma, p be FinSequence of the carrier of L,
  a be Element of L;
  func p*a -> FinSequence of the carrier of L means
  :Def3:
  dom it = dom p &
  for i being set st i in dom p holds it/.i = (p/.i)*a;
  existence
  proof
    deffunc F(set) = (p/.$1)*a;
    consider f being FinSequence of the carrier of L such that
A1: len f = len p and
A2: for j being Nat st j in dom f holds f/.j = F(j)
    from FINSEQ_4:sch 2;
    take f; thus
A3: dom f = dom p by A1,FINSEQ_3:31;
    let j be set;
    assume
   j in dom p;
    hence thesis by A2,A3;
  end;
  uniqueness
  proof
    let it1, it2 be FinSequence of the carrier of L such that
A4: dom it1 = dom p and
A5: for i being set st i in dom p holds it1/.i = (p/.i)*a and
A6: dom it2 = dom p and
A7: for i being set st i in dom p holds it2/.i = (p/.i)*a;
    now
      let j be Nat;
      assume
A8:   j in dom p;
      hence it1/.j = (p/.j)*a by A5
        .= it2/.j by A7,A8;
    end;
    hence thesis by A4,A6,FINSEQ_5:13;
  end;
end;

theorem Th19:
  for L being non empty multMagma, a being Element of L
  holds a*<*>(the carrier of L) = <*>(the carrier of L)
proof
  let L be non empty multMagma, a be Element of L;
  dom (a*<*>(the carrier of L)) = dom <*>(the carrier of L) by Def2;
  hence thesis;
end;

theorem Th20:
  for L being non empty multMagma, a being Element of L
  holds (<*>the carrier of L)*a = <*>(the carrier of L)
proof
  let L be non empty multMagma, a be Element of L;
  dom((<*>the carrier of L)*a) = dom <*>(the carrier of L) by Def3;
  hence thesis;
end;

theorem Th21:
  for L being non empty multMagma, a, b being Element of L
  holds a*<*b*> = <*a*b*>
proof
  let L be non empty multMagma, a, b be Element of L;
A1: dom<*a*b*> = Seg 1 by FINSEQ_1:55
    .= dom<*b*> by FINSEQ_1:55;
  for i being set st i in dom<*b*> holds <*a*b*>/.i = a*(<*b*>/.i)
  proof
    let i be set;
    assume i in dom<*b*>;
    then i in {1} by FINSEQ_1:4,55;
    then
A2: i = 1 by TARSKI:def 1;
    hence <*a*b*>/.i = a*b by FINSEQ_4:25
      .= a*(<*b*>/.i) by A2,FINSEQ_4:25;
  end;
  hence thesis by A1,Def2;
end;

theorem Th22:
  for L being non empty multMagma, a, b being Element of L
  holds <*b*>*a = <*b*a*>
proof
  let L be non empty multMagma, a, b be Element of L;
A1: dom<*b*a*> = Seg 1 by FINSEQ_1:55
    .= dom<*b*> by FINSEQ_1:55;
  for i being set st i in dom<*b*> holds <*b*a*>/.i = (<*b*>/.i)*a
  proof
    let i be set;
    assume i in dom<*b*>;
    then i in {1} by FINSEQ_1:4,55;
    then
A2: i = 1 by TARSKI:def 1;
    hence <*b*a*>/.i = b*a by FINSEQ_4:25
      .= (<*b*>/.i)*a by A2,FINSEQ_4:25;
  end;
  hence thesis by A1,Def3;
end;

theorem Th23:
  for L being non empty multMagma, a being Element of L,
  p, q being FinSequence of the carrier of L holds a*(p^q) = (a*p)^(a*q)
proof
  let L be non empty multMagma, a be Element of L,
  p, q be FinSequence of the carrier of L;
A1: dom (a*p) = dom p by Def2;
  then
A2: len (a*p) = len p by FINSEQ_3:31;
A3: dom (a*q) = dom q by Def2;
  then
A4: len (a*q) = len q by FINSEQ_3:31;
A5: len ((a*p)^(a*q)) = len (a*p) + len (a*q) by FINSEQ_1:35
    .= len (p^q) by A2,A4,FINSEQ_1:35;
A6: dom (a*(p^q)) = dom (p^q) by Def2;
  then
A7: dom (a*(p^q)) = dom ((a*p)^(a*q)) by A5,FINSEQ_3:31;
  now
    let i be Nat;
    assume
A8: i in dom (a*(p^q));
    per cases by A6,A8,FINSEQ_1:38;
    suppose
A9:   i in dom p;
      thus (a*(p^q))/.i = a*((p^q)/.i) by A6,A8,Def2
        .= a*(p/.i) by A9,FINSEQ_4:83
        .= (a*p)/.i by A9,Def2
        .= ((a*p)^(a*q))/.i by A1,A9,FINSEQ_4:83;
    end;
    suppose ex n being Nat st n in dom q & i = len p+n;
      then consider n being Nat such that
A10:  n in dom q & i = len p+n;
      thus (a*(p^q))/.i = a*((p^q)/.i) by A6,A8,Def2
        .= a*(q/.n) by A10,FINSEQ_4:84
        .= (a*q)/.n by A10,Def2
        .= ((a*p)^(a*q))/.i by A2,A3,A10,FINSEQ_4:84;
    end;
  end;
  hence thesis by A7,FINSEQ_5:13;
end;

theorem Th24:
  for L being non empty multMagma, a being Element of L,
  p, q being FinSequence of the carrier of L holds (p^q)*a = (p*a)^(q*a)
proof
  let L be non empty multMagma, a be Element of L,
  p, q be FinSequence of the carrier of L;
A1: dom (p*a) = dom p by Def3;
  then
A2: len (p*a) = len p by FINSEQ_3:31;
A3: dom (q*a) = dom q by Def3;
  then
A4: len (q*a) = len q by FINSEQ_3:31;
A5: len ((p*a)^(q*a)) = len (p*a) + len (q*a) by FINSEQ_1:35
    .= len (p^q) by A2,A4,FINSEQ_1:35;
A6: dom ((p^q)*a) = dom (p^q) by Def3;
  then
A7: dom ((p^q)*a) = dom ((p*a)^(q*a)) by A5,FINSEQ_3:31;
  now
    let i be Nat;
    assume
A8: i in dom ((p^q)*a);
    per cases by A6,A8,FINSEQ_1:38;
    suppose
A9:   i in dom p;
      thus ((p^q)*a)/.i = ((p^q)/.i)*a by A6,A8,Def3
        .= (p/.i)*a by A9,FINSEQ_4:83
        .= (p*a)/.i by A9,Def3
        .= ((p*a)^(q*a))/.i by A1,A9,FINSEQ_4:83;
    end;
    suppose ex n being Nat st n in dom q & i = len p+n;
      then consider n being Nat such that
A10:  n in dom q & i = len p+n;
      thus (p^q*a)/.i = ((p^q)/.i)*a by A6,A8,Def3
        .= (q/.n)*a by A10,FINSEQ_4:84
        .= (q*a)/.n by A10,Def3
        .= ((p*a)^(q*a))/.i by A2,A3,A10,FINSEQ_4:84;
    end;
  end;
  hence thesis by A7,FINSEQ_5:13;
end;

registration
  cluster non degenerated -> non trivial (non empty multLoopStr_0);
  coherence;
end;

registration
  cluster right_unital (non empty strict multLoopStr_0);
  existence
  proof
    take multEX_0;
    thus thesis;
  end;
end;

registration
  cluster strict Abelian add-associative right_zeroed right_complementable
    associative commutative distributive almost_left_invertible
    well-unital non trivial (non empty doubleLoopStr);
  existence
  proof
    take F_Real; thus thesis;
  end;
end;

canceled 2;

theorem Th27:
  for L being add-associative right_zeroed right_complementable
  right_unital right-distributive (non empty doubleLoopStr) st 0.L = 1.L
  holds L is trivial
proof
  let L be add-associative right_zeroed right_complementable
  right_unital right-distributive (non empty doubleLoopStr) such that
A1: 0.L = 1.L;
  let u be Element of L;
  thus u = u*0.L by A1,VECTSP_1:def 13
    .= 0.L by VECTSP_1:36;
end;

theorem Th28:
  for L being add-associative right_zeroed right_complementable
  right_unital distributive (non empty doubleLoopStr), a being Element of L,
  p being FinSequence of the carrier of L holds Sum (a*p) = a*Sum p
proof
  let L be add-associative right_zeroed right_complementable
  right_unital distributive (non empty doubleLoopStr), a be Element of L;
  set p = <*>(the carrier of L);
A1: Sum p = 0.L by RLVECT_1:60;
  defpred P[FinSequence of the carrier of L] means Sum (a*$1) = a*Sum $1;
  Sum (a*p) = Sum p by Th19;
  then
A2: P[p] by A1,VECTSP_1:36;
A3: now
    let p be FinSequence of the carrier of L, r be Element of L such that
A4: P[p];
    Sum (a*(p^<*r*>)) = Sum ((a*p)^(a*<*r*>)) by Th23
      .= Sum (a*p) + Sum (a*<*r*>) by RLVECT_1:58
      .= Sum (a*p) + Sum (<*a*r*>) by Th21
      .= Sum (a*p) + a*r by RLVECT_1:61
      .= a*Sum p + a*Sum<*r*> by A4,RLVECT_1:61
      .= a*(Sum p + Sum<*r*>) by VECTSP_1:def 18
      .= a*Sum (p^<*r*>) by RLVECT_1:58;
    hence P[p^<*r*>];
  end;
  thus for p being FinSequence of the carrier of L holds P[p]
  from FINSEQ_2:sch 2(A2,A3);
end;

theorem Th29:
  for L being add-associative right_zeroed right_complementable
  right_unital distributive (non empty doubleLoopStr), a being Element of L,
  p being FinSequence of the carrier of L holds Sum (p*a) = (Sum p)*a
proof
  let L be add-associative right_zeroed right_complementable
  right_unital distributive (non empty doubleLoopStr), a be Element of L;
  set p = <*>(the carrier of L);
A1: Sum p = 0.L by RLVECT_1:60;
  defpred P[FinSequence of the carrier of L] means Sum ($1*a) = (Sum $1)*a;
  Sum (p*a) = Sum p by Th20;
  then
A2: P[p] by A1,VECTSP_1:39;
A3: now
    let p be FinSequence of the carrier of L, r be Element of L such that
A4: P[p];
    Sum ((p^<*r*>)*a) = Sum ((p*a)^(<*r*>*a)) by Th24
      .= Sum (p*a) + Sum (<*r*>*a) by RLVECT_1:58
      .= Sum (p*a) + Sum (<*r*a*>) by Th22
      .= Sum (p*a) + r*a by RLVECT_1:61
      .= (Sum p)*a + (Sum<*r*>)*a by A4,RLVECT_1:61
      .= (Sum p + Sum<*r*>)*a by VECTSP_1:def 18
      .= (Sum (p^<*r*>))*a by RLVECT_1:58;
    hence P[p^<*r*>];
  end;
  thus for p being FinSequence of the carrier of L holds P[p]
  from FINSEQ_2:sch 2(A2,A3);
end;

begin :: Sequence flattening --------------------------------------------------

registration
  let D be set, F be empty FinSequence of D*;
  cluster FlattenSeq F -> empty;
  coherence
  proof F = <*>(D*);
    then FlattenSeq F = <*>D by DTCONSTR:20;
    hence thesis;
  end;
end;

theorem Th30:
  for D being set, F being FinSequence of D*
  holds len FlattenSeq F = Sum Card F
proof
  let D be set;
  defpred P[FinSequence of D*] means len FlattenSeq $1 = Sum Card $1;
A1: P[<*>(D*)] by RVSUM_1:102;
A2: now
    let F be FinSequence of D*, p be Element of D* such that
A3: P[F];
    len FlattenSeq (F^<*p*>)
    = len (FlattenSeq F ^ FlattenSeq <*p*>) by DTCONSTR:21
      .= (Sum Card F) + len FlattenSeq <*p*> by A3,FINSEQ_1:35
      .= (Sum Card F) + len p by DTCONSTR:13
      .= Sum ((Card F)^<*len p*>) by RVSUM_1:104
      .= Sum ((Card F) ^ Card <*p*>) by Th12
      .= Sum Card (F^<*p*>) by Th13;
    hence P[F^<*p*>];
  end;
  thus for F be FinSequence of D* holds P[F] from FINSEQ_2:sch 2(A1,A2);
end;

theorem Th31:
  for D, E being set, F being FinSequence of D*, G being FinSequence of E*
  st Card F = Card G holds len FlattenSeq F = len FlattenSeq G
proof
  let D, E be set, F be FinSequence of D*, G be FinSequence of E*;
  assume Card F = Card G;
  hence len FlattenSeq F = Sum Card G by Th30
    .= len FlattenSeq G by Th30;
end;

theorem Th32:
  for D being set, F being FinSequence of D*, k being set
  st k in dom FlattenSeq F
  ex i, j being Element of NAT st i in dom F & j in dom (F.i) &
  k = (Sum Card (F|(i-'1))) + j & (F.i).j = (FlattenSeq F).k
proof
  let D be set;
  set F = <*>(D*);
  defpred P[FinSequence of D*] means for k being set st k in dom FlattenSeq $1
  ex i,j be Element of NAT st i in dom $1 & j in dom ($1.i) &
  k = (Sum Card ($1|(i-'1))) + j & ($1.i).j = (FlattenSeq $1).k;
A1: P[F];
A2: for F be FinSequence of D*, p be Element of D* st P[F] holds P[F^<*p*>]
  proof
    let F be FinSequence of D*, p be Element of D*;
    assume
A3: P[F];
    let k be set;
    assume
A4: k in dom FlattenSeq (F^<*p*>);
    then reconsider m = k as Element of NAT;
A5: FlattenSeq (F^<*p*>) = FlattenSeq F ^ FlattenSeq <*p*> by DTCONSTR:21
      .= FlattenSeq F ^ p by DTCONSTR:13;
A6: Sum Card F = len FlattenSeq F by Th30;
A7: (F^<*p*>)|len F = F by FINSEQ_5:26;
    per cases;
    suppose
A8:   not k in dom FlattenSeq F;
      take i = len F + 1;
      take j = m-'Sum Card ((F^<*p*>)|(i-'1));
A9:   (Sum Card ((F^<*p*>)|(i-'1))) = len FlattenSeq F by A6,A7,NAT_D:34;
      1 <= m by A4,FINSEQ_3:27;
      then
A10:  len FlattenSeq F < m by A8,FINSEQ_3:27;
A11:  len (F^<*p*>) = len F + len <*p*> by FINSEQ_1:35
        .= len F +1 by FINSEQ_1:56;
      1 in dom <*p*> by FINSEQ_5:6;
      then
A12:  (F^<*p*>).i = <*p*>.1 by FINSEQ_1:def 7
        .= p by FINSEQ_1:57;
      1 <= len F +1 by NAT_1:11;
      hence i in dom (F^<*p*>) by A11,FINSEQ_3:27;
      len FlattenSeq F +1 <= m by A10,NAT_1:13;
      then
A13:  1 <= j by A9,NAT_D:55;
      m <= len (FlattenSeq F ^ p) by A4,A5,FINSEQ_3:27;
      then m <= len FlattenSeq F + len p by FINSEQ_1:35;
      then j <= len p by A9,NAT_D:53;
      hence
A14:  j in dom ((F^<*p*>).i) by A12,A13,FINSEQ_3:27;
      thus k = (Sum Card ((F^<*p*>)|(i-'1))) + j by A9,A10,XREAL_1:237;
      hence thesis
      by A5,A9,A12,A14,FINSEQ_1:def 7;
    end;
    suppose
A15:  k in dom FlattenSeq F;
      then consider i, j being Element of NAT such that
A16:  i in dom F and
A17:  j in dom (F.i) and
A18:  k = (Sum Card (F|(i-'1))) + j and
A19:  (F.i).j = (FlattenSeq F).k by A3;
      take i, j;
      dom F c= dom (F^<*p*>) by FINSEQ_1:39;
      hence i in dom (F^<*p*>) by A16;
A20:  (F^<*p*>).i = (F.i) by A16,FINSEQ_1:def 7;
      thus j in dom ((F^<*p*>).i) by A16,A17,FINSEQ_1:def 7;
A21:  i <= len F by A16,FINSEQ_3:27;
      i-'1 <= i by NAT_D:35;
      hence k = (Sum Card ((F^<*p*>)|(i-'1))) + j by A18,A21,FINSEQ_5:25
,XXREAL_0:2;
      ((F^<*p*>).i).j = (FlattenSeq (F^<*p*>)).m
      by A5,A15,A19,A20,FINSEQ_1:def 7;
      hence thesis;
    end;
  end;
  thus for F being FinSequence of D* holds P[F] from FINSEQ_2:sch 2(A1,A2);
end;

theorem Th33:
  for D being set, F being FinSequence of D*, i, j being Element of NAT
  st i in dom F & j in dom (F.i)
  holds (Sum Card (F|(i-'1))) + j in dom FlattenSeq F &
  (F.i).j = (FlattenSeq F).((Sum Card (F|(i-'1))) + j)
proof
  let D be set;
  set F = <*>(D*);
  defpred P[FinSequence of D*] means
  for i, j be Element of NAT st i in dom $1 & j in dom ($1.i) holds
  (Sum Card ($1|(i-'1))) + j in dom FlattenSeq $1 &
  ($1.i).j = (FlattenSeq $1).((Sum Card ($1|(i-'1))) + j);
A1: P[F];
A2: for F be FinSequence of D*, p be Element of D* st P[F] holds P[F^<*p*>]
  proof
    let F be FinSequence of D*, p be Element of D*;
    assume
A3: for i, j being Element of NAT st i in dom F & j in dom (F.i)
    holds (Sum Card (F|(i-'1))) + j in dom FlattenSeq F &
    (F.i).j = (FlattenSeq F).((Sum Card (F|(i-'1))) + j);
    let i, j be Element of NAT;
    assume that
A4: i in dom (F^<*p*>) and
A5: j in dom ((F^<*p*>).i);
A6: FlattenSeq (F^<*p*>) = FlattenSeq F ^ FlattenSeq <*p*> by DTCONSTR:21
      .= FlattenSeq F ^ p by DTCONSTR:13;
    per cases;
    suppose
A7:   not i in dom F;
A8:   len (F^<*p*>) = len F + len <*p*> by FINSEQ_1:35
        .= len F + 1 by FINSEQ_1:57;
A9:   1 <= i & i <= len (F^<*p*>) by A4,FINSEQ_3:27;
      then len F < i by A7,FINSEQ_3:27;
      then len F + 1 <= i by NAT_1:13;
      then
A10:  i = len F + 1 by A8,A9,XXREAL_0:1;
      then
A11:  i-'1 = len F by NAT_D:34;
      1 in dom <*p*> by FINSEQ_5:6;
      then
A12:  (F^<*p*>).i = <*p*>.1 by A10,FINSEQ_1:def 7
        .= p by FINSEQ_1:57;
A13:  (F^<*p*>)|(i-'1) = F by A11,FINSEQ_5:26;
A14:  Sum Card F = len FlattenSeq F by Th30;
      hence (Sum Card ((F^<*p*>)|(i-'1))) + j in dom FlattenSeq (F^<*p*>)
      by A5,A6,A12,A13,FINSEQ_1:41;
      thus thesis by A5,A6,A12,A13,A14,FINSEQ_1:def 7;
    end;
    suppose
A15:  i in dom F;
      then
A16:  i <= len F by FINSEQ_3:27;
      i-'1 <= i by NAT_D:35;
      then
A17:  (F^<*p*>)|(i-'1) = F|(i-'1) by A16,FINSEQ_5:25,XXREAL_0:2;
A18:  dom FlattenSeq F c= dom FlattenSeq (F^<*p*>) by A6,FINSEQ_1:39;
A19:  j in dom (F.i) by A5,A15,FINSEQ_1:def 7;
      then
A20:  (Sum Card (F|(i-'1))) + j in dom FlattenSeq F by A3,A15;
      hence (Sum
      Card ((F^<*p*>)|(i-'1))) + j in dom FlattenSeq (F^<*p*>) by A17,A18;
      thus ((F^<*p*>).i).j = (F.i).j by A15,FINSEQ_1:def 7
        .= (FlattenSeq F).((Sum Card (F|(i-'1))) + j) by A3,A15,A19
        .= (FlattenSeq (F^<*p*>)).((Sum Card ((F^<*p*>)|(i-'1)))+j)
      by A6,A17,A20,FINSEQ_1:def 7;
    end;
  end;
  thus for F being FinSequence of D* holds P[F] from FINSEQ_2:sch 2(A1,A2);
end;

theorem Th34:
  for L being add-associative right_zeroed right_complementable
  (non empty addLoopStr), F being FinSequence of (the carrier of L)*
  holds Sum FlattenSeq F = Sum Sum F
proof
  let L be add-associative right_zeroed right_complementable
  (non empty addLoopStr);
  defpred P[FinSequence of (the carrier of L)*] means
  Sum FlattenSeq $1 = Sum Sum $1;
  Sum FlattenSeq(<*>((the carrier of L)*)) = Sum <*>(the carrier of L);
  then
A1: P[<*>((the carrier of L)*)] by Th16;
A2: for f being FinSequence of (the carrier of L)*,
  p being Element of (the carrier of L)* st P[f] holds P[f^<*p*>]
  proof
    let f be FinSequence of (the carrier of L)*,
    p be Element of (the carrier of L)* such that
A3: Sum FlattenSeq f = Sum Sum f;
    thus Sum FlattenSeq(f^<*p*>)
    = Sum((FlattenSeq f)^FlattenSeq <*p*>) by DTCONSTR:21
      .= Sum((FlattenSeq f)^p) by DTCONSTR:13
      .= Sum Sum f +Sum p by A3,RLVECT_1:58
      .= Sum Sum f+Sum<*Sum p*> by RLVECT_1:61
      .= Sum(Sum f^<*Sum p*>) by RLVECT_1:58
      .= Sum(Sum f^Sum<*p*>) by Th17
      .= Sum Sum(f^<*p*>) by Th18;
  end;
  thus for f be FinSequence of (the carrier of L)* holds P[f]
  from FINSEQ_2:sch 2(A1,A2);
end;

theorem Th35:
  for X, Y being non empty set, f being FinSequence of X*,
  v being Function of X, Y holds (dom f --> v)**f is FinSequence of Y*
proof
  let X, Y be non empty set, f be FinSequence of X*, v be Function of X, Y;
  set F = (dom f --> v)**f;
A1: dom F = dom (dom f --> v) /\ dom f by PBOOLE:def 24
    .= dom f /\ dom f by FUNCOP_1:19
    .= dom f;
  then dom F = Seg len f by FINSEQ_1:def 3;
  then
A2: F is FinSequence-like by FINSEQ_1:def 2;
  rng F c= Y*
  proof
    let y be set;
    assume y in rng F;
    then consider x being set such that
A3: x in dom F & y = F.x by FUNCT_1:def 5;
    reconsider x as Element of NAT by A1,A3;
A4: y = (dom f --> v).x * (f.x) by A3,PBOOLE:def 24
      .= v*(f.x) by A1,A3,FUNCOP_1:13;
    f.x in X* by A1,A3,FINSEQ_2:13;
    then f.x is FinSequence of X by FINSEQ_1:def 11;
    then y is FinSequence of Y by A4,FINSEQ_2:36;
    hence thesis by FINSEQ_1:def 11;
  end;
  hence thesis by A2,FINSEQ_1:def 4;
end;

theorem Th36:
  for X, Y being non empty set, f being FinSequence of X*,
  v being Function of X, Y ex F being FinSequence of Y*
  st F = (dom f --> v)**f & v*FlattenSeq f = FlattenSeq F
proof
  let X, Y be non empty set, f be FinSequence of X*, v be Function of X, Y;
  reconsider F = (dom f --> v)**f as FinSequence of Y* by Th35;
  take F;
  thus F = (dom f --> v)**f;
  set Fl = FlattenSeq F;
  set fl = FlattenSeq f;
  reconsider vfl = v*fl as FinSequence of Y by FINSEQ_2:36;
  now
    len fl = len vfl by FINSEQ_2:37;
    hence
A1: dom fl = dom vfl by FINSEQ_3:31;
A2: dom f = dom Card f by CARD_3:def 2;
A3: dom F = dom (dom f --> v) /\ dom f by PBOOLE:def 24
      .= dom f /\ dom f by FUNCOP_1:19
      .= dom f;
    then
A4: dom f = dom Card F by CARD_3:def 2;
    now
      let k be set;
      assume
A5:   k in dom f;
      then reconsider k1=k as Element of NAT;
A6:   F.k = ((dom f --> v).k)*(f.k) by A3,A5,PBOOLE:def 24
        .= v*(f.k) by A5,FUNCOP_1:13;
      f.k1 in X* by A5,FINSEQ_2:13;
      then reconsider fk = f.k as FinSequence of X by FINSEQ_1:def 11;
      thus (Card f).k = len fk by A5,CARD_3:def 2
        .= len (F.k) by A6,FINSEQ_2:37
        .= (Card F).k by A3,A5,CARD_3:def 2;
    end;
    then
A7: Card f = Card F by A2,A4,FUNCT_1:9;
    then len fl = len Fl by Th31;
    hence dom fl = dom Fl by FINSEQ_3:31;
    let k be Nat;
    assume
A8: k in dom fl;
    then consider i, j being Element of NAT such that
A9: i in dom f and
A10: j in dom (f.i) and
A11: k = (Sum Card (f|(i-'1))) + j and
A12: (f.i).j = fl.k by Th32;
A13: dom v = X by FUNCT_2:def 1;
    f.i in X* by A9,FINSEQ_2:13;
    then f.i is FinSequence of X by FINSEQ_1:def 11;
    then rng (f.i) c= dom v by A13,FINSEQ_1:def 4;
    then
A14: j in dom (v*(f.i)) by A10,RELAT_1:46;
A15: F.i = ((dom f --> v).i)*(f.i) by A3,A9,PBOOLE:def 24
      .= v*(f.i) by A9,FUNCOP_1:13;
    f.i in X* by A9,FINSEQ_2:13;
    then reconsider fi = f.i as FinSequence of X by FINSEQ_1:def 11;
    len fi = len (F.i) by A15,FINSEQ_2:37;
    then
A16: j in dom (F.i) by A10,FINSEQ_3:31;
    Card (F|(i-'1)) = Card (F|Seg (i-'1)) by FINSEQ_1:def 15
      .= (Card f)|Seg (i-'1) by A7,Th11
      .= Card (f|Seg(i-'1)) by Th11
      .= Card (f|(i-'1)) by FINSEQ_1:def 15;
    then Fl.k = (F.i).j by A3,A9,A11,A16,Th33
      .= (((dom f --> v).i)*(f.i)).j by A3,A9,PBOOLE:def 24
      .= (v*(f.i)).j by A9,FUNCOP_1:13
      .= v.((f.i).j) by A14,FUNCT_1:22;
    hence vfl.k = Fl.k by A1,A8,A12,FUNCT_1:22;
  end;
  hence thesis by FINSEQ_1:17;
end;

begin :: Functions yielding natural and real numbers -------------------------

registration
  let f be natural-valued Function, x be set, n be natural number;
  cluster f+*(x,n) -> natural-valued;
  coherence
  proof
    set F = f+*(x,n);
    let a be set such that a in dom F;
    per cases;
    suppose x in dom f & x = a;
      hence thesis by FUNCT_7:33;
    end;
    suppose x in dom f & x <> a;
      then F.a = f.a by FUNCT_7:34;
      hence thesis;
    end;
    suppose not x in dom f;
      then F.a = f.a by FUNCT_7:def 3;
      hence thesis;
    end;
  end;
end;

registration
  let f be real-valued Function, x be set, n be real number;
  cluster f+*(x,n) -> real-valued;
  coherence
  proof
    set F = f+*(x,n);
    let a be set such that a in dom F;
    per cases;
    suppose x in dom f & x = a;
      hence thesis by FUNCT_7:33;
    end;
    suppose x in dom f & x <> a;
      then F.a = f.a by FUNCT_7:34;
      hence thesis;
    end;
    suppose not x in dom f;
      then F.a = f.a by FUNCT_7:def 3;
      hence thesis;
    end;
  end;
end;

registration
  let X be set;
  cluster natural-valued ManySortedSet of X;
  existence
  proof
    set f = X --> 0;
    dom f = X by FUNCOP_1:19;
    then reconsider f as ManySortedSet of X by PARTFUN1:def 4;
    take f;
    thus thesis;
  end;
end;

registration
  let X be set;
  cluster real-valued ManySortedSet of X;
  existence
  proof
    consider b being natural-valued ManySortedSet of X;
    b is real-valued;
    hence thesis;
  end;
end;

registration
  let X be set;
  cluster real-valued ManySortedSet of X;
  existence
  proof
    consider b being natural-valued ManySortedSet of X;
    b is real-valued;
    hence thesis;
  end;
end;

definition
  let X be set, b1, b2 be complex-valued ManySortedSet of X;
  canceled;
  redefine func b1+b2 -> ManySortedSet of X means
  :Def5:
  for x being set holds it.x = b1.x+b2.x;
  coherence
  proof
A1: dom b1 = X & dom b2 = X by PARTFUN1:def 4;
    X /\ X = X;
    then dom(b1+b2) = X by A1,VALUED_1:def 1;
   hence thesis by PARTFUN1:def 4,RELAT_1:def 18;
  end;
  compatibility
  proof
    let f be ManySortedSet of X;
A2: dom b1 = X & dom b2 = X by PARTFUN1:def 4;
    then
A3: dom f = dom b1 /\ dom b2 by PARTFUN1:def 4;
    thus f = b1+b2 implies for x being set holds f.x = b1.x+b2.x
    proof
      assume
A4:   f = b1+b2;
      let x be set;
      per cases;
      suppose x in X;
        hence thesis by A2,A3,A4,VALUED_1:def 1;
      end;
      suppose
A5:     not x in X;
        then b1.x = 0 & b2.x = 0 by A2,FUNCT_1:def 4;
        hence thesis by A2,A3,A5,FUNCT_1:def 4;
      end;
    end;
    assume for x being set holds f.x = b1.x+b2.x;
    then for c being set st c in dom f holds f.c = b1.c+b2.c;
    hence thesis by A3,VALUED_1:def 1;
  end;
end;

definition
  let X be set, b1, b2 be natural-valued ManySortedSet of X;
  func b1 -' b2 -> ManySortedSet of X means
  :Def6:
  for x being set holds it.x = b1.x -' b2.x;
  existence
  proof
    deffunc F(set) = b1.$1 -' b2.$1;
    consider f being ManySortedSet of X such that
A1: for i being set st i in X holds f.i = F(i) from PBOOLE:sch 4;
    take f;
    let x be set;
    per cases;
    suppose x in X;
      hence thesis by A1;
    end;
    suppose
A2:   not x in X;
A3:   dom f = X by PARTFUN1:def 4;
A4:   dom b1 = X by PARTFUN1:def 4;
A5:   dom b2 = X by PARTFUN1:def 4;
      thus f.x = 0 by A2,A3,FUNCT_1:def 4
        .= 0-'0 by XREAL_1:234
        .= 0-'b2.x by A2,A5,FUNCT_1:def 4
        .= b1.x-'b2.x by A2,A4,FUNCT_1:def 4;
    end;
  end;
  uniqueness
  proof
    let it1, it2 be ManySortedSet of X such that
A6: for x being set holds it1.x = b1.x-'b2.x and
A7: for x being set holds it2.x = b1.x-'b2.x;
    now
      let x be set;
      assume x in X;
      thus it1.x = b1.x-'b2.x by A6
        .= it2.x by A7;
    end;
    hence it1 = it2 by PBOOLE:3;
  end;
end;

theorem
  for X being set, b, b1, b2 being real-valued ManySortedSet of X
  st for x being set st x in X holds b.x = b1.x+b2.x holds b = b1+b2
proof
  let X be set, b, b1, b2 be real-valued ManySortedSet of X;
  assume
A1: for x being set st x in X holds b.x = b1.x+b2.x;
  now
    let x be set;
    per cases;
    suppose x in X;
      hence b.x = b1.x+b2.x by A1;
    end;
    suppose
A2:   not x in X;
A3:   dom b = X by PARTFUN1:def 4;
A4:   dom b1 = X by PARTFUN1:def 4;
A5:   dom b2 = X by PARTFUN1:def 4;
      thus b.x = 0 qua Nat + (0 qua Nat) by A2,A3,FUNCT_1:def 4
        .= 0 qua Nat+b2.x by A2,A5,FUNCT_1:def 4
        .= b1.x+b2.x by A2,A4,FUNCT_1:def 4;
    end;
  end;
  hence thesis by Def5;
end;

theorem Th38:
  for X being set, b, b1, b2 being natural-valued ManySortedSet of X
  st for x being set st x in X holds b.x = b1.x-'b2.x holds b = b1-'b2
proof
  let X be set, b, b1, b2 be natural-valued ManySortedSet of X;
  assume
A1: for x being set st x in X holds b.x = b1.x-'b2.x;
  now
    let x be set;
    per cases;
    suppose x in X;
      hence b.x = b1.x -' b2.x by A1;
    end;
    suppose
A2:   not x in X;
A3:   dom b = X by PARTFUN1:def 4;
A4:   dom b1 = X by PARTFUN1:def 4;
A5:   dom b2 = X by PARTFUN1:def 4;
      thus b.x = 0 by A2,A3,FUNCT_1:def 4
        .= 0-'0 by XREAL_1:234
        .= 0-'b2.x by A2,A5,FUNCT_1:def 4
        .= b1.x-'b2.x by A2,A4,FUNCT_1:def 4;
    end;
  end;
  hence thesis by Def6;
end;

registration
  let X be set, b1, b2 be natural-valued ManySortedSet of X;
  cluster b1+b2 -> natural-valued;
  coherence;
  cluster b1-'b2 -> natural-valued;
  coherence
  proof
    set f = b1 -' b2;
    rng f c= NAT
    proof
      let y be set;
      assume y in rng f;
      then consider x being set such that
A1:   x in dom f & y = f.x by FUNCT_1:def 5;
      f.x = b1.x -' b2.x by Def6;
      hence thesis by A1;
    end;
    hence thesis by VALUED_0:def 6;
  end;
end;

theorem Th39:
  for X being set, b1, b2, b3 being real-valued ManySortedSet of X
  holds (b1+b2)+b3 = b1+(b2+b3)
proof
  let X be set, b1, b2, b3 be real-valued ManySortedSet of X;
  now
    let x be set;
    assume x in X;
    thus ((b1+b2)+b3).x = (b1+b2).x+b3.x by Def5
      .= b1.x+b2.x+b3.x by Def5
      .= b1.x+(b2.x+b3.x)
      .= b1.x+(b2+b3).x by Def5
      .= (b1+(b2+b3)).x by Def5;
  end;
  hence thesis by PBOOLE:3;
end;

theorem
  for X being set, b, c, d being natural-valued ManySortedSet of X
  holds b-'c-'d = b-'(c+d)
proof
  let X be set, b, c, d be natural-valued ManySortedSet of X;
  now
    let x be set;
    assume x in X;
    thus (b-'c-'d).x = (b-'c).x -' d.x by Def6
      .= b.x-'c.x-'d.x by Def6
      .= b.x-'(c.x+d.x) by NAT_2:32
      .= b.x-'(c+d).x by Def5;
  end;
  hence thesis by Th38;
end;

begin :: The support of a function --------------------------------------------

definition
  let f be Function;
  func support f means
  :Def7:
  for x being set holds x in it iff f.x <> 0;
  existence
  proof
    defpred P[set] means f.$1 <> 0;
    consider A being set such that
A1: for x being set holds x in A iff x in dom f & P[x] from XBOOLE_0:sch 1;
    take A;
    let x be set;
    thus x in A implies f.x <> 0 by A1;
    assume
A2: f.x <> 0;
    then x in dom f by FUNCT_1:def 4;
    hence thesis by A1,A2;
  end;
  uniqueness
  proof
    let A,B be set such that
A3: for x being set holds x in A iff f.x <> 0 and
A4: for x being set holds x in B iff f.x <> 0;
    for x being set holds x in A iff x in B
    proof
      let x be set;
      x in A iff f.x <> 0 by A3;
      hence thesis by A4;
    end;
    hence thesis by TARSKI:2;
  end;
end;

theorem Th41:
  for f being Function holds support f c= dom f
proof
  let f be Function, x be set;
  assume x in support f;
  then f.x <> 0 by Def7;
  hence thesis by FUNCT_1:def 4;
end;

definition
  let f be Function;
  attr f is finite-support means
  :Def8:
  support f is finite;
end;

registration
  cluster finite -> finite-support Function;
  coherence
  proof
    let f be Function;
    assume f is finite;
    then dom f is finite;
    hence support f is finite by Th41,FINSET_1:13;
  end;
end;

registration
  cluster natural-valued finite-support non empty Function;
  existence
  proof
    take f = 0 .--> 1;
    thus f is natural-valued;
    thus f is finite-support;
    thus thesis;
  end;
end;

registration
  let f be finite-support Function;
  cluster support f -> finite;
  coherence by Def8;
end;

registration
  let X be set;
  cluster finite-support Function of X, NAT;
  existence
  proof
    set f = X --> 0;
A1: dom f = X by FUNCOP_1:19;
    reconsider f as Function of X, NAT;
    take f;
    now
      assume support f <> {};
      then consider x being set such that
A3:   x in support f by XBOOLE_0:def 1;
A4:   f.x <> 0 by A3,Def7;
      support f c= dom f by Th41;
      hence contradiction by A1,A3,A4,FUNCOP_1:13;
    end;
    hence support f is finite;
  end;
end;

registration
  let f be finite-support Function, x, y be set;
  cluster f+*(x,y) -> finite-support;
  coherence
  proof
    set F = f+*(x,y);
    support F c= support f \/ {x}
    proof
      let a be set;
      assume a in support F;
      then
A1:   F.a <> 0 by Def7;
      per cases;
      suppose x in dom f & a = x;
        then a in {x} by TARSKI:def 1;
        hence thesis by XBOOLE_0:def 3;
      end;
      suppose x in dom f & a <> x;
        then F.a = f.a by FUNCT_7:34;
        then a in support f by A1,Def7;
        hence thesis by XBOOLE_0:def 3;
      end;
      suppose not x in dom f;
        then F.a = f.a by FUNCT_7:def 3;
        then a in support f by A1,Def7;
        hence thesis by XBOOLE_0:def 3;
      end;
    end;
    hence support (f+*(x,y)) is finite;
  end;
end;

registration
  let X be set;
  cluster natural-valued finite-support ManySortedSet of X;
  existence
  proof
    set f = X --> 0;
A1: dom f = X by FUNCOP_1:19;
    then reconsider f as ManySortedSet of X by PARTFUN1:def 4;
    take f;
    thus f is natural-valued;
    support f = {}
    proof
      assume not thesis;
      then consider x being set such that
A2:   x in support f by XBOOLE_0:def 1;
      support f c= dom f by Th41;
      then f.x = 0 by A1,A2,FUNCOP_1:13;
      hence contradiction by A2,Def7;
    end;
    hence thesis by Def8;
  end;
end;

theorem Th42:
  for X being set, b1, b2 being natural-valued ManySortedSet of X
  holds support (b1+b2) = support b1 \/ support b2
proof
  let X be set, b1, b2 be natural-valued ManySortedSet of X;
  now
    let x be set;
    hereby
      assume x in support b1 \/ support b2;
      then x in support b1 or x in support b2 by XBOOLE_0:def 3;
      then b1.x <> 0 or b2.x <> 0 by Def7;
      then b1.x + b2.x <> 0;
      hence (b1+b2).x <> 0 by Def5;
    end;
    assume
A1: (b1+b2).x <> 0;
    assume not x in support b1 \/ support b2;
    then not x in support b1 & not x in support b2 by XBOOLE_0:def 3;
    then b1.x = 0 & b2.x = 0 by Def7;
    then b1.x+b2.x = 0;
    hence contradiction by A1,Def5;
  end;
  hence thesis by Def7;
end;

theorem Th43:
  for X being set, b1, b2 being natural-valued ManySortedSet of X
  holds support (b1-'b2) c= support b1
proof
  let X be set, b1, b2 be natural-valued ManySortedSet of X;
  thus support (b1-'b2) c= support b1
  proof
    let x be set;
    assume
A1: x in support (b1-'b2);
    assume not x in support b1;
    then b1.x = 0 by Def7;
    then b1.x-'b2.x = 0 by NAT_2:10;
    then (b1-'b2).x = 0 by Def6;
    hence contradiction by A1,Def7;
  end;
end;

definition
  let X be non empty set, S be ZeroStr, f be Function of X, S;
  func Support f -> Subset of X means
  :Def9:
  for x being Element of X holds x in it iff f.x <> 0.S;
  existence
  proof
    defpred P[set] means f.$1 <> 0.S;
    consider B being Subset of X such that
A1: for x being Element of X holds x in B iff P[x] from SUBSET_1:sch 3;
    take B;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let A,B be Subset of X such that
A2: for x being Element of X holds x in A iff f.x <> 0.S and
A3: for x being Element of X holds x in B iff f.x <> 0.S;
    now
      let x be Element of X;
      x in A iff f.x <> 0.S by A2;
      hence x in A iff x in B by A3;
    end;
    hence thesis by SUBSET_1:8;
  end;
end;

definition
  let X be non empty set, S be ZeroStr, p be Function of X, S;
  attr p is finite-Support means
  :Def10:
  Support p is finite;
end;

begin :: Bags -----------------------------------------------------------------

definition
  let X be set;
  mode bag of X is natural-valued finite-support ManySortedSet of X;
end;

registration
  let X be finite set;
  cluster -> finite-support ManySortedSet of X;
  coherence
  proof
    let f be ManySortedSet of X;
    support f c= dom f & dom f = X by Th41,PARTFUN1:def 4;
    hence support f is finite;
  end;
end;

registration
  let X be set, b1, b2 be bag of X;
  cluster b1+b2 -> finite-support;
  coherence
  proof
    support (b1+b2) = support b1 \/ support b2 by Th42;
    hence support (b1+b2) is finite;
  end;
  cluster b1-'b2 -> finite-support;
  coherence
  proof support (b1-'b2) c= support b1 by Th43;
    hence support (b1-'b2) is finite;
  end;
end;

theorem Th44:
  for X being set holds X--> 0 is bag of X
proof
  let X be set;
  set f = X --> 0;
A1: dom f = X by FUNCOP_1:19;
  support f = {}
  proof
    assume not thesis;
    then consider x being set such that
A2: x in support f by XBOOLE_0:def 1;
    support f c= dom f by Th41;
    then f.x = 0 by A1,A2,FUNCOP_1:13;
    hence contradiction by A2,Def7;
  end;
  hence thesis by A1,Def8,PARTFUN1:def 4;
end;

definition
  let n be Ordinal, p, q be bag of n;
  pred p < q means
  :Def11:
  ex k being Ordinal st p.k < q.k &
  for l being Ordinal st l in k holds p.l = q.l;
  asymmetry
  proof
    let p, q be bag of n;
    given k being Ordinal such that
A1: p.k < q.k and
A2: for l being Ordinal st l in k holds p.l = q.l;
    given k1 being Ordinal such that
A3: q.k1 < p.k1 and
A4: for l being Ordinal st l in k1 holds q.l = p.l;
    per cases by ORDINAL1:24;
    suppose k in k1;
      hence contradiction by A1,A4;
    end;
    suppose k1 in k;
      hence contradiction by A2,A3;
    end;
    suppose k1 = k;
      hence contradiction by A1,A3;
    end;
  end;
end;

theorem Th45:
  for n being Ordinal, p, q, r being bag of n st p < q & q < r holds p < r
proof
  let n be Ordinal, p, q, r be bag of n;
  assume
A1: p < q & q < r;
  then consider k being Ordinal such that
A2: p.k < q.k and
A3: for l being Ordinal st l in k holds p.l = q.l by Def11;
  consider m being Ordinal such that
A4: q.m < r.m and
A5: for l being Ordinal st l in m holds q.l = r.l by A1,Def11;
  take n = k /\ m;
A6: n c= k & n c= m by XBOOLE_1:17;
A7: (n c= k & n <> k iff n c< k) &
  (n c= m & n <> m iff n c< m) by XBOOLE_0:def 8;
  now
    per cases by ORDINAL1:24;
    suppose k in m;
      hence p.n < r.n by A2,A5,A7,ORDINAL1:21,ORDINAL3:16,XBOOLE_1:17;
    end;
    suppose m in k;
      hence p.n < r.n by A3,A4,A7,ORDINAL1:21,ORDINAL3:16,XBOOLE_1:17;
    end;
    suppose m = k;
      hence p.n < r.n by A2,A4,XXREAL_0:2;
    end;
  end;
  hence p.n < r.n;
  let l be Ordinal;
  assume
A8: l in n;
  hence p.l = q.l by A3,A6
    .= r.l by A5,A6,A8;
end;

definition
  let n be Ordinal, p, q be bag of n;
  pred p <=' q means
  :Def12:
  p < q or p = q;
  reflexivity;
end;

theorem Th46:

for n being Ordinal, p, q, r being bag of n st p <=' q & q <=' r holds p <=' r
proof
  let n be Ordinal, p, q, r be bag of n;
  assume p <=' q & q <=' r;
  then (p < q or p = q) & (q < r or q = r) by Def12;
  then p < r or p <=' r by Th45;
  hence thesis by Def12;
end;

theorem
  for n being Ordinal, p, q, r being bag of n st p < q & q <=' r holds p < r
proof
  let n be Ordinal, p, q, r be bag of n such that
A1: p < q and
A2: q <=' r;
  q < r or q = r by A2,Def12;
  hence thesis by A1,Th45;
end;

theorem
  for n being Ordinal, p, q, r being bag of n st p <=' q & q < r holds p < r
proof
  let n be Ordinal, p, q, r be bag of n such that
A1: p <=' q and
A2: q < r;
  p < q or p = q by A1,Def12;
  hence thesis by A2,Th45;
end;

theorem Th49:
  for n being Ordinal, p, q being bag of n holds p <=' q or q <=' p
proof
  let n be Ordinal, p, q be bag of n;
  assume
A1: not p <=' q;
  then
A2: not p < q & not p = q by Def12;
  consider i being set such that
A3: i in n and
A4: p.i <> q.i by A1,PBOOLE:3;
  reconsider j = i as Ordinal by A3;
  defpred P[set] means p.$1 <> q.$1;
  j in n by A3;
  then
A5: ex i being Ordinal st P[i] by A4;
  consider m being Ordinal such that
A6: P[m] and
A7: for n being Ordinal st P[n] holds m c= n from ORDINAL1:sch 1(A5);
A8: for l being Ordinal st l in m holds q.l = p.l by A7,ORDINAL1:7;
  per cases by A6,XXREAL_0:1;
  suppose p.m < q.m;
    hence thesis by A2,A8,Def11;
  end;
  suppose p.m > q.m;
    then q < p by A8,Def11;
    hence thesis by Def12;
  end;
end;

definition
  let X be set, d, b be bag of X;
  pred d divides b means
  :Def13:
  for k being set holds d.k <= b.k;
  reflexivity;
end;

theorem Th50:
  for n being set, d, b being bag of n
  st for k being set st k in n holds d.k <= b.k holds d divides b
proof
  let n be set, d, b be bag of n;
  assume
A1: for k being set st k in n holds d.k <= b.k;
  let k be set;
  per cases;
  suppose k in dom d;
    then k in n by PARTFUN1:def 4;
    hence thesis by A1;
  end;
  suppose not k in dom d;
    hence thesis by FUNCT_1:def 4;
  end;
end;

theorem Th51:
  for n being Ordinal, b1, b2 being bag of n
  st b1 divides b2 holds b2 -' b1 + b1 = b2
proof
  let n be Ordinal, b1, b2 be bag of n such that
A1: b1 divides b2;
  now
    let k be set;
    assume k in n;
    then reconsider k' = k as Ordinal;
A2: b1.k' <= b2.k' by A1,Def13;
    thus (b2 -' b1 + b1).k = (b2-'b1).k + b1.k by Def5
      .= b2.k -' b1.k + b1.k by Def6
      .= b2.k + b1.k -' b1.k by A2,NAT_D:38
      .= b2.k by NAT_D:34;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th52:
  for X being set, b1, b2 being bag of X holds b2 + b1 -' b1 = b2
proof
  let X be set, b1, b2 be bag of X;
  now
    let k be set;
    assume k in X;
    thus (b2 + b1 -' b1).k = (b2+b1).k -' b1.k by Def6
      .= b2.k+b1.k -' b1.k by Def5
      .= b2.k by NAT_D:34;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th53:
  for n being Ordinal, d, b being bag of n st d divides b holds d <=' b
proof
  let n be Ordinal, d, b be bag of n;
  assume that
A1: d divides b and
A2: not (d < b);
  now
    let p be set;
    assume p in n;
    then reconsider p' = p as Ordinal;
A3: d.p' <= b.p' by A1,Def13;
    defpred P[set] means d.$1 < b.$1;
    assume d.p <> b.p;
    then d.p' < b.p' by A3,XXREAL_0:1;
    then
A4: ex p being Ordinal st P[p];
    consider k being Ordinal such that
A5: P[k] and
A6: for m being Ordinal st P[m] holds k c= m from ORDINAL1:sch 1(A4);
    now
      let l be Ordinal;
      assume l in k;
      then
A7:   b.l <= d.l by A6,ORDINAL1:7;
      d.l <= b.l by A1,Def13;
      hence d.l = b.l by A7,XXREAL_0:1;
    end;
    hence contradiction by A2,A5,Def11;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th54:
  for n being set, b,b1,b2 being bag of n st b = b1 + b2 holds b1 divides b
proof
  let n be set, b,b1,b2 be bag of n;
  assume
A1: b = b1 + b2;
  now
    let k be set;
    assume k in n;
    b.k = b1.k+b2.k by A1,Def5;
    hence b1.k <= b.k by NAT_1:11;
  end;
  hence thesis by Th50;
end;

definition
  let X be set;
  func Bags X means
  :Def14:
  for x being set holds x in it iff x is bag of X;
  existence
  proof
    defpred P[set] means $1 is bag of X;
    consider A being set such that
A1: for x being set holds x in A iff x in Funcs(X,NAT) & P[x] from
    XBOOLE_0:sch 1;
    take A;
    let x be set;
    thus x in A implies x is bag of X by A1;
    assume
A2: x is bag of X;
    then reconsider b = x as bag of X;
    dom b = X & rng b c= NAT by PARTFUN1:def 4,VALUED_0:def 6;
    then x in Funcs(X,NAT) by FUNCT_2:def 2;
    hence thesis by A1,A2;
  end;
  uniqueness
  proof
    let A,B be set such that
A3: for x being set holds x in A iff x is bag of X and
A4: for x being set holds x in B iff x is bag of X;
    now
      let x be set;
      x in A iff x is bag of X by A3;
      hence x in A iff x in B by A4;
    end;
    hence thesis by TARSKI:2;
  end;
end;

definition
  let X be set;
  redefine func Bags X -> Subset of Bags X;
  coherence
  proof
    Bags X c= Bags X;
    hence thesis;
  end;
end;

theorem
  Bags {} = {{}}
proof
  now
    let x be set;
    hereby
      assume x in {{}};
      then x = {} by TARSKI:def 1;
      hence x is bag of {} by PARTFUN1:def 4,RELAT_1:60,def 18;
    end;
    assume x is bag of {};
    then reconsider x' = x as ManySortedSet of {};
    dom x' = {} by PARTFUN1:def 4;
    then x' = {};
    hence x in {{}} by TARSKI:def 1;
  end;
  hence thesis by Def14;
end;

registration
  let X be set;
  cluster Bags X -> non empty;
  coherence
  proof
    X --> 0 is bag of X by Th44;
    hence thesis by Def14;
  end;
end;

definition
  let X be set, B be non empty Subset of Bags X;
  redefine mode Element of B -> bag of X;
  coherence
  proof
    let b be Element of B; thus thesis by Def14;
  end;
end;

definition
  let n be set, L be non empty 1-sorted, p be Function of Bags n, L,
  x be bag of n;
  redefine func p.x -> Element of L;
  coherence
  proof
    reconsider f = p as Function of Bags n, the carrier of L;
    reconsider b = x as Element of Bags n by Def14;
    f.b is Element of L;
    hence thesis;
  end;
end;

definition
  let X be set;
  func EmptyBag X -> Element of Bags X equals

  X --> 0;
  coherence
  proof
    X --> 0 is bag of X by Th44;
    hence thesis by Def14;
  end;
end;

theorem Th56:
  for X, x being set holds (EmptyBag X).x = 0
proof
  let X, x be set;
A1: dom (X --> 0) = X by FUNCOP_1:19;
  per cases;
  suppose x in X;
    hence thesis by FUNCOP_1:13;
  end;
  suppose not x in X;
    hence thesis by A1,FUNCT_1:def 4;
  end;
end;

theorem
  for X be set, b being bag of X holds b+EmptyBag X = b
proof
  let X be set, b be bag of X;
  now
    let x be set;
    assume x in X;
    then
A1: (EmptyBag X).x = 0 by FUNCOP_1:13;
    thus (b+EmptyBag X).x = b.x+(EmptyBag X).x by Def5
      .= b.x by A1;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th58:
  for X be set, b being bag of X holds b-'EmptyBag X = b
proof
  let X be set, b be bag of X;
  now
    let x be set;
    assume x in X;
    then
A1: (EmptyBag X).x = 0 by FUNCOP_1:13;
    thus (b-'EmptyBag X).x = b.x-'(EmptyBag X).x by Def6
      .= b.x by A1,NAT_D:40;
  end;
  hence thesis by PBOOLE:3;
end;

theorem
  for X be set, b being bag of X holds (EmptyBag X) -' b = EmptyBag X
proof
  let X be set, b be bag of X;
  now
    let x be set;
    assume x in X;
    then
A1: (EmptyBag X).x = 0 by FUNCOP_1:13;
    thus ((EmptyBag X)-'b).x = (EmptyBag X).x-'b.x by Def6
      .= (EmptyBag X).x by A1,NAT_2:10;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th60:
  for X being set, b being bag of X holds b-'b = EmptyBag X
proof
  let X be set, b be bag of X;
  now
    let x be set;
    assume x in X;
    thus (b-'b).x = b.x -' b.x by Def6
      .= 0 by XREAL_1:234
      .= (EmptyBag X).x by Th56;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th61:
  for n being set, b1, b2 be bag of n
  st b1 divides b2 & b2 -' b1 = EmptyBag n holds b2 = b1
proof
  let n be set, b1, b2 be bag of n such that
A1: b1 divides b2 and
A2: b2 -' b1 = EmptyBag n;
  now
    let k be set;
    assume k in n;
A3: b1.k <= b2.k by A1,Def13;
    0 = (b2-'b1).k by A2,Th56
      .= b2.k -' b1.k by Def6;
    then b2.k <= b1.k by NAT_D:36;
    hence b2.k = b1.k by A3,XXREAL_0:1;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th62:
  for n being set, b being bag of n st b divides EmptyBag n
  holds EmptyBag n = b
proof
  let n be set, b be bag of n;
  assume
A1: b divides EmptyBag n;
  now
    let k be set;
    assume k in n;
A2: (EmptyBag n).k = 0 by Th56;
    then b.k <= 0 by A1,Def13;
    hence (EmptyBag n).k = b.k by A2;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th63:
  for n being set, b being bag of n holds EmptyBag n divides b
proof
  let n be set, b be bag of n;
  let k be set;
  thus thesis by Th56;
end;

theorem
  for n being Ordinal, b being bag of n holds EmptyBag n <=' b by Th53,Th63;

definition
  let n be Ordinal;
  func BagOrder n -> Order of Bags n means
  :Def16:
  for p, q being bag of n holds [p, q] in it iff p <=' q;
  existence
  proof
    defpred P[set,set] means
    ex b1,b2 be Element of Bags n st $1 = b1 & $2 = b2 & b1 <=' b2;
    consider BO being Relation of Bags n, Bags n such that
A1: for x, y being set holds [x,y] in BO iff
    x in Bags n & y in Bags n & P[x,y] from RELSET_1:sch 1;
A2: BO is_reflexive_in Bags n
    proof
      let x be set;
      assume x in Bags n;
      hence thesis by A1;
    end;
A3: BO is_antisymmetric_in Bags n
    proof
      let x, y be set;
      assume
A4:   x in Bags n & y in Bags n & [x,y] in BO & [y,x] in BO;
      then consider b1, b2 being Element of Bags n such that
A5:   x = b1 & y = b2 & b1 <=' b2 by A1;
      consider b1', b2' being Element of Bags n such that
A6:   y = b1' & x = b2' & b1' <=' b2' by A1,A4;
      (b1 < b2 or b1 = b2) & (b1' < b2' or b1' = b2') by A5,A6,Def12;
      hence thesis by A5,A6;
    end;
A7: BO is_transitive_in Bags n
    proof
      let x, y, z be set such that x in Bags n & y in Bags n & z in Bags n and
A8:   [x,y] in BO & [y,z] in BO;
      consider b1, b2 being Element of Bags n such that
A9:   x = b1 & y = b2 & b1 <=' b2 by A1,A8;
      consider b1', b2' being Element of Bags n such that
A10:  y = b1' & z = b2' & b1' <=' b2' by A1,A8;
      reconsider B1 = b1, B2' = b2' as bag of n;
      B1 <=' B2' by A9,A10,Th46;
      hence thesis by A1,A9,A10;
    end;
    dom BO = Bags n & field BO = Bags n by A2,ORDERS_1:98;
    then reconsider BO as Order of Bags n
    by A2,A3,A7,PARTFUN1:def 4,RELAT_2:def 9,def 12,def 16;
    take BO;
    let p, q be bag of n;
A11: p in Bags n & q in Bags n by Def14;
    hereby
      assume [p, q] in BO;
      then consider b1, b2 being Element of Bags n such that
A12:  p = b1 & q = b2 & b1 <=' b2 by A1;
      thus p <=' q by A12;
    end;
    thus thesis by A1,A11;
  end;
  uniqueness
  proof
    let B1, B2 be Order of Bags n such that
A13: for p, q being bag of n holds [p, q] in B1 iff p <=' q and
A14: for p, q being bag of n holds [p, q] in B2 iff p <=' q;
    let a, b be set;
    hereby
      assume
A15:  [a,b] in B1;
      then consider b1, b2 being set such that
A16:  [a,b] = [b1,b2] & b1 in Bags n & b2 in Bags n by RELSET_1:6;
      reconsider b1, b2 as bag of n by A16,Def14;
      b1 <=' b2 by A13,A15,A16;
      hence [a,b] in B2 by A14,A16;
    end;
    assume
A17: [a,b] in B2;
    then consider b1, b2 being set such that
A18: [a,b] = [b1,b2] & b1 in Bags n & b2 in Bags n by RELSET_1:6;
    reconsider b1, b2 as bag of n by A18,Def14;
    b1 <=' b2 by A14,A17,A18;
    hence thesis by A13,A18;
  end;
end;

Lm1: for n being Ordinal holds BagOrder n is_reflexive_in Bags n
proof
  let n be Ordinal;
  let x be set;
  assume x in Bags n;
  then reconsider x' = x as bag of n by Def14;
  x' <=' x';
  hence thesis by Def16;
end;

Lm2: for n being Ordinal holds BagOrder n is_antisymmetric_in Bags n
proof
  let n be Ordinal;
  set BO = BagOrder n;
  let x, y be set;
  assume
A1: x in Bags n & y in Bags n & [x,y] in BO & [y,x] in BO;
  then reconsider b1 = x, b2 = y as bag of n by Def14;
A2: b1 <=' b2 by A1,Def16;
  reconsider b1' = y, b2' = x as bag of n by A1,Def14;
  b1' <=' b2' by A1,Def16;
  then (b1 < b2 or b1 = b2) & (b1' < b2' or b1' = b2') by A2,Def12;
  hence thesis;
end;

Lm3: for n being Ordinal holds BagOrder n is_transitive_in Bags n
proof
  let n be Ordinal;
  set BO = BagOrder n;
  let x, y, z be set such that
A1: x in Bags n & y in Bags n & z in Bags n and
A2: [x,y] in BO & [y,z] in BO;
  reconsider b1 = x, b2 = y as bag of n by A1,Def14;
A3: b1 <=' b2 by A2,Def16;
  reconsider b1'= y, b2' = z as bag of n by A1,Def14;
A4: b1' <=' b2' by A2,Def16;
  reconsider B1 = b1, B2' = b2' as bag of n;
  B1 <=' B2' by A3,A4,Th46;
  hence thesis by Def16;
end;

Lm4: for n being Ordinal holds BagOrder n linearly_orders Bags n
proof
  let n be Ordinal;
  set BO = BagOrder n;
A1: BO is_reflexive_in Bags n by Lm1;
A2: BO is_antisymmetric_in Bags n by Lm2;
A3: BO is_transitive_in Bags n by Lm3;
  BO is_connected_in Bags n
  proof
    let x, y be set;
    assume
A4: x in Bags n & y in Bags n & x <> y & not [x,y] in BO;
    then reconsider p = x, q = y as bag of n by Def14;
    not p <=' q by A4,Def16;
    then q <=' p by Th49;
    hence thesis by Def16;
  end;
  hence thesis by A1,A2,A3,ORDERS_1:def 8;
end;

registration
  let n be Ordinal;
  cluster BagOrder n -> being_linear-order;
  coherence
  proof
    set BO = BagOrder n;
A1: field BO = Bags n by ORDERS_1:100;
    BO linearly_orders Bags n by Lm4;
    then BO is_connected_in Bags n by ORDERS_1:def 8;
    then BO is connected by A1,RELAT_2:def 14;
    hence thesis by ORDERS_1:def 5;
  end;
end;

definition
  let X be set, f be Function of X, NAT;
  func NatMinor f -> Subset of Funcs(X, NAT) means
  :Def17:
  for g being natural-valued ManySortedSet of X
  holds g in it iff for x being set st x in X holds g.x <= f.x;
  existence
  proof
    defpred P[set] means ex g being natural-valued ManySortedSet of X
    st $1 = g & for x being set st x in X holds g.x <= f.x;
    consider IT being Subset of Funcs(X, NAT) such that
A1: for h being set holds h in IT iff h in Funcs(X, NAT) & P[h] from
    SUBSET_1:sch 1;
    take IT;
    let g be natural-valued ManySortedSet of X;
    hereby
      assume g in IT;
      then consider g1 being natural-valued ManySortedSet of X such that
A2:   g1 = g & for x being set st x in X holds g1.x <= f.x by A1;
      thus for x being set st x in X holds g.x <= f.x by A2;
    end;
    assume
A3: for x being set st x in X holds g.x <= f.x;
    dom g = X & rng g c= NAT by PARTFUN1:def 4,VALUED_0:def 6;
    then g is Function of X, NAT by FUNCT_2:def 1,RELSET_1:11;
    then g in Funcs(X, NAT) by FUNCT_2:11;
    hence thesis by A1,A3;
  end;
  uniqueness
  proof
    let it1, it2 be Subset of Funcs(X, NAT) such that
A4: for g being natural-valued ManySortedSet of X
    holds g in it1 iff for x being set st x in X holds g.x <= f.x and
A5: for g being natural-valued ManySortedSet of X
    holds g in it2 iff for x being set st x in X holds g.x <= f.x;
    now
      let h be Element of Funcs(X, NAT);
      dom h = X & rng h c= NAT by FUNCT_2:169;
      then
A6:   h is natural-valued ManySortedSet of X by PARTFUN1:def 4;
      hereby
        assume h in it1;
        then for x being set st x in X holds h.x <= f.x by A4,A6;
        hence h in it2 by A5,A6;
      end;
      assume h in it2;
      then for x being set st x in X holds h.x <= f.x by A5,A6;
      hence h in it1 by A4,A6;
    end;
    hence thesis by SUBSET_1:8;
  end;
end;

theorem Th65:
  for X being set, f being Function of X, NAT holds f in NatMinor f
proof
  let X be set, f be Function of X, NAT;
  dom f = X by FUNCT_2:def 1;
  then
A1: f is ManySortedSet of X by PARTFUN1:def 4;
  for x being set st x in X holds f.x <= f.x;
  hence thesis by A1,Def17;
end;

registration
  let X be set, f be Function of X, NAT;
  cluster NatMinor f -> non empty functional;
  coherence by Th65;
end;

registration
  let X be set, f be Function of X, NAT;
  cluster -> natural-valued Element of NatMinor f;
  coherence
  proof
    let x be Element of NatMinor f;
    rng x c= NAT by FUNCT_2:169;
    hence thesis by VALUED_0:def 6;
  end;
end;

theorem Th66:
  for X being set, f being finite-support Function of X, NAT
  holds NatMinor f c= Bags X
proof
  let X be set, f be finite-support Function of X, NAT;
  let x be set;
  assume x in NatMinor f;
  then reconsider x' = x as Element of NatMinor f;
A1: dom x' = X by FUNCT_2:169;
  then
A2: x' is ManySortedSet of X by PARTFUN1:def 4,RELAT_1:def 18;
  support x' c= support f
  proof
    let a be set;
    assume
A3: a in support x';
    then x'.a <> 0 by Def7;
    then
A4: 0 < x'.a;
    support x' c= dom x' by Th41;
    then f.a <> 0 by A1,A2,A3,A4,Def17;
    hence thesis by Def7;
  end;
  then support x' is finite;
  then x is bag of X by A1,Def8,PARTFUN1:def 4,RELAT_1:def 18;
  hence thesis by Def14;
end;

definition
  let X be set, f be finite-support Function of X, NAT;
  redefine func support f -> Element of Fin X;
  coherence
  proof
    dom f = X by FUNCT_2:def 1;
    then support f c= X by Th41;
    hence thesis by FINSUB_1:def 5;
  end;
end;

theorem Th67:
  for X being non empty set, f being finite-support Function of X, NAT
  holds card NatMinor f = multnat $$ (support f, addnat[:](f,1))
proof
  let X be non empty set;
  defpred P[Element of Fin X] means for f being Function of X, NAT
  st for x being Element of X st not x in $1 holds f.x = 0
  holds card NatMinor f = multnat $$ ($1, addnat[:](f,1));
A1: P[{}.X]
  proof
    let f be Function of X, NAT such that
A2: for x being Element of X st not x in {}.X holds f.x = 0;
    now
      let x be set;
      hereby
        assume
A3:     x in NatMinor f;
        then reconsider x' = x as Function of X, NAT by FUNCT_2:121;
        dom x' = X & rng x' c= NAT by FUNCT_2:def 1;
        then reconsider x'' = x' as natural-valued ManySortedSet of X
        by PARTFUN1:def 4;
        now
          let c be Element of X;
A4:       x''.c <= f.c by A3,Def17;
          f.c = 0 by A2;
          hence x'.c = f.c by A4;
        end;
        hence x = f by FUNCT_2:113;
      end;
      thus x = f implies x in NatMinor f by Th65;
    end;
    then NatMinor f = {f} by TARSKI:def 1;
    hence card NatMinor f = 1 by CARD_1:50
      .= multnat $$ ({}.X, addnat[:](f,1)) by BINOP_2:10,SETWISEO:40;
  end;
A5: for B being Element of Fin X, b being Element of X
  holds P[B] & not b in B implies P[B \/ {.b.}]
  proof
    let B be Element of Fin X, b be Element of X such that
A6: P[B] & not b in B;
    let f be Function of X, NAT such that
A7: for x being Element of X st not x in B \/ {b} holds f.x = 0;
    dom (addnat[:](f,1)) = X by FUNCT_2:def 1;
    then
A8: addnat[:](f,1).b = addnat.(f.b,1) by FUNCOP_1:35
      .= f.b+1 by BINOP_2:def 23;
    set g = f+*(b,0);
A9: dom f = X by FUNCT_2:def 1;
    for x being Element of X st not x in B holds g.x = 0
    proof
      let x be Element of X such that
A10:  not x in B;
      per cases;
      suppose x = b;
        hence thesis by A9,FUNCT_7:33;
      end;
      suppose
A11:    x <> b;
A12:    now
          assume x in B \/ {b};
          then x in B or x in {b} by XBOOLE_0:def 3;
          hence contradiction by A10,A11,TARSKI:def 1;
        end;
        thus g.x = f.x by A11,FUNCT_7:34
          .= 0 by A7,A12;
      end;
    end;
    then
A13: card NatMinor g = (multnat $$ (B, addnat[:](g,1))) by A6;
    then reconsider ng = NatMinor g as functional finite non empty set;
    set cng = card ng;
    g|B = f|B by A6,FUNCT_7:94;
    then addnat[:](g,1)|B = addnat[:](f,1)|B by FUNCOP_1:36;
    then
A14: (multnat $$ (B, addnat[:](g,1))) = (multnat $$ (B, addnat[:](f,1) ))
    by SETWOP_2:9;
A15: f.b < f.b+1 by XREAL_1:31;
    reconsider fb1 = f.b+1 as non empty Element of NAT;
    [:ng,f.b+1 :],NatMinor f are_equipotent
    proof
      deffunc F(Element of ng,Element of fb1) = $1+*(b,$2);
A16:  for p being Element of ng, l being Element of fb1
      holds F(p,l) in NatMinor f
      proof
        let p be Element of ng, l be Element of fb1;
        reconsider q = p as Element of NatMinor g;
A17:    fb1 c= NAT;
        l in fb1;
        then reconsider k = l as Element of NAT by A17;
        p in NatMinor g;
        then
A18:    dom p = X by FUNCT_2:169;
        then dom(p+*(b,l)) = X by FUNCT_7:32;
        then reconsider pbl = q+*(b,k)
        as natural-valued ManySortedSet of X by PARTFUN1:def 4,RELAT_1:def 18;
        for x being set st x in X holds pbl.x <= f.x
        proof
          let x be set;
          assume
A19:      x in X;
          per cases;
          suppose
A20:        x = b;
            then
A21:        pbl.x = k by A18,FUNCT_7:33;
            k < fb1 by NAT_1:45;
            hence thesis by A20,A21,NAT_1:13;
          end;
          suppose
A22:        x <> b;
            then
A23:        pbl.x = q.x by FUNCT_7:34;
            q is ManySortedSet of X by A18,PARTFUN1:def 4,RELAT_1:def 18;
            then q.x <= g.x by A19,Def17;
            hence thesis by A22,A23,FUNCT_7:34;
          end;
        end;
        hence thesis by Def17;
      end;
      consider r being Function of [:ng,fb1:], NatMinor f such that
A24:  for p being Element of ng, l being Element of fb1
      holds r.(p,l) = F(p,l) from FUNCT_7:sch 1(A16);
      take r;
      thus r is one-to-one
      proof
        let x1,x2 be set;
        assume
A25:    x1 in dom r & x2 in dom r & r.x1 = r.x2;
        then consider p1, l1 being set such that
A26:    x1 = [p1,l1] by RELAT_1:def 1;
A27:    p1 in ng & l1 in fb1 by A25,A26,ZFMISC_1:106;
        consider p2, l2 being set such that
A28:    x2 = [p2,l2] by A25,RELAT_1:def 1;
A29:    p2 in ng & l2 in fb1 by A25,A28,ZFMISC_1:106;
        reconsider p1 as Element of NatMinor g by A25,A26,ZFMISC_1:106;
        reconsider p2 as Element of NatMinor g by A25,A28,ZFMISC_1:106;
A30:    p1+*(b,l1) = r.(p1,l1) by A24,A27
          .= r.(p2,l2) by A25,A26,A28
          .= p2+*(b,l2) by A24,A29;
A31:    dom p1 = X by FUNCT_2:169;
A32:    dom p2 = X by FUNCT_2:169;
        then reconsider p1' = p1, p2' = p2 as
        natural-valued ManySortedSet of X by A31,PARTFUN1:def 4,RELAT_1:def 18;
A33:    now
          let x be set;
          assume
A34:      x in X;
          per cases;
          suppose
A35:        x = b;
A36:        g.b = 0 by A9,FUNCT_7:33;
A37:        p1'.x <= g.x & p2'.x <= g.x by A34,Def17;
            hence p1'.x = 0 by A35,A36
              .= p2'.x by A35,A36,A37;
          end;
          suppose
A38:        x <> b;
            hence p1'.x = (p1+*(b,l1)).x by FUNCT_7:34
              .= p2'.x by A30,A38,FUNCT_7:34;
          end;
        end;
        l1 = (p1+*(b,l1)).b by A31,FUNCT_7:33
          .= l2 by A30,A32,FUNCT_7:33;
        hence thesis by A26,A28,A33,PBOOLE:3;
      end; thus
A39:  dom r = [:ng,f.b+1 :] by FUNCT_2:def 1;
      thus rng r c= NatMinor f;
      thus NatMinor f c= rng r
      proof
        let x be set;
        assume x in NatMinor f;
        then reconsider e = x as Element of NatMinor f;
A40:    dom e = X by FUNCT_2:169;
        then
A41:    e is ManySortedSet of X by PARTFUN1:def 4,RELAT_1:def 18;
        dom (e+*(b,0)) = X by A40,FUNCT_7:32;
        then reconsider eb0 = e+*(b,0)
        as natural-valued ManySortedSet of X by PARTFUN1:def 4,RELAT_1:def 18;
        now
          let x be set;
          assume
A42:      x in X;
          per cases;
          suppose x = b;
            hence eb0.x <= g.x by A40,FUNCT_7:33;
          end;
          suppose
A43:        x <> b;
            then
A44:        eb0.x = e.x by FUNCT_7:34;
            e.x <= f.x by A41,A42,Def17;
            hence eb0.x <= g.x by A43,A44,FUNCT_7:34;
          end;
        end;
        then reconsider eb0 as Element of NatMinor g by Def17;
        e.b <= f.b by A41,Def17;
        then e.b < fb1 by A15,XXREAL_0:2;
        then
A45:    e.b in fb1 by NAT_1:45;
        then
A46:    [eb0,e.b] in dom r by A39,ZFMISC_1:106;
        e = e+*(b,e.b) by FUNCT_7:37
          .= eb0+*(b,e.b) by FUNCT_7:36;
        then e = r.(eb0,e.b) by A24,A45;
        hence thesis by A46,FUNCT_1:def 5;
      end;
    end;
    hence card NatMinor f = card [:ng,f.b+1 :] by CARD_1:21
      .= cng * card(f.b+1) by CARD_2:65
      .= cng * (f.b+1) by CARD_1:def 5
      .= multnat.(multnat $$ (B, addnat[:](f,1)), f.b+1) by A13,A14,
BINOP_2:def 24
      .= multnat $$ (B \/ {.b.}, addnat[:](f,1)) by A6,A8,SETWOP_2:4;
  end;
A47: for B being Element of Fin X holds P[B] from SETWISEO:sch 2(A1,A5);
  let f be finite-support Function of X, NAT;
  for x being Element of X holds not x in support f implies f.x = 0 by Def7;
  hence thesis by A47;
end;

registration
  let X be set, f be finite-support Function of X, NAT;
  cluster NatMinor f -> finite;
  coherence
  proof
    per cases;
    suppose X is empty;
      then NatMinor f c= Funcs({},NAT);
      then NatMinor f c= {{}} by FUNCT_5:64;
      hence thesis;
    end;
    suppose X is not empty;
      then reconsider X as non empty set;
      reconsider f as finite-support Function of X, NAT;
      card NatMinor f = multnat $$ (support f, addnat[:](f,1)) by Th67;
      hence thesis;
    end;
  end;
end;

definition
  let n be Ordinal, b be bag of n;
  func divisors b -> FinSequence of Bags n means
  :Def18:
  ex S being non empty finite Subset of Bags n st it = SgmX(BagOrder n, S) &
  for p being bag of n holds p in S iff p divides b;
  existence
  proof
    dom b = n & rng b c= NAT by PARTFUN1:def 4,VALUED_0:def 6;
    then reconsider f = b as finite-support Function of n, NAT
    by FUNCT_2:def 1,RELSET_1:11;
    reconsider S = NatMinor f as non empty finite Subset of Bags n by Th66;
    take IT = SgmX(BagOrder n, S);
    take S;
    thus IT = SgmX(BagOrder n, S);
    let p be bag of n;
    thus p in S implies p divides b
    proof
      assume p in S;
      then for x being set st x in n holds p.x <= b.x by Def17;
      hence thesis by Th50;
    end;
    assume p divides b;
    then for x being set st x in n holds p.x <= b.x by Def13;
    hence thesis by Def17;
  end;
  uniqueness
  proof
    let it1, it2 be FinSequence of Bags n;
    given S1 being non empty finite Subset of Bags n such that
A1: it1 = SgmX(BagOrder n, S1) and
A2: (for p being bag of n holds p in S1 iff p divides b);
    given S2 being non empty finite Subset of Bags n such that
A3: it2 = SgmX(BagOrder n, S2) and
A4: (for p being bag of n holds p in S2 iff p divides b);
    now
      let x be set;
      hereby
        assume
A5:     x in S1;
        then reconsider x' = x as Element of Bags n;
        x' divides b by A2,A5;
        hence x in S2 by A4;
      end;
      assume
A6:   x in S2;
      then reconsider x' = x as Element of Bags n;
      x' divides b by A4,A6;
      hence x in S1 by A2;
    end;
    hence thesis by A1,A3,TARSKI:2;
  end;
end;

registration
  let n be Ordinal, b be bag of n;
  cluster divisors b -> non empty one-to-one;
  coherence
  proof
    ex S being non empty finite Subset of Bags n st
    divisors b = SgmX(BagOrder n, S) &
    (for p being bag of n holds p in S iff p divides b) by Def18;
    hence thesis;
  end;
end;

theorem Th68:
  for n being Ordinal,i being Element of NAT, b being bag of n
  st i in dom divisors b
  holds ((divisors b)/.i) qua Element of Bags n divides b
proof
  let n be Ordinal,i be Element of NAT, b be bag of n;
  assume
A1: i in dom divisors b;
  consider S being non empty finite Subset of Bags n such that
A2: divisors b = SgmX(BagOrder n, S) and
A3: (for p being bag of n holds p in S iff p divides b) by Def18;
A4: BagOrder n linearly_orders S by Lm4,ORDERS_1:134;
A5: (divisors b)/.i = (divisors b).i by A1,PARTFUN1:def 8;
  (divisors b)/.i is Element of Bags n;
  then reconsider pid = (divisors b)/.i as bag of n;
  (divisors b).i in rng divisors b by A1,FUNCT_1:def 5;
  then pid in S by A2,A4,A5,TRIANG_1:def 2;
  hence thesis by A3;
end;

theorem Th69:
  for n being Ordinal, b being bag of n holds (divisors b)/.1 = EmptyBag n &
  (divisors b)/.len divisors b = b
proof
  let n be Ordinal, b be bag of n;
  consider S being non empty finite Subset of Bags n such that
A1: divisors b = SgmX(BagOrder n, S) and
A2: (for p being bag of n holds p in S iff p divides b) by Def18;
  EmptyBag n divides b by Th63;
  then
A3: EmptyBag n in S by A2;
A4: BagOrder n linearly_orders S by Lm4,ORDERS_1:134;
  now
    let y be Element of Bags n;
    assume y in S;
    EmptyBag n <=' y by Th53,Th63;
    hence [EmptyBag n, y] in BagOrder n by Def16;
  end;
  hence (divisors b)/.1 = EmptyBag n by A1,A3,A4,Th8;
A5: b in S by A2;
  now
    let y be Element of Bags n;
    assume y in S;
    then y divides b by A2;
    then y <=' b by Th53;
    hence [y,b] in BagOrder n by Def16;
  end;
  hence thesis by A1,A4,A5,Th9;
end;

theorem Th70:
  for n being Ordinal, i being Nat, b, b1, b2 being bag of n
  st i > 1 & i < len divisors b
  holds (divisors b)/.i <> EmptyBag n & (divisors b)/.i <> b
proof
  let n be Ordinal, i be Nat, b, b1, b2 be bag of n;
A1: (divisors b)/.1 = EmptyBag n & (divisors b)/.len divisors b = b by Th69;
A2: 1 in dom divisors b & len divisors b in dom divisors b by FINSEQ_5:6;
  assume
A3: i > 1 & i < len divisors b;
  then i in dom divisors b by FINSEQ_3:27;
  hence thesis by A1,A2,A3,PARTFUN2:17;
end;

theorem Th71:
  for n being Ordinal holds divisors EmptyBag n = <* EmptyBag n *>
proof
  let n be Ordinal;
  consider S being non empty finite Subset of Bags n such that
A1: divisors EmptyBag n = SgmX(BagOrder n, S) and
A2: for p being bag of n holds p in S iff p divides EmptyBag n by Def18;
A3: BagOrder n linearly_orders S by Lm4,ORDERS_1:134;
  EmptyBag n in S by A2;
  then
A4: { EmptyBag n } c= S by ZFMISC_1:37;
  S c= { EmptyBag n}
  proof
    let x be set;
    assume
A5: x in S;
    then reconsider b = x as bag of n by Def14;
    b divides EmptyBag n by A2,A5;
    then b = EmptyBag n by Th62;
    hence thesis by TARSKI:def 1;
  end;
  then S = { EmptyBag n} by A4,XBOOLE_0:def 10;
  then
A6: rng divisors EmptyBag n = {EmptyBag n} by A1,A3,TRIANG_1:def 2;
  len divisors EmptyBag n = card rng divisors EmptyBag n by Th7
    .= 1 by A6,CARD_1:50;
  hence thesis by A6,FINSEQ_1:56;
end;

definition
  let n be Ordinal, b be bag of n;
  func decomp b -> FinSequence of 2-tuples_on Bags n means
  :Def19:
  dom it = dom divisors b & for i being Element of NAT, p being bag of n
  st i in dom it & p = (divisors b)/.i holds it/.i = <*p, b-'p*>;
  existence
  proof
    defpred P[Nat,set] means
    for p being bag of n st p = (divisors b)/.$1 holds $2 = <*p,b-'p*>;
A1: for k being Nat st k in Seg len divisors b
    ex d being Element of 2-tuples_on Bags n st P[k,d]
    proof
      let k be Nat such that k in Seg len divisors b;
      reconsider p = (divisors b)/.k as bag of n by Def14;
      reconsider b1=p, b2=b-'p as Element of Bags n by Def14;
      len<*p,b-'p*> = 2 by FINSEQ_1:61;
      then reconsider d = <*b1,b2*> as Element of 2-tuples_on Bags n
      by FINSEQ_2:110;
      take d;
      thus thesis;
    end;
    consider f being FinSequence of 2-tuples_on Bags n such that
A2: len f = len divisors b and
A3: for n being Nat st n in Seg len divisors b holds P[n,f/.n]
    from FINSEQ_4:sch 1(A1);
    take f;
    thus dom f = dom divisors b by A2,FINSEQ_3:31;
    let i be Element of NAT, p be bag of n such that
A4: i in dom f and
A5: p = (divisors b)/.i;
    i in Seg len divisors b by A2,A4,FINSEQ_1:def 3;
    hence thesis by A3,A5;
  end;
  uniqueness
  proof
    let F,G be FinSequence of 2-tuples_on Bags n such that
A6: dom F = dom divisors b and
A7: for i being Element of NAT, p being bag of n
    st i in dom F & p = (divisors b)/.i holds F/.i = <*p, b-'p*> and
A8: dom G = dom divisors b and
A9: for i being Element of NAT, p being bag of n
    st i in dom G & p = (divisors b)/.i holds G/.i = <*p, b-'p*>;
    now
      let i be Nat;
      reconsider p = (divisors b)/.i as bag of n by Def14;
      assume
A10:  i in dom F;
      hence F/.i = <*p,b-'p*> by A7
        .= G/.i by A6,A8,A9,A10;
    end;
    hence thesis by A6,A8,FINSEQ_5:13;
  end;
end;

theorem Th72:
  for n being Ordinal, i being Element of NAT, b being bag of n
  st i in dom decomp b
  ex b1, b2 being bag of n st (decomp b)/.i = <*b1, b2*> & b = b1+b2
proof
  let n be Ordinal, i be Element of NAT, b be bag of n;
  assume
A1: i in dom decomp b;
  then
A2: i in dom divisors b by Def19;
  reconsider p = (divisors b)/.i as bag of n by Def14;
  take p, b-'p;
  thus (decomp b)/.i = <*p,b-'p*> by A1,Def19;
  thus thesis by A2,Th51,Th68;
end;

theorem Th73:
  for n being Ordinal, b, b1, b2 being bag of n st b = b1+b2
  ex i being Element of NAT st i in dom decomp b & (decomp b)/.i = <*b1, b2*>
proof
  let n be Ordinal, b, b1, b2 be bag of n;
  consider S being non empty finite Subset of Bags n such that
A1: divisors b = SgmX(BagOrder n, S) and
A2: for p being bag of n holds p in S iff p divides b by Def18;
A3: BagOrder n linearly_orders S by Lm4,ORDERS_1:134;
  assume
A4: b = b1+b2;
  then b1 divides b by Th54;
  then b1 in S by A2;
  then b1 in rng divisors b by A1,A3,TRIANG_1:def 2;
  then consider i being Element of NAT such that
A5: i in dom divisors b and
A6: (divisors b)/.i= b1 by PARTFUN2:4;
  take i;
  thus i in dom decomp b by A5,Def19;
  then (decomp b)/.i = <*b1, b-'b1*> by A6,Def19;
  hence thesis by A4,Th52;
end;

theorem Th74:
  for n being Ordinal, i being Element of NAT, b,b1,b2 being bag of n
  st i in dom decomp b & (decomp b)/.i = <*b1, b2*> holds b1 = (divisors b)/.i
proof
  let n be Ordinal, i be Element of NAT, b,b1,b2 be bag of n;
  reconsider p = (divisors b)/.i as bag of n by Def14;
  assume i in dom decomp b & (decomp b)/.i = <*b1, b2*>;
  then <*b1,b2*> = <*p,b-'p*> by Def19;
  hence thesis by GROUP_7:2;
end;

registration
  let n be Ordinal, b be bag of n;
  cluster decomp b -> non empty one-to-one FinSequence-yielding;
  coherence
  proof
A1: dom divisors b = dom decomp b by Def19;
    hence decomp b is non empty;
    now
      let k,m be Element of NAT;
      assume
A2:   k in dom decomp b;
      assume
A3:   m in dom decomp b;
      then consider bm1, bm2 being bag of n such that
A4:   (decomp b)/.m = <*bm1, bm2*> and b = bm1+bm2 by Th72;
      assume (decomp b)/.k = (decomp b)/.m;
      then (divisors b)/.k = bm1 by A2,A4,Th74
        .= (divisors b)/.m by A3,A4,Th74;
      hence k = m by A1,A2,A3,PARTFUN2:17;
    end;
    hence decomp b is one-to-one by PARTFUN2:16;
    let x be set;
    assume
A5: x in dom decomp b;
    then reconsider k = x as Element of NAT;
    reconsider p = (divisors b)/.k as bag of n by Def14;
    (decomp b)/.k = <*p,b-'p*> by A5,Def19;
    hence thesis by A5,PARTFUN1:def 8;
  end;
end;

registration
  let n be Ordinal, b be Element of Bags n;
  cluster decomp b -> non empty one-to-one FinSequence-yielding;
  coherence;
end;

theorem Th75:
  for n being Ordinal, b being bag of n
  holds (decomp b)/.1 = <*EmptyBag n, b*> &
  (decomp b)/.len decomp b = <*b, EmptyBag n*>
proof
  let n be Ordinal, b be bag of n;
  dom decomp b = dom divisors b by Def19;
  then
A1: len decomp b = len divisors b by FINSEQ_3:31;
  reconsider p = (divisors b)/.1 as bag of n by Def14;
A2: p = EmptyBag n by Th69;
  1 in dom decomp b by FINSEQ_5:6;
  hence (decomp b)/.1 = <*EmptyBag n, b-'EmptyBag n*> by A2,Def19
    .= <*EmptyBag n, b*> by Th58;
  reconsider p = (divisors b)/.len decomp b as bag of n by Def14;
A3: p = b by A1,Th69;
  len decomp b in dom decomp b by FINSEQ_5:6;
  hence (decomp b)/.len decomp b = <*b,b-'b*> by A3,Def19
    .= <*b, EmptyBag n*> by Th60;
end;

theorem Th76:
  for n being Ordinal, i being Nat, b, b1, b2 being bag of n
  st i > 1 & i < len decomp b & (decomp b)/.i = <*b1, b2*>
  holds b1 <> EmptyBag n & b2 <> EmptyBag n
proof
  let n be Ordinal, i be Nat, b, b1, b2 be bag of n such that
A1: i > 1 and
A2: i < len decomp b and
A3: (decomp b)/.i = <*b1, b2*>;
A4: dom decomp b = dom divisors b by Def19;
  then
A5: len decomp b = len divisors b by FINSEQ_3:31;
  reconsider p = (divisors b)/.i as bag of n by Def14;
A6: i in dom decomp b by A1,A2,FINSEQ_3:27;
  then (decomp b)/.i = <*p,b-'p*> by Def19;
  then
A7: b1 = p & b2 = b-'p by A3,GROUP_7:2;
  hence b1 <> EmptyBag n by A1,A2,A5,Th70;
  assume b2 = EmptyBag n;
  then p = b by A4,A6,A7,Th61,Th68;
  hence contradiction by A1,A2,A5,Th70;
end;

theorem Th77:

for n being Ordinal holds decomp EmptyBag n = <* <*EmptyBag n, EmptyBag n*> *>
proof
  let n be Ordinal;
  len<*EmptyBag n, EmptyBag n*> = 2 by FINSEQ_1:61;
  then reconsider E = <*EmptyBag n, EmptyBag n*>
  as Element of 2-tuples_on Bags n by FINSEQ_2:110;
  rng<* E *> c= 2-tuples_on Bags n
  proof
    let u be set;
    assume u in rng<* E *>;
    then u in {E} by FINSEQ_1:56;
    then u = E by TARSKI:def 1;
    hence thesis;
  end;
  then reconsider e = <* E *> as FinSequence of 2-tuples_on Bags n
  by FINSEQ_1:def 4;
A1: <* EmptyBag n *> = divisors EmptyBag n by Th71;
A2: dom e = Seg 1 by FINSEQ_1:55;
  then
A3: dom e = dom divisors EmptyBag n by A1,FINSEQ_1:55;
  for i being Element of NAT, p being bag of n st i in
  dom e & p = (divisors EmptyBag n)/.i holds e/.i = <*p, (EmptyBag n)-'p*>
  proof
    let i be Element of NAT, p be bag of n such that
A4: i in dom e and
A5: p = (divisors EmptyBag n)/.i;
A6: i = 1 by A2,A4,FINSEQ_1:4,TARSKI:def 1;
    then
A7: (divisors EmptyBag n)/.i = EmptyBag n by A1,FINSEQ_4:25;
    thus e/.i = E by A6,FINSEQ_4:25
      .= <*p, (EmptyBag n)-'p*> by A5,A7,Th58;
  end;
  hence thesis by A3,Def19;
end;

theorem Th78:
  for n being Ordinal, b being bag of n,
  f, g being FinSequence of (3-tuples_on Bags n)*
  st dom f = dom decomp b & dom g = dom decomp b &
  (for k being Nat st k in dom f holds
  f.k = ((decomp ((((decomp b)/.k)/.1) qua Element of Bags n))) ^^
  ((len (decomp ((((decomp b)/.k)/.1) qua Element of Bags n)))
  |-> <*(((decomp b)/.k)/.2)*>)) &
  (for k being Nat st k in dom g holds
  g.k = ((len (decomp ((((decomp b)/.k)/.2) qua Element of Bags n)))
  |-> <*((decomp b)/.k)/.1*>) ^^
  (decomp ((((decomp b)/.k)/.2) qua Element of Bags n)))
  ex p being Permutation of dom FlattenSeq f
  st FlattenSeq g = (FlattenSeq f)*p
proof
  let n be Ordinal, b be bag of n,
  f, g be FinSequence of (3-tuples_on Bags n)* such that
A1: dom f = dom decomp b and
A2: dom g = dom decomp b and
A3: (for k being Nat st k in dom f holds
  f.k = ((decomp ((((decomp b)/.k)/.1) qua Element of Bags n))) ^^
  ((len (decomp ((((decomp b)/.k)/.1) qua Element of Bags n)))
  |-> <*(((decomp b)/.k)/.2)*>)) and
A4: (for k being Nat st k in dom g holds
  g.k = ((len (decomp ((((decomp b)/.k)/.2) qua Element of Bags n)))
  |-> <*(((decomp b)/.k)/.1)*>) ^^
  (decomp ((((decomp b)/.k)/.2) qua Element of Bags n)));
  set Ff = FlattenSeq f, Fg = FlattenSeq g, db = decomp b;
  now
    let y be set;
    hereby
      assume y in rng Ff;
      then consider k being set such that
A5:   k in dom Ff & y = Ff.k by FUNCT_1:def 5;
      reconsider k as Element of NAT by A5;
      consider i, j being Element of NAT such that
A6:   i in dom f and
A7:   j in dom (f.i) and k = (Sum Card (f|(i-'1))) + j and
A8:   (f.i).j = Ff.k by A5,Th32;
      set ddbi1 = decomp (((db/.i)/.1) qua Element of Bags n);
A9:   f.i = ddbi1 ^^ ((len ddbi1) |-> <*(db/.i)/.2*>) by A3,A6;
      consider b1, b2 being bag of n such that
A10:  db/.i = <*b1,b2*> and
A11:  b = b1+b2 by A1,A6,Th72;
      reconsider b1' = b1, b2' = b2 as Element of Bags n by Def14;
A12:  b1' = b1 & b2' = b2;
      then
A13:  (db/.i)/.1 = b1 by A10,FINSEQ_4:26;
A14:  (db/.i)/.2 = b2 by A10,A12,FINSEQ_4:26;
A15:  dom (f.i) = dom ddbi1 /\ dom ((len ddbi1) |-> <*(db/.i)/.2*>)
      by A9,MATRLIN:def 2
        .= dom ddbi1 /\ Seg len ddbi1 by FUNCOP_1:19
        .= dom ddbi1 /\ dom ddbi1 by FINSEQ_1:def 3
        .= dom ddbi1;
      then consider b11, b12 being bag of n such that
A16:  ddbi1/.j = <*b11, b12*> and
A17:  b1 = b11+b12 by A7,A13,Th72;
A18:  dom ddbi1 = Seg len ddbi1 by FINSEQ_1:def 3;
A19:  ddbi1/.j = ddbi1.j by A7,A15,PARTFUN1:def 8;
      ((len ddbi1) |-> <*(db/.i)/.2*>).j = <*(db/.i)/.2*>
      by A7,A15,A18,FUNCOP_1:13;
      then
A20:  (f.i).j = <*b11,b12*>^<*b2*> by A7,A9,A14,A16,A19,MATRLIN:def 2
        .= <*b11,b12,b2*> by FINSEQ_1:60;
      b = b11+(b12+b2) by A11,A17,Th39;
      then consider i' being Element of NAT such that
A21:  i' in dom decomp b and
A22:  (decomp b)/.i' = <*b11, b12+b2*> by Th73;
      set b3 = b12+b2;
      consider j' being Element of NAT such that
A23:  j' in dom decomp b3 and
A24:  (decomp b3)/.j' = <*b12, b2*> by Th73;
      set ddbi'2 = decomp ((((decomp b)/.i')/.2) qua Element of Bags n);
A25:  g.i' = ((len ddbi'2) |-> <*((decomp b)/.i')/.1*>) ^^ ddbi'2 by A2,A4,A21;
      reconsider b11' = b11, b3' = b3 as Element of Bags n by Def14;
A26:  (decomp b)/.i' = <*b11', b3'*> by A22;
      then
A27:  ((decomp b)/.i')/.1 = b11 by FINSEQ_4:26;
A28:  ddbi'2 = decomp b3 by A26,FINSEQ_4:26;
A29:  dom (g.i') = dom ((len ddbi'2) |-> <*((decomp b)/.i')/.1*>)
      /\ dom ddbi'2 by A25,MATRLIN:def 2
        .= Seg len ddbi'2 /\ dom ddbi'2 by FUNCOP_1:19
        .= dom ddbi'2 /\ dom ddbi'2 by FINSEQ_1:def 3
        .= dom ddbi'2;
      then
A30:  j' in dom (g.i') by A23,A26,FINSEQ_4:26;
      then
A31:  j' in Seg len ddbi'2 by A29,FINSEQ_1:def 3;
A32:  (decomp b3)/.j' = (decomp b3).j' by A23,PARTFUN1:def 8;
A33:  (g.i').j' = (((len ddbi'2) |-> <*((decomp b)/.i')/.1*>)).j'
      ^ (ddbi'2).j' by A25,A30,MATRLIN:def 2
        .= <*b11*>^<*b12,b2*> by A24,A27,A28,A31,A32,FUNCOP_1:13
        .= <*b11,b12,b2*> by FINSEQ_1:60;
      set m = (Sum Card (g|(i'-'1))) + j';
A34:  m in dom Fg by A2,A21,A30,Th33;
      Fg.m = (g.i').j' by A2,A21,A30,Th33;
      hence y in rng Fg by A5,A8,A20,A33,A34,FUNCT_1:def 5;
    end;
    assume y in rng Fg;
    then consider k being set such that
A35: k in dom Fg & y = Fg.k by FUNCT_1:def 5;
    reconsider k as Element of NAT by A35;
    consider i, j being Element of NAT such that
A36: i in dom g and
A37: j in dom (g.i) and k = (Sum Card (g|(i-'1))) + j and
A38: (g.i).j = Fg.k by A35,Th32;
    set ddbi1 = decomp (((db/.i)/.2) qua Element of Bags n);
A39: g.i = ((len ddbi1) |-> <*(db/.i)/.1*>) ^^ ddbi1 by A4,A36;
    consider b1, b2 being bag of n such that
A40: db/.i = <*b1,b2*> and
A41: b = b1+b2 by A2,A36,Th72;
    reconsider b1' = b1, b2' = b2 as Element of Bags n by Def14;
A42: b1' = b1 & b2' = b2;
    then
A43: (db/.i)/.1 = b1 by A40,FINSEQ_4:26;
A44: (db/.i)/.2 = b2 by A40,A42,FINSEQ_4:26;
A45: dom (g.i) = dom ddbi1 /\ dom ((len ddbi1) |-> <*(db/.i)/.1*>)
    by A39,MATRLIN:def 2
      .= dom ddbi1 /\ Seg len ddbi1 by FUNCOP_1:19
      .= dom ddbi1 /\ dom ddbi1 by FINSEQ_1:def 3
      .= dom ddbi1;
    then consider b11, b12 being bag of n such that
A46: ddbi1/.j = <*b11, b12*> and
A47: b2 = b11+b12 by A37,A44,Th72;
A48: ddbi1/.j = ddbi1.j by A37,A45,PARTFUN1:def 8;
    dom ddbi1 = Seg len ddbi1 by FINSEQ_1:def 3;
    then ((len ddbi1) |-> <*(db/.i)/.1*>).j = <*(db/.i)/.1*>
    by A37,A45,FUNCOP_1:13;
    then
A49: (g.i).j = <*b1*>^<*b11,b12*> by A37,A39,A43,A46,A48,MATRLIN:def 2
      .= <*b1,b11,b12*> by FINSEQ_1:60;
    b = b1+b11+b12 by A41,A47,Th39;
    then consider i' being Element of NAT such that
A50: i' in dom decomp b and
A51: (decomp b)/.i' = <*b1+b11, b12*> by Th73;
    set b3 = b1+b11;
    consider j' being Element of NAT such that
A52: j' in dom decomp b3 and
A53: (decomp b3)/.j' = <*b1, b11*> by Th73;
    set ddbi'2 = decomp ((((decomp b)/.i')/.1) qua Element of Bags n);
A54: f.i' = ddbi'2 ^^ ((len ddbi'2) |-> <*((decomp b)/.i')/.2*>) by A1,A3,A50;
    reconsider b3' = b3, b12' = b12 as Element of Bags n by Def14;
A55: (decomp b)/.i' = <*b3', b12'*> by A51;
    then
A56: ((decomp b)/.i')/.2 = b12 by FINSEQ_4:26;
A57: ((decomp b)/.i')/.1 = b3 by A55,FINSEQ_4:26;
A58: dom (f.i') = dom ((len ddbi'2) |-> <*((decomp b)/.i')/.2*>)
    /\ dom ddbi'2 by A54,MATRLIN:def 2
      .= Seg len ddbi'2 /\ dom ddbi'2 by FUNCOP_1:19
      .= dom ddbi'2 /\ dom ddbi'2 by FINSEQ_1:def 3
      .= dom ddbi'2;
A59: j' in Seg len ddbi'2 by A52,A57,FINSEQ_1:def 3;
A60: (decomp b3)/.j' = (decomp b3).j' by A52,PARTFUN1:def 8;
A61: (f.i').j' = (ddbi'2).j' ^ (((len ddbi'2) |-> <*((decomp b)/.i')/.2*>)).j'
    by A52,A54,A57,A58,MATRLIN:def 2
      .= <*b1,b11*>^<*b12*> by A53,A56,A57,A59,A60,FUNCOP_1:13
      .= <*b1,b11,b12*> by FINSEQ_1:60;
    set m = (Sum Card (f|(i'-'1))) + j';
A62: m in dom Ff by A1,A50,A52,A57,A58,Th33;
    Ff.m = (f.i').j' by A1,A50,A52,A57,A58,Th33;
    hence y in rng Ff by A35,A38,A49,A61,A62,FUNCT_1:def 5;
  end;
  then
A63: rng Ff = rng Fg by TARSKI:2;
A64: Ff is one-to-one
  proof
    let k1, k2 be set such that
A65: k1 in dom Ff and
A66: k2 in dom Ff and
A67: Ff.k1 = Ff.k2;
    consider i1, j1 being Element of NAT such that
A68: i1 in dom f and
A69: j1 in dom (f.i1) and
A70: k1 = (Sum Card (f|(i1-'1))) + j1 and
A71: (f.i1).j1 = Ff.k1 by A65,Th32;
    consider i2, j2 being Element of NAT such that
A72: i2 in dom f and
A73: j2 in dom (f.i2) and
A74: k2 = (Sum Card (f|(i2-'1))) + j2 and
A75: (f.i2).j2 = Ff.k2 by A66,Th32;
    set ddbi11 = decomp (((db/.i1)/.1) qua Element of Bags n);
A76: f.i1 = ddbi11 ^^ ((len ddbi11) |-> <*(db/.i1)/.2*>) by A3,A68;
A77: db/.i1 = db.i1 by A1,A68,PARTFUN1:def 8;
    consider b11, b12 being bag of n such that
A78: db/.i1 = <*b11,b12*> and b = b11+b12 by A1,A68,Th72;
    reconsider b11' = b11, b12' = b12 as Element of Bags n by Def14;
A79: b11' = b11 & b12' = b12;
    then
A80: (db/.i1)/.1 = b11 by A78,FINSEQ_4:26;
A81: (db/.i1)/.2 = b12 by A78,A79,FINSEQ_4:26;
A82: dom (f.i1) = dom ddbi11 /\ dom ((len ddbi11) |-> <*(db/.i1)/.2*>)
    by A76,MATRLIN:def 2
      .= dom ddbi11 /\ Seg len ddbi11 by FUNCOP_1:19
      .= dom ddbi11 /\ dom ddbi11 by FINSEQ_1:def 3
      .= dom ddbi11;
    then consider b111, b112 being bag of n such that
A83: ddbi11/.j1 = <*b111, b112*> and
A84: b11 = b111+b112 by A69,A80,Th72;
A85: ddbi11/.j1 = ddbi11.j1 by A69,A82,PARTFUN1:def 8;
    dom ddbi11 = Seg len ddbi11 by FINSEQ_1:def 3;
    then ((len ddbi11) |-> <*(db/.i1)/.2*>).j1 = <*(db/.i1)/.2*>
    by A69,A82,FUNCOP_1:13;
    then
A86: (f.i1).j1 = <*b111,b112*>^<*b12*> by A69,A76,A81,A83,A85,MATRLIN:def 2
      .= <*b111,b112,b12*> by FINSEQ_1:60;
    set ddbi21 = decomp (((db/.i2)/.1) qua Element of Bags n);
A87: f.i2 = ddbi21 ^^ ((len ddbi21) |-> <*(db/.i2)/.2*>) by A3,A72;
A88: db/.i2 = db.i2 by A1,A72,PARTFUN1:def 8;
    consider b21, b22 being bag of n such that
A89: db/.i2 = <*b21,b22*> and b = b21+b22 by A1,A72,Th72;
    reconsider b21' = b21, b22' = b22 as Element of Bags n by Def14;
A90: b21' = b21 & b22' = b22;
    then
A91: (db/.i2)/.1 = b21 by A89,FINSEQ_4:26;
A92: (db/.i2)/.2 = b22 by A89,A90,FINSEQ_4:26;
A93: dom (f.i2) = dom ddbi21 /\ dom ((len ddbi21) |-> <*(db/.i2)/.2*>)
    by A87,MATRLIN:def 2
      .= dom ddbi21 /\ Seg len ddbi21 by FUNCOP_1:19
      .= dom ddbi21 /\ dom ddbi21 by FINSEQ_1:def 3
      .= dom ddbi21;
    then consider b211, b212 being bag of n such that
A94: ddbi21/.j2 = <*b211, b212*> and
A95: b21 = b211+b212 by A73,A91,Th72;
A96: dom ddbi21 = Seg len ddbi21 by FINSEQ_1:def 3;
A97: ddbi21/.j2 = ddbi21.j2 by A73,A93,PARTFUN1:def 8;
    ((len ddbi21) |-> <*(db/.i2)/.2*>).j2 = <*(db/.i2)/.2*>
    by A73,A93,A96,FUNCOP_1:13;
    then (f.i2).j2 = <*b211,b212*>^<*b22*> by A73,A87,A92,A94,A97,MATRLIN:def 2
      .= <*b211,b212,b22*> by FINSEQ_1:60;
    then
A98: b111 = b211 & b112 = b212 & b12 = b22 by A67,A71,A75,A86,GROUP_7:3;
    then i1 = i2 by A1,A68,A72,A77,A78,A84,A88,A89,A95,FUNCT_1:def 8;
    hence thesis by A69,A70,A73,A74,A83,A85,A93,A94,A97,A98,FUNCT_1:def 8;
  end;
  Fg is one-to-one
  proof
    let k1, k2 be set such that
A99: k1 in dom Fg and
A100: k2 in dom Fg and
A101: Fg.k1 = Fg.k2;
    consider i1, j1 being Element of NAT such that
A102: i1 in dom g and
A103: j1 in dom (g.i1) and
A104: k1 = (Sum Card (g|(i1-'1))) + j1 and
A105: (g.i1).j1 = Fg.k1 by A99,Th32;
    consider i2, j2 being Element of NAT such that
A106: i2 in dom g and
A107: j2 in dom (g.i2) and
A108: k2 = (Sum Card (g|(i2-'1))) + j2 and
A109: (g.i2).j2 = Fg.k2 by A100,Th32;
    set ddbi11 = decomp (((db/.i1)/.2) qua Element of Bags n);
A110: g.i1 = ((len ddbi11) |-> <*(db/.i1)/.1*>)^^ddbi11 by A4,A102;
A111: db/.i1 = db.i1 by A2,A102,PARTFUN1:def 8;
    consider b11, b12 being bag of n such that
A112: db/.i1 = <*b11,b12*> and b = b11+b12 by A2,A102,Th72;
    reconsider b11' = b11, b12' = b12 as Element of Bags n by Def14;
A113: b11' = b11 & b12' = b12;
    then
A114: (db/.i1)/.1 = b11 by A112,FINSEQ_4:26;
A115: (db/.i1)/.2 = b12 by A112,A113,FINSEQ_4:26;
A116: dom (g.i1) = dom ddbi11 /\ dom ((len ddbi11) |-> <*(db/.i1)/.1*>)
    by A110,MATRLIN:def 2
      .= dom ddbi11 /\ Seg len ddbi11 by FUNCOP_1:19
      .= dom ddbi11 /\ dom ddbi11 by FINSEQ_1:def 3
      .= dom ddbi11;
    then consider b111, b112 being bag of n such that
A117: ddbi11/.j1 = <*b111, b112*> and
A118: b12 = b111+b112 by A103,A115,Th72;
A119: dom ddbi11 = Seg len ddbi11 by FINSEQ_1:def 3;
A120: ddbi11/.j1 = ddbi11.j1 by A103,A116,PARTFUN1:def 8;
    ((len ddbi11) |-> <*(db/.i1)/.1*>).j1 = <*(db/.i1)/.1*>
    by A103,A116,A119,FUNCOP_1:13;
    then
A121: (g.i1).j1 = <*b11*>^<*b111,b112*> by A103,A110,A114,A117,A120,
MATRLIN:def 2
      .= <*b11,b111,b112*> by FINSEQ_1:60;
    set ddbi21 = decomp (((db/.i2)/.2) qua Element of Bags n);
A122: g.i2 = ((len ddbi21) |-> <*(db/.i2)/.1*>) ^^ ddbi21 by A4,A106;
A123: db/.i2 = db.i2 by A2,A106,PARTFUN1:def 8;
    consider b21, b22 being bag of n such that
A124: db/.i2 = <*b21,b22*> and b = b21+b22 by A2,A106,Th72;
    reconsider b21' = b21, b22' = b22 as Element of Bags n by Def14;
A125: b21' = b21 & b22' = b22;
    then
A126: (db/.i2)/.1 = b21 by A124,FINSEQ_4:26;
A127: (db/.i2)/.2 = b22 by A124,A125,FINSEQ_4:26;
A128: dom (g.i2) = dom ddbi21 /\ dom ((len ddbi21) |-> <*(db/.i2)/.1*>)
    by A122,MATRLIN:def 2
      .= dom ddbi21 /\ Seg len ddbi21 by FUNCOP_1:19
      .= dom ddbi21 /\ dom ddbi21 by FINSEQ_1:def 3
      .= dom ddbi21;
    then consider b211, b212 being bag of n such that
A129: ddbi21/.j2 = <*b211, b212*> and
A130: b22 = b211+b212 by A107,A127,Th72;
A131: ddbi21/.j2 = ddbi21.j2 by A107,A128,PARTFUN1:def 8;
    dom ddbi21 = Seg len ddbi21 by FINSEQ_1:def 3;
    then ((len ddbi21) |-> <*(db/.i2)/.1*>).j2 = <*(db/.i2)/.1*>
    by A107,A128,FUNCOP_1:13;
    then (g.i2).j2 = <*b21*>^<*b211,b212*> by A107,A122,A126,A129,A131,
MATRLIN:def 2
      .= <*b21,b211, b212*> by FINSEQ_1:60;
    then
A132: b111 = b211 & b112 = b212 & b11 = b21 by A101,A105,A109,A121,GROUP_7:3;
    then i1 = i2 by A2,A102,A106,A111,A112,A118,A123,A124,A130,FUNCT_1:def 8;
    hence thesis
    by A103,A104,A107,A108,A117,A120,A128,A129,A131,A132,FUNCT_1:def 8;
  end;
  then Ff, Fg are_fiberwise_equipotent by A63,A64,RFINSEQ:39;
  hence thesis by RFINSEQ:17;
end;

begin :: Formal power series --------------------------------------------------

definition
  let X be set, S be 1-sorted;
  mode Series of X, S is Function of Bags X, S;
end;

definition
  let n be set, L be non empty addLoopStr, p, q be Series of n, L;
  canceled;
  func p+q -> Series of n, L means
  :Def21:
  for x being bag of n holds it.x = p.x+q.x;
  existence
  proof
    deffunc F(Element of Bags n) = p.$1+q.$1;
    consider f being Function of Bags n, the carrier of L such that
A1: for x being Element of Bags n holds f.x = F(x) from FUNCT_2:sch 4;
    reconsider f as Function of Bags n, L;
    reconsider f as Series of n, L;
    take f;
    let x be bag of n;
    x in Bags n by Def14;
    hence thesis by A1;
  end;
  uniqueness
  proof
    let it1, it2 be Series of n, L such that
A2: for x being bag of n holds it1.x = p.x+q.x and
A3: for x being bag of n holds it2.x = p.x+q.x;
    now
      let x be Element of Bags n;
      reconsider x' = x as bag of n;
      thus it1.x = p.x'+q.x' by A2
        .= it2.x by A3;
    end;
    hence it1 = it2 by FUNCT_2:113;
  end;
end;

theorem Th79:
  for n being set, L being right_zeroed (non empty addLoopStr),
  p, q being Series of n, L holds Support (p+q) c= Support p \/ Support q
proof
  let n be set, L be right_zeroed (non empty addLoopStr),
  p, q be Series of n, L;
  set f = p+q, Sp = Support p, Sq = Support q;
  let x be set;
  assume
A1: x in Support f;
  then reconsider x' = x as Element of Bags n;
  f.x' <> 0.L by A1,Def9;
  then p.x'+q.x' <> 0.L by Def21;
  then not(p.x' = 0.L & q.x' = 0.L) by RLVECT_1:def 7;
  then x' in Sp or x' in Sq by Def9;
  hence thesis by XBOOLE_0:def 3;
end;

definition
  let n be set, L be Abelian right_zeroed (non empty addLoopStr),
  p, q be Series of n, L;
  redefine func p+q;
  commutativity
  proof
    let p, q be Series of n, L;
    now
      let b be Element of Bags n;
      thus (p + q).b = q.b + p.b by Def21
        .= (q + p).b by Def21;
    end;
    hence p+q = q+p by FUNCT_2:113;
  end;
end;

theorem Th80:
  for n being set,
  L being add-associative right_zeroed (non empty doubleLoopStr),
  p, q, r being Series of n, L holds (p+q)+r = p+(q+r)
proof
  let n be set, L be add-associative right_zeroed (non empty doubleLoopStr),
  p, q, r be Series of n, L;
  now
    let b be Element of Bags n;
    thus ((p+q)+r).b = (p+q).b+r.b by Def21
      .= p.b+q.b+r.b by Def21
      .= p.b+(q.b+r.b) by RLVECT_1:def 6
      .= p.b+(q+r).b by Def21
      .= (p+(q+r)).b by Def21;
  end;
  hence thesis by FUNCT_2:113;
end;

definition
  let n be set, L be add-associative right_zeroed right_complementable
  (non empty addLoopStr), p be Series of n, L;
  func -p -> Series of n, L means
  :Def22:
  for x being bag of n holds it.x = -(p.x);
  existence
  proof
    deffunc F(Element of Bags n) = -(p.$1);
    consider f being Function of Bags n, the carrier of L such that
A1: for x being Element of Bags n holds f.x = F(x) from FUNCT_2:sch 4;
    reconsider f as Function of Bags n, L;
    reconsider f as Series of n, L;
    take f;
    let x be bag of n;
    x in Bags n by Def14;
    hence thesis by A1;
  end;
  uniqueness
  proof
    let it1, it2 be Series of n, L such that
A2: for x being bag of n holds it1.x = -(p.x) and
A3: for x being bag of n holds it2.x = -(p.x);
    now
      let b be Element of Bags n;
      thus it1.b = -(p.b) by A2
        .= it2.b by A3;
    end;
    hence it1 = it2 by FUNCT_2:113;
  end;
  involutiveness
  proof
    let p,q be Series of n, L such that
A4: for x being bag of n holds p.x = -(q.x);
    let x be bag of n;
    thus q.x = --(q.x) by RLVECT_1:30
      .= -(p.x) by A4;
  end;
end;

definition
  let n be set, L be add-associative right_zeroed right_complementable
  (non empty addLoopStr), p, q be Series of n, L;
  func p-q -> Series of n, L equals

  p+-q;
  coherence;
end;

definition
  let n be set, S be non empty ZeroStr;
  func 0_(n, S) -> Series of n, S equals

  (Bags n) --> 0.S;
  coherence;
end;

theorem Th81:
  for n being set, S being non empty ZeroStr, b be bag of n
  holds (0_(n, S)).b = 0.S
proof
  let n be set, S be non empty ZeroStr, b be bag of n;
  b in Bags n by Def14;
  hence thesis by FUNCOP_1:13;
end;

theorem Th82:

for n being set, L be right_zeroed (non empty addLoopStr), p be Series of n, L
  holds p+0_(n,L) = p
proof
  let n be set, L be right_zeroed (non empty addLoopStr), p be Series of n, L;
  reconsider ls = p+0_(n,L), p' = p as Function of (Bags n), the carrier of L;
  now
    let b be Element of Bags n;
    thus ls.b = p.b + 0_(n,L).b by Def21
      .= p'.b+0.L by Th81
      .= p'.b by RLVECT_1:def 7;
  end;
  hence thesis by FUNCT_2:113;
end;

definition
  let n be set, L be right_unital (non empty multLoopStr_0);
  func 1_(n,L) -> Series of n, L equals

  0_(n,L)+*(EmptyBag n,1.L);
  coherence;
end;

theorem Th83:
  for n being set, L being add-associative right_zeroed right_complementable
  (non empty addLoopStr), p being Series of n, L holds p-p = 0_(n,L)
proof
  let n be set, L be add-associative right_zeroed right_complementable
  (non empty addLoopStr), p be Series of n, L;
  reconsider pp = p-p, Z = 0_(n,L) as Function of Bags n, the carrier of L;
  now
    let b be Element of Bags n;
    thus pp.b = p.b+(-p).b by Def21
      .= p.b + -p.b by Def22
      .= 0.L by RLVECT_1:def 11
      .= Z.b by Th81;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th84:
  for n being set, L being right_unital (non empty multLoopStr_0)
  holds (1_(n,L)).EmptyBag n = 1.L &
  for b being bag of n st b <> EmptyBag n holds (1_(n,L)).b = 0.L
proof
  let n be set, L be right_unital (non empty multLoopStr_0);
  set Z = 0_(n,L);
  dom Z = Bags n by FUNCOP_1:19;
  hence (1_(n,L)).EmptyBag n = 1.L by FUNCT_7:33;
  let b be bag of n;
  assume
A1: b <> EmptyBag n;
A2: b in Bags n by Def14;
  thus (1_(n,L)).b = Z.b by A1,FUNCT_7:34
    .= 0.L by A2,FUNCOP_1:13;
end;

definition
  let n be Ordinal, L be add-associative right_complementable
  right_zeroed (non empty doubleLoopStr), p, q be Series of n, L;
  func p*'q -> Series of n, L means
  :Def26:
  for b being bag of n
  ex s being FinSequence of the carrier of L st it.b = Sum s &
  len s = len decomp b & for k being Element of NAT st k in dom s
  ex b1, b2 being bag of n st (decomp b)/.k = <*b1, b2*> & s/.k = p.b1*q.b2;
  existence
  proof
    defpred P[Element of Bags n, Element of L] means
    ex b being bag of n st b = $1 &
    ex s being FinSequence of the carrier of L st $2 = Sum s &
    len s = len decomp b & for k being Element of NAT st k in dom s
    ex b1, b2 being bag of n st (decomp b)/.k = <*b1, b2*> & s/.k = p.b1*q.b2;
A1: now
      let bb be Element of Bags n;
      reconsider b = bb as bag of n;
      defpred Q[Nat, set] means
      ex b1, b2 being bag of n st (decomp b)/.$1 = <*b1, b2*> &
      $2 = p.b1*q.b2;
A2:   now
        let k be Nat;
        assume k in Seg len decomp b;
        then k in dom decomp b by FINSEQ_1:def 3;
        then consider b1, b2 being bag of n such that
A3:     (decomp b)/.k = <*b1,b2*> and b = b1+b2 by Th72;
        reconsider x = p.b1*q.b2 as Element of L;
        take x;
        thus Q[k,x] by A3;
      end;
      consider s being FinSequence of the carrier of L such that
A4:   len s = len decomp b and
A5:   for k being Nat st k in Seg len decomp b holds Q[k, s/.k]
      from FINSEQ_4:sch 1 (A2);
      reconsider y = Sum s as Element of L;
      take y;
      thus P[bb,y]
      proof
        take b; thus b = bb;
        take s; thus y = Sum s;
        thus len s = len decomp b by A4;
        let k be Element of NAT;
        assume k in dom s;
        then k in Seg len decomp b by A4,FINSEQ_1:def 3;
        hence thesis by A5;
      end;
    end;
    consider P being Function of (Bags n), the carrier of L such that
A6: for b being Element of Bags n holds P[b, P.b] from FUNCT_2:sch 3(A1);
    reconsider P as Function of (Bags n), L;
    reconsider P as Series of n, L;
    take P;
    let b be bag of n;
    reconsider bb = b as Element of Bags n by Def14;
    P[bb, P.bb] by A6;
    hence thesis;
  end;
  uniqueness
  proof
    let it1, it2 be Series of n, L such that
A7: for b being bag of n ex s being FinSequence of the carrier of L st
    it1.b = Sum s & len s = len decomp b &
    for k being Element of NAT st k in dom s ex b1, b2 being bag of n
    st (decomp b)/.k = <*b1, b2*> & s/.k = p.b1*q.b2 and
A8: for b being bag of n ex s being FinSequence of the carrier of L st
    it2.b = Sum s & len s = len decomp b &
    for k being Element of NAT st k in dom s ex b1, b2 being bag of n
    st (decomp b)/.k = <*b1, b2*> & s/.k = p.b1*q.b2;
    reconsider ita = it1, itb = it2 as Function of (Bags n), the carrier of L;
    now
      let b be Element of Bags n;
      consider sa being FinSequence of the carrier of L such that
A9:   ita.b = Sum sa and
A10:  len sa = len decomp b and
A11:  for k being Element of NAT st k in dom sa
      ex b1, b2 being bag of n st (decomp b)/.k = <*b1, b2*> &
      sa/.k = p.b1*q.b2 by A7;
      consider sb being FinSequence of the carrier of L such that
A12:  itb.b = Sum sb and
A13:  len sb = len decomp b and
A14:  for k being Element of NAT st k in dom sb
      ex b1, b2 being bag of n st (decomp b)/.k = <*b1, b2*> &
      sb/.k = p.b1*q.b2 by A8;
      now
        let k be Nat;
        assume
A15:    1 <= k & k <= len sa;
        then
A16:    k in dom sa by FINSEQ_3:27;
        then consider ab1, ab2 being bag of n such that
A17:    (decomp b)/.k = <*ab1, ab2*> and
A18:    sa/.k = p.ab1*q.ab2 by A11;
A19:    k in dom sb by A10,A13,A15,FINSEQ_3:27;
        then consider bb1, bb2 being bag of n such that
A20:    (decomp b)/.k = <*bb1, bb2*> and
A21:    sb/.k = p.bb1*q.bb2 by A14;
A22:    sa/.k = sa.k & sb/.k = sb.k by A16,A19,PARTFUN1:def 8;
        ab1 = bb1 & ab2 = bb2 by A17,A20,GROUP_7:2;
        hence sa.k = sb.k by A18,A21,A22;
      end;
      hence ita.b = itb.b by A9,A10,A12,A13,FINSEQ_1:18;
    end;
    hence it1 = it2 by FUNCT_2:113;
  end;
end;

theorem Th85:
  for n being Ordinal,
  L being Abelian add-associative right_zeroed right_complementable
  distributive associative (non empty doubleLoopStr),
  p, q, r being Series of n, L holds p*'(q+r) = p*'q+p*'r
proof
  let n be Ordinal,
  L be Abelian add-associative right_zeroed right_complementable
  distributive associative (non empty doubleLoopStr),
  p, q, r be Series of n, L;
  set cL = the carrier of L;
  now
    let b be Element of Bags n;
    consider s being FinSequence of cL such that
A1: (p*'(q+r)).b = Sum s and
A2: len s = len decomp b and
A3: for k being Element of NAT st k in dom s
    ex b1, b2 being bag of n st (decomp b)/.k = <*b1, b2*> &
    s/.k = p.b1*(q+r).b2 by Def26;
    consider t being FinSequence of cL such that
A4: (p*'q).b = Sum t and
A5: len t = len decomp b and
A6: for k being Element of NAT st k in dom t
    ex b1, b2 being bag of n st (decomp b)/.k = <*b1, b2*> &
    t/.k = p.b1*q.b2 by Def26;
    consider u being FinSequence of cL such that
A7: (p*'r).b = Sum u and
A8: len u = len decomp b and
A9: for k being Element of NAT st k in dom u
    ex b1, b2 being bag of n st (decomp b)/.k = <*b1, b2*> &
    u/.k = p.b1*r.b2 by Def26;
    reconsider S = s, t, u as Element of (len s)-tuples_on cL
    by A2,A5,A8,FINSEQ_2:110;
A10: dom t = dom s & dom u = dom s by A2,A5,A8,FINSEQ_3:31;
    then
A11: dom (t+u) = dom s by Th5;
    then
A12: len (t+u) = len s by FINSEQ_3:31;
X: dom s = Seg len s by FINSEQ_1:def 3;
    now
      let i be Nat;
      assume i in dom s;
      then 1 <= i & i <= len s by X,FINSEQ_1:3;
      then
A13:  i in dom s by FINSEQ_3:27;
      then consider sb1, sb2 being bag of n such that
A14:  (decomp b)/.i = <*sb1, sb2*> & s/.i = p.sb1*(q+r).sb2 by A3;
      consider tb1, tb2 being bag of n such that
A15:  (decomp b)/.i = <*tb1, tb2*> & t/.i = p.tb1*q.tb2 by A6,A10,A13;
      consider ub1, ub2 being bag of n such that
A16:  (decomp b)/.i = <*ub1, ub2*> & u/.i = p.ub1*r.ub2 by A9,A10,A13;
A17:  sb1 = tb1 & sb1 = ub1 & sb2 = tb2 & sb2 = ub2 by A14,A15,A16,GROUP_7:2;
A18:  s/.i = s.i & t/.i = t.i & u/.i = u.i by A10,A13,PARTFUN1:def 8;
      hence s.i = p.sb1*(q.sb2+r.sb2) by A14,Def21
        .= p.sb1*q.sb2+p.sb1*r.sb2 by VECTSP_1:def 18
        .= (t + u).i by A11,A13,A15,A16,A17,A18,FVSUM_1:21;
    end;
    then s = t + u by A12,FINSEQ_2:10;
    hence (p*'(q+r)).b = Sum t + Sum u by A1,FVSUM_1:95
      .= (p*'q+p*'r).b by A4,A7,Def21;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th86:
  for n being Ordinal,
  L being Abelian add-associative right_zeroed right_complementable
  right_unital distributive associative (non empty doubleLoopStr),
  p, q, r being Series of n, L holds (p*'q)*'r = p*'(q*'r)
proof
  let n be Ordinal,
  L be Abelian add-associative right_zeroed right_complementable
  right_unital distributive associative (non empty doubleLoopStr),
  p, q, r be Series of n, L;
  set cL = the carrier of L;
  reconsider pqra = (p*'q)*'r, pqrb = p*'(q*'r) as Function of Bags n, cL;
  set pq = p*'q, qr = q*'r;
  now
    let b be Element of Bags n;
    set db = decomp b;
    consider ls being FinSequence of cL such that
A1: pqra.b = Sum ls and
A2: len ls = len decomp b and
A3: for k being Element of NAT st k in dom ls
    ex b1,b2 being bag of n st db/.k = <*b1,b2*> &
    ls/.k = pq.b1*r.b2 by Def26;
    consider rs being FinSequence of cL such that
A4: pqrb.b = Sum rs and
A5: len rs = len decomp b and
A6: for k being Element of NAT st k in dom rs
    ex b1,b2 being bag of n st db/.k = <*b1,b2*> &
    rs/.k = p.b1*qr.b2 by Def26;
    deffunc F(Nat)
    = ((decomp (((db/.$1)/.1) qua Element of Bags n))) ^^
    ((len (decomp (((db/.$1)/.1) qua Element of Bags n)))|-> <*(db/.$1)/.2*>);
    consider dbl being FinSequence such that
A7: len dbl = len db and
A8: for k being Nat st k in dom dbl holds dbl.k = F(k) from FINSEQ_1:sch 2;
    deffunc G(Nat)
    = ((len (decomp (((db/.$1)/.2) qua Element of Bags n)))
    |-> <*(db/.$1)/.1*>) ^^ ((decomp (((db/.$1)/.2) qua Element of Bags n)));
    consider dbr being FinSequence such that
A9: len dbr = len db and
A10: for k being Nat st k in dom dbr holds dbr.k = G(k) from FINSEQ_1:sch 2;
A11: rng dbl c= (3-tuples_on Bags n)*
    proof
      let y be set;
      assume y in rng dbl;
      then consider k being set such that
A12:  k in dom dbl & y = dbl.k by FUNCT_1:def 5;
      set ddbk1 = decomp (((db/.k)/.1) qua Element of Bags n);
      set dbk2 = (db/.k)/.2;
      set dblk = ddbk1 ^^ ((len ddbk1) |-> <*dbk2*>);
      reconsider k as Nat by A12;
A13:  dbl.k = ddbk1 ^^ ((len ddbk1) |-> <*dbk2*>) by A8,A12;
A14:  dom dblk = dom ddbk1 /\ dom ((len ddbk1) |-> <*dbk2*>) by MATRLIN:def 2
        .= dom ddbk1 /\ Seg len ddbk1 by FUNCOP_1:19
        .= dom ddbk1 /\ dom ddbk1 by FINSEQ_1:def 3
        .= dom ddbk1;
A15:  dom ddbk1 = Seg len ddbk1 by FINSEQ_1:def 3;
      rng dblk c= 3-tuples_on Bags n
      proof
        let y be set;
        assume y in rng dblk;
        then consider i being set such that
A16:    i in dom dblk & dblk.i = y by FUNCT_1:def 5;
        ddbk1.i in rng ddbk1 by A14,A16,FUNCT_1:def 5;
        then reconsider Fi = ddbk1.i as Element of 2-tuples_on Bags n;
        reconsider i' = i as Element of NAT by A16;
A17:    ((len ddbk1) |-> <*dbk2*>).i' = <*dbk2*> by A14,A15,A16,FUNCOP_1:13;
        reconsider Gi = <*dbk2*> as Element of 1-tuples_on Bags n;
        y = Fi^Gi by A16,A17,MATRLIN:def 2;
        hence thesis;
      end;
      then dblk is FinSequence of 3-tuples_on Bags n by FINSEQ_1:def 4;
      hence thesis by A12,A13,FINSEQ_1:def 11;
    end;
    rng dbr c= (3-tuples_on Bags n)*
    proof
      let y be set;
      assume y in rng dbr;
      then consider k being set such that
A18:  k in dom dbr & y = dbr.k by FUNCT_1:def 5;
      reconsider k as Nat by A18;
      set ddbk1 = decomp (((db/.k)/.2) qua Element of Bags n);
      set dbk2 = (db/.k)/.1;
      set dbrk = ((len ddbk1) |-> <*dbk2*>) ^^ ddbk1;
A19:  dbr.k = ((len ddbk1) |-> <*dbk2*>) ^^ ddbk1 by A10,A18;
A20:  dom dbrk = dom ddbk1 /\ dom ((len ddbk1) |-> <*dbk2*>) by MATRLIN:def 2
        .= dom ddbk1 /\ Seg len ddbk1 by FUNCOP_1:19
        .= dom ddbk1 /\ dom ddbk1 by FINSEQ_1:def 3
        .= dom ddbk1;
A21:  dom ddbk1 = Seg len ddbk1 by FINSEQ_1:def 3;
      rng dbrk c= 3-tuples_on Bags n
      proof
        let y be set;
        assume y in rng dbrk;
        then consider i being set such that
A22:    i in dom dbrk & dbrk.i = y by FUNCT_1:def 5;
        ddbk1.i in rng ddbk1 by A20,A22,FUNCT_1:def 5;
        then reconsider Fi = ddbk1.i as Element of 2-tuples_on Bags n;
        reconsider i' = i as Element of NAT by A22;
A23:    ((len ddbk1) |-> <*dbk2*>).i' = <*dbk2*> by A20,A21,A22,FUNCOP_1:13;
        reconsider Gi = <*dbk2*> as Element of 1-tuples_on Bags n;
        y = Gi^Fi by A22,A23,MATRLIN:def 2;
        hence thesis;
      end;
      then dbrk is FinSequence of 3-tuples_on Bags n by FINSEQ_1:def 4;
      hence thesis by A18,A19,FINSEQ_1:def 11;
    end;
    then reconsider dbl, dbr as FinSequence of (3-tuples_on Bags n)* by A11,
FINSEQ_1:def 4;
    deffunc F(Element of 3-tuples_on Bags n) = p.($1/.1)*q.($1/.2)*r.($1/.3);
    consider v being Function of (3-tuples_on Bags n), cL such that
A24: for b being Element of 3-tuples_on Bags n holds
    v.b = F(b) from FUNCT_2:sch 4;
A25: dom v = 3-tuples_on Bags n by FUNCT_2:def 1;
    set fdbl = FlattenSeq dbl, fdbr = FlattenSeq dbr;
    reconsider vfdbl = v*fdbl,vfdbr = v*fdbr as FinSequence of cL
    by FINSEQ_2:36;
    consider vdbl being FinSequence of cL* such that
A26: vdbl = ((dom dbl --> v)**dbl) and
A27: vfdbl = FlattenSeq vdbl by Th36;
A28: Sum vfdbl = Sum Sum vdbl by A27,Th34;
    now
      set f = Sum vdbl;
A29:  dom f = dom vdbl by Th15;
A30:  dom vdbl = dom (dom dbl --> v) /\ dom dbl by A26,PBOOLE:def 24
        .= dom dbl /\ dom dbl by FUNCOP_1:19
        .= dom dbl;
      hence len Sum vdbl = len ls by A2,A7,A29,FINSEQ_3:31;
      let k be Nat such that
A31:  1 <= k & k <= len ls;
A32:  dom ls = dom f by A2,A7,A29,A30,FINSEQ_3:31;
A33:  k in dom f by A2,A7,A29,A30,A31,FINSEQ_3:27;
      then consider b1,b2 being bag of n such that
A34:  db/.k = <*b1,b2*> and
A35:  ls/.k = pq.b1*r.b2 by A3,A32;
      reconsider b2' = b2 as Element of Bags n by Def14;
      consider pqs being FinSequence of the carrier of L such that
A36:  pq.b1 = Sum pqs and
A37:  len pqs = len decomp b1 and
A38:  for i being Element of NAT st i in dom pqs
      ex b11, b12 being bag of n st (decomp b1)/.i = <*b11, b12*> &
      pqs/.i = p.b11*q.b12 by Def26;
A39:  Sum (pqs*r.b2) = (Sum pqs)*r.b2 by Th29;
A40:  k in dom vdbl by A2,A7,A30,A31,FINSEQ_3:27;
      set vdblk = v*(dbl.k);
      set ddbk1 = decomp (((db/.k)/.1) qua Element of Bags n);
      set dbk2 = (db/.k)/.2;
      len <*b1,b2*> = 2 by FINSEQ_1:61;
      then
A41:  1 in dom <*b1,b2*> & 2 in dom <*b1,b2*> by FINSEQ_3:27;
      then
A42:  dbk2 = <*b1,b2*>.2 by A34,PARTFUN1:def 8
        .= b2 by FINSEQ_1:61;
A43:  (db/.k)/.1 = <*b1,b2*>.1 by A34,A41,PARTFUN1:def 8
        .= b1 by FINSEQ_1:61;
A44:  dbl.k = ddbk1 ^^ ((len ddbk1) |-> <*dbk2*>) by A8,A30,A40;
      set dblk = dbl.k;
A45:  dom dblk
      = dom ddbk1 /\ dom ((len ddbk1) |-> <*dbk2*>) by A44,MATRLIN:def 2
        .= dom ddbk1 /\ Seg len ddbk1 by FUNCOP_1:19
        .= dom ddbk1 /\ dom ddbk1 by FINSEQ_1:def 3
        .= dom ddbk1;
      k in dom dbl by A2,A7,A31,FINSEQ_3:27;
      then dblk in rng dbl by FUNCT_1:def 5;
      then dblk is Element of (3-tuples_on Bags n)*;
      then reconsider dblk as FinSequence of 3-tuples_on Bags n;
A46:  dom ddbk1 = Seg len ddbk1 by FINSEQ_1:def 3;
      rng dblk c= 3-tuples_on Bags n;
      then
A47:  dom vdblk = dom dblk by A25,RELAT_1:46;
      then dom vdblk = Seg len ddbk1 by A45,FINSEQ_1:def 3;
      then reconsider vdblk as FinSequence by FINSEQ_1:def 2;
A48:  dom pqs = dom (pqs*r.b2) by Def3;
      now thus
        len vdblk = len pqs by A37,A43,A45,A47,FINSEQ_3:31
          .= len (pqs*r.b2) by A48,FINSEQ_3:31;
        then
A49:    dom vdblk = dom (pqs*r.b2) by FINSEQ_3:31;
        let i be Nat;
        assume
A50:    1 <= i & i <= len (pqs*r.b2);
        then
A51:    i in dom (pqs*r.b2) by FINSEQ_3:27;
        then consider b11, b12 being bag of n such that
A52:    (decomp b1)/.i = <*b11, b12*> and
A53:    pqs/.i = p.b11*q.b12 by A38,A48;
        reconsider i' = i as Element of NAT by ORDINAL1:def 13;
A54:    ((len ddbk1) |-> <*dbk2*>).i' = <*dbk2*>
        by A45,A46,A47,A49,A51,FUNCOP_1:13;
        (decomp b1)/.i = (decomp b1).i by A43,A45,A47,A49,A51,PARTFUN1:def 8;
        then
A55:    dblk.i = <*b11,b12*>^<*b2*>
        by A42,A43,A44,A47,A49,A51,A52,A54,MATRLIN:def 2
          .= <*b11,b12,b2*> by FINSEQ_1:60;
        reconsider b11' = b11, b12' = b12 as Element of Bags n by Def14;
        reconsider B = <*b11',b12',b2'*> as Element of 3-tuples_on Bags n
        by FINSEQ_2:124;
A56:    i in dom pqs by A48,A50,FINSEQ_3:27;
A57:    dom pqs = dom (pqs*r.b2) by Def3;
        thus (v*(dbl.k)).i = v.(dblk.i) by A49,A51,FUNCT_1:22
          .= p.(B/.1)*q.(B/.2)*r.(B/.3) by A24,A55
          .= p.b11'*q.(B/.2)*r.(B/.3) by FINSEQ_4:27
          .= p.b11*q.b12*r.(B/.3) by FINSEQ_4:27
          .= (pqs/.i)*r.b2 by A53,FINSEQ_4:27
          .= (pqs*r.b2)/.i by A56,Def3
          .= (pqs*r.b2).i by A56,A57,PARTFUN1:def 8;
      end;
      then
A58:  vdblk = pqs*r.b2 by FINSEQ_1:18;
A59:  vdbl/.k = vdbl.k by A40,PARTFUN1:def 8
        .= ((dom dbl --> v).k)*(dbl.k) by A26,A40,PBOOLE:def 24
        .= pqs*r.b2 by A30,A40,A58,FUNCOP_1:13;
A60:  ls/.k = ls.k by A32,A33,PARTFUN1:def 8;
      f/.k = f.k by A33,PARTFUN1:def 8;
      hence (Sum vdbl).k = ls.k by A33,A35,A36,A39,A59,A60,MATRLIN:def 8;
    end;
    then
A61: Sum vdbl = ls by FINSEQ_1:18;
    consider vdbr being FinSequence of cL* such that
A62: vdbr = ((dom dbr --> v)**dbr) and
A63: vfdbr = FlattenSeq vdbr by Th36;
A64: Sum vfdbr = Sum Sum vdbr by A63,Th34;
    now
      set f = Sum vdbr;
A65:  dom f = dom vdbr by Th15;
A66:  dom vdbr = dom (dom dbr --> v) /\ dom dbr by A62,PBOOLE:def 24
        .= dom dbr /\ dom dbr by FUNCOP_1:19
        .= dom dbr;
      hence len Sum vdbr = len rs by A5,A9,A65,FINSEQ_3:31;
      let k be Nat such that
A67:  1 <= k & k <= len rs;
A68:  dom rs = dom f by A5,A9,A65,A66,FINSEQ_3:31;
A69:  k in dom f by A5,A9,A65,A66,A67,FINSEQ_3:27;
      then consider b1,b2 being bag of n such that
A70:  db/.k = <*b1,b2*> and
A71:  rs/.k = p.b1*qr.b2 by A6,A68;
      reconsider b1' = b1 as Element of Bags n by Def14;
      consider qrs being FinSequence of the carrier of L such that
A72:  qr.b2 = Sum qrs and
A73:  len qrs = len decomp b2 and
A74:  for i being Element of NAT st i in dom qrs
      ex b11, b12 being bag of n st (decomp b2)/.i = <*b11, b12*> &
      qrs/.i = q.b11*r.b12 by Def26;
A75:  Sum (p.b1*qrs) = p.b1*(Sum qrs) by Th28;
A76:  k in dom vdbr by A5,A9,A66,A67,FINSEQ_3:27;
      set vdbrk = v*(dbr.k);
      set ddbk1 = decomp (((db/.k)/.2) qua Element of Bags n);
      set dbk2 = (db/.k)/.1;
      len <*b1,b2*> = 2 by FINSEQ_1:61;
      then
A77:  1 in dom <*b1,b2*> & 2 in dom <*b1,b2*> by FINSEQ_3:27;
      then
A78:  dbk2 = <*b1,b2*>.1 by A70,PARTFUN1:def 8
        .= b1 by FINSEQ_1:61;
A79:  (db/.k)/.2 = <*b1,b2*>.2 by A70,A77,PARTFUN1:def 8
        .= b2 by FINSEQ_1:61;
A80:  dbr.k = ((len ddbk1) |-> <*dbk2*>) ^^ ddbk1 by A10,A66,A76;
      set dbrk = dbr.k;
A81:  dom dbrk
      = dom ddbk1 /\ dom ((len ddbk1) |-> <*dbk2*>) by A80,MATRLIN:def 2
        .= dom ddbk1 /\ Seg len ddbk1 by FUNCOP_1:19
        .= dom ddbk1 /\ dom ddbk1 by FINSEQ_1:def 3
        .= dom ddbk1;
      k in dom dbr by A5,A9,A67,FINSEQ_3:27;
      then dbrk in rng dbr by FUNCT_1:def 5;
      then dbrk is Element of (3-tuples_on Bags n)*;
      then reconsider dbrk as FinSequence of 3-tuples_on Bags n;
A82:  dom ddbk1 = Seg len ddbk1 by FINSEQ_1:def 3;
      rng dbrk c= 3-tuples_on Bags n;
      then
A83:  dom vdbrk = dom dbrk by A25,RELAT_1:46;
      then dom vdbrk = Seg len ddbk1 by A81,FINSEQ_1:def 3;
      then reconsider vdbrk as FinSequence by FINSEQ_1:def 2;
A84:  dom qrs = dom (p.b1*qrs) by Def2;
      then
A85:  len qrs = len (p.b1*qrs) by FINSEQ_3:31;
      then
A86:  len vdbrk = len (p.b1*qrs) by A73,A79,A81,A83,FINSEQ_3:31;
A87:  dom vdbrk = dom (p.b1*qrs) by A73,A79,A81,A83,A84,FINSEQ_3:31;
      now
        let i be Nat;
        assume
A88:    1 <= i & i <= len (p.b1*qrs);
        then
A89:    i in dom dbrk by A73,A79,A81,A85,FINSEQ_3:27;
        then consider b11, b12 being bag of n such that
A90:    (decomp b2)/.i = <*b11, b12*> and
A91:    qrs/.i = q.b11*r.b12 by A74,A83,A84,A87;
        reconsider i' = i as Element of NAT by ORDINAL1:def 13;
A92:    ((len ddbk1) |-> <*dbk2*>).i' = <*dbk2*> by A81,A82,A89,FUNCOP_1:13;
        (decomp b2)/.i = (decomp b2).i by A79,A81,A89,PARTFUN1:def 8;
        then
A93:    dbrk.i = <*b1*>^<*b11,b12*> by A78,A79,A80,A89,A90,A92,MATRLIN:def 2
          .= <*b1,b11,b12*> by FINSEQ_1:60;
        reconsider b11' = b11, b12' = b12 as Element of Bags n by Def14;
        reconsider B = <*b1',b11',b12'*> as Element of 3-tuples_on Bags n
        by FINSEQ_2:124;
A94:    i in dom qrs by A84,A88,FINSEQ_3:27;
        thus (v*(dbr.k)).i = v.(dbrk.i) by A83,A89,FUNCT_1:22
          .= p.(B/.1)*q.(B/.2)*r.(B/.3) by A24,A93
          .= p.b1*q.(B/.2)*r.(B/.3) by FINSEQ_4:27
          .= p.b1*q.b11*r.(B/.3) by FINSEQ_4:27
          .= p.b1*q.b11*r.b12 by FINSEQ_4:27
          .= p.b1*(qrs/.i) by A91,GROUP_1:def 4
          .= (p.b1*qrs)/.i by A94,Def2
          .= (p.b1*qrs).i by A84,A94,PARTFUN1:def 8;
      end;
      then
A95:  vdbrk = p.b1*qrs by A86,FINSEQ_1:18;
A96:  vdbr/.k = vdbr.k by A76,PARTFUN1:def 8
        .= ((dom dbr --> v).k)*(dbr.k) by A62,A76,PBOOLE:def 24
        .= p.b1*qrs by A66,A76,A95,FUNCOP_1:13;
A97:  rs/.k = rs.k by A68,A69,PARTFUN1:def 8;
      f/.k = f.k by A69,PARTFUN1:def 8;
      hence (Sum vdbr).k = rs.k by A69,A71,A72,A75,A96,A97,MATRLIN:def 8;
    end;
    then
A98: Sum vdbr = rs by FINSEQ_1:18;
    dom dbl = dom db & dom dbr = dom db by A7,A9,FINSEQ_3:31;
    then consider P being Permutation of dom fdbl such that
A99: fdbr = fdbl*P by A8,A10,Th78;
    rng fdbl c= 3-tuples_on Bags n;
    then dom vfdbl = dom fdbl by A25,RELAT_1:46;
    then reconsider P as Permutation of dom (vfdbl);
    vfdbr = vfdbl*P by A99,RELAT_1:55;
    hence pqra.b = pqrb.b by A1,A4,A28,A61,A64,A98,RLVECT_2:9;
  end;
  hence thesis by FUNCT_2:113;
end;

definition
  let n be Ordinal,
  L be Abelian add-associative right_zeroed right_complementable
  commutative (non empty doubleLoopStr), p, q be Series of n, L;
  redefine func p*'q;
  commutativity
  proof
    let p, q be Series of n, L;
    reconsider pq = p*'q, qp = q*'p as Function of Bags n, the carrier of L;
    now
      let b be Element of Bags n;
      consider s being FinSequence of the carrier of L such that
A1:   pq.b = Sum s and
A2:   len s = len decomp b and
A3:   for k being Element of NAT st k in dom s
      ex b1, b2 being bag of n st (decomp b)/.k = <*b1, b2*> &
      s/.k = p.b1*q.b2 by Def26;
      consider t being FinSequence of the carrier of L such that
A4:   qp.b = Sum t and
A5:   len t = len decomp b and
A6:   for k being Element of NAT st k in dom t
      ex b1, b2 being bag of n st (decomp b)/.k = <*b1, b2*> &
      t/.k = q.b1*p.b2 by Def26;
A7:   dom s = dom decomp b & dom t = dom decomp b by A2,A5,FINSEQ_3:31;
      then reconsider ds = dom s as non empty set;
      defpred P[set, set] means ex b1, b2 being bag of n
      st (decomp b).$1 = <*b1, b2*> & (decomp b).$2 = <*b2, b1*>;
A8:   now
        let e be set;
        assume
A9:     e in ds;
        then consider b1, b2 being bag of n such that
A10:    (decomp b)/.e = <*b1, b2*> and
A11:    b = b1+b2 by A7,Th72;
        consider d being Element of NAT such that
A12:    d in dom decomp b and
A13:    (decomp b)/.d = <*b2,b1*> by A11,Th73;
        reconsider d as set;
        take d;
        thus d in ds by A2,A12,FINSEQ_3:31;
        thus P[e,d]
        proof
          take b1, b2;
          thus thesis
          by A7,A9,A10,A12,A13,PARTFUN1:def 8;
        end;
      end;
      consider f being Function of ds, ds such that
A14:  for e being set st e in ds holds P[e,f.e] from FUNCT_2:sch 1(A8);
A15:  dom f = ds & rng f c= ds by FUNCT_2:def 1;
A16:  f is one-to-one
      proof
        let x1, x2 be set such that
A17:    x1 in dom f and
A18:    x2 in dom f and
A19:    f.x1 = f.x2;
        consider b1, b2 being bag of n such that
A20:    (decomp b).x1 = <*b1, b2*> & (decomp b).(f.x1) = <*b2, b1*>
        by A14,A17;
        consider b3, b4 being bag of n such that
A21:    (decomp b).x2 = <*b3, b4*> & (decomp b).(f.x2) = <*b4, b3*> by A14,A18;
        b2 = b4 & b1 = b3 by A19,A20,A21,GROUP_7:2;
        hence thesis by A7,A17,A18,A20,A21,FUNCT_1:def 8;
      end;
      ds c= rng f
      proof
        let x be set;
        assume
A22:    x in ds;
        then
A23:    f.x in rng f by A15,FUNCT_1:def 5;
        then
A24:    f.(f.x) in rng f by A15,FUNCT_1:def 5;
        consider b1, b2 being bag of n such that
A25:    (decomp b).x = <*b1, b2*> & (decomp b).(f.x) = <*b2, b1*> by A14,A22;
        consider b3, b4 being bag of n such that
A26:    (decomp b).(f.x) = <*b3, b4*> & (decomp b).(f.(f.x)) = <*b4, b3*>
        by A14,A23;
        b3 = b2 & b4 = b1 by A25,A26,GROUP_7:2;
        hence thesis by A7,A22,A24,A25,A26,FUNCT_1:def 8;
      end;
      then rng f = ds by XBOOLE_0:def 10;
      then reconsider f as Permutation of dom s by A16,FUNCT_2:83;
      now
        let i be Element of NAT;
        assume
A27:    i in dom t;
        then
A28:    f.i in rng f by A7,A15,FUNCT_1:def 5;
        reconsider fi = f.i as Element of NAT;
        consider b1, b2 being bag of n such that
A29:    (decomp b)/.i = <*b1, b2*> & t/.i = q.b1*p.b2 by A6,A27;
        consider b3, b4 being bag of n such that
A30:    (decomp b)/.fi = <*b3, b4*> & s/.fi = p.b3*q.b4 by A3,A28;
        consider b5, b6 being bag of n such that
A31:    (decomp b).i = <*b5, b6*> & (decomp b).(f.i) = <*b6, b5*> by A7,A14,A27
;
A32:    dom s = dom t by A2,A5,FINSEQ_3:31;
A33:    t/.i = t.i & s/.fi = s.fi by A27,A28,PARTFUN1:def 8;
        dom s = dom decomp b by A2,FINSEQ_3:31;
        then (decomp b)/.i = (decomp b).i & (decomp b)/.fi = (decomp b).fi
        by A27,A28,A32,PARTFUN1:def 8;
        then b1 = b5 & b2 = b6 & b3 = b6 & b4 = b5 by A29,A30,A31,GROUP_7:2;
        hence t.i = s.(f.i) by A29,A30,A33;
      end;
      hence pq.b = qp.b by A1,A2,A4,A5,RLVECT_2:8;
    end;
    hence p*'q = q*'p by FUNCT_2:113;
  end;
end;

theorem
  for n being Ordinal,
  L being add-associative right_complementable right_zeroed
  right_unital distributive (non empty doubleLoopStr), p being Series of n, L
  holds p*'0_(n,L) = 0_(n,L)
proof
  let n be Ordinal, L be add-associative right_complementable
  right_zeroed right_unital distributive (non empty doubleLoopStr),
  p be Series of n, L;
  set Z = 0_(n,L);
  now
    let b be Element of Bags n;
    consider s being FinSequence of the carrier of L such that
A1: (p*'Z).b = Sum s and len s = len decomp b and
A2: for k being Element of NAT st k in dom s
    ex b1, b2 being bag of n st (decomp b)/.k = <*b1, b2*>
    & s/.k = p.b1*Z.b2 by Def26;
    now
      let k be Nat;
      assume k in dom s;
      then consider b1, b2 being bag of n such that
      (decomp b)/.k = <*b1, b2*> and
A3:   s/.k = p.b1*Z.b2 by A2;
      thus s/.k = p.b1*0.L by A3,Th81
        .= 0.L by VECTSP_1:36;
    end;
    then Sum s = 0.L by MATRLIN:15;
    hence (p*'Z).b = Z.b by A1,Th81;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th88:
  for n being Ordinal, L being add-associative right_complementable
  right_zeroed distributive right_unital
  non trivial (non empty doubleLoopStr), p being Series of n, L
  holds p*'1_(n,L) = p
proof
  let n be Ordinal, L be add-associative right_complementable
  right_zeroed distributive right_unital
  non trivial (non empty doubleLoopStr), p be Series of n, L;
  set O = 1_(n,L), cL = the carrier of L;
  now
    let b be Element of Bags n;
    consider s being FinSequence of cL such that
A1: (p*'O).b = Sum s and
A2: len s = len decomp b and
A3: for k being Element of NAT st k in dom s
    ex b1, b2 being bag of n st (decomp b)/.k = <*b1, b2*>
    & s/.k = p.b1*O.b2 by Def26;
A4: len s <> 0 by A2;
    then consider t being FinSequence of cL, s1 being Element of cL such that
A5: s = t^<*s1*> by FINSEQ_2:22;
A6: Sum s = (Sum t) + (Sum <*s1*>) by A5,RLVECT_1:58;
    s is non empty by A4;
    then
A7: len s in dom s by FINSEQ_5:6;
    then consider b1, b2 being bag of n such that
A8: (decomp b)/.len s = <*b1, b2*> and
A9: s/.len s = p.b1*O.b2 by A3;
    (decomp b)/.len s = <*b, EmptyBag n*> by A2,Th75;
    then
A10: b1 = b & b2 = EmptyBag n by A8,GROUP_7:2;
A11: s.len s = (t^<*s1*>).(len t +1) by A5,FINSEQ_2:19
      .= s1 by FINSEQ_1:59;
A12: s/.len s = s.len s by A7,PARTFUN1:def 8;
A13: Sum <*s1*> = s1 by RLVECT_1:61
      .= p.b*1.L by A9,A10,A11,A12,Th84
      .= p.b by VECTSP_1:def 13;
    now
      per cases;
      suppose t = <*>(cL);
        hence (Sum t) = 0.L by RLVECT_1:60;
      end;
      suppose
A14:    t <> <*>(cL);
        now
          let k be Nat;
          assume
A15:      k in dom t;
          then
A16:      t/.k = t.k by PARTFUN1:def 8
            .= s.k by A5,A15,FINSEQ_1:def 7;
A17:      1 <= k by A15,FINSEQ_3:27;
A18:      dom s = dom decomp b by A2,FINSEQ_3:31;
A19:      len s = len t + len <*s1*> by A5,FINSEQ_1:35
            .= len t +1 by FINSEQ_1:56;
          k <= len t by A15,FINSEQ_3:27;
          then
A20:      k < len s by A19,NAT_1:13;
          then
A21:      k in dom decomp b by A2,A17,FINSEQ_3:27;
          then
A22:      s/.k = s.k by A18,PARTFUN1:def 8;
          per cases by A17,XXREAL_0:1;
          suppose
A23:        1 < k;
            consider b1, b2 being bag of n such that
A24:        (decomp b)/.k = <*b1, b2*> and
A25:        s/.k = p.b1*O.b2 by A3,A18,A21;
            b2 <> EmptyBag n by A2,A20,A23,A24,Th76;
            hence t/.k = p.b1*0.L by A16,A22,A25,Th84
              .= 0.L by VECTSP_1:36;
          end;
          suppose
A26:        k = 1;
            consider b1, b2 being bag of n such that
A27:        (decomp b)/.k = <*b1, b2*> and
A28:        s/.k = p.b1*O.b2 by A3,A18,A21;
            (decomp b)/.1 = <*EmptyBag n, b*> by Th75;
            then
A29:        b1 = EmptyBag n & b2 = b by A26,A27,GROUP_7:2;
            now
              assume b = EmptyBag n;
              then decomp b = <* <*EmptyBag n, EmptyBag n*> *> by Th77;
              then len t +1 = 0 qua Nat+1 by A2,A19,FINSEQ_1:56;
              hence contradiction by A14;
            end;
            then s.k = (p.EmptyBag n)*0.L by A22,A28,A29,Th84
              .= 0.L by VECTSP_1:36;
            hence t/.k = 0.L by A16;
          end;
        end;
        hence (Sum t) = 0.L by MATRLIN:15;
      end;
    end;
    hence (p*'O).b = p.b by A1,A6,A13,RLVECT_1:10;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th89:
  for n being Ordinal, L being add-associative right_complementable
  right_zeroed distributive well-unital non trivial (non empty doubleLoopStr),
  p being Series of n, L holds 1_(n,L)*'p = p
proof
  let n be Ordinal, L be add-associative right_complementable
  right_zeroed distributive well-unital non trivial (non empty doubleLoopStr),
  p be Series of n, L;
  set O = 1_(n,L), cL = the carrier of L;
  now
    let b be Element of Bags n;
    consider s being FinSequence of cL such that
A1: (O*'p).b = Sum s and
A2: len s = len decomp b and
A3: for k being Element of NAT st k in dom s
    ex b1, b2 being bag of n st (decomp b)/.k = <*b1, b2*>
    & s/.k = O.b1*p.b2 by Def26;
A4: len s <> 0 by A2;
    then s is non empty;
    then consider s1 being Element of cL, t being FinSequence of cL such that
A5: s1 = s.1 and
A6: s = <*s1*>^t by FINSEQ_3:111;
A7: Sum s = (Sum <*s1*>) + (Sum t) by A6,RLVECT_1:58;
    s is non empty by A4;
    then
A8: 1 in dom s by FINSEQ_5:6;
    then consider b1, b2 being bag of n such that
A9: (decomp b)/.1 = <*b1, b2*> and
A10: s/.1 = O.b1*p.b2 by A3;
    (decomp b)/.1 = <*EmptyBag n, b*> by Th75;
    then
A11: b2 = b & b1 = EmptyBag n by A9,GROUP_7:2;
A12: s/.1 = s.1 by A8,PARTFUN1:def 8;
A13: Sum <*s1*> = s1 by RLVECT_1:61
      .= 1.L*p.b by A5,A10,A11,A12,Th84
      .= p.b by VECTSP_1:def 16;
    now
      per cases;
      suppose t = <*>(cL);
        hence (Sum t) = 0.L by RLVECT_1:60;
      end;
      suppose
A14:    t <> <*>(cL);
        now
          let k be Nat;
          assume
A15:      k in dom t;
          then
A16:      t/.k = t.k by PARTFUN1:def 8
            .= s.(k+1) by A6,A15,FINSEQ_3:112;
          1 <= k by A15,FINSEQ_3:27;
          then
A17:      1 < k+1 by NAT_1:13;
A18:      dom s = dom decomp b by A2,FINSEQ_3:31;
A19:      len s = len t + len <*s1*> by A6,FINSEQ_1:35
            .= len t +1 by FINSEQ_1:56;
          k <= len t by A15,FINSEQ_3:27;
          then
A20:      k+1 <= len s by A19,XREAL_1:8;
          then
A21:      k+1 in dom decomp b by A2,A17,FINSEQ_3:27;
          then
A22:      s/.(k+1) = s.(k+1) by A18,PARTFUN1:def 8;
          per cases by A20,XXREAL_0:1;
          suppose
A23:        k+1 < len s;
            consider b1, b2 being bag of n such that
A24:        (decomp b)/.(k+1) = <*b1, b2*> and
A25:        s/.(k+1) = O.b1*p.b2 by A3,A18,A21;
            b1 <> EmptyBag n by A2,A17,A23,A24,Th76;
            hence t/.k = 0.L*p.b2 by A16,A22,A25,Th84
              .= 0.L by VECTSP_1:39;
          end;
          suppose
A26:        k+1 = len s;
            consider b1, b2 being bag of n such that
A27:        (decomp b)/.(k+1) = <*b1, b2*> and
A28:        s/.(k+1) = O.b1*p.b2 by A3,A18,A21;
            (decomp b)/.len s = <*b,EmptyBag n*> by A2,Th75;
            then
A29:        b2 = EmptyBag n & b1 = b by A26,A27,GROUP_7:2;
            now
              assume b = EmptyBag n;
              then decomp b = <* <*EmptyBag n, EmptyBag n*> *> by Th77;
              then len t +1 = 0 qua Nat+1 by A2,A19,FINSEQ_1:56;
              hence contradiction by A14;
            end;
            then s.(k+1) = 0.L*(p.EmptyBag n) by A22,A28,A29,Th84
              .= 0.L by VECTSP_1:39;
            hence t/.k = 0.L by A16;
          end;
        end;
        hence Sum t = 0.L by MATRLIN:15;
      end;
    end;
    hence (O*'p).b = p.b by A1,A7,A13,RLVECT_1:10;
  end;
  hence thesis by FUNCT_2:113;
end;

begin :: Polynomials ----------------------------------------------------------

registration
  let n be set, S be non empty ZeroStr;
  cluster finite-Support Series of n, S;
  existence
  proof
    reconsider P = Bags n --> 0.S
    as Function of Bags n, the carrier of S;
    reconsider P as Function of Bags n, S;
    reconsider P as Series of n, S;
    take P;
    for x being Element of Bags n holds x in {} iff P.x <> 0.S by FUNCOP_1:13;
    then Support P = {}Bags n by Def9;
    hence Support P is finite;
  end;
end;

definition
  let n be Ordinal, S be non empty ZeroStr;
  mode Polynomial of n, S is finite-Support Series of n, S;
end;

registration
  let n be Ordinal, L be right_zeroed (non empty addLoopStr),
  p, q be Polynomial of n, L;
  cluster p+q -> finite-Support;
  coherence
  proof
A1: Support p is finite by Def10;
A2: Support q is finite by Def10;
    set Sp = Support p, Sq = Support q;
    Sp \/ Sq is finite by A1,A2;
    then Support (p+q) is finite by Th79,FINSET_1:13;
    hence thesis by Def10;
  end;
end;

registration
  let n be Ordinal, L be add-associative right_zeroed right_complementable
  (non empty addLoopStr), p be Polynomial of n, L;
  cluster -p -> finite-Support;
  coherence
  proof
    set f = -p;
A1: Support p is finite by Def10;
    Support f c= Support p
    proof
      let x be set;
      assume
A2:   x in Support f;
      then reconsider x' = x as Element of Bags n;
      f.x' <> 0.L by A2,Def9;
      then -(p.x') <> 0.L by Def22;
      then p.x' <> 0.L by RLVECT_1:25;
      hence thesis by Def9;
    end;
    then Support f is finite by A1;
    hence thesis by Def10;
  end;
end;

registration
  let n be Element of NAT,
  L be add-associative right_zeroed right_complementable
  (non empty addLoopStr), p, q be Polynomial of n, L;
  cluster p-q -> finite-Support;
  coherence;
end;

registration
  let n be Ordinal, S be non empty ZeroStr;
  cluster 0_(n, S) -> finite-Support;
  coherence
  proof
    set Z = 0_(n, S);
    now
      given x being set such that
A1:   x in Support Z;
      reconsider x as Element of Bags n by A1;
      Z.x = 0.S by FUNCOP_1:13;
      hence contradiction by A1,Def9;
    end;
    then Support Z = {} by XBOOLE_0:def 1;
    hence thesis by Def10;
  end;
end;

registration
  let n be Ordinal, L be add-associative right_zeroed right_complementable
  right_unital right-distributive non trivial (non empty doubleLoopStr);
  cluster 1_(n,L) -> finite-Support;
  coherence
  proof
    reconsider O = 0_(n,L)+*(EmptyBag n,1.L)
    as Function of Bags n, the carrier of L;
    reconsider O' = O as Function of Bags n, L;
    reconsider O' as Series of n, L;
    now
      let x be set;
      hereby
        assume
A1:     x in Support O';
        then reconsider x' = x as Element of Bags n;
        assume x <> EmptyBag n;
        then O'.x = 0_(n,L).x' by FUNCT_7:34
          .= 0.L by FUNCOP_1:13;
        hence contradiction by A1,Def9;
      end;
      assume
A2:   x = EmptyBag n;
      dom 0_(n,L) = Bags n by FUNCOP_1:19;
      then O'.x <> 0.L by A2,Th27,FUNCT_7:33;
      hence x in Support O' by A2,Def9;
    end;
    then Support O' = {EmptyBag n} by TARSKI:def 1;
    hence thesis by Def10;
  end;
end;

registration
  let n be Ordinal, L be add-associative right_complementable right_zeroed
  right_unital distributive (non empty doubleLoopStr),
  p, q be Polynomial of n, L;
  cluster p*'q -> finite-Support;
  coherence
  proof
    deffunc F(Element of Bags n,Element of Bags n) = $1+$2;
    set D = { F(b1,b2) where b1, b2 is Element of Bags n :
    b1 in Support p & b2 in Support q };
A1: Support p is finite by Def10;
A2: Support q is finite by Def10;
A3: D is finite from FRAENKEL:sch 22(A1, A2);
    Support (p*'q) c= D
    proof
      let x' be set;
      assume
A4:   x' in Support (p*'q);
      then reconsider b = x' as Element of Bags n;
A5:   (p*'q).b <> 0.L by A4,Def9;
      consider s being FinSequence of the carrier of L such that
A6:   (p*'q).b = Sum s and
A7:   len s = len decomp b and
A8:   for k being Element of NAT st k in dom s
      ex b1, b2 being bag of n st (decomp b)/.k = <*b1, b2*> &
      s/.k = p.b1*q.b2 by Def26;
      consider k being Nat such that
A9:   k in dom s and
A10:  s/.k <> 0.L by A5,A6,MATRLIN:15;
      consider b1, b2 being bag of n such that
A11:  (decomp b)/.k = <*b1, b2*> and
A12:  s/.k = p.b1*q.b2 by A8,A9;
A13:  b1 in Bags n & b2 in Bags n by Def14;
      p.b1 <> 0.L & q.b2 <> 0.L by A10,A12,VECTSP_1:36,39;
      then
A14:  b1 in Support p & b2 in Support q by A13,Def9;
      k in dom decomp b by A7,A9,FINSEQ_3:31;
      then consider b1', b2' being bag of n such that
A15:  (decomp b)/.k = <*b1', b2'*> and
A16:  b = b1'+b2' by Th72;
      b1' = b1 & b2' = b2 by A11,A15,GROUP_7:2;
      hence thesis by A14,A16;
    end;
    then Support (p*'q) is finite by A3;
    hence thesis by Def10;
  end;
end;

begin :: The ring of polynomials ---------------------------------------------

definition
  let n be Ordinal, L be right_zeroed add-associative right_complementable
  right_unital distributive non trivial (non empty doubleLoopStr);
  func Polynom-Ring (n, L) -> strict non empty doubleLoopStr means
  :Def27:
  (for x being set holds x in the carrier of it iff x is Polynomial of n, L) &
  (for x, y being Element of it, p, q being Polynomial of n, L
  st x = p & y = q holds x+y = p+q) &
  (for x, y being Element of it, p, q being Polynomial of n, L
  st x = p & y = q holds x*y = p*'q) & 0.it = 0_(n,L) & 1.it = 1_(n,L);
  existence
  proof
    defpred Q[set] means
    ex x' being Series of n, L st x' = $1 & x' is finite-Support;
    consider P being Subset of Funcs(Bags n, the carrier of L) such that
A1: for x being Element of Funcs(Bags n, the carrier of L)holds x in P iff
    Q[x] from SUBSET_1:sch 3;
    consider x' being finite-Support Series of n, L;
    x' in Funcs(Bags n, the carrier of L) by FUNCT_2:11;
    then reconsider P as non empty Subset of Funcs(Bags n, the carrier of L)
by A1;
    defpred A[set, set, set] means
    ex p, q, r being Polynomial of n, L st p = $1 & q = $2 & r = $3 & p+q=r;
A2: now
      let x be Element of P, y be Element of P;
      reconsider p = x, q = y as Element of Funcs(Bags n, the carrier of L);
      consider p' being Series of n, L such that
A3:   p' = p & p' is finite-Support by A1;
      consider q' being Series of n, L such that
A4:   q' = q & q' is finite-Support by A1;
      reconsider p', q' as Polynomial of n, L by A3,A4;
      set r = p'+q';
      r in Funcs(Bags n, the carrier of L) by FUNCT_2:11;
      then reconsider u = r as Element of P by A1;
      take u;
      thus A[x,y,u] by A3,A4;
    end;
    consider fadd being Function of [:P,P:],P such that
A5: for x being Element of P, y being Element of P holds A[x,y,fadd.(x,y)]
    from BINOP_1:sch 3(A2);
    defpred M[set, set, set] means
    ex p, q, r being Polynomial of n, L st p = $1 & q = $2 & r = $3 & p*'q=r;
A6: now
      let x be Element of P, y be Element of P;
      reconsider p = x, q = y as Element of Funcs(Bags n, the carrier of L);
      consider p' being Series of n, L such that
A7:   p' = p & p' is finite-Support by A1;
      consider q' being Series of n, L such that
A8:   q' = q & q' is finite-Support by A1;
      reconsider p', q' as Polynomial of n, L by A7,A8;
      set r = p'*'q';
      r in Funcs(Bags n, the carrier of L) by FUNCT_2:11;
      then reconsider u = r as Element of P by A1;
      take u;
      thus M[x,y,u] by A7,A8;
    end;
    consider fmult being Function of [:P,P:],P such that
A9: for x being Element of P, y being Element of P holds M[x,y,fmult.(x,y)]
    from BINOP_1:sch 3(A6);
    reconsider Z = (Bags n) --> 0.L
    as Function of Bags n, the carrier of L;
    reconsider Z' = Z as Function of Bags n, L;
    reconsider Z' as Series of n, L;
    reconsider ZZ = Z as Element of Funcs(Bags n, the carrier of L)
    by FUNCT_2:11;
    now
      given x being set such that
A10:  x in Support Z';
      reconsider x as Element of Bags n by A10;
      Z'.x = 0.L by FUNCOP_1:13;
      hence contradiction by A10,Def9;
    end;
    then Support Z' = {} by XBOOLE_0:def 1;
    then Z' is finite-Support by Def10;
    then ZZ in P by A1;
    then reconsider Ze = Z as Element of P;
    reconsider O = Z+*(EmptyBag n,1.L)
    as Function of Bags n, the carrier of L;
    reconsider O' = O as Function of Bags n, L;
    reconsider O' as Series of n, L;
    reconsider O as Element of Funcs(Bags n, the carrier of L) by FUNCT_2:11;
    now
      let x be set;
      hereby
        assume
A11:    x in Support O';
        then reconsider x' = x as Element of Bags n;
        assume x <> EmptyBag n;
        then O'.x = Z.x' by FUNCT_7:34
          .= 0.L by FUNCOP_1:13;
        hence contradiction by A11,Def9;
      end;
      assume
A12:  x = EmptyBag n;
      dom Z = Bags n by FUNCOP_1:19;
      then O'.x <> 0.L by A12,Th27,FUNCT_7:33;
      hence x in Support O' by A12,Def9;
    end;
    then Support O' = {EmptyBag n} by TARSKI:def 1;
    then O' is finite-Support by Def10;
    then reconsider O as Element of P by A1;
    reconsider R = doubleLoopStr(# P, fadd, fmult, O, Ze #)
    as strict non empty doubleLoopStr;
    take R;
    thus for x being set holds x in the carrier of R
    iff x is Polynomial of n, L
    proof
      let x be set;
      hereby
        assume
A13:    x in the carrier of R;
        then reconsider xx = x as Element of Funcs(Bags n, the carrier of L);
        consider x' being Series of n, L such that
A14:    x' = xx & x' is finite-Support by A1,A13;
        thus x is Polynomial of n, L by A14;
      end;
      assume
A15:  x is Polynomial of n, L;
      then x is Element of Funcs(Bags n, the carrier of L) by FUNCT_2:11;
      hence thesis by A1,A15;
    end;
    hereby
      let x, y be Element of R, p, q be Polynomial of n, L such that
A16:  x = p & y = q;
      consider p', q', r' being Polynomial of n, L such that
A17:  p' = x & q' = y & r' = fadd.(x,y) and
A18:  p'+q'= r' by A5;
      thus x+y = p+q by A16,A17,A18;
    end;
    hereby
      let x, y be Element of R, p, q be Polynomial of n, L such that
A19:  x = p & y = q;
      consider p', q', r' being Polynomial of n, L such that
A20:  p' = x & q' = y & r' = fmult.(x,y) and
A21:  p'*'q'= r' by A9;
      thus x*y = p*'q by A19,A20,A21;
    end;
    thus 0.R = 0_(n,L);
    thus thesis;
  end;
  uniqueness
  proof
    let it1, it2 be strict non empty doubleLoopStr such that
A22: (for x being set holds x in the carrier of it1
    iff x is Polynomial of n, L) and
A23: (for x, y being Element of it1, p, q being Polynomial of n, L
    st x = p & y = q holds x+y = p+q) and
A24: (for x, y being Element of it1, p, q being Polynomial of n, L
    st x = p & y = q holds x*y = p*'q) and
A25: 0.it1 = 0_(n,L) and
A26: 1.it1 = 1_(n,L) and
A27: (for x being set holds x in the carrier of it2
    iff x is Polynomial of n, L) and
A28: (for x, y being Element of it2, p, q being Polynomial of n, L
    st x = p & y = q holds x+y = p+q) and
A29: (for x, y being Element of it2, p, q being Polynomial of n, L
    st x = p & y = q holds x*y = p*'q) and
A30: 0.it2 = 0_(n,L) and
A31: 1.it2 = 1_(n,L);
A32: now
      let x be set;
      hereby
        assume x in the carrier of it1;
        then x is Polynomial of n, L by A22;
        hence x in the carrier of it2 by A27;
      end;
      assume x in the carrier of it2;
      then x is Polynomial of n, L by A27;
      hence x in the carrier of it1 by A22;
    end;
    then
A33: the carrier of it1 = the carrier of it2 by TARSKI:2;
    now
      let a, b be Element of it1;
      reconsider a1 = a, b1 = b as Element of it1;
      reconsider p = a, q = b as Polynomial of n, L by A22;
      reconsider a' = a, b' = b as Element of it2 by A32;
      reconsider a1' = a', b1' = b' as Element of it2;
      thus (the addF of it1).(a, b) = a1+b1
        .= p+q by A23
        .= a1'+b1' by A28
        .= (the addF of it2).(a, b);
    end;
    then
A34: the addF of it1 = the addF of it2 by A33,BINOP_1:2;
    now
      let a, b be Element of it1;
      reconsider a1 = a, b1 = b as Element of it1;
      reconsider p = a, q = b as Polynomial of n, L by A22;
      reconsider a' = a, b' = b as Element of it2 by A32;
      reconsider a1' = a', b1' = b' as Element of it2;
      thus (the multF of it1).(a, b) = a1*b1
        .= p*'q by A24
        .= a1'*b1' by A29
        .= (the multF of it2).(a, b);
    end;
    hence thesis by A25,A26,A30,A31,A33,A34,BINOP_1:2;
  end;
end;

registration
  let n be Ordinal,
  L be Abelian right_zeroed add-associative right_complementable
  right_unital distributive non trivial (non empty doubleLoopStr);
  cluster Polynom-Ring (n, L) -> Abelian;
  coherence
  proof
    set Pm = Polynom-Ring (n, L);
    let v, w be Element of Pm;
    reconsider p = v, q = w as Polynomial of n, L by Def27;
    thus v + w = q+p by Def27
      .= w + v by Def27;
  end;
end;

registration
  let n be Ordinal, L be add-associative right_zeroed right_complementable
  right_unital distributive non trivial (non empty doubleLoopStr);
  cluster Polynom-Ring (n, L) -> add-associative;
  coherence
  proof
    set Pm = Polynom-Ring (n, L);
    let u, v, w be Element of Pm;
    reconsider o = u, p = v, q = w as Polynomial of n, L by Def27;
A1: v+w = p+q by Def27;
    u+v = o+p by Def27;
    hence (u+v)+w = (o+p)+q by Def27
      .= o+(p+q) by Th80
      .= u+(v+w) by A1,Def27;
  end;
end;

registration
  let n be Ordinal, L be right_zeroed add-associative right_complementable
  right_unital distributive non trivial (non empty doubleLoopStr);
  cluster Polynom-Ring (n, L) -> right_zeroed;
  coherence
  proof
    let v be Element of Polynom-Ring (n, L);
    reconsider p = v as Polynomial of n, L by Def27;
    0.Polynom-Ring (n, L) = 0_(n,L) by Def27;
    hence v + 0.Polynom-Ring (n, L) = p+0_(n,L) by Def27
      .= v by Th82;
  end;
end;

registration
  let n be Ordinal, L be right_complementable right_zeroed add-associative
  right_unital distributive non trivial (non empty doubleLoopStr);
  cluster Polynom-Ring (n, L) -> right_complementable;
  coherence
  proof
    let v be Element of Polynom-Ring (n,L);
    reconsider p = v as Polynomial of n, L by Def27;
    reconsider w = -p as Element of Polynom-Ring(n,L) by Def27;
    take w;
    thus v + w = p-p by Def27
      .= 0_(n,L) by Th83
      .= 0.Polynom-Ring(n,L) by Def27;
  end;
end;

registration
  let n be Ordinal,
  L be Abelian add-associative right_zeroed right_complementable
  commutative right_unital distributive non trivial (non empty doubleLoopStr);
  cluster Polynom-Ring (n, L) -> commutative;
  coherence
  proof
    set Pm = Polynom-Ring (n, L);
    let v, w be Element of Pm;
    reconsider p = v, q = w as Polynomial of n, L by Def27;
    thus v*w = q*'p by Def27
      .= w*v by Def27;
  end;
end;

registration
  let n be Ordinal,
  L be Abelian add-associative right_zeroed right_complementable
  right_unital distributive associative non trivial (non empty doubleLoopStr);
  cluster Polynom-Ring (n, L) -> associative;
  coherence
  proof
    set Pm = Polynom-Ring (n, L);
    let x,y,z be Element of Pm;
    reconsider p = x, q = y, r = z as Polynomial of n, L by Def27;
A1: y*z = q*'r by Def27;
    x*y = p*'q by Def27;
    hence (x*y)*z = (p*'q)*'r by Def27
      .= p*'(q*'r) by Th86
      .= x*(y*z) by A1,Def27;
  end;
end;

Lm5: now
  let n be Ordinal,
  L be right_zeroed Abelian add-associative right_complementable
  well-unital distributive associative non trivial (non empty doubleLoopStr);
  set Pm = Polynom-Ring (n, L);
  let x, e be Element of Pm;
  assume
A1: e = 1.Pm;
  reconsider p = x as Polynomial of n, L by Def27;
A2: 1.Pm = 1_(n,L) by Def27;
  hence x*e = p*'1_(n,L) by A1,Def27
    .= x by Th88;
  thus e*x = 1_(n,L)*'p by A1,A2,Def27
    .= x by Th89;
end;

registration
  let n be Ordinal,
  L be right_zeroed Abelian add-associative right_complementable
  well-unital distributive associative non trivial (non empty doubleLoopStr);
  cluster Polynom-Ring (n, L) -> well-unital right-distributive;
  coherence
  proof
    set Pm = Polynom-Ring (n, L);
    thus Pm is well-unital
    proof
      let x be Element of Pm;
      thus thesis by Lm5;
    end;
    let x, y, z be Element of Pm;
    reconsider p = x, q = y, r = z as Polynomial of n, L by Def27;
A1: x*y = p*'q by Def27;
A2: x*z = p*'r by Def27;
    y+z = q+r by Def27;
    hence x*(y+z) = p*'(q+r) by Def27
      .= p*'q+p*'r by Th85
      .= x*y + x*z by A1,A2,Def27;
  end;
end;

theorem
  for n being Ordinal,
  L being right_zeroed Abelian add-associative right_complementable
  right_unital distributive associative
  non trivial (non empty doubleLoopStr) holds
  1.Polynom-Ring(n, L) = 1_(n,L) by Def27;

theorem
  for X being set, b1, b2 being real-valued ManySortedSet of X
  holds support (b1+b2) c= support b1 \/ support b2
proof
  let X be set, b1, b2 be real-valued ManySortedSet of X;
  let x be set;
  assume x in support (b1+b2);
  then
A1: (b1+b2).x <> 0 by Def7;
  assume not x in support b1 \/ support b2;
  then not x in support b1 & not x in support b2 by XBOOLE_0:def 3;
  then b1.x = 0 & b2.x = 0 by Def7;
  then b1.x+b2.x = 0;
  hence contradiction by A1,Def5;
end;

