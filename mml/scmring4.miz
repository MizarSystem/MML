:: Relocability for { \bf SCM } over Ring
::  by Artur Korni{\l}owicz and Yasunari Shidama
::
:: Received February 6, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabularies AMI_3, SCMFSA7B, FUNCSDOM, AMI_1, FINSET_1, ORDINAL2, CARD_5,
      AMI_2, GR_CY_1, BOOLE, FUNCT_1, FUNCOP_1, CAT_1, ARYTM, GOBOARD5,
      RELAT_1, AMI_5, MCART_1, FUNCT_4, SGRAPH1, TARSKI, FUNCT_7, AMISTD_2,
      REALSET1, RLVECT_1, ARYTM_1, AMISTD_1, CARD_3, RELOC, PARTFUN1;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, DOMAIN_1, ORDINAL1, ORDINAL2,
      FINSET_1, RELAT_1, NUMBERS, FUNCT_1, PARTFUN1, FUNCT_2, STRUCT_0,
      FUNCSDOM, REALSET2, FUNCOP_1, XCMPLX_0, XREAL_0, NAT_1, RLVECT_1,
      CQC_LANG, FUNCT_4, GR_CY_1, CARD_3, FUNCT_7, GROUP_1, BINARITH, AMI_1,
      AMI_2, AMI_3, AMI_5, SCMRING1, SCMRING2, AMISTD_1, AMISTD_2, SCMRING3;
 constructors AMI_5, AMISTD_2, DOMAIN_1, FUNCT_7, PRALG_2, BINARITH, SCMRING3,
      WELLORD2, MEMBERED, ARYTM_0, SCMPDS_9, NAT_1;
 registrations AMI_1, RELSET_1, SCMRING1, STRUCT_0, AMISTD_2, FUNCT_1,
      FINSEQ_1, WAYBEL12, XBOOLE_0, AMI_3, NAT_1, FRAENKEL, XREAL_0, SCMRING3,
      AMI_5, FUNCOP_1, SCMFSA_4, AMISTD_1, SETFAM_1, FINSET_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, WELLORD2, FUNCT_7, AMI_1, XBOOLE_0;
 theorems TARSKI, NAT_1, AMI_1, SCMRING2, AMI_3, FUNCT_4, AMI_5, FUNCT_1,
      FUNCT_2, RELSET_1, ZFMISC_1, CQC_LANG, SCMRING1, AMI_2, MCART_1,
      FINSET_1, ANPROJ_1, CQC_THE1, GR_CY_1, CARD_3, XBOOLE_0, XBOOLE_1,
      XCMPLX_1, BINARITH, RELAT_1, GRFUNC_1, PARTFUN1, SCMRING3, JORDAN3,
      AMISTD_1, ORDINAL2, CARD_1, AMISTD_2, FUNCT_7, SCMFSA_3;
 schemes NAT_1;

begin :: On the standard computers

reserve
  i, j, k for natural number,
  n for Nat,
  N for with_non-empty_elements set,
  S for standard (IC-Ins-separated definite
        (non empty non void AMI-Struct over N)),
  l for Instruction-Location of S,
  f for FinPartState of S;

Lm1:
  for a,A being set st A /\ {a} <> {} holds a in A
  proof
    let a,A be set;
    assume A /\ {a} <> {};
    then A meets {a} by XBOOLE_0:def 7;
    hence thesis by ZFMISC_1:56;
  end;

Lm2:
  for a,b,c being set holds not c in a \ ({c} \/ b)
  proof
    let a,b,c be set;
    assume c in a \ ({c} \/ b);
    then not c in {c} \/ b by XBOOLE_0:def 4;
    then not c in {c} by XBOOLE_0:def 2;
    hence thesis by TARSKI:def 1;
  end;

theorem Th1:
  NAT,the Instruction-Locations of S are_equipotent
  proof
    consider f being Function of NAT, the Instruction-Locations of S such that
A1:   f is bijective and for m, n being Nat holds m <= n iff f.m <= f.n
      by AMISTD_1:def 10;
    take f;
     f is onto by A1,FUNCT_2:def 4;
    hence thesis by A1,FUNCT_2:def 1,def 3,def 4;
  end;

registration
   let N,S;
 cluster the Instruction-Locations of S -> infinite;
coherence
  proof
     NAT,the Instruction-Locations of S are_equipotent by Th1;
    hence thesis by CARD_1:68;
  end;
end;

theorem Th2:
  il.(S,i) + j = il.(S,i+j)
  proof
    thus il.(S,i)+j = il.(S,locnum (il.(S,i)) + j) by AMISTD_1:def 14
      .= il.(S,i+j) by AMISTD_1:def 13;
  end;

definition
  let N be with_non-empty_elements set,
      S be standard (IC-Ins-separated definite
           (non empty non void AMI-Struct over N)),
      loc be Instruction-Location of S,
      k be natural number;
 func loc -' k -> Instruction-Location of S equals :Def1:
  il.(S, (locnum loc) -' k);
coherence;
end;

theorem
   l -' 0 = l
  proof
    thus l -' 0 = il.(S,locnum l -' 0) by Def1
      .= il.(S,locnum l) by JORDAN3:2
      .= l by AMISTD_1:def 13;
  end;

theorem
   (locnum l) -' k = locnum (l -' k)
  proof
    thus locnum l -' k = locnum il.(S,locnum l-'k) by AMISTD_1:def 13
      .= locnum (l -' k) by Def1;
  end;

theorem Th5:
  l + k -' k = l
  proof
    thus l + k -' k = il.(S,locnum (l + k) -' k) by Def1
      .= il.(S,locnum l + k -' k) by AMISTD_1:33
      .= il.(S,locnum l) by BINARITH:39
      .= l by AMISTD_1:def 13;
  end;

theorem
   il.(S,i) -' j = il.(S,i-'j)
  proof
    thus il.(S,i)-'j = il.(S,locnum (il.(S,i)) -' j) by Def1
      .= il.(S,i-'j) by AMISTD_1:def 13;
  end;

theorem Th7:
  for S being IC-Ins-separated definite (non empty non void AMI-Struct over N),
      p being FinPartState of S holds
  dom DataPart p c=
    (the carrier of S) \ ({IC S} \/ the Instruction-Locations of S)
  proof
    let S be IC-Ins-separated definite (non empty non void AMI-Struct over N),
        p be FinPartState of S;
    set I = the Instruction-Locations of S;
     DataPart p = p | ((the carrier of S) \ ({IC S} \/ I)) by AMI_5:def 7;
    hence dom DataPart p c= ((the carrier of S) \ ({IC S} \/ I))
      by RELAT_1:87;
  end;

Lm3:
  now
    let N;
    let S be non empty AMI-Struct over N;
    set C = the carrier of S;
    set I = the Instruction-Locations of S;
    set B = C \ ({IC S} \/ I);
    thus I misses B
    proof
      assume I meets B;
      then consider o being set such that
A1:     o in I and
A2:     o in B by XBOOLE_0:3;
       not o in {IC S} \/ I by A2,XBOOLE_0:def 4;
      hence thesis by A1,XBOOLE_0:def 2;
    end;
  end;

Lm4:
  for a,b,c being set st a c= c & b c= c \ a holds c = a \/ (c \ (a\/b)) \/ b
  proof
    let a,b,c be set such that
A1:   a c= c and
A2:   b c= c \ a;
    thus a \/ (c \ (a\/b)) \/ b = a \/ (c \ a \ b) \/ b by XBOOLE_1:41
     .= a \/ ((c \ a \ b) \/ b) by XBOOLE_1:4
     .= a \/ ((c \ a) \/ b) by XBOOLE_1:39
     .= a \/ (c \ a) by A2,XBOOLE_1:12
     .= a \/ c by XBOOLE_1:39
     .= c by A1,XBOOLE_1:12;
  end;

Lm5:
  for S being IC-Ins-separated definite realistic
              (non empty non void AMI-Struct over N) holds
    the Instruction-Locations of S c= (the carrier of S) \ {IC S}
  proof
    let S be IC-Ins-separated definite realistic
             (non empty non void AMI-Struct over N);
    let i be set;
    assume
A1:   i in the Instruction-Locations of S;
    then i <> IC S by AMI_1:48;
    then not i in {IC S} by TARSKI:def 1;
    hence thesis by A1,XBOOLE_0:def 4;
  end;

theorem Th8:
  for S being IC-Ins-separated definite realistic
              (non empty non void AMI-Struct over N),
      p being FinPartState of S holds
  p is data-only iff
   dom p c= (the carrier of S) \ ({IC S} \/ the Instruction-Locations of S)
  proof
    let S be IC-Ins-separated definite realistic
             (non empty non void AMI-Struct over N),
        p be FinPartState of S;
    set C = the carrier of S;
    set I = the Instruction-Locations of S;
    set B = C \ ({IC S} \/ I);
A1: B misses I by Lm3;
     I c= C \ {IC S}
    proof
      let i be set;
      assume
A2:     i in I;
      then i <> IC S by AMI_1:48;
      then not i in {IC S} by TARSKI:def 1;
      hence thesis by A2,XBOOLE_0:def 4;
    end;
    then A3: C = {IC S} \/ B \/ I by Lm4;
     dom p c= C by AMI_3:37;
    then A4: dom p c= {IC S} \/ I \/ B by A3,XBOOLE_1:4;
     not IC S in B by Lm2;
    then B misses {IC S} by ZFMISC_1:56;
    then B misses {IC S} \/ I by A1,XBOOLE_1:70;
    then dom p misses {IC S} \/ I iff dom p c= B by A4,XBOOLE_1:63,73;
    hence thesis by AMI_5:def 8;
  end;

theorem Th9:
  for l1, l2 being Instruction-Location of S holds
   Start-At(l1+k) = Start-At(l2+k) iff Start-At l1 = Start-At l2
  proof
    let l1,l2 be Instruction-Location of S;
    hereby
      assume
A1:   Start-At(l1 + k) = Start-At(l2 + k);
A2:   Start-At(l1 + k) = IC S .--> (l1 + k) &
      Start-At(l2 + k) = IC S .--> (l2 + k) by AMI_3:def 12;
      then {[IC S, l1 + k]} = IC S .--> (l2 + k) by A1,AMI_5:35;
      then {[IC S, l1 + k]} = {[IC S, l2 + k]} by A2,AMI_5:35;
      then [IC S, l1 + k] = [IC S, l2 + k] by ZFMISC_1:6;
      then l1 + k = l2 + k by ZFMISC_1:33;
      then l1 = l2 + k -' k by Th5;
      hence Start-At l1 = Start-At l2 by Th5;
    end;
    assume Start-At l1 = Start-At l2;
    then {[IC S, l1]} = Start-At l2 by AMI_5:35;
    then {[IC S, l1]} = {[IC S, l2]} by AMI_5:35;
    then [IC S, l1] = [IC S, l2] by ZFMISC_1:6;
    hence Start-At(l1 + k) = Start-At(l2 + k) by ZFMISC_1:33;
  end;

theorem Th10:
  for l1, l2 being Instruction-Location of S
    st Start-At l1 = Start-At l2 holds
  Start-At(l1 -' k) = Start-At(l2 -' k)
  proof
    let l1, l2 be Instruction-Location of S;
    assume Start-At l1 = Start-At l2;
    then {[IC S, l1]} = Start-At l2 by AMI_5:35
       .= {[IC S, l2]} by AMI_5:35;
    then [IC S, l1] = [IC S, l2] by ZFMISC_1:6;
    hence Start-At(l1 -' k) = Start-At(l2 -' k) by ZFMISC_1:33;
  end;

theorem Th11:
  l in dom f implies Shift(f,k).(l + k) = f.l
  proof
    assume
A1:   l in dom f;
    consider m being natural number such that
A2:   l = il.(S,m) by AMISTD_1:26;
A3: m is Nat by ORDINAL2:def 21;
    thus Shift(f,k).(l + k) = Shift(f,k).(il.(S,locnum l+k)) by AMISTD_1:def 14
               .= Shift(f,k).(il.(S,m+k)) by A2,AMISTD_1:def 13
               .= f.l by A1,A2,A3,AMISTD_2:def 16;
  end;

theorem
   dom Shift(f,k) =
    { il+k where il is Instruction-Location of S: il in dom f}
  proof
A1: dom Shift(f,k) = { il.(S,m+k) where m is Nat: il.(S,m) in dom f }
     by AMISTD_2:def 16;
    hereby
      let e be set;
      assume e in dom Shift(f,k);
      then consider m being Nat such that
A2:     e = il.(S,m+k) and
A3:     il.(S,m) in dom f by A1;
        (il.(S,m))+k = il.(S,locnum (il.(S,m)) + k) by AMISTD_1:def 14
         .= il.(S,m+k) by AMISTD_1:def 13;
      hence e in { il+k where il is Instruction-Location of S:
       il in dom f } by A2,A3;
    end;
    let e be set;
    assume e in { il+k where il is Instruction-Location of S: il in dom f };
    then consider il being Instruction-Location of S such that
A4:   e = il+k and
A5:   il in dom f;
      il = il.(S,locnum il) & il+k = il.(S,locnum il+k)
       by AMISTD_1:def 13,def 14;
    hence thesis by A1,A4,A5;
  end;

theorem Th13:
  for S being Exec-preserving IC-Ins-separated definite realistic
              steady-programmed (non empty non void AMI-Struct over N),
      s being State of S,
      i being Instruction of S,
      p being programmed FinPartState of S
   holds Exec (i, s +* p) = Exec (i,s) +* p
  proof
    let S be Exec-preserving IC-Ins-separated definite realistic
             steady-programmed (non empty non void AMI-Struct over N),
        s be State of S,
        i be Instruction of S,
        p be programmed FinPartState of S;
    set C = the carrier of S;
    set I = the Instruction-Locations of S;
    set D = C \ ({IC S} \/ I);
A1: dom p c= I by AMI_3:def 13;
A2: dom s = C by AMI_3:36;
A3: dom (s+*p) = C by AMI_3:36;
A4: dom Exec(i,s) = C by AMI_3:36;
A5: dom Exec(i,s+*p) = C by AMI_3:36;
     D = C \ I \ {IC S} by XBOOLE_1:41;
    then A6: D \/ {IC S} = (C \ I) \/ {IC S} by XBOOLE_1:39;
     {IC S} c= C \ I
    proof
      let x be set;
      assume
A7:     x in {IC S};
      then x = IC S by TARSKI:def 1;
      then not x in I by AMI_1:48;
      hence thesis by A7,XBOOLE_0:def 4;
    end;
    then A8: C \ I = D \/ {IC S} by A6,XBOOLE_1:12;
     {IC S} c= C & I c= C \ {IC S} by Lm5;
    then A9: C = {IC S} \/ D \/ I by Lm4;
     D \/ {IC S} misses I
    proof
      assume not thesis;
      then consider o being set such that
A10:     o in D \/ {IC S} and
A11:     o in I by XBOOLE_0:3;
A12:   o in D or o in {IC S} by A10,XBOOLE_0:def 2;
      per cases by A12,TARSKI:def 1;
      suppose o in D;
      then not o in {IC S} \/ I by XBOOLE_0:def 4;
      hence contradiction by A11,XBOOLE_0:def 2;
      end;
      suppose o = IC S;
      hence contradiction by A11,AMI_1:48;
      end;
    end;
    then A13: D \/ {IC S} misses dom p by A1,XBOOLE_1:63;
     s, s+*p equal_outside I
    proof
      thus s|(dom s \ I) = (s+*p)|(dom(s+*p) \ I) by A2,A3,A8,A13,FUNCT_4:76;
    end;
    then A14: Exec(i,s), Exec(i,s+*p) equal_outside I by AMISTD_2:def 19;
A15: (Exec(i,s) +* p) | (D \/ {IC S})
       = Exec(i,s) | (D \/ {IC S}) by A13,FUNCT_4:76
      .= Exec(i,s +* p) | (D \/ {IC S}) by A4,A5,A8,A14,FUNCT_7:def 2;
A16: Exec (i, s +* p)|I = (s +* p)|I by SCMFSA_3:5
      .= s|I +* p|I by FUNCT_4:75
      .= Exec (i,s)|I +* p|I by SCMFSA_3:5
      .= (Exec (i, s) +* p)|I by FUNCT_4:75;
    thus Exec (i, s +* p)
       = Exec (i, s +* p)| ({IC S} \/ D \/ I) by A5,A9,RELAT_1:98
      .= (Exec (i, s) +* p)| ({IC S} \/ D)
         +* (Exec (i, s) +* p)|I by A15,A16,FUNCT_4:83
      .= (Exec (i,s) +* p)| ({IC S} \/ D \/ I) by FUNCT_4:83
      .= (Exec (i,s) +* p)| dom(Exec (i, s) +* p) by A9,AMI_3:36
      .= Exec (i,s) +* p by RELAT_1:98;
  end;

begin :: SCM R

reserve
  R for good Ring,
  a, b for Data-Location of R,
  r for Element of the carrier of R,
  loc for Instruction-Location of SCM R,
  I for Instruction of SCM R,
  p for FinPartState of SCM R,
  s, s1, s2 for State of SCM R,
  q for FinPartState of SCM;

theorem Th14:
  the carrier of SCM R = {IC SCM R} \/ SCM-Data-Loc \/ SCM-Instr-Loc
  proof
     IC SCM R = IC SCM by AMI_3:4,SCMRING2:9;
    hence thesis by AMI_3:def 1,AMI_5:23,SCMRING2:def 1;
  end;

theorem
   ObjectKind loc = SCM-Instr R
   proof
A1: the Instruction-Locations of SCM R = SCM-Instr-Loc &
    the Object-Kind of SCM R = SCM-OK R by SCMRING2:def 1;
    thus ObjectKind loc = (the Object-Kind of SCM R).loc by AMI_1:def 6
        .= SCM-Instr R by A1,SCMRING1:6;
  end;

theorem Th16:
  dl.(R,n) = 2*n + 1
  proof
    thus dl.(R,n) = dl.n by SCMRING3:def 1
      .= 2*n+1 by AMI_3:def 19;
  end;

theorem
   il.(SCM R,k) = 2*k + 2
  proof
    thus il.(SCM R,k) = il.k by SCMRING3:66
        .= 2*k+2 by AMI_3:def 20;
  end;

theorem
   for dl being Data-Location of R ex i being Nat st dl = dl.(R,i)
  proof
    let dl be Data-Location of R;
      dl in SCM-Data-Loc by SCMRING2:1;
    then consider i being Nat such that
A1:   dl = 2*i +1 by AMI_2:def 2;
    take i;
    thus dl = dl.(R,i) by A1,Th16;
  end;

theorem
   for i,j being Nat holds i <> j implies dl.(R,i) <> dl.(R,j)
  proof
    let i,j be Nat;
A1: dl.(R,j) = 2*j + 1 & dl.(R,i) = 2*i + 1 by Th16;
    assume i <> j;
    then 2*i <> 2*j by XCMPLX_1:5;
    hence thesis by A1,XCMPLX_1:2;
  end;

theorem Th20:
  a <> loc
  proof
A1: the Instruction-Locations of SCM R = SCM-Instr-Loc by SCMRING2:def 1;
    assume a = loc;
    then loc in (the carrier of SCM R) \ (SCM-Instr-Loc \/ {0})
      by SCMRING2:def 2;
    then not loc in SCM-Instr-Loc \/ {0} by XBOOLE_0:def 4;
    hence thesis by A1,XBOOLE_0:def 2;
  end;

Lm6:
now
  let R;
  thus the carrier of SCM = {IC SCM R} \/ SCM-Data-Loc \/ SCM-Instr-Loc
    by AMI_3:4,AMI_5:23,SCMRING2:9
    .= the carrier of SCM R by Th14;
end;

Lm7:
now
  let a be State of SCM;
  let R,s;
  thus dom a = the carrier of SCM by AMI_3:36
    .= the carrier of SCM R by Lm6
    .= dom s by AMI_3:36;
end;

theorem Th21:
  SCM-Data-Loc c= dom s
  proof
    consider a being State of SCM;
     SCM-Data-Loc c= dom a by AMI_5:27;
    hence thesis by Lm7;
  end;

theorem Th22:
  dom (s|SCM-Data-Loc) = SCM-Data-Loc
  proof
     SCM-Data-Loc c= dom s by Th21;
    hence dom (s|SCM-Data-Loc) = SCM-Data-Loc by RELAT_1:91;
  end;

theorem
   p = q implies DataPart p = DataPart q
  proof
    assume
A1:   p = q;
    thus DataPart p =
    p | ((the carrier of SCM R) \
        ({IC SCM R} \/ the Instruction-Locations of SCM R)) by AMI_5:def 7
    .= q | ((the carrier of SCM) \
        ({IC SCM R} \/ the Instruction-Locations of SCM R)) by A1,Lm6
    .= q | ((the carrier of SCM) \
        ({IC SCM} \/ the Instruction-Locations of SCM R)) by AMI_3:4,SCMRING2:9
    .= q | ((the carrier of SCM) \
        ({IC SCM} \/ the Instruction-Locations of SCM)) by AMI_3:def 1
,SCMRING2:def 1
    .= DataPart q by AMI_5:def 7;
  end;

theorem Th24:
  DataPart p = p | SCM-Data-Loc
  proof
A1: SCM-Data-Loc misses {IC SCM R} \/ the Instruction-Locations of SCM R
    proof
       now
        assume IC SCM R in SCM-Data-Loc;
        then IC SCM R is Data-Location of R by SCMRING2:1;
        hence contradiction by SCMRING3:3;
      end;
      then SCM-Data-Loc misses {IC SCM R} by ZFMISC_1:56;
      then SCM-Data-Loc misses {IC SCM R} \/ SCM-Instr-Loc
        by AMI_5:33,XBOOLE_1:70;
      then SCM-Data-Loc /\ ({IC SCM R} \/ SCM-Instr-Loc) = {}
       by XBOOLE_0:def 7;
      hence SCM-Data-Loc /\ ({IC SCM R} \/ the Instruction-Locations of SCM R)
        = {} by SCMRING2:def 1;
    end;
     the carrier of SCM R = {IC SCM R} \/ SCM-Data-Loc \/ SCM-Instr-Loc
      by Th14
       .= {IC SCM R} \/ SCM-Instr-Loc \/ SCM-Data-Loc by XBOOLE_1:4
       .= {IC SCM R} \/ (the Instruction-Locations of SCM R) \/ SCM-Data-Loc
           by SCMRING2:def 1;
    then (the carrier of SCM R) \
        ({IC SCM R} \/ the Instruction-Locations of SCM R)
     = SCM-Data-Loc \ ({IC SCM R} \/ the Instruction-Locations of SCM R)
       by XBOOLE_1:40
    .= SCM-Data-Loc by A1,XBOOLE_1:83;
    hence thesis by AMI_5:def 7;
  end;

theorem
   p is data-only iff dom p c= SCM-Data-Loc
  proof
A1: the carrier of SCM R = {IC SCM R} \/ SCM-Data-Loc \/ SCM-Instr-Loc
     by Th14;
     dom p c= the carrier of SCM R by AMI_3:37;
    then A2: dom p c= {IC SCM R} \/ SCM-Instr-Loc \/ SCM-Data-Loc
      by A1,XBOOLE_1:4;
     now
      assume IC SCM R in SCM-Data-Loc;
      then IC SCM R is Data-Location of R by SCMRING2:1;
      hence contradiction by SCMRING3:3;
    end;
    then SCM-Data-Loc misses {IC SCM R} by ZFMISC_1:56;
    then SCM-Data-Loc misses {IC SCM R} \/ SCM-Instr-Loc
      by AMI_5:33,XBOOLE_1:70;
    then dom p misses {IC SCM R} \/ SCM-Instr-Loc
     iff dom p c= SCM-Data-Loc by A2,XBOOLE_1:63,73;
    then dom p misses {IC SCM R} \/ the Instruction-Locations of SCM R
     iff dom p c= SCM-Data-Loc by SCMRING2:def 1;
    hence thesis by AMI_5:def 8;
  end;

theorem Th26:
  dom DataPart p c= SCM-Data-Loc
  proof
     DataPart p = p|SCM-Data-Loc by Th24;
    hence dom DataPart p c= SCM-Data-Loc by RELAT_1:87;
  end;

theorem
   SCM-Instr-Loc c= dom s
  proof
A1: dom s = the carrier of SCM R by AMI_3:36;
     SCM-Instr-Loc c= {IC SCM R} \/ SCM-Data-Loc \/ SCM-Instr-Loc by XBOOLE_1:7
;
    hence SCM-Instr-Loc c= dom s by A1,Th14;
  end;

theorem
   p = q implies ProgramPart p = ProgramPart q
  proof
    assume
A1:   p = q;
    thus ProgramPart p =
       p | the Instruction-Locations of SCM R by AMI_5:def 6
    .= q | the Instruction-Locations of SCM by A1,AMI_3:def 1,SCMRING2:def 1
    .= ProgramPart q by AMI_5:def 6;
  end;

theorem Th29:
  dom ProgramPart p c= SCM-Instr-Loc
  proof
      ProgramPart p = p | the Instruction-Locations of SCM R by AMI_5:def 6;
    then ProgramPart p = p|SCM-Instr-Loc by SCMRING2:def 1;
    hence dom ProgramPart p c= SCM-Instr-Loc by RELAT_1:87;
  end;

registration
  let R; let I be Element of the Instructions of SCM R;
  cluster InsCode I -> natural;
  coherence
  proof
       the Instruction-Codes of SCM R = Segm 8 by SCMRING2:def 1;
     then InsCode I in Segm 8;
     hence thesis by ORDINAL2:def 21;
  end;
end;

theorem Th30:
  InsCode(I) <= 7
   proof
     the Instructions of SCM R = SCM-Instr R by SCMRING2:def 1;
    then I in SCM-Instr R;
    then A1: I`1 in Segm 8 by MCART_1:10;
     InsCode(I) = I`1 by AMI_5:def 1;
    then InsCode(I) < 7+1 by A1,GR_CY_1:10;
    hence InsCode(I) <= 7 by NAT_1:38;
  end;

theorem Th31:
  IncAddr(goto loc,k) = goto (loc + k)
  proof
    thus IncAddr(goto loc,k) = goto il.(SCM R, locnum loc + k) by SCMRING3:69
     .= goto il.(SCM R, locnum (loc + k)) by AMISTD_1:33
     .= goto (loc + k) by AMISTD_1:def 13;
  end;

theorem Th32:
  IncAddr(a=0_goto loc,k) = a=0_goto (loc + k)
  proof
    thus IncAddr(a=0_goto loc,k) = a=0_goto il.(SCM R, locnum loc + k)
        by SCMRING3:70
     .= a=0_goto il.(SCM R, locnum (loc + k)) by AMISTD_1:33
     .= a=0_goto (loc + k) by AMISTD_1:def 13;
  end;

theorem Th33:
  s.a = (s +* Start-At loc).a
  proof
A1: dom (Start-At loc) = {IC SCM R} by AMI_3:34;
     a in the carrier of SCM R;
    then a in dom s by AMI_3:36;
    then A2: a in dom s \/ dom (Start-At loc) by XBOOLE_0:def 2;
     a <> IC SCM R by SCMRING3:3;
    then not a in {IC SCM R} by TARSKI:def 1;
    hence s.a = (s +* Start-At loc).a by A1,A2,FUNCT_4:def 1;
  end;

theorem Th34:
  IC(s1) = IC(s2) &
  (for a being Data-Location of R holds s1.a = s2.a) &
  (for i being Instruction-Location of SCM R holds s1.i = s2.i)
  implies s1 = s2
  proof
    assume that
A1:   IC(s1) = IC(s2) and
A2:   for a being Data-Location of R holds s1.a = s2.a and
A3:   for i being Instruction-Location of SCM R holds s1.i = s2.i;
      s1 is Element of product SCM-OK R by SCMRING2:def 1;
    then consider g1 being Function such that
A4:   s1 = g1 & dom g1 = dom SCM-OK R &
    for x being set st x in dom SCM-OK R holds g1.x in (SCM-OK R).x
      by CARD_3:def 5;
      s2 is Element of product SCM-OK R by SCMRING2:def 1;
    then consider g2 being Function such that
A5:   s2 = g2 & dom g2 = dom SCM-OK R &
    for x being set st x in dom SCM-OK R holds g2.x in (SCM-OK R).x
      by CARD_3:def 5;
A6: NAT = dom g1 & NAT = dom g2 by A4,A5,FUNCT_2:def 1;
      now
      let x be set such that
A7:     x in NAT;
        NAT = the carrier of SCM R by SCMRING2:def 1
         .= {IC SCM R} \/ SCM-Data-Loc \/ SCM-Instr-Loc by Th14;
then A8:   x in {IC SCM R} \/ SCM-Data-Loc or x in SCM-Instr-Loc
       by A7,XBOOLE_0:def 2;
      per cases by A8,XBOOLE_0:def 2;
      suppose x in {IC SCM R};
then A9:   x = IC SCM R by TARSKI:def 1;
        s1.IC SCM R = IC(s1) by AMI_1:def 15
                .= s2.IC SCM R by A1,AMI_1:def 15;
      hence g1.x = g2.x by A4,A5,A9;
      end;
      suppose x in SCM-Data-Loc;
      then x is Data-Location of R by SCMRING2:1;
      hence g1.x = g2.x by A2,A4,A5;
      end;
      suppose
A10:     x in SCM-Instr-Loc;
        the Instruction-Locations of SCM R = SCM-Instr-Loc by SCMRING2:def 1;
      hence g1.x = g2.x by A3,A4,A5,A10;
      end;
    end;
    hence s1 = s2 by A4,A5,A6,FUNCT_1:9;
  end;

theorem Th35:
  Exec(IncAddr(CurInstr s,k),s +* Start-At (IC s + k))
     = Following(s) +* Start-At (IC Following(s) + k)
  proof
    set INS = CurInstr s;
A1: Following(s) +* Start-At (IC Following(s) + k)
     = Exec(INS, s) +* Start-At (IC Following(s) + k) by AMI_1:def 18
    .= Exec(INS, s) +* Start-At (IC Exec(INS, s) + k) by AMI_1:def 18;
    consider m being natural number such that
A2:   IC s = il.(SCM R,m) by AMISTD_1:26;
A3: IC s + k = il.(SCM R,m + k) by A2,Th2;
A4: Next IC (s +* Start-At (IC s + k))
      = Next (IC s + k) by AMI_5:79
     .= il.(SCM R,(m + k) + 1) by A3,SCMRING3:67
     .= il.(SCM R,m + 1 + k)
     .= il.(SCM R,m + 1) + k by Th2
     .= (Next il.(SCM R,m)) + k by SCMRING3:67
     .= IC (Exec(INS, s) +* Start-At ((Next IC s) + k)) by A2,AMI_5:79;
A5: now
      let d be Instruction-Location of SCM R;
      thus Exec(INS, s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by AMI_1:def 13
         .= s.d by AMI_5:81
         .= Exec(INS, s).d by AMI_1:def 13
         .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by AMI_5:81;
    end;
A6: InsCode INS <= 7 by Th30;
    per cases by A6,CQC_THE1:8;
    suppose InsCode INS = 0;
then A7:   INS = halt SCM R by SCMRING3:16;
then A8: Following(s) = Exec(halt SCM R, s) by AMI_1:def 18
                .= s by AMI_1:def 8;
    thus Exec(IncAddr(CurInstr s,k),s +* Start-At (IC s + k))
          = Exec(halt SCM R, s +* Start-At (IC s + k )) by A7,AMISTD_2:29
         .= Following(s) +* Start-At (IC Following(s) + k) by A8,AMI_1:def 8;
    end;
   suppose InsCode INS = 1;
     then consider da,db being Data-Location of R such that
A9:   INS = da := db by SCMRING3:17;
A10:   IncAddr(INS,k) = INS by A9,AMISTD_2:29;
A11:   IC Exec(INS, s) = Exec(INS, s).IC SCM R by AMI_1:def 15
                      .= Next IC s by A9,SCMRING2:13;

A12:   IC Exec(INS, s +* Start-At (IC s + k))
      = Exec(INS, s +* Start-At (IC s + k)).IC SCM R by AMI_1:def 15
     .= IC (Exec(INS, s) +* Start-At ((Next IC s) + k)) by A4,A9,SCMRING2:13;

      now let d be Data-Location of R;
     per cases;
     suppose
A13:         da = d;
     hence Exec(INS, s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).db by A9,SCMRING2:13
         .= s.db by Th33
         .= Exec(INS, s).d by A9,A13,SCMRING2:13
         .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
    end;
     suppose
A14:         da <> d;
     hence Exec(INS, s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by A9,SCMRING2:13
         .= s.d by Th33
         .= Exec(INS, s).d by A9,A14,SCMRING2:13
         .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
     end;
     end;
    hence thesis by A1,A5,A10,A11,A12,Th34;
    end;
   suppose InsCode INS = 2;
     then consider da,db being Data-Location of R such that
A15:   INS = AddTo(da, db) by SCMRING3:18;
A16:   IncAddr(INS, k) = INS by A15,AMISTD_2:29;
A17:   IC Exec(INS, s) = Exec(INS, s).IC SCM R by AMI_1:def 15
                      .= Next IC s by A15,SCMRING2:14;
A18:   IC Exec(INS, s +* Start-At (IC s + k))
      = Exec(INS, s +* Start-At (IC s + k)).IC SCM R by AMI_1:def 15
     .= IC (Exec(INS, s) +* Start-At ((Next IC s) + k)) by A4,A15,SCMRING2:14;

      now let d be Data-Location of R;
     per cases;
     suppose
A19:         da = d;
     hence Exec(INS, s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).da + (s +* Start-At (IC s + k)).db
 by A15,SCMRING2:14
         .= s.da + (s +* Start-At (IC s + k)).db by Th33
         .= s.da + s.db by Th33
         .= Exec(INS, s).d by A15,A19,SCMRING2:14
         .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
    end;
     suppose
A20:         da <> d;
     hence Exec(INS, s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by A15,SCMRING2:14
         .= s.d by Th33
         .= Exec(INS, s).d by A15,A20,SCMRING2:14
         .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
     end;
     end;
   hence thesis by A1,A5,A16,A17,A18,Th34;
    end;

   suppose InsCode INS = 3;
     then consider da,db being Data-Location of R such that
A21:   INS = SubFrom(da, db) by SCMRING3:19;
A22:   IncAddr(INS, k) = INS by A21,AMISTD_2:29;
A23:   IC Exec(INS, s) = Exec(INS, s).IC SCM R by AMI_1:def 15
                       .= Next IC s by A21,SCMRING2:15;

A24:   IC Exec(INS, s +* Start-At (IC s + k))
      = Exec(INS, s +* Start-At (IC s + k)).IC SCM R by AMI_1:def 15
     .= IC (Exec(INS, s) +* Start-At ((Next IC s) + k)) by A4,A21,SCMRING2:15;
     now let d be Data-Location of R;
     per cases;
     suppose
A25:         da = d;
     hence Exec(INS, s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).da - (s +* Start-At (IC s + k)).db
 by A21,SCMRING2:15
         .= s.da - (s +* Start-At (IC s + k)).db by Th33
         .= s.da - s.db by Th33
         .= Exec(INS, s).d by A21,A25,SCMRING2:15
         .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
    end;
     suppose
A26:         da <> d;
     hence Exec(INS, s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by A21,SCMRING2:15
         .= s.d by Th33
         .= Exec(INS, s).d by A21,A26,SCMRING2:15
         .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
     end;
     end;
   hence thesis by A1,A5,A22,A23,A24,Th34;

    end;
   suppose InsCode INS = 4;
     then consider da,db being Data-Location of R such that
A27:   INS = MultBy(da, db) by SCMRING3:20;
A28:   IncAddr(INS, k) = INS by A27,AMISTD_2:29;
A29:   IC Exec(INS, s) = Exec(INS, s).IC SCM R by AMI_1:def 15
                       .= Next IC s by A27,SCMRING2:16;

A30:   IC Exec(INS, s +* Start-At (IC s + k))
      = Exec(INS, s +* Start-At (IC s + k)).IC SCM R by AMI_1:def 15
     .= IC (Exec(INS, s) +* Start-At ((Next IC s) + k)) by A4,A27,SCMRING2:16;

      now let d be Data-Location of R;
     per cases;
     suppose
A31:         da = d;
     hence Exec(INS, s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).da * (s +* Start-At (IC s + k)).db
 by A27,SCMRING2:16
         .= s.da * (s +* Start-At (IC s + k)).db by Th33
         .= s.da * s.db by Th33
         .= Exec(INS, s).d by A27,A31,SCMRING2:16
         .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
    end;
     suppose
A32:         da <> d;
     hence Exec(INS, s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by A27,SCMRING2:16
         .= s.d by Th33
         .= Exec(INS, s).d by A27,A32,SCMRING2:16
         .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
     end;
     end;
   hence thesis by A1,A5,A28,A29,A30,Th34;

    end;
   suppose InsCode INS = 5;
     then consider da being Data-Location of R,
              r being Element of the carrier of R such that
A33:   INS = da:=r by SCMRING3:21;
A34:  IncAddr(INS,k) = INS by A33,AMISTD_2:29;
A35:  IC Exec(INS, s) = Exec(INS, s).IC SCM R by AMI_1:def 15
                     .= Next IC s by A33,SCMRING2:19;

A36:   IC Exec(INS, s +* Start-At (IC s + k))
      = Exec(INS, s +* Start-At (IC s + k)).IC SCM R by AMI_1:def 15
     .= IC (Exec(INS, s) +* Start-At ((Next IC s) + k)) by A4,A33,SCMRING2:19;

      now let d be Data-Location of R;
     per cases;
     suppose
A37:         da = d;
     hence Exec(INS, s +* Start-At (IC s + k)).d
          = r by A33,SCMRING2:19
         .= Exec(INS, s).d by A33,A37,SCMRING2:19
         .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
    end;
     suppose
A38:         da <> d;
     hence Exec(INS, s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by A33,SCMRING2:19
         .= s.d by Th33
         .= Exec(INS, s).d by A33,A38,SCMRING2:19
         .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
     end;
     end;
    hence thesis by A1,A5,A34,A35,A36,Th34;

    end;
  suppose InsCode INS = 6;
     then consider loc being Instruction-Location of SCM R such that
A39:   INS = goto loc by SCMRING3:22;
A40:   IncAddr(INS, k) = goto (loc + k) by A39,Th31;
A41:   IC Exec(INS, s) = Exec(INS, s).IC SCM R by AMI_1:def 15
                      .= loc by A39,SCMRING2:17;

A42:   IC Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
      = Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).IC SCM R
 by AMI_1:def 15
     .= loc + k by A40,SCMRING2:17
     .= IC (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)) by A41,AMI_5:79;

A43:  now let d be Data-Location of R;
     thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by A40,SCMRING2:17
         .= s.d by Th33
         .= Exec(INS, s).d by A39,SCMRING2:17
         .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by Th33;
     end;

       now let d be Instruction-Location of SCM R;
     thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by AMI_1:def 13
         .= s.d by AMI_5:81
         .= Exec(INS, s).d by AMI_1:def 13
         .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_5:81;
     end;
    hence thesis by A1,A42,A43,Th34;

    end;
    suppose InsCode INS = 7;
     then consider da being Data-Location of R,
              loc being Instruction-Location of SCM R such that
A44:   INS = da=0_goto loc by SCMRING3:23;
A45:   IncAddr(INS, k) = da=0_goto (loc + k) by A44,Th32;

       now per cases;
       suppose
A46:           s.da = 0.R;
then A47:        (s +* Start-At(IC s + k)).da=0.R by Th33;
A48:   IC Exec(INS, s) = Exec(INS, s).IC SCM R by AMI_1:def 15
                       .= loc by A44,A46,SCMRING2:18;
A49:   IC Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
       = Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).IC SCM R
 by AMI_1:def 15
      .= loc + k by A45,A47,SCMRING2:18
      .= IC (Exec(INS,s) +* Start-At (IC Exec(INS, s) + k)) by A48,AMI_5:79;

A50:   now let d be Data-Location of R;
      thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by A45,SCMRING2:18
         .= s.d by Th33
         .= Exec(INS, s).d by A44,SCMRING2:18
         .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by Th33;
      end;

        now let d be Instruction-Location of SCM R;
      thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by AMI_1:def 13
         .= s.d by AMI_5:81
         .= Exec(INS, s).d by AMI_1:def 13
         .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_5:81;
     end;
   hence Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
         = Exec(INS, s) +* Start-At (IC Exec(INS, s) + k) by A49,A50,Th34;
    end;

      suppose
A51:         s.da <> 0.R;
then A52:        (s +* Start-At(IC s + k)).da<>0.R by Th33;
A53:    IC Exec(INS, s) = Exec(INS, s).IC SCM R by AMI_1:def 15
                       .= Next IC s by A44,A51,SCMRING2:18;
A54:   IC Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
       = Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).IC SCM R
       by AMI_1:def 15
      .= IC (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)) by A4,A45,A52,A53,
SCMRING2:18;

A55:   now let d be Data-Location of R;
      thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by A45,SCMRING2:18
         .= s.d by Th33
         .= Exec(INS, s).d by A44,SCMRING2:18
         .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by Th33;
      end;

        now let d be Instruction-Location of SCM R;
      thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by AMI_1:def 13
         .= s.d by AMI_5:81
         .= Exec(INS, s).d by AMI_1:def 13
         .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_5:81;
      end;
     hence Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
          = (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)) by A54,A55,Th34;
     end;
    end;
    hence thesis by A1;
    end;
  end;

theorem Th36:
  IC s = il.(SCM R,j+k) implies
   Exec(I, s +* Start-At (IC s -' k))
     = Exec(IncAddr(I, k), s) +* Start-At (IC Exec(IncAddr(I,k), s) -' k)
  proof
   assume
A1: IC s = il.(SCM R,j+k);
then A2: Next (IC s -' k)
    = Next (il.(SCM R,j) + k -' k) by Th2
   .= Next (il.(SCM R,j)) by Th5
   .= il.(SCM R,j+1) by SCMRING3:67
   .= il.(SCM R,j+1) + k -' k by Th5
   .= il.(SCM R,j+1+k) -' k by Th2
   .= il.(SCM R,j+k+1) -' k
   .= (Next IC s) -' k by A1,SCMRING3:67;
A3: now let d be Instruction-Location of SCM R;
      thus Exec(I, s +* Start-At (IC s -' k)).d
         = (s +* Start-At (IC s -' k)).d by AMI_1:def 13
        .= s.d by AMI_5:81
        .= Exec(IncAddr(I, k), s).d by AMI_1:def 13
        .= (Exec(IncAddr(I, k), s)
           +* Start-At (IC Exec(IncAddr(I,k), s) -' k)).d by AMI_5:81;
     end;
A4: InsCode I <= 7 by Th30;
    per cases by A4,CQC_THE1:8;

 suppose InsCode I = 0;
then A5: I = halt SCM R by SCMRING3:16;
A6: IncAddr (halt SCM R, k) = halt SCM R by AMISTD_2:29;

 thus Exec(I, s +* Start-At (IC s -' k))
    = s +* Start-At (IC s -' k) by A5,AMI_1:def 8
   .= s +* Start-At (IC Exec(IncAddr(I,k), s) -' k) by A5,A6,AMI_1:def 8
   .= Exec(IncAddr(I, k), s) +* Start-At (IC Exec(IncAddr(I,k), s) -' k)
 by A5,A6,AMI_1:def 8;
    end;

 suppose InsCode I = 1;
    then consider da,db being Data-Location of R such that
A7: I = da := db by SCMRING3:17;
A8: IncAddr(I, k) = da := db by A7,AMISTD_2:29;
then A9: Exec(IncAddr(I,k), s).IC SCM R = Next IC s by SCMRING2:13;

A10: IC Exec(I, s +* Start-At (IC s -' k))
     = Exec(I, s +* Start-At (IC s -' k)).IC SCM R by AMI_1:def 15
    .= Next IC (s +* Start-At (IC s -' k)) by A7,SCMRING2:13
    .= (Next IC s) -' k by A2,AMI_5:79
    .= IC Exec(IncAddr(I,k), s) -' k by A9,AMI_1:def 15
 .= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s) -' k))
 by AMI_5:79;
      now let d be Data-Location of R;
     per cases;
     suppose
A11:         da = d;
     hence Exec(I, s +* Start-At (IC s -' k)).d
          = (s +* Start-At (IC s -' k)).db by A7,SCMRING2:13
         .= s.db by Th33
         .= Exec(IncAddr(I,k), s).d by A8,A11,SCMRING2:13
         .= (Exec(IncAddr(I,k), s) +*
             Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
    end;
     suppose
A12:         da <> d;
     hence Exec(I, s +* Start-At (IC s -' k)).d
          = (s +* Start-At (IC s -' k)).d by A7,SCMRING2:13
         .= s.d by Th33
         .= Exec(IncAddr(I, k), s).d by A8,A12,SCMRING2:13
         .= (Exec(IncAddr(I,k), s) +*
             Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
     end;
     end;
   hence thesis by A3,A10,Th34;
    end;

 suppose InsCode I = 2;
    then consider da,db being Data-Location of R such that
A13:  I = AddTo(da, db) by SCMRING3:18;
A14:  IncAddr(I, k) = AddTo(da, db) by A13,AMISTD_2:29;
then A15:  Exec(IncAddr(I,k), s).IC SCM R = Next IC s by SCMRING2:14;

A16: IC Exec(I, s +* Start-At (IC s -' k))
     = Exec(I, s +* Start-At (IC s -' k)).IC SCM R by AMI_1:def 15
    .= Next IC (s +* Start-At (IC s -' k)) by A13,SCMRING2:14
    .= (Next IC s) -' k by A2,AMI_5:79
    .= IC Exec(IncAddr(I,k), s) -' k by A15,AMI_1:def 15
  .= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s) -' k))
 by AMI_5:79;
      now let d be Data-Location of R;
     per cases;
     suppose
A17:         da = d;
     hence Exec(I, s +* Start-At (IC s -' k)).d
          = (s +* Start-At (IC s -' k)).da
            + (s +* Start-At (IC s -' k)).db by A13,SCMRING2:14
         .= s.da + (s +* Start-At (IC s -' k)).db by Th33
         .= s.da + s.db by Th33
         .= Exec(IncAddr(I,k), s).d by A14,A17,SCMRING2:14
         .= (Exec(IncAddr(I,k), s) +*
             Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
    end;
     suppose
A18:         da <> d;
     hence Exec(I, s +* Start-At (IC s -' k)).d
          = (s +* Start-At (IC s -' k)).d by A13,SCMRING2:14
         .= s.d by Th33
         .= Exec(IncAddr(I, k), s).d by A14,A18,SCMRING2:14
         .= (Exec(IncAddr(I,k), s) +*
             Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
     end;
     end;
    hence thesis by A3,A16,Th34;
    end;

 suppose InsCode I = 3;
     then consider da,db being Data-Location of R such that
A19:   I = SubFrom(da, db) by SCMRING3:19;
A20:   IncAddr(I, k) = SubFrom(da, db) by A19,AMISTD_2:29;
then A21:   Exec(IncAddr(I,k), s).IC SCM R = Next IC s by SCMRING2:15;

A22: IC Exec(I, s +* Start-At (IC s -' k))
     = Exec(I, s +* Start-At (IC s -' k)).IC SCM R by AMI_1:def 15
    .= Next IC (s +* Start-At (IC s -' k)) by A19,SCMRING2:15
    .= (Next IC s) -' k by A2,AMI_5:79
    .= IC Exec(IncAddr(I,k), s) -' k by A21,AMI_1:def 15
 .= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s) -' k))
 by AMI_5:79;
      now let d be Data-Location of R;
     per cases;
     suppose
A23:         da = d;
     hence Exec(I, s +* Start-At (IC s -' k)).d
          = (s +* Start-At (IC s -' k)).da
            - (s +* Start-At (IC s -' k)).db by A19,SCMRING2:15
         .= s.da - (s +* Start-At (IC s -' k)).db by Th33
         .= s.da - s.db by Th33
         .= Exec(IncAddr(I,k), s).d by A20,A23,SCMRING2:15
         .= (Exec(IncAddr(I,k), s) +*
             Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
    end;
     suppose
A24:         da <> d;
     hence Exec(I, s +* Start-At (IC s -' k)).d
          = (s +* Start-At (IC s -' k)).d by A19,SCMRING2:15
         .= s.d by Th33
         .= Exec(IncAddr(I, k), s).d by A20,A24,SCMRING2:15
         .= (Exec(IncAddr(I,k), s) +*
             Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
     end;
     end;
    hence thesis by A3,A22,Th34;
    end;

 suppose InsCode I = 4;
     then consider da,db being Data-Location of R such that
A25:   I = MultBy(da, db) by SCMRING3:20;
A26:   IncAddr(I, k) = MultBy(da, db) by A25,AMISTD_2:29;
then A27:   Exec(IncAddr(I,k), s).IC SCM R = Next IC s by SCMRING2:16;

A28: IC Exec(I, s +* Start-At (IC s -' k))
     = Exec(I, s +* Start-At (IC s -' k)).IC SCM R by AMI_1:def 15
    .= Next IC (s +* Start-At (IC s -' k)) by A25,SCMRING2:16
    .= (Next IC s) -' k by A2,AMI_5:79
    .= IC Exec(IncAddr(I,k), s) -' k by A27,AMI_1:def 15
 .= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s) -' k))
 by AMI_5:79;
       now let d be Data-Location of R;
     per cases;
     suppose
A29:         da = d;
     hence Exec(I, s +* Start-At (IC s -' k)).d
          = (s +* Start-At (IC s -' k)).da
            * (s +* Start-At (IC s -' k)).db by A25,SCMRING2:16
         .= s.da * (s +* Start-At (IC s -' k)).db by Th33
         .= s.da * s.db by Th33
         .= Exec(IncAddr(I,k), s).d by A26,A29,SCMRING2:16
         .= (Exec(IncAddr(I,k), s) +*
             Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
    end;
     suppose
A30:         da <> d;
     hence Exec(I, s +* Start-At (IC s -' k)).d
          = (s +* Start-At (IC s -' k)).d by A25,SCMRING2:16
         .= s.d by Th33
         .= Exec(IncAddr(I, k), s).d by A26,A30,SCMRING2:16
         .= (Exec(IncAddr(I,k), s) +*
             Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
     end;
     end;
    hence thesis by A3,A28,Th34;
    end;

 suppose InsCode I = 5;
     then consider da being Data-Location of R,
              r being Element of the carrier of R such that
A31:   I = da:=r by SCMRING3:21;
A32: IncAddr(I, k) = da := r by A31,AMISTD_2:29;
then A33: Exec(IncAddr(I,k), s).IC SCM R = Next IC s by SCMRING2:19;

A34: IC Exec(I, s +* Start-At (IC s -' k))
     = Exec(I, s +* Start-At (IC s -' k)).IC SCM R by AMI_1:def 15
    .= Next IC (s +* Start-At (IC s -' k)) by A31,SCMRING2:19
    .= (Next IC s) -' k by A2,AMI_5:79
    .= IC Exec(IncAddr(I,k), s) -' k by A33,AMI_1:def 15
 .= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s) -' k))
 by AMI_5:79;
      now let d be Data-Location of R;
     per cases;
     suppose
A35:         da = d;
     hence Exec(I, s +* Start-At (IC s -' k)).d
          = r by A31,SCMRING2:19
         .= Exec(IncAddr(I,k), s).d by A32,A35,SCMRING2:19
         .= (Exec(IncAddr(I,k), s) +*
             Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
    end;
     suppose
A36:         da <> d;
     hence Exec(I, s +* Start-At (IC s -' k)).d
          = (s +* Start-At (IC s -' k)).d by A31,SCMRING2:19
         .= s.d by Th33
         .= Exec(IncAddr(I, k), s).d by A32,A36,SCMRING2:19
         .= (Exec(IncAddr(I,k), s) +*
             Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
     end;
     end;
   hence thesis by A3,A34,Th34;
    end;

  suppose InsCode I = 6;
  then consider loc being Instruction-Location of SCM R such that
A37:  I = goto loc by SCMRING3:22;
A38:  IncAddr(I, k) = goto (loc + k) by A37,Th31;
A39:  IC Exec(IncAddr(I,k), s)=Exec(IncAddr(I,k), s).IC SCM R
 by AMI_1:def 15
                              .= loc + k by A38,SCMRING2:17;
A40:  IC Exec(I, s +* Start-At (IC s -' k))
      = Exec(I, s +* Start-At (IC s -' k)).IC SCM R by AMI_1:def 15
     .= loc by A37,SCMRING2:17
     .= IC Exec(IncAddr(I,k), s) -' k by A39,Th5
 .= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s) -' k))
 by AMI_5:79;
     now let d be Data-Location of R;
    thus Exec(I, s +* Start-At (IC s -' k)).d
          = (s +* Start-At (IC s -' k)).d by A37,SCMRING2:17
         .= s.d by Th33
         .= Exec(IncAddr(I,k), s).d by A38,SCMRING2:17
         .= (Exec(IncAddr(I,k), s) +*
             Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
   end;
 hence thesis by A3,A40,Th34;
    end;

 suppose InsCode I = 7;
  then consider da being Data-Location of R,
           loc being Instruction-Location of SCM R such that
A41:   I = da=0_goto loc by SCMRING3:23;
A42:   IncAddr(I, k) = da=0_goto (loc + k) by A41,Th32;

A43: now per cases;
   suppose
A44:  s.da = 0.R;
then A45: (s +* Start-At (IC s -' k)).da = 0.R by Th33;
A46: IC Exec(IncAddr(I,k), s)=Exec(IncAddr(I,k), s).IC SCM R
 by AMI_1:def 15
                             .= loc + k by A42,A44,SCMRING2:18;
      IC Exec(I, s +* Start-At (IC s -' k))
       = Exec(I, s +* Start-At (IC s -' k)).IC SCM R by AMI_1:def 15
      .= loc by A41,A45,SCMRING2:18
      .= IC Exec(IncAddr(I,k), s) -' k by A46,Th5
 .= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s) -' k))
 by AMI_5:79;
 hence IC Exec(I, s +* Start-At (IC s -' k))
     = IC(Exec(IncAddr(I,k),s) +* Start-At(IC Exec(IncAddr(I,k),s)-'k));
    end;

    suppose
A47:  s.da <> 0.R;
then A48: (s +* Start-At (IC s -' k)).da <> 0.R by Th33;
A49:   Exec(IncAddr(I,k), s).IC SCM R = Next IC s by A42,A47,SCMRING2:18;
       IC Exec(I, s +* Start-At (IC s -' k))
       = Exec(I, s +* Start-At (IC s -' k)).IC SCM R by AMI_1:def 15
      .= Next IC (s +* Start-At (IC s -' k)) by A41,A48,SCMRING2:18
      .= (Next IC s) -' k by A2,AMI_5:79
      .= IC Exec(IncAddr(I,k), s) -' k by A49,AMI_1:def 15
 .= IC(Exec(IncAddr(I,k),s) +* Start-At(IC Exec(IncAddr(I,k),s) -' k))
 by AMI_5:79;
 hence IC Exec(I, s +* Start-At (IC s -' k))
     = IC(Exec(IncAddr(I,k),s) +* Start-At(IC Exec(IncAddr(I,k),s)-'k));
  end;
  end;

     now let d be Data-Location of R;
    thus Exec(I, s +* Start-At (IC s -' k)).d
          = (s +* Start-At (IC s -' k)).d by A41,SCMRING2:18
         .= s.d by Th33
         .= Exec(IncAddr(I,k), s).d by A42,SCMRING2:18
         .= (Exec(IncAddr(I,k), s) +*
             Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
    end;
   hence thesis by A3,A43,Th34;
end;
    end;

registration let R;
 cluster autonomic non programmed FinPartState of SCM R;
 existence
  proof
    set P = (IC SCM R, il.(SCM R,0)) --> (il.(SCM R,0), halt SCM R);
A1: {IC SCM R}-->il.(SCM R,0) = IC SCM R.-->il.(SCM R,0) by CQC_LANG:def 2
             .= Start-At il.(SCM R,0) by AMI_3:def 12;
      P = ({IC SCM R}-->il.(SCM R,0)) +* ({il.(SCM R,0)}-->halt SCM R)
     by FUNCT_4:def 4
     .= Start-At(il.(SCM R,0))+*((il.(SCM R,0)) .--> halt SCM R)
     by A1,CQC_LANG:def 2;
    then reconsider P as FinPartState of SCM R;
    take P;
A2: ObjectKind il.(SCM R,0) = the Instructions of SCM R by AMI_1:def 14;
      ObjectKind IC SCM R = the Instruction-Locations of SCM R by AMI_1:def 11;
    hence P is autonomic by A2,AMI_1:67;
      now
        dom P = { IC SCM R, il.(SCM R,0) } by FUNCT_4:65;
then A3:   IC SCM R in dom P by TARSKI:def 2;
      assume dom P c= the Instruction-Locations of SCM R;
      hence contradiction by A3,AMI_1:48;
    end;
    hence P is non programmed by AMI_3:def 13;
  end;
end;

definition let R;
           let a be Data-Location of R;
           let r be Element of the carrier of R;
 redefine func a .--> r -> FinPartState of SCM R;
coherence
  proof
    reconsider b = a as Nat by SCMRING2:def 1;
    set k = a .--> r,
        f = the Object-Kind of SCM R;
A1: dom the Object-Kind of SCM R = dom SCM-OK R by SCMRING2:def 1
       .= NAT by FUNCT_2:def 1;
A2: dom k = {a} by CQC_LANG:5;
A3: {b} is Subset of NAT;
      for x being set st x in dom k holds k.x in f.x
    proof
      let x be set;
      assume x in dom k;
then A4:   x = a by A2,TARSKI:def 1;
then A5:   k.x = r by CQC_LANG:6;
        f.x = ObjectKind a by A4,AMI_1:def 6
         .= the carrier of R by SCMRING3:1;
      hence k.x in f.x by A5;
    end;
    then X:k in sproduct the Object-Kind of SCM R by A1,A2,A3,AMI_1:def 16;
    k = {a} --> r by CQC_LANG:def 2; then
    k is finite;
    hence thesis by X,AMI_1:def 24;
  end;
end;

theorem Th37:
  R is non trivial implies
  for p being autonomic FinPartState of SCM R st DataPart p <> {} holds
   IC SCM R in dom p
  proof
    assume
A1:   R is non trivial;
    let p be autonomic FinPartState of SCM R;
    assume DataPart p <> {};
then A2: dom DataPart p <> {} by RELAT_1:64;
    assume A3: not IC SCM R in dom p;
      p is not autonomic
    proof
      consider d1 being Element of dom DataPart p;
A4:   d1 in dom DataPart p by A2;
        dom DataPart p c= the carrier of SCM R by AMI_3:37;
      then reconsider d1 as Element of the carrier of SCM R by A4;
        DataPart p = p | SCM-Data-Loc by Th24;
      then dom DataPart p c= SCM-Data-Loc by RELAT_1:87;
      then reconsider d1 as Data-Location of R by A4,SCMRING2:1;
      consider d2 being Element of SCM-Data-Loc \ dom p;
      not SCM-Data-Loc c= dom p by FINSET_1:13;
then A6:   SCM-Data-Loc \ dom p <> {} by XBOOLE_1:37;
      then d2 in SCM-Data-Loc by XBOOLE_0:def 4;
      then reconsider d2 as Data-Location of R by SCMRING2:1;
     consider il being Element of (the Instruction-Locations of SCM R) \ dom p;
        not the Instruction-Locations of SCM R c= dom p
        by FINSET_1:13;
then A7:   (the Instruction-Locations of SCM R) \ dom p <> {} by XBOOLE_1:37;
      then reconsider il as Instruction-Location of SCM R by XBOOLE_0:def 4;
      consider e being Element of the carrier of R such that
A8:     e <> 0.R by A1,ANPROJ_1:def 8;
      set p1 = p +* ((il .--> (d1:=d2)) +* (d2.--> 0.R) +* Start-At il);
      set p2 = p +* ((il .--> (d1:=d2)) +* (d2.--> e) +* Start-At il);
      consider s1 being State of SCM R such that
A9:     p1 c= s1 by AMI_3:39;
      consider s2 being State of SCM R such that
A10:     p2 c= s2 by AMI_3:39;
      take s1, s2;
A11:   not d2 in dom p by A6,XBOOLE_0:def 4;
A12:  not il in dom p by A7,XBOOLE_0:def 4;
        dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
      proof
        dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
        = dom((il .--> (d1:=d2)) +* ( d2.--> 0.R)) \/ dom(Start-At il)
                                                by FUNCT_4:def 1
       .= dom((il .--> (d1:=d2)) +* ( d2.--> 0.R)) \/ {IC SCM R} by AMI_3:34
       .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> 0.R) \/ {IC SCM R}
           by FUNCT_4:def 1
       .= {il} \/ dom ( d2.--> 0.R) \/ {IC SCM R} by CQC_LANG:5
       .= {il} \/ {d2} \/ {IC SCM R} by CQC_LANG:5;
      hence dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
        = dom p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM R} by XBOOLE_1:23
       .= dom p /\ ({il} \/ {d2}) \/ {} by A3,Lm1
       .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
       .= dom p /\ {il} \/ {} by A11,Lm1
       .= {} by A12,Lm1;
      end;
      then p c= p1 by FUNCT_4:33;
      hence p c= s1 by A9,XBOOLE_1:1;
        dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
      proof
        dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
         = dom((il .--> (d1:=d2)) +* ( d2.--> e)) \/ dom(Start-At il)
                                                 by FUNCT_4:def 1
        .= dom((il .--> (d1:=d2)) +* ( d2.--> e)) \/ {IC SCM R} by AMI_3:34
        .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> e) \/ {IC SCM R}
           by FUNCT_4:def 1
        .= {il} \/ dom ( d2.--> e) \/ {IC SCM R} by CQC_LANG:5
        .= {il} \/ {d2} \/ {IC SCM R} by CQC_LANG:5;
      hence dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
         = dom p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM R} by XBOOLE_1:23
        .= dom p /\ ({il} \/ {d2}) \/ {} by A3,Lm1
        .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
        .= dom p /\ {il} \/ {} by A11,Lm1
        .= {} by A12,Lm1;
      end;
      then p c= p2 by FUNCT_4:33;
      hence p c= s2 by A10,XBOOLE_1:1;
      take 1;
        DataPart p c= p by AMI_5:62;
then A13:   dom DataPart p c= dom p by RELAT_1:25;
        dom ((Computation s1).1) = the carrier of SCM R by AMI_3:36;
      then dom p c= dom ((Computation s1).1) by AMI_3:37;
then A14:  dom ((Computation s1).1|dom p) = dom p by RELAT_1:91;
A15:  dom(Start-At il) = {IC SCM R} by AMI_3:34;
then A16:  IC SCM R in dom (Start-At il) by TARSKI:def 1;
A17:  dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
          = dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R)) \/ dom(Start-At il)
                                 by FUNCT_4:def 1;
then A18:  IC SCM R in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
                                 by A16,XBOOLE_0:def 2;
A19:dom p1 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
                                 by FUNCT_4:def 1;
then A20:IC SCM R in dom p1 by A18,XBOOLE_0:def 2;
A21:IC s1 = s1.IC SCM R by AMI_1:def 15
         .= p1.IC SCM R by A9,A20,GRFUNC_1:8
         .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il).IC SCM R
            by A18,FUNCT_4:14
         .= (Start-At il).IC SCM R by A16,FUNCT_4:14
         .= il by AMI_3:50;
      dom (il .--> (d1:=d2)) = {il} by CQC_LANG:5;
then A22:il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
A23:dom (d2 .--> 0.R) = {d2} by CQC_LANG:5;
A24:     il <> d2 by Th20;
then A25:not il in dom (d2 .--> 0.R) by A23,TARSKI:def 1;
A26:dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R))
         = dom (il .--> (d1:=d2)) \/ dom ( d2.--> 0.R) by FUNCT_4:def 1;
then A27:il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R)) by A22,XBOOLE_0:def 2;
A28:     il <> IC SCM R by AMI_1:48;
then A29:not il in dom (Start-At il) by A15,TARSKI:def 1;
A30:il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
         by A17,A27,XBOOLE_0:def 2;
    then il in dom p1 by A19,XBOOLE_0:def 2;
then A31:s1.il = p1.il by A9,GRFUNC_1:8
         .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il).il
                                                 by A30,FUNCT_4:14
         .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R)).il by A29,FUNCT_4:12
         .= (il .--> (d1:=d2)).il by A25,FUNCT_4:12
         .= d1:=d2 by CQC_LANG:6;
A32:d2 in dom (d2 .--> 0.R) by A23,TARSKI:def 1;
then A33:d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R)) by A26,XBOOLE_0:def 2;
A34:     d2 <> IC SCM R by SCMRING3:3;
then A35:not d2 in dom (Start-At il) by A15,TARSKI:def 1;
A36:d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
                                        by A17,A33,XBOOLE_0:def 2;
    then d2 in dom p1 by A19,XBOOLE_0:def 2;
then A37:s1.d2 = p1.d2 by A9,GRFUNC_1:8
         .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il).d2
                                                by A36,FUNCT_4:14
         .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R)).d2 by A35,FUNCT_4:12
         .= (d2.--> 0.R).d2 by A32,FUNCT_4:14
         .= 0.R by CQC_LANG:6;
      (Computation s1).(0+1).d1 = (Following (Computation s1).0).d1
     by AMI_1:def 19
                           .= (Following s1).d1 by AMI_1:def 19
                           .= Exec(CurInstr s1,s1).d1 by AMI_1:def 18
                           .= Exec(s1.il,s1).d1 by A21,AMI_1:def 17
                           .= 0.R by A31,A37,SCMRING2:13;
then A38:((Computation s1).1|dom p).d1 = 0.R by A4,A13,A14,FUNCT_1:70;
      dom ((Computation s2).1) = the carrier of SCM R by AMI_3:36;
    then dom p c= dom ((Computation s2).1) by AMI_3:37;
then A39:dom ((Computation s2).1|dom p) = dom p by RELAT_1:91;
A40:dom(Start-At il) = {IC SCM R} by AMI_3:34;
then A41:IC SCM R in dom (Start-At il) by TARSKI:def 1;
A42:dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
         = dom ((il .--> (d1:=d2)) +* ( d2.--> e)) \/ dom(Start-At il)
                                 by FUNCT_4:def 1;
then A43:IC SCM R in dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
                                 by A41,XBOOLE_0:def 2;
A44:dom p2 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
                                 by FUNCT_4:def 1;
then A45:IC SCM R in dom p2 by A43,XBOOLE_0:def 2;
A46:IC s2 = s2.IC SCM R by AMI_1:def 15
         .= p2.IC SCM R by A10,A45,GRFUNC_1:8
         .= ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il).IC SCM R
                                             by A43,FUNCT_4:14
         .= (Start-At il).IC SCM R by A41,FUNCT_4:14
         .= il by AMI_3:50;
      dom (il .--> (d1:=d2)) = {il} by CQC_LANG:5;
then A47:il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
A48:dom (d2 .--> e) = {d2} by CQC_LANG:5;
then A49:not il in dom (d2 .--> e) by A24,TARSKI:def 1;
A50:dom ((il .--> (d1:=d2)) +* ( d2.--> e))
        = dom (il .--> (d1:=d2)) \/ dom ( d2.--> e) by FUNCT_4:def 1;
then A51:il in dom ((il .--> (d1:=d2)) +* ( d2.--> e)) by A47,XBOOLE_0:def 2;
A52:not il in dom (Start-At il) by A28,A40,TARSKI:def 1;
A53:il in dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
                             by A42,A51,XBOOLE_0:def 2;
    then il in dom p2 by A44,XBOOLE_0:def 2;
then A54:s2.il = p2.il by A10,GRFUNC_1:8
         .= ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il).il
                                                by A53,FUNCT_4:14
         .= ((il .--> (d1:=d2)) +* ( d2.--> e)).il by A52,FUNCT_4:12
         .= (il .--> (d1:=d2)).il by A49,FUNCT_4:12
         .= d1:=d2 by CQC_LANG:6;
A55:d2 in dom (d2 .--> e) by A48,TARSKI:def 1;
then A56:d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> e)) by A50,XBOOLE_0:def 2;
 A57:not d2 in dom (Start-At il) by A34,A40,TARSKI:def 1;
A58:d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
                                        by A42,A56,XBOOLE_0:def 2;
    then d2 in dom p2 by A44,XBOOLE_0:def 2;
then A59:s2.d2 = p2.d2 by A10,GRFUNC_1:8
         .= ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il).d2
                                                by A58,FUNCT_4:14
         .= ((il .--> (d1:=d2)) +* ( d2.--> e)).d2 by A57,FUNCT_4:12
         .= (d2.--> e).d2 by A55,FUNCT_4:14
         .= e by CQC_LANG:6;
      (Computation s2).(0+1).d1 = (Following (Computation s2).0).d1
    by AMI_1:def 19
                             .= (Following s2).d1 by AMI_1:def 19
                             .= Exec(CurInstr s2,s2).d1 by AMI_1:def 18
                             .= Exec(s2.il,s2).d1 by A46,AMI_1:def 17
                             .= e by A54,A59,SCMRING2:13;
    hence (Computation s1).1|dom p <> (Computation s2).1|dom p by A4,A8,A13,A38
,A39,FUNCT_1:70;
  end;
  hence contradiction;
end;

theorem Th38:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R holds
   IC SCM R in dom p
  proof
   assume
A1:  R is non trivial;
   let p be autonomic non programmed FinPartState of SCM R;
     the Instruction-Locations of SCM R = SCM-Instr-Loc by SCMRING2:def 1;
then A2:not dom p c= SCM-Instr-Loc by AMI_3:def 13;
     dom p c= the carrier of SCM R by AMI_3:37;
   then dom p = dom p /\ the carrier of SCM R by XBOOLE_1:28
        .= dom p /\ ({IC SCM R} \/ SCM-Data-Loc \/ SCM-Instr-Loc) by Th14
        .= dom p /\ ({IC SCM R} \/ SCM-Data-Loc) \/ dom p /\ SCM-Instr-Loc
                                      by XBOOLE_1:23;
 then dom p /\ ({IC SCM R} \/ SCM-Data-Loc) <> {} by A2,XBOOLE_1:17;
 then A3: dom p /\ {IC SCM R} \/ dom p /\ SCM-Data-Loc <> {} by XBOOLE_1:23;
    per cases by A3;
    suppose dom p /\ {IC SCM R} <> {};
    hence IC SCM R in dom p by Lm1;
    end;
    suppose A4: dom p /\ SCM-Data-Loc <> {};
     DataPart p = p | SCM-Data-Loc by Th24;
    then DataPart p <> {} by A4,FUNCT_1:68,RELAT_1:60;
    hence IC SCM R in dom p by A1,Th37;
    end;
  end;

theorem
   for p being autonomic FinPartState of SCM R st IC SCM R in dom p holds
   IC p in dom p
    proof
     let p be autonomic FinPartState of SCM R;
     assume
A1:    IC SCM R in dom p;
     assume
A2:    not IC p in dom p;
     set il = IC p;
     set p1 = p +* ((il .--> goto il.(SCM R,0)));
     set p2 = p +* ((il .--> goto il.(SCM R,1)));
     consider s1 being State of SCM R such that A3: p1 c= s1 by AMI_3:39;
     consider s2 being State of SCM R such that A4: p2 c= s2 by AMI_3:39;
       p is not autonomic
      proof
A5:    dom (il .--> (goto il.(SCM R,1))) = {il} by CQC_LANG:5;
A6:    dom (il .--> (goto il.(SCM R,0))) = {il} by CQC_LANG:5;
       take s1,s2;
         dom p misses {il}
       proof
         thus dom p /\ {il} = {} by A2,Lm1;
       end;
    then p c= p1 & p c= p2 by A5,A6,FUNCT_4:33;
       hence A7: p c= s1 & p c= s2 by A3,A4,XBOOLE_1:1;
       take 1;
A8:     il in dom (il .--> (goto il.(SCM R,1))) by A5,TARSKI:def 1;
A9:     il in dom (il .--> (goto il.(SCM R,0))) by A6,TARSKI:def 1;
          dom p1 = dom p \/ dom ((il .--> goto il.(SCM R,0))) by FUNCT_4:def 1;
        then il in dom p1 by A9,XBOOLE_0:def 2;
then A10:     s1.il = p1.il by A3,GRFUNC_1:8
             .= ((il .--> goto il.(SCM R,0))).il by A9,FUNCT_4:14
             .= goto il.(SCM R,0) by CQC_LANG:6;
          dom p2 = dom p \/ dom ((il .--> goto il.(SCM R,1))) by FUNCT_4:def 1;
        then il in dom p2 by A8,XBOOLE_0:def 2;
then A11:     s2.il = p2.il by A4,GRFUNC_1:8
             .= ((il .--> goto il.(SCM R,1))).il by A8,FUNCT_4:14
             .= goto il.(SCM R,1) by CQC_LANG:6;
A12:    (Following s1).IC SCM R
        = (Exec (CurInstr s1,s1)).IC SCM R by AMI_1:def 18
       .= Exec (s1.IC s1,s1).IC SCM R by AMI_1:def 17
       .= Exec (goto il.(SCM R,0),s1).IC SCM R by A1,A7,A10,AMI_5:60
       .= il.(SCM R,0) by SCMRING2:17;

A13:    (Following s2).IC SCM R
        = (Exec (CurInstr s2,s2)).IC SCM R by AMI_1:def 18
       .= Exec (s2.IC s2,s2).IC SCM R by AMI_1:def 17
       .= Exec (goto il.(SCM R,1),s2).IC SCM R by A1,A7,A11,AMI_5:60
       .= il.(SCM R,1) by SCMRING2:17;

       assume A14: (Computation s1).1|dom p = (Computation s2).1|dom p;
         A15: (Following(s1))|dom p
                      = (Following ((Computation s1).0))|dom p by AMI_1:def 19
                     .= (Computation s1).(0+1)|dom p by AMI_1:def 19
                     .= (Following ((Computation s2).0))|dom p
                     by A14,AMI_1:def 19
                     .= (Following(s2))|dom p by AMI_1:def 19;
              il.(SCM R,0) = ((Following(s1))|dom p).IC SCM R
             by A1,A12,FUNCT_1:72
                .= il.(SCM R,1) by A1,A13,A15,FUNCT_1:72;
       hence contradiction by AMISTD_1:25;
    end;
     hence contradiction;
  end;

theorem Th40:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R st p c= s
   holds IC (Computation s).n in dom ProgramPart(p)
  proof
   assume
A1:  R is non trivial;
   let p be autonomic non programmed FinPartState of SCM R such that
A2:  p c= s;
   set Csi = (Computation s).n;
   set loc = IC Csi;
   consider ll being natural number such that
A3:   loc = il.(SCM R,ll) by AMISTD_1:26;
   set loc1 = il.(SCM R,ll+1);
A4:  loc <> loc1
       proof
         assume loc = loc1;
         then ll + 0 = ll + 1 by A3,AMISTD_1:25;
        hence contradiction by XCMPLX_1:2;
       end;
A5: loc = Csi.IC SCM R by AMI_1:def 15;
  assume
A6: not IC (Computation s).n in dom ProgramPart(p);
A7: the Instruction-Locations of SCM R = SCM-Instr-Loc by SCMRING2:def 1;
    then ProgramPart p = p|SCM-Instr-Loc by AMI_5:def 6;
    then loc in dom ProgramPart p iff loc in dom p /\ SCM-Instr-Loc by
FUNCT_1:68;
    then A8:not loc in dom p by A6,A7,XBOOLE_0:def 3;
    set p1 = p +* (loc .--> goto loc);
    set p2 = p +* (loc .--> goto loc1);

A9:  dom p1 = dom p \/ dom (loc .--> goto loc) &
         dom p2 = dom p \/ dom (loc .--> goto loc1) by FUNCT_4:def 1;
A10:  dom (loc .--> goto loc) = {loc} &
         dom (loc .--> goto loc1) = {loc} by CQC_LANG:5;
then A11:  loc in dom (loc .--> goto loc) &
         loc in dom (loc .--> goto loc1) by TARSKI:def 1;
then A12:   loc in dom p1 & loc in dom p2 by A9,XBOOLE_0:def 2;

    consider s1 being State of SCM R such that
A13: p1 c= s1 by AMI_3:39;
    consider s2 being State of SCM R such that
A14: p2 c= s2 by AMI_3:39;

 set Cs1i = (Computation s1).n;
 set Cs2i = (Computation s2).n;

A15:  IC SCM R in dom p by A1,Th38;
    p is not autonomic
   proof
     take s1, s2;
       dom s1 = the carrier of SCM R & dom s2 = the carrier of SCM R
                                                    by AMI_3:36;
then A16: dom p c= dom s1 & dom p c= dom s2 by AMI_3:37;
       now let x be set; assume
A17:    x in dom p;
A18:   dom p misses dom (loc .--> goto loc)
     proof
       thus dom p /\ dom (loc .--> goto loc) = {} by A8,A10,Lm1;
     end;
        x in dom p1 by A9,A17,XBOOLE_0:def 2;
       then p.x = p1.x & p1.x = s1.x by A13,A17,A18,FUNCT_4:17,GRFUNC_1:8;
      hence p.x = s1.x;
     end;
    hence
A19: p c= s1 by A16,GRFUNC_1:8;
      now let x be set; assume
A20:   x in dom p;
A21:   dom p misses dom (loc .--> goto loc1)
     proof
       thus dom p /\ dom (loc .--> goto loc1) = {} by A8,A10,Lm1;
     end;
        x in dom p2 by A9,A20,XBOOLE_0:def 2;
      then p.x = p2.x & p2.x = s2.x by A14,A20,A21,FUNCT_4:17,GRFUNC_1:8;
     hence p.x = s2.x;
    end;
   hence
A22: p c= s2 by A16,GRFUNC_1:8;
         (loc .--> goto loc).loc = goto loc &
       (loc .--> goto loc1).loc = goto loc1 by CQC_LANG:6;
       then p1.loc = goto loc & p2.loc = goto loc1 by A11,FUNCT_4:14;
then A23:  s1.loc = goto loc & s2.loc = goto loc1 by A12,A13,A14,GRFUNC_1:8;

  take k = n+1;

  set Cs1k = (Computation s1).k;
  set Cs2k = (Computation s2).k;
A24: Cs1k = Following Cs1i by AMI_1:def 19
          .= Exec (CurInstr Cs1i, Cs1i) by AMI_1:def 18;
A25: Cs2k = Following Cs2i by AMI_1:def 19
          .= Exec (CurInstr Cs2i, Cs2i) by AMI_1:def 18;

      A26:   Cs1i.loc = goto loc & Cs2i.loc = goto loc1 by A23,AMI_1:54;
A27:  (Cs1i|dom p) = (Csi|dom p) by A2,A19,AMI_1:def 25;
A28: Cs1i.IC SCM R = (Cs1i|dom p).IC SCM R &
     Csi.IC SCM R = (Csi|dom p).IC SCM R by A15,FUNCT_1:72;
    (Cs1i|dom p) = (Cs2i|dom p) by A19,A22,AMI_1:def 25;
 then A29:   Cs1i.IC SCM R = loc & Cs2i.IC SCM R = loc by A5,A15,A27,A28,
FUNCT_1:72;
     IC Cs1i = Cs1i.IC SCM R & IC Cs2i = Cs2i.IC SCM R by AMI_1:def 15;
 then CurInstr Cs1i = goto loc & CurInstr Cs2i = goto loc1 by A26,A29,
AMI_1:def 17;
then A30:   Cs1k.IC SCM R = loc & Cs2k.IC SCM R = loc1 by A24,A25,SCMRING2:17;
       (Cs1k|dom p).IC SCM R = Cs1k.IC SCM R &
     (Cs2k|dom p).IC SCM R = Cs2k.IC SCM R by A15,FUNCT_1:72;
   hence Cs1k|dom p <> Cs2k|dom p by A4,A30;
  end;
 hence contradiction;
end;

theorem Th41:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
   st p c= s1 & p c= s2 holds
  IC (Computation s1).n = IC (Computation s2).n &
  CurInstr ((Computation s1).n) = CurInstr ((Computation s2).n)
  proof
    assume
A1:   R is non trivial;
    let p be autonomic non programmed FinPartState of SCM R such that
A2:   p c= s1 & p c= s2;
    set Cs1i = (Computation s1).n;
    set Cs2i = (Computation s2).n;
A3: IC SCM R in dom p by A1,Th38;
    thus
A4:   IC Cs1i = IC Cs2i
    proof
      assume
A5:     IC Cs1i <> IC Cs2i;
A6:   IC Cs1i = Cs1i.IC SCM R & IC Cs2i = Cs2i.IC SCM R by AMI_1:def 15;
       (Cs1i|dom p).IC SCM R = Cs1i.IC SCM R &
      (Cs2i|dom p).IC SCM R = Cs2i.IC SCM R by A3,FUNCT_1:72;
      hence contradiction by A2,A5,A6,AMI_1:def 25;
    end;
    assume
A7:   not thesis;
A8: Cs1i.IC Cs1i = CurInstr ((Computation s1).n) &
    Cs2i.IC Cs2i = CurInstr Cs2i by AMI_1:def 17;
A9: IC Cs1i in dom ProgramPart p & IC Cs2i in dom ProgramPart p by A1,A2,Th40;
     ProgramPart p c= p by AMI_5:63;
    then dom ProgramPart p c= dom p by GRFUNC_1:8;
    then (Cs1i|dom p).IC Cs1i = Cs1i.IC Cs1i &
         (Cs2i|dom p).IC Cs2i = Cs2i.IC Cs2i by A9,FUNCT_1:72;
    hence contradiction by A2,A4,A7,A8,AMI_1:def 25;
  end;

theorem Th42:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
   st p c= s1 & p c= s2 & CurInstr ((Computation s1).n) = a := b & a in dom p
  holds (Computation s1).n.b = (Computation s2).n.b
  proof
    assume
A1:   R is non trivial;
    let p be autonomic non programmed FinPartState of SCM R such that
A2:   p c= s1 & p c= s2;
    set I = CurInstr ((Computation s1).n);
    set Cs1i = (Computation s1).n;
    set Cs2i = (Computation s2).n;
A3: I = CurInstr ((Computation s2).n) by A1,A2,Th41;
    set Cs1i1 = (Computation s1).(n+1);
    set Cs2i1 = (Computation s2).(n+1);
A4: Cs1i1 = Following Cs1i by AMI_1:def 19
         .= Exec (CurInstr Cs1i, Cs1i) by AMI_1:def 18;
A5: Cs2i1 = Following Cs2i by AMI_1:def 19
         .= Exec (CurInstr Cs2i, Cs2i) by AMI_1:def 18;
A6: a in dom p implies (Cs1i1|dom p).a = Cs1i1.a & (Cs2i1|dom p).a = Cs2i1.a
      by FUNCT_1:72;
    assume
A7:   I = a := b & a in dom p & (Computation s1).n.b <> (Computation s2).n.b;
    then Cs1i1.a = Cs1i.b & Cs2i1.a = Cs2i.b by A3,A4,A5,SCMRING2:13;
    hence contradiction by A2,A6,A7,AMI_1:def 25;
  end;

theorem Th43:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
   st p c= s1 & p c= s2 &
      CurInstr ((Computation s1).n) = AddTo(a,b) & a in dom p
  holds (Computation s1).n.a + (Computation s1).n.b
      = (Computation s2).n.a + (Computation s2).n.b
  proof
    assume
A1:   R is non trivial;
    let p be autonomic non programmed FinPartState of SCM R such that
A2:   p c= s1 & p c= s2;
    set I = CurInstr ((Computation s1).n);
    set Cs1i = (Computation s1).n;
    set Cs2i = (Computation s2).n;
A3: I = CurInstr ((Computation s2).n) by A1,A2,Th41;
    set Cs1i1 = (Computation s1).(n+1);
    set Cs2i1 = (Computation s2).(n+1);
A4: Cs1i1 = Following Cs1i by AMI_1:def 19
         .= Exec (CurInstr Cs1i, Cs1i) by AMI_1:def 18;
A5: Cs2i1 = Following Cs2i by AMI_1:def 19
         .= Exec (CurInstr Cs2i, Cs2i) by AMI_1:def 18;
A6: a in dom p implies (Cs1i1|dom p).a = Cs1i1.a & (Cs2i1|dom p).a = Cs2i1.a
      by FUNCT_1:72;
    assume
A7:   I = AddTo(a,b) & a in dom p &
      (Computation s1).n.a + (Computation s1).n.b
       <> (Computation s2).n.a + (Computation s2).n.b;
    then Cs1i1.a = Cs1i.a + Cs1i.b & Cs2i1.a = Cs2i.a + Cs2i.b
         by A3,A4,A5,SCMRING2:14;
    hence contradiction by A2,A6,A7,AMI_1:def 25;
  end;

theorem Th44:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
   st p c= s1 & p c= s2 &
      CurInstr ((Computation s1).n) = SubFrom(a, b) & a in dom p
  holds (Computation s1).n.a - (Computation s1).n.b
      = (Computation s2).n.a - (Computation s2).n.b
  proof
    assume
A1:   R is non trivial;
    let p be autonomic non programmed FinPartState of SCM R such that
A2:   p c= s1 & p c= s2;
    set I = CurInstr ((Computation s1).n);
    set Cs1i = (Computation s1).n;
    set Cs2i = (Computation s2).n;
A3: I = CurInstr ((Computation s2).n) by A1,A2,Th41;
    set Cs1i1 = (Computation s1).(n+1);
    set Cs2i1 = (Computation s2).(n+1);
A4: Cs1i1 = Following Cs1i by AMI_1:def 19
         .= Exec (CurInstr Cs1i, Cs1i) by AMI_1:def 18;
A5: Cs2i1 = Following Cs2i by AMI_1:def 19
         .= Exec (CurInstr Cs2i, Cs2i) by AMI_1:def 18;
A6: a in dom p implies (Cs1i1|dom p).a = Cs1i1.a & (Cs2i1|dom p).a = Cs2i1.a
     by FUNCT_1:72;
    assume
A7:   I = SubFrom(a,b) & a in dom p &
      (Computation s1).n.a - (Computation s1).n.b
       <> (Computation s2).n.a - (Computation s2).n.b;
    then Cs1i1.a = Cs1i.a - Cs1i.b & Cs2i1.a = Cs2i.a - Cs2i.b
         by A3,A4,A5,SCMRING2:15;
    hence contradiction by A2,A6,A7,AMI_1:def 25;
  end;

theorem Th45:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
   st p c= s1 & p c= s2 &
      CurInstr ((Computation s1).n) = MultBy(a, b) & a in dom p
  holds (Computation s1).n.a * (Computation s1).n.b
      = (Computation s2).n.a * (Computation s2).n.b
  proof
    assume
A1:   R is non trivial;
    let p be autonomic non programmed FinPartState of SCM R such that
A2:   p c= s1 & p c= s2;
    set I = CurInstr ((Computation s1).n);
    set Cs1i = (Computation s1).n;
    set Cs2i = (Computation s2).n;
A3: I = CurInstr ((Computation s2).n) by A1,A2,Th41;
    set Cs1i1 = (Computation s1).(n+1);
    set Cs2i1 = (Computation s2).(n+1);
A4: Cs1i1 = Following Cs1i by AMI_1:def 19
         .= Exec (CurInstr Cs1i, Cs1i) by AMI_1:def 18;
A5: Cs2i1 = Following Cs2i by AMI_1:def 19
         .= Exec (CurInstr Cs2i, Cs2i) by AMI_1:def 18;
A6: a in dom p implies (Cs1i1|dom p).a = Cs1i1.a & (Cs2i1|dom p).a = Cs2i1.a
     by FUNCT_1:72;
    assume
A7:   I = MultBy(a,b) & a in dom p &
      (Computation s1).n.a * (Computation s1).n.b
       <> (Computation s2).n.a * (Computation s2).n.b;
    then Cs1i1.a = Cs1i.a * Cs1i.b & Cs2i1.a = Cs2i.a * Cs2i.b
         by A3,A4,A5,SCMRING2:16;
    hence contradiction by A2,A6,A7,AMI_1:def 25;
  end;

theorem Th46:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
   st p c= s1 & p c= s2 &
      CurInstr ((Computation s1).n) = a=0_goto loc &
      loc <> Next (IC (Computation s1).n) holds
  (Computation s1).n.a = 0.R iff (Computation s2).n.a = 0.R
  proof
    assume
A1:   R is non trivial;
    let p be autonomic non programmed FinPartState of SCM R such that
A2:   p c= s1 & p c= s2;
    set I = CurInstr ((Computation s1).n);
    set Cs1i = (Computation s1).n;
    set Cs2i = (Computation s2).n;
A3: IC SCM R in dom p by A1,Th38;
A4: IC Cs1i = IC Cs2i by A1,A2,Th41;
A5: I = CurInstr ((Computation s2).n) by A1,A2,Th41;
    set Cs1i1 = (Computation s1).(n+1);
    set Cs2i1 = (Computation s2).(n+1);
A6: Cs1i1 = Following Cs1i by AMI_1:def 19
         .= Exec (CurInstr Cs1i, Cs1i) by AMI_1:def 18;
A7: Cs2i1 = Following Cs2i by AMI_1:def 19
         .= Exec (CurInstr Cs2i, Cs2i) by AMI_1:def 18;
A8: (Cs1i1|dom p).IC SCM R = Cs1i1.IC SCM R &
     (Cs2i1|dom p).IC SCM R = Cs2i1.IC SCM R by A3,FUNCT_1:72;
    assume
A9: I = a=0_goto loc & loc <> Next (IC (Computation s1).n);
    hereby
      assume (Computation s1).n.a = 0.R & (Computation s2).n.a <> 0.R;
      then Cs1i1.IC SCM R = loc & Cs2i1.IC SCM R = Next IC Cs2i
           by A5,A6,A7,A9,SCMRING2:18;
      hence contradiction by A2,A4,A8,A9,AMI_1:def 25;
    end;
    assume (Computation s2).n.a = 0.R & (Computation s1).n.a <> 0.R;
    then Cs2i1.IC SCM R = loc & Cs1i1.IC SCM R = Next IC Cs1i
     by A5,A6,A7,A9,SCMRING2:18;
    hence contradiction by A2,A8,A9,AMI_1:def 25;
  end;

begin :: Relocability

definition
  let N be with_non-empty_elements set,
      S be regular standard (IC-Ins-separated definite
           (non empty non void AMI-Struct over N)),
      k be natural number,
      p be FinPartState of S;
 func Relocated (p,k) -> FinPartState of S equals :Def2:
  Start-At ((IC p)+k) +* IncAddr(Shift(ProgramPart(p),k),k) +* DataPart p;
coherence;
end;

reserve
  S for regular standard (IC-Ins-separated definite
              (non empty non void AMI-Struct over N)),
  g for FinPartState of S,
  il for Instruction-Location of S;

theorem Th47:
  DataPart(Relocated(g,k)) = DataPart(g)
  proof
    set I = the Instruction-Locations of S;
    set B = (the carrier of S) \ ({IC S} \/ I);
    set X = (Start-At ((IC g)+k)) | B;
    consider x being Element of dom X;
      now
      assume dom X <> {};
      then x in dom X;
      then A1:   x in dom (Start-At ((IC g)+k)) /\ B by FUNCT_1:68;
      then x in B by XBOOLE_0:def 3;
      then A2:   not x in {IC S} \/ I by XBOOLE_0:def 4;
       x in dom (Start-At ((IC g)+k)) by A1,XBOOLE_0:def 3;
      then x in {IC S} by AMI_3:34;
      hence contradiction by A2,XBOOLE_0:def 2;
    end;
    then (Start-At ((IC g)+k)) | B is Function of {},{} by FUNCT_2:55;
    then A3: (Start-At ((IC g)+k)) | B = {} by PARTFUN1:57;
A4: dom IncAddr(Shift(ProgramPart(g),k),k)
      c= the Instruction-Locations of S by AMI_3:def 13;
A5: dom DataPart g c= B by Th7;
A6: B misses I by Lm3;
    thus DataPart(Relocated(g,k))
      = Relocated(g,k)| B by AMI_5:def 7
     .= (Start-At ((IC g)+k)+* IncAddr(Shift(ProgramPart(g),k),k)+*DataPart g)
        | B by Def2
     .=(Start-At ((IC g)+k)+* (IncAddr(Shift(ProgramPart(g),k),k)+*DataPart g))
        | B by FUNCT_4:15
     .= ((Start-At ((IC g)+k)) | B) +*
      (IncAddr(Shift(ProgramPart(g),k),k)+*DataPart g)| B by FUNCT_4:75
     .= (IncAddr(Shift(ProgramPart(g),k),k)+*DataPart g)
        | B by A3,FUNCT_4:21
     .= DataPart g by A4,A5,A6,FUNCT_4:81;
  end;

theorem Th48:
  S is realistic implies
  ProgramPart(Relocated(g,k)) = IncAddr(Shift(ProgramPart(g),k),k)
  proof
    assume
A1:   S is realistic;
    set I = the Instruction-Locations of S;
    set B = (the carrier of S) \ ({IC S} \/ I);
    set X = (Start-At ((IC g)+k)) | I;
    set f = IncAddr(Shift(ProgramPart(g),k),k);
    consider x being Element of dom X;
     now
      assume dom X <> {};
      then x in dom X;
      then A2:   x in dom (Start-At ((IC g)+k)) /\ I by FUNCT_1:68;
      then A3:   x in I by XBOOLE_0:def 3;
       x in dom (Start-At ((IC g)+k)) by A2,XBOOLE_0:def 3;
      then x in {IC S} by AMI_3:34;
      then x = IC S by TARSKI:def 1;
      hence contradiction by A1,A3,AMI_1:48;
    end;
    then X is Function of {},{} by FUNCT_2:55;
    then A4: X = {} by PARTFUN1:57;
A5: dom f c= I by AMI_3:def 13;
A6: dom DataPart g c= B by Th7;
A7: I misses B by Lm3;
    thus ProgramPart(Relocated(g,k))
     = Relocated(g,k)| I by AMI_5:def 6
    .= (Start-At ((IC g)+k)+* f +*DataPart g) | I by Def2
    .= (Start-At ((IC g)+k)+* (f+*DataPart g)) | I by FUNCT_4:15
    .= ((Start-At ((IC g)+k)) | I) +* ((f+*DataPart g)| I) by FUNCT_4:75
    .= (f+*DataPart g) | I by A4,FUNCT_4:21
    .= f by A5,A6,A7,FUNCT_4:81;
  end;

theorem Th49:
  S is realistic implies
  dom ProgramPart(Relocated(g,k))
     = { il.(S,j+k) where j is Nat : il.(S,j) in dom ProgramPart(g) }
  proof
    assume
   S is realistic;
    hence dom ProgramPart(Relocated(g,k))
          = dom IncAddr(Shift(ProgramPart(g),k),k) by Th48
         .= dom Shift(ProgramPart(g),k) by AMISTD_2:def 15
         .= { il.(S,j+k) where j is Nat:
          il.(S,j) in dom ProgramPart(g) } by AMISTD_2:def 16;
  end;

theorem Th50:
  S is realistic implies
  (il in dom g iff il+k in dom Relocated(g,k))
  proof
    assume
A1:   S is realistic;
    consider m being natural number such that
A2:   il = il.(S,m) by AMISTD_1:26;
A3: il + k = il.(S,m+k) by A2,Th2;
A4: dom ProgramPart(Relocated(g,k))
       = { il.(S,j+k) where j is Nat: il.(S,j) in dom ProgramPart(g) }
         by A1,Th49;
     ProgramPart(Relocated(g,k)) c= Relocated(g,k) by AMI_5:63;
    then A5: dom ProgramPart(Relocated(g,k)) c= dom Relocated(g,k) by
GRFUNC_1:8;
A6: m is Nat by ORDINAL2:def 21;
    hereby
      assume il in dom g;
      then il.(S,m) in dom ProgramPart g by A2,AMI_5:73;
      then il + k in dom ProgramPart(Relocated(g,k)) by A3,A4,A6;
      hence il + k in dom Relocated(g,k) by A5;
    end;
    assume il + k in dom Relocated(g,k);
    then il + k in dom ProgramPart(Relocated(g,k)) by AMI_5:73;
    then consider j being Nat such that
A7:   il + k = il.(S,j+k) and
A8:   il.(S,j) in dom ProgramPart g by A4;
     ProgramPart g c= g by AMI_5:63;
    then A9: dom ProgramPart g c= dom g by GRFUNC_1:8;
     m+k = j+k by A3,A7,AMISTD_1:25;
    then il in dom ProgramPart g by A2,A8,XCMPLX_1:2;
    hence il in dom g by A9;
  end;

theorem Th51:
  IC S in dom Relocated (g,k)
  proof
A1: Relocated (g,k)
     = Start-At ((IC g)+k) +* IncAddr(Shift(ProgramPart(g),k),k)+*DataPart g
       by Def2
    .= Start-At ((IC g)+k) +* (IncAddr(Shift(ProgramPart(g),k),k)+*DataPart g)
       by FUNCT_4:15;
     dom(Start-At((IC g)+k)) = {IC S} by AMI_3:34;
    then IC S in dom (Start-At((IC g)+k)) by TARSKI:def 1;
    hence IC S in dom Relocated (g,k) by A1,FUNCT_4:13;
  end;

theorem Th52:
  S is realistic implies
  IC Relocated (g,k) = (IC g) + k
  proof
    assume
A1:   S is realistic;
A2: Relocated (g,k) = Start-At ((IC g)+k)
      +* IncAddr(Shift(ProgramPart(g),k),k)+*DataPart g by Def2
    .= Start-At ((IC g)+k)
      +* (IncAddr(Shift(ProgramPart(g),k),k)+*DataPart g) by FUNCT_4:15;
A3: Start-At ((IC g)+k) = IC S .--> ((IC g)+k) by AMI_3:def 12;
      ProgramPart(Relocated(g,k)) = IncAddr(Shift(ProgramPart(g),k),k)
      by A1,Th48;
    then not IC S in dom(IncAddr(Shift(ProgramPart(g),k),k)) &
    not IC S in dom(DataPart g) by A1,AMI_5:65,66;
    then A4: not IC S in dom(IncAddr(Shift(ProgramPart(g),k),k)+*DataPart g)
      by FUNCT_4:13;
     IC S in dom Relocated (g,k) by Th51;
    hence IC Relocated (g,k) = Relocated (g,k).IC S by AMI_3:def 16
                .= (Start-At ((IC g)+k)).IC S by A2,A4,FUNCT_4:12
                .= (IC g) +k by A3,CQC_LANG:6;
  end;

theorem Th53:
  for p being programmed FinPartState of S,
      l being Instruction-Location of S st l in dom p holds
   IncAddr(p,k).l = IncAddr(pi(p,l),k)
  proof
    let p be programmed FinPartState of S,
        l be Instruction-Location of S such that
A1:   l in dom p;
     ex m being natural number st l = il.(S,m) by AMISTD_1:26;
    hence IncAddr (p,k).l = IncAddr(pi(p,l),k) by A1,AMISTD_2:def 15;
  end;

theorem Th54:
  for p being programmed FinPartState of S holds
   Shift(IncAddr(p,i),i) = IncAddr(Shift(p,i),i)
  proof
    let p be programmed FinPartState of S;
    set f = Shift(IncAddr(p,i),i);
    set g = IncAddr(Shift(p,i),i);
     dom(IncAddr(p,i)) = dom p by AMISTD_2:def 15;
    then dom(Shift(p,i)) = { il.(S,m+i) where m is Nat:
      il.(S,m) in dom (IncAddr(p,i)) } by AMISTD_2:def 16
      .= dom f by AMISTD_2:def 16;
    then A1: dom f = dom g by AMISTD_2:def 15;
     now
      let x be set;
A2:   dom f c= the Instruction-Locations of S by AMI_3:def 13;
      assume
A3:     x in dom f;
      then reconsider x'=x as Instruction-Location of S by A2;
        x in { il.(S,m+i) where m is Nat:il.(S,m) in dom IncAddr(p,i) }
       by A3,AMISTD_2:def 16;
      then consider m being Nat such that
A4:     x = il.(S,m+i) & il.(S,m) in dom IncAddr(p,i);
A5:   x = il.(S,m) + i by A4,Th2;
A6:   il.(S,m) in dom p by A4,AMISTD_2:def 15;
       dom Shift(p,i) = { il.(S,mm+i) where mm is Nat :
        il.(S,mm) in dom p} by AMISTD_2:def 16;
      then A7:   x' in dom Shift(p,i) by A4,A6;
A8:   pi(p,il.(S,m)) = p.(il.(S,m)) by A6,AMI_5:def 5
                    .= Shift(p,i).(il.(S,m)+i) by A6,Th11
                    .= Shift(p,i).(il.(S,m+i)) by Th2
                    .= pi(Shift(p,i),x') by A4,A7,AMI_5:def 5;
      thus f.x = IncAddr(p,i).(il.(S,m)) by A4,A5,Th11
              .= IncAddr(pi(Shift(p,i),x'),i) by A6,A8,Th53
              .= g.x by A7,Th53;
    end;
    hence thesis by A1,FUNCT_1:9;
  end;

theorem Th55:
  S is realistic implies
  for I being Instruction of S holds
  il in dom ProgramPart g & I = g.il implies
   IncAddr(I, k) = (Relocated (g, k)).(il + k)
  proof
    assume
A1:   S is realistic;
    let I be Instruction of S;
    assume
A2:   il in dom ProgramPart g & I = g.il;
A3: ProgramPart g c= g by AMI_5:63;
    consider i being natural number such that
A4:   il = il.(S,i) by AMISTD_1:26;
     i is Nat by ORDINAL2:def 21;
    then il.(S,i+k) in { il.(S,j+k) where j is Nat:
       il.(S,j) in dom ProgramPart(g) } by A2,A4;
    then il.(S,i+k) in dom ProgramPart(Relocated(g,k)) by A1,Th49;
    then A5: il + k in dom ProgramPart(Relocated(g,k)) by A4,Th2;
A6: il in dom IncAddr(ProgramPart(g),k) by A2,AMISTD_2:def 15;
A7: I = (ProgramPart g).il by A2,A3,GRFUNC_1:8;
     ProgramPart (Relocated(g, k)) c= (Relocated(g, k)) by AMI_5:63;
    hence (Relocated(g, k)).(il+k)
      = (ProgramPart(Relocated(g, k))).(il+k) by A5,GRFUNC_1:8
     .= (IncAddr(Shift(ProgramPart(g),k),k)).(il+k) by A1,Th48
     .= (Shift(IncAddr(ProgramPart(g),k),k)).(il+k) by Th54
     .= (IncAddr(ProgramPart(g),k)).il by A6,Th11
     .= IncAddr(pi(ProgramPart(g), il),k) by A2,Th53
     .= IncAddr(I,k) by A2,A7,AMI_5:def 5;
  end;

theorem Th56:
  S is realistic implies
  Start-At (IC g + k) c= Relocated (g,k)
  proof
    assume
A1:   S is realistic;
    let x be set;
A2: Start-At (IC g + k) = {[IC S,IC g + k]} by AMI_5:35;
A3: IC S in dom (Relocated(g,k)) by Th51;
A4: IC Relocated(g,k) = IC g + k by A1,Th52;
     IC Relocated(g,k) = Relocated(g,k).IC S by A3,AMI_3:def 16;
    then [IC S,IC g + k] in Relocated(g,k) by A3,A4,FUNCT_1:def 4;
    hence thesis by A2,TARSKI:def 1;
  end;

theorem Th57:
  S is realistic implies
  for q being data-only FinPartState of S st IC S in dom g holds
   Relocated((g +* q), k) = Relocated (g,k) +* q
  proof
    assume
A1:   S is realistic;
    let q be data-only FinPartState of S;
    assume
A2:   IC S in dom g;
    then A3: IC S in dom g \/ dom q by XBOOLE_0:def 2;
    set I = the Instruction-Locations of S;
    set B = (the carrier of S) \ ({IC S} \/ I);
A4: dom q c= B by A1,Th8;
    then A5: not IC S in dom q by Lm2;
     IC S in dom (g +* q) by A3,FUNCT_4:def 1;
    then A6: IC (g +* q) = (g +* q).IC S by AMI_3:def 16
               .= g.IC S by A3,A5,FUNCT_4:def 1
               .= IC g by A2,AMI_3:def 16;
     I misses B by Lm3;
    then A7: dom q misses I by A4,XBOOLE_1:63;
A8: ProgramPart (g +* q)
     = (g +* q) | I by AMI_5:def 6
    .= g | I by A7,FUNCT_4:76
    .= ProgramPart g by AMI_5:def 6;
A9: DataPart (g +* q)
     = (g +* q) | B by AMI_5:def 7
    .= g | B +* q | B by FUNCT_4:75
    .= DataPart g +* q | B by AMI_5:def 7
    .= DataPart g +* q by A4,RELAT_1:97;
    set P = Start-At((IC(g+*q))+k)+*IncAddr(Shift(ProgramPart(g+*q),k),k);
    thus Relocated((g +* q), k)
          = P +* (DataPart g +* q) by A9,Def2
         .= P +* DataPart g +* q by FUNCT_4:15
         .= Relocated(g,k) +* q by A6,A8,Def2;
  end;

theorem Th58:
  for p being autonomic FinPartState of SCM R
   st p c= s1 & Relocated (p,k) c= s2 holds
  p c= s1 +* s2|SCM-Data-Loc
  proof
    let p be autonomic FinPartState of SCM R such that
A1:   p c= s1 & Relocated (p,k) c= s2;
    reconsider s = s1 +* s2|SCM-Data-Loc as State of SCM R by AMI_5:82;
    set s3 = s2|SCM-Data-Loc;
A2: dom p c= the carrier of SCM R by AMI_3:37;
then A3: dom p c= {IC SCM R} \/ SCM-Data-Loc \/ SCM-Instr-Loc by Th14;
A4: dom p c= dom s by A2,AMI_3:36;
      now
      let x be set such that
A5:     x in dom p;
        dom s2 = the carrier of SCM R by AMI_3:36
             .= NAT by SCMRING2:def 1;
then A6:   SCM-Data-Loc = dom s2 /\ SCM-Data-Loc by XBOOLE_1:28;
A7:   x in {IC SCM R} \/ SCM-Data-Loc or x in SCM-Instr-Loc
        by A3,A5,XBOOLE_0:def 2;
      per cases by A7,XBOOLE_0:def 2;
      suppose
          x in {IC SCM R};
then A8:     x = IC SCM R by TARSKI:def 1;
        not IC SCM R in SCM-Data-Loc
       proof
        assume not thesis;
        then IC SCM R is Data-Location of R by SCMRING2:1;
        hence contradiction by SCMRING3:3;
       end;
then not IC SCM R in dom s3 by A6,FUNCT_1:68;
      then s1.x = s.x by A8,FUNCT_4:12;
      hence p.x = s.x by A1,A5,GRFUNC_1:8;
      end;
      suppose
A9:     x in SCM-Data-Loc;
      set DPp = DataPart p;
      set DPRp = DataPart Relocated (p, k);
A10:   DPp = p|SCM-Data-Loc by Th24;
        x in dom p /\ SCM-Data-Loc by A5,A9,XBOOLE_0:def 3;
then A11:  x in dom DPp by A10,FUNCT_1:68;
        DPp c= p by AMI_5:62;
then A12:  DPp.x = p.x by A11,GRFUNC_1:8;
        DPp = DPRp by Th47;
      then DPp c= Relocated (p, k) by AMI_5:62;
then A13:  DPp c= s2 by A1,XBOOLE_1:1;
then A14:  DPp.x = s2.x by A11,GRFUNC_1:8;
A15:   dom DPp c= dom s2 by A13,GRFUNC_1:8;
A16:  s2.x = s3.x by A9,FUNCT_1:72;
        x in dom s2 /\ SCM-Data-Loc by A9,A11,A15,XBOOLE_0:def 3;
      then x in dom s3 by FUNCT_1:68;
      hence p.x = s.x by A12,A14,A16,FUNCT_4:14;
      end;

      suppose
A17:    x in SCM-Instr-Loc;
        now
        assume x in dom s3;
        then x in dom s2 /\ SCM-Data-Loc by FUNCT_1:68;
        then x in SCM-Data-Loc by XBOOLE_0:def 3;
        hence contradiction by A17,AMI_5:33,XBOOLE_0:3;
      end;
      then s1.x = s.x by FUNCT_4:12;
      hence p.x = s.x by A1,A5,GRFUNC_1:8;
    end;
    end;
    hence p c= s1 +* s2|SCM-Data-Loc by A4,GRFUNC_1:8;
  end;

theorem Th59:
  R is non trivial implies
  for p being autonomic FinPartState of SCM R
    st IC SCM R in dom p & p c= s1 & Relocated (p,k) c= s2 &
       s = s1 +* s2|SCM-Data-Loc
    holds for i being Nat holds
     IC (Computation s1).i + k = IC (Computation s2).i &
     IncAddr(CurInstr((Computation s1).i), k) = CurInstr((Computation s2).i) &
     (Computation s1).i|dom (DataPart p)
          = (Computation s2).i|dom (DataPart (Relocated (p,k))) &
     (Computation s).i|SCM-Data-Loc = (Computation s2).i|SCM-Data-Loc
 proof
  assume A1: R is non trivial;
  let p be autonomic FinPartState of SCM R such that
A2:   IC SCM R in dom p and
A3:   p c= s1 and
A4:   Relocated (p,k) c= s2 and
A5:   s = s1 +* s2|SCM-Data-Loc;
A6:   IC SCM R in dom Relocated(p,k) by Th51;
A7:   DataPart p = DataPart (Relocated (p,k)) by Th47;
        DataPart p c= p by AMI_5:62;
then A8:   DataPart p c= s1 by A3,XBOOLE_1:1;
        DataPart (Relocated(p,k)) c= Relocated(p,k) by AMI_5:62;
then A9:   DataPart (Relocated(p,k)) c= s2 by A4,XBOOLE_1:1;
A10:   p is non programmed by A2,AMI_5:76;
A11:   p c= s by A3,A4,A5,Th58;
defpred P[Nat] means
  IC (Computation s1).$1 + k = IC (Computation s2).$1 &
  IncAddr(CurInstr((Computation s1).$1), k) = CurInstr((Computation s2).$1) &
  (Computation s1).$1|dom (DataPart p)
          = (Computation s2).$1|dom (DataPart (Relocated (p,k))) &
     (Computation s).$1|SCM-Data-Loc = (Computation s2).$1|SCM-Data-Loc;
A12:P[0]
    proof
    thus IC (Computation s1).0 + k
         = IC s1 + k by AMI_1:def 19
        .= IC p + k by A2,A3,AMI_5:60
        .= IC Relocated(p,k) by Th52
        .= IC s2 by A4,A6,AMI_5:60
        .= IC (Computation s2).0 by AMI_1:def 19;
A13: IC p = IC s1 by A2,A3,AMI_5:60;
    then IC p = IC (Computation s1).0 by AMI_1:def 19;
then A14: IC p in dom ProgramPart p by A1,A3,A10,Th40;
      ProgramPart p c= p by AMI_5:63;
then A15: dom ProgramPart p c= dom p by GRFUNC_1:8;
    then p.IC p = pi(p,IC p) by A14,AMI_5:def 5;
    then reconsider I = p.IC p as Instruction of SCM R;
A16: p.IC p = s1.IC s1 by A3,A13,A14,A15,GRFUNC_1:8;
A17: IncAddr(CurInstr((Computation s1).0), k)
    = IncAddr(CurInstr(s1), k) by AMI_1:def 19
   .= IncAddr(s1.IC s1, k) by AMI_1:def 17;
A18: IC SCM R in dom Relocated (p, k) by Th51;
A19: (IC p) + k in dom Relocated(p,k) by A14,A15,Th50;
   CurInstr((Computation s2).0)
    = CurInstr(s2) by AMI_1:def 19
   .= s2.IC s2 by AMI_1:def 17
   .= s2.(IC Relocated (p, k)) by A4,A18,AMI_5:60
   .= s2.((IC p) + k) by Th52
   .= (Relocated(p,k)).((IC p) + k) by A4,A19,GRFUNC_1:8;
    hence IncAddr(CurInstr((Computation s1).0), k)
       = CurInstr((Computation s2).0) by A14,A16,A17,Th55;
    thus (Computation s1).0|dom (DataPart p)
         = s1 | dom (DataPart p) by AMI_1:def 19
        .= DataPart p by A8,GRFUNC_1:64
        .= s2 | dom (DataPart p) by A7,A9,GRFUNC_1:64
        .= (Computation s2).0|dom (DataPart (Relocated (p,k)))
        by A7,AMI_1:def 19;
A20: dom (s2|SCM-Data-Loc) = SCM-Data-Loc by Th22;
    thus (Computation s).0|SCM-Data-Loc
          = (s1 +* s2|SCM-Data-Loc)|SCM-Data-Loc by A5,AMI_1:def 19
         .= s2|SCM-Data-Loc by A20,FUNCT_4:24
         .= (Computation s2).0|SCM-Data-Loc by AMI_1:def 19;
    end;
A21: for i being Nat st P[i] holds P[i+1]
     proof let i be Nat such that
A22: IC (Computation s1).i + k = IC (Computation s2).i and
A23: IncAddr(CurInstr((Computation s1).i), k) = CurInstr((Computation s2).i)
     and
A24: (Computation s1).i|dom (DataPart p)
        = (Computation s2).i|dom (DataPart (Relocated (p,k))) and
A25: (Computation s).i|SCM-Data-Loc = (Computation s2).i|SCM-Data-Loc;

 set Cs1i = (Computation s1).i;
 set Cs2i = (Computation s2).i;
 set Cs3i = (Computation s).i;
 set Cs1i1 = (Computation s1).(i+1);
 set Cs2i1 = (Computation s2).(i+1);
 set Cs3i1 = (Computation s).(i+1);
 set DPp = DataPart p;
A26: dom DataPart p = dom DataPart(Relocated (p, k)) by Th47;
      dom Cs1i1 = the carrier of SCM R by AMI_3:36;
then A27: dom Cs1i1 = {IC SCM R} \/ SCM-Data-Loc \/ SCM-Instr-Loc by Th14;
      dom Cs2i1 = the carrier of SCM R by AMI_3:36;
then A28:dom Cs2i1 = {IC SCM R} \/ SCM-Data-Loc \/ SCM-Instr-Loc by Th14;
      dom Cs1i = the carrier of SCM R by AMI_3:36;
then A29: dom Cs1i = {IC SCM R} \/ SCM-Data-Loc \/ SCM-Instr-Loc by Th14;
      dom Cs2i = the carrier of SCM R by AMI_3:36;
then A30:dom Cs2i = {IC SCM R} \/ SCM-Data-Loc \/ SCM-Instr-Loc by Th14;
       DPp = p | SCM-Data-Loc by Th24;
     then dom DPp = dom p /\ SCM-Data-Loc by FUNCT_1:68;
     then dom DPp c= SCM-Data-Loc by XBOOLE_1:17;
then A31:  dom DPp c= {IC SCM R} \/ SCM-Data-Loc by XBOOLE_1:10;
then A32:  dom DPp c= dom Cs1i1 by A27,XBOOLE_1:10;
A33: dom DPp c= dom Cs2i1 by A28,A31,XBOOLE_1:10;
A34: dom (Cs1i1|dom DPp) = dom Cs1i1 /\ dom DPp by FUNCT_1:68
                          .= dom DPp by A32,XBOOLE_1:28;
A35: dom (Cs2i1|dom DataPart(Relocated(p, k)))
             = dom Cs2i1 /\ dom DPp by A26,FUNCT_1:68
            .= dom DPp by A33,XBOOLE_1:28;
A36: dom DPp c= dom Cs1i by A29,A31,XBOOLE_1:10;
A37: dom DPp c= dom Cs2i by A30,A31,XBOOLE_1:10;
A38: dom (Cs1i|dom DPp) = dom Cs1i /\ dom DPp by FUNCT_1:68
                       .= dom DPp by A36,XBOOLE_1:28;
A39: dom (Cs2i|dom DataPart(Relocated(p, k)))
             = dom Cs2i /\ dom DPp by A26,FUNCT_1:68
            .= dom DPp by A37,XBOOLE_1:28;
A40: dom (Cs3i|SCM-Data-Loc) = SCM-Data-Loc by Th22;
A41: dom (Cs2i|SCM-Data-Loc) = SCM-Data-Loc by Th22;
A42: dom (Cs3i1|SCM-Data-Loc) = SCM-Data-Loc by Th22;
A43: dom (Cs2i1|SCM-Data-Loc) = SCM-Data-Loc by Th22;
A44: dom (Cs1i1|dom DPp)c=dom (Cs2i1|dom DPp) by A34,A35,Th47;
A45: dom(Cs3i1|SCM-Data-Loc) c= dom(Cs2i1|SCM-Data-Loc) by A42,Th22;
A46: now
       let s be State of SCM R,
           d be Data-Location of R;
         d in SCM-Data-Loc by SCMRING2:1;
       hence d in dom (s|SCM-Data-Loc) by Th22;
     end;
A47: now
       let d be Data-Location of R;
A48:   d in dom (Cs3i|SCM-Data-Loc) & d in dom (Cs3i|SCM-Data-Loc) by A46;
       hence Cs3i.d = (Cs3i|SCM-Data-Loc).d by FUNCT_1:70
                   .= Cs2i.d by A25,A48,FUNCT_1:70;
     end;
A49: now let x be set, d be Data-Location of R such that
A50: d = x & d in dom DPp and
A51:  Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d;
A52:  (Cs1i|dom DPp).d = Cs1i.d & (Cs2i|dom DPp).d = Cs2i.d
 by A26,A38,A39,A50,FUNCT_1:70;
    thus (Cs1i1|dom DPp).x
        = Cs1i1.d by A34,A50,FUNCT_1:70
       .= (Cs2i1|dom DPp).x by A24,A26,A35,A50,A51,A52,FUNCT_1:70;
end;
A53: now let x be set, d be Data-Location of R such that
A54: d = x & d in dom DPp and
A55:  Cs1i1.d = Cs2i1.d;
    thus (Cs1i1|dom DPp).x
        = Cs2i1.d by A34,A54,A55,FUNCT_1:70
       .= (Cs2i1|dom DPp).x by A26,A35,A54,FUNCT_1:70;
end;
A56: now let x be set; assume
A57: x in dom (Cs3i1|SCM-Data-Loc) &
    Cs3i1.x = Cs2i1.x;
    hence (Cs3i1|SCM-Data-Loc).x
          = Cs2i1.x by FUNCT_1:70
         .= (Cs2i1|SCM-Data-Loc).x by A42,A43,A57,FUNCT_1:70;
end;
A58: now let x be set; assume
A59: x in dom (Cs3i1|SCM-Data-Loc) &
    Cs3i1.x = Cs3i.x & Cs2i1.x = Cs2i.x;
    then (Cs3i|SCM-Data-Loc).x = Cs3i.x & (Cs2i|SCM-Data-Loc).x = Cs2i.x
 by A40,A41,A42,FUNCT_1:70;
    hence (Cs3i1|SCM-Data-Loc).x = (Cs2i1|SCM-Data-Loc).x
 by A25,A56,A59;
end;
A60: now assume
    IC (Computation s1).(i+1) + k = IC (Computation s2).(i+1);
then A61: CurInstr(Cs2i1) = Cs2i1.(IC Cs1i1 + k) by AMI_1:def 17;
     reconsider loc = IC Cs1i1 as Instruction-Location of SCM R;
A62:  loc in dom ProgramPart p by A1,A3,A10,Th40;
       ProgramPart p c= p by AMI_5:63;
then A63: dom ProgramPart p c= dom p by GRFUNC_1:8;
A64: CurInstr(Cs1i1) = Cs1i1.loc by AMI_1:def 17
                    .= s1.loc by AMI_1:54
                    .= p.loc by A3,A62,A63,GRFUNC_1:8;
      p.loc = pi(p, loc) by A62,A63,AMI_5:def 5;
    then reconsider I = p.loc as Instruction of SCM R;
    loc + k in dom Relocated(p, k) by A62,A63,Th50;
then Relocated(p, k).(loc + k) = s2.(loc+k) by A4,GRFUNC_1:8
                              .= Cs2i1.(loc + k) by AMI_1:54;
 hence IncAddr(CurInstr((Computation s1).(i+1)), k)
        = CurInstr((Computation s2).(i+1)) by A61,A62,A64,Th55;
end;
A65: Cs1i1 = Following Cs1i by AMI_1:def 19
          .= Exec (CurInstr Cs1i, Cs1i) by AMI_1:def 18;
A66: Cs2i1 = Following Cs2i by AMI_1:def 19
          .= Exec (CurInstr Cs2i, Cs2i) by AMI_1:def 18;
A67: Cs3i1 = Following Cs3i by AMI_1:def 19
          .= Exec (CurInstr Cs3i, Cs3i) by AMI_1:def 18
          .= Exec (CurInstr Cs1i, Cs3i) by A1,A3,A10,A11,Th41;
  consider j being natural number such that
A68: IC Cs1i = il.(SCM R,j) by AMISTD_1:26;
A69: Next (IC Cs1i + k) = Next (il.(SCM R,j + k)) by A68,Th2
      .= il.(SCM R,j+k+1) by SCMRING3:67
      .= il.(SCM R,j+1+k)
      .= il.(SCM R,j+1) + k by Th2
      .= (Next IC Cs1i) + k by A68,SCMRING3:67;

  set I = CurInstr(Cs1i);
A70: InsCode(I) <= 7 by Th30;
    per cases by A70,CQC_THE1:8;
    suppose InsCode I = 0;
then A71:  I = halt SCM R by SCMRING3:16;
then A72:  CurInstr(Cs2i) = halt SCM R by A23,AMISTD_2:29;
    thus IC (Computation s1).(i+1) + k
               = IC Cs1i + k by A65,A71,AMI_1:def 8
              .= IC (Computation s2).(i+1) by A22,A66,A72,AMI_1:def 8;
    hence IncAddr(CurInstr((Computation s1).(i+1)), k)
        = CurInstr((Computation s2).(i+1)) by A60;
A73:        Cs2i1 = Cs2i & Cs1i1 = Cs1i by A65,A66,A71,A72,AMI_1:def 8;
     hence (Computation s1).(i+1)|dom (DataPart p)
          = (Computation s2).(i+1)|dom (DataPart (Relocated (p,k))) by A24;
     thus Cs3i1|SCM-Data-Loc = Cs2i1|SCM-Data-Loc
       by A25,A67,A71,A73,AMI_1:def 8;
      end;
    suppose InsCode I = 1;
     then consider da, db being Data-Location of R such that
A74:   I = da := db by SCMRING3:17;
A75:   IncAddr(I, k) = da := db by A74,AMISTD_2:29;
A76:  Exec(I, Cs1i).IC SCM R = Next IC Cs1i by A74,SCMRING2:13;
A77:  Cs3i.db = Cs2i.db by A47;
   thus
   IC (Computation s1).(i+1) + k
    = Next IC Cs2i by A22,A65,A69,A76,AMI_1:def 15
   .= Exec (CurInstr Cs2i, Cs2i).IC SCM R by A23,A75,SCMRING2:13
   .= IC (Computation s2).(i+1) by A66,AMI_1:def 15;
     hence IncAddr(CurInstr((Computation s1).(i+1)), k)
        = CurInstr((Computation s2).(i+1)) by A60;
     now let x be set; assume
A78: x in dom (Cs1i1|dom DPp);
       dom DPp c= SCM-Data-Loc by Th26;
     then reconsider d = x as Data-Location of R by A34,A78,SCMRING2:1;
       DPp c= p by AMI_5:62;
then A79:  dom DPp c= dom p by GRFUNC_1:8;
   per cases;
   suppose
A80: da = d;
then A81:  Cs1i1.d = Cs1i.db by A65,A74,SCMRING2:13;
A82: Cs2i1.d = Cs2i.db by A23,A66,A75,A80,SCMRING2:13;
    Cs3i.db = Cs1i.db by A1,A3,A10,A11,A34,A74,A78,A79,A80,Th42;
    hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x
      by A34,A53,A77,A78,A81,A82;
      end;
   suppose da <> d;
   then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A23,A65,A66,A74,A75,SCMRING2:13
;
   hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A34,A49,A78;
   end;
   end;
   then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A44,GRFUNC_1:8;
   hence (Computation s1).(i+1)|dom (DataPart p)
          = (Computation s2).(i+1)|dom (DataPart (Relocated (p,k)))
 by A26,A34,A35,GRFUNC_1:9;
     now let x be set; assume
A83: x in dom (Cs3i1|SCM-Data-Loc);
     then reconsider d = x as Data-Location of R by A42,SCMRING2:1;
   per cases;
   suppose da = d;
   then Cs2i1.d = Cs2i.db & Cs3i1.d=Cs3i.db by A23,A66,A67,A74,A75,SCMRING2:13
;
    hence (Cs3i1|SCM-Data-Loc).x = (Cs2i1|SCM-Data-Loc).x by A56,A77,A83;
      end;
   suppose
A84: da <> d;
then A85:  Cs3i1.d = Cs3i.d by A67,A74,SCMRING2:13;
       Cs2i1.d = Cs2i.d by A23,A66,A75,A84,SCMRING2:13;
    hence (Cs3i1|SCM-Data-Loc).x = (Cs2i1|SCM-Data-Loc).x by A58,A83,A85;
   end;
   end;
   then Cs3i1|SCM-Data-Locc=(Computation s2).(i+1)|SCM-Data-Loc by A45,
GRFUNC_1:8;
   hence Cs3i1|SCM-Data-Loc = (Computation s2).(i+1)|SCM-Data-Loc
 by A42,A43,GRFUNC_1:9;
      end;

    suppose InsCode I = 2;
     then consider da, db being Data-Location of R such that
A86:   I = AddTo(da, db) by SCMRING3:18;
A87:   IncAddr(I, k) = AddTo(da, db) by A86,AMISTD_2:29;
A88:  Exec(I, Cs1i).IC SCM R = Next IC Cs1i by A86,SCMRING2:14;
A89: Cs3i.da = Cs2i.da by A47;
A90:  Cs3i.db = Cs2i.db by A47;
     thus
   IC (Computation s1).(i+1) + k
    = Next IC Cs2i by A22,A65,A69,A88,AMI_1:def 15
   .= Exec (CurInstr Cs2i, Cs2i).IC SCM R by A23,A87,SCMRING2:14
   .= IC (Computation s2).(i+1) by A66,AMI_1:def 15;
     hence IncAddr(CurInstr((Computation s1).(i+1)), k)
        = CurInstr((Computation s2).(i+1)) by A60;
     now let x be set such that
A91: x in dom (Cs1i1|dom DPp);
       dom DPp c= SCM-Data-Loc by Th26;
     then reconsider d = x as Data-Location of R by A34,A91,SCMRING2:1;
       DPp c= p by AMI_5:62;
then A92:  dom DPp c= dom p by GRFUNC_1:8;
   per cases;
   suppose
A93: da = d;
then A94:  Cs1i1.d = Cs1i.da + Cs1i.db by A65,A86,SCMRING2:14;
    Cs2i1.d = Cs2i.da + Cs2i.db by A23,A66,A87,A93,SCMRING2:14;
  then Cs1i1.d = Cs2i1.d by A1,A3,A10,A11,A34,A86,A89,A90,A91,A92,A93,A94,Th43
;
    hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A34,A53,A91;
      end;
   suppose da <> d;
   then Cs1i1.d=Cs1i.d & Cs2i1.d = Cs2i.d by A23,A65,A66,A86,A87,SCMRING2:14;
    hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A34,A49,A91;
   end;
   end;
   then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A44,GRFUNC_1:8;
   hence (Computation s1).(i+1)|dom (DataPart p)
          = (Computation s2).(i+1)|dom (DataPart (Relocated (p,k)))
 by A26,A34,A35,GRFUNC_1:9;
     now let x be set; assume
A95: x in dom (Cs3i1|SCM-Data-Loc);
     then reconsider d = x as Data-Location of R by A42,SCMRING2:1;
   per cases;
    suppose
A96:  da = d;
then A97:  Cs2i1.d = Cs2i.da + Cs2i.db by A23,A66,A87,SCMRING2:14;
       Cs3i1.d = Cs3i.da + Cs3i.db by A67,A86,A96,SCMRING2:14;
    hence (Cs3i1|SCM-Data-Loc).x = (Cs2i1|SCM-Data-Loc).x
 by A56,A89,A90,A95,A97;
      end;
   suppose
A98:  da <> d;
then A99:  Cs3i1.d = Cs3i.d by A67,A86,SCMRING2:14;
       Cs2i1.d = Cs2i.d by A23,A66,A87,A98,SCMRING2:14;
    hence (Cs3i1|SCM-Data-Loc).x = (Cs2i1|SCM-Data-Loc).x by A58,A95,A99;
   end;
   end;
   then Cs3i1|SCM-Data-Locc=(Computation s2).(i+1)|SCM-Data-Loc by A45,
GRFUNC_1:8;
   hence Cs3i1|SCM-Data-Loc = (Computation s2).(i+1)|SCM-Data-Loc
 by A42,A43,GRFUNC_1:9;
      end;
    suppose InsCode I = 3;
     then consider da, db being Data-Location of R such that
A100:   I = SubFrom(da, db) by SCMRING3:19;
A101:   IncAddr(I, k) = SubFrom(da, db) by A100,AMISTD_2:29;
A102:  Exec(I, Cs1i).IC SCM R = Next IC Cs1i by A100,SCMRING2:15;
A103: Cs3i.da = Cs2i.da by A47;
A104:  Cs3i.db = Cs2i.db by A47;
     thus
   IC (Computation s1).(i+1) + k
    = Next IC Cs2i by A22,A65,A69,A102,AMI_1:def 15
   .= Exec (CurInstr Cs2i, Cs2i).IC SCM R by A23,A101,SCMRING2:15
   .= IC (Computation s2).(i+1) by A66,AMI_1:def 15;
     hence IncAddr(CurInstr((Computation s1).(i+1)), k)
        = CurInstr((Computation s2).(i+1)) by A60;
     now let x be set such that
A105: x in dom (Cs1i1|dom DPp);
       dom DPp c= SCM-Data-Loc by Th26;
     then reconsider d = x as Data-Location of R by A34,A105,SCMRING2:1;
       DPp c= p by AMI_5:62;
then A106: dom DPp c= dom p by GRFUNC_1:8;
   per cases;
   suppose
A107: da = d;
then A108:  Cs1i1.d = Cs1i.da - Cs1i.db by A65,A100,SCMRING2:15;
    Cs2i1.d = Cs2i.da - Cs2i.db by A23,A66,A101,A107,SCMRING2:15;
 then Cs1i1.d = Cs2i1.d by A1,A3,A10,A11,A34,A100,A103,A104,A105,A106,A107,A108
,Th44;
    hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A34,A53,A105;
      end;
   suppose
   da <> d;
     then Cs1i1.d = Cs1i.d &
     Cs2i1.d = Cs2i.d by A23,A65,A66,A100,A101,SCMRING2:15;
    hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A34,A49,A105;
   end;
   end;
   then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A44,GRFUNC_1:8;
   hence (Computation s1).(i+1)|dom (DataPart p)
          = (Computation s2).(i+1)|dom (DataPart (Relocated (p,k)))
 by A26,A34,A35,GRFUNC_1:9;
     now let x be set; assume
A109: x in dom (Cs3i1|SCM-Data-Loc);
     then reconsider d = x as Data-Location of R by A42,SCMRING2:1;
   per cases;
    suppose
A110:  da = d;
then A111:  Cs2i1.d = Cs2i.da - Cs2i.db by A23,A66,A101,SCMRING2:15;
       Cs3i1.d = Cs3i.da - Cs3i.db by A67,A100,A110,SCMRING2:15;
    hence (Cs3i1|SCM-Data-Loc).x = (Cs2i1|SCM-Data-Loc).x
 by A56,A103,A104,A109,A111;
      end;
   suppose
A112: da <> d;
then A113:  Cs3i1.d = Cs3i.d by A67,A100,SCMRING2:15;
       Cs2i1.d = Cs2i.d by A23,A66,A101,A112,SCMRING2:15;
    hence (Cs3i1|SCM-Data-Loc).x = (Cs2i1|SCM-Data-Loc).x by A58,A109,A113;
   end;
   end;
   then Cs3i1|SCM-Data-Locc=(Computation s2).(i+1)|SCM-Data-Loc by A45,
GRFUNC_1:8;
   hence Cs3i1|SCM-Data-Loc = (Computation s2).(i+1)|SCM-Data-Loc
 by A42,A43,GRFUNC_1:9;
      end;
    suppose InsCode I = 4;
     then consider da, db being Data-Location of R such that
A114:   I = MultBy(da, db) by SCMRING3:20;
A115:   IncAddr(I, k) = MultBy(da, db) by A114,AMISTD_2:29;
A116:  Exec(I, Cs1i).IC SCM R = Next IC Cs1i by A114,SCMRING2:16;
A117: Cs3i.da = Cs2i.da by A47;
A118:  Cs3i.db = Cs2i.db by A47;
     thus
   IC (Computation s1).(i+1) + k
    = Next IC Cs2i by A22,A65,A69,A116,AMI_1:def 15
   .= Exec (CurInstr Cs2i, Cs2i).IC SCM R by A23,A115,SCMRING2:16
   .= IC (Computation s2).(i+1) by A66,AMI_1:def 15;
     hence IncAddr(CurInstr((Computation s1).(i+1)), k)
        = CurInstr((Computation s2).(i+1)) by A60;
     now let x be set such that
A119: x in dom (Cs1i1|dom DPp);
       dom DPp c= SCM-Data-Loc by Th26;
     then reconsider d = x as Data-Location of R by A34,A119,SCMRING2:1;
       DPp c= p by AMI_5:62;
then A120:  dom DPp c= dom p by GRFUNC_1:8;
   per cases;
   suppose
A121: da = d;
then A122:  Cs1i1.d = Cs1i.da * Cs1i.db by A65,A114,SCMRING2:16;
    Cs2i1.d = Cs2i.da * Cs2i.db by A23,A66,A115,A121,SCMRING2:16;
  then Cs1i1.d = Cs2i1.d by A1,A3,A10,A11,A34,A114,A117,A118,A119,A120,A121
,A122,Th45;
    hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A34,A53,A119;
      end;
   suppose
   da <> d;
     then Cs1i1.d = Cs1i.d &
     Cs2i1.d = Cs2i.d by A23,A65,A66,A114,A115,SCMRING2:16;
    hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A34,A49,A119;
   end;
   end;
   then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A44,GRFUNC_1:8;
   hence (Computation s1).(i+1)|dom (DataPart p)
          = (Computation s2).(i+1)|dom (DataPart (Relocated (p,k)))
 by A26,A34,A35,GRFUNC_1:9;
     now let x be set; assume
A123: x in dom (Cs3i1|SCM-Data-Loc);
     then reconsider d = x as Data-Location of R by A42,SCMRING2:1;
    per cases;
    suppose
A124:  da = d;
then A125:  Cs2i1.d = Cs2i.da * Cs2i.db by A23,A66,A115,SCMRING2:16;
       Cs3i1.d = Cs3i.da * Cs3i.db by A67,A114,A124,SCMRING2:16;
    hence (Cs3i1|SCM-Data-Loc).x = (Cs2i1|SCM-Data-Loc).x
 by A56,A117,A118,A123,A125;
 end;
   suppose
A126: da <> d;
then A127:  Cs3i1.d = Cs3i.d by A67,A114,SCMRING2:16;
       Cs2i1.d = Cs2i.d by A23,A66,A115,A126,SCMRING2:16;
    hence (Cs3i1|SCM-Data-Loc).x = (Cs2i1|SCM-Data-Loc).x by A58,A123,A127;
   end;
   end;
   then Cs3i1|SCM-Data-Locc=(Computation s2).(i+1)|SCM-Data-Loc by A45,
GRFUNC_1:8;
   hence Cs3i1|SCM-Data-Loc = (Computation s2).(i+1)|SCM-Data-Loc
 by A42,A43,GRFUNC_1:9;
      end;
    suppose InsCode I = 5;
    then consider da being Data-Location of R,
             r being Element of the carrier of R such that
A128:   I = da:=r by SCMRING3:21;
A129:   IncAddr(I, k) = da := r by A128,AMISTD_2:29;
   Exec(I, Cs1i).IC SCM R = Next IC Cs1i by A128,SCMRING2:19;
   hence
   IC (Computation s1).(i+1) + k
    = Next IC Cs2i by A22,A65,A69,AMI_1:def 15
   .= Exec (CurInstr Cs2i, Cs2i).IC SCM R by A23,A129,SCMRING2:19
   .= IC (Computation s2).(i+1) by A66,AMI_1:def 15;
     hence IncAddr(CurInstr((Computation s1).(i+1)), k)
        = CurInstr((Computation s2).(i+1)) by A60;
     now let x be set; assume
A130: x in dom (Cs1i1|dom DPp);
       dom DPp c= SCM-Data-Loc by Th26;
     then reconsider d = x as Data-Location of R by A34,A130,SCMRING2:1;
   per cases;
   suppose
A131: da = d;
    thus (Cs1i1|dom DPp).x = Cs1i1.d by A34,A130,FUNCT_1:72
       .= r by A65,A128,A131,SCMRING2:19
       .= Cs2i1.d by A23,A66,A129,A131,SCMRING2:19
       .= (Cs2i1|dom DPp).x by A34,A130,FUNCT_1:72;
      end;
   suppose
   da <> d;
    then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d
     by A23,A65,A66,A128,A129,SCMRING2:19;
   hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A34,A49,A130;
   end;
   end;
   then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A44,GRFUNC_1:8;
   hence (Computation s1).(i+1)|dom (DataPart p)
          = (Computation s2).(i+1)|dom (DataPart (Relocated (p,k)))
 by A26,A34,A35,GRFUNC_1:9;
     now let x be set; assume
A132: x in dom (Cs3i1|SCM-Data-Loc);
     then reconsider d = x as Data-Location of R by A42,SCMRING2:1;
   per cases;
   suppose da = d;
   then Cs2i1.d = r & Cs3i1.d = r by A23,A66,A67,A128,A129,SCMRING2:19;
    hence (Cs3i1|SCM-Data-Loc).x = (Cs2i1|SCM-Data-Loc).x by A56,A132;
      end;
   suppose
A133: da <> d;
then A134:  Cs3i1.d = Cs3i.d by A67,A128,SCMRING2:19;
       Cs2i1.d = Cs2i.d by A23,A66,A129,A133,SCMRING2:19;
    hence (Cs3i1|SCM-Data-Loc).x = (Cs2i1|SCM-Data-Loc).x by A58,A132,A134;
   end;
   end;
   then Cs3i1|SCM-Data-Locc=(Computation s2).(i+1)|SCM-Data-Loc by A45,
GRFUNC_1:8;
   hence Cs3i1|SCM-Data-Loc = (Computation s2).(i+1)|SCM-Data-Loc
 by A42,A43,GRFUNC_1:9;
      end;
    suppose InsCode I = 6;
     then consider loc being Instruction-Location of SCM R such that
A135:  I = goto loc by SCMRING3:22;
A136:  CurInstr(Cs2i) = goto (loc+k) by A23,A135,Th31;
   Exec (I, Cs1i).IC SCM R = IC Exec (I, Cs1i) by AMI_1:def 15;
     hence
     IC (Computation s1).(i+1) + k
    = loc + k by A65,A135,SCMRING2:17
   .= Exec (CurInstr Cs2i, Cs2i).IC SCM R by A136,SCMRING2:17
   .= IC (Computation s2).(i+1) by A66,AMI_1:def 15;
     hence IncAddr(CurInstr((Computation s1).(i+1)), k)
        = CurInstr((Computation s2).(i+1)) by A60;
     now let x be set such that
A137: x in dom (Cs1i1|dom DPp);
       dom DPp c= SCM-Data-Loc by Th26;
     then reconsider d = x as Data-Location of R by A34,A137,SCMRING2:1;
       Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A65,A66,A135,A136,SCMRING2:17;
    hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A34,A49,A137;
   end;
   then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A44,GRFUNC_1:8;
   hence (Computation s1).(i+1)|dom (DataPart p)
          = (Computation s2).(i+1)|dom (DataPart (Relocated (p,k)))
 by A26,A34,A35,GRFUNC_1:9;
     now let x be set; assume
A138: x in dom (Cs3i1|SCM-Data-Loc);
     then reconsider d = x as Data-Location of R by A42,SCMRING2:1;
       Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A66,A67,A135,A136,SCMRING2:17;
    hence (Cs3i1|SCM-Data-Loc).x = (Cs2i1|SCM-Data-Loc).x by A58,A138;
   end;
   then Cs3i1|SCM-Data-Locc=(Computation s2).(i+1)|SCM-Data-Loc by A45,
GRFUNC_1:8;
   hence Cs3i1|SCM-Data-Loc = (Computation s2).(i+1)|SCM-Data-Loc
 by A42,A43,GRFUNC_1:9;
      end;
    suppose InsCode I = 7;
     then consider da being Data-Location of R,
              loc being Instruction-Location of SCM R such that
A139:  I = da=0_goto loc by SCMRING3:23;
A140:  CurInstr(Cs2i) = da=0_goto (loc+k) by A23,A139,Th32;
A141:  Exec (I, Cs1i).IC SCM R = IC Exec (I, Cs1i) by AMI_1:def 15;
A142: Cs3i.da = Cs2i.da by A47;
A143: now per cases;
     case Cs1i.da = 0.R;
     hence IC (Computation s1).(i+1) + k
    = loc + k by A65,A139,A141,SCMRING2:18;
    end;
     case Cs1i.da <> 0.R;
     hence IC (Computation s1).(i+1) + k
    = Next (IC Cs2i) by A22,A65,A69,A139,A141,SCMRING2:18;
      end;
      end;
A144: now per cases;
     case
A145:  Cs2i.da = 0.R;
      thus IC (Computation s2).(i+1)
    = Exec (CurInstr Cs2i, Cs2i).IC SCM R by A66,AMI_1:def 15
   .= loc + k by A140,A145,SCMRING2:18;
      end;
     case
A146:  Cs2i.da <> 0.R;
      thus IC (Computation s2).(i+1)
    = Exec (CurInstr Cs2i, Cs2i).IC SCM R by A66,AMI_1:def 15
   .= Next IC Cs2i by A140,A146,SCMRING2:18;
     end;
     end;
       now per cases;
     suppose loc <> Next IC Cs1i;
     hence IC (Computation s1).(i+1) + k
      = IC (Computation s2).(i+1) by A1,A3,A10,A11,A139,A142,A143,A144,Th46;
      end;
     suppose loc = Next IC Cs1i;
     hence IC (Computation s1).(i+1) + k
         = IC (Computation s2).(i+1) by A22,A69,A143,A144;
     end;
    end;
     hence
     IC (Computation s1).(i+1) + k = IC (Computation s2).(i+1) &
     IncAddr(CurInstr((Computation s1).(i+1)), k)
        = CurInstr((Computation s2).(i+1)) by A60;
     now let x be set such that
A147: x in dom (Cs1i1|dom DPp);
       dom DPp c= SCM-Data-Loc by Th26;
     then reconsider d = x as Data-Location of R by A34,A147,SCMRING2:1;
       Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A65,A66,A139,A140,SCMRING2:18;
    hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A34,A49,A147;
   end;
   then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A44,GRFUNC_1:8;
   hence (Computation s1).(i+1)|dom (DataPart p)
          = (Computation s2).(i+1)|dom (DataPart (Relocated (p,k)))
 by A26,A34,A35,GRFUNC_1:9;
     now let x be set; assume
A148: x in dom (Cs3i1|SCM-Data-Loc);
     then reconsider d = x as Data-Location of R by A42,SCMRING2:1;
       Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A66,A67,A139,A140,SCMRING2:18;
    hence (Cs3i1|SCM-Data-Loc).x = (Cs2i1|SCM-Data-Loc).x by A58,A148;
   end;
   then Cs3i1|SCM-Data-Locc=(Computation s2).(i+1)|SCM-Data-Loc by A45,
GRFUNC_1:8;
   hence Cs3i1|SCM-Data-Loc = (Computation s2).(i+1)|SCM-Data-Loc
      by A42,A43,GRFUNC_1:9;
    end;
      end;
    for n holds P[n] from NAT_1:sch 1(A12,A21);
   hence thesis;
end;

theorem Th60:
  R is non trivial implies
  for p being autonomic FinPartState of SCM R st IC SCM R in dom p holds
   p is halting iff Relocated (p,k) is halting
  proof
assume
A1:R is non trivial;
   let p be autonomic FinPartState of SCM R;
   assume
A2: IC SCM R in dom p;
   hereby assume
A3: p is halting;
   thus Relocated (p,k) is halting
    proof
    let t be State of SCM R;
    assume
A4:  Relocated(p,k) c= t;
    set s = t +* p;
A5: p c= s by FUNCT_4:26;
     then s is halting by A3,AMI_1:def 26;
     then consider u being Nat such that
A6:  CurInstr((Computation s).u) = halt SCM R by AMI_1:def 20;
      reconsider s3 = s +* t|SCM-Data-Loc as State of SCM R by AMI_5:82;
        s3 = s3;
then A7:  CurInstr((Computation t).u) = IncAddr(halt SCM R, k)
      by A1,A2,A4,A5,A6,Th59
                                .= halt SCM R by AMISTD_2:29;
     take u;
     thus thesis by A7;
    end;
   end;

   assume
A8: Relocated (p,k) is halting;
   let t be State of SCM R;
   assume
A9: p c= t;
    reconsider s = t +* Relocated(p, k) as State of SCM R;
A10: Relocated (p,k) c= t +* Relocated (p,k) by FUNCT_4:26;
     then s is halting by A8,AMI_1:def 26;
     then consider u being Nat such that
A11:  CurInstr((Computation s).u) = halt SCM R by AMI_1:def 20;
      reconsider s3 = t +* s|SCM-Data-Loc as State of SCM R by AMI_5:82;
        s3 = s3;
then A12:  IncAddr(CurInstr((Computation t).u), k) = halt SCM R
        by A1,A2,A9,A10,A11,Th59;
     take u;
   thus CurInstr((Computation t).u) = halt SCM R by A12,AMISTD_2:35;
  end;

theorem
   R is non trivial implies
  for p being autonomic FinPartState of SCM R st IC SCM R in dom p & p c= s
  for i being Nat holds
    (Computation (s +* Relocated (p,k))).i
       = (Computation s).i +* Start-At (IC (Computation s ).i + k)
        +* ProgramPart (Relocated (p,k))
   proof
   assume
   A1:R is non trivial;
    let p being autonomic FinPartState of SCM R such that
        A2: IC SCM R in dom p and
         A3: p c= s;
      not IC SCM R in dom DataPart p by AMI_5:65;
then A4: dom DataPart p /\ {IC SCM R} = {} by Lm1;
A5: dom DataPart p c= SCM-Data-Loc by Th26;
A6: dom ProgramPart(Relocated(p,k)) c= SCM-Instr-Loc by Th29;
A7:dom DataPart p misses dom (Start-At ((IC p) + k)
        +* ProgramPart (Relocated (p,k)))
    proof
      SCM-Instr-Loc misses dom DataPart p by A5,AMI_5:33,XBOOLE_1:63;
 then dom DataPart p misses dom (ProgramPart (Relocated (p,k)))
   by A6,XBOOLE_1:63;
 then dom DataPart p /\ dom (ProgramPart (Relocated (p,k))) = {}
 by XBOOLE_0:def 7;
       then dom DataPart p /\ dom (Start-At ((IC p) + k))
    \/ dom DataPart p /\ dom (ProgramPart (Relocated (p,k))) = {}
 by A4,AMI_3:34;
then dom DataPart p /\ (dom (Start-At ((IC p) + k))
        \/ dom (ProgramPart (Relocated (p,k)))) = {} by XBOOLE_1:23;
hence dom DataPart p /\ dom (Start-At ((IC p) + k)
        +* ProgramPart (Relocated (p,k))) = {} by FUNCT_4:def 1;
      end;
     A8:    IC p = p.IC SCM R by A2,AMI_3:def 16
            .= s.IC SCM R by A2,A3,GRFUNC_1:8
            .= IC s by AMI_1:def 15;
         DataPart p c= p by AMI_5:62;
then A9:    DataPart p c= s by A3,XBOOLE_1:1;
A10:    (Computation s).0 = s by AMI_1:def 19;
defpred P[Nat] means
    (Computation (s +* Relocated (p,k))).$1
       = (Computation s).$1 +* Start-At (IC (Computation s ).$1 + k)
        +* ProgramPart (Relocated (p,k));
  (Computation (s +* Relocated (p,k))).0
         = s +* Relocated (p,k) by AMI_1:def 19
        .= s +* (Start-At ((IC p)+k) +*
           IncAddr(Shift(ProgramPart(p),k),k)+*DataPart p) by Def2
        .= s +* ((Start-At ((IC p) + k) +*
           ProgramPart (Relocated (p,k))) +* DataPart p) by Th48
        .= s +* (DataPart p +* (Start-At ((IC p) + k) +*
           ProgramPart (Relocated (p,k)))) by A7,FUNCT_4:36
        .= s +* DataPart p +* (Start-At ((IC p) + k) +*
           ProgramPart (Relocated (p,k))) by FUNCT_4:15
        .= s +* DataPart p +* Start-At ((IC p) + k) +*
           ProgramPart (Relocated (p,k)) by FUNCT_4:15
        .= (Computation s).0 +* Start-At (IC (Computation s).0 + k)
                +* ProgramPart (Relocated (p,k)) by A8,A9,A10,FUNCT_4:79;
   then A11: P[0];
A12: for i being Nat st P[i] holds P[i+1]
  proof
   let i be Nat
   such that
A13: (Computation (s +* Relocated (p,k))).i
     = (Computation (s)).i +* Start-At (IC (Computation (s)).i + k)
       +* ProgramPart (Relocated (p,k));
A14: (Computation (s)).(i+1) = Following((Computation (s)).i) by AMI_1:def 19;
      dom (Start-At (IC (Computation (s)).i + k)) = {IC SCM R}
 by AMI_3:34;
then A15: IC SCM R in dom (Start-At (IC (Computation (s)).i + k)) by
TARSKI:def 1;
A16: not IC SCM R in dom ProgramPart(Relocated (p,k)) by AMI_5:66;
A17: IC ((Computation (s)).i
         +* Start-At (IC (Computation (s)).i + k)
         +* ProgramPart (Relocated (p,k)))
      = ((Computation (s)).i
         +* Start-At (IC (Computation (s)).i + k)
         +* ProgramPart (Relocated (p,k))).IC SCM R by AMI_1:def 15
     .= ((Computation (s)).i
         +* Start-At (IC (Computation (s)).i + k)).IC SCM R
 by A16,FUNCT_4:12
  .= (Start-At (IC (Computation (s)).i + k)).IC SCM R by A15,FUNCT_4:14
  .= IC (Computation (s)).i + k by AMI_3:50;
      p is not programmed by A2,AMI_5:76;
then A18:  IC (Computation (s)).i in dom ProgramPart(p) by A1,A3,Th40;
     then A19:  IC (Computation (s)).i in dom IncAddr(ProgramPart(p),k)
 by AMISTD_2:def 15;

A20: ProgramPart(p) c= (Computation (s)).i by A3,AMI_5:64;
A21: pi(ProgramPart(p),IC (Computation (s)).i)
    = (ProgramPart(p)).IC (Computation (s)).i by A18,AMI_5:def 5
   .= ((Computation (s)).i).IC (Computation (s)).i by A18,A20,GRFUNC_1:8;
           ProgramPart p c= p by AMI_5:63;
     then dom ProgramPart p c= dom p by GRFUNC_1:8;
then (IC (Computation s).i + k) in dom (Relocated (p,k)) by A18,Th50;
then A22: (IC (Computation s).i + k) in dom (ProgramPart (Relocated (p,k)))
 by AMI_5:73;
A23: CurInstr ((Computation (s +* Relocated (p,k))).i)
     = ((Computation (s)).i
       +* Start-At (IC (Computation (s)).i + k)
       +* ProgramPart (Relocated (p,k))).(IC (Computation (s)).i + k)
 by A13,A17,AMI_1:def 17
    .= (ProgramPart (Relocated (p,k))).(IC (Computation (s)).i + k)
 by A22,FUNCT_4:14

    .= IncAddr(Shift(ProgramPart(p),k),k).(IC (Computation (s)).i + k)
 by Th48
    .= Shift(IncAddr(ProgramPart(p),k),k).(IC (Computation (s)).i + k)
 by Th54
    .= IncAddr(ProgramPart(p),k).(IC (Computation (s)).i)
 by A19,Th11
    .= IncAddr (((Computation (s)).i).IC ((Computation (s)).i),k)
 by A18,A21,Th53

    .= IncAddr (CurInstr ( Computation (s)).i,k) by AMI_1:def 17;
   thus (Computation (s +* Relocated (p,k))).(i+1)
         = Following((Computation (s +* Relocated (p,k))).i) by AMI_1:def 19
        .= Exec(IncAddr(CurInstr (Computation (s)).i,k),
               ((Computation (s +* Relocated (p,k))).i)) by A23,AMI_1:def 18
         .= Exec(IncAddr(CurInstr (Computation (s)).i,k),
           (Computation (s)).i
           +* Start-At (IC (Computation (s)).i + k))
           +* ProgramPart (Relocated (p,k)) by A13,Th13
        .= (Computation (s)).(i+1)
          +* Start-At (IC (Computation (s)).(i+1) + k)
          +* ProgramPart (Relocated (p,k)) by A14,Th35;
    end;
     for n holds P[n] from NAT_1:sch 1 (A11,A12);
    hence thesis;
   end;

theorem Th62:
  R is non trivial implies
  for p being autonomic FinPartState of SCM R st
   IC SCM R in dom p & Relocated(p,k) c= s holds
  for i being Nat holds
    (Computation s).i
     = (Computation(s +* p)).i +* Start-At (IC(Computation(s +* p)).i + k)
       +* s|dom ProgramPart p +* ProgramPart (Relocated (p,k))
  proof
  assume
  A1:R is non trivial;
   let p be autonomic FinPartState of SCM R such that
A2:  IC SCM R in dom p and
A3: Relocated (p,k) c= s;
A4: dom Start-At (IC(Computation (s +* p)).0 + k) = {IC SCM R} by AMI_3:34;
A5: dom Start-At(IC p) = {IC SCM R} by AMI_3:34;
       ProgramPart (Relocated (p,k)) c= Relocated (p,k) by AMI_5:63;
then A6: ProgramPart (Relocated (p,k)) c= s by A3,XBOOLE_1:1;
A7: s|dom ProgramPart p c= s by RELAT_1:88;
       dom ProgramPart p c= the carrier of SCM R by AMI_3:37;
     then dom ProgramPart p c= dom s by AMI_3:36;
then A8: dom ProgramPart p = dom (s|dom ProgramPart p) by RELAT_1:91;
A9:IC(Computation (s +* p)).0 = IC (s +* p) by AMI_1:def 19
                                .= (s +* p).IC SCM R by AMI_1:def 15
                                .= p.IC SCM R by A2,FUNCT_4:14
                                .= IC p by A2,AMI_3:def 16;
       Start-At (IC p + k ) c= Relocated (p,k) by Th56;
then A10: Start-At (IC(Computation (s +* p)).0 + k) c= s by A3,A9,XBOOLE_1:1;
A11: {IC SCM R} misses dom ProgramPart p by AMI_5:68;
       DataPart (Relocated (p,k)) c= Relocated (p,k) by AMI_5:62;
     then DataPart (Relocated (p,k)) c= s by A3,XBOOLE_1:1;
then A12: DataPart p c= s by Th47;
A13: dom DataPart p misses dom ProgramPart p by AMI_5:71;
A14: dom Start-At(IC p) = dom Start-At (IC(Computation (s +* p)).0 + k)
 by A4,AMI_3:34;
A15: {IC SCM R} misses dom DataPart p by AMI_5:67;
A16: {IC SCM R} misses dom ProgramPart p by AMI_5:68;

 set IS = Start-At (IC(Computation (s +* p)).0 + k);
 set IP = Start-At (IC p);
 set SD = s|dom ProgramPart p;
 set PP = ProgramPart p;
 set DP = DataPart p;
 set PR = ProgramPart (Relocated (p,k));
defpred P[Nat] means (Computation s).$1
     = (Computation(s +* p)).$1 +* Start-At (IC(Computation(s +* p)).$1 + k)
       +* s|dom ProgramPart p +* ProgramPart (Relocated (p,k));
 (Computation s).0
   = s by AMI_1:def 19
  .= s +* PR by A6,FUNCT_4:79
  .= s +* SD +* PR by A7,FUNCT_4:79
  .= s +* PP +* SD +* PR by A8,FUNCT_4:78
  .= s +* IS +* PP +* SD +* PR by A10,FUNCT_4:79
  .= s +*(IS +* PP) +* SD +* PR by FUNCT_4:15
  .= s +*(PP +* IS) +* SD +* PR by A4,A11,FUNCT_4:36
  .= s +* PP +* IS +* SD +* PR by FUNCT_4:15
  .= s +* DP +* PP +* IS +* SD +* PR by A12,FUNCT_4:79
  .= s +*(DP +* PP) +* IS +* SD +* PR by FUNCT_4:15
  .= s +*(PP +* DP) +* IS +* SD +* PR by A13,FUNCT_4:36
  .= s +* PP +* DP +* IS +* SD +* PR by FUNCT_4:15
  .= s +* PP +* DP +* IP +* IS +* SD +* PR by A14,FUNCT_4:78
  .= s +*(PP +* DP) +* IP +* IS +* SD +* PR by FUNCT_4:15
  .= s +*(PP +* DP +* IP) +* IS +* SD +* PR by FUNCT_4:15
  .= s +*(PP +*(DP +* IP))+* IS +* SD +* PR by FUNCT_4:15
  .= s +*(PP +*(IP +* DP))+* IS +* SD +* PR by A5,A15,FUNCT_4:36
  .= s +*(PP +* IP +* DP) +* IS +* SD +* PR by FUNCT_4:15
  .= s +*(IP +* PP +* DP) +* IS +* SD +* PR by A5,A16,FUNCT_4:36
  .= s +* p +* IS +* SD +* PR by A2,AMI_5:75
  .= (Computation (s +* p)).0 +* Start-At (IC(Computation (s +* p)).0 + k)
       +* s|dom ProgramPart p +* ProgramPart (Relocated (p,k)) by AMI_1:def 19;
 then A17: P[0];
A18: for i being Nat st P[i] holds P[i+1]
  proof
   let i be Nat
   such that
A19: (Computation s).i
    = (Computation (s +* p)).i +* Start-At (IC (Computation (s +* p)).i + k)
       +* s|dom ProgramPart p+* ProgramPart (Relocated (p,k));
      product the Object-Kind of SCM R c= sproduct the Object-Kind of SCM R
 by AMI_1:27;
    then s in sproduct the Object-Kind of SCM R by TARSKI:def 3;
    then reconsider sdom = s|dom ProgramPart p
            as Element of sproduct the Object-Kind of SCM R by AMI_1:41;
      dom ProgramPart p c= the carrier of SCM R by AMI_3:37;
    then dom ProgramPart p c= dom s by AMI_3:36;
then A20: dom ProgramPart p = dom (s|dom ProgramPart p) by RELAT_1:91;
    then dom sdom is finite;
    then sdom is finite by FINSET_1:29;
    then reconsider sdom as FinPartState of SCM R by AMI_1:def 24;
      dom (s|dom ProgramPart p) c= SCM-Instr-Loc by A20,Th29;
    then dom (s|dom ProgramPart p) c= the Instruction-Locations of SCM R
 by SCMRING2:def 1;
    then reconsider sdom as programmed FinPartState of SCM R by AMI_3:def 13;

A21: (Computation (s +* p)).(i+1) = Following((Computation (s +* p)).i)
 by AMI_1:def 19;
      dom (Start-At (IC (Computation (s +* p)).i + k)) = {IC SCM R}
 by AMI_3:34;
then A22: IC SCM R in dom (Start-At (IC (Computation (s +* p)).i + k))
 by TARSKI:def 1;
A23: not IC SCM R in dom ProgramPart(Relocated (p,k)) by AMI_5:66;
A24: dom sdom = dom s /\ dom ProgramPart p by FUNCT_1:68;
        not IC SCM R in dom ProgramPart p by AMI_5:66;
then A25: not IC SCM R in dom sdom by A24,XBOOLE_0:def 3;
A26: IC ((Computation (s +* p)).i
        +* Start-At (IC (Computation (s +* p)).i + k)
        +* sdom
        +* ProgramPart (Relocated (p,k)))
      = ((Computation (s +* p)).i
        +* Start-At (IC (Computation (s +* p)).i + k)
        +* sdom
        +* ProgramPart (Relocated (p,k))).IC SCM R by AMI_1:def 15
     .= ((Computation (s +* p)).i
        +* Start-At (IC (Computation (s +* p)).i + k)
        +* sdom).IC SCM R by A23,FUNCT_4:12
     .= ((Computation (s +* p)).i
        +* Start-At (IC (Computation (s +* p)).i + k)).IC SCM R
 by A25,FUNCT_4:12
     .= (Start-At (IC (Computation (s +* p)).i + k)).IC SCM R
 by A22,FUNCT_4:14
     .= IC (Computation (s +* p)).i + k by AMI_3:50;
A27:  p c= s +* p by FUNCT_4:26;
       p is not programmed by A2,AMI_5:76;
then A28:  IC (Computation (s +* p)).i in dom ProgramPart(p) by A1,A27,Th40;
     then A29:  IC (Computation (s +* p)).i in dom IncAddr(ProgramPart(p),k)
 by AMISTD_2:def 15;
A30: ProgramPart(p) c= (Computation (s +* p)).i by A27,AMI_5:64;
A31: pi(ProgramPart(p),IC (Computation (s +* p)).i)
    = (ProgramPart(p)).IC (Computation (s +* p)).i by A28,AMI_5:def 5
   .= ((Computation (s +* p)).i).IC (Computation (s +* p)).i
 by A28,A30,GRFUNC_1:8;
           ProgramPart p c= p by AMI_5:63;
     then dom ProgramPart p c= dom p by GRFUNC_1:8;
then (IC (Computation (s +* p)).i + k) in dom (Relocated (p,k))
 by A28,Th50;
then A32: (IC (Computation (s +* p)).i + k) in
  dom (ProgramPart (Relocated (p,k))) by AMI_5:73;
A33: CurInstr (Computation (s)).i
    = ((Computation (s +* p)).i
       +* Start-At (IC (Computation (s +* p)).i + k)
       +* sdom +* ProgramPart (Relocated (p,k))) .IC
      ((Computation (s +* p)).i
       +* Start-At (IC (Computation (s +* p)).i + k)
       +* sdom +* ProgramPart (Relocated (p,k))) by A19,AMI_1:def 17
   .= (ProgramPart (Relocated (p,k))).(IC (Computation (s +* p)).i + k)
 by A26,A32,FUNCT_4:14
   .= IncAddr(Shift(ProgramPart(p),k),k).(IC (Computation (s +* p)).i + k)
 by Th48
   .= Shift(IncAddr(ProgramPart(p),k),k).(IC (Computation (s +* p)).i + k)
 by Th54
   .= IncAddr(ProgramPart(p),k).(IC (Computation (s +* p)).i) by A29,Th11
   .= IncAddr(((Computation (s +* p)).i).IC ((Computation (s +* p)).i),k)
 by A28,A31,Th53
   .= IncAddr(CurInstr ((Computation (s +* p)).i),k) by AMI_1:def 17;

 thus (Computation s).(i+1)
   = Following((Computation s ).i) by AMI_1:def 19
  .= Exec(CurInstr (Computation (s)).i,
         (Computation (s +* p)).i
            +* Start-At (IC (Computation (s +* p)).i + k)
            +* sdom +* ProgramPart (Relocated (p,k))) by A19,AMI_1:def 18
  .= Exec(IncAddr(CurInstr ((Computation (s +* p)).i),k),
         ((Computation (s +* p)).i)
          +* Start-At (IC ((Computation (s +* p)).i) + k)
          +* sdom ) +* ProgramPart (Relocated (p,k)) by A33,Th13
  .= Exec(IncAddr(CurInstr ((Computation (s +* p)).i),k),
         ((Computation (s +* p)).i)
          +* Start-At (IC ((Computation (s +* p)).i) + k))
          +* sdom +* ProgramPart (Relocated (p,k)) by Th13
  .= (Computation (s +* p)).(i+1)
          +* Start-At (IC (Computation (s +* p)).(i+1) + k)
          +* s|dom ProgramPart p +* ProgramPart (Relocated (p,k)) by A21,Th35;
    end;
     for n holds P[n] from NAT_1:sch 1 (A17,A18);
    hence thesis;
  end;

theorem Th63:
  R is non trivial & IC SCM R in dom p & p c= s & Relocated(p,k) is autonomic
  implies
  for i being Nat holds
   (Computation s).i
    = (Computation(s +* Relocated(p,k))).i
      +* Start-At (IC(Computation(s +* Relocated(p,k))).i -' k)
      +* s|dom ProgramPart Relocated(p,k) +* ProgramPart (p)
  proof
  assume that
  A1:R is non trivial and
A2:IC SCM R in dom p and
A3: p c= s and
A4:Relocated (p,k) is autonomic;
 set IS = Start-At (IC(Computation (s +* Relocated(p,k))).0 -' k);
 set IP = Start-At((IC p)+k);
 set PR = ProgramPart Relocated (p,k);
 set SD = s|(dom PR);
 set PP = ProgramPart p;
 set DP = DataPart p;

A5: dom IS = {IC SCM R} by AMI_3:34;
A6: dom IP = {IC SCM R} by AMI_3:34;
       PP c= p by AMI_5:63;
then A7: PP c= s by A3,XBOOLE_1:1;
       Start-At (IC p) c= p by A2,AMI_5:78;
then A8: Start-At (IC p) c= s by A3,XBOOLE_1:1;
       dom PR c= the carrier of SCM R by AMI_3:37;
then A9:dom PR c= dom s by AMI_3:36;
A10:  IC SCM R in dom Relocated(p,k) by Th51;
A11:IC(Computation (s +* Relocated(p,k))).0
        = IC (s +* Relocated(p,k)) by AMI_1:def 19
       .= (s +* Relocated(p,k)).IC SCM R by AMI_1:def 15
       .= Relocated(p,k).IC SCM R by A10,FUNCT_4:14
       .= IC Relocated(p,k) by A10,AMI_3:def 16;
       DP c= p by AMI_5:62;
then A12: DP c= s by A3,XBOOLE_1:1;
A13: dom DP misses dom PR by AMI_5:71;
A14: dom Start-At((IC p)+k) = dom IS by A5,AMI_3:34;
A15: {IC SCM R} misses dom DP by AMI_5:67;
A16: {IC SCM R} misses dom PR by AMI_5:68;
A17:dom IS misses dom (s|(dom PR))
    proof
    thus dom IS
        /\ dom (s|(dom PR))
    = dom IS /\ (dom s /\ dom PR) by FUNCT_1:68
   .= {IC SCM R} /\ (dom s /\ dom PR) by AMI_3:34
   .= {IC SCM R} /\ dom PR /\ dom s by XBOOLE_1:16
   .= {} /\ dom s by A16,XBOOLE_0:def 7
   .= {};
   end;
A18: dom PR = dom(s|(dom PR)) by A9,RELAT_1:91;
defpred P[Nat] means (Computation s).$1
     = (Computation(s +* Relocated(p,k))).$1
     +* Start-At (IC(Computation(s +* Relocated(p,k))).$1 -' k)
     +* s|(dom ProgramPart Relocated(p,k)) +* ProgramPart p;
  (Computation s).0
   = s by AMI_1:def 19
  .= s +* PP by A7,FUNCT_4:79
  .= s +* Start-At (IC p) +* PP by A8,FUNCT_4:79
  .= s +* Start-At (IC p + k -' k) +* PP by Th5
  .= s +* IS +* PP by A11,Th52
  .= s +* SD +* IS +* PP by FUNCT_4:80
  .= s +* PR +* SD +* IS +* PP by A18,FUNCT_4:78
  .= s +* PR +* (SD +* IS) +* PP by FUNCT_4:15
  .= s +* PR +* (IS +* SD) +* PP by A17,FUNCT_4:36
  .= s +* PR +* IS +* SD +* PP by FUNCT_4:15
  .= s +* DP +* PR +* IS +* SD +* PP by A12,FUNCT_4:79
  .= s +*(DP +* PR) +* IS +* SD +* PP by FUNCT_4:15
  .= s +*(PR +* DP) +* IS +* SD +* PP by A13,FUNCT_4:36
  .= s +* PR +* DP +* IS +* SD +* PP by FUNCT_4:15
  .= s +* PR +* DP +* IP +* IS +* SD +* PP by A14,FUNCT_4:78
  .= s +*(PR +* DP) +* IP +* IS +* SD +* PP by FUNCT_4:15
  .= s +*(PR +* DP +* IP) +* IS +* SD +* PP by FUNCT_4:15
  .= s +*(PR +* (DP +* IP))+* IS +* SD +* PP by FUNCT_4:15
  .= s +*(PR +* (IP +* DP))+* IS +* SD +* PP by A6,A15,FUNCT_4:36
  .= s +*(PR +* IP +* DP) +* IS +* SD +* PP by FUNCT_4:15
  .= s +*(IP +* PR +* DP) +* IS +* SD +* PP by A6,A16,FUNCT_4:36
  .= s +*(IP +* IncAddr(Shift(ProgramPart(p),k),k) +* DP)
     +* IS +* SD +* PP by Th48
  .= s +* Relocated(p,k) +* IS +* SD +* PP by Def2
  .= (Computation (s +* Relocated(p,k))).0
     +* Start-At (IC(Computation (s +* Relocated(p,k))).0 -' k)
     +* s|(dom ProgramPart Relocated(p,k))
     +* ProgramPart p by AMI_1:def 19;
then A19: P[0];
A20: for i being Nat st P[i] holds P[i+1]
  proof
   let i be Nat such that
A21: P[i];
     product the Object-Kind of SCM R c= sproduct the Object-Kind of SCM R
    by AMI_1:27;
    then s in sproduct the Object-Kind of SCM R by TARSKI:def 3;
    then reconsider sdom = s|(dom ProgramPart Relocated(p,k))
            as Element of sproduct the Object-Kind of SCM R by AMI_1:41;

      dom ProgramPart Relocated(p,k) c= the carrier of SCM R by AMI_3:37;
    then dom ProgramPart Relocated(p,k) c= dom s by AMI_3:36;
then A22: dom ProgramPart Relocated(p,k) =
       dom (s|(dom ProgramPart Relocated(p,k))) by RELAT_1:91;
    then dom sdom is finite;
    then sdom is finite by FINSET_1:29;
    then reconsider sdom as FinPartState of SCM R by AMI_1:def 24;
      dom (s|(dom ProgramPart Relocated(p,k))) c= SCM-Instr-Loc by A22,Th29;
    then dom (s|(dom ProgramPart Relocated(p,k)))
       c= the Instruction-Locations of SCM R by SCMRING2:def 1;
    then reconsider sdom as programmed FinPartState of SCM R by AMI_3:def 13;
A23: (Computation (s +* Relocated(p,k))).(i+1)
     = Following((Computation (s +* Relocated(p,k))).i) by AMI_1:def 19;
     dom (Start-At (IC (Computation (s +* Relocated(p,k))).i -' k)) = {IC SCM R
}
 by AMI_3:34;
then A24: IC SCM R in dom (Start-At (IC (Computation (s +* Relocated(p,k))).i
-' k))
 by TARSKI:def 1;
A25: not IC SCM R in dom ProgramPart p by AMI_5:66;
A26: dom sdom = dom s /\ dom ProgramPart Relocated(p,k) by FUNCT_1:68;
        not IC SCM R in dom ProgramPart Relocated(p,k) by AMI_5:66;
then A27: not IC SCM R in dom sdom by A26,XBOOLE_0:def 3;
A28: IC ((Computation (s +* Relocated(p,k))).i
        +* Start-At (IC (Computation (s +* Relocated(p,k))).i -' k)
        +* sdom
        +* ProgramPart p)
      = ((Computation (s +* Relocated(p,k))).i
        +* Start-At (IC (Computation (s +* Relocated(p,k))).i -' k)
        +* sdom
        +* ProgramPart p).IC SCM R by AMI_1:def 15
     .= ((Computation (s +* Relocated(p,k))).i
        +* Start-At (IC (Computation (s +* Relocated(p,k))).i -' k)
        +* sdom).IC SCM R by A25,FUNCT_4:12
     .= ((Computation (s +* Relocated(p,k))).i
        +* Start-At (IC (Computation (s +* Relocated(p,k))).i -' k)).IC SCM R
 by A27,FUNCT_4:12
     .= (Start-At (IC (Computation (s +* Relocated(p,k))).i -' k)).IC SCM R
 by A24,FUNCT_4:14
     .= IC (Computation (s +* Relocated(p,k))).i -' k by AMI_3:50;
A29:  Relocated(p,k) c= s +* Relocated(p,k) by FUNCT_4:26;
       IC SCM R in dom Relocated(p,k) by Th51;
     then Relocated(p,k) is not programmed by AMI_5:76;
then A30:  IC (Computation (s +* Relocated(p,k))).i
       in dom ProgramPart(Relocated(p,k)) by A1,A4,A29,Th40;
A31:  ProgramPart(Relocated(p,k)) c= (Computation (s +* Relocated(p,k))).i
 by A29,AMI_5:64;
   consider jk being natural number such that
A32: IC (Computation (s +* Relocated(p,k))).i = il.(SCM R,jk) by AMISTD_1:26;
      il.(SCM R,jk) in { il.(SCM R,j+k) where j is Nat:
      il.(SCM R,j) in dom ProgramPart(p) } by A30,A32,Th49;
   then consider j being Nat such that
A33: il.(SCM R,jk) = il.(SCM R,j+k) & il.(SCM R,j) in dom ProgramPart(p);
A34: il.(SCM R,j+k) -' k + k = il.(SCM R,j) + k -'k + k by Th2
                      .= il.(SCM R,j) + k by Th5
                      .= il.(SCM R,j+k) by Th2;
A35: il.(SCM R,j+k) -' k = il.(SCM R,j) + k -' k by Th2
                  .= il.(SCM R,j) by Th5;
    reconsider pp = ProgramPart(p) as programmed FinPartState of SCM R;
   dom Shift(pp, k) = { il.(SCM R,m+k) where m is Nat: il.(SCM R,m) in dom pp}
   by AMISTD_2:def 16;
     then A36: il.(SCM R,j+k) in dom Shift(ProgramPart(p), k) by A33;
A37: CurInstr (Computation (s)).i
    = ((Computation (s +* Relocated(p,k))).i
       +* Start-At (IC (Computation (s +* Relocated(p,k))).i -' k)
       +* sdom +* ProgramPart p) .IC
      ((Computation (s +* Relocated(p,k))).i
       +* Start-At (IC (Computation (s +* Relocated(p,k))).i -' k)
       +* sdom +* ProgramPart p) by A21,AMI_1:def 17
   .= (ProgramPart p).
      (IC (Computation (s +* Relocated(p,k))).i -' k)
        by A28,A32,A33,A35,FUNCT_4:14
   .= Shift(ProgramPart p, k).
      (IC (Computation (s +* Relocated(p,k))).i) by A32,A33,A34,A35,Th11
   .= pi(Shift(ProgramPart p, k),IC (Computation (s +* Relocated(p,k))).i)
 by A32,A33,A36,AMI_5:def 5;
  IncAddr(pi(Shift(ProgramPart p, k),
                         IC (Computation (s +* Relocated(p,k))).i), k)
    = IncAddr(Shift(ProgramPart(p),k),k).
      (IC (Computation (s +* Relocated(p,k))).i) by A32,A33,A36,Th53
   .= (ProgramPart Relocated(p,k)).(IC (Computation (s +* Relocated(p,k))).i)
 by Th48
   .= ((Computation (s +* Relocated(p,k))).i).
         IC ((Computation (s +* Relocated(p,k))).i) by A30,A31,GRFUNC_1:8
   .= CurInstr ((Computation (s +* Relocated(p,k))).i) by AMI_1:def 17;
then A38:
   Exec(CurInstr (Computation (s)).i,
   (Computation (s +* Relocated(p,k))).i
    +* Start-At (IC (Computation (s +* Relocated(p,k))).i -' k))
 = Exec(CurInstr (Computation (s +* Relocated(p,k))).i,
        (Computation (s +* Relocated(p,k))).i)
  +* Start-At (IC Exec(CurInstr (Computation (s +* Relocated(p,k))).i,
                  (Computation (s +* Relocated(p,k))).i) -' k) by A32,A33,A37,
Th36
.= Exec(CurInstr (Computation (s +* Relocated(p,k))).i,
        (Computation (s +* Relocated(p,k))).i)
  +* Start-At ((IC Following(Computation (s +* Relocated(p,k))).i) -' k)
 by AMI_1:def 18
.= Following((Computation (s +* Relocated(p,k))).i)
  +* Start-At ((IC Following(Computation (s +* Relocated(p,k))).i) -' k)
 by AMI_1:def 18;
 thus (Computation s).(i+1)
   = Following((Computation s ).i) by AMI_1:def 19
  .= Exec(CurInstr (Computation (s)).i,
     (Computation (s +* Relocated(p,k))).i
     +* Start-At (IC (Computation (s +* Relocated(p,k))).i -' k)
     +* sdom +* ProgramPart p) by A21,AMI_1:def 18
  .= Exec(CurInstr (Computation (s)).i,
     (Computation (s +* Relocated(p,k))).i
     +* Start-At (IC (Computation (s +* Relocated(p,k))).i -' k)
     +* sdom ) +* ProgramPart p by Th13
  .= (Computation (s +* Relocated(p,k))).(i+1)
     +* Start-At (IC (Computation (s +* Relocated(p,k))).(i+1) -' k)
     +* s|dom ProgramPart Relocated(p,k) +* ProgramPart p by A23,A38,Th13;
    end;
    for n holds P[n] from NAT_1:sch 1 (A19,A20);
   hence thesis;
  end;

theorem Th64:
  R is non trivial & IC SCM R in dom p
  implies
  (p is autonomic iff Relocated (p,k) is autonomic)
  proof
  assume that
A1:R is non trivial and
A2:IC SCM R in dom p;
   hereby assume
A3: p is autonomic;
   thus Relocated (p,k) is autonomic
   proof
    let s1,s2 be State of SCM R such that
A4:   Relocated (p,k) c= s1 & Relocated (p,k) c= s2;
    let i be Nat;
A5:  (Computation s1).i
     = (Computation(s1 +* p)).i +* Start-At (IC(Computation(s1 +* p)).i + k)
        +* s1|dom ProgramPart p +* ProgramPart (Relocated (p,k))
 by A1,A2,A3,A4,Th62;
A6:  (Computation s2).i
     = (Computation(s2 +* p)).i +* Start-At (IC(Computation(s2 +* p)).i + k)
        +* s2|dom ProgramPart p +* ProgramPart (Relocated (p,k))
 by A1,A2,A3,A4,Th62;
       p c= s1 +* p & p c= s2 +* p by FUNCT_4:26;
then A7:  (Computation (s1 +* p)).i|dom (p ) = (Computation (s2 +* p)).i|dom (p
)
 by A3,AMI_1:def 25;
A8:  dom (Start-At ((IC p)+k)) = {IC SCM R} by AMI_3:34;
A9: dom (Start-At ((IC (Computation(s1 +* p)).i)+k)) = {IC SCM R} by AMI_3:34;
A10: dom (Start-At ((IC (Computation(s2 +* p)).i)+k)) = {IC SCM R} by AMI_3:34;
A11:  {IC SCM R} c= dom p by A2,ZFMISC_1:37;
A12:  Start-At (IC(Computation(s1 +* p)).i)
     = (Computation(s1 +* p)).i|{IC SCM R} by AMI_5:34
    .= (Computation(s2 +* p)).i|{IC SCM R} by A7,A11,RELAT_1:188
    .= Start-At (IC(Computation(s2 +* p)).i) by AMI_5:34;
A13:dom (Start-At ((IC p) + k))
    misses dom ProgramPart (Relocated (p,k)) by A8,AMI_5:68;
      dom ProgramPart p c= the carrier of SCM R by AMI_3:37;
    then dom ProgramPart p c= dom s1 by AMI_3:36;
then A14:dom(s1|dom ProgramPart p) = dom ProgramPart p by RELAT_1:91;
then A15:dom (Start-At ((IC p) + k))
    misses dom (s1| dom ProgramPart p) by A8,AMI_5:68;
      dom ProgramPart p c= the carrier of SCM R by AMI_3:37;
    then dom ProgramPart p c= dom s2 by AMI_3:36;
then A16:dom(s2|dom ProgramPart p) = dom ProgramPart p by RELAT_1:91;
then A17:dom (Start-At ((IC p) + k))
    misses dom (s2| dom ProgramPart p) by A8,AMI_5:68;
A18: (Computation s1).i|dom (Start-At ((IC p)+k))
    = ((Computation(s1 +* p)).i +* Start-At (IC(Computation(s1 +* p)).i + k)
        +* s1|dom ProgramPart p)
       |dom (Start-At ((IC p)+k)) by A5,A13,FUNCT_4:76
   .= ((Computation(s1 +* p)).i +* Start-At (IC(Computation(s1 +* p)).i + k))
       |dom (Start-At ((IC p)+k)) by A15,FUNCT_4:76
   .= Start-At (IC(Computation(s1 +* p)).i + k) by A8,A9,FUNCT_4:24
   .= Start-At (IC(Computation(s2 +* p)).i + k) by A12,Th9
   .= ((Computation(s2 +* p)).i +* Start-At (IC(Computation(s2 +* p)).i + k))
      |dom (Start-At ((IC p)+k)) by A8,A10,FUNCT_4:24
   .= ((Computation(s2 +* p)).i +* Start-At (IC(Computation(s2 +* p)).i + k)
        +* s2|dom ProgramPart p)
       |dom (Start-At ((IC p)+k)) by A17,FUNCT_4:76
   .= (Computation s2).i|dom (Start-At ((IC p)+k)) by A6,A13,FUNCT_4:76;
A19:  (Computation s1).i|dom (IncAddr(Shift(ProgramPart(p),k),k))
    = (Computation s1).i|dom (ProgramPart (Relocated (p,k)))
 by Th48
   .= ProgramPart (Relocated (p,k)) by A5,FUNCT_4:24
   .= (Computation s2).i|dom (ProgramPart (Relocated (p,k)))
 by A6,FUNCT_4:24
   .= (Computation s2).i|dom (IncAddr(Shift(ProgramPart(p),k),k))
 by Th48;
         DataPart p c= p by AMI_5:62;
then A20:  dom DataPart p c= dom p by GRFUNC_1:8;
A21:  dom(DataPart p) misses dom(ProgramPart(Relocated (p,k)))by AMI_5:71;
A22: dom(DataPart p) misses dom(s1|dom ProgramPart p) by A14,AMI_5:71;
A23: dom(DataPart p) misses dom(s2|dom ProgramPart p) by A16,AMI_5:71;
A24: dom(DataPart p) misses dom (Start-At (IC(Computation(s1 +* p)).i + k))
 by A9,AMI_5:67;
A25: dom(DataPart p) misses dom (Start-At (IC(Computation(s2 +* p)).i + k))
 by A10,AMI_5:67;
A26:    (Computation s1).i|dom (DataPart p)
    = ((Computation(s1 +* p)).i +* Start-At (IC(Computation(s1 +* p)).i + k)
      +* s1|dom ProgramPart p)
      | dom(DataPart p) by A5,A21,FUNCT_4:76
   .= ((Computation(s1 +* p)).i +* Start-At (IC(Computation(s1 +* p)).i + k))
      | dom(DataPart p) by A22,FUNCT_4:76
   .= ((Computation(s1 +* p)).i) | dom (DataPart p) by A24,FUNCT_4:76
   .= ((Computation(s2 +* p)).i) | dom (DataPart p) by A7,A20,RELAT_1:188
   .= ((Computation(s2 +* p)).i +* Start-At (IC(Computation(s2 +* p)).i + k))
      | dom(DataPart p) by A25,FUNCT_4:76
   .= ((Computation(s2 +* p)).i +* Start-At (IC(Computation(s2 +* p)).i + k)
      +* s2|dom ProgramPart p)
      | dom(DataPart p) by A23,FUNCT_4:76
   .= (Computation s2).i|dom (DataPart p) by A6,A21,FUNCT_4:76;
A27:    (Computation s1).i|dom (Start-At ((IC p)+k) +*
       IncAddr(Shift(ProgramPart(p),k),k))
     = (Computation s1).i|(dom (Start-At ((IC p)+k)) \/
       dom (IncAddr(Shift(ProgramPart(p),k),k))) by FUNCT_4:def 1
    .= (Computation s2).i|dom (Start-At ((IC p)+k)) \/
       (Computation s2).i|dom (IncAddr(Shift(ProgramPart(p),k),k)) by A18,A19,
RELAT_1:107
    .= (Computation s2).i|(dom (Start-At ((IC p)+k)) \/
       dom (IncAddr(Shift(ProgramPart(p),k),k))) by RELAT_1:107
    .= (Computation s2).i|dom (Start-At ((IC p)+k) +*
       IncAddr(Shift(ProgramPart(p),k),k)) by FUNCT_4:def 1;
    thus (Computation s1).i|dom Relocated (p,k)
     = (Computation s1).i|dom (Start-At ((IC p)+k) +*
       IncAddr(Shift(ProgramPart(p),k),k) +* DataPart p) by Def2
    .= (Computation s1).i|(dom (Start-At ((IC p)+k) +*
       IncAddr(Shift(ProgramPart(p),k),k)) \/ dom (DataPart p))
         by FUNCT_4:def 1
    .= (Computation s2).i|dom (Start-At ((IC p)+k) +*
       IncAddr(Shift(ProgramPart(p),k),k)) \/
       (Computation s2).i|dom (DataPart p) by A26,A27,RELAT_1:107
    .= (Computation s2).i|(dom (Start-At ((IC p)+k) +*
       IncAddr(Shift(ProgramPart(p),k),k)) \/ dom (DataPart p)) by RELAT_1:107
    .= (Computation s2).i|dom (Start-At ((IC p)+k) +*
       IncAddr(Shift(ProgramPart(p),k),k) +* DataPart p) by FUNCT_4:def 1
    .= (Computation s2).i|dom Relocated (p,k) by Def2;
   end;
  end;

  assume
A28: Relocated (p,k) is autonomic;
    let s1,s2 be State of SCM R such that
A29:   p c= s1 & p c= s2;
    let i be Nat;
A30:  (Computation s1).i
     = (Computation(s1 +* Relocated (p,k))).i
     +* Start-At (IC(Computation(s1 +* Relocated (p,k))).i -' k)
        +* s1|dom ProgramPart Relocated(p,k) +* ProgramPart (p)
 by A1,A2,A28,A29,Th63;
A31:  (Computation s2).i
     = (Computation(s2 +* Relocated (p,k))).i
     +* Start-At (IC(Computation(s2 +* Relocated (p,k))).i -' k)
        +* s2|dom ProgramPart Relocated(p,k) +* ProgramPart (p)
 by A1,A2,A28,A29,Th63;
        Relocated (p,k) c= s1 +* Relocated (p,k) &
      Relocated (p,k) c= s2 +* Relocated (p,k) by FUNCT_4:26;
then A32:  (Computation (s1 +* Relocated (p,k))).i|dom (Relocated (p,k))
   = (Computation (s2 +* Relocated (p,k))).i|dom (Relocated (p,k))
      by A28,AMI_1:def 25;
A33:  dom (Start-At (IC p)) = {IC SCM R} by AMI_3:34;
A34: dom (Start-At ((IC (Computation(s1 +* Relocated (p,k))).i) -' k))
     = {IC SCM R} by AMI_3:34;
A35: dom (Start-At ((IC (Computation(s2 +* Relocated (p,k))).i) -' k))
     = {IC SCM R} by AMI_3:34;
       IC SCM R in dom Relocated (p,k) by Th51;
then A36:  {IC SCM R} c= dom Relocated (p,k) by ZFMISC_1:37;
A37: Start-At (IC(Computation(s1 +* Relocated (p,k))).i)
      = (Computation(s1 +* Relocated (p,k))).i|{IC SCM R} by AMI_5:34
     .= (Computation(s2 +* Relocated (p,k))).i|{IC SCM R}
          by A32,A36,RELAT_1:188
     .= Start-At (IC(Computation(s2 +* Relocated (p,k))).i) by AMI_5:34;
A38: dom (Start-At (IC p)) misses dom (ProgramPart p) by A33,AMI_5:68;
      dom ProgramPart Relocated(p,k) c= the carrier of SCM R by AMI_3:37;
    then dom ProgramPart Relocated(p,k) c= dom s1 by AMI_3:36;
then A39:dom(s1|dom ProgramPart Relocated(p,k))
         = dom ProgramPart Relocated(p,k) by RELAT_1:91;
then A40:dom (Start-At (IC p)) misses dom (s1|dom ProgramPart Relocated(p,k))
 by A33,AMI_5:68;
      dom ProgramPart Relocated(p,k) c= the carrier of SCM R by AMI_3:37;
    then dom ProgramPart Relocated(p,k) c= dom s2 by AMI_3:36;
then A41:dom(s2|dom ProgramPart Relocated(p,k))
         = dom ProgramPart Relocated(p,k) by RELAT_1:91;
then A42:dom (Start-At (IC p)) misses dom (s2|dom ProgramPart Relocated(p,k))
 by A33,AMI_5:68;

A43:  (Computation s1).i|dom (Start-At (IC p))
    = ((Computation(s1 +* Relocated (p,k))).i
      +* Start-At (IC(Computation(s1 +* Relocated (p,k))).i -' k)
      +* s1|dom ProgramPart Relocated(p,k))
       |dom (Start-At (IC p)) by A30,A38,FUNCT_4:76
   .= ((Computation(s1 +* Relocated (p,k))).i
      +* Start-At (IC(Computation(s1 +* Relocated (p,k))).i -' k))
       |dom (Start-At (IC p)) by A40,FUNCT_4:76
   .= Start-At (IC(Computation(s1 +* Relocated (p,k))).i -' k)
 by A33,A34,FUNCT_4:24
   .= Start-At (IC(Computation(s2 +* Relocated (p,k))).i -' k)
 by A37,Th10
   .= ((Computation(s2 +* Relocated (p,k))).i
      +* Start-At (IC(Computation(s2 +* Relocated (p,k))).i -' k))
      |dom (Start-At (IC p)) by A33,A35,FUNCT_4:24
   .= ((Computation(s2 +* Relocated (p,k))).i
      +* Start-At (IC(Computation(s2 +* Relocated (p,k))).i -' k)
      +* s2|dom ProgramPart Relocated(p,k))
       |dom (Start-At (IC p)) by A42,FUNCT_4:76
   .= (Computation s2).i|dom (Start-At (IC p)) by A31,A38,FUNCT_4:76;
A44:  (Computation s1).i|dom (ProgramPart p)
    = ProgramPart (p) by A30,FUNCT_4:24
   .= (Computation s2).i|dom (ProgramPart p) by A31,FUNCT_4:24;
        DataPart (Relocated(p,k)) c= Relocated(p,k) by AMI_5:62;
      then DataPart p c= Relocated(p,k) by Th47;
then A45: dom (DataPart p) c= dom (Relocated(p,k)) by GRFUNC_1:8;
A46:  dom (DataPart p) misses dom (ProgramPart p) by AMI_5:71;
A47: dom (DataPart p) misses dom (s1|dom ProgramPart Relocated(p,k))
 by A39,AMI_5:71;
A48: dom (DataPart p) misses dom (s2|dom ProgramPart Relocated(p,k))
 by A41,AMI_5:71;
A49: dom(DataPart p) misses
      dom(Start-At (IC(Computation(s1 +* Relocated (p,k))).i -' k))
 by A34,AMI_5:67;
A50: dom(DataPart p) misses
      dom(Start-At (IC(Computation(s2 +* Relocated (p,k))).i -' k))
 by A35,AMI_5:67;
A51: (Computation s1).i|dom (DataPart p)
    = ((Computation(s1 +* Relocated (p,k))).i
      +* Start-At (IC(Computation(s1 +* Relocated (p,k))).i -' k)
      +* s1|dom ProgramPart Relocated(p,k))
      | dom(DataPart p) by A30,A46,FUNCT_4:76
   .= ((Computation(s1 +* Relocated (p,k))).i +*
       Start-At (IC(Computation(s1 +* Relocated (p,k))).i -' k))
      | dom(DataPart p) by A47,FUNCT_4:76
   .= ((Computation(s1 +* Relocated (p,k))).i) | dom (DataPart p)
 by A49,FUNCT_4:76
   .= ((Computation(s2 +* Relocated (p,k))).i) | dom (DataPart p)
 by A32,A45,RELAT_1:188
   .= ((Computation(s2 +* Relocated (p,k))).i +*
      Start-At (IC(Computation(s2 +* Relocated (p,k))).i -' k))
      | dom(DataPart p) by A50,FUNCT_4:76
   .= ((Computation(s2 +* Relocated (p,k))).i
      +* Start-At (IC(Computation(s2 +* Relocated (p,k))).i -' k)
      +* s2|dom ProgramPart Relocated(p,k))
      | dom(DataPart p) by A48,FUNCT_4:76
   .= (Computation s2).i|dom (DataPart p) by A31,A46,FUNCT_4:76;

A52:    (Computation s1).i|dom (Start-At (IC p) +* ProgramPart p)
     = (Computation s1).i|(dom (Start-At (IC p)) \/ dom (ProgramPart p))
 by FUNCT_4:def 1
    .= (Computation s2).i|dom (Start-At (IC p)) \/
       (Computation s2).i|dom (ProgramPart p) by A43,A44,RELAT_1:107
    .= (Computation s2).i|(dom (Start-At (IC p)) \/ dom (ProgramPart p))
 by RELAT_1:107
    .= (Computation s2).i|dom (Start-At (IC p) +* ProgramPart p)
 by FUNCT_4:def 1;
  thus (Computation s1).i|dom p
     = (Computation s1).i|dom (Start-At (IC p) +* ProgramPart p +*
        DataPart p ) by A2,AMI_5:75
    .= (Computation s1).i|(dom (Start-At (IC p) +* ProgramPart p) \/
        dom (DataPart p)) by FUNCT_4:def 1
    .= (Computation s2).i|dom (Start-At (IC p) +* ProgramPart p ) \/
       (Computation s2).i|dom (DataPart p) by A51,A52,RELAT_1:107
    .= (Computation s2).i|(dom (Start-At (IC p) +* ProgramPart p) \/
        dom (DataPart p)) by RELAT_1:107
    .= (Computation s2).i|dom (Start-At (IC p) +*
        ProgramPart p +* DataPart p) by FUNCT_4:def 1
    .= (Computation s2).i|dom p by A2,AMI_5:75;
  end;

theorem Th65:
  R is non trivial implies
  for p being halting autonomic FinPartState of SCM R st IC SCM R in dom p
   holds
  DataPart Result p = DataPart Result Relocated(p,k)
  proof
  assume
  A1:R is non trivial;
   let p being halting autonomic FinPartState of SCM R such that
A2: IC SCM R in dom p;
   consider s being State of SCM R such that
A3: p c= s by AMI_3:39;
      s is halting by A3,AMI_1:def 26;
   then consider j1 being Nat such that
A4: Result(s) = (Computation s).j1 and
A5: CurInstr(Result(s)) = halt SCM R by AMI_1:def 22;
   consider t being State of SCM R such that
A6: Relocated(p,k) c= t by AMI_3:39;
    reconsider s3 = s +* t|SCM-Data-Loc as State of SCM R by AMI_5:82;
A7:    s3 = s3;
      t.(IC ((Computation t).j1))
     = ((Computation t).j1).(IC ((Computation t).j1)) by AMI_1:54
    .= CurInstr((Computation t).j1) by AMI_1:def 17
    .= IncAddr(CurInstr((Computation s).j1), k) by A1,A2,A3,A6,A7,Th59
    .= halt SCM R by A4,A5,AMISTD_2:29;
then A8: Result t = (Computation t).j1 by AMI_1:56;
A9: Relocated(p,k) is halting & Relocated(p,k) is autonomic by A1,A2,Th60,Th64;
   thus DataPart(Result(p))
      = (Result p) | SCM-Data-Loc by Th24
     .= (Result s) | dom p | SCM-Data-Loc by A3,AMI_1:def 28
     .= (Result s) | (dom p /\ SCM-Data-Loc) by RELAT_1:100
     .= (Result s) | dom (p | SCM-Data-Loc) by FUNCT_1:68
     .= (Result s) | dom (DataPart p) by Th24
     .= (Result t) | dom (DataPart Relocated(p,k)) by A1,A2,A3,A4,A6,A7,A8,Th59
     .= (Result t) | dom (Relocated(p,k) | SCM-Data-Loc) by Th24
     .= (Result t) | (dom Relocated(p,k) /\ SCM-Data-Loc) by FUNCT_1:68
     .= (Result t) | dom Relocated(p,k) | SCM-Data-Loc by RELAT_1:100
     .= (Result Relocated(p,k)) | SCM-Data-Loc by A6,A9,AMI_1:def 28
     .= DataPart (Result(Relocated(p,k))) by Th24;
  end;

theorem
   R is non trivial implies
  for F being PartFunc of FinPartSt SCM R, FinPartSt SCM R
   st IC SCM R in dom p & F is data-only holds
  p computes F iff Relocated (p,k) computes F
  proof
    assume
 A1: R is non trivial;
  let F be PartFunc of FinPartSt SCM R, FinPartSt SCM R such that
A2: IC SCM R in dom p and
A3: F is data-only;
  hereby assume
A4:  p computes F;
    thus Relocated (p,k) computes F
    proof
    let x be set;
    assume
A5: x in dom F;
      dom F c= FinPartSt SCM R by RELSET_1:12;
    then reconsider s = x as data-only FinPartState of SCM R
      by A3,A5,AMI_3:32,AMI_5:def 9;
    take s;
    thus x=s;
    consider s1 being FinPartState of SCM R such that
A6: x = s1 & p +* s1 is pre-program of SCM R &
     F.s1 c= Result(p +* s1) by A4,A5,AMI_1:def 29;
     reconsider Fs1 = F.s1 as FinPartState of SCM R by A6,AMI_5:61;
A7: Fs1 is data-only by A3,A5,A6,AMI_5:def 9;
then A8: F.s1 c= DataPart(Result(p +* s1)) by A6,AMI_5:74;
A9:Relocated(p,k) +* s = Relocated((p +* s) ,k) by A2,Th57;
      dom(p +* s) = dom p \/ dom s by FUNCT_4:def 1;
then A10: IC SCM R in dom(p +* s) by A2,XBOOLE_0:def 2;
    hence Relocated(p,k) +* s is pre-program of SCM R by A1,A6,A9,Th60,Th64;
      DataPart(Result(p +* s1))
     = DataPart(Result(Relocated(p +* s,k))) by A1,A6,A10,Th65
    .= DataPart(Result(Relocated(p,k) +* s)) by A2,Th57;
    hence F.s c= Result(Relocated(p,k) +* s) by A6,A7,A8,AMI_5:74;
    end;
  end;

  assume
A11:  Relocated (p,k) computes F;
    let x be set;
    assume
A12: x in dom F;
      dom F c= FinPartSt SCM R by RELSET_1:12;
    then reconsider s = x as data-only FinPartState of SCM R
      by A3,A12,AMI_3:32,AMI_5:def 9;
    take s;
    thus x=s;
    consider s1 being FinPartState of SCM R such that
A13: x = s1 & Relocated (p,k) +* s1 is pre-program of SCM R &
    F.s1 c= Result (Relocated (p,k) +* s1) by A11,A12,AMI_1:def 29;
    reconsider Fs1 = F.s1 as FinPartState of SCM R by A13,AMI_5:61;
A14: Fs1 is data-only by A3,A12,A13,AMI_5:def 9;
then A15: F.s1 c= DataPart(Result(Relocated(p,k) +* s1)) by A13,AMI_5:74;
A16: Relocated(p,k) +* s = Relocated((p +* s),k) by A2,Th57;
      dom(p +* s) = dom p \/ dom s by FUNCT_4:def 1;
then A17: IC SCM R in dom(p +* s) by A2,XBOOLE_0:def 2;
    then A18: p +* s is autonomic by A1,A13,A16,Th64;
    hence p +* s is pre-program of SCM R by A1,A13,A16,A17,Th60;
    A19: p +* s is halting by A1,A13,A16,A17,A18,Th60;
      DataPart(Result(Relocated(p,k) +* s1))
      = DataPart(Result(Relocated(p +* s,k))) by A2,A13,Th57
     .= DataPart(Result(p +* s)) by A1,A17,A18,A19,Th65;
    hence F.s c= Result(p +* s) by A13,A14,A15,AMI_5:74;
 end;
