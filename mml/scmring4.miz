:: Relocability for { \bf SCM } over Ring
::  by Artur Korni{\l}owicz and Yasunari Shidama
::
:: Received February 6, 2004
:: Copyright (c) 2004-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies ORDINAL1, SUBSET_1, NUMBERS, XBOOLE_0, SETFAM_1, FUNCSDOM, AMI_3,
      AMI_1, FSM_1, STRUCT_0, AMI_2, FUNCT_1, TARSKI, RELAT_1, AMISTD_2,
      ARYTM_3, FUNCT_4, CIRCUIT2, CARD_1, GRAPHSP, ARYTM_1, SUPINF_2, FUNCOP_1,
      ZFMISC_1, PARTFUN1, RELOC, NAT_1, AMISTD_5, COMPOS_1, FINSET_1,
      GOBRD13, MEMSTR_0, EXTPRO_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, DOMAIN_1, ORDINAL1, RELAT_1,
      FINSET_1, NUMBERS, FUNCT_1, PARTFUN1, STRUCT_0, ALGSTR_0, FUNCSDOM,
      FUNCOP_1, XCMPLX_0, NAT_1, FUNCT_4, FUNCT_7, NAT_D, VALUED_1, PBOOLE,
      MEMSTR_0, COMPOS_0, COMPOS_1, EXTPRO_1, AMI_2, AMI_3, SCMRING1, SCMRING2,
      SCMRING3, AMISTD_2, AMISTD_5;
 constructors XXREAL_0, REALSET2, AMI_3, AMISTD_2, SCMRING3, PRE_POLY, NAT_D,
      AMISTD_1, AMISTD_5, PBOOLE, INT_3, FUNCT_7, RELSET_1, MEMSTR_0, SCMRING1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, XREAL_0, NAT_1,
      CARD_3, STRUCT_0, AMI_3, SCMRING2, AMISTD_2, SCMRING3, FINSET_1,
      ORDINAL1, RELSET_1, GRFUNC_1, FUNCT_2, VALUED_1, FUNCT_4, COMPOS_1,
      EXTPRO_1, AMISTD_5, AMI_5, PBOOLE, PRE_POLY, FUNCT_7, ZFMISC_1, SUBSET_1,
      MEMSTR_0, NUMBERS, INT_1, CARD_1, AMI_2, INT_3, COMPOS_0;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCT_1, EXTPRO_1, FUNCOP_1, AMI_3, AMI_2, AMISTD_1, AMISTD_2,
      NAT_1, COMPOS_1, AMISTD_5, STRUCT_0, MEMSTR_0, COMPOS_0;
 theorems TARSKI, NAT_1, SCMRING2, AMI_3, FUNCT_4, FUNCT_1, ZFMISC_1, FUNCOP_1,
      SCMRING1, AMI_2, STRUCT_0, XBOOLE_0, XBOOLE_1, RELAT_1, GRFUNC_1,
      SCMRING3, AMISTD_2, PBOOLE, PARTFUN1, ORDINAL1, COMPOS_1, EXTPRO_1,
      AMISTD_5, MEMSTR_0, COMPOS_0, XTUPLE_0;
 schemes NAT_1;

begin :: SCM R

reserve i, j, k for Element of NAT,
  n for Element of NAT,
  IL for non empty set,
  N for with_non-empty_elements set;

reserve R for non trivial Ring,
  a, b for Data-Location of R,
  loc for Element of NAT,
  I for Instruction of SCM R,
  p for FinPartState of SCM R,
  s, s1, s2 for State of SCM R,
  P,P1,P2 for Instruction-Sequence of SCM R,
  q for FinPartState of SCM;

theorem Th1:
  dl.(R,n) = [1,n]
proof
  thus dl.(R,n) = dl.n by SCMRING3:def 1
    .= [1,n];
end;

theorem
  for dl being Data-Location of R ex i being Element of NAT st dl = dl.(
  R,i)
proof
  let dl be Data-Location of R;
  dl in Data-Locations SCM by SCMRING2:1;
  then consider i being Element of NAT such that
A1: dl = [1,i] by AMI_2:23,AMI_3:27;
  take i;
  thus thesis by A1,Th1;
end;

theorem
  for i,j being Element of NAT holds i <> j implies dl.(R,i) <> dl.(R,j)
proof
  let i,j be Element of NAT;
  assume
A1: i <> j;
  dl.(R,j) = [1,j] & dl.(R,i) = [1,i] by Th1;
  hence thesis by A1,XTUPLE_0:1;
end;

theorem
  Data-Locations SCM c= dom s
proof
  Data-Locations SCM R = Data-Locations SCM by SCMRING2:22;
  hence thesis by MEMSTR_0:8;
end;

theorem Th5:
  s.a = (s +* Start-At(loc,SCM R)).a
proof
  a in the carrier of SCM R;
  then a in dom s by PARTFUN1:def 2;
  then
A1: dom (Start-At(loc,SCM R)) = {IC SCM R} & a in dom s \/
dom (Start-At(loc,SCM R)) by FUNCOP_1:13,XBOOLE_0:def 3;
  a <> IC SCM R by SCMRING3:2;
  then not a in {IC SCM R} by TARSKI:def 1;
  hence thesis by A1,FUNCT_4:def 1;
end;

theorem Th6:
  for s1,s2 being State of SCM R st IC(s1) = IC(s2) &
  (for a being Data-Location of R holds s1.a = s2.a)
    holds  s1 =  s2
proof
  let s1,s2 be State of SCM R such that
A1: IC(s1) = IC(s2);
    IC SCM R in dom s1 & IC SCM R in dom s2 by MEMSTR_0:2;
    then
A2:  s1 = DataPart s1 +* Start-At (IC s1,SCM R) &
     s2 = DataPart s2 +* Start-At (IC s2,SCM R) by MEMSTR_0:26;
  assume
A3: for a being Data-Location of R holds s1.a = s2.a;
   DataPart s1 = DataPart s2
    proof
A4:   dom DataPart s1 = Data-Locations SCM R by MEMSTR_0:9;
     hence
    dom DataPart s1 = dom DataPart s2 by MEMSTR_0:9;
     let x be set;
     assume
A5:     x in dom DataPart s1;
      then
A6:   x is Data-Location of R by A4,SCMRING2:23;
     thus (DataPart s1).x = s1.x by A5,A4,FUNCT_1:49
         .= s2.x by A6,A3
         .= (DataPart s2).x by A5,A4,FUNCT_1:49;
    end;
  hence thesis by A1,A2;
end;

registration let R;
 cluster SCM R -> relocable;
 coherence
 proof let INS be Instruction of SCM R, j,k be Nat;
   reconsider k as Element of NAT by ORDINAL1:def 12;
  let s be State of SCM R;
A1: IC IncIC(Exec(IncAddr(INS,j),s),k)
       = IC Exec(IncAddr(INS,j),s) + k by MEMSTR_0:53
      .= IC Exec(IncAddr(INS,j+k),IncIC(s,k)) by AMISTD_2:def 3;
  per cases by NAT_1:31,SCMRING3:39;
  suppose InsCode INS = 0;
    then
A2: INS = halt SCM R by SCMRING3:12;
    Exec(IncAddr(INS,j+k),IncIC(s,k))
       = IncIC(s,k) by A2,EXTPRO_1:def 3
      .= IncIC(Exec(IncAddr(INS,j),s),k) by A2,EXTPRO_1:def 3;
   hence thesis;
  end;
  suppose InsCode INS = 1;
    then consider da,db being Data-Location of R such that
A3: INS = da := db by SCMRING3:13;
    now
      let d be Data-Location of R;
      per cases;
      suppose
A4:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A3,COMPOS_0:4
          .= IncIC(s,k).db by A3,A4,SCMRING2:11
          .= s.db by Th5
          .= Exec(INS, s).d by A3,A4,SCMRING2:11
          .= Exec(IncAddr(INS,j), s).d by A3,COMPOS_0:4
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th5;
      end;
      suppose
A5:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A3,COMPOS_0:4
          .= IncIC(s,k).d by A3,A5,SCMRING2:11
          .= s.d by Th5
          .= Exec(INS, s).d by A3,A5,SCMRING2:11
          .= Exec(IncAddr(INS,j), s).d by A3,COMPOS_0:4
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th5;
      end;
    end;
   hence thesis by Th6,A1;
  end;
  suppose InsCode INS = 2;
    then consider da,db being Data-Location of R such that
A6: INS = AddTo(da, db) by SCMRING3:14;
    now let d be Data-Location of R;
      per cases;
      suppose
A7:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A6,COMPOS_0:4
          .= IncIC(s,k).da + IncIC(s,k).db by A7,A6,SCMRING2:12
          .= s.da + IncIC(s,k).db by Th5
          .= s.da + s.db by Th5
          .= Exec(INS, s).d by A6,A7,SCMRING2:12
          .= Exec(IncAddr(INS,j), s).d by A6,COMPOS_0:4
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th5;
      end;
      suppose
A8:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A6,COMPOS_0:4
          .= IncIC(s,k).d by A6,A8,SCMRING2:12
          .= s.d by Th5
          .= Exec(INS, s).d by A6,A8,SCMRING2:12
          .= Exec(IncAddr(INS,j), s).d by A6,COMPOS_0:4
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th5;
      end;
    end;
   hence thesis by Th6,A1;
  end;
  suppose InsCode INS = 3;
    then consider da,db being Data-Location of R such that
A9: INS = SubFrom(da, db) by SCMRING3:15;
    now let d be Data-Location of R;
      per cases;
      suppose
A10:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A9,COMPOS_0:4
          .= IncIC(s,k).da - IncIC(s,k).db by A10,A9,SCMRING2:13
          .= s.da - IncIC(s,k).db by Th5
          .= s.da - s.db by Th5
          .= Exec(INS, s).d by A9,A10,SCMRING2:13
          .= Exec(IncAddr(INS,j), s).d by A9,COMPOS_0:4
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th5;
      end;
      suppose
A11:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A9,COMPOS_0:4
          .= IncIC(s,k).d by A9,A11,SCMRING2:13
          .= s.d by Th5
          .= Exec(INS, s).d by A9,A11,SCMRING2:13
          .= Exec(IncAddr(INS,j), s).d by A9,COMPOS_0:4
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th5;
      end;
    end;
    hence thesis by Th6,A1;
  end;
  suppose InsCode INS = 4;
    then consider da,db being Data-Location of R such that
A12: INS = MultBy(da, db) by SCMRING3:16;
    now let d be Data-Location of R;
      per cases;
      suppose
A13:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A12,COMPOS_0:4
          .= IncIC(s,k).da * IncIC(s,k).db by A13,A12,SCMRING2:14
          .= s.da * IncIC(s,k).db by Th5
          .= s.da * s.db by Th5
          .= Exec(INS, s).d by A12,A13,SCMRING2:14
          .= Exec(IncAddr(INS,j), s).d by A12,COMPOS_0:4
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th5;
      end;
      suppose
A14:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A12,COMPOS_0:4
          .= IncIC(s,k).d by A12,A14,SCMRING2:14
          .= s.d by Th5
          .= Exec(INS, s).d by A12,A14,SCMRING2:14
          .= Exec(IncAddr(INS,j), s).d by A12,COMPOS_0:4
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th5;
      end;
    end;
    hence thesis by Th6,A1;
  end;
  suppose InsCode INS = 5;
    then consider da being Data-Location of R,
                  r being Element of R such that
A15: INS = da:=r by SCMRING3:17;
    now let d be Data-Location of R;
      per cases;
      suppose
A16:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A15,COMPOS_0:4
          .= r by A16,A15,SCMRING2:17
          .= Exec(INS, s).d by A15,A16,SCMRING2:17
          .= Exec(IncAddr(INS,j), s).d by A15,COMPOS_0:4
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th5;
      end;
      suppose
A17:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A15,COMPOS_0:4
          .= IncIC(s,k).d by A15,A17,SCMRING2:17
          .= s.d by Th5
          .= Exec(INS, s).d by A15,A17,SCMRING2:17
          .= Exec(IncAddr(INS,j), s).d by A15,COMPOS_0:4
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th5;
      end;
    end;
    hence thesis by Th6,A1;
  end;
  suppose InsCode INS = 6;
    then consider loc being Element of NAT such that
A18: INS = goto(loc,R) by SCMRING3:18;
A19: IncAddr(INS, j+k) = goto(loc + (j+k),R) by A18,SCMRING3:37;
A20: IncAddr(INS, j) = goto (loc + j,R) by A18,SCMRING3:37;
    now let d be Data-Location of R;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = IncIC(s,k).d by A19,SCMRING2:15
          .= s.d by Th5
          .= Exec(IncAddr(INS,j), s).d by A20,SCMRING2:15
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th5;
    end;
    hence thesis by Th6,A1;
  end;
  suppose InsCode INS = 7;
    then consider da being Data-Location of R, loc being Element of NAT
    such that
A21: INS = da=0_goto loc by SCMRING3:19;
A22: IncAddr(INS, j+k) = da=0_goto (loc + (j+k)) by A21,SCMRING3:38;
A23: IncAddr(INS, j) = da=0_goto (loc + j) by A21,SCMRING3:38;
    now let d be Data-Location of R;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = IncIC(s,k).d by A22,SCMRING2:16
          .= s.d by Th5
          .= Exec(IncAddr(INS,j), s).d by A23,SCMRING2:16
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th5;
    end;
   hence thesis by A1,Th6;
  end;
 end;
end;

definition
  let R;
  let a be Data-Location of R;
  let r be Element of R;
  redefine func a .--> r -> FinPartState of SCM R;
  coherence
  proof
    set k = a .--> r, f = the_Values_of SCM R;
    reconsider b = a as Element of SCM-Memory by SCMRING2:def 1;
A1: dom k = {a} by FUNCOP_1:13;
    for x being set st x in dom k holds k.x in f.x
    proof
      let x be set;
      assume
A2:   x in dom k;
      then
     x = a by A1,TARSKI:def 1;
      then
A3:   k.x = r by FUNCOP_1:72;
      a in Data-Locations SCM by SCMRING2:1;
      then
A4:    a in SCM-Data-Loc by AMI_3:27;
      f.x = Values a by A1,A2,TARSKI:def 1
        .= (the_Values_of SCM R).a
        .= ((SCM-VAL R)*SCM-OK).a by SCMRING2:24
        .= the carrier of R by A4,SCMRING1:3;
      hence thesis by A3;
    end;
    hence thesis by FUNCT_1:def 14;
  end;
end;

registration let R be non trivial Ring;
 cluster SCM R -> IC-recognized;
 coherence
 proof
   for q being non halt-free finite
      (the InstructionsF of SCM R)-valued NAT-defined Function
   for p being q-autonomic
    FinPartState of SCM R st DataPart p <> {}
     holds IC SCM R in dom p
   proof
  let q be non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function;
  let p be q-autonomic FinPartState of SCM R;
  assume DataPart p <> {};
  then
A1: dom DataPart p <> {};
  assume
A2: not IC SCM R in dom p;
  p is not q-autonomic
  proof
    set il = the Element of (NAT) \ dom q;
    set d2 = the Element of Data-Locations SCM \ dom p;
    set d1 = the Element of dom DataPart p;
A3: d1 in dom DataPart p by A1;
    DataPart p c=  p by MEMSTR_0:12;
    then
A4:  dom DataPart p c= dom  p by RELAT_1:11;
    dom DataPart p c= the carrier of SCM R by RELAT_1:def 18;
    then reconsider d1 as Element of SCM R by A3;
    not Data-Locations SCM c= dom p;
    then
A5: Data-Locations SCM \ dom p <> {} by XBOOLE_1:37;
    then d2 in Data-Locations SCM by XBOOLE_0:def 5;
    then reconsider d2 as Data-Location of R by SCMRING2:1;
 not d2 in dom p by A5,XBOOLE_0:def 5;
    then
A6:  dom p misses {d2} by ZFMISC_1:50;
    not NAT c= dom q;
    then
A7: (NAT) \ dom q <> {} by XBOOLE_1:37;
    then reconsider il as Element of NAT by XBOOLE_0:def 5;
A8: not il in dom q by A7,XBOOLE_0:def 5;
    Data-Locations SCM R = Data-Locations SCM by SCMRING2:22;
    then dom DataPart p c= Data-Locations SCM by RELAT_1:58;
    then reconsider d1 as Data-Location of R by A3,SCMRING2:1;
A9: dom (( d2.--> 0.R) +* Start-At(il,SCM R))
     = dom (( d2.--> 0.R)) \/ dom(Start-At(il,SCM R))
    by FUNCT_4:def 1;
    set p1 = p +* ((d2.--> 0.R) +* Start-At(il,SCM R));
    set q1 = q +* (il .--> (d1:=d2));
    consider s1 being State of SCM R such that
A10: p1 c= s1 by PBOOLE:141;
    consider S1 being Instruction-Sequence of SCM R
       such that
A11: q1 c= S1 by PBOOLE:145;
A12: dom p1 = dom p \/ dom (( d2.--> 0.R) +*
    Start-At(il,SCM R)) by FUNCT_4:def 1;
A13: dom(Start-At(il,SCM R)) = {IC SCM R} by FUNCOP_1:13;
    then
A14: IC SCM R in dom (Start-At(il,SCM R)) by TARSKI:def 1;
    then
A15: IC SCM R in dom (( d2.--> 0.R) +* Start-At(il,SCM R))
    by A9,XBOOLE_0:def 3;
    then IC SCM R in dom p1 by A12,XBOOLE_0:def 3;
    then
A16: IC s1 = p1.IC SCM R by A10,GRFUNC_1:2
      .= (( d2.--> 0.R) +* Start-At(il,SCM R)).IC SCM R
      by A15,FUNCT_4:13
      .= (Start-At(il,SCM R)).IC SCM R by A14,FUNCT_4:13
      .= il by FUNCOP_1:72;
A17: dom(Start-At(il,SCM R)) = {IC SCM R} by FUNCOP_1:13;
A18: d2 <> IC SCM R by SCMRING3:2;
    then
A19: not d2 in dom (Start-At(il,SCM R)) by A13,TARSKI:def 1;
A20: not d2 in dom (Start-At(il,SCM R)) by A18,A17,TARSKI:def 1;
    dom (d2 .--> 0.R) = {d2} by FUNCOP_1:13;
    then d2 in dom (d2 .--> 0.R) by TARSKI:def 1;
    then
A21: d2 in dom (( d2.--> 0.R) +* Start-At(il,SCM R))
by A9,XBOOLE_0:def 3;
    then d2 in dom p1 by A12,XBOOLE_0:def 3;
    then
A22: s1.d2 = p1.d2 by A10,GRFUNC_1:2
      .= (( d2.--> 0.R) +* Start-At(il,SCM R)).d2 by A21,FUNCT_4:13
      .= ( d2.--> 0.R).d2 by A19,FUNCT_4:11
      .= 0.R by FUNCOP_1:72;
A23:  dom (il .--> (d1:=d2)) = {il} by FUNCOP_1:13;
      then
A24: il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
 dom q1 = dom q \/ dom ((il .--> (d1:=d2))) by FUNCT_4:def 1;
    then il in dom q1 by A24,XBOOLE_0:def 3;
    then
A25: S1.il = q1.il by A11,GRFUNC_1:2
      .= (il .--> (d1:=d2)).il by A24,FUNCT_4:13
      .= d1:=d2 by FUNCOP_1:72;
A26:  dom  p c= the carrier of SCM R by RELAT_1:def 18;
    dom Comput(S1,s1,1) = the carrier of SCM R by PARTFUN1:def 2;
    then
A27: dom (Comput(S1,s1,1)|dom  p) = dom  p by A26,RELAT_1:62;
    consider e being Element of R such that
A28: e <> 0.R by STRUCT_0:def 18;
    set p2 = p +* ((d2.--> e) +* Start-At(il,SCM R));
    set q2 = q +* (il .--> (d1:=d2));
    consider s2 being State of SCM R such that
A29: p2 c= s2 by PBOOLE:141;
    consider S2 being Instruction-Sequence of SCM R
    such that
A30: q2 c= S2 by PBOOLE:145;
A31: dom ( Comput(S2,s2,1)) = the carrier of SCM R
       by PARTFUN1:def 2;
A32: dom ( Comput(S2,s2,1)|dom  p) = dom  p
       by A26,A31,RELAT_1:62;
    dom p misses {IC SCM R} by A2,ZFMISC_1:50;
    then
A33: dom p /\ {IC SCM R} = {} by XBOOLE_0:def 7;
    take P = S1, Q = S2;
    dom (( d2.--> 0.R) +* Start-At(il,SCM R))
       = dom(( d2.--> 0.R)) \/ dom(Start-At(il,SCM R)) by FUNCT_4:def 1
      .= dom ( d2.--> 0.R) \/ {IC SCM R} by FUNCOP_1:13
      .= {d2} \/ {IC SCM R} by FUNCOP_1:13;
    then dom p /\ dom (( d2.--> 0.R) +* Start-At(il,SCM R))
       = dom p /\ {d2} \/ {} by A33,XBOOLE_1:23
      .= {} by A6,XBOOLE_0:def 7;
    then dom p misses dom (( d2.--> 0.R) +* Start-At(il,SCM R))
    by XBOOLE_0:def 7;
    then p c= p1 by FUNCT_4:32;
    then
A34:  p c= s1 by A10,XBOOLE_1:1;
A35:   dom q misses dom (il .--> (d1:=d2)) by A23,A8,ZFMISC_1:50;
     then q c= q1 by FUNCT_4:32;
    hence q c= P by A11,XBOOLE_1:1;
    dom (( d2.--> e) +* Start-At(il,SCM R))
       = dom(( d2.--> e)) \/ dom(Start-At(il,SCM R)) by FUNCT_4:def 1
      .= dom(( d2.--> e)) \/ {IC SCM R} by FUNCOP_1:13
      .= {d2} \/ {IC SCM R} by FUNCOP_1:13;
    then
    dom p /\ dom (( d2.--> e) +* Start-At(il,SCM R))
       = dom p /\ {d2} \/ {} by A33,XBOOLE_1:23
      .= {} by A6,XBOOLE_0:def 7;
    then dom p misses dom (( d2.--> e) +* Start-At(il,SCM R))
    by XBOOLE_0:def 7;
    then p c= p2 by FUNCT_4:32;
    then
A36:  p c= s2 by A29,XBOOLE_1:1;
     q c= q2 by A35,FUNCT_4:32;
    hence q c= Q by A30,XBOOLE_1:1;
    take s1, s2;
    thus  p c= s1 by A34;
    thus  p c= s2 by A36;
    take 1;
A37: dom (( d2.--> e) +* Start-At(il,SCM R))
    = dom (( d2.--> e)) \/ dom(Start-At(il,SCM R)) by FUNCT_4:def 1;
A38: dom (d2 .--> e) = {d2} by FUNCOP_1:13;
A39: dom p2 = dom p \/ dom (( d2.--> e) +* Start-At(
    il,SCM R)) by FUNCT_4:def 1;
A40: IC SCM R in dom (Start-At(il,SCM R)) by A17,TARSKI:def 1;
    then
A41: IC SCM R in dom (( d2.--> e) +* Start-At(il,SCM R) )
           by A37,XBOOLE_0:def 3;
    then IC SCM R in dom p2 by A39,XBOOLE_0:def 3;
    then
A42: IC s2 = p2.IC SCM R by A29,GRFUNC_1:2
      .= (( d2.--> e) +* Start-At(il,SCM R)).IC SCM R
      by A41,FUNCT_4:13
      .= (Start-At(il,SCM R)).IC SCM R by A40,FUNCT_4:13
      .= il by FUNCOP_1:72;
    dom (il .--> (d1:=d2)) = {il} by FUNCOP_1:13;
    then
A43: il in dom(il .--> (d1:=d2)) by TARSKI:def 1;
 dom q1 = dom q \/ dom ((il .--> (d1:=d2))) by FUNCT_4:def 1;
    then il in dom q2 by A43,XBOOLE_0:def 3;
    then
A44: S2.il = q2.il by A30,GRFUNC_1:2
      .= (il .--> (d1:=d2)).il by A43,FUNCT_4:13
      .= d1:=d2 by FUNCOP_1:72;
     d2 in dom (d2 .--> e) by A38,TARSKI:def 1;
    then
A45: d2 in dom (( d2.--> e) +* Start-At(il,SCM R))
by A37,XBOOLE_0:def 3;
    then d2 in dom p2 by A39,XBOOLE_0:def 3;
    then
A46: s2.d2 = p2.d2 by A29,GRFUNC_1:2
      .= (( d2.--> e) +* Start-At(il,SCM R)).d2 by A45,FUNCT_4:13
      .= (( d2.--> e)).d2 by A20,FUNCT_4:11
      .= e by FUNCOP_1:72;
A47:  S2/.il = S2.il by PBOOLE:143;
A48: Comput(S2,s2,0+1).d1 =
 (Following(S2,Comput(S2,s2,0))).d1 by EXTPRO_1:3
      .= (Following(S2,s2)).d1
      .= e by A42,A44,A46,A47,SCMRING2:11;
A49:  S1/.il = S1.il by PBOOLE:143;
    Comput(S1,s1,0+1).d1 = (Following(S1,Comput(S1,s1,0))).d1 by EXTPRO_1:3
      .= (Following(S1,s1)).d1
      .= 0.R by A16,A25,A22,A49,SCMRING2:11;
    then
   (Comput(P,s1,1)|dom  p).d1 = 0.R
     by A27,A3,A4,FUNCT_1:47;
    hence Comput(P,s1,1)|dom  p <> Comput(Q,s2,1)|dom  p
        by A28,A3,A32,A4,A48,FUNCT_1:47;
  end;
  hence contradiction;
 end;
   hence thesis by AMISTD_5:3;
end;
end;

registration let R be non trivial Ring;
 cluster SCM R -> CurIns-recognized;
 coherence
proof
  let q be non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function;
  let p be q-autonomic non empty FinPartState of SCM R,
      s be State of SCM R such that
A1:  p c= s;
  let P be Instruction-Sequence of SCM R such that
A2: q c= P;
  let i be Element of NAT;
  set Csi = Comput(P,s,i);
  set loc = IC Csi;
  set loc1 = loc+1;
  assume
A3:  not IC Comput(P,s,i) in dom q;
  set I = dl.(R,0) := dl.(R,0);
  set q1 = q +* (loc .--> I);
  set q2 = q +* (loc .--> halt SCM R);
  reconsider P1 = P +* (loc .--> I)
   as Instruction-Sequence of SCM R;
  reconsider P2 = P +* (loc .--> halt SCM R)
   as Instruction-Sequence of SCM R;
A4: dom (loc .--> halt SCM R) = {loc} by FUNCOP_1:13;
  then
A5: loc in dom (loc .--> halt SCM R) by TARSKI:def 1;
A6: dom (loc .--> I) = {loc} by FUNCOP_1:13;
  then
A7: loc in dom (loc .--> I) by TARSKI:def 1;
A8: dom q misses dom (loc .--> halt SCM R) by A3,A4,ZFMISC_1:50;
A9: dom q misses dom (loc .--> I) by A3,A6,ZFMISC_1:50;
A10: q1 c= P1 by A2,FUNCT_4:123;
A11: q2 c= P2 by A2,FUNCT_4:123;
  set Cs2i = Comput(P2,s,i), Cs1i = Comput(P1,s,i);
  p is not q-autonomic
  proof
    (loc .--> halt SCM R).loc = halt SCM R by FUNCOP_1:72;
    then
A12:  P2.loc = halt SCM R by A5,FUNCT_4:13;
A13:  (loc .--> I).loc = I by FUNCOP_1:72;
    take P1, P2;
    q c= q1 by A9,FUNCT_4:32;
    hence
A14:  q c= P1 by A10,XBOOLE_1:1;
    q c= q2 by A8,FUNCT_4:32;
    hence
A15:  q c= P2 by A11,XBOOLE_1:1;
    take s, s;
    thus  p c= s by A1;
A16: (Cs1i|dom  p) = (Csi|dom  p) by A14,A2,A1,EXTPRO_1:def 10;
    thus  p c= s by A1;
A17: (Cs1i|dom  p) = (Cs2i|dom  p) by A14,A15,A1,EXTPRO_1:def 10;
    take k = i+1;
    set Cs1k = Comput(P1,s,k);
A18: IC SCM R in dom p by AMISTD_5:6;
 IC Csi = IC(Csi|dom  p) by A18,FUNCT_1:49;
    then
  IC Cs1i = loc by A16,A18,FUNCT_1:49;
    then
A19: CurInstr(P1,Cs1i) = P1.loc by PBOOLE:143
         .= I by A13,A7,FUNCT_4:13;
A20: Cs1k = Following(P1,Cs1i) by EXTPRO_1:3
      .= Exec(I,Cs1i) by A19;
A21:  IC Exec(I,Cs1i) = succ IC Cs1i by SCMRING2:11;
A22: IC SCM R in dom p by AMISTD_5:6;
A23: IC Csi = IC(Csi|dom  p) by A22,FUNCT_1:49;
    then
A24: IC Cs1k = loc1 by A20,A21,A16,A22,FUNCT_1:49;
    set Cs2k = Comput(P2,s,k);
A25: Cs2k = Following(P2,Cs2i) by EXTPRO_1:3
      .= Exec (CurInstr(P2,Cs2i), Cs2i);
A26:  P2/.IC Cs2i = P2.IC Cs2i by PBOOLE:143;
    IC Cs2i = loc by A16,A23,A17,A22,FUNCT_1:49;
    then
A27: IC Cs2k = loc by A25,A12,A26,EXTPRO_1:def 3;
    IC(Cs1k|dom  p) = IC Cs1k & IC(Cs2k|dom  p) = IC Cs2k
     by A22,FUNCT_1:49;
    hence thesis by A24,A27;
  end;
  hence contradiction;
end;
end;

theorem Th7:
  for q being non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function
  for p being q-autonomic non empty
  FinPartState of SCM R st  p c= s1 &  p c= s2 &
  q c= P1 & q c= P2 &
  CurInstr(P1,Comput(P1,s1,n)) = a := b &
  a in dom p
   holds Comput(P1,s1,n).b = Comput(P2,s2,n).b
proof
  set Cs2i1 = Comput(P2,s2,n+1);
  set Cs1i1 = Comput(P1,s1,n+1);
  set Cs2i = Comput(P2,s2,n);
  set Cs1i = Comput(P1,s1,n);
  set I = CurInstr(P1,Comput(P1,s1,n));
  let q be non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function;
  let p be q-autonomic non empty FinPartState of SCM R such that
A1:  p c= s1 &  p c= s2 and
A2: q c= P1 & q c= P2;
A3: a in dom  p implies
 (Cs1i1|dom  p).a = Cs1i1.a & (Cs2i1|dom  p).a = Cs2i1.a
  by FUNCT_1:49;
A4: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:3
    .= Exec (CurInstr(P2,Cs2i), Cs2i);
  assume that
A5: I = a := b and
A6: a in dom p & Comput(P1,s1,n).b <> Comput(P2,s2,n)
.b;
  Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:3
    .= Exec (CurInstr(P1,Cs1i), Cs1i);
  then
A7: Cs1i1.a = Cs1i.b by A5,SCMRING2:11;
  I = CurInstr(P2,Comput(P2,s2,n)) by A1,A2,AMISTD_5:7;
  then Cs2i1.a = Cs2i.b by A4,A5,SCMRING2:11;
  hence contradiction by A1,A3,A6,A7,A2,EXTPRO_1:def 10;
end;

theorem Th8:
  for q being non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function
  for p being q-autonomic non empty
  FinPartState of SCM R st  p c= s1 &  p c= s2 &
  q c= P1 & q c= P2 &
  CurInstr(P1,Comput(P1,s1,n)) =
  AddTo(a,b) & a in dom p holds Comput(P1,s1,n).a + Comput(P1,s1,n).b =
     Comput(P2,s2,n).a + Comput(P2,s2,n).b
proof
  set Cs2i1 = Comput(P2,s2,n+1);
  set Cs1i1 = Comput(P1,s1,n+1);
  set Cs2i = Comput(P2,s2,n);
  set Cs1i = Comput(P1,s1,n);
  set I = CurInstr(P1,Comput(P1,s1,n));
  let q be non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function;
  let p be q-autonomic non empty FinPartState of SCM R such that
A1:  p c= s1 &  p c= s2 and
A2: q c= P1 & q c= P2;
A3: a in dom  p
 implies (Cs1i1|dom  p).a = Cs1i1.a & (Cs2i1|dom  p).a = Cs2i1.a
  by FUNCT_1:49;
A4: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:3
    .= Exec (CurInstr(P2,Cs2i), Cs2i);
  assume that
A5: I = AddTo(a,b) and
A6: a in dom p & Comput(P1,s1,n).a
    + Comput(P1,s1,n).b <>
  Comput(P2,s2,n). a + Comput(P2,s2,n).b;
  Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:3
    .= Exec (CurInstr(P1,Cs1i), Cs1i);
  then
A7: Cs1i1.a = Cs1i.a + Cs1i.b by A5,SCMRING2:12;
  I = CurInstr(P2,Comput(P2,s2,n))
   by A1,A2,AMISTD_5:7;
  then Cs2i1.a = Cs2i.a + Cs2i.b by A4,A5,SCMRING2:12;
  hence contradiction by A1,A3,A6,A7,A2,EXTPRO_1:def 10;
end;

theorem Th9:
  for q being non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function
  for p being q-autonomic non empty
  FinPartState of SCM R st  p c= s1 &  p c= s2 &
  q c= P1 & q c= P2 &
  CurInstr(P1,Comput(P1,s1,n)) =
  SubFrom(a, b) & a in dom p holds Comput(P1,s1,n).a - Comput(
P1,s1,n).b =
  Comput(P2,s2,n).a - Comput(P2,s2,n).b
proof
  set Cs2i1 = Comput(P2,s2,n+1);
  set Cs1i1 = Comput(P1,s1,n+1);
  set Cs2i = Comput(P2,s2,n);
  set Cs1i = Comput(P1,s1,n);
  set I = CurInstr(P1,Comput(P1,s1,n));
  let q be non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function;
  let p be q-autonomic non empty FinPartState of SCM R such that
A1:  p c= s1 &  p c= s2 and
A2: q c= P1 & q c= P2;
A3: a in dom  p
 implies (Cs1i1|dom  p).a = Cs1i1.a & (Cs2i1|dom  p).a = Cs2i1.a
  by FUNCT_1:49;
A4: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:3
    .= Exec (CurInstr(P2,Cs2i), Cs2i);
  assume that
A5: I = SubFrom(a,b) and
A6: a in dom p & Comput(P1,s1,n).a - Comput(P1,s1,n).
b <>
  Comput(P2,s2,n). a - Comput(P2,s2,n).b;
  Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:3
    .= Exec (CurInstr(P1,Cs1i), Cs1i);
  then
A7: Cs1i1.a = Cs1i.a - Cs1i.b by A5,SCMRING2:13;
  I = CurInstr(P2,Comput(P2,s2,n))
   by A1,A2,AMISTD_5:7;
  then Cs2i1.a = Cs2i.a - Cs2i.b by A4,A5,SCMRING2:13;
  hence contradiction by A1,A3,A6,A7,A2,EXTPRO_1:def 10;
end;

theorem Th10:
  for q being non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function
  for p being q-autonomic non empty
  FinPartState of SCM R st  p c= s1 &  p c= s2 &
  q c= P1 & q c= P2 &
  CurInstr(P1,Comput(P1,s1,n)) =
  MultBy(a, b) & a in dom p holds Comput(P1,s1,n).a * Comput(
P1,s1,n).b =
  Comput(P2,s2,n).a * Comput(P2,s2,n).b
proof
  set Cs2i1 = Comput(P2,s2,n+1);
  set Cs1i1 = Comput(P1,s1,n+1);
  set Cs2i = Comput(P2,s2,n);
  set Cs1i = Comput(P1,s1,n);
  set I = CurInstr(P1,Comput(P1,s1,n));
  let q be non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function;
  let p be q-autonomic non empty FinPartState of SCM R such that
A1:  p c= s1 &  p c= s2 and
A2: q c= P1 & q c= P2;
A3: a in dom  p
    implies (Cs1i1|dom  p).a = Cs1i1.a & (Cs2i1|dom  p).a = Cs2i1.a
  by FUNCT_1:49;
A4: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:3
    .= Exec (CurInstr(P2,Cs2i), Cs2i);
  assume that
A5: I = MultBy(a,b) and
A6: a in dom p & Comput(P1,s1,n).a * Comput(P1,s1,n).
b <>
  Comput(P2,s2,n). a * Comput(P2,s2,n).b;
  Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:3
    .= Exec (CurInstr(P1,Cs1i), Cs1i);
  then
A7: Cs1i1.a = Cs1i.a * Cs1i.b by A5,SCMRING2:14;
  I = CurInstr(P2,Comput(P2,s2,n))
   by A1,A2,AMISTD_5:7;
  then Cs2i1.a = Cs2i.a * Cs2i.b by A4,A5,SCMRING2:14;
  hence contradiction by A1,A3,A6,A7,A2,EXTPRO_1:def 10;
end;

theorem Th11:
  for q being non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function
  for p being q-autonomic non empty
  FinPartState of SCM R st  p c= s1 &  p c= s2 &
  q c= P1 & q c= P2 &
  CurInstr(P1,Comput(P1,s1,n)) = a
=0_goto loc & loc <> succ (IC Comput(P1,s1,n)) holds Comput(
P1,s1,n).a = 0.
  R iff Comput(P2,s2,n).a = 0.R
proof
  set Cs2i1 = Comput(P2,s2,n+1);
  set Cs1i1 = Comput(P1,s1,n+1);
  set I = CurInstr(P1,Comput(P1,s1,n));
  let q be non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function;
  let p be q-autonomic non empty FinPartState of SCM R such that
A1:  p c= s1 &  p c= s2 and
A2: q c= P1 & q c= P2;
A3: I = CurInstr(P2,Comput(P2,s2,n))
        by A1,A2,AMISTD_5:7;
  set Cs2i = Comput(P2,s2,n);
  set Cs1i = Comput(P1,s1,n);
A4: Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:3
    .= Exec (CurInstr(P1,Cs1i), Cs1i);
A5: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:3
    .= Exec (CurInstr(P2,Cs2i), Cs2i);
   IC SCM R in dom p by AMISTD_5:6;
   then
A6: (Cs1i1|dom  p).IC SCM R = Cs1i1.IC SCM R &
   (Cs2i1|dom  p).IC SCM R = Cs2i1.IC SCM R by FUNCT_1:49;
  assume that
A7: I = a=0_goto loc and
A8: loc <> succ (IC Comput(P1,s1,n));
A9: IC Cs1i = IC Cs2i by A1,A2,AMISTD_5:7;
  hereby
    assume
    Comput(P1,s1,n).a = 0.R & Comput(P2,s2,n).a <> 0.
R;
    then Cs1i1.IC SCM R = loc & Cs2i1.IC SCM R = succ IC Cs2i by A3,A4,A5,A7,
SCMRING2:16;
    hence contradiction by A1,A9,A6,A8,A2,EXTPRO_1:def 10;
  end;
  assume that
A10: Comput(P2,s2,n).a = 0.R and
A11: Comput(P1,s1,n).a <> 0.R;
A12: Cs1i1.IC SCM R = succ IC Cs1i by A4,A7,A11,SCMRING2:16;
  Cs2i1.IC SCM R = loc by A3,A5,A7,A10,SCMRING2:16;
  hence contradiction by A1,A6,A8,A12,A2,EXTPRO_1:def 10;
end;

begin :: Relocability

theorem Th12:
 for q being non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function
 for p being non empty q-autonomic FinPartState of
  SCM R st p c= s1 & IncIC( p,k) c= s2
 for P1,P2 being Instruction-Sequence of SCM R
  st q c= P1 & Reloc(q,k) c= P2
  for i being Element of NAT
   holds IC Comput(P1,s1,i) + k = IC Comput(P2,s2,i) &
  IncAddr(CurInstr(P1,Comput(P1,s1,i)), k) = CurInstr(P2,Comput(P2,s2,i)) &
  Comput(P1,s1,i)|dom (DataPart p) = Comput(P2,s2,i)|dom DataPart p &
  DataPart Comput(P1,s1 +* DataPart s2,i) = DataPart Comput(P2,s2,i)
proof
  let q be non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function;
  let p be non empty q-autonomic FinPartState of SCM R such that
A2:  p c= s1 and
A3: IncIC( p,k) c= s2;
A1: IC SCM R in dom  p by AMISTD_5:6;
  let P1,P2 be Instruction-Sequence of SCM R
  such that
A5: q c= P1 & Reloc(q,k) c= P2;
 set s = s1 +* DataPart s2;
  defpred P[Element of NAT] means
   IC Comput(P1,s1,$1) + k = IC Comput(P2,s2,$1) &
IncAddr(CurInstr(P1,Comput(P1,s1,$1)), k) =
CurInstr(P2,Comput(P2,s2,$1)) &
Comput(P1,s1,$1)|dom (DataPart p) = Comput(P2,s2,$1)|dom DataPart p &
 DataPart Comput(P1,s,$1) = DataPart Comput(P2,s2,$1);
A7: IC  p = IC s1 by A2,A1,GRFUNC_1:2;
  then IC  p = IC Comput(P1,s1,0);
  then
A8: IC  p in dom q by A2,A5,AMISTD_5:def 4;
A9:  p c= s by A2,A3,MEMSTR_0:61;
A10: for i being Element of NAT st P[i] holds P[i+1 qua Element of NAT]
  proof
    set DPp = DataPart p;
    let i be Element of NAT such that
A11: IC Comput(P1,s1,i) + k = IC Comput(P2,s2,i) and
A12:
IncAddr(CurInstr(P1,Comput(P1,s1,i)), k) =
CurInstr(P2,Comput(P2,s2,i))
and
A13: Comput(P1,s1,i)|dom DataPart p = Comput(P2,s2,i)|dom DataPart p and
A14: DataPart Comput(P1,s,i) = DataPart Comput(P2,s2,i);
    set Cs2i1 = Comput(P2,s2,i+1);
    set Cs3i = Comput(P1,s,i);
    set Cs2i = Comput(P2,s2,i);
A15: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:3
      .= Exec (CurInstr(P2,Cs2i), Cs2i);
A16: now
      let s be State of SCM R, d be Data-Location of R;
      d in Data-Locations SCM R by SCMRING2:23;
      hence d in dom DataPart s by MEMSTR_0:9;
    end;
A17: now
      let d be Data-Location of R;
A18:  d in dom DataPart Cs3i by A16;
      hence Cs3i.d = (DataPart Cs3i).d by FUNCT_1:47
        .= Cs2i.d by A14,A18,FUNCT_1:47;
    end;
    set Cs1i1 = Comput(P1,s1,i+1);
    set Cs1i = Comput(P1,s1,i);
    dom Cs1i1 = the carrier of SCM R by PARTFUN1:def 2;
    then
A19: dom Cs1i1 = {IC SCM R} \/ Data-Locations SCM R by XBOOLE_1:45;

A20: succ (IC Cs1i + k) = (succ IC Cs1i) + k;
A21: now
      reconsider loc = IC Cs1i1 as Element of NAT;
      assume
A22:  IC Comput(P1,s1,i+1) + k = IC Comput(P2
,s2,i+1);
A23:  loc in dom q by A2,A5,AMISTD_5:def 4;
      loc + k in dom Reloc(q, k) by A23,COMPOS_1:46;
      then
A24:  Reloc(q, k).(loc + k) = P2.(loc + k)
           by A5,GRFUNC_1:2;
A25:  P2/.IC Comput(P2,s2,i+1)
    = P2.IC Comput(P2,s2,i+1) by PBOOLE:143;
      CurInstr(P1,Cs1i1) = P1.loc by PBOOLE:143
        .= (q).loc by A23,A5,GRFUNC_1:2;
      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       =
      CurInstr(P2,Comput(P2,s2,i+1))
       by A22,A23,A24,A25,COMPOS_1:35;
    end;
    dom Cs2i = the carrier of SCM R by PARTFUN1:def 2;
    then
A26: dom Cs2i = {IC SCM R} \/ Data-Locations SCM R by XBOOLE_1:45;
    dom DPp = dom p /\ Data-Locations SCM R by RELAT_1:61;
    then
A27: dom DPp c= {IC SCM R} \/ Data-Locations SCM R by XBOOLE_1:10,17;
    set Cs3i1 = Comput(P1,s,i+1);
A28: dom DataPart Cs2i = Data-Locations SCM R by MEMSTR_0:9;
A29: dom DataPart Cs3i1 = Data-Locations SCM R by MEMSTR_0:9;
    then
A30: dom DataPart Cs3i1 c= dom DataPart Cs2i1 by MEMSTR_0:9;
A31: dom DataPart Cs2i1 = Data-Locations SCM R by MEMSTR_0:9;
A32: now
      let x be set;
      assume that
A33:  x in dom (DataPart Cs3i1) and
A34:  Cs3i1.x = Cs2i1.x;
      thus (DataPart Cs3i1).x = Cs2i1.x by A33,A34,FUNCT_1:47
        .= (DataPart Cs2i1).x by A29,A31,A33,FUNCT_1:47;
    end;
A35: dom DataPart Cs3i = Data-Locations SCM R by MEMSTR_0:9;
A36: now
      let x be set;
      assume that
A37:  x in dom DataPart Cs3i1 and
A38:  Cs3i1.x = Cs3i.x & Cs2i1.x = Cs2i.x;
      (DataPart Cs3i).x = Cs3i.x by A35,A29,A37,FUNCT_1:47;
      hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A14,A28,A29,A32,A37,A38,
FUNCT_1:47;
    end;
    dom Cs1i = the carrier of SCM R by PARTFUN1:def 2;
    then
A39: dom Cs1i = {IC SCM R} \/ Data-Locations SCM R by XBOOLE_1:45;
    dom Cs2i1 = the carrier of SCM R by PARTFUN1:def 2;
    then
A40: dom Cs2i1 = {IC SCM R} \/ Data-Locations SCM R by XBOOLE_1:45;
    set I = CurInstr(P1,Cs1i);
A41: Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:3
      .= Exec (CurInstr(P1,Cs1i), Cs1i);
A42: dom (Cs1i|dom DPp) = dom Cs1i /\ dom DPp by RELAT_1:61
      .= dom DPp by A39,A27,XBOOLE_1:28;
A43: dom (Cs1i1|dom DPp) = dom Cs1i1 /\ dom DPp by RELAT_1:61
      .= dom DPp by A19,A27,XBOOLE_1:28;
A44: dom (Cs2i1|dom DataPart p) = dom Cs2i1 /\ dom DPp by RELAT_1:61
      .= dom DPp by A40,A27,XBOOLE_1:28;
    then
A45: dom (Cs1i1|dom DPp)c=dom (Cs2i1|dom DPp) by A43;
A46: dom (Cs2i|dom DataPart p) = dom Cs2i /\ dom DPp by RELAT_1:61
      .= dom DPp by A26,A27,XBOOLE_1:28;
A47: now
      let x be set, d be Data-Location of R such that
A48:  d = x and
A49:  d in dom DPp and
A50:  Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d;
A51:  (Cs1i|dom DPp).d = Cs1i.d & (Cs2i|dom DPp).d = Cs2i.d by A42,A46,A49,
FUNCT_1:47;
      thus (Cs1i1|dom DPp).x = Cs1i1.d by A43,A48,A49,FUNCT_1:47
        .= (Cs2i1|dom DPp).x by A13,A44,A48,A49,A50,A51,FUNCT_1:47;
    end;
A52: now
      let x be set, d be Data-Location of R such that
A53:  d = x & d in dom DPp and
A54:  Cs1i1.d = Cs2i1.d;
      thus (Cs1i1|dom DPp).x = Cs2i1.d by A43,A53,A54,FUNCT_1:47
        .= (Cs2i1|dom DPp).x by A44,A53,FUNCT_1:47;
    end;
A55: Cs3i1 = Following(P1,Cs3i) by EXTPRO_1:3
      .= Exec (CurInstr(P1,Cs1i), Cs3i)
       by A2,A9,A5,AMISTD_5:7;
    per cases by NAT_1:31,SCMRING3:39;
    suppose
      InsCode I = 0;
      then
A56:  I = halt SCM R by SCMRING3:12;
      hence IC Comput(P1,s1,i+1) + k
       = IC Cs1i + k by A41,EXTPRO_1:def 3
        .= IC Comput(P2,s2,i+1)
         by A11,A12,A15,A56,EXTPRO_1:def 3;
      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1)) by A21;
A57:  Cs2i1 = Cs2i by A12,A15,A56,EXTPRO_1:def 3;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A13,A41,A56,EXTPRO_1:def 3;
      thus thesis by A14,A55,A56,A57,EXTPRO_1:def 3;
    end;
    suppose
      InsCode I = 1;
      then consider da, db being Data-Location of R such that
A58:  I = da := db by SCMRING3:13;
A59:  IncAddr(I, k) = da := db by A58,COMPOS_0:4;
A60:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A58,SCMRING2:11;
      hence
      IC Comput(P1,s1,i+1) + k = IC Comput(P2
,s2,i+1)
      by A11,A12,A41,A15,A20,A59,SCMRING2:11;
      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)),k)
       = CurInstr(P2,Comput(P2,s2,i+1))
       by A11,A12,A21,A41,A15,A20,A59,A60,SCMRING2:11;
A61:  Cs3i.db = Cs2i.db by A17;
      now
        DPp c= p by RELAT_1:59;
        then
A62:    dom DPp c= dom p by GRFUNC_1:2;
        let x be set;
        assume
A63:    x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM R by RELAT_1:58;
        then reconsider d = x as Data-Location of R by A43,A63,SCMRING2:23;
        per cases;
        suppose
A64:      da = d;
          then Cs1i1.d = Cs1i.db & Cs2i1.d = Cs2i.db by A12,A41,A15,A58,A59,
SCMRING2:11;
          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A9,A43,A52,A58,A61,A63
,A62,A64,Th7,A5;
        end;
        suppose
          da <> d;
          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A41,A15,A58,A59,
SCMRING2:11;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A43,A47,A63;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A45,GRFUNC_1:2;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A43,A44,GRFUNC_1:3;
      now
        let x be set;
        assume
A65:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A29,SCMRING2:23;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = Cs2i.db & Cs3i1.d=Cs3i.db by A12,A15,A55,A58,A59,
SCMRING2:11;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A17,A32,A65;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A55,A58,A59,
SCMRING2:11;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A36,A65;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A30,GRFUNC_1:2;
      hence thesis by A29,A31,GRFUNC_1:3;
    end;
    suppose
      InsCode I = 2;
      then consider da, db being Data-Location of R such that
A66:  I = AddTo(da, db) by SCMRING3:14;
A67:  IncAddr(I, k) = AddTo(da, db) by A66,COMPOS_0:4;
A68:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A66,SCMRING2:12;
      hence
      IC Comput(P1,s1,i+1) + k = IC Comput(P2
,s2,i+1)
      by A11,A12,A41,A15,A20,A67,SCMRING2:12;
      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1))
       by A11,A12,A21,A41,A15,A20,A67,A68,SCMRING2:12;
A69:  Cs3i.da = Cs2i.da & Cs3i.db = Cs2i.db by A17;
      now
        DPp c= p by RELAT_1:59;
        then
A70:    dom DPp c= dom p by GRFUNC_1:2;
        let x be set such that
A71:    x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM R by RELAT_1:58;
        then reconsider d = x as Data-Location of R by A43,A71,SCMRING2:23;
        per cases;
        suppose
A72:      da = d;
          then Cs1i1.d = Cs1i.da + Cs1i.db & Cs2i1.d = Cs2i.da + Cs2i.db by A12
,A41,A15,A66,A67,SCMRING2:12;
          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A9,A43,A52,A66,A69,A71
,A70,A72,Th8,A5;
        end;
        suppose
          da <> d;
          then Cs1i1.d=Cs1i.d & Cs2i1.d = Cs2i.d by A12,A41,A15,A66,A67,
SCMRING2:12;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A43,A47,A71;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A45,GRFUNC_1:2;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A43,A44,GRFUNC_1:3;
      now
        let x be set;
        assume
A73:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A29,SCMRING2:23;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = Cs2i.da + Cs2i.db & Cs3i1.d = Cs3i.da + Cs3i.db by A12
,A15,A55,A66,A67,SCMRING2:12;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A32,A69,A73;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A55,A66,A67,
SCMRING2:12;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A36,A73;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A30,GRFUNC_1:2;
      hence thesis by A29,A31,GRFUNC_1:3;
    end;
    suppose
      InsCode I = 3;
      then consider da, db being Data-Location of R such that
A74:  I = SubFrom(da, db) by SCMRING3:15;
A75:  IncAddr(I, k) = SubFrom(da, db) by A74,COMPOS_0:4;
A76:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A74,SCMRING2:13;
      hence
      IC Comput(P1,s1,i+1) + k = IC Comput(P2
,s2,i+1)
      by A11,A12,A41,A15,A20,A75,SCMRING2:13;
      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1))
      by A11,A12,A21,A41,A15,A20,A75,A76,SCMRING2:13;
A77:  Cs3i.da = Cs2i.da & Cs3i.db = Cs2i.db by A17;
      now
        DPp c= p by RELAT_1:59;
        then
A78:    dom DPp c= dom p by GRFUNC_1:2;
        let x be set such that
A79:    x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM R by RELAT_1:58;
        then reconsider d = x as Data-Location of R by A43,A79,SCMRING2:23;
        per cases;
        suppose
A80:      da = d;
          then Cs1i1.d = Cs1i.da - Cs1i.db & Cs2i1.d = Cs2i.da - Cs2i.db by A12
,A41,A15,A74,A75,SCMRING2:13;
          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A9,A43,A52,A74,A77,A79
,A78,A80,Th9,A5;
        end;
        suppose
          da <> d;
          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A41,A15,A74,A75,
SCMRING2:13;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A43,A47,A79;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A45,GRFUNC_1:2;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A43,A44,GRFUNC_1:3;
      now
        let x be set;
        assume
A81:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A29,SCMRING2:23;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = Cs2i.da - Cs2i.db & Cs3i1.d = Cs3i.da - Cs3i.db by A12
,A15,A55,A74,A75,SCMRING2:13;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A32,A77,A81;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A55,A74,A75,
SCMRING2:13;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A36,A81;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A30,GRFUNC_1:2;
      hence thesis by A29,A31,GRFUNC_1:3;
    end;
    suppose
      InsCode I = 4;
      then consider da, db being Data-Location of R such that
A82:  I = MultBy(da, db) by SCMRING3:16;
A83:  IncAddr(I, k) = MultBy(da, db) by A82,COMPOS_0:4;
A84:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A82,SCMRING2:14;
      hence
      IC Comput(P1,s1,i+1) + k = IC Comput(P2
,s2,i+1)
      by A11,A12,A41,A15,A20,A83,SCMRING2:14;
      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1))
      by A11,A12,A21,A41,A15,A20,A83,A84,SCMRING2:14;
A85:  Cs3i.da = Cs2i.da & Cs3i.db = Cs2i.db by A17;
      now
        DPp c= p by RELAT_1:59;
        then
A86:    dom DPp c= dom p by GRFUNC_1:2;
        let x be set such that
A87:    x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM R by RELAT_1:58;
        then reconsider d = x as Data-Location of R by A43,A87,SCMRING2:23;
        per cases;
        suppose
A88:      da = d;
          then Cs1i1.d = Cs1i.da * Cs1i.db & Cs2i1.d = Cs2i.da * Cs2i.db by A12
,A41,A15,A82,A83,SCMRING2:14;
          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A9,A43,A52,A82,A85,A87
,A86,A88,Th10,A5;
        end;
        suppose
          da <> d;
          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A41,A15,A82,A83,
SCMRING2:14;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A43,A47,A87;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A45,GRFUNC_1:2;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A43,A44,GRFUNC_1:3;
      now
        let x be set;
        assume
A89:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A29,SCMRING2:23;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = Cs2i.da * Cs2i.db & Cs3i1.d = Cs3i.da * Cs3i.db by A12
,A15,A55,A82,A83,SCMRING2:14;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A32,A85,A89;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A55,A82,A83,
SCMRING2:14;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A36,A89;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A30,GRFUNC_1:2;
      hence thesis by A29,A31,GRFUNC_1:3;
    end;
    suppose
      InsCode I = 5;
      then consider
      da being Data-Location of R, r being Element of R such that
A90:  I = da:=r by SCMRING3:17;
A91:  IncAddr(I, k) = da := r by A90,COMPOS_0:4;
A92:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A90,SCMRING2:17;
      hence
      IC Comput(P1,s1,i+1) + k = IC Comput(P2
,s2,i+1)
      by A11,A12,A41,A15,A20,A91,SCMRING2:17;
      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1))
      by A11,A12,A21,A41,A15,A20,A91,A92,SCMRING2:17;
      now
        let x be set;
        assume
A93:    x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM R by RELAT_1:58;
        then reconsider d = x as Data-Location of R by A43,A93,SCMRING2:23;
        per cases;
        suppose
A94:      da = d;
          thus (Cs1i1|dom DPp).x = Cs1i1.d by A43,A93,FUNCT_1:49
            .= r by A41,A90,A94,SCMRING2:17
            .= Cs2i1.d by A12,A15,A91,A94,SCMRING2:17
            .= (Cs2i1|dom DPp).x by A43,A93,FUNCT_1:49;
        end;
        suppose
          da <> d;
          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A41,A15,A90,A91,
SCMRING2:17;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A43,A47,A93;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A45,GRFUNC_1:2;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A43,A44,GRFUNC_1:3;
      now
        let x be set;
        assume
A95:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A29,SCMRING2:23;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = r & Cs3i1.d = r
           by A12,A15,A55,A90,A91,SCMRING2:17;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A32,A95;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A55,A90,A91,
SCMRING2:17;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A36,A95;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A30,GRFUNC_1:2;
      hence thesis by A29,A31,GRFUNC_1:3;
    end;
    suppose
      InsCode I = 6;
      then consider loc being Element of NAT such that
A96:  I = goto(loc,R) by SCMRING3:18;
A97:  CurInstr(P2,Cs2i) = goto (loc + k,R)
by A12,A96,SCMRING3:37;
      thus IC Comput(P1,s1,i+1) + k = loc + k
       by A41,A96,SCMRING2:15
        .= IC Comput(P2,s2,i+1) by A15,A97,SCMRING2:15;
      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1)) by A21;
      now
        let x be set such that
A98:   x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM R by RELAT_1:58;
        then reconsider d = x as Data-Location of R by A43,A98,SCMRING2:23;
        Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d
            by A41,A15,A96,A97,SCMRING2:15;
        hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A43,A47,A98;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A45,GRFUNC_1:2;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A43,A44,GRFUNC_1:3;
      now
        let x be set;
        assume
A99:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A29,SCMRING2:23;
        Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d
           by A15,A55,A96,A97,SCMRING2:15;
        hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A36,A99;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A30,GRFUNC_1:2;
      hence thesis by A29,A31,GRFUNC_1:3;
    end;
    suppose
      InsCode I = 7;
      then consider
      da being Data-Location of R, loc being Element of NAT
      such that
A100: I = da=0_goto loc by SCMRING3:19;
A101: now
        per cases;
        case
          Cs1i.da = 0.R;
          hence IC Comput(P1,s1,i+1) + k = loc + k by A41,A100,SCMRING2:16;
        end;
        case
          Cs1i.da <> 0.R;
          hence
          IC Comput(P1,s1,i+1) + k = succ (IC Cs2i)
          by A11,A41,A20,A100,SCMRING2:16;
        end;
      end;
A102: CurInstr(P2,Cs2i)
 = da=0_goto (loc + k) by A12,A100,SCMRING3:38;
A103: now
        per cases;
        case
          Cs2i.da = 0.R;
          hence IC Comput(P2,s2,i+1) = loc + k
          by A15,A102,SCMRING2:16;
        end;
        case
          Cs2i.da <> 0.R;
          hence IC Comput(P2,s2,i+1) = succ IC Cs2i by A15,A102,SCMRING2:16;
        end;
      end;
A104: Cs3i.da = Cs2i.da by A17;
      now
        per cases;
        suppose
          loc <> succ IC Cs1i;
          hence IC Comput(P1,s1,i+1) + k = IC Comput(
P2,s2,i+1)
          by A2,A9,A100,A104,A101,A103,Th11,A5;
        end;
        suppose
          loc = succ IC Cs1i;
          hence
          IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,i+1)
          by A11,A101,A103;
        end;
      end;
      hence IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,i+1) &
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k) =
      CurInstr(P2,Comput(P2,s2,i+1))
       by A21;
      now
        let x be set such that
A105:   x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM R by RELAT_1:58;
        then reconsider d = x as Data-Location of R by A43,A105,SCMRING2:23;
        Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d
        by A41,A15,A100,A102,SCMRING2:16;
        hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A43,A47,A105;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A45,GRFUNC_1:2;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A43,A44,GRFUNC_1:3;
      now
        let x be set;
        assume
A106:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A29,SCMRING2:23;
        Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d
        by A15,A55,A100,A102,SCMRING2:16;
        hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A36,A106;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A30,GRFUNC_1:2;
      hence thesis by A29,A31,GRFUNC_1:3;
    end;
  end;
A107: DataPart  p c=  p by RELAT_1:59;
A108: DataPart IncIC(p,k) = DataPart p by MEMSTR_0:51;
A109: DataPart p c= IncIC( p,k) by A108,MEMSTR_0:12;
A110: Comput(P1,s1,0)|dom (DataPart p) = s1 | dom (DataPart p)
    .= DataPart p by A2,A107,GRFUNC_1:23,XBOOLE_1:1
    .= s2 | dom (DataPart p) by A109,A3,GRFUNC_1:23,XBOOLE_1:1
    .= Comput(P2,s2,0)|dom DataPart p;
A111: DataPart Comput(P1,s,0) = DataPart(s1 +* DataPart s2)
    .= DataPart s2 by PBOOLE:142
    .= DataPart Comput(P2,s2,0);
A112: IC SCM R in dom IncIC( p,k) by MEMSTR_0:52;
A113: IC Comput(P1,s1,0) + k = IC s1 + k
      .= IC  p + k by A2,A1,GRFUNC_1:2
    .= IC p + k
      .= IC IncIC( p,k) by MEMSTR_0:53
    .= IC s2 by A3,A112,GRFUNC_1:2
    .= IC Comput(P2,s2,0);
A114: IC SCM R in dom IncIC( p,k) by MEMSTR_0:52;
A115: (IC  p) + k in dom Reloc(q,k) by A8,COMPOS_1:46;
A116:  P2/.IC s2 = P2.IC s2 by PBOOLE:143;
A117: CurInstr(P2,Comput(P2,s2,0))
     = P2.IC s2 by A116
    .= P2.(IC IncIC( p,k)) by A3,A114,GRFUNC_1:2
    .= P2.((IC p) + k) by MEMSTR_0:53
      .= P2.((IC  p) +k)
    .= (Reloc(q,k)).((IC  p) + k) by A115,A5,GRFUNC_1:2;
A118: (q).IC  p
    = P1.IC s1 by A7,A8,A5,GRFUNC_1:2;
A119:  CurInstr(P1,s1) = (q).IC  p by A118,PBOOLE:143;
A120: IncAddr(CurInstr(P1,Comput(P1,s1,0)), k)
      = IncAddr(CurInstr(P1,s1), k)
     .= CurInstr(P2,Comput(P2,s2,0)) by A117,A8,A119,COMPOS_1:35;
A121: P[0 qua Element of NAT] by A113,A120,A110,A111;
  for n holds P[n] from NAT_1:sch 1(A121,A10);
  hence thesis;
end;

registration let R be non trivial Ring;
 cluster SCM R -> relocable1 relocable2;
 coherence
  proof
   thus SCM R is relocable1
   proof
   thus
    for k being Element of NAT
    for q being non halt-free finite
     (the InstructionsF of SCM R)-valued NAT-defined Function,
    p being q-autonomic non empty FinPartState of SCM R ,
    s1, s2 being State of SCM R st  p c= s1 & IncIC( p,k) c= s2
  for P1,P2 being Instruction-Sequence of SCM R
   st q c= P1 & Reloc(q,k) c= P2
for i being Element of NAT
 holds IncAddr(CurInstr(P1,Comput(P1,s1,i)), k)
  = CurInstr(P2,Comput(P2,s2,i)) by Th12;
  end;
  let k be Element of NAT;
  let q be non halt-free finite
   (the InstructionsF of SCM R)-valued NAT-defined Function,
  p be q-autonomic non empty FinPartState of SCM R,
      s1, s2 be State of SCM R;
  assume
A1: p c= s1 & IncIC( p,k) c= s2;
  let P1,P2 be Instruction-Sequence of SCM R;
  assume q c= P1 & Reloc(q,k) c= P2;
  hence for i being Element of NAT holds
   Comput(P1,s1,i)|dom DataPart p =
    Comput(P2,s2,i)|dom DataPart p by A1,Th12;
  end;
end;

