:: Relocability for { \bf SCM } over Ring
::  by Artur Korni{\l}owicz and Yasunari Shidama
::
:: Received February 6, 2004
:: Copyright (c) 2004-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies ORDINAL1, SUBSET_1, NUMBERS, XBOOLE_0, SETFAM_1, SCMFSA7B,
      FUNCSDOM, AMI_3, AMI_1, FSM_1, STRUCT_0, AMI_2, FUNCT_1, TARSKI,
      RELAT_1, AMISTD_2, ARYTM_3, FUNCT_4, CIRCUIT2, CARD_1, GRAPHSP, ARYTM_1,
      SUPINF_2, FUNCOP_1, ZFMISC_1, PARTFUN1, SCMNORM, RELOC, NAT_1,
      AMISTD_5, COMPOS_1, PBOOLE;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, DOMAIN_1, ORDINAL1, RELAT_1,
      NUMBERS, FUNCT_1, PARTFUN1, STRUCT_0, ALGSTR_0, FUNCSDOM, FUNCOP_1,
      XCMPLX_0, NAT_1, FUNCT_4, FUNCT_7, NAT_D, VALUED_1, PBOOLE,
      COMPOS_1, EXTPRO_1, AMI_2, AMI_3, SCMRING1,
      SCMRING2, SCMRING3, AMISTD_2, AMISTD_5;
 constructors XXREAL_0, REALSET2, AMI_3, AMISTD_2, SCMRING3, PRE_POLY,
      NAT_D, AMISTD_1, AMISTD_5, PBOOLE, INT_3, FUNCT_7;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, XREAL_0, NAT_1,
      CARD_3, STRUCT_0, AMI_3, SCMRING2, AMISTD_2, SCMRING3,
      FINSET_1, ORDINAL1, RELSET_1, GRFUNC_1, FUNCT_2, VALUED_1, FUNCT_4,
      COMPOS_1, EXTPRO_1, AMISTD_5, AMI_5, PBOOLE, PRE_POLY, FUNCT_7;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCT_1, EXTPRO_1, FUNCOP_1, AMI_3, AMI_2, AMISTD_1, AMISTD_2,
      NAT_1, COMPOS_1, AMISTD_5, STRUCT_0;
 theorems TARSKI, NAT_1, SCMRING2, AMI_3, FUNCT_4, FUNCT_1,
      ZFMISC_1, FUNCOP_1, SCMRING1, AMI_2, STRUCT_0, XBOOLE_0, XBOOLE_1,
      RELAT_1, GRFUNC_1, SCMRING3, AMISTD_2, PBOOLE,
      PARTFUN1, ORDINAL1, COMPOS_1, EXTPRO_1, AMISTD_5;
 schemes NAT_1;

begin :: On the standard computers

reserve i, j, k for Element of NAT,
  n for Element of NAT,
  IL for non empty set,
  N for with_non-empty_elements set;

Lm1: for a,A being set st A /\ {a} <> {} holds a in A
proof
  let a,A be set;
  assume A /\ {a} <> {};
  then A meets {a} by XBOOLE_0:def 7;
  hence thesis by ZFMISC_1:56;
end;

begin :: SCM R

reserve R for non trivial good Ring,
  a, b for Data-Location of R,
  loc for Element of NAT,
  I for Instruction of SCM R,
  p for FinPartState of SCM R,
  s, s1, s2 for State of SCM R,
  P,P1,P2 for (the Instructions of SCM R)-valued ManySortedSet of NAT,

  q for FinPartState of SCM;

theorem
  (the Object-Kind of SCM R).loc = SCM-Instr R
proof
  reconsider i = loc as Element of NAT;
  thus (the Object-Kind of SCM R).loc = (SCM-OK R).i by SCMRING2:def 1
    .= SCM-Instr R by SCMRING1:6;
end;

theorem Th2:
  dl.(R,n) = [1,n]
proof
  thus dl.(R,n) = dl.n by SCMRING3:def 1
    .= [1,n];
end;

theorem
  for dl being Data-Location of R ex i being Element of NAT st dl = dl.(
  R,i)
proof
  let dl be Data-Location of R;
  dl in Data-Locations SCM by SCMRING2:1;
  then consider i being Element of NAT such that
A1: dl = [1,i] by AMI_2:32,AMI_3:72;
  take i;
  thus thesis by A1,Th2;
end;

theorem
  for i,j being Element of NAT holds i <> j implies dl.(R,i) <> dl.(R,j)
proof
  let i,j be Element of NAT;
  assume
A1: i <> j;
  dl.(R,j) = [1,j] & dl.(R,i) = [1,i] by Th2;
  hence thesis by A1,ZFMISC_1:33;
end;

theorem Th5:
  a <> loc
proof
  assume a = loc;
  then loc in (the carrier of SCM R) \ (NAT \/ {NAT}) by SCMRING2:def 2;
  then not loc in NAT \/ {NAT} by XBOOLE_0:def 5;
  hence thesis by XBOOLE_0:def 3;
end;

theorem
  Data-Locations SCM c= dom s
proof
  Data-Locations SCM R = Data-Locations SCM by SCMRING2:31;
  hence thesis by COMPOS_1:49;
end;

theorem Th7:
  s.a = (s +* Start-At(loc,SCM R)).a
proof
  a in the carrier of SCM R;
  then a in dom s by PARTFUN1:def 4;
  then
A1: dom (Start-At(loc,SCM R)) = {IC SCM R} & a in dom s \/
dom (Start-At(loc,SCM R)) by FUNCOP_1:19,XBOOLE_0:def 3;
  a <> IC SCM R by SCMRING3:3;
  then not a in {IC SCM R} by TARSKI:def 1;
  hence thesis by A1,FUNCT_4:def 1;
end;

theorem Th8:
  for s1,s2 being State of SCM R st IC(s1) = IC(s2) &
  (for a being Data-Location of R holds s1.a = s2.a)
    holds NPP s1 = NPP s2
proof
  let s1,s2 be State of SCM R such that
A1: IC(s1) = IC(s2);
    IC SCM R in dom s1 & IC SCM R in dom s2 by COMPOS_1:9;
    then
X1: NPP s1 = DataPart s1 +* Start-At (IC s1,SCM R) &
    NPP s2 = DataPart s2 +* Start-At (IC s2,SCM R) by COMPOS_1:74;
  assume
B2: for a being Data-Location of R holds s1.a = s2.a;
   DataPart s1 = DataPart s2
    proof
B1:   dom DataPart s1 = Data-Locations SCM R by COMPOS_1:50;
     hence
    dom DataPart s1 = dom DataPart s2 by COMPOS_1:50;
     let x be set;
     assume
Z:     x in dom DataPart s1;
      then
A2:   x is Data-Location of R by B1,SCMRING2:32;
     thus (DataPart s1).x = s1.x by Z,B1,FUNCT_1:72
         .= s2.x by A2,B2
         .= (DataPart s2).x by Z,B1,FUNCT_1:72;
    end;
  hence thesis by A1,X1;
end;

registration let R;
 cluster SCM R -> relocable;
 coherence
 proof let INS be Instruction of SCM R, j,k be Nat;
   reconsider k as Element of NAT by ORDINAL1:def 13;
  let s be State of SCM R;
A1: IC IncIC(Exec(IncAddr(INS,j),s),k)
       = IC Exec(IncAddr(INS,j),s) + k by COMPOS_1:54
      .= IC Exec(IncAddr(INS,j+k),IncIC(s,k)) by AMISTD_2:def 18;
  per cases by NAT_1:32,SCMRING3:71;
  suppose InsCode INS = 0;
    then
A3: INS = halt SCM R by SCMRING3:16;
    Exec(IncAddr(INS,j+k),IncIC(s,k))
       = IncIC(s,k) by EXTPRO_1:def 3,A3
      .= IncIC(Exec(IncAddr(INS,j),s),k) by A3,EXTPRO_1:def 3;
   hence thesis;
  end;
  suppose InsCode INS = 1;
    then consider da,db being Data-Location of R such that
A4: INS = da := db by SCMRING3:17;
    now
      let d be Data-Location of R;
      per cases;
      suppose
A5:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A4,COMPOS_1:92
          .= IncIC(s,k).db by A4,A5,SCMRING2:13
          .= s.db by Th7
          .= Exec(INS, s).d by A4,A5,SCMRING2:13
          .= Exec(IncAddr(INS,j), s).d by A4,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th7;
      end;
      suppose
A6:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A4,COMPOS_1:92
          .= IncIC(s,k).d by A4,A6,SCMRING2:13
          .= s.d by Th7
          .= Exec(INS, s).d by A4,A6,SCMRING2:13
          .= Exec(IncAddr(INS,j), s).d by A4,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th7;
      end;
    end;
   hence thesis by Th8,A1;
  end;
  suppose InsCode INS = 2;
    then consider da,db being Data-Location of R such that
A7: INS = AddTo(da, db) by SCMRING3:18;
    now let d be Data-Location of R;
      per cases;
      suppose
A8:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A7,COMPOS_1:92
          .= IncIC(s,k).da + IncIC(s,k).db by A8,A7,SCMRING2:14
          .= s.da + IncIC(s,k).db by Th7
          .= s.da + s.db by Th7
          .= Exec(INS, s).d by A7,A8,SCMRING2:14
          .= Exec(IncAddr(INS,j), s).d by A7,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th7;
      end;
      suppose
A9:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A7,COMPOS_1:92
          .= IncIC(s,k).d by A7,A9,SCMRING2:14
          .= s.d by Th7
          .= Exec(INS, s).d by A7,A9,SCMRING2:14
          .= Exec(IncAddr(INS,j), s).d by A7,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th7;
      end;
    end;
   hence thesis by Th8,A1;
  end;
  suppose InsCode INS = 3;
    then consider da,db being Data-Location of R such that
A10: INS = SubFrom(da, db) by SCMRING3:19;
    now let d be Data-Location of R;
      per cases;
      suppose
A11:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A10,COMPOS_1:92
          .= IncIC(s,k).da - IncIC(s,k).db by A11,A10,SCMRING2:15
          .= s.da - IncIC(s,k).db by Th7
          .= s.da - s.db by Th7
          .= Exec(INS, s).d by A10,A11,SCMRING2:15
          .= Exec(IncAddr(INS,j), s).d by A10,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th7;
      end;
      suppose
A12:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A10,COMPOS_1:92
          .= IncIC(s,k).d by A10,A12,SCMRING2:15
          .= s.d by Th7
          .= Exec(INS, s).d by A10,A12,SCMRING2:15
          .= Exec(IncAddr(INS,j), s).d by A10,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th7;
      end;
    end;
    hence thesis by Th8,A1;
  end;
  suppose InsCode INS = 4;
    then consider da,db being Data-Location of R such that
A13: INS = MultBy(da, db) by SCMRING3:20;
    now let d be Data-Location of R;
      per cases;
      suppose
A14:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A13,COMPOS_1:92
          .= IncIC(s,k).da * IncIC(s,k).db by A14,A13,SCMRING2:16
          .= s.da * IncIC(s,k).db by Th7
          .= s.da * s.db by Th7
          .= Exec(INS, s).d by A13,A14,SCMRING2:16
          .= Exec(IncAddr(INS,j), s).d by A13,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th7;
      end;
      suppose
A15:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A13,COMPOS_1:92
          .= IncIC(s,k).d by A13,A15,SCMRING2:16
          .= s.d by Th7
          .= Exec(INS, s).d by A13,A15,SCMRING2:16
          .= Exec(IncAddr(INS,j), s).d by A13,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th7;
      end;
    end;
    hence thesis by Th8,A1;
  end;
  suppose InsCode INS = 5;
    then consider da being Data-Location of R,
                  r being Element of R such that
A16: INS = da:=r by SCMRING3:21;
    now let d be Data-Location of R;
      per cases;
      suppose
A17:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A16,COMPOS_1:92
          .= r by A17,A16,SCMRING2:19
          .= Exec(INS, s).d by A16,A17,SCMRING2:19
          .= Exec(IncAddr(INS,j), s).d by A16,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th7;
      end;
      suppose
A18:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A16,COMPOS_1:92
          .= IncIC(s,k).d by A16,A18,SCMRING2:19
          .= s.d by Th7
          .= Exec(INS, s).d by A16,A18,SCMRING2:19
          .= Exec(IncAddr(INS,j), s).d by A16,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th7;
      end;
    end;
    hence thesis by Th8,A1;
  end;
  suppose InsCode INS = 6;
    then consider loc being Element of NAT such that
A19: INS = goto(loc,R) by SCMRING3:22;
A20: IncAddr(INS, j+k) = goto(loc + (j+k),R) by A19,SCMRING3:69;
A21: IncAddr(INS, j) = goto (loc + j,R) by A19,SCMRING3:69;
    now let d be Data-Location of R;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = IncIC(s,k).d by A20,SCMRING2:17
          .= s.d by Th7
          .= Exec(IncAddr(INS,j), s).d by A21,SCMRING2:17
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th7;
    end;
    hence thesis by Th8,A1;
  end;
  suppose InsCode INS = 7;
    then consider da being Data-Location of R, loc being Element of NAT
    such that
A22: INS = da=0_goto loc by SCMRING3:23;
A23: IncAddr(INS, j+k) = da=0_goto (loc + (j+k)) by A22,SCMRING3:70;
A24: IncAddr(INS, j) = da=0_goto (loc + j) by A22,SCMRING3:70;
    now let d be Data-Location of R;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = IncIC(s,k).d by A23,SCMRING2:18
          .= s.d by Th7
          .= Exec(IncAddr(INS,j), s).d by A24,SCMRING2:18
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by Th7;
    end;
   hence thesis by A1,Th8;
  end;
 end;
end;

definition
  let R;
  let a be Data-Location of R;
  let r be Element of R;
  redefine func a .--> r -> FinPartState of SCM R;
  coherence
  proof
    set k = a .--> r, f = the Object-Kind of SCM R;
    reconsider b = a as Element of SCM-Memory by SCMRING2:def 1;
A1: dom k = {a} by FUNCOP_1:19;
    for x being set st x in dom k holds k.x in f.x
    proof
      let x be set;
      assume
A2:   x in dom k;
      then x = a by A1,TARSKI:def 1;
      then
A3:   k.x = r by FUNCOP_1:87;
      f.x = ObjectKind a by A1,A2,TARSKI:def 1
        .= the carrier of R by SCMRING3:1;
      hence thesis by A3;
    end;
    hence thesis by FUNCT_1:def 20;
  end;
end;

registration let R be non trivial good Ring;
 cluster SCM R -> IC-recognized;
 coherence
 proof
  R is non trivial implies for p being autonomic FinPartState of
  SCM R st DataPart p <> {} holds IC SCM R in dom p
proof
  assume
 R is non trivial;
  let p be autonomic FinPartState of SCM R;
  assume DataPart p <> {};
  then
A1: dom DataPart p <> {};
  assume
A2: not IC SCM R in dom p;
  p is not autonomic
  proof
    set il =the  Element of (NAT) \ dom p;
    set d2 =the  Element of Data-Locations SCM \ dom p;
    set d1 =the  Element of dom DataPart p;
A3: d1 in dom DataPart p by A1;
    DataPart p c= NPP p by COMPOS_1:169;
    then
A4:  dom DataPart p c= dom NPP p by RELAT_1:25;
    dom DataPart p c= the carrier of SCM R by RELAT_1:def 18;
    then reconsider d1 as Element of SCM R by A3;
    not Data-Locations SCM c= dom p;
    then
A5: Data-Locations SCM \ dom p <> {} by XBOOLE_1:37;
    then d2 in Data-Locations SCM by XBOOLE_0:def 5;
    then reconsider d2 as Data-Location of R by SCMRING2:1;
A6: not d2 in dom p by A5,XBOOLE_0:def 5;
    not NAT c= dom p;
    then
A7: (NAT) \ dom p <> {} by XBOOLE_1:37;
    then reconsider il as Element of NAT by XBOOLE_0:def 5;
A8: not il in dom p by A7,XBOOLE_0:def 5;
    Data-Locations SCM R = Data-Locations SCM by SCMRING2:31;
    then dom DataPart p c= Data-Locations SCM by RELAT_1:87;
    then reconsider d1 as Data-Location of R by A3,SCMRING2:1;
A9: dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At(il,SCM R)) = dom ((il
    .--> (d1:=d2)) +* ( d2.--> 0.R)) \/ dom(Start-At(il,SCM R))
    by FUNCT_4:def 1;
    set p1 = p +* ((il .--> (d1:=d2)) +* (d2.--> 0.R) +* Start-At(il,SCM R));
    consider s1 being State of SCM R such that
A10: p1 c= s1 by PBOOLE:156;
A11: dom p1 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +*
    Start-At(il,SCM R)) by FUNCT_4:def 1;
A12: dom(Start-At(il,SCM R)) = {IC SCM R} by FUNCOP_1:19;
    then
A13: IC SCM R in dom (Start-At(il,SCM R)) by TARSKI:def 1;
    then
A14: IC SCM R in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +*
Start-At(il,SCM R))
    by A9,XBOOLE_0:def 3;
    then IC SCM R in dom p1 by A11,XBOOLE_0:def 3;
    then
A15: IC s1 = p1.IC SCM R by A10,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At(il,SCM R)).IC SCM R
      by A14,FUNCT_4:14
      .= (Start-At(il,SCM R)).IC SCM R by A13,FUNCT_4:14
      .= il by FUNCOP_1:87;
A16: il <> IC SCM R by COMPOS_1:3;
    then
A17: not il in dom (Start-At(il,SCM R)) by A12,TARSKI:def 1;
A18: dom(Start-At(il,SCM R)) = {IC SCM R} by FUNCOP_1:19;
    then
A19: not il in dom (Start-At(il,SCM R)) by A16,TARSKI:def 1;
A20: d2 <> IC SCM R by SCMRING3:3;
    then
A21: not d2 in dom (Start-At(il,SCM R)) by A12,TARSKI:def 1;
A22: not d2 in dom (Start-At(il,SCM R)) by A20,A18,TARSKI:def 1;
A23: dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R)) = dom (il .--> (d1:=d2)) \/
    dom ( d2.--> 0.R) by FUNCT_4:def 1;
A24: dom (d2 .--> 0.R) = {d2} by FUNCOP_1:19;
    then
A25: d2 in dom (d2 .--> 0.R) by TARSKI:def 1;
    then d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R)) by A23,XBOOLE_0:def 3;
    then
A26: d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At(il,SCM R))
by A9,XBOOLE_0:def 3;
    then d2 in dom p1 by A11,XBOOLE_0:def 3;
    then
A27: s1.d2 = p1.d2 by A10,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At(il,SCM R)).d2 by A26,
FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R)).d2 by A21,FUNCT_4:12
      .= (d2.--> 0.R).d2 by A25,FUNCT_4:14
      .= 0.R by FUNCOP_1:87;
A28: il <> d2 by Th5;
    then
A29: not il in dom (d2 .--> 0.R) by A24,TARSKI:def 1;
    dom (il .--> (d1:=d2)) = {il} by FUNCOP_1:19;
    then il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
    then il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R)) by A23,XBOOLE_0:def 3;
    then
A30: il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At(il,SCM R))
by A9,XBOOLE_0:def 3;
    then il in dom p1 by A11,XBOOLE_0:def 3;
    then
A31: s1.il = p1.il by A10,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At(il,SCM R)).il by A30,
FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R)).il by A17,FUNCT_4:12
      .= (il .--> (d1:=d2)).il by A29,FUNCT_4:12
      .= d1:=d2 by FUNCOP_1:87;
A32:  dom NPP p c= the carrier of SCM R by RELAT_1:def 18;
    dom Comput(ProgramPart(s1),s1,1) = the carrier of SCM R by PARTFUN1:def 4;
    then
A33: dom (Comput(ProgramPart(s1),s1,1)|dom NPP p) = dom NPP p by A32
,RELAT_1:91;
    consider e being Element of R such that
A34: e <> 0.R by STRUCT_0:def 19;
    set p2 = p +* ((il .--> (d1:=d2)) +* (d2.--> e) +* Start-At(il,SCM R));
    consider s2 being State of SCM R such that
A35: p2 c= s2 by PBOOLE:156;
A36: dom ( Comput(ProgramPart(s2),s2,1)) = the carrier of SCM R
       by PARTFUN1:def 4;
A37: dom ( Comput(ProgramPart(s2),s2,1)|dom NPP p) = dom NPP p
       by RELAT_1:91,A32,A36;
    take P = ProgramPart s1, Q = ProgramPart s2;
    dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At(il,SCM R)) = dom((il
    .--> (d1:=d2)) +* ( d2.--> 0.R)) \/ dom(Start-At(il,SCM R))
    by FUNCT_4:def 1
      .= dom((il .--> (d1:=d2)) +* ( d2.--> 0.R)) \/ {IC SCM R} by FUNCOP_1:19
      .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> 0.R) \/ {IC SCM R} by
FUNCT_4:def 1
      .= {il} \/ dom ( d2.--> 0.R) \/ {IC SCM R} by FUNCOP_1:19
      .= {il} \/ {d2} \/ {IC SCM R} by FUNCOP_1:19;
    then dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +*
    Start-At(il,SCM R)) =
    dom p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM R} by XBOOLE_1:23
      .= dom p /\ ({il} \/ {d2}) \/ {} by A2,Lm1
      .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
      .= dom p /\ {il} \/ {} by A6,Lm1
      .= {} by A8,Lm1;
    then
    dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +*
    Start-At(il,SCM R))
    by XBOOLE_0:def 7;
    then p c= p1 by FUNCT_4:33;
    then
A38:  p c= s1 by A10,XBOOLE_1:1;
    hence ProgramPart p c= P by RELAT_1:105;
    dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R)) =
    dom((il .-->
    (d1:=d2)) +* ( d2.--> e)) \/ dom(Start-At(il,SCM R)) by FUNCT_4:def 1
      .= dom((il .--> (d1:=d2)) +* ( d2.--> e)) \/ {IC SCM R} by FUNCOP_1:19
      .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> e) \/ {IC SCM R} by
FUNCT_4:def 1
      .= {il} \/ dom ( d2.--> e) \/ {IC SCM R} by FUNCOP_1:19
      .= {il} \/ {d2} \/ {IC SCM R} by FUNCOP_1:19;
    then
    dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R))
     = dom
    p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM R} by XBOOLE_1:23
      .= dom p /\ ({il} \/ {d2}) \/ {} by A2,Lm1
      .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
      .= dom p /\ {il} \/ {} by A6,Lm1
      .= {} by A8,Lm1;
    then dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> e) +*
    Start-At(il,SCM R))
    by XBOOLE_0:def 7;
    then p c= p2 by FUNCT_4:33;
    then
A39:  p c= s2 by A35,XBOOLE_1:1;
    hence ProgramPart p c= Q by RELAT_1:105;
    take s1, s2;
     p c= s1 by A38;
    hence NPP p c= s1 by XBOOLE_1:1;
     p c= s2 by A39;
    hence NPP p c= s2 by XBOOLE_1:1;
    take 1;
A40: dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R)) = dom ((il
    .--> (d1:=d2)) +* ( d2.--> e)) \/ dom(Start-At(il,SCM R)) by FUNCT_4:def 1;
A41: dom (d2 .--> e) = {d2} by FUNCOP_1:19;
    then
A42: not il in dom (d2 .--> e) by A28,TARSKI:def 1;
A43: dom p2 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(
    il,SCM R)) by FUNCT_4:def 1;
A44: IC SCM R in dom (Start-At(il,SCM R)) by A18,TARSKI:def 1;
    then
A45: IC SCM R in dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R) )
    by A40,XBOOLE_0:def 3;
    then IC SCM R in dom p2 by A43,XBOOLE_0:def 3;
    then
A46: IC s2 = p2.IC SCM R by A35,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R)).IC SCM R
      by A45,FUNCT_4:14
      .= (Start-At(il,SCM R)).IC SCM R by A44,FUNCT_4:14
      .= il by FUNCOP_1:87;
A47: dom ((il .--> (d1:=d2)) +* ( d2.--> e)) = dom (il .--> (d1:=d2)) \/
    dom ( d2.--> e) by FUNCT_4:def 1;
    dom (il .--> (d1:=d2)) = {il} by FUNCOP_1:19;
    then il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
    then il in dom ((il .--> (d1:=d2)) +* ( d2.--> e)) by A47,XBOOLE_0:def 3;
    then
A48: il in dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R))
by A40,XBOOLE_0:def 3;
    then il in dom p2 by A43,XBOOLE_0:def 3;
    then
A49: s2.il = p2.il by A35,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R)).il by A48,
FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> e)).il by A19,FUNCT_4:12
      .= (il .--> (d1:=d2)).il by A42,FUNCT_4:12
      .= d1:=d2 by FUNCOP_1:87;
A50: d2 in dom (d2 .--> e) by A41,TARSKI:def 1;
    then d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> e)) by A47,XBOOLE_0:def 3;
    then
A51: d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R))
by A40,XBOOLE_0:def 3;
    then d2 in dom p2 by A43,XBOOLE_0:def 3;
    then
A52: s2.d2 = p2.d2 by A35,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R)).d2 by A51,
FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> e)).d2 by A22,FUNCT_4:12
      .= (d2.--> e).d2 by A50,FUNCT_4:14
      .= e by FUNCOP_1:87;
A53:  (ProgramPart s2)/.il = s2.il by COMPOS_1:38;
A54: Comput(ProgramPart(s2),s2,0+1).d1 =
 (Following(ProgramPart s2,Comput(ProgramPart(s2),s2,
0))).d1 by EXTPRO_1:4
      .= (Following(ProgramPart s2,s2)).d1 by EXTPRO_1:3
      .= e by A46,A49,A52,A53,SCMRING2:13;
A55:  (ProgramPart s1)/.il = s1.il by COMPOS_1:38;
    Comput(ProgramPart(s1),s1,0+1).d1 =
     (Following(ProgramPart s1,Comput(ProgramPart(s1),s1,0))).d1
     by EXTPRO_1:4
      .= (Following(ProgramPart s1,s1)).d1 by EXTPRO_1:3
      .= 0.R by A15,A31,A27,A55,SCMRING2:13;
    then
   (Comput(P,s1,1)|dom NPP p).d1 = 0.R
     by A33,FUNCT_1:70,A3,A4;
    hence Comput(P,s1,1)|dom NPP p <> Comput(Q,s2,1)|dom NPP p
        by A34,A3,A37,A4,A54,FUNCT_1:70;
  end;
  hence contradiction;
end;
  hence thesis by AMISTD_5:3;
 end;
end;

registration let R be non trivial good Ring;
 cluster SCM R -> CurIns-recognized;
 coherence
proof
  let p be autonomic non NAT-defined FinPartState of SCM R,
      s be State of SCM R such that
A1: NPP p c= s;
  let P be (the Instructions of SCM R)-valued ManySortedSet of NAT such that
A2: ProgramPart p c= P;
  let i be Element of NAT;
  set Csi = Comput(P,s,i);
  set loc = IC Csi;
  set loc1 = loc+1;
A3: loc in dom ProgramPart p iff loc in dom p /\ NAT by RELAT_1:90;
  assume not IC Comput(P,s,i) in dom ProgramPart(p);
  then
A4: not loc in dom p by A3,XBOOLE_0:def 4;
  set I = dl.(R,0) := dl.(R,0);
  set p1 = p +* (loc .--> I);
  set p2 = p +* (loc .--> halt SCM R);
  reconsider P1 = P +* (loc .--> I)
   as (the Instructions of SCM R)-valued ManySortedSet of NAT;
  reconsider P2 = P +* (loc .--> halt SCM R)
   as (the Instructions of SCM R)-valued ManySortedSet of NAT;
A6: dom (loc .--> halt SCM R) = {loc} by FUNCOP_1:19;
  then
A7: loc in dom (loc .--> halt SCM R) by TARSKI:def 1;
A12: dom (loc .--> I) = {loc} by FUNCOP_1:19;
  then
A13: loc in dom (loc .--> I) by TARSKI:def 1;
Y6: dom p misses dom (loc .--> halt SCM R) by A4,A6,ZFMISC_1:56;
Y5: dom p misses dom (loc .--> I) by A4,A12,ZFMISC_1:56;
    ProgramPart p1 = ProgramPart p +* ProgramPart(loc .--> I) by FUNCT_4:75
      .= ProgramPart p +* (loc .--> I) by RELAT_1:209;
   then
P3: ProgramPart p1 c= P1 by A2,FUNCT_4:131;
    ProgramPart p2 = ProgramPart p +* ProgramPart(loc .--> halt SCM R)
              by FUNCT_4:75
      .= ProgramPart p +* (loc .--> halt SCM R) by RELAT_1:209;
   then
P4: ProgramPart p2 c= P2 by A2,FUNCT_4:131;
  set Cs2i = Comput(P2,s,i), Cs1i = Comput(P1,s,i);
  p is not autonomic
  proof
    (loc .--> halt SCM R).loc = halt SCM R by FUNCOP_1:87;
    then
A18:  P2.loc = halt SCM R by A7,FUNCT_4:14;
    (loc .--> I).loc = I by FUNCOP_1:87;
    then
A19:  P1.loc = I by A13,FUNCT_4:14;
    take P1, P2;
    ProgramPart p c= ProgramPart p1 by Y5,FUNCT_4:33,RELAT_1:105;
    hence
A25:  ProgramPart p c= P1 by P3,XBOOLE_1:1;
    ProgramPart p c= ProgramPart p2 by Y6,FUNCT_4:33,RELAT_1:105;
    hence
A27:  ProgramPart p c= P2 by P4,XBOOLE_1:1;
    take s, s;
    thus NPP p c= s by A1;
A28: (Cs1i|dom NPP p) = (Csi|dom NPP p) by A25,A2,A1,EXTPRO_1:def 9;
    thus NPP p c= s by A1;
A29: (Cs1i|dom NPP p) = (Cs2i|dom NPP p) by A25,A27,A1,EXTPRO_1:def 9;
    take k = i+1;
    set Cs1k = Comput(P1,s,k);
A33: IC SCM R in dom p by AMISTD_5:6;
 IC Csi = IC(Csi|dom NPP p) by A33,COMPOS_1:179,FUNCT_1:72;
    then
  IC Cs1i = loc by A28,A33,COMPOS_1:179,FUNCT_1:72;
    then
XX: CurInstr(P1,Cs1i) = P1.loc by PBOOLE:158
         .= I by A19;
A31: Cs1k = Following(P1,Cs1i) by EXTPRO_1:4
      .= Exec (CurInstr(P1,Cs1i), Cs1i)
      .= Exec(I,Cs1i) by XX;
A32:  IC Exec(I,Cs1i) = succ IC Cs1i by SCMRING2:13;
A33: IC SCM R in dom p by AMISTD_5:6;
A34: IC Csi = IC(Csi|dom NPP p) by A33,COMPOS_1:179,FUNCT_1:72;
    then IC Cs1i = loc by A28,A33,COMPOS_1:179,FUNCT_1:72;
    then
A35: IC Cs1k = succ loc by A31,A32
         .= loc1;
    set Cs2k = Comput(P2,s,k);
A36: Cs2k = Following(P2,Cs2i) by EXTPRO_1:4
      .= Exec (CurInstr(P2,Cs2i), Cs2i);
A37:  P2/.IC Cs2i = P2.IC Cs2i by PBOOLE:158;
    IC Cs2i = loc by A28,A34,A29,A33,COMPOS_1:179,FUNCT_1:72;
    then
A38: IC Cs2k = loc by A36,A18,A37,EXTPRO_1:def 3;
    IC(Cs1k|dom NPP p) = IC Cs1k & IC(Cs2k|dom NPP p) = IC Cs2k
     by A33,COMPOS_1:179,FUNCT_1:72;
    hence thesis by A35,A38;
  end;
  hence contradiction;
end;
end;

Lm2:
 for p being PartState of SCM R
 holds a in dom p implies a in dom NPP p
proof
 let p be PartState of SCM R;
  Data-Locations SCM R = Data-Locations SCM by SCMRING2:31;
  then
A1: a in Data-Locations SCM R by SCMRING2:1;
 assume a in dom p;
  then
A2:  a in dom DataPart p by A1,RELAT_1:86;
   DataPart p c= NPP p by COMPOS_1:169;
   then dom DataPart p c= dom NPP p by RELAT_1:25;
 hence a in dom NPP p by A2;
end;

theorem Th9:
  R is non trivial implies for p being autonomic non NAT-defined
  FinPartState of SCM R st NPP p c= s1 & NPP p c= s2 &
  ProgramPart p c= P1 & ProgramPart p c= P2 &
  CurInstr(P1,Comput(P1,s1,n)) = a := b &
  a in dom p
   holds Comput(P1,s1,n).b = Comput(P2,s2,n).b
proof
  assume
 R is non trivial;
  set Cs2i1 = Comput(P2,s2,n+1);
  set Cs1i1 = Comput(P1,s1,n+1);
  set Cs2i = Comput(P2,s2,n);
  set Cs1i = Comput(P1,s1,n);
  set I = CurInstr(P1,Comput(P1,s1,n));
  let p be autonomic non NAT-defined FinPartState of SCM R such that
A1: NPP p c= s1 & NPP p c= s2 and
A2: ProgramPart p c= P1 & ProgramPart p c= P2;
A3: a in dom NPP p implies
 (Cs1i1|dom NPP p).a = Cs1i1.a & (Cs2i1|dom NPP p).a = Cs2i1.a
  by FUNCT_1:72;
A4: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:4
    .= Exec (CurInstr(P2,Cs2i), Cs2i);
  assume that
A5: I = a := b and
A6: a in dom p & Comput(P1,s1,n).b <> Comput(P2,s2,n)
.b;
  Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:4
    .= Exec (CurInstr(P1,Cs1i), Cs1i);
  then
A7: Cs1i1.a = Cs1i.b by A5,SCMRING2:13;
  I = CurInstr(P2,Comput(P2,s2,n))
   by A1,AMISTD_5:7,A2;
  then Cs2i1.a = Cs2i.b by A4,A5,SCMRING2:13;
  hence contradiction by A1,A3,A6,A7,EXTPRO_1:def 9,A2,Lm2;
end;

theorem Th10:
  R is non trivial implies for p being autonomic non NAT-defined
  FinPartState of SCM R st NPP p c= s1 & NPP p c= s2 &
  ProgramPart p c= P1 & ProgramPart p c= P2 &
  CurInstr(P1,Comput(P1,s1,n)) =
  AddTo(a,b) & a in dom p holds Comput(P1,s1,n).a + Comput(P1,s1,n).b =
     Comput(P2,s2,n).a + Comput(P2,s2,n).b
proof
  assume
 R is non trivial;
  set Cs2i1 = Comput(P2,s2,n+1);
  set Cs1i1 = Comput(P1,s1,n+1);
  set Cs2i = Comput(P2,s2,n);
  set Cs1i = Comput(P1,s1,n);
  set I = CurInstr(P1,Comput(P1,s1,n));
  let p be autonomic non NAT-defined FinPartState of SCM R such that
A1: NPP p c= s1 & NPP p c= s2 and
A2: ProgramPart p c= P1 & ProgramPart p c= P2;
A3: a in dom NPP p
 implies (Cs1i1|dom NPP p).a = Cs1i1.a & (Cs2i1|dom NPP p).a = Cs2i1.a
  by FUNCT_1:72;
A4: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:4
    .= Exec (CurInstr(P2,Cs2i), Cs2i);
  assume that
A5: I = AddTo(a,b) and
A6: a in dom p & Comput(P1,s1,n).a
    + Comput(P1,s1,n).b <>
  Comput(P2,s2,n). a + Comput(P2,s2,n).b;
  Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:4
    .= Exec (CurInstr(P1,Cs1i), Cs1i);
  then
A7: Cs1i1.a = Cs1i.a + Cs1i.b by A5,SCMRING2:14;
  I = CurInstr(P2,Comput(P2,s2,n))
   by A1,AMISTD_5:7,A2;
  then Cs2i1.a = Cs2i.a + Cs2i.b by A4,A5,SCMRING2:14;
  hence contradiction by A1,A3,A6,A7,EXTPRO_1:def 9,Lm2,A2;
end;

theorem Th11:
  R is non trivial implies for p being autonomic non NAT-defined
  FinPartState of SCM R st NPP p c= s1 & NPP p c= s2 &
  ProgramPart p c= P1 & ProgramPart p c= P2 &
  CurInstr(P1,Comput(P1,s1,n)) =
  SubFrom(a, b) & a in dom p holds Comput(P1,s1,n).a - Comput(
P1,s1,n).b =
  Comput(P2,s2,n).a - Comput(P2,s2,n).b
proof
  assume
 R is non trivial;
  set Cs2i1 = Comput(P2,s2,n+1);
  set Cs1i1 = Comput(P1,s1,n+1);
  set Cs2i = Comput(P2,s2,n);
  set Cs1i = Comput(P1,s1,n);
  set I = CurInstr(P1,Comput(P1,s1,n));
  let p be autonomic non NAT-defined FinPartState of SCM R such that
A1: NPP p c= s1 & NPP p c= s2 and
A2: ProgramPart p c= P1 & ProgramPart p c= P2;
A3: a in dom NPP p
 implies (Cs1i1|dom NPP p).a = Cs1i1.a & (Cs2i1|dom NPP p).a = Cs2i1.a
  by FUNCT_1:72;
A4: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:4
    .= Exec (CurInstr(P2,Cs2i), Cs2i);
  assume that
A5: I = SubFrom(a,b) and
A6: a in dom p & Comput(P1,s1,n).a - Comput(P1,s1,n).
b <>
  Comput(P2,s2,n). a - Comput(P2,s2,n).b;
  Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:4
    .= Exec (CurInstr(P1,Cs1i), Cs1i);
  then
A7: Cs1i1.a = Cs1i.a - Cs1i.b by A5,SCMRING2:15;
  I = CurInstr(P2,Comput(P2,s2,n))
   by A1,AMISTD_5:7,A2;
  then Cs2i1.a = Cs2i.a - Cs2i.b by A4,A5,SCMRING2:15;
  hence contradiction by A1,A3,A6,A7,EXTPRO_1:def 9,Lm2,A2;
end;

theorem Th12:
  R is non trivial implies for p being autonomic non NAT-defined
  FinPartState of SCM R st NPP p c= s1 & NPP p c= s2 &
  ProgramPart p c= P1 & ProgramPart p c= P2 &
  CurInstr(P1,Comput(P1,s1,n)) =
  MultBy(a, b) & a in dom p holds Comput(P1,s1,n).a * Comput(
P1,s1,n).b =
  Comput(P2,s2,n).a * Comput(P2,s2,n).b
proof
  assume
 R is non trivial;
  set Cs2i1 = Comput(P2,s2,n+1);
  set Cs1i1 = Comput(P1,s1,n+1);
  set Cs2i = Comput(P2,s2,n);
  set Cs1i = Comput(P1,s1,n);
  set I = CurInstr(P1,Comput(P1,s1,n));
  let p be autonomic non NAT-defined FinPartState of SCM R such that
A1: NPP p c= s1 & NPP p c= s2 and
A2: ProgramPart p c= P1 & ProgramPart p c= P2;
A3: a in dom NPP p
    implies (Cs1i1|dom NPP p).a = Cs1i1.a & (Cs2i1|dom NPP p).a = Cs2i1.a
  by FUNCT_1:72;
A4: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:4
    .= Exec (CurInstr(P2,Cs2i), Cs2i);
  assume that
A5: I = MultBy(a,b) and
A6: a in dom p & Comput(P1,s1,n).a * Comput(P1,s1,n).
b <>
  Comput(P2,s2,n). a * Comput(P2,s2,n).b;
  Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:4
    .= Exec (CurInstr(P1,Cs1i), Cs1i);
  then
A7: Cs1i1.a = Cs1i.a * Cs1i.b by A5,SCMRING2:16;
  I = CurInstr(P2,Comput(P2,s2,n))
   by A1,AMISTD_5:7,A2;
  then Cs2i1.a = Cs2i.a * Cs2i.b by A4,A5,SCMRING2:16;
  hence contradiction by A1,A3,A6,A7,EXTPRO_1:def 9,Lm2,A2;
end;

theorem Th13:
  R is non trivial implies for p being autonomic non NAT-defined
  FinPartState of SCM R st NPP p c= s1 & NPP p c= s2 &
  ProgramPart p c= P1 & ProgramPart p c= P2 &
  CurInstr(P1,Comput(P1,s1,n)) = a
=0_goto loc & loc <> succ (IC Comput(P1,s1,n)) holds Comput(
P1,s1,n).a = 0.
  R iff Comput(P2,s2,n).a = 0.R
proof
  assume
 R is non trivial;
  set Cs2i1 = Comput(P2,s2,n+1);
  set Cs1i1 = Comput(P1,s1,n+1);
  set I = CurInstr(P1,Comput(P1,s1,n));
  let p be autonomic non NAT-defined FinPartState of SCM R such that
A1: NPP p c= s1 & NPP p c= s2 and
A2: ProgramPart p c= P1 & ProgramPart p c= P2;
A3: I = CurInstr(P2,Comput(P2,s2,n))
        by A1,AMISTD_5:7,A2;
  set Cs2i = Comput(P2,s2,n);
  set Cs1i = Comput(P1,s1,n);
A4: Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:4
    .= Exec (CurInstr(P1,Cs1i), Cs1i);
A5: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:4
    .= Exec (CurInstr(P2,Cs2i), Cs2i);
   IC SCM R in dom p by AMISTD_5:6;
   then
A6: (Cs1i1|dom NPP p).IC SCM R = Cs1i1.IC SCM R &
   (Cs2i1|dom NPP p).IC SCM R = Cs2i1.IC SCM R by FUNCT_1:72,COMPOS_1:179;
  assume that
A7: I = a=0_goto loc and
A8: loc <> succ (IC Comput(P1,s1,n));
A9: IC Cs1i = IC Cs2i by A1,AMISTD_5:7,A2;
  hereby
    assume
    Comput(P1,s1,n).a = 0.R & Comput(P2,s2,n).a <> 0.
R;
    then Cs1i1.IC SCM R = loc & Cs2i1.IC SCM R = succ IC Cs2i by A3,A4,A5,A7,
SCMRING2:18;
    hence contradiction by A1,A9,A6,A8,EXTPRO_1:def 9,A2;
  end;
  assume that
A10: Comput(P2,s2,n).a = 0.R and
A11: Comput(P1,s1,n).a <> 0.R;
A12: Cs1i1.IC SCM R = succ IC Cs1i by A4,A7,A11,SCMRING2:18;
  Cs2i1.IC SCM R = loc by A3,A5,A7,A10,SCMRING2:18;
  hence contradiction by A1,A6,A8,A12,EXTPRO_1:def 9,A2;
end;

begin :: Relocability

theorem Th14:
 for p being autonomic FinPartState of
  SCM R st IC SCM R in dom p &
   NPP p c= s1 & NPP Relocated (p,k) c= s2
 for P1,P2 being (the Instructions of SCM R)-valued ManySortedSet of NAT
  st ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2
  for i being Element of NAT
   holds IC Comput(P1,s1,i) + k = IC Comput(P2,s2,i) &
  IncAddr(CurInstr(P1,Comput(P1,s1,i)), k) = CurInstr(P2,Comput(P2,s2,i)) &
  Comput(P1,s1,i)|dom (DataPart p) = Comput(P2,s2,i)|dom DataPart p &
  DataPart Comput(P1,s1 +* DataPart s2,i) = DataPart Comput(P2,s2,i)
proof
  let p be autonomic FinPartState of SCM R such that
A1: IC SCM R in dom p and
A2: NPP p c= s1 and
A3: NPP Relocated (p,k) c= s2;
B1: IC SCM R in dom NPP p by A1,COMPOS_1:179;
  let P1,P2 be (the Instructions of SCM R)-valued ManySortedSet of NAT
  such that
A4: ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2;
 set s = s1 +* DataPart s2;
  defpred P[Element of NAT] means
   IC Comput(P1,s1,$1) + k = IC Comput(P2,s2,$1) &
IncAddr(CurInstr(P1,Comput(P1,s1,$1)), k) =
CurInstr(P2,Comput(P2,s2,$1)) &
Comput(P1,s1,$1)|dom (DataPart p) = Comput(P2,s2,$1)|dom DataPart p &
 DataPart Comput(P1,s,$1) = DataPart Comput(P2,s2,$1);
A6: p is non NAT-defined by A1,COMPOS_1:19;
A7: IC NPP p = IC s1 by A2,GRFUNC_1:8,B1;
  then IC NPP p = IC Comput(P1,s1,0) by EXTPRO_1:3;
  then
A8: IC NPP p in dom ProgramPart p by A2,A6,AMISTD_5:def 4,A4;
A9: NPP p c= s by A2,A3,COMPOS_1:203;
A10: for i being Element of NAT st P[i] holds P[i+1 qua Element of NAT]
  proof
    set DPp = DataPart p;
    let i be Element of NAT such that
A11: IC Comput(P1,s1,i) + k = IC Comput(P2,s2,i) and
A12:
IncAddr(CurInstr(P1,Comput(P1,s1,i)), k) =
CurInstr(P2,Comput(P2,s2,i))
and
A13: Comput(P1,s1,i)|dom DataPart p = Comput(P2,s2,i)|dom DataPart p and
A14: DataPart Comput(P1,s,i) = DataPart Comput(P2,s2,i);
    set Cs2i1 = Comput(P2,s2,i+1);
    set Cs3i = Comput(P1,s,i);
    set Cs2i = Comput(P2,s2,i);
A15: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:4
      .= Exec (CurInstr(P2,Cs2i), Cs2i);
A16: now
      let s be State of SCM R, d be Data-Location of R;
      d in Data-Locations SCM R by SCMRING2:32;
      hence d in dom DataPart s by COMPOS_1:50;
    end;
A17: now
      let d be Data-Location of R;
A18:  d in dom DataPart Cs3i by A16;
      hence Cs3i.d = (DataPart Cs3i).d by FUNCT_1:70
        .= Cs2i.d by A14,A18,FUNCT_1:70;
    end;
    set Cs1i1 = Comput(P1,s1,i+1);
    set Cs1i = Comput(P1,s1,i);
    dom Cs1i1 = the carrier of SCM R by PARTFUN1:def 4;
    then
A19: dom Cs1i1 = {IC SCM R} \/ Data-Locations SCM R \/ NAT by COMPOS_1:160;

A20: succ (IC Cs1i + k) = (succ IC Cs1i) + k;
A21: now
      reconsider loc = IC Cs1i1 as Element of NAT;
      assume
A22:  IC Comput(P1,s1,i+1) + k = IC Comput(P2
,s2,i+1);
A23:  loc in dom ProgramPart p by A2,A6,AMISTD_5:def 4,A4;
      loc + k in dom Reloc(ProgramPart p, k) by A23,COMPOS_1:158;
      then
A24:  Reloc(ProgramPart p, k).(loc + k) = P2.(loc + k)
           by GRFUNC_1:8,A4;
A25:  P2/.IC Comput(P2,s2,i+1)
    = P2.IC Comput(P2,s2,i+1) by PBOOLE:158;
      CurInstr(P1,Cs1i1) = P1.loc by PBOOLE:158
        .= (ProgramPart p).loc by A23,GRFUNC_1:8,A4;
      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       =
      CurInstr(P2,Comput(P2,s2,i+1))
       by A22,A23,A24,A25,COMPOS_1:122;
    end;
    dom Cs2i = the carrier of SCM R by PARTFUN1:def 4;
    then
A26: dom Cs2i = {IC SCM R} \/ Data-Locations SCM R \/ NAT by COMPOS_1:160;
    dom DPp = dom p /\ Data-Locations SCM R by RELAT_1:90;
    then
A27: dom DPp c= {IC SCM R} \/ Data-Locations SCM R by XBOOLE_1:10,17;
    set Cs3i1 = Comput(P1,s,i+1);
A28: dom DataPart Cs2i = Data-Locations SCM R by COMPOS_1:50;
A29: dom DataPart Cs3i1 = Data-Locations SCM R by COMPOS_1:50;
    then
A30: dom DataPart Cs3i1 c= dom DataPart Cs2i1 by COMPOS_1:50;
A31: dom DataPart Cs2i1 = Data-Locations SCM R by COMPOS_1:50;
A32: now
      let x be set;
      assume that
A33:  x in dom (DataPart Cs3i1) and
A34:  Cs3i1.x = Cs2i1.x;
      thus (DataPart Cs3i1).x = Cs2i1.x by A33,A34,FUNCT_1:70
        .= (DataPart Cs2i1).x by A29,A31,A33,FUNCT_1:70;
    end;
A35: dom DataPart Cs3i = Data-Locations SCM R by COMPOS_1:50;
A36: now
      let x be set;
      assume that
A37:  x in dom DataPart Cs3i1 and
A38:  Cs3i1.x = Cs3i.x & Cs2i1.x = Cs2i.x;
      (DataPart Cs3i).x = Cs3i.x by A35,A29,A37,FUNCT_1:70;
      hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A14,A28,A29,A32,A37,A38,
FUNCT_1:70;
    end;
    dom Cs1i = the carrier of SCM R by PARTFUN1:def 4;
    then
A39: dom Cs1i = {IC SCM R} \/ Data-Locations SCM R \/ NAT by COMPOS_1:160;
    dom Cs2i1 = the carrier of SCM R by PARTFUN1:def 4;
    then
A40: dom Cs2i1 = {IC SCM R} \/ Data-Locations SCM R \/ NAT by COMPOS_1:160;
    set I = CurInstr(P1,Cs1i);
A41: Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:4
      .= Exec (CurInstr(P1,Cs1i), Cs1i);
A42: dom (Cs1i|dom DPp) = dom Cs1i /\ dom DPp by RELAT_1:90
      .= dom DPp by A39,A27,XBOOLE_1:10,28;
A43: dom (Cs1i1|dom DPp) = dom Cs1i1 /\ dom DPp by RELAT_1:90
      .= dom DPp by A19,A27,XBOOLE_1:10,28;
A44: dom DataPart p = dom DataPart(Relocated (p, k)) by COMPOS_1:115;
    then
A45: dom (Cs2i1|dom DataPart(Relocated(p, k))) = dom Cs2i1 /\ dom DPp by
RELAT_1:90
      .= dom DPp by A40,A27,XBOOLE_1:10,28;
    then
A46: dom (Cs1i1|dom DPp)c=dom (Cs2i1|dom DPp) by A43,COMPOS_1:115;
A47: dom (Cs2i|dom DataPart(Relocated(p, k))) = dom Cs2i /\ dom DPp by A44,
RELAT_1:90
      .= dom DPp by A26,A27,XBOOLE_1:10,28;
A48: now
      let x be set, d be Data-Location of R such that
A49:  d = x and
A50:  d in dom DPp and
A51:  Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d;
A52:  (Cs1i|dom DPp).d = Cs1i.d & (Cs2i|dom DPp).d = Cs2i.d by A44,A42,A47,A50,
FUNCT_1:70;
      thus (Cs1i1|dom DPp).x = Cs1i1.d by A43,A49,A50,FUNCT_1:70
        .= (Cs2i1|dom DPp).x by A13,A44,A45,A49,A50,A51,A52,FUNCT_1:70;
    end;
A53: now
      let x be set, d be Data-Location of R such that
A54:  d = x & d in dom DPp and
A55:  Cs1i1.d = Cs2i1.d;
      thus (Cs1i1|dom DPp).x = Cs2i1.d by A43,A54,A55,FUNCT_1:70
        .= (Cs2i1|dom DPp).x by A44,A45,A54,FUNCT_1:70;
    end;
A56: Cs3i1 = Following(P1,Cs3i) by EXTPRO_1:4
      .= Exec (CurInstr(P1,Cs1i), Cs3i)
       by A2,A6,A9,AMISTD_5:7,A4;
    per cases by NAT_1:32,SCMRING3:71;
    suppose
      InsCode I = 0;
      then
A57:  I = halt SCM R by SCMRING3:16;
      hence IC Comput(P1,s1,i+1) + k
       = IC Cs1i + k by A41,EXTPRO_1:def 3
        .= IC Comput(P2,s2,i+1)
         by A11,A12,A15,A57,EXTPRO_1:def 3;
      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1)) by A21;
A58:  Cs2i1 = Cs2i by A12,A15,A57,EXTPRO_1:def 3;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A13,A41,A57,EXTPRO_1:def 3;
      thus thesis by A14,A56,A57,A58,EXTPRO_1:def 3;
    end;
    suppose
      InsCode I = 1;
      then consider da, db being Data-Location of R such that
A59:  I = da := db by SCMRING3:17;
A60:  IncAddr(I, k) = da := db by A59,COMPOS_1:92;
A61:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A59,SCMRING2:13;
      hence
      IC Comput(P1,s1,i+1) + k = IC Comput(P2
,s2,i+1)
      by A11,A12,A41,A15,A20,A60,SCMRING2:13;
      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)),k)
       = CurInstr(P2,Comput(P2,s2,i+1))
       by A11,A12,A21,A41,A15,A20,A60,A61,SCMRING2:13;
A62:  Cs3i.db = Cs2i.db by A17;
      now
        DPp c= p by RELAT_1:88;
        then
A63:    dom DPp c= dom p by GRFUNC_1:8;
        let x be set;
        assume
A64:    x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM R by RELAT_1:87;
        then reconsider d = x as Data-Location of R by A43,A64,SCMRING2:32;
        per cases;
        suppose
A65:      da = d;
          then Cs1i1.d = Cs1i.db & Cs2i1.d = Cs2i.db by A12,A41,A15,A59,A60,
SCMRING2:13;
          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A6,A9,A43,A53,A59,A62
,A64,A63,A65,Th9,A4;
        end;
        suppose
          da <> d;
          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A41,A15,A59,A60,
SCMRING2:13;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A43,A48,A64;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A46,GRFUNC_1:8;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A44,A43,A45,GRFUNC_1:9;
      now
        let x be set;
        assume
A66:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A29,SCMRING2:32;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = Cs2i.db & Cs3i1.d=Cs3i.db by A12,A15,A56,A59,A60,
SCMRING2:13;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A17,A32,A66;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A56,A59,A60,
SCMRING2:13;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A36,A66;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A30,
GRFUNC_1:8;
      hence thesis by A29,A31,GRFUNC_1:9;
    end;
    suppose
      InsCode I = 2;
      then consider da, db being Data-Location of R such that
A67:  I = AddTo(da, db) by SCMRING3:18;
A68:  IncAddr(I, k) = AddTo(da, db) by A67,COMPOS_1:92;
A69:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A67,SCMRING2:14;
      hence
      IC Comput(P1,s1,i+1) + k = IC Comput(P2
,s2,i+1)
      by A11,A12,A41,A15,A20,A68,SCMRING2:14;
      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1))
       by A11,A12,A21,A41,A15,A20,A68,A69,SCMRING2:14;
A70:  Cs3i.da = Cs2i.da & Cs3i.db = Cs2i.db by A17;
      now
        DPp c= p by RELAT_1:88;
        then
A71:    dom DPp c= dom p by GRFUNC_1:8;
        let x be set such that
A72:    x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM R by RELAT_1:87;
        then reconsider d = x as Data-Location of R by A43,A72,SCMRING2:32;
        per cases;
        suppose
A73:      da = d;
          then Cs1i1.d = Cs1i.da + Cs1i.db & Cs2i1.d = Cs2i.da + Cs2i.db by A12
,A41,A15,A67,A68,SCMRING2:14;
          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A6,A9,A43,A53,A67,A70
,A72,A71,A73,Th10,A4;
        end;
        suppose
          da <> d;
          then Cs1i1.d=Cs1i.d & Cs2i1.d = Cs2i.d by A12,A41,A15,A67,A68,
SCMRING2:14;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A43,A48,A72;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A46,GRFUNC_1:8;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A44,A43,A45,GRFUNC_1:9;
      now
        let x be set;
        assume
A74:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A29,SCMRING2:32;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = Cs2i.da + Cs2i.db & Cs3i1.d = Cs3i.da + Cs3i.db by A12
,A15,A56,A67,A68,SCMRING2:14;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A32,A70,A74;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A56,A67,A68,
SCMRING2:14;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A36,A74;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A30,
GRFUNC_1:8;
      hence thesis by A29,A31,GRFUNC_1:9;
    end;
    suppose
      InsCode I = 3;
      then consider da, db being Data-Location of R such that
A75:  I = SubFrom(da, db) by SCMRING3:19;
A76:  IncAddr(I, k) = SubFrom(da, db) by A75,COMPOS_1:92;
A77:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A75,SCMRING2:15;
      hence
      IC Comput(P1,s1,i+1) + k = IC Comput(P2
,s2,i+1)
      by A11,A12,A41,A15,A20,A76,SCMRING2:15;
      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1))
      by A11,A12,A21,A41,A15,A20,A76,A77,SCMRING2:15;
A78:  Cs3i.da = Cs2i.da & Cs3i.db = Cs2i.db by A17;
      now
        DPp c= p by RELAT_1:88;
        then
A79:    dom DPp c= dom p by GRFUNC_1:8;
        let x be set such that
A80:    x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM R by RELAT_1:87;
        then reconsider d = x as Data-Location of R by A43,A80,SCMRING2:32;
        per cases;
        suppose
A81:      da = d;
          then Cs1i1.d = Cs1i.da - Cs1i.db & Cs2i1.d = Cs2i.da - Cs2i.db by A12
,A41,A15,A75,A76,SCMRING2:15;
          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A6,A9,A43,A53,A75,A78
,A80,A79,A81,Th11,A4;
        end;
        suppose
          da <> d;
          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A41,A15,A75,A76,
SCMRING2:15;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A43,A48,A80;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A46,GRFUNC_1:8;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A44,A43,A45,GRFUNC_1:9;
      now
        let x be set;
        assume
A82:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A29,SCMRING2:32;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = Cs2i.da - Cs2i.db & Cs3i1.d = Cs3i.da - Cs3i.db by A12
,A15,A56,A75,A76,SCMRING2:15;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A32,A78,A82;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A56,A75,A76,
SCMRING2:15;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A36,A82;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A30,
GRFUNC_1:8;
      hence thesis by A29,A31,GRFUNC_1:9;
    end;
    suppose
      InsCode I = 4;
      then consider da, db being Data-Location of R such that
A83:  I = MultBy(da, db) by SCMRING3:20;
A84:  IncAddr(I, k) = MultBy(da, db) by A83,COMPOS_1:92;
A85:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A83,SCMRING2:16;
      hence
      IC Comput(P1,s1,i+1) + k = IC Comput(P2
,s2,i+1)
      by A11,A12,A41,A15,A20,A84,SCMRING2:16;
      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1))
      by A11,A12,A21,A41,A15,A20,A84,A85,SCMRING2:16;
A86:  Cs3i.da = Cs2i.da & Cs3i.db = Cs2i.db by A17;
      now
        DPp c= p by RELAT_1:88;
        then
A87:    dom DPp c= dom p by GRFUNC_1:8;
        let x be set such that
A88:    x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM R by RELAT_1:87;
        then reconsider d = x as Data-Location of R by A43,A88,SCMRING2:32;
        per cases;
        suppose
A89:      da = d;
          then Cs1i1.d = Cs1i.da * Cs1i.db & Cs2i1.d = Cs2i.da * Cs2i.db by A12
,A41,A15,A83,A84,SCMRING2:16;
          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A6,A9,A43,A53,A83,A86
,A88,A87,A89,Th12,A4;
        end;
        suppose
          da <> d;
          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A41,A15,A83,A84,
SCMRING2:16;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A43,A48,A88;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A46,GRFUNC_1:8;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A44,A43,A45,GRFUNC_1:9;
      now
        let x be set;
        assume
A90:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A29,SCMRING2:32;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = Cs2i.da * Cs2i.db & Cs3i1.d = Cs3i.da * Cs3i.db by A12
,A15,A56,A83,A84,SCMRING2:16;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A32,A86,A90;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A56,A83,A84,
SCMRING2:16;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A36,A90;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A30,
GRFUNC_1:8;
      hence thesis by A29,A31,GRFUNC_1:9;
    end;
    suppose
      InsCode I = 5;
      then consider
      da being Data-Location of R, r being Element of R such that
A91:  I = da:=r by SCMRING3:21;
A92:  IncAddr(I, k) = da := r by A91,COMPOS_1:92;
A93:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A91,SCMRING2:19;
      hence
      IC Comput(P1,s1,i+1) + k = IC Comput(P2
,s2,i+1)
      by A11,A12,A41,A15,A20,A92,SCMRING2:19;
      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1))
      by A11,A12,A21,A41,A15,A20,A92,A93,SCMRING2:19;
      now
        let x be set;
        assume
A94:    x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM R by RELAT_1:87;
        then reconsider d = x as Data-Location of R by A43,A94,SCMRING2:32;
        per cases;
        suppose
A95:      da = d;
          thus (Cs1i1|dom DPp).x = Cs1i1.d by A43,A94,FUNCT_1:72
            .= r by A41,A91,A95,SCMRING2:19
            .= Cs2i1.d by A12,A15,A92,A95,SCMRING2:19
            .= (Cs2i1|dom DPp).x by A43,A94,FUNCT_1:72;
        end;
        suppose
          da <> d;
          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A41,A15,A91,A92,
SCMRING2:19;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A43,A48,A94;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A46,GRFUNC_1:8;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A44,A43,A45,GRFUNC_1:9;
      now
        let x be set;
        assume
A96:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A29,SCMRING2:32;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = r & Cs3i1.d = r
           by A12,A15,A56,A91,A92,SCMRING2:19;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A32,A96;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A56,A91,A92,
SCMRING2:19;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A36,A96;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A30,
GRFUNC_1:8;
      hence thesis by A29,A31,GRFUNC_1:9;
    end;
    suppose
      InsCode I = 6;
      then consider loc being Element of NAT such that
A97:  I = goto(loc,R) by SCMRING3:22;
A98:  CurInstr(P2,Cs2i) = goto (loc + k,R)
by A12,A97,SCMRING3:69;
      thus IC Comput(P1,s1,i+1) + k = loc + k
       by A41,A97,SCMRING2:17
        .= IC Comput(P2,s2,i+1) by A15,A98,SCMRING2:17;
      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1)) by A21;
      now
        let x be set such that
A99:   x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM R by RELAT_1:87;
        then reconsider d = x as Data-Location of R by A43,A99,SCMRING2:32;
        Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d
            by A41,A15,A97,A98,SCMRING2:17;
        hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A43,A48,A99;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A46,GRFUNC_1:8;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A44,A43,A45,GRFUNC_1:9;
      now
        let x be set;
        assume
A100:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A29,SCMRING2:32;
        Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d
           by A15,A56,A97,A98,SCMRING2:17;
        hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A36,A100;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A30,
GRFUNC_1:8;
      hence thesis by A29,A31,GRFUNC_1:9;
    end;
    suppose
      InsCode I = 7;
      then consider
      da being Data-Location of R, loc being Element of NAT
      such that
A101: I = da=0_goto loc by SCMRING3:23;
A102: now
        per cases;
        case
          Cs1i.da = 0.R;
          hence IC Comput(P1,s1,i+1) + k = loc + k by A41,A101,
SCMRING2:18;
        end;
        case
          Cs1i.da <> 0.R;
          hence
          IC Comput(P1,s1,i+1) + k = succ (IC Cs2i)
          by A11,A41,A20,A101,SCMRING2:18;
        end;
      end;
A103: CurInstr(P2,Cs2i)
 = da=0_goto (loc + k) by A12,A101,SCMRING3:70;
A104: now
        per cases;
        case
          Cs2i.da = 0.R;
          hence IC Comput(P2,s2,i+1) = loc + k
          by A15,A103,SCMRING2:18;
        end;
        case
          Cs2i.da <> 0.R;
          hence IC Comput(P2,s2,i+1) = succ IC Cs2i by A15,A103,
SCMRING2:18;
        end;
      end;
A105: Cs3i.da = Cs2i.da by A17;
      now
        per cases;
        suppose
          loc <> succ IC Cs1i;
          hence IC Comput(P1,s1,i+1) + k = IC Comput(
P2,s2,i+1)
          by A2,A6,A9,A101,A105,A102,A104,Th13,A4;
        end;
        suppose
          loc = succ IC Cs1i;
          hence
          IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,i+1)
          by A11,A102,A104;
        end;
      end;
      hence IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,i+1) &
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k) =
      CurInstr(P2,Comput(P2,s2,i+1))
       by A21;
      now
        let x be set such that
A106:   x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM R by RELAT_1:87;
        then reconsider d = x as Data-Location of R by A43,A106,SCMRING2:32;
        Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d
        by A41,A15,A101,A103,SCMRING2:18;
        hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A43,A48,A106;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A46,GRFUNC_1:8;
      hence Comput(P1,s1,i+1)|dom (DataPart p)
       = Comput(P2,s2,i+1)|dom DataPart p by A44,A43,A45,GRFUNC_1:9;
      now
        let x be set;
        assume
A107:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A29,SCMRING2:32;
        Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d
        by A15,A56,A101,A103,SCMRING2:18;
        hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A36,A107;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A30,
GRFUNC_1:8;
      hence thesis by A29,A31,GRFUNC_1:9;
    end;
  end;
A110: DataPart p = DataPart (Relocated (p,k)) by COMPOS_1:115;
B127: DataPart NPP p c= NPP p by RELAT_1:88;
  DataPart p = DataPart NPP p by COMPOS_1:73;
    then
X1: DataPart p c= s1 by A2,B127,XBOOLE_1:1;
    DataPart Relocated (p,k) c= NPP Relocated (p,k) by COMPOS_1:169;
    then
X2: DataPart p c= s2 by A3,A110,XBOOLE_1:1;
A111: Comput(P1,s1,0)|dom (DataPart p) = s1 | dom (DataPart p) by
EXTPRO_1:3
    .= DataPart p by GRFUNC_1:64,X1
    .= s2 | dom (DataPart p) by GRFUNC_1:64,X2
    .= Comput(P2,s2,0)|dom DataPart p by EXTPRO_1:3;
A112: DataPart Comput(P1,s,0) = DataPart(s1 +* DataPart s2) by EXTPRO_1:3
    .= DataPart s2 by PBOOLE:157
    .= DataPart Comput(P2,s2,0) by EXTPRO_1:3;
A113: IC SCM R in dom Relocated(p,k) by COMPOS_1:119;
   then
B130: IC SCM R in dom NPP Relocated(p,k) by COMPOS_1:179;
A114: IC Comput(P1,s1,0) + k = IC s1 + k by EXTPRO_1:3
      .= IC NPP p + k by A2,GRFUNC_1:8,B1
    .= IC p + k by A1,COMPOS_1:72
    .= IC Relocated(p,k) by A1,COMPOS_1:120
      .= IC NPP Relocated(p,k) by A113,COMPOS_1:72
    .= IC s2 by A3,GRFUNC_1:8,B130
    .= IC Comput(P2,s2,0) by EXTPRO_1:3;
 IC SCM R in dom Relocated (p, k) by COMPOS_1:119;
      then
B134: IC SCM R in dom NPP Relocated (p, k) by COMPOS_1:179;
A116: (IC NPP p) + k in dom Reloc(ProgramPart p,k) by A8,COMPOS_1:158;
B117:  P2/.IC s2 = P2.IC s2 by PBOOLE:158;
 Comput(P2,s2,0) = s2 by EXTPRO_1:3;
 then
A118: CurInstr(P2,Comput(P2,s2,0))
     = P2.IC s2 by B117
    .= P2.(IC NPP Relocated (p, k)) by A3,GRFUNC_1:8,B134
     .= P2.(IC Relocated (p, k)) by GRFUNC_1:8,B134
    .= P2.((IC p) + k) by A1,COMPOS_1:120
      .= P2.((IC NPP p) +k) by A1,COMPOS_1:72
    .= (Reloc(ProgramPart p,k)).((IC NPP p) + k) by A116,GRFUNC_1:8,A4;
A119: (ProgramPart p).IC NPP p
    = P1.IC s1 by A7,A8,GRFUNC_1:8,A4;
A120:  IC Comput(P1,s1,0) + k = IC Comput(P2,s2,0)
      by A114;
A121:  CurInstr(P1,s1) = (ProgramPart p).IC NPP p by A119,PBOOLE:158;
A122: IncAddr(CurInstr(P1,Comput(P1,s1,0)), k)
      = IncAddr(CurInstr(P1,s1), k) by EXTPRO_1:3
     .= CurInstr(P2,Comput(P2,s2,0)) by A118,A8,COMPOS_1:122,A121;
A124: P[0 qua Element of NAT] by A120,A122,A111,A112;
  for n holds P[n] from NAT_1:sch 1(A124,A10);
  hence thesis;
end;

registration let R be non trivial good Ring;
 cluster SCM R -> relocable1 relocable2;
 coherence
  proof
   thus SCM R is relocable1
   proof
   thus
    for k being Element of NAT, p being autonomic FinPartState of
SCM R , s1, s2 being State of SCM R st IC SCM R in dom p &
    NPP p c= s1 & NPP Relocated (p,k) c= s2
  for P1,P2 being (the Instructions of SCM R)-valued ManySortedSet of NAT
   st ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2
for i being Element of NAT
 holds IncAddr(CurInstr(P1,Comput(P1,s1,i)), k)
  = CurInstr(P2,Comput(P2,s2,i)) by Th14;
  end;
  let k be Element of NAT, p be autonomic FinPartState of SCM R,
      s1, s2 be State of SCM R;
  assume
A1:  IC SCM R in dom p & NPP p c= s1 & NPP Relocated(p,k) c= s2;
  let P1,P2 be (the Instructions of SCM R)-valued ManySortedSet of NAT;
  assume ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2;
  hence for i being Element of NAT holds
   Comput(P1,s1,i)|dom DataPart p =
    Comput(P2,s2,i)|dom DataPart p by A1,Th14;
  end;
end;

