:: Relocability for { \bf SCM } over Ring
::  by Artur Korni{\l}owicz and Yasunari Shidama
::
:: Received February 6, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabularies AMI_3, SCMFSA7B, FUNCSDOM, AMI_1, ORDINAL2, AMI_2, BOOLE,
      FUNCT_1, FUNCOP_1, CAT_1, ARYTM, RELAT_1, AMI_5, FUNCT_4,
      REALSET1, RLVECT_1, ARYTM_1, CARD_3, RELOC, PARTFUN1, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, DOMAIN_1, ORDINAL1,
      RELAT_1, NUMBERS, XXREAL_0, FUNCT_1, PARTFUN1, FUNCT_2, STRUCT_0,
      ALGSTR_0, FUNCSDOM, FUNCOP_1, XCMPLX_0, NAT_1, RLVECT_1, FUNCT_4, CARD_3,
      FUNCT_7, BINARITH, VALUED_1, AMI_1,
      SCMNORM, AMI_2, AMI_3, SCMRING1, SCMRING2,
      AMISTD_1, SCMRING3, AMISTD_2;
 constructors WELLORD2, XXREAL_0, NAT_1, REALSET2, AMI_5, AMISTD_2, SCMRING3,
      SCMNORM, PARTFUN1, VALUED_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, FRAENKEL,
      XREAL_0, NAT_1, CARD_3, REALSET1, STRUCT_0, AMI_1, AMI_3, AMI_5,
      SCMRING1, SCMRING2, AMISTD_2, SCMRING3, FINSET_1, AMI_2, ORDINAL1,
      SCMNORM, NUMBERS, RELSET_1, FINSEQ_1, CARD_1;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions AMI_1, XBOOLE_0, FUNCOP_1, AMI_3, AMI_2, AMISTD_1, AMISTD_2,
      SCMNORM;
 theorems TARSKI, NAT_1, AMI_1, SCMRING2, AMI_3, FUNCT_4, AMI_5, FUNCT_1,
      FUNCT_2, RELSET_1, ZFMISC_1, FUNCOP_1, SCMRING1, AMI_2, FINSET_1,
      ANPROJ_1, CARD_3, XBOOLE_0, XBOOLE_1, RELAT_1, GRFUNC_1,
      SCMRING3, AMISTD_1, ORDINAL1, AMISTD_2, SCMNORM;
 schemes NAT_1;

begin :: On the standard computers

reserve i, j, k for natural number,
  n for Element of NAT,
  IL for non empty set,
  N for with_non-empty_elements set;

Lm1: for a,A being set st A /\ {a} <> {} holds a in A
proof
  let a,A be set;
  assume A /\ {a} <> {};
  then A meets {a} by XBOOLE_0:def 7;
  hence thesis by ZFMISC_1:56;
end;

begin :: SCM R

reserve R for good Ring,
  a, b for Data-Location of R,
  loc for Instruction-Location of SCM R,
  I for Instruction of SCM R,
  p for FinPartState of SCM R,
  s, s1, s2 for State of SCM R,
  q for FinPartState of SCM;

theorem Th14:
  the carrier of SCM R = {IC SCM R} \/ SCM-Data-Loc \/ NAT
proof
  IC SCM R = IC SCM by AMI_3:4,SCMRING2:9;
  hence thesis by AMI_5:23,SCMRING2:def 1;
end;

theorem
  ObjectKind loc = SCM-Instr R
proof
  reconsider i = loc as Element of NAT by AMI_1:def 4;
  thus ObjectKind loc = (SCM-OK R).i by SCMRING2:def 1
    .= SCM-Instr R by SCMRING1:6;
end;

theorem Th16:
  dl.(R,n) = [1,n]
proof
  thus dl.(R,n) = dl.n by SCMRING3:def 1
    .= [1,n];
end;

theorem
  il.(SCM R,k) = k
proof
  thus il.(SCM R,k) = il.k by SCMRING3:66
    .= k;
end;

theorem
  for dl being Data-Location of R ex i being Element of NAT st dl = dl.(R,i)
proof
  let dl be Data-Location of R;
  dl in SCM-Data-Loc by SCMRING2:1;
  then consider i being Element of NAT such that
A1: dl = [1,i] by AMI_2:32;
  take i;
  thus dl = dl.(R,i) by A1,Th16;
end;

theorem
  for i,j being Element of NAT holds i <> j implies dl.(R,i) <> dl.(R,j)
proof
  let i,j be Element of NAT;
A1: dl.(R,j) = [1,j] & dl.(R,i) = [1,i] by Th16;
  assume i <> j;
  hence thesis by A1,ZFMISC_1:33;
end;

theorem Th20:
  a <> loc
proof
  assume a = loc;
  then loc in (the carrier of SCM R) \ (NAT \/ {NAT})
  by SCMRING2:def 2;
  then not loc in NAT \/ {NAT} by XBOOLE_0:def 4;
  then not loc in NAT by XBOOLE_0:def 2;
  hence thesis by AMI_1:def 4;
end;

Lm6: now
  let R;
  thus the carrier of SCM = {IC SCM R} \/ SCM-Data-Loc \/ NAT
  by SCMRING2:9
    .= the carrier of SCM R by Th14;
end;

theorem
  SCM-Data-Loc c= dom s
proof
  Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
 hence SCM-Data-Loc c= dom s by SCMNORM:13;
end;

theorem Th22:
  dom DataPart s = SCM-Data-Loc
proof
   Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
  hence dom DataPart s = SCM-Data-Loc by SCMNORM:14;
end;

theorem
  p = q implies DataPart p = DataPart q
proof
  assume p = q;
  hence DataPart p = q | ((the carrier of SCM) \ ({IC SCM R} \/ NAT)) by Lm6
    .= DataPart q by AMI_3:4,SCMRING2:9;
end;

canceled;

theorem
 p is data-only iff dom p c= SCM-Data-Loc
proof
  Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
  hence thesis by AMI_1:139;
end;

theorem Th26:
  dom DataPart p c= SCM-Data-Loc
proof
  Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
  hence dom DataPart p c= SCM-Data-Loc by RELAT_1:87;
end;

theorem
  NAT c= dom s
proof
A1: dom s = the carrier of SCM R by AMI_1:79;
  NAT c= {IC SCM R} \/ SCM-Data-Loc \/ NAT by XBOOLE_1:7;
  hence NAT c= dom s by A1,Th14;
end;

theorem
  p = q implies ProgramPart p = ProgramPart q;

theorem
  dom ProgramPart p c= NAT by RELAT_1:87;

canceled;

theorem
  IncAddr(goto loc,k) = goto (loc + k) by SCMRING3:69;

theorem
  IncAddr(a=0_goto loc,k) = a=0_goto (loc + k)
   by SCMRING3:70;

theorem Th33:
  s.a = (s +* Start-At loc).a
proof
A1: dom (Start-At loc) = {IC SCM R} by FUNCOP_1:19;
  a in the carrier of SCM R;
  then a in dom s by AMI_1:79;
  then
A2: a in dom s \/ dom (Start-At loc) by XBOOLE_0:def 2;
  a <> IC SCM R by SCMRING3:3;
  then not a in {IC SCM R} by TARSKI:def 1;
  hence s.a = (s +* Start-At loc).a by A1,A2,FUNCT_4:def 1;
end;

theorem Th34:
  IC(s1) = IC(s2) & (for a being Data-Location of R holds s1.a = s2.a) &
  (for i being Instruction-Location of SCM R holds s1.i = s2.i)
  implies s1 = s2
proof
  assume that
A1: IC(s1) = IC(s2) and
A2: for a being Data-Location of R holds s1.a = s2.a and
A3: for i being Instruction-Location of SCM R holds s1.i = s2.i;
  s1 is Element of product SCM-OK R by SCMRING2:def 1;
  then consider g1 being Function such that
A4: s1 = g1 & dom g1 = dom SCM-OK R &
  for x being set st x in dom SCM-OK R holds g1.x in (SCM-OK R).x
  by CARD_3:def 5;
  s2 is Element of product SCM-OK R by SCMRING2:def 1;
  then consider g2 being Function such that
A5: s2 = g2 & dom g2 = dom SCM-OK R &
  for x being set st x in dom SCM-OK R holds g2.x in (SCM-OK R).x
  by CARD_3:def 5;
A6: SCM-Memory = dom g1 & SCM-Memory = dom g2 by A4,A5,FUNCT_2:def 1;
  now
    let x be set such that
A7: x in SCM-Memory;
    SCM-Memory = {IC SCM R} \/ SCM-Data-Loc \/ NAT
    by SCMRING2:def 1;
    then
A8: x in {IC SCM R} \/ SCM-Data-Loc or x in NAT
    by A7,XBOOLE_0:def 2;
    per cases by A8,XBOOLE_0:def 2;
    suppose x in {IC SCM R};
      then x = IC SCM R by TARSKI:def 1;
      hence g1.x = g2.x by A1,A4,A5;
    end;
    suppose x in SCM-Data-Loc;
      then x is Data-Location of R by SCMRING2:1;
      hence g1.x = g2.x by A2,A4,A5;
    end;
    suppose x in NAT;
      then reconsider l = x as Instruction-Location of SCM R by AMI_1:def 4;
      l = x;
      hence g1.x = g2.x by A3,A4,A5;
    end;
  end;
  hence s1 = s2 by A4,A5,A6,FUNCT_1:9;
end;

theorem Th35:
  Exec(IncAddr(CurInstr s,k),s +* Start-At (IC s + k))
  = Following(s) +* Start-At (IC Following(s) + k)
proof
  set INS = CurInstr s;
  consider m being natural number such that
A1: IC s = il.(SCM R,m) by AMISTD_1:26;
A2: IC s + k = il.(SCM R,m + k) by A1,AMISTD_1:def 13;
A3: Next IC (s +* Start-At (IC s + k)) = Next (IC s + k) by AMI_1:111
    .= il.(SCM R,(m + k) + 1) by A2,SCMRING3:67
    .= il.(SCM R,m + 1 + k)
    .= il.(SCM R,m + 1) + k by AMISTD_1:def 13
    .= (Next il.(SCM R,m)) + k by SCMRING3:67
    .= IC (Exec(INS, s) +* Start-At ((Next IC s) + k)) by A1,AMI_1:111;
A4: now
    let d be Instruction-Location of SCM R;
    thus Exec(INS, s +* Start-At (IC s + k)).d
    = (s +* Start-At (IC s + k)).d by AMI_1:def 13
      .= s.d by AMI_1:112
      .= Exec(INS, s).d by AMI_1:def 13
      .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by AMI_1:112;
  end;
  per cases by NAT_1:32,SCMRING3:71;
  suppose InsCode INS = 0;
    then
A5: INS = halt SCM R by SCMRING3:16;
    then
A6: Following(s) = s by AMI_1:def 8;
    thus Exec(IncAddr(CurInstr s,k),s +* Start-At (IC s + k))
    = Exec(halt SCM R, s +* Start-At (IC s + k )) by A5,AMISTD_2:29
      .= Following(s) +* Start-At (IC Following(s) + k) by A6,AMI_1:def 8;
  end;
  suppose InsCode INS = 1;
    then consider da,db being Data-Location of R such that
A7: INS = da := db by SCMRING3:17;
A8: IncAddr(INS,k) = INS by A7,AMISTD_2:29;
A9: IC Exec(INS, s) = Next IC s by A7,SCMRING2:13;
A10: IC Exec(INS, s +* Start-At (IC s + k))
    = IC (Exec(INS, s) +* Start-At ((Next IC s) + k)) by A3,A7,SCMRING2:13;
    now
      let d be Data-Location of R;
      per cases;
      suppose
A11:    da = d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).db by A7,SCMRING2:13
          .= s.db by Th33
          .= Exec(INS, s).d by A7,A11,SCMRING2:13
          .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
      end;
      suppose
A12:    da <> d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).d by A7,SCMRING2:13
          .= s.d by Th33
          .= Exec(INS, s).d by A7,A12,SCMRING2:13
          .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
      end;
    end;
    hence thesis by A4,A8,A9,A10,Th34;
  end;
  suppose InsCode INS = 2;
    then consider da,db being Data-Location of R such that
A13: INS = AddTo(da, db) by SCMRING3:18;
A14: IncAddr(INS, k) = INS by A13,AMISTD_2:29;
A15: IC Exec(INS, s) = Next IC s by A13,SCMRING2:14;
A16: IC Exec(INS, s +* Start-At (IC s + k))
    = IC (Exec(INS, s) +* Start-At ((Next IC s) + k)) by A3,A13,SCMRING2:14;
    now
      let d be Data-Location of R;
      per cases;
      suppose
A17:    da = d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).da + (s +* Start-At (IC s + k)).db
        by A13,SCMRING2:14
          .= s.da + (s +* Start-At (IC s + k)).db by Th33
          .= s.da + s.db by Th33
          .= Exec(INS, s).d by A13,A17,SCMRING2:14
          .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
      end;
      suppose
A18:    da <> d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).d by A13,SCMRING2:14
          .= s.d by Th33
          .= Exec(INS, s).d by A13,A18,SCMRING2:14
          .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
      end;
    end;
    hence thesis by A4,A14,A15,A16,Th34;
  end;
  suppose InsCode INS = 3;
    then consider da,db being Data-Location of R such that
A19: INS = SubFrom(da, db) by SCMRING3:19;
A20: IncAddr(INS, k) = INS by A19,AMISTD_2:29;
A21: IC Exec(INS, s) = Next IC s by A19,SCMRING2:15;
A22: IC Exec(INS, s +* Start-At (IC s + k))
    = IC (Exec(INS, s) +* Start-At ((Next IC s) + k)) by A3,A19,SCMRING2:15;
    now
      let d be Data-Location of R;
      per cases;
      suppose
A23:    da = d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).da - (s +* Start-At (IC s + k)).db
        by A19,SCMRING2:15
          .= s.da - (s +* Start-At (IC s + k)).db by Th33
          .= s.da - s.db by Th33
          .= Exec(INS, s).d by A19,A23,SCMRING2:15
          .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
      end;
      suppose
A24:    da <> d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).d by A19,SCMRING2:15
          .= s.d by Th33
          .= Exec(INS, s).d by A19,A24,SCMRING2:15
          .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
      end;
    end;
    hence thesis by A4,A20,A21,A22,Th34;
  end;
  suppose InsCode INS = 4;
    then consider da,db being Data-Location of R such that
A25: INS = MultBy(da, db) by SCMRING3:20;
A26: IncAddr(INS, k) = INS by A25,AMISTD_2:29;
A27: IC Exec(INS, s) = Next IC s by A25,SCMRING2:16;
A28: IC Exec(INS, s +* Start-At (IC s + k))
    = IC (Exec(INS, s) +* Start-At ((Next IC s) + k)) by A3,A25,SCMRING2:16;
    now
      let d be Data-Location of R;
      per cases;
      suppose
A29:    da = d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).da * (s +* Start-At (IC s + k)).db
        by A25,SCMRING2:16
          .= s.da * (s +* Start-At (IC s + k)).db by Th33
          .= s.da * s.db by Th33
          .= Exec(INS, s).d by A25,A29,SCMRING2:16
          .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
      end;
      suppose
A30:    da <> d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).d by A25,SCMRING2:16
          .= s.d by Th33
          .= Exec(INS, s).d by A25,A30,SCMRING2:16
          .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
      end;
    end;
    hence thesis by A4,A26,A27,A28,Th34;
  end;
  suppose InsCode INS = 5;
    then consider da being Data-Location of R, r being Element of R such that
A31: INS = da:=r by SCMRING3:21;
A32: IncAddr(INS,k) = INS by A31,AMISTD_2:29;
A33: IC Exec(INS, s) = Next IC s by A31,SCMRING2:19;
A34: IC Exec(INS, s +* Start-At (IC s + k))
    = IC (Exec(INS, s) +* Start-At ((Next IC s) + k)) by A3,A31,SCMRING2:19;
    now
      let d be Data-Location of R;
      per cases;
      suppose
A35:    da = d;
        hence Exec(INS, s +* Start-At (IC s + k)).d = r by A31,SCMRING2:19
          .= Exec(INS, s).d by A31,A35,SCMRING2:19
          .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
      end;
      suppose
A36:    da <> d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).d by A31,SCMRING2:19
          .= s.d by Th33
          .= Exec(INS, s).d by A31,A36,SCMRING2:19
          .= (Exec(INS, s) +* Start-At ((Next IC s) + k)).d by Th33;
      end;
    end;
    hence thesis by A4,A32,A33,A34,Th34;
  end;
  suppose InsCode INS = 6;
    then consider loc being Instruction-Location of SCM R such that
A37: INS = goto loc by SCMRING3:22;
A38: IncAddr(INS, k) = goto (loc + k) by A37,SCMRING3:69;
A39: IC Exec(INS, s) = loc by A37,SCMRING2:17;
A40: IC Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
    = loc + k by A38,SCMRING2:17
      .= IC (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)) by A39,AMI_1:111;
A41: now
      let d be Data-Location of R;
      thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
      = (s +* Start-At (IC s + k)).d by A38,SCMRING2:17
        .= s.d by Th33
        .= Exec(INS, s).d by A37,SCMRING2:17
        .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by Th33;
    end;
    now
      let d be Instruction-Location of SCM R;
      thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
      = (s +* Start-At (IC s + k)).d by AMI_1:def 13
        .= s.d by AMI_1:112
        .= Exec(INS, s).d by AMI_1:def 13
        .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_1:112;
    end;
    hence thesis by A40,A41,Th34;
  end;
  suppose InsCode INS = 7;
    then consider da being Data-Location of R,
    loc being Instruction-Location of SCM R such that
A42: INS = da=0_goto loc by SCMRING3:23;
A43: IncAddr(INS, k) = da=0_goto (loc + k) by A42,SCMRING3:70;
    now per cases;
      suppose
A44:    s.da = 0.R;
        then
A45:    (s +* Start-At(IC s + k)).da=0.R by Th33;
A46:    IC Exec(INS, s) = loc by A42,A44,SCMRING2:18;
A47:    IC Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
        = loc + k by A43,A45,SCMRING2:18

.= IC (Exec(INS,s) +* Start-At (IC Exec(INS, s) + k)) by A46,AMI_1:111;
A48:    now
          let d be Data-Location of R;
          thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by A43,SCMRING2:18
            .= s.d by Th33
            .= Exec(INS, s).d by A42,SCMRING2:18
            .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by Th33;
        end;
        now
          let d be Instruction-Location of SCM R;
          thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by AMI_1:def 13
            .= s.d by AMI_1:112
            .= Exec(INS, s).d by AMI_1:def 13
            .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_1:112;
        end;
        hence Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
        = Exec(INS, s) +* Start-At (IC Exec(INS, s) + k) by A47,A48,Th34;
      end;
      suppose
A49:    s.da <> 0.R;
        then
A50:    (s +* Start-At(IC s + k)).da<>0.R by Th33;
        IC Exec(INS, s) = Next IC s by A42,A49,SCMRING2:18;
        then
A51:    IC Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
        = IC (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)) by A3,A43,A50,
        SCMRING2:18;
A52:    now
          let d be Data-Location of R;
          thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by A43,SCMRING2:18
            .= s.d by Th33
            .= Exec(INS, s).d by A42,SCMRING2:18
            .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by Th33;
        end;
        now
          let d be Instruction-Location of SCM R;
          thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by AMI_1:def 13
            .= s.d by AMI_1:112
            .= Exec(INS, s).d by AMI_1:def 13
            .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_1:112;
        end;
        hence Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
        = (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)) by A51,A52,Th34;
      end;
    end;
    hence thesis;
  end;
end;

theorem Th36:
  IC s = il.(SCM R,j+k) implies Exec(I, s +* Start-At (IC s -' k))
  = Exec(IncAddr(I, k), s) +* Start-At (IC Exec(IncAddr(I,k), s) -' k)
proof
  assume
A1: IC s = il.(SCM R,j+k);
  then
A2: Next (IC s -' k) = Next (il.(SCM R,j) + k -' k) by AMISTD_1:def 13
    .= Next (il.(SCM R,j)) by AMISTD_1:61
    .= il.(SCM R,j+1) by SCMRING3:67
    .= il.(SCM R,j+1) + k -' k by AMISTD_1:61
    .= il.(SCM R,j+1+k) -' k by AMISTD_1:def 13
    .= il.(SCM R,j+k+1) -' k
    .= (Next IC s) -' k by A1,SCMRING3:67;
A3: now
    let d be Instruction-Location of SCM R;
    thus Exec(I, s +* Start-At (IC s -' k)).d
    = (s +* Start-At (IC s -' k)).d by AMI_1:def 13
      .= s.d by AMI_1:112
      .= Exec(IncAddr(I, k), s).d by AMI_1:def 13
      .= (Exec(IncAddr(I, k), s)
    +* Start-At (IC Exec(IncAddr(I,k), s) -' k)).d by AMI_1:112;
  end;
  per cases by NAT_1:32,SCMRING3:71;
  suppose InsCode I = 0;
    then
A4: I = halt SCM R by SCMRING3:16;
A5: IncAddr (halt SCM R, k) = halt SCM R by AMISTD_2:29;
    thus Exec(I, s +* Start-At (IC s -' k))
    = s +* Start-At (IC s -' k) by A4,AMI_1:def 8
      .= s +* Start-At (IC Exec(IncAddr(I,k), s) -' k) by A4,A5,AMI_1:def 8
      .= Exec(IncAddr(I, k), s) +* Start-At (IC Exec(IncAddr(I,k), s) -' k)
    by A4,A5,AMI_1:def 8;
  end;
  suppose InsCode I = 1;
    then consider da,db being Data-Location of R such that
A6: I = da := db by SCMRING3:17;
A7: IncAddr(I, k) = da := db by A6,AMISTD_2:29;
    then
A8: Exec(IncAddr(I,k), s).IC SCM R = Next IC s by SCMRING2:13;
A9: IC Exec(I, s +* Start-At (IC s -' k))
    = Next IC (s +* Start-At (IC s -' k)) by A6,SCMRING2:13
      .= IC Exec(IncAddr(I,k), s) -' k by A2,A8,AMI_1:111
      .= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s) -' k))
    by AMI_1:111;
    now
      let d be Data-Location of R;
      per cases;
      suppose
A10:    da = d;
        hence Exec(I, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).db by A6,SCMRING2:13
          .= s.db by Th33
          .= Exec(IncAddr(I,k), s).d by A7,A10,SCMRING2:13
          .= (Exec(IncAddr(I,k), s) +*
        Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
      end;
      suppose
A11:    da <> d;
        hence Exec(I, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).d by A6,SCMRING2:13
          .= s.d by Th33
          .= Exec(IncAddr(I, k), s).d by A7,A11,SCMRING2:13
          .= (Exec(IncAddr(I,k), s) +*
        Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
      end;
    end;
    hence thesis by A3,A9,Th34;
  end;
  suppose InsCode I = 2;
    then consider da,db being Data-Location of R such that
A12: I = AddTo(da, db) by SCMRING3:18;
A13: IncAddr(I, k) = AddTo(da, db) by A12,AMISTD_2:29;
    then
A14: Exec(IncAddr(I,k), s).IC SCM R = Next IC s by SCMRING2:14;
A15: IC Exec(I, s +* Start-At (IC s -' k))
    = Next IC (s +* Start-At (IC s -' k)) by A12,SCMRING2:14
      .= IC Exec(IncAddr(I,k), s) -' k by A2,A14,AMI_1:111
      .= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s) -' k))
    by AMI_1:111;
    now
      let d be Data-Location of R;
      per cases;
      suppose
A16:    da = d;
        hence Exec(I, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).da
        + (s +* Start-At (IC s -' k)).db by A12,SCMRING2:14
          .= s.da + (s +* Start-At (IC s -' k)).db by Th33
          .= s.da + s.db by Th33
          .= Exec(IncAddr(I,k), s).d by A13,A16,SCMRING2:14
          .= (Exec(IncAddr(I,k), s) +*
        Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
      end;
      suppose
A17:    da <> d;
        hence Exec(I, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).d by A12,SCMRING2:14
          .= s.d by Th33
          .= Exec(IncAddr(I, k), s).d by A13,A17,SCMRING2:14
          .= (Exec(IncAddr(I,k), s) +*
        Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
      end;
    end;
    hence thesis by A3,A15,Th34;
  end;
  suppose InsCode I = 3;
    then consider da,db being Data-Location of R such that
A18: I = SubFrom(da, db) by SCMRING3:19;
A19: IncAddr(I, k) = SubFrom(da, db) by A18,AMISTD_2:29;
    then
A20: Exec(IncAddr(I,k), s).IC SCM R = Next IC s by SCMRING2:15;
A21: IC Exec(I, s +* Start-At (IC s -' k))
    = Next IC (s +* Start-At (IC s -' k)) by A18,SCMRING2:15
      .= IC Exec(IncAddr(I,k), s) -' k by A2,A20,AMI_1:111
      .= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s) -' k))
    by AMI_1:111;
    now
      let d be Data-Location of R;
      per cases;
      suppose
A22:    da = d;
        hence Exec(I, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).da
        - (s +* Start-At (IC s -' k)).db by A18,SCMRING2:15
          .= s.da - (s +* Start-At (IC s -' k)).db by Th33
          .= s.da - s.db by Th33
          .= Exec(IncAddr(I,k), s).d by A19,A22,SCMRING2:15
          .= (Exec(IncAddr(I,k), s) +*
        Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
      end;
      suppose
A23:    da <> d;
        hence Exec(I, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).d by A18,SCMRING2:15
          .= s.d by Th33
          .= Exec(IncAddr(I, k), s).d by A19,A23,SCMRING2:15
          .= (Exec(IncAddr(I,k), s) +*
        Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
      end;
    end;
    hence thesis by A3,A21,Th34;
  end;
  suppose InsCode I = 4;
    then consider da,db being Data-Location of R such that
A24: I = MultBy(da, db) by SCMRING3:20;
A25: IncAddr(I, k) = MultBy(da, db) by A24,AMISTD_2:29;
    then
A26: Exec(IncAddr(I,k), s).IC SCM R = Next IC s by SCMRING2:16;
A27: IC Exec(I, s +* Start-At (IC s -' k))
    = Next IC (s +* Start-At (IC s -' k)) by A24,SCMRING2:16
      .= IC Exec(IncAddr(I,k), s) -' k by A2,A26,AMI_1:111
      .= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s) -' k))
    by AMI_1:111;
    now
      let d be Data-Location of R;
      per cases;
      suppose
A28:    da = d;
        hence Exec(I, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).da
        * (s +* Start-At (IC s -' k)).db by A24,SCMRING2:16
          .= s.da * (s +* Start-At (IC s -' k)).db by Th33
          .= s.da * s.db by Th33
          .= Exec(IncAddr(I,k), s).d by A25,A28,SCMRING2:16
          .= (Exec(IncAddr(I,k), s) +*
        Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
      end;
      suppose
A29:    da <> d;
        hence Exec(I, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).d by A24,SCMRING2:16
          .= s.d by Th33
          .= Exec(IncAddr(I, k), s).d by A25,A29,SCMRING2:16
          .= (Exec(IncAddr(I,k), s) +*
        Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
      end;
    end;
    hence thesis by A3,A27,Th34;
  end;
  suppose InsCode I = 5;
    then consider da being Data-Location of R, r being Element of R such that
A30: I = da:=r by SCMRING3:21;
A31: IncAddr(I, k) = da := r by A30,AMISTD_2:29;
    then
A32: Exec(IncAddr(I,k), s).IC SCM R = Next IC s by SCMRING2:19;
A33: IC Exec(I, s +* Start-At (IC s -' k))
    = Next IC (s +* Start-At (IC s -' k)) by A30,SCMRING2:19
      .= IC Exec(IncAddr(I,k), s) -' k by A2,A32,AMI_1:111
      .= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s) -' k))
    by AMI_1:111;
    now
      let d be Data-Location of R;
      per cases;
      suppose
A34:    da = d;
        hence Exec(I, s +* Start-At (IC s -' k)).d = r by A30,SCMRING2:19
          .= Exec(IncAddr(I,k), s).d by A31,A34,SCMRING2:19
          .= (Exec(IncAddr(I,k), s) +*
        Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
      end;
      suppose
A35:    da <> d;
        hence Exec(I, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).d by A30,SCMRING2:19
          .= s.d by Th33
          .= Exec(IncAddr(I, k), s).d by A31,A35,SCMRING2:19
          .= (Exec(IncAddr(I,k), s) +*
        Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
      end;
    end;
    hence thesis by A3,A33,Th34;
  end;
  suppose InsCode I = 6;
    then consider loc being Instruction-Location of SCM R such that
A36: I = goto loc by SCMRING3:22;
A37: IncAddr(I, k) = goto (loc + k) by A36,SCMRING3:69;
    then
A38: IC Exec(IncAddr(I,k), s)= loc + k by SCMRING2:17;
A39: IC Exec(I, s +* Start-At (IC s -' k)) = loc by A36,SCMRING2:17
      .= IC Exec(IncAddr(I,k), s) -' k by A38,AMISTD_1:61
      .= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s) -' k))
    by AMI_1:111;
    now
      let d be Data-Location of R;
      thus Exec(I, s +* Start-At (IC s -' k)).d
      = (s +* Start-At (IC s -' k)).d by A36,SCMRING2:17
        .= s.d by Th33
        .= Exec(IncAddr(I,k), s).d by A37,SCMRING2:17
        .= (Exec(IncAddr(I,k), s) +*
      Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
    end;
    hence thesis by A3,A39,Th34;
  end;
  suppose InsCode I = 7;
    then consider da being Data-Location of R,
    loc being Instruction-Location of SCM R such that
A40: I = da=0_goto loc by SCMRING3:23;
A41: IncAddr(I, k) = da=0_goto (loc + k) by A40,SCMRING3:70;
A42: now per cases;
      suppose
A43:    s.da = 0.R;
        then
A44:    (s +* Start-At (IC s -' k)).da = 0.R by Th33;
A45:    IC Exec(IncAddr(I,k), s)= loc + k by A41,A43,SCMRING2:18;
        IC Exec(I, s +* Start-At (IC s -' k)) = loc by A40,A44,SCMRING2:18
          .= IC Exec(IncAddr(I,k), s) -' k by A45,AMISTD_1:61

.= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s) -' k))
        by AMI_1:111;
        hence IC Exec(I, s +* Start-At (IC s -' k))
        = IC(Exec(IncAddr(I,k),s) +* Start-At(IC Exec(IncAddr(I,k),s)-'k));
      end;
      suppose
A46:    s.da <> 0.R;
        then
A47:    (s +* Start-At (IC s -' k)).da <> 0.R by Th33;
A48:    Exec(IncAddr(I,k), s).IC SCM R = Next IC s by A41,A46,SCMRING2:18;
        IC Exec(I, s +* Start-At (IC s -' k))
        = Next IC (s +* Start-At (IC s -' k)) by A40,A47,SCMRING2:18
          .= IC Exec(IncAddr(I,k), s) -' k by A2,A48,AMI_1:111
          .= IC(Exec(IncAddr(I,k),s) +* Start-At(IC Exec(IncAddr(I,k),s) -' k))
        by AMI_1:111;
        hence IC Exec(I, s +* Start-At (IC s -' k))
        = IC(Exec(IncAddr(I,k),s) +* Start-At(IC Exec(IncAddr(I,k),s)-'k));
      end;
    end;
    now
      let d be Data-Location of R;
      thus Exec(I, s +* Start-At (IC s -' k)).d
      = (s +* Start-At (IC s -' k)).d by A40,SCMRING2:18
        .= s.d by Th33
        .= Exec(IncAddr(I,k), s).d by A41,SCMRING2:18
        .= (Exec(IncAddr(I,k), s) +*
      Start-At (IC Exec(IncAddr(I,k),s) -' k)).d by Th33;
    end;
    hence thesis by A3,A42,Th34;
  end;
end;

registration
  let R;
  cluster autonomic non programmed FinPartState of SCM R;
  existence
  proof
    reconsider il = il.(SCM R,0) as Instruction-Location of SCM R;
    set P = (IC SCM R, il.(SCM R,0)) --> (il, halt SCM R);
    P = Start-At(il.(SCM R,0))+*((il.(SCM R,0)) .--> halt SCM R)
    by FUNCT_4:def 4;
    then reconsider P as FinPartState of SCM R;
    take P;
    reconsider h = halt SCM R as Element of ObjectKind il by AMI_1:def 14;
    ObjectKind IC SCM R = NAT by AMI_1:def 11;
    then reconsider l = il as Element of ObjectKind IC SCM R by AMI_1:def 4;
    (IC SCM R,il) --> (l, h) is autonomic by AMI_1:67;
    hence P is autonomic;
    now
      dom P = { IC SCM R, il.(SCM R,0) } by FUNCT_4:65;
      then
A1:   IC SCM R in dom P by TARSKI:def 2;
      assume dom P c= NAT;
      then reconsider l = IC SCM R as Instruction-Location of SCM R
      by A1,AMI_1:def 4;
      l = IC SCM R;
      hence contradiction by AMI_1:48;
    end;
    hence P is non programmed by AMI_1:def 40;
  end;
end;

definition
  let R;
  let a be Data-Location of R;
  let r be Element of R;
  redefine func a .--> r -> FinPartState of SCM R;
  coherence
  proof
    reconsider b = a as Element of SCM-Memory by SCMRING2:def 1;
    set k = a .--> r, f = the Object-Kind of SCM R;
A1: dom the Object-Kind of SCM R = dom SCM-OK R by SCMRING2:def 1
      .= SCM-Memory by FUNCT_2:def 1;
A2: dom k = {a} by FUNCOP_1:19;
A3: {b} is Subset of SCM-Memory;
    for x being set st x in dom k holds k.x in f.x
    proof
      let x be set;
      assume
A4:   x in dom k;
      then x = a by A2,TARSKI:def 1;
      then
A5:   k.x = r by FUNCOP_1:87;
      f.x = ObjectKind a by A2,A4,TARSKI:def 1
        .= the carrier of R by SCMRING3:1;
      hence k.x in f.x by A5;
    end;
    hence thesis by A1,A2,A3,CARD_3:def 9;
  end;
end;

theorem Th37:
  R is non trivial implies
  for p being autonomic FinPartState of SCM R st DataPart p <> {} holds
  IC SCM R in dom p
proof
  assume
A1: R is non trivial;
  let p be autonomic FinPartState of SCM R;
  assume DataPart p <> {};
  then
A2: dom DataPart p <> {};
  assume
A3: not IC SCM R in dom p;
  p is not autonomic
  proof
    consider d1 being Element of dom DataPart p;
A4: d1 in dom DataPart p by A2;
    dom DataPart p c= the carrier of SCM R by AMI_1:80;
    then reconsider d1 as Element of SCM R by A4;
    Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
    then dom DataPart p c= SCM-Data-Loc by RELAT_1:87;
    then reconsider d1 as Data-Location of R by A4,SCMRING2:1;
    consider d2 being Element of SCM-Data-Loc \ dom p;
    not SCM-Data-Loc c= dom p;
    then
A5: SCM-Data-Loc \ dom p <> {} by XBOOLE_1:37;
    then d2 in SCM-Data-Loc by XBOOLE_0:def 4;
    then reconsider d2 as Data-Location of R by SCMRING2:1;
    consider il being Element of (NAT) \ dom p;
    not NAT c= dom p;
    then
A6: (NAT) \ dom p <> {} by XBOOLE_1:37;
    then il is Element of NAT by XBOOLE_0:def 4;
    then reconsider il as Instruction-Location of SCM R by AMI_1:def 4;
    consider e being Element of R such that
A7: e <> 0.R by A1,ANPROJ_1:def 8;
    set p1 = p +* ((il .--> (d1:=d2)) +* (d2.--> 0.R) +* Start-At il);
    set p2 = p +* ((il .--> (d1:=d2)) +* (d2.--> e) +* Start-At il);
    consider s1 being State of SCM R such that
A8: p1 c= s1 by CARD_3:97;
    consider s2 being State of SCM R such that
A9: p2 c= s2 by CARD_3:97;
    take s1, s2;
A10: not d2 in dom p by A5,XBOOLE_0:def 4;
A11: not il in dom p by A6,XBOOLE_0:def 4;
    dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
    proof
      dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
      = dom((il .--> (d1:=d2)) +* ( d2.--> 0.R)) \/ dom(Start-At il)
      by FUNCT_4:def 1

.= dom((il .--> (d1:=d2)) +* ( d2.--> 0.R)) \/ {IC SCM R} by FUNCOP_1:19
        .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> 0.R) \/ {IC SCM R}
      by FUNCT_4:def 1
        .= {il} \/ dom ( d2.--> 0.R) \/ {IC SCM R} by FUNCOP_1:19
        .= {il} \/ {d2} \/ {IC SCM R} by FUNCOP_1:19;
      hence dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
      = dom p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM R} by XBOOLE_1:23
        .= dom p /\ ({il} \/ {d2}) \/ {} by A3,Lm1
        .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
        .= dom p /\ {il} \/ {} by A10,Lm1
        .= {} by A11,Lm1;
    end;
    then p c= p1 by FUNCT_4:33;
    hence p c= s1 by A8,XBOOLE_1:1;
    dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
    proof
      dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
      = dom((il .--> (d1:=d2)) +* ( d2.--> e)) \/ dom(Start-At il)
      by FUNCT_4:def 1
        .= dom((il .--> (d1:=d2)) +* ( d2.--> e)) \/ {IC SCM R} by FUNCOP_1:19
        .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> e) \/ {IC SCM R}
      by FUNCT_4:def 1
        .= {il} \/ dom ( d2.--> e) \/ {IC SCM R} by FUNCOP_1:19
        .= {il} \/ {d2} \/ {IC SCM R} by FUNCOP_1:19;
      hence dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
      = dom p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM R} by XBOOLE_1:23
        .= dom p /\ ({il} \/ {d2}) \/ {} by A3,Lm1
        .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
        .= dom p /\ {il} \/ {} by A10,Lm1
        .= {} by A11,Lm1;
    end;
    then p c= p2 by FUNCT_4:33;
    hence p c= s2 by A9,XBOOLE_1:1;
    take 1;
    DataPart p c= p by RELAT_1:88;
    then
A12: dom DataPart p c= dom p by RELAT_1:25;
    dom Computation(s1,1) = the carrier of SCM R by AMI_1:79;
    then
A13: dom (Computation(s1,1)|dom p) = dom p by AMI_1:80,RELAT_1:91;
A14: dom(Start-At il) = {IC SCM R} by FUNCOP_1:19;
    then
A15: IC SCM R in dom (Start-At il) by TARSKI:def 1;
A16: dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
    = dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R)) \/ dom(Start-At il)
    by FUNCT_4:def 1;
    then
A17: IC SCM R in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
    by A15,XBOOLE_0:def 2;
A18: dom p1 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
    by FUNCT_4:def 1;
    then IC SCM R in dom p1 by A17,XBOOLE_0:def 2;
    then
A19: IC s1 = p1.IC SCM R by A8,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il).IC SCM R
    by A17,FUNCT_4:14
      .= (Start-At il).IC SCM R by A15,FUNCT_4:14
      .= il by FUNCOP_1:87;
    dom (il .--> (d1:=d2)) = {il} by FUNCOP_1:19;
    then
A20: il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
A21: dom (d2 .--> 0.R) = {d2} by FUNCOP_1:19;
A22: il <> d2 by Th20;
    then
A23: not il in dom (d2 .--> 0.R) by A21,TARSKI:def 1;
A24: dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R))
    = dom (il .--> (d1:=d2)) \/ dom ( d2.--> 0.R) by FUNCT_4:def 1;
    then
A25: il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R)) by A20,XBOOLE_0: def 2;
A26: il <> IC SCM R by AMI_1:48;
    then
A27: not il in dom (Start-At il) by A14,TARSKI:def 1;
A28: il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
    by A16,A25,XBOOLE_0:def 2;
    then il in dom p1 by A18,XBOOLE_0:def 2;
    then
A29: s1.il = p1.il by A8,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il).il
    by A28,FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R)).il by A27,FUNCT_4:12
      .= (il .--> (d1:=d2)).il by A23,FUNCT_4:12
      .= d1:=d2 by FUNCOP_1:87;
A30: d2 in dom (d2 .--> 0.R) by A21,TARSKI:def 1;
    then
A31: d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R)) by A24,XBOOLE_0: def 2;
A32: d2 <> IC SCM R by SCMRING3:3;
    then
A33: not d2 in dom (Start-At il) by A14,TARSKI:def 1;
A34: d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il)
    by A16,A31,XBOOLE_0:def 2;
    then d2 in dom p1 by A18,XBOOLE_0:def 2;
    then
A35: s1.d2 = p1.d2 by A8,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At il).d2
    by A34,FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R)).d2 by A33,FUNCT_4:12
      .= (d2.--> 0.R).d2 by A30,FUNCT_4:14
      .= 0.R by FUNCOP_1:87;
    Computation(s1,0+1).d1 = (Following Computation(s1,0)).d1
    by AMI_1:14
      .= (Following s1).d1 by AMI_1:13
      .= 0.R by A19,A29,A35,SCMRING2:13;
    then
A36: (Computation(s1,1)|dom p).d1 = 0.R by A4,A12,A13,FUNCT_1:70;
    dom (Computation(s2,1)) = the carrier of SCM R by AMI_1:79;
    then
A37: dom (Computation(s2,1)|dom p) = dom p by AMI_1:80,RELAT_1:91;
A38: dom(Start-At il) = {IC SCM R} by FUNCOP_1:19;
    then
A39: IC SCM R in dom (Start-At il) by TARSKI:def 1;
A40: dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
    = dom ((il .--> (d1:=d2)) +* ( d2.--> e)) \/ dom(Start-At il)
    by FUNCT_4:def 1;
    then
A41: IC SCM R in dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il )
    by A39,XBOOLE_0:def 2;
A42: dom p2 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
    by FUNCT_4:def 1;
    then IC SCM R in dom p2 by A41,XBOOLE_0:def 2;
    then
A43: IC s2 = p2.IC SCM R by A9,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il).IC SCM R
    by A41,FUNCT_4:14
      .= (Start-At il).IC SCM R by A39,FUNCT_4:14
      .= il by FUNCOP_1:87;
    dom (il .--> (d1:=d2)) = {il} by FUNCOP_1:19;
    then
A44: il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
A45: dom (d2 .--> e) = {d2} by FUNCOP_1:19;
    then
A46: not il in dom (d2 .--> e) by A22,TARSKI:def 1;
A47: dom ((il .--> (d1:=d2)) +* ( d2.--> e))
    = dom (il .--> (d1:=d2)) \/ dom ( d2.--> e) by FUNCT_4:def 1;
    then
A48: il in dom ((il .--> (d1:=d2)) +* ( d2.--> e)) by A44,XBOOLE_0:def 2;
A49: not il in dom (Start-At il) by A26,A38,TARSKI:def 1;
A50: il in dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
    by A40,A48,XBOOLE_0:def 2;
    then il in dom p2 by A42,XBOOLE_0:def 2;
    then
A51: s2.il = p2.il by A9,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il).il
    by A50,FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> e)).il by A49,FUNCT_4:12
      .= (il .--> (d1:=d2)).il by A46,FUNCT_4:12
      .= d1:=d2 by FUNCOP_1:87;
A52: d2 in dom (d2 .--> e) by A45,TARSKI:def 1;
    then
A53: d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> e)) by A47,XBOOLE_0:def 2;
A54: not d2 in dom (Start-At il) by A32,A38,TARSKI:def 1;
A55: d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il)
    by A40,A53,XBOOLE_0:def 2;
    then d2 in dom p2 by A42,XBOOLE_0:def 2;
    then
A56: s2.d2 = p2.d2 by A9,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At il).d2
    by A55,FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> e)).d2 by A54,FUNCT_4:12
      .= (d2.--> e).d2 by A52,FUNCT_4:14
      .= e by FUNCOP_1:87;
    Computation(s2,0+1).d1 = (Following Computation(s2,0)).d1
    by AMI_1:14
      .= (Following s2).d1 by AMI_1:13
      .= e by A43,A51,A56,SCMRING2:13;
    hence Computation(s1,1)|dom p <> Computation(s2,1)|dom p by A4,A7,A12,A36
    ,A37,FUNCT_1:70;
  end;
  hence contradiction;
end;

theorem Th38:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R holds
  IC SCM R in dom p
proof
  assume
A1: R is non trivial;
  let p be autonomic non programmed FinPartState of SCM R;
A2: not dom p c= NAT by AMI_1:def 40;
  dom p = dom p /\ the carrier of SCM R by AMI_1:80,XBOOLE_1:28
    .= dom p /\ ({IC SCM R} \/ SCM-Data-Loc \/ NAT) by Th14
    .= dom p /\ ({IC SCM R} \/ SCM-Data-Loc) \/ dom p /\ NAT
  by XBOOLE_1:23;
  then dom p /\ ({IC SCM R} \/ SCM-Data-Loc) <> {} by A2,XBOOLE_1:17;
  then
A3: dom p /\ {IC SCM R} \/ dom p /\ SCM-Data-Loc <> {} by XBOOLE_1:23;
  per cases by A3;
  suppose dom p /\ {IC SCM R} <> {};
    hence IC SCM R in dom p by Lm1;
  end;
  suppose
A4: dom p /\ SCM-Data-Loc <> {};
    Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
    then DataPart p <> {} by A4,FUNCT_1:68,RELAT_1:60;
    hence IC SCM R in dom p by A1,Th37;
  end;
end;

theorem
  for p being autonomic FinPartState of SCM R st IC SCM R in dom p holds
  IC p in dom p
proof
  let p be autonomic FinPartState of SCM R;
  assume
A1: IC SCM R in dom p;
  assume
A2: not IC p in dom p;
  set il = IC p;
  set p1 = p +* ((il .--> goto il.(SCM R,0)));
  set p2 = p +* ((il .--> goto il.(SCM R,1)));
  consider s1 being State of SCM R such that
A3: p1 c= s1 by CARD_3:97;
  consider s2 being State of SCM R such that
A4: p2 c= s2 by CARD_3:97;
  p is not autonomic
  proof
A5: dom (il .--> (goto il.(SCM R,1))) = {il} by FUNCOP_1:19;
A6: dom (il .--> (goto il.(SCM R,0))) = {il} by FUNCOP_1:19;
    take s1,s2;
    dom p misses {il} by A2,ZFMISC_1:56;
    then
A7: p c= p1 & p c= p2 by A5,A6,FUNCT_4:33;
    hence p c= s1 & p c= s2 by A3,A4,XBOOLE_1:1;
    take 1;
A8: il in dom (il .--> (goto il.(SCM R,1))) by A5,TARSKI:def 1;
A9: il in dom (il .--> (goto il.(SCM R,0))) by A6,TARSKI:def 1;
    dom p1 = dom p \/ dom ((il .--> goto il.(SCM R,0))) by FUNCT_4:def 1;
    then il in dom p1 by A9,XBOOLE_0:def 2;
    then
A10: s1.il = p1.il by A3,GRFUNC_1:8
      .= ((il .--> goto il.(SCM R,0))).il by A9,FUNCT_4:14
      .= goto il.(SCM R,0) by FUNCOP_1:87;
    dom p2 = dom p \/ dom ((il .--> goto il.(SCM R,1))) by FUNCT_4:def 1;
    then il in dom p2 by A8,XBOOLE_0:def 2;
    then
A11: s2.il = p2.il by A4,GRFUNC_1:8
      .= ((il .--> goto il.(SCM R,1))).il by A8,FUNCT_4:14
      .= goto il.(SCM R,1) by FUNCOP_1:87;
A12: (Following s1).IC SCM R = Exec (goto il.(SCM R,0),s1).IC SCM R
    by A1,A3,A7,A10,AMI_1:97,XBOOLE_1:1
      .= il.(SCM R,0) by SCMRING2:17;
A13: (Following s2).IC SCM R = Exec (goto il.(SCM R,1),s2).IC SCM R
    by A1,A4,A7,A11,AMI_1:97,XBOOLE_1:1
      .= il.(SCM R,1) by SCMRING2:17;
    assume
A14: Computation(s1,1)|dom p = Computation(s2,1)|dom p;
A15: (Following(s1))|dom p
    = (Following (Computation(s1,0)))|dom p by AMI_1:13
      .= Computation(s1,0+1)|dom p by AMI_1:14
      .= (Following (Computation(s2,0)))|dom p by A14,AMI_1:14
      .= (Following(s2))|dom p by AMI_1:13;
    il.(SCM R,0) = ((Following(s1))|dom p).IC SCM R by A1,A12,FUNCT_1:72
      .= il.(SCM R,1) by A1,A13,A15,FUNCT_1:72;
    hence contradiction by AMISTD_1:25;
  end;
  hence contradiction;
end;

theorem Th40:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R st p c= s
  holds IC Computation(s,n) in dom ProgramPart(p)
proof
  assume
A1: R is non trivial;
  let p be autonomic non programmed FinPartState of SCM R such that
A2: p c= s;
  set Csi = Computation(s,n);
  set loc = IC Csi;
  consider ll being natural number such that
A3: loc = il.(SCM R,ll) by AMISTD_1:26;
  set loc1 = il.(SCM R,ll+1);
A4: loc <> loc1
  proof
    assume loc = loc1;
    then ll + 0 = ll + 1 by A3,AMISTD_1:25;
    hence contradiction;
  end;
  assume
A5: not IC Computation(s,n) in dom ProgramPart(p);
A6: loc in NAT by AMI_1:def 4;
  loc in dom ProgramPart p iff loc in dom p /\ NAT by FUNCT_1:68;
  then
A7: not loc in dom p by A5,A6,XBOOLE_0:def 3;
  set p1 = p +* (loc .--> goto loc);
  set p2 = p +* (loc .--> goto loc1);
A8: dom p1 = dom p \/ dom (loc .--> goto loc) &
  dom p2 = dom p \/ dom (loc .--> goto loc1) by FUNCT_4:def 1;
A9: dom (loc .--> goto loc) = {loc} &
  dom (loc .--> goto loc1) = {loc} by FUNCOP_1:19;
  then
A10: loc in dom (loc .--> goto loc) &
  loc in dom (loc .--> goto loc1) by TARSKI:def 1;
  then
A11: loc in dom p1 & loc in dom p2 by A8,XBOOLE_0:def 2;
  consider s1 being State of SCM R such that
A12: p1 c= s1 by CARD_3:97;
  consider s2 being State of SCM R such that
A13: p2 c= s2 by CARD_3:97;
  set Cs1i = Computation(s1,n);
  set Cs2i = Computation(s2,n);
  p is not autonomic
  proof
    take s1, s2;
    dom s1 = the carrier of SCM R & dom s2 = the carrier of SCM R by AMI_1:79;
    then
A14: dom p c= dom s1 & dom p c= dom s2 by AMI_1:80;
    now
      let x be set;
      assume
A15:  x in dom p;
A16:  dom p misses dom (loc .--> goto loc) by A7,A9,ZFMISC_1:56;
      x in dom p1 by A8,A15,XBOOLE_0:def 2;
      then p.x = p1.x & p1.x = s1.x by A12,A15,A16,FUNCT_4:17,GRFUNC_1:8;
      hence p.x = s1.x;
    end;
    hence
A17: p c= s1 by A14,GRFUNC_1:8;
    now
      let x be set;
      assume
A18:  x in dom p;
A19:  dom p misses dom (loc .--> goto loc1) by A7,A9,ZFMISC_1:56;
      x in dom p2 by A8,A18,XBOOLE_0:def 2;
      then p.x = p2.x & p2.x = s2.x by A13,A18,A19,FUNCT_4:17,GRFUNC_1:8;
      hence p.x = s2.x;
    end;
    hence
A20: p c= s2 by A14,GRFUNC_1:8;
    (loc .--> goto loc).loc = goto loc &
    (loc .--> goto loc1).loc = goto loc1 by FUNCOP_1:87;
    then p1.loc = goto loc & p2.loc = goto loc1 by A10,FUNCT_4:14;
    then
A21: s1.loc = goto loc & s2.loc = goto loc1 by A11,A12,A13,GRFUNC_1:8;
    take k = n+1;
    set Cs1k = Computation(s1,k);
    set Cs2k = Computation(s2,k);
A22: Cs1k = Following Cs1i by AMI_1:14
      .= Exec (CurInstr Cs1i, Cs1i);
A23: Cs2k = Following Cs2i by AMI_1:14
      .= Exec (CurInstr Cs2i, Cs2i);
A24: Cs1i.loc = goto loc & Cs2i.loc = goto loc1 by A21,AMI_1:54;
A25: (Cs1i|dom p) = (Csi|dom p) by A2,A17,AMI_1:def 25;
A26: Cs1i.IC SCM R = (Cs1i|dom p).IC SCM R &
    Csi.IC SCM R = (Csi|dom p).IC SCM R by A1,Th38,FUNCT_1:72;
    (Cs1i|dom p) = (Cs2i|dom p) by A17,A20,AMI_1:def 25;
    then Cs1i.IC SCM R = loc & Cs2i.IC SCM R = loc
    by A1,A25,A26,Th38,FUNCT_1:72;
    then
A27: Cs1k.IC SCM R = loc & Cs2k.IC SCM R = loc1 by A22,A23,A24, SCMRING2:17;
    (Cs1k|dom p).IC SCM R = Cs1k.IC SCM R &
    (Cs2k|dom p).IC SCM R = Cs2k.IC SCM R by A1,Th38,FUNCT_1:72;
    hence Cs1k|dom p <> Cs2k|dom p by A4,A27;
  end;
  hence contradiction;
end;

theorem Th41:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
  st p c= s1 & p c= s2 holds IC Computation(s1,n) = IC Computation(s2,n) &
  CurInstr (Computation(s1,n)) = CurInstr (Computation(s2,n))
proof
  assume
A1: R is non trivial;
  let p be autonomic non programmed FinPartState of SCM R such that
A2: p c= s1 & p c= s2;
  set Cs1i = Computation(s1,n);
  set Cs2i = Computation(s2,n); thus
A3: IC Cs1i = IC Cs2i
  proof
    assume
A4: IC Cs1i <> IC Cs2i;
    (Cs1i|dom p).IC SCM R = Cs1i.IC SCM R &
    (Cs2i|dom p).IC SCM R = Cs2i.IC SCM R by A1,Th38,FUNCT_1:72;
    hence contradiction by A2,A4,AMI_1:def 25;
  end;
  assume
A5: not thesis;
A6: IC Cs1i in dom ProgramPart p & IC Cs2i in dom ProgramPart p by A1,A2,Th40;
  ProgramPart p c= p by RELAT_1:88;
  then dom ProgramPart p c= dom p by GRFUNC_1:8;
  then (Cs1i|dom p).IC Cs1i = Cs1i.IC Cs1i &
  (Cs2i|dom p).IC Cs2i = Cs2i.IC Cs2i by A6,FUNCT_1:72;
  hence contradiction by A2,A3,A5,AMI_1:def 25;
end;

theorem Th42:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
  st p c= s1 & p c= s2 & CurInstr (Computation(s1,n)) = a := b & a in dom p
  holds Computation(s1,n).b = Computation(s2,n).b
proof
  assume
A1: R is non trivial;
  let p be autonomic non programmed FinPartState of SCM R such that
A2: p c= s1 & p c= s2;
  set I = CurInstr (Computation(s1,n));
  set Cs1i = Computation(s1,n);
  set Cs2i = Computation(s2,n);
A3: I = CurInstr (Computation(s2,n)) by A1,A2,Th41;
  set Cs1i1 = Computation(s1,n+1);
  set Cs2i1 = Computation(s2,n+1);
A4: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A5: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A6: a in dom p implies (Cs1i1|dom p).a = Cs1i1.a & (Cs2i1|dom p).a = Cs2i1.a
  by FUNCT_1:72;
  assume
A7: I = a := b & a in dom p & Computation(s1,n).b <> Computation(s2,n).b;
  then Cs1i1.a = Cs1i.b & Cs2i1.a = Cs2i.b by A3,A4,A5,SCMRING2:13;
  hence contradiction by A2,A6,A7,AMI_1:def 25;
end;

theorem Th43:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
  st p c= s1 & p c= s2 &
  CurInstr (Computation(s1,n)) = AddTo(a,b) & a in dom p
  holds Computation(s1,n).a + Computation(s1,n).b
  = Computation(s2,n).a + Computation(s2,n).b
proof
  assume
A1: R is non trivial;
  let p be autonomic non programmed FinPartState of SCM R such that
A2: p c= s1 & p c= s2;
  set I = CurInstr (Computation(s1,n));
  set Cs1i = Computation(s1,n);
  set Cs2i = Computation(s2,n);
A3: I = CurInstr (Computation(s2,n)) by A1,A2,Th41;
  set Cs1i1 = Computation(s1,n+1);
  set Cs2i1 = Computation(s2,n+1);
A4: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A5: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A6: a in dom p implies (Cs1i1|dom p).a = Cs1i1.a & (Cs2i1|dom p).a = Cs2i1.a
  by FUNCT_1:72;
  assume
A7: I = AddTo(a,b) & a in dom p & Computation(s1,n).a + Computation(s1,n).b
  <> Computation(s2,n).a + Computation(s2,n).b;
  then Cs1i1.a = Cs1i.a + Cs1i.b & Cs2i1.a = Cs2i.a + Cs2i.b
  by A3,A4,A5,SCMRING2:14;
  hence contradiction by A2,A6,A7,AMI_1:def 25;
end;

theorem Th44:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
  st p c= s1 & p c= s2 &
  CurInstr (Computation(s1,n)) = SubFrom(a, b) & a in dom p
  holds Computation(s1,n).a - Computation(s1,n).b
  = Computation(s2,n).a - Computation(s2,n).b
proof
  assume
A1: R is non trivial;
  let p be autonomic non programmed FinPartState of SCM R such that
A2: p c= s1 & p c= s2;
  set I = CurInstr (Computation(s1,n));
  set Cs1i = Computation(s1,n);
  set Cs2i = Computation(s2,n);
A3: I = CurInstr (Computation(s2,n)) by A1,A2,Th41;
  set Cs1i1 = Computation(s1,n+1);
  set Cs2i1 = Computation(s2,n+1);
A4: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A5: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A6: a in dom p implies (Cs1i1|dom p).a = Cs1i1.a & (Cs2i1|dom p).a = Cs2i1.a
  by FUNCT_1:72;
  assume
A7: I = SubFrom(a,b) & a in dom p &
  Computation(s1,n).a - Computation(s1,n).b
  <> Computation(s2,n).a - Computation(s2,n).b;
  then Cs1i1.a = Cs1i.a - Cs1i.b & Cs2i1.a = Cs2i.a - Cs2i.b
  by A3,A4,A5,SCMRING2:15;
  hence contradiction by A2,A6,A7,AMI_1:def 25;
end;

theorem Th45:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
  st p c= s1 & p c= s2 &
  CurInstr (Computation(s1,n)) = MultBy(a, b) & a in dom p
  holds Computation(s1,n).a * Computation(s1,n).b
  = Computation(s2,n).a * Computation(s2,n).b
proof
  assume
A1: R is non trivial;
  let p be autonomic non programmed FinPartState of SCM R such that
A2: p c= s1 & p c= s2;
  set I = CurInstr (Computation(s1,n));
  set Cs1i = Computation(s1,n);
  set Cs2i = Computation(s2,n);
A3: I = CurInstr (Computation(s2,n)) by A1,A2,Th41;
  set Cs1i1 = Computation(s1,n+1);
  set Cs2i1 = Computation(s2,n+1);
A4: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A5: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A6: a in dom p implies (Cs1i1|dom p).a = Cs1i1.a & (Cs2i1|dom p).a = Cs2i1.a
  by FUNCT_1:72;
  assume
A7: I = MultBy(a,b) & a in dom p & Computation(s1,n).a * Computation(s1,n).b
  <> Computation(s2,n).a * Computation(s2,n).b;
  then Cs1i1.a = Cs1i.a * Cs1i.b & Cs2i1.a = Cs2i.a * Cs2i.b
  by A3,A4,A5,SCMRING2:16;
  hence contradiction by A2,A6,A7,AMI_1:def 25;
end;

theorem Th46:
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
  st p c= s1 & p c= s2 & CurInstr (Computation(s1,n)) = a=0_goto loc &
  loc <> Next (IC Computation(s1,n)) holds
  Computation(s1,n).a = 0.R iff Computation(s2,n).a = 0.R
proof
  assume
A1: R is non trivial;
  let p be autonomic non programmed FinPartState of SCM R such that
A2: p c= s1 & p c= s2;
  set I = CurInstr (Computation(s1,n));
  set Cs1i = Computation(s1,n);
  set Cs2i = Computation(s2,n);
A3: IC Cs1i = IC Cs2i by A1,A2,Th41;
A4: I = CurInstr (Computation(s2,n)) by A1,A2,Th41;
  set Cs1i1 = Computation(s1,n+1);
  set Cs2i1 = Computation(s2,n+1);
A5: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A6: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A7: (Cs1i1|dom p).IC SCM R = Cs1i1.IC SCM R &
  (Cs2i1|dom p).IC SCM R = Cs2i1.IC SCM R by A1,Th38,FUNCT_1:72;
  assume
A8: I = a=0_goto loc & loc <> Next (IC Computation(s1,n));
  hereby
    assume Computation(s1,n).a = 0.R & Computation(s2,n).a <> 0.R;
    then Cs1i1.IC SCM R = loc & Cs2i1.IC SCM R = Next IC Cs2i
    by A4,A5,A6,A8,SCMRING2:18;
    hence contradiction by A2,A3,A7,A8,AMI_1:def 25;
  end;
  assume Computation(s2,n).a = 0.R & Computation(s1,n).a <> 0.R;
  then Cs2i1.IC SCM R = loc & Cs1i1.IC SCM R = Next IC Cs1i
  by A4,A5,A6,A8,SCMRING2:18;
  hence contradiction by A2,A7,A8,AMI_1:def 25;
end;

begin :: Relocability

theorem Th58:
  for p being autonomic FinPartState of SCM R
  st p c= s1 & Relocated (p,k) c= s2 holds p c= s1 +* DataPart s2
proof
X: Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
  let p be autonomic FinPartState of SCM R such that
A1: p c= s1 & Relocated (p,k) c= s2;
  reconsider s = s1 +* DataPart s2 as State of SCM R;
  set s3 = DataPart s2;
A2: dom p c= the carrier of SCM R by AMI_1:80;
  then
A3: dom p c= {IC SCM R} \/ SCM-Data-Loc \/ NAT by Th14;
A4: dom p c= dom s by A2,AMI_1:79;
  now
    let x be set such that
A5: x in dom p;
    dom s2 = the carrier of SCM R by AMI_1:79
      .= SCM-Memory by SCMRING2:def 1;
    then
A6: SCM-Data-Loc = dom s2 /\ SCM-Data-Loc by XBOOLE_1:28;
A7: x in {IC SCM R} \/ SCM-Data-Loc or x in NAT
    by A3,A5,XBOOLE_0:def 2;
    per cases by A7,XBOOLE_0:def 2;
    suppose x in {IC SCM R};
      then
A8:   x = IC SCM R by TARSKI:def 1;
      not IC SCM R in SCM-Data-Loc
      proof
        assume not thesis;
        then IC SCM R is Data-Location of R by SCMRING2:1;
        hence contradiction by SCMRING3:3;
      end;
      then not IC SCM R in dom s3 by A6,FUNCT_1:68,X;
      then s1.x = s.x by A8,FUNCT_4:12;
      hence p.x = s.x by A1,A5,GRFUNC_1:8;
    end;
    suppose
A9:   x in SCM-Data-Loc;
      set DPp = DataPart p;
      set DPRp = DataPart Relocated (p, k);
      x in dom p /\ SCM-Data-Loc by A5,A9,XBOOLE_0:def 3;
      then
A11:  x in dom DPp by FUNCT_1:68,X;
      DPp c= p by RELAT_1:88;
      then
A12:  DPp.x = p.x by A11,GRFUNC_1:8;
      DPp = DPRp by AMISTD_2:68;
      then DPp c= Relocated (p, k) by RELAT_1:88;
      then
A13:  DPp c= s2 by A1,XBOOLE_1:1;
      then
A14:  DPp.x = s2.x by A11,GRFUNC_1:8;
A15:  dom DPp c= dom s2 by A13,GRFUNC_1:8;
A16:  s2.x = s3.x by A9,FUNCT_1:72,X;
      x in dom s2 /\ SCM-Data-Loc by A9,A11,A15,XBOOLE_0:def 3;
      then x in dom s3 by FUNCT_1:68,X;
      hence p.x = s.x by A12,A14,A16,FUNCT_4:14;
    end;
    suppose
A17:  x in NAT;
      now
        assume x in dom s3;
        then x in dom s2 /\ SCM-Data-Loc by FUNCT_1:68,X;
        then x in SCM-Data-Loc by XBOOLE_0:def 3;
        hence contradiction by A17,AMI_2:29,XBOOLE_0:3;
      end;
      then s1.x = s.x by FUNCT_4:12;
      hence p.x = s.x by A1,A5,GRFUNC_1:8;
    end;
  end;
  hence p c= s1 +* DataPart s2 by A4,GRFUNC_1:8;
end;

theorem Th59:
  R is non trivial implies for p being autonomic FinPartState of SCM R
  st IC SCM R in dom p & p c= s1 & Relocated (p,k) c= s2 &
  s = s1 +* DataPart s2
   for i being Element of NAT holds
  IC Computation(s1,i) + k = IC Computation(s2,i) &
  IncAddr(CurInstr(Computation(s1,i)), k) = CurInstr(Computation(s2,i)) &
  Computation(s1,i)|dom (DataPart p)
  = Computation(s2,i)|dom (DataPart (Relocated (p,k))) &
  DataPart Computation(s,i) = DataPart Computation(s2,i)
proof
  assume
A1: R is non trivial;
  let p be autonomic FinPartState of SCM R such that
A2: IC SCM R in dom p and
A3: p c= s1 and
A4: Relocated (p,k) c= s2 and
A5: s = s1 +* DataPart s2;
A6: IC SCM R in dom Relocated(p,k) by AMISTD_2:72;
A7: DataPart p = DataPart (Relocated (p,k)) by AMISTD_2:68;
A8: DataPart p c= p by RELAT_1:88;
A9: DataPart (Relocated(p,k)) c= Relocated(p,k) by RELAT_1:88;
A10: p is non programmed by A2,AMI_1:109;
A11: p c= s by A3,A4,A5,Th58;
  defpred P[Element of NAT] means
  IC Computation(s1,$1) + k = IC Computation(s2,$1) &
  IncAddr(CurInstr(Computation(s1,$1)), k) = CurInstr(Computation(s2,$1)) &
  Computation(s1,$1)|dom (DataPart p)
  = Computation(s2,$1)|dom (DataPart (Relocated (p,k))) &
  DataPart Computation(s,$1) = DataPart Computation(s2,$1);
A12: P[0 qua Element of NAT]
  proof
    thus IC Computation(s1,0) + k = IC s1 + k by AMI_1:13
      .= IC p + k by A2,A3,AMI_1:97
      .= IC Relocated(p,k) by AMISTD_2:73
      .= IC s2 by A4,A6,AMI_1:97
      .= IC Computation(s2,0) by AMI_1:13;
A13: IC p = IC s1 by A2,A3,AMI_1:97;
    then IC p = IC Computation(s1,0) by AMI_1:13;
    then
A14: IC p in dom ProgramPart p by A1,A3,A10,Th40;
    ProgramPart p c= p by RELAT_1:88;
    then
A15: dom ProgramPart p c= dom p by GRFUNC_1:8;
A16: p.IC p = s1.IC s1 by A3,A13,A14,A15,GRFUNC_1:8;
A17: IncAddr(CurInstr(Computation(s1,0)), k)
    = IncAddr(CurInstr(s1), k) by AMI_1:13
      .= IncAddr(s1.IC s1, k);
A18: IC SCM R in dom Relocated (p, k) by AMISTD_2:72;
A19: (IC p) + k in dom Relocated(p,k) by A14,A15,AMISTD_2:71;
    CurInstr(Computation(s2,0)) = CurInstr(s2) by AMI_1:13
      .= s2.(IC Relocated (p, k)) by A4,A18,AMI_1:97
      .= s2.((IC p) + k) by AMISTD_2:73
      .= (Relocated(p,k)).((IC p) + k) by A4,A19,GRFUNC_1:8;
    hence IncAddr(CurInstr(Computation(s1,0)), k)
    = CurInstr(Computation(s2,0)) by A14,A16,A17,AMISTD_2:76;
    thus Computation(s1,0)|dom (DataPart p)
    = s1 | dom (DataPart p) by AMI_1:13
      .= DataPart p by A3,A8,GRFUNC_1:64,XBOOLE_1:1
      .= s2 | dom (DataPart p) by A4,A7,A9,GRFUNC_1:64,XBOOLE_1:1
      .= Computation(s2,0)|dom (DataPart (Relocated (p,k)))
    by A7,AMI_1:13;
    thus DataPart Computation(s,0)
    = DataPart(s1 +* DataPart s2) by A5,AMI_1:13
      .= DataPart s2 by CARD_3:99
      .= DataPart Computation(s2,0) by AMI_1:13;
  end;
A21: for i being Element of NAT st P[i] holds P[i+1 qua Element of NAT]
  proof
    let i be Element of NAT such that
A22: IC Computation(s1,i) + k = IC Computation(s2,i) and
A23: IncAddr(CurInstr(Computation(s1,i)), k) = CurInstr(Computation(s2,i))
    and
A24: Computation(s1,i)|dom (DataPart p)
    = Computation(s2,i)|dom (DataPart (Relocated (p,k))) and
A25: DataPart Computation(s,i) = DataPart Computation(s2,i);
    set Cs1i = Computation(s1,i);
    set Cs2i = Computation(s2,i);
    set Cs3i = Computation(s,i);
    set Cs1i1 = Computation(s1,i+1);
    set Cs2i1 = Computation(s2,i+1);
    set Cs3i1 = Computation(s,i+1);
    set DPp = DataPart p;
A26: dom DataPart p = dom DataPart(Relocated (p, k)) by AMISTD_2:68;
    dom Cs1i1 = the carrier of SCM R by AMI_1:79;
    then
A27: dom Cs1i1 = {IC SCM R} \/ SCM-Data-Loc \/ NAT by Th14;
    dom Cs2i1 = the carrier of SCM R by AMI_1:79;
    then
A28: dom Cs2i1 = {IC SCM R} \/ SCM-Data-Loc \/ NAT by Th14;
    dom Cs1i = the carrier of SCM R by AMI_1:79;
    then
A29: dom Cs1i = {IC SCM R} \/ SCM-Data-Loc \/ NAT by Th14;
    dom Cs2i = the carrier of SCM R by AMI_1:79;
    then
A30: dom Cs2i = {IC SCM R} \/ SCM-Data-Loc \/ NAT by Th14;
    Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
    then dom DPp = dom p /\ SCM-Data-Loc by FUNCT_1:68;
    then
A31: dom DPp c= {IC SCM R} \/ SCM-Data-Loc by XBOOLE_1:10,17;
A32: dom (Cs1i1|dom DPp) = dom Cs1i1 /\ dom DPp by FUNCT_1:68
      .= dom DPp by A27,A31,XBOOLE_1:10,28;
A33: dom (Cs2i1|dom DataPart(Relocated(p, k)))
    = dom Cs2i1 /\ dom DPp by A26,FUNCT_1:68
      .= dom DPp by A28,A31,XBOOLE_1:10,28;
A34: dom (Cs1i|dom DPp) = dom Cs1i /\ dom DPp by FUNCT_1:68
      .= dom DPp by A29,A31,XBOOLE_1:10,28;
A35: dom (Cs2i|dom DataPart(Relocated(p, k)))
    = dom Cs2i /\ dom DPp by A26,FUNCT_1:68
      .= dom DPp by A30,A31,XBOOLE_1:10,28;
A36: dom DataPart Cs3i = SCM-Data-Loc by Th22;
A37: dom DataPart Cs2i = SCM-Data-Loc by Th22;
A38: dom DataPart Cs3i1 = SCM-Data-Loc by Th22;
A39: dom DataPart Cs2i1 = SCM-Data-Loc by Th22;
A40: dom (Cs1i1|dom DPp)c=dom (Cs2i1|dom DPp) by A32,A33,AMISTD_2:68;
A41: dom DataPart Cs3i1 c= dom DataPart Cs2i1 by A38,Th22;
A42: now
      let s be State of SCM R, d be Data-Location of R;
      d in SCM-Data-Loc by SCMRING2:1;
      hence d in dom DataPart s by Th22;
    end;
A43: now
      let d be Data-Location of R;
A44:  d in dom DataPart Cs3i & d in dom DataPart Cs3i by A42;
      hence Cs3i.d = (DataPart Cs3i).d by FUNCT_1:70
        .= Cs2i.d by A25,A44,FUNCT_1:70;
    end;
A45: now
      let x be set, d be Data-Location of R such that
A46:  d = x & d in dom DPp and
A47:  Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d;
A48:  (Cs1i|dom DPp).d = Cs1i.d & (Cs2i|dom DPp).d = Cs2i.d
      by A26,A34,A35,A46,FUNCT_1:70;
      thus (Cs1i1|dom DPp).x = Cs1i1.d by A32,A46,FUNCT_1:70
        .= (Cs2i1|dom DPp).x by A24,A26,A33,A46,A47,A48,FUNCT_1:70;
    end;
A49: now
      let x be set, d be Data-Location of R such that
A50:  d = x & d in dom DPp and
A51:  Cs1i1.d = Cs2i1.d;
      thus (Cs1i1|dom DPp).x = Cs2i1.d by A32,A50,A51,FUNCT_1:70
        .= (Cs2i1|dom DPp).x by A26,A33,A50,FUNCT_1:70;
    end;
A52: now
      let x be set;
      assume
A53:  x in dom (DataPart Cs3i1) & Cs3i1.x = Cs2i1.x;
      hence (DataPart Cs3i1).x = Cs2i1.x by FUNCT_1:70
        .= (DataPart Cs2i1).x by A38,A39,A53,FUNCT_1:70;
    end;
A54: now
      let x be set;
      assume
A55:  x in dom DataPart Cs3i1 & Cs3i1.x = Cs3i.x & Cs2i1.x = Cs2i.x;
      then (DataPart Cs3i).x = Cs3i.x & (DataPart Cs2i).x = Cs2i.x
      by A36,A37,A38,FUNCT_1:70;
      hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A25,A52,A55;
    end;
A56: now
      assume
A57:  IC Computation(s1,i+1) + k = IC Computation(s2,i+1);
      reconsider loc = IC Cs1i1 as Instruction-Location of SCM R;
A58:  loc in dom ProgramPart p by A1,A3,A10,Th40;
      ProgramPart p c= p by RELAT_1:88;
      then
A59:  dom ProgramPart p c= dom p by GRFUNC_1:8;
A60:  CurInstr(Cs1i1) = s1.loc by AMI_1:54
        .= p.loc by A3,A58,A59,GRFUNC_1:8;
      loc + k in dom Relocated(p, k) by A58,A59,AMISTD_2:71;
      then Relocated(p, k).(loc + k) = s2.(loc+k) by A4,GRFUNC_1:8
        .= Cs2i1.(loc + k) by AMI_1:54;
      hence IncAddr(CurInstr(Computation(s1,i+1)), k)
      = CurInstr(Computation(s2,i+1)) by A57,A58,A60,AMISTD_2:76;
    end;
A61: Cs1i1 = Following Cs1i by AMI_1:14
      .= Exec (CurInstr Cs1i, Cs1i);
A62: Cs2i1 = Following Cs2i by AMI_1:14
      .= Exec (CurInstr Cs2i, Cs2i);
A63: Cs3i1 = Following Cs3i by AMI_1:14
      .= Exec (CurInstr Cs1i, Cs3i) by A1,A3,A10,A11,Th41;
    consider j being natural number such that
A64: IC Cs1i = il.(SCM R,j) by AMISTD_1:26;
A65: Next (IC Cs1i + k) = Next (il.(SCM R,j + k)) by A64,AMISTD_1:def 13
      .= il.(SCM R,j+k+1) by SCMRING3:67
      .= il.(SCM R,j+1+k)
      .= il.(SCM R,j+1) + k by AMISTD_1:def 13
      .= (Next IC Cs1i) + k by A64,SCMRING3:67;
    set I = CurInstr(Cs1i);
    per cases by NAT_1:32,SCMRING3:71;
    suppose InsCode I = 0;
      then
A66:  I = halt SCM R by SCMRING3:16;
      then
A67:  CurInstr(Cs2i) = halt SCM R by A23,AMISTD_2:29;
      thus IC Computation(s1,i+1) + k = IC Cs1i + k by A61,A66,AMI_1:def 8
        .= IC Computation(s2,i+1) by A22,A62,A67,AMI_1:def 8;
      hence IncAddr(CurInstr(Computation(s1,i+1)), k)
      = CurInstr(Computation(s2,i+1)) by A56;
A68:  Cs2i1 = Cs2i & Cs1i1 = Cs1i by A61,A62,A66,A67,AMI_1:def 8;
      hence Computation(s1,i+1)|dom (DataPart p)
      = Computation(s2,i+1)|dom (DataPart (Relocated (p,k))) by A24;
      thus DataPart Cs3i1 = DataPart Cs2i1
      by A25,A63,A66,A68,AMI_1:def 8;
    end;
    suppose InsCode I = 1;
      then consider da, db being Data-Location of R such that
A69:  I = da := db by SCMRING3:17;
A70:  IncAddr(I, k) = da := db by A69,AMISTD_2:29;
A71:  Exec(I, Cs1i).IC SCM R = Next IC Cs1i by A69,SCMRING2:13;
A72:  Cs3i.db = Cs2i.db by A43; thus
      IC Computation(s1,i+1) + k
      = IC Computation(s2,i+1) by A22,A23,A61,A62,A65,A70,A71,SCMRING2:13;
      thus IncAddr(CurInstr(Computation(s1,i+1)), k)
      = CurInstr(Computation(s2,i+1)) by A22,A23,A56,A61,A62,A65,A70,A71,
      SCMRING2:13;
      now
        let x be set;
        assume
A73:    x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by Th26;
        then reconsider d = x as Data-Location of R by A32,A73,SCMRING2:1;
        DPp c= p by RELAT_1:88;
        then
A74:    dom DPp c= dom p by GRFUNC_1:8;
        per cases;
        suppose
A75:      da = d;
          then
A76:      Cs1i1.d = Cs1i.db by A61,A69,SCMRING2:13;
          Cs2i1.d = Cs2i.db by A23,A62,A70,A75,SCMRING2:13;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x
          by A1,A3,A10,A11,A32,A49,A69,A72,A73,A74,A75,A76,Th42;
        end;
        suppose da <> d;

then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A23,A61,A62,A69,A70,SCMRING2:13;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A32,A45,A73;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A40,GRFUNC_1:8;
      hence Computation(s1,i+1)|dom (DataPart p)
      = Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
      by A26,A32,A33,GRFUNC_1:9;
      now
        let x be set;
        assume
A77:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A38,SCMRING2:1;
        per cases;
        suppose da = d;

then Cs2i1.d = Cs2i.db & Cs3i1.d=Cs3i.db by A23,A62,A63,A69,A70,SCMRING2:13;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A43,A52,A77;
        end;
        suppose
A78:      da <> d;
          then
A79:      Cs3i1.d = Cs3i.d by A63,A69,SCMRING2:13;
          Cs2i1.d = Cs2i.d by A23,A62,A70,A78,SCMRING2:13;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A54,A77,A79;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A41,
      GRFUNC_1:8;
      hence DataPart Cs3i1 = DataPart Computation(s2,i+1)
      by A38,A39,GRFUNC_1:9;
    end;
    suppose InsCode I = 2;
      then consider da, db being Data-Location of R such that
A80:  I = AddTo(da, db) by SCMRING3:18;
A81:  IncAddr(I, k) = AddTo(da, db) by A80,AMISTD_2:29;
A82:  Exec(I, Cs1i).IC SCM R = Next IC Cs1i by A80,SCMRING2:14;
A83:  Cs3i.da = Cs2i.da by A43;
A84:  Cs3i.db = Cs2i.db by A43; thus
      IC Computation(s1,i+1) + k
      = IC Computation(s2,i+1) by A22,A23,A61,A62,A65,A81,A82,SCMRING2:14;
      thus IncAddr(CurInstr(Computation(s1,i+1)), k)
      = CurInstr(Computation(s2,i+1)) by A22,A23,A56,A61,A62,A65,A81,A82,
      SCMRING2:14;
      now
        let x be set such that
A85:    x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by Th26;
        then reconsider d = x as Data-Location of R by A32,A85,SCMRING2:1;
        DPp c= p by RELAT_1:88;
        then
A86:    dom DPp c= dom p by GRFUNC_1:8;
        per cases;
        suppose
A87:      da = d;
          then
A88:      Cs1i1.d = Cs1i.da + Cs1i.db by A61,A80,SCMRING2:14;
          Cs2i1.d = Cs2i.da + Cs2i.db by A23,A62,A81,A87,SCMRING2:14;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x
          by A1,A3,A10,A11,A32,A49,A80,A83,A84,A85,A86,A87,A88,Th43;
        end;
        suppose da <> d;

then Cs1i1.d=Cs1i.d & Cs2i1.d = Cs2i.d by A23,A61,A62,A80,A81,SCMRING2:14;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A32,A45,A85;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A40,GRFUNC_1:8;
      hence Computation(s1,i+1)|dom (DataPart p)
      = Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
      by A26,A32,A33,GRFUNC_1:9;
      now
        let x be set;
        assume
A89:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A38,SCMRING2:1;
        per cases;
        suppose
A90:      da = d;
          then
A91:      Cs2i1.d = Cs2i.da + Cs2i.db by A23,A62,A81,SCMRING2:14;
          Cs3i1.d = Cs3i.da + Cs3i.db by A63,A80,A90,SCMRING2:14;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x
          by A52,A83,A84,A89,A91;
        end;
        suppose
A92:      da <> d;
          then
A93:      Cs3i1.d = Cs3i.d by A63,A80,SCMRING2:14;
          Cs2i1.d = Cs2i.d by A23,A62,A81,A92,SCMRING2:14;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A54,A89,A93;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A41,
      GRFUNC_1:8;
      hence DataPart Cs3i1 = DataPart Computation(s2,i+1)
      by A38,A39,GRFUNC_1:9;
    end;
    suppose InsCode I = 3;
      then consider da, db being Data-Location of R such that
A94:  I = SubFrom(da, db) by SCMRING3:19;
A95:  IncAddr(I, k) = SubFrom(da, db) by A94,AMISTD_2:29;
A96:  Exec(I, Cs1i).IC SCM R = Next IC Cs1i by A94,SCMRING2:15;
A97:  Cs3i.da = Cs2i.da by A43;
A98:  Cs3i.db = Cs2i.db by A43; thus
      IC Computation(s1,i+1) + k
      = IC Computation(s2,i+1) by A22,A23,A61,A62,A65,A95,A96,SCMRING2:15;
      thus IncAddr(CurInstr(Computation(s1,i+1)), k)
      = CurInstr(Computation(s2,i+1)) by A22,A23,A56,A61,A62,A65,A95,A96,
      SCMRING2:15;
      now
        let x be set such that
A99:    x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by Th26;
        then reconsider d = x as Data-Location of R by A32,A99,SCMRING2:1;
        DPp c= p by RELAT_1:88;
        then
A100:   dom DPp c= dom p by GRFUNC_1:8;
        per cases;
        suppose
A101:     da = d;
          then
A102:     Cs1i1.d = Cs1i.da - Cs1i.db by A61,A94,SCMRING2:15;
          Cs2i1.d = Cs2i.da - Cs2i.db by A23,A62,A95,A101,SCMRING2:15;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x
          by A1,A3,A10,A11,A32,A49,A94,A97,A98,A99,A100,A101,A102,Th44;
        end;
        suppose da <> d;
          then Cs1i1.d = Cs1i.d &
          Cs2i1.d = Cs2i.d by A23,A61,A62,A94,A95,SCMRING2:15;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A32,A45,A99;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A40,GRFUNC_1:8;
      hence Computation(s1,i+1)|dom (DataPart p)
      = Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
      by A26,A32,A33,GRFUNC_1:9;
      now
        let x be set;
        assume
A103:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A38,SCMRING2:1;
        per cases;
        suppose
A104:     da = d;
          then
A105:     Cs2i1.d = Cs2i.da - Cs2i.db by A23,A62,A95,SCMRING2:15;
          Cs3i1.d = Cs3i.da - Cs3i.db by A63,A94,A104,SCMRING2:15;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x
          by A52,A97,A98,A103,A105;
        end;
        suppose
A106:     da <> d;
          then
A107:     Cs3i1.d = Cs3i.d by A63,A94,SCMRING2:15;
          Cs2i1.d = Cs2i.d by A23,A62,A95,A106,SCMRING2:15;

hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A54,A103,A107;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A41,
      GRFUNC_1:8;
      hence DataPart Cs3i1 = DataPart Computation(s2,i+1)
      by A38,A39,GRFUNC_1:9;
    end;
    suppose InsCode I = 4;
      then consider da, db being Data-Location of R such that
A108: I = MultBy(da, db) by SCMRING3:20;
A109: IncAddr(I, k) = MultBy(da, db) by A108,AMISTD_2:29;
A110: Exec(I, Cs1i).IC SCM R = Next IC Cs1i by A108,SCMRING2:16;
A111: Cs3i.da = Cs2i.da by A43;
A112: Cs3i.db = Cs2i.db by A43; thus
      IC Computation(s1,i+1) + k
      = IC Computation(s2,i+1) by A22,A23,A61,A62,A65,A109,A110,SCMRING2:16;
      thus IncAddr(CurInstr(Computation(s1,i+1)), k)
      = CurInstr(Computation(s2,i+1)) by A22,A23,A56,A61,A62,A65,A109,A110
      ,SCMRING2:16;
      now
        let x be set such that
A113:   x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by Th26;
        then reconsider d = x as Data-Location of R by A32,A113,SCMRING2:1;
        DPp c= p by RELAT_1:88;
        then
A114:   dom DPp c= dom p by GRFUNC_1:8;
        per cases;
        suppose
A115:     da = d;
          then
A116:     Cs1i1.d = Cs1i.da * Cs1i.db by A61,A108,SCMRING2:16;
          Cs2i1.d = Cs2i.da * Cs2i.db by A23,A62,A109,A115,SCMRING2:16;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x
          by A1,A3,A10,A11,A32,A49,A108,A111,A112,A113,A114,A115,A116,Th45;
        end;
        suppose da <> d;
          then Cs1i1.d = Cs1i.d &
          Cs2i1.d = Cs2i.d by A23,A61,A62,A108,A109,SCMRING2:16;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A32,A45,A113;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A40,GRFUNC_1:8;
      hence Computation(s1,i+1)|dom (DataPart p)
      = Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
      by A26,A32,A33,GRFUNC_1:9;
      now
        let x be set;
        assume
A117:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A38,SCMRING2:1;
        per cases;
        suppose
A118:     da = d;
          then
A119:     Cs2i1.d = Cs2i.da * Cs2i.db by A23,A62,A109,SCMRING2: 16;
          Cs3i1.d = Cs3i.da * Cs3i.db by A63,A108,A118,SCMRING2:16;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x
          by A52,A111,A112,A117,A119;
        end;
        suppose
A120:     da <> d;
          then
A121:     Cs3i1.d = Cs3i.d by A63,A108,SCMRING2:16;
          Cs2i1.d = Cs2i.d by A23,A62,A109,A120,SCMRING2:16;

hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A54,A117,A121;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A41,
      GRFUNC_1:8;
      hence DataPart Cs3i1 = DataPart Computation(s2,i+1)
      by A38,A39,GRFUNC_1:9;
    end;
    suppose InsCode I = 5;
      then consider da being Data-Location of R,
      r being Element of R such that
A122: I = da:=r by SCMRING3:21;
A123: IncAddr(I, k) = da := r by A122,AMISTD_2:29;
A124: Exec(I, Cs1i).IC SCM R = Next IC Cs1i by A122,SCMRING2:19;
      hence IC Computation(s1,i+1) + k
      = IC Computation(s2,i+1) by A22,A23,A61,A62,A65,A123,SCMRING2:19;
      thus IncAddr(CurInstr(Computation(s1,i+1)), k)
      = CurInstr(Computation(s2,i+1)) by A22,A23,A56,A61,A62,A65,A123,A124
      ,SCMRING2:19;
      now
        let x be set;
        assume
A125:   x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by Th26;
        then reconsider d = x as Data-Location of R by A32,A125,SCMRING2:1;
        per cases;
        suppose
A126:     da = d;
          thus (Cs1i1|dom DPp).x = Cs1i1.d by A32,A125,FUNCT_1:72
            .= r by A61,A122,A126,SCMRING2:19
            .= Cs2i1.d by A23,A62,A123,A126,SCMRING2:19
            .= (Cs2i1|dom DPp).x by A32,A125,FUNCT_1:72;
        end;
        suppose da <> d;
          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d
          by A23,A61,A62,A122,A123,SCMRING2:19;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A32,A45,A125;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A40,GRFUNC_1:8;
      hence Computation(s1,i+1)|dom (DataPart p)
      = Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
      by A26,A32,A33,GRFUNC_1:9;
      now
        let x be set;
        assume
A127:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A38,SCMRING2:1;
        per cases;
        suppose da = d;
          then Cs2i1.d = r & Cs3i1.d = r by A23,A62,A63,A122,A123,SCMRING2:19;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A52,A127;
        end;
        suppose
A128:     da <> d;
          then
A129:     Cs3i1.d = Cs3i.d by A63,A122,SCMRING2:19;
          Cs2i1.d = Cs2i.d by A23,A62,A123,A128,SCMRING2:19;

hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A54,A127,A129;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A41,
      GRFUNC_1:8;
      hence DataPart Cs3i1 = DataPart Computation(s2,i+1)
      by A38,A39,GRFUNC_1:9;
    end;
    suppose InsCode I = 6;
      then consider loc being Instruction-Location of SCM R such that
A130: I = goto loc by SCMRING3:22;
A131: CurInstr(Cs2i) = goto (loc+k) by A23,A130,SCMRING3:69; thus
      IC Computation(s1,i+1) + k = loc + k by A61,A130,SCMRING2:17
        .= IC Computation(s2,i+1) by A62,A131,SCMRING2:17;
      hence IncAddr(CurInstr(Computation(s1,i+1)), k)
      = CurInstr(Computation(s2,i+1)) by A56;
      now
        let x be set such that
A132:   x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by Th26;
        then reconsider d = x as Data-Location of R by A32,A132,SCMRING2:1;
        Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A61,A62,A130,A131,SCMRING2:17;
        hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A32,A45,A132;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A40,GRFUNC_1:8;
      hence Computation(s1,i+1)|dom (DataPart p)
      = Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
      by A26,A32,A33,GRFUNC_1:9;
      now
        let x be set;
        assume
A133:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A38,SCMRING2:1;
        Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A62,A63,A130,A131,SCMRING2:17;
        hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A54,A133;
      end;
      then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A41,
      GRFUNC_1:8;
      hence DataPart Cs3i1 = DataPart Computation(s2,i+1)
      by A38,A39,GRFUNC_1:9;
    end;
    suppose InsCode I = 7;
      then consider da being Data-Location of R,
      loc being Instruction-Location of SCM R such that
A134: I = da=0_goto loc by SCMRING3:23;
A135: CurInstr(Cs2i) = da=0_goto (loc+k) by A23,A134,SCMRING3:70;
A136: Cs3i.da = Cs2i.da by A43;
A137: now per cases;
        case Cs1i.da = 0.R;
          hence IC Computation(s1,i+1) + k
          = loc + k by A61,A134,SCMRING2:18;
        end;
        case Cs1i.da <> 0.R;
          hence IC Computation(s1,i+1) + k
          = Next (IC Cs2i) by A22,A61,A65,A134,SCMRING2:18;
        end;
      end;
A138: now per cases;
        case Cs2i.da = 0.R;
          hence IC Computation(s2,i+1) = loc + k by A62,A135,SCMRING2:18;
        end;
        case Cs2i.da <> 0.R;
          hence IC Computation(s2,i+1)
          = Next IC Cs2i by A62,A135,SCMRING2:18;
        end;
      end;
      now per cases;
        suppose loc <> Next IC Cs1i;
          hence IC Computation(s1,i+1) + k

= IC Computation(s2,i+1) by A1,A3,A10,A11,A134,A136,A137,A138,Th46;
        end;
        suppose loc = Next IC Cs1i;
          hence IC Computation(s1,i+1) + k
          = IC Computation(s2,i+1) by A22,A65,A137,A138;
        end;
      end;
      hence IC Computation(s1,i+1) + k = IC Computation(s2,i+1) &
      IncAddr(CurInstr(Computation(s1,i+1)), k)
      = CurInstr(Computation(s2,i+1)) by A56;
      now
        let x be set such that
A139:   x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by Th26;
        then reconsider d = x as Data-Location of R by A32,A139,SCMRING2:1;
        Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A61,A62,A134,A135,SCMRING2:18;
        hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A32,A45,A139;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A40,GRFUNC_1:8;
      hence Computation(s1,i+1)|dom (DataPart p)
      = Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
      by A26,A32,A33,GRFUNC_1:9;
      now
        let x be set;
        assume
A140:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A38,SCMRING2:1;
        Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A62,A63,A134,A135,SCMRING2:18;
        hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A54,A140;
      end;
      then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A41,
      GRFUNC_1:8;
      hence DataPart Cs3i1 = DataPart Computation(s2,i+1)
      by A38,A39,GRFUNC_1:9;
    end;
  end;
  for n holds P[n] from NAT_1:sch 1(A12,A21);
  hence thesis;
end;

theorem Th60:
  R is non trivial implies
  for p being autonomic FinPartState of SCM R st IC SCM R in dom p holds
  p is halting iff Relocated (p,k) is halting
proof
  assume
A1: R is non trivial;
  let p be autonomic FinPartState of SCM R;
  assume
A2: IC SCM R in dom p;
  hereby
    assume
A3: p is halting;
    thus Relocated (p,k) is halting
    proof
      let t be State of SCM R;
      assume
A4:   Relocated(p,k) c= t;
      set s = t +* p;
A5:   p c= s by FUNCT_4:26;
      then s is halting by A3,AMI_1:def 26;
      then consider u being Element of NAT such that
A6:   CurInstr(Computation(s,u)) = halt SCM R by AMI_1:def 20;
      reconsider s3 = s +* DataPart t as State of SCM R;
      s3 = s3;
      then
A7:   CurInstr(Computation(t,u)) = IncAddr(halt SCM R, k)
      by A1,A2,A4,A5,A6,Th59
        .= halt SCM R by AMISTD_2:29;
      take u;
      thus thesis by A7;
    end;
  end;
  assume
A8: Relocated (p,k) is halting;
  let t be State of SCM R;
  assume
A9: p c= t;
  reconsider s = t +* Relocated(p, k) as State of SCM R;
A10: Relocated (p,k) c= t +* Relocated (p,k) by FUNCT_4:26;
  then s is halting by A8,AMI_1:def 26;
  then consider u being Element of NAT such that
A11: CurInstr(Computation(s,u)) = halt SCM R by AMI_1:def 20;
  reconsider s3 = t +* DataPart s as State of SCM R;
  s3 = s3;
  then
A12: IncAddr(CurInstr(Computation(t,u)), k) = halt SCM R
  by A1,A2,A9,A10,A11,Th59;
  take u;
  thus CurInstr(Computation(t,u)) = halt SCM R by A12,AMISTD_2:35;
end;

theorem
  R is non trivial implies
  for p being autonomic FinPartState of SCM R st IC SCM R in dom p & p c= s
  for i being Element of NAT holds Computation(s+*Relocated(p,k),i)
  = Computation(s,i) +* Start-At (IC Computation(s,i) + k)
  +* ProgramPart (Relocated (p,k))
proof
  assume
A1: R is non trivial;
  let p being autonomic FinPartState of SCM R such that
A2: IC SCM R in dom p and
A3: p c= s;
A4: dom DataPart p /\ {IC SCM R} = {} by Lm1,AMI_1:100;
A5: dom DataPart p misses dom (Start-At ((IC p) + k)
  +* ProgramPart (Relocated (p,k)))
  proof
    NAT misses dom DataPart p by Th26,AMI_2:29,XBOOLE_1:63;
    then dom DataPart p misses dom (ProgramPart (Relocated (p,k)))
    by RELAT_1:87,XBOOLE_1:63;
    then dom DataPart p /\ dom (ProgramPart (Relocated (p,k))) = {}
    by XBOOLE_0:def 7;
    then dom DataPart p /\ dom (Start-At ((IC p) + k))
    \/ dom DataPart p /\ dom (ProgramPart (Relocated (p,k))) = {}
    by A4,FUNCOP_1:19;
    then dom DataPart p /\ (dom (Start-At ((IC p) + k))
    \/ dom (ProgramPart (Relocated (p,k)))) = {} by XBOOLE_1:23;
    hence dom DataPart p /\ dom (Start-At ((IC p) + k)
    +* ProgramPart (Relocated (p,k))) = {} by FUNCT_4:def 1;
  end;
A6: IC p = p.IC SCM R by A2,AMI_1:def 43
    .= IC s by A2,A3,GRFUNC_1:8;
  DataPart p c= p by RELAT_1:88;
  then
A7: DataPart p c= s by A3,XBOOLE_1:1;
A8: Computation(s,0) = s by AMI_1:13;
  defpred P[Element of NAT] means Computation(s+*Relocated(p,k),$1)
  = Computation(s,$1) +* Start-At (IC Computation(s,$1) + k)
  +* ProgramPart (Relocated (p,k));
  Computation(s+*Relocated(p,k),0) = s +* (Start-At ((IC p)+k) +*
  IncAddr(Shift([ProgramPart p],k),k)+*DataPart p) by AMI_1:13
    .= s +* ((Start-At ((IC p) + k) +*
  ProgramPart (Relocated (p,k))) +* DataPart p) by AMISTD_2:69
    .= s +* (DataPart p +* (Start-At ((IC p) + k) +*
  ProgramPart (Relocated (p,k)))) by A5,FUNCT_4:36
    .= s +* DataPart p +* (Start-At ((IC p) + k) +*
  ProgramPart (Relocated (p,k))) by FUNCT_4:15
    .= s +* DataPart p +* Start-At ((IC p) + k) +*
  ProgramPart (Relocated (p,k)) by FUNCT_4:15
    .= Computation(s,0) +* Start-At (IC Computation(s,0) + k)
  +* ProgramPart (Relocated (p,k)) by A6,A7,A8,FUNCT_4:79;
  then
A9: P[0 qua Element of NAT];
A10: for i being Element of NAT st P[i] holds P[i+1 qua Element of NAT]
  proof
    let i be Element of NAT such that
A11: Computation(s+*Relocated(p,k),i)
    = Computation(s,i) +* Start-At (IC Computation(s,i) + k)
    +* ProgramPart (Relocated (p,k));
A12: Computation(s,i+1) = Following(Computation(s,i)) by AMI_1:14;
    dom (Start-At (IC Computation(s,i) + k)) = {IC SCM R} by FUNCOP_1:19;
    then
A13: IC SCM R in dom (Start-At (IC Computation(s,i) + k)) by TARSKI :def 1;
    not IC SCM R in dom ProgramPart(Relocated (p,k)) by AMI_1:101;
    then
A14: IC (Computation(s,i) +* Start-At (IC Computation(s,i) + k)
    +* [ProgramPart Relocated (p,k)]) = (Computation(s,i)
    +* Start-At (IC Computation(s,i) + k)).IC SCM R by FUNCT_4:12
      .= (Start-At (IC Computation(s,i) + k)).IC SCM R by A13,FUNCT_4:14
      .= IC Computation(s,i) + k by FUNCOP_1:87;
    p is not programmed by A2,AMI_1:109;
    then
A15: IC Computation(s,i) in dom ProgramPart(p) by A1,A3,Th40;
    then
A16: IC Computation(s,i) in dom IncAddr([ProgramPart p],k)
    by AMISTD_2:def 15;
A17: [ProgramPart p] c= Computation(s,i) by A3,AMI_1:99;
    reconsider ii = IC Computation(s,i) as Element of NAT
     by ORDINAL1:def 13;
A18: pi([ProgramPart p],ii) = ([ProgramPart p]).ii by A15,AMI_1:def 47
      .= (Computation(s,i)).IC Computation(s,i) by A15,A17,GRFUNC_1:8;
    ProgramPart p c= p by RELAT_1:88;
    then dom ProgramPart p c= dom p by GRFUNC_1:8;
    then (IC Computation(s,i) + k) in dom (Relocated (p,k)) by A15,AMISTD_2:71;
    then (IC Computation(s,i) + k) in dom (ProgramPart (Relocated (p,k)))
    by AMI_1:106;
    then
A19: CurInstr (Computation(s+*Relocated(p,k),i))
    = (ProgramPart (Relocated (p,k))).(IC Computation(s,i) + k)
    by A11,A14,FUNCT_4:14
      .= IncAddr(Shift([ProgramPart p],k),k).(IC Computation(s,i) + k)
    by AMISTD_2:69
      .= Shift(IncAddr([ProgramPart p],k),k).(IC Computation(s,i) + k)
    by AMISTD_2:75
      .= IncAddr([ProgramPart p],k).(IC Computation(s,i)) by A16,AMISTD_2:65
      .= IncAddr (CurInstr Computation(s,i),k) by A15,A18,AMISTD_2:74;
    thus Computation(s+*Relocated(p,k),i+1)
    = Following(Computation(s+*Relocated(p,k),i)) by AMI_1:14
      .= Exec(IncAddr(CurInstr Computation(s,i),k), Computation(s,i)
    +* Start-At (IC Computation(s,i) + k))
    +* [ProgramPart (Relocated (p,k))] by A11,A19,AMISTD_2:67
      .= Computation(s,i+1) +* Start-At (IC Computation(s,i+1) + k)
    +* ProgramPart (Relocated (p,k)) by A12,Th35;
  end;
  for n holds P[n] from NAT_1:sch 1 (A9,A10);
  hence thesis;
end;

theorem Th62:
  R is non trivial implies for p being autonomic FinPartState of SCM R st
  IC SCM R in dom p & Relocated(p,k) c= s holds
  for i being Element of NAT holds Computation(s,i)
  = Computation(s+*p,i) +* Start-At (IC Computation(s+*p,i) + k)
  +* s|dom ProgramPart p +* ProgramPart (Relocated (p,k))
proof
  assume
A1: R is non trivial;
  let p be autonomic FinPartState of SCM R such that
A2: IC SCM R in dom p and
A3: Relocated (p,k) c= s;
A4: dom Start-At (IC Computation(s+*p,0) + k) = {IC SCM R} by FUNCOP_1:19;
A5: dom Start-At(IC p) = {IC SCM R} by FUNCOP_1:19;
  ProgramPart (Relocated (p,k)) c= Relocated (p,k) by RELAT_1:88;
  then
A6: ProgramPart (Relocated (p,k)) c= s by A3,XBOOLE_1:1;
A7: s|dom ProgramPart p c= s by RELAT_1:88;
  dom [ProgramPart p] c= the carrier of SCM R by AMI_1:80;
  then dom ProgramPart p c= dom s by AMI_1:79;
  then
A8: dom ProgramPart p = dom (s|dom ProgramPart p) by RELAT_1:91;
A9: IC Computation(s+*p,0) = (s +* p).IC SCM R by AMI_1:13
    .= p.IC SCM R by A2,FUNCT_4:14
    .= IC p by A2,AMI_1:def 43;
  Start-At (IC p + k ) c= Relocated (p,k) by AMISTD_2:77;
  then
A10: Start-At (IC Computation(s+*p,0) + k) c= s by A3,A9,XBOOLE_1:1;
  DataPart (Relocated (p,k)) c= Relocated (p,k) by RELAT_1:88;
  then DataPart (Relocated (p,k)) c= s by A3,XBOOLE_1:1;
  then
A11: DataPart p c= s by AMISTD_2:68;
A12: dom DataPart p misses dom ProgramPart p by AMI_1:104;
A13: dom Start-At(IC p) = dom Start-At (IC Computation(s+*p,0) + k)
  by A4,FUNCOP_1:19;
A14: {IC SCM R} misses dom DataPart p by AMI_1:102;
  set IS = Start-At (IC Computation(s+*p,0) + k);
  set IP = Start-At (IC p);
  set SD = s|dom ProgramPart p;
  set PP = ProgramPart p;
  set DP = DataPart p;
  set PR = ProgramPart (Relocated (p,k));
  defpred P[Element of NAT] means Computation(s,$1)
  = Computation(s+*p,$1) +* Start-At (IC Computation(s+*p,$1) + k)
  +* s|dom ProgramPart p +* ProgramPart (Relocated (p,k));
  Computation(s,0) = s by AMI_1:13
    .= s +* PR by A6,FUNCT_4:79
    .= s +* SD +* PR by A7,FUNCT_4:79
    .= s +* PP +* SD +* PR by A8,FUNCT_4:78
    .= s +* IS +* PP +* SD +* PR by A10,FUNCT_4:79
    .= s +*(IS +* PP) +* SD +* PR by FUNCT_4:15
    .= s +*(PP +* IS) +* SD +* PR by A4,AMI_1:103,FUNCT_4:36
    .= s +* PP +* IS +* SD +* PR by FUNCT_4:15
    .= s +* DP +* PP +* IS +* SD +* PR by A11,FUNCT_4:79
    .= s +*(DP +* PP) +* IS +* SD +* PR by FUNCT_4:15
    .= s +*(PP +* DP) +* IS +* SD +* PR by A12,FUNCT_4:36
    .= s +* PP +* DP +* IS +* SD +* PR by FUNCT_4:15
    .= s +* PP +* DP +* IP +* IS +* SD +* PR by A13,FUNCT_4:78
    .= s +*(PP +* DP) +* IP +* IS +* SD +* PR by FUNCT_4:15
    .= s +*(PP +* DP +* IP) +* IS +* SD +* PR by FUNCT_4:15
    .= s +*(PP +*(DP +* IP))+* IS +* SD +* PR by FUNCT_4:15
    .= s +*(PP +*(IP +* DP))+* IS +* SD +* PR by A5,A14,FUNCT_4:36
    .= s +*(PP +* IP +* DP) +* IS +* SD +* PR by FUNCT_4:15
    .= s +*(IP +* PP +* DP) +* IS +* SD +* PR by A5,AMI_1:103,FUNCT_4:36
    .= s +* p +* IS +* SD +* PR by A2,AMI_1:108
    .= Computation(s+*p,0) +* Start-At (IC Computation(s+*p,0) + k)
  +* s|dom ProgramPart p +* ProgramPart (Relocated (p,k)) by AMI_1:13;
  then
A15: P[0 qua Element of NAT];
A16: for i being Element of NAT st P[i] holds P[i+1 qua Element of NAT]
  proof
    let i be Element of NAT such that
A17: Computation(s,i)
    =  Computation(s+*p,i) +* Start-At (IC  Computation(s+*p,i) + k)
    +* s|dom ProgramPart p+* ProgramPart (Relocated (p,k));
    reconsider sdom = s|dom ProgramPart p
    as Element of sproduct the Object-Kind of SCM R;
    dom [ProgramPart p] c= the carrier of SCM R by AMI_1:80;
    then dom ProgramPart p c= dom s by AMI_1:79;
    then
A18: dom ProgramPart p = dom (s|dom ProgramPart p) by RELAT_1:91;
    then reconsider sdom as FinPartState of SCM R by FINSET_1:29;
    dom (s|dom ProgramPart p) c= NAT by A18,RELAT_1:87;
    then reconsider sdom as programmed FinPartState of SCM R by AMI_1:def 40;
A19:  Computation(s+*p,i+1) = Following( Computation(s+*p,i))
    by AMI_1:14;
    dom (Start-At (IC  Computation(s+*p,i) + k)) = {IC SCM R}
    by FUNCOP_1:19;
    then
A20: IC SCM R in dom (Start-At (IC  Computation(s+*p,i) + k))
    by TARSKI:def 1;
A21: not IC SCM R in dom ProgramPart(Relocated (p,k)) by AMI_1:101;
A22: dom sdom = dom s /\ dom ProgramPart p by FUNCT_1:68;
    not IC SCM R in dom ProgramPart p by AMI_1:101;
    then
A23: not IC SCM R in dom sdom by A22,XBOOLE_0:def 3;
A24: IC ( Computation(s+*p,i)
    +* Start-At (IC  Computation(s+*p,i) + k) +* sdom
    +* [ProgramPart Relocated (p,k)]) = ( Computation(s+*p,i)
    +* Start-At (IC  Computation(s+*p,i) + k)
    +* sdom).IC SCM R by A21,FUNCT_4:12
      .= ( Computation(s+*p,i)
    +* Start-At (IC  Computation(s+*p,i) + k)).IC SCM R by A23,FUNCT_4:12
      .= (Start-At (IC  Computation(s+*p,i) + k)).IC SCM R
    by A20,FUNCT_4:14
      .= IC  Computation(s+*p,i) + k by FUNCOP_1:87;
    p is not programmed by A2,AMI_1:109;
    then
A25: IC  Computation(s+*p,i) in dom [ProgramPart p] by A1,Th40, FUNCT_4:26;
    then
A26: IC  Computation(s+*p,i) in dom IncAddr([ProgramPart p],k)
    by AMISTD_2:def 15;
A27: [ProgramPart p] c=  Computation(s+*p,i) by AMI_1:99,FUNCT_4:26;
    reconsider ii = IC  Computation(s+*p,i) as Element of NAT
      by ORDINAL1:def 13;
A28: pi([ProgramPart p],ii)
    = ([ProgramPart p]).IC  Computation(s+*p,i) by A25,AMI_1:def 47
      .= ( Computation(s+*p,i)).IC  Computation(s+*p,i)
    by A25,A27,GRFUNC_1:8;
    ProgramPart p c= p by RELAT_1:88;
    then dom ProgramPart p c= dom p by GRFUNC_1:8;
    then (IC  Computation(s+*p,i) + k) in dom (Relocated (p,k))
    by A25,AMISTD_2:71;
    then (IC  Computation(s+*p,i) + k) in
    dom (ProgramPart (Relocated (p,k))) by AMI_1:106;
    then
A29: CurInstr Computation(s,i)
    = (ProgramPart (Relocated (p,k))).(IC  Computation(s+*p,i) + k)
    by A17,A24,FUNCT_4:14
      .= IncAddr(Shift([ProgramPart p],k),k).(IC  Computation(s+*p,i) + k)
    by AMISTD_2:69
      .= Shift(IncAddr([ProgramPart p],k),k).(IC  Computation(s+*p,i) + k)
    by AMISTD_2:75
      .= IncAddr([ProgramPart p],k).(IC  Computation(s+*p,i))
       by A26,AMISTD_2:65
      .= IncAddr(CurInstr ( Computation(s+*p,i)),k) by A25,A28,AMISTD_2:74;
    thus Computation(s,i+1) = Following(Computation(s,i)) by AMI_1:14
      .= Exec(IncAddr(CurInstr ( Computation(s+*p,i)),k),
    ( Computation(s+*p,i)) +* Start-At (IC ( Computation(s+*p,i)) + k)
    +* sdom ) +* [ProgramPart Relocated (p,k)] by A17,A29,AMISTD_2:67
      .= Exec(IncAddr(CurInstr ( Computation(s+*p,i)),k),
    ( Computation(s+*p,i))
    +* Start-At (IC ( Computation(s+*p,i)) + k))
    +* sdom +* ProgramPart (Relocated (p,k)) by AMISTD_2:67
      .=  Computation(s+*p,i+1)
    +* Start-At (IC  Computation(s+*p,i+1) + k)
    +* s|dom ProgramPart p +* ProgramPart (Relocated (p,k)) by A19,Th35;
  end;
  for n holds P[n] from NAT_1:sch 1 (A15,A16);
  hence thesis;
end;

theorem Th63:
  R is non trivial & IC SCM R in dom p & p c= s & Relocated(p,k) is autonomic
  implies for i being Element of NAT holds Computation(s,i)
  = Computation(s+*Relocated(p,k),i)
  +* Start-At (IC Computation(s+*Relocated(p,k),i) -' k)
  +* s|dom ProgramPart Relocated(p,k) +* ProgramPart (p)
proof
  assume that
A1: R is non trivial and
A2: IC SCM R in dom p and
A3: p c= s and
A4: Relocated (p,k) is autonomic;
  set IS = Start-At (IC Computation(s+*Relocated(p,k),0) -' k);
  set IP = Start-At((IC p)+k);
  set PR = [ProgramPart Relocated (p,k)];
  set SD = s|(dom PR);
  set PP = ProgramPart p;
  set DP = DataPart p;
A5: dom IS = {IC SCM R} by FUNCOP_1:19;
A6: dom IP = {IC SCM R} by FUNCOP_1:19;
  PP c= p by RELAT_1:88;
  then
A7: PP c= s by A3,XBOOLE_1:1;
  Start-At (IC p) c= p by A2,AMI_1:110;
  then
A8: Start-At (IC p) c= s by A3,XBOOLE_1:1;
  dom PR c= the carrier of SCM R by AMI_1:80;
  then
A9: dom PR c= dom s by AMI_1:79;
A10: IC SCM R in dom Relocated(p,k) by AMISTD_2:72;
A11: IC Computation(s+*Relocated(p,k),0)
  = (s +* Relocated(p,k)).IC SCM R by AMI_1:13
    .= Relocated(p,k).IC SCM R by A10,FUNCT_4:14
    .= IC Relocated(p,k) by A10,AMI_1:def 43;
  DP c= p by RELAT_1:88;
  then
A12: DP c= s by A3,XBOOLE_1:1;
A13: dom DP misses dom PR by AMI_1:104;
A14: dom Start-At((IC p)+k) = dom IS by A5,FUNCOP_1:19;
A15: {IC SCM R} misses dom DP by AMI_1:102;
A16: {IC SCM R} misses dom PR by AMI_1:103;
A17: dom IS misses dom (s|(dom PR))
  proof
    thus dom IS /\ dom (s|(dom PR))
    = dom IS /\ (dom s /\ dom PR) by FUNCT_1:68
      .= {IC SCM R} /\ (dom s /\ dom PR) by FUNCOP_1:19
      .= {IC SCM R} /\ dom PR /\ dom s by XBOOLE_1:16
      .= {} /\ dom s by A16,XBOOLE_0:def 7
      .= {};
  end;
A18: dom PR = dom(s|(dom PR)) by A9,RELAT_1:91;
  defpred P[Element of NAT] means Computation(s,$1)
  = Computation(s+*Relocated(p,k),$1)
  +* Start-At (IC Computation(s+*Relocated(p,k),$1) -' k)
  +* s|(dom ProgramPart Relocated(p,k)) +* ProgramPart p;
  Computation(s,0) = s by AMI_1:13
    .= s +* PP by A7,FUNCT_4:79
    .= s +* Start-At (IC p) +* PP by A8,FUNCT_4:79
    .= s +* Start-At (IC p + k -' k) +* PP by AMISTD_1:61
    .= s +* IS +* PP by A11,AMISTD_2:73
    .= s +* SD +* IS +* PP by FUNCT_4:80
    .= s +* PR +* SD +* IS +* PP by A18,FUNCT_4:78
    .= s +* PR +* (SD +* IS) +* PP by FUNCT_4:15
    .= s +* PR +* (IS +* SD) +* PP by A17,FUNCT_4:36
    .= s +* PR +* IS +* SD +* PP by FUNCT_4:15
    .= s +* DP +* PR +* IS +* SD +* PP by A12,FUNCT_4:79
    .= s +*(DP +* PR) +* IS +* SD +* PP by FUNCT_4:15
    .= s +*(PR +* DP) +* IS +* SD +* PP by A13,FUNCT_4:36
    .= s +* PR +* DP +* IS +* SD +* PP by FUNCT_4:15
    .= s +* PR +* DP +* IP +* IS +* SD +* PP by A14,FUNCT_4:78
    .= s +*(PR +* DP) +* IP +* IS +* SD +* PP by FUNCT_4:15
    .= s +*(PR +* DP +* IP) +* IS +* SD +* PP by FUNCT_4:15
    .= s +*(PR +* (DP +* IP))+* IS +* SD +* PP by FUNCT_4:15
    .= s +*(PR +* (IP +* DP))+* IS +* SD +* PP by A6,A15,FUNCT_4:36
    .= s +*(PR +* IP +* DP) +* IS +* SD +* PP by FUNCT_4:15
    .= s +*(IP +* PR +* DP) +* IS +* SD +* PP by A6,AMI_1:103,FUNCT_4:36
    .= s +* Relocated(p,k) +* IS +* SD +* PP by AMISTD_2:69
    .= Computation(s+*Relocated(p,k),0)
  +* Start-At (IC Computation(s+*Relocated(p,k),0) -' k)
  +* s|(dom ProgramPart Relocated(p,k)) +* ProgramPart p by AMI_1:13;
  then
A19: P[0 qua Element of NAT];
A20: for i being Element of NAT st P[i] holds P[i+1 qua Element of NAT]
  proof
    let i be Element of NAT such that
A21: P[i];
    reconsider sdom = s|(dom ProgramPart Relocated(p,k))
    as Element of sproduct the Object-Kind of SCM R;
    dom [ProgramPart Relocated(p,k)] c= the carrier of SCM R by AMI_1:80;
    then dom ProgramPart Relocated(p,k) c= dom s by AMI_1:79;
    then
A22: dom ProgramPart Relocated(p,k) =
    dom (s|(dom ProgramPart Relocated(p,k))) by RELAT_1:91;
    then reconsider sdom as FinPartState of SCM R by FINSET_1:29;
    dom (s|(dom ProgramPart Relocated(p,k))) c= NAT by A22,RELAT_1:87;
    then reconsider sdom as programmed FinPartState of SCM R by AMI_1:def 40;
A23: Computation(s+*Relocated(p,k),i+1)
    = Following(Computation(s+*Relocated(p,k),i)) by AMI_1:14;
    dom (Start-At (IC Computation(s+*Relocated(p,k),i) -' k)) = {IC SCM R
    } by FUNCOP_1:19;
    then
A24: IC SCM R in dom (Start-At (IC Computation(s+*Relocated(p,k),i)
    -' k)) by TARSKI:def 1;
A25: not IC SCM R in dom ProgramPart p by AMI_1:101;
A26: dom sdom = dom s /\ dom ProgramPart Relocated(p,k) by FUNCT_1:68;
    not IC SCM R in dom ProgramPart Relocated(p,k) by AMI_1:101;
    then
A27: not IC SCM R in dom sdom by A26,XBOOLE_0:def 3;
A28: IC (Computation(s+*Relocated(p,k),i)
    +* Start-At (IC Computation(s+*Relocated(p,k),i) -' k) +* sdom
    +* [ProgramPart p]) = (Computation(s+*Relocated(p,k),i)
    +* Start-At (IC Computation(s+*Relocated(p,k),i) -' k)
    +* sdom).IC SCM R by A25,FUNCT_4:12
      .= (Computation(s+*Relocated(p,k),i)
    +* Start-At (IC Computation(s+*Relocated(p,k),i) -' k)).IC SCM R
    by A27,FUNCT_4:12
      .= (Start-At (IC Computation(s+*Relocated(p,k),i) -' k)).IC SCM R
    by A24,FUNCT_4:14
      .= IC Computation(s+*Relocated(p,k),i) -' k by FUNCOP_1:87;
    IC SCM R in dom Relocated(p,k) by AMISTD_2:72;
    then Relocated(p,k) is not programmed by AMI_1:109;
    then
A29: IC Computation(s+*Relocated(p,k),i)
    in dom ProgramPart(Relocated(p,k)) by A1,A4,Th40,FUNCT_4:26;
A30: ProgramPart(Relocated(p,k)) c= Computation(s+*Relocated(p,k),i)
    by AMI_1:99,FUNCT_4:26;
    consider jk being natural number such that
A31: IC Computation(s+*Relocated(p,k),i) = il.(SCM R,jk) by AMISTD_1:26;
    il.(SCM R,jk) in { il.(SCM R,j+k) where j is Element of NAT:
    il.(SCM R,j) in dom [ProgramPart p] } by A29,A31,AMISTD_2:70;
    then consider j being Element of NAT such that
A32: il.(SCM R,jk) = il.(SCM R,j+k) & il.(SCM R,j) in dom [ProgramPart p];
A33: il.(SCM R,j+k) -' k + k = il.(SCM R,j) + k -'k + k by AMISTD_1:def 13
      .= il.(SCM R,j) + k by AMISTD_1:61
      .= il.(SCM R,j+k) by AMISTD_1:def 13;
A34: il.(SCM R,j+k) -' k = il.(SCM R,j) + k -' k by AMISTD_1:def 13
      .= il.(SCM R,j) by AMISTD_1:61;
    reconsider pp = [ProgramPart p] as programmed FinPartState of SCM R;
    dom Shift(pp, k) = { il.(SCM R,m+k) where m is Element of NAT:
    il.(SCM R,m) in dom pp} by AMISTD_2:def 16;
    then
A35: il.(SCM R,j+k) in dom Shift([ProgramPart p], k) by A32;
    reconsider ii = IC Computation(s+*Relocated(p,k),i) as Element of NAT
      by ORDINAL1:def 13;
A36: CurInstr Computation(s,i) = (ProgramPart p).
    (IC Computation(s+*Relocated(p,k),i) -' k)
    by A21,A28,A31,A32,A34,FUNCT_4:14
      .= Shift([ProgramPart p], k).
    (IC Computation(s+*Relocated(p,k),i)) by A31,A32,A33,A34,AMISTD_2:65
      .= pi(Shift([ProgramPart p], k),ii) by A31,A32,A35,AMI_1:def 47;
    IncAddr(pi(Shift([ProgramPart p], k),
    ii), k)
    = IncAddr(Shift([ProgramPart p],k),k).
    (IC Computation(s+*Relocated(p,k),i)) by A31,A32,A35,AMISTD_2:74

.= (ProgramPart Relocated(p,k)).(IC Computation(s+*Relocated(p,k),i))
    by AMISTD_2:69

.= CurInstr (Computation(s+*Relocated(p,k),i)) by A29,A30,GRFUNC_1:8;
    then
A37: Exec(CurInstr Computation(s,i), Computation(s+*Relocated(p,k),i)
    +* Start-At (IC Computation(s+*Relocated(p,k),i) -' k))
    = Following(Computation(s+*Relocated(p,k),i))

+* Start-At ((IC Following Computation(s+*Relocated(p,k),i)) -' k) by A31
    ,A32,A36,Th36;
    thus Computation(s,i+1) = Following(Computation(s,i)) by AMI_1:14
      .= Exec(CurInstr Computation(s,i),
    Computation(s+*Relocated(p,k),i)
    +* Start-At (IC Computation(s+*Relocated(p,k),i) -' k)
    +* sdom ) +* ProgramPart p by A21,AMISTD_2:67
      .= Computation(s+*Relocated(p,k),i+1)
    +* Start-At (IC Computation(s+*Relocated(p,k),i+1) -' k)
    +* s|dom ProgramPart Relocated(p,k) +* ProgramPart p
     by A23,A37,AMISTD_2:67;
  end;
  for n holds P[n] from NAT_1:sch 1 (A19,A20);
  hence thesis;
end;

theorem Th64:
  R is non trivial & IC SCM R in dom p implies
  (p is autonomic iff Relocated (p,k) is autonomic)
proof
  assume that
A1: R is non trivial and
A2: IC SCM R in dom p;
  hereby
    assume
A3: p is autonomic;
    thus Relocated (p,k) is autonomic
    proof
      let s1,s2 be State of SCM R such that
A4:   Relocated (p,k) c= s1 & Relocated (p,k) c= s2;
      let i be Element of NAT;
A5:   Computation(s1,i)
      =  Computation(s1+*p,i) +* Start-At (IC Computation(s1+*p,i) + k)
      +* s1|dom ProgramPart p +* ProgramPart (Relocated (p,k))
      by A1,A2,A3,A4,Th62;
A6:   Computation(s2,i)
      =  Computation(s2+*p,i) +* Start-At (IC Computation(s2+*p,i) + k)
      +* s2|dom ProgramPart p +* ProgramPart (Relocated (p,k))
      by A1,A2,A3,A4,Th62;
      p c= s1 +* p & p c= s2 +* p by FUNCT_4:26;
      then
A7:    Computation(s1+*p,i)|dom (p ) =  Computation(s2+*p,i) |dom (p )
      by A3,AMI_1:def 25;
A8:   dom (Start-At ((IC p)+k)) = {IC SCM R} by FUNCOP_1:19;
A9:   dom (Start-At ((IC  Computation(s1+*p,i))+k)) = {IC SCM R} by
      FUNCOP_1:19;
A10:  dom (Start-At ((IC  Computation(s2+*p,i))+k)) = {IC SCM R} by
      FUNCOP_1:19;
A11:  {IC SCM R} c= dom p by A2,ZFMISC_1:37;
A12:  Start-At (IC Computation(s1+*p,i))
      =  Computation(s1+*p,i)|{IC SCM R} by AMI_1:95
        .=  Computation(s2+*p,i)|{IC SCM R} by A7,A11,RELAT_1:188
        .= Start-At (IC Computation(s2+*p,i)) by AMI_1:95;
A13:  dom (Start-At ((IC p) + k))
      misses dom ProgramPart (Relocated (p,k)) by A8,AMI_1:103;
      dom [ProgramPart p] c= the carrier of SCM R by AMI_1:80;
      then dom ProgramPart p c= dom s1 by AMI_1:79;
      then
A14:  dom(s1|dom ProgramPart p) = dom ProgramPart p by RELAT_1:91;
      dom [ProgramPart p] c= the carrier of SCM R by AMI_1:80;
      then dom ProgramPart p c= dom s2 by AMI_1:79;
      then
A15:  dom(s2|dom ProgramPart p) = dom ProgramPart p by RELAT_1:91;
A16:  Computation(s1,i)|dom (Start-At ((IC p)+k))
      = ( Computation(s1+*p,i) +* Start-At (IC Computation(s1+*p,i) + k)
      +* s1|dom ProgramPart p) |dom (Start-At ((IC p)+k)) by A5,A13,FUNCT_4:76

.= ( Computation(s1+*p,i) +* Start-At (IC Computation(s1+*p,i) + k))
      |dom (Start-At ((IC p)+k)) by A8,A14,AMI_1:103,FUNCT_4:76
        .= Start-At (IC Computation(s1+*p,i) + k) by A8,A9,FUNCT_4:24
        .= Start-At (IC Computation(s2+*p,i) + k) by A12,AMISTD_1:63

.= ( Computation(s2+*p,i) +* Start-At (IC Computation(s2+*p,i) + k))
      |dom (Start-At ((IC p)+k)) by A8,A10,FUNCT_4:24

.= ( Computation(s2+*p,i) +* Start-At (IC Computation(s2+*p,i) + k)
      +* s2|dom ProgramPart p)
      |dom (Start-At ((IC p)+k)) by A8,A15,AMI_1:103,FUNCT_4:76
        .= Computation(s2,i)|dom (Start-At ((IC p)+k)) by A6,A13,FUNCT_4:76;
A17:  Computation(s1,i)|dom (IncAddr(Shift([ProgramPart p],k),k))
      = Computation(s1,i)|dom (ProgramPart (Relocated (p,k))) by AMISTD_2:69
        .= ProgramPart (Relocated (p,k)) by A5,FUNCT_4:24
        .= Computation(s2,i)|dom (ProgramPart (Relocated (p,k)))
      by A6,FUNCT_4:24
        .= Computation(s2,i)|dom (IncAddr(Shift([ProgramPart p],k),k))
      by AMISTD_2:69;
      DataPart p c= p by RELAT_1:88;
      then
A18:  dom DataPart p c= dom p by GRFUNC_1:8;
A19:  dom(DataPart p) misses dom(ProgramPart(Relocated (p,k)))by AMI_1:104;
A20:  dom(DataPart p) misses dom (Start-At (IC Computation(s1+*p,i) + k))
      by A9,AMI_1:102;
A21:  dom(DataPart p) misses dom (Start-At (IC Computation(s2+*p,i) + k))
      by A10,AMI_1:102;
A22:  Computation(s1,i)|dom (DataPart p)
      = ( Computation(s1+*p,i) +* Start-At (IC Computation(s1+*p,i) + k)
      +* s1|dom ProgramPart p) | dom(DataPart p) by A5,A19,FUNCT_4:76

.= ( Computation(s1+*p,i) +* Start-At (IC Computation(s1+*p,i) + k))
      | dom(DataPart p) by A14,AMI_1:104,FUNCT_4:76
        .= ( Computation(s1+*p,i)) | dom (DataPart p) by A20,FUNCT_4:76
        .= ( Computation(s2+*p,i)) | dom (DataPart p) by A7,A18,RELAT_1:188

.= ( Computation(s2+*p,i) +* Start-At (IC Computation(s2+*p,i) + k))
      | dom(DataPart p) by A21,FUNCT_4:76

.= ( Computation(s2+*p,i) +* Start-At (IC Computation(s2+*p,i) + k)
      +* s2|dom ProgramPart p) | dom(DataPart p) by A15,AMI_1:104,FUNCT_4:76
        .= Computation(s2,i)|dom (DataPart p) by A6,A19,FUNCT_4:76;
A23:  Computation(s1,i)|dom (Start-At ((IC p)+k) +*
      IncAddr(Shift([ProgramPart p],k),k))
      = Computation(s1,i)|(dom (Start-At ((IC p)+k)) \/
      dom (IncAddr(Shift([ProgramPart p],k),k))) by FUNCT_4:def 1
        .= Computation(s2,i)|dom (Start-At ((IC p)+k)) \/
      Computation(s2,i)|dom (IncAddr(Shift([ProgramPart p],k),k)) by A16,A17,
      RELAT_1:107
        .= Computation(s2,i)|(dom (Start-At ((IC p)+k)) \/
      dom (IncAddr(Shift([ProgramPart p],k),k))) by RELAT_1:107
        .= Computation(s2,i)|dom (Start-At ((IC p)+k) +*
      IncAddr(Shift([ProgramPart p],k),k)) by FUNCT_4:def 1;
      thus Computation(s1,i)|dom Relocated (p,k)
      = Computation(s1,i)|(dom (Start-At ((IC p)+k) +*
      IncAddr(Shift([ProgramPart p],k),k)) \/ dom (DataPart p))
      by FUNCT_4:def 1
        .= Computation(s2,i)|dom (Start-At ((IC p)+k) +*
      IncAddr(Shift([ProgramPart p],k),k)) \/
      Computation(s2,i)|dom (DataPart p) by A22,A23,RELAT_1:107
        .= Computation(s2,i)|(dom (Start-At ((IC p)+k) +*
      IncAddr(Shift([ProgramPart p],k),k)) \/ dom (DataPart p)) by RELAT_1:107
        .= Computation(s2,i)|dom Relocated (p,k) by FUNCT_4:def 1;
    end;
  end;
  assume
A24: Relocated (p,k) is autonomic;
  let s1,s2 be State of SCM R such that
A25: p c= s1 & p c= s2;
  let i be Element of NAT;
A26: Computation(s1,i) = Computation(s1+*Relocated(p,k),i)
  +* Start-At (IC Computation(s1+*Relocated(p,k),i) -' k)
  +* s1|dom ProgramPart Relocated(p,k) +* ProgramPart (p)
  by A1,A2,A24,A25,Th63;
A27: Computation(s2,i) = Computation(s2+*Relocated(p,k),i)
  +* Start-At (IC Computation(s2+*Relocated(p,k),i) -' k)
  +* s2|dom ProgramPart Relocated(p,k) +* ProgramPart (p)
  by A1,A2,A24,A25,Th63;
  Relocated (p,k) c= s1 +* Relocated (p,k) &
  Relocated (p,k) c= s2 +* Relocated (p,k) by FUNCT_4:26;
  then
A28: Computation(s1+*Relocated(p,k),i)|dom (Relocated (p,k))
  = Computation(s2+*Relocated(p,k),i)|dom (Relocated (p,k))
  by A24,AMI_1:def 25;
A29: dom (Start-At (IC p)) = {IC SCM R} by FUNCOP_1:19;
A30: dom (Start-At ((IC Computation(s1+*Relocated(p,k),i)) -' k))
  = {IC SCM R} by FUNCOP_1:19;
A31: dom (Start-At ((IC Computation(s2+*Relocated(p,k),i)) -' k))
  = {IC SCM R} by FUNCOP_1:19;
  IC SCM R in dom Relocated (p,k) by AMISTD_2:72;
  then
A32: {IC SCM R} c= dom Relocated (p,k) by ZFMISC_1:37;
A33: Start-At (IC Computation(s1+*Relocated(p,k),i))
  = Computation(s1+*Relocated(p,k),i)|{IC SCM R} by AMI_1:95
    .= Computation(s2+*Relocated(p,k),i)|{IC SCM R}
  by A28,A32,RELAT_1:188
    .= Start-At (IC Computation(s2+*Relocated(p,k),i)) by AMI_1:95;
A34: dom (Start-At (IC p)) misses dom (ProgramPart p) by A29,AMI_1:103;
  dom [ProgramPart Relocated(p,k)] c= the carrier of SCM R by AMI_1:80;
  then dom ProgramPart Relocated(p,k) c= dom s1 by AMI_1:79;
  then
A35: dom(s1|dom ProgramPart Relocated(p,k))
  = dom ProgramPart Relocated(p,k) by RELAT_1:91;
  dom [ProgramPart Relocated(p,k)] c= the carrier of SCM R by AMI_1:80;
  then dom ProgramPart Relocated(p,k) c= dom s2 by AMI_1:79;
  then
A36: dom(s2|dom ProgramPart Relocated(p,k))
  = dom ProgramPart Relocated(p,k) by RELAT_1:91;
A37: Computation(s1,i)|dom (Start-At (IC p))
  = (Computation(s1+*Relocated(p,k),i)
  +* Start-At (IC Computation(s1+*Relocated(p,k),i) -' k)
  +* s1|dom ProgramPart Relocated(p,k))
  |dom (Start-At (IC p)) by A26,A34,FUNCT_4:76
    .= (Computation(s1+*Relocated(p,k),i)
  +* Start-At (IC Computation(s1+*Relocated(p,k),i) -' k))
  |dom (Start-At (IC p)) by A29,A35,AMI_1:103,FUNCT_4:76
    .= Start-At (IC Computation(s1+*Relocated(p,k),i) -' k)
  by A29,A30,FUNCT_4:24
    .= Start-At (IC Computation(s2+*Relocated(p,k),i) -' k) by A33,AMISTD_1:64
    .= (Computation(s2+*Relocated(p,k),i)
  +* Start-At (IC Computation(s2+*Relocated(p,k),i) -' k))
  |dom (Start-At (IC p)) by A29,A31,FUNCT_4:24
    .= (Computation(s2+*Relocated(p,k),i)
  +* Start-At (IC Computation(s2+*Relocated(p,k),i) -' k)
  +* s2|dom ProgramPart Relocated(p,k))
  |dom (Start-At (IC p)) by A29,A36,AMI_1:103,FUNCT_4:76
    .= Computation(s2,i)|dom (Start-At (IC p)) by A27,A34,FUNCT_4:76;
A38: Computation(s1,i)|dom (ProgramPart p)
  = ProgramPart (p) by A26,FUNCT_4:24
    .= Computation(s2,i)|dom (ProgramPart p) by A27,FUNCT_4:24;
  DataPart (Relocated(p,k)) c= Relocated(p,k) by RELAT_1:88;
  then DataPart p c= Relocated(p,k) by AMISTD_2:68;
  then
A39: dom (DataPart p) c= dom (Relocated(p,k)) by GRFUNC_1:8;
A40: dom (DataPart p) misses dom (ProgramPart p) by AMI_1:104;
A41: dom(DataPart p) misses
  dom(Start-At (IC Computation(s1+*Relocated(p,k),i) -' k))
  by A30,AMI_1:102;
A42: dom(DataPart p) misses
  dom(Start-At (IC Computation(s2+*Relocated(p,k),i) -' k))
  by A31,AMI_1:102;
A43: Computation(s1,i)|dom (DataPart p)
  = (Computation(s1+*Relocated(p,k),i)
  +* Start-At (IC Computation(s1+*Relocated(p,k),i) -' k)
  +* s1|dom ProgramPart Relocated(p,k))
  | dom(DataPart p) by A26,A40,FUNCT_4:76
    .= (Computation(s1+*Relocated(p,k),i) +*
  Start-At (IC Computation(s1+*Relocated(p,k),i) -' k))
  | dom(DataPart p) by A35,AMI_1:104,FUNCT_4:76
    .= (Computation(s1+*Relocated(p,k),i)) | dom (DataPart p)
  by A41,FUNCT_4:76
    .= (Computation(s2+*Relocated(p,k),i)) | dom (DataPart p)
  by A28,A39,RELAT_1:188
    .= (Computation(s2+*Relocated(p,k),i) +*
  Start-At (IC Computation(s2+*Relocated(p,k),i) -' k))
  | dom(DataPart p) by A42,FUNCT_4:76
    .= (Computation(s2+*Relocated(p,k),i)
  +* Start-At (IC Computation(s2+*Relocated(p,k),i) -' k)
  +* s2|dom ProgramPart Relocated(p,k))
  | dom(DataPart p) by A36,AMI_1:104,FUNCT_4:76
    .= Computation(s2,i)|dom (DataPart p) by A27,A40,FUNCT_4:76;
A44: Computation(s1,i)|dom (Start-At (IC p) +* ProgramPart p)
  = Computation(s1,i)|(dom (Start-At (IC p)) \/ dom (ProgramPart p))
  by FUNCT_4:def 1
    .= Computation(s2,i)|dom (Start-At (IC p)) \/
  Computation(s2,i)|dom (ProgramPart p) by A37,A38,RELAT_1:107
    .= Computation(s2,i)|(dom (Start-At (IC p)) \/ dom (ProgramPart p))
  by RELAT_1:107
    .= Computation(s2,i)|dom (Start-At (IC p) +* ProgramPart p)
  by FUNCT_4:def 1;
  thus Computation(s1,i)|dom p
  = Computation(s1,i)|dom (Start-At (IC p) +* ProgramPart p +*
  DataPart p ) by A2,AMI_1:108
    .= Computation(s1,i)|(dom (Start-At (IC p) +* ProgramPart p) \/
  dom (DataPart p)) by FUNCT_4:def 1
    .= Computation(s2,i)|dom (Start-At (IC p) +* ProgramPart p ) \/
  Computation(s2,i)|dom (DataPart p) by A43,A44,RELAT_1:107
    .= Computation(s2,i)|(dom (Start-At (IC p) +* ProgramPart p) \/
  dom (DataPart p)) by RELAT_1:107
    .= Computation(s2,i)|dom (Start-At (IC p) +*
  ProgramPart p +* DataPart p) by FUNCT_4:def 1
    .= Computation(s2,i)|dom p by A2,AMI_1:108;
end;

theorem Th65:
  R is non trivial implies
  for p being halting autonomic FinPartState of SCM R st IC SCM R in dom p
  holds DataPart Result p = DataPart Result Relocated(p,k)
proof
X: Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
  assume
A1: R is non trivial;
  let p being halting autonomic FinPartState of SCM R such that
A2: IC SCM R in dom p;
  consider s being State of SCM R such that
A3: p c= s by CARD_3:97;
  s is halting by A3,AMI_1:def 26;
  then consider j1 being Element of NAT such that
A4: Result(s) =  Computation(s,j1) and
A5: CurInstr(Result(s)) = halt SCM R by AMI_1:def 22;
  consider t being State of SCM R such that
A6: Relocated(p,k) c= t by CARD_3:97;
  reconsider s3 = s +* DataPart t as State of SCM R;
A7: s3 = s3;
  t.(IC ( Computation(t,j1))) = CurInstr( Computation(t,j1)) by AMI_1:54
    .= IncAddr(CurInstr( Computation(s,j1)), k) by A1,A2,A3,A6,A7,Th59
    .= halt SCM R by A4,A5,AMISTD_2:29;
  then
A8: Result t =  Computation(t,j1) by AMI_1:56;
A9: Relocated(p,k) is halting & Relocated(p,k) is autonomic by A1,A2,Th60,Th64;
  thus DataPart(Result(p)) = DataPart((Result s) | dom p) by A3,AMI_1:def 28
    .= (Result s) | (dom p /\ SCM-Data-Loc) by RELAT_1:100,X
    .= (Result s) | dom DataPart p by FUNCT_1:68,X
    .= (Result t) | dom DataPart Relocated(p,k) by A1,A2,A3,A4,A6,A7,A8,Th59
    .= (Result t) | (dom Relocated(p,k) /\ SCM-Data-Loc) by FUNCT_1:68,X
    .= DataPart ((Result t) | dom Relocated(p,k)) by RELAT_1:100,X
    .= DataPart (Result(Relocated(p,k))) by A6,A9,AMI_1:def 28;
end;

theorem
  R is non trivial implies
  for F being PartFunc of FinPartSt SCM R, FinPartSt SCM R
  st IC SCM R in dom p & F is data-only holds
  p computes F iff Relocated (p,k) computes F
proof
  assume
A1: R is non trivial;
  let F be PartFunc of FinPartSt SCM R, FinPartSt SCM R such that
A2: IC SCM R in dom p and
A3: F is data-only;
  hereby
    assume
A4: p computes F;
    thus Relocated (p,k) computes F
    proof
      let x be set;
      assume
A5:   x in dom F;
      dom F c= FinPartSt SCM R by RELSET_1:12;
      then reconsider s = x as FinPartState of SCM R by A5,AMI_1:125;
      reconsider s as data-only FinPartState of SCM R by A3,A5,AMI_1:def 51;
      take s;
      thus x=s;
      consider s1 being FinPartState of SCM R such that
A6:   x = s1 & p +* s1 is pre-program of SCM R &
      F.s1 c= Result(p +* s1) by A4,A5,AMI_1:def 29;
      reconsider Fs1 = F.s1 as FinPartState of SCM R
       by A6,CARD_3:80;
A7:   Fs1 is data-only by A3,A5,A6,AMI_1:def 51;
      then
A8:   F.s1 c= DataPart(Result(p +* s1)) by A6,AMI_1:107;
A9:   Relocated(p,k) +* s = Relocated((p +* s) ,k) by A2,AMISTD_2:78;
      dom(p +* s) = dom p \/ dom s by FUNCT_4:def 1;
      then
A10:  IC SCM R in dom(p +* s) by A2,XBOOLE_0:def 2;
      hence Relocated(p,k) +* s is pre-program of SCM R by A1,A6,A9,Th60,Th64;
      DataPart(Result(p +* s1))
      = DataPart(Result(Relocated(p +* s,k))) by A1,A6,A10,Th65
        .= DataPart(Result(Relocated(p,k) +* s)) by A2,AMISTD_2:78;
      hence F.s c= Result(Relocated(p,k) +* s) by A6,A7,A8,AMI_1:107;
    end;
  end;
  assume
A11: Relocated (p,k) computes F;
  let x be set;
  assume
A12: x in dom F;
  dom F c= FinPartSt SCM R by RELSET_1:12;
  then reconsider s = x as FinPartState of SCM R by A12,AMI_1:125;
  reconsider s as data-only FinPartState of SCM R by A3,A12,AMI_1:def 51;
  take s;
  thus x=s;
  consider s1 being FinPartState of SCM R such that
A13: x = s1 & Relocated (p,k) +* s1 is pre-program of SCM R &
  F.s1 c= Result (Relocated (p,k) +* s1) by A11,A12,AMI_1:def 29;
  reconsider Fs1 = F.s1 as FinPartState of SCM R by A13,CARD_3:80;
A14: Fs1 is data-only by A3,A12,A13,AMI_1:def 51;
  then
A15: F.s1 c= DataPart(Result(Relocated(p,k) +* s1)) by A13,AMI_1:107;
A16: Relocated(p,k) +* s = Relocated((p +* s),k) by A2,AMISTD_2:78;
  dom(p +* s) = dom p \/ dom s by FUNCT_4:def 1;
  then
A17: IC SCM R in dom(p +* s) by A2,XBOOLE_0:def 2;
  then
A18: p +* s is autonomic by A1,A13,A16,Th64;
  hence p +* s is pre-program of SCM R by A1,A13,A16,A17,Th60;
A19: p +* s is halting by A1,A13,A16,A17,A18,Th60;
  DataPart(Result(Relocated(p,k) +* s1))
  = DataPart(Result(Relocated(p +* s,k))) by A2,A13,AMISTD_2:78
    .= DataPart(Result(p +* s)) by A1,A17,A18,A19,Th65;
  hence F.s c= Result(p +* s) by A13,A14,A15,AMI_1:107;
end;

