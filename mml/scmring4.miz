:: Relocability for { \bf SCM } over Ring
::  by Artur Korni{\l}owicz and Yasunari Shidama
::
:: Received February 6, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabularies ORDINAL1, SUBSET_1, NUMBERS, XBOOLE_0, SETFAM_1, SCMFSA7B,
      FUNCSDOM, AMI_3, AMI_1, FSM_1, STRUCT_0, AMI_2, FUNCT_1, AMISTD_1,
      TARSKI, RELAT_1, AMISTD_2, ARYTM_3, FUNCT_4, CIRCUIT2, CARD_1, GRAPHSP,
      ARYTM_1, SUPINF_2, FUNCOP_1, ZFMISC_1, GLIB_000, VALUED_1, MSUALG_1,
      PARTFUN1, TURING_1, SCMNORM, FINSET_1, RELOC;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, DOMAIN_1, ORDINAL1, RELAT_1,
      NUMBERS, FUNCT_1, PARTFUN1, FINSET_1,
      STRUCT_0, ALGSTR_0, FUNCSDOM, FUNCOP_1,
      XCMPLX_0, NAT_1, FUNCT_4, NAT_D, VALUED_1,
      COMPOS_1, AMI_1, AMI_2, AMI_3, SCMRING1,
      SCMRING2, AMISTD_1, SCMRING3, AMISTD_2;
 constructors XXREAL_0, REALSET2, AMI_5, AMISTD_2, SCMRING3, PRE_POLY,
      NAT_D;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, XREAL_0, NAT_1,
      CARD_3, STRUCT_0, AMI_1, AMI_3, AMI_5, SCMRING2, AMISTD_2, SCMRING3,
      FINSET_1, ORDINAL1, RELSET_1, GRFUNC_1, FUNCT_2, VALUED_1,
      COMPOS_1;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions AMI_1, FUNCOP_1, AMI_3, AMI_2, AMISTD_1, AMISTD_2, NAT_1,
      COMPOS_1;
 theorems TARSKI, NAT_1, AMI_1, SCMRING2, AMI_3, FUNCT_4, AMI_5, FUNCT_1,
      ZFMISC_1, FUNCOP_1, SCMRING1, AMI_2, STRUCT_0, XBOOLE_0, XBOOLE_1,
      RELAT_1, GRFUNC_1, SCMRING3, AMISTD_1, AMISTD_2, PBOOLE,
      PARTFUN1, ORDINAL1, VALUED_1, NAT_D, COMPOS_1;
 schemes NAT_1;

begin :: On the standard computers

reserve i, j, k for Element of NAT,
  n for Element of NAT,
  IL for non empty set,
  N for with_non-empty_elements set;

Lm1: for a,A being set st A /\ {a} <> {} holds a in A
proof
  let a,A be set;
  assume A /\ {a} <> {};
  then A meets {a} by XBOOLE_0:def 7;
  hence thesis by ZFMISC_1:56;
end;

begin :: SCM R

reserve R for good Ring,
  a, b for Data-Location of R,
  loc for
  Element of NAT,
  I for Instruction of SCM R,
  p for FinPartState
  of SCM R,
  s, s1, s2 for State of SCM R,
  q for FinPartState of SCM;

theorem Th1:
  the carrier of SCM R = {IC SCM R} \/ SCM-Data-Loc \/ NAT
proof
  IC SCM R = IC SCM by AMI_3:4,SCMRING2:9;
  hence thesis by AMI_5:23,SCMRING2:def 1;
end;

theorem
  (the Object-Kind of SCM R).loc = SCM-Instr R
proof
  reconsider i = loc as Element of NAT;
  thus (the Object-Kind of SCM R).loc = (SCM-OK R).i by SCMRING2:def 1
    .= SCM-Instr R by SCMRING1:6;
end;

theorem Th3:
  dl.(R,n) = [1,n]
proof
  thus dl.(R,n) = dl.n by SCMRING3:def 1
    .= [1,n];
end;

canceled;

theorem
  for dl being Data-Location of R ex i being Element of NAT st dl = dl.(
  R,i)
proof
  let dl be Data-Location of R;
  dl in SCM-Data-Loc by SCMRING2:1;
  then consider i being Element of NAT such that
A1: dl = [1,i] by AMI_2:32;
  take i;
  thus thesis by A1,Th3;
end;

theorem
  for i,j being Element of NAT holds i <> j implies dl.(R,i) <> dl.(R,j)
proof
  let i,j be Element of NAT;
  assume
A1: i <> j;
  dl.(R,j) = [1,j] & dl.(R,i) = [1,i] by Th3;
  hence thesis by A1,ZFMISC_1:33;
end;

theorem Th7:
  a <> loc
proof
  assume a = loc;
  then loc in (the carrier of SCM R) \ (NAT \/ {NAT}) by SCMRING2:def 2;
  then not loc in NAT \/ {NAT} by XBOOLE_0:def 5;
  hence thesis by XBOOLE_0:def 3;
end;

Lm2: now
  let R;
  thus the carrier of SCM = {IC SCM R} \/ SCM-Data-Loc \/ NAT by SCMRING2:9
    .= the carrier of SCM R by Th1;
end;

theorem
  SCM-Data-Loc c= dom s
proof
  Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
  hence thesis by COMPOS_1:49;
end;

theorem Th9:
  dom DataPart s = SCM-Data-Loc
proof
  Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
  hence thesis by COMPOS_1:50;
end;

theorem
  p = q implies DataPart p = DataPart q
proof
  assume p = q;
  hence DataPart p = q | ((the carrier of SCM) \ ({IC SCM R} \/ NAT)) by Lm2
    .= DataPart q by AMI_3:4,SCMRING2:9;
end;

canceled;

theorem
  p is data-only iff dom p c= SCM-Data-Loc
proof
  Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
  hence thesis by COMPOS_1:31;
end;

theorem Th13:
  dom DataPart p c= SCM-Data-Loc
proof
  Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
  hence thesis by RELAT_1:87;
end;

theorem
  NAT c= dom s
proof
  dom s = the carrier of SCM R & NAT c= {IC SCM R} \/ SCM-Data-Loc \/ NAT
  by PARTFUN1:def 4,XBOOLE_1:7;
  hence thesis by Th1;
end;

canceled;

theorem
  dom ProgramPart p c= NAT by RELAT_1:87;

canceled;

theorem
  IncAddr(goto(loc,R),k) = goto(loc + k,R) by SCMRING3:69;

theorem
  IncAddr(a=0_goto loc,k) = a=0_goto (loc + k) by SCMRING3:70;

theorem Th20:
  s.a = (s +* Start-At(loc,SCM R)).a
proof
  a in the carrier of SCM R;
  then a in dom s by PARTFUN1:def 4;
  then
A1: dom (Start-At(loc,SCM R)) = {IC SCM R} & a in dom s \/
dom (Start-At(loc,SCM R)) by FUNCOP_1:19,XBOOLE_0:def 3;
  a <> IC SCM R by SCMRING3:3;
  then not a in {IC SCM R} by TARSKI:def 1;
  hence thesis by A1,FUNCT_4:def 1;
end;

theorem Th21:
  IC(s1) = IC(s2) & (for a being Data-Location of R holds s1.a =
  s2.a) & (for i being Element of NAT holds s1.i = s2.i) implies
  s1 = s2
proof
  assume that
A1: IC(s1) = IC(s2) and
A2: for a being Data-Location of R holds s1.a = s2.a and
A3: for i being Element of NAT holds s1.i = s2.i;
A5: dom s1 = the carrier of SCM R by PARTFUN1:def 4;
A7: dom s2 = the carrier of SCM R by PARTFUN1:def 4;
A8: now
A9: SCM-Memory = {IC SCM R} \/ SCM-Data-Loc \/ NAT by SCMRING2:def 1;
    let x be set;
    assume x in SCM-Memory;
    then
A10: x in {IC SCM R} \/ SCM-Data-Loc or x in NAT by A9,XBOOLE_0:def 3;
    per cases by A10,XBOOLE_0:def 3;
    suppose
      x in {IC SCM R};
      then x = IC SCM R by TARSKI:def 1;
      hence s1.x = s2.x by A1;
    end;
    suppose
      x in SCM-Data-Loc;
      then x is Data-Location of R by SCMRING2:1;
      hence s1.x = s2.x by A2;
    end;
    suppose
      x in NAT;
      then reconsider l = x as Element of NAT;
      l = x;
      hence s1.x = s2.x by A3;
    end;
  end;
   SCM-Memory = dom s1 by A5,SCMRING2:def 1;
  hence thesis by A5,A7,A8,FUNCT_1:9;
end;

theorem Th22:
  Exec(IncAddr(CurInstr(ProgramPart s,s),k),s +*
  Start-At(IC s + k,SCM R))
   = Following(ProgramPart s,s) +*
   Start-At(IC Following(ProgramPart s,s) +k,SCM R)
proof
  set INS = CurInstr(ProgramPart s,s);
  consider m being natural number such that
A1: IC s = m;
  reconsider m as Element of NAT by ORDINAL1:def 13;
A3: succ IC (s +* Start-At(IC s + k,SCM R)) = succ (IC s + k)
         by FUNCT_4:121
    .= IC (Exec(INS, s) +* Start-At(succ IC s + k,SCM R))
     by FUNCT_4:121;
A4: now
    let d be Element of NAT;
    thus Exec(INS, s +* Start-At(IC s + k,SCM R)).d =
    (s +* Start-At(IC s + k,SCM R)).d
    by AMI_1:def 13
      .= s.d by COMPOS_1:20
      .= Exec(INS, s).d by AMI_1:def 13
      .= (Exec(INS, s) +* Start-At(succ IC s + k,SCM R)).d by COMPOS_1:20;
  end;
  per cases by NAT_1:32,SCMRING3:71;
  suppose
    InsCode INS = 0;
    then
A5: INS = halt SCM R by SCMRING3:16;
    then
A6: Following(ProgramPart s,s) = s by AMI_1:def 8;
    thus Exec(IncAddr(CurInstr(ProgramPart s,s),k),s +*
    Start-At(IC s + k,SCM R))
      = Following(ProgramPart s,s) +*
      Start-At(IC Following(ProgramPart s,s) +k,SCM R)
      by A6,A5,AMI_1:def 8;
  end;
  suppose
    InsCode INS = 1;
    then consider da,db being Data-Location of R such that
A7: INS = da := db by SCMRING3:17;
A8: now
      let d be Data-Location of R;
      per cases;
      suppose
A9:     da = d;
        hence
        Exec(INS, s +* Start-At(IC s + k,SCM R)).d =
        (s +* Start-At(IC s + k,SCM R)
        ).db by A7,SCMRING2:13
          .= s.db by Th20
          .= Exec(INS, s).d by A7,A9,SCMRING2:13
          .= (Exec(INS, s) +* Start-At(succ IC s + k,SCM R)).d by Th20;
      end;
      suppose
A10:    da <> d;
        hence
        Exec(INS, s +* Start-At(IC s + k,SCM R)).d =
        (s +* Start-At(IC s + k,SCM R)
        ).d by A7,SCMRING2:13
          .= s.d by Th20
          .= Exec(INS, s).d by A7,A10,SCMRING2:13
          .= (Exec(INS, s) +* Start-At(succ IC s + k,SCM R)).d by Th20;
      end;
    end;
A11: IncAddr(INS,k) = INS & IC Exec(INS, s) = succ IC s by A7,AMISTD_2:29
,SCMRING2:13;
    IC Exec(INS, s +* Start-At(IC s + k,SCM R)) = IC (Exec(INS, s) +*
     Start-At(succ IC s + k,SCM R)) by A3,A7,SCMRING2:13;
    hence thesis by A4,A11,A8,Th21;
  end;
  suppose
    InsCode INS = 2;
    then consider da,db being Data-Location of R such that
A12: INS = AddTo(da, db) by SCMRING3:18;
A13: now
      let d be Data-Location of R;
      per cases;
      suppose
A14:    da = d;
        hence
        Exec(INS, s +* Start-At(IC s + k,SCM R)).d =
        (s +* Start-At(IC s + k,SCM R)
        ).da + (s +* Start-At(IC s + k,SCM R)).db by A12,SCMRING2:14
          .= s.da + (s +* Start-At(IC s + k,SCM R)).db by Th20
          .= s.da + s.db by Th20
          .= Exec(INS, s).d by A12,A14,SCMRING2:14
          .= (Exec(INS, s) +* Start-At(succ IC s + k,SCM R)).d by Th20;
      end;
      suppose
A15:    da <> d;
        hence
        Exec(INS, s +* Start-At(IC s + k,SCM R)).d =
        (s +* Start-At(IC s + k,SCM R)
        ).d by A12,SCMRING2:14
          .= s.d by Th20
          .= Exec(INS, s).d by A12,A15,SCMRING2:14
          .= (Exec(INS, s) +* Start-At(succ IC s + k,SCM R)).d by Th20;
      end;
    end;
A16: IncAddr(INS, k) = INS & IC Exec(INS, s) = succ IC s by A12,AMISTD_2:29
,SCMRING2:14;
    IC Exec(INS, s +* Start-At(IC s + k,SCM R)) = IC (Exec(INS, s) +*
    Start-At(succ IC s + k,SCM R)) by A3,A12,SCMRING2:14;
    hence thesis by A4,A16,A13,Th21;
  end;
  suppose
    InsCode INS = 3;
    then consider da,db being Data-Location of R such that
A17: INS = SubFrom(da, db) by SCMRING3:19;
A18: now
      let d be Data-Location of R;
      per cases;
      suppose
A19:    da = d;
        hence
        Exec(INS, s +* Start-At(IC s + k,SCM R)).d =
        (s +* Start-At(IC s + k,SCM R)
        ).da - (s +* Start-At(IC s + k,SCM R)).db by A17,SCMRING2:15
          .= s.da - (s +* Start-At(IC s + k,SCM R)).db by Th20
          .= s.da - s.db by Th20
          .= Exec(INS, s).d by A17,A19,SCMRING2:15
          .= (Exec(INS, s) +* Start-At(succ IC s + k,SCM R)).d by Th20;
      end;
      suppose
A20:    da <> d;
        hence
        Exec(INS, s +* Start-At(IC s + k,SCM R)).d =
        (s +* Start-At(IC s + k,SCM R)
        ).d by A17,SCMRING2:15
          .= s.d by Th20
          .= Exec(INS, s).d by A17,A20,SCMRING2:15
          .= (Exec(INS, s) +* Start-At(succ IC s + k,SCM R)).d by Th20;
      end;
    end;
A21: IncAddr(INS, k) = INS & IC Exec(INS, s) = succ IC s by A17,AMISTD_2:29
,SCMRING2:15;
    IC Exec(INS, s +* Start-At(IC s + k,SCM R)) = IC (Exec(INS, s) +*
    Start-At(succ IC s + k,SCM R)) by A3,A17,SCMRING2:15;
    hence thesis by A4,A21,A18,Th21;
  end;
  suppose
    InsCode INS = 4;
    then consider da,db being Data-Location of R such that
A22: INS = MultBy(da, db) by SCMRING3:20;
A23: now
      let d be Data-Location of R;
      per cases;
      suppose
A24:    da = d;
        hence
        Exec(INS, s +* Start-At(IC s + k,SCM R)).d =
        (s +* Start-At(IC s + k,SCM R)
        ).da * (s +* Start-At(IC s + k,SCM R)).db by A22,SCMRING2:16
          .= s.da * (s +* Start-At(IC s + k,SCM R)).db by Th20
          .= s.da * s.db by Th20
          .= Exec(INS, s).d by A22,A24,SCMRING2:16
          .= (Exec(INS, s) +* Start-At(succ IC s + k,SCM R)).d by Th20;
      end;
      suppose
A25:    da <> d;
        hence
        Exec(INS, s +* Start-At(IC s + k,SCM R)).d =
        (s +* Start-At(IC s + k,SCM R)
        ).d by A22,SCMRING2:16
          .= s.d by Th20
          .= Exec(INS, s).d by A22,A25,SCMRING2:16
          .= (Exec(INS, s) +* Start-At(succ IC s + k,SCM R)).d by Th20;
      end;
    end;
A26: IncAddr(INS, k) = INS & IC Exec(INS, s) = succ IC s by A22,AMISTD_2:29
,SCMRING2:16;
    IC Exec(INS, s +* Start-At(IC s + k,SCM R)) = IC (Exec(INS, s) +*
    Start-At(succ IC s + k,SCM R)) by A3,A22,SCMRING2:16;
    hence thesis by A4,A26,A23,Th21;
  end;
  suppose
    InsCode INS = 5;
    then consider da being Data-Location of R, r being Element of R such that
A27: INS = da:=r by SCMRING3:21;
A28: now
      let d be Data-Location of R;
      per cases;
      suppose
A29:    da = d;
        hence Exec(INS, s +* Start-At(IC s + k,SCM R)).d = r
        by A27,SCMRING2:19
          .= Exec(INS, s).d by A27,A29,SCMRING2:19
          .= (Exec(INS, s) +* Start-At(succ IC s + k,SCM R)).d by Th20;
      end;
      suppose
A30:    da <> d;
        hence
        Exec(INS, s +* Start-At(IC s + k,SCM R)).d =
        (s +* Start-At(IC s + k,SCM R)
        ).d by A27,SCMRING2:19
          .= s.d by Th20
          .= Exec(INS, s).d by A27,A30,SCMRING2:19
          .= (Exec(INS, s) +* Start-At(succ IC s + k,SCM R)).d by Th20;
      end;
    end;
A31: IncAddr(INS,k) = INS & IC Exec(INS, s) = succ IC s by A27,AMISTD_2:29
,SCMRING2:19;
    IC Exec(INS, s +* Start-At(IC s + k,SCM R)) = IC (Exec(INS, s) +*
    Start-At(succ IC s + k,SCM R)) by A3,A27,SCMRING2:19;
    hence thesis by A4,A31,A28,Th21;
  end;
  suppose
    InsCode INS = 6;
    then consider loc being Element of NAT such that
A32: INS = goto(loc,R) by SCMRING3:22;
A33: IC Exec(INS, s) = loc by A32,SCMRING2:17;
A34: now
      let d be Element of NAT;
      thus Exec(IncAddr(INS, k), s +* Start-At(IC s + k,SCM R)).d =
      (s +* Start-At(IC s + k,SCM R)).d by AMI_1:def 13
        .= s.d by COMPOS_1:20
        .= Exec(INS, s).d by AMI_1:def 13
        .= (Exec(INS, s) +*Start-At(IC Exec(INS,s) +k,SCM R)).d
           by COMPOS_1:20;
    end;
A35: IncAddr(INS, k) = goto(loc + k,R) by A32,SCMRING3:69;
A36: now
      let d be Data-Location of R;
      thus Exec(IncAddr(INS, k), s +* Start-At(IC s + k,SCM R)).d =
      (s +* Start-At(IC s + k,SCM R)).d by A35,SCMRING2:17
        .= s.d by Th20
        .= Exec(INS, s).d by A32,SCMRING2:17
        .= (Exec(INS, s) +*Start-At(IC Exec(INS,s) +k,SCM R)).d
        by Th20;
    end;
  set s1 = Exec(IncAddr(INS, k), s +* Start-At(IC s + k,SCM R)),
      s2 = (Exec(INS, s) +*Start-At(IC Exec(INS,s) +k,SCM R));
    IC Exec(IncAddr(INS, k), s +* Start-At(IC s + k,SCM R))
    = loc + k
    by A35,SCMRING2:17
      .= IC (Exec(INS, s) +*Start-At(IC Exec(INS,s) +k,SCM R))
      by A33,FUNCT_4:121;
    hence thesis by A36,A34,Th21;
  end;
  suppose
    InsCode INS = 7;
    then consider
    da being Data-Location of R, loc being Element of NAT
    such that
A37: INS = da=0_goto loc by SCMRING3:23;
A38: IncAddr(INS, k) = da=0_goto (loc + k) by A37,SCMRING3:70;
    now
      per cases;
      suppose
A39:    s.da = 0.R;
A40:    now
          let d be Data-Location of R;
          thus Exec(IncAddr(INS, k), s +* Start-At(IC s + k,SCM R)).d
           = (s +*
          Start-At(IC s + k,SCM R)).d by A38,SCMRING2:18
            .= s.d by Th20
            .= Exec(INS, s).d by A37,SCMRING2:18
            .= (Exec(INS, s) +*Start-At(IC Exec(INS,s) +k,SCM R)).d
            by Th20;
        end;
A41:    now
          let d be Element of NAT;
          thus Exec(IncAddr(INS, k), s +* Start-At(IC s + k,SCM R)).d
           = (s +*
          Start-At(IC s + k,SCM R)).d by AMI_1:def 13
            .= s.d by COMPOS_1:20
            .= Exec(INS, s).d by AMI_1:def 13
            .= (Exec(INS, s) +*Start-At(IC Exec(INS,s) +k,SCM R)).d
            by COMPOS_1:20;
        end;
A42:    IC Exec(INS, s) = loc by A37,A39,SCMRING2:18;
        (s +* Start-At(IC s + k,SCM R)).da=0.R by A39,Th20;
        then IC Exec(IncAddr(INS, k), s +* Start-At(IC s + k,SCM R)) =
        loc + k by A38,SCMRING2:18
          .= IC (Exec(INS,s) +*Start-At(IC Exec(INS,s) +k,SCM R))
          by A42,FUNCT_4:121;
        hence
        Exec(IncAddr(INS, k), s +* Start-At(IC s + k,SCM R))
         = Exec(INS, s) +*
       Start-At(IC Exec(INS,s) +k,SCM R) by A40,A41,Th21;
      end;
      suppose
A43:    s.da <> 0.R;
A44:    now
          let d be Element of NAT;
          thus Exec(IncAddr(INS, k), s +* Start-At(IC s + k,SCM R)).d
           = (s +*
          Start-At(IC s + k,SCM R)).d by AMI_1:def 13
            .= s.d by COMPOS_1:20
            .= Exec(INS, s).d by AMI_1:def 13
            .= (Exec(INS, s) +*Start-At(IC Exec(INS,s) +k,SCM R)).d
            by COMPOS_1:20;
        end;
A45:    now
          let d be Data-Location of R;
          thus Exec(IncAddr(INS, k), s +* Start-At(IC s + k,SCM R)).d
           = (s +*
          Start-At(IC s + k,SCM R)).d by A38,SCMRING2:18
            .= s.d by Th20
            .= Exec(INS, s).d by A37,SCMRING2:18
            .= (Exec(INS, s) +*Start-At(IC Exec(INS,s) +k,SCM R)).d
            by Th20;
        end;
        (s +* Start-At(IC s + k,SCM R)).da<>0.R & IC Exec(INS, s)
         = succ IC s
        by A37,A43,Th20,SCMRING2:18;
        then
        IC Exec(IncAddr(INS, k), s +* Start-At(IC s + k,SCM R))
         = IC (Exec(INS
        , s) +*Start-At(IC Exec(INS,s) +k,SCM R))
        by A3,A38,SCMRING2:18;
        hence Exec(IncAddr(INS, k), s +* Start-At(IC s + k,SCM R)) =
        (Exec(INS, s)
        +*Start-At(IC Exec(INS,s) +k,SCM R)) by A45,A44,Th21;
      end;
    end;
    hence thesis;
  end;
end;

theorem Th23:
  IC s = j+k implies Exec(I, s +* Start-At(IC s -' k,SCM R))
  = Exec(IncAddr(I, k), s) +*
   Start-At (IC Exec(IncAddr(I,k), s) -' k,SCM R)
proof
A1: now
    let d be Element of NAT;
    thus Exec(I, s +* Start-At(IC s -' k,SCM R)).d =
    (s +* Start-At(IC s -' k,SCM R)).d
    by AMI_1:def 13
      .= s.d by COMPOS_1:20
      .= Exec(IncAddr(I, k), s).d by AMI_1:def 13
      .= (Exec(IncAddr(I, k), s) +*
      Start-At (IC Exec(IncAddr(I,k), s) -' k,SCM R)
    ).d by COMPOS_1:20;
  end;
  assume
A2: IC s = j+k;
  then
A3: succ (IC s -' k) = succ j by NAT_D:34
    .= j+1 + k -' k by NAT_D:34
    .= (succ IC s) -' k by A2;
  per cases by NAT_1:32,SCMRING3:71;
  suppose
    InsCode I = 0;
    then
A4: I = halt SCM R by SCMRING3:16;
    hence Exec(I, s +* Start-At(IC s -' k,SCM R)) =
    s +* Start-At(IC s -' k,SCM R) by AMI_1:def 8
      .= s +* Start-At (IC Exec(IncAddr(I,k), s) -' k,SCM R)
      by A4,AMI_1:def 8
      .= Exec(IncAddr(I, k), s) +*
      Start-At (IC Exec(IncAddr(I,k), s) -' k,SCM R) by A4,AMI_1:def 8;
  end;
  suppose
    InsCode I = 1;
    then consider da,db being Data-Location of R such that
A5: I = da := db by SCMRING3:17;
A6: IncAddr(I, k) = da := db by A5,AMISTD_2:29;
    then
A7: Exec(IncAddr(I,k), s).IC SCM R = succ IC s by SCMRING2:13;
A8: now
      let d be Data-Location of R;
      per cases;
      suppose
A9:     da = d;
        hence
        Exec(I, s +* Start-At(IC s -' k,SCM R)).d =
        (s +* Start-At(IC s -' k,SCM R)
        ).db by A5,SCMRING2:13
          .= s.db by Th20
          .= Exec(IncAddr(I,k), s).d by A6,A9,SCMRING2:13
          .= (Exec(IncAddr(I,k), s) +* Start-At (IC Exec(IncAddr(I,k),s) -'
        k,SCM R)).d by Th20;
      end;
      suppose
A10:    da <> d;
        hence
        Exec(I, s +* Start-At(IC s -' k,SCM R)).d =
        (s +* Start-At(IC s -' k,SCM R)
        ).d by A5,SCMRING2:13
          .= s.d by Th20
          .= Exec(IncAddr(I, k), s).d by A6,A10,SCMRING2:13
          .= (Exec(IncAddr(I,k), s) +* Start-At (IC Exec(IncAddr(I,k),s) -'
        k,SCM R)).d by Th20;
      end;
    end;
    IC Exec(I, s +* Start-At(IC s -' k,SCM R))
     = succ IC (s +* Start-At (IC s
    -' k,SCM R)) by A5,SCMRING2:13
      .= IC Exec(IncAddr(I,k), s) -' k by A3,A7,FUNCT_4:121
      .= IC (Exec(IncAddr(I,k),s) +*
      Start-At (IC Exec(IncAddr(I,k),s) -' k,SCM R)
    ) by FUNCT_4:121;
    hence thesis by A1,A8,Th21;
  end;
  suppose
    InsCode I = 2;
    then consider da,db being Data-Location of R such that
A11: I = AddTo(da, db) by SCMRING3:18;
A12: IncAddr(I, k) = AddTo(da, db) by A11,AMISTD_2:29;
    then
A13: Exec(IncAddr(I,k), s).IC SCM R = succ IC s by SCMRING2:14;
A14: now
      let d be Data-Location of R;
      per cases;
      suppose
A15:    da = d;
        hence
        Exec(I, s +* Start-At(IC s -' k,SCM R)).d =
        (s +* Start-At(IC s -' k,SCM R)
        ).da + (s +* Start-At(IC s -' k,SCM R)).db by A11,SCMRING2:14
          .= s.da + (s +* Start-At(IC s -' k,SCM R)).db by Th20
          .= s.da + s.db by Th20
          .= Exec(IncAddr(I,k), s).d by A12,A15,SCMRING2:14
          .= (Exec(IncAddr(I,k), s) +* Start-At (IC Exec(IncAddr(I,k),s) -'
        k,SCM R)).d by Th20;
      end;
      suppose
A16:    da <> d;
        hence
        Exec(I, s +* Start-At(IC s -' k,SCM R)).d =
        (s +* Start-At(IC s -' k,SCM R)
        ).d by A11,SCMRING2:14
          .= s.d by Th20
          .= Exec(IncAddr(I, k), s).d by A12,A16,SCMRING2:14
          .= (Exec(IncAddr(I,k), s) +* Start-At (IC Exec(IncAddr(I,k),s) -'
        k,SCM R)).d by Th20;
      end;
    end;
    IC Exec(I, s +* Start-At(IC s -' k,SCM R))
     = succ IC (s +* Start-At (IC s
    -' k,SCM R)) by A11,SCMRING2:14
      .= IC Exec(IncAddr(I,k), s) -' k by A3,A13,FUNCT_4:121
      .= IC (Exec(IncAddr(I,k),s) +*
      Start-At (IC Exec(IncAddr(I,k),s) -' k,SCM R)
    ) by FUNCT_4:121;
    hence thesis by A1,A14,Th21;
  end;
  suppose
    InsCode I = 3;
    then consider da,db being Data-Location of R such that
A17: I = SubFrom(da, db) by SCMRING3:19;
A18: IncAddr(I, k) = SubFrom(da, db) by A17,AMISTD_2:29;
    then
A19: Exec(IncAddr(I,k), s).IC SCM R = succ IC s by SCMRING2:15;
A20: now
      let d be Data-Location of R;
      per cases;
      suppose
A21:    da = d;
        hence
        Exec(I, s +* Start-At(IC s -' k,SCM R)).d =
        (s +* Start-At(IC s -' k,SCM R)
        ).da - (s +* Start-At(IC s -' k,SCM R)).db by A17,SCMRING2:15
          .= s.da - (s +* Start-At(IC s -' k,SCM R)).db by Th20
          .= s.da - s.db by Th20
          .= Exec(IncAddr(I,k), s).d by A18,A21,SCMRING2:15
          .= (Exec(IncAddr(I,k), s) +* Start-At (IC Exec(IncAddr(I,k),s) -'
        k,SCM R)).d by Th20;
      end;
      suppose
A22:    da <> d;
        hence
        Exec(I, s +* Start-At(IC s -' k,SCM R)).d =
        (s +* Start-At(IC s -' k,SCM R)
        ).d by A17,SCMRING2:15
          .= s.d by Th20
          .= Exec(IncAddr(I, k), s).d by A18,A22,SCMRING2:15
          .= (Exec(IncAddr(I,k), s) +* Start-At (IC Exec(IncAddr(I,k),s) -'
        k,SCM R)).d by Th20;
      end;
    end;
    IC Exec(I, s +* Start-At(IC s -' k,SCM R))
     = succ IC (s +* Start-At (IC s
    -' k,SCM R)) by A17,SCMRING2:15
      .= IC Exec(IncAddr(I,k), s) -' k by A3,A19,FUNCT_4:121
      .= IC (Exec(IncAddr(I,k),s) +*
      Start-At (IC Exec(IncAddr(I,k),s) -' k,SCM R)
    ) by FUNCT_4:121;
    hence thesis by A1,A20,Th21;
  end;
  suppose
    InsCode I = 4;
    then consider da,db being Data-Location of R such that
A23: I = MultBy(da, db) by SCMRING3:20;
A24: IncAddr(I, k) = MultBy(da, db) by A23,AMISTD_2:29;
    then
A25: Exec(IncAddr(I,k), s).IC SCM R = succ IC s by SCMRING2:16;
A26: now
      let d be Data-Location of R;
      per cases;
      suppose
A27:    da = d;
        hence
        Exec(I, s +* Start-At(IC s -' k,SCM R)).d =
        (s +* Start-At(IC s -' k,SCM R)
        ).da * (s +* Start-At(IC s -' k,SCM R)).db by A23,SCMRING2:16
          .= s.da * (s +* Start-At(IC s -' k,SCM R)).db by Th20
          .= s.da * s.db by Th20
          .= Exec(IncAddr(I,k), s).d by A24,A27,SCMRING2:16
          .= (Exec(IncAddr(I,k), s) +* Start-At (IC Exec(IncAddr(I,k),s) -'
        k,SCM R)).d by Th20;
      end;
      suppose
A28:    da <> d;
        hence
        Exec(I, s +* Start-At(IC s -' k,SCM R)).d =
        (s +* Start-At(IC s -' k,SCM R)
        ).d by A23,SCMRING2:16
          .= s.d by Th20
          .= Exec(IncAddr(I, k), s).d by A24,A28,SCMRING2:16
          .= (Exec(IncAddr(I,k), s) +* Start-At (IC Exec(IncAddr(I,k),s) -'
        k,SCM R)).d by Th20;
      end;
    end;
    IC Exec(I, s +* Start-At(IC s -' k,SCM R))
     = succ IC (s +* Start-At (IC s
    -' k,SCM R)) by A23,SCMRING2:16
      .= IC Exec(IncAddr(I,k), s) -' k by A3,A25,FUNCT_4:121
      .= IC (Exec(IncAddr(I,k),s) +*
      Start-At (IC Exec(IncAddr(I,k),s) -' k,SCM R)
    ) by FUNCT_4:121;
    hence thesis by A1,A26,Th21;
  end;
  suppose
    InsCode I = 5;
    then consider da being Data-Location of R, r being Element of R such that
A29: I = da:=r by SCMRING3:21;
A30: IncAddr(I, k) = da := r by A29,AMISTD_2:29;
    then
A31: Exec(IncAddr(I,k), s).IC SCM R = succ IC s by SCMRING2:19;
A32: now
      let d be Data-Location of R;
      per cases;
      suppose
A33:    da = d;
        hence Exec(I, s +* Start-At(IC s -' k,SCM R)).d = r
        by A29,SCMRING2:19
          .= Exec(IncAddr(I,k), s).d by A30,A33,SCMRING2:19
          .= (Exec(IncAddr(I,k), s) +* Start-At (IC Exec(IncAddr(I,k),s) -'
        k,SCM R)).d by Th20;
      end;
      suppose
A34:    da <> d;
        hence
        Exec(I, s +* Start-At(IC s -' k,SCM R)).d =
        (s +* Start-At(IC s -' k,SCM R)
        ).d by A29,SCMRING2:19
          .= s.d by Th20
          .= Exec(IncAddr(I, k), s).d by A30,A34,SCMRING2:19
          .= (Exec(IncAddr(I,k), s) +* Start-At (IC Exec(IncAddr(I,k),s) -'
        k,SCM R)).d by Th20;
      end;
    end;
    IC Exec(I, s +* Start-At(IC s -' k,SCM R))
     = succ IC (s +* Start-At (IC s
    -' k,SCM R)) by A29,SCMRING2:19
      .= IC Exec(IncAddr(I,k), s) -' k by A3,A31,FUNCT_4:121
      .= IC (Exec(IncAddr(I,k),s) +*
      Start-At (IC Exec(IncAddr(I,k),s) -' k,SCM R)
    ) by FUNCT_4:121;
    hence thesis by A1,A32,Th21;
  end;
  suppose
    InsCode I = 6;
    then consider loc being Element of NAT such that
A35: I = goto(loc,R) by SCMRING3:22;
A36: IncAddr(I, k) = goto(loc + k,R) by A35,SCMRING3:69;
    then
A37: IC Exec(IncAddr(I,k), s)= loc + k by SCMRING2:17;
A38: now
      let d be Data-Location of R;
      thus Exec(I, s +* Start-At(IC s -' k,SCM R)).d =
      (s +* Start-At(IC s -' k,SCM R)).
      d by A35,SCMRING2:17
        .= s.d by Th20
        .= Exec(IncAddr(I,k), s).d by A36,SCMRING2:17
        .= (Exec(IncAddr(I,k), s) +*
        Start-At (IC Exec(IncAddr(I,k),s) -' k,SCM R)
      ).d by Th20;
    end;
    IC Exec(I, s +* Start-At(IC s -' k,SCM R)) = loc by A35,SCMRING2:17
      .= IC Exec(IncAddr(I,k), s) -' k by A37,NAT_D:34
      .= IC (Exec(IncAddr(I,k),s) +*
      Start-At (IC Exec(IncAddr(I,k),s) -' k,SCM R)
    ) by FUNCT_4:121;
    hence thesis by A1,A38,Th21;
  end;
  suppose
    InsCode I = 7;
    then consider
    da being Data-Location of R, loc being Element of NAT
    such that
A39: I = da=0_goto loc by SCMRING3:23;
A40: IncAddr(I, k) = da=0_goto (loc + k) by A39,SCMRING3:70;
A41: now
      per cases;
      suppose
A42:    s.da = 0.R;
        then
A43:    IC Exec(IncAddr(I,k), s)= loc + k by A40,SCMRING2:18;
        (s +* Start-At(IC s -' k,SCM R)).da = 0.R by A42,Th20;
        then IC Exec(I, s +* Start-At(IC s -' k,SCM R)) = loc
        by A39,SCMRING2:18
          .= IC Exec(IncAddr(I,k), s) -' k by A43,NAT_D:34
          .= IC (Exec(IncAddr(I,k),s) +* Start-At (IC Exec(IncAddr(I,k),s)
        -' k,SCM R)) by FUNCT_4:121;
        hence IC Exec(I, s +* Start-At(IC s -' k,SCM R)) =
        IC(Exec(IncAddr(I,k),s)
        +* Start-At(IC Exec(IncAddr(I,k),s)-'k,SCM R));
      end;
      suppose
A44:    s.da <> 0.R;
        then
A45:    Exec(IncAddr(I,k), s).IC SCM R = succ IC s by A40,SCMRING2:18;
        (s +* Start-At(IC s -' k,SCM R)).da <> 0.R by A44,Th20;
        then IC Exec(I, s +* Start-At(IC s -' k,SCM R)) =
        succ IC (s +* Start-At (
        IC s -' k,SCM R)) by A39,SCMRING2:18
          .= IC Exec(IncAddr(I,k), s) -' k by A3,A45,FUNCT_4:121
          .= IC(Exec(IncAddr(I,k),s) +* Start-At(IC Exec(IncAddr(I,k),s) -'
        k,SCM R)) by FUNCT_4:121;
        hence IC Exec(I, s +* Start-At(IC s -' k,SCM R)) =
        IC(Exec(IncAddr(I,k),s)
        +* Start-At(IC Exec(IncAddr(I,k),s)-'k,SCM R));
      end;
    end;
    now
      let d be Data-Location of R;
      thus Exec(I, s +* Start-At(IC s -' k,SCM R)).d =
      (s +* Start-At(IC s -' k,SCM R)).
      d by A39,SCMRING2:18
        .= s.d by Th20
        .= Exec(IncAddr(I,k), s).d by A40,SCMRING2:18
        .= (Exec(IncAddr(I,k), s) +*
        Start-At (IC Exec(IncAddr(I,k),s) -' k,SCM R)
      ).d by Th20;
    end;
    hence thesis by A1,A41,Th21;
  end;
end;

registration
  let R;
  cluster autonomic non NAT-defined FinPartState of SCM R;
  existence
  proof
    set P = (IC SCM R, 0) --> (0, halt SCM R);
    P = Start-At(0,SCM R)+*((0) .--> halt SCM R) by FUNCT_4:def 4;
    then reconsider P as FinPartState of SCM R;
    take P;
    thus P is autonomic by AMI_1:67;
    now
      dom P = { IC SCM R, 0 } by FUNCT_4:65;
      then
A1:   IC SCM R in dom P by TARSKI:def 2;
      assume dom P c= NAT;
      then reconsider l = IC SCM R as Element of NAT by A1;
      l = IC SCM R;
      hence contradiction by COMPOS_1:3;
    end;
    hence thesis by RELAT_1:def 18;
  end;
end;

definition
  let R;
  let a be Data-Location of R;
  let r be Element of R;
  redefine func a .--> r -> FinPartState of SCM R;
  coherence
  proof
    set k = a .--> r, f = the Object-Kind of SCM R;
    reconsider b = a as Element of SCM-Memory by SCMRING2:def 1;
A2: dom k = {a} by FUNCOP_1:19;
    for x being set st x in dom k holds k.x in f.x
    proof
      let x be set;
      assume
A4:   x in dom k;
      then x = a by A2,TARSKI:def 1;
      then
A5:   k.x = r by FUNCOP_1:87;
      f.x = ObjectKind a by A2,A4,TARSKI:def 1
        .= the carrier of R by SCMRING3:1;
      hence thesis by A5;
    end;
    hence thesis by A2,FUNCT_1:def 20,RELAT_1:def 18;
  end;
end;

theorem Th24:
  R is non trivial implies for p being autonomic FinPartState of
  SCM R st DataPart p <> {} holds IC SCM R in dom p
proof
  assume
A1: R is non trivial;
  let p be autonomic FinPartState of SCM R;
  assume DataPart p <> {};
  then
A2: dom DataPart p <> {};
  assume
A3: not IC SCM R in dom p;
  p is not autonomic
  proof
    consider il being Element of (NAT) \ dom p;
    consider d2 being Element of SCM-Data-Loc \ dom p;
    consider d1 being Element of dom DataPart p;
A4: d1 in dom DataPart p by A2;
    dom DataPart p c= the carrier of SCM R by RELAT_1:def 18;
    then reconsider d1 as Element of SCM R by A4;
    not SCM-Data-Loc c= dom p;
    then
A5: SCM-Data-Loc \ dom p <> {} by XBOOLE_1:37;
    then d2 in SCM-Data-Loc by XBOOLE_0:def 5;
    then reconsider d2 as Data-Location of R by SCMRING2:1;
A6: not d2 in dom p by A5,XBOOLE_0:def 5;
    not NAT c= dom p;
    then
A7: (NAT) \ dom p <> {} by XBOOLE_1:37;
    then reconsider il as Element of NAT by XBOOLE_0:def 5;
A8: not il in dom p by A7,XBOOLE_0:def 5;
    Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
    then dom DataPart p c= SCM-Data-Loc by RELAT_1:87;
    then reconsider d1 as Data-Location of R by A4,SCMRING2:1;
A9: dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At(il,SCM R)) = dom ((il
    .--> (d1:=d2)) +* ( d2.--> 0.R)) \/ dom(Start-At(il,SCM R))
    by FUNCT_4:def 1;
    set p1 = p +* ((il .--> (d1:=d2)) +* (d2.--> 0.R) +* Start-At(il,SCM R));
    consider s1 being State of SCM R such that
A10: p1 c= s1 by PBOOLE:156;
A11: dom p1 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +*
    Start-At(il,SCM R)) by FUNCT_4:def 1;
A12: dom(Start-At(il,SCM R)) = {IC SCM R} by FUNCOP_1:19;
    then
A13: IC SCM R in dom (Start-At(il,SCM R)) by TARSKI:def 1;
    then
A14: IC SCM R in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +*
Start-At(il,SCM R))
    by A9,XBOOLE_0:def 3;
    then IC SCM R in dom p1 by A11,XBOOLE_0:def 3;
    then
A15: IC s1 = p1.IC SCM R by A10,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At(il,SCM R)).IC SCM R
      by A14,FUNCT_4:14
      .= (Start-At(il,SCM R)).IC SCM R by A13,FUNCT_4:14
      .= il by FUNCOP_1:87;
A16: il <> IC SCM R by COMPOS_1:3;
    then
A17: not il in dom (Start-At(il,SCM R)) by A12,TARSKI:def 1;
A18: dom(Start-At(il,SCM R)) = {IC SCM R} by FUNCOP_1:19;
    then
A19: not il in dom (Start-At(il,SCM R)) by A16,TARSKI:def 1;
A20: d2 <> IC SCM R by SCMRING3:3;
    then
A21: not d2 in dom (Start-At(il,SCM R)) by A12,TARSKI:def 1;
A22: not d2 in dom (Start-At(il,SCM R)) by A20,A18,TARSKI:def 1;
A23: dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R)) = dom (il .--> (d1:=d2)) \/
    dom ( d2.--> 0.R) by FUNCT_4:def 1;
A24: dom (d2 .--> 0.R) = {d2} by FUNCOP_1:19;
    then
A25: d2 in dom (d2 .--> 0.R) by TARSKI:def 1;
    then d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R)) by A23,XBOOLE_0:def 3;
    then
A26: d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At(il,SCM R))
by A9,XBOOLE_0:def 3;
    then d2 in dom p1 by A11,XBOOLE_0:def 3;
    then
A27: s1.d2 = p1.d2 by A10,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At(il,SCM R)).d2 by A26,
FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R)).d2 by A21,FUNCT_4:12
      .= (d2.--> 0.R).d2 by A25,FUNCT_4:14
      .= 0.R by FUNCOP_1:87;
A28: il <> d2 by Th7;
    then
A29: not il in dom (d2 .--> 0.R) by A24,TARSKI:def 1;
    dom (il .--> (d1:=d2)) = {il} by FUNCOP_1:19;
    then il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
    then il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R)) by A23,XBOOLE_0:def 3;
    then
A30: il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At(il,SCM R))
by A9,XBOOLE_0:def 3;
    then il in dom p1 by A11,XBOOLE_0:def 3;
    then
A31: s1.il = p1.il by A10,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At(il,SCM R)).il by A30,
FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> 0.R)).il by A17,FUNCT_4:12
      .= (il .--> (d1:=d2)).il by A29,FUNCT_4:12
      .= d1:=d2 by FUNCOP_1:87;
X:  dom p c= the carrier of SCM R by RELAT_1:def 18;
    dom Comput(ProgramPart(s1),s1,1) = the carrier of SCM R by PARTFUN1:def 4;
    then
A32: dom (Comput(ProgramPart(s1),s1,1)|dom p) = dom p by X,RELAT_1:91;
    consider e being Element of R such that
A33: e <> 0.R by A1,STRUCT_0:def 19;
    DataPart p c= p by RELAT_1:88;
    then
A34: dom DataPart p c= dom p by RELAT_1:25;
    set p2 = p +* ((il .--> (d1:=d2)) +* (d2.--> e) +* Start-At(il,SCM R));
    consider s2 being State of SCM R such that
A35: p2 c= s2 by PBOOLE:156;
    take s1, s2;
    dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +* Start-At(il,SCM R)) = dom((il
    .--> (d1:=d2)) +* ( d2.--> 0.R)) \/ dom(Start-At(il,SCM R))
    by FUNCT_4:def 1
      .= dom((il .--> (d1:=d2)) +* ( d2.--> 0.R)) \/ {IC SCM R} by FUNCOP_1:19
      .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> 0.R) \/ {IC SCM R} by
FUNCT_4:def 1
      .= {il} \/ dom ( d2.--> 0.R) \/ {IC SCM R} by FUNCOP_1:19
      .= {il} \/ {d2} \/ {IC SCM R} by FUNCOP_1:19;
    then dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +*
    Start-At(il,SCM R)) =
    dom p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM R} by XBOOLE_1:23
      .= dom p /\ ({il} \/ {d2}) \/ {} by A3,Lm1
      .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
      .= dom p /\ {il} \/ {} by A6,Lm1
      .= {} by A8,Lm1;
    then
    dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> 0.R) +*
    Start-At(il,SCM R))
    by XBOOLE_0:def 7;
    then p c= p1 by FUNCT_4:33;
    hence p c= s1 by A10,XBOOLE_1:1;
    dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R)) =
    dom((il .-->
    (d1:=d2)) +* ( d2.--> e)) \/ dom(Start-At(il,SCM R)) by FUNCT_4:def 1
      .= dom((il .--> (d1:=d2)) +* ( d2.--> e)) \/ {IC SCM R} by FUNCOP_1:19
      .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> e) \/ {IC SCM R} by
FUNCT_4:def 1
      .= {il} \/ dom ( d2.--> e) \/ {IC SCM R} by FUNCOP_1:19
      .= {il} \/ {d2} \/ {IC SCM R} by FUNCOP_1:19;
    then
    dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R))
     = dom
    p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM R} by XBOOLE_1:23
      .= dom p /\ ({il} \/ {d2}) \/ {} by A3,Lm1
      .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
      .= dom p /\ {il} \/ {} by A6,Lm1
      .= {} by A8,Lm1;
    then dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> e) +*
    Start-At(il,SCM R))
    by XBOOLE_0:def 7;
    then p c= p2 by FUNCT_4:33;
    hence p c= s2 by A35,XBOOLE_1:1;
    take 1;
A36: dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R)) = dom ((il
    .--> (d1:=d2)) +* ( d2.--> e)) \/ dom(Start-At(il,SCM R)) by FUNCT_4:def 1;
A37: dom (d2 .--> e) = {d2} by FUNCOP_1:19;
    then
A38: not il in dom (d2 .--> e) by A28,TARSKI:def 1;
A39: dom p2 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(
    il,SCM R)) by FUNCT_4:def 1;
A40: IC SCM R in dom (Start-At(il,SCM R)) by A18,TARSKI:def 1;
    then
A41: IC SCM R in dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R) )
    by A36,XBOOLE_0:def 3;
    then IC SCM R in dom p2 by A39,XBOOLE_0:def 3;
    then
A42: IC s2 = p2.IC SCM R by A35,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R)).IC SCM R
      by A41,FUNCT_4:14
      .= (Start-At(il,SCM R)).IC SCM R by A40,FUNCT_4:14
      .= il by FUNCOP_1:87;
X:  dom p c= the carrier of SCM R by RELAT_1:def 18;
    dom (Comput(ProgramPart(s2),s2,1)) = the carrier of SCM R by PARTFUN1:def 4
;
    then
A43: dom (Comput(ProgramPart(s2),s2,1)|dom p) = dom p by X,RELAT_1:91;
A44: dom ((il .--> (d1:=d2)) +* ( d2.--> e)) = dom (il .--> (d1:=d2)) \/
    dom ( d2.--> e) by FUNCT_4:def 1;
    dom (il .--> (d1:=d2)) = {il} by FUNCOP_1:19;
    then il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
    then il in dom ((il .--> (d1:=d2)) +* ( d2.--> e)) by A44,XBOOLE_0:def 3;
    then
A45: il in dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R))
by A36,XBOOLE_0:def 3;
    then il in dom p2 by A39,XBOOLE_0:def 3;
    then
A46: s2.il = p2.il by A35,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R)).il by A45,
FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> e)).il by A19,FUNCT_4:12
      .= (il .--> (d1:=d2)).il by A38,FUNCT_4:12
      .= d1:=d2 by FUNCOP_1:87;
A47: d2 in dom (d2 .--> e) by A37,TARSKI:def 1;
    then d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> e)) by A44,XBOOLE_0:def 3;
    then
A48: d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R))
by A36,XBOOLE_0:def 3;
    then d2 in dom p2 by A39,XBOOLE_0:def 3;
    then
A49: s2.d2 = p2.d2 by A35,GRFUNC_1:8
      .= ((il .--> (d1:=d2)) +* ( d2.--> e) +* Start-At(il,SCM R)).d2 by A48,
FUNCT_4:14
      .= ((il .--> (d1:=d2)) +* ( d2.--> e)).d2 by A22,FUNCT_4:12
      .= (d2.--> e).d2 by A47,FUNCT_4:14
      .= e by FUNCOP_1:87;
X:  (ProgramPart s2)/.il = s2.il by COMPOS_1:38;
A50: Comput(ProgramPart(s2),s2,0+1).d1 =
 (Following(ProgramPart s2,Comput(ProgramPart(s2),s2,
0))).d1 by AMI_1:14
      .= (Following(ProgramPart s2,s2)).d1 by AMI_1:13
      .= e by A42,A46,A49,X,SCMRING2:13;
X:  (ProgramPart s1)/.il = s1.il by COMPOS_1:38;
    Comput(ProgramPart(s1),s1,0+1).d1 =
     (Following(ProgramPart s1,Comput(ProgramPart(s1)
,s1,0))).d1
     by AMI_1:14
      .= (Following(ProgramPart s1,s1)).d1 by AMI_1:13
      .= 0.R by A15,A31,A27,X,SCMRING2:13;
    then (Comput(ProgramPart(s1),s1,1)|dom p).d1 = 0.R by A4,A34,A32,FUNCT_1:70
;
    hence Comput(ProgramPart(s1),s1,1)|dom p <> Comput(ProgramPart(s2),s2,1)|
dom p by A4,A33,A34,A43,A50,FUNCT_1:70;
  end;
  hence contradiction;
end;

theorem Th25:
  R is non trivial implies for p being autonomic non NAT-defined
  FinPartState of SCM R holds IC SCM R in dom p
proof
  assume
A1: R is non trivial;
  let p be autonomic non NAT-defined FinPartState of SCM R;
A2: not dom p c= NAT by RELAT_1:def 18;
  dom p c= the carrier of SCM R by RELAT_1:def 18;
  then dom p = dom p /\ the carrier of SCM R by XBOOLE_1:28
    .= dom p /\ ({IC SCM R} \/ SCM-Data-Loc \/ NAT) by Th1
    .= dom p /\ ({IC SCM R} \/ SCM-Data-Loc) \/ dom p /\ NAT by XBOOLE_1:23;
  then dom p /\ ({IC SCM R} \/ SCM-Data-Loc) <> {} by A2,XBOOLE_1:17;
  then
A3: dom p /\ {IC SCM R} \/ dom p /\ SCM-Data-Loc <> {} by XBOOLE_1:23;
  per cases by A3;
  suppose
    dom p /\ {IC SCM R} <> {};
    hence thesis by Lm1;
  end;
  suppose
A4: dom p /\ SCM-Data-Loc <> {};
    Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
    then DataPart p <> {} by A4,RELAT_1:60,90;
    hence thesis by A1,Th24;
  end;
end;

theorem
  for p being autonomic FinPartState of SCM R st IC SCM R in dom p holds
  IC p in dom p
proof
  let p be autonomic FinPartState of SCM R;
  assume
A1: IC SCM R in dom p;
  set il = IC p;
  set p1 = p +* ((il .--> goto(0,R)));
  set p2 = p +* ((il .--> goto(1,R)));
  consider s1 being State of SCM R such that
A2: p1 c= s1 by PBOOLE:156;
  consider s2 being State of SCM R such that
A3: p2 c= s2 by PBOOLE:156;
  assume
A4: not IC p in dom p;
  p is not autonomic
  proof
    take s1,s2;
A5: dom (il .--> (goto(1,R))) = {il} by FUNCOP_1:19;
    then
A6: il in dom (il .--> (goto(1,R))) by TARSKI:def 1;
A7: dom p misses {il} by A4,ZFMISC_1:56;
    then
A8: p c= p2 by A5,FUNCT_4:33;
    dom p2 = dom p \/ dom ((il .--> goto(1,R))) by FUNCT_4:def 1;
    then il in dom p2 by A6,XBOOLE_0:def 3;
    then
X:   s2.il = p2.il by A3,GRFUNC_1:8
      .= ((il .--> goto(1,R))).il by A6,FUNCT_4:14
      .= goto(1,R) by FUNCOP_1:87;
Y:  (ProgramPart s2)/.il = s2.il by COMPOS_1:38;
    p c= s2 by A3,A8,XBOOLE_1:1;
    then
A9: (Following(ProgramPart s2,s2)).IC SCM R =
Exec (goto(1,R),s2).IC SCM R
by A1,X,Y,GRFUNC_1:8
      .= 1 by SCMRING2:17;
A10: dom (il .--> (goto(0,R))) = {il} by FUNCOP_1:19;
    then
A11: il in dom (il .--> (goto(0,R))) by TARSKI:def 1;
A12: p c= p1 by A10,A7,FUNCT_4:33;
    hence p c= s1 & p c= s2 by A2,A3,A8,XBOOLE_1:1;
    take 1;
    assume
A13: Comput(ProgramPart(s1),s1,1)|dom p = Comput(ProgramPart(s2),s2,1)|dom p;
A14: (Following(ProgramPart s1,s1))|dom p
 = (Following(ProgramPart s1,Comput(ProgramPart(s1),
s1,0)))|dom p
 by AMI_1:13
      .= Comput(ProgramPart(s1),s1,0+1)|dom p by AMI_1:14
      .= (Following(ProgramPart s2,Comput(ProgramPart
(s2),s2,0)))|dom p
      by A13,AMI_1:14
      .= (Following(ProgramPart s2,s2))|dom p by AMI_1:13;
    dom p1 = dom p \/ dom ((il .--> goto(0,R))) by FUNCT_4:def 1;
    then il in dom p1 by A11,XBOOLE_0:def 3;
    then
X:   s1.il = p1.il by A2,GRFUNC_1:8
      .= ((il .--> goto(0,R))).il by A11,FUNCT_4:14
      .= goto(0,R) by FUNCOP_1:87;
Y:  (ProgramPart s1)/.il = s1.il by COMPOS_1:38;
    p c= s1 by A2,A12,XBOOLE_1:1;
    then
    (Following(ProgramPart s1,s1)).IC SCM R =
    Exec (goto(0,R),s1).IC SCM R
    by A1,X,Y,GRFUNC_1:8
      .= 0 by SCMRING2:17;
    then 0 = ((Following(ProgramPart s1,s1))|dom p).IC SCM R
    by A1,FUNCT_1:72
      .= 1 by A1,A9,A14,FUNCT_1:72;
    hence contradiction;
  end;
  hence contradiction;
end;

theorem Th27:
  R is non trivial implies for p being autonomic non NAT-defined
FinPartState of SCM R st p c= s holds IC Comput(ProgramPart(s),s,n) in dom
ProgramPart(p)
proof
  assume
A1: R is non trivial;
  set Csi = Comput(ProgramPart(s),s,n);
  let p be autonomic non NAT-defined FinPartState of SCM R such that
A2: p c= s;
  set loc = IC Csi;
  consider ll being natural number such that
A3: loc = ll;
  set loc1 = ll+1;
A4: loc <> loc1 by A3;
  set p2 = p +* (loc .--> goto(loc1,R));
A5: loc in dom ProgramPart p iff loc in dom p /\ NAT by RELAT_1:90;
  set p1 = p +* (loc .--> goto(loc,R));
A7: dom (loc .--> goto(loc,R)) = {loc} by FUNCOP_1:19;
  then
A8: loc in dom (loc .--> goto(loc,R)) by TARSKI:def 1;
  assume not IC Comput(ProgramPart(s),s,n) in dom ProgramPart(p);
  then
A9: not loc in dom p by A5,XBOOLE_0:def 4;
  consider s2 being State of SCM R such that
A10: p2 c= s2 by PBOOLE:156;
  set Cs2i = Comput(ProgramPart(s2),s2,n);
  consider s1 being State of SCM R such that
A11: p1 c= s1 by PBOOLE:156;
  set Cs1i = Comput(ProgramPart(s1),s1,n);
A12: dom (loc .--> goto(loc1,R)) = {loc} by FUNCOP_1:19;
  then
A13: loc in dom (loc .--> goto(loc1,R)) by TARSKI:def 1;
A14: dom p2 = dom p \/ dom (loc .--> goto(loc1,R)) by FUNCT_4:def 1;
  then
A15: loc in dom p2 by A13,XBOOLE_0:def 3;
A16: dom p1 = dom p \/ dom (loc .--> goto(loc,R)) by FUNCT_4:def 1;
  then
A17: loc in dom p1 by A8,XBOOLE_0:def 3;
  p is not autonomic
  proof
A18: now
      let x be set;
      assume
A19:  x in dom p;
      dom p misses dom (loc .--> goto(loc1,R)) by A9,A12,ZFMISC_1:56;
      then
A20:  p.x = p2.x by A19,FUNCT_4:17;
      x in dom p2 by A14,A19,XBOOLE_0:def 3;
      hence p.x = s2.x by A10,A20,GRFUNC_1:8;
    end;
    (loc .--> goto(loc1,R)).loc = goto(loc1,R) by FUNCOP_1:87;
    then p2.loc = goto(loc1,R) by A13,FUNCT_4:14;
    then s2.loc = goto(loc1,R) by A15,A10,GRFUNC_1:8;
    then
A21: Cs2i.loc = goto(loc1,R) by AMI_1:54;
    (loc .--> goto(loc,R)).loc = goto(loc,R) by FUNCOP_1:87;
    then p1.loc = goto(loc,R) by A8,FUNCT_4:14;
    then s1.loc = goto(loc,R) by A17,A11,GRFUNC_1:8;
    then
A22: Cs1i.loc = goto(loc,R) by AMI_1:54;
    take s1, s2;
A23: now
      let x be set;
      assume
A24:  x in dom p;
      dom p misses dom (loc .--> goto(loc,R)) by A9,A7,ZFMISC_1:56;
      then
A25:  p.x = p1.x by A24,FUNCT_4:17;
      x in dom p1 by A16,A24,XBOOLE_0:def 3;
      hence p.x = s1.x by A11,A25,GRFUNC_1:8;
    end;
    dom s1 = the carrier of SCM R by PARTFUN1:def 4;
    then dom p c= dom s1 by RELAT_1:def 18;
    hence
A26: p c= s1 by A23,GRFUNC_1:8;
    then
A27: (Cs1i|dom p) = (Csi|dom p) by A2,AMI_1:def 25;
    dom s2 = the carrier of SCM R by PARTFUN1:def 4;
    then dom p c= dom s2 by RELAT_1:def 18;
    hence p c= s2 by A18,GRFUNC_1:8;
    then
A28: (Cs1i|dom p) = (Cs2i|dom p) by A26,AMI_1:def 25;
    take k = n+1;
    set Cs1k = Comput(ProgramPart(s1),s1,k);
A29: Cs1k = Following(ProgramPart s1,Cs1i) by AMI_1:14
      .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by AMI_1:123;
Y:  (ProgramPart Cs1i)/.loc = Cs1i.loc by COMPOS_1:38;
A30: Csi.IC SCM R = (Csi|dom p).IC SCM R by A1,Th25,FUNCT_1:72;
    then Cs1i.IC SCM R = loc by A1,A27,Th25,FUNCT_1:72;
    then
A31: Cs1k.IC SCM R = loc by A29,A22,Y,SCMRING2:17;
    set Cs2k = Comput(ProgramPart(s2),s2,k);
A32: Cs2k = Following(ProgramPart s2,Cs2i) by AMI_1:14
      .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by AMI_1:123;
Y:  (ProgramPart Cs2i)/.loc = Cs2i.loc by COMPOS_1:38;
    Cs2i.IC SCM R = loc by A1,A27,A30,A28,Th25,FUNCT_1:72;
    then
A33: Cs2k.IC SCM R = loc1 by A32,A21,Y,SCMRING2:17;
    (Cs1k|dom p).IC SCM R = Cs1k.IC SCM R by A1,Th25,FUNCT_1:72;
    hence Cs1k|dom p <> Cs2k|dom p by A1,A4,A31,A33,Th25,FUNCT_1:72;
  end;
  hence contradiction;
end;

theorem Th28:
  R is non trivial implies for p being autonomic non NAT-defined
  FinPartState of SCM R st p c= s1 & p c= s2 holds IC Comput(ProgramPart(s1),s1
,n) = IC
Comput(ProgramPart(s2),s2,n) &
CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s1),s1,n))
=
CurInstr(ProgramPart Comput(ProgramPart(s2),s2,n),Comput(ProgramPart(s2),s2,n))
proof
  assume
A1: R is non trivial;
  set Cs2i = Comput(ProgramPart(s2),s2,n);
  set Cs1i = Comput(ProgramPart(s1),s1,n);
  let p be autonomic non NAT-defined FinPartState of SCM R such that
A2: p c= s1 and
A3: p c= s2;
  ProgramPart p c= p by RELAT_1:88;
  then
A4: dom ProgramPart p c= dom p by GRFUNC_1:8;
  thus
A5: IC Cs1i = IC Cs2i
  proof
    assume
A6: IC Cs1i <> IC Cs2i;
    (Cs1i|dom p).IC SCM R = Cs1i.IC SCM R & (Cs2i|dom p).IC SCM R = Cs2i.
    IC SCM R by A1,Th25,FUNCT_1:72;
    hence contradiction by A2,A3,A6,AMI_1:def 25;
  end;
  IC Cs2i in dom ProgramPart p by A1,A3,Th27;
  then
A7: (Cs2i|dom p).IC Cs2i = Cs2i.IC Cs2i by A4,FUNCT_1:72;
Y:  (ProgramPart Cs1i)/.IC Cs1i = Cs1i.IC Cs1i by COMPOS_1:38;
Z:  (ProgramPart Cs2i)/.IC Cs2i = Cs2i.IC Cs2i by COMPOS_1:38;
  IC Cs1i in dom ProgramPart p by A1,A2,Th27;
  then
A8: (Cs1i|dom p).IC Cs1i = Cs1i.IC Cs1i by A4,FUNCT_1:72;
  assume not thesis;
  hence contradiction by A2,A3,A5,A8,A7,Y,Z,AMI_1:def 25;
end;

theorem Th29:
  R is non trivial implies for p being autonomic non NAT-defined
  FinPartState of SCM R st p c= s1 & p c= s2 &
  CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s1),s1,n
)) = a
  := b & a in dom p holds Comput(ProgramPart(s1),s1,n).b = Comput(ProgramPart(
s2),s2,n).b
proof
  assume
A1: R is non trivial;
  set Cs2i1 = Comput(ProgramPart(s2),s2,n+1);
  set Cs1i1 = Comput(ProgramPart(s1),s1,n+1);
  set Cs2i = Comput(ProgramPart(s2),s2,n);
  set Cs1i = Comput(ProgramPart(s1),s1,n);
  set I = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(
s1),s1,n));
  let p be autonomic non NAT-defined FinPartState of SCM R such that
A2: p c= s1 & p c= s2;
A3: a in dom p implies (Cs1i1|dom p).a = Cs1i1.a & (Cs2i1|dom p).a = Cs2i1.a
  by FUNCT_1:72;
A4: Cs2i1 = Following(ProgramPart s2,Cs2i) by AMI_1:14
    .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by AMI_1:123;
  assume that
A5: I = a := b and
A6: a in dom p & Comput(ProgramPart(s1),s1,n).b <> Comput(ProgramPart(s2),s2,n)
.b;
  Cs1i1 = Following(ProgramPart s1,Cs1i) by AMI_1:14
    .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by AMI_1:123;
  then
A7: Cs1i1.a = Cs1i.b by A5,SCMRING2:13;
  I = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,n),Comput(ProgramPart(s2),
s2,n)) by A1,A2,Th28;
  then Cs2i1.a = Cs2i.b by A4,A5,SCMRING2:13;
  hence contradiction by A2,A3,A6,A7,AMI_1:def 25;
end;

theorem Th30:
  R is non trivial implies for p being autonomic non NAT-defined
  FinPartState of SCM R st p c= s1 & p c= s2 &
  CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s1),s1,n
)) =
  AddTo(a,b) & a in dom p holds Comput(ProgramPart(s1),s1,n).a + Comput(
ProgramPart(s1),s1,n).b =
  Comput(ProgramPart(s2),s2,n).a + Comput(ProgramPart(s2),s2,n).b
proof
  assume
A1: R is non trivial;
  set Cs2i1 = Comput(ProgramPart(s2),s2,n+1);
  set Cs1i1 = Comput(ProgramPart(s1),s1,n+1);
  set Cs2i = Comput(ProgramPart(s2),s2,n);
  set Cs1i = Comput(ProgramPart(s1),s1,n);
  set I = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(
s1),s1,n));
  let p be autonomic non NAT-defined FinPartState of SCM R such that
A2: p c= s1 & p c= s2;
A3: a in dom p implies (Cs1i1|dom p).a = Cs1i1.a & (Cs2i1|dom p).a = Cs2i1.a
  by FUNCT_1:72;
A4: Cs2i1 = Following(ProgramPart s2,Cs2i) by AMI_1:14
    .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by AMI_1:123;
  assume that
A5: I = AddTo(a,b) and
A6: a in dom p & Comput(ProgramPart(s1),s1,n).a + Comput(ProgramPart(s1),s1,n).
b <>
  Comput(ProgramPart(s2),s2,n). a + Comput(ProgramPart(s2),s2,n).b;
  Cs1i1 = Following(ProgramPart s1,Cs1i) by AMI_1:14
    .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by AMI_1:123;
  then
A7: Cs1i1.a = Cs1i.a + Cs1i.b by A5,SCMRING2:14;
  I = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,n),Comput(ProgramPart(s2),
s2,n)) by A1,A2,Th28;
  then Cs2i1.a = Cs2i.a + Cs2i.b by A4,A5,SCMRING2:14;
  hence contradiction by A2,A3,A6,A7,AMI_1:def 25;
end;

theorem Th31:
  R is non trivial implies for p being autonomic non NAT-defined
  FinPartState of SCM R st p c= s1 & p c= s2 &
  CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s1),s1,n
)) =
  SubFrom(a, b) & a in dom p holds Comput(ProgramPart(s1),s1,n).a - Comput(
ProgramPart(s1),s1,n).b =
  Comput(ProgramPart(s2),s2,n).a - Comput(ProgramPart(s2),s2,n).b
proof
  assume
A1: R is non trivial;
  set Cs2i1 = Comput(ProgramPart(s2),s2,n+1);
  set Cs1i1 = Comput(ProgramPart(s1),s1,n+1);
  set Cs2i = Comput(ProgramPart(s2),s2,n);
  set Cs1i = Comput(ProgramPart(s1),s1,n);
  set I = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(
s1),s1,n));
  let p be autonomic non NAT-defined FinPartState of SCM R such that
A2: p c= s1 & p c= s2;
A3: a in dom p implies (Cs1i1|dom p).a = Cs1i1.a & (Cs2i1|dom p).a = Cs2i1.a
  by FUNCT_1:72;
A4: Cs2i1 = Following(ProgramPart s2,Cs2i) by AMI_1:14
    .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by AMI_1:123;
  assume that
A5: I = SubFrom(a,b) and
A6: a in dom p & Comput(ProgramPart(s1),s1,n).a - Comput(ProgramPart(s1),s1,n).
b <>
  Comput(ProgramPart(s2),s2,n). a - Comput(ProgramPart(s2),s2,n).b;
  Cs1i1 = Following(ProgramPart s1,Cs1i) by AMI_1:14
    .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by AMI_1:123;
  then
A7: Cs1i1.a = Cs1i.a - Cs1i.b by A5,SCMRING2:15;
  I = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,n),Comput(ProgramPart(s2),
s2,n)) by A1,A2,Th28;
  then Cs2i1.a = Cs2i.a - Cs2i.b by A4,A5,SCMRING2:15;
  hence contradiction by A2,A3,A6,A7,AMI_1:def 25;
end;

theorem Th32:
  R is non trivial implies for p being autonomic non NAT-defined
  FinPartState of SCM R st p c= s1 & p c= s2 &
  CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s1),s1,n
)) =
  MultBy(a, b) & a in dom p holds Comput(ProgramPart(s1),s1,n).a * Comput(
ProgramPart(s1),s1,n).b =
  Comput(ProgramPart(s2),s2,n).a * Comput(ProgramPart(s2),s2,n).b
proof
  assume
A1: R is non trivial;
  set Cs2i1 = Comput(ProgramPart(s2),s2,n+1);
  set Cs1i1 = Comput(ProgramPart(s1),s1,n+1);
  set Cs2i = Comput(ProgramPart(s2),s2,n);
  set Cs1i = Comput(ProgramPart(s1),s1,n);
  set I = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(
s1),s1,n));
  let p be autonomic non NAT-defined FinPartState of SCM R such that
A2: p c= s1 & p c= s2;
A3: a in dom p implies (Cs1i1|dom p).a = Cs1i1.a & (Cs2i1|dom p).a = Cs2i1.a
  by FUNCT_1:72;
A4: Cs2i1 = Following(ProgramPart s2,Cs2i) by AMI_1:14
    .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by AMI_1:123;
  assume that
A5: I = MultBy(a,b) and
A6: a in dom p & Comput(ProgramPart(s1),s1,n).a * Comput(ProgramPart(s1),s1,n).
b <>
  Comput(ProgramPart(s2),s2,n). a * Comput(ProgramPart(s2),s2,n).b;
  Cs1i1 = Following(ProgramPart s1,Cs1i) by AMI_1:14
    .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by AMI_1:123;
  then
A7: Cs1i1.a = Cs1i.a * Cs1i.b by A5,SCMRING2:16;
  I = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,n),Comput(ProgramPart(s2),
s2,n)) by A1,A2,Th28;
  then Cs2i1.a = Cs2i.a * Cs2i.b by A4,A5,SCMRING2:16;
  hence contradiction by A2,A3,A6,A7,AMI_1:def 25;
end;

theorem Th33:
  R is non trivial implies for p being autonomic non NAT-defined
  FinPartState of SCM R st p c= s1 & p c= s2 &
  CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s1),s1,n
)) = a
=0_goto loc & loc <> succ (IC Comput(ProgramPart(s1),s1,n)) holds Comput(
ProgramPart(s1),s1,n).a = 0.
  R iff Comput(ProgramPart(s2),s2,n).a = 0.R
proof
  assume
A1: R is non trivial;
  set Cs2i1 = Comput(ProgramPart(s2),s2,n+1);
  set Cs1i1 = Comput(ProgramPart(s1),s1,n+1);
  set I = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(
s1),s1,n));
  let p be autonomic non NAT-defined FinPartState of SCM R such that
A2: p c= s1 & p c= s2;
A3: I = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,n),Comput(ProgramPart(s2
),s2,n))
 by A1,A2,Th28;
  set Cs2i = Comput(ProgramPart(s2),s2,n);
  set Cs1i = Comput(ProgramPart(s1),s1,n);
A4: Cs1i1 = Following(ProgramPart s1,Cs1i) by AMI_1:14
    .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by AMI_1:123;
A5: Cs2i1 = Following(ProgramPart s2,Cs2i) by AMI_1:14
    .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by AMI_1:123;
A6: (Cs1i1|dom p).IC SCM R = Cs1i1.IC SCM R & (Cs2i1|dom p).IC SCM R = Cs2i1
  .IC SCM R by A1,Th25,FUNCT_1:72;
  assume that
A7: I = a=0_goto loc and
A8: loc <> succ (IC Comput(ProgramPart(s1),s1,n));
A9: IC Cs1i = IC Cs2i by A1,A2,Th28;
  hereby
    assume
    Comput(ProgramPart(s1),s1,n).a = 0.R & Comput(ProgramPart(s2),s2,n).a <> 0.
R;
    then Cs1i1.IC SCM R = loc & Cs2i1.IC SCM R = succ IC Cs2i by A3,A4,A5,A7,
SCMRING2:18;
    hence contradiction by A2,A9,A6,A8,AMI_1:def 25;
  end;
  assume that
A10: Comput(ProgramPart(s2),s2,n).a = 0.R and
A11: Comput(ProgramPart(s1),s1,n).a <> 0.R;
A12: Cs1i1.IC SCM R = succ IC Cs1i by A4,A7,A11,SCMRING2:18;
  Cs2i1.IC SCM R = loc by A3,A5,A7,A10,SCMRING2:18;
  hence contradiction by A2,A6,A8,A12,AMI_1:def 25;
end;

begin :: Relocability

theorem Th34:
  for p being autonomic FinPartState of SCM R st p c= s1 &
  Relocated (p,k) c= s2 holds p c= s1 +* DataPart s2
proof
A1: Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
  set s3 = DataPart s2;
  reconsider s = s1 +* DataPart s2 as State of SCM R;
  let p be autonomic FinPartState of SCM R such that
A2: p c= s1 and
A3: Relocated (p,k) c= s2;
A4: dom p c= the carrier of SCM R by RELAT_1:def 18;
  then
A5: dom p c= {IC SCM R} \/ SCM-Data-Loc \/ NAT by Th1;
A6: now
    dom s2 = the carrier of SCM R by PARTFUN1:def 4
      .= SCM-Memory by SCMRING2:def 1;
    then
A7: SCM-Data-Loc = dom s2 /\ SCM-Data-Loc by XBOOLE_1:28;
    let x be set such that
A8: x in dom p;
A9: x in {IC SCM R} \/ SCM-Data-Loc or x in NAT by A5,A8,XBOOLE_0:def 3;
    per cases by A9,XBOOLE_0:def 3;
    suppose
A10:  x in {IC SCM R};
      not IC SCM R in SCM-Data-Loc
      proof
        assume not thesis;
        then IC SCM R is Data-Location of R by SCMRING2:1;
        hence contradiction by SCMRING3:3;
      end;
      then
A11:  not IC SCM R in dom s3 by A1,A7,RELAT_1:90;
      x = IC SCM R by A10,TARSKI:def 1;
      then s1.x = s.x by A11,FUNCT_4:12;
      hence p.x = s.x by A2,A8,GRFUNC_1:8;
    end;
    suppose
A12:  x in SCM-Data-Loc;
      set DPRp = DataPart Relocated (p, k);
      set DPp = DataPart p;
      x in dom p /\ SCM-Data-Loc by A8,A12,XBOOLE_0:def 4;
      then
A13:  x in dom DPp by A1,RELAT_1:90;
      DPp = DPRp by AMISTD_2:68;
      then DPp c= Relocated (p, k) by RELAT_1:88;
      then
A14:  DPp c= s2 by A3,XBOOLE_1:1;
      then dom DPp c= dom s2 by GRFUNC_1:8;
      then x in dom s2 /\ SCM-Data-Loc by A12,A13,XBOOLE_0:def 4;
      then
A15:  x in dom s3 by A1,RELAT_1:90;
A16:  s2.x = s3.x by A1,A12,FUNCT_1:72;
      DPp c= p by RELAT_1:88;
      then
A17:  DPp.x = p.x by A13,GRFUNC_1:8;
      DPp.x = s2.x by A13,A14,GRFUNC_1:8;
      hence p.x = s.x by A17,A16,A15,FUNCT_4:14;
    end;
    suppose
A18:  x in NAT;
      now
        assume x in dom s3;
        then x in dom s2 /\ SCM-Data-Loc by A1,RELAT_1:90;
        then x in SCM-Data-Loc by XBOOLE_0:def 4;
        hence contradiction by A18,AMI_2:29,XBOOLE_0:3;
      end;
      then s1.x = s.x by FUNCT_4:12;
      hence p.x = s.x by A2,A8,GRFUNC_1:8;
    end;
  end;
  dom p c= dom s by A4,PARTFUN1:def 4;
  hence thesis by A6,GRFUNC_1:8;
end;

theorem Th35:
  R is non trivial implies for p being autonomic FinPartState of
  SCM R st IC SCM R in dom p & p c= s1 & Relocated (p,k) c= s2 & s = s1 +*
  DataPart s2 for i being Element of NAT
   holds IC Comput(ProgramPart(s1),s1,i) + k = IC
  Comput(ProgramPart(s2),s2,i) & IncAddr(CurInstr(ProgramPart Comput(
ProgramPart(s1),s1,i),
  Comput(ProgramPart(s1),s1,i)), k) =
   CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),s2,
i))
    & Comput(ProgramPart(s1),s1,i)|dom (DataPart p) = Comput(ProgramPart(s2),s2
,i)|dom
(DataPart (Relocated (p,k))) & DataPart Comput(ProgramPart(s),s,i) = DataPart
Comput(ProgramPart(s2),s2,i)
proof
  assume
A1: R is non trivial;
  let p be autonomic FinPartState of SCM R such that
A2: IC SCM R in dom p and
A3: p c= s1 and
A4: Relocated (p,k) c= s2 and
A5: s = s1 +* DataPart s2;
  defpred P[Element of NAT] means
   IC Comput(ProgramPart(s1),s1,$1) + k = IC Comput(ProgramPart(
s2),
s2,$1) &
IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,$1),Comput(ProgramPart(
s1),s1,$1)), k) =
CurInstr(ProgramPart Comput(ProgramPart(s2),s2,$1),Comput(ProgramPart(s2),s2,$1
)) &
Comput(ProgramPart(s1),s1,$1)|dom (DataPart p) = Comput(ProgramPart(s2),s2,$1)|
dom (DataPart (
  Relocated (p,k))) & DataPart Comput(ProgramPart(s),s,$1) = DataPart Comput(
ProgramPart(s2),s2,$1);
A6: p is non NAT-defined by A2,COMPOS_1:19;
A7: IC p = IC s1 by A2,A3,GRFUNC_1:8;
  then IC p = IC Comput(ProgramPart(s1),s1,0) by AMI_1:13;
  then
A8: IC p in dom ProgramPart p by A1,A3,A6,Th27;
A9: p c= s by A3,A4,A5,Th34;
A10: for i being Element of NAT st P[i] holds P[i+1 qua Element of NAT]
  proof
    set DPp = DataPart p;
    let i be Element of NAT such that
A11: IC Comput(ProgramPart(s1),s1,i) + k = IC Comput(ProgramPart(s2),s2
,i) and
A12:
IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(s1
),s1,i)), k) =
CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),s2,i))
and
A13: Comput(ProgramPart(s1),s1,i)|dom (DataPart p) = Comput(ProgramPart(s2),s2,
i)|dom (
    DataPart (Relocated (p,k))) and
A14: DataPart Comput(ProgramPart(s),s,i) = DataPart Comput(ProgramPart(s2),s2,i
);
    set Cs2i1 = Comput(ProgramPart(s2),s2,i+1);
    set Cs3i = Comput(ProgramPart(s),s,i);
    set Cs2i = Comput(ProgramPart(s2),s2,i);
A15: Cs2i1 = Following(ProgramPart s2,Cs2i) by AMI_1:14
      .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by AMI_1:123;
A16: now
      let s be State of SCM R, d be Data-Location of R;
      d in SCM-Data-Loc by SCMRING2:1;
      hence d in dom DataPart s by Th9;
    end;
A17: now
      let d be Data-Location of R;
A18:  d in dom DataPart Cs3i by A16;
      hence Cs3i.d = (DataPart Cs3i).d by FUNCT_1:70
        .= Cs2i.d by A14,A18,FUNCT_1:70;
    end;
    set Cs1i1 = Comput(ProgramPart(s1),s1,i+1);
    set Cs1i = Comput(ProgramPart(s1),s1,i);
    dom Cs1i1 = the carrier of SCM R by PARTFUN1:def 4;
    then
A19: dom Cs1i1 = {IC SCM R} \/ SCM-Data-Loc \/ NAT by Th1;
    consider j being natural number such that
A20: IC Cs1i = j;
A21: succ (IC Cs1i + k) = (succ IC Cs1i) + k by A20;
A22: now
      reconsider loc = IC Cs1i1 as Element of NAT;
      assume
A23:  IC Comput(ProgramPart(s1),s1,i+1) + k = IC Comput(ProgramPart(s2)
,s2,i+1);
A24:  loc in dom ProgramPart p by A1,A3,A6,Th27;
      ProgramPart p c= p by RELAT_1:88;
      then
A25:  dom ProgramPart p c= dom p by GRFUNC_1:8;
      then loc + k in dom Relocated(p, k) by A24,AMISTD_2:71;
      then
A26:  Relocated(p, k).(loc + k) = s2.(loc + k) by A4,GRFUNC_1:8
        .= Cs2i1.(loc + k) by AMI_1:54;
Y:  (ProgramPart Cs1i1)/.loc = Cs1i1.loc by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s2),s2,i+1))/.IC Comput(ProgramPart(s2),s2,
i+1)
 = Comput(ProgramPart(s2),s2,i+1).IC Comput(ProgramPart(s2),s2,i+1) by
COMPOS_1:38;
      CurInstr(ProgramPart Cs1i1,Cs1i1) = s1.loc by Y,AMI_1:54
        .= p.loc by A3,A24,A25,GRFUNC_1:8;
      hence
      IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i+1),Comput(
ProgramPart(s1),s1,i+1)), k)
       =
      CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i+1),Comput(ProgramPart(s2
),s2,i+1))
       by A23,A24,A26,Z,AMISTD_2:76;
    end;
    dom Cs2i = the carrier of SCM R by PARTFUN1:def 4;
    then
A27: dom Cs2i = {IC SCM R} \/ SCM-Data-Loc \/ NAT by Th1;
    Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
    then dom DPp = dom p /\ SCM-Data-Loc by RELAT_1:90;
    then
A28: dom DPp c= {IC SCM R} \/ SCM-Data-Loc by XBOOLE_1:10,17;
    set Cs3i1 = Comput(ProgramPart(s),s,i+1);
A29: dom DataPart Cs2i = SCM-Data-Loc by Th9;
A30: dom DataPart Cs3i1 = SCM-Data-Loc by Th9;
    then
A31: dom DataPart Cs3i1 c= dom DataPart Cs2i1 by Th9;
A32: dom DataPart Cs2i1 = SCM-Data-Loc by Th9;
A33: now
      let x be set;
      assume that
A34:  x in dom (DataPart Cs3i1) and
A35:  Cs3i1.x = Cs2i1.x;
      thus (DataPart Cs3i1).x = Cs2i1.x by A34,A35,FUNCT_1:70
        .= (DataPart Cs2i1).x by A30,A32,A34,FUNCT_1:70;
    end;
A36: dom DataPart Cs3i = SCM-Data-Loc by Th9;
A37: now
      let x be set;
      assume that
A38:  x in dom DataPart Cs3i1 and
A39:  Cs3i1.x = Cs3i.x & Cs2i1.x = Cs2i.x;
      (DataPart Cs3i).x = Cs3i.x by A36,A30,A38,FUNCT_1:70;
      hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A14,A29,A30,A33,A38,A39,
FUNCT_1:70;
    end;
    dom Cs1i = the carrier of SCM R by PARTFUN1:def 4;
    then
A40: dom Cs1i = {IC SCM R} \/ SCM-Data-Loc \/ NAT by Th1;
    dom Cs2i1 = the carrier of SCM R by PARTFUN1:def 4;
    then
A41: dom Cs2i1 = {IC SCM R} \/ SCM-Data-Loc \/ NAT by Th1;
    set I = CurInstr(ProgramPart Cs1i,Cs1i);
A42: Cs1i1 = Following(ProgramPart s1,Cs1i) by AMI_1:14
      .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by AMI_1:123;
A43: dom (Cs1i|dom DPp) = dom Cs1i /\ dom DPp by RELAT_1:90
      .= dom DPp by A40,A28,XBOOLE_1:10,28;
A44: dom (Cs1i1|dom DPp) = dom Cs1i1 /\ dom DPp by RELAT_1:90
      .= dom DPp by A19,A28,XBOOLE_1:10,28;
A45: dom DataPart p = dom DataPart(Relocated (p, k)) by AMISTD_2:68;
    then
A46: dom (Cs2i1|dom DataPart(Relocated(p, k))) = dom Cs2i1 /\ dom DPp by
RELAT_1:90
      .= dom DPp by A41,A28,XBOOLE_1:10,28;
    then
A47: dom (Cs1i1|dom DPp)c=dom (Cs2i1|dom DPp) by A44,AMISTD_2:68;
A48: dom (Cs2i|dom DataPart(Relocated(p, k))) = dom Cs2i /\ dom DPp by A45,
RELAT_1:90
      .= dom DPp by A27,A28,XBOOLE_1:10,28;
A49: now
      let x be set, d be Data-Location of R such that
A50:  d = x and
A51:  d in dom DPp and
A52:  Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d;
A53:  (Cs1i|dom DPp).d = Cs1i.d & (Cs2i|dom DPp).d = Cs2i.d by A45,A43,A48,A51,
FUNCT_1:70;
      thus (Cs1i1|dom DPp).x = Cs1i1.d by A44,A50,A51,FUNCT_1:70
        .= (Cs2i1|dom DPp).x by A13,A45,A46,A50,A51,A52,A53,FUNCT_1:70;
    end;
A54: now
      let x be set, d be Data-Location of R such that
A55:  d = x & d in dom DPp and
A56:  Cs1i1.d = Cs2i1.d;
      thus (Cs1i1|dom DPp).x = Cs2i1.d by A44,A55,A56,FUNCT_1:70
        .= (Cs2i1|dom DPp).x by A45,A46,A55,FUNCT_1:70;
    end;
T: ProgramPart s = ProgramPart Cs3i
by AMI_1:123;
A57: Cs3i1 = Following(ProgramPart s,Cs3i) by AMI_1:14
      .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs3i) by A1,A3,A6,A9,Th28,T;
    per cases by NAT_1:32,SCMRING3:71;
    suppose
      InsCode I = 0;
      then
A58:  I = halt SCM R by SCMRING3:16;
      hence IC Comput(ProgramPart(s1),s1,i+1) + k
       = IC Cs1i + k by A42,AMI_1:def 8
        .= IC Comput(ProgramPart(s2),s2,i+1) by A11,A12,A15,A58,AMI_1:def 8;
      hence
      IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i+1),Comput(
ProgramPart(s1),s1,i+1)), k)
       = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i+1),Comput(ProgramPart
(s2),s2,i+1)) by A22;
A59:  Cs2i1 = Cs2i by A12,A15,A58,AMI_1:def 8;
      hence Comput(ProgramPart(s1),s1,i+1)|dom (DataPart p) = Comput(
ProgramPart(s2),s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A13,A42,A58,AMI_1:def 8;
      thus thesis by A14,A57,A58,A59,AMI_1:def 8;
    end;
    suppose
      InsCode I = 1;
      then consider da, db being Data-Location of R such that
A60:  I = da := db by SCMRING3:17;
A61:  IncAddr(I, k) = da := db by A60,AMISTD_2:29;
A62:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A60,SCMRING2:13;
      hence
      IC Comput(ProgramPart(s1),s1,i+1) + k = IC Comput(ProgramPart(s2)
,s2,i+1)
      by A11,A12,A42,A15,A21,A61,SCMRING2:13;
      thus IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i+1),
      Comput(ProgramPart(s1),s1,i+1)), k) = CurInstr(ProgramPart Comput(
ProgramPart(s2),s2,i+1),
      Comput(ProgramPart(s2),s2,i+1))
       by A11,A12,A22,A42,A15,A21,A61,A62,SCMRING2:13;
A63:  Cs3i.db = Cs2i.db by A17;
      now
        DPp c= p by RELAT_1:88;
        then
A64:    dom DPp c= dom p by GRFUNC_1:8;
        let x be set;
        assume
A65:    x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by Th13;
        then reconsider d = x as Data-Location of R by A44,A65,SCMRING2:1;
        per cases;
        suppose
A66:      da = d;
          then Cs1i1.d = Cs1i.db & Cs2i1.d = Cs2i.db by A12,A42,A15,A60,A61,
SCMRING2:13;
          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A1,A3,A6,A9,A44,A54,A60,A63
,A65,A64,A66,Th29;
        end;
        suppose
          da <> d;
          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A42,A15,A60,A61,
SCMRING2:13;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A44,A49,A65;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A47,GRFUNC_1:8;
      hence Comput(ProgramPart(s1),s1,i+1)|dom (DataPart p) = Comput(
ProgramPart(s2),s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A45,A44,A46,GRFUNC_1:9;
      now
        let x be set;
        assume
A67:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A30,SCMRING2:1;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = Cs2i.db & Cs3i1.d=Cs3i.db by A12,A15,A57,A60,A61,
SCMRING2:13;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A17,A33,A67;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A57,A60,A61,
SCMRING2:13;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A37,A67;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(ProgramPart(s2),s2,i+1) by A31,
GRFUNC_1:8;
      hence thesis by A30,A32,GRFUNC_1:9;
    end;
    suppose
      InsCode I = 2;
      then consider da, db being Data-Location of R such that
A68:  I = AddTo(da, db) by SCMRING3:18;
A69:  IncAddr(I, k) = AddTo(da, db) by A68,AMISTD_2:29;
A70:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A68,SCMRING2:14;
      hence
      IC Comput(ProgramPart(s1),s1,i+1) + k = IC Comput(ProgramPart(s2)
,s2,i+1)
      by A11,A12,A42,A15,A21,A69,SCMRING2:14;
      thus IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i+1),
      Comput(ProgramPart(s1),s1,i+1)), k) = CurInstr(ProgramPart Comput(
ProgramPart(s2),s2,i+1),
      Comput(ProgramPart(s2),s2,i+1))
       by A11,A12,A22,A42,A15,A21,A69,A70,SCMRING2:14;
A71:  Cs3i.da = Cs2i.da & Cs3i.db = Cs2i.db by A17;
      now
        DPp c= p by RELAT_1:88;
        then
A72:    dom DPp c= dom p by GRFUNC_1:8;
        let x be set such that
A73:    x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by Th13;
        then reconsider d = x as Data-Location of R by A44,A73,SCMRING2:1;
        per cases;
        suppose
A74:      da = d;
          then Cs1i1.d = Cs1i.da + Cs1i.db & Cs2i1.d = Cs2i.da + Cs2i.db by A12
,A42,A15,A68,A69,SCMRING2:14;
          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A1,A3,A6,A9,A44,A54,A68,A71
,A73,A72,A74,Th30;
        end;
        suppose
          da <> d;
          then Cs1i1.d=Cs1i.d & Cs2i1.d = Cs2i.d by A12,A42,A15,A68,A69,
SCMRING2:14;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A44,A49,A73;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A47,GRFUNC_1:8;
      hence Comput(ProgramPart(s1),s1,i+1)|dom (DataPart p) = Comput(
ProgramPart(s2),s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A45,A44,A46,GRFUNC_1:9;
      now
        let x be set;
        assume
A75:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A30,SCMRING2:1;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = Cs2i.da + Cs2i.db & Cs3i1.d = Cs3i.da + Cs3i.db by A12
,A15,A57,A68,A69,SCMRING2:14;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A33,A71,A75;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A57,A68,A69,
SCMRING2:14;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A37,A75;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(ProgramPart(s2),s2,i+1) by A31,
GRFUNC_1:8;
      hence thesis by A30,A32,GRFUNC_1:9;
    end;
    suppose
      InsCode I = 3;
      then consider da, db being Data-Location of R such that
A76:  I = SubFrom(da, db) by SCMRING3:19;
A77:  IncAddr(I, k) = SubFrom(da, db) by A76,AMISTD_2:29;
A78:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A76,SCMRING2:15;
      hence
      IC Comput(ProgramPart(s1),s1,i+1) + k = IC Comput(ProgramPart(s2)
,s2,i+1)
      by A11,A12,A42,A15,A21,A77,SCMRING2:15;
      thus IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i+1),
      Comput(ProgramPart(s1),s1,i+1)), k) = CurInstr(ProgramPart Comput(
ProgramPart(s2),s2,i+1),
      Comput(ProgramPart(s2),s2,i+1))
      by A11,A12,A22,A42,A15,A21,A77,A78,SCMRING2:15;
A79:  Cs3i.da = Cs2i.da & Cs3i.db = Cs2i.db by A17;
      now
        DPp c= p by RELAT_1:88;
        then
A80:    dom DPp c= dom p by GRFUNC_1:8;
        let x be set such that
A81:    x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by Th13;
        then reconsider d = x as Data-Location of R by A44,A81,SCMRING2:1;
        per cases;
        suppose
A82:      da = d;
          then Cs1i1.d = Cs1i.da - Cs1i.db & Cs2i1.d = Cs2i.da - Cs2i.db by A12
,A42,A15,A76,A77,SCMRING2:15;
          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A1,A3,A6,A9,A44,A54,A76,A79
,A81,A80,A82,Th31;
        end;
        suppose
          da <> d;
          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A42,A15,A76,A77,
SCMRING2:15;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A44,A49,A81;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A47,GRFUNC_1:8;
      hence Comput(ProgramPart(s1),s1,i+1)|dom (DataPart p) = Comput(
ProgramPart(s2),s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A45,A44,A46,GRFUNC_1:9;
      now
        let x be set;
        assume
A83:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A30,SCMRING2:1;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = Cs2i.da - Cs2i.db & Cs3i1.d = Cs3i.da - Cs3i.db by A12
,A15,A57,A76,A77,SCMRING2:15;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A33,A79,A83;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A57,A76,A77,
SCMRING2:15;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A37,A83;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(ProgramPart(s2),s2,i+1) by A31,
GRFUNC_1:8;
      hence thesis by A30,A32,GRFUNC_1:9;
    end;
    suppose
      InsCode I = 4;
      then consider da, db being Data-Location of R such that
A84:  I = MultBy(da, db) by SCMRING3:20;
A85:  IncAddr(I, k) = MultBy(da, db) by A84,AMISTD_2:29;
A86:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A84,SCMRING2:16;
      hence
      IC Comput(ProgramPart(s1),s1,i+1) + k = IC Comput(ProgramPart(s2)
,s2,i+1)
      by A11,A12,A42,A15,A21,A85,SCMRING2:16;
      thus IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i+1),
      Comput(ProgramPart(s1),s1,i+1)), k) = CurInstr(ProgramPart Comput(
ProgramPart(s2),s2,i+1),
      Comput(ProgramPart(s2),s2,i+1))
      by A11,A12,A22,A42,A15,A21,A85,A86,SCMRING2:16;
A87:  Cs3i.da = Cs2i.da & Cs3i.db = Cs2i.db by A17;
      now
        DPp c= p by RELAT_1:88;
        then
A88:    dom DPp c= dom p by GRFUNC_1:8;
        let x be set such that
A89:    x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by Th13;
        then reconsider d = x as Data-Location of R by A44,A89,SCMRING2:1;
        per cases;
        suppose
A90:      da = d;
          then Cs1i1.d = Cs1i.da * Cs1i.db & Cs2i1.d = Cs2i.da * Cs2i.db by A12
,A42,A15,A84,A85,SCMRING2:16;
          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A1,A3,A6,A9,A44,A54,A84,A87
,A89,A88,A90,Th32;
        end;
        suppose
          da <> d;
          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A42,A15,A84,A85,
SCMRING2:16;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A44,A49,A89;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A47,GRFUNC_1:8;
      hence Comput(ProgramPart(s1),s1,i+1)|dom (DataPart p) = Comput(
ProgramPart(s2),s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A45,A44,A46,GRFUNC_1:9;
      now
        let x be set;
        assume
A91:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A30,SCMRING2:1;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = Cs2i.da * Cs2i.db & Cs3i1.d = Cs3i.da * Cs3i.db by A12
,A15,A57,A84,A85,SCMRING2:16;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A33,A87,A91;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A57,A84,A85,
SCMRING2:16;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A37,A91;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(ProgramPart(s2),s2,i+1) by A31,
GRFUNC_1:8;
      hence thesis by A30,A32,GRFUNC_1:9;
    end;
    suppose
      InsCode I = 5;
      then consider
      da being Data-Location of R, r being Element of R such that
A92:  I = da:=r by SCMRING3:21;
A93:  IncAddr(I, k) = da := r by A92,AMISTD_2:29;
A94:  Exec(I, Cs1i).IC SCM R = succ IC Cs1i by A92,SCMRING2:19;
      hence
      IC Comput(ProgramPart(s1),s1,i+1) + k = IC Comput(ProgramPart(s2)
,s2,i+1)
      by A11,A12,A42,A15,A21,A93,SCMRING2:19;
      thus IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i+1),
      Comput(ProgramPart(s1),s1,i+1)), k) = CurInstr(ProgramPart Comput(
ProgramPart(s2),s2,i+1),
      Comput(ProgramPart(s2),s2,i+1))
      by A11,A12,A22,A42,A15,A21,A93,A94,SCMRING2:19;
      now
        let x be set;
        assume
A95:    x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by Th13;
        then reconsider d = x as Data-Location of R by A44,A95,SCMRING2:1;
        per cases;
        suppose
A96:      da = d;
          thus (Cs1i1|dom DPp).x = Cs1i1.d by A44,A95,FUNCT_1:72
            .= r by A42,A92,A96,SCMRING2:19
            .= Cs2i1.d by A12,A15,A93,A96,SCMRING2:19
            .= (Cs2i1|dom DPp).x by A44,A95,FUNCT_1:72;
        end;
        suppose
          da <> d;
          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A42,A15,A92,A93,
SCMRING2:19;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A44,A49,A95;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A47,GRFUNC_1:8;
      hence Comput(ProgramPart(s1),s1,i+1)|dom (DataPart p) = Comput(
ProgramPart(s2),s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A45,A44,A46,GRFUNC_1:9;
      now
        let x be set;
        assume
A97:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A30,SCMRING2:1;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = r & Cs3i1.d = r by A12,A15,A57,A92,A93,SCMRING2:19;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A33,A97;
        end;
        suppose
          da <> d;
          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A15,A57,A92,A93,
SCMRING2:19;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A37,A97;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(ProgramPart(s2),s2,i+1) by A31,
GRFUNC_1:8;
      hence thesis by A30,A32,GRFUNC_1:9;
    end;
    suppose
      InsCode I = 6;
      then consider loc being Element of NAT such that
A98:  I = goto(loc,R) by SCMRING3:22;
A99:  CurInstr(ProgramPart Cs2i,Cs2i) = goto (loc + k,R)
by A12,A98,SCMRING3:69;
      thus IC Comput(ProgramPart(s1),s1,i+1) + k = loc + k
       by A42,A98,SCMRING2:17
        .= IC Comput(ProgramPart(s2),s2,i+1) by A15,A99,SCMRING2:17;
      hence
      IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i+1),
      Comput(ProgramPart(s1),s1,i+1)), k) = CurInstr(ProgramPart Comput(
ProgramPart(s2),s2,i+1),
      Comput(ProgramPart(s2),s2,i+1)) by A22;
      now
        let x be set such that
A100:   x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by Th13;
        then reconsider d = x as Data-Location of R by A44,A100,SCMRING2:1;
        Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A42,A15,A98,A99,SCMRING2:17;
        hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A44,A49,A100;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A47,GRFUNC_1:8;
      hence Comput(ProgramPart(s1),s1,i+1)|dom (DataPart p) = Comput(
ProgramPart(s2),s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A45,A44,A46,GRFUNC_1:9;
      now
        let x be set;
        assume
A101:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A30,SCMRING2:1;
        Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A15,A57,A98,A99,SCMRING2:17;
        hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A37,A101;
      end;
      then DataPart Cs3i1 c= DataPart Comput(ProgramPart(s2),s2,i+1) by A31,
GRFUNC_1:8;
      hence thesis by A30,A32,GRFUNC_1:9;
    end;
    suppose
      InsCode I = 7;
      then consider
      da being Data-Location of R, loc being Element of NAT
      such that
A102: I = da=0_goto loc by SCMRING3:23;
A103: now
        per cases;
        case
          Cs1i.da = 0.R;
          hence IC Comput(ProgramPart(s1),s1,i+1) + k = loc + k by A42,A102,
SCMRING2:18;
        end;
        case
          Cs1i.da <> 0.R;
          hence
          IC Comput(ProgramPart(s1),s1,i+1) + k = succ (IC Cs2i)
          by A11,A42,A21,A102,SCMRING2:18;
        end;
      end;
A104: CurInstr(ProgramPart Cs2i,Cs2i)
 = da=0_goto (loc + k) by A12,A102,SCMRING3:70;
A105: now
        per cases;
        case
          Cs2i.da = 0.R;
          hence IC Comput(ProgramPart(s2),s2,i+1) = loc + k
          by A15,A104,SCMRING2:18;
        end;
        case
          Cs2i.da <> 0.R;
          hence IC Comput(ProgramPart(s2),s2,i+1) = succ IC Cs2i by A15,A104,
SCMRING2:18;
        end;
      end;
A106: Cs3i.da = Cs2i.da by A17;
      now
        per cases;
        suppose
          loc <> succ IC Cs1i;
          hence IC Comput(ProgramPart(s1),s1,i+1) + k = IC Comput(
ProgramPart(s2),s2,i+1)
          by A1,A3,A6,A9,A102,A106,A103,A105,Th33;
        end;
        suppose
          loc = succ IC Cs1i;
          hence
          IC Comput(ProgramPart(s1),s1,i+1) + k = IC Comput(ProgramPart
(s2),s2,i+1)
          by A11,A103,A105;
        end;
      end;
      hence IC Comput(ProgramPart(s1),s1,i+1) + k = IC Comput(
ProgramPart(s2),s2,i+1) &
      IncAddr(
      CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i+1),Comput(ProgramPart(s1
),s1,i+1)), k) =
      CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i+1),Comput(ProgramPart(s2
),s2,i+1))
       by A22;
      now
        let x be set such that
A107:   x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by Th13;
        then reconsider d = x as Data-Location of R by A44,A107,SCMRING2:1;
        Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A42,A15,A102,A104,SCMRING2:18;
        hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A44,A49,A107;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A47,GRFUNC_1:8;
      hence Comput(ProgramPart(s1),s1,i+1)|dom (DataPart p) = Comput(
ProgramPart(s2),s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A45,A44,A46,GRFUNC_1:9;
      now
        let x be set;
        assume
A108:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location of R by A30,SCMRING2:1;
        Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A15,A57,A102,A104,SCMRING2:18;
        hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A37,A108;
      end;
      then DataPart Cs3i1 c= DataPart Comput(ProgramPart(s2),s2,i+1) by A31,
GRFUNC_1:8;
      hence thesis by A30,A32,GRFUNC_1:9;
    end;
  end;
Comput(ProgramPart(s1),s1,0) = s1 by AMI_1:13;then
A109: IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,0),Comput(
ProgramPart(s1),s1,0)), k) = IncAddr(s1.IC s1, k) by COMPOS_1:38;
A110: DataPart (Relocated(p,k)) c= Relocated(p,k) by RELAT_1:88;
A111: DataPart p c= p by RELAT_1:88;
A112: DataPart p = DataPart (Relocated (p,k)) by AMISTD_2:68;
A113: Comput(ProgramPart(s1),s1,0)|dom (DataPart p) = s1 | dom (DataPart p) by
AMI_1:13
    .= DataPart p by A3,A111,GRFUNC_1:64,XBOOLE_1:1
    .= s2 | dom (DataPart p) by A4,A112,A110,GRFUNC_1:64,XBOOLE_1:1
    .= Comput(ProgramPart(s2),s2,0)|dom (DataPart (Relocated (p,k))) by A112,
AMI_1:13;
A114: DataPart Comput(ProgramPart(s),s,0) = DataPart(s1 +* DataPart s2) by A5,
AMI_1:13
    .= DataPart s2 by PBOOLE:157
    .= DataPart Comput(ProgramPart(s2),s2,0) by AMI_1:13;
A115: IC SCM R in dom Relocated(p,k) by AMISTD_2:72;
A116: IC Comput(ProgramPart(s1),s1,0) + k = IC s1 + k by AMI_1:13
    .= IC p + k by A2,A3,GRFUNC_1:8
    .= IC Relocated(p,k) by A2,AMISTD_2:73
    .= IC s2 by A4,A115,GRFUNC_1:8
    .= IC Comput(ProgramPart(s2),s2,0) by AMI_1:13;
A117: IC SCM R in dom Relocated (p, k) by AMISTD_2:72;
  ProgramPart p c= p by RELAT_1:88;
  then
A118: dom ProgramPart p c= dom p by GRFUNC_1:8;
  then
A119: (IC p) + k in dom Relocated(p,k) by A8,AMISTD_2:71;
Y:  (ProgramPart s2)/.IC Relocated (p, k) = s2.IC Relocated (p, k)
 by COMPOS_1:38;
 Comput(ProgramPart(s2),s2,0) = s2 by AMI_1:13;
 then
A120: CurInstr(ProgramPart Comput(ProgramPart(s2),s2,0),Comput(ProgramPart(s2),
s2,0))
     = s2.(IC Relocated (p, k)) by A4,A117,Y,GRFUNC_1:8
    .= s2.((IC p) + k) by A2,AMISTD_2:73
    .= (Relocated(p,k)).((IC p) + k) by A4,A119,GRFUNC_1:8;
  p.IC p = s1.IC s1 by A3,A7,A8,A118,GRFUNC_1:8;
  then
A121: P[0 qua Element of NAT] by A116,A8,A109,A120,A113,A114,AMISTD_2:76;
  for n holds P[n] from NAT_1:sch 1(A121,A10);
  hence thesis;
end;

theorem Th36:
  R is non trivial implies for p being autonomic FinPartState of
  SCM R st IC SCM R in dom p holds p is halting iff Relocated (p,k) is halting
proof
  assume
A1: R is non trivial;
  let p be autonomic FinPartState of SCM R;
  assume
A2: IC SCM R in dom p;
  hereby
    assume
A3: p is halting;
    thus Relocated(p,k) is halting
    proof
      let t be State of SCM R;
      assume
A4:   Relocated(p,k) c= t;
      set s = t +* p;
      reconsider s3 = s +* DataPart t as State of SCM R;
A5:   p c= s by FUNCT_4:26;
      then ProgramPart s halts_on s by A3,AMI_1:def 26;
      then consider u being Element of NAT such that
A6:   CurInstr(ProgramPart s,Comput(ProgramPart(s),s,u)) = halt SCM R
by AMI_1:146;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,u)
by AMI_1:123;
      take u;
     IC Comput(ProgramPart(t),t,u) in NAT;
    hence IC Comput(ProgramPart(t),t,u) in dom ProgramPart t by COMPOS_1:34;
NX: ProgramPart t = ProgramPart Comput(ProgramPart(t),t,u)
by AMI_1:123;
      s3 = s3;
      then CurInstr(ProgramPart (t),Comput(ProgramPart(t),t,u))
       = IncAddr(halt SCM R, k) by A1,A2,A4,A5,A6,Th35,TX,NX
        .= halt SCM R by AMISTD_2:29;
      hence thesis;
    end;
  end;
  assume
A7: Relocated (p,k) is halting;
  let t be State of SCM R;
  reconsider s = t +* Relocated(p, k) as State of SCM R;
A8: Relocated (p,k) c= t +* Relocated (p,k) by FUNCT_4:26;
  then ProgramPart s halts_on s by A7,AMI_1:def 26;
  then consider u being Element of NAT such that
A9: CurInstr(ProgramPart s,Comput(ProgramPart(s),s,u)) = halt SCM R
by AMI_1:146;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,u)
by AMI_1:123;
  reconsider s3 = t +* DataPart s as State of SCM R;
  assume
A10: p c= t;
  take u;
     IC Comput(ProgramPart(t),t,u) in NAT;
    hence IC Comput(ProgramPart(t),t,u) in dom ProgramPart t by COMPOS_1:34;
NX: ProgramPart t = ProgramPart Comput(ProgramPart(t),t,u)
by AMI_1:123;
  s3 = s3;
  then IncAddr(CurInstr(ProgramPart Comput(ProgramPart(t),t,u),Comput(
ProgramPart(t),t,u)), k)
   = halt SCM R by A1,A2,A10,A8,A9,Th35,TX;
  hence thesis by NX,AMISTD_2:35;
end;

theorem
  R is non trivial implies for p being autonomic FinPartState of SCM R
st IC SCM R in dom p & p c= s for i being Element of NAT holds Comput(
ProgramPart(s+*
  Relocated(p,k)),s+*
  Relocated(p,k),i) = Comput(ProgramPart(s),s,i) +*
  Start-At(IC Comput(ProgramPart(s),s,i) +k,SCM R) +*
  ProgramPart (Relocated (p,k))
proof
  assume
A1: R is non trivial;
  let p being autonomic FinPartState of SCM R such that
A2: IC SCM R in dom p and
A3: p c= s;
A4: IC p = IC s by A2,A3,GRFUNC_1:8;
  defpred P[Element of NAT] means Comput(ProgramPart(s+*Relocated(p,k)),s+*
Relocated(p,k),$1) =
  Comput(ProgramPart(s),s,$1) +* Start-At(IC Comput(ProgramPart(s),s,$1)
   +k,SCM R)
   +* ProgramPart (
  Relocated (p,k));
A5: for i being Element of NAT st P[i] holds P[i+1 qua Element of NAT]
  proof
    let i be Element of NAT such that
A6: Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i) = Comput(
ProgramPart(s),s,i) +* Start-At (
    IC Comput(ProgramPart(s),s,i) + k,SCM R) +* ProgramPart (Relocated
(p,k));
    reconsider ii = IC Comput(ProgramPart(s),s,i) as Element of NAT;
    dom (Start-At(IC Comput(ProgramPart(s),s,i) +k,SCM R)) = {IC SCM R}
    by FUNCOP_1:19;
    then
A7: IC SCM R in dom (Start-At(IC Comput(ProgramPart(s),s,i) +k,SCM R))
by TARSKI:def 1;
    not IC SCM R in dom ProgramPart(Relocated (p,k)) by COMPOS_1:12;
    then
A8: IC (Comput(ProgramPart(s),s,i) +*
 Start-At(IC Comput(ProgramPart(s),s,i) +k,SCM R) +*
ProgramPart Relocated (p,k)) = (Comput(ProgramPart(s),s,i) +* Start-At (IC
Comput(ProgramPart(s
    ),s
    ,i) + k,SCM R)).IC SCM R by FUNCT_4:12
      .= (Start-At(IC Comput(ProgramPart(s),s,i) +k,SCM R)).IC SCM R
      by A7,FUNCT_4:14
      .= IC Comput(ProgramPart(s),s,i) + k by FUNCOP_1:87;
A9: ProgramPart p c= Comput(ProgramPart(s),s,i) by A3,AMI_1:99;
    p is not NAT-defined by A2,COMPOS_1:19;
    then
A10: IC Comput(ProgramPart(s),s,i) in dom ProgramPart(p) by A1,A3,Th27;
    then
A11: IC Comput(ProgramPart(s),s,i) in dom IncAddr(ProgramPart p,k) by
AMISTD_2:def 15;
A12: (ProgramPart p)/.ii = (ProgramPart p).ii by A10,PARTFUN1:def 8
      .= (Comput(ProgramPart(s),s,i)).IC Comput(ProgramPart(s),s,i) by A10,A9,
GRFUNC_1:8;
Y:  (ProgramPart Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i))/.
      IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i)
 = Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i).
 IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i) by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,i))/.IC Comput(ProgramPart(s),s,i)
 = Comput(ProgramPart(s),s,i).IC Comput(ProgramPart(s),s,i) by COMPOS_1:38;
    ProgramPart p c= p by RELAT_1:88;
    then dom ProgramPart p c= dom p by GRFUNC_1:8;
    then (IC Comput(ProgramPart(s),s,i) + k) in dom (Relocated (p,k))
    by A10,AMISTD_2:71;
    then (IC Comput(ProgramPart(s),s,i) + k) in dom (ProgramPart
    (Relocated (p,k))) by COMPOS_1:16;
    then
A13: CurInstr(ProgramPart Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,
k),i),
Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i))
= (ProgramPart (Relocated
    (p,k))).(IC Comput(ProgramPart(s),s,i) + k) by A6,A8,Y,FUNCT_4:14
      .= IncAddr(Shift(ProgramPart p,k),k).
      (IC Comput(ProgramPart(s),s,i) + k)
by AMISTD_2:69
      .= Shift(IncAddr(ProgramPart p,k),k).
         (IC Comput(ProgramPart(s),s,i) + k)
by AMISTD_2:75
      .= IncAddr(ProgramPart p,k).(IC Comput(ProgramPart(s),s,i)) by A11,
VALUED_1:def 12
      .= IncAddr (CurInstr(ProgramPart Comput(ProgramPart(s),s,i),Comput(
ProgramPart(s),s,i)),k)
      by A10,A12,Z,AMISTD_2:def 15;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s)
,s,i)
by AMI_1:123;
A14: Comput(ProgramPart(s),s,i+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,i)) by AMI_1:14;
S: ProgramPart (s+*Relocated(p,k)) =
ProgramPart Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated
(p,k),i)
by AMI_1:123;
    thus Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i+1)
     = Following(ProgramPart (s+*Relocated(p,k)),
     Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i)) by AMI_1:14
      .= Exec(IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s),s,i),
      Comput(ProgramPart(s),s,i)),k), Comput(ProgramPart(s),s,i) +*
Start-At(IC Comput(ProgramPart(s),s,i) +k,SCM R)) +*
 ProgramPart (Relocated (p,k))
 by A6,A13,S,AMISTD_2:67
      .= Comput(ProgramPart(s),s,i+1) +*
       Start-At (IC Comput(ProgramPart(s),s,i+1) + k,SCM R) +*
    ProgramPart (Relocated (p,k)) by A14,Th22,T;
  end;
A15: Comput(ProgramPart(s),s,0) = s by AMI_1:13;
  DataPart p c= p by RELAT_1:88;
  then
A18: DataPart p c= s by A3,XBOOLE_1:1;
  Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),0)
    = s +* (IncrIC(NPP p,k) +* Reloc(ProgramPart p,k)) by AMI_1:13
   .= s +* (IncrIC(NPP p,k) +* ProgramPart Relocated(p,k)) by AMISTD_2:69
   .= s +* (DataPart p +* Start-At ((IC p) +k,SCM R) +*
         ProgramPart Relocated(p,k)) by A2,COMPOS_1:75
   .= s +* (DataPart p +* (Start-At ((IC p) +k,SCM R) +*
         ProgramPart Relocated(p,k))) by FUNCT_4:15
   .= s +* DataPart p +* (Start-At ((IC p) +k,SCM R) +*
         ProgramPart Relocated(p,k)) by FUNCT_4:15
    .= s +* DataPart p +* Start-At ((IC p) +k,SCM R) +*
       ProgramPart (Relocated (p,k)) by FUNCT_4:15
    .= Comput(ProgramPart(s),s,0) +* Start-At(IC Comput(ProgramPart(s),s,0) +k,
SCM R)
     +* ProgramPart
  (Relocated(p,k)) by A18,A4,A15,FUNCT_4:79;
  then
A19: P[0 qua Element of NAT];
  for n holds P[n] from NAT_1:sch 1 (A19,A5);
  hence thesis;
end;

theorem Th38:
  R is non trivial implies for p being autonomic FinPartState of
  SCM R st IC SCM R in dom p & Relocated(p,k) c= s holds for i being Element of
NAT holds Comput(ProgramPart(s),s,i) = Comput(ProgramPart(s+*p),s+*p,i) +*
Start-At (IC Comput(ProgramPart(s
  +*p),s
  +*p,i) + k,SCM R) +* s|dom ProgramPart p
   +* ProgramPart (Relocated (p,k))
proof
  assume
A1: R is non trivial;
  let p be autonomic FinPartState of SCM R such that
A2: IC SCM R in dom p and
A3: Relocated (p,k) c= s;
A4: Start-At(IC p +k,SCM R) c= Relocated (p,k) by A2,AMISTD_2:77;
  defpred P[Element of NAT] means Comput(ProgramPart(s),s,$1) = Comput(
ProgramPart(s+*p),s+*p,$1) +*
Start-At (IC Comput(ProgramPart(s+*p),s+*p,$1) + k,SCM R) +* s|dom
ProgramPart p +*
ProgramPart (
  Relocated (p,k));
A5: for i being Element of NAT st P[i] holds P[i+1 qua Element of NAT]
  proof
    set sdom = s|dom ProgramPart p;
    let i be Element of NAT such that
A6: Comput(ProgramPart(s),s,i) = Comput(ProgramPart(s+*p),s+*p,i) +* Start-At (
IC
Comput(ProgramPart(s+*p),s+*p,i) + k,SCM R) +* s|dom ProgramPart p+*
ProgramPart (Relocated (p,k))
    ;
    dom ProgramPart p c= the carrier of SCM R by RELAT_1:def 18;
    then dom ProgramPart p c= dom s by PARTFUN1:def 4;
    then
A7: dom ProgramPart p = dom (s|dom ProgramPart p) by RELAT_1:91;
    reconsider sdom as FinPartState of SCM R;
    dom (s|dom ProgramPart p) c= NAT by A7,RELAT_1:87;
    then reconsider sdom as NAT-defined FinPartState of SCM R by RELAT_1:def 18
    ;
    reconsider ii = IC Comput(ProgramPart(s+*p),s+*p,i) as Element of NAT;
A8: ProgramPart p c= Comput(ProgramPart(s+*p),s+*p,i) by AMI_1:99,FUNCT_4:26;
    dom (Start-At (IC Comput(ProgramPart(s+*p),s+*p,i) + k,SCM R)) = {
IC SCM R}
    by FUNCOP_1:19;
    then
A9: IC SCM R in dom (Start-At (IC Comput(ProgramPart(s+*p),s+*p,i) + k,
SCM R))
by TARSKI:def 1;
    dom sdom = dom s /\ dom ProgramPart p & not IC SCM R in dom
    ProgramPart p by COMPOS_1:12,RELAT_1:90;
    then
A10: not IC SCM R in dom sdom by XBOOLE_0:def 4;
    p is not NAT-defined by A2,COMPOS_1:19;
    then
A11: IC Comput(ProgramPart(s+*p),s+*p,i) in dom ProgramPart p by A1,Th27,
FUNCT_4:26;
    then
A12: IC Comput(ProgramPart(s+*p),s+*p,i) in dom IncAddr(ProgramPart p,k) by
AMISTD_2:def 15;
    ProgramPart p c= p by RELAT_1:88;
    then dom ProgramPart p c= dom p by GRFUNC_1:8;
    then (IC Comput(ProgramPart(s+*p),s+*p,i) + k) in dom (Relocated (p
,k)) by A11,AMISTD_2:71;
    then
A13: (IC Comput(ProgramPart(s+*p),s+*p,i) + k)
in dom (ProgramPart (Relocated (p,k)))
    by COMPOS_1:16;
A14: (ProgramPart p)/.ii = (ProgramPart p).IC Comput(ProgramPart(s+*p),s+*p,i)
by A11,PARTFUN1:def 8
      .= ( Comput(ProgramPart(s+*p),s+*p,i)).IC Comput(ProgramPart(s+*p),s+*p,i
) by A11,A8,GRFUNC_1:8;
Y:  (ProgramPart Comput(ProgramPart(s),s,i))/.IC Comput(ProgramPart(s),s,i)
 = Comput(ProgramPart(s),s,i).IC Comput(ProgramPart(s),s,i) by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s+*p),s+*p,i))/.IC Comput(ProgramPart(s+*p)
,s+*p,i)
 = Comput(ProgramPart(s+*p),s+*p,i).IC Comput(ProgramPart(s+*p),s+*p,i) by
COMPOS_1:38;
    not IC SCM R in dom ProgramPart(Relocated (p,k)) by COMPOS_1:12;
    then IC ( Comput(ProgramPart(s+*p),s+*p,i) +*
    Start-At (IC Comput(ProgramPart(s+*p),s+*p,i) + k,SCM R) +*
sdom +* ProgramPart Relocated (p,k)) = ( Comput(ProgramPart(s+*p),s+*p,i) +*
Start-At (IC
    Comput(ProgramPart(s+*p),s+*p,i) + k,SCM R) +* sdom).IC SCM R by FUNCT_4:12
      .= ( Comput(ProgramPart(s+*p),s+*p,i) +*
      Start-At (IC Comput(ProgramPart(s+*p),s+*p,i) + k,SCM R)).IC
    SCM R by A10,FUNCT_4:12
      .= (Start-At (IC Comput(ProgramPart(s+*p),s+*p,i) + k,SCM R)).IC
SCM R
      by A9,FUNCT_4:14
      .= IC Comput(ProgramPart(s+*p),s+*p,i) + k by FUNCOP_1:87;
    then
A15: CurInstr(ProgramPart Comput(ProgramPart(s),s,i),Comput(ProgramPart(s),s,i)
)
 = (ProgramPart (Relocated (p,k))).(IC
    Comput(ProgramPart(s+*p),s+*p,i) + k) by A6,A13,Y,FUNCT_4:14
      .= IncAddr(Shift(ProgramPart p,k),k).(IC Comput(ProgramPart(s+*p),s+*p,i)
+ k)
      by AMISTD_2:69
      .= Shift(IncAddr(ProgramPart p,k),k).(IC Comput(ProgramPart(s+*p),s+*p,i)
+ k)
      by AMISTD_2:75
      .= IncAddr(ProgramPart p,k).(IC Comput(ProgramPart(s+*p),s+*p,i)) by A12,
VALUED_1:def 12
      .= IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s+*p),s+*p,i),
      Comput(ProgramPart(s+*p),s+*p,i)),k) by A11,A14,Z,AMISTD_2:def 15;
T: ProgramPart(s+*p) = ProgramPart Comput(ProgramPart(s+*p),s+*p,i)
by AMI_1:123;
A16: Comput(ProgramPart(s+*p),s+*p,i+1)
 = Following(ProgramPart(s+*p) ,Comput(ProgramPart(s
+*p),s+*p,i))
 by AMI_1:14;
S: ProgramPart s = ProgramPart Comput(
ProgramPart(s),s,i)
by AMI_1:123;
    thus Comput(ProgramPart(s),s,i+1) = Following(ProgramPart s,
    Comput(ProgramPart(s),s,i)) by AMI_1:14
      .= Exec(IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s+*p),s+*p,i),
      Comput(ProgramPart(s+*p),s+*p,i)),k), ( Comput(ProgramPart(s+*p
    ),s+*p
    ,i)) +* Start-At (IC ( Comput(ProgramPart(s+*p),s+*p,i)) + k,SCM R)
+* sdom ) +*
    ProgramPart
    Relocated (p,k) by A6,A15,S,AMISTD_2:67
      .= Exec(IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s+*p),s+*p,i),
      Comput(ProgramPart(s+*p),s+*p,i)),k), ( Comput(ProgramPart(s+*p
    ),s+*p
    ,i)) +* Start-At (IC ( Comput(ProgramPart(s+*p),s+*p,i)) + k,SCM R)
) +* sdom +*
    ProgramPart (
    Relocated (p,k)) by AMISTD_2:67
      .= Comput(ProgramPart(s+*p),s+*p,i+1) +*
      Start-At (IC Comput(ProgramPart(s+*p),s+*p,i+1) + k,SCM R) +*
    s|dom ProgramPart p +* ProgramPart (Relocated (p,k)) by A16,Th22,T;
  end;
  set SD = s|dom ProgramPart p;
A17: dom DataPart p misses dom ProgramPart p by COMPOS_1:15;
  set PR = ProgramPart (Relocated (p,k));
  set IP = Start-At(IC p,SCM R);
A18: s|dom ProgramPart p c= s by RELAT_1:88;
  set PP = ProgramPart p;
A19: {IC SCM R} misses dom DataPart p by COMPOS_1:13;
  ProgramPart (Relocated (p,k)) c= Relocated (p,k) by RELAT_1:88;
  then
A20: ProgramPart (Relocated (p,k)) c= s by A3,XBOOLE_1:1;
  dom ProgramPart p c= the carrier of SCM R by RELAT_1:def 18;
  then dom ProgramPart p c= dom s by PARTFUN1:def 4;
  then
A21: dom ProgramPart p = dom (s|dom ProgramPart p) by RELAT_1:91;
  DataPart (Relocated (p,k)) c= Relocated (p,k) by RELAT_1:88;
  then DataPart (Relocated (p,k)) c= s by A3,XBOOLE_1:1;
  then
A22: DataPart p c= s by AMISTD_2:68;
  set DP = DataPart p;
  set IS = Start-At (IC Comput(ProgramPart(s+*p),s+*p,0) + k,SCM R);
A23: dom Start-At(IC p,SCM R) = {IC SCM R} by FUNCOP_1:19;
  IC Comput(ProgramPart(s+*p),s+*p,0) = (s +* p).IC SCM R by AMI_1:13
    .= IC p by A2,FUNCT_4:14;
  then
A24: Start-At (IC Comput(ProgramPart(s+*p),s+*p,0) + k,SCM R) c= s
by A3,A4,XBOOLE_1:1;
A25: dom Start-At (IC Comput(ProgramPart(s+*p),s+*p,0) + k,SCM R) = {IC
SCM R}
by FUNCOP_1:19;
  then
A26: dom Start-At(IC p,SCM R) =
 dom Start-At (IC Comput(ProgramPart(s+*p),s+*p,0) + k,SCM R) by FUNCOP_1:19;
  Comput(ProgramPart(s),s,0) = s by AMI_1:13
    .= s +* PR by A20,FUNCT_4:79
    .= s +* SD +* PR by A18,FUNCT_4:79
    .= s +* PP +* SD +* PR by A21,FUNCT_4:78
    .= s +* IS +* PP +* SD +* PR by A24,FUNCT_4:79
    .= s +*(IS +* PP) +* SD +* PR by FUNCT_4:15
    .= s +*(PP +* IS) +* SD +* PR by A25,COMPOS_1:14,FUNCT_4:36
    .= s +* PP +* IS +* SD +* PR by FUNCT_4:15
    .= s +* DP +* PP +* IS +* SD +* PR by A22,FUNCT_4:79
    .= s +*(DP +* PP) +* IS +* SD +* PR by FUNCT_4:15
    .= s +*(PP +* DP) +* IS +* SD +* PR by A17,FUNCT_4:36
    .= s +* PP +* DP +* IS +* SD +* PR by FUNCT_4:15
    .= s +* PP +* DP +* IP +* IS +* SD +* PR by A26,FUNCT_4:78
    .= s +*(PP +* DP) +* IP +* IS +* SD +* PR by FUNCT_4:15
    .= s +*(PP +* DP +* IP) +* IS +* SD +* PR by FUNCT_4:15
    .= s +*(PP +*(DP +* IP))+* IS +* SD +* PR by FUNCT_4:15
    .= s +*(PP +*(IP +* DP))+* IS +* SD +* PR by A23,A19,FUNCT_4:36
    .= s +*(PP +* IP +* DP) +* IS +* SD +* PR by FUNCT_4:15
    .= s +*(IP +* PP +* DP) +* IS +* SD +* PR by A23,COMPOS_1:14,FUNCT_4:36
    .= s +* p +* IS +* SD +* PR by A2,COMPOS_1:18
    .= Comput(ProgramPart(s+*p),s+*p,0) +*
     Start-At (IC Comput(ProgramPart(s+*p),s+*p,0) + k,SCM R)
     +* s|dom
  ProgramPart p +* ProgramPart (Relocated (p,k)) by AMI_1:13;
  then
A27: P[0 qua Element of NAT];
  for n holds P[n] from NAT_1:sch 1 (A27,A5);
  hence thesis;
end;

theorem Th39:
  R is non trivial & IC SCM R in dom p & p c= s & Relocated(p,k)
  is autonomic implies for i being Element of NAT holds Comput(ProgramPart(s),s
,i) =
Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i) +* Start-At (IC
Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),
  i) -' k,SCM R) +* s|dom ProgramPart Relocated(p,k) +* ProgramPart (p)
proof
  assume that
A1: R is non trivial and
A2: IC SCM R in dom p and
A3: p c= s and
A4: Relocated (p,k) is autonomic;
A5: IC SCM R in dom Relocated(p,k) by AMISTD_2:72;
  defpred P[Element of NAT] means Comput(ProgramPart(s),s,$1) = Comput(
ProgramPart(s+*Relocated
  (p,k)),s+*Relocated
  (p,k),$1) +*
   Start-At (IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),$1) -'
k,SCM R) +*
  s|(dom
  ProgramPart Relocated(p,k)) +* ProgramPart p;
A6: for i being Element of NAT st P[i] holds P[i+1 qua Element of NAT]
  proof
    reconsider pp = ProgramPart p as NAT-defined FinPartState of SCM R;
    set sdom = s|(dom ProgramPart Relocated(p,k));
    let i be Element of NAT such that
A7: P[i];
    reconsider ii = IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),
i) as Element of NAT;
A8: ProgramPart(Relocated(p,k)) c= Comput(ProgramPart(s+*Relocated(p,k)),s+*
Relocated(p,k),i) by AMI_1:99,FUNCT_4:26;
    dom (Start-At (IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i
) -' k,SCM R))
     = {IC SCM R
    } by FUNCOP_1:19;
    then
A9: IC SCM R in dom (Start-At
 (IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i) -' k,
SCM R))
    by TARSKI:def 1;
    dom ProgramPart Relocated(p,k) c= the carrier of SCM R by RELAT_1:def 18;
    then dom ProgramPart Relocated(p,k) c= dom s by PARTFUN1:def 4;
    then
A10: dom ProgramPart Relocated(p,k) = dom (s|(dom ProgramPart Relocated(p,
    k))) by RELAT_1:91;
    reconsider sdom as FinPartState of SCM R;
    dom (s|(dom ProgramPart Relocated(p,k))) c= NAT by A10,RELAT_1:87;
    then reconsider sdom as NAT-defined FinPartState of SCM R by RELAT_1:def 18
    ;
    consider jk being natural number such that
A11: IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i) = jk;
    IC SCM R in dom Relocated(p,k) by AMISTD_2:72;
    then Relocated(p,k) is not NAT-defined by COMPOS_1:19;
    then
A12: IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i) in dom
ProgramPart(Relocated(p,k)
    ) by A1,A4,Th27,FUNCT_4:26;
    then IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i)
     in dom Reloc(ProgramPart p,k) by AMISTD_2:69;
    then
A13: jk in { j+k where j is Element of NAT: j in dom ProgramPart p }
 by A11,AMISTD_2:70;
    dom sdom = dom s /\ dom ProgramPart Relocated(p,k) & not IC SCM R in
    dom ProgramPart Relocated(p,k) by COMPOS_1:12,RELAT_1:90;
    then
A14: not IC SCM R in dom sdom by XBOOLE_0:def 4;
    consider j being Element of NAT such that
A15: jk = j+k and
A16: j in dom ProgramPart p by A13;
Y:  (ProgramPart Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i))/.
IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i)
 = Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i).
 IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i) by COMPOS_1:38;
 reconsider sh = Shift(ProgramPart p, k)
  as NAT-defined (the Instructions of SCM R)-valued finite Function;
    dom Shift(pp, k) = { m+k where m is Element of NAT: m in dom pp}
     by VALUED_1:def 12;
    then
A17: j+k in dom Shift(ProgramPart p, k) by A16;
    then
A18: IncAddr(Shift(ProgramPart p, k)/.ii, k)
    = IncAddr(sh,k).ii by A11,A15,AMISTD_2:def 15
      .= (ProgramPart Relocated(p,k)).(IC Comput(ProgramPart(s+*Relocated(p,k))
,s+*Relocated(p,k),i))
    by AMISTD_2:69
      .= CurInstr(ProgramPart Comput(ProgramPart(s+*Relocated(p,k)),s+*
Relocated(p,k),i),
      Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i))
       by A12,A8,Y,GRFUNC_1:8;
A19: j+k -' k + k = j + k by NAT_D:34;
Y:  (ProgramPart Comput(ProgramPart(s),s,i))/.IC Comput(ProgramPart(s),s,i)
 = Comput(ProgramPart(s),s,i).IC Comput(ProgramPart(s),s,i) by COMPOS_1:38;
A20: (j+k) -' k = j by NAT_D:34;
T: ProgramPart(s+*Relocated(p,k)) =
 ProgramPart Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),
i)
by AMI_1:123;
S: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,i)
by AMI_1:123;
    not IC SCM R in dom ProgramPart p by COMPOS_1:12;
    then IC (Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i) +*
Start-At (IC Comput(ProgramPart(s+*
Relocated(p,k)),s+*
Relocated(p,k),i) -' k,SCM R) +* sdom +* ProgramPart p) =
(Comput(ProgramPart(s+*Relocated
(p,k)),s+*Relocated
(p,k),i) +*
Start-At
 (IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i) -' k,
SCM R) +* sdom).IC SCM
    R by FUNCT_4:12
      .= (Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i) +*
Start-At (IC Comput(ProgramPart(s+*
    Relocated(p,k)),s+*
    Relocated(p,k),i) -' k,SCM R)).IC SCM R by A14,FUNCT_4:12
      .= (Start-At
       (IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i)
        -' k,SCM R)).IC SCM R
      by A9,FUNCT_4:14
      .= IC Comput(ProgramPart(s+*Relocated(p,k)),
      s+*Relocated(p,k),i) -' k by FUNCOP_1:87;
    then CurInstr(ProgramPart Comput(ProgramPart(s),s,i),Comput(ProgramPart(s),
s,i))
     = (ProgramPart p). (IC Comput(ProgramPart(s+*
    Relocated(p,k)),s+*
    Relocated(p,k),i) -' k) by A7,A11,A15,A16,A20,Y,FUNCT_4:14
      .= Shift(ProgramPart p, k). (IC Comput(ProgramPart(s+*Relocated(p,k)),s+*
Relocated(p,k),i)) by A11,A15,A16,A19,VALUED_1:def 12
      .= Shift(ProgramPart p, k)/.ii by A11,A15,A17,PARTFUN1:def 8;
    then
A21: Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i+1) =
 Following(ProgramPart Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),
i),
 Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k), i))
  & Exec(CurInstr(ProgramPart Comput(ProgramPart(s),s,i),
Comput(ProgramPart(s),s,i)), Comput(ProgramPart(s+*Relocated(
p,k)),s+*Relocated(
p,k),i) +* Start-At (IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k)
,i) -' k,SCM R)) =
Following(ProgramPart Comput(ProgramPart(s +*Relocated(p,k)),s +*Relocated(p,k)
,i),
Comput(ProgramPart(s +*Relocated(p,k)),s +*Relocated(p,k),i))
 +* Start-At ((IC
 Following(ProgramPart(s+*Relocated(p,k)) ,
 Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i)))
  -' k,SCM R) by A11,A15,A18,Th23,T,AMI_1:14;
    thus Comput(ProgramPart(s),s,i+1)
     = Following(ProgramPart s,Comput(ProgramPart(s),s
,i))
     by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s),s,i),Comput(
ProgramPart(s),s,i)),
      Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i) +*
Start-At (IC Comput(ProgramPart(s+*Relocated(p,k)),
s+*Relocated(p,k),i) -' k,SCM R) +* sdom ) +*
ProgramPart p
    by A7,S,AMISTD_2:67
      .= Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),i+1) +*
Start-At (IC Comput(ProgramPart(s+*
Relocated(p,k)),s+*
Relocated(p,k),i+1) -' k,SCM R) +* s|dom ProgramPart Relocated(p,k) +*
ProgramPart p
    by A21,T,AMISTD_2:67;
  end;
  set PR = ProgramPart Relocated (p,k);
  set IP = Start-At(IC p +k,SCM R);
  set IS = Start-At (IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k)
,0) -' k,SCM R);
  set SD = s|(dom PR);
A23: IC Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),0) = (s +*
Relocated(p,k)).IC SCM R by AMI_1:13
    .= IC Relocated(p,k) by A5,FUNCT_4:14;
  set PP = ProgramPart p;
  PP c= p by RELAT_1:88;
  then
A24: PP c= s by A3,XBOOLE_1:1;
  Start-At(IC p,SCM R) c= p by A2,FUNCOP_1:99;
  then
A25: Start-At(IC p,SCM R) c= s by A3,XBOOLE_1:1;
  set DP = DataPart p;
  DP c= p by RELAT_1:88;
  then
A26: DP c= s by A3,XBOOLE_1:1;
A28: {IC SCM R} misses dom PR by COMPOS_1:14;
  dom IS /\ dom (s|(dom PR)) = dom IS /\ (dom s /\ dom PR) by RELAT_1:90
    .= {IC SCM R} /\ (dom s /\ dom PR) by FUNCOP_1:19
    .= {IC SCM R} /\ dom PR /\ dom s by XBOOLE_1:16
    .= {} /\ dom s by A28,XBOOLE_0:def 7
    .= {};
  then
A29: dom IS misses dom (s|(dom PR)) by XBOOLE_0:def 7;
  dom PR c= the carrier of SCM R by RELAT_1:def 18;
  then dom PR c= dom s by PARTFUN1:def 4;
  then
A30: dom PR = dom(s|(dom PR)) by RELAT_1:91;
  dom IS = {IC SCM R} by FUNCOP_1:19;
  then
A31: dom Start-At(IC p +k,SCM R) = dom IS by FUNCOP_1:19;
U2: dom Start-At((IC p)+k,SCM R) = {IC SCM R} by FUNCOP_1:19;
  Comput(ProgramPart(s),s,0) = s by AMI_1:13
    .= s +* PP by A24,FUNCT_4:79
    .= s +* Start-At(IC p,SCM R) +* PP by A25,FUNCT_4:79
    .= s +* Start-At (IC p + k -' k,SCM R) +* PP by NAT_D:34
    .= s +* IS +* PP by A23,A2,AMISTD_2:73
    .= s +* SD +* IS +* PP by FUNCT_4:80
    .= s +* PR +* SD +* IS +* PP by A30,FUNCT_4:78
    .= s +* PR +* (SD +* IS) +* PP by FUNCT_4:15
    .= s +* PR +* (IS +* SD) +* PP by A29,FUNCT_4:36
    .= s +* PR +* IS +* SD +* PP by FUNCT_4:15
    .= s +* DP +* PR +* IS +* SD +* PP by A26,FUNCT_4:79
    .= s +* DP +* PR +* IP +* IS +* SD +* PP by A31,FUNCT_4:78
    .= s +* (DP +* PR) +* IP +* IS +* SD +* PP by FUNCT_4:15
    .= s +* (DP +* PR +* IP) +* IS +* SD +* PP by FUNCT_4:15
    .= s +* (DP +* (PR +* IP)) +* IS +* SD +* PP by FUNCT_4:15
    .= s +* (DP +* (IP +* PR)) +* IS +* SD +* PP by U2,COMPOS_1:14,FUNCT_4:36

    .= s +* (DP +* IP +* PR) +* IS +* SD +* PP by FUNCT_4:15
    .= s +* (IncrIC(NPP p,k) +* PR) +* IS +* SD +* PP by A2,COMPOS_1:75
    .= s +* Relocated(p,k) +* IS +* SD +* PP by AMISTD_2:69
    .= Comput(ProgramPart(s+*Relocated(p,k)),s+*Relocated(p,k),0) +* Start-At (
IC Comput(ProgramPart(s+*
Relocated(p,k)),s+*
Relocated(p,k),0) -' k,SCM R) +* s|(dom ProgramPart Relocated(p,k)) +*
ProgramPart p
  by AMI_1:13;
  then
A33: P[0 qua Element of NAT];
  for n holds P[n] from NAT_1:sch 1 (A33,A6);
  hence thesis;
end;

theorem Th40:
  R is non trivial & IC SCM R in dom p implies (p is autonomic iff
  Relocated (p,k) is autonomic)
proof
  assume that
A1: R is non trivial and
A2: IC SCM R in dom p;
  hereby
    assume
A3: p is autonomic;
    thus Relocated (p,k) is autonomic
    proof
      let s1,s2 be State of SCM R such that
A4:   Relocated (p,k) c= s1 and
A5:   Relocated (p,k) c= s2;
      let i be Element of NAT;
A6:   Comput(ProgramPart(s1),s1,i) = Comput(ProgramPart(s1+*p),s1+*p,i) +*
Start-At (IC Comput(ProgramPart(s1+*p),s1+*p,i) + k,SCM R) +* s1|dom
ProgramPart p +*
ProgramPart (Relocated (p,k))
by A1,A2,A3,A4,Th38;
      dom ProgramPart p c= the carrier of SCM R by RELAT_1:def 18;
      then dom ProgramPart p c= dom s2 by PARTFUN1:def 4;
      then
A7:   dom(s2|dom ProgramPart p) = dom ProgramPart p by RELAT_1:91;
      dom ProgramPart p c= the carrier of SCM R by RELAT_1:def 18;
      then dom ProgramPart p c= dom s1 by PARTFUN1:def 4;
      then
A8:   dom(s1|dom ProgramPart p) = dom ProgramPart p by RELAT_1:91;
A9:   dom (Start-At ((IC Comput(ProgramPart(s2+*p),s2+*p,i))+k,SCM R))
= {IC SCM R}
by FUNCOP_1:19;
      then
A10:  dom(DataPart p) misses
 dom (Start-At (IC Comput(ProgramPart(s2+*p),s2+*p,i) + k,SCM R))
      by COMPOS_1:13;
A11:  dom (Start-At ((IC Comput(ProgramPart(s1+*p),s1+*p,i))+k,SCM R))
= {IC SCM R}
by FUNCOP_1:19;
      then
A12:  dom(DataPart p) misses
      dom (Start-At (IC Comput(ProgramPart(s1+*p),s1+*p,i) + k,SCM R))
      by COMPOS_1:13;
A13:  Comput(ProgramPart(s2),s2,i) = Comput(ProgramPart(s2+*p),s2+*p,i) +*
Start-At (IC Comput(ProgramPart(s2+*p),s2+*p,i) + k,SCM R) +* s2|dom
ProgramPart p +*
ProgramPart (Relocated (p,k))
by A1,A2,A3,A5,Th38;
A14:  Comput(ProgramPart(s1),s1,i)|dom (IncAddr(Shift(ProgramPart p,k),k)) =
      Comput(ProgramPart(s1),s1,i)|dom (ProgramPart (Relocated (p,k))) by
AMISTD_2:69
        .= ProgramPart (Relocated (p,k)) by A6,FUNCT_4:24
        .= Comput(ProgramPart(s2),s2,i)|dom (ProgramPart (Relocated (p,k))) by
A13,FUNCT_4:24
        .= Comput(ProgramPart(s2),s2,i)|dom (IncAddr(Shift(ProgramPart p,k),k))
by AMISTD_2:69;
      DataPart p c= p by RELAT_1:88;
      then
A15:  dom DataPart p c= dom p by GRFUNC_1:8;
      p c= s1 +* p & p c= s2 +* p by FUNCT_4:26;
      then
A16:  Comput(ProgramPart(s1+*p),s1+*p,i)|dom (p ) = Comput(ProgramPart(s2+*p),
s2+*p,i) |dom (p ) by A3,AMI_1:def 25;
A17:  dom(DataPart p) misses dom(ProgramPart(Relocated (p,k)))by COMPOS_1:15;
      then
A18:  Comput(ProgramPart(s1),s1,i)|dom (DataPart p) = ( Comput(ProgramPart(s1+*
p),s1+*p,i) +*
Start-At (IC Comput(ProgramPart(s1+*p),s1+*p,i) + k,SCM R) +* s1|dom
ProgramPart p) |
dom(DataPart
      p) by A6,FUNCT_4:76
        .= ( Comput(ProgramPart(s1+*p),s1+*p,i) +*
        Start-At (IC Comput(ProgramPart(s1+*p),s1+*p,i) + k,SCM R))
      | dom(DataPart p) by A8,COMPOS_1:15,FUNCT_4:76
        .= ( Comput(ProgramPart(s1+*p),s1+*p,i)) | dom (DataPart p) by A12,
FUNCT_4:76
        .= ( Comput(ProgramPart(s2+*p),s2+*p,i)) | dom (DataPart p) by A16,A15,
RELAT_1:188
        .= ( Comput(ProgramPart(s2+*p),s2+*p,i) +*
        Start-At (IC Comput(ProgramPart(s2+*p),s2+*p,i) + k,SCM R))
      | dom(DataPart p) by A10,FUNCT_4:76
        .= ( Comput(ProgramPart(s2+*p),s2+*p,i) +*
        Start-At (IC Comput(ProgramPart(s2+*p),s2+*p,i) + k,SCM R)
      +* s2|dom ProgramPart p) | dom(DataPart p) by A7,COMPOS_1:15,FUNCT_4:76
        .= Comput(ProgramPart(s2),s2,i)|dom (DataPart p) by A13,A17,FUNCT_4:76;
A19:  {IC SCM R} c= dom p by A2,ZFMISC_1:37;
A20:  Start-At (IC Comput(ProgramPart(s1+*p),s1+*p,i),SCM R) = Comput(
ProgramPart(s1+*p),s1+*p,i)|{IC SCM R
      } by COMPOS_1:10
        .= Comput(ProgramPart(s2+*p),s2+*p,i)|{IC SCM R} by A16,A19,RELAT_1:188
        .= Start-At (IC Comput(ProgramPart(s2+*p),s2+*p,i),SCM R) by
COMPOS_1:10;
A21:  dom (Start-At(IC p +k,SCM R)) = {IC SCM R} by FUNCOP_1:19;
      then
A22:  dom (Start-At(IC p +k,SCM R)) misses
 dom ProgramPart (Relocated (p,k)
      ) by COMPOS_1:14;
      then
A23:  Comput(ProgramPart(s1),s1,i)|dom (Start-At(IC p +k,SCM R))
 = ( Comput(ProgramPart(s1+*p),s1+*p,i
) +* Start-At (IC Comput(ProgramPart(s1+*p),s1+*p,i) + k,SCM R) +*
s1|dom ProgramPart p) |
dom (
      Start-At(IC p +k,SCM R)) by A6,FUNCT_4:76
        .= ( Comput(ProgramPart(s1+*p),s1+*p,i) +*
        Start-At (IC Comput(ProgramPart(s1+*p),s1+*p,i) + k,SCM R))
      |dom (Start-At(IC p +k,SCM R)) by A21,A8,COMPOS_1:14,FUNCT_4:76
        .= Start-At (IC Comput(ProgramPart(s1+*p),s1+*p,i) + k,SCM R)
        by A21,A11,FUNCT_4:24
        .= Start-At (IC Comput(ProgramPart(s2+*p),s2+*p,i) + k,SCM R)
        by A20,COMPOS_1:43
        .= ( Comput(ProgramPart(s2+*p),s2+*p,i) +*
        Start-At (IC Comput(ProgramPart(s2+*p),s2+*p,i) + k,SCM R))
      |dom (Start-At(IC p +k,SCM R)) by A21,A9,FUNCT_4:24
        .= ( Comput(ProgramPart(s2+*p),s2+*p,i) +*
        Start-At (IC Comput(ProgramPart(s2+*p),s2+*p,i) + k,SCM R)
      +* s2|dom ProgramPart p) |dom (Start-At(IC p +k,SCM R))
      by A21,A7,COMPOS_1:14,FUNCT_4:76
        .= Comput(ProgramPart(s2),s2,i)|dom (Start-At(IC p +k,SCM R))
        by A13,A22,FUNCT_4:76;
U2: dom Start-At((IC p)+k,SCM R) = {IC SCM R} by FUNCOP_1:19;
U:  dom NPP p = {IC SCM R} \/ dom DataPart p by A2,COMPOS_1:70;
Y1: Comput(ProgramPart s1,s1,i)|dom NPP p
       = Comput(ProgramPart s1,s1,i)|{IC SCM R}
          \/ Comput(ProgramPart s1,s1,i)|dom DataPart p by U,RELAT_1:107
       .= Comput(ProgramPart s2,s2,i)|dom NPP p by U,U2,A23,A18,RELAT_1:107;
Y:  dom IncrIC(NPP p,k)
      = dom NPP p \/ dom Start-At((IC NPP p)+k,SCM R) by FUNCT_4:def 1
     .= dom NPP p \/ dom Start-At((IC p)+k,SCM R) by A2,COMPOS_1:72;
X1: Comput(ProgramPart s1,s1,i)|dom IncrIC(NPP p,k)
     = Comput(ProgramPart s1,s1,i)|dom NPP p
        \/ Comput(ProgramPart s1,s1,i)|dom Start-At((IC p)+k,SCM R)
                                                  by Y,RELAT_1:107
    .= Comput(ProgramPart s2,s2,i)|dom IncrIC(NPP p,k)
         by Y,Y1,A23,RELAT_1:107;
X:    dom Relocated (p,k)
       = dom IncrIC(NPP p,k) \/ dom Reloc(ProgramPart p,k) by FUNCT_4:def 1;
     hence Comput(ProgramPart(s1),s1,i)|dom Relocated (p,k)
        = Comput(ProgramPart(s1),s1,i)|dom IncrIC(NPP p,k)
           \/ Comput(ProgramPart(s1),s1,i)|dom Reloc(ProgramPart p,k)
                                                  by RELAT_1:107
       .= Comput(ProgramPart(s2),s2,i)|dom Relocated (p,k)
           by X1,A14,X,RELAT_1:107;
    end;
  end;
  assume
A25: Relocated (p,k) is autonomic;
  let s1,s2 be State of SCM R such that
A26: p c= s1 and
A27: p c= s2;
  let i be Element of NAT;
A28: Comput(ProgramPart(s2),s2,i) = Comput(ProgramPart(s2+*Relocated(p,k)),s2+*
Relocated(p,k),i) +* Start-At (IC
Comput(ProgramPart(s2+*Relocated(p,k)),s2+*Relocated(p,k),i) -' k,SCM R
) +* s2|dom
ProgramPart Relocated(p,k) +*
  ProgramPart (p) by A1,A2,A25,A27,Th39;
  DataPart (Relocated(p,k)) c= Relocated(p,k) by RELAT_1:88;
  then DataPart p c= Relocated(p,k) by AMISTD_2:68;
  then
A29: dom (DataPart p) c= dom (Relocated(p,k)) by GRFUNC_1:8;
A30: dom (Start-At
 ((IC Comput(ProgramPart(s1+*Relocated(p,k)),
 s1+*Relocated(p,k),i)) -' k,SCM R)) =
{IC SCM
  R} by FUNCOP_1:19;
  then
A31: dom(DataPart p) misses dom(Start-At (IC Comput(ProgramPart(s1+*Relocated(p
,k)),s1+*Relocated(p,k),
  i) -' k,SCM R)) by COMPOS_1:13;
  dom ProgramPart Relocated(p,k) c= the carrier of SCM R by RELAT_1:def 18;
  then dom ProgramPart Relocated(p,k) c= dom s1 by PARTFUN1:def 4;
  then
A32: dom(s1|dom ProgramPart Relocated(p,k)) = dom ProgramPart Relocated(p,k)
  by RELAT_1:91;
A33: Comput(ProgramPart(s1),s1,i) = Comput(ProgramPart(s1+*Relocated(p,k)),s1+*
Relocated(p,k),i) +* Start-At (IC
Comput(ProgramPart(s1+*Relocated(p,k)),s1+*Relocated(p,k),i) -' k,SCM R
) +* s1|dom ProgramPart
Relocated(p,k) +*
  ProgramPart (p) by A1,A2,A25,A26,Th39;
  then
A34: Comput(ProgramPart(s1),s1,i)|dom (ProgramPart p) = ProgramPart (p) by
FUNCT_4:24
    .= Comput(ProgramPart(s2),s2,i)|dom (ProgramPart p) by A28,FUNCT_4:24;
  Relocated (p,k) c= s1 +* Relocated (p,k) & Relocated (p,k) c= s2 +*
  Relocated (p,k) by FUNCT_4:26;
  then
A35: Comput(ProgramPart(s1+*Relocated(p,k)),s1+*Relocated(p,k),i)|dom (
Relocated (p,k)) = Comput(ProgramPart(
  s2+*Relocated(p,k)),
  s2+*Relocated(p,k),i)|dom (Relocated (p,k)) by A25,AMI_1:def 25;
  dom ProgramPart Relocated(p,k) c= the carrier of SCM R by RELAT_1:def 18;
  then dom ProgramPart Relocated(p,k) c= dom s2 by PARTFUN1:def 4;
  then
A36: dom(s2|dom ProgramPart Relocated(p,k)) = dom ProgramPart Relocated(p,k)
  by RELAT_1:91;
A37: dom (Start-At ((IC Comput(ProgramPart(s2+*Relocated(p,k)),s2+*Relocated(p,
k),i)) -' k,SCM R))
 =
 {IC SCM
  R} by FUNCOP_1:19;
  then
A38: dom(DataPart p) misses dom(Start-At (IC Comput(ProgramPart(s2+*Relocated(p
,k)),s2+*Relocated(p,k),
  i) -' k,SCM R)) by COMPOS_1:13;
A39: dom (DataPart p) misses dom (ProgramPart p) by COMPOS_1:15;
  then
A40: Comput(ProgramPart(s1),s1,i)|dom (DataPart p) = (Comput(ProgramPart(s1+*
Relocated(p,k)),s1+*Relocated(p,k),i)
  +* Start-At (IC Comput(ProgramPart(s1+*Relocated(p,k)),s1+*Relocated(p,k),i)
-' k,SCM R) +* s1|
  dom ProgramPart
  Relocated(p,k)) | dom(DataPart p) by A33,FUNCT_4:76
    .= (Comput(ProgramPart(s1+*Relocated(p,k)),s1+*Relocated(p,k),i) +*
Start-At (IC Comput(ProgramPart(s1+*
  Relocated(p,k)),s1+*
  Relocated(p,k),i) -' k,SCM R)) | dom(DataPart p)
  by A32,COMPOS_1:15,FUNCT_4:76
    .= (Comput(ProgramPart(s1+*Relocated(p,k)),s1+*Relocated(p,k),i)) | dom (
DataPart p) by A31,FUNCT_4:76
    .= (Comput(ProgramPart(s2+*Relocated(p,k)),s2+*Relocated(p,k),i)) | dom (
DataPart p) by A35,A29,RELAT_1:188
    .= (Comput(ProgramPart(s2+*Relocated(p,k)),s2+*Relocated(p,k),i) +*
Start-At (IC Comput(ProgramPart(s2+*
  Relocated(p,k)),s2+*
  Relocated(p,k),i) -' k,SCM R)) | dom(DataPart p) by A38,FUNCT_4:76
    .= (Comput(ProgramPart(s2+*Relocated(p,k)),s2+*Relocated(p,k),i) +*
Start-At (IC Comput(ProgramPart(s2+*
Relocated(p,k)),s2+*
Relocated(p,k),i) -' k,SCM R) +* s2|dom ProgramPart Relocated(p,k)) |
dom(DataPart p)
  by A36,COMPOS_1:15,FUNCT_4:76
    .= Comput(ProgramPart(s2),s2,i)|dom (DataPart p) by A28,A39,FUNCT_4:76;
  IC SCM R in dom Relocated (p,k) by AMISTD_2:72;
  then
A41: {IC SCM R} c= dom Relocated (p,k) by ZFMISC_1:37;
A42: Start-At (IC Comput(ProgramPart(s1+*Relocated(p,k)),s1+*Relocated(p,k),i),
SCM R) = Comput(ProgramPart(s1+*
  Relocated(p,k)),s1+*
  Relocated(p,k),i)|{IC SCM R} by COMPOS_1:10
    .= Comput(ProgramPart(s2+*Relocated(p,k)),s2+*Relocated(p,k),i)|{IC SCM R}
by A35,A41,RELAT_1:188
    .= Start-At (IC Comput(ProgramPart(s2+*Relocated(p,k)),s2+*Relocated(p,k),i
),SCM R) by COMPOS_1:10;
A43: dom (Start-At(IC p,SCM R)) = {IC SCM R} by FUNCOP_1:19;
  then
A44: dom (Start-At(IC p,SCM R)) misses dom (ProgramPart p) by COMPOS_1:14;
  then
A45: Comput(ProgramPart(s1),s1,i)|dom (Start-At(IC p,SCM R)) =
 (Comput(ProgramPart(s1+*Relocated(p,
  k)),s1+*Relocated(p,
  k),i) +* Start-At
   (IC Comput(ProgramPart(s1+*Relocated(p,k)),
   s1+*Relocated(p,k),i) -' k,SCM R) +* s1|dom
  ProgramPart Relocated(p,k)) |dom (Start-At(IC p,SCM R)) by A33,FUNCT_4:76
    .= (Comput(ProgramPart(s1+*Relocated(p,k)),s1+*Relocated(p,k),i) +*
Start-At (IC Comput(ProgramPart(s1+*
Relocated(p,k)),s1+*
Relocated(p,k),i) -' k,SCM R)) |dom (Start-At(IC p,SCM R))
by A43,A32,COMPOS_1:14,FUNCT_4:76
    .= Start-At (IC Comput(ProgramPart(s1+*Relocated(p,k)),s1+*Relocated(p,k),i
) -' k,SCM R)
    by A43,A30,FUNCT_4:24
    .= Start-At (IC Comput(ProgramPart(s2+*Relocated(p,k)),s2+*Relocated(p,k),i
) -' k,SCM R)
    by A42,COMPOS_1:44
    .= (Comput(ProgramPart(s2+*Relocated(p,k)),s2+*Relocated(p,k),i) +*
Start-At (IC Comput(ProgramPart(s2+*
  Relocated(p,k)),s2+*
  Relocated(p,k),i) -' k,SCM R)) |dom (Start-At(IC p,SCM R))
  by A43,A37,FUNCT_4:24
    .= (Comput(ProgramPart(s2+*Relocated(p,k)),s2+*Relocated(p,k),i) +*
Start-At (IC Comput(ProgramPart(s2+*
Relocated(p,k)),s2+*
Relocated(p,k),i) -' k,SCM R) +* s2|dom ProgramPart Relocated(p,k)) |
dom (Start-At (
  IC p,SCM R)) by A43,A36,COMPOS_1:14,FUNCT_4:76
    .= Comput(ProgramPart(s2),s2,i)|dom (Start-At(IC p,SCM R)) by A28,A44,
FUNCT_4:76;
A46: Comput(ProgramPart(s1),s1,i)|dom (Start-At(IC p,SCM R) +* ProgramPart p) =
Comput(ProgramPart(
  s1),
  s1,i)|(dom (Start-At(IC p,SCM R)) \/ dom (ProgramPart p)) by FUNCT_4:def 1
    .= Comput(ProgramPart(s2),s2,i)|dom (Start-At(IC p,SCM R)) \/ Comput(
ProgramPart(s2),s2,i)|dom (
  ProgramPart p) by A45,A34,RELAT_1:107
    .= Comput(ProgramPart(s2),s2,i)|(dom (Start-At(IC p,SCM R)) \/ dom (
ProgramPart p))
by RELAT_1:107
    .= Comput(ProgramPart(s2),s2,i)|dom (Start-At(IC p,SCM R) +* ProgramPart p)
by FUNCT_4:def 1;
  thus Comput(ProgramPart(s1),s1,i)|dom p = Comput(ProgramPart(s1),s1,i)|dom (
Start-At(IC p,SCM R) +*
  ProgramPart p +* DataPart p ) by A2,COMPOS_1:18
    .= Comput(ProgramPart(s1),s1,i)|(dom (Start-At(IC p,SCM R) +* ProgramPart p
) \/ dom (
  DataPart p)) by FUNCT_4:def 1
    .= Comput(ProgramPart(s2),s2,i)|dom (Start-At(IC p,SCM R) +* ProgramPart p
) \/
  Comput(ProgramPart(s2),s2,i)|dom (DataPart p) by A40,A46,RELAT_1:107
    .= Comput(ProgramPart(s2),s2,i)|(dom (Start-At(IC p,SCM R) +* ProgramPart p
) \/ dom (
  DataPart p)) by RELAT_1:107
    .= Comput(ProgramPart(s2),s2,i)|dom (Start-At(IC p,SCM R) +* ProgramPart p
+*
    DataPart p
  ) by FUNCT_4:def 1
    .= Comput(ProgramPart(s2),s2,i)|dom p by A2,COMPOS_1:18;
end;

theorem Th41:
  R is non trivial implies for p being halting autonomic
  FinPartState of SCM R st IC SCM R in dom p holds DataPart Result(ProgramPart(
p),p) = DataPart
  Result(ProgramPart(Relocated(p,k)),Relocated(p,k))
proof
A1: Data-Locations SCM R = SCM-Data-Loc by SCMRING2:31;
  assume
A2: R is non trivial;
  let p being halting autonomic FinPartState of SCM R such that
A3: IC SCM R in dom p;
A4: Relocated(p,k) is halting & Relocated(p,k) is autonomic by A2,A3,Th36,Th40;
  consider s being State of SCM R such that
A5: p c= s by PBOOLE:156;
  ProgramPart s halts_on s by A5,AMI_1:def 26;
  then consider j1 being Element of NAT such that
A6: Result(ProgramPart(s),s) = Comput(ProgramPart(s),s,j1) and
A7: CurInstr(ProgramPart (s),Result(ProgramPart(s),s)) =
halt SCM R by AMI_1:def 22;
  consider t being State of SCM R such that
A8: Relocated(p,k) c= t by PBOOLE:156;
  reconsider s3 = s +* DataPart t as State of SCM R;
A9: s3 = s3;
Y:  (ProgramPart Comput(ProgramPart(t),t,j1))/.IC Comput(ProgramPart(t),t,j1)
= Comput(ProgramPart(t),t,j1).IC Comput(ProgramPart(t),t,j1) by COMPOS_1:38;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,j1)
by AMI_1:123;
  (ProgramPart t).(IC ( Comput(ProgramPart(t),t,j1)))
    = t.(IC ( Comput(ProgramPart(t),t,j1))) by COMPOS_1:2
   .= CurInstr(ProgramPart Comput(ProgramPart(t),t,j1),Comput(ProgramPart(t),t,
j1))
   by Y,AMI_1:54
    .= IncAddr(CurInstr(ProgramPart s,Comput(ProgramPart(s),s,j1)), k)
    by A2,A3,A5,A8,A9,Th35,TX
    .= halt SCM R by A6,A7,AMISTD_2:29;
  then
A10: Result(ProgramPart(t),t) = Comput(ProgramPart(t),t,j1) by AMI_1:56;
  thus DataPart(Result(ProgramPart(p),p)) = DataPart((Result(ProgramPart(s),s))
| dom p) by A5,AMI_1:def 29
    .= (Result(ProgramPart(s),s)) | (dom p /\ SCM-Data-Loc) by A1,RELAT_1:100
    .= (Result(ProgramPart(s),s)) | dom DataPart p by A1,RELAT_1:90
    .= (Result(ProgramPart(t),t)) | dom DataPart Relocated(p,k) by A2,A3,A5,A6
,A8,A9,A10,Th35
    .= (Result(ProgramPart(t),t)) | (dom Relocated(p,k) /\ SCM-Data-Loc) by A1,
RELAT_1:90
    .= DataPart ((Result(ProgramPart(t),t)) | dom Relocated(p,k)) by A1,
RELAT_1:100
    .= DataPart (Result(ProgramPart(Relocated(p,k)),Relocated(p,k))) by A8,A4,
AMI_1:def 29;
end;

theorem
  R is non trivial implies for F being PartFunc of FinPartSt SCM R,
  FinPartSt SCM R st IC SCM R in dom p & F is data-only
   holds ProgramPart p, p computes F
    iff ProgramPart Relocated (p,k), Relocated (p,k) computes F
proof
  assume
A1: R is non trivial;
  let F be PartFunc of FinPartSt SCM R, FinPartSt SCM R such that
A2: IC SCM R in dom p and
A3: F is data-only;
F1: ProgramPart p +* p = p by FUNCT_4:119;
F2: ProgramPart Relocated(p,k) +* Relocated(p,k) = Relocated(p,k)
              by FUNCT_4:119;
  hereby
    assume
A4: ProgramPart p, p computes F;
    thus ProgramPart Relocated (p,k), Relocated (p,k) computes F
    proof
      let x be set;
      assume
A5:   x in dom F;
      then consider d1 being FinPartState of SCM R such that
A6:   x = d1 and
A7:   ProgramPart p +* p +* d1 is pre-program of SCM R and
A8:   F.d1 c= Result(ProgramPart p,p +* d1) by A4,AMI_1:def 30;
      dom F c= FinPartSt SCM R by RELAT_1:def 18;
      then reconsider d = x as FinPartState of SCM R by A5,COMPOS_1:25;
      reconsider d as data-only FinPartState of SCM R by A3,A5,COMPOS_1:def 24;
X:    Relocated(p +* d,k) = Relocated(p,k) +* d by AMISTD_2:78;
xx:   dom d misses NAT by COMPOS_1:40;
      then
x:    ProgramPart(p +* d)= ProgramPart p by FUNCT_4:76;
y:    ProgramPart(Relocated(p,k) +* d) = ProgramPart Relocated(p,k)
               by xx,FUNCT_4:76;
      dom(p +* d) = dom p \/ dom d by FUNCT_4:def 1;
      then
A9:   IC SCM R in dom(p +* d) by A2,XBOOLE_0:def 3;
      then
A10:  DataPart(Result(ProgramPart p,p +* d1))
        = DataPart(Result(ProgramPart Relocated(p,k),Relocated(p,k) +* d))
         by A1,A6,A7,Th41,F1,x,X,y;
      reconsider Fd1 = F.d1 as FinPartState of SCM R by A8;
      take d;
      thus x=d;
      Relocated(p,k) +* d = Relocated((p +* d) ,k) by AMISTD_2:78;
      hence ProgramPart Relocated(p,k) +* Relocated(p,k) +* d
       is pre-program of SCM R by A1,A6,A7,A9,Th36,F1,F2,Th40;
A11:  Fd1 is data-only by A3,A5,A6,COMPOS_1:def 24;
      then F.d1 c= DataPart(Result(ProgramPart p,p +* d1)) by A8,COMPOS_1:17;
      hence F.d c= Result(ProgramPart Relocated(p,k),Relocated(p,k) +* d)
by A6,A11,A10,COMPOS_1:17;
    end;
  end;
  assume
A12: ProgramPart Relocated (p,k), Relocated (p,k) computes F;
  let x be set;
  assume
A13: x in dom F;
  then consider d1 being FinPartState of SCM R such that
A14: x = d1 and
A15: ProgramPart Relocated (p,k) +* Relocated (p,k) +* d1
      is pre-program of SCM R and
A16: F.d1 c= Result(ProgramPart Relocated (p,k),Relocated (p,k) +* d1)
by A12,AMI_1:def 30;
  dom F c= FinPartSt SCM R by RELAT_1:def 18;
  then reconsider d = x as FinPartState of SCM R by A13,COMPOS_1:25;
  reconsider d as data-only FinPartState of SCM R by A3,A13,COMPOS_1:def 24;
  dom(p +* d) = dom p \/ dom d by FUNCT_4:def 1;
  then
A17: IC SCM R in dom(p +* d) by A2,XBOOLE_0:def 3;
A18: Relocated(p,k) +* d = Relocated((p +* d),k) by AMISTD_2:78;
  then
A19: p +* d is autonomic by A1,A14,A15,A17,Th40,F2;
  then
A20: p +* d is halting by A1,A14,A15,A18,A17,Th36,F2;
X:    Relocated(p +* d,k) = Relocated(p,k) +* d by AMISTD_2:78;
xx:   dom d misses NAT by COMPOS_1:40;
      then
x:    ProgramPart(p +* d)= ProgramPart p by FUNCT_4:76;
y:    ProgramPart(Relocated(p,k) +* d) = ProgramPart Relocated(p,k)
               by xx,FUNCT_4:76;
A21: DataPart(Result(ProgramPart Relocated(p,k),Relocated(p,k) +* d1))
    = DataPart(Result(ProgramPart p,p +* d))
     by A1,A17,A19,A20,Th41,x,y,X,A14;
  take d;
  thus x=d;
  thus ProgramPart p +* p +* d is
   pre-program of SCM R by A1,A14,A15,A18,A17,A19,Th36,F1,F2;
  reconsider Fd1 = F.d1 as FinPartState of SCM R by A16;
A22: Fd1 is data-only by A3,A13,A14,COMPOS_1:def 24;
  then F.d1 c= DataPart(Result(ProgramPart Relocated(p,k),Relocated(p,k)
+* d1)) by A16,COMPOS_1:17;
  hence thesis by A14,A22,A21,COMPOS_1:17;
end;

