:: Computation and Program Shift in the SCMPDS Computer
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, INT_1, FSM_1, AMI_1, COMPLEX1,
      ARYTM_3, FUNCT_1, AMI_2, STRUCT_0, XBOOLE_0, RELAT_1, TARSKI, CARD_1,
      AMI_3, SCMPDS_1, GRAPHSP, SCMNORM, XXREAL_0, ARYTM_1, FUNCT_4, FUNCOP_1,
      CIRCUIT2, ORDINAL1, PARTFUN1;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, RELAT_1, FUNCT_1,
      PARTFUN1, FUNCT_4, INT_1, NAT_1, STRUCT_0, FUNCOP_1, INT_2, XXREAL_0,
      COMPOS_1, EXTPRO_1, AMI_1, AMI_2, SCMPDS_1, SCMPDS_2;
 constructors DOMAIN_1, XXREAL_0, INT_2, AMI_5, SCMPDS_1, SCMPDS_2, REAL_1,
      PRE_POLY, AMI_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, NUMBERS,
      XREAL_0, INT_1, CARD_3, AMI_1, AMI_3, SCMPDS_2, FINSET_1, RELSET_1,
      FUNCT_2, COMPOS_1, EXTPRO_1;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM, REAL;
 definitions AMI_1, EXTPRO_1, AMI_2, AMI_3, FUNCOP_1, SCMPDS_2, NAT_1,
 COMPOS_1;
 theorems AMI_1, AMI_3, GRFUNC_1, NAT_1, FUNCOP_1, TARSKI, FUNCT_4, FUNCT_1,
      ZFMISC_1, INT_1, RELAT_1, ABSVALUE, SCMPDS_2, XBOOLE_0, XBOOLE_1, AMI_2,
      NUMBERS, PBOOLE, PARTFUN1, COMPOS_1, EXTPRO_1;

begin :: Preliminaries

reserve j, k, m, n for Element of NAT,
  a,b for Int_position,
  k1,k2 for Integer;

canceled;

theorem Th2:
  for k1 be Integer,s1,s2 being State of SCMPDS st IC s1 = IC s2
  holds ICplusConst(s1,k1)=ICplusConst(s2,k1)
proof
  let k1 be Integer,s1,s2 be State of SCMPDS;
A1: ex i being Element of NAT st i = IC s1 & ICplusConst(s1,k1 ) = abs(i+k1)
  by SCMPDS_2:def 20;
  assume IC s1 = IC s2;
  hence thesis by A1,SCMPDS_2:def 20;
end;

theorem Th3:
  for k1 be Integer,a be Int_position,s1,s2 being State of SCMPDS
  st DataPart s1 = DataPart s2 holds s1.DataLoc(s1.a,k1)=s2.DataLoc(s2.a,k1)
proof
  let k1 be Integer,a be Int_position,s1,s2 be State of SCMPDS;
  assume
A1: DataPart s1 = DataPart s2;
A2: a in SCM-Data-Loc by SCMPDS_2:def 2;
  then
A3: s1.a= (DataPart s1).a by FUNCT_1:72,SCMPDS_2:100
    .= s2.a by A1,A2,FUNCT_1:72,SCMPDS_2:100;
A4: DataLoc(s1.a,k1) in SCM-Data-Loc by SCMPDS_2:def 2;
  hence s1.DataLoc(s1.a,k1)= (DataPart s1).DataLoc(s1.a,k1) by FUNCT_1:72
,SCMPDS_2:100
    .= s2.DataLoc(s2.a,k1) by A1,A4,A3,FUNCT_1:72,SCMPDS_2:100;
end;

theorem Th4:
  for a be Int_position,s1,s2 being State of SCMPDS st DataPart s1
  = DataPart s2 holds s1.a=s2.a
proof
  let a be Int_position,s1,s2 be State of SCMPDS;
  assume
A1: DataPart s1 = DataPart s2;
A2: a in SCM-Data-Loc by SCMPDS_2:def 2;
  hence s1.a= (DataPart s1).a by FUNCT_1:72,SCMPDS_2:100
    .= s2.a by A1,A2,FUNCT_1:72,SCMPDS_2:100;
end;

theorem
  the carrier of SCMPDS = {IC SCMPDS } \/ SCM-Data-Loc \/ NAT by AMI_3:4;

theorem
  not IC SCMPDS in SCM-Data-Loc
proof
  assume IC SCMPDS in SCM-Data-Loc;
  then IC SCMPDS is Int_position by SCMPDS_2:9;
  then ObjectKind IC SCMPDS = INT by SCMPDS_2:13;
  hence contradiction by COMPOS_1:def 6,NUMBERS:27;
end;

theorem Th7:
  for s1,s2 being State of SCMPDS st s1 | (SCM-Data-Loc \/ {IC
  SCMPDS }) = s2 | (SCM-Data-Loc \/ {IC SCMPDS }) for l being Instruction of
  SCMPDS holds Exec (l,s1) | (SCM-Data-Loc \/ {IC SCMPDS }) = Exec (l,s2) | (
  SCM-Data-Loc \/ {IC SCMPDS })
proof
  IC SCMPDS in {IC SCMPDS} by TARSKI:def 1;
  then
A1: IC SCMPDS in (SCM-Data-Loc \/ {IC SCMPDS}) by XBOOLE_0:def 3;
  let s1,s2 be State of SCMPDS such that
A2: s1 | (SCM-Data-Loc \/ {IC SCMPDS})=s2 | (SCM-Data-Loc \/ {IC SCMPDS}
  );
A3: DataPart s1 =DataPart s2 by A2,RELAT_1:188,SCMPDS_2:100,XBOOLE_1:7;
A4: (SCM-Data-Loc \/ {IC SCMPDS}) c= the carrier of SCMPDS by AMI_3:4
,XBOOLE_1:7;
  then (SCM-Data-Loc \/ {IC SCMPDS}) c= dom s2 by PARTFUN1:def 4;
  then
A5: IC SCMPDS in dom (s2 | (SCM-Data-Loc \/ {IC SCMPDS})) by A1,RELAT_1:91;
  (SCM-Data-Loc \/ {IC SCMPDS}) c= dom s1 by A4,PARTFUN1:def 4;
  then IC SCMPDS in dom (s1 | (SCM-Data-Loc \/ {IC SCMPDS})) by A1,RELAT_1:91;
  then
A6: IC s1 = (s2 | (SCM-Data-Loc \/ {IC SCMPDS})).IC SCMPDS by A2,FUNCT_1:70
    .= IC s2 by A5,FUNCT_1:70;
  let l be Instruction of SCMPDS;
A7: dom Exec(l,s1) = the carrier of SCMPDS by PARTFUN1:def 4;
  then
A8: dom Exec(l,s1) = dom Exec(l,s2) by PARTFUN1:def 4;
  dom Exec(l,s2) = the carrier of SCMPDS by PARTFUN1:def 4;
  then
A9: dom DataPart Exec (l,s2)= SCM-Data-Loc by RELAT_1:91,SCMPDS_2:100;
A10: dom DataPart Exec (l,s1)= SCM-Data-Loc by A7,RELAT_1:91,SCMPDS_2:100;
  per cases by NAT_1:38,SCMPDS_2:15;
  suppose
    InsCode (l) = 0;
    then consider k1 such that
A11: l = goto k1 by SCMPDS_2:35;
    for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x =
    (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A12:  x in SCM-Data-Loc;
      then reconsider a = x as Int_position by SCMPDS_2:9;
      thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A12,FUNCT_1:72
,SCMPDS_2:100
        .= s1.a by A11,SCMPDS_2:66
        .= (DataPart s1).a by A12,FUNCT_1:72,SCMPDS_2:100
        .= s2.a by A3,A12,FUNCT_1:72,SCMPDS_2:100
        .= (Exec (l,s2)).a by A11,SCMPDS_2:66
        .= (DataPart Exec (l,s2)).x by A12,FUNCT_1:72,SCMPDS_2:100;
    end;
    then
A13: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc ) by A10,A9,
FUNCT_1:9,SCMPDS_2:100;
    Exec (l,s1).IC SCMPDS = ICplusConst(s1,k1) by A11,SCMPDS_2:66
      .= ICplusConst(s2,k1) by A6,Th2
      .= Exec (l,s2).IC SCMPDS by A11,SCMPDS_2:66;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A8,
GRFUNC_1:90;
    hence thesis by A13,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 1;
    then consider a such that
A14: l = return a by SCMPDS_2:36;
    for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x =
    (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A15:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A16:    b<>a;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b by A15,FUNCT_1:72
,SCMPDS_2:100
          .= s1.b by A14,A16,SCMPDS_2:70
          .= (DataPart s1).b by A15,FUNCT_1:72,SCMPDS_2:100
          .= s2.b by A3,A15,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).b by A14,A16,SCMPDS_2:70
          .= (DataPart Exec (l,s2)).x by A15,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A17:    b=a;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b by A15,FUNCT_1:72
,SCMPDS_2:100
          .= s1.DataLoc(s1.a,RetSP) by A14,A17,SCMPDS_2:70
          .= s2.DataLoc(s2.a,RetSP) by A3,Th3
          .= (Exec (l,s2)).b by A14,A17,SCMPDS_2:70
          .= (DataPart Exec (l,s2)).x by A15,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A18: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc ) by A10,A9,
FUNCT_1:9,SCMPDS_2:100;
    Exec (l,s1).IC SCMPDS = (abs(s1.DataLoc(s1.a,RetIC)))+2 by A14,SCMPDS_2:70
      .= (abs(s2.DataLoc(s2.a,RetIC)))+2 by A3,Th3
      .= Exec (l,s2).IC SCMPDS by A14,SCMPDS_2:70;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A8,
GRFUNC_1:90;
    hence thesis by A18,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 2;
    then consider a,k1 such that
A19: l= a:=k1 by SCMPDS_2:37;
    for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x =
    (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A20:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A21:    b<>a;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b by A20,FUNCT_1:72
,SCMPDS_2:100
          .= s1.b by A19,A21,SCMPDS_2:57
          .= (DataPart s1).b by A20,FUNCT_1:72,SCMPDS_2:100
          .= s2.b by A3,A20,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).b by A19,A21,SCMPDS_2:57
          .= (DataPart Exec (l,s2)).x by A20,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A22:    b=a;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b by A20,FUNCT_1:72
,SCMPDS_2:100
          .= k1 by A19,A22,SCMPDS_2:57
          .= (Exec (l,s2)).b by A19,A22,SCMPDS_2:57
          .= (DataPart Exec (l,s2)).x by A20,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A23: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc ) by A10,A9,
FUNCT_1:9,SCMPDS_2:100;
    Exec (l,s1).IC SCMPDS = succ IC s2 by A6,A19,SCMPDS_2:57
      .= Exec (l,s2).IC SCMPDS by A19,SCMPDS_2:57;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A8,
GRFUNC_1:90;
    hence thesis by A23,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 3;
    then consider a,k1 such that
A24: l= saveIC(a,k1) by SCMPDS_2:38;
    for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x =
    (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A25:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A26:    b<>DataLoc(s1.a,k1);
        then
A27:    b<>DataLoc(s2.a,k1) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b by A25,FUNCT_1:72
,SCMPDS_2:100
          .= s1.b by A24,A26,SCMPDS_2:71
          .= (DataPart s1).b by A25,FUNCT_1:72,SCMPDS_2:100
          .= s2.b by A3,A25,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).b by A24,A27,SCMPDS_2:71
          .= (DataPart Exec (l,s2)).x by A25,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A28:    b=DataLoc(s1.a,k1);
        then
A29:    b=DataLoc(s2.a,k1) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b by A25,FUNCT_1:72
,SCMPDS_2:100
          .= IC s2 by A6,A24,A28,SCMPDS_2:71
          .= (Exec (l,s2)).b by A24,A29,SCMPDS_2:71
          .= (DataPart Exec (l,s2)).x by A25,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A30: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc ) by A10,A9,
FUNCT_1:9,SCMPDS_2:100;
    Exec (l,s1).IC SCMPDS = succ IC s2 by A6,A24,SCMPDS_2:71
      .= Exec (l,s2).IC SCMPDS by A24,SCMPDS_2:71;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A8,
GRFUNC_1:90;
    hence thesis by A30,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 4;
    then consider a,k1,k2 such that
A31: l = (a,k1)<>0_goto k2 by SCMPDS_2:39;
    now
      per cases;
      suppose
A32:    s1.DataLoc(s1.a,k1) <> 0;
        then
A33:    s2.DataLoc(s2.a,k1) <> 0 by A3,Th3;
        thus Exec (l,s1).IC SCMPDS = ICplusConst(s1,k2) by A31,A32,SCMPDS_2:67
          .= ICplusConst(s2,k2) by A6,Th2
          .= Exec (l,s2).IC SCMPDS by A31,A33,SCMPDS_2:67;
      end;
      suppose
A34:    s1.DataLoc(s1.a,k1) = 0;
        then
A35:    s2.DataLoc(s2.a,k1) = 0 by A3,Th3;
        thus Exec (l,s1).IC SCMPDS = succ IC s2 by A6,A31,A34,SCMPDS_2:67
          .= Exec (l,s2).IC SCMPDS by A31,A35,SCMPDS_2:67;
      end;
    end;
    then
A36: Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A8,GRFUNC_1:90;
    for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x =
    (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A37:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b by A37,FUNCT_1:72
,SCMPDS_2:100
        .= s1.b by A31,SCMPDS_2:67
        .= (DataPart s1).b by A37,FUNCT_1:72,SCMPDS_2:100
        .= s2.b by A3,A37,FUNCT_1:72,SCMPDS_2:100
        .= (Exec (l,s2)).b by A31,SCMPDS_2:67
        .= (DataPart Exec (l,s2)).x by A37,FUNCT_1:72,SCMPDS_2:100;
    end;
    then
    Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc ) by A10,A9,
FUNCT_1:9,SCMPDS_2:100;
    hence thesis by A36,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 5;
    then consider a,k1,k2 such that
A38: l = (a,k1)<=0_goto k2 by SCMPDS_2:40;
    now
      per cases;
      suppose
A39:    s1.DataLoc(s1.a,k1) <= 0;
        then
A40:    s2.DataLoc(s2.a,k1) <= 0 by A3,Th3;
        thus Exec (l,s1).IC SCMPDS = ICplusConst(s1,k2) by A38,A39,SCMPDS_2:68
          .= ICplusConst(s2,k2) by A6,Th2
          .= Exec (l,s2).IC SCMPDS by A38,A40,SCMPDS_2:68;
      end;
      suppose
A41:    s1.DataLoc(s1.a,k1) > 0;
        then
A42:    s2.DataLoc(s2.a,k1) > 0 by A3,Th3;
        thus Exec (l,s1).IC SCMPDS = succ IC s2 by A6,A38,A41,SCMPDS_2:68
          .= Exec (l,s2).IC SCMPDS by A38,A42,SCMPDS_2:68;
      end;
    end;
    then
A43: Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A8,GRFUNC_1:90;
    for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x =
    (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A44:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b by A44,FUNCT_1:72
,SCMPDS_2:100
        .= s1.b by A38,SCMPDS_2:68
        .= (DataPart s1).b by A44,FUNCT_1:72,SCMPDS_2:100
        .= s2.b by A3,A44,FUNCT_1:72,SCMPDS_2:100
        .= (Exec (l,s2)).b by A38,SCMPDS_2:68
        .= (DataPart Exec (l,s2)).x by A44,FUNCT_1:72,SCMPDS_2:100;
    end;
    then
    Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc ) by A10,A9,
FUNCT_1:9,SCMPDS_2:100;
    hence thesis by A43,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 6;
    then consider a,k1,k2 such that
A45: l = (a,k1)>=0_goto k2 by SCMPDS_2:41;
    now
      per cases;
      suppose
A46:    s1.DataLoc(s1.a,k1) >= 0;
        then
A47:    s2.DataLoc(s2.a,k1) >= 0 by A3,Th3;
        thus Exec (l,s1).IC SCMPDS = ICplusConst(s1,k2) by A45,A46,SCMPDS_2:69
          .= ICplusConst(s2,k2) by A6,Th2
          .= Exec (l,s2).IC SCMPDS by A45,A47,SCMPDS_2:69;
      end;
      suppose
A48:    s1.DataLoc(s1.a,k1) < 0;
        then
A49:    s2.DataLoc(s2.a,k1) < 0 by A3,Th3;
        thus Exec (l,s1).IC SCMPDS = succ IC s2 by A6,A45,A48,SCMPDS_2:69
          .= Exec (l,s2).IC SCMPDS by A45,A49,SCMPDS_2:69;
      end;
    end;
    then
A50: Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A8,GRFUNC_1:90;
    for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x =
    (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A51:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b by A51,FUNCT_1:72
,SCMPDS_2:100
        .= s1.b by A45,SCMPDS_2:69
        .= (DataPart s1).b by A51,FUNCT_1:72,SCMPDS_2:100
        .= s2.b by A3,A51,FUNCT_1:72,SCMPDS_2:100
        .= (Exec (l,s2)).b by A45,SCMPDS_2:69
        .= (DataPart Exec (l,s2)).x by A51,FUNCT_1:72,SCMPDS_2:100;
    end;
    then
    Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc ) by A10,A9,
FUNCT_1:9,SCMPDS_2:100;
    hence thesis by A50,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 7;
    then consider a,k1,k2 such that
A52: l = (a,k1):=k2 by SCMPDS_2:42;
    for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x =
    (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A53:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A54:    b<>DataLoc(s1.a,k1);
        then
A55:    b<>DataLoc(s2.a,k1) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b by A53,FUNCT_1:72
,SCMPDS_2:100
          .= s1.b by A52,A54,SCMPDS_2:58
          .= (DataPart s1).b by A53,FUNCT_1:72,SCMPDS_2:100
          .= s2.b by A3,A53,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).b by A52,A55,SCMPDS_2:58
          .= (DataPart Exec (l,s2)).x by A53,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A56:    b=DataLoc(s1.a,k1);
        then
A57:    b=DataLoc(s2.a,k1) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b by A53,FUNCT_1:72
,SCMPDS_2:100
          .= k2 by A52,A56,SCMPDS_2:58
          .= (Exec (l,s2)).b by A52,A57,SCMPDS_2:58
          .= (DataPart Exec (l,s2)).x by A53,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A58: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc ) by A10,A9,
FUNCT_1:9,SCMPDS_2:100;
    Exec (l,s1).IC SCMPDS = succ IC s2 by A6,A52,SCMPDS_2:58
      .= Exec (l,s2).IC SCMPDS by A52,SCMPDS_2:58;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A8,
GRFUNC_1:90;
    hence thesis by A58,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 8;
    then consider a,k1,k2 such that
A59: l = AddTo(a,k1,k2) by SCMPDS_2:43;
    for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x =
    (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A60:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A61:    b<>DataLoc(s1.a,k1);
        then
A62:    b<>DataLoc(s2.a,k1) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b by A60,FUNCT_1:72
,SCMPDS_2:100
          .= s1.b by A59,A61,SCMPDS_2:60
          .= (DataPart s1).b by A60,FUNCT_1:72,SCMPDS_2:100
          .= s2.b by A3,A60,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).b by A59,A62,SCMPDS_2:60
          .= (DataPart Exec (l,s2)).x by A60,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A63:    b=DataLoc(s1.a,k1);
        then
A64:    b=DataLoc(s2.a,k1) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b by A60,FUNCT_1:72
,SCMPDS_2:100
          .= s1.DataLoc(s1.a,k1)+k2 by A59,A63,SCMPDS_2:60
          .= s2.DataLoc(s2.a,k1)+k2 by A3,Th3
          .= (Exec (l,s2)).b by A59,A64,SCMPDS_2:60
          .= (DataPart Exec (l,s2)).x by A60,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A65: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc ) by A10,A9,
FUNCT_1:9,SCMPDS_2:100;
    Exec (l,s1).IC SCMPDS = succ IC s2 by A6,A59,SCMPDS_2:60
      .= Exec (l,s2).IC SCMPDS by A59,SCMPDS_2:60;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A8,
GRFUNC_1:90;
    hence thesis by A65,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 9;
    then consider a,b,k1,k2 such that
A66: l = AddTo(a,k1,b,k2) by SCMPDS_2:44;
    for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x
    = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A67:  x in SCM-Data-Loc;
      then reconsider c = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A68:    c <>DataLoc(s1.a,k1);
        then
A69:    c <>DataLoc(s2.a,k1) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).c by A67,FUNCT_1:72
,SCMPDS_2:100
          .= s1.c by A66,A68,SCMPDS_2:61
          .= (DataPart s1).c by A67,FUNCT_1:72,SCMPDS_2:100
          .= s2.c by A3,A67,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).c by A66,A69,SCMPDS_2:61
          .= (DataPart Exec (l,s2)).x by A67,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A70:    c = DataLoc(s1.a,k1);
        then
A71:    c = DataLoc(s2.a,k1) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).c by A67,FUNCT_1:72
,SCMPDS_2:100
          .= s1.DataLoc(s1.a,k1)+s1.DataLoc(s1.b,k2) by A66,A70,SCMPDS_2:61
          .= s2.DataLoc(s2.a,k1)+s1.DataLoc(s1.b,k2) by A3,Th3
          .= s2.DataLoc(s2.a,k1)+s2.DataLoc(s2.b,k2) by A3,Th3
          .= (Exec (l,s2)).c by A66,A71,SCMPDS_2:61
          .= (DataPart Exec (l,s2)).x by A67,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A72: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc ) by A10,A9,
FUNCT_1:9,SCMPDS_2:100;
    Exec (l,s1).IC SCMPDS = succ IC s2 by A6,A66,SCMPDS_2:61
      .= Exec (l,s2).IC SCMPDS by A66,SCMPDS_2:61;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A8,
GRFUNC_1:90;
    hence thesis by A72,RELAT_1:185;
  end;
  suppose
    InsCode (l) = 10;
    then consider a,b,k1,k2 such that
A73: l = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
    for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x
    = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A74:  x in SCM-Data-Loc;
      then reconsider c = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A75:    c <>DataLoc(s1.a,k1);
        then
A76:    c <>DataLoc(s2.a,k1) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).c by A74,FUNCT_1:72
,SCMPDS_2:100
          .= s1.c by A73,A75,SCMPDS_2:62
          .= (DataPart s1).c by A74,FUNCT_1:72,SCMPDS_2:100
          .= s2.c by A3,A74,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).c by A73,A76,SCMPDS_2:62
          .= (DataPart Exec (l,s2)).x by A74,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A77:    c = DataLoc(s1.a,k1);
        then
A78:    c = DataLoc(s2.a,k1) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).c by A74,FUNCT_1:72
,SCMPDS_2:100
          .= s1.DataLoc(s1.a,k1)-s1.DataLoc(s1.b,k2) by A73,A77,SCMPDS_2:62
          .= s2.DataLoc(s2.a,k1)-s1.DataLoc(s1.b,k2) by A3,Th3
          .= s2.DataLoc(s2.a,k1)-s2.DataLoc(s2.b,k2) by A3,Th3
          .= (Exec (l,s2)).c by A73,A78,SCMPDS_2:62
          .= (DataPart Exec (l,s2)).x by A74,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A79: DataPart Exec (l,s1) = DataPart Exec (l,s2) by A10,A9,FUNCT_1:9;
    Exec (l,s1).IC SCMPDS = succ IC s2 by A6,A73,SCMPDS_2:62
      .= Exec (l,s2).IC SCMPDS by A73,SCMPDS_2:62;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A8,
GRFUNC_1:90;
    hence thesis by A79,RELAT_1:185,SCMPDS_2:100;
  end;
  suppose
    InsCode (l) = 11;
    then consider a,b,k1,k2 such that
A80: l = MultBy(a,k1,b,k2) by SCMPDS_2:46;
    for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x
    = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A81:  x in SCM-Data-Loc;
      then reconsider c = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A82:    c <>DataLoc(s1.a,k1);
        then
A83:    c <>DataLoc(s2.a,k1) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).c by A81,FUNCT_1:72
,SCMPDS_2:100
          .= s1.c by A80,A82,SCMPDS_2:63
          .= (DataPart s1).c by A81,FUNCT_1:72,SCMPDS_2:100
          .= s2.c by A3,A81,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).c by A80,A83,SCMPDS_2:63
          .= (DataPart Exec (l,s2)).x by A81,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A84:    c = DataLoc(s1.a,k1);
        then
A85:    c = DataLoc(s2.a,k1) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).c by A81,FUNCT_1:72
,SCMPDS_2:100
          .= s1.DataLoc(s1.a,k1) * s1.DataLoc(s1.b,k2) by A80,A84,SCMPDS_2:63
          .= s2.DataLoc(s2.a,k1) * s1.DataLoc(s1.b,k2) by A3,Th3
          .= s2.DataLoc(s2.a,k1) * s2.DataLoc(s2.b,k2) by A3,Th3
          .= (Exec (l,s2)).c by A80,A85,SCMPDS_2:63
          .= (DataPart Exec (l,s2)).x by A81,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A86: DataPart Exec (l,s1) = DataPart Exec (l,s2) by A10,A9,FUNCT_1:9;
    Exec (l,s1).IC SCMPDS = succ IC s2 by A6,A80,SCMPDS_2:63
      .= Exec (l,s2).IC SCMPDS by A80,SCMPDS_2:63;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A8,
GRFUNC_1:90;
    hence thesis by A86,RELAT_1:185,SCMPDS_2:100;
  end;
  suppose
    InsCode (l) = 12;
    then consider a,b,k1,k2 such that
A87: l = Divide(a,k1,b,k2) by SCMPDS_2:47;
    for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x
    = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A88:  x in SCM-Data-Loc;
      then reconsider c = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A89:    c = DataLoc(s1.b,k2);
        then
A90:    c = DataLoc(s2.b,k2) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).c by A88,FUNCT_1:72
,SCMPDS_2:100
          .= s1.DataLoc(s1.a,k1) mod s1.DataLoc(s1.b,k2) by A87,A89,SCMPDS_2:64
          .= s2.DataLoc(s2.a,k1) mod s1.DataLoc(s1.b,k2) by A3,Th3
          .= s2.DataLoc(s2.a,k1) mod s2.DataLoc(s2.b,k2) by A3,Th3
          .= (Exec (l,s2)).c by A87,A90,SCMPDS_2:64
          .= (DataPart Exec (l,s2)).x by A88,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A91:    c <>DataLoc(s1.b,k2);
        then
A92:    c <>DataLoc(s2.b,k2) by A3,Th4;
        hereby
          per cases;
          suppose
A93:        c <> DataLoc(s1.a,k1);
            then
A94:        c <> DataLoc(s2.a,k1) by A3,Th4;
            thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).c by A88,FUNCT_1:72
,SCMPDS_2:100
              .= s1.c by A87,A91,A93,SCMPDS_2:64
              .= s2.c by A3,Th4
              .= (Exec (l,s2)).c by A87,A92,A94,SCMPDS_2:64
              .= (DataPart Exec (l,s2)).x by A88,FUNCT_1:72,SCMPDS_2:100;
          end;
          suppose
A95:        c = DataLoc(s1.a,k1);
            then
A96:        c = DataLoc(s2.a,k1) by A3,Th4;
            thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).c by A88,FUNCT_1:72
,SCMPDS_2:100
              .= s1.DataLoc(s1.a,k1) div s1.DataLoc(s1.b,k2) by A87,A91,A95,
SCMPDS_2:64
              .= s2.DataLoc(s2.a,k1) div s1.DataLoc(s1.b,k2) by A3,Th3
              .= s2.DataLoc(s2.a,k1) div s2.DataLoc(s2.b,k2) by A3,Th3
              .= (Exec (l,s2)).c by A87,A92,A96,SCMPDS_2:64
              .= (DataPart Exec (l,s2)).x by A88,FUNCT_1:72,SCMPDS_2:100;
          end;
        end;
      end;
    end;
    then
A97: DataPart Exec (l,s1) = DataPart Exec (l,s2) by A10,A9,FUNCT_1:9;
    Exec (l,s1).IC SCMPDS = succ IC s2 by A6,A87,SCMPDS_2:64
      .= Exec (l,s2).IC SCMPDS by A87,SCMPDS_2:64;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A8,
GRFUNC_1:90;
    hence thesis by A97,RELAT_1:185,SCMPDS_2:100;
  end;
  suppose
    InsCode (l) = 13;
    then consider a,b,k1,k2 such that
A98: l = (a,k1):=(b,k2) by SCMPDS_2:48;
    for x being set st x in SCM-Data-Loc holds (DataPart Exec (l,s1)).x
    = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A99:  x in SCM-Data-Loc;
      then reconsider c = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A100:   c <>DataLoc(s1.a,k1);
        then
A101:   c <>DataLoc(s2.a,k1) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).c by A99,FUNCT_1:72
,SCMPDS_2:100
          .= s1.c by A98,A100,SCMPDS_2:59
          .= (DataPart s1).c by A99,FUNCT_1:72,SCMPDS_2:100
          .= s2.c by A3,A99,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).c by A98,A101,SCMPDS_2:59
          .= (DataPart Exec (l,s2)).x by A99,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A102:   c = DataLoc(s1.a,k1);
        then
A103:   c = DataLoc(s2.a,k1) by A3,Th4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).c by A99,FUNCT_1:72
,SCMPDS_2:100
          .= s1.DataLoc(s1.b,k2) by A98,A102,SCMPDS_2:59
          .= s2.DataLoc(s2.b,k2) by A3,Th3
          .= (Exec (l,s2)).c by A98,A103,SCMPDS_2:59
          .= (DataPart Exec (l,s2)).x by A99,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A104: DataPart Exec (l,s1) = DataPart Exec (l,s2) by A10,A9,FUNCT_1:9;
    Exec (l,s1).IC SCMPDS = succ IC s2 by A6,A98,SCMPDS_2:59
      .= Exec (l,s2).IC SCMPDS by A98,SCMPDS_2:59;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A8,
GRFUNC_1:90;
    hence thesis by A104,RELAT_1:185,SCMPDS_2:100;
  end;
end;

begin :: Finite partial states of SCMPDS

canceled 6;

theorem
  for s being State of SCMPDS ,iloc being Element of NAT
  , a being Int_position holds s.a = (s +* Start-At(iloc,SCMPDS)).a
proof
  let s be State of SCMPDS, iloc be Element of NAT, a be
  Int_position;
  a in the carrier of SCMPDS;
  then a in dom s by PARTFUN1:def 4;
  then
A1: dom (Start-At(iloc,SCMPDS)) = {IC SCMPDS } &
 a in dom s \/ dom (Start-At(iloc,SCMPDS))
  by FUNCOP_1:19,XBOOLE_0:def 3;
  a <> IC SCMPDS by SCMPDS_2:52;
  then not a in {IC SCMPDS } by TARSKI:def 1;
  hence thesis by A1,FUNCT_4:def 1;
end;

theorem
  for s, t being State of SCMPDS holds s +* t|(SCM-Data-Loc ) is State
  of SCMPDS;

begin :: Autonomic finite partial states of SCMPDS and its computation

definition
  let la be Int_position;
  let a be Integer;
  redefine func la .--> a -> FinPartState of SCMPDS;
  coherence
  proof
    a is Element of INT & ObjectKind la = INT by INT_1:def 2,SCMPDS_2:13;
    hence thesis by COMPOS_1:5;
  end;
end;

theorem Th16:
  for p being autonomic FinPartState of SCMPDS st DataPart p <> {}
  holds IC SCMPDS in dom p
proof
  let p be autonomic FinPartState of SCMPDS;
  assume DataPart p <> {};
  then
A1: dom DataPart p <> {};
  assume
A2: not IC SCMPDS in dom p;
  p is not autonomic
  proof
    consider il being Element of (NAT) \ dom p;
    consider d1 being Element of dom DataPart p;
A3: d1 in dom DataPart p by A1;
    dom DataPart p c= the carrier of SCMPDS by RELAT_1:def 18;
    then reconsider d1 as Element of SCMPDS by A3;
    not NAT c= dom p;
    then
A4: (NAT) \ dom p <> {} by XBOOLE_1:37;
    then il is Element of NAT by XBOOLE_0:def 5;
    then reconsider il as Element of NAT;
    not il in dom p by A4,XBOOLE_0:def 5;
    then
A5: dom p misses {il} by ZFMISC_1:56;
    dom DataPart p c= SCM-Data-Loc by RELAT_1:87,SCMPDS_2:100;
    then reconsider d1 as Int_position by A3,SCMPDS_2:9;
A6: dom (Start-At(il,SCMPDS)) = {IC SCMPDS} by FUNCOP_1:19;
    then
A7: IC SCMPDS in dom (Start-At(il,SCMPDS)) by TARSKI:def 1;
    il <> IC SCMPDS by COMPOS_1:3;
    then
A8: not il in dom (Start-At(il,SCMPDS)) by A6,TARSKI:def 1;
A9: dom p misses {IC SCMPDS} by A2,ZFMISC_1:56;
    set p2 = p +* ((il .--> (d1:=1)) +* Start-At(il,SCMPDS));
    set p1 = p +* ((il .--> (d1:=0)) +* Start-At(il,SCMPDS));
    consider s1 being State of SCMPDS such that
A10: p1 c= s1 by PBOOLE:156;
    consider s2 being State of SCMPDS such that
A11: p2 c= s2 by PBOOLE:156;
    take s1,s2;
    dom ((il .--> (d1:=0)) +* Start-At(il,SCMPDS))
     = dom (il .--> (d1:=0)) \/ dom
    (Start-At(il,SCMPDS)) by FUNCT_4:def 1
      .= dom (il .--> (d1:=0)) \/ { IC SCMPDS } by FUNCOP_1:19
      .= {il} \/ { IC SCMPDS } by FUNCOP_1:19;
    then dom p /\ dom ((il .--> (d1:=0)) +* Start-At(il,SCMPDS))
     = dom p /\ {il} \/
    dom p /\ {IC SCMPDS} by XBOOLE_1:23
      .= dom p /\ {il} \/ {} by A9,XBOOLE_0:def 7
      .= {} by A5,XBOOLE_0:def 7;
    then dom p misses dom ((il .--> (d1:=0)) +* Start-At(il,SCMPDS))
    by XBOOLE_0:def 7;
    then p c= p1 by FUNCT_4:33;
    hence p c= s1 by A10,XBOOLE_1:1;
    dom ((il .--> (d1:=1)) +* Start-At(il,SCMPDS))
     = dom (il .--> (d1:=1)) \/ dom
    (Start-At(il,SCMPDS)) by FUNCT_4:def 1
      .= dom (il .--> (d1:=1)) \/ { IC SCMPDS } by FUNCOP_1:19
      .= {il} \/ { IC SCMPDS } by FUNCOP_1:19;
    then dom p /\ dom ((il .--> (d1:=1)) +* Start-At(il,SCMPDS))
     = dom p /\ {il} \/
    dom p /\ {IC SCMPDS} by XBOOLE_1:23
      .= dom p /\ {il} \/ {} by A9,XBOOLE_0:def 7
      .= {} by A5,XBOOLE_0:def 7;
    then dom p misses dom ((il .--> (d1:=1)) +* Start-At(il,SCMPDS))
    by XBOOLE_0:def 7;
    then p c= p2 by FUNCT_4:33;
    hence p c= s2 by A11,XBOOLE_1:1;
    take 1;
A12: dom p2 = dom p \/ dom ((il .--> (d1:=1)) +* Start-At(il,SCMPDS))
by FUNCT_4:def 1;
A13: dom ((il .--> (d1:=1)) +* Start-At(il,SCMPDS)) =
 dom ((il .--> (d1:=1))) \/
    dom (Start-At(il,SCMPDS)) by FUNCT_4:def 1;
    then
A14: IC SCMPDS in dom ((il .--> (d1:=1)) +* Start-At(il,SCMPDS))
by A7,XBOOLE_0:def 3;
    then IC SCMPDS in dom p2 by A12,XBOOLE_0:def 3;
    then
A15: IC s2 = p2.IC SCMPDS by A11,GRFUNC_1:8
      .= ((il .--> (d1:=1)) +* Start-At(il,SCMPDS)).IC SCMPDS by A14,FUNCT_4:14
      .= (Start-At(il,SCMPDS)).IC SCMPDS by A7,FUNCT_4:14
      .= il by FUNCOP_1:87;
    dom (il .--> (d1:=1)) = {il} by FUNCOP_1:19;
    then il in dom (il .--> (d1:=1)) by TARSKI:def 1;
    then
A16: il in dom ((il .--> (d1:=1)) +* Start-At(il,SCMPDS))
by A13,XBOOLE_0:def 3;
    then il in dom p2 by A12,XBOOLE_0:def 3;
    then
A17: s2.il = p2.il by A11,GRFUNC_1:8
      .= ((il .--> (d1:=1)) +* Start-At(il,SCMPDS)).il by A16,FUNCT_4:14
      .= (il .--> (d1:=1)).il by A8,FUNCT_4:12
      .=(d1:=1) by FUNCOP_1:87;
Y:  (ProgramPart s2)/.IC s2
 = s2.IC s2 by COMPOS_1:38;
A18: Comput(ProgramPart(s2),s2,0+1).d1 =
(Following(ProgramPart s2,Comput(ProgramPart(s2),s2,0
))).d1
by EXTPRO_1:4
      .= (Following(ProgramPart s2,s2)).d1 by EXTPRO_1:3
      .= 1 by A15,A17,Y,SCMPDS_2:57;
X:  dom p c= the carrier of SCMPDS by RELAT_1:def 18;
    dom (Comput(ProgramPart(s1),s1,1)) = the carrier of SCMPDS by
PARTFUN1:def 4;
    then
A19: dom (Comput(ProgramPart(s1),s1,1)|dom p) = dom p by X,RELAT_1:91;
    il <> IC SCMPDS by COMPOS_1:3;
    then
A20: not il in dom (Start-At(il,SCMPDS)) by A6,TARSKI:def 1;
    dom (Comput(ProgramPart(s2),s2,1)) = the carrier of SCMPDS by
PARTFUN1:def 4;
    then
A21: dom (Comput(ProgramPart(s2),s2,1)|dom p) = dom p by X,RELAT_1:91;
A22: dom p1 = dom p \/ dom ((il .--> (d1:=0)) +* Start-At(il,SCMPDS))
by FUNCT_4:def 1;
A23: dom ((il .--> (d1:=0)) +* Start-At(il,SCMPDS)) =
dom ((il .--> (d1:=0))) \/
    dom (Start-At(il,SCMPDS)) by FUNCT_4:def 1;
    then
A24: IC SCMPDS in dom ((il .--> (d1:=0)) +* Start-At(il,SCMPDS))
by A7,XBOOLE_0:def 3;
    then IC SCMPDS in dom p1 by A22,XBOOLE_0:def 3;
    then
A25: IC s1 = p1.IC SCMPDS by A10,GRFUNC_1:8
      .= ((il .--> (d1:=0)) +* Start-At(il,SCMPDS)).IC SCMPDS by A24,FUNCT_4:14
      .= (Start-At(il,SCMPDS)).IC SCMPDS by A7,FUNCT_4:14
      .= il by FUNCOP_1:87;
    dom (il .--> (d1:=0)) = {il} by FUNCOP_1:19;
    then il in dom (il .--> (d1:=0)) by TARSKI:def 1;
    then
A26: il in dom ((il .--> (d1:=0)) +* Start-At(il,SCMPDS))
by A23,XBOOLE_0:def 3;
    then il in dom p1 by A22,XBOOLE_0:def 3;
    then
A27: s1.il = p1.il by A10,GRFUNC_1:8
      .= ((il .--> (d1:=0)) +* Start-At(il,SCMPDS)).il by A26,FUNCT_4:14
      .= (il .--> (d1:=0)).il by A20,FUNCT_4:12
      .=(d1:=0) by FUNCOP_1:87;
    DataPart p c= p by RELAT_1:88;
    then
A28: dom DataPart p c= dom p by RELAT_1:25;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by COMPOS_1:38;
    Comput(ProgramPart(s1),s1,0+1).d1 =
    (Following(ProgramPart s1,Comput(ProgramPart(s1),
s1,0))).d1
    by EXTPRO_1:4
      .= (Following(ProgramPart s1,s1)).d1 by EXTPRO_1:3
      .= 0 by A25,A27,Y,SCMPDS_2:57;
    then (Comput(ProgramPart(s1),s1,1)|dom p).d1 = 0 by A3,A28,A19,FUNCT_1:70;
    hence thesis by A3,A28,A21,A18,FUNCT_1:70;
  end;
  hence contradiction;
end;

theorem Th17:
  for p being autonomic non NAT-defined FinPartState of SCMPDS
  holds IC SCMPDS in dom p
proof
  let p be autonomic non NAT-defined FinPartState of SCMPDS;
   dom p c= the carrier of SCMPDS by RELAT_1:def 18;
   then
A1: dom p = dom p /\ the carrier of SCMPDS by XBOOLE_1:28
    .= dom p /\ (SCM-Data-Loc \/ {IC SCMPDS }) \/ dom p /\ NAT by AMI_3:4
,XBOOLE_1:23;
  not dom p c= NAT by RELAT_1:def 18;
  then dom p /\ (SCM-Data-Loc \/ {IC SCMPDS }) <> {} by A1,XBOOLE_1:17;
  then
A2: dom p /\ {IC SCMPDS } \/ dom p /\ (SCM-Data-Loc ) <> {} by XBOOLE_1:23;
  per cases by A2;
  suppose
    dom p /\ {IC SCMPDS } <> {};
    then dom p meets {IC SCMPDS } by XBOOLE_0:def 7;
    hence thesis by ZFMISC_1:56;
  end;
  suppose
    dom p /\ (SCM-Data-Loc ) <> {};
    then DataPart p <> {} by RELAT_1:60,90,SCMPDS_2:100;
    hence thesis by Th16;
  end;
end;

theorem Th18:
  for s1,s2 being State of SCMPDS,k1,k2,m be Integer st IC s1= IC
  s2 & k1 <> k2 & m=IC s1 & m+k1 >= 0 & m+k2 >= 0 holds ICplusConst(s1,k1) <>
  ICplusConst(s2,k2)
proof
  let s1,s2 be State of SCMPDS,k1,k2,m be Integer;
  assume that
A1: IC s1 = IC s2 and
A2: k1<>k2 and
A3: m=IC s1 and
A4: m+k1 >= 0 and
A5: m+k2 >= 0;
  ex i being Element of NAT st i = IC s1 & ICplusConst(s1, k1)=abs(i+k1) by
SCMPDS_2:def 20;
  then
A6: ICplusConst(s1,k1)=m+k1 by A3,A4,ABSVALUE:def 1;
  assume
A7: ICplusConst(s1,k1) = ICplusConst(s2,k2);
  ex j being Element of NAT st j = IC s2 & ICplusConst(s2, k2)=abs(j+k2) by
SCMPDS_2:def 20;
  then ICplusConst(s2,k2)=m+k2 by A1,A3,A5,ABSVALUE:def 1;
  hence contradiction by A2,A7,A6;
end;

theorem Th19:
  for s1,s2 being State of SCMPDS,k1,k2 be Element of NAT st IC s1
  = IC s2 & k1 <> k2 holds ICplusConst(s1,k1) <> ICplusConst(s2,k2)
proof
  let s1,s2 be State of SCMPDS,k1,k2 be Element of NAT;
  reconsider m=IC s1 as Element of NAT;
  set mm=m+2;
  mm-2+k1=m+k1;
  then
A1: mm-2+k1>=0 by NAT_1:2;
  mm-2+k2=m+k2;
  then
A2: mm-2+k2>=0 by NAT_1:2;
  assume IC s1 = IC s2 & k1<>k2;
  hence thesis by A1,A2,Th18;
end;

theorem Th20:
  for s being State of SCMPDS holds succ IC s= ICplusConst(s,1)
proof
  let s be State of SCMPDS;
  consider j such that
A1: j = IC s and
A2: ICplusConst(s,1)=abs(j+1) by SCMPDS_2:def 20;
  reconsider mj = IC s as Element of NAT;
A3: j*1 >= 0 by NAT_1:2;
  j >= 0 by NAT_1:2;
  then succ IC s = abs(mj)+1 by A1,ABSVALUE:def 1
    .= abs(mj)+abs(1) by ABSVALUE:def 1
    .= abs(mj+1) by A1,A3,ABSVALUE:24;
  hence thesis by A1,A2;
end;

theorem
  for p being autonomic FinPartState of SCMPDS st IC SCMPDS in dom p
  holds IC p in dom p
proof
  let p be autonomic FinPartState of SCMPDS;
  assume
A1: IC SCMPDS in dom p;
  set il = IC p;
  set p1 = p +* ((il .--> goto 0));
  set p2 = p +* ((il .--> goto 1));
  consider s1 being State of SCMPDS such that
A2: p1 c= s1 by PBOOLE:156;
  consider s2 being State of SCMPDS such that
A3: p2 c= s2 by PBOOLE:156;
  assume
A4: not IC p in dom p;
  p is not autonomic
  proof
    take s1,s2;
A5: dom (il .--> (goto 1)) = {il} by FUNCOP_1:19;
    then
A6: il in dom (il .--> (goto 1)) by TARSKI:def 1;
A7: dom (il .--> (goto 0)) = {il} by FUNCOP_1:19;
    then
A8: il in dom (il .--> (goto 0)) by TARSKI:def 1;
A9: dom p misses {il} by A4,ZFMISC_1:56;
    then
A10: p c= p1 by A7,FUNCT_4:33;
A11: p c= p2 by A5,A9,FUNCT_4:33;
    hence p c= s1 & p c= s2 by A2,A3,A10,XBOOLE_1:1;
    dom p2 = dom p \/ dom ((il .--> goto 1)) by FUNCT_4:def 1;
    then il in dom p2 by A6,XBOOLE_0:def 3;
    then
X:    s2.il = p2.il by A3,GRFUNC_1:8
      .= ((il .--> goto 1)).il by A6,FUNCT_4:14
      .= goto 1 by FUNCOP_1:87;
Y:  (ProgramPart s2)/.IC s2
 = s2.IC s2 by COMPOS_1:38;
x:  p c= s2 by A3,A11,XBOOLE_1:1;
    then
A12: (Following(ProgramPart s2,s2)).IC SCMPDS = Exec (goto 1,s2).IC SCMPDS
by A1,X,Y,GRFUNC_1:8
      .= ICplusConst(s2,1) by SCMPDS_2:66;
    take 1;
    assume
A13: Comput(ProgramPart(s1),s1,1)|dom p = Comput(ProgramPart(s2),s2,1)|dom p;
A14: (Following(ProgramPart s1,s1))|dom p =
(Following(ProgramPart s1,Comput(ProgramPart(s1),s1,0
)))|dom p
by EXTPRO_1:3
      .= Comput(ProgramPart(s1),s1,0+1)|dom p by EXTPRO_1:4
      .= (Following(ProgramPart s2,Comput(ProgramPart
(s2),s2,0)))|dom p
      by A13,EXTPRO_1:4
      .= (Following(ProgramPart s2,s2))|dom p by EXTPRO_1:3;
    dom p1 = dom p \/ dom ((il .--> goto 0)) by FUNCT_4:def 1;
    then il in dom p1 by A8,XBOOLE_0:def 3;
    then
Y:   s1.il = p1.il by A2,GRFUNC_1:8
      .= ((il .--> goto 0)).il by A8,FUNCT_4:14
      .= goto 0 by FUNCOP_1:87;
Z:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by COMPOS_1:38;
y:  p c= s1 by A2,A10,XBOOLE_1:1;
    then (Following(ProgramPart s1,s1)).IC SCMPDS =
    Exec (goto 0,s1).IC SCMPDS by A1,Y,Z,GRFUNC_1:8
      .= ICplusConst(s1,0) by SCMPDS_2:66;
    then
A15: ICplusConst(s1,0) = ((Following(ProgramPart s1,s1))|dom p).IC SCMPDS
by A1,FUNCT_1:72
      .= ICplusConst(s2,1) by A1,A12,A14,FUNCT_1:72;
    IC s2 = il by A1,x,GRFUNC_1:8
      .= IC s1 by A1,y,GRFUNC_1:8;
    hence contradiction by A15,Th19;
  end;
  hence contradiction;
end;

theorem Th22:
  for p being autonomic non NAT-defined FinPartState of SCMPDS , s
being State of SCMPDS st p c= s for i being Element of NAT holds IC Comput(
ProgramPart(s),s,i) in dom ProgramPart(p)
proof
  let p be autonomic non NAT-defined FinPartState of SCMPDS, s be State of
  SCMPDS such that
A1: p c= s;
  let i be Element of NAT;
  set Csi = Comput(ProgramPart(s),s,i);
  set loc = IC Csi;
A3: loc in dom ProgramPart p iff loc in dom p /\ NAT by RELAT_1:90;
  assume not IC Comput(ProgramPart(s),s,i) in dom ProgramPart(p);
  then
A4: not loc in dom p by A3,XBOOLE_0:def 4;
  set p2 = p +* (loc .--> goto 1 );
  set p1 = p +* (loc .--> goto 0 );
A5: dom p1 = dom p \/ dom (loc .--> goto 0 ) by FUNCT_4:def 1;
A6: dom (loc .--> goto 1 ) = {loc} by FUNCOP_1:19;
  then
A7: loc in dom (loc .--> goto 1) by TARSKI:def 1;
A8: dom p2 = dom p \/ dom (loc .--> goto 1 ) by FUNCT_4:def 1;
  then
A9: loc in dom p2 by A7,XBOOLE_0:def 3;
  consider s2 being State of SCMPDS such that
A10: p2 c= s2 by PBOOLE:156;
  set Cs2i = Comput(ProgramPart(s2),s2,i);
  consider s1 being State of SCMPDS such that
A11: p1 c= s1 by PBOOLE:156;
  set Cs1i = Comput(ProgramPart(s1),s1,i);
A12: dom (loc .--> goto 0 ) = {loc} by FUNCOP_1:19;
  then
A13: loc in dom (loc .--> goto 0 ) by TARSKI:def 1;
  then
A14: loc in dom p1 by A5,XBOOLE_0:def 3;
  p is not autonomic
  proof
A15: now
      let x be set;
      assume
A16:  x in dom p;
      dom p misses dom (loc .--> goto 1 ) by A4,A6,ZFMISC_1:56;
      then
A17:  p.x = p2.x by A16,FUNCT_4:17;
      x in dom p2 by A8,A16,XBOOLE_0:def 3;
      hence p.x = s2.x by A10,A17,GRFUNC_1:8;
    end;
    (loc .--> goto 1 ).loc = goto 1 by FUNCOP_1:87;
    then p2.loc = goto 1 by A7,FUNCT_4:14;
    then s2.loc = goto 1 by A9,A10,GRFUNC_1:8;
    then
A18: Cs2i.loc = goto 1 by AMI_1:54;
    (loc .--> goto 0 ).loc = goto 0 by FUNCOP_1:87;
    then p1.loc = goto 0 by A13,FUNCT_4:14;
    then s1.loc = goto 0 by A14,A11,GRFUNC_1:8;
    then
A19: Cs1i.loc = goto 0 by AMI_1:54;
    take s1, s2;
A20: now
      let x be set;
      assume
A21:  x in dom p;
      dom p misses dom (loc .--> goto 0 ) by A4,A12,ZFMISC_1:56;
      then
A22:  p.x = p1.x by A21,FUNCT_4:17;
      x in dom p1 by A5,A21,XBOOLE_0:def 3;
      hence p.x = s1.x by A11,A22,GRFUNC_1:8;
    end;
    dom s1 = the carrier of SCMPDS by PARTFUN1:def 4;
    then dom p c= dom s1 by RELAT_1:def 18;
    hence
A23: p c= s1 by A20,GRFUNC_1:8;
    then
A24: (Cs1i|dom p) = (Csi|dom p) by A1,EXTPRO_1:def 9;
    dom s2 = the carrier of SCMPDS by PARTFUN1:def 4;
    then dom p c= dom s2 by RELAT_1:def 18;
    hence p c= s2 by A15,GRFUNC_1:8;
    then
A25: (Cs1i|dom p) = (Cs2i|dom p) by A23,EXTPRO_1:def 9;
    take k = i+1;
    set Cs2k = Comput(ProgramPart(s2),s2,k);
T: ProgramPart s2 = ProgramPart Cs2i
by AMI_1:123;
A26: Cs2k = Following(ProgramPart s2,Cs2i) by EXTPRO_1:4
      .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by T;
Y:  (ProgramPart Cs2i)/.IC Cs2i
 = Cs2i.IC Cs2i by COMPOS_1:38;
A27: Csi.IC SCMPDS = (Csi|dom p).IC SCMPDS by Th17,FUNCT_1:72;
    then Cs2i.IC SCMPDS = loc by A24,A25,Th17,FUNCT_1:72;
    then
A28: Cs2k.IC SCMPDS = ICplusConst(Cs2i,1) by A26,A18,Y,SCMPDS_2:66;
A29: Cs1i.IC SCMPDS = (Cs1i|dom p).IC SCMPDS by Th17,FUNCT_1:72;
    then
A30: IC Cs1i = IC Cs2i by A25,Th17,FUNCT_1:72;
    set Cs1k = Comput(ProgramPart(s1),s1,k);
A31: (Cs1k|dom p).IC SCMPDS = Cs1k.IC SCMPDS & (Cs2k|dom p).IC SCMPDS =
    Cs2k.IC SCMPDS by Th17,FUNCT_1:72;
Y:  (ProgramPart Cs1i)/.IC Cs1i
 = Cs1i.IC Cs1i by COMPOS_1:38;
T: ProgramPart s1 = ProgramPart Cs1i
by AMI_1:123;
    Cs1k = Following(ProgramPart s1,Cs1i) by EXTPRO_1:4
      .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by T;
    then Cs1k.IC SCMPDS = ICplusConst(Cs1i,0) by A19,A24,A29,A27,Y,SCMPDS_2:66;
    hence thesis by A28,A30,A31,Th19;
  end;
  hence contradiction;
end;

theorem Th23:
  for p being autonomic non NAT-defined FinPartState of SCMPDS ,
  s1, s2 being State of SCMPDS st p c= s1 & p c= s2 for i being Element of NAT
holds IC Comput(ProgramPart(s1),s1,i) = IC Comput(ProgramPart(s2),s2,i) &
 CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(s1),s1,i)
)
  = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),s2
,i))
proof
  let p be autonomic non NAT-defined FinPartState of SCMPDS , s1, s2 be State
  of SCMPDS such that
A1: p c= s1 and
A2: p c= s2;
  let i be Element of NAT;
  set Cs1i = Comput(ProgramPart(s1),s1,i);
  set Cs2i = Comput(ProgramPart(s2),s2,i);
  thus
A3: IC Cs1i = IC Cs2i
  proof
    assume
A4: IC Comput(ProgramPart(s1),s1,i) <> IC Comput(ProgramPart(s2),s2,i);
    (Cs1i|dom p).IC SCMPDS = Cs1i.IC SCMPDS & (Cs2i|dom p).IC SCMPDS =
    Cs2i.IC SCMPDS by Th17,FUNCT_1:72;
    hence contradiction by A1,A2,A4,EXTPRO_1:def 9;
  end;
  set I = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(
s1),s1,i));
  thus I = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart
(s2),s2,i))
  proof
    ProgramPart p c= p by RELAT_1:88;
    then
A5: dom ProgramPart p c= dom p by GRFUNC_1:8;
    IC Cs2i in dom ProgramPart p by A2,Th22;
    then
A6: (Cs2i|dom p).IC Cs2i = Cs2i.IC Cs2i by A5,FUNCT_1:72;
    IC Cs1i in dom ProgramPart p by A1,Th22;
    then
A7: (Cs1i|dom p).IC Cs1i = Cs1i.IC Cs1i by A5,FUNCT_1:72;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,i))/.IC Comput(ProgramPart(s2),s2,i)
 = Comput(ProgramPart(s2),s2,i).IC Comput(ProgramPart(s2),s2,i) by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s1),s1,i))/.IC Comput(ProgramPart(s1),s1,i)
 = Comput(ProgramPart(s1),s1,i).IC Comput(ProgramPart(s1),s1,i) by COMPOS_1:38;
    assume
ZZ:    I <> CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(
ProgramPart(s2),s2,i));
      Comput(ProgramPart(s1),s1,i)|dom p = Comput(ProgramPart(s2),s2,i)|dom p
                            by A1,A2,EXTPRO_1:def 9;
    hence contradiction by A3,A7,A6,Y,ZZ,Z;
  end;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCMPDS, s1, s2
being State of SCMPDS st p c= s1 & p c= s2 for i being Element of NAT,k1,k2 be
Integer,a,b be Int_position st CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i
),
Comput(ProgramPart(s1),s1,i)) = (a,k1) := (b,k2)
& a in dom p & DataLoc(Comput(ProgramPart(s1),s1,i).a,k1) in dom p holds Comput
(ProgramPart(s1),s1,i)
.DataLoc(Comput(ProgramPart(s1),s1,i).b,k2) = Comput(ProgramPart(s2),s2,i).
DataLoc(Comput(ProgramPart(s2),s2,i).
  b,k2)
proof
  let p be autonomic non NAT-defined FinPartState of SCMPDS, s1, s2 be State
  of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT,k1,k2 be Integer,a,b be Int_position;
  set I = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(
s1),s1,i));
  set Cs1i = Comput(ProgramPart(s1),s1,i);
  set Cs2i = Comput(ProgramPart(s2),s2,i);
  assume that
A2: I = (a,k1) := (b,k2) and
A3: a in dom p and
A4: DataLoc(Cs1i.a,k1) in dom p;
  a in dom p implies (Cs1i|dom p).a = Cs1i.a & (Cs2i|dom p).a = Cs2i.a by
FUNCT_1:72;
  then
A5: Cs1i.a=Cs2i.a by A1,A3,EXTPRO_1:def 9;
  set Cs1i1 = Comput(ProgramPart(s1),s1,i+1);
T: ProgramPart s1 = ProgramPart Cs1i
by AMI_1:123;
  Cs1i1 = Following(ProgramPart s1,Cs1i) by EXTPRO_1:4
    .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by T;
  then
A6: Cs1i1.DataLoc(Cs1i.a,k1) = Cs1i.DataLoc(Cs1i.b,k2) by A2,SCMPDS_2:59;
  set Cs2i1 = Comput(ProgramPart(s2),s2,i+1);
T: ProgramPart s2 = ProgramPart Cs2i
by AMI_1:123;
A7: Cs2i1 = Following(ProgramPart s2,Cs2i) by EXTPRO_1:4
    .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by T;
A8: DataLoc(Cs1i.a,k1) in dom p implies (Cs1i1|dom p).DataLoc(Cs1i.a,k1) =
  Cs1i1.DataLoc(Cs1i.a,k1) & (Cs2i1|dom p).DataLoc(Cs1i.a,k1) = Cs2i1.DataLoc(
  Cs1i.a,k1) by FUNCT_1:72;
  I = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),
s2,i)) by A1,Th23;
  then Cs2i1.DataLoc(Cs2i.a,k1) = Cs2i.DataLoc(Cs2i.b,k2) by A7,A2,SCMPDS_2:59;
  hence thesis by A1,A8,A4,A5,A6,EXTPRO_1:def 9;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCMPDS, s1, s2
being State of SCMPDS st p c= s1 & p c= s2 for i being Element of NAT,k1,k2 be
Integer,a,b be Int_position st CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i
),
Comput(ProgramPart(s1),s1,i)) = AddTo(a,k1,b,k2)
& a in dom p & DataLoc(Comput(ProgramPart(s1),s1,i).a,k1) in dom p holds Comput
(ProgramPart(s1),s1,i)
.DataLoc(Comput(ProgramPart(s1),s1,i).b,k2) = Comput(ProgramPart(s2),s2,i).
DataLoc(Comput(ProgramPart(s2),s2,i).
  b,k2)
proof
  let p be autonomic non NAT-defined FinPartState of SCMPDS, s1, s2 be State
  of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT,k1,k2 be Integer,a,b be Int_position;
  set I = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(
s1),s1,i));
  set Cs1i = Comput(ProgramPart(s1),s1,i);
  set Cs2i = Comput(ProgramPart(s2),s2,i);
  assume that
A2: I = AddTo(a,k1,b,k2) and
A3: a in dom p and
A4: DataLoc(Cs1i.a,k1) in dom p;
  a in dom p implies (Cs1i|dom p).a = Cs1i.a & (Cs2i|dom p).a = Cs2i.a by
FUNCT_1:72;
  then
A5: Cs1i.a=Cs2i.a by A1,A3,EXTPRO_1:def 9;
  set Cs2i1 = Comput(ProgramPart(s2),s2,i+1);
  set Cs1i1 = Comput(ProgramPart(s1),s1,i+1);
  set D11=Cs1i1.DataLoc(Cs1i.a,k1), D21=Cs2i1.DataLoc(Cs2i.a,k1), C11=Cs1i.
  DataLoc(Cs1i.a,k1), C12=Cs1i.DataLoc(Cs1i.b,k2), C21=Cs2i.DataLoc(Cs2i.a,k1),
  C22=Cs2i.DataLoc(Cs2i.b,k2);
T: ProgramPart s2 = ProgramPart Cs2i
by AMI_1:123;
A6: Cs2i1 = Following(ProgramPart s2,Cs2i) by EXTPRO_1:4
    .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by T;
  DataLoc(Cs1i.a,k1) in dom p implies (Cs1i1|dom p).DataLoc(Cs1i.a,k1) =
  Cs1i1.DataLoc(Cs1i.a,k1) & (Cs2i1|dom p).DataLoc(Cs1i.a,k1) = Cs2i1.DataLoc(
  Cs1i.a,k1) by FUNCT_1:72;
  then
A7: D11 = D21 by A1,A4,A5,EXTPRO_1:def 9;
T: ProgramPart s1 = ProgramPart Cs1i
by AMI_1:123;
  Cs1i1 = Following(ProgramPart s1,Cs1i) by EXTPRO_1:4
    .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by T;
  then
A8: D11 = C11+ C12 by A2,SCMPDS_2:61;
  DataLoc(Cs1i.a,k1) in dom p implies (Cs1i|dom p).DataLoc(Cs1i.a,k1) =
Cs1i.DataLoc(Cs1i.a,k1) & (Cs2i|dom p).DataLoc(Cs1i.a,k1) = Cs2i.DataLoc(Cs1i.a
  ,k1) by FUNCT_1:72;
  then
A9: C11=C21 by A1,A4,A5,EXTPRO_1:def 9;
  I = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),
s2,i)) by A1,Th23;
  then D21 = C21 + C22 by A6,A2,SCMPDS_2:61;
  hence thesis by A9,A7,A8;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCMPDS, s1, s2
being State of SCMPDS st p c= s1 & p c= s2 for i being Element of NAT,k1,k2 be
Integer,a,b be Int_position st CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i
),
Comput(ProgramPart(s1),s1,i)) = SubFrom(a,k1,b,k2
) & a in dom p & DataLoc(Comput(ProgramPart(s1),s1,i).a,k1) in dom p holds
Comput(ProgramPart(s1),s1,
i).DataLoc(Comput(ProgramPart(s1),s1,i).b,k2) = Comput(ProgramPart(s2),s2,i).
DataLoc(Comput(ProgramPart(s2),s2,i
  ).b,k2)
proof
  let p be autonomic non NAT-defined FinPartState of SCMPDS, s1, s2 be State
  of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT,k1,k2 be Integer,a,b be Int_position;
  set I = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(
s1),s1,i));
  set Cs1i = Comput(ProgramPart(s1),s1,i);
  set Cs2i = Comput(ProgramPart(s2),s2,i);
  assume that
A2: I = SubFrom(a,k1,b,k2) and
A3: a in dom p and
A4: DataLoc(Cs1i.a,k1) in dom p;
  a in dom p implies (Cs1i|dom p).a = Cs1i.a & (Cs2i|dom p).a = Cs2i.a by
FUNCT_1:72;
  then
A5: Cs1i.a=Cs2i.a by A1,A3,EXTPRO_1:def 9;
  set Cs2i1 = Comput(ProgramPart(s2),s2,i+1);
  set Cs1i1 = Comput(ProgramPart(s1),s1,i+1);
  set D11=Cs1i1.DataLoc(Cs1i.a,k1), D21=Cs2i1.DataLoc(Cs2i.a,k1), C11=Cs1i.
  DataLoc(Cs1i.a,k1), C12=Cs1i.DataLoc(Cs1i.b,k2), C21=Cs2i.DataLoc(Cs2i.a,k1),
  C22=Cs2i.DataLoc(Cs2i.b,k2);
T: ProgramPart s2 = ProgramPart Cs2i
by AMI_1:123;
A6: Cs2i1 = Following(ProgramPart s2,Cs2i) by EXTPRO_1:4
    .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by T;
  DataLoc(Cs1i.a,k1) in dom p implies (Cs1i1|dom p).DataLoc(Cs1i.a,k1) =
  Cs1i1.DataLoc(Cs1i.a,k1) & (Cs2i1|dom p).DataLoc(Cs1i.a,k1) = Cs2i1.DataLoc(
  Cs1i.a,k1) by FUNCT_1:72;
  then
A7: D11 = D21 by A1,A4,A5,EXTPRO_1:def 9;
T: ProgramPart s1 = ProgramPart Cs1i
by AMI_1:123;
  Cs1i1 = Following(ProgramPart s1,Cs1i) by EXTPRO_1:4
    .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by T;
  then
A8: D11 = C11- C12 by A2,SCMPDS_2:62;
  DataLoc(Cs1i.a,k1) in dom p implies (Cs1i|dom p).DataLoc(Cs1i.a,k1) =
Cs1i.DataLoc(Cs1i.a,k1) & (Cs2i|dom p).DataLoc(Cs1i.a,k1) = Cs2i.DataLoc(Cs1i.a
  ,k1) by FUNCT_1:72;
  then
A9: C11=C21 by A1,A4,A5,EXTPRO_1:def 9;
  I = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),
s2,i)) by A1,Th23;
  then D21 = C21 - C22 by A6,A2,SCMPDS_2:62;
  hence thesis by A9,A7,A8;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCMPDS, s1, s2
being State of SCMPDS st p c= s1 & p c= s2 for i being Element of NAT,k1,k2 be
Integer,a,b be Int_position st CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i
),
Comput(ProgramPart(s1),s1,i)) = MultBy(a,k1,b,k2)
& a in dom p & DataLoc(Comput(ProgramPart(s1),s1,i).a,k1) in dom p holds Comput
(ProgramPart(s1),s1,i)
.DataLoc(Comput(ProgramPart(s1),s1,i).a,k1) * Comput(ProgramPart(s1),s1,i).
DataLoc(Comput(ProgramPart(s1),s1,i).
b,k2) = Comput(ProgramPart(s2),s2,i).DataLoc(Comput(ProgramPart(s2),s2,i).a,k1)
* Comput(ProgramPart(s2),s2,i).
  DataLoc(Comput(ProgramPart(s2),s2,i).b,k2)
proof
  let p be autonomic non NAT-defined FinPartState of SCMPDS, s1, s2 be State
  of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT,k1,k2 be Integer,a,b be Int_position;
  set I = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(
s1),s1,i));
  set Cs1i = Comput(ProgramPart(s1),s1,i);
  set Cs2i = Comput(ProgramPart(s2),s2,i);
  assume that
A2: I = MultBy (a,k1,b,k2) and
A3: a in dom p and
A4: DataLoc(Cs1i.a,k1) in dom p;
  a in dom p implies (Cs1i|dom p).a = Cs1i.a & (Cs2i|dom p).a = Cs2i.a by
FUNCT_1:72;
  then
A5: Cs1i.a=Cs2i.a by A1,A3,EXTPRO_1:def 9;
  set Cs2i1 = Comput(ProgramPart(s2),s2,i+1);
  set Cs1i1 = Comput(ProgramPart(s1),s1,i+1);
  set D11=Cs1i1.DataLoc(Cs1i.a,k1), D21=Cs2i1.DataLoc(Cs2i.a,k1);
T: ProgramPart s1 = ProgramPart Cs1i
by AMI_1:123;
  Cs1i1 = Following(ProgramPart s1,Cs1i) by EXTPRO_1:4
    .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by T;
  then
A6: D11 = Cs1i.DataLoc(Cs1i.a,k1) * Cs1i.DataLoc(Cs1i.b,k2) by A2,SCMPDS_2:63;
T: ProgramPart s2 = ProgramPart Cs2i
by AMI_1:123;
A7: Cs2i1 = Following(ProgramPart s2,Cs2i) by EXTPRO_1:4
    .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by T;
A8: DataLoc(Cs1i.a,k1) in dom p implies (Cs1i1|dom p).DataLoc(Cs1i.a,k1) =
  Cs1i1.DataLoc(Cs1i.a,k1) & (Cs2i1|dom p).DataLoc(Cs1i.a,k1) = Cs2i1.DataLoc(
  Cs1i.a,k1) by FUNCT_1:72;
  I = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),
s2,i)) by A1,Th23;
  then D21 = Cs2i.DataLoc(Cs2i.a,k1) * Cs2i.DataLoc(Cs2i.b,k2) by A7,A2,
SCMPDS_2:63;
  hence thesis by A1,A8,A4,A5,A6,EXTPRO_1:def 9;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCMPDS, s1, s2
being State of SCMPDS st p c= s1 & p c= s2 for i,m being Element of NAT,a being
Int_position,k1,k2 be Integer st CurInstr(ProgramPart Comput(ProgramPart(s1),s1
,i),
Comput(ProgramPart(s1),s1,i)) = (a,k1)<>0_goto
  k2 & m= IC Comput(ProgramPart(s1),s1,i) & m+k2 >= 0 & k2 <> 1 holds (Comput(
ProgramPart(s1),s1,i).
DataLoc(Comput(ProgramPart(s1),s1,i).a,k1) = 0 iff Comput(ProgramPart(s2),s2,i)
.DataLoc(Comput(ProgramPart(
  s2),
  s2,i).a,k1) = 0 )
proof
  let p be autonomic non NAT-defined FinPartState of SCMPDS, s1, s2 be State
  of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i,m be Element of NAT,a be Int_position,k1,k2 be Integer;
  set Cs1i = Comput(ProgramPart(s1),s1,i);
  set Cs2i = Comput(ProgramPart(s2),s2,i);
  set Cs1i1 = Comput(ProgramPart(s1),s1,i+1);
  set Cs2i1 = Comput(ProgramPart(s2),s2,i+1);
A2: IC Cs1i = IC Cs2i & (Cs1i1|dom p) = (Cs2i1|dom p) by A1,Th23,EXTPRO_1:def 9
;
  set I = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(
s1),s1,i));
T: ProgramPart s1 = ProgramPart Cs1i
by AMI_1:123;
A3: Cs1i1 = Following(ProgramPart s1,Cs1i) by EXTPRO_1:4
    .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by T;
A4: m+1>=0 by NAT_1:2;
A5: (Cs1i1|dom p).IC SCMPDS = Cs1i1.IC SCMPDS & (Cs2i1|dom p).IC SCMPDS =
  Cs2i1. IC SCMPDS by Th17,FUNCT_1:72;
T: ProgramPart s2 = ProgramPart Cs2i
by AMI_1:123;
A6: Cs2i1 = Following(ProgramPart s2,Cs2i) by EXTPRO_1:4
    .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by T;
  assume that
A7: I = (a,k1)<>0_goto k2 and
A8: m= IC Cs1i & m+k2 >= 0 & k2 <> 1;
A9: I = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2
),s2,i)) by A1,Th23;
A10: now
    assume that
A11: Comput(ProgramPart(s2),s2,i).DataLoc(Cs2i.a,k1) = 0 and
A12: Comput(ProgramPart(s1),s1,i).DataLoc(Cs1i.a,k1) <> 0;
A13: Cs1i1.IC SCMPDS = ICplusConst(Cs1i,k2) by A3,A7,A12,SCMPDS_2:67;
    Cs2i1.IC SCMPDS = succ IC Cs2i by A9,A6,A7,A11,SCMPDS_2:67
      .=ICplusConst(Cs2i,1) by Th20;
    hence contradiction by A5,A2,A8,A4,A13,Th18;
  end;
  now
    assume that
A14: Comput(ProgramPart(s1),s1,i).DataLoc(Cs1i.a,k1) = 0 and
A15: Comput(ProgramPart(s2),s2,i).DataLoc(Cs2i.a,k1) <> 0;
A16: Cs2i1.IC SCMPDS = ICplusConst(Cs2i,k2) by A9,A6,A7,A15,SCMPDS_2:67;
    Cs1i1.IC SCMPDS = succ IC Cs1i by A3,A7,A14,SCMPDS_2:67
      .=ICplusConst(Cs1i,1) by Th20;
    hence contradiction by A5,A2,A8,A4,A16,Th18;
  end;
  hence thesis by A10;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCMPDS, s1, s2
being State of SCMPDS st p c= s1 & p c= s2 for i,m being Element of NAT,a being
Int_position,k1,k2 be Integer st CurInstr(ProgramPart Comput(ProgramPart(s1),s1
,i),
Comput(ProgramPart(s1),s1,i)) = (a,k1)<=0_goto
  k2 & m= IC Comput(ProgramPart(s1),s1,i) & m+k2 >= 0 & k2 <> 1 holds (Comput(
ProgramPart(s1),s1,i).
DataLoc(Comput(ProgramPart(s1),s1,i).a,k1) > 0 iff Comput(ProgramPart(s2),s2,i)
.DataLoc(Comput(ProgramPart(
  s2),
  s2,i).a,k1) > 0 )
proof
  let p be autonomic non NAT-defined FinPartState of SCMPDS, s1, s2 be State
  of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i,m be Element of NAT,a be Int_position,k1,k2 be Integer;
  set Cs1i = Comput(ProgramPart(s1),s1,i);
  set Cs2i = Comput(ProgramPart(s2),s2,i);
  set Cs1i1 = Comput(ProgramPart(s1),s1,i+1);
  set Cs2i1 = Comput(ProgramPart(s2),s2,i+1);
A2: IC Cs1i = IC Cs2i & (Cs1i1|dom p) = (Cs2i1|dom p) by A1,Th23,EXTPRO_1:def 9
;
  set I = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(
s1),s1,i));
T: ProgramPart s1 = ProgramPart Cs1i
by AMI_1:123;
A3: Cs1i1 = Following(ProgramPart s1,Cs1i) by EXTPRO_1:4
    .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by T;
A4: m+1>=0 by NAT_1:2;
A5: (Cs1i1|dom p).IC SCMPDS = Cs1i1.IC SCMPDS & (Cs2i1|dom p).IC SCMPDS =
  Cs2i1. IC SCMPDS by Th17,FUNCT_1:72;
T: ProgramPart s2 = ProgramPart Cs2i
by AMI_1:123;
A6: Cs2i1 = Following(ProgramPart s2,Cs2i) by EXTPRO_1:4
    .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by T;
  assume that
A7: I = (a,k1)<=0_goto k2 and
A8: m= IC Cs1i & m+k2 >= 0 & k2 <> 1;
A9: I = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2
),s2,i)) by A1,Th23;
A10: now
    assume that
A11: Comput(ProgramPart(s2),s2,i).DataLoc(Cs2i.a,k1) > 0 and
A12: Comput(ProgramPart(s1),s1,i).DataLoc(Cs1i.a,k1) <= 0;
A13: Cs1i1.IC SCMPDS = ICplusConst(Cs1i,k2) by A3,A7,A12,SCMPDS_2:68;
    Cs2i1.IC SCMPDS = succ IC Cs2i by A9,A6,A7,A11,SCMPDS_2:68
      .=ICplusConst(Cs2i,1) by Th20;
    hence contradiction by A5,A2,A8,A4,A13,Th18;
  end;
  now
    assume that
A14: Comput(ProgramPart(s1),s1,i).DataLoc(Cs1i.a,k1) > 0 and
A15: Comput(ProgramPart(s2),s2,i).DataLoc(Cs2i.a,k1) <= 0;
A16: Cs2i1.IC SCMPDS = ICplusConst(Cs2i,k2) by A9,A6,A7,A15,SCMPDS_2:68;
    Cs1i1.IC SCMPDS = succ IC Cs1i by A3,A7,A14,SCMPDS_2:68
      .=ICplusConst(Cs1i,1) by Th20;
    hence contradiction by A5,A2,A8,A4,A16,Th18;
  end;
  hence thesis by A10;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCMPDS, s1, s2
being State of SCMPDS st p c= s1 & p c= s2 for i,m being Element of NAT,a being
Int_position,k1,k2 be Integer st CurInstr(ProgramPart Comput(ProgramPart(s1),s1
,i),
Comput(ProgramPart(s1),s1,i)) = (a,k1)>=0_goto
  k2 & m= IC Comput(ProgramPart(s1),s1,i) & m+k2 >= 0 & k2 <> 1 holds (Comput(
ProgramPart(s1),s1,i).
DataLoc(Comput(ProgramPart(s1),s1,i).a,k1) < 0 iff Comput(ProgramPart(s2),s2,i)
.DataLoc(Comput(ProgramPart(
  s2),
  s2,i).a,k1) < 0 )
proof
  let p be autonomic non NAT-defined FinPartState of SCMPDS, s1, s2 be State
  of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i,m be Element of NAT,a be Int_position,k1,k2 be Integer;
  set Cs1i = Comput(ProgramPart(s1),s1,i);
  set Cs2i = Comput(ProgramPart(s2),s2,i);
  set Cs1i1 = Comput(ProgramPart(s1),s1,i+1);
  set Cs2i1 = Comput(ProgramPart(s2),s2,i+1);
A2: IC Cs1i = IC Cs2i & (Cs1i1|dom p) = (Cs2i1|dom p) by A1,Th23,EXTPRO_1:def 9
;
  set I = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(
s1),s1,i));
T: ProgramPart s1 = ProgramPart Cs1i
by AMI_1:123;
A3: Cs1i1 = Following(ProgramPart s1,Cs1i) by EXTPRO_1:4
    .= Exec (CurInstr(ProgramPart Cs1i,Cs1i), Cs1i) by T;
A4: m+1>=0 by NAT_1:2;
A5: (Cs1i1|dom p).IC SCMPDS = Cs1i1.IC SCMPDS & (Cs2i1|dom p).IC SCMPDS =
  Cs2i1. IC SCMPDS by Th17,FUNCT_1:72;
T: ProgramPart s2 = ProgramPart Cs2i
by AMI_1:123;
A6: Cs2i1 = Following(ProgramPart s2,Cs2i) by EXTPRO_1:4
    .= Exec (CurInstr(ProgramPart Cs2i,Cs2i), Cs2i) by T;
  assume that
A7: I = (a,k1)>=0_goto k2 and
A8: m= IC Cs1i & m+k2 >= 0 & k2 <> 1;
A9: I = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2
),s2,i))
 by A1,Th23;
A10: now
    assume that
A11: Comput(ProgramPart(s2),s2,i).DataLoc(Cs2i.a,k1) < 0 and
A12: Comput(ProgramPart(s1),s1,i).DataLoc(Cs1i.a,k1) >= 0;
A13: Cs1i1.IC SCMPDS = ICplusConst(Cs1i,k2) by A3,A7,A12,SCMPDS_2:69;
    Cs2i1.IC SCMPDS = succ IC Cs2i by A9,A6,A7,A11,SCMPDS_2:69
      .=ICplusConst(Cs2i,1) by Th20;
    hence contradiction by A5,A2,A8,A4,A13,Th18;
  end;
  now
    assume that
A14: Comput(ProgramPart(s1),s1,i).DataLoc(Cs1i.a,k1) < 0 and
A15: Comput(ProgramPart(s2),s2,i).DataLoc(Cs2i.a,k1) >= 0;
A16: Cs2i1.IC SCMPDS = ICplusConst(Cs2i,k2) by A9,A6,A7,A15,SCMPDS_2:69;
    Cs1i1.IC SCMPDS = succ IC Cs1i by A3,A7,A14,SCMPDS_2:69
      .=ICplusConst(Cs1i,1) by Th20;
    hence contradiction by A5,A2,A8,A4,A16,Th18;
  end;
  hence thesis by A10;
end;

