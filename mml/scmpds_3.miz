:: Computation and Program Shift in the SCMPDS Computer
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies SCMPDS_2, INT_1, AMI_1, AMI_2, SCMPDS_1, ABSVALUE, ARYTM_1,
      RELAT_1, FUNCT_1, BOOLE, AMI_5, AMI_3, NAT_1, FUNCT_4, CARD_3, CAT_1,
      FUNCOP_1, SCMPDS_3, ARYTM, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, CARD_3, RELAT_1,
      FUNCT_1, FUNCT_4, INT_1, NAT_1, STRUCT_0, FUNCOP_1, INT_2, XXREAL_0,
      AMI_1, SCMNORM, AMI_2, SCMPDS_1, SCMPDS_2;
 constructors DOMAIN_1, XXREAL_0, NAT_1, INT_2, AMI_5, SCMPDS_1, SCMPDS_2,
      REAL_1, SCMNORM;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1,
      FRAENKEL, NUMBERS, XREAL_0, INT_1, CARD_3, AMI_1, AMI_3, SCMPDS_2,
      SCMNORM, FINSET_1, FINSEQ_1;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM, REAL;
 definitions AMI_1, AMI_2, AMI_3, FUNCOP_1, SCMPDS_2, NAT_1, SCMNORM;
 theorems AMI_1, AMI_3, GRFUNC_1, NAT_1, FUNCOP_1, TARSKI, FUNCT_4, FUNCT_1,
      FINSET_1, ZFMISC_1, INT_1, RELAT_1, ABSVALUE, SCMPDS_2, BINARITH,
      XBOOLE_0, XBOOLE_1, CARD_3, AMI_2, NUMBERS, ORDINAL1, SCMNORM;

begin :: Preliminaries

reserve j, k, m, n for Element of NAT,
  a,b for Int_position,
  k1,k2 for Integer;

canceled;

theorem Th2:
  for k1 be Integer,s1,s2 being State of SCMPDS st IC s1 = IC s2
  holds ICplusConst(s1,k1)=ICplusConst(s2,k1)
proof
  let k1 be Integer,s1,s2 be State of SCMPDS;
  assume
A1: IC s1 = IC s2;
  consider i being Element of NAT such that
A2: i = IC s1 & ICplusConst(s1,k1) = abs(i+k1) by SCMPDS_2:def 20;
  consider j being Element of NAT such that
A3: j = IC s2 & ICplusConst(s2,k1) = abs(j+k1) by SCMPDS_2:def 20;
  thus thesis by A1,A2,A3;
end;

theorem Th3:
  for k1 be Integer,a be Int_position,s1,s2 being State of SCMPDS st
  DataPart s1 = DataPart s2
  holds s1.DataLoc(s1.a,k1)=s2.DataLoc(s2.a,k1)
proof
  let k1 be Integer,a be Int_position,s1,s2 be State of SCMPDS;
  assume
A1: DataPart s1 = DataPart s2;
A2: a in SCM-Data-Loc by SCMPDS_2:def 2;
A3: DataLoc(s1.a,k1) in SCM-Data-Loc by SCMPDS_2:def 2;
A4: s1.a= (DataPart s1).a by A2,FUNCT_1:72,SCMPDS_2:100
    .= s2.a by A1,A2,FUNCT_1:72,SCMPDS_2:100;
  thus s1.DataLoc(s1.a,k1)= (DataPart s1).DataLoc(s1.a,k1)
  by A3,FUNCT_1:72,SCMPDS_2:100
    .= s2.DataLoc(s2.a,k1) by A1,A3,A4,FUNCT_1:72,SCMPDS_2:100;
end;

theorem Th4:
  for a be Int_position,s1,s2 being State of SCMPDS st
  DataPart s1 = DataPart s2 holds s1.a=s2.a
proof
  let a be Int_position,s1,s2 be State of SCMPDS;
  assume
A1: DataPart s1 = DataPart s2;
A2: a in SCM-Data-Loc by SCMPDS_2:def 2;
  hence s1.a= (DataPart s1).a by FUNCT_1:72,SCMPDS_2:100
    .= s2.a by A1,A2,FUNCT_1:72,SCMPDS_2:100;
end;

theorem
  the carrier of SCMPDS = {IC SCMPDS } \/ SCM-Data-Loc \/ NAT by AMI_3:4;

theorem
  not IC SCMPDS in SCM-Data-Loc
proof
  assume IC SCMPDS in SCM-Data-Loc;
  then IC SCMPDS is Int_position by SCMPDS_2:9;
  then ObjectKind IC SCMPDS = INT by SCMPDS_2:13;
  hence contradiction by AMI_1:def 11,NUMBERS:27;
end;

theorem Th7:
  for s1,s2 being State of SCMPDS st
  s1 | (SCM-Data-Loc \/ {IC SCMPDS }) = s2 | (SCM-Data-Loc \/ {IC SCMPDS })
  for l being Instruction of SCMPDS holds
  Exec (l,s1) | (SCM-Data-Loc \/ {IC SCMPDS })
  = Exec (l,s2) | (SCM-Data-Loc \/ {IC SCMPDS })
proof
  let s1,s2 be State of SCMPDS such that
A1: s1 | (SCM-Data-Loc \/ {IC SCMPDS})=s2 | (SCM-Data-Loc \/ {IC SCMPDS});
A2: DataPart s1 =DataPart s2 by A1,RELAT_1:188,SCMPDS_2:100,XBOOLE_1:7;
  IC SCMPDS in {IC SCMPDS} by TARSKI:def 1;
  then
A3: IC SCMPDS in (SCM-Data-Loc \/ {IC SCMPDS}) by XBOOLE_0:def 3;
A4: (SCM-Data-Loc \/ {IC SCMPDS}) c= the carrier of SCMPDS by AMI_3:4
,XBOOLE_1:7;
  then (SCM-Data-Loc \/ {IC SCMPDS}) c= dom s1 by AMI_1:79;
  then
A5: IC SCMPDS in dom (s1 | (SCM-Data-Loc \/ {IC SCMPDS})) by A3,RELAT_1:91;
  (SCM-Data-Loc \/ {IC SCMPDS}) c= dom s2 by A4,AMI_1:79;
  then
A6: IC SCMPDS in dom (s2 | (SCM-Data-Loc \/ {IC SCMPDS})) by A3,RELAT_1:91;
A7: IC s1 = (s2 | (SCM-Data-Loc \/ {IC SCMPDS})).IC SCMPDS by A1,A5,FUNCT_1:70
    .= IC s2 by A6,FUNCT_1:70;
  let l be Instruction of SCMPDS;
A8: dom Exec(l,s1) = the carrier of SCMPDS by AMI_1:79;
A9: dom Exec(l,s2) = the carrier of SCMPDS by AMI_1:79;
A10: dom Exec(l,s1) = dom Exec(l,s2) by A8,AMI_1:79;
A11: dom DataPart Exec (l,s1)= SCM-Data-Loc by A8,RELAT_1:91,SCMPDS_2:100;
A12: dom DataPart Exec (l,s2)= SCM-Data-Loc by A9,RELAT_1:91,SCMPDS_2:100;
  per cases by NAT_1:38,SCMPDS_2:15;
  suppose InsCode (l) = 0;
    then consider k1 such that
A13: l = goto k1 by SCMPDS_2:35;
    for x being set st x in SCM-Data-Loc holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A14:  x in SCM-Data-Loc;
      then reconsider a = x as Int_position by SCMPDS_2:9;
      thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a
       by A14,FUNCT_1:72,SCMPDS_2:100
        .= s1.a by A13,SCMPDS_2:66
        .= (DataPart s1).a by A14,FUNCT_1:72,SCMPDS_2:100
        .= s2.a by A2,A14,FUNCT_1:72,SCMPDS_2:100
        .= (Exec (l,s2)).a by A13,SCMPDS_2:66
        .= (DataPart Exec (l,s2)).x by A14,FUNCT_1:72,SCMPDS_2:100;
    end;
    then
A15: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
    by A11,A12,FUNCT_1:9,SCMPDS_2:100;
    Exec (l,s1).IC SCMPDS = ICplusConst(s1,k1) by A13,SCMPDS_2:66
      .= ICplusConst(s2,k1) by A7,Th2
      .= Exec (l,s2).IC SCMPDS by A13,SCMPDS_2:66;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
    hence thesis by A15,RELAT_1:185;
  end;
  suppose InsCode (l) = 1;
    then consider a such that
A16: l = return a by SCMPDS_2:36;
    for x being set st x in SCM-Data-Loc holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A17:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A18:    b<>a;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).b by A17,FUNCT_1:72,SCMPDS_2:100
          .= s1.b by A16,A18,SCMPDS_2:70
          .= (DataPart s1).b by A17,FUNCT_1:72,SCMPDS_2:100
          .= s2.b by A2,A17,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).b by A16,A18,SCMPDS_2:70
          .= (DataPart Exec (l,s2)).x by A17,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A19:    b=a;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).b by A17,FUNCT_1:72,SCMPDS_2:100
          .= s1.DataLoc(s1.a,RetSP) by A16,A19,SCMPDS_2:70
          .= s2.DataLoc(s2.a,RetSP) by A2,Th3
          .= (Exec (l,s2)).b by A16,A19,SCMPDS_2:70
          .= (DataPart Exec (l,s2)).x by A17,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A20: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
    by A11,A12,FUNCT_1:9,SCMPDS_2:100;
    Exec (l,s1).IC SCMPDS = (abs(s1.DataLoc(s1.a,RetIC)))+2 by A16,SCMPDS_2:70
      .= (abs(s2.DataLoc(s2.a,RetIC)))+2 by A2,Th3
      .= Exec (l,s2).IC SCMPDS by A16,SCMPDS_2:70;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
    hence thesis by A20,RELAT_1:185;
  end;
  suppose InsCode (l) = 2;
    then consider a,k1 such that
A21: l= a:=k1 by SCMPDS_2:37;
    for x being set st x in SCM-Data-Loc holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A22:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A23:    b<>a;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).b by A22,FUNCT_1:72,SCMPDS_2:100
          .= s1.b by A21,A23,SCMPDS_2:57
          .= (DataPart s1).b by A22,FUNCT_1:72,SCMPDS_2:100
          .= s2.b by A2,A22,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).b by A21,A23,SCMPDS_2:57
          .= (DataPart Exec (l,s2)).x by A22,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A24:    b=a;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).b by A22,FUNCT_1:72,SCMPDS_2:100
          .= k1 by A21,A24,SCMPDS_2:57
          .= (Exec (l,s2)).b by A21,A24,SCMPDS_2:57
          .= (DataPart Exec (l,s2)).x by A22,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A25: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
    by A11,A12,FUNCT_1:9,SCMPDS_2:100;
    Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A21,SCMPDS_2:57
      .= Exec (l,s2).IC SCMPDS by A21,SCMPDS_2:57;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
    hence thesis by A25,RELAT_1:185;
  end;
  suppose InsCode (l) = 3;
    then consider a,k1 such that
A26: l= saveIC(a,k1) by SCMPDS_2:38;
    for x being set st x in SCM-Data-Loc holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A27:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A28:    b<>DataLoc(s1.a,k1);
        then
A29:    b<>DataLoc(s2.a,k1) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).b by A27,FUNCT_1:72,SCMPDS_2:100
          .= s1.b by A26,A28,SCMPDS_2:71
          .= (DataPart s1).b by A27,FUNCT_1:72,SCMPDS_2:100
          .= s2.b by A2,A27,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).b by A26,A29,SCMPDS_2:71
          .= (DataPart Exec (l,s2)).x by A27,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A30:    b=DataLoc(s1.a,k1);
        then
A31:    b=DataLoc(s2.a,k1) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).b by A27,FUNCT_1:72,SCMPDS_2:100
          .= IC s2 by A7,A26,A30,SCMPDS_2:71
          .= (Exec (l,s2)).b by A26,A31,SCMPDS_2:71
          .= (DataPart Exec (l,s2)).x by A27,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A32: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
    by A11,A12,FUNCT_1:9,SCMPDS_2:100;
    Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A26,SCMPDS_2:71
      .= Exec (l,s2).IC SCMPDS by A26,SCMPDS_2:71;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
    hence thesis by A32,RELAT_1:185;
  end;
  suppose InsCode (l) = 4;
    then consider a,k1,k2 such that
A33: l = (a,k1)<>0_goto k2 by SCMPDS_2:39;
    for x being set st x in SCM-Data-Loc holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A34:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b
       by A34,FUNCT_1:72,SCMPDS_2:100
        .= s1.b by A33,SCMPDS_2:67
        .= (DataPart s1).b by A34,FUNCT_1:72,SCMPDS_2:100
        .= s2.b by A2,A34,FUNCT_1:72,SCMPDS_2:100
        .= (Exec (l,s2)).b by A33,SCMPDS_2:67
        .= (DataPart Exec (l,s2)).x by A34,FUNCT_1:72,SCMPDS_2:100;
    end;
    then
A35: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
    by A11,A12,FUNCT_1:9,SCMPDS_2:100;
    now
      per cases;
      suppose
A36:    s1.DataLoc(s1.a,k1) <> 0;
        then
A37:    s2.DataLoc(s2.a,k1) <> 0 by A2,Th3;
        thus Exec (l,s1).IC SCMPDS = ICplusConst(s1,k2) by A33,A36,SCMPDS_2:67
          .= ICplusConst(s2,k2) by A7,Th2
          .= Exec (l,s2).IC SCMPDS by A33,A37,SCMPDS_2:67;
      end;
      suppose
A38:    s1.DataLoc(s1.a,k1) = 0;
        then
A39:    s2.DataLoc(s2.a,k1) = 0 by A2,Th3;
        thus Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A33,A38,SCMPDS_2:67
          .= Exec (l,s2).IC SCMPDS by A33,A39,SCMPDS_2:67;
      end;
    end;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
    hence thesis by A35,RELAT_1:185;
  end;
  suppose InsCode (l) = 5;
    then consider a,k1,k2 such that
A40: l = (a,k1)<=0_goto k2 by SCMPDS_2:40;
    for x being set st x in SCM-Data-Loc holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A41:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b
       by A41,FUNCT_1:72,SCMPDS_2:100
        .= s1.b by A40,SCMPDS_2:68
        .= (DataPart s1).b by A41,FUNCT_1:72,SCMPDS_2:100
        .= s2.b by A2,A41,FUNCT_1:72,SCMPDS_2:100
        .= (Exec (l,s2)).b by A40,SCMPDS_2:68
        .= (DataPart Exec (l,s2)).x by A41,FUNCT_1:72,SCMPDS_2:100;
    end;
    then
A42: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
    by A11,A12,FUNCT_1:9,SCMPDS_2:100;
    now
      per cases;
      suppose
A43:    s1.DataLoc(s1.a,k1) <= 0;
        then
A44:    s2.DataLoc(s2.a,k1) <= 0 by A2,Th3;
        thus Exec (l,s1).IC SCMPDS = ICplusConst(s1,k2) by A40,A43,SCMPDS_2:68
          .= ICplusConst(s2,k2) by A7,Th2
          .= Exec (l,s2).IC SCMPDS by A40,A44,SCMPDS_2:68;
      end;
      suppose
A45:    s1.DataLoc(s1.a,k1) > 0;
        then
A46:    s2.DataLoc(s2.a,k1) > 0 by A2,Th3;
        thus Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A40,A45,SCMPDS_2:68
          .= Exec (l,s2).IC SCMPDS by A40,A46,SCMPDS_2:68;
      end;
    end;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
    hence thesis by A42,RELAT_1:185;
  end;
  suppose InsCode (l) = 6;
    then consider a,k1,k2 such that
A47: l = (a,k1)>=0_goto k2 by SCMPDS_2:41;
    for x being set st x in SCM-Data-Loc holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A48:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).b
       by A48,FUNCT_1:72,SCMPDS_2:100
        .= s1.b by A47,SCMPDS_2:69
        .= (DataPart s1).b by A48,FUNCT_1:72,SCMPDS_2:100
        .= s2.b by A2,A48,FUNCT_1:72,SCMPDS_2:100
        .= (Exec (l,s2)).b by A47,SCMPDS_2:69
        .= (DataPart Exec (l,s2)).x by A48,FUNCT_1:72,SCMPDS_2:100;
    end;
    then
A49: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
    by A11,A12,FUNCT_1:9,SCMPDS_2:100;
    now
      per cases;
      suppose
A50:    s1.DataLoc(s1.a,k1) >= 0;
        then
A51:    s2.DataLoc(s2.a,k1) >= 0 by A2,Th3;
        thus Exec (l,s1).IC SCMPDS = ICplusConst(s1,k2) by A47,A50,SCMPDS_2:69
          .= ICplusConst(s2,k2) by A7,Th2
          .= Exec (l,s2).IC SCMPDS by A47,A51,SCMPDS_2:69;
      end;
      suppose
A52:    s1.DataLoc(s1.a,k1) < 0;
        then
A53:    s2.DataLoc(s2.a,k1) < 0 by A2,Th3;
        thus Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A47,A52,SCMPDS_2:69
          .= Exec (l,s2).IC SCMPDS by A47,A53,SCMPDS_2:69;
      end;
    end;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
    hence thesis by A49,RELAT_1:185;
  end;
  suppose InsCode (l) = 7;
    then consider a,k1,k2 such that
A54: l = (a,k1):=k2 by SCMPDS_2:42;
    for x being set st x in SCM-Data-Loc holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A55:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A56:    b<>DataLoc(s1.a,k1);
        then
A57:    b<>DataLoc(s2.a,k1) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).b by A55,FUNCT_1:72,SCMPDS_2:100
          .= s1.b by A54,A56,SCMPDS_2:58
          .= (DataPart s1).b by A55,FUNCT_1:72,SCMPDS_2:100
          .= s2.b by A2,A55,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).b by A54,A57,SCMPDS_2:58
          .= (DataPart Exec (l,s2)).x by A55,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A58:    b=DataLoc(s1.a,k1);
        then
A59:    b=DataLoc(s2.a,k1) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).b by A55,FUNCT_1:72,SCMPDS_2:100
          .= k2 by A54,A58,SCMPDS_2:58
          .= (Exec (l,s2)).b by A54,A59,SCMPDS_2:58
          .= (DataPart Exec (l,s2)).x by A55,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A60: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
    by A11,A12,FUNCT_1:9,SCMPDS_2:100;
    Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A54,SCMPDS_2:58
      .= Exec (l,s2).IC SCMPDS by A54,SCMPDS_2:58;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
    hence thesis by A60,RELAT_1:185;
  end;
  suppose InsCode (l) = 8;
    then consider a,k1,k2 such that
A61: l = AddTo(a,k1,k2) by SCMPDS_2:43;
    for x being set st x in SCM-Data-Loc holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A62:  x in SCM-Data-Loc;
      then reconsider b = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A63:    b<>DataLoc(s1.a,k1);
        then
A64:    b<>DataLoc(s2.a,k1) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).b by A62,FUNCT_1:72,SCMPDS_2:100
          .= s1.b by A61,A63,SCMPDS_2:60
          .= (DataPart s1).b by A62,FUNCT_1:72,SCMPDS_2:100
          .= s2.b by A2,A62,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).b by A61,A64,SCMPDS_2:60
          .= (DataPart Exec (l,s2)).x by A62,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A65:    b=DataLoc(s1.a,k1);
        then
A66:    b=DataLoc(s2.a,k1) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).b by A62,FUNCT_1:72,SCMPDS_2:100
          .= s1.DataLoc(s1.a,k1)+k2 by A61,A65,SCMPDS_2:60
          .= s2.DataLoc(s2.a,k1)+k2 by A2,Th3
          .= (Exec (l,s2)).b by A61,A66,SCMPDS_2:60
          .= (DataPart Exec (l,s2)).x by A62,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A67: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
    by A11,A12,FUNCT_1:9,SCMPDS_2:100;
    Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A61,SCMPDS_2:60
      .= Exec (l,s2).IC SCMPDS by A61,SCMPDS_2:60;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
    hence thesis by A67,RELAT_1:185;
  end;
  suppose InsCode (l) = 9;
    then consider a,b,k1,k2 such that
A68: l = AddTo(a,k1,b,k2) by SCMPDS_2:44;
    for x being set st x in SCM-Data-Loc holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A69:  x in SCM-Data-Loc;
      then reconsider c = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A70:    c <>DataLoc(s1.a,k1);
        then
A71:    c <>DataLoc(s2.a,k1) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).c by A69,FUNCT_1:72,SCMPDS_2:100
          .= s1.c by A68,A70,SCMPDS_2:61
          .= (DataPart s1).c by A69,FUNCT_1:72,SCMPDS_2:100
          .= s2.c by A2,A69,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).c by A68,A71,SCMPDS_2:61
          .= (DataPart Exec (l,s2)).x by A69,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A72:    c = DataLoc(s1.a,k1);
        then
A73:    c = DataLoc(s2.a,k1) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).c by A69,FUNCT_1:72,SCMPDS_2:100
          .= s1.DataLoc(s1.a,k1)+s1.DataLoc(s1.b,k2) by A68,A72,SCMPDS_2:61
          .= s2.DataLoc(s2.a,k1)+s1.DataLoc(s1.b,k2) by A2,Th3
          .= s2.DataLoc(s2.a,k1)+s2.DataLoc(s2.b,k2) by A2,Th3
          .= (Exec (l,s2)).c by A68,A73,SCMPDS_2:61
          .= (DataPart Exec (l,s2)).x by A69,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A74: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
    by A11,A12,FUNCT_1:9,SCMPDS_2:100;
    Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A68,SCMPDS_2:61
      .= Exec (l,s2).IC SCMPDS by A68,SCMPDS_2:61;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
    hence thesis by A74,RELAT_1:185;
  end;
  suppose InsCode (l) = 10;
    then consider a,b,k1,k2 such that
A75: l = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
    for x being set st x in SCM-Data-Loc holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A76:  x in SCM-Data-Loc;
      then reconsider c = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A77:    c <>DataLoc(s1.a,k1);
        then
A78:    c <>DataLoc(s2.a,k1) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).c by A76,FUNCT_1:72,SCMPDS_2:100
          .= s1.c by A75,A77,SCMPDS_2:62
          .= (DataPart s1).c by A76,FUNCT_1:72,SCMPDS_2:100
          .= s2.c by A2,A76,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).c by A75,A78,SCMPDS_2:62
          .= (DataPart Exec (l,s2)).x by A76,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A79:    c = DataLoc(s1.a,k1);
        then
A80:    c = DataLoc(s2.a,k1) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).c by A76,FUNCT_1:72,SCMPDS_2:100
          .= s1.DataLoc(s1.a,k1)-s1.DataLoc(s1.b,k2) by A75,A79,SCMPDS_2:62
          .= s2.DataLoc(s2.a,k1)-s1.DataLoc(s1.b,k2) by A2,Th3
          .= s2.DataLoc(s2.a,k1)-s2.DataLoc(s2.b,k2) by A2,Th3
          .= (Exec (l,s2)).c by A75,A80,SCMPDS_2:62
          .= (DataPart Exec (l,s2)).x by A76,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A81: DataPart Exec (l,s1) = DataPart Exec (l,s2)
    by A11,A12,FUNCT_1:9;
    Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A75,SCMPDS_2:62
      .= Exec (l,s2).IC SCMPDS by A75,SCMPDS_2:62;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
    hence thesis by A81,RELAT_1:185,SCMPDS_2:100;
  end;
  suppose InsCode (l) = 11;
    then consider a,b,k1,k2 such that
A82: l = MultBy(a,k1,b,k2) by SCMPDS_2:46;
    for x being set st x in SCM-Data-Loc holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A83:  x in SCM-Data-Loc;
      then reconsider c = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A84:    c <>DataLoc(s1.a,k1);
        then
A85:    c <>DataLoc(s2.a,k1) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).c by A83,FUNCT_1:72,SCMPDS_2:100
          .= s1.c by A82,A84,SCMPDS_2:63
          .= (DataPart s1).c by A83,FUNCT_1:72,SCMPDS_2:100
          .= s2.c by A2,A83,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).c by A82,A85,SCMPDS_2:63
          .= (DataPart Exec (l,s2)).x by A83,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A86:    c = DataLoc(s1.a,k1);
        then
A87:    c = DataLoc(s2.a,k1) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).c by A83,FUNCT_1:72,SCMPDS_2:100
          .= s1.DataLoc(s1.a,k1) * s1.DataLoc(s1.b,k2) by A82,A86,SCMPDS_2:63
          .= s2.DataLoc(s2.a,k1) * s1.DataLoc(s1.b,k2) by A2,Th3
          .= s2.DataLoc(s2.a,k1) * s2.DataLoc(s2.b,k2) by A2,Th3
          .= (Exec (l,s2)).c by A82,A87,SCMPDS_2:63
          .= (DataPart Exec (l,s2)).x by A83,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A88: DataPart Exec (l,s1) = DataPart Exec (l,s2)
    by A11,A12,FUNCT_1:9;
    Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A82,SCMPDS_2:63
      .= Exec (l,s2).IC SCMPDS by A82,SCMPDS_2:63;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
    hence thesis by A88,RELAT_1:185,SCMPDS_2:100;
  end;
  suppose InsCode (l) = 12;
    then consider a,b,k1,k2 such that
A89: l = Divide(a,k1,b,k2) by SCMPDS_2:47;
    for x being set st x in SCM-Data-Loc holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A90:  x in SCM-Data-Loc;
      then reconsider c = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A91:    c = DataLoc(s1.b,k2);
        then
A92:    c = DataLoc(s2.b,k2) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).c by A90,FUNCT_1:72,SCMPDS_2:100
          .= s1.DataLoc(s1.a,k1) mod s1.DataLoc(s1.b,k2) by A89,A91,SCMPDS_2:64
          .= s2.DataLoc(s2.a,k1) mod s1.DataLoc(s1.b,k2) by A2,Th3
          .= s2.DataLoc(s2.a,k1) mod s2.DataLoc(s2.b,k2) by A2,Th3
          .= (Exec (l,s2)).c by A89,A92,SCMPDS_2:64
          .= (DataPart Exec (l,s2)).x by A90,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A93:    c <>DataLoc(s1.b,k2);
        then
A94:    c <>DataLoc(s2.b,k2) by A2,Th4;
        hereby
          per cases;
          suppose
A95:        c <> DataLoc(s1.a,k1);
            then
A96:        c <> DataLoc(s2.a,k1) by A2,Th4;
            thus (DataPart Exec (l,s1)).x
            = (Exec (l,s1)).c by A90,FUNCT_1:72,SCMPDS_2:100
              .= s1.c by A89,A93,A95,SCMPDS_2:64
              .= s2.c by A2,Th4
              .= (Exec (l,s2)).c by A89,A94,A96,SCMPDS_2:64
              .= (DataPart Exec (l,s2)).x by A90,FUNCT_1:72,SCMPDS_2:100;
          end;
          suppose
A97:        c = DataLoc(s1.a,k1);
            then
A98:        c = DataLoc(s2.a,k1) by A2,Th4;
            thus (DataPart Exec (l,s1)).x
            = (Exec (l,s1)).c by A90,FUNCT_1:72,SCMPDS_2:100
              .= s1.DataLoc(s1.a,k1) div s1.DataLoc(s1.b,k2)
            by A89,A93,A97,SCMPDS_2:64
              .= s2.DataLoc(s2.a,k1) div s1.DataLoc(s1.b,k2) by A2,Th3
              .= s2.DataLoc(s2.a,k1) div s2.DataLoc(s2.b,k2) by A2,Th3
              .= (Exec (l,s2)).c by A89,A94,A98,SCMPDS_2:64
              .= (DataPart Exec (l,s2)).x by A90,FUNCT_1:72,SCMPDS_2:100;
          end;
        end;
      end;
    end;
    then
A99: DataPart Exec (l,s1) = DataPart Exec (l,s2)
    by A11,A12,FUNCT_1:9;
    Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A89,SCMPDS_2:64
      .= Exec (l,s2).IC SCMPDS by A89,SCMPDS_2:64;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
    hence thesis by A99,RELAT_1:185,SCMPDS_2:100;
  end;
  suppose InsCode (l) = 13;
    then consider a,b,k1,k2 such that
A100: l = (a,k1):=(b,k2) by SCMPDS_2:48;
    for x being set st x in SCM-Data-Loc holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A101: x in SCM-Data-Loc;
      then reconsider c = x as Int_position by SCMPDS_2:9;
      per cases;
      suppose
A102:   c <>DataLoc(s1.a,k1);
        then
A103:   c <>DataLoc(s2.a,k1) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).c by A101,FUNCT_1:72,SCMPDS_2:100
          .= s1.c by A100,A102,SCMPDS_2:59
          .= (DataPart s1).c by A101,FUNCT_1:72,SCMPDS_2:100
          .= s2.c by A2,A101,FUNCT_1:72,SCMPDS_2:100
          .= (Exec (l,s2)).c by A100,A103,SCMPDS_2:59
          .= (DataPart Exec (l,s2)).x by A101,FUNCT_1:72,SCMPDS_2:100;
      end;
      suppose
A104:   c = DataLoc(s1.a,k1);
        then
A105:   c = DataLoc(s2.a,k1) by A2,Th4;
        thus (DataPart Exec (l,s1)).x
        = (Exec (l,s1)).c by A101,FUNCT_1:72,SCMPDS_2:100
          .= s1.DataLoc(s1.b,k2) by A100,A104,SCMPDS_2:59
          .= s2.DataLoc(s2.b,k2) by A2,Th3
          .= (Exec (l,s2)).c by A100,A105,SCMPDS_2:59
          .= (DataPart Exec (l,s2)).x by A101,FUNCT_1:72,SCMPDS_2:100;
      end;
    end;
    then
A106: DataPart Exec (l,s1) = DataPart Exec (l,s2)
    by A11,A12,FUNCT_1:9;
    Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A100,SCMPDS_2:59
      .= Exec (l,s2).IC SCMPDS by A100,SCMPDS_2:59;
    then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
    hence thesis by A106,RELAT_1:185,SCMPDS_2:100;
  end;
end;

theorem
  for i being Instruction of SCMPDS,s being State of SCMPDS
  holds Exec (i, s) | NAT = s | NAT
proof
  let i be Instruction of SCMPDS, s be State of SCMPDS;
  dom Exec (i,s) = the carrier of SCMPDS by AMI_1:79;
  then
A1: dom (Exec (i, s) | NAT) = NAT by RELAT_1:91;
  dom s = the carrier of SCMPDS by AMI_1:79;
  then
A2: dom (s | NAT) = NAT by RELAT_1:91;
  for x being set st x in NAT
  holds (Exec (i, s) | NAT).x = (s | NAT).x
  proof
    let x be set;
    assume
A3: x in NAT;
    then reconsider l = x as Instruction-Location of SCMPDS by AMI_1:def 4;
    thus (Exec (i, s) | NAT).x = (Exec (i, s)).l by A3,FUNCT_1:72
      .= s.l by AMI_1:def 13
      .= (s | NAT).x by A3,FUNCT_1:72;
  end;
  hence Exec (i, s) | NAT = s | NAT by A1,A2,FUNCT_1:9;
end;

begin :: Finite partial states of SCMPDS

canceled 4;

theorem
  for i being Instruction of SCMPDS, s being State of SCMPDS ,
  p being preProgram of SCMPDS holds
  Exec (i, s +* p) = Exec (i,s) +* p
proof
  let i be Instruction of SCMPDS, s be State of SCMPDS,
  p be preProgram of SCMPDS;
A1: dom p c= NAT by AMI_1:def 40;
  now
    assume {IC SCMPDS } meets NAT;
    then consider x being set such that
A2: x in {IC SCMPDS } and
A3: x in NAT by XBOOLE_0:3;
    reconsider x as Instruction-Location of SCMPDS by A3,AMI_1:def 4;
    x = IC SCMPDS by A2,TARSKI:def 1;
    hence contradiction by AMI_1:48;
  end;
  then SCM-Data-Loc \/ {IC SCMPDS } misses NAT by AMI_2:29,XBOOLE_1:70;
  then
A4: SCM-Data-Loc \/ {IC SCMPDS } misses dom p by A1,XBOOLE_1:63;
  then
A5: s|(SCM-Data-Loc \/ {IC SCMPDS })
  = (s +* p) | (SCM-Data-Loc \/ {IC SCMPDS }) by FUNCT_4:76;
A6: (Exec(i,s) +* p)|(SCM-Data-Loc \/ {IC SCMPDS })
  = Exec(i,s)|(SCM-Data-Loc \/ {IC SCMPDS }) by A4,FUNCT_4:76
    .= Exec(i,s +* p) | (SCM-Data-Loc \/ {IC SCMPDS }) by A5,Th7;
A7: Exec (i, s +* p)|NAT = (s +* p)|NAT by AMI_1:117
    .= s |(NAT ) +*
  p|NAT by FUNCT_4:75
    .= Exec (i,s) |(NAT ) +* p|NAT by AMI_1:117
    .= (Exec (i, s) +* p)|NAT by FUNCT_4:75;
  thus Exec (i, s +* p)
  = Exec (i, s +* p)| dom(Exec (i, s +* p)) by RELAT_1:97
    .= Exec (i, s +* p)| (SCM-Data-Loc \/ {IC SCMPDS } \/ NAT )
  by AMI_1:79,AMI_3:4
    .= (Exec (i, s) +* p)| (SCM-Data-Loc \/ {IC SCMPDS })
  +* (Exec (i, s) +* p)|NAT by A6,A7,FUNCT_4:83
    .= (Exec (i,s) +* p)| the carrier of SCMPDS by AMI_3:4,FUNCT_4:83
    .= (Exec (i,s) +* p)| dom(Exec (i, s) +* p) by AMI_1:79
    .= Exec (i,s) +* p by RELAT_1:97;
end;

theorem
  for s being State of SCMPDS ,iloc being Instruction-Location of SCMPDS ,
  a being Int_position holds s.a = (s +* Start-At iloc).a
proof
  let s be State of SCMPDS, iloc be Instruction-Location of SCMPDS,
  a be Int_position;
A1: dom (Start-At iloc) = {IC SCMPDS } by FUNCOP_1:19;
  a in the carrier of SCMPDS;
  then a in dom s by AMI_1:79;
  then
A2: a in dom s \/ dom (Start-At iloc) by XBOOLE_0:def 3;
  a <> IC SCMPDS by SCMPDS_2:52;
  then not a in {IC SCMPDS } by TARSKI:def 1;
  hence s.a = (s +* Start-At iloc).a by A1,A2,FUNCT_4:def 1;
end;

theorem
  for s, t being State of SCMPDS
  holds s +* t|(SCM-Data-Loc ) is State of SCMPDS
proof
  let s, t be State of SCMPDS;
A1: product the Object-Kind of SCMPDS c= sproduct the Object-Kind of SCMPDS
  by CARD_3:67;
  t in product the Object-Kind of SCMPDS;
  hence s +* t|(SCM-Data-Loc ) is State of SCMPDS by A1,CARD_3:69,81;
end;

begin :: Autonomic finite partial states of SCMPDS and its computation

definition
  let la be Int_position;
  let a be Integer;
  redefine func la .--> a -> FinPartState of SCMPDS;
  coherence
  proof
    a is Element of INT & ObjectKind la = INT by INT_1:def 2,SCMPDS_2:13;
    hence thesis by AMI_1:59;
  end;
end;

theorem Th16:
  for p being autonomic FinPartState of SCMPDS st DataPart p <> {}
  holds IC SCMPDS in dom p
proof
  let p be autonomic FinPartState of SCMPDS;
  assume DataPart p <> {};
  then
A1: dom DataPart p <> {};
  assume
A2: not IC SCMPDS in dom p;
  p is not autonomic
  proof
    consider d1 being Element of dom DataPart p;
A3: d1 in dom DataPart p by A1;
    dom DataPart p c= the carrier of SCMPDS by AMI_1:80;
    then reconsider d1 as Element of SCMPDS by A3;
    dom DataPart p c= SCM-Data-Loc by RELAT_1:87,SCMPDS_2:100;
    then reconsider d1 as Int_position by A3,SCMPDS_2:9;
    consider il being Element of (NAT) \ dom p;
    not NAT c= dom p by SCMPDS_2:11;
    then
A4: (NAT) \ dom p <> {} by XBOOLE_1:37;
    then il is Element of NAT by XBOOLE_0:def 5;
    then reconsider il as Instruction-Location of SCMPDS by AMI_1:def 4;
    set p1 = p +* ((il .--> (d1:=0)) +* Start-At il);
    set p2 = p +* ((il .--> (d1:=1)) +* Start-At il);
    consider s1 being State of SCMPDS such that
A5: p1 c= s1 by CARD_3:97;
    consider s2 being State of SCMPDS such that
A6: p2 c= s2 by CARD_3:97;
    take s1,s2;
A7: dom p misses {IC SCMPDS} by A2,ZFMISC_1:56;
    not il in dom p by A4,XBOOLE_0:def 5;
    then
A8: dom p misses {il} by ZFMISC_1:56;
    dom ((il .--> (d1:=0)) +* Start-At il)
    = dom (il .--> (d1:=0)) \/ dom (Start-At il) by FUNCT_4:def 1
      .= dom (il .--> (d1:=0)) \/ { IC SCMPDS } by FUNCOP_1:19
      .= {il} \/ { IC SCMPDS } by FUNCOP_1:19;
    then dom p /\ dom ((il .--> (d1:=0)) +* Start-At il)
    = dom p /\ {il} \/ dom p /\ {IC SCMPDS} by XBOOLE_1:23
      .= dom p /\ {il} \/ {} by A7,XBOOLE_0:def 7
      .= {} by A8,XBOOLE_0:def 7;
    then dom p misses dom ((il .--> (d1:=0)) +* Start-At il) by XBOOLE_0:def 7;
    then p c= p1 by FUNCT_4:33;
    hence p c= s1 by A5,XBOOLE_1:1;
    dom ((il .--> (d1:=1)) +* Start-At il)
    = dom (il .--> (d1:=1)) \/ dom (Start-At il) by FUNCT_4:def 1
      .= dom (il .--> (d1:=1)) \/ { IC SCMPDS } by FUNCOP_1:19
      .= {il} \/ { IC SCMPDS } by FUNCOP_1:19;
    then dom p /\ dom ((il .--> (d1:=1)) +* Start-At il)
    = dom p /\ {il} \/ dom p /\ {IC SCMPDS} by XBOOLE_1:23
      .= dom p /\ {il} \/ {} by A7,XBOOLE_0:def 7
      .= {} by A8,XBOOLE_0:def 7;
    then dom p misses dom ((il .--> (d1:=1)) +* Start-At il) by XBOOLE_0:def 7;
    then p c= p2 by FUNCT_4:33;
    hence p c= s2 by A6,XBOOLE_1:1;
    take 1;
    DataPart p c= p by RELAT_1:88;
    then
A9: dom DataPart p c= dom p by RELAT_1:25;
    dom (Computation(s1,1)) = the carrier of SCMPDS by AMI_1:79;
    then
A10: dom (Computation(s1,1)|dom p) = dom p by AMI_1:80,RELAT_1:91;
A11: dom (Start-At il) = {IC SCMPDS} by FUNCOP_1:19;
    then
A12: IC SCMPDS in dom (Start-At il) by TARSKI:def 1;
A13: dom ((il .--> (d1:=0)) +* Start-At il)
    = dom ((il .--> (d1:=0))) \/ dom (Start-At il) by FUNCT_4:def 1;
    then
A14: IC SCMPDS in dom ((il .--> (d1:=0)) +* Start-At il) by A12,XBOOLE_0:def 3;
A15: dom p1 = dom p \/ dom ((il .--> (d1:=0)) +* Start-At il)
    by FUNCT_4:def 1;
    then IC SCMPDS in dom p1 by A14,XBOOLE_0:def 3;
    then
A16: IC s1 = p1.IC SCMPDS by A5,GRFUNC_1:8
      .= ((il .--> (d1:=0)) +* Start-At il).IC SCMPDS by A14,FUNCT_4:14
      .= (Start-At il).IC SCMPDS by A12,FUNCT_4:14
      .= il by FUNCOP_1:87;
    dom (il .--> (d1:=0)) = {il} by FUNCOP_1:19;
    then
A17: il in dom (il .--> (d1:=0)) by TARSKI:def 1;
    il <> IC SCMPDS by AMI_1:48;
    then
A18: not il in dom (Start-At il) by A11,TARSKI:def 1;
A19: il in dom ((il .--> (d1:=0)) +* Start-At il) by A13,A17,XBOOLE_0:def 3;
    then il in dom p1 by A15,XBOOLE_0:def 3;
    then
A20: s1.il = p1.il by A5,GRFUNC_1:8
      .= ((il .--> (d1:=0)) +* Start-At il).il by A19,FUNCT_4:14
      .= (il .--> (d1:=0)).il by A18,FUNCT_4:12
      .=(d1:=0) by FUNCOP_1:87;
    Computation(s1,0+1).d1
    = (Following Computation(s1,0)).d1 by AMI_1:14
      .= (Following s1).d1 by AMI_1:13
      .= 0 by A16,A20,SCMPDS_2:57;
    then
A21: (Computation(s1,1)|dom p).d1 = 0 by A3,A9,A10,FUNCT_1:70;
    dom (Computation(s2,1)) = the carrier of SCMPDS by AMI_1:79;
    then
A22: dom (Computation(s2,1)|dom p) = dom p by AMI_1:80,RELAT_1:91;
A23: dom ((il .--> (d1:=1)) +* Start-At il)
    = dom ((il .--> (d1:=1))) \/ dom (Start-At il) by FUNCT_4:def 1;
    then
A24: IC SCMPDS in dom ((il .--> (d1:=1)) +* Start-At il) by A12,XBOOLE_0:def 3;
A25: dom p2 = dom p \/ dom ((il .--> (d1:=1)) +* Start-At il)
    by FUNCT_4:def 1;
    then IC SCMPDS in dom p2 by A24,XBOOLE_0:def 3;
    then
A26: IC s2 = p2.IC SCMPDS by A6,GRFUNC_1:8
      .= ((il .--> (d1:=1)) +* Start-At il).IC SCMPDS by A24,FUNCT_4:14
      .= (Start-At il).IC SCMPDS by A12,FUNCT_4:14
      .= il by FUNCOP_1:87;
    dom (il .--> (d1:=1)) = {il} by FUNCOP_1:19;
    then
A27: il in dom (il .--> (d1:=1)) by TARSKI:def 1;
    il <> IC SCMPDS by AMI_1:48;
    then
A28: not il in dom (Start-At il) by A11,TARSKI:def 1;
A29: il in dom ((il .--> (d1:=1)) +* Start-At il) by A23,A27,XBOOLE_0:def 3;
    then il in dom p2 by A25,XBOOLE_0:def 3;
    then
A30: s2.il = p2.il by A6,GRFUNC_1:8
      .= ((il .--> (d1:=1)) +* Start-At il).il by A29,FUNCT_4:14
      .= (il .--> (d1:=1)).il by A28,FUNCT_4:12
      .=(d1:=1) by FUNCOP_1:87;
    Computation(s2,0+1).d1
    = (Following Computation(s2,0)).d1 by AMI_1:14
      .= (Following s2).d1 by AMI_1:13
      .= 1 by A26,A30,SCMPDS_2:57;
    hence Computation(s1,1)|dom p <> Computation(s2,1)|dom p by A3,A9,A21,A22,
FUNCT_1:70;
  end;
  hence contradiction;
end;

registration
  cluster autonomic non programmed FinPartState of SCMPDS;
  existence
  proof
    reconsider il=2 as Instruction-Location of SCMPDS by AMI_1:def 4;
    set P = (IC SCMPDS, il)-->(il, halt SCMPDS);
    P = Start-At il +* (il .--> halt SCMPDS) by FUNCT_4:def 4;
    then reconsider P as FinPartState of SCMPDS;
    take P;
A1: ObjectKind il = the Instructions of SCMPDS by AMI_1:def 14;
    ObjectKind IC SCMPDS = NAT by AMI_1:def 11;
    hence P is autonomic by A1,AMI_1:67;
    now
      dom P = { IC SCMPDS, il } by FUNCT_4:65;
      then
A2:   IC SCMPDS in dom P by TARSKI:def 2;
      assume dom P c= NAT;
      then reconsider l=IC SCMPDS as Instruction-Location of SCMPDS
      by A2,AMI_1:def 4;
      l=IC SCMPDS;
      hence contradiction by AMI_1:48;
    end;
    hence P is non programmed by AMI_1:def 40;
  end;
end;

theorem Th17:
  for p being autonomic non programmed FinPartState of SCMPDS
  holds IC SCMPDS in dom p
proof
  let p be autonomic non programmed FinPartState of SCMPDS;
A1: not dom p c= NAT by AMI_1:def 40;
  dom p = dom p /\ the carrier of SCMPDS by AMI_1:80,XBOOLE_1:28
    .= dom p /\
  (SCM-Data-Loc \/ {IC SCMPDS }) \/ dom p /\ NAT by AMI_3:4,XBOOLE_1:23;
  then dom p /\ (SCM-Data-Loc \/ {IC SCMPDS }) <> {} by A1,XBOOLE_1:17;
  then
A2: dom p /\ {IC SCMPDS } \/ dom p /\ (SCM-Data-Loc ) <> {} by XBOOLE_1:23;
  per cases by A2;
  suppose dom p /\ {IC SCMPDS } <> {};
    then dom p meets {IC SCMPDS } by XBOOLE_0:def 7;
    hence IC SCMPDS in dom p by ZFMISC_1:56;
  end;
  suppose
A3: dom p /\ (SCM-Data-Loc ) <> {};
    DataPart p <> {} by A3,RELAT_1:60,90,SCMPDS_2:100;
    hence IC SCMPDS in dom p by Th16;
  end;
end;

theorem Th18:
  for s1,s2 being State of SCMPDS,k1,k2,m be Integer st
  IC s1= IC s2 & k1 <> k2 & m=IC s1 & m+k1 >= 0 & m+k2 >= 0 holds
  ICplusConst(s1,k1) <> ICplusConst(s2,k2)
proof
  let s1,s2 be State of SCMPDS,k1,k2,m be Integer;
  assume
A1: IC s1 = IC s2 & k1<>k2 & m=IC s1 & m+k1 >= 0 & m+k2 >= 0;
  assume
A2: ICplusConst(s1,k1) = ICplusConst(s2,k2);
  consider i being Element of NAT such that
A3: i = IC s1 & ICplusConst(s1,k1)=abs(i+k1) by SCMPDS_2:def 20;
A4: ICplusConst(s1,k1)=m+k1 by A1,A3,ABSVALUE:def 1;
  consider j being Element of NAT such that
A5: j = IC s2 & ICplusConst(s2,k2)=abs(j+k2) by SCMPDS_2:def 20;
  ICplusConst(s2,k2)=m+k2 by A1,A5,ABSVALUE:def 1;
  hence contradiction by A1,A2,A4;
end;

theorem Th19:
  for s1,s2 being State of SCMPDS,k1,k2 be Element of NAT st
  IC s1= IC s2 & k1 <> k2 holds ICplusConst(s1,k1) <> ICplusConst(s2,k2)
proof
  let s1,s2 be State of SCMPDS,k1,k2 be Element of NAT;
  assume
A1: IC s1 = IC s2 & k1<>k2;
  reconsider m=IC s1 as Element of NAT by AMI_1:def 4;
  set mm=m+2;
  mm-2+k1=m+k1;
  then
A2: mm-2+k1>=0 by NAT_1:2;
  mm-2+k2=m+k2;
  then mm-2+k2>=0 by NAT_1:2;
  hence thesis by A1,A2,Th18;
end;

theorem Th20:
  for s being State of SCMPDS holds Next IC s= ICplusConst(s,1)
proof
  let s be State of SCMPDS;
  consider j such that
A1: j = IC s & ICplusConst(s,1)=abs(j+1) by SCMPDS_2:def 20;
A2: j >= 0 by NAT_1:2;
A3: j*1 >= 0 by NAT_1:2;
  reconsider mj = IC s as Element of NAT by ORDINAL1:def 13;
  Next IC s = abs(mj)+1 by A1,A2,ABSVALUE:def 1
    .= abs(mj)+abs(1) by ABSVALUE:def 1
    .= abs(mj+1) by A1,A3,ABSVALUE:24;
  hence thesis by A1;
end;

theorem
  for p being autonomic FinPartState of SCMPDS st IC SCMPDS in dom p
  holds IC p in dom p
proof
  let p be autonomic FinPartState of SCMPDS;
  assume
A1: IC SCMPDS in dom p;
  assume
A2: not IC p in dom p;
  set il = IC p;
  set p1 = p +* ((il .--> goto 0));
  set p2 = p +* ((il .--> goto 1));
  consider s1 being State of SCMPDS such that
A3: p1 c= s1 by CARD_3:97;
  consider s2 being State of SCMPDS such that
A4: p2 c= s2 by CARD_3:97;
  p is not autonomic
  proof
A5: dom (il .--> (goto 1)) = {il} by FUNCOP_1:19;
A6: dom (il .--> (goto 0)) = {il} by FUNCOP_1:19;
    take s1,s2;
    dom p misses {il} by A2,ZFMISC_1:56;
    then
A7: p c= p1 & p c= p2 by A5,A6,FUNCT_4:33;
    hence p c= s1 & p c= s2 by A3,A4,XBOOLE_1:1;
    take 1;
A8: il in dom (il .--> (goto 1)) by A5,TARSKI:def 1;
A9: il in dom (il .--> (goto 0)) by A6,TARSKI:def 1;
    dom p1 = dom p \/ dom ((il .--> goto 0)) by FUNCT_4:def 1;
    then il in dom p1 by A9,XBOOLE_0:def 3;
    then
A10: s1.il = p1.il by A3,GRFUNC_1:8
      .= ((il .--> goto 0)).il by A9,FUNCT_4:14
      .= goto 0 by FUNCOP_1:87;
    dom p2 = dom p \/ dom ((il .--> goto 1)) by FUNCT_4:def 1;
    then il in dom p2 by A8,XBOOLE_0:def 3;
    then
A11: s2.il = p2.il by A4,GRFUNC_1:8
      .= ((il .--> goto 1)).il by A8,FUNCT_4:14
      .= goto 1 by FUNCOP_1:87;
A12: (Following s1).IC SCMPDS
    = Exec (goto 0,s1).IC SCMPDS by A1,A3,A7,A10,AMI_1:97,XBOOLE_1:1
      .= ICplusConst(s1,0) by SCMPDS_2:66;
A13: (Following s2).IC SCMPDS
    = Exec (goto 1,s2).IC SCMPDS by A1,A4,A7,A11,AMI_1:97,XBOOLE_1:1
      .= ICplusConst(s2,1) by SCMPDS_2:66;
    assume
A14: Computation(s1,1)|dom p = Computation(s2,1)|dom p;
A15: (Following(s1))|dom p
    = (Following (Computation(s1,0)))|dom p by AMI_1:13
      .= Computation(s1,0+1)|dom p by AMI_1:14
      .= (Following (Computation(s2,0)))|dom p by A14,AMI_1:14
      .= (Following(s2))|dom p by AMI_1:13;
A16: ICplusConst(s1,0) = ((Following(s1))|dom p).IC SCMPDS by A1,A12,FUNCT_1:72
      .= ICplusConst(s2,1) by A1,A13,A15,FUNCT_1:72;
    IC s2 = il by A1,A4,A7,AMI_1:97,XBOOLE_1:1
      .= IC s1 by A1,A3,A7,AMI_1:97,XBOOLE_1:1;
    hence contradiction by A16,Th19;
  end;
  hence contradiction;
end;

theorem Th22:
  for p being autonomic non programmed FinPartState of SCMPDS ,
  s being State of SCMPDS st p c= s for i being Element of NAT
  holds IC Computation(s,i) in dom ProgramPart(p)
proof
  let p be autonomic non programmed FinPartState of SCMPDS,
  s be State of SCMPDS such that
A1: p c= s;
  let i be Element of NAT;
  set Csi = Computation(s,i);
  set loc = IC Csi;
  assume
A2: not IC Computation(s,i) in dom ProgramPart(p);
A3: loc in NAT by AMI_1:def 4;
  loc in dom ProgramPart p iff loc in dom p /\ NAT by FUNCT_1:68;
  then
A4: not loc in dom p by A2,A3,XBOOLE_0:def 4;
  set p1 = p +* (loc .--> goto 0 );
  set p2 = p +* (loc .--> goto 1 );
A5: dom p1 = dom p \/ dom (loc .--> goto 0 ) &
  dom p2 = dom p \/ dom (loc .--> goto 1 ) by FUNCT_4:def 1;
A6: dom (loc .--> goto 0 ) = {loc} &
  dom (loc .--> goto 1 ) = {loc} by FUNCOP_1:19;
  then
A7: loc in dom (loc .--> goto 0 ) &
  loc in dom (loc .--> goto 1) by TARSKI:def 1;
  then
A8: loc in dom p1 & loc in dom p2 by A5,XBOOLE_0:def 3;
  consider s1 being State of SCMPDS such that
A9: p1 c= s1 by CARD_3:97;
  consider s2 being State of SCMPDS such that
A10: p2 c= s2 by CARD_3:97;
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
  p is not autonomic
  proof
    take s1, s2;
    dom s1 = the carrier of SCMPDS & dom s2 = the carrier of SCMPDS
    by AMI_1:79;
    then
A11: dom p c= dom s1 & dom p c= dom s2 by AMI_1:80;
    now
      let x be set;
      assume
A12:  x in dom p;
      then dom p misses dom (loc .--> goto 0 ) &
      x in dom p1 by A4,A5,A6,XBOOLE_0:def 3,ZFMISC_1:56;
      then p.x = p1.x & p1.x = s1.x by A9,A12,FUNCT_4:17,GRFUNC_1:8;
      hence p.x = s1.x;
    end;
    hence
A13: p c= s1 by A11,GRFUNC_1:8;
    now
      let x be set;
      assume
A14:  x in dom p;
      then dom p misses dom (loc .--> goto 1 ) &
      x in dom p2 by A4,A5,A6,XBOOLE_0:def 3,ZFMISC_1:56;
      then p.x = p2.x & p2.x = s2.x by A10,A14,FUNCT_4:17,GRFUNC_1:8;
      hence p.x = s2.x;
    end;
    hence
A15: p c= s2 by A11,GRFUNC_1:8;
    (loc .--> goto 0 ).loc = goto 0 &
    (loc .--> goto 1 ).loc = goto 1 by FUNCOP_1:87;
    then p1.loc = goto 0 & p2.loc = goto 1 by A7,FUNCT_4:14;
    then
A16: s1.loc = goto 0 & s2.loc = goto 1 by A8,A9,A10,GRFUNC_1:8;
    take k = i+1;
    set Cs1k = Computation(s1,k);
    set Cs2k = Computation(s2,k);
A17: Cs1k = Following Cs1i by AMI_1:14
      .= Exec (CurInstr Cs1i, Cs1i);
A18: Cs2k = Following Cs2i by AMI_1:14
      .= Exec (CurInstr Cs2i, Cs2i);
A19: Cs1i.loc = goto 0 & Cs2i.loc = goto 1 by A16,AMI_1:54;
A20: (Cs1i|dom p) = (Csi|dom p) by A1,A13,AMI_1:def 25;
A21: Cs1i.IC SCMPDS = (Cs1i|dom p).IC SCMPDS &
    Csi.IC SCMPDS = (Csi|dom p).IC SCMPDS by Th17,FUNCT_1:72;
A22: (Cs1i|dom p) = (Cs2i|dom p) by A13,A15,AMI_1:def 25;
    then Cs1i.IC SCMPDS = loc & Cs2i.IC SCMPDS = loc
    by A20,A21,Th17,FUNCT_1:72;
    then
A23: Cs1k.IC SCMPDS = ICplusConst(Cs1i,0) &
    Cs2k.IC SCMPDS = ICplusConst(Cs2i,1) by A17,A18,A19,SCMPDS_2:66;
A24: IC Cs1i = IC Cs2i by A21,A22,Th17,FUNCT_1:72;
    (Cs1k|dom p).IC SCMPDS = Cs1k.IC SCMPDS &
    (Cs2k|dom p).IC SCMPDS = Cs2k.IC SCMPDS by Th17,FUNCT_1:72;
    hence Cs1k|dom p <> Cs2k|dom p by A23,A24,Th19;
  end;
  hence contradiction;
end;

theorem Th23:
  for p being autonomic non programmed FinPartState of SCMPDS ,
  s1, s2 being State of SCMPDS st p c= s1 & p c= s2 for i being Element of NAT
  holds IC Computation(s1,i) = IC Computation(s2,i) &
  CurInstr (Computation(s1,i)) = CurInstr (Computation(s2,i))
proof
  let p be autonomic non programmed FinPartState of SCMPDS ,
  s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT;
  set I = CurInstr (Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i); thus
A2: IC Cs1i = IC Cs2i
  proof
    assume
A3: IC Computation(s1,i) <> IC Computation(s2,i);
    (Cs1i|dom p).IC SCMPDS = Cs1i.IC SCMPDS &
    (Cs2i|dom p).IC SCMPDS = Cs2i.IC SCMPDS by Th17,FUNCT_1:72;
    hence contradiction by A1,A3,AMI_1:def 25;
  end;
  thus I = CurInstr (Computation(s2,i))
  proof
    assume
A4: I <> CurInstr (Computation(s2,i));
A5: IC Cs1i in dom ProgramPart p & IC Cs2i in dom ProgramPart p by A1,Th22;
    ProgramPart p c= p by RELAT_1:88;
    then dom ProgramPart p c= dom p by GRFUNC_1:8;
    then (Cs1i|dom p).IC Cs1i = Cs1i.IC Cs1i & (Cs2i|dom p).IC Cs2i = Cs2i.IC
    Cs2i by A5,FUNCT_1:72;
    hence contradiction by A1,A2,A4,AMI_1:def 25;
  end;
end;

theorem
  for p being autonomic non programmed FinPartState of SCMPDS,
  s1, s2 being State of SCMPDS st p c= s1 & p c= s2
  for i being Element of NAT,k1,k2 be Integer,a,b be Int_position
  st CurInstr (Computation(s1,i)) = (a,k1) := (b,k2) &
  a in dom p & DataLoc(Computation(s1,i).a,k1) in dom p
  holds Computation(s1,i).DataLoc(Computation(s1,i).b,k2) =
  Computation(s2,i).DataLoc(Computation(s2,i).b,k2)
proof
  let p be autonomic non programmed FinPartState of SCMPDS,
  s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT,k1,k2 be Integer,a,b be Int_position;
  set I = CurInstr (Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
A2: I = CurInstr (Computation(s2,i)) by A1,Th23;
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A5: DataLoc(Cs1i.a,k1) in dom p implies (Cs1i1|dom p).DataLoc(Cs1i.a,k1)
  = Cs1i1.DataLoc(Cs1i.a,k1) & (Cs2i1|dom p).DataLoc(Cs1i.a,k1)
  = Cs2i1.DataLoc(Cs1i.a,k1) by FUNCT_1:72;
A6: a in dom p implies (Cs1i|dom p).a = Cs1i.a &
  (Cs2i|dom p).a = Cs2i.a by FUNCT_1:72;
  assume
A7: I = (a,k1) := (b,k2) & a in dom p & DataLoc(Cs1i.a,k1) in dom p;
  then
A8: Cs1i.a=Cs2i.a by A1,A6,AMI_1:def 25;
  Cs1i1.DataLoc(Cs1i.a,k1) = Cs1i.DataLoc(Cs1i.b,k2) &
  Cs2i1.DataLoc(Cs2i.a,k1) = Cs2i.DataLoc(Cs2i.b,k2)
  by A2,A3,A4,A7,SCMPDS_2:59;
  hence thesis by A1,A5,A7,A8,AMI_1:def 25;
end;

theorem
  for p being autonomic non programmed FinPartState of SCMPDS,
  s1, s2 being State of SCMPDS st p c= s1 & p c= s2
  for i being Element of NAT,k1,k2 be Integer,a,b be Int_position
  st CurInstr (Computation(s1,i)) = AddTo(a,k1,b,k2) &
  a in dom p & DataLoc(Computation(s1,i).a,k1) in dom p
  holds Computation(s1,i).DataLoc(Computation(s1,i).b,k2)
  = Computation(s2,i).DataLoc(Computation(s2,i).b,k2)
proof
  let p be autonomic non programmed FinPartState of SCMPDS,
  s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT,k1,k2 be Integer,a,b be Int_position;
  set I = CurInstr (Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
A2: I = CurInstr (Computation(s2,i)) by A1,Th23;
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A5: DataLoc(Cs1i.a,k1) in dom p implies (Cs1i1|dom p).DataLoc(Cs1i.a,k1)
  = Cs1i1.DataLoc(Cs1i.a,k1) & (Cs2i1|dom p).DataLoc(Cs1i.a,k1)
  = Cs2i1.DataLoc(Cs1i.a,k1) by FUNCT_1:72;
A6: a in dom p implies (Cs1i|dom p).a = Cs1i.a &
  (Cs2i|dom p).a = Cs2i.a by FUNCT_1:72;
A7: DataLoc(Cs1i.a,k1) in dom p implies (Cs1i|dom p).DataLoc(Cs1i.a,k1)
  = Cs1i.DataLoc(Cs1i.a,k1) & (Cs2i|dom p).DataLoc(Cs1i.a,k1)
  = Cs2i.DataLoc(Cs1i.a,k1) by FUNCT_1:72;
  assume
A8: I = AddTo(a,k1,b,k2) & a in dom p & DataLoc(Cs1i.a,k1) in dom p;
  set D11=Cs1i1.DataLoc(Cs1i.a,k1), D21=Cs2i1.DataLoc(Cs2i.a,k1),
  C11=Cs1i.DataLoc(Cs1i.a,k1), C12=Cs1i.DataLoc(Cs1i.b,k2),
  C21=Cs2i.DataLoc(Cs2i.a,k1), C22=Cs2i.DataLoc(Cs2i.b,k2);
A9: Cs1i.a=Cs2i.a by A1,A6,A8,AMI_1:def 25;
  then
A10: C11=C21 by A1,A7,A8,AMI_1:def 25;
A11: D11 = D21 by A1,A5,A8,A9,AMI_1:def 25;
  D11 = C11+ C12 & D21 = C21 + C22 by A2,A3,A4,A8,SCMPDS_2:61;
  hence thesis by A10,A11;
end;

theorem
  for p being autonomic non programmed FinPartState of SCMPDS,
  s1, s2 being State of SCMPDS st p c= s1 & p c= s2
  for i being Element of NAT,k1,k2 be Integer,a,b be Int_position
  st CurInstr (Computation(s1,i)) = SubFrom(a,k1,b,k2) &
  a in dom p & DataLoc(Computation(s1,i).a,k1) in dom p
  holds Computation(s1,i).DataLoc(Computation(s1,i).b,k2)
  = Computation(s2,i).DataLoc(Computation(s2,i).b,k2)
proof
  let p be autonomic non programmed FinPartState of SCMPDS,
  s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT,k1,k2 be Integer,a,b be Int_position;
  set I = CurInstr (Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
A2: I = CurInstr (Computation(s2,i)) by A1,Th23;
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A5: DataLoc(Cs1i.a,k1) in dom p implies (Cs1i1|dom p).DataLoc(Cs1i.a,k1)
  = Cs1i1.DataLoc(Cs1i.a,k1) & (Cs2i1|dom p).DataLoc(Cs1i.a,k1)
  = Cs2i1.DataLoc(Cs1i.a,k1) by FUNCT_1:72;
A6: a in dom p implies (Cs1i|dom p).a = Cs1i.a &
  (Cs2i|dom p).a = Cs2i.a by FUNCT_1:72;
A7: DataLoc(Cs1i.a,k1) in dom p implies (Cs1i|dom p).DataLoc(Cs1i.a,k1)
  = Cs1i.DataLoc(Cs1i.a,k1) & (Cs2i|dom p).DataLoc(Cs1i.a,k1)
  = Cs2i.DataLoc(Cs1i.a,k1) by FUNCT_1:72;
  assume
A8: I = SubFrom(a,k1,b,k2) & a in dom p & DataLoc(Cs1i.a,k1) in dom p;
  set D11=Cs1i1.DataLoc(Cs1i.a,k1), D21=Cs2i1.DataLoc(Cs2i.a,k1),
  C11=Cs1i.DataLoc(Cs1i.a,k1), C12=Cs1i.DataLoc(Cs1i.b,k2),
  C21=Cs2i.DataLoc(Cs2i.a,k1), C22=Cs2i.DataLoc(Cs2i.b,k2);
A9: Cs1i.a=Cs2i.a by A1,A6,A8,AMI_1:def 25;
  then
A10: C11=C21 by A1,A7,A8,AMI_1:def 25;
A11: D11 = D21 by A1,A5,A8,A9,AMI_1:def 25;
  D11 = C11- C12 & D21 = C21 - C22 by A2,A3,A4,A8,SCMPDS_2:62;
  hence thesis by A10,A11;
end;

theorem
  for p being autonomic non programmed FinPartState of SCMPDS,
  s1, s2 being State of SCMPDS st p c= s1 & p c= s2
  for i being Element of NAT,k1,k2 be Integer,a,b be Int_position
  st CurInstr (Computation(s1,i)) = MultBy(a,k1,b,k2) &
  a in dom p & DataLoc(Computation(s1,i).a,k1) in dom p
  holds Computation(s1,i).DataLoc(Computation(s1,i).a,k1)
  * Computation(s1,i).DataLoc(Computation(s1,i).b,k2)
  = Computation(s2,i).DataLoc(Computation(s2,i).a,k1)
  * Computation(s2,i).DataLoc(Computation(s2,i).b,k2)
proof
  let p be autonomic non programmed FinPartState of SCMPDS,
  s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT,k1,k2 be Integer,a,b be Int_position;
  set I = CurInstr (Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
A2: I = CurInstr (Computation(s2,i)) by A1,Th23;
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A5: DataLoc(Cs1i.a,k1) in dom p implies (Cs1i1|dom p).DataLoc(Cs1i.a,k1)
  = Cs1i1.DataLoc(Cs1i.a,k1) & (Cs2i1|dom p).DataLoc(Cs1i.a,k1)
  = Cs2i1.DataLoc(Cs1i.a,k1) by FUNCT_1:72;
A6: a in dom p implies (Cs1i|dom p).a = Cs1i.a &
  (Cs2i|dom p).a = Cs2i.a by FUNCT_1:72;
  assume
A7: I = MultBy (a,k1,b,k2) & a in dom p & DataLoc(Cs1i.a,k1) in dom p;
  set D11=Cs1i1.DataLoc(Cs1i.a,k1), D21=Cs2i1.DataLoc(Cs2i.a,k1);
A8: Cs1i.a=Cs2i.a by A1,A6,A7,AMI_1:def 25;
  D11 = Cs1i.DataLoc(Cs1i.a,k1) * Cs1i.DataLoc(Cs1i.b,k2) &
  D21 = Cs2i.DataLoc(Cs2i.a,k1) * Cs2i.DataLoc(Cs2i.b,k2)
  by A2,A3,A4,A7,SCMPDS_2:63;
  hence thesis by A1,A5,A7,A8,AMI_1:def 25;
end;

theorem
  for p being autonomic non programmed FinPartState of SCMPDS,
  s1, s2 being State of SCMPDS st p c= s1 & p c= s2
  for i,m being Element of NAT,a being Int_position,k1,k2 be Integer
  st CurInstr (Computation(s1,i)) = (a,k1)<>0_goto k2 &
  m= IC Computation(s1,i) & m+k2 >= 0 & k2 <> 1
  holds (Computation(s1,i).DataLoc(Computation(s1,i).a,k1) = 0 iff
  Computation(s2,i).DataLoc(Computation(s2,i).a,k1) = 0 )
proof
  let p be autonomic non programmed FinPartState of SCMPDS,
  s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i,m be Element of NAT,a be Int_position,k1,k2 be Integer;
  set I = CurInstr (Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
A2: IC Cs1i = IC Cs2i by A1,Th23;
A3: I = CurInstr (Computation(s2,i)) by A1,Th23;
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A4: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A5: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A6: (Cs1i1|dom p).IC SCMPDS = Cs1i1.IC SCMPDS &
  (Cs2i1|dom p).IC SCMPDS = Cs2i1.IC SCMPDS by Th17,FUNCT_1:72;
A7: (Cs1i1|dom p) = (Cs2i1|dom p) by A1,AMI_1:def 25;
  assume
A8: I = (a,k1)<>0_goto k2 & m= IC Cs1i & m+k2 >= 0 & k2 <> 1;
A9: m+1>=0 by NAT_1:2;
A10: now
    assume
A11: Computation(s1,i).DataLoc(Cs1i.a,k1) = 0 &
    Computation(s2,i).DataLoc(Cs2i.a,k1) <> 0;
    then
A12: Cs1i1.IC SCMPDS = Next IC Cs1i by A4,A8,SCMPDS_2:67
      .=ICplusConst(Cs1i,1) by Th20;
    Cs2i1.IC SCMPDS = ICplusConst(Cs2i,k2) by A3,A5,A8,A11,SCMPDS_2:67;
    hence contradiction by A2,A6,A7,A8,A9,A12,Th18;
  end;
  now
    assume
A13: Computation(s2,i).DataLoc(Cs2i.a,k1) = 0 &
    Computation(s1,i).DataLoc(Cs1i.a,k1) <> 0;
    then
A14: Cs2i1.IC SCMPDS = Next IC Cs2i by A3,A5,A8,SCMPDS_2:67
      .=ICplusConst(Cs2i,1) by Th20;
    Cs1i1.IC SCMPDS = ICplusConst(Cs1i,k2) by A4,A8,A13,SCMPDS_2:67;
    hence contradiction by A2,A6,A7,A8,A9,A14,Th18;
  end;
  hence Computation(s1,i).DataLoc(Cs1i.a,k1) = 0 iff
  Computation(s2,i).DataLoc(Cs2i.a,k1) = 0 by A10;
end;

theorem
  for p being autonomic non programmed FinPartState of SCMPDS,
  s1, s2 being State of SCMPDS st p c= s1 & p c= s2
  for i,m being Element of NAT,a being Int_position,k1,k2 be Integer
  st CurInstr (Computation(s1,i)) = (a,k1)<=0_goto k2 &
  m= IC Computation(s1,i) & m+k2 >= 0 & k2 <> 1
  holds (Computation(s1,i).DataLoc(Computation(s1,i).a,k1) > 0 iff
  Computation(s2,i).DataLoc(Computation(s2,i).a,k1) > 0 )
proof
  let p be autonomic non programmed FinPartState of SCMPDS,
  s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i,m be Element of NAT,a be Int_position,k1,k2 be Integer;
  set I = CurInstr (Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
A2: IC Cs1i = IC Cs2i by A1,Th23;
A3: I = CurInstr (Computation(s2,i)) by A1,Th23;
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A4: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A5: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A6: (Cs1i1|dom p).IC SCMPDS = Cs1i1.IC SCMPDS &
  (Cs2i1|dom p).IC SCMPDS = Cs2i1.IC SCMPDS by Th17,FUNCT_1:72;
A7: (Cs1i1|dom p) = (Cs2i1|dom p) by A1,AMI_1:def 25;
  assume
A8: I = (a,k1)<=0_goto k2 & m= IC Cs1i & m+k2 >= 0 & k2 <> 1;
A9: m+1>=0 by NAT_1:2;
A10: now
    assume
A11: Computation(s1,i).DataLoc(Cs1i.a,k1) > 0 &
    Computation(s2,i).DataLoc(Cs2i.a,k1) <= 0;
    then
A12: Cs1i1.IC SCMPDS = Next IC Cs1i by A4,A8,SCMPDS_2:68
      .=ICplusConst(Cs1i,1) by Th20;
    Cs2i1.IC SCMPDS = ICplusConst(Cs2i,k2) by A3,A5,A8,A11,SCMPDS_2:68;
    hence contradiction by A2,A6,A7,A8,A9,A12,Th18;
  end;
  now
    assume
A13: Computation(s2,i).DataLoc(Cs2i.a,k1) > 0 &
    Computation(s1,i).DataLoc(Cs1i.a,k1) <= 0;
    then
A14: Cs2i1.IC SCMPDS = Next IC Cs2i by A3,A5,A8,SCMPDS_2:68
      .=ICplusConst(Cs2i,1) by Th20;
    Cs1i1.IC SCMPDS = ICplusConst(Cs1i,k2) by A4,A8,A13,SCMPDS_2:68;
    hence contradiction by A2,A6,A7,A8,A9,A14,Th18;
  end;
  hence Computation(s1,i).DataLoc(Cs1i.a,k1) > 0 iff
  Computation(s2,i).DataLoc(Cs2i.a,k1) > 0 by A10;
end;

theorem
  for p being autonomic non programmed FinPartState of SCMPDS,
  s1, s2 being State of SCMPDS st p c= s1 & p c= s2
  for i,m being Element of NAT,a being Int_position,k1,k2 be Integer
  st CurInstr (Computation(s1,i)) = (a,k1)>=0_goto k2 &
  m= IC Computation(s1,i) & m+k2 >= 0 & k2 <> 1
  holds (Computation(s1,i).DataLoc(Computation(s1,i).a,k1) < 0 iff
  Computation(s2,i).DataLoc(Computation(s2,i).a,k1) < 0 )
proof
  let p be autonomic non programmed FinPartState of SCMPDS,
  s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
  let i,m be Element of NAT,a be Int_position,k1,k2 be Integer;
  set I = CurInstr (Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
A2: IC Cs1i = IC Cs2i by A1,Th23;
A3: I = CurInstr (Computation(s2,i)) by A1,Th23;
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A4: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A5: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A6: (Cs1i1|dom p).IC SCMPDS = Cs1i1.IC SCMPDS &
  (Cs2i1|dom p).IC SCMPDS = Cs2i1.IC SCMPDS by Th17,FUNCT_1:72;
A7: (Cs1i1|dom p) = (Cs2i1|dom p) by A1,AMI_1:def 25;
  assume
A8: I = (a,k1)>=0_goto k2 & m= IC Cs1i & m+k2 >= 0 & k2 <> 1;
A9: m+1>=0 by NAT_1:2;
A10: now
    assume
A11: Computation(s1,i).DataLoc(Cs1i.a,k1) < 0 &
    Computation(s2,i).DataLoc(Cs2i.a,k1) >= 0;
    then
A12: Cs1i1.IC SCMPDS = Next IC Cs1i by A4,A8,SCMPDS_2:69
      .=ICplusConst(Cs1i,1) by Th20;
    Cs2i1.IC SCMPDS = ICplusConst(Cs2i,k2) by A3,A5,A8,A11,SCMPDS_2:69;
    hence contradiction by A2,A6,A7,A8,A9,A12,Th18;
  end;
  now
    assume
A13: Computation(s2,i).DataLoc(Cs2i.a,k1) < 0 &
    Computation(s1,i).DataLoc(Cs1i.a,k1) >= 0;
    then
A14: Cs2i1.IC SCMPDS = Next IC Cs2i by A3,A5,A8,SCMPDS_2:69
      .=ICplusConst(Cs2i,1) by Th20;
    Cs1i1.IC SCMPDS = ICplusConst(Cs1i,k2) by A4,A8,A13,SCMPDS_2:69;
    hence contradiction by A2,A6,A7,A8,A9,A14,Th18;
  end;
  hence Computation(s1,i).DataLoc(Cs1i.a,k1) < 0 iff
  Computation(s2,i).DataLoc(Cs2i.a,k1) < 0 by A10;
end;

begin :: Program Shift in the SCMPDS Computer

definition
  let k;
  canceled;
  func inspos k -> Instruction-Location of SCMPDS equals
   k;
  coherence by AMI_1:def 4;
end;

