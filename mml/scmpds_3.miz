:: Computation and Program Shift in the SCMPDS Computer
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies SCMPDS_2, INT_1, AMI_1, AMI_2, SCMPDS_1, ABSVALUE, ARYTM_1,
      RELAT_1, FUNCT_1, BOOLE, AMI_5, AMI_3, NAT_1, FUNCT_4, CARD_3, CAT_1,
      FUNCOP_1, RELOC, FINSET_1, SCMPDS_3, ARYTM;
 notations TARSKI, XBOOLE_0, SUBSET_1, FUNCT_2, NUMBERS, XCMPLX_0, CARD_3,
      RELAT_1, FUNCT_1, FUNCT_4, INT_1, NAT_1, STRUCT_0, FUNCOP_1, FINSET_1,
      AMI_1, AMI_2, AMI_3, SCMPDS_1, SCMPDS_2, BINARITH, INT_2, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, NAT_1, INT_2, SEQ_1, BINARITH, AMI_5,
      SCMPDS_1, SCMPDS_2, REAL_1, VALUED_1, PARTFUN1;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1,
      FRAENKEL, NUMBERS, XREAL_0, INT_1, CARD_3, TREES_2, AMI_1, AMI_3,
      SCMPDS_2, VALUED_1, FUNCT_2;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM, REAL;
 definitions AMI_1, AMI_2, AMI_3, TARSKI, XBOOLE_0, FUNCOP_1, SCMPDS_2,
      VALUED_1;
 theorems AMI_1, AMI_3, GRFUNC_1, NAT_1, FUNCOP_1, TARSKI, FUNCT_4, FUNCT_1,
      FINSET_1, ZFMISC_1, INT_1, RELAT_1, AMI_5, ABSVALUE, SCMPDS_2, BINARITH,
      FUNCT_2, XBOOLE_0, XBOOLE_1, CARD_3, AMI_2;
 schemes CLASSES1, FUNCT_7;

begin :: Preliminaries

reserve j, k, m, n for Element of NAT,
        a,b for Int_position,
        k1,k2 for Integer;

canceled;

theorem Th2:
  for k1 be Integer,s1,s2 being State of SCMPDS st IC s1 = IC s2
  holds ICplusConst(s1,k1)=ICplusConst(s2,k1)
proof let k1 be Integer,s1,s2 be State of SCMPDS;
      assume A1: IC s1 = IC s2;
      consider i being Element of NAT such that
A2:  i = IC s1 & ICplusConst(s1,k1) = abs(i+k1) by SCMPDS_2:def 20;
      consider j being Element of NAT such that
A3:  j = IC s2 & ICplusConst(s2,k1) = abs(j+k1) by SCMPDS_2:def 20;
     thus thesis by A1,A2,A3;
end;

theorem Th3:
  for k1 be Integer,a be Int_position,s1,s2 being State of SCMPDS st
  s1 | SCM-Data-Loc = s2 | SCM-Data-Loc
  holds s1.DataLoc(s1.a,k1)=s2.DataLoc(s2.a,k1)
proof
    let k1 be Integer,a be Int_position,s1,s2 be State of SCMPDS;
    assume A1: s1 | SCM-Data-Loc = s2 | SCM-Data-Loc;
    A2: a in SCM-Data-Loc by SCMPDS_2:def 2;
    A3: DataLoc(s1.a,k1) in SCM-Data-Loc by SCMPDS_2:def 2;
    A4: s1.a= (s1 | SCM-Data-Loc).a by A2,FUNCT_1:72
          .= s2.a by A1,A2,FUNCT_1:72;
    thus s1.DataLoc(s1.a,k1)= (s1 | SCM-Data-Loc).DataLoc(s1.a,k1)
           by A3,FUNCT_1:72
          .= s2.DataLoc(s2.a,k1) by A1,A3,A4,FUNCT_1:72;
end;

theorem Th4:
  for a be Int_position,s1,s2 being State of SCMPDS st
  s1 | SCM-Data-Loc = s2 | SCM-Data-Loc holds s1.a=s2.a
proof
    let a be Int_position,s1,s2 be State of SCMPDS;
    assume A1: s1 | SCM-Data-Loc = s2 | SCM-Data-Loc;
     A2: a in SCM-Data-Loc by SCMPDS_2:def 2;
     hence s1.a= (s1 | SCM-Data-Loc).a by FUNCT_1:72
           .= s2.a by A1,A2,FUNCT_1:72;
end;

theorem
   the carrier of SCMPDS = {IC SCMPDS } \/ SCM-Data-Loc \/
         NAT
    by AMI_3:4;

theorem Th6:
 not IC SCMPDS in SCM-Data-Loc
proof assume IC SCMPDS in SCM-Data-Loc;
  then IC SCMPDS is Int_position by SCMPDS_2:9;
then ObjectKind IC SCMPDS = INT by SCMPDS_2:13;
 hence contradiction by AMI_1:def 11,SCMPDS_2:4;
end;

theorem Th7:
  for s1,s2 being State of SCMPDS st
   s1 | (SCM-Data-Loc \/ {IC SCMPDS }) = s2 | (SCM-Data-Loc \/ {IC SCMPDS })
  for l being Instruction of SCMPDS holds
      Exec (l,s1) | (SCM-Data-Loc \/ {IC SCMPDS })
    = Exec (l,s2) | (SCM-Data-Loc \/ {IC SCMPDS })
proof
     let s1,s2 be State of SCMPDS such that
A1: s1 | (SCM-Data-Loc \/ {IC SCMPDS})=s2 | (SCM-Data-Loc \/ {IC SCMPDS});
         SCM-Data-Loc c= SCM-Data-Loc \/ {IC SCMPDS} by XBOOLE_1:7;
then A2: s1 | SCM-Data-Loc =s2 | SCM-Data-Loc by A1,RELAT_1:188;
         IC SCMPDS in {IC SCMPDS} by TARSKI:def 1;
then A3:  IC SCMPDS in (SCM-Data-Loc \/ {IC SCMPDS}) by XBOOLE_0:def 2;
A4:  (SCM-Data-Loc \/ {IC SCMPDS}) c= the carrier of SCMPDS by AMI_3:4
,XBOOLE_1:7;
     then (SCM-Data-Loc \/ {IC SCMPDS}) c= dom s1 by AMI_1:79;
then A5:  IC SCMPDS in dom (s1 | (SCM-Data-Loc \/ {IC SCMPDS})) by A3,
RELAT_1:91;
         (SCM-Data-Loc \/ {IC SCMPDS}) c= dom s2 by A4,AMI_1:79;
then A6:  IC SCMPDS in dom (s2 | (SCM-Data-Loc \/ {IC SCMPDS})) by A3,
RELAT_1:91;
A7:   IC s1
      = (s2 | (SCM-Data-Loc \/ {IC SCMPDS})).IC SCMPDS by A1,A5,FUNCT_1:70
     .= IC s2 by A6,FUNCT_1:70;
     let l be Instruction of SCMPDS;
A8:  dom Exec(l,s1) = the carrier of SCMPDS by AMI_1:79;
A9:  dom Exec(l,s2) = the carrier of SCMPDS by AMI_1:79;
A10:  dom Exec(l,s1) = dom Exec(l,s2) by A8,AMI_1:79;
A11:  dom ((Exec (l,s1)) | SCM-Data-Loc)= SCM-Data-Loc by A8,RELAT_1:91;
A12:  dom ((Exec (l,s2)) | SCM-Data-Loc)= SCM-Data-Loc by A9,RELAT_1:91;
A13: InsCode(l) <= 13 by SCMPDS_2:15;
     per cases by A13,NAT_1:38;
     suppose InsCode (l) = 0;
         then consider k1 such that
     A14: l = goto k1 by SCMPDS_2:35;
         for x being set st x in SCM-Data-Loc holds
        (Exec (l,s1) | SCM-Data-Loc ).x = (Exec (l,s2) | SCM-Data-Loc ).x
     proof
        let x be set; assume
     A15: x in SCM-Data-Loc;
         then reconsider a = x as Int_position by SCMPDS_2:9;
         thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).a by A15,FUNCT_1:72
          .= s1.a by A14,SCMPDS_2:66
          .= (s1 | SCM-Data-Loc).a by A15,FUNCT_1:72
          .= s2.a by A2,A15,FUNCT_1:72
          .= (Exec (l,s2)).a by A14,SCMPDS_2:66
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A15,FUNCT_1:72;
       end;
    then A16: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
         by A11,A12,FUNCT_1:9;
             Exec (l,s1).IC SCMPDS = ICplusConst(s1,k1) by A14,SCMPDS_2:66
         .= ICplusConst(s2,k1) by A7,Th2
         .= Exec (l,s2).IC SCMPDS by A14,SCMPDS_2:66;
       then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
       hence thesis by A16,RELAT_1:185;

     end;
     suppose InsCode (l) = 1;
         then consider a such that
     A17: l = return a by SCMPDS_2:36;
         for x being set st x in SCM-Data-Loc holds
        (Exec (l,s1) | SCM-Data-Loc ).x = (Exec (l,s2) | SCM-Data-Loc ).x
     proof
        let x be set; assume
     A18: x in SCM-Data-Loc;
         then reconsider b = x as Int_position by SCMPDS_2:9;
         per cases;
         suppose A19:b<>a;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).b by A18,FUNCT_1:72
          .= s1.b by A17,A19,SCMPDS_2:70
          .= (s1 | SCM-Data-Loc).b by A18,FUNCT_1:72
          .= s2.b by A2,A18,FUNCT_1:72
          .= (Exec (l,s2)).b by A17,A19,SCMPDS_2:70
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A18,FUNCT_1:72;
         end;
         suppose A20:b=a;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).b by A18,FUNCT_1:72
          .= s1.DataLoc(s1.a,RetSP) by A17,A20,SCMPDS_2:70
          .= s2.DataLoc(s2.a,RetSP) by A2,Th3
          .= (Exec (l,s2)).b by A17,A20,SCMPDS_2:70
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A18,FUNCT_1:72;
       end;
       end;
    then A21: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
         by A11,A12,FUNCT_1:9;
             Exec (l,s1).IC SCMPDS = (abs(s1.DataLoc(s1.a,RetIC)))+2
         by A17,SCMPDS_2:70
         .= (abs(s2.DataLoc(s2.a,RetIC)))+2 by A2,Th3
         .= Exec (l,s2).IC SCMPDS by A17,SCMPDS_2:70;
       then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
       hence thesis by A21,RELAT_1:185;

     end;
     suppose InsCode (l) = 2;
         then consider a,k1 such that
     A22: l= a:=k1 by SCMPDS_2:37;
         for x being set st x in SCM-Data-Loc holds
        (Exec (l,s1) | SCM-Data-Loc ).x = (Exec (l,s2) | SCM-Data-Loc ).x
     proof
        let x be set; assume
     A23: x in SCM-Data-Loc;
         then reconsider b = x as Int_position by SCMPDS_2:9;
         per cases;
         suppose A24:b<>a;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).b by A23,FUNCT_1:72
          .= s1.b by A22,A24,SCMPDS_2:57
          .= (s1 | SCM-Data-Loc).b by A23,FUNCT_1:72
          .= s2.b by A2,A23,FUNCT_1:72
          .= (Exec (l,s2)).b by A22,A24,SCMPDS_2:57
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A23,FUNCT_1:72;
         end;
         suppose A25:b=a;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).b by A23,FUNCT_1:72
          .= k1 by A22,A25,SCMPDS_2:57
          .= (Exec (l,s2)).b by A22,A25,SCMPDS_2:57
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A23,FUNCT_1:72;
       end;
       end;
    then A26: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
         by A11,A12,FUNCT_1:9;
             Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A22,SCMPDS_2:57
         .= Exec (l,s2).IC SCMPDS by A22,SCMPDS_2:57;
       then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
       hence thesis by A26,RELAT_1:185;

     end;
     suppose InsCode (l) = 3;
         then consider a,k1 such that
     A27: l= saveIC(a,k1) by SCMPDS_2:38;
         for x being set st x in SCM-Data-Loc holds
        (Exec (l,s1) | SCM-Data-Loc ).x = (Exec (l,s2) | SCM-Data-Loc ).x
     proof
        let x be set; assume
     A28: x in SCM-Data-Loc;
         then reconsider b = x as Int_position by SCMPDS_2:9;
         per cases;
         suppose A29:b<>DataLoc(s1.a,k1);
           then A30:b<>DataLoc(s2.a,k1) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).b by A28,FUNCT_1:72
          .= s1.b by A27,A29,SCMPDS_2:71
          .= (s1 | SCM-Data-Loc).b by A28,FUNCT_1:72
          .= s2.b by A2,A28,FUNCT_1:72
          .= (Exec (l,s2)).b by A27,A30,SCMPDS_2:71
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A28,FUNCT_1:72;
         end;
         suppose A31:b=DataLoc(s1.a,k1);
           then A32:b=DataLoc(s2.a,k1) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).b by A28,FUNCT_1:72
          .= IC s2 by A7,A27,A31,SCMPDS_2:71
          .= (Exec (l,s2)).b by A27,A32,SCMPDS_2:71
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A28,FUNCT_1:72;
       end;
       end;
    then A33: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
         by A11,A12,FUNCT_1:9;
             Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A27,SCMPDS_2:71
         .= Exec (l,s2).IC SCMPDS by A27,SCMPDS_2:71;
       then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
       hence thesis by A33,RELAT_1:185;
     end;
     suppose InsCode (l) = 4;
         then consider a,k1,k2 such that
     A34: l = (a,k1)<>0_goto k2 by SCMPDS_2:39;
         for x being set st x in SCM-Data-Loc holds
        (Exec (l,s1) | SCM-Data-Loc ).x = (Exec (l,s2) | SCM-Data-Loc ).x
     proof
        let x be set; assume
     A35: x in SCM-Data-Loc;
         then reconsider b = x as Int_position by SCMPDS_2:9;
       thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).b by A35,FUNCT_1:72
          .= s1.b by A34,SCMPDS_2:67
          .= (s1 | SCM-Data-Loc).b by A35,FUNCT_1:72
          .= s2.b by A2,A35,FUNCT_1:72
          .= (Exec (l,s2)).b by A34,SCMPDS_2:67
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A35,FUNCT_1:72;
     end;
    then A36: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
         by A11,A12,FUNCT_1:9;
         now
        per cases;
        suppose A37:s1.DataLoc(s1.a,k1) <> 0;
              then A38:s2.DataLoc(s2.a,k1) <> 0 by A2,Th3;
        thus Exec (l,s1).IC SCMPDS = ICplusConst(s1,k2) by A34,A37,SCMPDS_2:67
         .= ICplusConst(s2,k2) by A7,Th2
         .= Exec (l,s2).IC SCMPDS by A34,A38,SCMPDS_2:67;
        end;
        suppose A39:s1.DataLoc(s1.a,k1) = 0;
              then A40:s2.DataLoc(s2.a,k1) = 0 by A2,Th3;
        thus Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A34,A39,SCMPDS_2:67
         .= Exec (l,s2).IC SCMPDS by A34,A40,SCMPDS_2:67;
      end;
      end;
      then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
      hence thesis by A36,RELAT_1:185;

     end;
     suppose InsCode (l) = 5;
         then consider a,k1,k2 such that
     A41: l = (a,k1)<=0_goto k2 by SCMPDS_2:40;
         for x being set st x in SCM-Data-Loc holds
        (Exec (l,s1) | SCM-Data-Loc ).x = (Exec (l,s2) | SCM-Data-Loc ).x
     proof
        let x be set; assume
     A42: x in SCM-Data-Loc;
         then reconsider b = x as Int_position by SCMPDS_2:9;
       thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).b by A42,FUNCT_1:72
          .= s1.b by A41,SCMPDS_2:68
          .= (s1 | SCM-Data-Loc).b by A42,FUNCT_1:72
          .= s2.b by A2,A42,FUNCT_1:72
          .= (Exec (l,s2)).b by A41,SCMPDS_2:68
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A42,FUNCT_1:72;
     end;
    then A43: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
         by A11,A12,FUNCT_1:9;
         now
        per cases;
        suppose A44:s1.DataLoc(s1.a,k1) <= 0;
              then A45:s2.DataLoc(s2.a,k1) <= 0 by A2,Th3;
        thus Exec (l,s1).IC SCMPDS = ICplusConst(s1,k2) by A41,A44,SCMPDS_2:68
         .= ICplusConst(s2,k2) by A7,Th2
         .= Exec (l,s2).IC SCMPDS by A41,A45,SCMPDS_2:68;
        end;
        suppose A46:s1.DataLoc(s1.a,k1) > 0;
              then A47:s2.DataLoc(s2.a,k1) > 0 by A2,Th3;
        thus Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A41,A46,SCMPDS_2:68
         .= Exec (l,s2).IC SCMPDS by A41,A47,SCMPDS_2:68;
      end;
      end;
      then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
      hence thesis by A43,RELAT_1:185;
     end;
     suppose InsCode (l) = 6;
           then consider a,k1,k2 such that
     A48: l = (a,k1)>=0_goto k2 by SCMPDS_2:41;
         for x being set st x in SCM-Data-Loc holds
        (Exec (l,s1) | SCM-Data-Loc ).x = (Exec (l,s2) | SCM-Data-Loc ).x
     proof
        let x be set; assume
     A49: x in SCM-Data-Loc;
         then reconsider b = x as Int_position by SCMPDS_2:9;
       thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).b by A49,FUNCT_1:72
          .= s1.b by A48,SCMPDS_2:69
          .= (s1 | SCM-Data-Loc).b by A49,FUNCT_1:72
          .= s2.b by A2,A49,FUNCT_1:72
          .= (Exec (l,s2)).b by A48,SCMPDS_2:69
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A49,FUNCT_1:72;
     end;
    then A50: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
         by A11,A12,FUNCT_1:9;
         now
        per cases;
        suppose A51:s1.DataLoc(s1.a,k1) >= 0;
              then A52:s2.DataLoc(s2.a,k1) >= 0 by A2,Th3;
        thus Exec (l,s1).IC SCMPDS = ICplusConst(s1,k2) by A48,A51,SCMPDS_2:69
         .= ICplusConst(s2,k2) by A7,Th2
         .= Exec (l,s2).IC SCMPDS by A48,A52,SCMPDS_2:69;
        end;
        suppose A53:s1.DataLoc(s1.a,k1) < 0;
              then A54:s2.DataLoc(s2.a,k1) < 0 by A2,Th3;
        thus Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A48,A53,SCMPDS_2:69
         .= Exec (l,s2).IC SCMPDS by A48,A54,SCMPDS_2:69;
      end;
      end;
      then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
      hence thesis by A50,RELAT_1:185;

     end;
     suppose InsCode (l) = 7;
          then consider a,k1,k2 such that
     A55: l = (a,k1):=k2 by SCMPDS_2:42;
            for x being set st x in SCM-Data-Loc holds
        (Exec (l,s1) | SCM-Data-Loc ).x = (Exec (l,s2) | SCM-Data-Loc ).x
     proof
        let x be set; assume
     A56: x in SCM-Data-Loc;
         then reconsider b = x as Int_position by SCMPDS_2:9;
         per cases;
         suppose A57:b<>DataLoc(s1.a,k1);
           then A58:b<>DataLoc(s2.a,k1) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).b by A56,FUNCT_1:72
          .= s1.b by A55,A57,SCMPDS_2:58
          .= (s1 | SCM-Data-Loc).b by A56,FUNCT_1:72
          .= s2.b by A2,A56,FUNCT_1:72
          .= (Exec (l,s2)).b by A55,A58,SCMPDS_2:58
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A56,FUNCT_1:72;
         end;
         suppose A59:b=DataLoc(s1.a,k1);
             then A60:b=DataLoc(s2.a,k1) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).b by A56,FUNCT_1:72
          .= k2 by A55,A59,SCMPDS_2:58
          .= (Exec (l,s2)).b by A55,A60,SCMPDS_2:58
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A56,FUNCT_1:72;
       end;
       end;
    then A61: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
         by A11,A12,FUNCT_1:9;
             Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A55,SCMPDS_2:58
         .= Exec (l,s2).IC SCMPDS by A55,SCMPDS_2:58;
       then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
       hence thesis by A61,RELAT_1:185;

     end;
     suppose InsCode (l) = 8;
          then consider a,k1,k2 such that
     A62: l = AddTo(a,k1,k2) by SCMPDS_2:43;
            for x being set st x in SCM-Data-Loc holds
        (Exec (l,s1) | SCM-Data-Loc ).x = (Exec (l,s2) | SCM-Data-Loc ).x
     proof
        let x be set; assume
     A63: x in SCM-Data-Loc;
         then reconsider b = x as Int_position by SCMPDS_2:9;
         per cases;
         suppose A64:b<>DataLoc(s1.a,k1);
           then A65:b<>DataLoc(s2.a,k1) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).b by A63,FUNCT_1:72
          .= s1.b by A62,A64,SCMPDS_2:60
          .= (s1 | SCM-Data-Loc).b by A63,FUNCT_1:72
          .= s2.b by A2,A63,FUNCT_1:72
          .= (Exec (l,s2)).b by A62,A65,SCMPDS_2:60
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A63,FUNCT_1:72;
         end;
         suppose A66:b=DataLoc(s1.a,k1);
             then A67:b=DataLoc(s2.a,k1) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).b by A63,FUNCT_1:72
          .= s1.DataLoc(s1.a,k1)+k2 by A62,A66,SCMPDS_2:60
          .= s2.DataLoc(s2.a,k1)+k2 by A2,Th3
          .= (Exec (l,s2)).b by A62,A67,SCMPDS_2:60
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A63,FUNCT_1:72;
       end;
       end;
    then A68: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
         by A11,A12,FUNCT_1:9;
             Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A62,SCMPDS_2:60
         .= Exec (l,s2).IC SCMPDS by A62,SCMPDS_2:60;
       then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
       hence thesis by A68,RELAT_1:185;

     end;
     suppose InsCode (l) = 9;
          then consider a,b,k1,k2 such that
     A69: l = AddTo(a,k1,b,k2) by SCMPDS_2:44;
            for x being set st x in SCM-Data-Loc holds
        (Exec (l,s1) | SCM-Data-Loc ).x = (Exec (l,s2) | SCM-Data-Loc ).x
     proof
        let x be set; assume
     A70: x in SCM-Data-Loc;
         then reconsider c = x as Int_position by SCMPDS_2:9;
         per cases;
         suppose A71:c <>DataLoc(s1.a,k1);
           then A72:c <>DataLoc(s2.a,k1) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).c by A70,FUNCT_1:72
          .= s1.c by A69,A71,SCMPDS_2:61
          .= (s1 | SCM-Data-Loc).c by A70,FUNCT_1:72
          .= s2.c by A2,A70,FUNCT_1:72
          .= (Exec (l,s2)).c by A69,A72,SCMPDS_2:61
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A70,FUNCT_1:72;
         end;
         suppose A73:c = DataLoc(s1.a,k1);
             then A74:c = DataLoc(s2.a,k1) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).c by A70,FUNCT_1:72
          .= s1.DataLoc(s1.a,k1)+s1.DataLoc(s1.b,k2) by A69,A73,SCMPDS_2:61
          .= s2.DataLoc(s2.a,k1)+s1.DataLoc(s1.b,k2) by A2,Th3
          .= s2.DataLoc(s2.a,k1)+s2.DataLoc(s2.b,k2) by A2,Th3
          .= (Exec (l,s2)).c by A69,A74,SCMPDS_2:61
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A70,FUNCT_1:72;
       end;
       end;
    then A75: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
         by A11,A12,FUNCT_1:9;
             Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A69,SCMPDS_2:61
         .= Exec (l,s2).IC SCMPDS by A69,SCMPDS_2:61;
       then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
       hence thesis by A75,RELAT_1:185;

     end;
     suppose InsCode (l) = 10;
          then consider a,b,k1,k2 such that
     A76: l = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
            for x being set st x in SCM-Data-Loc holds
        (Exec (l,s1) | SCM-Data-Loc ).x = (Exec (l,s2) | SCM-Data-Loc ).x
     proof
        let x be set; assume
     A77: x in SCM-Data-Loc;
         then reconsider c = x as Int_position by SCMPDS_2:9;
         per cases;
         suppose A78:c <>DataLoc(s1.a,k1);
           then A79:c <>DataLoc(s2.a,k1) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).c by A77,FUNCT_1:72
          .= s1.c by A76,A78,SCMPDS_2:62
          .= (s1 | SCM-Data-Loc).c by A77,FUNCT_1:72
          .= s2.c by A2,A77,FUNCT_1:72
          .= (Exec (l,s2)).c by A76,A79,SCMPDS_2:62
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A77,FUNCT_1:72;
         end;
         suppose A80:c = DataLoc(s1.a,k1);
             then A81:c = DataLoc(s2.a,k1) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).c by A77,FUNCT_1:72
          .= s1.DataLoc(s1.a,k1)-s1.DataLoc(s1.b,k2) by A76,A80,SCMPDS_2:62
          .= s2.DataLoc(s2.a,k1)-s1.DataLoc(s1.b,k2) by A2,Th3
          .= s2.DataLoc(s2.a,k1)-s2.DataLoc(s2.b,k2) by A2,Th3
          .= (Exec (l,s2)).c by A76,A81,SCMPDS_2:62
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A77,FUNCT_1:72;
       end;
       end;
    then A82: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
         by A11,A12,FUNCT_1:9;
             Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A76,SCMPDS_2:62
         .= Exec (l,s2).IC SCMPDS by A76,SCMPDS_2:62;
       then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
       hence thesis by A82,RELAT_1:185;

     end;
     suppose InsCode (l) = 11;
           then consider a,b,k1,k2 such that
     A83: l = MultBy(a,k1,b,k2) by SCMPDS_2:46;
            for x being set st x in SCM-Data-Loc holds
        (Exec (l,s1) | SCM-Data-Loc ).x = (Exec (l,s2) | SCM-Data-Loc ).x
     proof
        let x be set; assume
     A84: x in SCM-Data-Loc;
         then reconsider c = x as Int_position by SCMPDS_2:9;
         per cases;
         suppose A85:c <>DataLoc(s1.a,k1);
           then A86:c <>DataLoc(s2.a,k1) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).c by A84,FUNCT_1:72
          .= s1.c by A83,A85,SCMPDS_2:63
          .= (s1 | SCM-Data-Loc).c by A84,FUNCT_1:72
          .= s2.c by A2,A84,FUNCT_1:72
          .= (Exec (l,s2)).c by A83,A86,SCMPDS_2:63
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A84,FUNCT_1:72;
         end;
         suppose A87:c = DataLoc(s1.a,k1);
             then A88:c = DataLoc(s2.a,k1) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).c by A84,FUNCT_1:72
          .= s1.DataLoc(s1.a,k1) * s1.DataLoc(s1.b,k2) by A83,A87,SCMPDS_2:63
          .= s2.DataLoc(s2.a,k1) * s1.DataLoc(s1.b,k2) by A2,Th3
          .= s2.DataLoc(s2.a,k1) * s2.DataLoc(s2.b,k2) by A2,Th3
          .= (Exec (l,s2)).c by A83,A88,SCMPDS_2:63
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A84,FUNCT_1:72;
       end;
       end;
    then A89: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
         by A11,A12,FUNCT_1:9;
             Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A83,SCMPDS_2:63
         .= Exec (l,s2).IC SCMPDS by A83,SCMPDS_2:63;
       then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
       hence thesis by A89,RELAT_1:185;

     end;
     suppose InsCode (l) = 12;
         then consider a,b,k1,k2 such that
     A90: l = Divide(a,k1,b,k2) by SCMPDS_2:47;
            for x being set st x in SCM-Data-Loc holds
        (Exec (l,s1) | SCM-Data-Loc ).x = (Exec (l,s2) | SCM-Data-Loc ).x
     proof
        let x be set; assume
     A91: x in SCM-Data-Loc;
         then reconsider c = x as Int_position by SCMPDS_2:9;
         per cases;
         suppose A92:c = DataLoc(s1.b,k2);
             then A93:c = DataLoc(s2.b,k2) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).c by A91,FUNCT_1:72
          .= s1.DataLoc(s1.a,k1) mod s1.DataLoc(s1.b,k2) by A90,A92,SCMPDS_2:64
          .= s2.DataLoc(s2.a,k1) mod s1.DataLoc(s1.b,k2) by A2,Th3
          .= s2.DataLoc(s2.a,k1) mod s2.DataLoc(s2.b,k2) by A2,Th3
          .= (Exec (l,s2)).c by A90,A93,SCMPDS_2:64
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A91,FUNCT_1:72;
         end;
         suppose A94:c <>DataLoc(s1.b,k2);
           then A95:c <>DataLoc(s2.b,k2) by A2,Th4;
           hereby
             per cases;
             suppose A96: c <> DataLoc(s1.a,k1);
                then A97: c <> DataLoc(s2.a,k1) by A2,Th4;
              thus (Exec (l,s1) | SCM-Data-Loc ).x
               = (Exec (l,s1)).c by A91,FUNCT_1:72
               .= s1.c by A90,A94,A96,SCMPDS_2:64
               .= s2.c by A2,Th4
               .= (Exec (l,s2)).c by A90,A95,A97,SCMPDS_2:64
               .= (Exec (l,s2) | SCM-Data-Loc ).x by A91,FUNCT_1:72;
             end;
             suppose A98: c = DataLoc(s1.a,k1);
               then A99: c = DataLoc(s2.a,k1) by A2,Th4;
               thus (Exec (l,s1) | SCM-Data-Loc ).x
               = (Exec (l,s1)).c by A91,FUNCT_1:72
              .= s1.DataLoc(s1.a,k1) div s1.DataLoc(s1.b,k2)
                by A90,A94,A98,SCMPDS_2:64
              .= s2.DataLoc(s2.a,k1) div s1.DataLoc(s1.b,k2) by A2,Th3
              .= s2.DataLoc(s2.a,k1) div s2.DataLoc(s2.b,k2) by A2,Th3
              .= (Exec (l,s2)).c by A90,A95,A99,SCMPDS_2:64
              .= (Exec (l,s2) | SCM-Data-Loc ).x by A91,FUNCT_1:72;
           end;
           end;
       end;
       end;
    then A100: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
         by A11,A12,FUNCT_1:9;
             Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A90,SCMPDS_2:64
         .= Exec (l,s2).IC SCMPDS by A90,SCMPDS_2:64;
       then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
       hence thesis by A100,RELAT_1:185;

     end;
     suppose InsCode (l) = 13;
        then consider a,b,k1,k2 such that
     A101: l = (a,k1):=(b,k2) by SCMPDS_2:48;
            for x being set st x in SCM-Data-Loc holds
        (Exec (l,s1) | SCM-Data-Loc ).x = (Exec (l,s2) | SCM-Data-Loc ).x
     proof
        let x be set; assume
     A102: x in SCM-Data-Loc;
         then reconsider c = x as Int_position by SCMPDS_2:9;
         per cases;
         suppose A103:c <>DataLoc(s1.a,k1);
           then A104:c <>DataLoc(s2.a,k1) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).c by A102,FUNCT_1:72
          .= s1.c by A101,A103,SCMPDS_2:59
          .= (s1 | SCM-Data-Loc).c by A102,FUNCT_1:72
          .= s2.c by A2,A102,FUNCT_1:72
          .= (Exec (l,s2)).c by A101,A104,SCMPDS_2:59
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A102,FUNCT_1:72;
         end;
         suppose A105:c = DataLoc(s1.a,k1);
             then A106:c = DataLoc(s2.a,k1) by A2,Th4;
           thus (Exec (l,s1) | SCM-Data-Loc ).x
           = (Exec (l,s1)).c by A102,FUNCT_1:72
          .= s1.DataLoc(s1.b,k2) by A101,A105,SCMPDS_2:59
          .= s2.DataLoc(s2.b,k2) by A2,Th3
          .= (Exec (l,s2)).c by A101,A106,SCMPDS_2:59
          .= (Exec (l,s2) | SCM-Data-Loc ).x by A102,FUNCT_1:72;
       end;
       end;
    then A107: Exec (l,s1) | (SCM-Data-Loc ) = Exec (l,s2) | (SCM-Data-Loc )
         by A11,A12,FUNCT_1:9;
             Exec (l,s1).IC SCMPDS = Next IC s2 by A7,A101,SCMPDS_2:59
         .= Exec (l,s2).IC SCMPDS by A101,SCMPDS_2:59;
       then Exec (l,s1) | {IC SCMPDS} = Exec (l,s2) | {IC SCMPDS} by A10,
GRFUNC_1:90;
       hence thesis by A107,RELAT_1:185;
end;
end;

theorem
      for i being Instruction of SCMPDS,s being State of SCMPDS
   holds Exec (i, s) | SCM-Instr-Loc = s | SCM-Instr-Loc
proof
    let i be Instruction of SCMPDS,
        s be State of SCMPDS;
        dom Exec (i,s) = the carrier of SCMPDS by AMI_1:79;
then A1: dom (Exec (i, s) | SCM-Instr-Loc) = SCM-Instr-Loc by RELAT_1:91
;
        dom s = the carrier of SCMPDS by AMI_1:79;
then A2: dom (s | SCM-Instr-Loc) = SCM-Instr-Loc by RELAT_1:91;
        for x being set st x in SCM-Instr-Loc
      holds (Exec (i, s) | SCM-Instr-Loc).x = (s | SCM-Instr-Loc).x
    proof
       let x be set;
       assume
A3:      x in SCM-Instr-Loc;
       then reconsider l = x as Instruction-Location of SCMPDS by AMI_1:def 4;
       thus (Exec (i, s) | SCM-Instr-Loc).x
              = (Exec (i, s)).l by A3,FUNCT_1:72
             .= s.l by AMI_1:def 13
             .= (s | SCM-Instr-Loc).x by A3,FUNCT_1:72;
    end;
    hence Exec (i, s) | SCM-Instr-Loc = s | SCM-Instr-Loc by A1,A2,FUNCT_1:9;
end;

begin :: Finite partial states of SCMPDS

theorem Th9:
 for p being FinPartState of SCMPDS
  holds DataPart p = p | SCM-Data-Loc
proof let p be FinPartState of SCMPDS;
    SCM-Data-Loc misses {IC SCMPDS } by Th6,ZFMISC_1:56;
   then A1:SCM-Data-Loc
      misses ({IC SCMPDS } \/ NAT )
        by AMI_2:29,XBOOLE_1:70;
       the carrier of SCMPDS = SCM-Data-Loc \/ ({IC SCMPDS } \/
        NAT ) by AMI_3:4,XBOOLE_1:4;
  then (the carrier of SCMPDS )
      \ ({IC SCMPDS } \/ NAT )
    = (SCM-Data-Loc )
      \ ({IC SCMPDS } \/ NAT ) by XBOOLE_1:40
   .= SCM-Data-Loc by A1,XBOOLE_1:83;
  hence thesis;
end;

theorem
   for p being FinPartState of SCMPDS holds
  p is data-only iff dom p c= SCM-Data-Loc
proof let p be FinPartState of SCMPDS;
A1: the carrier of SCMPDS = SCM-Data-Loc \/ ({IC SCMPDS } \/
        NAT ) by AMI_3:4,XBOOLE_1:4;
 hereby assume p is data-only;
   then A2:dom p misses {IC SCMPDS } \/ NAT
       by AMI_1:def 50;
       dom p c= the carrier of SCMPDS by AMI_1:80;
  hence dom p c= SCM-Data-Loc by A1,A2,XBOOLE_1:73;
 end;
 assume
A3: dom p c= SCM-Data-Loc;
    SCM-Data-Loc misses {IC SCMPDS } by Th6,ZFMISC_1:56;
   then SCM-Data-Loc misses {IC SCMPDS }
     \/ NAT by AMI_2:29,XBOOLE_1:70;
 hence dom p misses {IC SCMPDS } \/ NAT
         by A3,XBOOLE_1:63;
end;

theorem
     for p being FinPartState of SCMPDS
  holds dom DataPart p c= SCM-Data-Loc
proof
   let p be FinPartState of SCMPDS;
       DataPart p = p| SCM-Data-Loc by Th9;
   hence dom DataPart p c= SCM-Data-Loc by RELAT_1:87;
end;

canceled;

theorem
      for i being Instruction of SCMPDS, s being State of SCMPDS ,
      p being programmed FinPartState of SCMPDS
   holds
      Exec (i, s +* p) = Exec (i,s) +* p
proof
     let i be Instruction of SCMPDS,
         s be State of SCMPDS,
         p be programmed FinPartState of SCMPDS;
      A1: dom p c= NAT by AMI_1:def 40;
          now assume {IC SCMPDS } meets NAT;
      then consider x being set such that
A2:    x in {IC SCMPDS } and
A3:    x in NAT by XBOOLE_0:3;
      reconsider x as Instruction-Location of SCMPDS by A3,AMI_1:def 4;
           x = IC SCMPDS by A2,TARSKI:def 1;
       hence contradiction by AMI_1:48;
      end;
      then SCM-Data-Loc \/ {IC SCMPDS } misses
           NAT
                by AMI_2:29,XBOOLE_1:70;
then A4:        SCM-Data-Loc \/ {IC SCMPDS } misses dom p
          by A1,XBOOLE_1:63;
then A5:   s|(SCM-Data-Loc \/ {IC SCMPDS })
                = (s +* p) | (SCM-Data-Loc \/ {IC SCMPDS }) by FUNCT_4:76;
A6:    (Exec(i,s) +* p)|(SCM-Data-Loc \/ {IC SCMPDS })
           = Exec(i,s)|(SCM-Data-Loc \/ {IC SCMPDS }) by A4,FUNCT_4:76
          .= Exec(i,s +* p) |
               (SCM-Data-Loc \/ {IC SCMPDS }) by A5,Th7;
A7:     Exec (i, s +* p)|NAT
            = (s +* p)|NAT by AMI_1:117
           .= s |(NAT ) +*
                  p|NAT by FUNCT_4:75
           .= Exec (i,s) |(NAT ) +*
                  p|NAT by AMI_1:117
           .= (Exec (i, s) +* p)|NAT
                    by FUNCT_4:75;
     thus Exec (i, s +* p)
             = Exec (i, s +* p)| dom(Exec (i, s +* p)) by RELAT_1:97
            .= Exec (i, s +* p)| (SCM-Data-Loc \/ {IC SCMPDS } \/
                  NAT )
                           by AMI_1:79,AMI_3:4
            .= (Exec (i, s) +* p)|
                 (SCM-Data-Loc \/ {IC SCMPDS })
                 +* (Exec (i, s) +* p)|NAT
                        by A6,A7,FUNCT_4:83
            .= (Exec (i,s) +* p)| the carrier of SCMPDS
                     by AMI_3:4,FUNCT_4:83
            .= (Exec (i,s) +* p)| dom(Exec (i, s) +* p) by AMI_1:79
            .= Exec (i,s) +* p by RELAT_1:97;
end;

theorem
     for s being State of SCMPDS ,iloc being Instruction-Location of SCMPDS ,
     a being Int_position
  holds s.a = (s +* Start-At iloc).a
proof
   let s be State of SCMPDS,
       iloc be Instruction-Location of SCMPDS,
       a be Int_position;
A1: dom (Start-At iloc) = {IC SCMPDS } by FUNCOP_1:19;
        a in the carrier of SCMPDS;
    then a in dom s by AMI_1:79;
then A2: a in dom s \/ dom (Start-At iloc) by XBOOLE_0:def 2;
        a <> IC SCMPDS by SCMPDS_2:52;
    then not a in {IC SCMPDS } by TARSKI:def 1;
    hence s.a = (s +* Start-At iloc).a by A1,A2,FUNCT_4:def 1;
end;

theorem
     for s, t being State of SCMPDS
  holds s +* t|(SCM-Data-Loc ) is State of SCMPDS
proof
 let s, t be State of SCMPDS;
A1: product the Object-Kind of SCMPDS c= sproduct the Object-Kind of SCMPDS
      by CARD_3:67;
       t in product the Object-Kind of SCMPDS;
   then t|(SCM-Data-Loc ) in
      sproduct the Object-Kind of SCMPDS by A1,CARD_3:81;
  hence s +* t|(SCM-Data-Loc ) is State of SCMPDS
       by CARD_3:69;
end;

begin :: Autonomic finite partial states of SCMPDS and its computation

definition
 let la be Int_position;
 let a be Integer;
 redefine func la .--> a -> FinPartState of SCMPDS;
 coherence
  proof
        a is Element of INT & ObjectKind la = INT by INT_1:def 2,SCMPDS_2:13;
    hence thesis by AMI_1:59;
  end;
end;

theorem Th16:
 for p being autonomic FinPartState of SCMPDS st DataPart p <> {}
 holds IC SCMPDS in dom p
proof
  let p be autonomic FinPartState of SCMPDS;
  assume DataPart p <> {};
 then A1: dom DataPart p <> {} by RELAT_1:64;
   assume A2: not IC SCMPDS in dom p;
       p is not autonomic
   proof
     consider d1 being Element of dom DataPart p;
A3:  d1 in dom DataPart p by A1;
         dom DataPart p c= the carrier of SCMPDS by AMI_1:80;
     then reconsider d1 as Element of SCMPDS by A3;
         DataPart p = p | SCM-Data-Loc by Th9;
     then dom DataPart p c= SCM-Data-Loc by RELAT_1:87;
     then reconsider d1 as Int_position by A3,SCMPDS_2:9;
     consider il being Element of
       (NAT) \ dom p;
         not NAT c= dom p
     by FINSET_1:13,SCMPDS_2:11;
     then A4: (NAT) \ dom p <> {} by XBOOLE_1:37;
     then il is Element of NAT
               by XBOOLE_0:def 4;
     then reconsider il as Instruction-Location of SCMPDS by AMI_1:def 4;
     set p1 = p +* ((il .--> (d1:=0)) +* Start-At il);
     set p2 = p +* ((il .--> (d1:=1)) +* Start-At il);
     consider s1 being State of SCMPDS such that
A5:  p1 c= s1 by AMI_1:82;
     consider s2 being State of SCMPDS such that
A6: p2 c= s2 by AMI_1:82;
     take s1,s2;
A7: dom p misses {IC SCMPDS} by A2,ZFMISC_1:56;
     not il in dom p by A4,XBOOLE_0:def 4;
then A8: dom p misses {il} by ZFMISC_1:56;
         dom ((il .--> (d1:=0)) +* Start-At il)
     = dom (il .--> (d1:=0)) \/ dom (Start-At il) by FUNCT_4:def 1
    .= dom (il .--> (d1:=0)) \/ { IC SCMPDS } by FUNCOP_1:19
    .= {il} \/ { IC SCMPDS } by FUNCOP_1:19;
   then dom p /\ dom ((il .--> (d1:=0)) +* Start-At il)
       = dom p /\ {il} \/ dom p /\ {IC SCMPDS} by XBOOLE_1:23
      .= dom p /\ {il} \/ {} by A7,XBOOLE_0:def 7
      .= {} by A8,XBOOLE_0:def 7;
   then dom p misses dom ((il .--> (d1:=0)) +* Start-At il) by XBOOLE_0:def 7;
   then p c= p1 by FUNCT_4:33;
   hence p c= s1 by A5,XBOOLE_1:1;
         dom ((il .--> (d1:=1)) +* Start-At il)
     = dom (il .--> (d1:=1)) \/ dom (Start-At il) by FUNCT_4:def 1
    .= dom (il .--> (d1:=1)) \/ { IC SCMPDS } by FUNCOP_1:19
    .= {il} \/ { IC SCMPDS } by FUNCOP_1:19;
   then dom p /\ dom ((il .--> (d1:=1)) +* Start-At il)
       = dom p /\ {il} \/ dom p /\ {IC SCMPDS} by XBOOLE_1:23
      .= dom p /\ {il} \/ {} by A7,XBOOLE_0:def 7
      .= {} by A8,XBOOLE_0:def 7;
   then dom p misses dom ((il .--> (d1:=1)) +* Start-At il) by XBOOLE_0:def 7;
   then p c= p2 by FUNCT_4:33;
   hence p c= s2 by A6,XBOOLE_1:1;
    take 1;
         DataPart p c= p by RELAT_1:88;
     then A9: dom DataPart p c= dom p by RELAT_1:25;
         dom ((Computation s1).1) = the carrier of SCMPDS by AMI_1:79;
     then dom p c= dom ((Computation s1).1) by AMI_1:80;
then A10: dom ((Computation s1).1|dom p) = dom p by RELAT_1:91;
A11: dom (Start-At il) = {IC SCMPDS} by FUNCOP_1:19;
then A12: IC SCMPDS in dom (Start-At il) by TARSKI:def 1;
A13:  dom ((il .--> (d1:=0)) +* Start-At il)
        = dom ((il .--> (d1:=0))) \/ dom (Start-At il) by FUNCT_4:def 1;
then A14: IC SCMPDS in dom ((il .--> (d1:=0)) +* Start-At il) by A12,
XBOOLE_0:def 2;
A15: dom p1 = dom p \/ dom ((il .--> (d1:=0)) +* Start-At il)
      by FUNCT_4:def 1;
then IC SCMPDS in dom p1 by A14,XBOOLE_0:def 2;
then A16: IC s1 = p1.IC SCMPDS by A5,GRFUNC_1:8
      .= ((il .--> (d1:=0)) +* Start-At il).IC SCMPDS by A14,FUNCT_4:14
      .= (Start-At il).IC SCMPDS by A12,FUNCT_4:14
      .= il by FUNCOP_1:87;
         dom (il .--> (d1:=0)) = {il} by FUNCOP_1:19;
then A17: il in dom (il .--> (d1:=0)) by TARSKI:def 1;
         il <> IC SCMPDS by AMI_1:48;
then A18: not il in dom (Start-At il) by A11,TARSKI:def 1;
A19: il in dom ((il .--> (d1:=0)) +* Start-At il) by A13,A17,XBOOLE_0:def 2
;
     then il in dom p1 by A15,XBOOLE_0:def 2;
then A20: s1.il = p1.il by A5,GRFUNC_1:8
     .= ((il .--> (d1:=0)) +* Start-At il).il by A19,FUNCT_4:14
     .= (il .--> (d1:=0)).il by A18,FUNCT_4:12
     .=(d1:=0) by FUNCOP_1:87;
        (Computation s1).(0+1).d1
     = (Following (Computation s1).0).d1 by AMI_1:def 19
    .= (Following s1).d1 by AMI_1:def 19
    .= 0 by A16,A20,SCMPDS_2:57;
then A21:  ((Computation s1).1|dom p).d1 = 0 by A3,A9,A10,FUNCT_1:70;
         dom ((Computation s2).1) = the carrier of SCMPDS by AMI_1:79;
     then dom p c= dom ((Computation s2).1) by AMI_1:80;
then A22:  dom ((Computation s2).1|dom p) = dom p by RELAT_1:91;

A23:  dom ((il .--> (d1:=1)) +* Start-At il)
     = dom ((il .--> (d1:=1))) \/ dom (Start-At il) by FUNCT_4:def 1;
then A24: IC SCMPDS in dom ((il .--> (d1:=1)) +* Start-At il) by A12,
XBOOLE_0:def 2;
A25: dom p2 = dom p \/ dom ((il .--> (d1:=1)) +* Start-At il)
      by FUNCT_4:def 1;
then IC SCMPDS in dom p2 by A24,XBOOLE_0:def 2;
then A26: IC s2
       = p2.IC SCMPDS by A6,GRFUNC_1:8
      .= ((il .--> (d1:=1)) +* Start-At il).IC SCMPDS by A24,FUNCT_4:14
      .= (Start-At il).IC SCMPDS by A12,FUNCT_4:14
      .= il by FUNCOP_1:87;
         dom (il .--> (d1:=1)) = {il} by FUNCOP_1:19;
then A27: il in dom (il .--> (d1:=1)) by TARSKI:def 1;
         il <> IC SCMPDS by AMI_1:48;
then A28: not il in dom (Start-At il) by A11,TARSKI:def 1;
A29: il in dom ((il .--> (d1:=1)) +* Start-At il) by A23,A27,XBOOLE_0:def 2
;
     then il in dom p2 by A25,XBOOLE_0:def 2;
then A30: s2.il = p2.il by A6,GRFUNC_1:8
     .= ((il .--> (d1:=1)) +* Start-At il).il by A29,FUNCT_4:14
     .= (il .--> (d1:=1)).il by A28,FUNCT_4:12
     .=(d1:=1) by FUNCOP_1:87;
       (Computation s2).(0+1).d1
    = (Following (Computation s2).0).d1 by AMI_1:def 19
    .= (Following s2).d1 by AMI_1:def 19
    .= 1 by A26,A30,SCMPDS_2:57;
    hence (Computation s1).1|dom p <> (Computation s2).1|dom p by A3,A9,A21,A22
,FUNCT_1:70;
   end;
   hence contradiction;
end;

registration
 cluster autonomic non programmed FinPartState of SCMPDS;
 existence
 proof
   reconsider il=2 as Instruction-Location of SCMPDS by AMI_1:def 4;
   set P = (IC SCMPDS, il)-->(il, halt SCMPDS);
       P = Start-At il +* (il .--> halt SCMPDS) by FUNCT_4:def 4;
   then reconsider P as FinPartState of SCMPDS;
   take P;
   A1: ObjectKind il = the Instructions of SCMPDS by AMI_1:def 14;
        ObjectKind IC SCMPDS = NAT
              by AMI_1:def 11;
   hence P is autonomic by A1,AMI_1:67;
        now
         dom P = { IC SCMPDS, il } by FUNCT_4:65;
then A2:  IC SCMPDS in dom P by TARSKI:def 2;
     assume dom P c= NAT;
      then reconsider l=IC SCMPDS as Instruction-Location of SCMPDS
                 by A2,AMI_1:def 4;
       l=IC SCMPDS;
     hence contradiction by AMI_1:48;
    end;
   hence P is non programmed by AMI_1:def 40;
  end;
end;

theorem Th17:
 for p being autonomic non programmed FinPartState of SCMPDS
 holds IC SCMPDS in dom p
proof
   let p be autonomic non programmed FinPartState of SCMPDS;
   A1: not dom p c= NAT by AMI_1:def 40;
       dom p c= the carrier of SCMPDS by AMI_1:80;
   then dom p = dom p /\ the carrier of SCMPDS by XBOOLE_1:28
        .= dom p /\
             (SCM-Data-Loc \/ {IC SCMPDS }) \/
              dom p /\ NAT
                                      by AMI_3:4,XBOOLE_1:23;
    then dom p /\ (SCM-Data-Loc \/ {IC SCMPDS }) <> {} by A1,XBOOLE_1:17;
    then A2: dom p /\ {IC SCMPDS } \/
       dom p /\ (SCM-Data-Loc ) <> {} by XBOOLE_1:23;
    per cases by A2;
    suppose dom p /\ {IC SCMPDS } <> {};
    then dom p meets {IC SCMPDS } by XBOOLE_0:def 7;
    hence IC SCMPDS in dom p by ZFMISC_1:56;
    end;
    suppose A3: dom p /\ (SCM-Data-Loc ) <> {};
        DataPart p = p |(SCM-Data-Loc ) by Th9;
    then DataPart p <> {} by A3,RELAT_1:60,90;
   hence IC SCMPDS in dom p by Th16;
end;
end;

theorem Th18:
  for s1,s2 being State of SCMPDS,k1,k2,m be Integer st
  IC s1= IC s2 & k1 <> k2 & m=IC s1 & m+k1 >= 0 & m+k2 >= 0
  holds
     ICplusConst(s1,k1) <> ICplusConst(s2,k2)
proof
   let s1,s2 be State of SCMPDS,k1,k2,m be Integer;
   assume A1:IC s1 = IC s2 & k1<>k2 & m=IC s1
     & m+k1 >= 0 & m+k2 >= 0;
   assume A2:ICplusConst(s1,k1) = ICplusConst(s2,k2);
   consider i being Element of NAT such that
A3: i = IC s1 & ICplusConst(s1,k1)=abs(i+k1) by SCMPDS_2:def 20;
A4: ICplusConst(s1,k1)=m+k1 by A1,A3,ABSVALUE:def 1
   .=m+k1;
   consider j being Element of NAT such that
A5: j = IC s2 & ICplusConst(s2,k2)=abs(j+k2) by SCMPDS_2:def 20;
     ICplusConst(s2,k2)=m+k2 by A1,A5,ABSVALUE:def 1
   .=m+k2;
    hence contradiction by A1,A2,A4;
end;

theorem Th19:
  for s1,s2 being State of SCMPDS,k1,k2 be Element of NAT st
  IC s1= IC s2 & k1 <> k2 holds
      ICplusConst(s1,k1) <> ICplusConst(s2,k2)
proof
    let s1,s2 be State of SCMPDS,k1,k2 be Element of NAT;
    assume A1:IC s1 = IC s2 & k1<>k2;
    reconsider m=IC s1 as Element of NAT by AMI_1:def 4;
    set mm=m+2;
        mm-2+k1=m+k1;
then A2: mm-2+k1>=0 by NAT_1:2;
        mm-2+k2=m+k2;
 then mm-2+k2>=0 by NAT_1:2;
    hence thesis by A1,A2,Th18;
end;

theorem Th20:
  for s being State of SCMPDS holds Next IC s= ICplusConst(s,1)
proof
    let s be State of SCMPDS;
    consider j such that
A1: j = IC s & ICplusConst(s,1)=abs(j+1) by SCMPDS_2:def 20;
 A2: j >= 0 by NAT_1:2;
A3: j*1 >= 0 by NAT_1:2;
     consider mj be Element of SCM-Instr-Loc such that
A4:  mj = IC s & Next mj = Next IC s by SCMPDS_2:def 19;
      reconsider mj as Element of NAT;
  Next IC s = mj+1 by A4
         .= abs(mj)+1 by A1,A2,A4,ABSVALUE:def 1
         .= abs(mj)+abs(1) by ABSVALUE:def 1
         .= abs(mj+1) by A1,A3,A4,ABSVALUE:24;
 hence thesis by A4,SCMPDS_2:def 20;
end;

theorem
  for p being autonomic FinPartState of SCMPDS st IC SCMPDS in dom p
   holds IC p in dom p
proof
     let p be autonomic FinPartState of SCMPDS;
     assume
A1:        IC SCMPDS in dom p;
     assume
A2:        not IC p in dom p;
     set il = IC p;
     set p1 = p +* ((il .--> goto 0));
     set p2 = p +* ((il .--> goto 1));
     consider s1 being State of SCMPDS such that A3: p1 c= s1 by AMI_1:82;
     consider s2 being State of SCMPDS such that A4: p2 c= s2 by AMI_1:82;
         p is not autonomic
      proof
A5:    dom (il .--> (goto 1)) = {il} by FUNCOP_1:19;
A6:    dom (il .--> (goto 0)) = {il} by FUNCOP_1:19;
       take s1,s2;
        dom p misses {il} by A2,ZFMISC_1:56;
       then p c= p1 & p c= p2 by A5,A6,FUNCT_4:33;
       hence A7: p c= s1 & p c= s2 by A3,A4,XBOOLE_1:1;
       take 1;
A8:     il in dom (il .--> (goto 1)) by A5,TARSKI:def 1;
A9:     il in dom (il .--> (goto 0)) by A6,TARSKI:def 1;
            dom p1 = dom p \/ dom ((il .--> goto 0)) by FUNCT_4:def 1;
        then il in dom p1 by A9,XBOOLE_0:def 2;
then A10:     s1.il = p1.il by A3,GRFUNC_1:8
             .= ((il .--> goto 0)).il by A9,FUNCT_4:14
             .= goto 0 by FUNCOP_1:87;
            dom p2 = dom p \/ dom ((il .--> goto 1)) by FUNCT_4:def 1;
        then il in dom p2 by A8,XBOOLE_0:def 2;
then A11:     s2.il = p2.il by A4,GRFUNC_1:8
             .= ((il .--> goto 1)).il by A8,FUNCT_4:14
             .= goto 1 by FUNCOP_1:87;
A12:    (Following s1).IC SCMPDS
        = Exec (goto 0,s1).IC SCMPDS by A1,A7,A10,AMI_1:97
       .= ICplusConst(s1,0) by SCMPDS_2:66;
A13:    (Following s2).IC SCMPDS
        = Exec (goto 1,s2).IC SCMPDS by A1,A7,A11,AMI_1:97
       .= ICplusConst(s2,1) by SCMPDS_2:66;

       assume A14: (Computation s1).1|dom p = (Computation s2).1|dom p;
     A15: (Following(s1))|dom p
                      = (Following ((Computation s1).0))|dom p by AMI_1:def 19
                     .= (Computation s1).(0+1)|dom p by AMI_1:def 19
                     .= (Following ((Computation s2).0))|dom p by A14,
AMI_1:def 19
                     .= (Following(s2))|dom p by AMI_1:def 19;
    A16: ICplusConst(s1,0) = ((Following(s1))|dom p).IC SCMPDS by A1,A12,
FUNCT_1:72
                .= ICplusConst(s2,1) by A1,A13,A15,FUNCT_1:72;
           IC s2 = il by A1,A7,AMI_1:97
        .= IC s1 by A1,A7,AMI_1:97;
       hence contradiction by A16,Th19;
    end;
     hence contradiction;
end;

theorem Th22:
 for p being autonomic non programmed FinPartState of SCMPDS ,
     s being State of SCMPDS st p c= s
 for i being Element of NAT
 holds IC (Computation s).i in dom ProgramPart(p)
proof
   let p be autonomic non programmed FinPartState of SCMPDS,
       s be State of SCMPDS such that
A1:  p c= s;
   let i be Element of NAT;
   set Csi = (Computation s).i;
   set loc = IC Csi;
  assume
A2: not IC (Computation s).i in dom ProgramPart(p);
A3:  loc in NAT by AMI_1:def 4;
     loc in dom ProgramPart p iff
         loc in dom p /\ NAT by FUNCT_1:68;
 then A4:not loc in dom p by A2,A3,XBOOLE_0:def 3;
    set p1 = p +* (loc .--> goto 0 );
    set p2 = p +* (loc .--> goto 1 );

A5:  dom p1 = dom p \/ dom (loc .--> goto 0 ) &
         dom p2 = dom p \/ dom (loc .--> goto 1 ) by FUNCT_4:def 1;
A6:  dom (loc .--> goto 0 ) = {loc} &
         dom (loc .--> goto 1 ) = {loc} by FUNCOP_1:19;
then A7:  loc in dom (loc .--> goto 0 ) &
         loc in dom (loc .--> goto 1) by TARSKI:def 1;
then A8:   loc in dom p1 & loc in dom p2 by A5,XBOOLE_0:def 2;

    consider s1 being State of SCMPDS such that
A9: p1 c= s1 by AMI_1:82;
    consider s2 being State of SCMPDS such that
A10: p2 c= s2 by AMI_1:82;

 set Cs1i = (Computation s1).i;
 set Cs2i = (Computation s2).i;

A11:  IC SCMPDS in dom p by Th17;
      p is not autonomic
   proof
     take s1, s2;
         dom s1 = the carrier of SCMPDS & dom s2 = the carrier of SCMPDS
                                                    by AMI_1:79;
then A12: dom p c= dom s1 & dom p c= dom s2 by AMI_1:80;
         now let x be set; assume
A13:    x in dom p;
       then dom p misses dom (loc .--> goto 0 ) &
       x in dom p1 by A4,A5,A6,XBOOLE_0:def 2,ZFMISC_1:56;
       then p.x = p1.x & p1.x = s1.x by A9,A13,FUNCT_4:17,GRFUNC_1:8;
      hence p.x = s1.x;
     end;
    hence A14: p c= s1 by A12,GRFUNC_1:8;
        now let x be set; assume
A15:   x in dom p;
      then dom p misses dom (loc .--> goto 1 ) &
      x in dom p2 by A4,A5,A6,XBOOLE_0:def 2,ZFMISC_1:56;
      then p.x = p2.x & p2.x = s2.x by A10,A15,FUNCT_4:17,GRFUNC_1:8;
     hence p.x = s2.x;
    end;
   hence A16: p c= s2 by A12,GRFUNC_1:8;
           (loc .--> goto 0 ).loc = goto 0 &
       (loc .--> goto 1 ).loc = goto 1 by FUNCOP_1:87;
       then p1.loc = goto 0 & p2.loc = goto 1 by A7,FUNCT_4:14;
then A17:  s1.loc = goto 0 & s2.loc = goto 1 by A8,A9,A10,GRFUNC_1:8;

  take k = i+1;

  set Cs1k = (Computation s1).k;
  set Cs2k = (Computation s2).k;
A18: Cs1k = Following Cs1i by AMI_1:def 19
          .= Exec (CurInstr Cs1i, Cs1i);
A19: Cs2k = Following Cs2i by AMI_1:def 19
          .= Exec (CurInstr Cs2i, Cs2i);
      A20:   Cs1i.loc = goto 0 & Cs2i.loc = goto 1 by A17,AMI_1:54;
A21:  (Cs1i|dom p) = (Csi|dom p) by A1,A14,AMI_1:def 25;
A22: Cs1i.IC SCMPDS = (Cs1i|dom p).IC SCMPDS &
     Csi.IC SCMPDS = (Csi|dom p).IC SCMPDS by A11,FUNCT_1:72;
     A23: (Cs1i|dom p) = (Cs2i|dom p) by A14,A16,AMI_1:def 25;
then Cs1i.IC SCMPDS = loc & Cs2i.IC SCMPDS = loc
           by A11,A21,A22,FUNCT_1:72;
then A24: Cs1k.IC SCMPDS = ICplusConst(Cs1i,0) &
     Cs2k.IC SCMPDS = ICplusConst(Cs2i,1) by A18,A19,A20,SCMPDS_2:66;
     A25: IC Cs1i = IC Cs2i by A11,A22,A23,FUNCT_1:72;
         (Cs1k|dom p).IC SCMPDS = Cs1k.IC SCMPDS &
     (Cs2k|dom p).IC SCMPDS = Cs2k.IC SCMPDS by A11,FUNCT_1:72;
   hence Cs1k|dom p <> Cs2k|dom p by A24,A25,Th19;
  end;
 hence contradiction;
end;

theorem Th23:
 for p being autonomic non programmed FinPartState of SCMPDS ,
     s1, s2 being State of SCMPDS
  st p c= s1 & p c= s2
   for i being Element of NAT
    holds IC (Computation s1).i = IC (Computation s2).i &
          CurInstr ((Computation s1).i) = CurInstr ((Computation s2).i)
proof
   let p be autonomic non programmed FinPartState of SCMPDS ,
       s1, s2 be State of SCMPDS such that
A1:  p c= s1 & p c= s2;
    let i be Element of NAT;
 set I = CurInstr ((Computation s1).i);
    set Cs1i = (Computation s1).i;
    set Cs2i = (Computation s2).i;
A2: IC SCMPDS in dom p by Th17;
   thus
A3: IC Cs1i = IC Cs2i
   proof assume
A4:  IC (Computation s1).i <> IC (Computation s2).i;
        (Cs1i|dom p).IC SCMPDS = Cs1i.IC SCMPDS &
    (Cs2i|dom p).IC SCMPDS = Cs2i.IC SCMPDS by A2,FUNCT_1:72;
   hence contradiction by A1,A4,AMI_1:def 25;
  end;
 thus I = CurInstr ((Computation s2).i)
   proof assume
A5:  I <> CurInstr ((Computation s2).i);
A6:  IC Cs1i in dom ProgramPart p & IC Cs2i in dom ProgramPart p by A1,Th22;
        ProgramPart p c= p by RELAT_1:88;
    then dom ProgramPart p c= dom p by GRFUNC_1:8;
  then (Cs1i|dom p).IC Cs1i = Cs1i.IC Cs1i & (Cs2i|dom p).IC Cs2i = Cs2i.IC
Cs2i
   by A6,FUNCT_1:72;
   hence contradiction by A1,A3,A5,AMI_1:def 25;
  end;
end;

theorem
     for p being autonomic non programmed FinPartState of SCMPDS,
     s1, s2 being State of SCMPDS st p c= s1 & p c= s2
   for i being Element of NAT,k1,k2 be Integer,a,b be Int_position
    st CurInstr ((Computation s1).i) = (a,k1) := (b,k2) &
    a in dom p & DataLoc((Computation s1).i.a,k1) in dom p
 holds (Computation s1).i.DataLoc((Computation s1).i.b,k2) =
       (Computation s2).i.DataLoc((Computation s2).i.b,k2)
proof
 let p be autonomic non programmed FinPartState of SCMPDS,
     s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
   let i be Element of NAT,k1,k2 be Integer,a,b be Int_position;
   set I = CurInstr ((Computation s1).i);
   set Cs1i = (Computation s1).i;
   set Cs2i = (Computation s2).i;
A2: I = CurInstr ((Computation s2).i) by A1,Th23;
   set Cs1i1 = (Computation s1).(i+1);
   set Cs2i1 = (Computation s2).(i+1);
A3:    Cs1i1 = Following Cs1i by AMI_1:def 19
               .= Exec (CurInstr Cs1i, Cs1i);
A4:    Cs2i1 = Following Cs2i by AMI_1:def 19
               .= Exec (CurInstr Cs2i, Cs2i);
A5:   DataLoc(Cs1i.a,k1) in dom p implies (Cs1i1|dom p).DataLoc(Cs1i.a,k1)
       = Cs1i1.DataLoc(Cs1i.a,k1) & (Cs2i1|dom p).DataLoc(Cs1i.a,k1)
       = Cs2i1.DataLoc(Cs1i.a,k1) by FUNCT_1:72;
A6:  a in dom p implies (Cs1i|dom p).a = Cs1i.a &
          (Cs2i|dom p).a = Cs2i.a by FUNCT_1:72;
     assume
A7:        I = (a,k1) := (b,k2) & a in dom p & DataLoc(Cs1i.a,k1) in dom p;
then A8:      Cs1i.a=Cs2i.a by A1,A6,AMI_1:def 25;
             Cs1i1.DataLoc(Cs1i.a,k1) = Cs1i.DataLoc(Cs1i.b,k2) &
         Cs2i1.DataLoc(Cs2i.a,k1) = Cs2i.DataLoc(Cs2i.b,k2)
           by A2,A3,A4,A7,SCMPDS_2:59;
         hence thesis by A1,A5,A7,A8,AMI_1:def 25;
end;

theorem
     for p being autonomic non programmed FinPartState of SCMPDS,
     s1, s2 being State of SCMPDS
  st p c= s1 & p c= s2
   for i being Element of NAT,k1,k2 be Integer,a,b be Int_position
    st CurInstr ((Computation s1).i) = AddTo(a,k1,b,k2) &
    a in dom p & DataLoc((Computation s1).i.a,k1) in dom p
   holds (Computation s1).i.DataLoc((Computation s1).i.b,k2)
       = (Computation s2).i.DataLoc((Computation s2).i.b,k2)
proof
 let p be autonomic non programmed FinPartState of SCMPDS,
     s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
   let i be Element of NAT,k1,k2 be Integer,a,b be Int_position;
   set I = CurInstr ((Computation s1).i);
   set Cs1i = (Computation s1).i;
   set Cs2i = (Computation s2).i;
A2: I = CurInstr ((Computation s2).i) by A1,Th23;
   set Cs1i1 = (Computation s1).(i+1);
   set Cs2i1 = (Computation s2).(i+1);
A3:    Cs1i1 = Following Cs1i by AMI_1:def 19
               .= Exec (CurInstr Cs1i, Cs1i);
A4:    Cs2i1 = Following Cs2i by AMI_1:def 19
               .= Exec (CurInstr Cs2i, Cs2i);
A5:   DataLoc(Cs1i.a,k1) in dom p implies (Cs1i1|dom p).DataLoc(Cs1i.a,k1)
       = Cs1i1.DataLoc(Cs1i.a,k1) & (Cs2i1|dom p).DataLoc(Cs1i.a,k1)
       = Cs2i1.DataLoc(Cs1i.a,k1) by FUNCT_1:72;
A6:  a in dom p implies (Cs1i|dom p).a = Cs1i.a &
          (Cs2i|dom p).a = Cs2i.a by FUNCT_1:72;
A7:   DataLoc(Cs1i.a,k1) in dom p implies (Cs1i|dom p).DataLoc(Cs1i.a,k1)
       = Cs1i.DataLoc(Cs1i.a,k1) & (Cs2i|dom p).DataLoc(Cs1i.a,k1)
       = Cs2i.DataLoc(Cs1i.a,k1) by FUNCT_1:72;
     assume
A8:        I = AddTo(a,k1,b,k2) & a in dom p & DataLoc(Cs1i.a,k1) in dom p;
         set D11=Cs1i1.DataLoc(Cs1i.a,k1),
             D21=Cs2i1.DataLoc(Cs2i.a,k1),
             C11=Cs1i.DataLoc(Cs1i.a,k1),
             C12=Cs1i.DataLoc(Cs1i.b,k2),
             C21=Cs2i.DataLoc(Cs2i.a,k1),
             C22=Cs2i.DataLoc(Cs2i.b,k2);
A9:      Cs1i.a=Cs2i.a by A1,A6,A8,AMI_1:def 25;
then A10:      C11=C21 by A1,A7,A8,AMI_1:def 25;
A11:      D11 = D21 by A1,A5,A8,A9,AMI_1:def 25;
             D11 = C11+ C12 & D21 = C21 + C22 by A2,A3,A4,A8,SCMPDS_2:61;
         hence thesis by A10,A11;
end;

theorem
     for p being autonomic non programmed FinPartState of SCMPDS,
     s1, s2 being State of SCMPDS
  st p c= s1 & p c= s2
   for i being Element of NAT,k1,k2 be Integer,a,b be Int_position
    st CurInstr ((Computation s1).i) = SubFrom(a,k1,b,k2) &
    a in dom p & DataLoc((Computation s1).i.a,k1) in dom p
   holds (Computation s1).i.DataLoc((Computation s1).i.b,k2)
       = (Computation s2).i.DataLoc((Computation s2).i.b,k2)
proof
 let p be autonomic non programmed FinPartState of SCMPDS,
     s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
   let i be Element of NAT,k1,k2 be Integer,a,b be Int_position;
   set I = CurInstr ((Computation s1).i);
   set Cs1i = (Computation s1).i;
   set Cs2i = (Computation s2).i;
A2: I = CurInstr ((Computation s2).i) by A1,Th23;
   set Cs1i1 = (Computation s1).(i+1);
   set Cs2i1 = (Computation s2).(i+1);
A3:    Cs1i1 = Following Cs1i by AMI_1:def 19
               .= Exec (CurInstr Cs1i, Cs1i);
A4:    Cs2i1 = Following Cs2i by AMI_1:def 19
               .= Exec (CurInstr Cs2i, Cs2i);
A5:   DataLoc(Cs1i.a,k1) in dom p implies (Cs1i1|dom p).DataLoc(Cs1i.a,k1)
       = Cs1i1.DataLoc(Cs1i.a,k1) & (Cs2i1|dom p).DataLoc(Cs1i.a,k1)
       = Cs2i1.DataLoc(Cs1i.a,k1) by FUNCT_1:72;
A6:  a in dom p implies (Cs1i|dom p).a = Cs1i.a &
          (Cs2i|dom p).a = Cs2i.a by FUNCT_1:72;
A7:   DataLoc(Cs1i.a,k1) in dom p implies (Cs1i|dom p).DataLoc(Cs1i.a,k1)
       = Cs1i.DataLoc(Cs1i.a,k1) & (Cs2i|dom p).DataLoc(Cs1i.a,k1)
       = Cs2i.DataLoc(Cs1i.a,k1) by FUNCT_1:72;
     assume
A8:        I = SubFrom(a,k1,b,k2) & a in dom p & DataLoc(Cs1i.a,k1) in dom p;
         set D11=Cs1i1.DataLoc(Cs1i.a,k1),
             D21=Cs2i1.DataLoc(Cs2i.a,k1),
             C11=Cs1i.DataLoc(Cs1i.a,k1),
             C12=Cs1i.DataLoc(Cs1i.b,k2),
             C21=Cs2i.DataLoc(Cs2i.a,k1),
             C22=Cs2i.DataLoc(Cs2i.b,k2);
A9:      Cs1i.a=Cs2i.a by A1,A6,A8,AMI_1:def 25;
then A10:      C11=C21 by A1,A7,A8,AMI_1:def 25;
A11:      D11 = D21 by A1,A5,A8,A9,AMI_1:def 25;
             D11 = C11- C12 & D21 = C21 - C22 by A2,A3,A4,A8,SCMPDS_2:62;
         hence thesis by A10,A11;
end;

theorem
     for p being autonomic non programmed FinPartState of SCMPDS,
     s1, s2 being State of SCMPDS
  st p c= s1 & p c= s2
   for i being Element of NAT,k1,k2 be Integer,a,b be Int_position
    st CurInstr ((Computation s1).i) = MultBy(a,k1,b,k2) &
    a in dom p & DataLoc((Computation s1).i.a,k1) in dom p
   holds (Computation s1).i.DataLoc((Computation s1).i.a,k1)
       * (Computation s1).i.DataLoc((Computation s1).i.b,k2)
       = (Computation s2).i.DataLoc((Computation s2).i.a,k1)
       * (Computation s2).i.DataLoc((Computation s2).i.b,k2)
proof
 let p be autonomic non programmed FinPartState of SCMPDS,
     s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
   let i be Element of NAT,k1,k2 be Integer,a,b be Int_position;
   set I = CurInstr ((Computation s1).i);
   set Cs1i = (Computation s1).i;
   set Cs2i = (Computation s2).i;
A2: I = CurInstr ((Computation s2).i) by A1,Th23;
   set Cs1i1 = (Computation s1).(i+1);
   set Cs2i1 = (Computation s2).(i+1);
A3:    Cs1i1 = Following Cs1i by AMI_1:def 19
               .= Exec (CurInstr Cs1i, Cs1i);
A4:    Cs2i1 = Following Cs2i by AMI_1:def 19
               .= Exec (CurInstr Cs2i, Cs2i);
A5:   DataLoc(Cs1i.a,k1) in dom p implies (Cs1i1|dom p).DataLoc(Cs1i.a,k1)
       = Cs1i1.DataLoc(Cs1i.a,k1) & (Cs2i1|dom p).DataLoc(Cs1i.a,k1)
       = Cs2i1.DataLoc(Cs1i.a,k1) by FUNCT_1:72;
A6:  a in dom p implies (Cs1i|dom p).a = Cs1i.a &
          (Cs2i|dom p).a = Cs2i.a by FUNCT_1:72;
     assume
A7:        I = MultBy (a,k1,b,k2) & a in dom p & DataLoc(Cs1i.a,k1) in dom p;
         set D11=Cs1i1.DataLoc(Cs1i.a,k1),
             D21=Cs2i1.DataLoc(Cs2i.a,k1);
A8:      Cs1i.a=Cs2i.a by A1,A6,A7,AMI_1:def 25;
             D11 = Cs1i.DataLoc(Cs1i.a,k1) * Cs1i.DataLoc(Cs1i.b,k2) &
         D21 = Cs2i.DataLoc(Cs2i.a,k1) * Cs2i.DataLoc(Cs2i.b,k2)
         by A2,A3,A4,A7,SCMPDS_2:63;
         hence thesis by A1,A5,A7,A8,AMI_1:def 25;
end;

theorem
     for p being autonomic non programmed FinPartState of SCMPDS,
     s1, s2 being State of SCMPDS
  st p c= s1 & p c= s2
   for i,m being Element of NAT,a being Int_position,k1,k2 be Integer
    st CurInstr ((Computation s1).i) = (a,k1)<>0_goto k2 &
       m= IC (Computation s1).i & m+k2 >= 0 & k2 <> 1
   holds ((Computation s1).i.DataLoc((Computation s1).i.a,k1) = 0 iff
          (Computation s2).i.DataLoc((Computation s2).i.a,k1) = 0 )
proof
 let p be autonomic non programmed FinPartState of SCMPDS,
     s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
   let i,m be Element of NAT,a be Int_position,k1,k2 be Integer;
 set I = CurInstr ((Computation s1).i);
    set Cs1i = (Computation s1).i;
    set Cs2i = (Computation s2).i;
A2: IC SCMPDS in dom p by Th17;
A3: IC Cs1i = IC Cs2i by A1,Th23;
A4: I = CurInstr ((Computation s2).i) by A1,Th23;
    set Cs1i1 = (Computation s1).(i+1);
    set Cs2i1 = (Computation s2).(i+1);
A5:  Cs1i1 = Following Cs1i by AMI_1:def 19
             .= Exec (CurInstr Cs1i, Cs1i);
A6:  Cs2i1 = Following Cs2i by AMI_1:def 19
             .= Exec (CurInstr Cs2i, Cs2i);
A7:(Cs1i1|dom p).IC SCMPDS = Cs1i1.IC SCMPDS &
               (Cs2i1|dom p).IC SCMPDS = Cs2i1.IC SCMPDS
                   by A2,FUNCT_1:72;
A8:  (Cs1i1|dom p) = (Cs2i1|dom p) by A1,AMI_1:def 25;
  assume
A9: I = (a,k1)<>0_goto k2 & m= IC Cs1i & m+k2 >= 0 & k2 <> 1;
A10: m+1>=0 by NAT_1:2;
A11: now assume
A12: (Computation s1).i.DataLoc(Cs1i.a,k1) = 0 &
    (Computation s2).i.DataLoc(Cs2i.a,k1) <> 0;
then A13: Cs1i1.IC SCMPDS = Next IC Cs1i by A5,A9,SCMPDS_2:67
    .=ICplusConst(Cs1i,1) by Th20;
      Cs2i1.IC SCMPDS = ICplusConst(Cs2i,k2) by A4,A6,A9,A12,SCMPDS_2:67;
    hence contradiction by A3,A7,A8,A9,A10,A13,Th18;
   end;
       now assume
A14: (Computation s2).i.DataLoc(Cs2i.a,k1) = 0 &
    (Computation s1).i.DataLoc(Cs1i.a,k1) <> 0;
then A15: Cs2i1.IC SCMPDS = Next IC Cs2i by A4,A6,A9,SCMPDS_2:67
    .=ICplusConst(Cs2i,1) by Th20;
      Cs1i1.IC SCMPDS = ICplusConst(Cs1i,k2) by A5,A9,A14,SCMPDS_2:67;
    hence contradiction by A3,A7,A8,A9,A10,A15,Th18;
   end;
  hence (Computation s1).i.DataLoc(Cs1i.a,k1) = 0 iff
  (Computation s2).i.DataLoc(Cs2i.a,k1) = 0 by A11;
end;

theorem
     for p being autonomic non programmed FinPartState of SCMPDS,
     s1, s2 being State of SCMPDS st p c= s1 & p c= s2
   for i,m being Element of NAT,a being Int_position,k1,k2 be Integer
    st CurInstr ((Computation s1).i) = (a,k1)<=0_goto k2 &
       m= IC (Computation s1).i & m+k2 >= 0 & k2 <> 1
   holds ((Computation s1).i.DataLoc((Computation s1).i.a,k1) > 0 iff
          (Computation s2).i.DataLoc((Computation s2).i.a,k1) > 0 )
proof
 let p be autonomic non programmed FinPartState of SCMPDS,
     s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
   let i,m be Element of NAT,a be Int_position,k1,k2 be Integer;
 set I = CurInstr ((Computation s1).i);
    set Cs1i = (Computation s1).i;
    set Cs2i = (Computation s2).i;
A2: IC SCMPDS in dom p by Th17;
A3: IC Cs1i = IC Cs2i by A1,Th23;
A4: I = CurInstr ((Computation s2).i) by A1,Th23;
    set Cs1i1 = (Computation s1).(i+1);
    set Cs2i1 = (Computation s2).(i+1);
A5:  Cs1i1 = Following Cs1i by AMI_1:def 19
             .= Exec (CurInstr Cs1i, Cs1i);
A6:  Cs2i1 = Following Cs2i by AMI_1:def 19
             .= Exec (CurInstr Cs2i, Cs2i);
A7:(Cs1i1|dom p).IC SCMPDS = Cs1i1.IC SCMPDS &
               (Cs2i1|dom p).IC SCMPDS = Cs2i1.IC SCMPDS
                   by A2,FUNCT_1:72;
A8:  (Cs1i1|dom p) = (Cs2i1|dom p) by A1,AMI_1:def 25;
  assume
A9: I = (a,k1)<=0_goto k2 & m= IC Cs1i & m+k2 >= 0 & k2 <> 1;
A10: m+1>=0 by NAT_1:2;
A11: now assume
A12: (Computation s1).i.DataLoc(Cs1i.a,k1) > 0 &
    (Computation s2).i.DataLoc(Cs2i.a,k1) <= 0;
then A13: Cs1i1.IC SCMPDS = Next IC Cs1i by A5,A9,SCMPDS_2:68
    .=ICplusConst(Cs1i,1) by Th20;
      Cs2i1.IC SCMPDS = ICplusConst(Cs2i,k2) by A4,A6,A9,A12,SCMPDS_2:68;
    hence contradiction by A3,A7,A8,A9,A10,A13,Th18;
   end;
       now assume
A14: (Computation s2).i.DataLoc(Cs2i.a,k1) > 0 &
    (Computation s1).i.DataLoc(Cs1i.a,k1) <= 0;
then A15: Cs2i1.IC SCMPDS = Next IC Cs2i by A4,A6,A9,SCMPDS_2:68
    .=ICplusConst(Cs2i,1) by Th20;
      Cs1i1.IC SCMPDS = ICplusConst(Cs1i,k2) by A5,A9,A14,SCMPDS_2:68;
    hence contradiction by A3,A7,A8,A9,A10,A15,Th18;
   end;
  hence (Computation s1).i.DataLoc(Cs1i.a,k1) > 0 iff
  (Computation s2).i.DataLoc(Cs2i.a,k1) > 0 by A11;
end;

theorem
     for p being autonomic non programmed FinPartState of SCMPDS,
     s1, s2 being State of SCMPDS
  st p c= s1 & p c= s2
   for i,m being Element of NAT,a being Int_position,k1,k2 be Integer
    st CurInstr ((Computation s1).i) = (a,k1)>=0_goto k2 &
       m= IC (Computation s1).i & m+k2 >= 0 & k2 <> 1
   holds ((Computation s1).i.DataLoc((Computation s1).i.a,k1) < 0 iff
          (Computation s2).i.DataLoc((Computation s2).i.a,k1) < 0 )
proof
 let p be autonomic non programmed FinPartState of SCMPDS,
     s1, s2 be State of SCMPDS such that
A1: p c= s1 & p c= s2;
   let i,m be Element of NAT,a be Int_position,k1,k2 be Integer;
 set I = CurInstr ((Computation s1).i);
    set Cs1i = (Computation s1).i;
    set Cs2i = (Computation s2).i;
A2: IC SCMPDS in dom p by Th17;
A3: IC Cs1i = IC Cs2i by A1,Th23;
A4: I = CurInstr ((Computation s2).i) by A1,Th23;
    set Cs1i1 = (Computation s1).(i+1);
    set Cs2i1 = (Computation s2).(i+1);
A5:  Cs1i1 = Following Cs1i by AMI_1:def 19
             .= Exec (CurInstr Cs1i, Cs1i);
A6:  Cs2i1 = Following Cs2i by AMI_1:def 19
             .= Exec (CurInstr Cs2i, Cs2i);
A7:(Cs1i1|dom p).IC SCMPDS = Cs1i1.IC SCMPDS &
               (Cs2i1|dom p).IC SCMPDS = Cs2i1.IC SCMPDS
                   by A2,FUNCT_1:72;
A8:  (Cs1i1|dom p) = (Cs2i1|dom p) by A1,AMI_1:def 25;
  assume
A9: I = (a,k1)>=0_goto k2 & m= IC Cs1i & m+k2 >= 0 & k2 <> 1;
A10: m+1>=0 by NAT_1:2;
A11: now assume
A12: (Computation s1).i.DataLoc(Cs1i.a,k1) < 0 &
    (Computation s2).i.DataLoc(Cs2i.a,k1) >= 0;
then A13: Cs1i1.IC SCMPDS = Next IC Cs1i by A5,A9,SCMPDS_2:69
    .=ICplusConst(Cs1i,1) by Th20;
      Cs2i1.IC SCMPDS = ICplusConst(Cs2i,k2) by A4,A6,A9,A12,SCMPDS_2:69;
    hence contradiction by A3,A7,A8,A9,A10,A13,Th18;
   end;
       now assume
A14: (Computation s2).i.DataLoc(Cs2i.a,k1) < 0 &
    (Computation s1).i.DataLoc(Cs1i.a,k1) >= 0;
then A15: Cs2i1.IC SCMPDS = Next IC Cs2i by A4,A6,A9,SCMPDS_2:69
    .=ICplusConst(Cs2i,1) by Th20;
      Cs1i1.IC SCMPDS = ICplusConst(Cs1i,k2) by A5,A9,A14,SCMPDS_2:69;
    hence contradiction by A3,A7,A8,A9,A10,A15,Th18;
   end;
  hence (Computation s1).i.DataLoc(Cs1i.a,k1) < 0 iff
  (Computation s2).i.DataLoc(Cs2i.a,k1) < 0 by A11;
end;

begin :: Program Shift in the SCMPDS Computer

definition let k;
 canceled;

 func inspos k -> Instruction-Location of SCMPDS equals
   il.k;
 coherence by AMI_1:def 4;
end;

theorem   ::SF2_18
  for k1,k2 be Element of NAT st k1 <> k2 holds inspos k1 <> inspos k2;

theorem Th32:  ::SF2_21
 for il being Instruction-Location of SCMPDS ex i being Element of NAT
  st il = inspos i
proof
  let il be Instruction-Location of SCMPDS;
   il in NAT by AMI_1:def 4;
   then reconsider D = il as Instruction-Location of SCM by AMI_1:def 4;
   consider i being Element of NAT such that
A1:  D = il.i by AMI_5:19;
   take i;
   thus il = inspos i by A1;
end;

definition
let loc be Instruction-Location of SCMPDS , k be Element of NAT;
func loc + k -> Instruction-Location of SCMPDS means
:Def3:  ex m being Element of NAT st loc = inspos m & it = inspos(m+k);
existence
 proof
  consider m being Element of NAT such that A1: loc = inspos m by Th32;
  take IT = inspos(m+k);
  take m;
  thus loc = inspos m & IT = inspos(m+k) by A1;
 end;
uniqueness;

func loc -' k -> Instruction-Location of SCMPDS means
:Def4: ex m being Element of NAT st loc = inspos m & it = inspos (m -' k);
existence
 proof
  consider m being Element of NAT such that A2: loc = inspos m by Th32;
  take IT = inspos(m -' k);
  take m;
  thus loc = inspos m & IT = inspos(m -' k) by A2;
 end;
uniqueness;
end;

theorem
     for l being Instruction-Location of SCMPDS,m,n
   holds l+m+n = l+(m+n)
proof let l be Instruction-Location of SCMPDS,m,n;
  consider i being Element of NAT such that
A1:  l = inspos i and
A2:  l+m = inspos(i+m) by Def3;
      l+m+n = inspos(i+m+n) by A2,Def3
         .= inspos(i+(m+n));
 hence l+m+n = l+(m+n) by A1,Def3;
end;

theorem Th34:
 for loc being Instruction-Location of SCMPDS,k being Element of NAT
  holds loc + k -' k = loc
  proof
   let loc be Instruction-Location of SCMPDS, k be Element of NAT;
   consider m being Element of NAT such that
A1: inspos m = loc by Th32;
    thus loc + k -' k = inspos(m + k) -' k by A1,Def3
    .= inspos(m + k -' k) by Def4
    .= loc by A1,BINARITH:39;
end;

theorem
     for l1,l2 being Instruction-Location of SCMPDS, k being Element of NAT
 holds
    Start-At(l1 + k) = Start-At(l2 +k) iff Start-At l1 = Start-At l2
proof
   let l1,l2 be Instruction-Location of SCMPDS, k be Element of NAT;
   hereby
   assume
A1: Start-At(l1 + k) = Start-At(l2 + k);
A2: Start-At(l1 + k) = IC SCMPDS .--> (l1 + k) &
    Start-At(l2 + k) = IC SCMPDS .--> (l2 + k);
     {[IC SCMPDS, l1 + k]} = IC SCMPDS .--> (l2 + k) by A1,AMI_1:96;
    then {[IC SCMPDS, l1 + k]} = {[IC SCMPDS, l2 + k]} by A2,AMI_1:96;
    then [IC SCMPDS, l1 + k] = [IC SCMPDS, l2 + k] by ZFMISC_1:6;
    then l1 + k = l2 + k by ZFMISC_1:33;
    then l1 = l2 + k -' k by Th34;
    hence Start-At l1 = Start-At l2 by Th34;
   end;
   assume Start-At l1 = Start-At l2;
    then {[IC SCMPDS, l1]} = Start-At l2 by AMI_1:96;
    then {[IC SCMPDS, l1]} = {[IC SCMPDS, l2]} by AMI_1:96;
    then [IC SCMPDS, l1] = [IC SCMPDS, l2] by ZFMISC_1:6;
    hence Start-At(l1 + k) = Start-At(l2 + k) by ZFMISC_1:33;
end;

theorem
     for l1,l2 being Instruction-Location of SCMPDS, k being Element of NAT
  st Start-At l1 = Start-At l2
  holds
    Start-At(l1 -' k) = Start-At(l2 -' k)
proof
  let l1,l2 be Instruction-Location of SCMPDS, k be Element of NAT;
   assume Start-At l1 = Start-At l2;
   then {[IC SCMPDS, l1]} = Start-At l2 by AMI_1:96;
   then {[IC SCMPDS, l1]} = {[IC SCMPDS, l2]} by AMI_1:96;
   then [IC SCMPDS, l1] = [IC SCMPDS, l2] by ZFMISC_1:6;
   hence Start-At(l1 -' k) = Start-At(l2 -' k) by ZFMISC_1:33;
end;

definition let IT be FinPartState of SCMPDS;
 attr IT is initial means
      for m,n st inspos n in dom IT & m < n holds inspos m in dom IT;
end;

definition
 func SCMPDS-Stop -> FinPartState of SCMPDS equals
  (inspos 0).--> halt SCMPDS;
 correctness;
end;

registration
 cluster SCMPDS-Stop -> non empty initial programmed;
 coherence
  proof
   thus SCMPDS-Stop is non empty;
A1:  dom SCMPDS-Stop = {inspos 0} by FUNCOP_1:19;
   thus SCMPDS-Stop is initial
    proof let m,n such that
A2:   inspos n in dom SCMPDS-Stop and
A3:   m < n;
          inspos n = inspos 0 by A1,A2,TARSKI:def 1;
     hence inspos m in dom SCMPDS-Stop by A3,NAT_1:2;
    end;
   thus dom SCMPDS-Stop c= NAT
          by A1,ZFMISC_1:37;
  end;
end;

registration
 cluster initial programmed non empty FinPartState of SCMPDS;
 existence
 proof take SCMPDS-Stop;
   thus thesis;
 end;
end;

definition
 let p be programmed FinPartState of SCMPDS , k be Element of NAT;
 func Shift(p,k) -> programmed FinPartState of SCMPDS means
:Def7:  dom it = { inspos(m+k):inspos m in dom p } &
 for m st inspos m in dom p holds it.inspos(m+k) = p.inspos m;
 existence
  proof
   deffunc U(Element of NAT) = inspos $1;
   deffunc V(Element of NAT) = inspos($1+k);
   set A = { V(m): U(m) in dom p };
   defpred P [set,set] means ex m st $1 = V(m) & $2 = p.U(m);
   A1:for e being set st e in A ex u being set st P[e,u]
    proof
     let e be set;
     assume e in A;
     then consider m such that A2: e = inspos(m+k) & inspos m in dom p;
     take p.inspos m;
     thus thesis by A2;
    end;
   consider f being Function such that
A3:  dom f = A and
A4:  for e being set st e in A holds P[e,f.e] from CLASSES1:sch 1(A1);
 A5: A c= NAT
      proof
       let x be set;
       assume x in A;
       then ex m st x = inspos(m+k) & inspos m in dom p;
       hence x in NAT;
      end;
         then A c= the carrier of SCMPDS by XBOOLE_1:1;
then A6:  dom f c= dom the Object-Kind of SCMPDS by A3,FUNCT_2:def 1
;  :: -> def 4
         for x being set st x in dom f holds f.x in (the Object-Kind of SCMPDS)
.
x
      proof
       let x be set;
       assume
A7:          x in dom f;
       then consider m such that
A8:       x = inspos(m+k) and
A9:       f.x = p.inspos m by A3,A4;
       reconsider y = x as Instruction-Location of SCMPDS by A3,A5,A7,
AMI_1:def 4;
A10:   (the Object-Kind of SCMPDS).y = ObjectKind y
                    .= the Instructions of SCMPDS by AMI_1:def 14;
       consider s being State of SCMPDS such that
A11:       p c= s by AMI_1:82;
       consider j such that
A12:       inspos(m+k) = inspos(j+k) and
A13:       inspos j in dom p by A3,A7,A8;
           s.inspos m in the Instructions of SCMPDS;
       hence f.x in (the Object-Kind of SCMPDS).x
              by A9,A10,A11,A12,A13,GRFUNC_1:8;
      end;
    then reconsider f as Element of sproduct the Object-Kind of SCMPDS
              by A6,CARD_3:def 9;
A14: dom p is finite;
A15: for m1,m2 being Element of NAT st U(m1) = U(m2) holds m1 = m2;
        A is finite from FUNCT_7:sch 2(A14,A15);
    then f is finite by A3,FINSET_1:29;
    then reconsider f as FinPartState of SCMPDS by AMI_1:77;
        f is programmed
     proof
      let x be set;
      assume x in dom f;
      then ex m st x = inspos(m+k) & inspos m in dom p by A3;
      hence x in NAT;
     end;
    then reconsider IT = f as programmed FinPartState of SCMPDS;
    take IT;
    thus dom IT = { inspos(m+k):inspos m in dom p } by A3;
    let m;
    assume inspos m in dom p;
    then inspos(m+k) in A;
    then consider j such that
A16:     inspos(m+k) = inspos(j+k) and
A17:     f.inspos(m+k) = p.inspos j by A4;
   thus IT.inspos(m+k) = p.inspos m by A16,A17;
  end;

 uniqueness
  proof
   let IT1,IT2 be programmed FinPartState of SCMPDS such that
A18:  dom IT1 = { inspos(m+k):inspos m in dom p } and
A19:  for m st inspos m in dom p holds IT1.inspos(m+k) = p.inspos m and
A20:  dom IT2 = { inspos(m+k):inspos m in dom p } and
A21:  for m st inspos m in dom p holds IT2.inspos(m+k) = p.inspos m;
         for x being set st x in { inspos(m+k):inspos m in dom p } holds
      IT1.x = IT2.x
       proof
        let x be set;
        assume x in { inspos(m+k):inspos m in dom p };
        then consider m such that
A22:         x = inspos(m+k) and
A23:         inspos m in dom p;
        thus IT1.x = p.inspos m by A19,A22,A23
                   .= IT2.x by A21,A22,A23;
       end;
    hence IT1=IT2 by A18,A20,FUNCT_1:9;
  end;
end;

theorem
     for l being Instruction-Location of SCMPDS, k being Element of NAT,
     p being programmed FinPartState of SCMPDS st l in dom p
     holds Shift(p,k).(l + k) = p.l
 proof
  let l be Instruction-Location of SCMPDS , k be Element of NAT,
      p be programmed FinPartState of SCMPDS such that A1: l in dom p;
   consider m being Element of NAT such that A2: l = inspos m by Th32;
   thus Shift(p,k).(l + k)
      = Shift(p,k).(inspos(m+k)) by A2,Def3
     .= p.l by A1,A2,Def7;
 end;

reserve l,p,q for Element of NAT;

theorem
     for p being programmed FinPartState of SCMPDS, k being Element of NAT
  holds dom Shift(p,k) =
         { il+k where il is Instruction-Location of SCMPDS: il in dom p}
  proof
     let p be programmed FinPartState of SCMPDS, k be Element of NAT;
A1: dom Shift(p,k) = { inspos(m+k):inspos m in dom p } by Def7;
     hereby
      let e be set;
      assume e in dom Shift(p,k);
      then consider m being Element of NAT such that
A2:   e = inspos(m+k) and
A3:   inspos m in dom p by A1;
          (inspos m)+k = inspos(m+k) by Def3;
     hence e in { il+k where il is Instruction-Location of SCMPDS: il in dom p
}
        by A2,A3;
    end;
    let e be set;
    assume e in { il+k where il is Instruction-Location of SCMPDS: il in
 dom p};
   then consider il being Instruction-Location of SCMPDS such that
A4: e = il+k and
A5: il in dom p;
    consider m being Element of NAT such that
A6: il = inspos m and
A7: il+k = inspos(m+k) by Def3;
   thus e in dom Shift(p,k) by A1,A4,A5,A6,A7;
  end;

theorem
     for I being programmed FinPartState of SCMPDS
  holds Shift(Shift(I,m),n) = Shift(I,m+n)
proof let I be programmed FinPartState of SCMPDS;
  set A = { inspos(l+m) : inspos l in dom I };
A1: dom Shift(I,m) = A by Def7;
       {inspos(p+n):inspos p in A } = { inspos(q+(m+n)):inspos q in dom I}
    proof
     thus {inspos(p+n):inspos p in A } c= { inspos(q+(m+n)):inspos q in dom I}
      proof let x be set;
       assume x in {inspos(p+n):inspos p in A };
        then consider p such that
A2:      x = inspos(p+n) and
A3:      inspos p in A;
        consider l such that
A4:      inspos p = inspos(l+m) and
A5:      inspos l in dom I by A3;
         x = inspos(l+(m+n)) by A2,A4;
       hence x in { inspos(q+(m+n)):inspos q in dom I} by A5;
      end;
     let x be set;
     assume x in { inspos(q+(m+n)):inspos q in dom I};
      then consider q such that
A6:    x = inspos(q+(m+n)) and
A7:    inspos q in dom I;
A8:    x = inspos((q+m)+n) by A6;
          inspos(q+m) in A by A7;
     hence x in {inspos(p+n):inspos p in A } by A8;
    end;
then A9: dom Shift(Shift(I,m),n)
         = { inspos(l+(m+n)):inspos l in dom I} by A1,Def7;
        now let l; assume
A10:  inspos l in dom I;
then A11:  inspos(l+m) in dom Shift(I,m) by A1;
     thus Shift(Shift(I,m),n).inspos(l+(m+n))
        = Shift(Shift(I,m),n).inspos(l+m+n)
       .= Shift(I,m).inspos(l+m) by A11,Def7
       .= I.inspos l by A10,Def7;
    end;
    hence Shift(Shift(I,m),n) = Shift(I,m+n) by A9,Def7;
end;

theorem
     for s be programmed FinPartState of SCMPDS,
     f be Function of the Instructions of SCMPDS, the Instructions of SCMPDS
 for n holds Shift(f*s,n) = f*Shift(s,n)
proof let s be programmed FinPartState of SCMPDS,
          f be Function of the Instructions of SCMPDS,
                           the Instructions of SCMPDS;
    let n;
A1: dom(f*s) = dom s by AMI_1:119;
A2: dom(f*Shift(s,n)) = dom Shift(s,n) by AMI_1:119;
A3: dom Shift(s,n) = { inspos(m+n):inspos m in dom(f*s) } by A1,Def7;
       now let m; assume
A4: inspos m in dom(f*s);
    then inspos(m+n) in dom Shift(s,n) by A3;
    hence (f*Shift(s,n)).inspos(m+n)
     = f.(Shift(s,n).inspos(m+n)) by FUNCT_1:23
    .= f.(s.inspos m) by A1,A4,Def7
    .= (f*s).inspos m by A1,A4,FUNCT_1:23;
  end;
  hence Shift(f*s,n) = f*Shift(s,n) by A2,A3,Def7;
end;

theorem
    for I,J being programmed FinPartState of SCMPDS holds
 Shift(I +* J, n) = Shift(I,n) +* Shift(J,n)
proof let I,J be programmed FinPartState of SCMPDS;
A1: dom(I +* J) = dom I \/ dom J by FUNCT_4:def 1;
A2: dom Shift(J,n) = { inspos(m+n):inspos m in dom J } by Def7;
A3: dom Shift(I,n) = { inspos(m+n):inspos m in dom I } by Def7;
      dom Shift(I,n) \/ dom Shift(J,n) = { inspos(m+n):inspos m in dom I \/ dom
J
}
   proof
    hereby let x be set;
     assume x in dom Shift(I,n) \/ dom Shift(J,n);
      then x in dom Shift(I,n) or x in dom Shift(J,n) by XBOOLE_0:def 2;
      then consider m such that
A4:     x = inspos(m+n) & inspos m in dom J or
       x = inspos(m+n) & inspos m in dom I by A2,A3;
          inspos m in dom I \/ dom J by A4,XBOOLE_0:def 2;
     hence x in { inspos(l+n):inspos l in dom I \/ dom J } by A4;
    end;
    let x be set;
    assume x in { inspos(m+n):inspos m in dom I \/ dom J };
     then consider m such that
A5:   x = inspos(m+n) and
A6:   inspos m in dom I \/ dom J;
         inspos m in dom I or inspos m in dom J by A6,XBOOLE_0:def 2;
     then x in dom Shift(I,n) or x in dom Shift(J,n) by A2,A3,A5;
    hence thesis by XBOOLE_0:def 2;
   end;
then A7: dom(Shift(I,n) +* Shift(J,n)) = { inspos(m+n):inspos m in dom(I +* J)
}
                                   by A1,FUNCT_4:def 1;
      now let m such that
A8: inspos m in dom(I +* J);
   per cases;
   suppose
A9:  inspos m in dom J;
    then inspos(m+n) in dom Shift(J,n) by A2;
   hence (Shift(I,n) +* Shift(J,n)).inspos(m+n)
      = Shift(J,n).inspos(m+n) by FUNCT_4:14
     .= J.inspos m by A9,Def7
     .= (I +* J).inspos m by A9,FUNCT_4:14;
   end;
   suppose
A10:  not inspos m in dom J;
   then not ex l st inspos(m+n) = inspos(l+n) & inspos l in dom J;

then A11:  not inspos(m+n) in dom Shift(J,n) by A2;
        inspos m in dom I \/ dom J by A8,FUNCT_4:def 1;
then A12:  inspos m in dom I by A10,XBOOLE_0:def 2;
    thus (Shift(I,n) +* Shift(J,n)).inspos(m+n)
      = Shift(I,n).inspos(m+n) by A11,FUNCT_4:12
     .= I.inspos m by A12,Def7
     .= (I +* J).inspos m by A10,FUNCT_4:12;
  end;
  end;
 hence Shift(I +* J, n) = Shift(I,n) +* Shift(J,n) by A7,Def7;
end;

