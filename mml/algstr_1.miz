:: From Loops to Abelian Multiplicative Groups with Zero
::  by Micha{\l} Muzalewski and Wojciech Skaba
::
:: Received July 10, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies RLVECT_1, BOOLE, ARYTM_1, VECTSP_1, CAT_1, BINOP_1, RELAT_1,
      ARYTM_3, ALGSTR_1, GROUP_1, VECTSP_2, ARYTM, ALGSTR_0;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, REAL_1, BINOP_2, STRUCT_0,
      ALGSTR_0, GROUP_1, VECTSP_1, RLVECT_1;
 constructors BINOP_1, BINOP_2, VECTSP_1, RLVECT_1, FUNCT_5;
 registrations NUMBERS, VECTSP_1, ALGSTR_0;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions STRUCT_0, VECTSP_1, ALGSTR_0;
 theorems RLVECT_1, VECTSP_1, TARSKI, XCMPLX_1, BINOP_2, GROUP_1, CARD_1,
      ALGSTR_0, STRUCT_0;

begin :: GROUPS

reserve L for non empty addLoopStr;
reserve a,b,c,x,y,z for Element of L;

theorem Th1:
  (for a holds a + 0.L = a) & (for a ex x st a+x = 0.L)
  & (for a,b,c holds (a+b)+c = a+(b+c)) implies (a+b = 0.L implies b+a = 0.L)
proof
  assume
A1: (for a holds a + 0.L = a) & (for a ex x st a+x = 0.L)
  & (for a,b,c holds (a+b)+c = a+(b+c));
  assume
A2: a+b = 0.L;
  consider x such that
A3: b + x = 0.L by A1;
  thus b+a = (b+a) + (b+x) by A1,A3
    .= ((b+a) + b) + x by A1
    .= (b + 0.L) + x by A1,A2
    .= 0.L by A1,A3;
end;

theorem Th2:
  (for a holds a + 0.L = a) & (for a ex x st a+x = 0.L)
  & (for a,b,c holds (a+b)+c = a+(b+c)) implies 0.L+a = a+0.L
proof
  assume
A1: (for a holds a + 0.L = a) & (for a ex x st a+x = 0.L)
  & (for a,b,c holds (a+b)+c = a+(b+c));
  then consider x such that
A2: a + x = 0.L;
  thus 0.L+a = a + (x+a) by A1,A2
    .= a+0.L by A1,A2,Th1;
end;

theorem Th3:
  (for a holds a + 0.L = a) & (for a ex x st a+x = 0.L)
  & (for a,b,c holds (a+b)+c = a+(b+c)) implies for a ex x st x+a = 0.L
proof
  assume
A1: (for a holds a + 0.L = a) & (for a ex x st a+x = 0.L)
  & (for a,b,c holds (a+b)+c = a+(b+c));
  let a;
  consider x such that
A2: a + x = 0.L by A1;
  x+a=0.L by A1,A2,Th1;
  hence thesis;
end;

definition
  let x be set;
  canceled 2;
  func Extract x -> Element of {x} equals

  x;
  coherence by TARSKI:def 1;
end;

canceled;

theorem Th5:
  for a,b being Element of Trivial-addLoopStr holds a = b
proof
  let a,b be Element of Trivial-addLoopStr;
  thus a = {} by CARD_1:87,TARSKI:def 1
    .= b by CARD_1:87,TARSKI:def 1;
end;

theorem
  for a,b be Element of Trivial-addLoopStr holds a+b = 0. Trivial-addLoopStr
  by Th5;

Lm1: for a be Element of Trivial-addLoopStr holds a + 0.Trivial-addLoopStr = a
by Th5;

Lm2: for a be Element of Trivial-addLoopStr holds 0.Trivial-addLoopStr + a = a
by Th5;

Lm3: for a,b be Element of Trivial-addLoopStr
ex x be Element of Trivial-addLoopStr st a+x=b
proof
  let a,b be Element of Trivial-addLoopStr;
  take x = 0.Trivial-addLoopStr;
  thus a+x = b by Th5;
end;

Lm4: for a,b be Element of Trivial-addLoopStr
ex x be Element of Trivial-addLoopStr st x+a=b
proof
  let a,b be Element of Trivial-addLoopStr;
  take x = 0.Trivial-addLoopStr;
  thus x+a = b by Th5;
end;

Lm5: for a,x,y be Element of Trivial-addLoopStr holds a+x=a+y
implies x=y by Th5;

Lm6: for a,x,y be Element of Trivial-addLoopStr holds x+a=y+a
implies x=y by Th5;

definition
  let IT be non empty addLoopStr;
  canceled;
  attr IT is left_zeroed means
  :Def5:
  for a being Element of IT holds 0.IT + a = a;
end;

definition
  let L be non empty addLoopStr;
  canceled 2;
  attr L is add-left-invertible means
  :Def8:
  for a,b be Element of L
  ex x being Element of L st x + a = b;
  attr L is add-right-invertible means
  :Def9:
  for a,b be Element of L
  ex x being Element of L st a + x = b;
end;

definition
  let IT be non empty addLoopStr;
  canceled 2;
  attr IT is Loop-like means
  :Def12:
  IT is left_add-cancelable right_add-cancelable
  add-left-invertible add-right-invertible;
end;

registration
  cluster Loop-like -> left_add-cancelable right_add-cancelable
    add-left-invertible add-right-invertible (non empty addLoopStr);
  coherence by Def12;
  cluster left_add-cancelable right_add-cancelable
    add-left-invertible add-right-invertible ->
    Loop-like (non empty addLoopStr);
  coherence by Def12;
end;

Lm7: for L being addLoopStr st L is left_add-cancelable
for x,y,z being Element of L st x+y = x+z holds y = z by ALGSTR_0:def 3;

Lm8: for L being addLoopStr st L is right_add-cancelable
for x,y,z being Element of L st y+x = z+x holds y = z by ALGSTR_0:def 4;

theorem Th7:
  for L being non empty addLoopStr holds L is Loop-like iff
  (for a,b be Element of L ex x being Element of L st a+x=b)
  & (for a,b be Element of L ex x being Element of L st x+a=b)
  & (for a,x,y be Element of L holds a+x=a+y implies x=y)
  & (for a,x,y be Element of L holds x+a=y+a implies x=y)
proof
  let L be non empty addLoopStr;
  thus L is Loop-like implies
   (for a,b be Element of L ex x being Element of L st a+x=b) &
   (for a,b be Element of L ex x being Element of L st x+a=b) &
   (for a,x,y be Element of L holds a+x=a+y implies x=y) &
    for a,x,y being Element of L st x+a=y+a holds x=y
    by Lm7,Lm8,Def8,Def9;
  assume
A2: (for a,b be Element of L ex x being Element of L st a+x=b)
  & (for a,b be Element of L ex x being Element of L st x+a=b)
  & (for a,x,y be Element of L holds a+x=a+y implies x=y)
  & (for a,x,y be Element of L holds x+a=y+a implies x=y);
  thus L is left_add-cancelable
  proof
    let x,x,x be Element of L;
    thus thesis by A2;
  end;
  thus L is right_add-cancelable
  proof
    let x,x,x be Element of L;
    thus thesis by A2;
  end;
  thus L is add-left-invertible add-right-invertible by A2,Def8,Def9;
end;

Lm9: for a,b,c be Element of Trivial-addLoopStr
holds (a+b)+c = a+(b+c) by Th5;

Lm10: for a,b be Element of Trivial-addLoopStr holds a+b = b+a by Th5;

registration
  cluster Trivial-addLoopStr
    -> add-associative Loop-like right_zeroed left_zeroed;
  coherence by Def5,Lm1,Lm2,Lm3,Lm4,Lm5,Lm6,Lm9,Th7,RLVECT_1:def 6,def 7;
end;

registration
  cluster strict left_zeroed right_zeroed Loop-like (non empty addLoopStr);
  existence
  proof
    take Trivial-addLoopStr;
    thus thesis;
  end;
end;

definition
  mode Loop is left_zeroed right_zeroed Loop-like (non empty addLoopStr);
end;

registration
  cluster strict add-associative Loop;
  existence
  proof
    take Trivial-addLoopStr;
    thus thesis;
  end;
end;

definition
  mode AddGroup is add-associative Loop;
end;

registration
  cluster Loop-like -> add-left-invertible (non empty addLoopStr);
  coherence;
  cluster add-associative right_zeroed right_complementable
    -> left_zeroed Loop-like (non empty addLoopStr);
  coherence
  proof
    let L;
    assume
A1: L is add-associative right_zeroed right_complementable;
    then reconsider G = L as add-associative right_zeroed right_complementable
    (non empty addLoopStr);
    thus for a holds 0.L + a = a by A1,RLVECT_1:10;
    now thus for a,b ex x st a+x=b by A1,RLVECT_1:20;
      thus for a,b ex x st x+a=b
      proof
        let a,b;
        reconsider a' = a, b' = b as Element of G;
        reconsider x = b' + -a' as Element of L;
        take x;
        (b'+-a')+a' = b'+(-a'+a') by RLVECT_1:def 6
          .= b'+0.G by RLVECT_1:16
          .= b by RLVECT_1:10;
        hence thesis;
      end;
      thus (for a,x,y be Element of L holds a+x=a+y implies x=y) &
      for a,x,y be Element of L holds x+a=y+a implies x=y by A1,RLVECT_1:21;
    end;
    hence L is Loop-like by Th7;
  end;
end;

canceled;

theorem Th9:
  L is AddGroup iff (for a holds a + 0.L = a) & (for a ex x st a+x = 0.L)
  & (for a,b,c holds (a+b)+c = a+(b+c))
proof
  thus L is AddGroup implies (for a holds a + 0.L = a)
  & (for a ex x st a+x = 0.L) & (for a,b,c holds (a+b)+c = a+(b+c))
  by Th7,RLVECT_1:def 6,def 7;
  assume
A1: (for a holds a + 0.L = a) & (for a ex x st a+x = 0.L)
  & (for a,b,c holds (a+b)+c = a+(b+c));
  now thus
A2: for a be Element of L holds 0.L + a = a
    proof
      let a;
      thus 0.L+a = a+0.L by A1,Th2
        .= a by A1;
    end;
    thus for a,b be Element of L ex x being Element of L st a+x=b
    proof
      let a,b;
      consider y such that
A3:   a+y = 0.L by A1;
      take x = y+b;
      thus a+x = 0.L + b by A1,A3
        .= b by A2;
    end;
    thus for a,b be Element of L ex x being Element of L st x+a=b
    proof
      let a,b;
      consider y such that
A4:   y+a = 0.L by A1,Th3;
      take x = b+y;
      thus x+a = b + 0.L by A1,A4
        .= b by A1;
    end;
    thus for a,x,y be Element of L holds a+x=a+y implies x=y
    proof
      let a,x,y;
      consider z such that
A5:   z+a = 0.L by A1,Th3;
      assume a+x = a+y;
      then (z+a)+x = z+(a+y) by A1
        .= (z+a)+y by A1;
      hence x = 0.L + y by A2,A5
        .= y by A2;
    end;
    thus for a,x,y be Element of L holds x+a=y+a implies x=y
    proof
      let a,x,y;
      consider z such that
A6:   a+z = 0.L by A1;
      assume x+a = y+a;
      then x+(a+z) = (y+a)+z by A1
        .= y+(a+z) by A1;
      hence x = y + 0.L by A1,A6
        .= y by A1;
    end;
  end;
  hence thesis by A1,Def5,Th7,RLVECT_1:def 6,def 7;
end;

registration
  cluster Trivial-addLoopStr -> Abelian;
  coherence by Lm10,RLVECT_1:def 5;
end;

registration
  cluster strict Abelian AddGroup;
  existence
  proof
    take Trivial-addLoopStr;
    thus thesis;
  end;
end;

canceled;

theorem
  L is Abelian AddGroup iff (for a holds a + 0.L = a)
  & (for a ex x st a+x = 0.L) & (for a,b,c holds (a+b)+c = a+(b+c))
  & (for a,b holds a+b = b+a) by Th9,RLVECT_1:def 5;

registration
  cluster Trivial-multLoopStr -> non empty;
  coherence;
end;

canceled 6;

theorem Th18:
  for a,b being Element of Trivial-multLoopStr holds a = b
proof
  let a,b be Element of Trivial-multLoopStr;
  thus a = {} by CARD_1:87,TARSKI:def 1
    .= b by CARD_1:87,TARSKI:def 1;
end;

theorem
  for a,b be Element of Trivial-multLoopStr
  holds a*b = 1.Trivial-multLoopStr by Th18;

Lm11: for a be Element of Trivial-multLoopStr
holds a * 1.Trivial-multLoopStr = a by Th18;

Lm12: for a be Element of Trivial-multLoopStr
holds 1.Trivial-multLoopStr * a = a by Th18;

Lm13: for a,b be Element of Trivial-multLoopStr
ex x be Element of Trivial-multLoopStr st a*x=b
proof
  let a,b be Element of Trivial-multLoopStr;
  take x = 1_Trivial-multLoopStr;
  thus a*x = b by Th18;
end;

Lm14: for a,b be Element of Trivial-multLoopStr
ex x be Element of Trivial-multLoopStr st x*a=b
proof
  let a,b be Element of Trivial-multLoopStr;
  take x = 1_Trivial-multLoopStr;
  thus x*a = b by Th18;
end;

definition
  let IT be non empty multLoopStr;
  canceled;
  attr IT is invertible means
  :Def14:
  (for a,b be Element of IT
  ex x being Element of IT st a*x=b) & (for a,b be Element of IT
  ex x being Element of IT st x*a=b);
  canceled;
end;

notation
  let L be non empty multLoopStr;
  synonym L is cancelable for L is mult-cancelable;
end;

registration
  cluster strict well-unital invertible cancelable (non empty multLoopStr);
  existence
  proof
    Trivial-multLoopStr is well-unital invertible cancelable
    by Def14,Lm11,Lm12,Lm13,Lm14,VECTSP_1:def 16;
    hence thesis;
  end;
end;

definition
  mode multLoop is well-unital invertible cancelable (non empty multLoopStr);
end;

registration
  cluster Trivial-multLoopStr -> well-unital invertible cancelable;
  coherence by Def14,Lm11,Lm12,Lm13,Lm14,VECTSP_1:def 16;
end;

Lm15: for a,b,c be Element of Trivial-multLoopStr
holds (a*b)*c = a*(b*c) by Th18;

registration
  cluster strict associative multLoop;
  existence
  proof Trivial-multLoopStr is associative by Lm15,GROUP_1:def 4;
    hence thesis;
  end;
end;

definition
  mode multGroup is associative multLoop;
end;

reserve L for non empty multLoopStr;
reserve a,b,c,x,y,z for Element of L;

Lm16: (for a holds a * 1.L = a) & (for a ex x st a*x = 1.L)
& (for a,b,c holds (a*b)*c = a*(b*c)) implies (a*b = 1.L implies b*a = 1.L)
proof
  assume
A1: (for a holds a * 1.L = a) & (for a ex x st a*x = 1.L)
  & (for a,b,c holds (a*b)*c = a*(b*c));
  assume
A2: a*b = 1.L;
  consider x such that
A3: b * x = 1.L by A1;
  thus b*a = (b*a) * (b*x) by A1,A3
    .= ((b*a) * b) * x by A1
    .= (b * 1.L) * x by A1,A2
    .= 1.L by A1,A3;
end;

Lm17: (for a holds a * 1.L = a) & (for a ex x st a*x = 1.L)
& (for a,b,c holds (a*b)*c = a*(b*c)) implies 1.L*a = a*1.L
proof
  assume
A1: (for a holds a * 1.L = a) & (for a ex x st a*x = 1.L)
  & (for a,b,c holds (a*b)*c = a*(b*c));
  then consider x such that
A2: a * x = 1.L;
  thus 1.L*a = a * (x*a) by A1,A2
    .= a*1.L by A1,A2,Lm16;
end;

Lm18: (for a holds a * 1.L = a) & (for a ex x st a*x = 1.L)
& (for a,b,c holds (a*b)*c = a*(b*c)) implies for a ex x st x*a = 1.L
proof
  assume
A1: (for a holds a * 1.L = a) & (for a ex x st a*x = 1.L)
  & (for a,b,c holds (a*b)*c = a*(b*c));
  let a;
  consider x such that
A2: a * x = 1.L by A1;
  x*a=1.L by A1,A2,Lm16;
  hence thesis;
end;

canceled 2;

theorem Th22:
  L is multGroup iff (for a holds a * 1.L = a) & (for a ex x st a*x = 1.L)
  & (for a,b,c holds (a*b)*c = a*(b*c))
proof
  thus L is multGroup implies (for a holds a * 1.L = a)
  & (for a ex x st a*x = 1.L) & (for a,b,c holds (a*b)*c = a*(b*c))
  by Def14,GROUP_1:def 4,VECTSP_1:def 16;
  assume
A1: (for a holds a * 1.L = a) & (for a ex x st a*x = 1.L)
  & (for a,b,c holds (a*b)*c = a*(b*c));
  now thus
A2: for a be Element of L holds 1.L * a = a
    proof
      let a;
      thus 1.L*a = a*1.L by A1,Lm17
        .= a by A1;
    end;
    thus for a,b be Element of L ex x being Element of L st a*x=b
    proof
      let a,b;
      consider y such that
A3:   a*y = 1.L by A1;
      take x = y*b;
      thus a*x = 1.L * b by A1,A3
        .= b by A2;
    end;
    thus for a,b be Element of L ex x being Element of L st x*a=b
    proof
      let a,b;
      consider y such that
A4:   y*a = 1.L by A1,Lm18;
      take x = b*y;
      thus x*a = b * 1.L by A1,A4
        .= b by A1;
    end;
    thus L is left_mult-cancelable
    proof
      let a,x,y;
      consider z such that
A5:   z*a = 1.L by A1,Lm18;
      assume a*x = a*y;
      then (z*a)*x = z*(a*y) by A1
        .= (z*a)*y by A1;
      hence x = 1.L * y by A2,A5
        .= y by A2;
    end;
    thus L is right_mult-cancelable
    proof
      let a,x,y;
      consider z such that
A6:   a*z = 1.L by A1;
      assume x*a = y*a;
      then x*(a*z) = (y*a)*z by A1
        .= y*(a*z) by A1;
      hence x = y * 1.L by A1,A6
        .= y by A1;
    end;
  end;
  hence thesis by A1,Def14,GROUP_1:def 4,VECTSP_1:def 16;
end;

registration
  cluster Trivial-multLoopStr -> associative;
  coherence by Lm15,GROUP_1:def 4;
end;

Lm19: for a,b be Element of Trivial-multLoopStr holds a*b = b*a by Th18;

registration
  cluster strict commutative multGroup;
  existence
  proof Trivial-multLoopStr is commutative by Lm19,GROUP_1:def 16;
    hence thesis;
  end;
end;

canceled;

theorem
  L is commutative multGroup iff (for a holds a * 1.L = a)
  & (for a ex x st a*x = 1.L) & (for a,b,c holds (a*b)*c = a*(b*c))
  & (for a,b holds a*b = b*a) by Th22,GROUP_1:def 16;

notation
  let L be invertible cancelable (non empty multLoopStr);
  let x be Element of L;
  synonym x" for /x;
end;

registration
  let L be invertible cancelable (non empty multLoopStr);
  cluster -> left_invertible Element of L;
  coherence
  proof
    let x be Element of L;
    thus ex y being Element of L st y*x = 1.L by Def14;
  end;
end;

reserve G for multGroup;
reserve a,b,c,x for Element of G;

canceled;

theorem
  a"*a=1.G & a*(a") = 1.G
proof thus
A1: a"*a = 1.G by ALGSTR_0:def 30;
  (for a holds a * 1.G = a) & (for a ex x st a*x = 1.G)
  & (for a,b,c holds (a*b)*c = a*(b*c)) by Th22;
  hence a*a" = 1.G by A1,Lm16;
end;

definition
  canceled 3;
  let L be invertible cancelable (non empty multLoopStr);
  let a, b be Element of L;
  func a/b -> Element of L equals

  a*(b");
  correctness;
end;

definition
  canceled 3;
  func multEX_0 -> strict multLoopStr_0 equals
  multLoopStr_0 (# REAL, multreal, 0, 1 #);
  correctness;
end;

registration
  cluster multEX_0 -> non empty;
  coherence;
end;

Lm20: now
  let x, e be Element of multEX_0;
  assume
A1: e = 1;
  reconsider a = x as Real;
  thus x*e = a*1 by A1,BINOP_2:def 11
    .= x;
  thus e*x = 1*a by A1,BINOP_2:def 11
    .= x;
end;

registration
  cluster multEX_0 -> well-unital;
  coherence
  proof
    let x be Element of multEX_0;
    thus thesis by Lm20;
  end;
end;

Lm21: 0 = 0.multEX_0;

Lm22: 1 = 1_multEX_0;

canceled 5;

theorem Th32:
  for q,p be Real st q<>0 ex y be Real st p=q*y
proof
  let q,p be Real;
  reconsider y = p/q as Real;
  assume
A1: q<>0;
  take y;
  thus thesis by A1,XCMPLX_1:88;
end;

theorem Th33:
  for q,p be Real st q<>0 ex y be Real st p=y*q
proof
  let q,p be Real;
  reconsider y =p/q as Real;
  assume
A1: q<>0;
  take y;
  thus thesis by A1,XCMPLX_1:88;
end;

Lm23: for a,b be Element of multEX_0 st a<>0.multEX_0
ex x be Element of multEX_0 st a*x=b
proof
  let a,b be Element of multEX_0 such that
A1: a<>0.multEX_0;
  reconsider p=a, q=b as Real;
  consider r be Real such that
A2: p*r = q by A1,Th32;
  reconsider x=r as Element of multEX_0;
  a*x = b by A2,BINOP_2:def 11;
  hence thesis;
end;

Lm24: for a,b be Element of multEX_0 st a<>0.multEX_0
ex x be Element of multEX_0 st x*a=b
proof
  let a,b be Element of multEX_0 such that
A1: a<>0.multEX_0;
  reconsider p=a, q=b as Real;
  consider r be Real such that
A2: r*p = q by A1,Th33;
  reconsider x=r as Element of multEX_0;
  x*a = b by A2,BINOP_2:def 11;
  hence thesis;
end;

Lm25: for a,x,y be Element of multEX_0 st a<>0.multEX_0
holds a*x=a*y implies x=y
proof
  let a,x,y be Element of multEX_0 such that
A1: a<>0.multEX_0;
  assume
A2: a*x=a*y;
  reconsider aa=a, p=x, q=y as Real;
  aa*p = a*y by A2,BINOP_2:def 11
    .= aa*q by BINOP_2:def 11;
  hence thesis by A1,XCMPLX_1:5;
end;

Lm26: for a,x,y be Element of multEX_0 st a<>0.multEX_0
holds x*a=y*a implies x=y
proof
  let a,x,y be Element of multEX_0 such that
A1: a<>0.multEX_0;
  assume
A2: x*a=y*a;
  reconsider aa=a, p=x, q=y as Real;
  p*aa = y*a by A2,BINOP_2:def 11
    .= q*aa by BINOP_2:def 11;
  hence thesis by A1,XCMPLX_1:5;
end;

Lm27: for a be Element of multEX_0 holds a*0.multEX_0 = 0.multEX_0
proof
  let a be Element of multEX_0;
  reconsider aa=a as Real;
  thus a*0.multEX_0 = aa*0 by BINOP_2:def 11
    .= 0.multEX_0;
end;

Lm28: for a be Element of multEX_0 holds 0.multEX_0*a = 0.multEX_0
proof
  let a be Element of multEX_0;
  reconsider aa=a as Real;
  thus 0.multEX_0*a = 0*aa by BINOP_2:def 11
    .= 0.multEX_0;
end;

definition
  let IT be non empty multLoopStr_0;
  attr IT is almost_invertible means
  :Def24:
  (for a,b be Element of IT st a<>0.IT ex x be Element of IT st a*x=b) &
  (for a,b be Element of IT st a<>0.IT ex x be Element of IT st x*a=b);
end;

definition
  let IT be non empty multLoopStr_0;
  canceled;
  attr IT is multLoop_0-like means
  :Def26:
  IT is almost_invertible almost_cancelable
  & (for a be Element of IT holds a*0.IT = 0.IT)
  & (for a be Element of IT holds 0.IT*a = 0.IT);
end;

theorem Th34:
  for L being non empty multLoopStr_0 holds L is multLoop_0-like iff
  (for a,b be Element of L st a<>0.L ex x be Element of L st a*x=b) &
  (for a,b be Element of L st a<>0.L ex x be Element of L st x*a=b) &
  (for a,x,y be Element of L st a<>0.L holds a*x=a*y implies x=y) &
  (for a,x,y be Element of L st a<>0.L holds x*a=y*a implies x=y) &
  (for a be Element of L holds a*0.L = 0.L) &
  (for a be Element of L holds 0.L*a = 0.L)
proof
  let L be non empty multLoopStr_0;
  hereby
    assume
A1: L is multLoop_0-like;
    then
A2: L is almost_invertible almost_cancelable &
    (for a be Element of L holds a*0.L = 0.L)
    & (for a be Element of L holds 0.L*a = 0.L) by Def26;
    hence (for a,b be Element of L st a<>0.L ex x be Element of L st a*x=b) &
    (for a,b be Element of L st a<>0.L
    ex x be Element of L st x*a=b) by Def24; thus
    (for a,x,y be Element of L st a<>0.L holds a*x=a*y implies x=y)
    proof
      let a,x,y be Element of L such that
A3:   a<>0.L;
      L is almost_left_cancelable by A2;
      then a is left_mult-cancelable by A3,ALGSTR_0:def 36;
      hence a*x=a*y implies x=y by ALGSTR_0:def 20;
    end; thus
    (for a,x,y be Element of L st a<>0.L holds x*a=y*a implies x=y)
    proof
      let a,x,y be Element of L such that
A4:   a<>0.L;
      L is almost_right_cancelable by A2;
      then a is right_mult-cancelable by A4,ALGSTR_0:def 37;
      hence x*a=y*a implies x=y by ALGSTR_0:def 21;
    end;
    thus (for a be Element of L holds a*0.L = 0.L) &
    (for a be Element of L holds 0.L*a = 0.L) by A1,Def26;
  end;
  assume
A5: (for a,b be Element of L st a<>0.L ex x be Element of L st a*x=b) &
  (for a,b be Element of L st a<>0.L ex x be Element of L st x*a=b) &
  (for a,x,y be Element of L st a<>0.L holds a*x=a*y implies x=y) &
  (for a,x,y be Element of L st a<>0.L holds x*a=y*a implies x=y) &
  (for a be Element of L holds a*0.L = 0.L) &
  (for a be Element of L holds 0.L*a = 0.L);
A6: L is almost_left_cancelable
  proof
    let x being Element of L;
    assume
A7: x <> 0.L;
    let y,z be Element of L;
    assume x*y = x*z;
    hence y = z by A5,A7;
  end;
  L is almost_right_cancelable
  proof
    let x being Element of L;
    assume
A8: x <> 0.L;
    let y,z be Element of L;
    assume y*x = z*x;
    hence y = z by A5,A8;
  end;
  then L is almost_invertible almost_cancelable
  & (for a be Element of L holds a*0.L = 0.L)
  & (for a be Element of L holds 0.L*a = 0.L) by A5,A6,Def24;
  hence thesis by Def26;
end;

registration
  cluster multLoop_0-like -> almost_invertible almost_cancelable
    (non empty multLoopStr_0);
  coherence by Def26;
end;

registration
  cluster strict well-unital multLoop_0-like non degenerated
    (non empty multLoopStr_0);
  existence
  proof
    multEX_0 is well-unital multLoop_0-like non degenerated
    by Lm22,Lm23,Lm24,Lm25,Lm26,Lm27,Lm28,Th34,STRUCT_0:def 8;
    hence thesis;
  end;
end;

definition
  mode multLoop_0 is well-unital non degenerated multLoop_0-like
    (non empty multLoopStr_0);
end;

registration
  cluster multEX_0 -> well-unital multLoop_0-like;
  coherence by Lm23,Lm24,Lm25,Lm26,Lm27,Lm28,Th34;
end;

Lm29: for a,b,c be Element of multEX_0 holds (a*b)*c = a*(b*c)
proof
  let a,b,c be Element of multEX_0;
  reconsider p=a, q=b, r=c as Real;
A1: a*b = p*q by BINOP_2:def 11;
A2: b*c = q*r by BINOP_2:def 11;
  thus (a*b)*c = (p*q)*r by A1,BINOP_2:def 11
    .= p*(q*r)
    .= a*(b*c) by A2,BINOP_2:def 11;
end;

registration
  cluster strict associative non degenerated multLoop_0;
  existence
  proof multEX_0 is associative non degenerated by Lm21,Lm22,Lm29,GROUP_1:def 4
    ,STRUCT_0:def 8;
    hence thesis;
  end;
end;

definition
  mode multGroup_0 is associative non degenerated multLoop_0;
end;

reserve L for non empty multLoopStr_0;
reserve a,b,c,x,y,z for Element of L;

canceled 2;

registration
  cluster multEX_0 -> associative;
  coherence by Lm29,GROUP_1:def 4;
end;

Lm30: for a,b be Element of multEX_0 holds a*b = b*a
proof
  let a,b be Element of multEX_0;
  reconsider p=a, q=b as Real;
  thus a*b = q*p by BINOP_2:def 11
    .= b*a by BINOP_2:def 11;
end;

registration
  cluster strict commutative multGroup_0;
  existence
  proof multEX_0 is commutative non degenerated
    by Lm21,Lm22,Lm30,GROUP_1:def 16,STRUCT_0:def 8;
    hence thesis;
  end;
end;

canceled 2;

definition
  let L be almost_invertible almost_cancelable (non empty multLoopStr_0);
  let x be Element of L;
  assume
A1: x<>0.L;
  redefine func x" means
  :Def27:
  it*x = 1.L;
  compatibility
  proof
    let IT be Element of L;
    consider x1 being Element of L such that
A2: x1*x = 1.L by A1,Def24;
A3: x is left_invertible by A2,ALGSTR_0:def 27;
    x is right_mult-cancelable by A1,ALGSTR_0:def 37;
    hence thesis by A3,ALGSTR_0:def 35;
  end;
end;

reserve G for associative almost_invertible almost_cancelable well-unital
  (non empty multLoopStr_0);

reserve a,x for Element of G;

canceled;

theorem
  a<>0.G implies a"*a=1.G & a*(a") = 1.G
proof
  assume
A1: a<>0.G;
  hence
A2: a"*a = 1.G by Def27;
  consider x such that
A3: a*x = 1.G by A1,Def24;
  a"*a*x = a" * 1.G by A3,GROUP_1:def 4;
  then x = a" * 1.G by A2,VECTSP_1:def 19;
  hence thesis by A3,VECTSP_1:def 13;
end;

definition
  let L be almost_invertible almost_cancelable (non empty multLoopStr_0);
  let a, b be Element of L;
  func a/b -> Element of L equals

  a*(b");
  correctness;
end;

