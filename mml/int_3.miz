:: The Ring of Integers, Euclidean Rings and Modulo Integers
::  by Christoph Schwarzweller
::
:: Received February 4, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies BINOP_1, INT_1, FUNCT_1, VECTSP_1, RELAT_1, ARYTM_1, GR_CY_1,
      FUNCT_7, RLVECT_1, VECTSP_2, LATTICES, ABSVALUE, EUCLID, NAT_1, FUNCSDOM,
      GCD_1, ARYTM_3, INT_2, MCART_1, ORDINAL2, NAT_LAT, INT_3, ARYTM, GROUP_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, ORDINAL2, NUMBERS, XCMPLX_0,
      RLVECT_1, MCART_1, RELAT_1, FUNCT_1, BINOP_2, STRUCT_0, FUNCT_2, GCD_1,
      GROUP_1, VECTSP_1, VECTSP_2, FUNCSDOM, BINOP_1, EUCLID, GR_CY_1, INT_1,
      FUNCT_7, NEWTON, INT_2, NAT_1, XXREAL_0;
 constructors DOMAIN_1, GROUP_2, REAL_1, GCD_1, NAT_1, EUCLID, GR_CY_1,
      FUNCT_7, SEQ_1, BINOP_2, INT_2, XXREAL_0;
 registrations STRUCT_0, FUNCT_1, XREAL_0, INT_1, RELSET_1, GCD_1, SEQ_1,
      MEMBERED, ORDINAL2, NAT_1, VECTSP_1, XXREAL_0;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions RLVECT_1, STRUCT_0, GROUP_1, VECTSP_1, VECTSP_2, BINOP_1;
 theorems TARSKI, BINOP_1, FUNCT_1, FUNCT_2, VECTSP_1, INT_1, RELAT_1, GCD_1,
      RLVECT_1, REAL_1, EUCLID, ABSVALUE, GR_CY_1, FUNCT_7, NAT_1, MCART_1,
      INT_2, RELSET_1, XREAL_0, ORDINAL2, XCMPLX_0, XCMPLX_1, NUMBERS, BINOP_2,
      GROUP_1, XREAL_1, COMPLEX1, NEWTON, XXREAL_0;
 schemes NAT_1, BINOP_1, LMOD_7, BINOP_2;

begin

definition
redefine func multint means :Def1:
 for a,b being Element of INT holds it.(a,b) = multreal.(a,b);
 compatibility
  proof let b be BinOp of INT;
   hereby assume
A1:   b = multint;
    let i1,i2 be Element of INT;
     i1 in INT & i2 in INT;
     then
A2:   i1 in REAL & i2 in REAL by NUMBERS:15;
    thus b.(i1,i2) = i1 * i2 by A1,BINOP_2:def 22
        .= multreal.(i1,i2) by A2,BINOP_2:def 11;
   end;
   assume
A3:  for i1,i2 being Element of INT holds
      b.(i1,i2) = multreal.(i1,i2);
    now let i1,i2 be Element of INT;
      i1 in INT & i2 in INT;
      then
A4:   i1 in REAL & i2 in REAL by NUMBERS:15;
     thus b.(i1,i2) = multreal.(i1,i2) by A3
        .= i1 * i2 by A4,BINOP_2:def 11
        .= multint.(i1,i2) by BINOP_2:def 22;
    end;
   hence b = multint by BINOP_1:2;
  end;
end;

definition
 redefine func compint means
    for a being Element of INT holds it.(a) = compreal.(a);
 compatibility
  proof let b be UnOp of INT;
   hereby assume
A1:   b = compint;
    let i be Element of INT;
     i in INT;
     then
A2:   i in REAL by NUMBERS:15;
    thus b.i = -i by A1,BINOP_2:def 19
        .= compreal.i by A2,BINOP_2:def 7;
   end;
   assume
A3:  for i being Element of INT holds
      b.i = compreal.i;
    now let i be Element of INT;
      i in INT;
      then
A4:   i in REAL by NUMBERS:15;
     thus b.i = compreal.i by A3
        .= -i by A4,BINOP_2:def 7
        .= compint.i by BINOP_2:def 19;
    end;
   hence b = compint by FUNCT_2:113;
  end;
end;

definition
func INT.Ring -> doubleLoopStr equals
 doubleLoopStr(#INT,addint,multint,In (1,INT),In (0,INT)#);
coherence;
end;

Lm1: for x being Element of INT.Ring holds x in REAL
    proof
     let x be Element of INT.Ring;
        x in INT;
     hence thesis by NUMBERS:15;
     end;

registration
 cluster INT.Ring -> strict non empty;
coherence
  proof
    thus INT.Ring is strict;
    thus the carrier of INT.Ring is non empty;
  end;
end;

set M = INT.Ring;

Lm2:0 = 0.M
proof
A1: 0 in INT by INT_1:def 2;
thus 0.M = the Zero of INT.Ring
    .= 0 by A1,FUNCT_7:def 1;
end;

Lm3:for a,b being Element of INT.Ring
for a',b' being Integer st a' = a & b' = b holds
a * b = a' * b'
proof
let a,b be Element of INT.Ring;
let a',b' be Integer;
assume A1: a' = a & b' = b;
reconsider a,b as Element of INT;
A2: a is Element of REAL & b is Element of REAL by XREAL_0:def 1;
   multint.(a,b) = multreal.(a,b) by Def1
                .= a' * b' by A1,A2,BINOP_2:def 11;
hence thesis;
end;

Lm4:
for e, h being Element of M st e = 1 holds
h*e=h & e*h=h
proof
  let e, h be Element of M such that
A1: e = 1;
  reconsider a=h, b=e as Element of INT;
  thus h*e = a*1 by A1,Lm3
  .= h;
  thus e*h = 1*a by A1,Lm3
  .= h;
end;

registration
 cluster INT.Ring -> unital;
coherence
proof
  reconsider e = 1 as Element of M by INT_1:def 1;
  take e;
  thus thesis by Lm4;
end;
end;

Lm5:
1.M = 1
proof
  reconsider e = 1 as Element of M by INT_1:def 1;
  for x being Element of M holds x*e=x & e*x=x by Lm4;
  hence thesis by GROUP_1:def 5;
end;

registration
 cluster INT.Ring -> Abelian add-associative right_zeroed right_complementable
                     distributive commutative associative
                     domRing-like non degenerated;
coherence
  proof
    hereby
     let a,b be Element of M;
     reconsider a' = a as Element of REAL by Lm1;
     reconsider b' = b as Element of REAL by Lm1;
     thus a + b = (the add of M).[a,b]
          .= (the add of M).(a,b)
          .= addreal.(a,b) by GR_CY_1:def 2
          .= a' + b' by BINOP_2:def 9
          .= addreal.(b,a) by BINOP_2:def 9
          .= addint.(b,a) by GR_CY_1:def 2
          .= (the add of M).[b,a]
          .= b + a;
    end;
    hereby
     let a,b,c be Element of M;
     A1: a + b = (the add of M).[a,b]
               .= (the add of M).(a,b)
               .= addreal.(a,b) by GR_CY_1:def 2;
     A2: (a + b) + c = (the add of M).[(a+b),c]
                     .= addint.((a+b),c)
                     .= addreal.(addreal.(a,b),c) by A1,GR_CY_1:def 2;
     A3: b + c = (the add of M).[b,c]
               .= (the add of M).(b,c)
               .= addreal.(b,c) by GR_CY_1:def 2;
     A4: a + (b + c) = (the add of M).[a,(b+c)]
                     .= addint.(a,(b+c))
                     .= addreal.(a,addreal.(b,c)) by A3,GR_CY_1:def 2;
     reconsider a' = a, b' = b, c' = c as Element of REAL by Lm1;
           addreal.(addreal.(a',b'),c')
      = addreal.(a' + b',c') by BINOP_2:def 9
     .= (a' + b') + c' by BINOP_2:def 9
     .= a' + (b' + c')
     .= addreal.(a',b' + c') by BINOP_2:def 9
     .= addreal.(a',addreal.(b',c')) by BINOP_2:def 9;
     hence (a + b) + c = a + (b + c) by A2,A4;
    end;
    hereby
     let a be Element of M;
     A5: 0 in INT by INT_1:def 2;
     A6: a + 0.M = (the add of M).[a,0.M]
                 .= addint.(a,0.M)
                 .= addreal.(a,0.M) by GR_CY_1:def 2
                 .= addreal.(a,the Zero of M)
                 .= addreal.(a,0) by A5,FUNCT_7:def 1;
     reconsider a' = a as Element of REAL by Lm1;
     reconsider t = 0 as Element of REAL;
        addreal.(a',t) = a' + t by BINOP_2:def 9
                   .= a;
     hence a + 0.M = a by A6;
    end;
    hereby
     let a be Element of M;
     reconsider a' = a as Integer by INT_1:def 2;
     reconsider v = -a' as Element of M by INT_1:def 2;
     reconsider v' = v as Integer;
     take v;
     thus a + v = (the add of M).[a,v]
         .= addint.(a,v)
         .= a'+v' by GR_CY_1:14
         .= 0.M by Lm2;
    end;
 A7: for a,b being Element of M holds
     a * b = b * a
     proof
     let a,b be Element of M;
     reconsider a' = a as Element of REAL by Lm1;
     reconsider b' = b as Element of REAL by Lm1;
        a * b = (the mult of M).(a,b)
          .= multreal.(a,b) by Def1
          .= a' * b' by BINOP_2:def 11
          .= multreal.(b,a) by BINOP_2:def 11
          .= (the mult of M).(b,a) by Def1
          .= b * a;
     hence thesis;
     end;
 A8: for a,b,c being Element of M holds
     a * (b + c) = a * b + a * c
     proof
     let a,b,c be Element of M;
     A9: b + c = (the add of M).[b,c]
               .= (the add of M).(b,c)
               .= addreal.(b,c) by GR_CY_1:def 2;
     A10: a * (b + c) = (the mult of M).(a,(b+c))
                     .= multreal.(a,addreal.(b,c)) by A9,Def1;
     A11: a * b = (the mult of M).(a,b)
               .= multreal.(a,b) by Def1;
     A12: a * c = (the mult of M).(a,c)
               .= multreal.(a,c) by Def1;
     A13: a * b + a * c = (the add of M).[(a*b),(a*c)]
                       .= (the add of M).((a*b),(a*c))
                       .= addreal.(multreal.(a,b),multreal.(a,c)) by A11,A12,
GR_CY_1:def 2;
     reconsider a,b,c as Element of REAL by Lm1;
     reconsider t = multreal.(a,b) as Element of REAL;
     reconsider t' = multreal.(a,c) as Element of REAL;
           multreal.(a,addreal.(b,c))
      = multreal.(a,b+c) by BINOP_2:def 9
     .= a * (b + c) by BINOP_2:def 11
     .= a * b + a * c
     .= t + (a * c) by BINOP_2:def 11
     .= t + t' by BINOP_2:def 11
     .= addreal.(multreal.(a,b),multreal.(a,c)) by BINOP_2:def 9;
     hence thesis by A10,A13;
     end;
    hereby
     let a,b,c be Element of M;
     thus a*(b+c) = a*b+a*c by A8;
     thus (b + c) * a = a * (b + c) by A7
                     .= a * b + a * c by A8
                     .= b * a + a * c by A7
                     .= b * a + c * a by A7;
    end;
     thus for x,y be Element of M holds x*y = y*x by A7;
    hereby
     let a,b,c be Element of M;
     A14: a * b = (the mult of M).(a,b)
               .= multreal.(a,b) by Def1;
     A15: (a * b) * c = (the mult of M).((a*b),c)
                     .= multreal.(multreal.(a,b),c) by A14,Def1;
     A16: b * c = (the mult of M).(b,c)
               .= multreal.(b,c) by Def1;
     A17: a * (b * c) = (the mult of M).(a,(b*c))
                     .= multreal.(a,multreal.(b,c)) by A16,Def1;
     reconsider a' = a, b' = b, c' = c as Element of REAL by Lm1;
           multreal.(multreal.(a,b),c)
      = multreal.(a' * b',c') by BINOP_2:def 11
     .= (a' * b') * c' by BINOP_2:def 11
     .= a' * (b' * c')
     .= multreal.(a',b' * c') by BINOP_2:def 11
     .= multreal.(a',multreal.(b',c')) by BINOP_2:def 11;
     hence a*b*c = a*(b*c) by A15,A17;
    end;
    hereby
      let a,b be Element of M;
      assume A18: a * b = 0.M;
      A19: a * b = (the mult of M).(a,b)
                .= multreal.(a,b) by Def1;
      reconsider a' = a as Element of REAL by Lm1;
      reconsider b' = b as Element of REAL by Lm1;
              multreal.(a,b) = a' * b' by BINOP_2:def 11;
      hence a = 0.M or b = 0.M by A18,A19,Lm2,XCMPLX_1:6;
    end;
      A20: 1 in INT & 0 in INT by INT_1:def 2;
      A21: 1.M = 1 by Lm5;
         0.M = the Zero of M
         .= 0 by A20,FUNCT_7:def 1;
    hence 0.M <> 1.M by A21;
  end;
end;

Lm6:for a being Element of INT.Ring
for a' being Integer st a' = a holds -(a') = -a
proof
let a be Element of INT.Ring;
let a' be Integer;
assume A1: a' = a;
reconsider b' = -a' as Element of M by INT_1:def 2;
reconsider c = b' as Integer;
    b' + a = (the add of M).[b',a]
       .= (the add of M).(b',a)
       .= c + a' by A1,GR_CY_1:14
       .= 0.M by Lm2;
 hence thesis by RLVECT_1:19;
end;

definition
let a,b be Element of INT.Ring;
pred a <= b means :Def4:
 ex a',b' being Integer st a' = a & b' = b & a' <= b';
reflexivity
 proof
 let a be Element of INT.Ring;
    ex k being Nat st a = k or a = - k by INT_1:def 1;
 hence thesis;
 end;
connectedness
 proof
 let a,b be Element of INT.Ring;
 assume A1: not ex a',b' being Integer st a' = a & b' = b & a' <= b';
 consider a',b' being Element of INT such that A2: a' = a & b' = b;
    not a' <= b' by A1,A2;
 hence ex b',a' being Integer st b' = b & a' = a & b' <= a' by A2;
 end;
end;

notation
let a,b be Element of INT.Ring;
synonym b >= a for a <= b; antonym b < a for a <= b; antonym a > b for
 a <= b; end;

Lm7:for a,b being Element of INT.Ring holds
a < b iff (a <= b & a <> b)
proof
let a,b be Element of INT.Ring;
   now assume A1: a <= b & a <> b;
   then consider a',b' being Integer such that
   A2: a' = a & b' = b & a' <= b' by Def4;
      not(ex b',a' being Integer st b' = b & a' = a & b' <= a') by A1,A2,
REAL_1:def 5;
   hence a < b by Def4;
end;
hence thesis;
end;

definition
let a be Element of INT.Ring;
func abs(a) -> Element of INT.Ring equals :Def5:
 a if a >= 0.INT.Ring
 otherwise - a;
correctness;
end;

definition
func absint -> Function of the carrier of INT.Ring,NAT means :Def6:
 for a being Element of INT.Ring holds
 it.a = absreal.(a);
existence
 proof
    dom(absreal) = REAL by FUNCT_2:def 1;
 then A1: dom((absreal)|INT) = the carrier of INT.Ring
 by NUMBERS:15,RELAT_1:91;
    for y being set holds y in rng((absreal)|INT) implies y in NAT
   proof
   let y be set;
   assume y in rng((absreal)|INT);
   then consider x being set such that
   A2: [x,y] in (absreal)|INT by RELAT_1:def 5;
   A3: ((absreal)|INT).x = y by A2,FUNCT_1:8;
   A4: x in dom((absreal)|INT) by A2,RELAT_1:def 4;
   then reconsider x as Integer by A1,INT_1:def 2;
   A5: ((absreal)|INT).x = (absreal).x by A1,A4,FUNCT_1:72;
      now per cases;
   case A6: 0 <= x;
           ((absreal)|INT).x = abs(x) by A5,EUCLID:def 2
                         .= x by A6,ABSVALUE:def 1;
        hence ((absreal)|INT).x is Nat by A6,INT_1:16;
   end;
   case A7: not(0 <= x);
        A8: ((absreal)|INT).x = abs(x) by A5,EUCLID:def 2
                             .= -x by A7,ABSVALUE:def 1;
           -0 <= -x by A7,XREAL_1:26;
        hence ((absreal)|INT).x is Nat by A8,INT_1:16;
   end;
   end;
   hence thesis by A3;
   end;
 then rng((absreal)|INT) c= NAT by TARSKI:def 3;
 then reconsider f = (absreal)|INT as
   Function of the carrier of INT.Ring,NAT by A1,FUNCT_2:def 1,RELSET_1:11;
 take f;
 thus thesis by FUNCT_1:72;
 end;
uniqueness
 proof
   deffunc F(Element of INT.Ring)=absreal.($1);
   thus for f1,f2 being Function of the carrier of INT.Ring,NAT st
   (for x being Element of INT.Ring holds f1.x = F(x)) &
   (for x being Element of INT.Ring holds f2.x = F(x))
  holds f1 = f2 from BINOP_2:sch 1;
 end;
end;

theorem
Th1:for a being Element of INT.Ring holds absint.a = abs(a)
proof
let a be Element of INT.Ring;
reconsider a' = a as Integer by INT_1:def 2;
A1: absint.a = absreal.a' by Def6
            .= abs(a') by EUCLID:def 2;
  A2: 0 in INT by INT_1:def 2;
   now per cases;
case A3: a >= 0.INT.Ring;
  then A4: abs(a) = a by Def5;
  consider c,d being Integer such that
  A5: c = 0.INT.Ring & d = a & c <= d by A3,Def4;
     0 = In (0,INT) by A2,FUNCT_7:def 1
   .= c by A5;
  hence absint.(a) = abs(a) by A1,A4,A5,ABSVALUE:def 1;
end;
case A6: not a >= 0.INT.Ring;
     ex c',d' being Integer st c' = 0.INT.Ring & d' = a
    proof
    take 0,a';
    thus thesis by Lm2;
    end;
  then consider c',d' being Integer such that
  A7: c' = 0.INT.Ring & d' = a;
  A8: not 0 <= d' by A6,A7,Def4,Lm2;
     absint.(a) = absreal.(d') by A7,Def6
            .= abs(d') by EUCLID:def 2
            .= - d' by A8,ABSVALUE:def 1
            .= - a by A7,Lm6
            .= abs(a) by A6,Def5;
  hence thesis;
end;
end;
hence thesis;
end;

Lm8: for a being Integer holds a = 0 or absreal.a >= 1
proof
let a be Integer;
assume A1: a <> 0;
   now per cases;
  case A2: 0 <= a;
  then reconsider a as Nat by INT_1:16;
  A3: absreal.(a) = abs((a)) by EUCLID:def 2
               .= a by ABSVALUE:def 1;
    0 + 1 < a + 1 by A1,A2,XREAL_1:8;
  hence thesis by A3,NAT_1:38;
  end;
  case A4: a < 0;
  A5: absreal.(a) = abs((a)) by EUCLID:def 2
               .= -a by A4,ABSVALUE:def 1;
     a <= -1 by A4,INT_1:21;
  then -(-1) <= -a by XREAL_1:26;
  hence thesis by A5;
  end;
  end;
hence thesis;
end;

Lm9:for a,b being Element of INT.Ring
for a',b' being Integer st a' = a & b' = b holds
a + b = a' + b'
proof
let a,b be Element of INT.Ring;
let a',b' be Integer;
assume A1: a' = a & b' = b;
reconsider a,b as Element of INT;
A2: a is Element of REAL & b is Element of REAL by XREAL_0:def 1;
       addint.(a,b) = addreal.(a,b) by GR_CY_1:def 2
               .= a' + b' by A1,A2,BINOP_2:def 9;
hence thesis;
end;

Lm10:for a,b being Element of INT.Ring
  st b <> 0.INT.Ring
  for b' being Integer st b' = b holds
  0 <= b' implies
     ex q,r being Element of INT.Ring st
     (a = q * b + r & (r = 0.INT.Ring or absint.r < absint.b))
  proof
  let a,b be Element of M;
  assume A1: b <> 0.M;
  let b' be Integer;
  assume A2: b' = b;
  assume A3: 0 <= b';
  reconsider a' = a as Integer by INT_1:def 2;
  defpred P[Nat] means ex s being Integer st $1 = a' - s * b';
  A4: ex k being Nat st P[k]
     proof
        now per cases;
     case 0 <= a';
       then reconsider a' as Nat by INT_1:16;
          a' - 0 * b' = a';
       hence thesis;
     end;
     case A5: a' < 0;
       A6: a' - a' * b' = (-a') * (b' - 1);
          0 < -a' by A5,XREAL_1:60;
       then reconsider n = -a' as Nat by INT_1:16;
         1 + 0 <= b' by A1,A2,A3,Lm2,INT_1:20;
       then 1 - 1 <= b' - 1 by XREAL_1:11;
       then reconsider m = b' - 1 as Nat by INT_1:16;
          n * m is Nat;
       hence thesis by A6;
     end;
     end;
     hence thesis;
     end;
     ex k being Nat st P[k] &
  for n being Nat st P[n] holds k <= n from NAT_1:sch 5(A4);
  then consider k' being Nat such that
  A7: ex s being Integer st k' = a' - s * b' &
       for n being Nat st ex s' being Integer st n = a' - s' * b'
       holds k' <= n;
  consider l' being Integer such that
  A8: k' = a' - l' * b' by A7;
  A9: a' = l' * b' + k' by A8;
  A10: k' = 0 or k' < b'
      proof
      assume k' <> 0;
      assume b' <= k';
      then reconsider k = k' - b' as Nat by INT_1:18;
      A11: k' > k
        proof
        assume k' <= k;
        then consider x being Nat such that A12: k = k' + x by NAT_1:28;
           k' + x = k' + -b' by A12;
        then A13: x = - b';
        reconsider b' as Nat by A3,INT_1:16;
        A14: 0 < b' by A1,A2,Lm2;
           - x = b' by A13;
        then x < 0 by A14;
        hence contradiction;
        end;
         k' - b' = a' - (l' + 1) * b' by A8;
      hence thesis by A7,A11;
      end;
  reconsider k = k',l = l' as Element of M by INT_1:def 2;
  consider d being Element of M such that A15: d = l * b;
  consider d' being Integer such that A16: d' = l' * b';
     d = d' by A2,A15,A16,Lm3;
  then A17: k + l * b = a by A9,A15,A16,Lm9;
     k = 0.M or absint.k < absint.b
       proof
       assume A18: k <> 0.M;
       A19: absint.k = absreal.(k) by Def6
                   .= abs(k') by EUCLID:def 2
                   .= k' by ABSVALUE:def 1;
       reconsider b' as Nat by A3,INT_1:16;
          absint.b = absreal.(b') by A2,Def6
               .= abs(b') by EUCLID:def 2
               .= b' by ABSVALUE:def 1;
       hence thesis by A10,A18,A19,Lm2;
       end;
  hence thesis by A17;
  end;

Lm11:for a,b being Element of INT.Ring
  st b <> 0.INT.Ring
  for b' being Integer st b' = b holds
  0 <= b' implies
     ex q,r being Element of INT.Ring st
     a = q * b + r & 0.INT.Ring <= r & r < abs(b)
  proof
  let a,b be Element of M;
  assume A1: b <> 0.M;
  let b' be Integer;
  assume A2: b' = b;
  assume A3: 0 <= b';
  reconsider a' = a as Integer by INT_1:def 2;
  defpred P[Nat] means ex s being Integer st $1 = a' - s * b';
  A4: ex k being Nat st P[k]
     proof
        now per cases;
     case 0 <= a';
       then reconsider a' as Nat by INT_1:16;
          a' - 0 * b' = a';
       hence thesis;
     end;
     case A5: a' < 0;
       A6: a' - a' * b' = (-a') * (b' - 1);
          0 < -a' by A5,XREAL_1:60;
       then reconsider n = -a' as Nat by INT_1:16;
         1 + 0 <= b' by A1,A2,A3,Lm2,INT_1:20;
       then 1 - 1 <= b' - 1 by XREAL_1:11;
       then reconsider m = b' - 1 as Nat by INT_1:16;
          n * m is Nat;
       hence thesis by A6;
     end;
     end;
     hence thesis;
     end;
     ex k being Nat st P[k] &
  for n being Nat st P[n] holds k <= n from NAT_1:sch 5(A4);
  then consider k' being Nat such that
  A7: ex s being Integer st k' = a' - s * b' &
       for n being Nat st ex s' being Integer st n = a' - s' * b'
       holds k' <= n;
  consider l' being Integer such that
  A8: k' = a' - l' * b' by A7;
  A9: a' = l' * b' + k' by A8;
  A10: k' = 0 or k' < b'
      proof
      assume k' <> 0;
      assume b' <= k';
      then reconsider k = k' - b' as Nat by INT_1:18;
      A11: k' > k
        proof
        assume k' <= k;
        then consider x being Nat such that A12: k = k' + x by NAT_1:28;
           k' + x = k' + -b' by A12;
        then A13: x = - b';
        reconsider b' as Nat by A3,INT_1:16;
        A14: 0 < b' by A1,A2,Lm2;
           - x = b' by A13;
        then x < 0 by A14;
        hence contradiction;
        end;
         k' - b' = a' - (l' + 1) * b' by A8;
      hence thesis by A7,A11;
      end;
  reconsider k = k',l = l' as Element of M by INT_1:def 2;
  consider d being Element of M such that A15: d = l * b;
  consider d' being Integer such that A16: d' = l' * b';
     d = d' by A2,A15,A16,Lm3;
  then A17: k + l * b = a by A9,A15,A16,Lm9;
     0.M <= k & k < abs(b)
       proof
       reconsider k' as Nat;
       reconsider b' as Nat by A3,INT_1:16;
       A18: absint.b = b'
           proof
              absint.b = absreal.b' by A2,Def6
                   .= abs(b') by EUCLID:def 2
                   .= b' by ABSVALUE:def 1;
           hence thesis;
           end;
       then A19: abs(b) = b' by Th1;
       A20: abs(b) <> 0.M by A1,A2,A18,Th1;
          now per cases by A10;
       case A21: k' = 0;
         then k' <= b';
         then k <= abs(b) by A19,Def4;
         hence thesis by A20,A21,Lm2,Lm7;
       end;
       case A22: k' < b';
         then k <= abs(b) by A19,Def4;
         hence thesis by A19,A22,Def4,Lm2,Lm7;
       end;
       end;
       hence thesis;
       end;
  hence thesis by A17;
  end;

theorem
Th2:for a,b,q1,q2,r1,r2 being Element of INT.Ring
st b <> 0.INT.Ring &
   a = q1 * b + r1 & 0.INT.Ring <= r1 & r1 < abs(b) &
   a = q2 * b + r2 & 0.INT.Ring <= r2 & r2 < abs(b)
holds q1 = q2 & r1 = r2
 proof
 let a,b,q1,q2,r1,r2 be Element of INT.Ring;
 assume A1: b <> 0.INT.Ring &
        a = q1 * b + r1 & 0.INT.Ring <= r1 & r1 < abs(b) &
        a = q2 * b + r2 & 0.INT.Ring <= r2 & r2 < abs(b);
 set I = INT.Ring;
 reconsider a' = a as Integer by INT_1:def 2;
 reconsider b' = b as Integer by INT_1:def 2;
 reconsider q1' = q1 as Integer by INT_1:def 2;
 reconsider q2' = q2 as Integer by INT_1:def 2;
 reconsider r1' = r1 as Integer by INT_1:def 2;
 reconsider r2' = r2 as Integer by INT_1:def 2;
   A2: a' = q1' * b' + r1' & a' = q2' * b' + r2'
     proof
     consider d being Element of I such that A3: d = q1 * b;
     consider d' being Integer such that A4: d' = q1' * b';
     consider e being Element of I such that A5: e = q2 * b;
     consider e' being Integer such that A6: e' = q2' * b';
     A7: d = d' by A3,A4,Lm3;
        e = e' by A5,A6,Lm3;
     hence thesis by A1,A3,A4,A5,A6,A7,Lm9;
     end;
 then A8: q1' * b' = a' - r1' & q2' * b' = a' - r2';
 A9: now per cases;
 case A10: 0 <= r1' - r2';
   A11: (q2' - q1') * b' = q2' * b' + (-q1') * b'
                       .= a' - r2' + -(a' - r1') by A8
                       .= r1' - r2';
      now per cases;
   case 0 = r1' - r2';
     then A12: q2' - q1' = 0 or b' = 0 by A11,XCMPLX_1:6;
        q2' = (q2' - q1') + q1'
        .= q1' by A1,A12,Lm2;
     hence q1 = q2;
   end;
   case 0 <> r1' - r2';
     then 0 <> q2' - q1' by A11;
     then A13: absreal.(q2' - q1') >= 1 by Lm8;
     A14: absreal.(q2' - q1') * absreal.b' >= absreal.b'
          proof
             absreal.b' = absint.b by Def6;
          then reconsider c = absreal.b' as Nat;
          reconsider d' = q2' - q1' as Integer;
          reconsider e = q2 + -q1 as Element of I;
          A15: -(q1') = -q1 by Lm6;
             d' = q2' + -q1'
               .= e by A15,Lm9;
          then absreal.d' = absint.e by Def6;
          then reconsider d = absreal.d' as Nat;
             d * c >= 1 * c by A13,NAT_1:20;
          hence thesis;
          end;
     consider i1,i2 being Integer such that
     A16: i1 = 0.I & i2 = r2 & i1 <= i2 by A1,Def4;
        -r2' <= -0 by A16,Lm2,XREAL_1:26;
     then r1' + -r2' <= r1' + 0 by XREAL_1:8;
     then A17: r1' - r2' <= r1';
     A18: abs(b) = absint.b by Th1 .= absreal.b by Def6;
     consider u,v being Integer such that
     A19: u = r1 & v = abs(b) & u <= v by A1,Def4;
     A20: r1' < absreal.b' by A1,A18,A19,REAL_1:def 5;
        r1' - r2' = abs(((q2' - q1') * b')) by A10,A11,ABSVALUE:def 1
              .= abs((q2' - q1')) * abs(b') by COMPLEX1:151
              .= absreal.(q2' - q1') * abs(b') by EUCLID:def 2
              .= absreal.(q2' - q1') * absreal.b' by EUCLID:def 2;
     hence q1 = q2 by A14,A17,A20,XXREAL_0:2;
   end;
   end;
   hence q1 = q2;
 end;
 case A21: r1' - r2' < 0;
   then A22: -(r1' - r2') > 0 by XREAL_1:60;
   A23: -(r1' - r2') = r2' - r1';
   A24: (q1' - q2') * b' = q1' * b' + (-q2') * b'
                       .= a' - r1' + -(a' - r2') by A2
                       .= r2' - r1';
   then 0 <> q1' - q2' by A21,A23,XREAL_1:60;
   then A25: absreal.(q1' - q2') >= 1 by Lm8;
   A26: absreal.(q1' - q2') * absreal.b' >= absreal.b'
        proof
           absreal.b' = absint.b by Def6;
        then reconsider c = absreal.b' as Nat;
        reconsider d' = q1' - q2' as Integer;
        reconsider e = q1 + -q2 as Element of I;
        A27: -(q2') = -q2 by Lm6;
           d' = q1' + -q2'
             .= e by A27,Lm9;
        then absreal.d' = absint.e by Def6;
        then reconsider d = absreal.d' as Nat;
           d * c >= 1 * c by A25,NAT_1:20;
        hence thesis;
        end;
   consider i1,i2 being Integer such that
   A28: i1 = 0.I & i2 = r1 & i1 <= i2 by A1,Def4;
      -r1' <= -0 by A28,Lm2,XREAL_1:26;
   then r2' + -r1' <= r2' + 0 by XREAL_1:8;
   then A29: r2' - r1' <= r2';
   A30: abs(b) = absint.b by Th1 .= absreal.b by Def6;
     consider u,v being Integer such that
     A31: u = r2 & v = abs(b) & u <= v by A1,Def4;
   A32: r2' < absreal.b' by A1,A30,A31,REAL_1:def 5;
      r2' - r1' = abs(((q1' - q2') * b')) by A22,A24,ABSVALUE:def 1
            .= abs((q1' - q2')) * abs(b') by COMPLEX1:151
            .= absreal.(q1' - q2') * abs(b') by EUCLID:def 2
            .= absreal.(q1' - q2') * absreal.b' by EUCLID:def 2;
   hence q1 = q2 by A26,A29,A32,XXREAL_0:2;
   end;
   end;
    r1 = r1 + 0.INT.Ring by RLVECT_1:10
   .= r1 + (q1 * b + -(q1 * b)) by RLVECT_1:16
   .= (q2 * b + r2) + -(q2 * b) by A1,A9,RLVECT_1:def 6
   .= r2 + (q2 * b + -(q2 * b)) by RLVECT_1:def 6
   .= r2 + 0.INT.Ring by RLVECT_1:16
   .= r2 by RLVECT_1:10;
 hence thesis by A9;
end;

definition
let a,b be Element of INT.Ring;
assume A1:b <> 0.INT.Ring;
func a div b -> Element of INT.Ring means :Def7:
 ex r being Element of INT.Ring st
 a = it * b + r & 0.INT.Ring <= r & r < abs(b);
existence
  proof
  set I = INT.Ring;
  reconsider b' = b as Integer by INT_1:def 2;
     now per cases;
  case 0 <= b';
  hence thesis by A1,Lm11;
  end;
  case A2: b' < 0;
  then A3: 0 < -b' by XREAL_1:60;
  reconsider c = -b' as Element of I by INT_1:def 2;
  consider q,r being Element of I such that
  A4: a = q * c + r & 0.I <= r & r < abs(c) by A3,Lm2,Lm11;
  reconsider t = -q as Element of I;
  reconsider t' = t, q' = q, r' = r as Integer by INT_1:def 2;
  reconsider c' = c as Integer;
  consider d being Element of I such that A5: d = t * b;
  consider d' being Integer such that A6: d' = t' * b';
  consider e being Element of I such that A7: e = q * c;
  consider e' being Integer such that A8: e' = q' * c';
  A9: d = d' by A5,A6,Lm3;
  A10: e = e' by A7,A8,Lm3;
  A11: t * b + r = d' + r' by A5,A9,Lm9
               .= (-q') * b' + r' by A6,Lm6
               .= q' * (-b') + r'
               .= a by A4,A7,A8,A10,Lm9;
     0.I <= r & r < abs(b)
    proof
       absint.c = absreal.c by Def6
            .= abs((-b')) by EUCLID:def 2
            .= -b' by A3,ABSVALUE:def 1
            .= abs((b')) by A2,ABSVALUE:def 1
            .= absreal.b' by EUCLID:def 2
            .= absint.b by Def6
            .= abs(b) by Th1;
    hence thesis by A4,Th1;
    end;
  hence thesis by A11;
  end;
  end;
  hence thesis;
  end;
uniqueness by A1,Th2;
end;

definition
let a,b be Element of INT.Ring;
assume A1:b <> 0.INT.Ring;
func a mod b -> Element of INT.Ring means :Def8:
 ex q being Element of INT.Ring st
 a = q * b + it & 0.INT.Ring <= it & it < abs(b);
existence
  proof
  set I = INT.Ring;
  reconsider b' = b as Integer by INT_1:def 2;
     now per cases;
  case 0 <= b';
  then ex q,r being Element of INT.Ring st
   a = q * b + r & 0.INT.Ring <= r & r < abs(b) by A1,Lm11;
  hence thesis;
  end;
  case A2: b' < 0;
  then A3: 0 < -b' by XREAL_1:60;
  reconsider c = -b' as Element of I by INT_1:def 2;
  consider q,r being Element of I such that
  A4: a = q * c + r & 0.I <= r & r < abs(c) by A3,Lm2,Lm11;
  reconsider t = -q as Element of I;
  reconsider t' = t as Integer by INT_1:def 2;
  reconsider q' = q as Integer by INT_1:def 2;
  reconsider r' = r as Integer by INT_1:def 2;
  reconsider c' = c as Integer;
  consider d being Element of I such that A5: d = t * b;
  consider d' being Integer such that A6: d' = t' * b';
  consider e being Element of I such that A7: e = q * c;
  consider e' being Integer such that A8: e' = q' * c';
  A9: d = d' by A5,A6,Lm3;
  A10: e = e' by A7,A8,Lm3;
  A11: t * b + r = d' + r' by A5,A9,Lm9
               .= (-q') * b' + r' by A6,Lm6
               .= q' * (-b') + r'
               .= a by A4,A7,A8,A10,Lm9;
     0.I <= r & r < abs(b)
    proof
       absint.c = absreal.c by Def6
            .= abs((-b')) by EUCLID:def 2
            .= -b' by A3,ABSVALUE:def 1
            .= abs((b')) by A2,ABSVALUE:def 1
            .= absreal.b' by EUCLID:def 2
            .= absint.b by Def6
            .= abs(b) by Th1;
    hence thesis by A4,Th1;
    end;
  hence thesis by A11;
  end;
  end;
  hence thesis;
  end;
uniqueness by A1,Th2;
end;

theorem
   for a,b being Element of INT.Ring
st b <> 0.INT.Ring holds a = (a div b) * b + (a mod b)
proof
let a,b be Element of INT.Ring;
assume A1: b <> 0.INT.Ring;
consider d being Element of INT.Ring such that
A2: d = (a div b);
consider c being Element of INT.Ring such that
A3: c = a mod b;
consider r being Element of INT.Ring such that
A4: a = d * b + r & 0.INT.Ring <= r & r < abs(b) by A1,A2,Def7;
consider q being Element of INT.Ring such that
A5: a = q * b + c & 0.INT.Ring <= c & c < abs(b) by A1,A3,Def8;
thus thesis by A1,A2,A3,A4,A5,Th2;
end;

::: Euclidian Domains
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

begin

definition
let I be non empty doubleLoopStr;
attr I is Euclidian means :Def9:
 ex f being Function of the carrier of I,NAT st
 (for a,b being Element of I st b <> 0.I holds
  (ex q,r being Element of I st
  (a = q * b + r & (r = 0.I or f.r < f.b))));
end;

registration
 cluster INT.Ring -> Euclidian;
coherence
 proof
  take absint;
  let a,b be Element of M;
  assume A1: b <> 0.M;
  reconsider b' = b as Integer by INT_1:def 2;
     now per cases;
  case 0 <= b';
  hence thesis by A1,Lm10;
  end;
  case A2: b' < 0;
  then A3: 0 < -b' by XREAL_1:60;
  reconsider c = -b' as Element of M by INT_1:def 2;
  consider q,r being Element of M such that
  A4: a = q * c + r & (r = 0.M or absint.r < absint.c) by A3,Lm2,Lm10;
  reconsider t = -q as Element of M;
  reconsider t' = t, q' = q, r' = r as Integer by INT_1:def 2;
  reconsider c' = c as Integer;
  consider d being Element of M such that A5: d = t * b;
  consider d' being Integer such that A6: d' = t' * b';
  consider e being Element of M such that A7: e = q * c;
  consider e' being Integer such that A8: e' = q' * c';
  A9: d = d' by A5,A6,Lm3;
  A10: e = e' by A7,A8,Lm3;
  A11: t * b + r= d' + r' by A5,A9,Lm9
               .= (-q') * b' + r' by A6,Lm6
               .= q' * (-b') + r'
               .= a by A4,A7,A8,A10,Lm9;
     r = 0.M or absint.r < absint.b
    proof
    assume A12: r <> 0.M;
       absint.c = absreal.c by Def6
            .= abs((-b')) by EUCLID:def 2
            .= -b' by A3,ABSVALUE:def 1
            .= abs((b')) by A2,ABSVALUE:def 1
            .= absreal.(b') by EUCLID:def 2
            .= absint.b by Def6;
    hence thesis by A4,A12;
    end;
  hence ex q,r being Element of M st
        (a = q * b + r & (r = 0.M or absint.r < absint.b)) by A11;
  end;
  end;
  hence thesis;
  end;
end;

Lm12:for F being commutative associative left_unital Field-like right_zeroed
  (non empty doubleLoopStr)
  for f being Function of the carrier of F,NAT holds
    (for a,b being Element of F st b <> 0.F holds
    (ex q,r being Element of F st
     (a = q * b + r & (r = 0.F or f.r < f.b))))
  proof
  let F be commutative associative left_unital Field-like right_zeroed
     (non empty doubleLoopStr);
  let f be Function of the carrier of F,NAT;
     now let a,b be Element of F;
  assume A1: b <> 0.F;
     (ex q,r being Element of F st
        (a = q * b + r & (r = 0.F or f.r < f.b)))
      proof
      consider x being Element of F such that
      A2: b * x = 1.F by A1,VECTSP_1:def 20;
           (a * x) * b + 0.F
         = a * 1.F + 0.F by A2,GROUP_1:def 4
        .= a + 0.F by VECTSP_1:def 19
        .= a by RLVECT_1:def 7;
      hence thesis;
      end;
  hence b <> 0.F implies
      (ex q,r being Element of F st
        (a = q * b + r & (r = 0.F or f.r < f.b)));
  end;
  hence thesis;
  end;

registration
cluster strict Euclidian domRing-like non degenerated
        distributive commutative Ring;
existence
proof
  take INT.Ring;
  thus thesis;
end;
end;

definition
mode EuclidianRing is Euclidian domRing-like non degenerated
     distributive commutative Ring;
end;

registration
cluster strict EuclidianRing;
existence
 proof
   take INT.Ring;
   thus thesis;
 end;
end;

definition
let E be Euclidian (non empty doubleLoopStr);
mode DegreeFunction of E ->
              Function of the carrier of E,NAT means :Def10:
 (for a,b being Element of E
  st b <> 0.E holds
  (ex q,r being Element of E st
  (a = q * b + r & (r = 0.E or it.r < it.b))));
existence by Def9;
end;

theorem
Th4:for E being EuclidianRing holds E is gcdDomain
proof
 let E be EuclidianRing;
 consider d being DegreeFunction of E;
    E is gcd-like
     proof
        now let x,y be Element of E;
        now per cases;
     case A1: x = 0.E;
         y * 0.E = 0.E by VECTSP_1:36;
     then A2: y divides 0.E by GCD_1:def 1;
        for zz being Element of E
          st (zz divides x & zz divides y)
          holds (zz divides y);
     hence ex z being Element of E st
           z divides x & z divides y &
           for zz being Element of E st
           (zz divides x & zz divides y) holds zz divides z by A1,A2;
     end;
     case A3: x <> 0.E;
     set M = { z where z is Element of E:
               ex s,t being Element of E
               st z = s * x + t * y};
     A4: x in M & y in M
         proof
         A5:   1.E * x + 0.E * y
             = 1.E * x + 0.E by VECTSP_1:39
            .= 1.E * x by RLVECT_1:def 7
            .= x by VECTSP_1:def 19;
               0.E * x + 1.E * y
             = 0.E + 1.E * y by VECTSP_1:39
            .= 1.E * y by RLVECT_1:10
            .= y by VECTSP_1:def 19;
         hence thesis by A5;
         end;
     defpred P[Nat] means
        ex z being Element of E
        st (z in M & z <> 0.E & $1 = d.z);
     A6: ex k being Nat st P[k]
         proof
             ex k being Nat st k = d.x;
         hence thesis by A3,A4;
         end;
         ex k being Nat st P[k] &
         for n being Nat st P[n] holds k <= n from NAT_1:sch 5(A6);
     then consider k being Nat such that
     A7: P[k] & for n being Nat st P[n] holds k <= n;

     consider g being Element of E such that
     A8: g in M & g <> 0.E & k = d.g &
         for n being Nat st
         (ex z being Element of E
          st (z in M & z <> 0.E & n = d.z))
         holds k <= n by A7;
     set G = { z where z is Element of E:
               ex r being Element of E
               st z = r * g};
     A9: M = G
     proof
     A10: for z being set holds z in M implies z in G
         proof
         let z be set;
         assume z in M;
         then consider z2 being Element of E such that
         A11: z = z2 &
              ex s,t being Element of E st
              z2 = s * x + t * y;
         reconsider z as Element of E by A11;
         consider u,v being Element of E such that
         A12: z2 = u * x + v * y by A11;
         consider q,r being Element of E such that
         A13: z = q * g + r & (r = 0.E or d.r < d.g) by A8,Def10;
            r in M
              proof
              A14:   z + (-(q * g))
                  = r + ((q * g) + (-(q * g))) by A13,RLVECT_1:def 6
                 .= r + 0.E by RLVECT_1:def 10
                 .= r by RLVECT_1:def 7;
              consider z1 being Element of E such that
              A15: g = z1 &
                  ex s,t being Element of E st
                  z1 = s * x + t * y by A8;
              consider s,t being Element of E such that
              A16: z1 = s * x + t * y by A15;
                  r = z + (-(q * (s * x) + q * (t * y)))
 by A14,A15,A16,VECTSP_1:def 18
                   .= z + ((-(q * (s * x))) + (-(q * (t * y))))
 by RLVECT_1:45
                   .= ((u * x + v * y) + (-(q * (s * x)))) + (-(q * (t * y)))
 by A11,A12,RLVECT_1:def 6
                   .= ((u * x + (-(q * (s * x)))) + v * y) + (-(q * (t * y)))
 by RLVECT_1:def 6
                   .= (u * x + (-(q * (s * x)))) + (v * y + (-(q * (t * y))))
 by RLVECT_1:def 6
                   .= (u * x + ((-q) * (s * x))) + (v * y + (-(q * (t * y))))
 by GCD_1:51
                   .= (u * x + ((-q) * (s * x))) + (v * y + ((-q) * (t * y)))
 by GCD_1:51
                   .= (u * x + ((-q) * s) * x) + (v * y + ((-q) * (t * y)))
 by GROUP_1:def 4
                   .= (u * x + ((-q) * s) * x) + (v * y + ((-q) * t) * y)
 by GROUP_1:def 4
                   .= (u + ((-q) * s)) * x + (v * y + ((-q) * t) * y)
 by VECTSP_1:def 18
                   .= (u + ((-q) * s)) * x + (v + ((-q) * t)) * y
 by VECTSP_1:def 18;
              hence thesis;
              end;
         then r = 0.E by A8,A13;
          then z = q * g by A13,RLVECT_1:def 7;
         hence thesis;
         end;
        for z being set holds z in G implies z in M
         proof
         let z be set;
         assume z in G;
         then consider z2 being Element of E such that
         A17: z = z2 &
              ex s being Element of E st
              z2 = s * g;
         reconsider z as Element of E by A17;
         consider u being Element of E such that
         A18: z2 = u * g by A17;
         consider z1 being Element of E such that
         A19: g = z1 &
              ex s,t being Element of E st
              z1 = s * x + t * y by A8;
         consider s,t being Element of E such that
         A20: z1 = s * x + t * y by A19;
             z = u * (s * x) + u * (t * y) by A17,A18,A19,A20,VECTSP_1:def 11
           .= (u * s) * x + u * (t * y) by GROUP_1:def 4
           .= (u * s) * x + (u * t) * y by GROUP_1:def 4;
         hence thesis;
         end;
     hence thesis by A10,TARSKI:2;
     end;
     A21: g divides x & g divides y
          proof
          consider zz being Element of E such that
          A22: x = zz &
              ex r being Element of E st
              zz = r * g by A4,A9;
          consider zzz being Element of E such that
          A23: y = zzz &
              ex r being Element of E st
              zzz = r * g by A4,A9;
          thus thesis by A22,A23,GCD_1:def 1;
          end;
        for z being Element of E
          holds (z divides x & z divides y) implies z divides g
          proof
          let z be Element of E;
          assume A24: z divides x & z divides y;
          then consider u being Element of E such that
          A25: x = z * u by GCD_1:def 1;
          consider v being Element of E such that
          A26: y = z * v by A24,GCD_1:def 1;
          consider zz being Element of E such that
          A27: g = zz &
              ex s,t being Element of E st
              zz = s * x + t * y by A8;
          consider s,t being Element of E such that
          A28: zz = s * x + t * y by A27;
              g = (s * u) * z + t * (v * z) by A25,A26,A27,A28,GROUP_1:def 4
            .= (s * u) * z + (t * v) * z by GROUP_1:def 4
            .= (s * u + t * v) * z by VECTSP_1:def 18;
          hence thesis by GCD_1:def 1;
          end;
     hence ex z being Element of E st
          z divides x & z divides y &
          for zz being Element of E st
          (zz divides x & zz divides y) holds zz divides z by A21;
     end;
     end;
     hence ex z being Element of E st
          z divides x & z divides y &
          for zz being Element of E st
          (zz divides x & zz divides y) holds zz divides z;
     end;
     hence thesis by GCD_1:def 11;
     end;
hence thesis;
end;

registration
cluster Euclidian -> gcd-like (domRing-like non degenerated
    Abelian add-associative right_zeroed right_complementable
    associative commutative right_unital right-distributive
     (non empty doubleLoopStr));
coherence by Th4;
end;

definition
redefine func absint -> DegreeFunction of INT.Ring;
coherence
proof
    for a,b being Element of M st b <> 0.M holds
  (ex q,r being Element of M st
  (a = q * b + r & (r = 0.M or absint.r < absint.b)))
  proof
  let a,b be Element of M;
  assume A1: b <> 0.M;
  reconsider b' = b as Integer by INT_1:def 2;
     now per cases;
  case 0 <= b';
  hence thesis by A1,Lm10;
  end;
  case A2: b' < 0;
  then A3: 0 < -b' by XREAL_1:60;
  reconsider c = -b' as Element of M by INT_1:def 2;
  consider q,r being Element of M such that
  A4: (a = q * c + r & (r = 0.M or absint.r < absint.c)) by A3,Lm2,Lm10;
  reconsider t = -q as Element of M;
  reconsider t' = t, q' = q, r' = r as Integer by INT_1:def 2;
  reconsider c' = c as Integer;
  consider d being Element of M such that A5: d = t * b;
  consider d' being Integer such that A6: d' = t' * b';
  consider e being Element of M such that A7: e = q * c;
  consider e' being Integer such that A8: e' = q' * c';
  A9: d = d' by A5,A6,Lm3;
  A10: e = e' by A7,A8,Lm3;
  A11: t * b + r = d' + r' by A5,A9,Lm9
               .= (-q') * b' + r' by A6,Lm6
               .= e' + r' by A8
               .= a by A4,A7,A10,Lm9;
     r = 0.M or absint.r < absint.b
    proof
    assume A12: r <> 0.M;
       absint.c = absreal.c by Def6
            .= abs((-b')) by EUCLID:def 2
            .= -b' by A3,ABSVALUE:def 1
            .= abs((b')) by A2,ABSVALUE:def 1
            .= absreal.(b') by EUCLID:def 2
            .= absint.b by Def6;
    hence thesis by A4,A12;
    end;
  hence ex q,r being Element of M st
        (a = q * b + r & (r = 0.M or absint.r < absint.b)) by A11;
  end;
  end;
  hence thesis;
  end;
hence thesis by Def10;
end;
end;

theorem
Th5:for F being commutative associative left_unital Field-like right_zeroed
  (non empty doubleLoopStr) holds F is Euclidian
proof
let F be commutative associative left_unital Field-like right_zeroed
  (non empty doubleLoopStr);
consider f being Function of the carrier of F,NAT;
    (for a,b being Element of F st b <> 0.F holds
    (ex q,r being Element of F st
     (a = q * b + r & (r = 0.F or f.r < f.b)))) by Lm12;
hence thesis by Def9;
end;

registration
cluster commutative associative left_unital Field-like right_zeroed Field-like
  -> Euclidian (non empty doubleLoopStr);
coherence by Th5;
end;

theorem
   for F being commutative associative left_unital Field-like right_zeroed
  (non empty doubleLoopStr)
for f being Function of the carrier of F,NAT holds
f is DegreeFunction of F
proof
let F be commutative associative left_unital Field-like right_zeroed
  (non empty doubleLoopStr);
let f be Function of the carrier of F,NAT;
   (for a,b being Element of F st b <> 0.F holds
    (ex q,r being Element of F st
     (a = q * b + r & (r = 0.F or f.r < f.b)))) by Lm12;
hence thesis by Def10;
end;

::: Some Theorems about DIV and MOD
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

begin

canceled;

theorem
Th8:for n,a,k being Integer holds
(n <> 0 implies (a + n * k) div n = (a div n) + k) &
(a + n * k) mod n = a mod n
proof
let n,a,k be Integer;
thus
A1: now
  assume A2: n <> 0;
  thus (a + n * k) div n = [\ (a + n * k)/n /] by INT_1:def 7
    .= [\ (a + n * k) * n" /] by XCMPLX_0:def 9
    .= [\ a * n" + (n * n") * k /]
    .= [\ a * n" + 1 * k /] by A2,XCMPLX_0:def 7
    .= [\ a * n" /] + k by INT_1:51
    .= [\ a/n /] + k by XCMPLX_0:def 9
    .= (a div n) + k by INT_1:def 7;
end;
per cases;
suppose A3: n <> 0;
hence (a + n * k) mod n = (a + n * k) - ((a div n) + k) * n by A1,INT_1:def 8
   .= a - (a div n) * n
   .= a mod n by A3,INT_1:def 8;
end;
suppose n = 0;
hence thesis;
end;
end;

theorem
Th9:for n being natural number st n > 0
for a being Integer holds a mod n >= 0 & a mod n < n
proof
let n be natural number; assume A1: n > 0;
let a be Integer;
   now
     a div n = [\ a/n /] by INT_1:def 7;
  then a div n <= a/n by INT_1:def 4;
  then (a div n) * n <= a/n * n by XREAL_1:66;
  then (a div n) * n <= (a * n") * n by XCMPLX_0:def 9;
  then (a div n) * n <= a * (n" * n);
  then (a div n) * n <= a * 1 by A1,XCMPLX_0:def 7;
  then (a div n) * n - (a div n) * n <= a - (a div n) * n by XREAL_1:11;
  hence 0 <= a mod n by A1,INT_1:def 8;
  assume a mod n >= n;
  then a - (a div n) * n >= n by A1,INT_1:def 8;
  then (a + -(a div n) * n) + (a div n) * n >= n + (a div n) * n
 by XREAL_1:8;
  then A2: a - n >= (n + (a div n) * n) - n by XREAL_1:11;
  (a - n) * n" >= ((a div n) * n) * n" by A2,XREAL_1:66;
  then (a - n) * n" >= (a div n) * (n * n");
  then a * n" - n * n" >= (a div n) * 1 by A1,XCMPLX_0:def 7;
  then a * n" - 1 >= (a div n) by A1,XCMPLX_0:def 7;
  then A3: a/n - 1 >= (a div n) by XCMPLX_0:def 9;
     a div n = [\ a/n /] by INT_1:def 7;
  hence contradiction by A3,INT_1:def 4;
end;
hence thesis;
end;

theorem
Th10:for n,a being Integer holds
(0 <= a & a < n implies a mod n = a) &
(0 > a & a >= -n implies a mod n = n + a)
proof
let n,a be Integer;
per cases;
suppose n = 0;
hence thesis;
end;
suppose A1: n <> 0;
hereby
   assume A2: 0 <= a & a < n;
   then reconsider aa = a as Nat by INT_1:16;
A3: n >= 0 by A2;
   then reconsider nn = n as Nat by INT_1:16;
   consider t being Nat such that
   A4: aa = nn * t + (aa mod nn) & (aa mod nn) < nn by A1,NAT_1:def 2;
      t = 0
     proof
     assume A5: t <> 0;
      t >= 0;
     then t >= 1 + 0 by A5,INT_1:20;
     then A6: t * n >= 1 * n by A3,XREAL_1:66;
      nn * t + (aa mod nn) >= nn * t by NAT_1:29;
     hence thesis by A2,A4,A6,XXREAL_0:2;
     end;
   hence a mod n = a by A4,NEWTON:101;
   end;
   assume A7: 0 > a & a >= -n;
   then -n <= 0;
   then A8: n >= 0 by XREAL_1:60;
   A9: a mod n = a - (a div n) * n by A1,INT_1:def 8;
   A10: -1 <= a/n
   proof
        n" > 0 by A1,A8,XREAL_1:124;
       then a * n" >= (-n) * n" by A7,XREAL_1:66;
       then a /n >= -(n * n") by XCMPLX_0:def 9;
       hence thesis by A1,XCMPLX_0:def 7;
       end;
      a/n - 1 < -1
       proof
       assume a/n - 1 >= -1;
       then (a/n - 1) + 1 >= -1 + 1 by XREAL_1:8;
       then a/n + (-1 + 1) >= 0;
       then a * n" >= 0 by XCMPLX_0:def 9;
       then (a * n") * n >= 0 * n by A8,XREAL_1:66;
       then a * (n" * n) >= 0;
       then a * 1 >= 0 by A1,XCMPLX_0:def 7;
       hence thesis by A7;
       end;
   then [\ a/n /] = -1 by A10,INT_1:def 4;
   then a div n = -1 by INT_1:def 7;
   hence thesis by A9;
end;
end;

theorem
Th11:for n being natural number st n > 0
for a being Integer holds a mod n = 0 iff n divides a
proof
let n be natural number; assume A1: n > 0;
let a be Integer;
A2: now assume a mod n = 0;
   then 0 = a - (a div n) * n by A1,INT_1:def 8;
   then (a div n) * n = (a - (a div n) * n) + (a div n) * n;
   hence n divides a by INT_1:def 9;
   end;
   now assume n divides a;
   then consider k being Integer such that A3: n * k = a by INT_1:def 9;
   A4: a mod n = a - (a div n) * n by A1,INT_1:def 8
          .= a - ([\ a/n /]) * n by INT_1:def 7;
   A5: k <= a/n
       proof
       assume k > a/n;
       then k * n > a/n * n by A1,XREAL_1:70;
       then k * n > (a * n") * n by XCMPLX_0:def 9;
       then k * n > a * (n" * n);
       then n * k > a * 1 by A1,XCMPLX_0:def 7;
       hence thesis by A3;
       end;
      a/n - 1 < k
       proof
        A6: not(-n > 0);
          -n <> 0 by A1;
       then A7: -n + a < 0 + a by A6,XREAL_1:8;
          0 < n" by A1,XREAL_1:124;
       then (-n + a) * n" < (n * k) * n" by A3,A7,XREAL_1:70;
       then (-n) * n" + a * n" < (n * k) * n";
       then (-n) * n" + a/n < (n * n") * k by XCMPLX_0:def 9;
       then (-n) * n" + a/n < 1 * k by A1,XCMPLX_0:def 7;
       then -n * n" + a/n < k;
       then -1 + a/n < k by A1,XCMPLX_0:def 7;
       hence thesis;
       end;
   then ([\ a/n /]) = k by A5,INT_1:def 4;
   hence a mod n = 0 by A3,A4;
   end;
hence thesis by A2;
end;

theorem
Th12:for n,a,b being Integer holds
(n <> 0 & a mod n = b mod n implies a,b are_congruent_mod n) &
(a,b are_congruent_mod n implies a mod n = b mod n)
proof
let n,a,b be Integer;
hereby
  assume A1: n <> 0;
  assume a mod n = b mod n;
  then a - (a div n) * n = b mod n by A1,INT_1:def 8;
  then a - (a div n) * n = b - (b div n) * n by A1,INT_1:def 8;
  then (a - (a div n) * n) - b = (b - (b div n) * n) + -b;
  then ((a + -(a div n) * n) - b) + (a div n) * n =
  -(b div n) * n + (a div n) * n;
  then ((a + -(a div n) * n) + -b) + (a div n) * n =
  -(b div n) * n + (a div n) * n;
  then ((a + -(a div n) * n) + (a div n) * n) + -b =
        -(b div n) * n + (a div n) * n;
  then a - b = (-(b div n) + (a div n)) * n;
  then n divides (a-b) by INT_1:def 9;
  hence a,b are_congruent_mod n by INT_2:19;
end;
  assume a,b are_congruent_mod n;
  then n divides (a-b) by INT_2:19;
  then consider k being Integer such that A2: n * k = a - b by INT_1:def 9;
   a = n * k + b by A2;
  hence a mod n = b mod n by Th8;
end;

theorem
Th13:for n being natural number
for a being Integer holds (a mod n) mod n = a mod n
proof
let n be natural number;
let a be Integer;
per cases;
suppose
A1: n = 0;
hence (a mod n) mod n = 0 by INT_1:def 8
    .= a mod n by A1,INT_1:def 8;
end;
suppose n <> 0;
then A2: n > 0;
then A3: a mod n >= 0 by Th9;
   a mod n < n by A2,Th9;
hence thesis by A3,Th10;
end;
end;

theorem
Th14:for n,a,b being Integer holds
(a + b) mod n = ((a mod n) + (b mod n)) mod n
proof
let n,a,b be Integer;
per cases;
suppose
A1: n = 0;
hence (a + b) mod n = 0 by INT_1:def 8
   .= ((a mod n) + (b mod n)) mod n by A1,INT_1:def 8;
end;
suppose A2: n <> 0;
  then A3: a mod n + (a div n) * n = (a - (a div n) * n) + (a div n) * n
  by INT_1:def 8;
   b mod n + (b div n) * n = (b - (b div n) * n) + (b div n) * n
  by A2,INT_1:def 8;
   then (a + b) - ((a mod n) + (b mod n))
 = ((((a mod n) + (a div n) * n) + (b div n) * n) + (b mod n)) -
   ((a mod n) + (b mod n)) by A3
.= ((a div n) + (b div n)) * n;
then n divides (a + b) - ((a mod n) + (b mod n)) by INT_1:def 9;
then a+b,(a mod n)+(b mod n) are_congruent_mod n by INT_2:19;
hence thesis by Th12;
end;
end;

theorem
Th15:for n,a,b being Integer holds
(a * b) mod n = ((a mod n) * (b mod n)) mod n
proof
let n,a,b be Integer;
per cases;
suppose
A1: n = 0;
hence (a * b) mod n = 0 by INT_1:def 8
   .= ((a mod n) * (b mod n)) mod n by A1,INT_1:def 8;
end;
suppose A2: n <> 0;
  then A3: a mod n + (a div n) * n = (a - (a div n) * n) + (a div n) * n
  by INT_1:def 8;
   b mod n + (b div n) * n = (b - (b div n) * n) + (b div n) * n
  by A2,INT_1:def 8;
   then (a * b) - ((a mod n) * (b mod n))
 = ((a mod n) * (b mod n) + ((a mod n) * ((b div n) * n) +
     (((a div n) * n) * (b mod n) + ((a div n) * n) * ((b div n) * n)))) -
   ((a mod n) * (b mod n)) by A3
.= (((a mod n) * (b div n)) + (((a div n) * (b mod n)) +
      (((a div n) * n) * (b div n)))) * n;
then n divides ((a * b) - ((a mod n) * (b mod n))) by INT_1:def 9;
then (a*b),((a mod n)*(b mod n)) are_congruent_mod n by INT_2:19;
hence thesis by Th12;
end;
end;

theorem
Th16:for a,b being Integer ex s,t being Integer st a gcd b = s * a + t * b
proof
let a,b be Integer;
A1: for a,b being Integer st a > 0 & b > 0 holds
   (ex s,t being Integer st ((a gcd b) = (s * a + t * b)))
     proof
     let a,b be Integer;
     assume A2: a > 0 & b > 0;
     then reconsider a,b as Nat by INT_1:16;
     set M = {z where z is Nat : ex s,t being Integer st z = s * a + t * b};
     defpred P[Nat] means ($1 in M & $1 <> 0);
        a = 1 * a + 0 * b & b = 0 * a + 1 * b;
     then A3: a in M & b in M;
     then A4: ex k being Nat st P[k] by A2;
     consider g being Nat such that
     A5: P[g] & for n being Nat st P[n] holds g <= n from NAT_1:sch 5(A4);
     consider z being Nat such that
     A6: z = g & ex s,t being Integer st z = s * a + t * b by A5;
     consider s,t being Integer such that A7: g = s * a + t * b by A6;
     set G = {zz where zz is Nat : ex s being Nat st zz = s * g};
     A8: abs(a) = a & abs(b) = b by ABSVALUE:def 1;
     A9: G = M
         proof
         A10: for x being set holds x in M implies x in G
            proof
            let x be set; assume x in M;
            then consider x' being Nat such that
            A11: x' = x & ex u,v being Integer st x' = u * a + v * b;
            consider u,v being Integer such that A12: x = u * a + v * b by A11;
            consider r being Nat such that
            A13: x' = g * (x' div g) + r & r < g by A5,NAT_1:def 1;
            r = x' - g * (x' div g) by A13
             .= (u * a + v * b) -
                ((a * (s * (x' div g))) + (b * (t * (x' div g))))
               by A7,A11,A12
             .= a * (u + -(s * (x' div g))) + b * (v + -(t * (x' div g)));
            then r in M;
            then r = 0 by A5,A13;
            hence thesis by A11,A13;
            end;
            for x being set holds x in G implies x in M
            proof
            let x be set; assume x in G;
            then consider x' being Nat such that
            A14: x' = x & ex u being Nat st x' = u * g;
            consider u being Integer such that A15: x = u * g by A14;
               x = u * (s * a) + u * (t * b) by A7,A15
             .= (u * s) * a + (u * t) * b;
            hence thesis by A14;
            end;
         hence thesis by A10,TARSKI:2;
         end;
     then consider a' being Nat
     such that A16: a' = a & ex s being Nat st a' = s * g by A3;
     consider b' being Nat
     such that A17: b' = b & ex t being Nat st b' = t * g by A3,A9;
     consider u,v being Nat such that
     A18: a = u * g & b = v * g by A16,A17;
     A19: g divides abs(a) & g divides abs(b) by A8,A18,NAT_1:def 3;
        for m being Nat st m divides abs(a) & m divides abs(b) holds m
 divides g
        proof
        let m be Nat; assume A20: m divides abs(a) & m divides abs(b);
        then consider u being Nat such that A21: a = m * u by A8,NAT_1:def 3;
        consider v being Nat such that A22: b = m * v by A8,A20,NAT_1:def 3;
        consider g' being Nat such that
        A23: g' = g & ex s,t being Integer st g' = s * a + t * b by A5;
        consider s,t being Integer such that A24: g = s * a + t * b by A23;
        A25: g = m * (s * u + t * v) by A21,A22,A24;
           s * u + t * v is Nat
          proof
             s * u + t * v >= 0
             proof
             assume A26: s * u + t * v < 0;
               m >= 0 & g >= 0;
             hence thesis by A5,A25,A26,XREAL_1:133;
             end;
          hence thesis by INT_1:16;
          end;
        hence thesis by A25,NAT_1:def 3;
        end;
     then g = abs(a) hcf abs(b) by A19,NAT_1:def 5
                .= a gcd b by INT_2:def 3;
     hence thesis by A7;
     end;
   now per cases;
case A27: a = 0 or b = 0;
A28:for a,b being Integer holds a = 0 implies a gcd b = abs(b)
    proof
    let a,b be Integer; assume a = 0;
    then A29: abs(a) = 0 by ABSVALUE:def 1;
    A30: a gcd b = abs(a) hcf abs(b) by INT_2:def 3;
    A31: abs(b) divides abs(a) by A29,NAT_1:53;
       for m being Nat st m divides abs(a) & m divides abs(b) holds m
 divides abs(b);
    hence thesis by A30,A31,NAT_1:def 5;
    end;
   now per cases by A27;
case a = 0;
  then A32: a gcd b = abs(b) by A28;
     now per cases;
    case b >= 0;
    hence a gcd b = 0 * a + 1 * b by A32,ABSVALUE:def 1;
    end;
    case b < 0;
    hence a gcd b = -(b * 1) by A32,ABSVALUE:def 1
                 .= 0 * a + (-1) * b;
  end;
  end;
  hence thesis;
end;
case b = 0;
  then A33: a gcd b = abs(a) by A28;
     now per cases;
    case a >= 0;
    hence a gcd b = 1 * a + 0 * b by A33,ABSVALUE:def 1;
    end;
    case a < 0;
    hence a gcd b = -(a * 1) by A33,ABSVALUE:def 1
                 .= 0 * b + (-1) * a;
  end;
  end;
  hence thesis;
end;
end;
hence thesis;
end;
case A34: a <> 0 & b <> 0;
   now per cases;
case a >= 0 & b >= 0; hence thesis by A1,A34;
end;
case a < 0 & b >= 0;
  then -a > 0 & b > 0 by A34,XREAL_1:60;
  then consider s,t being Integer such that A35: -a gcd b = s * -a + t * b by
A1;
  A36: s * -a + t * b = (-s) * a + t * b;
     a gcd b = abs(a) hcf abs(b) by INT_2:def 3
         .= abs((-a)) hcf abs(b) by COMPLEX1:138
         .= -a gcd b by INT_2:def 3;
  hence thesis by A35,A36;
end;
case a >= 0 & b < 0;
  then -b > 0 & a > 0 by A34,XREAL_1:60;
  then consider s,t being Integer such that A37: a gcd -b = s * a + t * -b by
A1;
  A38: s * a + t * -b = s * a + (-t) * b;
     a gcd b = abs(a) hcf abs(b) by INT_2:def 3
         .= abs(a) hcf abs((-b)) by COMPLEX1:138
         .= a gcd -b by INT_2:def 3;
  hence thesis by A37,A38;
end;
case a < 0 & b < 0;
  then -a > 0 & -b > 0 by XREAL_1:60;
  then consider s,t being Integer such that A39: -a gcd -b = s * -a + t * -b
by A1;
  A40: s * -a + t * -b = (-s) * a + (-t) * b;
     a gcd b = abs(a) hcf abs(b) by INT_2:def 3
         .= abs(a) hcf abs((-b)) by COMPLEX1:138
         .= abs((-a)) hcf abs((-b)) by COMPLEX1:138
         .= -a gcd -b by INT_2:def 3;
  hence thesis by A39,A40;
end;
end;
hence thesis;
end;
end;
hence thesis;
end;

::: Modulo Integers
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

begin

definition
let n be natural number such that A1:n > 0;
func multint(n) -> BinOp of Segm(n) means :Def11:
 for k,l being Element of Segm(n) holds
 it.(k,l) = (k * l) mod n;
existence
 proof
   defpred P[Element of Segm(n),Element of Segm(n),set]
   means $3 = ($1 * $2) mod n;
  A2: for k,l being Element of Segm(n) ex c being Element of Segm(n)
      st P[k,l,c]
      proof
      let k,l be Element of Segm(n);
      reconsider k' = k,l' = l as Nat;
      ((k'*l') mod n) < n by A1,NAT_1:46;
      then reconsider c = (k'*l') mod n as Element of Segm(n) by GR_CY_1:10;
      take c;
      thus thesis;
      end;
  thus ex c being BinOp of Segm(n) st
 for k,l being Element of Segm(n) holds P[k,l,c.(k,l)]
 from BINOP_1:sch 3(A2);
  end;
uniqueness
 proof
   deffunc O(Element of Segm(n),Element of Segm(n))=($1 * $2) mod n;
   thus for o1,o2 being BinOp of Segm(n) st
    (for a,b being Element of Segm(n) holds o1.(a,b) = O(a,b)) &
    (for a,b being Element of Segm(n) holds o2.(a,b) = O(a,b))
  holds o1 = o2 from BINOP_2:sch 2;
 end;
end;

definition
let n be natural number such that A1:n > 0;
func compint(n) -> UnOp of Segm(n) means :Def12:
 for k being Element of Segm(n) holds
 it.k = (n - k) mod n;
existence
 proof
 set f = {[k,(n-k) mod n] where k is Nat : k < n };
 A2: f is Relation-like
    proof
       for x being set holds x in f implies ex y,z being set st x = [y,z]
     proof
      let x be set;
      assume x in f;
      then consider k being Nat such that
      A3: x = [k,(n-k) mod n] & k < n;
      thus thesis by A3;
      end;
    hence thesis by RELAT_1:def 1;
    end;
    f is Function-like
   proof
      for x,y1,y2 being set st [x,y1] in f & [x,y2] in f holds y1 = y2
     proof
     let x,y1,y2 be set;
     assume A4: [x,y1] in f & [x,y2] in f;
     then consider k being Nat such that
     A5: [x,y1] = [k,(n-k)mod n] & k < n;
     consider k' being Nat such that
     A6: [x,y2] = [k',(n-k') mod n] & k' < n by A4;
     A7: k = [x,y1]`1 by A5,MCART_1:def 1
          .= x by MCART_1:def 1
          .= [k',(n-k')mod n]`1 by A6,MCART_1:def 1
          .= k' by MCART_1:def 1;
     A8: y1 = [k,(n-k)mod n]`2 by A5,MCART_1:def 2
           .= (n-k)mod n by MCART_1:def 2;
         y2 = [k',(n-k')mod n]`2 by A6,MCART_1:def 2
           .= (n-k')mod n by MCART_1:def 2;
     hence thesis by A7,A8;
     end;
   hence thesis by FUNCT_1:def 1;
   end;
 then reconsider f as Function by A2;
 A9: dom f = Segm(n)
    proof
    A10: for x being set holds x in dom f implies x in Segm(n)
        proof
        let x be set;
        assume x in dom f;
        then consider y being set such that A11: [x,y] in f by RELAT_1:def 4;
        consider k being Nat such that
        A12: [x,y] = [k,(n-k)mod n] & k < n by A11;
           x = [k,(n-k)mod n]`1 by A12,MCART_1:def 1
         .= k by MCART_1:def 1;
        hence thesis by A12,GR_CY_1:10;
        end;
       for x being set holds x in Segm(n) implies x in dom f
        proof
        let x be set;
        assume A13: x in Segm(n);
        then reconsider x as Nat;
           x < n by A1,A13,GR_CY_1:10;
        then [x,(n-x)mod n] in f;
        hence thesis by RELAT_1:def 4;
        end;
    hence thesis by A10,TARSKI:2;
    end;
    rng f c= Segm(n)
    proof
       for y being set holds y in rng f implies y in Segm(n)
      proof
      let y be set;
      assume y in rng f;
      then consider x being set such that A14: [x,y] in f by RELAT_1:def 5;
      consider k being Nat such that
      A15: [x,y] = [k,(n-k)mod n] & k < n by A14;
      A16: y = [k,(n-k)mod n]`2 by A15,MCART_1:def 2
           .= (n-k)mod n by MCART_1:def 2;
         k - k < n - k by A15,XREAL_1:11;
      then reconsider z = n - k as Nat by INT_1:16;
      A17: (n-k) mod n = z mod n
          proof
             now per cases;
          case A18: k = 0;
          reconsider n as Integer;
          A19: (n-k) mod n = n - (n div n) * n by A1,A18,INT_1:def 8
                          .= n - ([\ n/n /]) * n by INT_1:def 7
                          .= n - ([\ 1 /]) * n by A1,XCMPLX_1:60
                          .= n - 1 * n by INT_1:47
                          .= 0;
          reconsider n as Nat by ORDINAL2:def 21;
          consider a being Nat such that A20: a = z mod n;
          consider t being Nat such that
          A21: (z = n * t + a & a < n) or (a = 0 & n = 0) by A20,NAT_1:def 2;
          A22: t = 1
               proof
               assume A23: t <> 1;
                  now per cases;
               case t <= 1;
                 then t < 0 + 1 by A23,REAL_1:def 5;
                 then t <= 0 by NAT_1:38;
                 then t = 0;
                 hence thesis by A1,A18,A21;
               end;
               case t > 1;
                 then n * t > 1 * n by A1,XREAL_1:70;
                 hence thesis by A18,A21,NAT_1:29;
               end;
               end;
               hence thesis;
               end;
              z - n * t = (n * t + a) + -(n * t) by A1,A21
                   .= 0 + a;
          hence thesis by A18,A19,A20,A22;
          end;
          case A24: k <> 0;
          reconsider n as Integer;
          A25: n - k < n
                   proof
                      n <= n + k by NAT_1:29;
                   then A26: n - k <= (n + k) - k by XREAL_1:11;
                      n - k <> n by A24;
                   hence thesis by A26,REAL_1:def 5;
                   end;
          A27: (n-k) mod n = (n - k) - ((n-k) div n) * n by A1,INT_1:def 8
                          .= (n - k) - ([\ (n-k)/n /]) * n by INT_1:def 7;
             (n-k)/n < 1
               proof
               set c = n";
               A28: n * c = 1 by A1,XCMPLX_0:def 7;
               A29: 0 < c by A1,XREAL_1:124;
                  (n-k) * c < n * c
                   proof
                   A30: (n-k) * c <= n * c by A25,A29,XREAL_1:66;
                      (n-k) * c <> n * c by A25,A29,XCMPLX_1:5;
                   hence thesis by A30,REAL_1:def 5;
                   end;
               hence thesis by A28,XCMPLX_0:def 9;
               end;
          then A31: (n-k)/n - 1 < 1 - 1 by XREAL_1:11;
             0 <= (n-k)/n
             proof
             set c = n";
             A32: 0 < c by A1,XREAL_1:124;
                k - k < n - k by A15,XREAL_1:11;
             then 0 * c <= (n-k) * c by A32,XREAL_1:66;
             hence thesis by XCMPLX_0:def 9;
             end;
          then A33: [\ (n-k)/n /] = 0 by A31,INT_1:def 4;
          reconsider n as Nat by ORDINAL2:def 21;
          consider a being Nat such that A34: a = z mod n;
          consider t being Nat such that
          A35: (z = n * t + a & a < n) or (a = 0 & n = 0) by A34,NAT_1:def 2;
             t = 0
            proof
            assume A36: t <> 0;
             A37: 0 <= t;
            1 <= t
                proof
                   1 + 0 <= t by A36,A37,INT_1:20;
                hence thesis;
                end;
            then 1 * n <= t * n by XREAL_1:66;
            then A38: n + a <= n * t + a by XREAL_1:8;
               n <= n + a by NAT_1:29;
            hence thesis by A1,A25,A35,A38,XXREAL_0:2;
            end;
          hence thesis by A1,A27,A33,A34,A35;
          end;
          end;
          hence thesis;
          end;
         z mod n < n by A1,NAT_1:46;
      hence thesis by A16,A17,GR_CY_1:10;
      end;
    hence thesis by TARSKI:def 3;
    end;
 then reconsider f as UnOp of Segm(n) by A9,FUNCT_2:def 1,RELSET_1:11;
    for k being Element of Segm(n) holds f.(k) = (n - k) mod n
   proof
   let k be Element of Segm(n);
   reconsider k as Nat;
      k < n by A1,GR_CY_1:10;
   then [k,(n-k)mod n] in f;
   hence thesis by A9,FUNCT_1:def 4;
   end;
 hence thesis;
 end;
uniqueness
 proof
   deffunc F(Element of Segm(n))=(n - $1) mod n;
  thus for f1,f2 being UnOp of Segm(n) st
     (for a being Element of Segm(n) holds f1.(a) = F(a))
   & (for a being Element of Segm(n) holds f2.(a) = F(a))
  holds f1 = f2 from LMOD_7:sch 2;
 end;
end;

Lm13:for n being natural number st n > 0
for a being natural number st a < n
for b being natural number st b = n - a holds (n-a) mod n = b mod n
proof
let n be natural number; assume A1: n > 0;
let a be natural number; assume A2: a < n;
let b be natural number;
assume A3: b = n - a;
   now per cases;
case A4: a = 0;
reconsider n as Integer;
A5: (n-a) mod n = n - (n div n) * n by A1,A4,INT_1:def 8
               .= n - ([\ n/n /]) * n by INT_1:def 7
               .= n - ([\ 1 /]) * n by A1,XCMPLX_1:60
               .= n - 1 * n by INT_1:47
               .= 0;
reconsider n as Nat by ORDINAL2:def 21;
consider a' being Nat such that A6: a' = b mod n;
consider t being Nat such that
A7: (b = n * t + a' & a' < n) or (a' = 0 & n = 0)
 by A6,NAT_1:def 2;
A8: t = 1
     proof
     assume A9: t <> 1;
        now per cases;
     case t <= 1;
        then t < 0 + 1 by A9,REAL_1:def 5;
        then t <= 0 by NAT_1:38;
        then t = 0;
        hence thesis by A1,A3,A4,A7;
     end;
     case t > 1;
        then n * t > 1 * n by A1,XREAL_1:70;
        hence thesis by A3,A4,A7,NAT_1:29;
     end;
     end;
     hence thesis;
     end;
    b - n * t = 0 + a' by A1,A7;
hence thesis by A3,A4,A5,A6,A8;
end;
case A10: a <> 0;
reconsider n as Integer;
A11: n - a < n
     proof
        n <= n + a by NAT_1:29;
     then A12: n - a <= (n + a) - a by XREAL_1:11;
        n - a <> n by A10;
      hence thesis by A12,REAL_1:def 5;
      end;
A13: (n-a) mod n = (n - a) - ((n-a) div n) * n by A1,INT_1:def 8
                .= (n - a) - ([\ (n-a)/n /]) * n by INT_1:def 7;
   (n-a)/n < 1
   proof
   set c = n";
   A14: n * c = 1 by A1,XCMPLX_0:def 7;
   A15: 0 < c by A1,XREAL_1:124;
      (n-a) * c < n * c
       proof
       A16: (n-a) * c <= n * c by A11,A15,XREAL_1:66;
          (n-a) * c <> n * c by A11,A15,XCMPLX_1:5;
       hence thesis by A16,REAL_1:def 5;
       end;
    hence thesis by A14,XCMPLX_0:def 9;
    end;
then A17: (n-a)/n - 1 < 1 - 1 by XREAL_1:11;
   0 <= (n-a)/n
    proof
    set c = n";
    A18: 0 < c by A1,XREAL_1:124;
       a - a < n - a by A2,XREAL_1:11;
    then 0 * c <= (n-a) * c by A18,XREAL_1:66;
    hence thesis by XCMPLX_0:def 9;
    end;
then A19: [\ (n-a)/n /] = 0 by A17,INT_1:def 4;
reconsider n as Nat by ORDINAL2:def 21;
consider a' being Nat such that A20: a' = b mod n;
consider t being Nat such that
A21: (b = n * t + a' & a' < n) or (a' = 0 & n = 0)
 by A20,NAT_1:def 2;
   t = 0
   proof
   assume A22: t <> 0;
    A23: 0 <= t;
   1 <= t
       proof
          1 + 0 <= t by A22,A23,INT_1:20;
       hence thesis;
       end;
   then 1 * n <= t * n by XREAL_1:66;
   then A24: n + a' <= n * t + a' by XREAL_1:8;
      n <= n + a' by NAT_1:29;
   hence thesis by A3,A11,A21,A24,XXREAL_0:2;
   end;
hence thesis by A1,A3,A13,A19,A20,A21;
end;
end;
hence thesis;
end;

theorem
Th17:for n being natural number st n > 0
for a,b being Element of Segm(n) holds
(a + b < n iff (addint(n)).(a,b) = a + b) &
(a + b >= n iff (addint(n)).(a,b) = (a + b) - n)
proof
let n be natural number;
assume A1: n > 0;
let a,b be Element of Segm(n);
consider c being Nat such that A2: c = (a + b) mod n;
consider t being Nat such that
A3: (a + b = n * t + c & c < n) or c = 0 & n = 0 by A2,NAT_1:def 2;
A4: now assume A5: a + b < n;
       t = 0
        proof
        assume A6: t <> 0;
           0 <= t;
        then 1 + 0 <= t by A6,INT_1:20;
        then A7: 1 * n <= t * n by XREAL_1:66;
           n * t <= n * t + c by NAT_1:29;
        hence thesis by A3,A5,A7,XXREAL_0:2;
        end;
    hence (addint(n)).(a,b) = a + b by A1,A2,A3,GR_CY_1:def 5;
    end;
A8: (addint(n)).(a,b) = (a + b) implies a + b < n
    proof
    assume (addint(n)).(a,b) = (a + b);
    then (a + b) mod n = a + b by A1,GR_CY_1:def 5;
    hence thesis by A1,NAT_1:46;
    end;
A9: (addint(n)).(a,b) = (a + b) - n implies a + b >= n
    proof
    assume (addint(n)).(a,b) = (a + b) - n;
    then A10: (a + b) mod n = (a + b) - n by A1,GR_CY_1:def 5;
    assume A11: a + b < n;
    consider t being Nat such that
    A12: a + b = n * t + ((a + b) mod n) & ((a + b) mod n) < n
 by A1,NAT_1:def 2;
       t = 0
         proof
         assume A13: t <> 0;
          A14: t >= 0;
            1 <= t
            proof
               1 + 0 <= t by A13,A14,INT_1:20;
            hence thesis;
            end;
         then A15: 1 * n <= t * n by XREAL_1:66;
            t * n <= t * n + ((a + b) mod n) by NAT_1:29;
         hence thesis by A11,A12,A15,XXREAL_0:2;
         end;
    then 0 = ((a + b) + -n) - (a + b) by A10,A12
          .= 0 + - n;
    then n = -0 .= 0;
    hence thesis by A1;
    end;
   now assume A16: a + b >= n;
       t = 1
      proof
         now per cases;
        case t = 0;
          hence thesis by A1,A3,A16;
        end;
        case A17: t <> 0;
             t < 2
            proof
            assume t >= 2;
            then A18: n * t >= n * 2 by XREAL_1:66;
            A19: n * t + c >= n * t by NAT_1:29;
               a is natural & b is natural by ORDINAL2:def 21;
            then a < n & b < n by A1,GR_CY_1:10;
            then a + b < n * 1 + n * 1 by XREAL_1:10;
            hence thesis by A3,A18,A19,XXREAL_0:2;
            end;
          then t < 1 + 1;
          then A20: t <= 1 by NAT_1:38;
             0 <= t;
          then 1 + 0 <= t by A17,INT_1:20;
          hence thesis by A20,XXREAL_0:1;
        end;
        end;
      hence thesis;
      end;
    then (a + b) - n = (n + c) + -n by A1,A3
                    .= c + 0;
    hence (addint(n)).(a,b) = (a + b) - n by A1,A2,GR_CY_1:def 5;
    end;
hence thesis by A4,A8,A9;
end;

Lm14:for a,b being natural number st b <> 0 holds
ex k being Nat st k * b <= a & a < (k + 1) * b
proof
let a,b be natural number;
assume A1: b <> 0;
set k' = a div b;
consider t being Nat such that
A2: a = b * k' + t & t < b by A1,NAT_1:def 1;
   (k' + 1) * b = k' * b + b;
then A3: (k' + 1) * b > a by A2,XREAL_1:8;
   k' * b <= k' * b + t by NAT_1:29;
hence thesis by A2,A3;
end;

theorem
Th18:for n being natural number st n > 0
for a,b being Element of Segm(n)
for k being natural number holds
(k * n <= a * b & a * b < (k + 1) * n)
iff (multint(n)).(a,b) = a * b - k * n
proof
let n be natural number;
assume A1: n > 0;
let a,b be Element of Segm(n);
reconsider a, b as Nat;
let k be natural number;
A2: now assume (multint(n)).(a,b) = a * b - k * n;
   then A3: (a * b) mod n = a * b - k * n by A1,Def11;
   then a * b - k * n >= 0;
   then A4: (a * b - k * n) + k * n >= 0 + k * n by XREAL_1:8;
   consider t being Nat such that
   A5: a * b = n * t + (a * b - n * k) & (a * b - n * k) < n
 by A1,A3,NAT_1:def 2;
      (k + 1) * n = k * n + n;
   hence k * n <= a * b & a * b < (k + 1) * n by A4,A5,XREAL_1:8;
   end;
   now assume A6: k * n <= a * b & a * b < (k + 1) * n;
consider c being Nat such that A7: c = (a * b) mod n;
consider t being Nat such that
A8: (a * b = n * t + c & c < n) or c = 0 & n = 0 by A7,NAT_1:def 2;
   now
      now
      consider q being Nat such that A9: a * b = k * n + q by A6,NAT_1:28;
         t = k
        proof
           now per cases;
        case t <= k;
           then consider r being Nat such that A10: t + r = k by NAT_1:28;
              n * t + c = t * n + (r * n + q) by A1,A8,A9,A10;
          then A11: c = r * n + q;
             now per cases;
          case t = k;
            hence thesis;
          end;
          case A12: t <> k;
               r >= 1
              proof
              assume A13: r < 1;
                 r = 0
                proof
                assume r <> 0;
                then r > 0;
                then 1 + 0 <= r by INT_1:20;
                hence thesis by A13;
                end;
              hence thesis by A10,A12;
              end;
            then r * n >= 1 * n by NAT_1:20;
            then A14: r * n + q >= 1 * n + q by XREAL_1:8;
               1 * n + q >= n by NAT_1:29;
            hence thesis by A1,A8,A11,A14,XXREAL_0:2;
          end;
          end;
          hence thesis;
        end;
        case t > k;
          then t >= k + 1 by INT_1:20;
          then A15: n * t >= n * (k + 1) by NAT_1:20;
             n * t + c >= n * t by NAT_1:29;
          hence thesis by A6,A8,A15,XXREAL_0:2;
        end;
        end;
        hence thesis;
        end;
      hence (multint(n)).(a,b) = a * b - k * n by A1,A7,A8,Def11;
   end;
   hence (multint(n)).(a,b) = a * b - k * n;
   end;
  hence (multint(n)).(a,b) = a * b - k * n;
end;
hence thesis by A2;
end;

theorem
   for n being natural number st n > 0
for a being Element of Segm(n) holds
(a = 0 iff (compint(n)).(a) = 0) &
(a <> 0 iff (compint(n)).(a) = n - a)
proof
let n be natural number;
assume A1: n > 0;
let a be Element of Segm(n);
reconsider a as Nat;
A2: a < n by A1,GR_CY_1:10;
then a - a < n - a by XREAL_1:11;
then reconsider b = n - a as Nat by INT_1:16;
consider c being Nat such that A3: c = b mod n;
consider t being Nat such that
A4: (b = n * t + c & c < n) or c = 0 & n = 0 by A3,NAT_1:def 2;
A5: (n-a) mod n = b mod n by A2,Lm13;
A6: n - a <= n
    proof
    assume n - a > n;
    then (n - a) + a > n + a by XREAL_1:8;
    hence thesis by NAT_1:29;
    end;
A7: now assume A8: a = 0;
  A9: t = 1
    proof
       now per cases;
    case t = 0;
       hence thesis by A1,A4,A8;
    end;
    case A10: t <> 0;
          t < 2
          proof
          assume t >= 2;
          then A11: n * t >= n * 2 by XREAL_1:66;
             n * t + c >= n * t by NAT_1:29;
          then A12: n - a >= n * 2 by A1,A4,A11,XXREAL_0:2;
             n <= n * 1 + n * 1 by NAT_1:29;
          then n * 1 = 2 * n by A8,A12,XXREAL_0:1;
          hence thesis by A1;
          end;
       then t < 1 + 1;
       then A13: t <= 1 by NAT_1:38;
          0 <= t;
       then 1 + 0 <= t by A10,INT_1:20;
       hence thesis by A13,XXREAL_0:1;
    end;
    end;
    hence thesis;
    end;
     c = 0
    proof
    assume A14: c <> 0;
       0 <= c;
    then n + c > n + 0 by A14,XREAL_1:8;
    hence thesis by A4,A6,A9;
    end;
  hence (compint(n)).(a) = 0 by A1,A3,A5,Def12;
end;
A15: (compint(n)).(a) = 0 implies a = 0
    proof
    assume (compint(n)).(a) = 0;
    then A16: (n - a) mod n = 0 by A1,Def12;
    assume A17: a <> 0;
    A18: n - a < n
         proof
            n <= n + a by NAT_1:29;
         then A19: n - a <= (n + a) - a by XREAL_1:11;
            n - a <> n by A17;
         hence thesis by A19,REAL_1:def 5;
         end;
       a - a < n - a by A2,XREAL_1:11;
    then reconsider a' = n - a as Nat by INT_1:16;
    consider t being Nat such that
    A20: (a' = n * t + (a' mod n) & a' mod n < n) by A1,NAT_1:def 2;
       t = 0
         proof
         assume A21: t <> 0;
          A22: t >= 0;
            1 <= t
            proof
               1 + 0 <= t by A21,A22,INT_1:20;
            hence thesis;
            end;
         then A23: 1 * n <= t * n by XREAL_1:66;
            t * n <= t * n + (a' mod n) by NAT_1:29;
         hence thesis by A18,A20,A23,XXREAL_0:2;
         end;
    then a' = 0 by A2,A16,A20,Lm13;
    then (n - a) + a = a;
    hence thesis by A1,GR_CY_1:10;
    end;
A24: (compint(n)).(a) = n - a implies a <> 0
    proof
    assume (compint(n)).(a) = n - a;
    then A25: (n - a) mod n = n - a by A1,Def12;
    assume A26: a = 0;
    then reconsider a' = n - a as Nat by ORDINAL2:def 21;
       a' mod n < n by A1,NAT_1:46;
    hence thesis by A25,A26,Lm13;
    end;
   now assume A27: a <> 0;
  A28: n - a < n
      proof
      assume n - a >= n;
      then n - a = n by A6,XXREAL_0:1;
      then (n - a) + -n = 0;
      then a = a + -a .= 0;
      hence thesis by A27;
      end;
     t = 0
    proof
    assume A29: t <> 0;
       0 <= t;
    then 1 + 0 <= t by A29,INT_1:20;
    then A30: 1 * n <= t * n by XREAL_1:66;
       n * t <= n * t + c by NAT_1:29;
    hence thesis by A1,A4,A28,A30,XXREAL_0:2;
    end;
  hence (compint(n)).(a) = n - a by A1,A3,A4,A5,Def12;
end;
hence thesis by A7,A15,A24;
end;

definition let n be natural number;
func INT.Ring(n) -> doubleLoopStr equals
 doubleLoopStr(#Segm(n),addint(n),multint(n),In (1,Segm(n)),In (0,Segm(n))#);
coherence;
end;

registration let n be natural number;
 cluster INT.Ring(n) -> strict non empty;
coherence
  proof
   thus INT.Ring n is strict &
         the carrier of INT.Ring n is non empty;
  end;
end;

theorem Th20:
INT.Ring 1 is degenerated & INT.Ring 1 is Ring &
INT.Ring 1 is Field-like unital distributive commutative
proof
set n = 1,
    R = INT.Ring n;
A1: for x being Element of R st x <> 0.R
    ex y be Element of R st x*y = 1.R
    proof
    let x be Element of R;
    assume x <> 0.R;
    then x <> In (0,Segm(1));
    then x <> 0 by FUNCT_7:def 1;
    hence thesis by GR_CY_1:13,TARSKI:def 1;
    end;
A2: 0.R = 0 by GR_CY_1:13,TARSKI:def 1 .= 1.R by GR_CY_1:13,TARSKI:def 1;
A3: for a,b being Element of R holds a + b = b + a
    proof
    let a,b be Element of R;
    thus a + b = 0 by GR_CY_1:13,TARSKI:def 1 .= b + a by GR_CY_1:13
,TARSKI:def 1;
    end;
A4: for a,b being Element of R holds a * b = b * a
    proof
    let a,b be Element of R;
    thus a * b = 0 by GR_CY_1:13,TARSKI:def 1 .= b * a by GR_CY_1:13
,TARSKI:def 1;
    end;
A5: for a,b,c being Element of R holds
    (a + b) + c = a + (b + c)
    proof
    let a,b,c be Element of R;
    thus (a + b) + c = 0 by GR_CY_1:13,TARSKI:def 1 .= a + (b + c) by
GR_CY_1:13,TARSKI:def 1;
    end;
A6: for a,b,c being Element of R holds
    (a * b) * c = a * (b * c)
    proof
    let a,b,c be Element of R;
    thus (a * b) * c = 0 by GR_CY_1:13,TARSKI:def 1 .= a * (b * c) by
GR_CY_1:13,TARSKI:def 1;
     end;
A7: for a being Element of R holds
    a + 0.R = a
    proof
    let a be Element of R;
       a = 0 by GR_CY_1:13,TARSKI:def 1;
    hence thesis by GR_CY_1:13,TARSKI:def 1;
    end;
A8: for a being Element of R holds
    a + (-a) = 0.R
    proof
    let a be Element of R;
    thus a + (-a) = 0 by GR_CY_1:13,TARSKI:def 1 .= 0.R by GR_CY_1:13
,TARSKI:def 1;
    end;
A9: for a being Element of R holds
    1.R * a = a & a * 1.R = a
    proof
    let a be Element of R;
    A10: 1.R * a = 0 by GR_CY_1:13,TARSKI:def 1 .= a by GR_CY_1:13
,TARSKI:def 1;
       a * 1.R = 0 by GR_CY_1:13,TARSKI:def 1 .= a by GR_CY_1:13
,TARSKI:def 1;
    hence thesis by A10;
    end;
A11: for a,b,c being Element of R holds
    (b + c) * a = b * a + c * a
    proof
    let a,b,c be Element of R;
    thus (b + c) * a = 0 by GR_CY_1:13,TARSKI:def 1 .= b * a + c * a by
GR_CY_1:13,TARSKI:def 1;
    end;
A12: for a,b,c being Element of R holds
    a * (b + c) = a * b + a * c
    proof
    let a,b,c be Element of R;
    thus a * (b + c) = 0 by GR_CY_1:13,TARSKI:def 1 .= a * b + a * c by
GR_CY_1:13,TARSKI:def 1;
    end;
A13: R is right_complementable
     proof
       let v be Element of R;
       take -v;
       thus v + -v = 0.R by A8;
     end;
     R is left_unital
     proof
      let x be Element of R;
      thus (1.R)*x = x by A9;
     end;
hence thesis by A1,A2,A3,A4,A5,A6,A7,A9,A11,A12,A13,GROUP_1:def 4,def 16
,def 2,RLVECT_1:def 5,def 6,def 7,VECTSP_1:def 18,def 20,def 21,
VECTSP_1:def 13;
end;

registration
 cluster strict degenerated unital distributive Field-like commutative Ring;
existence by Th20;
end;

Lm15:
now
  let a, n be natural number;
  assume
A1:  n > 0;
  assume a in Segm n;
  then a < n by A1,GR_CY_1:10;
then A2: n-a is Nat by INT_1:18;
  assume a > 0;
  then n-a < n-0 by REAL_1:92;
  hence n-a in Segm n by A2,GR_CY_1:10;
end;

Lm16:
for n being natural number st 0 < n
for e, h being Element of INT.Ring(n) st e = 1 holds
h*e=h & e*h=h
proof
  let n be natural number;
  assume
A1: 0 < n;
  set M = INT.Ring(n);
  let e, h be Element of M such that
A2: e = 1;
  reconsider a=h, b=e as Element of Segm(n);
  reconsider a1 = a as Element of NAT;
A3: a1 < n by A1,GR_CY_1:10;
  thus h*e = (multint(n)).(a,b)
  .= (a * 1) mod n by A2,A1,Def11
  .= h by A3,NAT_1:76;
  thus e*h = (multint(n)).(b,a)
  .= (a * 1) mod n by A2,A1,Def11
  .= h by A3,NAT_1:76;
end;

Lm17: now
  let n be natural number;
  assume
A1: 1 < n;
  thus INT.Ring(n) is unital
  proof
    set M = INT.Ring(n);
    reconsider e = 1 as Element of M by A1,GR_CY_1:10;
    take e;
    thus thesis by A1,Lm16;
  end;
end;

Lm18:
for n being natural number st 1 < n holds 1.INT.Ring(n) = 1
proof
  let n be natural number;
  set M = INT.Ring(n);
  assume
A1: 1 < n;
  then
A2: M is unital by Lm17;
  reconsider e = 1 as Element of M by A1,GR_CY_1:10;
  for x being Element of M holds x*e=x & e*x=x by A1,Lm16;
  hence thesis by A2,GROUP_1:def 5;
end;

theorem Th21:
for n being natural number st n > 1 holds
 INT.Ring(n) is non degenerated &
 INT.Ring(n) is unital distributive commutative Ring
 proof
 let n be natural number;
 assume A1: n > 1;
 then 1 < n + 1 by NAT_1:38;
 then A2: 1 - 1 < (n + 1) - 1 by XREAL_1:11;
 A3: n <> 0 by A1;
 set F = INT.Ring(n);
 A4: 0 in Segm(n) by A2,GR_CY_1:10;
 A5: 0.F = In (0,Segm(n))
        .= 0 by A4,FUNCT_7:def 1;
 A6: 1.F = 1 by A1,Lm18;
 A7: for a,b being Element of F holds a + b = b + a
     proof
     let a,b be Element of F;
     reconsider a' = a as Element of Segm(n);
     reconsider b' = b as Element of Segm(n);
        now per cases;
     case A8: a' + b' < n;
       hence (addint(n)).(a,b) = a' + b' by Th17
                             .= (addint(n)).(b,a) by A8,Th17;
     end;
     case A9: a' + b' >= n;
       hence (addint(n)).(a,b) = (a' + b') - n by A2,Th17
                             .= (addint(n)).(b,a) by A2,A9,Th17;
     end;
     end;
     hence thesis;
     end;
 A10: for a,b being Element of F holds a * b = b * a
     proof
     let a,b be Element of F;
     reconsider a' = a as Element of Segm(n);
     reconsider b' = b as Element of Segm(n);
     consider k being Nat such that
     A11: k * n <= a' * b' & a' * b' < (k + 1) * n by A3,Lm14;
        (multint(n)).(a',b') = a' * b' - k * n by A2,A11,Th18
                              .= (multint(n)).(b',a') by A2,A11,Th18;
     hence a * b = (the mult of F).(b,a)
               .= b * a;
     end;
 A12: for a,b,c being Element of F holds
     (a + b) + c = a + (b + c)
     proof
     let a,b,c be Element of F;
     reconsider a' = a, b' = b, c' = c as Element of Segm(n);
     reconsider aa = a' as Nat; reconsider aa as Integer;
     reconsider bb = b' as Nat; reconsider bb as Integer;
     reconsider cc = c' as Nat; reconsider cc as Integer;
     A13: aa >= 0 & aa < n & bb >= 0 & bb < n & cc >= 0 & cc < n
 by A2,GR_CY_1:10;
     A14: (aa + bb) mod n = (a' + b') mod n by NEWTON:101;
        (aa + bb) mod n >= 0 & (aa + bb) mod n < n by A2,Th9;
     then A15: (a' + b') mod n is Element of Segm(n) by A14,GR_CY_1:10;
     A16: (bb + cc) mod n = (b' + c') mod n by NEWTON:101;
        (bb + cc) mod n >= 0 & (bb + cc) mod n < n by A2,Th9;
     then A17: (b' + c') mod n is Element of Segm(n) by A16,GR_CY_1:10;
     A18: (a + b) + c
         = (the add of F).[a+b,c]
        .= (addint(n)).(a+b,c)
        .= (addint(n)).((the add of F).[a,b],c)
        .= (addint(n)).((addint(n)).(a,b),c)
        .= (addint(n)).((a' + b') mod n, c') by A2,GR_CY_1:def 5
        .= (((a' + b') mod n) + c') mod n by A2,A15,GR_CY_1:def 5;
     A19: a + (b + c)
         = (the add of F).[a,b+c]
        .= (addint(n)).(a,b+c)
        .= (addint(n)).(a,(the add of F).[b,c])
        .= (addint(n)).(a,(addint(n)).(b,c))
        .= (addint(n)).(a', (b' + c') mod n) by A2,GR_CY_1:def 5
        .= (a' + ((b' + c') mod n)) mod n by A2,A17,GR_CY_1:def 5;
           (a' + ((b' + c') mod n)) mod n
      = (aa + (bb + cc mod n)) mod n by A16,NEWTON:101
     .= ((aa mod n) + (bb + cc mod n)) mod n by A13,Th10
     .= (aa + (bb + cc)) mod n by Th14
     .= ((aa + bb) + cc) mod n
     .= (((aa + bb) mod n) + (cc mod n)) mod n by Th14
     .= (((a' + b') mod n) + cc) mod n by A13,A14,Th10
     .= (((a' + b') mod n) + c') mod n by NEWTON:101;
     hence thesis by A18,A19;
     end;
 A20: for a,b,c being Element of F holds
     (a * b) * c = a * (b * c)
     proof
     let a,b,c be Element of F;
     reconsider a' = a, b' = b, c' = c as Element of Segm(n);
     reconsider aa = a' as Nat; reconsider aa as Integer;
     reconsider bb = b' as Nat; reconsider bb as Integer;
     reconsider cc = c' as Nat; reconsider cc as Integer;
     A21: aa >= 0 & aa < n & bb >= 0 & bb < n & cc >= 0 & cc < n
 by A2,GR_CY_1:10;
     A22: (aa * bb) mod n = (a' * b') mod n by NEWTON:101;
        (aa * bb) mod n >= 0 & (aa * bb) mod n < n by A2,Th9;
     then A23: (a' * b') mod n is Element of Segm(n) by A22,GR_CY_1:10;
     A24: (bb * cc) mod n = (b' * c') mod n by NEWTON:101;
        (bb * cc) mod n >= 0 & (bb * cc) mod n < n by A2,Th9;
     then A25: (b' * c') mod n is Element of Segm(n) by A24,GR_CY_1:10;
     A26: (a * b) * c
         = (multint(n)).(a*b,c)
        .= (multint(n)).((multint(n)).(a,b),c)
        .= (multint(n)).((a' * b') mod n, c') by A2,Def11
        .= (((a' * b') mod n) * c') mod n by A2,A23,Def11;
     A27: a * (b * c)
         = (multint(n)).(a,b*c)
        .= (multint(n)).(a,(multint(n)).(b,c))
        .= (multint(n)).(a', (b' * c') mod n) by A2,Def11
        .= (a' * ((b' * c') mod n)) mod n by A2,A25,Def11;
           (a' * ((b' * c') mod n)) mod n
      = (aa * (bb * cc mod n)) mod n by A24,NEWTON:101
     .= ((aa mod n) * (bb * cc mod n)) mod n by A21,Th10
     .= (aa * (bb * cc)) mod n by Th15
     .= ((aa * bb) * cc) mod n
     .= (((aa * bb) mod n) * (cc mod n)) mod n by Th15
     .= (((a' * b') mod n) * cc) mod n by A21,A22,Th10
     .= (((a' * b') mod n) * c') mod n by NEWTON:101;
     hence thesis by A26,A27;
     end;
 A28: for a being Element of F holds a + 0.F = a
     proof
     let a be Element of F;
     A29: a + 0.F = (the add of F).[a,0.F]
                 .= (addint(n)).(a,0) by A5;
     reconsider a' = a as Element of Segm(n);
     A30: 0 is Element of Segm(n) by A2,GR_CY_1:10;
        a' + 0 < n by A2,GR_CY_1:10;
     hence thesis by A29,A30,Th17;
     end;
 A31: for a being Element of F holds
     1.F * a = a & a * 1.F = a
     proof
     let a be Element of F;
     reconsider a' = a as Element of Segm(n);
     A32: (0 * n <= 1 * a' & 1 * a' < (0 + 1) * n) by A2,GR_CY_1:10;
     A33: 1 is Element of Segm(n) by A1,GR_CY_1:10;
     then A34: (multint(n)).(1,a) = a' - 0 * n by A32,Th18
                                 .= a';
        (multint(n)).(a,1) = a' - 0 * n by A32,A33,Th18
                            .= a';
     hence thesis by A6,A34;
     end;
 A35: for a,b,c being Element of F holds
     (b + c) * a = b * a + c * a
     proof
     let a,b,c be Element of F;
     reconsider a' = a, b' = b, c' = c as Element of Segm(n);
     reconsider aa = a' as Nat; reconsider aa as Integer;
     reconsider bb = b' as Nat; reconsider bb as Integer;
     reconsider cc = c' as Nat; reconsider cc as Integer;
     A36: aa >= 0 & aa < n & bb >= 0 & bb < n & cc >= 0 & cc < n
 by A2,GR_CY_1:10;
     A37: (bb + cc) mod n = (b' + c') mod n by NEWTON:101;
        (bb + cc) mod n >= 0 & (bb + cc) mod n < n by A2,Th9;
     then A38: (b' + c') mod n is Element of Segm(n) by A37,GR_CY_1:10;
     A39: (bb * aa) mod n = (b' * a') mod n by NEWTON:101;
        (bb * aa) mod n >= 0 & (bb * aa) mod n < n by A2,Th9;
     then A40: (b' * a') mod n is Element of Segm(n) by A39,GR_CY_1:10;
     A41: (cc * aa) mod n = (c' * a') mod n by NEWTON:101;
        (cc * aa) mod n >= 0 & (cc * aa) mod n < n by A2,Th9;
     then A42: (c' * a') mod n is Element of Segm(n) by A41,GR_CY_1:10;
     A43: (b + c) * a
         = (multint(n)).(b+c,a)
        .= (multint(n)).((the add of F).[b,c],a)
        .= (multint(n)).((addint(n)).(b,c),a)
        .= (multint(n)).((b' + c') mod n, a') by A2,GR_CY_1:def 5
        .= (((b' + c') mod n) * a') mod n by A2,A38,Def11;
     A44: b * a + c * a
         = (the add of F).[b*a,c*a]
        .= (addint(n)).(b*a,c*a)
        .= (addint(n)).(b*a,(multint(n)).(c,a))
        .= (addint(n)).((multint(n)).(b,a),(multint(n)).(c,a))
        .= (addint(n)).((multint(n)).(b,a),(c' * a') mod n) by A2,Def11
        .= (addint(n)).((b' * a') mod n,(c' * a') mod n) by A2,Def11
        .= (((b' * a') mod n) + ((c' * a') mod n)) mod n
 by A2,A40,A42,GR_CY_1:def 5;
           (((b' * a') mod n) + ((c' * a') mod n)) mod n
      = (((bb * aa) mod n) + ((cc * aa) mod n)) mod n by A39,A41,NEWTON:101
     .= (bb * aa + cc * aa) mod n by Th14
     .= ((bb + cc) * aa) mod n
     .= (((bb + cc) mod n) * (aa mod n)) mod n by Th15
     .= (((b' + c') mod n) * aa) mod n by A36,A37,Th10
     .= (((b' + c') mod n) * a') mod n by NEWTON:101;
     hence thesis by A43,A44;
     end;
 A45: for a,b,c being Element of F holds
     a * (b + c) = a * b + a * c
     proof
     let a,b,c be Element of F;
     thus a * (b + c) = (b + c) * a by A10
                     .= b * a + c * a by A35
                     .= a * b + c * a by A10
                     .= a * b + a * c by A10;
     end;
 A46: F is right_complementable
      proof
        let a be Element of F;
        reconsider a' = a as Element of Segm(n);
        reconsider a' as Nat;
        per cases;
        suppose A47: a' = 0;
        take 0.F;
        thus a + 0.F = 0.F by A5,A28,A47;
        end;
        suppose a' <> 0;
        then a' > 0;
        then reconsider b = n-a' as Element of Segm n by A2,Lm15;
        reconsider v = b as Element of F;
        take v;
        thus a + v
           = (the add of F).[a,v]
          .= (the add of F).(a,v)
          .= (a'+b) mod n by A2,GR_CY_1:def 5
          .= 0.F by A5,NAT_1:77;
      end;
      end;
 A48: F is right_unital
      proof
       let x be Element of F;
       thus x*(1.F) = x by A31;
      end;
      F is left_unital
      proof
       let x be Element of F;
       thus (1.F)*x = x by A31;
      end;
 then reconsider F as commutative Ring by A7,A10,A12,A20,A28,A35,A45,A46,A48,
GROUP_1:def 4,def 16,RLVECT_1:def 5,def 6,def 7,VECTSP_1:def 18;
    F is non degenerated by A5,A6,VECTSP_1:def 21;
 hence thesis;
end;

Lm19: for p being natural number st p > 0 holds 0.(INT.Ring(p)) = 0
proof
let p be natural number; assume A1: p > 0;
A2: 0 in Segm(p) by A1,GR_CY_1:12;
thus 0.(INT.Ring(p)) = In (0,Segm(p))
             .= 0 by A2,FUNCT_7:def 1;
end;

theorem
Th22:for p being natural number st p > 1 holds
 INT.Ring(p) is add-associative right_zeroed right_complementable
    Abelian commutative associative left_unital distributive
      Field-like non degenerated (non empty doubleLoopStr)
  iff p is Prime
proof
let p be natural number; assume A1: p > 1;
then p > 1 + 0;
then A2: p >= 0 & p <> 0 & p > 0;
reconsider P = INT.Ring(p) as Ring by A1,Th21;
    reconsider p as Nat by ORDINAL2:def 21;
A3: now assume A4: p is Prime;
      for a being Element of P st a <> 0.P
   ex b be Element of P st a * b = 1.P
    proof
    let a be Element of P; assume A5: a <> 0.P;
    reconsider a' = a as Element of Segm(p);
    reconsider a' as Nat;
    A6: abs(a') = a & abs(p) = p by ABSVALUE:def 1;
       1 * a' = a' & 1 * p = p;
    then A7: 1 divides a' & 1 divides p by NAT_1:def 3;
       for m being Nat st m divides a' & m divides p holds m divides 1
      proof
      let m be Nat; assume A8: m divides a' & m divides p;
      then consider k being Nat such that A9: a' = m * k by NAT_1:def 3;
         m <= a'
        proof
        assume A10: m > a';
           now per cases;
        case k = 0; hence thesis by A2,A5,A9,Lm19;
        end;
        case A11: k <> 0;
           A12: k >= 0;
          then k >= 1 + 0 by A11,INT_1:20;
          then k * a' >= 1 * a' by XREAL_1:66;
          hence thesis by A9,A10,A11,A12,XREAL_1:70;
        end;
        end;
        hence thesis;
        end;
      then m <> p by A2,GR_CY_1:10;
      hence thesis by A4,A8,INT_2:def 5;
      end;
    then a' hcf p = 1 by A7,NAT_1:def 5;
    then a' gcd p = 1 by A6,INT_2:def 3;
    then consider s,t being Integer such that
    A13: 1 = s * a' + t * p by Th16;
    A14: s mod p >= 0 & s mod p < p by A2,Th9;
    then s mod p is Nat by INT_1:16;
    then reconsider b' = s mod p as Element of Segm(p) by A14,GR_CY_1:10;
    reconsider b' as Nat;
    reconsider b = b' as Element of P;
    reconsider b2 = b' as Integer; reconsider a2 = a' as Integer;
    reconsider e = 1 as Integer;
       a * b = (multint(p)).(a',b')
         .= (a' * b') mod p by A2,Def11
         .= (a2 * b2) mod p by NEWTON:101
         .= ((a2 mod p) * ((s mod p) mod p)) mod p by Th15
         .= ((a2 mod p) * (s mod p)) mod p by Th13
         .= (a2 * s) mod p by Th15
         .= e mod p by A13,Th8
         .= e by A1,Th10
         .= 1.P by A1,Lm18;
    hence thesis;
    end;
   hence INT.Ring(p) is add-associative right_zeroed right_complementable
    Abelian commutative associative left_unital distributive
      Field-like non degenerated (non empty doubleLoopStr) by A1,Th21,
VECTSP_1:def 20;
   end;
   now assume A15: INT.Ring(p) is add-associative right_zeroed
right_complementable
    Abelian commutative associative left_unital distributive
      Field-like non degenerated (non empty doubleLoopStr);
      for n being Nat holds n divides p implies n = 1 or n = p
     proof
     let n be Nat; assume n divides p;
     then consider k being Nat such that A16: p = n * k by NAT_1:def 3;
     A17: k <= p
         proof
         assume A18: k > p;
            now per cases;
         case n = 0; hence thesis by A1,A16;
         end;
         case A19: n <> 0;
            A20: n >= 0;
           then n >= 1 + 0 by A19,INT_1:20;
           then n * p >= 1 * p by XREAL_1:66;
           hence thesis by A16,A18,A19,A20,XREAL_1:70;
         end;
         end;
         hence thesis;
         end;
     A21: n <= p
         proof
         assume A22: n > p;
            now per cases;
         case k = 0; hence thesis by A1,A16;
         end;
         case A23: k <> 0;
            A24: k >= 0;
           then k >= 1 + 0 by A23,INT_1:20;
           then k * p >= 1 * p by XREAL_1:66;
           hence thesis by A16,A22,A23,A24,XREAL_1:70;
         end;
         end;
         hence thesis;
         end;
        now per cases;
     case k = p;
       then 1 * p = p * n by A16;
       hence thesis by A2,XCMPLX_1:5;
     end;
     case k <> p;
       then A25: k < p by A17,REAL_1:def 5;
          now per cases;
       case n = p;
         then 1 * p = k * p by A16;
         then k = 1 by A2,XCMPLX_1:5;
         hence thesis by A16;
       end;
       case n <> p;
         then n < p by A21,REAL_1:def 5;
         then reconsider n2 = n as Element of Segm(p) by GR_CY_1:10;
         reconsider n' = n2 as Element of INT.Ring(p);
         reconsider k2 = k as Element of Segm(p) by A25,GR_CY_1:10;
         reconsider k' = k2 as Element of INT.Ring(p);
         reconsider n, k as Integer;
            n <> 0 & k <> 0 by A1,A16;
         then A26: n <> 0.(INT.Ring(p)) & k <> 0.(INT.Ring(p)) by A2,Lm19;
            n' * k' = (multint(p)).(n2,k2)
                .= (n2 * k2) mod p by A2,Def11
                .= (n * k) mod p by NEWTON:101
                .= 0 by A2,A16,Th11
                .= 0.(INT.Ring(p)) by A2,Lm19;
         hence contradiction by A15,A26,VECTSP_1:44;
       end;
       end;
       hence thesis;
     end;
     end;
     hence thesis;
     end;
   hence p is Prime by A1,INT_2:def 5;
   end;
hence thesis by A3;
end;

registration
let p be Prime;
 cluster INT.Ring(p) -> add-associative right_zeroed right_complementable
   Abelian commutative associative left_unital distributive Field-like
    non degenerated;
coherence
 proof
    p > 1 by INT_2:def 5; hence thesis by Th22;
 end;
end;

theorem
  1.INT.Ring = 1 by Lm5;

theorem
  for n being natural number st 1 < n holds 1.INT.Ring(n) = 1 by Lm18;

