:: The Ring of Integers, Euclidean Rings and Modulo Integers
::  by Christoph Schwarzweller
::
:: Received February 4, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies BINOP_1, INT_1, FUNCT_1, VECTSP_1, RELAT_1, ARYTM_1, GR_CY_1,
      FUNCT_7, RLVECT_1, VECTSP_2, LATTICES, ABSVALUE, EUCLID, NAT_1, FUNCSDOM,
      GCD_1, ARYTM_3, INT_2, MCART_1, ORDINAL2, NAT_LAT, INT_3, ARYTM, GROUP_1,
      XREAL_0;
 notations TARSKI, SUBSET_1, ORDINAL1, CARD_1, NUMBERS, XCMPLX_0, COMPLEX1,
      MCART_1, RELAT_1, FUNCT_1, FUNCT_2, FUNCSDOM, BINOP_1, EUCLID,
      XXREAL_0, BINOP_2, GR_CY_1, INT_1, FUNCT_7, NEWTON, INT_2, NAT_D,
      STRUCT_0, ALGSTR_0, RLVECT_1, GCD_1, GROUP_1, VECTSP_1, VECTSP_2, NAT_1;
 constructors DOMAIN_1, XXREAL_0, REAL_1, NAT_1, NAT_D, BINOP_2, NEWTON,
      FUNCT_7, GR_CY_1, EUCLID, GCD_1, SEQ_1, RELSET_1, GROUP_2;
 registrations XBOOLE_0, FUNCT_1, ORDINAL1, RELSET_1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, NEWTON, STRUCT_0, VECTSP_1, GR_CY_1, GCD_1,
      VALUED_0, REAL_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions RLVECT_1, STRUCT_0, GROUP_1, VECTSP_1, VECTSP_2, CARD_1, ALGSTR_0,
      GR_CY_1;
 theorems TARSKI, BINOP_1, FUNCT_1, FUNCT_2, VECTSP_1, INT_1, RELAT_1, GCD_1,
      RLVECT_1, EUCLID, ABSVALUE, GR_CY_1, FUNCT_7, NAT_1, MCART_1, INT_2,
      RELSET_1, XREAL_0, ORDINAL1, XCMPLX_0, XCMPLX_1, NUMBERS, BINOP_2,
      GROUP_1, XREAL_1, COMPLEX1, XXREAL_0, NAT_D, STRUCT_0, NEWTON, CARD_1;
 schemes NAT_1, BINOP_1, LMOD_7, BINOP_2;

begin

definition
  redefine func multint means
  :Def1:
  for a,b being Element of INT holds it.(a,
  b) = multreal.(a,b);
  compatibility
  proof
    let b be BinOp of INT;
    hereby
      assume
A1:   b = multint;
      let i1,i2 be Element of INT;
      thus b.(i1,i2) = i1 * i2 by A1,BINOP_2:def 22
        .= multreal.(i1,i2) by BINOP_2:def 11;
    end;
    assume
A3: for i1,i2 being Element of INT holds b.(i1,i2) = multreal.(i1,i2);
    now
      let i1,i2 be Element of INT;
      thus b.(i1,i2) = multreal.(i1,i2) by A3
        .= i1 * i2 by BINOP_2:def 11
        .= multint.(i1,i2) by BINOP_2:def 22;
    end;
    hence b = multint by BINOP_1:2;
  end;
end;

definition
  redefine func compint means
  for a being Element of INT holds it.(a) =
  compreal.(a);
  compatibility
  proof
    let b be UnOp of INT;
    hereby
      assume
A1:   b = compint;
      let i be Element of INT;
      thus b.i = -i by A1,BINOP_2:def 19
        .= compreal.i by BINOP_2:def 7;
    end;
    assume
A3: for i being Element of INT holds b.i = compreal.i;
    now
      let i be Element of INT;
      thus b.i = compreal.i by A3
        .= -i by BINOP_2:def 7
        .= compint.i by BINOP_2:def 19;
    end;
    hence b = compint by FUNCT_2:113;
  end;
end;

definition
  func INT.Ring -> doubleLoopStr equals
  doubleLoopStr(#INT,addint,multint,In (
    1,INT),In (0,INT)#);
  coherence;
end;

Lm1: for x being Element of INT.Ring holds x in REAL
proof
  let x be Element of INT.Ring;
  x in INT;
  hence thesis by NUMBERS:15;
end;

registration
  cluster INT.Ring -> strict non empty;
  coherence;
end;

registration
  cluster -> integer Element of INT.Ring;
  coherence;
end;

registration
  let a,b be Element of INT.Ring, c,d be Integer;
  identify a * b with c * d when a = c, b = d;
  compatibility
  proof
    assume
A1: a = c & b = d;
    reconsider a, b as Element of INT;
    multint.(a,b) = multreal.(a,b) by Def1
      .= c * d by A1,BINOP_2:def 11;
    hence thesis;
  end;
  identify a + b with c + d when a = c, b = d;
  compatibility
  proof
    assume
A3: a = c & b = d;
    reconsider a, b as Element of INT;
    addint.(a,b) = addreal.(a,b) by GR_CY_1:def 2
      .= c + d by A3,BINOP_2:def 9;
    hence thesis;
  end;
end;
set M = INT.Ring;

Lm2: 0 in INT by INT_1:def 2;
then
Lm3: 0 = 0.M by FUNCT_7:def 1;

registration
  cluster INT.Ring -> well-unital;
  coherence
  proof
    let x be Element of INT.Ring;
     1 in INT by INT_1:def 2;
     then 1 = 1.M by FUNCT_7:def 1;
   hence thesis;
  end;
end;

Lm5: 1_M = 1
proof
  reconsider e = 1 as Element of M by INT_1:def 1;
  for x being Element of M holds x*e=x & e*x=x;
  then 1_INT.Ring = e by GROUP_1:def 5;
  hence thesis;
end;

registration
  cluster INT.Ring -> Abelian add-associative right_zeroed
    right_complementable distributive commutative associative domRing-like non
    degenerated;
  coherence
  proof
    thus for a,b be Element of M holds a + b = b + a;
    thus for a,b,c be Element of M holds (a + b) + c = a + (b + c);
    hereby
      reconsider t = 0 as Element of REAL;
      let a be Element of M;
      reconsider a' = a as Element of REAL by Lm1;
A1:   addreal.(a',t) = a' + t by BINOP_2:def 9
        .= a;
      a + 0.M = addreal.(a,0.M) by GR_CY_1:def 2
        .= addreal.(a,0) by Lm2,FUNCT_7:def 1;
      hence a + 0.M = a by A1;
    end;
    thus M is right_complementable
    proof
      let a be Element of M;
      reconsider a' = a as Integer;
      reconsider v = -a' as Element of M;
      take v;
      thus thesis by FUNCT_7:def 1;
    end;
    thus for a,b,c be Element of M holds a*(b+c) = a*b+a*c & (b + c) * a = b *
    a + c * a;
    thus for x,y be Element of M holds x*y = y*x;
    thus for a,b,c be Element of M holds a*b*c = a*(b*c);
    thus for a,b be Element of M st a * b = 0.M holds a = 0.M or b = 0.M by Lm3
,XCMPLX_1:6;
    thus 0.M <> 1.M by Lm2,Lm5,FUNCT_7:def 1;
  end;
end;

registration
  let a be Element of INT.Ring, b be Integer;
  identify -a with -b when a = b;
  compatibility
  proof
    reconsider b' = -b as Element of M;
    assume
    b = a;
    then b' + a = 0.M by FUNCT_7:def 1;
    hence thesis by RLVECT_1:19;
  end;
end;

definition
  canceled;
  let a be Element of INT.Ring;
  redefine func abs(a) -> Element of INT.Ring equals
  a if a >= 0.INT.Ring
  otherwise - a;
  coherence
  proof
    abs(a) in INT by INT_1:def 2;
    hence thesis;
  end;
  compatibility by Lm3,ABSVALUE:def 1;
  consistency;
end;

definition
  func absint -> Function of the carrier of INT.Ring,NAT means
  :Def6:
  for a
  being Element of INT.Ring holds it.a = absreal.(a);
  existence
  proof
    dom(absreal) = REAL by FUNCT_2:def 1;
    then
A1: dom((absreal)|INT) = the carrier of INT.Ring by NUMBERS:15,RELAT_1:91;
    for y being set holds y in rng((absreal)|INT) implies y in NAT
    proof
      let y be set;
      assume
      y in rng((absreal)|INT);
      then consider x being set such that
A2:   [x,y] in (absreal)|INT by RELAT_1:def 5;
A3:   ((absreal)|INT).x = y by A2,FUNCT_1:8;
A4:   x in dom((absreal)|INT) by A2,RELAT_1:def 4;
      then reconsider x as Integer by A1;
A5:   ((absreal)|INT).x = (absreal).x by A1,A4,FUNCT_1:72;
      now
        per cases;
        case
A6:       0 <= x;
          ((absreal)|INT).x = abs(x) by A5,EUCLID:def 2
            .= x by A6,ABSVALUE:def 1;
          hence ((absreal)|INT).x is Element of NAT by A6,INT_1:16;
        end;
        case
A7:       not 0 <= x;
          ((absreal)|INT).x = abs(x) by A5,EUCLID:def 2
            .= -x by A7,ABSVALUE:def 1;
          hence ((absreal)|INT).x is Element of NAT by A7,INT_1:16;
        end;
      end;
      hence thesis by A3;
    end;
    then rng((absreal)|INT) c= NAT by TARSKI:def 3;
    then reconsider
    f = (absreal)|INT as Function of the carrier of INT.Ring,NAT by A1,
FUNCT_2:def 1,RELSET_1:11;
    take f;
    thus thesis by FUNCT_1:72;
  end;
  uniqueness
  proof
    deffunc F(Element of INT.Ring)=absreal.($1);
    thus for f1,f2 being Function of the carrier of INT.Ring,NAT st (for x
being Element of INT.Ring holds f1.x = F(x)) & (for x being Element of INT.Ring
    holds f2.x = F(x)) holds f1 = f2 from BINOP_2:sch 1;
  end;
end;

theorem Th1:
  for a being Element of INT.Ring holds absint.a = abs(a)
proof
  let a be Element of INT.Ring;
  reconsider a' = a as Integer;
  absint.a = absreal.a' by Def6
    .= abs(a') by EUCLID:def 2;
  hence thesis;
end;

Lm6: for a being Integer holds a = 0 or absreal.a >= 1
proof
  let a be Integer;
  assume
A1: a <> 0;
  now
    per cases;
    case
      0 <= a;
      then reconsider a as Element of NAT by INT_1:16;
A2:   absreal.(a) = abs((a)) by EUCLID:def 2
        .= a by ABSVALUE:def 1;
      0 + 1 < a + 1 by A1,XREAL_1:8;
      hence thesis by A2,NAT_1:13;
    end;
    case
A3:   a < 0;
      then a <= -1 by INT_1:21;
      then
A4:   -(-1) <= -a by XREAL_1:26;
      absreal.(a) = abs((a)) by EUCLID:def 2
        .= -a by A3,ABSVALUE:def 1;
      hence thesis by A4;
    end;
  end;
  hence thesis;
end;

Lm7: for a,b being Element of INT.Ring st b <> 0.INT.Ring for b' being Integer
st b' = b holds 0 <= b' implies ex q,r being Element of INT.Ring st a = q * b +
r & (r = 0.INT.Ring or absint.r < absint.b)

proof
  consider d being Element of M;
  let a,b be Element of M;
  assume
A1: b <> 0.M;
  reconsider a' = a as Integer;
  let b' be Integer;
  assume
A2: b' = b;
  defpred P[Nat] means ex s being Integer st $1 = a' - s * b';
  assume
A3: 0 <= b';
A4: ex k being Nat st P[k]
  proof
    now
      per cases;
      case
        0 <= a';
        then reconsider a' as Element of NAT by INT_1:16;
        a' - 0 * b' = a';
        hence thesis;
      end;
      case
A5:     a' < 0;
        1 + 0 <= b' by A1,A2,A3,Lm3,INT_1:20;
        then 1 - 1 <= b' - 1 by XREAL_1:11;
        then reconsider m = b' - 1 as Element of NAT by INT_1:16;
        reconsider n = -a' as Element of NAT by A5,INT_1:16;
        a' - a' * b' = (-a') * (b' - 1) & n * m is Element of NAT;
        hence thesis;
      end;
    end;
    hence thesis;
  end;

  ex k being Nat st P[k] & for n being Nat st P[n] holds k <= n from
  NAT_1:sch 5(A4);

  then consider k' being Nat such that

A6: ex s being Integer st k' = a' - s * b' & for n being Nat st ex s'
  being Integer st n = a' - s' * b' holds k' <= n;

  consider l' being Integer such that
A7: k' = a' - l' * b' by A6;
  reconsider k = k',l = l' as Element of M by INT_1:def 2;
A8: k' = 0 or k' < b'
  proof
    assume
    k' <> 0;
    assume
    b' <= k';
    then reconsider k = k' - b' as Element of NAT by INT_1:18;
A9: k' > k
    proof
      reconsider b' as Element of NAT by A3,INT_1:16;
      assume
      k' <= k;
      then consider x being Nat such that
A10:  k = k' + x by NAT_1:10;
      - x = b' by A10;
      hence contradiction by A1,A2,Lm2,FUNCT_7:def 1;
    end;
    k' - b' = a' - (l' + 1) * b' by A7;
    hence thesis by A6,A9;
  end;
A11: k = 0.M or absint.k < absint.b
  proof
    reconsider b' as Element of NAT by A3,INT_1:16;
    assume
A12: k <> 0.M;
A13: absint.k = absreal.(k) by Def6
      .= abs(k') by EUCLID:def 2
      .= k' by ABSVALUE:def 1;
    absint.b = absreal.(b') by A2,Def6
      .= abs(b') by EUCLID:def 2
      .= b' by ABSVALUE:def 1;
    hence thesis by A8,A12,A13,FUNCT_7:def 1;
  end;
  k + l * b = a by A2,A7;
  hence thesis by A11;
end;

Lm8: for a,b being Element of INT.Ring st b <> 0.INT.Ring for b' being Integer
st b' = b holds 0 <= b' implies ex q,r being Element of INT.Ring st a = q * b +
r & 0.INT.Ring <= r & r < abs(b)

proof
  consider d being Element of M;
  let a,b be Element of M;
  assume
A1: b <> 0.M;
  reconsider a' = a as Integer;
  let b' be Integer;
  assume
A2: b' = b;
  defpred P[Nat] means ex s being Integer st $1 = a' - s * b';
  assume
A3: 0 <= b';
A4: ex k being Nat st P[k]
  proof
    now
      per cases;
      case
        0 <= a';
        then reconsider a' as Element of NAT by INT_1:16;
        a' - 0 * b' = a';
        hence thesis;
      end;
      case
A5:     a' < 0;
        1 + 0 <= b' by A1,A2,A3,Lm3,INT_1:20;
        then 1 - 1 <= b' - 1 by XREAL_1:11;
        then reconsider m = b' - 1 as Element of NAT by INT_1:16;
        reconsider n = -a' as Element of NAT by A5,INT_1:16;
        a' - a' * b' = (-a') * (b' - 1) & n * m is Element of NAT;
        hence thesis;
      end;
    end;
    hence thesis;
  end;

  ex k being Nat st P[k] & for n being Nat st P[n] holds k <= n from
  NAT_1:sch 5(A4);

  then consider k' being Nat such that

A6: ex s being Integer st k' = a' - s * b' & for n being Nat st ex s'
  being Integer st n = a' - s' * b' holds k' <= n;

  consider l' being Integer such that
A7: k' = a' - l' * b' by A6;
  reconsider k = k',l = l' as Element of M by INT_1:def 2;
A8: k' = 0 or k' < b'
  proof
    assume
    k' <> 0;
    assume
    b' <= k';
    then reconsider k = k' - b' as Element of NAT by INT_1:18;
A9: k' > k
    proof
      reconsider b' as Element of NAT by A3,INT_1:16;
      assume
      k' <= k;
      then consider x being Nat such that
A10:  k = k' + x by NAT_1:10;
      - x = b' by A10;
      hence contradiction by A1,A2,Lm2,FUNCT_7:def 1;
    end;
    k' - b' = a' - (l' + 1) * b' by A7;
    hence thesis by A6,A9;
  end;
A11: 0.M <= k & k < abs(b)
  proof
    reconsider b' as Element of NAT by A3,INT_1:16;
    reconsider k' as Element of NAT by ORDINAL1:def 13;
A12: absint.b = absreal.b' by A2,Def6
      .= abs(b') by EUCLID:def 2
      .= b' by ABSVALUE:def 1;
    now
      per cases by A8;
      case
        k' = 0;
        hence thesis by A1,A2,A12,Lm3,Th1;
      end;
      case
        k' < b';
        hence thesis by A12,Lm2,Th1,FUNCT_7:def 1;
      end;
    end;
    hence thesis;
  end;
  k + l * b = a by A2,A7;
  hence thesis by A11;
end;

theorem Th2:
  for a,b,q1,q2,r1,r2 being Element of INT.Ring st b <> 0.INT.Ring
  & a = q1 * b + r1 & 0.INT.Ring <= r1 & r1 < abs(b) & a = q2 * b + r2 & 0.
  INT.Ring <= r2 & r2 < abs(b) holds q1 = q2 & r1 = r2
proof
  let a,b,q1,q2,r1,r2 be Element of INT.Ring;
  assume that
A1: b <> 0.INT.Ring and
A2: a = q1 * b + r1 and
A3: 0.INT.Ring <= r1 and
A4: r1 < abs(b) and
A5: a = q2 * b + r2 and
A6: 0.INT.Ring <= r2 and
A7: r2 < abs(b);
  reconsider r2' = r2 as Integer;
  reconsider r1' = r1 as Integer;
  reconsider q2' = q2 as Integer;
  reconsider q1' = q1 as Integer;
  reconsider b' = b as Integer;
  now
    per cases;
    case
A8:   0 <= r1' - r2';
A9:   (q2' - q1') * b' = r1' - r2' by A2,A5;
      now
        per cases;
        case
          0 = r1' - r2';
          then q2' - q1' = 0 or b' = 0 by A9,XCMPLX_1:6;
          hence q1 = q2 by A1,FUNCT_7:def 1;
        end;
        case
          0 <> r1' - r2';
          then
A10:      0 <> q2' - q1' by A9;
A11:      absreal.(q2' - q1') * absreal.b' >= absreal.b'
          proof
            reconsider e = q2 + -q1 as Element of M;
            reconsider d' = q2' - q1' as Integer;
            absreal.b' = absint.b by Def6;
            then reconsider c = absreal.b' as Element of NAT;
            absreal.d' = absint.e by Def6;
            then reconsider d = absreal.d' as Element of NAT;
            d * c >= 1 * c by A10,Lm6,NAT_1:4;
            hence thesis;
          end;
A12:      r1' + -r2' <= r1' + 0 by A6,Lm3,XREAL_1:8;
A13:      abs(b) = absint.b by Th1
            .= absreal.b by Def6;
          r1' - r2' = abs(((q2' - q1') * b')) by A2,A5,A8,ABSVALUE:def 1
            .= abs((q2' - q1')) * abs(b') by COMPLEX1:151
            .= absreal.(q2' - q1') * abs(b') by EUCLID:def 2
            .= absreal.(q2' - q1') * absreal.b' by EUCLID:def 2;
          hence q1 = q2 by A4,A11,A12,A13,XXREAL_0:2;
        end;
      end;
      hence q1 = q2;
    end;
    case
A14:  r1' - r2' < 0;
      -(r1' - r2') = r2' - r1' & (q1' - q2') * b' = r2' - r1' by A2,A5;
      then
A15:  0 <> q1' - q2' by A14,XREAL_1:60;
A16:  absreal.(q1' - q2') * absreal.b' >= absreal.b'
      proof
        reconsider e = q1 + -q2 as Element of M;
        reconsider d' = q1' - q2' as Integer;
        absreal.b' = absint.b by Def6;
        then reconsider c = absreal.b' as Element of NAT;
        absreal.d' = absint.e by Def6;
        then reconsider d = absreal.d' as Element of NAT;
        d * c >= 1 * c by A15,Lm6,NAT_1:4;
        hence thesis;
      end;
A17:  abs(b) = absint.b by Th1
        .= absreal.b by Def6;
      -(r1' - r2') > 0 by A14,XREAL_1:60;
      then
A18:  r2' - r1' = abs(((q1' - q2') * b')) by A2,A5,ABSVALUE:def 1
        .= abs((q1' - q2')) * abs(b') by COMPLEX1:151
        .= absreal.(q1' - q2') * abs(b') by EUCLID:def 2
        .= absreal.(q1' - q2') * absreal.b' by EUCLID:def 2;
      r2' + -r1' <= r2' + 0 by A3,Lm3,XREAL_1:8;
      hence q1 = q2 by A7,A16,A17,A18,XXREAL_0:2;
    end;
  end;
  hence thesis by A2,A5;
end;

definition
  let a,b be Element of INT.Ring;
  assume
A1: b <> 0.INT.Ring;
  func a div b -> Element of INT.Ring means
  :Def7:
  ex r being Element of
  INT.Ring st a = it * b + r & 0.INT.Ring <= r & r < abs(b);
  existence
  proof
    reconsider b' = b as Integer;
    now
      per cases;
      case
        0 <= b';
        hence thesis by A1,Lm8;
      end;
      case
A2:     b' < 0;
        reconsider c = -b' as Element of M;
        0 < -b' by A2,XREAL_1:60;
        then consider q,r being Element of M such that
A3:     a = q * c + r and
A4:     0.M <= r and
A5:     r < abs(c) by Lm3,Lm8;
        reconsider t = -q as Element of M;
A6:     t * b + r = a by A3;
        absint.c = absreal.c by Def6
          .= abs((-b')) by EUCLID:def 2
          .= -b' by A2,ABSVALUE:def 1
          .= abs((b')) by A2,ABSVALUE:def 1
          .= absreal.b' by EUCLID:def 2
          .= absint.b by Def6
          .= abs(b) by Th1;
        then r < abs(b) by A5,Th1;
        hence thesis by A4,A6;
      end;
    end;
    hence thesis;
  end;
  uniqueness by A1,Th2;
end;

definition
  let a,b be Element of INT.Ring;
  assume
A1: b <> 0.INT.Ring;
  func a mod b -> Element of INT.Ring means
  :Def8:
  ex q being Element of
  INT.Ring st a = q * b + it & 0.INT.Ring <= it & it < abs(b);
  existence
  proof
    reconsider b' = b as Integer;
    now
      per cases;
      case
        0 <= b';
        then
        ex q,r being Element of INT.Ring st a = q * b + r & 0.INT.Ring <=
        r & r < abs(b) by A1,Lm8;
        hence thesis;
      end;
      case
A2:     b' < 0;
        reconsider c = -b' as Element of M;
        0 < -b' by A2,XREAL_1:60;
        then consider q,r being Element of M such that
A3:     a = q * c + r and
A4:     0.M <= r and
A5:     r < abs(c) by Lm3,Lm8;
        reconsider t = -q as Element of M;
A6:     t * b + r = a by A3;
        absint.c = absreal.c by Def6
          .= abs(-b') by EUCLID:def 2
          .= -b' by A2,ABSVALUE:def 1
          .= abs(b') by A2,ABSVALUE:def 1
          .= absreal.b' by EUCLID:def 2
          .= absint.b by Def6
          .= abs(b) by Th1;
        then r < abs(b) by A5,Th1;
        hence thesis by A4,A6;
      end;
    end;
    hence thesis;
  end;
  uniqueness by A1,Th2;
end;

theorem
  for a,b being Element of INT.Ring st b <> 0.INT.Ring holds a = (a div
  b) * b + (a mod b)
proof
  let a,b be Element of INT.Ring;
  consider d being Element of INT.Ring such that
A1: d = (a div b);
  assume
A2: b <> 0.INT.Ring;
  then
  ex r being Element of INT.Ring st a = d * b + r & 0. INT.Ring <= r & r <
  abs(b) by A1,Def7;
  hence thesis by A2,A1,Def8;
end;

begin :: Euclidian Domains

definition
  let I be non empty doubleLoopStr;
  attr I is Euclidian means
  :Def9:
  ex f being Function of the carrier of I,NAT
st for a,b being Element of I st b <> 0.I holds ex q,r being Element of I st a
  = q * b + r & (r = 0.I or f.r < f.b);
end;

registration
  cluster INT.Ring -> Euclidian;
  coherence
  proof
    take absint;
    let a,b be Element of M;
    reconsider b' = b as Integer;
    assume
A1: b <> 0.M;
    now
      per cases;
      case
        0 <= b';
        hence thesis by A1,Lm7;
      end;
      case
A2:     b' < 0;
        reconsider c = -b' as Element of M;
        0 < -b' by A2,XREAL_1:60;
        then consider q,r being Element of M such that
A3:     a = q * c + r and
A4:     r = 0.M or absint.r < absint.c by Lm3,Lm7;
A5:     r = 0.M or absint.r < absint.b
        proof
          assume
A6:       r <> 0.M;
          absint.c = absreal.c by Def6
            .= abs(-b') by EUCLID:def 2
            .= -b' by A2,ABSVALUE:def 1
            .= abs(b') by A2,ABSVALUE:def 1
            .= absreal.(b') by EUCLID:def 2
            .= absint.b by Def6;
          hence thesis by A4,A6;
        end;
        reconsider t = -q as Element of M;
        t * b + r = a by A3;
        hence
        ex q,r being Element of M st a = q * b + r & (r = 0.M or absint.r
        < absint.b) by A5;
      end;
    end;
    hence thesis;
  end;
end;

Lm9: for F being commutative associative well-unital almost_left_invertible
right_zeroed (non empty doubleLoopStr) for f being Function of the carrier of F
,NAT holds (for a,b being Element of F st b <> 0.F holds (ex q,r being Element
of F st (a = q * b + r & (r = 0.F or f.r < f.b))))

proof

  let F be commutative associative well-unital almost_left_invertible
  right_zeroed (non empty doubleLoopStr);

  let f be Function of the carrier of F,NAT;
  now
    let a,b be Element of F;
    assume
A1: b <> 0.F;
    ex q,r being Element of F st a = q * b + r & (r = 0.F or f.r < f.b)
    proof
      consider x being Element of F such that
A2:   x * b = 1.F by A1,VECTSP_1:def 20;
      (a * x) * b + 0.F = a * 1.F + 0.F by A2,GROUP_1:def 4
        .= a + 0.F by VECTSP_1:def 16
        .= a by RLVECT_1:def 7;
      hence thesis;
    end;

    hence
    b <> 0.F implies ex q,r being Element of F st a = q * b + r & (r = 0.
    F or f.r < f.b);

  end;
  hence thesis;
end;

registration
  cluster strict Euclidian domRing-like non degenerated distributive
    commutative Ring;
  existence
  proof
    take INT.Ring;
    thus thesis;
  end;
end;

definition
  mode EuclidianRing is Euclidian domRing-like non degenerated distributive
    commutative Ring;
end;

registration
  cluster strict EuclidianRing;
  existence
  proof
    take INT.Ring;
    thus thesis;
  end;
end;

definition
  let E be Euclidian (non empty doubleLoopStr);
  mode DegreeFunction of E -> Function of the carrier of E,NAT means
    :Def10:
for a,b being Element of E st b <> 0.E holds ex q,r being Element of E st a = q
    * b + r & (r = 0.E or it.r < it.b);
  existence by Def9;
end;

theorem Th4:
  for E being EuclidianRing holds E is gcdDomain
proof
  let E be EuclidianRing;
  consider d being DegreeFunction of E;
  now
    let x,y be Element of E;
    now
      per cases;
      case
A1:     x = 0.E;
        y * 0.E = 0.E by VECTSP_1:36;
        then
A2:     y divides 0.E by GCD_1:def 1;
        for zz being Element of E st zz divides x & zz divides y holds zz
        divides y;
        hence ex z being Element of E st z divides x & z divides y & for zz
being Element of E st zz divides x & zz divides y holds zz divides z by A1,A2;
      end;
      case
A3:     x <> 0.E;
        set M = { z where z is Element of E: ex s,t being Element of E st z =
        s * x + t * y};
        defpred P[Nat] means ex z being Element of E st (z in M & z <> 0.E &
        $1 = d.z);
        1.E * x + 0.E * y = 1.E * x + 0.E by VECTSP_1:39
          .= 1.E * x by RLVECT_1:def 7
          .= x by VECTSP_1:def 16;
        then
A4:     x in M;
        ex k being Element of NAT st k = d.x;
        then
A5:     ex k being Nat st P[k] by A3,A4;
        ex k being Nat st P[k] & for n being Nat st P[n] holds k <= n
        from NAT_1:sch 5(A5);
        then consider k being Nat such that
A6:     ( P[k])& for n being Nat st P[n] holds k <= n;
        consider g being Element of E such that
A7:     g in M and
A8:     g <> 0.E and
A9:     k = d.g & for n being Nat st (ex z being Element of E st z in
        M & z <> 0.E & n = d.z) holds k <= n by A6;
        set G = { z where z is Element of E: ex r being Element of E st z = r
        * g};
A10:    for z being set holds z in M implies z in G
        proof
          let z be set;
          assume
          z in M;
          then consider z2 being Element of E such that
A11:      z = z2 and
A12:      ex s,t being Element of E st z2 = s * x + t * y;
          consider u,v being Element of E such that
A13:      z2 = u * x + v * y by A12;
          reconsider z as Element of E by A11;
          consider q,r being Element of E such that
A14:      z = q * g + r and
A15:      r = 0.E or d.r < d.g by A8,Def10;
          r in M
          proof
            consider z1 being Element of E such that
A16:        g = z1 and
A17:        ex s,t being Element of E st z1 = s * x + t * y by A7;
            consider s,t being Element of E such that
A18:        z1 = s * x + t * y by A17;
            z + (-(q * g)) = r + ((q * g) + (-(q * g))) by A14,RLVECT_1:def 6
              .= r + 0.E by RLVECT_1:def 11
              .= r by RLVECT_1:def 7;
            then r = z + (-(q * (s * x) + q * (t * y))) by A16,A18,
VECTSP_1:def 18
              .= z + ((-(q * (s * x))) + (-(q * (t * y)))) by RLVECT_1:45
              .= ((u * x + v * y) + (-(q * (s * x)))) + (-(q * (t * y))) by A11
,A13,RLVECT_1:def 6
              .= ((u * x + (-(q * (s * x)))) + v * y) + (-(q * (t * y))) by
RLVECT_1:def 6
              .= (u * x + (-(q * (s * x)))) + (v * y + (-(q * (t * y)))) by
RLVECT_1:def 6
              .= (u * x + ((-q) * (s * x))) + (v * y + (-(q * (t * y)))) by
GCD_1:51
              .= (u * x + ((-q) * (s * x))) + (v * y + ((-q) * (t * y))) by
GCD_1:51
              .= (u * x + ((-q) * s) * x) + (v * y + ((-q) * (t * y))) by
GROUP_1:def 4
              .= (u * x + ((-q) * s) * x) + (v * y + ((-q) * t) * y) by
GROUP_1:def 4
              .= (u + ((-q) * s)) * x + (v * y + ((-q) * t) * y) by
VECTSP_1:def 18
              .= (u + ((-q) * s)) * x + (v + ((-q) * t)) * y by VECTSP_1:def 18
;
            hence thesis;
          end;
          then r = 0.E by A9,A15;
          then z = q * g by A14,RLVECT_1:def 7;
          hence thesis;
        end;
A19:    for z being Element of E holds z divides x & z divides y implies
        z divides g
        proof
          let z be Element of E;
          assume that
A20:      z divides x and
A21:      z divides y;
          consider u being Element of E such that
A22:      x = z * u by A20,GCD_1:def 1;
          consider zz being Element of E such that
A23:      g = zz and
A24:      ex s,t being Element of E st zz = s * x + t * y by A7;
          consider s,t being Element of E such that
A25:      zz = s * x + t * y by A24;
          consider v being Element of E such that
A26:      y = z * v by A21,GCD_1:def 1;
          g = (s * u) * z + t * (v * z) by A22,A26,A23,A25,GROUP_1:def 4
            .= (s * u) * z + (t * v) * z by GROUP_1:def 4
            .= (s * u + t * v) * z by VECTSP_1:def 18;
          hence thesis by GCD_1:def 1;
        end;
        0.E * x + 1.E * y = 0.E + 1.E * y by VECTSP_1:39
          .= 1.E * y by RLVECT_1:10
          .= y by VECTSP_1:def 16;
        then
A27:    y in M;
        for z being set holds z in G implies z in M
        proof
          let z be set;
          assume
          z in G;
          then consider z2 being Element of E such that
A28:      z = z2 and
A29:      ex s being Element of E st z2 = s * g;
          reconsider z as Element of E by A28;
          consider u being Element of E such that
A30:      z2 = u * g by A29;
          consider z1 being Element of E such that
A31:      g = z1 and
A32:      ex s,t being Element of E st z1 = s * x + t * y by A7;
          consider s,t being Element of E such that
A33:      z1 = s * x + t * y by A32;
          z = u * (s * x) + u * (t * y) by A28,A30,A31,A33,VECTSP_1:def 11
            .= (u * s) * x + u * (t * y) by GROUP_1:def 4
            .= (u * s) * x + (u * t) * y by GROUP_1:def 4;
          hence thesis;
        end;
        then
A34:    M = G by A10,TARSKI:2;
        g divides x & g divides y
        proof
          (ex zz being Element of E st x = zz & ex r being Element of E
st zz = r * g )& ex zzz being Element of E st y = zzz & ex r being Element of E
          st zzz = r * g by A4,A27,A34;
          hence thesis by GCD_1:def 1;
        end;
        hence ex z being Element of E st z divides x & z divides y & for zz
being Element of E st zz divides x & zz divides y holds zz divides z by A19;
      end;
    end;
    hence ex z being Element of E st z divides x & z divides y & for zz being
    Element of E st zz divides x & zz divides y holds zz divides z;
  end;
  hence thesis by GCD_1:def 11;
end;

registration
  cluster Euclidian -> gcd-like (domRing-like non degenerated Abelian
    add-associative right_zeroed right_complementable associative commutative
    well-unital right-distributive (non empty doubleLoopStr));
  coherence by Th4;
end;

definition
  redefine func absint -> DegreeFunction of INT.Ring;
  coherence
  proof
    for a,b being Element of M st b <> 0.M holds ex q,r being Element of M
    st a = q * b + r & (r = 0.M or absint.r < absint.b)
    proof
      let a,b be Element of M;
      reconsider b' = b as Integer;
      assume
A1:   b <> 0.M;
      now
        per cases;
        case
          0 <= b';
          hence thesis by A1,Lm7;
        end;
        case
A2:       b' < 0;
          reconsider c = -b' as Element of M;
          0 < -b' by A2,XREAL_1:60;
          then consider q,r being Element of M such that
A3:       a = q * c + r and
A4:       r = 0.M or absint.r < absint.c by Lm3,Lm7;
A5:       r = 0.M or absint.r < absint.b
          proof
            assume
A6:         r <> 0.M;
            absint.c = absreal.c by Def6
              .= abs((-b')) by EUCLID:def 2
              .= -b' by A2,ABSVALUE:def 1
              .= abs((b')) by A2,ABSVALUE:def 1
              .= absreal.(b') by EUCLID:def 2
              .= absint.b by Def6;
            hence thesis by A4,A6;
          end;
          reconsider t = -q as Element of M;
          t * b + r = a by A3;
          hence thesis by A5;
        end;
      end;
      hence thesis;
    end;
    hence thesis by Def10;
  end;
end;

theorem Th5:
  for F being commutative associative well-unital
  almost_left_invertible right_zeroed (non empty doubleLoopStr) holds F is
  Euclidian
proof
  let F be commutative associative well-unital almost_left_invertible
  right_zeroed (non empty doubleLoopStr);
  consider f being Function of the carrier of F,NAT;
  for a,b being Element of F st b <> 0.F holds ex q,r being Element of F
  st a = q * b + r & (r = 0.F or f.r < f.b) by Lm9;
  hence thesis by Def9;
end;

registration
  cluster commutative associative well-unital almost_left_invertible
    right_zeroed almost_left_invertible -> Euclidian (non empty doubleLoopStr);
  coherence by Th5;
end;

theorem
  for F being commutative associative well-unital almost_left_invertible
right_zeroed (non empty doubleLoopStr) for f being Function of the carrier of F
  ,NAT holds f is DegreeFunction of F
proof
  let F be commutative associative well-unital almost_left_invertible
  right_zeroed (non empty doubleLoopStr);
  let f be Function of the carrier of F,NAT;
  for a,b being Element of F st b <> 0.F holds ex q,r being Element of F
  st a = q * b + r & (r = 0.F or f.r < f.b) by Lm9;
  hence thesis by Def10;
end;

begin :: Some Theorems about DIV and MOD

canceled;

theorem Th8:
  for n,a,k being Integer holds (n <> 0 implies (a + n * k) div n =
  (a div n) + k) & (a + n * k) mod n = a mod n
proof
  let n,a,k be Integer;
  thus
A1: now
    assume
A2: n <> 0;
    thus (a + n * k) div n = [\ (a + n * k)/n /] by INT_1:def 7
      .= [\ (a + n * k) * n" /] by XCMPLX_0:def 9
      .= [\ a * n" + (n * n") * k /]
      .= [\ a * n" + 1 * k /] by A2,XCMPLX_0:def 7
      .= [\ a * n" /] + k by INT_1:51
      .= [\ a/n /] + k by XCMPLX_0:def 9
      .= (a div n) + k by INT_1:def 7;
  end;
  per cases;
  suppose
A3: n <> 0;
    hence (a + n * k) mod n = (a + n * k) - ((a div n) + k) * n by A1,
INT_1:def 8
      .= a - (a div n) * n
      .= a mod n by A3,INT_1:def 8;
  end;
  suppose
    n = 0;
    hence thesis;
  end;
end;

theorem Th9:
  for n being natural number st n > 0 for a being Integer holds a
  mod n >= 0 & a mod n < n
proof
  let n be natural number;
  assume
A1: n > 0;
  let a be Integer;
  now
    a div n = [\ a/n /] by INT_1:def 7;
    then a div n <= a/n by INT_1:def 4;
    then (a div n) * n <= a/n * n by XREAL_1:66;
    then (a div n) * n <= (a * n") * n by XCMPLX_0:def 9;
    then (a div n) * n <= a * (n" * n);
    then (a div n) * n <= a * 1 by A1,XCMPLX_0:def 7;
    then (a div n) * n - (a div n) * n <= a - (a div n) * n by XREAL_1:11;
    hence 0 <= a mod n by INT_1:def 8;
    assume
    a mod n >= n;
    then a - (a div n) * n >= n by A1,INT_1:def 8;
    then (a + -(a div n) * n) + (a div n) * n >= n + (a div n) * n by XREAL_1:8
;
    then a - n >= (n + (a div n) * n) - n by XREAL_1:11;
    then (a - n) * n" >= ((a div n) * n) * n" by XREAL_1:66;
    then (a - n) * n" >= (a div n) * (n * n");
    then a * n" - n * n" >= (a div n) * 1 by A1,XCMPLX_0:def 7;
    then a * n" - 1 >= (a div n) by A1,XCMPLX_0:def 7;
    then
A2: a/n - 1 >= (a div n) by XCMPLX_0:def 9;
    a div n = [\ a/n /] by INT_1:def 7;
    hence contradiction by A2,INT_1:def 4;
  end;
  hence thesis;
end;

theorem Th10:
  for n,a being Integer holds (0 <= a & a < n implies a mod n = a)
  & (0 > a & a >= -n implies a mod n = n + a)
proof
  let n,a be Integer;
  per cases;
  suppose
    n = 0;
    hence thesis;
  end;
  suppose
A1: n <> 0;
    hereby
      assume that
A2:   0 <= a and
A3:   a < n;
      reconsider aa = a as Element of NAT by A2,INT_1:16;
      reconsider nn = n as Element of NAT by A2,A3,INT_1:16;
      consider t being Nat such that
A4:   aa = nn * t + (aa mod nn) and
      (aa mod nn) < nn by A1,NAT_D:def 2;
      t = 0
      proof
        assume
        t <> 0;
        then t >= 1 + 0 by INT_1:20;
        then
A5:     t * n >= 1 * n by A2,A3,XREAL_1:66;
        nn * t + (aa mod nn) >= nn * t by NAT_1:11;
        hence thesis by A3,A4,A5,XXREAL_0:2;
      end;
      hence a mod n = a by A4;
    end;
    assume that
A6: 0 > a and
A7: a >= -n;
A8: n >= 0 by A6,A7;
A9: a/n - 1 < -1
    proof
      assume
      a/n - 1 >= -1;
      then (a/n - 1) + 1 >= -1 + 1 by XREAL_1:8;
      then a * n" >= 0 by XCMPLX_0:def 9;
      then (a * n") * n >= 0 * n by A8;
      then a * (n" * n) >= 0;
      then a * 1 >= 0 by A1,XCMPLX_0:def 7;
      hence thesis by A6;
    end;
    a * n" >= (-n) * n" by A7,A8,XREAL_1:66;
    then a /n >= -(n * n") by XCMPLX_0:def 9;
    then -1 <= a/n by A1,XCMPLX_0:def 7;
    then [\ a/n /] = -1 by A9,INT_1:def 4;
    then
A10: a div n = -1 by INT_1:def 7;
    a mod n = a - (a div n) * n by A1,INT_1:def 8;
    hence thesis by A10;
  end;
end;

canceled;

theorem Th12:
  for n,a,b being Integer holds (n <> 0 & a mod n = b mod n
implies a,b are_congruent_mod n) & (a,b are_congruent_mod n implies a mod n = b
  mod n)
proof
  let n,a,b be Integer;
  hereby
    assume
A1: n <> 0;
    assume
    a mod n = b mod n;
    then a - (a div n) * n = b mod n by A1,INT_1:def 8;
    then a - (a div n) * n = b - (b div n) * n by A1,INT_1:def 8;
    then a - b = (-(b div n) + (a div n)) * n;
    then n divides (a-b) by INT_1:def 9;
    hence a,b are_congruent_mod n by INT_2:19;
  end;
  assume
  a,b are_congruent_mod n;
  then n divides (a-b) by INT_2:19;
  then consider k being Integer such that
A2: n * k = a - b by INT_1:def 9;
  a = n * k + b by A2;
  hence thesis by Th8;
end;

theorem Th13:
  for n being natural number for a being Integer holds (a mod n)
  mod n = a mod n
proof
  let n be natural number;
  let a be Integer;
  per cases;
  suppose
A1: n = 0;
    hence (a mod n) mod n = 0 by INT_1:def 8
      .= a mod n by A1,INT_1:def 8;
  end;
  suppose
    n <> 0;
    then a mod n >= 0 & a mod n < n by Th9;
    hence thesis by Th10;
  end;
end;

theorem Th14:
  for n,a,b being Integer holds (a + b) mod n = ((a mod n) + (b
  mod n)) mod n
proof
  let n,a,b be Integer;
  per cases;
  suppose
A1: n = 0;
    hence (a + b) mod n = 0 by INT_1:def 8
      .= ((a mod n) + (b mod n)) mod n by A1,INT_1:def 8;
  end;
  suppose
    n <> 0;
    then
    a mod n + (a div n) * n = (a - (a div n) * n) + (a div n) * n & b mod
    n + (b div n) * n = (b - (b div n) * n) + (b div n) * n by INT_1:def 8;
    then (a + b) - ((a mod n) + (b mod n)) = ((a div n) + (b div n)) * n;
    then n divides (a + b) - ((a mod n) + (b mod n)) by INT_1:def 9;
    then a+b,(a mod n)+(b mod n) are_congruent_mod n by INT_2:19;
    hence thesis by Th12;
  end;
end;

theorem Th15:
  for n,a,b being Integer holds (a * b) mod n = ((a mod n) * (b
  mod n)) mod n
proof
  let n,a,b be Integer;
  per cases;
  suppose
A1: n = 0;
    hence (a * b) mod n = 0 by INT_1:def 8
      .= ((a mod n) * (b mod n)) mod n by A1,INT_1:def 8;
  end;
  suppose
    n <> 0;
    then
    a mod n + (a div n) * n = (a - (a div n) * n) + (a div n) * n & b mod
    n + (b div n) * n = (b - (b div n) * n) + (b div n) * n by INT_1:def 8;
    then (a * b) - ((a mod n) * (b mod n)) = (((a mod n) * (b div n)) + (((a
    div n) * (b mod n)) + (((a div n) * n) * (b div n)))) * n;
    then n divides ((a * b) - ((a mod n) * (b mod n))) by INT_1:def 9;
    then (a*b),((a mod n)*(b mod n)) are_congruent_mod n by INT_2:19;
    hence thesis by Th12;
  end;
end;

theorem Th16:
  for a,b being Integer ex s,t being Integer st a gcd b = s * a +
  t * b
proof
  let a,b be Integer;
A1: for a,b being Integer st a > 0 & b > 0 holds ex s,t being Integer st (a
  gcd b) = (s * a + t * b)
  proof
    let a,b be Integer;
    assume that
A2: a > 0 and
A3: b > 0;
    reconsider a,b as Element of NAT by A2,A3,INT_1:16;
    set M = {z where z is Element of NAT : ex s,t being Integer st z = s * a +
    t * b};
    defpred P[Nat] means ($1 in M & $1 <> 0);
    a = 1 * a + 0 * b;
    then
A4: a in M;
    then
A5: ex k being Nat st P[k] by A2;
    consider g being Nat such that
A6: P[g] & for n being Nat st P[n] holds g <= n from NAT_1:sch 5(A5);
    set G = {zz where zz is Element of NAT : ex s being Element of NAT st zz =
    s * g};
    ex z being Element of NAT st z = g & ex s,t being Integer st z = s * a
    + t * b by A6;
    then consider s,t being Integer such that
A7: g = s * a + t * b;
A8: for x being set holds x in M implies x in G
    proof
      let x be set;
      assume
      x in M;
      then consider x' being Element of NAT such that
A9:   x' = x and
A10:  ex u,v being Integer st x' = u * a + v * b;
      consider u,v being Integer such that
A11:  x = u * a + v * b by A9,A10;
      consider r being Nat such that
A12:  x' = g * (x' div g) + r and
A13:  r < g by A6,NAT_D:def 1;
A14:  r in NAT by ORDINAL1:def 13;
      r = x' - g * (x' div g) by A12
        .= a * (u + -(s * (x' div g))) + b * (v + -(t * (x' div g)))
         by A7,A9,A11;
      then r in M by A14;
      then r = 0 by A6,A13;
      hence thesis by A9,A12;
    end;
    for x being set holds x in G implies x in M
    proof
      let x be set;
      assume
      x in G;
      then
A15:  ex x' being Element of NAT st x' = x & ex u being Element of NAT st
      x' = u * g;
      then consider u being Integer such that
A16:  x = u * g;
      x = (u * s) * a + (u * t) * b by A7,A16;
      hence thesis by A15;
    end;
    then
A17: G = M by A8,TARSKI:2;
A18: abs(b) = b by ABSVALUE:def 1;
A19: abs(a) = a by ABSVALUE:def 1;
A20: for m being Nat st m divides abs(a) & m divides abs(b) holds m
    divides g
    proof
      ex g' being Element of NAT st g' = g & ex s,t being Integer st g' =
      s * a + t * b by A6;
      then consider s,t being Integer such that
A21:  g = s * a + t * b;
      let m be Nat;
      assume that
A22:  m divides abs(a) and
A23:  m divides abs(b);
      consider u being Nat such that
A24:  a = m * u by A19,A22,NAT_D:def 3;
      consider v being Nat such that
A25:  b = m * v by A18,A23,NAT_D:def 3;
A26:  g = m * (s * u + t * v) by A24,A25,A21;
      then s * u + t * v >= 0 by A6;
      then s * u + t * v is Element of NAT by INT_1:16;
      hence thesis by A26,NAT_D:def 3;
    end;
    b = 0 * a + 1 * b;
    then b in M;
    then
    ex b' being Element of NAT st b' = b & ex t being Element of NAT st b'
    = t * g by A17;
    then
A27: g divides abs(b) by A18,NAT_D:def 3;
    ex a' being Element of NAT st a' = a & ex s being Element of NAT st a'
    = s * g by A4,A17;
    then g divides abs(a) by A19,NAT_D:def 3;
    then g = abs(a) gcd abs(b) by A27,A20,NAT_D:def 5
      .= a gcd b by INT_2:51;
    hence thesis by A7;
  end;
  now
    per cases;
    case
A28:  a = 0 or b = 0;
A29:  for a,b being Integer holds a = 0 implies a gcd b = abs(b)
      proof
        let a,b be Integer;
        assume
        a = 0;
        then abs(a) = 0 by ABSVALUE:def 1;
        then
A30:    abs(b) divides abs(a) by NAT_D:6;
        a gcd b = abs(a) gcd abs(b) & for m being Nat st m divides abs(a)
        & m divides abs(b) holds m divides abs(b) by INT_2:51;
        hence thesis by A30,NAT_D:def 5;
      end;
      now
        per cases by A28;
        case
          a = 0;
          then
A31:      a gcd b = abs(b) by A29;
          now
            per cases;
            case
              b >= 0;
              hence a gcd b = 0 * a + 1 * b by A31,ABSVALUE:def 1;
            end;
            case
              b < 0;
              hence a gcd b = -(b * 1) by A31,ABSVALUE:def 1
                .= 0 * a + (-1) * b;
            end;
          end;
          hence thesis;
        end;
        case
          b = 0;
          then
A32:      a gcd b = abs(a) by A29;
          now
            per cases;
            case
              a >= 0;
              hence a gcd b = 1 * a + 0 * b by A32,ABSVALUE:def 1;
            end;
            case
              a < 0;
              hence a gcd b = -(a * 1) by A32,ABSVALUE:def 1
                .= 0 * b + (-1) * a;
            end;
          end;
          hence thesis;
        end;
      end;
      hence thesis;
    end;
    case
A33:  a <> 0 & b <> 0;
      now
        per cases;
        case
          a >= 0 & b >= 0;
          hence thesis by A1,A33;
        end;
        case
A34:      a < 0 & b >= 0;
          then -a > 0 by XREAL_1:60;
          then consider s,t being Integer such that
A35:      -a gcd b = s * -a + t * b by A1,A33,A34;
A36:      a gcd b = abs(a) gcd abs(b) by INT_2:51
            .= abs((-a)) gcd abs(b) by COMPLEX1:138
            .= -a gcd b by INT_2:51;
          s * -a + t * b = (-s) * a + t * b;
          hence thesis by A35,A36;
        end;
        case
A37:      a >= 0 & b < 0;
          then -b > 0 by XREAL_1:60;
          then consider s,t being Integer such that
A38:      a gcd -b = s * a + t * -b by A1,A33,A37;
A39:      a gcd b = abs(a) gcd abs(b) by INT_2:51
            .= abs(a) gcd abs((-b)) by COMPLEX1:138
            .= a gcd -b by INT_2:51;
          s * a + t * -b = s * a + (-t) * b;
          hence thesis by A38,A39;
        end;
        case
          a < 0 & b < 0;
          then -a > 0 & -b > 0 by XREAL_1:60;
          then consider s,t being Integer such that
A40:      -a gcd -b = s * -a + t * -b by A1;
A41:      a gcd b = abs(a) gcd abs(b) by INT_2:51
            .= abs(a) gcd abs((-b)) by COMPLEX1:138
            .= abs((-a)) gcd abs((-b)) by COMPLEX1:138
            .= -a gcd -b by INT_2:51;
          s * -a + t * -b = (-s) * a + (-t) * b;
          hence thesis by A40,A41;
        end;
      end;
      hence thesis;
    end;
  end;
  hence thesis;
end;

begin :: Modulo Integers

definition
  let n be natural number such that
A1: n > 0;
  func multint(n) -> BinOp of Segm(n) means
  :Def11:
  for k,l being Element of
  Segm(n) holds it.(k,l) = (k * l) mod n;
  existence
  proof
    reconsider n as non zero natural number by A1;
    defpred P[Element of Segm(n),Element of Segm(n),set] means $3 = ($1 * $2)
    mod n;
A2: for k,l being Element of Segm(n) ex c being Element of Segm(n) st P[k,
    l,c]
    proof
      let k,l be Element of Segm(n);
      reconsider k' = k,l' = l as Element of NAT;
      ((k'*l') mod n) < n by NAT_D:1;
      then reconsider c = (k'*l') mod n as Element of Segm(n) by NAT_1:45;
      take c;
      thus thesis;
    end;
    ex c being BinOp of Segm(n) st for k,l being Element of Segm(n) holds
    P[k,l,c.(k,l)] from BINOP_1:sch 3(A2);
    hence thesis;
  end;
  uniqueness
  proof
    reconsider n as non zero natural number by A1;
    deffunc O(Element of Segm(n),Element of Segm(n))=($1 * $2) mod n;
    for o1,o2 being BinOp of Segm(n) st (for a,b being Element of Segm(n)
holds o1.(a,b) = O(a,b)) & (for a,b being Element of Segm(n) holds o2.(a,b) = O
    (a,b)) holds o1 = o2 from BINOP_2:sch 2;
    hence thesis;
  end;
end;

definition
  let n be natural number such that
A1: n > 0;
  func compint(n) -> UnOp of Segm(n) means
  :Def12:
  for k being Element of Segm
  (n) holds it.k = (n - k) mod n;
  existence
  proof
    reconsider n as non zero natural number by A1;
    set f = {[k,(n-k) mod n] where k is Element of NAT : k < n };
A2: for x being set holds x in f implies ex y,z being set st x = [y,z]
    proof
      let x be set;
      assume
      x in f;
      then ex k being Element of NAT st x = [k,(n-k) mod n] & k < n;
      hence thesis;
    end;
    for x,y1,y2 being set st [x,y1] in f & [x,y2] in f holds y1 = y2
    proof
      let x,y1,y2 be set;
      assume that
A3:   [x,y1] in f and
A4:   [x,y2] in f;
      consider k being Element of NAT such that
A5:   [x,y1] = [k,(n-k)mod n] and
      k < n by A3;
A6:   y1 = [k,(n-k)mod n]`2 by A5,MCART_1:def 2
        .= (n-k)mod n by MCART_1:def 2;
      consider k' being Element of NAT such that
A7:   [x,y2] = [k',(n-k') mod n] and
      k' < n by A4;
A8:   y2 = [k',(n-k')mod n]`2 by A7,MCART_1:def 2
        .= (n-k')mod n by MCART_1:def 2;
      k = [x,y1]`1 by A5,MCART_1:def 1
        .= x by MCART_1:def 1
        .= [k',(n-k')mod n]`1 by A7,MCART_1:def 1
        .= k' by MCART_1:def 1;
      hence thesis by A6,A8;
    end;
    then reconsider f as Function by A2,FUNCT_1:def 1,RELAT_1:def 1;
A9: for x being set holds x in Segm(n) implies x in dom f
    proof
      let x be set;
      assume
A10:  x in Segm(n);
      then reconsider x as Element of NAT;
      x < n by A10,NAT_1:45;
      then [x,(n-x)mod n] in f;
      hence thesis by RELAT_1:def 4;
    end;
    for x being set holds x in dom f implies x in Segm(n)
    proof
      let x be set;
      assume
      x in dom f;
      then consider y being set such that
A11:  [x,y] in f by RELAT_1:def 4;
      consider k being Element of NAT such that
A12:  [x,y] = [k,(n-k)mod n] and
A13:  k < n by A11;
      x = [k,(n-k)mod n]`1 by A12,MCART_1:def 1
        .= k by MCART_1:def 1;
      hence thesis by A13,NAT_1:45;
    end;
    then
A14: dom f = Segm(n) by A9,TARSKI:2;
    for y being set holds y in rng f implies y in Segm(n)
    proof
      let y be set;
      assume
      y in rng f;
      then consider x being set such that
A15:  [x,y] in f by RELAT_1:def 5;
      consider k being Element of NAT such that
A16:  [x,y] = [k,(n-k)mod n] and
A17:  k < n by A15;
      k - k < n - k by A17,XREAL_1:11;
      then reconsider z = n - k as Element of NAT by INT_1:16;
A18:  z mod n < n by NAT_D:1;
      y = [k,(n-k)mod n]`2 by A16,MCART_1:def 2
        .= (n-k)mod n by MCART_1:def 2;
      hence thesis by A18,NAT_1:45;
    end;
    then rng f c= Segm(n) by TARSKI:def 3;
    then reconsider f as UnOp of Segm(n) by A14,FUNCT_2:def 1,RELSET_1:11;
    for k being Element of Segm(n) holds f.(k) = (n - k) mod n
    proof
      let k be Element of Segm(n);
      reconsider k as Element of NAT;
      k < n by NAT_1:45;
      then [k,(n-k)mod n] in f;
      hence thesis by A14,FUNCT_1:def 4;
    end;
    hence thesis;
  end;
  uniqueness
  proof
    reconsider n as non zero natural number by A1;
    deffunc F(Element of Segm(n))=(n - $1) mod n;
    for f1,f2 being UnOp of Segm(n) st (for a being Element of Segm(n)
holds f1.a = F(a)) & (for a being Element of Segm(n) holds f2.a = F(a)) holds
    f1 = f2 from LMOD_7:sch 2;
    hence thesis;
  end;
end;

theorem Th17:
  for n being natural number st n > 0 for a,b being Element of
  Segm(n) holds (a + b < n iff (addint(n)).(a,b) = a + b) & (a + b >= n iff (
  addint(n)).(a,b) = (a + b) - n)
proof
  let n be natural number;
  assume
A1: n > 0;
  let a,b be Element of Segm(n);
  reconsider n as non zero natural number by A1;
  consider c being Element of NAT such that
A2: c = (a + b) mod n;
  consider t being Nat such that
A3: a + b = n * t + c & c < n or c = 0 & n = 0 by A2,NAT_D:def 2;
A4: now
    assume
A5: a + b >= n;
    t = 1
    proof
      now
        per cases;
        case
          t = 0;
          hence thesis by A3,A5;
        end;
        case
A6:       t <> 0;
          t < 2
          proof
            a < n & b < n by NAT_1:45;
            then
A7:         n * t + c >= n * t & a + b < n * 1 + n * 1 by NAT_1:11,XREAL_1:10;
            assume
            t >= 2;
            then n * t >= n * 2 by XREAL_1:66;
            hence thesis by A3,A7,XXREAL_0:2;
          end;
          then t < 1 + 1;
          then
A8:       t <= 1 by NAT_1:13;
          1 + 0 <= t by A6,INT_1:20;
          hence thesis by A8,XXREAL_0:1;
        end;
      end;
      hence thesis;
    end;
    hence (addint(n)).(a,b) = (a + b) - n by A2,A3,GR_CY_1:def 5;
  end;
A9: (addint(n)).(a,b) = (a + b) - n implies a + b >= n
  proof
    assume
    (addint(n)).(a,b) = (a + b) - n;
    then
A10: (a + b) mod n = (a + b) - n by GR_CY_1:def 5;
    consider t being Nat such that
A11: a + b = n * t + ((a + b) mod n) and
    ((a + b) mod n) < n by NAT_D:def 2;
    assume
A12: a + b < n;
    t = 0
    proof
      assume
      t <> 0;
      then 1 + 0 <= t by INT_1:20;
      then
A13:  1 * n <= t * n by XREAL_1:66;
      t * n <= t * n + ((a + b) mod n) by NAT_1:11;
      hence thesis by A12,A11,A13,XXREAL_0:2;
    end;
    hence thesis by A10,A11;
  end;
A14: now
    assume
A15: a + b < n;
    t = 0
    proof
      assume
      t <> 0;
      then 1 + 0 <= t by INT_1:20;
      then
A16:  1 * n <= t * n by XREAL_1:66;
      n * t <= n * t + c by NAT_1:11;
      hence thesis by A3,A15,A16,XXREAL_0:2;
    end;
    hence (addint(n)).(a,b) = a + b by A2,A3,GR_CY_1:def 5;
  end;
  (addint(n)).(a,b) = (a + b) implies a + b < n
  proof
    assume
    (addint(n)).(a,b) = (a + b);
    then (a + b) mod n = a + b by GR_CY_1:def 5;
    hence thesis by NAT_D:1;
  end;
  hence thesis by A14,A9,A4;
end;

Lm10: for a,b being natural number st b <> 0 holds ex k being Element of NAT
st k * b <= a & a < (k + 1) * b

proof
  let a,b be natural number;
  set k' = a div b;
  assume
  b <> 0;
  then
A1: ex t being Nat st a = b * k' + t & t < b by NAT_D:def 1;
  (k' + 1) * b = k' * b + b;
  then (k' + 1) * b > a by A1,XREAL_1:8;
  hence thesis by A1,NAT_1:11;
end;

theorem Th18:
  for n being natural number st n > 0 for a,b being Element of
  Segm(n) for k being natural number holds k * n <= a * b & a * b < (k + 1) * n
  iff (multint(n)).(a,b) = a * b - k * n
proof
  let n be natural number;
  assume
A1: n > 0;
  let a,b be Element of Segm(n);
  reconsider a, b as Element of NAT by ORDINAL1:def 13;
  let k be natural number;
A2: now
    assume that
A3: k * n <= a * b and
A4: a * b < (k + 1) * n;
    consider c being Element of NAT such that
A5: c = (a * b) mod n;
    consider t being Nat such that
A6: a * b = n * t + c & c < n or c = 0 & n = 0 by A5,NAT_D:def 2;
    now
      consider q being Nat such that
A7:   a * b = k * n + q by A3,NAT_1:10;
      t = k
      proof
        now
          per cases;
          case
            t <= k;
            then consider r being Nat such that
A8:         t + r = k by NAT_1:10;
A9:         n * t + c = t * n + (r * n + q) by A1,A6,A7,A8;
            now
              per cases;
              case
                t = k;
                hence thesis;
              end;
              case
A10:            t <> k;
                r >= 1
                proof
                  assume
A11:              r < 1;
                  r = 0
                  proof
                    assume
                    r <> 0;
                    then 1 + 0 <= r by INT_1:20;
                    hence thesis by A11;
                  end;
                  hence thesis by A8,A10;
                end;
                then r * n >= 1 * n by NAT_1:4;
                then
A12:            r * n + q >= 1 * n + q by XREAL_1:8;
                1 * n + q >= n by NAT_1:11;
                hence thesis by A1,A6,A9,A12,XXREAL_0:2;
              end;
            end;
            hence thesis;
          end;
          case
            t > k;
            then t >= k + 1 by INT_1:20;
            then
A13:        n * t >= n * (k + 1) by NAT_1:4;
            n * t + c >= n * t by NAT_1:11;
            hence thesis by A4,A6,A13,XXREAL_0:2;
          end;
        end;
        hence thesis;
      end;
      hence (multint(n)).(a,b) = a * b - k * n by A1,A5,A6,Def11;
    end;
    hence (multint(n)).(a,b) = a * b - k * n;
  end;
  now
    assume
    (multint(n)).(a,b) = a * b - k * n;
    then (a * b) mod n = a * b - k * n by A1,Def11;
    then
A14: (a * b - k * n) + k * n >= 0 + k * n & ex t being Nat st a * b = n * t
    + (a * b - n * k) & (a * b - n * k) < n by A1,NAT_D:def 2,XREAL_1:8;
    (k + 1) * n = k * n + n;
    hence k * n <= a * b & a * b < (k + 1) * n by A14,XREAL_1:8;
  end;
  hence thesis by A2;
end;

theorem
  for n being natural number st n > 0 for a being Element of Segm(n)
holds (a = 0 iff (compint(n)).(a) = 0) & (a <> 0 iff (compint(n)).(a) = n - a)
proof
  let n be natural number;
  assume
A1: n > 0;
  let a be Element of Segm(n);
  reconsider n as non zero natural number by A1;
  reconsider a as Element of NAT by ORDINAL1:def 13;
A2: a < n by NAT_1:45;
  then a - a < n - a by XREAL_1:11;
  then reconsider b = n - a as Element of NAT by INT_1:16;
  consider c being Element of NAT such that
A3: c = b mod n;
A4: (compint(n)).(a) = 0 implies a = 0
  proof
    a - a < n - a by A2,XREAL_1:11;
    then reconsider a' = n - a as Element of NAT by INT_1:16;
    assume
A5: (compint(n)).(a) = 0;
    n <= n + a by NAT_1:11;
    then
A6: n - a <= (n + a) - a by XREAL_1:11;
    consider t being Nat such that
A7: a' = n * t + (a' mod n) and
    a' mod n < n by NAT_D:def 2;
    assume
    a <> 0;
    then n - a <> n;
    then
A8: n - a < n by A6,XXREAL_0:1;
    t = 0
    proof
      assume
      t <> 0;
      then 1 + 0 <= t by INT_1:20;
      then
A9:   1 * n <= t * n by XREAL_1:66;
      t * n <= t * n + (a' mod n) by NAT_1:11;
      hence thesis by A8,A7,A9,XXREAL_0:2;
    end;
    then a' = 0 by A5,A7,Def12;
    hence thesis by NAT_1:45;
  end;
  consider t being Nat such that
A10: b = n * t + c & c < n or c = 0 & n = 0 by A3,NAT_D:def 2;
A11: n - a <= n
  proof
    assume
    n - a > n;
    then (n - a) + a > n + a by XREAL_1:8;
    hence thesis by NAT_1:11;
  end;
A12: now
    assume
A13: a = 0;
A14: t = 1
    proof
      now
        per cases;
        case
          t = 0;
          hence thesis by A10,A13;
        end;
        case
A15:      t <> 0;
          t < 2
          proof
            assume
            t >= 2;
            then
A16:        n * t >= n * 2 by XREAL_1:66;
A17:        n <= n * 1 + n * 1 by NAT_1:11;
            n * t + c >= n * t by NAT_1:11;
            then n - a >= n * 2 by A10,A16,XXREAL_0:2;
            then n * 1 = 2 * n by A13,A17,XXREAL_0:1;
            hence thesis by A1;
          end;
          then t < 1 + 1;
          then
A18:      t <= 1 by NAT_1:13;
          1 + 0 <= t by A15,INT_1:20;
          hence thesis by A18,XXREAL_0:1;
        end;
      end;
      hence thesis;
    end;
    c = 0
    proof
      assume
      c <> 0;
      then n + c > n + 0 by XREAL_1:8;
      hence thesis by A10,A11,A14;
    end;
    hence (compint(n)).(a) = 0 by A3,Def12;
  end;
  now
    assume
A19: a <> 0;
A20: n - a < n
    proof
      assume
      n - a >= n;
      then n - a = n by A11,XXREAL_0:1;
      hence thesis by A19;
    end;
    t = 0
    proof
      assume
      t <> 0;
      then 1 + 0 <= t by INT_1:20;
      then
A21:  1 * n <= t * n by XREAL_1:66;
      n * t <= n * t + c by NAT_1:11;
      hence thesis by A10,A20,A21,XXREAL_0:2;
    end;
    hence (compint(n)).(a) = n - a by A3,A10,Def12;
  end;
  hence thesis by A12,A4;
end;

definition
  let n be natural number;
  func INT.Ring(n) -> doubleLoopStr equals
  doubleLoopStr(#Segm(n),addint(n),
    multint(n),In (1,Segm(n)),In (0,Segm(n))#);
  coherence;
end;

registration
  let n be non zero natural number;
  cluster INT.Ring(n) -> strict non empty;
  coherence;
end;

theorem Th20:
  INT.Ring 1 is degenerated & INT.Ring 1 is Ring & INT.Ring 1 is
  almost_left_invertible unital distributive commutative
proof
  set n = 1, R = INT.Ring n;
A1: for x being Element of R st x <> 0.R ex y be Element of R st y*x = 1.R
  proof
    let x be Element of R;
    assume
    x <> 0.R;
    then x <> 0 by FUNCT_7:def 1;
    hence thesis by CARD_1:87,TARSKI:def 1;
  end;
A2: for a,b being Element of R holds a + b = b + a
  proof
    let a,b be Element of R;
    thus a + b = 0 by CARD_1:87,TARSKI:def 1
      .= b + a by CARD_1:87,TARSKI:def 1;
  end;
A3: for a being Element of R holds a + 0.R = a
  proof
    let a be Element of R;
    a = 0 by CARD_1:87,TARSKI:def 1;
    hence thesis by CARD_1:87,TARSKI:def 1;
  end;
A4: for a,b,c being Element of R holds (a * b) * c = a * (b * c)
  proof
    let a,b,c be Element of R;
    thus (a * b) * c = 0 by CARD_1:87,TARSKI:def 1
      .= a * (b * c) by CARD_1:87,TARSKI:def 1;
  end;
A5: for a being Element of R holds a + (-a) = 0.R
  proof
    let a be Element of R;
    thus a + (-a) = 0 by CARD_1:87,TARSKI:def 1
      .= 0.R by CARD_1:87,TARSKI:def 1;
  end;
A6: R is right_complementable
  proof
    let v be Element of R;
    take -v;
    thus thesis by A5;
  end;
A7: for a,b,c being Element of R holds (a + b) + c = a + (b + c)
  proof
    let a,b,c be Element of R;
    thus (a + b) + c = 0 by CARD_1:87,TARSKI:def 1
      .= a + (b + c) by CARD_1:87,TARSKI:def 1;
  end;
A8: for a being Element of R holds 1.R * a = a & a * 1.R = a
  proof
    let a be Element of R;
A9: a * 1.R = 0 by CARD_1:87,TARSKI:def 1
      .= a by CARD_1:87,TARSKI:def 1;
    1.R * a = 0 by CARD_1:87,TARSKI:def 1
      .= a by CARD_1:87,TARSKI:def 1;
    hence thesis by A9;
  end;
A10: R is well-unital
  proof
    let x be Element of R;
    thus x*(1.R) = x by A8;
    thus thesis by A8;
  end;
A11: for a,b being Element of R holds a * b = b * a
  proof
    let a,b be Element of R;
    thus a * b = 0 by CARD_1:87,TARSKI:def 1
      .= b * a by CARD_1:87,TARSKI:def 1;
  end;
A12: for a,b,c being Element of R holds a * (b + c) = a * b + a * c
  proof
    let a,b,c be Element of R;
    thus a * (b + c) = 0 by CARD_1:87,TARSKI:def 1
      .= a * b + a * c by CARD_1:87,TARSKI:def 1;
  end;
A13: for a,b,c being Element of R holds (b + c) * a = b * a + c * a
  proof
    let a,b,c be Element of R;
    thus (b + c) * a = 0 by CARD_1:87,TARSKI:def 1
      .= b * a + c * a by CARD_1:87,TARSKI:def 1;
  end;
  0.R = 0 by CARD_1:87,TARSKI:def 1
    .= 1.R by CARD_1:87,TARSKI:def 1;
  hence thesis by A1,A2,A11,A7,A4,A3,A13,A12,A6,A10,GROUP_1:def 4,def 16
,RLVECT_1:def 5,def 6,def 7,VECTSP_1:def 18,def 20;
end;

registration
  cluster strict degenerated unital distributive almost_left_invertible
    commutative Ring;
  existence by Th20;
end;

Lm11: now
  let a, n be natural number;
  assume
  a in Segm n;
  then a < n by NAT_1:45;
  then
A1: n-a is Element of NAT by INT_1:18;
  assume
  a > 0;
  then n-a < n-0 by XREAL_1:17;
  hence n-a in Segm n by A1,NAT_1:45;
end;

Lm12: for n being natural number st 1 < n holds 1.INT.Ring(n) = 1
proof
  let n be natural number;
  assume
  1 < n;
  then 1 in Segm n by NAT_1:45;
  hence thesis by FUNCT_7:def 1;
end;

theorem Th21:
  for n being natural number st n > 1 holds INT.Ring(n) is non
  degenerated & INT.Ring(n) is well-unital distributive commutative Ring
proof
  let n be natural number;
  assume
A1: n > 1;
  then reconsider n as non zero natural number;
  set F = INT.Ring(n);
A2: 1.F = 1 by A1,Lm12;
A3: for a being Element of F holds 1.F * a = a & a * 1.F = a
  proof
    let a be Element of F;
    reconsider a' = a as Element of Segm(n);
A4: 1 * a' < (0 + 1) * n & 1 is Element of Segm(n) by A1,NAT_1:45;
    then
A5: (multint(n)).(a,1) = a' - 0 * n by Th18
      .= a';
    (multint(n)).(1,a) = a' - 0 * n by A4,Th18
      .= a';
    hence thesis by A1,A5,Lm12;
  end;
A6: F is well-unital
  proof
    let x be Element of F;
    thus x*(1.F) = x by A3;
    thus thesis by A3;
  end;
A7: for a,b being Element of F holds a + b = b + a
  proof
    let a,b be Element of F;
    reconsider a' = a as Element of Segm(n);
    reconsider b' = b as Element of Segm(n);
    now
      per cases;
      case
A8:     a' + b' < n;
        hence (addint(n)).(a,b) = a' + b' by Th17
          .= (addint(n)).(b,a) by A8,Th17;
      end;
      case
A9:     a' + b' >= n;
        hence (addint(n)).(a,b) = (a' + b') - n by Th17
          .= (addint(n)).(b,a) by A9,Th17;
      end;
    end;
    hence thesis;
  end;
A10: for a,b,c being Element of F holds (a * b) * c = a * (b * c)
  proof
    let a,b,c be Element of F;
    reconsider a' = a, b' = b, c' = c as Element of Segm(n);
    reconsider aa = a' as Element of NAT;
    reconsider aa as Integer;
    reconsider bb = b' as Element of NAT;
    reconsider bb as Integer;
    reconsider cc = c' as Element of NAT;
    reconsider cc as Integer;
A11: cc < n by NAT_1:45;
    aa < n by NAT_1:45;
    then
A12: (a' * ((b' * c') mod n)) mod n = ((aa mod n) * (bb * cc mod n)) mod n
    by Th10
      .= (aa * (bb * cc)) mod n by Th15
      .= ((aa * bb) * cc) mod n
      .= (((aa * bb) mod n) * (cc mod n)) mod n by Th15
      .= (((a' * b') mod n) * c') mod n by A11,Th10;
    (aa * bb) mod n < n by Th9;
    then
A13: (a' * b') mod n is Element of Segm(n) by NAT_1:45;
    (bb * cc) mod n < n by Th9;
    then
A14: (b' * c') mod n is Element of Segm(n) by NAT_1:45;
A15: a * (b * c) = (multint(n)).(a', (b' * c') mod n) by Def11
      .= (a' * ((b' * c') mod n)) mod n by A14,Def11;
    (a * b) * c = (multint(n)).((a' * b') mod n, c') by Def11
      .= (((a' * b') mod n) * c') mod n by A13,Def11;
    hence thesis by A15,A12;
  end;
A16: for a,b being Element of F holds a * b = b * a
  proof
    let a,b be Element of F;
    reconsider a' = a as Element of Segm(n);
    reconsider b' = b as Element of Segm(n);
    consider k being Element of NAT such that
A17: k * n <= a' * b' & a' * b' < (k + 1) * n by Lm10;
    (multint(n)).(a',b') = a' * b' - k * n by A17,Th18
      .= (multint(n)).(b',a') by A17,Th18;
    hence thesis;
  end;
A18: for a,b,c being Element of F holds (a + b) + c = a + (b + c)
  proof
    let a,b,c be Element of F;
    reconsider a' = a, b' = b, c' = c as Element of Segm(n);
    reconsider aa = a' as Element of NAT;
    reconsider aa as Integer;
    reconsider bb = b' as Element of NAT;
    reconsider bb as Integer;
    reconsider cc = c' as Element of NAT;
    reconsider cc as Integer;
A19: cc < n by NAT_1:45;
    aa < n by NAT_1:45;
    then
A20: (a' + ((b' + c') mod n)) mod n = ((aa mod n) + (bb + cc mod n)) mod n
    by Th10
      .= (aa + (bb + cc)) mod n by Th14
      .= ((aa + bb) + cc) mod n
      .= (((aa + bb) mod n) + (cc mod n)) mod n by Th14
      .= (((a' + b') mod n) + c') mod n by A19,Th10;
    (aa + bb) mod n < n by Th9;
    then
A21: (a' + b') mod n is Element of Segm(n) by NAT_1:45;
    (bb + cc) mod n < n by Th9;
    then
A22: (b' + c') mod n is Element of Segm(n) by NAT_1:45;
A23: a + (b + c) = (addint(n)).(a', (b' + c') mod n) by GR_CY_1:def 5
      .= (a' + ((b' + c') mod n)) mod n by A22,GR_CY_1:def 5;
    (a + b) + c = (addint(n)).((a' + b') mod n, c') by GR_CY_1:def 5
      .= (((a' + b') mod n) + c') mod n by A21,GR_CY_1:def 5;
    hence thesis by A23,A20;
  end;
  0 in Segm(n) by NAT_1:45;
  then
A24: 0.F = 0 by FUNCT_7:def 1;
A25: for a being Element of F holds a + 0.F = a
  proof
    let a be Element of F;
    reconsider a' = a as Element of Segm(n);
    a' + 0 < n by NAT_1:45;
    hence thesis by A24,Th17;
  end;
A26: F is right_complementable
  proof
    let a be Element of F;
    reconsider a' = a as Element of Segm(n);
    reconsider a' as Element of NAT;
    per cases;
    suppose
A27:  a' = 0;
      take 0.F;
      thus thesis by A24,A25,A27;
    end;
    suppose
      a' <> 0;
      then reconsider b = n-a' as Element of Segm n by Lm11;
      reconsider v = b as Element of F;
      take v;
      thus a + v = (a'+b) mod n by GR_CY_1:def 5
        .= 0.F by A24,NAT_D:25;
    end;
  end;
A28: for a,b,c being Element of F holds (b + c) * a = b * a + c * a
  proof
    let a,b,c be Element of F;
    reconsider a' = a, b' = b, c' = c as Element of Segm(n);
    reconsider aa = a' as Element of NAT;
    reconsider aa as Integer;
    reconsider bb = b' as Element of NAT;
    reconsider bb as Integer;
    reconsider cc = c' as Element of NAT;
    reconsider cc as Integer;
A29: aa < n by NAT_1:45;
A30: (((b' * a') mod n) + ((c' * a') mod n)) mod n = (bb * aa + cc * aa)
    mod n by Th14
      .= ((bb + cc) * aa) mod n
      .= (((bb + cc) mod n) * (aa mod n)) mod n by Th15
      .= (((b' + c') mod n) * a') mod n by A29,Th10;
    (bb + cc) mod n < n by Th9;
    then
A31: (b' + c') mod n is Element of Segm(n) by NAT_1:45;
    (cc * aa) mod n < n by Th9;
    then
A32: (c' * a') mod n is Element of Segm(n) by NAT_1:45;
    (bb * aa) mod n < n by Th9;
    then
A33: (b' * a') mod n is Element of Segm(n) by NAT_1:45;
A34: (b + c) * a = (multint(n)).((b' + c') mod n, a') by GR_CY_1:def 5
      .= (((b' + c') mod n) * a') mod n by A31,Def11;
    b * a + c * a = (addint(n)).((multint(n)).(b,a),(c' * a') mod n) by Def11
      .= (addint(n)).((b' * a') mod n,(c' * a') mod n) by Def11
      .= (((b' * a') mod n) + ((c' * a') mod n)) mod n by A33,A32,GR_CY_1:def 5
;
    hence thesis by A34,A30;
  end;
  for a,b,c being Element of F holds a * (b + c) = a * b + a * c
  proof
    let a,b,c be Element of F;
    thus a * (b + c) = (b + c) * a by A16
      .= b * a + c * a by A28
      .= a * b + c * a by A16
      .= a * b + a * c by A16;
  end;
  then reconsider F as commutative Ring by A7,A16,A18,A10,A25,A28,A26,A6,
GROUP_1:def 4,def 16,RLVECT_1:def 5,def 6,def 7,VECTSP_1:def 18;
  F is non degenerated by A24,A2,STRUCT_0:def 8;
  hence thesis;
end;

theorem Th22:
  for p being natural number st p > 1 holds INT.Ring(p) is
  add-associative right_zeroed right_complementable Abelian commutative
  associative well-unital distributive almost_left_invertible non degenerated (
  non empty doubleLoopStr) iff p is Prime
proof
  let p be natural number;
  assume
A1: p > 1;
  then reconsider p as non zero natural number;
  reconsider P = INT.Ring(p) as Ring by A1,Th21;
  reconsider p as non zero Element of NAT by ORDINAL1:def 13;
A2: now
    assume
A3: INT.Ring(p) is add-associative right_zeroed right_complementable
Abelian commutative associative well-unital distributive almost_left_invertible
    non degenerated (non empty doubleLoopStr);
    for n being natural number holds n divides p implies n = 1 or n = p
    proof
      let n be natural number;
      assume
      n divides p;
      then consider k being Nat such that
A4:   p = n * k by NAT_D:def 3;
A5:   n <= p
      proof
        assume
A6:     n > p;
        now
          per cases;
          case
            k = 0;
            hence thesis by A4;
          end;
          case
A7:         k <> 0;
            then k >= 1 + 0 by INT_1:20;
            then k * p >= 1 * p by XREAL_1:66;
            hence thesis by A4,A6,A7,XREAL_1:70;
          end;
        end;
        hence thesis;
      end;
A8:   k <= p
      proof
        assume
A9:     k > p;
        now
          per cases;
          case
            n = 0;
            hence thesis by A4;
          end;
          case
A10:        n <> 0;
            then n >= 1 + 0 by INT_1:20;
            then n * p >= 1 * p by XREAL_1:66;
            hence thesis by A4,A9,A10,XREAL_1:70;
          end;
        end;
        hence thesis;
      end;
      now
        per cases;
        case
          k = p;
          then 1 * p = p * n by A4;
          hence thesis by XCMPLX_1:5;
        end;
        case
          k <> p;
          then
A11:      k < p by A8,XXREAL_0:1;
          now
            per cases;
            case
              n = p;
              then 1 * p = k * p by A4;
              then k = 1 by XCMPLX_1:5;
              hence thesis by A4;
            end;
            case
              n <> p;
              then n < p by A5,XXREAL_0:1;
              then reconsider n2 = n as Element of Segm(p) by NAT_1:45;
              0 in p by NAT_1:45;
              then
U:            0 = 0.(INT.Ring p) by FUNCT_7:def 1;
              k <> 0 by A4;
              then
A12:          k <> 0.(INT.Ring(p)) by U;
              reconsider k2 = k as Element of Segm(p) by A11,NAT_1:45;
              reconsider n' = n2 as Element of INT.Ring(p);
              reconsider k' = k2 as Element of INT.Ring(p);
              n <> 0 by A4;
              then
A13:          n <> 0.(INT.Ring(p)) by U;
              n' * k' = (n2 * k2) mod p by Def11
                .= 0.(INT.Ring(p)) by U,A4,INT_1:89;
              hence contradiction by A3,A13,A12,VECTSP_1:44;
            end;
          end;
          hence thesis;
        end;
      end;
      hence thesis;
    end;
    hence p is Prime by A1,INT_2:def 5;
  end;
  now
    assume
A14: p is Prime;
    for a being Element of P st a <> 0.P ex b be Element of P st b * a =
    1.P
    proof
      reconsider e = 1 as Integer;
      let a be Element of P;
      reconsider a' = a as Element of Segm(p);
      reconsider a' as Element of NAT;
      reconsider a2 = a' as Integer;
      1 * p = p;
      then
A15:  1 divides p by NAT_D:def 3;
      assume
A16:  a <> 0.P;
A17:  for m being Nat st m divides a' & m divides p holds m divides 1
      proof
        let m be Nat;
        assume that
A18:    m divides a' and
A19:    m divides p;
        consider k being Nat such that
A20:    a' = m * k by A18,NAT_D:def 3;
        m <= a'
        proof
          assume
A21:      m > a';
          now
            per cases;
            case
              k = 0;
              hence thesis by A16,A20,FUNCT_7:def 1;
            end;
            case
A22:          k <> 0;
              then k >= 1 + 0 by INT_1:20;
              then k * a' >= 1 * a' by XREAL_1:66;
              hence thesis by A20,A21,A22,XREAL_1:70;
            end;
          end;
          hence thesis;
        end;
        then m <> p by NAT_1:45;
        hence thesis by A14,A19,INT_2:def 5;
      end;
      1 * a' = a';
      then 1 divides a' by NAT_D:def 3;
      then a' gcd p = 1 by A15,A17,NAT_D:def 5;
      then consider s,t being Integer such that
A23:  1 = s * a' + t * p by Th16;
      s mod p >= 0 by Th9;
      then
A24:  s mod p is Element of NAT by INT_1:16;
      s mod p < p by Th9;
      then reconsider b' = s mod p as Element of Segm(p) by A24,NAT_1:45;
      reconsider b = b' as Element of P;
      b * a = (a' * b') mod p by Def11
        .= ((a2 mod p) * ((s mod p) mod p)) mod p by Th15
        .= ((a2 mod p) * (s mod p)) mod p by Th13
        .= (a2 * s) mod p by Th15
        .= e mod p by A23,Th8
        .= e by A1,Th10
        .= 1.P by A1,Lm12;
      hence thesis;
    end;
    hence INT.Ring(p) is add-associative right_zeroed right_complementable
Abelian commutative associative well-unital distributive almost_left_invertible
    non degenerated (non empty doubleLoopStr) by A1,Th21,VECTSP_1:def 20;
  end;
  hence thesis by A2;
end;

registration
  cluster -> non zero Prime;
  coherence
  proof
    let k be Prime;
    assume
    k is zero;
    then k in SetPrimenumber 2 by NEWTON:def 7;
    hence contradiction;
  end;
end;

registration
  let p be Prime;
  cluster INT.Ring(p) -> add-associative right_zeroed right_complementable
Abelian commutative associative well-unital distributive almost_left_invertible
    non degenerated;
  coherence
  proof
    p > 1 by INT_2:def 5;
    hence thesis by Th22;
  end;
end;

theorem
  1.INT.Ring = 1 by Lm5;

theorem
  for n being natural number st 1 < n holds 1.INT.Ring(n) = 1 by Lm12;

