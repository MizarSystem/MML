:: The Ring of Integers, Euclidean Rings and Modulo Integers
::  by Christoph Schwarzweller
::
:: Received February 4, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies BINOP_1, INT_1, FUNCT_1, VECTSP_1, RELAT_1, ARYTM_1, GR_CY_1,
      FUNCT_7, RLVECT_1, VECTSP_2, LATTICES, ABSVALUE, EUCLID, NAT_1, FUNCSDOM,
      GCD_1, ARYTM_3, INT_2, MCART_1, ORDINAL2, NAT_LAT, INT_3, ARYTM, GROUP_1,
      XREAL_0;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0, COMPLEX1,
      RLVECT_1, MCART_1, RELAT_1, FUNCT_1, BINOP_2, STRUCT_0, FUNCT_2, GCD_1,
      GROUP_1, CARD_1, VECTSP_1, VECTSP_2, FUNCSDOM, BINOP_1, EUCLID, GR_CY_1,
      INT_1, FUNCT_7, NEWTON, INT_2, NAT_1, NAT_D, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, NAT_1, NAT_D, BINOP_2, NEWTON,
      FUNCT_7, GR_CY_1, EUCLID, GCD_1;
 registrations XBOOLE_0, FUNCT_1, ORDINAL1, RELSET_1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, MEMBERED, SEQ_1, NEWTON, STRUCT_0, VECTSP_1,
      GR_CY_1, GCD_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions RLVECT_1, STRUCT_0, GROUP_1, VECTSP_1, VECTSP_2, CARD_1;
 theorems TARSKI, BINOP_1, FUNCT_1, FUNCT_2, VECTSP_1, INT_1, RELAT_1, GCD_1,
      RLVECT_1, REAL_1, EUCLID, ABSVALUE, GR_CY_1, FUNCT_7, NAT_1, MCART_1,
      INT_2, RELSET_1, XREAL_0, ORDINAL1, XCMPLX_0, XCMPLX_1, NUMBERS, BINOP_2,
      GROUP_1, XREAL_1, COMPLEX1, XXREAL_0, NAT_D, STRUCT_0, CARD_1, NEWTON;
 schemes NAT_1, BINOP_1, LMOD_7, BINOP_2;

begin

definition
  redefine func multint means :Def1:
  for a,b being Element of INT holds it.(a,b) = multreal.(a,b);
 compatibility
  proof let b be BinOp of INT;
   hereby assume
A1:   b = multint;
    let i1,i2 be Element of INT;
     A2: i1 in INT & i2 in INT;
    thus b.(i1,i2) = i1 * i2 by A1,BINOP_2:def 22
        .= multreal.(i1,i2) by A2,BINOP_2:def 11,NUMBERS:15;
   end;
   assume
A3:  for i1,i2 being Element of INT holds
      b.(i1,i2) = multreal.(i1,i2);
     now let i1,i2 be Element of INT;
      A4: i1 in INT & i2 in INT;
     thus b.(i1,i2) = multreal.(i1,i2) by A3
        .= i1 * i2 by A4,BINOP_2:def 11,NUMBERS:15
        .= multint.(i1,i2) by BINOP_2:def 22;
    end;
   hence b = multint by BINOP_1:2;
  end;
end;

definition
 redefine func compint means
     for a being Element of INT holds it.(a) = compreal.(a);
 compatibility
  proof let b be UnOp of INT;
   hereby assume
A1:   b = compint;
    let i be Element of INT;
     A2: i in INT;
    thus b.i = -i by A1,BINOP_2:def 19
        .= compreal.i by A2,BINOP_2:def 7,NUMBERS:15;
   end;
   assume
A3:  for i being Element of INT holds
      b.i = compreal.i;
     now let i be Element of INT;
      A4: i in INT;
     thus b.i = compreal.i by A3
        .= -i by A4,BINOP_2:def 7,NUMBERS:15
        .= compint.i by BINOP_2:def 19;
    end;
   hence b = compint by FUNCT_2:113;
  end;
end;

definition
func INT.Ring -> doubleLoopStr equals
  doubleLoopStr(#INT,addint,multint,In (1,INT),In (0,INT)#);
coherence;
end;

Lm1: for x being Element of INT.Ring holds x in REAL
    proof
     let x be Element of INT.Ring;
         x in INT;
     hence thesis by NUMBERS:15;
     end;

registration
 cluster INT.Ring -> strict non empty;
coherence
  proof
    thus INT.Ring is strict;
    thus the carrier of INT.Ring is non empty;
  end;
end;

registration
  cluster -> integer Element of INT.Ring;
  coherence by INT_1:def 2;
end;

registration let a,b be Element of INT.Ring, c,d be Integer;
  identify a * b with c * d when a = c, b = d;
  compatibility
  proof
    assume
A1: a = c & b = d;
    reconsider a, b as Element of INT;
A2: a is Element of REAL & b is Element of REAL by XREAL_0:def 1;
     multint.(a,b) = multreal.(a,b) by Def1
    .= c * d by A1,A2,BINOP_2:def 11;
    hence thesis;
  end;
  identify a + b with c + d when a = c, b = d;
  compatibility
  proof
    assume
A3: a = c & b = d;
    reconsider a, b as Element of INT;
A4: a is Element of REAL & b is Element of REAL by XREAL_0:def 1;
     addint.(a,b) = addreal.(a,b) by GR_CY_1:def 2
    .= c + d by A3,A4,BINOP_2:def 9;
    hence thesis;
  end;
end;

set M = INT.Ring;

Lm2: 0 in INT by INT_1:def 2;

then Lm3:0 = 0.M by FUNCT_7:def 1;

 1 in INT by INT_1:def 2;

then Lm4:1 = 1.M by FUNCT_7:def 1;

registration
 cluster INT.Ring -> well-unital;
coherence
proof let x be Element of INT.Ring;
  thus thesis by Lm4;
end;
end;

Lm5:
1_M = 1
proof
  reconsider e = 1 as Element of M by INT_1:def 1;
   for x being Element of M holds x*e=x & e*x=x;
  hence thesis by GROUP_1:def 5;
end;

registration
 cluster INT.Ring -> Abelian add-associative right_zeroed right_complementable
                     distributive commutative associative
                     domRing-like non degenerated;
coherence
  proof
    thus for a,b be Element of M holds a + b = b + a;
    thus for a,b,c be Element of M holds (a + b) + c = a + (b + c);
    hereby
     let a be Element of M;
     A1: a + 0.M = addreal.(a,0.M) by GR_CY_1:def 2
                 .= addreal.(a,0) by Lm2,FUNCT_7:def 1;
     reconsider a' = a as Element of REAL by Lm1;
     reconsider t = 0 as Element of REAL;
         addreal.(a',t) = a' + t by BINOP_2:def 9
                   .= a;
     hence a + 0.M = a by A1;
    end;
    hereby
     let a be Element of M;
     reconsider a' = a as Integer;
     reconsider v = -a' as Element of M by INT_1:def 2;
     reconsider v' = v as Integer;
     take v;
     thus a + v = 0.M by FUNCT_7:def 1;
    end;
    thus for a,b,c be Element of M holds a*(b+c) = a*b+a*c &
    (b + c) * a = b * a + c * a;
    thus for x,y be Element of M holds x*y = y*x;
    thus for a,b,c be Element of M holds a*b*c = a*(b*c);
    thus for a,b be Element of M st a * b = 0.M holds
     a = 0.M or b = 0.M by Lm3,XCMPLX_1:6;
     thus 0.M <> 1_M by Lm2,Lm5,FUNCT_7:def 1;
  end;
end;

registration let a be Element of INT.Ring, b be Integer;
  identify -a with -b when a = b;
  compatibility
  proof
    assume A1: b = a;
    reconsider b' = -b as Element of M by INT_1:def 2;
     b' + a = 0.M by A1,FUNCT_7:def 1;
    hence thesis by RLVECT_1:19;
  end;
end;

definition
  canceled;
  let a be Element of INT.Ring;
  redefine func abs(a) -> Element of INT.Ring equals
   a if a >= 0.INT.Ring
  otherwise - a;
  coherence
  proof
     abs(a) in INT by INT_1:def 2;
    hence thesis;
  end;
  compatibility
  proof
    let x be Element of M;
    thus a >= 0.M implies (x = abs(a) iff x = a) by Lm3,ABSVALUE:def 1;
    reconsider b = a as Integer;
    assume a < 0.M;
    hence thesis by Lm3,COMPLEX1:156;
  end;
  consistency;
end;

definition
func absint -> Function of the carrier of INT.Ring,NAT means :Def6:
 for a being Element of INT.Ring holds
 it.a = absreal.(a);
existence
 proof
     dom(absreal) = REAL by FUNCT_2:def 1;
 then A1: dom((absreal)|INT) = the carrier of INT.Ring
 by NUMBERS:15,RELAT_1:91;
     for y being set holds y in rng((absreal)|INT) implies y in NAT
   proof
   let y be set;
   assume y in rng((absreal)|INT);
   then consider x being set such that
   A2: [x,y] in (absreal)|INT by RELAT_1:def 5;
   A3: ((absreal)|INT).x = y by A2,FUNCT_1:8;
   A4: x in dom((absreal)|INT) by A2,RELAT_1:def 4;
   then reconsider x as Integer by A1,INT_1:def 2;
   A5: ((absreal)|INT).x = (absreal).x by A1,A4,FUNCT_1:72;
       now per cases;
   case A6: 0 <= x;
            ((absreal)|INT).x = abs(x) by A5,EUCLID:def 2
                         .= x by A6,ABSVALUE:def 1;
        hence ((absreal)|INT).x is Element of NAT by A6,INT_1:16;
   end;
   case A7: not(0 <= x);
        A8: ((absreal)|INT).x = abs(x) by A5,EUCLID:def 2
                             .= -x by A7,ABSVALUE:def 1;
            -0 <= -x by A7,XREAL_1:26;
        hence ((absreal)|INT).x is Element of NAT by A8,INT_1:16;
   end;
   end;
   hence thesis by A3;
   end;
 then rng((absreal)|INT) c= NAT by TARSKI:def 3;
 then reconsider f = (absreal)|INT as
   Function of the carrier of INT.Ring,NAT by A1,FUNCT_2:def 1,RELSET_1:11;
 take f;
 thus thesis by FUNCT_1:72;
 end;
uniqueness
 proof
   deffunc F(Element of INT.Ring)=absreal.($1);
   thus for f1,f2 being Function of the carrier of INT.Ring,NAT st
   (for x being Element of INT.Ring holds f1.x = F(x)) &
   (for x being Element of INT.Ring holds f2.x = F(x))
  holds f1 = f2 from BINOP_2:sch 1;
 end;
end;

theorem
Th1:for a being Element of INT.Ring holds absint.a = abs(a)
proof
  let a be Element of INT.Ring;
  reconsider a' = a as Integer;
   absint.a = absreal.a' by Def6
  .= abs(a') by EUCLID:def 2;
  hence thesis;
end;

Lm6: for a being Integer holds a = 0 or absreal.a >= 1
proof
let a be Integer;
assume A1: a <> 0;
    now per cases;
  case A2: 0 <= a;
  then reconsider a as Element of NAT by INT_1:16;
  A3: absreal.(a) = abs((a)) by EUCLID:def 2
               .= a by ABSVALUE:def 1;
     0 + 1 < a + 1 by A1,A2,XREAL_1:8;
  hence thesis by A3,NAT_1:13;
  end;
  case A4: a < 0;
  A5: absreal.(a) = abs((a)) by EUCLID:def 2
               .= -a by A4,ABSVALUE:def 1;
      a <= -1 by A4,INT_1:21;
  then -(-1) <= -a by XREAL_1:26;
  hence thesis by A5;
  end;
  end;
hence thesis;
end;

Lm7:for a,b being Element of INT.Ring
  st b <> 0.INT.Ring
  for b' being Integer st b' = b holds
  0 <= b' implies
     ex q,r being Element of INT.Ring st
     (a = q * b + r & (r = 0.INT.Ring or absint.r < absint.b))
  proof
  let a,b be Element of M;
  assume A1: b <> 0.M;
  let b' be Integer;
  assume A2: b' = b;
  assume A3: 0 <= b';
  reconsider a' = a as Integer;
  defpred P[Nat] means ex s being Integer st $1 = a' - s * b';
  A4: ex k being Nat st P[k]
     proof
      now per cases;
     case 0 <= a';
       then reconsider a' as Element of NAT by INT_1:16;
       a' - 0 * b' = a';
       hence thesis;
     end;
     case A5: a' < 0;
       A6: a' - a' * b' = (-a') * (b' - 1);
           0 < -a' by A5,XREAL_1:60;
       then reconsider n = -a' as Element of NAT by INT_1:16;
          1 + 0 <= b' by A1,A2,A3,Lm3,INT_1:20;
       then 1 - 1 <= b' - 1 by XREAL_1:11;
       then reconsider m = b' - 1 as Element of NAT by INT_1:16;
           n * m is Element of NAT;
       hence thesis by A6;
     end;
     end;
     hence thesis;
     end;
      ex k being Nat st P[k] &
  for n being Nat st P[n] holds k <= n from NAT_1:sch 5(A4);
  then consider k' being Nat such that
  A7: ex s being Integer st k' = a' - s * b' &
       for n being Nat st ex s' being Integer st n = a' - s' * b'
       holds k' <= n;
  consider l' being Integer such that
  A8: k' = a' - l' * b' by A7;
  A9: k' = 0 or k' < b'
      proof
      assume k' <> 0;
      assume b' <= k';
      then reconsider k = k' - b' as Element of NAT by INT_1:18;
      A10: k' > k
        proof
        assume k' <= k;
        then consider x being Nat such that
        A11: k = k' + x by NAT_1:10;
        reconsider b' as Element of NAT by A3,INT_1:16;
        A12: 0 < b' by A1,A2,Lm3;
            - x = b' by A11;
        hence contradiction by A12;
        end;
          k' - b' = a' - (l' + 1) * b' by A8;
      hence thesis by A7,A10;
      end;
  reconsider k = k',l = l' as Element of M by INT_1:def 2;
  consider d being Element of M;
  consider d' being Integer;
  A13: k + l * b = a by A2,A8;
      k = 0.M or absint.k < absint.b
       proof
       assume A14: k <> 0.M;
       A15: absint.k = absreal.(k) by Def6
                   .= abs(k') by EUCLID:def 2
                   .= k' by ABSVALUE:def 1;
       reconsider b' as Element of NAT by A3,INT_1:16;
           absint.b = absreal.(b') by A2,Def6
               .= abs(b') by EUCLID:def 2
               .= b' by ABSVALUE:def 1;
       hence thesis by A9,A14,A15,FUNCT_7:def 1;
       end;
  hence thesis by A13;
  end;

Lm8:for a,b being Element of INT.Ring
  st b <> 0.INT.Ring
  for b' being Integer st b' = b holds
  0 <= b' implies
     ex q,r being Element of INT.Ring st
     a = q * b + r & 0.INT.Ring <= r & r < abs(b)
  proof
  let a,b be Element of M;
  assume A1: b <> 0.M;
  let b' be Integer;
  assume A2: b' = b;
  assume A3: 0 <= b';
  reconsider a' = a as Integer;
  defpred P[Nat] means ex s being Integer st $1 = a' - s * b';
  A4: ex k being Nat st P[k]
     proof
      now per cases;
     case 0 <= a';
       then reconsider a' as Element of NAT by INT_1:16;
       a' - 0 * b' = a';
       hence thesis;
     end;
     case A5: a' < 0;
       A6: a' - a' * b' = (-a') * (b' - 1);
           0 < -a' by A5,XREAL_1:60;
       then reconsider n = -a' as Element of NAT by INT_1:16;
          1 + 0 <= b' by A1,A2,A3,Lm3,INT_1:20;
       then 1 - 1 <= b' - 1 by XREAL_1:11;
       then reconsider m = b' - 1 as Element of NAT by INT_1:16;
       n * m is Element of NAT;
       hence thesis by A6;
     end;
     end;
     hence thesis;
     end;
      ex k being Nat st P[k] &
  for n being Nat st P[n] holds k <= n from NAT_1:sch 5(A4);
  then consider k' being Nat such that
  A7: ex s being Integer st k' = a' - s * b' &
       for n being Nat st ex s' being Integer st n = a' - s' * b'
       holds k' <= n;
  consider l' being Integer such that
  A8: k' = a' - l' * b' by A7;
  A9: k' = 0 or k' < b'
      proof
      assume k' <> 0;
      assume b' <= k';
      then reconsider k = k' - b' as Element of NAT by INT_1:18;
      A10: k' > k
        proof
        assume k' <= k;
        then consider x being Nat such that
        A11: k = k' + x by NAT_1:10;
        reconsider b' as Element of NAT by A3,INT_1:16;
        A12: 0 < b' by A1,A2,Lm3;
        - x = b' by A11;
        hence contradiction by A12;
        end;
          k' - b' = a' - (l' + 1) * b' by A8;
      hence thesis by A7,A10;
      end;
  reconsider k = k',l = l' as Element of M by INT_1:def 2;
  consider d being Element of M;
  consider d' being Integer;
  A13: k + l * b = a by A2,A8;
      0.M <= k & k < abs(b)
       proof
       reconsider k' as Element of NAT by ORDINAL1:def 13;
       reconsider b' as Element of NAT by A3,INT_1:16;
       A14: absint.b = b'
           proof
               absint.b = absreal.b' by A2,Def6
                   .= abs(b') by EUCLID:def 2
                   .= b' by ABSVALUE:def 1;
           hence thesis;
           end;
       then A15: abs(b) <> 0.M by A1,A2,Th1;
           now per cases by A9;
       case k' = 0;
         hence thesis by A14,A15,Lm3,Th1;
       end;
       case k' < b';
         hence thesis by A14,Lm2,Th1,FUNCT_7:def 1;
       end;
       end;
       hence thesis;
       end;
  hence thesis by A13;
  end;

theorem
Th2:for a,b,q1,q2,r1,r2 being Element of INT.Ring
st b <> 0.INT.Ring &
   a = q1 * b + r1 & 0.INT.Ring <= r1 & r1 < abs(b) &
   a = q2 * b + r2 & 0.INT.Ring <= r2 & r2 < abs(b)
holds q1 = q2 & r1 = r2
 proof
 let a,b,q1,q2,r1,r2 be Element of INT.Ring;
 assume A1: b <> 0.INT.Ring &
        a = q1 * b + r1 & 0.INT.Ring <= r1 & r1 < abs(b) &
        a = q2 * b + r2 & 0.INT.Ring <= r2 & r2 < abs(b);
 reconsider a' = a as Integer;
 reconsider b' = b as Integer;
 reconsider q1' = q1 as Integer;
 reconsider q2' = q2 as Integer;
 reconsider r1' = r1 as Integer;
 reconsider r2' = r2 as Integer;
  now per cases;
 case A2: 0 <= r1' - r2';
   A3: (q2' - q1') * b' = r1' - r2' by A1;
       now per cases;
   case 0 = r1' - r2';
     then q2' - q1' = 0 or b' = 0 by A3,XCMPLX_1:6;
     hence q1 = q2 by A1,FUNCT_7:def 1;
   end;
   case 0 <> r1' - r2';
     then 0 <> q2' - q1' by A3;
     then A4: absreal.(q2' - q1') >= 1 by Lm6;
     A5: absreal.(q2' - q1') * absreal.b' >= absreal.b'
          proof
              absreal.b' = absint.b by Def6;
          then reconsider c = absreal.b' as Element of NAT;
          reconsider d' = q2' - q1' as Integer;
          reconsider e = q2 + -q1 as Element of M;
           absreal.d' = absint.e by Def6;
          then reconsider d = absreal.d' as Element of NAT;
              d * c >= 1 * c by A4,NAT_1:4;
          hence thesis;
          end;
     consider i1,i2 being Integer such that
     A6: i1 = 0.M & i2 = r2 & i1 <= i2 by A1;
         -r2' <= -0 by A6,Lm3,XREAL_1:26;
     then A7: r1' + -r2' <= r1' + 0 by XREAL_1:8;
     A8: abs(b) = absint.b by Th1 .= absreal.b by Def6;
         r1' - r2' = abs(((q2' - q1') * b')) by A1,A2,ABSVALUE:def 1
              .= abs((q2' - q1')) * abs(b') by COMPLEX1:151
              .= absreal.(q2' - q1') * abs(b') by EUCLID:def 2
              .= absreal.(q2' - q1') * absreal.b' by EUCLID:def 2;
     hence q1 = q2 by A1,A5,A7,A8,XXREAL_0:2;
   end;
   end;
   hence q1 = q2;
 end;
 case A9: r1' - r2' < 0;
   then A10: -(r1' - r2') > 0 by XREAL_1:60;
   A11: -(r1' - r2') = r2' - r1';
    (q1' - q2') * b' = r2' - r1' by A1;
   then 0 <> q1' - q2' by A9,A11,XREAL_1:60;
   then A12: absreal.(q1' - q2') >= 1 by Lm6;
   A13: absreal.(q1' - q2') * absreal.b' >= absreal.b'
        proof
            absreal.b' = absint.b by Def6;
        then reconsider c = absreal.b' as Element of NAT;
        reconsider d' = q1' - q2' as Integer;
        reconsider e = q1 + -q2 as Element of M;
         absreal.d' = absint.e by Def6;
        then reconsider d = absreal.d' as Element of NAT;
            d * c >= 1 * c by A12,NAT_1:4;
        hence thesis;
        end;
   consider i1,i2 being Integer such that
   A14: i1 = 0.M & i2 = r1 & i1 <= i2 by A1;
       -r1' <= -0 by A14,Lm3,XREAL_1:26;
   then A15: r2' + -r1' <= r2' + 0 by XREAL_1:8;
   A16: abs(b) = absint.b by Th1 .= absreal.b by Def6;
       r2' - r1' = abs(((q1' - q2') * b')) by A1,A10,ABSVALUE:def 1
            .= abs((q1' - q2')) * abs(b') by COMPLEX1:151
            .= absreal.(q1' - q2') * abs(b') by EUCLID:def 2
            .= absreal.(q1' - q2') * absreal.b' by EUCLID:def 2;
   hence q1 = q2 by A1,A13,A15,A16,XXREAL_0:2;
   end;
   end;
 hence thesis by A1;
end;

definition
let a,b be Element of INT.Ring;
assume A1:b <> 0.INT.Ring;
func a div b -> Element of INT.Ring means :Def7:
 ex r being Element of INT.Ring st
 a = it * b + r & 0.INT.Ring <= r & r < abs(b);
existence
  proof
  reconsider b' = b as Integer;
      now per cases;
  case 0 <= b';
  hence thesis by A1,Lm8;
  end;
  case A2: b' < 0;
  then A3: 0 < -b' by XREAL_1:60;
  reconsider c = -b' as Element of M by INT_1:def 2;
  consider q,r being Element of M such that
  A4: a = q * c + r & 0.M <= r & r < abs(c) by A3,Lm3,Lm8;
  reconsider t = -q as Element of M;
  reconsider q' = q, r' = r as Integer;
  A5: t * b + r = a by A4;
      0.M <= r & r < abs(b)
    proof
        absint.c = absreal.c by Def6
            .= abs((-b')) by EUCLID:def 2
            .= -b' by A3,ABSVALUE:def 1
            .= abs((b')) by A2,ABSVALUE:def 1
            .= absreal.b' by EUCLID:def 2
            .= absint.b by Def6
            .= abs(b) by Th1;
    hence thesis by A4,Th1;
    end;
  hence thesis by A5;
  end;
  end;
  hence thesis;
  end;
uniqueness by A1,Th2;
end;

definition
let a,b be Element of INT.Ring;
assume A1:b <> 0.INT.Ring;
func a mod b -> Element of INT.Ring means :Def8:
 ex q being Element of INT.Ring st
 a = q * b + it & 0.INT.Ring <= it & it < abs(b);
existence
  proof
  reconsider b' = b as Integer;
      now per cases;
  case 0 <= b';
  then ex q,r being Element of INT.Ring st
   a = q * b + r & 0.INT.Ring <= r & r < abs(b) by A1,Lm8;
  hence thesis;
  end;
  case A2: b' < 0;
  then A3: 0 < -b' by XREAL_1:60;
  reconsider c = -b' as Element of M by INT_1:def 2;
  consider q,r being Element of M such that
  A4: a = q * c + r & 0.M <= r & r < abs(c) by A3,Lm3,Lm8;
  reconsider t = -q as Element of M;
  A5: t * b + r = a by A4;
      0.M <= r & r < abs(b)
    proof
        absint.c = absreal.c by Def6
            .= abs(-b') by EUCLID:def 2
            .= -b' by A3,ABSVALUE:def 1
            .= abs(b') by A2,ABSVALUE:def 1
            .= absreal.b' by EUCLID:def 2
            .= absint.b by Def6
            .= abs(b) by Th1;
    hence thesis by A4,Th1;
    end;
  hence thesis by A5;
  end;
  end;
  hence thesis;
  end;
uniqueness by A1,Th2;
end;

theorem
   for a,b being Element of INT.Ring
st b <> 0.INT.Ring holds a = (a div b) * b + (a mod b)
proof
let a,b be Element of INT.Ring;
assume A1: b <> 0.INT.Ring;
consider d being Element of INT.Ring such that
A2: d = (a div b);
consider c being Element of INT.Ring such that
A3: c = a mod b;
consider r being Element of INT.Ring such that
A4: a = d * b + r & 0.INT.Ring <= r & r < abs(b) by A1,A2,Def7;
consider q being Element of INT.Ring such that
A5: a = q * b + c & 0.INT.Ring <= c & c < abs(b) by A1,A3,Def8;
thus thesis by A1,A2,A3,A4,A5,Th2;
end;

::: Euclidian Domains
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

begin

definition
let I be non empty doubleLoopStr;
attr I is Euclidian means :Def9:
 ex f being Function of the carrier of I,NAT st
 for a,b being Element of I st b <> 0.I holds
 ex q,r being Element of I st
  a = q * b + r & (r = 0.I or f.r < f.b);
end;

registration
 cluster INT.Ring -> Euclidian;
coherence
 proof
  take absint;
  let a,b be Element of M;
  assume A1: b <> 0.M;
  reconsider b' = b as Integer;
      now per cases;
  case 0 <= b';
  hence thesis by A1,Lm7;
  end;
  case A2: b' < 0;
  then A3: 0 < -b' by XREAL_1:60;
  reconsider c = -b' as Element of M by INT_1:def 2;
  consider q,r being Element of M such that
  A4: a = q * c + r & (r = 0.M or absint.r < absint.c) by A3,Lm3,Lm7;
  reconsider t = -q as Element of M;
  A5: t * b + r = a by A4;
      r = 0.M or absint.r < absint.b
    proof
    assume A6: r <> 0.M;
        absint.c = absreal.c by Def6
            .= abs(-b') by EUCLID:def 2
            .= -b' by A3,ABSVALUE:def 1
            .= abs(b') by A2,ABSVALUE:def 1
            .= absreal.(b') by EUCLID:def 2
            .= absint.b by Def6;
    hence thesis by A4,A6;
    end;
  hence ex q,r being Element of M st
        (a = q * b + r & (r = 0.M or absint.r < absint.b)) by A5;
  end;
  end;
  hence thesis;
  end;
end;

Lm9:for F being commutative associative well-unital Field-like right_zeroed
  (non empty doubleLoopStr)
  for f being Function of the carrier of F,NAT holds
    (for a,b being Element of F st b <> 0.F holds
    (ex q,r being Element of F st
     (a = q * b + r & (r = 0.F or f.r < f.b))))
  proof
  let F be commutative associative well-unital Field-like right_zeroed
     (non empty doubleLoopStr);
  let f be Function of the carrier of F,NAT;
      now let a,b be Element of F;
  assume A1: b <> 0.F;
      (ex q,r being Element of F st
        (a = q * b + r & (r = 0.F or f.r < f.b)))
      proof
      consider x being Element of F such that
      A2: b * x = 1.F by A1,VECTSP_1:def 20;
            (a * x) * b + 0.F
         = a * 1.F + 0.F by A2,GROUP_1:def 4
        .= a + 0.F by VECTSP_1:def 16
        .= a by RLVECT_1:def 7;
      hence thesis;
      end;
  hence b <> 0.F implies
      (ex q,r being Element of F st
        (a = q * b + r & (r = 0.F or f.r < f.b)));
  end;
  hence thesis;
  end;

registration
cluster strict Euclidian domRing-like non degenerated
        distributive commutative Ring;
existence
proof
  take INT.Ring;
  thus thesis;
end;
end;

definition
mode EuclidianRing is Euclidian domRing-like non degenerated
     distributive commutative Ring;
end;

registration
cluster strict EuclidianRing;
existence
 proof
   take INT.Ring;
   thus thesis;
 end;
end;

definition
let E be Euclidian (non empty doubleLoopStr);
mode DegreeFunction of E ->
              Function of the carrier of E,NAT means :Def10:
 (for a,b being Element of E
  st b <> 0.E holds
  (ex q,r being Element of E st
  (a = q * b + r & (r = 0.E or it.r < it.b))));
existence by Def9;
end;

theorem
Th4:for E being EuclidianRing holds E is gcdDomain
proof
 let E be EuclidianRing;
 consider d being DegreeFunction of E;
     E is gcd-like
     proof
         now let x,y be Element of E;
         now per cases;
     case A1: x = 0.E;
          y * 0.E = 0.E by VECTSP_1:36;
     then A2: y divides 0.E by GCD_1:def 1;
         for zz being Element of E
          st (zz divides x & zz divides y)
          holds (zz divides y);
     hence ex z being Element of E st
           z divides x & z divides y &
           for zz being Element of E st
           (zz divides x & zz divides y) holds zz divides z by A1,A2;
     end;
     case A3: x <> 0.E;
     set M = { z where z is Element of E:
               ex s,t being Element of E
               st z = s * x + t * y};
     A4: x in M & y in M
         proof
         A5:   1.E * x + 0.E * y
             = 1.E * x + 0.E by VECTSP_1:39
            .= 1.E * x by RLVECT_1:def 7
            .= x by VECTSP_1:def 16;
                0.E * x + 1.E * y
             = 0.E + 1.E * y by VECTSP_1:39
            .= 1.E * y by RLVECT_1:10
            .= y by VECTSP_1:def 16;
         hence thesis by A5;
         end;
     defpred P[Nat] means
        ex z being Element of E
        st (z in M & z <> 0.E & $1 = d.z);
     A6: ex k being Nat st P[k]
         proof
          ex k being Element of NAT st k = d.x;
         hence thesis by A3,A4;
         end;
          ex k being Nat st P[k] &
         for n being Nat st P[n] holds k <= n from NAT_1:sch 5(A6);
     then consider k being Nat such that
     A7: P[k] & for n being Nat st P[n] holds k <= n;
     consider g being Element of E such that
     A8: g in M & g <> 0.E & k = d.g &
         for n being Nat st
         (ex z being Element of E st z in M & z <> 0.E & n = d.z)
         holds k <= n by A7;
     set G = { z where z is Element of E:
               ex r being Element of E
               st z = r * g};
     A9: M = G
     proof
     A10: for z being set holds z in M implies z in G
         proof
         let z be set;
         assume z in M;
         then consider z2 being Element of E such that
         A11: z = z2 &
              ex s,t being Element of E st
              z2 = s * x + t * y;
         reconsider z as Element of E by A11;
         consider u,v being Element of E such that
         A12: z2 = u * x + v * y by A11;
         consider q,r being Element of E such that
         A13: z = q * g + r & (r = 0.E or d.r < d.g) by A8,Def10;
             r in M
              proof
              A14:   z + (-(q * g))
                  = r + ((q * g) + (-(q * g))) by A13,RLVECT_1:def 6
                 .= r + 0.E by RLVECT_1:def 10
                 .= r by RLVECT_1:def 7;
              consider z1 being Element of E such that
              A15: g = z1 &
                  ex s,t being Element of E st
                  z1 = s * x + t * y by A8;
              consider s,t being Element of E such that
              A16: z1 = s * x + t * y by A15;
                   r = z + (-(q * (s * x) + q * (t * y)))
 by A14,A15,A16,VECTSP_1:def 18
                   .= z + ((-(q * (s * x))) + (-(q * (t * y))))
 by RLVECT_1:45
                   .= ((u * x + v * y) + (-(q * (s * x)))) + (-(q * (t * y)))
 by A11,A12,RLVECT_1:def 6
                   .= ((u * x + (-(q * (s * x)))) + v * y) + (-(q * (t * y)))
 by RLVECT_1:def 6
                   .= (u * x + (-(q * (s * x)))) + (v * y + (-(q * (t * y))))
 by RLVECT_1:def 6
                   .= (u * x + ((-q) * (s * x))) + (v * y + (-(q * (t * y))))
 by GCD_1:51
                   .= (u * x + ((-q) * (s * x))) + (v * y + ((-q) * (t * y)))
 by GCD_1:51
                   .= (u * x + ((-q) * s) * x) + (v * y + ((-q) * (t * y)))
 by GROUP_1:def 4
                   .= (u * x + ((-q) * s) * x) + (v * y + ((-q) * t) * y)
 by GROUP_1:def 4
                   .= (u + ((-q) * s)) * x + (v * y + ((-q) * t) * y)
 by VECTSP_1:def 18
                   .= (u + ((-q) * s)) * x + (v + ((-q) * t)) * y
 by VECTSP_1:def 18;
              hence thesis;
              end;
         then r = 0.E by A8,A13;
          then z = q * g by A13,RLVECT_1:def 7;
         hence thesis;
         end;
         for z being set holds z in G implies z in M
         proof
         let z be set;
         assume z in G;
         then consider z2 being Element of E such that
         A17: z = z2 &
              ex s being Element of E st
              z2 = s * g;
         reconsider z as Element of E by A17;
         consider u being Element of E such that
         A18: z2 = u * g by A17;
         consider z1 being Element of E such that
         A19: g = z1 &
              ex s,t being Element of E st
              z1 = s * x + t * y by A8;
         consider s,t being Element of E such that
         A20: z1 = s * x + t * y by A19;
              z = u * (s * x) + u * (t * y) by A17,A18,A19,A20,VECTSP_1:def 11
           .= (u * s) * x + u * (t * y) by GROUP_1:def 4
           .= (u * s) * x + (u * t) * y by GROUP_1:def 4;
         hence thesis;
         end;
     hence thesis by A10,TARSKI:2;
     end;
     A21: g divides x & g divides y
          proof
          consider zz being Element of E such that
          A22: x = zz &
              ex r being Element of E st
              zz = r * g by A4,A9;
          consider zzz being Element of E such that
          A23: y = zzz &
              ex r being Element of E st
              zzz = r * g by A4,A9;
          thus thesis by A22,A23,GCD_1:def 1;
          end;
         for z being Element of E
          holds (z divides x & z divides y) implies z divides g
          proof
          let z be Element of E;
          assume A24: z divides x & z divides y;
          then consider u being Element of E such that
          A25: x = z * u by GCD_1:def 1;
          consider v being Element of E such that
          A26: y = z * v by A24,GCD_1:def 1;
          consider zz being Element of E such that
          A27: g = zz &
              ex s,t being Element of E st
              zz = s * x + t * y by A8;
          consider s,t being Element of E such that
          A28: zz = s * x + t * y by A27;
               g = (s * u) * z + t * (v * z) by A25,A26,A27,A28,GROUP_1:def 4
            .= (s * u) * z + (t * v) * z by GROUP_1:def 4
            .= (s * u + t * v) * z by VECTSP_1:def 18;
          hence thesis by GCD_1:def 1;
          end;
     hence ex z being Element of E st
          z divides x & z divides y &
          for zz being Element of E st
          (zz divides x & zz divides y) holds zz divides z by A21;
     end;
     end;
     hence ex z being Element of E st
          z divides x & z divides y &
          for zz being Element of E st
          (zz divides x & zz divides y) holds zz divides z;
     end;
     hence thesis by GCD_1:def 11;
     end;
hence thesis;
end;

registration
cluster Euclidian -> gcd-like (domRing-like non degenerated
    Abelian add-associative right_zeroed right_complementable
    associative commutative well-unital right-distributive
     (non empty doubleLoopStr));
coherence by Th4;
end;

definition
redefine func absint -> DegreeFunction of INT.Ring;
coherence
proof
     for a,b being Element of M st b <> 0.M holds
  (ex q,r being Element of M st
  (a = q * b + r & (r = 0.M or absint.r < absint.b)))
  proof
  let a,b be Element of M;
  assume A1: b <> 0.M;
  reconsider b' = b as Integer;
      now per cases;
  case 0 <= b';
  hence thesis by A1,Lm7;
  end;
  case A2: b' < 0;
  then A3: 0 < -b' by XREAL_1:60;
  reconsider c = -b' as Element of M by INT_1:def 2;
  consider q,r being Element of M such that
  A4: (a = q * c + r & (r = 0.M or absint.r < absint.c)) by A3,Lm3,Lm7;
  reconsider t = -q as Element of M;
  A5: t * b + r = a by A4;
      r = 0.M or absint.r < absint.b
    proof
    assume A6: r <> 0.M;
        absint.c = absreal.c by Def6
            .= abs((-b')) by EUCLID:def 2
            .= -b' by A3,ABSVALUE:def 1
            .= abs((b')) by A2,ABSVALUE:def 1
            .= absreal.(b') by EUCLID:def 2
            .= absint.b by Def6;
    hence thesis by A4,A6;
    end;
  hence ex q,r being Element of M st
        (a = q * b + r & (r = 0.M or absint.r < absint.b)) by A5;
  end;
  end;
  hence thesis;
  end;
hence thesis by Def10;
end;
end;

theorem
Th5:for F being commutative associative well-unital Field-like right_zeroed
  (non empty doubleLoopStr) holds F is Euclidian
proof
let F be commutative associative well-unital Field-like right_zeroed
  (non empty doubleLoopStr);
consider f being Function of the carrier of F,NAT;
     (for a,b being Element of F st b <> 0.F holds
    (ex q,r being Element of F st
     (a = q * b + r & (r = 0.F or f.r < f.b)))) by Lm9;
hence thesis by Def9;
end;

registration
cluster commutative associative well-unital Field-like right_zeroed Field-like
  -> Euclidian (non empty doubleLoopStr);
coherence by Th5;
end;

theorem
    for F being commutative associative well-unital Field-like right_zeroed
  (non empty doubleLoopStr)
for f being Function of the carrier of F,NAT holds
f is DegreeFunction of F
proof
let F be commutative associative well-unital Field-like right_zeroed
  (non empty doubleLoopStr);
let f be Function of the carrier of F,NAT;
    (for a,b being Element of F st b <> 0.F holds
    (ex q,r being Element of F st
     (a = q * b + r & (r = 0.F or f.r < f.b)))) by Lm9;
hence thesis by Def10;
end;

::: Some Theorems about DIV and MOD
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

begin

canceled;

theorem
Th8:for n,a,k being Integer holds
(n <> 0 implies (a + n * k) div n = (a div n) + k) &
(a + n * k) mod n = a mod n
proof
let n,a,k be Integer;
thus
A1: now
  assume A2: n <> 0;
  thus (a + n * k) div n = [\ (a + n * k)/n /] by INT_1:def 7
    .= [\ (a + n * k) * n" /] by XCMPLX_0:def 9
    .= [\ a * n" + (n * n") * k /]
    .= [\ a * n" + 1 * k /] by A2,XCMPLX_0:def 7
    .= [\ a * n" /] + k by INT_1:51
    .= [\ a/n /] + k by XCMPLX_0:def 9
    .= (a div n) + k by INT_1:def 7;
end;
per cases;
suppose A3: n <> 0;
hence (a + n * k) mod n = (a + n * k) - ((a div n) + k) * n by A1,INT_1:def 8
   .= a - (a div n) * n
   .= a mod n by A3,INT_1:def 8;
end;
suppose n = 0;
hence thesis;
end;
end;

theorem
Th9:for n being natural number st n > 0
for a being Integer holds a mod n >= 0 & a mod n < n
proof
let n be natural number; assume A1: n > 0;
let a be Integer;
    now
      a div n = [\ a/n /] by INT_1:def 7;
  then a div n <= a/n by INT_1:def 4;
  then (a div n) * n <= a/n * n by XREAL_1:66;
  then (a div n) * n <= (a * n") * n by XCMPLX_0:def 9;
  then (a div n) * n <= a * (n" * n);
  then (a div n) * n <= a * 1 by A1,XCMPLX_0:def 7;
  then (a div n) * n - (a div n) * n <= a - (a div n) * n by XREAL_1:11;
  hence 0 <= a mod n by A1,INT_1:def 8;
  assume a mod n >= n;
  then a - (a div n) * n >= n by A1,INT_1:def 8;
  then (a + -(a div n) * n) + (a div n) * n >= n + (a div n) * n
 by XREAL_1:8;
  then a - n >= (n + (a div n) * n) - n by XREAL_1:11;
  then (a - n) * n" >= ((a div n) * n) * n" by XREAL_1:66;
  then (a - n) * n" >= (a div n) * (n * n");
  then a * n" - n * n" >= (a div n) * 1 by A1,XCMPLX_0:def 7;
  then a * n" - 1 >= (a div n) by A1,XCMPLX_0:def 7;
  then A2: a/n - 1 >= (a div n) by XCMPLX_0:def 9;
      a div n = [\ a/n /] by INT_1:def 7;
  hence contradiction by A2,INT_1:def 4;
end;
hence thesis;
end;

theorem
Th10:for n,a being Integer holds
(0 <= a & a < n implies a mod n = a) &
(0 > a & a >= -n implies a mod n = n + a)
proof
let n,a be Integer;
per cases;
suppose n = 0;
hence thesis;
end;
suppose A1: n <> 0;
hereby
   assume A2: 0 <= a & a < n;
   then reconsider aa = a as Element of NAT by INT_1:16;
   reconsider nn = n as Element of NAT by A2,INT_1:16;
   consider t being Nat such that
   A3: aa = nn * t + (aa mod nn) & (aa mod nn) < nn by A1,NAT_D:def 2;
       t = 0
     proof
     assume A4: t <> 0;
       t >= 0;
     then t >= 1 + 0 by A4,INT_1:20;
     then A5: t * n >= 1 * n by A2,XREAL_1:66;
       nn * t + (aa mod nn) >= nn * t by NAT_1:11;
     hence thesis by A2,A3,A5,XXREAL_0:2;
     end;
   hence a mod n = a by A3;
   end;
   assume A6: 0 > a & a >= -n;
   then A7: n >= 0 by XREAL_1:60;
   A8: a mod n = a - (a div n) * n by A1,INT_1:def 8;
   A9: -1 <= a/n
   proof
         n" > 0 by A1,A7,XREAL_1:124;
       then a * n" >= (-n) * n" by A6,XREAL_1:66;
       then a /n >= -(n * n") by XCMPLX_0:def 9;
       hence thesis by A1,XCMPLX_0:def 7;
       end;
       a/n - 1 < -1
       proof
       assume a/n - 1 >= -1;
       then (a/n - 1) + 1 >= -1 + 1 by XREAL_1:8;
       then a * n" >= 0 by XCMPLX_0:def 9;
       then (a * n") * n >= 0 * n by A7,XREAL_1:66;
       then a * (n" * n) >= 0;
       then a * 1 >= 0 by A1,XCMPLX_0:def 7;
       hence thesis by A6;
       end;
   then [\ a/n /] = -1 by A9,INT_1:def 4;
   then a div n = -1 by INT_1:def 7;
   hence thesis by A8;
end;
end;

canceled;

theorem
Th12:for n,a,b being Integer holds
(n <> 0 & a mod n = b mod n implies a,b are_congruent_mod n) &
(a,b are_congruent_mod n implies a mod n = b mod n)
proof
let n,a,b be Integer;
hereby
  assume A1: n <> 0;
  assume a mod n = b mod n;
  then a - (a div n) * n = b mod n by A1,INT_1:def 8;
  then a - (a div n) * n = b - (b div n) * n by A1,INT_1:def 8;
  then a - b = (-(b div n) + (a div n)) * n;
  then n divides (a-b) by INT_1:def 9;
  hence a,b are_congruent_mod n by INT_2:19;
end;
  assume a,b are_congruent_mod n;
  then n divides (a-b) by INT_2:19;
  then consider k being Integer such that A2: n * k = a - b by INT_1:def 9;
    a = n * k + b by A2;
  hence a mod n = b mod n by Th8;
end;

theorem
Th13:for n being natural number
for a being Integer holds (a mod n) mod n = a mod n
proof
let n be natural number;
let a be Integer;
per cases;
suppose
A1: n = 0;
hence (a mod n) mod n = 0 by INT_1:def 8
    .= a mod n by A1,INT_1:def 8;
end;
suppose n <> 0;
then A2: n > 0;
then A3: a mod n >= 0 by Th9;
    a mod n < n by A2,Th9;
hence thesis by A3,Th10;
end;
end;

theorem
Th14:for n,a,b being Integer holds
(a + b) mod n = ((a mod n) + (b mod n)) mod n
proof
let n,a,b be Integer;
per cases;
suppose
A1: n = 0;
hence (a + b) mod n = 0 by INT_1:def 8
   .= ((a mod n) + (b mod n)) mod n by A1,INT_1:def 8;
end;
suppose A2: n <> 0;
  then A3: a mod n + (a div n) * n = (a - (a div n) * n) + (a div n) * n
  by INT_1:def 8;
    b mod n + (b div n) * n = (b - (b div n) * n) + (b div n) * n
  by A2,INT_1:def 8;
   then (a + b) - ((a mod n) + (b mod n))
 = ((a div n) + (b div n)) * n by A3;
then n divides (a + b) - ((a mod n) + (b mod n)) by INT_1:def 9;
then a+b,(a mod n)+(b mod n) are_congruent_mod n by INT_2:19;
hence thesis by Th12;
end;
end;

theorem
Th15:for n,a,b being Integer holds
(a * b) mod n = ((a mod n) * (b mod n)) mod n
proof
let n,a,b be Integer;
per cases;
suppose
A1: n = 0;
hence (a * b) mod n = 0 by INT_1:def 8
   .= ((a mod n) * (b mod n)) mod n by A1,INT_1:def 8;
end;
suppose A2: n <> 0;
  then A3: a mod n + (a div n) * n = (a - (a div n) * n) + (a div n) * n
  by INT_1:def 8;
    b mod n + (b div n) * n = (b - (b div n) * n) + (b div n) * n
  by A2,INT_1:def 8;
   then (a * b) - ((a mod n) * (b mod n))
 = (((a mod n) * (b div n)) + (((a div n) * (b mod n)) +
      (((a div n) * n) * (b div n)))) * n by A3;
then n divides ((a * b) - ((a mod n) * (b mod n))) by INT_1:def 9;
then (a*b),((a mod n)*(b mod n)) are_congruent_mod n by INT_2:19;
hence thesis by Th12;
end;
end;

theorem
Th16:for a,b being Integer ex s,t being Integer st a gcd b = s * a + t * b
proof
let a,b be Integer;
A1: for a,b being Integer st a > 0 & b > 0 holds
   (ex s,t being Integer st ((a gcd b) = (s * a + t * b)))
     proof
     let a,b be Integer;
     assume A2: a > 0 & b > 0;
     then reconsider a,b as Element of NAT by INT_1:16;
     set M = {z where z is Element of NAT :
     ex s,t being Integer st z = s * a + t * b};
     defpred P[Nat] means ($1 in M & $1 <> 0);
         a = 1 * a + 0 * b & b = 0 * a + 1 * b;
     then A3: a in M & b in M;
     then A4: ex k being Nat st P[k] by A2;
     consider g being Nat such that
     A5: P[g] & for n being Nat st P[n] holds
     g <= n from NAT_1:sch 5(A4);
     consider z being Element of NAT such that
     A6: z = g & ex s,t being Integer st z = s * a + t * b by A5;
     consider s,t being Integer such that A7: g = s * a + t * b by A6;
     set G = {zz where zz is Element of NAT :
     ex s being Element of NAT st zz = s * g};
     A8: abs(a) = a & abs(b) = b by ABSVALUE:def 1;
     A9: G = M
         proof
         A10: for x being set holds x in M implies x in G
            proof
            let x be set; assume x in M;
            then consider x' being Element of NAT such that
            A11: x' = x & ex u,v being Integer st x' = u * a + v * b;
            consider u,v being Integer such that A12: x = u * a + v * b by A11;
            consider r being Nat such that
            A13: x' = g * (x' div g) + r & r < g by A5,NAT_D:def 1;
A14:         r in NAT by ORDINAL1:def 13;
             r = x' - g * (x' div g) by A13
             .= (u * a + v * b) -
                ((a * (s * (x' div g))) + (b * (t * (x' div g))))
               by A7,A11,A12
             .= a * (u + -(s * (x' div g))) + b * (v + -(t * (x' div g)));
            then r in M by A14;
            then r = 0 by A5,A13,A14;
            hence thesis by A11,A13;
            end;
             for x being set holds x in G implies x in M
            proof
            let x be set; assume x in G;
            then consider x' being Element of NAT such that
            A15: x' = x & ex u being Element of NAT st x' = u * g;
            consider u being Integer such that A16: x = u * g by A15;
                x = (u * s) * a + (u * t) * b by A7,A16;
            hence thesis by A15;
            end;
         hence thesis by A10,TARSKI:2;
         end;
     then consider a' being Element of NAT
     such that A17: a' = a & ex s being Element of NAT st a' = s * g by A3;
     consider b' being Element of NAT
     such that A18: b' = b & ex t being Element of NAT st b' = t * g by A3,A9;
     consider u,v being Element of NAT such that
     A19: a = u * g & b = v * g by A17,A18;
     A20: g divides abs(a) & g divides abs(b) by A8,A19,NAT_D:def 3;
      for m being Nat st
     m divides abs(a) & m divides abs(b) holds m divides g
        proof
          let m be Nat; assume
          A21: m divides abs(a) & m divides abs(b);
          then consider u being Nat such that
          A22: a = m * u by A8,NAT_D:def 3;
          consider v being Nat such that
          A23: b = m * v by A8,A21,NAT_D:def 3;
        consider g' being Element of NAT such that
        A24: g' = g & ex s,t being Integer st g' = s * a + t * b by A5;
        consider s,t being Integer such that A25: g = s * a + t * b by A24;
        A26: g = m * (s * u + t * v) by A22,A23,A25;
            s * u + t * v is Element of NAT
          proof
              s * u + t * v >= 0
             proof
             assume A27: s * u + t * v < 0;
                m >= 0 & g >= 0;
             hence thesis by A5,A26,A27,XREAL_1:133;
             end;
          hence thesis by INT_1:16;
          end;
        hence thesis by A26,NAT_D:def 3;
        end;
     then g = abs(a) hcf abs(b) by A20,NAT_D:def 5
                .= a gcd b by INT_2:def 3;
     hence thesis by A7;
     end;
    now per cases;
case A28: a = 0 or b = 0;
A29:for a,b being Integer holds a = 0 implies a gcd b = abs(b)
    proof
    let a,b be Integer; assume a = 0;
    then A30: abs(a) = 0 by ABSVALUE:def 1;
    A31: a gcd b = abs(a) hcf abs(b) by INT_2:def 3;
    A32: abs(b) divides abs(a) by A30,NAT_D:6;
     for m being Nat st
    m divides abs(a) & m divides abs(b) holds m
    divides abs(b);
    hence thesis by A31,A32,NAT_D:def 5;
    end;
    now per cases by A28;
case a = 0;
  then A33: a gcd b = abs(b) by A29;
      now per cases;
    case b >= 0;
    hence a gcd b = 0 * a + 1 * b by A33,ABSVALUE:def 1;
    end;
    case b < 0;
    hence a gcd b = -(b * 1) by A33,ABSVALUE:def 1
                 .= 0 * a + (-1) * b;
  end;
  end;
  hence thesis;
end;
case b = 0;
  then A34: a gcd b = abs(a) by A29;
      now per cases;
    case a >= 0;
    hence a gcd b = 1 * a + 0 * b by A34,ABSVALUE:def 1;
    end;
    case a < 0;
    hence a gcd b = -(a * 1) by A34,ABSVALUE:def 1
                 .= 0 * b + (-1) * a;
  end;
  end;
  hence thesis;
end;
end;
hence thesis;
end;
case A35: a <> 0 & b <> 0;
    now per cases;
case a >= 0 & b >= 0; hence thesis by A1,A35;
end;
case a < 0 & b >= 0;
  then -a > 0 & b > 0 by A35,XREAL_1:60;
  then consider s,t being Integer such that A36: -a gcd b = s * -a + t * b by
A1;
  A37: s * -a + t * b = (-s) * a + t * b;
      a gcd b = abs(a) hcf abs(b) by INT_2:def 3
         .= abs((-a)) hcf abs(b) by COMPLEX1:138
         .= -a gcd b by INT_2:def 3;
  hence thesis by A36,A37;
end;
case a >= 0 & b < 0;
  then -b > 0 & a > 0 by A35,XREAL_1:60;
  then consider s,t being Integer such that A38: a gcd -b = s * a + t * -b by
A1;
  A39: s * a + t * -b = s * a + (-t) * b;
      a gcd b = abs(a) hcf abs(b) by INT_2:def 3
         .= abs(a) hcf abs((-b)) by COMPLEX1:138
         .= a gcd -b by INT_2:def 3;
  hence thesis by A38,A39;
end;
case a < 0 & b < 0;
  then -a > 0 & -b > 0 by XREAL_1:60;
  then consider s,t being Integer such that A40: -a gcd -b = s * -a + t * -b
by A1;
  A41: s * -a + t * -b = (-s) * a + (-t) * b;
      a gcd b = abs(a) hcf abs(b) by INT_2:def 3
         .= abs(a) hcf abs((-b)) by COMPLEX1:138
         .= abs((-a)) hcf abs((-b)) by COMPLEX1:138
         .= -a gcd -b by INT_2:def 3;
  hence thesis by A40,A41;
end;
end;
hence thesis;
end;
end;
hence thesis;
end;

::: Modulo Integers
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

begin

definition
let n be natural number such that A1:n > 0;
func multint(n) -> BinOp of Segm(n) means :Def11:
 for k,l being Element of Segm(n) holds
 it.(k,l) = (k * l) mod n;
existence
 proof
    reconsider n as non zero natural number by A1;
   defpred P[Element of Segm(n),Element of Segm(n),set]
   means $3 = ($1 * $2) mod n;
  A2: for k,l being Element of Segm(n) ex c being Element of Segm(n)
      st P[k,l,c]
      proof
      let k,l be Element of Segm(n);
      reconsider k' = k,l' = l as Element of NAT;
       ((k'*l') mod n) < n by NAT_D:1;
      then reconsider c = (k'*l') mod n as Element of Segm(n) by GR_CY_1:10;
      take c;
      thus thesis;
      end;
     ex c being BinOp of Segm(n) st
     for k,l being Element of Segm(n) holds P[k,l,c.(k,l)]
          from BINOP_1:sch 3(A2);
   hence thesis;
  end;
uniqueness
 proof
    reconsider n as non zero natural number by A1;
   deffunc O(Element of Segm(n),Element of Segm(n))=($1 * $2) mod n;
    for o1,o2 being BinOp of Segm(n) st
    (for a,b being Element of Segm(n) holds o1.(a,b) = O(a,b)) &
    (for a,b being Element of Segm(n) holds o2.(a,b) = O(a,b))
     holds o1 = o2 from BINOP_2:sch 2;
  hence thesis;
 end;
end;

definition
let n be natural number such that A1:n > 0;
func compint(n) -> UnOp of Segm(n) means :Def12:
 for k being Element of Segm(n) holds
 it.k = (n - k) mod n;
existence
 proof
    reconsider n as non zero natural number by A1;
 set f = {[k,(n-k) mod n] where k is Element of NAT : k < n };
 A2: f is Relation-like
    proof
        for x being set holds x in f implies ex y,z being set st x = [y,z]
     proof
      let x be set;
      assume x in f;
      then consider k being Element of NAT such that
      A3: x = [k,(n-k) mod n] & k < n;
      thus thesis by A3;
      end;
    hence thesis by RELAT_1:def 1;
    end;
     f is Function-like
   proof
       for x,y1,y2 being set st [x,y1] in f & [x,y2] in f holds y1 = y2
     proof
     let x,y1,y2 be set;
     assume A4: [x,y1] in f & [x,y2] in f;
     then consider k being Element of NAT such that
     A5: [x,y1] = [k,(n-k)mod n] & k < n;
     consider k' being Element of NAT such that
     A6: [x,y2] = [k',(n-k') mod n] & k' < n by A4;
     A7: k = [x,y1]`1 by A5,MCART_1:def 1
          .= x by MCART_1:def 1
          .= [k',(n-k')mod n]`1 by A6,MCART_1:def 1
          .= k' by MCART_1:def 1;
     A8: y1 = [k,(n-k)mod n]`2 by A5,MCART_1:def 2
           .= (n-k)mod n by MCART_1:def 2;
          y2 = [k',(n-k')mod n]`2 by A6,MCART_1:def 2
           .= (n-k')mod n by MCART_1:def 2;
     hence thesis by A7,A8;
     end;
   hence thesis by FUNCT_1:def 1;
   end;
 then reconsider f as Function by A2;
 A9: dom f = Segm(n)
    proof
    A10: for x being set holds x in dom f implies x in Segm(n)
        proof
        let x be set;
        assume x in dom f;
        then consider y being set such that A11: [x,y] in f by RELAT_1:def 4;
        consider k being Element of NAT such that
        A12: [x,y] = [k,(n-k)mod n] & k < n by A11;
            x = [k,(n-k)mod n]`1 by A12,MCART_1:def 1
         .= k by MCART_1:def 1;
        hence thesis by A12,GR_CY_1:10;
        end;
        for x being set holds x in Segm(n) implies x in dom f
        proof
        let x be set;
        assume A13: x in Segm(n);
        then reconsider x as Element of NAT;
            x < n by A13,GR_CY_1:10;
        then [x,(n-x)mod n] in f;
        hence thesis by RELAT_1:def 4;
        end;
    hence thesis by A10,TARSKI:2;
    end;
     rng f c= Segm(n)
    proof
        for y being set holds y in rng f implies y in Segm(n)
      proof
      let y be set;
      assume y in rng f;
      then consider x being set such that A14: [x,y] in f by RELAT_1:def 5;
      consider k being Element of NAT such that
      A15: [x,y] = [k,(n-k)mod n] & k < n by A14;
      A16: y = [k,(n-k)mod n]`2 by A15,MCART_1:def 2
           .= (n-k)mod n by MCART_1:def 2;
          k - k < n - k by A15,XREAL_1:11;
      then reconsider z = n - k as Element of NAT by INT_1:16;
       z mod n < n by NAT_D:1;
      hence thesis by A16,GR_CY_1:10;
      end;
    hence thesis by TARSKI:def 3;
    end;
 then reconsider f as UnOp of Segm(n) by A9,FUNCT_2:def 1,RELSET_1:11;
     for k being Element of Segm(n) holds f.(k) = (n - k) mod n
   proof
   let k be Element of Segm(n);
   reconsider k as Element of NAT;
       k < n by GR_CY_1:10;
   then [k,(n-k)mod n] in f;
   hence thesis by A9,FUNCT_1:def 4;
   end;
 hence thesis;
 end;
uniqueness
 proof
    reconsider n as non zero natural number by A1;
   deffunc F(Element of Segm(n))=(n - $1) mod n;
   for f1,f2 being UnOp of Segm(n) st
     (for a being Element of Segm(n) holds f1.a = F(a))
   & (for a being Element of Segm(n) holds f2.a = F(a))
    holds f1 = f2 from LMOD_7:sch 2;
  hence thesis;
 end;
end;

theorem
Th17:for n being natural number st n > 0
for a,b being Element of Segm(n) holds
(a + b < n iff (addint(n)).(a,b) = a + b) &
(a + b >= n iff (addint(n)).(a,b) = (a + b) - n)
proof
let n be natural number;
assume A1: n > 0;
let a,b be Element of Segm(n);
 reconsider n as non zero natural number by A1;
consider c being Element of NAT such that A2: c = (a + b) mod n;
consider t being Nat such that
A3: (a + b = n * t + c & c < n) or c = 0 & n = 0 by A2,NAT_D:def 2;
A4: now assume A5: a + b < n;
        t = 0
        proof
        assume A6: t <> 0;
            0 <= t;
        then 1 + 0 <= t by A6,INT_1:20;
        then A7: 1 * n <= t * n by XREAL_1:66;
            n * t <= n * t + c by NAT_1:11;
        hence thesis by A3,A5,A7,XXREAL_0:2;
        end;
    hence (addint(n)).(a,b) = a + b by A2,A3,GR_CY_1:def 5;
    end;
A8: (addint(n)).(a,b) = (a + b) implies a + b < n
    proof
    assume (addint(n)).(a,b) = (a + b);
    then (a + b) mod n = a + b by GR_CY_1:def 5;
    hence thesis by NAT_D:1;
    end;
A9: (addint(n)).(a,b) = (a + b) - n implies a + b >= n
    proof
    assume (addint(n)).(a,b) = (a + b) - n;
    then A10: (a + b) mod n = (a + b) - n by GR_CY_1:def 5;
    assume A11: a + b < n;
    consider t being Nat such that
    A12: a + b = n * t + ((a + b) mod n) & ((a + b) mod n) < n
 by NAT_D:def 2;
        t = 0
         proof
         assume A13: t <> 0;
          A14: t >= 0;
             1 <= t
            proof
                1 + 0 <= t by A13,A14,INT_1:20;
            hence thesis;
            end;
         then A15: 1 * n <= t * n by XREAL_1:66;
             t * n <= t * n + ((a + b) mod n) by NAT_1:11;
         hence thesis by A11,A12,A15,XXREAL_0:2;
         end;
    hence thesis by A10,A12;
    end;
    now assume A16: a + b >= n;
        t = 1
      proof
          now per cases;
        case t = 0;
          hence thesis by A3,A16;
        end;
        case A17: t <> 0;
              t < 2
            proof
            assume t >= 2;
            then A18: n * t >= n * 2 by XREAL_1:66;
            A19: n * t + c >= n * t by NAT_1:11;
             a < n & b < n by CARD_1:98;
            then a + b < n * 1 + n * 1 by XREAL_1:10;
            hence thesis by A3,A18,A19,XXREAL_0:2;
            end;
          then t < 1 + 1;
          then A20: t <= 1 by NAT_1:13;
              0 <= t;
          then 1 + 0 <= t by A17,INT_1:20;
          hence thesis by A20,XXREAL_0:1;
        end;
        end;
      hence thesis;
      end;
    hence (addint(n)).(a,b) = (a + b) - n by A2,A3,GR_CY_1:def 5;
    end;
hence thesis by A4,A8,A9;
end;

Lm10:for a,b being natural number st b <> 0 holds
ex k being Element of NAT st k * b <= a & a < (k + 1) * b
proof
let a,b be natural number;
assume A1: b <> 0;
set k' = a div b;
consider t being Nat such that
A2: a = b * k' + t & t < b by A1,NAT_D:def 1;
    (k' + 1) * b = k' * b + b;
then A3: (k' + 1) * b > a by A2,XREAL_1:8;
    k' * b <= k' * b + t by NAT_1:11;
hence thesis by A2,A3;
end;

theorem
Th18:for n being natural number st n > 0
for a,b being Element of Segm(n)
for k being natural number holds
(k * n <= a * b & a * b < (k + 1) * n)
iff (multint(n)).(a,b) = a * b - k * n
proof
let n be natural number;
assume A1: n > 0;
let a,b be Element of Segm(n);
reconsider a, b as Element of NAT by ORDINAL1:def 13;
let k be natural number;
A2: now assume (multint(n)).(a,b) = a * b - k * n;
   then A3: (a * b) mod n = a * b - k * n by A1,Def11;
   then A4: (a * b - k * n) + k * n >= 0 + k * n by XREAL_1:8;
   consider t being Nat such that
   A5: a * b = n * t + (a * b - n * k) & (a * b - n * k) < n
 by A1,A3,NAT_D:def 2;
       (k + 1) * n = k * n + n;
   hence k * n <= a * b & a * b < (k + 1) * n by A4,A5,XREAL_1:8;
   end;
    now assume A6: k * n <= a * b & a * b < (k + 1) * n;
consider c being Element of NAT such that A7: c = (a * b) mod n;
consider t being Nat such that
A8: (a * b = n * t + c & c < n) or c = 0 & n = 0 by A7,NAT_D:def 2;
    now
       now
        consider q being Nat such that
        A9: a * b = k * n + q by A6,NAT_1:10;
          t = k
        proof
            now per cases;
        case t <= k;
          then consider r being Nat such that
          A10: t + r = k by NAT_1:10;
              A11: n * t + c = t * n + (r * n + q) by A1,A8,A9,A10;
              now per cases;
          case t = k;
            hence thesis;
          end;
          case A12: t <> k;
                r >= 1
              proof
              assume A13: r < 1;
                  r = 0
                proof
                assume r <> 0;
                then r > 0;
                then 1 + 0 <= r by INT_1:20;
                hence thesis by A13;
                end;
              hence thesis by A10,A12;
              end;
            then r * n >= 1 * n by NAT_1:4;
            then A14: r * n + q >= 1 * n + q by XREAL_1:8;
                1 * n + q >= n by NAT_1:11;
            hence thesis by A1,A8,A11,A14,XXREAL_0:2;
          end;
          end;
          hence thesis;
        end;
        case t > k;
          then t >= k + 1 by INT_1:20;
          then A15: n * t >= n * (k + 1) by NAT_1:4;
              n * t + c >= n * t by NAT_1:11;
          hence thesis by A6,A8,A15,XXREAL_0:2;
        end;
        end;
        hence thesis;
        end;
      hence (multint(n)).(a,b) = a * b - k * n by A1,A7,A8,Def11;
   end;
   hence (multint(n)).(a,b) = a * b - k * n;
   end;
  hence (multint(n)).(a,b) = a * b - k * n;
end;
hence thesis by A2;
end;

theorem
    for n being natural number st n > 0
for a being Element of Segm(n) holds
(a = 0 iff (compint(n)).(a) = 0) &
(a <> 0 iff (compint(n)).(a) = n - a)
proof
let n be natural number;
assume A1: n > 0;
let a be Element of Segm(n);
 reconsider n as non zero natural number by A1;
reconsider a as Element of NAT by ORDINAL1:def 13;
A2: a < n by CARD_1:98;
then a - a < n - a by XREAL_1:11;
then reconsider b = n - a as Element of NAT by INT_1:16;
consider c being Element of NAT such that A3: c = b mod n;
consider t being Nat such that
A4: (b = n * t + c & c < n) or c = 0 & n = 0 by A3,NAT_D:def 2;
A5: n - a <= n
    proof
    assume n - a > n;
    then (n - a) + a > n + a by XREAL_1:8;
    hence thesis by NAT_1:11;
    end;
A6: now assume A7: a = 0;
  A8: t = 1
    proof
        now per cases;
    case t = 0;
       hence thesis by A4,A7;
    end;
    case A9: t <> 0;
           t < 2
          proof
          assume t >= 2;
          then A10: n * t >= n * 2 by XREAL_1:66;
              n * t + c >= n * t by NAT_1:11;
          then A11: n - a >= n * 2 by A4,A10,XXREAL_0:2;
              n <= n * 1 + n * 1 by NAT_1:11;
          then n * 1 = 2 * n by A7,A11,XXREAL_0:1;
          hence thesis by A1;
          end;
       then t < 1 + 1;
       then A12: t <= 1 by NAT_1:13;
           0 <= t;
       then 1 + 0 <= t by A9,INT_1:20;
       hence thesis by A12,XXREAL_0:1;
    end;
    end;
    hence thesis;
    end;
      c = 0
    proof
    assume A13: c <> 0;
        0 <= c;
    then n + c > n + 0 by A13,XREAL_1:8;
    hence thesis by A4,A5,A8;
    end;
  hence (compint(n)).(a) = 0 by A3,Def12;
end;
A14: (compint(n)).(a) = 0 implies a = 0
    proof
    assume A15: (compint(n)).(a) = 0;
    assume A16: a <> 0;
    A17: n - a < n
         proof
             n <= n + a by NAT_1:11;
         then A18: n - a <= (n + a) - a by XREAL_1:11;
             n - a <> n by A16;
         hence thesis by A18,REAL_1:def 5;
         end;
        a - a < n - a by A2,XREAL_1:11;
    then reconsider a' = n - a as Element of NAT by INT_1:16;
    consider t being Nat such that
    A19: (a' = n * t + (a' mod n) & a' mod n < n) by NAT_D:def 2;
        t = 0
         proof
         assume A20: t <> 0;
          A21: t >= 0;
             1 <= t
            proof
                1 + 0 <= t by A20,A21,INT_1:20;
            hence thesis;
            end;
         then A22: 1 * n <= t * n by XREAL_1:66;
             t * n <= t * n + (a' mod n) by NAT_1:11;
         hence thesis by A17,A19,A22,XXREAL_0:2;
         end;
    then a' = 0 by A15,A19,Def12;
    hence thesis by CARD_1:98;
    end;
    now assume A23: a <> 0;
  A24: n - a < n
      proof
      assume n - a >= n;
      then n - a = n by A5,XXREAL_0:1;
      hence thesis by A23;
      end;
      t = 0
    proof
    assume A25: t <> 0;
        0 <= t;
    then 1 + 0 <= t by A25,INT_1:20;
    then A26: 1 * n <= t * n by XREAL_1:66;
        n * t <= n * t + c by NAT_1:11;
    hence thesis by A4,A24,A26,XXREAL_0:2;
    end;
  hence (compint(n)).(a) = n - a by A3,A4,Def12;
end;
hence thesis by A6,A14;
end;

definition let n be natural number;
func INT.Ring(n) -> doubleLoopStr equals
  doubleLoopStr(#Segm(n),addint(n),multint(n),In (1,Segm(n)),In (0,Segm(n))#);
coherence;
end;

registration let n be non zero natural number;
 cluster INT.Ring(n) -> strict non empty;
coherence
  proof
   thus INT.Ring n is strict &
         the carrier of INT.Ring n is non empty;
  end;
end;

theorem Th20:
INT.Ring 1 is degenerated & INT.Ring 1 is Ring &
INT.Ring 1 is Field-like unital distributive commutative
proof
set n = 1,
    R = INT.Ring n;
A1: for x being Element of R st x <> 0.R
    ex y be Element of R st x*y = 1.R
    proof
    let x be Element of R;
    assume x <> 0.R;
    then x <> 0 by FUNCT_7:def 1;
    hence thesis by GR_CY_1:13,TARSKI:def 1;
    end;
A2: 0.R = 0 by GR_CY_1:13,TARSKI:def 1 .= 1.R by GR_CY_1:13,TARSKI:def 1;
A3: for a,b being Element of R holds a + b = b + a
    proof
    let a,b be Element of R;
    thus a + b = 0 by GR_CY_1:13,TARSKI:def 1 .= b + a by GR_CY_1:13
,TARSKI:def 1;
    end;
A4: for a,b being Element of R holds a * b = b * a
    proof
    let a,b be Element of R;
    thus a * b = 0 by GR_CY_1:13,TARSKI:def 1 .= b * a by GR_CY_1:13
,TARSKI:def 1;
    end;
A5: for a,b,c being Element of R holds
    (a + b) + c = a + (b + c)
    proof
    let a,b,c be Element of R;
    thus (a + b) + c = 0 by GR_CY_1:13,TARSKI:def 1 .= a + (b + c) by
GR_CY_1:13,TARSKI:def 1;
    end;
A6: for a,b,c being Element of R holds
    (a * b) * c = a * (b * c)
    proof
    let a,b,c be Element of R;
    thus (a * b) * c = 0 by GR_CY_1:13,TARSKI:def 1 .= a * (b * c) by
GR_CY_1:13,TARSKI:def 1;
     end;
A7: for a being Element of R holds
    a + 0.R = a
    proof
    let a be Element of R;
        a = 0 by GR_CY_1:13,TARSKI:def 1;
    hence thesis by GR_CY_1:13,TARSKI:def 1;
    end;
A8: for a being Element of R holds
    a + (-a) = 0.R
    proof
    let a be Element of R;
    thus a + (-a) = 0 by GR_CY_1:13,TARSKI:def 1 .= 0.R by GR_CY_1:13
,TARSKI:def 1;
    end;
A9: for a being Element of R holds
    1.R * a = a & a * 1.R = a
    proof
    let a be Element of R;
    A10: 1.R * a = 0 by GR_CY_1:13,TARSKI:def 1 .= a by GR_CY_1:13,TARSKI:def 1
;
        a * 1.R = 0 by GR_CY_1:13,TARSKI:def 1 .= a by GR_CY_1:13,TARSKI:def 1;
    hence thesis by A10;
    end;
A11: for a,b,c being Element of R holds
    (b + c) * a = b * a + c * a
    proof
    let a,b,c be Element of R;
    thus (b + c) * a = 0 by GR_CY_1:13,TARSKI:def 1 .= b * a + c * a by
GR_CY_1:13,TARSKI:def 1;
    end;
A12: for a,b,c being Element of R holds
    a * (b + c) = a * b + a * c
    proof
    let a,b,c be Element of R;
    thus a * (b + c) = 0 by GR_CY_1:13,TARSKI:def 1 .= a * b + a * c by
GR_CY_1:13,TARSKI:def 1;
    end;
A13: R is right_complementable
     proof
       let v be Element of R;
       take -v;
       thus v + -v = 0.R by A8;
     end;
      R is well-unital
     proof
      let x be Element of R;
      thus x*(1.R) = x by A9;
      thus (1.R)*x = x by A9;
     end;
hence thesis by A1,A2,A3,A4,A5,A6,A7,A9,A11,A12,A13,GROUP_1:def 2,def 4,def 16
,RLVECT_1:def 5,def 6,def 7,STRUCT_0:def 8,VECTSP_1:def 18,def 20;
end;

registration
 cluster strict degenerated unital distributive Field-like commutative Ring;
existence by Th20;
end;

Lm11:
now
  let a, n be natural number;
  assume
   n > 0;
  assume a in Segm n;
  then a < n by CARD_1:98;
then A1: n-a is Element of NAT by INT_1:18;
  assume a > 0;
  then n-a < n-0 by REAL_1:92;
  hence n-a in Segm n by A1,CARD_1:98;
end;

Lm12:
for n being natural number st 1 < n holds 1.INT.Ring(n) = 1
proof
  let n be natural number;
  set M = INT.Ring(n);
  assume 1 < n;
   then  1 in Segm n by CARD_1:98;
  hence 1.INT.Ring(n) = 1 by FUNCT_7:def 1;
end;

theorem Th21:
for n being natural number st n > 1 holds
 INT.Ring(n) is non degenerated &
 INT.Ring(n) is well-unital distributive commutative Ring
 proof
 let n be natural number;
 assume A1: n > 1;
 then reconsider n as non zero natural number;
 set F = INT.Ring(n);
  0 in Segm(n) by CARD_1:98;
 then A2: 0.F = 0 by FUNCT_7:def 1;
 A3: 1.F = 1 by A1,Lm12;
 A4: for a,b being Element of F holds a + b = b + a
     proof
     let a,b be Element of F;
     reconsider a' = a as Element of Segm(n);
     reconsider b' = b as Element of Segm(n);
         now per cases;
     case A5: a' + b' < n;
       hence (addint(n)).(a,b) = a' + b' by Th17
                             .= (addint(n)).(b,a) by A5,Th17;
     end;
     case A6: a' + b' >= n;
       hence (addint(n)).(a,b) = (a' + b') - n by Th17
                             .= (addint(n)).(b,a) by A6,Th17;
     end;
     end;
     hence thesis;
     end;
 A7: for a,b being Element of F holds a * b = b * a
     proof
     let a,b be Element of F;
     reconsider a' = a as Element of Segm(n);
     reconsider b' = b as Element of Segm(n);
     consider k being Element of NAT such that
     A8: k * n <= a' * b' & a' * b' < (k + 1) * n by Lm10;
         (multint(n)).(a',b') = a' * b' - k * n by A8,Th18
                              .= (multint(n)).(b',a') by A8,Th18;
     hence a * b = b * a;
     end;
 A9: for a,b,c being Element of F holds
     (a + b) + c = a + (b + c)
     proof
     let a,b,c be Element of F;
     reconsider a' = a, b' = b, c' = c as Element of Segm(n);
     reconsider aa = a' as Element of NAT; reconsider aa as Integer;
     reconsider bb = b' as Element of NAT; reconsider bb as Integer;
     reconsider cc = c' as Element of NAT; reconsider cc as Integer;
     A10: aa >= 0 & aa < n & bb >= 0 & bb < n & cc >= 0 & cc < n
 by CARD_1:98;
         (aa + bb) mod n >= 0 & (aa + bb) mod n < n by Th9;
     then A11: (a' + b') mod n is Element of Segm(n) by CARD_1:98;
         (bb + cc) mod n >= 0 & (bb + cc) mod n < n by Th9;
     then A12: (b' + c') mod n is Element of Segm(n) by CARD_1:98;
     A13: (a + b) + c
         = (addint(n)).((a' + b') mod n, c') by GR_CY_1:def 5
        .= (((a' + b') mod n) + c') mod n by A11,GR_CY_1:def 5;
     A14: a + (b + c)
         = (addint(n)).(a', (b' + c') mod n) by GR_CY_1:def 5
        .= (a' + ((b' + c') mod n)) mod n by A12,GR_CY_1:def 5;
            (a' + ((b' + c') mod n)) mod n
      = ((aa mod n) + (bb + cc mod n)) mod n by A10,Th10
     .= (aa + (bb + cc)) mod n by Th14
     .= ((aa + bb) + cc) mod n
     .= (((aa + bb) mod n) + (cc mod n)) mod n by Th14
     .= (((a' + b') mod n) + c') mod n by A10,Th10;
     hence thesis by A13,A14;
     end;
 A15: for a,b,c being Element of F holds
     (a * b) * c = a * (b * c)
     proof
     let a,b,c be Element of F;
     reconsider a' = a, b' = b, c' = c as Element of Segm(n);
     reconsider aa = a' as Element of NAT; reconsider aa as Integer;
     reconsider bb = b' as Element of NAT; reconsider bb as Integer;
     reconsider cc = c' as Element of NAT; reconsider cc as Integer;
     A16: aa >= 0 & aa < n & bb >= 0 & bb < n & cc >= 0 & cc < n
 by CARD_1:98;
         (aa * bb) mod n >= 0 & (aa * bb) mod n < n by Th9;
     then A17: (a' * b') mod n is Element of Segm(n) by CARD_1:98;
         (bb * cc) mod n >= 0 & (bb * cc) mod n < n by Th9;
     then A18: (b' * c') mod n is Element of Segm(n) by CARD_1:98;
     A19: (a * b) * c
         = (multint(n)).((a' * b') mod n, c') by Def11
        .= (((a' * b') mod n) * c') mod n by A17,Def11;
     A20: a * (b * c)
         = (multint(n)).(a', (b' * c') mod n) by Def11
        .= (a' * ((b' * c') mod n)) mod n by A18,Def11;
            (a' * ((b' * c') mod n)) mod n
      = ((aa mod n) * (bb * cc mod n)) mod n by A16,Th10
     .= (aa * (bb * cc)) mod n by Th15
     .= ((aa * bb) * cc) mod n
     .= (((aa * bb) mod n) * (cc mod n)) mod n by Th15
     .= (((a' * b') mod n) * c') mod n by A16,Th10;
     hence thesis by A19,A20;
     end;
 A21: for a being Element of F holds a + 0.F = a
     proof
     let a be Element of F;
     reconsider a' = a as Element of Segm(n);
         a' + 0 < n by CARD_1:98;
     hence thesis by A2,Th17;
     end;
 A22: for a being Element of F holds
     1.F * a = a & a * 1.F = a
     proof
     let a be Element of F;
     reconsider a' = a as Element of Segm(n);
     A23: (0 * n <= 1 * a' & 1 * a' < (0 + 1) * n) by CARD_1:98;
     A24: 1 is Element of Segm(n) by A1,CARD_1:98;
     then A25: (multint(n)).(1,a) = a' - 0 * n by A23,Th18
                                 .= a';
         (multint(n)).(a,1) = a' - 0 * n by A23,A24,Th18
                            .= a';
     hence thesis by A1,A25,Lm12;
     end;
 A26: for a,b,c being Element of F holds
     (b + c) * a = b * a + c * a
     proof
     let a,b,c be Element of F;
     reconsider a' = a, b' = b, c' = c as Element of Segm(n);
     reconsider aa = a' as Element of NAT; reconsider aa as Integer;
     reconsider bb = b' as Element of NAT; reconsider bb as Integer;
     reconsider cc = c' as Element of NAT; reconsider cc as Integer;
     A27: aa >= 0 & aa < n & bb >= 0 & bb < n & cc >= 0 & cc < n
 by CARD_1:98;
         (bb + cc) mod n >= 0 & (bb + cc) mod n < n by Th9;
     then A28: (b' + c') mod n is Element of Segm(n) by CARD_1:98;
         (bb * aa) mod n >= 0 & (bb * aa) mod n < n by Th9;
     then A29: (b' * a') mod n is Element of Segm(n) by CARD_1:98;
         (cc * aa) mod n >= 0 & (cc * aa) mod n < n by Th9;
     then A30: (c' * a') mod n is Element of Segm(n) by CARD_1:98;
     A31: (b + c) * a
         = (multint(n)).((b' + c') mod n, a') by GR_CY_1:def 5
        .= (((b' + c') mod n) * a') mod n by A28,Def11;
     A32: b * a + c * a
         = (addint(n)).((multint(n)).(b,a),(c' * a') mod n) by Def11
        .= (addint(n)).((b' * a') mod n,(c' * a') mod n) by Def11
        .= (((b' * a') mod n) + ((c' * a') mod n)) mod n
 by A29,A30,GR_CY_1:def 5;
            (((b' * a') mod n) + ((c' * a') mod n)) mod n
      = (bb * aa + cc * aa) mod n by Th14
     .= ((bb + cc) * aa) mod n
     .= (((bb + cc) mod n) * (aa mod n)) mod n by Th15
     .= (((b' + c') mod n) * a') mod n by A27,Th10;
     hence thesis by A31,A32;
     end;
 A33: for a,b,c being Element of F holds
     a * (b + c) = a * b + a * c
     proof
     let a,b,c be Element of F;
     thus a * (b + c) = (b + c) * a by A7
                     .= b * a + c * a by A26
                     .= a * b + c * a by A7
                     .= a * b + a * c by A7;
     end;
 A34: F is right_complementable
      proof
        let a be Element of F;
        reconsider a' = a as Element of Segm(n);
        reconsider a' as Element of NAT;
        per cases;
        suppose A35: a' = 0;
        take 0.F;
        thus a + 0.F = 0.F by A2,A21,A35;
        end;
        suppose a' <> 0;
        then a' > 0;
        then reconsider b = n-a' as Element of Segm n by Lm11;
        reconsider v = b as Element of F;
        take v;
        thus a + v
           = (a'+b) mod n by GR_CY_1:def 5
          .= 0.F by A2,NAT_D:25;
      end;
      end;
       F is well-unital
      proof
       let x be Element of F;
       thus x*(1.F) = x by A22;
       thus (1.F)*x = x by A22;
      end;
 then reconsider F as commutative Ring by A4,A7,A9,A15,A21,A26,A33,A34,
GROUP_1:def 4,def 16,RLVECT_1:def 5,def 6,def 7,VECTSP_1:def 18;
     F is non degenerated by A2,A3,STRUCT_0:def 8;
 hence thesis;
end;

Lm13: for p being natural number st p > 0 holds 0.(INT.Ring(p)) = 0
proof
let p be natural number; assume p > 0;
then 0 in Segm(p) by GR_CY_1:12;
hence 0.(INT.Ring(p)) = 0 by FUNCT_7:def 1;
end;

theorem
Th22:for p being natural number st p > 1 holds
 INT.Ring(p) is add-associative right_zeroed right_complementable
    Abelian commutative associative well-unital distributive
      Field-like non degenerated (non empty doubleLoopStr)
  iff p is Prime
proof
let p be natural number; assume A1: p > 1;
 then reconsider p as non zero natural number;
reconsider P = INT.Ring(p) as Ring by A1,Th21;
    reconsider p as non zero Element of NAT by ORDINAL1:def 13;
A2: now assume A3: p is Prime;
       for a being Element of P st a <> 0.P
   ex b be Element of P st a * b = 1.P
    proof
    let a be Element of P; assume A4: a <> 0.P;
    reconsider a' = a as Element of Segm(p);
    reconsider a' as Element of NAT;
    A5: abs(a') = a & abs(p) = p by ABSVALUE:def 1;
        1 * a' = a' & 1 * p = p;
    then A6: 1 divides a' & 1 divides p by NAT_D:def 3;
     for m being Nat st
    m divides a' & m divides p holds m divides 1
      proof
      let m be Nat; assume A7: m divides a' & m divides p;
      then consider k being Nat such that
      A8: a' = m * k by NAT_D:def 3;
          m <= a'
        proof
        assume A9: m > a';
            now per cases;
        case k = 0; hence thesis by A4,A8,Lm13;
        end;
        case A10: k <> 0;
           A11: k >= 0;
          then k >= 1 + 0 by A10,INT_1:20;
          then k * a' >= 1 * a' by XREAL_1:66;
          hence thesis by A8,A9,A10,A11,XREAL_1:70;
        end;
        end;
        hence thesis;
        end;
      then m <> p by CARD_1:98;
      hence thesis by A3,A7,INT_2:def 5;
      end;
    then a' hcf p = 1 by A6,NAT_D:def 5;
    then a' gcd p = 1 by A5,INT_2:def 3;
    then consider s,t being Integer such that
    A12: 1 = s * a' + t * p by Th16;
    A13: s mod p >= 0 & s mod p < p by Th9;
    then s mod p is Element of NAT by INT_1:16;
    then reconsider b' = s mod p as Element of Segm(p) by A13,CARD_1:98;
    reconsider b = b' as Element of P;
    reconsider b2 = b' as Integer; reconsider a2 = a' as Integer;
    reconsider e = 1 as Integer;
        a * b = (a' * b') mod p by Def11
         .= ((a2 mod p) * ((s mod p) mod p)) mod p by Th15
         .= ((a2 mod p) * (s mod p)) mod p by Th13
         .= (a2 * s) mod p by Th15
         .= e mod p by A12,Th8
         .= e by A1,Th10
         .= 1.P by A1,Lm12;
    hence thesis;
    end;
   hence INT.Ring(p) is add-associative right_zeroed right_complementable
    Abelian commutative associative well-unital distributive
      Field-like non degenerated (non empty doubleLoopStr) by A1,Th21,
VECTSP_1:def 20;
   end;
    now assume A14: INT.Ring(p) is add-associative right_zeroed
right_complementable
    Abelian commutative associative well-unital distributive
      Field-like non degenerated (non empty doubleLoopStr);
       for n being natural number holds n divides p implies n = 1 or n = p
     proof
       let n be natural number; assume n divides p;
       then consider k being Nat such that
       A15: p = n * k by NAT_D:def 3;
     A16: k <= p
         proof
         assume A17: k > p;
             now per cases;
         case n = 0; hence thesis by A15;
         end;
         case A18: n <> 0;
            A19: n >= 0;
           then n >= 1 + 0 by A18,INT_1:20;
           then n * p >= 1 * p by XREAL_1:66;
           hence thesis by A15,A17,A18,A19,XREAL_1:70;
         end;
         end;
         hence thesis;
         end;
     A20: n <= p
         proof
         assume A21: n > p;
             now per cases;
         case k = 0; hence thesis by A15;
         end;
         case A22: k <> 0;
            A23: k >= 0;
           then k >= 1 + 0 by A22,INT_1:20;
           then k * p >= 1 * p by XREAL_1:66;
           hence thesis by A15,A21,A22,A23,XREAL_1:70;
         end;
         end;
         hence thesis;
         end;
         now per cases;
     case k = p;
       then 1 * p = p * n by A15;
       hence thesis by XCMPLX_1:5;
     end;
     case k <> p;
       then A24: k < p by A16,REAL_1:def 5;
           now per cases;
       case n = p;
         then 1 * p = k * p by A15;
         then k = 1 by XCMPLX_1:5;
         hence thesis by A15;
       end;
       case n <> p;
         then n < p by A20,REAL_1:def 5;
         then reconsider n2 = n as Element of Segm(p) by CARD_1:98;
         reconsider n' = n2 as Element of INT.Ring(p);
         reconsider k2 = k as Element of Segm(p) by A24,CARD_1:98;
         reconsider k' = k2 as Element of INT.Ring(p);
             n <> 0 & k <> 0 by A15;
         then A25: n <> 0.(INT.Ring(p)) & k <> 0.(INT.Ring(p)) by Lm13;
             n' * k' = (n2 * k2) mod p by Def11
                .= 0 by A15,INT_1:89
                .= 0.(INT.Ring(p)) by Lm13;
         hence contradiction by A14,A25,VECTSP_1:44;
       end;
       end;
       hence thesis;
     end;
     end;
     hence thesis;
     end;
   hence p is Prime by A1,INT_2:def 5;
   end;
hence thesis by A2;
end;

registration
 cluster -> non zero Prime;
 coherence
  proof let k be Prime;
   assume k is zero;
    then k in SetPrimenumber 2 by NEWTON:def 7;
   hence contradiction;
  end;
end;

registration
let p be Prime;
 cluster INT.Ring(p) -> add-associative right_zeroed right_complementable
   Abelian commutative associative well-unital distributive Field-like
    non degenerated;
coherence
 proof
     p > 1 by INT_2:def 5; hence thesis by Th22;
 end;
end;

theorem
   1.INT.Ring = 1 by Lm5;

theorem
   for n being natural number st 1 < n holds 1.INT.Ring(n) = 1 by Lm12;

