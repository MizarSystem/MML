:: The { \bf for } (going up) Macro Instruction
::  by Piotr Rudnicki
::
:: Received June 4, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies FUNCT_2, FUNCT_4, FUNCT_1, RELAT_1, BOOLE, FINSET_1, SQUARE_1,
      INT_1, FINSEQ_1, GRAPH_2, FINSEQ_4, ARYTM_1, RFUNCT_2, AMI_1, SCMFSA_2,
      SF_MASTR, SCMFSA6A, SCMFSA7B, AMI_3, UNIALG_2, SCMFSA6C, SCMFSA6B,
      SCMFSA_4, CAT_1, AMI_5, ABSVALUE, SCMFSA8B, SCMFSA_9, CARD_1, SCMFSA8A,
      SFMASTR1, CARD_3, SCMFSA9A, SCM_1, FINSEQ_2, SFMASTR3, SGRAPH1, ARYTM,
      ORDINAL2, MEMBERED;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0, XREAL_0,
      REAL_1, CARD_3, MEMBERED, INT_1, NAT_1, INT_2, RELAT_1,
      RELSET_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_7, GRAPH_2, CARD_1, FINSET_1,
      FINSUB_1, SETWISEO, FINSEQ_1, FINSEQ_2, FINSEQ_4, PRE_CIRC, AMI_1, AMI_3,
      SCM_1, AMI_5, SCMFSA_2, SCMFSA_4, SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C,
      SCMFSA7B, SCMFSA8A, SCMFSA8B, SCMFSA_9, SFMASTR1, SCMFSA9A, XXREAL_0;
 constructors RELAT_2, PARTFUN1, SETWISEO, XXREAL_0, REAL_1, NAT_1, RAT_1,
      SEQ_4, FINSEQ_4, INT_2, GRAPH_2, SCM_1, AMI_5, SCMFSA6A, SCMFSA6B,
      SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA_9, SFMASTR1, SCMFSA9A;
 registrations FINSET_1, RELSET_1, FUNCT_1, INT_1, AMI_1, SCMFSA_2, SCMFSA_4,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B, SCMFSA_9,
      SFMASTR1, FINSEQ_1, WSIERP_1, FUNCT_2, FRAENKEL, XREAL_0, ARYTM_3,
      MEMBERED, PRE_CIRC, PARTFUN1, ORDINAL1, SETFAM_1, XXREAL_0, CARD_3;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, FUNCT_2, SCMFSA7B, SCMFSA9A, SEQ_4;
 theorems TARSKI, ZFMISC_1, ENUMSET1, REAL_1, ABSVALUE, NAT_1, INT_1, RELAT_1,
      FUNCT_1, FUNCT_2, FUNCT_7, CQC_LANG, FINSEQ_1, FINSEQ_2, FINSEQ_3,
      FINSEQ_4, GRAPH_2, AMI_1, SCMFSA_2, SCMFSA_4, SCMFSA6A, SCMFSA6B,
      SF_MASTR, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B, SCMFSA8C, SCMFSA_9,
      SFMASTR1, SCMFSA9A, SFMASTR2, RELSET_1, XBOOLE_0, XBOOLE_1, PARTFUN1,
      MEMBERED, XREAL_1, XXREAL_0, PRE_CIRC;
 schemes FUNCT_2, NAT_1;

begin :: General preliminaries

theorem Th1:
 for X being set, p being Permutation of X, x, y being Element of X
  holds p+*(x, p.y)+*(y, p.x) is Permutation of X
proof let X be set, p be Permutation of X, x, y be Element of X;
 set p1 = p+*(x, p.y); set p2 = p1+*(y, p.x);
A1: dom p2 = dom p1 by FUNCT_7:32;
A2: dom p1 = dom p by FUNCT_7:32;
        X = {} implies X = {};
then A3: dom p = X by FUNCT_2:def 1;
 per cases;
 suppose X is empty;
  hence p+*(x, p.y)+*(y, p.x) is Permutation of X
          by A1,A2,A3,FUNCT_2:55,PARTFUN1:58;
 end;
 suppose A4: X is non empty;
 A5: rng p = X by FUNCT_2:def 3;
 then A6: p.x in X by A3,A4,FUNCT_1:def 5;
  thus p+*(x, p.y)+*(y, p.x) is Permutation of X proof
   per cases;
   suppose A7: x = y;
     then p2 = p1 by FUNCT_7:37 .= p by A7,FUNCT_7:37;
   hence p+*(x, p.y)+*(y, p.x) is Permutation of X;
   end;
   suppose A8: x <> y;
   then A9: p2.x = p1.x by FUNCT_7:34
           .= p.y by A3,A4,FUNCT_7:33;
   A10: p2.y = p.x by A2,A3,A4,FUNCT_7:33;
   A11: now let z be set such that
         z in X and
     A12: z <> x & z <> y;
      thus p2.z = p1.z by A12,FUNCT_7:34
             .= p.z by A12,FUNCT_7:34;
     end;
    A13: now let pz be set;
     hereby assume pz in rng p2; then consider z being set such that
     A14: z in dom p2 & pz = p2.z by FUNCT_1:def 5;
     A15: p.z in X by A1,A2,A5,A14,FUNCT_1:def 5;
       per cases;
       suppose z = x; hence pz in X by A3,A4,A5,A9,A14,FUNCT_1:def 5;
       end;
       suppose z = y; hence pz in X by A2,A3,A6,A14,FUNCT_7:33;
       end;
       suppose z <> x & z <> y; hence pz in X by A1,A2,A11,A14,A15;
     end;
     end;
     assume pz in X; then consider z being set such that
     A16: z in dom p & pz = p.z by A5,FUNCT_1:def 5;
     per cases;
      suppose z = x;hence pz in rng p2 by A1,A2,A3,A10,A16,FUNCT_1:def 5;
      end;
      suppose z = y;hence pz in rng p2 by A1,A2,A3,A9,A16,FUNCT_1:def 5;
      end;
      suppose z <> x & z <> y; then p2.z = p.z by A11,A16;
       hence pz in rng p2 by A1,A2,A16,FUNCT_1:def 5;
    end;
    end;
   then rng p2 = X by TARSKI:2;
      then reconsider p2 as Function of X, X
        by A1,A2,A3,A4,FUNCT_2:def 1,RELSET_1:11;
         p2 is bijective
      proof
           now let z1, z2 be set such that
        A17: z1 in X and
        A18: z2 in X and
        A19: p2.z1 = p2.z2 and
        A20: z1 <> z2;
         per cases;
         suppose z1 = x & z2 = y;
          hence contradiction by A4,A8,A9,A10,A19,FUNCT_2:25;
         end;
         suppose z1 = y & z2 = x;
          hence contradiction by A4,A8,A9,A10,A19,FUNCT_2:25;
         end;
         suppose A21: z1 = x & z2 <> y;
         then p2.z2 = p.z2 by A11,A18,A20;
          hence contradiction by A9,A18,A19,A21,FUNCT_2:25;
         end;
         suppose A22: z1 <> x & z2 = y;
           then p2.z1 = p.z1 by A11,A17,A20;
          hence contradiction by A10,A17,A19,A22,FUNCT_2:25;
         end;
         suppose A23: z1 = y & z2 <> x;
           then p2.z2 = p.z2 by A11,A18,A20;
          hence contradiction by A10,A18,A19,A23,FUNCT_2:25;
         end;
         suppose A24: z1 <> y & z2 = x;
           then p2.z1 = p.z1 by A11,A17,A20;
          hence contradiction by A9,A17,A19,A24,FUNCT_2:25;
         end;
         suppose A25: z1 <> y & z2 <> x & z1 <> x & z2 <> y;
           then A26: p2.z1 = p.z1 by A11,A17;
                  p2.z2 = p.z2 by A11,A18,A25;
          hence contradiction by A17,A18,A19,A20,A26,FUNCT_2:25;
        end;
        end;
       hence p2 is one-to-one by A4,FUNCT_2:25;
       thus rng p2 = X by A13,TARSKI:2;
      end;
   hence p+*(x, p.y)+*(y, p.x) is Permutation of X;
  end;
  end;
end;
end;

theorem Th2:
 for f being Function, x, y being set
  st x in dom f & y in dom f
   ex p being Permutation of dom f st f+*(x, f.y)+*(y, f.x) =f*p
proof let f be Function, x, y be set such that
A1: x in dom f & y in dom f;
   set i = id dom f;
      i.x = x & i.y = y by A1,FUNCT_1:35;
   then reconsider p = i+*(x, y)+*(y, x) as Permutation of dom f by A1,Th1;
 take p;
 set fk = f+*(x, f.y); set fl = fk+*(y, f.x); set fr = f*p;
 set pk = i+*(x, y);
A2: dom f = dom fk by FUNCT_7:32;
A3: dom fk = dom fl by FUNCT_7:32;
A4: dom p = dom pk by FUNCT_7:32;
A5: dom pk = dom i by FUNCT_7:32;
A6: dom i = dom f by FUNCT_1:34;
     now
   thus dom f = dom fl by A3,FUNCT_7:32;
           rng p = dom f by FUNCT_2:def 3;
   hence dom f = dom fr by A4,A5,A6,RELAT_1:46;
   let z be set such that
  A7: z in dom f;
   per cases;
   suppose A8: x <> y;
    thus fl.z = fr.z proof
     per cases;
     suppose A9: z = x;
      hence fl.z
         = fk.z by A8,FUNCT_7:34
        .= f.y by A7,A9,FUNCT_7:33
        .= f.(pk.x) by A1,A6,FUNCT_7:33
        .= f.(p.x) by A8,FUNCT_7:34
        .= fr.z by A4,A5,A6,A7,A9,FUNCT_1:23;
     end;
     suppose A10: z = y;
      hence fl.z
         = f.x by A2,A7,FUNCT_7:33
        .= f.(p.y) by A1,A5,A6,FUNCT_7:33
        .= fr.z by A4,A5,A6,A7,A10,FUNCT_1:23;
     end;
     suppose A11: z <> x & z <> y;
     then A12: p.z = pk.z by FUNCT_7:34
            .= i.z by A11,FUNCT_7:34
            .= z by A7,FUNCT_1:35;
      thus fl.z = fk.z by A11,FUNCT_7:34
               .= f.(p.z) by A11,A12,FUNCT_7:34
               .= fr.z by A4,A5,A6,A7,FUNCT_1:23;
    end;
    end;
   end;
   suppose A13: x = y;
then A14:  fk = f by FUNCT_7:37;
   A15: x = i.x by A1,FUNCT_1:34;
         i = i+*(x, i.y) by A13,FUNCT_7:37;
    hence fl.z = fr.z by A13,A14,A15,RELAT_1:78;
  end;
  end;
 hence f+*(x, f.y)+*(y, f.x) = f*p by FUNCT_1:9;
end;

 :: NOTE: The following to be done well needs Real-yielding functions, etc.
 :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

reserve n,k for natural number;

registration
  let X be finite non empty natural-membered set;
  cluster min X -> integer;
  coherence
    proof min X in X by PRE_CIRC:def 4;
      hence min X is integer by MEMBERED:def 4;
    end;
end;

definition
 canceled;
 let F be FinSequence of INT, m, n be Nat;
 assume
A1: 1 <= m & m <= n & n <= len F;
 canceled;

 func min_at(F, m, n) -> Nat means
:Def3:
  ex X being finite non empty Subset of INT
   st X = rng ((m,n)-cut F) & it+1 = (min X)..(m,n)-cut F +m;
 existence proof
  set Cut = (m,n)-cut F;
  set X = rng Cut;
A2: rng (Cut qua Relation of NAT, INT) is Subset of INT;
A3: m < n+1 by A1,NAT_1:38;
   len Cut +m = n+1 by A1,GRAPH_2:def 1;
then A4: len Cut = n+1-m;
      m-m < n+1-m by A3,XREAL_1:11;
  then Cut is non empty by A4,FINSEQ_1:25;
  then reconsider X as finite non empty Subset of INT by A2,RELAT_1:64;
  set q = (min X)..Cut +m -1;
     1-1 <= m-1 by A1,XREAL_1:11;
  then 0 <= (min X)..Cut & 0 <= m-1;
  then 0+0 <= (min X)..Cut + (m-1) by XREAL_1:9;
  then reconsider q as Nat by INT_1:16;
  take q, X;
  thus X = rng Cut;
  thus q+1 = (min X)..Cut +m;
 end;
 uniqueness;
end;

reserve F, F1 for FinSequence of INT,
        k, m, n, ma for Nat;

theorem Th3:
 1 <= m & m <= n & n <= len F implies
  (ma = min_at(F, m, n) iff
    m <= ma & ma <= n &
    (for i being Nat st m <= i & i <= n holds F.ma <= F.i) &
    for i being Nat st m <= i & i < ma holds F.ma < F.i)
proof assume that
A1: 1 <= m & m <= n & n <= len F;
   set Cut = (m,n)-cut F;
A2: len Cut +m = n+1 by A1,GRAPH_2:def 1;
 hereby assume ma = min_at(F, m, n);
   then consider X being finite non empty Subset of INT such that
 A3: X = rng Cut and
 A4: ma+1 = (min X)..Cut +m by A1,Def3;
 A5: ma = (min X)..Cut +m-1 by A4;
 A6: min X in X by PRE_CIRC:def 4;
 then A7: 1 <= (min X)..Cut & (min X)..Cut <= len Cut by A3,FINSEQ_4:31;
    then m+1 <= (min X)..Cut +m by XREAL_1:8;
 then A8: m+1-1 <= ma by A5,XREAL_1:11;
       (min X)..Cut+m <= len Cut +m by A7,XREAL_1:8;
 then A9: ma <= len Cut +m-1 by A5,XREAL_1:11;
  hence
 m <= ma & ma <= n by A2,A8;
       1-1 <= (min X)..Cut-1 by A7,XREAL_1:11;
    then reconsider i1 = (min X)..Cut-1 as Nat by INT_1:16;
 A10: ma = (min X)..Cut-1 +m by A5;
 A11: ma+1-m = (min X)..Cut by A4;
        i1 < (min X)..Cut by XREAL_1:148;
 then i1 < len Cut by A7,XXREAL_0:2;
 then A12: F.ma = Cut.(i1+1) by A1,A10,GRAPH_2:def 1
       .= Cut.(ma+1-m) by A4;
 A13: Cut.((min X)..Cut) = min X by A3,A6,FINSEQ_4:29;
 A14: len Cut = n+1-m by A2
       .= n-m+1;
  thus
A15: for i being Nat st m <= i & i <= n holds F.ma <= F.i proof
    let i be Nat; assume
  A16: m <= i & i <= n;
      then  m-m <= i-m by XREAL_1:11;
      then reconsider i1 = i-m as Nat by INT_1:16;
         n-m < n-m+1 & i1 <= n-m by A16,XREAL_1:11,XREAL_1:31;
  then A17: i1 < len Cut by A14,XXREAL_0:2;
  then A18: Cut.(i1+1) = F.(m+i1) by A1,GRAPH_2:def 1;
  A19: 0+1 <= i1+1 by XREAL_1:8;
      i1+1 <= len Cut by A17,NAT_1:38;
  then i1+1 in dom Cut by A19,FINSEQ_3:27;
    then F.i in rng Cut by A18,FUNCT_1:def 5;
   hence F.ma <= F.i by A3,A4,A12,A13,PRE_CIRC:def 4;
  end;
  let i be Nat; assume
 A20: m <= i & i < ma;
 then A21: i <= n by A2,A9,XXREAL_0:2;
         m-m <= i-m by A20,XREAL_1:11;
    then reconsider i1 = i-m as Nat by INT_1:16;
    reconsider k = i1+1 as Nat;
        i-m < ma-m by A20,XREAL_1:11;
     then k < ma-m+1 by XREAL_1:8;
 then A22: k < (min X)..Cut by A11;
A23: 0+1 <= k by XREAL_1:8;
       i <= len Cut -1 +m by A9,A20,XXREAL_0:2;
      then i-m <= len Cut -1 by XREAL_1:22;
      then k <= len Cut by XREAL_1:21;
      then k in dom Cut by A23,FINSEQ_3:27;
 then A24: Cut.k <> min X by A22,FINSEQ_4:34;
        n-m < n-m+1 & i1 <= n-m by A21,XREAL_1:11,XREAL_1:31;
 then A25: i1 < len Cut by A14,XXREAL_0:2;
         F.i = F.(i1+m)
         .= Cut.k by A1,A25,GRAPH_2:def 1;
   then A26: F.i <> F.ma by A3,A4,A6,A12,A24,FINSEQ_4:29;
      F.ma <= F.i by A15,A20,A21;
  hence F.ma < F.i by A26,REAL_1:def 5;
 end;
 assume that
A27: m <= ma & ma <= n and
A28: for i being Nat st m <= i & i <= n holds F.ma <= F.i and
A29: for i being Nat st m <= i & i < ma holds F.ma < F.i;
  set Cut = (m,n)-cut F;
  set X = rng Cut;
A30: rng (Cut qua Relation of NAT, INT) is Subset of INT;
A31: m < n+1 by A1,NAT_1:38;
   len Cut +m = n+1 by A1,GRAPH_2:def 1;
then A32: len Cut = n+1-m;
       m-m < n+1-m by A31,XREAL_1:11;
   then Cut is non empty by A32,FINSEQ_1:25;
   then reconsider X as finite non empty Subset of INT by A30,RELAT_1:64;
  set mX = min X;
   reconsider rX = X as finite non empty Subset of REAL by MEMBERED:2;
A33: mX in X by PRE_CIRC:def 4;
then A34: Cut.(mX..Cut) = mX by FINSEQ_4:29;
      m-m <= ma-m by A27,XREAL_1:11;
   then reconsider qm = ma-m as Nat by INT_1:16;
A35: qm+1 = ma+1-m;
   then reconsider q1 = ma+1-m as Nat;
   set mXC = mX..Cut;
A36: 0+1 <= qm+1 by XREAL_1:8;
       ma+1 <= n+1 by A27,XREAL_1:8;
then A37: q1 <= len Cut by A32,XREAL_1:11;
then A38: q1 in dom Cut by A36,FINSEQ_3:27;
A39: qm < len Cut by A35,A37,NAT_1:38;
      ma = qm+m;
then A40: F.ma = Cut.(ma+1-m) by A1,A35,A39,GRAPH_2:def 1;
     now
   thus F.ma in X by A38,A40,FUNCT_1:def 5;
   let k be real number; assume k in X; then consider dk being set such that
  A41: dk in dom Cut & Cut.dk = k by FUNCT_1:def 5;
     reconsider dk as Nat by A41;
  A42: 1 <= dk & dk <= len Cut by A41,FINSEQ_3:27;
      then 1-1 <= dk-1 by XREAL_1:11;
      then reconsider dk1 = dk-1 as Nat by INT_1:16;
  A43: m <= dk1+m by NAT_1:37;
        dk+m <= (len Cut)+m by A42,XREAL_1:8;
     then A44: dk+m-1 <= n by A2,XREAL_1:22;
         dk1 < dk by XREAL_1:148;
      then dk1 < len Cut by A42,XXREAL_0:2;
     then F.(dk1+m) = Cut.(dk1+1) by A1,GRAPH_2:def 1
      .= Cut.dk;
    hence F.ma <= k by A28,A41,A43,A44;
  end;
then A45: F.ma = min rX by PRE_CIRC:def 4;
      1 <= mXC by A33,FINSEQ_4:31;
   then 1-1 <= mXC -1 by XREAL_1:11;
   then reconsider mXC1 = mXC-1 as Nat by INT_1:16;
   set mXCm = mXC1+m;
A46: m <= mXCm by NAT_1:37;
A47: mXC = mXC1+1;
       mXC1 < mXC & mXC <= len Cut by A33,FINSEQ_4:31,XREAL_1:148;
    then mXC1 < len Cut by XXREAL_0:2;
then A48: F.mXCm = Cut.mXC by A1,A47,GRAPH_2:def 1;
    now assume
 A49: q1 <> mXC;
  per cases by A49,XXREAL_0:1;
  suppose q1 < mXC;
   hence contradiction by A38,A40,A45,FINSEQ_4:34;
  end;
  suppose q1 > mXC;
      then mXC+m < ma+1 by XREAL_1:22;
      then mXC+m-1 < ma by XREAL_1:21;
   hence contradiction by A29,A34,A45,A46,A48;
 end;
 end;
  then ma+1 = mX..Cut +m;
 hence ma = min_at(F, m, n) by A1,Def3;
end;

theorem Th4:
 1 <= m & m <= len F implies min_at(F, m, m) = m
proof assume that
A1: 1 <= m & m <= len F;
A2: for i being Nat st m <= i & i <= m holds F.m <= F.i by XXREAL_0:1;
      for i being Nat st m <= i & i < m holds F.m < F.i;
 hence min_at(F, m, m) = m by A1,A2,Th3;
end;

definition
 let F be FinSequence of INT, m, n be Nat;
 pred F is_non_decreasing_on m, n means
:Def4:
   for i, j being Nat st m <= i & i <= j & j <= n holds F.i <= F.j;
end;

definition
 let F be FinSequence of INT, n be Nat;
 pred F is_split_at n means
:Def5:
  for i, j being Nat st 1 <= i & i <= n & n < j & j <= len F
   holds F.i <= F.j;
end;

theorem Th5:
  k+1 <= len F & ma = min_at(F, k+1, len F) & F is_split_at k &
  F is_non_decreasing_on 1, k & F1 = F+*(k+1, F.ma)+*(ma, F.(k+1))
    implies F1 is_non_decreasing_on 1, k+1
proof assume that
A1: k+1 <= len F and
A2: ma = min_at(F, k+1, len F) and
A3: F is_split_at k and
A4: F is_non_decreasing_on 1, k and
A5: F1 = F+*(k+1, F.ma)+*(ma, F.(k+1));
   set Fk = F+*(k+1, F.ma);
A6: dom F1 = dom Fk by A5,FUNCT_7:32;
A7: dom Fk = dom F by FUNCT_7:32;
 let i, j be Nat such that
A8: 1 <= i & i <= j & j <= k+1;
A9: 1 <= k+1 by NAT_1:37;
        1 <= j & j <= len F by A1,A8,XXREAL_0:2;
then A10: j in dom F1 by A6,A7,FINSEQ_3:27;
A11: k+1 in dom F1 by A1,A6,A7,A9,FINSEQ_3:27;
 per cases by A8,REAL_1:def 5;
 suppose A12: j < k+1;
 then A13: j <= k by NAT_1:38;
        i < k+1 by A8,A12,XXREAL_0:2;
 then A14: i <> ma by A1,A2,A9,Th3;
 A15: j <> ma by A1,A2,A9,A12,Th3;
 A16: F1.i = Fk.i by A5,A14,FUNCT_7:34
         .= F.i by A8,A12,FUNCT_7:34;
     F1.j = Fk.j by A5,A15,FUNCT_7:34
         .= F.j by A12,FUNCT_7:34;
  hence F1.i <= F1.j by A4,A8,A13,A16,Def4;
 end;
 suppose A17: j = k+1;
  thus F1.i <= F1.j proof
   per cases by A8,REAL_1:def 5;
   suppose A18: i < j;
   then i <> ma by A1,A2,A9,A17,Th3;
   then A19: F1.i = Fk.i by A5,FUNCT_7:34
           .= F.i by A17,A18,FUNCT_7:34;
   A20: i <= k by A17,A18,NAT_1:38;
   A21: k < j by A17,NAT_1:38;
    thus F1.i <= F1.j proof
     per cases;
     suppose k+1 = ma; then F1.j = F.(k+1) by A5,A6,A11,A17,FUNCT_7:33;
      hence F1.i <= F1.j by A1,A3,A8,A17,A19,A20,A21,Def5;
     end;
     suppose A22: k+1 <> ma;
            k+1 <= ma by A1,A2,A9,Th3;
     then A23: k < ma by NAT_1:38;
     A24: ma <= len F by A1,A2,A9,Th3;
          F1.j = Fk.j by A5,A17,A22,FUNCT_7:34
           .= F.ma by A6,A7,A10,A17,FUNCT_7:33;
      hence F1.i <= F1.j by A3,A8,A19,A20,A23,A24,Def5;
    end;
    end;
   end;
   suppose i = j; hence F1.i <= F1.j;
  end;
  end;
end;
end;

theorem Th6:
 k+1 <= len F & ma = min_at(F, k+1, len F) & F is_split_at k &
 F1 = F+*(k+1, F.ma)+*(ma, F.(k+1))
   implies F1 is_split_at k+1
proof assume that
A1: k+1 <= len F and
A2: ma = min_at(F, k+1, len F) and
A3: F is_split_at k and
A4: F1 = F+*(k+1, F.ma)+*(ma, F.(k+1));
A5: dom F1 = dom (F+*(k+1, F.ma)) by A4,FUNCT_7:32;
A6: dom (F+*(k+1, F.ma)) = dom F by FUNCT_7:32;
then A7: len F1 = len F by A5,FINSEQ_3:31;
A8: k < k+1 by NAT_1:38;
A9: 1 <= k+1 & k+1 <= len F by A1,NAT_1:37;
 let i, j be Nat; assume
A10: 1 <= i & i <= k+1 & k+1 < j & j <= len F1;
then A11: k < j by NAT_1:38;
       1 <= j by A10,NAT_1:37;
then A12: j in dom F1 by A10,FINSEQ_3:27;
       i <= len F1 by A1,A7,A10,XXREAL_0:2;
then A13: i in dom F1 by A10,FINSEQ_3:27;
A14: k+1 <= len F by A7,A10,XXREAL_0:2;
 per cases by A10,REAL_1:def 5;
 suppose A15: i < k+1;
 then A16: i <= k by NAT_1:38;
    i <> ma by A2,A9,A15,Th3;
 then A17: F1.i = (F+*(k+1, F.ma)).i by A4,FUNCT_7:34
         .= F.i by A15,FUNCT_7:34;
  thus F1.i <= F1.j proof
   per cases;
   suppose j <> ma;
     then F1.j = (F+*(k+1, F.ma)).j by A4,FUNCT_7:34
         .= F.j by A10,FUNCT_7:34;
    hence thesis by A3,A7,A10,A11,A16,A17,Def5;
   end;
   suppose j = ma; then F1.j = F.(k+1) by A4,A5,A12,FUNCT_7:33;
    hence thesis by A3,A8,A10,A14,A16,A17,Def5;
   end;
   end;
 end;
 suppose A18: i = k+1;
 A19: F1.i = F.ma proof
  per cases;
  suppose k+1 = ma;
   hence F1.i = F.ma by A4,A5,A13,A18,FUNCT_7:33;
  end;
  suppose k+1 <> ma;
   hence F1.i = (F+*(k+1, F.ma)).i by A4,A18,FUNCT_7:34
             .= F.ma by A5,A6,A13,A18,FUNCT_7:33;
 end;
 end;
  thus thesis proof
   per cases;
   suppose j = ma;
     then F1.j = F.(k+1) by A4,A5,A12,FUNCT_7:33;
    hence F1.i <= F1.j by A2,A9,A19,Th3;
   end;
   suppose j <> ma;
     then F1.j = (F+*(k+1, F.ma)).j by A4,FUNCT_7:34
         .= F.j by A10,FUNCT_7:34;
    hence F1.i <= F1.j by A2,A7,A9,A10,A19,Th3;
  end;
  end;
end;
end;

begin :: SCM+FSA preliminaries

 reserve s for State of SCM+FSA,
         a, c for read-write Int-Location,
         aa, bb, cc, dd, x for Int-Location,
         f for FinSeq-Location,
         I, J for Macro-Instruction,
         Ig for good Macro-Instruction,
         i, k for Nat;

theorem Th7:
 I is_closed_on Initialize s & I is_halting_on Initialize s &
 I does_not_destroy aa
  implies IExec(I,s).aa = (Initialize s).aa
proof
 set D = Int-Locations \/ FinSeq-Locations;
 set a = aa; assume that
A1: I is_closed_on Initialize s & I is_halting_on Initialize s and
A2: I does_not_destroy a;
A3: (Initialize s) | D = (Initialize s +* (I +* Start-At insloc 0)) | D
       by SCMFSA8A:11;
   thus IExec(I,s).a
    = (Computation (Initialize s +* (I +* Start-At insloc 0))).0.a by A1,A2,
SCMFSA8C:89
   .= (Initialize s +* (I +* Start-At insloc 0)).a by AMI_1:def 19
   .= (Initialize s).a by A3,SCMFSA6A:38;
end;

theorem Th8:
 s.intloc 0 = 1 implies
   IExec(SCM+FSA-Stop, s) | (Int-Locations \/ FinSeq-Locations) =
     s | (Int-Locations \/ FinSeq-Locations)
proof
 set D = Int-Locations \/ FinSeq-Locations; assume
A1: s.intloc 0 = 1;
 thus IExec(SCM+FSA-Stop, s) | D
    = (Initialize s +* Start-At insloc 0) | D by SCMFSA8C:38
   .= (Initialize s) | D by SCMFSA8A:10
   .= s | D by A1,SCMFSA8C:27;
end;

theorem Th9:
 SCM+FSA-Stop does_not_refer aa
proof
 let i be Instruction of SCM+FSA such that
A1: i in rng SCM+FSA-Stop;
     rng SCM+FSA-Stop = {halt SCM+FSA} by CQC_LANG:5,SCMFSA_4:def 5;
  then i = halt SCM+FSA by A1,TARSKI:def 1;
 hence i does_not_refer aa by SCMFSA8C:78;
end;

theorem Th10:
 aa <> bb implies cc := bb does_not_refer aa
proof
   assume A1: aa <> bb;
      now let e be Int-Location;
      let l be Instruction-Location of SCM+FSA;
      let f be FinSeq-Location;
   A2: 1 <> 2 & 1 <> 3 & 1 <> 4 & 1 <> 5 & 1 <> 7 & 1 <> 8 & 1 <> 9 & 1 <> 10
      & 1 <> 12 & InsCode (cc := bb) = 1 by SCMFSA_2:42;
      thus e := aa <> cc := bb by A1,SF_MASTR:5;
      thus AddTo(e,aa) <> cc := bb by A2,SCMFSA_2:43;
      thus SubFrom(e,aa) <> cc := bb by A2,SCMFSA_2:44;
      thus MultBy(e,aa) <> cc := bb by A2,SCMFSA_2:45;
      thus Divide(aa,e) <> cc := bb & Divide(e,aa) <> cc := bb
          by A2,SCMFSA_2:46;
      thus aa =0_goto l <> cc := bb by A2,SCMFSA_2:48;
      thus aa >0_goto l <> cc := bb by A2,SCMFSA_2:49;
      thus e :=(f,aa) <> cc := bb by A2,SCMFSA_2:50;
      thus (f,e):= aa <> cc := bb & (f,aa):= e <> cc := bb by A2,SCMFSA_2:51;
      thus f :=<0,...,0> aa <> cc := bb by A2,SCMFSA_2:53;
     end;
   hence cc := bb does_not_refer aa by SCMFSA7B:def 1;
 end;

theorem Th11:  :: change SCMFSA_2:98
 Exec(a := (f, bb), s).a = (s.f)/.abs(s.bb)
proof
   ex k st k = abs(s.bb) & Exec(a:=(f,bb), s).a = (s.f)/.k by SCMFSA_2:98;
 hence thesis;
end;

theorem Th12:  :: see SCMFSA_2:99
 Exec((f, aa) := bb, s).f = s.f+*(abs(s.aa), s.bb)
proof
   ex k st k=abs(s.aa) & Exec((f,aa):=bb, s).f = s.f+*(k,s.bb) by SCMFSA_2:99;
 hence thesis;
end;

registration
 let a be read-write Int-Location, b be Int-Location,
     I, J be good Macro-Instruction;
 cluster if>0(a, b, I, J) -> good;
 coherence proof
      if>0(a, b, I, J) = SubFrom(a,b) ';' if>0(a,I,J) by SCMFSA8B:def 5;
  hence thesis;
 end;
end;

theorem Th13:
 UsedIntLoc if>0(aa, bb, I, J) = {aa, bb} \/ (UsedIntLoc I) \/ UsedIntLoc J
proof set a = aa;
 thus UsedIntLoc if>0(a, bb, I, J)
 = UsedIntLoc (SubFrom(a,bb) ';' if>0(a,I,J)) by SCMFSA8B:def 5
.= (UsedIntLoc SubFrom(a,bb)) \/ UsedIntLoc if>0(a,I,J) by SF_MASTR:33
.= {a,bb} \/ UsedIntLoc if>0(a,I,J) by SF_MASTR:18
.= {a,bb} \/ ({a} \/ UsedIntLoc I \/ UsedIntLoc J) by SCMFSA9A:15
.= {a,bb} \/ ({a} \/ (UsedIntLoc I \/ UsedIntLoc J)) by XBOOLE_1:4
.= {a,bb} \/ {a} \/ ((UsedIntLoc I \/ UsedIntLoc J)) by XBOOLE_1:4
.= {a, bb} \/ (UsedIntLoc I \/ UsedIntLoc J) by ZFMISC_1:14
.= {a, bb} \/ UsedIntLoc I \/ UsedIntLoc J by XBOOLE_1:4;
end;

theorem Th14:
 I does_not_destroy aa implies while>0(bb, I) does_not_destroy aa
proof assume
A1: I does_not_destroy aa;
   set J=insloc (card I +4) .--> goto insloc 0;
  set F=if>0(bb, I ';' Goto insloc 0, SCM+FSA-Stop);
A2:  J does_not_destroy aa by SCMFSA_9:35;
      Goto insloc 0 does_not_destroy aa by SCMFSA8C:86;
then A3: I ';' Goto insloc 0 does_not_destroy aa by A1,SCMFSA8C:81;
    SCM+FSA-Stop does_not_destroy aa by SCMFSA8C:85;
then A4:  F does_not_destroy aa by A3,SCMFSA8C:121;
        while>0(bb,I) = F+*J by SCMFSA_9:def 2;
 hence while>0(bb,I) does_not_destroy aa by A2,A4,SCMFSA8A:25;
end;

theorem Th15:
 cc <> aa & I does_not_destroy cc & J does_not_destroy cc
  implies if>0(aa, bb, I, J) does_not_destroy cc
proof assume that
A1: cc <> aa and
A2: I does_not_destroy cc and
A3: J does_not_destroy cc;
A4: if>0(aa, bb, I, J) = SubFrom(aa,bb) ';' if>0(aa,I,J) by SCMFSA8B:def 5;
A5: SubFrom(aa,bb) does_not_destroy cc by A1,SCMFSA7B:14;
      if>0(aa,I,J) does_not_destroy cc by A2,A3,SCMFSA8C:121;
 hence if>0(aa, bb, I, J) does_not_destroy cc by A4,A5,SCMFSA8C:82;
end;

begin :: The for-up macro instruction

definition
 let a, b, c be Int-Location, I be Macro-Instruction,
     s be State of SCM+FSA;
 func StepForUp(a, b, c, I, s) -> Function of NAT,
                                     product the Object-Kind of SCM+FSA
  equals

  StepWhile>0(1-stRWNotIn ({a, b, c} \/ UsedIntLoc I),
        I ';' AddTo(a, intloc 0) ';'
        SubFrom(1-stRWNotIn ({a, b, c} \/ UsedIntLoc I), intloc 0),
        s+*(1-stRWNotIn ({a, b, c} \/ UsedIntLoc I), s.c-s.b+1)+*(a, s.b));
 coherence;
end;

theorem Th16:
 s.intloc 0 = 1 implies StepForUp(a, bb, cc, I, s).0.intloc 0 = 1
proof assume
A1: s.intloc 0 = 1;
 set aux = 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I);
 set S = s+*(aux, s.cc-s.bb+1)+*(a, s.bb);
A2: StepWhile>0(aux, I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0), S).0
    = S by SCMFSA_9:def 5;
   S.intloc 0 = (s+*(aux, s.cc-s.bb+1)).intloc 0 by FUNCT_7:34
  .= s.intloc 0 by FUNCT_7:34;
 hence StepForUp(a, bb, cc, I, s).0.intloc 0 = 1 by A1,A2;
end;

theorem Th17:
  StepForUp(a, bb, cc, I, s).0.a = s.bb
proof
 set aux = 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I);
 set S = s+*(aux, s.cc-s.bb+1)+*(a, s.bb);
A1: StepWhile>0(aux, I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0), S).0
    = S by SCMFSA_9:def 5;
       a in dom (s+*(aux, s.cc-s.bb+1)) by SCMFSA_2:66;
 hence thesis by A1,FUNCT_7:33;
end;

theorem Th18:
  a <> bb implies StepForUp(a, bb, cc, I, s).0.bb = s.bb
proof assume
A1: a <> bb;
 set aux = 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I);
 set S = s+*(aux, s.cc-s.bb+1)+*(a, s.bb);
A2: StepWhile>0(aux, I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0), S).0
    = S by SCMFSA_9:def 5;
       bb in {a, bb, cc} by ENUMSET1:def 1;
    then bb in {a, bb, cc} \/ UsedIntLoc I by XBOOLE_0:def 2;
then A3: bb <> aux by SFMASTR1:21;
      S.bb = (s+*(aux, s.cc-s.bb+1)).bb by A1,FUNCT_7:34
      .= s.bb by A3,FUNCT_7:34;
 hence StepForUp(a, bb, cc, I, s).0.bb = s.bb by A2;
end;

theorem Th19:
  a <> cc implies StepForUp(a, bb, cc, I, s).0.cc = s.cc
proof assume
A1: a <> cc;
 set aux = 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I);
 set S = s+*(aux, s.cc-s.bb+1)+*(a, s.bb);
A2: StepWhile>0(aux, I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0), S).0
    = S by SCMFSA_9:def 5;
       cc in {a, bb, cc} by ENUMSET1:def 1;
    then cc in {a, bb, cc} \/ UsedIntLoc I by XBOOLE_0:def 2;
then A3: cc <> aux by SFMASTR1:21;
      S.cc = (s+*(aux, s.cc-s.bb+1)).cc by A1,FUNCT_7:34
      .= s.cc by A3,FUNCT_7:34;
 hence StepForUp(a, bb, cc, I, s).0.cc = s.cc by A2;
end;

theorem Th20:
 a <> dd & dd in UsedIntLoc I implies StepForUp(a, bb, cc, I, s).0.dd = s.dd
proof assume
A1: a <> dd & dd in UsedIntLoc I;
 set aux = 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I);
 set S = s+*(aux, s.cc-s.bb+1)+*(a, s.bb);
A2: StepWhile>0(aux, I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0), S).0
    = S by SCMFSA_9:def 5;
       dd in {a, bb, cc} \/ UsedIntLoc I by A1,XBOOLE_0:def 2;
then A3: dd <> aux by SFMASTR1:21;
      S.dd = (s+*(aux, s.cc-s.bb+1)).dd by A1,FUNCT_7:34
       .= s.dd by A3,FUNCT_7:34;
 hence StepForUp(a, bb, cc, I, s).0.dd = s.dd by A2;
end;

theorem Th21:
 StepForUp(a, bb, cc, I, s).0.f = s.f
proof
 set aux = 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I);
 set S = s+*(aux, s.cc-s.bb+1)+*(a, s.bb);
A1: StepWhile>0(aux, I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0), S).0
    = S by SCMFSA_9:def 5;
A2: f <> a by SCMFSA_2:83;
A3: f <> aux by SCMFSA_2:83;
      S.f = (s+*(aux, s.cc-s.bb+1)).f by A2,FUNCT_7:34
      .= s.f by A3,FUNCT_7:34;
 hence thesis by A1;
end;

theorem Th22:
 s.intloc 0 = 1 implies
  for aux being read-write Int-Location
    st aux = 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I)
  holds IExec( aux := cc ';' SubFrom(aux, bb) ';' AddTo(aux, intloc 0) ';'
              (a := bb), s) | (Int-Locations \/ FinSeq-Locations)
      = (s+*(aux, s.cc-s.bb+1)+*(a, s.bb)) |
        (Int-Locations \/ FinSeq-Locations)
proof assume
A1: s.intloc 0 = 1;
let aux be read-write Int-Location such that
A2: aux = 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I);
   set i0 = aux := cc;
   set i1 = SubFrom(aux, bb);
   set i2 = AddTo(aux, intloc 0);
   set i3 = a := bb;
   set s1 = IExec(i0 ';' i1 ';' i2 ';' i3, s);
   set s2 = s+*(aux, s.cc-s.bb+1)+*(a, s.bb);
         a in {a, bb, cc} by ENUMSET1:def 1;
      then a in {a, bb, cc} \/ UsedIntLoc I by XBOOLE_0:def 2;
then A3: a <> aux by A2,SFMASTR1:21;
         bb in {a, bb, cc} by ENUMSET1:def 1;
      then bb in {a, bb, cc} \/ UsedIntLoc I by XBOOLE_0:def 2;
then A4: bb <> aux by A2,SFMASTR1:21;
A5: IExec(i0 ';' i1, s).intloc 0
   = Exec(i1, Exec(i0, Initialize s)).intloc 0 by SCMFSA6C:9
  .= Exec(i0, Initialize s).intloc 0 by SCMFSA_2:91
  .= (Initialize s).intloc 0 by SCMFSA_2:89
  .= 1 by SCMFSA6C:3;
        cc = intloc 0 or cc is read-write by SF_MASTR:def 5;
then A6: (Initialize s).cc = s.cc by A1,SCMFSA6C:3;
        bb = intloc 0 or bb is read-write by SF_MASTR:def 5;
then A7: (Initialize s).bb = s.bb by A1,SCMFSA6C:3;
A8: s1.aux
   = Exec(i3, IExec(i0 ';' i1 ';' i2, s)).aux by SCMFSA6C:7
  .= IExec(i0 ';' i1 ';' i2, s).aux by A3,SCMFSA_2:89
  .= Exec(i2, IExec(i0 ';' i1, s)).aux by SCMFSA6C:7
  .= IExec(i0 ';' i1, s).aux + 1 by A5,SCMFSA_2:90
  .= Exec(i1, Exec(i0, Initialize s)).aux +1 by SCMFSA6C:9
  .= Exec(i0, Initialize s).aux
      - Exec(i0, Initialize s).bb +1 by SCMFSA_2:91
  .= (Initialize s).cc
      - Exec(i0, Initialize s).bb +1 by SCMFSA_2:89
  .= s.cc-s.bb+1 by A4,A6,A7,SCMFSA_2:89;
A9: s1.a
   = Exec(i3, IExec(i0 ';' i1 ';' i2, s)).a by SCMFSA6C:7
  .= IExec(i0 ';' i1 ';' i2, s).bb by SCMFSA_2:89
  .= Exec(i2, IExec(i0 ';' i1, s)).bb by SCMFSA6C:7
  .= IExec(i0 ';' i1, s).bb by A4,SCMFSA_2:90
  .= Exec(i1, Exec(i0, Initialize s)).bb by SCMFSA6C:9
  .= Exec(i0, Initialize s).bb by A4,SCMFSA_2:91
  .= s.bb by A4,A7,SCMFSA_2:89;
A10: aux in dom s by SCMFSA_2:66;
A11:  s2.aux
      = (s+*(aux, s.cc-s.bb+1)).aux by A3,FUNCT_7:34
     .= s.cc-s.bb+1 by A10,FUNCT_7:33;
    A12: a in dom (s+*(aux, s.cc-s.bb+1)) by SCMFSA_2:66;
      now
    hereby let x be Int-Location;
     per cases;
     suppose x = a;
      hence s1.x = s2.x by A9,A12,FUNCT_7:33;
    end;
    suppose x = aux;
      hence s1.x = s2.x by A8,A11;
    end;
    suppose A13: x <> aux & x <> a;
      A14: x = intloc 0 or x is read-write by SF_MASTR:def 5;
      A15: s1.x = Exec(i3, IExec(i0 ';' i1 ';' i2, s)).x by SCMFSA6C:7
               .= IExec(i0 ';' i1 ';' i2, s).x by A13,SCMFSA_2:89
               .= Exec(i2, IExec(i0 ';' i1, s)).x by SCMFSA6C:7
               .= IExec(i0 ';' i1, s).x by A13,SCMFSA_2:90
               .= Exec(i1, Exec(i0, Initialize s)).x by SCMFSA6C:9
               .= Exec(i0, Initialize s).x by A13,SCMFSA_2:91
               .= (Initialize s).x by A13,SCMFSA_2:89
               .= s.x by A1,A14,SCMFSA6C:3;
             s2.x = (s+*(aux, s.cc-s.bb+1)).x by A13,FUNCT_7:34
               .= s.x by A13,FUNCT_7:34;
      hence s1.x = s2.x by A15;
     end;
     end;
    let x be FinSeq-Location;
      A16: x <> a & x <> aux by SCMFSA_2:83;
    thus s1.x = Exec(i3, IExec(i0 ';' i1 ';' i2, s)).x by SCMFSA6C:8
               .= IExec(i0 ';' i1 ';' i2, s).x by SCMFSA_2:89
               .= Exec(i2, IExec(i0 ';' i1, s)).x by SCMFSA6C:8
               .= IExec(i0 ';' i1, s).x by SCMFSA_2:90
               .= Exec(i1, Exec(i0, Initialize s)).x by SCMFSA6C:10
               .= Exec(i0, Initialize s).x by SCMFSA_2:91
               .= (Initialize s).x by SCMFSA_2:89
               .= s.x by SCMFSA6C:3
               .= (s+*(aux, s.cc-s.bb+1)).x by A16,FUNCT_7:34
               .= s2.x by A16,FUNCT_7:34;
   end;
 hence thesis by SCMFSA6A:38;
end;

definition
 let a, b, c be Int-Location, I be Macro-Instruction, s be State of SCM+FSA;
 pred ProperForUpBody a, b, c, I, s means :Def7:
  for i being Nat st i < s.c-s.b+1
   holds I is_closed_on StepForUp(a, b, c, I, s).i &
         I is_halting_on StepForUp(a, b, c, I, s).i;
end;

theorem Th23:
 for I being parahalting Macro-Instruction
  holds ProperForUpBody aa, bb, cc, I, s
proof let I be parahalting Macro-Instruction;
 let i be Nat such that i < s.cc-s.bb+1;
 thus I is_closed_on StepForUp(aa, bb, cc, I, s).i by SCMFSA7B:24;
 thus I is_halting_on StepForUp(aa, bb, cc, I, s).i by SCMFSA7B:25;
end;

theorem Th24:
 StepForUp(a, bb, cc, Ig, s).k.intloc 0 = 1 &
 Ig is_closed_on StepForUp(a, bb, cc, Ig, s).k &
 Ig is_halting_on StepForUp(a, bb, cc, Ig, s).k
  implies StepForUp(a, bb, cc, Ig, s).(k+1).intloc 0 = 1
proof
 set D = Int-Locations \/ FinSeq-Locations;
set I = Ig; assume that
A1: StepForUp(a, bb, cc, I, s).k.intloc 0 = 1 and
A2: I is_closed_on StepForUp(a, bb, cc, I, s).k and
A3: I is_halting_on StepForUp(a, bb, cc, I, s).k;
  set aux = 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I);
  set IB = I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0);
  set SW2 = StepWhile>0(aux,IB,s+*(aux, s.cc-s.bb+1)+*(a, s.bb));
A4: IB = I ';'(AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0)) by SCMFSA6A:65;
  per cases;
  suppose SW2.k.aux <= 0;
        then SW2.(k+1) | D = SW2.k | D by SCMFSA9A:37;
   hence StepForUp(a, bb, cc, I, s).(k+1).intloc 0 = 1 by A1,SCMFSA6A:38;
  end;
  suppose A5: SW2.k.aux > 0;
  A6: I is_closed_on Initialize SW2.k by A1,A2,SFMASTR2:4;
  A7: I is_halting_on Initialize SW2.k by A1,A2,A3,SFMASTR2:5;
  A8:  AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0) is_closed_on
             IExec(I, SW2.k) by SCMFSA7B:24;
  A9:  AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0) is_halting_on
             IExec(I, SW2.k) by SCMFSA7B:25;
  A10: IB is_closed_on Initialize SW2.k by A4,A6,A7,A8,SFMASTR1:3;
      IB is_halting_on Initialize SW2.k by A4,A6,A7,A8,A9,SFMASTR1:4;
  then A11: SW2.(k+1) | D = IExec(IB, SW2.k) | D
                                       by A1,A5,A10,SCMFSA9A:38;
        IExec(IB, SW2.k).intloc 0
   = IExec(AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0),
             IExec(I, SW2.k)).intloc 0 by A4,A6,A7,SFMASTR1:8
  .= Exec(SubFrom(aux, intloc 0),
       Exec(AddTo(a, intloc 0), Initialize IExec(I, SW2.k))).intloc 0
         by SCMFSA6C:9
  .= Exec(AddTo(a, intloc 0), Initialize IExec(I, SW2.k)).intloc 0
         by SCMFSA_2:91
  .= (Initialize IExec(I, SW2.k)).intloc 0 by SCMFSA_2:90
  .= 1 by SCMFSA6C:3;
  hence StepForUp(a, bb, cc, I, s).(k+1).intloc 0 = 1 by A11,SCMFSA6A:38;
end;
end;

theorem Th25:
 s.intloc 0 = 1 & ProperForUpBody a, bb, cc, Ig, s implies
   for k st k <= s.cc-s.bb+1
      holds StepForUp(a, bb, cc, Ig, s).k.intloc 0 = 1 &
            (Ig does_not_destroy a implies
                   StepForUp(a, bb, cc, Ig, s).k.a = k+s.bb &
                   StepForUp(a, bb, cc, Ig, s).k.a <= s.cc+1) &
 StepForUp(a, bb, cc, Ig, s).k.(1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc Ig)) + k
  = s.cc-s.bb+1
proof
 set D = Int-Locations \/ FinSeq-Locations;
set I = Ig; assume that
A1: s.intloc 0 = 1 and
A2: ProperForUpBody a, bb, cc, I, s;
   set SF = StepForUp(a, bb, cc, I, s);
   set aux = (1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I));
   set IB = I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0);
   set s2 = s+*(aux, s.cc-s.bb+1)+*(a, s.bb);
   set SW2 = StepWhile>0(aux,IB,s2);
   set scb1 = s.cc-s.bb+1;
A3: IB = I ';'(AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0)) by SCMFSA6A:65;
  defpred P[Nat] means
   $1 <= scb1
    implies SF.$1.intloc 0 = 1 &
            (I does_not_destroy a implies
                   SF.$1.a = $1+s.bb &
                   SF.$1.a <= s.cc+1) &
            SF.$1.aux + $1 = scb1;
A4: a in dom (s+*(aux, s.cc-s.bb+1)) by SCMFSA_2:66;
A5: aux in dom s by SCMFSA_2:66;
          a in {a, bb, cc} by ENUMSET1:def 1;
       then a in {a, bb, cc} \/ UsedIntLoc I by XBOOLE_0:def 2;
then A6: aux <> a by SFMASTR1:21;
A7: P[0] proof assume
  A8: 0 <= scb1;
  A9: SW2.0 = s2 by SCMFSA_9:def 5;
     hence SF.0.intloc 0 = (s+*(aux, s.cc-s.bb+1)).intloc 0 by FUNCT_7:34
       .= 1 by A1,FUNCT_7:34;
     hereby assume I does_not_destroy a;
      thus SF.0.a = 0+s.bb by A4,A9,FUNCT_7:33;
            0+s.bb <= s.cc+1-s.bb+s.bb by A8,XREAL_1:8;
      hence SF.0.a <= s.cc+1 by A4,A9,FUNCT_7:33;
     end;
     thus SF.0.aux + 0 = (s+*(aux, s.cc-s.bb+1)).aux by A6,A9,FUNCT_7:34
       .= scb1 by A5,FUNCT_7:33;
    end;
A10: for k st P[k] holds P[k+1] proof let k such that
    A11: P[k];
      thus P[k+1]
      proof
       assume
    A12: k+1 <= scb1;
    A13: k < k+1 by XREAL_1:31;
    then A14: k < scb1 by A12,XXREAL_0:2;
    then A15: I is_closed_on SF.k by A2,Def7;
    A16: I is_halting_on SF.k by A2,A14,Def7;
        set k1 = k+1;
     thus SF.k1.intloc 0 = 1 by A11,A12,A13,A15,A16,Th24,XXREAL_0:2;

  A17: SW2.k.aux > 0 by A11,A12,A14,XREAL_1:10;
  A18: I is_closed_on Initialize SW2.k
        by A11,A12,A13,A15,XXREAL_0:2,SFMASTR2:4;
  A19: I is_halting_on Initialize SW2.k
        by A11,A12,A13,A15,A16,XXREAL_0:2,SFMASTR2:5;
  A20:  AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0) is_closed_on
             IExec(I, SW2.k) by SCMFSA7B:24;
  A21:  AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0) is_halting_on
             IExec(I, SW2.k) by SCMFSA7B:25;
  A22: IB is_closed_on Initialize SW2.k by A3,A18,A19,A20,SFMASTR1:3;
      IB is_halting_on Initialize SW2.k
              by A3,A18,A19,A20,A21,SFMASTR1:4;
  then A23: SW2.(k+1) | D = IExec(IB, SW2.k) | D
              by A11,A12,A13,A17,A22,XXREAL_0:2,SCMFSA9A:38;
     hereby assume
     A24: I does_not_destroy a;
   IExec(IB, SW2.k).a
   = IExec(AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0),
             IExec(I, SW2.k)).a by A3,A18,A19,SFMASTR1:8
  .= Exec(SubFrom(aux, intloc 0),
       Exec(AddTo(a, intloc 0), Initialize IExec(I, SW2.k))).a by SCMFSA6C:9
  .= Exec(AddTo(a, intloc 0), Initialize IExec(I, SW2.k)).a by A6,SCMFSA_2:91
  .= (Initialize IExec(I, SW2.k)).a + (Initialize IExec(I, SW2.k)).intloc 0
         by SCMFSA_2:90
  .= (Initialize IExec(I, SW2.k)).a +1 by SCMFSA6C:3
  .= IExec(I, SW2.k).a +1 by SCMFSA6C:3
  .= (Initialize SW2.k).a +1 by A18,A19,A24,Th7
  .= SW2.k.a +1 by SCMFSA6C:3;
      hence A25: SF.k1.a = k+s.bb +1
                            by A11,A12,A13,A23,A24,XXREAL_0:2,SCMFSA6A:38
                  .= k1+s.bb;
            k1+s.bb <= s.cc+1-s.bb+s.bb by A12,XREAL_1:8;
      hence SF.k1.a <= s.cc+1 by A25;
     end;
        not aux in UsedIntLoc I proof assume not thesis;
       then aux in {a, bb, cc} \/ UsedIntLoc I by XBOOLE_0:def 2;
      hence contradiction by SFMASTR1:21;
     end;
then A26: I does_not_destroy aux by SFMASTR1:1;
    IExec(IB, SW2.k).aux
   = IExec(AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0),
             IExec(I, SW2.k)).aux by A3,A18,A19,SFMASTR1:8
  .= Exec(SubFrom(aux, intloc 0),
      Exec(AddTo(a, intloc 0), Initialize IExec(I, SW2.k))).aux by SCMFSA6C:9
  .= Exec(AddTo(a, intloc 0), Initialize IExec(I, SW2.k)).aux
       - Exec(AddTo(a, intloc 0), Initialize IExec(I, SW2.k)).intloc 0
        by SCMFSA_2:91
  .= Exec(AddTo(a, intloc 0), Initialize IExec(I, SW2.k)).aux
       - (Initialize IExec(I, SW2.k)).intloc 0 by SCMFSA_2:90
  .= Exec(AddTo(a, intloc 0), Initialize IExec(I, SW2.k)).aux
       - 1 by SCMFSA6C:3
  .= (Initialize IExec(I, SW2.k)).aux -1 by A6,SCMFSA_2:90
  .= IExec(I, SW2.k).aux -1 by SCMFSA6C:3
  .= (Initialize SW2.k).aux -1 by A18,A19,A26,Th7
  .= SW2.k.aux -1 by SCMFSA6C:3;
     hence SF.k1.aux + k1
        = SW2.k.aux-1+k1 by A23,SCMFSA6A:38
       .= SW2.k.aux+k-1+1
       .= scb1 by A11,A12,A13,XXREAL_0:2;
     end;
    end;
 thus for k holds P[k] from NAT_1:sch 1(A7, A10);
end;

theorem Th26:
 s.intloc 0 = 1 & ProperForUpBody a, bb, cc, Ig, s implies
 for k holds
   StepForUp(a, bb, cc, Ig, s).k.(1-stRWNotIn({a, bb, cc} \/
 UsedIntLoc Ig)) > 0
iff k < s.cc-s.bb+1
proof
 set D = Int-Locations \/ FinSeq-Locations;
set I = Ig; assume that
A1: s.intloc 0 = 1 and
A2: ProperForUpBody a, bb, cc, I, s;
  set SF = StepForUp(a, bb, cc, I, s);
   set aux = (1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I));
   set s2 = s+*(aux, s.cc-s.bb+1)+*(a, s.bb);
   set IB = I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0);
   set SW2 = StepWhile>0(aux,IB,s2);
   set scb1 = s.cc-s.bb+1;
  defpred P[Nat] means
   SF.$1.aux > 0 implies $1 < scb1;

A3: aux in dom s by SCMFSA_2:66;
          a in {a, bb, cc} by ENUMSET1:def 1;
       then a in {a, bb, cc} \/ UsedIntLoc I by XBOOLE_0:def 2;
then A4: aux <> a by SFMASTR1:21;

A5: P[0] proof assume
  A6: SF.0.aux > 0;
      SW2.0 = s2 by SCMFSA_9:def 5;
      then SF.0.aux = (s+*(aux, s.cc-s.bb+1)).aux by A4,FUNCT_7:34
       .= scb1 by A3,FUNCT_7:33;
      hence 0 < scb1 by A6;
    end;
A7: for k st P[k] holds P[k+1] proof let k such that
  A8: P[k] and
  A9: SF.(k+1).aux > 0;
  A10: SF.k.aux > 0 proof assume
      A11: SF.k.aux <= 0;
          then SF.(k+1) | D = SF.k | D by SCMFSA9A:37;
         hence contradiction by A9,A11,SCMFSA6A:38;
      end;
      0 <= scb1 by A8,A10;
       then reconsider scb1 as Nat by INT_1:16;
      A12: k+1 <= scb1 by A8,A10,NAT_1:38;
     assume
         k+1 >= s.cc-s.bb+1;
      then SF.(k+1).aux+(k+1) > 0+scb1 by A9,XREAL_1:10;
     hence contradiction by A1,A2,A12,Th25;
    end;
A13: for k holds P[k] from NAT_1:sch 1(A5, A7);
   let k;
  thus P[k] by A13; assume
A14: k < scb1;
   then A15: SF.k.aux + k = scb1 by A1,A2,Th25;
      k-k < scb1-k by A14,XREAL_1:11;
  hence SF.k.aux > 0 by A15;
end;

theorem Th27:
s.intloc 0 = 1 & ProperForUpBody a, bb, cc, Ig, s & k < s.cc-s.bb+1 implies
  StepForUp(a, bb, cc, Ig, s).(k+1) | (({a, bb, cc} \/ UsedIntLoc Ig) \/
    FinSeq-Locations)
  = IExec(Ig ';' AddTo(a, intloc 0), StepForUp(a, bb, cc, Ig, s).k)
      | (({a, bb, cc} \/ UsedIntLoc Ig) \/ FinSeq-Locations)
proof
 set FL = FinSeq-Locations;
 set D = Int-Locations \/ FinSeq-Locations;
set I = Ig; assume that
A1: s.intloc 0 = 1 and
A2: ProperForUpBody a, bb, cc, I, s and
A3: k < s.cc-s.bb+1;

   set SF = StepForUp(a, bb, cc, I, s);
   set aux = (1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I));
   set IB = I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0);
   set s2 = s+*(aux, s.cc-s.bb+1)+*(a, s.bb);
   set SW2 = StepWhile>0(aux,IB,s2);
   set scb1 = s.cc-s.bb+1;
   set Iloc = {a, bb, cc} \/ UsedIntLoc I;
A4: SF = SW2;
A5: IB = I ';'(AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0)) by SCMFSA6A:65;

A6: SF.k.aux+k = scb1 by A1,A2,A3,Th25;
A7: I is_closed_on SF.k by A2,A3,Def7;
A8: I is_halting_on SF.k by A2,A3,Def7;
A9: SW2.k.intloc 0 = 1 by A1,A2,A3,A4,Th25;
  A10: SW2.k.aux > 0 proof
        assume SW2.k.aux <= 0;
               then SW2.k.aux + k < 0+scb1 by A3,XREAL_1:10;
         hence contradiction by A6;
      end;
  A11: I is_closed_on Initialize SW2.k by A7,A9,SFMASTR2:4;
  A12: I is_halting_on Initialize SW2.k by A7,A8,A9,SFMASTR2:5;
  A13:  AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0) is_closed_on
             IExec(I, SW2.k) by SCMFSA7B:24;
  A14:  AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0) is_halting_on
             IExec(I, SW2.k) by SCMFSA7B:25;
  A15: IB is_closed_on Initialize SW2.k by A5,A11,A12,A13,SFMASTR1:3;
      IB is_halting_on Initialize SW2.k
           by A5,A11,A12,A13,A14,SFMASTR1:4;
  then A16: SW2.(k+1) | D = IExec(IB, SW2.k) | D
                                       by A9,A10,A15,SCMFSA9A:38;
A17: Iloc \/ FL c= D by XBOOLE_1:9;
     set IB1 = I ';' AddTo(a, intloc 0);
     set S1 = IExec(IB1, SW2.k);
     set S2 = IExec(IB, SW2.k);
A18: IB1 = I ';' Macro AddTo(a, intloc 0) by SCMFSA6A:def 6;

  A19: Macro AddTo(a, intloc 0) is_closed_on IExec(I, SW2.k) by SCMFSA7B:24;
  A20: Macro AddTo(a, intloc 0) is_halting_on IExec(I, SW2.k) by SCMFSA7B:25;
  A21: IB1 is_closed_on Initialize SW2.k by A11,A12,A18,A19,SFMASTR1:3;
  A22: IB1 is_halting_on Initialize SW2.k
       by A11,A12,A18,A19,A20,SFMASTR1:4;
      now
    hereby let x be Int-Location; assume
       x in Iloc;
   then A23: x <> aux by SFMASTR1:21;
         S2.x = Exec(SubFrom(aux, intloc 0), S1).x by A21,A22,SFMASTR1:12
          .= S1.x by A23,SCMFSA_2:91;
     hence S1.x = S2.x;
    end;
    let x be FinSeq-Location;
         S2.x = Exec(SubFrom(aux, intloc 0), S1).x by A21,A22,SFMASTR1:13
          .= S1.x by SCMFSA_2:91;
     hence S1.x = S2.x;
   end;
then S1 | (Iloc \/ FL) = IExec(IB, SW2.k) | (Iloc \/ FL) by SFMASTR2:7;

  hence SF.(k+1) | (Iloc \/ FL)
     = IExec(I ';' AddTo(a, intloc 0), SF.k) | (Iloc \/ FL) by A16,A17,
RELAT_1:188;
end;

definition
 let a, b, c be Int-Location, I be Macro-Instruction;
 set aux = 1-stRWNotIn ({a, b, c} \/ UsedIntLoc I);
 func for-up(a, b, c, I) -> Macro-Instruction equals

    aux := c ';'
    SubFrom(aux, b) ';'
    AddTo(aux, intloc 0) ';'
    (a := b) ';'
    while>0( aux, I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0) );
 coherence;
end;

theorem Th28:
 {aa, bb, cc} \/ UsedIntLoc I c= UsedIntLoc for-up(aa, bb, cc, I)
proof
 set aux = 1-stRWNotIn ({aa, bb, cc} \/ UsedIntLoc I);
 set i0 = aux := cc;
 set i1 = SubFrom(aux, bb);
 set i2 = AddTo(aux, intloc 0);
 set i3 = aa := bb;
 set I4 = while>0( aux, I ';' AddTo(aa, intloc 0) ';'
                          SubFrom(aux, intloc 0));
A1:
 UsedIntLoc (i0 ';' i1 ';' i2 ';' i3)
  = UsedIntLoc (i0 ';' i1 ';' i2) \/ UsedIntLoc i3 by SF_MASTR:34
 .= UsedIntLoc (i0 ';' i1) \/ (UsedIntLoc i2) \/ UsedIntLoc i3 by SF_MASTR:34
 .= (UsedIntLoc i0) \/ (UsedIntLoc i1) \/ (UsedIntLoc i2) \/ UsedIntLoc i3
        by SF_MASTR:35
 .= {aux, cc} \/ (UsedIntLoc i1) \/ (UsedIntLoc i2) \/ UsedIntLoc i3
        by SF_MASTR:18
 .= {aux, cc} \/ {aux, bb} \/ (UsedIntLoc i2) \/ UsedIntLoc i3 by SF_MASTR:18
 .= {aux, cc} \/ {aux, bb} \/ {aux, intloc 0} \/ UsedIntLoc i3 by SF_MASTR:18
 .= {aux, cc} \/ {aux, bb} \/ {aux, intloc 0} \/ {aa, bb} by SF_MASTR:18;
A2: UsedIntLoc I4 = {aux} \/ UsedIntLoc (I ';' AddTo(aa, intloc 0) ';'
                          SubFrom(aux, intloc 0)) by SCMFSA9A:30
 .= {aux} \/ (UsedIntLoc (I ';' AddTo(aa, intloc 0)) \/
                   UsedIntLoc SubFrom(aux, intloc 0)) by SF_MASTR:34
 .= {aux} \/ (((UsedIntLoc I) \/ UsedIntLoc AddTo(aa, intloc 0))
               \/ UsedIntLoc SubFrom(aux, intloc 0)) by SF_MASTR:34
 .= {aux} \/ ((UsedIntLoc I) \/ ((UsedIntLoc AddTo(aa, intloc 0))
               \/ UsedIntLoc SubFrom(aux, intloc 0))) by XBOOLE_1:4
 .= (UsedIntLoc I) \/ ({aux} \/ (UsedIntLoc AddTo(aa, intloc 0)
               \/ UsedIntLoc SubFrom(aux, intloc 0))) by XBOOLE_1:4;
A3: UsedIntLoc for-up(aa, bb, cc, I) =
     (UsedIntLoc (i0 ';' i1 ';' i2 ';' i3)) \/ UsedIntLoc I4 by SF_MASTR:31;
 let x be set; assume
     x in {aa, bb, cc} \/ UsedIntLoc I;
then A4: x in {aa, bb, cc} or x in UsedIntLoc I by XBOOLE_0:def 2;
 per cases by A4,ENUMSET1:def 1;
 suppose x = aa; then x in {aa, bb} by TARSKI:def 2;
   then x in UsedIntLoc (i0 ';' i1 ';' i2 ';' i3) by A1,XBOOLE_0:def 2;
  hence x in UsedIntLoc for-up(aa, bb, cc, I) by A3,XBOOLE_0:def 2;
 end;
 suppose x = bb; then x in {aa, bb} by TARSKI:def 2;
   then x in UsedIntLoc (i0 ';' i1 ';' i2 ';' i3) by A1,XBOOLE_0:def 2;
  hence x in UsedIntLoc for-up(aa, bb, cc, I) by A3,XBOOLE_0:def 2;
 end;
 suppose x = cc; then x in {aux, cc} by TARSKI:def 2;
   then x in {aux, cc} \/ {aux, bb} by XBOOLE_0:def 2;
   then x in {aux, cc} \/ {aux, bb} \/ {aux, intloc 0} by XBOOLE_0:def 2;
   then x in {aux, cc} \/ {aux, bb} \/ {aux, intloc 0} \/ {aa, bb}by
XBOOLE_0:def 2;
  hence x in UsedIntLoc for-up(aa, bb, cc, I) by A1,A3,XBOOLE_0:def 2;
 end;
 suppose x in UsedIntLoc I; then x in UsedIntLoc I4 by A2,XBOOLE_0:def 2;
  hence x in UsedIntLoc for-up(aa, bb, cc, I) by A3,XBOOLE_0:def 2;
end;
end;

registration
 let a be read-write Int-Location, b, c be Int-Location,
     I be good Macro-Instruction;
 cluster for-up(a, b, c, I) -> good;
 coherence;
end;

theorem Th29:
 a <> aa & aa <> 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I) &
 I does_not_destroy aa
  implies for-up(a, bb, cc, I) does_not_destroy aa
proof assume that
A1: a <> aa and
A2: aa <> 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I) and
A3: I does_not_destroy aa;
   set aux = 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I);
   set i0 = aux := cc;
   set i1 = SubFrom(aux, bb);
   set i2 = AddTo(aux, intloc 0);
   set i3 = a := bb;
   set IB = I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0);
   set I4 = while>0( aux, IB);
   set I03 = i0 ';' i1 ';' i2 ';' i3;
A4:  i0 does_not_destroy aa by A2,SCMFSA7B:12;
A5:  i1 does_not_destroy aa by A2,SCMFSA7B:14;
A6:  i2 does_not_destroy aa by A2,SCMFSA7B:13;
A7:  i3 does_not_destroy aa by A1,SCMFSA7B:12;
         i0 ';' i1 does_not_destroy aa by A4,A5,SCMFSA8C:84;
      then i0 ';' i1 ';' i2 does_not_destroy aa by A6,SCMFSA8C:83;
then A8: I03 does_not_destroy aa by A7,SCMFSA8C:83;
      AddTo(a, intloc 0) does_not_destroy aa by A1,SCMFSA7B:13;
then A9: I ';' AddTo(a, intloc 0) does_not_destroy aa by A3,SCMFSA8C:83;
      SubFrom(aux, intloc 0) does_not_destroy aa by A2,SCMFSA7B:14;
   then IB does_not_destroy aa by A9,SCMFSA8C:83;
 then I4 does_not_destroy aa by Th14;
  hence for-up(a, bb, cc, I) does_not_destroy aa by A8,SCMFSA8C:81;
end;

theorem Th30:
 s.intloc 0 = 1 & s.bb > s.cc
   implies (for x st x <> a & x in {bb, cc} \/ UsedIntLoc I
              holds IExec(for-up(a, bb, cc, I), s).x = s.x) &
           for f holds IExec(for-up(a, bb, cc, I), s).f = s.f
proof
 set D = Int-Locations \/ FinSeq-Locations;
assume that
A1: s.intloc 0 = 1 and
A2: s.bb > s.cc;
   set aux = 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I);
   set i0 = aux := cc;
   set i1 = SubFrom(aux, bb);
   set i2 = AddTo(aux, intloc 0);
   set i3 = a := bb;
   set IB = I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0);
   set I4 = while>0( aux, IB);
   set I03 = i0 ';' i1 ';' i2 ';' i3;
   set MI = for-up(a, bb, cc, I);
   set s1 = IExec(I03, s);
   set s2 = s+*(aux, s.cc-s.bb+1)+*(a, s.bb);
         a in {a, bb, cc} by ENUMSET1:def 1;
      then a in {a, bb, cc} \/ UsedIntLoc I by XBOOLE_0:def 2;
then A3: a <> aux by SFMASTR1:21;
         bb in {a, bb, cc} by ENUMSET1:def 1;
      then bb in {a, bb, cc} \/ UsedIntLoc I by XBOOLE_0:def 2;
then A4: bb <> aux by SFMASTR1:21;
A5: IExec(i0 ';' i1, s).intloc 0
   = Exec(i1, Exec(i0, Initialize s)).intloc 0 by SCMFSA6C:9
  .= Exec(i0, Initialize s).intloc 0 by SCMFSA_2:91
  .= (Initialize s).intloc 0 by SCMFSA_2:89
  .= 1 by SCMFSA6C:3;
        cc = intloc 0 or cc is read-write by SF_MASTR:def 5;
then A6: (Initialize s).cc = s.cc by A1,SCMFSA6C:3;
        bb = intloc 0 or bb is read-write by SF_MASTR:def 5;
then A7: (Initialize s).bb = s.bb by A1,SCMFSA6C:3;
A8: s1.aux
   = Exec(i3, IExec(i0 ';' i1 ';' i2, s)).aux by SCMFSA6C:7
  .= IExec(i0 ';' i1 ';' i2, s).aux by A3,SCMFSA_2:89
  .= Exec(i2, IExec(i0 ';' i1, s)).aux by SCMFSA6C:7
  .= IExec(i0 ';' i1, s).aux + 1 by A5,SCMFSA_2:90
  .= Exec(i1, Exec(i0, Initialize s)).aux +1 by SCMFSA6C:9
  .= Exec(i0, Initialize s).aux
      - Exec(i0, Initialize s).bb +1 by SCMFSA_2:91
  .= (Initialize s).cc
      - Exec(i0, Initialize s).bb +1 by SCMFSA_2:89
  .= s.cc-s.bb+1 by A4,A6,A7,SCMFSA_2:89;
        s.bb -s.bb > s.cc-s.bb by A2,XREAL_1:11;
     then s.cc-s.bb <= -1 by INT_1:21;
     then A9: s.cc-s.bb+1 <= -1+1 by XREAL_1:8;
A10: s1.intloc 0
   = Exec(i3, IExec(i0 ';' i1 ';' i2, s)).intloc 0 by SCMFSA6C:7
  .= IExec(i0 ';' i1 ';' i2, s).intloc 0 by SCMFSA_2:89
  .= Exec(i2, IExec(i0 ';' i1, s)).intloc 0 by SCMFSA6C:7
  .= 1 by A5,SCMFSA_2:90;
A11: I4 is_halting_on s1 by A8,A9,SCMFSA_9:43;
    I4 is_closed_on s1 by A8,A9,SCMFSA_9:43;
then A12: IExec(MI, s) | D
   = IExec(I4, s1) | D by A11,SFMASTR1:10
  .= s1 | D by A8,A9,A10,SCMFSA9A:41
  .= s2 | D by A1,Th22;
  set s3 = IExec(MI, s);
 hereby let x be Int-Location such that
   A13: x <> a and
   A14: x in {bb, cc} \/ UsedIntLoc I;
          x in {a, bb, cc} \/ UsedIntLoc I proof
        per cases by A14,XBOOLE_0:def 2;
        suppose x in {bb, cc}; then x = bb or x = cc by TARSKI:def 2;
          then x in {a, bb, cc} by ENUMSET1:def 1;
         hence thesis by XBOOLE_0:def 2;
        end;
        suppose x in UsedIntLoc I;
         hence thesis by XBOOLE_0:def 2;
       end;
       end;
   then A15: x <> aux by SFMASTR1:21;
  thus s3.x = s2.x by A12,SCMFSA6A:38
           .= (s+*(aux, s.cc-s.bb+1)).x by A13,FUNCT_7:34
           .= s.x by A15,FUNCT_7:34;
 end;
 let x be FinSeq-Location;
   A16: x <> a by SCMFSA_2:83;
   A17: x <> aux by SCMFSA_2:83;
  thus s3.x = s2.x by A12,SCMFSA6A:38
           .= (s+*(aux, s.cc-s.bb+1)).x by A16,FUNCT_7:34
           .= s.x by A17,FUNCT_7:34;
end;

Lm1:
now let s, a, bb, cc;
 set D = Int-Locations \/ FinSeq-Locations;
let I be good Macro-Instruction such that
A1: s.intloc 0 = 1 and
A2: ProperForUpBody a, bb, cc, I, s or I is parahalting;
A3: ProperForUpBody a, bb, cc, I, s by A2,Th23;
   set aux = 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I);
   set i0 = aux := cc;
   set i1 = SubFrom(aux, bb);
   set i2 = AddTo(aux, intloc 0);
   set i3 = a := bb;
   set IB = I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0);
   set s1 = IExec(i0 ';' i1 ';' i2 ';' i3, s);
   set s2 = s+*(aux, s.cc-s.bb+1)+*(a, s.bb);
A4: s1 | D = s2 | D by A1,Th22;
    set IB2 = AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0);
    set SW1 = StepWhile>0(aux,IB,s1);
    set SW2 = StepWhile>0(aux,IB,s2);
    set SF = StepForUp(a, bb, cc, I, s);
    set scb1 = s.cc-s.bb+1;
A5: IB = I ';' (AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0)) by SCMFSA6A:65;
A6: SF = SW2;

A7: ProperBodyWhile>0 aux, IB, s2 proof let k be Nat; assume
          StepWhile>0(aux,IB,s2).k.aux > 0;
   then A8: k < scb1 by A1,A3,A6,Th26;
   then A9: SF.k.intloc 0 = 1 by A1,A3,Th25;
   A10: I is_closed_on SF.k by A3,A8,Def7;
   then A11: I is_closed_on Initialize SF.k by A9,SFMASTR2:4;
       I is_halting_on SF.k by A3,A8,Def7;
   then A12: I is_halting_on Initialize SF.k by A9,A10,SFMASTR2:5;
   A13: IB2 is_closed_on IExec(I, SF.k) by SCMFSA7B:24;
   then A14: IB is_closed_on Initialize SF.k by A5,A11,A12,SFMASTR1:3;
      hence IB is_closed_on SW2.k by A9,SFMASTR2:4;
       IB2 is_halting_on IExec(I, SF.k) by SCMFSA7B:25;
       then IB is_halting_on Initialize SF.k by A5,A11,A12,A13,SFMASTR1:4;
      hence IB is_halting_on SW2.k by A9,A14,SFMASTR2:5;
     end;

 thus
    ProperBodyWhile>0 aux, IB, s1 proof let k be Nat; assume
     A15: StepWhile>0(aux,IB,s1).k.aux > 0;
     A16: SW2.k | D = SW1.k | D by A4,A7,SCMFSA9A:40;
     then A17: SW1.k.aux = SW2.k.aux by SCMFSA6A:38;
     then A18: IB is_closed_on SW2.k by A7,A15,SCMFSA9A:def 4;
     A19: IB is_halting_on SW2.k by A7,A15,A17,SCMFSA9A:def 4;
      thus IB is_closed_on SW1.k by A16,A18,SCMFSA8B:6;
      thus IB is_halting_on SW1.k by A16,A18,A19,SCMFSA8B:8;
     end;

   deffunc U(Element of product the Object-Kind of SCM+FSA) =  abs($1.aux);
   consider f being Function of product the Object-Kind of SCM+FSA,NAT
     such that
A20: for x being Element of product the Object-Kind of SCM+FSA
      holds f.x = U(x) from FUNCT_2:sch 4;
A21: for k being Nat
      holds ( f.(SW1.(k+1)) < f.(SW1.k) or SW1.k.aux <= 0 ) proof
      let k be Nat;
        A22: SW1.k | D = SW2.k | D by A4,A7,SCMFSA9A:40;
    then A23: SW1.k.aux = SW2.k.aux by SCMFSA6A:38;
           SW2.(k+1) | D = SW1.(k+1) | D by A4,A7,SCMFSA9A:40;
    then A24: SW1.(k+1).aux = SW2.(k+1).aux by SCMFSA6A:38;
         now assume
       A25: SW1.k.aux > 0;
       A26: f.(SW1.k)
          = abs( SW1.k.aux ) by A20
         .= SW2.k.aux by A23,A25,ABSVALUE:def 1;
            k < scb1 by A1,A3,A6,A23,A25,Th26;
       then A27: SW2.k.aux+k = s.cc-s.bb+1 by A1,A3,A6,Th25;
       A28: k < scb1 by A1,A3,A6,A23,A25,Th26;
         0 <= scb1 by A28;
         then reconsider scb1 as Nat by INT_1:16;
       A29: k+1 <= scb1 by A28,NAT_1:38;
     then A30: SW2.(k+1).aux+(k+1) = s.cc-s.bb+1 by A1,A3,A6,Th25;
       per cases;
       suppose A31: SW1.(k+1).aux > 0;
          A32: f.(SW1.(k+1))
             = abs( SW1.(k+1).aux ) by A20
            .= SW2.(k+1).aux by A24,A31,ABSVALUE:def 1
            .= scb1-(k+1) by A30
            .= scb1-k-1;
                  SW2.k.aux = scb1-k by A27;
        hence f.(SW1.(k+1)) < f.(SW1.k) by A26,A32,XREAL_1:148;
       end;
       suppose A33: SW1.(k+1).aux <= 0;
           SW2.(k+1).aux = scb1 - (k+1) by A30;
        then A34: SW1.(k+1).aux = 0 by A24,A29,A33,XREAL_1:50;
               f.(SW1.(k+1))
             = abs( SW1.(k+1).aux ) by A20
            .= 0 by A34,ABSVALUE:def 1;
        hence f.(SW1.(k+1)) < f.(SW1.k) by A22,A25,A26,SCMFSA6A:38;
       end;
       end;
      hence thesis;
     end;
 thus WithVariantWhile>0 aux, IB, s1 proof
       take f; thus thesis by A21;
     end;
end;

theorem Th31:
 s.intloc 0 = 1 &
 k = s.cc-s.bb+1 & (ProperForUpBody a, bb, cc, Ig, s or Ig is parahalting)
implies IExec(for-up(a, bb, cc, Ig), s) | (Int-Locations \/ FinSeq-Locations)
 = StepForUp(a, bb, cc, Ig, s).k | (Int-Locations \/ FinSeq-Locations)
proof
 set SAt = Start-At insloc 0;
 set D = Int-Locations \/ FinSeq-Locations;
set I = Ig; assume that
A1: s.intloc 0 = 1 and
A2: k = s.cc-s.bb+1 and
A3: ProperForUpBody a, bb, cc, I, s or I is parahalting;
A4: ProperForUpBody a, bb, cc, I, s by A3,Th23;
   set aux = 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I);
   set i0 = aux := cc;
   set i1 = SubFrom(aux, bb);
   set i2 = AddTo(aux, intloc 0);
   set i3 = a := bb;
   set IB = I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0);
   set I4 = while>0( aux, IB);
   set I03 = i0 ';' i1 ';' i2 ';' i3;
   set MI = for-up(a, bb, cc, I);
   set s1 = IExec(I03, s);
   set s2 = s+*(aux, s.cc-s.bb+1)+*(a, s.bb);
A5: s1.intloc 0
   = Exec(i3, IExec(i0 ';' i1 ';' i2, s)).intloc 0 by SCMFSA6C:7
  .= IExec(i0 ';' i1 ';' i2, s).intloc 0 by SCMFSA_2:89
  .= Exec(i2, IExec(i0 ';' i1, s)).intloc 0 by SCMFSA6C:7
  .= IExec(i0 ';' i1, s).intloc 0 by SCMFSA_2:90
  .= Exec(i1, Exec(i0, Initialize s)).intloc 0 by SCMFSA6C:9
  .= Exec(i0, Initialize s).intloc 0 by SCMFSA_2:91
  .= (Initialize s).intloc 0 by SCMFSA_2:89
  .= 1 by SCMFSA6C:3;
then A6: (Initialize s1) | D = s1 | D by SCMFSA8C:27;
A7: ProperBodyWhile>0 aux, IB, s1 by A1,A3,Lm1;
then A8: ProperBodyWhile>0 aux, IB, Initialize s1 by A6,SCMFSA9A:44;
A9: WithVariantWhile>0 aux, IB, s1 by A1,A3,Lm1;
then A10: WithVariantWhile>0 aux, IB, Initialize s1
           by A5,A6,A7,SCMFSA9A:47;
A11: I4 is_halting_on s1 by A7,A9,SCMFSA9A:33;
A12: I4 is_closed_on s1 by A7,A9,SCMFSA9A:33;
A13: s1 | D = s2 | D by A1,Th22;
    set SW1 = StepWhile>0(aux, IB, Initialize s1);
    set Ex1 = ExitsAtWhile>0(aux, IB, Initialize s1);
    set SW2 = StepWhile>0(aux,IB,s2);
    set SF = StepForUp(a, bb, cc, I, s);
    set scb1 = s.cc-s.bb+1;
  consider K being Nat such that
A14: Ex1 = K and
A15: SW1.K.aux <= 0 and
A16: for i being Nat st SW1.i.aux <= 0 holds K <= i and
      (Computation ((Initialize s1) +* (while>0(aux, IB) +* SAt))).
         (LifeSpan ((Initialize s1) +* (while>0(aux, IB) +* SAt))) | D
     = SW1.K | D by A8,A10,SCMFSA9A:def 6;
       SW1.K | D = SW2.K | D by A6,A8,A13,SCMFSA9A:40;
then A17: SW1.K.aux = SW2.K.aux by SCMFSA6A:38;
       SW1.k | D = SW2.k | D by A6,A8,A13,SCMFSA9A:40;
then A18: SW1.k.aux = SW2.k.aux by SCMFSA6A:38;
      SF.k.aux+k = scb1 by A1,A2,A4,Th25;
   then SF.k.aux = 0 by A2;
then A19: K <= k by A16,A18;
      now assume A20: K < scb1;
       then SF.K.aux + K < 0+scb1 by A15,A17,XREAL_1:10;
     hence contradiction by A1,A4,A20,Th25;
   end;
then A21: Ex1 = k by A2,A14,A19,XXREAL_0:1;

 thus IExec(MI, s) | D
  = IExec(I4, s1) | D by A11,A12,SFMASTR1:10
 .= SW1.Ex1 | D by A8,A10,SCMFSA9A:42
 .= SW2.k | D by A6,A8,A13,A21,SCMFSA9A:40
 .= StepForUp(a, bb, cc, I, s).k | D;
end;

theorem Th32:
 s.intloc 0 = 1 & (ProperForUpBody a, bb, cc, Ig, s or Ig is parahalting)
  implies for-up(a, bb, cc, Ig) is_closed_on s &
          for-up(a, bb, cc, Ig) is_halting_on s
proof set I = Ig; assume that
A1: s.intloc 0 = 1 and
A2: ProperForUpBody a, bb, cc, I, s or I is parahalting;
   set aux = 1-stRWNotIn ({a, bb, cc} \/ UsedIntLoc I);
   set i0 = aux := cc;
   set i1 = SubFrom(aux, bb);
   set i2 = AddTo(aux, intloc 0);
   set i3 = a := bb;
   set IB = I ';' AddTo(a, intloc 0) ';' SubFrom(aux, intloc 0);
   set I4 = while>0( aux, IB);
   set I03 = i0 ';' i1 ';' i2 ';' i3;
   set MI = for-up(a, bb, cc, I);
   set s1 = IExec(I03, s);
     reconsider I03 as parahalting Macro-Instruction;
A3: I03 is_closed_on Initialize s by SCMFSA7B:24;
A4: I03 is_halting_on Initialize s by SCMFSA7B:25;
A5: ProperBodyWhile>0 aux, IB, s1 by A1,A2,Lm1;
A6: WithVariantWhile>0 aux, IB, s1 by A1,A2,Lm1;
then A7: I4 is_closed_on s1 by A5,SCMFSA9A:33;
A8: I4 is_halting_on s1 by A5,A6,SCMFSA9A:33;
A9: MI is_closed_on Initialize s by A3,A4,A7,SFMASTR1:3;
 hence MI is_closed_on s by A1,SFMASTR2:4;
     MI is_halting_on Initialize s by A3,A4,A7,A8,SFMASTR1:4;
 hence MI is_halting_on s by A1,A9,SFMASTR2:5;
end;

begin :: Finding minimum in a section of an array

definition
 let start, finish, minpos be Int-Location, f be FinSeq-Location;
  set aux1 = 1-stRWNotIn {start, finish, minpos};
  set aux2 = 2-ndRWNotIn {start, finish, minpos};
  set cv = 3-rdRWNotIn {start, finish, minpos};
::  set aux1 = 1-stRWNotIn {start, finish, min_pos};
::  set aux2 = 2-ndRWNotIn {start, finish, min_pos};
::  set cv =   3-rdRWNotIn {start, finish, min_pos};
 func FinSeqMin(f, start, finish, minpos) -> Macro-Instruction equals

  minpos := start ';'
  for-up ( cv, start, finish,
           aux1 := (f, cv) ';'
           (aux2 := (f, minpos)) ';'
           if>0(aux2, aux1, Macro (minpos := cv), SCM+FSA-Stop)
         );
 coherence;
end;

registration
 let start, finish be Int-Location, minpos be read-write Int-Location,
     f be FinSeq-Location;
 cluster FinSeqMin(f, start, finish, minpos) -> good;
 coherence;
end;

theorem Th33:
 c <> aa implies FinSeqMin(f, aa, bb, c) does_not_destroy aa
proof assume
A1: c <> aa;
   set a = aa, b = bb;
  set aux1 = 1-stRWNotIn {a, b, c};
  set aux2 = 2-ndRWNotIn {a, b, c};
  set cv = 3-rdRWNotIn {a, b, c};
  set i0 = c := a;
  set i10 = aux1 := (f, cv);
  set i11 = aux2 := (f, c);
  set I12 = if>0(aux2, aux1, Macro (c := cv), SCM+FSA-Stop);
  set I1B = i10 ';' i11 ';' I12;
  set I1 = for-up ( cv, a, b, I1B);
A2: i0 does_not_destroy a by A1,SCMFSA7B:12;
A3:  a in {a, b, c} by ENUMSET1:def 1;
   then aux1 <> a by SFMASTR1:21;
then A4: i10 does_not_destroy a by SCMFSA7B:20;
A5: aux2 <> a by A3,SFMASTR1:21;
 then i11 does_not_destroy a by SCMFSA7B:20;
then A6: i10 ';' i11 does_not_destroy a by A4,SCMFSA8C:84;
      c := cv does_not_destroy a by A1,SCMFSA7B:12;
then A7: Macro (c := cv) does_not_destroy a by SCMFSA8C:77;
    SCM+FSA-Stop does_not_destroy a by SCMFSA8C:85;
   then I12 does_not_destroy a by A5,A7,Th15;
then A8: I1B does_not_destroy a by A6,SCMFSA8C:81;
      a in {cv, a, b} by ENUMSET1:def 1;
   then a in {cv, a, b} \/ UsedIntLoc I1B by XBOOLE_0:def 2;
then A9: a <> 1-stRWNotIn ({cv, a, b} \/ UsedIntLoc I1B) by SFMASTR1:21;
      cv <> a by A3,SFMASTR1:21;
   then I1 does_not_destroy a by A8,A9,Th29;
 hence FinSeqMin(f, a, b, c) does_not_destroy a by A2,SCMFSA8C:82;
end;

theorem Th34:
 {aa, bb, c} c= UsedIntLoc FinSeqMin(f, aa, bb, c)
proof
  set a = aa, b = bb;
  set aux1 = 1-stRWNotIn {a, b, c};
  set aux2 = 2-ndRWNotIn {a, b, c};
  set cv = 3-rdRWNotIn {a, b, c};
  set i0 = c := a;
  set i10 = aux1 := (f, cv);
  set i11 = aux2 := (f, c);
  set I12 = if>0(aux2, aux1, Macro (c := cv), SCM+FSA-Stop);
  set I1B = i10 ';' i11 ';' I12;
  set I1 = for-up ( cv, a, b, I1B);
A1: UsedIntLoc (i0 ';' I1)
 = (UsedIntLoc i0) \/ UsedIntLoc I1 by SF_MASTR:33;
A2: UsedIntLoc i0 = {c ,a} by SF_MASTR:18;
A3: {cv, a, b} \/ UsedIntLoc I1B c= UsedIntLoc I1 by Th28;
 let x be set;
 assume A4: x in {a, b, c};
 per cases by A4,ENUMSET1:def 1;
 suppose x = a; then x in {c, a} by TARSKI:def 2;
  hence x in UsedIntLoc FinSeqMin(f, aa, bb, c) by A1,A2,XBOOLE_0:def 2;
 end;
 suppose x = b; then x in {cv, a, b} by ENUMSET1:def 1;
   then x in {cv, a, b} \/ UsedIntLoc I1B by XBOOLE_0:def 2;
  hence x in UsedIntLoc FinSeqMin(f, aa, bb, c) by A1,A3,XBOOLE_0:def 2;
 end;
 suppose x = c; then x in {c, a} by TARSKI:def 2;
  hence x in UsedIntLoc FinSeqMin(f, aa, bb, c) by A1,A2,XBOOLE_0:def 2;
end;
end;

theorem Th35:
 s.intloc 0 = 1 implies
   FinSeqMin(f, aa, bb, c) is_closed_on s &
   FinSeqMin(f, aa, bb, c) is_halting_on s
proof assume
A1: s.intloc 0 = 1;
  set a = aa, b = bb;
  set aux1 = 1-stRWNotIn {a, b, c};
  set aux2 = 2-ndRWNotIn {a, b, c};
  set cv = 3-rdRWNotIn {a, b, c};
  set i0 = c := a;
  set i10 = aux1 := (f, cv);
  set i11 = aux2 := (f, c);
  set I12 = if>0(aux2, aux1, Macro (c := cv), SCM+FSA-Stop);
  set I1B = i10 ';' i11 ';' I12;
  set I1 = for-up ( cv, a, b, I1B);

A2: FinSeqMin(f, a, b, c)
   = i0 ';' I1
  .= Macro i0 ';' I1 by SCMFSA6A:def 5;

  set s1 = IExec(Macro i0, s);
    s1.intloc 0
     = Exec(i0, Initialize s).intloc 0 by SCMFSA6C:6
    .= (Initialize s). intloc 0 by SCMFSA_2:89
    .= 1 by SCMFSA6C:3;
then A3: I1 is_closed_on s1 & I1 is_halting_on s1 by Th32;
A4: Macro i0 is_closed_on Initialize s by SCMFSA7B:24;
A5: Macro i0 is_halting_on Initialize s by SCMFSA7B:25;
then A6: FinSeqMin(f, aa, bb, c) is_closed_on Initialize s
        by A2,A3,A4,SFMASTR1:3;
 hence FinSeqMin(f, aa, bb, c) is_closed_on s by A1,SFMASTR2:4;
       FinSeqMin(f, aa, bb, c) is_halting_on Initialize s
        by A2,A3,A4,A5,SFMASTR1:4;
 hence FinSeqMin(f, aa, bb, c) is_halting_on s by A1,A6,SFMASTR2:5;
end;

theorem Th36:
 aa <> c & bb <> c & s.intloc 0 = 1
  implies IExec(FinSeqMin(f, aa, bb, c), s).f = s.f &
          IExec(FinSeqMin(f, aa, bb, c), s).aa = s.aa &
          IExec(FinSeqMin(f, aa, bb, c), s).bb = s.bb
proof
set D = Int-Locations \/ FinSeq-Locations;
  assume that
A1: aa <> c and
A2: bb <> c and
A3: s.intloc 0 = 1;
  set a = aa, b = bb;
  set aux1 = 1-stRWNotIn {a, b, c};
  set aux2 = 2-ndRWNotIn {a, b, c};
  set cv = 3-rdRWNotIn {a, b, c};
  set i0 = c := a;
  set i10 = aux1 := (f, cv);
  set i11 = aux2 := (f, c);
  set I12 = if>0(aux2, aux1, Macro (c := cv), SCM+FSA-Stop);
  set I1B = i10 ';' i11 ';' I12;
  set I1 = for-up ( cv, a, b, I1B);

        c in {a, b, c} by ENUMSET1:def 1;
then A4: cv <> c by SFMASTR1:21;
A5: aux2 <> cv by SFMASTR1:22;
A6: aux1 <> cv by SFMASTR1:22;
A7:  a in {a, b, c} by ENUMSET1:def 1;
then A8: cv <> a by SFMASTR1:21;
A9: aux2 <> a by A7,SFMASTR1:21;
A10: aux1 <> a by A7,SFMASTR1:21;
A11:  b in {a, b, c} by ENUMSET1:def 1;
then A12: cv <> b by SFMASTR1:21;
A13: aux2 <> b by A11,SFMASTR1:21;
A14: aux1 <> b by A11,SFMASTR1:21;
        cv in {cv, a, b} by ENUMSET1:def 1;
then A15: cv in {cv, a, b} \/ UsedIntLoc I1B by XBOOLE_0:def 2;
        a in {cv, a, b} by ENUMSET1:def 1;
then A16: a in {cv, a, b} \/ UsedIntLoc I1B by XBOOLE_0:def 2;
        b in {cv, a, b} by ENUMSET1:def 1;
then A17: b in {cv, a, b} \/ UsedIntLoc I1B by XBOOLE_0:def 2;
  set s1 = Exec(i0, Initialize s);

A18: s1.intloc 0
     = (Initialize s). intloc 0 by SCMFSA_2:89
    .= 1 by SCMFSA6C:3;
A19: a = intloc 0 or a is read-write by SF_MASTR:def 5;
A20: s1.a = (Initialize s).a by A1,SCMFSA_2:89
         .= s.a by A3,A19,SCMFSA6C:3;
A21: b = intloc 0 or b is read-write by SF_MASTR:def 5;
A22: s1.b = (Initialize s).b by A2,SCMFSA_2:89
         .= s.b by A3,A21,SCMFSA6C:3;
A23: s1.f = (Initialize s).f by SCMFSA_2:89
         .= s.f by SCMFSA6C:3;

A24: I1 is_closed_on s1 & I1 is_halting_on s1 by A18,Th32;

 per cases;
 suppose A25: s.aa > s.bb;
       a in {a, b} by TARSKI:def 2;
 then A26: a in {a, b} \/ UsedIntLoc I1B by XBOOLE_0:def 2;
       b in {a, b} by TARSKI:def 2;
 then A27: b in {a, b} \/ UsedIntLoc I1B by XBOOLE_0:def 2;
  thus IExec(FinSeqMin(f, aa, bb, c), s).f
     = IExec(I1, s1).f by A24,SFMASTR1:16
    .= s.f by A18,A20,A22,A23,A25,Th30;
  thus IExec(FinSeqMin(f, aa, bb, c), s).aa
     = IExec(I1, s1).aa by A24,SFMASTR1:15
    .= s.aa by A8,A18,A20,A22,A25,A26,Th30;
  thus IExec(FinSeqMin(f, aa, bb, c), s).bb
     = IExec(I1, s1).bb by A24,SFMASTR1:15
    .= s.bb by A12,A18,A20,A22,A25,A27,Th30;
 end;
 suppose A28: s.aa <= s.bb;
  then A29: s.a-s.a <= s.b-s.a by XREAL_1:11;
then s.b-s.a <= s.b-s.a+1 & 0 <= s.b-s.a by XREAL_1:31;
  then reconsider k = s.b - s.a +1 as Nat by INT_1:16;
        0 < 1 & 0+1 <= s.b-s.a+1 by A29,XREAL_1:8;
then A30: 0 < k;
  set SF = StepForUp(cv, a, b, I1B, s1);

A31: ProperForUpBody cv, a, b, I1B, s1 by Th23;

  defpred P[Nat] means
   0 < $1 & $1 <= k implies
    SF.$1.intloc 0 = 1 &
    SF.$1.cv = $1+s1.a &
    SF.$1.f = s1.f &
    SF.$1.a = s1.a &
    SF.$1.b = s1.b;

A32: P[0];
A33: for n being Nat st P[n] holds P[n+1] proof let n be Nat such that
 A34:  P[n] and
 A35:  0 < n+1 & n+1 <= k;
         n < n+1 by XREAL_1:31;
 then A36: n < k by A35,XXREAL_0:2;
 A37: SF.n.intloc 0 = 1 & SF.n.cv = n+s1.a & SF.n.cv <= s1.b proof
      per cases;
      suppose A38: 0 = n;
       hence SF.n.intloc 0 = 1 by A18,Th16;
       thus SF.n.cv = n+s1.a by A38,Th17;
       thus SF.n.cv <= s1.b by A20,A22,A28,A38,Th17;
      end;
      suppose A39: 0 < n;
       hence SF.n.intloc 0 = 1 by A34,A35,NAT_1:38;
       thus SF.n.cv = n+s1.a by A34,A35,A39,NAT_1:38;
           n+1-1 <= s.b-s.a+1-1 by A35,XREAL_1:11;
       hence SF.n.cv <= s1.b by A20,A22,A34,A35,A39,NAT_1:38,XREAL_1:21;
     end;
     end;
 A40:  SF.(n+1) | (({cv, a, b} \/ UsedIntLoc I1B) \/ FinSeq-Locations)
    = IExec(I1B ';' AddTo(cv, intloc 0), SF.n)
       | (({cv, a, b} \/ UsedIntLoc I1B) \/ FinSeq-Locations)
          by A18,A20,A22,A31,A36,Th27;

   set S0 = Initialize (SF.n);
   set S1 = Exec(i10, S0);
   set S2 = Exec(i11, Exec(i10, S0));
   set ss = IExec(i10 ';' i11, SF.n);

          c := cv does_not_refer aux2 by A5,Th10;
 then A41: Macro (c := cv) does_not_refer aux2 by SCMFSA8C:80;
 A42: SCM+FSA-Stop does_not_refer aux2 by Th9;
 A43: IExec(i10 ';' i11, SF.n).intloc 0
      = S2.intloc 0 by SCMFSA6C:9
     .= S1.intloc 0 by SCMFSA_2:98
     .= S0.intloc 0 by SCMFSA_2:98
     .= 1 by SCMFSA6C:3;
 then A44: IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)) | D
        = IExec(i10 ';' i11, SF.n) | D by Th8;

 A45: SF.(n+1).cv
      = IExec(I1B ';' AddTo(cv, intloc 0), SF.n).cv by A15,A40,SFMASTR2:7
     .= Exec(AddTo(cv, intloc 0), IExec(I1B, SF.n)).cv by SFMASTR1:12
     .= IExec(I1B, SF.n).cv+IExec(I1B, SF.n).intloc 0 by SCMFSA_2:90
     .= IExec(I1B, SF.n).cv+1 by SCMFSA6B:35
     .= IExec(I12, IExec(i10 ';' i11, SF.n)).cv+1 by SFMASTR1:8;
 A46: IExec(i10 ';' i11, SF.n).cv
      = S2.cv by SCMFSA6C:9
     .= S1.cv by A5,SCMFSA_2:98
     .= S0.cv by A6,SCMFSA_2:98;
 A47: SF.(n+1).a
      = IExec(I1B ';' AddTo(cv, intloc 0), SF.n).a by A16,A40,SFMASTR2:7
     .= Exec(AddTo(cv, intloc 0), IExec(I1B, SF.n)).a by SFMASTR1:12
     .= IExec(I1B, SF.n).a by A8,SCMFSA_2:90
     .= IExec(I12, IExec(i10 ';' i11, SF.n)).a by SFMASTR1:8;
 A48: IExec(i10 ';' i11, SF.n).a
      = S2.a by SCMFSA6C:9
     .= S1.a by A9,SCMFSA_2:98
     .= S0.a by A10,SCMFSA_2:98;
 A49: SF.(n+1).b
      = IExec(I1B ';' AddTo(cv, intloc 0), SF.n).b by A17,A40,SFMASTR2:7
     .= Exec(AddTo(cv, intloc 0), IExec(I1B, SF.n)).b by SFMASTR1:12
     .= IExec(I1B, SF.n).b by A12,SCMFSA_2:90
     .= IExec(I12, IExec(i10 ';' i11, SF.n)).b by SFMASTR1:8;
 A50: IExec(i10 ';' i11, SF.n).b
      = S2.b by SCMFSA6C:9
     .= S1.b by A13,SCMFSA_2:98
     .= S0.b by A14,SCMFSA_2:98;
 A51: SF.(n+1).f
      = IExec(I1B ';' AddTo(cv, intloc 0), SF.n).f by A40,SFMASTR2:7
     .= Exec(AddTo(cv, intloc 0), IExec(I1B, SF.n)).f by SFMASTR1:13
     .= IExec(I1B, SF.n).f by SCMFSA_2:90
     .= IExec(I12, IExec(i10 ';' i11, SF.n)).f by SFMASTR1:9;
 A52: IExec(i10 ';' i11, SF.n).f
      = S2.f by SCMFSA6C:10
     .= S1.f by SCMFSA_2:98
     .= S0.f by SCMFSA_2:98;

     per cases;
     suppose A53: 0 = n;
      thus thesis proof

   A54: S0.f = SF.0.f by A53,SCMFSA6C:3
            .= s.f by A23,Th21;
   A55: S0.cv = SF.0.cv by A53,SCMFSA6C:3
              .= s.a by A20,Th17;
   A56: S0.a = SF.0.a by A19,A37,A53,SCMFSA6C:3
            .= s1.a by A8,Th18;
   A57: S0.b = SF.0.b by A21,A37,A53,SCMFSA6C:3
            .= s1.b by A12,Th19;
    thus SF.(n+1).intloc 0 = 1 by A18,A20,A22,A31,A35,Th25;
    thus thesis proof
    per cases;
    suppose A58: ss.aux2 <= ss.aux1;
    hence SF.(n+1).cv
      = IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)).cv+1
                 by A5,A41,A42,A45,SCMFSA8B:43
     .= (n+1)+s1.a by A20,A44,A46,A53,A55,SCMFSA6A:38;
    thus SF.(n+1).f
      = IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)).f
                 by A41,A42,A51,A58,SCMFSA8B:43
     .= s1.f by A23,A44,A52,A54,SCMFSA6A:38;
    thus SF.(n+1).a
      = IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)).a
                 by A9,A41,A42,A47,A58,SCMFSA8B:43
     .= s1.a by A44,A48,A56,SCMFSA6A:38;
    thus SF.(n+1).b
      = IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)).b
                 by A13,A41,A42,A49,A58,SCMFSA8B:43
     .= s1.b by A44,A50,A57,SCMFSA6A:38;
    end;
    suppose A59: ss.aux2 > ss.aux1;
    hence SF.(n+1).cv
      = IExec(Macro (c := cv), IExec(i10 ';' i11, SF.n)).cv+1
                 by A5,A41,A42,A45,SCMFSA8B:43
     .= Exec(c := cv, Initialize IExec(i10 ';' i11, SF.n)).cv+1
                 by SCMFSA6C:6
     .= (Initialize IExec(i10 ';' i11, SF.n)).cv+1 by A4,SCMFSA_2:89
      .= (n+1)+s1.a by A20,A46,A53,A55,SCMFSA6C:3;
    thus SF.(n+1).f
      = IExec(Macro(c := cv), IExec(i10 ';' i11, SF.n)).f
                 by A41,A42,A51,A59,SCMFSA8B:43
     .= Exec(c := cv, Initialize IExec(i10 ';' i11, SF.n)).f
                 by SCMFSA6C:6
     .= (Initialize IExec(i10 ';' i11, SF.n)).f by SCMFSA_2:89
     .= s1.f by A23,A52,A54,SCMFSA6C:3;
    thus SF.(n+1).a
      = IExec(Macro (c := cv), IExec(i10 ';' i11, SF.n)).a
                 by A9,A41,A42,A47,A59,SCMFSA8B:43
     .= Exec(c := cv, Initialize IExec(i10 ';' i11, SF.n)).a
                 by SCMFSA6C:6
     .= (Initialize IExec(i10 ';' i11, SF.n)).a by A1,SCMFSA_2:89
     .= s1.a by A19,A43,A48,A56,SCMFSA6C:3;
    thus SF.(n+1).b
      = IExec(Macro (c := cv), IExec(i10 ';' i11, SF.n)).b
                 by A13,A41,A42,A49,A59,SCMFSA8B:43
     .= Exec(c := cv, Initialize IExec(i10 ';' i11, SF.n)).b
                 by SCMFSA6C:6
     .= (Initialize IExec(i10 ';' i11, SF.n)).b by A2,SCMFSA_2:89
     .= s1.b by A21,A43,A50,A57,SCMFSA6C:3;
     end;
     end;
     end;
     end;
     suppose A60: 0 < n;
      thus thesis proof

   A61: S0.f = s.f by A23,A34,A35,A60,NAT_1:38,SCMFSA6C:3;
   A62: S0.cv = SF.n.cv by SCMFSA6C:3;
   A63: S0.a = s1.a by A19,A34,A35,A60,NAT_1:38,SCMFSA6C:3;
   A64: S0.b = s1.b by A21,A34,A35,A60,NAT_1:38,SCMFSA6C:3;
      thus SF.(n+1).intloc 0 = 1 by A18,A20,A22,A31,A35,Th25;
      thus thesis proof
       per cases;
    suppose A65: ss.aux2 <= ss.aux1;
    hence SF.(n+1).cv
      = IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)).cv+1
                 by A5,A41,A42,A45,SCMFSA8B:43
     .= IExec(i10 ';' i11, SF.n).cv+1 by A44,SCMFSA6A:38
     .= (n+1)+s1.a by A37,A46,A62;
    thus SF.(n+1).f
      = IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)).f
                 by A41,A42,A51,A65,SCMFSA8B:43
     .= s1.f by A23,A44,A52,A61,SCMFSA6A:38;
    thus SF.(n+1).a
      = IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)).a
                 by A9,A41,A42,A47,A65,SCMFSA8B:43
     .= s1.a by A44,A48,A63,SCMFSA6A:38;
    thus SF.(n+1).b
      = IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)).b
                 by A13,A41,A42,A49,A65,SCMFSA8B:43
     .= s1.b by A44,A50,A64,SCMFSA6A:38;
    end;
    suppose A66: ss.aux2 > ss.aux1;
    hence SF.(n+1).cv
      = IExec(Macro (c := cv), IExec(i10 ';' i11, SF.n)).cv+1
                 by A5,A41,A42,A45,SCMFSA8B:43
     .= Exec(c := cv, Initialize IExec(i10 ';' i11, SF.n)).cv+1
                 by SCMFSA6C:6
     .= (Initialize IExec(i10 ';' i11, SF.n)).cv+1 by A4,SCMFSA_2:89
      .= IExec(i10 ';' i11, SF.n).cv+1 by SCMFSA6C:3
     .= (n+1)+s1.a by A37,A46,A62;
    thus SF.(n+1).f
      = IExec(Macro(c := cv), IExec(i10 ';' i11, SF.n)).f
                 by A41,A42,A51,A66,SCMFSA8B:43
     .= Exec(c := cv, Initialize IExec(i10 ';' i11, SF.n)).f
                 by SCMFSA6C:6
     .= (Initialize IExec(i10 ';' i11, SF.n)).f by SCMFSA_2:89
     .= s1.f by A23,A52,A61,SCMFSA6C:3;
    thus SF.(n+1).a
      = IExec(Macro (c := cv), IExec(i10 ';' i11, SF.n)).a
                 by A9,A41,A42,A47,A66,SCMFSA8B:43
     .= Exec(c := cv, Initialize IExec(i10 ';' i11, SF.n)).a
                 by SCMFSA6C:6
     .= (Initialize IExec(i10 ';' i11, SF.n)).a by A1,SCMFSA_2:89
     .= s1.a by A19,A43,A48,A63,SCMFSA6C:3;
    thus SF.(n+1).b
      = IExec(Macro (c := cv), IExec(i10 ';' i11, SF.n)).b
                 by A13,A41,A42,A49,A66,SCMFSA8B:43
     .= Exec(c := cv, Initialize IExec(i10 ';' i11, SF.n)).b
                 by SCMFSA6C:6
     .= (Initialize IExec(i10 ';' i11, SF.n)).b by A2,SCMFSA_2:89
     .= s1.b by A21,A43,A50,A64,SCMFSA6C:3;
      end;
      end;
     end;
    end;
    end;
A67: for n being Nat holds P[n] from NAT_1:sch 1(A32, A33);

A68: IExec(I1, s1) | D = SF.k | D by A18,A20,A22,Th31;

  thus IExec(FinSeqMin(f, aa, bb, c), s).f
     = IExec(I1, s1).f by A24,SFMASTR1:16
    .= SF.k.f by A68,SCMFSA6A:38
    .= s.f by A23,A30,A67;
  thus IExec(FinSeqMin(f, aa, bb, c), s).aa
     = IExec(I1, s1).a by A24,SFMASTR1:15
    .= SF.k.a by A68,SCMFSA6A:38
    .= s.aa by A20,A30,A67;
  thus IExec(FinSeqMin(f, aa, bb, c), s).bb
     = IExec(I1, s1).b by A24,SFMASTR1:15
    .= SF.k.b by A68,SCMFSA6A:38
    .= s.bb by A22,A30,A67;
end;
end;

theorem Th37:
 1 <= s.aa & s.aa <= s.bb & s.bb <= len (s.f) & aa <> c & bb <> c &
 s.intloc 0 = 1
  implies IExec(FinSeqMin(f, aa, bb, c), s).c
        = min_at(s.f, abs(s.aa), abs(s.bb))
proof
set D = Int-Locations \/ FinSeq-Locations;
set a = aa, b = bb; assume that
A1: 1 <= s.a and
A2: s.a <= s.b and
A3: s.b <= len (s.f) and
A4: a <> c and
A5: b <> c and
A6: s.intloc 0 = 1;
A7: s.a <= len (s.f) by A2,A3,XXREAL_0:2;
A8: 0 <= s.a by A1;
     reconsider sa = abs(s.a) as Nat;
A9: s.a = sa by A8,ABSVALUE:def 1;
     reconsider sb = abs(s.b) as Nat;
A10: sa in dom (s.f) by A1,A7,A9,FINSEQ_3:27;
  set aux1 = 1-stRWNotIn {a, b, c};
  set aux2 = 2-ndRWNotIn {a, b, c};
  set cv = 3-rdRWNotIn {a, b, c};
A11:  c in {a, b, c} by ENUMSET1:def 1;
then A12: cv <> c by SFMASTR1:21;
A13: aux1 <> aux2 by SFMASTR1:22;
A14: aux2 <> c by A11,SFMASTR1:21;
A15: aux1 <> c by A11,SFMASTR1:21;
A16: aux2 <> cv by SFMASTR1:22;
A17: aux1 <> cv by SFMASTR1:22;
  set i0 = c := a;
  set i10 = aux1 := (f, cv);
  set i11 = aux2 := (f, c);
  set I12 = if>0(aux2, aux1, Macro (c := cv), SCM+FSA-Stop);
  set I1B = i10 ';' i11 ';' I12;
  set I1 = for-up ( cv, a, b, I1B);
     c in {c, cv} by TARSKI:def 2;
  then c in UsedIntLoc (c := cv) by SF_MASTR:18;
  then c in UsedIntLoc Macro (c := cv) by SF_MASTR:32;
  then c in {aux2, aux1} \/ (UsedIntLoc Macro (c := cv)) by XBOOLE_0:def 2;
  then c in {aux2, aux1} \/ (UsedIntLoc Macro (c := cv)) \/ UsedIntLoc
SCM+FSA-Stop
         by XBOOLE_0:def 2;
  then c in UsedIntLoc I12 by Th13;
     then c in (UsedIntLoc (i10 ';' i11)) \/ UsedIntLoc I12 by XBOOLE_0:def 2;
  then A18: c in UsedIntLoc I1B by SF_MASTR:31;
then A19: c in {cv, a, b} \/ (UsedIntLoc I1B) by XBOOLE_0:def 2;
       cv in {cv, a, b} by ENUMSET1:def 1;
then A20: cv in {cv, a, b} \/ (UsedIntLoc I1B) by XBOOLE_0:def 2;
  set s1 = Exec(i0, Initialize s);

A21: s1.intloc 0
     = (Initialize s). intloc 0 by SCMFSA_2:89
    .= 1 by SCMFSA6C:3;
A22: a = intloc 0 or a is read-write by SF_MASTR:def 5;
A23: s1.a = (Initialize s).a by A4,SCMFSA_2:89
         .= s.a by A6,A22,SCMFSA6C:3;
A24: b = intloc 0 or b is read-write by SF_MASTR:def 5;
A25: s1.b = (Initialize s).b by A5,SCMFSA_2:89
         .= s.b by A6,A24,SCMFSA6C:3;
A26: s1.c = (Initialize s).a by SCMFSA_2:89
         .= s.a by A6,A22,SCMFSA6C:3;
A27: s1.f = (Initialize s).f by SCMFSA_2:89
         .= s.f by SCMFSA6C:3;

      s.a-s.a <= s.b-s.a by A2,XREAL_1:11;
   then reconsider sba = s.b-s.a as Nat by INT_1:16;
   set k = sba+1;

  set SF = StepForUp(cv, a, b, I1B, s1);

A28: ProperForUpBody cv, a, b, I1B, s1 by Th23;
  defpred P[Nat] means
   0 < $1 & $1 <= k implies
    SF.$1.intloc 0 = 1 &
    SF.$1.cv = $1+s1.a &
    SF.$1.f = s1.f &
    ex sa1 being Nat st sa1 = $1+sa-1 & SF.$1.c = min_at(s.f, sa, sa1);

A29: P[0];

A30: for n being Nat st P[n] holds P[n+1] proof let n be Nat such that
 A31:  P[n] and
 A32:  0 < n+1 & n+1 <= k;
         n < n+1 by XREAL_1:31;
 then A33: n < k by A32,XXREAL_0:2;

 A34: SF.n.intloc 0 = 1 & SF.n.cv = n+s1.a & SF.n.cv <= s1.b proof
      per cases;
      suppose A35: 0 = n;
       hence SF.n.intloc 0 = 1 by A21,Th16;
       thus SF.n.cv = n+s1.a by A35,Th17;
       thus SF.n.cv <= s1.b by A2,A23,A25,A35,Th17;
      end;
      suppose A36: 0 < n;
       hence SF.n.intloc 0 = 1 by A31,A32,NAT_1:38;
       thus SF.n.cv = n+s1.a by A31,A32,A36,NAT_1:38;
           n+1-1 <= s.b-s.a+1-1 by A32,XREAL_1:11;
       hence SF.n.cv <= s1.b by A23,A25,A31,A36,NAT_1:38,XREAL_1:21;
     end;
     end;
 A37:  SF.(n+1) | ({cv, a, b} \/ (UsedIntLoc I1B) \/ FinSeq-Locations)
      = IExec(I1B ';' AddTo(cv, intloc 0), SF.n)
         | ({cv, a, b} \/ (UsedIntLoc I1B) \/ FinSeq-Locations)
              by A21,A23,A25,A28,A33,Th27;

   set S0 = Initialize (SF.n);
   set S1 = Exec(i10, S0);
   set S2 = Exec(i11, Exec(i10, S0));

          c := cv does_not_refer aux2 by A16,Th10;
 then A38: Macro (c := cv) does_not_refer aux2 by SCMFSA8C:80;
 A39: SCM+FSA-Stop does_not_refer aux2 by Th9;
        IExec(i10 ';' i11, SF.n).intloc 0
      = S2.intloc 0 by SCMFSA6C:9
     .= S1.intloc 0 by SCMFSA_2:98
     .= S0.intloc 0 by SCMFSA_2:98
     .= 1 by SCMFSA6C:3;
 then A40: IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)) | D
        = IExec(i10 ';' i11, SF.n) | D by Th8;

 A41: SF.(n+1).c
      = IExec(I1B ';' AddTo(cv, intloc 0), SF.n).c by A19,A37,SFMASTR2:7
     .= Exec(AddTo(cv, intloc 0), IExec(I1B, SF.n)).c by SFMASTR1:12
     .= IExec(I1B, SF.n).c by A12,SCMFSA_2:90
     .= IExec(I12, IExec(i10 ';' i11, SF.n)).c by SFMASTR1:8;
 A42: IExec(i10 ';' i11, SF.n).c
      = S2.c by SCMFSA6C:9
     .= S1.c by A14,SCMFSA_2:98
     .= S0.c by A15,SCMFSA_2:98
     .= SF.n.c by SCMFSA6C:3;
 A43: SF.(n+1).cv
      = IExec(I1B ';' AddTo(cv, intloc 0), SF.n).cv by A20,A37,SFMASTR2:7
     .= Exec(AddTo(cv, intloc 0), IExec(I1B, SF.n)).cv by SFMASTR1:12
     .= IExec(I1B, SF.n).cv+IExec(I1B, SF.n).intloc 0 by SCMFSA_2:90
     .= IExec(I1B, SF.n).cv+1 by SCMFSA6B:35
     .= IExec(I12, IExec(i10 ';' i11, SF.n)).cv+1 by SFMASTR1:8;
 A44: IExec(i10 ';' i11, SF.n).cv
      = S2.cv by SCMFSA6C:9
     .= S1.cv by A16,SCMFSA_2:98
     .= S0.cv by A17,SCMFSA_2:98;
 A45: SF.(n+1).f
      = IExec(I1B ';' AddTo(cv, intloc 0), SF.n).f by A37,SFMASTR2:7
     .= Exec(AddTo(cv, intloc 0), IExec(I1B, SF.n)).f by SFMASTR1:13
     .= IExec(I1B, SF.n).f by SCMFSA_2:90
     .= IExec(I12, IExec(i10 ';' i11, SF.n)).f by SFMASTR1:9;
 A46: IExec(i10 ';' i11, SF.n).f
      = S2.f by SCMFSA6C:10
     .= S1.f by SCMFSA_2:98
     .= S0.f by SCMFSA_2:98;

     per cases;
     suppose A47: 0 = n;
      thus thesis proof

   A48: S0.f = SF.0.f by A47,SCMFSA6C:3
            .= s.f by A27,Th21;
   A49: S0.cv = SF.0.cv by A47,SCMFSA6C:3
              .= s.a by A23,Th17;
   A50: S1.f = s.f by A48,SCMFSA_2:98;
   A51: SF.0.c = s1.c by A12,A18,Th20;
   A52: S1.c = S0.c by A15,SCMFSA_2:98
            .= s.a by A26,A47,A51,SCMFSA6C:3;
       0 <= S0.cv by A1,A49;
   then reconsider S0cv = S0.cv as Nat by INT_1:16;

   A53: IExec(i10 ';' i11, SF.n).aux1
      = S2.aux1 by SCMFSA6C:9
     .= S1.aux1 by A13,SCMFSA_2:98
     .= (S0.f)/.abs(S0.cv) by Th11
     .= s.f.S0cv by A9,A10,A48,A49,FINSEQ_4:def 4;

   A54: IExec(i10 ';' i11, SF.n).aux2
      = S2.aux2 by SCMFSA6C:9
     .= (S1.f)/.abs(S1.c) by Th11
     .= s.f.S0cv by A9,A10,A49,A50,A52,FINSEQ_4:def 4;

    thus SF.(n+1).intloc 0 = 1 by A21,A23,A25,A28,A32,Th25;
    thus SF.(n+1).cv
      = IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)).cv+1
                 by A16,A38,A39,A43,A53,A54,SCMFSA8B:43
     .= (n+1)+s1.a by A23,A40,A44,A47,A49,SCMFSA6A:38;
    thus SF.(n+1).f
      = IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)).f
                 by A38,A39,A45,A53,A54,SCMFSA8B:43
     .= s1.f by A27,A40,A46,A48,SCMFSA6A:38;

   A55: SF.(n+1).c
      = IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)).c
          by A14,A38,A39,A41,A53,A54,SCMFSA8B:43
     .= s.a by A26,A40,A42,A47,A51,SCMFSA6A:38;
       reconsider sa1 = (n+1)+sa-1 as Nat by A47;
      take sa1;
      thus sa1 = (n+1)+sa-1;
      thus SF.(n+1).c = min_at(s.f, sa, sa1) by A1,A7,A9,A47,A55,Th4;
     end;
     end;
     suppose A56: 0 < n;
      thus thesis proof

   A57: S0.f = s.f by A27,A31,A32,A56,NAT_1:38,SCMFSA6C:3;
   A58: S0.cv = SF.n.cv by SCMFSA6C:3;
   A59: S1.f = s.f by A57,SCMFSA_2:98;

    0 <= S0.cv by A9,A23,A34,A58,NAT_1:37;
   then reconsider S0cv = S0.cv as Nat by INT_1:16;

   A60: 1 <= S0cv by A1,A9,A23,A34,A58,NAT_1:37;
            S0cv <= len (s.f) by A3,A25,A34,A58,XXREAL_0:2;
   then A61: S0cv in dom (s.f) by A60,FINSEQ_3:27;

   A62: IExec(i10 ';' i11, SF.n).aux1
      = S2.aux1 by SCMFSA6C:9
     .= S1.aux1 by A13,SCMFSA_2:98
     .= (S0.f)/.abs(S0.cv) by Th11
     .= (S0.f)/.S0cv by ABSVALUE:def 1
     .= s.f.S0cv by A57,A61,FINSEQ_4:def 4;
     consider sa1 being Nat such that
A63: sa1 = n+sa-1 & SF.n.c = min_at(s.f, sa, sa1) by A31,A32,A56,NAT_1:38;
        reconsider SFnc = SF.n.c as Nat by A63;
           0+1 <= n by A56,NAT_1:38;
        then 1-1 <= n-1 by XREAL_1:11;
        then A64: 0+s.a <= n-1+s.a by XREAL_1:8;
   then A65: s.a <= n+s.a-1;
           n+s.a <= len (s.f) by A3,A23,A25,A34,XXREAL_0:2;
        then 0 <= 1 & n+s.a-1 <= len (s.f)-1 by XREAL_1:11;
        then A66: n+s.a-1+0 <= len (s.f)-1+1 by XREAL_1:9;

   then A67: sa <= SFnc & SFnc <= sa1 by A1,A9,A63,A64,Th3;
   A68:  for i st sa <= i & i < SF.n.c holds s.f.i > s.f.(SFnc)
          by A1,A9,A63,A64,A66,Th3;
         1 <= SFnc & SFnc <= len (s.f) by A1,A9,A63,A66,A67,XXREAL_0:2;
   then A69: SFnc in dom (s.f) by FINSEQ_3:27;
   A70: IExec(i10 ';' i11, SF.n).aux2
      = S2.aux2 by SCMFSA6C:9
     .= (S1.f)/.abs(S1.c) by Th11
     .= (S1.f)/.abs(S0.c) by A15,SCMFSA_2:98
     .= (S1.f)/.abs(SF.n.c) by SCMFSA6C:3
     .= (S1.f)/.SFnc by ABSVALUE:def 1
     .= s.f.SFnc by A59,A69,FINSEQ_4:def 4;

      thus SF.(n+1).intloc 0 = 1 by A21,A23,A25,A28,A32,Th25;
      thus thesis proof
       A71: (n+1)+s.a-1 = n+s.a+1-1 .= n+sa by A8,ABSVALUE:def 1;
       then A72: s.a <= (n+1)+s.a-1 by NAT_1:37;
A73:    (n+1)+s.a-1 <= len (s.f) by A3,A23,A25,A34,XXREAL_0:2;

       per cases;
       suppose A74: s.f.S0cv < s.f.SFnc;
       hence SF.(n+1).cv
             = IExec(Macro (c := cv), IExec(i10 ';' i11, SF.n)).cv+1
                 by A16,A38,A39,A43,A62,A70,SCMFSA8B:43
            .= Exec(c := cv, Initialize IExec(i10 ';' i11, SF.n)).cv+1
                 by SCMFSA6C:6
            .= (Initialize IExec(i10 ';' i11, SF.n)).cv+1 by A12,SCMFSA_2:89
            .= IExec(i10 ';' i11, SF.n).cv+1 by SCMFSA6C:3
            .= (n+1)+s1.a by A34,A44,A58;
       thus SF.(n+1).f
             = IExec(Macro (c := cv), IExec(i10 ';' i11, SF.n)).f
                 by A38,A39,A45,A62,A70,A74,SCMFSA8B:43
            .= Exec(c := cv, Initialize IExec(i10 ';' i11, SF.n)).f
                 by SCMFSA6C:6
            .= (Initialize IExec(i10 ';' i11, SF.n)).f by SCMFSA_2:89
            .= s1.f by A27,A46,A57,SCMFSA6C:3;
       A75: SF.(n+1).c
             = IExec(Macro (c := cv), IExec(i10 ';' i11, SF.n)).c
                 by A14,A38,A39,A41,A62,A70,A74,SCMFSA8B:43
            .= Exec(c := cv, Initialize IExec(i10 ';' i11, SF.n)).c
                 by SCMFSA6C:6
            .= (Initialize IExec(i10 ';' i11, SF.n)).cv by SCMFSA_2:89
            .= S0cv by A44,SCMFSA6C:3;
       A76: for i st s.a <= i & i <= (n+1)+s.a-1
              holds s.f.S0cv <= s.f.i proof
             let i such that
          A77: s.a <= i & i <= (n+1)+s.a-1;
             per cases by A77,REAL_1:def 5;
             suppose i < (n+1)+s.a-1;
               then i+1 <= n+s.a by A71,NAT_1:38;
               then i+1-1 <= n+s.a-1 by XREAL_1:11;
               then s.f.(SFnc) <= s.f.i by A1,A9,A63,A64,A66,A77,Th3;
              hence s.f.S0cv <= s.f.i by A74,XXREAL_0:2;
             end;
             suppose i = (n+1)+s.a-1;
              hence s.f.S0cv <= s.f.i by A23,A34,A58;
            end;
            end;
       A78: for i st s.a <= i & i < S0cv holds s.f.i > s.f.S0cv proof
             let i; assume
          A79: s.a <= i & i < S0cv;
              then i+1 <= S0cv by NAT_1:38;
              then i+1-1 <= S0cv-1 by XREAL_1:11;
              then s.f.SFnc <= s.f.i by A1,A9,A23,A34,A58,A63,A65,A66,A79,Th3;
             hence s.f.i > s.f.S0cv by A74,XXREAL_0:2;
            end;

         reconsider sa11 = (n+1)+sa-1 as Nat by A71;
         take sa11;
         thus sa11 = (n+1)+sa-1;
         thus SF.(n+1).c = min_at(s.f, sa, sa11)
                 by A1,A9,A23,A34,A58,A72,A73,A75,A76,A78,Th3;
       end;
       suppose A80: s.f.SFnc <= s.f.S0cv;
        thus thesis proof
       thus SF.(n+1).cv
             = IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)).cv+1
                 by A16,A38,A39,A43,A62,A70,A80,SCMFSA8B:43
            .= IExec(i10 ';' i11, SF.n).cv+1 by A40,SCMFSA6A:38
            .= (n+1)+s1.a by A34,A44,A58;
       thus SF.(n+1).f
             = IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)).f
                 by A38,A39,A45,A62,A70,A80,SCMFSA8B:43
            .= s1.f by A27,A40,A46,A57,SCMFSA6A:38;
       A81: SF.(n+1).c
             = IExec(SCM+FSA-Stop, IExec(i10 ';' i11, SF.n)).c
                 by A14,A38,A39,A41,A62,A70,A80,SCMFSA8B:43
            .= SF.n.c by A40,A42,SCMFSA6A:38;
               n+s.a-1 <= n+s.a-1+1 by XREAL_1:31;
       then A82: s.a <= SFnc & SFnc <= (n+1)+s.a-1 by A9,A63,A67,XXREAL_0:2;
       A83: for i st s.a <= i & i <= (n+1)+s.a-1
              holds s.f.(SFnc) <= s.f.i proof
             let i such that
         A84: s.a <= i & i <= (n+1)+s.a-1;
             per cases by A84,REAL_1:def 5;
             suppose i < (n+1)+s.a-1;
               then i+1 <= n+s.a by A71,NAT_1:38;
               then i+1-1 <= n+s.a-1 by XREAL_1:11;
              hence s.f.(SFnc) <= s.f.i by A1,A9,A63,A64,A66,A84,Th3;
             end;
             suppose i = (n+1)+s.a-1;
              hence s.f.(SFnc) <= s.f.i by A23,A34,A58,A80;
            end;
            end;
        reconsider sa11 = (n+1)+sa-1 as Nat by A71;
        take sa11;
        thus sa11 = (n+1)+sa-1;
        thus SF.(n+1).c = min_at(s.f, sa, sa11)
          by A1,A9,A68,A72,A73,A81,A82,A83,Th3;
       end;
      end;
      end;
     end;
    end;
    end;

A85: for n being Nat holds P[n] from NAT_1:sch 1(A29, A30);

A86: IExec(I1, s1) | D = SF.k | D by A21,A23,A25,Th31;

   consider sab being Nat such that
A87: sab = k+sa-1 & SF.k.c = min_at(s.f, sa, sab) by A85;
A88: sab = sb by A9,A87,ABSVALUE:def 1;
    I1 is_closed_on s1 & I1 is_halting_on s1 by A21,Th32;
 hence IExec(FinSeqMin(f, a, b, c), s).c
    = IExec(I1, s1).c by SFMASTR1:15
   .= min_at(s.f, abs(s.a), abs(s.b)) by A86,A87,A88,SCMFSA6A:38;
end;

begin :: A swap macro instruction

definition
 let f be FinSeq-Location, a, b be Int-Location;
  set aux1 = 1-stRWNotIn {a, b};
  set aux2 = 2-ndRWNotIn {a, b};
::  set aux1 = 1-stRWNotIn {a, b};
::  set aux2 = 2-ndRWNotIn {a, b};
 func swap(f, a, b) -> Macro-Instruction equals

  aux1 := (f,a) ';' (aux2 := (f,b)) ';' ((f,a) := aux2) ';' ((f,b) := aux1);
 coherence;
end;

registration
 let f be FinSeq-Location, a, b be Int-Location;
  cluster swap(f, a, b) -> good parahalting;
 coherence;
end;

theorem Th38:
 cc <> 1-stRWNotIn {aa, bb} & cc <> 2-ndRWNotIn {aa, bb}
  implies swap(f, aa, bb) does_not_destroy cc
proof assume that
A1: cc <> 1-stRWNotIn {aa, bb} and
A2: cc <> 2-ndRWNotIn {aa, bb};
  set a = aa, b = bb;
  set aux1 = 1-stRWNotIn {a, b};
  set aux2 = 2-ndRWNotIn {a, b};
A3: aux1 := (f,a) does_not_destroy cc by A1,SCMFSA7B:20;
A4: aux2 := (f,b) does_not_destroy cc by A2,SCMFSA7B:20;
A5: (f,a) := aux2 does_not_destroy cc by SCMFSA7B:21;
A6: (f,b) := aux1 does_not_destroy cc by SCMFSA7B:21;
      aux1 := (f,a) ';' (aux2 := (f,b)) does_not_destroy cc by A3,A4,
SCMFSA8C:84;
    then aux1 := (f,a) ';' (aux2 := (f,b)) ';' ((f,a) := aux2)
does_not_destroy cc
         by A5,SCMFSA8C:83;
 hence swap(f, aa, bb) does_not_destroy cc by A6,SCMFSA8C:83;
end;

theorem Th39:
 1 <= s.aa & s.aa <= len (s.f) & 1 <= s.bb & s.bb <= len (s.f) &
 s.intloc 0 = 1
 implies IExec(swap(f, aa, bb), s).f
       = s.f+*(s.aa, s.f.(s.bb))+*(s.bb, s.f.(s.aa))
proof set a = aa, b = bb; assume that
A1: 1 <= s.a & s.a <= len (s.f) & 1 <= s.b & s.b <= len (s.f) and
A2: s.intloc 0 = 1;
  set aux1 = 1-stRWNotIn {a, b}, aux2 = 2-ndRWNotIn {a, b};
  set i0 = aux1 := (f,a), i1 = aux2 := (f,b), i2 = (f,a) := aux2;
  set i3 = (f,b) := aux1;
  set s0 = Initialize s, s1 = Exec(i0, s0), s2 = IExec(i0 ';' i1, s);
  set s3 = IExec(i0 ';' i1 ';' i2, s);
  set s0a = abs(s0.a), s2a = abs(s2.a);
  set s1b = abs(s1.b);
 0 < s.a by A1; then reconsider sa = s.a as Nat by INT_1:16;
A3: sa = abs(s.a) by ABSVALUE:def 1;
 0 < s.b by A1; then reconsider sb = s.b as Nat by INT_1:16;
A4: sb = abs(s.b) by ABSVALUE:def 1;
A5: s0.f = s.f by SCMFSA6C:3;
A6: s1.f = s0.f by SCMFSA_2:98 .= s.f by SCMFSA6C:3;
A7: s2.f = Exec(i1, s1).f by SCMFSA6C:10
   .= s1.f by SCMFSA_2:98;
A8: s3.f = Exec(i2, s2).f by SCMFSA6C:8
   .= s2.f+*(s2a, s2.aux2) by Th12;
A9:   a in {a, b} & b in {a, b} by TARSKI:def 2;
then A10: a <> aux2 by SFMASTR1:21;
A11: a <> aux1 by A9,SFMASTR1:21;
A12: b <> aux2 by A9,SFMASTR1:21;
A13: b <> aux1 by A9,SFMASTR1:21;
A14: a = intloc 0 or a is read-write by SF_MASTR:def 5;
then A15: sa = s0a by A2,A3,SCMFSA6C:3;
         s2.a = Exec(i1, s1).a by SCMFSA6C:9 .= s1.a by A10,SCMFSA_2:98
      .= s0.a by A11,SCMFSA_2:98;
then A16: sa = s2a by A2,A3,A14,SCMFSA6C:3;
A17:   b = intloc 0 or b is read-write by SF_MASTR:def 5;
A18: s1.b = s0.b by A13,SCMFSA_2:98
       .= s.b by A2,A17,SCMFSA6C:3;
      A19: s3.b = Exec(i2, s2).b by SCMFSA6C:7 .= s2.b by SCMFSA_2:99
   .= Exec(i1, s1).b by SCMFSA6C:9 .= s1.b by A12,SCMFSA_2:98;
A20: s2.aux2 = Exec(i1, s1).aux2 by SCMFSA6C:9
      .= (s1.f)/.s1b by Th11
      .= s.f.sb by A1,A4,A6,A18,FINSEQ_4:24;
A21: aux1 <> aux2 by SFMASTR1:22;
A22: s3.aux1 = Exec(i2, s2).aux1 by SCMFSA6C:7
      .= s2.aux1 by SCMFSA_2:99 .= Exec(i1, s1).aux1 by SCMFSA6C:9
      .= s1.aux1 by A21,SCMFSA_2:98 .= (s0.f)/.s0a by Th11
      .= s.f.sa by A1,A5,A15,FINSEQ_4:24;
 thus IExec(swap(f, a, b), s).f = Exec(i3, s3).f by SCMFSA6C:8
   .= s.f+*(s.a, s.f.(s.b))+*(s.b, s.f.(s.a))
       by A4,A6,A7,A8,A16,A18,A19,A20,A22,Th12;
end;

theorem
  1 <= s.aa & s.aa <= len (s.f) & 1 <= s.bb & s.bb <= len (s.f) &
 s.intloc 0 = 1
 implies IExec(swap(f, aa, bb), s).f.(s.aa) = s.f.(s.bb) &
         IExec(swap(f, aa, bb), s).f.(s.bb) = s.f.(s.aa)
proof set a = aa, b = bb; assume that
A1: 1 <= s.a & s.a <= len (s.f) & 1 <= s.b & s.b <= len (s.f) and
A2: s.intloc 0 = 1;
        0 < s.a by A1;
    then reconsider sa = s.a as Nat by INT_1:16;
        0 < s.b by A1;
    then reconsider sb = s.b as Nat by INT_1:16;
A3: sa in dom (s.f) & sb in dom (s.f) by A1,FINSEQ_3:27;
A4: IExec(swap(f, a, b), s).f
    = (s.f+*(s.a, s.f.(s.b))+*(s.b, s.f.(s.a))) by A1,A2,Th39;
A5: dom (s.f+*(s.a, s.f.(s.b))) = dom (s.f) by FUNCT_7:32;
 per cases;
 suppose sa <> sb;
 hence IExec(swap(f, a, b), s).f.(s.a)
    = (s.f+*(s.a, s.f.(s.b))).(s.a) by A4,FUNCT_7:34
   .= s.f.(s.b) by A3,FUNCT_7:33;
 thus IExec(swap(f, a, b), s).f.(s.b)
    = s.f.(s.a) by A3,A4,A5,FUNCT_7:33;
 end;
 suppose sa = sb;
 hence IExec(swap(f, a, b), s).f.(s.a)
    = s.f.(s.b) by A3,A4,A5,FUNCT_7:33;
 thus IExec(swap(f, a, b), s).f.(s.b)
    = s.f.(s.a) by A3,A4,A5,FUNCT_7:33;
end;
end;

theorem Th41:
 {aa, bb} c= UsedIntLoc swap(f, aa, bb)
proof set a = aa, b = bb;
  set aux1 = 1-stRWNotIn {a, b}, aux2 = 2-ndRWNotIn {a, b};
  set i0 = aux1 := (f,a), i1 = aux2 := (f,b), i2 = (f,a) := aux2;
  set i3 = (f,b) := aux1;
A1: UsedIntLoc swap(f, a, b)
   = UsedIntLoc (i0 ';' i1 ';' i2 ';' i3)
  .= UsedIntLoc (i0 ';' i1 ';' i2) \/ UsedIntLoc i3 by SF_MASTR:34
  .= UsedIntLoc (i0 ';' i1) \/ (UsedIntLoc i2) \/ UsedIntLoc i3 by SF_MASTR:34
  .= (UsedIntLoc i0) \/ (UsedIntLoc i1) \/ (UsedIntLoc i2) \/ UsedIntLoc i3
         by SF_MASTR:35
  .= {aux1, a} \/ (UsedIntLoc i1) \/ (UsedIntLoc i2) \/ UsedIntLoc i3
         by SF_MASTR:21
  .= {aux1, a} \/ {aux2, b} \/ (UsedIntLoc i2) \/ UsedIntLoc i3 by SF_MASTR:21
  .= {aux1, a} \/ {aux2, b} \/ {aux2, a} \/ UsedIntLoc i3 by SF_MASTR:21
  .= {aux1, a} \/ {aux2, b} \/ {aux2, a} \/ {aux1, b} by SF_MASTR:21;
 let x be set; assume
A2: x in {a, b};
 per cases by A2,TARSKI:def 2;
 suppose x = a; then x in {aux2, a} by TARSKI:def 2;
   then x in {aux1, a} \/ {aux2, b} \/ {aux2, a} by XBOOLE_0:def 2;
  hence x in UsedIntLoc swap(f, a, b) by A1,XBOOLE_0:def 2;
 end;
 suppose x = b; then x in {aux1, b} by TARSKI:def 2;
  hence x in UsedIntLoc swap(f, a, b) by A1,XBOOLE_0:def 2;
end;
end;

theorem
  UsedInt*Loc swap(f, aa, bb) = {f}
proof set a = aa, b = bb;
      set aux1 = 1-stRWNotIn {a, b}; set aux2 = 2-ndRWNotIn {a, b};
thus
    UsedInt*Loc swap(f, a, b) =
   UsedInt*Loc (aux1 := (f,a) ';' (aux2 := (f,b)) ';'
              ((f,a) := aux2) ';' ((f,b) := aux1))
.= UsedInt*Loc (aux1 := (f,a) ';' (aux2 := (f,b)) ';'
              ((f,a) := aux2)) \/ UsedInt*Loc ((f,b) := aux1) by SF_MASTR:50
.= UsedInt*Loc (aux1 := (f,a) ';' (aux2 := (f,b)) ';'
              ((f,a) := aux2)) \/ {f} by SF_MASTR:37
.= UsedInt*Loc (aux1 := (f,a) ';' (aux2 := (f,b))) \/
              (UsedInt*Loc ((f,a) := aux2)) \/ {f} by SF_MASTR:50
.= UsedInt*Loc (aux1 := (f,a) ';' (aux2 := (f,b))) \/
              {f} \/ {f} by SF_MASTR:37
.= (UsedInt*Loc (aux1 := (f,a)) \/ (UsedInt*Loc (aux2 := (f,b)))) \/
              {f} \/ {f} by SF_MASTR:51
.= {f} \/ (UsedInt*Loc (aux2 := (f,b))) \/ {f} \/ {f} by SF_MASTR:37
.= {f} \/ {f} \/ {f} by SF_MASTR:37
.= {f};
end;

begin :: Selection sort

definition
 let f be FinSeq-Location;
  set cv = 1-stRWNotIn {} Int-Locations;
  set minpos = 2-ndRWNotIn {} Int-Locations;

 func Selection-sort f -> Macro-Instruction equals
  (1-stNotUsed swap(f, cv, minpos)) :=len f ';'
  for-up ( cv, intloc 0, (1-stNotUsed swap(f, cv, minpos)),
           FinSeqMin(f, cv, (1-stNotUsed swap(f, cv, minpos)), minpos) ';'
           swap(f, cv, minpos)
         );
 coherence;
end;

theorem
    for S being State of SCM+FSA st S = IExec(Selection-sort f, s)
   holds S.f is_non_decreasing_on 1, len (S.f) &
         ex p being Permutation of dom(s.f) st S.f = (s.f) * p
proof
set D = Int-Locations \/ FinSeq-Locations;
let S be State of SCM+FSA such that
A1: S = IExec(Selection-sort f, s);
  set cv = 1-stRWNotIn {} Int-Locations;
  set minpos = 2-ndRWNotIn {} Int-Locations;
  set finish = 1-stNotUsed swap(f, cv, minpos);
  set i1 = finish :=len f;
  set I21 = FinSeqMin(f, cv, finish, minpos);
  set I22 = swap(f, cv, minpos);
  set I2B = I21 ';' I22;
  set I2 = for-up ( cv, intloc 0, finish, I2B );
     minpos <> cv by SFMASTR1:22;
then A2: FinSeqMin(f, cv, finish, minpos) does_not_destroy cv by Th33;
         cv in {cv, minpos} by TARSKI:def 2;
      then cv <> 1-stRWNotIn {cv, minpos} & cv <> 2-ndRWNotIn{cv, minpos}
       by SFMASTR1:21;
      then swap(f, cv, minpos) does_not_destroy cv by Th38;
then A3: I2B does_not_destroy cv by A2,SCMFSA8C:81;

  set s1 = Exec(i1, Initialize s);

A4: s1.intloc 0
   = (Initialize s).intloc 0 by SCMFSA_2:100
  .= 1 by SCMFSA6C:3;
A5: s1.finish = len ((Initialize s).f) by SCMFSA_2:100
   .= len (s.f) by SCMFSA6C:3;
  then reconsider n = s1.finish-s1.intloc 0 +1 as Nat by A4;

A6:  finish = 1-stRWNotIn UsedIntLoc I22 by SFMASTR1:def 4;
    A7: {cv, minpos} c= UsedIntLoc I22 by Th41;
            cv in {cv, minpos} by TARSKI:def 2;
    then A8: cv <> finish by A6,A7,SFMASTR1:21;

  set SF = StepForUp(cv, intloc 0, finish, I2B, s1);
  defpred Q[Nat] means
   $1 < n implies
     SF.$1.intloc 0 = 1 & I2B is_closed_on SF.$1 & I2B is_halting_on SF.$1;

A9: Q[0] proof assume 0 < n;
     thus
    A10: SF.0.intloc 0 = 1 by A4,Th16;
    A11:  (Initialize SF.0).intloc 0 = 1 by SCMFSA6C:3;
    then A12: I21 is_closed_on Initialize SF.0 by Th35;
    A13: I21 is_halting_on Initialize SF.0 by A11,Th35;
    A14: I22 is_closed_on IExec(I21, SF.0) by SCMFSA7B:24;
    then A15:  I2B is_closed_on Initialize SF.0 by A12,A13,SFMASTR1:3;
      hence I2B is_closed_on SF.0 by A10,SFMASTR2:4;
          I22 is_halting_on IExec(I21, SF.0) by SCMFSA7B:25;
       then I2B is_halting_on Initialize SF.0 by A12,A13,A14,SFMASTR1:4;
      hence I2B is_halting_on SF.0 by A10,A15,SFMASTR2:5;
    end;

A16: for k being Nat st Q[k] holds Q[k+1] proof let k be Nat such that
 A17: Q[k]; assume k+1 < n;
     hence
    A18: SF.(k+1).intloc 0 = 1 by A17,Th24,NAT_1:38;
    A19: (Initialize SF.(k+1)).intloc 0 = 1 by SCMFSA6C:3;
    then A20: I21 is_closed_on Initialize SF.(k+1) by Th35;
    A21: I21 is_halting_on Initialize SF.(k+1) by A19,Th35;
    A22: I22 is_closed_on IExec(I21, SF.(k+1)) by SCMFSA7B:24;
    then A23:  I2B is_closed_on Initialize SF.(k+1)
            by A20,A21,SFMASTR1:3;
     hence I2B is_closed_on SF.(k+1) by A18,SFMASTR2:4;
         I22 is_halting_on IExec(I21, SF.(k+1)) by SCMFSA7B:25;
      then I2B is_halting_on Initialize SF.(k+1) by A20,A21,A22,SFMASTR1:4;
     hence I2B is_halting_on SF.(k+1) by A18,A23,SFMASTR2:5;
    end;

A24: for k being Nat holds Q[k] from NAT_1:sch 1(A9, A16);

A25: ProperForUpBody cv, intloc 0, finish, I2B, s1 proof let i be Nat;
      thus thesis by A24;
     end;

  defpred P[Nat] means
   $1 <= n implies
     SF.$1.cv = $1+s1.intloc 0 &
     SF.$1.finish = s1.finish &
     SF.$1.f is_split_at $1 &
     SF.$1.f is_non_decreasing_on 1, $1 &
     ex p being Permutation of dom(s.f) st SF.$1.f = (s.f) * p;

A26: P[0] proof
    assume 0 <= n;
     thus SF.0.cv = 0+s1.intloc 0 by Th17;
     thus SF.0.finish = s1.finish by A8,Th19;
     thus SF.0.f is_split_at 0 proof let i, j be Nat; assume
      1 <= i & i <= 0 & 0 < j & j <= len (SF.0.f);
      hence thesis;
     end;
     thus SF.0.f is_non_decreasing_on 1, 0 proof let i, j be Nat; assume
      1 <= i & i <= j & j <= 0;
      hence thesis;
     end;
   A27: SF.0.f = s1.f by Th21 .= (Initialize s).f by SCMFSA_2:100
             .= s.f by SCMFSA6C:3;
       dom(s.f) = Seg len(s.f) by FINSEQ_1:def 3;
       then reconsider p = idseq len (s.f) as Permutation of dom(s.f)
        by FINSEQ_2:65;
     take p;
     thus SF.0.f = (s.f) * p by A27,FINSEQ_2:64;
    end;

A28: for k being Nat st P[k] holds P[k+1] proof let k be Nat such that
 A29: P[k];
 A30: now assume
    A31: k < n;
     hence
    A32: SF.k.intloc 0 = 1 by A24;
    A33: I2B is_closed_on SF.k by A24,A31;
     hence I2B is_closed_on Initialize SF.k by A32,SFMASTR2:4;
           I2B is_halting_on SF.k by A24,A31;
     hence I2B is_halting_on Initialize SF.k by A32,A33,SFMASTR2:5;
     thus SF.k.cv = k+s1.intloc 0 by A29,A31;
     thus SF.k.finish = s1.finish by A29,A31;
     thus SF.k.cv <= s1.finish by A4,A29,A31,NAT_1:38;
     thus
         SF.(k+1) | ({cv, intloc 0, finish} \/ (UsedIntLoc I2B) \/
         FinSeq-Locations)
    = IExec(I2B ';' AddTo(cv,intloc 0), SF.k)
               | ({cv, intloc 0, finish} \/ (UsedIntLoc I2B) \/
                 FinSeq-Locations) by A4,A25,A31,Th27;
   end;
   assume
   A34: k+1 <= n;
    hence SF.(k+1).cv = (k+1)+s1.intloc 0 by A3,A4,A25,Th25;
            (Initialize SF.k).intloc 0 = 1 by SCMFSA6C:3;
  then A35: I21 is_closed_on Initialize SF.k &
         I21 is_halting_on Initialize SF.k by Th35;
A36: finish = 1-stRWNotIn UsedIntLoc I22 by SFMASTR1:def 4;
then A37: not finish in UsedIntLoc I22 by SFMASTR1:21;
    A38: {cv, minpos} c= UsedIntLoc I22 by Th41;
            cv in {cv, minpos} by TARSKI:def 2;
    then A39: cv <> finish by A36,A38,SFMASTR1:21;
            minpos in {cv, minpos} by TARSKI:def 2;
  then A40: finish <> minpos by A36,A38,SFMASTR1:21;
  A41:  cv <> minpos by SFMASTR1:22;
    A42: I22 is_closed_on Initialize IExec(I21, SF.k) by SCMFSA7B:24;
    A43: I22 is_halting_on Initialize IExec(I21, SF.k) by SCMFSA7B:25;
    A44: {cv, finish, minpos} c= UsedIntLoc I21 by Th34;
            finish in {cv, finish, minpos} by ENUMSET1:def 1;
         then finish in (UsedIntLoc I21) \/ UsedIntLoc I22 by A44,
XBOOLE_0:def 2;
         then finish in UsedIntLoc I2B by SF_MASTR:31;
     then finish in {cv, intloc 0, finish} \/ UsedIntLoc I2B by XBOOLE_0:def 2
;
    hence SF.(k+1).finish   :: too lazy to use: does_not_destroy
       = IExec(I2B ';' AddTo(cv,intloc 0), SF.k).finish
              by A30,A34,NAT_1:38,SFMASTR2:7
      .= Exec(AddTo(cv, intloc 0), IExec(I2B, SF.k)).finish
             by A30,A34,NAT_1:38,SFMASTR1:12
      .= IExec(I2B, SF.k).finish by A39,SCMFSA_2:90
      .= IExec(I22, IExec(I21, SF.k)).finish by A35,SFMASTR1:8
      .= (Initialize IExec(I21, SF.k)).finish by A37,A42,A43,SFMASTR2:1
      .= IExec(I21, SF.k).finish by SCMFSA6C:3
      .= s1.finish by A30,A34,A40,A41,Th36,NAT_1:38;
 set F = SF.k.f, F1 = SF.(k+1).f;
 set ma = min_at(F, k+1, len F);

       consider p being Permutation of dom(s.f) such that
   A45: F = (s.f) * p by A29,A34,NAT_1:38;
   A46: dom(s.f) = Seg len(s.f) by FINSEQ_1:def 3;
   then A47: len F = len (s.f) by A45,FINSEQ_2:47;
then A48: dom F = dom(s.f) by FINSEQ_3:31;
   A49: 1 <= k+1 by NAT_1:37;
   then A50: k+1 in dom F by A4,A5,A34,A47,FINSEQ_3:27;
   A51: k+1 <= ma & ma <= len F by A4,A5,A34,A47,A49,Th3;
   then 1 <= ma by A49,XXREAL_0:2;
   then A52: ma in dom F by A51,FINSEQ_3:27;

A53:  F1 = F+*(k+1, F.ma)+*(ma, F.(k+1)) proof
   set S2 = IExec(I21, SF.k);
  A54: SF.k.finish = len F by A5,A30,A34,A45,A46,FINSEQ_2:47,NAT_1:38;
  A55: S2.f = F by A30,A34,A40,A41,Th36,NAT_1:38;
  A56: S2.cv = k+1 by A4,A30,A34,A40,A41,Th36,NAT_1:38;
  k+1 = abs(k+1) & len F = abs(len F) by ABSVALUE:def 1;
  then A57: S2.minpos = ma by A4,A30,A34,A40,A41,A49,A54,Th37,NAT_1:38;
  then A58: 1 <= S2.minpos by A49,A51,XXREAL_0:2;
  A59: S2.minpos <= len (S2.f) by A4,A5,A34,A47,A49,A55,A57,Th3;
  A60: S2.intloc 0 = 1 by A35,SCMFSA8C:96;
 thus F1 = IExec(I2B ';' AddTo(cv, intloc 0), SF.k).f
                by A30,A34,NAT_1:38,SFMASTR2:7
      .= Exec(AddTo(cv, intloc 0), IExec(I2B, SF.k)).f
                by A30,A34,NAT_1:38,SFMASTR1:13
      .= IExec(I2B, SF.k).f by SCMFSA_2:90
      .= IExec(I22, IExec(I21, SF.k)).f by A35,SFMASTR1:9
      .= F+*(k+1, F.ma)+*(ma, F.(k+1))
               by A4,A5,A34,A47,A49,A55,A56,A57,A58,A59,A60,Th39;
 end;
    hence SF.(k+1).f is_split_at (k+1) by A4,A5,A29,A34,A47,Th6,NAT_1:38;
    thus SF.(k+1).f is_non_decreasing_on 1, (k+1)
              by A4,A5,A29,A34,A47,A53,Th5,NAT_1:38;
     consider p1 being Permutation of dom F such that
   A61: F1 = F*p1 by A50,A52,A53,Th2;
     reconsider p1 as Permutation of dom(s.f) by A48;
     reconsider pp = p*p1 as Permutation of dom(s.f);
   take pp;
   thus F1 = (s.f)*pp by A45,A61,RELAT_1:55;
   end;

A62: for k being Nat holds P[k] from NAT_1:sch 1(A26, A28);

A63: IExec(I2, s1) | D = SF.n | D by A4,A25,Th31;
   I2 is_halting_on s1 & I2 is_closed_on s1 by A4,A25,Th32;
then A64: S.f = IExec(I2, s1).f by A1,SFMASTR1:16
      .= SF.n.f by A63,SCMFSA6A:38;
  consider p being Permutation of dom(s.f) such that
A65: SF.n.f = (s.f) * p by A62;
     dom(s.f) = Seg len(s.f) by FINSEQ_1:def 3;
  then len (S.f) = n by A4,A5,A64,A65,FINSEQ_2:47;
 hence S.f is_non_decreasing_on 1, len (S.f) by A62,A64;
 thus ex p being Permutation of dom(s.f) st S.f = (s.f) * p by A62,A64;
end;
