:: Preliminaries to Circuits, I
::  by Yatsuka Nakamura, Piotr Rudnicki, Andrzej Trybulec and Pauline N. Kawamoto
::
:: Received November 17, 1994
:: Copyright (c) 1994 Association of Mizar Users

environ

 vocabularies FINSET_1, FUNCT_1, RELAT_1, FUNCOP_1, FUNCT_4, BOOLE, SQUARE_1,
      FINSUB_1, SETWISEO, PBOOLE, TDGROUP, FINSEQ_1, CARD_3, ZF_REFLE, TARSKI,
      FUNCT_5, FUNCT_2, PRALG_1, PRALG_2, MCART_1, FINSEQ_2, TREES_1, TREES_3,
      TREES_2, FUNCT_6, TREES_4, CQC_LANG, CARD_1, PRE_CIRC, ORDINAL2, ARYTM,
      MEMBERED, SEQ_2, SEQ_4, ARYTM_1, CARD_FIN, INT_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0,
      XREAL_0, REAL_1, INT_1, MCART_1, CARD_1, MEMBERED, SEQ_4, RELAT_1,
      FUNCT_1, FINSET_1, FINSUB_1, SETWISEO, FUNCT_2, XXREAL_0, XXREAL_2,
      BINOP_1,
      FUNCOP_1, FUNCT_4, CARD_3, BINARITH, TREES_1, TREES_2, TREES_3, TREES_4,
      FUNCT_5, FUNCT_6, PBOOLE, FINSEQ_1, FINSEQ_2, NAT_1;
 constructors WELLORD2, BINOP_1, FUNCT_4, SETWISEO, XXREAL_0, NAT_1, FUNCT_5,
      CARD_3, SEQ_4, PBOOLE, TREES_4, BINARITH, INT_1, SEQ_1, XXREAL_2;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      FINSET_1, FRAENKEL, NUMBERS, XREAL_0, MEMBERED, FINSEQ_1, TREES_1,
      CARD_3, PBOOLE, TREES_2, TREES_3, XXREAL_2, CARD_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, FUNCOP_1, WELLORD2, FUNCT_1, RELAT_1, PBOOLE, XBOOLE_0,
      SEQ_4, FINSEQ_2, FINSET_1;
 theorems TARSKI, ZFMISC_1, FINSUB_1, FINSEQ_1, FINSEQ_3, GRFUNC_1, FUNCT_1,
      FUNCT_2, FUNCT_4, FUNCT_5, TREES_1, TREES_2, TREES_3, TREES_4, NAT_1,
      RELAT_1, CARD_3, FUNCOP_1, MCART_1, PBOOLE, CARD_2, CARD_1, FUNCT_6,
      FINSET_1, RELSET_1, XBOOLE_0, XBOOLE_1, PARTFUN1, XCMPLX_1, MEMBERED,
      SEQ_4, ORDERS_1, XREAL_1, XXREAL_0, BINARITH, XXREAL_2;
 schemes SETWISEO, DOMAIN_1, PBOOLE, FUNCT_1, FRAENKEL, FINSEQ_1, NAT_1;

begin

scheme FraenkelFinIm{ A() -> finite non empty set, F(set) -> set, P[set] }:
  { F(x) where x is Element of A() : P[x] } is finite
proof
A1: A() is finite;
  set B = { F(x) where x is Element of A() : x in A() };
A2: B is finite from FRAENKEL:sch 21(A1);
  { F(x) where x is Element of A() : P[x] } c= B
  proof
    let a be set;
    assume a in { F(x) where x is Element of A() : P[x] };
    then consider b being Element of A() such that
A3: F(b) = a and P[b];
    thus thesis by A3;
  end;
  hence thesis by A2;
end;

canceled;

theorem
  for f being Function, x, y being set st dom f = {x} & rng f = {y}
  holds f = { [x,y] }
proof
  let f be Function, x, y be set;
  assume dom f = {x} & rng f = {y};
  then f = {x} --> y by FUNCOP_1:15;
  hence f = { [x,y] } by ZFMISC_1:35;
end;

theorem Th3:
  for f, g, h being Function st f c= g holds f +* h c= g +* h
proof
  let f, g, h be Function;
  assume
A1: f c= g;
  now
    dom (f +* h) = dom f \/ dom h & dom (g +* h) = dom g \/ dom h
    by FUNCT_4:def 1;
    hence dom (f +* h) c= dom (g +* h) by A1,XBOOLE_1:9,RELAT_1:25;
    let x be set;
    assume x in dom (f +* h);
    then
A3: x in dom f or x in dom h by FUNCT_4:13;
    per cases;
    suppose
A4:   x in dom h;
      hence (f +* h).x = h.x by FUNCT_4:14
        .= (g +* h).x by A4,FUNCT_4:14;
    end;
    suppose
A5:   not x in dom h;
      then
A6:   (f +* h).x = f.x by FUNCT_4:12;
      (g +* h).x = g.x by A5,FUNCT_4:12;
      hence (f +* h).x = (g +* h).x by A1,A3,A5,A6,GRFUNC_1:8;
    end;
  end;
  hence f +* h c= g +* h by GRFUNC_1:8;
end;

theorem
  for f, g, h being Function st f c= g & dom f misses dom h holds f c= g +* h
proof
  let f, g, h be Function;
  assume f c= g;
  then
A1: f +* h c= g +* h by Th3;
  assume dom f misses dom h;
  then f c= f +* h by FUNCT_4:33;
  hence f c= g +* h by A1,XBOOLE_1:1;
end;

begin

::---------------------------------------------------------------------------
:: Many Sorted Sets and Functions
::---------------------------------------------------------------------------

theorem
  for I being set, MSS being ManySortedSet of I holds MSS#.<*>I = {{}}
proof
  let I be set, MSS be ManySortedSet of I;
  reconsider eI = <*>I as Element of I* by FINSEQ_1:66;
  thus MSS#.<*>I = product (MSS*eI) by PBOOLE:def 19
    .= {{}} by CARD_3:19;
end;

reserve i,j,x,y for set,
  g for Function;

scheme MSSLambda2Part { I() -> set, P [set], F, G (set) -> set }:
  ex f being ManySortedSet of I() st for i being Element of I() st i in I()
  holds (P[i] implies f.i = F(i)) & (not P[i] implies f.i = G(i))
proof
  defpred Q[set,set] means
  (P[$1] implies $2 = F($1)) & (not P[$1] implies $2 = G($1));
A1: now
    let i such that i in I();
    thus ex j st Q[i,j]
    proof
      per cases;
      suppose
A2:     P[i];
        take F(i); thus thesis by A2;
      end;
      suppose
A3:     not P[i];
        take G(i); thus thesis by A3;
      end;
    end;
  end;
  consider f being ManySortedSet of I() such that
A4: for i st i in I() holds Q[i,f.i] from PBOOLE:sch 3(A1);
  take f;
  thus thesis by A4;
end;

notation
  let I be set;
  let IT be ManySortedSet of I;
  synonym IT is locally-finite for IT is finite-yielding;
end;

definition
  let I be set;
  let IT be ManySortedSet of I;
  canceled 2;
  redefine attr IT is locally-finite means
  for i st i in I holds IT.i is finite;
  compatibility
  proof
A1: dom IT = I by PBOOLE:def 3;
    hereby
      assume
A2:   IT is locally-finite;
      let i;
      assume i in I;
      then IT.i in rng IT by A1,FUNCT_1:12;
      hence IT.i is finite by A2,FINSET_1:def 2;
    end;
    assume
A3: for i st i in I holds IT.i is finite;
    let i be set;
    assume i in rng IT;
    then ex x st x in dom IT & i = IT.x by FUNCT_1:def 5;
    hence i is finite by A1,A3;
  end;
end;

registration
  let I be set;
  cluster non-empty locally-finite ManySortedSet of I;
  existence
  proof
    reconsider f = I --> {{}} as Function;
    dom f = I by FUNCOP_1:19;
    then reconsider f as ManySortedSet of I by PBOOLE:def 3;
    take f;
    thus f is non-empty;
    thus f is locally-finite
    proof
      let i be set;
      assume i in I;
      hence f.i is finite by FUNCOP_1:13;
    end;
  end;
end;

definition
  let I, A be set;
  redefine func I --> A -> ManySortedSet of I;
  coherence
  proof
    set f = I --> A;
    dom f = I by FUNCOP_1:19;
    hence f is ManySortedSet of I by PBOOLE:def 3;
  end;
end;

definition
  let I be set, M be ManySortedSet of I, A be Subset of I;
  redefine func M | A -> ManySortedSet of A;
  coherence
  proof
    set B = M | A;
A1: dom B = dom M /\ A by RELAT_1:90;
    dom M = I by PBOOLE:def 3;
    then dom B = A by A1,XBOOLE_1:28;
    hence thesis by PBOOLE:def 3;
  end;
end;

registration
  let M be non-empty Function, A be set;
  cluster M | A -> non-empty;
  coherence
  proof
    rng(M|A) c= rng M by RELAT_1:99;
    hence not {} in rng(M|A) by RELAT_1:def 9;
  end;
end;

theorem Th6:
  for I being non empty set, B being non-empty ManySortedSet of I
  holds union rng B is non empty
proof
  let I be non empty set, B be non-empty ManySortedSet of I;
  consider i being Element of I;
  i in I;
  then i in dom B by PBOOLE:def 3;
  then B.i <> {} & B.i in rng B by FUNCT_1:def 5;
  hence union rng B is non empty by ORDERS_1:91;
end;

theorem Th7:
  for I being set holds uncurry (I --> {}) = {}
proof
  let I be set;
  per cases;
  suppose I = {};
    then dom (I-->{}) = {};
    hence thesis by FUNCT_5:50,RELAT_1:64;
  end;
  suppose I <> {};
    then rng (I --> {}) = {{}} by FUNCOP_1:14
      .= Funcs({} qua set, {} qua set) by FUNCT_5:64;
    then dom uncurry (I --> {}) = [:dom (I --> {}), {}:] by FUNCT_5:33
      .= {} by ZFMISC_1:113;
    hence thesis;
  end;
end;

theorem
  for I being non empty set, A being set,
  B being non-empty ManySortedSet of I,
  F being ManySortedFunction of (I --> A), B holds dom commute F = A
proof
  let I be non empty set, A be set, B be non-empty ManySortedSet of I,
  F be ManySortedFunction of (I --> A), B;
A1: dom B = I & dom F = I by PBOOLE:def 3;
  per cases;
  suppose
A2: A is empty;
A3: rng F <> {} by A1,RELAT_1:65;
    rng F c= {{}}
    proof
      let x be set;
      assume x in rng F;
      then consider i being set such that
A4:   i in I & x = F.i by A1,FUNCT_1:def 5;
A5:   (I -->A).i = A by A4,FUNCOP_1:13;
      x is Function of (I -->A).i, B.i by A4,PBOOLE:def 18;
      then x = {} by A2,A5,PARTFUN1:57;
      hence thesis by TARSKI:def 1;
    end;
    then rng F = {{}} by A3,ZFMISC_1:39;
    then
A6: F = I --> {} by A1,FUNCOP_1:15;
    commute F = curry' uncurry F by FUNCT_6:def 12
      .= {} by A6,Th7,FUNCT_5:49;
    hence thesis by A2;
  end;
  suppose
A7: A is non empty;
    union rng B is non empty by Th6;
    then
A8: Funcs (I, union rng B) is non empty by FUNCT_2:11;
    rng F c= Funcs(A, union rng B)
    proof
      let x be set;
      assume x in rng F;
      then consider i being set such that
A9:   i in dom F & x = F.i by FUNCT_1:def 5;
      (I -->A).i = A by A1,A9,FUNCOP_1:13;
      then reconsider x' = x as Function of A, B.i by A1,A9,PBOOLE:def 18;
      B.i <> {} by A1,A9;
      then
A10:  dom x' = A & rng x' c= B.i by FUNCT_2:def 1 ,RELSET_1:12;
      B.i in rng B by A1,A9,FUNCT_1:def 5;
      then B.i c= union rng B by ZFMISC_1:92;
      then rng x' c= union rng B by A10,XBOOLE_1:1;
      hence x in Funcs(A, union rng B) by A10,FUNCT_2:def 2;
    end;
    then F in Funcs (I, Funcs(A, union rng B)) by A1,FUNCT_2:def 2;
    then commute F in Funcs (A, Funcs(I, union rng B)) by A7,FUNCT_6:85;
    then commute F is Function of A, Funcs(I, union rng B) by FUNCT_2:121;
    hence dom commute F = A by A8,FUNCT_2:def 1;
  end;
end;

scheme LambdaRecCorrD {D() -> non empty set, A() -> Element of D(),
  F(Nat, Element of D()) -> Element of D() } :
  (ex f being Function of NAT, D() st f.0 = A()
  & for i being Nat holds f.(i+1) = F(i, f.i))
  & for f1, f2 being Function of NAT, D() st (f1.0 = A()
  & for i being Nat holds f1.(i+1) = F(i, f1.i)) & (f2.0 = A() &
  for i being Nat holds f2.(i+1) = F(i,f2.i)) holds f1 = f2
proof
  thus ex f being Function of NAT, D() st f.0 = A()
  & for i being Nat holds f.(i+1) = F(i,f.i) from NAT_1:sch 12;
  let f1, f2 be Function of NAT, D() such that
A1: f1.0 = A() and
B1: for i being Nat holds f1.(i+1) = F(i,f1.i) and
A2: f2.0 = A() and
B2: for i being Nat holds f2.(i+1) = F(i,f2.i);
  thus f1 = f2 from NAT_1:sch 16(A1,B1,A2,B2);
end;

scheme LambdaMSFD{J() -> non empty set, I() -> Subset of J(),
  A, B() -> ManySortedSet of I(), F(set) -> set } :
  ex f being ManySortedFunction of A(), B() st
  for i being Element of J() st i in I() holds f.i = F(i)
provided
A1: for i being Element of J() st i in I()
holds F(i) is Function of A().i, B().i
proof
  consider f being ManySortedSet of I() such that
A2: for i st i in I() holds f.i = F(i) from PBOOLE:sch 4;
  f is Function-yielding
  proof
    let i;
    assume i in dom f;
    then
A3: i in I() by PBOOLE:def 3;
    then F(i) is Function by A1;
    hence thesis by A2,A3;
  end;
  then reconsider f as ManySortedFunction of I();
  f is ManySortedFunction of A(), B()
  proof
    let i;
    assume
A4: i in I();
    then F(i) is Function of A().i, B().i by A1;
    hence thesis by A2,A4;
  end;
  then reconsider f as ManySortedFunction of A(), B();
  take f;
  thus thesis by A2;
end;

theorem
  for I being set, f being non-empty ManySortedSet of I, g being Function ,
  s being Element of product f
  st dom g c= dom f & for x being set st x in dom g holds g.x in f.x
  holds s+*g is Element of product f
proof
  let I be set, f be non-empty ManySortedSet of I, g be Function,
  s be Element of product f;
  assume
A1: dom g c= dom f & for x being set st x in dom g holds g.x in f.x;
A2: dom (s+*g) = dom s \/ dom g by FUNCT_4:def 1;
  dom s = dom f by CARD_3:18;
  then
A3: dom (s+*g) = dom f by A1,A2,XBOOLE_1:12;
  now
    let x be set;
    assume
A4: x in dom f;
    per cases;
    suppose
A5:   x in dom g;
      then (s+*g).x = g.x by FUNCT_4:14;
      hence (s+*g).x in f.x by A1,A5;
    end;
    suppose not x in dom g;
      then
A6:   (s+*g).x = s.x by FUNCT_4:12;
      ex g' being Function st s = g' & dom g' = dom f
      & for x being set st x in dom f holds g'.x in f.x by CARD_3:def 5;
      hence (s+*g).x in f.x by A4,A6;
    end;
  end;
  hence s+*g is Element of product f by A3,CARD_3:18;
end;

theorem
  for A, B being non empty set, C being non-empty ManySortedSet of A,
  InpFs being ManySortedFunction of A --> B, C, b being Element of B
  ex c being ManySortedSet of A st c = (commute InpFs).b & c in C
proof
  let A, B be non empty set, C be non-empty ManySortedSet of A,
  InpFs be ManySortedFunction of A --> B, C, b be Element of B;
A1: commute InpFs = curry' uncurry InpFs by FUNCT_6:def 12;
A2: dom InpFs = A by PBOOLE:def 3;
  dom(uncurry InpFs) = [:A,B:]
  proof
    thus dom(uncurry InpFs) c= [:A,B:]
    proof
      let i;
      assume i in dom(uncurry InpFs);
      then consider x,g,y such that
A3:   i = [x,y] and
A4:   x in dom InpFs and
A5:   g = InpFs.x and
A6:   y in dom g by FUNCT_5:def 4;
A7:   C.x <> {} by A2,A4;
      g is Function of (A-->B).x, C.x by A2,A4,A5,PBOOLE:def 18;
      then dom g = (A-->B).x by A7,FUNCT_2:def 1;
      then dom g = B by A2,A4,FUNCOP_1:13;
      hence i in [:A,B:] by A2,A3,A4,A6,ZFMISC_1:106;
    end;
    let i1,i2 be set;
    assume
A8: [i1,i2] in [:A,B:];
    then
A9: [i1,i2] = [[i1,i2]`1,[i1,i2]`2] by MCART_1:23;
A10: [i1,i2]`1 in dom InpFs by A2,A8,MCART_1:10;
    reconsider g = InpFs.[i1,i2]`1 as Function;
A11: C.[i1,i2]`1 <> {} by A2,A10;
    g is Function of (A-->B).[i1,i2]`1, C.[i1,i2]`1
              by PBOOLE:def 18,A8,MCART_1:10;
    then dom g = (A-->B).[i1,i2]`1 by A11,FUNCT_2:def 1;
    then dom g = B by FUNCOP_1:13,A8,MCART_1:10;
    then [i1,i2]`2 in dom g by A8,MCART_1:10;
    hence [i1,i2] in dom(uncurry InpFs) by A9,A10,FUNCT_5:45;
  end;
  then consider g being Function such that
A12: (curry' uncurry InpFs).b = g & dom g = A and
  rng g c= rng uncurry InpFs and
A13: for i st i in A holds g.i = (uncurry InpFs).(i,b) by FUNCT_5:39;
  reconsider c = (commute InpFs).b as ManySortedSet of A
  by A1,A12,PBOOLE:def 3;
  take c;
  thus c = (commute InpFs).b;
  let i;
  assume
A14: i in A;
  reconsider h = InpFs.i as Function;
A15: C.i <> {} by A14;
  (A-->B).i = B by A14,FUNCOP_1:13;
  then
A16: h is Function of B, C.i by A14,PBOOLE:def 18;
  then
A17: dom h = B by A15,FUNCT_2:def 1;
  c.i = (uncurry InpFs).(i,b) by A1,A12,A13,A14
    .= h.b by A2,A14,A17,FUNCT_5:45;
  hence c.i in C.i by A15,A16,FUNCT_2:7;
end;

canceled;

theorem
  for n being Element of NAT, a being set
  holds product ( n |-> {a} ) = { n |-> a }
proof
  let n be Element of NAT, a be set;
  now
    let i;
    hereby
      assume i in product ( n |-> {a} );
      then consider g being Function such that
A1:   i = g and
A2:   dom g = dom( n |-> {a} ) and
A3:   for x st x in dom( n |-> {a} ) holds g.x in ( n |-> {a} ).x
      by CARD_3:def 5;
A4:   dom g = Seg n by A2,FUNCOP_1:19;
      now
        let x;
        assume
A5:     x in dom g;
        then g.x in ( n |-> {a} ).x & x is Element of NAT by A2,A3;
        then g.x in {a} by A4,A5,FUNCOP_1:13;
        hence g.x = a by TARSKI:def 1;
      end;
      hence i = n |-> a by A1,A4,FUNCOP_1:17;
    end;
    assume
A6: i = n |-> a;
    then reconsider g = i as Function;
A7: dom g = Seg n by A6,FUNCOP_1:19
      .= dom( n |-> {a} ) by FUNCOP_1:19;
    now
      let x;
      assume x in dom( n |-> {a} );
      then x in Seg n by FUNCOP_1:19;
      then g.x = a & ( n |-> {a} ).x = {a} by A6,FUNCOP_1:13;
      hence g.x in ( n |-> {a} ).x by TARSKI:def 1;
    end;
    hence i in product ( n |-> {a} ) by A7,CARD_3:18;
  end;
  hence product ( n |-> {a} ) = { n |-> a } by TARSKI:def 1;
end;

begin

::---------------------------------------------------------------------------
:: Trees
::---------------------------------------------------------------------------

reserve T,T1 for finite Tree,
  t,p for Element of T,
  t1 for Element of T1;

registration
  let D be non empty set;
  cluster -> finite Element of FinTrees D;
  coherence
  proof
    let t be Element of FinTrees D;
    dom t is finite;
    hence t is finite by FINSET_1:29;
  end;
end;

registration
  let T be finite DecoratedTree, t be Element of dom T;
  cluster T|t -> finite;
  coherence
  proof
    dom(T|t) = (dom T)|t by TREES_2:def 11;
    hence thesis by FINSET_1:29;
  end;
end;

theorem Th13:
  T|p,{ t : p is_a_prefix_of t } are_equipotent
proof
  set X = { t : p is_a_prefix_of t };
  deffunc F(Element of T|p) = p^$1;
  consider f being Function such that
A1: dom f = T|p and
A2: for n being Element of T|p holds f.n = F(n) from FUNCT_1:sch 4;
  take f;
  thus f is one-to-one
  proof
    let x,y such that
A3: x in dom f and
A4: y in dom f and
A5: f.x = f.y;
    reconsider m = x, n = y as Element of T|p by A1,A3,A4;
    p^m = f.n by A2,A5
      .= p^n by A2;
    hence x = y by FINSEQ_1:46;
  end;
  thus dom f = T|p by A1;
  thus rng f c= X
  proof
    let i;
    assume i in rng f;
    then consider n being set such that
A6: n in dom f and
A7: i = f.n by FUNCT_1:def 5;
    reconsider n as Element of T|p by A1,A6;
    reconsider t = p^n as Element of T by TREES_1:def 9;
A8: f.n = p^n by A2;
    p is_a_prefix_of t by TREES_1:8;
    hence i in X by A7,A8;
  end;
  let i;
  assume i in X;
  then consider t being Element of T such that
A9: i = t & p is_a_prefix_of t;
  consider n being FinSequence such that
A10: i = p^n by A9,TREES_1:8;
  n is FinSequence of NAT by A9,A10,FINSEQ_1:50;
  then reconsider n as Element of T|p by A9,A10,TREES_1:def 9;
  i = f.n by A2,A10;
  hence i in rng f by A1,FUNCT_1:def 5;
end;

registration
  let T be finite DecoratedTree, t be Element of dom T;
  let T1 be finite DecoratedTree;
  cluster T with-replacement (t,T1) -> finite;
  coherence
  proof
    dom (T with-replacement (t,T1)) =
    dom T with-replacement (t,dom T1) by TREES_2:def 12;
    hence thesis by FINSET_1:29;
  end;
end;

theorem Th14:
  T with-replacement (p,T1) =
  { t : not p is_a_prefix_of t } \/ { p^t1 : not contradiction }
proof
  defpred P1[set] means $1=$1;
  defpred P2[set] means not contradiction;
  deffunc F(FinSequence) = p^$1;
  set A = { t : not p is_a_proper_prefix_of t }, B = { F(t1) : P1[t1] },
  C = { t : not p is_a_prefix_of t }, D = { F(t1) : P2[t1] };
A1: for t1 holds P1[t1] iff P2[t1];
A2: B = D from FRAENKEL:sch 3(A1);
  now
    let x;
    hereby
      assume x in A;
      then consider t such that
A3:   x = t & not p is_a_proper_prefix_of t;
      not p is_a_prefix_of t or t = p by A3,XBOOLE_0:def 8;
      hence x in C or x in {p} by A3,TARSKI:def 1;
    end;
    assume x in C or x in {p};
    then x = p or ex t st t = x & not p is_a_prefix_of t by TARSKI:def 1;
    then consider t such that
A4: t = x and
A5: t = p or not p is_a_prefix_of t;
    not p is_a_proper_prefix_of t by A5,XBOOLE_0:def 8;
    hence x in A by A4;
  end;
  then
A6: A = C \/ {p} by XBOOLE_0:def 2;
  {} is Element of T1 & p^{} = p by FINSEQ_1:47,TREES_1:47;
  then
A7: p in D;
  thus T with-replacement (p,T1) = C \/ {p} \/ D by A2,A6,TREES_1:64
    .= C \/ ({p} \/ D) by XBOOLE_1:4
    .= C \/ D by A7,ZFMISC_1:46;
end;

theorem Th15:
  for f being FinSequence of NAT st f in T with-replacement (p,T1) &
  p is_a_prefix_of f ex t1 st f = p^t1
proof
  let f be FinSequence of NAT such that
A1: f in T with-replacement (p,T1) and
A2: p is_a_prefix_of f;
A3: T with-replacement (p,T1) =
  { t : not p is_a_prefix_of t } \/ { p^t1 : not contradiction } by Th14;
  not f in { t : not p is_a_prefix_of t }
  proof
    assume f in { t : not p is_a_prefix_of t };
    then ex t st f = t & not p is_a_prefix_of t;
    hence contradiction by A2;
  end;
  then f in { p^t1 : not contradiction } by A1,A3,XBOOLE_0:def 2;
  hence thesis;
end;

theorem Th16:
  for p being Tree-yielding FinSequence, k being Element of NAT st k+1 in dom p
  holds (tree p)|<*k*> = p.(k+1)
proof
  let p be Tree-yielding FinSequence, k be Element of NAT;
  assume k+1 in dom p;
  then k+1 <= len p by FINSEQ_3:27;
  then k < len p by NAT_1:13;
  hence (tree p)|<*k*> = p.(k+1) by TREES_3:52;
end;

theorem
  for q being DTree-yielding FinSequence, k being Element of NAT
  st k+1 in dom q holds <*k*> in tree doms q
proof
  let q be DTree-yielding FinSequence, k be Element of NAT;
  assume
A1: k+1 in dom q;
  then
A2: k+1 <= len q by FINSEQ_3:27;
  k < k+1 by XREAL_1:31;
  then
A3: k < len q by A2,XXREAL_0:2;
    dom doms q = dom q & doms q is Tree-yielding by TREES_3:39;
  then (doms q).(k+1) is Tree by A1,TREES_3:24;
  then
A5: {} in (doms q).(k+1) by TREES_1:47;
  dom q = Seg len q & Seg len doms q = dom doms q by FINSEQ_1:def 3;
  then
A6: k < len doms q by A3,FINSEQ_1:8,TREES_3:39;
  <*k*> = <*k*>^{} by FINSEQ_1:47;
  hence <*k*> in tree doms q by A5,A6,TREES_3:def 15;
end;

theorem Th18:
  for p,q being Tree-yielding FinSequence, k being Element of NAT
  st len p = len q & k+1 in dom p &
  for i being Element of NAT st i in dom p & i <> k+1 holds p.i = q.i
  for t being Tree st q.(k+1) = t
  holds tree(q) = tree(p) with-replacement (<*k*>, t)
proof
  let p,q be Tree-yielding FinSequence, k be Element of NAT such that
A1: len p = len q and
A2: k+1 in dom p and
A3: for i being Element of NAT st i in dom p & i <> k+1 holds p.i = q.i;
  set o = <*k*>;
  k+1 <= len p by A2,FINSEQ_3:27;
  then
A4: k < len p by NAT_1:13;
  let t be Tree;
  assume
A5: q.(k+1) = t;
  p.(k+1) is Tree by A2,TREES_3:24;
  then
A6: {} in p.(k+1) by TREES_1:47;
  o = o^{} by FINSEQ_1:47;
  then
A7: o in tree(p) by A4,A6,TREES_3:def 15;
  now
    let s be FinSequence of NAT;
    hereby
      assume
A8:   s in tree(q);
      per cases by A8,TREES_3:def 15;
      suppose s = {};
        hence s in tree(p) & not o is_a_proper_prefix_of s or
        ex r being FinSequence of NAT st r in
        t & s = o^r by TREES_1:47,XBOOLE_1:115;
      end;
      suppose ex n being Element of NAT, r being FinSequence
        st n < len q & r in q.(n+1) & s = <*n*>^r;
        then consider n being Element of NAT, r being FinSequence such that
A9:     n < len q & r in q.(n+1) & s = <*n*>^r;
        now per cases;
          case
A10:        n = k;
            reconsider r as FinSequence of NAT by A9,FINSEQ_1:50;
            take r;
            thus r in t & s = o^r by A5,A9,A10;
          end;
          case
A11:        n <> k;
            1 <= n+1 & n+1 <= len p by A1,A9,NAT_1:11,13;
            then n+1 in dom p by FINSEQ_3:27;
            then q.(n+1) = p.(n+1) by A3,A11,XCMPLX_1:2;
            hence s in tree(p) by A1,A9,TREES_3:def 15;
            assume o is_a_proper_prefix_of s;
            then o is_a_prefix_of s by XBOOLE_0:def 8;
            then consider s1 being FinSequence such that
A12:        s = o^s1 by TREES_1:8;
            k = s.1 by A12,FINSEQ_1:58
              .= n by A9,FINSEQ_1:58;
            hence contradiction by A11;
          end;
        end;
        hence s in tree(p) & not o is_a_proper_prefix_of s or
        ex r being FinSequence of NAT st r in t & s = o^r;
      end;
    end;
    assume
A13: s in tree(p) & not o is_a_proper_prefix_of s or
    ex r being FinSequence of NAT st r in t & s = o^r;
    per cases by A13;
    suppose that
A14:  s in tree(p) and
A15:  not o is_a_proper_prefix_of s;
      now per cases by A14,TREES_3:def 15;
        suppose s = {};
          hence s in tree(q) by TREES_1:47;
        end;
        suppose ex n being Element of NAT, r being FinSequence
          st n < len p & r in p.(n+1) & s = <*n*>^r;
          then consider n being Element of NAT, r being FinSequence such that
A16:      n < len p & r in p.(n+1) & s = <*n*>^r;
          now per cases;
            suppose
A17:          r = {};
              1 <= n+1 & n+1 <= len q by A1,A16,NAT_1:11,13;
              then n+1 in dom q by FINSEQ_3:27;
              then q.(n+1) is Tree by TREES_3:24;
              then r in q.(n+1) by A17,TREES_1:47;
              hence s in tree(q) by A1,A16,TREES_3:def 15;
            end;
            suppose
A18:          r <> {};
A19:          now
                assume
A20:            n = k;
                then
A21:            o is_a_prefix_of s by A16,TREES_1:8;
                not s = o by A16,A18,A20,TREES_1:5;
                hence contradiction by A15,A21,XBOOLE_0:def 8;
              end;
              1 <= n+1 & n+1 <= len p by A16,NAT_1:11,13;
              then n+1 in dom p by FINSEQ_3:27;
              then q.(n+1) = p.(n+1) by A3,A19,XCMPLX_1:2;
              hence s in tree(q) by A1,A16,TREES_3:def 15;
            end;
          end;
          hence s in tree(q);
        end;
      end;
      hence s in tree(q);
    end;
    suppose ex r being FinSequence of NAT st r in t & s = o^r;
      then consider r being FinSequence of NAT such that
A22:  r in t & s = o^r;
      thus s in tree(q) by A1,A4,A5,A22,TREES_3:def 15;
    end;
  end;
  hence tree(q) = tree(p) with-replacement (o, t) by A7,TREES_1:def 12;
end;

theorem
  for e1,e2 being finite DecoratedTree, x being set, k being Element of NAT,
  p being DTree-yielding FinSequence st <*k*> in dom e1 & e1 = x-tree p
  ex q being DTree-yielding FinSequence st
  e1 with-replacement (<*k*>,e2) = x-tree q & len q = len p & q.(k+1) = e2 &
  for i being Element of NAT st i in dom p & i <> k+1 holds q.i = p.i
proof
  let e1,e2 be finite DecoratedTree, x be set, k be Element of NAT,
  p be DTree-yielding FinSequence such that
A1: <*k*> in dom e1 and
A2: e1 = x-tree p;
  set o = <*k*>;
  deffunc F(Nat) = IFEQ($1,k+1,e2,p.$1);
  consider q being FinSequence such that
A3: len q = len p and
A4: for i being Nat st i in dom q holds q.i = F(i) from FINSEQ_1:sch 2;
A5: dom q = Seg len p by A3,FINSEQ_1:def 3;
A6: dom p = Seg len p by FINSEQ_1:def 3;
A7: dom q = dom p by A3,FINSEQ_3:31;
  now
    let x;
    assume
A8: x in dom q;
    then reconsider i = x as Element of NAT;
A9: q.i = IFEQ(i,k+1,e2,p.i) by A4,A8;
    i = k+1 or i <> k+1;
    then q.i = e2 or q.i = p.i by A9,FUNCOP_1:def 8;
    hence q.x is DecoratedTree by A7,A8,TREES_3:26;
  end;
  then reconsider q as DTree-yielding FinSequence by TREES_3:26;
  take q;
  consider j being Element of NAT, T being DecoratedTree, w being Node of T
  such that
A10: j < len p and T = p.(j+1) and
A11: <*k*> = <*j*>^w by A1,A2,TREES_4:11;
  <*j*> = <*k*> by A11,TREES_1:6;
  then
A12: j = <*k*>.1 by FINSEQ_1:def 8
    .= k by FINSEQ_1:def 8;
  then 1 <= k+1 & k+1 <= len p by A10,NAT_1:11,13;
  then
A13: k+1 in dom p by FINSEQ_3:27;
  then k+1 in Seg len p by FINSEQ_1:def 3;
  then
A14: q.(k+1) = IFEQ(k+1,k+1,e2,p.(k+1)) by A4,A5
    .= e2 by FUNCOP_1:def 8;
  consider qq being DTree-yielding FinSequence such that
A15: q = qq & dom(x-tree q) = tree doms qq by TREES_4:def 4;
  consider pp being DTree-yielding FinSequence such that
A16: p = pp & dom(x-tree p) = tree doms pp by TREES_4:def 4;
  reconsider dqq = doms qq as Tree-yielding FinSequence;
A17: len doms pp = len p by A16,TREES_3:40
    .= len doms qq
  by A3,A15,TREES_3:40;
A18: dom doms pp = dom p by A16,TREES_3:39;
A19: now
    let i be Element of NAT;
    assume
A20: i in dom doms pp & i <> k+1;
    then
A21: q.i = IFEQ(i,k+1,e2,p.i) by A4,A6,A18,A5
      .= p.i by A20,FUNCOP_1:def 8;
    reconsider pii = p.i as DecoratedTree by A18,A20,TREES_3:26;
    thus (doms pp).i = dom pii by A16,A18,A20,FUNCT_6:31
      .= (doms qq).i by A7,A15,A18,A20,A21,FUNCT_6:31;
  end;
  (doms qq).(k+1) = dom e2 by A7,A13,A14,A15,FUNCT_6:31;
  then
A22: dom(x-tree q) = dom e1 with-replacement (o, dom e2) by A2,A13,A15
  ,A16,A17,A18,A19,Th18;
  for f being FinSequence of NAT st
  f in dom e1 with-replacement (o, dom e2) holds
  (not o is_a_prefix_of f & (x-tree q).f = e1.f) or
  ex r being FinSequence of NAT st r in dom e2 & f = o^ r &
  (x-tree q).f = e2.r
  proof
    let f be FinSequence of NAT;
    assume
A23: f in dom e1 with-replacement (o, dom e2);
    reconsider o' = o as Element of dom e1 by A1;
    per cases by A23,Th15;
    suppose
A24:  not o' is_a_prefix_of f;
A25:  (x-tree q).f = e1.f
      proof
        per cases by A15,A22,A23,TREES_3:def 15;
        suppose
A26:      f = {};
          hence (x-tree q).f = x by TREES_4:def 4
            .= e1.f by A2,A26,TREES_4:def 4;
        end;
        suppose ex w being Element of NAT, u being FinSequence
          st w < len(dqq) & u in (dqq).(w+1) & f = <*w*>^u;
          then consider w be Element of NAT, u being FinSequence such that
A27:      w < len(doms q) and
A28:      u in (doms q).(w+1) and
A29:      f = <*w*>^u by A15;
          reconsider u as FinSequence of NAT by A29,FINSEQ_1:50;
          reconsider ww = <*w*> as FinSequence of NAT;
A30:      w+1 <> k+1 by A24,A29,TREES_1:8;
A31:      w < len q by A27,TREES_3:40;
          then 1 <= w+1 & w+1 <= len p by A3,NAT_1:11,13;
          then
A32:      w+1 in dom p by FINSEQ_3:27;
A33:      (x-tree q)|<*w*> = q.(w+1) by A31,TREES_4:def 4;
A34:      w+1 in dom doms p by A32,TREES_3:39;
A35:      w+1 in dom doms q by A7,A32,TREES_3:39;
A36:      q.(w+1) = IFEQ(w+1,k+1,e2,p.(w+1)) by A4,A6,A32,A5
            .= p.(w+1) by A30,FUNCOP_1:def 8;
          reconsider pw1 = p.(w+1) as DecoratedTree by A32,TREES_3:26;
A37:      (dom(x-tree q))|<*w*> = (doms q).(w+1) by A15,A35,Th16;
          consider pp being DTree-yielding FinSequence such that
A38:      p = pp & dom(x-tree p) = tree doms pp by TREES_4:def 4;
A39:      (dom(x-tree p))|<*w*> = (doms p).(w+1) by A34,A38,Th16
            .= dom pw1 by A32,FUNCT_6:31
            .= (doms q).(w+1) by A7,A32,A36,FUNCT_6:31;
          thus (x-tree q).f = ((x-tree q)|ww).u by A28,A29,A37,TREES_2:def 11
            .= ((x-tree p)|ww).u by A3,A31,A33,A36,TREES_4:def 4
            .= e1.f by A2,A28,A29,A39,TREES_2:def 11;
        end;
      end;
      assume o is_a_prefix_of f or (x-tree q).f <> e1.f;
      hence thesis by A24,A25;
    end;
    suppose ex t1 being Element of dom e2 st f=o'^t1;
      then consider r being Element of dom e2 such that
A40:  f = o^r;
      reconsider r as FinSequence of NAT;
      assume o is_a_prefix_of f or (x-tree q).f <> e1.f;
      take r; thus
A41:  r in dom e2;
A42:  (x-tree q)|o = q.(k+1) by A3,A10,A12,TREES_4:def 4;
A43:  r in (dom(x-tree q))|o by A1,A22,A41,TREES_1:66;
      thus f = o^r by A40;
      thus (x-tree q).f = e2.r by A14,A40,A42,A43,TREES_2:def 11;
    end;
  end;
  hence e1 with-replacement (o,e2) = x-tree q by A1,A22,TREES_2:def 12;
  thus len q = len p by A3;
  thus q.(k+1) = e2 by A14;
  let i be Element of NAT;
  assume i in dom p;
  then q.i = IFEQ(i,k+1,e2,p.i) by A4,A6,A5;
  hence thesis by FUNCOP_1:def 8;
end;

theorem
  for T being finite Tree, p being Element of T st p <> {}
  holds card (T|p) < card T
proof
  let T be finite Tree, p be Element of T;
  assume
A1: p <> {};
  reconsider p' = p as Element of NAT* by FINSEQ_1:def 11;
  set X = { p'^n where n is Element of NAT*: n in T|p };
A2: T|p,X are_equipotent
  proof
    deffunc F(Element of T|p) = p'^$1;
    consider f being Function such that
A3: dom f = T|p and
A4: for n being Element of T|p holds f.n = F(n) from FUNCT_1:sch 4;
    take f;
    thus f is one-to-one
    proof
      let x,y such that
A5:   x in dom f and
A6:   y in dom f and
A7:   f.x = f.y;
      reconsider m = x, n = y as Element of T|p by A3,A5,A6;
      p'^m = f.n by A4,A7
        .= p'^n by A4;
      hence x = y by FINSEQ_1:46;
    end;
    thus dom f = T|p by A3;
    thus rng f c= X
    proof
      let i;
      assume i in rng f;
      then consider n being set such that
A8:   n in dom f and
A9:   i = f.n by FUNCT_1:def 5;
      T|p c= NAT* by TREES_1:def 5;
      then reconsider n as Element of NAT* by A3,A8;
      f.n = p'^n by A3,A4,A8;
      hence i in X by A3,A8,A9;
    end;
    let i;
    assume i in X;
    then consider n being Element of NAT* such that
A10: i = p'^n and
A11: n in T|p;
    reconsider n as Element of T|p by A11;
    i = f.n by A4,A10;
    hence i in rng f by A3,FUNCT_1:def 5;
  end;
  then reconsider X as finite set by CARD_1:68;
A12: X c= T
  proof
    let i;
    assume i in X;
    then consider n being Element of NAT* such that
A13: i = p'^n & n in T|p;
    thus i in T by A13,TREES_1:def 9;
  end;
  X <> T
  proof
    assume X = T;
    then {} in X by TREES_1:47;
    then ex n being Element of NAT* st {} = p'^n & n in T|p;
    hence contradiction by A1;
  end;
  then
A14: X c< T by A12,XBOOLE_0:def 8;
  card X = card(T|p) by A2,CARD_1:21;
  hence card (T|p) < card T by A14,CARD_2:67;
end;

theorem Th21:
  for f being Function holds Card (f qua set) = Card dom f
proof
  let f be Function;
  dom f,f are_equipotent
  proof
    deffunc F(set) = [$1,f.$1];
    consider g being Function such that
A1: dom g = dom f and
A2: for x st x in dom f holds g.x = F(x) from FUNCT_1:sch 3;
    take g;
    thus g is one-to-one
    proof
      let x,y;
      assume
A3:   x in dom g & y in dom g;
      assume g.x = g.y;
      then [x,f.x] = g.y by A1,A2,A3
        .= [y,f.y] by A1,A2,A3;
      hence x = y by ZFMISC_1:33;
    end;
    thus dom g = dom f by A1;
    thus rng g c= f
    proof
      let i;
      assume i in rng g;
      then consider x such that
A4:   x in dom g and
A5:   g.x = i by FUNCT_1:def 5;
      g.x = [x,f.x] by A1,A2,A4;
      hence i in f by A1,A4,A5,FUNCT_1:8;
    end;
    let x,y;
    assume [x,y] in f;
    then
A6: x in dom f & y = f.x by FUNCT_1:8;
    then g.x = [x,y] by A2;
    hence [x,y] in rng g by A1,A6,FUNCT_1:def 5;
  end;
  hence Card (f qua set) = Card dom f by CARD_1:21;
end;

theorem Th22:
  for T, T1 being finite Tree, p being Element of T
  holds card(T with-replacement (p,T1)) + card (T|p) = card T + card T1
proof
  let T, T1, p;
  defpred P1[Element of T] means not p is_a_prefix_of $1;
  defpred P2[Element of T] means p is_a_prefix_of $1;
  set A = { t : P1[t] };
  set B = { t : P2[t] };
  set C = { p^t1 : not contradiction };
A1: A is Subset of T from DOMAIN_1:sch 7;
A2: B is Subset of T from DOMAIN_1:sch 7;
  then reconsider A,B as finite set by A1;
A3: T with-replacement (p,T1) = A \/ C by Th14;
A4: A misses C
  proof
    assume not thesis;
    then consider x such that
A5: x in A /\ C by XBOOLE_0:4;
    x in A by A5,XBOOLE_0:def 3;
    then consider t such that
A6: x = t & not p is_a_prefix_of t;
    x in C by A5,XBOOLE_0:def 3;
    then ex t1 st x = p^t1;
    hence contradiction by A6,TREES_1:8;
  end;
  now
    let x;
    hereby
      assume x in T;
      then reconsider t = x as Element of T;
      p is_a_prefix_of t or not p is_a_prefix_of t;
      hence x in A or x in B;
    end;
    assume x in A or x in B;
    hence x in T by A1,A2;
  end;
  then
A7: T = A \/ B by XBOOLE_0:def 2;
A8: A misses B
  proof
    assume not thesis;
    then consider x such that
A9: x in A /\ B by XBOOLE_0:4;
    x in A & x in B by A9,XBOOLE_0:def 3;
    then (ex t st x = t & not p is_a_prefix_of t)
    & (ex t st x = t & p is_a_prefix_of t);
    hence contradiction;
  end;
A10: T1,C are_equipotent
  proof
    deffunc F(Element of T1) = p^$1;
    consider f being Function such that
A11: dom f = T1 and
A12: for n being Element of T1 holds f.n = F(n) from FUNCT_1:sch 4;
    take f;
    thus f is one-to-one
    proof
      let x,y such that
A13:  x in dom f and
A14:  y in dom f and
A15:  f.x = f.y;
      reconsider m = x, n = y as Element of T1 by A11,A13,A14;
      p^m = f.n by A12,A15
        .= p^n by A12;
      hence x = y by FINSEQ_1:46;
    end;
    thus dom f = T1 by A11;
    thus rng f c= C
    proof
      let i;
      assume i in rng f;
      then consider n being set such that
A16:  n in dom f and
A17:  i = f.n by FUNCT_1:def 5;
      T1 c= NAT* by TREES_1:def 5;
      then reconsider n as Element of NAT* by A11,A16;
      f.n = p^n by A11,A12,A16;
      hence i in C by A11,A16,A17;
    end;
    let i;
    assume i in C;
    then consider n being Element of T1 such that
A18: i = p^n;
    i = f.n by A12,A18;
    hence i in rng f by A11,FUNCT_1:def 5;
  end;
  then reconsider C as finite set by CARD_1:68;
A19: card T1 = card C by A10,CARD_1:21;
  T|p,B are_equipotent by Th13;
  then card(T|p) = card B by CARD_1:21;
  hence card(T with-replacement (p,T1)) + card (T|p) =
  card A + card C + card B by A3,A4,CARD_2:53
    .= card A + card B + card C
    .= card T + card T1 by A7,A8,A19,CARD_2:53;
end;

theorem
  for T, T1 being finite DecoratedTree, p being Element of dom T
  holds card(T with-replacement (p,T1)) + card (T|p) = card T + card T1
proof
  let T, T1 be finite DecoratedTree, p be Element of dom T;
A1: dom (T with-replacement(p, T1)) =
  dom T with-replacement (p, dom T1) & dom (T|p) = (dom T)|p
  by TREES_2:def 11,def 12;
A2: card dom T = card T & card dom T1 = card T1 by Th21;
  card dom (T with-replacement(p,T1)) = card(T with-replacement (p,T1)) &
  card dom (T|p) = card (T|p) by Th21;
  hence card(T with-replacement (p,T1)) + card (T|p)
  = card T + card T1 by A1,A2,Th22;
end;

registration
  let x be set;
  cluster root-tree x -> finite;
  coherence
  proof
    root-tree x = {[{},x]} by TREES_4:6;
    hence thesis;
  end;
end;

theorem
  for x being set holds card root-tree x = 1
proof
  let x be set;
  root-tree x = {[{},x]} by TREES_4:6;
  hence card root-tree x = 1 by CARD_1:50;
end;

begin :: Addenda

:: from AMISTD_2

theorem
  for F being non empty finite set holds card F - 1 = card F -' 1
proof
  let F be non empty finite set;
  card F - 1 >= 0 by NAT_1:14,XREAL_1:50;
  hence thesis by BINARITH:def 3;
end;

:: from AMISTD_2, 2006.03.26, A.T.

theorem
  for f, g being Function holds
  dom f,dom g are_equipotent iff f,g are_equipotent
proof
  let f, g be Function;
A1: Card(f qua set) = Card dom f & Card(g qua set) = Card dom g by Th21;
  hereby
    assume dom f,dom g are_equipotent;
    then Card dom f = Card dom g by CARD_1:21;
    hence f,g are_equipotent by A1,CARD_1:21;
  end;
  assume f,g are_equipotent;
  then Card(f qua set) = Card(g qua set) by CARD_1:21;
  hence dom f,dom g are_equipotent by A1,CARD_1:21;
end;

theorem
  for f, g being finite Function st dom f misses dom g
  holds card (f +* g) = card f + card g
proof
  let f, g be finite Function such that
A1: dom f misses dom g;
  thus card (f +* g) = card dom (f +* g) by Th21
    .= card (dom f \/ dom g) by FUNCT_4:def 1
    .= card dom f + card dom g by A1,CARD_2:53
    .= card dom f + card g by Th21
    .= card f + card g by Th21;
end;

:: from SCMPDS_9. 2008.05.06, A.T.

canceled;

theorem
  {k where k is Element of NAT: k > 1} is infinite
proof
  set X = {k where k is Element of NAT: k > 1};
  assume
A1: X is finite;
A2: X c= NAT
  proof
    let x be set;
    assume x in X;
    then ex k being Element of NAT st x = k & k > 1;
    hence thesis;
  end;
  2 in X;
  then reconsider X as non empty finite Subset of NAT by A1,A2;
  set m = max X;
  m in X by XXREAL_2:def 8;
  then consider k being Element of NAT such that
A3: m = k and
A4: k > 1;
  k+1 > k+0 by XREAL_1:10;
  then k+1 > 1 by A4,XXREAL_0:2;
  then m+1 in X by A3;
  then m+1 <= m+0 by XXREAL_2:def 8;
  hence contradiction by XREAL_1:10;
end;

