:: Development of Terminology for {\bf SCM}
::  by Grzegorz Bancerek and Piotr Rudnicki
::
:: Received October 8, 1993
:: Copyright (c) 1993 Association of Mizar Users

environ

 vocabularies AMI_3, INT_1, FINSEQ_1, AMI_1, AMI_2, FUNCT_1, RELAT_1, ARYTM_1,
      NAT_1, MCART_1, SCM_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, NUMBERS, XCMPLX_0, NAT_1,
      NAT_D, INT_1, MCART_1, RELAT_1, FUNCT_1, FUNCT_2, FINSEQ_1, STRUCT_0,
      AMI_1, AMI_2, AMI_3, XXREAL_0;
 constructors XXREAL_0, NAT_1, MEMBERED, AMI_2, AMI_3, NAT_D;
 registrations AMI_1, AMI_3, INT_1, XBOOLE_0, RELSET_1, FINSEQ_1, FRAENKEL,
      XREAL_0, MEMBERED, ORDINAL1, SETFAM_1, XXREAL_0, CARD_3;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions AMI_1;
 theorems NAT_1, INT_1, MCART_1, FUNCT_1, FUNCT_2, FINSEQ_1, CARD_3, AMI_1,
      AMI_2, AMI_3, FINSEQ_3, RELSET_1, XXREAL_0, ORDINAL1;
 schemes NAT_1, PARTFUN1, WELLORD2;

begin

definition
 let i be Integer;
 redefine func <*i*> -> FinSequence of INT;
 coherence proof
  reconsider i1 = i as Element of INT by INT_1:def 2;
      <*i1*> is FinSequence of INT;
  hence thesis;
 end;
end;

 Lm1: for s being State of SCM
     holds IC s = s.0 & CurInstr s = s.(s.0) by AMI_3:4;

canceled;

theorem Th2: for s being State of SCM, k being Element of NAT
     holds CurInstr (Computation s).k = s.(IC (Computation s).k) &
       CurInstr (Computation s).k = s.((Computation s).k.0)
          by  AMI_3:4, AMI_1:54;

theorem Th3:
for s being State of SCM
 st ex k being Element of NAT st s.(IC (Computation s).k) = halt SCM
  holds s is halting proof
 let s be State of SCM;
 given k being Element of NAT such that
A1: s.(IC (Computation s).k) = halt SCM;
 take k;
 thus CurInstr (Computation s).k = halt SCM by A1,Th2;
end;

theorem Th4:
for s being State of SCM, k being Element of NAT
  st s.(IC (Computation s).k) = halt SCM
   holds (Result s) = (Computation s).k proof
 let s be State of SCM, k be Element of NAT; assume
A1: s.(IC (Computation s).k) = halt SCM;
then A2: s is halting by Th3;
       CurInstr (Computation s).k = halt SCM by A1,Th2;
  hence Result s = (Computation s).k by A2,AMI_1:def 22;
end;

canceled 2;

theorem Th7: for n, m being Element of NAT holds
  IC SCM <> il.n & IC SCM <> dl.n & il.n <> dl.m by AMI_3:56,57;

Lm2: now let p be FinSequence, n be Element of NAT; assume n < len p;
       then n+1 >= 0+1 & n+1 <= len p by NAT_1:13;
       then n+1 in dom p & dom p = Seg len p by FINSEQ_1:def 3,FINSEQ_3:27;
      hence n+1 in dom p & p.(n+1) in rng p by FUNCT_1:def 5;
 end;

Lm3:
  now let n be Element of NAT, x be set; let p be FinSequence of x; assume
        n < len p; then p.(n+1) in rng p & rng p c= x by Lm2,FINSEQ_1:def 4;
   hence p.(n+1) in x;
  end;

definition
 let I be FinSequence of the Instructions of SCM,
     D be FinSequence of INT,
     il, ps, ds be Element of NAT;
 mode State-consisting of il, ps, ds, I, D -> State of SCM means
:Def1:  IC it = il.il &
  (for k being Element of NAT st k < len I holds it.il.(ps+k) = I.(k+1)) &
  (for k being Element of NAT st k < len D holds it.dl.(ds+k) = D.(k+1));
 existence proof
   defpred X[set,set] means
     (ex n being Element of NAT st $1 = il.(ps+n) & n < len I & $2 = I.(n+1))
     or
      $2 = halt SCM &
      not ex n being Element of NAT st $1 = il.(ps+n) & n < len I;
A1: for x being set st x in NAT ex y being set st y in SCM-Instr & X[x,y]
  proof let x be set;
     assume x in NAT;
     per cases;
     suppose ex n being Element of NAT st x = il.(ps+n) & n < len I;
       then consider n being Element of NAT such that
 A2:   x = il.(ps+n) & n < len I;
       reconsider y = I.(n+1) as Element of the Instructions of SCM
               by A2,Lm3;
      take y;
      thus y in SCM-Instr by AMI_3:def 1;
      thus X[x,y] by A2;
    end;
    suppose
A3:    not ex n being Element of NAT st x = il.(ps+n) & n < len I;
       reconsider y = halt SCM as Element of the Instructions of SCM;
     take y;
     thus y in SCM-Instr by AMI_3:def 1;
     thus X[x,y] by A3;
   end;
   end;
  consider I1 being Function such that
A4: dom I1 = NAT & rng I1 c= SCM-Instr &
    for x being set st x in NAT holds X[x,I1.x] from WELLORD2:sch 1(A1);
  reconsider I1 as Function of NAT, the Instructions of SCM
    by A4,AMI_3:def 1,FUNCT_2:def 1,RELSET_1:11;
A5:  0 in INT by INT_1:def 2;
   defpred X[set,set] means
     (ex n being Element of NAT st $1 = dl.(ds+n) & n < len D & $2 = D.(n+1))
     or
      $2 = 0 & not ex n being Element of NAT st $1 = dl.(ds+n) & n < len D;
A6: now let x be set;
     assume x in NAT;
     per cases;
     suppose ex n being Element of NAT st x = dl.(ds+n) & n < len D;
       then consider n being Element of NAT such that
 A7:   x = dl.(ds+n) & n < len D;
      take y = D.(n+1);
      thus y in INT by A7,Lm3;
      thus X[x,y] by A7;
    end;
    suppose not ex n being Element of NAT st x = dl.(ds+n) & n < len D;
     hence ex y being set st y in INT &  X[x,y] by A5;
   end;
   end;
  consider D1 being Function such that
A8: dom D1 = NAT & rng D1 c= INT &
    for x being set st x in NAT holds X[x,D1.x] from WELLORD2:sch 1(A6);
  reconsider D1 as Function of NAT, INT by A8,FUNCT_2:def 1,RELSET_1:11;
A9: dom the Object-Kind of SCM = NAT by AMI_3:def 1,FUNCT_2:def 1;
  consider s being State of SCM;
  deffunc U(set) = il.il;
  deffunc V(set) = s.$1;
  defpred X[set] means $1 = 0;
  consider s1 being Function such that
A10: dom s1 = NAT &
    for x being set st x in NAT holds
     (X[x] implies s1.x = U(x)) & (not X[x] implies s1.x = V(x)) from
PARTFUN1:sch 1;
      now let x be set; assume x in NAT;
      then reconsider n = x as Element of NAT;
   per cases;
   suppose x = 0;
     then s1.n = il.il & (the Object-Kind of SCM).x = SCM-Instr-Loc
       by A10,AMI_2:def 5,AMI_3:def 1;
    hence s1.x in (the Object-Kind of SCM).x by AMI_3:def 1;
   end;
   suppose x <> 0; then s1.n = s.x by A10;
    hence s1.x in (the Object-Kind of SCM).x by A9,CARD_3:18;
  end;
  end;
  then reconsider s1 as State of SCM by A9,A10,CARD_3:18;
  deffunc U(set) = I1.$1;
  deffunc V(set) = s1.$1;
  defpred X[set] means ex n being Element of NAT st $1 = il.n;
  consider s2 being Function such that
A11: dom s2 = NAT &
    for x being set st x in NAT holds
     (X[x] implies s2.x = U(x)) &
     (not X[x] implies s2.x = V(x)) from PARTFUN1:sch 1;
      now let x be set; assume x in NAT;
      then reconsider n = x as Element of NAT;
   per cases;
   suppose ex n being Element of NAT st x = il.n;
     then s2.x = I1.n & x is Instruction-Location of SCM by A11;
     then s2.x is Instruction of SCM & (the Object-Kind of SCM).x = SCM-Instr
      by AMI_2:11,AMI_3:def 1;
    hence s2.x in (the Object-Kind of SCM).x by AMI_3:def 1;
   end;
   suppose not ex n being Element of NAT st x = il.n;
    then s2.n = s1.x by A11;
    hence s2.x in (the Object-Kind of SCM).x by A9,CARD_3:18;
  end;
  end;
  then reconsider s2 as State of SCM by A9,A11,CARD_3:18;
  deffunc U(set) = D1.$1;
  deffunc V(set) = s2.$1;
  defpred X[set] means ex n being Element of NAT st $1 = dl.n;

  consider s3 being Function such that
A12: dom s3 = NAT &
    for x being set st x in NAT holds
     (X[x] implies s3.x = U(x)) &
     (not X[x] implies s3.x = V(x)) from PARTFUN1:sch 1;
      now let x be set; assume x in NAT;
      then reconsider n = x as Element of NAT;
   per cases;
   suppose ex n being Element of NAT st x = dl.n;
     then s3.x = D1.n & x in SCM-Data-Loc by A12,AMI_3:def 2;
     then s3.x in INT & (the Object-Kind of SCM).x = INT by AMI_2:10
,AMI_3:def 1;
    hence s3.x in (the Object-Kind of SCM).x;
   end;
   suppose not ex n being Element of NAT st x = dl.n;
    then s3.n = s2.x by A12;
    hence s3.x in (the Object-Kind of SCM).x by A9,CARD_3:18;
  end;
  end;
  then reconsider s3 as State of SCM by A9,A12,CARD_3:18;

  take s3;
  thus IC s3 = s2.0 by  AMI_3:4,A12,Th7
            .= s1.0 by A11,Th7,AMI_3:4
            .= il.il by A10;
  hereby let k be Element of NAT; assume k<len I;
  then consider k' being Element of NAT such that
A13: il.(ps+k) = il.(ps+k') & k' < len I & I1.il.(ps+k) = I.(k'+1)
     by A4,AMI_3:def 1;
A14:    ps+k = ps+k' by A13,AMI_3:53;
       for n being Element of NAT holds il.(ps+k) <> dl.n by AMI_3:56;
   hence s3.il.(ps+k) = s2.il.(ps+k) by A12,AMI_3:def 1
               .= I.(k+1) by  A11,AMI_3:def 1,A13,A14;
   end;
   let k be Element of NAT; assume k < len D;
   then consider k' being Element of NAT such that
A15: dl.(ds+k) = dl.(ds+k') & k' < len D & D1.dl.(ds+k) = D.(k'+1)
                by A8,AMI_3:def 1;
A16:     ds+k = ds+k' by A15,AMI_3:52;
   thus s3.dl.(ds+k) = D.(k+1) by  A12,AMI_3:def 1,A15,A16;
 end;
end;

canceled 6;

theorem
    for I1, I2, I3, I4, I5, I6, I7, I8, I9 being Instruction of SCM,
    i1, i2, i3, i4 being Integer,
    il being Element of NAT,
    s being State-consisting of il, 0, 0,
             <*I1*>^<*I2*>^<*I3*>^<*I4*>^<*I5*>^<*I6*>^<*I7*>^<*I8*>^<*I9*>,
             <*i1*>^<*i2*>^<*i3*>^<*i4*>
 holds IC s = il.il &
       s.il.0 = I1 & s.il.1 = I2 & s.il.2 = I3 & s.il.3 = I4 &
       s.il.4 = I5 & s.il.5 = I6 & s.il.6 = I7 & s.il.7 = I8 & s.il.8 = I9 &
       s.dl.0 = i1 & s.dl.1 = i2 & s.dl.2 = i3 & s.dl.3 = i4
proof
let I1, I2, I3, I4, I5, I6, I7, I8, I9 be Instruction of SCM,
    i1, i2, i3, i4 be Integer,
    il  be Element of NAT,
    s be State-consisting of il, 0, 0,
             <*I1*>^<*I2*>^<*I3*>^<*I4*>^<*I5*>^<*I6*>^<*I7*>^<*I8*>^<*I9*>,
             <*i1*>^<*i2*>^<*i3*>^<*i4*>;
thus IC s = il.il by Def1;
 set I = <*I1*>^<*I2*>^<*I3*>^<*I4*>^<*I5*>^<*I6*>^<*I7*>^<*I8*>^<*I9*>,
     D = <*i1*>^<*i2*>^<*i3*>^<*i4*>;
A1:   I.(0+1) = I1 & I.(1+1) = I2 & I.(2+1) = I3 & I.(3+1) = I4 & I.(4+1)=I5 &
     I.(5+1) = I6 & I.(6+1) = I7 & I.(7+1) = I8 & I.(8+1) = I9 by FINSEQ_1:92;
A2:   D.(0+1) = i1 & D.(1+1) = i2 & D.(2+1) = i3 & D.(3+1) = i4 by FINSEQ_1:87;
         len I=9 & 0+0=0&0+1=1&0+2=2&0+3=3&0+4=4&0+5=5&0+6=6&0+7=7&0+8=8 by
FINSEQ_1:92
;
hence s.il.0 = I1 & s.il.1 = I2 & s.il.2 = I3 & s.il.3 = I4 &
     s.il.4 = I5 & s.il.5 = I6 & s.il.6 = I7 & s.il.7 = I8 & s.il.8 = I9
                                                           by A1,Def1;
         len D = 4 & 0+0=0&0+1=1&0+2=2&0+3=3 by FINSEQ_1:87;
hence s.dl.0 = i1 & s.dl.1 = i2 & s.dl.2 = i3 & s.dl.3 = i4 by A2,Def1;
end;

theorem Th15:
for I1, I2 being Instruction of SCM,
    i1, i2 being Integer,
    il being Element of NAT,
    s being State-consisting of il, 0, 0, <*I1*>^<*I2*>, <*i1*>^<*i2*>
 holds IC s = il.il &
       s.il.0 = I1 & s.il.1 = I2 &
       s.dl.0 = i1 & s.dl.1 = i2
proof
let I1, I2 be Instruction of SCM, i1, i2 be Integer,
    il be Element of NAT,
    s be State-consisting of il, 0, 0, <*I1*>^<*I2*>, <*i1*>^<*i2*>;
 thus IC s = il.il by Def1;
  set ins = <*I1*>^<*I2*>, data = <*i1*>^<*i2*>;
      ins = <*I1, I2*> & data = <*i1, i2*> by FINSEQ_1:def 9;
then A1:  len ins = 2 & len data = 2 & ins.(0+1) = I1 & ins.(1+1) = I2 &
                           data.(0+1) = i1 & data.(1+1) = i2 by FINSEQ_1:61;
       1 < 2 & 0+0=0&0+1=1;
 hence s.il.0 = I1 & s.il.1 = I2 &
       s.dl.0 = i1 & s.dl.1 = i2 by A1,Def1;
 end;

definition
let N be with_non-empty_elements set;
 let S be halting IC-Ins-separated definite
    (non empty non void AMI-Struct over N);
 let s be State of S such that
A1: s is halting;
 func Complexity s -> Element of NAT means
:Def2:  CurInstr((Computation s).it) = halt S &
  for k being Element of NAT st CurInstr((Computation s).k) = halt S
  holds it <= k;
  existence proof
    defpred X[Element of NAT] means CurInstr((Computation s).$1)=halt S;
A2: ex k being Element of NAT st X[k] by A1,AMI_1:def 20;
   thus ex k being Element of NAT st X[k] &
    for n being Element of NAT st X[n] holds k <= n from NAT_1:sch 5 ( A2 );
  end;
  uniqueness proof
   let it1, it2 be Element of NAT;
   assume
A3:  not thesis;
    then it1 <= it2 & it2 <= it1;
   hence contradiction by A3,XXREAL_0:1;
  end;
 end;

notation
let N be with_non-empty_elements set;
 let S be halting IC-Ins-separated definite
    (non empty non void AMI-Struct over N);
 let s be State of S;
 synonym LifeSpan s for Complexity s;
end;

theorem Th16:
 for s being State of SCM, k being Element of NAT
  holds s.(IC (Computation s).k) <> halt SCM &
     s.(IC (Computation s).(k+1)) = halt SCM
  iff Complexity s = k+1 & s is halting
proof let s be State of SCM, k be Element of NAT;
  hereby assume
        s.(IC (Computation s).k) <> halt SCM &
    s.(IC (Computation s).(k+1)) = halt SCM;
then A1:  s is halting & CurInstr (Computation s).k <> halt SCM &
    CurInstr (Computation s).(k+1) = halt SCM by Th2,Th3;
        now let i be Element of NAT; assume
A2:    CurInstr (Computation s).i = halt SCM & k+1 > i;
      then i <= k by NAT_1:13;
     hence contradiction by A1,A2,AMI_1:52;
    end;
   hence Complexity s = k+1 & s is halting by A1,Def2;
  end;
  assume
 A3: Complexity s = k+1 & s is halting;
then A4: CurInstr((Computation s).(k+1)) = halt SCM &
   for l being Element of NAT st CurInstr((Computation s).l)=halt SCM
   holds (k+1)<=l
                                                       by Def2;
       now assume CurInstr((Computation s).k) = halt SCM;
    then k+1 <= k by A3,Def2;
    hence contradiction by NAT_1:13;
   end;
  hence thesis by A4,Th2;
end;

theorem Th17:
 for s being State of SCM, k being Element of NAT
  st IC (Computation s).k <> IC (Computation s).(k+1) &
     s.(IC (Computation s).(k+1)) = halt SCM
  holds Complexity s = k+1 proof
 let s be State of SCM, k be Element of NAT; assume
A1: IC (Computation s).k <> IC (Computation s).(k+1) &
   s.(IC (Computation s).(k+1)) = halt SCM;
       now assume s.(IC (Computation s).k) = halt SCM;
     then CurInstr (Computation s).k = halt SCM & k <= k+1 by Th2,NAT_1:11;
    hence contradiction by A1,AMI_1:52;
   end;
 hence thesis by A1,Th16;
end;

Lm4: for n being Element of NAT holds Next il.n = il.(n+1) proof
 let n be Element of NAT;
  consider iN being Element of SCM-Instr-Loc such that
A1: iN = il.n & Next il.n = Next iN by AMI_3:def 11;
 thus Next il.n = (iN + 2) by A1,AMI_2:def 15
              .= 2*n+2*1 + 2 by A1,AMI_3:def 20
              .= 2*(n+1) + 2
              .= il.(n+1) by AMI_3:def 20;
end;

Lm5:
 for k being Element of NAT, s being State of SCM
  holds (Computation s).(k+1) = Exec(CurInstr (Computation s).k,
                                     (Computation s).k) proof
 let k be Element of NAT, s be State of SCM;
 thus (Computation s).(k+1) = Following (Computation s).k by AMI_1:def 19
                    .= Exec(CurInstr (Computation s).k,
                                     (Computation s).k);
end;

Lm6:
now let k, n be Element of NAT, s be State of SCM, a, b be Data-Location;
 assume
A1: IC (Computation s).k = il.n;
A2: (Computation s).k.il.n = s.il.n by AMI_1:54;
   set csk = (Computation s).k;
   set csk1 = (Computation s).(k+1);
A3: csk.0 = il.n by A1,Lm1;
   assume
A4:  s.il.n = a := b or s.il.n = AddTo(a,b) or s.il.n = SubFrom(a, b) or
      s.il.n = MultBy(a, b) or a<>b & s.il.n = Divide(a,b);
    thus
A5:  csk1 = (Exec(CurInstr csk, csk)) by Lm5
           .= (Exec(s.il.n, csk)) by A2,A3,Lm1;
    thus IC csk1 = Next IC csk by  A4,A5,AMI_3:8,9,10,11,
12
      .= il.(n+1) by A1,Lm4;
end;

theorem Th18:
for k, n being Element of NAT, s being State of SCM, a, b being Data-Location
 st IC (Computation s).k = il.n & s.il.n = a := b
  holds IC (Computation s).(k+1) = il.(n+1) &
        (Computation s).(k+1).a = (Computation s).k.b &
        for d being Data-Location st d <> a holds
                              (Computation s).(k+1).d = (Computation s).k.d
proof let k, n be Element of NAT, s be State of SCM, a, b be Data-Location;
 assume
A1: IC (Computation s).k = il.n;
   set csk = (Computation s).k;
   set csk1 = (Computation s).(k+1);
  assume
A2:  s.il.n = a := b;
    then csk1 = Exec(a:=b, csk) by A1,Lm6;
  hence IC csk1 = il.(n+1) & csk1.a = csk.b &
    for d being Data-Location st d <> a holds csk1.d = csk.d
      by A1,A2,Lm6,AMI_3:8;
end;

theorem Th19:
for k, n being Element of NAT, s being State of SCM, a, b being Data-Location
 st IC (Computation s).k = il.n & s.il.n = AddTo(a,b)
  holds IC (Computation s).(k+1) = il.(n+1) &
        (Computation s).(k+1).a = (Computation s).k.a+(Computation s).k.b &
        for d being Data-Location st d <> a holds
                              (Computation s).(k+1).d = (Computation s).k.d
proof let k, n be Element of NAT, s be State of SCM, a, b be Data-Location;
 assume
A1: IC (Computation s).k = il.n;
   set csk = (Computation s).k;
   set csk1 = (Computation s).(k+1);
  assume
A2:  s.il.n = AddTo(a,b);
    then csk1 = Exec(AddTo(a,b), csk) by A1,Lm6;
  hence IC csk1 = il.(n+1) & csk1.a = csk.a + csk.b &
    for d being Data-Location st d <> a holds csk1.d = csk.d
      by A1,A2,Lm6,AMI_3:9;
end;

theorem Th20:
for k, n being Element of NAT, s being State of SCM, a, b being Data-Location
 st IC (Computation s).k = il.n & s.il.n = SubFrom(a,b)
  holds IC (Computation s).(k+1) = il.(n+1) &
        (Computation s).(k+1).a = (Computation s).k.a-(Computation s).k.b &
        for d being Data-Location st d <> a holds
                              (Computation s).(k+1).d = (Computation s).k.d
proof let k, n be Element of NAT, s be State of SCM, a, b be Data-Location;
 assume
A1: IC (Computation s).k= il.n;
   set csk = (Computation s).k;
   set csk1 = (Computation s).(k+1);
  assume
A2:  s.il.n = SubFrom(a,b);
    then csk1 = Exec(SubFrom(a,b), csk) by A1,Lm6;
   hence IC csk1 = il.(n+1) & csk1.a = csk.a - csk.b &
    for d being Data-Location st d <> a holds csk1.d = csk.d
      by A1,A2,Lm6,AMI_3:10;
end;

theorem Th21:
for k, n being Element of NAT, s being State of SCM, a, b being Data-Location
 st IC (Computation s).k = il.n & s.il.n = MultBy(a,b)
  holds IC (Computation s).(k+1) = il.(n+1) &
        (Computation s).(k+1).a = (Computation s).k.a*(Computation s).k.b &
        for d being Data-Location st d <> a holds
                              (Computation s).(k+1).d = (Computation s).k.d
proof let k, n be Element of NAT, s be State of SCM, a, b be Data-Location;
 assume
A1: IC (Computation s).k = il.n;
   set csk = (Computation s).k;
   set csk1 = (Computation s).(k+1);
  assume
A2:  s.il.n = MultBy(a,b);
    then csk1 = Exec(MultBy(a,b), csk) by A1,Lm6;
   hence IC csk1 = il.(n+1) & csk1.a = csk.a * csk.b &
    for d being Data-Location st d <> a holds csk1.d = csk.d
      by A1,A2,Lm6,AMI_3:11;
end;

theorem Th22:
for k, n being Element of NAT, s being State of SCM, a, b being Data-Location
 st IC (Computation s).k = il.n & s.il.n = Divide(a,b) & a<>b
  holds IC (Computation s).(k+1) = il.(n+1) &
    (Computation s).(k+1).a = (Computation s).k.a div (Computation s).k.b &
    (Computation s).(k+1).b = (Computation s).k.a mod (Computation s).k.b &
        for d being Data-Location st d <> a & d <> b holds
                              (Computation s).(k+1).d = (Computation s).k.d
proof let k, n be Element of NAT, s be State of SCM, a, b be Data-Location;
 assume
A1: IC (Computation s).k = il.n;
   set csk = (Computation s).k;
   set csk1 = (Computation s).(k+1);
  assume
A2:  s.il.n = Divide(a,b) & a <> b;
    then csk1 = Exec(Divide(a,b), csk) by A1,Lm6;
   hence IC csk1 = il.(n+1) &
    csk1.a = csk.a div csk.b & csk1.b = csk.a mod csk.b &
    for d being Data-Location st d <> a & d <> b holds csk1.d = csk.d
      by A1,A2,Lm6,AMI_3:12;
end;

theorem Th23:
for k, n being Element of NAT, s being State of SCM,
    il being Instruction-Location of SCM
 st IC (Computation s).k = il.n & s.il.n = goto il
 holds IC (Computation s).(k+1) = il &
       for d being Data-Location holds
                              (Computation s).(k+1).d = (Computation s).k.d
proof
let k, n be Element of NAT, s be State of SCM,
    il be Instruction-Location of SCM; assume
A1: IC (Computation s).k = il.n & s.il.n = goto il;
A2: (Computation s).k.il.n = s.il.n by AMI_1:54;
   set csk = (Computation s).k;
   set csk1 = (Computation s).(k+1);
 A3: csk1 = Exec(CurInstr csk, csk) by Lm5
           .= Exec(goto il, csk) by A1,A2;
 thus IC csk1 = il by A3,AMI_3:13;
 thus thesis by A3,AMI_3:13;
end;

theorem Th24:
for k, n being Element of NAT, s being State of SCM, a being Data-Location,
    il being Instruction-Location of SCM
 st IC (Computation s).k = il.n & s.il.n = a =0_goto il
 holds ((Computation s).k.a = 0 implies IC (Computation s).(k+1) = il) &
       ((Computation s).k.a <>0 implies IC (Computation s).(k+1) = il.(n+1)) &
       for d being Data-Location holds
                              (Computation s).(k+1).d = (Computation s).k.d
proof
let k, n be Element of NAT, s be State of SCM, a be Data-Location,
    il be Instruction-Location of SCM; assume
A1: IC (Computation s).k = il.n & s.il.n = a =0_goto il;
A2: (Computation s).k.il.n = s.il.n by AMI_1:54;
   set csk = (Computation s).k;
   set csk1 = (Computation s).(k+1);
 A3: csk1 = Exec(CurInstr csk, csk) by Lm5
           .= Exec(a =0_goto il, csk) by A1,A2;
 thus csk.a = 0 implies IC csk1 = il by A3,AMI_3:14;
 hereby assume
       csk.a <> 0;
  hence IC csk1 = Next il.n by A1,A3,AMI_3:14
               .= il.(n+1) by Lm4;
 end;
 thus thesis by A3,AMI_3:14;
end;

theorem Th25:
for k, n being Element of NAT, s being State of SCM, a being Data-Location,
    il being Instruction-Location of SCM
 st IC (Computation s).k = il.n & s.il.n = a >0_goto il
  holds ((Computation s).k.a > 0 implies IC (Computation s).(k+1) = il) &
   ((Computation s).k.a <= 0 implies IC (Computation s).(k+1) = il.(n+1)) &
       for d being Data-Location holds
                              (Computation s).(k+1).d = (Computation s).k.d
proof
let k, n be Element of NAT, s be State of SCM, a be Data-Location,
    il be Instruction-Location of SCM; assume
A1: IC (Computation s).k = il.n & s.il.n = a >0_goto il;
A2: (Computation s).k.il.n = s.il.n by AMI_1:54;
   set csk = (Computation s).k;
   set csk1 = (Computation s).(k+1);
 A3: csk1 = Exec(CurInstr csk, csk) by Lm5
           .= Exec(a >0_goto il, csk) by A1,A2;
 thus csk.a > 0 implies IC csk1 = il by A3,AMI_3:15;
 hereby assume
       csk.a <= 0;
  hence IC csk1 = Next il.n by A1,A3,AMI_3:15
               .= il.(n+1) by Lm4;
 end;
 thus thesis by A3,AMI_3:15;
end;

theorem Th26:
 (halt SCM)`1 = 0 &
 (for a, b being Data-Location holds (a := b)`1 = 1) &
 (for a, b being Data-Location holds (AddTo(a,b))`1 = 2) &
 (for a, b being Data-Location holds (SubFrom(a,b))`1 = 3) &
 (for a, b being Data-Location holds (MultBy(a,b))`1 = 4) &
 (for a, b being Data-Location holds (Divide(a,b))`1 = 5) &
 (for i being Instruction-Location of SCM holds (goto i)`1 = 6) &
 (for a being Data-Location, i being Instruction-Location of SCM
     holds (a =0_goto i)`1 = 7) &
 (for a being Data-Location, i being Instruction-Location of SCM
     holds (a >0_goto i)`1 = 8)
proof
  thus (halt SCM)`1 = 0 by AMI_3:71,MCART_1:7;
 hereby let a, b be Data-Location;
       a := b = [1, <*a,b*>] by AMI_3:def 3;
  hence (a := b)`1 = 1 by MCART_1:7;
 end;
 hereby let a, b be Data-Location;
       AddTo(a,b) = [2, <*a,b*>] by AMI_3:def 4;
  hence (AddTo(a,b))`1 = 2 by MCART_1:7;
 end;
 hereby let a, b be Data-Location;
       SubFrom(a,b) = [3, <*a,b*>] by AMI_3:def 5;
  hence (SubFrom(a,b))`1 = 3 by MCART_1:7;
 end;
 hereby let a, b be Data-Location;
       MultBy(a,b) = [4, <*a,b*>] by AMI_3:def 6;
  hence (MultBy(a,b))`1 = 4 by MCART_1:7;
 end;
 hereby let a, b be Data-Location;
       Divide(a,b) = [5, <*a,b*>] by AMI_3:def 7;
  hence (Divide(a,b))`1 = 5 by MCART_1:7;
 end;
 hereby let i be Instruction-Location of SCM;
       goto i = [6, <*i*>] by AMI_3:def 8;
  hence (goto i)`1 = 6 by MCART_1:7;
 end;
 hereby let a be Data-Location, i be Instruction-Location of SCM;
       a =0_goto i = [7, <*i,a*>] by AMI_3:def 9;
  hence (a =0_goto i)`1 = 7 by MCART_1:7;
 end;
 hereby let a be Data-Location, i be Instruction-Location of SCM;
       a >0_goto i = [8, <*i,a*>] by AMI_3:def 10;
  hence (a >0_goto i)`1 = 8 by MCART_1:7;
 end;
end;

theorem Th27:
 for N being non empty with_non-empty_elements set,
     S be IC-Ins-separated definite halting
       (non empty non void AMI-Struct over N),
     s being State of S, m being Element of NAT
 holds s is halting iff (Computation s).m is halting
proof
 let N be non empty with_non-empty_elements set;
 let S be IC-Ins-separated definite halting
     (non empty non void AMI-Struct over N),
     s be State of S, m be Element of NAT;
 hereby assume s is halting;
   then consider n being Element of NAT such that
A1:  CurInstr((Computation s).n) = halt S by AMI_1:def 20;
  per cases;
  suppose n <= m;
   then (Computation s).n = (Computation s).(m+0) by A1,AMI_1:52
            .= (Computation (Computation s).m).0 by AMI_1:51;
  hence (Computation s).m is halting by A1,AMI_1:def 20;
  end;
  suppose n >= m;
   then reconsider k = n - m as Element of NAT by INT_1:18;
       (Computation (Computation s).m).k
        = (Computation s).(m+k) by AMI_1:51
       .= (Computation s).n;
  hence (Computation s).m is halting by A1,AMI_1:def 20;
 end;
 end;
 assume (Computation s).m is halting;
  then consider n being Element of NAT such that
A2: CurInstr((Computation (Computation s).m).n) = halt S by AMI_1:def 20;
 take m+n;
 thus thesis by A2,AMI_1:51;
end;

theorem
     for s1, s2 being State of SCM, k, c being Element of NAT
  st s2 = (Computation s1).k & Complexity s2 = c & s2 is halting & 0 < c
   holds Complexity s1 = k+c
proof
 let s1, s2 be State of SCM, k, c be Element of NAT; assume
A1: s2 = (Computation s1).k & Complexity s2 = c & s2 is halting & 0 < c;
   then consider l being Nat such that
A2: c = l+1 by NAT_1:6;
   reconsider l as Element of NAT by ORDINAL1:def 13;
       s2.(IC (Computation s2).l) <> halt SCM &
   s2.(IC (Computation s2).(l+1)) = halt SCM by A1,A2,Th16;
   then s2.(IC (Computation s1).(k+l)) <> halt SCM &
   s2.(IC (Computation s1).(k+(l+1))) = halt SCM by A1,AMI_1:51;
   then s1.(IC (Computation s1).(k+l)) <> halt SCM &
   s1.(IC (Computation s1).(k+(l+1))) = halt SCM by A1,AMI_1:54;
  hence Complexity s1 = (k+l)+1 by Th16
                     .= k+c by A2;
end;

theorem
     for s1, s2 being State of SCM, k being Element of NAT
  st s2 = (Computation s1).k & s2 is halting
   holds Result s2 = Result s1
 proof
 let s1, s2 be State of SCM, k be Element of NAT; assume
A1: s2 = (Computation s1).k & s2 is halting;
then A2: s1 is halting by Th27;
   consider l being Element of NAT such that
A3: Result s2 = (Computation s2).l & CurInstr(Result s2) = halt SCM
                                                     by A1,AMI_1:def 22;
     (Computation (Computation s1).k).l = (Computation s1).(k+l) by AMI_1:51;
 hence Result s2 = Result s1 by A1,A2,A3,AMI_1:def 22;
end;

theorem
    for I1, I2, I3, I4, I5, I6, I7, I8, I9 being Instruction of SCM,
    i1, i2, i3, i4 being Integer,
    il being Element of NAT,
    s being State of SCM
 st IC s = il.il &
    s.il.0 = I1 & s.il.1 = I2 & s.il.2 = I3 & s.il.3 = I4 &
    s.il.4 = I5 & s.il.5 = I6 & s.il.6 = I7 & s.il.7 = I8 & s.il.8 = I9 &
    s.dl.0 = i1 & s.dl.1 = i2 & s.dl.2 = i3 & s.dl.3 = i4
 holds
    s is State-consisting of il, 0, 0,
             <*I1*>^<*I2*>^<*I3*>^<*I4*>^<*I5*>^<*I6*>^<*I7*>^<*I8*>^<*I9*>,
             <*i1*>^<*i2*>^<*i3*>^<*i4*>
proof
let I1, I2, I3, I4, I5, I6, I7, I8, I9 be Instruction of SCM,
    i1, i2, i3, i4 be Integer,
    il  be Element of NAT,
    s be State of SCM such that
A1:  IC s = il.il &
    s.il.0 = I1 & s.il.1 = I2 & s.il.2 = I3 & s.il.3 = I4 &
    s.il.4 = I5 & s.il.5 = I6 & s.il.6 = I7 & s.il.7 = I8 & s.il.8 = I9 &
    s.dl.0 = i1 & s.dl.1 = i2 & s.dl.2 = i3 & s.dl.3 = i4;
 set I = <*I1*>^<*I2*>^<*I3*>^<*I4*>^<*I5*>^<*I6*>^<*I7*>^<*I8*>^<*I9*>,
     D = <*i1*>^<*i2*>^<*i3*>^<*i4*>;
A2: now let k be Element of NAT; assume
A3:  k < len I;   len I=9 & 9=8+1 by FINSEQ_1:92;

    then k <= 8 & 8=7+1 by A3,NAT_1:13;
    then (k <= 7 or k=8) & 7=6+1 by NAT_1:8;
    then (k <= 6 or k=7 or k=8) & 6=5+1 by NAT_1:8;
    then (k <= 5 or k = 6 or k=7 or k=8) & 5=4+1 by NAT_1:8;
    then (k <= 4 or k=5 or k = 6 or k=7 or k=8) & 4=3+1 by NAT_1:8;
    then (k <= 3 or k=4 or k=5 or k = 6 or k=7 or k=8) & 3=2+1
                                                           by NAT_1:8;
    then (k <= 2 or k=3 or k=4 or k=5 or k = 6 or k=7 or k=8) & 2=1+1
                                                           by NAT_1:8;
    then (k <= 1 or k= 2 or k=3 or k=4 or k=5 or k = 6 or k=7 or k=8) & 1=0+1
                                                           by NAT_1:8;
    then (k <= 0 or k=1 or k= 2 or k=3 or k=4 or k=5 or k = 6 or k=7 or k=8) &
                                        0 <= k by NAT_1:8;
    then k=0 or k=1 or k=2 or k=3 or k=4 or k=5 or k=6 or k=7 or k=8;
    hence s.il.(0+k)=I.(k+1) by A1,FINSEQ_1:92;
   end;
    now let k be Element of NAT; assume
A4: k < len D;   len D=4 & 4=3+1 by FINSEQ_1:87;
    then k <= 3 & 3=2+1 by A4,NAT_1:13;
    then (k <= 2 or k=3) & 2=1+1 by NAT_1:8;
    then (k <= 1 or k=2 or k=3) & 1=0+1 by NAT_1:8;
    then (k <= 0 or k = 1 or k=2 or k=3) & 0 <= k by NAT_1:8;
    then k=0 or k=1 or k=2 or k=3;
    hence s.dl.(0+k)=D.(k+1) by A1,FINSEQ_1:87;
   end;
hence s is State-consisting of il, 0, 0,
             <*I1*>^<*I2*>^<*I3*>^<*I4*>^<*I5*>^<*I6*>^<*I7*>^<*I8*>^<*I9*>,
             <*i1*>^<*i2*>^<*i3*>^<*i4*> by A1,A2,Def1;
end;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Empty program
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

theorem
    for s being State-consisting of 0, 0, 0, <*halt SCM*>, <*>INT
    holds s is halting & Complexity s = 0 & Result s = s proof
 let s be State-consisting of 0, 0, 0, <*halt SCM*>, <*>INT;
A1: IC s = il.0 by Def1;
       1 = len <*halt SCM*> by FINSEQ_1:57;
then A2: s.il.(0+0) = <*halt SCM*>.(0+1) by Def1
        .= halt SCM by FINSEQ_1:57;
   set s0 = (Computation s).0;
A3: s = s0 by AMI_1:def 19;
then s.IC s0 = halt SCM by A2,Def1;
 hence
A4: s is halting by Th3;
      CurInstr s0 = halt SCM &
  for k be Element of NAT st CurInstr (Computation s).k = halt SCM holds
  0 <= k by A1,A2,A3;
 hence Complexity s = 0 by A4,Def2;

 thus Result s = s by A1,A2,A3,Th4;
end;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Assignment
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

theorem
    for i1, i2 being Integer,
    s being State-consisting of 0, 0, 0, <*dl.0 := dl.1*>^<*halt SCM*>,
                                 <*i1*>^<*i2*>
    holds s is halting &
          Complexity s = 1 &
          (Result s).dl.0 = i2 &
          for d being Data-Location st d<>dl.0 holds (Result s).d = s.d
proof
 let i1, i2 be Integer,
     s be State-consisting of 0, 0, 0, <*dl.0 := dl.1*>^<*halt SCM*>,
                                  <*i1*>^<*i2*>;
A1: IC s = il.0 &
   s.il.0 = dl.0 := dl.1 & s.il.1 = halt SCM &
   s.dl.0 = i1 & s.dl.1 = i2 by Th15;
   set s1 = (Computation s).(0+1);
A2: s = (Computation s).0 by AMI_1:def 19;
then A3: IC s1 = il.(0+1) by A1,Th18;
A4:  s1.dl.0 = s.dl.1 by A1,A2,Th18;
 thus s is halting by A1,A3,Th3;   il.0 <> il.1 by AMI_3:53;
 hence Complexity s = 1 by A1,A2,A3,Th17;

 thus (Result s).dl.0 = i2 by A1,A3,A4,Th4;

 let d be Data-Location; assume
A5: d<>dl.0;
 thus (Result s).d = s1.d by A1,A3,Th4
                  .= s.d by A1,A2,A5,Th18;
end;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Adding two integers
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

theorem
    for i1, i2 being Integer,
    s being State-consisting of 0, 0, 0, <*AddTo(dl.0,dl.1)*>^<*halt SCM*>,
                                <*i1*>^<*i2*>
    holds s is halting &
          Complexity s = 1 &
          (Result s).dl.0 = i1 + i2 &
          for d being Data-Location st d<>dl.0 holds (Result s).d = s.d
proof
 let i1, i2 be Integer,
     s be State-consisting of 0, 0, 0, <*AddTo(dl.0,dl.1)*>^<*halt SCM*>,
                              <*i1*>^<*i2*>;
A1: IC s = il.0 &
   s.il.0 = AddTo(dl.0,dl.1) & s.il.1 = halt SCM &
   s.dl.0 = i1 & s.dl.1 = i2 by Th15;

   set s0 = (Computation s).0;
   set s1 = (Computation s).(0+1);

:: Step 0

A2: s = s0 by AMI_1:def 19;
:: Step 1
then A3: IC s1 = il.(0+1) by A1,Th19;
A4: s1.dl.0 = s0.dl.0 + s0.dl.1 by A1,A2,Th19;

 thus s is halting by A1,A3,Th3;   il.0 <> il.1 by AMI_3:53;
 hence Complexity s = 1 by A1,A2,A3,Th17;

 thus (Result s).dl.0 = i1 + i2 by A1,A2,A3,A4,Th4;

 let d be Data-Location; assume
A5: d<>dl.0;
 thus (Result s).d = s1.d by A1,A3,Th4
                  .= s.d by A1,A2,A5,Th19;
end;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Subtracting two integers
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

theorem
    for i1, i2 being Integer,
    s being State-consisting of 0, 0, 0, <*SubFrom(dl.0,dl.1)*>^<*halt SCM*>,
                                <*i1*>^<*i2*>
    holds s is halting &
          Complexity s = 1 &
          (Result s).dl.0 = i1 - i2 &
          for d being Data-Location st d<>dl.0 holds (Result s).d = s.d
proof
 let i1, i2 be Integer,
     s be State-consisting of 0, 0, 0, <*SubFrom(dl.0,dl.1)*>^<*halt SCM*>,
                              <*i1*>^<*i2*>;
A1: IC s = il.0 &
   s.il.0 = SubFrom(dl.0,dl.1) & s.il.1 = halt SCM &
   s.dl.0 = i1 & s.dl.1 = i2 by Th15;

   set s0 = (Computation s).0;
   set s1 = (Computation s).(0+1);

:: Step 0

A2: s = s0 by AMI_1:def 19;
:: Step 1
then A3: IC s1 = il.(0+1) by A1,Th20;
A4: s1.dl.0 = s0.dl.0 - s0.dl.1 by A1,A2,Th20;

 thus s is halting by A1,A3,Th3;   il.0 <> il.1 by AMI_3:53;
 hence Complexity s = 1 by A1,A2,A3,Th17;

 thus (Result s).dl.0 = i1 - i2 by A1,A2,A3,A4,Th4;

 let d be Data-Location; assume
A5: d<>dl.0;
 thus (Result s).d = s1.d by A1,A3,Th4
                  .= s.d by A1,A2,A5,Th20;
end;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Multiplying two integers
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

theorem
    for i1, i2 being Integer,
    s being State-consisting of 0, 0, 0, <*MultBy(dl.0,dl.1)*>^<*halt SCM*>,
                                <*i1*>^<*i2*>
    holds s is halting &
          Complexity s = 1 &
          (Result s).dl.0 = i1 * i2 &
          for d being Data-Location st d<>dl.0 holds (Result s).d = s.d
proof
 let i1, i2 be Integer,
     s be State-consisting of 0, 0, 0, <*MultBy(dl.0,dl.1)*>^<*halt SCM*>,
                              <*i1*>^<*i2*>;
A1: IC s = il.0 &
   s.il.0 = MultBy(dl.0,dl.1) & s.il.1 = halt SCM &
   s.dl.0 = i1 & s.dl.1 = i2 by Th15;

   set s0 = (Computation s).0;
   set s1 = (Computation s).(0+1);

:: Step 0

A2: s = s0 by AMI_1:def 19;
:: Step 1
then A3: IC s1 = il.(0+1) by A1,Th21;
A4: s1.dl.0 = s0.dl.0 * s0.dl.1 by A1,A2,Th21;

 thus s is halting by A1,A3,Th3;   il.0 <> il.1 by AMI_3:53;
 hence Complexity s = 1 by A1,A2,A3,Th17;

 thus (Result s).dl.0 = i1 * i2 by A1,A2,A3,A4,Th4;

 let d be Data-Location; assume
A5: d<>dl.0;
 thus (Result s).d = s1.d by A1,A3,Th4
                  .= s.d by A1,A2,A5,Th21;
end;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Dividing two integers
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

theorem
    for i1, i2 being Integer,
    s being State-consisting of 0, 0, 0, <*Divide(dl.0,dl.1)*>^<*halt SCM*>,
                                <*i1*>^<*i2*>
    holds s is halting &
          Complexity s = 1 &
          (Result s).dl.0 = i1 div i2 & (Result s).dl.1 = i1 mod i2 &
::            (i2 <> 0 implies abs((Result s).dl.1) < abs i2
          for d being Data-Location st d<>dl.0 & d<>dl.1
                                    holds (Result s).d = s.d
proof
 let i1, i2 be Integer,
     s be State-consisting of 0, 0, 0, <*Divide(dl.0,dl.1)*>^<*halt SCM*>,
                              <*i1*>^<*i2*>;
A1: IC s = il.0 &
   s.il.0 = Divide(dl.0,dl.1) & s.il.1 = halt SCM &
   s.dl.0 = i1 & s.dl.1 = i2 by Th15;
   set s1 = (Computation s).(0+1);
A2: dl.0 <> dl.1 by AMI_3:52;
A3: s = (Computation s).0 by AMI_1:def 19;
then A4: s.(IC s1) = halt SCM by A1,A2,Th22;
 hence s is halting by Th3;   Divide(dl.0, dl.1) <> halt SCM by Th26;
 hence Complexity s = 1 by A1,A3,A4,Th16;

 thus (Result s).dl.0 = s1.dl.0 by A4,Th4
                    .= i1 div i2 by A1,A2,A3,Th22;
 thus (Result s).dl.1 = s1.dl.1 by A4,Th4
                    .= i1 mod i2 by A1,A2,A3,Th22;
 let d be Data-Location; assume
A5: d<>dl.0 & d<>dl.1;
 thus (Result s).d = s1.d by A4,Th4
                  .= s.d by A1,A2,A3,A5,Th22;
end;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Unconditional jump
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

theorem
    for i1, i2 being Integer,
    s being State-consisting of 0, 0, 0, <*goto il.1*>^<*halt SCM*>,
                                <*i1*>^<*i2*>
    holds s is halting &
          Complexity s = 1 &
          for d being Data-Location holds (Result s).d = s.d
proof
 let i1, i2 be Integer,
     s be State-consisting of 0, 0, 0, <*goto il.1*>^<*halt SCM*>,
                              <*i1*>^<*i2*>;
A1: IC s = il.0 &
   s.il.0 = goto il.1 & s.il.1 = halt SCM &
   s.dl.0 = i1 & s.dl.1 = i2 by Th15;
   set s1 = (Computation s).(0+1);
:: Step 0
A2: s = (Computation s).0 by AMI_1:def 19;
:: Step 1
then A3: IC s1 = il.(0+1) by A1,Th23;
hence s is halting by A1,Th3;   il.0 <> il.1 by AMI_3:53;
 hence Complexity s = 1 by A1,A2,A3,Th17;

 let d be Data-Location;
 thus (Result s).d = s1.d by A1,A3,Th4
                  .= s.d by A1,A2,Th23;
end;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Jump at zero
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

theorem
    for i1, i2 being Integer,
    s being State-consisting of 0, 0, 0, <*dl.0 =0_goto il.1*>^<*halt SCM*>,
                                <*i1*>^<*i2*>
    holds s is halting &
          Complexity s = 1 &
          for d being Data-Location holds (Result s).d = s.d
proof
 let i1, i2 be Integer,
     s be State-consisting of 0, 0, 0, <*dl.0 =0_goto il.1*>^<*halt SCM*>,
                              <*i1*>^<*i2*>;
A1: IC s = il.0 &
   s.il.0 = dl.0 =0_goto il.1 & s.il.1 = halt SCM &
   s.dl.0 = i1 & s.dl.1 = i2 by Th15;
   set s1 = (Computation s).(0+1);
:: Step 0

A2: s = (Computation s).0 by AMI_1:def 19;
:: Step 1
         s.dl.0 = 0 or s.dl.0 <> 0;
then A3: IC s1 = il.(0+1) by A1,A2,Th24;
hence s is halting by A1,Th3;   il.0 <> il.1 by AMI_3:53;
 hence Complexity s = 1 by A1,A2,A3,Th17;

 let d be Data-Location;
 thus (Result s).d = s1.d by A1,A3,Th4
                  .= s.d by A1,A2,Th24;
end;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Jump at greater than zero
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

theorem
    for i1, i2 being Integer,
    s being State-consisting of 0, 0, 0, <*dl.0 >0_goto il.1*>^<*halt SCM*>,
                                <*i1*>^<*i2*>
    holds s is halting &
          Complexity s = 1 &
          for d being Data-Location holds (Result s).d = s.d
proof
 let i1, i2 be Integer,
     s be State-consisting of 0, 0, 0, <*dl.0 >0_goto il.1*>^<*halt SCM*>,
                              <*i1*>^<*i2*>;
A1: IC s = il.0 &
   s.il.0 = dl.0 >0_goto il.1 & s.il.1 = halt SCM &
   s.dl.0 = i1 & s.dl.1 = i2 by Th15;
   set s1 = (Computation s).(0+1);
:: Step 0

A2: s = (Computation s).0 by AMI_1:def 19;
:: Step 1
         s.dl.0 <= 0 or s.dl.0 > 0;
then A3: IC s1 = il.(0+1) by A1,A2,Th25;
hence s is halting by A1,Th3;   il.0 <> il.1 by AMI_3:53;
 hence Complexity s = 1 by A1,A2,A3,Th17;

 let d be Data-Location;
 thus (Result s).d = s1.d by A1,A3,Th4
                  .= s.d by A1,A2,Th25;
end;

