:: Development of Terminology for {\bf SCM}
::  by Grzegorz Bancerek and Piotr Rudnicki
::
:: Received October 8, 1993
:: Copyright (c) 1993 Association of Mizar Users

environ

 vocabularies NUMBERS, INT_1, FINSEQ_1, SUBSET_1, FSM_1, AMI_3, NAT_1,
      PARTFUN1, AMI_1, SCMNORM, RELAT_1, FUNCT_1, CIRCUIT2, MSUALG_1,
      ARYTM_3, XXREAL_0, CARD_1, TARSKI, AFINSQ_1, AMI_2, ORDINAL4, GRAPHSP,
      ARYTM_1, MCART_1, SCM_1, STRUCT_0, ORDINAL1;
 notations TARSKI, SUBSET_1, NUMBERS, XCMPLX_0, NAT_1, INT_1, MCART_1, RELAT_1,
      FUNCT_1, PARTFUN1, FUNCT_2, ORDINAL4, FINSEQ_1, XXREAL_0,
      AFINSQ_1, AMI_2, STRUCT_0, AMI_1, AMI_3, SCMNORM;
 constructors XXREAL_0, NAT_1, AMI_3, SCMNORM, RELSET_1, PARTFUN1, AMI_2,
      AFINSQ_1, ORDINAL4, PBOOLE, PRE_POLY;
 registrations XBOOLE_0, SETFAM_1, ORDINAL1, RELSET_1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, CARD_3, FUNCT_1, AMI_3, AMI_2, FINSET_1, AMI_1,
      AFINSQ_1, CARD_1, FUNCT_2, RELAT_1, PBOOLE;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions AFINSQ_1, AMI_1, NAT_1, AMI_3;
 theorems NAT_1, INT_1, MCART_1, FUNCT_1, FUNCT_2, FINSEQ_1, AMI_1, AMI_2,
      AMI_3, FINSEQ_3, RELSET_1, ORDINAL1, RELAT_1, AFINSQ_1,
      PARTFUN1;
 schemes PARTFUN1, WELLORD2;

begin

definition
  let i be Integer;
  redefine func <*i*> -> FinSequence of INT;
  coherence
  proof
    reconsider i1 = i as Element of INT by INT_1:def 2;
    <*i1*> is FinSequence of INT;
    hence thesis;
  end;
end;

canceled 2;

theorem Th3:
  for s being State of SCM st ex k being Element of NAT st s.(IC
  Comput(ProgramPart(s),s,k)) = halt SCM holds ProgramPart s halts_on s
proof
  let s be State of SCM;
  given k being Element of NAT such that
A1: s.(IC Comput(ProgramPart(s),s,k)) = halt SCM;
  take k;
NX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k)
by AMI_1:123;
Y:  (ProgramPart Comput(ProgramPart(s),s,k))/.IC Comput(ProgramPart(s),s,k)
 = Comput(ProgramPart(s),s,k).IC Comput(ProgramPart(s),s,k) by AMI_1:150;
   IC Comput(ProgramPart(s),s,k) in NAT;
  hence IC Comput(ProgramPart(s),s,k) in dom ProgramPart s by AMI_1:143;
   CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,k))
    = halt SCM by A1,Y,NX,AMI_1:54;
  hence CurInstr(ProgramPart s, Comput(ProgramPart(s),s,k)) = halt SCM;
end;

theorem Th4:
  for s being State of SCM, k being Element of NAT st s.(IC
  Comput(ProgramPart(s),s,k)) = halt SCM holds (Result(ProgramPart(s),s)) =
Comput(ProgramPart(s),s,k)
proof
  let s be State of SCM, k be Element of NAT;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k)
by AMI_1:123;
Y:  (ProgramPart Comput(ProgramPart(s),s,k))/.IC Comput(ProgramPart(s),s,k)
 = Comput(ProgramPart(s),s,k).IC Comput(ProgramPart(s),s,k) by AMI_1:150;
  assume
Z:  s.(IC Comput(ProgramPart(s),s,k)) = halt SCM;
  then
X:  ProgramPart s halts_on s by Th3;
  CurInstr(ProgramPart s,Comput(ProgramPart(s),s,k)) = halt SCM
   by Z,Y,TX,AMI_1:54;
  hence thesis by X,AMI_1:def 22;
end;

canceled 2;

theorem Th7:
  for n, m being Element of NAT holds
  IC SCM <> n & IC SCM <> dl.n &
   n <> dl.m by AMI_3:56,57;

Lm1: now
  let p be FinSequence, n be Element of NAT;
  assume
  n < len p;
  then n+1 >= 0+1 & n+1 <= len p by NAT_1:13;
  then n+1 in dom p by FINSEQ_3:27;
  hence n+1 in dom p & p.(n+1) in rng p by FUNCT_1:def 5;
end;

Lm29: now
  let n be Element of NAT, x be set;
  let p be FinSequence of x;
  assume
  n < len p;
  then
A1: p.(n+1) in rng p by Lm1;
  rng p c= x by FINSEQ_1:def 4;
  hence p.(n+1) in x by A1;
end;

Lm1: now
  let p be XFinSequence, n be Element of NAT;
  assume
  n < len p;
  hence n in dom p by NAT_1:45;
  hence p.n in rng p by FUNCT_1:def 5;
end;

Lm2: now
  let n be Element of NAT, x be set;
  let p be XFinSequence of x;
  assume
  n < len p;
  then
A1: p.n in rng p by Lm1;
  rng p c= x by RELAT_1:def 19;
  hence p.n in x by A1;
end;

definition
  let I be XFinSequence of the Instructions of SCM, D be FinSequence of INT,
     il, ps, ds be Element of NAT;
  mode State-consisting of il, ps, ds, I, D -> State of SCM means
    :Def1:
    IC it = il &
    (for k being Element of NAT st k < len I holds it.(ps+k) = I.k) &
    for k being Element of NAT st k < len D holds it.dl.(ds+k) = D.(k+1);
  existence
  proof
    defpred X[set] means $1 = NAT;
    deffunc U(set) = il;
    consider s being State of SCM;
    defpred X[set,set] means (ex n being Element of NAT st $1 = (ps+n) & n
< len I & $2 = I.n) or $2 = halt SCM & not ex n being Element of NAT st $1
    = (ps+n) & n < len I;
    deffunc V(set) = s.$1;
    consider s1 being Function such that
A1: dom s1 = SCM-Memory & for x being set st x in SCM-Memory holds (X
[x] implies s1.x = U(x)) & (not X[x] implies s1.x = V(x)) from PARTFUN1:sch 1;
    defpred X[set] means ex n being Element of NAT st $1 = n;
A2: for x being set st x in SCM-Memory ex y being set st y in SCM-Instr &
    X[x,y]
    proof
      let x be set;
      assume
      x in SCM-Memory;
      per cases;
      suppose
        ex n being Element of NAT st x = (ps+n) & n < len I;
        then consider n being Element of NAT such that
A3:     x = (ps+n) and
A4:     n < len I;
        reconsider y = I.n as Element of the Instructions of SCM by A4,Lm2;
        take y;
        thus y in SCM-Instr;
        thus thesis by A3,A4;
      end;
      suppose
A5:     not ex n being Element of NAT st x = (ps+n) & n < len I;
        take halt SCM;
        thus thesis by A5;
      end;
    end;
    consider I1 being Function such that
A6: dom I1 = SCM-Memory & rng I1 c= SCM-Instr & for x being set st x
    in SCM-Memory holds X[x,I1.x] from WELLORD2:sch 1(A2 );
    reconsider I1 as Function of SCM-Memory, the Instructions of SCM by A6,
FUNCT_2:def 1,RELSET_1:11;
    defpred X[set,set] means (ex n being Element of NAT st $1 = dl.(ds+n) & n
< len D & $2 = D.(n+1)) or $2 = 0 & not ex n being Element of NAT st $1 = dl.(
    ds+n) & n < len D;
A7: 0 in INT by INT_1:def 2;
A8: now
      let x be set;
      assume
      x in SCM-Memory;
      per cases;
      suppose
        ex n being Element of NAT st x = dl.(ds+n) & n < len D;
        then consider n being Element of NAT such that
A9:     x = dl.(ds+n) and
A10:    n < len D;
        take y = D.(n+1);
        thus y in INT by A10,Lm29;
        thus X[x,y] by A9,A10;
      end;
      suppose
        not ex n being Element of NAT st x = dl.(ds+n) & n < len D;
        hence ex y being set st y in INT & X[x,y] by A7;
      end;
    end;
    consider D1 being Function such that
A11: dom D1 = SCM-Memory & rng D1 c= INT & for x being set st x in
    SCM-Memory holds X[x,D1.x] from WELLORD2:sch 1(A8 );
A13: now
      let x be set;
      assume
Z:     x in SCM-Memory;
      then reconsider n = x as Element of SCM-Memory;
      per cases;
      suppose
        x = NAT;
        then s1.n = il & (the Object-Kind of SCM).x = NAT by A1,AMI_2:30,def 5;
        hence s1.x in (the Object-Kind of SCM).x;
      end;
      suppose
        x <> NAT;
        then
X:         s1.n = s.x by A1;
         x in dom s by Z,PARTFUN1:def 4;
        hence s1.x in (the Object-Kind of SCM).x by X,FUNCT_1:def 20;
      end;
    end;
    reconsider D1 as Function of SCM-Memory, INT by A11,FUNCT_2:def 1
,RELSET_1:11;
    deffunc U(set) = I1.$1;
    reconsider s1 as State of SCM by A1,A13,FUNCT_1:def 20,PARTFUN1:def 4
,RELAT_1:def 18;
    deffunc V(set) = s1.$1;
    consider s2 being Function such that
A14: dom s2 = SCM-Memory & for x being set st x in SCM-Memory holds (X
[x] implies s2.x = U(x)) & (not X[x] implies s2.x = V(x)) from PARTFUN1:sch 1;
    now
      let x be set;
      assume x in SCM-Memory;
      then reconsider n = x as Element of SCM-Memory;
      per cases;
      suppose
A15:    ex n being Element of NAT st x = n;
        then reconsider a=x as Element of NAT;
A16:    (the Object-Kind of SCM).a = SCM-Instr by AMI_2:11;
        s2.x = I1.n by A14,A15;
        hence s2.x in (the Object-Kind of SCM).x by A16;
      end;
      suppose
        not ex n being Element of NAT st x = n;
        then s2.n = s1.x by A14;
        hence s2.x in (the Object-Kind of SCM).x by A1,FUNCT_1:def 20;
      end;
    end;
    then reconsider s2 as State of SCM by A14,FUNCT_1:def 20,PARTFUN1:def 4
,RELAT_1:def 18;
    deffunc V(set) = s2.$1;
    defpred X[set] means ex n being Element of NAT st $1 = dl.n;
    deffunc U(set) = D1.$1;
    consider s3 being Function such that
A17: dom s3 = SCM-Memory & for x being set st x in SCM-Memory holds (X
[x] implies s3.x = U(x)) & (not X[x] implies s3.x = V(x)) from PARTFUN1:sch 1;
    now
      let x be set;
      assume x in SCM-Memory;
      then reconsider n = x as Element of SCM-Memory;
      per cases;
      suppose
A18:    ex n being Element of NAT st x = dl.n;
        then x in SCM-Data-Loc by AMI_3:def 2;
        then
A19:    (the Object-Kind of SCM).x = INT by AMI_2:10;
        s3.x = D1.n by A17,A18;
        hence s3.x in (the Object-Kind of SCM).x by A19;
      end;
      suppose
        not ex n being Element of NAT st x = dl.n;
        then
X:       s3.n = s2.x by A17;
         dom s2 = the carrier of SCM by PARTFUN1:def 4;
        hence s3.x in (the Object-Kind of SCM).x by X,FUNCT_1:def 20;
      end;
    end;
    then reconsider s3 as State of SCM by A17,FUNCT_1:def 20,PARTFUN1:def 4
,RELAT_1:def 18;
    take s3;
    thus IC s3 = s2.NAT by A17,Th7,AMI_3:4
      .= s1.NAT by A14,Th7,AMI_3:4
      .= il by A1,AMI_2:30;
    hereby
      let k be Element of NAT;
Y:    ps+k in NAT;
      assume
      k<len I;
      then
A20:  ex k9 being Element of NAT st (ps+k) = (ps+k9) & k9 < len I &
      I1.(ps+k) = I.k9 by A6,Y;
      for n being Element of NAT holds (ps+k) <> dl.n by AMI_3:56;
      hence s3.(ps+k) = s2.(ps+k) by A17,Y
        .= I.k by A14,A20,Y;
    end;
    let k be Element of NAT;
    assume
    k < len D;
    then consider k9 being Element of NAT such that
A21: dl.(ds+k) = dl.(ds+k9) and
    k9 < len D and
A22: D1.dl.(ds+k) = D.(k9+1) by A11;
    ds+k = ds+k9 by A21,AMI_3:52;
    hence thesis by A17,A22;
  end;
end;

canceled 6;

theorem
  for I1, I2, I3, I4, I5, I6, I7, I8, I9 being Instruction of SCM, i1,
i2, i3, i4 being Integer, il being Element of NAT, s being State-consisting of
il, 0, 0, <%I1%>^<%I2%>^<%I3%>^<%I4%>^<%I5%>^<%I6%>^<%I7%>^<%I8%>^<%I9%>,
   <*i1*>^<*i2*>^<*i3*>^<*i4*>
holds IC s = il & s.0 = I1 & s.1 = I2 & s.2
= I3 & s.3 = I4 & s.4 = I5 & s.5 = I6 & s.6 = I7 & s.7 = I8 & s.
  8 = I9 & s.dl.0 = i1 & s.dl.1 = i2 & s.dl.2 = i3 & s.dl.3 = i4
proof
  let I1, I2, I3, I4, I5, I6, I7, I8, I9 be Instruction of SCM, i1, i2, i3, i4
be Integer, il be Element of NAT, s be State-consisting of il, 0, 0, <%I1%>^<%
I2%>^<%I3%>^<%I4%>^<%I5%>^<%I6%>^<%I7%>^<%I8%>^<%I9%>, <*i1*>^<*i2*>^<*i3*>^<*
  i4*>;
  set I = <%I1%>^<%I2%>^<%I3%>^<%I4%>^<%I5%>^<%I6%>^<%I7%>^<%I8%>^<%I9%>, D =
  <*i1*>^<*i2*>^<*i3*>^<*i4*>;
A1: I.2 = I3 & I.3 = I4 by AFINSQ_1:54;
A2: I.6 = I7 & I.7 = I8 by AFINSQ_1:54;
  thus IC s = il by Def1;
A3: I.4=I5 & I.5 = I6 by AFINSQ_1:54;
A4: I.8 = I9 & len I=9 by AFINSQ_1:54;
A5: 0+7=7 & 0+8=8;
A6: 0+5=5 & 0+6=6;
A7: 0+2=2 & 0+3=3;
A8: 0+3=3 & 0+4=4;
A9: 0+0=0 & 0+2=2 & 0+1=1;
  I.0 = I1 & I.(1) = I2 by AFINSQ_1:54;
  hence  s.0 = I1 & s.1 = I2 & s.2 = I3 & s.3 = I4 & s.4 = I5 &
     s.5 = I6 & s.6 = I7 & s.7 = I8 & s.8 = I9
   by A1,A3,A2,A4,A9,A8,A6,A5,Def1;
A10: D.(2+1) = i3 & D.(3+1) = i4 by FINSEQ_1:87;
A11: len D = 4 & 0+0=0 by FINSEQ_1:87;
  D.(0+1) = i1 & D.(1+1) = i2 by FINSEQ_1:87;
  hence thesis by A10,A11,A7,Def1;
end;

theorem Th15:
  for I1, I2 being Instruction of SCM, i1, i2 being Integer, il
being Element of NAT, s being State-consisting of il, 0, 0, <%I1%>^<%I2%>, <*i1
*>^<*i2*> holds IC s = il & s.0 = I1 & s.1 = I2 & s.dl.0 = i1 & s.dl.1
  = i2
proof
  let I1, I2 be Instruction of SCM, i1, i2 be Integer, il be Element of NAT, s
  be State-consisting of il, 0, 0, <%I1%>^<%I2%>, <*i1*>^<*i2*>;
  set ins = <%I1%>^<%I2%>, data = <*i1*>^<*i2*>;
A1: 0+0=0;
A2: data = <*i1, i2*> by FINSEQ_1:def 9;
  then
A3: len data = 2 & data.(0+1) = i1 by FINSEQ_1:61;
  thus IC s = il by Def1;
A4: ins = <%I1, I2%>;
  then
A5: ins.1 = I2 by AFINSQ_1:42;
A6: data.(1+1) = i2 by A2,FINSEQ_1:61;
  len ins = 2 & ins.0 = I1 by A4,AFINSQ_1:42;
  hence thesis by A5,A3,A6,A1,Def1;
end;

theorem Th16:
  for s being State of SCM, k being Element of NAT holds s.(IC
  Comput(ProgramPart(s),s,k)) <> halt SCM & s.(IC Comput(ProgramPart(s),s,k+1))
= halt SCM iff
  LifeSpan(ProgramPart(s),s) = k+1 & ProgramPart s halts_on s
proof
  let s be State of SCM, k be Element of NAT;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k)
by AMI_1:123;
TY: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k+1)
by AMI_1:123;
  hereby
    assume that
A1: s.(IC Comput(ProgramPart(s),s,k)) <> halt SCM and
A2: s.(IC Comput(ProgramPart(s),s,k+1)) = halt SCM;
Y:  (ProgramPart s)/.IC Comput(ProgramPart(s),s,k)
 = Comput(ProgramPart(s),s,k).IC Comput(ProgramPart(s),s,k) by TX,AMI_1:150;
A3: CurInstr(ProgramPart s,Comput(ProgramPart(s),s,k))
<> halt SCM
by A1,Y,AMI_1:54;
A4: now
      let i be Element of NAT;
      assume that
A5:   CurInstr(ProgramPart s,Comput(ProgramPart(s),s,i)) = halt SCM and
A6:   k+1 > i;
      i <= k by A6,NAT_1:13;
      then Comput(ProgramPart(s),s,k) = Comput(ProgramPart(s),s,i)
       by A5,AMI_1:52;
      hence contradiction by A3,A5;
    end;
Y:  (ProgramPart s)/.IC Comput(ProgramPart(s),s,k+1)
 = Comput(ProgramPart(s),s,k+1).IC Comput(ProgramPart(s),s,k+1)
  by TY,AMI_1:150;
    ProgramPart s halts_on s & CurInstr(ProgramPart s,
    Comput(ProgramPart(s),s,k+1)) = halt SCM
     by A2,Th3,Y,AMI_1:54;
    hence LifeSpan(ProgramPart(s),s) = k+1 & ProgramPart s halts_on s by A4,
AMI_1:def 46;
  end;
  assume
A7: LifeSpan(ProgramPart(s),s) = k+1 & ProgramPart s halts_on s;
A8: now
    assume
    CurInstr(ProgramPart s,Comput(ProgramPart(s),s,k)) = halt SCM;
    then k+1 <= k by A7,AMI_1:def 46;
    hence contradiction by NAT_1:13;
  end;
Z:  (ProgramPart s)/.IC Comput(ProgramPart(s),s,k)
 = Comput(ProgramPart(s),s,k).IC Comput(ProgramPart(s),s,k) by TX,AMI_1:150;
Y:  (ProgramPart s)/.IC Comput(ProgramPart(s),s,k+1)
 = Comput(ProgramPart(s),s,k+1).IC Comput(ProgramPart(s),s,k+1)
    by TY,AMI_1:150;
  CurInstr(ProgramPart s,Comput(ProgramPart(s),s,k+1))
   = halt SCM by A7,AMI_1:def 46;
  hence thesis by A8,Y,Z,AMI_1:54;
end;

theorem Th17:
  for s being State of SCM, k being Element of NAT st IC
  Comput(ProgramPart(s),s,k) <> IC Comput(ProgramPart(s),s,k+1) & s.(IC Comput(
ProgramPart(s),s,k+1)) = halt
  SCM holds LifeSpan(ProgramPart(s),s) = k+1
proof
  let s be State of SCM, k be Element of NAT;
  assume that
A1: IC Comput(ProgramPart(s),s,k) <> IC Comput(ProgramPart(s),s,k+1) and
A2: s.(IC Comput(ProgramPart(s),s,k+1)) = halt SCM;
Y:  (ProgramPart Comput(ProgramPart(s),s,k))/.IC Comput(ProgramPart(s),s,k)
 = Comput(ProgramPart(s),s,k).IC Comput(ProgramPart(s),s,k) by AMI_1:150;
  now
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k)
by AMI_1:123;
    assume
    s.(IC Comput(ProgramPart(s),s,k)) = halt SCM;
    then CurInstr(ProgramPart(s),Comput(ProgramPart(s),s,k)) = halt SCM
    by Y,T,AMI_1:54;
    hence contradiction by A1,AMI_1:52,NAT_1:11;
  end;
  hence thesis by A2,Th16;
end;

Lm3: for k being Element of NAT, s being State of SCM holds Comput(ProgramPart(
s),s,k+1)
= Exec(CurInstr(ProgramPart Comput(ProgramPart(s),s,k),Comput(ProgramPart(s),s,
k)),
Comput(ProgramPart(s),s,k))

proof
  let k be Element of NAT, s be State of SCM;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k)
by AMI_1:123;
  thus Comput(ProgramPart(s),s,k+1)
   = Following(ProgramPart s,Comput(ProgramPart(s),s,k
))
   by AMI_1:14
    .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s),s,k),Comput(ProgramPart(
s),s,k)),
    Comput(ProgramPart(s),s,k)) by T;
end;

Lm4: now
  let k, n be Element of NAT, s be State of SCM, a, b be Data-Location;
  assume
A1: IC Comput(ProgramPart(s),s,k) = n;
  set csk1 = Comput(ProgramPart(s),s,k+1);
  set csk = Comput(ProgramPart(s),s,k);
  assume

A2: s.n = a := b or s.n = AddTo(a,b) or s.n = SubFrom(a, b) or
  s.n = MultBy(a, b) or a<>b & s.n = Divide(a,b);

Y:  (ProgramPart csk)/.IC csk
 = csk.IC csk by AMI_1:150;
  thus csk1 = (Exec(CurInstr(ProgramPart csk,csk), csk)) by Lm3
    .= (Exec(s.n, csk)) by A1,Y,AMI_1:54;
  hence IC csk1 = succ IC csk by A2,AMI_3:8,9,10,11,12
    .= (n+1) by A1;
end;

theorem Th18:
  for k, n being Element of NAT, s being State of SCM, a, b being
  Data-Location st IC Comput(ProgramPart(s),s,k) = n & s.n = a := b holds IC
Comput(ProgramPart(s),s,k+1) = (n+1) & Comput(ProgramPart(s),s,k+1).a = Comput(
ProgramPart(s),s,k).b & for
d being Data-Location st d <> a holds Comput(ProgramPart(s),s,k+1).d = Comput(
ProgramPart(s),s,k).d
proof
  let k, n be Element of NAT, s be State of SCM, a, b be Data-Location;
  assume
A1: IC Comput(ProgramPart(s),s,k) = n;
  set csk1 = Comput(ProgramPart(s),s,k+1);
  set csk = Comput(ProgramPart(s),s,k);
  assume
A2: s.n = a := b;
  then csk1 = Exec(a:=b, csk) by A1,Lm4;
  hence thesis by A1,A2,Lm4,AMI_3:8;
end;

theorem Th19:
  for k, n being Element of NAT, s being State of SCM, a, b being
  Data-Location st IC Comput(ProgramPart(s),s,k) = n & s.n = AddTo(a,b) holds
IC
  Comput(ProgramPart(s),s,k+1) = (n+1) & Comput(ProgramPart(s),s,k+1).a =
Comput(ProgramPart(s),s,k).a+
Comput(ProgramPart(s),s,k).b & for d being Data-Location st d <> a holds Comput
(ProgramPart(s),s,k+
  1).d = Comput(ProgramPart(s),s,k).d
proof
  let k, n be Element of NAT, s be State of SCM, a, b be Data-Location;
  assume
A1: IC Comput(ProgramPart(s),s,k) = n;
  set csk1 = Comput(ProgramPart(s),s,k+1);
  set csk = Comput(ProgramPart(s),s,k);
  assume
A2: s.n = AddTo(a,b);
  then csk1 = Exec(AddTo(a,b), csk) by A1,Lm4;
  hence thesis by A1,A2,Lm4,AMI_3:9;
end;

theorem Th20:
  for k, n being Element of NAT, s being State of SCM, a, b being
  Data-Location st IC Comput(ProgramPart(s),s,k) = n & s.n = SubFrom(a,b) holds
IC
  Comput(ProgramPart(s),s,k+1) = (n+1) & Comput(ProgramPart(s),s,k+1).a =
Comput(ProgramPart(s),s,k).a-
Comput(ProgramPart(s),s,k).b & for d being Data-Location st d <> a holds Comput
(ProgramPart(s),s,k+
  1).d = Comput(ProgramPart(s),s,k).d
proof
  let k, n be Element of NAT, s be State of SCM, a, b be Data-Location;
  assume
A1: IC Comput(ProgramPart(s),s,k)= n;
  set csk1 = Comput(ProgramPart(s),s,k+1);
  set csk = Comput(ProgramPart(s),s,k);
  assume
A2: s.n = SubFrom(a,b);
  then csk1 = Exec(SubFrom(a,b), csk) by A1,Lm4;
  hence thesis by A1,A2,Lm4,AMI_3:10;
end;

theorem Th21:
  for k, n being Element of NAT, s being State of SCM, a, b being
  Data-Location st IC Comput(ProgramPart(s),s,k) = n & s.n = MultBy(a,b) holds
IC
  Comput(ProgramPart(s),s,k+1) = (n+1) & Comput(ProgramPart(s),s,k+1).a =
Comput(ProgramPart(s),s,k).a*
Comput(ProgramPart(s),s,k).b & for d being Data-Location st d <> a holds Comput
(ProgramPart(s),s,k+
  1).d = Comput(ProgramPart(s),s,k).d
proof
  let k, n be Element of NAT, s be State of SCM, a, b be Data-Location;
  assume
A1: IC Comput(ProgramPart(s),s,k) = n;
  set csk1 = Comput(ProgramPart(s),s,k+1);
  set csk = Comput(ProgramPart(s),s,k);
  assume
A2: s.n = MultBy(a,b);
  then csk1 = Exec(MultBy(a,b), csk) by A1,Lm4;
  hence thesis by A1,A2,Lm4,AMI_3:11;
end;

theorem Th22:
  for k, n being Element of NAT, s being State of SCM, a, b being
Data-Location st IC Comput(ProgramPart(s),s,k) = n & s.n = Divide(a,b) & a<>b
holds
  IC Comput(ProgramPart(s),s,k+1) = (n+1) & Comput(ProgramPart(s),s,k+1).a =
Comput(ProgramPart(s),s,k).a
  div Comput(ProgramPart(s),s,k).b & Comput(ProgramPart(s),s,k+1).b = Comput(
ProgramPart(s),s,k).a mod
  Comput(ProgramPart(s),s,k).b & for d being Data-Location st d <> a & d <> b
holds
  Comput(ProgramPart(s),s,k+1).d = Comput(ProgramPart(s),s,k).d
proof
  let k, n be Element of NAT, s be State of SCM, a, b be Data-Location;
  assume
A1: IC Comput(ProgramPart(s),s,k) = n;
  set csk1 = Comput(ProgramPart(s),s,k+1);
  set csk = Comput(ProgramPart(s),s,k);
  assume
A2: s.n = Divide(a,b) & a <> b;
  then csk1 = Exec(Divide(a,b), csk) by A1,Lm4;
  hence thesis by A1,A2,Lm4,AMI_3:12;
end;

theorem Th23:
  for k, n being Element of NAT, s being State of SCM, il being
  Element of NAT st IC Comput(ProgramPart(s),s,k) = n &
   s.n = SCM-goto il
holds IC Comput(ProgramPart(s),s,k+1) = il & for d being Data-Location holds
Comput(ProgramPart(
  s),
  s,k+1).d = Comput(ProgramPart(s),s,k).d
proof
  let k, n be Element of NAT, s be State of SCM, il be Element of NAT;
  assume
A1: IC Comput(ProgramPart(s),s,k) = n & s.n = SCM-goto il;
  set csk1 = Comput(ProgramPart(s),s,k+1);
  set csk = Comput(ProgramPart(s),s,k);
Y:  (ProgramPart csk)/.IC csk
 = csk.IC csk by AMI_1:150;
A2: csk1 = Exec(CurInstr(ProgramPart csk,csk), csk) by Lm3
    .= Exec(SCM-goto il, csk) by A1,Y,AMI_1:54;
  hence IC csk1 = il by AMI_3:13;
  thus thesis by A2,AMI_3:13;
end;

theorem Th24:
  for k, n being Element of NAT, s being State of SCM, a being
  Data-Location, il being Element of NAT st IC Comput(ProgramPart(s),s,k) =
  n & s.n = a =0_goto il holds ( Comput(ProgramPart(s),s,k).a = 0 implies IC
Comput(ProgramPart(s),s,k+1) = il) & ( Comput(ProgramPart(s),s,k).a <>0 implies
IC Comput(ProgramPart(s),s,k+
  1) = (n+1)) & for d being Data-Location holds Comput(ProgramPart(s),s,k+1).d
=
  Comput(ProgramPart(s),s,k).d
proof
  let k, n be Element of NAT, s be State of SCM, a be Data-Location, il be
  Element of NAT;
  assume that
A1: IC Comput(ProgramPart(s),s,k) = n and
A2: s.n = a =0_goto il;
  set csk1 = Comput(ProgramPart(s),s,k+1);
  set csk = Comput(ProgramPart(s),s,k);
Y:  (ProgramPart csk)/.IC csk
 = csk.IC csk by AMI_1:150;
A3: csk1 = Exec(CurInstr(ProgramPart csk,csk), csk) by Lm3
    .= Exec(a =0_goto il, csk) by A1,A2,Y,AMI_1:54;
  hence csk.a = 0 implies IC csk1 = il by AMI_3:14;
  hereby
    assume
    csk.a <> 0;
    hence IC csk1 = succ n by A1,A3,AMI_3:14
      .= (n+1);
  end;
  thus thesis by A3,AMI_3:14;
end;

theorem Th25:
  for k, n being Element of NAT, s being State of SCM, a being
  Data-Location, il being Element of NAT st IC Comput(ProgramPart(s),s,k) =
  n & s.n = a >0_goto il holds ( Comput(ProgramPart(s),s,k).a > 0 implies IC
Comput(ProgramPart(s),s,k+1) = il) & ( Comput(ProgramPart(s),s,k).a <= 0
implies IC Comput(ProgramPart(s),s,k
  +1) = (n+1)) & for d being Data-Location holds Comput(ProgramPart(s),s,k+1).d
=
  Comput(ProgramPart(s),s,k).d
proof
  let k, n be Element of NAT, s be State of SCM, a be Data-Location, il be
  Element of NAT;
  assume that
A1: IC Comput(ProgramPart(s),s,k) = n and
A2: s.n = a >0_goto il;
  set csk1 = Comput(ProgramPart(s),s,k+1);
  set csk = Comput(ProgramPart(s),s,k);
Y:  (ProgramPart csk)/.IC csk
 = csk.IC csk by AMI_1:150;
A3: csk1 = Exec(CurInstr(ProgramPart csk,csk), csk) by Lm3
    .= Exec(a >0_goto il, csk) by A1,A2,Y,AMI_1:54;
  hence csk.a > 0 implies IC csk1 = il by AMI_3:15;
  hereby
    assume
    csk.a <= 0;
    hence IC csk1 = succ n by A1,A3,AMI_3:15
      .= (n+1);
  end;
  thus thesis by A3,AMI_3:15;
end;

theorem Th26:
  (halt SCM)`1 = 0 & (for a, b being Data-Location holds (a := b)
  `1 = 1) & (for a, b being Data-Location holds (AddTo(a,b))`1 = 2) & (for a, b
being Data-Location holds (SubFrom(a,b))`1 = 3) & (for a, b being Data-Location
holds (MultBy(a,b))`1 = 4) & (for a, b being Data-Location holds (Divide(a,b))
`1 = 5) & (for i being Element of NAT holds (SCM-goto i)`1 = 6)
 & (for
a being Data-Location, i being Element of NAT holds (a =0_goto i)
`1 = 7) & for a being Data-Location, i being Element of NAT holds
  (a >0_goto i)`1 = 8 by AMI_3:71,MCART_1:7;

canceled;

theorem
  for s1, s2 being State of SCM, k, c being Element of NAT st s2 =
Comput(ProgramPart(s1),s1,k) & LifeSpan(ProgramPart(s2),s2) = c & ProgramPart
s2 halts_on s2 &
 0 < c holds LifeSpan(ProgramPart(s1),s1) =
  k+c
proof
  let s1, s2 be State of SCM, k, c be Element of NAT;
  assume that
A1: s2 = Comput(ProgramPart(s1),s1,k) and
A2: LifeSpan(ProgramPart(s2),s2) = c & ProgramPart s2 halts_on s2 and
A3: 0 < c;
  consider l being Nat such that
A4: c = l+1 by A3,NAT_1:6;
  reconsider l as Element of NAT by ORDINAL1:def 13;
T: ProgramPart s1 = ProgramPart s2 by A1,AMI_1:123;
  s2.(IC Comput(ProgramPart(s2),s2,l+1)) = halt SCM by A2,A4,Th16;
  then s2.(IC Comput(ProgramPart(s1),s1,k+(l+1))) = halt SCM by A1,T,AMI_1:51;
  then
A5: s1.(IC Comput(ProgramPart(s1),s1,k+(l+1))) = halt SCM by A1,AMI_1:54;
  s2.(IC Comput(ProgramPart(s2),s2,l)) <> halt SCM by A2,A4,Th16;
  then s2.(IC Comput(ProgramPart(s1),s1,k+l)) <> halt SCM by A1,T,AMI_1:51;
  then s1.(IC Comput(ProgramPart(s1),s1,k+l)) <> halt SCM by A1,AMI_1:54;
  hence LifeSpan(ProgramPart(s1),s1) = (k+l)+1 by A5,Th16
    .= k+c by A4;
end;

theorem
  for s1 being State of SCM, k being Element of NAT
   st ProgramPart s1 halts_on Comput(ProgramPart(s1),s1,k)
   holds Result(ProgramPart(Comput(ProgramPart(s1),s1,k)),Comput(ProgramPart(s1
),s1,k)) = Result(ProgramPart(s1),s1)
proof
  let s1 be State of SCM, k be Element of NAT;
  set s2 = Comput(ProgramPart(s1),s1,k);
  assume
A2: ProgramPart s1 halts_on s2;
  then ProgramPart s2 halts_on s2 by AMI_1:123;
  then consider l being Element of NAT such that
A4: Result(ProgramPart(s2),s2) = Comput(ProgramPart(s2),s2,l) &
    CurInstr(ProgramPart s2,Result(ProgramPart(s2),s2)) = halt SCM
     by AMI_1:def 22;
A3: ProgramPart s1 halts_on s1 by A2,AMI_1:93;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:123;
  Comput(ProgramPart(s1),Comput(ProgramPart(s1),s1,k),l)
   = Comput(ProgramPart(s1),s1,k+l) by AMI_1:51;
  hence thesis by A3,A4,T,AMI_1:def 22;
end;

theorem
  for I1, I2, I3, I4, I5, I6, I7, I8, I9 being Instruction of SCM, i1,
i2, i3, i4 being Integer, il being Element of NAT, s being State of SCM st IC s
= il & s.0 = I1 & s.1 = I2 & s.2 = I3 & s.3 = I4 & s.4 = I5 &
s.5 = I6 & s.6 = I7 & s.7 = I8 & s.8 = I9 & s.dl.0 = i1 & s.dl.1 =
i2 & s.dl.2 = i3 & s.dl.3 = i4 holds s is State-consisting of il, 0, 0, <%I1%>^
<%I2%>^<%I3%>^<%I4%>^<%I5%>^<%I6%>^<%I7%>^<%I8%>^<%I9%>, <*i1*>^<*i2*>^<*i3*>^
  <*i4*>
proof
  let I1, I2, I3, I4, I5, I6, I7, I8, I9 be Instruction of SCM, i1, i2, i3, i4
  be Integer, il be Element of NAT, s be State of SCM such that
A1: IC s = il and
A2: s.0 = I1 & s.1 = I2 & s.2 = I3 & s.3 = I4 & s.4 = I5
  & s. 5 = I6 & s.6 = I7 & s.7 = I8 & s.8 = I9 and
A3: s.dl.0 = i1 & s.dl.1 = i2 & s.dl.2 = i3 & s.dl.3 = i4;
  set I = <%I1%>^<%I2%>^<%I3%>^<%I4%>^<%I5%>^<%I6%>^<%I7%>^<%I8%>^<%I9%>, D =
  <*i1*>^<*i2*>^<*i3*>^<*i4*>;
A4: now
    let k be Element of NAT;
A5: len I=9 & 9=8+1 by AFINSQ_1:54;
A6: 8=7+1;
    assume
    k < len I;
    then k <= 8 by A5,NAT_1:13;
    then
A7: k <= 7 or k=8 by A6,NAT_1:8;
A8: 6=5+1;
    7=6+1;
    then k <= 6 or k=7 or k=8 by A7,NAT_1:8;
    then
A9: k <= 5 or k = 6 or k=7 or k=8 by A8,NAT_1:8;
A10: 4=3+1;
    5=4+1;
    then k <= 4 or k=5 or k = 6 or k=7 or k=8 by A9,NAT_1:8;
    then
A11: k <= 3 or k=4 or k=5 or k = 6 or k=7 or k=8 by A10,NAT_1:8;
A12: 2=1+1;
    3=2+1;
    then k <= 2 or k=3 or k=4 or k=5 or k = 6 or k=7 or k=8 by A11,NAT_1:8;
    then
A13: k <= 1 or k= 2 or k=3 or k=4 or k=5 or k = 6 or k=7 or k=8 by A12,NAT_1:8;
    1=0+1;
    then k=0 or k=1 or k=2 or k=3 or k=4 or k=5 or k=6 or k=7 or k=8 by A13,
NAT_1:8;
    hence s.(0+k)=I.k by A2,AFINSQ_1:54;
  end;
  now
    let k be Element of NAT;
A14: len D=4 & 4=3+1 by FINSEQ_1:87;
A15: 3=2+1;
    assume
    k < len D;
    then k <= 3 by A14,NAT_1:13;
    then
A16: k <= 2 or k=3 by A15,NAT_1:8;
A17: 1=0+1;
    2=1+1;
    then k <= 1 or k=2 or k=3 by A16,NAT_1:8;
    then k=0 or k=1 or k=2 or k=3 by A17,NAT_1:8;
    hence s.dl.(0+k)=D.(k+1) by A3,FINSEQ_1:87;
  end;
  hence thesis by A1,A4,Def1;
end;

:: Empty program

theorem
  for s being State-consisting of 0, 0, 0, <%halt SCM%>, <*>INT
   holds ProgramPart s halts_on s & LifeSpan(ProgramPart(s),s) = 0 & Result(
ProgramPart(s),s) = s
proof
  let s be State-consisting of 0, 0, 0, <%halt SCM%>, <*>INT;
  1 = len <%halt SCM%> by AFINSQ_1:38;
  then
A1: s.(0+0) = <%halt SCM%>.0 by Def1
    .= halt SCM by AFINSQ_1:38;
A2: s = Comput(ProgramPart(s),s,0) by AMI_1:13;
  s.IC s = halt SCM by A1,Def1;
  hence
A3: ProgramPart s halts_on s by Th3,A2;
Y:  (ProgramPart s)/.IC s = s.IC s by AMI_1:150;
  CurInstr(ProgramPart s,s) = halt SCM by A1,Def1,Y;
  hence LifeSpan(ProgramPart(s),s) = 0 by A3,A2,AMI_1:def 46;
  IC s = 0 by Def1;
  hence thesis by A1,A2,Th4;
end;

:: Assignment

theorem
  for i1, i2 being Integer, s being State-consisting of 0, 0, 0, <%dl.0
  := dl.1%>^<%halt SCM%>, <*i1*>^<*i2*> holds ProgramPart s halts_on s &
   LifeSpan(ProgramPart(s),s) = 1 & (
Result(ProgramPart(s),s)).dl.0 = i2 & for d being Data-Location st d<>dl.0
holds (Result(ProgramPart(s),s)).d =
  s.d
proof
  let i1, i2 be Integer, s be State-consisting of 0, 0, 0, <%dl.0 := dl.1%>^<%
  halt SCM%>, <*i1*>^<*i2*>;
  set s1 = Comput(ProgramPart(s),s,0+1);
A1: s.dl.1 = i2 by Th15;
A2: IC s = 0 & s = Comput(ProgramPart(s),s,0) by Th15,AMI_1:13;
A3: s.0 = dl.0 := dl.1 by Th15;
  then
A4: IC s1 = (0+1) by A2,Th18;
A5: s.1 = halt SCM by Th15;
  hence ProgramPart s halts_on s by A4,Th3;
  thus LifeSpan(ProgramPart(s),s) = 1 by A5,A2,A4,Th17;
  s1.dl.0 = s.dl.1 by A3,A2,Th18;
  hence (Result(ProgramPart(s),s)).dl.0 = i2 by A5,A1,A4,Th4;
  let d be Data-Location;
  assume
A6: d<>dl.0;
  thus (Result(ProgramPart(s),s)).d = s1.d by A5,A4,Th4
    .= s.d by A3,A2,A6,Th18;
end;

:: Adding two integers

theorem
  for i1, i2 being Integer, s being State-consisting of 0, 0, 0, <%AddTo
(dl.0,dl.1)%>^<%halt SCM%>, <*i1*>^<*i2*> holds ProgramPart s halts_on s &
 LifeSpan(ProgramPart(s),s) = 1 &
(Result(ProgramPart(s),s)).dl.0 = i1 + i2 & for d being Data-Location st d<>dl.
0 holds Result(ProgramPart s,
  s).d = s.d
proof
  let i1, i2 be Integer, s be State-consisting of 0, 0, 0, <%AddTo(dl.0,dl.1)
  %>^<%halt SCM%>, <*i1*>^<*i2*>;
  set s0 = Comput(ProgramPart(s),s,0);
  set s1 = Comput(ProgramPart(s),s,0+1);
A1: s = s0 by AMI_1:13;
A2: s.dl.0 = i1 & s.dl.1 = i2 by Th15;
A3: IC s = 0 by Th15;
A4: s.0 = AddTo(dl.0,dl.1) by Th15;
  then
A5: IC s1 = (0+1) by A3,A1,Th19;
A6: s.1 = halt SCM by Th15;
  hence ProgramPart s halts_on s by A5,Th3;
  thus LifeSpan(ProgramPart(s),s) = 1 by A3,A6,A1,A5,Th17;
  s1.dl.0 = s0.dl.0 + s0.dl.1 by A3,A4,A1,Th19;
  hence (Result(ProgramPart(s),s)).dl.0 = i1 + i2 by A6,A2,A1,A5,Th4;
  let d be Data-Location;
  assume
A7: d<>dl.0;
  thus (Result(ProgramPart(s),s)).d = s1.d by A6,A5,Th4
    .= s.d by A3,A4,A1,A7,Th19;
end;

:: Subtracting two integers

theorem
  for i1, i2 being Integer, s being State-consisting of 0, 0, 0, <%
SubFrom(dl.0,dl.1)%>^<%halt SCM%>, <*i1*>^<*i2*> holds ProgramPart s halts_on s
 & LifeSpan(ProgramPart s,s) = 1 &
 (Result(ProgramPart(s),s)).dl.0 = i1 - i2 & for d being Data-Location
st d<>dl.0 holds
  (Result(ProgramPart(s),s)).d = s.d
proof
  let i1, i2 be Integer, s be State-consisting of 0, 0, 0, <%SubFrom(dl.0,dl.1
  )%>^<%halt SCM%>, <*i1*>^<*i2*>;
  set s0 = Comput(ProgramPart(s),s,0);
  set s1 = Comput(ProgramPart(s),s,0+1);
A1: s = s0 by AMI_1:13;
A2: s.dl.0 = i1 & s.dl.1 = i2 by Th15;
A3: IC s = 0 by Th15;
A4: s.0 = SubFrom(dl.0,dl.1) by Th15;
  then
A5: IC s1 = (0+1) by A3,A1,Th20;
A6: s.1 = halt SCM by Th15;
  hence ProgramPart s halts_on s by A5,Th3;
  thus LifeSpan(ProgramPart(s),s) = 1 by A3,A6,A1,A5,Th17;
  s1.dl.0 = s0.dl.0 - s0.dl.1 by A3,A4,A1,Th20;
  hence (Result(ProgramPart(s),s)).dl.0 = i1 - i2 by A6,A2,A1,A5,Th4;
  let d be Data-Location;
  assume
A7: d<>dl.0;
  thus (Result(ProgramPart(s),s)).d = s1.d by A6,A5,Th4
    .= s.d by A3,A4,A1,A7,Th20;
end;

:: Multiplying two integers

theorem
  for i1, i2 being Integer, s being State-consisting of 0, 0, 0, <%
MultBy(dl.0,dl.1)%>^<%halt SCM%>, <*i1*>^<*i2*> holds ProgramPart s halts_on s
 & LifeSpan(ProgramPart(s),s)
= 1 & (Result(ProgramPart(s),s)).dl.0 = i1 * i2 & for d being Data-Location st
d<>dl.0 holds (
  Result(ProgramPart(s),s)).d = s.d
proof
  let i1, i2 be Integer, s be State-consisting of 0, 0, 0, <%MultBy(dl.0,dl.1)
  %>^<%halt SCM%>, <*i1*>^<*i2*>;
  set s0 = Comput(ProgramPart(s),s,0);
  set s1 = Comput(ProgramPart(s),s,0+1);
A1: s = s0 by AMI_1:13;
A2: s.dl.0 = i1 & s.dl.1 = i2 by Th15;
A3: IC s = 0 by Th15;
A4: s.0 = MultBy(dl.0,dl.1) by Th15;
  then
A5: IC s1 = (0+1) by A3,A1,Th21;
A6: s.1 = halt SCM by Th15;
  hence ProgramPart s halts_on s by A5,Th3;
  thus LifeSpan(ProgramPart(s),s) = 1 by A3,A6,A1,A5,Th17;
  s1.dl.0 = s0.dl.0 * s0.dl.1 by A3,A4,A1,Th21;
  hence (Result(ProgramPart(s),s)).dl.0 = i1 * i2 by A6,A2,A1,A5,Th4;
  let d be Data-Location;
  assume
A7: d<>dl.0;
  thus (Result(ProgramPart(s),s)).d = s1.d by A6,A5,Th4
    .= s.d by A3,A4,A1,A7,Th21;
end;

:: Dividing two integers

theorem
  for i1, i2 being Integer, s being State-consisting of 0, 0, 0, <%
Divide(dl.0,dl.1)%>^<%halt SCM%>, <*i1*>^<*i2*> holds ProgramPart s halts_on s
 & LifeSpan(ProgramPart(s),s)
  = 1 & (Result(ProgramPart(s),s)).dl.0 = i1 div i2 & (Result(ProgramPart(s),s)
).dl.1 = i1 mod i2 & for d being
  Data-Location st d<>dl.0 & d<>dl.1 holds (Result(ProgramPart(s),s)).d = s.d
proof
  let i1, i2 be Integer, s be State-consisting of 0, 0, 0, <%Divide(dl.0,dl.1)
  %>^<%halt SCM%>, <*i1*>^<*i2*>;
  set s1 = Comput(ProgramPart(s),s,0+1);
A1: dl.0 <> dl.1 by AMI_3:52;
A2: IC s = 0 & s.0 = Divide(dl.0,dl.1) by Th15;
A3: s.dl.0 = i1 & s.dl.1 = i2 by Th15;
A4: s = Comput(ProgramPart(s),s,0) by AMI_1:13;
  s.1 = halt SCM by Th15;
  then
A5: s.(IC s1) = halt SCM by A2,A1,A4,Th22;
  hence ProgramPart s halts_on s by Th3;
  Divide(dl.0, dl.1) <> halt SCM by Th26;
  hence LifeSpan(ProgramPart(s),s) = 1 by A2,A4,A5,Th16;
  thus (Result(ProgramPart(s),s)).dl.0 = s1.dl.0 by A5,Th4
    .= i1 div i2 by A2,A3,A1,A4,Th22;
  thus (Result(ProgramPart(s),s)).dl.1 = s1.dl.1 by A5,Th4
    .= i1 mod i2 by A2,A3,A1,A4,Th22;
  let d be Data-Location;
  assume
A6: d<>dl.0 & d<>dl.1;
  thus (Result(ProgramPart(s),s)).d = s1.d by A5,Th4
    .= s.d by A2,A1,A4,A6,Th22;
end;

:: Unconditional jump

theorem
  for i1, i2 being Integer, s being State-consisting of 0, 0, 0, <%SCM-goto
1%>^<%halt SCM%>, <*i1*>^<*i2*> holds ProgramPart s halts_on s &
 LifeSpan(ProgramPart(s),s) = 1 & for d
  being Data-Location holds (Result(ProgramPart(s),s)).d = s.d
proof
  let i1, i2 be Integer, s be State-consisting of 0, 0, 0, <%SCM-goto 1%>^<%
  halt SCM%>, <*i1*>^<*i2*>;
  set s1 = Comput(ProgramPart(s),s,0+1);
A1: IC s = 0 & s = Comput(ProgramPart(s),s,0) by Th15,AMI_1:13;
A2: s.0 = SCM-goto 1 by Th15;
  then
A3: IC s1 = (0+1) by A1,Th23;
A4: s.1 = halt SCM by Th15;
  hence ProgramPart s halts_on s by A3,Th3;
  thus LifeSpan(ProgramPart(s),s) = 1 by A4,A1,A3,Th17;
  let d be Data-Location;
  thus (Result(ProgramPart(s),s)).d = s1.d by A4,A3,Th4
    .= s.d by A2,A1,Th23;
end;

:: Jump at zero

theorem
  for i1, i2 being Integer, s being State-consisting of 0, 0, 0, <%dl.0
=0_goto 1%>^<%halt SCM%>, <*i1*>^<*i2*> holds ProgramPart s halts_on s
 & LifeSpan(ProgramPart(s),s) = 1
  & for d being Data-Location holds (Result(ProgramPart(s),s)).d = s.d
proof
  let i1, i2 be Integer, s be State-consisting of 0, 0, 0, <%dl.0 =0_goto 1
  %>^<%halt SCM%>, <*i1*>^<*i2*>;
  set s1 = Comput(ProgramPart(s),s,0+1);
A1: s.0 = dl.0 =0_goto 1 by Th15;
A2: s.1 = halt SCM by Th15;
A3: IC s = 0 & s = Comput(ProgramPart(s),s,0) by Th15,AMI_1:13;
  s.dl.0 = i1 by Th15;
  then
A4: IC s1 = (0+1) by A1,A3,Th24;
  hence ProgramPart s halts_on s by A2,Th3;
  thus LifeSpan(ProgramPart(s),s) = 1 by A2,A3,A4,Th17;
  let d be Data-Location;
  thus (Result(ProgramPart(s),s)).d = s1.d by A2,A4,Th4
    .= s.d by A1,A3,Th24;
end;

:: Jump at greater than zero

theorem
  for i1, i2 being Integer, s being State-consisting of 0, 0, 0, <%dl.0
>0_goto 1%>^<%halt SCM%>, <*i1*>^<*i2*> holds ProgramPart s halts_on s
 & LifeSpan(ProgramPart(s),s) = 1
  & for d being Data-Location holds (Result(ProgramPart(s),s)).d = s.d
proof
  let i1, i2 be Integer, s be State-consisting of 0, 0, 0, <%dl.0 >0_goto 1
  %>^<%halt SCM%>, <*i1*>^<*i2*>;
  set s1 = Comput(ProgramPart(s),s,0+1);
A1: s.0 = dl.0 >0_goto 1 by Th15;
A2: s.1 = halt SCM by Th15;
A3: IC s = 0 & s = Comput(ProgramPart(s),s,0) by Th15,AMI_1:13;
  s.dl.0 = i1 by Th15;
  then
A4: IC s1 = (0+1) by A1,A3,Th25;
  hence ProgramPart s halts_on s by A2,Th3;
  thus LifeSpan(ProgramPart(s),s) = 1 by A2,A3,A4,Th17;
  let d be Data-Location;
  thus (Result(ProgramPart(s),s)).d = s1.d by A2,A4,Th4
    .= s.d by A1,A3,Th25;
end;

