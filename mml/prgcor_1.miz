:: Correctness of Non Overwriting Programs. {P}art {I}
::  by Yatsuka Nakamura
::
:: Received December 5, 2003
:: Copyright (c) 2003 Association of Mizar Users

environ

 vocabularies RELAT_1, FUNCT_1, FINSEQ_1, ARYTM_1, ARYTM_3, INT_1, NAT_1,
      PARTFUN1, GROUP_1, PRGCOR_1, FUNCOP_1, ARYTM;
 notations TARSKI, SUBSET_1, NUMBERS, XCMPLX_0, XXREAL_0, FUNCT_1, FINSEQ_1,
      INT_1, BINARITH, RELSET_1, FUNCOP_1, PARTFUN1, NAT_1, NAT_D, NEWTON;
 constructors XXREAL_0, REAL_1, NAT_1, NAT_D, NEWTON, BINARITH;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, XXREAL_0, XREAL_0, NAT_1, INT_1,
      NEWTON;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI;
 theorems FINSEQ_1, REAL_1, NAT_1, FUNCT_1, XCMPLX_1, PRE_FF, INT_1, NEWTON,
      BINARITH, CARD_4, FINSEQ_3, FUNCOP_1, TARSKI, XREAL_1, XXREAL_0,
      ORDINAL1, NAT_D, WSIERP_1;
 schemes NAT_1, FINSEQ_1;

begin

::----------------------
::----------------------
::  Non overwriting program is a program where each variable used in it
::is written only just one time, but the control variables used for
::for-statement are exceptional.  Contrarily, variables are allowed
::to be read many times.
::    There are other restriction for non overwriting program. For statements,
::only the followings are allowed: substituting-statement, if-else-statement,
::for-statement(with break and without break), function(correct one)-call
::-statement and return-statement.
::   Grammars of non overwriting program is like one of C-language.
::   For type of variables, 'int','real","char" and "float" can be used, and
::and array of them can also be used. For operation, "+", "-" and "*"
::are used for a type int, "+","-","*" and "/" are used for a type float.
::    User can also define structures like in C.
::    Non overwriting program can be translated to (predicative) logic
::formula in definition part to define functions. If a new function
::is correctly defined, a corresponding program is correct, if it does not use
::arrays. If it uses arrays, area check is necessary in the following
::theorem.
::    Semantic correctness is shown by some theorems following the definition.
::These theorems must tie up the result of the program and mathematical concepts
::introduced before.
::   Correctness is proven function-wise. We must use only
::correctness-proven functions to define a new function(to write a new
::program as a form of a function).
::  Here, we present two program of division function of two natural
::numbers and of two integers. An algorithm is checked for each case, by
::proving correctness of the definitions.
::  We also do an area check of index of arrays used in one of the programs.
::---------
:: type correspondence:
::  int .....> Integer
::  float .....> Real
::  char ......> Subset of A
::---------
:: statement correspondence:
::   We use tr(statement_i) for translated logic formula corresponding
:: to statement_i.
::  i=j+k-l;  ....>    i=j+k-l
::  i=j*k;  ....>    i=j*k
::  x=y*z/s;  ....>   x=y*z/s
::  statement_1;statement2;statement3;...
::   .......>    tr(statement_1)& tr(statement_2)& tr(statement_3)&...
::  if (statement_1){statement_2;statement_3;...}
::   .......>    tr(statement_1) implies tr(statement_2)& tr(statement_3)&..;
::  if (statement_1){statement_2;statement_3;...} else statement_4;
::   .......>  (tr(statement_1) implies tr(statement_2)& tr(statement_3)&..)&
::             (not tr(statement_1) implies tr(statement_4));
::  for (i=1;i++;i<=n)statement_1;
::   .......> for i being Integer st 1<=i & i<=n holds tr(statement_1);
::  for (i=1;i++;i<=n){statement_1;statement_2;...;if (statement_3)break;}
::   .......> (ex j being Integer st 1<=j & j<=n &
::                 (for i being Integer st 1<=i & i<j holds
::                  tr(statement_1 for i)& tr(statement_2 for i)&...
::                                & not (statement_3 for i))&
::                 &tr(statement_1 for j)& tr(statement_2 for j)&...
::                 &statement_3 for j)
::                or
::                 (for i being Integer st 1<=i & i<=n holds
::                  tr(statement_1 for i)& tr(statement_2 for i)&...
::                                & not (statement_3 for i));
:: ***If "break" is expected in the above "for statement",
:: then "or" part can be deleted.
::------
:: arrays correspondence:
::  int a[n+1]   .....> ex a being FinSequence of INT st len a=n & ...;
::  float x[n+1] .....> ex x being FinSequence of REAL st len x=n & ...;
::  Declaration of variables corresponds to existential statement.
::------
:: various correctness problem:
::   1. mathematical algorithm   .....>  a function is well defined in Mizar
::   2. semantic correctness   .....> by theorems connecting it with
::         other mathematical or computational concepts in Mizar
::   3. area check of variable of array .....> by a theorem checking
::                                                the area, in Mizar
::   4. Is the translation to logic formula correct?
::                    ......> by other methods outside of Mizar
::   5. overflow problem  .....> by other theorems, maybe in Mizar
::   6. error about float .....> avoid "=" sign in if clause,
::                 or corresponding float to other types not Real
::   7. translation of usual programs to non overwriting programs
::                    ......>  by other methods outside of Mizar
::------
:: other comments:
::   A concept of non overwriting is important, not only
:: because of proving correctness, but because of debugging and
:: safety of data.
::   As memory is now cheap enough, it is wise to save all history of
:: variables in a program.
::-------------------------
::-------------------------

theorem Th1:
  for n,m,k being Element of NAT holds (n+k)-'(m+k)=n-'m
proof
  let n,m,k be Element of NAT;
A1: n+k-(m+k)=n-m;
  per cases;
  suppose n-m>=0;
    then n-'m=n-m by BINARITH:def 3;
    hence (n+k)-'(m+k)=n-'m by A1,BINARITH:def 3;
  end;
  suppose
A2: n-m<0;
    then n-'m=0 by BINARITH:def 3;
    hence (n+k)-'(m+k)=n-'m by A1,A2,BINARITH:def 3;
  end;
end;

theorem Th2:
  for n,k being Element of NAT st k>0 & n mod (2*k)>=k holds
  n mod (2*k)-k= n mod k & (n mod k) +k = n mod (2*k)
proof
  let n,k be Element of NAT;
  assume
A1: k>0 & n mod (2*k)>=k;
  ( ex t be Nat st n = 2*k * t + (n mod (2*k)) & n mod (2*k) < 2*k )
  or n mod (2*k) = 0 & 2*k = 0 by NAT_D:def 2;
  then consider t be Nat such that
A2: n=2*k*t + (n mod (2*k)) by A1;
  reconsider t as Element of NAT by ORDINAL1:def 13;
  (n mod (2*k))-k>=0 by A1,XREAL_1:50;
  then
A3: (n mod (2*k))-'k=(n mod (2*k))-k by BINARITH:def 3;
  then
A4: n=k*(2*t+1)+((n mod (2*k))-'k) by A2;
  2*k>2*0 by A1,XREAL_1:70;
  then n mod (2*k)<2*k by NAT_D:1;
  then (n mod (2*k))-k<2*k-k by XREAL_1:11;
  hence ((n mod (2*k))-k)= (n mod k) by A3,A4,NAT_D:def 2;
  hence thesis;
end;

theorem Th3:
  for n,k being Element of NAT st k>0 & n mod (2*k)>=k holds
  n div k= (n div (2*k))*2+1
proof
  let n,k be Element of NAT;
  assume
A1: k>0 & n mod (2*k)>=k;
  then 2*k>2*0 by XREAL_1:70;
  then
A2: n=2*k*( n div (2*k))+ (n mod (2*k)) by NAT_D:2
    .=2*k*( n div (2*k))+((n mod k) +k) by A1,Th2
    .=k*(2*( n div (2*k))+1)+(n mod k);
  n mod k<k by A1,NAT_D:1;
  hence thesis by A2,NAT_D:def 1;
end;

theorem Th4:
  for n,k being Element of NAT st k>0 & n mod (2*k)<k holds
  n mod (2*k)= n mod k
proof
  let n,k be Element of NAT;
  assume
A1: k>0 & n mod (2*k)<k;
  ( ex t be Nat st n = 2*k * t + (n mod (2*k)) & n mod (2*k) < 2*k )
  or n mod (2*k) = 0 & 2*k = 0 by NAT_D:def 2;
  then consider t be Nat such that
A2: n=2*k*t + (n mod (2*k)) by A1;
  reconsider t as Element of NAT by ORDINAL1:def 13;
  n=k*(2*t)+ (n mod (2*k)) by A2;
  hence thesis by A1,NAT_D:def 2;
end;

theorem Th5:
  for n,k being Element of NAT st k>0 & n mod (2*k)<k holds
  n div k= (n div (2*k))*2
proof
  let n,k be Element of NAT;
  assume
A1: k>0 & n mod (2*k)<k;
  then 2*k>2*0 by XREAL_1:70;
  then
A2: n=2*k*( n div (2*k))+ (n mod (2*k)) by NAT_D:2
    .=k*(2*( n div (2*k)))+(n mod k) by A1,Th4;
  n mod k<k by A1,NAT_D:1;
  hence thesis by A2,NAT_D:def 1;
end;

registration
  let C be set, f be PartFunc of C, INT, x be set;
  cluster f.x -> integer;
  coherence
  proof
    per cases;
    suppose x in dom f;
      then f.x in rng f by FUNCT_1:def 5;
      hence thesis by INT_1:def 2;
    end;
    suppose not x in dom f;
      hence thesis by FUNCT_1:def 4;
    end;
  end;
end;

theorem Th6:
  for m,n being Element of NAT st m>0 ex i being Element of NAT st
  (for k2 being Element of NAT st k2<i holds m*(2|^k2)<=n) & m*(2|^i)>n
proof
  let m,n be Element of NAT;
  assume
A1: m>0;
  then
A2: m*(2|^(n+1-'1))>m*(n+1-'1) by NEWTON:105,XREAL_1:70;
  n+1-1=n;
  then
A3: n+1-'1=n by BINARITH:def 3;
  m>=0+1 by A1,NAT_1:13;
  then m*n>=1*n by XREAL_1:66;
  then
A4: m*(2|^(n+1-'1))> n by A2,A3,XXREAL_0:2;
  defpred P[Nat] means m*(2|^$1)> n;
A5: ex k being Nat st P[k] by A4;
  ex k being Nat st P[k] & for j being Nat st P[j]
  holds k<=j from NAT_1:sch 5(A5);
  then consider k being Nat such that
A6: P[k] & for j being Nat st P[j] holds k<=j;
A7: k in NAT by ORDINAL1:def 13;
  for k2 being Element of NAT st k2<k holds m*(2|^(k2))<=n by A6;
  hence thesis by A6,A7;
end;

theorem Th7:
  for i being Integer,f being FinSequence st 1<=i & i<=len f holds i in dom f
proof
  let i be Integer,f be FinSequence;
  assume
A1: 1<=i & i<=len f;
  then i is Element of NAT by INT_1:16;
  hence i in dom f by A1,FINSEQ_3:27;
end;

:: Overwrting program to divide n by m (n>=0&m>0),where division / used is
:: special, because it is achieved by shifting a word.
:: int idiv1_prg(int n,int m){
::   int sm,sn,pn,i,j;
::   if(n<m){return 0;}
::   sm=m;
::   for (i=1;i<=n;i++){sm=sm*2; if (sm >n)break;}
::   pn=0;sn=n;sm=sm/2;
::   for (j=1;j<=i;j++){
::   if(sn>=sm){sn=sn-sm;sm=sm/2;pn=pn*2+1;} else {sm=sm/2;pn=pn*2;}
::   }
::   return pn;
:: }
:: Non overwrting program same as above, assuming n>=0 & m>0
:: int idiv1_prg(int n,int m){
::    int sm[n+1+1],sn[n+1+1],pn[n+1+1],i,j;
::    if (n<m){return 0;}
::    sm[1]=m;
::    for (i=1;i<=n;i++){
::     sm[i+1]=sm[i]*2;
::     if(sm[i+1]>n){break;}
::     }
::    pn[i+1]=0;sn[i+1]=n;
::    for (j=1;j<=i;j++){
::     if(sn[i+1-(j-1)]>=sm[i+1-j]){sn[i+1-j]=sn[i+1-(j-1)]-sm[i+1-j];
::           pn[i+1-j]=pn[i+1-(j-1)]*2+1;}
::        else {sn[i+1-j]=sn[i+1-(j-1)]; pn[i+1-j]=pn[i+1-(j-1)]*2;}
::        }
::     return pn[1];
::   }

definition
  let n,m be Integer;
  assume
A1: n>=0 & m>0;
  func idiv1_prg(n,m) -> Integer means
  :Def1:
  ex sm,sn,pn being FinSequence of INT st
  len sm=n+1 & len sn=n+1 & len pn=n+1 & (n<m implies it=0)&
  (not (n<m) implies sm.1=m & ( ex i being Integer st 1<=i & i<=n &
  ((for k being Integer st 1<=k & k<i holds
  sm.(k+1)=sm.(k)*2 & not(sm.(k+1)>n)) & sm.(i+1)=sm.(i)*2 & sm.(i+1)>n ) &
  pn.(i+1)=0 & sn.(i+1)=n & (for j being Integer st 1<=j & j<=i holds
  (sn.(i+1- (j- 1))>=sm.(i+1- j) implies
  sn.(i+1- j)=sn.(i+1- (j- 1))-sm.(i+1- j) & pn.(i+1- j)=pn.(i+1- (j- 1))*2+1
  )& (not sn.(i+1- (j- 1))>=sm.(i+1- j) implies sn.(i+1- j)=sn.(i+1- (j- 1)) &
  pn.(i+1- j)=pn.(i+1- (j- 1))*2 ) )& it=pn.1 ) );
  existence
  proof
    reconsider n2=n,m2=m as Element of NAT by A1,INT_1:16;
    per cases;
    suppose
A2:   n<m;
      set ssm = Seg (n2+1) --> 1;
A3:   dom ssm = Seg (n2+1) by FUNCOP_1:19;
      then reconsider ssm as FinSequence by FINSEQ_1:def 2;
A4:   rng ssm c= {1} by FUNCOP_1:19;
      rng ssm c= INT
      proof
        let y be set;
        assume y in rng ssm;
        then y=1 by A4,TARSKI:def 1;
        hence y in INT by INT_1:def 2;
      end;
      then reconsider ssm as FinSequence of INT by FINSEQ_1:def 4;
      set ssn=ssm,ppn=ssm;
      len ssm=n+1 & len ssn=n+1 & len ppn=n+1 & (n<m implies n div m=0)&
      (not (n<m) implies ssm.1=m & ( ex i being Integer st 1<=i & i<=n &
      ((for k being Integer st 1<=k & k<i holds
      ssm.(k+1)=ssm.(k)*2 & not(ssm.(k+1)>n))
      & ssm.(i+1)=ssm.(i)*2 & ssm.(i+1)>n ) & ppn.(i+1)=0 & ssn.(i+1)=n &
      (for j being Integer st 1<=j & j<=i holds
      (ssn.(i+1- (j- 1))>=ssm.(i+1- j) implies
      ssn.(i+1- j)=ssn.(i+1- (j- 1))-ssm.(i+1- j) &
      ppn.(i+1- j)=ppn.(i+1- (j- 1))*2+1 )&
      (not ssn.(i+1- (j- 1))>=ssm.(i+1- j) implies
      ssn.(i+1- j)=ssn.(i+1- (j- 1)) & ppn.(i+1- j)=ppn.(i+1- (j- 1))*2 ) )&
      n div m=ppn.1 ) ) by A2,A3,FINSEQ_1:def 3,PRE_FF:4;
      hence thesis;
    end;
    suppose
A5:   n>=m;
      then n2>=0+1 by A1,NAT_1:13;
      then 1< n2+1 by NAT_1:13;
      then
A6:   1 in Seg (n2+1) by FINSEQ_1:3;
      deffunc F1(Nat) = m2*(2|^($1-'1));
      ex ssm being FinSequence st len ssm=n2+1 &
      for k2 being Nat st k2 in dom ssm holds
      ssm.k2=F1(k2) from FINSEQ_1:sch 2;
      then consider ssm being FinSequence such that
A7:   len ssm=n2+1 & for k2 being Nat st k2 in dom ssm holds
      ssm.k2=m*(2|^(k2-'1));
A8: dom ssm = Seg(n2+1) by A7,FINSEQ_1:def 3;
      rng ssm c= INT
      proof
        let y be set;
        assume y in rng ssm;
        then consider x being set such that
A9:     x in dom ssm & y=ssm.x by FUNCT_1:def 5;
        reconsider n=x as Element of NAT by A9;
        ssm.n=m*(2|^(n-'1)) by A7,A9;
        hence y in INT by A9,INT_1:def 2;
      end;
      then reconsider ssm as FinSequence of INT by FINSEQ_1:def 4;
      deffunc F(Nat) = n2 mod (m2*(2|^($1-'1)));
      ex ssn being FinSequence st len ssn=n2+1 &
      for k2 being Nat st k2 in dom ssn holds
      ssn.k2=F(k2) from FINSEQ_1:sch 2;
      then consider ssn being FinSequence such that
A11:  len ssn=n2+1 & for k2 being Nat st k2 in dom ssn holds
      ssn.k2=n2 mod (m2*(2|^(k2-'1)));
A12: dom ssn = Seg(n2+1) by A11,FINSEQ_1:def 3;
      rng ssn c= INT
      proof
        let y be set;
        assume y in rng ssn;
        then consider x being set such that
A13:    x in dom ssn & y=ssn.x by FUNCT_1:def 5;
        reconsider n3=x as Element of NAT by A13;
        ssn.n3=n2 mod (m2*(2|^(n3-'1))) by A11,A13;
        hence y in INT by A13,INT_1:def 2;
      end;
      then reconsider ssn as FinSequence of INT by FINSEQ_1:def 4;
      deffunc F3(Nat)= n2 div (m2*(2|^($1-'1)));
      ex ppn being FinSequence st len ppn=n2+1 &
      for k2 being Nat st k2 in dom ppn holds
      ppn.k2= F3(k2) from FINSEQ_1:sch 2;
      then consider ppn being FinSequence such that
A15:  len ppn=n+1 & for k2 being Nat st k2 in dom ppn holds
      ppn.k2= n2 div (m2*(2|^(k2-'1)));
A16: dom ppn = Seg(n2+1) by A15,FINSEQ_1:def 3;
      rng ppn c= INT
      proof
        let y be set;
        assume y in rng ppn;
        then consider x being set such that
A17:    x in dom ppn & y=ppn.x by FUNCT_1:def 5;
        reconsider n3=x as Element of NAT by A17;
        ppn.n3=n2 div (m2*(2|^(n3-'1))) by A15,A17;
        hence y in INT by A17,INT_1:def 2;
      end;
      then reconsider ppn as FinSequence of INT by FINSEQ_1:def 4;
A19:  m2*(2 |^ 0) = m2*1 by NEWTON:9
        .= m2;
A20:  ppn.1=n2 div (m2*(2|^(1-'1))) by A6,A15,A16
        .=n2 div m2 by A19,BINARITH:51;
A21:  ssm.1=m*(2|^(1-'1)) by A6,A7,A8
        .=m*(2|^0) by BINARITH:51
        .=m*1 by NEWTON:9
        .=m;
      consider ii0 being Element of NAT such that
A22:  (for k2 being Element of NAT st k2<ii0 holds m*(2|^(k2))<=n2)
      & m2*(2|^(ii0))>n2 by A1,Th6;
      reconsider i0=ii0 as Integer;
      now
        assume i0=0;
        then m2*1>n2 by A22,NEWTON:9;
        hence contradiction by A5;
      end;
      then ii0>0;
      then
A23:  ii0>=0+1 by NAT_1:13;
      then
A24:  i0-1>=0 by XREAL_1:50;
A25:  now
        assume i0>n2;
        then
A26:    m*(2|^n2) <= n2 by A22;
        1+0<=m2 by A1,NAT_1:13;
        then 1*(2|^n2)<=m2*(2|^n2) by XREAL_1:66;
        then
A27:    (2|^n2)<=n2 by A26,XXREAL_0:2;
        n2+1<= 2|^n2 by NEWTON:104;
        hence contradiction by A27,NAT_1:13;
      end;
      then
A28:  i0+1<=n2+1 by XREAL_1:9;
      i0<n2+1 by A25,NAT_1:13;
      then
A29:  ii0 in Seg(n2+1) by A23,FINSEQ_1:3;
      1<=i0+1 by A23,NAT_1:13;
      then ii0+1 in Seg(n2+1) by A28,FINSEQ_1:3;
      then
A30:  ssm.(i0+1)=m*(2|^(ii0+1-'1)) by A7,A8;
      ii0+1-' 1=i0-1+1 by BINARITH:39
        .=ii0-' 1+1 by A24,BINARITH:def 3;
      then 2|^(ii0+1-'1)=(2|^(ii0-'1))*2 by NEWTON:11;
      then
A31:  ssm.(i0+1) =m*(2|^(ii0-'1))*2 by A30
        .=(ssm.i0)*2 by A7,A29,A8;
A32:  for k being Element of NAT st 1<=k & k<i0 holds
      ssm.(k+1)=ssm.(k)*2 & not(ssm.(k+1)>n)
      proof
        let k be Element of NAT;
        assume
A33:    1<=k & k<i0;
        then
A34:    k<=n2 by A25,XXREAL_0:2;
A35:    k-1>=0 by A33,XREAL_1:50;
A36:    1<k+1 by A33,NAT_1:13;
A37:    k+1-'1=k by BINARITH:39;
        k+1<=n2+1 by A34,XREAL_1:9;
        then k+1 in Seg (n2+1) by A36,FINSEQ_1:3;
        then
A38:    ssm.(k+1)=m*(2|^(k+1-'1)) by A7,A8;
        k<=n2+1 by A34,NAT_1:12;
        then k in Seg (n2+1) by A33,FINSEQ_1:3;
        then
A39:    ssm.(k)=m*(2|^(k-'1)) by A7,A8;
        k+1-'1=k-1+1 by BINARITH:39
          .=k-' 1+1 by A35,BINARITH:def 3;
        then 2|^(k+1-'1)=(2|^(k-'1))*2 by NEWTON:11;
        hence ssm.(k+1)=ssm.(k)*2 & not(ssm.(k+1)>n) by A22,A33,A37,A38,A39;
      end;
A40:  for k being Integer st 1<=k & k<i0 holds
      ssm.(k+1)=ssm.(k)*2 & not(ssm.(k+1)>n)
      proof
        let k be Integer;
        assume
A41:    1<=k & k<i0;
        then reconsider kk=k as Element of NAT by INT_1:16;
        ssm.(kk+1)=ssm.(kk)*2 & not(ssm.(kk+1)>n) by A32,A41;
        hence ssm.(k+1)=ssm.(k)*2 & not(ssm.(k+1)>n);
      end;
A42:  1<=1+ii0 by NAT_1:11;
A43:  ii0+1-'1=ii0 by BINARITH:39;
      i0+1<=n2+1 by A25,XREAL_1:9;
      then
A44:  ii0+1 in (Seg (n2+1)) by A42,FINSEQ_1:3;
      then
A45:  ssm.(i0+1)>n by A7,A22,A43,A8;
      i0 <n2+1 by A25,NAT_1:13;
      then
A46:  ii0+1<=n2+1 by NAT_1:13;
      0+1<=i0+1 by XREAL_1:9;
      then ii0+1 in Seg (n2+1) by A46,FINSEQ_1:3;
      then
A47:  ssn.(i0+1)=n2 mod (m2*(2|^(ii0+1-'1))) by A11,A12;
      reconsider k5=m2*(2|^(ii0+1-'1)) as Element of NAT;
A48:  k5>n2 by A22,BINARITH:39;
      n2 div (m2*(2|^(ii0+1-'1)))=0 by A22,A43,NAT_D:27;
      then
A49:  ppn.(i0+1)=0 & ssn.(i0+1)=n by A15,A44,A47,A48,NAT_D:24,A16;
      for j being Integer st 1<=j & j<=i0 holds
      (ssn.(i0+1- (j- 1))>=ssm.(i0+1- j) implies
      ssn.(i0+1- j)=ssn.(i0+1- (j- 1))-ssm.(i0+1-j) &
      ppn.(i0+1- j)=ppn.(i0+1- (j- 1))*2+1 )&
      (not ssn.(i0+1- (j- 1))>=ssm.(i0+1- j) implies
      ssn.(i0+1- j)=ssn.(i0+1- (j- 1)) & ppn.(i0+1- j)=ppn.(i0+1- (j- 1))*2 )
      proof
        let j be Integer;
        assume
A50:    1<=j & j<=i0;
        then reconsider jj=j as Element of NAT by INT_1:16;
A51:    i0-j>=0 by A50,XREAL_1:50;
        then
A52:    ii0-' jj=i0-j by BINARITH:def 3;
A53:    j-1>=0 by A50,XREAL_1:50;
        thus (ssn.(i0+1- (j- 1))>=ssm.(i0+1- j) implies
        ssn.(i0+1- j)=ssn.(i0+1- (j- 1))-ssm.(i0+1- j) &
        ppn.(i0+1- j)=ppn.(i0+1- (j- 1))*2+1 )
        proof
          assume
A54:      ssn.(i0+1- (j- 1))>=ssm.(i0+1- j);
A55:      jj-' 1=j-1 by A53,BINARITH:def 3;
A56:      j+1<=i0+1 by A50,XREAL_1:9;
          j<j+1 by XREAL_1:31;
          then
A57:      j<i0+1 by A56,XXREAL_0:2;
          ii0<ii0+1 by NAT_1:13;
          then j<i0+1 by A50,XXREAL_0:2;
          then
A58:      i0+1-j>0 by XREAL_1:52;
          then
A59:      ii0+1-' jj=i0+1-j by BINARITH:def 3;
A60:      ii0+1-' jj=i0-j+1 by A58,BINARITH:def 3;
A61:      ii0+1-' jj=i0+1-j by A58,BINARITH:def 3;
          jj-' 1<=j by BINARITH:52;
          then jj-' 1<i0+1 by A57,XXREAL_0:2;
          then
A62:      ii0+1-(jj -' 1)>=0 by XREAL_1:50;
          then
A63:      ii0+1-' (jj-' 1)=i0+1-j+1 by A55,BINARITH:def 3;
          then
A64:      ii0+1-' (jj-' 1)-' 1=ii0+1-' jj by A59,BINARITH:39;
A65:      ii0+1-' (jj-' 1)=i0+1-(j-1) by A55,A62,BINARITH:def 3;
          ii0<ii0+1 by NAT_1:13;
          then j<i0+1 by A50,XXREAL_0:2;
          then i0+1-j>=0 by XREAL_1:50;
          then
A66:      ii0+1-' jj=i0+1-j by BINARITH:def 3;
          i0+1<=n2+j by A25,A50,XREAL_1:9;
          then i0+1-j<=n2+j-j by XREAL_1:11;
          then
A67:      ii0+1-' jj+1<=n2+1 by A66,XREAL_1:9;
          1<=ii0+1-' (jj-' 1) by A59,A63,NAT_1:11;
          then
A68:      ii0+1-' (jj-' 1) in Seg (n2+1) by A59,A63,A67,FINSEQ_1 :3;
          then
A69:      ssn.(ii0+1-' (jj-' 1))=n2 mod (m2*(2|^(ii0+1-' (jj-' 1 )-' 1 )))
          by A11,A12;
A70:      ii0+1-' jj>=0+1 by A58,A59,NAT_1:13;
          then ii0+1-' jj -1>=0 by XREAL_1:50;
          then
A71:      ii0+1-' jj -' 1=i0-j by A59,BINARITH:def 3;
A72:      ii0+1-' jj<=i0+1 by BINARITH:52;
          i0+1<=n2+1 by A25,XREAL_1:9;
          then n2+1>=(ii0+1-' jj) by A72,XXREAL_0:2;
          then
A73:      ii0+1-' (jj) in Seg (n2+1) by A70,FINSEQ_1:3;
          then
A74:      ssn.(ii0+1-' jj)=n2 mod (m2*(2|^(ii0+1-' jj-' 1))) by A11,A12;
A75:      jj-' 1=j-1 by A53,BINARITH:def 3;
A76:      j+1<=i0+1 by A50,XREAL_1:9;
          jj<jj+1 by NAT_1:13;
          then
A77:      j<i0+1 by A76,XXREAL_0:2;
          jj-' 1<=jj by BINARITH:52;
          then jj-' 1<i0+1 by A77,XXREAL_0:2;
          then ii0+1-(jj -' 1)>=0 by XREAL_1:50;
          then ii0+1-' (jj-' 1)=ii0+1-' jj+1 by A59,A75,BINARITH:def 3;
          then
A78:      ssn.(ii0+1-' (jj-' 1))
          =n2 mod (m2*(2|^(ii0+1-' jj))) by A69,BINARITH:39;
          ii0+1-' jj-1>=0 by A50,A60,XREAL_1:50;
          then
A79:      ii0+1-' jj-' 1 =i0-j by A59,BINARITH:def 3
            .=ii0-' jj
          by A51,BINARITH:def 3;
A80:      m2*(2|^(ii0+1-' jj))=m2*(2|^(ii0-' jj+1)) by A52,A58, BINARITH:def 3
            .=m2*((2|^(ii0-' jj))*2) by NEWTON:11
            .=2*(m2*(2|^(ii0-' jj)));
A81:      ssm.(ii0+1-' jj)=m2*(2|^(ii0-' jj)) by A7,A73,A79,A8;
          2|^(ii0-' jj)<>0 by CARD_4:51;
          then 2|^(ii0-' jj)>0;
          then
A82:      m2*(2|^(ii0-' jj))> m2*0 by A1,XREAL_1:70;
          then
A83:      ssn.(ii0+1-' (jj-' 1))-ssm.(ii0+1-' jj)
          = n2 mod (m2*(2|^(ii0-' jj))) by A54,A61,A63,A78,A80,A81,Th2;
          ppn.(ii0+1-' jj)=n2 div (m2*(2|^(ii0+1-' jj-' 1))) by A15,A73,A16
            .= (n2 div (m2*(2|^(ii0+1-' (jj-' 1)-' 1))))*2+1
          by A54,A59,A64,A65,A69,A79,A80,A81,A82,Th3
            .= ppn.(ii0+1-' (jj-' 1))*2+1 by A15,A68,A16;
          hence ssn.(i0+1- j)=ssn.(i0+1- (j- 1))-ssm.(i0+1- j) &
          ppn.(i0+1- j)=ppn.(i0+1- (j- 1))*2+1 by A59,A63,A71,A74,A83,
          BINARITH:def 3;
        end;
        thus (not ssn.(i0+1- (j- 1))>=ssm.(i0+1- j) implies
        ssn.(i0+1- j)=ssn.(i0+1- (j- 1)) & ppn.(i0+1- j)=ppn.(i0+1- (j- 1))*2
        )
        proof
          assume
A84:      not ssn.(i0+1- (j- 1))>=ssm.(i0+1- j);
A85:      jj-' 1=j-1 by A53,BINARITH:def 3;
A86:      j+1<=i0+1 by A50,XREAL_1:9;
          jj<jj+1 by NAT_1:13;
          then
A87:      j<i0+1 by A86,XXREAL_0:2;
          ii0<ii0+1 by NAT_1:13;
          then j<i0+1 by A50,XXREAL_0:2;
          then
A88:      i0+1-j>0 by XREAL_1:52;
          then
A89:      ii0+1-' jj=i0+1-j by BINARITH:def 3;
A90:      ii0+1-' jj=i0-j+1 by A88,BINARITH:def 3;
          jj-' 1<=jj by BINARITH:52;
          then jj-' 1<i0+1 by A87,XXREAL_0:2;
          then
A91:      i0+1-(jj -' 1)>=0 by XREAL_1:50;
          then
A92:      ii0+1-' (jj-' 1)=i0+1-j+1 by A85,BINARITH:def 3;
          then
A93:      ii0+1-' (jj-' 1)-' 1=ii0+1-' jj by A89,BINARITH:39;
          ii0<ii0+1 by NAT_1:13;
          then j<i0+1 by A50,XXREAL_0:2;
          then i0+1-j>=0 by XREAL_1:50;
          then
A94:      ii0+1-' jj=i0+1-j by BINARITH:def 3;
          i0+1<=n2+j by A25,A50,XREAL_1:9;
          then i0+1-j<=n2+j-j by XREAL_1:11;
          then
A95:      ii0+1-' jj+1<=n2+1 by A94,XREAL_1:9;
          1<=ii0+1-' (jj-' 1) by A89,A92,NAT_1:11;
          then
A96:      ii0+1-' (jj-' 1) in Seg (n2+1) by A89,A92,A95,FINSEQ_1 :3;
          then
A97:      ssn.(ii0+1-' (jj-' 1))=n2 mod (m2*(2|^(ii0+1-' (jj-' 1 )-' 1 )))
          by A11,A12;
A98:      ii0+1-' jj>=0+1 by A88,A89,NAT_1:13;
          then ii0+1-' jj -1>=0 by XREAL_1:50;
          then
A99:      ii0+1-' jj -' 1=i0-j by A89,BINARITH:def 3;
A100:      ii0+1-' jj<=ii0+1 by BINARITH:52;
          i0+1<=n2+1 by A25,XREAL_1:9;
          then n2+1>=(ii0+1-' jj) by A100,XXREAL_0:2;
          then
A101:      ii0+1-' (jj) in Seg (n2+1) by A98,FINSEQ_1:3;
          then ssn.(ii0+1-' jj)=n2 mod (m2*(2|^(ii0+1-' jj-' 1))) by A11,A12;
          then
A102:      ssn.(ii0+1-' jj) =n2 mod (m2*(2|^(ii0-' jj))) by A99,
          BINARITH:def 3;
A103:     jj-' 1=j-1 by A53,BINARITH:def 3;
A104:     j+1<=i0+1 by A50,XREAL_1:9;
          jj<jj+1 by NAT_1:13;
          then
A105:     j<i0+1 by A104,XXREAL_0:2;
          jj-' 1<=j by BINARITH:52;
          then jj-' 1<i0+1 by A105,XXREAL_0:2;
          then i0+1-(jj -' 1)>=0 by XREAL_1:50;
          then
A106:     ii0+1-' (jj-' 1)=i0+1-j+1 by A103,BINARITH:def 3
            .=ii0+1-' jj+1 by A88,BINARITH:def 3;
A107:     ii0+1-' (jj-' 1)=i0+1-(j-1) by A85,A91,BINARITH:def 3;
A108:     ssn.(ii0+1-' (jj-' 1))
          =n2 mod (m2*(2|^(ii0+1-' jj))) by A97,A106,BINARITH:39;
          ii0+1-' jj-1>=0 by A50,A90,XREAL_1:50;
          then
A109:     ii0+1-' jj-' 1 =i0-j by A89,BINARITH:def 3
            .=ii0-' jj
          by A51,BINARITH:def 3;
A110:     m2*(2|^(ii0+1-' jj))=m2*(2|^(ii0-' jj+1)) by A52,A88, BINARITH:def 3
            .=m2*((2|^(ii0-' jj))*2) by NEWTON:11
            .=2*(m2*(2|^(ii0-' jj)));
A111:     ssm.(ii0+1-' jj)=m2*(2|^(ii0-' jj)) by A7,A101,A109,A8;
          ppn.(ii0+1-' jj)=n2 div (m2*(2|^(ii0+1-' jj-' 1))) by A15,A101,A16

            .= (n2 div (m2*(2|^(ii0+1-' (jj-' 1)-' 1))))*2
          by A84,A89,A93,A97,A107,A109,A110,A111,Th5
            .= ppn.(ii0+1-' (jj-' 1))*2 by A15,A96,A16;
          hence thesis by A84,A89,A92,A102,A108,A110,A111,Th4;
        end;
      end;
      hence thesis by A5,A7,A11,A15,A20,A21,A23,A25,A31,A40,A45,A49;
    end;
  end;
  uniqueness
  proof
    let t1,t2 be Integer;
    assume
A112: (ex sm,sn,pn being FinSequence of INT st
    len sm=n+1 & len sn=n+1 & len pn=n+1 & (n<m implies t1=0)&
    (not (n<m) implies sm.1=m & ( ex i being Integer st 1<=i & i<=n &
    ((for k being Integer st 1<=k & k<i holds
    sm.(k+1)=sm.(k)*2 & not(sm.(k+1)>n)) & sm.(i+1)=sm.(i)*2 & sm.(i+1)>n ) &
    pn.(i+1)=0 & sn.(i+1)=n & (for j being Integer st 1<=j & j<=i holds
    (sn.(i+1- (j- 1))>=sm.(i+1- j) implies
    sn.(i+1- j)=sn.(i+1- (j- 1))-sm.(i+1- j) &
    pn.(i+1- j)=pn.(i+1- (j- 1))*2+1 )&
    (not sn.(i+1- (j- 1))>=sm.(i+1- j) implies sn.(i+1- j)=sn.(i+1- (j- 1)) &
    pn.(i+1- j)=pn.(i+1- (j- 1))*2 ) )& t1=pn.1 ) ) ) &
    (ex sm,sn,pn being FinSequence of INT st
    len sm=n+1 & len sn=n+1 & len pn=n+1 & (n<m implies t2=0)&
    (not (n<m) implies sm.1=m & ( ex i being Integer st 1<=i & i<=n &
    ((for k being Integer st 1<=k & k<i holds
    sm.(k+1)=sm.(k)*2 & not(sm.(k+1)>n)) & sm.(i+1)=sm.(i)*2 & sm.(i+1)>n ) &
    pn.(i+1)=0 & sn.(i+1)=n & (for j being Integer st 1<=j & j<=i holds
    (sn.(i+1- (j- 1))>=sm.(i+1- j) implies
    sn.(i+1- j)=sn.(i+1- (j- 1))-sm.(i+1- j) &
    pn.(i+1- j)=pn.(i+1- (j- 1))*2+1 )&
    (not sn.(i+1- (j- 1))>=sm.(i+1- j) implies sn.(i+1- j)=sn.(i+1- (j- 1)) &
    pn.(i+1- j)=pn.(i+1- (j- 1))*2 ) )& t2=pn.1 ) ));
    then consider sm1,sn1,pn1 being FinSequence of INT such that
A113: len sm1=n+1 & len sn1=n+1 & len pn1=n+1 & (n<m implies t1=0)&
    (not (n<m) implies sm1.1=m & ( ex i being Integer st 1<=i & i<=n &
    ((for k being Integer st 1<=k & k<i holds
    sm1.(k+1)=sm1.(k)*2 & not(sm1.(k+1)>n))
    & sm1.(i+1)=sm1.(i)*2 & sm1.(i+1)>n ) & pn1.(i+1)=0 & sn1.(i+1)=n &
    (for j being Integer st 1<=j & j<=i holds
    (sn1.(i+1- (j- 1))>=sm1.(i+1- j) implies
    sn1.(i+1- j)=sn1.(i+1- (j- 1))-sm1.(i+1- j) &
    pn1.(i+1- j)=pn1.(i+1- (j- 1))*2+1 )&
    (not sn1.(i+1- (j- 1))>=sm1.(i+1- j) implies
    sn1.(i+1- j)=sn1.(i+1- (j- 1)) & pn1.(i+1- j)=pn1.(i+1- (j- 1))*2 ) )&
    t1=pn1.1 ) );
    consider sm2,sn2,pn2 being FinSequence of INT such that
A114: len sm2=n+1 & len sn2=n+1 & len pn2=n+1 & (n<m implies t2=0)&
    (not (n<m) implies sm2.1=m & ( ex i being Integer st 1<=i & i<=n &
    ((for k being Integer st 1<=k & k<i holds
    sm2.(k+1)=sm2.(k)*2 & not(sm2.(k+1)>n))
    & sm2.(i+1)=sm2.(i)*2 & sm2.(i+1)>n ) & pn2.(i+1)=0 & sn2.(i+1)=n &
    (for j being Integer st 1<=j & j<=i holds
    (sn2.(i+1- (j- 1))>=sm2.(i+1- j) implies
    sn2.(i+1- j)=sn2.(i+1- (j- 1))-sm2.(i+1- j) &
    pn2.(i+1- j)=pn2.(i+1- (j- 1))*2+1 )&
    (not sn2.(i+1- (j- 1))>=sm2.(i+1- j) implies
    sn2.(i+1- j)=sn2.(i+1- (j- 1)) & pn2.(i+1- j)=pn2.(i+1- (j- 1))*2 ) )&
    t2=pn2.1 ) ) by A112;
    now per cases;
      suppose n<m;
        hence t1=t2 by A113,A114;
      end;
      suppose
A115:   n>=m;
        then consider i1 being Integer such that
A116:   1<=i1 & i1<=n & ((for k being Integer st 1<=k & k<i1 holds
        sm1.(k+1)=sm1.(k)*2 & not(sm1.(k+1)>n))
        & sm1.(i1+1)=sm1.(i1)*2 & sm1.(i1+1)>n ) &
        pn1.(i1+1)=0 & sn1.(i1+1)=n &
        (for j being Integer st 1<=j & j<=i1 holds
        (sn1.(i1+1- (j- 1))>=sm1.(i1+1- j) implies
        sn1.(i1+1- j)=sn1.(i1+1- (j- 1))-sm1.(i1+1- j) &
        pn1.(i1+1- j)=pn1.(i1+1- (j- 1))*2+1 )&
        (not sn1.(i1+1- (j- 1))>=sm1.(i1+1- j) implies
        sn1.(i1+1- j)=sn1.(i1+1- (j- 1)) & pn1.(i1+1- j)=pn1.(i1+1- (j- 1))*2
        ) )& t1=pn1.1 by A113;
        consider i2 being Integer such that
A117:   1<=i2 & i2<=n & ((for k being Integer st 1<=k & k<i2 holds
        sm2.(k+1)=sm2.(k)*2 & not(sm2.(k+1)>n))
        & sm2.(i2+1)=sm2.(i2)*2 & sm2.(i2+1)>n ) &
        pn2.(i2+1)=0 & sn2.(i2+1)=n &
        (for j being Integer st 1<=j & j<=i2 holds
        (sn2.(i2+1- (j- 1))>=sm2.(i2+1- j) implies
        sn2.(i2+1- j)=sn2.(i2+1- (j- 1))-sm2.(i2+1- j) &
        pn2.(i2+1- j)=pn2.(i2+1- (j- 1))*2+1 )&
        (not sn2.(i2+1- (j- 1))>=sm2.(i2+1- j) implies
        sn2.(i2+1- j)=sn2.(i2+1- (j- 1)) & pn2.(i2+1- j)=pn2.(i2+1- (j- 1))*2
        ) )& t2=pn2.1 by A114,A115;
        reconsider ii1=i1 as Element of NAT by A116,INT_1:16;
        reconsider ii2=i2 as Element of NAT by A117,INT_1:16;
A118:   now
          assume
A119:     i1<i2;
A120:     for k being Integer st 1<=k & k<=i1+1 holds sm1.k=sm2.k
          proof
            let k be Integer;
            assume
A121:       1<=k & k<=i1+1;
            then reconsider kh=k as Element of NAT by INT_1:16;
            k-1>=0 by A121,XREAL_1:50;
            then
A122:       kh-' 1=k-1 by BINARITH:def 3;
            then
A123:       kh-' 1+1=k;
A124:       k-1<=i1+1-1 by A121,XREAL_1:11;
            ii1<ii1+1 by NAT_1:13;
            then
A125:       kh-' 1<i1+1 by A122,A124,XXREAL_0:2;

defpred P[Element of NAT] means $1<i1+1 implies sm1.($1+1)=sm2.($1+1);
A126:       P[0] by A113,A114,A115;
A127:       for e being Element of NAT st P[e] holds P[e+1]
            proof
              let e be Element of NAT;
              assume
A128:         P[e];
              per cases;
              suppose e+1<i1+1;
                then e+1+1<=ii1+1 by NAT_1:13;
                then
A129:           e+1+1-1<=i1+1-1 by XREAL_1:11;
                then
A130:           e+1 <i2 by A119,XXREAL_0:2;
A131:           0+1<=e+1 by XREAL_1:9;
A132:           e<e+1 by NAT_1:13;
                now per cases;
                  case e+1<i1;
                    hence sm1.(e+1+1)=(sm1.(e+1))*2 by A116,A131;
                  end;
                  case e+1>=i1;
                    then e+1=i1 by A129,XXREAL_0:1;
                    hence sm1.(e+1+1)=(sm1.(e+1))*2 by A116;
                  end;
                end;
                hence P[e+1] by A117,A128,A130,A131,A132,XXREAL_0:2;
              end;
              suppose e+1>=i1+1;
                hence P[e+1];
              end;
            end;
            for e being Element of NAT holds P[e] from NAT_1:sch 1(A126,A127
            );
            hence sm1.k=sm2.k by A123,A125;
          end;
          0<=ii1;
          then 0+1<=i1+1 by XREAL_1:9;
          then sm1.(i1+1)=sm2.(i1+1) by A120;
          hence contradiction by A116,A117,A119;
        end;
A133:   now
          assume
A134:     i2<i1;
A135:     for k being Integer st 1<=k & k<=i2+1 holds sm2.k=sm1.k
          proof
            let k be Integer;
            assume
A136:       1<=k & k<=i2+1;
            then reconsider kh=k as Element of NAT by INT_1:16;
            k-1>=0 by A136,XREAL_1:50;
            then
A137:       kh-'1=k-1 by BINARITH:def 3;
            then
A138:       kh-'1+1=k;
A139:       k-1<=i2+1-1 by A136,XREAL_1:11;
            ii2<ii2+1 by NAT_1:13;
            then
A140:       kh-'1<i2+1 by A137,A139,XXREAL_0:2;

defpred P[Element of NAT] means $1<i2+1 implies sm2.($1+1)=sm1.($1+1);
A141:       P[0] by A113,A114,A115;
A142:       for e being Element of NAT st P[e] holds P[e+1]
            proof
              let e be Element of NAT;
              assume
A143:         P[e];
              per cases;
              suppose e+1<i2+1;
                then e+1+1<=ii2+1 by NAT_1:13;
                then
A144:           e+1+1-1<=i2+1-1 by XREAL_1:11;
                then
A145:           e+1 <i1 by A134,XXREAL_0:2;
A146:           0+1<=e+1 by XREAL_1:9;
A147:           e<e+1 by NAT_1:13;
                now per cases;
                  case e+1<i2;
                    hence sm2.(e+1+1)=(sm2.(e+1))*2 by A117,A146;
                  end;
                  case e+1>=i2;
                    then e+1=i2 by A144,XXREAL_0:1;
                    hence sm2.(e+1+1)=(sm2.(e+1))*2 by A117;
                  end;
                end;
                hence P[e+1] by A116,A143,A145,A146,A147,XXREAL_0:2;
              end;
              suppose e+1>=i2+1;
                hence P[e+1];
              end;
            end;
            for e being Element of NAT holds P[e] from NAT_1:sch 1(A141,A142
            );
            hence sm2.k=sm1.k by A138,A140;
          end;
          0<=ii2;
          then 0+1<=i2+1 by XREAL_1:9;
          then sm2.(i2+1)=sm1.(i2+1) by A135;
          hence contradiction by A116,A117,A134;
        end;
        then
A148:   i1=i2 by A118,XXREAL_0:1;
A149:   ii1<ii1+1 by NAT_1:13;

defpred P2[Element of NAT] means 1<=$1 & $1<=i1+1 implies sm1.$1=sm2.$1;
A150:   P2[0];
A151:   for kk being Element of NAT st P2[kk] holds P2[kk+1]
        proof
          let kk be Element of NAT;
          assume
A152:     P2[kk];
          1<=kk+1 & kk+1<=i1+1 implies sm1.(kk+1)=sm2.(kk+1)
          proof
            assume
A153:       1<=kk+1 & kk+1<=i1+1;
            per cases by A153,REAL_1:def 5;
            suppose
A154:         kk+1<i1+1;
              then
A155:         kk+1-1<=i2+1-1 by A148,XREAL_1:11;
              now per cases;
                case 0<kk;
                  then
A156:             0+1<=kk by NAT_1:13;
A157:             kk<i1 by A154,XREAL_1:9;
                  now per cases;
                    case kk<i2;
                      hence sm2.(kk+1)=(sm2.(kk))*2 by A117,A156;
                    end;
                    case kk>=i2;
                      then kk=i2 by A155,XXREAL_0:1;
                      hence sm2.(kk+1)=(sm2.(kk))*2 by A117;
                    end;
                  end;
                  hence sm1.(kk+1)=sm2.(kk+1) by A116,A149,A152,A156,A157,
                  XXREAL_0:2;
                end;
                case 0>=kk;
                  then kk=0;
                  hence sm1.(kk+1)=sm2.(kk+1) by A113,A114,A115;
                end;
              end;
              hence sm1.(kk+1)=sm2.(kk+1);
            end;
            suppose kk+1=i1+1;
              hence sm1.(kk+1)=sm2.(kk+1) by A116,A117,A148,A152,NAT_1:13;
            end;
          end;
          hence P2[kk+1];
        end;
A158:   for jj being Element of NAT holds P2[jj] from NAT_1:sch 1(A150,A151);
A159:   for jj being Integer st 1<=jj & jj<=i1+1 holds sm1.jj=sm2.jj
        proof
          let jj be Integer;
          assume
A160:     1<=jj & jj<=i1+1;
          then reconsider jj2=jj as Element of NAT by INT_1:16;
          sm1.(jj2)=sm2.(jj2) by A158,A160;
          hence sm1.jj=sm2.jj;
        end;
        defpred P3[Element of NAT] means 1<=$1 & $1<=i1+1 implies
        sn1.(ii1+1+1-'$1)=sn2.(ii1+1+1-'$1);
A161:   P3[0];
A162:   for kk being Element of NAT st P3[kk] holds P3[kk+1]
        proof
          let kk be Element of NAT;
          assume
A163:     P3[kk];
          1<=kk+1 & kk+1<=i1+1 implies
          sn1.(ii1+1+1-'(kk+1))=sn2.(ii1+1+1-'(kk+1))
          proof
            assume 1<=kk+1 & kk+1<=i1+1;
            then
A164:       kk+1-1<=i2+1-1 by A148,XREAL_1:11;
            per cases;
            suppose 0<kk;
              then
A165:         0+1<=kk by NAT_1:13;
              then
A166:         kk-1>=0 by XREAL_1:50;
A167:         kk<i1+1 by A148,A149,A164,XXREAL_0:2;
              kk-' 1<=kk by BINARITH:52;
              then kk-' 1<i1+1 by A167,XXREAL_0:2;
              then i1+1-(kk -' 1)>=0 by XREAL_1:50;
              then
A168:         ii1+1-' (kk-' 1)=i1+1-(kk-' 1) by BINARITH:def 3
                .=i1+1-(kk-1) by A166,BINARITH:def 3;
              i1+1-kk>0 by A167,XREAL_1:52;
              then
A169:         ii1+1-' kk=i1+1-kk by BINARITH:def 3;
              now per cases;
                case
A170:             kk<=i2;
                  then
A171:             (sn1.(ii1+1-'(kk-'1))>=sm1.(ii1+1-'kk) implies
                  sn1.(ii1+1-'kk)=sn1.(ii1+1-'(kk-'1))-sm1.(ii1+1-'kk) &
                  pn1.(ii1+1-'kk)=pn1.(ii1+1-'(kk-'1))*2+1 )&
                  (not sn1.(ii1+1-'(kk-'1))>=sm1.(ii1+1-'kk) implies
                  sn1.(ii1+1-'kk)=sn1.(ii1+1-'(kk-'1)) &
                  pn1.(ii1+1-'kk)=pn1.(ii1+1-'(kk-'1))*2
                  ) by A116,A148,A165,A168,A169;
A172:             (sn2.(ii1+1-'(kk-'1))>=sm2.(ii1+1-'kk) implies
                  sn2.(ii1+1-'kk)=sn2.(ii1+1-'(kk-'1))-sm2.(ii1+1-'kk) &
                  pn2.(ii1+1-'kk)=pn2.(ii1+1-'(kk-'1))*2+1 )&
                  (not sn2.(ii1+1-'(kk-'1))>=sm2.(ii1+1-'kk) implies
                  sn2.(ii1+1-'kk)=sn2.(ii1+1-'(kk-'1)) &
                  pn2.(ii1+1-'kk)=pn2.(ii1+1-'(kk-'1))*2
                  ) by A117,A148,A165,A168,A169,A170;
                  ii1<ii1+1 by NAT_1:13;
                  then kk<i1+1 by A148,A170,XXREAL_0:2;
                  then
A173:             i1+1-kk>0 by XREAL_1:52;
                  then ii1+1-'kk=i1+1-kk by BINARITH:def 3;
                  then
A174:             ii1+1-'kk>=0+1 by A173,NAT_1:13;
                  kk-1>=0 by A165,XREAL_1:50;
                  then kk-'1=kk-1 by BINARITH:def 3;
                  then kk=kk-'1+1;
                  then
A175:             ii1+1+1-'kk = ii1+1-'(kk-'1) by Th1;
A176:             1<=ii1+1-'kk & ii1+1-'kk<=i1+1 by A174,BINARITH:52;
                  ii1+1+1-'(kk+1)=ii1+1-'kk by Th1;

hence sn1.(ii1+1+1-'(kk+1))=sn2.(ii1+1+1-'(kk+1)) by A148,A159
                  ,A163,A165,A170,A171,A172,A175,A176,NAT_1:13;
                end;
                case kk>i2;
                  hence contradiction by A164;
                end;
              end;
              hence sn1.(ii1+1+1-'(kk+1))=sn2.(ii1+1+1-'(kk+1));
            end;
            suppose 0>=kk;
              then
A177:         kk=0;
              ii1+1+1-'(kk+1)=ii1+1-'kk by Th1
                .=ii1+1 by A177, BINARITH:58;
              hence sn1.(ii1+1+1-'(kk+1))=sn2.(ii1+1+1-'(kk+1)) by A116,A117
              ,A118,A133,XXREAL_0:1;
            end;
          end;
          hence P3[kk+1];
        end;
A178:   for jj being Element of NAT holds P3[jj] from NAT_1:sch 1(A161,A162);
        defpred P4[Element of NAT] means 1<=$1 & $1<=i1+1 implies
        pn1.(ii1+1+1-'$1)=pn2.(ii1+1+1-'$1);
A179:   P4[0];
A180:   for kk being Element of NAT st P4[kk] holds P4[kk+1]
        proof
          let kk be Element of NAT;
          assume
A181:     P4[kk];
          1<=kk+1 & kk+1<=i1+1 implies
          pn1.(ii1+1+1-'(kk+1))=pn2.(ii1+1+1-'(kk+1))
          proof
            assume
A182:       1<=kk+1 & kk+1<=i1+1;
            then
A183:       kk+1-1<=i2+1-1 by A148,XREAL_1:11;
            per cases;
            suppose 0<kk;
              then
A184:         0+1<=kk by NAT_1:13;
              then
A185:         kk-1>=0 by XREAL_1:50;
              then
A186:         kk-1=kk-'1 by BINARITH:def 3;
              kk-'1<kk-'1+1 by NAT_1:13;
              then kk-'1<i2 by A183,A186,XXREAL_0:2;
              then kk-'1<i2+1 by A148,A149,XXREAL_0:2;
              then i1+1-(kk -' 1)>=0 by A148,XREAL_1:50;
              then
A187:         ii1+1-' (kk-' 1)=i1+1-(kk-' 1) by BINARITH:def 3
                .=i1+1-(kk-1) by A185,BINARITH:def 3;
              kk<ii1+1 by A182,NAT_1:13;
              then i1+1-kk>0 by XREAL_1:52;
              then
A188:         ii1+1-' kk=i1+1-kk by BINARITH:def 3;
              now per cases;
                case
A189:             kk<=i2;
                  then
A190:             (sn1.(ii1+1-'(kk-'1))>=sm1.(ii1+1-'kk) implies
                  sn1.(ii1+1-'kk)=sn1.(ii1+1-'(kk-'1))-sm1.(ii1+1-'kk) &
                  pn1.(ii1+1-'kk)=pn1.(ii1+1-'(kk-'1))*2+1 )&
                  (not sn1.(ii1+1-'(kk-'1))>=sm1.(ii1+1-'kk) implies
                  sn1.(ii1+1-'kk)=sn1.(ii1+1-'(kk-'1)) &
                  pn1.(ii1+1-'kk)=pn1.(ii1+1-'(kk-'1))*2
                  ) by A116,A148,A184,A187,A188;
A191:             (sn2.(ii1+1-'(kk-'1))>=sm2.(ii1+1-'kk) implies
                  sn2.(ii1+1-'kk)=sn2.(ii1+1-'(kk-'1))-sm2.(ii1+1-'kk) &
                  pn2.(ii1+1-'kk)=pn2.(ii1+1-'(kk-'1))*2+1 )&
                  (not sn2.(ii1+1-'(kk-'1))>=sm2.(ii1+1-'kk) implies
                  sn2.(ii1+1-'kk)=sn2.(ii1+1-'(kk-'1)) &
                  pn2.(ii1+1-'kk)=pn2.(ii1+1-'(kk-'1))*2
                  ) by A117,A148,A184,A187,A188,A189;
                  ii1<ii1+1 by NAT_1:13;
                  then
A192:             kk<i1+1 by A148,A189,XXREAL_0:2;
                  then
A193:             i1+1-kk>0 by XREAL_1:52;
                  then ii1+1-'kk=i1+1-kk by BINARITH:def 3;
                  then
A194:             ii1+1-'kk>=0+1 by A193,NAT_1:13;
                  kk-1>=0 by A184,XREAL_1:50;
                  then kk-'1=kk-1 by BINARITH:def 3;
                  then kk=kk-'1+1;
                  then
A195:             ii1+1+1-'kk = ii1+1-'(kk-'1) by Th1;
A196:             sm1.(ii1+1-'kk)=sm2.(ii1+1-'kk) by A159,A194,BINARITH:52;
                  ii1+1+1-'(kk+1)=ii1+1-'kk by Th1;

hence pn1.(ii1+1+1-'(kk+1))=pn2.(ii1+1+1-'(kk+1)) by A178,A181
                  ,A184,A190,A191,A192,A195,A196;
                end;
                case kk>i2;
                  hence contradiction by A183;
                end;
              end;
              hence pn1.(ii1+1+1-'(kk+1))=pn2.(ii1+1+1-'(kk+1));
            end;
            suppose 0>=kk;
              then
A197:         kk=0;
              ii1+1+1-'(kk+1)=ii1+1-'kk by Th1
                .=i1+1 by A197,BINARITH: 58;
              hence pn1.(ii1+1+1-'(kk+1))=pn2.(ii1+1+1-'(kk+1)) by A116,A117
              ,A118,A133,XXREAL_0:1;
            end;
          end;
          hence P4[kk+1];
        end;
A198:   for jj being Element of NAT holds P4[jj] from NAT_1:sch 1(A179,A180);
A199:   for jj being Integer st 1<=jj & jj<=i1+1 holds
        pn1.(i1+1+1- jj)=pn2.(i1+1+1- jj)
        proof
          let jj be Integer;
          assume
A200:     1<=jj & jj<=i1+1;
          then reconsider j2=jj as Element of NAT by INT_1:16;
          ii1+1<ii1+1+1 by NAT_1:13;
          then jj<ii1+1+1 by A200,XXREAL_0:2;
          then ii1+1+1-j2>=0 by XREAL_1:50;
          then ii1+1+1-' j2=ii1+1+1-jj by BINARITH:def 3;
          hence pn1.(i1+1+1- jj)=pn2.(i1+1+1- jj) by A198,A200;
        end;
A201:   1<=1+ii1 by NAT_1:11;
        i1+1+1- (i1+1)=1;
        hence t1=t2 by A116,A117,A199,A201;
      end;
    end;
    hence thesis;
  end;
end;

:: The following theorem is about array index area checking.
:: Each index of an array appeared in the program is checked
:: at the place just in front of the place the array is used,
:: if it remains in the defined area of array.

theorem
  for n,m being Integer st n>=0 & m>0 holds
  for sm,sn,pn being FinSequence of INT,i being Integer st
  len sm=n+1 & len sn=n+1 & len pn=n+1 & (not (n<m) implies sm.1=m &
  ( 1<=i & i<=n & ((for k being Integer st 1<=k & k<i holds
  sm.(k+1)=sm.(k)*2 & not(sm.(k+1)>n)) & sm.(i+1)=sm.(i)*2 & sm.(i+1)>n ) &
  pn.(i+1)=0 & sn.(i+1)=n & (for j being Integer st 1<=j & j<=i holds
  (sn.(i+1- (j- 1))>=sm.(i+1- j) implies
  sn.(i+1- j)=sn.(i+1- (j- 1))-sm.(i+1- j) & pn.(i+1- j)=pn.(i+1- (j- 1))*2+1
  )& (not sn.(i+1- (j- 1))>=sm.(i+1- j) implies sn.(i+1- j)=sn.(i+1- (j- 1)) &
  pn.(i+1- j)=pn.(i+1- (j- 1))*2 ) )& idiv1_prg(n,m)=pn.1 ) ) holds
  len sm=n+1 & len sn=n+1 & len pn=n+1 & (n<m implies idiv1_prg(n,m)=0)&
  (not (n<m) implies 1 in dom sm & sm.1=m & ( 1<=i & i<=n &
  ((for k being Integer st 1<=k & k<i holds
  k+1 in dom sm & k in dom sm & sm.(k+1)=sm.(k)*2 & not(sm.(k+1)>n))
  & i+1 in dom sm & i in dom sm & sm.(i+1)=sm.(i)*2 & sm.(i+1)>n ) &
  i+1 in dom pn & pn.(i+1)=0 & i+1 in dom sn & sn.(i+1)=n &
  (for j being Integer st 1<=j & j<=i holds
  i+1-(j-1) in dom sn & i+1-j in dom sm &
  (sn.(i+1- (j- 1))>=sm.(i+1- j) implies i+1-j in dom sn & i+1-j in dom sm &
  sn.(i+1- j)=sn.(i+1- (j- 1))-sm.(i+1- j)
  & i+1-j in dom pn & i+1-(j-1) in dom pn & pn.(i+1- j)=pn.(i+1- (j- 1))*2+1
  )& (not sn.(i+1- (j- 1))>=sm.(i+1- j) implies
  i+1-j in dom sn & i+1-(j-1) in dom sn & sn.(i+1- j)=sn.(i+1- (j- 1))
  & i+1-j in dom pn & i+1-(j-1) in dom pn & pn.(i+1- j)=pn.(i+1- (j- 1))*2 )
  ) & 1 in dom pn & idiv1_prg(n,m) =pn.1 ) )
proof
  let n,m be Integer;
  assume
A1: n>=0 & m>0;
  let sm,sn,pn be FinSequence of INT,i be Integer;
  assume
A2: len sm=n+1 & len sn=n+1 & len pn=n+1 & (not (n<m) implies sm.1=m &
  ( 1<=i & i<=n & ((for k being Integer st 1<=k & k<i holds
  sm.(k+1)=sm.(k)*2 & not(sm.(k+1)>n)) & sm.(i+1)=sm.(i)*2 & sm.(i+1)>n ) &
  pn.(i+1)=0 & sn.(i+1)=n & (for j being Integer st 1<=j & j<=i holds
  (sn.(i+1- (j- 1))>=sm.(i+1- j) implies
  sn.(i+1- j)=sn.(i+1- (j- 1))-sm.(i+1- j) & pn.(i+1- j)=pn.(i+1- (j- 1))*2+1
  )& (not sn.(i+1- (j- 1))>=sm.(i+1- j) implies sn.(i+1- j)=sn.(i+1- (j- 1)) &
  pn.(i+1- j)=pn.(i+1- (j- 1))*2 ) )& idiv1_prg(n,m)=pn.1 ) );
  reconsider n2=n as Element of NAT by A1,INT_1:16;
  (not (n<m) implies 1 in dom sm & sm.1=m & ( 1<=i & i<=n &
  ((for k being Integer st 1<=k & k<i holds
  k+1 in dom sm & k in dom sm & sm.(k+1)=sm.(k)*2 & not(sm.(k+1)>n))
  & i+1 in dom sm & i in dom sm & sm.(i+1)=sm.(i)*2 & sm.(i+1)>n ) &
  i+1 in dom pn & pn.(i+1)=0 & i+1 in dom sn & sn.(i+1)=n &
  (for j being Integer st 1<=j & j<=i holds
  i+1-(j-1) in dom sn & i+1-j in dom sm &
  (sn.(i+1- (j- 1))>=sm.(i+1- j) implies i+1-j in dom sn & i+1-j in dom sm &
  sn.(i+1- j)=sn.(i+1- (j- 1))-sm.(i+1- j)
  & i+1-j in dom pn & i+1-(j-1) in dom pn & pn.(i+1- j)=pn.(i+1- (j- 1))*2+1
  )& (not sn.(i+1- (j- 1))>=sm.(i+1- j) implies
  i+1-j in dom sn & i+1-(j-1) in dom sn & sn.(i+1- j)=sn.(i+1- (j- 1))
  & i+1-j in dom pn & i+1-(j-1) in dom pn & pn.(i+1- j)=pn.(i+1- (j- 1))*2 )
  ) & 1 in dom pn & idiv1_prg(n,m) =pn.1 ) )
  proof
    assume
A3: not (n<m);
    1<=n2+1 by NAT_1:12;
    then
A4: 1 in Seg len sm by A2,FINSEQ_1:3;
A5: (for j being Integer st 1<=j & j<=i holds
    i+1-(j-1) in dom sn & i+1-j in dom sm &
    (sn.(i+1- (j- 1))>=sm.(i+1- j) implies i+1-j in dom sn & i+1-j in dom sm &
    sn.(i+1- j)=sn.(i+1- (j- 1))-sm.(i+1- j)
    & i+1-j in dom pn & i+1-(j-1) in dom pn & pn.(i+1- j)=pn.(i+1- (j- 1))*2+1
    )& (not sn.(i+1- (j- 1))>=sm.(i+1- j) implies
    i+1-j in dom sn & i+1-(j-1) in dom sn & sn.(i+1- j)=sn.(i+1- (j- 1))
    & i+1-j in dom pn & i+1-(j-1) in dom pn & pn.(i+1- j)=pn.(i+1- (j- 1))*2 )
    )
    proof
      let j be Integer;
      assume
A6:   1<=j & j<=i;
      then
A7:   0<=i-j by XREAL_1:50;
A8:   i-j<i-j+1 by XREAL_1:31;
      then
A9:   0+1<=i-j+1+1 by A7,XREAL_1:9;
A10:  i+1<=n2+1 by A2,A3,XREAL_1:9;
      j-1>=0 by A6,XREAL_1:50;
      then i+1+0<=i+1+(j-1) by XREAL_1:9;
      then i+1-(j-1)<=i+1+(j-1)-(j-1) by XREAL_1:11;
      then
A11:  i+1-(j-1)<=n2+1 by A10,XXREAL_0:2;
      0<i-j+1 by A6,A8,XREAL_1:50;
      then reconsider ij=i-j+1 as Element of NAT by INT_1:16;
A12:  0+1<=ij by A7,A8,NAT_1:13;
A13:  i+1<=n2+1 by A2,A3,XREAL_1:9;
      i+1+0<=i+1+j by A6,XREAL_1:9;
      then i+1-j<=i+1+j-j by XREAL_1:11;
      then i+1-j<=n2+1 by A13,XXREAL_0:2;
      hence thesis by A2,A3,A6,A9,A11,A12,Th7;
    end;
    reconsider i2=i as Element of NAT by A2,A3,INT_1:16;
A14: i2+1<=n2+1 by A2,A3,XREAL_1:9;
    1<=i2+1 by NAT_1:12;
    then
A15: i2+1 in Seg (n2+1) by A14,FINSEQ_1:3;
A16: i2<=n2+1 by A2,A3,NAT_1:13;
    then
A17: i2 in Seg (n2+1) by A2,A3,FINSEQ_1:3;
    for k being Integer st 1<=k & k<i holds
    k+1 in dom sm & k in dom sm & sm.(k+1)=sm.(k)*2 & not(sm.(k+1)>n)
    proof
      let k be Integer;
      assume
A18:  1<=k & k<i;
      then reconsider k2=k as Element of NAT by INT_1:16;
A19:  k2<n2+1 by A16,A18,XXREAL_0:2;
      then
A20:  k in Seg (n2+1) by A18,FINSEQ_1:3;
A21:  k2+1<=n2+1 by A19,NAT_1:13;
      1<=k2+1 by NAT_1:12;
      then k2+1 in Seg (n2+1) by A21,FINSEQ_1:3;
      hence k+1 in dom sm & k in dom sm &
      sm.(k+1)=sm.(k)*2 & not(sm.(k+1)>n) by A2,A3,A18,A20,FINSEQ_1:def 3;
    end;
    hence thesis by A2,A3,A4,A5,A15,A17,FINSEQ_1:def 3;
  end;
  hence thesis by A1,A2,Def1;
end;

theorem Th9:
  for n,m being Element of NAT st m>0 holds
  idiv1_prg(n qua Integer,m qua Integer)=n div m
proof
  let n2,m2 be Element of NAT;
  assume
A1: m2>0;
  reconsider n=n2,m=m2 as Integer;
  now per cases;
    suppose
A2:   n<m;
      set ssm = Seg (n2+1) --> 1;
A3:   dom ssm = Seg (n2+1) by FUNCOP_1:19;
      then reconsider ssm as FinSequence by FINSEQ_1:def 2;
A4:   rng ssm c= {1} by FUNCOP_1:19;
      rng ssm c= INT
      proof
        let y be set;
        assume y in rng ssm;
        then y=1 by A4,TARSKI:def 1;
        hence y in INT by INT_1:def 2;
      end;
      then reconsider ssm as FinSequence of INT by FINSEQ_1:def 4;
      set ssn=ssm,ppn=ssm;
      len ssm=n+1 & len ssn=n+1 & len ppn=n+1 & (n<m implies n2 div m2=0)&
      (not (n<m) implies ssm.1=m & ( ex i being Integer st 1<=i & i<=n &
      ((for k being Integer st 1<=k & k<i holds
      ssm.(k+1)=ssm.(k)*2 & not(ssm.(k+1)>n))
      & ssm.(i+1)=ssm.(i)*2 & ssm.(i+1)>n ) & ppn.(i+1)=0 & ssn.(i+1)=n &
      (for j being Integer st 1<=j & j<=i holds
      (ssn.(i+1- (j- 1))>=ssm.(i+1- j) implies
      ssn.(i+1- j)=ssn.(i+1- (j- 1))-ssm.(i+1- j) &
      ppn.(i+1- j)=ppn.(i+1- (j- 1))*2+1 )&
      (not ssn.(i+1- (j- 1))>=ssm.(i+1- j) implies
      ssn.(i+1- j)=ssn.(i+1- (j- 1)) & ppn.(i+1- j)=ppn.(i+1- (j- 1))*2 ) )&
      n2 div m2=ppn.1 ) ) by A2,A3,FINSEQ_1:def 3,PRE_FF:4;
      hence ex sm,sn,pn being FinSequence of INT st
      len sm=n+1 & len sn=n+1 & len pn=n+1 & (n<m implies n2 div m2=0)&
      (not (n<m) implies sm.1=m & ( ex i being Integer st 1<=i & i<=n &
      ((for k being Integer st 1<=k & k<i holds
      sm.(k+1)=sm.(k)*2 & not(sm.(k+1)>n)) & sm.(i+1)=sm.(i)*2 & sm.(i+1)>n )
      & pn.(i+1)=0 & sn.(i+1)=n & (for j being Integer st 1<=j & j<=i holds
      (sn.(i+1- (j- 1))>=sm.(i+1- j) implies
      sn.(i+1- j)=sn.(i+1- (j- 1))-sm.(i+1- j) &
      pn.(i+1- j)=pn.(i+1- (j- 1))*2+1 )&
      (not sn.(i+1- (j- 1))>=sm.(i+1- j) implies sn.(i+1- j)=sn.(i+1- (j- 1))
      & pn.(i+1- j)=pn.(i+1- (j- 1))*2 ) )& n2 div m2=pn.1 ) );
    end;
    suppose
A5:   n>=m;
      then n2>=0+1 by A1,NAT_1:13;
      then 1< n2+1 by NAT_1:13;
      then
A6:   1 in Seg (n2+1) by FINSEQ_1:3;
      deffunc F1(Nat) = m2*(2|^($1-'1));
      ex ssm being FinSequence st len ssm=n2+1 &
      for k2 being Nat st k2 in dom ssm holds
      ssm.k2=F1(k2) from FINSEQ_1:sch 2;
      then consider ssm being FinSequence such that
A7:   len ssm=n2+1 & for k2 being Nat st k2 in dom ssm holds
      ssm.k2=m*(2|^(k2-'1));
A8: dom ssm = Seg(n2+1) by A7,FINSEQ_1:def 3;
      rng ssm c= INT
      proof
        let y be set;
        assume y in rng ssm;
        then consider x being set such that
A9:     x in dom ssm & y=ssm.x by FUNCT_1:def 5;
        reconsider n=x as Element of NAT by A9;
        ssm.n=m*(2|^(n-'1)) by A7,A9;
        hence y in INT by A9,INT_1:def 2;
      end;
      then reconsider ssm as FinSequence of INT by FINSEQ_1:def 4;
      deffunc F(Nat) = n2 mod (m2*(2|^($1-'1)));
      ex ssn being FinSequence st len ssn=n2+1 &
      for k2 being Nat st k2 in dom ssn holds
      ssn.k2=F(k2) from FINSEQ_1:sch 2;
      then consider ssn being FinSequence such that
A11:  len ssn=n2+1 & for k2 being Nat st k2 in dom ssn holds
      ssn.k2=n2 mod (m2*(2|^(k2-'1)));
A12: dom ssn = Seg(n2+1)  by A11,FINSEQ_1:def 3;
      rng ssn c= INT
      proof
        let y be set;
        assume y in rng ssn;
        then consider x being set such that
A13:    x in dom ssn & y=ssn.x by FUNCT_1:def 5;
        reconsider n3=x as Element of NAT by A13;
        ssn.n3=n2 mod (m2*(2|^(n3-'1))) by A11,A13;
        hence y in INT by A13,INT_1:def 2;
      end;
      then reconsider ssn as FinSequence of INT by FINSEQ_1:def 4;
      deffunc F3(Nat)= n2 div (m2*(2|^($1-'1)));
      ex ppn being FinSequence st len ppn=n2+1 &
      for k2 being Nat st k2 in dom ppn holds
      ppn.k2= F3(k2) from FINSEQ_1:sch 2;
      then consider ppn being FinSequence such that
A15:  len ppn=n2+1 & for k2 being Nat st k2 in dom ppn holds
      ppn.k2= n2 div (m2*(2|^(k2-'1)));
A16: dom ppn = Seg(n2+1) by A15,FINSEQ_1:def 3;
      rng ppn c= INT
      proof
        let y be set;
        assume y in rng ppn;
        then consider x being set such that
A17:    x in dom ppn & y=ppn.x by FUNCT_1:def 5;
        reconsider n3=x as Element of NAT by A17;
        ppn.n3=n2 div (m2*(2|^(n3-'1))) by A15,A17;
        hence y in INT by A17,INT_1:def 2;
      end;
      then reconsider ppn as FinSequence of INT by FINSEQ_1:def 4;
A19:  ppn.1=n2 div (m2*(2|^(1-'1))) by A6,A15,A16
        .=n2 div (m2*(2|^(0))) by BINARITH:51
        .=n2 div m2*1 by NEWTON:9
        .=n2 div m2;
A20:  ssm.1=m*(2|^(1-'1)) by A6,A7,A8
        .=m*(2|^(0)) by BINARITH:51
        .=m*1 by NEWTON:9
        .=m;
      consider ii0 being Element of NAT such that
A21:  (for k2 being Element of NAT st k2<ii0 holds m*(2|^(k2))<=n2)
      & m2*(2|^(ii0))>n2 by A1,Th6;
      reconsider i0=ii0 as Integer;
      now
        assume i0=0;
        then m2*1>n2 by A21,NEWTON:9;
        hence contradiction by A5;
      end;
      then ii0>0;
      then
A22:  ii0>=0+1 by NAT_1:13;
      then
A23:  i0-1>=0 by XREAL_1:50;
A24:  now
        assume i0>n2;
        then
A25:    m*(2|^n2) <= n2 by A21;
        1+0<=m2 by A1,NAT_1:13;
        then 1*(2|^n2)<=m2*(2|^n2) by XREAL_1:66;
        then
A26:    (2|^n2)<=n2 by A25,XXREAL_0:2;
        n2+1<= 2|^n2 by NEWTON:104;
        hence contradiction by A26,NAT_1:13;
      end;
      then
A27:  i0+1<=n2+1 by XREAL_1:9;
      i0<n2+1 by A24,NAT_1:13;
      then
A28:  ii0 in Seg(n2+1) by A22,FINSEQ_1:3;
      1<=i0+1 by A22,NAT_1:13;
      then
A29:  ii0+1 in Seg(n2+1) by A27,FINSEQ_1:3;
      ii0+1-' 1=i0-1+1 by BINARITH:39
        .=ii0-' 1+1 by A23,BINARITH:def 3;
      then
A30:  2|^(ii0+1-'1)=(2|^(ii0-'1))*2 by NEWTON:11;
A31:  ssm.(i0+1)=m*(2|^(ii0+1-'1)) by A7,A29,A8
        .=m*(2|^(ii0-'1))*2 by A30
        .=(ssm.i0)*2 by A7,A28,A8;
A32:  for k being Element of NAT st 1<=k & k<i0 holds
      ssm.(k+1)=ssm.(k)*2 & not(ssm.(k+1)>n)
      proof
        let k be Element of NAT;
        assume
A33:    1<=k & k<i0;
        then
A34:    k<=n2 by A24,XXREAL_0:2;
A35:    k-1>=0 by A33,XREAL_1:50;
A36:    1<k+1 by A33,NAT_1:13;
A37:    k+1-'1=k by BINARITH:39;
        k+1<=n2+1 by A34,XREAL_1:9;
        then k+1 in Seg (n2+1) by A36,FINSEQ_1:3;
        then
A38:    ssm.(k+1)=m*(2|^(k+1-'1)) by A7,A8;
        k<=n2+1 by A34,NAT_1:12;
        then k in Seg (n2+1) by A33,FINSEQ_1:3;
        then
A39:    ssm.(k)=m*(2|^(k-'1)) by A7,A8;
        k+1-'1=k-1+1 by BINARITH:39
          .=k-' 1+1 by A35,BINARITH:def 3;
        then 2|^(k+1-'1)=(2|^(k-'1))*2 by NEWTON:11;
        hence ssm.(k+1)=ssm.(k)*2 & not(ssm.(k+1)>n) by A21,A33,A37,A38,A39;
      end;
A40:  for k being Integer st 1<=k & k<i0 holds
      ssm.(k+1)=ssm.(k)*2 & not(ssm.(k+1)>n)
      proof
        let k be Integer;
        assume
A41:    1<=k & k<i0;
        then reconsider kk=k as Element of NAT by INT_1:16;
        ssm.(kk+1)=ssm.(kk)*2 & not(ssm.(kk+1)>n) by A32,A41;
        hence ssm.(k+1)=ssm.(k)*2 & not(ssm.(k+1)>n);
      end;
A42:  1<=1+ii0 by NAT_1:11;
A43:  ii0+1-'1=ii0 by BINARITH:39;
      i0+1<=n2+1 by A24,XREAL_1:9;
      then
A44:  ii0+1 in (Seg (n2+1)) by A42,FINSEQ_1:3;
      then
A45:  ssm.(i0+1)>n by A7,A21,A43,A8;
      i0 <n2+1 by A24,NAT_1:13;
      then
A46:  ii0+1<=n2+1 by NAT_1:13;
      0+1<=i0+1 by XREAL_1:9;
      then ii0+1 in Seg (n2+1) by A46,FINSEQ_1:3;
      then
A47:  ssn.(i0+1)=n2 mod (m2*(2|^(ii0+1-'1))) by A11,A12;
      reconsider k5=m2*(2|^(ii0+1-'1)) as Element of NAT;
A48:  k5>n2 by A21,BINARITH:39;
      n2 div (m2*(2|^(ii0+1-'1)))=0 by A21,A43,NAT_D:27;
      then
A49:  ppn.(i0+1)=0 & ssn.(i0+1)=n by A15,A44,A47,A48,NAT_D:24,A16;
      for j being Integer st 1<=j & j<=i0 holds
      (ssn.(i0+1- (j- 1))>=ssm.(i0+1- j) implies
      ssn.(i0+1- j)=ssn.(i0+1- (j- 1))-ssm.(i0+1- j) &
      ppn.(i0+1- j)=ppn.(i0+1- (j- 1))*2+1 )&
      (not ssn.(i0+1- (j- 1))>=ssm.(i0+1- j) implies
      ssn.(i0+1- j)=ssn.(i0+1- (j- 1)) & ppn.(i0+1- j)=ppn.(i0+1- (j- 1))*2 )
      proof
        let j be Integer;
        assume
A50:    1<=j & j<=i0;
        then reconsider jj=j as Element of NAT by INT_1:16;
A51:    i0-j>=0 by A50,XREAL_1:50;
        then
A52:    ii0-' jj=i0-j by BINARITH:def 3;
A53:    j-1>=0 by A50,XREAL_1:50;
        hereby
          assume
A54:      ssn.(i0+1- (j- 1))>=ssm.(i0+1- j);
A55:      jj-' 1=j-1 by A53,BINARITH:def 3;
A56:      j+1<=i0+1 by A50,XREAL_1:9;
          j<j+1 by XREAL_1:31;
          then
A57:      j<i0+1 by A56,XXREAL_0:2;
          ii0<ii0+1 by NAT_1:13;
          then j<i0+1 by A50,XXREAL_0:2;
          then
A58:      i0+1-j>0 by XREAL_1:52;
          then
A59:      ii0+1-' jj=i0+1-j by BINARITH:def 3;
A60:      ii0+1-' jj=i0-j+1 by A58,BINARITH:def 3;
A61:      ii0+1-' jj=i0+1-j by A58,BINARITH:def 3;
          jj-' 1<=j by BINARITH:52;
          then jj-' 1<i0+1 by A57,XXREAL_0:2;
          then
A62:      ii0+1-(jj -' 1)>=0 by XREAL_1:50;
          then
A63:      ii0+1-' (jj-' 1)=i0+1-j+1 by A55,BINARITH:def 3;
          then
A64:      ii0+1-' (jj-' 1)-' 1=ii0+1-' jj by A59,BINARITH:39;
A65:      ii0+1-' (jj-' 1)=i0+1-(j-1) by A55,A62,BINARITH:def 3;
          ii0<ii0+1 by NAT_1:13;
          then j<i0+1 by A50,XXREAL_0:2;
          then i0+1-j>=0 by XREAL_1:50;
          then
A66:      ii0+1-' jj=i0+1-j by BINARITH:def 3;
          i0+1<=n2+j by A24,A50,XREAL_1:9;
          then i0+1-j<=n2+j-j by XREAL_1:11;
          then
A67:      ii0+1-' jj+1<=n2+1 by A66,XREAL_1:9;
          1<=ii0+1-' (jj-' 1) by A59,A63,NAT_1:11;
          then
A68:      ii0+1-' (jj-' 1) in Seg (n2+1) by A59,A63,A67,FINSEQ_1 :3;
A69:      ii0+1-' jj>=0+1 by A58,A59,NAT_1:13;
          then ii0+1-' jj -1>=0 by XREAL_1:50;
          then
A70:      ii0+1-' jj -' 1=i0-j by A59,BINARITH:def 3;
A71:      ii0+1-' jj<=i0+1 by BINARITH:52;
          i0+1<=n2+1 by A24,XREAL_1:9;
          then n2+1>=(ii0+1-' jj) by A71,XXREAL_0:2;
          then
A72:      ii0+1-' (jj) in Seg (n2+1) by A69,FINSEQ_1:3;
          then
A73:      ssn.(ii0+1-' jj)=n2 mod (m2*(2|^(ii0+1-' jj-' 1))) by A11,A12;
A74:      jj-' 1=j-1 by A53,BINARITH:def 3;
A75:      j+1<=i0+1 by A50,XREAL_1:9;
          jj<jj+1 by NAT_1:13;
          then
A76:      j<i0+1 by A75,XXREAL_0:2;
          jj-' 1<=jj by BINARITH:52;
          then jj-' 1<i0+1 by A76,XXREAL_0:2;
          then ii0+1-(jj -' 1)>=0 by XREAL_1:50;
          then ii0+1-' (jj-' 1)=i0+1-j+1 by A74,BINARITH:def 3
            .=ii0+1-' jj+1 by A58,BINARITH:def 3;
          then
A77:      ssn.(ii0+1-' (jj-' 1))
          =n2 mod (m2*(2|^(ii0+1-' jj+1-' 1))) by A11,A68,A12
            .=n2 mod (m2*(2|^(ii0+1-' jj))) by BINARITH:39;
          ii0+1-' jj-1>=0 by A50,A60,XREAL_1:50;
          then
A78:      ii0+1-' jj-' 1 =i0-j by A59,BINARITH:def 3
            .=ii0-' jj
          by A51,BINARITH:def 3;
A79:      m2*(2|^(ii0+1-' jj))=m2*(2|^(ii0-' jj+1)) by A52,A58, BINARITH:def 3
            .=m2*((2|^(ii0-' jj))*2) by NEWTON:11
            .=2*(m2*(2|^(ii0-' jj)));
A80:      ssm.(ii0+1-' jj)=m2*(2|^(ii0-' jj)) by A7,A72,A78,A8;
          2|^(ii0-' jj)<>0 by CARD_4:51;
          then 2|^(ii0-' jj)>0;
          then
A81:      m2*(2|^(ii0-' jj))> m2*0 by A1,XREAL_1:70;
          then
A82:      ssn.(ii0+1-' (jj-' 1))-ssm.(ii0+1-' jj)
          = n2 mod (m2*(2|^(ii0-' jj))) by A54,A61,A63,A77,A79,A80,Th2;
          ppn.(ii0+1-' jj)=n2 div (m2*(2|^(ii0+1-' jj-' 1))) by A15,A72,A16
            .= (n2 div (m2*(2|^(ii0+1-' (jj-' 1)-' 1))))*2+1
          by A54,A59,A64,A65,A77,A78,A79,A80,A81,Th3
            .= ppn.(ii0+1-' (jj-' 1))*2+1 by A15,A68,A16;
          hence ssn.(i0+1- j)=ssn.(i0+1- (j- 1))-ssm.(i0+1- j) &
          ppn.(i0+1- j)=ppn.(i0+1- (j- 1))*2+1 by A59,A63,A70,A73,A82,
          BINARITH:def 3;
        end;
        thus thesis
        proof
          assume
A83:      not ssn.(i0+1- (j- 1))>=ssm.(i0+1- j);
A84:      jj-' 1=j-1 by A53,BINARITH:def 3;
A85:      j+1<=i0+1 by A50,XREAL_1:9;
          jj<jj+1 by NAT_1:13;
          then
A86:      j<i0+1 by A85,XXREAL_0:2;
          ii0<ii0+1 by NAT_1:13;
          then j<i0+1 by A50,XXREAL_0:2;
          then
A87:      i0+1-j>0 by XREAL_1:52;
          then
A88:      ii0+1-' jj=i0+1-j by BINARITH:def 3;
A89:      ii0+1-' jj=i0-j+1 by A87,BINARITH:def 3;
          jj-' 1<=jj by BINARITH:52;
          then jj-' 1<i0+1 by A86,XXREAL_0:2;
          then
A90:      i0+1-(jj -' 1)>=0 by XREAL_1:50;
          then
A91:      ii0+1-' (jj-' 1)=i0+1-j+1 by A84,BINARITH:def 3;
          then
A92:      ii0+1-' (jj-' 1)-' 1 =ii0+1-' jj by A88,BINARITH:39;
          ii0<ii0+1 by NAT_1:13;
          then j<i0+1 by A50,XXREAL_0:2;
          then i0+1-j>=0 by XREAL_1:50;
          then
A93:      ii0+1-' jj=i0+1-j by BINARITH:def 3;
          i0+1<=n2+j by A24,A50,XREAL_1:9;
          then i0+1-j<=n2+j-j by XREAL_1:11;
          then
A94:      ii0+1-' jj+1<=n2+1 by A93,XREAL_1:9;
          1<=ii0+1-' (jj-' 1) by A88,A91,NAT_1:11;
          then
A95:      ii0+1-' (jj-' 1) in Seg (n2+1) by A88,A91,A94,FINSEQ_1 :3;
A96:      ii0+1-' jj>=0+1 by A87,A88,NAT_1:13;
          then ii0+1-' jj -1>=0 by XREAL_1:50;
          then
A97:      ii0+1-' jj -' 1=i0-j by A88,BINARITH:def 3;
A98:      ii0+1-' jj<=ii0+1 by BINARITH:52;
          i0+1<=n2+1 by A24,XREAL_1:9;
          then n2+1>=(ii0+1-' jj) by A98,XXREAL_0:2;
          then
A99:      ii0+1-' (jj) in Seg (n2+1) by A96,FINSEQ_1:3;
          then ssn.(ii0+1-' jj)=n2 mod (m2*(2|^(ii0+1-' jj-' 1))) by A11,A12;
          then
A100:      ssn.(ii0+1-' jj) =n2 mod (m2*(2|^(ii0-' jj))) by A97,
          BINARITH:def 3;
A101:      jj-' 1=j-1 by A53,BINARITH:def 3;
A102:      j+1<=i0+1 by A50,XREAL_1:9;
          jj<jj+1 by NAT_1:13;
          then
A103:     j<i0+1 by A102,XXREAL_0:2;
          jj-' 1<=j by BINARITH:52;
          then jj-' 1<i0+1 by A103,XXREAL_0:2;
          then i0+1-(jj -' 1)>=0 by XREAL_1:50;
          then
A104:     ii0+1-' (jj-' 1)=ii0+1-' jj+1 by A88,A101,BINARITH:def 3;
A105:     ii0+1-' (jj-' 1)=i0+1-(j-1) by A84,A90,BINARITH:def 3;
A106:     ssn.(ii0+1-' (jj-' 1))
          =n2 mod (m2*(2|^(ii0+1-' jj+1-' 1))) by A11,A95,A104,A12
            .=n2 mod (m2*(2|^(ii0+1-' jj))) by BINARITH:39;
A107:     ii0+1-' jj-' 1 =i0-j+1-1 by A51,A89,BINARITH:def 3
            .=ii0-' jj
          by A51,BINARITH:def 3;
A108:     m2*(2|^(ii0+1-' jj))=m2*(2|^(ii0-' jj+1)) by A52,A87, BINARITH:def 3
            .=m2*((2|^(ii0-' jj))*2) by NEWTON:11
            .=2*(m2*(2|^(ii0-' jj)));
A109:     ssm.(ii0+1-' jj)=m2*(2|^(ii0-' jj)) by A7,A99,A107,A8;
          ppn.(ii0+1-' jj)=n2 div (m2*(2|^(ii0+1-' jj-' 1))) by A15,A99,A16
            .= (n2 div (m2*(2|^(ii0+1-' (jj-' 1)-' 1))))*2
          by A83,A88,A92,A105,A106,A107,A108,A109,Th5
            .= ppn.(ii0+1-' (jj-' 1))*2 by A15,A95,A16;
          hence ssn.(i0+1- j)=ssn.(i0+1- (j- 1))
          & ppn.(i0+1- j)=ppn.(i0+1- (j- 1))*2 by A83,A88,A91,A100,A106,A108
          ,A109,Th4;
        end;
      end;
      hence ex sm,sn,pn being FinSequence of INT st
      len sm=n+1 & len sn=n+1 & len pn=n+1 & (n<m implies n2 div m2=0)&
      (not (n<m) implies sm.1=m & ( ex i being Integer st 1<=i & i<=n &
      ((for k being Integer st 1<=k & k<i holds
      sm.(k+1)=sm.(k)*2 & not(sm.(k+1)>n)) & sm.(i+1)=sm.(i)*2 & sm.(i+1)>n )
      & pn.(i+1)=0 & sn.(i+1)=n & (for j being Integer st 1<=j & j<=i holds
      (sn.(i+1- (j- 1))>=sm.(i+1- j) implies
      sn.(i+1- j)=sn.(i+1- (j- 1))-sm.(i+1- j) &
      pn.(i+1- j)=pn.(i+1- (j- 1))*2+1 )&
      (not sn.(i+1- (j- 1))>=sm.(i+1- j) implies sn.(i+1- j)=sn.(i+1- (j- 1))
      & pn.(i+1- j)=pn.(i+1- (j- 1))*2 ) )& n2 div m2=pn.1 )
      ) by A5,A7,A11,A15,A19,A20,A22,A24,A31,A40,A45,A49;
    end;
  end;
  hence idiv1_prg(n2 qua Integer,m2 qua Integer)=n2 div m2 by A1,Def1;
end;

theorem Th10:
  for n,m being Integer st n>=0 & m>0 holds idiv1_prg(n,m)=n div m
proof
  let n,m be Integer;
  assume
A1: n>=0 & m>0;
  then reconsider n2=n,m2=m as Element of NAT by INT_1:16;
  idiv1_prg(n,m)=n2 div m2 by A1,Th9;
  hence idiv1_prg(n,m)=n div m;
end;

theorem Th11:
  for n,m being Integer,n2,m2 being Element of NAT holds
  (m=0 & n2=n & m2=m implies n div m=0 & n2 div m2=0)&
  (n>=0 & m>0 & n2=n & m2=m implies n div m =n2 div m2)&
  (n>=0 & m<0 & n2=n & m2= -m implies
  (m2*(n2 div m2)=n2 implies n div m =-(n2 div m2))
  &(m2*(n2 div m2)<>n2 implies n div m =-(n2 div m2)-1))&
  (n<0 & m>0 & n2= -n & m2=m implies
  (m2*(n2 div m2)=n2 implies n div m =-(n2 div m2))
  &(m2*(n2 div m2)<>n2 implies n div m =-(n2 div m2)-1))&
  (n<0 & m<0 & n2= -n & m2= -m implies n div m =n2 div m2)
proof
  let n,m be Integer,n2,m2 be Element of NAT;
  thus (m=0 & n2=n & m2=m implies n div m=0 & n2 div m2=0) by INT_1:75;
  thus (n>=0 & m>0 & n2=n & m2=m implies n div m =n2 div m2);
  thus (n>=0 & m<0 & n2=n & m2= -m implies
  (m2*(n2 div m2)=n2 implies n div m =-(n2 div m2))
  &(m2*(n2 div m2)<>n2 implies n div m =-(n2 div m2)-1))
  proof
    assume
A1: n>=0 & m<0 & n2=n & m2= -m; thus
    (m2*(n2 div m2)=n2 implies n div m =-(n2 div m2))
    proof
      assume
A2:   m2*(n2 div m2)=n2;
A3:   m2>0 by A1,XREAL_1:60;
      then
A4:   n2 = m2 * (n2 div m2) + (n2 mod m2) by NAT_D:2;
      thus n div m =[\ n/m /] by INT_1:def 7
        .=[\ (-n)/(-m) /] by XCMPLX_1:192
        .=(-n2) div m2 by A1,INT_1:def 7
        .= -(n2 div m2) by A2,A3,A4,WSIERP_1:50;
    end; thus
    (m2*(n2 div m2)<>n2 implies n div m =-(n2 div m2)-1)
    proof
      assume
A5:   m2*(n2 div m2)<>n2;
A6:   m2>0 by A1,XREAL_1:60;
      then n2 = m2 * (n2 div m2) + (n2 mod m2) by NAT_D:2;
      then
A7:   not n2 mod m2=0 by A5;
A8:   n div m =[\ n/m /] by INT_1:def 7
        .=[\ (-n)/(-m) /] by XCMPLX_1:192
        .=(-n2) div m2 by A1,INT_1:def 7;
      (-n2) div m2 +1= -(n2 div m2) by A6,A7,WSIERP_1:49;
      hence n div m =-(n2 div m2)-1 by A8;
    end;
  end;
  thus (n<0 & m>0 & n2= -n & m2=m implies
  (m2*(n2 div m2)=n2 implies n div m =-(n2 div m2))
  &(m2*(n2 div m2)<>n2 implies n div m =-(n2 div m2)-1))
  proof
    assume
A9: n<0 & m>0 & n2= -n & m2=m; thus
    (m2*(n2 div m2)=n2 implies n div m =-(n2 div m2))
    proof
      assume
A10:  m2*(n2 div m2)=n2;
A11:  n2 = m2 * (n2 div m2) + (n2 mod m2) by A9,NAT_D:2;
      (n div m)=(-n2) div m by A9
        .=-(n2 div m2) by A9,A10,A11,WSIERP_1:50;
      hence n div m = -(n2 div m2);
    end; thus
    (m2*(n2 div m2)<>n2 implies n div m =-(n2 div m2)-1)
    proof
      assume
A12:  m2*(n2 div m2)<>n2;
      n2 = m2 * (n2 div m2) + (n2 mod m2) by A9,NAT_D:2;
      then not n2 mod m2=0 by A12;
      then (-n2) div m2 +1 = -(n2 div m2) by A9,WSIERP_1:49;
      hence n div m =-(n2 div m2)-1 by A9;
    end;
  end;
  thus (n<0 & m<0 & n2= -n & m2= -m implies n div m =n2 div m2)
  proof
    assume
A13: n<0 & m<0 & n2= -n & m2= -m;
    thus n div m = [\ n/m /] by INT_1:def 7
      .=[\ (-n)/(-m) /] by XCMPLX_1:192
      .=n2 div m2 by A13,INT_1:def 7;
  end;
end;

::
:: int idiv_prg(int n,int m){
::   int i;
::   if (m==0){return 0;}
::   if (n>=0 && m>0){return idiv1_prg(n,m);}
::   if (n>=0 && m<0){
::    i= idiv1_prg(n,-m);
::    if((-m)*i==n){return -i;} else{return -i-1;}
::   }
::   if (n<0 && m>0){
::    i= idiv1_prg(-n,m);
::    if(m*i== -n){return -i;} else{return -i-1;}
::   }
::   return idiv1_prg(-n,-m);
::   }
::
:: One time writing program
::  Same as above.

definition
  let n,m be Integer;
  func idiv_prg(n,m) -> Integer means
  :Def2:
  ex i being Integer st
  (m=0 implies it=0)& (not m=0 implies
  (n>=0 & m>0 implies it= idiv1_prg(n,m))& (not (n>=0 & m>0) implies
  (n>=0 & m<0 implies i=idiv1_prg(n,-m) & ((-m)*i=n implies it=-i )&
  ((-m)*i <> n implies it= -i-1 ) )& (not (n>=0 & m<0) implies
  (n<0 & m>0 implies i=idiv1_prg(-n,m) & (m*i= -n implies it=-i )&
  (m*i <> -n implies it=-i-1 ) )& (not (n<0 & m>0) implies it=idiv1_prg(-n,-m)
  ) ) ) );
  existence
  proof
    defpred P[Integer] means (m=0 implies n div m=0)& (not m=0 implies
    (n>=0 & m>0 implies n div m= idiv1_prg(n,m))& (not (n>=0 & m>0) implies
    (n>=0 & m<0 implies $1=idiv1_prg(n,-m) & ((-m)*$1=n implies n div m=-$1 )&
    ((-m)*$1 <> n implies n div m= -$1-1 ) )& (not (n>=0 & m<0) implies
    (n<0 & m>0 implies $1=idiv1_prg(-n,m) & (m*$1= -n implies n div m=-$1 )&
    (m*$1 <> -n implies n div m=-$1-1 ) )& (not (n<0 & m>0) implies
    n div m=idiv1_prg(-n,-m) ) ) ) );
    per cases;
    suppose m=0;
      hence thesis;
    end;
    suppose
A1:   m<>0;
      now per cases;
        case
A2:       n>=0;
          now per cases by A1;
            case m>0;
              then P[idiv1_prg(n,m)] by A2,Th10;
              hence ex i being Integer st P[i];
            end;
            case
A3:           m<0;
              then
A4:           -m>0 by XREAL_1:60;
              then reconsider n2=n,m2=-m as Element of NAT by A2,INT_1:16;
              now per cases;
                case
A5:               (-m)* idiv1_prg(n,-m)=n;
A6:               idiv1_prg(n,-m)=n div (-m) by A2,A4,Th10;
                  then n div m= -(n2 div m2) by A3,A5,Th11;
                  hence ex i being Integer st P[i] by A3,A5,A6;
                end;
                case
A7:               (-m)* idiv1_prg(n,-m)<>n;
A8:               idiv1_prg(n,-m)=n div (-m) by A2,A4,Th10;
                  then n div m= -(n2 div m2)-1 by A3,A7,Th11;::then
                  hence ex i being Integer st P[i] by A3,A7,A8;
                end;
              end;
              hence ex i being Integer st P[i];
            end;
          end;
          hence ex i being Integer st P[i];
        end;
        case
A9:       n<0;
          then
A10:      -n >0 by XREAL_1:60;
          now per cases by A1;
            case
A11:          m<0;
              then
A12:          -m>0 by XREAL_1:60;
              n div m = [\ n/m /] by INT_1:def 7
                .=[\ (-n)/(-m) /] by XCMPLX_1:192
                .=(-n) div (-m) by INT_1:def 7;
              then P[idiv1_prg(-n,-m)] by A9,A10,A11,A12,Th10;
              hence ex i being Integer st P[i];
            end;
            case
A13:          m>0;
              then reconsider n2= -n,m2=m as Element of NAT by A10,INT_1:16;
              now per cases;
                case
A14:              (m)* idiv1_prg(-n,m)= -n;
A15:              idiv1_prg(-n,m)=(-n) div (m) by A10,A13,Th10;
                  then n div m= -(n2 div m2) by A9,A13,A14,Th11;::then
                  hence ex i being Integer st P[i] by A9,A13,A14,A15;
                end;
                case
A16:              (m)* idiv1_prg(-n,m)<> -n;
A17:              idiv1_prg(-n,m)=(-n) div (m) by A10,A13,Th10;
                  then n div m= -(n2 div m2)-1 by A9,A13,A16,Th11;
                  hence ex i being Integer st P[i] by A9,A13,A16,A17;
                end;
              end;
              hence ex i being Integer st P[i];
            end;
          end;
          hence ex i being Integer st P[i];
        end;
      end;
      hence thesis;
    end;
  end;
  uniqueness;
end;

theorem
  for n,m being Integer holds idiv_prg(n,m)=n div m
proof
  let n,m be Integer;
  per cases;
  suppose
A1: m=0;
    then idiv_prg(n,m)=0 by Def2;
    hence idiv_prg(n,m)=n div m by A1,INT_1:75;
  end;
  suppose
A2: m<>0;
    now per cases;
      case
A3:     n>=0;
        now per cases by A2;
          case
A4:         m>0;
            hence idiv_prg(n,m)=idiv1_prg(n,m) by A3,Def2
              .=n div m by A3,A4,Th10;
          end;
          case
A5:         m<0;
            now per cases;
              case
A6:             (-m)*(idiv1_prg(n,-m))=n;
A7:             -m>0 by A5,XREAL_1:60;
                then reconsider m2= -m,n2= n as Element of NAT by A3,INT_1:16;
A8:             idiv_prg(n,m)= - (idiv1_prg(n,-m)) by A3,A5,A6,Def2;
                idiv1_prg(n,-m)=n2 div m2 by A7,Th9;
                hence idiv_prg(n,m)=n div m by A5,A6,A8,Th11;
              end;
              case
A9:             (-m)*(idiv1_prg(n,-m))<>n;
A10:            -m>0 by A5,XREAL_1:60;
                then reconsider m2= -m,n2= n as Element of NAT by A3,INT_1:16;
A11:            idiv_prg(n,m)= - (idiv1_prg(n,-m))-1 by A3,A5,A9,Def2;
                idiv1_prg(n,-m)=n2 div m2 by A10,Th9;
                hence idiv_prg(n,m)=n div m by A5,A9,A11,Th11;
              end;
            end;
            hence idiv_prg(n,m)=n div m;
          end;
        end;
        hence idiv_prg(n,m)=n div m;
      end;
      case
A12:    n<0;
        then
A13:    -n>0 by XREAL_1:60;
        now per cases by A2;
          case
A14:        m<0;
            then
A15:        -m>0 by XREAL_1:60;
A16:        idiv_prg(n,m)=idiv1_prg(-n,-m) by A12,A14,Def2
              .=(-n) div (-m) by A13,A15,Th10;
            n div m = [\ n/m /] by INT_1:def 7
              .=[\ (-n)/(-m) /] by XCMPLX_1:192
              .=(-n) div (-m) by INT_1:def 7;
            hence idiv_prg(n,m)=(n) div (m) by A16;
          end;
          case
A17:        m>0;
            now per cases;
              case
A18:            (m)*(idiv1_prg(-n,m))= -n;
                reconsider m2= m,n2= -n as Element of NAT by A13,A17,INT_1:16;
A19:            idiv_prg(n,m)= - (idiv1_prg(-n,m)) by A12,A17,A18,Def2;
                idiv1_prg(-n,m)=n2 div m2 by A17,Th9;
                hence idiv_prg(n,m)=n div m by A12,A17,A18,A19,Th11;
              end;
              case
A20:            (m)*(idiv1_prg(-n,m))<> -n;
                reconsider m2= m,n2= -n as Element of NAT by A13,A17,INT_1:16;
A21:            idiv_prg(n,m)= - (idiv1_prg(-n,m))-1 by A12,A17,A20,Def2;
                idiv1_prg(-n,m)=n2 div m2 by A17,Th9;
                hence idiv_prg(n,m)=n div m by A12,A17,A20,A21,Th11;
              end;
            end;
            hence idiv_prg(n,m)=n div m;
          end;
        end;
        hence idiv_prg(n,m)=n div m;
      end;
    end;
    hence idiv_prg(n,m)=n div m;
  end;
end;

