:: Sequent calculus, derivability, provability. Goedel's completeness theorem.
::  by Marco B. Caminati
::
:: Received December 29, 2010
:: Copyright (c) 2010-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, NAT_1, RELAT_1,
      RELAT_2, FINSEQ_1, FUNCT_1, ARYTM_3, XCMPLX_0, CARD_1, ARYTM_1, FUNCT_2,
      XXREAL_0, ORDINAL4, FUNCT_7, FINSEQ_2, EQREL_1, COMPLEX1, MCART_1,
      PARTFUN1, MARGREL1, XBOOLEAN, FINSET_1, FUNCT_3, SETFAM_1, FUNCT_4,
      FUNCOP_1, CARD_3, FOMODEL0, FOMODEL1, FOMODEL2, FOMODEL3, FOMODEL4;
 notations TARSKI, MARGREL1, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SETFAM_1, SUBSET_1, DOMAIN_1,
      RELAT_1, RELSET_1, FUNCT_1, PARTFUN1, FUNCT_2, MCART_1, ORDINAL1, NAT_1,
      CARD_1, NUMBERS, XCMPLX_0, RELAT_2, XXREAL_0, FUNCT_7, FINSEQ_1, LANG1,
      FINSEQ_2, EQREL_1, INT_2, FINSET_1, FUNCT_4, FUNCOP_1, CARD_3, ORDERS_4,
      FOMODEL0, FOMODEL1, FOMODEL2, FOMODEL3;
 constructors NAT_1, CARD_1, ZFMISC_1, NUMBERS, INT_1, FINSEQ_1, XCMPLX_0,
      MONOID_0, XXREAL_0, FUNCT_7, FINSEQ_2, ENUMSET1, EQREL_1, RELSET_1,
      MCART_1, MARGREL1, FINSET_1, PARTFUN1, FINSEQOP, MATRIX_2, FUNCT_3,
      RFUNCT_3, SETFAM_1, LANG1, PRE_POLY, FUNCT_1, FUNCT_4, FUNCOP_1, CARD_3,
      ORDERS_4, FOMODEL0, FOMODEL1, FOMODEL2, FOMODEL3, XTUPLE_0;
 registrations ORDINAL1, XCMPLX_0, NAT_1, RELAT_1, NUMBERS, REAL_1, FUNCT_1,
      INT_1, FINSEQ_1, XREAL_0, FUNCT_2, FINSEQ_2, SUBSET_1, RELSET_1,
      PARTFUN1, EQREL_1, FINSEQ_6, PRE_POLY, CARD_1, XBOOLE_0, XXREAL_0,
      ZFMISC_1, SETFAM_1, MARGREL1, SIMPLEX0, FINSET_1, RAMSEY_1, YELLOW12,
      REALSET1, FUNCOP_1, CARD_3, FOMODEL0, FOMODEL1, FOMODEL2, FOMODEL3,
      FUNCT_7, FUNCT_4, XTUPLE_0;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions FINSEQ_1, RELAT_1, XBOOLEAN, FUNCOP_1, FOMODEL0, FOMODEL1,
      FOMODEL2, FOMODEL3, XTUPLE_0;
 theorems TARSKI, XBOOLE_0, FUNCT_1, FINSEQ_1, RELAT_1, XBOOLE_1, ZFMISC_1,
      FUNCT_2, ENUMSET1, NAT_1, ORDINAL1, MCART_1, FUNCT_7, ABSVALUE, EQREL_1,
      RELSET_1, PARTFUN1, RELSET_2, LANG1, FRAENKEL, RFUNCT_1, FINSEQ_2,
      HENMODEL, FUNCT_4, FUNCOP_1, SUPINF_2, GRFUNC_1, RELAT_2, XREAL_1,
      FOMODEL0, FOMODEL1, FOMODEL2, FOMODEL3, CARD_1, XTUPLE_0;
 schemes NAT_1, FUNCT_2, RELSET_1, FRAENKEL;

begin

reserve k,m,n for Nat,
        kk,mm,nn for Element of NAT, U for non empty set,
        A,B,X,Y,Z,x,x1,x2,y,z for set, S for Language,
        s, s1, s2 for Element of S, f,g for Function,
        w for string of S, tt,tt1,tt2 for Element of AllTermsOf S,
        psi,psi1,psi2,phi,phi1,phi2 for wff string of S,
        u,u1,u2 for Element of U,
        Phi,Phi1,Phi2 for Subset of AllFormulasOf S,
        t,t1,t2 for termal string of S,
r for relational Element of S, a for ofAtomicFormula Element of S,
l, l1, l2 for literal Element of S, p for FinSequence,
m1, n1 for non zero Nat, S1, S2 for Language;

Lm1: X is Subset of Funcs(A,B) implies X is Subset-Family of [:A,B:]
proof
A1: Funcs(A,B) c= bool [:A,B:] by FRAENKEL:2;
assume X is Subset of Funcs (A, B); hence thesis by A1,XBOOLE_1:1;
end;

Lm2: <*TheEqSymbOf S*>^t1^t2 is 0wff string of S
proof
set E=TheEqSymbOf S, AT=AllTermsOf S, C=S-multiCat, SS=AllSymbolsOf S;
reconsider tt1=t1,tt2=t2 as Element of AT by FOMODEL1:def 32; reconsider
T=<*tt1*>^<*tt2*> as 2-element Element of (AT*) by FINSEQ_1:def 11;
reconsider ATT=AT as Subset of SS* by XBOOLE_1:1; reconsider
TT=T as Element of ATT*;
reconsider TTT=TT as Element of SS**;
reconsider EE=E as ofAtomicFormula Element of S;
A1: abs(-2)=-(-2) by ABSVALUE:def 1 .= 2;
A2: abs(ar(EE))=2 by A1,FOMODEL1:def 23; C.TT is Element of SS*;
then reconsider tailer=C.T as FinSequence of SS;
reconsider SSS=SS as non empty set;
reconsider EEE=EE as Element of SSS;
reconsider header=<*EEE*> as FinSequence of SS;
reconsider IT=header^tailer as non empty FinSequence of SS;

reconsider phi=IT as string of S by FOMODEL1:13;

tailer = (SS-multiCat.<*tt1,tt2*>) .= tt1^tt2 by FOMODEL0:15;
then <*E*>^(t1^t2) is 0wff string of S by A2,FOMODEL1:def 35;
hence <*E*>^t1^t2 is 0wff string of S by FINSEQ_1:32;
end;

::#####################################################################
::#Definitions and auxiliary lemmas
definition let S be Language;
func S-sequents equals
{[premises,conclusion] where premises is Subset of (AllFormulasOf S),
conclusion is wff string of S: premises is finite};
coherence;
end;

registration let S be Language;
cluster S-sequents -> non empty;
coherence
proof
set AF=AllFormulasOf S; set premises = the finite Subset of AF;
set conclusion = the wff string of S;
[premises,conclusion] in S-sequents; hence thesis;
end;
end;

registration let S;
cluster S-sequents -> Relation-like;
coherence
proof
set SS=AllSymbolsOf S, strings=SS*\{{}}, FF=AllFormulasOf S;
now
let z; assume z in S-sequents; then consider x being Subset of FF,
y being wff string of S such that A1: z=[x,y] & x is finite;
thus z in [:bool FF, strings:] by A1;
end; then S-sequents is Subset of [:bool FF, strings:] by TARSKI:def 3;
hence thesis;
end;
end;

definition
let S be Language;
let x be set;
attr x is S-sequent-like means :Def2: x in S-sequents;
end;

definition ::def3 1
let S,X;
attr X is S-sequents-like means :Def3: X c= S-sequents;
end;

registration let S;
cluster -> S-sequents-like for Subset of S-sequents;
coherence by Def3;
cluster -> S-sequent-like for Element of S-sequents;
coherence by Def2;
end;

registration
let S be Language;
cluster S-sequent-like for Element of S-sequents;
existence proof take the Element of S-sequents; thus thesis; end;
cluster S-sequents-like for Subset of S-sequents;
existence proof take the Subset of S-sequents; thus thesis; end;
end;

registration let S;
cluster S-sequent-like for set;
existence proof take the Element of S-sequents; thus thesis; end;
cluster S-sequents-like for set;
existence proof take the Subset of S-sequents; thus thesis; end;
end;

definition let S be Language;
mode Rule of S is Element of Funcs (bool (S-sequents), bool (S-sequents));
end;

definition let S be Language;
mode RuleSet of S is Subset of Funcs (bool (S-sequents), bool (S-sequents));
end;

reserve D,D1,D2,D3 for RuleSet of S, R for Rule of S,
Seqts,Seqts1,Seqts2 for Subset of S-sequents,
seqt,seqt1,seqt2 for Element of S-sequents,
SQ,SQ1,SQ2 for S-sequents-like set, Sq,Sq1,Sq2 for S-sequent-like set;

registration
let A,B;
let X be Subset of Funcs(A,B);
cluster union X -> Relation-like;
coherence;
end;

registration
let S be Language; let D be RuleSet of S;
cluster union D -> Relation-like;
coherence;
end;

definition
let S,D;
func OneStep(D) -> Rule of S means :Def4:
for Seqs being Element of bool (S-sequents) holds
it.Seqs = union ((union D) .: {Seqs});
existence
proof
set Q=S-sequents, F=Funcs(bool Q,bool Q);
reconsider RR=union D as Relation of bool Q by FOMODEL0:19;
deffunc G(Element of bool Q)=union (RR.:{$1}); consider f being
Function of bool Q, bool Q such that A1: for x being Element of bool Q
holds f.x=G(x) from FUNCT_2:sch 4; reconsider ff=f as Element of F
by FUNCT_2:8; take ff; thus thesis by A1;
end;
uniqueness
proof
set Q=S-sequents, F=Funcs(bool Q,bool Q); let IT1,IT2 be Rule of S;
reconsider IT11=IT1, IT22=IT2 as Function of bool Q, bool Q;
deffunc G(set)=union ((union D).:{$1});
assume A2: for Seqs being Element of bool Q holds IT1.Seqs = G(Seqs);
assume A3: for Seqs being Element of bool Q holds IT2.Seqs = G(Seqs);
now
let x be Element of bool Q; thus IT11.x=G(x) by A2 .= IT22.x by A3;
end;
hence thesis by FUNCT_2:63;
end;
end;

Lm3: dom (OneStep D)=bool (S-sequents) & rng (OneStep D) c= dom (OneStep D) &
iter(OneStep D,m) is Function of bool (S-sequents), bool (S-sequents) &
dom iter(OneStep D,m)=bool (S-sequents) & dom (OneStep D) \/
rng (OneStep D) = bool (S-sequents) & Seqts in dom R & SQ in dom (iter(R,m))
proof
set O=OneStep D, Q=S-sequents; thus A1: dom O=bool Q by FUNCT_2:def 1;
hence A2: rng O c= dom O by RELAT_1:def 19;
thus iter(O,m) is Function of bool Q, bool Q by FUNCT_7:83; hence
dom iter(O,m)=bool Q by FUNCT_2:def 1; thus
dom O \/ rng O = bool Q by A1,A2,XBOOLE_1:12;
dom R=bool Q by FUNCT_2:def 1; hence Seqts in dom R;
iter(R,m) is Function of bool Q, bool Q by FUNCT_7:83; then
dom (iter (R,m))=bool Q & SQ c= Q by Def3,FUNCT_2:def 1;
hence SQ in dom (iter(R,m));
end;

definition let S,D,m;
func (m,D)-derivables -> Rule of S equals iter(OneStep D,m);
coherence
proof
set Q=S-sequents, O=OneStep D, IT=iter(O,m);
IT is Function of bool Q, bool Q by FUNCT_7:83; hence thesis by FUNCT_2:8;
end;
end;

definition
let S be Language;
let D be RuleSet of S;
let Seqs1,Seqs2 be set;
attr Seqs2 is (Seqs1,D)-derivable means :Def6:
Seqs2 c= union (((OneStep D) [*]) .: {Seqs1});
end;

definition ::def7 1
let m,S,D; let Seqts,seqt be set;
attr seqt is (m,Seqts,D)-derivable means :Def7:
seqt in (m,D)-derivables.Seqts;
end;

definition let S,D;
func D-iterators -> Subset-Family of [:bool (S-sequents), bool (S-sequents):]
equals {iter(OneStep D,mm):not contradiction};
coherence
proof
set O=OneStep D, Q=S-sequents, IT={iter(O,mm):not contradiction};
now
let x; assume x in IT; then consider mm such that
A1: x=iter(O,mm) & not contradiction; x is Relation of bool Q, bool Q by Lm3,A1
;
hence x in bool [:bool Q, bool Q:];
end;
hence thesis by TARSKI:def 3;
end;
end;

definition let S,R;
attr R is isotone means :Def9:
Seqts1 c= Seqts2 implies R.Seqts1 c= R.Seqts2;
end;

Lm4: id (bool (S-sequents)) is Rule of S &
(R=id (bool (S-sequents)) implies R is isotone)
proof
set Q=S-sequents;
reconsider I=id (bool Q) as Rule of S by FUNCT_2:8;
id (bool Q)=I;hence id (bool Q) is Rule of S;
A1: now
let Seqts1, Seqts2;
A2: I.Seqts1=Seqts1 & I.Seqts2=Seqts2 by FUNCT_1:17;
assume Seqts1 c= Seqts2;
hence I.Seqts1 c= I.Seqts2 by A2;
end;
assume R=id (bool Q); hence thesis by A1,Def9;
end;

registration let S;
cluster isotone for Rule of S;
existence
proof
set Q=S-sequents; reconsider I=id(bool Q) as Rule of S by Lm4; take I;
thus I is isotone by Lm4;
end;
end;

definition let S,D;
attr D is isotone means :Def10: for Seqts1,Seqts2,f st
Seqts1 c= Seqts2 & f in D ex g st (g in D & f.Seqts1 c= g.Seqts2);
end;

registration let S; let M be isotone Rule of S;
cluster {M} -> isotone for RuleSet of S;
coherence
proof
set Q=S-sequents;
now
let Seqts1,Seqts2,f; assume A1: Seqts1 c= Seqts2 & f in {M}; then
reconsider F=f as isotone Rule of S by TARSKI:def 1;
take g=f; thus g in {M} by A1;
F.Seqts1 c= F.Seqts2 by A1,Def9; hence f.Seqts1 c= g.Seqts2;
end;
hence thesis by Def10;
end;
end;

registration let S;
cluster isotone for RuleSet of S;
existence
proof set M = the isotone Rule of S; take D={M}; thus thesis; end;
end;

reserve M,K,K1,K2 for isotone RuleSet of S;

definition
let S be Language;
let D be RuleSet of S;
let Seqts be set;
attr Seqts is D-derivable means :Def11: Seqts is ({},D)-derivable;
end;

registration
let S,D;
cluster D-derivable -> ({},D)-derivable for set;
coherence by Def11;
cluster ({},D)-derivable -> D-derivable for set;
coherence by Def11;
end;

registration
let S,D; let Seqts be empty set;
cluster (Seqts,D)-derivable -> D-derivable for set;
coherence;
end;

definition let S,D,X; let phi be set;
attr phi is (X,D)-provable means :Def12: ::Def13 1
{[X,phi]} is D-derivable or ex seqt being set
st (seqt`1 c= X & seqt`2 = phi & {seqt} is D-derivable);
end;

definition let S,D,X,x;
redefine attr x is (X,D)-provable means :Def13:
ex seqt being set st (seqt`1 c= X & seqt`2 = x & {seqt} is D-derivable);
compatibility
proof
defpred P[] means ex seqt being set st
(seqt`1 c= X & seqt`2 = x & {seqt} is D-derivable);
thus  x is (X,D)-provable implies P[]
proof assume
A1: x is (X,D)-provable;
per cases; suppose
A2: {[X,x]} is D-derivable; take seqt=[X,x];
thus seqt`1 c= X & seqt`2 = x by MCART_1:7;
thus {seqt} is D-derivable by A2;
end;
suppose not {[X,x]} is D-derivable; hence thesis by Def12,A1; end;
end;
assume P[]; hence x is (X,D)-provable by Def12;
end;
end;

definition let S,D,R;
attr R is D-macro means for Seqs being Subset of S-sequents
holds R.Seqs is (Seqs,D)-derivable;
end;

definition let S,D; let Phi be set;
func (Phi,D)-termEq equals
{ [t1, t2] where t1,t2 is termal string of S:
<* TheEqSymbOf S *> ^ t1 ^ t2 is (Phi,D)-provable};
coherence;
end;

definition
let S,D; let Phi be set; ::Def16 1
attr Phi is D-expanded means :Def16:
::#Deductively closed (cfr. Hedman)
x is (Phi,D)-provable implies {x} c= Phi;
end;

definition
let S,x; ::Def17 1
attr x is S-null means :Def17: not contradiction;
end;

Lm5: X c= Y & x is (X,D)-provable implies x is (Y,D)-provable
proof
assume
A1: X c= Y; assume
x is (X,D)-provable; then consider seqt being set such that
A2: (seqt`1 c= X & seqt`2 = x & {seqt} is D-derivable) by Def13;
(seqt`1 c= Y & seqt`2 = x & {seqt} is D-derivable) by A2,A1,XBOOLE_1:1;
hence thesis by Def13;
end;

::#####################################################################
::#####################################################################
::#####################################################################
::#Type Tuning

definition
let S,D; let Phi be set;
redefine func (Phi,D)-termEq -> Relation of (AllTermsOf S);
coherence
proof
now
let x be set;
assume x in (Phi,D)-termEq;
then consider t1,t2 being termal string of S such that A1:
x=[t1,t2] & <* TheEqSymbOf S *> ^ t1 ^ t2 is (Phi,D)-provable;
reconsider t1b = t1 as Element of (AllTermsOf S) by FOMODEL1:def 32;
reconsider t2b = t2 as Element of (AllTermsOf S) by FOMODEL1:def 32;
x=[t1b,t2b] by A1;
hence x in [:AllTermsOf S, AllTermsOf S:];
end;
hence thesis by TARSKI:def 3;
end;
end;

registration
let S,phi;
let Phi1,Phi2 be finite Subset of (AllFormulasOf S);
cluster [Phi1 \/ Phi2, phi] -> S-sequent-like;
coherence
proof
set AF=AllFormulasOf S; reconsider Phi=Phi1 \/ Phi2 as finite Subset of AF;
[Phi, phi] in S-sequents; hence thesis;
end;
end;

definition
let S;
let x be empty set;
let phi be wff string of S;
redefine func [ x, phi ] -> Element of S-sequents;
coherence
proof
reconsider premises=x as finite Subset of ((AllSymbolsOf S)*) by XBOOLE_1:2;
premises c= AllFormulasOf S by XBOOLE_1:2;
then [premises ,phi] in S-sequents;
hence thesis;
end;
end;

registration let S;
cluster {} /\ S -> S-sequents-like for set;
coherence
proof
set Q=S-sequents, IT={}/\S;
reconsider ITT=IT as Subset of Q by XBOOLE_1:2;
ITT is S-sequents-like; hence thesis;
end;
end;

registration let S;
cluster S-null for set;
existence by Def17;
end;

registration let S;
cluster S-sequent-like -> S-null for set;
coherence by Def17;
end;

registration
let S;
cluster -> S-null for Element of S-sequents; coherence;
end;

registration
let m,S,D,X;
cluster (m,D)-derivables.X -> S-sequents-like;
coherence
proof
set Q=S-sequents;
reconsider f=(m,D)-derivables as Function of bool Q, bool Q;
per cases;
suppose not X in bool Q; then not X in dom f;
then f.X={} by FUNCT_1:def 2; then f.X c= Q by XBOOLE_1:2;
hence thesis;
end;
suppose X in bool Q; then reconsider XX=X as Element of bool Q;
f.XX is Element of bool Q; hence thesis;
end;
end;
end;

registration let S,Y; let X be S-sequents-like set;
cluster X/\Y -> S-sequents-like for set;
coherence
proof
set Q=S-sequents;
X c= Q by Def3; then X/\Y c= Q by XBOOLE_1:1;
hence thesis;
end;
end;

registration
let S,D,m,X;
cluster (m,X,D)-derivable -> S-sequent-like for set;
coherence
proof
set O=OneStep D, All=union ((O[*]).:{X}), Q=S-sequents;
A1: (m,D)-derivables.X c= Q by Def3;
let x; assume x is (m,X,D)-derivable; then
x in (m,D)-derivables.X by Def7;
hence thesis by A1;
end;
end;

registration
let S,D;
let Phi1, Phi2 be set;
cluster (Phi1\Phi2,D)-provable -> (Phi1,D)-provable for set;
coherence by Lm5;
end;

registration
let S,D;
let Phi1, Phi2 be set;
cluster (Phi1\Phi2,D)-provable -> (Phi1\/Phi2,D)-provable for set;
coherence by Lm5,XBOOLE_1:7;
end;

registration
let S,D; let Phi1,Phi2 be set;
cluster (Phi1/\Phi2,D)-provable -> (Phi1,D)-provable for set;
coherence by Lm5;
end;

registration
let S,D; let X be set, x be Subset of X;
cluster (x,D)-provable -> (X,D)-provable for set;
coherence
proof
let y; assume y is (x,D)-provable; then consider seqt being set such that
A1: (seqt`1 c= x & seqt`2 = y & {seqt} is D-derivable) by Def13;
(seqt`1 c= X & seqt`2 = y & {seqt} is D-derivable) by A1,XBOOLE_1:1;
hence thesis by Def13;
end;
end;

registration
let S; let premises be finite Subset of (AllFormulasOf S);
let phi be wff string of S;
cluster [premises,phi] -> S-sequent-like for set;
coherence
proof
set x=[premises,phi], Q=S-sequents;
x in Q; hence thesis;
end;
end;

registration
let S; let phi1,phi2 be wff string of S;
cluster [{phi1},phi2] -> S-sequent-like for set;
coherence
proof
set AF=AllFormulasOf S;
reconsider phi11=phi1 as Element of AF by FOMODEL2:16;
reconsider Phi={phi11} as finite Subset of AF;
[Phi,phi2] is S-sequent-like; hence thesis;
end;
let phi3 be wff string of S;
cluster [{phi1,phi2},phi3] -> S-sequent-like for set;
coherence
proof
set AF=AllFormulasOf S; reconsider phi11=phi1,phi22=phi2 as
Element of AF by FOMODEL2:16; reconsider Phi={phi11}\/{phi22} as
finite Subset of AF; [Phi,phi2] is S-sequent-like
& Phi={phi11, phi22} by ENUMSET1:1; hence thesis;
end;
end;

registration
let S, phi1, phi2; let Phi be finite Subset of AllFormulasOf S;
cluster [Phi\/{phi1}, phi2] -> S-sequent-like for set;
coherence
proof
set AF=AllFormulasOf S;
reconsider phi11=phi1 as Element of AF by FOMODEL2:16;
reconsider Phi2=Phi\/{phi11} as finite Subset of AF;
[Phi2,phi2] is S-sequent-like; hence thesis;
end;
end;

::######################################################################
::########################Lemmas

Lm6: X c= S-sequents implies (OneStep D).X = union( union
{R.:{X} where R is Subset of [:bool(S-sequents),bool(S-sequents):]:R in D})
proof
set Q=S-sequents,F={R.:{X} where R is Subset of [:bool Q,bool Q:]:R in D},
O=OneStep D; assume X c= Q;
then reconsider Seqts=X as Element of bool Q;
reconsider DD=D as Subset-Family of [:bool Q, bool Q:] by Lm1;
O.Seqts = union ((union DD) .: {Seqts}) by Def4 .=
union (union F) by RELSET_2:34; hence thesis;
end;

Lm7: R=OneStep({R})
proof
set IT=OneStep({R}); A1:
dom R= bool (S-sequents) by FUNCT_2:def 1 .= dom IT by FUNCT_2:def 1;
now
let x be set;assume A2: x in dom R; thus
R.x = union ({R.x}) by ZFMISC_1:25 .= union (Im(R,x)) by A2,FUNCT_1:59 .=
union ((union {R}).:{x}) by ZFMISC_1:25 .= IT.x by Def4,A2;
end;
hence thesis by A1,FUNCT_1:2;
end;

Lm8:{y} is (Seqts,D)-derivable implies ex mm st y is (mm,Seqts,D)-derivable
proof
set X=Seqts, Q=S-sequents, O=OneStep D, I=D-iterators;
assume {y} is (X,D)-derivable; then
{y} c= union ((O[*]).:{X}) by Def6; then
y in union ((O[*]).:{X}) by ZFMISC_1:31; then consider
Y such that A1: y in Y & Y in ((O[*]).:{X}) by TARSKI:def 4;
rng O c= dom O by Lm3; then O[*]=union I by FOMODEL0:17; then
(O[*]).:{X} = union {R.:{X} where R is Subset of [:bool Q, bool Q:]: R in I}
by RELSET_2:34; then consider Z such that
A2: Y in Z & Z in {R.:{X} where R is Subset of [:bool Q, bool Q:]: R in I}
by A1,TARSKI:def 4;
consider f being Subset of [:bool Q, bool Q:] such that
A3: Z=f.:{X} & f in I by A2; consider mm being Element of NAT such that
A4: f=iter(O,mm) & not contradiction by A3; take mm;
iter(O,mm) is Function of bool Q, bool Q by FUNCT_7:83; then
A5: dom iter(O,mm) = bool Q by FUNCT_2:def 1;
y in Y & Y in Im((iter(O,mm)),X) by A1,A2,A4,A3; then
y in Y & Y in {(iter(O,mm)).X} by A5,FUNCT_1:59;
then y in (mm,D)-derivables.Seqts by TARSKI:def 1;
hence y is (mm,Seqts,D)-derivable by Def7;
end;

Lm9:
X c= S-sequents implies (m,D)-derivables.X c= union (((OneStep D)[*]).:{X})
proof
set O=OneStep D, RH=union ((O[*]).:{X}),Q=S-sequents; assume X c= Q;then
A1: X in dom iter(O,m) by Lm3;
reconsider f=union {iter(O,m)} as Function by ZFMISC_1:25;
A2: iter(O,m).X = union {iter(O,m).X} by ZFMISC_1:25 .=
union (Im(iter(O,m),X)) by A1,FUNCT_1:59 .= union (f.:{X})
by ZFMISC_1:25; reconsider mm=m as Element of NAT by ORDINAL1:def 12;
iter(O,mm)=iter(O,m); then iter(O,m) in D-iterators; then
{iter(O,m)} c= D-iterators by ZFMISC_1:31; then
union {iter(O,m)} c= union (D-iterators) by ZFMISC_1:77; then
f.:{X} c= (union (D-iterators)).:{X} by RELAT_1:124; then
A3: (m,D)-derivables.X c= union ((union (D-iterators)).:{X})
by A2,ZFMISC_1:77; rng O c= dom O by Lm3;
hence thesis by A3,FOMODEL0:17;
end;

Lm10: union (((OneStep D)[*]).:{X}) =
union {(mm,D)-derivables.X where mm is Element of NAT: not contradiction}
proof
set F={(mm,D)-derivables.X where mm is Element of NAT: not contradiction},
LH=union F, Q=S-sequents, O=OneStep D, RH=union((O[*]).:{X});
per cases;
suppose A1: not X in bool Q; then {X} misses bool Q by ZFMISC_1:50; then
{X} misses dom (O[*]) by XBOOLE_1:63; then {X} /\ dom (O[*]) = {} by
XBOOLE_0:def 7;
then (O[*]).:{X} = (O[*]).:{} by RELAT_1:112.= {}; then
reconsider E=(O[*]).:{X} as empty set;
now
let x; assume x in F; then consider mm such that
A2: x=(mm,D)-derivables.X; not X in dom (mm,D)-derivables by A1;
then x={} by A2,FUNCT_1:def 2; hence x in {{}} by TARSKI:def 1;
end;
then F c= {{}} by TARSKI:def 3; then LH c= union {{}} by ZFMISC_1:77;
then LH c= {} by ZFMISC_1:25; then union E = {} & LH ={};
hence thesis;
end;
suppose A3: X in bool Q; then reconsider Seqts=X as Element of bool Q;
for Y st Y in F holds Y c= RH
proof
let Y; assume Y in F; then consider mm such that
A4: Y=(mm,D)-derivables.X & not contradiction;
thus thesis by A4,A3,Lm9;
end;
then A5: LH c= RH by ZFMISC_1:76;
now
let y; assume y in RH; then {y} c= RH by ZFMISC_1:31; then {y} is (Seqts,D)
-derivable by Def6; then consider mm such that
A6: y is (mm,Seqts,D)-derivable by Lm8;
set Y=(mm,D)-derivables.Seqts; y in Y & Y in F by Def7,A6;
hence y in LH by TARSKI:def 4;
end;
then RH c= LH by TARSKI:def 3; hence thesis by A5,XBOOLE_0:def 10;
end;
end;

Lm11: (m,D)-derivables.X c= union (((OneStep D)[*]).:{X})
proof
set F={(mm,D)-derivables.X where mm is Element of NAT: not contradiction},
LH=union F, Q=S-sequents, O=OneStep D, RH=union((O[*]).:{X});
reconsider mm=m as Element of NAT by ORDINAL1:def 12;
(mm,D)-derivables.X in F; then (mm,D)-derivables.X c= union F
by ZFMISC_1:74; hence thesis by Lm10;
end;

Lm12: x is (m,X,D)-derivable implies {x} is (X,D)-derivable
proof
set Q=S-sequents, O=OneStep D, RH=union((O[*]).:{X});
assume x is (m,X,D)-derivable; then
A1: x in (m,D)-derivables.X by Def7;
(m,D)-derivables.X c= RH by Lm11; then
{x} c= RH by A1,ZFMISC_1:31; hence thesis by Def6;
end;

Lm13: Seqts1 c= Seqts2 & D1 c= D2 & (D2 is isotone or D1 is isotone)
implies (OneStep D1).Seqts1 c= (OneStep D2).Seqts2
proof
set Q=S-sequents, U1=union D1, U2=union D2, O1=OneStep D1, O2=OneStep D2,
F1={R.:{Seqts1} where R is Subset of [:bool Q, bool Q:]:R in D1},
F2={R.:{Seqts2} where R is Subset of [:bool Q, bool Q:]:R in D2},
X1=Seqts1, X2=Seqts2;
A1: O1.X1=union (union F1) & O2.X2 = union (union F2) by Lm6; assume
A2: X1 c= X2 & D1 c= D2 & (D2 is isotone or D1 is isotone);
now
let z; assume z in union union F1; then consider x such that
A3: z in x & x in union F1 by TARSKI:def 4;
consider X such that
A4: x in X & X in F1 by A3,TARSKI:def 4;
consider R being Subset of [: bool Q, bool Q:] such that
A5: X=R.:{X1} & R in D1 by A4;
reconsider RR=R as Rule of S by A5;
X=Im(RR,X1) & R in D1 & X1 in dom RR by A5,Lm3; then
A6: X={RR.X1} by FUNCT_1:59;
now
per cases;
suppose D2 is isotone; hence ex g st
g in D2 & RR.X1 c= g.X2 by A5,A2,Def10;
end;
suppose not D2 is isotone; then consider g such that
A7: g in D1 & RR.X1 c= g.X2 by A5,A2,Def10;
thus ex g st g in D2 & RR.X1 c= g.X2 by A7,A2;
end;
end;
then consider g such that
A8: g in D2 & RR.X1 c= g.X2;
reconsider Rg=g as Rule of S by A8; A9: X2 in dom Rg by Lm3;
A10: x c= g.X2 by A8,A6,A4,TARSKI:def 1; Im(Rg,X2) in F2 by A8; then
{Rg.X2} in F2 by A9,FUNCT_1:59; then {{Rg.X2}} c= F2 by ZFMISC_1:31;
then union {{g.X2}} c= union F2 by ZFMISC_1:77; then
{g.X2} c= union F2 by ZFMISC_1:25; then
union {g.X2} c= union union F2 by ZFMISC_1:77; then
g.X2 c= union union F2 by ZFMISC_1:25; then
x c= union union F2 by A10,XBOOLE_1:1; hence
z in union union F2 by A3;
end;
hence thesis by A1,TARSKI:def 3;
end;

Lm14: Seqts1 c= Seqts2 & D1 c= D2 & (D2 is isotone or D1 is isotone)
implies (m,D1)-derivables.Seqts1 c= (m,D2)-derivables.Seqts2
proof
set O1=OneStep D1, O2=OneStep D2, Q=S-sequents, X1=Seqts1, X2=Seqts2;
assume A1: X1 c= X2 & D1 c= D2 & (D2 is isotone or D1 is isotone);
defpred P[Nat] means ($1,D1)-derivables.X1 c= ($1,D2)-derivables.X2;
A2: P[0]
proof
A3: iter(O1,0).X1=(id field O1).X1 by FUNCT_7:68
.= id(bool Q).X1 by Lm3 .= X1 by FUNCT_1:17;
iter(O2,0).X2=(id field O2).X2 by FUNCT_7:68
.= id(bool Q).X2 by Lm3 .= X2 by FUNCT_1:17;
hence thesis by A3,A1;
end;
A4: for n st P[n] holds P[n+1]
proof
let n; A5:X1 in dom iter(O1,n) & X2 in dom iter(O2,n) by Lm3; reconsider
X11=(n,D1)-derivables.X1, X22=(n,D2)-derivables.X2 as Subset of Q;
assume
A6: P[n];
A7: (n+1,D1)-derivables.X1=(O1*iter(O1,n)).X1 by FUNCT_7:71 .=
O1.X11 by A5,FUNCT_1:13;
(n+1,D2)-derivables.X2 = (O2*iter(O2,n)).X2 by FUNCT_7:71 .=
O2.X22 by A5,FUNCT_1:13;
hence thesis by A7,A6,Lm13,A1;
end;
for k being Nat holds P[k] from NAT_1:sch 2(A2,A4); hence thesis;
end;

Lm15: SQ1 c= SQ2 & D1 c= D2 & (D2 is isotone or D1 is isotone)
implies (m,D1)-derivables.SQ1 c= (m,D2)-derivables.SQ2
proof
reconsider Seqts1=SQ1, Seqts2=SQ2 as Subset of S-sequents by Def3;
assume SQ1 c= SQ2 & D1 c= D2 & (D2 is isotone or D1 is isotone);
then (m,D1)-derivables.Seqts1 c= (m,D2)-derivables.Seqts2 by Lm14;
hence thesis;
end;

Lm16: D1 c= D2 & (D2 is isotone or D1 is isotone) implies
(m,D1)-derivables.X c= (m,D2)-derivables.X
proof
set Q=S-sequents, f1=(m,D1)-derivables, f2=(m,D2)-derivables;
assume A1: D1 c= D2 & (D2 is isotone or D1 is isotone);
per cases;
suppose X in bool Q;
then reconsider Seqts1=X as Element of bool Q;
f1.Seqts1 c= f2.Seqts1 by Lm14,A1; hence f1.X c= f2.X;
end;
suppose not X in bool Q; then not X in dom f1 & not X in dom f2;
then f1.X={} & f2.X={} by FUNCT_1:def 2; hence f1.X c= f2.X;
end;
end;

Lm17: D1 c= D2 & (D2 is isotone or D1 is isotone) implies
union (((OneStep D1)[*]).:{X}) c= union (((OneStep D2)[*]).:{X})
proof
set F1={(mm,D1)-derivables.X where mm is Element of NAT: not contradiction},
F2={(mm,D2)-derivables.X where mm is Element of NAT: not contradiction},
O1=OneStep D1, O2=OneStep D2, Q=S-sequents, LH=union ((O1[*]).:{X}),
RH=union ((O2[*]).:{X});
A1: LH=union F1 & RH=union F2 by Lm10;
assume A2: D1 c= D2 & (D2 is isotone or D1 is isotone);
now
let x; assume x in F1; then consider mm such that
A3: x=(mm,D1)-derivables.X & not contradiction;
A4: x c= (mm,D2)-derivables.X by A2,Lm16,A3;
(mm,D2)-derivables.X in F2; then
(mm,D2)-derivables.X c= union F2 by ZFMISC_1:74;
hence x c= union F2 by A4,XBOOLE_1:1;
end;
hence thesis by A1,ZFMISC_1:76;
end;

Lm18: D1 c= D2 & (D2 is isotone or D1 is isotone) & Y is (X,D1)-derivable
implies Y is (X,D2)-derivable
proof
set O1=OneStep D1, O2=OneStep D2, Q=S-sequents, LH=union ((O1[*]).:{X}),
RH=union ((O2[*]).:{X}); assume
D1 c= D2 & (D2 is isotone or D1 is isotone) & Y is (X,D1)-derivable;
then LH c= RH & Y c= LH by Def6,Lm17; then
Y c= RH by XBOOLE_1:1; hence thesis by Def6;
end;

Lm19: Y c= R.Seqts implies Y is (Seqts,{R})-derivable
proof
set D={R}, RR=(OneStep D)[*], Q=S-sequents;
Seqts in bool Q & dom R=bool Q by FUNCT_2:def 1; then
A1: {R.Seqts}=Im(R,Seqts) by FUNCT_1:59 .= R.:{Seqts};
(OneStep D) c= RR by LANG1:18; then A2: R c= RR by Lm7;
{R.Seqts} c= RR.:{Seqts} by A1,A2,RELAT_1:124; then
union {R.Seqts} c= union (RR.:{Seqts}) by ZFMISC_1:77; then
A3: R.Seqts c= union (RR.:{Seqts}) by ZFMISC_1:25;
assume Y c= R.Seqts; then Y c= union (RR.:{Seqts}) by A3,XBOOLE_1:1;
hence thesis by Def6;
end;

Lm20: (D1 is isotone & D1\/D2 is isotone &
SQ2 c= iter(OneStep D1,m).SQ1 & Z c= iter(OneStep D2,n).SQ2) implies
Z c= iter (OneStep (D1\/D2),m+n).SQ1
proof
reconsider mm=m, nn=n as Element of NAT by ORDINAL1:def 12;
set D3=D1\/D2, O1=OneStep D1, O2=OneStep D2,
O3=OneStep (D3), X=SQ1, Y=SQ2; assume
A1: D1 is isotone & D3 is isotone; assume
A2: Y c= iter(O1,m).X & Z c= iter(O2,n).Y;
A3: D3 c= D3 & D1 c= D3 & D2 c= D3 by XBOOLE_1:7; then
(m,D1)-derivables.X c= (m,D1\/D2)-derivables.X by Lm16,A1; then
A4: Y c= (m,D3)-derivables.X by A2,XBOOLE_1:1;
A5: X in dom iter(O3,m) by Lm3;
(n,D2)-derivables.Y c= (n,D3)-derivables.Y by A3,A1,Lm16; then
A6: Z c= (n,D3)-derivables.Y by A2,XBOOLE_1:1;
(m+n,D1\/D2)-derivables.X =
(iter(O3,nn)*iter(O3,mm)).X by FUNCT_7:77
.= (n,D1\/D2)-derivables.(iter(O3,m).X) by A5,FUNCT_1:13; then
(n,D1\/D2)-derivables.Y c= (m+n,D1\/D2)-derivables.X by A4,A1,Lm15;
hence thesis by A6,XBOOLE_1:1;
end;

Lm21: (D1 is isotone & D1\/D2 is isotone &
y is (m,X,D1)-derivable & z is (n,{y},D2)-derivable) implies
z is (m+n,X,D1\/D2)-derivable
proof
set Q=S-sequents, D3=D1\/D2, O1=OneStep D1, O2=OneStep D2, O3=OneStep D3;
assume
A1: D1 is isotone & D3 is isotone; assume
A2: y is (m,X,D1)-derivable & z is (n,{y},D2)-derivable; then
A3: y in (m,D1)-derivables.X & z in (n,D2)-derivables.{y} by Def7;
X in bool Q
proof
assume not X in bool Q; then not X in dom (m,D1)-derivables; then
A4: (m,D1)-derivables.X = {} by FUNCT_1:def 2;
thus contradiction by A4,A2,Def7;
end; then reconsider SQ=X as Subset of Q;
reconsider yy=y as Element of Q by Def2,A2;
{yy} c= iter(O1,m).SQ & {z} c= iter(O2,n).{yy} by A3,ZFMISC_1:31; then
{z} c= iter (O3,m+n).SQ by Lm20,A1; then z in (m+n,D3)-derivables.X by
ZFMISC_1:31; hence thesis by Def7;
end;

Lm22: [t1,t2] in (X,D)-termEq iff <*TheEqSymbOf S*>^t1^t2 is (X,D)-provable
proof
set E=TheEqSymbOf S, R=(X,D)-termEq;
thus [t1,t2] in R implies <*E*>^t1^t2 is (X,D)-provable
proof
assume [t1,t2] in R; then consider t11,t22 being termal string
of S such that A1: [t11,t22]=[t1,t2] & <*E*>^t11^t22 is (X,D)-provable;
t11=t1 & t22=t2 & <*E*>^t11^t22 is (X,D)-provable by A1,XTUPLE_0:1;
hence thesis;
end;
assume <*E*>^t1^t2 is (X,D)-provable; hence thesis;
end;

Lm23: Sq`2 is wff string of S
proof
set Q=S-sequents; reconsider seqt=Sq as Element of Q by Def2;
seqt in Q; then consider premises being Subset of (AllFormulasOf S),
conclusion being wff string of S such that
A1: seqt=[premises,conclusion] & premises is finite;
thus Sq`2 is wff string of S by A1,MCART_1:7;
end;

Lm24: x is (X,D)-provable implies x is wff string of S
proof
set Q=S-sequents;
assume x is (X,D)-provable; then consider y such that
A1: y`1 c= X & y`2=x & {y} is D-derivable by Def13;
reconsider E={} as Subset of Q by XBOOLE_1:2;
{y} is ({},D)-derivable by A1; then consider mm such that
A2: y is (mm,E,D)-derivable by Lm8;
reconsider yy=y as Element of Q by Def2,A2;
yy`2 is wff string of S by Lm23; hence thesis by A1;
end;

Lm25: AllFormulasOf S is D-expanded
proof
set AF=AllFormulasOf S;
now
let x; assume x is (AF,D)-provable; then reconsider
xx=x as wff string of S by Lm24; consider m such that
A1: xx is m-wff by FOMODEL2:def 25;
xx in AF by A1; hence {x} c= AF by ZFMISC_1:31;
end;
hence thesis by Def16;
end;

registration
let S,D;
cluster D-expanded for (Subset of AllFormulasOf S);
existence
proof
set AF=AllFormulasOf S; reconsider AFF=AF as Subset of AF
by XBOOLE_0:def 10; take AFF; thus thesis by Lm25;
end;
end;

registration
let S,D;
cluster D-expanded for set;
existence
proof set AF=AllFormulasOf S; take the D-expanded Subset of AF;
thus thesis; end;
end;

::############################################################################
::# Encoding of modified Gentzen rules
definition
let Seqts be set; let S be Language; let seqt be S-null set;

pred seqt Rule0 Seqts means :Def18: seqt`2 in seqt`1; ::Def18 1

pred seqt Rule1 Seqts means :Def19: ex y being set st y in Seqts &
y`1 c= seqt`1 & seqt`2 = y`2;

pred seqt Rule2 Seqts means :Def20: seqt`1 is empty &
ex t being termal string of S st seqt`2 = <* TheEqSymbOf S *> ^ t ^ t;

pred seqt Rule3a Seqts means :Def21:
ex t,t1,t2 being termal string of S, x being set st
(x in Seqts & seqt`1 = x`1 \/ { <* TheEqSymbOf S *> ^ t1 ^ t2 } &
x`2 = <* TheEqSymbOf S *> ^ t ^ t1 & seqt`2 = <* TheEqSymbOf S *> ^ t ^ t2);

pred seqt Rule3b Seqts means :Def22: ::Def22 1
ex t1,t2 being termal string of S st seqt`1 = {<*TheEqSymbOf S*>^t1^t2} &
seqt`2 = <*TheEqSymbOf S*>^t2^t1;

pred seqt Rule3d Seqts means :Def23: ::Def24 1
ex s being low-compounding Element of S,
T,U being (abs(ar(s)))-element Element of (AllTermsOf S)* st
(s is operational & seqt`1=
{<*TheEqSymbOf S*>^(TT.j)^(UU.j) where j is Element of Seg abs(ar(s)),
TT,UU is Function of Seg abs(ar(s)), (AllSymbolsOf S)*\{{}} : TT=T & UU=U}
& seqt`2=<*TheEqSymbOf S*>^(s-compound(T))^(s-compound(U)));

pred seqt Rule3e Seqts means :Def24:
ex s being relational Element of S,
T,U being (abs(ar(s)))-element Element of (AllTermsOf S)* st
(seqt`1={s-compound(T)} \/
{<*TheEqSymbOf S*>^(TT.j)^(UU.j) where j is Element of Seg abs(ar(s)),
TT,UU is Function of Seg abs(ar(s)), (AllSymbolsOf S)*\{{}} : TT=T & UU=U}
& seqt`2=s-compound(U));

pred seqt Rule4 Seqts means :Def25:
ex l being literal Element of S, phi being wff string of S, t being
termal string of S st seqt`1={(l,t) SubstIn phi} & seqt`2=<*l*>^phi;

pred seqt Rule5 Seqts means :Def26: ex v1,v2 being
literal Element of S, x,p st
seqt`1=x \/ {<*v1*>^p} & v2 is (x\/{p}\/{seqt`2})-absent &
[x\/{(v1 SubstWith v2).p},seqt`2] in Seqts;

pred seqt Rule6 Seqts means :Def27: ::def28 1
ex y1,y2 being set,phi1, phi2 being wff string of S st y1 in Seqts &
y2 in Seqts & y1`1 = y2`1 & y2`1=seqt`1 &
y1`2= <*TheNorSymbOf S*> ^ phi1 ^ phi1 &
y2`2=  <*TheNorSymbOf S*> ^ phi2 ^ phi2 &
seqt`2 = <*TheNorSymbOf S*> ^ phi1 ^ phi2;

pred seqt Rule7 Seqts means :Def28:
ex y being set, phi1, phi2 being wff string of S st y in Seqts &
y`1 = seqt`1 & y`2 =<* TheNorSymbOf S*> ^ phi1 ^ phi2 &
seqt`2 = <* TheNorSymbOf S*> ^ phi2 ^ phi1;

pred seqt Rule8 Seqts means :Def29:
ex y1,y2 being set, phi,phi1,phi2 being wff string of S st y1 in Seqts &
y2 in Seqts & y1`1=y2`1 & y1`2=phi1 &
y2`2 = <* TheNorSymbOf S *> ^ phi1 ^ phi2 &
{phi}\/seqt`1=y1`1 & seqt`2= <* TheNorSymbOf S *> ^ phi ^ phi;

pred seqt Rule9 Seqts means :Def30:
ex y being set, phi being wff string of S st
y in Seqts & seqt`2=phi & y`1=seqt`1 & y`2=xnot (xnot phi);
end;

definition
let S be Language;
func P#0(S) -> Relation of bool (S-sequents), S-sequents means :Def31:
for Seqts being Element of bool (S-sequents), seqt being
Element of (S-sequents) holds [ Seqts, seqt ] in it iff seqt Rule0 Seqts;
existence
proof
defpred P[set, Element of S-sequents] means $2 Rule0 $1;
consider R being Relation of bool (S-sequents), S-sequents such that A1:
for x being Element of bool (S-sequents), y being Element of S-sequents holds
[x,y] in R iff P[x,y] from RELSET_1:sch 2;
take R;
thus thesis by A1;
end;
uniqueness
proof
defpred P[set, Element of S-sequents] means $2 Rule0 $1;
let IT1 be Relation of bool (S-sequents), S-sequents;
let IT2 be Relation of bool (S-sequents), S-sequents;
assume A2: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT1 iff P[x,y];
assume A3: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT2 iff P[x,y];
thus thesis from RELSET_1:sch 4(A2,A3);
end;

func P#1(S) -> Relation of bool (S-sequents), S-sequents means :Def32: ::def32
for Seqts being Element of bool (S-sequents), seqt being
Element of (S-sequents) holds [ Seqts, seqt ] in it iff seqt Rule1 Seqts;
existence
proof
defpred P[set, Element of S-sequents] means $2 Rule1 $1;
consider R being Relation of bool (S-sequents), S-sequents such that A4:
for x being Element of bool (S-sequents), y being Element of S-sequents holds
[x,y] in R iff P[x,y] from RELSET_1:sch 2;
take R;
thus thesis by A4;
end;
uniqueness
proof
defpred P[set, Element of S-sequents] means $2 Rule1 $1;
let IT1 be Relation of bool (S-sequents), S-sequents;
let IT2 be Relation of bool (S-sequents), S-sequents;
assume A5: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT1 iff P[x,y];
assume A6: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT2 iff P[x,y];
thus thesis from RELSET_1:sch 4(A5,A6);
end;

func P#2(S) -> Relation of bool (S-sequents), S-sequents means :Def33:
for Seqts being Element of bool (S-sequents), seqt being
Element of (S-sequents) holds [ Seqts, seqt ] in it iff seqt Rule2 Seqts;
existence
proof
defpred P[set, Element of S-sequents] means $2 Rule2 $1;
consider R being Relation of bool (S-sequents), S-sequents such that A7:
for x being Element of bool (S-sequents), y being Element of S-sequents holds
[x,y] in R iff P[x,y] from RELSET_1:sch 2;
take R;
thus thesis by A7;
end;
uniqueness
proof
defpred P[set, Element of S-sequents] means $2 Rule2 $1;
let IT1 be Relation of bool (S-sequents), S-sequents;
let IT2 be Relation of bool (S-sequents), S-sequents;
assume A8: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT1 iff P[x,y];
assume A9: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT2 iff P[x,y];
thus thesis from RELSET_1:sch 4(A8,A9);
end;

func P#3a(S) -> Relation of bool (S-sequents), S-sequents means :Def34:
for Seqts being Element of bool (S-sequents), seqt being
Element of (S-sequents) holds [ Seqts, seqt ] in it iff seqt Rule3a Seqts;
existence
proof
defpred P[set, Element of S-sequents] means $2 Rule3a $1;
consider R being Relation of bool (S-sequents), S-sequents such that A10:
for x being Element of bool (S-sequents), y being Element of S-sequents holds
[x,y] in R iff P[x,y] from RELSET_1:sch 2;
take R;
thus thesis by A10;
end;
uniqueness
proof
defpred P[set, Element of S-sequents] means $2 Rule3a $1;
let IT1 be Relation of bool (S-sequents), S-sequents;
let IT2 be Relation of bool (S-sequents), S-sequents;
assume A11: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT1 iff P[x,y];
assume A12: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT2 iff P[x,y];
thus thesis from RELSET_1:sch 4(A11,A12);
end;

func P#3b(S) -> Relation of bool (S-sequents), S-sequents means :Def35:
for Seqts being Element of bool (S-sequents), seqt being
Element of (S-sequents) holds [ Seqts, seqt ] in it iff seqt Rule3b Seqts;
existence
proof
defpred P[set, Element of S-sequents] means $2 Rule3b $1;
consider R being Relation of bool (S-sequents), S-sequents such that A13:
for x being Element of bool (S-sequents), y being Element of S-sequents holds
[x,y] in R iff P[x,y] from RELSET_1:sch 2;
take R;
thus thesis by A13;
end;
uniqueness
proof
defpred P[set, Element of S-sequents] means $2 Rule3b $1;
let IT1 be Relation of bool (S-sequents), S-sequents;
let IT2 be Relation of bool (S-sequents), S-sequents;
assume A14: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT1 iff P[x,y];
assume A15: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT2 iff P[x,y];
thus thesis from RELSET_1:sch 4(A14,A15);
end;

func P#3d(S) -> Relation of bool (S-sequents), S-sequents means :Def36:
for Seqts being Element of bool (S-sequents), seqt being ::Def37 1
Element of (S-sequents) holds [ Seqts, seqt ] in it iff seqt Rule3d Seqts;
existence
proof
defpred P[set, Element of S-sequents] means $2 Rule3d $1;
consider R being Relation of bool (S-sequents), S-sequents such that A16:
for x being Element of bool (S-sequents), y being Element of S-sequents
holds [x,y] in R iff P[x,y] from RELSET_1:sch 2;
take R;
thus thesis by A16;
end;
uniqueness
proof
defpred P[set, Element of S-sequents] means $2 Rule3d $1;
let IT1 be Relation of bool (S-sequents), S-sequents;
let IT2 be Relation of bool (S-sequents), S-sequents;
assume A17: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT1 iff P[x,y];
assume A18: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT2 iff P[x,y];
thus thesis from RELSET_1:sch 4(A17,A18);
end;

func P#3e(S) -> Relation of bool (S-sequents), S-sequents means :Def37:
for Seqts being Element of bool (S-sequents), seqt being
Element of (S-sequents) holds [ Seqts, seqt ] in it iff seqt Rule3e Seqts;
existence
proof
defpred P[set, Element of S-sequents] means $2 Rule3e $1;
consider R being Relation of bool (S-sequents), S-sequents such that A19:
for x being Element of bool (S-sequents), y being Element of S-sequents
holds [x,y] in R iff P[x,y] from RELSET_1:sch 2;
take R;
thus thesis by A19;
end;
uniqueness
proof
defpred P[set, Element of S-sequents] means $2 Rule3e $1;
let IT1 be Relation of bool (S-sequents), S-sequents;
let IT2 be Relation of bool (S-sequents), S-sequents;
assume A20: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT1 iff P[x,y];
assume A21: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT2 iff P[x,y];
thus thesis from RELSET_1:sch 4(A20,A21);
end;

func P#4(S) -> Relation of bool (S-sequents), S-sequents means :Def38:
for Seqts being Element of bool (S-sequents), seqt being
Element of (S-sequents) holds [ Seqts, seqt ] in it iff seqt Rule4 Seqts;
existence
proof
defpred P[set, Element of S-sequents] means $2 Rule4 $1;
consider R being Relation of bool (S-sequents), S-sequents such that A22:
for x being Element of bool (S-sequents), y being Element of S-sequents holds
[x,y] in R iff P[x,y] from RELSET_1:sch 2;
take R;
thus thesis by A22;
end;
uniqueness
proof
defpred P[set, Element of S-sequents] means $2 Rule4 $1;
let IT1 be Relation of bool (S-sequents), S-sequents;
let IT2 be Relation of bool (S-sequents), S-sequents;
assume A23: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT1 iff P[x,y];
assume A24: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT2 iff P[x,y];
thus thesis from RELSET_1:sch 4(A23,A24);
end;

func P#5(S) -> Relation of bool (S-sequents), S-sequents means :Def39:
for Seqts being Element of bool (S-sequents), seqt being
Element of (S-sequents) holds [ Seqts, seqt ] in it iff seqt Rule5 Seqts;
existence
proof
defpred P[set, Element of S-sequents] means $2 Rule5 $1;
consider R being Relation of bool (S-sequents), S-sequents such that A25:
for x being Element of bool (S-sequents), y being Element of S-sequents holds
[x,y] in R iff P[x,y] from RELSET_1:sch 2;
take R;
thus thesis by A25;
end;
uniqueness
proof
defpred P[set, Element of S-sequents] means $2 Rule5 $1;
let IT1 be Relation of bool (S-sequents), S-sequents;
let IT2 be Relation of bool (S-sequents), S-sequents;
assume A26: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT1 iff P[x,y];
assume A27: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT2 iff P[x,y];
thus thesis from RELSET_1:sch 4(A26,A27);
end;

func P#6(S) -> Relation of bool (S-sequents), S-sequents means :Def40:
for Seqts being Element of bool (S-sequents), seqt being ::def41 1
Element of (S-sequents) holds [ Seqts, seqt ] in it iff seqt Rule6 Seqts;
existence
proof
defpred P[set, Element of S-sequents] means $2 Rule6 $1;
consider R being Relation of bool (S-sequents), S-sequents such that A28:
for x being Element of bool (S-sequents), y being Element of S-sequents holds
[x,y] in R iff P[x,y] from RELSET_1:sch 2;
take R;
thus thesis by A28;
end;
uniqueness
proof
defpred P[set, Element of S-sequents] means $2 Rule6 $1;
let IT1 be Relation of bool (S-sequents), S-sequents;
let IT2 be Relation of bool (S-sequents), S-sequents;
assume A29: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT1 iff P[x,y];
assume A30: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT2 iff P[x,y];
thus thesis from RELSET_1:sch 4(A29,A30);
end;

func P#7(S) -> Relation of bool (S-sequents), S-sequents means :Def41:
for Seqts being Element of bool (S-sequents), seqt being
Element of (S-sequents) holds [ Seqts, seqt ] in it iff seqt Rule7 Seqts;
existence
proof
defpred P[set, Element of S-sequents] means $2 Rule7 $1;
consider R being Relation of bool (S-sequents), S-sequents such that A31:
for x being Element of bool (S-sequents), y being Element of S-sequents holds
[x,y] in R iff P[x,y] from RELSET_1:sch 2;
take R;
thus thesis by A31;
end;
uniqueness
proof
defpred P[set, Element of S-sequents] means $2 Rule7 $1;
let IT1 be Relation of bool (S-sequents), S-sequents;
let IT2 be Relation of bool (S-sequents), S-sequents;
assume A32: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT1 iff P[x,y];
assume A33: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT2 iff P[x,y];
thus thesis from RELSET_1:sch 4(A32,A33);
end;

func P#8(S) -> Relation of bool (S-sequents), S-sequents means :Def42:
for Seqts being Element of bool (S-sequents), seqt being
Element of (S-sequents) holds [ Seqts, seqt ] in it iff seqt Rule8 Seqts;
existence
proof
defpred P[set, Element of S-sequents] means $2 Rule8 $1;
consider R being Relation of bool (S-sequents), S-sequents such that A34:
for x being Element of bool (S-sequents), y being Element of S-sequents holds
[x,y] in R iff P[x,y] from RELSET_1:sch 2;
take R;
thus thesis by A34;
end;
uniqueness
proof
defpred P[set, Element of S-sequents] means $2 Rule8 $1;
let IT1 be Relation of bool (S-sequents), S-sequents;
let IT2 be Relation of bool (S-sequents), S-sequents;
assume A35: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT1 iff P[x,y];
assume A36: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT2 iff P[x,y];
thus thesis from RELSET_1:sch 4(A35,A36);
end;

func P#9(S) -> Relation of bool (S-sequents), S-sequents means :Def43:
for Seqts being Element of bool (S-sequents), seqt being
Element of (S-sequents) holds [ Seqts, seqt ] in it iff seqt Rule9 Seqts;
existence
proof
defpred P[set, Element of S-sequents] means $2 Rule9 $1;
consider R being Relation of bool (S-sequents), S-sequents such that A37:
for x being Element of bool (S-sequents), y being Element of S-sequents holds
[x,y] in R iff P[x,y] from RELSET_1:sch 2;
take R;
thus thesis by A37;
end;
uniqueness
proof
defpred P[set, Element of S-sequents] means $2 Rule9 $1;
let IT1 be Relation of bool (S-sequents), S-sequents;
let IT2 be Relation of bool (S-sequents), S-sequents;
assume A38: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT1 iff P[x,y];
assume A39: for x being Element of bool (S-sequents),
y being Element of S-sequents holds [x,y] in IT2 iff P[x,y];
thus thesis from RELSET_1:sch 4(A38,A39);
end;
end;

definition
let S;
let R be Relation of bool (S-sequents), S-sequents;
func FuncRule(R) -> Rule of S means :Def44:
for inseqs being set st inseqs in bool (S-sequents) holds it.inseqs =
{ x where x is Element of S-sequents : [inseqs, x] in R};
existence
proof
deffunc A(set) = { x where x is Element of S-sequents : [$1,x] in R};
A1: for inseqs being set holds A(inseqs) in (bool (S-sequents))
proof
let inseqs be set;
now
let x be set;
assume x in A(inseqs); then
consider seq being Element of S-sequents such that A2:
seq=x & [inseqs,seq] in R;
thus x in S-sequents by A2;
end;
then A(inseqs) c= S-sequents by TARSKI:def 3;
hence thesis;
end;
A3: for inseqs being set st inseqs in bool (S-sequents) holds
A(inseqs) in (bool (S-sequents)) by A1;
consider f being Function of bool (S-sequents),bool (S-sequents)
such that A4: for x being set st x in bool (S-sequents) holds
f.x = A(x) from FUNCT_2:sch 2(A3);
take f;
thus thesis by A4,FUNCT_2:8;
end;
uniqueness
proof
set Q=S-sequents; let IT1,IT2 be Rule of S;
deffunc F(set)={ x where x is Element of S-sequents : [$1, x] in R};
assume
A5: for inseqs being set st inseqs in bool (S-sequents) holds
IT1.inseqs = F(inseqs); assume
A6: for inseqs being set st inseqs in bool (S-sequents) holds
IT2.inseqs = F(inseqs);
for x st x in bool Q holds IT1.x=IT2.x
proof
let x; assume A7: x in bool Q; hence IT1.x=F(x) by A5 .= IT2.x by A6,A7;
end;
hence thesis by FUNCT_2:12;
end;
end;

Lm26: for R being Relation of bool (S-sequents), S-sequents holds
[Seqts, seqt] in R implies seqt in (FuncRule(R)).Seqts
proof
let R be Relation of bool (S-sequents), S-sequents;
A1: (FuncRule(R)).Seqts =
{ x where x is Element of S-sequents : [Seqts, x] in R} by Def44;
assume [Seqts, seqt] in R; hence thesis by A1;
end;

Lm27: for R being Relation of bool (S-sequents), S-sequents holds
[SQ, Sq] in R implies Sq is (1,SQ,{FuncRule(R)})-derivable
proof
set Q=S-sequents; let R be Relation of bool Q,Q;
set F=FuncRule(R), O=OneStep {F};
reconsider Seqts=SQ as Subset of Q by Def3;
reconsider seqt=Sq as Element of Q by Def2;
A1: F=O by Lm7 .= (1,{F})-derivables by FUNCT_7:70; assume
[SQ, Sq] in R; then seqt in (1,{F})-derivables.Seqts by A1,Lm26;
hence thesis by Def7;
end;

Lm28: for R being Relation of bool (S-sequents), S-sequents holds
(y in (FuncRule R).SQ iff (y in S-sequents & [SQ,y] in R))
proof
set Q=S-sequents; let R be Relation of bool Q, Q;
reconsider F=FuncRule R as Function of bool Q, bool Q;
reconsider Seqts=SQ as Element of (bool Q) by Def3;
set G={ x where x is Element of S-sequents : [Seqts, x] in R};
A1: F.Seqts=G by Def44;
A2: F.Seqts c= Q;
thus y in (FuncRule R).SQ implies (y in Q & [SQ,y] in R)
proof
assume
A3: y in (FuncRule R).SQ; thus y in Q by A2,A3;
consider x being Element of Q such that
A4: y=x & [Seqts,x] in R by A3,A1; thus thesis by A4;
end; assume
A5: y in Q & [SQ,y] in R; then reconsider seqt=y as Element of Q;
seqt in F.Seqts by Lm26,A5; hence thesis;
end;

Lm29: for R being Relation of bool (S-sequents), S-sequents holds
(y in (FuncRule R).X iff (y in S-sequents & [X,y] in R))
proof
set Q=S-sequents; let R be Relation of bool Q, Q;
reconsider F=FuncRule R as Function of bool Q, bool Q;
per cases;
suppose A1: not X in bool Q;
not X in dom F by A1;
hence thesis by A1,FUNCT_1:def 2,ZFMISC_1:87;
end;
suppose X in bool Q; then reconsider Seqts=X as Element of bool Q;
set SQ=Seqts;
(y in (FuncRule R).SQ iff (y in S-sequents & [SQ,y] in R)) by Lm28;
hence thesis;
end;
end;

definition let S;
func R#0(S) -> Rule of S equals FuncRule(P#0(S));
coherence;
func R#1(S) -> Rule of S equals FuncRule(P#1(S));
coherence;
func R#2(S) -> Rule of S equals FuncRule(P#2(S));
coherence;
func R#3a(S) -> Rule of S equals FuncRule(P#3a(S));
coherence;
func R#3b(S) -> Rule of S equals FuncRule(P#3b(S));
coherence;
func R#3d(S) -> Rule of S equals FuncRule(P#3d(S));
coherence;
func R#3e(S) -> Rule of S equals FuncRule(P#3e(S));
coherence;
func R#4(S) -> Rule of S equals FuncRule(P#4(S));
coherence;
func R#5(S) -> Rule of S equals FuncRule(P#5(S));
coherence;
func R#6(S) -> Rule of S equals FuncRule(P#6(S));
coherence;
func R#7(S) -> Rule of S equals FuncRule(P#7(S));
coherence;
func R#8(S) -> Rule of S equals FuncRule(P#8(S));
coherence;
func R#9(S) -> Rule of S equals FuncRule(P#9(S));
coherence;
end;

registration
let S; let t be termal string of S;
cluster {[{},<*TheEqSymbOf S*>^t^t]} -> {R#2(S)}-derivable for set;
coherence
proof
set E=TheEqSymbOf S, SS=AllSymbolsOf S, T=S-termsOfMaxDepth,
C=S-multiCat; reconsider phi=<*E*>^t^t as wff string of S by Lm2;
reconsider Seqts={} as Element of bool (S-sequents) by XBOOLE_1:2;
reconsider seqt=[{},phi] as Element of S-sequents;
seqt`1 is empty & seqt`2=<*E*>^t^t by MCART_1:7; then
seqt Rule2 {} by Def20; then [Seqts,seqt] in P#2(S) by Def33;
then seqt in (R#2(S)).Seqts by Lm26; then
{seqt} c= (R#2(S)).Seqts by ZFMISC_1:31; then
{seqt} is ({},{R#2(S)})-derivable by Lm19;hence thesis;
end;
end;

registration
let S;
cluster R#2(S) -> isotone for Rule of S;
coherence
proof
now
let Seqts1, Seqts2; set X=Seqts1, Y=Seqts2; assume X c= Y;
::# note this assumption remains unused here
set R=R#2(S), Q=S-sequents;
now
let x; assume
A1: x in R.X; then
A2: x in Q & [X,x] in P#2(S) by Lm29;
reconsider seqt=x as Element of Q by A1;
seqt Rule2 X by Def33,A2;
then seqt`1 is empty &
ex t being termal string of S st seqt`2 = <* TheEqSymbOf S *> ^ t ^ t
by Def20;
then seqt Rule2 Y by Def20; then [Y,seqt] in P#2(S) by Def33;
hence x in R.Y by Lm26;
end;
hence R.X c= R.Y by TARSKI:def 3;
end;
hence thesis by Def9;
end;
end;

Lm30: {R#2(S)} c= D implies (X,D)-termEq is total
proof
assume
A1:{R#2(S)} c= D;
set AT=AllTermsOf S, E=TheEqSymbOf S, Phi=X, R=(Phi,D)-termEq;
now
let x; assume x in AT; then reconsider t=x as termal string of S;
set phi=<*E*>^t^t, seqt=[{},phi];
{seqt} is ({},D)-derivable by A1,Lm18;
then phi is ({}\(Phi\{}),D)-provable by Def12; then
phi is (Phi\/{},D)-provable;
then [t,t] in (Phi,D)-termEq;
hence x in dom R by XTUPLE_0:def 12;
end;
then AT c= dom R by TARSKI:def 3;
then AT=dom R by XBOOLE_0:def 10; hence R is total by PARTFUN1:def 2;
end;

registration
let S;
cluster R#3b(S) -> isotone for Rule of S;
coherence
proof
now
let Seqts1, Seqts2; set X=Seqts1, Y=Seqts2; assume X c= Y;
::#note this assumption remains unused here
set R=R#3b(S), Q=S-sequents;
now
let x; assume
A1: x in R.X;
reconsider seqt=x as Element of Q by A1;
[X,seqt] in P#3b(S) by A1,Lm29; then
seqt Rule3b X by Def35;
then
ex t1,t2 being termal string of S st seqt`1 = {<*TheEqSymbOf S*>^t1^t2} &
seqt`2 = <*TheEqSymbOf S*>^t2^t1 by Def22;
then seqt Rule3b Y by Def22; then [Y,seqt] in P#3b(S) by Def35;
hence x in R.Y by Lm26;
end;
hence R.X c= R.Y by TARSKI:def 3;
end;
hence thesis by Def9;
end;
end;

Lm31:
{R#3b(S)} c= D & X is D-expanded implies (X,D)-termEq is symmetric
proof
set AT=AllTermsOf S, E=TheEqSymbOf S, Q=S-sequents, AF=AllFormulasOf S,
Phi=X, R=(X,D)-termEq;
assume A1: {R#3b(S)} c= D;
assume A2: Phi is D-expanded;
A3: field R c= AT\/AT by RELSET_1:8;
now
let x,y; assume x in field R & y in field R; then
reconsider tt1=x, tt2=y as Element of AT by A3;
reconsider t1=tt1, t2=tt2 as termal string of S;
reconsider phi1=<*E*>^t1^t2 as wff string of S by Lm2;
reconsider phi2=<*E*>^t2^t1 as wff string of S by Lm2;
reconsider seqt=[{phi1},phi2] as Element of S-sequents by Def2;
A4: seqt`1={phi1} & seqt`2 = phi2 by MCART_1:7;
reconsider Seqts={} as Element of bool Q by XBOOLE_1:2;
A5: seqt Rule3b {} by A4,Def22;
[Seqts,seqt] in P#3b(S) by A5,Def35; then
seqt in (R#3b(S)).Seqts by Lm26; then
{seqt} c= (R#3b(S)).Seqts by ZFMISC_1:31;
then {seqt} is ({},{R#3b(S)})-derivable by Lm19;
then {seqt} is ({},D)-derivable by A1,Lm18; then
A6: phi2 is ({phi1},D)-provable by Def12;
assume [x,y] in (Phi,D)-termEq; then consider
t11,t22 be termal string of S such that
A7: [x,y]=[t11,t22] & <*E*>^t11^t22 is (Phi,D)-provable;
t1=t11 & t2=t22 by A7,XTUPLE_0:1; then
{phi1} c= Phi by A2,Def16,A7;
hence [y,x] in (Phi,D)-termEq by A6;
end;
then R is_symmetric_in field R by RELAT_2:def 3;
hence thesis by RELAT_2:def 11;
end;

registration
let S; let t,t1,t2 be termal string of S;
let premises be finite (Subset of AllFormulasOf S);
cluster [premises\/{<*TheEqSymbOf S*>^t1^t2},<*TheEqSymbOf S*>^t^t2]
-> (1,{[premises,<*TheEqSymbOf S*>^t^t1]},{R#3a(S)})-derivable for set;
coherence
proof
set E=TheEqSymbOf S, AF=AllFormulasOf S;
reconsider phi0=<*E*>^t1^t2, phi1=<*E*>^t^t1, phi2=<*E*>^t^t2 as
0wff string of S by Lm2;
phi0 in AF; then
reconsider Phi0={phi0} as finite Subset of AF by ZFMISC_1:31;
reconsider prem2=premises \/ Phi0 as finite Subset of AF;
reconsider seqt2=[prem2,phi2], seqt1=[premises,phi1] as
Element of S-sequents by Def2;
reconsider Seqts={seqt1} as Subset of S-sequents;
A1:seqt1 in Seqts by TARSKI:def 1;
A2: seqt2`1=premises \/ {phi0} by MCART_1:7 .= (seqt1`1)\/{phi0} by MCART_1:7;
A3: seqt1`2=phi1 & seqt2`2=phi2 by MCART_1:7;
seqt2 Rule3a Seqts by A1,A2,A3,Def21; then [Seqts, seqt2] in P#3a(S) by Def34
; hence thesis by Lm27;
end;
end;

registration
let S; let t,t1,t2 be termal string of S, phi be wff string of S;
cluster [{phi,<*TheEqSymbOf S*>^t1^t2},<*TheEqSymbOf S*>^t^t2]
-> (1,{[{phi},<*TheEqSymbOf S*>^t^t1]},{R#3a(S)})-derivable for set;
coherence
proof
set AF=AllFormulasOf S, E=TheEqSymbOf S, allpremises={phi,<*E*>^t1^t2},
IT=[{phi,<*E*>^t1^t2},<*E*>^t^t2];
reconsider phii=phi as Element of AF by FOMODEL2:16;
reconsider premises={phii} as finite Subset of AF;
[premises\/{<*E*>^t1^t2}, <*E*>^t^t2] is
(1,{[premises,<*E*>^t^t1]},{R#3a(S)})-derivable; hence thesis by ENUMSET1:1;
end;
end;

registration
let S; let phi be wff string of S, Phi be finite Subset of AllFormulasOf S;
cluster [Phi \/ {phi}, phi] -> (1,{},{R#0(S)})-derivable for set;
coherence
proof
set Q=S-sequents;
reconsider Sq=[Phi \/ {phi}, phi] as Element of Q by Def2;
reconsider E={} as Subset of Q by XBOOLE_1:2;
A1: phi in {phi} & {phi} c= Phi\/{phi} by TARSKI:def 1,XBOOLE_1:7;
Sq`2=phi & Sq`1=Phi\/{phi} by MCART_1:7; then
Sq Rule0 E by Def18,A1; then [E,Sq] in P#0(S) by Def31; hence thesis by Lm27;
end;
end;

registration
let S; let phi1,phi2 be wff string of S;
cluster [{phi1,phi2},phi1] -> (1,{},{R#0(S)})-derivable for set;
coherence
proof
set AF=AllFormulasOf S;
reconsider phi11=phi1, phi22=phi2 as Element of AF by FOMODEL2:16;
reconsider Phi={phi22} as finite Subset of AF;
[Phi \/ {phi1}, phi1] is (1,{},{R#0(S)})-derivable;
hence thesis by ENUMSET1:1;
end;
end;

registration
let S,phi;
cluster [{phi},phi] -> (1,{},{R#0(S)})-derivable for set;
coherence
proof
set AF=AllFormulasOf S;
reconsider Phi={} as finite Subset of AF by XBOOLE_1:2;
[Phi\/{phi},phi] is (1,{},{R#0(S)})-derivable; hence thesis;
end;
end;

registration
let S; let phi be wff string of S;
cluster {[{phi}, phi]} -> ({},{R#0(S)})-derivable for set;
coherence by Lm12;
end;

registration
let S;
cluster R#0(S) -> isotone for Rule of S;
coherence
proof
now
let Seqts1, Seqts2; set X=Seqts1, Y=Seqts2; assume X c= Y;
::# note this assumption remains unused here
set R=R#0(S), Q=S-sequents;
now
let x; assume
A1: x in R.X;
reconsider seqt=x as Element of Q by A1;
[X,seqt] in P#0(S) by A1,Lm29; then
seqt Rule0 X by Def31; then
seqt`2 in seqt`1 by Def18; then seqt Rule0 Y by Def18;
then [Y,seqt] in P#0(S) by Def31;
hence x in R.Y by Lm26;
end;
hence R.X c= R.Y by TARSKI:def 3;
end;
hence thesis by Def9;
end;
cluster R#3a(S) -> isotone for Rule of S;
coherence
proof
now
let Seqts1, Seqts2; set X=Seqts1, Y=Seqts2; assume
A2: X c= Y;
set R=R#3a(S), Q=S-sequents;
now
let x; assume
A3: x in R.X;
reconsider seqt=x as Element of Q by A3;
[X,seqt] in P#3a(S) by A3,Lm29; then
seqt Rule3a X by Def34; then
consider t,t1,t2 being termal string of S, xx being set such that
A4:(xx in X & seqt`1 = xx`1 \/ { <* TheEqSymbOf S *> ^ t1 ^ t2 } &
xx`2 = <* TheEqSymbOf S *> ^ t ^ t1 & seqt`2 = <* TheEqSymbOf S *> ^ t ^ t2)
by Def21; seqt Rule3a Y by Def21,A4,A2; then
[Y,seqt] in P#3a(S) by Def34; hence x in R.Y by Lm26;
end;
hence R.X c= R.Y by TARSKI:def 3;
end;
hence thesis by Def9;
end;
cluster R#3d(S) -> isotone for Rule of S;
coherence
proof
now
let Seqts1, Seqts2; set X=Seqts1, Y=Seqts2; assume
X c= Y;
set R=R#3d(S), Q=S-sequents;
now
let x; assume
A5: x in R.X;
reconsider seqt=x as Element of Q by A5;
[X,seqt] in P#3d(S) by A5,Lm29; then
seqt Rule3d X by Def36; then
ex s being low-compounding Element of S,
T,U being (abs(ar(s)))-element Element of (AllTermsOf S)* st
(s is operational & seqt`1=
{<*TheEqSymbOf S*>^(TT.j)^(UU.j) where j is Element of Seg abs(ar(s)),
TT,UU is Function of Seg abs(ar(s)), (AllSymbolsOf S)*\{{}} : TT=T & UU=U}
& seqt`2=<*TheEqSymbOf S*>^(s-compound(T))^(s-compound(U))) by Def23;
then seqt Rule3d Y by Def23;
then [Y,seqt] in P#3d(S) by Def36;
hence x in R.Y by Lm26;
end;
hence R.X c= R.Y by TARSKI:def 3;
end;
hence thesis by Def9;
end;
cluster R#3e(S) -> isotone for Rule of S;
coherence
proof
now
let Seqts1, Seqts2; set X=Seqts1, Y=Seqts2; assume
X c= Y;
set R=R#3e(S), Q=S-sequents;
now
let x; assume
A6: x in R.X;
reconsider seqt=x as Element of Q by A6;
[X,seqt] in P#3e(S) by A6,Lm29; then
seqt Rule3e X by Def37; then
ex s being relational Element of S,
T,U being (abs(ar(s)))-element Element of (AllTermsOf S)* st
(seqt`1={s-compound(T)} \/
{<*TheEqSymbOf S*>^(TT.j)^(UU.j) where j is Element of Seg abs(ar(s)),
TT,UU is Function of Seg abs(ar(s)), (AllSymbolsOf S)*\{{}} : TT=T & UU=U}
& seqt`2=s-compound(U)) by Def24;
then seqt Rule3e Y by Def24;
then [Y,seqt] in P#3e(S) by Def37;
hence x in R.Y by Lm26;
end;
hence R.X c= R.Y by TARSKI:def 3;
end;
hence thesis by Def9;
end;
let K1,K2;
cluster K1\/K2 -> isotone for RuleSet of S;
coherence
proof
set D=K1\/K2;
A7: K1 c= D & K2 c= D by XBOOLE_1:7;
for Seqts1,Seqts2,f st
Seqts1 c= Seqts2 & f in D ex g st g in D & f.Seqts1 c= g.Seqts2
proof
let Seqts1, Seqts2, f; set X=Seqts1, Y=Seqts2; assume
A8: X c= Y & f in D;
per cases;
suppose f in K1; then consider g such that
A9: g in K1 & f.X c= g.Y by A8,Def10; take g;
thus g in D & f.X c= g.Y by A9,A7;
end;
suppose not f in K1; then f in K2 by A8,XBOOLE_0:def 3; then
consider g such that
A10: g in K2 & f.X c= g.Y by A8,Def10; take g;
thus g in D & f.X c= g.Y by A10,A7;
end;
end;
hence thesis by Def10;
end;
end;

Lm32:
{R#0(S)}\/{R#3a(S)} c= D & X is D-expanded implies (X,D)-termEq is transitive
proof
set AT=AllTermsOf S, E=TheEqSymbOf S, Q=S-sequents, AF=AllFormulasOf S,
Phi=X, R=(X,D)-termEq;
reconsider Seqts={} as Element of bool Q by XBOOLE_1:2; assume
A1: {R#0(S)}\/{R#3a(S)} c= D; assume
A2: Phi is D-expanded;
A3: field R c= AT\/AT by RELSET_1:8;
now
let x,y,z; assume x in field R & y in field R & z in field R; then
reconsider tt1=x, tt2=y, tt3=z as Element of AT by A3;
reconsider t1=tt1, t2=tt2, t3=tt3 as termal string of S;
reconsider phi1=<*E*>^t1^t2 as wff string of S by Lm2;
reconsider phi2=<*E*>^t2^t3 as wff string of S by Lm2;
reconsider phi3=<*E*>^t1^t3 as wff string of S by Lm2;
[{phi1,<*E*>^t2^t3},<*E*>^t1^t3] is
(1,{[{phi1},<*E*>^t1^t2]},{R#3a(S)})-derivable; then
A4: [{phi1,phi2},phi3] is (1,{[{phi1},phi1]},{R#3a(S)})-derivable;
[{phi1,phi2},phi3] is (1+1,{},{R#0(S)}\/{R#3a(S)})-derivable by A4,Lm21; then
{[{phi1,phi2},phi3]} is ({},{R#0(S)}\/{R#3a(S)})-derivable by Lm12;
then {[{phi1,phi2},phi3]} is ({},D)-derivable by Lm18,A1; then
A5: {phi1,phi2}={phi1} \/ {phi2} & phi3 is ({phi1,phi2},D)-provable
by Def12,ENUMSET1:1; assume [x,y] in R & [y,z] in R; then
phi1 is (Phi,D)-provable & phi2 is (Phi,D)-provable by Lm22; then
reconsider Phi1={phi1}, Phi2={phi2} as Subset of Phi by A2,Def16;
reconsider Phi3=Phi1\/Phi2 as Subset of Phi;
phi3 is (Phi3,D)-provable by A5; hence [x,z] in (Phi,D)-termEq;
end;
then R is_transitive_in field R by RELAT_2:def 8;
hence thesis by RELAT_2:def 16;
end;

Lm33: {R#0(S),R#3a(S)} c= D & {R#2(S),R#3b(S)} c= D & X is D-expanded implies
(X,D)-termEq is Equivalence_Relation of (AllTermsOf S)
proof
A1: {R#2(S)} c= {R#2(S),R#3b(S)} & {R#3b(S)} c= {R#2(S),R#3b(S)} by ZFMISC_1:7;
assume {R#0(S),R#3a(S)} c= D; then
A2: {R#0(S)}\/{R#3a(S)} c= D by ENUMSET1:1;
assume {R#2(S),R#3b(S)} c= D; then
A3: {R#2(S)} /\ D = {R#2(S)} & {R#3b(S)} /\ D={R#3b(S)} by A1,XBOOLE_1:1,28;
assume
A4: X is D-expanded; set R=(X,D)-termEq;
thus thesis by Lm30,Lm32,A2,A4,Lm31,A3;
end;

registration
let S; let t1,t2 be termal string of S;
cluster <*TheEqSymbOf S*>^t1^t2 -> 0-wff for string of S;
coherence by Lm2;
end;

definition
let S; let m be non zero Nat;
let T,U be m-element (Element of ((AllTermsOf S)*));
func PairWiseEq (T,U) equals
{<*TheEqSymbOf S*>^(TT.j)^(UU.j) where j is Element of Seg m,
TT,UU is Function of Seg m, (AllSymbolsOf S)*\{{}} : TT=T & UU=U};
coherence;
end;

definition
let S; let m be non zero Nat, T1,T2 be m-element Element of ((AllTermsOf S)*);
redefine func PairWiseEq (T1,T2) -> Subset of AllFormulasOf S;
coherence
proof
set P=PairWiseEq (T1,T2), SS=AllSymbolsOf S, E=TheEqSymbOf S,
AT=AllTermsOf S, AF=AllFormulasOf S;
now
let x; assume x in P; then consider
j being Element of Seg m, T11,T22 being Function of Seg m,SS*\{{}}
such that A1: x=<*E*>^T11.j^T22.j & T11=T1 & T22=T2;
m-tuples_on AT = Funcs(Seg m, AT) by FOMODEL0:11; then
T1 is Element of Funcs(Seg m,AT) & T2 is Element of Funcs(Seg m,AT)
by FOMODEL0:16; then reconsider T111=T1, T222=T2 as Function of Seg m, AT;
T111.j is Element of AT & T222.j is Element of AT; then
reconsider t1=T111.j, t2=T222.j as  string of S; reconsider
w=<*E*>^t1^t2 as 0-wff string of S; w in AF; hence x in AF by A1;
end;
hence thesis by TARSKI:def 3;
end;
end;

registration
let S; let m be non zero Nat;
let T,U be m-element (Element of ((AllTermsOf S)*));
cluster PairWiseEq(T,U) -> finite;
coherence
proof
set AT=AllTermsOf S, E=TheEqSymbOf S, SS=AllSymbolsOf S;
T in m-tuples_on AT & U in m-tuples_on AT by FOMODEL0:16; then
T is Element of Funcs (Seg m, AT) & U is Element of Funcs (Seg m,AT)
by FOMODEL0:11; then reconsider TT=T, UU=U as Function of Seg m, AT;
deffunc F(Element of Seg m)=<*E*>^(TT.$1)^(UU.$1);
set IT={F(j) where j is Element of Seg m:j in Seg m};
A1: Seg m is finite; IT is finite from FRAENKEL:sch 21(A1); then
reconsider ITT=IT as finite set;
now
let x; assume x in PairWiseEq (T,U); then consider
j be Element of Seg m, TTT,UUU be Function of Seg m, SS*\{{}}
such that A2: x=<*E*>^TTT.j^UUU.j & TTT=T & UUU=U;
thus x in IT by A2;
end;
then reconsider Y=PairWiseEq(T,U) as Subset of ITT by TARSKI:def 3;
Y is finite; hence thesis;
end;
end;

Lm34: for s being low-compounding Element of S,
T,U being abs(ar(s))-element Element of (AllTermsOf S)* st s is termal
holds
{[PairWiseEq(T,U), <*TheEqSymbOf S*>^(s-compound(T))^(s-compound(U))]}
is ({},{R#3d(S)})-derivable
proof
let s be low-compounding Element of S; set m=abs(ar(s)),
AT=AllTermsOf S, E=TheEqSymbOf S;
let T,U be m-element Element of AT*;
assume s is termal; then reconsider ss=s as termal Element of S;
reconsider t1=ss-compound(T), t2=ss-compound(U) as termal string of S;
reconsider conclusion=<*E*>^t1^t2 as wff string of S; reconsider
seqt=[PairWiseEq(T,U),conclusion] as Element of S-sequents by Def2;
reconsider Seqts={} as Subset of S-sequents by XBOOLE_1:2; ss is termal;then
A1: s is operational &
seqt`1=PairWiseEq(T,U) & seqt`2=<*E*>^(s-compound(T))^(s-compound(U))
by MCART_1:7; seqt Rule3d Seqts by A1,Def23; then
[Seqts,seqt] in P#3d(S) by Def36; then seqt in (R#3d(S)).Seqts by Lm26;
then {seqt} c= (R#3d(S)).Seqts by ZFMISC_1:31;
hence thesis by Lm19;
end;

Lm35: for s being relational Element of S,
T1,T2 being abs(ar(s))-element Element of (AllTermsOf S)* holds
{[PairWiseEq(T1,T2)\/{s-compound(T1)},s-compound(T2)]}
is ({},{R#3e(S)})-derivable
proof
let s be relational Element of S; set m=abs(ar(s)),
AT=AllTermsOf S, E=TheEqSymbOf S, AF=AllFormulasOf S;
let T1,T2 be m-element Element of AT*; reconsider
w1=s-compound(T1), conclusion=s-compound(T2) as 0-wff string of S;
w1 in AF; then reconsider w11=w1 as Element of AF;
reconsider premises=PairWiseEq(T1,T2)\/{w11} as Subset of AF; reconsider
seqt=[premises,conclusion] as Element of S-sequents by Def2;
reconsider Seqts={} as Subset of S-sequents by XBOOLE_1:2;
seqt`1={s-compound(T1)}\/PairWiseEq(T1,T2) & seqt`2=s-compound(T2)
by MCART_1:7; then seqt Rule3e Seqts by Def24; then
[Seqts,seqt] in P#3e(S) by Def37; then seqt in (R#3e(S)).Seqts by Lm26;
then {seqt} c= (R#3e(S)).Seqts by ZFMISC_1:31;
hence thesis by Lm19;
end;

registration
let S; let s be relational Element of S;
let T1,T2 be abs(ar(s))-element Element of (AllTermsOf S)*;
cluster {[PairWiseEq(T1,T2)\/{s-compound(T1)},s-compound(T2)]} ->
({},{R#3e(S)})-derivable;
coherence by Lm35;
end;

Lm36: for s being low-compounding Element of S holds
(X is D-expanded & [x1,x2] in abs(ar(s))-placesOf (X,D)-termEq)
implies ex T,U being abs(ar(s))-element Element of (AllTermsOf S)* st
(T=x1 & U=x2 & PairWiseEq(T,U) c= X )
proof
let s be low-compounding Element of S;
set n=abs(ar(s)), AT=AllTermsOf S, E=TheEqSymbOf S, Phi=X,
f=S-cons, SS=AllSymbolsOf S, R=(Phi,D)-termEq, SS=AllSymbolsOf S;
assume A1: Phi is D-expanded;
assume [x1,x2] in n-placesOf R; then
consider p,q being Element of n-tuples_on AT such that A2:
[x1,x2]=[p,q] & for i being set st i in Seg n holds [p.i,q.i] in R;
A3: p=x1 & q=x2 by A2,XTUPLE_0:1;
reconsider T1=x1, T2=x2 as Element of n-tuples_on AT by A2,XTUPLE_0:1;
reconsider T11=T1, T22=T2 as n-element Element of AT* by FINSEQ_1:def 11;
take T=T11, U=T22; thus T=x1 & U=x2; set Z=PairWiseEq(T,U);
T1 is Element of Funcs(Seg n, AT) & T2 is Element of Funcs(Seg n, AT) by
FOMODEL0:11; then reconsider T111=T1, T222=T2 as Function of Seg n, AT;
now
let z; assume z in Z; then
consider j be Element of Seg n, TT,UU be Function of Seg n, SS*\{{}}
such that A4: z=<*E*>^(TT.j)^(UU.j) & TT=T11 & UU=T22;
reconsider t11=T111.j, t22=T222.j as Element of AT;
reconsider t1=t11, t2=t22 as termal string of S;
[T111.j,T222.j] in R by A2,A3; then
<*E*>^t1^t2 is (Phi,D)-provable by Lm22; then
{<*E*>^t1^t2} c= Phi by A1,Def16;
hence z in Phi by A4,ZFMISC_1:31;
end;
hence Z c= Phi by TARSKI:def 3;
end;

Lm37: for s being low-compounding Element of S holds {R#3d(S)} c= D &
X is D-expanded & s is termal implies X-freeInterpreter(s) is
((X,D)-termEq)-respecting
proof
let s be low-compounding Element of S;
set n=abs(ar(s)), AT=AllTermsOf S, E=TheEqSymbOf S, Phi=X,
R=(Phi,D)-termEq, I=X-freeInterpreter(s); assume
A1: {R#3d(S)} c= D; assume
A2: Phi is D-expanded; assume s is termal; then reconsider ss=s as
termal Element of S;
A3: not ss is relational;
now
let x1,x2; assume [x1,x2] in n-placesOf R;
then consider T1,T2 being n-element Element of AT* such that
A4: T1=x1 & T2=x2 & PairWiseEq(T1,T2) c= X by Lm36,A2;
set Z=PairWiseEq(T1,T2); reconsider
t1 = ss-compound(T1), t2 = ss-compound(T2) as termal string of S;
reconsider ZZ=Z as Subset of Phi by A4;
{[Z,<*E*>^t1^t2]} is ({},{R#3d(S)})-derivable by Lm34; then
A5: {[Z,<*E*>^t1^t2]} is ({},D)-derivable by A1,Lm18;
A6: <*E*>^t1^t2 is (ZZ,D)-provable by A5,Def12;
I.T1=t1 & I.T2=t2 by FOMODEL3:6; hence [I.x1,I.x2] in R by A6,A4;
end;
then I is (n-placesOf R,R)-respecting by FOMODEL3:def 9; hence
I is R-respecting by A3,FOMODEL3:def 10;
end;

Lm38: {R#3e(S)} c= D &
X is D-expanded & [x1,x2] in abs(ar(r))-placesOf ((X,D)-termEq) &
r-compound.x1 in X implies r-compound.x2 in X
proof
set s=r, n=abs(ar(s)), AT=AllTermsOf S, E=TheEqSymbOf S, Phi=X,
f=s-compound, R=(Phi,D)-termEq;
assume A1: {R#3e(S)} c= D;
assume A2: Phi is D-expanded;
assume [x1,x2] in n-placesOf R;
then consider T1,T2 being n-element Element of AT* such that
A3: T1=x1 & T2=x2 & PairWiseEq(T1,T2) c= X by Lm36,A2;
set Z=PairWiseEq(T1,T2);
reconsider w1=s-compound(T1), w2=s-compound(T2) as 0-wff string of S;
A4: f.x1=w1 & f.x2=w2 by A3,FOMODEL3:def 2;
assume f.x1 in X;
then reconsider X1={w1} as Subset of X by A4,ZFMISC_1:31;
reconsider ZZ=Z as Subset of Phi by A3;
reconsider ZZZ=ZZ \/ X1 as Subset of X;
{[Z\/{s-compound(T1)},s-compound(T2)]} is ({},{R#3e(S)})-derivable;
then {[ZZZ,w2]} is ({},D)-derivable by Lm18,A1; then
w2 is (ZZZ,D)-provable by Def12; then
{w2} c= Phi by A2,Def16; hence thesis by A4,ZFMISC_1:31;
end;

Lm39: {R#2(S)}/\D={R#2(S)} & {R#3b(S)}/\D={R#3b(S)} & D/\{R#3e(S)}={R#3e(S)} &
X is D-expanded & [x1,x2] in abs(ar(r))-placesOf ((X,D)-termEq) implies
(r-compound.x1 in X iff r-compound.x2 in X)
proof
set s=r, n=abs(ar(s)), AT=AllTermsOf S, E=TheEqSymbOf S, Phi=X,
f=s-compound, R=(X,D)-termEq; assume
A1: {R#2(S)}/\D={R#2(S)} & {R#3b(S)}/\D={R#3b(S)} &
D/\{R#3e(S)}={R#3e(S)} & X is D-expanded &
[x1,x2] in n-placesOf R;
then reconsider Rr=R as symmetric total Relation of AT by Lm30,Lm31;
thus f.x1 in X implies f.x2 in X by A1,Lm38; reconsider RR =
n-placesOf Rr as symmetric total Relation of n-tuples_on AT; [x2,x1] in RR
by A1,EQREL_1:6; hence f.x2 in X implies f.x1 in X by A1,Lm38;
end;

Lm40: for x,y being Element of U st x in Y iff y in Y
holds [(chi(Y,U)).x, (chi(Y,U)).y] in (id BOOLEAN)
proof
let x,y be Element of U; set f=chi(Y,U);
assume A1: x in Y iff y in Y;
per cases;
suppose x in Y; then f.x=1 & y in Y by A1,RFUNCT_1:63; then
f.x=1 & f.y=1 & 1 in BOOLEAN by RFUNCT_1:63; hence thesis by RELAT_1:def 10;
end;
suppose not x in Y; then f.x=0 & not y in Y by A1,RFUNCT_1:64; then
f.x=0 & f.y=0 & 0 in BOOLEAN by RFUNCT_1:64; hence thesis by RELAT_1:def 10;
end;
end;

Lm41: {R#2(S)}/\D={R#2(S)} & {R#3b(S)}/\D={R#3b(S)} & D/\{R#3e(S)}={R#3e(S)} &
X is D-expanded implies X-freeInterpreter(r) is ((X,D)-termEq)-respecting
proof
assume A1: {R#2(S)}/\D={R#2(S)} & {R#3b(S)}/\D={R#3b(S)} &
D/\{R#3e(S)}={R#3e(S)} & X is D-expanded;
set  AT=AllTermsOf S, R=(X,D)-termEq,
I=X-freeInterpreter(r), AF=AtomicFormulasOf S, ch=chi(X,AF),
SS=AllSymbolsOf S;
set g=r-compound, m=abs(ar(r));
now
let x1,x2; assume A2: [x1,x2] in m-placesOf R;
then consider T1,T2 being m-element Element of AT* such that A3:
T1=x1 & T2=x2 & PairWiseEq(T1,T2) c= X by Lm36,A1;
reconsider w1=r-compound(T1), w2=r-compound(T2) as 0-wff string of S;
w1 in AF & w2 in AF; then reconsider w11=w1, w22=w2 as Element of AF;
A4: g.x1=w11 & g.x2=w22 by A3,FOMODEL3:def 2;
w11 in X iff w22 in X by A4,A1,A2,Lm39; then
[ch.w1,ch.w2] in id BOOLEAN & I.T1=ch.w1 & I.T2=ch.w2 by Lm40,FOMODEL3:6;
hence [I.x1, I.x2] in (id BOOLEAN) by A3;
end;
then I is (m-placesOf R, id BOOLEAN)-respecting by FOMODEL3:def 9;
hence thesis by FOMODEL3:def 10;
end;

Lm42: for R being total reflexive (Relation of U),
f being Function of X,U st x in X holds f is ({[x,x]},R)-respecting
proof
let R be total reflexive Relation of U; let f be Function of X,U;
reconsider E={[x,x]} as Relation;
assume A1: x in X; then reconsider XX=X as non empty set;
reconsider ff=f as Function of XX,U;
now
let x1,x2 be set;
assume [x1,x2] in E; then
A2: [x1,x2] = [x,x] by TARSKI:def 1; then
A3: x1=x & x2=x by XTUPLE_0:1;
reconsider x11=x1, x22=x2 as Element of XX by A1,A2,XTUPLE_0:1;
ff.x11 in U & ff.x22 in U & ff.x11=ff.x22 by A3; hence
[f.x1, f.x2] in R by EQREL_1:5;
end;
hence thesis by FOMODEL3:def 9;
end;

Lm43: for E being total reflexive (Relation of U),
f being Interpreter of l,U holds f is E-respecting
proof
let E being total reflexive Relation of U;
reconsider m=abs(ar(l)) as zero Nat; let f be Interpreter of l,U;
m-tuples_on U={{}} by FOMODEL0:10;
then reconsider ff=f as Function of {{}},U by FOMODEL2:def 2;
{} in {{}} by TARSKI:def 1;then ff is ({[{},{}]},E)-respecting by Lm42;
then f is (m-placesOf E,E)-respecting; hence thesis by FOMODEL3:def 10;
end;

Lm44: {R#0(S),R#3a(S)} c= D & {R#2(S),R#3b(S)} c= D & X is D-expanded implies
X-freeInterpreter(l) is ((X,D)-termEq)-respecting
proof
set AT=AllTermsOf S, I=X-freeInterpreter(l);
assume {R#0(S),R#3a(S)} c= D & {R#2(S),R#3b(S)} c= D & X is D-expanded;
then reconsider R=(X,D)-termEq as Equivalence_Relation of AT by Lm33;
I is R-respecting by Lm43;
hence thesis;
end;

Lm45: {R#0(S),R#3a(S)} c= D &
D/\{R#3d(S)}={R#3d(S)} & {R#2(S)}/\D={R#2(S)} & {R#3b(S)}/\D={R#3b(S)} &
D/\{R#3e(S)}={R#3e(S)} & X is D-expanded implies
X-freeInterpreter(a) is ((X,D)-termEq)-respecting
proof
set s=a, AT=AllTermsOf S, I=X-freeInterpreter(s), AF=AtomicFormulasOf S,
ch=chi(X,AF), SS=AllSymbolsOf S, n=abs(ar(s)), f=s-compound, R=(X,D)-termEq;
assume A1: {R#0(S),R#3a(S)} c= D & D/\{R#3d(S)}={R#3d(S)} &
{R#2(S)}/\D={R#2(S)}
& {R#3b(S)}/\D={R#3b(S)} & D/\{R#3e(S)}={R#3e(S)} & X is D-expanded; then
reconsider S2={R#2(S)}, S3={R#3b(S)} as Subset of D;
A2: S2\/S3 c= D;
per cases;
suppose not s is relational; then reconsider ss=s as termal Element of S;
per cases;
suppose ss is literal; then reconsider l=ss as literal Element of S;
{R#2(S),R#3b(S)} c= D by A2,ENUMSET1:1; then
X-freeInterpreter(l) is R-respecting by Lm44,A1; hence thesis;
end;
suppose ss is non literal; then
reconsider sss=ss as low-compounding Element of S;
X-freeInterpreter(sss) is R-respecting by Lm37,A1; hence thesis;
end;
end;
suppose s is relational;then reconsider r=s as relational Element of S;
X-freeInterpreter(r) is R-respecting by Lm41,A1; hence thesis;
end;
end;

definition
let m,S,D;
attr D is m-ranked means :Def59: ::def58 1
R#0(S) in D & R#2(S) in D & R#3a(S) in D & R#3b(S) in D if m=0,
R#0(S) in D & R#2(S) in D & R#3a(S) in D & R#3b(S) in D
& R#3d(S) in D & R#3e(S) in D if m=1,
R#0(S) in D & R#1(S) in D & R#2(S) in D & R#3a(S) in D & R#3b(S) in D
& R#3d(S) in D & R#3e(S) in D & R#4(S) in D & R#5(S) in D & R#6(S) in D &
R#7(S) in D & R#8(S) in D if m=2 otherwise D={};
consistency;
end;

registration
let S;
cluster 1-ranked -> 0-ranked for RuleSet of S;
coherence
proof
let D be RuleSet of S; assume D is 1-ranked; then
R#0(S) in D & R#2(S) in D & R#3a(S) in D & R#3b(S) in D by Def59;
hence thesis by Def59;
end;
cluster 2-ranked -> 1-ranked for RuleSet of S;
coherence
proof
let D be RuleSet of S; assume D is 2-ranked; then
R#0(S) in D & R#2(S) in D & R#3a(S) in D & R#3b(S) in D
& R#3d(S) in D & R#3e(S) in D by Def59; hence thesis by Def59;
end;
end;

definition
let S;
func S-rules -> RuleSet of S equals
{R#0(S), R#1(S), R#2(S), R#3a(S), R#3b(S), R#3d(S), R#3e(S), R#4(S)} \/
{R#5(S), R#6(S), R#7(S), R#8(S)};
coherence;
end;

registration let S;
cluster S-rules -> 2-ranked for RuleSet of S;
coherence
proof
set A={R#0(S), R#1(S), R#2(S), R#3a(S), R#3b(S), R#3d(S), R#3e(S), R#4(S)},
B={R#5(S),R#6(S),R#7(S), R#8(S)}, C=A\/B;
R#0(S) in A & R#1(S) in A & R#2(S) in A & R#3a(S) in A & R#3b(S) in A
& R#3d(S) in A & R#3e(S) in A & R#4(S) in A & R#5(S) in B & R#6(S) in B &
R#7(S) in B & R#8(S) in B by ENUMSET1:def 2,def 6; then
R#0(S) in C & R#1(S) in C & R#2(S) in C & R#3a(S) in C & R#3b(S) in C
& R#3d(S) in C & R#3e(S) in C & R#4(S) in C & R#5(S) in C & R#6(S) in C &
R#7(S) in C & R#8(S) in C by XBOOLE_0:def 3;
hence thesis by Def59;
end;
end;

registration let S;
cluster 2-ranked for RuleSet of S;
existence proof take S-rules; thus thesis; end;
end;

registration let S;
cluster 1-ranked for RuleSet of S;
existence proof take the 2-ranked RuleSet of S; thus thesis; end;
end;

registration let S;
cluster 0-ranked for RuleSet of S;
existence proof take the 1-ranked RuleSet of S; thus thesis; end;
end;

Lm46:
D is 1-ranked & X is D-expanded implies
X-freeInterpreter(a) is ((X,D)-termEq)-respecting
proof
assume
A1: D is 1-ranked; then R#0 S in D & R#3a S in D by Def59; then
{R#0(S)} c= D & {R#3a(S)} c= D by ZFMISC_1:31; then
{R#0(S)} \/ {R#3a(S)} c= D by XBOOLE_1:8; then
A2: {R#0 S,R#3a S} c= D by ENUMSET1:1;
R#3d S in D & R#2 S in D & R#3b S in D & R#3e S in D by A1,Def59; then
{R#3d S} c= D & {R#2 S} c= D & {R#3b S} c= D & {R#3e S} c= D by ZFMISC_1:31;
then
A3: D/\{R#3d S}={R#3d S} & D/\{R#2 S}={R#2 S} & D/\{R#3b S}={R#3b S}
& D/\{R#3e S}={R#3e S} by XBOOLE_1:28; assume
X is D-expanded; hence thesis by Lm45,A2,A3;
end;

registration
let S; let D be 1-ranked RuleSet of S; let X be D-expanded set; let a;
cluster X-freeInterpreter(a) -> ((X,D)-termEq)-respecting for Interpreter of a
,AllTermsOf S;
coherence by Lm46;
end;

Lm47: D is 0-ranked & X is D-expanded implies
(X,D)-termEq is Equivalence_Relation of (AllTermsOf S)
proof
assume D is 0-ranked; then
R#0 S in D & R#3a S in D & R#2 S in D & R#3b S in D by Def59; then
{R#0(S)} c= D & {R#3a(S)} c= D & {R#2 S} c= D & {R#3b S} c= D
by ZFMISC_1:31; then {R#0(S)} \/ {R#3a(S)} c= D
& {R#2 S} \/ {R#3b S} c= D by XBOOLE_1:8; then
A1: {R#0 S,R#3a S} c= D & {R#2 S, R#3b S} c= D by ENUMSET1:1;
assume X is D-expanded; hence thesis by A1,Lm33;
end;

registration
let S; let D be 0-ranked RuleSet of S; let X be D-expanded set;
cluster ((X,D)-termEq) ->
total symmetric transitive for Relation of (AllTermsOf S);
coherence by Lm47;
end;

registration let S;
cluster 1-ranked for 0-ranked RuleSet of S;
existence
proof
set D = the 1-ranked RuleSet of S;
reconsider DD=D as 0-ranked RuleSet of S; take DD; thus thesis;
end;
end;

theorem D1 c= D2 & (D2 is isotone or D1 is isotone) &
Y is (X,D1)-derivable implies Y is (X,D2)-derivable by Lm18;

registration let S, Sq;
cluster {Sq} -> S-sequents-like;
coherence
proof
set Q=S-sequents; Sq in Q by Def2; then {Sq} c= Q by ZFMISC_1:31;
hence thesis;
end;
end;

registration
let S,SQ1,SQ2;
cluster SQ1\/SQ2 -> S-sequents-like for set;
coherence
proof
set Q=S-sequents; reconsider X=SQ1, Y=SQ2 as Subset of Q by Def3;
X\/Y c= Q; hence thesis;
end;
end;

registration
let S; let x,y be S-sequent-like set;
cluster {x,y} -> S-sequents-like for set;
coherence proof {x,y}={x}\/{y} by ENUMSET1:1; hence thesis; end;
end;

Lm48: (D1\/D2 is isotone & D1\/D2\/D3 is isotone &
x is (m,SQ1,D1)-derivable & y is (m,SQ2,D2)-derivable &
z is (n,{x,y},D3)-derivable)
implies z is (m+n,SQ1\/SQ2,D1\/D2\/D3)-derivable
proof
set Q=S-sequents, D=D1\/D2, O1=OneStep D1, O2=OneStep D2, O3=OneStep D3,
O=OneStep D, OO=OneStep(D\/D3); reconsider X=SQ1, Y=SQ2 as Subset of Q
by Def3; set Z=X\/Y; assume
A1: D is isotone & D\/D3 is isotone; assume
A2: x is (m,SQ1,D1)-derivable & y is (m,SQ2,D2)-derivable; then
A3: x in (m,D1)-derivables.X & y in (m,D2)-derivables.Y
by Def7;
reconsider sq1=x, sq2=y as S-sequent-like set by A2;
X null Y c= Z & Y null X c= Z & D1 null D2 c= D & D2 null D1 c= D; then
(m,D1)-derivables.X c= (m,D)-derivables.Z
& (m,D2)-derivables.Y c= (m,D)-derivables.Z by Lm14,A1; then
A4: {sq1,sq2} c= iter(O,m).Z by A3,ZFMISC_1:32; assume
z is (n,{x,y},D3)-derivable; then z in (n,D3)-derivables.{x,y}
by Def7; then {z} c= iter(O3,n).{x,y} by ZFMISC_1:31; then
{z} c= iter (OO,m+n).Z by A4,A1,Lm20;
then z in (m+n,D\/D3)-derivables.Z by ZFMISC_1:31;
hence thesis by Def7;
end;

Lm49: (D1 c= D2 & (D1 is isotone or D2 is isotone) &
x is (X,D1)-provable) implies x is (X,D2)-provable
proof
assume
A1: D1 c= D2 & (D1 is isotone or D2 is isotone);
assume x is (X,D1)-provable; then consider seqt being set such that
A2: seqt`1 c= X & seqt`2 = x & {seqt} is D1-derivable by Def13;
{seqt} is ({},D2)-derivable by A2,A1,Lm18;
hence thesis by A2,Def13;
end;

Lm50: x in R.X implies x is (1,X,{R})-derivable
proof
set Q=S-sequents, D={R}, O=OneStep(D), f=iter(O,1); assume
A1: x in R.X; then X in dom R by FUNCT_1:def 2; then
reconsider Seqts=X as Element of bool Q;
iter(O,1)=O by FUNCT_7:70 .= R by Lm7; then
x in (1,D)-derivables.Seqts by A1; hence thesis by Def7;
end;

registration
let S, phi1, phi2;
cluster [{xnot phi1, xnot phi2},<*TheNorSymbOf S*>^phi1^phi2]
-> (1,
{[{xnot phi1,xnot phi2}, xnot phi1], [{xnot phi1, xnot phi2}, xnot phi2]},
{R#6(S)})-derivable for set;
coherence
proof
set Q=S-sequents, x1=xnot phi1, x2=xnot phi2, N=TheNorSymbOf S, prem={x1,x2},
sq=[prem,<*N*>^phi1^phi2], sq1=[prem,x1], sq2=[prem,x2], SQ={sq1, sq2};
reconsider seqt=sq as Element of Q by Def2;
reconsider Seqts=SQ as Element of bool Q by Def3; {sq1}\Seqts={} &
{sq2}\Seqts={} & sq1`1 \+\ prem = {} & sq2`1 \+\ prem={}
& sq`1 \+\ prem = {} & sq`1 \+\ prem={} & sq1`2 \+\ xnot phi1={} &
sq2`2 \+\ xnot phi2 ={} & sq`2 \+\ (<*N*>^phi1^phi2)={}; then sq1 in Seqts &
sq2 in Seqts & sq1`1=prem & sq2`1=prem & sq`1=prem & sq1`2=xnot phi1
& sq2`2=xnot phi2 & sq`2=<*N*>^phi1^phi2 by ZFMISC_1:60; then
seqt Rule6 Seqts by Def27; then [Seqts,seqt] in P#6(S) by Def40;
then seqt in (R#6(S)).Seqts by Lm26; hence thesis by Lm50;
end;
end;

registration
let S,phi1,phi2;
cluster [{phi1,phi2},phi2] -> (1,{},{R#0(S)})-derivable for set;
coherence proof [{phi1,phi2},phi2]=[{phi2,phi1},phi2]; hence thesis; end;
end;

theorem Th2: for R being Relation of bool (S-sequents), S-sequents
st [SQ, Sq] in R holds Sq in (FuncRule(R)).SQ
proof
set Q=S-sequents; reconsider seqt=Sq as Element of Q by Def2;
reconsider Seqts=SQ as Element of bool Q by Def3;
let R be Relation of bool Q, Q; [Seqts,seqt] in R implies
seqt in (FuncRule(R)).Seqts by Lm26; hence thesis;
end;

theorem x in R.X implies x is (1,X,{R})-derivable by Lm50;

definition
let S,D,X;
redefine attr X is D-expanded means :Def61: ::def59 1
x is (X,D)-provable implies x in X;
compatibility
proof
defpred P[] means for x st x is (X,D)-provable holds x in X;
thus X is D-expanded implies P[]
proof
assume A1: X is D-expanded;
hereby
let x; assume x is (X,D)-provable; then
{x} c= X by A1,Def16; hence x in X by ZFMISC_1:31;
end;
end;
assume
A2: P[];
hereby
let x; assume x is (X,D)-provable; then x in X by A2;
hence {x} c= X by ZFMISC_1:31;
end;
end;
end;

theorem Th4: phi in X implies phi is (X,{R#0(S)})-provable ::Th5 1
proof
assume phi in X; then reconsider Xphi={phi} as Subset of X by ZFMISC_1:31;
{[{phi},phi]} is ({},{R#0(S)})-derivable; then
phi is (Xphi,{R#0(S)})-provable by Def12; hence thesis;
end;

theorem (D1\/D2 is isotone & D1\/D2\/D3 is isotone &
x is (m,SQ1,D1)-derivable & y is (m,SQ2,D2)-derivable &
z is (n,{x,y},D3)-derivable) implies
z is (m+n,SQ1\/SQ2,D1\/D2\/D3)-derivable by Lm48; ::#generalizing Lm28

theorem (D1 is isotone & D1\/D2 is isotone &
y is (m,X,D1)-derivable & z is (n,{y},D2)-derivable) implies
z is (m+n,X,D1\/D2)-derivable by Lm21;

theorem x is (m,X,D)-derivable implies {x} is (X,D)-derivable by Lm12;

registration let S;
cluster R#6(S) -> isotone for Rule of S;
coherence
proof
set R=R#6(S), Q=S-sequents;
now
let Seqts, Seqts2; set X=Seqts, Y=Seqts2; assume
A1: X c= Y;
now
let x; assume
A2: x in R.X;
reconsider seqt=x as Element of Q by A2;
[X,seqt] in P#6(S) by A2,Lm29; then
seqt Rule6 X by Def40; then
consider y1,y2 being set,phi1, phi2 being wff string of S such that
A3: y1 in Seqts & y2 in Seqts & y1`1 = y2`1 & y2`1=seqt`1 &
y1`2= <* TheNorSymbOf S *> ^ phi1 ^ phi1 &
y2`2=  <* TheNorSymbOf S *> ^ phi2 ^ phi2 &
seqt`2 = <* TheNorSymbOf S *> ^ phi1 ^ phi2 by Def27;
seqt Rule6 Y by Def27,A3,A1;
then [Y,seqt] in P#6(S) by Def40;
hence x in R.Y by Th2;
end;
hence R.X c= R.Y by TARSKI:def 3;
end;
hence thesis by Def9;
end;
end;

theorem (D1 c= D2 & (D1 is isotone or D2 is isotone) &
x is (X,D1)-provable) implies x is (X,D2)-provable by Lm49;

theorem X c= Y & x is (X,D)-provable implies x is (Y,D)-provable;

registration let S;
cluster R#8(S) -> isotone for Rule of S;
coherence
proof
set R=R#8(S), Q=S-sequents;
now
let Seqts, Seqts2; set X=Seqts, Y=Seqts2; assume
A1: X c= Y;
now
let x; assume
A2: x in R.X;
reconsider seqt=x as Element of Q by A2;
[X,seqt] in P#8(S) by A2,Lm29; then
seqt Rule8 X by Def42; then
consider y1,y2 being set, phi, phi1, phi2 being wff string of S such that
A3:y1 in Seqts & y2 in Seqts & y1`1=y2`1 & y1`2=phi1 &
y2`2 = <*TheNorSymbOf S*>^phi1^phi2 & {phi}\/seqt`1=y1`1 &
seqt`2= <*TheNorSymbOf S*>^phi^phi by Def29; seqt Rule8 Y by Def29,A3,A1;
then [Y,seqt] in P#8(S) by Def42;
hence x in R.Y by Th2;
end;
hence R.X c= R.Y by TARSKI:def 3;
end;
hence thesis by Def9;
end;
end;

registration
let S;
cluster R#1(S) -> isotone for Rule of S;
coherence
proof
set R=R#1(S), Q=S-sequents;
now
let Seqts, Seqts2; set X=Seqts, Y=Seqts2; assume
A1: X c= Y;
now
let x; assume
A2: x in R.X;
reconsider seqt=x as Element of Q by A2;
[X,seqt] in P#1(S) by A2,Lm29; then
seqt Rule1 X by Def32; then consider
y being set such that
A3: y in Seqts & y`1 c= seqt`1 & seqt`2 = y`2 by Def19;
seqt Rule1 Y by Def19,A3,A1; then [Y,seqt] in P#1(S) by Def32;
hence x in R.Y by Th2;
end;
hence R.X c= R.Y by TARSKI:def 3;
end;
hence thesis by Def9;
end;
end;

theorem ::Th11
{y} is (SQ,D)-derivable implies ex mm st y is (mm,SQ,D)-derivable
proof
set Q=S-sequents; reconsider Seqts=SQ as Element of bool Q
by Def3; {y} is (Seqts,D)-derivable implies ex mm st
y is (mm,Seqts,D)-derivable by Lm8; hence thesis;
end;

registration
let S,D,X;
cluster (X,D)-derivable -> S-sequents-like for set;
coherence
proof
set Q=S-sequents, O=OneStep D, F={(mm,D)-derivables.X: not contradiction};
let IT be set;assume IT is (X,D)-derivable; then IT c= union ((O[*]).:{X})
by Def6; then
A1: IT c= union F by Lm10;
now
let x; assume x in IT; then consider Y such that
A2: x in Y & Y in F by A1,TARSKI:def 4; consider mm such that
A3: Y=(mm,D)-derivables.X & not contradiction by A2;
x is (mm,X,D)-derivable by Def7,A2,A3;
hence x in Q by Def2;
end;
then IT c= Q by TARSKI:def 3; hence thesis;
end;
end;

definition ::def64 4
let S,D,X,x;
redefine attr x is (X,D)-provable means :Def62:
ex H being set, m st H c= X & [H,x] is (m,{},D)-derivable;
compatibility
proof
set FF=AllFormulasOf S, Q=S-sequents; defpred P[] means
ex H being set, m st (H c= X & [H,x] is (m,{},D)-derivable);
{} /\ S is S-sequents-like; then reconsider e={} as Element of bool Q by
Def3;
thus x is (X,D)-provable implies P[]
proof
assume x is (X,D)-provable; then consider seqt being set such that
A1: (seqt`1 c= X & seqt`2 = x & {seqt} is D-derivable) by Def13;
A2: seqt`1 c= X & seqt`2 = x & {seqt} is ({},D)-derivable by A1;
{seqt} c= Q & seqt in {seqt} by A2,Def3,TARSKI:def 1;
then seqt in Q; then consider
premises being Subset of FF, conclusion being wff string of S such that
A3: seqt=[premises, conclusion] & premises is finite;
consider mm such that
A4: seqt is (mm,e,D)-derivable by A2,Lm8; take H=seqt`1, m=mm;
H=premises & seqt`2=conclusion by A3,MCART_1:7;
hence thesis by A1,A4,A3;
end;
assume P[]; then consider H being set, m such that
A5: H c= X & [H,x] is (m,{},D)-derivable;
now
take seqt=[H,x];
seqt`1 c= X & seqt`2=x  & {seqt} is ({},D)-derivable by A5,Lm12,MCART_1:7;
hence seqt`1 c= X & seqt`2=x & {seqt} is D-derivable;
end;
hence thesis by Def12;
end;
end;

theorem Th11: D1 c= D2 & (D2 is isotone or D1 is isotone) & x is
(m,X,D1)-derivable implies x is (m,X,D2)-derivable
proof
set f1=(m,D1)-derivables, f2=(m,D2)-derivables;
assume D1 c= D2 & (D2 is isotone or D1 is isotone); then
A1: f1.X c= f2.X by Lm16; assume x is (m,X,D1)-derivable; then
x in f1.X by Def7;
hence thesis by Def7,A1;
end;

registration
let S;
cluster R#7(S) -> isotone for Rule of S;
coherence
proof
set R=R#7(S), Q=S-sequents;
now
let Seqts, Seqts2; set X=Seqts, Y=Seqts2; assume
A1: X c= Y;
now
let x; assume
A2: x in R.X;
reconsider seqt=x as Element of Q by A2;
[X,seqt] in P#7(S) by A2,Lm29; then
seqt Rule7 X by Def41; then consider
y being set, phi1, phi2 being wff string of S such that
A3: y in Seqts & y`1 = seqt`1 & y`2 =<* TheNorSymbOf S*> ^ phi1 ^ phi2 &
seqt`2 = <* TheNorSymbOf S*> ^ phi2 ^ phi1 by Def28;
seqt Rule7 Y by Def28,A3,A1; then [Y,seqt] in P#7(S) by Def41;
hence x in R.Y by Th2;
end;
hence R.X c= R.Y by TARSKI:def 3;
end;
hence thesis by Def9;
end;
end;

theorem x is (X,D)-provable implies x is wff string of S by Lm24;

reserve D,E,F for (RuleSet of S), D1 for 1-ranked 0-ranked RuleSet of S,
D2 for 2-ranked RuleSet of S;

registration
let S, D1; let X be D1-expanded set;
cluster (S,X)-freeInterpreter -> ((X,D1)-termEq)-respecting
for (S,AllTermsOf S)-interpreter-like Function;
coherence
proof
set TT=AllTermsOf S, E=(X,D1)-termEq, I=(S,X)-freeInterpreter;
now
let o be own Element of S; I.o=X-freeInterpreter(o) by FOMODEL3:def 4;
hence I.o is E-respecting;
end;
hence thesis by FOMODEL3:def 16;
end;
end;

definition
let S; let D be 0-ranked RuleSet of S; let X be D-expanded set;
func D Henkin X -> Function equals
(S,X)-freeInterpreter quotient ((X,D)-termEq);
coherence;
end;

registration
let S; let D be 0-ranked RuleSet of S; let X be D-expanded set;
cluster D Henkin X -> (OwnSymbolsOf S)-defined;
coherence;
end;

registration
let S, D1; let X be D1-expanded set;
cluster D1 Henkin X -> (S,Class (X,D1)-termEq)-interpreter-like for Function;
coherence;
end;

definition
let S, D1; let X be D1-expanded set;
redefine func D1 Henkin X ->
Element of (Class (X,D1)-termEq)-InterpretersOf S;
coherence
proof
set TT=AllTermsOf S, R=(X,D1)-termEq, I=(S,X)-freeInterpreter;
I quotient R is Element of (Class R)-InterpretersOf S; hence thesis;
end;
end;

registration
let S, phi1, phi2;
cluster <*TheNorSymbOf S*>^phi1^phi2 ->
({xnot phi1, xnot phi2},{R#0(S)}\/{R#6(S)})-provable for set;
coherence
proof
set N=TheNorSymbOf S, phi=<*N*>^phi1^phi2, x1=xnot phi1, x2=xnot phi2,
prem={x1,x2}, sq=[prem,phi], sq1=[prem,x1], sq2=[prem, x2];
{} /\ S is S-sequents-like; then reconsider SQe={} as S-sequents-like set;
sq is (1+1,SQe\/SQe,{R#0(S)}\/{R#0(S)}\/{R#6(S)})-derivable by Lm48; then
{sq} is ({},{R#0(S)}\/{R#6(S)})-derivable by Lm12;
hence thesis by Def12;
end;
end;

registration
let S;
cluster -> non empty for 0-ranked RuleSet of S;
coherence by Def59;
end;

definition ::def62 1
let S,x;
attr x is S-premises-like means :Def64:
x c= AllFormulasOf S & x is finite;
end;

registration
let S;
cluster S-premises-like -> finite for set;
coherence by Def64;
end;

registration
let S,phi;
cluster {phi} -> S-premises-like for set;
coherence
proof
set FF=AllFormulasOf S; phi in FF by FOMODEL2:16; then
{phi} c= FF & {phi} is finite by ZFMISC_1:31; hence thesis by Def64;
end;
end;

registration
let S; let e be empty set;
cluster e null S -> S-premises-like for set;
coherence
proof
set FF=AllFormulasOf S; e /\ FF=e; hence thesis by Def64;
end;
end;

registration
let X,S;
cluster S-premises-like for Subset of X;
existence
proof
{}/\X={}; then reconsider e={} null S as Subset of X; take e; thus thesis;
end;
end;

registration
let S;
cluster S-premises-like for set;
existence
proof take the S-premises-like Subset of S; thus thesis; end;
end;

registration
let S; let X be S-premises-like set;
cluster -> S-premises-like for Subset of X;
coherence
proof
set FF=AllFormulasOf S; reconsider XX=X as finite Subset of FF
by Def64; let Y be Subset of X; Y is Subset of XX; then
Y is finite Subset of FF by XBOOLE_1:1; hence thesis by Def64;
end;
end;

reserve H,H1,H2,H3 for S-premises-like set;

definition
let S, H2, H1;
redefine func H1 null H2 -> Subset of (AllFormulasOf S);
coherence by Def64;
end;

registration
let S,H,x;
cluster H null x -> S-premises-like;
coherence;
end;

registration
let S, H1, H2;
cluster H1\/H2 -> S-premises-like for set;
coherence
proof
set FF=AllFormulasOf S; (H1 null H1) \/ (H2 null H2) c= FF;
hence thesis by Def64;
end;
end;

registration
let S,H,phi;
cluster [H,phi] -> S-sequent-like;
coherence
proof
set FF=AllFormulasOf S; reconsider HH=H as finite Subset of FF by Def64;
[HH,phi] is S-sequent-like; hence thesis;
end;
end;

registration
let S, H1, H2, phi;
cluster [H1\/H2, phi] -> (1,{[H1,phi]},{R#1(S)})-derivable for set;
coherence
proof
set y=[H1,phi], SQ={y}, H=H1\/H2, Sq=[H,phi], Q=S-sequents;
reconsider seqt=Sq as Element of Q by Def2;
reconsider Seqts=SQ as Element of bool Q by Def3;
H1 null H2 c= H & {y}\SQ={} & y`1\+\H1={} & Sq`1\+\H={} &
Sq`2 \+\ phi = {} & y`2 \+\ phi={}; then
H1 c= H & y in SQ & y`1 = H1 & Sq`1=H & Sq`2=phi & y`2=phi
by ZFMISC_1:60;
then seqt Rule1 Seqts by Def19; then [Seqts,seqt] in P#1(S) by Def32;
then Sq in (R#1(S)).SQ by Th2; hence thesis by Lm50;
end;
end;

registration
let S,H, phi, phi1, phi2;
cluster [H null (phi1^phi2),xnot phi] -> (1,
{[H\/{phi},phi1],[H\/{phi},<*TheNorSymbOf S*>^phi1^phi2]},
{R#8(S)})-derivable for set;
coherence
proof
set N=TheNorSymbOf S, H1=H\/{phi}, psi=<*N*>^phi1^phi2, y1=[H1,phi1],
y2=[H1,psi], SQ={y1,y2}, Sq=[H, xnot phi], Q=S-sequents;
reconsider seqt=Sq as Element of Q by Def2;
reconsider Seqts=SQ as Element of bool Q by Def3;
{y1}\SQ={} & {y2}\SQ={} & y1`1\+\H1={} & y2`1\+\H1={}  &
y1`2\+\phi1={} & y2`2\+\psi={} & Sq`1\+\H={} & Sq`2\+\(xnot phi)={};
then y1 in SQ & y2 in SQ & y1`1=H1 & y2`1=H1 & y1`2=phi1 & y2`2=psi &
Sq`1=H & Sq`2=xnot phi by ZFMISC_1:60; then seqt Rule8 Seqts
by Def29;
then [Seqts,seqt] in P#8(S) by Def42; then Sq in (R#8(S)).SQ by Th2;
hence thesis by Lm50;
end;
end;

registration
let S;
cluster {} null S -> S-sequents-like for set;
coherence
proof {} null S = {}/\S; hence thesis; end;
end;

registration
let S,H,phi;
cluster [H\/{phi}, phi] -> (1,{},{R#0(S)})-derivable for set;
coherence
proof
set H1=H\/{phi}, Sq=[H1,phi], SQ={} null S, Q=S-sequents;
reconsider seqt=Sq as Element of Q by Def2;
reconsider Seqts=SQ as Element of bool Q by Def3;
Sq`2\+\phi={} & Sq`1\+\H1={} & ({phi} null H)\H1 = {}; then
Sq`2=phi & Sq`1=H1 & phi in H1 by ZFMISC_1:60; then
seqt Rule0 Seqts by Def18; then [Seqts,seqt] in P#0(S) by Def31;
then Sq in (R#0(S)).SQ by Th2; hence thesis by Lm50;
end;
end;

registration
let S, H, phi1, phi2;
cluster [H null phi2,xnot phi1] -> (2,
{[H,<*TheNorSymbOf S*>^phi1^phi2]},{R#0(S)}\/{R#1(S)}\/{R#8(S)})-derivable for
set;
coherence
proof
set N=TheNorSymbOf S, psi1=xnot phi1, psi2=<*N*>^phi1^phi2,
Sq=[H,psi2], Sq1=[H\/{phi1}, psi2], Sq2=[H\/{phi1},phi1], SQ={} null S,
goal=[H null (phi1^phi2), xnot phi1];
goal is (1+1, SQ\/{Sq}, {R#0(S)}\/{R#1(S)}\/{R#8(S)})-derivable by Lm48;
hence thesis;
end;
end;

registration
let S, H, phi1, phi2;
cluster [H, <*TheNorSymbOf S*>^phi2^phi1] -> (1,
{[H,<*TheNorSymbOf S*>^phi1^phi2]},{R#7(S)})-derivable for set;
coherence
proof
set N=TheNorSymbOf S, psi1=<*N*>^phi1^phi2, psi2=<*N*>^phi2^phi1,
Sq=[H,psi2], y=[H,psi1], SQ={y}, Q=S-sequents;
reconsider seqt=Sq as Element of Q by Def2;
reconsider Seqts=SQ as Element of bool Q by Def3;
{y}\SQ={} & y`1\+\H={} & Sq`1\+\H={} & y`2\+\psi1={} & Sq`2\+\psi2={}; then
y in SQ & y`1=H & Sq`1=H & y`2=psi1 & Sq`2=psi2 by ZFMISC_1:60;
then seqt Rule7 Seqts by Def28; then [Seqts,seqt] in P#7(S) by Def41;
then Sq in (R#7(S)).SQ by Th2; hence thesis by Lm50;
end;
end;

registration
let S, H, phi1, phi2;
cluster [H null phi1, xnot phi2] ->
(3,{[H,<*TheNorSymbOf S*>^phi1^phi2]},{R#0(S)}\/{R#1(S)}\/{R#8(S)}\/{R#7(S)})
-derivable for set;
coherence
proof
set N=TheNorSymbOf S, psi2=<*N*>^phi2^phi1, Sq1=[H, psi2], D1={R#7(S)},
D2=D1, D3= {R#0(S)}\/{R#1(S)}\/{R#8(S)}, goal=[H null phi1, xnot phi2],
SQ1={[H,<*N*>^phi1^phi2]}, SQ2=SQ1;
A1: D1\/D2 is isotone & D1\/D2\/D3 is isotone &
{Sq1,Sq1}={Sq1}\/{Sq1} by ENUMSET1:1;
goal is (1+2, SQ1\/SQ2, D1\/D2\/D3)-derivable by A1,Lm48;
hence thesis;
end;
end;

registration
let S,Sq;
cluster Sq`1 -> S-premises-like for set;
coherence
proof
set FF=AllFormulasOf S, Q=S-sequents; Sq in Q by Def2; then consider
premises being Subset of FF, conclusion being wff string of S such that
A1: Sq=[premises, conclusion] & premises is finite;
Sq`1=premises by A1,MCART_1:7; hence thesis by A1,Def64;
end;
end;

definition
let S,X,D;
redefine func D null X -> RuleSet of S;
coherence;
end;

registration
let S,phi1,phi2,l1,H;
let l2 be (H\/{phi1}\/{phi2})-absent literal Element of S;
cluster [(H\/{<*l1*>^phi1}) null l2, phi2] ->
(1,{[H\/{(l1,l2)-SymbolSubstIn phi1}, phi2]},{R#5(S)})-derivable for set;
coherence
proof
reconsider phi11=(l1,l2)-SymbolSubstIn phi1 as wff string of S;
set H1=H\/{phi11}, Sq1=[H1,phi2],H2=H\/{<*l1*>^phi1}, Sq2=[H2,phi2],
R=R#5(S), Q=S-sequents, x=H, SS=AllSymbolsOf S, SQ={Sq1}, s=l1 SubstWith l2;
reconsider p=phi1 as SS-valued FinSequence; reconsider seqt=Sq2 as
Element of Q by Def2; reconsider Seqts=SQ as Element of bool Q
by Def3; seqt`1 \+\ H2={} & seqt`2 \+\ phi2={}; then
A1: seqt`1=H2 & seqt`2=phi2 by FOMODEL0:29; x\/{s.p}=H1 by FOMODEL0:def 23;
then [x\/{s.p},seqt`2] in Seqts by A1,TARSKI:def 1;
then seqt Rule5 Seqts by A1,Def26; then [Seqts,seqt] in P#5(S)
by Def39; then seqt in (R#5(S)).Seqts by Th2; hence thesis by Lm50;
end;
end;

definition ::def63 2
let S,D,X;
attr X is D-inconsistent means :Def65: ex phi1,phi2 st
(phi1 is (X,D)-provable & <*TheNorSymbOf S*>^phi1^phi2 is (X,D)-provable);
end;

registration
let m1, S, H1, H2, phi;
cluster [(H1\/H2) null m1, phi] -> (m1,{[H1,phi]},{R#1(S)})-derivable for set;
coherence
proof
set H=H1\/H2, sq1=[H1,phi], sq=[H, phi]; consider m such that
A1: m1=m+1 by NAT_1:6; defpred P[Nat] means
sq is ($1+1,{sq1},{R#1(S)})-derivable;
A2: [H\/H,phi] is (1,{sq},{R#1(S)})-derivable;
A3: P[0];
A4: for n st P[n] holds P[n+1]
proof
let n; assume P[n]; then
sq is (n+1+1,{sq1},{R#1(S)}\/{R#1(S)})-derivable by Lm21,A2;
hence thesis;
end;
for n holds P[n] from NAT_1:sch 2(A3,A4); hence thesis by A1;
end;
end;

registration
let S;
cluster non empty for isotone RuleSet of S;
existence proof take {R#0(S)}; thus thesis; end;
end;

theorem Th13:
(X is D-inconsistent & D is isotone & R#1(S) in D & R#8(S) in D)
implies xnot phi is (X,D)-provable
proof
set N=TheNorSymbOf S;
assume X is D-inconsistent; then consider phi1,phi2 such that
A1: phi1 is (X,D)-provable & <*N*>^phi1^phi2 is (X,D)-provable by Def65;
reconsider psi=<*N*>^phi1^phi2 as wff string of S;
consider H being set, m such that
A2: H c= X & [H,phi1] is (m, {}, D)-derivable by A1,Def62;
consider K being set, n such that
A3: K c= X & [K,psi] is (n,{},D)-derivable by A1,Def62;
reconsider HHH=H, KKK=K as Subset of X by A2,A3;
reconsider sq1=[H,phi1], sq2=[K,psi] as S-sequent-like set by A2,A3;
H=sq1`1 & K=sq2`1 by MCART_1:7; then
reconsider HH=H, KK=K as S-premises-like set;
reconsider J=HH\/KK\/{phi} as S-premises-like set; assume
A4: D is isotone & R#1(S) in D & R#8(S) in D; then
reconsider DD=D as non empty isotone RuleSet of S;
reconsider E1=R#1(S), E8=R#8(S) as Element of DD by A4;
A5: DD\/{E1} = DD null E1 & DD \/ {E8} = DD null E8 & D\/D is isotone &
D\/D\/{R#8(S)} is isotone & D is non empty & HHH\/KKK c= X by A4;
A6: [(J\/J) null (n+1), phi1] is (n+1,{[J,phi1]},{R#1(S)})-derivable &
[(J\/J) null (m+1), psi] is (m+1,{[J,psi]},{R#1(S)})-derivable;
[HH\/(KK\/{phi}), phi1] is (m+1,{},D\/{R#1(S)})-derivable
by Lm21,A2,A4; then
[J,phi1] is (m+1,{},D)-derivable by A5,XBOOLE_1:4; then
A7: [J,phi1] is ((m+1)+(n+1),{},D)-derivable by A6,A5,Lm21;
[KK\/(HH\/{phi}),  psi] is (n+1,{},D\/{R#1(S)})-derivable
by Lm21,A3,A4; then
[J,psi] is (n+1,{},D)-derivable by A5,XBOOLE_1:4; then
A8: [J,psi] is (n+1+(m+1),{},D)-derivable by A6,Lm21,A5;
[(KK\/HH) null (phi1^phi2),xnot phi] is
(1, {[J,phi1],[J,psi]}, {R#8(S)})-derivable; then [KK\/HH, xnot phi] is
((m+n+2)+1, ({} null S)\/({} null S), D\/D\/{R#8(S)})-derivable
by Lm48,A7,A8,A4; hence thesis by A5,Def62;
end;

registration
let S;
cluster R#5(S) -> isotone for Rule of S;
coherence
proof
set R=R#5(S), Q=S-sequents;
now
let Seqts, Seqts2; set X=Seqts, Y=Seqts2; assume
A1: X c= Y;
now
let x; assume
A2: x in R.X;
reconsider seqt=x as Element of Q by A2;
[X,seqt] in P#5(S) by A2,Lm29; then
seqt Rule5 X by Def39; then consider
v1,v2 being literal Element of S, z,p such that
A3: seqt`1=z \/ {<*v1*>^p} & v2 is (z\/{p}\/{seqt`2})-absent &
[z\/{(v1 SubstWith v2).p},seqt`2] in X by Def26;
seqt Rule5 Y by Def26,A1,A3; then
[Y,seqt] in P#5(S) by Def39; hence x in R.Y by Th2;
end;
hence R.X c= R.Y by TARSKI:def 3;
end;
hence thesis by Def9;
end;
end;

registration
let S,l,t,phi;
cluster [{(l,t) SubstIn phi}, <*l*>^phi] -> (1,{},{R#4(S)})-derivable for set;
coherence
proof
set Q=S-sequents, psi=(l,t) SubstIn phi;
reconsider Sq=[{psi},<*l*>^phi] as S-sequent-like set;
reconsider SQ={} null S as S-sequents-like set;
reconsider seqt=Sq as Element of Q by Def2;
reconsider Seqts=SQ as Element of bool Q by Def3;
seqt`1 \+\ {psi}={} & seqt`2\+\<*l*>^phi={}; then
Seqts={} & seqt`1={psi} & seqt`2=<*l*>^phi by FOMODEL0:29;
then seqt Rule4 Seqts by Def25; then [Seqts,seqt] in P#4(S) by Def38;
then Sq in (R#4(S)).SQ by Th2; hence thesis by Lm50;
end;
end;

registration
let S;
cluster R#4(S) -> isotone for Rule of S;
coherence
proof
set R=R#4(S), Q=S-sequents;
now
let Seqts, Seqts2; set X=Seqts, Y=Seqts2; assume
X c= Y;
now
let x; assume
A1: x in R.X;
reconsider seqt=x as Element of Q by A1;
[X,seqt] in P#4(S) by A1,Lm29; then
seqt Rule4 X by Def38; then consider
l being literal Element of S, phi being wff string of S, t being
termal string of S such that
A2: seqt`1={(l,t) SubstIn phi} & seqt`2=<*l*>^phi by Def25;
seqt Rule4 Y by A2,Def25; then [Y,seqt] in P#4(S) by Def38;
hence x in R.Y by Th2;
end;
hence R.X c= R.Y by TARSKI:def 3;
end;
hence thesis by Def9;
end;
end;

Lm51: for X being D1-expanded set, phi being 0wff string of S holds
((D1 Henkin X)-AtomicEval phi = 1 iff phi in X)
proof
let X be D1-expanded set, phi be 0wff string of S;
R#0(S) in D1 by Def59; then
A1: {R#0(S)} c= D1 by ZFMISC_1:31;
set TT=AllTermsOf S, E=TheEqSymbOf S, p=SubTerms phi, F=S-firstChar, s=F.phi,
n=abs(ar s), R=(X,D1)-termEq, U=Class R, AF=AtomicFormulasOf S,
d=U-deltaInterpreter, i=(S,X)-freeInterpreter;
A2: abs(ar E)-2=0;
reconsider I=D1 Henkin X as Element of U-InterpretersOf S;
set UV=I-TermEval, V=I-AtomicEval phi, uv=i-TermEval, v=i-AtomicEval phi,
f=I===.s, G=I.s, g=i.s, O=OwnSymbolsOf S, FF=AllFormulasOf S,
C=S-multiCat, SS=AllSymbolsOf S;
reconsider pp=p as Element of n-tuples_on TT by FOMODEL0:16;
pp is Element of Funcs(Seg n, TT) by FOMODEL0:11; then
reconsider fp=pp as Function of Seg n, TT;
A3: 2-tuples_on (SS*\{{}}) = {<*tt1,tt2*> where tt1,tt2 is
Element of SS*\{{}}: not contradiction} by FINSEQ_2:99;
p in TT*; then reconsider Pp=p as Element of (SS*\{{}})*;
A4: phi = <*s*>^(C.p) by FOMODEL1:def 38;
A5: UV=(R-class)*uv by FOMODEL3:3;
A6: uv=id TT by FOMODEL3:4;
n-tuples_on TT c= TT* & TT* c= (SS*\{{}})* by FINSEQ_2:142; then
n-tuples_on TT c= (SS*\{{}})* by XBOOLE_1:1; then reconsider nc =
(s-compound|(n-tuples_on TT)) as Function of n-tuples_on TT, SS*\{{}}
by FUNCT_2:32;
per cases;
suppose A7: s=E;
reconsider p1=p as (0+1+1)-element Element of TT* by A7,A2;
Pp in 2-tuples_on (SS*\{{}}) by A2,A7,FOMODEL0:16; then
consider tt11, tt22 being Element of SS*\{{}} such that
A8: Pp=<*tt11, tt22*> & not contradiction by A3;
A9: C.<*tt11, tt22*>=tt11^tt22 by FOMODEL0:15;
reconsider p2=p as (1+1+0)-element Element of TT* by A7,A2;
{p1.(0+1)}\TT={} & {p2.(1+1)}\TT={}; then
reconsider tt1=p.1, tt2=p.2 as Element of TT by ZFMISC_1:60;
reconsider t1=tt1, t2=tt2 as termal string of S;
A10: (R-class).tt1=EqClass(R,tt1) & (R-class).tt2=EqClass(R,tt2)
by FOMODEL3:def 13;
A11: tt1=tt11 & tt2=tt22 by A8,FINSEQ_1:44;
{(id TT).tt1}\{tt1}={} & {(id TT).tt2}\{tt2}={}; then
A12: (id TT).tt1=tt1 & (id TT).tt2=tt2 by ZFMISC_1:15;
((R-class)*uv).tt1\+\(R-class).(uv.tt1)={} &
((R-class)*uv).tt2\+\(R-class).(uv.tt2)={}; then
((R-class)*uv).tt1 = (R-class).(uv.tt1) &
((R-class)*uv).tt2 = (R-class).(uv.tt2) by FOMODEL0:29; then
A13: V=1 iff EqClass(R,tt1) = EqClass(R,tt2)
by A10,A12,A5,A7,A6,FOMODEL2:15; then
A14: V=1 iff [tt1, tt2] in R by EQREL_1:35;
A15: <*E*>^t1^t2 = phi by A4,A8,A9,A11,A7,FINSEQ_1:32;
thus (D1 Henkin X)-AtomicEval phi=1 implies phi in X
proof
assume (D1 Henkin X)-AtomicEval phi=1; then
[tt1, tt2] in R by A13,EQREL_1:35; then
consider t11, t22 being termal string of S such that
A16: [tt1, tt2]=[t11,t22] & <*E*>^t11^t22 is (X,D1)-provable;
t11=tt1 & t22=tt2 by A16,XTUPLE_0:1; then
<*E*>^(t11^t22) =
phi by A4,A8,A11,A7,FOMODEL0:15; then
phi is (X,D1)-provable by A16,FINSEQ_1:32;
then {phi} c= X by Def16;
hence thesis by ZFMISC_1:31;
end;
assume phi in X;
then reconsider Xphi={phi} as Subset of X by ZFMISC_1:31;
{[{phi},phi]} is
({},D1)-derivable by Lm18,A1; then phi is (Xphi,D1)-provable by Def12;
hence thesis by A14,A15;
end;
suppose
A17: not s=E; then reconsider o=s as Element of O by FOMODEL1:15; set gg=i.o;
s<>E & V=v & v=gg.(uv*p) by A17,FOMODEL2:14,FOMODEL3:5; then V=
gg.((id TT)*fp) by FOMODEL3:4 .= gg.(fp) by FUNCT_2:17 .=
(X-freeInterpreter o).p by FOMODEL3:def 4 .=
(chi(X,AF)*(o-compound|(n-tuples_on TT))).pp by FOMODEL3:def 3 .=
chi(X,AF).(nc.pp) by FUNCT_2:15 .=
chi(X,AF).((o-compound).pp) by FUNCT_1:49 .=
chi(X,AF).(o-compound Pp) by FOMODEL3:def 2 .=
chi(X,AF).phi by FOMODEL1:def 38; then
V=1 iff phi in (chi(X,AF))"{1} by FOMODEL0:25; then
V=1 iff (phi in X/\AF) by FOMODEL0:24; then
phi in AF & (V=1 iff (phi in X & phi in AF)) by XBOOLE_0:def 4;
hence thesis;
end;
end;

definition
let S,X;
attr X is S-witnessed means :Def66:
for l1, phi1 st <*l1*>^phi1 in X ex l2 st (
(l1,l2)-SymbolSubstIn phi1 in X & not l2 in rng phi1);
end;

theorem Th14: for X being D1-expanded set st
R#1(S) in D1 & R#4(S) in D1 & R#6(S) in D1 & R#7(S) in D1 &
R#8(S) in D1 & X is S-mincover & X is S-witnessed
holds (D1 Henkin X)-TruthEval psi = 1 iff psi in X
proof
let X be D1-expanded set; set TT=AllTermsOf S, E=TheEqSymbOf S,
F=S-firstChar, N=TheNorSymbOf S, R=(X,D1)-termEq, U=Class R, L=LettersOf S,
AF=AtomicFormulasOf S, d=U-deltaInterpreter, i=(S,X)-freeInterpreter,
II=U-InterpretersOf S, D=D1, ii=TT-InterpretersOf S, G0=R#0(S), G1=R#1(S),
G2=R#2(S), G4=R#4(S), G6=R#6(S), G7=R#7(S), G8=R#8(S), E0={G0}, E1={G1},
E2={G2}, E4={G4}, E6={G6}, E7={G7}, E8={G8}; reconsider
E0, E1, E2, E4, E6, E7, E8 as RuleSet of S; assume
G1 in D & G4 in D & G6 in D & G7 in D & G8 in D; then
G0 in D & G1 in D & G2 in D & G4 in D & G6 in D & G7 in D & G8 in D by Def59
; then
reconsider F0=E0, F1=E1, F2=E2, F4=E4, F6=E6, F7=E7, F8=E8 as Subset of D
by ZFMISC_1:31;
A1: (F0\/(F0\/F1\/F8)) c= D & F0\/F6 c= D & F0 c= D &
F0\/(F0\/F1\/F8\/F7) c= D;
reconsider I=D1 Henkin X as Element of II;
set UV=I-TermEval, uv=i-TermEval, O=OwnSymbolsOf S, FF=AllFormulasOf S,
C=S-multiCat, SS=AllSymbolsOf S; assume
A2: X is S-mincover & X is S-witnessed;
defpred P[Nat] means for phi st phi is $1-wff holds
(I-TruthEval phi=1 iff phi in X);
A3: P[0]
proof
let phi; assume phi is 0-wff; then reconsider phi0=phi as 0wff string of S;
I-AtomicEval phi0=1 iff phi0 in X by Lm51; hence thesis;
end;
A4: for n st P[n] holds P[n+1]
proof
let n; set Vn=(I,n)-TruthEval; assume
A5: P[n]; let phi; set s=F.phi, V=I-TruthEval phi; assume
A6: phi is (n+1)-wff;
per cases;
suppose phi is non 0wff & phi is exal; then
reconsider phii=phi as non 0wff exal (n+1)-wff string of S by A6;
reconsider phi1=head phii as n-wff string of S;
reconsider l=F.phii as literal Element of S;
A7: phii=<*l*>^phi1^(tail phii) by FOMODEL2:23 .= <*l*>^phi1;
hereby
assume V=1;
then consider u being Element of U such that
A8: ((l,u) ReassignIn I)-TruthEval phi1=1 by A7,FOMODEL2:19;
consider x such that
A9: x in TT & u=Class (R,x) by EQREL_1:def 3;
reconsider tt=x as Element of TT by A9;
reconsider psi1=(l,tt) SubstIn phi1 as n-wff string of S;
id TT.tt \+\ tt={}; then id TT.tt=tt & ((R-class)*(i-TermEval)).tt \+\
(R-class).(i-TermEval.tt)={} by FOMODEL0:29; then
A10: i-TermEval.tt=tt & ((R-class)*(i-TermEval)).tt=(R-class).(i-TermEval.tt)
by FOMODEL0:29,FOMODEL3:4; I-TermEval.tt = ((R-class)*(i-TermEval)).tt
by FOMODEL3:3 .= u by A10,A9,FOMODEL3:def 13; then
1 = I-TruthEval psi1 by A8,FOMODEL3:10; then psi1 in X by A5; then
A11: {psi1} c= X by ZFMISC_1:31; [{(l,tt) SubstIn phi1},<*l*>^phi1] is
(1,{},{R#4(S)})-derivable; then <*l*>^phi1 is (X,E4)-provable &
F4 c= D & E4 is isotone by A11,Def62; then
phii is (X,D)-provable by A7,Lm49; hence phi in X by Def61;
end;
assume phi in X; then consider l2 such that
A12: (l,l2)-SymbolSubstIn phi1 in X & not l2 in rng phi1 by A2,Def66,A7;
reconsider psi1=(l,l2)-SymbolSubstIn phi1 as n-wff string of S;
consider u being Element of U such that
A13: u=I.l2.{} & (l2,u) ReassignIn I=I by FOMODEL2:26;
reconsider I2=(l2,u) ReassignIn I, I1=(l,u) ReassignIn I as Element of II;
I2-TruthEval psi1=1 by A12,A5,A13; then
I1-TruthEval phi1=1 by A12,FOMODEL3:9; hence thesis by A7,FOMODEL2:19;
end;
suppose phi is non 0wff & phi is non exal; then
reconsider phii=phi as non 0wff non exal (n+1)-wff string of S by A6;
set phi1=head phii, phi2=tail phii; F.phii\+\N={}; then
s = N by FOMODEL0:29; then
A14: phi=<*N*>^phi1^phi2 by FOMODEL2:23;
V=1 iff (I-TruthEval phi1=0 & I-TruthEval phi2=0) by A14,FOMODEL2:19;
then V=1 iff ((not I-TruthEval phi1=1) & (not I-TruthEval phi2=1)) by
FOMODEL0:39; then
A15: V=1 iff ((not phi1 in X) & (not phi2 in X)) by A5;
A16: now
assume xnot phi1 in X & xnot phi2 in X; then xnot phi1 is
(X,{R#0(S)})-provable & xnot phi2 is (X,{R#0(S)})-provable by Th4; then
xnot phi1 is (X,D1)-provable & xnot phi2 is (X,D1)-provable by A1,Lm49;
then xnot phi1 in X & xnot phi2 in X by Def61; then
reconsider Y={xnot phi1, xnot phi2} as Subset of X by ZFMISC_1:32;
phi is (X null Y,D1)-provable by Lm49,A1,A14;
hence phi in X by Def61;
end;
now
reconsider H={phi} as S-premises-like set; assume phi in X; then
A17: H c= X by ZFMISC_1:31;
A18: [{phi},phi] is (1, {}, E0)-derivable;
A19: [H null phi2,xnot phi1] is (2,{[{phi},phi]},E0\/E1\/E8)-derivable by A14;
A20: [H null phi1, xnot phi2] is (3,{[H,phi]},E0\/E1\/E8\/E7)-derivable by A14;
[H,xnot phi1] is (1+2,{},E0\/(E0\/E1\/E8))-derivable by A19,Lm21; then
[H,xnot phi1] is (3,{},D)-derivable by A1,Th11; then
xnot phi1 is (X,D)-provable by Def62,A17; hence xnot phi1 in X by
Def61;
A21: [H,xnot phi2] is (1+3, {}, E0\/(E0\/E1\/E8\/E7))-derivable
by A18,A20,Lm21;
[H,xnot phi2] is (4, {}, D)-derivable by A1,A21,Th11; then
xnot phi2 is (X,D)-provable by Def62,A17; hence xnot phi2 in X by
Def61;
end;
hence thesis by A15,A2,A16,FOMODEL2:def 34;
end;
suppose phi is 0wff; hence thesis by A3; end;
end;
A22: for n holds P[n] from NAT_1:sch 2(A3, A4); psi is (Depth psi)-wff
by FOMODEL2:def 31;
hence thesis by A22;
end;

notation
let S,D,X;
antonym X is D-consistent for X is D-inconsistent;
end;

theorem Th15: for X being Subset of Y st X is D-inconsistent
holds Y is D-inconsistent
proof
let X be Subset of Y; set N=TheNorSymbOf S; assume X is D-inconsistent;
then consider phi1, phi2 such that
A1: phi1 is (X,D)-provable & <*N*>^phi1^phi2 is (X,D)-provable
by Def65; thus thesis by Def65,A1;
end;

definition
let S,D; let X be functional set; let phi be Element of ExFormulasOf S;
func (D,phi) AddAsWitnessTo X equals :Def67:
X\/{
(S-firstChar.phi, the Element of (
LettersOf S \ SymbolsOf (((AllSymbolsOf S)*\{{}})/\(X\/{head phi}))
))-SymbolSubstIn (head phi)
} if X\/{phi} is D-consistent &
LettersOf S \ SymbolsOf (((AllSymbolsOf S)*\{{}})/\(X\/{head phi}))<>{}
otherwise X;
consistency;
coherence;
end;

registration
let S,D; let X be functional set; let phi be Element of ExFormulasOf S;
cluster X \ ((D,phi) AddAsWitnessTo X) -> empty for set;
coherence
proof
set F=S-firstChar, L=LettersOf S, Y=(D,phi) AddAsWitnessTo X, s1=F.phi,
phi1=head phi, SS=AllSymbolsOf S, strings=SS*\{{}}, no=
SymbolsOf (strings/\(X\/{phi1})), s2=the Element of L\no,
Z={(s1,s2)-SymbolSubstIn phi1};
defpred P[] means X\/{phi} is D-consistent & L\no <> {};
(P[] implies (X null Z c= X\/Z & Y=X\/Z)) &
((not P[]) implies Y=X null Z) by Def67; hence thesis;
end;
end;

registration
let S,D; let X be functional set; let phi be Element of ExFormulasOf S;
cluster ((D,phi) AddAsWitnessTo X)\X -> trivial for set;
coherence
proof
set F=S-firstChar,L=LettersOf S,SS=AllSymbolsOf S,strings=SS*\{{}},
s1=F.phi, Y=(D,phi) AddAsWitnessTo X, phi1=head phi, no=SymbolsOf
(strings/\(X\/{phi1})),s2=the Element of L\no, Z={(s1,s2)-SymbolSubstIn phi1};
defpred P[] means X\/{phi} is D-consistent & L\no <> {};
(P[] implies Y=X\/Z) & ((not P[]) implies Y=X) by Def67; then
(P[] implies Y\X=Z\X) & ((not P[]) implies Y\X={}) by XBOOLE_1:40;
hence thesis;
end;
end;

definition
let S,D; let X be functional set; let phi be Element of ExFormulasOf S;
redefine func (D,phi) AddAsWitnessTo X -> Subset of (X\/AllFormulasOf S);
coherence
proof
set F=S-firstChar, IT=(D,phi) AddAsWitnessTo X, L=LettersOf S, l1=F.phi,
phi1=head phi, SS=AllSymbolsOf S, strings=SS*\{{}}, FF=AllFormulasOf S,
no=SymbolsOf (strings/\(X\/{phi1})), s2=the Element of (L\no);
defpred P[] means X\/{phi} is D-consistent & L\no<>{};
per cases;
suppose
A1: P[]; then reconsider Y=L\no as non empty set;
s2 in Y & Y c= L; then
reconsider l2=s2 as literal Element of SS;
reconsider psi=(l1,l2)-SymbolSubstIn phi1 as wff string of S;
reconsider psii=psi as Element of FF by FOMODEL2:16;
IT=X\/{psii} by A1,Def67; hence thesis by XBOOLE_1:9;
end;
suppose not P[]; then IT=X null FF by Def67; hence thesis; end;
end;
end;

definition ::def67 1
let S,D;
attr D is Correct means :Def68: for phi, X st
phi is (X,D)-provable holds for U for I being Element of U-InterpretersOf S
st X is I-satisfied holds I-TruthEval phi=1;
end;

Lm52: (D is isotone & R#1(S) in D & R#8(S) in D &
X \/ {phi} is D-inconsistent) implies xnot phi is (X,D)-provable
proof
set XX=X\/{phi},N=TheNorSymbOf S,G1=R#1(S),G8=R#8(S),E1={G1}, E8={G8};assume
A1: D is isotone & G1 in D & G8 in D; then
reconsider F1=E1, F8=E8 as Subset of D by ZFMISC_1:31; assume
XX is D-inconsistent; then consider phi1, phi2 such that
A2: phi1 is (XX,D)-provable & <*N*>^phi1^phi2 is (XX,D)-provable
by Def65;
set nphi1=<*N*>^phi1^phi2; consider H1 being set, m1 being Nat such that
A3: H1 c= XX & [H1,phi1] is (m1,{},D)-derivable by Def62,A2;
consider H2 being set, m2 being Nat such that
A4: H2 c= XX & [H2,nphi1] is (m2,{},D)-derivable by Def62,A2;
reconsider seqt1=[H1,phi1], seqt2=[H2, nphi1] as S-sequent-like set by A3,A4;
seqt1`1 \+\H1= {} & seqt2`1 \+\ H2={}; then reconsider
H11=H1, H22=H2 as S-premises-like Subset of XX by A3,A4,FOMODEL0:29;
reconsider H111=H11\{phi}, H222=H22\{phi} as
S-premises-like Subset of X by XBOOLE_1:43;
H11\H111=H11/\{phi} & H22\H222=H22/\{phi} by XBOOLE_1:48; then reconsider
pH1=H11\H111, pH2=H22\H222 as S-premises-like Subset of {phi};
reconsider H=H11\/H22 as S-premises-like Subset of XX;
reconsider h=H\{phi} as S-premises-like Subset of X by XBOOLE_1:43;
reconsider hp=H/\{phi} as S-premises-like Subset of {phi};
reconsider Phi={phi} as S-premises-like set; set M=m1+m2+1;
reconsider hh=h\/{phi} as S-premises-like set;
reconsider e={} null S as S-sequents-like set;
set x=[hh,phi1], y=[hh, nphi1];
[(H11\/(H22\/Phi)) null (m2+1), phi1] is
(m2+1,{[H11, phi1]},E1)-derivable; then
[H11\/(H22\/{phi}), phi1] is (m1+(m2+1),{},D\/E1)-derivable by A3,Lm21,A1;
then [H\/{phi},phi1] is (m1+m2+1,{},D null F1)-derivable
by XBOOLE_1:4; then [h\/hp\/{phi}, phi1] is
(m1+m2+1,{},D)-derivable by FOMODEL0:48; then
A5: [h\/({phi} null hp), phi1] is (m1+m2+1,{},D)-derivable by XBOOLE_1:4;
[(H22\/(H11\/{phi})) null (m1+1), nphi1] is
(m1+1,{[H22, nphi1]},E1)-derivable; then
[H22\/(H11\/{phi}), nphi1] is (m2+(m1+1),{},D\/E1)-derivable by A4,Lm21,A1;
then [H\/{phi}, nphi1] is (m1+m2+1,{},D null F1)-derivable by XBOOLE_1:4;
then [h\/hp\/{phi}, nphi1] is (m1+m2+1,{},D)-derivable by FOMODEL0:48; then
A6: [h\/({phi} null hp), nphi1] is (m1+m2+1,{},D)-derivable
by XBOOLE_1:4; [h null (phi1^phi2), xnot phi] is
(1,{[h\/{phi},phi1], [h\/{phi}, nphi1]},{R#8(S)})-derivable;
then [h, xnot phi] is
(M+1,e\/e,D\/D\/{R#8(S)})-derivable by A5,A6,Lm48,A1; then
[h,xnot phi] is (M+1,{},D null F8)-derivable;
hence thesis by Def62;
end;

Lm53: X is D-consistent iff
(for Y being finite Subset of X holds Y is D-consistent)
proof
set N=TheNorSymbOf S;
thus X is D-consistent implies for Y being finite Subset of X holds Y is D
-consistent by Th15;
assume A1: for Y being finite Subset of X holds Y is D-consistent;
assume  X is D-inconsistent; then consider phi1, phi2 such that
A2: phi1 is (X,D)-provable & <*N*>^phi1^phi2 is (X,D)-provable by Def65;
reconsider phi=<*N*>^phi1^phi2 as non exal non 0wff wff string of S;
consider H1 being set, m1 being Nat such that
A3: H1 c= X & [H1,phi1] is (m1,{},D)-derivable by Def62,A2;
consider H2 being set, m2 being Nat such that
A4: H2 c= X & [H2,phi] is (m2,{},D)-derivable by Def62,A2;
reconsider seqt1=[H1,phi1], seqt2=[H2,phi] as S-sequent-like set by A3,A4;
seqt1`1 \+\ H1={} & seqt2`1\+\H2={}; then reconsider
H11=H1, H22=H2 as S-premises-like Subset of X by A3,A4,FOMODEL0:29;
A5: phi1 is (H1 null H2,D)-provable by A3,Def62;
phi is (H2 null H1,D)-provable by A4,Def62; then
H11\/H22 is D-inconsistent by A5,Def65; hence contradiction by A1;
end;

Lm54: (R#0(S) in D & X is S-covering & X is D-consistent)
implies (X is S-mincover & X is D-expanded)
proof
set G0=R#0(S), E0={G0}; assume that A1: G0 in D and
A2: X is S-covering & X is D-consistent;
A3: E0 c= D by A1,ZFMISC_1:31;
A4: for phi holds (phi in X implies not xnot phi in X) &
((not phi in X) implies xnot phi in X)
proof
let phi;
hereby
assume phi in X; then phi is (X,{R#0(S)})-provable by Th4;
then phi is (X,D)-provable by A3,Lm49; then not xnot phi is (X,D)-provable
by A2,Def65; then not xnot phi is (X,{R#0(S)})-provable by A3,Lm49;
hence not xnot phi in X by Th4;
end; assume not phi in X; hence xnot phi in X by A2,FOMODEL2:def 40;
end; then
 for phi holds (phi in X iff not xnot phi in X); hence
 X is S-mincover by FOMODEL2:def 34;
now
let x; assume A5: x is (X,D)-provable; then reconsider
phi=x as wff string of S by Lm24; not xnot phi is (X,D)-provable
by A5,A2,Def65; then not xnot phi is (X,E0)-provable by A3,Lm49; then
not xnot phi in X by Th4; hence x in X by A4;
end; hence thesis by Def61;
end;

Lm55: D is isotone & R#1(S) in D & R#8(S) in D & phi is (X,D)-provable
& X is D-consistent implies X\/{phi} is D-consistent
proof
assume A1: D is isotone & R#1(S) in D & R#8(S) in D;
assume phi is (X,D)-provable & X is D-consistent; then
not xnot phi is (X,D)-provable by Def65; hence thesis by Lm52,A1;
end;

Lm56: for I being Element of U-InterpretersOf S st
D is Correct & X is I-satisfied holds X is D-consistent
proof
set N=TheNorSymbOf S; let I being Element of U-InterpretersOf S; assume
A1: D is Correct & X is I-satisfied;
now
given phi1, phi2 such that
A2: phi1 is (X,D)-provable & <*N*>^phi1^phi2 is (X,D)-provable; set
nphi1=<*N*>^phi1^phi2; I-TruthEval phi1=1 & I-TruthEval nphi1=1
by A2,A1,Def68; hence contradiction by FOMODEL2:19;
end; hence thesis by Def65;
end;

registration
let S, t1, t2;
cluster SubTerms (<*TheEqSymbOf S*>^t1^t2) \+\ <*t1, t2*> -> empty for set;
coherence
proof
set E=TheEqSymbOf S; reconsider phi0=<*E*>^t1^t2 as 0wff string of S;
set C=S-multiCat, F=S-firstChar, ST=SubTerms phi0, SS=AllSymbolsOf S,
TT=AllTermsOf S;
reconsider tt3=t1, tt4=t2 as Element of TT by FOMODEL1:def 32;
A1: 2-tuples_on TT={<*tt1, tt2*>: not contradiction} by FINSEQ_2:99;
A2: phi0=<*E*>^(t1^t2) & (<*E*>^(t1^t2)).1 \+\ E={} by FINSEQ_1:32; then
A3: E = phi0.1 by FOMODEL0:29 .= F.phi0 by FOMODEL0:6; then
<*E*>^(C.ST) = <*E*>^(t1^t2) by A2,FOMODEL1:def 38; then
A4: C.ST=t1^t2 by FOMODEL0:41; abs ar E-2+2=0+2; then
ST in 2-tuples_on TT by A3,FOMODEL0:16;
then consider tt1, tt2 such that
A5: ST=<*tt1, tt2*> by A1;
tt1 is Element of SS* & tt2 is Element of SS* & tt3 is Element of SS* &
tt4 is Element of SS* by TARSKI:def 3; then reconsider
tt11=tt1, tt22=tt2, tt33=tt3, tt44=tt4 as SS-valued FinSequence;
C.<*tt11, tt22*> \+\ tt11^tt22 = {}; then
tt11^tt22 = tt33^tt44 by A5,A4,FOMODEL0:29; then
tt11=tt33 & tt22=tt44 by FOMODEL0:def 20;
hence thesis by A5,FOMODEL0:29;
end;
end;

Lm57: for I being (S,U)-interpreter-like Function holds
(I-AtomicEval (<*TheEqSymbOf S*>^t1^t2)=1 iff I-TermEval.t1=I-TermEval.t2)
proof
set E=TheEqSymbOf S, phi0=<*E*>^t1^t2, ST=SubTerms phi0, F=S-firstChar;
phi0=<*E*>^(t1^t2) & (<*E*>^(t1^t2)).1 \+\ E={} by FINSEQ_1:32; then
A1: E=phi0.1 by FOMODEL0:29 .= F.phi0 by FOMODEL0:6;
ST\+\<*t1, t2*>={}; then ST=<*t1, t2*> by FOMODEL0:29; then
ST.1=t1 & ST.2=t2 by FINSEQ_1:44; hence thesis by A1,FOMODEL2:15;
end;

definition
let S; let R be Rule of S;
attr R is Correct means :Def69:
X is S-correct implies R.X is S-correct;
end;

registration
let S;
cluster S-sequent-like -> S-null for set;
coherence;
end;

Lm58: R#0(S) is Correct
proof
now
set f=R#0(S), R=P#0(S), Q=S-sequents; let X; assume X is S-correct;
now
let U; set II=U-InterpretersOf S; let I be Element of II;
let x be I-satisfied set; let phi; set s=[x,phi];
A1: dom R c= bool Q & s`1=x & s`2=phi; assume
A2: [x, phi] in f.X; then
A3: s in Q & [X, s] in R by Lm29; then X in dom R by XTUPLE_0:def 12;
then reconsider XX=X as Subset of Q;
reconsider seqt=s as Element of Q by A2,Lm29;
seqt Rule0 XX by A3,Def31; then phi in x by A1,Def18;
hence I-TruthEval phi=1 by FOMODEL2:def 42;
end; hence f.X is S-correct by FOMODEL2:def 44;
end; hence thesis by Def69;
end;

registration
let S;
cluster R#0(S) -> Correct for Rule of S;
coherence by Lm58;
end;

registration
let S;
cluster Correct for Rule of S;
existence proof take R#0(S); thus thesis; end;
end;

Lm59: R#1(S) is Correct
proof
now
set f=R#1(S), R=P#1(S), Q=S-sequents, E=TheEqSymbOf S, N=TheNorSymbOf S,
FF=AllFormulasOf S, TT=AllTermsOf S, SS=AllSymbolsOf S, F=S-firstChar,
C=S-multiCat;
let X; assume
A1: X is S-correct;
now
let U; set II=U-InterpretersOf S; let I be Element of II;
let x be I-satisfied set; let psi; set s=[x,psi], TE=I-TermEval,
d=U-deltaInterpreter;
A2: s`1 \+\ x={} & s`2 \+\ psi={};
A3: dom R c= bool Q & s`1=x & s`2=psi; assume
A4: s in f.X; then
A5: s in Q & [X, s] in R by Lm29; then X in dom R by XTUPLE_0:def 12;
then reconsider Seqts=X as S-correct Subset of Q by A1;
reconsider seqt=s as Element of Q by A4,Lm29;
seqt Rule1 Seqts by A5,Def32; then consider y such that
A6: y in Seqts & y`1 c= seqt`1 & seqt`2 = y`2 by Def19;
reconsider H=y`1 as Subset of x by A2,A6; [H, psi] in Seqts
by A6,A3,MCART_1:21; hence I-TruthEval psi=1 by FOMODEL2:def 44;
end; hence f.X is S-correct by FOMODEL2:def 44;
end; hence thesis by Def69;
end;

registration
let S;
cluster R#1(S) -> Correct for Rule of S;
coherence by Lm59;
end;

Lm60: R#2(S) is Correct
proof
now
set f=R#2(S), R=P#2(S), Q=S-sequents, E=TheEqSymbOf S, N=TheNorSymbOf S,
FF=AllFormulasOf S, TT=AllTermsOf S, SS=AllSymbolsOf S, F=S-firstChar,
C=S-multiCat;
let X; assume
A1: X is S-correct;
now
let U; set II=U-InterpretersOf S; let I be Element of II;
let x be I-satisfied set; let psi; set s=[x,psi], TE=I-TermEval,
d=U-deltaInterpreter;
A2: s`1 \+\ x={} & s`2 \+\ psi={}; assume
A3: s in f.X; then
A4: s in Q & [X, s] in R by Lm29; then X in dom R by XTUPLE_0:def 12;
then reconsider Seqts=X as S-correct Subset of Q by A1;
reconsider seqt=s as Element of Q by A3,Lm29;
seqt Rule2 Seqts by A4,Def33; then consider t such that
A5: seqt`2 = <* TheEqSymbOf S *> ^ t ^ t  by Def20;
TE.t=TE.t; then I-AtomicEval (<*E*>^t^t) = 1 by Lm57;
hence I-TruthEval psi=1 by A2,A5;
end; hence f.X is S-correct by FOMODEL2:def 44;
end; hence thesis by Def69;
end;

registration let S;
cluster R#2(S) -> Correct for Rule of S;
coherence by Lm60;
end;

Lm61: R#3a(S) is Correct
proof
now
set f=R#3a(S), R=P#3a(S), Q=S-sequents, E=TheEqSymbOf S, N=TheNorSymbOf S,
FF=AllFormulasOf S, TT=AllTermsOf S, SS=AllSymbolsOf S, F=S-firstChar,
C=S-multiCat;
let X; assume
A1: X is S-correct;
now
let U; set II=U-InterpretersOf S; let I be Element of II;
let x be I-satisfied set; let psi; set s=[x,psi], TE=I-TermEval,
d=U-deltaInterpreter;
A2: s`1 \+\ x={} & s`2 \+\ psi={}; assume
A3: s in f.X; then
A4: s in Q & [X, s] in R by Lm29; then X in dom R by XTUPLE_0:def 12;
then reconsider Seqts=X as S-correct Subset of Q by A1;
reconsider seqt=s as Element of Q by A3,Lm29;
seqt Rule3a Seqts by A4,Def34; then consider
t,t1,t2 being termal string of S, y being set such that
A5: (y in Seqts & seqt`1 = y`1 \/ { <* TheEqSymbOf S *> ^ t1 ^ t2 } &
y`2 = <* TheEqSymbOf S *> ^ t ^ t1 & seqt`2 = <* TheEqSymbOf S *> ^ t ^ t2)
by Def21;
reconsider phi1=<*E*>^t^t1, phi2=<*E*>^t^t2, phi=<*E*>^t1^t2 as
0wff string of S;
reconsider gamma=y`1 null {phi}, z={phi} null (y`1) as Subset of x
by A5,A2; [gamma, phi1] in Seqts by A5,MCART_1:21; then
 I-TruthEval phi1=1 by FOMODEL2:def 44; then
A6: phi2=psi & TE.t=TE.t1 by Lm57,A2,A5; z={phi}; then
I-TruthEval phi=1 by FOMODEL2:27; then TE.t2 = TE.t by A6,Lm57; then
I-AtomicEval phi2=1 by Lm57;
hence I-TruthEval psi=1 by A2,A5;
end; hence f.X is S-correct by FOMODEL2:def 44;
end; hence thesis by Def69;
end;

registration let S;
cluster R#3a(S) -> Correct for Rule of S;
coherence by Lm61;
end;

Lm62: R#3b(S) is Correct
proof
now
set f=R#3b(S), R=P#3b(S), Q=S-sequents, E=TheEqSymbOf S, N=TheNorSymbOf S,
FF=AllFormulasOf S, TT=AllTermsOf S, SS=AllSymbolsOf S, F=S-firstChar,
C=S-multiCat;
let X; assume
A1: X is S-correct;
now
let U; set II=U-InterpretersOf S; let I be Element of II;
let x be I-satisfied set; let psi; set s=[x,psi], TE=I-TermEval,
d=U-deltaInterpreter;
A2: s`1 \+\ x={} & s`2 \+\ psi={}; assume
A3: s in f.X; then
A4: s in Q & [X, s] in R by Lm29; then X in dom R by XTUPLE_0:def 12;
then reconsider Seqts=X as S-correct Subset of Q by A1;
reconsider seqt=s as Element of Q by A3,Lm29;
seqt Rule3b Seqts by A4,Def35; then consider
t1,t2 being termal string of S such that
A5: seqt`1 = {<*TheEqSymbOf S*>^t1^t2} & seqt`2 = <*TheEqSymbOf S*>^t2^t1
by Def22; set phi1=<*E*>^t1^t2, phi2=<*E*>^t2^t1;
{phi1} is I-satisfied by A5,A2; then
1 = I-AtomicEval phi1 by FOMODEL2:27;
then TE.t1=TE.t2 by Lm57; then I-AtomicEval phi2=1
& phi2=psi by A5,A2,Lm57; hence I-TruthEval psi=1;
end; hence f.X is S-correct by FOMODEL2:def 44;
end; hence thesis by Def69;
end;

registration let S;
cluster R#3b(S) -> Correct for Rule of S;
coherence by Lm62;
end;

Lm63: R#3d(S) is Correct
proof
now
set f=R#3d(S), R=P#3d(S), Q=S-sequents, E=TheEqSymbOf S, N=TheNorSymbOf S,
FF=AllFormulasOf S, TT=AllTermsOf S, SS=AllSymbolsOf S, F=S-firstChar,
C=S-multiCat;
let X; assume
A1: X is S-correct;
now
let U; set II=U-InterpretersOf S; let I be Element of II;
let x be I-satisfied set; let psi; set s=[x,psi], TE=I-TermEval,
d=U-deltaInterpreter;
A2: s`1 \+\ x={} & s`2 \+\ psi={}; assume
A3: s in f.X; then
A4: s in Q & [X, s] in R by Lm29; then X in dom R by XTUPLE_0:def 12;
then reconsider Seqts=X as S-correct Subset of Q by A1;
reconsider seqt=s as Element of Q by A3,Lm29;
seqt Rule3d Seqts by A4,Def36; then consider
r being low-compounding Element of S,
T1, T2 being (abs ar r)-element Element of TT* such that
A5: r is operational &
seqt`1 = {<*E*>^(TT1.j)^(TT2.j) where j is Element of Seg (abs ar r),
TT1,TT2 is Function of Seg (abs ar r), SS*\{{}} : TT1=T1 & TT2=T2}
& seqt`2=<*E*>^(r-compound T1)^(r-compound T2) by Def23;
reconsider t1=r-compound T1, t2=r-compound T2 as termal string of S by A5;
t1.1 \+\ r={} & t2.1 \+\ r={}; then t1.1=r & t2.1=r by FOMODEL0:29; then
A6: F.t1=r & F.t2=r by FOMODEL0:6; then SubTerms t1=T1 & SubTerms t2=T2
by FOMODEL1:def 37; then
A7: TE.t1=I.r.(TE*T1) & TE.t2=I.r.(TE*T2) by A6,FOMODEL2:21;
reconsider Fam={<*E*>^(TT1.j)^(TT2.j) where j is Element of Seg (abs ar r),
TT1,TT2 is Function of Seg (abs ar r), SS*\{{}} : TT1=T1 & TT2=T2} null {}
as Subset of x by A5,A2;
now
set p=TE*T1, q=TE*T2; len p=abs ar r by CARD_1:def 7; hence
len q= len p by CARD_1:def 7; let k; assume
A8: 1<=k & k<=len p; then
A9: 1<=k & k<=abs ar r by CARD_1:def 7;
then reconsider kk=k as Element of Seg (abs ar r) by FINSEQ_1:1;
k-k <= abs ar r - k by A9,XREAL_1:9; then
reconsider h=abs ar r - k as Nat; reconsider k1=k as non zero Nat
by A8;
dom (T1 null 0)=Seg (abs ar r+0) & rng T1 c= SS*\{{}} &
dom (T2 null 0)=Seg (abs ar r+0) & rng T2 c= SS*\{{}}
by PARTFUN1:def 2,RELAT_1:def 19; then
T1 is Element of Funcs (Seg abs ar r, SS*\{{}}) &
T2 is Element of Funcs (Seg abs ar r, SS*\{{}}) by FUNCT_2:def 2; then
reconsider TT1=T1, TT2=T2 as Function of Seg abs ar r, SS*\{{}};
T1 is (k1+h)-element & T2 is (k1+h)-element; then
{T1.k1}\TT={} & {T2.k1}\TT={}; then T1.k in TT & T2.k in TT by ZFMISC_1:60;
then reconsider t1=T1.k, t2=T2.k as termal string of S;
reconsider z=<*E*>^t1^t2 as 0wff string of S;
TE.(TT1.kk) \+\ (TE*TT1).kk={} & TE.(TT2.kk)\+\(TE*TT2).kk={}; then
A10: TE.(TT1.kk) = (TE*TT1).kk & TE.(TT2.kk) = (TE*TT2).kk by FOMODEL0:29;
set ST=<*t1, t2*>;
<*E*>^TT1.kk^TT2.kk in Fam; then I-TruthEval z=1 by FOMODEL2:def 42;
hence p.k=q.k by A10,Lm57;
end; then
TE.t1=TE.t2 by A7,FINSEQ_1:14; then I-AtomicEval (<*E*>^t1^t2)=1 &
psi=<*E*>^t1^t2 by Lm57,A2,A5; hence I-TruthEval psi=1;
end; hence f.X is S-correct by FOMODEL2:def 44;
end; hence thesis by Def69;
end;

registration
let S;
cluster R#3d(S) -> Correct for Rule of S;
coherence by Lm63;
end;

Lm64: R#3e(S) is Correct
proof
now
set f=R#3e(S), R=P#3e(S), Q=S-sequents, E=TheEqSymbOf S, N=TheNorSymbOf S,
FF=AllFormulasOf S, TT=AllTermsOf S, SS=AllSymbolsOf S, F=S-firstChar,
C=S-multiCat;
let X; assume
A1: X is S-correct;
now
let U; set II=U-InterpretersOf S; let I be Element of II;
let x be I-satisfied set; let psi; set s=[x,psi], TE=I-TermEval,
d=U-deltaInterpreter;
A2: s`1 \+\ x={} & s`2 \+\ psi={}; assume
A3: s in f.X; then
A4: s in Q & [X, s] in R by Lm29; then X in dom R by XTUPLE_0:def 12;
then reconsider Seqts=X as S-correct Subset of Q by A1;
reconsider seqt=s as Element of Q by A3,Lm29;
seqt Rule3e Seqts by A4,Def37; then consider
r being relational Element of S,
T1, T2 being (abs ar r)-element Element of TT* such that
A5: (seqt`1={r-compound(T1)} \/
{<*E*>^(TT1.j)^(TT2.j) where j is Element of Seg (abs ar r),
TT1,TT2 is Function of Seg (abs ar r), SS*\{{}} : TT1=T1 & TT2=T2}
& seqt`2=r-compound(T2)) by Def24;
reconsider psi0=psi as 0wff string of S by A2,A5;
reconsider phi1=r-compound(T1) as 0wff string of S;
reconsider rr=F.psi0 as relational Element of S;
reconsider Fam=
{<*E*>^(TT1.j)^(TT2.j) where j is Element of Seg (abs ar r),
TT1,TT2 is Function of Seg (abs ar r), SS*\{{}} : TT1=T1 & TT2=T2} null
{phi1} as Subset of x by A5,A2;
(<*r*>^C.T1).1\+\r={} & (<*r*>^C.T2).1\+\r={}; then (<*r*>^C.T1).1=r &
(<*r*>^C.T2).1=r & psi0=<*r*>^(C.T2) by A5,A2,FOMODEL0:29; then
A6: F.phi1=r & rr=r & psi0=<*r*>^C.T2 by FOMODEL0:6; then
A7: T1=SubTerms phi1 & T2=SubTerms psi0 by FOMODEL1:def 38; reconsider
y={phi1} null Fam as Subset of x by A5,A2;
A8: {phi1}=y;
A9: now
set p=TE*T1, q=TE*T2; len p=abs ar r by CARD_1:def 7; hence
len q= len p by CARD_1:def 7; let k; assume
A10: 1<=k & k<=len p; then
A11: 1<=k & k<=abs ar r by CARD_1:def 7;
then reconsider kk=k as Element of Seg (abs ar r) by FINSEQ_1:1;
k-k <= abs ar r - k by A11,XREAL_1:9; then
reconsider h=abs ar r - k as Nat; reconsider k1=k as non zero Nat
by A10;
dom (T1 null 0)=Seg (abs ar r+0) & rng T1 c= SS*\{{}} &
dom (T2 null 0)=Seg (abs ar r+0) & rng T2 c= SS*\{{}}
by PARTFUN1:def 2,RELAT_1:def 19; then
T1 is Element of Funcs (Seg abs ar r, SS*\{{}}) &
T2 is Element of Funcs (Seg abs ar r, SS*\{{}}) by FUNCT_2:def 2; then
reconsider TT1=T1, TT2=T2 as Function of Seg abs ar r, SS*\{{}};
T1 is (k1+h)-element & T2 is (k1+h)-element; then
{T1.k1}\TT={} & {T2.k1}\TT={}; then T1.k in TT & T2.k in TT by ZFMISC_1:60;
then reconsider t1=T1.k, t2=T2.k as termal string of S;
reconsider z=<*E*>^t1^t2 as 0wff string of S;
TE.(TT1.kk) \+\ (TE*TT1).kk={} & TE.(TT2.kk)\+\(TE*TT2).kk={}; then
A12: TE.(TT1.kk) = (TE*TT1).kk & TE.(TT2.kk) = (TE*TT2).kk by FOMODEL0:29;
set ST=<*t1, t2*>; <*E*>^TT1.kk^TT2.kk in Fam; then
I-TruthEval z=1 by FOMODEL2:def 42; hence p.k=q.k by A12,Lm57;
end;
per cases;
suppose  rr=E; I-AtomicEval psi0 =
 I-AtomicEval phi1 by A6,A9,A7,FINSEQ_1:14;
hence I-TruthEval psi=1 by A8,FOMODEL2:27;
end;
suppose  rr<>E; I-AtomicEval psi0 =
I-AtomicEval phi1 by A6,A9,A7,FINSEQ_1:14;
hence I-TruthEval psi=1 by A8,FOMODEL2:27;
end;
end; hence f.X is S-correct by FOMODEL2:def 44;
end; hence thesis by Def69;
end;

registration
let S;
cluster R#3e(S) -> Correct for Rule of S;
coherence by Lm64;
end;

Lm65: R#4(S) is Correct
proof
now
set f=R#4(S), R=P#4(S), Q=S-sequents, E=TheEqSymbOf S, N=TheNorSymbOf S,
FF=AllFormulasOf S, TT=AllTermsOf S, SS=AllSymbolsOf S, F=S-firstChar;
let X; assume
A1: X is S-correct;
now
let U; set II=U-InterpretersOf S; let I be Element of II;
let x be I-satisfied set; let psi;
set s=[x,psi];
A2: s`1 \+\ x={} & s`2 \+\ psi={}; assume
A3: s in f.X; then
A4: s in Q & [X, s] in R by Lm29; then X in dom R by XTUPLE_0:def 12;
then reconsider Seqts=X as S-correct Subset of Q by A1;
reconsider seqt=s as Element of Q by A3,Lm29;
seqt Rule4 Seqts by A4,Def38; then consider
l being literal Element of S, phi being wff string of S,
t being termal string of S such that
A5: seqt`1={(l,t) SubstIn phi} & seqt`2=<*l*>^phi by Def25;
reconsider tt=t as Element of TT by FOMODEL1:def 32;
reconsider phii=(l,tt) SubstIn phi as wff string of S;
reconsider u=I-TermEval.tt as Element of U;
reconsider I1=(l,u) ReassignIn I as Element of II;
A6: x={phii} & psi=<*l*>^phi by A5,A2; then
1 = I-TruthEval phii by FOMODEL2:27 .= I1-TruthEval phi by FOMODEL3:10; hence
I-TruthEval psi=1 by A6,FOMODEL2:19;
end; hence f.X is S-correct by FOMODEL2:def 44;
end; hence thesis by Def69;
end;

registration
let S;
cluster R#4(S) -> Correct for Rule of S;
coherence by Lm65;
end;

Lm66: R#5(S) is Correct
proof
now
set f=R#5(S), R=P#5(S), Q=S-sequents, E=TheEqSymbOf S, N=TheNorSymbOf S,
FF=AllFormulasOf S, TT=AllTermsOf S, SS=AllSymbolsOf S, F=S-firstChar,
O=OwnSymbolsOf S; let X; assume
A1: X is S-correct;
now
let U; set II=U-InterpretersOf S; let I be Element of II;
let x be I-satisfied set; let psi;
set s=[x,psi];
A2: s`1 \+\ x={} & s`2 \+\ psi={};
A3: dom R c= bool Q & s`1=x & s`2=psi; assume
A4: s in f.X; then
A5: s in Q & [X, s] in R by Lm29; then X in dom R by XTUPLE_0:def 12;
then reconsider Seqts=X as S-correct Subset of Q by A1;
reconsider seqt=s as Element of Q by A4,Lm29;
seqt Rule5 Seqts by A5,Def39; then consider v1,v2 being
literal Element of S, y,p such that
A6: seqt`1=y \/ {<*v1*>^p} & v2 is (y\/{p}\/{seqt`2})-absent &
[y\/{(v1 SubstWith v2).p},seqt`2] in Seqts by Def26;
{<*v1*>^p} null y c= FF by A6,Def64; then
<*v1*>^p in FF by ZFMISC_1:31;
then reconsider phi1=<*v1*>^p as wff string of S;
v1 \+\ phi1.1={}; then
A7: v1= phi1.1 by FOMODEL0:29 .= F.phi1 by FOMODEL0:6; then
reconsider phi1 as non 0wff exal wff string of S by FOMODEL2:def 32;
reconsider phi=head phi1 as wff string of S;
{psi} null (y\/{phi})={psi}; then
reconsider Psi={psi} as non empty Subset of y\/{phi}\/{psi};
{phi} null (y\/{psi}) is Subset of y\/{phi}\/{psi}  by XBOOLE_1:4;
then reconsider Phi={phi} as non empty Subset of y\/{phi}\/{psi};
y \/ ({phi}\/{psi}) = y\/{phi}\/{psi} by XBOOLE_1:4; then
y null ({phi}\/{psi}) c= y\/{phi}\/{psi}; then reconsider
yyy=y as Subset of (y\/{phi}\/{psi});
A8: phi1 = <*v1*>^phi^(tail phi1) by A7,FOMODEL2:23 .= <*v1*>^phi; then
A9: phi=p by FOMODEL0:41; then
A10: v2 is (Psi null (y\/{phi}\/{psi}))-absent &
v2 is (Phi null (y\/{phi}\/{psi}))-absent &
v2 is (yyy null (y\/{phi}\/{psi}))-absent by A6,A3;
reconsider phi2=(v1, v2)-SymbolSubstIn phi as wff string of S;
reconsider yy=y null {phi1}, z={phi1} null y as I-satisfied Subset of x
by A6,A2;
z={phi1}; then I-TruthEval phi1=1 by FOMODEL2:27; then consider u such that
A11: 1 = (v1,u) ReassignIn I-TruthEval phi by A8,FOMODEL2:19;
set f2=v2.-->({}.-->u); reconsider
I1 =(v1,u) ReassignIn I, I2=(v2,u) ReassignIn I as Element of II;
not v2 in rng phi by A10,FOMODEL2:28; then
I2-TruthEval phi2 = 1 by A11,FOMODEL3:9; then reconsider
z2={phi2} as I2-satisfied set by FOMODEL2:27; not v2 in rng psi
by A10,FOMODEL2:28; then {v2} misses rng psi by ZFMISC_1:50; then
A12: dom f2 misses rng psi by FUNCOP_1:13;
I2|(rng psi)=I|(rng psi) +* f2|(rng psi) by FUNCT_4:71
     .= I|(rng psi) +* {} by A12,RELAT_1:66
     .= I|(rng psi);
      then
A13: I|(rng psi/\O) = I2|(rng psi)|O by RELAT_1:71.= I2|(rng psi/\O)
by RELAT_1:71; v2 is yyy-absent & yy is I-satisfied by A9,A6,A3;
then reconsider
yyyy=yyy as I2-satisfied Subset of x by FOMODEL3:14; reconsider
zz = yyyy\/z2 as I2-satisfied set; [zz,psi] in Seqts
by A6,A9,A3,FOMODEL0:def 23; hence 1 =
I2-TruthEval psi by FOMODEL2:def 44 .= I-TruthEval psi by A13,FOMODEL3:13;
end; hence f.X is S-correct by FOMODEL2:def 44;
end; hence thesis by Def69;
end;

registration
let S;
cluster R#5(S) -> Correct for Rule of S;
coherence by Lm66;
end;

Lm67: R#6(S) is Correct
proof
now
set f=R#6(S), R=P#6(S), Q=S-sequents, E=TheEqSymbOf S, N=TheNorSymbOf S;
let X; assume
A1: X is S-correct;
now
let U; set II=U-InterpretersOf S; let I be Element of II;
let x be I-satisfied set; let psi;
set s=[x,psi];
A2: dom R c= bool Q & s`1=x & s`2=psi; assume
A3: s in f.X; then
A4: s in Q & [X, s] in R by Lm29; then X in dom R by XTUPLE_0:def 12;
then reconsider Seqts=X as S-correct Subset of Q by A1;
reconsider seqt=s as Element of Q by A3,Lm29;
seqt Rule6 Seqts by A4,Def40; then consider y1,y2 being set,
phi1, phi2 being wff string of S such that
A5: y1 in Seqts & y2 in Seqts & y1`1 = y2`1 & y2`1=seqt`1 &
y1`2= <*TheNorSymbOf S*> ^ phi1 ^ phi1 &
y2`2=  <*TheNorSymbOf S*> ^ phi2 ^ phi2 &
seqt`2 = <*TheNorSymbOf S*> ^ phi1 ^ phi2 by Def27;
[x,<*N*>^phi1^phi1] in Seqts & [x,<*N*>^phi2^phi2] in Seqts & psi =
<*N*>^phi1^phi2 by A5,A2,MCART_1:21; then I-TruthEval
(<*N*>^phi1^phi1)=1 & I-TruthEval (<*N*>^phi2^phi2)=1 by FOMODEL2:def 44;
then I-TruthEval phi1=0 & I-TruthEval phi2=0 by FOMODEL2:19;
hence I-TruthEval psi=1 by A5,A2,FOMODEL2:19;
end; hence f.X is S-correct by FOMODEL2:def 44;
end; hence thesis by Def69;
end;

registration let S;
cluster R#6(S) -> Correct for Rule of S;
coherence by Lm67;
end;

Lm68: R#7(S) is Correct
proof
now
set f=R#7(S), R=P#7(S), Q=S-sequents, E=TheEqSymbOf S, N=TheNorSymbOf S;
let X; assume
A1: X is S-correct;
now
let U; set II=U-InterpretersOf S; let I be Element of II;
let x be I-satisfied set; let psi;
set s=[x,psi];
A2: dom R c= bool Q & s`1=x & s`2=psi; assume
A3: s in f.X; then
A4: s in Q & [X, s] in R by Lm29; then X in dom R by XTUPLE_0:def 12;
then reconsider Seqts=X as S-correct Subset of Q by A1;
reconsider seqt=s as Element of Q by A3,Lm29;
seqt Rule7 Seqts by A4,Def41; then consider y being set,
phi1, phi2 being wff string of S such that
A5: y in Seqts & y`1 = seqt`1 & y`2 =<* TheNorSymbOf S*> ^ phi1 ^ phi2 &
seqt`2 = <* TheNorSymbOf S*> ^ phi2 ^ phi1 by Def28;
 psi=<*N*>^phi2^phi1 & [x,<*N*>^phi1^phi2] in Seqts by A2,A5,MCART_1:21;
then I-TruthEval (<*N*>^phi1^phi2)=1 by FOMODEL2:def 44; then
I-TruthEval phi1=0 & I-TruthEval phi2=0 by FOMODEL2:19; hence
I-TruthEval psi=1 by A2,A5,FOMODEL2:19;
end; hence f.X is S-correct by FOMODEL2:def 44;
end; hence thesis by Def69;
end;

registration let S;
cluster R#7(S) -> Correct for Rule of S;
coherence by Lm68;
end;

Lm69: R#8(S) is Correct
proof
now
set f=R#8(S), R=P#8(S), Q=S-sequents, E=TheEqSymbOf S, N=TheNorSymbOf S;
let X; assume
A1: X is S-correct;
now
let U; set II=U-InterpretersOf S; let I be Element of II;
let x be I-satisfied set; let psi;
set s=[x,psi];
A2: s`1 \+\ x={} & s`2 \+\ psi={}; assume
A3: s in f.X; then
A4: s in Q & [X, s] in R by Lm29; then X in dom R by XTUPLE_0:def 12;
then reconsider Seqts=X as S-correct Subset of Q by A1;
reconsider seqt=s as Element of Q by A3,Lm29;
seqt Rule8 Seqts by A4,Def42; then consider y1,y2 being set,
phi,phi1,phi2 being wff string of S such that
A5: y1 in Seqts & y2 in Seqts & y1`1=y2`1 & y1`2=phi1 &
y2`2 = <* TheNorSymbOf S *> ^ phi1 ^ phi2 &
{phi}\/seqt`1=y1`1 & seqt`2= <* TheNorSymbOf S *> ^ phi ^ phi by Def29;
reconsider Seqts as non empty Subset of Q by A5;
reconsider seqt1=y1, seqt2=y2 as Element of Seqts by A5;
reconsider H=seqt1`1 as S-premises-like set;
A6: {phi}\/x=H & psi=<*N*>^phi^phi by A5,A2;
now
assume I-TruthEval phi=1; then reconsider H1={phi} as I-satisfied set
by FOMODEL2:27; H1\/x is I-satisfied; then reconsider H2=H as
I-satisfied set by A5,A2;
[H2,phi1] in Seqts & [H2,<*N*>^phi1^phi2] in Seqts
by A5,MCART_1:21; then I-TruthEval phi1=1 &
I-TruthEval (<*N*>^phi1^phi2) = 1 by FOMODEL2:def 44;
hence contradiction by FOMODEL2:19;
end; then I-TruthEval phi=0 by FOMODEL0:39; hence
I-TruthEval psi=1 by A6,FOMODEL2:19;
end; hence f.X is S-correct by FOMODEL2:def 44;
end; hence thesis by Def69;
end;

registration let S;
cluster R#8(S) -> Correct for Rule of S;
coherence by Lm69;
end;

theorem Th16:
(for R being Rule of S st R in D holds R is Correct) implies D is Correct
proof
set Q=S-sequents, O=OneStep D; {} null S is S-correct; then
reconsider e={} null Q as S-correct Subset of Q;
A1: dom O=bool Q by FUNCT_2:def 1;
reconsider RO=rng O as Subset of bool Q by RELAT_1:def 19;
assume
A2: for R being Rule of S st R in D holds R is Correct;
defpred P[Nat] means for X being S-correct Subset of Q holds
($1,D)-derivables.X is S-correct;
A3: P[0]
proof
set f=(0,D)-derivables;
A4: f = id field O by FUNCT_7:68
     .= id (bool Q\/RO) by A1
     .= id bool Q;
    let X be S-correct Subset of Q;
(id(bool Q)).X \+\ X={}; hence thesis by A4,FOMODEL0:29;
end;
A5: for n st P[n] holds P[n+1]
proof
let n; assume
A6: P[n]; let X be S-correct Subset of Q;
set DM=(n+1,D)-derivables, Dm=(n,D)-derivables;
A7: dom Dm=bool Q by FUNCT_2:def 1;
reconsider oldSeqs=Dm.X as S-correct Subset of Q by A6;
A8: DM=O*Dm by FUNCT_7:71;
now
let U; set II=U-InterpretersOf S; let I be Element of II;
let H be I-satisfied set; let phi;
assume
A9: [H,phi] in DM.X;
set Fam={R.:{oldSeqs} where R is Subset of [:bool Q, bool Q:]: R in D};
DM.X=O.oldSeqs by A7,A8,FUNCT_1:13 .=
union union Fam by Lm6; then consider x such that
A10: [H,phi] in x & x in union Fam by A9,TARSKI:def 4; consider y such that
A11: x in y & y in Fam by A10,TARSKI:def 4; consider R being Subset of
[:bool Q, bool Q:] such that
A12: y=R.:{oldSeqs} & R in D by A11; reconsider RR=R as Correct Rule of S
by A2,A12; reconsider newSeqs=RR.oldSeqs as S-correct Subset of Q by Def69;
dom RR=bool Q by FUNCT_2:def 1; then
y=Im(R,oldSeqs) & Im(RR,oldSeqs)= {RR.oldSeqs} by A12,FUNCT_1:59; then
[H,phi] in newSeqs by A10,A11,TARSKI:def 1;
hence I-TruthEval phi = 1 by FOMODEL2:def 44;
end; hence thesis by FOMODEL2:def 44;
end;
A13: for n holds P[n] from NAT_1:sch 2(A3, A5);
now
let phi; let X; assume phi is (X,D)-provable; then
consider H being set, m such that
A14: H c= X & [H,phi] is (m,{},D)-derivable by Def62;
reconsider HH=H as Subset of X by A14;
reconsider seqt=[H,phi] as Element of Q by Def2,A14;
reconsider okSeqs=(m,D)-derivables.e as S-correct Subset of Q by A13;
hereby
let U; set II=U-InterpretersOf S; let I be Element of II; assume
X is I-satisfied; then reconsider XX=X as I-satisfied set;
reconsider HHH=HH as I-satisfied Subset of XX;
[HHH,phi] in okSeqs by A14,Def7;
hence I-TruthEval phi=1 by FOMODEL2:def 44;
end;
end; hence D is Correct by Def68;
end;

registration let S; let R be Correct Rule of S;
cluster {R} -> Correct for RuleSet of S;
coherence
proof
set D={R};
for P being Rule of S st P in D holds P is Correct by TARSKI:def 1;
hence thesis by Th16;
end;
end;

registration
let S;
cluster S-rules -> Correct for RuleSet of S;
coherence
proof
set A={R#0(S), R#1(S), R#2(S), R#3a(S), R#3b(S), R#3d(S), R#3e(S), R#4(S)},
B={R#5(S), R#6(S), R#7(S), R#8(S)}, IT=S-rules;
now
let P be Rule of S; assume P in IT; then P in A or P in B by XBOOLE_0:def 3;
hence P is Correct by ENUMSET1:def 2,def 6;
end; hence thesis by Th16;
end;
end;

registration let S;
cluster R#9(S) -> isotone for Rule of S;
coherence
proof
set R=R#9(S), Q=S-sequents;
now
let Seqts, Seqts2; set X=Seqts, Y=Seqts2; assume
A1: X c= Y;
now
let x; assume
A2: x in R.X; then
A3: x in Q & [X,x] in P#9(S) by Lm29;
reconsider seqt=x as Element of Q by A2; seqt Rule9 X by A3,Def43;
then consider y being set, phi being wff string of S such that
A4: y in Seqts & seqt`2=phi & y`1=seqt`1 & y`2=xnot (xnot phi) by Def30;
seqt Rule9 Y by A4,Def30,A1; then [Y,seqt] in P#9(S) by Def43;
hence x in R.Y by Th2;
end;
hence R.X c= R.Y by TARSKI:def 3;
end;
hence thesis by Def9;
end;
end;

registration let S,H,phi;
cluster [H, phi] null 1 -> (1,{[H, xnot (xnot phi)]},{R#9(S)})-derivable for
set;
coherence
proof
set N=TheNorSymbOf S, nphi=xnot phi, phii=xnot nphi,
y=[H,phii], SQ={y}, Sq=[H,phi], Q=S-sequents;
reconsider seqt=Sq as Element of Q by Def2;
reconsider Seqts=SQ as Element of bool Q by Def3;
seqt`2 \+\ phi={} & y`1\+\H={} & seqt`1\+\H={} & y`2 \+\ phii={}; then
seqt`2=phi & y`1=H & seqt`1=H & y`2=phii by FOMODEL0:29; then
y`1=seqt`1 & seqt`2=phi & y`2=phii & y in Seqts by TARSKI:def 1;
then seqt Rule9 Seqts by Def30; then [Seqts,seqt] in P#9(S) by Def43;
then Sq in (R#9(S)).SQ by Th2; hence thesis by Lm50;
end;
end;

registration
let X, S;
cluster X-implied for 0-wff string of S;
existence
proof
set E=TheEqSymbOf S, t=the termal string of S, phi=<*E*>^t^t; take phi;
now
let U; set II=U-InterpretersOf S; let I be Element of II; assume
X is I-satisfied; set TE=I-TermEval; TE.t=TE.t;
hence I-TruthEval phi=1 by Lm57;
end; hence thesis by FOMODEL2:def 45;
end;
end;

registration let X, S;
cluster X-implied for wff string of S;
existence proof take the X-implied 0-wff string of S; thus thesis; end;
end;

registration let S, X; let phi be X-implied wff string of S;
cluster xnot xnot phi -> X-implied for wff string of S;
coherence
proof
now
let U; set II=U-InterpretersOf S; let I be Element of II;
set v=I-TruthEval phi, phi1=xnot phi, phi2=xnot phi1,
v1=I-TruthEval phi1, v2=I-TruthEval phi2;
'not' v \+\ v1={} & 'not' v1 \+\ v2={}; then
A1: v1='not' v & v2='not' v1 by FOMODEL0:29; assume X is I-satisfied;
hence v2=1 by A1,FOMODEL2:def 45;
end; hence thesis by FOMODEL2:def 45;
end;
end;

definition
let X, S, phi;
attr phi is X-provable means :Def70:
phi is (X,{R#9(S)}\/S-rules)-provable;
end;

begin
::# constructions for countable languages
::# witness adjoining
definition
let X be functional set; let S,D;
let num be Function of NAT, ExFormulasOf S;
set SS=AllSymbolsOf S, EF=ExFormulasOf S, FF=AllFormulasOf S, Y=X\/FF,
DD=bool Y;
func (D,num) AddWitnessesTo X -> Function of NAT, bool (X\/AllFormulasOf S)
means :Def71:
it.0=X & for mm holds it.(mm+1)=(D, num.mm) AddAsWitnessTo (it.mm);
existence
proof
reconsider Z=X null FF as Element of DD;
deffunc F(Nat, Element of DD)= (Y typed/\ ((D,num.$1) AddAsWitnessTo $2));
consider f being Function of NAT, DD such that
A1: f.0=Z & for n holds f.(n+1)=F(n,f.n qua Element of DD)
from NAT_1:sch 12; take f;
now
let n; reconsider nn=n as Element of NAT by ORDINAL1:def 12;
A2: ((D,num.nn) AddAsWitnessTo f.nn) c= FF\/(f.nn) & FF\/(f.nn) c= FF\/Y
by XBOOLE_1:9; FF\/Y=FF\/FF\/X by XBOOLE_1:4 .= Y; then reconsider A=
(D,num.nn) AddAsWitnessTo f.nn as Subset of Y by A2,XBOOLE_1:1; f.(n+1)
= A null Y by A1; hence f.(n+1)=(D,num.n) AddAsWitnessTo f.n;
end; hence thesis by A1;
end;
uniqueness
proof
deffunc F(Nat, Element of DD) = (D,num.$1) AddAsWitnessTo $2;
let IT1, IT2 be Function of NAT, DD; assume that
A3: IT1.0=X and
A4: for mm holds IT1.(mm+1)=F(mm,IT1.mm qua Element of DD) and
A5: IT2.0=X and
A6: for mm holds IT2.(mm+1)=F(mm,IT2.mm qua Element of DD);
A7: for m holds IT1.(m+1)=F(m,IT1.m qua Element of DD)
proof
let m; reconsider mm=m as Element of NAT by ORDINAL1:def 12;
IT1.(mm+1)=F(mm,IT1.mm qua Element of DD) by A4; hence thesis;
end;
A8: for m holds IT2.(m+1)=F(m,IT2.m qua Element of DD)
proof
let m; reconsider mm=m as Element of NAT by ORDINAL1:def 12;
IT2.(mm+1)=F(mm,IT2.mm qua Element of DD) by A6; hence thesis;
end;
A9: dom IT1=NAT by FUNCT_2:def 1;
A10: dom IT2=NAT by FUNCT_2:def 1;
thus IT1=IT2 from NAT_1:sch 15(A9,A3,A7,A10,A5,A8);
end;
end;

notation
let X be functional set; let S,D;
let num be Function of NAT, ExFormulasOf S;
synonym (D,num) addw X for (D,num) AddWitnessesTo X;
end;

Lm70: D is isotone & R#1(S) in D & R#8(S) in D & R#2(S) in D & R#5(S) in D &
X\/{(l1,l2)-SymbolSubstIn phi} is D-inconsistent &
l2 is (X\/{phi})-absent implies X\/{<*l1*>^phi} is D-inconsistent
proof
set E=TheEqSymbOf S, L=LettersOf S, SS=AllSymbolsOf S, Q=S-sequents,
psi=(l1,l2)-SymbolSubstIn phi, E1=R#1(S), E2=R#2(S), E5=R#5(S);
set ll = the Element of rng phi /\ L; ll in L by TARSKI:def 3; then
reconsider l=ll as literal Element of S;
reconsider t=<*l*> as termal string of S; set N=TheNorSymbOf S;
reconsider yes=<*E*>^t^t as 0wff string of S;
A1: rng yes=rng(<*E*>^t)\/ rng t by FINSEQ_1:31 .=
rng <*E*> \/ rng t \/ rng t by FINSEQ_1:31 .= rng <*E*> \/ (rng t \/ rng t)
by XBOOLE_1:4 .= {E} \/ rng t by FINSEQ_1:38 .= {E} \/ {l} by FINSEQ_1:38;
reconsider lll=ll as Element of rng phi by XBOOLE_0:def 4;
A2: {lll} \/ {E,N} c= rng phi \/ {E,N} by XBOOLE_1:9;
reconsider no=xnot yes as wff string of S;
A3: rng no = rng (<*N*>^yes) \/ rng yes by FINSEQ_1:31 .=
rng <*N*> \/ rng yes
\/ rng yes by FINSEQ_1:31 .= rng <*N*> \/ (rng yes \/ rng yes)
by XBOOLE_1:4 .= {N} \/ rng yes by FINSEQ_1:38 .=
{E}\/{N}\/{l} by A1,XBOOLE_1:4 .= {E,N} \/ {l} by ENUMSET1:1; assume
A4: D is isotone & R#1(S) in D & R#8(S) in D & R#2(S) in D & R#5(S) in D &
X\/{psi} is D-inconsistent; then no is (X\/{psi},D)-provable by Th13;
then consider H3 being set, m such that
A5: H3 c= X\/{psi} & [H3,no] is (m,{},D)-derivable by Def62;
reconsider seqt1=[H3,no] as Element of Q by Def2,A5;
seqt1`1 \+\ H3={}; then reconsider
H33=H3 as S-premises-like Subset of (X\/{psi}) by A5,FOMODEL0:29;
reconsider H1=H33/\X as S-premises-like Subset of X;
reconsider H2=H33/\{psi} as S-premises-like Subset of {psi};
{phi} null X c= X\/{phi} & X null {phi} c= X\/{phi}; then
reconsider XX=X, Phi={phi} as Subset of X\/{phi};
reconsider H11=H1 as S-premises-like Subset of XX;
reconsider NO={no}, Phii={phi} as Subset of SS*\{{}};
assume
A6: l2 is (X\/{phi})-absent; then
A7: l2 is XX-absent & l2 is Phi-absent; then not l2 in
SymbolsOf ((SS*\{{}})/\Phii) by FOMODEL2:def 38; then
not l2 in rng phi & not l2 in {E,N} by FOMODEL0:45,TARSKI:def 2; then
not l2 in rng no by A3,A2,XBOOLE_0:def 3; then
not l2 in SymbolsOf ((SS*\{{}})/\NO) by FOMODEL0:45; then
reconsider ln=l2 as {no}-absent (Element of S) by FOMODEL2:def 38;
reconsider lN=ln as ({phi}\/{no})-absent literal Element of S by A7;
lN is H11-absent by A6; then
reconsider lx=lN as (H11\/({phi}\/{no}))-absent literal Element of S;
H11\/({phi}\/{no})= H1\/{phi}\/{no} by XBOOLE_1:4; then
lx is (H1\/{phi}\/{no})-absent; then
reconsider l22=l2 as (H1\/{phi}\/{no})-absent literal Element of S;
reconsider F2={E2}, F1={E1}, F5={E5} as Subset of D by A4,ZFMISC_1:31;
A8: D\/(F1\/F5)=D & F2 c= D & {} c= X\/{<*l1*>^phi} &
H1\/{<*l1*>^phi} c= X\/{<*l1*>^phi} by XBOOLE_1:2,9;
A9: H33 null (X\/{psi}) =  H1 \/ H2 by XBOOLE_1:23;
A10: [(H1\/{<*l1*>^phi}) null l22, no] is
(1,{[H1\/{psi}, no]},{R#5(S)})-derivable;
[H1\/H2\/{psi}, no] is (1,{[H1\/H2,no]},{R#1(S)})-derivable; then
[H1\/({psi} null H2),no] is (1,{[H33, no]},{R#1(S)})-derivable
by A9,XBOOLE_1:4; then
[H1\/{<*l1*>^phi}, no] is (1+1,{[H33,no]},({R#1(S)}\/{R#5(S)}))-derivable
by A10,Lm21; then
[H1\/{<*l1*>^phi}, no] is (m+2,{},D)-derivable by A8,A4,Lm21,A5; then
A11: no is (X\/{<*l1*>^phi},D)-provable by A8,Def62;
set seqt2=[{},yes]; {[{},<*E*>^t^t]} is {R#2(S)}-derivable &
seqt2`1 \+\ {}={} & seqt2`2 \+\ yes={}; then
yes is ({},{R#2(S)})-provable by Def12; then yes is
(X\/{<*l1*>^phi},D)-provable by A8,Lm49; hence thesis by A11,Def65;
end;

theorem Th17: for X being functional set,
num being Function of NAT, ExFormulasOf S st
D is isotone & R#1(S) in D & R#8(S) in D & R#2(S) in D & R#5(S) in D &
LettersOf S\SymbolsOf (X/\((AllSymbolsOf S)*\{{}})) is infinite &
X is D-consistent
holds
((D,num) addw X).k c= ((D,num) addw X).(k+m) &
LettersOf S\SymbolsOf (((D,num) addw X).m/\((AllSymbolsOf S)*\{{}}))
is infinite & ((D,num) addw X).m is D-consistent
proof
let X be functional set; set L=LettersOf S,F=S-firstChar,FF=
AllFormulasOf S,SS=AllSymbolsOf S,strings=SS*\{{}},EF=ExFormulasOf S;
let num be Function of NAT, EF; set f=(D,num) addw X; assume
A1: D is isotone & R#1(S) in D & R#8(S) in D & R#2(S) in D & R#5(S) in D;
assume
A2: L\SymbolsOf (X/\strings) is infinite & X is D-consistent;
defpred P[Nat] means f.k c= f.(k+$1) &
L\SymbolsOf (f.$1 /\ strings) is infinite & f.$1 is D-consistent;
A3: P[0] by A2,Def71;
A4: for m st P[m] holds P[m+1]
proof
let m; reconsider mk=k+m, MM=m+1, mm=m as Element of NAT by ORDINAL1:def 12;
reconsider phii=num.mm as Element of EF;
reconsider phi=num.mm as exal wff string of S by TARSKI:def 3;
reconsider phi1=head phi as wff string of S;
reconsider l1=F.phi as literal Element of S;
A5: phi=<*l1*>^phi1^(tail phi) by FOMODEL2:23 .= <*l1*>^phi1;
reconsider fmk=(D, num.mk) AddAsWitnessTo (f.mk) as Subset of (f.mk\/FF);
reconsider fmm=(D, num.mm) AddAsWitnessTo (f.mm) as Subset of (f.mm\/FF);
 f.mk \ fmk = {}; then
 f.mk c= fmk by XBOOLE_1:37; then
A6: f.mk c= f.(mk+1) & f.MM=fmm by Def71; assume
A7: P[m];
hence f.k c= f.(k+(m+1)) by A6,XBOOLE_1:1; (f.mm)\fmm={}; then
reconsider fm=f.mm as functional Subset of fmm by XBOOLE_1:37;
reconsider sm=fm/\strings as Subset of (fmm/\strings) by XBOOLE_1:26;
reconsider t=fmm\(f.mm) as trivial set;
reconsider i=L\SymbolsOf sm as infinite set by A7;
reconsider T=t/\strings as functional finite FinSequence-membered set;
fmm=fm \/ t by XBOOLE_1:45; then
SymbolsOf (fmm/\strings)=
SymbolsOf (sm\/T) by XBOOLE_1:23 .=
SymbolsOf sm \/ SymbolsOf T by FOMODEL0:47; then
L\SymbolsOf (fmm/\strings)=i\SymbolsOf T by XBOOLE_1:41;
hence L\SymbolsOf (f.(m+1)/\strings) is infinite by Def71;
reconsider LF=L\SymbolsOf(strings/\(fm\/{head phii})) as Subset of L;
per cases;
suppose
A8: fm \/ {phii} is D-consistent & LF<>{}; then
reconsider LF as non empty Subset of L; set ll2=the Element of LF;
reconsider l2=ll2 as literal Element of S
by TARSKI:def 3; not ll2 in SymbolsOf(strings/\(fm\/{head phii}))
by XBOOLE_0:def 5; then fm\/{<*l1*>^phi1} is D-consistent
& l2 is (fm\/{phi1})-absent by A8,A5,FOMODEL2:def 38; then
A9: fm\/{(l1,l2)-SymbolSubstIn phi1} is D-consistent by Lm70,A1;
thus thesis by A8,Def67,A9,A6;
end;
suppose not (fm \/ {phii} is D-consistent & LF<>{});
hence thesis by A7,A6,Def67;
end;
end;
for n holds P[n] from NAT_1:sch 2(A3, A4); hence thesis;
end;

definition
let X be functional set; let S,D;
let num be Function of NAT, ExFormulasOf S;
func X WithWitnessesFrom (D,num) -> Subset of (X\/AllFormulasOf S)
equals union rng (D,num) AddWitnessesTo X;
coherence
proof
set FF=AllFormulasOf S, Y=X\/FF, f=(D,num) AddWitnessesTo X;
reconsider F=rng f as Subset of bool Y by RELAT_1:def 19;
union F\Y={}; hence thesis;
end;
end;

notation
let X be functional set; let S,D;
let num be Function of NAT, ExFormulasOf S;
synonym X addw (D,num) for X WithWitnessesFrom (D,num);
end;

Lm71: for X being functional set, num being Function of NAT, ExFormulasOf S
st D is isotone & R#1(S) in D & R#2(S) in D & R#5(S) in D & R#8(S) in D &
LettersOf S\SymbolsOf (X/\((AllSymbolsOf S)*\{{}})) is infinite &
X is D-consistent holds X addw (D,num) is D-consistent
proof
let X be functional set; set EF=ExFormulasOf S,L=LettersOf S,G1=R#1(S);
let num be Function of NAT, EF; set XX=X addw (D,num), f=(D,num) addw X,
G2=R#2(S), G5=R#5(S), G8=R#8(S), SS=AllSymbolsOf S, strings=SS*\{{}}; assume
A1: D is isotone & G1 in D & G2 in D & G5 in D & G8 in D &
L\SymbolsOf (X/\strings) is infinite & X is D-consistent;
A2: for nn,mm st mm in dom f & nn in dom f & nn < mm holds f.nn c= f.mm
proof
let nn,mm; set m=mm, n=nn; assume m in dom f & n in dom f & n<m; then
n-n<=m-n by XREAL_1:9; then 0 <= m-n; then reconsider k=m-n as Nat;
f.n c= f.(n+k) by Th17,A1; hence thesis;
end;
now
let Y be finite Subset of XX; consider kk such that
A3: Y c= f.kk by A2,HENMODEL:3; f.kk is D-consistent by A1,Th17;
hence Y is D-consistent by A3,Th15;
end; hence thesis by Lm53;
end;

registration
let X be functional set; let S,D;
let num be Function of NAT, ExFormulasOf S;
cluster X\ (X addw (D,num)) -> empty for set;
coherence
proof
set XX=X addw (D,num), f= (D,num) addw X, Y=rng f; reconsider ff=f as
Function of NAT, Y by FUNCT_2:6; ff.0=X by Def71; then
X c= XX by ZFMISC_1:74; hence thesis;
end;
end;

theorem Th18: for X being functional set,
num being Function of NAT, ExFormulasOf S st D is isotone &
R#1(S) in D & R#8(S) in D & R#2(S) in D & R#5(S) in D &
LettersOf S\SymbolsOf (X/\((AllSymbolsOf S)*\{{}})) is infinite &
X addw (D,num) c= Z & Z is D-consistent & rng num = ExFormulasOf S
holds Z is S-witnessed
proof
let X be functional set;set L=LettersOf S,F=S-firstChar,EF=ExFormulasOf S;
let num be Function of NAT, EF; set f=(D,num) addw X, Y=X addw (D,num),
SS=AllSymbolsOf S; X\Y ={}; then
A1: X c= Y by XBOOLE_1:37; assume
A2: D is isotone & R#1(S) in D & R#8(S) in D & R#2(S) in D & R#5(S) in D &
LettersOf S\SymbolsOf (X/\((AllSymbolsOf S)*\{{}})) is infinite; assume
A3: Y c= Z & Z is D-consistent; then X c= Z & Z is D-consistent
by A1,XBOOLE_1:1; then
A4: X is D-consistent by Th15; assume
A5: rng num = EF; set strings=SS*\{{}};
for l1, phi1 st <*l1*>^phi1 in Z ex l2 st
((l1,l2)-SymbolSubstIn phi1 in Z & not l2 in rng phi1)
proof
let l1, phi1; set phi=<*l1*>^phi1;
phi=<*l1*>^phi1^{} & not phi is 0wff; then
A6: l1=F.phi & phi1=head phi by FOMODEL2:23;
phi in EF; then
reconsider phii=phi as Element of EF; consider x such that
A7: x in dom num & num.x=phii by A5,FUNCT_1:def 3;
reconsider mm=x as Element of NAT by A7;
::#this works because of redefine func dom in relset_1
reconsider MM=mm+1 as Element of NAT by ORDINAL1:def 12;
reconsider Xm=f.mm as functional set;
set no=SymbolsOf (strings/\(f.mm\/{phi1})); reconsider T=strings/\{phi1}
as FinSequence-membered finite Subset of {phi1};
reconsider t=SymbolsOf T as finite set;
reconsider i=L\SymbolsOf (f.mm/\strings) as infinite Subset of L
by Th17,A2,A4;
A8: no= SymbolsOf ((strings/\f.mm)\/(strings/\{phi1})) by XBOOLE_1:23 .=
SymbolsOf (strings/\f.mm) \/ SymbolsOf T by FOMODEL0:47; then
L\no=i\t by XBOOLE_1:41;
then reconsider yes=L\no as non empty Subset of L;
set ll2=the Element of yes;
reconsider l2=ll2 as literal Element of S by TARSKI:def 3;
set psi1=(l1,l2)-SymbolSubstIn phi1;
dom f=NAT by FUNCT_2:def 1; then
A9: f.mm in rng f & f.MM in rng f by FUNCT_1:def 3; then
f.mm c= Y by ZFMISC_1:74; then
A10: f.mm c= Z by A3,XBOOLE_1:1;
assume phi in Z; then {phi} c= Z by ZFMISC_1:31; then
f.mm \/ {phi} c= Z by A10,XBOOLE_1:8;
then f.mm \/ {phi} is D-consistent by A3,Th15; then
f.mm \/ {(l1,l2)-SymbolSubstIn phi1}  =
(D,phii) AddAsWitnessTo f.mm by Def67,A6 .=
f.(mm+1) by Def71,A7; then {psi1} null (f.mm) c= f.MM; then
psi1 in f.MM by ZFMISC_1:31; then
A11: psi1 in Y by A9,TARSKI:def 4; take l2;
thus (l1,l2)-SymbolSubstIn phi1 in Z by A3,A11;
not l2 in no by XBOOLE_0:def 5; then
not l2 in SymbolsOf {phi1} by A8,XBOOLE_0:def 3;
hence thesis by FOMODEL0:45;
end; hence
Z is S-witnessed by Def66;
end;

begin
::# constructions for countable languages
::# Consistently maximizing a set of formulas of a countable language

definition
let X,S,D; let phi be Element of AllFormulasOf S;
func (D,phi) AddFormulaTo X equals :Def73: X\/{phi}
if not xnot phi is (X,D)-provable otherwise X \/ {xnot phi};
consistency;
coherence;
end;

definition
let X,S,D; let phi be Element of AllFormulasOf S;
redefine func (D,phi) AddFormulaTo X -> Subset of (X\/AllFormulasOf S);
coherence
proof
set F=S-firstChar, IT=(D,phi) AddFormulaTo X, FF=AllFormulasOf S;
reconsider Y=X\/FF as non empty set;
reconsider XX=X null FF as Subset of Y; reconsider
FFF=FF null X as non empty Subset of Y;
xnot phi is Element of FFF & phi is Element of FFF by FOMODEL2:16; then
reconsider phii=phi, psii=xnot phi as Element of Y;
reconsider Phi={phii}, Psi={psii} as Subset of Y;
defpred P[] means xnot phi is (X,D)-provable;
((not P[]) implies IT=XX\/Phi) & (P[] implies IT=XX\/Psi) by Def73;
hence thesis;
end;
end;

registration
let X,S,D; let phi be Element of AllFormulasOf S;
cluster X \ ((D,phi) AddFormulaTo X) -> empty;
coherence
proof
set Y=(D,phi) AddFormulaTo X, psi=xnot phi; defpred P[] means
 xnot phi is (X,D)-provable;
(not P[] implies Y=X\/{phi}) & (P[] implies Y=X\/{psi}) by Def73; then
X null {phi} c= Y or X null {psi} c= Y; hence thesis;
end;
end;

definition
let X,S,D; let num be Function of NAT, AllFormulasOf S;
set SS=AllSymbolsOf S, FF=AllFormulasOf S, Y=X\/FF, DD=bool Y;
func (D,num) AddFormulasTo X -> Function of NAT, bool (X\/AllFormulasOf S)
means :Def74:
it.0=X & for m holds it.(m+1)=(D,num.m) AddFormulaTo (it.m);
existence
proof
reconsider Z=X null FF as Element of DD;
deffunc F(Nat, Element of DD)= Y typed/\((D,num.$1) AddFormulaTo $2);
consider f being Function of NAT, DD such that
A1: f.0=Z & for n holds f.(n+1)=F(n,f.n qua Element of DD)
from NAT_1:sch 12; take f;
now
let n; reconsider nn=n as Element of NAT by ORDINAL1:def 12;
A2: (D,num.nn) AddFormulaTo f.nn c= FF\/(f.nn) & FF\/(f.nn) c= FF\/Y
by XBOOLE_1:9; FF\/Y=FF\/FF\/X by XBOOLE_1:4 .= Y; then reconsider A=
(D,num.nn) AddFormulaTo f.nn as Subset of Y by A2,XBOOLE_1:1; f.(n+1)
= A null Y by A1; hence f.(n+1)=(D,num.n) AddFormulaTo f.n;
end; hence thesis by A1;
end;
uniqueness
proof
deffunc F(Nat, Element of DD) = (D,num.$1) AddFormulaTo $2;
let IT1, IT2 be Function of NAT, DD; assume that
A3: IT1.0=X and
A4: for m holds IT1.(m+1)=F(m,IT1.m qua Element of DD) and
A5: IT2.0=X and
A6: for m holds IT2.(m+1)=F(m,IT2.m qua Element of DD);
A7: for m holds IT1.(m+1)=F(m,IT1.m qua Element of DD)
by A4;
A8: for m holds IT2.(m+1)=F(m,IT2.m qua Element of DD)
by A6;
A9: dom IT1=NAT by FUNCT_2:def 1;
A10: dom IT2=NAT by FUNCT_2:def 1;
thus IT1=IT2 from NAT_1:sch 15(A9,A3,A7,A10,A5,A8);
end;
end;

Lm72: for num being Function of NAT, AllFormulasOf S st
D is isotone & R#1(S) in D & R#8(S) in D & X is D-consistent holds
(((D,num) AddFormulasTo X).k c= ((D,num) AddFormulasTo X).(k+m) &
((D, num) AddFormulasTo X).m is D-consistent)
proof
set FF=AllFormulasOf S; let num be Function of NAT, FF;
set f=(D,num) AddFormulasTo X; assume
A1: D is isotone & R#1(S) in D & R#8(S) in D; assume
A2: X is D-consistent;
defpred P[Nat] means f.k c= f.(k+$1) & f.$1 is D-consistent;
A3: P[0] by A2,Def74;
A4: for n st P[n] holds P[n+1]
proof
let n; set fkn1=(D,num.(k+n)) AddFormulaTo (f.(k+n)),fkn=f.(k+n); assume
A5: P[n];
A6: fkn\fkn1 = {};
f.(k+(n+1)) = f.(k+n+1) .= fkn1 by Def74; then fkn c= f.(k+(n+1))
by A6,XBOOLE_1:37;
hence f.k c= f.(k+(n+1)) by A5,XBOOLE_1:1;
reconsider phii=num.n as Element of FF; reconsider
phi=phii as wff string of S; reconsider psi=xnot phi
as wff string of S; reconsider psii=psi as Element of FF by FOMODEL2:16;
set fn=f.n, fN=(D,num.n) AddFormulaTo fn;
defpred P[] means xnot phii is (fn,D)-provable;
A7: f.(n+1)=fN by Def74;
per cases;
suppose
A8: not P[]; then fn\/{phii} is D-consistent by A1,Lm52;
hence thesis by A7,A8,Def73;
end;
suppose
A9: P[]; then fn\/{xnot phii} is D-consistent by Lm55,A1,A5;
hence thesis by A7,A9,Def73;
end;
end;
for n holds P[n] from NAT_1:sch 2(A3, A4); hence thesis;
end;

definition
let X,S,D; let num be Function of NAT, AllFormulasOf S;
func (D,num) CompletionOf X -> Subset of (X\/AllFormulasOf S) equals
union rng ((D,num) AddFormulasTo X);
coherence
proof
set FF=AllFormulasOf S, Y=X\/FF, f=(D,num) AddFormulasTo X;
reconsider F=rng f as Subset of bool Y by RELAT_1:def 19;
union F \ Y = {}; hence thesis;
end;
end;

registration
let X,S,D; let num be Function of NAT, AllFormulasOf S;
cluster X\((D,num) CompletionOf X) -> empty for set;
coherence
proof
set f=(D,num) AddFormulasTo X, XX=(D,num) CompletionOf X; reconsider
ff=f as Function of NAT, rng f by FUNCT_2:6; ff.0 in rng f; then
f.0 c= XX by ZFMISC_1:74; then X c= XX by Def74;
hence thesis;
end;
end;

Lm73: for num being Function of NAT, AllFormulasOf S st
rng num=AllFormulasOf S holds (D,num) CompletionOf X is S-covering
proof
set FF=AllFormulasOf S; let num be Function of NAT, FF; set
XX=(D,num) CompletionOf X, f=(D,num) AddFormulasTo X; assume
A1: rng num=FF; reconsider
ff=f as Function of NAT, rng f by FUNCT_2:6;
hereby
let phi; reconsider phii=phi as Element of FF by FOMODEL2:16;
consider x such that
A2: x in dom num & num.x=phii by A1,FUNCT_1:def 3;
reconsider mm=x as Element of NAT by A2; reconsider MM=mm+1 as Element of
NAT by ORDINAL1:def 12;
f.(mm+1)=(D,num.mm) AddFormulaTo f.mm by Def74; then
f.(mm+1)=f.mm \/ {phi} or f.(mm+1)=f.mm \/ {xnot phi} by A2,Def73; then
A3: {phi} null f.mm c= f.MM or {xnot phi} null f.mm c= f.MM;
ff.MM is Element of rng f; then f.(mm+1) c= XX by ZFMISC_1:74; then
{phi} c= XX or {xnot phi} c= XX by A3,XBOOLE_1:1; hence
phi in XX or xnot phi in XX by ZFMISC_1:31;
end;
end;

Lm74: for num being Function of NAT, AllFormulasOf S st
D is isotone & R#1(S) in D & R#8(S) in D & X is D-consistent holds
(D,num) CompletionOf X is D-consistent ::Lindenbaum
proof
set EF=ExFormulasOf S,L=LettersOf S, FF=AllFormulasOf S;
let num be Function of NAT, FF; set XX=(D,num) CompletionOf X, G1=R#1(S),
G8=R#8(S), SS=AllSymbolsOf S, strings=SS*\{{}}, f=(D,num) AddFormulasTo X;
assume A1: D is isotone & G1 in D & G8 in D & X is D-consistent;
A2: for nn,mm st mm in dom f & nn in dom f & nn < mm holds f.nn c= f.mm
proof
let nn,mm; set m=mm, n=nn; assume m in dom f & n in dom f & n<m; then
n-n<=m-n by XREAL_1:9; then 0 <= m-n; then reconsider k=m-n as Nat;
f.n c= f.(n+k) by A1,Lm72; hence thesis;
end;
now
let Y be finite Subset of XX; consider kk such that
A3: Y c= f.kk by A2,HENMODEL:3; f.kk is D-consistent by A1,Lm72;
hence Y is D-consistent by A3,Th15;
end; hence XX is D-consistent by Lm53;
end;

theorem for R being Relation of bool (S-sequents), S-sequents holds ::Th20
(y in (FuncRule R).X iff (y in S-sequents & [X,y] in R)) by Lm29;

reserve D2 for 2-ranked RuleSet of S;

Lm75: for X being functional set st AllFormulasOf S is countable
& LettersOf S \SymbolsOf (X/\((AllSymbolsOf S)*\{{}})) is infinite
& X is D2-consistent & D2 is isotone
ex U st ex I being Element of U-InterpretersOf S st X is I-satisfied
proof
let X be functional set; set EF=ExFormulasOf S, FF=AllFormulasOf S;
set G0=R#0(S), G2=R#2(S), G3a=R#3a(S), G3b=R#3b(S), G3d=R#3d(S), G3e=R#3e(S),
G1=R#1(S), G4=R#4(S), G5=R#5(S), G6=R#6(S), G7=R#7(S), G8=R#8(S),
L=LettersOf S,
SS=AllSymbolsOf S, strings=SS*\{{}}, no=SymbolsOf (X/\strings), D=D2;
reconsider D1=D2 as 1-ranked 0-ranked RuleSet of S;
assume FF is countable; then reconsider FFC=FF as countable set;
consider numaa being Function of NAT, strings such that
A1: FFC=rng numaa by SUPINF_2:def 8; reconsider numa=numaa as Function of
NAT, FF by A1,FUNCT_2:6;
EF \ FFC = {}; then reconsider EFC=EF as Subset of FFC by XBOOLE_1:37;
consider numee being Function of NAT, FFC such that
A2: EFC=rng numee by SUPINF_2:def 8; reconsider nume=numee as Function of
NAT, EF by A2,FUNCT_2:6; assume
A3: L\no is infinite & X is D2-consistent;
A4:G0 in D1 & G1 in D & G2 in D1 & G4 in D & G5 in D & G6 in D &
G7 in D & G8 in D by Def59;
set X1=X addw (D1,nume), X2=(D1,numa) CompletionOf X1;
A5: X2 is S-covering by Lm73,A1; assume
A6: D is isotone; then
X1 is D-consistent by Lm71,A3,A4; then
A7: X2 is D-consistent by Lm74,A6,A4; then
A8: X2 is S-mincover & X2 is D-expanded by A4,Lm54,A5;
reconsider X22=X2 as D1-expanded set by A4,Lm54,A5,A7;
take U=Class (X22,D1)-termEq; reconsider I=
D1 Henkin X22 as Element of U-InterpretersOf S;take I;X\X1={} & X1\X2={};then
A9: X c= X1 & X1 c= X22 by XBOOLE_1:37; then
A10: X22 is S-witnessed by Th18,A3,A4,A6,A7,A2;
hereby
let phi; assume phi in X; then phi in X22 by A9,TARSKI:def 3;
hence I-TruthEval phi=1 by A10,Th14,A8,A4;
end;
end;

Lm76: for X being functional set st X is finite &
AllFormulasOf S is countable & X is D2-consistent & D2 is isotone
ex U st (ex I being Element of U-InterpretersOf S st X is I-satisfied)
proof
let X be functional set; set SS=AllSymbolsOf S,L=LettersOf S,
strings=SS*\{{}}, FF=AllFormulasOf S, no=SymbolsOf (X/\strings);
assume X is finite; then reconsider XS=X/\strings as
finite FinSequence-membered set; SymbolsOf XS is finite; then
A1: L\no is infinite; assume FF is countable & X is D2-consistent & D2 is
isotone; hence thesis by A1,Lm75;
end;

Lm77: for I1 being Element of U-InterpretersOf S1,
I2 being Element of U-InterpretersOf S2 st S2 is S1-extending &
X c= AllFormulasOf S1 & I1|(OwnSymbolsOf S1)=I2|(OwnSymbolsOf S1)
holds (X is I1-satisfied iff X is I2-satisfied)
proof
set II1=U-InterpretersOf S1, II2=U-InterpretersOf S2, a1=the adicity of S1,
a2=the adicity of S2, O1=OwnSymbolsOf S1, E1=TheEqSymbOf S1,
E2=TheEqSymbOf S2, N1=TheNorSymbOf S1, N2=TheNorSymbOf S2,
FF1=AllFormulasOf S1, AS1=AtomicFormulaSymbolsOf S1;
dom a1=AS1 & O1 c= AS1 by FOMODEL1:1,FUNCT_2:def 1; then reconsider
O11=O1 as Subset of dom a1;
let I1 be Element of II1, I2 be Element of II2; assume
A1: S2 is S1-extending; then a1 c= a2 by FOMODEL1:def 41; then
a1|O1 = a2|(dom a1)|O1 by GRFUNC_1:23
.= a2|(O11 null (dom a1)) by RELAT_1:71; then
A2: a1|O1=a2|O1 & N1=N2 & E1=E2 by A1,FOMODEL1:def 41; assume
A3: X c= FF1 & I1|O1=I2|O1;
hereby
assume
A4: X is I1-satisfied;
now
let phi2 be wff string of S2; assume A5: phi2 in X; then phi2 in FF1
by A3; then reconsider phi1=phi2 as wff string of S1;
consider phi22 being wff string of S2 such that
A6: phi1=phi22 & I1-TruthEval phi1= I2-TruthEval phi22
by A2,A3,FOMODEL3:12;
thus I2-TruthEval phi2=1 by A6,A5,A4,FOMODEL2:def 42;
end; hence X is I2-satisfied by FOMODEL2:def 42;
end;
assume
A7: X is I2-satisfied;
now
let phi1 be wff string of S1; assume
A8: phi1 in X;
consider phi2 being wff string of S2 such that
A9: phi1=phi2 & I1-TruthEval phi1= I2-TruthEval phi2 by A2,A3,FOMODEL3:12
; thus I1-TruthEval phi1 = 1 by A9,A8,A7,FOMODEL2:def 42;
end; hence thesis by FOMODEL2:def 42;
end;

registration
let S; let r1, r2 be isotone Rule of S;
cluster {r1,r2} -> isotone for RuleSet of S;
coherence proof {r1,r2}={r1}\/{r2} by ENUMSET1:1; hence thesis; end;
end;

registration
let S; let r1, r2, r3, r4 be isotone Rule of S;
cluster {r1,r2,r3,r4} -> isotone for RuleSet of S;
coherence
proof {r1,r2,r3,r4}={r1,r2}\/{r3,r4} by ENUMSET1:5; hence thesis; end;
end;

registration let S;
cluster S-rules -> isotone for RuleSet of S;
coherence
proof
set A={R#0(S), R#1(S), R#2(S), R#3a(S), R#3b(S), R#3d(S), R#3e(S), R#4(S)},
B={R#5(S),R#6(S),R#7(S),R#8(S)}, IT=S-rules; A={R#0(S), R#1(S), R#2(S),
R#3a(S)}
\/{R#3b(S), R#3d(S), R#3e(S), R#4(S)} by ENUMSET1:25; then reconsider AA=A as
isotone RuleSet of S; AA\/B is isotone; hence thesis;
end;
end;

registration let S;
cluster Correct for isotone RuleSet of S;
existence proof take S-rules; thus thesis; end;
end;

registration let S;
cluster 2-ranked for Correct isotone RuleSet of S;
existence proof take S-rules; thus thesis; end;
end;

registration
let S be countable Language;
cluster AllFormulasOf S -> countable;
coherence;
end;

theorem Th20: for S being countable Language, D being RuleSet of S st
D is 2-ranked & D is isotone & D is Correct & Z is D-consistent &
Z c= AllFormulasOf S ex U being non empty set,
I being Element of U-InterpretersOf S st Z is I-satisfied
proof
let S be countable Language; set S1=S; let D be RuleSet of S1;
set FF1=AllFormulasOf S1; assume
A1: D is 2-ranked & D is isotone & D is Correct
& Z is D-consistent & Z c= FF1; then reconsider X=Z as Subset of FF1;
set S2=S1 addLettersNotIn X, O1=OwnSymbolsOf S1, O2=OwnSymbolsOf S2,
FF2=AllFormulasOf S2, SS1=AllSymbolsOf S1, SS2=AllSymbolsOf S2,
strings2=SS2*\{{}}, L2=LettersOf S2;
reconsider D1=D as 2-ranked Correct RuleSet of S1 by A1; O1\O2 ={}; then
reconsider O11=O1 as non empty Subset of O2 by XBOOLE_1:37;
reconsider D2=S2-rules as 2-ranked Correct isotone RuleSet of S2;
reconsider sub1=X/\strings2 as Subset of X;
reconsider sub2=SymbolsOf sub1 as Subset of SymbolsOf X by FOMODEL0:46;
reconsider inf=L2\SymbolsOf X as Subset of L2\sub2 by XBOOLE_1:34;
A2: L2\sub2 null inf is infinite;
now
let Y be finite Subset of X; reconsider YY=Y as functional set;
reconsider YYY=YY as functional Subset of FF1 by XBOOLE_1:1;
YY is finite & FF1 is countable & YY is D1-consistent & D1 is isotone
by A1,Th15; then consider U such that
A3: ex I1 being Element of U-InterpretersOf S1 st YY is I1-satisfied
by Lm76; set II1=U-InterpretersOf S1, II2=U-InterpretersOf S2,
I02=the (S2,U)-interpreter-like Function;
consider I1 being Element of II1 such that
A4: YYY is I1-satisfied by A3;
reconsider I2 = (I02 +* I1)|O2 as Element of II2 by FOMODEL2:2;
I2|O1 = (I02 +* I1)|(O11 null O2) by RELAT_1:71
.= I02|O1 +* (I1|O1) by FUNCT_4:71 .= I1|O1; then
YYY is I2-satisfied by A4,Lm77; hence Y is D2-consistent by Lm56;
end; then X is D2-consistent by Lm53; then consider U such that
A5: ex I being Element of U-InterpretersOf S2 st X is I-satisfied
by A2,Lm75; set II1=U-InterpretersOf S1, II2=U-InterpretersOf S2;
consider I2 being Element of II2 such that
A6: X is I2-satisfied by A5; take U;
reconsider I1=I2|O1 as Element of II1 by FOMODEL2:2;
take I1; I1|O1=I2|O1 null O1;
hence thesis by A6,Lm77;
end;

Lm78: for S being countable Language, phi being wff string of S
st Z c= AllFormulasOf S & xnot phi is Z-implied holds
xnot phi is (Z,S-rules)-provable
proof
let S be countable Language; set D=S-rules, FF=AllFormulasOf S;
let phi be wff string of S; assume
Z c= FF; then reconsider X=Z as Subset of FF;
set psi=xnot phi; phi in FF by FOMODEL2:16; then
reconsider Phi={phi} as non empty Subset of FF by ZFMISC_1:31;
reconsider Y=X\/Phi as non empty Subset of FF;
reconsider XX=X null Phi as Subset of Y; reconsider Phii=Phi null X
as non empty Subset of Y; assume
A1: psi is Z-implied; assume not psi is (Z,D)-provable; then
D is isotone & R#1(S) in D & R#8(S) in D & not psi is (Z,D)-provable
by Def59; then
consider
U being non empty set, I being Element of U-InterpretersOf S such that
A2: Y is I-satisfied by Th20,Lm52;
I-TruthEval psi \+\ 'not' (I-TruthEval phi)={}; then
A3: I-TruthEval psi='not' (I-TruthEval phi) by FOMODEL0:29;
A4: Y/\XX is I-satisfied by A2; phi in Phii by TARSKI:def 1;
then 1 = 'not' (I-TruthEval psi) by A3,A2,FOMODEL2:def 42;
hence contradiction by A4,A1,FOMODEL2:def 45;
end;

reserve C for countable Language, phi for wff string of C;

theorem ::Goedel's completeness theorem
(X c= AllFormulasOf C & phi is X-implied) implies phi is X-provable
proof
reconsider S=C as Language; reconsider DD={R#9(S)} as RuleSet of S;
set FF=AllFormulasOf C, D=C-rules; assume X c= FF; then
reconsider Y=X as Subset of FF; assume phi is X-implied; then
reconsider phii=phi as X-implied wff string of C; set psi=xnot xnot phii;
psi is (Y,D)-provable by Lm78; then consider H being set, m such that
A1: H c= Y & [H, psi] is (m,{},D)-derivable by Def62;
reconsider seqt=[H, psi] as C-sequent-like set by A1;
A2: seqt`1 \+\ H={};
reconsider HH=H as S-premises-like set by A2,FOMODEL0:29;
reconsider HC=H as C-premises-like set by A2,FOMODEL0:29;
reconsider a=phi as wff string of S;
[HC, phi] null 1 is (1,{[HC, xnot (xnot phi)]}, {R#9(C)})-derivable;
then [HC, phi] is (m+1, {}, D\/{R#9(C)})-derivable by Lm21,A1; then
phi is (Y,D\/{R#9(C)})-provable by A1,Def62;
hence thesis by Def70;
end;

