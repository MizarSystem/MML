:: Complex {B}anach Space of Bounded Linear Operators
::  by Noboru Endou
::
:: Received February 24, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabularies PRE_TOPC, NORMSP_1, RLVECT_1, QC_LANG1, FUNCT_1, ARYTM, ARYTM_1,
      ARYTM_3, RELAT_1, ABSVALUE, ORDINAL2, GRCAT_1, UNIALG_1, LATTICES,
      FUNCOP_1, FUNCT_2, RLSUB_1, SEQ_1, SEQ_2, SEQM_3, BHSP_3, RSSPACE,
      RSSPACE3, PARTFUN1, LOPBAN_1, XCMPLX_0, COMPLEX1, CLVECT_1, CFUNCT_1,
      CLOPBAN1, CSSPACE3, MONOID_0, FRAENKEL, ALGSTR_0;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1, PARTFUN1,
      FUNCT_2, FUNCT_3, PRE_TOPC, DOMAIN_1, FUNCOP_1, BINOP_1, XCMPLX_0,
      XXREAL_0, XREAL_0, REAL_1, NAT_1, STRUCT_0,
      ALGSTR_0, MONOID_0, ORDINAL1, NUMBERS,
      PSCOMP_1, COMPLEX1, RLVECT_1, FRAENKEL, NORMSP_1,
      VALUED_1, SEQ_1, SEQ_2, SEQM_3, SEQ_4, FUNCSDOM, CFUNCT_1, CLVECT_1,
      CSSPACE, CSSPACE3, LOPBAN_1;
 constructors DOMAIN_1, FUNCT_3, XXREAL_0, REAL_1, NAT_1, COMPLEX1, SEQM_3,
      FUNCSDOM, MONOID_0, PSCOMP_1, LOPBAN_1, CSSPACE3, SEQ_1, XXREAL_2;
 registrations XBOOLE_0, SUBSET_1, ORDINAL1, RELSET_1, FUNCT_2, NUMBERS,
      XCMPLX_0, XXREAL_0, XREAL_0, MEMBERED, SEQM_3, STRUCT_0, RLVECT_1,
      MONOID_0, CLVECT_1, CSSPACE3, VALUED_1, VALUED_0, FUNCOP_1;
 requirements SUBSET, REAL, BOOLE, NUMERALS, ARITHM;
 definitions SEQ_4, RLVECT_1, FRAENKEL, BINOP_1, STRUCT_0, ALGSTR_0;
 theorems XBOOLE_0, REAL_2, TARSKI, ABSVALUE, RLVECT_1, BINOP_1, FUNCOP_1,
      FUNCSDOM, XREAL_0, XCMPLX_0, SEQ_1, SEQ_2, SEQM_3, FUNCT_1, NAT_1,
      FUNCT_2, SEQ_4, FUNCT_3, CLVECT_1, LOPBAN_1, CSSPACE, COMPLEX1, CSSPACE3,
      MONOID_0, XREAL_1, XXREAL_0, NORMSP_1;
 schemes SEQ_1, FUNCT_2, XBOOLE_0, BINOP_1;

begin :: Complex Vector Space of Operators

definition
  let X be set;
  let Y be non empty set;
  let F be Function of [:COMPLEX, Y:], Y;
  let c be complex number, f be Function of X, Y;
  redefine func F[;](c,f) -> Element of Funcs(X, Y);
  coherence
  proof
A1: c in COMPLEX by XCMPLX_0:def 2;
    dom f = X by FUNCT_2:def 1;
    then dom f --> c is Function of X,COMPLEX by A1,FUNCOP_1:57;
    then reconsider g = <:dom f --> c, f:> as Function of X,[:COMPLEX, Y:]
    by FUNCT_3:78;
    F[;](c,f) = F * g by FUNCOP_1:def 5;
    hence thesis by FUNCT_2:11;
  end;
end;

theorem Th1:
  for X be non empty set, Y be ComplexLinearSpace ex MULT be Function of
  [:COMPLEX, Funcs(X,the carrier of Y):], Funcs(X,the carrier of Y) st
  for c be Complex, f be Element of Funcs(X,the carrier of Y) holds
  for s be Element of X holds (MULT.[c,f]).s = c*(f.s)
proof
  let X be non empty set;
  let Y be ComplexLinearSpace;
  deffunc F(Complex,Element of Funcs(X,the carrier of Y)) =
  ((the Mult of Y)[;]($1,$2));
  consider F being Function of
  [:COMPLEX,Funcs(X,the carrier of Y):], Funcs(X,the carrier of Y) such that
A1: for c be Complex, f being Element of Funcs(X,the carrier of Y)
  holds F.(c,f) = F(c,f) from BINOP_1:sch 4;
  take F;
  let c be Complex,f be Element of Funcs(X,the carrier of Y),
  x be Element of X;
A2: dom (F.[c,f]) = X by FUNCT_2:169;
  F.(c,f) = ((the Mult of Y)[;](c,f)) by A1;
  hence (F.[c,f]).x = (the Mult of Y).(c,f.x) by A2,FUNCOP_1:42
    .= c*(f.x) by CLVECT_1:def 1;
end;

definition
  let X be non empty set;
  let Y be ComplexLinearSpace;
  func FuncExtMult(X,Y) -> Function of [:COMPLEX,Funcs(X,the carrier of Y):],
  Funcs(X,the carrier of Y) means
  :Def1:
  for c being Complex,
  f being Element of Funcs(X,the carrier of Y), x being Element of X holds
  (it.[c,f]).x = c*(f.x);
  existence by Th1;
  uniqueness
  proof
    let it1,it2 be Function of [:COMPLEX,Funcs(X,the carrier of Y):],
    Funcs(X,the carrier of Y) such that
A1: for c being Complex, f being Element of Funcs(X,the carrier of Y),
    x being Element of X holds (it1.[c,f]).x = c*(f.x) and
A2: for c being Complex, f being Element of Funcs(X,the carrier of Y),
    x being Element of X holds (it2.[c,f]).x = c*(f.x);
    now
      let c be Element of COMPLEX, f be Element of Funcs(X,the carrier of Y );
      now
        let x be Element of X;
        thus (it1.[c,f]).x = c*(f.x) by A1
          .= (it2.[c,f]).x by A2;
      end;
      hence it1.(c,f) = it2.(c,f) by FUNCT_2:113;
    end;
    hence thesis by BINOP_1:2;
  end;
end;

reserve X for non empty set;
reserve Y for ComplexLinearSpace;
reserve f,g,h for Element of Funcs(X,the carrier of Y);

theorem Th2:
  for x being Element of X holds (FuncZero(X,Y)).x = 0.Y
proof
  let x be Element of X;
  thus (FuncZero(X,Y)).x = (X --> 0.Y).x by LOPBAN_1:def 3
    .= 0.Y by FUNCOP_1:13;
end;

reserve a,b for Complex;

theorem Th3:
  h = (FuncExtMult(X,Y)).[a,f] iff
  for x being Element of X holds h.x = a*(f.x)
proof
  thus h = (FuncExtMult(X,Y)).[a,f] implies
  (for x being Element of X holds h.x = a*(f.x)) by Def1;
  now
    assume
A1: for x being Element of X holds h.x = a*(f.x);
    for x being Element of X holds h.x = ((FuncExtMult(X,Y)).[a,f]).x
    proof
      let x be Element of X;
      thus h.x = a*(f.x) by A1
        .= ((FuncExtMult(X,Y)).[a,f]).x by Def1;
    end;
    hence h = (FuncExtMult(X,Y)).[a,f] by FUNCT_2:113;
  end;
  hence thesis;
end;

reserve u,v,w for VECTOR of CLSStruct(#Funcs(X,the carrier of Y),
    (FuncZero(X,Y)),FuncAdd(X,Y),FuncExtMult(X,Y)#);

theorem Th4:
  (FuncAdd(X,Y)).(f,g) = (FuncAdd(X,Y)).(g,f)
proof
  now
    let x be Element of X;
    thus ((FuncAdd(X,Y)).(f,g)).x = g.x + f.x by LOPBAN_1:3
      .= ((FuncAdd(X,Y)).(g,f)).x by LOPBAN_1:3;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th5:
  (FuncAdd(X,Y)).(f,(FuncAdd(X,Y)).(g,h))
  = (FuncAdd(X,Y)).((FuncAdd(X,Y)).(f,g),h)
proof
  now
    let x be Element of X;
    thus ((FuncAdd(X,Y)).(f,(FuncAdd(X,Y)).(g,h))).x
    = f.x + ((FuncAdd(X,Y)).(g,h)).x by LOPBAN_1:3
      .= f.x + (g.x + h.x) by LOPBAN_1:3
      .= (f.x + g.x) + h.x by RLVECT_1:def 6
      .= ((FuncAdd(X,Y)).(f,g)).x + h.x by LOPBAN_1:3
      .= ((FuncAdd(X,Y)).((FuncAdd(X,Y)).(f,g),h)).x by LOPBAN_1:3;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th6:
  (FuncAdd(X,Y)).(FuncZero(X,Y),f) = f
proof
  now
    let x be Element of X;
    thus ((FuncAdd(X,Y)).(FuncZero(X,Y),f)).x
    = (FuncZero(X,Y)).x + f.x by LOPBAN_1:3
      .= 0.Y + f.x by Th2
      .= f.x by RLVECT_1:def 7;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th7:
  (FuncAdd(X,Y)).(f,(FuncExtMult(X,Y)).[-1r,f]) = FuncZero(X,Y)
proof
  now
    let x be Element of X;
    set y=f.x;
    thus ((FuncAdd(X,Y)).(f,(FuncExtMult(X,Y)).[-1r,f])).x
    = f.x + ((FuncExtMult(X,Y)).[-1r,f]).x by LOPBAN_1:3
      .= f.x + ((-1r)*y) by Th3
      .= f.x + (-y) by CLVECT_1:4
      .= 0.Y by RLVECT_1:16
      .= (FuncZero(X,Y)).x by Th2;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th8:
  (FuncExtMult(X,Y)).[1r,f] = f
proof
  now
    let x be Element of X;
    thus ((FuncExtMult(X,Y)).[1r qua Complex,f]).x = 1r*(f.x) by Th3
      .= f.x by CLVECT_1:def 2;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th9:
  (FuncExtMult(X,Y)).[a,(FuncExtMult(X,Y)).[b,f]] = (FuncExtMult(X,Y)).[a*b,f]
proof
  now
    let x be Element of X;
    thus ((FuncExtMult(X,Y)).[a,(FuncExtMult(X,Y)).[b,f]]).x
    = a*(((FuncExtMult(X,Y)).[b,f]).x) by Th3
      .= a*(b*(f.x)) by Th3
      .= (a*b)*(f.x) by CLVECT_1:def 2
      .= ((FuncExtMult(X,Y)).[a*b,f]).x by Th3;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th10:
  (FuncAdd(X,Y)).((FuncExtMult(X,Y)).[a,f],(FuncExtMult(X,Y)).[b,f])
  = (FuncExtMult(X,Y)).[a+b,f]
proof
  now
    let x be Element of X;
    thus ((FuncAdd(X,Y)).
    ((FuncExtMult(X,Y)).[a,f],(FuncExtMult(X,Y)).[b,f])).x =
    ((FuncExtMult(X,Y)).[a,f]).x + ((FuncExtMult(X,Y)).[b,f]).x by LOPBAN_1:3
      .= a*(f.x) + ((FuncExtMult(X,Y)).[b,f]).x by Th3
      .= a*(f.x) + b*(f.x) by Th3
      .= (a+b)*(f.x) by CLVECT_1:def 2
      .= ((FuncExtMult(X,Y)).[a+b,f]).x by Th3;
  end;
  hence thesis by FUNCT_2:113;
end;

Lm1: (FuncAdd(X,Y)).((FuncExtMult(X,Y)).[a,f],(FuncExtMult(X,Y)).[a,g])
= (FuncExtMult(X,Y)).[a,(FuncAdd(X,Y)).(f,g)]
proof
  now
    let x be Element of X;
    thus ((FuncAdd(X,Y)).
    ((FuncExtMult(X,Y)).[a,f],(FuncExtMult(X,Y)).[a,g])).x
    = ((FuncExtMult(X,Y)).[a,f]).x + ((FuncExtMult(X,Y)).[a,g]).x
    by LOPBAN_1:3
      .= a*(f.x) + ((FuncExtMult(X,Y)).[a,g]).x by Th3
      .= a*(f.x) + a*(g.x) by Th3
      .= a*(f.x + g.x) by CLVECT_1:def 2
      .= a*(((FuncAdd(X,Y)).(f,g)).x) by LOPBAN_1:3
      .= ((FuncExtMult(X,Y)).[a,(FuncAdd(X,Y)).(f,g)]).x by Th3;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th11:
  CLSStruct(#Funcs(X,the carrier of Y),(FuncZero(X,Y)),FuncAdd(X,Y),
    FuncExtMult(X,Y)#) is ComplexLinearSpace
proof
  set IT = CLSStruct(#Funcs(X,the carrier of Y),(FuncZero(X,Y)),
    FuncAdd(X,Y),FuncExtMult(X,Y)#);
  IT is Abelian add-associative right_zeroed right_complementable
  ComplexLinearSpace-like
  proof
    thus u+v = v+u by Th4;
    thus (u+v)+w = u+(v+w) by Th5;
    thus u+0.IT = u
    proof
      reconsider u'=u as Element of Funcs(X,the carrier of Y);
      thus u+0.IT = (FuncAdd(X,Y)).(FuncZero(X,Y),u') by Th4
        .= u by Th6;
    end;
    thus u is right_complementable
    proof
      reconsider u' = u as Element of Funcs(X,the carrier of Y);
      reconsider w = (FuncExtMult(X,Y)).[-1r,u'] as VECTOR of IT;
      take w;
      thus u+w = 0.IT by Th7;
    end;
A1: for a be Complex, u,v be VECTOR of IT holds a * (u + v) = a * u + a * v
    proof
      let a be Complex;
      let u,v be VECTOR of IT;
      a * (u + v) = a * u + a * v
      proof
        reconsider v' = v, u' = u as Element of Funcs(X,the carrier of Y);
        reconsider w = (FuncExtMult(X,Y)).[a,u'],
        w' = (FuncExtMult(X,Y)).[a,v'] as VECTOR of IT;
        a*(u+v) = (FuncExtMult(X,Y)).[a,(FuncAdd(X,Y)).(u',v')] by
        CLVECT_1:def 1
          .=(FuncAdd(X,Y)).(w,w') by Lm1
          .= w + (a*v) by CLVECT_1:def 1
          .= a*u + a*v by CLVECT_1:def 1;
        hence thesis;
      end;
      hence thesis;
    end;
A2: for a,b be Complex, v be VECTOR of IT holds (a+b)*v = a*v + b*v
    proof
      let a,b be Complex;
      let v be VECTOR of IT;
      reconsider v' = v as Element of Funcs(X,the carrier of Y);
      reconsider w = (FuncExtMult(X,Y)).[a,v'],w' = (FuncExtMult(X,Y)).[b,v']
      as VECTOR of IT;
      thus (a+b)*v = (FuncExtMult(X,Y)).[a+b,v'] by CLVECT_1:def 1
        .= (FuncAdd(X,Y)).(w,w') by Th10
        .= w + (b*v) by CLVECT_1:def 1
        .= (a*v) + (b*v) by CLVECT_1:def 1;
    end;
A3: for a,b be Complex, v be VECTOR of IT holds (a*b)*v = a*(b*v)
    proof
      let a,b be Complex;
      let v be VECTOR of IT;
      reconsider v'=v as Element of Funcs(X,the carrier of Y);
      thus (a*b)*v = (FuncExtMult(X,Y)).[a*b,v'] by CLVECT_1:def 1
        .= (FuncExtMult(X,Y)).[a,(FuncExtMult(X,Y)).[b,v']] by Th9
        .= (FuncExtMult(X,Y)).[a,b*v] by CLVECT_1:def 1
        .= a*(b*v) by CLVECT_1:def 1;
    end;
    for v be VECTOR of IT holds 1r*v = v
    proof
      let v be VECTOR of IT;
      reconsider v'=v as Element of Funcs(X,the carrier of Y);
      thus 1r*v = (FuncExtMult(X,Y)).[1r,v'] by CLVECT_1:def 1
        .= v by Th8;
    end;
    hence IT is ComplexLinearSpace-like by A1,A2,A3,CLVECT_1:def 2;
  end;
  hence thesis;
end;

definition
  let X be non empty set;
  let Y be ComplexLinearSpace;
  func ComplexVectSpace(X,Y) -> ComplexLinearSpace equals
  CLSStruct(#Funcs(X,the carrier of Y),
    (FuncZero(X,Y)),FuncAdd(X,Y),FuncExtMult(X,Y)#);
  coherence by Th11;
end;

registration
  let X be non empty set;
  let Y be ComplexLinearSpace;
  cluster ComplexVectSpace(X,Y) -> strict;
  coherence;
end;

registration
  let X be non empty set;
  let Y be ComplexLinearSpace;
  cluster ComplexVectSpace(X,Y) -> constituted-Functions;
  coherence by MONOID_0:89;
end;

definition
  let X be non empty set;
  let Y be ComplexLinearSpace;
  let f be VECTOR of ComplexVectSpace(X,Y);
  let x be Element of X;
  redefine func f.x -> VECTOR of Y;
  coherence
  proof
    consider g being Function such that
A1: f = g and
A2: dom g = X and
A3: rng g c= the carrier of Y by FUNCT_2:def 2;
    f.x in rng g by A1,A2,FUNCT_1:def 5;
    hence thesis by A3;
  end;
end;

theorem
  for X be non empty set, Y be ComplexLinearSpace,
  f,g,h be VECTOR of ComplexVectSpace(X,Y) holds
  h = f+g iff for x be Element of X holds h.x = f.x + g.x by LOPBAN_1:3;

theorem Th13:
  for X be non empty set, Y be ComplexLinearSpace,
  f,h be VECTOR of ComplexVectSpace(X,Y), c be Complex holds
  h = c*f iff for x be Element of X holds h.x = c * f.x
proof
  let X be non empty set;
  let Y be ComplexLinearSpace;
  let f,h be VECTOR of ComplexVectSpace(X,Y);
  let c be Complex;
  reconsider f'=f,h'=h as Element of Funcs(X, the carrier of Y);
  hereby
    assume
A1: h = c*f;
    let x be Element of X;
    h= (FuncExtMult(X, Y)).[c,f'] by A1,CLVECT_1:def 1;
    hence h.x = c*f.x by Th3;
  end;
  assume for x be Element of X holds h.x=c*f.x;
  then h'=(FuncExtMult(X, Y)).[c,f'] by Th3;
  hence h =c*f by CLVECT_1:def 1;
end;

begin :: Complex Vector Space of Linear Operators

definition
  let X be non empty CLSStruct;
  let Y be non empty addLoopStr;
  let IT be Function of X, Y;
  attr IT is additive means
  :Def3:
  for x,y being VECTOR of X holds IT.(x+y) = IT.x+IT.y;
end;

definition
  let X, Y be non empty CLSStruct;
  let IT be Function of X,Y;
  attr IT is homogeneous means
  :Def4:
  for x being VECTOR of X, r being Complex holds IT.(r*x) = r*IT.x;
end;

registration
  let X be non empty CLSStruct;
  let Y be ComplexLinearSpace;
  cluster additive homogeneous Function of X,Y;
  existence
  proof
    set f = (the carrier of X) --> 0.Y;
    reconsider f as Function of X,Y;
    take f;
    hereby
      let x,y be VECTOR of X;
      thus f.(x+y) = 0.Y by FUNCOP_1:13
        .= 0.Y+0.Y by RLVECT_1:10
        .= f.x+0.Y by FUNCOP_1:13
        .= f.x+f.y by FUNCOP_1:13;
    end;
    hereby
      let x be VECTOR of X, c be Complex;
      thus f.(c*x) = 0.Y by FUNCOP_1:13
        .= c*0.Y by CLVECT_1:2
        .= c*f.x by FUNCOP_1:13;
    end;
  end;
end;

definition
  let X, Y be ComplexLinearSpace;
  mode LinearOperator of X,Y is additive homogeneous Function of X,Y;
end;

definition
  let X, Y be ComplexLinearSpace;
  func LinearOperators(X,Y) -> Subset of
  ComplexVectSpace(the carrier of X, Y) means
  :Def5:
  for x being set holds x in it iff x is LinearOperator of X,Y;
  existence
  proof
    defpred P[set] means $1 is LinearOperator of X,Y;
    consider IT being set such that
A1: for x being set holds x in IT
    iff x in Funcs(the carrier of X,the carrier of Y) & P[x]
    from XBOOLE_0:sch 1;
A2: IT is Subset of Funcs(the carrier of X,the carrier of Y)
    proof
      for x be set st x in IT holds
      x in Funcs(the carrier of X,the carrier of Y) by A1;
      hence thesis by TARSKI:def 3;
    end;
    take IT;
    thus IT is Subset of ComplexVectSpace(the carrier of X, Y) by A2;
    let x be set;
    thus x in IT implies x is LinearOperator of X,Y by A1;
    assume
A3: x is LinearOperator of X,Y;
    then x in Funcs(the carrier of X,the carrier of Y) by FUNCT_2:11;
    hence thesis by A1,A3;
  end;
  uniqueness
  proof
    let X1,X2 be Subset of ComplexVectSpace(the carrier of X, Y);
    assume that
A4: for x being set holds x in X1 iff x is LinearOperator of X,Y and
A5: for x being set holds x in X2 iff x is LinearOperator of X,Y;
    for x being set st x in X1 holds x in X2
    proof
      let x be set;
      assume x in X1;
      then x is LinearOperator of X,Y by A4;
      hence thesis by A5;
    end;
    then
A6: X1 c= X2 by TARSKI:def 3;
    for x being set st x in X2 holds x in X1
    proof
      let x be set;
      assume x in X2;
      then x is LinearOperator of X,Y by A5;
      hence thesis by A4;
    end;
    then X2 c= X1 by TARSKI:def 3;
    hence thesis by A6,XBOOLE_0:def 10;
  end;
end;

registration
  let X, Y be ComplexLinearSpace;
  cluster LinearOperators(X,Y) -> non empty functional;
  coherence
  proof
    set f = (the carrier of X) --> 0.Y;
    reconsider f as Function of X,Y;
A1: f is additive
    proof
      let x,y be VECTOR of X;
      thus f.(x+y) = 0.Y by FUNCOP_1:13
        .=0.Y+0.Y by RLVECT_1:10
        .= f.x+0.Y by FUNCOP_1:13
        .= f.x+f.y by FUNCOP_1:13;
    end;
    f is homogeneous
    proof
      let x be VECTOR of X, c be Complex;
      thus f.(c*x) = 0.Y by FUNCOP_1:13
        .= c*0.Y by CLVECT_1:2
        .= c*f.x by FUNCOP_1:13;
    end;
    hence LinearOperators(X,Y) is non empty by A1,Def5;
    let x be set;
    assume x in LinearOperators(X,Y);
    hence x is Function;
  end;
end;

canceled;

theorem Th15:
  for X,Y be ComplexLinearSpace holds LinearOperators(X,Y) is linearly-closed
proof
  let X, Y be ComplexLinearSpace;
  set W = LinearOperators(X,Y);
A1: for v,u be VECTOR of ComplexVectSpace(the carrier of X, Y) st
  v in LinearOperators(X,Y) & u in LinearOperators(X,Y) holds
  v + u in LinearOperators(X,Y)
  proof
    let v,u be VECTOR of ComplexVectSpace(the carrier of X,Y) such that
A2: v in W & u in W;
    v+u is LinearOperator of X,Y
    proof
      reconsider f=v+u as Function of X,Y by FUNCT_2:121;
      f is LinearOperator of X,Y
      proof
A3:     f is additive
        proof
          let x,y be VECTOR of X;
          reconsider v' = v, u' = u as Element of
          Funcs(the carrier of X,the carrier of Y);
A4:       u' is LinearOperator of X,Y by A2,Def5;
A5:       v' is LinearOperator of X,Y by A2,Def5; thus
          f.(x+y) =u'.(x+y)+v'.(x+y) by LOPBAN_1:3
            .=(u'.x+u'.y)+v'.(x+y) by A4,Def3
            .=u'.x+u'.y+(v'.x+v'.y) by A5,Def3
            .=u'.x+u'.y+v'.x+v'.y by RLVECT_1:def 6
            .=u'.x+v'.x+u'.y+v'.y by RLVECT_1:def 6
            .= f.x+ u'.y+v'.y by LOPBAN_1:3
            .= f.x+ (u'.y+v'.y) by RLVECT_1:def 6
            .= f.x+f.y by LOPBAN_1:3;
        end;
        f is homogeneous
        proof
          let x be VECTOR of X, s be Complex;
          reconsider v' = v, u' = u as Element of
          Funcs(the carrier of X,the carrier of Y);
A6:       u' is LinearOperator of X,Y by A2,Def5;
A7:       v' is LinearOperator of X,Y by A2,Def5;
          thus f.(s*x) =u'.(s*x)+v'.(s*x) by LOPBAN_1:3
            .=(s*(u'.x))+v'.(s*x) by A6,Def4
            .=s*u'.x+s*v'.x by A7,Def4
            .=s*(u'.x+v'.x) by CLVECT_1:def 2
            .= s*f.x by LOPBAN_1:3;
        end;
        hence thesis by A3;
      end;
      hence thesis;
    end;
    hence v+u in W by Def5;
  end;
  for c be Complex for v be VECTOR of ComplexVectSpace(the carrier of X,Y)
  st v in W holds c * v in W
  proof
    let c be Complex;
    let v be VECTOR of ComplexVectSpace(the carrier of X,Y) such that
A8: v in W;
    c*v is LinearOperator of X,Y
    proof
      reconsider f=c*v as Function of X,Y by FUNCT_2:121;
      f is LinearOperator of X,Y
      proof
A9:     f is additive
        proof
          let x,y be VECTOR of X;
          reconsider v' = v as Element of
          Funcs(the carrier of X,the carrier of Y);
A10:      f= (FuncExtMult(the carrier of X,Y)).[c,v'] by CLVECT_1:def 1;
A11:      v' is LinearOperator of X,Y by A8,Def5;
          thus f.(x+y) = c*(v'.(x+y)) by A10,Th3
            .=c*(v'.x+v'.y) by A11,Def3
            .=c*v'.x+c*v'.y by CLVECT_1:def 2
            .=f.x+c*v'.y by A10,Th3
            .=f.x+ f.y by A10,Th3;
        end;
        f is homogeneous
        proof
          let x be VECTOR of X, s be Complex;
          reconsider v' = v as Element of
          Funcs(the carrier of X,the carrier of Y);
A12:      f= (FuncExtMult(the carrier of X,Y)).[c,v'] by CLVECT_1:def 1;
A13:      v' is LinearOperator of X,Y by A8,Def5;
          thus f.(s*x) =c*v'.(s*x) by A12,Th3
            .=c*(s*(v'.x)) by A13,Def4
            .=c*s*v'.x by CLVECT_1:def 2
            .=s*(c*v'.x) by CLVECT_1:def 2
            .=s*f.x by A12,Th3;
        end;
        hence thesis by A9;
      end;
      hence thesis;
    end;
    hence thesis by Def5;
  end;
  hence thesis by A1,CLVECT_1:def 4;
end;

theorem
  for X,Y be ComplexLinearSpace holds CLSStruct (# LinearOperators(X,Y),
    Zero_(LinearOperators(X,Y),ComplexVectSpace(the carrier of X,Y)),
    Add_(LinearOperators(X,Y), ComplexVectSpace(the carrier of X,Y)),
    Mult_(LinearOperators(X,Y), ComplexVectSpace(the carrier of X,Y)) #)
  is Subspace of ComplexVectSpace(the carrier of X,Y) by Th15,CSSPACE:13;

registration
  let X,Y be ComplexLinearSpace;
  cluster CLSStruct (# LinearOperators(X,Y),
      Zero_(LinearOperators(X,Y),ComplexVectSpace(the carrier of X,Y)),
      Add_(LinearOperators(X,Y), ComplexVectSpace(the carrier of X,Y)),
      Mult_(LinearOperators(X,Y), ComplexVectSpace(the carrier of X,Y)) #)
    -> Abelian add-associative right_zeroed right_complementable
    ComplexLinearSpace-like;
  coherence by Th15,CSSPACE:13;
end;

definition
  let X, Y be ComplexLinearSpace;
  func C_VectorSpace_of_LinearOperators(X,Y) -> ComplexLinearSpace equals
  CLSStruct (# LinearOperators(X,Y),
    Zero_(LinearOperators(X,Y),ComplexVectSpace(the carrier of X,Y)),
    Add_(LinearOperators(X,Y), ComplexVectSpace(the carrier of X,Y)),
    Mult_(LinearOperators(X,Y), ComplexVectSpace(the carrier of X,Y)) #);
  coherence;
end;

registration
  let X, Y be ComplexLinearSpace;
  cluster C_VectorSpace_of_LinearOperators(X,Y) -> strict;
  coherence;
end;

registration
  let X,Y be ComplexLinearSpace;
  cluster C_VectorSpace_of_LinearOperators(X,Y) -> constituted-Functions;
  coherence by MONOID_0:89;
end;

definition
  let X,Y be ComplexLinearSpace;
  let f be Element of C_VectorSpace_of_LinearOperators(X,Y);
  let v be VECTOR of X;
  redefine func f.v -> VECTOR of Y;
  coherence
  proof
    reconsider f as LinearOperator of X,Y by Def5;
    f.v is VECTOR of Y;
    hence thesis;
  end;
end;

canceled;

theorem Th18:
  for X,Y be ComplexLinearSpace,
  f,g,h be VECTOR of C_VectorSpace_of_LinearOperators(X,Y) holds
  h = f+g iff for x be VECTOR of X holds h.x = f.x + g.x
proof
  let X, Y be ComplexLinearSpace;
  let f,g,h be VECTOR of C_VectorSpace_of_LinearOperators(X,Y);
  reconsider f'=f,g'=g,h'=h as LinearOperator of X,Y by Def5;
A1: C_VectorSpace_of_LinearOperators(X,Y) is
  Subspace of ComplexVectSpace(the carrier of X,Y) by Th15,CSSPACE:13;
  then reconsider
  f1 = f as VECTOR of ComplexVectSpace(the carrier of X,Y) by CLVECT_1:30;
  reconsider
  g1 = g as VECTOR of ComplexVectSpace(the carrier of X,Y) by A1,CLVECT_1:30;
  reconsider
  h1 = h as VECTOR of ComplexVectSpace(the carrier of X,Y) by A1,CLVECT_1:30;
A2: now
    assume
A3: h = f+g;
    let x be Element of X;
    h1 = f1 + g1 by A1,A3,CLVECT_1:33;
    hence h'.x=f'.x+g'.x by LOPBAN_1:3;
  end;
  now
    assume for x be Element of X holds h'.x=f'.x+g'.x;
    then h1 = f1 + g1 by LOPBAN_1:3;
    hence h =f+g by A1,CLVECT_1:33;
  end;
  hence thesis by A2;
end;

theorem Th19:
  for X,Y be ComplexLinearSpace,
  f,h be VECTOR of C_VectorSpace_of_LinearOperators(X,Y), c be Complex holds
  h = c*f iff for x be VECTOR of X holds h.x = c * f.x
proof
  let X,Y be ComplexLinearSpace;
  let f,h be VECTOR of C_VectorSpace_of_LinearOperators(X,Y);
  let c be Complex;
  reconsider f'=f,h'=h as LinearOperator of X,Y by Def5;
A1: C_VectorSpace_of_LinearOperators(X,Y) is
  Subspace of ComplexVectSpace(the carrier of X,Y) by Th15,CSSPACE:13;
  then reconsider f1=f as VECTOR
  of ComplexVectSpace(the carrier of X,Y) by CLVECT_1:30;
  reconsider h1=h as VECTOR
  of ComplexVectSpace(the carrier of X,Y) by A1,CLVECT_1:30;
A2: now
    assume
A3: h = c*f;
    let x be Element of X;
    h1 = c*f1 by A1,A3,CLVECT_1:34;
    hence h'.x=c*f'.x by Th13;
  end;
  now
    assume for x be Element of X holds h'.x=c*f'.x;
    then h1=c*f1 by Th13;
    hence h =c*f by A1,CLVECT_1:34;
  end;
  hence thesis by A2;
end;

theorem Th20:
  for X,Y be ComplexLinearSpace holds
  0.C_VectorSpace_of_LinearOperators(X,Y) = (the carrier of X) -->0.Y
proof
  let X,Y be ComplexLinearSpace;
A1: C_VectorSpace_of_LinearOperators(X,Y) is
  Subspace of ComplexVectSpace(the carrier of X,Y) by Th15,CSSPACE:13;
  0.ComplexVectSpace(the carrier of X,Y)
  =((the carrier of X) -->0.Y) by LOPBAN_1:def 3;
  hence thesis by A1,CLVECT_1:31;
end;

theorem Th21:
  for X,Y be ComplexLinearSpace holds
  (the carrier of X) --> 0.Y is LinearOperator of X,Y
proof
  let X,Y be ComplexLinearSpace;
  set f=(the carrier of X) --> 0.Y;
  reconsider f as Function of X,Y;
A1: f is additive
  proof
    let x,y be VECTOR of X;
    thus f.(x+y) = 0.Y by FUNCOP_1:13
      .=0.Y+0.Y by RLVECT_1:10
      .= f.x+0.Y by FUNCOP_1:13
      .= f.x+f.y by FUNCOP_1:13;
  end;
  f is homogeneous
  proof
    let x be VECTOR of X, c be Complex;
    thus f.(c*x) =0.Y by FUNCOP_1:13
      .=c*0.Y by CLVECT_1:2
      .= c*f.x by FUNCOP_1:13;
  end;
  hence thesis by A1;
end;

begin :: Complex Normed Linear Space of Bounded Linear Operators

theorem Th22:
  for X be ComplexNormSpace, seq be sequence of X, g be Point of X holds
  seq is convergent & lim seq = g implies
  ||.seq.|| is convergent & lim ||.seq.|| = ||.g.||
proof
  let X be ComplexNormSpace;
  let seq be sequence of X;
  let g be Point of X;
  assume that
A1: seq is convergent and
A2: lim seq = g;
A3: ||.seq.|| is convergent by A1,CLVECT_1:119;
  now
    let r be real number;
A4: r is Real by XREAL_0:def 1;
    assume r > 0;
    then consider m1 be Element of NAT such that
A5: for n be Element of NAT st n >= m1 holds ||.(seq.n) - g.|| < r
    by A1,A2,A4,CLVECT_1:def 18;
    take k = m1;
    now
      let n be Element of NAT;
      assume n >= k;
      then
A6:   ||.(seq.n) - g.|| < r by A5;
      abs(||.(seq.n).|| - ||.g.||) <= ||.(seq.n) - g.|| by CLVECT_1:111;
      then abs(||.(seq.n).|| - ||.g.||) < r by A6,XXREAL_0:2;
      hence abs(||.seq.||.n - ||.g.||) < r by CLVECT_1:def 17;
    end;
    hence for n be Element of NAT st k <= n
    holds abs(||.seq.||.n - ||.g.||) < r;
  end;
  hence thesis by A3,SEQ_2:def 7;
end;

definition
  let X, Y be ComplexNormSpace;
  let IT be LinearOperator of X,Y;
  attr IT is bounded means
  :Def7:
  ex K being Real st 0 <= K &
  for x being VECTOR of X holds ||. IT.x .|| <= K * ||. x .||;
end;

theorem Th23:
  for X,Y be ComplexNormSpace holds
  for f be LinearOperator of X,Y st (for x be VECTOR of X holds f.x=0.Y)
  holds f is bounded
proof
  let X,Y be ComplexNormSpace;
  let f be LinearOperator of X,Y such that
A1: for x be VECTOR of X holds f.x=0.Y;
A2: now
    let x be VECTOR of X;
    thus ||. f.x .|| = ||. 0.Y .|| by A1
      .=0*||. x .|| by CLVECT_1:103;
  end;
  take 0;
  thus thesis by A2;
end;

registration
  let X, Y be ComplexNormSpace;
  cluster bounded LinearOperator of X,Y;
  existence
  proof
    set f=(the carrier of X) --> 0.Y;
    reconsider f as LinearOperator of X,Y by Th21;
    take f;
    for x be VECTOR of X holds f.x =0.Y by FUNCOP_1:13;
    hence thesis by Th23;
  end;
end;

definition
  let X,Y be ComplexNormSpace;
  func BoundedLinearOperators(X,Y) ->
  Subset of C_VectorSpace_of_LinearOperators(X,Y) means
  :Def8:
  for x being set holds x in it iff x is bounded LinearOperator of X,Y;
  existence
  proof
    defpred P[set] means $1 is bounded LinearOperator of X,Y;
    consider IT being set such that
A1: for x being set holds x in IT
    iff x in LinearOperators(X,Y) & P[x] from XBOOLE_0:sch 1;
A2: IT is Subset of LinearOperators(X,Y)
    proof
      for x be set st x in IT holds x in LinearOperators(X,Y) by A1;
      hence thesis by TARSKI:def 3;
    end;
    take IT;
    thus IT is Subset of C_VectorSpace_of_LinearOperators(X,Y) by A2;
    let x be set;
    thus x in IT implies x is bounded LinearOperator of X,Y by A1;
    assume
A3: x is bounded LinearOperator of X,Y;
    then x in LinearOperators(X,Y) by Def5;
    hence thesis by A1,A3;
  end;
  uniqueness
  proof
    let X1,X2 be Subset of C_VectorSpace_of_LinearOperators(X,Y);
    assume that
A4: for x being set holds x in X1 iff x is bounded LinearOperator of X,Y and
A5: for x being set holds x in X2 iff x is bounded LinearOperator of X,Y;
    for x being set st x in X1 holds x in X2
    proof
      let x be set;
      assume x in X1;
      then x is bounded LinearOperator of X,Y by A4;
      hence thesis by A5;
    end;
    then
A6: X1 c= X2 by TARSKI:def 3;
    for x being set st x in X2 holds x in X1
    proof
      let x be set;
      assume x in X2;
      then x is bounded LinearOperator of X,Y by A5;
      hence thesis by A4;
    end;
    then X2 c= X1 by TARSKI:def 3;
    hence thesis by A6,XBOOLE_0:def 10;
  end;
end;

registration
  let X, Y be ComplexNormSpace;
  cluster BoundedLinearOperators(X,Y) -> non empty;
  coherence
  proof
    set f=(the carrier of X) --> 0.Y;
    reconsider f as LinearOperator of X,Y by Th21;
    f is bounded
    proof
      for x be VECTOR of X holds f.x =0.Y by FUNCOP_1:13;
      hence thesis by Th23;
    end;
    hence thesis by Def8;
  end;
end;

theorem Th24:
  for X,Y be ComplexNormSpace holds
  BoundedLinearOperators(X,Y) is linearly-closed
proof
  let X,Y be ComplexNormSpace;
  set W = BoundedLinearOperators(X,Y);
A1: for v,u be VECTOR of C_VectorSpace_of_LinearOperators(X,Y) st
  v in W & u in W holds v + u in W
  proof
    let v,u be VECTOR of C_VectorSpace_of_LinearOperators(X,Y) such that
A2: v in W & u in W;
    reconsider f=v+u as LinearOperator of X,Y by Def5;
    f is bounded
    proof
      reconsider u1=u as bounded LinearOperator of X,Y by A2,Def8;
      reconsider v1=v as bounded LinearOperator of X,Y by A2,Def8;
      consider K1 be Real such that
A3:   0 <= K1 & for x be VECTOR of X holds ||. u1.x .|| <= K1*||.x.|| by Def7;
      consider K2 be Real such that
A4:   0 <= K2 & for x be VECTOR of X holds ||. v1.x .|| <= K2*||.x.|| by Def7;
      take K3=K1+K2;
A5:   0 + 0 <= K1+K2 by A3,A4;
      now
        let x be VECTOR of X;
A6:     ||. f.x .|| =||. u1.x+v1.x .|| by Th18;
A7:     ||. u1.x+v1.x .|| <= ||. u1.x .||+ ||. v1.x .|| by CLVECT_1:def 11;
A8:     ||. u1.x .|| <= K1*||. x .|| by A3;
        ||. v1.x .|| <= K2*||. x .|| by A4;
        then ||. u1.x .|| + ||. v1.x .|| <= K1*||. x .|| +K2*||. x .||
        by A8,XREAL_1:9;
        hence ||. f.x .|| <= K3*||. x .|| by A6,A7,XXREAL_0:2;
      end;
      hence thesis by A5;
    end;
    hence thesis by Def8;
  end;
  for c be Complex, v be VECTOR of C_VectorSpace_of_LinearOperators(X,Y)
  st v in W holds c * v in W
  proof
    let c be Complex;
    let v be VECTOR of C_VectorSpace_of_LinearOperators(X,Y) such that
A9: v in W;
    reconsider f=c*v as LinearOperator of X,Y by Def5;
    f is bounded
    proof
      reconsider v1=v as bounded LinearOperator of X,Y by A9,Def8;
      consider K be Real such that
A10:  0 <= K & for x be VECTOR of X holds ||. v1.x .|| <= K*||. x .|| by Def7;
      take K1=|.c.| * K;
A11:  0 <= K & 0 <=|.c.| by A10,COMPLEX1:132;
      now
        let x be VECTOR of X;
A12:    ||. c*v1.x .|| = |.c.|* ||. v1.x .|| by CLVECT_1:def 11;
        0 <=|.c.| by COMPLEX1:132;
        then |.c.| * ||. v1.x .|| <= |.c.| * (K*||. x .||) by A10,XREAL_1:66;
        hence ||. f.x .|| <= |.c.| * K*||. x .|| by A12,Th19;
      end;
      hence thesis by A11;
    end;
    hence thesis by Def8;
  end;
  hence thesis by A1,CLVECT_1:def 4;
end;

theorem
  for X,Y be ComplexNormSpace holds CLSStruct (# BoundedLinearOperators(X,Y),
    Zero_(BoundedLinearOperators(X,Y), C_VectorSpace_of_LinearOperators(X,Y)),
    Add_(BoundedLinearOperators(X,Y), C_VectorSpace_of_LinearOperators(X,Y)),
    Mult_(BoundedLinearOperators(X,Y),C_VectorSpace_of_LinearOperators(X,Y)) #)
  is Subspace of C_VectorSpace_of_LinearOperators(X,Y) by Th24,CSSPACE:13;

registration
  let X, Y be ComplexNormSpace;
  cluster CLSStruct (# BoundedLinearOperators(X,Y),

Zero_(BoundedLinearOperators(X,Y), C_VectorSpace_of_LinearOperators(X,Y)),
      Add_(BoundedLinearOperators(X,Y), C_VectorSpace_of_LinearOperators(X,Y)),

Mult_(BoundedLinearOperators(X,Y),C_VectorSpace_of_LinearOperators(X,Y)) #)
    -> Abelian add-associative right_zeroed right_complementable
    ComplexLinearSpace-like;
  coherence by Th24,CSSPACE:13;
end;

definition
  let X, Y be ComplexNormSpace;
  func C_VectorSpace_of_BoundedLinearOperators(X,Y)
  -> ComplexLinearSpace equals

  CLSStruct (# BoundedLinearOperators(X,Y),
    Zero_(BoundedLinearOperators(X,Y), C_VectorSpace_of_LinearOperators(X,Y)),
    Add_(BoundedLinearOperators(X,Y), C_VectorSpace_of_LinearOperators(X,Y)),

Mult_(BoundedLinearOperators(X,Y), C_VectorSpace_of_LinearOperators(X,Y)) #);
  coherence;
end;

registration
  let X,Y be ComplexNormSpace;
  cluster C_VectorSpace_of_BoundedLinearOperators(X,Y) -> strict;
  coherence;
end;

registration
  let X,Y be ComplexNormSpace;
  cluster -> Function-like Relation-like Element of
    C_VectorSpace_of_BoundedLinearOperators(X,Y);
  coherence by Def8;
end;

definition
  let X,Y be ComplexNormSpace;
  let f be Element of C_VectorSpace_of_BoundedLinearOperators(X,Y);
  let v be VECTOR of X;
  redefine func f.v -> VECTOR of Y;
  coherence
  proof
    reconsider f as LinearOperator of X,Y by Def8;
    f.v is VECTOR of Y;
    hence thesis;
  end;
end;

canceled;

theorem Th27:
  for X,Y be ComplexNormSpace,
  f,g,h be VECTOR of C_VectorSpace_of_BoundedLinearOperators(X,Y) holds
  h = f+g iff for x be VECTOR of X holds h.x = f.x + g.x
proof
  let X,Y be ComplexNormSpace;
  let f,g,h be VECTOR of C_VectorSpace_of_BoundedLinearOperators(X,Y);
A1: C_VectorSpace_of_BoundedLinearOperators(X,Y) is
  Subspace of C_VectorSpace_of_LinearOperators(X,Y) by Th24,CSSPACE:13;
  then reconsider f1=f as VECTOR of C_VectorSpace_of_LinearOperators(X,Y)
  by CLVECT_1:30;
  reconsider g1=g as VECTOR of C_VectorSpace_of_LinearOperators(X,Y)
  by A1,CLVECT_1:30;
  reconsider h1=h as VECTOR of C_VectorSpace_of_LinearOperators(X,Y)
  by A1,CLVECT_1:30;
  hereby
    assume
A2: h = f+g;
    let x be Element of X;
    h1=f1+g1 by A1,A2,CLVECT_1:33;
    hence h.x=f.x+g.x by Th18;
  end;
  assume for x be Element of X holds h.x=f.x+g.x;
  then h1=f1+g1 by Th18;
  hence h =f+g by A1,CLVECT_1:33;
end;

theorem Th28:
  for X,Y be ComplexNormSpace,
  f,h be VECTOR of C_VectorSpace_of_BoundedLinearOperators(X,Y),
  c be Complex holds h = c*f iff for x be VECTOR of X holds h.x = c * f.x
proof
  let X,Y be ComplexNormSpace;
  let f,h be VECTOR of C_VectorSpace_of_BoundedLinearOperators(X,Y);
  let c be Complex;
A1: C_VectorSpace_of_BoundedLinearOperators(X,Y) is
  Subspace of C_VectorSpace_of_LinearOperators(X,Y) by Th24,CSSPACE:13;
  then reconsider f1=f as VECTOR of C_VectorSpace_of_LinearOperators(X,Y)
  by CLVECT_1:30;
  reconsider h1=h as VECTOR of C_VectorSpace_of_LinearOperators(X,Y)
  by A1,CLVECT_1:30;
  hereby
    assume
A2: h = c*f;
    let x be Element of X;
    h1=c*f1 by A1,A2,CLVECT_1:34;
    hence h.x=c*f.x by Th19;
  end;
  assume for x be Element of X holds h.x=c*f.x;
  then h1=c*f1 by Th19;
  hence h =c*f by A1,CLVECT_1:34;
end;

theorem Th29:
  for X,Y be ComplexNormSpace holds
  0.C_VectorSpace_of_BoundedLinearOperators(X,Y) = (the carrier of X) --> 0.Y
proof
  let X,Y be ComplexNormSpace;
A1: C_VectorSpace_of_BoundedLinearOperators(X,Y) is
  Subspace of C_VectorSpace_of_LinearOperators(X,Y) by Th24,CSSPACE:13;
  0.C_VectorSpace_of_LinearOperators(X,Y)
  =((the carrier of X) -->0.Y) by Th20;
  hence thesis by A1,CLVECT_1:31;
end;

definition
  let X, Y be ComplexNormSpace;
  let f be set such that
A1: f in BoundedLinearOperators(X,Y);
  func modetrans(f,X,Y) -> bounded LinearOperator of X,Y equals
  :Def10:
  f;
  coherence by A1,Def8;
end;

definition
  let X, Y be ComplexNormSpace;
  let u be LinearOperator of X,Y;
  func PreNorms(u) -> non empty Subset of REAL equals
  {||.u.t.|| where t is VECTOR of X : ||.t.|| <= 1 };
  coherence
  proof
A1: now
      let x be set;
      now
        assume x in {||.u.t.|| where t is VECTOR of X : ||.t.|| <= 1 };
        then consider t be VECTOR of X such that
A2:     x=||.u.t.|| & ||.t.|| <= 1;
        thus x in REAL by A2;
      end;

hence x in {||.u.t.|| where t is VECTOR of X : ||.t.|| <= 1 } implies x in
      REAL;
    end;
    ||.0.X.|| = 0 by CLVECT_1:103;
    then ||.u.(0.X).|| in {||.u.t.|| where t is VECTOR of X : ||.t.|| <= 1 };
    hence thesis by A1,TARSKI:def 3;
  end;
end;

theorem Th30:
  for X,Y be ComplexNormSpace, g be bounded LinearOperator of X,Y holds
  PreNorms(g) is non empty bounded_above
proof
  let X,Y be ComplexNormSpace;
  let g be bounded LinearOperator of X,Y;
  PreNorms(g) is bounded_above
  proof
    consider K be Real such that
A1: 0 <= K and
A2: for x be VECTOR of X holds ||. g.x .|| <= K*||. x .|| by Def7;
A3: now
      let r be Real such that
A4:   r in PreNorms(g);
      consider t be VECTOR of X such that
A5:   r=||.g.t.|| & ||.t.|| <= 1 by A4;
A6:   ||.g.t.|| <= K*||. t .|| by A2;
      K*||. t .|| <= K *1 by A1,A5,XREAL_1:66;
      hence r <=K by A5,A6,XXREAL_0:2;
    end;
    take K;
    thus thesis by A3;
  end;
  hence thesis;
end;

theorem
  for X,Y be ComplexNormSpace, g be LinearOperator of X,Y holds
  g is bounded iff PreNorms(g) is bounded_above
proof
  let X,Y be ComplexNormSpace;
  let g be LinearOperator of X,Y;
  now
    assume
A1: PreNorms(g) is bounded_above;
    reconsider K=sup PreNorms(g) as Real;
A2: 0 <= K
    proof
A3:   now
        let r be Real such that
A4:     r in PreNorms(g);
        consider t be VECTOR of X such that
A5:     r=||.g.t.|| & ||.t.|| <= 1 by A4;
        thus 0 <= r by A5,CLVECT_1:106;
      end;
      consider r0 be set such that
A6:   r0 in PreNorms(g) by XBOOLE_0:def 1;
      reconsider r0 as Real by A6;
      0 <= r0 by A3,A6;
      hence thesis by A1,A6,SEQ_4:def 4;
    end;
A7: now
      let t be VECTOR of X;
      now per cases;
        case
A8:       t = 0.X;
          then
A9:       g.t = g.(0c*0.X) by CLVECT_1:2
            .=0c*g.(0.X) by Def4
            .=0.Y by CLVECT_1:2;
          ||.t.|| = 0 by A8,CLVECT_1:def 11;
          hence ||.g.t.|| <= K*||.t.|| by A9,CLVECT_1:def 11;
        end;
        case t <> 0.X;
          then
A10:      ||.t.|| <> 0 by CLVECT_1:def 11;
          then
A11:      ||.t.|| > 0 by CLVECT_1:106;
A12:      |. ||.t.||"+0*<i> .| =abs( 1*||.t.||" )
            .=abs( 1/||.t.||) by XCMPLX_0:def 9
            .=1/abs( ||.t.||) by ABSVALUE:15
            .=1/||.t.|| by A11,ABSVALUE:def 1
            .=1*||.t.||" by XCMPLX_0:def 9
            .=||.t.||";
          reconsider t0 = ||.t.||"+0*<i> as Element of COMPLEX
          by XCMPLX_0:def 2;
          reconsider t1= t0 * t as VECTOR of X;
A13:      ||.t1.|| = |.t0.| * ||.t.|| by CLVECT_1:def 11
            .=1 by A10,A12,XCMPLX_0:def 7;
          ||.g.t.||/||.t.|| =||.g.t.|| * |. t0 .| by A12,XCMPLX_0:def 9
            .=||. t0*g.t .|| by CLVECT_1:def 11
            .=||.g.t1.|| by Def4;
          then ||.g.t.||/||.t.|| in PreNorms(g) by A13;
          then
A14:      ||.g.t.||/||.t.|| <= K by A1,SEQ_4:def 4;
          ||.g.t.||/||.t.||*||.t.||
          = ||.g.t.||*||.t.||"*||.t.|| by XCMPLX_0:def 9
            .=||.g.t.||*(||.t.||"*||.t.||)
            .=||.g.t.||*1 by A10,XCMPLX_0:def 7
            .=||.g.t.||;
          hence ||.g.t.|| <= K *||.t.|| by A11,A14,XREAL_1:66;
        end;
      end;
      hence ||.g.t.|| <= K*||.t.||;
    end;
    take K;
    thus g is bounded by A2,A7,Def7;
  end;
  hence thesis by Th30;
end;

theorem Th32:
  for X,Y be ComplexNormSpace
  ex NORM be Function of BoundedLinearOperators(X,Y),REAL st
  for f be set st f in BoundedLinearOperators(X,Y) holds
  NORM.f = sup PreNorms(modetrans(f,X,Y))
proof
  let X,Y be ComplexNormSpace;
  deffunc F(set) = sup PreNorms(modetrans($1,X,Y));
A1: for z be set st z in BoundedLinearOperators(X,Y) holds F(z) in REAL;
  ex f being Function of BoundedLinearOperators(X,Y),REAL st
  for x being set st x in BoundedLinearOperators(X,Y) holds
  f.x = F(x) from FUNCT_2:sch 2(A1);
  hence thesis;
end;

definition
  let X, Y be ComplexNormSpace;
  func BoundedLinearOperatorsNorm(X,Y)
  -> Function of BoundedLinearOperators(X,Y), REAL means
  :Def12:
  for x be set st x in BoundedLinearOperators(X,Y) holds
  it.x = sup PreNorms(modetrans(x,X,Y));
  existence by Th32;
  uniqueness
  proof
    let NORM1,NORM2 be Function of BoundedLinearOperators(X,Y), REAL such that
A1: (for x be set st x in BoundedLinearOperators(X,Y) holds
    NORM1.x = sup PreNorms(modetrans(x,X,Y))) and
A2: (for x be set st x in BoundedLinearOperators(X,Y) holds
    NORM2.x = sup PreNorms(modetrans(x,X,Y)));
A3: dom NORM1 = BoundedLinearOperators(X,Y) &
    dom NORM2 = BoundedLinearOperators(X,Y) by FUNCT_2:def 1;
    for z be set st z in BoundedLinearOperators(X,Y) holds NORM1.z = NORM2.z
    proof
      let z be set such that
A4:   z in BoundedLinearOperators(X,Y);
      NORM1.z = sup PreNorms(modetrans(z,X,Y)) by A1,A4;
      hence thesis by A2,A4;
    end;
    hence thesis by A3,FUNCT_1:9;
  end;
end;

theorem Th33:
  for X,Y be ComplexNormSpace, f be bounded LinearOperator of X,Y holds
  modetrans(f,X,Y)=f
proof
  let X,Y be ComplexNormSpace;
  let f be bounded LinearOperator of X,Y;
  f in BoundedLinearOperators(X,Y) by Def8;
  hence thesis by Def10;
end;

theorem Th34:
  for X,Y be ComplexNormSpace, f be bounded LinearOperator of X,Y holds
  BoundedLinearOperatorsNorm(X,Y).f = sup PreNorms(f)
proof
  let X,Y be ComplexNormSpace;
  let f be bounded LinearOperator of X,Y;
A1: f in BoundedLinearOperators(X,Y) by Def8;
  reconsider f'=f as set;
  thus BoundedLinearOperatorsNorm(X,Y).f
  = sup PreNorms(modetrans(f',X,Y)) by A1,Def12
    .= sup PreNorms(f) by Th33;
end;

definition
  let X,Y be ComplexNormSpace;
  func C_NormSpace_of_BoundedLinearOperators(X,Y) -> non empty CNORMSTR equals
  CNORMSTR (# BoundedLinearOperators(X,Y), Zero_(BoundedLinearOperators(X,Y),
    C_VectorSpace_of_LinearOperators(X,Y)), Add_(BoundedLinearOperators(X,Y),
    C_VectorSpace_of_LinearOperators(X,Y)), Mult_(BoundedLinearOperators(X,Y),
    C_VectorSpace_of_LinearOperators(X,Y)),
    BoundedLinearOperatorsNorm(X,Y) #);
  coherence;
end;

theorem Th35:
  for X,Y be ComplexNormSpace holds (the carrier of X) --> 0.Y
  = 0.C_NormSpace_of_BoundedLinearOperators(X,Y)
proof
  let X,Y be ComplexNormSpace;
  ((the carrier of X) --> 0.Y)
  =0.C_VectorSpace_of_BoundedLinearOperators(X,Y) by Th29
    .=0.C_NormSpace_of_BoundedLinearOperators(X,Y);
  hence thesis;
end;

theorem Th36:
  for X,Y be ComplexNormSpace,
  f being Point of C_NormSpace_of_BoundedLinearOperators(X,Y),
  g be bounded LinearOperator of X,Y st g=f holds
  for t be VECTOR of X holds ||.g.t.|| <= ||.f.|| * ||.t.||
proof
  let X,Y be ComplexNormSpace;
  let f being Point of C_NormSpace_of_BoundedLinearOperators(X,Y);
  let g be bounded LinearOperator of X,Y such that
A1: g=f;
A2: PreNorms(g) is non empty bounded_above by Th30;
  now
    let t be VECTOR of X;
    now per cases;
      case
A3:     t = 0.X;
        then
A4:     g.t =g.(0c * 0.X) by CLVECT_1:2
          .=0c * g.(0.X) by Def4
          .=0.Y by CLVECT_1:2;
        ||.t.|| = 0 by A3,CLVECT_1:def 11;
        hence ||.g.t.|| <= ||.f.||*||.t.|| by A4,CLVECT_1:def 11;
      end;
      case t <> 0.X;
        then
A5:     ||.t.|| <> 0 by CLVECT_1:def 11;
        then
A6:     ||.t.|| > 0 by CLVECT_1:106;
        reconsider t0 = ||.t.||"+0*<i> as Element of COMPLEX
        by XCMPLX_0:def 2;
A7:     |. t0 .| =abs( 1*||.t.||" )
          .=abs( 1/||.t.||) by XCMPLX_0:def 9
          .=1/abs( ||.t.||) by ABSVALUE:15
          .=1/||.t.|| by A6,ABSVALUE:def 1
          .=1*||.t.||" by XCMPLX_0:def 9
          .=||.t.||";
        reconsider t1= t0*t as VECTOR of X;
A8:     ||.t1.|| = |.t0.| * ||.t.|| by CLVECT_1:def 11
          .=1 by A5,A7,XCMPLX_0:def 7;
        ||.g.t.||/||.t.|| =||.g.t.|| * |. t0 .| by A7,XCMPLX_0:def 9
          .=||.t0*g.t.|| by CLVECT_1:def 11
          .=||.g.t1.|| by Def4;
        then ||.g.t.||/||.t.|| in
        {||.g.s.|| where s is VECTOR of X : ||.s.|| <= 1 } by A8;
        then ||.g.t.||/||.t.|| <= sup PreNorms(g) by A2,SEQ_4:def 4;
        then ||.g.t.||/||.t.|| <= BoundedLinearOperatorsNorm(X,Y).g by Th34;
        then
A9:     ||.g.t.||/||.t.|| <= ||.f.|| by A1,CLVECT_1:def 10;
        ||.g.t.||/||.t.||*||.t.||
        = ||.g.t.||*||.t.||"*||.t.|| by XCMPLX_0:def 9
          .=||.g.t.||*(||.t.||"*||.t.||)
          .=||.g.t.||*1 by A5,XCMPLX_0:def 7
          .=||.g.t.||;
        hence ||.g.t.|| <= ||.f.||*||.t.|| by A6,A9,XREAL_1:66;
      end;
    end;
    hence ||.g.t.|| <= ||.f.||*||.t.||;
  end;
  hence thesis;
end;

theorem Th37:
  for X,Y be ComplexNormSpace,
  f being Point of C_NormSpace_of_BoundedLinearOperators(X,Y) holds
  0 <= ||.f.||
proof
  let X,Y be ComplexNormSpace;
  let f being Point of C_NormSpace_of_BoundedLinearOperators(X,Y);
  reconsider g=f as bounded LinearOperator of X,Y by Def8;
A1: now
    let r be Real such that
A2: r in PreNorms(g);
    consider t be VECTOR of X such that
A3: r=||.g.t.|| & ||.t.|| <= 1 by A2;
    thus 0 <= r by A3,CLVECT_1:106;
  end;
A4: PreNorms(g) is non empty bounded_above by Th30;
  consider r0 be set such that
A5: r0 in PreNorms(g) by XBOOLE_0:def 1;
  reconsider r0 as Real by A5;
  0 <= r0 by A1,A5;
  then
A6: 0 <=sup PreNorms(g) by A4,A5,SEQ_4:def 4;
  BoundedLinearOperatorsNorm(X,Y).f = sup PreNorms(g) by Th34;
  hence thesis by A6,CLVECT_1:def 10;
end;

theorem Th38:
  for X,Y be ComplexNormSpace,
  f being Point of C_NormSpace_of_BoundedLinearOperators(X,Y)
  st f = 0.C_NormSpace_of_BoundedLinearOperators(X,Y) holds 0 = ||.f.||
proof
  let X,Y be ComplexNormSpace;
  let f being Point of C_NormSpace_of_BoundedLinearOperators(X,Y) such that
A1: f = 0.C_NormSpace_of_BoundedLinearOperators(X,Y);
  thus ||.f.|| = 0
  proof
    set z = (the carrier of X) --> 0.Y;
    reconsider z as Function of the carrier of X, the carrier of Y;
    reconsider g=f as bounded LinearOperator of X,Y by Def8;
A2: z=g by A1,Th35;
A3: now
      let r be Real such that
A4:   r in PreNorms(g);
      consider t be VECTOR of X such that
A5:   r=||.g.t.|| & ||.t.|| <= 1 by A4;
      ||.g.t.|| = ||.0.Y.|| by A2,FUNCOP_1:13
        .= 0 by CLVECT_1:def 11;
      hence 0 <= r & r <=0 by A5;
    end;
A6: PreNorms(g) is non empty bounded_above by Th30;
    consider r0 be set such that
A7: r0 in PreNorms(g) by XBOOLE_0:def 1;
    reconsider r0 as Real by A7;
A8: 0 <= r0 & r0<=0 by A3,A7;
    (for s be real number st s in PreNorms(g) holds s <= 0)
    implies sup PreNorms(g) <= 0 by SEQ_4:62;
    then sup PreNorms(g) = 0 by A3,A6,A7,A8,SEQ_4:def 4;
    then BoundedLinearOperatorsNorm(X,Y).f=0 by Th34;
    hence thesis by CLVECT_1:def 10;
  end;
end;

registration
  let X,Y be ComplexNormSpace;
  cluster -> Function-like Relation-like
    Element of C_NormSpace_of_BoundedLinearOperators(X,Y);
  coherence by Def8;
end;

definition
  let X,Y be ComplexNormSpace;
  let f be Element of C_NormSpace_of_BoundedLinearOperators(X,Y);
  let v be VECTOR of X;
  redefine func f.v -> VECTOR of Y;
  coherence
  proof
    reconsider f as LinearOperator of X,Y by Def8;
    f.v is VECTOR of Y;
    hence thesis;
  end;
end;

theorem Th39:
  for X,Y be ComplexNormSpace,
  f,g,h be Point of C_NormSpace_of_BoundedLinearOperators(X,Y) holds
  h = f+g iff for x be VECTOR of X holds h.x = f.x + g.x
proof
  let X,Y be ComplexNormSpace;
  let f,g,h be Point of C_NormSpace_of_BoundedLinearOperators(X,Y);
  reconsider f1=f, g1=g, h1=h as VECTOR of
  C_VectorSpace_of_BoundedLinearOperators(X,Y);
  h=f+g iff h1=f1+g1;
  hence thesis by Th27;
end;

theorem Th40:
  for X,Y be ComplexNormSpace,
  f,h be Point of C_NormSpace_of_BoundedLinearOperators(X,Y),
  c be Complex holds h = c*f iff for x be VECTOR of X holds h.x = c * f.x
proof
  let X,Y be ComplexNormSpace;
  let f,h be Point of C_NormSpace_of_BoundedLinearOperators(X,Y);
  let c be Complex;
  reconsider f1=f as VECTOR of C_VectorSpace_of_BoundedLinearOperators(X,Y);
  reconsider h1=h as VECTOR of C_VectorSpace_of_BoundedLinearOperators(X,Y);
  h=c*f iff h1=c*f1
  proof
A1: now
      assume h=c*f;
      hence h1=Mult_(BoundedLinearOperators(X,Y),
      C_VectorSpace_of_LinearOperators(X,Y)).[c,f] by CLVECT_1:def 1
        .=c*f1 by CLVECT_1:def 1;
    end;
    now
      assume h1=c*f1;
      hence h=Mult_(BoundedLinearOperators(X,Y),
      C_VectorSpace_of_LinearOperators(X,Y)).[c,f1] by CLVECT_1:def 1
        .=c*f by CLVECT_1:def 1;
    end;
    hence thesis by A1;
  end;
  hence thesis by Th28;
end;

theorem Th41:
  for X,Y be ComplexNormSpace,
  f, g being Point of C_NormSpace_of_BoundedLinearOperators(X,Y),
  c be Complex holds ( ||.f.|| = 0 iff
  f = 0.C_NormSpace_of_BoundedLinearOperators(X,Y) ) &
  ||.c*f.|| = |.c.| * ||.f.|| & ||.f+g.|| <= ||.f.|| + ||.g.||
proof
  let X,Y be ComplexNormSpace;
  let f,g being Point of C_NormSpace_of_BoundedLinearOperators(X,Y);
  let c be Complex;
A1: now
    assume
A2: ||.f.|| = 0;
    reconsider g=f as bounded LinearOperator of X,Y by Def8;
    set z = (the carrier of X) --> 0.Y;
    reconsider z as Function of the carrier of X, the carrier of Y;
    now
      let t be VECTOR of X;
      ||.g.t.|| <= ||.f.|| *||.t.|| by Th36;
      then ||.g.t.|| = 0 by A2,CLVECT_1:106;
      hence g.t =0.Y by CLVECT_1:def 11
        .=z.t by FUNCOP_1:13;
    end;
    then g=z by FUNCT_2:113;
    hence f=0.C_NormSpace_of_BoundedLinearOperators(X,Y) by Th35;
  end;
A3: now
    assume
A4: f = 0.C_NormSpace_of_BoundedLinearOperators(X,Y);
    thus ||.f.|| = 0
    proof
      set z = (the carrier of X) --> 0.Y;
      reconsider z as Function of the carrier of X, the carrier of Y;
      reconsider g=f as bounded LinearOperator of X,Y by Def8;
A5:   z=g by A4,Th35;
A6:   now
        let r be Real such that
A7:     r in PreNorms(g);
        consider t be VECTOR of X such that
A8:     r=||.g.t.|| & ||.t.|| <= 1 by A7;
        ||.g.t.|| = ||.0.Y.|| by A5,FUNCOP_1:13
          .= 0 by CLVECT_1:def 11;
        hence 0 <= r & r <=0 by A8;
      end;
A9:   PreNorms(g) is non empty bounded_above by Th30;
      consider r0 be set such that
A10:  r0 in PreNorms(g) by XBOOLE_0:def 1;
      reconsider r0 as Real by A10;
A11:  0<=r0 by A6,A10;
      (for s be real number st s in PreNorms(g) holds s <= 0)
      implies sup PreNorms(g) <= 0 by SEQ_4:62;
      then sup PreNorms(g) = 0 by A6,A9,A10,A11,SEQ_4:def 4;
      then BoundedLinearOperatorsNorm(X,Y).f =0 by Th34;
      hence thesis by CLVECT_1:def 10;
    end;
  end;
A12: ||.c*f.|| = |.c.| * ||.f.||
  proof
    reconsider f1=f, h1=c*f as bounded LinearOperator of X,Y by Def8;
A13: now
      let t be VECTOR of X such that
A14:  ||.t.|| <= 1;
A15:  ||.h1.t.||= ||.c*f1.t.|| by Th40;
A16:  ||.c*f1.t.|| =|.c.|*||.f1.t.|| by CLVECT_1:def 11;
A17:  ||.f1.t.||<= ||.f.||*||.t.|| by Th36;
      0 <= ||.f.|| by Th37;
      then ||.f.||*||.t.|| <= ||.f.||*1 by A14,XREAL_1:66;
      then
A18:  ||.f1.t.|| <= ||.f.|| by A17,XXREAL_0:2;
      0<= |.c.| by COMPLEX1:132;
      hence ||.h1.t.|| <= |.c.|*||.f.|| by A15,A16,A18,XREAL_1:66;
    end;
A19: now
      let r be Real such that
A20:  r in PreNorms(h1);
      consider t be VECTOR of X such that
A21:  r=||.h1.t.|| & ||.t.|| <= 1 by A20;
      thus r <= |.c.|*||.f.|| by A13,A21;
    end;
A22: (for s be real number st s in PreNorms(h1) holds s <= |.c.|*||.f.|| )
    implies sup PreNorms(h1) <= |.c.|*||.f.|| by SEQ_4:62;
    BoundedLinearOperatorsNorm(X,Y).(c*f) = sup PreNorms(h1) by Th34;
    then
A23: ||.c*f.|| <= |.c.|*||.f.|| by A19,A22,CLVECT_1:def 10;
    now per cases;
      case
A24:    c <> 0c;
A25:    now
          let t be VECTOR of X such that
A26:      ||.t.|| <= 1;
          h1.t=c*f1.t by Th40;
          then
A27:      c"*h1.t =( c"* c)*f1.t by CLVECT_1:def 2
            .=1r*f1.t by A24,COMPLEX1:def 7,XCMPLX_0:def 7
            .=f1.t by CLVECT_1:def 2;
A28:      ||.c"*h1.t.|| =|.c".|*||.h1.t.|| by CLVECT_1:def 11;
A29:      ||.h1.t.||<= ||.c*f.||*||.t.|| by Th36;
          0 <= ||.c*f.|| by Th37;
          then ||.c*f.||*||.t.|| <= ||.c*f.||*1 by A26,XREAL_1:66;
          then
A30:      ||.h1.t.|| <= ||.c*f.|| by A29,XXREAL_0:2;
A31:      0<= |.c".| by COMPLEX1:132;
          |.c".| =|.c.|" by COMPLEX1:152;
          hence ||.f1.t.|| <= |.c.|"*||.c*f.|| by A27,A28,A30,A31,XREAL_1:66;
        end;
A32:    now
          let r be Real such that
A33:      r in PreNorms(f1);
          consider t be VECTOR of X such that
A34:      r=||.f1.t.|| & ||.t.|| <= 1 by A33;
          thus r <= |.c.|"*||.c*f.|| by A25,A34;
        end;
A35:    |.c.| <>0 by A24,COMPLEX1:133;
A36:    (for s be real number st s in PreNorms(f1) holds
        s <= |.c.|"*||.c*f.|| )
        implies sup PreNorms(f1) <= |.c.|"*||.c*f.|| by SEQ_4:62;
        BoundedLinearOperatorsNorm(X,Y).(f) = sup PreNorms(f1) by Th34;
        then
A37:    ||.f.|| <=|.c.|"*||.c*f.|| by A32,A36,CLVECT_1:def 10;
        0 <= |.c.| by COMPLEX1:132;
        then |.c.|*||.f.|| <=|.c.|*(|.c.|"*||.c*f.||) by A37,XREAL_1:66;
        then |.c.|*||.f.|| <=(|.c.|*|.c.|")*||.c*f.||;
        then |.c.|*||.f.|| <=1*||.c*f.|| by A35,XCMPLX_0:def 7;
        hence |.c.|* ||.f.|| <=||.c*f.||;
      end;
      case
A38:    c = 0c;
        reconsider fz=f as VECTOR
        of C_VectorSpace_of_BoundedLinearOperators(X,Y);
        c*f =Mult_(BoundedLinearOperators(X,Y),
        C_VectorSpace_of_LinearOperators(X,Y)).[c,f] by CLVECT_1:def 1
          .=c*fz by CLVECT_1:def 1
          .=0.C_VectorSpace_of_BoundedLinearOperators(X,Y) by A38,CLVECT_1:2
          .=0.C_NormSpace_of_BoundedLinearOperators(X,Y);
        hence |.c.|* ||.f.|| =||.c*f.|| by A38,Th38,COMPLEX1:130;
      end;
    end;
    hence thesis by A23,XXREAL_0:1;
  end;
  ||.f+g.|| <= ||.f.|| + ||.g.||
  proof
    reconsider f1=f, g1=g, h1=f+g as bounded LinearOperator of X,Y by Def8;
A39: now
      let t be VECTOR of X such that
A40:  ||.t.|| <= 1;
A41:  ||.h1.t.||= ||.f1.t+g1.t.|| by Th39;
A42:  ||.f1.t+g1.t.|| <=||.f1.t.||+||.g1.t.|| by CLVECT_1:def 11;
A43:  ||.f1.t.||<= ||.f.||*||.t.|| by Th36;
      ||.g1.t.||<= ||.g.||*||.t.|| by Th36;
      then
A44:  ||.f1.t.||+||.g1.t.|| <= ||.f.||*||.t.|| + ||.g.||*||.t.||
      by A43,XREAL_1:9;
      0 <= ||.f.|| by Th37;
      then
A45:  ||.f.||*||.t.|| <= ||.f.||*1 by A40,XREAL_1:66;
      0 <= ||.g.|| by Th37;
      then ||.g.||*||.t.|| <= ||.g.||*1 by A40,XREAL_1:66;
      then ||.f.||*||.t.|| + ||.g.||*||.t.|| <= ||.f.||*1 + ||.g.||*1
      by A45,XREAL_1:9;
      then ||.f1.t.||+||.g1.t.|| <= ||.f.|| + ||.g.|| by A44,XXREAL_0:2;
      hence ||.h1.t.|| <= ||.f.|| + ||.g.|| by A41,A42,XXREAL_0:2;
    end;
A46: now
      let r be Real such that
A47:  r in PreNorms(h1);
      consider t be VECTOR of X such that
A48:  r=||.h1.t.|| & ||.t.|| <= 1 by A47;
      thus r <= ||.f.|| + ||.g.|| by A39,A48;
    end;
A49: (for s be real number st s in PreNorms(h1) holds s <= ||.f.|| + ||.g.||)
    implies sup PreNorms(h1) <= ||.f.|| + ||.g.|| by SEQ_4:62;
    BoundedLinearOperatorsNorm(X,Y).(f+g) = sup PreNorms(h1) by Th34;
    hence ||.f+g.|| <=||.f.|| + ||.g.|| by A46,A49,CLVECT_1:def 10;
  end;
  hence thesis by A1,A3,A12;
end;

theorem Th42:
  for X,Y be ComplexNormSpace holds
  C_NormSpace_of_BoundedLinearOperators(X,Y) is ComplexNormSpace-like
proof
  let X,Y be ComplexNormSpace;
  for x, y being Point of C_NormSpace_of_BoundedLinearOperators(X,Y)
  for c be Complex holds ( ||.x.|| = 0 iff
  x = 0.C_NormSpace_of_BoundedLinearOperators(X,Y) ) &
  ||.c*x.|| = |.c.| * ||.x.|| & ||.x+y.|| <= ||.x.|| + ||.y.|| by Th41;
  hence thesis by CLVECT_1:def 11;
end;

theorem Th43:
  for X,Y be ComplexNormSpace holds
  C_NormSpace_of_BoundedLinearOperators(X,Y) is ComplexNormSpace
proof
  let X,Y be ComplexNormSpace;
  CLSStruct (# BoundedLinearOperators(X,Y), Zero_(BoundedLinearOperators(X,Y),
    C_VectorSpace_of_LinearOperators(X,Y)), Add_(BoundedLinearOperators(X,Y),
    C_VectorSpace_of_LinearOperators(X,Y)), Mult_(BoundedLinearOperators(X,Y),
    C_VectorSpace_of_LinearOperators(X,Y)) #) is ComplexLinearSpace;
  hence thesis by Th42,CSSPACE3:4;
end;

registration
  let X,Y be ComplexNormSpace;
  cluster C_NormSpace_of_BoundedLinearOperators(X,Y) ->
    ComplexNormSpace-like ComplexLinearSpace-like
    Abelian add-associative right_zeroed right_complementable;
  coherence by Th43;
end;

theorem Th44:
  for X,Y be ComplexNormSpace,
  f,g,h be Point of C_NormSpace_of_BoundedLinearOperators(X,Y) holds
  h = f-g iff for x be VECTOR of X holds h.x = f.x - g.x
proof
  let X,Y be ComplexNormSpace;
  let f,g,h be Point of C_NormSpace_of_BoundedLinearOperators(X,Y);
  reconsider f'=f,g'=g,h'=h as bounded LinearOperator of X,Y by Def8;
  hereby
    assume h=f-g;
    then h+g=f-(g-g) by RLVECT_1:43;
    then h+g=f-0.C_NormSpace_of_BoundedLinearOperators(X,Y) by RLVECT_1:28;
    then
A1: h+g=f by RLVECT_1:26;
    now
      let x be VECTOR of X;
      f'.x=h'.x + g'.x by A1,Th39;
      then f'.x-g'.x=h'.x + (g'.x-g'.x) by RLVECT_1:def 6;
      then f'.x-g'.x=h'.x + 0.Y by RLVECT_1:28;
      hence f'.x-g'.x=h'.x by RLVECT_1:10;
    end;
    hence for x be VECTOR of X holds h.x = f.x - g.x;
  end;
  assume
A2: for x be VECTOR of X holds h.x = f.x - g.x;
  now
    let x be VECTOR of X;
    h'.x = f'.x - g'.x by A2;
    then h'.x + g'.x= f'.x - (g'.x- g'.x) by RLVECT_1:43;
    then h'.x + g'.x= f'.x - 0.Y by RLVECT_1:28;
    hence h'.x + g'.x= f'.x by RLVECT_1:26;
  end;
  then f=h+g by Th39;
  then f-g=h+(g-g) by RLVECT_1:def 6;
  then f-g=h+0.C_NormSpace_of_BoundedLinearOperators(X,Y) by RLVECT_1:28;
  hence f-g=h by RLVECT_1:10;
end;

begin :: Complex Banach Space of Bounded Linear Operators

definition
  let X be ComplexNormSpace;
  attr X is complete means
  :Def14:
  for seq be sequence of X holds
  seq is Cauchy_sequence_by_Norm implies seq is convergent;
end;

registration
  cluster complete ComplexNormSpace;
  existence
  proof
    take Complex_l1_Space;
    thus thesis by Def14,CSSPACE3:11;
  end;
end;

definition
  mode ComplexBanachSpace is complete ComplexNormSpace;
end;

Lm2: for e be Real, seq be Real_Sequence st ( seq is convergent &
ex k be Element of NAT
st (for i be Element of NAT st k <= i holds seq.i <=e ) ) holds lim seq <=e
proof
  let e be Real;
  let seq be Real_Sequence such that
A1: seq is convergent and
A2: ex k be Element of NAT
  st (for i be Element of NAT st k <= i holds seq.i <=e );
  reconsider cseq = NAT --> e as Real_Sequence;
A3: cseq is convergent by SEQ_4:39;
  consider k be Element of NAT such that
A4: for i be Element of NAT st k <= i holds seq.i <=e by A2;
A5: (seq ^\k) is convergent by A1,SEQ_4:33;
A6: lim (seq ^\k)=lim seq by A1,SEQ_4:33;
A7: now
    let i be Element of NAT;
A8: (seq ^\k).i = seq.(k+i) by NAT_1:def 3;
    seq.(k+i) <=e by A4,NAT_1:11;
    hence (seq ^\k) .i <= cseq.i by A8,FUNCOP_1:13;
  end;
  lim cseq = cseq.0 by SEQ_4:41
    .= e by FUNCOP_1:13;
  hence thesis by A3,A5,A6,A7,SEQ_2:32;
end;

theorem Th45:
  for X be ComplexNormSpace, seq be sequence of X st seq is convergent holds
  ||.seq.|| is convergent & lim ||.seq.|| = ||.lim seq.||
proof
  let X be ComplexNormSpace;
  let seq be sequence of X such that
A1: seq is convergent;
A2: now
    let e1 be real number such that
A3: e1 >0;
    reconsider e =e1 as Real by XREAL_0:def 1;
    consider k be Element of NAT such that
A4: for n be Element of NAT st n >= k holds ||.seq.n - lim seq.|| < e
    by A1,A3,CLVECT_1:def 18;
A5: now
      let m be Element of NAT such that
A6:   m >= k;
      ||.seq.m.||= ||.seq.||.m by CLVECT_1:def 17;
      then
A7:   abs( ||.seq.||.m - ||.lim seq.|| ) <= ||.seq.m - lim seq.||
      by CLVECT_1:111;
      ||.seq.m - lim seq.|| <e by A4,A6;
      hence abs( ||.seq.||.m - ||.lim seq.|| ) <e1 by A7,XXREAL_0:2;
    end;
    take k;
    thus for m be Element of NAT st m >= k holds
    abs(||.seq.||.m - ||.lim seq.|| ) < e1 by A5;
  end;
  then ||.seq.|| is convergent by SEQ_2:def 6;
  hence thesis by A2,SEQ_2:def 7;
end;

theorem Th46:
  for X,Y be ComplexNormSpace st Y is complete
  for seq be sequence of C_NormSpace_of_BoundedLinearOperators(X,Y)
  st seq is Cauchy_sequence_by_Norm holds seq is convergent
proof
  let X,Y be ComplexNormSpace such that
A1: Y is complete;
  let vseq be sequence of C_NormSpace_of_BoundedLinearOperators(X,Y) such that
A2: vseq is Cauchy_sequence_by_Norm;
A3: ||.vseq.|| is convergent
  proof
    now
      let e1 be real number such that
A4:   e1 >0;
      reconsider e =e1 as Real by XREAL_0:def 1;
      consider k be Element of NAT such that
A5:   for n, m be Element of NAT st ( n >= k & m >= k ) holds
      ||.(vseq.n) - (vseq.m).|| < e by A2,A4,CSSPACE3:10;
A6:   now
        let m be Element of NAT such that
A7:     m >= k;
A8:     abs( ||.vseq.m.||- ||.vseq.k.|| )
        <= ||.(vseq.m) - (vseq.k).|| by CLVECT_1:111;
A9:     ||.vseq.k.||= ||.vseq.||.k by CLVECT_1:def 17;
A10:    ||.vseq.m.||= ||.vseq.||.m by CLVECT_1:def 17;
        ||.(vseq.m) - (vseq.k).|| <e by A5,A7;
        hence abs( ||.vseq.||.m - ||.vseq.||.k ) <e1 by A8,A9,A10,XXREAL_0:2;
      end;
      take k;
      thus for m be Element of NAT st m >= k holds
      abs(||.vseq.||.m - ||.vseq.||.k ) < e1 by A6;
    end;
    hence ||.vseq.|| is convergent by SEQ_4:58;
  end;
  defpred P[set, set] means ex xseq be sequence of Y st
  (for n be Element of NAT holds xseq.n=modetrans((vseq.n),X,Y).$1)
  & xseq is convergent & $2= lim xseq;
A11: for x be Element of X ex y be Element of Y st P[x,y]
  proof
    let x be Element of X;
    deffunc F(Element of NAT) = modetrans((vseq.$1),X,Y).x;
    consider xseq be sequence of Y such that
A12: for n be Element of NAT holds xseq.n = F(n) from FUNCT_2:sch 4;
A13: for m,k be Element of NAT holds
    ||.xseq.m-xseq.k.|| <= ||.vseq.m - vseq.k.|| * ||.x.||
    proof
      let m,k be Element of NAT;
      vseq.m is bounded LinearOperator of X,Y by Def8;
      then
A14:  modetrans((vseq.m),X,Y)=vseq.m by Th33;
      vseq.k is bounded LinearOperator of X,Y by Def8;
      then
A15:  modetrans((vseq.k),X,Y)=vseq.k by Th33;
      reconsider h1=vseq.m-vseq.k as bounded LinearOperator of X,Y by Def8;
A16:  xseq.m =modetrans((vseq.m),X,Y).x by A12;
      xseq.k =modetrans((vseq.k),X,Y).x by A12;
      then xseq.m - xseq.k = h1.x by A14,A15,A16,Th44;
      hence thesis by Th36;
    end;
A17: xseq is convergent
    proof
      now
        let e be Real such that
A18:    e > 0;
        thus ex k be Element of NAT st
        for n, m be Element of NAT st ( n >= k & m >= k )
        holds ||.xseq.n -xseq.m.|| < e
        proof
          now per cases;
            case
A19:          x=0.X;
              take k=0;
              thus for n, m be Element of NAT st ( n >= k & m >= k ) holds
              ||.xseq.n -xseq.m.|| < e
              proof
                let n, m be Element of NAT such that n >= k & m >= k;
A20:            xseq.n=modetrans((vseq.n),X,Y).x by A12
                  .=modetrans((vseq.n),X,Y).(0c * x) by A19,CLVECT_1:2
                  .=0c * modetrans((vseq.n),X,Y).x by Def4
                  .=0.Y by CLVECT_1:2;
                xseq.m=modetrans((vseq.m),X,Y).x by A12
                  .=modetrans((vseq.m),X,Y).(0c*x) by A19,CLVECT_1:2
                  .=0c * modetrans((vseq.m),X,Y).x by Def4
                  .=0.Y by CLVECT_1:2;
                then ||.xseq.n -xseq.m.|| = ||.0.Y.|| by A20,RLVECT_1:26
                  .=0 by CLVECT_1:def 11;
                hence ||.xseq.n -xseq.m.|| < e by A18;
              end;
            end;
            case x <>0.X;
              then
A21:          ||.x.|| <> 0 by CLVECT_1:def 11;
              then
A22:          ||.x.|| > 0 by CLVECT_1:106;
              then e/||.x.||>0 by A18;
              then consider k be Element of NAT such that
A23:          for n, m be Element of NAT st n >= k & m >= k holds
              ||.(vseq.n) - (vseq.m).|| < e/||.x.|| by A2,CSSPACE3:10;
              take k;
              thus for n, m be Element of NAT st ( n >= k & m >= k )
              holds ||.xseq.n-xseq.m.|| < e
              proof
                let n,m be Element of NAT such that
A24:            n >=k & m >= k;
A25:            ||.xseq.n-xseq.m.||
                <= ||.(vseq.n) - (vseq.m).|| * ||.x.|| by A13;
                ||.(vseq.n) - (vseq.m).|| < e/||.x.|| by A23,A24;
                then
A26:            ||.(vseq.n) - (vseq.m).|| * ||.x.||
                < e/||.x.|| * ||.x.|| by A22,XREAL_1:70;
                e/||.x.|| * ||.x.|| = e*||.x.||"* ||.x.|| by XCMPLX_0:def 9
                  .= e*(||.x.||"* ||.x.||)
                  .= e*1 by A21,XCMPLX_0:def 7
                  .=e;
                hence ||.xseq.n-xseq.m.|| < e by A25,A26,XXREAL_0:2;
              end;
            end;
          end;
          hence thesis;
        end;
      end;
      then xseq is Cauchy_sequence_by_Norm by CSSPACE3:10;
      hence thesis by A1,Def14;
    end;
    take y = lim xseq;
    thus thesis by A12,A17;
  end;
  consider f be Function of the carrier of X,the carrier of Y such that
A27: for x be Element of X holds P[x,f.x] from FUNCT_2:sch 3(A11);
  reconsider tseq=f as Function of X,Y;
  tseq is LinearOperator of X,Y
  proof
A28: now
      let x,y be VECTOR of X;
      consider xseq be sequence of Y such that
A29:  (for n be Element of NAT holds xseq.n=modetrans((vseq.n),X,Y).x)
      & xseq is convergent & tseq.x = lim xseq by A27;
      consider yseq be sequence of Y such that
A30:  (for n be Element of NAT holds yseq.n=modetrans((vseq.n),X,Y).y)
      & yseq is convergent & tseq.y = lim yseq by A27;
      consider zseq be sequence of Y such that
A31:  (for n be Element of NAT holds zseq.n=modetrans((vseq.n),X,Y).(x+y))
      & zseq is convergent & tseq.(x+y) = lim zseq by A27;
      zseq=xseq+yseq
      proof
        now
          let n be Element of NAT;
          thus zseq.n=modetrans((vseq.n),X,Y).(x+y) by A31
            .= modetrans((vseq.n),X,Y).x+modetrans((vseq.n),X,Y).y by Def3
            .= xseq.n + modetrans((vseq.n),X,Y).y by A29
            .= xseq.n +yseq.n by A30;
        end;
        hence thesis by NORMSP_1:def 5;
      end;
      hence tseq.(x+y)=tseq.x+tseq.y by A29,A30,A31,CLVECT_1:121;
    end;
    now
      let x be VECTOR of X;
      let c be Complex;
      consider xseq be sequence of Y such that
A32:  (for n be Element of NAT holds xseq.n=modetrans((vseq.n),X,Y).x)
      & xseq is convergent & tseq.x = lim xseq by A27;
      consider zseq be sequence of Y such that
A33:  (for n be Element of NAT holds zseq.n=modetrans((vseq.n),X,Y).(c*x))
      & zseq is convergent & tseq.(c*x) = lim zseq by A27;
      zseq=c*xseq
      proof
        now
          let n be Element of NAT;
          thus zseq.n=modetrans((vseq.n),X,Y).(c*x) by A33
            .= c*modetrans((vseq.n),X,Y).x by Def4
            .= c*xseq.n by A32;
        end;
        hence thesis by CLVECT_1:def 15;
      end;
      hence tseq.(c*x)=c*tseq.x by A32,A33,CLVECT_1:124;
    end;
    hence thesis by A28,Def3,Def4;
  end;
  then reconsider tseq as LinearOperator of X,Y;
A34: tseq is bounded
  proof
A35: now
      let x be VECTOR of X;
      consider xseq be sequence of Y such that
A36:  (for n be Element of NAT holds xseq.n=modetrans((vseq.n),X,Y).x)
      & xseq is convergent & tseq.x = lim xseq by A27;
A37:  for m be Element of NAT holds ||.xseq.m.|| <= ||.vseq.m.|| * ||.x.||
      proof
        let m be Element of NAT;
A38:    vseq.m is bounded LinearOperator of X,Y by Def8;
        xseq.m =modetrans((vseq.m),X,Y).x by A36;
        hence thesis by A38,Th33,Th36;
      end;
A39:  ||.xseq.|| is convergent by A36,Th22;
A40:  ||.tseq.x.|| = lim ||.xseq.|| by A36,Th22;
A41:  for n be Element of NAT holds ||.xseq.||.n <=( ||.x.||(#)||.vseq.||).n
      proof
        let n be Element of NAT;
A42:    ||.xseq.||.n = ||.(xseq.n).|| by CLVECT_1:def 17;
A43:    ||.(xseq.n).|| <= ||.vseq.n.|| * ||.x.|| by A37;
        ||.vseq.n.|| = ||.vseq.||.n by CLVECT_1:def 17;
        hence thesis by A42,A43,SEQ_1:13;
      end;
A44:  ||.x.||(#)||.vseq.|| is convergent by A3,SEQ_2:21;
      lim ( ||.x.||(#)||.vseq.|| ) = lim (||.vseq.|| )* ||.x.||
      by A3,SEQ_2:22;
      hence ||.tseq.x.|| <= lim (||.vseq.|| )* ||.x.||
      by A39,A40,A41,A44,SEQ_2:32;
    end;
    take K= lim (||.vseq.|| );
    K >=0
    proof
      now
        let n be Element of NAT;
        ||.vseq.n.|| >=0 by CLVECT_1:106;
        hence ||.vseq.||.n >=0 by CLVECT_1:def 17;
      end;
      hence thesis by A3,SEQ_2:31;
    end;
    hence thesis by A35;
  end;
A45: for e be Real st e > 0 ex k be Element of NAT
  st for n be Element of NAT st n >= k holds for x be VECTOR of X holds
  ||.modetrans((vseq.n),X,Y).x - tseq.x.|| <= e* ||.x.||
  proof
    let e be Real such that
A46: e > 0;
    consider k be Element of NAT such that
A47: for n, m be Element of NAT st ( n >= k & m >= k ) holds
    ||.(vseq.n) - (vseq.m).|| < e by A2,A46,CSSPACE3:10;
A48: now
      let n be Element of NAT such that
A49:  n >= k;
      now
        let x be VECTOR of X;
        consider xseq be sequence of Y such that
A50:    (for n be Element of NAT holds xseq.n=modetrans((vseq.n),X,Y).x)
        & xseq is convergent & tseq.x = lim xseq by A27;
A51:    for m,k be Element of NAT holds
        ||.xseq.m-xseq.k.|| <= ||.vseq.m - vseq.k.|| * ||.x.||
        proof
          let m,k be Element of NAT;
          vseq.m is bounded LinearOperator of X,Y by Def8;
          then
A52:      modetrans((vseq.m),X,Y)=vseq.m by Th33;
          vseq.k is bounded LinearOperator of X,Y by Def8;
          then
A53:      modetrans((vseq.k),X,Y)=vseq.k by Th33;
          reconsider h1=vseq.m-vseq.k as bounded LinearOperator of X,Y
          by Def8;
A54:      xseq.m =modetrans((vseq.m),X,Y).x by A50;
          xseq.k =modetrans((vseq.k),X,Y).x by A50;
          then xseq.m - xseq.k =h1.x by A52,A53,A54,Th44;
          hence thesis by Th36;
        end;
A55:    for m be Element of NAT st m >=k
        holds ||.xseq.n-xseq.m.|| <= e * ||.x.||
        proof
          let m be Element of NAT such that
A56:      m >=k;
A57:      ||.xseq.n-xseq.m.|| <= ||.vseq.n - vseq.m.|| * ||.x.|| by A51;
A58:      ||.vseq.n - vseq.m.|| <e by A47,A49,A56;
          0 <= ||.x.|| by CLVECT_1:106;
          then ||.vseq.n - vseq.m.|| * ||.x.|| <= e* ||.x.|| by A58,XREAL_1:66;
          hence thesis by A57,XXREAL_0:2;
        end;
        ||.xseq.n-tseq.x.|| <= e * ||.x.||
        proof
          deffunc F(Element of NAT) = ||.xseq.$1 - xseq.n.||;
          consider rseq be Real_Sequence such that
A59:      for m be Element of NAT holds rseq.m = F(m) from SEQ_1:sch 1;
A60:      rseq is convergent & lim rseq = ||.tseq.x-xseq.n.||
          proof
A61:        xseq - xseq.n is convergent by A50,CLVECT_1:117;
A62:        lim (xseq-xseq.n)= tseq.x - xseq.n by A50,CLVECT_1:123;
            rseq = ||.xseq - xseq.n.||
            proof
              now
                let x be set such that
A63:            x in NAT;
                reconsider k=x as Element of NAT by A63;
                thus rseq.x = ||.xseq.k - xseq.n.|| by A59
                  .= ||.(xseq - xseq.n).k.|| by NORMSP_1:def 7
                  .= ||.(xseq - xseq.n).||.x by CLVECT_1:def 17;
              end;
              hence thesis by SEQ_1:8;
            end;
            hence thesis by A61,A62,Th45;
          end;
          for m be Element of NAT st m >= k holds rseq.m <= e * ||.x.||
          proof
            let m be Element of NAT such that
A64:        m >=k;
            rseq.m = ||.xseq.m-xseq.n.|| by A59
              .= ||.xseq.n-xseq.m.|| by CLVECT_1:109;
            hence thesis by A55,A64;
          end;
          then lim rseq <= e * ||.x.|| by A60,Lm2;
          hence thesis by A60,CLVECT_1:109;
        end;
        hence ||.modetrans((vseq.n),X,Y).x - tseq.x.|| <= e* ||.x.|| by A50;
      end;
      hence for x be VECTOR of X holds
      ||.modetrans((vseq.n),X,Y).x - tseq.x.|| <= e* ||.x.||;
    end;
    take k;
    thus thesis by A48;
  end;
  reconsider tseq as bounded LinearOperator of X,Y by A34;
  reconsider tv=tseq as Point of
  C_NormSpace_of_BoundedLinearOperators(X,Y) by Def8;
A65: for e be Real st e > 0
  ex k be Element of NAT st for n be Element of NAT st
  n >= k holds ||.vseq.n - tv.|| <= e
  proof
    let e be Real such that
A66: e > 0;
    consider k be Element of NAT such that
A67: for n be Element of NAT st n >= k holds for x be VECTOR of X holds
    ||.modetrans((vseq.n),X,Y).x - tseq.x.|| <= e* ||.x.|| by A45,A66;
    now
      let n be Element of NAT such that
A68:  n >= k;
      set f1=modetrans((vseq.n),X,Y);
      set g1=tseq;
      reconsider h1=vseq.n-tv as bounded LinearOperator of X,Y by Def8;
A69:  now
        let t be VECTOR of X such that
A70:    ||.t.|| <= 1;
        vseq.n is bounded LinearOperator of X,Y by Def8;
        then modetrans((vseq.n),X,Y)=vseq.n by Th33;
        then
A71:    ||.h1.t.||= ||.f1.t-g1.t.|| by Th44;
A72:    ||.f1.t-g1.t.|| <=e* ||.t.|| by A67,A68;
        e*||.t.|| <= e*1 by A66,A70,XREAL_1:66;
        hence ||.h1.t.|| <=e by A71,A72,XXREAL_0:2;
      end;
A73:  now
        let r be Real such that
A74:    r in PreNorms(h1);
        consider t be VECTOR of X such that
A75:    r=||.h1.t.|| & ||.t.|| <= 1 by A74;
        thus r <=e by A69,A75;
      end;
A76:  (for s be real number st s in PreNorms(h1) holds s <= e)
      implies sup PreNorms(h1) <=e by SEQ_4:62;
      BoundedLinearOperatorsNorm(X,Y).(vseq.n-tv) = sup PreNorms(h1) by Th34;
      hence ||.vseq.n-tv.|| <=e by A73,A76,CLVECT_1:def 10;
    end;
    hence thesis;
  end;
  for e be Real st e > 0 ex m be Element of NAT st for n be Element of NAT st
  n >= m holds ||.(vseq.n) - tv.|| < e
  proof
    let e be Real such that
A77: e > 0;
A78: e/2 > 0 by A77;
A79: e/2<e by A77,XREAL_1:218;
    consider m be Element of NAT such that
A80: for n be Element of NAT st
    n >= m holds ||.(vseq.n) - tv.|| <= e/2 by A65,A78;
    now
      let n be Element of NAT such that
A81:  n >= m;
      ||.(vseq.n) - tv.|| <= e/2 by A80,A81;
      hence ||.(vseq.n) - tv.|| < e by A79,XXREAL_0:2;
    end;
    hence thesis;
  end;
  hence thesis by CLVECT_1:def 16;
end;

theorem Th47:
  for X be ComplexNormSpace, Y be ComplexBanachSpace holds
  C_NormSpace_of_BoundedLinearOperators(X,Y) is ComplexBanachSpace
proof
  let X be ComplexNormSpace;
  let Y be ComplexBanachSpace;
  for seq be sequence of C_NormSpace_of_BoundedLinearOperators(X,Y)
  st seq is Cauchy_sequence_by_Norm holds seq is convergent by Th46;
  hence thesis by Def14;
end;

registration
  let X be ComplexNormSpace;
  let Y be ComplexBanachSpace;
  cluster C_NormSpace_of_BoundedLinearOperators (X,Y) -> complete;
  coherence by Th47;
end;

