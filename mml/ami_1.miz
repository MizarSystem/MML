:: A Mathematical Model of CPU
::  by Yatsuka Nakamura and Andrzej Trybulec
::
:: Received October 14, 1992
:: Copyright (c) 1992 Association of Mizar Users

environ

 vocabularies STRUCT_0, SUBSET_1, XBOOLE_0, FUNCT_1, NUMBERS, FUNCT_2, CARD_3,
      ORDINAL1, CARD_1, FUNCOP_1, FUNCT_4, RELAT_1, TARSKI, CAT_1, FSM_1,
      SETFAM_1, GLIB_000, FINSET_1, CIRCUIT2, NAT_1, ARYTM_3, XXREAL_0,
      MSUALG_1, TURING_1, PARTFUN1, MCART_1, ZFMISC_1, GRAPHSP, ARYTM_1,
      FUNCT_7, AMI_1, PBOOLE, SCMNORM;
 notations TARSKI, XBOOLE_0, ZFMISC_1, MCART_1, SUBSET_1, SETFAM_1, ORDINAL1,
      PBOOLE, NUMBERS, FUNCT_7, CARD_3, XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1,
      FINSET_1, NAT_1, FUNCOP_1, FUNCT_4, FINSEQ_1, FUNCT_2, GRAPH_2,
      DOMAIN_1, TREES_2, PRE_POLY, STRUCT_0, XXREAL_0;
 constructors SETFAM_1, PARTFUN1, DOMAIN_1, FUNCT_4, XXREAL_0, NAT_1, FUNCT_7,
      SEQ_1, INT_1, CARD_3, STRUCT_0, FINSEQ_4, GRAPH_2, TREES_2, RELSET_1,
      PRE_POLY, PBOOLE;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCT_2,
      FUNCOP_1, FUNCT_4, FINSET_1, XREAL_0, FINSEQ_1, CARD_3, STRUCT_0, INT_1,
      RELSET_1, GRFUNC_1, PRE_POLY, PBOOLE;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, STRUCT_0, XBOOLE_0, FUNCOP_1, ORDINAL1, RELAT_1, PBOOLE,
      FUNCT_1;
 theorems ZFMISC_1, FUNCT_2, TARSKI, NAT_1, CQC_LANG, CARD_3, FINSEQ_1,
      FUNCT_4, FUNCOP_1, FINSET_1, FUNCT_1, GRFUNC_1, RELAT_1, RELSET_1,
      XBOOLE_0, XBOOLE_1, ORDINAL1, MCART_1, ENUMSET1, SUBSET_1, XXREAL_0,
      FUNCT_7, INT_1, PARTFUN1, PBOOLE;
 schemes NAT_1, FRAENKEL;

begin :: General concepts

definition
  let N be set;
  struct (1-sorted) AMI-Struct over N (# carrier -> set,
Instruction-Counter -> Element of the carrier, Instructions -> non empty set,
    Object-Kind -> Function of the carrier, N \/ { the Instructions, NAT },
    Execution -> Function of the Instructions, Funcs(product the Object-Kind,
    product the Object-Kind) #);
end;

definition
  let N be set;
  canceled;
  func Trivial-AMI N -> strict AMI-Struct over N means
:Def2:
  the carrier of it = succ NAT & the Instruction-Counter of it = NAT &
  the Instructions of it = {[0,{}]} &
  the Object-Kind of it = (NAT --> {[0,{}]}) +* (NAT .--> NAT) &
  the Execution of it
    = [0,{}] .--> id product((NAT --> {[0,{}]}) +* (NAT .--> NAT));
  existence
  proof
    reconsider I = {[0,{}]} as non empty set;
    set f = (NAT --> I) +* (NAT .--> NAT);
A1: dom f = dom(NAT --> I) \/ dom(NAT .--> NAT) by FUNCT_4:def 1
      .= NAT \/ dom(NAT .--> NAT) by FUNCOP_1:19
      .= succ NAT by FUNCOP_1:19;
    rng(NAT --> I) c= {I} & rng(NAT .--> NAT) c= {NAT} by FUNCOP_1:19;
    then rng(NAT --> I) \/ rng(NAT .--> NAT) c= {I} \/ {NAT} by XBOOLE_1:13;
    then rng f c= rng(NAT --> I) \/ rng(NAT .--> NAT) &
     rng(NAT --> I) \/ rng(NAT .--> NAT) c= { I,NAT} by ENUMSET1:41,FUNCT_4:18;
    then
A2: rng f c= { I,NAT} by XBOOLE_1:1;
    { I,NAT } c= N \/ {I, NAT} by XBOOLE_1:7;
    then rng f c= N \/ {I, NAT} by A2,XBOOLE_1:1;
    then reconsider f as Function of succ NAT, N \/ {I, NAT} by A1,
FUNCT_2:def 1,RELSET_1:11;
    reconsider y = NAT as Element of succ NAT by ORDINAL1:10;
    reconsider E = I --> id product f as Function of I,Funcs(product f,
    product f) by FUNCOP_1:57,FUNCT_2:12;
    take S=AMI-Struct(#succ NAT,y,I,f,E #);
    thus thesis;
  end;
  uniqueness;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  attr S is stored-program means
:Def3: NAT c= the carrier of S;
end;

registration
  let N be set;
  cluster Trivial-AMI N-> non empty stored-program;
  coherence
  proof
    set S = Trivial-AMI N;
A1: the carrier of S = succ NAT by Def2;
    thus the carrier of S is non empty by Def2;
    thus NAT c= the carrier of S by A1,XBOOLE_1:7;
  end;
end;

registration
  let N be set;
  cluster non empty stored-program AMI-Struct over N;
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

definition
  let N be set;
  let S be non empty AMI-Struct over N;
  mode Object of S is Element of S;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  mode Instruction of S is Element of the Instructions of S;
end;

definition
 canceled;
  let N be set;
  let S be non empty AMI-Struct over N;
  func IC S -> Object of S equals
  the Instruction-Counter of S;
  correctness;
end;

definition
  let N be set;
  let S be non empty AMI-Struct over N;
  let o be Object of S;
  func ObjectKind o -> Element of N \/ { the Instructions of S, NAT } equals
  (the Object-Kind of S).o;
  correctness;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  mode PartState of S is (the carrier of S)-defined
           (the Object-Kind of S)-compatible Function;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  mode FinPartState of S is finite PartState of S;
end;

definition
  let N be with_non-empty_elements set;
  let S be AMI-Struct over N;
  mode State of S is total PartState of S;
end;

definition
  let N be with_non-empty_elements set;
  let S be AMI-Struct over N;
  let I be Instruction of S, s be State of S;
  func Exec(I,s) -> State of S equals
  ((the Execution of S).I).s;
  coherence
  proof
    consider f being Function such that
A1: (the Execution of S).I = f & dom f = product the Object-Kind of S and
A2: rng f c= product the Object-Kind of S by FUNCT_2:def 2;
   reconsider s as Element of product the Object-Kind of S by PBOOLE:155;
    (the Execution of S).I.s in rng f by A1,FUNCT_1:def 5;
    hence thesis by A2;
  end;
end;

reserve N for with_non-empty_elements set;

definition
  let N;
  let S be AMI-Struct over N;
  let I be Instruction of S;
  attr I is halting means
:Def8:
  for s being State of S holds Exec(I,s) = s;
end;

definition
  let N;
  let S be AMI-Struct over N;
  attr S is halting means
  :Def9:
  ex I being Instruction of S st I is halting;
end;

reserve E for set;

registration
  let N;
  cluster Trivial-AMI N -> halting;
  coherence
proof
  set T = Trivial-AMI N;
  set f = (NAT --> {[0,{}]}) +* (NAT .--> NAT);
A1: product the Object-Kind of T = product f by Def2;
  {[0,{}]} = the Instructions of T by Def2;
  then reconsider I = [0,{}] as Instruction of T by TARSKI:def 1;
  take I;
  let s be State of T;
   reconsider ss=s as Element of product the Object-Kind of T by PBOOLE:155;
  (I .--> id product f).I = id product f by FUNCOP_1:87;
  hence Exec(I,s) = (id product f).ss by Def2
    .= s by A1,FUNCT_1:35;
end;
end;

registration
  let N;
  cluster halting AMI-Struct over N;
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration
  let N;
  let S be halting (AMI-Struct over N);
  cluster halting Instruction of S;
  existence by Def9;
end;

definition
  let N be with_non-empty_elements set;
  let S be halting (AMI-Struct over N);
  func halt S -> Instruction of S equals
   the halting Instruction of S;
  coherence;
end;

registration
  let N;
  let S be halting (AMI-Struct over N);
  cluster halt S -> halting;
  coherence;
end;

definition
  let N be set;
  let IT be non empty AMI-Struct over N;
  attr IT is IC-Ins-separated means
  :Def11:
  ObjectKind IC IT = NAT;
end;

definition
  let N be with_non-empty_elements set;
  let S be halting (AMI-Struct over N);
  let I be FinPartState of S;
  attr I is halt-free means
  not halt S in rng I;
end;

definition
  let N be with_non-empty_elements set;
  let IT be non empty AMI-Struct over N;
  attr IT is steady-programmed means
  :Def13:
  for s being State of IT, i being Instruction of IT,
      l being Element of NAT
   holds Exec(i,s).l = s.l;
end;

definition
  let N be set;
  let IT be non empty stored-program AMI-Struct over N;
  attr IT is definite means
  :Def14:
  for l being Element of NAT
  holds (the Object-Kind of IT).l = the Instructions of IT;
end;

canceled 8;

theorem Th9:
  for s being State of Trivial-AMI N, i being Instruction of
  Trivial-AMI N holds Exec(i,s) = s
proof
  set T = Trivial-AMI N;
  let s be State of Trivial-AMI N, i be Instruction of Trivial-AMI N;
  set f = (NAT --> {[0,{}]}) +* (NAT .--> NAT);
A1: product the Object-Kind of T = product f by Def2;
   reconsider ss=s as Element of product the Object-Kind of T by PBOOLE:155;
  the Instructions of T = {[0,{}]} by Def2;
  then (i .--> id product f).i = id product f & i = [0,{}] by FUNCOP_1:87
,TARSKI:def 1;
  hence Exec(i,s) = (id product f).ss by Def2
    .= s by A1,FUNCT_1:35;
end;

registration
  let E be set;
  cluster Trivial-AMI E -> IC-Ins-separated definite;
  coherence
   proof
  thus Trivial-AMI E is IC-Ins-separated
proof
  dom(NAT .--> NAT) = {NAT} by FUNCOP_1:19;
  then
A1: NAT in dom(NAT .--> NAT) by TARSKI:def 1;
  IC Trivial-AMI E = NAT by Def2;
  hence ObjectKind IC Trivial-AMI E = ((NAT --> {[0,{}]}) +* (NAT .--> NAT)).
  NAT by Def2
    .= (NAT .--> NAT).NAT by A1,FUNCT_4:14
    .= NAT by FUNCOP_1:87;
end;
  let l be Element of NAT;
A1: l in NAT;
  now
    assume
    l in {NAT};
    then l = NAT by TARSKI:def 1;
    hence contradiction by A1;
  end;
  then
A2: not l in dom(NAT .--> NAT) by FUNCOP_1:19;
  thus (the Object-Kind of Trivial-AMI E).l
     = ((NAT --> {[0,{}]}) +* (NAT .--> NAT)).l by Def2
    .= (NAT --> {[0,{}]}).l by A2,FUNCT_4:12
    .= {[0,{}]} by FUNCOP_1:13
    .= the Instructions of Trivial-AMI E by Def2;
   end;
end;

registration

  let N be with_non-empty_elements set;
  cluster Trivial-AMI N -> steady-programmed;
  coherence
proof
  let s be State of Trivial-AMI N, i be Instruction of Trivial-AMI N,
  l be Element of NAT;
  thus thesis by Th9;
end;
end;

registration
  let E be set;
  cluster strict AMI-Struct over E;
  existence
  proof
    take Trivial-AMI E;
    thus thesis;
  end;
end;

registration
  let M be set;
  cluster IC-Ins-separated definite strict (non empty stored-program
    AMI-Struct over M);
  existence
  proof
    take Trivial-AMI M;
    thus thesis;
  end;
end;

registration
  let N;
  cluster IC-Ins-separated halting steady-programmed definite strict (non
    empty stored-program AMI-Struct over N);
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

definition
  let N be with_non-empty_elements set;
  let S be IC-Ins-separated (non empty AMI-Struct over N);
  let p be PartState of S;
  func IC p -> Element of NAT equals
  p.IC S;
  coherence
  proof
   per cases;
   suppose
A1: IC S in dom p;
    consider s being State of S such that
A2: p c= s by PBOOLE:156;
   reconsider ss=s as Element of product the Object-Kind of S by PBOOLE:155;
    dom the Object-Kind of S = the carrier of S by FUNCT_2:def 1;
    then pi(product the Object-Kind of S,IC S) = ObjectKind IC S by CARD_3:22
      .= NAT by Def11;
    then ss.IC S in NAT by CARD_3:def 6;
    hence thesis by A1,A2,GRFUNC_1:8;
   end;
   suppose not IC S in dom p;
   hence thesis by FUNCT_1:def 4;
   end;
  end;
end;

canceled 2;

theorem
  for s1, s2 being State of Trivial-AMI N st IC s1 = IC s2 holds s1=
  s2
proof
  set T = Trivial-AMI N;
  let s1,s2 be State of Trivial-AMI N such that
A1: IC s1 = IC s2;
A2: dom s1 = the carrier of T by PARTFUN1:def 4;
A3: now
    let x be set;
    assume
A4: x in dom s1;
    dom s1 = the carrier of T by PARTFUN1:def 4
      .= succ NAT by Def2;
    then
A5: x in NAT or x in {NAT} by A4,XBOOLE_0:def 3;
    per cases by A5,TARSKI:def 1;
    suppose
A6:   x in NAT;
      then x <> NAT;
      then not x in {NAT} by TARSKI:def 1;
      then
A7:   not x in dom(NAT .--> NAT) by FUNCOP_1:19;
A8:   (the Object-Kind of T).x = ((NAT --> {[0,{}]}) +* (NAT .--> NAT)).x by
Def2
        .= (NAT --> {[0,{}]}).x by A7,FUNCT_4:12
        .= {[0,{}]} by A6,FUNCOP_1:13;
      x in dom s2 by A2,A4,PARTFUN1:def 4;
      then
A9:   s2.x in {[0,{}]} by FUNCT_1:def 20,A8;
      s1.x in {[0,{}]} by A4,A8,FUNCT_1:def 20;
      hence s1.x = [0,{}] by TARSKI:def 1
        .= s2.x by A9,TARSKI:def 1;
    end;
    suppose
A10:  x = NAT;
      hence s1.x = IC s1 by Def2
        .= s2.x by A1,A10,Def2;
    end;
  end;
  dom s1 =dom s2 by A2,PARTFUN1:def 4;
  hence thesis by A3,FUNCT_1:9;
end;

begin :: General theory

reserve x,y,z,A,B for set,
  f,g,h for Function,
  i,j,k for Element of NAT;

definition
  let N;
  let S be IC-Ins-separated (non empty AMI-Struct over N);
  let p be (the Instructions of S)-valued Function;
  let s be State of S;
  func CurInstr(p,s) -> Instruction of S equals
  p/.IC s;
  coherence;
end;

definition
  let N be with_non-empty_elements set;
  let S be AMI-Struct over N;
  let s be PartState of S;
  func ProgramPart s -> PartState of S equals
  s | NAT;
  coherence;
end;

registration
  let N be with_non-empty_elements set;
  let S be AMI-Struct over N;
  let s be PartState of S;
  cluster ProgramPart s -> NAT-defined;
  coherence;
end;

reserve S for IC-Ins-separated definite (non empty stored-program AMI-Struct
  over N),
  s for State of S;

BWL:
 for i being natural number holds
 (ProgramPart s).i = s.i
 proof
  let i being natural number;
X:   i in NAT by ORDINAL1:def 13;
Y: dom s = the carrier of S by PARTFUN1:def 4;
   NAT c= the carrier of S by Def3;
   then i in the carrier of S by X;
   then i in dom s by Y;
   then i in dom ProgramPart s by X,RELAT_1:86;
  hence (ProgramPart s).i = s.i by FUNCT_1:70;
 end;

BWL2:
 for s being PartState of S
 for i being natural number st i in dom s
  holds (ProgramPart s).i = s.i
 proof let s be PartState of S;
  let i being natural number such that
Z: i in dom s;
X:   i in NAT by ORDINAL1:def 13;
   i in dom ProgramPart s by X,RELAT_1:86,Z;
  hence (ProgramPart s).i = s.i by FUNCT_1:70;
 end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N);
  let s be PartState of S;
  cluster ProgramPart s -> (the Instructions of S)-valued;
  coherence
   proof let e be set;
    assume e in rng ProgramPart s;
     then consider u being set such that
W1:   u in dom ProgramPart s and
W2:   e = (ProgramPart s).u by FUNCT_1:def 5;
B:   dom ProgramPart s = NAT /\ dom s by RELAT_1:90;
     then
D:    u in NAT by W1,XBOOLE_0:def 4;
     then
A:    (the Object-Kind of S).u = the Instructions of S by Def14;
     reconsider u as Nat by D;
E:   u in dom s by B,W1,XBOOLE_0:def 4;
     then
C:   (ProgramPart s).u = s.u by BWL2;
     s.u in (the Object-Kind of S).u by FUNCT_1:def 20,E;
    hence e in the Instructions of S by W2,C,A;
   end;
end;

LmU: for N being with_non-empty_elements set for S being
  steady-programmed (non empty stored-program AMI-Struct over N)
   for s being State of S
   holds dom ProgramPart s = NAT
proof
  let N be with_non-empty_elements set;
  let S be steady-programmed (non empty stored-program AMI-Struct over N);
  let s be State of S;
A1:   NAT c= the carrier of S by Def3;
   dom s = the carrier of S by PARTFUN1:def 4;
  hence thesis by A1,RELAT_1:91;
end;

BWL1:
 for N being with_non-empty_elements non empty set
 for S being
  IC-Ins-separated definite
  steady-programmed (non empty stored-program AMI-Struct over N)
   for s being State of S
 for i being natural number holds
 (ProgramPart s)/.i = s.i
 proof
 let N being with_non-empty_elements non empty set;
 let S being IC-Ins-separated definite
  steady-programmed (non empty stored-program AMI-Struct over N);
   let s being State of S;
  let i be natural number;
   dom ProgramPart s = NAT by LmU;
   then i in dom ProgramPart s by ORDINAL1:def 13;
  hence (ProgramPart s)/.i = (ProgramPart s).i by PARTFUN1:def 8
        .= s.i by BWL;
 end;

definition
  let N;
  let S be IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N);
  let s be State of S;
  let p be (the Instructions of S)-valued Function;
  func Following(p,s) -> State of S equals
  Exec(CurInstr(p,s),s);
  correctness;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  deffunc F(set,State of S) = down Following(p,$2);
  let s be State of S, k be Nat;
  func Comput(p,s,k) -> State of S means
:Def19:
  ex f being Function of NAT, product the Object-Kind of S st
  it = f.k & f.0 = s & for i being Nat holds f.(i+1) = Following(p,f.i);
  existence
  proof
    reconsider ss=s as Element of product the Object-Kind of S by PBOOLE:155;
    consider f being Function of NAT, product the Object-Kind of S such that
A1: f.0 = ss and
A2: for n being Nat holds f.(n+1) = F(n,f.n) from NAT_1:sch 12;
    take f.k, f;
    thus f.k = f.k;
    thus f.0 = s by A1;
    let i be Nat;
    thus f.(i+1) = F(i,f.i) by A2
       .= Following(p,f.i);
  end;
  uniqueness
  proof
    let s1,s2 be State of S;
    given f1 being Function of NAT, product the Object-Kind of S such that
A3: s1 = f1.k and
B4: f1.0 = s and
B5: for i being Nat holds f1.(i+1) = Following(p,f1.i);
    given f2 being Function of NAT, product the Object-Kind of S such that
A6: s2 = f2.k and
B7: f2.0 = s and
B8: for i being Nat holds f2.(i+1) = Following(p,f2.i);
    reconsider s as Element of product the Object-Kind of S by PBOOLE:155;
A4: f1.0 = s by B4;
A5: for i being Nat holds f1.(i+1) = F(i,f1.i) by B5;
A7: f2.0 = s by B7;
A8: for i being Nat holds f2.(i+1) = F(i,f2.i) by B8;
    f1 = f2 from NAT_1:sch 16(A4,A5,A7,A8);
    hence thesis by A3,A6;
  end;
end;

definition
  let N;
  let S be AMI-Struct over N;
  let f be Function of NAT, product the Object-Kind of S;
  let k;
  redefine func f.k -> Element of product the Object-Kind of S;
  coherence by FUNCT_2:7;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be halting IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let s be State of S;
  pred p halts_on s means
:Def20:
  ex k being Nat
   st IC Comput(p,s,k) in dom p & CurInstr(p,Comput(p,s,k)) = halt S;
end;

definition
  let N be set;
  let IT be AMI-Struct over N;
  attr IT is realistic means
  :Def21:
  not the Instruction-Counter of IT in NAT;
end;

theorem Th13:
  for N being non empty with_non-empty_elements set
  for S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  p be NAT-defined (the Instructions of S)-valued Function,
  s be State of S holds Comput(p,s,0) = s
proof let N be non empty with_non-empty_elements set;
  let S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  p be NAT-defined (the Instructions of S)-valued Function,
  s be State of S;
  ex f being Function of NAT, product the Object-Kind of S st
  Comput(p,s,0) = f.0 & f.0 = s & for i being Nat holds
  f.(i+1) = Following(p,f.i) by Def19;
  hence thesis;
end;

theorem Th14:
  for N being non empty with_non-empty_elements set
  for S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  p be NAT-defined (the Instructions of S)-valued Function,
  s be State of S, k be Nat holds
  Comput(p,s,k+1) = Following(p,Comput(p,s,k))
proof let N be non empty with_non-empty_elements set;
  let S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  p be NAT-defined (the Instructions of S)-valued Function,
  s be State of S, k be Nat;
  deffunc F(set,State of S) = down Following(p,$2);
  reconsider s as Element of product the Object-Kind of S by PBOOLE:155;
  consider f being Function of NAT, product the Object-Kind of S such that
A1: Comput(p,s,k+1) = f.(k+1) and
A2: f.0 = s and
B3: for i being Nat holds f.(i+1) = Following(p,f.i) by Def19;
  consider g being Function of NAT, product the Object-Kind of S such that
A4: Comput(p,s,k) = g.k and
A5: g.0 = s and
B6: for i being Nat holds g.(i+1) = Following(p,g.i) by Def19;
A3: for i being Nat holds f.(i+1) = F(i,f.i) by B3;
A6: for i being Nat holds g.(i+1) = F(i,g.i) by B6;
  f = g from NAT_1:sch 16(A2,A3,A5,A6);
  hence thesis by A1,A4,B6;
end;

canceled 33;

theorem Th48:
  for S being IC-Ins-separated (non empty AMI-Struct over E) st
  S is realistic holds not ex l being Element of NAT st IC S = l
      by Def21;

reserve N for non empty with_non-empty_elements set,
 S for IC-Ins-separated definite (non empty stored-program AMI-Struct
  over N),
  s for State of S;

canceled 2;

theorem Th51:
  for p being NAT-defined (the Instructions of S)-valued Function
  for k holds Comput(p,s,i+k) = Comput(p,Comput(p,s,i),k)
proof let p be NAT-defined (the Instructions of S)-valued Function;
  defpred P[Element of NAT] means Comput(p,s,i+$1)
   = Comput(p, Comput(p,s,i),$1);
A1: now
    let k;
    assume
A2: P[k];
    Comput(p,s,i+(k+1)) = Comput(p,s,i+k+1)
      .= Following(p, Comput(p,s,i+k)) by Th14
      .= Comput(p, Comput(p,s,i),k+1) by A2,Th14;
    hence P[k+1];
  end;
A3: P[ 0] by Th13;
  thus for k holds P[k] from NAT_1:sch 1(A3,A1);
end;

theorem Th52:
  i <= j implies
 for N for S being halting IC-Ins-separated
  definite (non empty stored-program AMI-Struct over N)
  for p being NAT-defined (the Instructions of S)-valued Function
  for s being State of S st CurInstr(p,Comput(p,s,i)) = halt S
 holds Comput(p,s,j) = Comput(p,s,i)
proof
  assume
  i <= j;
  then consider k being Nat such that
A1: j = i + k by NAT_1:10;
  reconsider k as Element of NAT by ORDINAL1:def 13;
A2: j = i + k by A1;
  let N;
  let S be halting IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let s be State of S such that
A3: CurInstr(p,Comput(p,s,i))
 = halt S;
  defpred P[Element of NAT] means Comput(p,s,i+$1)
   = Comput(p,s,i);
A4: now
    let k;
    assume
A5: P[k];
    Comput(p,s,i+(k+1)) = Comput(p,s,i+k+1)
      .= Following(p,Comput(p,s,i+k)) by Th14
      .= Comput(p,s,i) by A3,A5,Def8;
    hence P[k+1];
  end;
A6: P[ 0];
  for k holds P[k] from NAT_1:sch 1(A6,A4);
  hence thesis by A2;
end;

L117: for N being with_non-empty_elements set for S being
  steady-programmed (non empty stored-program AMI-Struct over N) for i being
  Instruction of S, s being State of S holds Exec (i, s) | NAT = s | NAT
proof
  let N be with_non-empty_elements set;
  let S be steady-programmed (non empty stored-program AMI-Struct over N);
  let i be Instruction of S, s be State of S;
A1: NAT c= the carrier of S by Def3;
A2: for x being set st x in NAT holds (Exec (i, s) | NAT).x = (s | NAT).x
  proof
    let x be set;
    assume
    x in NAT;
    then reconsider l = x as Element of NAT;
    thus (Exec (i, s) | NAT).x = (Exec (i, s)).l by FUNCT_1:72
      .= s.l by Def13
      .= (s | NAT).x by FUNCT_1:72;
  end;
A4: dom ProgramPart s = NAT by LmU;
  dom (Exec (i,s)) = the carrier of S by PARTFUN1:def 4;
  then dom (Exec (i, s) | NAT) = NAT by A1,RELAT_1:91;
  hence thesis by A4,A2,FUNCT_1:9;
end;

reserve n for Element of NAT;

LmA:
  for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for s being State of S, n holds s|NAT = (
  Comput(ProgramPart s,s,n))|NAT
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S;
  defpred X[Element of NAT] means s|NAT = ( Comput(ProgramPart s,s,$1))|NAT;
A1: now
    let n;
    assume
    X[n];
    then s|NAT =
     (Following(ProgramPart s, Comput(ProgramPart s,s,n)))|NAT by L117
      .= ( Comput(ProgramPart s,s,n+1))|NAT by Th14;
    hence X[n+1];
  end;
A2: X[ 0] by Th13;
  thus for n holds X[n] from NAT_1:sch 1(A2,A1);
end;

LmY:
 for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for s being State of S, k
 holds ProgramPart s = ProgramPart Comput(ProgramPart s,s,k)
           by LmA;

LmX:
 for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for s being State of S, k
 holds (ProgramPart s)/.IC Comput(ProgramPart s,s,k)
  = CurInstr(ProgramPart Comput(ProgramPart s,s,k),Comput(ProgramPart s,s,k))
 proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s being State of S; let k;
A: ProgramPart s = ProgramPart Comput(ProgramPart s,s,k) by LmY;
  thus (ProgramPart s)/.IC Comput(ProgramPart s,s,k)
           = CurInstr(ProgramPart Comput(ProgramPart s,s,k),
           Comput(ProgramPart s,s,k))
            by A;
 end;

definition
  let N;
  let S be halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
   let p be NAT-defined (the Instructions of S)-valued Function;
  let s be State of S such that
A1: p halts_on s;
  func Result(p,s) -> State of S means
:Def22:
  ex k st it = Comput(p,s,k) & CurInstr(p,it) = halt S;
  uniqueness
  proof
    let s1,s2 be State of S;
    given k1 being Element of NAT such that
A2: s1 = Comput(p,s,k1) & CurInstr(p, s1) = halt S;
    given k2 being Element of NAT such that
A3: s2 = Comput(p,s,k2) & CurInstr(p, s2) = halt S;
    k1 <= k2 or k2 <= k1;
    hence thesis by A2,A3,Th52;
  end;
  correctness
  proof
    consider k being Nat such that
     IC Comput(p,s,k) in dom p and
W:   CurInstr(p, Comput(p,s,k)) = halt S by A1,Def20;
     k in NAT by ORDINAL1:def 13;
    hence thesis by W;
  end;
end;

theorem
  for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for s being State of S, i be
  Element of NAT holds s.i = Following(ProgramPart s,s).i by Def13;

definition
  let N;
  let S be definite (non empty stored-program AMI-Struct over N);
  let s be State of S, l be Element of NAT;
  redefine func s.l -> Instruction of S;
  coherence
  proof
Y:  dom the Object-Kind of S = the carrier of S by FUNCT_2:def 1;
U:  l in NAT;
    NAT c= the carrier of S by Def3;
    then
X:   pi(product the Object-Kind of S,l)
       = (the Object-Kind of S).l by CARD_3:22,Y,U
      .= the Instructions of S by Def14;
     s in product the Object-Kind of S by PBOOLE:155;
    hence thesis by CARD_3:def 6,X;
  end;
end;

theorem Th54:
  for S being steady-programmed IC-Ins-separated definite (non
  empty stored-program AMI-Struct over N) for s being State of S, i be
  Element of NAT, k holds s.i = Comput(ProgramPart s,s,k).i
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S, i be Element of NAT;
  defpred P[Element of NAT] means s.i = Comput(ProgramPart s,s,$1).i;
A1: now
    let k;
X:  ProgramPart Comput(ProgramPart s,s,k) = ProgramPart s by LmY;
    assume
    P[k];
    then s.i = (Following(ProgramPart Comput(ProgramPart s,s,k),
    Comput(ProgramPart s,s,k))).i by Def13
      .= Comput(ProgramPart s,s,k+1).i by Th14,X;
    hence P[k+1];
  end;
A2: P[ 0] by Th13;
  thus for k holds P[k] from NAT_1:sch 1(A2,A1);
end;

theorem
  for S being steady-programmed IC-Ins-separated definite (non empty
stored-program AMI-Struct over N) for s being State of S
 holds Comput(ProgramPart s,s,k+1) =
  Exec(s.(IC Comput(ProgramPart s,s,k)), Comput(ProgramPart s,s,k))
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S;
A: ProgramPart Comput(ProgramPart s,s,k) = ProgramPart s by LmY;
X:   s.(IC Comput(ProgramPart s,s,k)) = Comput(ProgramPart s,s,k).
(IC Comput(ProgramPart s,s,k)) by Th54;
Y:  (ProgramPart Comput(ProgramPart s,s,k))/.IC Comput(ProgramPart s,s,k)
 = Comput(ProgramPart s,s,k).IC Comput(ProgramPart s,s,k) by BWL1;
  thus Comput(ProgramPart s,s,k+1)
   = Following(ProgramPart Comput(ProgramPart s,s,k),Comput(ProgramPart s,s,k))
   by Th14,A
   .= Exec(CurInstr(ProgramPart Comput(ProgramPart s,s,k),
         Comput(ProgramPart s,s,k)),Comput(ProgramPart s,s,k))
   .= Exec(s.(IC Comput(ProgramPart s,s,k)), Comput(ProgramPart s,s,k)) by X,Y;
end;

L94:
  for N being with_non-empty_elements set,
      S being non empty AMI-Struct over N
  for s being State of S holds IC S in dom s
proof
  let N be with_non-empty_elements set,
      S be non empty AMI-Struct over N;
  let s be State of S;
  dom s = the carrier of S by PARTFUN1:def 4;
  hence thesis;
end;

theorem Th56:
  for S being steady-programmed IC-Ins-separated halting definite
(non empty stored-program AMI-Struct over N) for s being State of S, k
 st s.IC Comput(ProgramPart s,s,k) = halt S holds Result(ProgramPart(s),s) =
  Comput(ProgramPart s,s,k)
proof
  let S be steady-programmed IC-Ins-separated halting definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S, k;
   IC Comput(ProgramPart s,s,k) in NAT;
   then
X: IC Comput(ProgramPart s,s,k) in dom ProgramPart s by LmU;
Z: ProgramPart s = ProgramPart Comput(ProgramPart s,s,k) by LmY;
Y:  (ProgramPart Comput(ProgramPart s,s,k))/.IC Comput(ProgramPart s,s,k)
 = Comput(ProgramPart s,s,k).IC Comput(ProgramPart s,s,k) by BWL1;
  assume
  s.IC Comput(ProgramPart s,s,k) = halt S;
  then
A1: CurInstr(ProgramPart s,Comput(ProgramPart s,s,k))
 = halt S by Th54,Y,Z    ;
  then CurInstr(ProgramPart s, Comput(ProgramPart s,s,k)) = halt S;
  then ProgramPart s halts_on s by Def20,X;
 hence thesis by A1,Def22;
end;

theorem Th57:
  for S being steady-programmed IC-Ins-separated halting definite
(non empty stored-program AMI-Struct over N) for s being State of S st ex k
st s.IC Comput(ProgramPart s,s,k) = halt S for i holds Result(ProgramPart(s),s)
    = Result(ProgramPart s,Comput(ProgramPart s,s,i))
proof
  let S be steady-programmed IC-Ins-separated halting definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S;
  given k such that
A1: s.IC Comput(ProgramPart s,s,k) = halt S;
  let i;
  set s9 = Comput(ProgramPart s,s,k);
Y:  (ProgramPart s9)/.IC s9
 = s9.IC s9 by BWL1;
TX:  ProgramPart s9 = ProgramPart s by LmY;
      then
A2: CurInstr(ProgramPart s, s9) = halt S by A1,Th54,Y;
   IC Comput(ProgramPart s,s,k) in NAT;
   then
X:  IC Comput(ProgramPart s,s,k) in dom ProgramPart Comput(ProgramPart s,s,i)
 by LmU;
  now
    per cases;
    suppose
      i <= k;
      then consider j being Nat such that
A3:   k = i + j by NAT_1:10;
      reconsider j as Element of NAT by ORDINAL1:def 13;
t:    ProgramPart Comput(ProgramPart s,s,i) = ProgramPart s by LmY;
      then
A4:   Comput(ProgramPart s,s,k)
      = Comput(ProgramPart Comput(ProgramPart s,s,i),
      Comput(ProgramPart s,s,i),j) by A3,Th51;
      CurInstr(ProgramPart Comput(ProgramPart s,s,i),
      Comput(ProgramPart s,s,k))
       = halt S
                    by A2,t;
      then
A5:   ProgramPart s halts_on Comput(ProgramPart s,s,i)
 by A4,Def20,X,t;
      thus Result(ProgramPart(s),s) = s9 by A1,Th56
        .= Result(ProgramPart s,Comput(ProgramPart s,s,i))
        by A2,A4,A5,Def22,t;
    end;
    suppose
A6:   i >= k;
A7:   Comput(ProgramPart Comput(ProgramPart s,s,k),Comput(ProgramPart s,s,k),0)
 = Comput(ProgramPart s,s,k)
 by Th13;
A8:   Comput(ProgramPart s,s,i) = s9 by A2,A6,Th52;
     IC Comput(ProgramPart s9,s9,0) in NAT;
     then
X:    IC Comput(ProgramPart s9,s9,0) in dom ProgramPart s9 by LmU;
      CurInstr(ProgramPart s9, Comput(ProgramPart s9,s9,0)) = halt S
         by A2,A7,TX;
      then
A9:   ProgramPart s halts_on Comput(ProgramPart s,s,i) by Def20,X,A8,TX;
      thus Result(ProgramPart(s),s) = s9 by A1,Th56
        .= Result(ProgramPart s,Comput(ProgramPart s,s
,i)) by A2,A8,A7,A9,Def22,TX;
    end;
  end;
  hence thesis;
end;

registration
  let N;
  let S be non empty AMI-Struct over N, o be Object of S;
  cluster ObjectKind o -> non empty;
  coherence;
end;

begin :: Finite substates

definition
  let N be set;
  let S be AMI-Struct over N;
  func FinPartSt S -> Subset of sproduct the Object-Kind of S equals
  { p where
  p is Element of sproduct the Object-Kind of S: p is finite };
  coherence
  proof
    defpred P[set] means $1 is finite;
    { p where p is Element of sproduct the Object-Kind of S: P[p] } c=
    sproduct the Object-Kind of S from FRAENKEL:sch 10;
    hence thesis;
  end;
end;

definition
  let N be set;
  let S be non empty AMI-Struct over N;
  func Data-Locations S equals
  (the carrier of S) \ ({IC S} \/ NAT);
  coherence;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let IT be FinPartState of S;
  attr IT is autonomic means
:Def25:
  for s1,s2 being State of S st IT c= s1 &
  IT c= s2 for i holds Comput(ProgramPart s1,s1,i)|dom IT
   = Comput(ProgramPart s2,s2,i)|dom IT;
end;

definition
  let N;
  let S be halting IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N);
  let IT be FinPartState of S;
  attr IT is halting means
:Def26:
  for s being State of S st IT c= s holds ProgramPart s halts_on s;
end;

theorem Th58:
  for S being non empty AMI-Struct over N for A,B being set, la
  ,lb being Object of S st ObjectKind la = A & ObjectKind lb = B for a being
Element of A, b being Element of B holds (la,lb) --> (a,b) is FinPartState of S
proof
  let S be non empty AMI-Struct over N;
  let A,B be set, la,lb be Object of S such that
A1: ObjectKind la = A and
A2: ObjectKind lb = B;
  let a be Element of A, b be Element of B;
  set p = (la,lb) --> (a,b);
A3: dom p = {la,lb} by FUNCT_4:65;
A4: now
    let x be set such that
A5: x in dom p;
    now
      per cases by A3,A5,TARSKI:def 2;
      suppose
A6:     la <> lb & x = la;
        then p.x = a by FUNCT_4:66;
        hence p.x in (the Object-Kind of S).x by A1,A6;
      end;
      suppose
A7:     la <> lb & x = lb;
        then p.x = b by FUNCT_4:66;
        hence p.x in (the Object-Kind of S).x by A2,A7;
      end;
      suppose
A8:     la = lb & x = la;
        then p = la .--> b by CQC_LANG:44;
        then p.x = b by A8,FUNCOP_1:87;
        hence p.x in (the Object-Kind of S).x by A2,A8;
      end;
    end;
    hence p.x in (the Object-Kind of S).x;
  end;
  reconsider p as PartState of S by A3,A4,FUNCT_1:def 20,RELAT_1:def 18;
  dom p = {la,lb} by FUNCT_4:65;
  hence thesis by FINSET_1:29;
end;

theorem Th59:
  for S being non empty AMI-Struct over N for A being set, la
being Object of S st (the Object-Kind of S).la = A
 for a being Element of A holds la .--> a is FinPartState of S
proof
  let S be non empty AMI-Struct over N;
  let A be set, la be Object of S such that
A1: (the Object-Kind of S).la = A;
  let a be Element of A;
  set p = la .--> a;
A2: dom p = {la} by FUNCOP_1:19;
A3: now
    let x be set;
    assume
    x in dom p;
    then
A4: x = la by A2,TARSKI:def 1;
    then p.x = a by FUNCOP_1:87;
    hence p.x in (the Object-Kind of S).x by A1,A4;
  end;
  reconsider p as PartState of S by A2,A3,FUNCT_1:def 20,RELAT_1:def 18;
  p is FinPartState of S;
  hence thesis;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let la be Object of S;
  let a be Element of ObjectKind la;
  redefine func la .--> a -> FinPartState of S;
  coherence by Th59;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let la,lb be Object of S;
  let a be Element of ObjectKind la, b be Element of ObjectKind lb;
  redefine func (la,lb) --> (a,b) -> FinPartState of S;
  coherence by Th58;
end;

registration
  let E;
  cluster Trivial-AMI E -> realistic;
  coherence
proof
  assume
A1: the Instruction-Counter of Trivial-AMI E in NAT;
  the Instruction-Counter of Trivial-AMI E = NAT by Def2;
  hence thesis by A1;
end;
end;

registration
  let E;
  cluster realistic strict AMI-Struct over E;
  existence
  proof
    take Trivial-AMI E;
    thus thesis;
  end;
end;

registration
  let M be set;
  cluster realistic strict IC-Ins-separated definite (non empty stored-program
    AMI-Struct over M);
  existence
  proof
    take Trivial-AMI M;
    thus thesis;
  end;
end;

registration
  let N;
  cluster halting steady-programmed realistic strict
   (IC-Ins-separated definite (non empty stored-program AMI-Struct over N));
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration
  let N be set;
  let S be AMI-Struct over N;
  let f,g be PartState of S;
  cluster f +* g -> (the carrier of S)-defined
           (the Object-Kind of S)-compatible Function;
  coherence;
end;

begin :: Preprograms

canceled 4;

theorem Th64:
  for S being halting realistic IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
  for l being Nat, I being Instruction of S
  for p being FinPartState of S, s being State of S
   st p = (IC S,l) --> (l, I) & p c= s holds CurInstr(ProgramPart s, s) = I
proof
  let S be halting realistic IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let l be Nat, I be Instruction of S;
  let p be FinPartState of S, s be State of S such that
Z: p = (IC S,l) --> (l, I) and
A3: p c= s;
  l in NAT by ORDINAL1:def 13;
  then
A4: IC S <> l by Def21;
Y:  (ProgramPart s)/.IC s
 = s.IC s by BWL1;
A5: dom((IC S,l) --> (l, I)) = {IC S,l} by FUNCT_4:65;
  then l in dom((IC S,l) --> (l, I )) by TARSKI:def 2;
  then
A6: ((IC S,l) --> (l, I)).IC S in dom((IC S,l) --> (l, I)) by A4,
FUNCT_4:66;
  IC S in dom((IC S,l) --> (l, I)) by A5,TARSKI:def 2;
  hence CurInstr(ProgramPart s, s) = s.(((IC S,l) --> (l, I)).IC S)
   by A3,GRFUNC_1:8,Z,Y
    .= ((IC S,l) --> (l, I)).(((IC S,l) --> (l, I)).IC S) by A3,A6,Z,
GRFUNC_1:8
    .= ((IC S,l) --> (l, I)).l by A4,FUNCT_4:66
    .= I by FUNCT_4:66;
end;

theorem Th65:
  for S being halting realistic IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
  for l being Nat
   for p being FinPartState of S st p = (IC S,l) --> (l, halt S)
   holds p is halting
proof
  let S be halting realistic IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let l be Nat;
   set h = halt S;
  let p be FinPartState of S such that
Z: p = (IC S,l) --> (l, h);
    let s be State of S such that
A3: p c= s;
    take 0;
     IC Comput(ProgramPart s,s,0) in NAT;
    hence IC Comput(ProgramPart s,s,0) in dom ProgramPart s by LmU;
u: Comput(ProgramPart s,s,0) = s by Th13;
    CurInstr(ProgramPart Comput(ProgramPart s,s,0),Comput(ProgramPart s,s,0))
     = CurInstr(ProgramPart s, s) by u
      .= halt S by A3,Th64,Z;
    hence CurInstr(ProgramPart s, Comput(ProgramPart s,s,0)) = halt S by LmX;
end;

theorem Th66:
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non
  empty stored-program AMI-Struct over N)
  for l being Nat
  for p being FinPartState of S, s being State of S
   st p = (IC S,l) --> (l, halt S) & p c= s
   for i holds Comput(ProgramPart s,s,i) = s
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty
  stored-program AMI-Struct over N);
  let l be Nat;
   set h = halt S;
  let p be FinPartState of S, s be State of S such that
Z:  p = (IC S,l) --> (l, h) and
A3: p c= s;
  defpred P[Element of NAT] means Comput(ProgramPart s,s,$1) = s;
A4: now
    let i;
    assume
A5: P[i];
    ProgramPart Comput(ProgramPart s,s,i) = ProgramPart s by LmY;
    then Comput(ProgramPart s,s,i+1)
     = Following(ProgramPart Comput(ProgramPart s,s,i),
     Comput(ProgramPart s,s,i)) by Th14
      .= Exec(halt S,s) by Z,A3,A5,Th64
      .= s by Def8;
    hence P[i+1];
  end;
A6: P[ 0] by Th13;
  thus for i holds P[i] from NAT_1:sch 1(A6,A4);
end;

theorem Th67:
  for S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
  for l being Nat
  for p being FinPartState of S st p = (IC S,l) --> (l, halt S)
   holds p is autonomic
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let l be Nat;
   set h = halt S;
  let p be FinPartState of S such that
Z: p = (IC S,l) --> (l, halt S);
    let s1,s2 be State of S;
    assume that
A3: p c= s1 and
A4: p c= s2;
A5: s1|dom((IC S,l) --> (l, h)) = (IC S,l) --> (l, h) & s2|dom((IC S,
    l) --> (l, h)) = (IC S,l) --> (l, h) by Z,A3,A4,GRFUNC_1:64;
    let i;
    Comput(ProgramPart s1,s1,i) = s1 by Z,A3,Th66;
    hence thesis by Z,A4,A5,Th66;
end;

registration
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  cluster autonomic halting FinPartState of S;
  existence
  proof
    reconsider h = halt S as Element of (the Object-Kind of S).0 by Def14;
K:  dom(IC S .--> 0) = {IC S} by FUNCOP_1:19;
    now let x;
     assume x in {IC S};
      then
Z:     x = IC S by TARSKI:def 1;
      then
A:     (IC S .--> 0).x = 0 by FUNCOP_1:87;
      ObjectKind IC S = NAT by Def11;
     hence (IC S .--> 0).x in (the Object-Kind of S).x by A,Z;
    end;
    then
Y:  IC S .--> 0 is
      (the carrier of S)-defined (the Object-Kind of S)-compatible
               by RELAT_1:def 18, FUNCT_1:def 20,K;
U:  0 in NAT;
    NAT c= the carrier of S by Def3;
    then
T:  {0} c= the carrier of S by ZFMISC_1:37,U;
L:  dom(0 .--> h) = {0} by FUNCOP_1:19;
V:  dom(0 .--> h) c= the carrier of S by T,FUNCOP_1:19;
    now let x;
     assume x in {0};
      then
Z:     x = 0 by TARSKI:def 1;
      then
A:     (0 .--> h).x = h by FUNCOP_1:87;
      (the Object-Kind of S).x = the Instructions of S by Z,Def14;
     hence (0 .--> h).x in (the Object-Kind of S).x by A;
    end;
    then 0 .--> h is
      (the carrier of S)-defined (the Object-Kind of S)-compatible
               by RELAT_1:def 18, FUNCT_1:def 20,V,L;
    then (IC S .--> 0) +* (0 .--> h) is
      (the carrier of S)-defined (the Object-Kind of S)-compatible by Y;

    then reconsider p = (IC S,0) --> (0, halt S)
     as FinPartState of S by FUNCT_4:def 4;
    p is autonomic halting by Th65,Th67;
    hence thesis;
  end;
end;

definition
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  mode pre-program of S is autonomic halting FinPartState of S;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
   let p be NAT-defined (the Instructions of S)-valued Function;
  let s be FinPartState of S;
canceled;
  assume
A1: s is pre-program of S;
  func Result(p,s) -> FinPartState of S means
  for s9 being State of S st s c= s9
  holds it = (Result(ProgramPart(s9),s9))|dom s;
  existence
  proof
    consider h being State of S such that
A3:  s c= h by PBOOLE:156;
    ProgramPart h halts_on h by A1,A3,Def26;
    then consider k1 being Element of NAT such that
A4: Result(ProgramPart(h),h) = Comput(ProgramPart h,h,k1) and
A5: CurInstr(ProgramPart(h), Result(ProgramPart(h),h)) =
halt S by Def22;
    reconsider R = (Result(ProgramPart(h),h))|dom s as FinPartState of S;
    take R;
    let s9 be State of S such that
A6: s c= s9;
    ProgramPart s9 halts_on s9 by A1,A6,Def26;
    then consider k2 being Element of NAT such that
A7: Result(ProgramPart(s9),s9) = Comput(ProgramPart s9,s9,k2) and
A8: CurInstr(ProgramPart(s9), Result(ProgramPart(s9),s9)) = halt S by Def22;
    now
      per cases;
      suppose
        k1 <= k2;
        then Result(ProgramPart(h),h) = Comput(ProgramPart h,h,k2) by A4,A5,
Th52;
        hence thesis by A1,A3,A6,A7,Def25;
      end;
      suppose
        k1 >= k2;
        then Result(ProgramPart(s9),s9) = Comput(ProgramPart s9,s9,k1) by A7,A8
,Th52;
        hence thesis by A1,A3,A6,A4,Def25;
      end;
    end;
    hence thesis;
  end;
  correctness
  proof
    consider h being State of S such that
A10:  s c= h by PBOOLE:156;
    let p1,p2 be FinPartState of S such that
A11: for s9 being State of S st s c= s9 holds p1 = (Result(ProgramPart(s9),s9))
|dom s and
A12: for s9 being State of S st s c= s9 holds p2 = (Result(ProgramPart(s9),s9))
|dom s;
    thus p1 = (Result(ProgramPart(h),h))|dom s by A11,A10
      .= p2 by A12,A10;
  end;
end;

begin :: Computability

definition
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be FinPartState of S, F be Function;
  pred p computes F means
:Def29:
  for x being set st x in dom F
   ex s being FinPartState of S
    st x = s & p +* s is pre-program of S & F.s c= Result(ProgramPart(p +* s),p
+* s);
end;

notation
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be FinPartState of S, F be Function;
  antonym p does_not_compute F for p computes F;
end;

theorem Th68:
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
 for p being FinPartState of S holds
  p computes {}
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be FinPartState of S;
  let x be set;
  assume
A1: x in dom {};
  then reconsider x as FinPartState of S;
  take x;
  thus thesis by A1;
end;

theorem Th69:
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N) for p being FinPartState of S
  holds p is pre-program of S iff p computes {} .--> Result(ProgramPart(p),p)
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N);
  let p be FinPartState of S;
  thus p is pre-program of S implies p
   computes {} .--> Result(ProgramPart(p),p)
  proof
A1: dom({} .--> Result(ProgramPart(p),p)) = {{}} by FUNCOP_1:19;
    assume
A2: p is pre-program of S;
    let x be set;
    assume
    x in dom({} .--> Result(ProgramPart(p),p));
    then
A3: x = {} by A1,TARSKI:def 1;
    then reconsider s = x as FinPartState of S by FUNCT_1:174,RELAT_1:206;
    take s;
    thus x = s;
    thus p +* s is pre-program of S by A2,A3,FUNCT_4:22;
X:   p+*s = p by A3,FUNCT_4:22;
    ({} .--> Result(ProgramPart(p),p)).s = Result(ProgramPart(p),p) by A3,
FUNCOP_1:87;
    hence thesis by X;
  end;
  dom({} .--> Result(ProgramPart(p),p)) = {{}} by FUNCOP_1:19;
  then
A4: {} in dom({} .--> Result(ProgramPart(p),p)) by TARSKI:def 1;
  assume
  p computes {} .--> Result(ProgramPart(p),p);
  then
  ex s being FinPartState of S st s = {} & p +* s is pre-program of S & ({}
  .--> Result(ProgramPart(p),p)).s c= Result(ProgramPart(p +* s),p +* s) by A4,
Def29;
  hence thesis by FUNCT_4:22;
end;

theorem Th70:
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N) for p being FinPartState of S
    holds p is pre-program of S iff p computes {} .--> {}
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be FinPartState of S;
  thus p is pre-program of S implies p computes {} .--> {}
  proof
A1: dom({} .--> {}) = {{}} by FUNCOP_1:19;
    assume
A2: p is pre-program of S;
    let x be set;
    assume
    x in dom({} .--> {});
    then
A3: x = {} by A1,TARSKI:def 1;
    then reconsider s = x as FinPartState of S by FUNCT_1:174,RELAT_1:206;
    take s;
    thus x = s;
    thus p +* s is pre-program of S by A2,A3,FUNCT_4:22;
    ({} .--> {}).s = {} by A3,FUNCOP_1:87;
    hence thesis by XBOOLE_1:2;
  end;
  dom({} .--> {}) = {{}} by FUNCOP_1:19;
  then
A4: {} in dom({} .--> {}) by TARSKI:def 1;
  assume
  p computes {} .--> {};
  then
  ex s being FinPartState of S st s = {} & p +* s is pre-program of S & ({}
  .--> {}).s c= Result(ProgramPart(p +* s),p +* s) by A4,Def29;
  hence thesis by FUNCT_4:22;
end;

definition
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let IT be PartFunc of FinPartSt S, FinPartSt S;
  attr IT is computable means
  :Def30:
  ex p being FinPartState of S st p computes IT;
end;

theorem Th71:
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
    for F being PartFunc of FinPartSt S,
  FinPartSt S st F = {} holds F is computable
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let F be PartFunc of FinPartSt S, FinPartSt S;
  consider p being FinPartState of S;
  assume
A1: F = {};
  take p;
  thus thesis by A1,Th68;
end;

theorem Th72:
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
    for F being PartFunc of FinPartSt S,
  FinPartSt S st F = {} .--> {} holds F is computable
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let F be PartFunc of FinPartSt S, FinPartSt S;
  consider p being pre-program of S;
  assume
A1: F = {} .--> {};
  take p;
  thus thesis by A1,Th70;
end;

theorem Th73:
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
   for p being pre-program of S for F
being PartFunc of FinPartSt S, FinPartSt S st F = {} .--> Result(ProgramPart(p)
,p) holds F is
  computable
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be pre-program of S;
  let F be PartFunc of FinPartSt S, FinPartSt S;
  assume
A1: F = {} .--> Result(ProgramPart(p),p);
  take p;
  thus thesis by A1,Th69;
end;

definition
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let F be PartFunc of FinPartSt S, FinPartSt S such that
A1: F is computable;
  mode Program of F -> FinPartState of S means
    it computes F;
  existence by A1,Def30;
end;

theorem
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
   for F being PartFunc of FinPartSt S,
  FinPartSt S st F = {} for p being FinPartState of S holds p is Program of F
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let F be PartFunc of FinPartSt S, FinPartSt S such that
A1: F = {};
  let p be FinPartState of S;
  thus F is computable by A1,Th71;
  thus thesis by A1,Th68;
end;

theorem
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
   for F being PartFunc of FinPartSt S,
  FinPartSt S st F = {} .--> {} for p being pre-program of S holds p is Program
  of F
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let F be PartFunc of FinPartSt S, FinPartSt S such that
A1: F = {} .--> {};
  let p be pre-program of S;
  thus F is computable by A1,Th72;
  thus thesis by A1,Th70;
end;

theorem
  for S being realistic halting IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N) for p being pre-program of S
  for F being
PartFunc of FinPartSt S, FinPartSt S st F = {} .--> Result(ProgramPart(p),p)
holds p is Program
  of F
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N);
  let p be pre-program of S;
  let F be PartFunc of FinPartSt S, FinPartSt S;
  assume
A1: F = {} .--> Result(ProgramPart(p),p);
  hence F is computable by Th73;
  thus thesis by A1,Th69;
end;

begin :: InsType & InsCode

notation
  let x;
  synonym InsCode x for x`1;
  synonym AddressPart x for x`2;
end;

definition
  let N be set, S be AMI-Struct over N;
  attr S is standard-ins means
:Def32:
   ex X being non empty set
    st the Instructions of S c= [: NAT,X*:];
end;

registration
  let N be set;
  cluster Trivial-AMI N -> standard-ins;
  coherence
  proof
    {} in ((union N) \/ the carrier of Trivial-AMI N)* by FINSEQ_1:66;
    then
A1: {{}} c= ((union N) \/ the carrier of Trivial-AMI N)* by ZFMISC_1:37;
    take X = (union N) \/ the carrier of Trivial-AMI N;
    the Instructions of Trivial-AMI N = {[0,{}]} by Def2
      .= [:{0},{{}}:] by ZFMISC_1:35;
    hence the Instructions of Trivial-AMI N c= [: NAT,X*:]
     by A1,ZFMISC_1:119;
  end;
end;

registration
  let N be set;
  cluster standard-ins non empty stored-program AMI-Struct over N;
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration
  let N be set, S be standard-ins AMI-Struct over N;
  cluster the Instructions of S -> Relation-like;
  coherence
   proof
    ex X being non empty set
     st the Instructions of S c= [: NAT,X*:] by Def32;
    hence thesis;
   end;
end;

registration let N be set;
 let S be standard-ins non empty AMI-Struct over N;
 let x be Instruction of S;
 cluster InsCode x -> natural;
 coherence
  proof
    consider X being non empty set such that
W:   the Instructions of S c= [:NAT,X*:] by Def32;
   x in the Instructions of S;
   then x`1 in NAT by W,MCART_1:10;
   hence thesis;
  end;
end;

registration
  let N;
  cluster IC-Ins-separated definite standard-ins (non empty stored-program
    AMI-Struct over N);
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration
  let N be set, S be standard-ins AMI-Struct over N;
  cluster the Instructions of S -> Relation-like;
  coherence;
end;

definition
  let N be set, S be standard-ins AMI-Struct over N;
  func InsCodes S equals
  dom the Instructions of S;
  correctness;
end;

definition
  let N be set, S be standard-ins AMI-Struct over N;
  mode InsType of S is Element of InsCodes S;
end;

definition
  let N be set, S be standard-ins AMI-Struct over N;
  let I be Element of the Instructions of S;
  redefine func InsCode I -> InsType of S;
  coherence by MCART_1:91;
end;

begin :: Some Remarks on AMI-Struct

reserve N for set,
  S for non empty AMI-Struct over N;

LMT:
 for N being with_non-empty_elements set,
     S be AMI-Struct over N
 for p being FinPartState of S holds p in FinPartSt S
 proof
  let N be with_non-empty_elements set,
     S be AMI-Struct over N;
  let p be FinPartState of S;
   p in sproduct the Object-Kind of S by CARD_3:153;
  hence thesis;
 end;

registration
  let N be with_non-empty_elements set;
  let S be AMI-Struct over N;
  cluster FinPartSt S -> non empty;
  coherence by LMT;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty AMI-Struct over N);
  canceled 5;
  let l be Nat;
  func Start-At(l,S) -> FinPartState of S equals
  IC S .--> l;
  correctness
  proof
    reconsider l as Element of NAT by ORDINAL1:def 13;
    ObjectKind IC S = NAT by Def11;
    then IC S .--> l is FinPartState of S by Th59;
    hence thesis;
  end;
end;

reserve N for with_non-empty_elements non empty set;

registration
  let N be set;
  let S be AMI-Struct over N;
  cluster NAT-defined FinPartState of S;
  existence
  proof
    reconsider Z = {} as FinPartState of S by FUNCT_1:174,RELAT_1:206;
    take Z;
    thus dom Z c= NAT by RELAT_1:60,XBOOLE_1:2;
  end;
end;

canceled 4;

theorem Th81:
  for S being steady-programmed IC-Ins-separated definite (non
empty stored-program AMI-Struct over N) for p being NAT-defined FinPartState
  of S for s being State of S st p c= s for k
  holds p c= Comput(ProgramPart s,s,k)
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let p be NAT-defined FinPartState of S, s be State of S such that
A1: p c= s;
  let k;
A2: dom p c= NAT by RELAT_1:def 18;
A3: now
    let x be set;
    assume
A4: x in dom p;
    then reconsider l = x as Element of NAT by A2;
    s.x = ( Comput(ProgramPart s,s,k)).l by Th54;
    hence p.x = ( Comput(ProgramPart s,s,k)).x by A1,A4,GRFUNC_1:8;
  end;
  dom s = the carrier of S by PARTFUN1:def 4
    .= dom( Comput(ProgramPart s,s,k)) by PARTFUN1:def 4;
  then dom p c= dom( Comput(ProgramPart s,s,k)) by A1,GRFUNC_1:8;
  hence thesis by A3,GRFUNC_1:8;
end;

definition
 canceled;
  let N be with_non-empty_elements set;
  let S be IC-Ins-separated (non empty AMI-Struct over N),
      l be Nat;
  let p be PartState of S;
  attr p is l-started means
:Def41: IC S in dom p & IC p = l;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty AMI-Struct over N),
      l be Nat;
  cluster Start-At(l,S) -> l-started;
  coherence
   proof
     dom Start-At(l,S) = {IC S} by FUNCOP_1:19;
    hence IC S in dom Start-At(l,S) by TARSKI:def 1;
    thus IC Start-At(l,S) = l by FUNCOP_1:87;
   end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty AMI-Struct over N),
      l be Nat;
  cluster l-started FinPartState of S;
  existence
   proof
    take Start-At(l,S);
    thus thesis;
   end;
end;

registration
  let N;
  let S be AMI-Struct over N;
  let s be State of S;
  let p be PartState of S;
  cluster s +* p -> total PartState of S;
  coherence;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty AMI-Struct over N),
      l be Nat,
      p being PartState of S, q be l-started PartState of S;
  cluster p +* q -> l-started;
  coherence
   proof
A:   IC S in dom q by Def41;
     dom q c= dom(p+*q) by FUNCT_4:11;
    hence IC S in dom(p+*q) by A;
     IC q = l by Def41;
    hence IC(p+*q) = l by A,FUNCT_4:14;
   end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty AMI-Struct over N),
      l be Nat;
  cluster l-started State of S;
  existence
   proof
    take t = (the State of S) +* Start-At(l,S);
    thus thesis;
   end;
end;

definition
  let N;
  let S be IC-Ins-separated halting (non empty AMI-Struct over N);
  let s be State of S, l be set;
  pred s halts_at l means
:Def42:
  s.l = halt S;
end;

definition
  canceled;
  let N;
  let S be IC-Ins-separated (non empty AMI-Struct over N),
      l be Nat;
  let s be State of S;
  redefine attr s is l-started means
  IC s = l;
  compatibility
   proof
    thus s is l-started implies IC s = l by Def41;
    assume
Z:    IC s = l;
    thus IC S in dom s by L94;
    thus IC s = l by Z,Def41;
   end;
end;

definition
  let N;
  let S be definite IC-Ins-separated halting (non empty stored-program
  AMI-Struct over N);
  let p be FinPartState of S, l be set;
  pred p halts_at l means
  l in dom p & p.l = halt S;
end;

canceled;

theorem Th83:
  for S being IC-Ins-separated definite steady-programmed halting
(non empty stored-program AMI-Struct over N), s being State of S
 holds ProgramPart s halts_on s iff ex k st s halts_at
 IC Comput(ProgramPart s,s,k)
proof
  let S be IC-Ins-separated definite steady-programmed halting (non empty
  stored-program AMI-Struct over N);
  let s be State of S;
  hereby
    assume ProgramPart s halts_on s;
    then consider k being Nat such that
     IC Comput(ProgramPart s,s,k) in dom ProgramPart s and
A1:  CurInstr(ProgramPart s, Comput(ProgramPart s,s,k)) = halt S by Def20;
    reconsider k as Element of NAT by ORDINAL1:def 13;
    take k;
Y:  (ProgramPart Comput(ProgramPart s,s,k))/.IC Comput(ProgramPart s,s,k)
 = Comput(ProgramPart s,s,k).IC Comput(ProgramPart s,s,k) by BWL1;
    (ProgramPart s)/.IC Comput(ProgramPart s,s,k)
     = CurInstr(ProgramPart Comput(ProgramPart s,s,k),
     Comput(ProgramPart s,s,k)) by LmX;
    then s.IC Comput(ProgramPart s,s,k) = halt S by A1,Th54,Y;
    hence s halts_at IC Comput(ProgramPart s,s,k) by Def42;
  end;
  given k such that
A2: s halts_at IC Comput(ProgramPart s,s,k);
  take k;
Y:  (ProgramPart Comput(ProgramPart s,s,k))/.IC Comput(ProgramPart s,s,k)
 = Comput(ProgramPart s,s,k).IC Comput(ProgramPart s,s,k) by BWL1;
   IC Comput(ProgramPart s,s,k) in NAT;
  hence IC Comput(ProgramPart s,s,k) in dom ProgramPart s by LmU;
   CurInstr(ProgramPart Comput(ProgramPart s,s,k),Comput(ProgramPart s,s,k))
    = s.IC Comput(ProgramPart s,s,k) by Th54,Y
    .= halt S by A2,Def42;
  hence CurInstr(ProgramPart s, Comput(ProgramPart s,s,k)) = halt S by LmX;
end;

theorem
  for S being IC-Ins-separated definite steady-programmed halting (non
  empty stored-program AMI-Struct over N), s being State of S, p being
  FinPartState of S, l being Element of NAT st p c= s & p halts_at l
  holds s halts_at l
proof
  let S be IC-Ins-separated definite steady-programmed halting (non empty
  stored-program AMI-Struct over N);
  let s be State of S, p be FinPartState of S, l be Element of NAT
  such that
A1: p c= s;
  assume
  l in dom p & p.l = halt S;
  hence s.l = halt S by A1,GRFUNC_1:8;
end;

theorem Th85:
  for S being halting steady-programmed IC-Ins-separated definite
(non empty stored-program AMI-Struct over N), s being State of S, k
 st ProgramPart s halts_on s
 holds Result(ProgramPart(s),s) = Comput(ProgramPart s,s,k) iff s halts_at
 IC Comput(ProgramPart s,s,k)
proof
  let S be halting steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S, k such that
A1: ProgramPart s halts_on s;
Y:  (ProgramPart Comput(ProgramPart s,s,k))/.IC Comput(ProgramPart s,s,k)
 = Comput(ProgramPart s,s,k).IC Comput(ProgramPart s,s,k) by BWL1;
TX: ProgramPart s = ProgramPart Comput(ProgramPart s,s,k) by LmY;
  hereby
    assume
    Result(ProgramPart(s),s) = Comput(ProgramPart s,s,k);
    then
    ex i st Comput(ProgramPart s,s,k) = Comput(ProgramPart s,s,i) &
     CurInstr(ProgramPart s,Comput(ProgramPart s,s,k))
      = halt S
      by A1,Def22;
    then s.IC Comput(ProgramPart s,s,k) = halt S by Th54,Y,TX;
    hence s halts_at IC Comput(ProgramPart s,s,k) by Def42;
  end;
  assume
  s.IC Comput(ProgramPart s,s,k) = halt S;
  then CurInstr(ProgramPart s,Comput(ProgramPart s,s,k)) = halt S
   by Th54,Y,TX;
  hence thesis by A1,Def22;
end;

theorem
  for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N), s being State of S, p being NAT-defined
  FinPartState of S, k holds p c= s iff p c= Comput(ProgramPart s,s,k)
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S, p be NAT-defined FinPartState of S, k;
  dom( Comput(ProgramPart s,s,k)) = the carrier of S by PARTFUN1:def 4;
  then
A1: dom p c= dom( Comput(ProgramPart s,s,k)) by RELAT_1:def 18;
A2: dom p c= NAT by RELAT_1:def 18;
A3: now
    hereby
      assume
A4:   for x being set st x in dom p holds p.x = s.x;
      let x be set;
      assume
A5:   x in dom p;
      then reconsider l = x as Element of NAT by A2;
      thus Comput(ProgramPart s,s,k).x = s.l by Th54
        .= p.x by A4,A5;
    end;
    assume
A6: for x being set st x in dom p holds p.x = Comput(ProgramPart s,s,k).x;
    let x be set;
    assume
A7: x in dom p;
    then reconsider l = x as Element of NAT by A2;
    thus s.x = Comput(ProgramPart s,s,k).l by Th54
      .= p.x by A6,A7;
  end;
  dom s = the carrier of S by PARTFUN1:def 4;
  then dom p c= dom s by RELAT_1:def 18;
  hence thesis by A1,A3,GRFUNC_1:8;
end;

theorem Th87:
  for S being halting steady-programmed IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N), s being State of S, k st s
  halts_at IC Comput(ProgramPart s,s,k) holds Result(ProgramPart(s),s) =
  Comput(ProgramPart s,s,k)
proof
  let S be halting steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N), s be State of S, k;
  assume
A1: s halts_at IC Comput(ProgramPart s,s,k);
  then ProgramPart s halts_on s by Th83;
  hence thesis by A1,Th85;
end;

theorem Th88:
  i <= j implies for S being halting steady-programmed
IC-Ins-separated definite (non empty stored-program AMI-Struct over N) for s
  being State of S st s halts_at IC Comput(ProgramPart s,s,i)
  holds s halts_at IC
  Comput(ProgramPart s,s,j)
proof
  assume
A1: i <= j;
  let S be halting steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S;
Y:  (ProgramPart Comput(ProgramPart s,s,i))/.IC Comput(ProgramPart s,s,i)
 = Comput(ProgramPart s,s,i).IC Comput(ProgramPart s,s,i) by BWL1;
X: ProgramPart Comput(ProgramPart s,s,i) = ProgramPart s by LmY;
  assume
A2: s.IC Comput(ProgramPart s,s,i) = halt S;
  then CurInstr(ProgramPart Comput(ProgramPart s,s,i),
  Comput(ProgramPart s,s,i)) = halt S
   by Th54,Y;
  hence s.IC Comput(ProgramPart s,s,j) = halt S by A1,A2,Th52,X;
end;

theorem :: AMI_1:46
  i <= j implies for S being halting steady-programmed IC-Ins-separated
definite (non empty stored-program AMI-Struct over N) for s being State of S
  st s halts_at IC Comput(ProgramPart s,s,i) holds Comput(ProgramPart s,s,j)
   = Comput(ProgramPart s,s,i)
proof
  assume
A1: i <= j;
  let S be halting steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N), s be State of S;
  assume
A2: s halts_at IC Comput(ProgramPart s,s,i);
  then s halts_at IC Comput(ProgramPart s,s,j) by A1,Th88;
  hence Comput(ProgramPart s,s,j) = Result(ProgramPart(s),s) by Th87
    .= Comput(ProgramPart s,s,i) by A2,Th87;
end;

theorem
  for S being steady-programmed IC-Ins-separated halting definite (non
empty stored-program AMI-Struct over N) for s being State of S st ex k st s
  halts_at IC Comput(ProgramPart s,s,k)
   for i holds Result(ProgramPart(s),s) =
  Result(ProgramPart s,Comput(ProgramPart s,s,i))
proof
  let S be steady-programmed IC-Ins-separated halting definite (non empty
  stored-program AMI-Struct over N), s be State of S;
  given k such that
A1: s halts_at IC Comput(ProgramPart s,s,k);
  let i;
  s.IC Comput(ProgramPart s,s,k) = halt S by A1,Def42;
  hence thesis by Th57;
end;

theorem
  for S being steady-programmed IC-Ins-separated definite halting (non
  empty stored-program AMI-Struct over N) for s being State of S,l being
Element of NAT,k holds s halts_at l iff Comput(ProgramPart s,s,k) halts_at l
proof
  let S be steady-programmed IC-Ins-separated definite halting (non empty
  stored-program AMI-Struct over N), s be State of S, l be
  Element of NAT,k;
  hereby
    assume
    s halts_at l;
    then s.l = halt S by Def42;
    then Comput(ProgramPart s,s,k).l = halt S by Th54;
    hence Comput(ProgramPart s,s,k) halts_at l by Def42;
  end;
  assume
  Comput(ProgramPart s,s,k).l = halt S;
  hence s.l = halt S by Th54;
end;

theorem
  for S being definite IC-Ins-separated
   (non empty stored-program AMI-Struct over N),
      l being Nat,
      p being l-started PartState of S
  for s being PartState of S st p c= s holds s is l-started
proof
  let S be definite IC-Ins-separated
   (non empty stored-program AMI-Struct over N),
      l be Nat,
      p be l-started PartState of S;
A1: IC S in dom p by Def41;
A2: IC p = l by Def41;
  let s be PartState of S;
  assume
Z:  p c= s;
   then dom p c= dom s by RELAT_1:25;
  hence IC S in dom s by A1;
  thus IC s = l by Z,A2,A1,GRFUNC_1:8;
end;

definition
  let N;
  let S be definite IC-Ins-separated (non empty stored-program AMI-Struct over
  N);
  let l be Element of NAT, I be Element of the Instructions of S;
  redefine func l .--> I -> NAT-defined FinPartState of S;
  coherence
  proof
X:  l in NAT;
    NAT c= the carrier of S by Def3;
    then reconsider la = l as Object of S by X;
    (the Object-Kind of S).l = the Instructions of S by Def14;
    then reconsider L = la .--> I as FinPartState of S by Th59;
    l in NAT & dom L = {l} by FUNCOP_1:19;
    hence thesis by RELAT_1:def 18;
  end;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let s be State of S such that
A1: p halts_on s;
  func LifeSpan(p,s) -> Element of NAT means
:Def46:
  CurInstr(p,Comput(p,s,it)) = halt S &
  for k being Element of NAT st
   CurInstr(p,Comput(p,s,k)) = halt S
  holds it <= k;
  existence
  proof
    defpred X[Nat] means
     CurInstr(p,Comput(p,s,$1))=halt S;
    consider k being Nat such that IC Comput(p,s,k) in dom p and
W:   CurInstr(p, Comput(p,s,k)) = halt S by A1,Def20;
A2: ex k being Nat st X[k] by W;
    consider k being Nat such that
A3: X[k] & for n being Nat st X[n] holds k <= n from NAT_1:sch 5(A2);
    reconsider k as Element of NAT by ORDINAL1:def 13;
    take k;
    thus thesis by A3;
  end;
  uniqueness
  proof
    let it1, it2 be Element of NAT;
    assume
A4: not thesis;
    then it1 <= it2 & it2 <= it1;
    hence contradiction by A4,XXREAL_0:1;
  end;
end;

theorem
  for N being non empty with_non-empty_elements set,
      S be IC-Ins-separated definite halting steady-programmed
       (non empty stored-program AMI-Struct over N),
      p being NAT-defined (the Instructions of S)-valued Function,
      s being State of S, m being Element of NAT
   holds p halts_on s iff p halts_on Comput(p,s,m)
proof
  let N be non empty with_non-empty_elements set;
  let S be IC-Ins-separated definite halting steady-programmed
   (non empty stored-program
  AMI-Struct over N),
  p be NAT-defined (the Instructions of S)-valued Function,
  s be State of S, m be Element of NAT;
  hereby
    assume
    p halts_on s;
    then consider n being Nat such that
W0:  IC Comput(p,s,n) in dom p and
W:   CurInstr(p, Comput(p,s,n)) = halt S by Def20;
    reconsider n as Element of NAT by ORDINAL1:def 13;
A1: CurInstr(p,Comput(p,s,n)) = halt S by W;
    per cases;
    suppose
      n <= m;
      then
       Comput(p,s,n) = Comput(p,s,m+0) by A1,Th52
        .= Comput(p,Comput(p,s,m),0) by Th51;
      hence p halts_on Comput(p,s,m) by Def20,W,W0;
    end;
    suppose
      n >= m;
      then reconsider k = n - m as Element of NAT by INT_1:18;
      Comput(p,Comput(p,s,m),k)
         = Comput(p,s,m+k) by Th51
        .= Comput(p,s,n);
     hence p halts_on Comput(p,s,m)
      by Def20,W0,W;
    end;
  end;
  given n being Nat such that
W1: IC Comput(p, Comput(p,s,m),n) in dom p and
W2: CurInstr(p, Comput(p,Comput(p,s,m),n)) = halt S;
   reconsider nn=n as Element of NAT by ORDINAL1:def 13;
  take m+nn;
  thus IC Comput(p,s,m+nn) in dom p &
   CurInstr(p, Comput(p,s,m+nn)) = halt S by W1,W2,Th51;
end;

reserve N for with_non-empty_elements non empty set,
  S for IC-Ins-separated (non empty
  AMI-Struct over N);

theorem Th94:
  for N being with_non-empty_elements set,
      S being non empty AMI-Struct over N
  for s being State of S holds IC S in dom s by L94;

theorem
  for s being State of S holds Start-At(IC s,S) = s | {IC S}
proof
  let s be State of S;
A1: IC S in dom s by Th94;
  thus Start-At(IC s,S) = {[IC S,s.IC S]} by FUNCT_4:87
    .= s | {IC S} by A1,GRFUNC_1:89;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let p be NAT-defined FinPartState of S, loc be set;
  assume
A1: loc in dom p;
  func pi (p, loc) -> Instruction of S equals
  p.loc;
  coherence
  proof
    dom p c= NAT by RELAT_1:def 18;
    then reconsider loc as Element of NAT by A1;
    consider s be State of S such that
A2: p c= s by PBOOLE:156;
    s.loc = p.loc by A1,A2,GRFUNC_1:8;
    hence thesis;
  end;
end;

registration
  let N be with_non-empty_elements set;
  let S be AMI-Struct over N;
  let p be FinPartState of S;
  cluster ProgramPart p -> finite;
  coherence;
end;

registration
  let N be with_non-empty_elements set;
  let S be AMI-Struct over N;
  let p be PartState of S;
  cluster ProgramPart p -> NAT-defined;
  coherence;
end;

definition
  let N be set;
  let S be non empty AMI-Struct over N;
  let p be PartState of S;
canceled 2;
  func DataPart p -> PartState of S equals
  p | Data-Locations S;
  coherence;
  projectivity by RELAT_1:101;
end;

registration
  let N be set;
  let S be non empty AMI-Struct over N;
  let p be FinPartState of S;
  cluster DataPart p -> finite;
  coherence;
end;

definition
  let N be set, S be non empty AMI-Struct over N;
  let IT be PartState of S;
  attr IT is data-only means
:Def50:
  dom IT misses {IC S} \/ NAT;
end;

registration
  let N be set, S be non empty AMI-Struct over N;
  cluster data-only FinPartState of S;
  existence
  proof
    consider p being FinPartState of S;
    {} c= p by XBOOLE_1:2;
    then reconsider p = {} as FinPartState of S;
    take p;
    thus dom p misses {IC S} \/ NAT by RELAT_1:60,XBOOLE_1:65;
  end;
end;

canceled 3;

theorem
  for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for p being FinPartState of S, s being
  State of S st p c= s for i being Element of NAT holds ProgramPart p c=
  Comput(ProgramPart s,s,i)
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let p be FinPartState of S, s be State of S such that
A1: p c= s;
  let i be Element of NAT;
  ProgramPart p c= p by RELAT_1:88;
  then ProgramPart p c= s by A1,XBOOLE_1:1;
  hence thesis by Th81;
end;

theorem Th100:
  for N being set, S being non empty AMI-Struct over N for
  p being FinPartState of S holds not IC S in dom DataPart p
proof
  let N be set, S be non empty AMI-Struct over N;
  let p be FinPartState of S;
  assume
A1: IC S in dom (DataPart p);
  dom(DataPart p) c= ((the carrier of S) \ ({IC S} \/ NAT)) by RELAT_1:87;
  then not IC S in {IC S} \/ NAT by A1,XBOOLE_0:def 5;
  then not IC S in {IC S} by XBOOLE_0:def 3;
  hence contradiction by TARSKI:def 1;
end;

theorem Th101:
  for S being IC-Ins-separated definite realistic (non empty
stored-program AMI-Struct over N) for p being FinPartState of S holds not IC
  S in dom (ProgramPart p)
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  AMI-Struct over N);
  let p be FinPartState of S;
  assume
A1: IC S in dom (ProgramPart p);
  dom(ProgramPart p) c= NAT by RELAT_1:87;
  then reconsider l = IC S as Element of NAT by A1;
  not l in dom ProgramPart p by Def21;
  hence contradiction by Def21;
end;

theorem
  for N being set, S being non empty AMI-Struct over N for p being
  FinPartState of S holds {IC S} misses dom DataPart p by Th100,ZFMISC_1:56;

theorem
  for S being IC-Ins-separated definite realistic (non empty
stored-program AMI-Struct over N) for p being FinPartState of S holds {IC S}
  misses dom (ProgramPart p) by Th101,ZFMISC_1:56;

theorem Th104:
  for p,q being FinPartState of S holds dom DataPart p misses dom
  ProgramPart q
proof
  let p,q be FinPartState of S;
  ((the carrier of S) \ ({IC S} \/ NAT)) c= (the carrier of S) \ NAT & dom(
DataPart p) c= ((the carrier of S) \ ({IC S} \/ NAT))
 by RELAT_1:87,XBOOLE_1:7,34;
  then
A1: dom(DataPart p) c= (the carrier of S) \ NAT by XBOOLE_1:1;
  dom ProgramPart q c= NAT by RELAT_1:87;
  hence thesis by A1,XBOOLE_1:64,79;
end;

theorem Th105:
  for p being NAT-defined FinPartState of S holds ProgramPart p = p
proof
  let p be NAT-defined FinPartState of S;
A1: dom p c= dom ProgramPart p
  proof
    let x be set;
A2: dom ProgramPart p = dom p /\ NAT & dom p c= NAT by RELAT_1:90,def 18;
    assume
    x in dom p;
    hence thesis by A2,XBOOLE_0:def 4;
  end;
  ProgramPart p c= p by RELAT_1:88;
  then dom ProgramPart p c= dom p by GRFUNC_1:8;
  then dom ProgramPart p = dom p by A1,XBOOLE_0:def 10;
  hence thesis by GRFUNC_1:9,RELAT_1:88;
end;

theorem
  for p being FinPartState of S, l being Element of NAT st l
  in dom p holds l in dom ProgramPart p
proof
  let p be FinPartState of S, l be Element of NAT;
A1: dom ProgramPart p = dom p /\ NAT by RELAT_1:90;
  assume
  l in dom p;
  hence thesis by A1,XBOOLE_0:def 4;
end;

theorem
  for p being data-only FinPartState of S, q being FinPartState of S
  holds p c= q iff p c= DataPart(q)
proof
  let p be data-only FinPartState of S, q be FinPartState of S;
  set X = (the carrier of S) \ ({IC S} \/ NAT);
A1: q|X c= q by RELAT_1:88;
  hereby
X:  X \/ ({IC S} \/ NAT) = (the carrier of S) \/ ({IC S} \/ NAT)
     by XBOOLE_1:39;
    dom p c= the carrier of S by RELAT_1:def 18;
    then
A2: dom p c= X \/ ({IC S} \/ NAT) by XBOOLE_1:10,X;
    assume
    p c= q;
    then
A3: p|X c= DataPart q by RELAT_1:105;
    dom p misses {IC S} \/ NAT by Def50;
    hence p c= DataPart q by A3,A2,RELAT_1:97,XBOOLE_1:73;
  end;
  assume
  p c= DataPart q;
  hence thesis by A1,XBOOLE_1:1;
end;

theorem
  for S being IC-Ins-separated definite realistic (non empty
  stored-program AMI-Struct over N) for p being FinPartState of S st IC S in
  dom p holds p = Start-At(IC p,S) +* ProgramPart p +* DataPart p
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  AMI-Struct over N);
  let p be FinPartState of S;
  assume IC S in dom p;
  then
A2: {IC S} is Subset of dom p by SUBSET_1:63;
A3: NAT c= the carrier of S by Def3;
A4: ({IC S} \/ (NAT) \/ ((the carrier of S) \ ({IC S} \/ NAT))) = ((the
  carrier of S) \/ ({IC S} \/ NAT)) by XBOOLE_1:39
    .= the carrier of S by A3,XBOOLE_1:8,12;
A5: dom p c= the carrier of S by RELAT_1:def 18;
A6: now
    let x be set;
    assume
A7: x in dom p;
    then
A8: x in {IC S} \/ (NAT) or x in (the carrier of S) \ ({IC S} \/ NAT) by A5,A4,
XBOOLE_0:def 3;
    per cases by A8,XBOOLE_0:def 3;
    suppose
A9:   x in {IC S};
      {IC S} = dom Start-At(IC p,S) by FUNCOP_1:19;
      then IC S in dom Start-At(IC p,S) by TARSKI:def 1;
      then
A10:  IC S in dom Start-At(IC p,S) \/ dom ProgramPart p by XBOOLE_0:def 3;
      then IC S in dom (Start-At(IC p,S) +* ProgramPart p) by FUNCT_4:def 1;
      then
A11:  IC S in dom (Start-At(IC p,S) +* ProgramPart p) \/ dom DataPart p by
XBOOLE_0:def 3;
A12:  not IC S in dom (ProgramPart p) by Th101;
A13:  x = IC S by A9,TARSKI:def 1;
      not IC S in dom (DataPart p) by Th100;
      then
      (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x = (Start-At(IC p,S)
      +* ProgramPart p).x by A13,A11,FUNCT_4:def 1
        .= (Start-At(IC p,S)).x by A13,A10,A12,FUNCT_4:def 1
        .= IC p by A13,FUNCOP_1:87
        .= p.IC S;
      hence p.x = (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x by A9,
TARSKI:def 1;
    end;
    suppose
      x in (the carrier of S) \ ({IC S} \/ NAT);
      then x in dom p /\ ((the carrier of S) \ ({IC S} \/ NAT)) by A7,
XBOOLE_0:def 4;
      then
A14:  x in dom (p | ((the carrier of S) \ ({IC S} \/ NAT))) by RELAT_1:90;
      then x in dom (Start-At(IC p,S) +* ProgramPart p) \/ dom (p | ((the
      carrier of S) \ ({IC S} \/ NAT))) by XBOOLE_0:def 3;
      then (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x = (p | ((the
      carrier of S) \ ({IC S} \/ NAT))).x by A14,FUNCT_4:def 1
        .= p.x by A14,FUNCT_1:70;
      hence p.x = (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x;
    end;
    suppose
      x in NAT;
      then x in dom p /\ NAT by A7,XBOOLE_0:def 4;
      then
A15:  x in dom (p | NAT) by RELAT_1:90;
      dom (DataPart p) misses dom (ProgramPart p) by Th104;
      then
A16:  not x in dom (DataPart p) by A15,XBOOLE_0:3;
A17:  x in dom (Start-At(IC p,S)) \/ dom (ProgramPart p) by A15,XBOOLE_0:def 3;
      then x in dom (Start-At(IC p,S) +* ProgramPart p) by FUNCT_4:def 1;
      then x in dom (Start-At(IC p,S) +* ProgramPart p) \/ dom (DataPart p) by
XBOOLE_0:def 3;
      then
      (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x = (Start-At(IC p,S)
      +* ProgramPart p).x by A16,FUNCT_4:def 1
        .= (p | NAT ).x by A15,A17,FUNCT_4:def 1
        .= p.x by A15,FUNCT_1:70;
      hence p.x = (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x;
    end;
  end;
X: dom p c= the carrier of S by RELAT_1:def 18;
  dom(Start-At(IC p,S) +* ProgramPart p +* DataPart p) = dom (Start-At(IC p
  ,S) +* ProgramPart p) \/ dom (DataPart p) by FUNCT_4:def 1
    .= dom (Start-At(IC p,S)) \/ dom (ProgramPart p) \/ dom (DataPart p) by
FUNCT_4:def 1
    .= {IC S} \/ dom (p | NAT) \/ dom(DataPart p) by FUNCOP_1:19
    .= dom p /\ {IC S} \/ dom (p|NAT) \/ dom(p|((the carrier of S) \ ({IC S}
  \/ NAT))) by A2,XBOOLE_1:28
    .= dom p /\ {IC S} \/ dom p /\ (NAT) \/ dom(p|((the carrier of S) \ ({IC
  S} \/ NAT))) by RELAT_1:90
    .= dom p /\ {IC S} \/ dom p /\ (NAT) \/ dom p /\ ((the carrier of S) \ ({
  IC S} \/ NAT)) by RELAT_1:90
    .= dom p /\ ({IC S} \/ (NAT)) \/ dom p /\ ((the carrier of S) \ ({IC S}
  \/ NAT)) by XBOOLE_1:23
    .= dom p /\ the carrier of S by A4,XBOOLE_1:23
    .= dom p by X,XBOOLE_1:28;
  hence thesis by A6,FUNCT_1:9;
end;

definition
  let N,S;
  let IT be PartFunc of FinPartSt S,FinPartSt S;
  attr IT is data-only means
  for p being FinPartState of S st p in dom IT
  holds p is data-only & for q being FinPartState of S st q = IT.p holds q is
  data-only;
end;

theorem
  for S being IC-Ins-separated definite realistic (non empty
  stored-program AMI-Struct over N) for p being FinPartState of S st IC S in
  dom p holds p is not NAT-defined
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  AMI-Struct over N);
  let p be FinPartState of S;
  assume
A1: IC S in dom p;
  assume
  p is NAT-defined;
  then dom p = dom ProgramPart p by Th105;
  hence contradiction by A1,Th101;
end;

theorem
  for p being FinPartState of S st IC S in dom p holds Start-At (IC p,S)
  c= p
proof
  let p be FinPartState of S;
  assume IC S in dom p;
  then [IC S, p.IC S] in p by FUNCT_1:8;
  then {[IC S, p.IC S]} c= p by ZFMISC_1:37;
  hence thesis by ZFMISC_1:35;
end;

theorem
  for s being State of S, iloc being Element of NAT holds IC
  (s +* Start-At(iloc,S)) = iloc
proof
  let s be State of S, iloc be Element of NAT;
A1: IC S in {IC S} by TARSKI:def 1;
  then dom (Start-At(iloc,S)) = {IC S} & IC S in dom s \/ {IC S} by FUNCOP_1:19
,XBOOLE_0:def 3;
  hence IC (s +* Start-At(iloc,S) ) = (Start-At(iloc,S)).IC S
   by A1,FUNCT_4:def 1
    .= iloc by FUNCOP_1:87;
end;

theorem
  for S being IC-Ins-separated definite realistic (non empty
  stored-program AMI-Struct over N) for s being State of S, iloc being
Element of NAT, a being Element of NAT holds s.a = (s +*
  Start-At(iloc,S)).a
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  AMI-Struct over N);
  let s be State of S, iloc be Element of NAT, a be
  Element of NAT;
X: a in NAT;
  NAT c= the carrier of S by Def3;
  then a in the carrier of S by X;
  then a in dom s by PARTFUN1:def 4;
  then
A1: dom (Start-At(iloc,S)) = {IC S} & a in dom s \/ dom (Start-At(iloc,S)) by
FUNCOP_1:19,XBOOLE_0:def 3;
  a <> IC S by Def21;
  then not a in {IC S} by TARSKI:def 1;
  hence thesis by A1,FUNCT_4:def 1;
end;

canceled;

theorem
  for N being with_non-empty_elements set, S
being stored-program AMI-Struct over N, s being State of S holds NAT c= dom s
proof
  let N be with_non-empty_elements set, S be
  stored-program AMI-Struct over N;
  let s be State of S;
  dom s = the carrier of S by PARTFUN1:def 4;
  hence thesis by Def3;
end;

theorem
  for N being with_non-empty_elements set, S being IC-Ins-separated (non
  empty stored-program AMI-Struct over N), s being State of S holds IC s in
  dom s
proof
  let N be with_non-empty_elements set, S be IC-Ins-separated (non empty
  stored-program AMI-Struct over N);
  let s be State of S;
X:      IC s in NAT;
        NAT c= the carrier of S by Def3;
        then IC s in the carrier of S by X;
  hence thesis by PARTFUN1:def 4;
end;

theorem
  for N being with_non-empty_elements set, S being non empty
  stored-program AMI-Struct over N, s being State of S, l being
  Element of NAT holds l in dom s
proof
  let N be with_non-empty_elements set, S be non empty stored-program
  AMI-Struct over N;
  let s be State of S, l be Element of NAT;
X:      l in NAT;
        NAT c= the carrier of S by Def3;
        then l in the carrier of S by X;
  hence thesis by PARTFUN1:def 4;
end;

theorem
  for N being with_non-empty_elements set for S being
  steady-programmed (non empty stored-program AMI-Struct over N) for i being
  Instruction of S, s being State of S holds Exec (i, s) | NAT = s | NAT
                 by L117;

registration
  let N be set, S be AMI-Struct over N;
  cluster NAT-defined FinPartState of S;
  existence
  proof
    reconsider z = {} as FinPartState of S by FUNCT_1:174,RELAT_1:206;
    take z;
    thus dom z c= NAT by RELAT_1:60,XBOOLE_1:2;
  end;
end;

theorem Th118:
  for N being with_non-empty_elements set, S being definite (non
empty stored-program AMI-Struct over N), p being NAT-defined FinPartState of
  S holds rng p c= the Instructions of S
proof
  let N be with_non-empty_elements set, S be definite (non empty
  stored-program AMI-Struct over N), p be NAT-defined FinPartState of S;
  let x be set;
  assume
  x in rng p;
  then consider y being set such that
A1: y in dom p and
A2: x = p.y by FUNCT_1:def 5;
  dom p c= NAT by RELAT_1:def 18;
  then reconsider y as Element of NAT by A1;
  (the Object-Kind of S).y = the Instructions of S by Def14;
  hence thesis by A1,A2,FUNCT_1:def 20;
end;

theorem
  for N being with_non-empty_elements set, S being definite (non empty
stored-program AMI-Struct over N), f being Function of the Instructions of S
, the Instructions of S, s being NAT-defined FinPartState of S holds dom(f*s) =
  dom s
proof
  let N be with_non-empty_elements set, S be definite (non empty
  stored-program AMI-Struct over N);
  let f be Function of the Instructions of S, the Instructions of S;
  let s be NAT-defined FinPartState of S;
  dom f = the Instructions of S by FUNCT_2:def 1;
  then rng s c= dom f by Th118;
  hence thesis by RELAT_1:46;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be definite (non empty stored-program AMI-Struct over N);
  let s be NAT-defined PartState of S;
  let f be Function of the Instructions of S, the Instructions of S;
  redefine func f*s -> NAT-defined PartState of S;
  coherence
  proof
A1: dom(f*s) c= NAT by RELAT_1:def 18;
A2: now
      let x be set;
A3:   rng(f*s) c= the Instructions of S by RELAT_1:def 19;
      assume
A4:   x in dom(f*s);
      then reconsider l = x as Element of NAT by A1;
A5:   (the Object-Kind of S).l = the Instructions of S by Def14;
      (f*s).x in rng(f*s) by A4,FUNCT_1:def 5;
      hence (f*s).x in (the Object-Kind of S).x by A3,A5;
    end;
    reconsider fs = f*s as PartState of S by A2,FUNCT_1:def 20;

    fs is NAT-defined;
    hence thesis;
  end;
end;

theorem
  for N being with_non-empty_elements set,
   A being AMI-Struct over N, s being State of A,
  I being NAT-defined FinPartState of A holds s,s+*I equal_outside NAT
proof
  let N be with_non-empty_elements set, A be AMI-Struct over N,
  s be State of A,
  I be NAT-defined
  FinPartState of A;
  dom I c= NAT by RELAT_1:def 18;
  hence thesis by FUNCT_7:31;
end;

theorem
  for N being with_non-empty_elements non empty set, S being realistic
  IC-Ins-separated (non empty AMI-Struct over N), s1, s2 being State of S
  holds s1,s2 equal_outside NAT implies IC s1 = IC s2
proof
  let N be with_non-empty_elements non empty set,
      S be realistic IC-Ins-separated (non
  empty AMI-Struct over N), s1, s2 be State of S;
  assume
A1: s1,s2 equal_outside NAT;
A2: not IC S in NAT by Def21;
  IC S in dom s2 by Th94;
  then IC S in dom s2 \ NAT by A2,XBOOLE_0:def 5;
  then
A3: IC S in dom s2 /\ (dom s2 \ NAT) by XBOOLE_0:def 4;
  IC S in dom s1 by Th94;
  then IC S in dom s1 \ NAT by A2,XBOOLE_0:def 5;
  then IC S in dom s1 /\ (dom s1 \ NAT) by XBOOLE_0:def 4;
  hence IC s1 = (s1|(dom s1 \ NAT)).IC S by FUNCT_1:71
    .= (s2|(dom s2 \ NAT)).IC S by A1,FUNCT_7:def 2
    .= IC s2 by A3,FUNCT_1:71;
end;

reserve m,n for Element of NAT;

theorem
  for S being halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N),
   p being NAT-defined (the Instructions of S)-valued Function,
   s being State of S
  st p halts_on s
 holds Result(p,s) = Comput(p,s,LifeSpan(p,s))
proof
  let S be halting IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let s be State of S;
  assume
A1: p halts_on s;
  then
A2: CurInstr(p,Comput(p,s,LifeSpan(p,s))) = halt S by Def46;
  consider m such that
A3: Result(p,s) = Comput(p,s,m) and
A4: CurInstr(p, Result(p,s)) = halt S by A1,Def22;
  LifeSpan(p,s) <= m by A1,A3,A4,Def46;
  hence thesis by A2,A3,Th52;
end;

definition
  let N be with_non-empty_elements set;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let s be State of S, l be Element of NAT, i be Instruction of S;
  redefine func s+*(l,i) -> State of S;
  coherence
  proof
    now
      let x be set;
      assume
A3:   x in dom(s+*(l,i));
B3:   x in dom s by A3,FUNCT_7:32;
      per cases;
      suppose
A4:     x = l;
        then
A5:     (the Object-Kind of S).x = the Instructions of S by Def14;
X:      l in NAT;
        NAT c= the carrier of S by Def3;
        then l in the carrier of S by X;
        then l in dom s by PARTFUN1:def 4;
        then (s+*(l,i)).x = i by A4,FUNCT_7:33;
        hence (s+*(l,i)).x in (the Object-Kind of S).x by A5;
      end;
      suppose
        x <> l;
        then (s+*(l,i)).x = s.x by FUNCT_7:34;
        hence (s+*(l,i)).x in (the Object-Kind of S).x by B3,FUNCT_1:def 20;
      end;
    end;
    hence thesis by FUNCT_1:def 20;
  end;
end;

theorem
  for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for s being State of S, n holds s|NAT = (
  Comput(ProgramPart s,s,n))|NAT by LmA;

theorem
  for N being with_non-empty_elements non empty set,
  S being steady-programmed
  IC-Ins-separated definite (non empty stored-program AMI-Struct over N), p
being NAT-defined FinPartState of S, s1,s2 being State of S
 st p c= s1 & p c= s2
  holds Comput(ProgramPart s1,s1,i) | dom p
   = Comput(ProgramPart s2,s2,i) | dom p
proof
  let N be with_non-empty_elements non empty set,
  S be steady-programmed
IC-Ins-separated definite (non empty stored-program AMI-Struct over N), p be
  NAT-defined FinPartState of S, s1,s2 be State of S such that
A1: p c= s1 and
A2: p c= s2;
  set Cs2= Comput(ProgramPart s2,s2,i);
  set Cs1= Comput(ProgramPart s1,s1,i);
A3: now
    let x be set;
    assume
A4: x in dom p;
    dom p c= NAT by RELAT_1:def 18;
    then reconsider l=x as Element of NAT by A4;
A5: s1.l = Cs1.l & s2.l = Cs2.l by Th54;
    p.x=s1.x by A1,A4,GRFUNC_1:8;
    hence Cs1.x = Cs2.x by A2,A4,A5,GRFUNC_1:8;
  end;
  dom Cs1 = the carrier of S by PARTFUN1:def 4
    .=dom Cs2 by PARTFUN1:def 4;
  hence thesis by A3,FUNCT_1:166;
end;

theorem
  for S being AMI-Struct over N, p being Element of FinPartSt S holds
  p is FinPartState of S
proof
  let S be AMI-Struct over N;
  let p be Element of FinPartSt S;
  p in FinPartSt S;
  then ex q being Element of sproduct the Object-Kind of S st q = p & q is
  finite;
  hence thesis;
end;

:: from SCMFSA8A, 2008.02.12, A.T.

theorem
  for N being with_non-empty_elements non empty set, S
  being definite (non empty stored-program AMI-Struct over N), I being NAT
  -defined FinPartState of S, x being set holds x in dom I implies I.x is
  Instruction of S
proof
  let N be with_non-empty_elements non empty set,
  S be definite (non empty
  stored-program AMI-Struct over N);
  let I be NAT-defined FinPartState of S;
  let x be set;
  assume
A1: x in dom I;
  dom I c= NAT by RELAT_1:def 18;
  then reconsider ll = x as Element of NAT by A1;
   ((the State of S) +* I).ll = I.x by A1,FUNCT_4:14;
  hence thesis;
end;

:: from SCMFSA9A, 2008.02.12, A.T.

theorem
  for N being non empty with_non-empty_elements set,
  S being halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N),
  s being State of S, k being Element of NAT
   st CurInstr(ProgramPart s,Comput(ProgramPart s,s,k)) = halt S
 holds Comput(ProgramPart s,s,LifeSpan(ProgramPart(s),s))
  = Comput(ProgramPart s,s,k)
proof
  let N be non empty with_non-empty_elements set, S be halting
IC-Ins-separated definite steady-programmed
 (non empty stored-program AMI-Struct over N), s be
  State of S, k be Element of NAT such that
A1: CurInstr(ProgramPart s,Comput(ProgramPart s,s,k)) = halt S;
  IC Comput(ProgramPart s,s,k) in NAT;
  then
X: IC Comput(ProgramPart s,s,k) in dom ProgramPart s by LmU;
A2: ProgramPart s halts_on s by Def20,X,A1;
  set Ls = LifeSpan(ProgramPart(s),s);
A3: CurInstr(ProgramPart s,Comput(ProgramPart s,s,Ls))
 = halt S by A2,Def46;
  Ls <= k by A1,A2,Def46;
  hence thesis by A3,Th52;
end;

:: from SCMISORT, 2008.02.12, A.T.

theorem
 for N being non empty with_non-empty_elements set
 for S being halting IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N)
  for p being NAT-defined (the Instructions of S)-valued Function
 for s being State of S st LifeSpan(p,s) <= j & p halts_on s
   holds Comput(p,s,j) = Comput(p,s,LifeSpan(p,s))
proof
  let N be non empty with_non-empty_elements set,
  S be halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N),
  p being NAT-defined (the Instructions of S)-valued Function,
  s be State of S;
  assume that
A1: LifeSpan(p,s) <= j and
A2: p halts_on s;
  CurInstr(p,Comput(p,s,LifeSpan(p,s))) = halt S by A2,Def46;
  hence thesis by A1,Th52;
end;

:: from AMI_6, 2008.02.12, A.T.

theorem
  for N being with_non-empty_elements non empty set,
      S being realistic IC-Ins-separated definite steady-programmed
       (non empty stored-program AMI-Struct over N),
      t, u being State of S,
      e being Element of NAT,
      I being Instruction of S st u = t+*((IC S, e)-->(e, I))
    holds u.e = I & IC u = e &
     IC Following(ProgramPart u,u) = Exec(u.IC u, u).IC S
proof

 let N be with_non-empty_elements non empty set,
     S be realistic IC-Ins-separated definite steady-programmed
      (non empty stored-program AMI-Struct over N),
     t, u be State of S,
     e be Element of NAT,
     I be Instruction of S such that
A2: u = t+*((IC S, e)-->(e, I));
A3: dom ((IC S, e)-->(e, I)) = {IC S, e} by FUNCT_4:65;
  then e in dom ((IC S, e)-->(e, I)) by TARSKI:def 2;
  hence u.e = ((IC S, e)-->(e, I)).e by A2,FUNCT_4:14
    .= I by FUNCT_4:66;
   reconsider il = e as Element of NAT;
X: IC S <> il by Def21;
Y:  (ProgramPart u)/.IC u
 = u.IC u by BWL1;
  IC S in dom ((IC S, e)-->(e, I)) by A3,TARSKI:def 2;
  hence IC u = ((IC S, e)-->(e, I)).IC S by A2,FUNCT_4:14
    .= e by FUNCT_4:66,X;
  thus thesis by Y;
end;

:: from SCMPDS_5, 2008.02.12, A.T.

theorem
  for S being halting IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N), s being State of S
   st s = Following(ProgramPart s,s)
  holds for n holds Comput(ProgramPart s,s,n) = s
proof
  let S be halting IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N), s be State of S;
  defpred X[Element of NAT] means Comput(ProgramPart s,s,$1) = s;
  assume
  s = Following(ProgramPart s,s);
  then
A1: for n st X[n] holds X[n+1] by Th14;
A2: X[ 0] by Th13;
  thus for n holds X[n] from NAT_1:sch 1(A2, A1);
end;

:: from SCMPDS_9, 2008.02.12, A.T.

theorem
  for N being with_non-empty_elements non empty set, S
being IC-Ins-separated definite steady-programmed
 (non empty stored-program AMI-Struct over N)
  , s being State of S, i being Instruction of S holds Exec(s.IC s,s).IC S = IC
  Following(ProgramPart s,s)
proof
  let N being with_non-empty_elements non empty set, S
being IC-Ins-separated definite steady-programmed
 (non empty stored-program AMI-Struct over N)
  , s being State of S, i being Instruction of S;
    (ProgramPart s)/.IC s
 = s.IC s by BWL1;
 hence Exec(s.IC s,s).IC S = IC Following(ProgramPart s,s);
end;

:: from SCMFSA6B, 2008.02.12, A.T.

theorem
  for N being with_non-empty_elements non empty set, S
being IC-Ins-separated definite (non empty stored-program AMI-Struct over N)
, s being State of S holds s = Following(ProgramPart s,s) implies
 for n holds Comput(ProgramPart s,s,n)
  = s
proof
  let N be with_non-empty_elements non empty set, S be
IC-Ins-separated definite (non empty stored-program AMI-Struct over N), s be
  State of S;
  defpred X[Nat] means Comput(ProgramPart s,s,$1) = s;
  assume
  s = Following(ProgramPart s,s);
  then
A1: for n st X[n] holds X[n+1] by Th14;
A2: X[ 0] by Th13;
  thus for n holds X[n] from NAT_1:sch 1(A2, A1);
end;

:: from SCMRING3, 2008.02.12, A.T.

theorem
  for N being with_non-empty_elements non empty set, S being realistic
IC-Ins-separated definite steady-programmed
 (non empty stored-program AMI-Struct over N), t, u
  being State of S, il being Element of NAT, e being Element of
ObjectKind IC S, I being Element of (the Object-Kind of S).il
 st e = il & u = t+*((IC S, il
)-->(e, I)) holds u.il = I & IC u = il & IC Following(ProgramPart u,u)
 = Exec(u.IC u, u).IC S
proof
  let N be with_non-empty_elements non empty set,
  S be realistic IC-Ins-separated
  definite steady-programmed
   (non empty stored-program AMI-Struct over N), t, u be State of S,
il be Element of NAT, e be Element of ObjectKind IC S, I be Element
  of (the Object-Kind of S).il such that
A1: e = il and
A2: u = t+*((IC S, il)-->(e, I));
A3: dom ((IC S, il)-->(e, I)) = {IC S, il} by FUNCT_4:65;
  then il in dom ((IC S, il)-->(e, I)) by TARSKI:def 2;
  hence u.il = ((IC S, il)-->(e, I)).il by A2,FUNCT_4:14
    .= I by FUNCT_4:66;
  IC S in dom ((IC S, il)-->(e, I)) by A3,TARSKI:def 2;
  hence IC u = ((IC S, il)-->(e, I)).IC S by A2,FUNCT_4:14
    .= il by A1,Th48,FUNCT_4:66;
    (ProgramPart u)/.IC u
 = u.IC u by BWL1;
  hence thesis;
end;

:: missing, 2008.03.26, A.T,

theorem Th134:
  for N being with_non-empty_elements non empty set
, S being IC-Ins-separated realistic (non empty AMI-Struct over N), l being
  Element of NAT holds dom Start-At(l,S) misses NAT
proof

  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated realistic (non empty AMI-Struct over N);
  let l be Element of NAT;
  dom Start-At(l,S) = {IC S} & not IC S in NAT by Def21,FUNCOP_1:19;
  hence thesis by ZFMISC_1:56;
end;

theorem
  for N being with_non-empty_elements non empty set, S
  being IC-Ins-separated realistic (non empty AMI-Struct over N), l being
  Element of NAT holds ProgramPart Start-At(l,S) = {}
proof

  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated realistic (non empty AMI-Struct over N);
  let l be Element of NAT;
  dom Start-At(l,S) misses NAT by Th134;
  hence thesis by RELAT_1:187;
end;

registration
  let N be set;
  let S be non empty AMI-Struct over N;
  let p be FinPartState of S;
  cluster DataPart p -> data-only;
  coherence
  proof
    ((the carrier of S) \ ({IC S} \/ NAT)) c= (the carrier of S) \ NAT & dom
( DataPart p) c= ((the carrier of S) \ ({IC S} \/ NAT))
 by RELAT_1:87,XBOOLE_1:7,34;
    then dom(DataPart p) c= (the carrier of S) \ NAT by XBOOLE_1:1;
    then
A1: dom DataPart p misses NAT by XBOOLE_1:64,79;
    dom DataPart p misses {IC S} by Th100,ZFMISC_1:56;
    hence dom DataPart p misses {IC S} \/ NAT by A1,XBOOLE_1:70;
  end;
end;

theorem
  for N being with_non-empty_elements set,
      S being non empty AMI-Struct over N, p be
  data-only FinPartState of S holds ProgramPart p = {}
proof
  let N be with_non-empty_elements set, S be non empty AMI-Struct over N,
      p be data-only
  FinPartState of S;
  dom p misses {IC S} \/ NAT by Def50;
  then dom p misses NAT by XBOOLE_1:70;
  hence thesis by RELAT_1:187;
end;

theorem
  for N being with_non-empty_elements non empty set, S
  being IC-Ins-separated realistic (non empty AMI-Struct over N), l,l1 being
  Element of NAT holds not l in dom Start-At(l1,S)
proof
  let N be with_non-empty_elements non empty set, S be
  IC-Ins-separated realistic (non empty AMI-Struct over N), l,l1 be
  Element of NAT;
  assume
  l in dom Start-At(l1,S);
  then NAT meets dom Start-At(l1,S) by XBOOLE_0:3;
  hence thesis by Th134;
end;

theorem
  for N being with_non-empty_elements non empty set, S
  being IC-Ins-separated (non empty AMI-Struct over N), l being
  Element of NAT holds DataPart Start-At(l,S) = {}
proof
  let N be with_non-empty_elements non empty set, S be
IC-Ins-separated (non empty AMI-Struct over N), l be Element of NAT;
  Data-Locations S misses {IC S} \/ NAT by XBOOLE_1:79;
  then Data-Locations S misses {IC S} by XBOOLE_1:70;
  then Data-Locations S misses dom Start-At(l,S) by FUNCOP_1:19;
  hence thesis by RELAT_1:95;
end;

theorem Th139:
  for S being non empty AMI-Struct over N, p being PartState
  of S holds p is data-only iff dom p c= Data-Locations S
proof
  let S be non empty AMI-Struct over N, p be PartState of S;
  thus p is data-only implies dom p c= Data-Locations S
  proof
X: dom p c= the carrier of S by RELAT_1:def 18;
    assume dom p misses {IC S} \/ NAT;
    hence thesis by X,XBOOLE_1:86;
  end;
  assume
  dom p c= Data-Locations S;
  hence dom p misses {IC S} \/ NAT by XBOOLE_1:106;
end;

theorem
  for S being IC-Ins-separated definite realistic (non empty
  stored-program AMI-Struct over N), s be State of S for X being set st X c=
  NAT holds rng(s|X) c= the Instructions of S
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  AMI-Struct over N);
  let s be State of S;
  let X be set such that
A1: X c= NAT;
  let x be set;
  assume
  x in rng(s|X);
  then consider y being set such that
A2: y in dom(s|X) and
A3: (s|X).y = x by FUNCT_1:def 5;
A4: dom(s|X) c= X by RELAT_1:87;
  then dom(s|X) c= NAT by A1,XBOOLE_1:1;
  then reconsider y as Element of NAT by A2;
  x = s.y by A2,A3,A4,FUNCT_1:72;
  hence thesis;
end;

:: from SCMFSA8B, 2008.04.30, A.T.

theorem
  for s being State of S, l1,l2 being Element of NAT holds s
  +* Start-At(l1,S) +* Start-At(l2,S) = s +* Start-At(l2,S)
proof
  let s be State of S;
  let l1,l2 be Element of NAT;
A1: dom Start-At(l1,S) = {IC S} by FUNCOP_1:19
    .= dom Start-At(l2,S) by FUNCOP_1:19;
  thus s +* Start-At(l1,S) +* Start-At(l2,S)
   = s +* (Start-At(l1,S) +* Start-At(l2,S)) by
FUNCT_4:15
    .= s +* Start-At(l2,S) by A1,FUNCT_4:20;
end;

:: missing, 2008.05.01, A.T.

theorem
  for S being non empty AMI-Struct over N, p being PartState of S
  holds p is data-only iff DataPart p = p
proof
  let S be non empty AMI-Struct over N, p be PartState of S;
  thus p is data-only implies DataPart p = p
  proof
    assume
    p is data-only;
    then dom p c= Data-Locations S by Th139;
    hence thesis by RELAT_1:97;
  end;
  assume
  DataPart p = p;
  then dom p c= Data-Locations S by RELAT_1:87;
  hence thesis by Th139;
end;

theorem
 for N being with_non-empty_elements set for S being
  steady-programmed (non empty stored-program AMI-Struct over N)
   for s being State of S
   holds dom ProgramPart s = NAT by LmU;

theorem
 for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for s being State of S, k
 holds ProgramPart s = ProgramPart Comput(ProgramPart s,s,k) by LmY;

theorem
 for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for s being State of S, k
 holds (ProgramPart s)/.IC Comput(ProgramPart s,s,k)
  = CurInstr(ProgramPart Comput(ProgramPart s,s,k),Comput(ProgramPart s,s,k))
   by LmX;

theorem
 for S being steady-programmed IC-Ins-separated definite halting
  (non empty stored-program AMI-Struct over N)
   for s being State of S holds ProgramPart s halts_on s
   iff ex k st CurInstr(ProgramPart s,Comput(ProgramPart s,s,k)) = halt S
proof
 let S be steady-programmed IC-Ins-separated definite halting
  (non empty stored-program AMI-Struct over N);
 let s be State of S;
 thus ProgramPart s halts_on s
   implies ex k st CurInstr(ProgramPart s,Comput(ProgramPart s,s,k))
    = halt S
  proof
   given k being Nat such that
    IC Comput(ProgramPart s,s,k) in dom ProgramPart s and
G2: CurInstr(ProgramPart s, Comput(ProgramPart s,s,k)) = halt S;
   take k;
   thus k is Element of NAT by ORDINAL1:def 13;
   thus CurInstr(ProgramPart s,Comput(ProgramPart s,s,k)) = halt S
    by G2;
  end;
 given k such that
G: CurInstr(ProgramPart s,Comput(ProgramPart s,s,k)) = halt S;
 take k;
  IC Comput(ProgramPart s,s,k) in NAT;
 hence IC Comput(ProgramPart s,s,k) in dom ProgramPart s by LmU;
 thus CurInstr(ProgramPart s, Comput(ProgramPart s,s,k)) = halt S by G;
end;

theorem
 for N being with_non-empty_elements set,
     S be AMI-Struct over N
 for p being FinPartState of S holds p in FinPartSt S by LMT;

theorem   :: temporary
 for N being with_non-empty_elements set,
     S be definite (non empty stored-program AMI-Struct over N),
     f being NAT-defined (the Instructions of S)-valued Function
     holds f is PartState of S
proof
 let N be with_non-empty_elements set,
     S be definite (non empty stored-program AMI-Struct over N),
     f be NAT-defined (the Instructions of S)-valued Function;
B: dom f c= NAT by RELAT_1:def 18;
   NAT c= the carrier of S by Def3;
   then
A: dom f c= the carrier of S by B,XBOOLE_1:1;
  for x holds x in dom f implies f.x in (the Object-Kind of S).x
   proof let x;
    assume
Z:    x in dom f;
      then reconsider x as Element of NAT by B;
     f.x in the Instructions of S by Z,FUNCT_1:172;
    hence thesis by Def14;
   end;
 hence f is PartState of S by A,RELAT_1:def 18, FUNCT_1:def 20;
end;

theorem :: to be removed
 for N being with_non-empty_elements set,
     S be definite IC-Ins-separated realistic
      (non empty stored-program AMI-Struct over N),
     n be Nat, i be Instruction of S
 holds (IC S,n) --> (n,i) is PartState of S
 proof
  let N be with_non-empty_elements set,
     S be definite IC-Ins-separated realistic
      (non empty stored-program AMI-Struct over N),
     n be Nat, i be Instruction of S;
  set p = (IC S,n) --> (n,i);
y: n in NAT by ORDINAL1:def 13;
Y:  NAT c= the carrier of S by Def3;
U: dom p = {IC S,n} by FUNCT_4:65;
V: IC S <> n by y,Def21;
A: p is (the carrier of S)-defined
   proof
    thus dom p c= the carrier of S by Y,ZFMISC_1:38,U,y;
   end;
  p is (the Object-Kind of S)-compatible
   proof let x be set;
    assume
Z:   x in dom p;
    per cases by Z,U,TARSKI:def 2;
    suppose
S:   x = IC S;
     then
I:   p.x = n by V,FUNCT_4:66;
     ObjectKind IC S = NAT by Def11;
    hence p.x in (the Object-Kind of S).x by I,ORDINAL1:def 13,S;
    end;
    suppose
S:   x = n;
     then
I:    p.x = i by FUNCT_4:66;
     (the Object-Kind of S).x = the Instructions of S by Def14,S,y;
    hence p.x in (the Object-Kind of S).x by I;
    end;
   end;
 hence (IC S,n) --> (n,i) is PartState of S by A;
 end;

reserve S for IC-Ins-separated definite (non empty stored-program AMI-Struct
  over N),
  s for State of S;

theorem
 for N being with_non-empty_elements non empty set
 for S being
  IC-Ins-separated definite
  steady-programmed (non empty stored-program AMI-Struct over N)
   for s being State of S
 for i being natural number holds
 (ProgramPart s)/.i = s.i by BWL1;

theorem
 for N being with_non-empty_elements non empty set
 for S being
  IC-Ins-separated definite
  steady-programmed (non empty stored-program AMI-Struct over N)
   for s1,s2 being State of S
 holds ProgramPart(s1+*DataPart s2) = ProgramPart s1
proof
 let N be with_non-empty_elements non empty set;
 let S be IC-Ins-separated definite steady-programmed
     (non empty stored-program AMI-Struct over N);
 let s1,s2 be State of S;
   NAT c= {IC S} \/ NAT by XBOOLE_1:7;
   then
   Data-Locations S misses NAT by XBOOLE_1:85;
   then
X: ProgramPart(DataPart s2) = {} by RELAT_1:207;
 thus ProgramPart(s1+*DataPart s2)
       = ProgramPart s1+*ProgramPart(DataPart s2) by FUNCT_4:75
      .= ProgramPart s1 by X,FUNCT_4:22;
end;
