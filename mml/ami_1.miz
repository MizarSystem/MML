:: A Mathematical Model of CPU
::  by Yatsuka Nakamura and Andrzej Trybulec
::
:: Received October 14, 1992
:: Copyright (c) 1992 Association of Mizar Users

environ

 vocabularies BOOLE, FUNCT_2, FUNCT_1, RELAT_1, FUNCOP_1, CAT_1, FUNCT_4,
      CARD_3, TARSKI, PARTFUN1, FINSET_1, AMI_1, NEWTON, AMI_5, MCART_1,
      AMISTD_2, FINSEQ_1, FINSEQ_4, GRAPH_2, TREES_2, ORDINAL1, ARYTM, AMI_3,
      SCM_1, FUNCT_7, ARYTM_1, SCMFSA7B, SCMNORM, ORDINAL2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, MCART_1, SUBSET_1, SETFAM_1, ORDINAL1,
      NUMBERS, FUNCT_7, CARD_3, XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2,
      FINSET_1, NAT_1, FUNCOP_1, FUNCT_4, FINSEQ_1, FINSEQ_4, GRAPH_2,
      DOMAIN_1, TREES_2, PRE_POLY, STRUCT_0, XXREAL_0;
 constructors SETFAM_1, PARTFUN1, DOMAIN_1, FUNCT_4, XXREAL_0, NAT_1, FUNCT_7,
      SEQ_1, INT_1, CARD_3, STRUCT_0, FINSEQ_4, GRAPH_2, TREES_2, RELSET_1,
      PRE_POLY;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCT_2,
      FUNCOP_1, FUNCT_4, FINSET_1, XREAL_0, FINSEQ_1, CARD_3, STRUCT_0, INT_1,
      RELSET_1;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, STRUCT_0, XBOOLE_0, FUNCOP_1, ORDINAL1, RELAT_1;
 theorems ZFMISC_1, FUNCT_2, TARSKI, NAT_1, CQC_LANG, CARD_3, FINSEQ_1,
      FUNCT_4, FUNCOP_1, FINSET_1, FUNCT_1, GRFUNC_1, RELAT_1, RELSET_1,
      XBOOLE_0, XBOOLE_1, ORDINAL1, MCART_1, ENUMSET1, SUBSET_1, XXREAL_0,
      FUNCT_7, INT_1;
 schemes NAT_1, FRAENKEL, FUNCT_1;

begin :: General concepts

definition
  let N be set;
  struct (1-sorted) AMI-Struct over N (# carrier -> set,
Instruction-Counter -> Element of the carrier, Instructions -> non empty set,
    Object-Kind -> Function of the carrier, N \/ { the Instructions, NAT },
    Execution -> Function of the Instructions, Funcs(product the Object-Kind,
    product the Object-Kind) #);
end;

definition
  let N be set;
  canceled;
  func Trivial-AMI N -> strict AMI-Struct over N means
  :Def2:
  the carrier of it = succ NAT & the Instruction-Counter of it = NAT &
  the Instructions of it = {[0,{}]} &
  the Object-Kind of it = (NAT --> {[0,{}]}) +* (NAT .--> NAT) &
  the Execution of it
    = [0,{}] .--> id product((NAT --> {[0,{}]}) +* (NAT .--> NAT));
  existence
  proof
    reconsider I = {[0,{}]} as non empty set;
    set f = (NAT --> I) +* (NAT .--> NAT);
A1: dom f = dom(NAT --> I) \/ dom(NAT .--> NAT) by FUNCT_4:def 1
      .= NAT \/ dom(NAT .--> NAT) by FUNCOP_1:19
      .= succ NAT by FUNCOP_1:19;
    rng(NAT --> I) c= {I} & rng(NAT .--> NAT) c= {NAT} by FUNCOP_1:19;
    then rng(NAT --> I) \/ rng(NAT .--> NAT) c= {I} \/ {NAT} by XBOOLE_1:13;
    then rng f c= rng(NAT --> I) \/ rng(NAT .--> NAT) &
     rng(NAT --> I) \/ rng(NAT .--> NAT) c= { I,NAT} by ENUMSET1:41,FUNCT_4:18;
    then
A2: rng f c= { I,NAT} by XBOOLE_1:1;
    { I,NAT } c= N \/ {I, NAT} by XBOOLE_1:7;
    then rng f c= N \/ {I, NAT} by A2,XBOOLE_1:1;
    then reconsider f as Function of succ NAT, N \/ {I, NAT} by A1,
    FUNCT_2:def 1,
    RELSET_1:11;
    reconsider y = NAT as Element of succ NAT by ORDINAL1:10;
    reconsider E = I --> id product f as Function of I,Funcs(product f,
    product f) by FUNCOP_1:57,FUNCT_2:12;
    take S=AMI-Struct(#succ NAT,y,I,f,E #);
    thus thesis;
  end;
  uniqueness;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  attr S is stored-program means
  :Def3:
  NAT c= the carrier of S;
end;

registration
  let N be set;
  cluster Trivial-AMI N-> non empty stored-program;
  coherence
  proof
    set S = Trivial-AMI N;
A1: the carrier of S = succ NAT by Def2;
    thus the carrier of S is non empty by Def2;
    thus NAT c= the carrier of S by A1,XBOOLE_1:7;
  end;
end;

registration
  let N be set;
  cluster non empty stored-program AMI-Struct over N;
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

definition
  let N be set;
  let S be non empty AMI-Struct over N;
  mode Object of S is Element of S;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  mode Instruction-Location of S means
    :Def4:
    it in NAT;
  existence by XBOOLE_0:def 1;
end;

registration
  let N be set;
  let S be AMI-Struct over N;
 cluster -> natural Instruction-Location of S;
 coherence
 proof let l be Instruction-Location of S;
  l in NAT by Def4;
  hence thesis;
 end;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  mode Instruction of S is Element of the Instructions of S;
end;

definition
  let N be set;
  let S be non empty AMI-Struct over N;
  func IC S -> Object of S equals
  the Instruction-Counter of S;
  correctness;
end;

definition
  let N be set;
  let S be non empty AMI-Struct over N;
  let o be Object of S;
  func ObjectKind o -> Element of N \/ { the Instructions of S, NAT } equals
  (
  the Object-Kind of S).o;
  correctness;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  mode State of S is Element of product the Object-Kind of S;
end;

definition

  let N be with_non-empty_elements set;
  let S be AMI-Struct over N;
  let I be Instruction of S, s be State of S;
  func Exec(I,s) -> State of S equals
  ((the Execution of S).I).s;
  coherence
  proof
    consider f being Function such that
A1: (the Execution of S).I = f & dom f = product the Object-Kind of S and
A2: rng f c= product the Object-Kind of S by FUNCT_2:def 2;
    (the Execution of S).I.s in rng f by A1,FUNCT_1:def 5;
    hence thesis by A2;
  end;
end;

reserve N for with_non-empty_elements set;

definition
  let N;
  let S be AMI-Struct over N;
  let I be Instruction of S;
  attr I is halting means
  :Def8:
  for s being State of S holds Exec(I,s) = s;
end;

definition
  let N;
  let S be AMI-Struct over N;
  attr S is halting means
  :Def9:
  ex I being Instruction of S st I is halting;
end;

reserve E for set;

registration
  let N;
  cluster Trivial-AMI N -> halting;
  coherence
proof
  set T = Trivial-AMI N;
  set f = (NAT --> {[0,{}]}) +* (NAT .--> NAT);
A1: product the Object-Kind of T = product f by Def2;
  {[0,{}]} = the Instructions of T by Def2;
  then reconsider I = [0,{}] as Instruction of T by TARSKI:def 1;
  take I;
  let s be State of T;
  (I .--> id product f).I = id product f by FUNCOP_1:87;
  hence Exec(I,s) = (id product f).s by Def2
    .= s by A1,FUNCT_1:35;
end;
end;

registration
  let N;
  cluster halting AMI-Struct over N;
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration
  let N;
  let S be halting (AMI-Struct over N);
  cluster halting Instruction of S;
  existence by Def9;
end;

definition

  let N be with_non-empty_elements set;
  let S be halting (AMI-Struct over N);
  func halt S -> Instruction of S equals
  choose { I where I is Instruction of
S: I is halting };
  coherence
  proof
    set X = { I where I is Instruction of S: I is halting };
    consider I being Instruction of S such that
A1: I is halting by Def9;
    I in X by A1;
    then choose X in X;
    then ex I being Instruction of S st choose X = I & I is halting;
    hence thesis;
  end;
end;

registration
  let N;
  let S be halting (AMI-Struct over N);
  cluster halt S -> halting;
  coherence
  proof
    set X = { I where I is Instruction of S: I is halting };
    consider I being Instruction of S such that
A1: I is halting by Def9;
    I in X by A1;
    then choose X in X;
    then ex I being Instruction of S st choose X = I & I is halting;
    hence thesis;
  end;
end;

definition
  let N be set;
  let IT be non empty AMI-Struct over N;
  attr IT is IC-Ins-separated means
  :Def11:
  ObjectKind IC IT = NAT;
end;

definition

  let N be with_non-empty_elements set;
  let IT be non empty AMI-Struct over N;
  canceled;
  attr IT is steady-programmed means
  :Def13:
  for s being State of IT, i being
Instruction of IT, l being Instruction-Location of IT holds Exec(i,s).l = s.l;
end;

definition
  let N be set;
  let IT be non empty stored-program AMI-Struct over N;
  redefine mode Instruction-Location of IT -> Element of IT;
  coherence
  proof
    let l be Instruction-Location of IT;
    l in NAT & NAT c= the carrier of IT by Def3,ORDINAL1:def 13;
    hence thesis;
  end;
end;

definition
  let N be set;
  let IT be non empty stored-program AMI-Struct over N;
  attr IT is definite means
  :Def14:
  for l being Instruction-Location of IT
  holds ObjectKind l = the Instructions of IT;
end;

canceled 8;

theorem Th9:
  for s being State of Trivial-AMI N, i being Instruction of
  Trivial-AMI N holds Exec(i,s) = s
proof
  set T = Trivial-AMI N;
  let s be State of Trivial-AMI N, i be Instruction of Trivial-AMI N;
  set f = (NAT --> {[0,{}]}) +* (NAT .--> NAT);
A1: product the Object-Kind of T = product f by Def2;
  the Instructions of T = {[0,{}]} by Def2;
  then (i .--> id product f).i = id product f & i = [0,{}] by
  FUNCOP_1:87 ,
  TARSKI:def 1;
  hence Exec(i,s) = (id product f).s by Def2
    .= s by A1,FUNCT_1:35;
end;

registration
  let E be set;
  cluster Trivial-AMI E -> IC-Ins-separated definite;
  coherence
   proof
  thus Trivial-AMI E is IC-Ins-separated
proof
  dom(NAT .--> NAT) = {NAT} by FUNCOP_1:19;
  then
A1: NAT in dom(NAT .--> NAT) by TARSKI:def 1;
  IC Trivial-AMI E = NAT by Def2;
  hence ObjectKind IC Trivial-AMI E = ((NAT --> {[0,{}]}) +* (NAT .--> NAT)).
  NAT by Def2
    .= (NAT .--> NAT).NAT by A1,FUNCT_4:14
    .= NAT by FUNCOP_1:87;
end;
  let l be Instruction-Location of Trivial-AMI E;
A1: l in NAT by Def4;
  now
    assume
    l in {NAT};
    then l = NAT by TARSKI:def 1;
    hence contradiction by A1;
  end;
  then
A2: not l in dom(NAT .--> NAT) by FUNCOP_1:19;
  thus ObjectKind l = ((NAT --> {[0,{}]}) +* (NAT .--> NAT)).l by Def2
    .= (NAT --> {[0,{}]}).l by A2,FUNCT_4:12
    .= {[0,{}]} by A1,FUNCOP_1:13
    .= the Instructions of Trivial-AMI E by Def2;
   end;
end;

registration

  let N be with_non-empty_elements set;
  cluster Trivial-AMI N -> steady-programmed;
  coherence
proof
  let s be State of Trivial-AMI N, i be Instruction of Trivial-AMI N,
  l be Instruction-Location of Trivial-AMI N;
  thus thesis by Th9;
end;
end;

registration
  let E be set;
  cluster strict AMI-Struct over E;
  existence
  proof
    take Trivial-AMI E;
    thus thesis;
  end;
end;

registration
  let M be set;
  cluster IC-Ins-separated definite strict (non empty stored-program
    AMI-Struct over M);
  existence
  proof
    take Trivial-AMI M;
    thus thesis;
  end;
end;

registration
  let N;
  cluster IC-Ins-separated halting steady-programmed definite strict (non
    empty stored-program AMI-Struct over N);
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

definition

  let N be with_non-empty_elements set;
  let S be IC-Ins-separated (non empty AMI-Struct over N);
  let s be State of S;
  func IC s -> Instruction-Location of S equals
  s.IC S;
  coherence
  proof
    dom the Object-Kind of S = the carrier of S by FUNCT_2:def 1;
    then pi(product the Object-Kind of S,IC S) = ObjectKind IC S by
    CARD_3:
    22
      .= NAT by Def11;
    then s.IC S in NAT by CARD_3:def 6;
    hence thesis by Def4;
  end;
end;

canceled 2;

theorem
  for s1, s2 being State of Trivial-AMI N st IC s1 = IC s2 holds s1=
  s2
proof
  set T = Trivial-AMI N;
  let s1,s2 be State of Trivial-AMI N such that
A1: IC s1 = IC s2;
A2: dom s1 = dom the Object-Kind of T by CARD_3:18;
A3: now
    let x be set;
    assume
A4: x in dom s1;
    dom s1 = the carrier of T by A2,FUNCT_2:def 1
      .= succ NAT by Def2;
    then
A5: x in NAT or x in {NAT} by A4,XBOOLE_0:def 3;
    per cases by A5,TARSKI:def 1;
    suppose
A6:   x in NAT;
      then x <> NAT;
      then not x in {NAT} by TARSKI:def 1;
      then
A7:   not x in dom(NAT .--> NAT) by FUNCOP_1:19;
A8:   (the Object-Kind of T).x = ((NAT --> {[0,{}]}) +* (NAT .--> NAT)).x by
      Def2
        .= (NAT --> {[0,{}]}).x by A7,FUNCT_4:12
        .= {[0,{}]} by A6,FUNCOP_1:13;
      then
A9:   s2.x in {[0,{}]} by A2,A4,CARD_3:18;
      s1.x in {[0,{}]} by A2,A4,A8,CARD_3:18;
      hence s1.x = [0,{}] by TARSKI:def 1
        .= s2.x by A9,TARSKI:def 1;
    end;
    suppose
A10:  x = NAT;
      hence s1.x = IC s1 by Def2
        .= s2.x by A1,A10,Def2;
    end;
  end;
  dom s1 =dom s2 by A2,CARD_3:18;
  hence thesis by A3,FUNCT_1:9;
end;

definition

  let N be with_non-empty_elements set;
  let S be IC-Ins-separated (non empty stored-program AMI-Struct over N);
  let s be State of S;
  redefine func IC s -> Instruction-Location of S;
  coherence;
end;

begin :: General theory

reserve x,y,z,A,B for set,
  f,g,h for Function,
  i,j,k for Element of NAT;

definition
  let N be with_non-empty_elements set;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let s be State of S;
  func CurInstr s -> Instruction of S equals
  s.IC s;
  coherence
  proof
    dom the Object-Kind of S = the carrier of S by FUNCT_2:def 1;
    then pi(product the Object-Kind of S,IC s) = ObjectKind IC s by
    CARD_3:
    22
      .= the Instructions of S by Def14;
    hence thesis by CARD_3:def 6;
  end;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  mode PartState of S is Element of sproduct the Object-Kind of S;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  mode FinPartState of S is finite PartState of S;
end;

definition
  let N be with_non-empty_elements set;
  let S be AMI-Struct over N;
  let s be State of S;
  func ProgramPart s -> PartState of S equals
  s | NAT;
  coherence by CARD_3:98;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let s be State of S;
  func Following s -> State of S equals
  Exec(CurInstr s,s);
  correctness;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  deffunc F(set, Element of product the Object-Kind of S) = Following $2;
  let s be State of S, k be Nat;
  func Computation(s,k) -> State of S means
  :Def19:
  ex f being Function of NAT
, product the Object-Kind of S st it = f.k & f.0 = s & for i being Nat holds f.
  (i+1) = Following(f.i);
  existence
  proof
    consider f being Function of NAT, product the Object-Kind of S such that
A1: f.0 = s & for n being Nat holds f.(n+1) = F(n,f.n) from NAT_1:sch
    12;
    take f.k, f;
    thus thesis by A1;
  end;
  uniqueness
  proof
    deffunc F(set,State of S) = Following $2;
    let s1,s2 be State of S;
    given f1 being Function of NAT, product the Object-Kind of S such that
A2: s1 = f1.k and
A3: f1.0 = s and
A4: for i being Nat holds f1.(i+1) = F(i,f1.i);
    given f2 being Function of NAT, product the Object-Kind of S such that
A5: s2 = f2.k and
A6: f2.0 = s and
A7: for i being Nat holds f2.(i+1) = F(i,f2.i);
    f1 = f2 from NAT_1:sch 16(A3,A4,A6,A7);
    hence thesis by A2,A5;
  end;
end;

definition
  let N;
  let S be AMI-Struct over N;
  let f be Function of NAT, product the Object-Kind of S;
  let k;
  redefine func f.k -> State of S;
  coherence by FUNCT_2:7;
end;

definition
  let N;
  let S be halting IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N);
  let p be PartState of S;
  let s be State of S;
  pred p halts_on s means
  :Def20:
  ex k st IC Computation(s,k) in dom p &
   p.IC Computation(s,k) = halt S;
end;

definition
  let N be set;
  let IT be AMI-Struct over N;
  attr IT is realistic means
  :Def21:
  not the Instruction-Counter of IT in NAT;
end;

theorem Th13:
  for N for S be IC-Ins-separated definite (non empty
stored-program AMI-Struct over N), s be State of S holds Computation(s,0) =
  s
proof
  let N;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N), s be State of S;
  ex f being Function of NAT, product the Object-Kind of S st Computation(
s,0) = f.0 & f.0 = s & for i being Nat holds f.(i+1) = Following(f.i) by Def19;
  hence thesis;
end;

theorem Th14:
  for N for S be IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N), s be State of S, k be Nat holds
  Computation(s,k+1) = Following Computation(s,k)
proof
  let N;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N), s be State of S, k be Nat;
  deffunc F(set,State of S) = Following $2;
  consider f being Function of NAT, product the Object-Kind of S such that
A1: Computation(s,k+1) = f.(k+1) and
A2: f.0 = s and
A3: for i being Nat holds f.(i+1) = F(i,f.i) by Def19;
  consider g being Function of NAT, product the Object-Kind of S such that
A4: Computation(s,k) = g.k and
A5: g.0 = s and
A6: for i being Nat holds g.(i+1) = F(i,g.i) by Def19;
  f = g from NAT_1:sch 16(A2,A3,A5,A6);
  hence thesis by A1,A4,A6;
end;

canceled 33;

theorem Th48:
  for S being IC-Ins-separated (non empty AMI-Struct over E) st
  S is realistic holds not ex l being Instruction-Location of S st IC S = l
 proof
  let S being IC-Ins-separated (non empty AMI-Struct over E) such that
Z: S is realistic;
  given l being Instruction-Location of S such that
G:  IC S = l;
   l in NAT by ORDINAL1:def 13;
  hence contradiction by Def21,Z,G;
 end;

reserve S for IC-Ins-separated definite (non empty stored-program AMI-Struct
  over N),
  s for State of S;

canceled 2;

theorem Th51:
  for k holds Computation(s,i+k) = Computation(Computation(s,i),k)
proof
  defpred P[Element of NAT] means Computation(s,i+$1) = Computation(
  Computation(s,i),$1);
A1: now
    let k;
    assume
A2: P[k];
    Computation(s,i+(k+1)) = Computation(s,i+k+1)
      .= Following Computation(s,i+k) by Th14
      .= Computation(Computation(s,i),k+1) by A2,Th14;
    hence P[k+1];
  end;
A3: P[0] by Th13;
  thus for k holds P[k] from NAT_1:sch 1(A3,A1);
end;

theorem Th52:
  i <= j implies for N for S being halting IC-Ins-separated
definite (non empty stored-program AMI-Struct over N) for s being State of S
st CurInstr Computation(s,i) = halt S holds Computation(s,j) = Computation(s,i)
proof
  assume
  i <= j;
  then consider k being Nat such that
A1: j = i + k by NAT_1:10;
  reconsider k as Element of NAT by ORDINAL1:def 13;
A2: j = i + k by A1;
  let N;
  let S be halting IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N);
  let s be State of S such that
A3: CurInstr Computation(s,i) = halt S;
  defpred P[Element of NAT] means Computation(s,i+$1) = Computation(s,i);
A4: now
    let k;
    assume
A5: P[k];
    Computation(s,i+(k+1)) = Computation(s,i+k+1)
      .= Following Computation(s,i+k) by Th14
      .= Computation(s,i) by A3,A5,Def8;
    hence P[k+1];
  end;
A6: P[0];
  for k holds P[k] from NAT_1:sch 1(A6,A4);
  hence thesis by A2;
end;

L79:
  for S being AMI-Struct over N, s being State of S holds dom s
  = the carrier of S
proof
  let S be AMI-Struct over N, s be State of S;
  thus dom s = dom the Object-Kind of S by CARD_3:18
    .= the carrier of S by FUNCT_2:def 1;
end;

LmU: for N being with_non-empty_elements set for S being
  steady-programmed (non empty stored-program AMI-Struct over N)
   for s being State of S
   holds dom ProgramPart s = NAT
proof
  let N be with_non-empty_elements set;
  let S be steady-programmed (non empty stored-program AMI-Struct over N);
  let s be State of S;
A1:   NAT c= the carrier of S by Def3;
   dom s = the carrier of S by L79;
  hence thesis by A1,RELAT_1:91;
end;


L117: for N being with_non-empty_elements set for S being
  steady-programmed (non empty stored-program AMI-Struct over N) for i being
  Instruction of S, s being State of S holds Exec (i, s) | NAT = s | NAT
proof
  let N be with_non-empty_elements set;
  let S be steady-programmed (non empty stored-program AMI-Struct over N);
  let i be Instruction of S, s be State of S;
A1: NAT c= the carrier of S by Def3;
A2: for x being set st x in NAT holds (Exec (i, s) | NAT).x = (s | NAT).x
  proof
    let x be set;
    assume
    x in NAT;
    then reconsider l = x as Instruction-Location of S by Def4;
A3: l in NAT by Def4;
    hence (Exec (i, s) | NAT).x = (Exec (i, s)).l by FUNCT_1:72
      .= s.l by Def13
      .= (s | NAT).x by A3,FUNCT_1:72;
  end;
A4: dom ProgramPart s = NAT by LmU;
  dom (Exec (i,s)) = the carrier of S by L79;
  then dom (Exec (i, s) | NAT) = NAT by A1,RELAT_1:91;
  hence thesis by A4,A2,FUNCT_1:9;
end;

LmY:
 for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for s being State of S, k
 holds ProgramPart s = ProgramPart Computation(s,k)
 proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s being State of S; let k;
  defpred X[Element of NAT] means s|NAT = ( Computation(s,$1))|NAT;
A1: now
    let k;
    assume
    X[k];
    then s|NAT = (Following( Computation(s,k)))|NAT by L117
      .= ( Computation(s,k+1))|NAT by Th14;
    hence X[k+1];
  end;
A2: X[0] by Th13;
   for k holds X[k] from NAT_1:sch 1(A2,A1);
  hence thesis;
 end;

LmX:
 for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for s being State of S, k
 holds (ProgramPart s).IC Computation(s,k) = CurInstr(Computation(s,k))
 proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s being State of S; let k;
A: ProgramPart s = ProgramPart Computation(s,k) by LmY;
   IC Computation(s,k) in NAT by Def4;
  hence (ProgramPart s).IC Computation(s,k)
            = Computation(s,k).IC Computation(s,k) by A,FUNCT_1:72
           .= CurInstr(Computation(s,k));
 end;

definition
  let N;
  let S be halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let s be State of S such that
A1: ProgramPart s halts_on s;
  func Result s -> State of S means
  :Def22:
  ex k st it = Computation(s,k) &
  CurInstr(it) = halt S;
  uniqueness
  proof
    let s1,s2 be State of S;
    given k1 being Element of NAT such that
A2: s1 = Computation(s,k1) & CurInstr(s1) = halt S;
    given k2 being Element of NAT such that
A3: s2 = Computation(s,k2) & CurInstr(s2) = halt S;
    k1 <= k2 or k2 <= k1;
    hence thesis by A2,A3,Th52;
  end;
  correctness
  proof
    consider k such that
     IC Computation(s,k) in dom ProgramPart s and
W:   (ProgramPart s).IC Computation(s,k) = halt S by A1,Def20;
     (ProgramPart s).IC Computation(s,k) = CurInstr(Computation(s,k)) by LmX;
    hence thesis by W;
  end;
end;

theorem
  for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for s being State of S, i be
  Instruction-Location of S holds s.i = (Following s).i by Def13;

definition
  let N;
  let S be definite (non empty stored-program AMI-Struct over N);
  let s be State of S, l be Instruction-Location of S;
  redefine func s.l -> Instruction of S;
  coherence
  proof
    dom the Object-Kind of S = the carrier of S by FUNCT_2:def 1;
    then pi(product the Object-Kind of S,l) = ObjectKind l by CARD_3:22
      .= the Instructions of S by Def14;
    hence thesis by CARD_3:def 6;
  end;
end;

theorem Th54:
  for S being steady-programmed IC-Ins-separated definite (non
  empty stored-program AMI-Struct over N) for s being State of S, i be
  Instruction-Location of S, k holds s.i = Computation(s,k).i
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S, i be Instruction-Location of S;
  defpred P[Element of NAT] means s.i = Computation(s,$1).i;
A1: now
    let k;
    assume
    P[k];
    then s.i = (Following Computation(s,k)).i by Def13
      .= Computation(s,k+1).i by Th14;
    hence P[k+1];
  end;
A2: P[0] by Th13;
  thus for k holds P[k] from NAT_1:sch 1(A2,A1);
end;

theorem
  for S being steady-programmed IC-Ins-separated definite (non empty
stored-program AMI-Struct over N) for s being State of S holds Computation(s
  ,k+1) = Exec(s.(IC Computation(s,k)), Computation(s,k))
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S;
  thus Computation(s,k+1) = Following Computation(s,k) by Th14
    .= Exec(s.(IC Computation(s,k)), Computation(s,k)) by Th54;
end;

theorem Th56:
  for S being steady-programmed IC-Ins-separated halting definite
(non empty stored-program AMI-Struct over N) for s being State of S, k st s.
  IC Computation(s,k) = halt S holds Result s = Computation(s,k)
proof
  let S be steady-programmed IC-Ins-separated halting definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S, k;
   IC Computation(s,k) in NAT by Def4;
   then
X: IC Computation(s,k) in dom ProgramPart s by LmU;
  assume
  s.IC Computation(s,k) = halt S;
  then
A1: CurInstr( Computation(s,k)) = halt S by Th54;
  then (ProgramPart s).IC Computation(s,k) = halt S by LmX;
  then ProgramPart s halts_on s by Def20,X;
 hence thesis by A1,Def22;
end;

theorem Th57:
  for S being steady-programmed IC-Ins-separated halting definite
(non empty stored-program AMI-Struct over N) for s being State of S st ex k
st s.IC Computation(s,k) = halt S for i holds Result s = Result Computation(s,i
  )
proof
  let S be steady-programmed IC-Ins-separated halting definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S;
  given k such that
A1: s.IC Computation(s,k) = halt S;
  let i;
  set s' = Computation(s,k);
A2: CurInstr s' = halt S by A1,Th54;
   IC Computation(s,k) in NAT by Def4;
   then
X:  IC Computation(s,k) in dom ProgramPart Computation(s,i) by LmU;
  now
    per cases;
    suppose
      i <= k;
      then consider j being Nat such that
A3:   k = i + j by NAT_1:10;
      reconsider j as Element of NAT by ORDINAL1:def 13;
A4:   Computation(s,k) = Computation(Computation(s,i),j) by A3,Th51;
      then (ProgramPart Computation(s,i)).IC Computation(s,k) = halt S
                    by A2,LmX;
      then
A5:   ProgramPart Computation(s,i) halts_on Computation(s,i) by A4,Def20,X;
      thus Result s = s' by A1,Th56
        .= Result Computation(s,i) by A2,A4,A5,Def22;
    end;
    suppose
A6:   i >= k;
A7:   Computation(Computation(s,k),0) = Computation(s,k) by Th13;
A8:   Computation(s,i) = s' by A2,A6,Th52;
     IC Computation(s',0) in NAT by Def4;
     then
X:    IC Computation(s',0) in dom ProgramPart s' by LmU;
      (ProgramPart s').IC Computation(s',0) = halt S by A2,A7,LmX;
      then
A9:   ProgramPart Computation(s,i) halts_on Computation(s,i) by Def20,X,A8;
      thus Result s = s' by A1,Th56
        .= Result Computation(s,i) by A2,A8,A7,A9,Def22;
    end;
  end;
  hence thesis;
end;

registration
  let N;
  let S be non empty AMI-Struct over N, o be Object of S;
  cluster ObjectKind o -> non empty;
  coherence;
end;

begin :: Finite substates

definition
  let N be set;
  let S be AMI-Struct over N;
  func FinPartSt S -> Subset of sproduct the Object-Kind of S equals
  { p where
  p is Element of sproduct the Object-Kind of S: p is finite };
  coherence
  proof
    defpred P[set] means $1 is finite;
    { p where p is Element of sproduct the Object-Kind of S: P[p] } c=
    sproduct the Object-Kind of S from FRAENKEL:sch 10;
    hence thesis;
  end;
end;

definition
  let N be set;
  let S be non empty AMI-Struct over N;
  func Data-Locations S equals
  (the carrier of S) \ ({IC S} \/ NAT);
  coherence;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let IT be FinPartState of S;
  attr IT is autonomic means
  :Def25:
  for s1,s2 being State of S st IT c= s1 &
  IT c= s2 for i holds Computation(s1,i)|dom IT = Computation(s2,i)|dom IT;
end;

definition
  let N;
  let S be halting IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N);
  let IT be FinPartState of S;
  attr IT is halting means
  :Def26:
  for s being State of S st IT c= s holds ProgramPart s halts_on s;
end;

definition
  let N;
  let IT be IC-Ins-separated definite (non empty stored-program AMI-Struct
  over N);
  attr IT is programmable means
  :Def27:
  ex s being FinPartState of IT st s is
  non empty autonomic;
end;

theorem Th58:
  for S being non empty AMI-Struct over N for A,B being set, la
  ,lb being Object of S st ObjectKind la = A & ObjectKind lb = B for a being
Element of A, b being Element of B holds (la,lb) --> (a,b) is FinPartState of S
proof
  let S be non empty AMI-Struct over N;
  let A,B be set, la,lb be Object of S such that
A1: ObjectKind la = A and
A2: ObjectKind lb = B;
  let a be Element of A, b be Element of B;
  set p = (la,lb) --> (a,b);
A3: dom p = {la,lb} by FUNCT_4:65;
A4: now
    let x be set such that
A5: x in dom p;
    now
      per cases by A3,A5,TARSKI:def 2;
      suppose
A6:     la <> lb & x = la;
        then p.x = a by FUNCT_4:66;
        hence p.x in (the Object-Kind of S).x by A1,A6;
      end;
      suppose
A7:     la <> lb & x = lb;
        then p.x = b by FUNCT_4:66;
        hence p.x in (the Object-Kind of S).x by A2,A7;
      end;
      suppose
A8:     la = lb & x = la;
        then p = la .--> b by CQC_LANG:44;
        then p.x = b by A8,FUNCOP_1:87;
        hence p.x in (the Object-Kind of S).x by A2,A8;
      end;
    end;
    hence p.x in (the Object-Kind of S).x;
  end;
  dom the Object-Kind of S = the carrier of S by FUNCT_2:def 1;
  then reconsider p as Element of sproduct the Object-Kind of S by A3,
  A4,CARD_3:
  def 9;
  dom p = {la,lb} by FUNCT_4:65;
  hence thesis by FINSET_1:29;
end;

theorem Th59:
  for S being non empty AMI-Struct over N for A being set, la
being Object of S st ObjectKind la = A for a being Element of A holds la .--> a
  is FinPartState of S
proof
  let S be non empty AMI-Struct over N;
  let A be set, la be Object of S such that
A1: ObjectKind la = A;
  let a be Element of A;
  set p = la .--> a;
A2: dom p = {la} by FUNCOP_1:19;
A3: now
    let x be set;
    assume
    x in dom p;
    then
A4: x = la by A2,TARSKI:def 1;
    then p.x = a by FUNCOP_1:87;
    hence p.x in (the Object-Kind of S).x by A1,A4;
  end;
  dom the Object-Kind of S = the carrier of S by FUNCT_2:def 1;
  then reconsider p as Element of sproduct the Object-Kind of S by A2,
  A3,CARD_3:
  def 9;
  p is FinPartState of S;
  hence thesis;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let la be Object of S;
  let a be Element of ObjectKind la;
  redefine func la .--> a -> FinPartState of S;
  coherence by Th59;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let la,lb be Object of S;
  let a be Element of ObjectKind la, b be Element of ObjectKind lb;
  redefine func (la,lb) --> (a,b) -> FinPartState of S;
  coherence by Th58;
end;

registration
  let E;
  cluster Trivial-AMI E -> realistic;
  coherence
proof
  assume
A1: the Instruction-Counter of Trivial-AMI E in NAT;
  the Instruction-Counter of Trivial-AMI E = NAT by Def2;
  hence thesis by A1;
end;
end;

registration
  let N;
  cluster Trivial-AMI N -> programmable;
  coherence
proof
  set T = Trivial-AMI N;
  reconsider la = NAT as Object of T by Def2;
  consider l being Element of NAT;
  dom(NAT .--> NAT) = {NAT} by FUNCOP_1:19;
  then
A1: NAT in dom(NAT .--> NAT) by TARSKI:def 1;
  ObjectKind la = ((NAT --> {[0,{}]}) +* (NAT .--> NAT)).NAT by Def2
    .= (NAT .--> NAT).NAT by A1,FUNCT_4:14
    .= NAT by FUNCOP_1:87;
  then reconsider a = l as Element of ObjectKind la;
  take la .--> a;
  thus la .--> a is non empty;
  let s1,s2 be State of T such that
A2: la .--> a c= s1 & la .--> a c= s2;
  defpred P[Element of NAT] means Computation(s1,$1)|dom(la .--> a) =
  Computation(s2,$1)|dom(la .--> a);
A3: now
    let i;
    assume
A4: P[i];
    set s3 = Computation(s1,i), s4 = Computation(s2,i);
    Computation(s1,i+1)|dom(la .--> a) = (Following s3)|dom(la .--> a) by
    Th14
      .= s3|dom(la .--> a) by Th9
      .= (Following s4)|dom(la .--> a) by A4,Th9
      .= Computation(s2,i+1)|dom(la .--> a) by Th14;
    hence P[i+1];
  end;
  Computation(s1,0)|dom(la .--> a) = s1|dom(la .--> a) by Th13
    .= s2|dom(la .--> a) by A2,GRFUNC_1:94
    .= Computation(s2,0)|dom(la .--> a) by Th13;
  then
A5: P[0];
  thus for i holds P[i] from NAT_1:sch 1(A5,A3);
end;
end;

registration
  let E;
  cluster realistic strict AMI-Struct over E;
  existence
  proof
    take Trivial-AMI E;
    thus thesis;
  end;
end;

registration
  let M be set;
  cluster realistic strict IC-Ins-separated definite (non empty stored-program
    AMI-Struct over M);
  existence
  proof
    take Trivial-AMI M;
    thus thesis;
  end;
end;

registration
  let N;
  cluster halting steady-programmed realistic programmable strict (
    IC-Ins-separated definite (non empty stored-program AMI-Struct over N));
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

canceled 2;

theorem Th62:
  for S being AMI-Struct over N, s being State of S, p being
  FinPartState of S holds s|dom p is FinPartState of S
proof
  let S be AMI-Struct over N, s be State of S, p be FinPartState of S;
A1: dom(s|dom p) = dom s /\ dom p by RELAT_1:90;
  product the Object-Kind of S c= sproduct the Object-Kind of S & s in
  product the Object-Kind of S by CARD_3:67;
  hence thesis by A1,CARD_3:81,FINSET_1:29;
end;

registration
  let N;
  let S be programmable (IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N));
  cluster non empty autonomic FinPartState of S;
  existence by Def27;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  let f,g be PartState of S;
  redefine func f +* g -> PartState of S;
  coherence by CARD_3:86;
end;

begin :: Preprograms

canceled;

theorem Th64:
  for S being halting realistic IC-Ins-separated definite (non
  empty stored-program AMI-Struct over N) for loc being Instruction-Location
  of S for l being Element of ObjectKind IC S st l = loc for h being Element of
ObjectKind loc st h = halt S for s being State of S st (IC S,loc) --> (l, h) c=
  s holds CurInstr s = halt S
proof
  let S be halting realistic IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let loc be Instruction-Location of S;
  let l be Element of ObjectKind IC S such that
A1: l = loc;
  let h be Element of ObjectKind loc such that
A2: h = halt S;
  let s be State of S such that
A3: (IC S,loc) --> (l, h) c= s;
  loc in NAT by Def4;
  then
A4: IC S <> loc by Def21;
A5: dom((IC S,loc) --> (l, h)) = {IC S,loc} by FUNCT_4:65;
  then loc in dom((IC S,loc) --> (l, h )) by TARSKI:def 2;
  then
A6: ((IC S,loc) --> (l, h)).IC S in dom((IC S,loc) --> (l, h)) by A1,A4,
  FUNCT_4:66;
  IC S in dom((IC S,loc) --> (l, h)) by A5,TARSKI:def 2;
  hence CurInstr s = s.(((IC S,loc) --> (l, h)).IC S) by A3,GRFUNC_1:8
    .= ((IC S,loc) --> (l, h)).(((IC S,loc) --> (l, h)).IC S) by A3,A6,
  GRFUNC_1:8
    .= ((IC S,loc) --> (l, h)).loc by A1,A4,FUNCT_4:66
    .= halt S by A2,FUNCT_4:66;
end;

theorem Th65:
  for S being halting realistic IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
   for loc being Instruction-Location
  of S for l being Element of ObjectKind IC S st l = loc for h being Element of
  ObjectKind loc st h = halt S holds (IC S,loc) --> (l, h) is halting
proof
  let S be halting realistic IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let loc be Instruction-Location of S;
  let l be Element of ObjectKind IC S such that
A1: l = loc;
  let h be Element of ObjectKind loc such that
A2: h = halt S;
  thus (IC S,loc) --> (l, h) is halting
  proof
    let s be State of S such that
A3: (IC S,loc) --> (l, h) c= s;
    take 0;
     IC Computation(s,0) in NAT by Def4;
    hence IC Computation(s,0) in dom ProgramPart s by LmU;
    CurInstr Computation(s,0) = CurInstr s by Th13
      .= halt S by A1,A2,A3,Th64;
    hence (ProgramPart s).IC Computation(s,0) = halt S by LmX;
  end;
end;

theorem Th66:
  for S being realistic halting IC-Ins-separated definite (non
  empty stored-program AMI-Struct over N) for loc being Instruction-Location
  of S for l being Element of ObjectKind IC S st l = loc for h being Element of
ObjectKind loc st h = halt S for s being State of S st (IC S,loc) --> (l, h) c=
  s for i holds Computation(s,i) = s
proof
  let S be realistic halting IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let loc be Instruction-Location of S;
  let l be Element of ObjectKind IC S such that
A1: l = loc;
  let h be Element of ObjectKind loc such that
A2: h = halt S;
  let s be State of S such that
A3: (IC S,loc) --> (l, h) c= s;
  defpred P[Element of NAT] means Computation(s,$1) = s;
A4: now
    let i;
    assume
A5: P[i];
    Computation(s,i+1) = Following Computation(s,i) by Th14
      .= Exec(halt S,s) by A1,A2,A3,A5,Th64
      .= s by Def8;
    hence P[i+1];
  end;
A6: P[0] by Th13;
  thus for i holds P[i] from NAT_1:sch 1(A6,A4);
end;

theorem Th67:
  for S be realistic halting IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for loc being Instruction-Location of S
  for l being Element of ObjectKind IC S st l = loc for h being Element of
  ObjectKind loc st h = halt S holds (IC S,loc) --> (l, h) is autonomic
proof
  let S be realistic halting IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let loc be Instruction-Location of S;
  let l be Element of ObjectKind IC S such that
A1: l = loc;
  let h be Element of ObjectKind loc such that
A2: h = halt S;
  thus (IC S,loc) --> (l, h) is autonomic
  proof
    let s1,s2 be State of S;
    assume that
A3: (IC S,loc) --> (l, h) c= s1 and
A4: (IC S,loc) --> (l, h) c= s2;
A5: s1|dom((IC S,loc) --> (l, h)) = (IC S,loc) --> (l, h) & s2|dom((IC S,
    loc) --> (l, h)) = (IC S,loc) --> (l, h) by A3,A4,GRFUNC_1:64;
    let i;
    Computation(s1,i) = s1 by A1,A2,A3,Th66;
    hence thesis by A1,A2,A4,A5,Th66;
  end;
end;

registration
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  cluster autonomic halting FinPartState of S;
  existence
  proof
    consider loc being Instruction-Location of S;
    reconsider h = halt S as Element of ObjectKind loc by Def14;
    loc in NAT by Def4;
    then reconsider l = loc as Element of ObjectKind IC S by Def11;
    (IC S,loc) --> (l, h) is autonomic halting by Th65,Th67;
    hence thesis;
  end;
end;

definition
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  mode pre-program of S is autonomic halting FinPartState of S;
end;

definition
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let s be FinPartState of S;
  assume
A1: s is pre-program of S;
  func Result(s) -> FinPartState of S means
  for s' being State of S st s c= s'
  holds it = (Result s')|dom s;
  existence
  proof
    consider h being Function such that
A2: h in product the Object-Kind of S and
A3: s c= h by CARD_3:70;
    reconsider h as State of S by A2;
    ProgramPart h halts_on h by A1,A3,Def26;
    then consider k1 being Element of NAT such that
A4: Result h = Computation(h,k1) and
A5: CurInstr(Result h) = halt S by Def22;
    reconsider R = (Result h)|dom s as FinPartState of S by Th62;
    take R;
    let s' be State of S such that
A6: s c= s';
    ProgramPart s' halts_on s' by A1,A6,Def26;
    then consider k2 being Element of NAT such that
A7: Result s' = Computation(s',k2) and
A8: CurInstr(Result s') = halt S by Def22;
    now
      per cases;
      suppose
        k1 <= k2;
        then Result h = Computation(h,k2) by A4,A5,Th52;
        hence thesis by A1,A3,A6,A7,Def25;
      end;
      suppose
        k1 >= k2;
        then Result s' = Computation(s',k1) by A7,A8,Th52;
        hence thesis by A1,A3,A6,A4,Def25;
      end;
    end;
    hence thesis;
  end;
  correctness
  proof
    consider h being Function such that
A9: h in product the Object-Kind of S and
A10: s c= h by CARD_3:70;
    reconsider h as State of S by A9;
    let p1,p2 be FinPartState of S such that
A11: for s' being State of S st s c= s' holds p1 = (Result s')|dom s and
A12: for s' being State of S st s c= s' holds p2 = (Result s')|dom s;
    thus p1 = (Result h)|dom s by A11,A10
      .= p2 by A12,A10;
  end;
end;

begin :: Computability

definition
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be FinPartState of S, F be Function;
  pred p computes F means
  :Def29:
  for x being set st x in dom F
   ex s being FinPartState of S
    st x = s & p +* s is pre-program of S & F.s c= Result(p +* s);
end;

notation
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be FinPartState of S, F be Function;
  antonym p does_not_compute F for p computes F;
end;

theorem Th68:
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
 for p being FinPartState of S holds
  p computes {}
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be FinPartState of S;
  let x be set;
  assume
A1: x in dom {};
  then reconsider x as FinPartState of S;
  take x;
  thus thesis by A1;
end;

theorem Th69:
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N) for p being FinPartState of S
  holds p is pre-program of S iff p computes {} .--> Result(p)
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N);
  let p be FinPartState of S;
  thus p is pre-program of S implies p computes {} .--> Result(p)
  proof
A1: dom({} .--> Result(p)) = {{}} by FUNCOP_1:19;
    assume
A2: p is pre-program of S;
    let x be set;
    assume
    x in dom({} .--> Result(p));
    then
A3: x = {} by A1,TARSKI:def 1;
    then reconsider s = x as FinPartState of S by CARD_3:66;
    take s;
    thus x = s;
    thus p +* s is pre-program of S by A2,A3,FUNCT_4:22;
    ({} .--> Result(p)).s = Result(p) by A3,FUNCOP_1:87;
    hence thesis by A3,FUNCT_4:22;
  end;
  dom({} .--> Result(p)) = {{}} by FUNCOP_1:19;
  then
A4: {} in dom({} .--> Result(p)) by TARSKI:def 1;
  assume
  p computes {} .--> Result(p);
  then
  ex s being FinPartState of S st s = {} & p +* s is pre-program of S & ({}
  .--> Result(p)).s c= Result(p +* s) by A4,Def29;
  hence thesis by FUNCT_4:22;
end;

theorem Th70:
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N) for p being FinPartState of S
    holds p is pre-program of S iff p computes {} .--> {}
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be FinPartState of S;
  thus p is pre-program of S implies p computes {} .--> {}
  proof
A1: dom({} .--> {}) = {{}} by FUNCOP_1:19;
    assume
A2: p is pre-program of S;
    let x be set;
    assume
    x in dom({} .--> {});
    then
A3: x = {} by A1,TARSKI:def 1;
    then reconsider s = x as FinPartState of S by CARD_3:66;
    take s;
    thus x = s;
    thus p +* s is pre-program of S by A2,A3,FUNCT_4:22;
    ({} .--> {}).s = {} by A3,FUNCOP_1:87;
    hence thesis by XBOOLE_1:2;
  end;
  dom({} .--> {}) = {{}} by FUNCOP_1:19;
  then
A4: {} in dom({} .--> {}) by TARSKI:def 1;
  assume
  p computes {} .--> {};
  then
  ex s being FinPartState of S st s = {} & p +* s is pre-program of S & ({}
  .--> {}).s c= Result(p +* s) by A4,Def29;
  hence thesis by FUNCT_4:22;
end;

definition
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let IT be PartFunc of FinPartSt S, FinPartSt S;
  attr IT is computable means
  :Def30:
  ex p being FinPartState of S st p computes IT;
end;

theorem Th71:
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
    for F being PartFunc of FinPartSt S,
  FinPartSt S st F = {} holds F is computable
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let F be PartFunc of FinPartSt S, FinPartSt S;
  consider p being FinPartState of S;
  assume
A1: F = {};
  take p;
  thus thesis by A1,Th68;
end;

theorem Th72:
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
    for F being PartFunc of FinPartSt S,
  FinPartSt S st F = {} .--> {} holds F is computable
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let F be PartFunc of FinPartSt S, FinPartSt S;
  consider p being pre-program of S;
  assume
A1: F = {} .--> {};
  take p;
  thus thesis by A1,Th70;
end;

theorem Th73:
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
   for p being pre-program of S for F
being PartFunc of FinPartSt S, FinPartSt S st F = {} .--> Result(p) holds F is
  computable
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be pre-program of S;
  let F be PartFunc of FinPartSt S, FinPartSt S;
  assume
A1: F = {} .--> Result(p);
  take p;
  thus thesis by A1,Th69;
end;

definition
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let F be PartFunc of FinPartSt S, FinPartSt S such that
A1: F is computable;
  mode Program of F -> FinPartState of S means
    it computes F;
  existence by A1,Def30;
end;

theorem
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
   for F being PartFunc of FinPartSt S,
  FinPartSt S st F = {} for p being FinPartState of S holds p is Program of F
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let F be PartFunc of FinPartSt S, FinPartSt S such that
A1: F = {};
  let p be FinPartState of S;
  thus F is computable by A1,Th71;
  thus thesis by A1,Th68;
end;

theorem
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
   for F being PartFunc of FinPartSt S,
  FinPartSt S st F = {} .--> {} for p being pre-program of S holds p is Program
  of F
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let F be PartFunc of FinPartSt S, FinPartSt S such that
A1: F = {} .--> {};
  let p be pre-program of S;
  thus F is computable by A1,Th72;
  thus thesis by A1,Th70;
end;

theorem
  for S being realistic halting IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N) for p being pre-program of S
  for F being
PartFunc of FinPartSt S, FinPartSt S st F = {} .--> Result p holds p is Program
  of F
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N);
  let p be pre-program of S;
  let F be PartFunc of FinPartSt S, FinPartSt S;
  assume
A1: F = {} .--> Result p;
  hence F is computable by Th73;
  thus thesis by A1,Th69;
end;

begin :: InsType & InsCode

notation
  let x;
  synonym InsCode x for x`1;
  synonym AddressPart x for x`2;
end;

definition
  let N be set, S be AMI-Struct over N;
  attr S is standard-ins means
  :Def32:
   ex X being non empty set
    st the Instructions of S c= [: NAT,X*:];
end;

registration
  let N be set;
  cluster Trivial-AMI N -> standard-ins;
  coherence
  proof
    {} in ((union N) \/ the carrier of Trivial-AMI N)* by FINSEQ_1:66;
    then
A1: {{}} c= ((union N) \/ the carrier of Trivial-AMI N)* by
    ZFMISC_1:37;
    take X = (union N) \/ the carrier of Trivial-AMI N;
    the Instructions of Trivial-AMI N = {[0,{}]} by Def2
      .= [:{0},{{}}:] by ZFMISC_1:35;
    hence the Instructions of Trivial-AMI N c= [: NAT,X*:]
     by A1,ZFMISC_1:119;
  end;
end;

registration
  let N be set;
  cluster standard-ins non empty stored-program AMI-Struct over N;
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration
  let N be set, S be standard-ins AMI-Struct over N;
  cluster the Instructions of S -> Relation-like;
  coherence
   proof
    ex X being non empty set
     st the Instructions of S c= [: NAT,X*:] by Def32;
    hence thesis;
   end;
end;

registration let N be set;
 let S be standard-ins non empty AMI-Struct over N;
 let x be Instruction of S;
 cluster InsCode x -> natural;
 coherence
  proof
    consider X being non empty set such that
W:   the Instructions of S c= [:NAT,X*:] by Def32;
   x in the Instructions of S;
   then x`1 in NAT by W,MCART_1:10;
   hence thesis;
  end;
end;

registration
  let N;
  cluster IC-Ins-separated definite standard-ins (non empty stored-program
    AMI-Struct over N);
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration
  let N be set, S be standard-ins AMI-Struct over N;
  cluster the Instructions of S -> Relation-like;
  coherence;
end;

definition
  let N be set, S be standard-ins AMI-Struct over N;
  func InsCodes S equals
  dom the Instructions of S;
  correctness;
end;

definition
  let N be set, S be standard-ins AMI-Struct over N;
  mode InsType of S is Element of InsCodes S;
end;

definition
  let N be set, S be standard-ins AMI-Struct over N;
  let I be Element of the Instructions of S;
  redefine func InsCode I -> InsType of S;
  coherence by MCART_1:91;
end;

theorem
  for N being set, S being AMI-Struct over N for x being finite
  Element of sproduct the Object-Kind of S holds x in FinPartSt S;

begin :: On the instruction locations

definition
  let N be set, S be AMI-Struct over N;
  mode IL-FinSequence of S -> FinSequence of NAT means
    :Def34:
    not
    contradiction;
  existence;
end;

reserve
  N for set,
  S for non empty AMI-Struct over N;

definition
  let N,S;
  let f be IL-FinSequence of S;
  let x be set;
  func f/.x -> Instruction-Location of S equals
  f/.x; :: przeplot, A.T.
  coherence by Def4;
end;

definition
  let N,S;
  let l1 be Instruction-Location of S;
  redefine func <*l1*> -> IL-FinSequence of S;
  coherence
  proof
    reconsider l1 as Element of NAT by ORDINAL1:def 13;
    <*l1*> is FinSequence of NAT;
    hence thesis by Def34;
  end;
  let l2 be Instruction-Location of S;
  redefine func <*l1,l2*> -> IL-FinSequence of S;
  coherence
  proof
    reconsider l1,l2 as Element of NAT by ORDINAL1:def 13;
    <*l1,l2*> is FinSequence of NAT;
    hence thesis by Def34;
  end;
end;

registration
  let N,S;
  cluster non empty IL-FinSequence of S;
  existence
  proof
    consider l being Instruction-Location of S;
    take a = <*l*>;
    thus thesis;
  end;
end;

definition
  let N,S;
  let f1,f2 be IL-FinSequence of S;
  redefine func f1^'f2 -> IL-FinSequence of S;
  coherence
  proof
    f1^'f2 is FinSequence of NAT;
    hence thesis by Def34;
  end;
end;

definition
  let D be set;
  let N, S;
  mode IL-Function of D,S -> Function of D, NAT means
    not contradiction;
  existence;
end;

definition
  let D be non empty set;
  let N,S;
  let f be IL-Function of D,S, d be Element of D;
  redefine func f.d -> Instruction-Location of S;
  correctness
  proof
    f.d is Element of NAT;
    hence thesis by Def4;
  end;
end;

definition
  let N,S;
  mode IL-DecoratedTree of S -> DecoratedTree of NAT means
    not contradiction;
  existence;
end;

definition
  let N,S;
  let T be IL-DecoratedTree of S;
  let x be set such that
A1: x in dom T;
  func T.x -> Instruction-Location of S equals
  T.x;
  coherence
  proof
    reconsider x as Element of dom T by A1;
    T.x is Element of NAT;
    hence thesis by Def4;
  end;
end;

scheme
  NATFraenkelFin { N() -> set, S() -> non empty
  stored-program AMI-Struct over N(), X() -> set, F(set) -> set }: { F(w)
  where w is Instruction-Location of S(): w in X() } is finite
provided
A1: X() is finite
proof
  set M = { F(w) where w is Instruction-Location of S(): w in X() };
  consider f being Function such that
A2: dom f = X() /\ NAT and
A3: for y being set st y in X() /\ NAT holds f.y = F(y) from FUNCT_1:
  sch 3;
  M = f.:X()
  proof
    thus M c= f.:X()
    proof
      let x be set;
      assume
      x in M;
      then consider u being Instruction-Location of S() such that
A4:   x = F(u) and
A5:   u in X();
      u in NAT by Def4;
      then
A6:   u in dom f by A2,A5,XBOOLE_0:def 4;
      then f.u = F(u) by A2,A3;
      hence thesis by A4,A5,A6,FUNCT_1:def 12;
    end;
    let x be set;
    assume
    x in f.:X();
    then consider y being set such that
A7: y in dom f and
A8: y in X() and
A9: x = f.y by FUNCT_1:def 12;
    y is Element of NAT by A2,A7,XBOOLE_0:def 4;
    then reconsider y as Instruction-Location of S() by Def4;
    x = F(y) by A2,A3,A7,A9;
    hence thesis by A8;
  end;
  hence thesis by A1;
end;

scheme
  { N,D()-> set, S()-> non empty stored-program
AMI-Struct over N(), F(set) -> set, T() -> Instruction-Location of S(), P[
set,set]}: { F(i) where i is Element of D(): ex l being Instruction-Location of
S() st l = T() & P[i,l] } = { F(j) where j is Element of D(): P[j,T()] } proof
  set X = { F(i) where i is Element of D(): ex l being Instruction-Location of
  S() st l = T() & P[i,l] }, Y = { F(j) where j is Element of D(): P[j,T()] };
  thus X c= Y
  proof
    let x be set;
    assume
    x in X;
    then ex i being Element of D() st x = F(i) & ex l being
    Instruction-Location of S() st l = T() & P[i,l];
    hence thesis;
  end;
  let x be set;
  assume
  x in Y;
  then ex j being Element of D() st x = F(j) & P[j,T()];
  hence thesis;
end;

begin :: Addenda

begin :: Some Remarks on AMI-Struct, moved from AMI_3, 2007.07.22

reserve N for set;

registration

  let N be set;
  let S be AMI-Struct over N;
  cluster FinPartSt S -> non empty;
  coherence
  proof
    consider p be FinPartState of S;
    p in FinPartSt S;
    hence thesis;
  end;
end;

definition

  let N be with_non-empty_elements set;
  let S be IC-Ins-separated (non empty AMI-Struct over N);
  let l be Instruction-Location of S;
  func Start-At l -> FinPartState of S equals
  IC S .--> l;
  correctness
  proof
A:   l in NAT by ORDINAL1:def 13;
    ObjectKind IC S = NAT by Def11;
    hence thesis by Th59,A;
  end;
end;

reserve N for with_non-empty_elements set;

registration
  let N be set;
  let S be AMI-Struct over N;
  cluster NAT-defined FinPartState of S;
  existence
  proof
    reconsider Z = {} as FinPartState of S by CARD_3:66;
    take Z;
    thus dom Z c= NAT by RELAT_1:60,XBOOLE_1:2;
  end;
end;

theorem Th78:
  for N being set for S being AMI-Struct over N for p1,p2 being
  NAT-defined PartState of S holds p1 +* p2 is NAT-defined
proof
  let N be set, S be AMI-Struct over N;
  let p1,p2 be NAT-defined PartState of S;
A1: dom(p1 +* p2) = dom p1 \/ dom p2 by FUNCT_4:def 1;
  dom p1 c= NAT & dom p2 c= NAT by RELAT_1:def 18;
  hence dom(p1 +* p2) c= NAT by A1,XBOOLE_1:8;
end;

theorem
  for S being AMI-Struct over N, s being State of S holds dom s
  = the carrier of S by L79;

theorem Th80:
  for S being AMI-Struct over N, p being PartState of S holds
  dom p c= the carrier of S
proof
  let S be AMI-Struct over N, p be PartState of S;
  dom p c= dom the Object-Kind of S by CARD_3:65;
  hence thesis by FUNCT_2:def 1;
end;

theorem Th81:
  for S being steady-programmed IC-Ins-separated definite (non
empty stored-program AMI-Struct over N) for p being NAT-defined FinPartState
  of S for s being State of S st p c= s for k holds p c= Computation(s,k)
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let p be NAT-defined FinPartState of S, s be State of S such that
A1: p c= s;
  let k;
A2: dom p c= NAT by RELAT_1:def 18;
A3: now
    let x be set;
    assume
A4: x in dom p;
    then reconsider l = x as Instruction-Location of S by A2,Def4;
    s.x = ( Computation(s,k)).l by Th54;
    hence p.x = ( Computation(s,k)).x by A1,A4,GRFUNC_1:8;
  end;
  dom s = the carrier of S by L79
    .= dom( Computation(s,k)) by L79;
  then dom p c= dom( Computation(s,k)) by A1,GRFUNC_1:8;
  hence thesis by A3,GRFUNC_1:8;
end;

definition
  canceled;
  let N;
  let S be IC-Ins-separated (non empty AMI-Struct over N);
  let s be State of S, l be Element of NAT;
  pred s starts_at l means
  IC s = l;
end;

definition
  let N;
  let S be IC-Ins-separated halting (non empty AMI-Struct over N);
  let s be State of S, l be set;
  pred s halts_at l means
  :Def42:
  s.l = halt S;
end;

definition
  let N;
  let S be IC-Ins-separated (non empty AMI-Struct over N);
  let p be FinPartState of S such that
A1: IC S in dom p;
  func IC p -> Instruction-Location of S equals
  :Def43:
  p.IC S;
  coherence
  proof
    consider s being State of S such that
A2: p c= s by CARD_3:97;
    IC s is Instruction-Location of S;
    hence thesis by A1,A2,GRFUNC_1:8;
  end;
end;

definition
  let N;
  let S be definite IC-Ins-separated (non empty stored-program AMI-Struct over
  N);
  let p be FinPartState of S, l be Element of NAT;
  pred p starts_at l means
  IC S in dom p & IC p = l;
end;

definition
  let N;
  let S be definite IC-Ins-separated halting (non empty stored-program
  AMI-Struct over N);
  let p be FinPartState of S, l be set;
  pred p halts_at l means
  l in dom p & p.l = halt S;
end;

canceled;

theorem Th83:
  for S being IC-Ins-separated definite steady-programmed halting
(non empty stored-program AMI-Struct over N), s being State of S
 holds ProgramPart s halts_on s iff ex k st s halts_at IC Computation(s,k)
proof
  let S be IC-Ins-separated definite steady-programmed halting (non empty
  stored-program AMI-Struct over N);
  let s be State of S;
  hereby
    assume ProgramPart s halts_on s;
    then consider k such that
     IC Computation(s,k) in dom ProgramPart s and
A1:  (ProgramPart s).IC Computation(s,k) = halt S by Def20;
    take k;
    (ProgramPart s).IC Computation(s,k) = CurInstr(Computation(s,k)) by LmX;
    then s.IC Computation(s,k) = halt S by A1,Th54;
    hence s halts_at IC Computation(s,k) by Def42;
  end;
  given k such that
A2: s halts_at IC Computation(s,k);
  take k;
   IC Computation(s,k) in NAT by Def4;
  hence IC Computation(s,k) in dom ProgramPart s by LmU;
   CurInstr( Computation(s,k)) = s.IC Computation(s,k) by Th54
    .= halt S by A2,Def42;
  hence (ProgramPart s).IC Computation(s,k) = halt S by LmX;
end;

theorem
  for S being IC-Ins-separated definite steady-programmed halting (non
  empty stored-program AMI-Struct over N), s being State of S, p being
  FinPartState of S, l being Instruction-Location of S st p c= s & p halts_at l
  holds s halts_at l
proof
  let S be IC-Ins-separated definite steady-programmed halting (non empty
  stored-program AMI-Struct over N);
  let s be State of S, p be FinPartState of S, l be Instruction-Location of S
  such that
A1: p c= s;
  assume
  l in dom p & p.l = halt S;
  hence s.l = halt S by A1,GRFUNC_1:8;
end;

theorem Th85:
  for S being halting steady-programmed IC-Ins-separated definite
(non empty stored-program AMI-Struct over N), s being State of S, k
 st ProgramPart s halts_on s
 holds Result s = Computation(s,k) iff s halts_at IC Computation(s,k)
proof
  let S be halting steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S, k such that
A1: ProgramPart s halts_on s;
  hereby
    assume
    Result s = Computation(s,k);
    then
    ex i st Computation(s,k) = Computation(s,i) & CurInstr( Computation(s,
    k)) = halt S by A1,Def22;
    then s.IC Computation(s,k) = halt S by Th54;
    hence s halts_at IC Computation(s,k) by Def42;
  end;
  assume
  s.IC Computation(s,k) = halt S;
  then CurInstr( Computation(s,k)) = halt S by Th54;
  hence thesis by A1,Def22;
end;

theorem
  for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N), s being State of S, p being NAT-defined
  FinPartState of S, k holds p c= s iff p c= Computation(s,k)
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S, p be NAT-defined FinPartState of S, k;
  dom( Computation(s,k)) = the carrier of S by L79;
  then
A1: dom p c= dom( Computation(s,k)) by Th80;
A2: dom p c= NAT by RELAT_1:def 18;
A3: now
    hereby
      assume
A4:   for x being set st x in dom p holds p.x = s.x;
      let x be set;
      assume
A5:   x in dom p;
      then reconsider l = x as Instruction-Location of S by A2,Def4;
      thus Computation(s,k).x = s.l by Th54
        .= p.x by A4,A5;
    end;
    assume
A6: for x being set st x in dom p holds p.x = Computation(s,k).x;
    let x be set;
    assume
A7: x in dom p;
    then reconsider l = x as Instruction-Location of S by A2,Def4;
    thus s.x = Computation(s,k).l by Th54
      .= p.x by A6,A7;
  end;
  dom s = the carrier of S by L79;
  then dom p c= dom s by Th80;
  hence thesis by A1,A3,GRFUNC_1:8;
end;

theorem Th87:
  for S being halting steady-programmed IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N), s being State of S, k st s
  halts_at IC Computation(s,k) holds Result s = Computation(s,k)
proof
  let S be halting steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N), s be State of S, k;
  assume
A1: s halts_at IC Computation(s,k);
  then ProgramPart s halts_on s by Th83;
  hence thesis by A1,Th85;
end;

theorem Th88:
  i <= j implies for S being halting steady-programmed
IC-Ins-separated definite (non empty stored-program AMI-Struct over N) for s
  being State of S st s halts_at IC Computation(s,i) holds s halts_at IC
  Computation(s,j)
proof
  assume
A1: i <= j;
  let S be halting steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S;
  assume
A2: s.IC Computation(s,i) = halt S;
  then CurInstr Computation(s,i) = halt S by Th54;
  hence s.IC Computation(s,j) = halt S by A1,A2,Th52;
end;

theorem :: AMI_1:46
  i <= j implies for S being halting steady-programmed IC-Ins-separated
definite (non empty stored-program AMI-Struct over N) for s being State of S
  st s halts_at IC Computation(s,i) holds Computation(s,j) = Computation(s,i)
proof
  assume
A1: i <= j;
  let S be halting steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N), s be State of S;
  assume
A2: s halts_at IC Computation(s,i);
  then s halts_at IC Computation(s,j) by A1,Th88;
  hence Computation(s,j) = Result s by Th87
    .= Computation(s,i) by A2,Th87;
end;

theorem
  for S being steady-programmed IC-Ins-separated halting definite (non
empty stored-program AMI-Struct over N) for s being State of S st ex k st s
  halts_at IC Computation(s,k) for i holds Result s = Result Computation(s,i)
proof
  let S be steady-programmed IC-Ins-separated halting definite (non empty
  stored-program AMI-Struct over N), s be State of S;
  given k such that
A1: s halts_at IC Computation(s,k);
  let i;
  s.IC Computation(s,k) = halt S by A1,Def42;
  hence thesis by Th57;
end;

theorem
  for S being steady-programmed IC-Ins-separated definite halting (non
  empty stored-program AMI-Struct over N) for s being State of S,l being
Instruction-Location of S,k holds s halts_at l iff Computation(s,k) halts_at l
proof
  let S be steady-programmed IC-Ins-separated definite halting (non empty
  stored-program AMI-Struct over N), s be State of S, l be
  Instruction-Location of S,k;
  hereby
    assume
    s halts_at l;
    then s.l = halt S by Def42;
    then Computation(s,k).l = halt S by Th54;
    hence Computation(s,k) halts_at l by Def42;
  end;
  assume
  Computation(s,k).l = halt S;
  hence s.l = halt S by Th54;
end;

theorem
  for S being definite IC-Ins-separated (non empty stored-program
  AMI-Struct over N), p being FinPartState of S, l being Element of NAT st p
  starts_at l for s being State of S st p c= s holds s starts_at l
proof
  let S be definite IC-Ins-separated (non empty stored-program AMI-Struct over
  N), p be FinPartState of S, l be Element of NAT such that
A1: IC S in dom p and
A2: IC p = l;
  let s be State of S;
  assume
  p c= s;
  hence IC s = p.IC S by A1,GRFUNC_1:8
    .= l by A1,A2,Def43;
end;

definition
  let N;
  let S be definite IC-Ins-separated (non empty stored-program AMI-Struct over
  N);
  let l be Instruction-Location of S, I be Element of the Instructions of S;
  redefine func l .--> I -> NAT-defined FinPartState of S;
  coherence
  proof
    ObjectKind l = the Instructions of S by Def14;
    then reconsider L = l .--> I as FinPartState of S by Th59;
    l in NAT & dom L = {l} by Def4,FUNCOP_1:19;
    then dom L c= NAT by ZFMISC_1:37;
    hence thesis by RELAT_1:def 18;
  end;
end;

:: from SCM_1, 2007.07.22, A.T.

definition

  let N be with_non-empty_elements set;
  let S be halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let s be State of S such that
A1: ProgramPart s halts_on s;
  func LifeSpan s -> Element of NAT means
  :Def46:
  CurInstr Computation(s,it) =
  halt S & for k being Element of NAT st CurInstr( Computation(s,k)) = halt S
  holds it <= k;
  existence
  proof
    defpred X[Nat] means CurInstr( Computation(s,$1))=halt S;
    consider k such that IC Computation(s,k) in dom ProgramPart s and
W:   (ProgramPart s).IC Computation(s,k) = halt S by A1,Def20;
    (ProgramPart s).IC Computation(s,k) = CurInstr(Computation(s,k)) by LmX;
    then
A2: ex k being Nat st X[k] by W;
    consider k being Nat such that
A3: X[k] & for n being Nat st X[n] holds k <= n from NAT_1:sch 5(A2);
    reconsider k as Element of NAT by ORDINAL1:def 13;
    take k;
    thus thesis by A3;
  end;
  uniqueness
  proof
    let it1, it2 be Element of NAT;
    assume
A4: not thesis;
    then it1 <= it2 & it2 <= it1;
    hence contradiction by A4,XXREAL_0:1;
  end;
end;

theorem
  for N being non empty with_non-empty_elements set,
      S be IC-Ins-separated definite halting steady-programmed
       (non empty stored-program AMI-Struct over N),
      s being State of S, m being Element of NAT
   holds ProgramPart s halts_on s iff ProgramPart s halts_on Computation(s,m)
proof
  let N be non empty with_non-empty_elements set;
  let S be IC-Ins-separated definite halting steady-programmed
   (non empty stored-program
  AMI-Struct over N), s be State of S, m be Element of NAT;
  hereby
    assume
    ProgramPart s halts_on s;
    then consider n being Element of NAT such that
W0:  IC Computation(s,n) in dom ProgramPart s and
W:   ( ProgramPart s).IC Computation(s,n) = halt S by Def20;
A1: CurInstr( Computation(s,n)) = halt S by W,LmX;
    per cases;
    suppose
      n <= m;
      then
A:     Computation(s,n) = Computation(s,m+0) by A1,Th52
        .= Computation(Computation(s,m),0) by Th51;
       ProgramPart Computation(s,m) = ProgramPart s by LmY;
      hence ProgramPart s halts_on Computation(s,m) by Def20,W,W0,A;
    end;
    suppose
      n >= m;
      then reconsider k = n - m as Element of NAT by INT_1:18;
A:    Computation(Computation(s,m),k) = Computation(s,m+k) by Th51
        .= Computation(s,n);
     ProgramPart Computation(s,m) = ProgramPart s by LmY;
     hence ProgramPart s halts_on Computation(s,m)
      by Def20,W0,W,A;
    end;
  end;
  given n being Element of NAT such that
W1: IC Computation(Computation(s,m),n) in dom ProgramPart s and
W2: (ProgramPart s).IC Computation(Computation(s,m),n) = halt S;
  take m+n;
   ProgramPart Computation(s,m) = ProgramPart s by LmY;
  hence IC Computation(s,m+n) in dom ProgramPart s &
   (ProgramPart s).IC Computation(s,m+n) = halt S by W1,W2,Th51;
end;

:: from AMI_5, 2007.07.22, A.T.

reserve N for with_non-empty_elements set,
  S for IC-Ins-separated (non empty
  AMI-Struct over N);

theorem Th94:
  for s being State of S holds IC S in dom s
proof
  let s be State of S;
  dom s = the carrier of S by L79;
  hence thesis;
end;

theorem
  for s being State of S holds Start-At(IC s) = s | {IC S}
proof
  let s be State of S;
A1: IC S in dom s by Th94;
  thus Start-At(IC s) = {[IC S,s.IC S]} by FUNCT_4:87
    .= s | {IC S} by A1,GRFUNC_1:89;
end;

canceled;

theorem
  for p being FinPartState of S, s being State of S st IC S in dom p & p
  c= s holds IC p = IC s
proof
  let p be FinPartState of S, s be State of S;
  assume that
A1: IC S in dom p and
A2: p c= s;
  thus IC p = p.IC S by A1,Def43
    .= IC s by A1,A2,GRFUNC_1:8;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let p be NAT-defined FinPartState of S, loc be set;
  assume
A1: loc in dom p;
  func pi (p, loc) -> Instruction of S equals
  p.loc;
  coherence
  proof
    dom p c= NAT by RELAT_1:def 18;
    then reconsider loc as Instruction-Location of S by A1,Def4;
    consider s be State of S such that
A2: p c= s by CARD_3:97;
    s.loc = p.loc by A1,A2,GRFUNC_1:8;
    hence thesis;
  end;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  let p be PartState of S;
  func ProgramPart p equals
  p | NAT;
  coherence;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  let p be PartState of S;
  redefine func ProgramPart p -> PartState of S;
  coherence by CARD_3:80,RELAT_1:88;
end;

registration
  let N be set;
  let S be AMI-Struct over N;
  let p be FinPartState of S;
  cluster ProgramPart p -> finite;
  coherence by FINSET_1:13,RELAT_1:88;
end;

registration
  let N be set;
  let S be AMI-Struct over N;
  let p be PartState of S;
  cluster ProgramPart p -> NAT-defined PartState of S;
  coherence
  proof
    reconsider q = p | NAT as PartState of S by CARD_3:80,RELAT_1:88;
    dom q = dom p /\ NAT by RELAT_1:90;
    then dom q c= NAT by XBOOLE_1:17;
    hence thesis by RELAT_1:def 18;
  end;
end;

definition
  let N be set;
  let S be non empty AMI-Struct over N;
  let p be PartState of S;
canceled;
  func DataPart p -> PartState of S equals
  p | Data-Locations S;
  coherence by CARD_3:80,RELAT_1:88;
  projectivity by RELAT_1:101;
end;

registration
  let N be set;
  let S be non empty AMI-Struct over N;
  let p be FinPartState of S;
  cluster DataPart p -> finite;
  coherence by FINSET_1:13,RELAT_1:88;
end;

definition
  let N be set, S be non empty AMI-Struct over N;
  let IT be PartState of S;
  attr IT is data-only means
  :Def50:
  dom IT misses {IC S} \/ NAT;
end;

registration
  let N be set, S be non empty AMI-Struct over N;
  cluster data-only FinPartState of S;
  existence
  proof
    consider p being FinPartState of S;
    {} c= p by XBOOLE_1:2;
    then reconsider p = {} as FinPartState of S by CARD_3:80;
    take p;
    thus dom p misses {IC S} \/ NAT by RELAT_1:60,XBOOLE_1:65;
  end;
end;

canceled;

theorem
  for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for p being FinPartState of S, s being
  State of S st p c= s for i being Element of NAT holds ProgramPart p c=
  Computation(s,i)
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let p be FinPartState of S, s be State of S such that
A1: p c= s;
  let i be Element of NAT;
  ProgramPart p c= p by RELAT_1:88;
  then ProgramPart p c= s by A1,XBOOLE_1:1;
  hence thesis by Th81;
end;

theorem Th100:
  for N being set, S being non empty AMI-Struct over N for
  p being FinPartState of S holds not IC S in dom DataPart p
proof
  let N be set, S be non empty AMI-Struct over N;
  let p be FinPartState of S;
  assume
A1: IC S in dom (DataPart p);
  dom(DataPart p) c= ((the carrier of S) \ ({IC S} \/ NAT)) by RELAT_1:87;
  then not IC S in {IC S} \/ NAT by A1,XBOOLE_0:def 5;
  then not IC S in {IC S} by XBOOLE_0:def 3;
  hence contradiction by TARSKI:def 1;
end;

theorem Th101:
  for S being IC-Ins-separated definite realistic (non empty
stored-program AMI-Struct over N) for p being FinPartState of S holds not IC
  S in dom (ProgramPart p)
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  AMI-Struct over N);
  let p be FinPartState of S;
  assume
A1: IC S in dom (ProgramPart p);
  dom(ProgramPart p) c= NAT by RELAT_1:87;
  then reconsider l = IC S as Instruction-Location of S by A1,Def4;
  not l in dom ProgramPart p by Th48;
  hence contradiction by Th48;
end;

theorem
  for N being set, S being non empty AMI-Struct over N for p being
  FinPartState of S holds {IC S} misses dom DataPart p by Th100,ZFMISC_1:56;

theorem
  for S being IC-Ins-separated definite realistic (non empty
stored-program AMI-Struct over N) for p being FinPartState of S holds {IC S}
  misses dom (ProgramPart p) by Th101,ZFMISC_1:56;

theorem Th104:
  for p,q being FinPartState of S holds dom DataPart p misses dom
  ProgramPart q
proof
  let p,q be FinPartState of S;
  ((the carrier of S) \ ({IC S} \/ NAT)) c= (the carrier of S) \ NAT & dom(
DataPart p) c= ((the carrier of S) \ ({IC S} \/ NAT))
 by RELAT_1:87,XBOOLE_1:7 ,34;
  then
A1: dom(DataPart p) c= (the carrier of S) \ NAT by XBOOLE_1:1;
  dom ProgramPart q c= NAT by RELAT_1:87;
  hence thesis by A1,XBOOLE_1:64,79;
end;

theorem Th105:
  for p being NAT-defined FinPartState of S holds ProgramPart p = p
proof
  let p be NAT-defined FinPartState of S;
A1: dom p c= dom ProgramPart p
  proof
    let x be set;
A2: dom ProgramPart p = dom p /\ NAT & dom p c= NAT by RELAT_1:90,def 18;
    assume
    x in dom p;
    hence thesis by A2,XBOOLE_0:def 4;
  end;
  ProgramPart p c= p by RELAT_1:88;
  then dom ProgramPart p c= dom p by GRFUNC_1:8;
  then dom ProgramPart p = dom p by A1,XBOOLE_0:def 10;
  hence thesis by GRFUNC_1:9,RELAT_1:88;
end;

theorem
  for p being FinPartState of S, l being Instruction-Location of S st l
  in dom p holds l in dom ProgramPart p
proof
  let p be FinPartState of S, l be Instruction-Location of S;
A1: dom ProgramPart p = dom p /\ NAT by RELAT_1:90;
A:   l in NAT by ORDINAL1:def 13;
  assume
  l in dom p;
  hence thesis by A1,XBOOLE_0:def 4,A;
end;

theorem
  for p being data-only FinPartState of S, q being FinPartState of S
  holds p c= q iff p c= DataPart(q)
proof
  let p be data-only FinPartState of S, q be FinPartState of S;
  set X = (the carrier of S) \ ({IC S} \/ NAT);
A1: q|X c= q by RELAT_1:88;
  hereby
    X \/ ({IC S} \/ NAT) = (the carrier of S) \/ ({IC S} \/ NAT) by XBOOLE_1
    :39;
    then
A2: dom p c= X \/ ({IC S} \/ NAT) by Th80,XBOOLE_1:10;
    assume
    p c= q;
    then
A3: p|X c= DataPart q by RELAT_1:105;
    dom p misses {IC S} \/ NAT by Def50;
    hence p c= DataPart q by A3,A2,RELAT_1:97,XBOOLE_1:73;
  end;
  assume
  p c= DataPart q;
  hence thesis by A1,XBOOLE_1:1;
end;

theorem
  for S being IC-Ins-separated definite realistic (non empty
  stored-program AMI-Struct over N) for p being FinPartState of S st IC S in
  dom p holds p = Start-At(IC p) +* ProgramPart p +* DataPart p
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  AMI-Struct over N);
  let p be FinPartState of S;
  assume
A1: IC S in dom p;
  then
A2: {IC S} is Subset of dom p by SUBSET_1:63;
A3: NAT c= the carrier of S by Def3;
A4: ({IC S} \/ (NAT) \/ ((the carrier of S) \ ({IC S} \/ NAT))) = ((the
  carrier of S) \/ ({IC S} \/ NAT)) by XBOOLE_1:39
    .= the carrier of S by A3,XBOOLE_1:8,12;
A5: dom p c= the carrier of S by Th80;
A6: now
    let x be set;
    assume
A7: x in dom p;
    then
A8: x in {IC S} \/ (NAT) or x in (the carrier of S) \ ({IC S} \/ NAT) by A5,
    A4,XBOOLE_0:def 3;
    per cases by A8,XBOOLE_0:def 3;
    suppose
A9:   x in {IC S};
      {IC S} = dom Start-At (IC p) by FUNCOP_1:19;
      then IC S in dom Start-At(IC p) by TARSKI:def 1;
      then
A10:  IC S in dom Start-At(IC p) \/ dom ProgramPart p by XBOOLE_0:
      def 3;
      then IC S in dom (Start-At(IC p) +* ProgramPart p) by
      FUNCT_4:def 1;
      then
A11:  IC S in dom (Start-At(IC p) +* ProgramPart p) \/ dom DataPart p by
      XBOOLE_0:def 3;
A12:  not IC S in dom (ProgramPart p) by Th101;
A13:  x = IC S by A9,TARSKI:def 1;
      not IC S in dom (DataPart p) by Th100;
      then
      (Start-At(IC p) +* ProgramPart p +* DataPart p).x = (Start-At(IC p)
      +* ProgramPart p).x by A13,A11,FUNCT_4:def 1
        .= (Start-At(IC p)).x by A13,A10,A12,FUNCT_4:def 1
        .= IC p by A13,FUNCOP_1:87
        .= p.IC S by A1,Def43;
      hence p.x = (Start-At(IC p) +* ProgramPart p +* DataPart p).x by A9,
      TARSKI:def 1;
    end;
    suppose
      x in (the carrier of S) \ ({IC S} \/ NAT);
      then x in dom p /\ ((the carrier of S) \ ({IC S} \/ NAT)) by A7,
      XBOOLE_0:def 4;
      then
A14:  x in dom (p | ((the carrier of S) \ ({IC S} \/ NAT))) by
      RELAT_1:90;
      then x in dom (Start-At(IC p) +* ProgramPart p) \/ dom (p | ((the
      carrier of S) \ ({IC S} \/ NAT))) by XBOOLE_0:def 3;
      then (Start-At(IC p) +* ProgramPart p +* DataPart p).x = (p | ((the
      carrier of S) \ ({IC S} \/ NAT))).x by A14,FUNCT_4:def 1
        .= p.x by A14,FUNCT_1:70;
      hence p.x = (Start-At(IC p) +* ProgramPart p +* DataPart p).x;
    end;
    suppose
      x in NAT;
      then x in dom p /\ NAT by A7,XBOOLE_0:def 4;
      then
A15:  x in dom (p | NAT) by RELAT_1:90;
      dom (DataPart p) misses dom (ProgramPart p) by Th104;
      then
A16:  not x in dom (DataPart p) by A15,XBOOLE_0:3;
A17:  x in dom (Start-At(IC p)) \/ dom (ProgramPart p) by A15, XBOOLE_0:
      def 3;
      then x in dom (Start-At(IC p) +* ProgramPart p) by FUNCT_4:def 1;
      then x in dom (Start-At(IC p) +* ProgramPart p) \/ dom (DataPart p) by
      XBOOLE_0:def 3;
      then
      (Start-At(IC p) +* ProgramPart p +* DataPart p).x = (Start-At(IC p)
      +* ProgramPart p).x by A16,FUNCT_4:def 1
        .= (p | NAT ).x by A15,A17,FUNCT_4:def 1
        .= p.x by A15,FUNCT_1:70;
      hence p.x = (Start-At(IC p) +* ProgramPart p +* DataPart p).x;
    end;
  end;
  dom (Start-At(IC p) +* ProgramPart p +* DataPart p) = dom (Start-At(IC p
  ) +* ProgramPart p) \/ dom (DataPart p) by FUNCT_4:def 1
    .= dom (Start-At(IC p)) \/ dom (ProgramPart p) \/ dom (DataPart p) by
  FUNCT_4:def 1
    .= {IC S} \/ dom (p | NAT) \/ dom(DataPart p) by FUNCOP_1:19
    .= dom p /\ {IC S} \/ dom (p|NAT) \/ dom(p|((the carrier of S) \ ({IC S}
  \/ NAT))) by A2,XBOOLE_1:28
    .= dom p /\ {IC S} \/ dom p /\ (NAT) \/ dom(p|((the carrier of S) \ ({IC
  S} \/ NAT))) by RELAT_1:90
    .= dom p /\ {IC S} \/ dom p /\ (NAT) \/ dom p /\ ((the carrier of S) \ ({
  IC S} \/ NAT)) by RELAT_1:90
    .= dom p /\ ({IC S} \/ (NAT)) \/ dom p /\ ((the carrier of S) \ ({IC S}
  \/ NAT)) by XBOOLE_1:23
    .= dom p /\ the carrier of S by A4,XBOOLE_1:23
    .= dom p by Th80,XBOOLE_1:28;
  hence thesis by A6,FUNCT_1:9;
end;

definition
  let N,S;
  let IT be PartFunc of FinPartSt S,FinPartSt S;
  attr IT is data-only means
  for p being FinPartState of S st p in dom IT
  holds p is data-only & for q being FinPartState of S st q = IT.p holds q is
  data-only;
end;

theorem
  for S being IC-Ins-separated definite realistic (non empty
  stored-program AMI-Struct over N) for p being FinPartState of S st IC S in
  dom p holds p is not NAT-defined
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  AMI-Struct over N);
  let p be FinPartState of S;
  assume
A1: IC S in dom p;
  assume
  p is NAT-defined;
  then dom p = dom ProgramPart p by Th105;
  hence contradiction by A1,Th101;
end;

definition
  let N;
  let S be AMI-Struct over N;
  let s be State of S;
  let p be PartState of S;
  redefine func s +* p -> State of S;
  coherence by CARD_3:69;
end;

theorem
  for p being FinPartState of S st IC S in dom p holds Start-At (IC p)
  c= p
proof
  let p be FinPartState of S;
  assume
A1: IC S in dom p;
  then [IC S, p.IC S] in p by FUNCT_1:8;
  then
A2: {[IC S, p.IC S]} c= p by ZFMISC_1:37;
  IC p = p.IC S by A1,Def43;
  hence thesis by A2,ZFMISC_1:35;
end;

theorem
  for s being State of S, iloc being Instruction-Location of S holds IC
  (s +* Start-At iloc ) = iloc
proof
  let s be State of S, iloc be Instruction-Location of S;
A1: IC S in {IC S} by TARSKI:def 1;
  then dom (Start-At iloc) = {IC S} & IC S in dom s \/ {IC S} by
  FUNCOP_1:19
  ,XBOOLE_0:def 3;
  hence IC (s +* Start-At iloc ) = (Start-At iloc).IC S by A1,FUNCT_4:def 1
    .= iloc by FUNCOP_1:87;
end;

theorem
  for S being IC-Ins-separated definite realistic (non empty
  stored-program AMI-Struct over N) for s being State of S, iloc being
Instruction-Location of S, a being Instruction-Location of S holds s.a = (s +*
  Start-At iloc).a
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  AMI-Struct over N);
  let s be State of S, iloc be Instruction-Location of S, a be
  Instruction-Location of S;
  a in the carrier of S;
  then a in dom s by L79;
  then
A1: dom (Start-At iloc) = {IC S} & a in dom s \/ dom (Start-At iloc) by
  FUNCOP_1:19,XBOOLE_0:def 3;
  a <> IC S by Th48;
  then not a in {IC S} by TARSKI:def 1;
  hence thesis by A1,FUNCT_4:def 1;
end;

:: from SCMFSA_2, 2007.07.22, A.T.

canceled;

theorem
  for N being with_non-empty_elements set, S
being stored-program AMI-Struct over N, s being State of S holds NAT c= dom s
proof
  let N be with_non-empty_elements set, S be
  stored-program AMI-Struct over N;
  let s be State of S;
  dom s = the carrier of S by L79;
  hence thesis by Def3;
end;

theorem
  for N being with_non-empty_elements set, S being IC-Ins-separated (non
  empty stored-program AMI-Struct over N), s being State of S holds IC s in
  dom s
proof
  let N be with_non-empty_elements set, S be IC-Ins-separated (non empty
  stored-program AMI-Struct over N);
  let s be State of S;
  dom s = the carrier of S by L79;
  hence thesis;
end;

theorem
  for N being with_non-empty_elements set, S being non empty
  stored-program AMI-Struct over N, s being State of S, l being
  Instruction-Location of S holds l in dom s
proof
  let N be with_non-empty_elements set, S be non empty stored-program
  AMI-Struct over N;
  let s be State of S, l be Instruction-Location of S;
  dom s = the carrier of S by L79;
  hence thesis;
end;

:: from SCMFSA_3, 2007.07.22, A.T.

theorem
  for N being with_non-empty_elements set for S being
  steady-programmed (non empty stored-program AMI-Struct over N) for i being
  Instruction of S, s being State of S holds Exec (i, s) | NAT = s | NAT
                 by L117;

:: from SCMFSA_4, 2007.07.22, A.T.

registration
  let N be set, S be AMI-Struct over N;
  cluster NAT-defined FinPartState of S;
  existence
  proof
    reconsider z = {} as FinPartState of S by CARD_3:66;
    take z;
    thus dom z c= NAT by RELAT_1:60,XBOOLE_1:2;
  end;
end;

theorem Th118:
  for N being with_non-empty_elements set, S being definite (non
empty stored-program AMI-Struct over N), p being NAT-defined FinPartState of
  S holds rng p c= the Instructions of S
proof
  let N be with_non-empty_elements set, S be definite (non empty
  stored-program AMI-Struct over N), p be NAT-defined FinPartState of S;
  let x be set;
  assume
  x in rng p;
  then consider y being set such that
A1: y in dom p and
A2: x = p.y by FUNCT_1:def 5;
  dom p c= NAT by RELAT_1:def 18;
  then reconsider y as Instruction-Location of S by A1,Def4;
  (the Object-Kind of S).y = ObjectKind y
    .= the Instructions of S by Def14;
  hence thesis by A1,A2,CARD_3:65;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  let I, J be NAT-defined PartState of S;
  redefine func I +* J -> NAT-defined PartState of S;
  coherence by Th78;
end;

theorem
  for N being with_non-empty_elements set, S being definite (non empty
stored-program AMI-Struct over N), f being Function of the Instructions of S
, the Instructions of S, s being NAT-defined FinPartState of S holds dom(f*s) =
  dom s
proof
  let N be with_non-empty_elements set, S be definite (non empty
  stored-program AMI-Struct over N);
  let f be Function of the Instructions of S, the Instructions of S;
  let s be NAT-defined FinPartState of S;
  dom f = the Instructions of S by FUNCT_2:def 1;
  then rng s c= dom f by Th118;
  hence thesis by RELAT_1:46;
end;

definition

  let N be non empty with_non-empty_elements set;
  let S be definite (non empty stored-program AMI-Struct over N);
  let s be NAT-defined PartState of S;
  let f be Function of the Instructions of S, the Instructions of S;
  redefine func f*s -> NAT-defined PartState of S;
  coherence
  proof
A1: dom(f*s) c= NAT by RELAT_1:def 18;
A2: now
      let x be set;
A3:   rng(f*s) c= the Instructions of S by RELAT_1:def 19;
      assume
A4:   x in dom(f*s);
      then reconsider l = x as Instruction-Location of S by A1,Def4;
A5:   (the Object-Kind of S).l = ObjectKind l
        .= the Instructions of S by Def14;
      (f*s).x in rng(f*s) by A4,FUNCT_1:def 5;
      hence (f*s).x in (the Object-Kind of S).x by A3,A5;
    end;
    dom the Object-Kind of S = the carrier of S by FUNCT_2:def 1;
    then dom(f*s) c= dom s & dom s c= dom the Object-Kind of S by Th80,
    RELAT_1:44;
    then dom(f*s) c= dom the Object-Kind of S by XBOOLE_1:1;
    then reconsider fs = f*s as PartState of S by A2,CARD_3:def 9;
    fs is NAT-defined;
    hence thesis;
  end;
end;

:: from SCMFSA6A, 2007.07.23, A.T.

theorem
  for N being set, A being AMI-Struct over N, s being State of A,
  I being NAT-defined FinPartState of A holds s,s+*I equal_outside NAT
proof
  let N be set, A be AMI-Struct over N, s be State of A, I be NAT-defined
  FinPartState of A;
  dom I c= NAT by RELAT_1:def 18;
  hence thesis by FUNCT_7:31;
end;

theorem
  for N being with_non-empty_elements set, S being realistic
  IC-Ins-separated (non empty AMI-Struct over N), s1, s2 being State of S
  holds s1,s2 equal_outside NAT implies IC s1 = IC s2
proof
  let N be with_non-empty_elements set, S be realistic IC-Ins-separated (non
  empty AMI-Struct over N), s1, s2 be State of S;
  assume
A1: s1,s2 equal_outside NAT;
A2: not IC S in NAT by Def21;
  IC S in dom s2 by Th94;
  then IC S in dom s2 \ NAT by A2,XBOOLE_0:def 5;
  then
A3: IC S in dom s2 /\ (dom s2 \ NAT) by XBOOLE_0:def 4;
  IC S in dom s1 by Th94;
  then IC S in dom s1 \ NAT by A2,XBOOLE_0:def 5;
  then IC S in dom s1 /\ (dom s1 \ NAT) by XBOOLE_0:def 4;
  hence IC s1 = (s1|(dom s1 \ NAT)).IC S by FUNCT_1:71
    .= (s2|(dom s2 \ NAT)).IC S by A1,FUNCT_7:def 2
    .= IC s2 by A3,FUNCT_1:71;
end;

:: from SCMFSA6B, 2007.07.25, A.T.

reserve m,n for Element of NAT;

theorem
  for S being halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N), s being State of S
  st ProgramPart s halts_on s
 holds Result s = Computation(s,LifeSpan s)
proof
  let S be halting IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N);
  let s be State of S;
  assume
A1: ProgramPart s halts_on s;
  then
A2: CurInstr Computation(s,LifeSpan s)= halt S by Def46;
  consider m such that
A3: Result s = Computation(s,m) and
A4: CurInstr Result s = halt S by A1,Def22;
  LifeSpan s <= m by A1,A3,A4,Def46;
  hence thesis by A2,A3,Th52;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let s be State of S, l be Instruction-Location of S, i be Instruction of S;
  redefine func s+*(l,i) -> State of S;
  coherence
  proof
A1: dom s = dom the Object-Kind of S by CARD_3:18;
A2: now
      let x be set;
      assume
A3:   x in dom the Object-Kind of S;
      per cases;
      suppose
A4:     x = l;
        then
A5:     (the Object-Kind of S).x = ObjectKind l
          .= the Instructions of S by Def14;
        (s+*(l,i)).x = i by A1,A3,A4,FUNCT_7:33;
        hence (s+*(l,i)).x in (the Object-Kind of S).x by A5;
      end;
      suppose
        x <> l;
        then (s+*(l,i)).x = s.x by FUNCT_7:34;
        hence (s+*(l,i)).x in (the Object-Kind of S).x by A3,CARD_3:18;
      end;
    end;
    dom(s+*(l,i)) = dom s by FUNCT_7:32;
    hence thesis by A1,A2,CARD_3:18;
  end;
end;

theorem
  for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for s being State of S, n holds s|NAT = (
  Computation(s,n))|NAT
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S;
  defpred X[Element of NAT] means s|NAT = ( Computation(s,$1))|NAT;
A1: now
    let n;
    assume
    X[n];
    then s|NAT = (Following( Computation(s,n)))|NAT by L117
      .= ( Computation(s,n+1))|NAT by Th14;
    hence X[n+1];
  end;
A2: X[0] by Th13;
  thus for n holds X[n] from NAT_1:sch 1(A2,A1);
end;

:: from SCMBSORT, 2007.07.26, A.T.

theorem
  for N being with_non-empty_elements set, S being steady-programmed
  IC-Ins-separated definite (non empty stored-program AMI-Struct over N), p
being NAT-defined FinPartState of S, s1,s2 being State of S
 st p c= s1 & p c= s2
  holds Computation(s1,i) | dom p = Computation(s2,i) | dom p
proof
  let N be with_non-empty_elements set, S be steady-programmed
IC-Ins-separated definite (non empty stored-program AMI-Struct over N), p be
  NAT-defined FinPartState of S, s1,s2 be State of S such that
A1: p c= s1 and
A2: p c= s2;
  set Cs2= Computation(s2,i);
  set Cs1= Computation(s1,i);
A3: now
    let x be set;
    assume
A4: x in dom p;
    dom p c= NAT by RELAT_1:def 18;
    then reconsider l=x as Instruction-Location of S by A4,Def4;
A5: s1.l = Cs1.l & s2.l = Cs2.l by Th54;
    p.x=s1.x by A1,A4,GRFUNC_1:8;
    hence Cs1.x = Cs2.x by A2,A4,A5,GRFUNC_1:8;
  end;
  dom Cs1 = the carrier of S by L79
    .=dom Cs2 by L79;
  hence thesis by A3,FUNCT_1:166;
end;

:: missing, 2007.11.13, A.T.

theorem
  for S being AMI-Struct over N, p being Element of FinPartSt S holds
  p is FinPartState of S
proof
  let S be AMI-Struct over N;
  let p be Element of FinPartSt S;
  p in FinPartSt S;
  then ex q being Element of sproduct the Object-Kind of S st q = p & q is
  finite;
  hence thesis;
end;

:: from SCMFSA8A, 2008.02.12, A.T.

theorem
  for N being with_non-empty_elements set, S
  being definite (non empty stored-program AMI-Struct over N), I being NAT
  -defined FinPartState of S, x being set holds x in dom I implies I.x is
  Instruction of S
proof

  let N be with_non-empty_elements set, S be definite (non empty
  stored-program AMI-Struct over N);
  let I be NAT-defined FinPartState of S;
  let x be set;
  assume
A1: x in dom I;
  dom I c= NAT by RELAT_1:def 18;
  then reconsider ll = x as Instruction-Location of S by A1,Def4;
  consider s being State of S;
  (s +* I).ll = I.x by A1,FUNCT_4:14;
  hence thesis;
end;

:: from SCMFSA9A, 2008.02.12, A.T.

theorem
  for N being non empty
  with_non-empty_elements set,
  S being halting IC-Ins-separated definite steady-programmed
   (non
empty stored-program AMI-Struct over N), s being State of S, k being Element
of NAT st CurInstr( Computation(s,k)) = halt S holds Computation(s,LifeSpan s)
  = Computation(s,k)
proof
  let N be non empty with_non-empty_elements set, S be halting
IC-Ins-separated definite steady-programmed
 (non empty stored-program AMI-Struct over N), s be
  State of S, k be Element of NAT such that
A1: CurInstr Computation(s,k) = halt S;
  IC Computation(s,k) in NAT by Def4;
  then
X: IC Computation(s,k) in dom ProgramPart s by LmU;
  (ProgramPart s).IC Computation(s,k) = CurInstr(Computation(s,k)) by LmX;
  then
A2: ProgramPart s halts_on s by Def20,X,A1;
  set Ls = LifeSpan s;
A3: CurInstr Computation(s,Ls) = halt S by A2,Def46;
  Ls <= k by A1,A2,Def46;
  hence thesis by A3,Th52;
end;

:: from SCMISORT, 2008.02.12, A.T.

theorem
  for N being non empty
with_non-empty_elements set
 for S being halting IC-Ins-separated definite steady-programmed
  (non
empty stored-program AMI-Struct over N) for s being State of S st (LifeSpan
  s) <= j & ProgramPart s halts_on s
   holds Computation(s,j) = Computation(s,LifeSpan s)
proof

  let N be non empty with_non-empty_elements set,
  S be halting IC-Ins-separated definite steady-programmed
 (non empty stored-program AMI-Struct over N), s be
  State of S;
  assume that
A1: (LifeSpan s) <= j and
A2: ProgramPart s halts_on s;
  CurInstr( Computation(s,LifeSpan s)) = halt S by A2,Def46;
  hence thesis by A1,Th52;
end;

:: from AMI_6, 2008.02.12, A.T.

theorem
  for N being with_non-empty_elements set, S
being realistic IC-Ins-separated definite (non empty stored-program AMI-Struct
over N), t, u being State of S, il being Instruction-Location of S, e being
Element of ObjectKind IC S, I being Element of ObjectKind il st e = il & u = t
+*((IC S, il)-->(e, I)) holds u.il = I & IC u = il & IC Following u = Exec(u.IC
  u, u).IC S
proof

  let N be with_non-empty_elements set, S be realistic IC-Ins-separated
  definite (non empty stored-program AMI-Struct over N), t, u be State of S,
il be Instruction-Location of S, e be Element of ObjectKind IC S, I be Element
  of ObjectKind il such that
A1: e = il and
A2: u = t+*((IC S, il)-->(e, I));
A3: dom ((IC S, il)-->(e, I)) = {IC S, il} by FUNCT_4:65;
  then il in dom ((IC S, il)-->(e, I)) by TARSKI:def 2;
  hence u.il = ((IC S, il)-->(e, I)).il by A2,FUNCT_4:14
    .= I by FUNCT_4:66;
  IC S in dom ((IC S, il)-->(e, I)) by A3,TARSKI:def 2;
  hence IC u = ((IC S, il)-->(e, I)).IC S by A2,FUNCT_4:14
    .= il by A1,Th48,FUNCT_4:66;
  thus thesis;
end;

:: from SCMPDS_5, 2008.02.12, A.T.

theorem
  for S being halting IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N), s being State of S st s = Following s
  holds for n holds Computation(s,n) = s
proof
  let S be halting IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N), s be State of S;
  defpred X[Element of NAT] means Computation(s,$1) = s;
  assume
  s = Following s;
  then
A1: for n st X[n] holds X[n+1] by Th14;
A2: X[0] by Th13;
  thus for n holds X[n] from NAT_1:sch 1(A2, A1);
end;

:: from SCMPDS_9, 2008.02.12, A.T.

theorem
  for N being with_non-empty_elements set, S
being IC-Ins-separated definite (non empty stored-program AMI-Struct over N)
  , s being State of S, i being Instruction of S holds Exec(s.IC s,s).IC S = IC
  Following s;

:: from SCMFSA7b, 2008.02.12, A.T.

definition

  let N be with_non-empty_elements set;
  let S be halting (AMI-Struct over N);
  let I be FinPartState of S;
  attr I is halt-free means
  not halt S in rng I;
end;

:: from SCMFSA6b, 2008.02.12, A.T.

theorem
  for N being with_non-empty_elements set, S
being IC-Ins-separated definite (non empty stored-program AMI-Struct over N)
, s being State of S holds s = Following s implies for n holds Computation(s,n)
  = s
proof
  let N be with_non-empty_elements set, S be
IC-Ins-separated definite (non empty stored-program AMI-Struct over N), s be
  State of S;
  defpred X[Nat] means Computation(s,$1) = s;
  assume
  s = Following s;
  then
A1: for n st X[n] holds X[n+1] by Th14;
A2: X[0] by Th13;
  thus for n holds X[n] from NAT_1:sch 1(A2, A1);
end;

:: from SCMRING3, 2008.02.12, A.T.

theorem
  for N being with_non-empty_elements set, S being realistic
IC-Ins-separated definite (non empty stored-program AMI-Struct over N), t, u
  being State of S, il being Instruction-Location of S, e being Element of
ObjectKind IC S, I being Element of ObjectKind il st e = il & u = t+*((IC S, il
)-->(e, I)) holds u.il = I & IC u = il & IC Following u = Exec(u.IC u, u).IC S
proof
  let N be with_non-empty_elements set, S be realistic IC-Ins-separated
  definite (non empty stored-program AMI-Struct over N), t, u be State of S,
il be Instruction-Location of S, e be Element of ObjectKind IC S, I be Element
  of ObjectKind il such that
A1: e = il and
A2: u = t+*((IC S, il)-->(e, I));
A3: dom ((IC S, il)-->(e, I)) = {IC S, il} by FUNCT_4:65;
  then il in dom ((IC S, il)-->(e, I)) by TARSKI:def 2;
  hence u.il = ((IC S, il)-->(e, I)).il by A2,FUNCT_4:14
    .= I by FUNCT_4:66;
  IC S in dom ((IC S, il)-->(e, I)) by A3,TARSKI:def 2;
  hence IC u = ((IC S, il)-->(e, I)).IC S by A2,FUNCT_4:14
    .= il by A1,Th48,FUNCT_4:66;
  thus thesis;
end;

:: missing, 2008.03.26, A.T,

theorem Th134:
  for N being with_non-empty_elements set
, S being IC-Ins-separated realistic (non empty AMI-Struct over N), l being
  Instruction-Location of S holds dom Start-At l misses NAT
proof

  let N be with_non-empty_elements set;
  let S be IC-Ins-separated realistic (non empty AMI-Struct over N);
  let l be Instruction-Location of S;
  dom Start-At l = {IC S} & not IC S in NAT by Def21,FUNCOP_1:19;
  hence thesis by ZFMISC_1:56;
end;

theorem
  for N being with_non-empty_elements set, S
  being IC-Ins-separated realistic (non empty AMI-Struct over N), l being
  Instruction-Location of S holds ProgramPart Start-At l = {}
proof

  let N be with_non-empty_elements set;
  let S be IC-Ins-separated realistic (non empty AMI-Struct over N);
  let l be Instruction-Location of S;
  dom Start-At l misses NAT by Th134;
  hence thesis by RELAT_1:187;
end;

registration
  let N be set;
  let S be non empty AMI-Struct over N;
  let p be FinPartState of S;
  cluster DataPart p -> data-only;
  coherence
  proof
    ((the carrier of S) \ ({IC S} \/ NAT)) c= (the carrier of S) \ NAT & dom
( DataPart p) c= ((the carrier of S) \ ({IC S} \/ NAT))
 by RELAT_1:87,XBOOLE_1:7,34;
    then dom(DataPart p) c= (the carrier of S) \ NAT by XBOOLE_1:1;
    then
A1: dom DataPart p misses NAT by XBOOLE_1:64,79;
    dom DataPart p misses {IC S} by Th100,ZFMISC_1:56;
    hence dom DataPart p misses {IC S} \/ NAT by A1,XBOOLE_1:70;
  end;
end;

theorem
  for N being set, S being non empty AMI-Struct over N, p be
  data-only FinPartState of S holds ProgramPart p = {}
proof
  let N be set, S be non empty AMI-Struct over N, p be data-only
  FinPartState of S;
  dom p misses {IC S} \/ NAT by Def50;
  then dom p misses NAT by XBOOLE_1:70;
  hence thesis by RELAT_1:187;
end;

theorem
  for N being with_non-empty_elements set, S
  being IC-Ins-separated realistic (non empty AMI-Struct over N), l,l1 being
  Instruction-Location of S holds not l in dom Start-At l1
proof
  let N be with_non-empty_elements set, S be
  IC-Ins-separated realistic (non empty AMI-Struct over N), l,l1 be
  Instruction-Location of S;
A: l in NAT by ORDINAL1:def 13;
  assume
  l in dom Start-At l1;
  then NAT meets dom Start-At l1 by XBOOLE_0:3,A;
  hence thesis by Th134;
end;

theorem
  for N being with_non-empty_elements set, S
  being IC-Ins-separated (non empty AMI-Struct over N), l being
  Instruction-Location of S holds DataPart Start-At l = {}
proof
  let N be with_non-empty_elements set, S be
IC-Ins-separated (non empty AMI-Struct over N), l be Instruction-Location of
  S;
  Data-Locations S misses {IC S} \/ NAT by XBOOLE_1:79;
  then Data-Locations S misses {IC S} by XBOOLE_1:70;
  then Data-Locations S misses dom Start-At l by FUNCOP_1:19;
  hence thesis by RELAT_1:95;
end;

theorem Th139:
  for S being non empty AMI-Struct over N, p being PartState
  of S holds p is data-only iff dom p c= Data-Locations S
proof
  let S be non empty AMI-Struct over N, p be PartState of S;
  thus p is data-only implies dom p c= Data-Locations S
  proof
    assume
    dom p misses {IC S} \/ NAT;
    hence thesis by Th80,XBOOLE_1:86;
  end;
  assume
  dom p c= Data-Locations S;
  hence dom p misses {IC S} \/ NAT by XBOOLE_1:106;
end;

theorem
  for S being IC-Ins-separated definite realistic (non empty
  stored-program AMI-Struct over N), s be State of S for X being set st X c=
  NAT holds rng(s|X) c= the Instructions of S
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  AMI-Struct over N);
  let s be State of S;
  let X be set such that
A1: X c= NAT;
  let x be set;
  assume
  x in rng(s|X);
  then consider y being set such that
A2: y in dom(s|X) and
A3: (s|X).y = x by FUNCT_1:def 5;
A4: dom(s|X) c= X by RELAT_1:87;
  then dom(s|X) c= NAT by A1,XBOOLE_1:1;
  then reconsider y as Instruction-Location of S by A2,Def4;
  x = s.y by A2,A3,A4,FUNCT_1:72;
  hence thesis;
end;

:: from SCMFSA8B, 2008.04.30, A.T.

theorem
  for s being State of S, l1,l2 being Instruction-Location of S holds s
  +* Start-At l1 +* Start-At l2 = s +* Start-At l2
proof
  let s be State of S;
  let l1,l2 be Instruction-Location of S;
A1: dom Start-At l1 = {IC S} by FUNCOP_1:19
    .= dom Start-At l2 by FUNCOP_1:19;
  thus s +* Start-At l1 +* Start-At l2 = s +* (Start-At l1 +* Start-At l2) by
  FUNCT_4:15
    .= s +* Start-At l2 by A1,FUNCT_4:20;
end;

:: missing, 2008.05.01, A.T.

theorem
  for S being non empty AMI-Struct over N, p being PartState of S
  holds p is data-only iff DataPart p = p
proof
  let S be non empty AMI-Struct over N, p be PartState of S;
  thus p is data-only implies DataPart p = p
  proof
    assume
    p is data-only;
    then dom p c= Data-Locations S by Th139;
    hence thesis by RELAT_1:97;
  end;
  assume
  DataPart p = p;
  then dom p c= Data-Locations S by RELAT_1:87;
  hence thesis by Th139;
end;

theorem
 for N being with_non-empty_elements set for S being
  steady-programmed (non empty stored-program AMI-Struct over N)
   for s being State of S
   holds dom ProgramPart s = NAT by LmU;

theorem
 for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for s being State of S, k
 holds ProgramPart s = ProgramPart Computation(s,k) by LmY;

theorem
 for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for s being State of S, k
 holds (ProgramPart s).IC Computation(s,k) = CurInstr(Computation(s,k)) by LmX;

theorem
 for S being steady-programmed IC-Ins-separated definite halting
  (non empty stored-program AMI-Struct over N)
   for s being State of S holds ProgramPart s halts_on s
   iff ex k st CurInstr Computation(s,k) = halt S
proof
 let S be steady-programmed IC-Ins-separated definite halting
  (non empty stored-program AMI-Struct over N);
 let s be State of S;
 thus ProgramPart s halts_on s
   implies ex k st CurInstr Computation(s,k) = halt S
  proof
   given k such that
G1: IC Computation(s,k) in dom ProgramPart s and
G2: (ProgramPart s).IC Computation(s,k) = halt S;
   take k;
   thus CurInstr Computation(s,k) = halt S by G2, LmX;
  end;
 given k such that
G: CurInstr Computation(s,k) = halt S;
 take k;
  IC Computation(s,k) in NAT by Def4;
 hence IC Computation(s,k) in dom ProgramPart s by LmU;
 thus (ProgramPart s).IC Computation(s,k) = halt S by G,LmX;
end;
