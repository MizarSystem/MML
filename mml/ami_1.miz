:: A Mathematical Model of CPU
::  by Yatsuka Nakamura and Andrzej Trybulec
::
:: Received October 14, 1992
:: Copyright (c) 1992 Association of Mizar Users

environ

 vocabularies STRUCT_0, SUBSET_1, XBOOLE_0, FUNCT_1, NUMBERS, CARD_3, ORDINAL1,
      CARD_1, FUNCOP_1, FUNCT_4, RELAT_1, TARSKI, CAT_1, FSM_1, SETFAM_1,
      GLIB_000, FINSET_1, CIRCUIT2, NAT_1, ARYTM_3, XXREAL_0, MSUALG_1,
      TURING_1, PARTFUN1, MCART_1, ZFMISC_1, GRAPHSP, ARYTM_1, FUNCT_7, AMI_1,
      PBOOLE, SCMNORM, GROUP_9, RECDEF_2, COMPOS_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, MCART_1, SUBSET_1, SETFAM_1, ORDINAL1,
      PBOOLE, NUMBERS, FUNCT_7, CARD_3, XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1,
      FINSET_1, NAT_1, FUNCOP_1, FUNCT_4, FINSEQ_1, FUNCT_2, DOMAIN_1,
      RECDEF_2, STRUCT_0, GROUP_9, XXREAL_0, COMPOS_1;
 constructors SETFAM_1, DOMAIN_1, FUNCT_4, XXREAL_0, FUNCT_7, GRAPH_2,
      RELSET_1, PRE_POLY, PBOOLE, RECDEF_2, COMPOS_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCT_2,
      FUNCOP_1, FUNCT_4, FINSET_1, XREAL_0, FINSEQ_1, CARD_3, STRUCT_0, INT_1,
      RELSET_1, GRFUNC_1, PRE_POLY, PBOOLE, COMPOS_1;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, STRUCT_0, FUNCOP_1, ORDINAL1, RELAT_1, PBOOLE, FUNCT_1,
      PARTFUN1, MCART_1, ZFMISC_1, COMPOS_1;
 theorems ZFMISC_1, FUNCT_2, TARSKI, NAT_1, CQC_LANG, CARD_3, FINSEQ_1,
      FUNCT_4, FUNCOP_1, FINSET_1, FUNCT_1, GRFUNC_1, RELAT_1, RELSET_1,
      XBOOLE_0, XBOOLE_1, ORDINAL1, MCART_1, ENUMSET1, SUBSET_1, XXREAL_0,
      FUNCT_7, INT_1, PARTFUN1, PBOOLE, RECDEF_2, FUNCT_5, COMPOS_1;
 schemes NAT_1, FRAENKEL;

begin :: General concepts

definition
  let N be set;
  struct (COM-Struct over N) AMI-Struct over N (# carrier -> set,
    Instruction-Counter -> Element of the carrier,
    Instructions -> non empty set,
    haltF -> Element of the Instructions,
    Object-Kind -> Function of the carrier, N \/ { the Instructions, NAT },
    Execution -> Action of the Instructions, product the Object-Kind
     #);
end;

definition
  let N be set;
  canceled;
  func Trivial-AMI N -> strict AMI-Struct over N means
:Def2:
  the carrier of it = succ NAT & the Instruction-Counter of it = NAT &
  the Instructions of it = {[0,{},{}]} &
  the haltF of it = [0,{},{}] &
  the Object-Kind of it = (NAT --> {[0,{},{}]}) +* (NAT .--> NAT) &
  the Execution of it
    = [0,{},{}] .--> id product((NAT --> {[0,{},{}]}) +* (NAT .--> NAT));
  existence
  proof
    reconsider I = {[0,{},{}]} as non empty set;
    reconsider i = [0,{},{}] as Element of I by TARSKI:def 1;
    set f = (NAT --> I) +* (NAT .--> NAT);
A1: dom f = dom(NAT --> I) \/ dom(NAT .--> NAT) by FUNCT_4:def 1
      .= NAT \/ dom(NAT .--> NAT) by FUNCOP_1:19
      .= succ NAT by FUNCOP_1:19;
    rng(NAT --> I) c= {I} & rng(NAT .--> NAT) c= {NAT} by FUNCOP_1:19;
    then rng(NAT --> I) \/ rng(NAT .--> NAT) c= {I} \/ {NAT} by XBOOLE_1:13;
    then rng f c= rng(NAT --> I) \/ rng(NAT .--> NAT) &
     rng(NAT --> I) \/ rng(NAT .--> NAT) c= { I,NAT} by ENUMSET1:41,FUNCT_4:18;
    then
A2: rng f c= { I,NAT} by XBOOLE_1:1;
    { I,NAT } c= N \/ {I, NAT} by XBOOLE_1:7;
    then rng f c= N \/ {I, NAT} by A2,XBOOLE_1:1;
    then reconsider f as Function of succ NAT, N \/ {I, NAT} by A1,
FUNCT_2:def 1,RELSET_1:11;
    reconsider y = NAT as Element of succ NAT by ORDINAL1:10;
    reconsider E = I --> id product f as Action of I, product f
       by FUNCOP_1:57,FUNCT_2:12;
    take S=AMI-Struct(#succ NAT,y,I,i,f,E #);
    thus thesis;
  end;
  uniqueness;
end;

registration
  let N be set;
  cluster Trivial-AMI N-> non empty stored-program;
  coherence
  proof
    set S = Trivial-AMI N;
A1: the carrier of S = succ NAT by Def2;
    thus the carrier of S is non empty by Def2;
    thus NAT c= the carrier of S by A1,XBOOLE_1:7;
  end;
end;

registration
  let N be set;
  cluster non empty stored-program AMI-Struct over N;
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

definition
 canceled 4;
  let N be with_non-empty_elements set;
  let S be AMI-Struct over N;
  let I be Instruction of S, s be State of S;
  func Exec(I,s) -> State of S equals
  ((the Execution of S).I).s;
  coherence
  proof
    consider f being Function such that
A1: (the Execution of S).I = f & dom f = product the Object-Kind of S and
A2: rng f c= product the Object-Kind of S by FUNCT_2:def 2;
   reconsider s as Element of product the Object-Kind of S by PBOOLE:155;
    (the Execution of S).I.s in rng f by A1,FUNCT_1:def 5;
    hence thesis by A2;
  end;
end;

reserve N for with_non-empty_elements set;

definition
  let N;
  let S be AMI-Struct over N;
  let I be Instruction of S;
  attr I is halting means
:Def8:
  for s being State of S holds Exec(I,s) = s;
end;

definition
  let N;
  let S be AMI-Struct over N;
  attr S is halting means
:Def9: the haltF of S is halting;
end;

definition
 canceled;
end;

registration
  let N;
  cluster Trivial-AMI N -> halting;
  coherence
proof
  set T = Trivial-AMI N;
  set f = (NAT --> {[0,{},{}]}) +* (NAT .--> NAT);
A1: product the Object-Kind of T = product f by Def2;
  set I = the haltF of T;
A2: I = [0,{},{}] by Def2;
  let s be State of T;
   reconsider ss=s as Element of product the Object-Kind of T by PBOOLE:155;
  (I .--> id product f).I = id product f by FUNCOP_1:87;
  hence Exec(I,s) = (id product f).ss by A2,Def2
    .= s by A1,FUNCT_1:35;
end;
end;

registration
  let N;
  cluster halting AMI-Struct over N;
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration
  let N;
  let S be halting (AMI-Struct over N);
  cluster halt S -> halting;
  coherence by Def9;
end;

registration
  let N;
  let S be halting (AMI-Struct over N);
  cluster halting Instruction of S;
  existence
   proof
    take halt S;
    thus thesis;
   end;
end;

definition
 canceled 2;
  let N be with_non-empty_elements set;
  let IT be non empty AMI-Struct over N;
  attr IT is steady-programmed means
  :Def13:
  for s being State of IT, i being Instruction of IT,
      l being Element of NAT
   holds Exec(i,s).l = s.l;
end;

canceled 8;

theorem Th9:
  for s being State of Trivial-AMI N, i being Instruction of
  Trivial-AMI N holds Exec(i,s) = s
proof
  set T = Trivial-AMI N;
  let s be State of Trivial-AMI N, i be Instruction of Trivial-AMI N;
  set f = (NAT --> {[0,{},{}]}) +* (NAT .--> NAT);
A1: product the Object-Kind of T = product f by Def2;
   reconsider ss=s as Element of product the Object-Kind of T by PBOOLE:155;
  the Instructions of T = {[0,{},{}]} by Def2;
  then (i .--> id product f).i = id product f & i = [0,{},{}] by FUNCOP_1:87
,TARSKI:def 1;
  hence Exec(i,s) = (id product f).ss by Def2
    .= s by A1,FUNCT_1:35;
end;

registration
  let E be set;
  cluster Trivial-AMI E -> IC-Ins-separated definite;
  coherence
   proof
  thus Trivial-AMI E is IC-Ins-separated
proof
  dom(NAT .--> NAT) = {NAT} by FUNCOP_1:19;
  then
A1: NAT in dom(NAT .--> NAT) by TARSKI:def 1;
  IC Trivial-AMI E = NAT by Def2;
  hence ObjectKind IC Trivial-AMI E
   = ((NAT --> {[0,{},{}]}) +* (NAT .--> NAT)).
  NAT by Def2
    .= (NAT .--> NAT).NAT by A1,FUNCT_4:14
    .= NAT by FUNCOP_1:87;
end;
  let l be Element of NAT;
A1: l in NAT;
  now
    assume l in {NAT};
    then l = NAT by TARSKI:def 1;
    hence contradiction by A1;
  end;
  then
A2: not l in dom(NAT .--> NAT) by FUNCOP_1:19;
  thus (the Object-Kind of Trivial-AMI E).l
     = ((NAT --> {[0,{},{}]}) +* (NAT .--> NAT)).l by Def2
    .= (NAT --> {[0,{},{}]}).l by A2,FUNCT_4:12
    .= {[0,{},{}]} by FUNCOP_1:13
    .= the Instructions of Trivial-AMI E by Def2;
   end;
end;

registration

  let N be with_non-empty_elements set;
  cluster Trivial-AMI N -> steady-programmed;
  coherence
proof
  let s be State of Trivial-AMI N, i be Instruction of Trivial-AMI N,
  l be Element of NAT;
  thus thesis by Th9;
end;
end;

registration
  let M be set;
  cluster IC-Ins-separated definite strict (non empty stored-program
    AMI-Struct over M);
  existence
  proof
    take Trivial-AMI M;
    thus thesis;
  end;
end;

registration
  let N;
  cluster IC-Ins-separated halting steady-programmed definite strict (non
    empty stored-program AMI-Struct over N);
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

canceled 2;

theorem
  for s1, s2 being State of Trivial-AMI N st IC s1 = IC s2 holds s1=
  s2
proof
  set T = Trivial-AMI N;
  let s1,s2 be State of Trivial-AMI N such that
A1: IC s1 = IC s2;
A2: dom s1 = the carrier of T by PARTFUN1:def 4;
A3: now
    let x be set;
    assume
A4: x in dom s1;
    dom s1 = the carrier of T by PARTFUN1:def 4
      .= succ NAT by Def2;
    then
A5: x in NAT or x in {NAT} by A4,XBOOLE_0:def 3;
    per cases by A5,TARSKI:def 1;
    suppose
A6:   x in NAT;
      then x <> NAT;
      then not x in {NAT} by TARSKI:def 1;
      then
A7:   not x in dom(NAT .--> NAT) by FUNCOP_1:19;
A8:   (the Object-Kind of T).x = ((NAT --> {[0,{},{}]}) +* (NAT .--> NAT)).x
by Def2
        .= (NAT --> {[0,{},{}]}).x by A7,FUNCT_4:12
        .= {[0,{},{}]} by A6,FUNCOP_1:13;
      x in dom s2 by A2,A4,PARTFUN1:def 4;
      then
A9:   s2.x in {[0,{},{}]} by A8,FUNCT_1:def 20;
      s1.x in {[0,{},{}]} by A4,A8,FUNCT_1:def 20;
      hence s1.x = [0,{},{}] by TARSKI:def 1
        .= s2.x by A9,TARSKI:def 1;
    end;
    suppose
A10:  x = NAT;
      hence s1.x = IC s1 by Def2
        .= s2.x by A1,A10,Def2;
    end;
  end;
  dom s1 =dom s2 by A2,PARTFUN1:def 4;
  hence thesis by A3,FUNCT_1:9;
end;

begin :: General theory

reserve x,y,z,A,B for set,
  f,g,h for Function,
  i,j,k for Element of NAT;

reserve S for IC-Ins-separated definite (non empty stored-program AMI-Struct
  over N),
  s for State of S;

definition
 canceled 4;
  let N;
  let S be IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N);
  let s be State of S;
  let p be (the Instructions of S)-valued Function;
  func Following(p,s) -> State of S equals
  Exec(CurInstr(p,s),s);
  correctness;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  deffunc F(set,State of S) = down Following(p,$2);
  let s be State of S, k be Nat;
  func Comput(p,s,k) -> State of S means
:Def19:
  ex f being Function of NAT, product the Object-Kind of S st
  it = f.k & f.0 = s & for i being Nat holds f.(i+1) = Following(p,f.i);
  existence
  proof
    reconsider ss=s as Element of product the Object-Kind of S by PBOOLE:155;
    consider f being Function of NAT, product the Object-Kind of S such that
A1: f.0 = ss and
A2: for n being Nat holds f.(n+1) = F(n,f.n) from NAT_1:sch 12;
    take f.k, f;
    thus f.k = f.k;
    thus f.0 = s by A1;
    let i be Nat;
    thus f.(i+1) = F(i,f.i) by A2
       .= Following(p,f.i);
  end;
  uniqueness
  proof
    let s1,s2 be State of S;
    given f1 being Function of NAT, product the Object-Kind of S such that
A3: s1 = f1.k and
B4: f1.0 = s and
B5: for i being Nat holds f1.(i+1) = Following(p,f1.i);
    given f2 being Function of NAT, product the Object-Kind of S such that
A6: s2 = f2.k and
B7: f2.0 = s and
B8: for i being Nat holds f2.(i+1) = Following(p,f2.i);
    reconsider s as Element of product the Object-Kind of S by PBOOLE:155;
A4: f1.0 = s by B4;
A5: for i being Nat holds f1.(i+1) = F(i,f1.i) by B5;
A7: f2.0 = s by B7;
A8: for i being Nat holds f2.(i+1) = F(i,f2.i) by B8;
    f1 = f2 from NAT_1:sch 16(A4,A5,A7,A8);
    hence thesis by A3,A6;
  end;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be halting IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let s be State of S;
  pred p halts_on s means
:Def20:
  ex k being Nat
   st IC Comput(p,s,k) in dom p & CurInstr(p,Comput(p,s,k)) = halt S;
end;

theorem Th13:
  for N being non empty with_non-empty_elements set
  for S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  p be NAT-defined (the Instructions of S)-valued Function,
  s be State of S holds Comput(p,s,0) = s
proof let N be non empty with_non-empty_elements set;
  let S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  p be NAT-defined (the Instructions of S)-valued Function,
  s be State of S;
  ex f being Function of NAT, product the Object-Kind of S st
  Comput(p,s,0) = f.0 & f.0 = s & for i being Nat holds
  f.(i+1) = Following(p,f.i) by Def19;
  hence thesis;
end;

theorem Th14:
  for N being non empty with_non-empty_elements set
  for S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  p be NAT-defined (the Instructions of S)-valued Function,
  s be State of S, k be Nat holds
  Comput(p,s,k+1) = Following(p,Comput(p,s,k))
proof let N be non empty with_non-empty_elements set;
  let S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  p be NAT-defined (the Instructions of S)-valued Function,
  s be State of S, k be Nat;
  deffunc F(set,State of S) = down Following(p,$2);
  reconsider s as Element of product the Object-Kind of S by PBOOLE:155;
  consider f being Function of NAT, product the Object-Kind of S such that
A1: Comput(p,s,k+1) = f.(k+1) and
A2: f.0 = s and
B3: for i being Nat holds f.(i+1) = Following(p,f.i) by Def19;
  consider g being Function of NAT, product the Object-Kind of S such that
A4: Comput(p,s,k) = g.k and
A5: g.0 = s and
B6: for i being Nat holds g.(i+1) = Following(p,g.i) by Def19;
A3: for i being Nat holds f.(i+1) = F(i,f.i) by B3;
A6: for i being Nat holds g.(i+1) = F(i,g.i) by B6;
  f = g from NAT_1:sch 16(A2,A3,A5,A6);
  hence thesis by A1,A4,B6;
end;

reserve E for set;

reserve N for non empty with_non-empty_elements set,
 S for IC-Ins-separated definite (non empty stored-program AMI-Struct
  over N),
  s for State of S;

canceled 36;

theorem Th51:
  for p being NAT-defined (the Instructions of S)-valued Function
  for k holds Comput(p,s,i+k) = Comput(p,Comput(p,s,i),k)
proof let p be NAT-defined (the Instructions of S)-valued Function;
  defpred P[Element of NAT] means Comput(p,s,i+$1)
   = Comput(p, Comput(p,s,i),$1);
A1: now
    let k;
    assume
A2: P[k];
    Comput(p,s,i+(k+1)) = Comput(p,s,i+k+1)
      .= Following(p, Comput(p,s,i+k)) by Th14
      .= Comput(p, Comput(p,s,i),k+1) by A2,Th14;
    hence P[k+1];
  end;
A3: P[ 0] by Th13;
  thus for k holds P[k] from NAT_1:sch 1(A3,A1);
end;

theorem Th52:
  i <= j implies
 for N for S being halting IC-Ins-separated
  definite (non empty stored-program AMI-Struct over N)
  for p being NAT-defined (the Instructions of S)-valued Function
  for s being State of S st CurInstr(p,Comput(p,s,i)) = halt S
 holds Comput(p,s,j) = Comput(p,s,i)
proof
  assume i <= j;
  then consider k being Nat such that
A1: j = i + k by NAT_1:10;
  reconsider k as Element of NAT by ORDINAL1:def 13;
A2: j = i + k by A1;
  let N;
  let S be halting IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let s be State of S such that
A3: CurInstr(p,Comput(p,s,i))
 = halt S;
  defpred P[Element of NAT] means Comput(p,s,i+$1)
   = Comput(p,s,i);
A4: now
    let k;
    assume
A5: P[k];
    Comput(p,s,i+(k+1)) = Comput(p,s,i+k+1)
      .= Following(p,Comput(p,s,i+k)) by Th14
      .= Comput(p,s,i) by A3,A5,Def8;
    hence P[k+1];
  end;
A6: P[ 0];
  for k holds P[k] from NAT_1:sch 1(A6,A4);
  hence thesis by A2;
end;

reserve n for Element of NAT;

definition
 canceled;
  let N;
  let S be halting IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N);
   let p be NAT-defined (the Instructions of S)-valued Function;
  let s be State of S such that
A1: p halts_on s;
  func Result(p,s) -> State of S means
:Def22:
  ex k st it = Comput(p,s,k) & CurInstr(p,it) = halt S;
  uniqueness
  proof
    let s1,s2 be State of S;
    given k1 being Element of NAT such that
A2: s1 = Comput(p,s,k1) & CurInstr(p, s1) = halt S;
    given k2 being Element of NAT such that
A3: s2 = Comput(p,s,k2) & CurInstr(p, s2) = halt S;
    k1 <= k2 or k2 <= k1;
    hence thesis by A2,A3,Th52;
  end;
  correctness
  proof
    consider k being Nat such that
     IC Comput(p,s,k) in dom p and
W:   CurInstr(p, Comput(p,s,k)) = halt S by A1,Def20;
     k in NAT by ORDINAL1:def 13;
    hence thesis by W;
  end;
end;

L117: for N being with_non-empty_elements set for S being
  steady-programmed (non empty stored-program AMI-Struct over N) for i being
  Instruction of S, s being State of S
   holds ProgramPart Exec (i, s) = ProgramPart s
proof
  let N be with_non-empty_elements set;
  let S be steady-programmed (non empty stored-program AMI-Struct over N);
  let i be Instruction of S, s be State of S;
A1: NAT c= the carrier of S by COMPOS_1:def 2;
A2: for x being set st x in NAT holds (Exec (i, s) | NAT).x = (s | NAT).x
  proof
    let x be set;
    assume x in NAT;
    then reconsider l = x as Element of NAT;
    thus (Exec (i, s) | NAT).x = (Exec (i, s)).l by FUNCT_1:72
      .= s.l by Def13
      .= (s | NAT).x by FUNCT_1:72;
  end;
A4: dom ProgramPart s = NAT by COMPOS_1:34;
  dom (Exec (i,s)) = the carrier of S by PARTFUN1:def 4;
  then dom (Exec (i, s) | NAT) = NAT by A1,RELAT_1:91;
  hence thesis by A4,A2,FUNCT_1:9;
end;

LmA:
  for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N)
 for P being (the Instructions of S)-valued ManySortedSet of NAT
 for s being State of S, n
  holds ProgramPart s = ProgramPart Comput(P,s,n)
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let P be (the Instructions of S)-valued ManySortedSet of NAT;
  let s be State of S;
  defpred X[Element of NAT]
   means ProgramPart s = ProgramPart Comput(P,s,$1);
A1: now
    let n;
    assume X[n];
    then ProgramPart s =
      ProgramPart Following(P, Comput(P,s,n)) by L117
      .= ProgramPart Comput(P,s,n+1) by Th14;
    hence X[n+1];
  end;
A2: X[ 0] by Th13;
  thus for n holds X[n] from NAT_1:sch 1(A2,A1);
end;

canceled;

theorem Th54:
  for S being steady-programmed IC-Ins-separated definite (non
  empty stored-program AMI-Struct over N)
  for P being (the Instructions of S)-valued ManySortedSet of NAT
  for s being State of S, i be
  Element of NAT, k holds s.i = Comput(P,s,k).i
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let P be (the Instructions of S)-valued ManySortedSet of NAT;
  let s be State of S, i be Element of NAT;
  defpred P[Element of NAT] means s.i = Comput(P,s,$1).i;
A1: now
    let k;
    assume P[k];
    then s.i = (Following(P,Comput(P,s,k))).i by Def13
      .= Comput(P,s,k+1).i by Th14;
    hence P[k+1];
  end;
A2: P[ 0] by Th13;
  thus for k holds P[k] from NAT_1:sch 1(A2,A1);
end;

theorem
  for S being steady-programmed IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N)
  for P being (the Instructions of S)-valued ManySortedSet of NAT
  for s being State of S
 holds Comput(P,s,k+1) = Exec(P.(IC Comput(P,s,k)),Comput(P,s,k))
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let P be (the Instructions of S)-valued ManySortedSet of NAT;
  let s be State of S;
D: dom P = NAT by PARTFUN1:def 4;
   IC Comput(P,s,k) in dom P by D;
   then
Y:  P/.IC Comput(P,s,k) = P.IC Comput(P,s,k) by PARTFUN1:def 8;
  thus Comput(P,s,k+1) = Following(P,Comput(P,s,k)) by Th14
   .= Exec(CurInstr(P,Comput(P,s,k)),Comput(P,s,k))
   .= Exec(P.(IC Comput(P,s,k)),Comput(P,s,k)) by Y;
end;

theorem Th56:
  for S being IC-Ins-separated halting definite
(non empty stored-program AMI-Struct over N)
  for P being (the Instructions of S)-valued ManySortedSet of NAT
  for s being State of S, k st P.IC Comput(P,s,k) = halt S
  holds Result(P,s) = Comput(P,s,k)
proof
  let S be IC-Ins-separated halting definite (non empty
  stored-program AMI-Struct over N);
  let P be (the Instructions of S)-valued ManySortedSet of NAT;
  let s be State of S, k;
D: dom P = NAT by PARTFUN1:def 4;
X: IC Comput(P,s,k) in dom P by D;
   then
Y:  P/.IC Comput(P,s,k) = P.IC Comput(P,s,k) by PARTFUN1:def 8;
  assume P.IC Comput(P,s,k) = halt S;
  then
A1: CurInstr(P,Comput(P,s,k)) = halt S by Y;
  then CurInstr(P, Comput(P,s,k)) = halt S;
  then P halts_on s by Def20,X;
 hence thesis by A1,Def22;
end;

theorem Th57:
  for S being IC-Ins-separated halting definite
(non empty stored-program AMI-Struct over N)
  for P being (the Instructions of S)-valued ManySortedSet of NAT
  for s being State of S st ex k st P.IC Comput(P,s,k) = halt S
 for i holds Result(P,s) = Result(P,Comput(P,s,i))
proof
  let S be IC-Ins-separated halting definite (non empty
  stored-program AMI-Struct over N);
  let P be (the Instructions of S)-valued ManySortedSet of NAT;
  let s be State of S;
  given k such that
A1: P.IC Comput(P,s,k) = halt S;
  let i;
XX: dom P = NAT by PARTFUN1:def 4;
  set s9 = Comput(P,s,k);
  IC s9 in dom P by XX;
  then
Y:  P/.IC s9 = P.IC s9 by PARTFUN1:def 8;
A2: CurInstr(P, s9) = halt S by A1,Y;
  now
    per cases;
    suppose
      i <= k;
      then consider j being Nat such that
A3:   k = i + j by NAT_1:10;
      reconsider j as Element of NAT by ORDINAL1:def 13;
A4:   Comput(P,s,k) = Comput(P,Comput(P,s,i),j) by A3,Th51;
      CurInstr(P,Comput(P,s,k)) = halt S by A2;
      then
A5:   P halts_on Comput(P,s,i) by A4,Def20,XX;
      thus Result(P,s) = s9 by A1,Th56
        .= Result(P,Comput(P,s,i)) by A2,A4,A5,Def22;
    end;
    suppose
A6:   i >= k;
A7:   Comput(P,Comput(P,s,k),0) = Comput(P,s,k) by Th13;
A8:   Comput(P,s,i) = s9 by A2,A6,Th52;
X:    IC Comput(P,s9,0) in dom P by XX;
      CurInstr(P, Comput(P,s9,0)) = halt S by A2,A7;
      then
A9:   P halts_on Comput(P,s,i) by Def20,X,A8;
      thus Result(P,s) = s9 by A1,Th56
        .= Result(P,Comput(P,s,i)) by A2,A8,A7,A9,Def22;
    end;
  end;
  hence thesis;
end;

definition
 canceled 2;
  let N;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let IT be PartState of S;
  attr IT is autonomic means
:Def25:
  for s1,s2 being State of S st IT c= s1 &
  IT c= s2 for i holds Comput(ProgramPart s1,s1,i)|dom IT
   = Comput(ProgramPart s2,s2,i)|dom IT;
end;

definition
  let N;
  let S be halting IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N);
  let IT be PartState of S;
  attr IT is halting means
:Def26:
  for s being State of S st IT c= s holds ProgramPart s halts_on s;
end;

registration
  let E;
  cluster Trivial-AMI E -> realistic;
  coherence
proof
  assume
A1: the Instruction-Counter of Trivial-AMI E in NAT;
  the Instruction-Counter of Trivial-AMI E = NAT by Def2;
  hence thesis by A1;
end;
end;

registration
  let E;
  cluster realistic strict AMI-Struct over E;
  existence
  proof
    take Trivial-AMI E;
    thus thesis;
  end;
end;

registration
  let M be set;
  cluster realistic strict IC-Ins-separated definite (non empty stored-program
    AMI-Struct over M);
  existence
  proof
    take Trivial-AMI M;
    thus thesis;
  end;
end;

registration
  let N;
  cluster halting steady-programmed realistic strict
   (IC-Ins-separated definite (non empty stored-program AMI-Struct over N));
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

begin :: Preprograms

canceled 7;

theorem Th65:
  for S being halting realistic IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
  for l being Nat
   for p being PartState of S st p = (IC S,l) --> (l, halt S)
   holds p is halting
proof
  let S be halting realistic IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let l be Nat;
   set h = halt S;
  let p be PartState of S such that
Z: p = (IC S,l) --> (l, h);
    let s be State of S such that
A3: p c= s;
    take 0;
     IC Comput(ProgramPart s,s,0) in NAT;
    hence IC Comput(ProgramPart s,s,0) in dom ProgramPart s by COMPOS_1:34;
u: Comput(ProgramPart s,s,0) = s by Th13;
    CurInstr(ProgramPart Comput(ProgramPart s,s,0),Comput(ProgramPart s,s,0))
     = CurInstr(ProgramPart s, s) by u
      .= halt S by A3,Z,COMPOS_1:6;
    hence CurInstr(ProgramPart s, Comput(ProgramPart s,s,0)) = halt S by u;
end;

theorem Th66:
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non
  empty stored-program AMI-Struct over N)
  for l being Nat
  for p being PartState of S, s being State of S
   st p = (IC S,l) --> (l, halt S) & p c= s
   for i holds Comput(ProgramPart s,s,i) = s
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty
  stored-program AMI-Struct over N);
  let l be Nat;
   set h = halt S;
  let p be PartState of S, s be State of S such that
Z:  p = (IC S,l) --> (l, h) and
A3: p c= s;
  defpred P[Element of NAT] means Comput(ProgramPart s,s,$1) = s;
A4: now
    let i;
    assume
A5: P[i];
    ProgramPart Comput(ProgramPart s,s,i) = ProgramPart s by LmA;
    then Comput(ProgramPart s,s,i+1)
     = Following(ProgramPart Comput(ProgramPart s,s,i),
     Comput(ProgramPart s,s,i)) by Th14
      .= Exec(halt S,s) by Z,A3,A5,COMPOS_1:6
      .= s by Def8;
    hence P[i+1];
  end;
A6: P[ 0] by Th13;
  thus for i holds P[i] from NAT_1:sch 1(A6,A4);
end;

theorem Th67:
  for S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
  for l being Nat
  for p being PartState of S st p = (IC S,l) --> (l, halt S)
   holds p is autonomic
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let l be Nat;
   set h = halt S;
  let p be PartState of S such that
Z: p = (IC S,l) --> (l, halt S);
    let s1,s2 be State of S;
    assume that
A3: p c= s1 and
A4: p c= s2;
A5: s1|dom((IC S,l) --> (l, h)) = (IC S,l) --> (l, h) & s2|dom((IC S,
    l) --> (l, h)) = (IC S,l) --> (l, h) by Z,A3,A4,GRFUNC_1:64;
    let i;
    Comput(ProgramPart s1,s1,i) = s1 by Z,A3,Th66;
    hence thesis by Z,A4,A5,Th66;
end;

registration
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  cluster autonomic halting FinPartState of S;
  existence
  proof
    reconsider h = halt S as Element of (the Object-Kind of S).0
     by COMPOS_1:def 8;
K:  dom(IC S .--> 0) = {IC S} by FUNCOP_1:19;
    now let x;
     assume x in {IC S};
      then
Z:     x = IC S by TARSKI:def 1;
      then
A:     (IC S .--> 0).x = 0 by FUNCOP_1:87;
      ObjectKind IC S = NAT by COMPOS_1:def 6;
     hence (IC S .--> 0).x in (the Object-Kind of S).x by A,Z;
    end;
    then
Y:  IC S .--> 0 is
      (the carrier of S)-defined (the Object-Kind of S)-compatible
               by K,FUNCT_1:def 20,RELAT_1:def 18;
U:  0 in NAT;
    NAT c= the carrier of S by COMPOS_1:def 2;
    then
T:  {0} c= the carrier of S by U,ZFMISC_1:37;
L:  dom(0 .--> h) = {0} by FUNCOP_1:19;
V:  dom(0 .--> h) c= the carrier of S by T,FUNCOP_1:19;
    now let x;
     assume x in {0};
      then
Z:     x = 0 by TARSKI:def 1;
      then
A:     (0 .--> h).x = h by FUNCOP_1:87;
      (the Object-Kind of S).x = the Instructions of S by Z,COMPOS_1:def 8;
     hence (0 .--> h).x in (the Object-Kind of S).x by A;
    end;
    then 0 .--> h is
      (the carrier of S)-defined (the Object-Kind of S)-compatible
               by V,L,FUNCT_1:def 20,RELAT_1:def 18;
    then (IC S .--> 0) +* (0 .--> h) is
      (the carrier of S)-defined (the Object-Kind of S)-compatible by Y;

    then reconsider p = (IC S,0) --> (0, halt S)
     as FinPartState of S by FUNCT_4:def 4;
    p is autonomic halting by Th65,Th67;
    hence thesis;
  end;
end;

definition
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  mode pre-program of S is autonomic halting FinPartState of S;
end;

definition
 canceled 2;
  let N be with_non-empty_elements non empty set;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let d be FinPartState of S;
  assume
A1: d is pre-program of S & p = ProgramPart d;
  func Result(p,d) -> FinPartState of S means
  for s being State of S st d c= s
  holds it = (Result(ProgramPart(s),s))|dom d;
  existence
  proof
    consider h being State of S such that
A3:  d c= h by PBOOLE:156;
    ProgramPart h halts_on h by A1,A3,Def26;
    then consider k1 being Element of NAT such that
A4: Result(ProgramPart(h),h) = Comput(ProgramPart h,h,k1) and
A5: CurInstr(ProgramPart(h), Result(ProgramPart(h),h)) =
halt S by Def22;
    reconsider R = (Result(ProgramPart(h),h))|dom d as FinPartState of S;
    take R;
    let s be State of S such that
A6: d c= s;
    ProgramPart s halts_on s by A1,A6,Def26;
    then consider k2 being Element of NAT such that
A7: Result(ProgramPart(s),s) = Comput(ProgramPart s,s,k2) and
A8: CurInstr(ProgramPart(s), Result(ProgramPart(s),s)) = halt S by Def22;
    now
      per cases;
      suppose
        k1 <= k2;
        then Result(ProgramPart(h),h) = Comput(ProgramPart h,h,k2) by A4,A5
,Th52;
        hence thesis by A1,A3,A6,A7,Def25;
      end;
      suppose
        k1 >= k2;
        then Result(ProgramPart(s),s) = Comput(ProgramPart s,s,k1) by A7,A8
,Th52;
        hence thesis by A1,A3,A6,A4,Def25;
      end;
    end;
    hence thesis;
  end;
  correctness
  proof
    consider h being State of S such that
A10:  d c= h by PBOOLE:156;
    let p1,p2 be FinPartState of S such that
A11: for s being State of S st d c= s
 holds p1 = (Result(ProgramPart(s),s))|dom d and
A12: for s being State of S st d c= s
 holds p2 = (Result(ProgramPart(s),s))|dom d;
    thus p1 = (Result(ProgramPart(h),h))|dom d by A11,A10
      .= p2 by A12,A10;
  end;
end;

begin :: Computability

definition
  let N;
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let d be FinPartState of S, F be Function;
  pred p,d computes F means
:Def29:
  for x being set st x in dom F
   ex s being FinPartState of S
    st x = s & p +* d +* s is pre-program of S & F.s c= Result(p,d+* s);
end;

theorem
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
 for p being NAT-defined (the Instructions of S)-valued Function
 for d being FinPartState of S holds
  p,d computes {}
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let d be FinPartState of S;
  let x be set;
  assume
A1: x in dom {};
  then reconsider x as FinPartState of S;
  take x;
  thus thesis by A1;
end;

theorem
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
  for p being NAT-defined (the Instructions of S)-valued Function
  for d being FinPartState of S
  holds p +* d is pre-program of S iff p,d computes {} .--> Result(p,d)
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let d be FinPartState of S;
  thus p +* d is pre-program of S implies p,d computes {} .--> Result(p,d)
  proof
A1: dom({} .--> Result(p,d)) = {{}} by FUNCOP_1:19;
    assume
A2: p +* d is pre-program of S;
    let x be set;
    assume x in dom({} .--> Result(p,d));
    then
A3: x = {} by A1,TARSKI:def 1;
    then reconsider s = x as FinPartState of S by FUNCT_1:174,RELAT_1:206;
    take s;
    thus x = s;
    thus p +* d +* s is pre-program of S by A2,A3,FUNCT_4:22;
X:   d+*s = d by A3,FUNCT_4:22;
    ({} .--> Result(p,d)).s = Result(p,d) by A3,FUNCOP_1:87;
    hence thesis by X;
  end;
  dom({} .--> Result(p,d)) = {{}} by FUNCOP_1:19;
  then
A4: {} in dom({} .--> Result(p,d)) by TARSKI:def 1;
  assume p,d computes {} .--> Result(p,d);
  then ex s being FinPartState of S
    st {} = s & p +* d +* s is pre-program of S &
      ({} .--> Result(p,d)).s c= Result(p,d+* s)
     by A4,Def29;
  hence thesis by FUNCT_4:22;
end;

theorem
  for S being realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)
  for p being NAT-defined (the Instructions of S)-valued Function
  for d being FinPartState of S
    holds p +* d is pre-program of S iff p,d computes {} .--> {}
proof
  let S be realistic halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let d be FinPartState of S;
  thus p +* d is pre-program of S implies p,d computes {} .--> {}
  proof
A1: dom({} .--> {}) = {{}} by FUNCOP_1:19;
    assume
A2: p +* d is pre-program of S;
    let x be set;
    assume x in dom({} .--> {});
    then
A3: x = {} by A1,TARSKI:def 1;
    then reconsider s = x as FinPartState of S by FUNCT_1:174,RELAT_1:206;
    take s;
    thus x = s;
    thus p +* d +* s is pre-program of S by A2,A3,FUNCT_4:22;
    ({} .--> {}).s = {} by A3,FUNCOP_1:87;
    hence thesis by XBOOLE_1:2;
  end;
  dom({} .--> {}) = {{}} by FUNCOP_1:19;
  then
A4: {} in dom({} .--> {}) by TARSKI:def 1;
  assume p,d computes {} .--> {};
  then ex s being FinPartState of S
    st {} = s & p +* d +* s is pre-program of S &
    ({} .--> {}).s c= Result(p,d+* s) by A4,Def29;
  hence thesis by FUNCT_4:22;
end;

begin :: InsType & InsCode

registration
  let N be set;
  cluster Trivial-AMI N -> standard-ins;
  coherence
  proof
    {} in ((union N) \/ the carrier of Trivial-AMI N)* by FINSEQ_1:66;
    then
A1: {{}} c= ((union N) \/ the carrier of Trivial-AMI N)* by ZFMISC_1:37;
    take X = (union N) \/ the carrier of Trivial-AMI N;
    {} in NAT* by FINSEQ_1:66;
    then
X:  {{}} c= NAT* by ZFMISC_1:37;
    the Instructions of Trivial-AMI N = {[0,{},{}]} by Def2
      .= [:{0},{{}},{{}}:] by MCART_1:39;
    hence the Instructions of Trivial-AMI N c= [: NAT,NAT*,X*:]
     by A1,X,MCART_1:77;
  end;
end;

registration
  let N be set;
  cluster standard-ins non empty stored-program AMI-Struct over N;
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

registration
  let N;
  cluster IC-Ins-separated definite standard-ins (non empty stored-program
    AMI-Struct over N);
  existence
  proof
    take Trivial-AMI N;
    thus thesis;
  end;
end;

begin :: Some Remarks on AMI-Struct

reserve N for with_non-empty_elements non empty set;

canceled 10;

theorem Th81:
  for S being steady-programmed IC-Ins-separated definite (non
empty stored-program AMI-Struct over N) for p being NAT-defined PartState
  of S
  for P being (the Instructions of S)-valued ManySortedSet of NAT
  for s being State of S st p c= s for k
  holds p c= Comput(P,s,k)
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let p be NAT-defined PartState of S;
  let P be (the Instructions of S)-valued ManySortedSet of NAT,
  s be State of S such that
A1: p c= s;
  let k;
A2: dom p c= NAT by RELAT_1:def 18;
A3: now
    let x be set;
    assume
A4: x in dom p;
    then reconsider l = x as Element of NAT by A2;
    s.x = ( Comput(P,s,k)).l by Th54;
    hence p.x = ( Comput(P,s,k)).x by A1,A4,GRFUNC_1:8;
  end;
  dom s = the carrier of S by PARTFUN1:def 4
    .= dom( Comput(P,s,k)) by PARTFUN1:def 4;
  then dom p c= dom( Comput(P,s,k)) by A1,GRFUNC_1:8;
  hence thesis by A3,GRFUNC_1:8;
end;

canceled;

theorem Th83:
  for S being IC-Ins-separated halting definite
(non empty stored-program AMI-Struct over N),
  p be NAT-defined (the Instructions of S)-valued Function,
    s being State of S holds p halts_on s
   iff ex i st p halts_at IC Comput(p,s,i)
proof
  let S be IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let s be State of S;
  hereby
    assume p halts_on s;
    then consider i being Nat such that
A0: IC Comput(p,s,i) in dom p and
A1: CurInstr(p,Comput(p,s,i)) = halt S by Def20;
     reconsider i as Element of NAT by ORDINAL1:def 13;
    take i;
    p.IC Comput(p,s,i) = halt S by A0,A1,PARTFUN1:def 8;
    hence p halts_at IC Comput(p,s,i) by A0,COMPOS_1:def 19;
  end;
  given i being Element of NAT such that
A0: p halts_at IC Comput(p,s,i);
A2: IC Comput(p,s,i) in dom p by A0,COMPOS_1:def 19;
A3: p.IC Comput(p,s,i) = halt S by A0,COMPOS_1:def 19;
  take i;
  thus IC Comput(p,s,i) in dom p by A0,COMPOS_1:def 19;
  thus CurInstr(p,Comput(p,s,i)) = p/.IC Comput(p,s,i)
    .= halt S by A2,A3,PARTFUN1:def 8;
end;

canceled;

theorem Th85:
  for S being halting IC-Ins-separated definite
(non empty stored-program AMI-Struct over N),
  p be NAT-defined (the Instructions of S)-valued Function,
  s being State of S,
    k being Nat st p halts_on s
  holds Result(p,s) = Comput(p,s,k) iff p halts_at IC Comput(p,s,k)
proof
  let S be halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let s be State of S, k being Nat;
  assume
Z0: p halts_on s;
   then consider n being Nat such that
G1: IC Comput(p,s,n) in dom p and
G2: CurInstr(p,Comput(p,s,n)) = halt S by Def20;
  hereby
    assume
Z:    Result(p,s) = Comput(p,s,k);
    consider i being Element of NAT such that
W1:  Result(p,s) = Comput(p,s,i) and
W2:  CurInstr(p,Result(p,s)) = halt S by Z0,Def22;
    reconsider i,n as Element of NAT by ORDINAL1:def 13;
Y:  now per cases;
     suppose i <= n;
     hence Comput(p,s,i) = Comput(p,s,n) by W1,W2,Th52;
     end;
     suppose n <= i;
     hence Comput(p,s,i) = Comput(p,s,n) by G2,Th52;
     end;
    end;
    p.IC Comput(p,s,k) = halt S by Y,W2,Z,G1,W1,PARTFUN1:def 8;
    hence p halts_at IC Comput(p,s,k) by Y,G1,W1,Z,COMPOS_1:def 19;
  end;
  assume that
Z1: IC Comput(p,s,k) in dom p and
Z2:  p.IC Comput(p,s,k) = halt S;
X:  CurInstr(p,Comput(p,s,k)) = halt S by Z1,Z2,PARTFUN1:def 8;
    reconsider k,n as Element of NAT by ORDINAL1:def 13;
    now per cases;
     suppose n <= k;
     hence Comput(p,s,k) = Comput(p,s,n) by G2,Th52;
     end;
     suppose k <= n;
     hence Comput(p,s,k) = Comput(p,s,n) by X,Th52;
     end;
    end;
  hence thesis by G2,Def22,Z0;
end;

theorem
  for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N), s being State of S, p being NAT-defined
  PartState of S, k holds p c= s iff p c= Comput(ProgramPart s,s,k)
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let s be State of S, p be NAT-defined PartState of S, k;
  dom( Comput(ProgramPart s,s,k)) = the carrier of S by PARTFUN1:def 4;
  then
A1: dom p c= dom( Comput(ProgramPart s,s,k)) by RELAT_1:def 18;
A2: dom p c= NAT by RELAT_1:def 18;
A3: now
    hereby
      assume
A4:   for x being set st x in dom p holds p.x = s.x;
      let x be set;
      assume
A5:   x in dom p;
      then reconsider l = x as Element of NAT by A2;
      thus Comput(ProgramPart s,s,k).x = s.l by Th54
        .= p.x by A4,A5;
    end;
    assume
A6: for x being set st x in dom p holds p.x = Comput(ProgramPart s,s,k).x;
    let x be set;
    assume
A7: x in dom p;
    then reconsider l = x as Element of NAT by A2;
    thus s.x = Comput(ProgramPart s,s,k).l by Th54
      .= p.x by A6,A7;
  end;
  dom s = the carrier of S by PARTFUN1:def 4;
  then dom p c= dom s by RELAT_1:def 18;
  hence thesis by A1,A3,GRFUNC_1:8;
end;

theorem Th87:
  for S being halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)
 for P being (the Instructions of S)-valued NAT-defined Function,
  s being State of S, k st P halts_at IC Comput(P,s,k)
   holds Result(P,s) = Comput(P,s,k)
proof
  let S be halting IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N),
  P be (the Instructions of S)-valued NAT-defined Function,
  s be State of S, k;
  assume
A1: P halts_at IC Comput(P,s,k);
  then P halts_on s by Th83;
  hence thesis by A1,Th85;
end;

theorem Th88:
  i <= j implies for S being halting
IC-Ins-separated definite (non empty stored-program AMI-Struct over N)
 for P being (the Instructions of S)-valued NAT-defined Function
 for s being State of S st P halts_at IC Comput(P,s,i)
  holds P halts_at IC Comput(P,s,j)
proof
  assume
A1: i <= j;
  let S be halting IC-Ins-separated definite (non empty
     stored-program AMI-Struct over N),
   p be NAT-defined (the Instructions of S)-valued Function;
  let s be State of S;
  assume that
A3: IC Comput(p,s,i) in dom p and
A2: p.IC Comput(p,s,i) = halt S;
X: CurInstr(p,Comput(p,s,i)) = halt S by A3,A2,PARTFUN1:def 8;
  hence IC Comput(p,s,j) in dom p by A3,A1,Th52;
  thus p.IC Comput(p,s,j) = halt S by A1,A2,X,Th52;
end;

theorem
  i <= j implies for S being halting IC-Ins-separated
definite (non empty stored-program AMI-Struct over N)
 for P being (the Instructions of S)-valued NAT-defined Function
 for s being State of S st P halts_at IC Comput(P,s,i)
   holds Comput(P,s,j) = Comput(P,s,i)
proof
  assume
A1: i <= j;
  let S be halting IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N),
  P be (the Instructions of S)-valued NAT-defined Function,
  s be State of S;
  assume
A2: P halts_at IC Comput(P,s,i);
  then P halts_at IC Comput(P,s,j) by A1,Th88;
  hence Comput(P,s,j) = Result(P,s) by Th87
    .= Comput(P,s,i) by A2,Th87;
end;

theorem
  for S being steady-programmed IC-Ins-separated halting definite (non
empty stored-program AMI-Struct over N)
 for P being (the Instructions of S)-valued ManySortedSet of NAT
 for s being State of S st ex k st P halts_at IC Comput(P,s,k)
   for i holds Result(P,s) = Result(P,Comput(P,s,i))
proof
  let S be steady-programmed IC-Ins-separated halting definite (non empty
  stored-program AMI-Struct over N),
  P be (the Instructions of S)-valued ManySortedSet of NAT,
  s be State of S;
  given k such that
A1: P halts_at IC Comput(P,s,k);
  let i;
   P.IC Comput(P,s,k) = halt S by A1,COMPOS_1:def 21;
  hence thesis by Th57;
end;

definition
  canceled 15;
  let N be with_non-empty_elements non empty set;
  let S be halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let s be State of S such that
A1: p halts_on s;
  func LifeSpan(p,s) -> Element of NAT means
:Def46:
  CurInstr(p,Comput(p,s,it)) = halt S &
  for k being Element of NAT st
   CurInstr(p,Comput(p,s,k)) = halt S
  holds it <= k;
  existence
  proof
    defpred X[Nat] means
     CurInstr(p,Comput(p,s,$1))=halt S;
    consider k being Nat such that IC Comput(p,s,k) in dom p and
W:   CurInstr(p, Comput(p,s,k)) = halt S by A1,Def20;
A2: ex k being Nat st X[k] by W;
    consider k being Nat such that
A3: X[k] & for n being Nat st X[n] holds k <= n from NAT_1:sch 5(A2);
    reconsider k as Element of NAT by ORDINAL1:def 13;
    take k;
    thus thesis by A3;
  end;
  uniqueness
  proof
    let it1, it2 be Element of NAT;
    assume
A4: not thesis;
    then it1 <= it2 & it2 <= it1;
    hence contradiction by A4,XXREAL_0:1;
  end;
end;

canceled 2;

theorem
  for N being non empty with_non-empty_elements set,
      S be IC-Ins-separated definite halting steady-programmed
       (non empty stored-program AMI-Struct over N),
      p being NAT-defined (the Instructions of S)-valued Function,
      s being State of S, m being Element of NAT
   holds p halts_on s iff p halts_on Comput(p,s,m)
proof
  let N be non empty with_non-empty_elements set;
  let S be IC-Ins-separated definite halting steady-programmed
   (non empty stored-program
  AMI-Struct over N),
  p be NAT-defined (the Instructions of S)-valued Function,
  s be State of S, m be Element of NAT;
  hereby
    assume p halts_on s;
    then consider n being Nat such that
W0:  IC Comput(p,s,n) in dom p and
W:   CurInstr(p, Comput(p,s,n)) = halt S by Def20;
    reconsider n as Element of NAT by ORDINAL1:def 13;
A1: CurInstr(p,Comput(p,s,n)) = halt S by W;
    per cases;
    suppose
      n <= m;
      then
       Comput(p,s,n) = Comput(p,s,m+0) by A1,Th52
        .= Comput(p,Comput(p,s,m),0) by Th51;
      hence p halts_on Comput(p,s,m) by Def20,W,W0;
    end;
    suppose
      n >= m;
      then reconsider k = n - m as Element of NAT by INT_1:18;
      Comput(p,Comput(p,s,m),k)
         = Comput(p,s,m+k) by Th51
        .= Comput(p,s,n);
     hence p halts_on Comput(p,s,m)
      by Def20,W0,W;
    end;
  end;
  given n being Nat such that
W1: IC Comput(p, Comput(p,s,m),n) in dom p and
W2: CurInstr(p, Comput(p,Comput(p,s,m),n)) = halt S;
   reconsider nn=n as Element of NAT by ORDINAL1:def 13;
  take m+nn;
  thus IC Comput(p,s,m+nn) in dom p &
   CurInstr(p, Comput(p,s,m+nn)) = halt S by W1,W2,Th51;
end;

reserve N for with_non-empty_elements non empty set,
  S for IC-Ins-separated (non empty AMI-Struct over N);

canceled 5;

theorem
  for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for p being PartState of S, s being
  State of S st p c= s for i being Element of NAT holds ProgramPart p c=
  Comput(ProgramPart s,s,i)
proof
  let S be steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N);
  let p be PartState of S, s be State of S such that
A1: p c= s;
  let i be Element of NAT;
  ProgramPart p c= p by RELAT_1:88;
  then ProgramPart p c= s by A1,XBOOLE_1:1;
  hence thesis by Th81;
end;

canceled 17;

theorem
  for N being with_non-empty_elements set for S being
  steady-programmed (non empty stored-program AMI-Struct over N) for i being
  Instruction of S, s being State of S
   holds ProgramPart Exec (i, s) = ProgramPart s by L117;

canceled 4;

reserve m,n for Element of NAT;

theorem
  for S being halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N),
   p being NAT-defined (the Instructions of S)-valued Function,
   s being State of S
  st p halts_on s
 holds Result(p,s) = Comput(p,s,LifeSpan(p,s))
proof
  let S be halting IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function;
  let s be State of S;
  assume
A1: p halts_on s;
  then
A2: CurInstr(p,Comput(p,s,LifeSpan(p,s))) = halt S by Def46;
  consider m such that
A3: Result(p,s) = Comput(p,s,m) and
A4: CurInstr(p, Result(p,s)) = halt S by A1,Def22;
  LifeSpan(p,s) <= m by A1,A3,A4,Def46;
  hence thesis by A2,A3,Th52;
end;

theorem
  for S being steady-programmed IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N) for s being State of S, n
   holds ProgramPart s = ProgramPart Comput(ProgramPart s,s,n) by LmA;

theorem
  for N being with_non-empty_elements non empty set,
  S being steady-programmed
  IC-Ins-separated definite (non empty stored-program AMI-Struct over N),
  p being NAT-defined (the Instructions of S)-valued Function,
  s1,s2 being State of S
   st p c= s1 & p c= s2
  holds Comput(ProgramPart s1,s1,i) | dom p
   = Comput(ProgramPart s2,s2,i) | dom p
proof
  let N be with_non-empty_elements non empty set,
  S be steady-programmed
IC-Ins-separated definite (non empty stored-program AMI-Struct over N),
  p be NAT-defined (the Instructions of S)-valued Function,
  s1,s2 be State of S such that
A1: p c= s1 and
A2: p c= s2;
  set Cs2= Comput(ProgramPart s2,s2,i);
  set Cs1= Comput(ProgramPart s1,s1,i);
A3: now
    let x be set;
    assume
A4: x in dom p;
    dom p c= NAT by RELAT_1:def 18;
    then reconsider l=x as Element of NAT by A4;
A5: s1.l = Cs1.l & s2.l = Cs2.l by Th54;
    p.x=s1.x by A1,A4,GRFUNC_1:8;
    hence Cs1.x = Cs2.x by A2,A4,A5,GRFUNC_1:8;
  end;
  dom Cs1 = the carrier of S by PARTFUN1:def 4
    .=dom Cs2 by PARTFUN1:def 4;
  hence thesis by A3,FUNCT_1:166;
end;

:: from SCMFSA9A, 2008.02.12, A.T.

canceled 2;

theorem
  for N being non empty with_non-empty_elements set,
  S being halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N),
  P being (the Instructions of S)-valued ManySortedSet of NAT,
  s being State of S, k being Element of NAT
   st CurInstr(P,Comput(P,s,k)) = halt S
 holds Comput(P,s,LifeSpan(P,s)) = Comput(P,s,k)
proof
  let N be non empty with_non-empty_elements set, S be halting
IC-Ins-separated definite steady-programmed
 (non empty stored-program AMI-Struct over N),
     P being (the Instructions of S)-valued ManySortedSet of NAT,
     s be State of S, k be Element of NAT such that
A1: CurInstr(P,Comput(P,s,k)) = halt S;
  dom P = NAT by PARTFUN1:def 4;
  then
X: IC Comput(P,s,k) in dom P;
A2: P halts_on s by Def20,X,A1;
  set Ls = LifeSpan(P,s);
A3: CurInstr(P,Comput(P,s,Ls)) = halt S by A2,Def46;
  Ls <= k by A1,A2,Def46;
  hence thesis by A3,Th52;
end;

:: from SCMISORT, 2008.02.12, A.T.

theorem
 for N being non empty with_non-empty_elements set
 for S being halting IC-Ins-separated definite steady-programmed
  (non empty stored-program AMI-Struct over N)
  for p being NAT-defined (the Instructions of S)-valued Function
 for s being State of S st LifeSpan(p,s) <= j & p halts_on s
   holds Comput(p,s,j) = Comput(p,s,LifeSpan(p,s))
proof
  let N be non empty with_non-empty_elements set,
  S be halting IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N),
  p being NAT-defined (the Instructions of S)-valued Function,
  s be State of S;
  assume that
A1: LifeSpan(p,s) <= j and
A2: p halts_on s;
  CurInstr(p,Comput(p,s,LifeSpan(p,s))) = halt S by A2,Def46;
  hence thesis by A1,Th52;
end;

:: from AMI_6, 2008.02.12, A.T.

theorem
  for N being with_non-empty_elements non empty set,
      S being realistic IC-Ins-separated definite steady-programmed
       (non empty stored-program AMI-Struct over N),
      t, u being State of S,
      e being Element of NAT,
      I being Instruction of S st u = t+*((IC S, e)-->(e, I))
    holds u.e = I & IC u = e &
     IC Following(ProgramPart u,u) = Exec(u.IC u, u).IC S
proof

 let N be with_non-empty_elements non empty set,
     S be realistic IC-Ins-separated definite steady-programmed
      (non empty stored-program AMI-Struct over N),
     t, u be State of S,
     e be Element of NAT,
     I be Instruction of S such that
A2: u = t+*((IC S, e)-->(e, I));
A3: dom ((IC S, e)-->(e, I)) = {IC S, e} by FUNCT_4:65;
  then e in dom ((IC S, e)-->(e, I)) by TARSKI:def 2;
  hence u.e = ((IC S, e)-->(e, I)).e by A2,FUNCT_4:14
    .= I by FUNCT_4:66;
   reconsider il = e as Element of NAT;
X: IC S <> il by COMPOS_1:def 12;
Y:  (ProgramPart u)/.IC u
 = u.IC u by COMPOS_1:38;
  IC S in dom ((IC S, e)-->(e, I)) by A3,TARSKI:def 2;
  hence IC u = ((IC S, e)-->(e, I)).IC S by A2,FUNCT_4:14
    .= e by X,FUNCT_4:66;
  thus thesis by Y;
end;

:: from SCMPDS_5, 2008.02.12, A.T.

theorem
  for S being halting IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N),
  P being (the Instructions of S)-valued ManySortedSet of NAT,
  s being State of S st s = Following(P,s)
  holds for n holds Comput(P,s,n) = s
proof
  let S be halting IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N),
  P be (the Instructions of S)-valued ManySortedSet of NAT,
  s be State of S;
  defpred X[Element of NAT] means Comput(P,s,$1) = s;
  assume s = Following(P,s);
  then
A1: for n st X[n] holds X[n+1] by Th14;
A2: X[ 0] by Th13;
  thus for n holds X[n] from NAT_1:sch 1(A2, A1);
end;

:: from SCMPDS_9, 2008.02.12, A.T.

theorem
  for N being with_non-empty_elements non empty set,
      S being IC-Ins-separated definite steady-programmed
           (non empty stored-program AMI-Struct over N),
      P being (the Instructions of S)-valued ManySortedSet of NAT,
      s being State of S, i being Instruction of S
   holds Exec(P.IC s,s).IC S = IC Following(P,s)
proof
  let N be with_non-empty_elements non empty set,
      S be IC-Ins-separated definite steady-programmed
           (non empty stored-program AMI-Struct over N),
      P be (the Instructions of S)-valued ManySortedSet of NAT,
      s be State of S, i being Instruction of S;
   NAT = dom P by PARTFUN1:def 4;
   then
A: IC s in dom P;
 thus Exec(P.IC s,s).IC S
     = IC Exec(P.IC s,s)
    .= IC Exec(CurInstr(P,s),s) by A,PARTFUN1:def 8
    .= IC Following(P,s);
end;

:: from SCMRING3, 2008.02.12, A.T.

canceled;

theorem
  for N being with_non-empty_elements non empty set, S being realistic
IC-Ins-separated definite steady-programmed
 (non empty stored-program AMI-Struct over N), t, u
  being State of S, il being Element of NAT, e being Element of
ObjectKind IC S, I being Element of (the Object-Kind of S).il
 st e = il & u = t+*((IC S, il
)-->(e, I)) holds u.il = I & IC u = il & IC Following(ProgramPart u,u)
 = Exec(u.IC u, u).IC S
proof
  let N be with_non-empty_elements non empty set,
  S be realistic IC-Ins-separated
  definite steady-programmed
   (non empty stored-program AMI-Struct over N), t, u be State of S,
il be Element of NAT, e be Element of ObjectKind IC S, I be Element
  of (the Object-Kind of S).il such that
A1: e = il and
A2: u = t+*((IC S, il)-->(e, I));
A3: dom ((IC S, il)-->(e, I)) = {IC S, il} by FUNCT_4:65;
  then il in dom ((IC S, il)-->(e, I)) by TARSKI:def 2;
  hence u.il = ((IC S, il)-->(e, I)).il by A2,FUNCT_4:14
    .= I by FUNCT_4:66;
  IC S in dom ((IC S, il)-->(e, I)) by A3,TARSKI:def 2;
  hence IC u = ((IC S, il)-->(e, I)).IC S by A2,FUNCT_4:14
    .= il by A1,COMPOS_1:3,FUNCT_4:66;
    (ProgramPart u)/.IC u
 = u.IC u by COMPOS_1:38;
  hence thesis;
end;

canceled 12;

:: missing, 2008.05.01, A.T.

theorem
 for S being steady-programmed IC-Ins-separated definite halting
  (non empty stored-program AMI-Struct over N)
   for P being (the Instructions of S)-valued ManySortedSet of NAT
   for s being State of S holds P halts_on s
   iff ex k st CurInstr(P,Comput(P,s,k)) = halt S
proof
 let S be steady-programmed IC-Ins-separated definite halting
  (non empty stored-program AMI-Struct over N);
 let P be (the Instructions of S)-valued ManySortedSet of NAT;
 let s be State of S;
 thus P halts_on s
   implies ex k st CurInstr(P,Comput(P,s,k))
    = halt S
  proof
   given k being Nat such that
    IC Comput(P,s,k) in dom P and
G2: CurInstr(P, Comput(P,s,k)) = halt S;
   take k;
   thus k is Element of NAT by ORDINAL1:def 13;
   thus CurInstr(P,Comput(P,s,k)) = halt S by G2;
  end;
 given k such that
G: CurInstr(P,Comput(P,s,k)) = halt S;
 take k;
  IC Comput(P,s,k) in NAT;
 hence IC Comput(P,s,k) in dom P  by PARTFUN1:def 4;
 thus CurInstr(P, Comput(P,s,k)) = halt S by G;
end;

