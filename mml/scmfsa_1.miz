:: An Extension of { \bf SCM }
::  by Andrzej Trybulec , Yatsuka Nakamura and Piotr Rudnicki
::
:: Received February 3, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies INT_1, AMI_2, BOOLE, GR_CY_1, TARSKI, FINSEQ_1, AMI_5, MCART_1,
      FUNCT_1, FUNCOP_1, FUNCT_4, CAT_1, RELAT_1, AMI_3, AMI_1, ORDINAL2,
      CARD_3, ZF_REFLE, PBOOLE, ABSVALUE, FINSEQ_2, FUNCT_2, FUNCT_5, SCMFSA_1,
      FINSEQ_4, CARD_1, ARYTM;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, CARD_1, NUMBERS,
      NAT_1, MCART_1, INT_2, PBOOLE, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2,
      BINOP_1, FRAENKEL, INT_1, FINSEQ_1, FUNCT_4, CAT_2, FINSOP_1, CARD_3,
      FUNCOP_1, FINSEQ_4, AMI_1, AMI_2, AMI_3, FUNCT_7, XXREAL_0;
 constructors PARTFUN1, DOMAIN_1, XXREAL_0, INT_2, FINSEQ_4, FINSOP_1, PBOOLE,
      CAT_2, AMI_2, AMI_3, REAL_1, VALUED_1, SEQ_1;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      FRAENKEL, NUMBERS, XREAL_0, INT_1, FINSEQ_1, CARD_3, PBOOLE, GR_CY_1,
      AMI_2, AMI_3, AFINSQ_1, RELAT_1, FINSET_1, CARD_4, CARD_1, VALUED_0,
      VALUED_1, FUNCT_2;
 requirements NUMERALS, REAL, BOOLE, SUBSET;
 definitions TARSKI, FUNCOP_1, CARD_1, AMI_2, FINSEQ_1, VALUED_1;
 theorems ZFMISC_1, FUNCT_2, TARSKI, CAT_2, FUNCOP_1, GR_CY_1, INT_1, CARD_3,
      FINSEQ_1, FINSEQ_4, MCART_1, FUNCT_4, AMI_1, RELAT_1, FUNCT_1, AMI_3,
      AMI_5, FINSEQ_2, PRE_CIRC, PBOOLE, AMI_2, FUNCT_7, RELSET_1, ORDINAL1,
      XBOOLE_0, XBOOLE_1, NUMBERS, CARD_1, ARYTM_3;
 schemes BINOP_1;

begin

 reserve x,y,z for set,
         k for Element of NAT;

notation
  synonym SCM+FSA-Data-Loc for SCM-Data-Loc;
  synonym SCM+FSA-Instr-Loc for SCM-Instr-Loc;
end;

definition
  func SCM+FSA-Data*-Loc equals
   INT \ NAT;
  coherence;
end;

definition
 func SCM+FSA-Memory equals
  SCM-Memory \/ SCM+FSA-Data*-Loc;
 coherence;
end;

registration
 cluster SCM+FSA-Memory -> non empty;
 coherence;
end;

theorem Th1:
 SCM-Memory c= SCM+FSA-Memory by XBOOLE_1:7;

definition
  redefine func SCM+FSA-Data-Loc -> Subset of SCM+FSA-Memory;
  coherence
  proof
     SCM-Data-Loc c= SCM-Memory;
    hence thesis by Th1,XBOOLE_1:1;
  end;
end;

definition
 redefine func SCM+FSA-Data*-Loc -> Subset of SCM+FSA-Memory;
  coherence by XBOOLE_1:7;
  canceled;
end;

definition
  redefine func SCM+FSA-Instr-Loc -> Subset of SCM+FSA-Memory;
  coherence by Th1,XBOOLE_1:1;
end;

registration
 cluster SCM+FSA-Data*-Loc -> non empty;
 coherence
  proof not INT c= NAT by NUMBERS:17,27,XBOOLE_0:def 10;
   hence thesis by XBOOLE_1:37;
  end;
end;

reserve J,K for Element of Segm 13,
        a for Element of SCM+FSA-Instr-Loc,
        b,b1,b2,c,c1,c2 for Element of SCM+FSA-Data-Loc,
        f,f1,f2 for Element of SCM+FSA-Data*-Loc;

definition
 func SCM+FSA-Instr
   -> Subset of [: NAT, (union {INT,INT*} \/ SCM+FSA-Memory)* :]
 equals
  SCM-Instr \/ { [J,<*c,f,b*>] : J in {9,10} } \/
                { [K,<*c1,f1*>] : K in {11,12} };
 coherence
  proof
A1: SCM+FSA-Memory c= union {INT,INT*} \/ SCM+FSA-Memory by XBOOLE_1:7;
A2: { [J,<*c,f,b*>] : J in {9,10} }
            c= [: NAT, (union {INT,INT*} \/ SCM+FSA-Memory)* :]
     proof let x be set;
      assume x in { [J,<*c,f,b*>] : J in {9,10} };
       then consider J,c,b,f such that
A3:       x = [J,<*c,f,b*>] & J in {9,10};
       reconsider c,f,b as Element of union {INT,INT*} \/ SCM+FSA-Memory
              by A1,TARSKI:def 3;
       <*c,f,b*> in (union {INT,INT*} \/ SCM+FSA-Memory)* by FINSEQ_1:def 11;
      hence x in [: NAT, (union {INT,INT*} \/ SCM+FSA-Memory)*:]
             by A3,ZFMISC_1:106;
     end;
A4: { [K,<*c1,f1*>] : K in {11,12} }
        c= [: NAT, (union {INT,INT*} \/ SCM+FSA-Memory)* :]
     proof let x be set;
      assume x in { [K,<*c,f*>] : K in {11,12} };
       then consider K,c,f such that
A5:       x = [K,<*c,f*>] & K in { 11,12 };
       reconsider c,f as Element of union {INT,INT*} \/ SCM+FSA-Memory
            by A1,TARSKI:def 3;
       <*c,f*> in (union {INT,INT*} \/ SCM+FSA-Memory)* by FINSEQ_1:def 11;
      hence x in [: NAT, (union {INT,INT*} \/ SCM+FSA-Memory)*:]
       by A5,ZFMISC_1:106;
     end;
    {INT} c= {INT,INT*} by ZFMISC_1:12;
    then union {INT} c= union {INT,INT*} by ZFMISC_1:95;
    then union {INT} \/ SCM-Memory c= union {INT,INT*} \/ SCM+FSA-Memory
                     by Th1,XBOOLE_1:13;
    then (union {INT} \/ SCM-Memory)* c= (union {INT,INT*} \/ SCM+FSA-Memory)*
                   by FINSEQ_1:83;
    then [: NAT, (union {INT} \/ SCM-Memory)* :]
        c= [: NAT, (union {INT,INT*} \/ SCM+FSA-Memory)* :] by ZFMISC_1:119;
    then SCM-Instr c= [: NAT, (union {INT,INT*} \/ SCM+FSA-Memory)* :]
                 by XBOOLE_1:1;
    then SCM-Instr \/ { [J,<*c,f,b*>] : J in {9,10} }
      c= [: NAT, (union {INT,INT*} \/ SCM+FSA-Memory)* :]
                    by A2,XBOOLE_1:8;
   hence thesis by A4,XBOOLE_1:8;
  end;
end;

theorem Th2:
 SCM-Instr c= SCM+FSA-Instr
proof
A1: SCM-Instr \/ { [J,<*c,f,b*>] : J in {9,10} } c= SCM+FSA-Instr by XBOOLE_1:7
;
      SCM-Instr c= SCM-Instr \/ { [J,<*c,f,b*>] : J in {9,10} } by XBOOLE_1:7;
 hence thesis by A1,XBOOLE_1:1;
end;

registration
 cluster SCM+FSA-Instr -> non empty;
 coherence;
end;

registration
 let I be Element of SCM+FSA-Instr;
 cluster InsCode I -> natural;
 coherence
  proof
     I`1 in NAT by MCART_1:10;
   hence thesis by ORDINAL1:def 13;
  end;
end;

theorem Th3:
 for I being Element of SCM+FSA-Instr st InsCode I <= 8
  holds I in SCM-Instr
proof let I be Element of SCM+FSA-Instr such that
A1: InsCode I <= 8;
A2: I in SCM-Instr \/ { [J,<*c,f,b*>] : J in {9,10} } or
   I in { [K,<*c1,f1*>] : K in {11,12} } by XBOOLE_0:def 2;
A3: now assume I in { [K,<*c1,f1*>] : K in {11,12} };
    then consider K,c,f such that
A4:  I = [K,<*c,f*>] and
A5:  K in {11,12};
         I`1 = K by A4,MCART_1:7;
     then I`1 = 11 or I`1 = 12 by A5,TARSKI:def 2;
    hence contradiction by A1;
   end;
       now assume I in { [J,<*c,f,b*>] : J in {9,10} };
    then consider J,c,b,f such that
A6:  I = [J,<*c,f,b*>] and
A7: J in {9,10};
        I`1 = J by A6,MCART_1:7;
     then I`1 = 9 or I`1 = 10 by A7,TARSKI:def 2;
    hence contradiction by A1;
   end;
 hence I in SCM-Instr by A2,A3,XBOOLE_0:def 2;
end;

theorem
     [0,{}] in SCM+FSA-Instr by Th2,AMI_2:2;

definition
 canceled;
 func SCM+FSA-OK ->
  Function of SCM+FSA-Memory,
         {INT,INT*} \/ { SCM+FSA-Instr, SCM+FSA-Instr-Loc } equals
    (SCM+FSA-Memory --> INT*) +* SCM-OK +*
       ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc));
 coherence
  proof
A1: dom SCM-OK c= SCM+FSA-Memory by Th1,FUNCT_2:def 1;
    dom(SCM-OK|SCM-Instr-Loc) c= dom SCM-OK by RELAT_1:89;
    then
A2: dom(SCM-OK|SCM-Instr-Loc) c= SCM+FSA-Memory by A1,XBOOLE_1:1;
    dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
       c= dom(SCM-OK|SCM-Instr-Loc) by RELAT_1:44;
    then
A3: dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)) c= SCM+FSA-Memory
            by A2,XBOOLE_1:1;
    dom((SCM+FSA-Memory --> INT*) +* SCM-OK)
        = dom(SCM+FSA-Memory --> INT*) \/ dom SCM-OK by FUNCT_4:def 1
       .= SCM+FSA-Memory \/ dom SCM-OK by FUNCOP_1:19
       .= SCM+FSA-Memory \/ SCM-Memory by FUNCT_2:def 1
       .= SCM+FSA-Memory by Th1,XBOOLE_1:12;
    then
A4: dom((SCM+FSA-Memory --> INT*) +* SCM-OK +*
       ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)))
        = SCM+FSA-Memory
             \/ dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
                                by FUNCT_4:def 1
       .= SCM+FSA-Memory by A3,XBOOLE_1:12;
A5: (SCM+FSA-Memory --> INT*) +* (SCM-OK +*
       ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)))
    = (SCM+FSA-Memory --> INT*) +* SCM-OK +*
      ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)) by FUNCT_4:15;

    rng(((SCM+FSA-Memory --> INT*) +* SCM-OK)
          +* ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)))
     c= {INT,INT*} \/ { SCM+FSA-Instr, SCM+FSA-Instr-Loc }
    proof let y;
     assume y in rng(((SCM+FSA-Memory --> INT*) +* SCM-OK)
      +* ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)));
      then consider z such that
A6:    z in dom(((SCM+FSA-Memory --> INT*) +* SCM-OK)
         +* ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))) and
A7:   (((SCM+FSA-Memory --> INT*) +* SCM-OK)
         +* ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))).z = y
               by FUNCT_1:def 5;
A8:   dom((SCM+FSA-Memory --> INT*) +* SCM-OK +*
       ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)))
        = dom(SCM+FSA-Memory --> INT*) \/ dom(SCM-OK +*
       ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)))
               by A5,FUNCT_4:def 1
       .= dom(SCM+FSA-Memory --> INT*)
         \ dom(SCM-OK +* ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)))
         \/ dom(SCM-OK +*((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)))
             by XBOOLE_1:39;
A9:     dom(SCM-OK +*((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)))
        = dom SCM-OK \/
           dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
                   by FUNCT_4:def 1
       .= (dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)) \/
           (dom SCM-OK \
           dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))))
                   by XBOOLE_1:39;
      A10: z in dom(SCM+FSA-Memory --> INT*)
         \ dom(SCM-OK +* ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)))
        or
      z in dom(SCM-OK +*((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)))
             by A6,A8,XBOOLE_0:def 2;
      per cases by A9,A10,XBOOLE_0:def 2;
      suppose
A11:    z in dom(SCM+FSA-Memory --> INT*) \
        dom(SCM-OK +* ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)));
        then not z in
       dom(SCM-OK +* ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)))
        by XBOOLE_0:def 4;
       then (SCM+FSA-Memory --> INT*).z = y by A5,A7,FUNCT_4:12;
       then
A12:      y in rng(SCM+FSA-Memory --> INT*) by A11,FUNCT_1:def 5;
A13:     {INT*} c= {INT,INT*} by ZFMISC_1:12;
            rng(SCM+FSA-Memory --> INT*) c= {INT*} by FUNCOP_1:19;
       then rng(SCM+FSA-Memory --> INT*) c= {INT,INT*} by A13,XBOOLE_1:1;
     hence y in {INT,INT*} \/
             { SCM+FSA-Instr, SCM+FSA-Instr-Loc } by A12,XBOOLE_0:def 2;
      end;
      suppose
A14:     z in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc));
       then ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)).z = y
                by A7,FUNCT_4:14;
then A15:     y in rng((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
               by A14,FUNCT_1:def 5;
        rng((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
        c= rng(SCM-Instr.-->SCM+FSA-Instr) by RELAT_1:45;
      then A16:     rng((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
         c= { SCM+FSA-Instr } by FUNCOP_1:14;
          { SCM+FSA-Instr } c= { SCM+FSA-Instr, SCM+FSA-Instr-Loc } by
ZFMISC_1:12
;
      then rng((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
       c= { SCM+FSA-Instr, SCM+FSA-Instr-Loc } by A16,XBOOLE_1:1;
     hence y in {INT,INT*} \/
 { SCM+FSA-Instr, SCM+FSA-Instr-Loc } by A15,XBOOLE_0:def 2;
      end;
      suppose
A17:      z in dom SCM-OK \
       dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc));
       then A18:    not z in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|
SCM-Instr-Loc))
        by XBOOLE_0:def 4;
A19:     z in dom SCM-OK by A17;
        z in dom SCM-OK \/
      dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)) by A17,
XBOOLE_0:def 2;
       then z in dom(SCM-OK +*
        ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)))
         by FUNCT_4:def 1;
then A20:      y = (SCM-OK +*
        ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))).z
                   by A5,A7,FUNCT_4:14
            .= SCM-OK.z by A18,FUNCT_4:12;
A21:      z in SCM-Memory by A19,FUNCT_2:def 1;
A22: dom SCM-OK = SCM-Memory by FUNCT_2:def 1;
            rng(SCM-OK|SCM-Instr-Loc) c= dom(SCM-Instr.-->SCM+FSA-Instr)
         proof let e be set;
          assume e in rng(SCM-OK|SCM-Instr-Loc);
           then consider u be set such that
A23:       u in dom(SCM-OK|SCM-Instr-Loc) and
A24:       (SCM-OK|SCM-Instr-Loc).u = e by FUNCT_1:def 5;
               dom(SCM-OK|SCM-Instr-Loc) c= SCM-Instr-Loc by RELAT_1:87;
           then reconsider u as Element of SCM-Instr-Loc by A23;
               e = SCM-OK.u by A23,A24,FUNCT_1:70
              .= SCM-Instr by AMI_2:11;
           then e in { SCM-Instr } by TARSKI:def 1;
          hence e in dom(SCM-Instr.-->SCM+FSA-Instr) by FUNCOP_1:19;
         end;
        then dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
              = dom(SCM-OK|SCM-Instr-Loc) by RELAT_1:46
             .= SCM-Instr-Loc by A22,RELAT_1:91;
        then not z in SCM-Instr-Loc by A17,XBOOLE_0:def 4;
        then z in {IC SCM} \/ SCM-Data-Loc by A21,AMI_3:def 1,AMI_5:23
,XBOOLE_0:def 2;
        then A25:      z in {IC SCM} or z in SCM-Data-Loc by XBOOLE_0:def 2;
       now per cases by A25,AMI_3:4,TARSKI:def 1;
       suppose z = NAT;
        then y = SCM+FSA-Instr-Loc by A20,AMI_2:7,30;
        then y in { SCM+FSA-Instr, SCM+FSA-Instr-Loc } by TARSKI:def 2;
       hence thesis by XBOOLE_0:def 2;
       end;
       suppose z in SCM-Data-Loc;
        then y = INT by A20,AMI_2:10;
        then y in {INT,INT*} by TARSKI:def 2;
       hence thesis by XBOOLE_0:def 2;
      end;
      end;
     hence thesis;
    end;
    end;
   hence thesis by A4,FUNCT_2:def 1,RELSET_1:11;
  end;
end;

Lm1:
 dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)) c= SCM-Instr-Loc
proof let x;
 assume
A1: x in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc));
      dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
      c= dom(SCM-OK|SCM-Instr-Loc) by RELAT_1:44;
 hence x in SCM-Instr-Loc by A1,RELAT_1:86;
end;

Lm2:
 rng(SCM-OK|SCM-Instr-Loc) c= {SCM-Instr}
proof let x;
 assume x in rng(SCM-OK|SCM-Instr-Loc);
  then consider y such that
A1: y in dom(SCM-OK|SCM-Instr-Loc) and
A2: (SCM-OK|SCM-Instr-Loc).y = x by FUNCT_1:def 5;
A3:  y in SCM-Instr-Loc by A1,RELAT_1:86;
       x = SCM-OK.y by A1,A2,FUNCT_1:70
        .= SCM-Instr by A3,AMI_2:11;
 hence x in {SCM-Instr} by TARSKI:def 1;
end;

Lm3:
 SCM-Instr-Loc c= dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
proof let x;
A1:  dom(SCM-Instr.-->SCM+FSA-Instr) = {SCM-Instr} by FUNCOP_1:19;
 assume
A2: x in SCM-Instr-Loc;
  then x in SCM-Memory;
  then x in dom SCM-OK by FUNCT_2:def 1;
  then x in dom(SCM-OK|SCM-Instr-Loc) by A2,RELAT_1:86;
 hence x in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
          by A1,Lm2,RELAT_1:46;
end;

theorem Th5:
 NAT in SCM+FSA-Memory
 proof
   NAT in {NAT} by TARSKI:def 1;
   then NAT in {NAT} \/ SCM-Data-Loc by XBOOLE_0:def 2;
   then NAT in SCM-Memory by XBOOLE_0:def 2;
  hence NAT in SCM+FSA-Memory by XBOOLE_0:def 2;
 end;

theorem
     x in {9,10} implies [x,<*c,f,b*>] in SCM+FSA-Instr
proof assume
A1: x in {9,10};
  then x = 9 or x = 10 by TARSKI:def 2;
  then reconsider x as Element of Segm 13 by GR_CY_1:10;
      [x,<*c,f,b*>] in { [K,<*c1,f1,b1*>] : K in {9,10}} by A1;
  then [x,<*c,f,b*>] in SCM-Instr \/
 { [K,<*c1,f1,b1*>] : K in {9,10}} by XBOOLE_0:def 2;
 hence thesis by XBOOLE_0:def 2;
end;

theorem
     x in {11,12} implies [x,<*c,f*>] in SCM+FSA-Instr
proof assume
A1: x in {11,12};
  then x = 11 or x = 12 by TARSKI:def 2;
  then reconsider x as Element of Segm 13 by GR_CY_1:10;
      [x,<*c,f*>] in { [K,<*c1,f1*>] : K in {11,12}} by A1;
 hence thesis by XBOOLE_0:def 2;
end;

theorem Th8:
 SCM+FSA-Memory
  = {NAT} \/ SCM+FSA-Data-Loc \/ SCM+FSA-Data*-Loc \/ SCM+FSA-Instr-Loc
           by XBOOLE_1:4;

theorem Th9:
 SCM+FSA-OK.NAT = SCM+FSA-Instr-Loc
 proof
    now assume
A1:   IC SCM in SCM-Instr-Loc;
     then reconsider l = IC SCM as Instruction-Location of SCM
                    by AMI_1:def 4,AMI_3:def 1;
      l in SCM-Instr-Loc by A1;
    hence contradiction by AMI_1:48;
   end;
   then
A2: not NAT in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
        by Lm1,AMI_3:4;
       NAT in SCM-Memory by AMI_2:30;
then A3:  NAT in dom SCM-OK by FUNCT_2:def 1;
   thus SCM+FSA-OK.NAT = ((SCM+FSA-Memory --> INT*) +* SCM-OK).NAT
              by A2,FUNCT_4:12
        .= SCM-OK.NAT by A3,FUNCT_4:14
        .= SCM+FSA-Instr-Loc by AMI_2:7,30;
 end;

theorem Th10:
 SCM+FSA-OK.b = INT
proof
A1: b in SCM-Data-Loc;
then A2: b in SCM-Memory;
    b is Data-Location by A1,AMI_3:def 1,def 2;
   then b is not Instruction-Location of SCM by AMI_5:22;
then A3: not b in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
      by Lm1,AMI_1:def 4,AMI_3:def 1;
A4:  b in dom SCM-OK by A2,FUNCT_2:def 1;
   thus SCM+FSA-OK.b = ((SCM+FSA-Memory --> INT*) +* SCM-OK).b by A3,FUNCT_4:12
        .= SCM-OK.b by A4,FUNCT_4:14
        .= INT by AMI_2:10;
end;

theorem Th11:
 SCM+FSA-OK.a = SCM+FSA-Instr
proof
A1: a in SCM-Instr-Loc;
  then A2: a in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)) by Lm3
;
  A3: dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
   c=dom(SCM-OK|SCM-Instr-Loc) by RELAT_1:44;
 thus SCM+FSA-OK.a
         = ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc)).a
                    by A1,Lm3,FUNCT_4:14
        .= (SCM-Instr.-->SCM+FSA-Instr).((SCM-OK|SCM-Instr-Loc).a)
                    by A1,Lm3,FUNCT_1:22
        .= (SCM-Instr.-->SCM+FSA-Instr).(SCM-OK.a) by A2,A3,FUNCT_1:70
        .= (SCM-Instr.-->SCM+FSA-Instr).SCM-Instr by AMI_2:11
        .= SCM+FSA-Instr by FUNCOP_1:87;
end;

Lm4:
 SCM+FSA-Data*-Loc misses SCM-Memory
 proof assume SCM+FSA-Data*-Loc meets SCM-Memory;
  then consider x such that
A1: x in  SCM+FSA-Data*-Loc and
A2: x in SCM-Memory by XBOOLE_0:3;
A3: not x in NAT by A1,XBOOLE_0:def 4;
   x in  {NAT} \/ SCM-Data-Loc \/ SCM-Instr-Loc by A2;
   then
A4: x in  {NAT} \/ SCM-Data-Loc or x in SCM-Instr-Loc by XBOOLE_0:def 2;
   x in INT by A1;
   then x in NAT \/ [:{0},NAT:] \ {[0,0]} by NUMBERS:def 4;
   then x in NAT \/ [:{0},NAT:];
   then
A5:  x in NAT or x in [:{0},NAT:] by XBOOLE_0:def 2;
  per cases by A4,XBOOLE_0:def 2;
  suppose x in {NAT};
   then
A6:  x = NAT by TARSKI:def 1;
    x in [:{0},NAT:] by A5,A6;
    then ex y,z st x = [y,z] by RELAT_1:def 1;
   hence contradiction by A6;
  end;
  suppose x in SCM-Data-Loc;
   then consider k such that
A7: x = [1,k] by AMI_2:32;
    x in [:{0},NAT:] by A5,A7,ARYTM_3:38;
    then consider y,z such that
A8:  y in {0} and z in NAT and
A9: x= [y,z] by ZFMISC_1:103;
    y = 0 by A8,TARSKI:def 1;
  hence contradiction by A7,A9,ZFMISC_1:33;
  end;
  suppose x in SCM-Instr-Loc;
   then consider k such that
A10: x = k;
  thus contradiction by A3,A10;
  end;
 end;

theorem Th12:
 SCM+FSA-OK.f = INT*
proof
A1: not f in SCM-Memory by Lm4,XBOOLE_0:3;
A2: now assume
A3: f in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc));
         dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|SCM-Instr-Loc))
       c= dom(SCM-OK|SCM-Instr-Loc) by RELAT_1:44;
     then f in dom SCM-OK by A3,RELAT_1:86;
    hence contradiction by A1,FUNCT_2:def 1;
   end;
A4: not f in dom SCM-OK by A1,FUNCT_2:def 1;
   thus SCM+FSA-OK.f = ((SCM+FSA-Memory --> INT*) +* SCM-OK).f by A2,FUNCT_4:12
        .= (SCM+FSA-Memory --> INT*).f by A4,FUNCT_4:12
        .= INT* by FUNCOP_1:13;
end;

theorem Th13:
   SCM+FSA-Instr-Loc <> INT & SCM+FSA-Instr <> INT &
   SCM+FSA-Instr-Loc <> SCM+FSA-Instr &
   SCM+FSA-Instr-Loc <> INT* & SCM+FSA-Instr <> INT*
 proof
  thus SCM+FSA-Instr-Loc <> INT by AMI_2:6;
A1: not ex x,y st 2 = [x,y];
       2 in NAT;
  hence SCM+FSA-Instr <> INT by A1,NUMBERS:17,RELAT_1:def 1;
  thus SCM+FSA-Instr-Loc <> SCM+FSA-Instr by A1,RELAT_1:def 1;
   0 qua Integer in INT by INT_1:def 1;
   then <*0*> is FinSequence of INT by FINSEQ_1:95;
   then
A2:  <*0*> in INT* by FINSEQ_1:def 11;
  hereby assume SCM+FSA-Instr-Loc = INT*;
    then <*0*> in SCM+FSA-Instr-Loc by A2;
    then ex k st <*0*> = k;
    then
A3:   <*0*> is Nat;
     card <*0*> = 1 by CARD_1:79;
     then  <*0*> = { 0 } by A3,CARD_1:66,87,FINSEQ_1:78;
     then [1,0] = 0 by ZFMISC_1:6;
   hence contradiction;
  end;
       now assume {} in SCM+FSA-Instr;
     then consider x,y such that
A4:    {} = [x,y] by RELAT_1:def 1;
    thus contradiction by A4;
   end;
  hence SCM+FSA-Instr <> INT* by FINSEQ_1:66;
 end;

theorem
 for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = SCM+FSA-Instr-Loc
  holds i = NAT
proof let i be Element of SCM+FSA-Memory such that
A1: SCM+FSA-OK.i = SCM+FSA-Instr-Loc;
    not i in SCM+FSA-Instr-Loc by A1,Th11,Th13;
    then
A2: i in {NAT} \/ SCM+FSA-Data-Loc \/ SCM+FSA-Data*-Loc by Th8,XBOOLE_0:def 2;
       not i in SCM+FSA-Data*-Loc by A1,Th12,Th13;
then A3: i in {NAT} \/ SCM+FSA-Data-Loc by A2,XBOOLE_0:def 2;
       not i in SCM+FSA-Data-Loc by A1,Th10,Th13;
  then i in {NAT} by A3,XBOOLE_0:def 2;
 hence i = NAT by TARSKI:def 1;
end;

theorem
  for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = INT
  holds i in SCM+FSA-Data-Loc
proof let i be Element of SCM+FSA-Memory such that
A1: SCM+FSA-OK.i = INT;
       not i in SCM+FSA-Instr-Loc by A1,Th11,Th13;
then A2: i in {NAT} \/ SCM+FSA-Data-Loc \/ SCM+FSA-Data*-Loc by Th8,
XBOOLE_0:def 2;
       not i in SCM+FSA-Data*-Loc by A1,Th12,FUNCT_7:18;
then A3: i in {NAT} \/ SCM+FSA-Data-Loc by A2,XBOOLE_0:def 2;
       not i in {NAT} by A1,Th9,Th13,TARSKI:def 1;
 hence i in SCM+FSA-Data-Loc by A3,XBOOLE_0:def 2;
end;

theorem
 for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = SCM+FSA-Instr
  holds i in SCM+FSA-Instr-Loc
proof let i be Element of SCM+FSA-Memory such that
A1: SCM+FSA-OK.i = SCM+FSA-Instr;
      now assume
A2: i in {NAT} \/ SCM+FSA-Data-Loc \/ SCM+FSA-Data*-Loc;
       not i in SCM+FSA-Data*-Loc by A1,Th12,Th13;
then A3: i in {NAT} \/ SCM+FSA-Data-Loc by A2,XBOOLE_0:def 2;
       not i in SCM+FSA-Data-Loc by A1,Th10,Th13;
    then i in{NAT} by A3,XBOOLE_0:def 2;
   hence contradiction by A1,Th9,Th13,TARSKI:def 1;
  end;
 hence i in SCM+FSA-Instr-Loc by Th8,XBOOLE_0:def 2;
end;

theorem
 for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = INT*
  holds i in SCM+FSA-Data*-Loc
proof let i be Element of SCM+FSA-Memory such that
A1: SCM+FSA-OK.i = INT*;
      not i in SCM+FSA-Instr-Loc by A1,Th11,Th13;
then A2: i in {NAT} \/ SCM+FSA-Data-Loc \/ SCM+FSA-Data*-Loc by Th8,
XBOOLE_0:def 2;
      now assume
A3: i in {NAT} \/ SCM+FSA-Data-Loc;
        not i in {NAT} by A1,Th9,Th13,TARSKI:def 1;
    then i in SCM+FSA-Data-Loc by A3,XBOOLE_0:def 2;
   hence contradiction by A1,Th10,FUNCT_7:18;
  end;
 hence i in SCM+FSA-Data*-Loc by A2,XBOOLE_0:def 2;
end;

definition
 mode SCM+FSA-State is Element of product SCM+FSA-OK;
end;

theorem Th18:
 for s being SCM+FSA-State, I being Element of SCM-Instr
  holds s|SCM-Memory +* (SCM-Instr-Loc --> I) is SCM-State
 proof let s be SCM+FSA-State, I be Element of SCM-Instr;
A1: dom(SCM+FSA-OK) = SCM+FSA-Memory by FUNCT_2:def 1;
A2: dom(s|SCM-Memory) = dom s /\ SCM-Memory by RELAT_1:90
       .= SCM+FSA-Memory /\ SCM-Memory by A1,CARD_3:18
       .= SCM-Memory by XBOOLE_1:21;
A3: dom(s|SCM-Memory +* (SCM-Instr-Loc --> I))
          = dom(s|SCM-Memory) \/ dom(SCM-Instr-Loc --> I) by FUNCT_4:def 1
         .= SCM-Memory \/ SCM-Instr-Loc by A2,FUNCOP_1:19
         .= SCM-Memory by XBOOLE_1:12
         .= dom SCM-OK by FUNCT_2:def 1;
   now let x; assume x in dom SCM-OK;
     then
A4:  x in SCM-Memory by FUNCT_2:def 1;
     then
A5:  x in {IC SCM} \/ SCM-Data-Loc or x in SCM-Instr-Loc
          by AMI_3:def 1,AMI_5:23,XBOOLE_0:def 2;
A6:   SCM-Instr-Loc = dom(SCM-Instr-Loc --> I) by FUNCOP_1:19;
    per cases by A5,XBOOLE_0:def 2;
    suppose x in {IC SCM};
      then
A7:   x = IC SCM by TARSKI:def 1;
      then SCM-OK.x = SCM-Instr-Loc by AMI_2:7,30,AMI_3:4;
      then not x in SCM-Instr-Loc by AMI_2:6,11;
      then
A8:     (s|SCM-Memory +* (SCM-Instr-Loc --> I)).x
            = (s|SCM-Memory).x by A6,FUNCT_4:12
           .= s.x by A2,A4,FUNCT_1:70;
      reconsider a = x as Element of SCM+FSA-Memory by A4,Th1;
      dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
      then
A9:   pi(product SCM+FSA-OK,a) = SCM-Instr-Loc by A7,Th9,AMI_3:4,CARD_3:22;
      s.a in pi(product SCM+FSA-OK,a) by CARD_3:def 6;
     hence (s|SCM-Memory +* (SCM-Instr-Loc --> I)).x in SCM-OK.x
               by A7,A8,A9,AMI_2:7,30,AMI_3:4;
    end;
    suppose
A10:  x in SCM-Data-Loc;
      then SCM-OK.x = INT by AMI_2:10;
      then not x in SCM-Instr-Loc by AMI_2:6,11;
      then
A11:   (s|SCM-Memory +* (SCM-Instr-Loc --> I)).x
            = (s|SCM-Memory).x by A6,FUNCT_4:12
           .= s.x by A2,A4,FUNCT_1:70;
      reconsider a = x as Element of SCM+FSA-Memory by A4,Th1;
      dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
      then
A12:  pi(product SCM+FSA-OK,a) = SCM+FSA-OK.a by CARD_3:22 .= INT by A10,Th10;
      s.a in pi(product SCM+FSA-OK,a) by CARD_3:def 6;
     hence (s|SCM-Memory +* (SCM-Instr-Loc --> I)).x in SCM-OK.x
                   by A10,A11,A12,AMI_2:10;
    end;
    suppose
A13:  x in SCM-Instr-Loc;
      then
A14:  (s|SCM-Memory +* (SCM-Instr-Loc --> I)).x = (SCM-Instr-Loc --> I).x
           by A6,FUNCT_4:14 .= I by A13,FUNCOP_1:13;
      SCM-OK.x = SCM-Instr by A13,AMI_2:11;
     hence (s|SCM-Memory +* (SCM-Instr-Loc --> I)).x in SCM-OK.x
                by A14;
  end;
  end;
 hence s|SCM-Memory +* (SCM-Instr-Loc --> I) is SCM-State by A3,CARD_3:18;
end;

theorem Th19:
 for s being SCM+FSA-State, s' being SCM-State
  holds s +* s' +* s|SCM+FSA-Instr-Loc is SCM+FSA-State
proof let s be SCM+FSA-State, s' be SCM-State;
A1: dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
then reconsider f = SCM+FSA-OK as non-empty ManySortedSet of SCM+FSA-Memory
 by PBOOLE:def 3;
A2: dom s' = dom SCM-OK by CARD_3:18 .= SCM-Memory by FUNCT_2:def 1;
       now let x be set;
    assume
A3:   x in dom s';
then A4:   x in {IC SCM} \/ SCM-Data-Loc or x in SCM-Instr-Loc by A2,
AMI_3:def 1,AMI_5:23,XBOOLE_0:def 2;
    per cases by A4,XBOOLE_0:def 2;
    suppose A5: x in {IC SCM};
      then A6:     x = IC SCM by TARSKI:def 1;
      reconsider a = x as Element of SCM-Memory by A2,A3;
          dom SCM-OK = SCM-Memory by FUNCT_2:def 1;
  then A7:  pi(product SCM-OK,a) = SCM-OK.a by CARD_3:22 .= SCM-Instr-Loc
             by A6,AMI_2:7,AMI_3:4;
          s'.a in pi(product SCM-OK,a) by CARD_3:def 6;
     hence s'.x in f.x by A5,A7,Th9,AMI_3:4,TARSKI:def 1;
    end;
    suppose
A8:    x in SCM-Data-Loc;
then A9:    SCM+FSA-OK.x = INT by Th10;
      reconsider a = x as Element of SCM-Memory by A2,A3;
          dom SCM-OK = SCM-Memory by FUNCT_2:def 1;
  then A10:  pi(product SCM-OK,a) = SCM-OK.a by CARD_3:22;
          s'.a in pi(product SCM-OK,a) by CARD_3:def 6;
     hence s'.x in f.x by A8,A9,A10,AMI_2:10;
    end;
    suppose
A11:   x in SCM-Instr-Loc;
then A12:    SCM-OK.x = SCM-Instr by AMI_2:11;
A13:    SCM+FSA-OK.x = SCM+FSA-Instr by A11,Th11;
          SCM+FSA-Instr = SCM-Instr \/ ({ [J,<*c,f2,b*>] : J in {9,10} } \/
                { [K,<*c1,f1*>] : K in {11,12} }) by XBOOLE_1:4;
then A14:    SCM-Instr c= SCM+FSA-Instr by XBOOLE_1:7;
      reconsider a = x as Element of SCM-Memory by A2,A3;
          dom SCM-OK = SCM-Memory by FUNCT_2:def 1;
  then A15:  pi(product SCM-OK,a) = SCM-OK.a by CARD_3:22;
          s'.a in pi(product SCM-OK,a) by CARD_3:def 6;
     hence s'.x in f.x by A12,A13,A14,A15;
   end;
   end;
then A16: s +* s' is SCM+FSA-State by A1,A2,Th1,PRE_CIRC:9;
A17: s in product SCM+FSA-OK;
       product SCM+FSA-OK c= sproduct SCM+FSA-OK by CARD_3:67;
   then s|SCM+FSA-Instr-Loc in sproduct SCM+FSA-OK by A17,CARD_3:81;
 hence s +* s' +* s|SCM+FSA-Instr-Loc is SCM+FSA-State by A16,CARD_3:69;
end;

definition let s be SCM+FSA-State, u be Element of SCM+FSA-Instr-Loc;
 func SCM+FSA-Chg(s,u) -> SCM+FSA-State equals
   s +* (NAT .--> u);
 coherence
  proof
A1:  dom(SCM+FSA-OK) = SCM+FSA-Memory by FUNCT_2:def 1;
    then dom s = SCM+FSA-Memory by CARD_3:18;
then A2:  dom(s +* (NAT .--> u)) = SCM+FSA-Memory \/ dom(NAT .--> u)
              by FUNCT_4:def 1
      .= SCM+FSA-Memory \/ {NAT} by FUNCOP_1:19
      .= dom(SCM+FSA-OK) by A1,Th5,ZFMISC_1:46;
        now let x be set;
     assume
A3:    x in dom(SCM+FSA-OK);
         now per cases;
      suppose
A4:     x = NAT;
            {NAT} = dom(NAT .--> u) by FUNCOP_1:19;
        then NAT in dom(NAT .--> u) by TARSKI:def 1;
        then (s +* (NAT .--> u)).NAT = (NAT .--> u).NAT by FUNCT_4:14
          .= u by FUNCOP_1:87;
       hence (s +* (NAT .--> u)).x in SCM+FSA-OK.x by A4,Th9;
      end;
      suppose
A5:     x <> NAT;
            {NAT} = dom(NAT .--> u) by FUNCOP_1:19;
        then not x in dom(NAT .--> u) by A5,TARSKI:def 1;
         then (s +* (NAT .--> u)).x = s.x by FUNCT_4:12;
       hence (s +* (NAT .--> u)).x in SCM+FSA-OK.x by A3,CARD_3:18;
     end;
     end;
     hence (s +* (NAT .--> u)).x in SCM+FSA-OK.x;
    end;
   hence thesis by A2,CARD_3:18;
  end;
end;

definition
 let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer;
 func SCM+FSA-Chg(s,t,u) -> SCM+FSA-State equals
   s +* (t .--> u);
 coherence
  proof
A1:  dom(SCM+FSA-OK) = SCM+FSA-Memory by FUNCT_2:def 1;
    then dom s = SCM+FSA-Memory by CARD_3:18;
then
A2:  dom(s +* (t .--> u)) = SCM+FSA-Memory \/ dom(t .--> u) by FUNCT_4:def 1
      .= SCM+FSA-Memory \/ {t} by FUNCOP_1:19
      .= dom(SCM+FSA-OK) by A1,ZFMISC_1:46;
        now let x be set;
     assume
A3:    x in dom(SCM+FSA-OK);
         now per cases;
      suppose
A4:     x = t;
            {t} = dom(t .--> u) by FUNCOP_1:19;
        then t in dom(t .--> u) by TARSKI:def 1;
        then (s +* (t .--> u)).t = (t .--> u).t by FUNCT_4:14
          .= u by FUNCOP_1:87;
        then (s +* (t .--> u)).t in INT by INT_1:def 2;
       hence (s +* (t .--> u)).x in SCM+FSA-OK.x by A4,Th10;
      end;
      suppose
A5:     x <> t;
            {t} = dom(t .--> u) by FUNCOP_1:19;
        then not x in dom(t .--> u) by A5,TARSKI:def 1;
        then (s +* (t .--> u)).x = s.x by FUNCT_4:12;
       hence (s +* (t .--> u)).x in SCM+FSA-OK.x by A3,CARD_3:18;
     end;
     end;
     hence (s +* (t .--> u)).x in SCM+FSA-OK.x;
    end;
   hence thesis by A2,CARD_3:18;
  end;
end;

definition
 let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc,
     u be FinSequence of INT;
 func SCM+FSA-Chg(s,t,u) -> SCM+FSA-State equals
   s +* (t .--> u);
 coherence
  proof
A1:  dom(SCM+FSA-OK) = SCM+FSA-Memory by FUNCT_2:def 1;
    then dom s = SCM+FSA-Memory by CARD_3:18;
then
A2:  dom(s +* (t .--> u)) = SCM+FSA-Memory \/ dom(t .--> u) by FUNCT_4:def 1
      .= SCM+FSA-Memory \/ {t} by FUNCOP_1:19
      .= dom(SCM+FSA-OK) by A1,ZFMISC_1:46;
        now let x be set;
     assume
A3:    x in dom(SCM+FSA-OK);
         now per cases;
      suppose
A4:     x = t;
            {t} = dom(t .--> u) by FUNCOP_1:19;
        then t in dom(t .--> u) by TARSKI:def 1;
        then (s +* (t .--> u)).t = (t .--> u).t by FUNCT_4:14
          .= u by FUNCOP_1:87;
        then (s +* (t .--> u)).t in INT* by FINSEQ_1:def 11;
       hence (s +* (t .--> u)).x in SCM+FSA-OK.x by A4,Th12;
      end;
      suppose
A5:     x <> t;
            {t} = dom(t .--> u) by FUNCOP_1:19;
        then not x in dom(t .--> u) by A5,TARSKI:def 1;
        then (s +* (t .--> u)).x = s.x by FUNCT_4:12;
       hence (s +* (t .--> u)).x in SCM+FSA-OK.x by A3,CARD_3:18;
     end;
     end;
     hence (s +* (t .--> u)).x in SCM+FSA-OK.x;
    end;
   hence thesis by A2,CARD_3:18;
  end;
end;

definition let s be SCM+FSA-State, a be Element of SCM+FSA-Data-Loc;
 redefine
  func s.a -> Integer;
 coherence
  proof
    dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
then A1:  pi(product SCM+FSA-OK,a) = SCM+FSA-OK.a by CARD_3:22 .= INT by Th10;
        s.a in pi(product SCM+FSA-OK,a) by CARD_3:def 6;
   hence s.a is Integer by A1,INT_1:def 2;
  end;
end;

definition let s be SCM+FSA-State, a be Element of SCM+FSA-Data*-Loc;
 redefine func s.a -> FinSequence of INT;
 coherence
  proof
    dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
then A1:  pi(product SCM+FSA-OK,a) = SCM+FSA-OK.a by CARD_3:22 .= INT* by Th12;
        s.a in pi(product SCM+FSA-OK,a) by CARD_3:def 6;
   hence s.a is FinSequence of INT by A1,FINSEQ_1:def 11;
  end;
end;

definition let x be Element of SCM+FSA-Instr;
 given c,f,b,J such that
A1: x = [ J, <*c,f,b*>];
 func x int_addr1 -> Element of SCM+FSA-Data-Loc means
       ex c,f,b st <*c,f,b*> = x`2 & it = c;
  existence
   proof take c,c,f,b;
    thus thesis by A1,MCART_1:7;
   end;
  uniqueness
   proof let a1,a2 be Element of SCM+FSA-Data-Loc;
    given c1,f1,b1 such that
A2:  <*c1,f1,b1*> = x`2 and
A3:  a1 = c1;
    given c2,f2,b2 such that
A4:  <*c2,f2,b2*> = x`2 and
A5:  a2 = c2;
    thus a1 = <*c1,f1,b1*>/.1 by A3,FINSEQ_4:27
     .= a2 by A2,A4,A5,FINSEQ_4:27;
   end;
 func x int_addr2 -> Element of SCM+FSA-Data-Loc means
       ex c,f,b st <*c,f,b*> = x`2 & it = b;
  existence
   proof take b,c,f,b;
    thus thesis by A1,MCART_1:7;
   end;
  correctness
   proof let a1,a2 be Element of SCM+FSA-Data-Loc;
    given c1,f1,b1 such that
A6:  <*c1,f1,b1*> = x`2 and
A7:  a1 = b1;
    given c2,f2,b2 such that
A8:  <*c2,f2,b2*> = x`2 and
A9:  a2 = b2;
    thus a1 = <*c1,f1,b1*>/.3 by A7,FINSEQ_4:27
     .= a2 by A6,A8,A9,FINSEQ_4:27;
   end;
 func x coll_addr1 -> Element of SCM+FSA-Data*-Loc means
       ex c,f,b st <*c,f,b*> = x`2 & it = f;
  existence
   proof take f,c,f,b;
    thus thesis by A1,MCART_1:7;
   end;
  correctness
   proof let a1,a2 be Element of SCM+FSA-Data*-Loc;
    given c1,f1,b1 such that
A10:  <*c1,f1,b1*> = x`2 and
A11:  a1 = f1;
    given c2,f2,b2 such that
A12:  <*c2,f2,b2*> = x`2 and
A13:  a2 = f2;
    thus a1 = <*c1,f1,b1*>/.2 by A11,FINSEQ_4:27
     .= a2 by A10,A12,A13,FINSEQ_4:27;
   end;
end;

definition let x be Element of SCM+FSA-Instr;
 given c,f,J such that
A1: x = [ J, <*c,f*>];
 func x int_addr3 -> Element of SCM+FSA-Data-Loc means
       ex c,f st <*c,f*> = x`2 & it = c;
  existence
   proof take c,c,f;
    thus thesis by A1,MCART_1:7;
   end;
  uniqueness
   proof let a1,a2 be Element of SCM+FSA-Data-Loc;
    given c1,f1 such that
A2:  <*c1,f1*> = x`2 and
A3:  a1 = c1;
    given c2,f2 such that
A4:  <*c2,f2*> = x`2 and
A5:  a2 = c2;
    thus a1 = <*c1,f1*>/.1 by A3,FINSEQ_4:26
     .= a2 by A2,A4,A5,FINSEQ_4:26;
   end;
 func x coll_addr2 -> Element of SCM+FSA-Data*-Loc means
      ex c,f st <*c,f*> = x`2 & it = f;
  existence
   proof take f,c,f;
    thus thesis by A1,MCART_1:7;
   end;
  correctness
   proof let a1,a2 be Element of SCM+FSA-Data*-Loc;
    given c1,f1 such that
A6:  <*c1,f1*> = x`2 and
A7:  a1 = f1;
    given c2,f2 such that
A8:  <*c2,f2*> = x`2 and
A9:  a2 = f2;
    thus a1 = <*c1,f1*>/.2 by A7,FINSEQ_4:26
     .= a2 by A6,A8,A9,FINSEQ_4:26;
   end;
canceled;
end;

definition let s be SCM+FSA-State;
 func IC(s) -> Element of SCM+FSA-Instr-Loc equals
       s.NAT;
 coherence
  proof reconsider z = NAT as Element of SCM+FSA-Memory by Th5;
    dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
then pi(product SCM+FSA-OK,NAT) = SCM+FSA-OK.z by CARD_3:22
     .= SCM+FSA-Instr-Loc by Th9;
   hence thesis by CARD_3:def 6;
  end;
end;

definition let x be Element of SCM+FSA-Instr, s be SCM+FSA-State;
 func SCM+FSA-Exec-Res(x,s) -> SCM+FSA-State means
       ex x' being Element of SCM-Instr, s' being SCM-State st
    x = x' & s' = s|SCM-Memory +* (SCM-Instr-Loc --> x')
           & it = s +* SCM-Exec-Res(x',s') +* s|SCM+FSA-Instr-Loc
      if InsCode x <= 8,
 ex i being Integer, k st k = abs(s.(x int_addr2)) & i = (s.(x coll_addr1))/.k
   & it = SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr1,i),Next IC s)
    if InsCode x = 9,
    ex f being FinSequence of INT,k st k = abs(s.(x int_addr2)) &
     f = s.(x coll_addr1)+*(k,s.(x int_addr1)) &
     it = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),Next IC s)
    if InsCode x = 10,
  it = SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr3,len(s.(x coll_addr2))),Next IC s)
    if InsCode x = 11,
  ex f being FinSequence of INT,k st k = abs(s.(x int_addr3)) & f = k |-> 0
    & it = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr2,f),Next IC s)
    if InsCode x = 12
     otherwise it = s;
 existence
  proof
   hereby assume InsCode x <= 8;
     then reconsider x' = x as Element of SCM-Instr by Th3;
     reconsider s' = s|SCM-Memory +* (SCM-Instr-Loc --> x') as SCM-State
              by Th18;
     reconsider s1 = s +* SCM-Exec-Res(x',s') +* s|SCM+FSA-Instr-Loc
        as SCM+FSA-State by Th19;
    take s1,x',s';
    thus x = x';
    thus s' = s|SCM-Memory +* (SCM-Instr-Loc --> x');
    thus s1 = s +* SCM-Exec-Res(x',s') +* s|SCM+FSA-Instr-Loc;
   end;
   hereby assume InsCode x = 9;
     reconsider k = abs(s.(x int_addr2)) as Element of NAT;
     reconsider i = (s.(x coll_addr1))/.k as Integer;
    take s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr1,i),Next IC s);
    take i,k;
    thus k = abs(s.(x int_addr2)) & i = (s.(x coll_addr1))/.k
      & s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr1,i),Next IC s);
   end;
   hereby assume InsCode x = 10;
     reconsider k = abs(s.(x int_addr2)) as Element of NAT;
    per cases;
    suppose
A1:   k in dom( s.(x coll_addr1));
then A2:   {k} c= dom( s.(x coll_addr1)) by ZFMISC_1:37;
     set f = s.(x coll_addr1) +* (k.-->s.(x int_addr1));
         dom f = dom(s.(x coll_addr1)) \/ dom((k.-->s.(x int_addr1)))
                    by FUNCT_4:def 1
          .= dom(s.(x coll_addr1)) \/ {k} by FUNCOP_1:19
          .= dom(s.(x coll_addr1)) by A2,XBOOLE_1:12
          .= Seg len(s.(x coll_addr1)) by FINSEQ_1:def 3;
     then reconsider f as FinSequence by FINSEQ_1:def 2;
A3:   rng f c= rng(s.(x coll_addr1)) \/ rng((k.-->s.(x int_addr1)))
           by FUNCT_4:18;
A4:   rng(s.(x coll_addr1)) c= INT by FINSEQ_1:def 4;
A5:   s.(x int_addr1) in INT by INT_1:def 2;
         rng((k.-->s.(x int_addr1))) = {s.(x int_addr1)} by FUNCOP_1:14;
     then rng((k.-->s.(x int_addr1))) c= INT by A5,ZFMISC_1:37;
     then rng(s.(x coll_addr1)) \/ rng((k.-->s.(x int_addr1))) c= INT
               by A4,XBOOLE_1:8;
     then rng f c= INT by A3,XBOOLE_1:1;
     then reconsider f as FinSequence of INT by FINSEQ_1:def 4;
     take s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),Next IC s);
     take f,k;
     thus k = abs(s.(x int_addr2));
     thus f = s.(x coll_addr1) +* (k,s.(x int_addr1)) by A1,FUNCT_7:def 3;
     thus s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),Next IC s);
    end;
    suppose
A6:   not k in dom( s.(x coll_addr1));
     reconsider f = s.(x coll_addr1) as FinSequence of INT;
     take s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),Next IC s);
     take f,k;
     thus k = abs(s.(x int_addr2));
    thus f = s.(x coll_addr1) +* (k,s.(x int_addr1)) by A6,FUNCT_7:def 3;
    thus s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),Next IC s);
   end;
   end;
   thus InsCode x = 11 implies ex s1 being SCM+FSA-State st
    s1 = SCM+FSA-Chg(
               SCM+FSA-Chg(s,x int_addr3,len(s.(x coll_addr2))),Next IC s);
   hereby assume InsCode x = 12;
    reconsider k = abs(s.(x int_addr3)) as Element of NAT;
        k |-> 0 = Seg k --> 0 by FINSEQ_2:def 2;
then A7:  rng(k |-> 0) c= {0} by FUNCOP_1:19;
        0 in INT by INT_1:def 2;
    then {0} c= INT by ZFMISC_1:37;
    then rng(k |-> 0) c= INT by A7,XBOOLE_1:1;
    then reconsider f = k |-> 0 as FinSequence of INT by FINSEQ_1:def 4;
    take s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr2,f),Next IC s);
    take f,k;
    thus k = abs(s.(x int_addr3)) & f = k |-> 0
        & s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr2,f),Next IC s);
   end;
   thus thesis;
  end;
 uniqueness;
 consistency;
end;

definition
 func SCM+FSA-Exec ->
  Function of SCM+FSA-Instr, Funcs(product SCM+FSA-OK, product SCM+FSA-OK)
         means
      for x being Element of SCM+FSA-Instr, y being SCM+FSA-State holds
    (it.x qua Element of Funcs(product SCM+FSA-OK, product SCM+FSA-OK)).y =
    SCM+FSA-Exec-Res(x,y);
 existence
  proof
   deffunc
    U(Element of SCM+FSA-Instr, SCM+FSA-State) = SCM+FSA-Exec-Res($1,$2);
   consider f being
    Function of [:SCM+FSA-Instr,product SCM+FSA-OK:], product SCM+FSA-OK
   such that
A1:   for x being Element of SCM+FSA-Instr, y being SCM+FSA-State holds
    f.(x,y) = U(x,y) from BINOP_1:sch 4;
   take curry f;
   let x be Element of SCM+FSA-Instr, y be SCM+FSA-State;
   thus (curry f).x.y = f.(x,y) by CAT_2:3 .= SCM+FSA-Exec-Res(x,y) by A1;
  end;
 uniqueness
  proof
   let f,g be
      Function of SCM+FSA-Instr, Funcs(product SCM+FSA-OK, product SCM+FSA-OK)
   such that
A2:   for x being Element of SCM+FSA-Instr, y being SCM+FSA-State holds
      (f.x qua Element of Funcs(product SCM+FSA-OK, product SCM+FSA-OK)).y =
      SCM+FSA-Exec-Res(x,y) and
A3:   for x being Element of SCM+FSA-Instr, y being SCM+FSA-State holds
      (g.x qua Element of Funcs(product SCM+FSA-OK, product SCM+FSA-OK)).y =
      SCM+FSA-Exec-Res(x,y);
        now let x be Element of SCM+FSA-Instr;
     reconsider gx=g.x, fx=f.x as
       Function of product SCM+FSA-OK, product SCM+FSA-OK;
         now let y be SCM+FSA-State;
      thus
           fx.y = SCM+FSA-Exec-Res(x,y) by A2
      .= gx.y by A3;
     end;
     hence f.x = g.x by FUNCT_2:113;
    end;
   hence f = g by FUNCT_2:113;
  end;
end;

theorem
     for s being SCM+FSA-State, u being Element of SCM+FSA-Instr-Loc
  holds SCM+FSA-Chg(s,u).NAT = u
 proof let s be SCM+FSA-State, u be Element of SCM+FSA-Instr-Loc;
      {NAT} = dom(NAT .--> u) by FUNCOP_1:19;
  then NAT in dom(NAT .--> u) by TARSKI:def 1;
  hence SCM+FSA-Chg(s,u).NAT = (NAT .--> u).NAT by FUNCT_4:14
    .= u by FUNCOP_1:87;
 end;

theorem
     for s being SCM+FSA-State, u being Element of SCM+FSA-Instr-Loc,
     mk being Element of SCM+FSA-Data-Loc
  holds SCM+FSA-Chg(s,u).mk = s.mk
proof let s be SCM+FSA-State, u be Element of SCM+FSA-Instr-Loc,
     mk be Element of SCM+FSA-Data-Loc;
A1:  SCM+FSA-OK.NAT = SCM+FSA-Instr-Loc & SCM+FSA-OK.mk = INT by Th9,Th10;
      {NAT} = dom(NAT .--> u) by FUNCOP_1:19;
then  not mk in dom(NAT .--> u) by A1,Th13,TARSKI:def 1;
  hence SCM+FSA-Chg(s,u).mk = s.mk by FUNCT_4:12;
end;

theorem
     for s being SCM+FSA-State, u being Element of SCM+FSA-Instr-Loc,
     p being Element of SCM+FSA-Data*-Loc
  holds SCM+FSA-Chg(s,u).p = s.p
proof let s be SCM+FSA-State, u be Element of SCM+FSA-Instr-Loc,
     mk be Element of SCM+FSA-Data*-Loc;
A1:  SCM+FSA-OK.NAT = SCM+FSA-Instr-Loc & SCM+FSA-OK.mk = INT* by Th9,Th12;
      {NAT} = dom(NAT .--> u) by FUNCOP_1:19;
then  not mk in dom(NAT .--> u) by A1,Th13,TARSKI:def 1;
  hence SCM+FSA-Chg(s,u).mk = s.mk by FUNCT_4:12;
end;

theorem
     for s being SCM+FSA-State, u,v being Element of SCM+FSA-Instr-Loc
  holds SCM+FSA-Chg(s,u).v = s.v
proof let s be SCM+FSA-State, u,v be Element of SCM+FSA-Instr-Loc;
  {NAT} = dom(NAT .--> u) by FUNCOP_1:19;
  then not v in dom(NAT .--> u) by TARSKI:def 1;
  hence SCM+FSA-Chg(s,u).v = s.v by FUNCT_4:12;
end;

theorem
     for s being SCM+FSA-State,
     t being Element of SCM+FSA-Data-Loc, u being Integer
  holds SCM+FSA-Chg(s,t,u).NAT = s.NAT
proof let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer;
A1:  SCM+FSA-OK.NAT = SCM+FSA-Instr-Loc & SCM+FSA-OK.t = INT by Th9,Th10;
      {t} = dom(t .--> u) by FUNCOP_1:19;
then  not NAT in dom(t .--> u) by A1,Th13,TARSKI:def 1;
 hence SCM+FSA-Chg(s,t,u).NAT = s.NAT by FUNCT_4:12;
end;

theorem
     for s being SCM+FSA-State,
     t being Element of SCM+FSA-Data-Loc, u being Integer
  holds SCM+FSA-Chg(s,t,u).t = u
proof let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer;
     {t} = dom(t .--> u) by FUNCOP_1:19;
then t in dom(t .--> u) by TARSKI:def 1;
 hence SCM+FSA-Chg(s,t,u).t = (t .--> u).t by FUNCT_4:14
   .= u by FUNCOP_1:87;
end;

theorem
     for s being SCM+FSA-State,
     t being Element of SCM+FSA-Data-Loc, u being Integer,
     mk being Element of SCM+FSA-Data-Loc st mk <> t
  holds SCM+FSA-Chg(s,t,u).mk = s.mk
proof let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer,
     mk be Element of SCM+FSA-Data-Loc such that
A1:   mk <> t;
      {t} = dom(t .--> u) by FUNCOP_1:19;
then not mk in dom(t .--> u) by A1,TARSKI:def 1;
 hence SCM+FSA-Chg(s,t,u).mk = s.mk by FUNCT_4:12;
end;

theorem
     for s being SCM+FSA-State,
     t being Element of SCM+FSA-Data-Loc, u being Integer,
     f being Element of SCM+FSA-Data*-Loc
  holds SCM+FSA-Chg(s,t,u).f = s.f
proof let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer,
     mk be Element of SCM+FSA-Data*-Loc;
A1:  SCM+FSA-OK.t = INT & SCM+FSA-OK.mk = INT* by Th10,Th12;
      {t} = dom(t .--> u) by FUNCOP_1:19;
then  not mk in dom(t .--> u) by A1,FUNCT_7:18,TARSKI:def 1;
 hence SCM+FSA-Chg(s,t,u).mk = s.mk by FUNCT_4:12;
end;

theorem
     for s being SCM+FSA-State,
     t being Element of SCM+FSA-Data-Loc, u being Integer,
     v being Element of SCM+FSA-Instr-Loc
  holds SCM+FSA-Chg(s,t,u).v = s.v
proof let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer,
     v be Element of SCM+FSA-Instr-Loc;
A1:     SCM+FSA-OK.v = SCM+FSA-Instr & SCM+FSA-OK.t = INT by Th10,Th11;
      {t} = dom(t .--> u) by FUNCOP_1:19;
then not v in dom(t .--> u) by A1,Th13,TARSKI:def 1;
 hence SCM+FSA-Chg(s,t,u).v = s.v by FUNCT_4:12;
end;

theorem
     for s being SCM+FSA-State,
     t being Element of SCM+FSA-Data*-Loc, u being FinSequence of INT
  holds SCM+FSA-Chg(s,t,u).t = u
proof let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc,
     u be FinSequence of INT;
     {t} = dom(t .--> u) by FUNCOP_1:19;
then t in dom(t .--> u) by TARSKI:def 1;
 hence SCM+FSA-Chg(s,t,u).t = (t .--> u).t by FUNCT_4:14
   .= u by FUNCOP_1:87;
end;

theorem
     for s being SCM+FSA-State,
     t being Element of SCM+FSA-Data*-Loc, u being FinSequence of INT,
     mk being Element of SCM+FSA-Data*-Loc st mk <> t
  holds SCM+FSA-Chg(s,t,u).mk = s.mk
proof let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc,
        u be FinSequence of INT,
     mk be Element of SCM+FSA-Data*-Loc such that
A1:   mk <> t;
      {t} = dom(t .--> u) by FUNCOP_1:19;
then  not mk in dom(t .--> u) by A1,TARSKI:def 1;
 hence SCM+FSA-Chg(s,t,u).mk = s.mk by FUNCT_4:12;
end;

theorem
     for s being SCM+FSA-State,
     t being Element of SCM+FSA-Data*-Loc, u being FinSequence of INT,
     a being Element of SCM+FSA-Data-Loc
  holds SCM+FSA-Chg(s,t,u).a = s.a
proof let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc,
          u be FinSequence of INT,
     mk be Element of SCM+FSA-Data-Loc;
A1:  SCM+FSA-OK.t = INT* & SCM+FSA-OK.mk = INT by Th10,Th12;
      {t} = dom(t .--> u) by FUNCOP_1:19;
then  not mk in dom(t .--> u) by A1,FUNCT_7:18,TARSKI:def 1;
 hence SCM+FSA-Chg(s,t,u).mk = s.mk by FUNCT_4:12;
end;

theorem
     for s being SCM+FSA-State,
     t being Element of SCM+FSA-Data*-Loc, u being FinSequence of INT,
     v being Element of SCM+FSA-Instr-Loc
  holds SCM+FSA-Chg(s,t,u).v = s.v
proof let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc,
     u be FinSequence of INT,
     v be Element of SCM+FSA-Instr-Loc;
A1:     SCM+FSA-OK.v = SCM+FSA-Instr & SCM+FSA-OK.t = INT* by Th11,Th12;
      {t} = dom(t .--> u) by FUNCOP_1:19;
then not v in dom(t .--> u) by A1,Th13,TARSKI:def 1;
 hence SCM+FSA-Chg(s,t,u).v = s.v by FUNCT_4:12;
end;

theorem
 SCM+FSA-Data*-Loc misses SCM-Memory by Lm4;
