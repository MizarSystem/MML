:: An Extension of { \bf SCM }
::  by Andrzej Trybulec , Yatsuka Nakamura and Piotr Rudnicki
::
:: Received February 3, 1996
:: Copyright (c) 1996 Association of Mizar Users
 
environ

 vocabularies NUMBERS, SUBSET_1, AMI_2, XBOOLE_0, TARSKI, CARD_1, FINSEQ_1,
      ZFMISC_1, RELAT_1, AMI_1, ORDINAL1, MCART_1, XXREAL_0, FUNCT_1, FUNCOP_1,
      FUNCT_4, INT_1, CARD_3, PBOOLE, NAT_1, PARTFUN1, COMPLEX1, FINSEQ_2,
      FUNCT_2, FUNCT_5, SCMFSA_1, GROUP_9, RECDEF_2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, CARD_1, NUMBERS,
      NAT_1, MCART_1, INT_2, PBOOLE, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2,
      BINOP_1, INT_1, FINSEQ_1, FUNCT_4, CAT_2, FINSEQ_2, CARD_3, FUNCOP_1,
      FINSEQ_4, AMI_2, FUNCT_7, XXREAL_0, RECDEF_2;
 constructors DOMAIN_1, XXREAL_0, INT_2, FINSEQ_4, PBOOLE, CAT_2, REAL_1,
      WELLORD2, RELSET_1, AMI_2, FUNCT_7, RECDEF_2;
 registrations XBOOLE_0, FUNCT_1, ORDINAL1, FUNCOP_1, NUMBERS, XREAL_0, INT_1,
      FINSEQ_1, CARD_3, GR_CY_1, AMI_2, RELAT_1, FINSET_1, CARD_1, CARD_2,
      RELSET_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET;
 definitions TARSKI, FUNCOP_1, CARD_1, AMI_2, FINSEQ_1, RELAT_1, MCART_1;
 theorems ZFMISC_1, FUNCT_2, TARSKI, CAT_2, FUNCOP_1, INT_1, CARD_3, FINSEQ_1,
      FINSEQ_4, MCART_1, FUNCT_4, RELAT_1, FUNCT_1, FINSEQ_2, PRE_CIRC, AMI_2,
      FUNCT_7, RELSET_1, ORDINAL1, XBOOLE_0, XBOOLE_1, NUMBERS, CARD_1,
      PARTFUN1, NAT_1, FUNCT_5, RECDEF_2;
 schemes BINOP_1;

begin

reserve x,y,z for set,
  k for Element of NAT;

notation
  synonym SCM+FSA-Data-Loc for SCM-Data-Loc;
end;

definition
  func SCM+FSA-Data*-Loc equals
  INT \ NAT;
  coherence;
end;

definition
  func SCM+FSA-Memory equals
  SCM-Memory \/ SCM+FSA-Data*-Loc;
  coherence;
end;

registration
  cluster SCM+FSA-Memory -> non empty;
  coherence;
end;

theorem Th1:
  SCM-Memory c= SCM+FSA-Memory by XBOOLE_1:7;

definition
  redefine func SCM+FSA-Data-Loc -> Subset of SCM+FSA-Memory;
  coherence
  proof
    SCM-Data-Loc c= SCM-Memory;
    hence thesis by Th1,XBOOLE_1:1;
  end;
end;

definition
  redefine func SCM+FSA-Data*-Loc -> Subset of SCM+FSA-Memory;
  coherence by XBOOLE_1:7;
  canceled;
end;

definition
  redefine func NAT -> Subset of SCM+FSA-Memory;
  coherence by Th1,XBOOLE_1:1;
end;

registration
  cluster SCM+FSA-Data*-Loc -> non empty;
  coherence
  proof
    not INT c= NAT by NUMBERS:17,27,XBOOLE_0:def 10;
    hence thesis by XBOOLE_1:37;
  end;
end;

reserve J,K for Element of Segm 13,
  a for Element of NAT,
  b,b1,b2,c,c1,c2 for Element of SCM+FSA-Data-Loc,
  f,f1,f2 for Element of SCM+FSA-Data*-Loc;

definition
  func SCM+FSA-Instr -> non empty set equals
  SCM-Instr \/ { [J,{},<*c,f,b*>] : J in {9,10} }
   \/ { [K,{},<*c1,f1*>] : K in {11,12} };
  coherence;
end;

theorem Th2:
  SCM-Instr c= SCM+FSA-Instr
proof
A1: SCM-Instr c= SCM-Instr \/ { [J,{},<*c,f,b*>] : J in {9,10} } by XBOOLE_1:7;
  SCM-Instr \/ { [J,{},<*c,f,b*>] : J in {9,10} } c= SCM+FSA-Instr
   by XBOOLE_1:7;
  hence thesis by A1,XBOOLE_1:1;
end;

registration
  cluster SCM+FSA-Instr -> non empty;
  coherence;
end;

LmX:
 SCM+FSA-Instr c= [:NAT,NAT*,proj2 SCM+FSA-Instr:] proof let x;
  assume
Z:  x in SCM+FSA-Instr;
  per cases by Z,XBOOLE_0:def 3;
  suppose
S: x in SCM-Instr \/ { [J,{},<*c,f,b*>] : J in {9,10} };
  per cases by S,XBOOLE_0:def 3;
  suppose x in SCM-Instr;
   then
X:  x in [:NAT,NAT*,proj2 SCM-Instr:] by AMI_2:34;
   proj2 SCM-Instr c= proj2 SCM+FSA-Instr by Th2,FUNCT_5:5;
   then [:NAT,NAT*,proj2 SCM-Instr:] c= [:NAT,NAT*,proj2 SCM+FSA-Instr:]
    by MCART_1:77;
  hence x in [:NAT,NAT*,proj2 SCM+FSA-Instr:] by X;
  end;
  suppose x in { [J,{},<*c,f,b*>] : J in {9,10}};
   then consider J,c,b,f such that
W:  x = [J,{},<*c,f,b*>] & J in {9,10};
X: {} in NAT* by FINSEQ_1:66;
   J in NAT & <*c,f,b*> in proj2 SCM+FSA-Instr by Z,W,RELAT_1:def 5;
  hence x in [:NAT,NAT*,proj2 SCM+FSA-Instr:] by W,MCART_1:73,X;
  end;
  end;
  suppose x in { [K,{},<*c1,f1*>] : K in {11,12} };
   then consider K,c1,f1 such that
W: x = [K,{},<*c1,f1*>] & K in {11,12};
X: {} in NAT* by FINSEQ_1:66;
   K in NAT & <*c1,f1*> in proj2 SCM+FSA-Instr by Z,W,RELAT_1:def 5;
  hence x in [:NAT,NAT*,proj2 SCM+FSA-Instr:] by W,MCART_1:73,X;
  end;
 end;

registration
  let I be Element of SCM+FSA-Instr;
  cluster I`1_3 -> natural;
  coherence
  proof
W: SCM+FSA-Instr c= [:NAT,NAT*,proj2 SCM+FSA-Instr:] by LmX;
   I in SCM+FSA-Instr;
   then I in [:NAT,NAT*,proj2 SCM+FSA-Instr:] by W;
   then I`1_3 in NAT by RECDEF_2:2;
   hence thesis;
  end;
end;

theorem Th3:
  for I being Element of SCM+FSA-Instr st I`1_3 <= 8 holds I in SCM-Instr
proof
  let I be Element of SCM+FSA-Instr such that
A1: I`1_3 <= 8;
A2: now
    assume I in { [K,{},<*c1,f1*>] : K in {11,12} };
    then consider K,c,f such that
A3: I = [K,{},<*c,f*>] and
A4: K in {11,12};
    I`1_3 = K by A3,RECDEF_2:def 1;
    then I`1_3 = 11 or I`1_3 = 12 by A4,TARSKI:def 2;
    hence contradiction by A1;
  end;
A5: now
    assume I in { [J,{},<*c,f,b*>] : J in {9,10} };
    then consider J,c,b,f such that
A6: I = [J,{},<*c,f,b*>] and
A7: J in {9,10};
    I`1_3 = J by A6,RECDEF_2:def 1;
    then I`1_3 = 9 or I`1_3 = 10 by A7,TARSKI:def 2;
    hence contradiction by A1;
  end;
  I in SCM-Instr \/ { [J,{},<*c,f,b*>] : J in {9,10} }
   or I in { [K,{},<*c1,f1*>] : K in {11,12} } by XBOOLE_0:def 3;
  hence thesis by A2,A5,XBOOLE_0:def 3;
end;

theorem
  [0,{},{}] in SCM+FSA-Instr by Th2,AMI_2:2;

definition
  canceled;
  func SCM+FSA-OK -> Function of SCM+FSA-Memory, {INT,INT*} \/ { SCM+FSA-Instr
  , NAT } equals
  (SCM+FSA-Memory --> INT*) +* SCM-OK +* ((SCM-Instr.-->
  SCM+FSA-Instr)*(SCM-OK|NAT));
  coherence
  proof
A1: (SCM+FSA-Memory --> INT*) +* (SCM-OK +* ((SCM-Instr.-->SCM+FSA-Instr)*
    (SCM-OK|NAT))) = (SCM+FSA-Memory --> INT*) +* SCM-OK +* ((SCM-Instr.-->
    SCM+FSA-Instr)*(SCM-OK|NAT)) by FUNCT_4:15;
A2: rng(((SCM+FSA-Memory --> INT*) +* SCM-OK) +* ((SCM-Instr.-->
    SCM+FSA-Instr)*(SCM-OK|NAT))) c= {INT,INT*} \/ { SCM+FSA-Instr, NAT }
    proof
      let y;
A3:   dom(SCM-OK +*((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT))) = dom
      SCM-OK \/ dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)) by FUNCT_4:def 1
        .= (dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)) \/ (dom SCM-OK \
      dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)))) by XBOOLE_1:39;
      assume y in rng(((SCM+FSA-Memory --> INT*) +* SCM-OK) +* ((SCM-Instr
      .-->SCM+FSA-Instr)*(SCM-OK|NAT)));
      then consider z such that
A4:   z in dom(((SCM+FSA-Memory --> INT*) +* SCM-OK) +* ((SCM-Instr
      .-->SCM+FSA-Instr)*(SCM-OK|NAT))) and
A5:   (((SCM+FSA-Memory --> INT*) +* SCM-OK) +* ((SCM-Instr.-->
      SCM+FSA-Instr)*(SCM-OK|NAT))).z = y by FUNCT_1:def 5;
      dom((SCM+FSA-Memory --> INT*) +* SCM-OK +* ((SCM-Instr.-->
SCM+FSA-Instr)*(SCM-OK|NAT))) = dom(SCM+FSA-Memory --> INT*) \/ dom(SCM-OK +* (
      (SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT))) by A1,FUNCT_4:def 1
        .= dom(SCM+FSA-Memory --> INT*) \ dom(SCM-OK +* ((SCM-Instr.-->
SCM+FSA-Instr)*(SCM-OK|NAT))) \/ dom(SCM-OK +*((SCM-Instr.-->SCM+FSA-Instr)*(
      SCM-OK|NAT))) by XBOOLE_1:39;
      then
A6:   z in dom(SCM+FSA-Memory --> INT*) \ dom(SCM-OK +* ((SCM-Instr.-->
SCM+FSA-Instr)*(SCM-OK|NAT))) or z in dom(SCM-OK +*((SCM-Instr.-->SCM+FSA-Instr
      )*(SCM-OK|NAT))) by A4,XBOOLE_0:def 3;
      per cases by A3,A6,XBOOLE_0:def 3;
      suppose
A7:     z in dom(SCM+FSA-Memory --> INT*) \ dom(SCM-OK +* ((SCM-Instr
        .-->SCM+FSA-Instr)*(SCM-OK|NAT)));
        then
        not z in dom(SCM-OK +* ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)
        )) by XBOOLE_0:def 5;
        then (SCM+FSA-Memory --> INT*).z = y by A1,A5,FUNCT_4:12;
        then
A8:     y in rng(SCM+FSA-Memory --> INT*) by A7,FUNCT_1:def 5;
        {INT*} c= {INT,INT*} & rng(SCM+FSA-Memory --> INT*) c= {INT*} by
FUNCOP_1:19,ZFMISC_1:12;
        then rng(SCM+FSA-Memory --> INT*) c= {INT,INT*} by XBOOLE_1:1;
        hence thesis by A8,XBOOLE_0:def 3;
      end;
      suppose
A9:     z in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT));
        then ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)).z = y by A5,FUNCT_4:14
;
        then
A10:    y in rng((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK| NAT)) by A9,
FUNCT_1:def 5;
        rng((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)) c= rng(SCM-Instr
        .-->SCM+FSA-Instr) by RELAT_1:45;
        then
A11:    rng((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)) c= { SCM+FSA-Instr
        } by FUNCOP_1:14;
        { SCM+FSA-Instr } c= { SCM+FSA-Instr, NAT } by ZFMISC_1:12;
        then
        rng((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)) c= { SCM+FSA-Instr
        , NAT } by A11,XBOOLE_1:1;
        hence thesis by A10,XBOOLE_0:def 3;
      end;
      suppose
A12:    z in dom SCM-OK \ dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK| NAT));
        then
A13:    not z in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK| NAT)) by
XBOOLE_0:def 5;
        z in dom SCM-OK \/ dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT))
        by A12,XBOOLE_0:def 3;
        then z in dom(SCM-OK +* ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)))
        by FUNCT_4:def 1;
        then
A14:    y = (SCM-OK +* ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT))).z by A1,A5,
FUNCT_4:14
          .= SCM-OK.z by A13,FUNCT_4:12;
        z in dom SCM-OK by A12;
        then
A15:    z in SCM-Memory by FUNCT_2:def 1;
A16:    dom SCM-OK = SCM-Memory by FUNCT_2:def 1;
        rng(SCM-OK|NAT) c= dom(SCM-Instr.-->SCM+FSA-Instr)
        proof
          let e be set;
          assume e in rng(SCM-OK|NAT);
          then consider u be set such that
A17:      u in dom(SCM-OK|NAT) and
A18:      (SCM-OK|NAT).u = e by FUNCT_1:def 5;
          dom(SCM-OK|NAT) c= NAT by RELAT_1:87;
          then reconsider u as Element of NAT by A17;
          e = SCM-OK.u by A17,A18,FUNCT_1:70
            .= SCM-Instr by AMI_2:11;
          then e in { SCM-Instr } by TARSKI:def 1;
          hence thesis by FUNCOP_1:19;
        end;
        then dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)) = dom(SCM-OK|NAT)
        by RELAT_1:46
          .= NAT by A16,RELAT_1:91;
        then not z in NAT by A12,XBOOLE_0:def 5;
        then z in {NAT} \/ SCM-Data-Loc by A15,XBOOLE_0:def 3;
        then
A19:    z in {NAT} or z in SCM-Data-Loc by XBOOLE_0:def 3;
        now
          per cases by A19,TARSKI:def 1;
          suppose
            z = NAT;
            then y = NAT by A14,AMI_2:7,30;
            then y in { SCM+FSA-Instr, NAT } by TARSKI:def 2;
            hence thesis by XBOOLE_0:def 3;
          end;
          suppose
            z in SCM-Data-Loc;
            then y = INT by A14,AMI_2:10;
            then y in {INT,INT*} by TARSKI:def 2;
            hence thesis by XBOOLE_0:def 3;
          end;
        end;
        hence thesis;
      end;
    end;
A20: dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)) c= dom(SCM-OK|NAT) by
RELAT_1:44;
    dom SCM-OK c= SCM+FSA-Memory & dom(SCM-OK|NAT) c= dom SCM-OK by Th1,
FUNCT_2:def 1,RELAT_1:89;
    then
A21: dom(SCM-OK|NAT) c= SCM+FSA-Memory by XBOOLE_1:1;
    dom((SCM+FSA-Memory --> INT*) +* SCM-OK) = dom(SCM+FSA-Memory --> INT*
    ) \/ dom SCM-OK by FUNCT_4:def 1
      .= SCM+FSA-Memory \/ dom SCM-OK by FUNCOP_1:19
      .= SCM+FSA-Memory \/ SCM-Memory by FUNCT_2:def 1
      .= SCM+FSA-Memory by XBOOLE_1:7,12;
    then dom((SCM+FSA-Memory --> INT*) +* SCM-OK +* ((SCM-Instr.-->
    SCM+FSA-Instr)*(SCM-OK|NAT))) = SCM+FSA-Memory \/ dom((SCM-Instr.-->
    SCM+FSA-Instr)*(SCM-OK|NAT)) by FUNCT_4:def 1
      .= SCM+FSA-Memory by A21,A20,XBOOLE_1:1,12;
    hence thesis by A2,FUNCT_2:def 1,RELSET_1:11;
  end;
end;

Lm1: dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)) c= NAT
proof
  let x;
A1: dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)) c= dom(SCM-OK|NAT) by
RELAT_1:44;
  assume x in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT));
  hence thesis by A1,RELAT_1:86;
end;

Lm2: rng(SCM-OK|NAT) c= {SCM-Instr}
proof
  let x;
  assume x in rng(SCM-OK|NAT);
  then consider y such that
A1: y in dom(SCM-OK|NAT) and
A2: (SCM-OK|NAT).y = x by FUNCT_1:def 5;
A3: y in NAT by A1,RELAT_1:86;
  x = SCM-OK.y by A1,A2,FUNCT_1:70
    .= SCM-Instr by A3,AMI_2:11;
  hence thesis by TARSKI:def 1;
end;

Lm3: NAT c= dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT))
proof
  let x;
  assume
A1: x in NAT;
  then x in SCM-Memory;
  then x in dom SCM-OK by FUNCT_2:def 1;
  then
  dom(SCM-Instr.-->SCM+FSA-Instr) = {SCM-Instr} & x in dom(SCM-OK|NAT) by A1,
FUNCOP_1:19,RELAT_1:86;
  hence thesis by Lm2,RELAT_1:46;
end;

theorem Th5:
  NAT in SCM+FSA-Memory
proof
  NAT in {NAT} by TARSKI:def 1;
  then NAT in {NAT} \/ SCM-Data-Loc by XBOOLE_0:def 3;
  then NAT in SCM-Memory by XBOOLE_0:def 3;
  hence thesis by XBOOLE_0:def 3;
end;

theorem
  x in {9,10} implies [x,{},<*c,f,b*>] in SCM+FSA-Instr
proof
  assume
A1: x in {9,10};
  then x = 9 or x = 10 by TARSKI:def 2;
  then reconsider x as Element of Segm 13 by NAT_1:45;
  [x,{},<*c,f,b*>] in { [K,{},<*c1,f1,b1*>] : K in {9,10}} by A1;
  then [x,{},<*c,f,b*>] in SCM-Instr \/
   { [K,{},<*c1,f1,b1*>] : K in {9,10}} by XBOOLE_0:def 3;
  hence thesis by XBOOLE_0:def 3;
end;

theorem
  x in {11,12} implies [x,{},<*c,f*>] in SCM+FSA-Instr
proof
  assume
A1: x in {11,12};
  then x = 11 or x = 12 by TARSKI:def 2;
  then reconsider x as Element of Segm 13 by NAT_1:45;
  [x,{},<*c,f*>] in { [K,{},<*c1,f1*>] : K in {11,12}} by A1;
  hence thesis by XBOOLE_0:def 3;
end;

theorem Th8:
  SCM+FSA-Memory = {NAT} \/ SCM+FSA-Data-Loc \/ SCM+FSA-Data*-Loc
  \/ NAT by XBOOLE_1:4;

theorem Th9:
  SCM+FSA-OK.NAT = NAT
proof
A1: NAT in dom SCM-OK by AMI_2:30,FUNCT_2:def 1;
  not NAT in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)) by Lm1;
  hence SCM+FSA-OK.NAT = ((SCM+FSA-Memory --> INT*) +* SCM-OK).NAT by
FUNCT_4:12
    .= SCM-OK.NAT by A1,FUNCT_4:14
    .= NAT by AMI_2:7,30;
end;

theorem Th10:
  SCM+FSA-OK.b = INT
proof
 b in SCM-Data-Loc;
  then b in SCM-Memory;
  then
A2: b in dom SCM-OK by FUNCT_2:def 1;
    ex x,y being set st x in {1} & y in NAT & b = [x,y] by ZFMISC_1:103;
  then b is not Element of NAT;
  then not b in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)) by Lm1;
  hence SCM+FSA-OK.b = ((SCM+FSA-Memory --> INT*) +* SCM-OK).b by FUNCT_4:12
    .= SCM-OK.b by A2,FUNCT_4:14
    .= INT by AMI_2:10;
end;

theorem Th11:
  SCM+FSA-OK.a = SCM+FSA-Instr
proof
A1: dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)) c=dom(SCM-OK|NAT) by
RELAT_1:44;
A2: a in NAT;
  then
A3: a in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)) by Lm3;
  thus SCM+FSA-OK.a = ((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)).a by A2,Lm3,
FUNCT_4:14
    .= (SCM-Instr.-->SCM+FSA-Instr).((SCM-OK|NAT).a) by A2,Lm3,FUNCT_1:22
    .= (SCM-Instr.-->SCM+FSA-Instr).(SCM-OK.a) by A3,A1,FUNCT_1:70
    .= (SCM-Instr.-->SCM+FSA-Instr).SCM-Instr by AMI_2:11
    .= SCM+FSA-Instr by FUNCOP_1:87;
end;

Lm4: SCM+FSA-Data*-Loc misses SCM-Memory
proof
  assume SCM+FSA-Data*-Loc meets SCM-Memory;
  then consider x such that
A1: x in SCM+FSA-Data*-Loc and
A2: x in SCM-Memory by XBOOLE_0:3;
A3: x in {NAT} \/ SCM-Data-Loc or x in NAT by A2,XBOOLE_0:def 3;
  x in NAT \/ [:{0},NAT:] \ {[0,0]} by A1,NUMBERS:def 4;
  then
A4: x in NAT or x in [:{0},NAT:] by XBOOLE_0:def 3;
  per cases by A3,XBOOLE_0:def 3;
  suppose
A5: x in {NAT};
    then ex y,z st x = [y,z] by A4,RELAT_1:def 1,TARSKI:def 1;
    hence contradiction by A5,TARSKI:def 1;
  end;
  suppose
    x in SCM-Data-Loc;
    then
A6: ex k st x = [1,k] by AMI_2:32;
    then consider y,z such that
A7: y in {0} and
    z in NAT and
A8: x= [y,z] by A4,ZFMISC_1:103;
    y = 0 by A7,TARSKI:def 1;
    hence contradiction by A6,A8,ZFMISC_1:33;
  end;
  suppose
    x in NAT;
    hence contradiction by A1,XBOOLE_0:def 5;
  end;
end;

theorem Th12:
  SCM+FSA-OK.f = INT*
proof
A1: not f in SCM-Memory by Lm4,XBOOLE_0:3;
  then
A2: not f in dom SCM-OK by FUNCT_2:def 1;
  now
A3: dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT)) c= dom(SCM-OK|NAT) by
RELAT_1:44;
    assume f in dom((SCM-Instr.-->SCM+FSA-Instr)*(SCM-OK|NAT));
    then f in dom SCM-OK by A3,RELAT_1:86;
    hence contradiction by A1,FUNCT_2:def 1;
  end;
  hence SCM+FSA-OK.f = ((SCM+FSA-Memory --> INT*) +* SCM-OK).f by FUNCT_4:12
    .= (SCM+FSA-Memory --> INT*).f by A2,FUNCT_4:12
    .= INT* by FUNCOP_1:13;
end;

theorem Th13:
  SCM+FSA-Instr <> INT & NAT <> SCM+FSA-Instr & NAT
  <> INT* & SCM+FSA-Instr <> INT*
proof
 2 in NAT;
  then
B0: 2 in INT by NUMBERS:17;
 not ex x,x1,y being set st x in NAT & x1 in NAT* &
        y in proj2 SCM+FSA-Instr & 2 = [x,x1,y];
   then not 2 in [:NAT,NAT*,proj2 SCM+FSA-Instr:] by MCART_1:72;
   then
A2:  not 2 in SCM+FSA-Instr by LmX;
  hence SCM+FSA-Instr <> INT by B0;
  thus NAT <> SCM+FSA-Instr by A2;
  0 qua Integer in INT by INT_1:def 1;
  then <*0*> is FinSequence of INT by FINSEQ_1:95;
  then
A2: <*0*> in INT* by FINSEQ_1:def 11;
  hereby
A3: card <*0*> = 1 by CARD_1:50;
    assume NAT = INT*;
    then <*0*> = { 0 } by A2,A3,CARD_1:87,def 5;
    hence contradiction by ZFMISC_1:6;
  end;
  now
    assume {} in SCM+FSA-Instr;
    then {} in [:NAT,NAT*,proj2 SCM+FSA-Instr:] by LmX;
    then ex x,x1,y being set st x in NAT & x1 in NAT* &
        y in proj2 SCM+FSA-Instr & {} = [x,x1,y] by MCART_1:72;
    hence contradiction;
  end;
  hence thesis by FINSEQ_1:66;
end;

theorem
  for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = NAT holds i = NAT
proof
  let i be Element of SCM+FSA-Memory such that
A1: SCM+FSA-OK.i = NAT;
  not i in NAT by A1,Th11,Th13;
  then
A2: i in {NAT} \/ SCM+FSA-Data-Loc \/ SCM+FSA-Data*-Loc by Th8,XBOOLE_0:def 3;
  not i in SCM+FSA-Data*-Loc by A1,Th12,Th13;
  then
A3: i in {NAT} \/ SCM+FSA-Data-Loc by A2,XBOOLE_0:def 3;
  not i in SCM+FSA-Data-Loc by A1,Th10,NUMBERS:27;
  then i in {NAT} by A3,XBOOLE_0:def 3;
  hence thesis by TARSKI:def 1;
end;

theorem
  for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = INT holds i in
  SCM+FSA-Data-Loc
proof
  let i be Element of SCM+FSA-Memory such that
A1: SCM+FSA-OK.i = INT;
  not i in NAT by A1,Th11,Th13;
  then
A2: i in {NAT} \/ SCM+FSA-Data-Loc \/ SCM+FSA-Data*-Loc by Th8,XBOOLE_0:def 3;
  not i in SCM+FSA-Data*-Loc by A1,Th12,FUNCT_7:18;
  then
A3: i in {NAT} \/ SCM+FSA-Data-Loc by A2,XBOOLE_0:def 3;
  not i in {NAT} by A1,Th9,NUMBERS:27,TARSKI:def 1;
  hence thesis by A3,XBOOLE_0:def 3;
end;

theorem
  for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = SCM+FSA-Instr
  holds i in NAT
proof
  let i be Element of SCM+FSA-Memory such that
A1: SCM+FSA-OK.i = SCM+FSA-Instr;
  now
    assume
A2: i in {NAT} \/ SCM+FSA-Data-Loc \/ SCM+FSA-Data*-Loc;
    not i in SCM+FSA-Data*-Loc by A1,Th12,Th13;
    then
A3: i in {NAT} \/ SCM+FSA-Data-Loc by A2,XBOOLE_0:def 3;
    not i in SCM+FSA-Data-Loc by A1,Th10,Th13;
    then i in{NAT} by A3,XBOOLE_0:def 3;
    hence contradiction by A1,Th9,Th13,TARSKI:def 1;
  end;
  hence thesis by Th8,XBOOLE_0:def 3;
end;

theorem
  for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = INT* holds i
  in SCM+FSA-Data*-Loc
proof
  let i be Element of SCM+FSA-Memory such that
A1: SCM+FSA-OK.i = INT*;
A2: now
    assume
A3: i in {NAT} \/ SCM+FSA-Data-Loc;
    not i in {NAT} by A1,Th9,Th13,TARSKI:def 1;
    then i in SCM+FSA-Data-Loc by A3,XBOOLE_0:def 3;
    hence contradiction by A1,Th10,FUNCT_7:18;
  end;
  not i in NAT by A1,Th11,Th13;
  then i in {NAT} \/ SCM+FSA-Data-Loc \/ SCM+FSA-Data*-Loc by Th8,
XBOOLE_0:def 3;
  hence thesis by A2,XBOOLE_0:def 3;
end;

registration
 cluster SCM-OK -> non-empty;
 coherence
  proof
A:  rng SCM-OK c= {INT} \/ { SCM-Instr, NAT } by RELAT_1:def 19;
   assume {} in rng SCM-OK;
    then {} in {INT} or {} in { SCM-Instr, NAT } by A,XBOOLE_0:def 3;
    then {} = INT or {} = SCM+FSA-Instr or {} = NAT by TARSKI:def 1,def 2;
   hence contradiction;
  end;
 cluster SCM+FSA-OK -> non-empty;
 coherence
  proof
A:  rng SCM+FSA-OK c= {INT,INT*} \/ { SCM+FSA-Instr, NAT } by RELAT_1:def 19;
   assume {} in rng SCM+FSA-OK;
    then {} in {INT,INT*} or {} in { SCM+FSA-Instr, NAT } by A,XBOOLE_0:def 3;
    then {} = INT or {} = INT* or {} = SCM+FSA-Instr or {} = NAT
         by TARSKI:def 2;
   hence contradiction;
  end;
end;

definition
  mode SCM+FSA-State is Element of product SCM+FSA-OK;
end;

theorem Th18:
  for s being SCM+FSA-State, I being Element of SCM-Instr holds s|
  SCM-Memory +* (NAT --> I) is SCM-State
proof
  let s be SCM+FSA-State, I be Element of SCM-Instr;
A1: dom(SCM+FSA-OK) = SCM+FSA-Memory by FUNCT_2:def 1;
A2: dom(s|SCM-Memory) = dom s /\ SCM-Memory by RELAT_1:90
    .= SCM+FSA-Memory /\ SCM-Memory by A1,CARD_3:18
    .= SCM-Memory by XBOOLE_1:21;
A3: now
    let x;
A4: NAT = dom(NAT --> I) by FUNCOP_1:19;
    assume x in dom SCM-OK;
    then
A5: x in SCM-Memory by FUNCT_2:def 1;
    then
A6: x in {NAT} \/ SCM-Data-Loc or x in NAT by XBOOLE_0:def 3;
    per cases by A6,XBOOLE_0:def 3;
    suppose
A7:   x in {NAT};
      then not x in NAT by TARSKI:def 1;
      then
A8:   (s|SCM-Memory +* (NAT --> I)).x = (s|SCM-Memory).x by A4,FUNCT_4:12
        .= s.x by A2,A5,FUNCT_1:70;
      reconsider a = x as Element of SCM+FSA-Memory by A5,Th1;
A9:   s.a in pi(product SCM+FSA-OK,a) by CARD_3:def 6;
A10:  x = NAT by A7,TARSKI:def 1;
      dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
      then pi(product SCM+FSA-OK,a) = NAT by A10,Th9,CARD_3:22;
      hence (s|SCM-Memory +* (NAT --> I)).x in SCM-OK.x
       by A10,A8,A9,AMI_2:7,30;
    end;
    suppose
A11:  x in SCM-Data-Loc;
      then SCM-OK.x = INT by AMI_2:10;
      then not x in NAT by AMI_2:6,11;
      then
A12:  (s|SCM-Memory +* (NAT --> I)).x = (s|SCM-Memory).x by A4,FUNCT_4:12
        .= s.x by A2,A5,FUNCT_1:70;
      reconsider a = x as Element of SCM+FSA-Memory by A5,Th1;
      dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
      then
A13:  pi(product SCM+FSA-OK,a) = SCM+FSA-OK.a by CARD_3:22
        .= INT by A11,Th10;
      s.a in pi(product SCM+FSA-OK,a) by CARD_3:def 6;
      hence (s|SCM-Memory +* (NAT --> I)).x in SCM-OK.x by A11,A12,A13,AMI_2:10
;
    end;
    suppose
A14:  x in NAT;
      then
A15:  SCM-OK.x = SCM-Instr by AMI_2:11;
      (s|SCM-Memory +* (NAT --> I)).x = (NAT --> I).x by A4,A14,FUNCT_4:14
        .= I by A14,FUNCOP_1:13;
      hence (s|SCM-Memory +* (NAT --> I)).x in SCM-OK.x by A15;
    end;
  end;
  dom(s|SCM-Memory +* (NAT --> I)) = dom(s|SCM-Memory) \/ dom(NAT --> I)
  by FUNCT_4:def 1
    .= SCM-Memory \/ NAT by A2,FUNCOP_1:19
    .= SCM-Memory by XBOOLE_1:12
    .= dom SCM-OK by FUNCT_2:def 1;
  hence thesis by A3,CARD_3:18;
end;

theorem Th19:
  for s being SCM+FSA-State, s9 being SCM-State holds s +* s9 +* s
  |NAT is SCM+FSA-State
proof
  let s be SCM+FSA-State, s9 be SCM-State;
A1: dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
  then reconsider
  f = SCM+FSA-OK as non-empty ManySortedSet of SCM+FSA-Memory by PARTFUN1:def 4
;
A2: dom s9 = dom SCM-OK by CARD_3:18
    .= SCM-Memory by FUNCT_2:def 1;
  now
    let x be set;
    assume
A3: x in dom s9;
    then
A4: x in {NAT} \/ SCM-Data-Loc or x in NAT by A2,XBOOLE_0:def 3;
    per cases by A4,XBOOLE_0:def 3;
    suppose
A5:   x in {NAT};
      reconsider a = x as Element of SCM-Memory by A2,A3;
A6:   s9.a in pi(product SCM-OK,a) by CARD_3:def 6;
A7:   x = NAT by A5,TARSKI:def 1;
      dom SCM-OK = SCM-Memory by FUNCT_2:def 1;
      then pi(product SCM-OK,a) = SCM-OK.a by CARD_3:22
        .= NAT by A7,AMI_2:7;
      hence s9.x in f.x by A5,A6,Th9,TARSKI:def 1;
    end;
    suppose
A8:   x in SCM-Data-Loc;
      reconsider a = x as Element of SCM-Memory by A2,A3;
A9:   s9.a in pi(product SCM-OK,a) by CARD_3:def 6;
      dom SCM-OK = SCM-Memory by FUNCT_2:def 1;
      then
A10:  pi(product SCM-OK,a) = SCM-OK.a by CARD_3:22;
      SCM+FSA-OK.x = INT by A8,Th10;
      hence s9.x in f.x by A8,A10,A9,AMI_2:10;
    end;
    suppose
A11:  x in NAT;
      SCM+FSA-Instr = SCM-Instr \/ ({ [J,{},<*c,f2,b*>] : J in {9,10} } \/ {
      [K,{},<*c1,f1*>] : K in {11,12} }) by XBOOLE_1:4;
      then
A12:  SCM-Instr c= SCM+FSA-Instr by XBOOLE_1:7;
      reconsider a = x as Element of SCM-Memory by A2,A3;
A13:  s9.a in pi(product SCM-OK,a) by CARD_3:def 6;
      dom SCM-OK = SCM-Memory by FUNCT_2:def 1;
      then
A14:  pi(product SCM-OK,a) = SCM-OK.a by CARD_3:22;
      SCM-OK.x = SCM-Instr & SCM+FSA-OK.x = SCM+FSA-Instr by A11,Th11,AMI_2:11;
      hence s9.x in f.x by A12,A14,A13;
    end;
  end;
  then s +* s9 is SCM+FSA-State by A1,A2,PRE_CIRC:9,XBOOLE_1:7;
  hence thesis by CARD_3:69;
end;

definition
  let s be SCM+FSA-State, u be Nat;
  func SCM+FSA-Chg(s,u) -> SCM+FSA-State equals
  s +* (NAT .--> u);
  coherence
  proof
A1: now
      let x be set;
      assume
A2:   x in dom(SCM+FSA-OK);
      now
        per cases;
        suppose
A3:       x = NAT;
          {NAT} = dom(NAT .--> u) by FUNCOP_1:19;
          then NAT in dom(NAT .--> u) by TARSKI:def 1;
          then (s +* (NAT .--> u)).NAT = (NAT .--> u).NAT by FUNCT_4:14
            .= u by FUNCOP_1:87;
          hence (s +* (NAT .--> u)).x in SCM+FSA-OK.x by A3,Th9,ORDINAL1:def 13
;
        end;
        suppose
A4:       x <> NAT;
          {NAT} = dom(NAT .--> u) by FUNCOP_1:19;
          then not x in dom(NAT .--> u) by A4,TARSKI:def 1;
          then (s +* (NAT .--> u)).x = s.x by FUNCT_4:12;
          hence (s +* (NAT .--> u)).x in SCM+FSA-OK.x by A2,CARD_3:18;
        end;
      end;
      hence (s +* (NAT .--> u)).x in SCM+FSA-OK.x;
    end;
A5: dom(SCM+FSA-OK) = SCM+FSA-Memory by FUNCT_2:def 1;
    then dom s = SCM+FSA-Memory by CARD_3:18;
    then dom(s +* (NAT .--> u)) = SCM+FSA-Memory \/ dom(NAT .--> u) by
FUNCT_4:def 1
      .= SCM+FSA-Memory \/ {NAT} by FUNCOP_1:19
      .= dom(SCM+FSA-OK) by A5,Th5,ZFMISC_1:46;
    hence thesis by A1,CARD_3:18;
  end;
end;

definition
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer;
  func SCM+FSA-Chg(s,t,u) -> SCM+FSA-State equals
  s +* (t .--> u);
  coherence
  proof
A1: now
      let x be set;
      assume
A2:   x in dom(SCM+FSA-OK);
      now
        per cases;
        suppose
A3:       x = t;
          {t} = dom(t .--> u) by FUNCOP_1:19;
          then t in dom(t .--> u) by TARSKI:def 1;
          then (s +* (t .--> u)).t = (t .--> u).t by FUNCT_4:14
            .= u by FUNCOP_1:87;
          then (s +* (t .--> u)).t in INT by INT_1:def 2;
          hence (s +* (t .--> u)).x in SCM+FSA-OK.x by A3,Th10;
        end;
        suppose
A4:       x <> t;
          {t} = dom(t .--> u) by FUNCOP_1:19;
          then not x in dom(t .--> u) by A4,TARSKI:def 1;
          then (s +* (t .--> u)).x = s.x by FUNCT_4:12;
          hence (s +* (t .--> u)).x in SCM+FSA-OK.x by A2,CARD_3:18;
        end;
      end;
      hence (s +* (t .--> u)).x in SCM+FSA-OK.x;
    end;
A5: dom(SCM+FSA-OK) = SCM+FSA-Memory by FUNCT_2:def 1;
    then dom s = SCM+FSA-Memory by CARD_3:18;
    then dom(s +* (t .--> u)) = SCM+FSA-Memory \/ dom(t .--> u) by
FUNCT_4:def 1
      .= SCM+FSA-Memory \/ {t} by FUNCOP_1:19
      .= dom(SCM+FSA-OK) by A5,ZFMISC_1:46;
    hence thesis by A1,CARD_3:18;
  end;
end;

definition
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc, u be FinSequence
  of INT;
  func SCM+FSA-Chg(s,t,u) -> SCM+FSA-State equals
  s +* (t .--> u);
  coherence
  proof
A1: now
      let x be set;
      assume
A2:   x in dom(SCM+FSA-OK);
      now
        per cases;
        suppose
A3:       x = t;
          {t} = dom(t .--> u) by FUNCOP_1:19;
          then t in dom(t .--> u) by TARSKI:def 1;
          then (s +* (t .--> u)).t = (t .--> u).t by FUNCT_4:14
            .= u by FUNCOP_1:87;
          then (s +* (t .--> u)).t in INT* by FINSEQ_1:def 11;
          hence (s +* (t .--> u)).x in SCM+FSA-OK.x by A3,Th12;
        end;
        suppose
A4:       x <> t;
          {t} = dom(t .--> u) by FUNCOP_1:19;
          then not x in dom(t .--> u) by A4,TARSKI:def 1;
          then (s +* (t .--> u)).x = s.x by FUNCT_4:12;
          hence (s +* (t .--> u)).x in SCM+FSA-OK.x by A2,CARD_3:18;
        end;
      end;
      hence (s +* (t .--> u)).x in SCM+FSA-OK.x;
    end;
A5: dom(SCM+FSA-OK) = SCM+FSA-Memory by FUNCT_2:def 1;
    then dom s = SCM+FSA-Memory by CARD_3:18;
    then dom(s +* (t .--> u)) = SCM+FSA-Memory \/ dom(t .--> u) by
FUNCT_4:def 1
      .= SCM+FSA-Memory \/ {t} by FUNCOP_1:19
      .= dom(SCM+FSA-OK) by A5,ZFMISC_1:46;
    hence thesis by A1,CARD_3:18;
  end;
end;

definition
  let s be SCM+FSA-State, a be Element of SCM+FSA-Data-Loc;
  redefine func s.a -> Integer;
  coherence
  proof
    dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
    then
A1: pi(product SCM+FSA-OK,a) = SCM+FSA-OK.a by CARD_3:22
      .= INT by Th10;
    s.a in pi(product SCM+FSA-OK,a) by CARD_3:def 6;
    hence thesis by A1;
  end;
end;

definition
  let s be SCM+FSA-State, a be Element of SCM+FSA-Data*-Loc;
  redefine func s.a -> FinSequence of INT;
  coherence
  proof
    dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
    then
A1: pi(product SCM+FSA-OK,a) = SCM+FSA-OK.a by CARD_3:22
      .= INT* by Th12;
    s.a in pi(product SCM+FSA-OK,a) by CARD_3:def 6;
    hence thesis by A1,FINSEQ_1:def 11;
  end;
end;

definition
  let x be Element of SCM+FSA-Instr;
  given c,f,b,J such that
A1: x = [J,{},<*c,f,b*>];
  func x int_addr1 -> Element of SCM+FSA-Data-Loc means
  ex c,f,b st <*c,f,b*> = x`3_3 & it = c;
  existence
  proof
    take c,c,f,b;
    thus thesis by A1,RECDEF_2:def 3;
  end;
  uniqueness
  proof
    let a1,a2 be Element of SCM+FSA-Data-Loc;
    given c1,f1,b1 such that
A2: <*c1,f1,b1*> = x`3_3 and
A3: a1 = c1;
    given c2,f2,b2 such that
A4: <*c2,f2,b2*> = x`3_3 & a2 = c2;
    thus a1 = <*c1,f1,b1*>/.1 by A3,FINSEQ_4:27
      .= a2 by A2,A4,FINSEQ_4:27;
  end;
  func x int_addr2 -> Element of SCM+FSA-Data-Loc means
  ex c,f,b st <*c,f,b*> = x`3_3 & it = b;
  existence
  proof
    take b,c,f,b;
    thus thesis by A1,RECDEF_2:def 3;
  end;
  correctness
  proof
    let a1,a2 be Element of SCM+FSA-Data-Loc;
    given c1,f1,b1 such that
A5: <*c1,f1,b1*> = x`3_3 and
A6: a1 = b1;
    given c2,f2,b2 such that
A7: <*c2,f2,b2*> = x`3_3 & a2 = b2;
    thus a1 = <*c1,f1,b1*>/.3 by A6,FINSEQ_4:27
      .= a2 by A5,A7,FINSEQ_4:27;
  end;
  func x coll_addr1 -> Element of SCM+FSA-Data*-Loc means
  ex c,f,b st <*c,f,b*> = x`3_3 & it = f;
  existence
  proof
    take f,c,f,b;
    thus thesis by A1,RECDEF_2:def 3;
  end;
  correctness
  proof
    let a1,a2 be Element of SCM+FSA-Data*-Loc;
    given c1,f1,b1 such that
A8: <*c1,f1,b1*> = x`3_3 and
A9: a1 = f1;
    given c2,f2,b2 such that
A10: <*c2,f2,b2*> = x`3_3 & a2 = f2;
    thus a1 = <*c1,f1,b1*>/.2 by A9,FINSEQ_4:27
      .= a2 by A8,A10,FINSEQ_4:27;
  end;
end;

definition
  let x be Element of SCM+FSA-Instr;
  given c,f,J such that
A1: x = [ J,{}, <*c,f*>];
  func x int_addr3 -> Element of SCM+FSA-Data-Loc means
  ex c,f st <*c,f*> = x`3_3 & it = c;
  existence
  proof
    take c,c,f;
    thus thesis by A1,RECDEF_2:def 3;
  end;
  uniqueness
  proof
    let a1,a2 be Element of SCM+FSA-Data-Loc;
    given c1,f1 such that
A2: <*c1,f1*> = x`3_3 and
A3: a1 = c1;
    given c2,f2 such that
A4: <*c2,f2*> = x`3_3 & a2 = c2;
    thus a1 = <*c1,f1*>/.1 by A3,FINSEQ_4:26
      .= a2 by A2,A4,FINSEQ_4:26;
  end;
  func x coll_addr2 -> Element of SCM+FSA-Data*-Loc means
  ex c,f st <*c,f*> = x`3_3 & it = f;
  existence
  proof
    take f,c,f;
    thus thesis by A1,RECDEF_2:def 3;
  end;
  correctness
  proof
    let a1,a2 be Element of SCM+FSA-Data*-Loc;
    given c1,f1 such that
A5: <*c1,f1*> = x`3_3 and
A6: a1 = f1;
    given c2,f2 such that
A7: <*c2,f2*> = x`3_3 & a2 = f2;
    thus a1 = <*c1,f1*>/.2 by A6,FINSEQ_4:26
      .= a2 by A5,A7,FINSEQ_4:26;
  end;
  canceled;
end;

definition
  let s be SCM+FSA-State;
  func IC(s) -> Element of NAT equals
  s.NAT;
  coherence
  proof
    reconsider z = NAT as Element of SCM+FSA-Memory by Th5;
    dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
    then pi(product SCM+FSA-OK,NAT) = SCM+FSA-OK.z by CARD_3:22
      .= NAT by Th9;
    hence thesis by CARD_3:def 6;
  end;
end;

definition
  let x be Element of SCM+FSA-Instr, s be SCM+FSA-State;
  func SCM+FSA-Exec-Res(x,s) -> SCM+FSA-State means
  ex x9 being Element of
  SCM-Instr, s9 being SCM-State st x = x9 & s9 = s|SCM-Memory +* (NAT --> x9) &
it = s +* SCM-Exec-Res(x9,s9) +* s|NAT if x`1_3 <= 8, ex i being Integer, k
  st k = abs(s.(x int_addr2)) & i = (s.(x coll_addr1))/.k & it = SCM+FSA-Chg(
  SCM+FSA-Chg(s,x int_addr1,i),succ IC s) if x`1_3 = 9, ex f being
FinSequence of INT,k st k = abs(s.(x int_addr2)) & f = s.(x coll_addr1)+*(k,s.(
  x int_addr1)) & it = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),succ IC s) if
x`1_3 = 10, it = SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr3,len(s.(x coll_addr2)
)),succ IC s) if x`1_3 = 11, ex f being FinSequence of INT,k st k = abs(s.(
  x int_addr3)) & f = k |-> 0 & it = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr2,f),
  succ IC s) if x`1_3 = 12 otherwise it = s;
  existence
  proof
    hereby
      assume x`1_3 <= 8;
      then reconsider x9 = x as Element of SCM-Instr by Th3;
      reconsider s9 = s|SCM-Memory +* (NAT --> x9) as SCM-State by Th18;
      reconsider s1 = s +* SCM-Exec-Res(x9,s9) +* s|NAT as SCM+FSA-State by
Th19;
      take s1,x9,s9;
      thus x = x9;
      thus s9 = s|SCM-Memory +* (NAT --> x9);
      thus s1 = s +* SCM-Exec-Res(x9,s9) +* s|NAT;
    end;
    hereby
      reconsider k = abs(s.(x int_addr2)) as Element of NAT;
      assume x`1_3 = 9;
      reconsider i = (s.(x coll_addr1))/.k as Integer;
      take s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr1,i),succ IC s);
      take i,k;
      thus k = abs(s.(x int_addr2)) & i = (s.(x coll_addr1))/.k & s1 =
      SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr1,i),succ IC s);
    end;
    hereby
      reconsider k = abs(s.(x int_addr2)) as Element of NAT;
      assume x`1_3 = 10;
      per cases;
      suppose
A1:     k in dom( s.(x coll_addr1));
        set f = s.(x coll_addr1) +* (k.-->s.(x int_addr1));
A2:     {k} c= dom( s.(x coll_addr1)) by A1,ZFMISC_1:37;
        dom f = dom(s.(x coll_addr1)) \/ dom((k.-->s.(x int_addr1))) by
FUNCT_4:def 1
          .= dom(s.(x coll_addr1)) \/ {k} by FUNCOP_1:19
          .= dom(s.(x coll_addr1)) by A2,XBOOLE_1:12
          .= Seg len(s.(x coll_addr1)) by FINSEQ_1:def 3;
        then reconsider f as FinSequence by FINSEQ_1:def 2;
        s.(x int_addr1) in INT & rng((k.-->s.(x int_addr1))) = {s.(x
        int_addr1)} by FUNCOP_1:14,INT_1:def 2;
        then
        rng(s.(x coll_addr1)) c= INT & rng((k.-->s.(x int_addr1))) c= INT
        by FINSEQ_1:def 4,ZFMISC_1:37;
        then rng f c= rng(s.(x coll_addr1)) \/ rng((k.-->s.(x int_addr1))) &
rng(s.(x coll_addr1)) \/ rng((k.-->s.(x int_addr1))) c= INT by FUNCT_4:18
,XBOOLE_1:8;
        then rng f c= INT by XBOOLE_1:1;
        then reconsider f as FinSequence of INT by FINSEQ_1:def 4;
        take s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),succ IC s);
        take f,k;
        thus k = abs(s.(x int_addr2));
        thus f = s.(x coll_addr1) +* (k,s.(x int_addr1)) by A1,FUNCT_7:def 3;
        thus s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),succ IC s);
      end;
      suppose
A3:     not k in dom( s.(x coll_addr1));
        reconsider f = s.(x coll_addr1) as FinSequence of INT;
        take s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),succ IC s);
        take f,k;
        thus k = abs(s.(x int_addr2));
        thus f = s.(x coll_addr1) +* (k,s.(x int_addr1)) by A3,FUNCT_7:def 3;
        thus s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),succ IC s);
      end;
    end;
    thus x`1_3 = 11 implies ex s1 being SCM+FSA-State st s1 = SCM+FSA-Chg(
    SCM+FSA-Chg(s,x int_addr3,len(s.(x coll_addr2))),succ IC s);
    hereby
      reconsider k = abs(s.(x int_addr3)) as Element of NAT;
      assume x`1_3 = 12;
      0 in INT by INT_1:def 2;
      then
A4:   {0} c= INT by ZFMISC_1:37;
      k |-> 0 = Seg k --> 0 by FINSEQ_2:def 2;
      then rng(k |-> 0) c= {0} by FUNCOP_1:19;
      then rng(k |-> 0) c= INT by A4,XBOOLE_1:1;
      then reconsider f = k |-> 0 as FinSequence of INT by FINSEQ_1:def 4;
      take s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr2,f),succ IC s);
      take f,k;
      thus k = abs(s.(x int_addr3)) & f = k |-> 0 & s1 = SCM+FSA-Chg(
      SCM+FSA-Chg(s,x coll_addr2,f),succ IC s);
    end;
    thus thesis;
  end;
  uniqueness;
  consistency;
end;

definition
  let A be set, B be non empty set;
  mode Action of A,B is Function of A, Funcs(B,B);
end;

definition
  func SCM+FSA-Exec -> Action of SCM+FSA-Instr, product SCM+FSA-OK means
  for x being Element of SCM+FSA-Instr, y being
  SCM+FSA-State holds (it.x).y = SCM+FSA-Exec-Res(x,y);
  existence
  proof
    deffunc U(Element of SCM+FSA-Instr, SCM+FSA-State) = SCM+FSA-Exec-Res($1,
    $2);
    consider f being Function of [:SCM+FSA-Instr,product SCM+FSA-OK:], product
    SCM+FSA-OK such that
A1: for x being Element of SCM+FSA-Instr, y being SCM+FSA-State holds
    f.(x,y) = U(x,y) from BINOP_1:sch 4;
    take curry f;
    let x be Element of SCM+FSA-Instr, y be SCM+FSA-State;
    thus (curry f).x.y = f.(x,y) by CAT_2:3
      .= SCM+FSA-Exec-Res(x,y) by A1;
  end;
  uniqueness
  proof
    let f,g be Function of SCM+FSA-Instr, Funcs(product SCM+FSA-OK, product
    SCM+FSA-OK) such that
A2: for x being Element of SCM+FSA-Instr, y being SCM+FSA-State holds
    (f.x qua Element of Funcs(product SCM+FSA-OK, product SCM+FSA-OK)).y =
    SCM+FSA-Exec-Res(x,y) and
A3: for x being Element of SCM+FSA-Instr, y being SCM+FSA-State holds
    (g.x qua Element of Funcs(product SCM+FSA-OK, product SCM+FSA-OK)).y =
    SCM+FSA-Exec-Res(x,y);
    now
      let x be Element of SCM+FSA-Instr;
      reconsider gx=g.x, fx=f.x as Function of product SCM+FSA-OK, product
      SCM+FSA-OK;
      now
        let y be SCM+FSA-State;
        thus fx.y = SCM+FSA-Exec-Res(x,y) by A2
          .= gx.y by A3;
      end;
      hence f.x = g.x by FUNCT_2:113;
    end;
    hence f = g by FUNCT_2:113;
  end;
end;

theorem
  for s being SCM+FSA-State, u being Element of NAT holds SCM+FSA-Chg(s,
  u).NAT = u
proof
  let s be SCM+FSA-State, u be Element of NAT;
  {NAT} = dom(NAT .--> u) by FUNCOP_1:19;
  then NAT in dom(NAT .--> u) by TARSKI:def 1;
  hence SCM+FSA-Chg(s,u).NAT = (NAT .--> u).NAT by FUNCT_4:14
    .= u by FUNCOP_1:87;
end;

theorem
  for s being SCM+FSA-State, u being Element of NAT, mk being Element of
  SCM+FSA-Data-Loc holds SCM+FSA-Chg(s,u).mk = s.mk
proof
  let s be SCM+FSA-State, u be Element of NAT, mk be Element of
  SCM+FSA-Data-Loc;
  SCM+FSA-OK.mk = INT & {NAT} = dom(NAT .--> u) by Th10,FUNCOP_1:19;
  then not mk in dom(NAT .--> u) by Th9,NUMBERS:27,TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem
  for s being SCM+FSA-State, u being Element of NAT, p being Element of
  SCM+FSA-Data*-Loc holds SCM+FSA-Chg(s,u).p = s.p
proof
  let s be SCM+FSA-State, u be Element of NAT, mk be Element of
  SCM+FSA-Data*-Loc;
  SCM+FSA-OK.mk = INT* & {NAT} = dom(NAT .--> u) by Th12,FUNCOP_1:19;
  then not mk in dom(NAT .--> u) by Th9,Th13,TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem
  for s being SCM+FSA-State, u,v being Element of NAT holds SCM+FSA-Chg(
  s,u).v = s.v
proof
  let s be SCM+FSA-State, u,v be Element of NAT;
  {NAT} = dom(NAT .--> u) by FUNCOP_1:19;
  then not v in dom(NAT .--> u) by TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data-Loc, u
  being Integer holds SCM+FSA-Chg(s,t,u).NAT = s.NAT
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer;
  SCM+FSA-OK.t = INT & {t} = dom(t .--> u) by Th10,FUNCOP_1:19;
  then not NAT in dom(t .--> u) by Th9,NUMBERS:27,TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data-Loc, u
  being Integer holds SCM+FSA-Chg(s,t,u).t = u
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer;
  {t} = dom(t .--> u) by FUNCOP_1:19;
  then t in dom(t .--> u) by TARSKI:def 1;
  hence SCM+FSA-Chg(s,t,u).t = (t .--> u).t by FUNCT_4:14
    .= u by FUNCOP_1:87;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data-Loc, u
  being Integer, mk being Element of SCM+FSA-Data-Loc st mk <> t holds
  SCM+FSA-Chg(s,t,u).mk = s.mk
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer, mk
  be Element of SCM+FSA-Data-Loc such that
A1: mk <> t;
  {t} = dom(t .--> u) by FUNCOP_1:19;
  then not mk in dom(t .--> u) by A1,TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data-Loc, u
being Integer, f being Element of SCM+FSA-Data*-Loc holds SCM+FSA-Chg(s,t,u).f
  = s.f
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer, mk
  be Element of SCM+FSA-Data*-Loc;
A1: {t} = dom(t .--> u) by FUNCOP_1:19;
  SCM+FSA-OK.t = INT & SCM+FSA-OK.mk = INT* by Th10,Th12;
  then not mk in dom(t .--> u) by A1,FUNCT_7:18,TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data-Loc, u
  being Integer, v being Element of NAT holds SCM+FSA-Chg(s,t,u).v = s.v
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer, v be
  Element of NAT;
A1: {t} = dom(t .--> u) by FUNCOP_1:19;
  SCM+FSA-OK.v = SCM+FSA-Instr & SCM+FSA-OK.t = INT by Th10,Th11;
  then not v in dom(t .--> u) by A1,Th13,TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data*-Loc, u
  being FinSequence of INT holds SCM+FSA-Chg(s,t,u).t = u
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc, u be FinSequence
  of INT;
  {t} = dom(t .--> u) by FUNCOP_1:19;
  then t in dom(t .--> u) by TARSKI:def 1;
  hence SCM+FSA-Chg(s,t,u).t = (t .--> u).t by FUNCT_4:14
    .= u by FUNCOP_1:87;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data*-Loc, u
  being FinSequence of INT, mk being Element of SCM+FSA-Data*-Loc st mk <> t
  holds SCM+FSA-Chg(s,t,u).mk = s.mk
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc, u be FinSequence
  of INT, mk be Element of SCM+FSA-Data*-Loc such that
A1: mk <> t;
  {t} = dom(t .--> u) by FUNCOP_1:19;
  then not mk in dom(t .--> u) by A1,TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data*-Loc, u
being FinSequence of INT, a being Element of SCM+FSA-Data-Loc holds SCM+FSA-Chg
  (s,t,u).a = s.a
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc, u be FinSequence
  of INT, mk be Element of SCM+FSA-Data-Loc;
A1: {t} = dom(t .--> u) by FUNCOP_1:19;
  SCM+FSA-OK.t = INT* & SCM+FSA-OK.mk = INT by Th10,Th12;
  then not mk in dom(t .--> u) by A1,FUNCT_7:18,TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data*-Loc, u
being FinSequence of INT, v being Element of NAT holds SCM+FSA-Chg(s,t,u).v = s
  .v
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc, u be FinSequence
  of INT, v be Element of NAT;
A1: {t} = dom(t .--> u) by FUNCOP_1:19;
  SCM+FSA-OK.v = SCM+FSA-Instr & SCM+FSA-OK.t = INT* by Th11,Th12;
  then not v in dom(t .--> u) by A1,Th13,TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem
  SCM+FSA-Data*-Loc misses SCM-Memory by Lm4;

theorem
 SCM+FSA-Instr c= [:NAT,NAT*,proj2 SCM+FSA-Instr:] by LmX;

registration
 cluster proj2 SCM+FSA-Instr -> FinSequence-membered;
 coherence
  proof let f be set;
   assume f in proj2 SCM+FSA-Instr;
    then consider y being set such that
Z:   [y,f] in SCM+FSA-Instr by RELAT_1:def 5;
    set x = [y,f];
  per cases by Z,XBOOLE_0:def 3;
  suppose
S: x in SCM-Instr \/ { [J,{},<*c,f1,b*>] : J in {9,10} };
  per cases by S,XBOOLE_0:def 3;
  suppose x in SCM-Instr;
   then f in proj2 SCM-Instr by RELAT_1:def 5;
  hence f is FinSequence;
  end;
  suppose x in { [J,{},<*c,f1,b*>] : J in {9,10}};
   then consider J,c,b,f1 such that
W:  x = [J,{},<*c,f1,b*>] & J in {9,10};
  f = <*c,f1,b*> by W,ZFMISC_1:33;
  hence f is FinSequence;
  end;
  end;
  suppose x in { [K,{},<*c1,f1*>] : K in {11,12} };
   then consider K,c1,f1 such that
W: x = [K,{},<*c1,f1*>] & K in {11,12};
  f = <*c1,f1*> by W,ZFMISC_1:33;
  hence f is FinSequence;
  end;
  end;
end;
