:: An Extension of { \bf SCM }
::  by Andrzej Trybulec , Yatsuka Nakamura and Piotr Rudnicki
::
:: Received February 3, 1996
:: Copyright (c) 1996-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_2, XBOOLE_0, TARSKI, CARD_1, FINSEQ_1,
      ZFMISC_1, RELAT_1, AMI_1, ORDINAL1, MCART_1, XXREAL_0, FUNCT_1, FUNCOP_1,
      FUNCT_4, INT_1, CARD_3, PBOOLE, NAT_1, PARTFUN1, COMPLEX1, FINSEQ_2,
      FUNCT_2, FUNCT_5, SCMFSA_1, GROUP_9, RECDEF_2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, CARD_1, NUMBERS,
      NAT_1, MCART_1, INT_2, PBOOLE, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2,
      BINOP_1, INT_1, FINSEQ_1, FUNCT_4, CAT_2, FINSEQ_2, CARD_3, FUNCOP_1,
      FINSEQ_4, AMI_2, FUNCT_7, XXREAL_0, RECDEF_2;
 constructors DOMAIN_1, XXREAL_0, INT_2, FINSEQ_4, PBOOLE, CAT_2, REAL_1,
      WELLORD2, RELSET_1, AMI_2, FUNCT_7, RECDEF_2, FINSEQ_2;
 registrations XBOOLE_0, FUNCT_1, ORDINAL1, FUNCOP_1, NUMBERS, XREAL_0, INT_1,
      FINSEQ_1, CARD_3, GR_CY_1, AMI_2, RELAT_1, FINSET_1, CARD_1, CARD_2,
      RELSET_1, FUNCT_2;
 requirements NUMERALS, REAL, BOOLE, SUBSET;
 definitions TARSKI, FUNCOP_1, CARD_1, AMI_2, FINSEQ_1, RELAT_1, MCART_1;
 theorems ZFMISC_1, FUNCT_2, TARSKI, CAT_2, FUNCOP_1, INT_1, CARD_3, FINSEQ_1,
      FINSEQ_4, MCART_1, FUNCT_4, RELAT_1, FUNCT_1, FINSEQ_2, PRE_CIRC, AMI_2,
      FUNCT_7, RELSET_1, ORDINAL1, XBOOLE_0, XBOOLE_1, NUMBERS, CARD_1,
      PARTFUN1, NAT_1, FUNCT_5, RECDEF_2;
 schemes BINOP_1;

begin

reserve x,y,z for set,
  k for Element of NAT;

notation
  synonym SCM+FSA-Data-Loc for SCM-Data-Loc;
end;

definition
  func SCM+FSA-Data*-Loc equals
  INT \ NAT;
  coherence;
end;

definition
  func SCM+FSA-Memory equals
  SCM-Memory \/ SCM+FSA-Data*-Loc;
  coherence;
end;

registration
  cluster SCM+FSA-Memory -> non empty;
  coherence;
end;

theorem Th1:
  SCM-Memory c= SCM+FSA-Memory by XBOOLE_1:7;

definition
  redefine func SCM+FSA-Data-Loc -> Subset of SCM+FSA-Memory;
  coherence
  proof
    SCM-Data-Loc c= SCM-Memory;
    hence thesis by Th1,XBOOLE_1:1;
  end;
end;

definition
  redefine func SCM+FSA-Data*-Loc -> Subset of SCM+FSA-Memory;
  coherence by XBOOLE_1:7;

end;

registration
  cluster SCM+FSA-Data*-Loc -> non empty;
  coherence
  proof
    not INT c= NAT by NUMBERS:17,27,XBOOLE_0:def 10;
    hence thesis by XBOOLE_1:37;
  end;
end;

reserve J,J1,K for Element of Segm 13,
  a for Element of NAT,
  b,b1,b2,c,c1,c2 for Element of SCM+FSA-Data-Loc,
  f,f1,f2 for Element of SCM+FSA-Data*-Loc;

definition
  func SCM+FSA-Instr -> non empty set equals
  SCM-Instr \/ { [J,{},<*c,f,b*>] : J in {9,10} }
   \/ { [K,{},<*c1,f1*>] : K in {11,12} };
  coherence;
end;

theorem Th2:
  SCM-Instr c= SCM+FSA-Instr
proof
A2: SCM-Instr c= SCM-Instr \/ { [J,{},<*c,f,b*>] : J in {9,10} }
      by XBOOLE_1:7;
   SCM-Instr \/ { [J,{},<*c,f,b*>] : J in {9,10} }
     c= SCM-Instr \/ { [J1,{},<*c2,f2,b2*>] : J1 in {9,10} }
   \/ { [K,{},<*c1,f1*>] : K in {11,12} } by XBOOLE_1:7;
   then
A1: SCM-Instr
     c= SCM-Instr \/ { [J,{},<*c,f,b*>] : J in {9,10} }
   \/ { [K,{},<*c1,f1*>] : K in {11,12} } by A2,XBOOLE_1:1;
  thus thesis by A1;
end;

registration
  cluster SCM+FSA-Instr -> non empty;
  coherence;
end;

Lm1:
 SCM+FSA-Instr c= [:NAT,NAT*,proj2 SCM+FSA-Instr:]
proof let x;
  assume
A1:  x in SCM+FSA-Instr;
  per cases by A1;
  suppose
A2: x in SCM-Instr \/ { [J,{},<*c,f,b*>] : J in {9,10} }
        \/ { [K,{},<*c1,f1*>] : K in {11,12} };
  per cases by A2,XBOOLE_0:def 3;
  suppose
B2:  x in SCM-Instr \/ { [J,{},<*c,f,b*>] : J in {9,10} };
  per cases by B2,XBOOLE_0:def 3;
  suppose x in SCM-Instr;
   then
A3:  x in [:NAT,NAT*,proj2 SCM-Instr:] by AMI_2:25;
   proj2 SCM-Instr c= proj2 SCM+FSA-Instr by Th2,FUNCT_5:3;
   then [:NAT,NAT*,proj2 SCM-Instr:] c= [:NAT,NAT*,proj2 SCM+FSA-Instr:]
    by MCART_1:73;
  hence x in [:NAT,NAT*,proj2 SCM+FSA-Instr:] by A3;
  end;
  suppose x in { [J,{},<*c,f,b*>] : J in {9,10}};
   then consider J,c,b,f such that
A4:  x = [J,{},<*c,f,b*>] & J in {9,10};
A5: {} in NAT* by FINSEQ_1:49;
   J in NAT & <*c,f,b*> in proj2 SCM+FSA-Instr by A1,A4,RELAT_1:def 5;
  hence x in [:NAT,NAT*,proj2 SCM+FSA-Instr:] by A4,A5,MCART_1:69;
  end;
  end;
  suppose x in { [K,{},<*c1,f1*>] : K in {11,12} };
   then consider K,c1,f1 such that
A6: x = [K,{},<*c1,f1*>] & K in {11,12};
A7: {} in NAT* by FINSEQ_1:49;
   K in NAT & <*c1,f1*> in proj2 SCM+FSA-Instr by A1,A6,RELAT_1:def 5;
  hence x in [:NAT,NAT*,proj2 SCM+FSA-Instr:] by A6,A7,MCART_1:69;
  end;
  end;
  suppose x in { [13,{},<*b1*>] : not contradiction };
   then consider b1 such that
A6: x = [13,{},<*b1*>];
A7: {} in NAT* by FINSEQ_1:49;
   K in NAT & <*b1*> in proj2 SCM+FSA-Instr by A1,A6,RELAT_1:def 5;
  hence x in [:NAT,NAT*,proj2 SCM+FSA-Instr:] by A6,A7,MCART_1:69;
  end;
 end;

registration
  let I be Element of SCM+FSA-Instr;
  cluster I`1_3 -> natural;
  coherence
  proof
A1: SCM+FSA-Instr c= [:NAT,NAT*,proj2 SCM+FSA-Instr:] by Lm1;
   I in SCM+FSA-Instr;
   then I in [:NAT,NAT*,proj2 SCM+FSA-Instr:] by A1;
   then I`1_3 in NAT by RECDEF_2:2;
   hence thesis;
  end;
end;

theorem Th3:
  for I being Element of SCM+FSA-Instr st I`1_3 <= 8 holds I in SCM-Instr
proof
  let I be Element of SCM+FSA-Instr such that
A1: I`1_3 <= 8;
A2: now
    assume I in { [K,{},<*c1,f1*>] : K in {11,12} };
    then consider K,c,f such that
A3: I = [K,{},<*c,f*>] and
A4: K in {11,12};
    I`1_3 = K by A3,RECDEF_2:def 1;
    then I`1_3 = 11 or I`1_3 = 12 by A4,TARSKI:def 2;
    hence contradiction by A1;
  end;
A5: now
    assume I in { [J,{},<*c,f,b*>] : J in {9,10} };
    then consider J,c,b,f such that
A6: I = [J,{},<*c,f,b*>] and
A7: J in {9,10};
    I`1_3 = J by A6,RECDEF_2:def 1;
    then I`1_3 = 9 or I`1_3 = 10 by A7,TARSKI:def 2;
    hence contradiction by A1;
  end;
B5: now
    assume I in { [13,{},<*b1*>] : not contradiction };
    then consider b1 such that
A6: I = [13,{},<*b1*>];
    I`1_3 = 13 by A6,RECDEF_2:def 1;
    hence contradiction by A1;
  end;
  I in SCM-Instr \/ { [J,{},<*c,f,b*>] : J in {9,10} }
   or I in { [K,{},<*c1,f1*>] : K in {11,12} }
   or I in { [13,{},<*b1*>] : not contradiction }
    by XBOOLE_0:def 3;
  hence thesis by A2,A5,B5,XBOOLE_0:def 3;
end;

theorem
  [0,{},{}] in SCM+FSA-Instr by Th2,AMI_2:1;

definition

  func SCM+FSA-OK -> Function of SCM+FSA-Memory, {INT,INT*} \/ { NAT } equals
   (SCM+FSA-Memory --> INT*) +* SCM-OK;
  coherence
  proof
A2: rng(((SCM+FSA-Memory --> INT*) +* SCM-OK)) c= {INT,INT*} \/ { NAT }
    proof
      let y;
      assume y in rng((SCM+FSA-Memory --> INT*) +* SCM-OK);
      then consider z such that
A4:   z in dom(((SCM+FSA-Memory --> INT*) +* SCM-OK)) and
A5:   (((SCM+FSA-Memory --> INT*) +* SCM-OK)).z = y by FUNCT_1:def 3;
      dom((SCM+FSA-Memory --> INT*) +* SCM-OK)
       = dom(SCM+FSA-Memory --> INT*) \/ dom(SCM-OK) by FUNCT_4:def 1
        .= dom(SCM+FSA-Memory --> INT*) \ dom(SCM-OK)
         \/ dom(SCM-OK) by XBOOLE_1:39;
      then
A6:   z in dom(SCM+FSA-Memory --> INT*) \ dom(SCM-OK)
       or z in dom(SCM-OK) by A4,XBOOLE_0:def 3;
      per cases by A6;
      suppose
A7:     z in dom(SCM+FSA-Memory --> INT*) \ dom(SCM-OK);
        then
        not z in dom SCM-OK by XBOOLE_0:def 5;
        then (SCM+FSA-Memory --> INT*).z = y by A5,FUNCT_4:11;
        then
A8:     y in rng(SCM+FSA-Memory --> INT*) by A7,FUNCT_1:def 3;
        {INT*} c= {INT,INT*} & rng(SCM+FSA-Memory --> INT*) c= {INT*} by
FUNCOP_1:13,ZFMISC_1:7;
        then rng(SCM+FSA-Memory --> INT*) c= {INT,INT*} by XBOOLE_1:1;
        hence thesis by A8,XBOOLE_0:def 3;
      end;
      suppose
A12:    z in dom SCM-OK;
        z in dom SCM-OK by A12;
        then z in dom(SCM-OK);
        then
A14:    y = (SCM-OK).z by A5,FUNCT_4:13
          .= SCM-OK.z;
        z in dom SCM-OK by A12;
        then
A15:    z in SCM-Memory by FUNCT_2:def 1;
        z in {NAT} \/ SCM-Data-Loc by A15;
        then
A19:    z in {NAT} or z in SCM-Data-Loc by XBOOLE_0:def 3;
        now
          per cases by A19,TARSKI:def 1;
          suppose
            z = NAT;
            then y = NAT by A14,AMI_2:6,22;
            then y in { NAT } by TARSKI:def 1;
            hence thesis by XBOOLE_0:def 3;
          end;
          suppose
            z in SCM-Data-Loc;
            then y = INT by A14,AMI_2:8;
            then y in {INT,INT*} by TARSKI:def 2;
            hence thesis by XBOOLE_0:def 3;
          end;
        end;
        hence thesis;
      end;
    end;
    dom((SCM+FSA-Memory --> INT*) +* SCM-OK) = dom(SCM+FSA-Memory --> INT*
    ) \/ dom SCM-OK by FUNCT_4:def 1
      .= SCM+FSA-Memory \/ dom SCM-OK by FUNCOP_1:13
      .= SCM+FSA-Memory \/ SCM-Memory by FUNCT_2:def 1
      .= SCM+FSA-Memory by XBOOLE_1:7,12;
    then dom((SCM+FSA-Memory --> INT*) +* SCM-OK)
       = SCM+FSA-Memory
      .= SCM+FSA-Memory;
    hence thesis by A2,FUNCT_2:def 1,RELSET_1:4;
  end;
end;

theorem Th5:
  NAT in SCM+FSA-Memory
proof
  NAT in {NAT} by TARSKI:def 1;
  then NAT in {NAT} \/ SCM-Data-Loc by XBOOLE_0:def 3;
  then NAT in SCM-Memory;
  hence thesis by XBOOLE_0:def 3;
end;

theorem
  x in {9,10} implies [x,{},<*c,f,b*>] in SCM+FSA-Instr
proof
  assume
A1: x in {9,10};
  then x = 9 or x = 10 by TARSKI:def 2;
  then reconsider x as Element of Segm 13 by NAT_1:44;
  [x,{},<*c,f,b*>] in { [K,{},<*c1,f1,b1*>] : K in {9,10}} by A1;
  then [x,{},<*c,f,b*>] in SCM-Instr \/ { [J,{},<*c1,f1,b1*>] : J in {9,10}}
    by XBOOLE_0:def 3;
  then [x,{},<*c,f,b*>] in SCM-Instr \/ { [J,{},<*c1,f1,b1*>] : J in {9,10}}
     \/ { [K,{},<*c2,f2*>] : K in {11,12} }
    by XBOOLE_0:def 3;
  hence thesis;
end;

theorem
  x in {11,12} implies [x,{},<*c,f*>] in SCM+FSA-Instr
proof
  assume
A1: x in {11,12};
  then x = 11 or x = 12 by TARSKI:def 2;
  then reconsider x as Element of Segm 13 by NAT_1:44;
  [x,{},<*c,f*>] in { [K,{},<*c1,f1*>] : K in {11,12}} by A1;
  then [x,{},<*c,f*>] in SCM-Instr \/ { [J,{},<*c2,f2,b*>] : J in {9,10} }
    \/ { [K,{},<*c1,f1*>] : K in {11,12} }
    by XBOOLE_0:def 3;
  then [x,{},<*c,f*>] in SCM-Instr \/ { [J,{},<*c2,f2,b*>] : J in {9,10} }
   \/ { [K,{},<*c1,f1*>] : K in {11,12} };
  hence thesis;
end;

theorem
  SCM+FSA-Memory = {NAT} \/ SCM+FSA-Data-Loc \/ SCM+FSA-Data*-Loc;

theorem Th9:
  SCM+FSA-OK.NAT = NAT
proof
A1: NAT in dom SCM-OK by AMI_2:22,FUNCT_2:def 1;
  thus SCM+FSA-OK.NAT = ((SCM+FSA-Memory --> INT*) +* SCM-OK).NAT
    .= SCM-OK.NAT by A1,FUNCT_4:13
    .= NAT by AMI_2:6,22;
end;

theorem Th10:
  SCM+FSA-OK.b = INT
proof
 b in SCM-Data-Loc;
  then b in SCM-Memory;
  then
A1: b in dom SCM-OK by FUNCT_2:def 1;
  thus SCM+FSA-OK.b = ((SCM+FSA-Memory --> INT*) +* SCM-OK).b
    .= SCM-OK.b by A1,FUNCT_4:13
    .= INT by AMI_2:8;
end;

Lm6: SCM+FSA-Data*-Loc misses SCM-Memory
proof
  assume SCM+FSA-Data*-Loc meets SCM-Memory;
  then consider x such that
A1: x in SCM+FSA-Data*-Loc and
A2: x in SCM-Memory by XBOOLE_0:3;
A3: x in {NAT} \/ SCM-Data-Loc or x in NAT by A2;
  x in NAT \/ [:{0},NAT:] \ {[0,0]} by A1,NUMBERS:def 4;
  then
A4: x in NAT or x in [:{0},NAT:] by XBOOLE_0:def 3;
  per cases by A3,XBOOLE_0:def 3;
  suppose
A5: x in {NAT};
    then ex y,z st x = [y,z] by A4,RELAT_1:def 1,TARSKI:def 1;
    hence contradiction by A5,TARSKI:def 1;
  end;
  suppose
    x in SCM-Data-Loc;
    then
A6: ex k st x = [1,k] by AMI_2:23;
    then consider y,z such that
A7: y in {0} and
    z in NAT and
A8: x= [y,z] by A4,ZFMISC_1:84;
    y = 0 by A7,TARSKI:def 1;
    hence contradiction by A6,A8,ZFMISC_1:27;
  end;
  suppose
    x in NAT;
    hence contradiction by A1,XBOOLE_0:def 5;
  end;
end;

theorem Th12:
  SCM+FSA-OK.f = INT*
proof
 not f in SCM-Memory by Lm6,XBOOLE_0:3;
  then
A2: not f in dom SCM-OK by FUNCT_2:def 1;
  thus SCM+FSA-OK.f = ((SCM+FSA-Memory --> INT*) +* SCM-OK).f
    .= (SCM+FSA-Memory --> INT*).f by A2,FUNCT_4:11
    .= INT* by FUNCOP_1:7;
end;

theorem Th13:
  SCM+FSA-Instr <> INT & NAT <> SCM+FSA-Instr & NAT
  <> INT* & SCM+FSA-Instr <> INT*
proof
 2 in NAT;
  then
A1: 2 in INT by NUMBERS:17;
 not ex x,x1,y being set st x in NAT & x1 in NAT* &
        y in proj2 SCM+FSA-Instr & 2 = [x,x1,y];
   then not 2 in [:NAT,NAT*,proj2 SCM+FSA-Instr:] by MCART_1:68;
   then
A2:  not 2 in SCM+FSA-Instr by Lm1;
  hence SCM+FSA-Instr <> INT by A1;
  thus NAT <> SCM+FSA-Instr by A2;
  0 qua Integer in INT by INT_1:def 1;
  then <*0*> is FinSequence of INT by FINSEQ_1:74;
  then
A3: <*0*> in INT* by FINSEQ_1:def 11;
  hereby
A4: card <*0*> = 1 by CARD_1:30;
    assume NAT = INT*;
    then <*0*> = { 0 } by A3,A4,CARD_1:49,def 2;
    hence contradiction by ZFMISC_1:3;
  end;
  now
    assume {} in SCM+FSA-Instr;
    then {} in [:NAT,NAT*,proj2 SCM+FSA-Instr:] by Lm1;
    then ex x,x1,y being set st x in NAT & x1 in NAT* &
        y in proj2 SCM+FSA-Instr & {} = [x,x1,y] by MCART_1:68;
    hence contradiction;
  end;
  hence thesis by FINSEQ_1:49;
end;

theorem
  for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = NAT holds i = NAT
proof
  let i be Element of SCM+FSA-Memory such that
A1: SCM+FSA-OK.i = NAT;
  not i in SCM+FSA-Data*-Loc by A1,Th12,Th13;
  then
A3: i in {NAT} \/ SCM+FSA-Data-Loc by XBOOLE_0:def 3;
  not i in SCM+FSA-Data-Loc by A1,Th10,NUMBERS:27;
  then i in {NAT} by A3,XBOOLE_0:def 3;
  hence thesis by TARSKI:def 1;
end;

theorem
  for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = INT holds i in
  SCM+FSA-Data-Loc
proof
  let i be Element of SCM+FSA-Memory such that
A1: SCM+FSA-OK.i = INT;
  not i in SCM+FSA-Data*-Loc by A1,Th12,FUNCT_7:16;
  then
A3: i in {NAT} \/ SCM+FSA-Data-Loc by XBOOLE_0:def 3;
  not i in {NAT} by A1,Th9,NUMBERS:27,TARSKI:def 1;
  hence thesis by A3,XBOOLE_0:def 3;
end;

theorem
  for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = SCM+FSA-Instr
  holds i in NAT
proof
  let i be Element of SCM+FSA-Memory such that
A1: SCM+FSA-OK.i = SCM+FSA-Instr;
  now
    assume
 i in {NAT} \/ SCM+FSA-Data-Loc \/ SCM+FSA-Data*-Loc;
    not i in SCM+FSA-Data*-Loc by A1,Th12,Th13;
    then
A3: i in {NAT} \/ SCM+FSA-Data-Loc by XBOOLE_0:def 3;
    not i in SCM+FSA-Data-Loc by A1,Th10,Th13;
    then i in{NAT} by A3,XBOOLE_0:def 3;
    hence contradiction by A1,Th9,Th13,TARSKI:def 1;
  end;
  hence thesis;
end;

theorem
  for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = INT* holds i
  in SCM+FSA-Data*-Loc
proof
  let i be Element of SCM+FSA-Memory such that
A1: SCM+FSA-OK.i = INT*;
A2: now
    assume
A3: i in {NAT} \/ SCM+FSA-Data-Loc;
    not i in {NAT} by A1,Th9,Th13,TARSKI:def 1;
    then i in SCM+FSA-Data-Loc by A3,XBOOLE_0:def 3;
    hence contradiction by A1,Th10,FUNCT_7:16;
  end;
  thus thesis by A2,XBOOLE_0:def 3;
end;

registration
 cluster SCM-OK -> non-empty;
 coherence
  proof
A1:  rng SCM-OK c= {INT} \/ { NAT } by RELAT_1:def 19;
   assume {} in rng SCM-OK;
    then {} in {INT} or {} in { NAT } by A1,XBOOLE_0:def 3;
    then {} = INT or {} = NAT by TARSKI:def 1;
   hence contradiction;
  end;
 cluster SCM+FSA-OK -> non-empty;
 coherence
  proof
A2:  rng SCM+FSA-OK c= {INT,INT*} \/ { NAT } by RELAT_1:def 19;
   assume {} in rng SCM+FSA-OK;
    then {} in {INT,INT*} or {} in { NAT } by A2,XBOOLE_0:def 3;
    then {} = INT or {} = INT* or {} = NAT by TARSKI:def 1,def 2;
   hence contradiction;
  end;
end;

definition
  mode SCM+FSA-State is Element of product SCM+FSA-OK;
end;

theorem Th18:
  for s being SCM+FSA-State, I being Element of SCM-Instr holds s|
  SCM-Memory is SCM-State
proof
  let s be SCM+FSA-State, I be Element of SCM-Instr;
A1: dom(SCM+FSA-OK) = SCM+FSA-Memory by FUNCT_2:def 1;
A2: dom(s|SCM-Memory) = dom s /\ SCM-Memory by RELAT_1:61
    .= SCM+FSA-Memory /\ SCM-Memory by A1,CARD_3:9
    .= SCM-Memory by XBOOLE_1:21;
A3: now
    let x;
    assume x in dom SCM-OK;
    then
A5: x in SCM-Memory by FUNCT_2:def 1;
    then
A6: x in {NAT} \/ SCM-Data-Loc;
    per cases by A6,XBOOLE_0:def 3;
    suppose
A7:   x in {NAT};
A8:   (s|SCM-Memory).x = (s|SCM-Memory).x
        .= s.x by A2,A5,FUNCT_1:47;
      reconsider a = x as Element of SCM+FSA-Memory by A5,Th1;
A9:   s.a in pi(product SCM+FSA-OK,a) by CARD_3:def 6;
A10:  x = NAT by A7,TARSKI:def 1;
      dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
      then pi(product SCM+FSA-OK,a) = NAT by A10,Th9,CARD_3:12;
      hence (s|SCM-Memory).x in SCM-OK.x
       by A10,A8,A9,AMI_2:6,22;
    end;
    suppose
A11:  x in SCM-Data-Loc;
A12:  (s|SCM-Memory).x = (s|SCM-Memory).x
        .= s.x by A2,A5,FUNCT_1:47;
      reconsider a = x as Element of SCM+FSA-Memory by A5,Th1;
      dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
      then
A13:  pi(product SCM+FSA-OK,a) = SCM+FSA-OK.a by CARD_3:12
        .= INT by A11,Th10;
      s.a in pi(product SCM+FSA-OK,a) by CARD_3:def 6;
      hence (s|SCM-Memory).x in SCM-OK.x
       by A11,A12,A13,AMI_2:8;
    end;
  end;
  dom(s|SCM-Memory) = dom(s|SCM-Memory)
    .= SCM-Memory by A2
    .= SCM-Memory
    .= dom SCM-OK by FUNCT_2:def 1;
  hence thesis by A3,CARD_3:9;
end;

theorem Th19:
  for s being SCM+FSA-State, s9 being SCM-State
   holds s +* s9 is SCM+FSA-State
proof
  let s be SCM+FSA-State, s9 be SCM-State;
A1: dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
  reconsider
  f = SCM+FSA-OK as non-empty ManySortedSet of SCM+FSA-Memory;
A2: dom s9 = dom SCM-OK by CARD_3:9
    .= SCM-Memory by FUNCT_2:def 1;
  now
    let x be set;
    assume
A3: x in dom s9;
    then
A4: x in {NAT} \/ SCM-Data-Loc by A2;
    per cases by A4,XBOOLE_0:def 3;
    suppose
A5:   x in {NAT};
      reconsider a = x as Element of SCM-Memory by A2,A3;
A6:   s9.a in pi(product SCM-OK,a) by CARD_3:def 6;
A7:   x = NAT by A5,TARSKI:def 1;
      dom SCM-OK = SCM-Memory by FUNCT_2:def 1;
      then pi(product SCM-OK,a) = SCM-OK.a by CARD_3:12
        .= NAT by A7,AMI_2:6;
      hence s9.x in f.x by A5,A6,Th9,TARSKI:def 1;
    end;
    suppose
A8:   x in SCM-Data-Loc;
      reconsider a = x as Element of SCM-Memory by A2,A3;
A9:   s9.a in pi(product SCM-OK,a) by CARD_3:def 6;
      dom SCM-OK = SCM-Memory by FUNCT_2:def 1;
      then
A10:  pi(product SCM-OK,a) = SCM-OK.a by CARD_3:12;
      SCM+FSA-OK.x = INT by A8,Th10;
      hence s9.x in f.x by A8,A10,A9,AMI_2:8;
    end;
  end;
  then s +* s9 is SCM+FSA-State by A1,A2,PRE_CIRC:6,XBOOLE_1:7;
  hence thesis;
end;

definition
  let s be SCM+FSA-State, u be Nat;
  func SCM+FSA-Chg(s,u) -> SCM+FSA-State equals
  s +* (NAT .--> u);
  coherence
  proof
A1: now
      let x be set;
      assume
A2:   x in dom(SCM+FSA-OK);
      now
        per cases;
        suppose
A3:       x = NAT;
          {NAT} = dom(NAT .--> u) by FUNCOP_1:13;
          then NAT in dom(NAT .--> u) by TARSKI:def 1;
          then (s +* (NAT .--> u)).NAT = (NAT .--> u).NAT by FUNCT_4:13
            .= u by FUNCOP_1:72;
          hence (s +* (NAT .--> u)).x in SCM+FSA-OK.x by A3,Th9,ORDINAL1:def 12
;
        end;
        suppose
A4:       x <> NAT;
          {NAT} = dom(NAT .--> u) by FUNCOP_1:13;
          then not x in dom(NAT .--> u) by A4,TARSKI:def 1;
          then (s +* (NAT .--> u)).x = s.x by FUNCT_4:11;
          hence (s +* (NAT .--> u)).x in SCM+FSA-OK.x by A2,CARD_3:9;
        end;
      end;
      hence (s +* (NAT .--> u)).x in SCM+FSA-OK.x;
    end;
A5: dom(SCM+FSA-OK) = SCM+FSA-Memory by FUNCT_2:def 1;
    then dom s = SCM+FSA-Memory by CARD_3:9;
    then dom(s +* (NAT .--> u)) = SCM+FSA-Memory \/ dom(NAT .--> u) by
FUNCT_4:def 1
      .= SCM+FSA-Memory \/ {NAT} by FUNCOP_1:13
      .= dom(SCM+FSA-OK) by A5,Th5,ZFMISC_1:40;
    hence thesis by A1,CARD_3:9;
  end;
end;

definition
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer;
  func SCM+FSA-Chg(s,t,u) -> SCM+FSA-State equals
  s +* (t .--> u);
  coherence
  proof
A1: now
      let x be set;
      assume
A2:   x in dom(SCM+FSA-OK);
      now
        per cases;
        suppose
A3:       x = t;
          {t} = dom(t .--> u) by FUNCOP_1:13;
          then t in dom(t .--> u) by TARSKI:def 1;
          then (s +* (t .--> u)).t = (t .--> u).t by FUNCT_4:13
            .= u by FUNCOP_1:72;
          then (s +* (t .--> u)).t in INT by INT_1:def 2;
          hence (s +* (t .--> u)).x in SCM+FSA-OK.x by A3,Th10;
        end;
        suppose
A4:       x <> t;
          {t} = dom(t .--> u) by FUNCOP_1:13;
          then not x in dom(t .--> u) by A4,TARSKI:def 1;
          then (s +* (t .--> u)).x = s.x by FUNCT_4:11;
          hence (s +* (t .--> u)).x in SCM+FSA-OK.x by A2,CARD_3:9;
        end;
      end;
      hence (s +* (t .--> u)).x in SCM+FSA-OK.x;
    end;
A5: dom(SCM+FSA-OK) = SCM+FSA-Memory by FUNCT_2:def 1;
    then dom s = SCM+FSA-Memory by CARD_3:9;
    then dom(s +* (t .--> u)) = SCM+FSA-Memory \/ dom(t .--> u) by
FUNCT_4:def 1
      .= SCM+FSA-Memory \/ {t} by FUNCOP_1:13
      .= dom(SCM+FSA-OK) by A5,ZFMISC_1:40;
    hence thesis by A1,CARD_3:9;
  end;
end;

definition
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc, u be FinSequence
  of INT;
  func SCM+FSA-Chg(s,t,u) -> SCM+FSA-State equals
  s +* (t .--> u);
  coherence
  proof
A1: now
      let x be set;
      assume
A2:   x in dom(SCM+FSA-OK);
      now
        per cases;
        suppose
A3:       x = t;
          {t} = dom(t .--> u) by FUNCOP_1:13;
          then t in dom(t .--> u) by TARSKI:def 1;
          then (s +* (t .--> u)).t = (t .--> u).t by FUNCT_4:13
            .= u by FUNCOP_1:72;
          then (s +* (t .--> u)).t in INT* by FINSEQ_1:def 11;
          hence (s +* (t .--> u)).x in SCM+FSA-OK.x by A3,Th12;
        end;
        suppose
A4:       x <> t;
          {t} = dom(t .--> u) by FUNCOP_1:13;
          then not x in dom(t .--> u) by A4,TARSKI:def 1;
          then (s +* (t .--> u)).x = s.x by FUNCT_4:11;
          hence (s +* (t .--> u)).x in SCM+FSA-OK.x by A2,CARD_3:9;
        end;
      end;
      hence (s +* (t .--> u)).x in SCM+FSA-OK.x;
    end;
A5: dom(SCM+FSA-OK) = SCM+FSA-Memory by FUNCT_2:def 1;
    then dom s = SCM+FSA-Memory by CARD_3:9;
    then dom(s +* (t .--> u)) = SCM+FSA-Memory \/ dom(t .--> u) by
FUNCT_4:def 1
      .= SCM+FSA-Memory \/ {t} by FUNCOP_1:13
      .= dom(SCM+FSA-OK) by A5,ZFMISC_1:40;
    hence thesis by A1,CARD_3:9;
  end;
end;

definition
  let s be SCM+FSA-State, a be Element of SCM+FSA-Data-Loc;
  redefine func s.a -> Integer;
  coherence
  proof
    dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
    then
A1: pi(product SCM+FSA-OK,a) = SCM+FSA-OK.a by CARD_3:12
      .= INT by Th10;
    s.a in pi(product SCM+FSA-OK,a) by CARD_3:def 6;
    hence thesis by A1;
  end;
end;

definition
  let s be SCM+FSA-State, a be Element of SCM+FSA-Data*-Loc;
  redefine func s.a -> FinSequence of INT;
  coherence
  proof
    dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
    then
A1: pi(product SCM+FSA-OK,a) = SCM+FSA-OK.a by CARD_3:12
      .= INT* by Th12;
    s.a in pi(product SCM+FSA-OK,a) by CARD_3:def 6;
    hence thesis by A1,FINSEQ_1:def 11;
  end;
end;

definition
  let x be Element of SCM+FSA-Instr;
  given c,f,b,J such that
A1: x = [J,{},<*c,f,b*>];
  func x int_addr1 -> Element of SCM+FSA-Data-Loc means
  ex c,f,b st <*c,f,b*> = x`3_3 & it = c;
  existence
  proof
    take c,c,f,b;
    thus thesis by A1,RECDEF_2:def 3;
  end;
  uniqueness
  proof
    let a1,a2 be Element of SCM+FSA-Data-Loc;
    given c1,f1,b1 such that
A2: <*c1,f1,b1*> = x`3_3 and
A3: a1 = c1;
    given c2,f2,b2 such that
A4: <*c2,f2,b2*> = x`3_3 & a2 = c2;
    thus a1 = <*c1,f1,b1*>/.1 by A3,FINSEQ_4:18
      .= a2 by A2,A4,FINSEQ_4:18;
  end;
  func x int_addr2 -> Element of SCM+FSA-Data-Loc means
  ex c,f,b st <*c,f,b*> = x`3_3 & it = b;
  existence
  proof
    take b,c,f,b;
    thus thesis by A1,RECDEF_2:def 3;
  end;
  correctness
  proof
    let a1,a2 be Element of SCM+FSA-Data-Loc;
    given c1,f1,b1 such that
A5: <*c1,f1,b1*> = x`3_3 and
A6: a1 = b1;
    given c2,f2,b2 such that
A7: <*c2,f2,b2*> = x`3_3 & a2 = b2;
    thus a1 = <*c1,f1,b1*>/.3 by A6,FINSEQ_4:18
      .= a2 by A5,A7,FINSEQ_4:18;
  end;
  func x coll_addr1 -> Element of SCM+FSA-Data*-Loc means
  ex c,f,b st <*c,f,b*> = x`3_3 & it = f;
  existence
  proof
    take f,c,f,b;
    thus thesis by A1,RECDEF_2:def 3;
  end;
  correctness
  proof
    let a1,a2 be Element of SCM+FSA-Data*-Loc;
    given c1,f1,b1 such that
A8: <*c1,f1,b1*> = x`3_3 and
A9: a1 = f1;
    given c2,f2,b2 such that
A10: <*c2,f2,b2*> = x`3_3 & a2 = f2;
    thus a1 = <*c1,f1,b1*>/.2 by A9,FINSEQ_4:18
      .= a2 by A8,A10,FINSEQ_4:18;
  end;
end;

definition
  let x be Element of SCM+FSA-Instr;
  given c such that
A1: x = [ 13,{}, <*c*>];
  func x int_addr -> Element of SCM+FSA-Data-Loc means
  ex c st <*c*> = x`3_3 & it = c;
  existence
  proof
    take c,c;
    thus thesis by A1,RECDEF_2:def 3;
  end;
  uniqueness
  proof
    let a1,a2 be Element of SCM+FSA-Data-Loc;
    given c1 such that
A2: <*c1*> = x`3_3 and
A3: a1 = c1;
    given c2 such that
A4: <*c2*> = x`3_3 & a2 = c2;
    thus a1 = <*c1*>/.1 by A3,FINSEQ_4:16
      .= a2 by A2,A4,FINSEQ_4:16;
  end;
end;

definition
  let x be Element of SCM+FSA-Instr;
  given c,f,J such that
A1: x = [ J,{}, <*c,f*>];
  func x int_addr3 -> Element of SCM+FSA-Data-Loc means
  ex c,f st <*c,f*> = x`3_3 & it = c;
  existence
  proof
    take c,c,f;
    thus thesis by A1,RECDEF_2:def 3;
  end;
  uniqueness
  proof
    let a1,a2 be Element of SCM+FSA-Data-Loc;
    given c1,f1 such that
A2: <*c1,f1*> = x`3_3 and
A3: a1 = c1;
    given c2,f2 such that
A4: <*c2,f2*> = x`3_3 & a2 = c2;
    thus a1 = <*c1,f1*>/.1 by A3,FINSEQ_4:17
      .= a2 by A2,A4,FINSEQ_4:17;
  end;
  func x coll_addr2 -> Element of SCM+FSA-Data*-Loc means
  ex c,f st <*c,f*> = x`3_3 & it = f;
  existence
  proof
    take f,c,f;
    thus thesis by A1,RECDEF_2:def 3;
  end;
  correctness
  proof
    let a1,a2 be Element of SCM+FSA-Data*-Loc;
    given c1,f1 such that
A5: <*c1,f1*> = x`3_3 and
A6: a1 = f1;
    given c2,f2 such that
A7: <*c2,f2*> = x`3_3 & a2 = f2;
    thus a1 = <*c1,f1*>/.2 by A6,FINSEQ_4:17
      .= a2 by A5,A7,FINSEQ_4:17;
  end;

end;

definition
  let s be SCM+FSA-State;
  func IC(s) -> Element of NAT equals
  s.NAT;
  coherence
  proof
    reconsider z = NAT as Element of SCM+FSA-Memory by Th5;
    dom SCM+FSA-OK = SCM+FSA-Memory by FUNCT_2:def 1;
    then pi(product SCM+FSA-OK,NAT) = SCM+FSA-OK.z by CARD_3:12
      .= NAT by Th9;
    hence thesis by CARD_3:def 6;
  end;
end;

definition
  let x be Element of SCM+FSA-Instr, s be SCM+FSA-State;
  func SCM+FSA-Exec-Res(x,s) -> SCM+FSA-State means
    ex x9 being Element of SCM-Instr, s9 being SCM-State st
     x = x9 & s9 = s|SCM-Memory &
     it = s +* SCM-Exec-Res(x9,s9)
              if x`1_3 <= 8,
    ex i being Integer, k st
     k = abs(s.(x int_addr2)) & i = (s.(x coll_addr1))/.k &
        it = SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr1,i),succ IC s)
              if x`1_3 = 9,
    ex f being FinSequence of INT,k st
     k = abs(s.(x int_addr2)) & f = s.(x coll_addr1)+*(k,s.(x int_addr1)) &
      it = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),succ IC s)
              if x`1_3 = 10,
    it =
     SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr3,len(s.(x coll_addr2))),succ IC s)
              if x`1_3 = 11,
    ex f being FinSequence of INT,k st
     k = abs(s.(x int_addr3)) & f = k |-> 0 &
     it = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr2,f),succ IC s)
              if x`1_3 = 12,
    ex i being Integer st
     i = 1 &
     it = SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr,i),succ IC s)
              if x`1_3 = 13
    otherwise it = s;
  existence
  proof
    hereby
      assume x`1_3 <= 8;
      then reconsider x9 = x as Element of SCM-Instr by Th3;
      reconsider s9 = s|SCM-Memory as SCM-State by Th18;
      reconsider s1 = s +* SCM-Exec-Res(x9,s9) as SCM+FSA-State by Th19;
      take s1,x9,s9;
      thus x = x9;
      thus s9 = s|SCM-Memory;
      thus s1 = s +* SCM-Exec-Res(x9,s9);
    end;
    hereby
      reconsider k = abs(s.(x int_addr2)) as Element of NAT;
      assume x`1_3 = 9;
      reconsider i = (s.(x coll_addr1))/.k as Integer;
      take s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr1,i),succ IC s);
      take i,k;
      thus k = abs(s.(x int_addr2)) & i = (s.(x coll_addr1))/.k & s1 =
      SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr1,i),succ IC s);
    end;
    hereby
      reconsider k = abs(s.(x int_addr2)) as Element of NAT;
      assume x`1_3 = 10;
      per cases;
      suppose
A1:     k in dom( s.(x coll_addr1));
        set f = s.(x coll_addr1) +* (k.-->s.(x int_addr1));
A2:     {k} c= dom( s.(x coll_addr1)) by A1,ZFMISC_1:31;
        dom f = dom(s.(x coll_addr1)) \/ dom((k.-->s.(x int_addr1))) by
FUNCT_4:def 1
          .= dom(s.(x coll_addr1)) \/ {k} by FUNCOP_1:13
          .= dom(s.(x coll_addr1)) by A2,XBOOLE_1:12
          .= Seg len(s.(x coll_addr1)) by FINSEQ_1:def 3;
        then reconsider f as FinSequence by FINSEQ_1:def 2;
        s.(x int_addr1) in INT & rng((k.-->s.(x int_addr1))) = {s.(x
        int_addr1)} by FUNCOP_1:8,INT_1:def 2;
        then
        rng(s.(x coll_addr1)) c= INT & rng((k.-->s.(x int_addr1))) c= INT
        by FINSEQ_1:def 4,ZFMISC_1:31;
        then rng f c= rng(s.(x coll_addr1)) \/ rng((k.-->s.(x int_addr1))) &
rng(s.(x coll_addr1)) \/ rng((k.-->s.(x int_addr1))) c= INT by FUNCT_4:17
,XBOOLE_1:8;
        then rng f c= INT by XBOOLE_1:1;
        then reconsider f as FinSequence of INT by FINSEQ_1:def 4;
        take s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),succ IC s);
        take f,k;
        thus k = abs(s.(x int_addr2));
        thus f = s.(x coll_addr1) +* (k,s.(x int_addr1)) by A1,FUNCT_7:def 3;
        thus s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),succ IC s);
      end;
      suppose
A3:     not k in dom( s.(x coll_addr1));
        reconsider f = s.(x coll_addr1) as FinSequence of INT;
        take s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),succ IC s);
        take f,k;
        thus k = abs(s.(x int_addr2));
        thus f = s.(x coll_addr1) +* (k,s.(x int_addr1)) by A3,FUNCT_7:def 3;
        thus s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),succ IC s);
      end;
    end;
    thus x`1_3 = 11 implies ex s1 being SCM+FSA-State st s1 = SCM+FSA-Chg(
    SCM+FSA-Chg(s,x int_addr3,len(s.(x coll_addr2))),succ IC s);
    hereby
      reconsider k = abs(s.(x int_addr3)) as Element of NAT;
      assume x`1_3 = 12;
      0 in INT by INT_1:def 2;
      then
A4:   {0} c= INT by ZFMISC_1:31;
      k |-> 0 = Seg k --> 0 by FINSEQ_2:def 2;
      then rng(k |-> 0) c= {0} by FUNCOP_1:13;
      then rng(k |-> 0) c= INT by A4,XBOOLE_1:1;
      then reconsider f = k |-> 0 as FinSequence of INT by FINSEQ_1:def 4;
      take s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr2,f),succ IC s);
      take f,k;
      thus k = abs(s.(x int_addr3)) & f = k |-> 0 & s1 = SCM+FSA-Chg(
      SCM+FSA-Chg(s,x coll_addr2,f),succ IC s);
    end;
    hereby
      assume x`1_3 = 13;
      reconsider i = 1 as Integer;
      take s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr,i),succ IC s);
      take i;
      thus i = 1 & s1 = SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr,i),succ IC s);
    end;
    thus thesis;
  end;
  uniqueness;
  consistency;
end;

definition
  func SCM+FSA-Exec -> Action of SCM+FSA-Instr, product SCM+FSA-OK means
  for x being Element of SCM+FSA-Instr, y being
  SCM+FSA-State holds (it.x).y = SCM+FSA-Exec-Res(x,y);
  existence
  proof
    deffunc U(Element of SCM+FSA-Instr, SCM+FSA-State) = SCM+FSA-Exec-Res($1,
    $2);
    consider f being Function of [:SCM+FSA-Instr,product SCM+FSA-OK:], product
    SCM+FSA-OK such that
A1: for x being Element of SCM+FSA-Instr, y being SCM+FSA-State holds
    f.(x,y) = U(x,y) from BINOP_1:sch 4;
    take curry f;
    let x be Element of SCM+FSA-Instr, y be SCM+FSA-State;
    thus (curry f).x.y = f.(x,y) by CAT_2:3
      .= SCM+FSA-Exec-Res(x,y) by A1;
  end;
  uniqueness
  proof
    let f,g be Function of SCM+FSA-Instr, Funcs(product SCM+FSA-OK, product
    SCM+FSA-OK) such that
A2: for x being Element of SCM+FSA-Instr, y being SCM+FSA-State holds
    (f.x qua Element of Funcs(product SCM+FSA-OK, product SCM+FSA-OK)).y =
    SCM+FSA-Exec-Res(x,y) and
A3: for x being Element of SCM+FSA-Instr, y being SCM+FSA-State holds
    (g.x qua Element of Funcs(product SCM+FSA-OK, product SCM+FSA-OK)).y =
    SCM+FSA-Exec-Res(x,y);
    now
      let x be Element of SCM+FSA-Instr;
      reconsider gx=g.x, fx=f.x as Function of product SCM+FSA-OK, product
      SCM+FSA-OK;
      now
        let y be SCM+FSA-State;
        thus fx.y = SCM+FSA-Exec-Res(x,y) by A2
          .= gx.y by A3;
      end;
      hence f.x = g.x by FUNCT_2:63;
    end;
    hence f = g by FUNCT_2:63;
  end;
end;

theorem
  for s being SCM+FSA-State, u being Element of NAT holds SCM+FSA-Chg(s,
  u).NAT = u
proof
  let s be SCM+FSA-State, u be Element of NAT;
  {NAT} = dom(NAT .--> u) by FUNCOP_1:13;
  then NAT in dom(NAT .--> u) by TARSKI:def 1;
  hence SCM+FSA-Chg(s,u).NAT = (NAT .--> u).NAT by FUNCT_4:13
    .= u by FUNCOP_1:72;
end;

theorem
  for s being SCM+FSA-State, u being Element of NAT, mk being Element of
  SCM+FSA-Data-Loc holds SCM+FSA-Chg(s,u).mk = s.mk
proof
  let s be SCM+FSA-State, u be Element of NAT, mk be Element of
  SCM+FSA-Data-Loc;
  SCM+FSA-OK.mk = INT & {NAT} = dom(NAT .--> u) by Th10,FUNCOP_1:13;
  then not mk in dom(NAT .--> u) by Th9,NUMBERS:27,TARSKI:def 1;
  hence thesis by FUNCT_4:11;
end;

theorem
  for s being SCM+FSA-State, u being Element of NAT, p being Element of
  SCM+FSA-Data*-Loc holds SCM+FSA-Chg(s,u).p = s.p
proof
  let s be SCM+FSA-State, u be Element of NAT, mk be Element of
  SCM+FSA-Data*-Loc;
  SCM+FSA-OK.mk = INT* & {NAT} = dom(NAT .--> u) by Th12,FUNCOP_1:13;
  then not mk in dom(NAT .--> u) by Th9,Th13,TARSKI:def 1;
  hence thesis by FUNCT_4:11;
end;

theorem
  for s being SCM+FSA-State, u,v being Element of NAT holds SCM+FSA-Chg(
  s,u).v = s.v
proof
  let s be SCM+FSA-State, u,v be Element of NAT;
  {NAT} = dom(NAT .--> u) by FUNCOP_1:13;
  then not v in dom(NAT .--> u) by TARSKI:def 1;
  hence thesis by FUNCT_4:11;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data-Loc, u
  being Integer holds SCM+FSA-Chg(s,t,u).NAT = s.NAT
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer;
  SCM+FSA-OK.t = INT & {t} = dom(t .--> u) by Th10,FUNCOP_1:13;
  then not NAT in dom(t .--> u) by Th9,NUMBERS:27,TARSKI:def 1;
  hence thesis by FUNCT_4:11;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data-Loc, u
  being Integer holds SCM+FSA-Chg(s,t,u).t = u
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer;
  {t} = dom(t .--> u) by FUNCOP_1:13;
  then t in dom(t .--> u) by TARSKI:def 1;
  hence SCM+FSA-Chg(s,t,u).t = (t .--> u).t by FUNCT_4:13
    .= u by FUNCOP_1:72;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data-Loc, u
  being Integer, mk being Element of SCM+FSA-Data-Loc st mk <> t holds
  SCM+FSA-Chg(s,t,u).mk = s.mk
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer, mk
  be Element of SCM+FSA-Data-Loc such that
A1: mk <> t;
  {t} = dom(t .--> u) by FUNCOP_1:13;
  then not mk in dom(t .--> u) by A1,TARSKI:def 1;
  hence thesis by FUNCT_4:11;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data-Loc, u
being Integer, f being Element of SCM+FSA-Data*-Loc holds SCM+FSA-Chg(s,t,u).f
  = s.f
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer, mk
  be Element of SCM+FSA-Data*-Loc;
A1: {t} = dom(t .--> u) by FUNCOP_1:13;
  SCM+FSA-OK.t = INT & SCM+FSA-OK.mk = INT* by Th10,Th12;
  then not mk in dom(t .--> u) by A1,FUNCT_7:16,TARSKI:def 1;
  hence thesis by FUNCT_4:11;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data*-Loc, u
  being FinSequence of INT holds SCM+FSA-Chg(s,t,u).t = u
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc, u be FinSequence
  of INT;
  {t} = dom(t .--> u) by FUNCOP_1:13;
  then t in dom(t .--> u) by TARSKI:def 1;
  hence SCM+FSA-Chg(s,t,u).t = (t .--> u).t by FUNCT_4:13
    .= u by FUNCOP_1:72;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data*-Loc, u
  being FinSequence of INT, mk being Element of SCM+FSA-Data*-Loc st mk <> t
  holds SCM+FSA-Chg(s,t,u).mk = s.mk
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc, u be FinSequence
  of INT, mk be Element of SCM+FSA-Data*-Loc such that
A1: mk <> t;
  {t} = dom(t .--> u) by FUNCOP_1:13;
  then not mk in dom(t .--> u) by A1,TARSKI:def 1;
  hence thesis by FUNCT_4:11;
end;

theorem
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data*-Loc, u
being FinSequence of INT, a being Element of SCM+FSA-Data-Loc holds SCM+FSA-Chg
  (s,t,u).a = s.a
proof
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc, u be FinSequence
  of INT, mk be Element of SCM+FSA-Data-Loc;
A1: {t} = dom(t .--> u) by FUNCOP_1:13;
  SCM+FSA-OK.t = INT* & SCM+FSA-OK.mk = INT by Th10,Th12;
  then not mk in dom(t .--> u) by A1,FUNCT_7:16,TARSKI:def 1;
  hence thesis by FUNCT_4:11;
end;

theorem
  SCM+FSA-Data*-Loc misses SCM-Memory by Lm6;

theorem
 SCM+FSA-Instr c= [:NAT,NAT*,proj2 SCM+FSA-Instr:] by Lm1;

registration
 cluster proj2 SCM+FSA-Instr -> FinSequence-membered;
 coherence
  proof let f be set;
   assume f in proj2 SCM+FSA-Instr;
    then consider y being set such that
A1:   [y,f] in SCM+FSA-Instr by RELAT_1:def 5;
    set x = [y,f];
  per cases by A1;
  suppose
B1: x in  SCM-Instr \/ { [J,{},<*c,f2,b*>] : J in {9,10} }
   \/ { [K,{},<*c1,f1*>] : K in {11,12} };
  per cases by B1,XBOOLE_0:def 3;
  suppose
A2: x in SCM-Instr \/ { [J,{},<*c,f1,b*>] : J in {9,10} };
  per cases by A2,XBOOLE_0:def 3;
  suppose x in SCM-Instr;
   then f in proj2 SCM-Instr by RELAT_1:def 5;
  hence f is FinSequence;
  end;
  suppose x in { [J,{},<*c,f1,b*>] : J in {9,10}};
   then consider J,c,b,f1 such that
A3:  x = [J,{},<*c,f1,b*>] & J in {9,10};
  f = <*c,f1,b*> by A3,ZFMISC_1:27;
  hence f is FinSequence;
  end;
  end;
  suppose x in { [K,{},<*c1,f1*>] : K in {11,12} };
   then consider K,c1,f1 such that
A4: x = [K,{},<*c1,f1*>] & K in {11,12};
  f = <*c1,f1*> by A4,ZFMISC_1:27;
  hence f is FinSequence;
  end;
  end;
  suppose x in { [13,{},<*b1*>] : not contradiction };
   then consider b1 such that
A4: x = [13,{},<*b1*>];
  f = <*b1*> by A4,ZFMISC_1:27;
  hence f is FinSequence;
  end;
  end;
end;

