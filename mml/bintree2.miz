:: Full Trees
::  by Robert Milewski
::
:: Received February 25, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies FINSEQ_1, RELAT_1, BINTREE1, TREES_1, MARGREL1, BOOLE, ORDINAL1,
      FUNCT_1, TREES_2, MIDSP_3, TREES_4, CQC_LANG, MCART_1, FINSEQ_5,
      BINARITH, CAT_1, EUCLID, FINSET_1, POWER, BINARI_3, ARYTM_1, ZF_LANG,
      CARD_1, TARSKI, NAT_1, MATRIX_2, BINTREE2, FINSEQ_4, ARYTM;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      MCART_1, NAT_1, NAT_D, ABIAN, SERIES_1, RELAT_1, MARGREL1, DOMAIN_1,
      FUNCT_1, PARTFUN1, FUNCT_2, BINOP_1, FINSET_1, FUNCOP_1, FINSEQ_1,
      FINSEQ_5, BINARITH, BINARI_3, TREES_1, TREES_2, TREES_4, BINTREE1,
      EUCLID, XXREAL_0;
 constructors WELLORD2, DOMAIN_1, XXREAL_0, NAT_1, NAT_D, FINSEQOP, SERIES_1,
      BINARITH, FINSEQ_5, TREES_9, ABIAN, EUCLID, BINTREE1, BINARI_3, ORDINAL1;
 registrations XBOOLE_0, SUBSET_1, ORDINAL1, RELSET_1, FINSET_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, FINSEQ_1, MARGREL1, TREES_2, TREES_9, BINTREE1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, XBOOLE_0, EUCLID, FINSEQ_2, MARGREL1, XBOOLEAN, BINOP_1;
 theorems TARSKI, MCART_1, NAT_1, NAT_2, WELLORD2, ZFMISC_1, FUNCT_1,
      FUNCT_2, CARD_1, CARD_2, FINSET_1, POWER, FUNCOP_1, FINSEQ_1, FINSEQ_2,
      FINSEQ_4, FINSEQ_5, FINSEQ_6, BINARITH, BINARI_3, TREES_1, TREES_2,
      BINTREE1, QC_LANG4, XBOOLE_0, XBOOLE_1, XREAL_1, NAT_D, PARTFUN1,
      RELAT_1, ORDINAL1, XXREAL_0, XREAL_0;
 schemes FUNCT_2, NAT_1, FINSEQ_2, TREES_2, WELLORD2;

begin :: Trees and Binary Trees

Lm1: for D being set, p, q being FinSequence of D holds
p^q is FinSequence of D;

Lm2: for D being non empty set, x being Element of D holds
<*x*> is FinSequence of D;

theorem Th1:
  for D be set for p be FinSequence for n be Element of NAT holds
  p in D* implies p|Seg n in D*
proof
  let D be set;
  let p be FinSequence;
  let n be Element of NAT;
  assume p in D*;
  then p is FinSequence of D by FINSEQ_1:def 11;
  then p|Seg n is FinSequence of D by FINSEQ_1:23;
  hence p|Seg n in D* by FINSEQ_1:def 11;
end;

theorem Th2:
  for T be binary Tree for t be Element of T holds t is FinSequence of BOOLEAN
proof
  let T be binary Tree;
  let t be Element of T;
  defpred P[FinSequence] means $1 is Element of T implies rng $1 c= BOOLEAN;
  rng <*>NAT = {} by RELAT_1:60;
  then
A1: P[<*>NAT] by XBOOLE_1:2;
A2: for p be FinSequence of NAT for x be Element of NAT st
  P[p] holds P[p^<*x*>]
  proof
    let p be FinSequence of NAT;
    let x be Element of NAT;
    assume
A3: P[p];
    assume
A4: p^<*x*> is Element of T;
    then reconsider p1 = p as Element of T by TREES_1:46;
    p^<*x*> in { p^<*n*> where n is Element of NAT : p^<*n*> in T } by A4;
    then
A5: p^<*x*> in succ p1 by TREES_2:def 5;
    then not p in Leaves T by BINTREE1:5;
    then succ p1 = { p^<* 0 *>, p^<*1*> } by BINTREE1:def 2;
    then p^<*x*> = p^<* 0 *> or p^<*x*> = p^<*1*> by A5,TARSKI:def 2;
    then x = 0 or x = 1 by FINSEQ_2:20;
    then
A6: x in {0,1} by TARSKI:def 2;
A7: {x} c= BOOLEAN
    proof
      let z be set;
      assume z in {x};
      hence z in BOOLEAN by A6,TARSKI:def 1;
    end;
    rng <*x*> = {x} by FINSEQ_1:55;
    then (rng p) \/ (rng <*x*>) c= BOOLEAN by A3,A4,A7,TREES_1:46,XBOOLE_1:8;
    hence rng (p^<*x*>) c= BOOLEAN by FINSEQ_1:44;
  end;
  for p be FinSequence of NAT holds P[p] from FINSEQ_2:sch 2(A1,A2);
  then rng t c= BOOLEAN;
  hence t is FinSequence of BOOLEAN by FINSEQ_1:def 4;
end;

definition
  let T be binary Tree;
  redefine mode Element of T -> FinSequence of BOOLEAN;
  coherence by Th2;
end;

theorem Th3:
  for T be Tree st T = {0,1}* holds T is binary
proof
  let T be Tree;
  assume
A1: T = {0,1}*;
  now
    let t be Element of T;
    assume not t in Leaves T;
    { t^<*n*> where n is Element of NAT :
    t^<*n*> in T } = { t^<* 0 *>, t^<* 1 *> }
    proof
      thus {t^<*n*> where n is Element of NAT :
      t^<*n*> in T} c= { t^<* 0 *>, t^<* 1 *> }
      proof
        let x be set;
        assume x in { t^<*n*> where n is Element of NAT : t^<*n*> in T };
        then consider n be Element of NAT such that
A2:     x = t^<*n*> and
A3:     t^<*n*> in T;
        reconsider tn = t^<*n*> as FinSequence of ({0,1} qua set)
        by A1,A3,FINSEQ_1:def 11;
        len t + 1 in Seg (len t + 1) by FINSEQ_1:6;
        then len t + 1 in Seg len tn by FINSEQ_2:19;
        then len t + 1 in dom tn by FINSEQ_1:def 3;
        then tn/.(len t + 1) = (t^<*n*>).(len t + 1) by PARTFUN1:def 8
          .= n by FINSEQ_1:59;
        then n = 0 or n = 1 by TARSKI:def 2;
        hence x in { t^<* 0 *>, t^<* 1 *> } by A2,TARSKI:def 2;
      end;
      let x be set;
A4:   t is FinSequence of {0,1} by A1,FINSEQ_1:def 11;
      rng <* 0 *> c= {0,1}
      proof
        let z be set;
        assume z in rng <* 0 *>;
        then z in {0} by FINSEQ_1:55;
        then z = 0 by TARSKI:def 1;
        hence z in {0,1} by TARSKI:def 2;
      end;
      then
A5:   <* 0 *> is FinSequence of {0,1} by FINSEQ_1:def 4;
      rng <* 1 *> c= {0,1}
      proof
        let z be set;
        assume z in rng <* 1 *>;
        then z in {1} by FINSEQ_1:55;
        then z = 1 by TARSKI:def 1;
        hence z in {0,1} by TARSKI:def 2;
      end;
      then
A6:   <* 1 *> is FinSequence of {0,1} by FINSEQ_1:def 4;
      t^<* 0 *> is FinSequence of {0,1} by A4,A5,Lm1;
      then
A7:   t^<* 0 *> in T by A1,FINSEQ_1:def 11;
      t^<* 1 *> is FinSequence of {0,1} by A4,A6,Lm1;
      then
A8:   t^<* 1 *> in T by A1,FINSEQ_1:def 11;
      assume x in { t^<* 0 *>, t^<* 1 *> };
      then x = t^<* 0 *> or x = t^<* 1 *> by TARSKI:def 2;
      hence x in { t^<*n*> where n is Element of NAT : t^<*n*> in T } by A7,A8;
    end;
    hence succ t = { t^<* 0 *>, t^<* 1 *> } by TREES_2:def 5;
  end;
  hence T is binary by BINTREE1:def 2;
end;

theorem Th4:
  for T be Tree st T = {0,1}* holds Leaves T = {}
proof
  let T be Tree;
  assume
A1: T = {0,1}*;
  assume Leaves T <> {};
  then consider x be set such that
A2: x in Leaves T by XBOOLE_0:def 1;
  reconsider x1 = x as Element of T by A2;
  T is binary by A1,Th3;
  then
A3: x1 is FinSequence of BOOLEAN by Th2;
  then reconsider x1 = x as FinSequence of NAT;
  set y1 = x1 ^ <* 0 *>;
A4: 0 in {0} by TARSKI:def 1;
  {0} c= BOOLEAN
  proof
    let z be set;
    assume z in {0};
    then z = FALSE by TARSKI:def 1;
    hence z in BOOLEAN;
  end;
  then <* 0 *> is FinSequence of BOOLEAN by A4,Lm2;
  then y1 is FinSequence of BOOLEAN by A3,Lm1;
  then
A5: y1 in T by A1,FINSEQ_1:def 11;
  x1 is_a_proper_prefix_of y1 by TREES_1:31;
  hence contradiction by A2,A5,TREES_1:def 8;
end;

theorem
  for T be binary Tree for n be Element of NAT
  for t be Element of T st t in T-level n holds t is Tuple of n,BOOLEAN
proof
  let T be binary Tree;
  let n be Element of NAT;
  let t be Element of T;
  assume t in T-level n;
  then t in { w where w is Element of T : len w = n } by TREES_2:def 6;
  then ex t2 be Element of T st t2 = t & len t2 = n;
  hence t is Tuple of n,BOOLEAN by FINSEQ_2:110;
end;

theorem
  for T be Tree st
  for t be Element of T holds succ t = { t^<* 0 *>, t^<* 1 *> } holds
  Leaves T = {}
proof
  let T be Tree;
  assume
A1: for t be Element of T holds succ t = { t^<* 0 *>, t^<* 1 *> };
  assume Leaves T <> {};
  then consider x be set such that
A2: x in Leaves T by XBOOLE_0:def 1;
  reconsider t = x as Element of T by A2;
  succ t = { t^<* 0 *>, t^<* 1 *> } by A1;
  hence contradiction by A2,BINTREE1:5;
end;

theorem Th7:
  for T be Tree st
  for t be Element of T holds succ t = { t^<* 0 *>, t^<* 1 *> } holds
  T is binary
proof
  let T be Tree;
  assume for t be Element of T holds succ t = { t^<* 0 *>, t^<* 1 *> };
  then for t be Element of T st not t in Leaves T holds
  succ t = { t^<* 0 *>, t^<* 1 *> };
  hence T is binary by BINTREE1:def 2;
end;

theorem Th8:
  for T be Tree holds T = {0,1}* iff
  for t be Element of T holds succ t = { t^<* 0 *>, t^<* 1 *> }
proof
  let T be Tree;
  thus T = {0,1}* implies
  for t be Element of T holds succ t = { t^<* 0 *>, t^<* 1 *> }
  proof
    assume
A1: T = {0,1}*;
    then
A2: T is binary by Th3;
    let t be Element of T;
    not t in Leaves T by A1,Th4;
    hence succ t = { t^<* 0 *>, t^<* 1 *> } by A2,BINTREE1:def 2;
  end;
  assume
A3: for t be Element of T holds succ t = { t^<* 0 *>, t^<* 1 *> };
  thus T = {0,1}*
  proof
    thus T c= {0,1}*
    proof
      let x be set;
A4:   T is binary by A3,Th7;
      assume x in T;
      then x is FinSequence of {0,1} by A4,Th2;
      hence x in {0,1}* by FINSEQ_1:def 11;
    end;
    let x be set;
    assume x in {0,1}*;
    then
A5: x is FinSequence of {0,1} by FINSEQ_1:def 11;
    defpred P[FinSequence] means $1 in T;
A6: P[<*> {0,1}] by TREES_1:47;
A7: for p be FinSequence of {0,1}
    for n be Element of {0,1} st P[p] holds P[p^<*n*>]
    proof
      let p be FinSequence of {0,1};
      let n be Element of {0,1};
      assume p in T;
      then reconsider p1 = p as Element of T;
A8:   succ p1 = { p1^<* 0 *>, p1^<* 1 *> } by A3;
      n = 0 or n = 1 by TARSKI:def 2;
      then p^<*n*> in succ p1 by A8,TARSKI:def 2;
      hence p^<*n*> in T;
    end;
    for p be FinSequence of {0,1} holds P[p] from FINSEQ_2:sch 2(A6,A7);
    hence x in T by A5;
  end;
end;

scheme DecoratedBinTreeEx {A() -> non empty set, a() -> Element of A(),
  P[set,set,set]}:
  ex D be binary DecoratedTree of A() st dom D = {0,1}* & D.{} = a() &
  for x be Node of D holds P[D.x,D.(x ^ <* 0 *>),D.(x ^ <*1*>)]
provided
A1: for a be Element of A() ex b,c be Element of A() st P[a,b,c]
proof
  defpred Q[set,set] means ex b,c be Element of A() st P[$1,b,c] & $2 = [b,c];
A2: for e be set st e in A() ex u be set st u in [:A(),A():] & Q[e,u]
  proof
    let e be set;
    assume e in A();
    then consider b,c be Element of A() such that
A3: P[e,b,c] by A1;
    take u = [b,c];
    thus u in [:A(),A():];
    thus Q[e,u] by A3;
  end;
  consider f be Function such that
A4: dom f = A() and
A5: rng f c= [:A(),A():] and
A6: for e be set st e in A() holds Q[e,f.e] from WELLORD2:sch 1(A2);
  deffunc F(set) = IFEQ($1`2,0,(f.($1`1))`1,(f.($1`1))`2);
A7: for x be set st x in [:A(),NAT:] holds F(x) in A()
  proof
    let x be set;
    assume x in [:A(),NAT:];
    then x`1 in A() by MCART_1:10;
    then f.(x`1) in rng f by A4,FUNCT_1:def 5;
    then
A8: (f.(x`1))`1 in A() & (f.(x`1))`2 in A() by A5,MCART_1:10;
    now per cases;
      suppose x`2 = 0;
        hence IFEQ(x`2,0,(f.(x`1))`1,(f.(x`1))`2) in A() by A8,FUNCOP_1:def 8;
      end;
      suppose x`2 <> 0;
        hence IFEQ(x`2,0,(f.(x`1))`1,(f.(x`1))`2) in A() by A8,FUNCOP_1:def 8;
      end;
    end;
    hence IFEQ(x`2,0,(f.(x`1))`1,(f.(x`1))`2) in A();
  end;
  consider F be Function of [:A(),NAT:],A() such that
A9: for x be set st x in [:A(),NAT:] holds F.x = F(x) from FUNCT_2:sch 2 (A7);
A10: for e be set st e in A() holds P[e,F.(e,0),F.(e,1)]
  proof
    let e be set;
    assume
A11: e in A();
    then consider b,c be Element of A() such that
A12: P[e,b,c] and
A13: f.e = [b,c] by A6;
A14: [e,0]`2 = 0 by MCART_1:7;
    [e,0] in [:A(),NAT:] by A11,ZFMISC_1:106;
    then
A15: F.[e,0] = IFEQ([e,0]`2,0,(f.([e,0]`1))`1,(f.([e,0]`1))`2) by A9
      .= (f.([e,0]`1))`1 by A14,FUNCOP_1:def 8
      .= (f.e)`1 by MCART_1:7
      .= b by A13,MCART_1:7;
A16: [e,1]`2 = 1 & 1 <> 0 by MCART_1:7;
    [e,1] in [:A(),NAT:] by A11,ZFMISC_1:106;
    then F.[e,1] = IFEQ([e,1]`2,0,(f.([e,1]`1))`1,(f.([e,1]`1))`2) by A9
      .= (f.([e,1]`1))`2 by A16,FUNCOP_1:def 8
      .= (f.e)`2 by MCART_1:7
      .= c by A13,MCART_1:7;
    hence P[e,F.(e,0),F.(e,1)] by A12,A15;
  end;
  deffunc F(set) = 2;
  consider D be DecoratedTree of A() such that
A17: D.{} = a() and
A18: for d be Element of dom D holds
  succ d = { d^<*k*> where k is Element of NAT : k < F(D.d) } &
  for n be Element of NAT st n < F(D.d)
  holds D.(d^<*n*>) = F.(D.d,n) from TREES_2:sch 9;
  now
    let t be Element of dom D;
    assume not t in Leaves dom D;
    { t^<*k*> where k is Element of NAT : k < 2 } = { t^<* 0 *>, t^<* 1 *> }
    proof
      thus { t^<*k*> where k is Element of NAT : k < 2 }
      c= { t^<* 0 *>, t^<* 1 *> }
      proof
        let v be set;
        assume v in { t^<*k*> where k is Element of NAT : k < 2 };
        then consider k be Element of NAT such that
A19:    v = t^<*k*> and
A20:    k < 2;
        k = 0 or k = 1 by A20,NAT_1:23;
        hence v in { t^<* 0 *>, t^<* 1 *> } by A19,TARSKI:def 2;
      end;
      let v be set;
      assume v in { t^<* 0 *>, t^<* 1 *> };
      then v = t^<* 0 *> or v = t^<* 1 *> by TARSKI:def 2;
      hence v in { t^<*k*> where k is Element of NAT : k < 2 };
    end;
    hence succ t = { t^<* 0 *>, t^<* 1 *> } by A18;
  end;
  then dom D is binary by BINTREE1:def 2;
  then reconsider D as binary DecoratedTree of A() by BINTREE1:def 3;
  take D;
  now
    let t be Element of dom D;
    { t^<*k*> where k is Element of NAT : k < 2 } = { t^<* 0 *>, t^<* 1 *> }
    proof
      thus { t^<*k*> where k is Element of NAT : k < 2 }
      c= { t^<* 0 *>, t^<* 1 *> }
      proof
        let v be set;
        assume v in { t^<*k*> where k is Element of NAT : k < 2 };
        then consider k be Element of NAT such that
A21:    v = t^<*k*> and
A22:    k < 2;
        k = 0 or k = 1 by A22,NAT_1:23;
        hence v in { t^<* 0 *>, t^<* 1 *> } by A21,TARSKI:def 2;
      end;
      let v be set;
      assume v in { t^<* 0 *>, t^<* 1 *> };
      then v = t^<* 0 *> or v = t^<* 1 *> by TARSKI:def 2;
      hence v in { t^<*k*> where k is Element of NAT : k < 2 };
    end;
    hence succ t = { t^<* 0 *>, t^<* 1 *> } by A18;
  end;
  hence dom D = {0,1}* by Th8;
  thus D.{} = a() by A17;
  let x be Node of D;
  P[D.x,F.(D.x,0),F.(D.x,1)] by A10;
  then P[D.x,D.(x ^ <* 0 *>),F.(D.x,1)] by A18;
  hence P[D.x,D.(x ^ <* 0 *>),D.(x ^ <* 1 *>)] by A18;
end;

scheme DecoratedBinTreeEx1 {A() -> non empty set, a() -> Element of A(),
  P[set,set], Q[set,set]}:
  ex D be binary DecoratedTree of A() st dom D = {0,1}* & D.{} = a() &
  for x be Node of D holds P[D.x,D.(x ^ <* 0 *>)] & Q[D.x,D.(x ^ <*1*>)]
provided
A1: for a be Element of A() ex b be Element of A() st P[a,b]
and
A2: for a be Element of A() ex b be Element of A() st Q[a,b]
proof
  defpred P1[set,set] means
  ( $1`2 = 0 implies P[$1`1,$2] ) & ( $1`2 = 1 implies Q[$1`1,$2] );
A3: for e be set st e in [:A(),NAT:] ex u be set st u in A() & P1[e,u]
  proof
    let e be set;
    assume e in [:A(),NAT:];
    then reconsider e1 = e`1 as Element of A() by MCART_1:10;
    consider u1 be Element of A() such that
A4: P[e1,u1] by A1;
    consider u2 be Element of A() such that
A5: Q[e1,u2] by A2;
    take u = IFEQ(e`2,0,u1,u2);
    thus u in A();
    thus e`2 = 0 implies P[e`1,u] by A4,FUNCOP_1:def 8;
    thus e`2 = 1 implies Q[e`1,u] by A5,FUNCOP_1:def 8;
  end;
  consider F be Function such that
A6: dom F = [:A(),NAT:] and
A7: rng F c= A() and
A8: for e be set st e in [:A(),NAT:] holds P1[e,F.e] from WELLORD2:sch 1(A3);
  reconsider F as Function of [:A(),NAT:],A() by A6,A7,FUNCT_2:4;
  deffunc F(set) = 2;
  consider D be DecoratedTree of A() such that
A9: D.{} = a() and
A10: for d be Element of dom D holds
  succ d = { d^<*k*> where k is Element of NAT : k < F(D.d) } &
  for n be Element of NAT st n < F(D.d) holds D.(d^<*n*>) = F.(D.d,n)
  from TREES_2:sch 9;
  now
    let t be Element of dom D;
    assume not t in Leaves dom D;
    { t^<*k*> where k is Element of NAT : k < 2 } = { t^<* 0 *>, t^<* 1 *> }
    proof
      thus { t^<*k*> where k is Element of NAT : k < 2 }
      c= { t^<* 0 *>, t^<* 1 *> }
      proof
        let v be set;
        assume v in { t^<*k*> where k is Element of NAT : k < 2 };
        then consider k be Element of NAT such that
A11:    v = t^<*k*> and
A12:    k < 2;
        k = 0 or k = 1 by A12,NAT_1:23;
        hence v in { t^<* 0 *>, t^<* 1 *> } by A11,TARSKI:def 2;
      end;
      let v be set;
      assume v in { t^<* 0 *>, t^<* 1 *> };
      then v = t^<* 0 *> or v = t^<* 1 *> by TARSKI:def 2;
      hence v in { t^<*k*> where k is Element of NAT : k < 2 };
    end;
    hence succ t = { t^<* 0 *>, t^<* 1 *> } by A10;
  end;
  then dom D is binary by BINTREE1:def 2;
  then reconsider D as binary DecoratedTree of A() by BINTREE1:def 3;
  take D;
  now
    let t be Element of dom D;
    { t^<*k*> where k is Element of NAT : k < 2 } = { t^<* 0 *>, t^<* 1 *> }
    proof
      thus { t^<*k*> where k is Element of NAT : k < 2 }
      c= { t^<* 0 *>, t^<* 1 *> }
      proof
        let v be set;
        assume v in { t^<*k*> where k is Element of NAT : k < 2 };
        then consider k be Element of NAT such that
A13:    v = t^<*k*> and
A14:    k < 2;
        k = 0 or k = 1 by A14,NAT_1:23;
        hence v in { t^<* 0 *>, t^<* 1 *> } by A13,TARSKI:def 2;
      end;
      let v be set;
      assume v in { t^<* 0 *>, t^<* 1 *> };
      then v = t^<* 0 *> or v = t^<* 1 *> by TARSKI:def 2;
      hence v in { t^<*k*> where k is Element of NAT : k < 2 };
    end;
    hence succ t = { t^<* 0 *>, t^<* 1 *> } by A10;
  end;
  hence dom D = {0,1}* by Th8;
  thus D.{} = a() by A9;
  let x be Node of D;
  [D.x,0]`2 = 0 by MCART_1:7;
  then P[[D.x,0]`1,F.[D.x,0]] by A8;
  then P[D.x,F.(D.x,0)] by MCART_1:7;
  hence P[D.x,D.(x ^ <* 0 *>)] by A10;
  [D.x,1]`2 = 1 by MCART_1:7;
  then Q[[D.x,1]`1,F.[D.x,1]] by A8;
  then Q[D.x,F.(D.x,1)] by MCART_1:7;
  hence Q[D.x,D.(x ^ <* 1 *>)] by A10;
end;

Lm3: for D be non empty set for f be FinSequence of D holds
Rev f is FinSequence of D;

definition
  let T be binary Tree;
  let n be non empty Nat;
  func NumberOnLevel(n,T) -> Function of T-level n,NAT means
  :Def1:
  for t be Element of T st t in T-level n
  for F be Tuple of n,BOOLEAN st F = Rev t holds it.t = (Absval F) + 1;
  existence
  proof
    defpred P[set,set] means ex t be Element of T st t = $1 &
    for F be Tuple of n,BOOLEAN st F = Rev t holds $2 = (Absval F) + 1;
A1: for e be set st e in T-level n ex u be set st u in NAT & P[e,u]
    proof
      let e be set;
      assume e in T-level n;
      then e in { w where w is Element of T : len w = n } by TREES_2:def 6;
      then consider t be Element of T such that
A2:   t = e and
A3:   len t = n;
      len Rev t = n by A3,FINSEQ_5:def 3;
      then reconsider F1 = Rev t as Tuple of n,BOOLEAN by FINSEQ_2:110;
      take u = (Absval F1) + 1;
      thus u in NAT;
      take t;
      thus t = e by A2;
      let F be Tuple of n,BOOLEAN;
      assume F = Rev t;
      hence u = (Absval F) + 1;
    end;
    consider f be Function such that
A4: dom f = T-level n and
A5: rng f c= NAT and
A6: for e be set st e in T-level n holds P[e,f.e] from WELLORD2:sch 1(A1);
    reconsider f as Function of T-level n,NAT by A4,A5,FUNCT_2:4;
    take f;
    let t be Element of T;
    assume t in T-level n;
    then consider t1 be Element of T such that
A7: t1 = t and
A8: for F be Tuple of n,BOOLEAN st F = Rev t1 holds f.t = (Absval F) + 1
    by A6;
    let F be Tuple of n,BOOLEAN;
    assume F = Rev t;
    hence f.t = (Absval F) + 1 by A7,A8;
  end;
  uniqueness
  proof
    let f1,f2 be Function of T-level n,NAT such that
A9: for t be Element of T st t in T-level n
    for F be Tuple of n,BOOLEAN st F = Rev t holds f1.t = (Absval F) + 1 and
A10: for t be Element of T st t in T-level n
    for F be Tuple of n,BOOLEAN st F = Rev t holds f2.t = (Absval F) + 1;
    now
      let x be set;
      assume
A11:  x in T-level n;
      then x in { w where w is Element of T : len w = n } by TREES_2:def 6;
      then consider t be Element of T such that
A12:  t = x and
A13:  len t = n;
      len Rev t = n by A13,FINSEQ_5:def 3;
      then reconsider F = Rev t as Tuple of n,BOOLEAN by FINSEQ_2:110;
      thus f1.x = (Absval F) + 1 by A9,A11,A12
        .= f2.x by A10,A11,A12;
    end;
    hence f1 = f2 by FUNCT_2:18;
  end;
end;

registration
  let T be binary Tree;
  let n be non empty Element of NAT;
  cluster NumberOnLevel(n,T) -> one-to-one;
  coherence
  proof
    now
      let x1,x2 be set;
      assume that
A1:   x1 in dom NumberOnLevel(n,T) and
A2:   x2 in dom NumberOnLevel(n,T) and
A3:   NumberOnLevel(n,T).x1 = NumberOnLevel(n,T).x2;
A4:   x1 in T-level n by A1,FUNCT_2:def 1;
      then x1 in { w where w is Element of T : len w = n } by TREES_2:def 6;
      then consider t1 be Element of T such that
A5:   t1 = x1 and
A6:   len t1 = n;
      len Rev t1 = n by A6,FINSEQ_5:def 3;
      then reconsider F1 = Rev t1 as Tuple of n,BOOLEAN by FINSEQ_2:110;
A7:   x2 in T-level n by A2,FUNCT_2:def 1;
      then x2 in { w where w is Element of T : len w = n } by TREES_2:def 6;
      then consider t2 be Element of T such that
A8:   t2 = x2 and
A9:   len t2 = n;
      len Rev t2 = n by A9,FINSEQ_5:def 3;
      then reconsider F2 = Rev t2 as Tuple of n,BOOLEAN by FINSEQ_2:110;
      (Absval F1) + 1 = NumberOnLevel(n,T).x1 by A4,A5,Def1
        .= (Absval F2) + 1 by A3,A7,A8,Def1;
      hence x1 = x2 by A5,A8,BINARI_3:2,3;
    end;
    hence NumberOnLevel(n,T) is one-to-one by FUNCT_1:def 8;
  end;
end;

begin :: Full Trees

definition
  let T be Tree;
  attr T is full means
  :Def2:
  T = {0,1}*;
end;

theorem Th9:
  {0,1}* is Tree
proof
  set X = {0,1}*;
A1: X c= NAT* by FINSEQ_1:83;
A2: now
    let p be FinSequence of NAT;
    assume
A3: p in X;
    thus ProperPrefixes p c= X
    proof
      let y be set;
      assume y in ProperPrefixes p;
      then consider q be FinSequence such that
A4:   y = q and
A5:   q is_a_proper_prefix_of p by TREES_1:def 4;
      q is_a_prefix_of p by A5,XBOOLE_0:def 8;
      then consider n be Element of NAT such that
A6:   q = p|Seg n by TREES_1:def 1;
      thus y in X by A3,A4,A6,Th1;
    end;
  end;
  now
    let p be FinSequence of NAT, k,n be Element of NAT;
    assume that
A7: p^<*k*> in X and
A8: n <= k;
A9: p^<*k*> is FinSequence of {0,1} by A7,FINSEQ_1:def 11;
    then
A10: p is FinSequence of {0,1} & <*k*> is FinSequence of {0,1} by FINSEQ_1:50;
    reconsider kk = <*k*> as FinSequence of {0,1} by A9,FINSEQ_1:50;
    1 in Seg 1 by FINSEQ_1:5;
    then 1 in dom <*k*> by FINSEQ_1:55;
    then kk.1 in {0,1} by FINSEQ_2:13;
    then
A11: k in {0,1} by FINSEQ_1:57;
    now per cases by A11,TARSKI:def 2;
      suppose k = 0;
        hence n = 0 or n = 1 by A8;
      end;
      suppose
A12:    k = 1;
        n = 1 or n = 0
        proof
          assume n <> 1;
          then n < 0 + 1 by A8,A12,XXREAL_0:1;
          then n <= 0 by NAT_1:13;
          hence n = 0;
        end;
        hence n = 0 or n = 1;
      end;
    end;
    then n in {0,1} by TARSKI:def 2;
    then <*n*> is FinSequence of {0,1} by Lm2;
    then p^<*n*> is FinSequence of {0,1} by A10,Lm1;
    hence p^<*n*> in X by FINSEQ_1:def 11;
  end;
  hence {0,1}* is Tree by A1,A2,TREES_1:def 5;
end;

theorem Th10:
  for T be Tree st T = {0,1}* for n be Nat holds 0*n in T-level n
proof
  let T be Tree;
  assume
A1: T = {0,1}*;
  let n be Nat;
A2: len (0*n) = n by FINSEQ_2:109;
  0*n in T by A1,BINARI_3:5;
  then 0*n in { w where w is Element of T : len w = n } by A2;
  hence 0*n in T-level n by TREES_2:def 6;
end;

theorem Th11:
  for T be Tree st T = {0,1}* for n be non empty Element of NAT
  for y be Tuple of n,BOOLEAN holds y in T-level n
proof
  let T be Tree;
  assume
A1: T = {0,1}*;
  let n be non empty Element of NAT;
  let y be Tuple of n,BOOLEAN;
A2: len y = n by FINSEQ_2:109;
  y in T by A1,FINSEQ_1:def 11;
  then y in { w where w is Element of T : len w = n } by A2;
  hence y in T-level n by TREES_2:def 6;
end;

registration
  let T be binary Tree;
  let n be Element of NAT;
  cluster T-level n -> finite;
  coherence by QC_LANG4:19;
end;

registration
  cluster full -> binary Tree;
  coherence
  proof
    let T be Tree;
    assume T is full;
    then T = {0,1}* by Def2;
    hence T is binary by Th3;
  end;
end;

registration
  cluster full Tree;
  existence
  proof
    reconsider T = {0,1}* as Tree by Th9;
    take T;
    thus T is full by Def2;
  end;
end;

theorem Th12:
  for T be full Tree for n be non empty Nat holds
  Seg (2 to_power n) c= rng NumberOnLevel(n,T)
proof
  let T be full Tree;
  let n be non empty Nat;
  let y be set;
  assume y in Seg (2 to_power n);
  then y in { k where k is Element of NAT : 1 <= k & k <= 2 to_power n }
  by FINSEQ_1:def 1;
  then consider k be Element of NAT such that
A1: k = y and
A2: 1 <= k and
A3: k <= 2 to_power n;
  set t = Rev (n-BinarySequence (k-'1));
  T = {0,1}* by Def2;
  then
A4: t in T by FINSEQ_1:def 11;
A5: len t = len (n-BinarySequence (k-'1)) by FINSEQ_5:def 3
    .= n by FINSEQ_2:109;
  then t in { w where w is Element of T : len w = n } by A4;
  then
A6: t in T-level n by TREES_2:def 6;
  then
A7: t in dom NumberOnLevel(n,T) by FUNCT_2:def 1;
  len Rev t = n by A5,FINSEQ_5:def 3;
  then reconsider F = Rev t as Tuple of n,BOOLEAN by FINSEQ_2:110;
A8: k - 1 >= 1 - 1 by A2,XREAL_1:11;
  k < 2 to_power n + 1 by A3,NAT_1:13;
  then k - 1 < 2 to_power n by XREAL_1:21;
  then
A9: k-'1 < 2 to_power n by A8,XREAL_0:def 2;
  NumberOnLevel(n,T).t = (Absval F) + 1 by A6,Def1
    .= (Absval (n-BinarySequence (k-'1))) + 1 by FINSEQ_6:29
    .= k -' 1 + 1 by A9,BINARI_3:36
    .= k - 1 + 1 by A8,XREAL_0:def 2
    .= y by A1;
  hence y in rng NumberOnLevel(n,T) by A7,FUNCT_1:def 5;
end;

definition
  let T be full Tree;
  let n be non empty Nat;
  func FinSeqLevel(n,T) -> FinSequence of T-level n equals
  NumberOnLevel(n,T)";
  coherence
  proof
    T = {0,1}* by Def2;
    then
A1: T-level n is non empty by Th10;
    reconsider k=n as non empty Element of NAT by ORDINAL1:def 13;
A2: rng (NumberOnLevel(k,T)") = dom NumberOnLevel(k,T) by FUNCT_1:55
      .= T-level n by FUNCT_2:def 1;
    for y be set holds y in Seg (2 to_power n) iff
    ex x be set st x in dom NumberOnLevel(k,T) & y = NumberOnLevel(k,T).x
    proof
      let y be set;
      thus y in Seg (2 to_power n) implies
      ex x be set st x in dom NumberOnLevel(k,T) & y = NumberOnLevel(k,T).x
      proof
        assume
A3:     y in Seg (2 to_power n);
        take x = (NumberOnLevel(n,T)").y;
        Seg (2 to_power n) c= rng NumberOnLevel(n,T) by Th12;
        hence x in dom NumberOnLevel(k,T) & y = NumberOnLevel(k,T).x
        by A3,FUNCT_1:54;
      end;
      given x be set such that
A4:   x in dom NumberOnLevel(k,T) and
A5:   y = NumberOnLevel(k,T).x;
A6:   x in T-level n by A4,FUNCT_2:def 1;
      then x in { t where t is Element of T : len t = n } by TREES_2:def 6;
      then consider t be Element of T such that
A7:   t = x and
A8:   len t = n;
      len Rev t = n by A8,FINSEQ_5:def 3;
      then reconsider F = Rev t as Tuple of n,BOOLEAN by FINSEQ_2:110;
A9:   y = (Absval F) + 1 by A5,A6,A7,Def1;
A10:  1 <= (Absval F) + 1 by NAT_1:11;
      Absval F < 2 to_power n by BINARI_3:1;
      then (Absval F) + 1 <= 2 to_power n by NAT_1:13;
      hence y in Seg (2 to_power n) by A9,A10,FINSEQ_1:3;
    end;
    then rng NumberOnLevel(n,T) = Seg (2 to_power n) by FUNCT_1:def 5;
    then dom (NumberOnLevel(k,T)") = Seg (2 to_power n) by FUNCT_1:55;
    then NumberOnLevel(n,T)" is Function of Seg (2 to_power n), T-level n
    by A2,FUNCT_2:4;
    hence NumberOnLevel(n,T)" is FinSequence of T-level n by A1,FINSEQ_2:28;
  end;
end;

registration
  let T be full Tree;
  let n be non empty Element of NAT;
  cluster FinSeqLevel(n,T) -> one-to-one;
  coherence by FUNCT_1:62;
end;

theorem Th13:
  for T be full Tree for n be non empty Element of NAT holds
  NumberOnLevel(n,T).(0*n) = 1
proof
  let T be full Tree;
A1: T = {0,1}* by Def2;
  let n be non empty Element of NAT;
A2: 0*n is Element of T by A1,BINARI_3:5;
A3: 0*n in T-level n by A1,Th10;
A4: Rev (0*n) is FinSequence of BOOLEAN by A2,Lm3;
  len Rev (0*n) = len 0*n by FINSEQ_5:def 3
    .= n by FINSEQ_2:109;
  then reconsider F = Rev (0*n) as Tuple of n,BOOLEAN by A4,FINSEQ_2:110;
  thus NumberOnLevel(n,T).(0*n) = (Absval F) + 1 by A3,Def1
    .= 0 + 1 by BINARI_3:7,9
    .= 1;
end;

theorem Th14:
  for T be full Tree for n be non empty Element of NAT
  for y be Tuple of n,BOOLEAN st y = 0*n holds
  NumberOnLevel(n,T).'not' y = 2 to_power n
proof
  let T be full Tree;
A1: T = {0,1}* by Def2;
  let n be non empty Element of NAT;
  let y be Tuple of n,BOOLEAN;
  assume
A2: y = 0*n;
A3: 'not' y in T-level n by A1,Th11;
  len Rev 'not' y = len 'not' y by FINSEQ_5:def 3
    .= n by FINSEQ_2:109;
  then reconsider F = Rev 'not' y as Tuple of n,BOOLEAN by FINSEQ_2:110;
A4: Rev 'not' y = 'not' y by A2,BINARI_3:10;
  thus NumberOnLevel(n,T).'not' y = (Absval F) + 1 by A3,Def1
    .= 2 to_power n - 1 + 1 by A2,A4,BINARI_3:8
    .= 2 to_power n;
end;

theorem Th15:
  for T be full Tree for n be non empty Element of NAT holds
  FinSeqLevel(n,T).1 = 0*n
proof
  let T be full Tree;
A1: T = {0,1}* by Def2;
  let n be non empty Element of NAT;
  0*n in T-level n by A1,Th10;
  then
A2: 0*n in dom NumberOnLevel(n,T) by FUNCT_2:def 1;
  1 = NumberOnLevel(n,T).(0*n) by Th13;
  hence FinSeqLevel(n,T).1 = 0*n by A2,FUNCT_1:54;
end;

theorem Th16:
  for T be full Tree for n be non empty Element of NAT
  for y be Tuple of n,BOOLEAN st y = 0*n holds
  FinSeqLevel(n,T).(2 to_power n) = 'not' y
proof
  let T be full Tree;
A1: T = {0,1}* by Def2;
  let n be non empty Element of NAT;
  let y be Tuple of n,BOOLEAN;
  assume
A2: y = 0*n;
  'not' y in T-level n by A1,Th11;
  then
A3: 'not' y in dom NumberOnLevel(n,T) by FUNCT_2:def 1;
  2 to_power n = NumberOnLevel(n,T).'not' y by A2,Th14;
  hence FinSeqLevel(n,T).(2 to_power n) = 'not' y by A3,FUNCT_1:54;
end;

theorem Th17:
  for T be full Tree for n be non empty Element of NAT
  for i be Element of NAT st i in Seg (2 to_power n) holds
  FinSeqLevel(n,T).i = Rev (n-BinarySequence (i-'1))
proof
  let T be full Tree;
  let n be non empty Element of NAT;
  let i be Element of NAT;
  assume i in Seg (2 to_power n);
  then
A1: 1 <= i & i <= 2 to_power n by FINSEQ_1:3;
  set nB = n-BinarySequence (i-'1);
A2: len Rev nB = len nB by FINSEQ_5:def 3
    .= n by FINSEQ_2:109;
  then reconsider RnB = Rev nB as Tuple of n,BOOLEAN by FINSEQ_2:110;
  RnB in {0,1}* by FINSEQ_1:def 11;
  then RnB is Element of T by Def2;
  then RnB in { t where t is Element of T : len t = n } by A2;
  then
A3: RnB in T-level n by TREES_2:def 6;
  nB = Rev RnB by FINSEQ_6:29;
  then
A4: NumberOnLevel(n,T).RnB = (Absval nB) + 1 by A3,Def1;
A5: RnB in dom NumberOnLevel(n,T) by A3,FUNCT_2:def 1;
  i < 2 to_power n + 1 by A1,NAT_1:13;
  then i - 1 < 2 to_power n by XREAL_1:21;
  then i-'1 < 2 to_power n by A1,XREAL_1:235;
  then (Absval nB) + 1 = i-'1 + 1 by BINARI_3:36
    .= i - 1 + 1 by A1,XREAL_1:235
    .= i;
  hence FinSeqLevel(n,T).i = Rev (n-BinarySequence (i-'1))
  by A4,A5,FUNCT_1:54;
end;

theorem Th18:
  for T be full Tree for n be Element of NAT holds
  Card (T-level n) = 2 to_power n
proof
  let T be full Tree;
A1: T = {0,1}* by Def2;
  defpred R[Element of NAT] means Card (T-level $1) = 2 to_power $1;
  Card (T-level 0) = card {{}} by QC_LANG4:17
    .= 1 by CARD_1:50
    .= 2 to_power 0 by POWER:29;
  then
A2: R[0];
A3: for n be Element of NAT st R[n] holds R[n+1]
  proof
    let n be Element of NAT;
    assume
A4: Card (T-level n) = 2 to_power n;
    set Tn10 = { p where p is Element of T : len p = n+1 & p.(n+1) = 0 };
    set Tn11 = { p where p is Element of T : len p = n+1 & p.(n+1) = 1 };
A5: len 0*(n+1) = n+1 by FINSEQ_2:109;
A6: 0*(n+1) in T by A1,BINARI_3:5;
    (0*(n+1)).(n+1) = 0 by FINSEQ_1:6,FUNCOP_1:13;
    then
A7: 0*(n+1) in Tn10 by A5,A6;
A8: len (0*n^<*1*>) = len 0*n + 1 by FINSEQ_2:19
      .= n+1 by FINSEQ_2:109;
    0*n in {0,1}* by BINARI_3:5;
    then
A9: 0*n is FinSequence of {0,1} by FINSEQ_1:def 11;
    rng <*1*> c= {0,1}
    proof
      let z be set;
      assume z in rng <*1*>;
      then z in {1} by FINSEQ_1:55;
      then z = 1 by TARSKI:def 1;
      hence z in {0,1} by TARSKI:def 2;
    end;
    then
A10: <*1*> is FinSequence of {0,1} by FINSEQ_1:def 4;
    then 0*n^<*1*> is FinSequence of {0,1} by A9,Lm1;
    then
A11: 0*n^<*1*> in T by A1,FINSEQ_1:def 11;
    len 0*n = n by FINSEQ_2:109;
    then (0*n^<*1*>).(n+1) = 1 by FINSEQ_1:59;
    then
A12: 0*n^<*1*> in Tn11 by A8,A11;
A13: Tn10 c= T-level (n+1)
    proof
      let x be set;
      assume x in Tn10;
      then consider p be Element of T such that
A14:  p = x and
A15:  len p = n+1 and p.(n+1) = 0;
      p in { w where w is Element of T : len w = n+1 } by A15;
      hence x in T-level (n+1) by A14,TREES_2:def 6;
    end;
A16: Tn11 c= T-level (n+1)
    proof
      let x be set;
      assume x in Tn11;
      then consider p be Element of T such that
A17:  p = x and
A18:  len p = n+1 and p.(n+1) = 1;
      p in { w where w is Element of T : len w = n+1 } by A18;
      hence x in T-level (n+1) by A17,TREES_2:def 6;
    end;
    then reconsider Tn10,Tn11 as non empty finite set
    by A7,A12,A13;
A19: Tn10 \/ Tn11 c= T-level (n+1) by A13,A16,XBOOLE_1:8;
A20: T-level (n+1) c= Tn10 \/ Tn11
    proof
      let x be set;
      assume x in T-level (n+1);
      then x in { w where w is Element of T : len w = n+1 } by TREES_2:def 6;
      then consider p be Element of T such that
A21:  p = x and
A22:  len p = n+1;
      x in Tn10 or x in Tn11
      proof
        assume
A23:    not x in Tn10;
        n+1 in Seg (n+1) by FINSEQ_1:6;
        then n+1 in dom p by A22,FINSEQ_1:def 3;
        then p.(n+1) in BOOLEAN by FINSEQ_2:13;
        then p.(n+1) = 0 or p.(n+1) = 1 by TARSKI:def 2;
        hence x in Tn11 by A21,A22,A23;
      end;
      hence x in Tn10 \/ Tn11 by XBOOLE_0:def 3;
    end;
A24: Tn10 misses Tn11
    proof
      assume Tn10 /\ Tn11 <> {};
      then consider x be set such that
A25:  x in Tn10 /\ Tn11 by XBOOLE_0:def 1;
A26:  x in Tn10 & x in Tn11 by A25,XBOOLE_0:def 4;
      then consider p1 be Element of T such that
A27:  p1 = x and len p1 = n+1 and
A28:  p1.(n+1) = 0;
      consider p2 be Element of T such that
A29:  p2 = x and len p2 = n+1 and
A30:  p2.(n+1) = 1 by A26;
      thus contradiction by A27,A28,A29,A30;
    end;
    reconsider Tn = T-level n as finite non empty set by A1,Th10;
    defpred P[set,set] means ex p be FinSequence st p = $1 & $2 = p^<* 0 *>;
A31: for x be Element of Tn ex y be Element of Tn10 st P[x,y]
    proof
      let x be Element of Tn;
      x in T-level n;
      then x in { w where w is Element of T : len w = n } by TREES_2:def 6;
      then consider p be Element of T such that
A32:  p = x and
A33:  len p = n;
      set y = p^<* 0 *>;
      rng <* 0 *> c= {0,1}
      proof
        let z be set;
        assume z in rng <* 0 *>;
        then z in {0} by FINSEQ_1:55;
        then z = 0 by TARSKI:def 1;
        hence z in {0,1} by TARSKI:def 2;
      end;
      then <* 0 *> is FinSequence of {0,1} by FINSEQ_1:def 4;
      then p^<* 0 *> is FinSequence of {0,1} by Lm1;
      then
A34:  y in T by A1,FINSEQ_1:def 11;
A35:  len y = n+1 by A33,FINSEQ_2:19;
      y.(n+1) = 0 by A33,FINSEQ_1:59;
      then y in { t where t is Element of T : len t = n+1 & t.(n+1) = 0 }
      by A34,A35;
      then reconsider y as Element of Tn10;
      take y,p;
      thus thesis by A32;
    end;
    defpred P1[set,set] means ex p be FinSequence st p = $1 & $2 = p^<* 1 *>;
A36: for x be Element of Tn ex y be Element of Tn11 st P1[x,y]
    proof
      let x be Element of Tn;
      x in T-level n;
      then x in { w where w is Element of T : len w = n } by TREES_2:def 6;
      then consider p be Element of T such that
A37:  p = x and
A38:  len p = n;
      set y = p^<*1*>;
      p^<*1*> is FinSequence of {0,1} by A10,Lm1;
      then
A39:  y in T by A1,FINSEQ_1:def 11;
A40:  len y = n+1 by A38,FINSEQ_2:19;
      y.(n+1) = 1 by A38,FINSEQ_1:59;
      then y in { t where t is Element of T : len t = n+1 & t.(n+1) = 1 }
      by A39,A40;
      then reconsider y as Element of Tn11;
      take y,p;
      thus thesis by A37;
    end;
    consider f0 be Function of Tn,Tn10 such that
A41: for x be Element of Tn holds P[x,f0.x] from FUNCT_2:sch 3(A31);
    consider f1 be Function of Tn,Tn11 such that
A42: for x be Element of Tn holds P1[x,f1.x] from FUNCT_2:sch 3(A36);
A43: Tn c= dom f0 by FUNCT_2:def 1;
    now
      let x1,x2 be set;
      assume that
A44:  x1 in dom f0 and
A45:  x2 in dom f0 and
A46:  f0.x1 = f0.x2;
      reconsider x1'= x1, x2'= x2 as Element of Tn by A44,A45,FUNCT_2:def 1;
      consider p1 be FinSequence such that
A47:  p1 = x1' and
A48:  f0.x1' = p1^<* 0 *> by A41;
      consider p2 be FinSequence such that
A49:  p2 = x2' and
A50:  f0.x2' = p2^<* 0 *> by A41;
      thus x1 = x2 by A46,A47,A48,A49,A50,FINSEQ_2:20;
    end;
    then f0 is one-to-one by FUNCT_1:def 8;
    then Tn,f0.:Tn are_equipotent by A43,CARD_1:60;
    then
A51: Tn,rng f0 are_equipotent by FUNCT_2:45;
    now
      let y be set;
      assume y in Tn10;
      then consider t be Element of T such that
A52:  t = y and
A53:  len t = n+1 and
A54:  t.(n+1) = 0;
      consider p be FinSequence of BOOLEAN, d be Element of BOOLEAN such that
A55:  t = p^<*d*> by A53,FINSEQ_2:22;
A56:  len p + 1 = n+1 by A53,A55,FINSEQ_2:19;
      reconsider x = p as set;
      take x;
      p in T by A1,FINSEQ_1:def 11;
      then
A57:  p in { w where w is Element of T : len w = n } by A56;
      hence x in Tn by TREES_2:def 6;
      reconsider x' = x as Element of Tn by A57,TREES_2:def 6;
      consider q be FinSequence such that
A58:  q = x' and
A59:  f0.x' = q^<* 0 *> by A41;
      thus y = f0.x by A52,A54,A55,A56,A58,A59,FINSEQ_1:59;
    end;
    then rng f0 = Tn10 by FUNCT_2:16;
    then
A60: card Tn = card Tn10 by A51,CARD_1:21;
A61: Tn c= dom f1 by FUNCT_2:def 1;
    now
      let x1,x2 be set;
      assume that
A62:  x1 in dom f1 and
A63:  x2 in dom f1 and
A64:  f1.x1 = f1.x2;
      reconsider x1'= x1, x2'= x2 as Element of Tn by A62,A63,FUNCT_2:def 1;
      consider p1 be FinSequence such that
A65:  p1 = x1' and
A66:  f1.x1' = p1^<*1*> by A42;
      consider p2 be FinSequence such that
A67:  p2 = x2' and
A68:  f1.x2' = p2^<*1*> by A42;
      thus x1 = x2 by A64,A65,A66,A67,A68,FINSEQ_2:20;
    end;
    then f1 is one-to-one by FUNCT_1:def 8;
    then Tn,f1.:Tn are_equipotent by A61,CARD_1:60;
    then
A69: Tn,rng f1 are_equipotent by FUNCT_2:45;
    now
      let y be set;
      assume y in Tn11;
      then consider t be Element of T such that
A70:  t = y and
A71:  len t = n+1 and
A72:  t.(n+1) = 1;
      consider p be FinSequence of BOOLEAN, d be Element of BOOLEAN such that
A73:  t = p^<*d*> by A71,FINSEQ_2:22;
A74:  len p + 1 = n+1 by A71,A73,FINSEQ_2:19;
      reconsider x = p as set;
      take x;
      p in T by A1,FINSEQ_1:def 11;
      then
A75:  p in { w where w is Element of T : len w = n } by A74;
      hence x in Tn by TREES_2:def 6;
      reconsider x' = x as Element of Tn by A75,TREES_2:def 6;
      consider q be FinSequence such that
A76:  q = x' and
A77:  f1.x' = q^<*1*> by A42;
      thus y = f1.x by A70,A72,A73,A74,A76,A77,FINSEQ_1:59;
    end;
    then
A78: rng f1 = Tn11 by FUNCT_2:16;
    thus 2 to_power (n+1) = 2 to_power n * 2 to_power 1 by POWER:32
      .= 2 * 2 to_power n by POWER:30
      .= card Tn + card Tn by A4
      .= card Tn10 + card Tn11 by A60,A69,A78,CARD_1:21
      .= card (Tn10 \/ Tn11) by A24,CARD_2:53
      .= Card (T-level (n+1)) by A19,A20,XBOOLE_0:def 10;
  end;
  thus for n be Element of NAT holds R[n] from NAT_1:sch 1(A2,A3);
end;

theorem Th19:
  for T be full Tree for n be non empty Element of NAT holds
  len FinSeqLevel(n,T) = 2 to_power n
proof
  let T be full Tree;
  let n be non empty Element of NAT;
  rng FinSeqLevel(n,T) = dom NumberOnLevel(n,T) by FUNCT_1:55
    .= T-level n by FUNCT_2:def 1;
  then
A1: dom FinSeqLevel(n,T),T-level n are_equipotent by WELLORD2:def 4;
  Card Seg len FinSeqLevel(n,T) = Card dom FinSeqLevel(n,T) by FINSEQ_1:def 3
    .= Card (T-level n) by A1,CARD_1:21
    .= 2 to_power n by Th18;
  hence thesis by FINSEQ_1:78;
end;

theorem Th20:
  for T be full Tree for n be non empty Element of NAT holds
  dom FinSeqLevel(n,T) = Seg (2 to_power n)
proof
  let T be full Tree;
  let n be non empty Element of NAT;
  thus dom FinSeqLevel(n,T) = Seg len FinSeqLevel(n,T) by FINSEQ_1:def 3
    .= Seg (2 to_power n) by Th19;
end;

theorem
  for T be full Tree for n be non empty Element of NAT holds
  rng FinSeqLevel(n,T) = T-level n
proof
  let T be full Tree;
A1: T = {0,1}* by Def2;
  let n be non empty Element of NAT;
  T-level n is non empty by A1,Th10;
  then reconsider p = FinSeqLevel(n,T) as
  Function of dom FinSeqLevel(n,T), T-level n by FINSEQ_2:30;
  reconsider dp = dom p as finite set;
  reconsider Tln = T-level n as finite set;
  card dp = Card Seg (2 to_power n) by Th20
    .= 2 to_power n by FINSEQ_1:78
    .= card Tln by Th18;
  hence rng FinSeqLevel(n,T) = T-level n by FINSEQ_4:78;
end;

theorem
  for T be full Tree holds FinSeqLevel(1,T).1 = <* 0 *>
proof
  let T be full Tree;
  thus FinSeqLevel(1,T).1 = 0*1 by Th15
    .= <* 0 *> by FINSEQ_2:73;
end;

theorem
  for T be full Tree holds FinSeqLevel(1,T).2 = <* 1 *>
proof
  let T be full Tree;
A1: 0*1 = <* FALSE *> by FINSEQ_2:73;
  thus FinSeqLevel(1,T).2 = FinSeqLevel(1,T).(2 to_power 1) by POWER:30
    .= <* 1 *> by A1,Th16,BINARI_3:15;
end;

theorem
  for T be full Tree
  for n,i be non empty Element of NAT st i <= 2 to_power (n+1)
  for F be Tuple of n,BOOLEAN st F = FinSeqLevel(n,T).((i+1) div 2) holds
  FinSeqLevel(n+1,T).i = F^<*(i+1) mod 2*>
proof
  let T be full Tree;
  let n,i be non empty Element of NAT;
  assume
A1: i <= 2 to_power (n+1);
  let F be Tuple of n,BOOLEAN;
  assume
A2: F = FinSeqLevel(n,T).((i+1) div 2);
A3: 1 <= i by NAT_1:14;
  then 1 + 1 <= i + 1 by XREAL_1:8;
  then
A4: 1 <= (i+1) div 2 by NAT_2:15;
  2 to_power (n+1) = (2 to_power n) * (2 to_power 1) by POWER:32
    .= 2 * (2 to_power n) by POWER:30;
  then (i+1) div 2 <= 2 to_power n by A1,NAT_2:27;
  then
A5: (i+1) div 2 in Seg (2 to_power n) by A4,FINSEQ_1:3;
A6: now per cases;
    suppose i-'1 is odd;
      then
A7:   i-'1 mod 2 = 1 by NAT_2:24;
      then i-'1 + (1+1)*1 mod 2 = 1 by NAT_D:21;
      then i-'1 + 1 + 1 mod 2 = 1;
      hence (i+1) mod 2 = (i-'1) mod 2 by A7,NAT_1:14,XREAL_1:237;
    end;
    suppose i-'1 is even;
      then
A8:   i-'1 mod 2 = 0 by NAT_2:23;
      then i-'1 + (1 + 1)*1 mod 2 = 0 by NAT_D:21;
      then i-'1 + 1 + 1 mod 2 = 0;
      hence (i+1) mod 2 = (i-'1) mod 2 by A8,NAT_1:14,XREAL_1:237;
    end;
  end;
  i + 1 >= 1 + 1 by A3,XREAL_1:8;
  then
A9: 1 <= (i + 1) div 2 by NAT_2:15;
A10: (i-'1) div 2 = (i-'1) div 2 + 1 - 1
    .= (i-'1 + (1 + 1)) div 2 - 1 by NAT_2:16
    .= ((i-'1 + 1 + 1) div 2) - 1
    .= ((i + 1) div 2) - 1 by NAT_1:14,XREAL_1:237
    .= ((i + 1) div 2) -' 1 by A9,XREAL_1:235;
  i in Seg (2 to_power (n+1)) by A1,A3,FINSEQ_1:3;
  hence FinSeqLevel(n+1,T).i = Rev ((n+1)-BinarySequence (i-'1)) by Th17
    .= Rev (<*(i-'1) mod 2*> ^ (n-BinarySequence ((i-'1) div 2)))
  by BINARI_3:35
    .= (Rev (n-BinarySequence (((i+1) div 2)-'1)))^<*(i+1) mod 2*>
  by A6,A10,FINSEQ_6:28
    .= F^<*(i+1) mod 2*> by A2,A5,Th17;
end;

