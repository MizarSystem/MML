:: Fundamental {T}heorem of {A}rithmetic
::  by Artur Korni{\l}owicz and Piotr Rudnicki
:: 
:: Received February 13, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabulary GROUP_1, ARYTM_3, ORDINAL2, ARYTM, POLYNOM1, FILTER_0, FUNCT_1,
      FINSEQ_1, ALGSEQ_1, CARD_3, FINSET_1, ARYTM_1, BOOLE, SEQM_3, PBOOLE,
      NAT_1, RELAT_1, NAT_LAT, FUNCOP_1, CARD_1, SEQ_1, REALSET1, SQUARE_1,
      FINSEQ_2, UPROOTS, VECTSP_1, FUNCT_2, SETWISEO, SGRAPH1, NAT_3;
 notation TARSKI, XBOOLE_0, SUBSET_1, FINSET_1, REALSET1, ORDINAL1, ORDINAL2,
      CARD_1, NUMBERS, XCMPLX_0, XREAL_0, REAL_1, NAT_1, INT_2, NEWTON,
      RELAT_1, FUNCT_1, FUNCT_2, FINSEQ_1, SEQ_1, SEQM_3, NAT_LAT, PBOOLE,
      POLYNOM1, POLYNOM2, RVSUM_1, WSIERP_1, BINARITH, TREES_4, UPROOTS,
      PRE_CIRC, VECTSP_1, SETWOP_2;
 constructors POLYNOM2, WSIERP_1, FINSOP_1, EULER_2, NAT_LAT, REAL_1, BINARITH,
      FINSEQOP, SEQ_2, DOMAIN_1, UPROOTS, PRE_CIRC, FACIRC_1, SETWISEO,
      BINOP_1;
 clusters XREAL_0, NAT_1, INT_1, POLYNOM1, RELSET_1, CARD_5, MEMBERED,
      BINARITH, PRE_CIRC, SEQ_1, RELAT_1, TEX_2, FINSET_1, CIRCCMB3, XCMPLX_0,
      FUNCT_1, NEWTON;
 requirements NUMERALS, SUBSET, ARITHM, REAL, BOOLE;
 definitions TARSKI, XBOOLE_0, INT_2, NAT_1, FINSEQ_1, SEQ_1, SEQM_3, POLYNOM1;
 theorems ORDINAL2, REAL_1, NEWTON, NAT_1, AXIOMS, XCMPLX_1, INT_1, CARD_4,
      XREAL_0, RVSUM_1, INT_2, CQC_THE1, PEPIN, PBOOLE, FUNCT_1, CARD_2,
      PREPOWER, POLYNOM1, FINSET_1, FINSEQ_1, TARSKI, NAT_LAT, XBOOLE_1,
      FUNCOP_1, CARD_1, WSIERP_1, XBOOLE_0, RADIX_1, AMI_5, BINARITH, BAGORDER,
      SEQ_1, FINSEQ_2, SEQM_3, FINSEQ_3, FINSEQ_4, JORDAN1A, REAL_2, RELAT_1,
      UPROOTS, PRE_CIRC, CIRCCMB3, FINSOP_1, FUNCT_2;
 schemes NAT_1, PRE_CIRC, GRAPH_2, FINSEQ_1, FINSEQ_2, MSUALG_1, FUNCT_1;

begin :: Preliminaries

reserve a, b, n for natural number,
        r for Real,
        f for FinSequence of REAL;

Seg1:
  for x being set st x in Seg n holds x is Nat;

registration
  let X be empty set;
  cluster card X -> empty;
coherence by CARD_1:47;
end;

registration
  cluster natural-yielding -> real-yielding Relation;
coherence
proof  
  let R be Relation;
  assume rng R c= NAT;
  hence rng R c= REAL by XBOOLE_1:1;
end;
end;

registration :: cirrcmb3
  cluster natural-yielding FinSequence;
 existence
 proof  
   consider f being FinSequence of NAT;
   take f;
   thus thesis;
 end;
 end;

registration
  let a be non empty natural number;
  let b be natural number;
  cluster a |^ b -> non empty;
coherence
proof  
  a is Real & b is Nat by XREAL_0:def 1,ORDINAL2:def 21;
  hence thesis by CARD_4:51;
end;
end;
  
registration
  cluster -> non empty Prime;
coherence
proof  
  let a be Prime;
  a > 1 by INT_2:def 5;
  then a > 0 by AXIOMS:22;
  hence thesis;
end;
end;

reserve p for Prime;

registration
  cluster SetPrimes -> infinite;
coherence by NAT_LAT:94;
end;

theorem t60:
for a, b, c, d being natural number st a divides c & b divides d
 holds a*b divides c*d
proof let a, b, c, d be natural number;  given x being Nat such that
a1: c = a*x;
  given y being Nat such that
a2: d = b*y;
  take x*y;
  thus c*d = a*b*(x*y) by a1,a2;
end;

theorem t1:
1 < a implies b <= a |^ b
proof  
  assume
c1: 1 < a;
  then reconsider a1 = a-1 as Nat by INT_1:18;
  defpred P[natural number] means $1 <= a |^ $1;
a1: P[0] by NAT_1:18;
a2: for k being natural number st P[k] holds P[k+1]
  proof  
    let k be natural number such that
a3:   P[k];
a4: k+1 <= a |^ k + 1 by a3,AXIOMS:24;
a5: a |^ (k+1) = a |^ k * a by NEWTON:11;
    now
a6:   a is Real by XREAL_0:def 1;
a7:   k is Nat by ORDINAL2:def 21;
      set x = a |^ k;
      assume x + 1 > x * a;
      then x*a - (x+1) < (x+1) - (x+1) by REAL_1:92;
      then x*a1 - 1 + 1 < 0+1 by REAL_1:53;
      then x*a1 <= 0 by NAT_1:38;
      then x*a1 = 0 by NAT_1:19;
      then x = 0 or a1 = 0 by XCMPLX_1:6;
      then x = 0 or a = 0+1;
      then a = 0 by c1,a6,a7,CARD_4:51;
      hence contradiction by c1;
    end;
    hence k+1 <= a |^ (k+1) by a4,a5,AXIOMS:22;
  end;
  for k being natural number holds P[k] from NAT_1:sch 2(a1,a2);
  hence b <= a |^ b;
end;

theorem t40:
a <> 0 implies n divides n |^ a
proof  
  assume a <> 0;
  then consider b being Nat such that
a1:  a = b+1 by NAT_1:22;
a2: n is Nat by ORDINAL2:def 21;
  1 <= b+1 by NAT_1:37;
  then n |^ 1 divides n |^ (b+1) by a2,RADIX_1:7;
  hence thesis by a1,NEWTON:10;
end;

theorem div1:
for i, j, m, n being natural number
 st i < j & m |^ j divides n holds m |^ (i+1) divides n
proof let i, j, m, n be natural number such that
A: i < j and
B: m |^ j divides n;
  reconsider i,j,m as Nat by ORDINAL2:def 21;
   i+1 <= j by A, NAT_1:38; then
   m |^ (i+1) divides m |^ j by RADIX_1:7;
 hence thesis by B, NAT_1:51;
end;

theorem t85:
p divides a |^ b implies p divides a
proof  
  assume that
a0: p divides a |^ b and
hh: not p divides a;
  reconsider a as Nat by ORDINAL2:def 21;
  defpred P[Nat] means p divides a|^($1+1);
  now
    assume 0+1 > b;
    then b <= 0 by NAT_1:38;
    then b = 0 by NAT_1:18;
    then p divides 1 by a0,NEWTON:9;
    then p = 1 by WSIERP_1:20;
    hence contradiction by INT_2:def 5;
  end;
  then b = b-'1+1 by AMI_5:4;
  then
a1: ex k being Nat st P[k] by a0;
a2: for k being Nat st k <> 0 & P[k] ex n being Nat st n < k & P[n]
  proof  
    let k be Nat such that
c4:   k <> 0 and
c5:   P[k];
    take k-'1;
    k > 0 by c4,NAT_1:19;
    then
e3: k >= 0+1 by NAT_1:38;
    then k-1 >= 0+1-1 by REAL_1:92;
    then k-'1 = k-1 by BINARITH:def 3;
    then k-'1 < k-0 by REAL_1:92;
    hence k-'1 < k;
c6: k-'1+1 = k by e3,AMI_5:4;
    p divides a |^ k * a by c5,NEWTON:11;
    hence P[k-'1] by c6,hh,NAT_LAT:95;
  end;
  P[0] from NAT_1:sch 7(a1,a2);
  hence thesis by hh,NEWTON:10;
end;
  
theorem t76:
for a being Prime st a divides p |^ b holds a = p
proof  
  let a be Prime such that
a1: a divides p |^ b;
z5: a <> 1 by INT_2:def 5;
  a divides p by a1,t85;
  hence a = p by z5,INT_2:def 5;
end;
  
theorem
for f being FinSequence of NAT st a in rng f holds a divides Product f
proof
  defpred P[FinSequence of NAT] means
   for a being natural number st a in rng $1 holds a divides Product $1;
A: P[<*>NAT];
B: for p being FinSequence of NAT, n being Nat st P[p] holds P[p^<*n*>] proof
    let p be FinSequence of NAT, n be Nat such that
   IH: P[p];
    set p1 = p^<*n*>;
    let a be natural number such that
   A1: a in rng p1;
   B1: rng p1 = rng p \/ rng <*n*> by FINSEQ_1:44;
   C1: Product p1 = Product p * n by RVSUM_1:126;
     per cases by A1, B1, XBOOLE_0:def 2;
     suppose a in rng p; then a divides Product p by IH;
      hence a divides Product p1 by C1, NAT_1:56;
    end;
     suppose a in rng <*n*>; then a in {n} by FINSEQ_1:56;
       then a = n by TARSKI:def 1;
      hence a divides Product p1 by C1, NAT_1:56;
    end;
   end;
  for p being FinSequence of NAT holds P[p] from FINSEQ_2:sch 2(A,B);
 hence thesis;
end;

theorem
for f being FinSequence of SetPrimes st p divides Product f holds p in rng f
proof
  defpred P[FinSequence of SetPrimes] means
   for p being Prime st p divides Product $1 holds p in rng $1;
A: P[<*>SetPrimes] proof
    let p being Prime; 
    assume p divides Product <*>SetPrimes; then
    p <= 1 by NAT_1:54,RVSUM_1:124;
    hence p in rng <*>SetPrimes by INT_2:def 5;
  end;
B: now let f be FinSequence of SetPrimes, n be Element of SetPrimes; assume
   IH: P[f];
   set f1 = f^<*n*>;
    thus P[f1] proof
     let p be Prime;
     assume
    B1: p divides Product f1;
        reconsider ff = f as FinSequence of NAT;
    A1:  p divides Product ff * n by B1, RVSUM_1:126;
     reconsider nn = n as Nat;      
     per cases by A1, NAT_LAT:95;
     suppose p divides Product f; then
     C1: p in rng f by IH;
         rng f c= rng f1 by FINSEQ_1:42;
      hence p in rng f1 by C1;
    end;
     suppose S1: p divides nn;
       nn is prime by NAT_LAT:def 17; then
       p = 1 or p = n by S1, INT_2:def 5; then
       p in {n} by INT_2:def 5,TARSKI:def 1; then
     C1: p in rng <*n*> by FINSEQ_1:55;
         rng <*n*> c= rng f1 by FINSEQ_1:43;
      hence p in rng f1 by C1;
    end;
    end;
   end;
   for p being FinSequence of SetPrimes holds P[p] from FINSEQ_2:sch 2(A,B);
  hence thesis;
end;

:: Power

definition
  let f be real-yielding FinSequence;
  let a be natural number;
  func f |^ a -> FinSequence means :defpr:
  len it = len f &
  for i being set st i in dom it holds it.i = f.i |^ a;
existence
proof  
  deffunc F(Nat) = f.$1 |^ a;
  consider p being FinSequence such that
a1: len p = len f and
a2: for k being Nat st k in Seg len f holds p.k = F(k) from FINSEQ_1:sch 2;
  take p;
  thus len p = len f by a1;
  dom p = Seg len p by FINSEQ_1:def 3;
  hence thesis by a2, a1;
end;
uniqueness
proof  
  let g,h be FinSequence such that
a1: len g = len f and
a2: for i being set st i in dom g holds g.i = f.i |^ a and
a3: len h = len f and
a4: for i being set st i in dom h holds h.i = f.i |^ a;
a5: dom g = Seg len g by FINSEQ_1:def 3;
a6: dom h = Seg len h by FINSEQ_1:def 3;
  for k being Nat st k in dom g holds g.k = h.k
  proof  
    let k be Nat such that
a7:   k in dom g;
    thus g.k = f.k |^ a by a2,a7
      .= h.k by a1,a3,a4,a5,a6,a7;
  end;
  hence g = h by a1,a3,a5,a6,FINSEQ_1:17;
end;
end;

registration
  let f be real-yielding FinSequence;
  let a be natural number;
  cluster f |^ a -> real-yielding;
coherence
proof  
  set g = f|^a;
  let y be set;
  assume y in rng g;
  then consider x being set such that
a1:  x in dom g & g.x = y by FUNCT_1:def 5;
  y = f.x |^ a by a1,defpr;
  hence y in REAL;
end;
end;

registration
  let f be natural-yielding FinSequence;
  let a be natural number;
  cluster f |^ a -> natural-yielding;
coherence
proof  
  set g = f|^a;
  let y be set;
  assume y in rng g;
  then consider x being set such that
a1:  x in dom g & g.x = y by FUNCT_1:def 5;
  y = f.x |^ a by a1,defpr;
  hence y in NAT by ORDINAL2:def 21;
end;
end;

definition
  let f be FinSequence of REAL;
  let a be natural number;
  redefine func f |^ a -> FinSequence of REAL;
coherence
proof  
  thus rng (f|^a) c= REAL by SEQ_1:def 1;
end;
end;

definition
  let f be FinSequence of NAT;
  let a be natural number;
  redefine func f |^ a -> FinSequence of NAT;
coherence
proof  
  thus rng (f|^a) c= NAT by SEQM_3:def 8;
end;
end;

theorem taa:
f |^ 0 = (len f) |-> 1
proof  
a1: len (f|^0) = len f by defpr; 
a2: len (len f |-> 1) = len f by FINSEQ_2:69;
  for k being Nat st 1 <= k & k <= len (f|^0)
   holds (f|^0).k = (len f |-> 1).k
  proof  
    let k be Nat;
    assume 1 <= k & k <= len (f|^0);
    then
a3: k in dom (f|^0) by FINSEQ_3:27;
    then
a4: k in Seg len f by a1,FINSEQ_1:def 3;
    thus (f|^0).k = f.k |^ 0 by a3,defpr
     .= 1 by NEWTON:9
     .= (len f |-> 1).k by a4,FINSEQ_2:70;
  end;
  hence thesis by a1,a2,FINSEQ_1:18;
end;
  
theorem
f |^ 1 = f
proof  
a1: len (f|^1) = len f by defpr; 
  for k being Nat st 1 <= k & k <= len (f|^1) holds (f|^1).k = f.k
  proof  
    let k be Nat;
    assume 1 <= k & k <= len (f|^1);
    then k in dom (f|^1) by FINSEQ_3:27;
    hence (f|^1).k = f.k |^ 1 by defpr
     .= f.k by NEWTON:10;
  end;
  hence thesis by a1,FINSEQ_1:18;
end;
  
theorem Tpr0:
<*>REAL |^ a = <*>REAL
proof
  len (<*>REAL |^ a) = len <*>REAL by defpr .= 0;
  hence thesis by FINSEQ_1:32;
end;

theorem Tpr1a:
<*r*>|^a = <*r|^a*>
proof
A1: len (<*r*>|^a) = len <*r*> by defpr .= 1 by FINSEQ_1:57;
    0+1 in Seg (0+1) by FINSEQ_1:6; then
    1 in dom (<*r*>|^a) by A1, FINSEQ_1:def 3; then
  (<*r*>|^a).1 = (<*r*>.1) |^ a by defpr
    .= r |^ a by FINSEQ_1:57;
 hence <*r*>|^a = <*r|^a*> by A1, FINSEQ_1:57;
end;
  
theorem Tpr2:
(f^<*r*>) |^ a = (f|^a)^(<*r*>|^a)
proof
A: len ((f^<*r*>) |^ a) = len (f^<*r*>) by defpr
   .= len f + len <*r*> by FINSEQ_1:35
   .= len f + 1 by FINSEQ_1:57;
B: len ((f|^a)^(<*r*>|^a)) = len (f|^a) + len (<*r*>|^a) by FINSEQ_1:35
   .= len f + len (<*r*>|^a) by defpr
   .= len f + len (<*r|^a*>) by Tpr1a
   .= len f + 1 by FINSEQ_1:57;
D: len (f|^a) = len f by defpr;
  now let i be Nat such that
  A1: i in Seg (len f +1);
  B1: 1 <= i & i <= len f + 1 by A1, FINSEQ_1:3;
  C1: i in dom ((f^<*r*>) |^ a) by A1, A, FINSEQ_1:def 3;
      per cases by B1, REAL_1:def 5;
      suppose i < len f +1; then
AA:      i <= len f by NAT_1:38; then
      A2: i in dom f by B1, FINSEQ_3:27;
      B2: i in dom (f|^a) by AA, B1, D, FINSEQ_3:27;
       thus ((f^<*r*>) |^ a).i
          = (f^<*r*>).i |^ a by C1, defpr
         .= f.i |^a by A2, FINSEQ_1:def 7
         .= (f|^a).i by B2, defpr
         .= ((f|^a)^(<*r*>|^a)).i by B2, FINSEQ_1:def 7;
       end;
      suppose S1: i = len f +1;
       thus ((f^<*r*>) |^ a).i = (f^<*r*>).i |^ a by C1, defpr
          .= r |^ a by FINSEQ_1:59, S1
          .= ((f|^a)^(<*r|^a*>)).i by D, S1, FINSEQ_1:59
          .= ((f|^a)^(<*r*>|^a)).i by Tpr1a;
    end;
  end;
 hence (f^<*r*>) |^ a = (f|^a)^(<*r*>|^a) by A, B, FINSEQ_2:10;
end;

theorem Tpr1:
Product (f|^(b+1)) = Product (f|^b) * Product f
proof
  defpred P[FinSequence of REAL] means
    for b being natural number
     holds Product ($1|^(b+1)) = Product ($1|^b) * Product $1;
P1: P[<*>REAL] proof let b be natural number;
      set f = <*>REAL;
     thus Product (f|^(b+1)) = 1 by Tpr0, RVSUM_1:124
       .= Product (f|^b) * Product f by Tpr0, RVSUM_1:124;
    end;
P2: now let p be FinSequence of REAL, x being Element of REAL such that
     IH: P[p];
      thus P[p^<*x*>] proof let b be natural number;
        set p1 = p^<*x*>;
      A1: p1 |^ (b+1) = (p|^(b+1))^(<*x*>|^(b+1)) by Tpr2;
       thus Product (p1|^(b+1))
          = Product (p|^(b+1)) * Product (<*x*>|^(b+1)) by A1, RVSUM_1:127
         .= (Product (p|^b) * Product p) * Product (<*x*>|^(b+1)) by IH
         .= (Product (p|^b) * Product p) * Product (<*x|^(b+1)*>) by Tpr1a
         .= (Product (p|^b) * Product p) * x|^(b+1) by RVSUM_1:125
         .= (Product (p|^b) * Product p) * (x|^b * x) by NEWTON:11
         .= Product (p|^b) * x|^b * x * Product p
         .= Product (p|^b ^ <*x|^b*>) * x * Product p by RVSUM_1:126
         .= Product (p|^b ^ (<*x*>|^b)) * x * Product p by Tpr1a
         .= Product (p1|^b) * x * Product p by Tpr2
         .= Product (p1|^b) * (Product p * x)
         .= Product (p1|^b) * Product p1 by RVSUM_1:126;
      end;
    end;
    for p being FinSequence of REAL holds P[p] from FINSEQ_2:sch 2(P1,P2);
  hence thesis;
end;

theorem 
Product (f|^a) = (Product f) |^ a
proof defpred P[natural number] means Product (f|^$1) = (Product f) |^ $1;
a1: P[0] proof
     thus Product (f|^0) = Product ((len f) |-> 1) by taa
                        .= 1 by RVSUM_1:132 .= (Product f) |^ 0 by NEWTON:9;
    end;
a2: P[b] implies P[b+1]
  proof assume
a3:   P[b];
    thus Product (f|^(b+1)) = Product (f|^b) * Product f by Tpr1 
      .= (Product f) |^ (b+1) by a3,NEWTON:11;
  end;
  P[b] from NAT_1:sch 2(a1,a2);
  hence Product (f|^a) = (Product f) |^ a;
end;

begin :: More about bags

registration :: cluster natural-yielding FinSequence;
   let X be set;
   cluster natural-yielding finite-support ManySortedSet of X;
   existence proof
     consider r being natural-yielding finite-support ManySortedSet of X;
::       ten cluster jest w polynom1
     r = r;
    hence thesis;
   end;
end;

definition
  let X be set, b be real-yielding ManySortedSet of X, a be natural number;
  func a * b -> ManySortedSet of X means :def5:
  for i being set holds it.i = a * b.i;
existence
proof
  deffunc F(set) = a * b.$1;
  consider f being ManySortedSet of X such that
a1:  for i being set st i in X holds f.i = F(i) from MSUALG_1:sch 2;
  take f;
  let i be set;
  per cases;
  suppose i in X;
  hence f.i = a * b.i by a1;
  end;
  suppose
a2: not i in X;
a3: dom b = X by PBOOLE:def 3;
  dom f = X by PBOOLE:def 3;
  hence f.i = a * 0 by a2,FUNCT_1:def 4
      .= a * b.i by a2,a3,FUNCT_1:def 4;
  end;
end;
uniqueness
proof
  let f, g be ManySortedSet of X such that
a1:  for i being set holds f.i = a * b.i and
a2:  for i being set holds g.i = a * b.i;
  for i being set st i in X holds f.i = g.i
  proof
    let i be set;
    assume i in X;
    thus f.i = a * b.i by a1
      .= g.i by a2;
  end;
  hence thesis by PBOOLE:3;
end;
end;

registration
  let X be set, b be real-yielding ManySortedSet of X, a be natural number;
  cluster a * b -> real-yielding;
coherence
proof
  let y be set;
  assume y in rng (a*b);
  then consider i being set such that
a1:  i in dom (a*b) & (a*b).i = y by FUNCT_1:def 5;
  y = a * b.i by a1,def5;
  hence thesis by XREAL_0:def 1;
end;
end;

registration
  let X be set, b be natural-yielding ManySortedSet of X, a be natural number;
  cluster a * b -> natural-yielding;
coherence
proof
  let y be set;
  assume y in rng (a*b);
  then consider i being set such that
a1:  i in dom (a*b) & (a*b).i = y by FUNCT_1:def 5;
  y = a * b.i by a1,def5;
  hence thesis by ORDINAL2:def 21;
end;
end;

registration
  let X be set, b be real-yielding ManySortedSet of X;
  cluster support (0*b) -> empty;
coherence
proof
  assume support (0*b) is non empty;
  then consider x being set such that
a1:  x in support (0*b) by XBOOLE_0:def 1;
  (0*b).x <> 0 by a1,POLYNOM1:def 7;
  then 0 * b.x <> 0 by def5;
  hence thesis;
end;
end;

theorem x11:
for X being set, b being real-yielding ManySortedSet of X
 st a <> 0 holds support b = support (a*b)
proof let X be set, b be real-yielding ManySortedSet of X such that
a1: a <> 0;
  hereby
    let x be set;
    assume x in support b;
    then b.x <> 0 by POLYNOM1:def 7;
    then a*b.x <> 0 by a1,XCMPLX_1:6;
    then (a*b).x <> 0 by def5;
    hence x in support (a*b) by POLYNOM1:def 7;
  end;
  let x be set;
  assume x in support (a*b);
  then (a*b).x <> 0 by POLYNOM1:def 7;
  then a*b.x <> 0 by def5;
  then b.x <> 0;
  hence x in support b by POLYNOM1:def 7;  
end;
  
registration
  let X be set, b be real-yielding finite-support ManySortedSet of X,
      a be natural number;
  cluster a * b -> finite-support;
coherence
proof
  per cases;
  suppose
a1: a = 0;
  support (0*b) = {};
  hence support (a*b) is finite by a1;
  end;
  suppose a <> 0;
  then support (a*b) = support b by x11;
  hence support (a*b) is finite;
  end;
end;
end;

definition
  let X be set; let b1, b2 be real-yielding ManySortedSet of X;
  func min(b1,b2) -> ManySortedSet of X means :dmin:
  for i being set holds (b1.i <= b2.i implies it.i = b1.i) &
                        (b1.i > b2.i implies it.i = b2.i);
existence
proof
  defpred P[set] means b1.$1 <= b2.$1;
  deffunc F(set) = b1.$1;
  deffunc G(set) = b2.$1;
  consider f being ManySortedSet of X such that
a1: for i being Element of X st i in X
      holds (P[i] implies f.i = F(i)) & (not P[i] implies f.i = G(i))
      from PRE_CIRC:sch 2;
  take f;
  let i be set;
  per cases;
  suppose i in X;
  hence thesis by a1;
  end;
  suppose not i in X;
  then not i in dom f & not i in dom b1 & not i in dom b2 by PBOOLE:def 3;
  then f.i = 0 & b1.i = 0 & b2.i = 0 by FUNCT_1:def 4;
  hence thesis;
  end;
end;
uniqueness
proof
  let f, g be ManySortedSet of X such that
a1:  for i being set holds (b1.i <= b2.i implies f.i = b1.i) &
                           (b1.i > b2.i implies f.i = b2.i) and
a2:  for i being set holds (b1.i <= b2.i implies g.i = b1.i) &
                           (b1.i > b2.i implies g.i = b2.i);
  now
    let i be set;
    assume i in X;
    per cases;
    suppose
a3:   b1.i <= b2.i;
    hence f.i = b1.i by a1
             .= g.i by a2,a3;
    end;
    suppose
a4:   b1.i > b2.i;
    hence f.i = b2.i by a1
       .= g.i by a2,a4;
    end;
  end;
  hence thesis by PBOOLE:3;
end;
end;

registration
  let X be set; let b1, b2 be real-yielding ManySortedSet of X;
  cluster min(b1,b2) -> real-yielding;
coherence
proof
  set f = min(b1,b2);
  let y be set;
  assume y in rng f;
  then consider x being set such that
    x in dom f and
a1: f.x = y by FUNCT_1:def 5;
  b1.x <= b2.x or b1.x > b2.x;
  then f.x = b1.x or f.x = b2.x by dmin;
  hence thesis by a1;
end;
end;

registration
  let X be set; let b1, b2 be natural-yielding ManySortedSet of X;
  cluster min(b1,b2) -> natural-yielding;
coherence
proof
  set f = min(b1,b2);
  let y be set;
  assume y in rng f;
  then consider x being set such that
    x in dom f and
a1: f.x = y by FUNCT_1:def 5;
  b1.x <= b2.x or b1.x > b2.x;
  then f.x = b1.x or f.x = b2.x by dmin;
  hence thesis by a1;
end;
end;

theorem x21:
for X being set, b1, b2 being real-yielding finite-support ManySortedSet of X
  holds support min(b1,b2) c= support b1 \/ support b2
proof
  let X be set; let b1, b2 be real-yielding finite-support ManySortedSet of X;
  set f = min(b1,b2);
  let x be set;
  assume x in support f;
  then
a1: f.x <> 0 by POLYNOM1:def 7;
  b1.x <= b2.x or b1.x > b2.x;
  then f.x = b1.x or f.x = b2.x by dmin;
  then x in support b1 or x in support b2 by a1,POLYNOM1:def 7;
  hence x in support b1 \/ support b2 by XBOOLE_0:def 2;
end;
  
registration
  let X be set; let b1, b2 be real-yielding finite-support ManySortedSet of X;
  cluster min(b1,b2) -> finite-support;
coherence
proof
  support min(b1,b2) c= support b1 \/ support b2 by x21;
  hence support min(b1,b2) is finite by FINSET_1:13;
end;
end;

definition
  let X be set; let b1, b2 be real-yielding ManySortedSet of X;
  func max(b1,b2) -> ManySortedSet of X means :dmax:
  for i being set holds (b1.i <= b2.i implies it.i = b2.i) &
                        (b1.i > b2.i implies it.i = b1.i);
existence
proof
  defpred P[set] means b1.$1 <= b2.$1;
  deffunc F(set) = b2.$1;
  deffunc G(set) = b1.$1;
  consider f being ManySortedSet of X such that
a1: for i being Element of X st i in X
      holds (P[i] implies f.i = F(i)) & (not P[i] implies f.i = G(i))
      from PRE_CIRC:sch 2;
  take f;
  let i be set;
  per cases;
  suppose i in X;
  hence thesis by a1;
  end;
  suppose not i in X;
  then not i in dom f & not i in dom b1 & not i in dom b2 by PBOOLE:def 3;
  then f.i = 0 & b1.i = 0 & b2.i = 0 by FUNCT_1:def 4;
  hence thesis;
  end;
end;
uniqueness
proof
  let f, g be ManySortedSet of X such that
a1:  for i being set holds (b1.i <= b2.i implies f.i = b2.i) &
                           (b1.i > b2.i implies f.i = b1.i) and
a2:  for i being set holds (b1.i <= b2.i implies g.i = b2.i) &
                           (b1.i > b2.i implies g.i = b1.i);
  now
    let i be set;
    assume i in X;
    per cases;
    suppose
a3:   b1.i <= b2.i;
    hence f.i = b2.i by a1
             .= g.i by a2,a3;
    end;
    suppose
a4:   b1.i > b2.i;
    hence f.i = b1.i by a1
       .= g.i by a2,a4;
    end;
  end;
  hence thesis by PBOOLE:3;
end;
end;

registration
  let X be set; let b1, b2 be real-yielding ManySortedSet of X;
  cluster max(b1,b2) -> real-yielding;
coherence
proof
  set f = max(b1,b2);
  let y be set;
  assume y in rng f;
  then consider x being set such that
    x in dom f and
a1: f.x = y by FUNCT_1:def 5;
  b1.x <= b2.x or b1.x > b2.x;
  then f.x = b1.x or f.x = b2.x by dmax;
  hence thesis by a1;
end;
end;

registration
  let X be set; let b1, b2 be natural-yielding ManySortedSet of X;
  cluster max(b1,b2) -> natural-yielding;
coherence
proof
  set f = max(b1,b2);
  let y be set;
  assume y in rng f;
  then consider x being set such that
    x in dom f and
a1: f.x = y by FUNCT_1:def 5;
  b1.x <= b2.x or b1.x > b2.x;
  then f.x = b1.x or f.x = b2.x by dmax;
  hence thesis by a1;
end;
end;

theorem x22:
for X being set, b1, b2 being real-yielding finite-support ManySortedSet of X
  holds support max(b1,b2) c= support b1 \/ support b2
proof
  let X be set; let b1, b2 be real-yielding finite-support ManySortedSet of X;
  set f = max(b1,b2);
  let x be set;
  assume x in support f;
  then
a1: f.x <> 0 by POLYNOM1:def 7;
  b1.x <= b2.x or b1.x > b2.x;
  then f.x = b1.x or f.x = b2.x by dmax;
  then x in support b1 or x in support b2 by a1,POLYNOM1:def 7;
  hence x in support b1 \/ support b2 by XBOOLE_0:def 2;
end;
  
registration
  let X be set; let b1, b2 be real-yielding finite-support ManySortedSet of X;
  cluster max(b1,b2) -> finite-support;
coherence
proof
  support max(b1,b2) c= support b1 \/ support b2 by x22;
  hence support max(b1,b2) is finite by FINSET_1:13;
end;
end;

definition
  let A be set, b be bag of A;
  func Product b -> natural number means                            :Lbagprod:
  ex f being FinSequence of NAT st it = Product f & f = b*canFS(support b);
  existence proof set cS = canFS(support b);
   set f = b*cS;
  A: rng b c= NAT by SEQM_3:def 8;
  Aa: support b c= dom b by POLYNOM1:41; rng cS = support b by UPROOTS:5;
     then dom f = dom cS by Aa, RELAT_1:46;
     then dom f = Seg len cS by FINSEQ_1:def 3; then
  B: f is FinSequence by FINSEQ_1:def 2;
     rng f c= rng b by RELAT_1:45; then rng f c= NAT by A, XBOOLE_1:1; then
   reconsider f as FinSequence of NAT by B, FINSEQ_1:def 4;
   take S = Product f; thus thesis;
  end;
  uniqueness;
end;

definition
  let A be set, b be bag of A;
  redefine func Product b -> Nat;
  coherence by ORDINAL2:def 21;
end;

theorem Prodsum:
for X being set, a, b being bag of X
 st support a misses support b holds Product (a+b) = (Product a) * Product b
proof let X be set, a, b be bag of X; assume support a misses support b; then
AA: support a /\ support b = {} by XBOOLE_0:def 7;
   set ab= a+b; set Pa = Product a, Pb = Product b, Pab = Product ab;
   set sab = support (a+b); set sa = support a; set sb = support b;
   consider f being FinSequence of NAT such that
B: Pab = Product f and
C: f = ab*canFS(support ab) by Lbagprod;
   consider fa being FinSequence of NAT such that
D: Pa = Product fa and
E: fa = a*canFS(support a) by Lbagprod;
   consider fb being FinSequence of NAT such that
F: Pb = Product fb and
G: fb = b*canFS(support b) by Lbagprod;
   set g = fa^fb; set ca = canFS(support a), cb = canFS(support b);
   set cg = ca^cb, cf = canFS(support ab);   set p = cg" * cf;
   len cf = card sab by UPROOTS:def 1; then
b: dom cf = Seg card sab by FINSEQ_1:def 3;
c: rng cf = sab by UPROOTS:5;
c1: cf is one-to-one by UPROOTS:4;
   dom ab = X by PBOOLE:def 3; then
e: dom f = Seg card sab by C, b, c, RELAT_1:46;
p1: len cb = card sb by UPROOTS:def 1; 
pa1: len ca = card sa by UPROOTS:def 1; 
h: sab = sa \/ sb by POLYNOM1:42;
n: rng cb = sb by UPROOTS:5;
na: rng ca = sa by UPROOTS:5;
m: cb is one-to-one by UPROOTS:4;
ma: ca is one-to-one by UPROOTS:4;
f4: len cg = card sa + card sb - card {} by p1, pa1, FINSEQ_1:35, REAL_1:25
        .= card sab by AA, h, CARD_2:64; then
f2: dom cg = Seg card sab by FINSEQ_1:def 3;
f1: rng cg = sab by h, n, na, FINSEQ_1:44;
f3: cg is one-to-one by f4, f1, FINSEQ_4:77;
f: dom (cg") = sab by f1, f3, FUNCT_1:55;
g: rng (cg") = Seg card sab by f2, f3, FUNCT_1:55;
o: dom (cb") = sb by m, n, FUNCT_1:54;
p: dom cb = Seg card sb by p1, FINSEQ_1:def 3;
r: rng (cb") = dom cb by m, FUNCT_1:55;
oa: dom (ca") = sa by ma, na, FUNCT_1:54;
pa: dom ca = Seg card sa by pa1, FINSEQ_1:def 3;
ra: rng (ca") = dom ca by ma, FUNCT_1:55;
   dom a = X by PBOOLE:def 3; then
w: dom ca = dom fa by na, E, RELAT_1:46; then
s: len ca = len fa by FINSEQ_3:31;
   dom b = X by PBOOLE:def 3; then
   dom cb = dom fb by n, G, RELAT_1:46; then
t: len cb = len fb by FINSEQ_3:31;
u: len cg = len ca + len cb by FINSEQ_1:35;
y: dom p = Seg card sab by b, c, f, RELAT_1:46;
   len g = card sa + card sb - card {} by p1, pa1, s, t, FINSEQ_1:35, REAL_1:25
        .= card sab by AA, h, CARD_2:64; then
i: dom g = Seg card sab by FINSEQ_1:def 3;
z: rng p = rng (cg") by c, f, RELAT_1:47; then
   reconsider p as Function of dom g, dom g by g, y, i, FUNCT_2:3;
   cg" is one-to-one by f3, FUNCT_1:62; then
I: p is one-to-one by c1, FUNCT_1:46;
   p is onto by z, g, i, FUNCT_2:def 3; then
   reconsider p as Permutation of dom g by I, FUNCT_2:def 4;
J: dom (g*p) = Seg card sab by z, g, i, y, RELAT_1:46;
   now let x be set; assume
   A1: x in dom f;       set cgx = cg".(cf.x);
   B1: (g*p).x = g.(p.x) by A1, e, J, FUNCT_1:22
              .= g.cgx by A1, e, b, FUNCT_1:23;
   C1: cf.x in sab by c, A1, e, b, FUNCT_1:12; then
       cgx in Seg card sab by g, f, FUNCT_1:12; 
       then reconsider cgx as natural number by Seg1;
       reconsider cgxN = cgx as Nat by ORDINAL2:def 21;
       consider d being set such that
   F1: d in dom cg and
   G1: cg.d = cf.x by C1, f1, FUNCT_1:def 5;
   H1: cgx = d by G1, F1, f3, FUNCT_1:56;
   E1: cgxN <= len fa + len fb by F1, H1, s, t, u, FINSEQ_3:27;
   E1a: 1 <= cgxN by F1, H1, FINSEQ_3:27;
    per cases by C1, h, XBOOLE_0:def 2;
    suppose S1: cf.x in sa; then
    A2: not cf.x in sb by AA, XBOOLE_0:def 3;
        set cax = ca".(cf.x);
        cax in rng (ca") by S1, oa, FUNCT_1:12; then
        reconsider cax as natural number by pa, ra, Seg1;
    G2: now assume len fa < cgx; then
        B3: len fa +1 <= cgx by NAT_1:38; then
        A3: cg.cgxN = cb.(cgx-len ca) by E1, s, t, FINSEQ_1:36;
        C3: len ca +1 - len ca <= cgx - len ca by s, B3, REAL_1:49; then
            0 <= cgx - len ca by AXIOMS:22; then
        D3: cgx - len ca is Nat by INT_1:16;
            cgx -len ca <= len ca + len cb - len ca by s, t,E1, REAL_1:49; then
            cgx-len ca in dom cb by C3, D3, FINSEQ_3:27; 
         hence contradiction by H1, G1, A2, n, A3, FUNCT_1:12;
        end;
    J2: cgxN in dom fa by G2, E1a, FINSEQ_3:27; 
    H2: cg.cgx = ca.cgx by J2, w, FINSEQ_1:def 7;
    B2: g.cgx = fa.cgxN by J2, FINSEQ_1:def 7
        .= a.(cf.x) by E, w, G1, H1, J2, H2, FUNCT_1:23;
     thus f.x = ab.(cf.x) by C, A1, FUNCT_1:22
             .= a.(cf.x) + b.(cf.x) by POLYNOM1:def 5
             .= a.(cf.x) + 0 by A2, POLYNOM1:def 7
             .= (g*p).x by B2, B1;    
    end;
    suppose S1: cf.x in sb; then
    A2: not cf.x in sa by AA, XBOOLE_0:def 3;
        set cbx = cb".(cf.x);
        cbx in rng (cb") by S1, o, FUNCT_1:12; then
        reconsider cbx as natural number by p, r, Seg1;
    G2: now assume len fa +1 > cgx; then cgx <= len fa by NAT_1:38; then
        A3: cgx in dom ca by E1a, w, FINSEQ_3:27; then
            ca.cgx in sa by na, FUNCT_1:12; then
            cg.cgxN in sa by A3, FINSEQ_1:def 7;
         hence contradiction by H1, G1, S1, AA, XBOOLE_0:def 3;
        end; then
    H2: cg.cgx = cb.(cgx-len ca) by E1, s,t, FINSEQ_1:36;
    K2: cgx-len ca <= len ca + len cb - len ca by E1, s, t, REAL_1:49;
    L2: len ca + 1 - len ca <= cgx-len ca by s, G2, REAL_1:49; then
        0 <= cgxN-len ca by AXIOMS:22; then
        cgxN-len ca is Nat by INT_1:16; then
    J2: cgxN-len ca in dom cb by K2, L2, FINSEQ_3:27;
    B2: g.cgx = fb.(cgxN-len fa) by G2, E1, FINSEQ_1:36
        .= b.(cf.x) by G, G1, H1, H2, J2, s, FUNCT_1:23; 
     thus f.x = ab.(cf.x) by C, A1, FUNCT_1:22
             .= a.(cf.x) + b.(cf.x) by POLYNOM1:def 5
             .= 0 + b.(cf.x) by A2, POLYNOM1:def 7
             .= (g*p).x by B2, B1;    
    end;
   end; then
H: f = g*p by e, J, FUNCT_1:9;   
 thus Product (a+b) = multreal $$ f by RVSUM_1:def 11, B
   .= multreal $$ g by H, FINSOP_1:8, RVSUM_1:11,12,15
   .= Product g by RVSUM_1:def 11
   .= (Product a) * Product b by D, F, RVSUM_1:127;
end;

definition
  let X be set, b be real-yielding ManySortedSet of X,
      n be non empty natural number;
  func b |^ n -> ManySortedSet of X means :Lbagexp:
  support it = support b &
  for i being set holds it.i = b.i |^ n;
  existence proof
    deffunc F(Element of X) = b.$1 |^ n;
  N: dom b = X by PBOOLE:def 3;
    consider f being Function such that
  A: dom f = X and
  B: for x being set st x in X holds f.x = F(x) from FUNCT_1:sch 3;
     reconsider n1 = n as Nat by ORDINAL2:def 21;
  C: n1 >= 1 by UPROOTS:1;
     reconsider f as ManySortedSet of X by A, PBOOLE:def 3;
     take f;
     now let x be set;
       hereby assume A1: x in support f;
        assume not x in support b; then
         b.x = 0 by POLYNOM1:def 7; then
       B1: b.x |^ n = 0 by C, NEWTON:16;
          support f c= X by A, POLYNOM1:41; then
          f.x = 0 by A1, B, B1;
        hence contradiction by A1, POLYNOM1:def 7;
       end;
       assume x in support b; then
       B1: b.x <> 0 by POLYNOM1:def 7;
         now per cases;
          suppose x in X;
          hence f.x = b.x |^ n1 by B;
          end;
          suppose
        M:  not x in X;
          hence f.x = 0 by A, FUNCT_1:def 4
            .= 0 |^ n1 by C, NEWTON:16
            .= b.x |^ n1 by M, N, FUNCT_1:def 4;
         end;
         end;
         then f.x <> 0 by B1, CARD_4:51;
       hence x in support f by POLYNOM1:def 7;
     end; 
     hence support f = support b by TARSKI:2;
     let i be set;
     per cases;
     suppose i in X;
     hence f.i = b.i |^ n by B;
     end;
     suppose
  M:   not i in X;
     thus f.i = 0 by A,M,FUNCT_1:def 4
        .= 0 |^ n by C,NEWTON:16
        .= b.i |^ n by M,N,FUNCT_1:def 4;
     end;
  end;
  uniqueness proof let it1, it2 be ManySortedSet of X such that
     support it1 = support b and
  A: for i being set holds it1.i = b.i |^ n and
     support it2 = support b and
  B: for i being set holds it2.i = b.i |^ n;
    now let x be set such that x in X;
     thus it1.x = b.x |^ n by A .= it2.x by B;
    end;
   hence it1 = it2 by PBOOLE:3;
  end;
end;

registration
  let X be set, b be natural-yielding ManySortedSet of X,
      n be non empty natural number;
  cluster b |^ n -> natural-yielding;
coherence
proof
  set f = b |^ n;
  let y be set; assume y in rng f; then
  consider x being set such that
    x in dom f and
B1: f.x = y by FUNCT_1:def 5;
  f.x = b.x |^ n by Lbagexp;
  hence thesis by B1, ORDINAL2:def 21;
end;
end;

registration
  let X be set, b be real-yielding finite-support ManySortedSet of X,
      n be non empty natural number;
  cluster b |^ n -> finite-support;
coherence
proof
  support b|^n = support b by Lbagexp;
  hence support b|^n is finite;
end;
end;

theorem ProdEB:
for A being set holds Product EmptyBag A = 1
proof let A be set; set b = EmptyBag A; set cS = canFS(support b);
  support b = {} by BAGORDER:19; then
  len cS = 0 by UPROOTS:def 1, CARD_1:78; then cS = <*>NAT by FINSEQ_1:32; then
 b*cS = <*>NAT by RELAT_1:62; 
 hence Product b = 1 by Lbagprod,  RVSUM_1:124;
end;
  
begin :: Multiplicity of a divisor

definition
  let n, d be natural number such that
c1: d <> 1 and
c2: n <> 0;  
  func d |-count n -> Nat means :def0:
  d |^ it divides n & not d |^ (it+1) divides n;
existence
proof  
  reconsider d1 = d, n1 = n as Nat by ORDINAL2:def 21;
  per cases;
  suppose s1: d = 0;
   take 0;  0 |^ 0 = 1 by NEWTON:9;
   hence d |^ 0 divides n by s1,NAT_1:53;
    not 0 divides n1 by c2,INT_2:3;
   hence not d |^ (0+1) divides n by s1,NEWTON:16;
    end;
  suppose f1: d <> 0;
s1: n > 0 by c2,NAT_1:19;
  defpred P[Nat] means d |^ $1 divides n;
a1:for k being Nat st P[k] holds k <= n1
  proof let k be Nat; assume P[k];
    then
a5: d |^ k <= n by s1,NAT_1:54;
    1 < d by c1,f1,CQC_THE1:2; then k <= d |^ k by t1;
    hence k <= n1 by a5,AXIOMS:22;
  end;
a2:ex k being Nat st P[k]
   proof take 0;  d |^ 0 = 1 by NEWTON:9;
     hence d |^ 0 divides n by NAT_1:53;
   end;
  consider k being Nat such that
a3: P[k] & for n being Nat st P[n] holds n <= k from NAT_1:sch 6(a1,a2);
  take k; k+0 < k+1 by REAL_1:53;
  hence thesis by a3;
    end;
end;
uniqueness proof  
  let a, b be Nat such that
a1:  d |^ a divides n and
a2:  not d |^ (a+1) divides n and
a3:  d |^ b divides n and
a4:  not d |^ (b+1) divides n and
j1:  a <> b;
   reconsider d1 = d as Nat by ORDINAL2:def 21;
   per cases by j1,REAL_1:def 5;
   suppose j4:   a < b;
   then consider x being Nat such that
j2:  a + x = b by NAT_1:28;
   now assume 0+1 > x; then x <= 0 by NAT_1:38; then x = 0 by NAT_1:18;
     hence contradiction by j4,j2;
   end;
   then a+1 <= a+x by AXIOMS:24;
   then d1 |^ (a+1) divides d1 |^ (a+x) by RADIX_1:7;
   hence contradiction by a2,a3,j2,NAT_1:51;
    end;
   suppose
j4:  b < a;
   then consider x being Nat such that
j2:  b + x = a by NAT_1:28;
   now
     assume 0+1 > x;
     then x <= 0 by NAT_1:38;
     then x = 0 by NAT_1:18;
     hence contradiction by j4,j2;
   end;
   then b+1 <= b+x by AXIOMS:24;
   then d1 |^ (b+1) divides d1 |^ (b+x) by RADIX_1:7;
   hence contradiction by a1,a4,j2,NAT_1:51;
    end;
end;
end;

theorem t9:
n <> 1 implies n |-count 1 = 0
proof  
  assume
a2: 1 <> n;
a1:n |^ 0 divides 1 by NEWTON:9;
  now
    assume
a3:   n |^ (0+1) divides 1;
    then n |^ 1 <= 1 by NAT_1:54;
    then n <= 1 by NEWTON:10;
    then n = 0 by a2,CQC_THE1:2;
    then 0 divides 1 by a3,NEWTON:10;
    hence contradiction by INT_2:3;
  end;
  hence thesis by a2,a1,def0;
end;

theorem
1 < n implies n |-count n = 1
proof  
  assume
a2: 1 < n;
  then
a0: n > 0 by AXIOMS:22;
a1:n |^ 1 divides n by NEWTON:10;
  now
    assume n |^ (1+1) divides n;
    then n |^ 2 <= n by a0,NAT_1:54;
    hence contradiction by a2,PREPOWER:21;
  end;
  hence thesis by a0,a2,a1,def0;
end;

theorem t5:
b <> 0 & b < a & a <> 1 implies a |-count b = 0
proof  
  assume that
a3:  b <> 0 and
a4:  b < a and
a0:  a <> 1;  
  a |^ 0 = 1 by NEWTON:9;
  then
a2:a |^ 0 divides b by NAT_1:53;
d1:a |^ 1 = a by NEWTON:10;
  b > 0 by a3,NAT_1:19;
  then not a |^ (0+1) divides b by a4,d1,NAT_1:54;
  hence a |-count b = 0 by a0,a2,a3,def0;
end;
  
theorem
a <> 1 & a <> p implies a |-count p = 0
proof  
  assume that
a0: a <> 1 and
a1: a <> p;
  a |^ 0 = 1 by NEWTON:9;
  then
a2:a |^ 0 divides p by NAT_1:53;
a6:a |^ (0+1) is Nat by ORDINAL2:def 21;
  a |^ 1 = a by NEWTON:10;
  then not a |^ (0+1) divides p by a0,a1,a6,INT_2:def 5;
  hence a |-count p = 0 by a0,a2,def0;
end;

theorem t70:
1 < b implies b |-count (b|^a) = a
proof  
  assume
a2: b > 1;
  then b > 0 by AXIOMS:22;
  then reconsider b as non empty Nat by ORDINAL2:def 21;
a1: b|^a > 0 by NAT_1:19;   
  reconsider a as Nat by ORDINAL2:def 21;
  now
    assume b|^(a+1) divides b|^a;
    then
b1: b|^(a+1) <= b|^a by a1,NAT_1:54;
hh: b|^(a+1) > 0 by NAT_1:19;
    a <= a+1 by NAT_1:29;
    then b|^a divides b|^(a+1) by RADIX_1:7;
    then b|^a <= b|^(a+1) by hh,NAT_1:54;
    then b|^a = b|^(a+1) by b1,AXIOMS:21;
    then a+0 = a+1 by a2,PEPIN:31;
    hence contradiction by XCMPLX_1:2;
  end;
  hence thesis by a2,def0;
end;

theorem t44:
b <> 1 & a <> 0 & b divides b |^ (b |-count a) implies b divides a
proof  
  assume that
a1: b <> 1 and
a2: a <> 0 and
a3: b divides b |^ (b |-count a);
  b |^ (b |-count a) divides a by a1,a2,def0;
  hence b divides a by a3,NAT_1:51;
end;

theorem t83:
b <> 1 implies (a <> 0 & b |-count a = 0 iff not b divides a)
proof  
  assume 
a4: b <> 1;
  thus a <> 0 & b |-count a = 0 implies not b divides a
  proof  
    assume that
a0:   a <> 0 and
a1:   b |-count a = 0 and
a2:   b divides a;
    not b |^ (0+1) divides a by a0,a1,a4,def0;
    hence contradiction by a2,NEWTON:10;
  end;
  assume
a6: not b divides a;
  then
a3:not b |^ (0+1) divides a by NEWTON:10;
a5: a <> 0 by a6,NAT_1:53;
  1 divides a by NAT_1:53;
  then b |^ 0 divides a by NEWTON:9;
  hence thesis by a3,a4,a5,def0;
end;
  
theorem t50:
for a, b being non empty natural number
  holds p |-count (a*b) = (p |-count a) + (p |-count b)
proof let a,b be non empty natural number;
  set x = p |-count a;  set y = p |-count b;  set z = p |-count (a*b);
a3: p <> 1 by INT_2:def 5;
a6: p |^ (x+y) = p |^ x * p |^ y by NEWTON:13;
d3: p |^ x divides a by a3,def0;
d4: p |^ y divides b by a3,def0; then
a5: p |^ (x+y) divides a*b by a6,d3,t60;
  now  assume
z1:  p |^ (x+y+1) divides a*b;
Z2:  p |^ (x+y+1) = p |^ (x+y) * p by NEWTON:11;
q2: not p |^ (y+1) divides b by a3,def0;
q3: not p |^ (x+1) divides a by a3,def0;
    consider t being Nat such that
A1: a = (p |^ x) * t by d3, NAT_1:def 3;
    consider u being Nat such that
B1: b = (p |^ y) * u by d4, NAT_1:def 3;
    consider v being Nat such that
C1: a*b = p |^ (x+y+1) * v by z1, NAT_1:def 3;
D1: a*b = (p |^ x) * (p |^ y) * t * u by A1, B1
       .= p |^ (x+y) * t * u by NEWTON:13
       .= p |^ (x+y) * (t * u);
     a*b = p |^ (x+y) * (p * v) by C1, Z2;
     then p*v = t*u by D1, XCMPLX_1:5; then
E1:  p divides t*u by NAT_1:def 3;
     per cases by E1, NAT_LAT:95;
     suppose p divides t; then consider t1 being Nat such that
     A2: t = p * t1 by NAT_1:def 3;
     a = (p |^ x) * p * t1 by A2, A1
      .= p |^ (x+1) * t1 by NEWTON:11;
      hence contradiction by q3, NAT_1:def 3;
    end;
     suppose p divides u; then consider t1 being Nat such that
     A2: u = p * t1 by NAT_1:def 3;
     b = (p |^ y) * p * t1 by A2, B1
      .= p |^ (y+1) * t1 by NEWTON:11;
      hence contradiction by q2, NAT_1:def 3;
    end;
  end;
  hence z = x + y by a3,a5,def0;
end;

theorem t43:
for a, b being non empty natural number
  holds p |^ (p |-count (a*b)) = (p |^ (p |-count a)) * (p |^ (p |-count b))
proof let a,b be non empty natural number;
  set x = p |-count a;  set y = p |-count b;
  thus p |^ (p |-count (a*b)) = p |^ (x + y) by t50
   .= (p |^ x) * (p |^ y) by NEWTON:13;
end;

theorem t501:
for a, b being non empty natural number
 st b divides a holds p |-count b <= p |-count a
proof let a,b be non empty natural number;
  set x = p |-count a;  set y = p |-count b;  set z = p |-count (a div b);
  assume b divides a; then
a2:a = b * (a div b) by NAT_1:49;
a3: p > 1 by INT_2:def 5;
b1: a div b <> 0 by a2;
b3: 0 < p |^ y by NAT_1:19;
  0 < p |^ z by NAT_1:19;
  then 0+1 <= p |^ z by NAT_1:38;
  then 1 * p |^ y <= p |^ z * p |^ y by b3,REAL_2:197;
  then p |^ y <= p |^ x by b1,a2,t43;
  hence thesis by a3,JORDAN1A:7;
end;

theorem t500:
for a, b being non empty natural number
 st b divides a holds p |-count (a div b) = (p |-count a) -' (p |-count b)
proof let a,b be non empty natural number;
  set x = p |-count a;  set y = p |-count b;  set z = p |-count (a div b);
  assume
a0: b divides a; then
a2:a = b * (a div b) by NAT_1:49;
  a div b <> 0 by a2;
  then p |-count (b*(a div b)) = y + z by t50;
  then
a1: z + y = x + 0 by a0,NAT_1:49;
  y <= x by a0,t501;
  then y-y <= x-y by REAL_1:92;
  then x-y = x-'y by BINARITH:def 3;
  then z - 0 = x -' y by a1,XCMPLX_1:33;
  hence thesis;
end;

theorem x10:
for a being non empty natural number
 holds p |-count (a|^b) = b * (p |-count a)
proof
  let a be non empty natural number;
a3: p <> 1 by INT_2:def 5;  
  defpred P[natural number] means p |-count (a|^$1) = $1 * (p |-count a);
a1: P[0]
  proof
    thus p |-count (a|^0) = p |-count 1 by NEWTON:9
      .= 0 * (p |-count a) by a3,t9;
  end;
a2: for x being natural number st P[x] holds P[x+1]
  proof let x be natural number such that
a4:   P[x];
    thus p |-count (a|^(x+1)) = p |-count (a|^x*a) by NEWTON:11
      .= x * (p |-count a) + 1 * (p |-count a) by a4,t50
      .= (x+1) * (p |-count a);
  end;
  for x being natural number holds P[x] from NAT_1:sch 2(a1,a2);
  hence thesis;
end;
  
begin :: Exponents in prime-power factorization

definition
  let n be natural number;
  func prime_exponents n -> ManySortedSet of SetPrimes means :def1:
  for p being Prime holds it.p = p |-count n;
existence proof deffunc F(natural number) = $1 |-count n;
  consider f being ManySortedSet of SetPrimes such that
a1: for i being set st i in SetPrimes holds f.i = F(i) from MSUALG_1:sch 2;
  take f; let i be Prime; i in SetPrimes by NAT_LAT:def 17;
  hence thesis by a1;
end;
uniqueness proof let f, g be ManySortedSet of SetPrimes such that
a1:  for i being Prime holds f.i = i |-count n and
a2:  for i being Prime holds g.i = i |-count n;
  now let i be set; assume i in SetPrimes;
    then reconsider a = i as Prime by NAT_LAT:def 17;
    thus f.i = a |-count n by a1 .= g.i by a2;
  end;
  hence thesis by PBOOLE:3;
end;
end;

notation
  let n be natural number;
  synonym pfexp n for prime_exponents n; :: for prime factors exponents
end;

theorem tdom:
for x being set st x in dom pfexp n holds x is Prime
proof let x be set; assume x in dom pfexp n;
  then x in SetPrimes by PBOOLE:def 3;
 hence x is Prime by NAT_LAT:def 17;
end;

theorem t51:
for x being set st x in support pfexp n holds x is Prime
proof  let x be set;  set f = pfexp n; assume
a3: x in support f;
  support f c= dom f by POLYNOM1:41;
  hence x is Prime by a3,tdom;
end;
  
theorem t6:
a > n & n <> 0 implies (pfexp n).a = 0
proof  set f = pfexp n; assume that
a0: a > n and
a6: n <> 0;
  reconsider a as Nat by ORDINAL2:def 21;
  per cases;
  suppose a is not prime;  then not a in dom pfexp n by tdom;
   hence thesis by FUNCT_1:def 4;
  end;
  suppose a1: a is prime; then a <> 1 by INT_2:def 5;
    then a |-count n = 0 by a0,a6,t5;
   hence thesis by a1,def1;
  end;
end;
  
registration
  let n be natural number;
  cluster pfexp n -> natural-yielding;
coherence proof set f = pfexp n; let y be set; assume y in rng f;
  then consider x being set such that
a1: x in dom f and
a2: f.x = y by FUNCT_1:def 5;
  reconsider x as Prime by a1,tdom;
  y = x |-count n by a2,def1;
  hence y in NAT;
end;
end;

theorem 
a in support pfexp b implies a divides b
proof  set f = pfexp b;  assume
a3: a in support f;  then reconsider a as Prime by t51;
a1:f.a <> 0 by a3,POLYNOM1:def 7;
a2: a <> 1 by INT_2:def 5;  
  f.a = a |-count b by def1;
  hence thesis by a1,a2,t83;
end;

theorem t51b:
b is non empty & a is Prime & a divides b implies a in support pfexp b
proof assume that
Aa: b is non empty and
A: a is Prime and
B: a divides b;
  1 < a by A, INT_2:def 5;
  then
C: a |-count b <> 0 by B, Aa, t83;
  (pfexp b).a = a |-count b by A, def1;
  hence thesis by C, POLYNOM1:def 7;
end;

registration
  let n be non empty natural number;
  cluster pfexp n -> finite-support;
coherence proof  set f = pfexp n;
  deffunc F(set) = $1;
  defpred P[Nat] means $1 is prime;
  reconsider n as Nat by ORDINAL2:def 21;
  set A = {F(i) where i is Nat: 0 <= i & i <= n & P[i]};
a6: A is finite from GRAPH_2:sch 1;
  support f c= A proof let x be set; assume
a3:   x in support f;
    then reconsider x as Prime by t51;
a5: f.x <> 0 by a3,POLYNOM1:def 7;
h1: 0 <= x by NAT_1:18;
    x <= n by a5, t6;
    hence thesis by h1;
  end;
  hence support f is finite by a6,FINSET_1:13;
end;
end;

theorem t45:
for a being non empty natural number st p divides a holds (pfexp a).p <> 0
proof let a be non empty natural number; assume p divides a; then
a2: p |^ (0+1) divides a by NEWTON:10;
a1: (pfexp a).p = p |-count a by def1;
    p <> 1 by INT_2:def 5;
  hence thesis by a1,a2,def0;
end;

theorem t200:
pfexp 1 = EmptyBag SetPrimes
proof set f = pfexp 1; set g = SetPrimes --> 0;
  for z being set st z in dom f holds f.z = 0
  proof let z be set; assume z in dom f;
      then reconsider z as Prime by tdom;
  a2: z <> 1 by INT_2:def 5;
      f.z = z |-count 1 by def1 .= 0 by a2,t9;
    hence thesis;
  end; then
A: f = (dom f) --> 0 by FUNCOP_1:17;
   dom f = SetPrimes by PBOOLE:def 3;
  hence thesis by A, POLYNOM1:def 15;
end;

registration
  cluster support pfexp 1 -> empty;
coherence
proof set f = pfexp 1; assume support f is non empty;
  then consider x being set such that
a1:  x in support f by XBOOLE_0:def 1;
  f.x <> 0 by a1,POLYNOM1:def 7;
  hence contradiction by t200,POLYNOM1:56;
end;
end;
  
theorem t23a:
(pfexp (p|^a)).p = a
proof set f = pfexp (p|^a);
a1: p > 1 by INT_2:def 5;
  f.p = p |-count (p|^a) by def1;
  hence f.p = a by a1,t70;
end;

theorem 
(pfexp p).p = 1
proof p = p |^ 1 by NEWTON:10; hence thesis by t23a; end;

theorem t21a:
a <> 0 implies support pfexp (p|^a) = {p}
proof  set f = pfexp (p|^a);  assume
a0: a <> 0;
  thus support f c= {p}
  proof  let x be set; assume
a3:   x in support f;
    then reconsider x as Prime by t51;
b1: f.x <> 0 by a3,POLYNOM1:def 7;
a5: x <> 1 by INT_2:def 5;
     f.x = x |-count (p|^a) by def1;  then x divides p|^a by a5,b1,t83;
     then x = p by t76;
    hence thesis by TARSKI:def 1;
  end;
  let x be set;  assume x in {p};  then
a1: x = p by TARSKI:def 1;
   p divides p|^a by a0,t40; then f.p <> 0 by t45;
  hence thesis by a1,POLYNOM1:def 7;
end;
  
theorem t21:
support pfexp p = {p}
proof  p = p |^ 1 by NEWTON:10;  hence thesis by t21a; end;

registration
  let p be Prime;
  let a be non empty natural number;
  cluster support pfexp (p|^a) -> non empty trivial;
coherence proof support pfexp (p|^a) = {p} by t21a;  hence thesis; end;
end;

registration
  let p be Prime;
  cluster support pfexp p -> non empty trivial;
coherence proof  support pfexp p = {p} by t21;  hence thesis; end;
end;

theorem t30a:
for a, b being non empty Nat
 st a,b are_relative_prime holds support pfexp a misses support pfexp b
proof  let a, b be non empty Nat; assume a,b are_relative_prime;
  then
a0: a hcf b = 1 by INT_2:def 6;
  set f = pfexp a;  set g = pfexp b;
  assume support f meets support g; then consider x being set such that
a1: x in support f and
a2: x in support g by XBOOLE_0:3;
  reconsider x as Prime by a1,t51;
b1: f.x <> 0 by a1,POLYNOM1:def 7;
a4: f.x = x |-count a by def1;
a5: x <> 1 by INT_2:def 5;
a6: x |^ (x |-count a) divides a by a5,def0;
  x divides x |^ (x |-count a) by b1,a4,t40; then
b4: x divides a by a6,NAT_1:51;
b2: g.x <> 0 by a2,POLYNOM1:def 7;
b3: g.x = x |-count b by def1;
a7: x |^ (x |-count b) divides b by a5,def0;
  x divides x |^ (x |-count b) by b2,b3,t40;
  then x divides b by a7,NAT_1:51; then x divides 1 by a0,b4,NAT_1:def 5;
  hence contradiction by a5,WSIERP_1:20;
end;

theorem t30c:
for a,b being non empty natural number
  holds support pfexp a c= support pfexp (a*b)
proof  let a, b be non empty natural number;
  set f = pfexp a;  set h = pfexp (a*b);
  let x be set; assume
a1: x in support f;  then reconsider x as Prime by t51;
b1:f.x <> 0 by a1,POLYNOM1:def 7;
a3: x <> 1 by INT_2:def 5;  then
a5: x |^ (x |-count a) divides a by def0;
  f.x = x |-count a by def1; then x divides x |^ (x |-count a) by b1,t40;
  then x divides a by a5,NAT_1:51; then x |^ 1 divides a by NEWTON:10; then
a4: x |^ (0+1) divides a*b by NAT_1:56;
  h.x = x |-count (a*b) by def1; then h.x <> 0 by a3,a4,def0;
  hence thesis by POLYNOM1:def 7;
end;

theorem t30b:
for a, b being non empty Nat
 holds support pfexp (a*b) = support pfexp a \/ support pfexp b
proof  let a, b be non empty Nat;
  set f = pfexp a;  set g = pfexp b;  set h = pfexp (a*b);
  thus support h c= support f \/ support g
  proof let x be set; assume
a1:   x in support h;
    then reconsider x as Prime by t51;
b1: h.x <> 0 by a1,POLYNOM1:def 7;
a3: x <> 1 by INT_2:def 5;
    h.x = x |-count (a*b) by def1;
    then
b2: x divides x |^ (x |-count (a*b)) by b1,t40;
b3: x |^ (x |-count(a*b)) = (x |^ (x |-count a)) * (x |^ (x |-count b)) by t43;
    per cases by b2,b3,NAT_LAT:95;
    suppose x divides x |^ (x |-count a);
    then x divides a by a3,t44;
    then f.x <> 0 by t45;
    then x in support f by POLYNOM1:def 7;
    hence thesis by XBOOLE_0:def 2;
    end;
    suppose x divides x |^ (x |-count b);
    then x divides b by a3,t44;
    then g.x <> 0 by t45;
    then x in support g by POLYNOM1:def 7;
    hence thesis by XBOOLE_0:def 2;
    end;
  end;
  support f c= support h & support g c= support h by t30c; 
  hence thesis by XBOOLE_1:8;
end;

theorem
for a, b being non empty Nat st a,b are_relative_prime
 holds card support pfexp (a*b) =  card support pfexp a + card support pfexp b
proof let a, b be non empty Nat;  assume
  a,b are_relative_prime;  then
a2:support pfexp a misses support pfexp b by t30a;
  support pfexp (a*b) = support pfexp a \/ support pfexp b by t30b;
  hence thesis by a2,CARD_2:53;
end;

theorem
for a, b being non empty natural number
 holds support pfexp a = support pfexp (a|^b)
proof  let a, b be non empty natural number;
  set f = pfexp a;  set g = pfexp (a|^b);
a4: a is Nat & b is Nat by ORDINAL2:def 21;
  a|^b = a|^(b-'1) * a by a4,PEPIN:27;
  hence support f c= support g by t30c;
  let x be set;  assume
b1: x in support g;
  then reconsider x as Prime by t51;
b3: g.x <> 0 by b1,POLYNOM1:def 7;
b4: g.x = x |-count (a|^b) by def1;
  x <> 1 by INT_2:def 5; then
c1: x divides a|^b by b3,b4,t83;
  now
    assume f.x = 0; then not x divides a by t45;
    hence contradiction by c1,t85;
  end;
  hence thesis by POLYNOM1:def 7;
end;

  reserve n, m for non empty natural number;

theorem
pfexp (n*m) = pfexp n + pfexp m
proof
for i being set st i in SetPrimes holds (pfexp (n*m)).i = (pfexp n + pfexp m).i
  proof
    let i be set;
    assume i in SetPrimes;
    then reconsider a = i as Prime by NAT_LAT:def 17;
    thus (pfexp (n*m)).i = a |-count (n*m) by def1
      .= (a |-count n) + (a |-count m) by t50
      .= (pfexp n).i + (a |-count m) by def1
      .= (pfexp n).i + (pfexp m).i by def1
      .= (pfexp n + pfexp m).i by POLYNOM1:def 5;
  end;
  hence thesis by PBOOLE:3;
end;

theorem
m divides n implies pfexp (n div m) = pfexp n -' pfexp m
proof
  assume
a0: m divides n;
  for i being set st i in SetPrimes holds
    (pfexp (n div m)).i = (pfexp n -' pfexp m).i
  proof
    let i be set;
    assume i in SetPrimes;
    then reconsider a = i as Prime by NAT_LAT:def 17;
    thus (pfexp (n div m)).i = a |-count (n div m) by def1
      .= (a |-count n) -' (a |-count m) by a0,t500
      .= (pfexp n).i -' (a |-count m) by def1
      .= (pfexp n).i -' (pfexp m).i by def1
      .= (pfexp n -' pfexp m).i by POLYNOM1:def 6;
  end;
  hence thesis by PBOOLE:3;
end;

theorem
pfexp (n|^a) = a * pfexp n
proof
  for i being set st i in SetPrimes holds (pfexp (n|^a)).i = (a * pfexp n).i
  proof
    let i be set;
    assume i in SetPrimes;
    then reconsider x = i as Prime by NAT_LAT:def 17;
    thus (pfexp (n|^a)).i = x |-count (n|^a) by def1
       .= a * (x |-count n) by x10
       .= a * (pfexp n).i by def1
       .= (a * pfexp n).i by def5;
  end;
  hence thesis by PBOOLE:3;
end;  
  
theorem pfexpsup1:
support pfexp n = {} implies n = 1
proof assume that
A: support pfexp n = {} and
B: n <> 1;
   n > 0 by NAT_1:19;
   then n >= 0+1 by NAT_1:38; then n > 1 by B, REAL_1:def 5;
   then n >= 1+1 & n is Nat by ORDINAL2:def 21, NAT_1:38;
   then consider p being Nat such that
C: p is prime and
D: p divides n by INT_2:48;
E: p > 1 by C, INT_2:def 5;
   p |-count n <> 0 by t83, D, E;
   then (pfexp n).p <> 0 by C, def1;
 hence contradiction by A, POLYNOM1:def 7;
end;
  
theorem
for m, n being non empty Nat holds pfexp (n hcf m) = min(pfexp n, pfexp m)
proof let m, n be non empty Nat;
  now let i be set; assume i in SetPrimes; then
    reconsider j = i as Prime by NAT_LAT:def 17;
    set lhs = pfexp (n hcf m); set rhs = min(pfexp n, pfexp m);
    set x = j |-count n, y = j |-count m, z = j |-count (n hcf m);
    j1: j <> 1 by INT_2:def 5;
    n0: n hcf m <> 0 by INT_2:5;  
    A1: lhs.j = z by def1;
    A1a: j |^ z divides (n hcf m) by j1, n0, def0;
    A1b: not j |^ (z+1) divides (n hcf m) by j1, n0, def0;
    B1: (pfexp n).j = x by def1;
    B1a: j |^ x divides n by j1, def0;
    B1b: not j |^ (x+1) divides n by j1, def0;
    C1: (pfexp m).j = y by def1;
    C1a: j |^ y divides m by j1, def0;
    C1b: not j |^ (y+1) divides m by j1, def0;
    D1: n hcf m divides m by NAT_1:def 5;
    D1a: n hcf m divides n by NAT_1:def 5;    
    E1: j |^ z divides m by A1a, D1, NAT_1:51;
    E1a: j |^ z divides n by A1a, D1a, NAT_1:51;    
     thus lhs.i = rhs.i proof
      per cases;
      suppose S2: (pfexp n).j <= (pfexp m).j; then
      A2: rhs.j = x by B1, dmin;
      B2: z <= x by E1a, B1b, div1;
          now assume AA: z < x; 
          D3: j |^ (z+1) divides n by AA, B1a, div1;
              z < y by S2, AA, C1, B1, AXIOMS:22; then
              j |^ (z+1) divides m by C1a, div1;
           hence contradiction by D3, NAT_1:def 5, A1b;
          end;
       hence thesis by A2, A1, B2, AXIOMS:21;
       end;
      suppose S2: (pfexp n).j > (pfexp m).j; then
      A2: rhs.j = y by C1, dmin;
      B2: z <= y by E1, C1b, div1;
          now assume AA: z < y; 
          D3: j |^ (z+1) divides m by AA, C1a, div1;
              z < x by S2, AA, C1, B1, AXIOMS:22; then
              j |^ (z+1) divides n by B1a, div1;
           hence contradiction by D3, NAT_1:def 5, A1b;
          end;
       hence thesis by A2, A1, B2, AXIOMS:21;
       end;
     end;
  end;
  hence pfexp (n hcf m) = min(pfexp n, pfexp m) by PBOOLE:3;
end;

theorem
for m, n being non empty Nat holds pfexp (n lcm m) = max(pfexp n, pfexp m)
proof let m, n be non empty Nat;
  now let i be set; assume i in SetPrimes; then
    reconsider j = i as Prime by NAT_LAT:def 17;
    set lhs = pfexp (n lcm m); set rhs = max(pfexp n, pfexp m);
    set x = j |-count n, y = j |-count m, z = j |-count (n lcm m);
    j1: j > 1 by INT_2:def 5;
    n0: n lcm m <> 0 by INT_2:4;  
    A1: lhs.j = z by def1;
    A1a: j |^ z divides (n lcm m) by j1, n0, def0;
    A1b: not j |^ (z+1) divides (n lcm m) by j1, n0, def0;
    B1: (pfexp n).j = x by def1;
    B1a: j |^ x divides n by j1, def0;
    B1b: not j |^ (x+1) divides n by j1, def0;
    C1: (pfexp m).j = y by def1;
    C1a: j |^ y divides m by j1, def0;
    C1b: not j |^ (y+1) divides m by j1, def0;
    D1: m divides n lcm m by NAT_1:def 4;
    D1a: n divides n lcm m by NAT_1:def 4;    
    E1: j |^ y divides n lcm m by C1a, D1, NAT_1:51;
    E1a: j |^ x divides n lcm m by B1a, D1a, NAT_1:51;    
     thus lhs.i = rhs.i proof
      per cases;
      suppose S2: (pfexp n).j <= (pfexp m).j; then
      A2: rhs.j = y by C1, dmax;
      B2: y <= z by E1, A1b, div1;
          now assume AA: y < z; 
          D3: j |^ (y+1) divides n lcm m by AA, A1a, div1;
              consider k being Nat such that
          E3: n lcm m = (j |^ (y+1))*k by D3, NAT_1:def 3;
          E3a: n lcm m = (j |^ y)*j*k by E3, NEWTON:11
                      .= (j |^ y)*(k*j);
               0 <> k by E3, INT_2:4; then
          H3: 0 < k by NAT_1:19;
          K3: 0 < j |^ y by NAT_1:19; then
          J3: 0*k < (j |^ y)*k by H3, REAL_1:70;
              consider t being Nat such that
          L3: n = (j |^ x) * t by B1a, NAT_1:def 3;
              consider u being Nat such that
          M3: n lcm m = n*u by D1a, NAT_1:def 3;
               consider p being Nat such that
          F3b: y = x+p by S2, C1, B1, NAT_1:28;
          F3c: j |^ (x+p) = (j |^x)*(j |^ p) by NEWTON:13; 
              (j |^ x)*((j |^ p) *(k*j)) = (j |^ x)*(t*u)
                by F3b, F3c, M3, L3, E3a, XCMPLX_1:4; then
              (j |^p)*k*j = t*u by XCMPLX_1:5; then
          N3: j divides t*u by NAT_1:def 3;
              now assume j divides t; then consider w being Nat such that
              A4: t = j*w by NAT_1:def 3;
                  n = (j |^ x) * j * w by A4, L3
                   .= (j |^ (x+1)) * w by NEWTON:11;
                hence contradiction by NAT_1:def 3, B1b;
              end; then
              j divides u by N3, NAT_LAT:95; then
              consider w being Nat such that
          O3: u = j*w by NAT_1:def 3;
              (j |^ y)*k*j = n*w*j by O3, E3a, M3, XCMPLX_1:4; then
              (j |^ y)*k = n*w by XCMPLX_1:5; then
          F3: n divides (j |^ y)*k by NAT_1:def 3;
              consider t being Nat such that
          L3: m = (j |^ y) * t by C1a, NAT_1:def 3;
              consider u being Nat such that
          M3: n lcm m = m*u by D1, NAT_1:def 3;
              (j |^ y)*(k*j) = (j |^ y)*(t*u) by M3, L3, E3a, XCMPLX_1:4;
              then k*j = t*u by XCMPLX_1:5; then
          N3: j divides t*u by NAT_1:def 3;
              now assume j divides t; then consider w being Nat such that
              A4: t = j*w by NAT_1:def 3;
                  m = (j |^ y) * j * w by A4, L3
                   .= (j |^ (y+1)) * w by NEWTON:11;
                hence contradiction by NAT_1:def 3, C1b;
              end; then
              j divides u by N3, NAT_LAT:95; then
              consider w being Nat such that
          O3: u = j*w by NAT_1:def 3;
              (j |^ y)*k*j = m*w*j by O3, E3a, M3, XCMPLX_1:4; then
              (j |^ y)*k = m*w by XCMPLX_1:5; then
              m divides (j |^ y)*k by NAT_1:def 3;
              then n lcm m divides (j |^ y)*k by F3, NAT_1:def 4; then
              (j |^ (y+1))*k <= (j |^ y)*k by J3, E3, NAT_1:54; then
              j |^ (y+1) <= j |^ y by H3, REAL_1:70; then
              (j |^ y) * j <= (j |^ y)*1 by NEWTON:11; then
              j <= 1 by K3, REAL_1:70;
           hence contradiction by INT_2:def 5;
          end;
       hence thesis by A2, A1, B2, AXIOMS:21;
       end;
      suppose S2: (pfexp n).j > (pfexp m).j; then
      A2: rhs.j = x by B1, dmax;
      B2: x <= z by E1a, A1b, div1;
          now assume AA: x < z; 
          D3: j |^ (x+1) divides n lcm m by AA, A1a, div1;
              consider k being Nat such that
          E3: n lcm m = (j |^ (x+1))*k by D3, NAT_1:def 3;
          E3a: n lcm m = (j |^ x)*j*k by E3, NEWTON:11
                      .= (j |^ x)*(k*j);
               0 <> k by E3, INT_2:4; then
          H3: 0 < k by NAT_1:19;
          K3: 0 < (j |^ x) by NAT_1:19; then
          J3: 0*k < (j |^ x)*k by H3, REAL_1:70;
              consider t being Nat such that
          L3: m = (j |^ y) * t by C1a, NAT_1:def 3;
              consider u being Nat such that
          M3: n lcm m = m*u by D1, NAT_1:def 3;
               consider p being Nat such that
          F3b: x = y+p by S2, C1, B1, NAT_1:28;
          F3c: j |^ (y+p) = (j |^y)*(j |^ p) by NEWTON:13; 
              (j |^ y)*((j |^ p) *(k*j)) = (j |^ y)*(t*u)
                by F3b, F3c, M3, L3, E3a, XCMPLX_1:4; then
              (j |^p)*k*j = t*u by XCMPLX_1:5; then
          N3: j divides t*u by NAT_1:def 3;
              now assume j divides t; then consider w being Nat such that
              A4: t = j*w by NAT_1:def 3;
                  m = (j |^ y) * j * w by A4, L3
                   .= (j |^ (y+1)) * w by NEWTON:11;
                hence contradiction by NAT_1:def 3, C1b;
              end; then j divides u by N3, NAT_LAT:95; then
              consider w being Nat such that
          O3: u = j*w by NAT_1:def 3;
              (j |^ x)*k*j = m*w*j by O3, E3a, M3, XCMPLX_1:4; then
              (j |^ x)*k = m*w by XCMPLX_1:5; then
          F3: m divides (j |^ x)*k by NAT_1:def 3;
              consider t being Nat such that
          L3: n = (j |^ x) * t by B1a, NAT_1:def 3;
              consider u being Nat such that
          M3: n lcm m = n*u by D1a, NAT_1:def 3;
              (j |^ x)*(k*j) = (j |^ x)*(t*u) by M3, L3, E3a, XCMPLX_1:4;
              then k*j = t*u by XCMPLX_1:5; then
          N3: j divides t*u by NAT_1:def 3;
              now assume j divides t; then consider w being Nat such that
              A4: t = j*w by NAT_1:def 3;
                  n = (j |^ x) * j * w by A4, L3
                   .= (j |^ (x+1)) * w by NEWTON:11;
                hence contradiction by NAT_1:def 3, B1b;
              end; then j divides u by N3, NAT_LAT:95; then
              consider w being Nat such that
          O3: u = j*w by NAT_1:def 3;
              (j |^ x)*k*j = n*w*j by O3, E3a, M3, XCMPLX_1:4; then
              (j |^ x)*k = n*w by XCMPLX_1:5; then
          G3: n divides (j |^ x)*k by NAT_1:def 3;
              n lcm m divides (j |^ x)*k by F3, G3, NAT_1:def 4; then
              (j |^ (x+1))*k <= (j |^ x)*k by J3, E3, NAT_1:54; then
              j |^ (x+1) <= j |^ x by H3, REAL_1:70; then
              (j |^ x) * j <= (j |^ x)*1 by NEWTON:11; then
              j <= 1 by K3, REAL_1:70;
           hence contradiction by INT_2:def 5;
          end;
       hence thesis by A2, A1, B2, AXIOMS:21;
     end;
     end;
  end;
  hence pfexp (n lcm m) = max(pfexp n, pfexp m) by PBOOLE:3;
end;

begin :: Prime-power factorization

definition
  let n be non empty natural number;
  func prime_factorization n -> ManySortedSet of SetPrimes means :Lppf:
  support it = support pfexp n &
  for p being natural number st p in support pfexp n holds
    it.p = p |^ (p |-count n);
  existence proof
   defpred P[set,set] means
   for p being Prime st $1 = p holds
     (p in support pfexp n implies $2 = p |^ (p |-count n)) &
     (not p in support pfexp n implies $2 = 0);
A: for x,y1,y2 being set st x in SetPrimes & P[x,y1] & P[x,y2] holds y1 = y2
   proof let x,y1,y2 be set such that
   A1: x in SetPrimes and
   B1: P[x,y1] and
   C1: P[x,y2];
       reconsider p = x as Prime by A1, NAT_LAT:def 17;   
     (p in support pfexp n implies y1 = p |^ (p |-count n)) &
     (not p in support pfexp n implies y1 = 0) by B1;
    hence y1 = y2 by C1;
   end;
B: for x being set st x in SetPrimes ex y being set st P[x,y] proof
     let x be set such that
   A1: x in SetPrimes;
       reconsider i = x as Prime by A1, NAT_LAT:def 17;       
     per cases;
     suppose S1: i in support pfexp n;
       take i |^ (i |-count n);
       let p be Prime; assume p = x;
      hence thesis by S1;
     end;
     suppose S1: not i in support pfexp n;
      take 0;
      let p be Prime; assume p = x;
      hence thesis by S1;
     end;
   end;
   consider f being Function such that
K: dom f = SetPrimes and
L: for x being set st x in SetPrimes holds P[x,f.x] from FUNCT_1:sch 2(A, B);
O: support f c= SetPrimes by K, POLYNOM1:41;
PP: now let x be set;
     hereby assume
     A1: x in support f; then
      x in SetPrimes by O; then
         reconsider i = x as Prime by NAT_LAT:def 17;     
      assume not x in support pfexp n;
       then f.i = 0 by O, A1, L;
      hence contradiction by A1, POLYNOM1:def 7;
     end;
     assume
    A1: x in support pfexp n;
        then x in SetPrimes;
        then reconsider i = x as Prime by NAT_LAT:def 17;
        f.i = i |^ (i |-count n) by A1, L;
     hence x in support f by POLYNOM1:def 7;
    end; 
   reconsider f as ManySortedSet of SetPrimes by K, PBOOLE:def 3;
   take f;
   thus support f = support pfexp n by PP,TARSKI:2;
   let p be natural number;
   assume
aa:  p in support pfexp n; then p is Prime by t51;
   hence f.p = p |^ (p |-count n) by aa,L;
  end;
  uniqueness proof let it1, it2 be ManySortedSet of SetPrimes such that
A1: support it1 = support pfexp n and
B1: for p being natural number st p in support pfexp n holds
     it1.p = p|^(p|-count n) and
A2: support it2 = support pfexp n and
B2: for p being natural number st p in support pfexp n holds
     it2.p = p|^(p|-count n);
    now let i be set such that
    A3: i in SetPrimes;
      reconsider p = i as Prime by A3, NAT_LAT:def 17;
     per cases;
     suppose S1: p in support pfexp n;
      thus it1.i = p|^(p|-count n) by S1, B1 .= it2.i by S1, B2;
     end;
     suppose S1: not p in support pfexp n;
      thus it1.i = 0 by A1, S1, POLYNOM1:def 7
        .= it2.i by A2, S1, POLYNOM1:def 7;
      end;
    end; 
   hence it1 = it2 by PBOOLE:3;
  end;
end;

notation
  let n be non empty natural number;
  synonym ppf n for prime_factorization n; :: for prime-power factorization
end;

registration
  let n be non empty natural number;
  cluster ppf n -> natural-yielding finite-support;
coherence
proof
  thus rng ppf n c= NAT
  proof
    let y be set;
    assume y in rng ppf n;
    then consider x being set such that
a1:   x in dom ppf n and
a2:   (ppf n).x = y by FUNCT_1:def 5;
    dom ppf n = SetPrimes by PBOOLE:def 3;
    then reconsider x as Prime by a1,NAT_LAT:def 17;
    per cases;
    suppose x in support pfexp n;
    then (ppf n).x = x |^ (x |-count n) by Lppf;
    hence thesis by a2;
    end;
    suppose not x in support pfexp n;
    then not x in support ppf n by Lppf;
    then (ppf n).x = 0 by POLYNOM1:def 7;
    hence thesis by a2;
    end;
  end;
  support ppf n = support pfexp n by Lppf;
  hence support ppf n is finite;
end;
end;

theorem ppfval0:
p |-count n = 0 implies (ppf n).p = 0
proof assume p |-count n = 0; then (pfexp n).p = 0 by def1;
  then not p in support pfexp n by POLYNOM1:def 7;
  then not p in support ppf n by Lppf;
 hence (ppf n).p = 0 by POLYNOM1:def 7;
end;

theorem ppfvaln0:
p |-count n <> 0 implies (ppf n).p = p |^ (p |-count n)
proof assume p |-count n <> 0; then (pfexp n).p <> 0 by def1;
  then p in support pfexp n by POLYNOM1:def 7;
 hence (ppf n).p = p |^ (p |-count n) by Lppf;
end;

theorem
support ppf n = {} implies n = 1
proof
 assume support ppf n = {};
 then support pfexp n = {} by Lppf;
 hence n = 1 by pfexpsup1;
end;

theorem ppfmult:
for a, b being non empty Nat st a, b are_relative_prime
 holds ppf (a*b) = ppf a + ppf b
proof let a, b be non empty Nat such that
A: a, b are_relative_prime;
   reconsider an = a, bn = b as non empty natural number;
  now let i be set such that
  A1: i in SetPrimes;
      reconsider p = i as Prime by A1, NAT_LAT:def 17;
  B1: p |-count (an*bn) = (p |-count a) + (p |-count b) by t50;
  C1: p > 1 by INT_2:def 5;
  D1: a hcf b = 1 by A, INT_2:def 6;
   per cases;
   suppose S1: p |-count (a*b) = 0; then
   A2: (p |-count a) = 0 & (p |-count b) = 0 by B1, NAT_1:23;
    thus (ppf (a*b)).i = 0 by S1, ppfval0
     .= 0 + (ppf b).i by A2, ppfval0
     .= (ppf a).i + (ppf b).i by A2, ppfval0
     .= (ppf a + ppf b).i by POLYNOM1:def 5;
   end;
   suppose S1: p |-count (a*b) <> 0;
    thus (ppf (a*b)).i = (ppf a + ppf b).i proof
    per cases by S1, B1;
    suppose A2: (p |-count a) <> 0;
    A2a: now assume
        A3: (p |-count b) <> 0;
            consider kb being Nat such that
        B3: (p |-count b) = kb+1 by A3, NAT_1:22;
            p |^ (p |-count b) divides b by C1, def0; then
            p*(p|^kb) divides b by B3, NEWTON:11; then
            consider lb being Nat such that
        C3: b = p*(p|^kb)*lb by NAT_1:def 3;
            b = p*((p|^kb)*lb) by C3; then
        D3: p divides b by NAT_1:def 3;
            consider ka being Nat such that
        B3a: (p |-count a) = ka+1 by A2, NAT_1:22;
            p |^ (p |-count a) divides a by C1, def0; then
            p*(p|^ka) divides a by B3a, NEWTON:11; then
            consider la being Nat such that
        C3a: a = p*(p|^ka)*la by NAT_1:def 3;
             a = p*((p|^ka)*la) by C3a; then
             p divides a by NAT_1:def 3; then
             p divides 1 by D1, D3, NAT_1:def 5;
         hence contradiction by C1, NAT_1:54;
        end;
     thus (ppf (a*b)).i = p |^ (p |-count a) by A2a, B1, S1, ppfvaln0
       .= (ppf a).p + 0 by A2, ppfvaln0
       .= (ppf a).p + (ppf b).p by A2a, ppfval0
       .= (ppf a + ppf b).i by POLYNOM1:def 5;
    end;
    suppose S2: (p |-count b) <> 0;
    A2: now assume
        A3: (p |-count a) <> 0;
            consider kb being Nat such that
        B3: (p |-count b) = kb+1 by S2, NAT_1:22;
            p |^ (p |-count b) divides b by C1, def0; then
            p*(p|^kb) divides b by B3, NEWTON:11; then
            consider lb being Nat such that
        C3: b = p*(p|^kb)*lb by NAT_1:def 3;
            b = p*((p|^kb)*lb) by C3; then
        D3: p divides b by NAT_1:def 3;
            consider ka being Nat such that
        B3a: (p |-count a) = ka+1 by A3, NAT_1:22;
            p |^ (p |-count a) divides a by C1, def0; then
            p*(p|^ka) divides a by B3a, NEWTON:11; then
            consider la being Nat such that
        C3a: a = p*(p|^ka)*la by NAT_1:def 3;
             a = p*((p|^ka)*la) by C3a; then
             p divides a by NAT_1:def 3; then
             p divides 1 by D1, D3, NAT_1:def 5;
         hence contradiction by C1, NAT_1:54;
        end;
     thus (ppf (a*b)).i = p |^ (p |-count b) by A2, B1, S1, ppfvaln0
       .= 0+(ppf b).p by S2, ppfvaln0
       .= (ppf a).p + (ppf b).p by A2, ppfval0
       .= (ppf a + ppf b).i by POLYNOM1:def 5;
    end;
    end;
   end;
  end;
 hence ppf (a*b) = ppf a + ppf b by PBOOLE:3;
end;

theorem ppfsing:
(ppf (p |^ n)).p = p |^ n
proof
  p > 1 by INT_2:def 5; then
  p |-count (p |^ n) = n by t70;
 hence (ppf (p |^ n)).p = p |^ n by ppfvaln0;
end;

theorem
ppf (n|^m) = (ppf n) |^ m
proof
 now let i be set; assume
  i in SetPrimes; then
     reconsider p = i as Prime by NAT_LAT:def 17;
     m > 0 by NAT_1:19; then 
 B: m >= 0+1 by NAT_1:38;
 A1: p |-count (n |^ m) = m * (p |-count n) by x10;
 B1: ((ppf n) |^ m).i = (ppf n).i |^ m by Lbagexp;
  per cases;
  suppose S1: p |-count n = 0;
    thus (ppf (n|^m)).i = 0 by A1, S1, ppfval0
      .= 0 |^ m by B, NEWTON:16 
      .= ((ppf n) |^ m).i by B1,S1, ppfval0; 
  end;
  suppose S1: p |-count n <> 0;
  C1: p |-count (n |^ m) <> 0 by A1, S1, XCMPLX_1:6;
   thus (ppf (n|^m)).i = p |^ (p |-count (n |^ m)) by C1, ppfvaln0
     .= (p |^ (p |-count n)) |^ m by A1, NEWTON:14
     .= ((ppf n) |^ m).i by B1, S1, ppfvaln0;
  end;
 end;
 hence thesis by PBOOLE:3;
end;

theorem
Product ppf n = n
proof
  defpred P[natural number] means
  for n being non empty natural number
   st support ppf n c= Seg $1 holds Product ppf n = n;
A: P[0] proof let n be non empty natural number;
       assume
   LL:   support ppf n c= Seg 0;
       {} c= support ppf n by XBOOLE_1:2; then
   D1: support ppf n = {} by LL, FINSEQ_1:4, XBOOLE_0:def 10; then
   C1: ppf n = EmptyBag SetPrimes by BAGORDER:20;
       now
         reconsider k = n as Nat by ORDINAL2:def 21;
         assume n <> 1; then k > 1 by UPROOTS:1; then k >=1+1 by NAT_1:38; then
             consider p being Nat such that
         A2: p is prime and
         B2: p divides k by INT_2:48;
           support pfexp n is non empty by A2, B2, t51b;
        hence contradiction by D1, Lppf;
       end;
     hence Product ppf n = n by C1, ProdEB;
   end;
B: for k being natural number st P[k] holds P[k+1] proof
    let k be natural number; assume
   IH: P[k];
    let n be non empty natural number such that
   A1: support ppf n c= Seg (k+1);
   D: support ppf n = support pfexp n by Lppf;
    per cases;
    suppose S: not support ppf n c= Seg k;
    B1: now assume
        A2: not k+1 in support ppf n;
            support ppf n c= Seg k proof let x be set; assume
            A3: x in support ppf n; then 
            B3: x is Prime by D, t51;
            reconsider m = x as natural number by A3, D, t51;
            C3: 1 <= m by B3, INT_2:def 5; 
                m <= k+1 by A1, A3, FINSEQ_1:3; then
                m < k+1 by A3, A2, REAL_1:def 5; then m <= k by NAT_1:38;
             hence x in Seg k by C3, FINSEQ_1:3;
            end;
         hence contradiction by S;
        end;
        set p = k+1; set e = p |-count n; set s = p |^ e;
     C1: p is Prime by B1, D, t51; then
     D1: (pfexp n).p = e by def1; 
     E1: p > 1 by C1, INT_2:def 5; then
         s divides n by def0; then consider t being Nat such that
     F1: n = s * t by NAT_1:def 3;
         set t1 = t;
         reconsider s, t as non empty natural number by F1, XCMPLX_1:6;
     F1a: support ppf t = support pfexp t by Lppf; 
     J1: support ppf t c= Seg k proof let x be set; assume
         A3: x in support ppf t; then
         A3a: x in support pfexp t by Lppf; then
         B3: x is Prime by t51; reconsider m = x as natural number by A3a,t51;
         C3: 1 <= m by B3, INT_2:def 5;
             support ppf t c= support ppf n by F1, F1a, D, t30c; then
             m in support ppf n by A3; then 
         E3: m <= k+1 by A1, FINSEQ_1:3;
             set f = p |-count t;
             now assume
             AA: m = p; 
             A4: (pfexp t).p = f by C1, def1;
                 f <> 0 by AA, A4, A3a, POLYNOM1:def 7; then
                 f > 0 by NAT_1:19; then f >= 0+1 by NAT_1:38; then
                 consider g being Nat such that
             B4: f = 1+g by NAT_1:28;
                 p |^ f divides t by E1, def0; then
                 consider u being Nat such that
             C4: t = (p |^ f)*u by NAT_1:def 3;
             D4: n = s * (((p |^ g)*p)*u) by B4, F1, C4, NEWTON:11
                  .= s*p *((p |^ g)*u)
                  .= (p |^ (e+1))*((p |^ g)*u) by NEWTON:11;
                  (p |^ g)*u is Nat by ORDINAL2:def 21; then
                 p |^ (e+1) divides n by D4, NAT_1:def 3;
                 hence contradiction by E1, def0;
                end;  then m < p by E3, REAL_1:def 5; then m <= k by NAT_1:38;
             hence x in Seg k by C3, FINSEQ_1:3;
         end;
     J1b: e <> 0 by D1, B1, D, POLYNOM1:def 7;
          support ppf s = support pfexp s by Lppf; then
     J1a: support ppf s = {p} by  J1b, C1, t21a;
         now assume (support ppf s) /\ (support ppf t) <> {}; then
             consider x being set such that
         A2: x in (support ppf s) /\ support ppf t by XBOOLE_0:def 1;
         C2: x in  support ppf s by A2, XBOOLE_0:def 3;
         D2: x in support ppf t by A2, XBOOLE_0:def 3;
             x = p by J1a, C2, TARSKI:def 1; then
             p <= k by D2, J1, FINSEQ_1:3;
          hence contradiction by NAT_1:38;
         end; then
     G1: support ppf s misses support ppf t by XBOOLE_0:def 7;
         reconsider s1 = s, t1 = t as non empty Nat by ORDINAL2:def 21;
         s1,t1 are_relative_prime proof assume
         A2: s1 hcf t1 <> 1;
             set u = s1 hcf t1;
         D2: u divides s1 by NAT_1:def 5;
             u <> 0 by INT_2:5; then 0 < u by NAT_1:19; then
             0+1 <= u by NAT_1:38; then u > 1 by A2, REAL_1:def 5; then
             u >= 1+1 by NAT_1:38; then
             consider r being Nat such that
         B2: r is prime and
         C2: r divides u by INT_2:48;
             r divides s1 by C2, D2, NAT_1:51; then
             r divides p by B2, t85; then
         H1: r = 1 or r = p by C1, INT_2:def 5;
             u divides t1 by NAT_1:def 5; then
             p divides t1 by C2, H1, B2, INT_2:def 5, NAT_1:51; then
             p in support pfexp t by C1, t51b; then
             k+1 <= k by F1a, J1, FINSEQ_1:3; 
          hence contradiction by NAT_1:38;
         end; then
     H1: ppf n = ppf s + ppf t by F1, ppfmult;
         consider f being FinSequence of NAT such that
     I1a: Product ppf s = Product f and
     I1b: f = (ppf s)*canFS(support ppf s) by Lbagprod;
     I1c: dom ppf s = SetPrimes by PBOOLE:def 3; 
          f = (ppf s)*<*p*> by J1a, I1b, UPROOTS:6
           .= <* (ppf s).p *> by I1c, B1, CIRCCMB3:36; then
     I1: Product ppf s = (ppf s).p by I1a, RVSUM_1:125
         .= s by J1b, C1, ppfsing;
         Product ppf t = t by IH, J1;
     hence Product ppf n = n by F1, G1, H1, I1, Prodsum;
    end;
    suppose support ppf n c= Seg k;
     hence Product ppf n = n by IH;
    end;
   end;
C: for k being natural number holds P[k] from NAT_1:sch 2(A,B);
D: support ppf n = support pfexp n by Lppf;
   per cases;
   suppose support ppf n is empty;
    hence thesis by A, FINSEQ_1:4;
   end;
   suppose support ppf n is non empty;
     then reconsider S = support ppf n as finite non empty Subset of NAT
      by XBOOLE_1:1;
      support ppf n c= Seg max S proof let x be set; assume
      A1: x in support ppf n; then
      C1: x is Prime by D, t51;
          reconsider m = x as natural number by A1, D, t51;
      Z1: 1 <= m by C1, INT_2:def 5;
          m <= max S by A1, PRE_CIRC:def 1;
        hence x in Seg max S by Z1, FINSEQ_1:3;
      end;
    hence thesis by C;
   end;
end;
