:: Fundamental {T}heorem of {A}rithmetic
::  by Artur Korni{\l}owicz and Piotr Rudnicki
::
:: Received February 13, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabularies GROUP_1, ARYTM_3, ORDINAL2, ARYTM, POLYNOM1, FILTER_0, FUNCT_1,
      FINSEQ_1, ALGSEQ_1, CARD_3, FINSET_1, ARYTM_1, BOOLE, PBOOLE, NAT_1,
      RELAT_1, NAT_LAT, FUNCOP_1, CARD_1, SEQ_1, REALSET1, SQUARE_1, FINSEQ_2,
      UPROOTS, FUNCT_2, SETWISEO, SGRAPH1, NAT_3, COMPLEX1, XCMPLX_0, COMPLSP1,
      VALUED_0, INT_2;
 notations TARSKI, XBOOLE_0, SUBSET_1, FINSET_1, REALSET1, ORDINAL1, CARD_1,
      NUMBERS, XCMPLX_0, XXREAL_0, REAL_1, NAT_D, INT_2, RELAT_1, FUNCT_1,
      FUNCT_2, FINSEQ_1, VALUED_0, SEQ_1, SEQM_3, PBOOLE, POLYNOM1, POLYNOM2,
      RVSUM_1, NAT_1, NEWTON, WSIERP_1, BINARITH, TREES_4, UPROOTS, BINOP_2,
      FUNCOP_1, XXREAL_2, SETWOP_2;
 constructors BINOP_1, SETWISEO, XXREAL_0, NAT_D, FINSEQOP, FINSOP_1, NEWTON,
      REALSET1, BINARITH, WSIERP_1, FACIRC_1, POLYNOM2, UPROOTS,
      SEQ_1, RECDEF_1, BINOP_2, XXREAL_2, RELSET_1;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FINSET_1, NUMBERS,
      XCMPLX_0, XXREAL_0, XREAL_0, NAT_1, INT_1, BINOP_2, MEMBERED, NEWTON,
      PRE_CIRC, TEX_2, POLYNOM1, SEQM_3, VALUED_0, FINSEQ_1, XXREAL_2, CARD_1,
      REALSET1, UPROOTS, FUNCT_2, RELSET_1, ZFMISC_1, FINSEQ_2;
 requirements NUMERALS, SUBSET, ARITHM, REAL, BOOLE;
 definitions TARSKI, XBOOLE_0, INT_2, NAT_D, FINSEQ_1, POLYNOM1, FINSEQ_2,
      VALUED_0;
 theorems ORDINAL1, NEWTON, NAT_1, XCMPLX_1, INT_1, CARD_4, XREAL_0, RVSUM_1,
      INT_2, PEPIN, PBOOLE, FUNCT_1, CARD_2, PREPOWER, POLYNOM1, FINSEQ_1,
      TARSKI, XBOOLE_1, FUNCOP_1, WSIERP_1, XBOOLE_0, RADIX_1, BAGORDER,
      FINSEQ_2, FINSEQ_3, FINSEQ_4, RELAT_1, UPROOTS, CIRCCMB3, FINSOP_1,
      FUNCT_2, XREAL_1, XXREAL_0, NAT_D, VALUED_0, XXREAL_2, PARTFUN1;
 schemes NAT_1, PRE_CIRC, FINSEQ_1, FINSEQ_2, PBOOLE, CLASSES1;

begin :: Preliminaries

reserve a, b, n for natural number,
  r for Real,
  f for FinSequence of REAL;

registration
  cluster natural-valued FinSequence;
  existence
  proof
    consider f being FinSequence of NAT;
    take f;
    thus thesis;
  end;
end;

registration
  let a be non empty natural number;
  let b be natural number;
  cluster a |^ b -> non empty;
  coherence
  proof
    a is Real & b in NAT by ORDINAL1:def 13,XREAL_0:def 1;
    hence thesis by CARD_4:51;
  end;
end;

registration
  cluster -> non empty Prime;
  coherence by INT_2:def 5;
end;

reserve p for Prime;

theorem Th1:
  for a, b, c, d being natural number st a divides c & b divides d
  holds a*b divides c*d
proof
  let a, b, c, d be natural number;
  given x being Nat such that
A1: c = a*x;
  given y being Nat such that
A2: d = b*y;
  take x*y;
  thus thesis by A1,A2;
end;

theorem Th2:
  1 < a implies b <= a |^ b
proof
  assume
A1: 1 < a;
  then reconsider a1 = a-1 as Element of NAT by INT_1:18;
  defpred P[natural number] means $1 <= a |^ $1;
A2: P[0];
A3: for k being natural number st P[k] holds P[k+1]
  proof
    let k be natural number such that
A4: P[k];
A5: k+1 <= a |^ k + 1 by A4,XREAL_1:8;
A6: a |^ (k+1) = a |^ k * a by NEWTON:11;
    now
      set x = a |^ k;
      assume x + 1 > x * a;
      then x*a - (x+1) < (x+1) - (x+1) by XREAL_1:16;
      then x*a1 - 1 + 1 < 0+1 by XREAL_1:8;
      then x*a1 <= 0 by NAT_1:13;
      then x*a1 = 0;
      then x = 0 or a1 = 0;
      hence contradiction by A1;
    end;
    hence thesis by A5,A6,XXREAL_0:2;
  end;
  for k being natural number holds P[k] from NAT_1:sch 2(A2,A3);
  hence thesis;
end;

theorem Th3:
  a <> 0 implies n divides n |^ a
proof
  assume a <> 0;
  then consider b being Nat such that
A1: a = b+1 by NAT_1:6;
  reconsider b as Element of NAT by ORDINAL1:def 13;
  n |^ 1 divides n |^ (b+1) by NAT_1:12,RADIX_1:7;
  hence thesis by A1,NEWTON:10;
end;

theorem Th4:
  for i, j, m, n being natural number
  st i < j & m |^ j divides n holds m |^ (i+1) divides n
proof
  let i, j, m, n be natural number such that
A1: i < j and
A2: m |^ j divides n;
  reconsider i,j,m as Element of NAT by ORDINAL1:def 13;
  i+1 <= j by A1,NAT_1:13;
  then m |^ (i+1) divides m |^ j by RADIX_1:7;
  hence thesis by A2,NAT_D:4;
end;

theorem Th5:
  p divides a |^ b implies p divides a
proof
  assume that
A1: p divides a |^ b and
A2: not p divides a;
  reconsider p,a as Element of NAT by ORDINAL1:def 13;
  defpred P[Nat] means p divides a|^($1+1);
  now
    assume 0+1 > b;
    then b <= 0 by NAT_1:13;
    then b = 0;
    then p divides 1 by A1,NEWTON:9;
    then p = 1 by WSIERP_1:20;
    hence contradiction by INT_2:def 5;
  end;
  then b = b-'1+1 by XREAL_1:237;
  then
A3: ex k being Nat st P[k] by A1;
A4: for k being Nat st k <> 0 & P[k] ex n being Nat st n < k & P[n]
  proof
    let k be Nat such that
A5: k <> 0 and
A6: P[k];
    take k-'1;
    k > 0 by A5;
    then
A7: k >= 0+1 by NAT_1:13;
    then k-1 >= 0+1-1 by XREAL_1:15;
    then k-'1 = k-1 by XREAL_0:def 2;
    then k-'1 < k-0 by XREAL_1:17;
    hence k-'1 < k;
A8: k-'1+1 = k by A7,XREAL_1:237;
    p divides a |^ k * a by A6,NEWTON:11;
    hence thesis by A2,A8,NEWTON:98;
  end;
  P[0] from NAT_1:sch 7(A3,A4);
  hence thesis by A2,NEWTON:10;
end;

theorem Th6:
  for a being Prime st a divides p |^ b holds a = p
proof
  let a be Prime such that
A1: a divides p |^ b;
A2: a <> 1 by INT_2:def 5;
  a divides p by A1,Th5;
  hence thesis by A2,INT_2:def 5;
end;

theorem
  for f being FinSequence of NAT st a in rng f holds a divides Product f
proof
  defpred P[FinSequence of NAT] means
  for a being natural number st a in rng $1 holds a divides Product $1;
A1: P[<*>NAT];
A2: for p being FinSequence of NAT, n being Element of NAT st P[p]
  holds P[p^<*n*>]
  proof
    let p be FinSequence of NAT, n be Element of NAT such that
A3: P[p];
    set p1 = p^<*n*>;
    let a be natural number such that
A4: a in rng p1;
A5: rng p1 = rng p \/ rng <*n*> by FINSEQ_1:44;
A6: Product p1 = Product p * n by RVSUM_1:126;
    per cases by A4,A5,XBOOLE_0:def 3;
    suppose a in rng p;
      hence thesis by A3,A6,NAT_D:9;
    end;
    suppose a in rng <*n*>;
      then a in {n} by FINSEQ_1:56;
      then a = n by TARSKI:def 1;
      hence thesis by A6,NAT_D:9;
    end;
  end;
  for p being FinSequence of NAT holds P[p] from FINSEQ_2:sch 2(A1,A2);
  hence thesis;
end;

theorem
  for f being FinSequence of SetPrimes st p divides Product f holds p in rng f
proof
  defpred P[FinSequence of SetPrimes] means
  for p being Prime st p divides Product $1 holds p in rng $1;
A1: P[<*>SetPrimes]
  proof
    let p being Prime;
    assume p divides Product <*>SetPrimes;
    then p <= 1 by NAT_D:7,RVSUM_1:124;
    hence thesis by INT_2:def 5;
  end;
A2: now
    let f be FinSequence of SetPrimes, n be Element of SetPrimes;
    assume
A3: P[f];
    set f1 = f^<*n*>;
    thus P[f1]
    proof
      let p be Prime;
      assume
A4:   p divides Product f1;
      reconsider ff = f as FinSequence of NAT;
A5:   p divides Product ff * n by A4,RVSUM_1:126;
      reconsider nn = n as Nat;
      per cases by A5,NEWTON:98;
      suppose p divides Product f;
        then
A6:     p in rng f by A3;
        rng f c= rng f1 by FINSEQ_1:42;
        hence thesis by A6;
      end;
      suppose
A7:     p divides nn;
        nn is prime by NEWTON:def 6;
        then p = 1 or p = n by A7,INT_2:def 5;
        then p in {n} by INT_2:def 5,TARSKI:def 1;
        then
A8:     p in rng <*n*> by FINSEQ_1:55;
        rng <*n*> c= rng f1 by FINSEQ_1:43;
        hence thesis by A8;
      end;
    end;
  end;
  for p being FinSequence of SetPrimes holds P[p] from FINSEQ_2:sch 2(A1,A2 );
  hence thesis;
end;

:: Power

definition
  let f be real-valued FinSequence;
  let a be natural number;
  func f |^ a -> FinSequence means
  :Def1:
  len it = len f &
  for i being set st i in dom it holds it.i = f.i |^ a;
  existence
  proof
    deffunc F(Nat) = f.$1 |^ a;
    consider p being FinSequence such that
A1: len p = len f and
A2: for k being Nat st k in dom p holds p.k = F(k) from FINSEQ_1:sch 2;
    take p;
    thus len p = len f by A1;
    let i be set;
    assume
A5: i in dom p;
    thus thesis by A2,A5;
  end;
  uniqueness
  proof
    let g,h be FinSequence such that
A6: len g = len f and
A7: for i being set st i in dom g holds g.i = f.i |^ a and
A8: len h = len f and
A9: for i being set st i in dom h holds h.i = f.i |^ a;
A10: dom g = Seg len g by FINSEQ_1:def 3;
A11: dom h = Seg len h by FINSEQ_1:def 3;
    for k being Nat st k in dom g holds g.k = h.k
    proof
      let k be Nat such that
A12:  k in dom g;
      thus g.k = f.k |^ a by A7,A12
        .= h.k by A6,A8,A9,A10,A11,A12;
    end;
    hence thesis by A6,A8,A10,A11,FINSEQ_1:17;
  end;
end;

registration
  let f be real-valued FinSequence;
  let a be natural number;
  cluster f |^ a -> real-valued;
  coherence
  proof
    set g = f|^a;
    let x be set;
    assume x in dom g;
    then (f |^ a).x = f.x |^ a by Def1;
    hence thesis;
  end;
end;

registration
  let f be natural-valued FinSequence;
  let a be natural number;
  cluster f |^ a -> natural-valued;
  coherence
  proof
    set g = f|^a;
    let x be set;
    assume x in dom g;
    then (f |^ a).x = f.x |^ a by Def1;
    hence thesis;
  end;
end;

definition
  let f be FinSequence of REAL;
  let a be natural number;
  redefine func f |^ a -> FinSequence of REAL;
  coherence
  proof
    thus rng (f|^a) c= REAL;
  end;
end;

definition
  let f be FinSequence of NAT;
  let a be natural number;
  redefine func f |^ a -> FinSequence of NAT;
  coherence
  proof
    thus rng (f|^a) c= NAT by VALUED_0:def 6;
  end;
end;

theorem Th9:
  f |^ 0 = (len f) |-> 1
proof
A1: len (f|^0) = len f by Def1;
A2: len (len f |-> 1) = len f by FINSEQ_1:def 18;
  for k being Nat st 1 <= k & k <= len (f|^0) holds (f|^0).k = (len f |-> 1).k
  proof
    let k be Nat;
    assume
A3: 1 <= k & k <= len (f|^0);
    then
A4: k in dom (f|^0) by FINSEQ_3:27;
    then
A5: k in Seg len f by A1,A3;
    thus (f|^0).k = f.k |^ 0 by A4,Def1
      .= 1 by NEWTON:9
      .= (len f |-> 1).k by A5,FUNCOP_1:13;
  end;
  hence thesis by A1,A2,FINSEQ_1:18;
end;

theorem
  f |^ 1 = f
proof
A1: len (f|^1) = len f by Def1;
  for k being Nat st 1 <= k & k <= len (f|^1) holds (f|^1).k = f.k
  proof
    let k be Nat;
    assume 1 <= k & k <= len (f|^1);
    then k in dom (f|^1) by FINSEQ_3:27;
    hence (f|^1).k = f.k |^ 1 by Def1
      .= f.k by NEWTON:10;
  end;
  hence thesis by A1,FINSEQ_1:18;
end;

theorem Th11:
  <*>REAL |^ a = <*>REAL
proof
  len (<*>REAL |^ a) = len <*>REAL by Def1
    .= 0;
  hence thesis;
end;

theorem Th12:
  <*r*>|^a = <*r|^a*>
proof
A1: len (<*r*>|^a) = len <*r*> by Def1
    .= 1 by FINSEQ_1:57;
  0+1 in Seg (0+1);
  then 1 in dom (<*r*>|^a) by A1,FINSEQ_1:def 3;
  then (<*r*>|^a).1 = (<*r*>.1) |^ a by Def1
    .= r |^ a by FINSEQ_1:57;
  hence thesis by A1,FINSEQ_1:57;
end;

theorem Th13:
  (f^<*r*>) |^ a = (f|^a)^(<*r*>|^a)
proof
A1: len ((f^<*r*>) |^ a) = len (f^<*r*>) by Def1
    .= len f + len <*r*> by FINSEQ_1:35
    .= len f + 1 by FINSEQ_1:57;
A2: len ((f|^a)^(<*r*>|^a)) = len (f|^a) + len (<*r*>|^a) by FINSEQ_1:35
    .= len f + len (<*r*>|^a) by Def1
    .= len f + len (<*r|^a*>) by Th12
    .= len f + 1 by FINSEQ_1:57;
A3: len (f|^a) = len f by Def1;
X: dom ((f^<*r*>) |^ a) = Seg(len f +1)  by A1,FINSEQ_1:def 3;
  now
    let i be Nat such that
A4: i in dom ((f^<*r*>) |^ a);
A5: 1 <= i & i <= len f + 1 by A4,X,FINSEQ_1:3;
A6: i in dom ((f^<*r*>) |^ a) by A4;
    per cases by A5,XXREAL_0:1;
    suppose i < len f +1;
      then
A7:   i <= len f by NAT_1:13;
      then
A8:   i in dom f by A5,FINSEQ_3:27;
A9:   i in dom (f|^a) by A3,A5,A7,FINSEQ_3:27;
      thus ((f^<*r*>) |^ a).i = (f^<*r*>).i |^ a by A6,Def1
        .= f.i |^a by A8,FINSEQ_1:def 7
        .= (f|^a).i by A9,Def1
        .= ((f|^a)^(<*r*>|^a)).i by A9,FINSEQ_1:def 7;
    end;
    suppose
A10:  i = len f +1;
      thus ((f^<*r*>) |^ a).i = (f^<*r*>).i |^ a by A6,Def1
        .= r |^ a by A10,FINSEQ_1:59
        .= ((f|^a)^(<*r|^a*>)).i by A3,A10,FINSEQ_1:59
        .= ((f|^a)^(<*r*>|^a)).i by Th12;
    end;
  end;
  hence thesis by A1,A2,FINSEQ_2:10;
end;

theorem Th14:
  Product (f|^(b+1)) = Product (f|^b) * Product f
proof
  defpred P[FinSequence of REAL] means for b being natural number
  holds Product ($1|^(b+1)) = Product ($1|^b) * Product $1;
A1: P[<*>REAL]
  proof
    let b be natural number;
    set f = <*>REAL;
    thus Product (f|^(b+1)) = 1 by Th11,RVSUM_1:124
      .= Product (f|^b) * Product f by Th11,RVSUM_1:124;
  end;
A2: now
    let p be FinSequence of REAL, x being Element of REAL such that
A3: P[p];
    thus P[p^<*x*>]
    proof
      let b be natural number;
      set p1 = p^<*x*>;
      p1 |^ (b+1) = (p|^(b+1))^(<*x*>|^(b+1)) by Th13;
      hence Product (p1|^(b+1))
      = Product (p|^(b+1)) * Product (<*x*>|^(b+1)) by RVSUM_1:127
        .= (Product (p|^b) * Product p) * Product (<*x*>|^(b+1)) by A3
        .= (Product (p|^b) * Product p) * Product (<*x|^(b+1)*>) by Th12
        .= (Product (p|^b) * Product p) * x|^(b+1) by RVSUM_1:125
        .= (Product (p|^b) * Product p) * (x|^b * x) by NEWTON:11
        .= Product (p|^b) * x|^b * x * Product p
        .= Product (p|^b ^ <*x|^b*>) * x * Product p by RVSUM_1:126
        .= Product (p|^b ^ (<*x*>|^b)) * x * Product p by Th12
        .= Product (p1|^b) * x * Product p by Th13
        .= Product (p1|^b) * (Product p * x)
        .= Product (p1|^b) * Product p1 by RVSUM_1:126;
    end;
  end;
  for p being FinSequence of REAL holds P[p] from FINSEQ_2:sch 2(A1,A2);
  hence thesis;
end;

theorem
  Product (f|^a) = (Product f) |^ a
proof
  defpred P[natural number] means Product (f|^$1) = (Product f) |^ $1;
A1: P[0]
  proof
    thus Product (f|^0) = Product ((len f) |-> 1) by Th9
      .= 1 by RVSUM_1:132
      .= (Product f) |^ 0 by NEWTON:9;
  end;
A2: P[b] implies P[b+1]
  proof
    assume
A3: P[b];
    thus Product (f|^(b+1)) = Product (f|^b) * Product f by Th14
      .= (Product f) |^ (b+1) by A3,NEWTON:11;
  end;
  P[b] from NAT_1:sch 2(A1,A2);
  hence thesis;
end;

begin :: More about bags

registration :: cluster natural-valued FinSequence;
  let X be set;
  cluster natural-valued finite-support ManySortedSet of X;
  existence
  proof
    consider r being natural-valued finite-support ManySortedSet of X;

::       ten cluster jest w polynom1
    r = r;
    hence thesis;
  end;
end;

definition
  let X be set, b be real-valued ManySortedSet of X, a be natural number;
  func a * b -> ManySortedSet of X means
  :Def2:
  for i being set holds it.i = a * b.i;
  existence
  proof
    deffunc F(set) = a * b.$1;
    consider f being ManySortedSet of X such that
A1: for i being set st i in X holds f.i = F(i) from PBOOLE:sch 4;
    take f;
    let i be set;
    per cases;
    suppose i in X;
      hence thesis by A1;
    end;
    suppose
A2:   not i in X;
A3:   dom b = X by PARTFUN1:def 4;
       dom f = X by PARTFUN1:def 4;
      hence f.i = a * 0 by A2,FUNCT_1:def 4
        .= a * b.i by A2,A3,FUNCT_1:def 4;
    end;
  end;
  uniqueness
  proof
    let f, g be ManySortedSet of X such that
A4: for i being set holds f.i = a * b.i and
A5: for i being set holds g.i = a * b.i;
    for i being set st i in X holds f.i = g.i
    proof
      let i be set;
      assume i in X;
      thus f.i = a * b.i by A4
        .= g.i by A5;
    end;
    hence thesis by PBOOLE:3;
  end;
end;

registration
  let X be set, b be real-valued ManySortedSet of X, a be natural number;
  cluster a * b -> real-valued;
  coherence
  proof
    let x be set;
    assume x in dom (a*b);
    (a*b).x = a * b.x by Def2;
    hence thesis;
  end;
end;

registration
  let X be set, b be natural-valued ManySortedSet of X, a be natural number;
  cluster a * b -> natural-valued;
  coherence
  proof
    let x be set;
    assume x in dom (a*b);
    (a*b).x = a * b.x by Def2;
    hence thesis;
  end;
end;

registration
  let X be set, b be real-valued ManySortedSet of X;
  cluster support (0*b) -> empty;
  coherence
  proof
    assume support (0*b) is non empty;
    then consider x being set such that
A1: x in support (0*b) by XBOOLE_0:def 1;
    (0*b).x <> 0 by A1,POLYNOM1:def 7;
    then 0 * b.x <> 0 by Def2;
    hence thesis;
  end;
end;

theorem Th16:
  for X being set, b being real-valued ManySortedSet of X
  st a <> 0 holds support b = support (a*b)
proof
  let X be set, b be real-valued ManySortedSet of X such that
A1: a <> 0;
  hereby
    let x be set;
    assume x in support b;
    then b.x <> 0 by POLYNOM1:def 7;
    then a*b.x <> 0 by A1;
    then (a*b).x <> 0 by Def2;
    hence x in support (a*b) by POLYNOM1:def 7;
  end;
  let x be set;
  assume x in support (a*b);
  then (a*b).x <> 0 by POLYNOM1:def 7;
  then a*b.x <> 0 by Def2;
  then b.x <> 0;
  hence thesis by POLYNOM1:def 7;
end;

registration
  let X be set, b be real-valued finite-support ManySortedSet of X,
  a be natural number;
  cluster a * b -> finite-support;
  coherence
  proof
    per cases;
    suppose
A1:   a = 0;
      thus support (a*b) is finite by A1;
    end;
    suppose a <> 0;
      then support (a*b) = support b by Th16;
      hence support (a*b) is finite;
    end;
  end;
end;

definition
  let X be set;
  let b1, b2 be real-valued ManySortedSet of X;
  func min(b1,b2) -> ManySortedSet of X means
  :Def3:
  for i being set holds (b1.i <= b2.i implies it.i = b1.i) &
  (b1.i > b2.i implies it.i = b2.i);
  existence
  proof
    defpred P[set] means b1.$1 <= b2.$1;
    deffunc F(set) = b1.$1;
    deffunc G(set) = b2.$1;
    consider f being ManySortedSet of X such that
A1: for i being Element of X st i in X
    holds (P[i] implies f.i = F(i)) & (not P[i] implies f.i = G(i))
    from PRE_CIRC:sch 2;
    take f;
    let i be set;
    per cases;
    suppose i in X;
      hence thesis by A1;
    end;
    suppose not i in X;
      then not i in dom f & not i in dom b1 & not i in dom b2 by PARTFUN1:def 4
;
      then f.i = 0 & b1.i = 0 & b2.i = 0 by FUNCT_1:def 4;
      hence thesis;
    end;
  end;
  uniqueness
  proof
    let f, g be ManySortedSet of X such that
A2: for i being set holds (b1.i <= b2.i implies f.i = b1.i) &
    (b1.i > b2.i implies f.i = b2.i) and
A3: for i being set holds (b1.i <= b2.i implies g.i = b1.i) &
    (b1.i > b2.i implies g.i = b2.i);
    now
      let i be set;
      assume i in X;
      per cases;
      suppose
A4:     b1.i <= b2.i;
        hence f.i = b1.i by A2
          .= g.i by A3,A4;
      end;
      suppose
A5:     b1.i > b2.i;
        hence f.i = b2.i by A2
          .= g.i by A3,A5;
      end;
    end;
    hence thesis by PBOOLE:3;
  end;
end;

registration
  let X be set;
  let b1, b2 be real-valued ManySortedSet of X;
  cluster min(b1,b2) -> real-valued;
  coherence
  proof
    set f = min(b1,b2);
    let x be set;
    assume x in dom f;
    b1.x <= b2.x or b1.x > b2.x;
    hence thesis by Def3;
  end;
end;

registration
  let X be set;
  let b1, b2 be natural-valued ManySortedSet of X;
  cluster min(b1,b2) -> natural-valued;
  coherence
  proof
    set f = min(b1,b2);
    let x be set;
    assume x in dom f;
    b1.x <= b2.x or b1.x > b2.x;
    hence thesis by Def3;
  end;
end;

theorem Th17:
  for X being set, b1, b2 being real-valued finite-support ManySortedSet of X
  holds support min(b1,b2) c= support b1 \/ support b2
proof
  let X be set;
  let b1, b2 be real-valued finite-support ManySortedSet of X;
  set f = min(b1,b2);
  let x be set;
  assume x in support f;
  then
A1: f.x <> 0 by POLYNOM1:def 7;
  b1.x <= b2.x or b1.x > b2.x;
  then f.x = b1.x or f.x = b2.x by Def3;
  then x in support b1 or x in support b2 by A1,POLYNOM1:def 7;
  hence thesis by XBOOLE_0:def 3;
end;

registration
  let X be set;
  let b1, b2 be real-valued finite-support ManySortedSet of X;
  cluster min(b1,b2) -> finite-support;
  coherence
  proof
    support min(b1,b2) c= support b1 \/ support b2 by Th17;
    hence support min(b1,b2) is finite;
  end;
end;

definition
  let X be set;
  let b1, b2 be real-valued ManySortedSet of X;
  func max(b1,b2) -> ManySortedSet of X means
  :Def4:
  for i being set holds (b1.i <= b2.i implies it.i = b2.i) &
  (b1.i > b2.i implies it.i = b1.i);
  existence
  proof
    defpred P[set] means b1.$1 <= b2.$1;
    deffunc F(set) = b2.$1;
    deffunc G(set) = b1.$1;
    consider f being ManySortedSet of X such that
A1: for i being Element of X st i in X
    holds (P[i] implies f.i = F(i)) & (not P[i] implies f.i = G(i))
    from PRE_CIRC:sch 2;
    take f;
    let i be set;
    per cases;
    suppose i in X;
      hence thesis by A1;
    end;
    suppose not i in X;
      then not i in dom f & not i in dom b1 & not i in dom b2 by PARTFUN1:def 4
;
      then f.i = 0 & b1.i = 0 & b2.i = 0 by FUNCT_1:def 4;
      hence thesis;
    end;
  end;
  uniqueness
  proof
    let f, g be ManySortedSet of X such that
A2: for i being set holds (b1.i <= b2.i implies f.i = b2.i) &
    (b1.i > b2.i implies f.i = b1.i) and
A3: for i being set holds (b1.i <= b2.i implies g.i = b2.i) &
    (b1.i > b2.i implies g.i = b1.i);
    now
      let i be set;
      assume i in X;
      per cases;
      suppose
A4:     b1.i <= b2.i;
        hence f.i = b2.i by A2
          .= g.i by A3,A4;
      end;
      suppose
A5:     b1.i > b2.i;
        hence f.i = b1.i by A2
          .= g.i by A3,A5;
      end;
    end;
    hence thesis by PBOOLE:3;
  end;
end;

registration
  let X be set;
  let b1, b2 be real-valued ManySortedSet of X;
  cluster max(b1,b2) -> real-valued;
  coherence
  proof
    set f = max(b1,b2);
    let x be set;
    assume x in dom f;
    b1.x <= b2.x or b1.x > b2.x;
    hence thesis by Def4;
  end;
end;

registration
  let X be set;
  let b1, b2 be natural-valued ManySortedSet of X;
  cluster max(b1,b2) -> natural-valued;
  coherence
  proof
    set f = max(b1,b2);
    let x be set;
    assume x in dom f;
    b1.x <= b2.x or b1.x > b2.x;
    hence thesis by Def4;
  end;
end;

theorem Th18:
  for X being set, b1, b2 being real-valued finite-support ManySortedSet of X
  holds support max(b1,b2) c= support b1 \/ support b2
proof
  let X be set;
  let b1, b2 be real-valued finite-support ManySortedSet of X;
  set f = max(b1,b2);
  let x be set;
  assume x in support f;
  then
A1: f.x <> 0 by POLYNOM1:def 7;
  b1.x <= b2.x or b1.x > b2.x;
  then f.x = b1.x or f.x = b2.x by Def4;
  then x in support b1 or x in support b2 by A1,POLYNOM1:def 7;
  hence thesis by XBOOLE_0:def 3;
end;

registration
  let X be set;
  let b1, b2 be real-valued finite-support ManySortedSet of X;
  cluster max(b1,b2) -> finite-support;
  coherence
  proof
    support max(b1,b2) c= support b1 \/ support b2 by Th18;
    hence support max(b1,b2) is finite;
  end;
end;

registration
  let A be set;
  cluster finite-support complex-yielding ManySortedSet of A;
  existence
  proof
    consider f being finite-support natural-valued ManySortedSet of A;
    f is complex-yielding;
    hence thesis;
  end;
end;

definition
  let A be set, b be finite-support complex-yielding ManySortedSet of A;
  func Product b -> complex number means
  :Def5:
  ex f being FinSequence of COMPLEX st
  it = Product f & f = b*canFS(support b);
  existence
  proof
    set cS = canFS(support b);
    set f = b*cS;
A1: support b c= dom b by POLYNOM1:41;
    rng cS = support b by FUNCT_2:def 3;
    then dom f = dom cS by A1,RELAT_1:46;
    then dom f = Seg len cS by FINSEQ_1:def 3;
    then
A2: f is FinSequence by FINSEQ_1:def 2;
    rng f c= COMPLEX by VALUED_0:def 1;
    then reconsider f as FinSequence of COMPLEX by A2,FINSEQ_1:def 4;
    take S = Product f; thus thesis;
  end;
  uniqueness;
end;

definition
  let A be set, b be bag of A;
  redefine func Product b -> Element of NAT;
  coherence
  proof
    consider f being FinSequence of COMPLEX such that
A1: Product b = Product f & f = b*canFS support b by Def5;
A2: rng b c= NAT by VALUED_0:def 6;
    rng f c= rng b by A1,RELAT_1:45;
    then rng f c= NAT by A2,XBOOLE_1:1;
    then reconsider g = f as FinSequence of NAT by FINSEQ_1:def 4;
    Product g in NAT;
    hence thesis by A1;
  end;
end;

theorem Th19:
  for X being set, a, b being bag of X
  st support a misses support b holds Product (a+b) = (Product a) * Product b
proof
  let X be set, a, b be bag of X;
  assume support a misses support b;
  then
A1: support a /\ support b = {} by XBOOLE_0:def 7;
  set ab= a+b;
  set Pa = Product a, Pb = Product b, Pab = Product ab;
  set sab = support (a+b);
  set sa = support a;
  set sb = support b;
  consider f being FinSequence of COMPLEX such that
A2: Pab = Product f and
A3: f = ab*canFS(support ab) by Def5;
  consider fa being FinSequence of COMPLEX such that
A4: Pa = Product fa and
A5: fa = a*canFS(support a) by Def5;
  consider fb being FinSequence of COMPLEX such that
A6: Pb = Product fb and
A7: fb = b*canFS(support b) by Def5;
  set g = fa^fb;
  set ca = canFS(support a), cb = canFS(support b);
  set cg = ca^cb, cf = canFS(support ab);
  set p = cg" * cf;
  len cf = card sab by UPROOTS:5;
  then
A8: dom cf = Seg card sab by FINSEQ_1:def 3;
A9: rng cf = sab by FUNCT_2:def 3;
  dom ab = X by PARTFUN1:def 4;
  then
A11: dom f = Seg card sab by A3,A8,A9,RELAT_1:46;
A12: len cb = card sb by UPROOTS:5;
A13: len ca = card sa by UPROOTS:5;
A14: sab = sa \/ sb by POLYNOM1:42;
A15: rng cb = sb by FUNCT_2:def 3;
A16: rng ca = sa by FUNCT_2:def 3;
A19: len cg = card sa + card sb - card {} by A12,A13,FINSEQ_1:35
    .= card sab by A1,A14,CARD_2:64;
  then
A20: dom cg = Seg card sab by FINSEQ_1:def 3;
A21: rng cg = sab by A14,A15,A16,FINSEQ_1:44;
  then
A22: cg is one-to-one by A19,FINSEQ_4:77;
  then
A23: dom (cg") = sab by A21,FUNCT_1:55;
A24: rng (cg") = Seg card sab by A20,A22,FUNCT_1:55;
  dom a = X by PARTFUN1:def 4;
  then
A29: dom ca = dom fa by A5,A16,RELAT_1:46;
  then
A30: len ca = len fa by FINSEQ_3:31;
  dom b = X by PARTFUN1:def 4;
  then dom cb = dom fb by A7,A15,RELAT_1:46;
  then
A31: len cb = len fb by FINSEQ_3:31;
A32: len cg = len ca + len cb by FINSEQ_1:35;
A33: dom p = Seg card sab by A8,A9,A23,RELAT_1:46;
  len g = card sa + card sb - card {} by A12,A13,A30,A31,FINSEQ_1:35
    .= card sab by A1,A14,CARD_2:64;
  then
A34: dom g = Seg card sab by FINSEQ_1:def 3;
A35: rng p = rng (cg") by A9,A23,RELAT_1:47;
  then reconsider p as Function of dom g, dom g by A24,A33,A34,FUNCT_2:3;
  cg" is one-to-one by A22;
  then
A36: p is one-to-one;
  p is onto by A24,A34,A35,FUNCT_2:def 3;
  then reconsider p as Permutation of dom g by A36;
A37: dom (g*p) = Seg card sab by A24,A33,A34,A35,RELAT_1:46;
  now
    let x be set;
    assume
A38: x in dom f;
    set cgx = cg".(cf.x);
A39: (g*p).x = g.(p.x) by A11,A37,A38,FUNCT_1:22
      .= g.cgx by A8,A11,A38,FUNCT_1:23;
A40: cf.x in sab by A8,A9,A11,A38,FUNCT_1:12;
    then cgx in Seg card sab by A23,A24,FUNCT_1:12;
    then reconsider cgx as natural number;
    reconsider cgxN = cgx as Nat;
    consider d being set such that
A41: d in dom cg and
A42: cg.d = cf.x by A21,A40,FUNCT_1:def 5;
A43: cgx = d by A22,A41,A42,FUNCT_1:56;
    then
A44: cgxN <= len fa + len fb by A30,A31,A32,A41,FINSEQ_3:27;
A45: 1 <= cgxN by A41,A43,FINSEQ_3:27;
    per cases by A14,A40,XBOOLE_0:def 3;
    suppose cf.x in sa;
      then
A47:  not cf.x in sb by A1,XBOOLE_0:def 4;
      set cax = ca".(cf.x);
      now
        assume len fa < cgx;
        then
A48:    len fa +1 <= cgx by NAT_1:13;
        then
A49:    cg.cgxN = cb.(cgx-len ca) by A30,A31,A44,FINSEQ_1:36;
A50:    len ca +1 - len ca <= cgx - len ca by A30,A48,XREAL_1:11;
        then
A51:    cgx - len ca is Element of NAT by INT_1:16;
        cgx -len ca <= len ca + len cb - len ca by A30,A31,A44,XREAL_1:11;
        then cgx-len ca in dom cb by A50,A51,FINSEQ_3:27;
        hence contradiction by A15,A42,A43,A47,A49,FUNCT_1:12;
      end;
      then
A52:  cgxN in dom fa by A45,FINSEQ_3:27;
      then
A53:  cg.cgx = ca.cgx by A29,FINSEQ_1:def 7;
A54:  g.cgx = fa.cgxN by A52,FINSEQ_1:def 7
        .= a.(cf.x) by A5,A29,A42,A43,A52,A53,FUNCT_1:23;
      thus f.x = ab.(cf.x) by A3,A38,FUNCT_1:22
        .= a.(cf.x) + b.(cf.x) by POLYNOM1:def 5
        .= a.(cf.x) + 0 by A47,POLYNOM1:def 7
        .= (g*p).x by A39,A54;
    end;
    suppose
A55:  cf.x in sb;
      then
A56:  not cf.x in sa by A1,XBOOLE_0:def 4;
      set cbx = cb".(cf.x);
A57:  now
        assume len fa +1 > cgx;
        then cgx <= len fa by NAT_1:13;
        then
A58:    cgx in dom ca by A29,A45,FINSEQ_3:27;
        then ca.cgx in sa by A16,FUNCT_1:12;
        then cg.cgxN in sa by A58,FINSEQ_1:def 7;
        hence contradiction by A1,A42,A43,A55,XBOOLE_0:def 4;
      end;
      then
A59:  cg.cgx = cb.(cgx-len ca) by A30,A31,A44,FINSEQ_1:36;
A60:  cgx-len ca <= len ca + len cb - len ca by A30,A31,A44,XREAL_1:11;
A61:  len ca + 1 - len ca <= cgx-len ca by A30,A57,XREAL_1:11;
      then cgxN-len ca in NAT by INT_1:16;
      then cgxN-len ca is Nat;
      then
A62:  cgxN-len ca in dom cb by A60,A61,FINSEQ_3:27;
A63:  g.cgx = fb.(cgxN-len fa) by A44,A57,FINSEQ_1:36
        .= b.(cf.x) by A7,A30,A42,A43,A59,A62,FUNCT_1:23;
      thus f.x = ab.(cf.x) by A3,A38,FUNCT_1:22
        .= a.(cf.x) + b.(cf.x) by POLYNOM1:def 5
        .= 0 + b.(cf.x) by A56,POLYNOM1:def 7
        .= (g*p).x by A39,A63;
    end;
  end;
  then
A64: f = g*p by A11,A37,FUNCT_1:9;
  thus Product (a+b) = multcomplex $$ f by A2,RVSUM_1:def 14
    .= multcomplex $$ g by A64,FINSOP_1:8
    .= Product g by RVSUM_1:def 14
    .= (Product a) * Product b by A4,A6,RVSUM_1:127;
end;

definition
  let X be set, b be real-valued ManySortedSet of X,
  n be non empty natural number;
  func b |^ n -> ManySortedSet of X means
  :Def6:
  support it = support b &
  for i being set holds it.i = b.i |^ n;
  existence
  proof
    deffunc F(Element of X) = b.$1 |^ n;
    defpred P[set,set] means ex a being Element of X st a = $1 & $2 = F(a);
A1: dom b = X by PARTFUN1:def 4;
A2: for e being set st e in X ex u being set st P[e,u]
    proof
      let e be set;
      assume e in X;
      then reconsider f = e as Element of X;
      take F(f), f;
      thus thesis;
    end;
    consider f being Function such that
A3: dom f = X and
A4: for x being set st x in X holds P[x,f.x] from CLASSES1:sch 1(A2);
    reconsider n1 = n as Element of NAT by ORDINAL1:def 13;
A5: n1 >= 1 by UPROOTS:1;
    reconsider f as ManySortedSet of X by A3,PARTFUN1:def 4,RELAT_1:def 18;
    take f;
    now
      let x be set;
      hereby
        assume
A6:     x in support f;
        assume not x in support b;
        then b.x = 0 by POLYNOM1:def 7;
        then
A7:     b.x |^ n = 0 by A5,NEWTON:16;
        support f c= X by A3,POLYNOM1:41;
        then P[x,f.x] by A4,A6;
        hence contradiction by A6,A7,POLYNOM1:def 7;
      end;
      assume x in support b;
      then
A8:   b.x <> 0 by POLYNOM1:def 7;
      now per cases;
        suppose x in X;
          then P[x,f.x] by A4;
          hence f.x = b.x |^ n1;
        end;
        suppose
A9:       not x in X;
          hence f.x = 0 by A3,FUNCT_1:def 4
            .= (0 qua Nat) |^ n1 by A5,NEWTON:16
            .= b.x |^ n1 by A1,A9,FUNCT_1:def 4;
        end;
      end;
      then f.x <> 0 by A8,CARD_4:51;
      hence x in support f by POLYNOM1:def 7;
    end;
    hence support f = support b by TARSKI:2;
    let i be set;
    per cases;
    suppose i in X;
      then P[i,f.i] by A4;
      hence thesis;
    end;
    suppose
A10:  not i in X;
      hence f.i = 0 by A3,FUNCT_1:def 4
        .= (0 qua Nat) |^ n by A5,NEWTON:16
        .= b.i |^ n by A1,A10,FUNCT_1:def 4;
    end;
  end;
  uniqueness
  proof
    let it1, it2 be ManySortedSet of X such that support it1 = support b and
A11: for i being set holds it1.i = b.i |^ n and support it2 = support b and
A12: for i being set holds it2.i = b.i |^ n;
    now
      let x be set such that x in X;
      thus it1.x = b.x |^ n by A11
        .= it2.x by A12;
    end;
    hence it1 = it2 by PBOOLE:3;
  end;
end;

registration
  let X be set, b be natural-valued ManySortedSet of X,
  n be non empty natural number;
  cluster b |^ n -> natural-valued;
  coherence
  proof
    set f = b |^ n;
    let x be set;
    assume x in dom f;
    f.x = b.x |^ n by Def6;
    hence thesis;
  end;
end;

registration
  let X be set, b be real-valued finite-support ManySortedSet of X,
  n be non empty natural number;
  cluster b |^ n -> finite-support;
  coherence
  proof
    support b|^n = support b by Def6;
    hence support b|^n is finite;
  end;
end;

theorem Th20:
  for A being set holds Product EmptyBag A = 1
proof
  let A be set;
  set b = EmptyBag A;
  set cS = canFS(support b);
  support b = {} by BAGORDER:19;
  then len cS = 0;
  then cS = <*>NAT;
  then b*cS = <*>COMPLEX;
  hence thesis by Def5,RVSUM_1:124;
end;

begin :: Multiplicity of a divisor

definition
  let n, d be natural number such that
A1: d <> 1 and
A2: n <> 0;
  func d |-count n -> Nat means
  :Def7:
  d |^ it divides n & not d |^ (it+1) divides n;
  existence
  proof
    reconsider n1 = n as Element of NAT by ORDINAL1:def 13;
    per cases;
    suppose
A3:   d = 0;
      take 0;
      (0 qua Nat) |^ 0 = 1 by NEWTON:9;
      hence d |^ 0 divides n by A3,NAT_D:6;
      not 0 divides n1 by A2,INT_2:3;
      hence not d |^ (0+1) divides n by A3,NEWTON:16;
    end;
    suppose
A4:   d <> 0;
A5:   n > 0 by A2;
      defpred P[Nat] means d |^ $1 divides n;
A6:   for k being Nat st P[k] holds k <= n1
      proof
        let k be Nat;
        assume P[k];
        then
A7:     d |^ k <= n by A5,NAT_D:7;
        k <= d |^ k by A1,A4,Th2,NAT_1:26;
        hence thesis by A7,XXREAL_0:2;
      end;
A8:   ex k being Nat st P[k]
      proof
        take 0;
        d |^ 0 = 1 by NEWTON:9;
        hence thesis by NAT_D:6;
      end;
      consider k being Nat such that
A9:   P[k] & for n being Nat st P[n] holds n <= k from NAT_1:sch 6(A6,A8);
      take k;
      k+(0 qua Nat)< k+1 by XREAL_1:8;
      hence thesis by A9;
    end;
  end;
  uniqueness
  proof
    let a, b be Nat such that
A10: d |^ a divides n and
A11: not d |^ (a+1) divides n and
A12: d |^ b divides n and
A13: not d |^ (b+1) divides n and
A14: a <> b;
    reconsider a,b as Element of NAT by ORDINAL1:def 13;
    reconsider d1 = d as Element of NAT by ORDINAL1:def 13;
    per cases by A14,XXREAL_0:1;
    suppose
A15:  a < b;
      then consider x being Nat such that
A16:  a + x = b by NAT_1:10;
      reconsider x as Element of NAT by ORDINAL1:def 13;
      now
        assume 0+1 > x;
        then x <= 0 by NAT_1:13;
        then x = 0;
        hence contradiction by A15,A16;
      end;
      then a+1 <= a+x by XREAL_1:8;
      then d1 |^ (a+1) divides d1 |^ (a+x) by RADIX_1:7;
      hence contradiction by A11,A12,A16,NAT_D:4;
    end;
    suppose
A17:  b < a;
      then consider x being Nat such that
A18:  b + x = a by NAT_1:10;
      reconsider x as Element of NAT by ORDINAL1:def 13;
      now
        assume 0+1 > x;
        then x <= 0 by NAT_1:13;
        then x = 0;
        hence contradiction by A17,A18;
      end;
      then b+1 <= b+x by XREAL_1:8;
      then d1 |^ (b+1) divides d1 |^ (b+x) by RADIX_1:7;
      hence contradiction by A10,A13,A18,NAT_D:4;
    end;
  end;
end;

definition
  let n, d be natural number;
  redefine func d |-count n -> Element of NAT;
  coherence by ORDINAL1:def 13;
end;

theorem Th21:
  n <> 1 implies n |-count 1 = 0
proof
  assume
A1: 1 <> n;
A2: n |^ 0 divides 1 by NEWTON:9;
  now
    assume
A3: n |^ (0+1) divides 1;
    then n |^ 1 <= 1 by NAT_D:7;
    then n <= 1 by NEWTON:10;
    then n = 0 by A1,NAT_1:26;
    then 0 divides 1 by A3,NEWTON:10;
    hence contradiction by INT_2:3;
  end;
  hence thesis by A1,A2,Def7;
end;

theorem
  1 < n implies n |-count n = 1
proof
  assume
A1: 1 < n;
A2: n |^ 1 divides n by NEWTON:10;
  now
    assume n |^ (1+1) divides n;
    then n |^ 2 <= n by A1,NAT_D:7;
    hence contradiction by A1,PREPOWER:21;
  end;
  hence thesis by A1,A2,Def7;
end;

theorem Th23:
  b <> 0 & b < a & a <> 1 implies a |-count b = 0
proof
  assume that
A1: b <> 0 and
A2: b < a and
A3: a <> 1;
  a |^ 0 = 1 by NEWTON:9;
  then
A4: a |^ 0 divides b by NAT_D:6;
A5: a |^ 1 = a by NEWTON:10;
  b > 0 by A1;
  then not a |^ (0+1) divides b by A2,A5,NAT_D:7;
  hence thesis by A1,A3,A4,Def7;
end;

theorem
  a <> 1 & a <> p implies a |-count p = 0
proof
  assume that
A1: a <> 1 and
A2: a <> p;
  a |^ 0 = 1 by NEWTON:9;
  then
A3: a |^ 0 divides p by NAT_D:6;
  a |^ 1 = a by NEWTON:10;
  then not a |^ (0+1) divides p by A1,A2,INT_2:def 5;
  hence thesis by A1,A3,Def7;
end;

theorem Th25:
  1 < b implies b |-count (b|^a) = a
proof
  assume
A1: b > 1;
  then reconsider b as non empty Element of NAT by ORDINAL1:def 13;
  reconsider a as Element of NAT by ORDINAL1:def 13;
  now
    assume b|^(a+1) divides b|^a;
    then
A2: b|^(a+1) <= b|^a by NAT_D:7;
    b|^a divides b|^(a+1) by NAT_1:11,RADIX_1:7;
    then b|^a <= b|^(a+1) by NAT_D:7;
    then b|^a = b|^(a+1) by A2,XXREAL_0:1;
    then a+0 = a+1 by A1,PEPIN:31;
    hence contradiction;
  end;
  hence thesis by A1,Def7;
end;

theorem Th26:
  b <> 1 & a <> 0 & b divides b |^ (b |-count a) implies b divides a
proof
  assume that
A1: b <> 1 and
A2: a <> 0 and
A3: b divides b |^ (b |-count a);
  b |^ (b |-count a) divides a by A1,A2,Def7;
  hence thesis by A3,NAT_D:4;
end;

theorem Th27:
  b <> 1 implies (a <> 0 & b |-count a = 0 iff not b divides a)
proof
  assume
A1: b <> 1;
  thus a <> 0 & b |-count a = 0 implies not b divides a
  proof
    assume that
A2: a <> 0 and
A3: b |-count a = 0 and
A4: b divides a;
    not b |^ (0+1) divides a by A1,A2,A3,Def7;
    hence contradiction by A4,NEWTON:10;
  end;
  assume
A5: not b divides a;
  then
A6: not b |^ (0+1) divides a by NEWTON:10;
A7: a <> 0 by A5,NAT_D:6;
  1 divides a by NAT_D:6;
  then b |^ 0 divides a by NEWTON:9;
  hence thesis by A1,A6,A7,Def7;
end;

theorem Th28:
  for a, b being non empty natural number
  holds p |-count (a*b) = (p |-count a) + (p |-count b)
proof
  let a,b be non empty natural number;
  set x = p |-count a;
  set y = p |-count b;
  set z = p |-count (a*b);
A1: p <> 1 by INT_2:def 5;
A2: p |^ (x+y) = p |^ x * p |^ y by NEWTON:13;
A3: p |^ x divides a by A1,Def7;
A4: p |^ y divides b by A1,Def7;
  then
A5: p |^ (x+y) divides a*b by A2,A3,Th1;
  now
    assume
A6: p |^ (x+y+1) divides a*b;
A7: p |^ (x+y+1) = p |^ (x+y) * p by NEWTON:11;
A8: not p |^ (y+1) divides b by A1,Def7;
A9: not p |^ (x+1) divides a by A1,Def7;
    consider t being Nat such that
A10: a = (p |^ x) * t by A3,NAT_D:def 3;
    consider u being Nat such that
A11: b = (p |^ y) * u by A4,NAT_D:def 3;
    consider v being Nat such that
A12: a*b = p |^ (x+y+1) * v by A6,NAT_D:def 3;
A13: a*b = (p |^ x) * (p |^ y) * t * u by A10,A11
      .= p |^ (x+y) * t * u by NEWTON:13
      .= p |^ (x+y) * (t * u);
    a*b = p |^ (x+y) * (p * v) by A7,A12;
    then p*v = t*u by A13,XCMPLX_1:5;
    then
A14: p divides t*u by NAT_D:def 3;
    per cases by A14,NEWTON:98;
    suppose p divides t;
      then consider t1 being Nat such that
A15:  t = p * t1 by NAT_D:def 3;
      a = (p |^ x) * p * t1 by A10,A15
        .= p |^ (x+1) * t1 by NEWTON:11;
      hence contradiction by A9,NAT_D:def 3;
    end;
    suppose p divides u;
      then consider t1 being Nat such that
A16:  u = p * t1 by NAT_D:def 3;
      b = (p |^ y) * p * t1 by A11,A16
        .= p |^ (y+1) * t1 by NEWTON:11;
      hence contradiction by A8,NAT_D:def 3;
    end;
  end;
  hence thesis by A1,A5,Def7;
end;

theorem Th29:
  for a, b being non empty natural number
  holds p |^ (p |-count (a*b)) = (p |^ (p |-count a)) * (p |^ (p |-count b))
proof
  let a,b be non empty natural number;
  set x = p |-count a;
  set y = p |-count b;
  thus p |^ (p |-count (a*b)) = p |^ (x + y) by Th28
    .= (p |^ x) * (p |^ y) by NEWTON:13;
end;

theorem Th30:
  for a, b being non empty natural number
  st b divides a holds p |-count b <= p |-count a
proof
  let a,b be non empty natural number;
  set x = p |-count a;
  set y = p |-count b;
  set z = p |-count (a div b);
  assume b divides a;
  then
A1: a = b * (a div b) by NAT_D:3;
A2: p > 1 by INT_2:def 5;
A3: a div b <> 0 by A1;
  0+1 <= p |^ z by NAT_1:13;
  then 1 * p |^ y <= p |^ z * p |^ y by XREAL_1:68;
  then p |^ y <= p |^ x by A1,A3,Th29;
  hence thesis by A2,PEPIN:71;
end;

theorem Th31:
  for a, b being non empty natural number
  st b divides a holds p |-count (a div b) = (p |-count a) -' (p |-count b)
proof
  let a,b be non empty natural number;
  set x = p |-count a;
  set y = p |-count b;
  set z = p |-count (a div b);
  assume
A1: b divides a;
  then a = b * (a div b) by NAT_D:3;
  then a div b <> 0;
  then p |-count (b*(a div b)) = y + z by Th28;
  then
A2: z + y = x + 0 by A1,NAT_D:3;
  y <= x by A1,Th30;
  then y-y <= x-y by XREAL_1:15;
  hence thesis by A2,XREAL_0:def 2;
end;

theorem Th32:
  for a being non empty natural number
  holds p |-count (a|^b) = b * (p |-count a)
proof
  let a be non empty natural number;
A1: p <> 1 by INT_2:def 5;
  defpred P[natural number] means p |-count (a|^$1) = $1 * (p |-count a);
A2: P[0]
  proof
    thus p |-count (a|^0) = p |-count 1 by NEWTON:9
      .= 0 * (p |-count a) by A1,Th21;
  end;
A3: for x being natural number st P[x] holds P[x+1]
  proof
    let x be natural number such that
A4: P[x];
    thus p |-count (a|^(x+1)) = p |-count (a|^x*a) by NEWTON:11
      .= x * (p |-count a) + 1 * (p |-count a) by A4,Th28
      .= (x+1) * (p |-count a);
  end;
  for x being natural number holds P[x] from NAT_1:sch 2(A2,A3);
  hence thesis;
end;

begin :: Exponents in prime-power factorization

definition
  let n be natural number;
  func prime_exponents n -> ManySortedSet of SetPrimes means
  :Def8:
  for p being Prime holds it.p = p |-count n;
  existence
  proof
    deffunc F(natural number) = $1 |-count n;
    defpred P[set,set] means ex w being natural number st w = $1 & $2 = F(w);
A1: for i being set st i in SetPrimes ex j being set st P[i,j]
    proof
      let i be set;
      assume i in SetPrimes;
      then reconsider i as prime Element of NAT by NEWTON:def 6;
      take F(i), i;
      thus thesis;
    end;
    consider f being ManySortedSet of SetPrimes such that
A2: for i being set st i in SetPrimes holds P[i,f.i] from PBOOLE:sch 3(A1);
    take f;
    let i be Prime;
    i in SetPrimes by NEWTON:def 6;
    then P[i,f.i] by A2;
    hence thesis;
  end;
  uniqueness
  proof
    let f, g be ManySortedSet of SetPrimes such that
A3: for i being Prime holds f.i = i |-count n and
A4: for i being Prime holds g.i = i |-count n;
    now
      let i be set;
      assume i in SetPrimes;
      then reconsider a = i as prime Element of NAT by NEWTON:def 6;
      thus f.i = a |-count n by A3
        .= g.i by A4;
    end;
    hence thesis by PBOOLE:3;
  end;
end;

notation
  let n be natural number;
  synonym pfexp n for prime_exponents n; :: for prime factors exponents
end;

theorem Th33:
  for x being set st x in dom pfexp n holds x is Prime
proof
  let x be set;
  assume x in dom pfexp n;
  then x in SetPrimes by PARTFUN1:def 4;
  then x is prime Element of NAT by NEWTON:def 6;
  hence thesis;
end;

theorem Th34:
  for x being set st x in support pfexp n holds x is Prime
proof
  let x be set;
  set f = pfexp n;
  assume
A1: x in support f;
  support f c= dom f by POLYNOM1:41;
  hence thesis by A1,Th33;
end;

theorem Th35:
  a > n & n <> 0 implies (pfexp n).a = 0
proof
  assume that
A1: a > n and
A2: n <> 0;
  reconsider a as Element of NAT by ORDINAL1:def 13;
  per cases;
  suppose a is not prime;
    then not a in dom pfexp n by Th33;
    hence thesis by FUNCT_1:def 4;
  end;
  suppose
A3: a is prime;
    then a <> 1 by INT_2:def 5;
    then a |-count n = 0 by A1,A2,Th23;
    hence thesis by A3,Def8;
  end;
end;

registration
  let n be natural number;
  cluster pfexp n -> natural-valued;
  coherence
  proof
    set f = pfexp n;
    let x be set;
    assume x in dom f;
    then reconsider x as Prime by Th33;
    f.x = x |-count n by Def8;
    hence thesis;
  end;
end;

theorem
  a in support pfexp b implies a divides b
proof
  set f = pfexp b;
  assume
A1: a in support f;
  then reconsider a as Prime by Th34;
A2: f.a <> 0 by A1,POLYNOM1:def 7;
A3: a <> 1 by INT_2:def 5;
  f.a = a |-count b by Def8;
  hence thesis by A2,A3,Th27;
end;

theorem Th37:
  b is non empty & a is Prime & a divides b implies a in support pfexp b
proof
  assume that
A1: b is non empty and
A2: a is Prime and
A3: a divides b;
  1 < a by A2,INT_2:def 5;
  then
A4: a |-count b <> 0 by A1,A3,Th27;
  (pfexp b).a = a |-count b by A2,Def8;
  hence thesis by A4,POLYNOM1:def 7;
end;

registration
  let n be non empty natural number;
  cluster pfexp n -> finite-support;
  coherence
  proof
    set f = pfexp n;
    deffunc F(set) = $1;
    defpred P[Nat] means $1 is prime;
    reconsider n as Element of NAT by ORDINAL1:def 13;
    set A = {F(i) where i is Element of NAT: 0 <= i & i <= n & P[i]};
A1: A is finite from FINSEQ_1:sch 6;
    support f c= A
    proof
      let x be set;
      assume
A2:   x in support f;
      then reconsider x as Prime by Th34;
A3:   x is prime Element of NAT by ORDINAL1:def 13;
      f.x <> 0 by A2,POLYNOM1:def 7;
      then x <= n by Th35;
      hence thesis by A3;
    end;
    hence support f is finite by A1;
  end;
end;

theorem Th38:
  for a being non empty natural number st p divides a holds (pfexp a).p <> 0
proof
  let a be non empty natural number;
  assume p divides a;
  then
A1: p |^ (0+1) divides a by NEWTON:10;
A2: (pfexp a).p = p |-count a by Def8;
  p <> 1 by INT_2:def 5;
  hence thesis by A1,A2,Def7;
end;

theorem Th39:
  pfexp 1 = EmptyBag SetPrimes
proof
  set f = pfexp 1;
  for z being set st z in dom f holds f.z = 0
  proof
    let z be set;
    assume z in dom f;
    then reconsider z as Prime by Th33;
A1: z <> 1 by INT_2:def 5;
    f.z = z |-count 1 by Def8
      .= 0 by A1,Th21;
    hence thesis;
  end;
  then f = (dom f) --> 0 by FUNCOP_1:17;
  hence thesis by PARTFUN1:def 4;
end;

registration
  cluster support pfexp 1 -> empty;
  coherence
  proof
    set f = pfexp 1;
    assume support f is non empty;
    then consider x being set such that
A1: x in support f by XBOOLE_0:def 1;
    f.x <> 0 by A1,POLYNOM1:def 7;
    hence contradiction by Th39,POLYNOM1:56;
  end;
end;

theorem Th40:
  (pfexp (p|^a)).p = a
proof
  set f = pfexp (p|^a);
A1: p > 1 by INT_2:def 5;
  f.p = p |-count (p|^a) by Def8;
  hence thesis by A1,Th25;
end;

theorem
  (pfexp p).p = 1
proof p = p |^ 1 by NEWTON:10;
  hence thesis by Th40;
end;

theorem Th42:
  a <> 0 implies support pfexp (p|^a) = {p}
proof
  set f = pfexp (p|^a);
  assume
A1: a <> 0;
  thus support f c= {p}
  proof
    let x be set;
    assume
A2: x in support f;
    then reconsider x as Prime by Th34;
A3: f.x <> 0 by A2,POLYNOM1:def 7;
A4: x <> 1 by INT_2:def 5;
    f.x = x |-count (p|^a) by Def8;
    then x divides p|^a by A3,A4,Th27;
    then x = p by Th6;
    hence thesis by TARSKI:def 1;
  end;
  let x be set;
  assume x in {p};
  then
A5: x = p by TARSKI:def 1;
  p divides p|^a by A1,Th3;
  then f.p <> 0 by Th38;
  hence thesis by A5,POLYNOM1:def 7;
end;

theorem Th43:
  support pfexp p = {p}
proof p = p |^ 1 by NEWTON:10;
  hence thesis by Th42;
end;

registration
  let p be Prime;
  let a be non empty natural number;
  cluster support pfexp (p|^a) -> non empty trivial;
  coherence
  proof support pfexp (p|^a) = {p} by Th42;
    hence thesis;
  end;
end;

registration
  let p be Prime;
  cluster support pfexp p -> non empty trivial;
  coherence
  proof support pfexp p = {p} by Th43;
    hence thesis;
  end;
end;

theorem Th44:
  for a, b being non empty Nat
  st a,b are_relative_prime holds support pfexp a misses support pfexp b
proof
  let a, b be non empty Nat;
  assume a,b are_relative_prime;
  then
A1: a gcd b = 1 by INT_2:def 4;
  set f = pfexp a;
  set g = pfexp b;
  assume support f meets support g;
  then consider x being set such that
A2: x in support f and
A3: x in support g by XBOOLE_0:3;
  reconsider x as Prime by A2,Th34;
A5: f.x <> 0 by A2,POLYNOM1:def 7;
A6: f.x = x |-count a by Def8;
A7: x <> 1 by INT_2:def 5;
  then
A8: x |^ (x |-count a) divides a by Def7;
  x divides x |^ (x |-count a) by A5,A6,Th3;
  then
A9: x divides a by A8,NAT_D:4;
A10: g.x <> 0 by A3,POLYNOM1:def 7;
A11: g.x = x |-count b by Def8;
A12: x |^ (x |-count b) divides b by A7,Def7;
  x divides x |^ (x |-count b) by A10,A11,Th3;
  then x divides b by A12,NAT_D:4;
  then x divides 1 by A1,A9,NAT_D:def 5;
  hence contradiction by A7,WSIERP_1:20;
end;

theorem Th45:
  for a,b being non empty natural number
  holds support pfexp a c= support pfexp (a*b)
proof
  let a, b be non empty natural number;
  set f = pfexp a;
  set h = pfexp (a*b);
  let x be set;
  assume
A1: x in support f;
  then reconsider x as Prime by Th34;
A2: f.x <> 0 by A1,POLYNOM1:def 7;
A3: x <> 1 by INT_2:def 5;
  then
A4: x |^ (x |-count a) divides a by Def7;
  f.x = x |-count a by Def8;
  then x divides x |^ (x |-count a) by A2,Th3;
  then x divides a by A4,NAT_D:4;
  then x |^ 1 divides a by NEWTON:10;
  then
A5: x |^ (0+1) divides a*b by NAT_D:9;
  h.x = x |-count (a*b) by Def8;
  then h.x <> 0 by A3,A5,Def7;
  hence thesis by POLYNOM1:def 7;
end;

theorem Th46:
  for a, b being non empty Nat
  holds support pfexp (a*b) = support pfexp a \/ support pfexp b
proof
  let a, b be non empty Nat;
  set f = pfexp a;
  set g = pfexp b;
  set h = pfexp (a*b);
  thus support h c= support f \/ support g
  proof
    let x be set;
    assume
A1: x in support h;
    then reconsider x as Prime by Th34;
A2: h.x <> 0 by A1,POLYNOM1:def 7;
A3: x <> 1 by INT_2:def 5;
A4: h.x = x |-count (a*b) by Def8;
A5: x |^ (x |-count(a*b)) = (x |^ (x |-count a)) * (x |^ (x |-count b))
    by Th29;
    per cases by A2,A4,A5,Th3,NEWTON:98;
    suppose x divides x |^ (x |-count a);
      then x divides a by A3,Th26;
      then f.x <> 0 by Th38;
      then x in support f by POLYNOM1:def 7;
      hence thesis by XBOOLE_0:def 3;
    end;
    suppose x divides x |^ (x |-count b);
      then x divides b by A3,Th26;
      then g.x <> 0 by Th38;
      then x in support g by POLYNOM1:def 7;
      hence thesis by XBOOLE_0:def 3;
    end;
  end;
  support f c= support h & support g c= support h by Th45;
  hence thesis by XBOOLE_1:8;
end;

theorem
  for a, b being non empty Nat st a,b are_relative_prime
  holds card support pfexp (a*b) = card support pfexp a + card support pfexp b
proof
  let a, b be non empty Nat;
  assume
A1: a,b are_relative_prime;
  support pfexp (a*b) = support pfexp a \/ support pfexp b by Th46;
  hence thesis by A1,Th44,CARD_2:53;
end;

theorem
  for a, b being non empty natural number
  holds support pfexp a = support pfexp (a|^b)
proof
  let a, b be non empty natural number;
  set f = pfexp a;
  set g = pfexp (a|^b);
  a|^b = a|^(b-'1) * a by PEPIN:27;
  hence support f c= support g by Th45;
  let x be set;
  assume
A1: x in support g;
  then reconsider x as Prime by Th34;
A2: g.x <> 0 by A1,POLYNOM1:def 7;
A3: g.x = x |-count (a|^b) by Def8;
  x <> 1 by INT_2:def 5;
  then x divides a|^b by A2,A3,Th27;
  then f.x <> 0 by Th5,Th38;
  hence thesis by POLYNOM1:def 7;
end;

reserve n, m for non empty natural number;

theorem
  pfexp (n*m) = pfexp n + pfexp m
proof
  for i being set st i in SetPrimes holds
  (pfexp (n*m)).i = (pfexp n + pfexp m).i
  proof
    let i be set;
    assume i in SetPrimes;
    then reconsider a = i as prime Element of NAT by NEWTON:def 6;
    thus (pfexp (n*m)).i = a |-count (n*m) by Def8
      .= (a |-count n) + (a |-count m) by Th28
      .= (pfexp n).i + (a |-count m) by Def8
      .= (pfexp n).i + (pfexp m).i by Def8
      .= (pfexp n + pfexp m).i by POLYNOM1:def 5;
  end;
  hence thesis by PBOOLE:3;
end;

theorem
  m divides n implies pfexp (n div m) = pfexp n -' pfexp m
proof
  assume
A1: m divides n;
  for i being set st i in SetPrimes holds
  (pfexp (n div m)).i = (pfexp n -' pfexp m).i
  proof
    let i be set;
    assume i in SetPrimes;
    then reconsider a = i as prime Element of NAT by NEWTON:def 6;
    thus (pfexp (n div m)).i = a |-count (n div m) by Def8
      .= (a |-count n) -' (a |-count m) by A1,Th31
      .= (pfexp n).i -' (a |-count m) by Def8
      .= (pfexp n).i -' (pfexp m).i by Def8
      .= (pfexp n -' pfexp m).i by POLYNOM1:def 6;
  end;
  hence thesis by PBOOLE:3;
end;

theorem
  pfexp (n|^a) = a * pfexp n
proof
  for i being set st i in SetPrimes holds (pfexp (n|^a)).i = (a * pfexp n).i
  proof
    let i be set;
    assume i in SetPrimes;
    then reconsider x = i as prime Element of NAT by NEWTON:def 6;
    thus (pfexp (n|^a)).i = x |-count (n|^a) by Def8
      .= a * (x |-count n) by Th32
      .= a * (pfexp n).i by Def8
      .= (a * pfexp n).i by Def2;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th52:
  support pfexp n = {} implies n = 1
proof
  assume that
A1: support pfexp n = {} and
A2: n <> 1;
  n >= 0+1 by NAT_1:13;
  then n > 1 by A2,XXREAL_0:1;
  then n >= 1+1 & n is Nat by NAT_1:13;
  then consider p being Element of NAT such that
A3: p is prime and
A4: p divides n by INT_2:48;
  p > 1 by A3,INT_2:def 5;
  then p |-count n <> 0 by A4,Th27;
  then (pfexp n).p <> 0 by A3,Def8;
  hence contradiction by A1,POLYNOM1:def 7;
end;

theorem
  for m, n being non empty Nat holds pfexp (n gcd m) = min(pfexp n, pfexp m)
proof
  let m, n be non empty Nat;
  now
    let i be set;
    assume i in SetPrimes;
    then reconsider j = i as prime Element of NAT by NEWTON:def 6;
    set lhs = pfexp (n gcd m);
    set rhs = min(pfexp n, pfexp m);
    set x = j |-count n, y = j |-count m, z = j |-count (n gcd m);
A1: j <> 1 by INT_2:def 5;
A2: n gcd m <> 0 by INT_2:5;
A3: lhs.j = z by Def8;
A4: j |^ z divides (n gcd m) by A1,A2,Def7;
A5: not j |^ (z+1) divides (n gcd m) by A1,A2,Def7;
A6: (pfexp n).j = x by Def8;
A7: j |^ x divides n by A1,Def7;
A8: not j |^ (x+1) divides n by A1,Def7;
A9: (pfexp m).j = y by Def8;
A10: j |^ y divides m by A1,Def7;
A11: not j |^ (y+1) divides m by A1,Def7;
A12: n gcd m divides m by NAT_D:def 5;
A13: n gcd m divides n by NAT_D:def 5;
A14: j |^ z divides m by A4,A12,NAT_D:4;
A15: j |^ z divides n by A4,A13,NAT_D:4;
    thus lhs.i = rhs.i
    proof
      per cases;
      suppose
A16:    (pfexp n).j <= (pfexp m).j;
        then
A17:    rhs.j = x by A6,Def3;
A18:    z <= x by A8,A15,Th4;
        now
          assume
A19:      z < x;
          then
A20:      j |^ (z+1) divides n by A7,Th4;
          z < y by A6,A9,A16,A19,XXREAL_0:2;
          then j |^ (z+1) divides m by A10,Th4;
          hence contradiction by A5,A20,NAT_D:def 5;
        end;
        hence thesis by A3,A17,A18,XXREAL_0:1;
      end;
      suppose
A21:    (pfexp n).j > (pfexp m).j;
        then
A22:    rhs.j = y by A9,Def3;
A23:    z <= y by A11,A14,Th4;
        now
          assume
A24:      z < y;
          then
A25:      j |^ (z+1) divides m by A10,Th4;
          z < x by A6,A9,A21,A24,XXREAL_0:2;
          then j |^ (z+1) divides n by A7,Th4;
          hence contradiction by A5,A25,NAT_D:def 5;
        end;
        hence thesis by A3,A22,A23,XXREAL_0:1;
      end;
    end;
  end;
  hence thesis by PBOOLE:3;
end;

theorem
  for m, n being non empty Nat holds pfexp (n lcm m) = max(pfexp n, pfexp m)
proof
  let m, n be non empty Nat;
  now
    let i be set;
    assume i in SetPrimes;
    then reconsider j = i as prime Element of NAT by NEWTON:def 6;
    set lhs = pfexp (n lcm m);
    set rhs = max(pfexp n, pfexp m);
    set x = j |-count n, y = j |-count m, z = j |-count (n lcm m);
A1: j > 1 by INT_2:def 5;
A2: n lcm m <> 0 by INT_2:4;
A3: lhs.j = z by Def8;
A4: j |^ z divides (n lcm m) by A1,A2,Def7;
A5: not j |^ (z+1) divides (n lcm m) by A1,A2,Def7;
A6: (pfexp n).j = x by Def8;
A7: j |^ x divides n by A1,Def7;
A8: not j |^ (x+1) divides n by A1,Def7;
A9: (pfexp m).j = y by Def8;
A10: j |^ y divides m by A1,Def7;
A11: not j |^ (y+1) divides m by A1,Def7;
A12: m divides n lcm m by NAT_D:def 4;
A13: n divides n lcm m by NAT_D:def 4;
A14: j |^ y divides n lcm m by A10,A12,NAT_D:4;
A15: j |^ x divides n lcm m by A7,A13,NAT_D:4;
    thus lhs.i = rhs.i
    proof
      per cases;
      suppose
A16:    (pfexp n).j <= (pfexp m).j;
        then
A17:    rhs.j = y by A9,Def4;
A18:    y <= z by A5,A14,Th4;
        now
          assume y < z;
          then j |^ (y+1) divides n lcm m by A4,Th4;
          then consider k being Nat such that
A19:      n lcm m = (j |^ (y+1))*k by NAT_D:def 3;
A20:      n lcm m = (j |^ y)*j*k by A19,NEWTON:11
            .= (j |^ y)*(k*j);
          0 <> k by A19,INT_2:4;
          then
A21:      0 < k;
          then
A22:      0*k < (j |^ y)*k;
          consider t being Nat such that
A23:      n = (j |^ x) * t by A7,NAT_D:def 3;
          consider u being Nat such that
A24:      n lcm m = n*u by A13,NAT_D:def 3;
          consider p being Nat such that
A25:      y = x+p by A6,A9,A16,NAT_1:10;
          (j |^ x)*((j |^ p) *(k*j)) = ((j |^ x)*(j |^ p)) *(k*j)
            .= (j |^ x)*(t*u) by A20,A23,A24,A25,NEWTON:13;
          then (j |^p)*k*j = t*u by XCMPLX_1:5;
          then
A26:      j divides t*u by NAT_D:def 3;
          now
            assume j divides t;
            then consider w being Nat such that
A27:        t = j*w by NAT_D:def 3;
            n = (j |^ x) * j * w by A23,A27
              .= (j |^ (x+1)) * w by NEWTON:11;
            hence contradiction by A8,NAT_D:def 3;
          end;
          then j divides u by A26,NEWTON:98;
          then consider w being Nat such that
A28:      u = j*w by NAT_D:def 3;
          (j |^ y)*k*j = n*w*j by A20,A24,A28;
          then (j |^ y)*k = n*w by XCMPLX_1:5;
          then
A29:      n divides (j |^ y)*k by NAT_D:def 3;
          consider t being Nat such that
A30:      m = (j |^ y) * t by A10,NAT_D:def 3;
          consider u being Nat such that
A31:      n lcm m = m*u by A12,NAT_D:def 3;
          (j |^ y)*(k*j) = (j |^ y)*(t*u) by A20,A30,A31;
          then k*j = t*u by XCMPLX_1:5;
          then
A32:      j divides t*u by NAT_D:def 3;
          now
            assume j divides t;
            then consider w being Nat such that
A33:        t = j*w by NAT_D:def 3;
            m = (j |^ y) * j * w by A30,A33
              .= (j |^ (y+1)) * w by NEWTON:11;
            hence contradiction by A11,NAT_D:def 3;
          end;
          then j divides u by A32,NEWTON:98;
          then consider w being Nat such that
A34:      u = j*w by NAT_D:def 3;
          (j |^ y)*k*j = m*w*j by A20,A31,A34;
          then (j |^ y)*k = m*w by XCMPLX_1:5;
          then m divides (j |^ y)*k by NAT_D:def 3;
          then n lcm m divides (j |^ y)*k by A29,NAT_D:def 4;
          then (j |^ (y+1))*k <= (j |^ y)*k by A19,A22,NAT_D:7;
          then j |^ (y+1) <= j |^ y by A21,XREAL_1:70;
          then (j |^ y) * j <= (j |^ y)*1 by NEWTON:11;
          then j <= 1 by XREAL_1:70;
          hence contradiction by INT_2:def 5;
        end;
        hence thesis by A3,A17,A18,XXREAL_0:1;
      end;
      suppose
A35:    (pfexp n).j > (pfexp m).j;
        then
A36:    rhs.j = x by A6,Def4;
A37:    x <= z by A5,A15,Th4;
        now
          assume x < z;
          then j |^ (x+1) divides n lcm m by A4,Th4;
          then consider k being Nat such that
A38:      n lcm m = (j |^ (x+1))*k by NAT_D:def 3;
A39:      n lcm m = (j |^ x)*j*k by A38,NEWTON:11
            .= (j |^ x)*(k*j);
          0 <> k by A38,INT_2:4;
          then
A40:      0 < k;
          then
A41:      0*k < (j |^ x)*k;
          consider t being Nat such that
A42:      m = (j |^ y) * t by A10,NAT_D:def 3;
          consider u being Nat such that
A43:      n lcm m = m*u by A12,NAT_D:def 3;
          consider p being Nat such that
A44:      x = y+p by A6,A9,A35,NAT_1:10;
          (j |^ y)*((j |^ p) *(k*j)) = (j |^ y)*(j |^ p) *(k*j)
            .= (j|^y)*(t*u) by A39,A42,A43,A44,NEWTON:13;
          then t*u = (j|^p)*k*j by XCMPLX_1:5;
          then
A45:      j divides t*u by NAT_D:def 3;
          now
            assume j divides t;
            then consider w being Nat such that
A46:        t = j*w by NAT_D:def 3;
            m = (j |^ y) * j * w by A42,A46
              .= (j |^ (y+1)) * w by NEWTON:11;
            hence contradiction by A11,NAT_D:def 3;
          end;
          then j divides u by A45,NEWTON:98;
          then consider w being Nat such that
A47:      u = j*w by NAT_D:def 3;
          (j |^ x)*k*j = m*w*j by A39,A43,A47;
          then (j |^ x)*k = m*w by XCMPLX_1:5;
          then
A48:      m divides (j |^ x)*k by NAT_D:def 3;
          consider t being Nat such that
A49:      n = (j |^ x) * t by A7,NAT_D:def 3;
          consider u being Nat such that
A50:      n lcm m = n*u by A13,NAT_D:def 3;
          (j |^ x)*(k*j) = (j |^ x)*(t*u) by A39,A49,A50;
          then k*j = t*u by XCMPLX_1:5;
          then
A51:      j divides t*u by NAT_D:def 3;
          now
            assume j divides t;
            then consider w being Nat such that
A52:        t = j*w by NAT_D:def 3;
            n = (j |^ x) * j * w by A49,A52
              .= (j |^ (x+1)) * w by NEWTON:11;
            hence contradiction by A8,NAT_D:def 3;
          end;
          then j divides u by A51,NEWTON:98;
          then consider w being Nat such that
A53:      u = j*w by NAT_D:def 3;
          (j |^ x)*k*j = n*w*j by A39,A50,A53;
          then (j |^ x)*k = n*w by XCMPLX_1:5;
          then n divides (j |^ x)*k by NAT_D:def 3;
          then n lcm m divides (j |^ x)*k by A48,NAT_D:def 4;
          then (j |^ (x+1))*k <= (j |^ x)*k by A38,A41,NAT_D:7;
          then j |^ (x+1) <= j |^ x by A40,XREAL_1:70;
          then (j |^ x) * j <= (j |^ x)*1 by NEWTON:11;
          then j <= 1 by XREAL_1:70;
          hence contradiction by INT_2:def 5;
        end;
        hence thesis by A3,A36,A37,XXREAL_0:1;
      end;
    end;
  end;
  hence thesis by PBOOLE:3;
end;

begin :: Prime-power factorization

definition
  let n be non empty natural number;
  func prime_factorization n -> ManySortedSet of SetPrimes means
  :Def9:
  support it = support pfexp n &
  for p being natural number st p in support pfexp n holds
  it.p = p |^ (p |-count n);
  existence
  proof
    defpred P[set,set] means for p being Prime st $1 = p holds
    (p in support pfexp n implies $2 = p |^ (p |-count n)) &
    (not p in support pfexp n implies $2 = 0);
A5: for x being set st x in SetPrimes ex y being set st P[x,y]
    proof
      let x be set such that
A6:   x in SetPrimes;
      reconsider i = x as prime Element of NAT by A6,NEWTON:def 6;
      per cases;
      suppose
A7:     i in support pfexp n;
        take i |^ (i |-count n);
        let p be Prime;
        assume p = x;
        hence thesis by A7;
      end;
      suppose
A8:     not i in support pfexp n;
        take 0;
        let p be Prime;
        assume p = x;
        hence thesis by A8;
      end;
    end;
    consider f being Function such that
A9: dom f = SetPrimes and
A10: for x being set st x in SetPrimes holds P[x,f.x] from CLASSES1:sch 1(A5);
A11: support f c= SetPrimes by A9,POLYNOM1:41;
A12: now
      let x be set;
      hereby
        assume
A13:    x in support f;
        then x in SetPrimes by A11;
        then reconsider i = x as prime Element of NAT by NEWTON:def 6;
        assume not x in support pfexp n;
        then f.i = 0 by A10,A11,A13;
        hence contradiction by A13,POLYNOM1:def 7;
      end;
      assume
A14:  x in support pfexp n;
      then x in SetPrimes;
      then reconsider i = x as prime Element of NAT by NEWTON:def 6;
      f.i = i |^ (i |-count n) by A10,A14;
      hence x in support f by POLYNOM1:def 7;
    end;
    reconsider f as ManySortedSet of SetPrimes by A9,PARTFUN1:def 4
,RELAT_1:def 18;
    take f;
    thus support f = support pfexp n by A12,TARSKI:2;
    let p be natural number;
    assume
A15: p in support pfexp n;
    then p is Prime by Th34;
    hence thesis by A10,A15;
  end;
  uniqueness
  proof
    let it1, it2 be ManySortedSet of SetPrimes such that
A16: support it1 = support pfexp n and
A17: for p being natural number st p in support pfexp n holds
    it1.p = p|^(p|-count n) and
A18: support it2 = support pfexp n and
A19: for p being natural number st p in support pfexp n holds
    it2.p = p|^(p|-count n);
    now
      let i be set such that
A20:  i in SetPrimes;
      reconsider p = i as prime Element of NAT by A20,NEWTON:def 6;
      per cases;
      suppose
A21:    p in support pfexp n;
        hence it1.i = p|^(p|-count n) by A17
          .= it2.i by A19,A21;
      end;
      suppose
A22:    not p in support pfexp n;
        hence it1.i = 0 by A16,POLYNOM1:def 7
          .= it2.i by A18,A22,POLYNOM1:def 7;
      end;
    end;
    hence it1 = it2 by PBOOLE:3;
  end;
end;

notation
  let n be non empty natural number;
  synonym ppf n for prime_factorization n; :: for prime-power factorization
end;

registration
  let n be non empty natural number;
  cluster ppf n -> natural-valued finite-support;
  coherence
  proof
    rng ppf n c= NAT
    proof
      let y be set;
      assume y in rng ppf n;
      then consider x being set such that
A1:   x in dom ppf n and
A2:   (ppf n).x = y by FUNCT_1:def 5;
      dom ppf n = SetPrimes by PARTFUN1:def 4;
      then reconsider x as prime Element of NAT by A1,NEWTON:def 6;
      per cases;
      suppose x in support pfexp n;
        then (ppf n).x = x |^ (x |-count n) by Def9;
        hence thesis by A2;
      end;
      suppose not x in support pfexp n;
        then not x in support ppf n by Def9;
        then (ppf n).x = 0 by POLYNOM1:def 7;
        hence thesis by A2;
      end;
    end;
    hence ppf n is natural-valued by VALUED_0:def 6;
    support ppf n = support pfexp n by Def9;
    hence support ppf n is finite;
  end;
end;

theorem Th55:
  p |-count n = 0 implies (ppf n).p = 0
proof
  assume p |-count n = 0;
  then (pfexp n).p = 0 by Def8;
  then not p in support pfexp n by POLYNOM1:def 7;
  then not p in support ppf n by Def9;
  hence thesis by POLYNOM1:def 7;
end;

theorem Th56:
  p |-count n <> 0 implies (ppf n).p = p |^ (p |-count n)
proof
  assume p |-count n <> 0;
  then (pfexp n).p <> 0 by Def8;
  then p in support pfexp n by POLYNOM1:def 7;
  hence thesis by Def9;
end;

theorem
  support ppf n = {} implies n = 1
proof
  assume support ppf n = {};
  then support pfexp n = {} by Def9;
  hence thesis by Th52;
end;

theorem Th58:
  for a, b being non empty Nat st a, b are_relative_prime
  holds ppf (a*b) = ppf a + ppf b
proof
  let a, b be non empty Nat such that
A1: a, b are_relative_prime;
  reconsider an = a, bn = b as non empty natural number;
  now
    let i be set such that
A2: i in SetPrimes;
    reconsider p = i as prime Element of NAT by A2,NEWTON:def 6;
A3: p |-count (an*bn) = (p |-count a) + (p |-count b) by Th28;
A4: p > 1 by INT_2:def 5;
A5: a gcd b = 1 by A1,INT_2:def 4;
    per cases;
    suppose
A6:   p |-count (a*b) = 0;
      then
A7:   (p |-count a) = 0 & (p |-count b) = 0 by A3;
      thus (ppf (a*b)).i = 0 by A6,Th55
        .= 0 + (ppf b).i by A7,Th55
        .= (ppf a).i + (ppf b).i by A7,Th55
        .= (ppf a + ppf b).i by POLYNOM1:def 5;
    end;
    suppose
A8:   p |-count (a*b) <> 0;
      thus (ppf (a*b)).i = (ppf a + ppf b).i
      proof
        per cases by A3,A8;
        suppose
A9:       (p |-count a) <> 0;
A10:      now
            assume (p |-count b) <> 0;
            then consider kb being Nat such that
A11:        (p |-count b) = kb+1 by NAT_1:6;
            p |^ (p |-count b) divides b by A4,Def7;
            then p*(p|^kb) divides b by A11,NEWTON:11;
            then consider lb being Nat such that
A12:        b = p*(p|^kb)*lb by NAT_D:def 3;
            b = p*((p|^kb)*lb) by A12;
            then
A13:        p divides b by NAT_D:def 3;
            consider ka being Nat such that
A14:        (p |-count a) = ka+1 by A9,NAT_1:6;
            p |^ (p |-count a) divides a by A4,Def7;
            then p*(p|^ka) divides a by A14,NEWTON:11;
            then consider la being Nat such that
A15:        a = p*(p|^ka)*la by NAT_D:def 3;
            a = p*((p|^ka)*la) by A15;
            then p divides a by NAT_D:def 3;
            then p divides 1 by A5,A13,NAT_D:def 5;
            hence contradiction by A4,NAT_D:7;
          end;
          hence (ppf (a*b)).i = p |^ (p |-count a) by A3,A8,Th56
            .= (ppf a).p + 0 by A9,Th56
            .= (ppf a).p + (ppf b).p by A10,Th55
            .= (ppf a + ppf b).i by POLYNOM1:def 5;
        end;
        suppose
A16:      (p |-count b) <> 0;
A17:      now
            assume
A18:        (p |-count a) <> 0;
            consider kb being Nat such that
A19:        (p |-count b) = kb+1 by A16,NAT_1:6;
            p |^ (p |-count b) divides b by A4,Def7;
            then p*(p|^kb) divides b by A19,NEWTON:11;
            then consider lb being Nat such that
A20:        b = p*(p|^kb)*lb by NAT_D:def 3;
            b = p*((p|^kb)*lb) by A20;
            then
A21:        p divides b by NAT_D:def 3;
            consider ka being Nat such that
A22:        (p |-count a) = ka+1 by A18,NAT_1:6;
            p |^ (p |-count a) divides a by A4,Def7;
            then p*(p|^ka) divides a by A22,NEWTON:11;
            then consider la being Nat such that
A23:        a = p*(p|^ka)*la by NAT_D:def 3;
            a = p*((p|^ka)*la) by A23;
            then p divides a by NAT_D:def 3;
            then p divides 1 by A5,A21,NAT_D:def 5;
            hence contradiction by A4,NAT_D:7;
          end;
          hence (ppf (a*b)).i = p |^ (p |-count b) by A3,A8,Th56
            .= 0+(ppf b).p by A16,Th56
            .= (ppf a).p + (ppf b).p by A17,Th55
            .= (ppf a + ppf b).i by POLYNOM1:def 5;
        end;
      end;
    end;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th59:
  (ppf (p |^ n)).p = p |^ n
proof
  p > 1 by INT_2:def 5;
  then p |-count (p |^ n) = n by Th25;
  hence thesis by Th56;
end;

theorem
  ppf (n|^m) = (ppf n) |^ m
proof
  now
    let i be set;
    assume i in SetPrimes;
    then reconsider p = i as prime Element of NAT by NEWTON:def 6;
A1: m >= 0+1 by NAT_1:13;
A2: p |-count (n |^ m) = m * (p |-count n) by Th32;
A3: ((ppf n) |^ m).i = (ppf n).i |^ m by Def6;
    per cases;
    suppose
A4:   p |-count n = 0;
      hence (ppf (n|^m)).i = 0 by A2,Th55
        .= (0 qua Nat) |^ m by A1,NEWTON:16
        .= ((ppf n) |^ m).i by A3,A4,Th55;
    end;
    suppose
A5:   p |-count n <> 0;
      hence (ppf (n|^m)).i = p |^ (p |-count (n |^ m)) by A2,Th56
        .= (p |^ (p |-count n)) |^ m by A2,NEWTON:14
        .= ((ppf n) |^ m).i by A3,A5,Th56;
    end;
  end;
  hence thesis by PBOOLE:3;
end;

theorem
  Product ppf n = n
proof
  defpred P[natural number] means for n being non empty natural number
  st support ppf n c= Seg $1 holds Product ppf n = n;
A1: P[0]
  proof
    let n be non empty natural number;
    assume
A2: support ppf n c= Seg 0;
    {} c= support ppf n by XBOOLE_1:2;
    then
A3: support ppf n = {} by A2,XBOOLE_0:def 10;
    then
A4: ppf n = EmptyBag SetPrimes by BAGORDER:20;
    now
      reconsider k = n as Nat;
      assume n <> 1;
      then k > 1 by UPROOTS:1;
      then k >=1+1 by NAT_1:13;
      then consider p being Element of NAT such that
A5:   p is prime and
A6:   p divides k by INT_2:48;
      support pfexp n is non empty by A5,A6,Th37;
      hence contradiction by A3,Def9;
    end;
    hence thesis by A4,Th20;
  end;
A7: for k being natural number st P[k] holds P[k+1]
  proof
    let k be natural number;
    assume
A8: P[k];
    let n be non empty natural number such that
A9: support ppf n c= Seg (k+1);
A10: support ppf n = support pfexp n by Def9;
    per cases;
    suppose
A11:  not support ppf n c= Seg k;
A12:  now
        assume
A13:    not k+1 in support ppf n;
        support ppf n c= Seg k
        proof
          let x be set;
          assume
A14:      x in support ppf n;
          then
A15:      x is Prime by A10,Th34;
          reconsider m = x as natural number by A14;
A16:      1 <= m by A15,INT_2:def 5;
          m <= k+1 by A9,A14,FINSEQ_1:3;
          then m < k+1 by A13,A14,XXREAL_0:1;
          then m <= k by NAT_1:13;
          hence thesis by A16,FINSEQ_1:3;
        end;
        hence contradiction by A11;
      end;
      set p = k+1;
      set e = p |-count n;
      set s = p |^ e;
A17:  p is Prime by A10,A12,Th34;
      then
A18:  (pfexp n).p = e by Def8;
A19:  p > 1 by A17,INT_2:def 5;
      then s divides n by Def7;
      then consider t being Nat such that
A20:  n = s * t by NAT_D:def 3;
      reconsider s, t as non empty natural number by A20;
A21:  support ppf t = support pfexp t by Def9;
A22:  support ppf t c= Seg k
      proof
        let x be set;
        assume
A23:    x in support ppf t;
        then
A24:    x in support pfexp t by Def9;
        then
A25:    x is Prime by Th34;
        reconsider m = x as natural number by A24;
A26:    1 <= m by A25,INT_2:def 5;
        support ppf t c= support ppf n by A10,A20,A21,Th45;
        then m in support ppf n by A23;
        then
A27:    m <= k+1 by A9,FINSEQ_1:3;
        set f = p |-count t;
        now
          assume
A28:      m = p;
          (pfexp t).p = f by A17,Def8;
          then f <> 0 by A24,A28,POLYNOM1:def 7;
          then f > 0;
          then f >= 0+1 by NAT_1:13;
          then consider g being Nat such that
A29:      f = 1+g by NAT_1:10;
          p |^ f divides t by A19,Def7;
          then consider u being Nat such that
A30:      t = (p |^ f)*u by NAT_D:def 3;
          n = s * (((p |^ g)*p)*u) by A20,A29,A30,NEWTON:11
            .= s*p *((p |^ g)*u)
            .= (p |^ (e+1))*((p |^ g)*u) by NEWTON:11;
          then p |^ (e+1) divides n by NAT_D:def 3;
          hence contradiction by A19,Def7;
        end;
        then m < p by A27,XXREAL_0:1;
        then m <= k by NAT_1:13;
        hence thesis by A26,FINSEQ_1:3;
      end;
A31:  e <> 0 by A10,A12,A18,POLYNOM1:def 7;
      support ppf s = support pfexp s by Def9;
      then
A32:  support ppf s = {p} by A17,A31,Th42;
      now
        assume (support ppf s) /\ (support ppf t) <> {};
        then consider x being set such that
A33:    x in (support ppf s) /\ support ppf t by XBOOLE_0:def 1;
A34:    x in support ppf s by A33,XBOOLE_0:def 4;
A35:    x in support ppf t by A33,XBOOLE_0:def 4;
        x = p by A32,A34,TARSKI:def 1;
        then p <= k by A22,A35,FINSEQ_1:3;
        hence contradiction by NAT_1:13;
      end;
      then
A36:  support ppf s misses support ppf t by XBOOLE_0:def 7;
      reconsider s1 = s, t1 = t as non empty Nat;
      s1,t1 are_relative_prime
      proof
        assume
A37:    s1 gcd t1 <> 1;
        set u = s1 gcd t1;
A38:    u divides s1 by NAT_D:def 5;
        u <> 0 by INT_2:5;
        then 0 < u;
        then 0+1 <= u by NAT_1:13;
        then u > 1 by A37,XXREAL_0:1;
        then u >= 1+1 by NAT_1:13;
        then consider r being Element of NAT such that
A39:    r is prime and
A40:    r divides u by INT_2:48;
        r divides s1 by A38,A40,NAT_D:4;
        then r divides p by A39,Th5;
        then
A41:    r = 1 or r = p by A17,INT_2:def 5;
        u divides t1 by NAT_D:def 5;
        then p divides t1 by A39,A40,A41,INT_2:def 5,NAT_D:4;
        then p in support pfexp t by A17,Th37;
        then k+1 <= k by A21,A22,FINSEQ_1:3;
        hence contradiction by NAT_1:13;
      end;
      then
A42:  ppf n = ppf s + ppf t by A20,Th58;
      consider f being FinSequence of COMPLEX such that
A43:  Product ppf s = Product f and
A44:  f = (ppf s)*canFS(support ppf s) by Def5;
A45:  dom ppf s = SetPrimes by PARTFUN1:def 4;
      f = (ppf s)*<*p*> by A32,A44,UPROOTS:6
        .= <* (ppf s).p *> by A12,A45,CIRCCMB3:36;
      then
A46:  Product ppf s = (ppf s).p by A43,RVSUM_1:125
        .= s by A17,A31,Th59;
      Product ppf t = t by A8,A22;
      hence thesis by A20,A36,A42,A46,Th19;
    end;
    suppose support ppf n c= Seg k;
      hence thesis by A8;
    end;
  end;
A47: for k being natural number holds P[k] from NAT_1:sch 2(A1,A7);
A48: support ppf n = support pfexp n by Def9;
  per cases;
  suppose support ppf n is empty;
    hence thesis by A1;
  end;
  suppose support ppf n is non empty;
    then reconsider S = support ppf n as finite non empty Subset of NAT
    by XBOOLE_1:1;
    support ppf n c= Seg max S
    proof
      let x be set;
      assume
A49:  x in support ppf n;
      then
A50:  x is Prime by A48,Th34;
      reconsider m = x as natural number by A49;
A51:  1 <= m by A50,INT_2:def 5;
      m <= max S by A49,XXREAL_2:def 8;
      hence thesis by A51,FINSEQ_1:3;
    end;
    hence thesis by A47;
  end;
end;

