:: Fundamental {T}heorem of {A}rithmetic
::  by Artur Korni{\l}owicz and Piotr Rudnicki
::
:: Received February 13, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabularies GROUP_1, ARYTM_3, ORDINAL2, ARYTM, POLYNOM1, FILTER_0, FUNCT_1,
      FINSEQ_1, ALGSEQ_1, CARD_3, FINSET_1, ARYTM_1, BOOLE, SEQM_3, PBOOLE,
      NAT_1, RELAT_1, NAT_LAT, FUNCOP_1, CARD_1, SEQ_1, REALSET1, SQUARE_1,
      FINSEQ_2, UPROOTS, VECTSP_1, FUNCT_2, SETWISEO, SGRAPH1, NAT_3;
 notations TARSKI, XBOOLE_0, SUBSET_1, FINSET_1, REALSET1, ORDINAL1, ORDINAL2,
      CARD_1, NUMBERS, XCMPLX_0, XREAL_0, REAL_1, NAT_1, INT_2, NEWTON,
      RELAT_1, FUNCT_1, FUNCT_2, FINSEQ_1, SEQ_1, SEQM_3, NAT_LAT, PBOOLE,
      POLYNOM1, POLYNOM2, RVSUM_1, WSIERP_1, BINARITH, TREES_4, UPROOTS,
      BINOP_2, PRE_CIRC, SETWOP_2;
 constructors POLYNOM2, WSIERP_1, FINSOP_1, EULER_2, NAT_LAT, REAL_1, BINARITH,
      FINSEQOP, SEQ_2, DOMAIN_1, UPROOTS, PRE_CIRC, FACIRC_1, SETWISEO,
      BINOP_1, BINOP_2;
 registrations XREAL_0, NAT_1, INT_1, POLYNOM1, RELSET_1, CARD_5, MEMBERED,
      BINARITH, PRE_CIRC, SEQ_1, RELAT_1, TEX_2, FINSET_1, CIRCCMB3, XCMPLX_0,
      FUNCT_1, NEWTON, BINOP_2;
 requirements NUMERALS, SUBSET, ARITHM, REAL, BOOLE;
 definitions TARSKI, XBOOLE_0, INT_2, NAT_1, FINSEQ_1, SEQ_1, SEQM_3, POLYNOM1;
 theorems ORDINAL2, REAL_1, NEWTON, NAT_1, AXIOMS, XCMPLX_1, INT_1, CARD_4,
      XREAL_0, RVSUM_1, INT_2, CQC_THE1, PEPIN, PBOOLE, FUNCT_1, CARD_2,
      PREPOWER, POLYNOM1, FINSET_1, FINSEQ_1, TARSKI, XBOOLE_1, FUNCOP_1,
      CARD_1, WSIERP_1, XBOOLE_0, RADIX_1, AMI_5, BINARITH, BAGORDER, SEQ_1,
      FINSEQ_2, SEQM_3, FINSEQ_3, FINSEQ_4, JORDAN1A, REAL_2, RELAT_1, UPROOTS,
      PRE_CIRC, CIRCCMB3, FINSOP_1, FUNCT_2;
 schemes NAT_1, PRE_CIRC, GRAPH_2, FINSEQ_1, FINSEQ_2, PBOOLE, FUNCT_1,
      ZFREFLE1;

begin :: Preliminaries

reserve a, b, n for natural number,
        r for Real,
        f for FinSequence of REAL;

Lm1:
  for x being set st x in Seg n holds x is Nat;

registration
  let X be empty set;
  cluster card X -> empty;
coherence by CARD_1:47;
end;

registration
  cluster natural-yielding -> real-yielding Relation;
coherence
proof
  let R be Relation;
  assume rng R c= NAT;
  hence rng R c= REAL by XBOOLE_1:1;
end;
end;

registration :: cirrcmb3
  cluster natural-yielding FinSequence;
 existence
 proof
   consider f being FinSequence of NAT;
   take f;
   thus thesis;
 end;
 end;

registration
  let a be non empty natural number;
  let b be natural number;
  cluster a |^ b -> non empty;
coherence
proof
   a is Real & b is Nat by ORDINAL2:def 21,XREAL_0:def 1;
  hence thesis by CARD_4:51;
end;
end;

registration
  cluster -> non empty Prime;
coherence
proof
  let a be Prime;
   a > 1 by INT_2:def 5;
  then a > 0;
  hence thesis;
end;
end;

reserve p for Prime;

registration
  cluster SetPrimes -> infinite;
coherence by NEWTON:97;
end;

theorem Th1:
for a, b, c, d being natural number st a divides c & b divides d
 holds a*b divides c*d
proof let a, b, c, d be natural number;  given x being Nat such that
A1: c = a*x;
  given y being Nat such that
A2: d = b*y;
  take x*y;
  thus c*d = a*b*(x*y) by A1,A2;
end;

theorem Th2:
1 < a implies b <= a |^ b
proof
  assume
A1: 1 < a;
  then reconsider a1 = a-1 as Nat by INT_1:18;
  defpred P[natural number] means $1 <= a |^ $1;
A2: P[0] by NAT_1:18;
A3: for k being natural number st P[k] holds P[k+1]
  proof
    let k be natural number such that
A4:   P[k];
A5: k+1 <= a |^ k + 1 by A4,AXIOMS:24;
A6: a |^ (k+1) = a |^ k * a by NEWTON:11;
     now
A7:   a is Real by XREAL_0:def 1;
A8:   k is Nat by ORDINAL2:def 21;
      set x = a |^ k;
      assume x + 1 > x * a;
      then x*a - (x+1) < (x+1) - (x+1) by REAL_1:92;
      then x*a1 - 1 + 1 < 0+1 by REAL_1:53;
      then x*a1 <= 0 by NAT_1:38;
      then x*a1 = 0 by NAT_1:19;
      then x = 0 or a1 = 0 by XCMPLX_1:6;
      then x = 0 or a = 0+1;
      then a = 0 by A1,A7,A8,CARD_4:51;
      hence contradiction by A1;
    end;
    hence k+1 <= a |^ (k+1) by A5,A6,AXIOMS:22;
  end;
   for k being natural number holds P[k] from NAT_1:sch 2(A2,A3);
  hence b <= a |^ b;
end;

theorem Th3:
a <> 0 implies n divides n |^ a
proof
  assume a <> 0;
  then consider b being Nat such that
A1:  a = b+1 by NAT_1:22;
A2: n is Nat by ORDINAL2:def 21;
   1 <= b+1 by NAT_1:37;
  then n |^ 1 divides n |^ (b+1) by A2,RADIX_1:7;
  hence thesis by A1,NEWTON:10;
end;

theorem Th4:
for i, j, m, n being natural number
 st i < j & m |^ j divides n holds m |^ (i+1) divides n
proof let i, j, m, n be natural number such that
A1: i < j and
A2: m |^ j divides n;
  reconsider i,j,m as Nat by ORDINAL2:def 21;
    i+1 <= j by A1,NAT_1:38;
   then m |^ (i+1) divides m |^ j by RADIX_1:7;
 hence thesis by A2,NAT_1:51;
end;

theorem Th5:
p divides a |^ b implies p divides a
proof
  assume that
A1: p divides a |^ b and
A2: not p divides a;
  reconsider a as Nat by ORDINAL2:def 21;
  defpred P[Nat] means p divides a|^($1+1);
   now
    assume 0+1 > b;
    then b <= 0 by NAT_1:38;
    then b = 0 by NAT_1:18;
    then p divides 1 by A1,NEWTON:9;
    then p = 1 by WSIERP_1:20;
    hence contradiction by INT_2:def 5;
  end;
  then b = b-'1+1 by AMI_5:4;
  then A3: ex k being Nat st P[k] by A1;
A4: for k being Nat st k <> 0 & P[k] ex n being Nat st n < k & P[n]
  proof
    let k be Nat such that
A5:   k <> 0 and
A6:   P[k];
    take k-'1;
     k > 0 by A5,NAT_1:19;
    then A7: k >= 0+1 by NAT_1:38;
    then k-1 >= 0+1-1 by REAL_1:92;
    then k-'1 = k-1 by BINARITH:def 3;
    then k-'1 < k-0 by REAL_1:92;
    hence k-'1 < k;
A8: k-'1+1 = k by A7,AMI_5:4;
     p divides a |^ k * a by A6,NEWTON:11;
    hence P[k-'1] by A2,A8,NEWTON:98;
  end;
   P[0] from NAT_1:sch 7(A3,A4);
  hence thesis by A2,NEWTON:10;
end;

theorem Th6:
for a being Prime st a divides p |^ b holds a = p
proof
  let a be Prime such that
A1: a divides p |^ b;
A2: a <> 1 by INT_2:def 5;
   a divides p by A1,Th5;
  hence a = p by A2,INT_2:def 5;
end;

theorem
 for f being FinSequence of NAT st a in rng f holds a divides Product f
proof
  defpred P[FinSequence of NAT] means
   for a being natural number st a in rng $1 holds a divides Product $1;
A1: P[<*>NAT];
A2: for p being FinSequence of NAT, n being Nat st P[p] holds P[p^<*n*>] proof
    let p be FinSequence of NAT, n be Nat such that
   A3: P[p];
    set p1 = p^<*n*>;
    let a be natural number such that
   A4: a in rng p1;
   A5: rng p1 = rng p \/ rng <*n*> by FINSEQ_1:44;
   A6: Product p1 = Product p * n by RVSUM_1:126;
     per cases by A4,A5,XBOOLE_0:def 2;
     suppose a in rng p; then a divides Product p by A3;
      hence a divides Product p1 by A6,NAT_1:56;
    end;
     suppose a in rng <*n*>; then a in {n} by FINSEQ_1:56;
       then a = n by TARSKI:def 1;
      hence a divides Product p1 by A6,NAT_1:56;
    end;
   end;
   for p being FinSequence of NAT holds P[p] from FINSEQ_2:sch 2(A1,A2);
 hence thesis;
end;

theorem
 for f being FinSequence of SetPrimes st p divides Product f holds p in rng f
proof
  defpred P[FinSequence of SetPrimes] means
   for p being Prime st p divides Product $1 holds p in rng $1;
A1: P[<*>SetPrimes] proof
    let p being Prime;
    assume p divides Product <*>SetPrimes;
    then p <= 1 by NAT_1:54,RVSUM_1:124;
    hence p in rng <*>SetPrimes by INT_2:def 5;
  end;
A2: now let f be FinSequence of SetPrimes, n be Element of SetPrimes; assume
   A3: P[f];
   set f1 = f^<*n*>;
    thus P[f1] proof
     let p be Prime;
     assume
    A4: p divides Product f1;
        reconsider ff = f as FinSequence of NAT;
    A5:  p divides Product ff * n by A4,RVSUM_1:126;
     reconsider nn = n as Nat;
     per cases by A5,NEWTON:98;
     suppose p divides Product f;
     then A6: p in rng f by A3;
          rng f c= rng f1 by FINSEQ_1:42;
      hence p in rng f1 by A6;
    end;
     suppose A7: p divides nn;
        nn is prime by NEWTON:def 6;
       then p = 1 or p = n by A7,INT_2:def 5;
       then p in {n} by INT_2:def 5,TARSKI:def 1;
     then A8: p in rng <*n*> by FINSEQ_1:55;
          rng <*n*> c= rng f1 by FINSEQ_1:43;
      hence p in rng f1 by A8;
    end;
    end;
   end;
    for p being FinSequence of SetPrimes holds P[p] from FINSEQ_2:sch 2(A1,A2);
  hence thesis;
end;

:: Power

definition
  let f be real-yielding FinSequence;
  let a be natural number;
  func f |^ a -> FinSequence means :Def1:
  len it = len f &
  for i being set st i in dom it holds it.i = f.i |^ a;
existence
proof
  deffunc F(Nat) = f.$1 |^ a;
  consider p being FinSequence such that
A1: len p = len f and
A2: for k being Nat st k in Seg len f holds p.k = F(k) from FINSEQ_1:sch 2;
  take p;
  thus len p = len f by A1;
   dom p = Seg len p by FINSEQ_1:def 3;
  hence thesis by A1,A2;
end;
uniqueness
proof
  let g,h be FinSequence such that
A3: len g = len f and
A4: for i being set st i in dom g holds g.i = f.i |^ a and
A5: len h = len f and
A6: for i being set st i in dom h holds h.i = f.i |^ a;
A7: dom g = Seg len g by FINSEQ_1:def 3;
A8: dom h = Seg len h by FINSEQ_1:def 3;
   for k being Nat st k in dom g holds g.k = h.k
  proof
    let k be Nat such that
A9:   k in dom g;
    thus g.k = f.k |^ a by A4,A9
      .= h.k by A3,A5,A6,A7,A8,A9;
  end;
  hence g = h by A3,A5,A7,A8,FINSEQ_1:17;
end;
end;

registration
  let f be real-yielding FinSequence;
  let a be natural number;
  cluster f |^ a -> real-yielding;
coherence
proof
  set g = f|^a;
  let y be set;
  assume y in rng g;
  then consider x being set such that
A1:  x in dom g & g.x = y by FUNCT_1:def 5;
   y = f.x |^ a by A1,Def1;
  hence y in REAL;
end;
end;

registration
  let f be natural-yielding FinSequence;
  let a be natural number;
  cluster f |^ a -> natural-yielding;
coherence
proof
  set g = f|^a;
  let y be set;
  assume y in rng g;
  then consider x being set such that
A1:  x in dom g & g.x = y by FUNCT_1:def 5;
   y = f.x |^ a by A1,Def1;
  hence y in NAT by ORDINAL2:def 21;
end;
end;

definition
  let f be FinSequence of REAL;
  let a be natural number;
  redefine func f |^ a -> FinSequence of REAL;
coherence
proof
  thus rng (f|^a) c= REAL by SEQ_1:def 1;
end;
end;

definition
  let f be FinSequence of NAT;
  let a be natural number;
  redefine func f |^ a -> FinSequence of NAT;
coherence
proof
  thus rng (f|^a) c= NAT by SEQM_3:def 8;
end;
end;

theorem Th9:
f |^ 0 = (len f) |-> 1
proof
A1: len (f|^0) = len f by Def1;
A2: len (len f |-> 1) = len f by FINSEQ_2:69;
   for k being Nat st 1 <= k & k <= len (f|^0)
   holds (f|^0).k = (len f |-> 1).k
  proof
    let k be Nat;
    assume 1 <= k & k <= len (f|^0);
    then A3: k in dom (f|^0) by FINSEQ_3:27;
    then A4: k in Seg len f by A1,FINSEQ_1:def 3;
    thus (f|^0).k = f.k |^ 0 by A3,Def1
     .= 1 by NEWTON:9
     .= (len f |-> 1).k by A4,FINSEQ_2:70;
  end;
  hence thesis by A1,A2,FINSEQ_1:18;
end;

theorem
 f |^ 1 = f
proof
A1: len (f|^1) = len f by Def1;
   for k being Nat st 1 <= k & k <= len (f|^1) holds (f|^1).k = f.k
  proof
    let k be Nat;
    assume 1 <= k & k <= len (f|^1);
    then k in dom (f|^1) by FINSEQ_3:27;
    hence (f|^1).k = f.k |^ 1 by Def1
     .= f.k by NEWTON:10;
  end;
  hence thesis by A1,FINSEQ_1:18;
end;

theorem Th11:
<*>REAL |^ a = <*>REAL
proof
   len (<*>REAL |^ a) = len <*>REAL by Def1 .= 0;
  hence thesis by FINSEQ_1:32;
end;

theorem Th12:
<*r*>|^a = <*r|^a*>
proof
A1: len (<*r*>|^a) = len <*r*> by Def1 .= 1 by FINSEQ_1:57;
     0+1 in Seg (0+1) by FINSEQ_1:6;
    then 1 in dom (<*r*>|^a) by A1,FINSEQ_1:def 3;
  then (<*r*>|^a).1 = (<*r*>.1) |^ a by Def1
    .= r |^ a by FINSEQ_1:57;
 hence <*r*>|^a = <*r|^a*> by A1,FINSEQ_1:57;
end;

theorem Th13:
(f^<*r*>) |^ a = (f|^a)^(<*r*>|^a)
proof
A1: len ((f^<*r*>) |^ a) = len (f^<*r*>) by Def1
   .= len f + len <*r*> by FINSEQ_1:35
   .= len f + 1 by FINSEQ_1:57;
A2: len ((f|^a)^(<*r*>|^a)) = len (f|^a) + len (<*r*>|^a) by FINSEQ_1:35
   .= len f + len (<*r*>|^a) by Def1
   .= len f + len (<*r|^a*>) by Th12
   .= len f + 1 by FINSEQ_1:57;
A3: len (f|^a) = len f by Def1;
   now let i be Nat such that
  A4: i in Seg (len f +1);
  A5: 1 <= i & i <= len f + 1 by A4,FINSEQ_1:3;
  A6: i in dom ((f^<*r*>) |^ a) by A1,A4,FINSEQ_1:def 3;
      per cases by A5,REAL_1:def 5;
      suppose i < len f +1;
then A7:      i <= len f by NAT_1:38;
      then A8: i in dom f by A5,FINSEQ_3:27;
      A9: i in dom (f|^a) by A3,A5,A7,FINSEQ_3:27;
       thus ((f^<*r*>) |^ a).i
          = (f^<*r*>).i |^ a by A6,Def1
         .= f.i |^a by A8,FINSEQ_1:def 7
         .= (f|^a).i by A9,Def1
         .= ((f|^a)^(<*r*>|^a)).i by A9,FINSEQ_1:def 7;
       end;
      suppose A10: i = len f +1;
       thus ((f^<*r*>) |^ a).i = (f^<*r*>).i |^ a by A6,Def1
          .= r |^ a by A10,FINSEQ_1:59
          .= ((f|^a)^(<*r|^a*>)).i by A3,A10,FINSEQ_1:59
          .= ((f|^a)^(<*r*>|^a)).i by Th12;
    end;
  end;
 hence (f^<*r*>) |^ a = (f|^a)^(<*r*>|^a) by A1,A2,FINSEQ_2:10;
end;

theorem Th14:
Product (f|^(b+1)) = Product (f|^b) * Product f
proof
  defpred P[FinSequence of REAL] means
    for b being natural number
     holds Product ($1|^(b+1)) = Product ($1|^b) * Product $1;
A1: P[<*>REAL] proof let b be natural number;
      set f = <*>REAL;
     thus Product (f|^(b+1)) = 1 by Th11,RVSUM_1:124
       .= Product (f|^b) * Product f by Th11,RVSUM_1:124;
    end;
A2: now let p be FinSequence of REAL, x being Element of REAL such that
     A3: P[p];
      thus P[p^<*x*>] proof let b be natural number;
        set p1 = p^<*x*>;
       p1 |^ (b+1) = (p|^(b+1))^(<*x*>|^(b+1)) by Th13;
       hence Product (p1|^(b+1))
          = Product (p|^(b+1)) * Product (<*x*>|^(b+1)) by RVSUM_1:127
         .= (Product (p|^b) * Product p) * Product (<*x*>|^(b+1)) by A3
         .= (Product (p|^b) * Product p) * Product (<*x|^(b+1)*>) by Th12
         .= (Product (p|^b) * Product p) * x|^(b+1) by RVSUM_1:125
         .= (Product (p|^b) * Product p) * (x|^b * x) by NEWTON:11
         .= Product (p|^b) * x|^b * x * Product p
         .= Product (p|^b ^ <*x|^b*>) * x * Product p by RVSUM_1:126
         .= Product (p|^b ^ (<*x*>|^b)) * x * Product p by Th12
         .= Product (p1|^b) * x * Product p by Th13
         .= Product (p1|^b) * (Product p * x)
         .= Product (p1|^b) * Product p1 by RVSUM_1:126;
      end;
    end;
     for p being FinSequence of REAL holds P[p] from FINSEQ_2:sch 2(A1,A2);
  hence thesis;
end;

theorem
 Product (f|^a) = (Product f) |^ a
proof defpred P[natural number] means Product (f|^$1) = (Product f) |^ $1;
A1: P[0] proof
     thus Product (f|^0) = Product ((len f) |-> 1) by Th9
                        .= 1 by RVSUM_1:132 .= (Product f) |^ 0 by NEWTON:9;
    end;
A2: P[b] implies P[b+1]
  proof assume
A3:   P[b];
    thus Product (f|^(b+1)) = Product (f|^b) * Product f by Th14
      .= (Product f) |^ (b+1) by A3,NEWTON:11;
  end;
   P[b] from NAT_1:sch 2(A1,A2);
  hence Product (f|^a) = (Product f) |^ a;
end;

begin :: More about bags

registration :: cluster natural-yielding FinSequence;
   let X be set;
   cluster natural-yielding finite-support ManySortedSet of X;
   existence proof
     consider r being natural-yielding finite-support ManySortedSet of X;
::       ten cluster jest w polynom1
      r = r;
    hence thesis;
   end;
end;

definition
  let X be set, b be real-yielding ManySortedSet of X, a be natural number;
  func a * b -> ManySortedSet of X means :Def2:
  for i being set holds it.i = a * b.i;
existence
proof
  deffunc F(set) = a * b.$1;
  consider f being ManySortedSet of X such that
A1:  for i being set st i in X holds f.i = F(i) from PBOOLE:sch 4;
  take f;
  let i be set;
  per cases;
  suppose i in X;
  hence f.i = a * b.i by A1;
  end;
  suppose
A2: not i in X;
A3: dom b = X by PBOOLE:def 3;
   dom f = X by PBOOLE:def 3;
  hence f.i = a * 0 by A2,FUNCT_1:def 4
      .= a * b.i by A2,A3,FUNCT_1:def 4;
  end;
end;
uniqueness
proof
  let f, g be ManySortedSet of X such that
A4:  for i being set holds f.i = a * b.i and
A5:  for i being set holds g.i = a * b.i;
   for i being set st i in X holds f.i = g.i
  proof
    let i be set;
    assume i in X;
    thus f.i = a * b.i by A4
      .= g.i by A5;
  end;
  hence thesis by PBOOLE:3;
end;
end;

registration
  let X be set, b be real-yielding ManySortedSet of X, a be natural number;
  cluster a * b -> real-yielding;
coherence
proof
  let y be set;
  assume y in rng (a*b);
  then consider i being set such that
A1:  i in dom (a*b) & (a*b).i = y by FUNCT_1:def 5;
   y = a * b.i by A1,Def2;
  hence thesis by XREAL_0:def 1;
end;
end;

registration
  let X be set, b be natural-yielding ManySortedSet of X, a be natural number;
  cluster a * b -> natural-yielding;
coherence
proof
  let y be set;
  assume y in rng (a*b);
  then consider i being set such that
A1:  i in dom (a*b) & (a*b).i = y by FUNCT_1:def 5;
   y = a * b.i by A1,Def2;
  hence thesis by ORDINAL2:def 21;
end;
end;

registration
  let X be set, b be real-yielding ManySortedSet of X;
  cluster support (0*b) -> empty;
coherence
proof
  assume support (0*b) is non empty;
  then consider x being set such that
A1:  x in support (0*b) by XBOOLE_0:def 1;
   (0*b).x <> 0 by A1,POLYNOM1:def 7;
  then 0 * b.x <> 0 by Def2;
  hence thesis;
end;
end;

theorem Th16:
for X being set, b being real-yielding ManySortedSet of X
 st a <> 0 holds support b = support (a*b)
proof let X be set, b be real-yielding ManySortedSet of X such that
A1: a <> 0;
  hereby
    let x be set;
    assume x in support b;
    then b.x <> 0 by POLYNOM1:def 7;
    then a*b.x <> 0 by A1,XCMPLX_1:6;
    then (a*b).x <> 0 by Def2;
    hence x in support (a*b) by POLYNOM1:def 7;
  end;
  let x be set;
  assume x in support (a*b);
  then (a*b).x <> 0 by POLYNOM1:def 7;
  then a*b.x <> 0 by Def2;
  then b.x <> 0;
  hence x in support b by POLYNOM1:def 7;
end;

registration
  let X be set, b be real-yielding finite-support ManySortedSet of X,
      a be natural number;
  cluster a * b -> finite-support;
coherence
proof
  per cases;
  suppose
A1: a = 0;
   support (0*b) = {};
  hence support (a*b) is finite by A1;
  end;
  suppose a <> 0;
  then support (a*b) = support b by Th16;
  hence support (a*b) is finite;
  end;
end;
end;

definition
  let X be set; let b1, b2 be real-yielding ManySortedSet of X;
  func min(b1,b2) -> ManySortedSet of X means :Def3:
  for i being set holds (b1.i <= b2.i implies it.i = b1.i) &
                        (b1.i > b2.i implies it.i = b2.i);
existence
proof
  defpred P[set] means b1.$1 <= b2.$1;
  deffunc F(set) = b1.$1;
  deffunc G(set) = b2.$1;
  consider f being ManySortedSet of X such that
A1: for i being Element of X st i in X
      holds (P[i] implies f.i = F(i)) & (not P[i] implies f.i = G(i))
      from PRE_CIRC:sch 2;
  take f;
  let i be set;
  per cases;
  suppose i in X;
  hence thesis by A1;
  end;
  suppose not i in X;
  then not i in dom f & not i in dom b1 & not i in dom b2 by PBOOLE:def 3;
  then f.i = 0 & b1.i = 0 & b2.i = 0 by FUNCT_1:def 4;
  hence thesis;
  end;
end;
uniqueness
proof
  let f, g be ManySortedSet of X such that
A2:  for i being set holds (b1.i <= b2.i implies f.i = b1.i) &
                           (b1.i > b2.i implies f.i = b2.i) and
A3:  for i being set holds (b1.i <= b2.i implies g.i = b1.i) &
                           (b1.i > b2.i implies g.i = b2.i);
   now
    let i be set;
    assume i in X;
    per cases;
    suppose
A4:   b1.i <= b2.i;
    hence f.i = b1.i by A2
             .= g.i by A3,A4;
    end;
    suppose
A5:   b1.i > b2.i;
    hence f.i = b2.i by A2
       .= g.i by A3,A5;
    end;
  end;
  hence thesis by PBOOLE:3;
end;
end;

registration
  let X be set; let b1, b2 be real-yielding ManySortedSet of X;
  cluster min(b1,b2) -> real-yielding;
coherence
proof
  set f = min(b1,b2);
  let y be set;
  assume y in rng f;
  then consider x being set such that
     x in dom f and
A1: f.x = y by FUNCT_1:def 5;
   b1.x <= b2.x or b1.x > b2.x;
  then f.x = b1.x or f.x = b2.x by Def3;
  hence thesis by A1;
end;
end;

registration
  let X be set; let b1, b2 be natural-yielding ManySortedSet of X;
  cluster min(b1,b2) -> natural-yielding;
coherence
proof
  set f = min(b1,b2);
  let y be set;
  assume y in rng f;
  then consider x being set such that
     x in dom f and
A1: f.x = y by FUNCT_1:def 5;
   b1.x <= b2.x or b1.x > b2.x;
  then f.x = b1.x or f.x = b2.x by Def3;
  hence thesis by A1;
end;
end;

theorem Th17:
for X being set, b1, b2 being real-yielding finite-support ManySortedSet of X
  holds support min(b1,b2) c= support b1 \/ support b2
proof
  let X be set; let b1, b2 be real-yielding finite-support ManySortedSet of X;
  set f = min(b1,b2);
  let x be set;
  assume x in support f;
  then A1: f.x <> 0 by POLYNOM1:def 7;
   b1.x <= b2.x or b1.x > b2.x;
  then f.x = b1.x or f.x = b2.x by Def3;
  then x in support b1 or x in support b2 by A1,POLYNOM1:def 7;
  hence x in support b1 \/ support b2 by XBOOLE_0:def 2;
end;

registration
  let X be set; let b1, b2 be real-yielding finite-support ManySortedSet of X;
  cluster min(b1,b2) -> finite-support;
coherence
proof
   support min(b1,b2) c= support b1 \/ support b2 by Th17;
  hence support min(b1,b2) is finite by FINSET_1:13;
end;
end;

definition
  let X be set; let b1, b2 be real-yielding ManySortedSet of X;
  func max(b1,b2) -> ManySortedSet of X means :Def4:
  for i being set holds (b1.i <= b2.i implies it.i = b2.i) &
                        (b1.i > b2.i implies it.i = b1.i);
existence
proof
  defpred P[set] means b1.$1 <= b2.$1;
  deffunc F(set) = b2.$1;
  deffunc G(set) = b1.$1;
  consider f being ManySortedSet of X such that
A1: for i being Element of X st i in X
      holds (P[i] implies f.i = F(i)) & (not P[i] implies f.i = G(i))
      from PRE_CIRC:sch 2;
  take f;
  let i be set;
  per cases;
  suppose i in X;
  hence thesis by A1;
  end;
  suppose not i in X;
  then not i in dom f & not i in dom b1 & not i in dom b2 by PBOOLE:def 3;
  then f.i = 0 & b1.i = 0 & b2.i = 0 by FUNCT_1:def 4;
  hence thesis;
  end;
end;
uniqueness
proof
  let f, g be ManySortedSet of X such that
A2:  for i being set holds (b1.i <= b2.i implies f.i = b2.i) &
                           (b1.i > b2.i implies f.i = b1.i) and
A3:  for i being set holds (b1.i <= b2.i implies g.i = b2.i) &
                           (b1.i > b2.i implies g.i = b1.i);
   now
    let i be set;
    assume i in X;
    per cases;
    suppose
A4:   b1.i <= b2.i;
    hence f.i = b2.i by A2
             .= g.i by A3,A4;
    end;
    suppose
A5:   b1.i > b2.i;
    hence f.i = b1.i by A2
       .= g.i by A3,A5;
    end;
  end;
  hence thesis by PBOOLE:3;
end;
end;

registration
  let X be set; let b1, b2 be real-yielding ManySortedSet of X;
  cluster max(b1,b2) -> real-yielding;
coherence
proof
  set f = max(b1,b2);
  let y be set;
  assume y in rng f;
  then consider x being set such that
     x in dom f and
A1: f.x = y by FUNCT_1:def 5;
   b1.x <= b2.x or b1.x > b2.x;
  then f.x = b1.x or f.x = b2.x by Def4;
  hence thesis by A1;
end;
end;

registration
  let X be set; let b1, b2 be natural-yielding ManySortedSet of X;
  cluster max(b1,b2) -> natural-yielding;
coherence
proof
  set f = max(b1,b2);
  let y be set;
  assume y in rng f;
  then consider x being set such that
     x in dom f and
A1: f.x = y by FUNCT_1:def 5;
   b1.x <= b2.x or b1.x > b2.x;
  then f.x = b1.x or f.x = b2.x by Def4;
  hence thesis by A1;
end;
end;

theorem Th18:
for X being set, b1, b2 being real-yielding finite-support ManySortedSet of X
  holds support max(b1,b2) c= support b1 \/ support b2
proof
  let X be set; let b1, b2 be real-yielding finite-support ManySortedSet of X;
  set f = max(b1,b2);
  let x be set;
  assume x in support f;
  then A1: f.x <> 0 by POLYNOM1:def 7;
   b1.x <= b2.x or b1.x > b2.x;
  then f.x = b1.x or f.x = b2.x by Def4;
  then x in support b1 or x in support b2 by A1,POLYNOM1:def 7;
  hence x in support b1 \/ support b2 by XBOOLE_0:def 2;
end;

registration
  let X be set; let b1, b2 be real-yielding finite-support ManySortedSet of X;
  cluster max(b1,b2) -> finite-support;
coherence
proof
   support max(b1,b2) c= support b1 \/ support b2 by Th18;
  hence support max(b1,b2) is finite by FINSET_1:13;
end;
end;

definition
  let A be set, b be bag of A;
  func Product b -> natural number means                            :Def5:
  ex f being FinSequence of NAT st it = Product f & f = b*canFS(support b);
  existence proof set cS = canFS(support b);
   set f = b*cS;
  A1: rng b c= NAT by SEQM_3:def 8;
  A2: support b c= dom b by POLYNOM1:41;  rng cS = support b by UPROOTS:5;
     then dom f = dom cS by A2,RELAT_1:46;
     then dom f = Seg len cS by FINSEQ_1:def 3;
  then A3: f is FinSequence by FINSEQ_1:def 2;
      rng f c= rng b by RELAT_1:45; then rng f c= NAT by A1,XBOOLE_1:1;
   then reconsider f as FinSequence of NAT by A3,FINSEQ_1:def 4;
   take S = Product f; thus thesis;
  end;
  uniqueness;
end;

definition
  let A be set, b be bag of A;
  redefine func Product b -> Nat;
  coherence by ORDINAL2:def 21;
end;

theorem Th19:
for X being set, a, b being bag of X
 st support a misses support b holds Product (a+b) = (Product a) * Product b
proof let X be set, a, b be bag of X; assume support a misses support b;
then A1: support a /\ support b = {} by XBOOLE_0:def 7;
   set ab= a+b; set Pa = Product a, Pb = Product b, Pab = Product ab;
   set sab = support (a+b); set sa = support a; set sb = support b;
   consider f being FinSequence of NAT such that
A2: Pab = Product f and
A3: f = ab*canFS(support ab) by Def5;
   consider fa being FinSequence of NAT such that
A4: Pa = Product fa and
A5: fa = a*canFS(support a) by Def5;
   consider fb being FinSequence of NAT such that
A6: Pb = Product fb and
A7: fb = b*canFS(support b) by Def5;
   set g = fa^fb; set ca = canFS(support a), cb = canFS(support b);
   set cg = ca^cb, cf = canFS(support ab);   set p = cg" * cf;
    len cf = card sab by UPROOTS:def 1;
then A8: dom cf = Seg card sab by FINSEQ_1:def 3;
A9: rng cf = sab by UPROOTS:5;
A10: cf is one-to-one by UPROOTS:4;
    dom ab = X by PBOOLE:def 3;
then A11: dom f = Seg card sab by A3,A8,A9,RELAT_1:46;
A12: len cb = card sb by UPROOTS:def 1;
A13: len ca = card sa by UPROOTS:def 1;
A14: sab = sa \/ sb by POLYNOM1:42;
A15: rng cb = sb by UPROOTS:5;
A16: rng ca = sa by UPROOTS:5;
A17: cb is one-to-one by UPROOTS:4;
A18: ca is one-to-one by UPROOTS:4;
A19: len cg = card sa + card sb - card {} by A12,A13,CARD_1:78,FINSEQ_1:35
        .= card sab by A1,A14,CARD_2:64;
then A20: dom cg = Seg card sab by FINSEQ_1:def 3;
A21: rng cg = sab by A14,A15,A16,FINSEQ_1:44;
then A22: cg is one-to-one by A19,FINSEQ_4:77;
then A23: dom (cg") = sab by A21,FUNCT_1:55;
A24: rng (cg") = Seg card sab by A20,A22,FUNCT_1:55;
A25: dom (cb") = sb by A15,A17,FUNCT_1:54;
A26: dom cb = Seg card sb by A12,FINSEQ_1:def 3;
A27: rng (cb") = dom cb by A17,FUNCT_1:55;
A28: dom (ca") = sa by A16,A18,FUNCT_1:54;
A29: dom ca = Seg card sa by A13,FINSEQ_1:def 3;
A30: rng (ca") = dom ca by A18,FUNCT_1:55;
    dom a = X by PBOOLE:def 3;
then A31: dom ca = dom fa by A5,A16,RELAT_1:46;
then A32: len ca = len fa by FINSEQ_3:31;
    dom b = X by PBOOLE:def 3;
   then dom cb = dom fb by A7,A15,RELAT_1:46;
then A33: len cb = len fb by FINSEQ_3:31;
A34: len cg = len ca + len cb by FINSEQ_1:35;
A35: dom p = Seg card sab by A8,A9,A23,RELAT_1:46;
    len g = card sa + card sb - card {}
        by A12,A13,A32,A33,CARD_1:78,FINSEQ_1:35
        .= card sab by A1,A14,CARD_2:64;
then A36: dom g = Seg card sab by FINSEQ_1:def 3;
A37: rng p = rng (cg") by A9,A23,RELAT_1:47;
   then reconsider p as Function of dom g, dom g by A24,A35,A36,FUNCT_2:3;
    cg" is one-to-one by A22,FUNCT_1:62;
then A38: p is one-to-one by A10,FUNCT_1:46;
    p is onto by A24,A36,A37,FUNCT_2:def 3;
   then reconsider p as Permutation of dom g by A38,FUNCT_2:def 4;
A39: dom (g*p) = Seg card sab by A24,A35,A36,A37,RELAT_1:46;
    now let x be set; assume
   A40: x in dom f;       set cgx = cg".(cf.x);
   A41: (g*p).x = g.(p.x) by A11,A39,A40,FUNCT_1:22
              .= g.cgx by A8,A11,A40,FUNCT_1:23;
   A42: cf.x in sab by A8,A9,A11,A40,FUNCT_1:12;
       then cgx in Seg card sab by A23,A24,FUNCT_1:12;
       then reconsider cgx as natural number by Lm1;
       reconsider cgxN = cgx as Nat by ORDINAL2:def 21;
       consider d being set such that
   A43: d in dom cg and
   A44: cg.d = cf.x by A21,A42,FUNCT_1:def 5;
   A45: cgx = d by A22,A43,A44,FUNCT_1:56;
   then A46: cgxN <= len fa + len fb by A32,A33,A34,A43,FINSEQ_3:27;
   A47: 1 <= cgxN by A43,A45,FINSEQ_3:27;
    per cases by A14,A42,XBOOLE_0:def 2;
    suppose A48: cf.x in sa;
    then A49: not cf.x in sb by A1,XBOOLE_0:def 3;
        set cax = ca".(cf.x);
         cax in rng (ca") by A28,A48,FUNCT_1:12;
        then reconsider cax as natural number by A29,A30,Lm1;
     now assume len fa < cgx;
        then A50: len fa +1 <= cgx by NAT_1:38;
        then A51: cg.cgxN = cb.(cgx-len ca) by A32,A33,A46,FINSEQ_1:36;
        A52: len ca +1 - len ca <= cgx - len ca by A32,A50,REAL_1:49;
            then 0 <= cgx - len ca;
        then A53: cgx - len ca is Nat by INT_1:16;
             cgx -len ca <= len ca + len cb - len ca by A32,A33,A46,REAL_1:49;
            then cgx-len ca in dom cb by A52,A53,FINSEQ_3:27;
         hence contradiction by A15,A44,A45,A49,A51,FUNCT_1:12;
        end;
    then A54: cgxN in dom fa by A47,FINSEQ_3:27;
    then A55: cg.cgx = ca.cgx by A31,FINSEQ_1:def 7;
    A56: g.cgx = fa.cgxN by A54,FINSEQ_1:def 7
        .= a.(cf.x) by A5,A31,A44,A45,A54,A55,FUNCT_1:23;
     thus f.x = ab.(cf.x) by A3,A40,FUNCT_1:22
             .= a.(cf.x) + b.(cf.x) by POLYNOM1:def 5
             .= a.(cf.x) + 0 by A49,POLYNOM1:def 7
             .= (g*p).x by A41,A56;
    end;
    suppose A57: cf.x in sb;
    then A58: not cf.x in sa by A1,XBOOLE_0:def 3;
        set cbx = cb".(cf.x);
         cbx in rng (cb") by A25,A57,FUNCT_1:12;
        then reconsider cbx as natural number by A26,A27,Lm1;
    A59: now assume len fa +1 > cgx; then cgx <= len fa by NAT_1:38;
        then A60: cgx in dom ca by A31,A47,FINSEQ_3:27;
            then ca.cgx in sa by A16,FUNCT_1:12;
            then cg.cgxN in sa by A60,FINSEQ_1:def 7;
         hence contradiction by A1,A44,A45,A57,XBOOLE_0:def 3;
        end;
    then A61: cg.cgx = cb.(cgx-len ca) by A32,A33,A46,FINSEQ_1:36;
    A62: cgx-len ca <= len ca + len cb - len ca by A32,A33,A46,REAL_1:49;
    A63: len ca + 1 - len ca <= cgx-len ca by A32,A59,REAL_1:49;
        then 0 <= cgxN-len ca;
        then cgxN-len ca is Nat by INT_1:16;
    then A64: cgxN-len ca in dom cb by A62,A63,FINSEQ_3:27;
    A65: g.cgx = fb.(cgxN-len fa) by A46,A59,FINSEQ_1:36
        .= b.(cf.x) by A7,A32,A44,A45,A61,A64,FUNCT_1:23;
     thus f.x = ab.(cf.x) by A3,A40,FUNCT_1:22
             .= a.(cf.x) + b.(cf.x) by POLYNOM1:def 5
             .= 0 + b.(cf.x) by A58,POLYNOM1:def 7
             .= (g*p).x by A41,A65;
    end;
   end;
then A66: f = g*p by A11,A39,FUNCT_1:9;
 thus Product (a+b) = multreal $$ f by A2,RVSUM_1:def 11
   .= multreal $$ g by A66,FINSOP_1:8
   .= Product g by RVSUM_1:def 11
   .= (Product a) * Product b by A4,A6,RVSUM_1:127;
end;

definition
  let X be set, b be real-yielding ManySortedSet of X,
      n be non empty natural number;
  func b |^ n -> ManySortedSet of X means :Def6:
  support it = support b &
  for i being set holds it.i = b.i |^ n;
  existence proof
    deffunc F(Element of X) = b.$1 |^ n;
    defpred P[set,set] means ex a being Element of X st a = $1 & $2 = F(a);
  A1: dom b = X by PBOOLE:def 3;
A2: for e being set st e in X ex u being set st P[e,u]
  proof
    let e be set;
    assume e in X;
    then reconsider f = e as Element of X;
    take F(f), f;
    thus thesis;
  end;
    consider f being Function such that
  A3: dom f = X and
  A4: for x being set st x in X holds P[x,f.x] from ZFREFLE1:sch 1(A2);
     reconsider n1 = n as Nat by ORDINAL2:def 21;
  A5: n1 >= 1 by UPROOTS:1;
     reconsider f as ManySortedSet of X by A3,PBOOLE:def 3;
     take f;
      now let x be set;
       hereby assume A6: x in support f;
        assume not x in support b;
         then b.x = 0 by POLYNOM1:def 7;
       then A7: b.x |^ n = 0 by A5,NEWTON:16;
           support f c= X by A3,POLYNOM1:41;
          then P[x,f.x] by A4,A6;
          then f.x = 0 by A7;
        hence contradiction by A6,POLYNOM1:def 7;
       end;
       assume x in support b;
       then A8: b.x <> 0 by POLYNOM1:def 7;
          now per cases;
          suppose x in X;
          then P[x,f.x] by A4;
          hence f.x = b.x |^ n1;
          end;
          suppose
        A9:  not x in X;
          hence f.x = 0 by A3,FUNCT_1:def 4
            .= 0 |^ n1 by A5,NEWTON:16
            .= b.x |^ n1 by A1,A9,FUNCT_1:def 4;
         end;
         end;
         then f.x <> 0 by A8,CARD_4:51;
       hence x in support f by POLYNOM1:def 7;
     end;
     hence support f = support b by TARSKI:2;
     let i be set;
     per cases;
     suppose i in X;
     then P[i,f.i] by A4;
     hence f.i = b.i |^ n;
     end;
     suppose
  A10:   not i in X;
     hence f.i = 0 by A3,FUNCT_1:def 4
        .= 0 |^ n by A5,NEWTON:16
        .= b.i |^ n by A1,A10,FUNCT_1:def 4;
     end;
  end;
  uniqueness proof let it1, it2 be ManySortedSet of X such that
      support it1 = support b and
  A11: for i being set holds it1.i = b.i |^ n and
      support it2 = support b and
  A12: for i being set holds it2.i = b.i |^ n;
     now let x be set such that x in X;
     thus it1.x = b.x |^ n by A11 .= it2.x by A12;
    end;
   hence it1 = it2 by PBOOLE:3;
  end;
end;

registration
  let X be set, b be natural-yielding ManySortedSet of X,
      n be non empty natural number;
  cluster b |^ n -> natural-yielding;
coherence
proof
  set f = b |^ n;
  let y be set; assume y in rng f;
  then consider x being set such that
     x in dom f and
A1: f.x = y by FUNCT_1:def 5;
   f.x = b.x |^ n by Def6;
  hence thesis by A1,ORDINAL2:def 21;
end;
end;

registration
  let X be set, b be real-yielding finite-support ManySortedSet of X,
      n be non empty natural number;
  cluster b |^ n -> finite-support;
coherence
proof
   support b|^n = support b by Def6;
  hence support b|^n is finite;
end;
end;

theorem Th20:
for A being set holds Product EmptyBag A = 1
proof let A be set; set b = EmptyBag A; set cS = canFS(support b);
   support b = {} by BAGORDER:19;
  then len cS = 0 by CARD_1:78,UPROOTS:def 1; then cS = <*>NAT by FINSEQ_1:32
;
 then b*cS = <*>NAT by RELAT_1:62;
 hence Product b = 1 by Def5,RVSUM_1:124;
end;

begin :: Multiplicity of a divisor

definition
  let n, d be natural number such that
A1: d <> 1 and
A2: n <> 0;
  func d |-count n -> Nat means :Def7:
  d |^ it divides n & not d |^ (it+1) divides n;
existence
proof
  reconsider d1 = d, n1 = n as Nat by ORDINAL2:def 21;
  per cases;
  suppose A3: d = 0;
   take 0;   0 |^ 0 = 1 by NEWTON:9;
   hence d |^ 0 divides n by A3,NAT_1:53;
     not 0 divides n1 by A2,INT_2:3;
   hence not d |^ (0+1) divides n by A3,NEWTON:16;
    end;
  suppose A4: d <> 0;
A5: n > 0 by A2,NAT_1:19;
  defpred P[Nat] means d |^ $1 divides n;
A6:for k being Nat st P[k] holds k <= n1
  proof let k be Nat; assume P[k];
    then A7: d |^ k <= n by A5,NAT_1:54;
     1 < d by A1,A4,CQC_THE1:2; then k <= d |^ k by Th2;
    hence k <= n1 by A7,AXIOMS:22;
  end;
A8:ex k being Nat st P[k]
   proof take 0;   d |^ 0 = 1 by NEWTON:9;
     hence d |^ 0 divides n by NAT_1:53;
   end;
  consider k being Nat such that
A9: P[k] & for n being Nat st P[n] holds n <= k from NAT_1:sch 6(A6,A8);
  take k;  k+0 < k+1 by REAL_1:53;
  hence thesis by A9;
    end;
end;
uniqueness proof
  let a, b be Nat such that
A10:  d |^ a divides n and
A11:  not d |^ (a+1) divides n and
A12:  d |^ b divides n and
A13:  not d |^ (b+1) divides n and
A14:  a <> b;
   reconsider d1 = d as Nat by ORDINAL2:def 21;
   per cases by A14,REAL_1:def 5;
   suppose A15:   a < b;
   then consider x being Nat such that
A16:  a + x = b by NAT_1:28;
    now assume 0+1 > x; then x <= 0 by NAT_1:38; then x = 0 by NAT_1:18;
     hence contradiction by A15,A16;
   end;
   then a+1 <= a+x by AXIOMS:24;
   then d1 |^ (a+1) divides d1 |^ (a+x) by RADIX_1:7;
   hence contradiction by A11,A12,A16,NAT_1:51;
    end;
   suppose
A17:  b < a;
   then consider x being Nat such that
A18:  b + x = a by NAT_1:28;
    now
     assume 0+1 > x;
     then x <= 0 by NAT_1:38;
     then x = 0 by NAT_1:18;
     hence contradiction by A17,A18;
   end;
   then b+1 <= b+x by AXIOMS:24;
   then d1 |^ (b+1) divides d1 |^ (b+x) by RADIX_1:7;
   hence contradiction by A10,A13,A18,NAT_1:51;
    end;
end;
end;

theorem Th21:
n <> 1 implies n |-count 1 = 0
proof
  assume
A1: 1 <> n;
A2:n |^ 0 divides 1 by NEWTON:9;
   now
    assume
A3:   n |^ (0+1) divides 1;
    then n |^ 1 <= 1 by NAT_1:54;
    then n <= 1 by NEWTON:10;
    then n = 0 by A1,CQC_THE1:2;
    then 0 divides 1 by A3,NEWTON:10;
    hence contradiction by INT_2:3;
  end;
  hence thesis by A1,A2,Def7;
end;

theorem
 1 < n implies n |-count n = 1
proof
  assume
A1: 1 < n;
  then A2: n > 0;
A3:n |^ 1 divides n by NEWTON:10;
   now
    assume n |^ (1+1) divides n;
    then n |^ 2 <= n by A2,NAT_1:54;
    hence contradiction by A1,PREPOWER:21;
  end;
  hence thesis by A1,A3,Def7;
end;

theorem Th23:
b <> 0 & b < a & a <> 1 implies a |-count b = 0
proof
  assume that
A1:  b <> 0 and
A2:  b < a and
A3:  a <> 1;
   a |^ 0 = 1 by NEWTON:9;
  then A4:a |^ 0 divides b by NAT_1:53;
A5:a |^ 1 = a by NEWTON:10;
   b > 0 by A1,NAT_1:19;
  then not a |^ (0+1) divides b by A2,A5,NAT_1:54;
  hence a |-count b = 0 by A1,A3,A4,Def7;
end;

theorem
 a <> 1 & a <> p implies a |-count p = 0
proof
  assume that
A1: a <> 1 and
A2: a <> p;
   a |^ 0 = 1 by NEWTON:9;
  then A3:a |^ 0 divides p by NAT_1:53;
A4:a |^ (0+1) is Nat by ORDINAL2:def 21;
   a |^ 1 = a by NEWTON:10;
  then not a |^ (0+1) divides p by A1,A2,A4,INT_2:def 5;
  hence a |-count p = 0 by A1,A3,Def7;
end;

theorem Th25:
1 < b implies b |-count (b|^a) = a
proof
  assume
A1: b > 1;
  then b > 0;
  then reconsider b as non empty Nat by ORDINAL2:def 21;
A2: b|^a > 0 by NAT_1:19;
  reconsider a as Nat by ORDINAL2:def 21;
   now
    assume b|^(a+1) divides b|^a;
    then A3: b|^(a+1) <= b|^a by A2,NAT_1:54;
A4: b|^(a+1) > 0 by NAT_1:19;
     a <= a+1 by NAT_1:29;
    then b|^a divides b|^(a+1) by RADIX_1:7;
    then b|^a <= b|^(a+1) by A4,NAT_1:54;
    then b|^a = b|^(a+1) by A3,AXIOMS:21;
    then a+0 = a+1 by A1,PEPIN:31;
    hence contradiction by XCMPLX_1:2;
  end;
  hence thesis by A1,Def7;
end;

theorem Th26:
b <> 1 & a <> 0 & b divides b |^ (b |-count a) implies b divides a
proof
  assume that
A1: b <> 1 and
A2: a <> 0 and
A3: b divides b |^ (b |-count a);
   b |^ (b |-count a) divides a by A1,A2,Def7;
  hence b divides a by A3,NAT_1:51;
end;

theorem Th27:
b <> 1 implies (a <> 0 & b |-count a = 0 iff not b divides a)
proof
  assume
A1: b <> 1;
  thus a <> 0 & b |-count a = 0 implies not b divides a
  proof
    assume that
A2:   a <> 0 and
A3:   b |-count a = 0 and
A4:   b divides a;
     not b |^ (0+1) divides a by A1,A2,A3,Def7;
    hence contradiction by A4,NEWTON:10;
  end;
  assume
A5: not b divides a;
  then A6:not b |^ (0+1) divides a by NEWTON:10;
A7: a <> 0 by A5,NAT_1:53;
   1 divides a by NAT_1:53;
  then b |^ 0 divides a by NEWTON:9;
  hence thesis by A1,A6,A7,Def7;
end;

theorem Th28:
for a, b being non empty natural number
  holds p |-count (a*b) = (p |-count a) + (p |-count b)
proof let a,b be non empty natural number;
  set x = p |-count a;  set y = p |-count b;  set z = p |-count (a*b);
A1: p <> 1 by INT_2:def 5;
A2: p |^ (x+y) = p |^ x * p |^ y by NEWTON:13;
A3: p |^ x divides a by A1,Def7;
A4: p |^ y divides b by A1,Def7;
then A5: p |^ (x+y) divides a*b by A2,A3,Th1;
   now assume
A6:  p |^ (x+y+1) divides a*b;
A7:  p |^ (x+y+1) = p |^ (x+y) * p by NEWTON:11;
A8: not p |^ (y+1) divides b by A1,Def7;
A9: not p |^ (x+1) divides a by A1,Def7;
    consider t being Nat such that
A10: a = (p |^ x) * t by A3,NAT_1:def 3;
    consider u being Nat such that
A11: b = (p |^ y) * u by A4,NAT_1:def 3;
    consider v being Nat such that
A12: a*b = p |^ (x+y+1) * v by A6,NAT_1:def 3;
A13: a*b = (p |^ x) * (p |^ y) * t * u by A10,A11
       .= p |^ (x+y) * t * u by NEWTON:13
       .= p |^ (x+y) * (t * u);
      a*b = p |^ (x+y) * (p * v) by A7,A12;
     then p*v = t*u by A13,XCMPLX_1:5;
then A14:  p divides t*u by NAT_1:def 3;
     per cases by A14,NEWTON:98;
     suppose p divides t; then consider t1 being Nat such that
     A15: t = p * t1 by NAT_1:def 3;
      a = (p |^ x) * p * t1 by A10,A15
      .= p |^ (x+1) * t1 by NEWTON:11;
      hence contradiction by A9,NAT_1:def 3;
    end;
     suppose p divides u; then consider t1 being Nat such that
     A16: u = p * t1 by NAT_1:def 3;
      b = (p |^ y) * p * t1 by A11,A16
      .= p |^ (y+1) * t1 by NEWTON:11;
      hence contradiction by A8,NAT_1:def 3;
    end;
  end;
  hence z = x + y by A1,A5,Def7;
end;

theorem Th29:
for a, b being non empty natural number
  holds p |^ (p |-count (a*b)) = (p |^ (p |-count a)) * (p |^ (p |-count b))
proof let a,b be non empty natural number;
  set x = p |-count a;  set y = p |-count b;
  thus p |^ (p |-count (a*b)) = p |^ (x + y) by Th28
   .= (p |^ x) * (p |^ y) by NEWTON:13;
end;

theorem Th30:
for a, b being non empty natural number
 st b divides a holds p |-count b <= p |-count a
proof let a,b be non empty natural number;
  set x = p |-count a;  set y = p |-count b;  set z = p |-count (a div b);
  assume b divides a;
then A1:a = b * (a div b) by NAT_1:49;
A2: p > 1 by INT_2:def 5;
A3: a div b <> 0 by A1;
A4: 0 < p |^ y by NAT_1:19;
   0 < p |^ z by NAT_1:19;
  then 0+1 <= p |^ z by NAT_1:38;
  then 1 * p |^ y <= p |^ z * p |^ y by A4,REAL_2:197;
  then p |^ y <= p |^ x by A1,A3,Th29;
  hence thesis by A2,JORDAN1A:7;
end;

theorem Th31:
for a, b being non empty natural number
 st b divides a holds p |-count (a div b) = (p |-count a) -' (p |-count b)
proof let a,b be non empty natural number;
  set x = p |-count a;  set y = p |-count b;  set z = p |-count (a div b);
  assume
A1: b divides a;
then a = b * (a div b) by NAT_1:49;
  then a div b <> 0;
  then p |-count (b*(a div b)) = y + z by Th28;
  then A2: z + y = x + 0 by A1,NAT_1:49;
   y <= x by A1,Th30;
  then y-y <= x-y by REAL_1:92;
  then x-y = x-'y by BINARITH:def 3;
  then z - 0 = x -' y by A2,XCMPLX_1:33;
  hence thesis;
end;

theorem Th32:
for a being non empty natural number
 holds p |-count (a|^b) = b * (p |-count a)
proof
  let a be non empty natural number;
A1: p <> 1 by INT_2:def 5;
  defpred P[natural number] means p |-count (a|^$1) = $1 * (p |-count a);
A2: P[0]
  proof
    thus p |-count (a|^0) = p |-count 1 by NEWTON:9
      .= 0 * (p |-count a) by A1,Th21;
  end;
A3: for x being natural number st P[x] holds P[x+1]
  proof let x be natural number such that
A4:   P[x];
    thus p |-count (a|^(x+1)) = p |-count (a|^x*a) by NEWTON:11
      .= x * (p |-count a) + 1 * (p |-count a) by A4,Th28
      .= (x+1) * (p |-count a);
  end;
   for x being natural number holds P[x] from NAT_1:sch 2(A2,A3);
  hence thesis;
end;

begin :: Exponents in prime-power factorization

definition
  let n be natural number;
  func prime_exponents n -> ManySortedSet of SetPrimes means :Def8:
  for p being Prime holds it.p = p |-count n;
existence proof deffunc F(natural number) = $1 |-count n;
defpred P[set,set] means ex w being natural number st w = $1 & $2 = F(w);
A1: for i being set st i in SetPrimes ex j being set st P[i,j]
  proof
    let i be set;
    assume i in SetPrimes;
    then reconsider i as Prime by NEWTON:def 6;
    take F(i), i;
    thus thesis;
  end;
  consider f being ManySortedSet of SetPrimes such that
A2: for i being set st i in SetPrimes holds P[i,f.i] from PBOOLE:sch 3(A1);
  take f; let i be Prime;  i in SetPrimes by NEWTON:def 6;
  then P[i,f.i] by A2;
  hence thesis;
end;
uniqueness proof let f, g be ManySortedSet of SetPrimes such that
A3:  for i being Prime holds f.i = i |-count n and
A4:  for i being Prime holds g.i = i |-count n;
   now let i be set; assume i in SetPrimes;
    then reconsider a = i as Prime by NEWTON:def 6;
    thus f.i = a |-count n by A3 .= g.i by A4;
  end;
  hence thesis by PBOOLE:3;
end;
end;

notation
  let n be natural number;
  synonym pfexp n for prime_exponents n; :: for prime factors exponents
end;

theorem Th33:
for x being set st x in dom pfexp n holds x is Prime
proof let x be set; assume x in dom pfexp n;
  then x in SetPrimes by PBOOLE:def 3;
 hence x is Prime by NEWTON:def 6;
end;

theorem Th34:
for x being set st x in support pfexp n holds x is Prime
proof let x be set;  set f = pfexp n; assume
A1: x in support f;
   support f c= dom f by POLYNOM1:41;
  hence x is Prime by A1,Th33;
end;

theorem Th35:
a > n & n <> 0 implies (pfexp n).a = 0
proof set f = pfexp n; assume that
A1: a > n and
A2: n <> 0;
  reconsider a as Nat by ORDINAL2:def 21;
  per cases;
  suppose a is not prime; then not a in dom pfexp n by Th33;
   hence thesis by FUNCT_1:def 4;
  end;
  suppose A3: a is prime; then a <> 1 by INT_2:def 5;
    then a |-count n = 0 by A1,A2,Th23;
   hence thesis by A3,Def8;
  end;
end;

registration
  let n be natural number;
  cluster pfexp n -> natural-yielding;
coherence proof set f = pfexp n; let y be set; assume y in rng f;
  then consider x being set such that
A1: x in dom f and
A2: f.x = y by FUNCT_1:def 5;
  reconsider x as Prime by A1,Th33;
   y = x |-count n by A2,Def8;
  hence y in NAT;
end;
end;

theorem
 a in support pfexp b implies a divides b
proof set f = pfexp b;  assume
A1: a in support f; then reconsider a as Prime by Th34;
A2:f.a <> 0 by A1,POLYNOM1:def 7;
A3: a <> 1 by INT_2:def 5;
   f.a = a |-count b by Def8;
  hence thesis by A2,A3,Th27;
end;

theorem Th37:
b is non empty & a is Prime & a divides b implies a in support pfexp b
proof assume that
A1: b is non empty and
A2: a is Prime and
A3: a divides b;
   1 < a by A2,INT_2:def 5;
  then A4: a |-count b <> 0 by A1,A3,Th27;
   (pfexp b).a = a |-count b by A2,Def8;
  hence thesis by A4,POLYNOM1:def 7;
end;

registration
  let n be non empty natural number;
  cluster pfexp n -> finite-support;
coherence proof set f = pfexp n;
  deffunc F(set) = $1;
  defpred P[Nat] means $1 is prime;
  reconsider n as Nat by ORDINAL2:def 21;
  set A = {F(i) where i is Nat: 0 <= i & i <= n & P[i]};
A1: A is finite from GRAPH_2:sch 1;
   support f c= A proof let x be set; assume
A2:   x in support f;
    then reconsider x as Prime by Th34;
A3: f.x <> 0 by A2,POLYNOM1:def 7;
A4: 0 <= x by NAT_1:18;
     x <= n by A3,Th35;
    hence thesis by A4;
  end;
  hence support f is finite by A1,FINSET_1:13;
end;
end;

theorem Th38:
for a being non empty natural number st p divides a holds (pfexp a).p <> 0
proof let a be non empty natural number; assume p divides a;
then A1: p |^ (0+1) divides a by NEWTON:10;
A2: (pfexp a).p = p |-count a by Def8;
     p <> 1 by INT_2:def 5;
  hence thesis by A1,A2,Def7;
end;

theorem Th39:
pfexp 1 = EmptyBag SetPrimes
proof set f = pfexp 1; set g = SetPrimes --> 0;
   for z being set st z in dom f holds f.z = 0
  proof let z be set; assume z in dom f;
      then reconsider z as Prime by Th33;
  A1: z <> 1 by INT_2:def 5;
       f.z = z |-count 1 by Def8 .= 0 by A1,Th21;
    hence thesis;
  end;
then A2: f = (dom f) --> 0 by FUNCOP_1:17;
    dom f = SetPrimes by PBOOLE:def 3;
  hence thesis by A2,POLYNOM1:def 15;
end;

registration
  cluster support pfexp 1 -> empty;
coherence
proof set f = pfexp 1; assume support f is non empty;
  then consider x being set such that
A1:  x in support f by XBOOLE_0:def 1;
   f.x <> 0 by A1,POLYNOM1:def 7;
  hence contradiction by Th39,POLYNOM1:56;
end;
end;

theorem Th40:
(pfexp (p|^a)).p = a
proof set f = pfexp (p|^a);
A1: p > 1 by INT_2:def 5;
   f.p = p |-count (p|^a) by Def8;
  hence f.p = a by A1,Th25;
end;

theorem
 (pfexp p).p = 1
proof p = p |^ 1 by NEWTON:10; hence thesis by Th40; end;

theorem Th42:
a <> 0 implies support pfexp (p|^a) = {p}
proof set f = pfexp (p|^a);  assume
A1: a <> 0;
  thus support f c= {p}
  proof let x be set; assume
A2:   x in support f;
    then reconsider x as Prime by Th34;
A3: f.x <> 0 by A2,POLYNOM1:def 7;
A4: x <> 1 by INT_2:def 5;
      f.x = x |-count (p|^a) by Def8; then x divides p|^a by A3,A4,Th27;
     then x = p by Th6;
    hence thesis by TARSKI:def 1;
  end;
  let x be set;  assume x in {p};
then A5: x = p by TARSKI:def 1;
    p divides p|^a by A1,Th3; then f.p <> 0 by Th38;
  hence thesis by A5,POLYNOM1:def 7;
end;

theorem Th43:
support pfexp p = {p}
proof  p = p |^ 1 by NEWTON:10;  hence thesis by Th42; end;

registration
  let p be Prime;
  let a be non empty natural number;
  cluster support pfexp (p|^a) -> non empty trivial;
coherence proof support pfexp (p|^a) = {p} by Th42;  hence thesis; end;
end;

registration
  let p be Prime;
  cluster support pfexp p -> non empty trivial;
coherence proof  support pfexp p = {p} by Th43;  hence thesis; end;
end;

theorem Th44:
for a, b being non empty Nat
 st a,b are_relative_prime holds support pfexp a misses support pfexp b
proof let a, b be non empty Nat; assume a,b are_relative_prime;
  then A1: a hcf b = 1 by INT_2:def 6;
  set f = pfexp a;  set g = pfexp b;
  assume support f meets support g; then consider x being set such that
A2: x in support f and
A3: x in support g by XBOOLE_0:3;
  reconsider x as Prime by A2,Th34;
A4: f.x <> 0 by A2,POLYNOM1:def 7;
A5: f.x = x |-count a by Def8;
A6: x <> 1 by INT_2:def 5;
then A7: x |^ (x |-count a) divides a by Def7;
   x divides x |^ (x |-count a) by A4,A5,Th3;
then A8: x divides a by A7,NAT_1:51;
A9: g.x <> 0 by A3,POLYNOM1:def 7;
A10: g.x = x |-count b by Def8;
A11: x |^ (x |-count b) divides b by A6,Def7;
   x divides x |^ (x |-count b) by A9,A10,Th3;
  then x divides b by A11,NAT_1:51; then x divides 1 by A1,A8,NAT_1:def 5;
  hence contradiction by A6,WSIERP_1:20;
end;

theorem Th45:
for a,b being non empty natural number
  holds support pfexp a c= support pfexp (a*b)
proof let a, b be non empty natural number;
  set f = pfexp a;  set h = pfexp (a*b);
  let x be set; assume
A1: x in support f; then reconsider x as Prime by Th34;
A2:f.x <> 0 by A1,POLYNOM1:def 7;
A3: x <> 1 by INT_2:def 5;
then A4: x |^ (x |-count a) divides a by Def7;
   f.x = x |-count a by Def8; then x divides x |^ (x |-count a) by A2,Th3;
  then x divides a by A4,NAT_1:51; then x |^ 1 divides a by NEWTON:10;
then A5: x |^ (0+1) divides a*b by NAT_1:56;
   h.x = x |-count (a*b) by Def8; then h.x <> 0 by A3,A5,Def7;
  hence thesis by POLYNOM1:def 7;
end;

theorem Th46:
for a, b being non empty Nat
 holds support pfexp (a*b) = support pfexp a \/ support pfexp b
proof let a, b be non empty Nat;
  set f = pfexp a;  set g = pfexp b;  set h = pfexp (a*b);
  thus support h c= support f \/ support g
  proof let x be set; assume
A1:   x in support h;
    then reconsider x as Prime by Th34;
A2: h.x <> 0 by A1,POLYNOM1:def 7;
A3: x <> 1 by INT_2:def 5;
     h.x = x |-count (a*b) by Def8;
    then A4: x divides x |^ (x |-count (a*b)) by A2,Th3;
A5: x |^ (x |-count(a*b)) = (x |^ (x |-count a)) * (x |^ (x |-count b)) by Th29
;
    per cases by A4,A5,NEWTON:98;
    suppose x divides x |^ (x |-count a);
    then x divides a by A3,Th26;
    then f.x <> 0 by Th38;
    then x in support f by POLYNOM1:def 7;
    hence thesis by XBOOLE_0:def 2;
    end;
    suppose x divides x |^ (x |-count b);
    then x divides b by A3,Th26;
    then g.x <> 0 by Th38;
    then x in support g by POLYNOM1:def 7;
    hence thesis by XBOOLE_0:def 2;
    end;
  end;
   support f c= support h & support g c= support h by Th45;
  hence thesis by XBOOLE_1:8;
end;

theorem
 for a, b being non empty Nat st a,b are_relative_prime
 holds card support pfexp (a*b) =  card support pfexp a + card support pfexp b
proof let a, b be non empty Nat;  assume
   a,b are_relative_prime;
then A1:support pfexp a misses support pfexp b by Th44;
   support pfexp (a*b) = support pfexp a \/ support pfexp b by Th46;
  hence thesis by A1,CARD_2:53;
end;

theorem
 for a, b being non empty natural number
 holds support pfexp a = support pfexp (a|^b)
proof let a, b be non empty natural number;
  set f = pfexp a;  set g = pfexp (a|^b);
 a is Nat & b is Nat by ORDINAL2:def 21;
  then a|^b = a|^(b-'1) * a by PEPIN:27;
  hence support f c= support g by Th45;
  let x be set;  assume
A1: x in support g;
  then reconsider x as Prime by Th34;
A2: g.x <> 0 by A1,POLYNOM1:def 7;
A3: g.x = x |-count (a|^b) by Def8;
   x <> 1 by INT_2:def 5;
then A4: x divides a|^b by A2,A3,Th27;
   now
    assume f.x = 0; then not x divides a by Th38;
    hence contradiction by A4,Th5;
  end;
  hence thesis by POLYNOM1:def 7;
end;

  reserve n, m for non empty natural number;

theorem
 pfexp (n*m) = pfexp n + pfexp m
proof
 for i being set st i in SetPrimes holds (pfexp (n*m)).i = (pfexp n + pfexp m).
i
  proof
    let i be set;
    assume i in SetPrimes;
    then reconsider a = i as Prime by NEWTON:def 6;
    thus (pfexp (n*m)).i = a |-count (n*m) by Def8
      .= (a |-count n) + (a |-count m) by Th28
      .= (pfexp n).i + (a |-count m) by Def8
      .= (pfexp n).i + (pfexp m).i by Def8
      .= (pfexp n + pfexp m).i by POLYNOM1:def 5;
  end;
  hence thesis by PBOOLE:3;
end;

theorem
 m divides n implies pfexp (n div m) = pfexp n -' pfexp m
proof
  assume
A1: m divides n;
   for i being set st i in SetPrimes holds
    (pfexp (n div m)).i = (pfexp n -' pfexp m).i
  proof
    let i be set;
    assume i in SetPrimes;
    then reconsider a = i as Prime by NEWTON:def 6;
    thus (pfexp (n div m)).i = a |-count (n div m) by Def8
      .= (a |-count n) -' (a |-count m) by A1,Th31
      .= (pfexp n).i -' (a |-count m) by Def8
      .= (pfexp n).i -' (pfexp m).i by Def8
      .= (pfexp n -' pfexp m).i by POLYNOM1:def 6;
  end;
  hence thesis by PBOOLE:3;
end;

theorem
 pfexp (n|^a) = a * pfexp n
proof
   for i being set st i in SetPrimes holds (pfexp (n|^a)).i = (a * pfexp n).i
  proof
    let i be set;
    assume i in SetPrimes;
    then reconsider x = i as Prime by NEWTON:def 6;
    thus (pfexp (n|^a)).i = x |-count (n|^a) by Def8
       .= a * (x |-count n) by Th32
       .= a * (pfexp n).i by Def8
       .= (a * pfexp n).i by Def2;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th52:
support pfexp n = {} implies n = 1
proof assume that
A1: support pfexp n = {} and
A2: n <> 1;
    n > 0 by NAT_1:19;
   then n >= 0+1 by NAT_1:38; then n > 1 by A2,REAL_1:def 5;
   then n >= 1+1 & n is Nat by NAT_1:38,ORDINAL2:def 21;
   then consider p being Nat such that
A3: p is prime and
A4: p divides n by INT_2:48;
 p > 1 by A3,INT_2:def 5;
   then p |-count n <> 0 by A4,Th27;
   then (pfexp n).p <> 0 by A3,Def8;
 hence contradiction by A1,POLYNOM1:def 7;
end;

theorem
 for m, n being non empty Nat holds pfexp (n hcf m) = min(pfexp n, pfexp m)
proof let m, n be non empty Nat;
   now let i be set; assume i in SetPrimes;
    then reconsider j = i as Prime by NEWTON:def 6;
    set lhs = pfexp (n hcf m); set rhs = min(pfexp n, pfexp m);
    set x = j |-count n, y = j |-count m, z = j |-count (n hcf m);
    A1: j <> 1 by INT_2:def 5;
    A2: n hcf m <> 0 by INT_2:5;
    A3: lhs.j = z by Def8;
    A4: j |^ z divides (n hcf m) by A1,A2,Def7;
    A5: not j |^ (z+1) divides (n hcf m) by A1,A2,Def7;
    A6: (pfexp n).j = x by Def8;
    A7: j |^ x divides n by A1,Def7;
    A8: not j |^ (x+1) divides n by A1,Def7;
    A9: (pfexp m).j = y by Def8;
    A10: j |^ y divides m by A1,Def7;
    A11: not j |^ (y+1) divides m by A1,Def7;
    A12: n hcf m divides m by NAT_1:def 5;
    A13: n hcf m divides n by NAT_1:def 5;
    A14: j |^ z divides m by A4,A12,NAT_1:51;
    A15: j |^ z divides n by A4,A13,NAT_1:51;
     thus lhs.i = rhs.i proof
      per cases;
      suppose A16: (pfexp n).j <= (pfexp m).j;
      then A17: rhs.j = x by A6,Def3;
      A18: z <= x by A8,A15,Th4;
           now assume A19: z < x;
          then A20: j |^ (z+1) divides n by A7,Th4;
               z < y by A6,A9,A16,A19,AXIOMS:22;
              then j |^ (z+1) divides m by A10,Th4;
           hence contradiction by A5,A20,NAT_1:def 5;
          end;
       hence thesis by A3,A17,A18,AXIOMS:21;
       end;
      suppose A21: (pfexp n).j > (pfexp m).j;
      then A22: rhs.j = y by A9,Def3;
      A23: z <= y by A11,A14,Th4;
           now assume A24: z < y;
          then A25: j |^ (z+1) divides m by A10,Th4;
               z < x by A6,A9,A21,A24,AXIOMS:22;
              then j |^ (z+1) divides n by A7,Th4;
           hence contradiction by A5,A25,NAT_1:def 5;
          end;
       hence thesis by A3,A22,A23,AXIOMS:21;
       end;
     end;
  end;
  hence pfexp (n hcf m) = min(pfexp n, pfexp m) by PBOOLE:3;
end;

theorem
 for m, n being non empty Nat holds pfexp (n lcm m) = max(pfexp n, pfexp m)
proof let m, n be non empty Nat;
   now let i be set; assume i in SetPrimes;
    then reconsider j = i as Prime by NEWTON:def 6;
    set lhs = pfexp (n lcm m); set rhs = max(pfexp n, pfexp m);
    set x = j |-count n, y = j |-count m, z = j |-count (n lcm m);
    A1: j > 1 by INT_2:def 5;
    A2: n lcm m <> 0 by INT_2:4;
    A3: lhs.j = z by Def8;
    A4: j |^ z divides (n lcm m) by A1,A2,Def7;
    A5: not j |^ (z+1) divides (n lcm m) by A1,A2,Def7;
    A6: (pfexp n).j = x by Def8;
    A7: j |^ x divides n by A1,Def7;
    A8: not j |^ (x+1) divides n by A1,Def7;
    A9: (pfexp m).j = y by Def8;
    A10: j |^ y divides m by A1,Def7;
    A11: not j |^ (y+1) divides m by A1,Def7;
    A12: m divides n lcm m by NAT_1:def 4;
    A13: n divides n lcm m by NAT_1:def 4;
    A14: j |^ y divides n lcm m by A10,A12,NAT_1:51;
    A15: j |^ x divides n lcm m by A7,A13,NAT_1:51;
     thus lhs.i = rhs.i proof
      per cases;
      suppose A16: (pfexp n).j <= (pfexp m).j;
      then A17: rhs.j = y by A9,Def4;
      A18: y <= z by A5,A14,Th4;
           now assume y < z;
          then j |^ (y+1) divides n lcm m by A4,Th4;
              then consider k being Nat such that
          A19: n lcm m = (j |^ (y+1))*k by NAT_1:def 3;
          A20: n lcm m = (j |^ y)*j*k by A19,NEWTON:11
                      .= (j |^ y)*(k*j);
                0 <> k by A19,INT_2:4;
          then A21: 0 < k by NAT_1:19;
          A22: 0 < j |^ y by NAT_1:19;
          then A23: 0*k < (j |^ y)*k by A21,REAL_1:70;
              consider t being Nat such that
          A24: n = (j |^ x) * t by A7,NAT_1:def 3;
              consider u being Nat such that
          A25: n lcm m = n*u by A13,NAT_1:def 3;
               consider p being Nat such that
          A26: y = x+p by A6,A9,A16,NAT_1:28;
           j |^ (x+p) = (j |^x)*(j |^ p) by NEWTON:13;
              then (j |^ x)*((j |^ p) *(k*j)) = (j |^ x)*(t*u)
                by A20,A24,A25,A26,XCMPLX_1:4;
              then (j |^p)*k*j = t*u by XCMPLX_1:5;
          then A27: j divides t*u by NAT_1:def 3;
               now assume j divides t; then consider w being Nat such that
              A28: t = j*w by NAT_1:def 3;
                   n = (j |^ x) * j * w by A24,A28
                   .= (j |^ (x+1)) * w by NEWTON:11;
                hence contradiction by A8,NAT_1:def 3;
              end;
              then j divides u by A27,NEWTON:98;
              then consider w being Nat such that
          A29: u = j*w by NAT_1:def 3;
               (j |^ y)*k*j = n*w*j by A20,A25,A29,XCMPLX_1:4;
              then (j |^ y)*k = n*w by XCMPLX_1:5;
          then A30: n divides (j |^ y)*k by NAT_1:def 3;
              consider t being Nat such that
          A31: m = (j |^ y) * t by A10,NAT_1:def 3;
              consider u being Nat such that
          A32: n lcm m = m*u by A12,NAT_1:def 3;
               (j |^ y)*(k*j) = (j |^ y)*(t*u) by A20,A31,A32;
              then k*j = t*u by XCMPLX_1:5;
          then A33: j divides t*u by NAT_1:def 3;
               now assume j divides t; then consider w being Nat such that
              A34: t = j*w by NAT_1:def 3;
                   m = (j |^ y) * j * w by A31,A34
                   .= (j |^ (y+1)) * w by NEWTON:11;
                hence contradiction by A11,NAT_1:def 3;
              end;
              then j divides u by A33,NEWTON:98;
              then consider w being Nat such that
          A35: u = j*w by NAT_1:def 3;
               (j |^ y)*k*j = m*w*j by A20,A32,A35,XCMPLX_1:4;
              then (j |^ y)*k = m*w by XCMPLX_1:5;
              then m divides (j |^ y)*k by NAT_1:def 3;
              then n lcm m divides (j |^ y)*k by A30,NAT_1:def 4;
              then (j |^ (y+1))*k <= (j |^ y)*k by A19,A23,NAT_1:54;
              then j |^ (y+1) <= j |^ y by A21,REAL_1:70;
              then (j |^ y) * j <= (j |^ y)*1 by NEWTON:11;
              then j <= 1 by A22,REAL_1:70;
           hence contradiction by INT_2:def 5;
          end;
       hence thesis by A3,A17,A18,AXIOMS:21;
       end;
      suppose A36: (pfexp n).j > (pfexp m).j;
      then A37: rhs.j = x by A6,Def4;
      A38: x <= z by A5,A15,Th4;
           now assume x < z;
          then j |^ (x+1) divides n lcm m by A4,Th4;
              then consider k being Nat such that
          A39: n lcm m = (j |^ (x+1))*k by NAT_1:def 3;
          A40: n lcm m = (j |^ x)*j*k by A39,NEWTON:11
                      .= (j |^ x)*(k*j);
                0 <> k by A39,INT_2:4;
          then A41: 0 < k by NAT_1:19;
          A42: 0 < (j |^ x) by NAT_1:19;
          then A43: 0*k < (j |^ x)*k by A41,REAL_1:70;
              consider t being Nat such that
          A44: m = (j |^ y) * t by A10,NAT_1:def 3;
              consider u being Nat such that
          A45: n lcm m = m*u by A12,NAT_1:def 3;
               consider p being Nat such that
          A46: x = y+p by A6,A9,A36,NAT_1:28;
           j |^ (y+p) = (j |^y)*(j |^ p) by NEWTON:13;
              then (j |^ y)*((j |^ p) *(k*j)) = (j |^ y)*(t*u)
                by A40,A44,A45,A46,XCMPLX_1:4;
              then (j |^p)*k*j = t*u by XCMPLX_1:5;
          then A47: j divides t*u by NAT_1:def 3;
               now assume j divides t; then consider w being Nat such that
              A48: t = j*w by NAT_1:def 3;
                   m = (j |^ y) * j * w by A44,A48
                   .= (j |^ (y+1)) * w by NEWTON:11;
                hence contradiction by A11,NAT_1:def 3;
              end; then j divides u by A47,NEWTON:98;
              then consider w being Nat such that
          A49: u = j*w by NAT_1:def 3;
               (j |^ x)*k*j = m*w*j by A40,A45,A49,XCMPLX_1:4;
              then (j |^ x)*k = m*w by XCMPLX_1:5;
          then A50: m divides (j |^ x)*k by NAT_1:def 3;
              consider t being Nat such that
          A51: n = (j |^ x) * t by A7,NAT_1:def 3;
              consider u being Nat such that
          A52: n lcm m = n*u by A13,NAT_1:def 3;
               (j |^ x)*(k*j) = (j |^ x)*(t*u) by A40,A51,A52;
              then k*j = t*u by XCMPLX_1:5;
          then A53: j divides t*u by NAT_1:def 3;
               now assume j divides t; then consider w being Nat such that
              A54: t = j*w by NAT_1:def 3;
                   n = (j |^ x) * j * w by A51,A54
                   .= (j |^ (x+1)) * w by NEWTON:11;
                hence contradiction by A8,NAT_1:def 3;
              end; then j divides u by A53,NEWTON:98;
              then consider w being Nat such that
          A55: u = j*w by NAT_1:def 3;
               (j |^ x)*k*j = n*w*j by A40,A52,A55,XCMPLX_1:4;
              then (j |^ x)*k = n*w by XCMPLX_1:5;
          then n divides (j |^ x)*k by NAT_1:def 3;
              then n lcm m divides (j |^ x)*k by A50,NAT_1:def 4;
              then (j |^ (x+1))*k <= (j |^ x)*k by A39,A43,NAT_1:54;
              then j |^ (x+1) <= j |^ x by A41,REAL_1:70;
              then (j |^ x) * j <= (j |^ x)*1 by NEWTON:11;
              then j <= 1 by A42,REAL_1:70;
           hence contradiction by INT_2:def 5;
          end;
       hence thesis by A3,A37,A38,AXIOMS:21;
     end;
     end;
  end;
  hence pfexp (n lcm m) = max(pfexp n, pfexp m) by PBOOLE:3;
end;

begin :: Prime-power factorization

definition
  let n be non empty natural number;
  func prime_factorization n -> ManySortedSet of SetPrimes means :Def9:
  support it = support pfexp n &
  for p being natural number st p in support pfexp n holds
    it.p = p |^ (p |-count n);
  existence proof
   defpred P[set,set] means
   for p being Prime st $1 = p holds
     (p in support pfexp n implies $2 = p |^ (p |-count n)) &
     (not p in support pfexp n implies $2 = 0);
A1: for x,y1,y2 being set st x in SetPrimes & P[x,y1] & P[x,y2] holds y1 = y2
   proof let x,y1,y2 be set such that
   A2: x in SetPrimes and
   A3: P[x,y1] and
   A4: P[x,y2];
       reconsider p = x as Prime by A2,NEWTON:def 6;
      (p in support pfexp n implies y1 = p |^ (p |-count n)) &
     (not p in support pfexp n implies y1 = 0) by A3;
    hence y1 = y2 by A4;
   end;
A5: for x being set st x in SetPrimes ex y being set st P[x,y] proof
     let x be set such that
   A6: x in SetPrimes;
       reconsider i = x as Prime by A6,NEWTON:def 6;
     per cases;
     suppose A7: i in support pfexp n;
       take i |^ (i |-count n);
       let p be Prime; assume p = x;
      hence thesis by A7;
     end;
     suppose A8: not i in support pfexp n;
      take 0;
      let p be Prime; assume p = x;
      hence thesis by A8;
     end;
   end;
   consider f being Function such that
A9: dom f = SetPrimes and
A10: for x being set st x in SetPrimes holds P[x,f.x] from FUNCT_1:sch 2(A1, A5
);
A11: support f c= SetPrimes by A9,POLYNOM1:41;
A12: now let x be set;
     hereby assume
     A13: x in support f;
      then x in SetPrimes by A11;
         then reconsider i = x as Prime by NEWTON:def 6;
      assume not x in support pfexp n;
       then f.i = 0 by A10,A11,A13;
      hence contradiction by A13,POLYNOM1:def 7;
     end;
     assume
    A14: x in support pfexp n;
        then x in SetPrimes;
        then reconsider i = x as Prime by NEWTON:def 6;
         f.i = i |^ (i |-count n) by A10,A14;
     hence x in support f by POLYNOM1:def 7;
    end;
   reconsider f as ManySortedSet of SetPrimes by A9,PBOOLE:def 3;
   take f;
   thus support f = support pfexp n by A12,TARSKI:2;
   let p be natural number;
   assume
A15:  p in support pfexp n; then p is Prime by Th34;
   hence f.p = p |^ (p |-count n) by A10,A15;
  end;
  uniqueness proof let it1, it2 be ManySortedSet of SetPrimes such that
A16: support it1 = support pfexp n and
A17: for p being natural number st p in support pfexp n holds
     it1.p = p|^(p|-count n) and
A18: support it2 = support pfexp n and
A19: for p being natural number st p in support pfexp n holds
     it2.p = p|^(p|-count n);
     now let i be set such that
    A20: i in SetPrimes;
      reconsider p = i as Prime by A20,NEWTON:def 6;
     per cases;
     suppose A21: p in support pfexp n;
      hence it1.i = p|^(p|-count n) by A17 .= it2.i by A19,A21;
     end;
     suppose A22: not p in support pfexp n;
      hence it1.i = 0 by A16,POLYNOM1:def 7
        .= it2.i by A18,A22,POLYNOM1:def 7;
      end;
    end;
   hence it1 = it2 by PBOOLE:3;
  end;
end;

notation
  let n be non empty natural number;
  synonym ppf n for prime_factorization n; :: for prime-power factorization
end;

registration
  let n be non empty natural number;
  cluster ppf n -> natural-yielding finite-support;
coherence
proof
  thus rng ppf n c= NAT
  proof
    let y be set;
    assume y in rng ppf n;
    then consider x being set such that
A1:   x in dom ppf n and
A2:   (ppf n).x = y by FUNCT_1:def 5;
     dom ppf n = SetPrimes by PBOOLE:def 3;
    then reconsider x as Prime by A1,NEWTON:def 6;
    per cases;
    suppose x in support pfexp n;
    then (ppf n).x = x |^ (x |-count n) by Def9;
    hence thesis by A2;
    end;
    suppose not x in support pfexp n;
    then not x in support ppf n by Def9;
    then (ppf n).x = 0 by POLYNOM1:def 7;
    hence thesis by A2;
    end;
  end;
   support ppf n = support pfexp n by Def9;
  hence support ppf n is finite;
end;
end;

theorem Th55:
p |-count n = 0 implies (ppf n).p = 0
proof assume p |-count n = 0; then (pfexp n).p = 0 by Def8;
  then not p in support pfexp n by POLYNOM1:def 7;
  then not p in support ppf n by Def9;
 hence (ppf n).p = 0 by POLYNOM1:def 7;
end;

theorem Th56:
p |-count n <> 0 implies (ppf n).p = p |^ (p |-count n)
proof assume p |-count n <> 0; then (pfexp n).p <> 0 by Def8;
  then p in support pfexp n by POLYNOM1:def 7;
 hence (ppf n).p = p |^ (p |-count n) by Def9;
end;

theorem
 support ppf n = {} implies n = 1
proof
 assume support ppf n = {};
 then support pfexp n = {} by Def9;
 hence n = 1 by Th52;
end;

theorem Th58:
for a, b being non empty Nat st a, b are_relative_prime
 holds ppf (a*b) = ppf a + ppf b
proof let a, b be non empty Nat such that
A1: a, b are_relative_prime;
   reconsider an = a, bn = b as non empty natural number;
   now let i be set such that
  A2: i in SetPrimes;
      reconsider p = i as Prime by A2,NEWTON:def 6;
  A3: p |-count (an*bn) = (p |-count a) + (p |-count b) by Th28;
  A4: p > 1 by INT_2:def 5;
  A5: a hcf b = 1 by A1,INT_2:def 6;
   per cases;
   suppose A6: p |-count (a*b) = 0;
   then A7: (p |-count a) = 0 & (p |-count b) = 0 by A3,NAT_1:23;
    thus (ppf (a*b)).i = 0 by A6,Th55
     .= 0 + (ppf b).i by A7,Th55
     .= (ppf a).i + (ppf b).i by A7,Th55
     .= (ppf a + ppf b).i by POLYNOM1:def 5;
   end;
   suppose A8: p |-count (a*b) <> 0;
    thus (ppf (a*b)).i = (ppf a + ppf b).i proof
    per cases by A3,A8;
    suppose A9: (p |-count a) <> 0;
    A10: now assume
         (p |-count b) <> 0;
            then consider kb being Nat such that
        A11: (p |-count b) = kb+1 by NAT_1:22;
             p |^ (p |-count b) divides b by A4,Def7;
            then p*(p|^kb) divides b by A11,NEWTON:11;
            then consider lb being Nat such that
        A12: b = p*(p|^kb)*lb by NAT_1:def 3;
             b = p*((p|^kb)*lb) by A12;
        then A13: p divides b by NAT_1:def 3;
            consider ka being Nat such that
        A14: (p |-count a) = ka+1 by A9,NAT_1:22;
             p |^ (p |-count a) divides a by A4,Def7;
            then p*(p|^ka) divides a by A14,NEWTON:11;
            then consider la being Nat such that
        A15: a = p*(p|^ka)*la by NAT_1:def 3;
              a = p*((p|^ka)*la) by A15;
             then p divides a by NAT_1:def 3;
             then p divides 1 by A5,A13,NAT_1:def 5;
         hence contradiction by A4,NAT_1:54;
        end;
     hence (ppf (a*b)).i = p |^ (p |-count a) by A3,A8,Th56
       .= (ppf a).p + 0 by A9,Th56
       .= (ppf a).p + (ppf b).p by A10,Th55
       .= (ppf a + ppf b).i by POLYNOM1:def 5;
    end;
    suppose A16: (p |-count b) <> 0;
    A17: now assume
        A18: (p |-count a) <> 0;
            consider kb being Nat such that
        A19: (p |-count b) = kb+1 by A16,NAT_1:22;
             p |^ (p |-count b) divides b by A4,Def7;
            then p*(p|^kb) divides b by A19,NEWTON:11;
            then consider lb being Nat such that
        A20: b = p*(p|^kb)*lb by NAT_1:def 3;
             b = p*((p|^kb)*lb) by A20;
        then A21: p divides b by NAT_1:def 3;
            consider ka being Nat such that
        A22: (p |-count a) = ka+1 by A18,NAT_1:22;
             p |^ (p |-count a) divides a by A4,Def7;
            then p*(p|^ka) divides a by A22,NEWTON:11;
            then consider la being Nat such that
        A23: a = p*(p|^ka)*la by NAT_1:def 3;
              a = p*((p|^ka)*la) by A23;
             then p divides a by NAT_1:def 3;
             then p divides 1 by A5,A21,NAT_1:def 5;
         hence contradiction by A4,NAT_1:54;
        end;
     hence (ppf (a*b)).i = p |^ (p |-count b) by A3,A8,Th56
       .= 0+(ppf b).p by A16,Th56
       .= (ppf a).p + (ppf b).p by A17,Th55
       .= (ppf a + ppf b).i by POLYNOM1:def 5;
    end;
    end;
   end;
  end;
 hence ppf (a*b) = ppf a + ppf b by PBOOLE:3;
end;

theorem Th59:
(ppf (p |^ n)).p = p |^ n
proof
   p > 1 by INT_2:def 5;
  then p |-count (p |^ n) = n by Th25;
 hence (ppf (p |^ n)).p = p |^ n by Th56;
end;

theorem
 ppf (n|^m) = (ppf n) |^ m
proof
  now let i be set; assume
   i in SetPrimes;
     then reconsider p = i as Prime by NEWTON:def 6;
      m > 0 by NAT_1:19;
 then A1: m >= 0+1 by NAT_1:38;
 A2: p |-count (n |^ m) = m * (p |-count n) by Th32;
 A3: ((ppf n) |^ m).i = (ppf n).i |^ m by Def6;
  per cases;
  suppose A4: p |-count n = 0;
    hence (ppf (n|^m)).i = 0 by A2,Th55
      .= 0 |^ m by A1,NEWTON:16
      .= ((ppf n) |^ m).i by A3,A4,Th55;
  end;
  suppose A5: p |-count n <> 0;
  then p |-count (n |^ m) <> 0 by A2,XCMPLX_1:6;
   hence (ppf (n|^m)).i = p |^ (p |-count (n |^ m)) by Th56
     .= (p |^ (p |-count n)) |^ m by A2,NEWTON:14
     .= ((ppf n) |^ m).i by A3,A5,Th56;
  end;
 end;
 hence thesis by PBOOLE:3;
end;

theorem
 Product ppf n = n
proof
  defpred P[natural number] means
  for n being non empty natural number
   st support ppf n c= Seg $1 holds Product ppf n = n;
A1: P[0] proof let n be non empty natural number;
       assume
   A2:   support ppf n c= Seg 0;
        {} c= support ppf n by XBOOLE_1:2;
   then A3: support ppf n = {} by A2,FINSEQ_1:4,XBOOLE_0:def 10;
   then A4: ppf n = EmptyBag SetPrimes by BAGORDER:20;
        now
         reconsider k = n as Nat by ORDINAL2:def 21;
         assume n <> 1; then k > 1 by UPROOTS:1; then k >=1+1 by NAT_1:38;
             then consider p being Nat such that
         A5: p is prime and
         A6: p divides k by INT_2:48;
            support pfexp n is non empty by A5,A6,Th37;
        hence contradiction by A3,Def9;
       end;
     hence Product ppf n = n by A4,Th20;
   end;
A7: for k being natural number st P[k] holds P[k+1] proof
    let k be natural number; assume
   A8: P[k];
    let n be non empty natural number such that
   A9: support ppf n c= Seg (k+1);
   A10: support ppf n = support pfexp n by Def9;
    per cases;
    suppose A11: not support ppf n c= Seg k;
    A12: now assume
        A13: not k+1 in support ppf n;
             support ppf n c= Seg k proof let x be set; assume
            A14: x in support ppf n;
            then A15: x is Prime by A10,Th34;
            reconsider m = x as natural number by A10,A14,Th34;
            A16: 1 <= m by A15,INT_2:def 5;
                 m <= k+1 by A9,A14,FINSEQ_1:3;
                then m < k+1 by A13,A14,REAL_1:def 5; then m <= k by NAT_1:38
;
             hence x in Seg k by A16,FINSEQ_1:3;
            end;
         hence contradiction by A11;
        end;
        set p = k+1; set e = p |-count n; set s = p |^ e;
     A17: p is Prime by A10,A12,Th34;
     then A18: (pfexp n).p = e by Def8;
     A19: p > 1 by A17,INT_2:def 5;
         then s divides n by Def7; then consider t being Nat such that
     A20: n = s * t by NAT_1:def 3;
         set t1 = t;
         reconsider s, t as non empty natural number by A20,XCMPLX_1:6;
     A21: support ppf t = support pfexp t by Def9;
     A22: support ppf t c= Seg k proof let x be set; assume
         A23: x in support ppf t;
         then A24: x in support pfexp t by Def9;
         then A25: x is Prime by Th34; reconsider m = x as natural number by
A24,Th34;
         A26: 1 <= m by A25,INT_2:def 5;
              support ppf t c= support ppf n by A10,A20,A21,Th45;
             then m in support ppf n by A23;
         then A27: m <= k+1 by A9,FINSEQ_1:3;
             set f = p |-count t;
              now assume
             A28: m = p;
              (pfexp t).p = f by A17,Def8;
                 then f <> 0 by A24,A28,POLYNOM1:def 7;
                 then f > 0 by NAT_1:19; then f >= 0+1 by NAT_1:38;
                 then consider g being Nat such that
             A29: f = 1+g by NAT_1:28;
                  p |^ f divides t by A19,Def7;
                 then consider u being Nat such that
             A30: t = (p |^ f)*u by NAT_1:def 3;
             A31: n = s * (((p |^ g)*p)*u) by A20,A29,A30,NEWTON:11
                  .= s*p *((p |^ g)*u)
                  .= (p |^ (e+1))*((p |^ g)*u) by NEWTON:11;
                   (p |^ g)*u is Nat by ORDINAL2:def 21;
                 then p |^ (e+1) divides n by A31,NAT_1:def 3;
                 hence contradiction by A19,Def7;
                end; then m < p by A27,REAL_1:def 5; then m <= k by NAT_1:38;
             hence x in Seg k by A26,FINSEQ_1:3;
         end;
     A32: e <> 0 by A10,A12,A18,POLYNOM1:def 7;
           support ppf s = support pfexp s by Def9;
     then A33: support ppf s = {p} by A17,A32,Th42;
          now assume (support ppf s) /\ (support ppf t) <> {};
             then consider x being set such that
         A34: x in (support ppf s) /\ support ppf t by XBOOLE_0:def 1;
         A35: x in  support ppf s by A34,XBOOLE_0:def 3;
         A36: x in support ppf t by A34,XBOOLE_0:def 3;
              x = p by A33,A35,TARSKI:def 1;
             then p <= k by A22,A36,FINSEQ_1:3;
          hence contradiction by NAT_1:38;
         end;
     then A37: support ppf s misses support ppf t by XBOOLE_0:def 7;
         reconsider s1 = s, t1 = t as non empty Nat by ORDINAL2:def 21;
          s1,t1 are_relative_prime proof assume
         A38: s1 hcf t1 <> 1;
             set u = s1 hcf t1;
         A39: u divides s1 by NAT_1:def 5;
              u <> 0 by INT_2:5; then 0 < u by NAT_1:19;
             then 0+1 <= u by NAT_1:38; then u > 1 by A38,REAL_1:def 5;
             then u >= 1+1 by NAT_1:38;
             then consider r being Nat such that
         A40: r is prime and
         A41: r divides u by INT_2:48;
              r divides s1 by A39,A41,NAT_1:51;
             then r divides p by A40,Th5;
         then A42: r = 1 or r = p by A17,INT_2:def 5;
              u divides t1 by NAT_1:def 5;
             then p divides t1 by A40,A41,A42,INT_2:def 5,NAT_1:51;
             then p in support pfexp t by A17,Th37;
             then k+1 <= k by A21,A22,FINSEQ_1:3;
          hence contradiction by NAT_1:38;
         end;
     then A43: ppf n = ppf s + ppf t by A20,Th58;
         consider f being FinSequence of NAT such that
     A44: Product ppf s = Product f and
     A45: f = (ppf s)*canFS(support ppf s) by Def5;
     A46: dom ppf s = SetPrimes by PBOOLE:def 3;
           f = (ppf s)*<*p*> by A33,A45,UPROOTS:6
           .= <* (ppf s).p *> by A12,A46,CIRCCMB3:36;
     then A47: Product ppf s = (ppf s).p by A44,RVSUM_1:125
         .= s by A17,A32,Th59;
          Product ppf t = t by A8,A22;
     hence Product ppf n = n by A20,A37,A43,A47,Th19;
    end;
    suppose support ppf n c= Seg k;
     hence Product ppf n = n by A8;
    end;
   end;
A48: for k being natural number holds P[k] from NAT_1:sch 2(A1,A7);
A49: support ppf n = support pfexp n by Def9;
   per cases;
   suppose support ppf n is empty;
    hence thesis by A1,FINSEQ_1:4;
   end;
   suppose support ppf n is non empty;
     then reconsider S = support ppf n as finite non empty Subset of NAT
      by XBOOLE_1:1;
       support ppf n c= Seg max S proof let x be set; assume
      A50: x in support ppf n;
      then A51: x is Prime by A49,Th34;
          reconsider m = x as natural number by A49,A50,Th34;
      A52: 1 <= m by A51,INT_2:def 5;
           m <= max S by A50,PRE_CIRC:def 1;
        hence x in Seg max S by A52,FINSEQ_1:3;
      end;
    hence thesis by A48;
   end;
end;
