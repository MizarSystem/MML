:: The { \bf while } macro instructions of SCM+FSA, Part { II }
::  by Piotr Rudnicki
::
:: Received June 3, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, INT_1, AMI_1, SCMFSA_2, SF_MASTR, FUNCOP_1,
      FUNCT_1, FINSUB_1, CARD_3, RELAT_1, TARSKI, AMISTD_2, XBOOLE_0, CARD_1,
      SCMFSA8A, AMI_3, FSM_1, SCMFSA7B, SCMFSA8B, ARYTM_3, TURING_1, SCMFSA6A,
      ARYTM_1, VALUED_1, FUNCT_4, SCMFSA_9, UNIALG_2, SCMFSA6B, XXREAL_0,
      CIRCUIT2, GRAPHSP, NAT_1, SCMFSA6C, MSUALG_1, SFMASTR1, PRE_FF, COMPLEX1,
      ABIAN, SCMFSA9A, ORDINAL1, PARTFUN1, SCMNORM, RELOC;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, FINSUB_1,
      FUNCOP_1, INT_1, ABIAN, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, PRE_FF,
      CARD_3, FUNCT_4, VALUED_1, INT_2, XXREAL_0, NAT_1, COMPOS_1, EXTPRO_1,
      AMI_1,
      AMISTD_2, SCMFSA_2, SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C,
      SCMFSA_7, SCMFSA7B, SCMFSA8A, SCMFSA8B, SCMFSA_9, SFMASTR1;
 constructors NAT_D, PRE_FF, ABIAN, SCMFSA_7, SCMFSA6A, SCMFSA6B,
      SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA_9, SFMASTR1, AMISTD_2,
      RELSET_1, PRE_POLY, XXREAL_2, PBOOLE, SCMFSA7B, AMI_1;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FINSET_1,
      FINSUB_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, ABIAN,
      SCMFSA_2, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B,
      SCMFSA_9, SFMASTR1, VALUED_1, FUNCT_2, RELAT_1, AMI_1, AFINSQ_1,
      FUNCT_4, FUNCOP_1, SCMFSA10, AMISTD_2, SCMFSA6A, COMPOS_1, EXTPRO_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, SCMFSA6A, AFINSQ_1, COMPOS_1, EXTPRO_1, AMI_1, AMISTD_2;
 theorems TARSKI, ZFMISC_1, ABSVALUE, NAT_1, INT_1, NAT_2, FUNCT_1, FUNCT_2,
      GRFUNC_1, FUNCOP_1, FUNCT_4, PRE_FF, ABIAN, AMI_1, SCMFSA_2,
      SCMFSA_4, SCMFSA_5, SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SCMFSA8B, SCMFSA8C, SCMFSA_9, SFMASTR1, RELAT_1, XBOOLE_0,
      XBOOLE_1, CARD_3, XREAL_1, XXREAL_0, ORDINAL1, NAT_D, VALUED_1, PBOOLE,
      PARTFUN1, FINSEQ_4, AMISTD_2, COMPOS_1, EXTPRO_1;
 schemes FUNCT_2, NAT_1;

begin :: SCM+FSA preliminaries

reserve k, l, n for Element of NAT,
  j for Integer,
  i for Instruction of SCM+FSA;

canceled 6;

theorem Th7: :: singleUsed
  UsedIntLoc (l .--> i) = UsedIntLoc i
proof
  set p = (l .--> i);
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc p = Union (UIL * p) by SF_MASTR:def 2;
A3: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
  thus UsedIntLoc p = union rng (UIL * ({l} --> i)) by A2,CARD_3:def 4
    .= union rng ({l} --> UIL.i) by A3,FUNCOP_1:23
    .= union {UIL.i} by FUNCOP_1:14
    .= union {UsedIntLoc i} by A1
    .= UsedIntLoc i by ZFMISC_1:31;
end;

theorem Th8: :: singleUsedF:
  UsedInt*Loc (l .--> i) = UsedInt*Loc i
proof
  set p = (l .--> i);
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc p = Union (UIL * p) by SF_MASTR:def 4;
A3: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
  thus UsedInt*Loc p = union rng (UIL * ({l} --> i)) by A2,CARD_3:def 4
    .= union rng ({l} --> UIL.i) by A3,FUNCOP_1:23
    .= union {UIL.i} by FUNCOP_1:14
    .= union {UsedInt*Loc i} by A1
    .= UsedInt*Loc i by ZFMISC_1:31;
end;

theorem Th9: :: StopUsed:
  UsedIntLoc Stop SCM+FSA = {} by Th7,SF_MASTR:17;

theorem Th10: :: StopUsedF:
  UsedInt*Loc Stop SCM+FSA = {}
proof
  thus UsedInt*Loc Stop SCM+FSA = UsedInt*Loc( 0 .--> halt SCM+FSA)
    .= UsedInt*Loc halt SCM+FSA by Th8
    .= {} by SF_MASTR:36;
end;

theorem Th11: :: GotoUsed:
  UsedIntLoc Goto l = {}
proof
  Goto l =  0 .--> goto l by SCMFSA8A:def 2;
  hence UsedIntLoc Goto l = UsedIntLoc goto l by Th7
    .= {} by SF_MASTR:19;
end;

theorem Th12: :: GotoUsedF:
  UsedInt*Loc Goto l = {}
proof
  Goto l =  0 .--> goto l by SCMFSA8A:def 2;
  hence UsedInt*Loc Goto l = UsedInt*Loc goto l by Th8
    .= {} by SF_MASTR:36;
end;

reserve s, s1, s2 for State of SCM+FSA,
  a for read-write Int-Location,
  b for Int-Location,
  I, J for Program of SCM+FSA,
  Ig for good Program of SCM+FSA,
  i, j, k, m, n for Element of NAT;

set D = Int-Locations \/ FinSeq-Locations;
set SAt = Start-At( 0,SCM+FSA);

theorem Th13:
  UsedIntLoc if=0(b, I, J) = {b} \/ UsedIntLoc I \/ UsedIntLoc J
proof
  set I5 = Stop SCM+FSA;
  set a = b;
  set I1 = a =0_goto  (card J + 3);
  set I3 = Goto  (card I + 1);
  thus UsedIntLoc if=0(a, I, J) = UsedIntLoc (I1 ';' J ';' I3 ';' I ';' I5) by
SCMFSA8B:def 1
    .= (UsedIntLoc (I1 ';' J ';' I3 ';' I)) \/ {} by Th9,SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J ';' I3)) \/ UsedIntLoc I by SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J)) \/ UsedIntLoc I3 \/ UsedIntLoc I by SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J)) \/ {} \/ UsedIntLoc I by Th11
    .= UsedIntLoc I1 \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:33
    .= {a} \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:20
    .= {a} \/ UsedIntLoc I \/ UsedIntLoc J by XBOOLE_1:4;
end;

theorem Th14: :: eifUsedF:
  for a being Int-Location holds UsedInt*Loc if=0(a, I, J) =
  UsedInt*Loc I \/ UsedInt*Loc J
proof
  set I5 = Stop SCM+FSA;
  let a be Int-Location;
  set I1 = a =0_goto  (card J + 3);
  set I3 = Goto  (card I + 1);
  thus UsedInt*Loc if=0(a, I, J) = UsedInt*Loc (I1 ';' J ';' I3 ';' I ';' I5)
  by SCMFSA8B:def 1
    .= (UsedInt*Loc (I1 ';' J ';' I3 ';' I)) \/ {} by Th10,SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J ';' I3)) \/ UsedInt*Loc I by SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J)) \/ UsedInt*Loc I3 \/ UsedInt*Loc I by
SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J)) \/ {} \/ UsedInt*Loc I by Th12
    .= UsedInt*Loc I1 \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:49
    .= {} \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:36
    .= UsedInt*Loc I \/ UsedInt*Loc J;
end;

theorem Th15: :: ifUsed:
  UsedIntLoc if>0(b, I, J) = {b} \/ UsedIntLoc I \/ UsedIntLoc J
proof
  set I5 = Stop SCM+FSA;
  set a = b;
  set I1 = a >0_goto  (card J + 3);
  set I3 = Goto  (card I + 1);
  thus UsedIntLoc if>0(a, I, J) = UsedIntLoc (I1 ';' J ';' I3 ';' I ';' I5) by
SCMFSA8B:def 2
    .= (UsedIntLoc (I1 ';' J ';' I3 ';' I)) \/ {} by Th9,SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J ';' I3)) \/ UsedIntLoc I by SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J)) \/ UsedIntLoc I3 \/ UsedIntLoc I by SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J)) \/ {} \/ UsedIntLoc I by Th11
    .= UsedIntLoc I1 \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:33
    .= {a} \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:20
    .= {a} \/ UsedIntLoc I \/ UsedIntLoc J by XBOOLE_1:4;
end;

theorem Th16: :: ifUsedF:
  UsedInt*Loc if>0(b, I, J) = UsedInt*Loc I \/ UsedInt*Loc J
proof
  set I5 = Stop SCM+FSA;
  set a = b;
  set I1 = a >0_goto  (card J + 3);
  set I3 = Goto  (card I + 1);
  thus UsedInt*Loc if>0(a, I, J) = UsedInt*Loc (I1 ';' J ';' I3 ';' I ';' I5)
  by SCMFSA8B:def 2
    .= (UsedInt*Loc (I1 ';' J ';' I3 ';' I)) \/ {} by Th10,SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J ';' I3)) \/ UsedInt*Loc I by SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J)) \/ UsedInt*Loc I3 \/ UsedInt*Loc I by
SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J)) \/ {} \/ UsedInt*Loc I by Th12
    .= UsedInt*Loc I1 \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:49
    .= {} \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:36
    .= UsedInt*Loc I \/ UsedInt*Loc J;
end;

begin :: while=0, general

Lm1: for a being Int-Location, I being Program of SCM+FSA holds card I +4 in
dom if=0(a,I ';' Goto  0,Stop SCM+FSA) & if=0(a,I ';' Goto  0,Stop
SCM+FSA).(card I +4) = goto (( 0)+(card I +4))

proof
  set J = Stop SCM+FSA;
  set G = Goto  0;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' G;
  set i = a =0_goto  (card J + 3);
  set c4 = card I + 4;
  set Lc4 = c4;
  set Mi= Macro i ';' J ';' Goto  (card I1 + 1) ';' I;
x: card Stop SCM+FSA = 1 by COMPOS_1:46;
A1: card (G ';' J) = card G + card J by SCMFSA6A:61
    .= 1 + 1 by x,SCMFSA8A:29
    .= 2;

A2: if=0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' (I ';' G) ';'
  J by SCMFSA8B:def 1

    .= Mi ';' G ';' J by SCMFSA6A:67
    .= Mi ';' (G ';' J) by SCMFSA6A:67;
  then card if=0(a, I1,J) = card Mi + card (G ';' J) by SCMFSA6A:61;
  then
A3: card Mi = card if=0(a,I1,J)-card (G ';' J)
    .= card I + 6 - 2 by A1,SCMFSA_9:1
    .= c4;
  then
A4: not Lc4 in dom Mi;
  set GJ = G ';' J;
A5: InsCode goto  0 = 6 by SCMFSA_2:47;
A6: G =  0 .--> goto  0 by SCMFSA8A:def 2;
  then
A7: G. 0 = goto  0 by FUNCOP_1:87;
  dom G = { 0} by A6,FUNCOP_1:19;
  then
A8:  0 in dom G by TARSKI:def 1;
A9: dom G c= dom GJ by SCMFSA6A:56;

  then  0 + c4 in { il+c4 where il is Element of NAT: il in dom GJ} by A8
;

  then
A10:  c4 in dom Shift(GJ,c4) by VALUED_1:def 12;
  then
A11: Shift(GJ,c4)/.Lc4 = Shift(GJ,c4).( 0 +c4) by PARTFUN1:def 8
    .= GJ. 0 by A8,A9,VALUED_1:def 12
    .= goto  0 by A8,A7,A5,SCMFSA6A:54;
x: card Stop SCM+FSA = 1 by COMPOS_1:46;
  card I1 = card I + card G by SCMFSA6A:61
    .= card I +1 by SCMFSA8A:29;
  then card I1 + card J + 3 = card I +4 +1 by x;
  then c4 < card I1 + card J + 3 by NAT_1:13;
  hence
A12: Lc4 in dom if=0(a,I1,J) by SCMFSA8C:56;

A13: dom if=0(a,I1,J) = dom Directed Mi \/ dom ProgramPart Relocated(GJ, c4
  ) by A2,A3,FUNCT_4:def 1;

  then dom if=0(a,I1,J) = dom Mi \/ dom ProgramPart Relocated(GJ, c4) by
FUNCT_4:105;

  then Lc4 in dom ProgramPart Relocated(GJ, c4) by A12,A4,XBOOLE_0:def 3;

  hence if=0(a,I1,J).Lc4 = (ProgramPart Relocated(GJ,c4)).Lc4 by A12,A2,A3,A13,
FUNCT_4:def 1

    .= Reloc(ProgramPart(GJ),c4).Lc4 by COMPOS_1:116
    .= Reloc(GJ,c4).Lc4 by RELAT_1:209
    .= IncAddr( goto  0, c4 ) by A10,A11,SCMFSA_4:24
    .= goto (( 0)+c4) by SCMFSA_4:14;
end;

Lm2: for a being Int-Location, I being Program of SCM+FSA holds UsedIntLoc
if=0(a,I ';' Goto  0,Stop SCM+FSA) = UsedIntLoc (if=0(a,I ';' Goto
0,Stop SCM+FSA) +* (  (card I +4) .--> goto  0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 =  (card I + 4);
  set if0 = if=0(a,I ';' Goto  0,Stop SCM+FSA);
  set ic4 =  (card I +4) .--> goto  0;

  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedIntLoc i and
A2: UsedIntLoc if0 = Union (UIL1 * if0) by SF_MASTR:def 2;
A3: dom UIL1 = the Instructions of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,RELAT_1:def 19;
A6: dom ic4 = { (card I +4)} by FUNCOP_1:19;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
     (card I +4) in dom if0 by Lm1;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
FUNCT_4:def 1,ZFMISC_1:37;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,RELAT_1:def 19;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:46
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:46;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:12
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.(goto (( 0)+(card I +4))) by A12,Lm1
        .= UsedIntLoc goto (( 0)+(card I +4)) by A1
        .= {} by SF_MASTR:19
        .= UsedIntLoc goto  0 by SF_MASTR:19
        .= UIL1.(goto  0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:87
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:14
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
  end;

  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A14: UsedIntLoc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 2;
  for c be Element of the Instructions of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedIntLoc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:113;
  hence thesis by A2,A14,A4,FUNCT_1:9;
end;

Lm3: for a being Int-Location, I being Program of SCM+FSA holds UsedInt*Loc
if=0(a,I ';' Goto  0,Stop SCM+FSA) = UsedInt*Loc (if=0(a,I ';' Goto
 0,Stop SCM+FSA) +* (  (card I +4) .--> goto  0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 =  (card I + 4);
  set if0 = if=0(a,I ';' Goto  0,Stop SCM+FSA);
  set ic4 =  (card I +4) .--> goto  0;

  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedInt*Loc i and
A2: UsedInt*Loc if0 = Union (UIL1 * if0) by SF_MASTR:def 4;
A3: dom UIL1 = the Instructions of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,RELAT_1:def 19;
A6: dom ic4 = { (card I +4)} by FUNCOP_1:19;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
     (card I +4) in dom if0 by Lm1;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
FUNCT_4:def 1,ZFMISC_1:37;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,RELAT_1:def 19;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:46
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:46;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:12
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.(goto (( 0)+(card I +4))) by A12,Lm1
        .= UsedInt*Loc goto (( 0)+(card I +4)) by A1
        .= {} by SF_MASTR:36
        .= UsedInt*Loc goto  0 by SF_MASTR:36
        .= UIL1.(goto  0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:87
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:14
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
  end;

  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A14: UsedInt*Loc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 4;
  for c be Element of the Instructions of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedInt*Loc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:113;
  hence thesis by A2,A14,A4,FUNCT_1:9;
end;

theorem :: ewhileUsed:
  UsedIntLoc while=0(b, I) = {b} \/ UsedIntLoc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ';' Goto  0;
  while=0(a, I) = if=0(a, IG, J) +* (  (card I +4) .--> goto
  0 ) by SCMFSA_9:def 1;
  hence UsedIntLoc while=0(a, I) = (UsedIntLoc if=0(a, IG, J)) by Lm2
    .= {a} \/ UsedIntLoc IG \/ UsedIntLoc J by Th13
    .= {a} \/ (UsedIntLoc I \/ UsedIntLoc Goto  0) \/ UsedIntLoc J by
SF_MASTR:31
    .= {a} \/ (UsedIntLoc I \/ {}) \/ UsedIntLoc J by Th11
    .= {a} \/ UsedIntLoc I by Th9;
end;

theorem :: ewhileUsedF:
  UsedInt*Loc while=0(b, I) = UsedInt*Loc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ';' Goto  0;
  while=0(a, I) = if=0(a, IG, J) +* (  (card I +4) .--> goto
  0 ) by SCMFSA_9:def 1;
  hence UsedInt*Loc while=0(a, I) = (UsedInt*Loc if=0(a, IG, J)) by Lm3
    .= UsedInt*Loc IG \/ UsedInt*Loc J by Th14
    .= (UsedInt*Loc I \/ UsedInt*Loc Goto  0) \/ UsedInt*Loc J by SF_MASTR:47
    .= UsedInt*Loc I \/ {} by Th10,Th12
    .= UsedInt*Loc I;
end;

definition
  let s be State of SCM+FSA, a be read-write Int-Location, I be Program of
  SCM+FSA;
  pred ProperBodyWhile=0 a, I, s means
  :Def1:
  for k being Element of NAT st
  StepWhile=0(a,I,s).k.a = 0 holds I is_closed_on StepWhile=0(a,I,s).k & I
  is_halting_on StepWhile=0(a,I,s).k;
  pred WithVariantWhile=0 a, I, s means
  :Def2:
  ex f being Function of product
  the Object-Kind of SCM+FSA, NAT st for k being Element of NAT holds ( f.(
StepWhile=0(a,I,s).(k+1)) < f.(StepWhile=0(a,I,s).k) or StepWhile=0(a,I,s).k.a
  <> 0 );
end;

theorem Th19: :: eParaProper:
  for I being parahalting Program of SCM+FSA holds
  ProperBodyWhile=0 a, I, s
proof
  let I be parahalting Program of SCM+FSA;
  let k be Element of NAT such that
  StepWhile=0(a,I,s).k.a = 0;
  thus I is_closed_on StepWhile=0(a,I,s).k by SCMFSA7B:24;
  thus thesis by SCMFSA7B:25;
end;

theorem Th20: :: SCMFSA_9:24, corrected
  ProperBodyWhile=0 a, I, s & WithVariantWhile=0 a, I, s implies
  while=0(a,I) is_halting_on s & while=0(a,I) is_closed_on s
proof
  assume
A1: for k being Element of NAT st StepWhile=0(a,I,s).k.a = 0 holds I
  is_closed_on StepWhile=0(a,I,s).k & I is_halting_on StepWhile=0(a,I,s).k;
  set s1 = s +* (while=0(a,I) +* Start-At( 0,SCM+FSA));
  defpred S[Element of NAT] means StepWhile=0(a,I,s).$1.a <> 0;
  given f being Function of product the Object-Kind of SCM+FSA,NAT such that
A2: for k being Element of NAT holds (f.(StepWhile=0(a,I,s).(k+1)) < f.(
  StepWhile=0(a,I,s).k) or (StepWhile=0(a,I,s).k).a <> 0 );
  deffunc F(Nat) = f.(StepWhile=0(a,I,s).$1);
A3: for k holds ( F(k+1) < F(k) or S[k] ) by A2;
  consider m being Element of NAT such that
A4: S[m] and
A5: for n st S[n] holds m <= n from NAT_1:sch 18(A3);
  defpred P[Nat] means $1+1 <= m implies ex k st StepWhile=0(a,I,s)
  .($1+1)=Comput(ProgramPart(s1),s1,k);
A6: now
    let k be Element of NAT;
    assume
A7: P[k];
    now
      set sk1=StepWhile=0(a,I,s).(k+1);
      set sk=StepWhile=0(a,I,s).k;
      assume
A8:   (k+1)+ 1 <= m;
      k + 0 < k+ (1+ 1) by XREAL_1:8;
      then k < m by A8,XXREAL_0:2;
      then
A9:   sk.a = 0 by A5;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
      then consider n being Element of NAT such that
A10:  sk1 = Comput(ProgramPart(s1),s1,n) by A7,A8,XXREAL_0:2;
A11:  sk1 = Comput(ProgramPart((sk +* (while=0(a,I)+* SAt))),(sk +* (while=0(a,
I)+* SAt)), (LifeSpan(ProgramPart(sk +* (I
      +* SAt)),sk +* (I
      +* SAt)) + 3)) by SCMFSA_9:def 4;
      take m=n +(LifeSpan(ProgramPart(sk1 +* (I +* SAt)),sk1 +* (I +* SAt)) + 3
);
      I is_closed_on sk & I is_halting_on sk by A1,A9;
      then IC sk1 =  0 by A11,A9,SCMFSA_9:22;
      hence StepWhile=0(a,I,s).((k+1)+1)=Comput(ProgramPart(s1),s1,m) by A10,
SCMFSA_9:31;
    end;
    hence P[k+1];
  end;
A12: IC SCM+FSA in dom (while=0(a,I) +* SAt ) by COMPOS_1:141;
A13: P[0]
  proof
    assume 0+1 <= m;
    take n=(LifeSpan(ProgramPart(s+* (I +* SAt)),s+* (I +* SAt)) + 3);
    thus thesis by SCMFSA_9:30;
  end;
A14: for k being Element of NAT holds P[k] from NAT_1:sch 1(A13,A6);
  now
    per cases;
    suppose
      m = 0;
      then s.a <> 0 by A4,SCMFSA_9:def 4;
      hence thesis by SCMFSA_9:18;
    end;
    suppose
A15:  m <> 0;
      set p=(LifeSpan(ProgramPart(s+* (I +* SAt)),s+* (I +* SAt)) + 3);
      set sm=StepWhile=0(a,I,s).m;
      set sm1=sm +* (while=0(a,I)+* SAt);
      consider i being Nat such that
A16:  m=i+1 by A15,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      set si=StepWhile=0(a,I,s).i;
A17:  sm= Comput(ProgramPart((si +* (while=0(a,I)+* SAt))),(si +* (while=0(a,I)
+* SAt)), (LifeSpan(ProgramPart(si +* (I
      +* SAt)),si +* (I
      +* SAt)) + 3)) by A16,SCMFSA_9:def 4;
      m=i+1 by A16;
      then consider n being Element of NAT such that
A18:  sm = Comput(ProgramPart(s1),s1,n) by A14;
      i < m by A16,NAT_1:13;
      then
A19:  si.a = 0 by A5;
      then I is_closed_on si & I is_halting_on si by A1;
      then
A20:  IC sm =  0 by A17,A19,SCMFSA_9:22;
      ProgramPart sm =ProgramPart s1 by A18,AMI_1:123;
      then
A21:  DataPart sm1 = DataPart sm &
        ProgramPart sm1 = ProgramPart sm by FUNCT_4:100,SCMFSA8A:11;
      IC sm1 = IC(while=0(a,I) +* SAt) by A12,FUNCT_4:14
        .= IC sm by A20,COMPOS_1:142;
      then
A22:  sm1=sm by A21,SCMFSA_9:29;
      while=0(a,I) is_halting_on sm by A4,SCMFSA_9:18;
      then ProgramPart sm1 halts_on sm1 by SCMFSA7B:def 8;
      then consider j being Element of NAT such that
A23:  CurInstr(ProgramPart sm,Comput(ProgramPart(sm),sm,j)) = halt SCM+FSA
by A22,EXTPRO_1:30;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),
s1,n)
by AMI_1:123;
x: Comput(ProgramPart(s1),s1,n+j)
 = Comput(ProgramPart(s1),Comput(ProgramPart(s1),s1,n),j) by EXTPRO_1:5;
      CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,n+j))
       = halt SCM+FSA by A18,A23,x,T;
      then ProgramPart s1 halts_on s1 by EXTPRO_1:30;
      hence while=0(a,I) is_halting_on s by SCMFSA7B:def 8;
      now
        let q be Element of NAT;
        per cases;
        suppose
A24:      q <= p;
A25:      StepWhile=0(a,I,s).0 = s by SCMFSA_9:def 4;
          then
A26:      s.a = 0 by A5,A15;
          then I is_closed_on s & I is_halting_on s by A1,A25;
          hence IC Comput(ProgramPart(s1),s1,q) in dom while=0(a,I) by A24,A26,
SCMFSA_9:22
;
        end;
        suppose
A27:      q > p;
A28:      now
            take k=p;
            thus StepWhile=0(a,I,s).1=Comput(ProgramPart(s1),s1,k) & k <= q by
A27,SCMFSA_9:30;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 & (ex k st StepWhile=0(a,I,s).$1
          = Comput(ProgramPart(s1),s1,k) & k <= q);
A29:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A15,XREAL_1:8;
          then 1 <= m by NAT_1:13;
          then
A30:      ex k be Nat st P2[k] by A28;
          consider t be Nat such that
A31:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A29,A30);
          reconsider t as Element of NAT by ORDINAL1:def 13;
          now
            per cases;
            suppose
              t=m;
              then consider r being Element of NAT such that
A32:          sm=Comput(ProgramPart(s1),s1,r) and
A33:          r <= q by A31;
              consider x being Nat such that
A34:          q = r+x by A33,NAT_1:10;
A35:          while=0(a,I) is_closed_on sm by A4,SCMFSA_9:18;
              reconsider x as Element of NAT by ORDINAL1:def 13;
T: ProgramPart s1 = ProgramPart sm1
by A22,A32,AMI_1:123;
              Comput(ProgramPart(s1),s1,q) = Comput(ProgramPart(s1),sm1,x) by
A22,A32,A34,EXTPRO_1:5;
              hence IC Comput(ProgramPart(s1),s1,q) in dom while=0(a,I) by A35
,T,SCMFSA7B:def 7;
            end;
            suppose
A36:          t<>m;
              set Dt=StepWhile=0(a,I,s).t;
              consider y being Nat such that
A37:          t=y+1 by A31,NAT_1:6;
              reconsider y as Element of NAT by ORDINAL1:def 13;
              set Dy=StepWhile=0(a,I,s).y;
A38:          Dt= Comput(ProgramPart((Dy +* (while=0(a,I)+* SAt))),(Dy +* (
while=0(a,I)+* SAt)), (LifeSpan(ProgramPart(Dy
              +* (I +* SAt)),Dy
              +* (I +* SAt)) + 3)) by A37,SCMFSA_9:def 4;
              y+ 0 < t by A37,XREAL_1:8;
              then y < m by A31,XXREAL_0:2;
              then
A39:          Dy.a = 0 by A5;
              then I is_closed_on Dy & I is_halting_on Dy by A1;
              then
A40:          IC Dt = 0 by A38,A39,SCMFSA_9:22;
              consider z being Element of NAT such that
A41:          StepWhile=0(a,I,s).t=Comput(ProgramPart(s1),s1,z) and
A42:          z <= q by A31;
              consider w being Nat such that
A43:          q = z+w by A42,NAT_1:10;
              reconsider w as Element of NAT by ORDINAL1:def 13;
X: Dt = Dt +* (while=0(a,I)+* SAt) by A41,A40,SCMFSA_9:31;
T: ProgramPart s1 = ProgramPart Dt
by A41,AMI_1:123;
A44:          Comput(ProgramPart(s1),s1,q) = Comput(ProgramPart(s1),Dt,w) by
A41,A43,EXTPRO_1:5
                .= Comput(ProgramPart((Dt +* (while=0(a,I)+* SAt))),(Dt +* (
while=0(a,I)+* SAt)),w) by X,T;
              set z2=z +(LifeSpan(ProgramPart(Dt +* (I +* SAt)),Dt +* (I +* SAt
)) + 3);
A45:          t < m by A31,A36,XXREAL_0:1;
              now
                assume
A46:            z2 <= q;
A47:            now
                  take k=z2;
                  thus StepWhile=0(a,I,s).(t+1)=Comput(ProgramPart(s1),s1,k) &
k <= q by A41,A40,A46,SCMFSA_9:31;
                end;
                t+1 <= m by A45,NAT_1:13;
                hence contradiction by A31,A47,XREAL_1:31;
              end;
              then
A48:          w < LifeSpan(ProgramPart(Dt +* (I +* SAt)),Dt +* (I +* SAt)) + 3
by A43,XREAL_1:8;
A49:          Dt.a = 0 by A5,A45;
              then I is_closed_on Dt & I is_halting_on Dt by A1;
              hence IC Comput(ProgramPart(s1),s1,q) in dom while=0(a,I) by A48
,A44,A49,SCMFSA_9:22;
            end;
          end;
          hence IC Comput(ProgramPart(s1),s1,q) in dom while=0(a,I);
        end;
      end;
      hence while=0(a,I) is_closed_on s by SCMFSA7B:def 7;
    end;
  end;
  hence thesis;
end;

theorem Th21: :: SCMFSA_9:25, corrected
  for I being parahalting Program of SCM+FSA st WithVariantWhile=0
  a, I, s holds while=0(a,I) is_halting_on s & while=0(a,I) is_closed_on s
proof
  let I be parahalting Program of SCM+FSA such that
A1: WithVariantWhile=0 a, I, s;
  ProperBodyWhile=0 a, I, s
  proof
    let k be Element of NAT;
    assume StepWhile=0(a,I,s).k.a = 0;
    thus thesis by SCMFSA7B:24,25;
  end;
  hence thesis by A1,Th20;
end;

theorem Th22: :: based on SCMFSA_9:10
  while=0(a, I) +* (Start-At( 0,SCM+FSA)) c= s & s.a <> 0 implies
  LifeSpan(ProgramPart(s),s) = 4 & for k being Element of NAT holds DataPart
Comput(ProgramPart
(s),s,k) =
  DataPart s
proof
  assume that
A1: while=0(a, I) +* SAt c= s and
A2: s.a <> 0;
  set i = a =0_goto  4;
  set s1 = s +* (while=0(a,I) +* Start-At( 0,SCM+FSA));
A3: IC SCM+FSA in dom (while=0(a,I) +* Start-At( 0,SCM+FSA))
by COMPOS_1:141;
  while=0(a,I) c= while=0(a,I) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A4: dom while=0(a,I) c= dom (while=0(a,I) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
  not a in dom (while=0(a,I) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  then
A5: s1.a = s.a by FUNCT_4:12;
A6:  1 in dom while=0(a,I) by SCMFSA_9:10;
A7: Comput(ProgramPart(s1),s1,1). 1 = s1. 1 by AMI_1:54
    .= (while=0(a,I) +* Start-At( 0,SCM+FSA)). 1
    by A4,A6,FUNCT_4:14
    .= while=0(a,I). 1 by A6,SCMFSA6B:7
    .= goto  2 by SCMFSA_9:11;
A8: IC s1 = IC(while=0(a,I) +* Start-At( 0,SCM+FSA)) by A3,FUNCT_4:14
    .=  0 by COMPOS_1:142;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by COMPOS_1:38;
A9:  0 in dom while=0(a,I) by SCMFSA_9:10;
  then s1. 0 = (while=0(a,I) +* Start-At( 0,SCM+FSA)). 0
  by A4,FUNCT_4:14
    .= while=0(a,I). 0 by A9,SCMFSA6B:7
    .= i by SCMFSA_9:11;
  then
A10: CurInstr(ProgramPart s1,s1) = i by A8,Y;
A11: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by EXTPRO_1:4
    .= Following(ProgramPart s1,s1) by EXTPRO_1:3
    .= Exec(i,s1) by A10;
  set loc5=  (card I +5);
  set s5 = Comput(ProgramPart(s1),s1,4);
  set s4 = Comput(ProgramPart(s1),s1,3);
  set s3 = Comput(ProgramPart(s1),s1,2);
  set s2 = Comput(ProgramPart(s1),s1,1);
A12:  2 in dom while=0(a,I) by SCMFSA_9:12;
A13: s3. 2 = s1. 2 by AMI_1:54
    .= (while=0(a,I) +* Start-At( 0,SCM+FSA)). 2
    by A4,A12,FUNCT_4:14
    .= while=0(a,I). 2 by A12,SCMFSA6B:7
    .= goto  3 by SCMFSA_9:16;
A14:  3 in dom while=0(a,I) by SCMFSA_9:12;
A15: s4. 3 = s1. 3 by AMI_1:54
    .= (while=0(a,I) +* Start-At( 0,SCM+FSA)). 3
    by A4,A14,FUNCT_4:14
    .= while=0(a,I). 3 by A14,SCMFSA6B:7
    .= goto loc5 by SCMFSA_9:15;
A16: loc5 in dom while=0(a,I) by SCMFSA_9:13;
A17: s5.loc5 = s1.loc5 by AMI_1:54
    .= (while=0(a,I) +* Start-At( 0,SCM+FSA)).loc5 by A4,A16,FUNCT_4:14
    .= while=0(a,I).loc5 by A16,SCMFSA6B:7
    .= halt SCM+FSA by SCMFSA_9:14;
A18: ( for c being Int-Location holds Exec(goto loc5, s4).c = s4.c)& for f
  being FinSeq-Location holds Exec(goto loc5, s4).f = s4.f by SCMFSA_2:95;
A19: ( for c being Int-Location holds Exec(goto  2, s2).c = s2.c)& for
f being FinSeq-Location holds Exec(goto  2, s2).f = s2.f by SCMFSA_2:95;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,1))/.IC Comput(ProgramPart(s1),s1,1)
 = Comput(ProgramPart(s1),s1,1).IC Comput(ProgramPart(s1),s1,1) by COMPOS_1:38;
  IC Comput(ProgramPart(s1),s1,1) = Comput(ProgramPart(s1),s1,1).IC SCM+FSA
    .= succ  0 by A2,A8,A11,A5,SCMFSA_2:96
    .=  (0 + 1);
  then
A20: CurInstr(ProgramPart Comput(ProgramPart(s1),s1,1),Comput(ProgramPart(s1),
s1,1)) = goto  2
by A7,Y;
T: ProgramPart s1 = ProgramPart s2
by AMI_1:123;
A21: Comput(ProgramPart(s1),s1,1+1) = Following(ProgramPart s1,s2) by
EXTPRO_1:4
    .= Exec(goto  2,s2) by A20,T;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
  IC s3 = s3.IC SCM+FSA
    .=  2 by A21,SCMFSA_2:95;
  then
A22: CurInstr(ProgramPart s3,s3) = goto  3 by A13,Y;
T: ProgramPart s1 = ProgramPart s3
by AMI_1:123;
A23: Comput(ProgramPart(s1),s1,2+1) = Following(ProgramPart s1,s3) by
EXTPRO_1:4
    .= Exec(goto  3,s3) by A22,T;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
  IC s4 = s4.IC SCM+FSA
    .=  3 by A23,SCMFSA_2:95;
  then
A24: CurInstr(ProgramPart s4,s4) = goto loc5 by A15,Y;
T: ProgramPart s1 = ProgramPart s4
by AMI_1:123;
A25: Comput(ProgramPart(s1),s1,3+1) = Following(ProgramPart s1,s4) by
EXTPRO_1:4
    .= Exec(goto loc5,s4) by A24,T;
Y:  (ProgramPart s5)/.IC s5
 = s5.IC s5 by COMPOS_1:38;
TX: ProgramPart s1 = ProgramPart s5
by AMI_1:123;
  IC s5 = s5.IC SCM+FSA
    .= loc5 by A25,SCMFSA_2:95;
  then
A26: CurInstr(ProgramPart s5,s5) = halt SCM+FSA by A17,Y;
  then
A27: ProgramPart s1 halts_on s1 by TX,EXTPRO_1:30;
A28: s = s1 by A1,FUNCT_4:79;
  now
    let k;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k)
by AMI_1:123;
    assume
A29: CurInstr(ProgramPart s,Comput(ProgramPart(s),s,k)) = halt SCM+FSA;
    assume 4 > k;
    then 3+1 > k;
    then
A30: k <= 3 by NAT_1:13;
    per cases by A30,NAT_1:28;
    suppose
      k = 0;
      then Comput(ProgramPart(s),s,k) = s by EXTPRO_1:3;
      hence contradiction by A28,A10,A29,SCMFSA_2:48;
    end;
    suppose
      k = 1;
      hence contradiction by A28,A20,A29,TX,SCMFSA_2:47;
    end;
    suppose
      k = 2;
      hence contradiction by A28,A22,A29,TX,SCMFSA_2:47;
    end;
    suppose
      k = 3;
      hence contradiction by A28,A24,A29,TX,SCMFSA_2:47;
    end;
  end;
  hence
A31: LifeSpan(ProgramPart(s),s) = 4 by A28,A26,A27,TX,EXTPRO_1:def 14;
A32: ( for c being Int-Location holds Exec(i, s1).c = s1.c)& for f being
  FinSeq-Location holds Exec(i, s1).f = s1.f by SCMFSA_2:96;
  then
A33: DataPart Comput(ProgramPart(s),s,1) = DataPart s by A28,A11,SCMFSA6A:38;
  then
A34: DataPart Comput(ProgramPart(s),s,2) = DataPart s by A28,A21,A19,
SCMFSA6A:38;
A35: ( for c being Int-Location holds Exec(goto  3, s3).c = s3.c)& for
f being FinSeq-Location holds Exec(goto  3, s3).f = s3.f by SCMFSA_2:95;
  then DataPart Comput(ProgramPart(s),s,3) = DataPart s by A28,A23,A34,
SCMFSA6A:38;
  then
A36: DataPart Comput(ProgramPart(s),s,4) = DataPart s by A28,A25,A18,
SCMFSA6A:38;
  let k be Element of NAT;
  k <= 3 or 3 < k;
  then
A37: k = 0 or k = 1 or k = 2 or k = 3 or 3+1 <= k by NAT_1:13,28;
  per cases by A37;
  suppose
    k = 0;
    hence thesis by EXTPRO_1:3;
  end;
  suppose
    k = 1;
    hence thesis by A28,A11,A32,SCMFSA6A:38;
  end;
  suppose
    k = 2;
    hence thesis by A28,A21,A19,A33,SCMFSA6A:38;
  end;
  suppose
    k = 3;
    hence thesis by A28,A23,A35,A34,SCMFSA6A:38;
  end;
  suppose
    4 <= k;
    then CurInstr(ProgramPart s,Comput(ProgramPart(s),
s,k))
     = halt SCM+FSA by A28,A27,A31,SCMFSA8A:4;
    hence thesis by A31,A36,EXTPRO_1:24;
  end;
end;

theorem Th23: :: based on SCMFSA_9:22
  I is_closed_on s & I is_halting_on s & s.a = 0 implies DataPart
  Comput(ProgramPart((s +* (while=0(a,I) +* Start-At( 0,SCM+FSA)))),(s +* (
while=0(a,I) +* Start-At( 0,SCM+FSA))),
  (LifeSpan(ProgramPart(s +* (I +*
Start-At( 0,SCM+FSA))),s +* (I +*
Start-At( 0,SCM+FSA))) + 3)) =
DataPart Comput(ProgramPart((s +* (I +* Start-At( 0,SCM+FSA))
  )),(s +* (I +* Start-At( 0,SCM+FSA))
  ), (LifeSpan(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +*
Start-At( 0,SCM+FSA)))))
proof
  assume that
A1: I is_closed_on s & I is_halting_on s and
A2: s.a = 0;
  set sI = s +* (I +* Start-At( 0,SCM+FSA));
  set s1 = s +* (while=0(a,I) +* Start-At( 0,SCM+FSA));
  defpred P[Nat] means $1 <= LifeSpan(ProgramPart(sI),sI) implies IC Comput(
ProgramPart(s1),s1,
  1+$1) = IC Comput(ProgramPart(sI),sI,$1) + 4 & DataPart Comput(ProgramPart(s1
),s1,1+$1) = DataPart
  Comput(ProgramPart(sI),sI,$1);
A3: now
    let k be Element of NAT;
    assume
A4: P[k];
    now
A5:   k + 0 < k + 1 by XREAL_1:8;
      assume k + 1 <= LifeSpan(ProgramPart(sI),sI);
      then k < LifeSpan(ProgramPart(sI),sI) by A5,XXREAL_0:2;
      hence IC Comput(ProgramPart(s1),s1,1+k+1) = IC Comput(ProgramPart(sI),sI,
k+1) + 4 & DataPart
Comput(ProgramPart(s1),s1,1+k+1) = DataPart Comput(ProgramPart(sI),sI,k+1) by
A1,A4,SCMFSA_9:19;
    end;
    hence P[k + 1];
  end;
  set i = a =0_goto  4;
  set s2 = Comput(ProgramPart(s1),s1,1);
A6: IC SCM+FSA in dom (while=0(a,I) +* Start-At( 0,SCM+FSA))
by COMPOS_1:141;
A7: IC s1 = IC(while=0(a,I) +* Start-At( 0,SCM+FSA)) by A6,FUNCT_4:14
    .=  0 by COMPOS_1:142;
  not a in dom (while=0(a,I) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  then
A8: s1.a = s.a by FUNCT_4:12;
  set loc4 =  (card I + 4);
  while=0(a,I) c= while=0(a,I) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A9: dom while=0(a,I) c= dom (while=0(a,I) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by COMPOS_1:38;
A10:  0 in dom while=0(a,I) by SCMFSA_9:10;
  then s1. 0 = (while=0(a,I) +* Start-At( 0,SCM+FSA)). 0
  by A9,FUNCT_4:14
    .= while=0(a,I). 0 by A10,SCMFSA6B:7
    .= i by SCMFSA_9:11;
  then
A11: CurInstr(ProgramPart s1,s1) = i by A7,Y;
A12: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by EXTPRO_1:4
    .= Following(ProgramPart s1,s1) by EXTPRO_1:3
    .= Exec(i,s1) by A11;
  then ( for c being Int-Location holds s2.c = s1.c)& for f being
  FinSeq-Location holds s2.f = s1.f by SCMFSA_2:96;
  then
A13: DataPart s2 = DataPart s1 by SCMFSA6A:38
    .= DataPart s by SCMFSA8A:11
    .= DataPart sI by SCMFSA8A:11;
A14: IC s2 = s2.IC SCM+FSA
    .=  4 by A2,A12,A8,SCMFSA_2:96;
A15: P[0]
  proof
    assume 0 <= LifeSpan(ProgramPart(sI),sI);
A16: IC SCM+FSA in dom (I +* Start-At( 0,SCM+FSA)) by COMPOS_1:141;
    IC Comput(ProgramPart(sI),sI,0) = IC sI by EXTPRO_1:3
      .= IC(I +* Start-At( 0,SCM+FSA)) by A16,FUNCT_4:14
      .=  0 by COMPOS_1:142;
    hence thesis by A14,A13,EXTPRO_1:3;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A15,A3);
  then
A17: P[LifeSpan(ProgramPart(sI),sI) qua Element of NAT];
  set s4=Comput(ProgramPart(s1),s1,1+LifeSpan(ProgramPart(sI),sI)+1+1);
  set s3 = Comput(ProgramPart(s1),s1,1+LifeSpan(ProgramPart(sI),sI)+1);
A18: loc4 in dom while=0(a,I) by SCMFSA_9:13;
  set s2 = Comput(ProgramPart(s1),s1,1+LifeSpan(ProgramPart(sI),sI));
A19: CurInstr(ProgramPart s2,s2) = goto loc4 by A1,A17,SCMFSA_9:20;
T: ProgramPart s1 = ProgramPart s2
by AMI_1:123;
A20: s3 = Following(ProgramPart s1,s2) by EXTPRO_1:4
    .= Exec(goto loc4,s2) by A19,T;
  then
A21: ( for c being Int-Location holds s3.c = s2.c)& for f being
  FinSeq-Location holds s3.f = s2.f by SCMFSA_2:95;
A22: s3.loc4 = s1.loc4 by AMI_1:54
    .= (while=0(a,I) +* Start-At( 0,SCM+FSA)).loc4 by A9,A18,FUNCT_4:14
    .= while=0(a,I).loc4 by A18,SCMFSA6B:7
    .= goto  0 by SCMFSA_9:21;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
  IC s3 = s3.IC SCM+FSA
    .= loc4 by A20,SCMFSA_2:95;
  then
A23: CurInstr(ProgramPart s3,s3) = goto  0 by A22,Y;
T: ProgramPart s1 = ProgramPart s3
by AMI_1:123;
  s4 = Following(ProgramPart s1,s3) by EXTPRO_1:4
    .= Exec(goto  0,s3) by A23,T;
  then ( for c being Int-Location holds s4.c = s3.c)& for f being
  FinSeq-Location holds s4.f = s3.f by SCMFSA_2:95;
  hence DataPart Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(sI),sI)+3) =
DataPart s3 by SCMFSA6A:38
    .= DataPart Comput(ProgramPart(sI),sI,LifeSpan(ProgramPart(sI),sI)) by A17
,A21,SCMFSA6A:38;
end;

theorem Th24: :: Step_eq0_0:
  (StepWhile=0(a, I, s).k).a <> 0 implies DataPart StepWhile=0(a,
  I, s).(k+1) = DataPart StepWhile=0(a, I, s).k
proof
  assume
A1: (StepWhile=0(a, I, s).k).a <> 0;
  set SW = StepWhile=0(a, I, s);
A2: while=0(a,I) +* SAt c= SW.k +* (while=0(a,I) +* SAt) by FUNCT_4:26;
A3: DataPart(SW.k +* (while=0(a,I) +* SAt)) = DataPart SW.k by SCMFSA8A:11;
  then
A4: SW.k.a = (SW.k +* (while=0(a,I) +* SAt)).a by SCMFSA6A:38;
  thus DataPart SW.(k+1) = DataPart Comput(ProgramPart((SW.k +* (while=0(a,I)
+* SAt)
  )),(SW.k +* (while=0(a,I) +* SAt)
  ), (LifeSpan(ProgramPart(SW.k +* (I +* SAt)),SW.k +* (I +* SAt)) + 3)) by
SCMFSA_9:def 4
    .= DataPart StepWhile=0(a, I, s).k by A1,A3,A4,A2,Th22;
end;

theorem Th25: :: Step_eq0_1:
  ( I is_halting_on Initialized StepWhile=0(a, I, s).k & I
  is_closed_on Initialized StepWhile=0(a, I, s).k or I is parahalting) & (
  StepWhile=0(a, I, s).k).a = 0 & (StepWhile=0(a, I, s).k).intloc 0 = 1 implies
DataPart StepWhile=0(a, I, s).(k+1) = DataPart IExec(I, StepWhile=0(a, I, s).k)
proof
  set Ins = NAT;
  assume that
A1: I is_halting_on Initialized StepWhile=0(a, I, s).k & I is_closed_on
  Initialized StepWhile=0(a, I, s).k or I is parahalting and
A2: (StepWhile=0(a, I, s).k).a = 0 and
A3: (StepWhile=0(a, I, s).k).intloc 0 = 1;
  set ISWk = Initialized StepWhile=0(a, I, s).k;
  set SW = StepWhile=0(a, I, s);
  set SWkI = SW.k+*Initialized I;
  DataPart ISWk = DataPart SW.k by A3,SCMFSA8C:27;
  then
A4: I is_closed_on SW.k & I is_halting_on SW.k by A1,SCMFSA7B:24,25,SCMFSA8B:8;
  I is_halting_on ISWk by A1,SCMFSA7B:25;
  then Initialized I is_halting_on SW.k by SCMFSA8C:22;
  then
X:   SAt c= Initialized I &
  ProgramPart(SW.k+*(Initialized I +* SAt))
   halts_on SW.k+*(Initialized I +* SAt) by FUNCT_4:26,SCMFSA7B:def 8;
  then SWkI = SW.k+*Initialize Initialized I by FUNCT_4:79;
  then
A5: ProgramPart SWkI halts_on SWkI by X;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A6: dom ProgramPart(SW.k) misses D by COMPOS_1:34;
  set IS = Initialize I;
  set SWkIS = SW.k+*IS;
A7: SWkI = SWkIS by A3,SCMFSA8C:18;
  set WHS = while=0(a, I) +* SAt;
A8: SW.(k+1) = Comput(ProgramPart((SW.k +* WHS)),(SW.k +* WHS),LifeSpan(
ProgramPart(SWkIS),SWkIS)
+ 3) by SCMFSA_9:def 4;
  DataPart IExec(I, SW.k) = DataPart(Result(ProgramPart(SWkI),SWkI) +* SW.k |
Ins) by SCMFSA6B:def 1
    .= DataPart Result(ProgramPart(SWkI),SWkI) by A6,FUNCT_4:76,SCMFSA_2:127
    .= DataPart Comput(ProgramPart(SWkIS),SWkIS,LifeSpan(ProgramPart(SWkIS),
SWkIS)) by A7,A5,EXTPRO_1:23;
  hence thesis by A2,A8,A4,Th23;
end;

theorem :: eGoodStep0:
  (ProperBodyWhile=0 a, Ig, s or Ig is parahalting) & s.intloc 0 = 1
  implies for k holds StepWhile=0(a, Ig, s).k.intloc 0 = 1
proof
  set I = Ig;
  assume that
A1: ProperBodyWhile=0 a,I, s or I is parahalting and
A2: s.intloc 0 = 1;
  set SW = StepWhile=0(a, I, s);
  defpred X[Nat] means SW.$1.intloc 0 = 1;
A3: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT such that
A4: SW.k.intloc 0 = 1;
    per cases;
    suppose
      SW.k.a <> 0;
      then DataPart SW.(k+1) = DataPart SW.k by Th24;
      hence thesis by A4,SCMFSA6A:38;
    end;
    suppose
A5:   SW.k.a = 0;
      set Ins = NAT;
      set IS = Initialize I;
      set SWkIS = SW.k+*IS;
      Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
      then
A6:   dom ProgramPart(SW.k) misses D by COMPOS_1:34;
      set SWkI = SW.k+*Initialized I;
      set ISWk = Initialized StepWhile=0(a, I, s).k;
A7:   DataPart SW.k = DataPart ISWk by A4,SCMFSA8C:27;
A8:   ProperBodyWhile=0 a, I, s by A1,Th19;
      then
A9:   I is_closed_on SW.k by A5,Def1;
      I is_halting_on SW.k by A5,A8,Def1;
      then
A10:  I is_halting_on Initialized SW.k by A9,A7,SCMFSA8B:8;
      then Initialized I is_halting_on SW.k by SCMFSA8C:22;
      then
X:       SAt c= Initialized I &
      ProgramPart(SW.k+*(Initialized I +* SAt))
       halts_on SW.k+*(Initialized I +* SAt) by FUNCT_4:26,SCMFSA7B:def 8;
  then SWkI = SW.k+*(Initialized I +* SAt) by FUNCT_4:79;
      then
A11:  ProgramPart SWkI halts_on SWkI by X;
A12:  SWkI = SWkIS by A4,SCMFSA8C:18;
A13:  DataPart IExec(I, SW.k) = DataPart(Result(ProgramPart(SWkI),SWkI) +* SW.k
| Ins) by SCMFSA6B:def 1
        .= DataPart Result(ProgramPart(SWkI),SWkI) by A6,FUNCT_4:76
,SCMFSA_2:127
        .= DataPart Comput(ProgramPart(SWkIS),SWkIS,LifeSpan(ProgramPart(SWkIS)
,SWkIS)) by A12,A11,EXTPRO_1:23;
      I is_closed_on Initialized SW.k by A9,A7,SCMFSA8B:6;
      then DataPart SW.(k+1) = DataPart IExec(I, SW.k) by A4,A5,A10,Th25;
      hence
      SW.(k+1).intloc 0 = (Comput(ProgramPart(SWkIS),SWkIS,LifeSpan(ProgramPart
(SWkIS),SWkIS))).
intloc 0 by A13,SCMFSA6A:38
        .= 1 by A4,A9,SCMFSA8C:97;
    end;
  end;
A14: X[0] by A2,SCMFSA_9:def 4;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A14,A3);
end;

theorem
  ProperBodyWhile=0 a, I, s1 & DataPart s1 = DataPart s2 implies for k
  holds DataPart StepWhile=0(a, I, s1).k = DataPart StepWhile=0(a, I, s2).k
proof
  assume that
A1: ProperBodyWhile=0 a, I, s1 and
A2: DataPart s1 = DataPart s2;
  set WH = while=0(a,I);
  set ST2 = StepWhile=0(a, I, s2);
  set ST1 = StepWhile=0(a, I, s1);
  defpred X[Nat] means DataPart ST1.$1 = DataPart ST2.$1;
A3: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k;
    set ST1kI = ST1.k +* (I +* SAt);
    set ST2kI = ST2.k +* (I +* SAt);
    assume
A4: DataPart ST1.k = DataPart ST2.k;
    then
A5: ST1.k.a = ST2.k.a by SCMFSA6A:38;
    per cases;
    suppose
A6:   ST1.k.a <> 0;
      hence DataPart ST1.(k+1) = DataPart ST1.k by Th24
        .= DataPart ST2.(k+1) by A4,A5,A6,Th24;
    end;
    suppose
A7:   ST1.k.a = 0;
      then
A8:   I is_closed_on ST1.k by A1,Def1;
A9:   I is_halting_on ST1.k by A1,A7,Def1;
      then
A10:  I is_closed_on ST2.k & I is_halting_on ST2.k by A4,A8,SCMFSA8B:8;
A11:  DataPart ST1.(k+1) = DataPart Comput(ProgramPart((ST1.k +* (WH +* SAt))),
(ST1.k +* (WH +* SAt)), (
      LifeSpan(ProgramPart(ST1kI),ST1kI) + 3)) by SCMFSA_9:def 4
        .= DataPart Comput(ProgramPart((ST1kI)),(ST1kI),LifeSpan(ProgramPart(
ST1kI),ST1kI)) by A7,A8,A9,Th23;
A12:  DataPart ST2.(k+1) = DataPart Comput(ProgramPart((ST2.k +* (WH +* SAt))),
(ST2.k +* (WH +* SAt)), (
      LifeSpan(ProgramPart(ST2kI),ST2kI) + 3)) by SCMFSA_9:def 4
        .= DataPart Comput(ProgramPart((ST2kI)),(ST2kI),LifeSpan(ProgramPart(
ST2kI),ST2kI)) by A5,A7,A10,Th23;
A13:  I +* SAt c= ST1kI & I +* SAt c= ST2kI by FUNCT_4:26;
A14:  DataPart ST1.k = DataPart ST1kI by SCMFSA8A:11;
      then
A15:  I is_closed_on (ST1kI) by A8,SCMFSA8B:6;
A16:  DataPart ST1kI = DataPart ST1.k by SCMFSA8A:11
        .= DataPart ST2kI by A4,SCMFSA8A:11;
      I is_halting_on ST1kI by A8,A9,A14,SCMFSA8B:8;
      then (LifeSpan(ProgramPart(ST1kI),ST1kI)) = (LifeSpan(ProgramPart(ST2kI),
ST2kI)) by A8,A16,A13,A14,SCMFSA8B:6,SCMFSA8C:44;
      hence thesis by A11,A12,A16,A13,A15,SCMFSA8C:43;
    end;
  end;
  DataPart ST1.0 = DataPart s1 by SCMFSA_9:def 4
    .= DataPart ST2.0 by A2,SCMFSA_9:def 4;
  then
A17: X[0];
  thus for k holds X[k] from NAT_1:sch 1(A17, A3);
end;

definition
  let s be State of SCM+FSA, a be read-write Int-Location, I be Program of
  SCM+FSA;
  assume that
A1: ProperBodyWhile=0 a, I, s or I is parahalting and
A2: WithVariantWhile=0 a, I, s;
  func ExitsAtWhile=0(a, I, s) -> Element of NAT means
  :Def3:
  ex k being
  Element of NAT st it = k & (StepWhile=0(a, I, s).k).a <> 0 & (for i being
  Element of NAT st (StepWhile=0(a, I, s).i).a <> 0 holds k <= i) & DataPart
  Comput(ProgramPart((s +* (while=0(a, I) +* (Start-At( 0,SCM+FSA))))),(s +* (
while=0(a, I) +* (Start-At( 0,SCM+FSA)))),
  (LifeSpan(ProgramPart(s +* (
  while=0(a, I) +* (Start-At( 0,SCM+FSA)))),s +* (
  while=0(a, I) +* (Start-At( 0,SCM+FSA)))))) =
  DataPart StepWhile=0(a, I, s).k;
  existence
  proof
    set S = s +* (while=0(a, I) +* SAt);
    set SW = StepWhile=0(a, I, s);
    defpred X[Nat] means SW.$1.a <> 0;
A3: while=0(a, I) +* SAt c= S by FUNCT_4:26;
    consider f being Function of product the Object-Kind of SCM+FSA, NAT such
    that
A4: for k being Element of NAT holds f.(SW.(k+1))<f.(SW.(k)) or X[k]
    by A2,Def2;
    deffunc U(Nat) = f.(SW.$1);
A5: for k being Element of NAT holds U(k+1)<U(k) or X[k] by A4;
    consider m such that
A6: X[m] and
A7: for n st X[n] holds m <= n from NAT_1:sch 18(A5);
    take m, m;
    thus m = m;
    thus SW.m.a <> 0 by A6;
    thus for n st SW.n.a <> 0 holds m <= n by A7;
    defpred P[Nat] means $1+1 <= m implies ex k st StepWhile=0(a,I,
    s).($1+1)=Comput(ProgramPart(S),S,k);
A8: ProperBodyWhile=0 a, I, s by A1,Th19;
A9: now
      let k be Element of NAT;
      assume
A10:  P[k];
      now
        set sk1=StepWhile=0(a,I,s).(k+1);
        set sk=StepWhile=0(a,I,s).k;
        assume
A11:    (k+1)+ 1 <= m;
        k + 0 < k+ (1+ 1) by XREAL_1:8;
        then k < m by A11,XXREAL_0:2;
        then
A12:    sk.a = 0 by A7;
        (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
        then consider n being Element of NAT such that
A13:    sk1 = Comput(ProgramPart(S),S,n) by A10,A11,XXREAL_0:2;
A14:    sk1 = Comput(ProgramPart((sk +* (while=0(a,I)+* SAt))),(sk +* (while=0(
a,I)+* SAt)), (LifeSpan(ProgramPart(sk +*
        (I +* SAt)),sk +*
        (I +* SAt)) + 3)) by SCMFSA_9:def 4;
        take m=n +(LifeSpan(ProgramPart(sk1 +* (I +* SAt)),sk1 +* (I +* SAt)) +
3);
        I is_closed_on sk & I is_halting_on sk by A8,A12,Def1;
        then IC sk1 = 0 by A14,A12,SCMFSA_9:22;
        hence StepWhile=0(a,I,s).((k+1)+1)=Comput(ProgramPart(S),S,m) by A13,
SCMFSA_9:31;
      end;
      hence P[k+1];
    end;
A15: IC SCM+FSA in dom (while=0(a,I) +* SAt ) by COMPOS_1:141;
A16: P[0]
    proof
      assume 0+1 <= m;
      take n=(LifeSpan(ProgramPart(s+* (I +* SAt)),s+* (I +* SAt)) + 3);
      thus thesis by SCMFSA_9:30;
    end;
A17: for k being Element of NAT holds P[k] from NAT_1:sch 1(A16,A9);
    per cases;
    suppose
A18:  m = 0;
A19:  DataPart S = DataPart s by SCMFSA8A:11
        .= DataPart SW.m by A18,SCMFSA_9:def 4;
      then S.a = SW.m.a by SCMFSA6A:38;
      hence thesis by A6,A3,A19,Th22;
    end;
    suppose
A20:  m <> 0;
      set sm = StepWhile=0(a,I,s).m;
      set sm1 = sm +* (while=0(a,I)+* SAt);
      consider i being Nat such that
A21:  m=i+1 by A20,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      set si = StepWhile=0(a,I,s).i;
A22:  sm = Comput(ProgramPart((si +* (while=0(a,I)+* SAt))),(si +* (while=0(a,I
)+* SAt)), (LifeSpan(ProgramPart(si +* (I
      +* SAt)),si +* (I
      +* SAt)) + 3)) by A21,SCMFSA_9:def 4;
      m=i+1 by A21;
      then consider n being Element of NAT such that
A23:  sm = Comput(ProgramPart(S),S,n) by A17;
      i < m by A21,NAT_1:13;
      then
A24:  si.a = 0 by A7;
      then I is_closed_on si & I is_halting_on si by A8,Def1;
      then
A25:  IC sm = 0 by A22,A24,SCMFSA_9:22;
A26:  IC sm1 = IC(while=0(a,I) +* SAt) by A15,FUNCT_4:14
        .= IC sm by A25,COMPOS_1:142;
      ProgramPart sm = ProgramPart S by A23,AMI_1:123;
      then DataPart sm1 = DataPart sm & ProgramPart sm1 = ProgramPart sm
         by FUNCT_4:100,SCMFSA8A:11;
      then
A27:  sm1 = sm by A26,SCMFSA_9:29;
      while=0(a,I) is_halting_on sm by A6,SCMFSA_9:18;
      then ProgramPart sm1 halts_on sm1 by SCMFSA7B:def 8;
      then consider j being Element of NAT such that
A28:  CurInstr(ProgramPart sm,Comput(ProgramPart(sm),
sm,j)) = halt SCM+FSA
by A27,EXTPRO_1:30;
x: Comput(ProgramPart(S),S,n+j)
 = Comput(ProgramPart(S),Comput(ProgramPart(S),S,n),j) by EXTPRO_1:5;
T: ProgramPart S = ProgramPart sm
by A23,AMI_1:123;
      CurInstr(ProgramPart S,Comput(ProgramPart(S),S
,n+j))
       = halt SCM+FSA by A23,A28,x,T;
      then
A29:  Comput(ProgramPart(S),S,LifeSpan(ProgramPart(S),S)) = Comput(ProgramPart(
S),S,n+j) by EXTPRO_1:24
        .= Comput(ProgramPart(S),sm,j) by A23,EXTPRO_1:5
        .= Comput(ProgramPart(sm),sm,LifeSpan(ProgramPart(sm),sm)) by A28,T,
EXTPRO_1:24;
      while=0(a,I)+* SAt c= sm by A27,FUNCT_4:26;
      hence thesis by A6,A29,Th22;
    end;
  end;
  uniqueness
  proof
    let it1, it2 be Element of NAT;
    given k1 being Element of NAT such that
A30: it1 = k1 and
A31: (StepWhile=0(a, I, s).k1).a <> 0 & for i being Element of NAT st
    ( StepWhile=0(a, I, s).i).a <> 0 holds k1 <= i and
    DataPart(Comput(ProgramPart((s +* (while=0(a, I) +* SAt))),(s +* (while=0(a
, I) +* SAt)), (LifeSpan(ProgramPart(s +* (
    while=0(a, I) +* SAt)),s +* (
    while=0(a, I) +* SAt))))) = DataPart StepWhile=0(a, I, s).k1;
    given k2 being Element of NAT such that
A32: it2 = k2 and
A33: (StepWhile=0(a, I, s).k2).a <> 0 & for i being Element of NAT st
    ( StepWhile=0(a, I, s).i).a <> 0 holds k2 <= i and
    DataPart(Comput(ProgramPart((s +* (while=0(a, I) +* SAt))),(s +* (while=0(a
, I) +* SAt)), (LifeSpan(ProgramPart(s +* (
    while=0(a, I) +* SAt)),s +* (
    while=0(a, I) +* SAt))))) = DataPart StepWhile=0(a, I, s).k2;
    k1 <= k2 & k2 <= k1 by A31,A33;
    hence thesis by A30,A32,XXREAL_0:1;
  end;
end;

theorem :: IE_while_ne0:
  s.intloc 0 = 1 & s.a <> 0 implies DataPart IExec(while=0(a, I), s) =
  DataPart s
proof
  set Ins = NAT;
  assume that
A1: s.intloc 0 = 1 and
A2: s.a <> 0;
  set WH = while=0(a, I);
  set Is = Initialized s;
  set Ids = s +* Initialized WH;
A3: Ids = Is +*(WH +* SAt) by SCMFSA8A:13;
  then
A4: WH +* SAt c= Ids by FUNCT_4:26;
  Is.a = s.a by SCMFSA6C:3;
  then WH is_halting_on Is by A2,SCMFSA_9:18;
  then
A5: ProgramPart Ids halts_on Ids by A3,SCMFSA7B:def 8;
  DataPart Is = DataPart Ids by SCMFSA8B:5;
  then
A6: Ids.a = Is.a by SCMFSA6A:38
    .= s.a by SCMFSA6C:3;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A7: dom ProgramPart s misses D by COMPOS_1:34;
  thus DataPart IExec(WH, s) = DataPart(Result(ProgramPart(s+*Initialized WH),s
+*Initialized WH) +* s | Ins)
  by SCMFSA6B:def 1
    .= DataPart(Result(ProgramPart(s+*Initialized WH),s+*Initialized WH)) by A7
,FUNCT_4:76,SCMFSA_2:127
    .= DataPart Comput(ProgramPart(Ids),Ids,LifeSpan(ProgramPart(Ids),Ids)) by
A5,EXTPRO_1:23
    .= DataPart Ids by A2,A6,A4,Th22
    .= DataPart Initialized s by SCMFSA8B:5
    .= DataPart s by A1,SCMFSA8C:27;
end;

theorem :: IE_while_eq0:
  (ProperBodyWhile=0 a, I, Initialized s or I is parahalting) &
WithVariantWhile=0 a, I, Initialized s implies DataPart IExec(while=0(a, I), s)
  = DataPart
   StepWhile=0(a, I, Initialized s).ExitsAtWhile=0(a, I, Initialized s)
proof
  set Ins = NAT;
  set WH = while=0(a, I);
  set Ids = s +* Initialized WH;
  set Is = Initialized s;
A1: Ids = Is +*(WH +* SAt) by SCMFSA8A:13;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A2: dom ProgramPart s misses D by COMPOS_1:34;
  assume
A3: ( ProperBodyWhile=0 a, I, Initialized s or I is parahalting)&
  WithVariantWhile=0 a, I, Initialized s;
  then
A4: ex k being Element of NAT st ExitsAtWhile=0(a, I, Is) = k & (StepWhile=0(
a, I, Is).k).a <> 0 &( for i being Element of NAT st ( StepWhile=0(a, I, Is).i)
.a <> 0 holds k <= i)& DataPart(Comput(ProgramPart((Is +* ( while=0(a, I) +*
SAt))),(Is +* ( while=0(a, I) +* SAt)), (
  LifeSpan(ProgramPart(Is +* (while=0(a, I) +* SAt)),Is +* (while=0(a, I) +*
SAt))))) = DataPart StepWhile=0(a, I, Is).k
  by Def3;
  WH is_halting_on Is by A3,Th20,Th21;
  then
A5: ProgramPart Ids halts_on Ids by A1,SCMFSA7B:def 8;
  thus DataPart IExec(WH, s) = DataPart(Result(ProgramPart(s+*Initialized WH),s
+*Initialized WH) +* s | Ins)
  by SCMFSA6B:def 1
    .= DataPart(Result(ProgramPart(s+*Initialized WH),s+*Initialized WH)) by A2
,FUNCT_4:76,SCMFSA_2:127
    .= DataPart StepWhile=0(a, I, Is).ExitsAtWhile=0(a, I, Is) by A1,A5,A4,
EXTPRO_1:23;
end;

begin :: while>0, general

Lm4: for a being Int-Location, I being Program of SCM+FSA holds card I +4 in
dom if>0(a,I ';' Goto  0,Stop SCM+FSA) & if>0(a,I ';' Goto  0,Stop
SCM+FSA).(card I +4) = goto (( 0)+(card I +4))

proof
  set J = Stop SCM+FSA;
  set G = Goto  0;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' G;
  set i = a >0_goto  (card J + 3);
  set c4 = card I + 4;
  set Lc4 = c4;
  set Mi= Macro i ';' J ';' Goto  (card I1 + 1) ';' I;
x: card Stop SCM+FSA = 1 by COMPOS_1:46;
A1: card (G ';' J) = card G + card J by SCMFSA6A:61
    .= 1 + 1 by x,SCMFSA8A:29
    .= 2;

A2: if>0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' (I ';' G) ';'
  J by SCMFSA8B:def 2

    .= Mi ';' G ';' J by SCMFSA6A:67
    .= Mi ';' (G ';' J) by SCMFSA6A:67;
  then card if>0(a, I1,J) = card Mi + card (G ';' J) by SCMFSA6A:61;
  then
A3: card Mi = card if>0(a,I1,J)-card (G ';' J)
    .= card I + 6 - 2 by A1,SCMFSA_9:2
    .= c4;
  then
A4: not Lc4 in dom Mi;
  set GJ = G ';' J;
A5: InsCode goto  0 = 6 by SCMFSA_2:47;
A6: G =  0 .--> goto  0 by SCMFSA8A:def 2;
  then
A7: G. 0 = goto  0 by FUNCOP_1:87;
  dom G = { 0} by A6,FUNCOP_1:19;
  then
A8:  0 in dom G by TARSKI:def 1;
A9: dom G c= dom GJ by SCMFSA6A:56;

  then  0 + c4 in { il+c4 where il is Element of NAT: il in dom GJ} by A8
;

  then
A10:  c4 in dom Shift(GJ,c4) by VALUED_1:def 12;
  then
A11: Shift(GJ,c4)/.Lc4 = Shift(GJ,c4).( 0 +c4) by PARTFUN1:def 8
    .= GJ. 0 by A8,A9,VALUED_1:def 12
    .= goto  0 by A8,A7,A5,SCMFSA6A:54;
x: card Stop SCM+FSA = 1 by COMPOS_1:46;
  card I1 = card I + card G by SCMFSA6A:61
    .= card I +1 by SCMFSA8A:29;
  then card I1 + card J + 3 = card I +4 +1 by x;
  then c4 < card I1 + card J + 3 by NAT_1:13;
  hence
A12: Lc4 in dom if>0(a,I1,J) by SCMFSA8C:57;

A13: dom if>0(a,I1,J) = dom Directed Mi \/ dom ProgramPart Relocated(GJ, c4
  ) by A2,A3,FUNCT_4:def 1;

  then dom if>0(a,I1,J) = dom Mi \/ dom ProgramPart Relocated(GJ, c4) by
FUNCT_4:105;

  then Lc4 in dom ProgramPart Relocated(GJ, c4) by A12,A4,XBOOLE_0:def 3;

  hence if>0(a,I1,J).Lc4 = (ProgramPart Relocated(GJ,c4)).Lc4 by A12,A2,A3,A13,
FUNCT_4:def 1

    .= Reloc(ProgramPart(GJ),c4).Lc4 by COMPOS_1:116
    .= Reloc(GJ,c4).Lc4 by RELAT_1:209
    .= IncAddr( goto  0, c4 ) by A10,A11,SCMFSA_4:24
    .= goto (( 0)+c4) by SCMFSA_4:14;
end;

Lm5: for a being Int-Location, I being Program of SCM+FSA holds UsedIntLoc
if>0(a,I ';' Goto  0,Stop SCM+FSA) = UsedIntLoc (if>0(a,I ';' Goto
0,Stop SCM+FSA) +* (  (card I +4) .--> goto  0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 =  (card I + 4);
  set if0 = if>0(a,I ';' Goto  0,Stop SCM+FSA);
  set ic4 =  (card I +4) .--> goto  0;

  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedIntLoc i and
A2: UsedIntLoc if0 = Union (UIL1 * if0) by SF_MASTR:def 2;
A3: dom UIL1 = the Instructions of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,RELAT_1:def 19;
A6: dom ic4 = { (card I +4)} by FUNCOP_1:19;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
     (card I +4) in dom if0 by Lm4;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
FUNCT_4:def 1,ZFMISC_1:37;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,RELAT_1:def 19;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:46
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:46;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:12
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.(goto (( 0)+(card I +4))) by A12,Lm4
        .= UsedIntLoc goto (( 0)+(card I +4)) by A1
        .= {} by SF_MASTR:19
        .= UsedIntLoc goto  0 by SF_MASTR:19
        .= UIL1.(goto  0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:87
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:14
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
  end;

  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A14: UsedIntLoc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 2;
  for c be Element of the Instructions of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedIntLoc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:113;
  hence thesis by A2,A14,A4,FUNCT_1:9;
end;

Lm6: for a being Int-Location, I being Program of SCM+FSA holds UsedInt*Loc
if>0(a,I ';' Goto  0,Stop SCM+FSA) = UsedInt*Loc (if>0(a,I ';' Goto
 0,Stop SCM+FSA) +* (  (card I +4) .--> goto  0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 =  (card I + 4);
  set if0 = if>0(a,I ';' Goto  0,Stop SCM+FSA);
  set ic4 =  (card I +4) .--> goto  0;

  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedInt*Loc i and
A2: UsedInt*Loc if0 = Union (UIL1 * if0) by SF_MASTR:def 4;
A3: dom UIL1 = the Instructions of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,RELAT_1:def 19;
A6: dom ic4 = { (card I +4)} by FUNCOP_1:19;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
     (card I +4) in dom if0 by Lm4;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
FUNCT_4:def 1,ZFMISC_1:37;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,RELAT_1:def 19;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:46
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:46;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:12
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.(goto (( 0)+(card I +4))) by A12,Lm4
        .= UsedInt*Loc goto (( 0)+(card I +4)) by A1
        .= {} by SF_MASTR:36
        .= UsedInt*Loc goto  0 by SF_MASTR:36
        .= UIL1.(goto  0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:87
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:14
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
  end;

  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A14: UsedInt*Loc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 4;
  for c be Element of the Instructions of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedInt*Loc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:113;
  hence thesis by A2,A14,A4,FUNCT_1:9;
end;

theorem :: whileUsed:
  UsedIntLoc while>0(b, I) = {b} \/ UsedIntLoc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ';' Goto  0;
  while>0(a, I) = if>0(a, IG, J) +* (  (card I +4) .--> goto
  0 ) by SCMFSA_9:def 2;
  hence UsedIntLoc while>0(a, I) = (UsedIntLoc if>0(a, IG, J)) by Lm5
    .= {a} \/ UsedIntLoc IG \/ UsedIntLoc J by Th15
    .= {a} \/ (UsedIntLoc I \/ UsedIntLoc Goto  0) \/ UsedIntLoc J by
SF_MASTR:31
    .= {a} \/ (UsedIntLoc I \/ {}) \/ UsedIntLoc J by Th11
    .= {a} \/ UsedIntLoc I by Th9;
end;

theorem :: whileUsedF:
  UsedInt*Loc while>0(b, I) = UsedInt*Loc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ';' Goto  0;
  while>0(a, I) = if>0(a, IG, J) +* (  (card I +4) .--> goto
  0 ) by SCMFSA_9:def 2;
  hence UsedInt*Loc while>0(a, I) = (UsedInt*Loc if>0(a, IG, J)) by Lm6
    .= UsedInt*Loc IG \/ UsedInt*Loc J by Th16
    .= (UsedInt*Loc I \/ UsedInt*Loc Goto  0) \/ UsedInt*Loc J by SF_MASTR:47
    .= UsedInt*Loc I \/ {} by Th10,Th12
    .= UsedInt*Loc I;
end;

definition
  let s be State of SCM+FSA, a be read-write Int-Location, I be Program of
  SCM+FSA;
  pred ProperBodyWhile>0 a, I, s means
  :Def4:
  for k being Element of NAT st
  StepWhile>0(a,I,s).k.a > 0 holds I is_closed_on StepWhile>0(a,I,s).k & I
  is_halting_on StepWhile>0(a,I,s).k;
  pred WithVariantWhile>0 a, I, s means
  :Def5:
  ex f being Function of product
  the Object-Kind of SCM+FSA, NAT st for k being Element of NAT holds ( f.(
StepWhile>0(a,I,s).(k+1)) < f.(StepWhile>0(a,I,s).k) or StepWhile>0(a,I,s).k.a
  <= 0 );
end;

theorem Th32: :: ParaProper:
  for I being parahalting Program of SCM+FSA holds
  ProperBodyWhile>0 a, I, s
proof
  let I be parahalting Program of SCM+FSA;
  let k be Element of NAT such that
  StepWhile>0(a,I,s).k.a > 0;
  thus I is_closed_on StepWhile>0(a,I,s).k by SCMFSA7B:24;
  thus thesis by SCMFSA7B:25;
end;

theorem Th33: :: SCMFSA_9:42, corrected
  ProperBodyWhile>0 a, I, s & WithVariantWhile>0 a, I, s implies
  while>0(a,I) is_halting_on s & while>0(a,I) is_closed_on s
proof
  assume
A1: for k being Element of NAT st StepWhile>0(a,I,s).k.a > 0 holds I
  is_closed_on StepWhile>0(a,I,s).k & I is_halting_on StepWhile>0(a,I,s).k;
  set s1 = s +* (while>0(a,I) +* Start-At( 0,SCM+FSA));
  defpred S[Nat] means StepWhile>0(a,I,s).$1.a <= 0;
  given f being Function of product the Object-Kind of SCM+FSA,NAT such that
A2: for k being Element of NAT holds (f.(StepWhile>0(a,I,s).(k+1)) < f.(
  StepWhile>0(a,I,s).k) or (StepWhile>0(a,I,s).k).a <= 0 );
  deffunc F(Nat) = f.(StepWhile>0(a,I,s).$1);
A3: for k holds ( F(k+1) < F(k) or S[k] ) by A2;
  consider m being Element of NAT such that
A4: S[m] and
A5: for n st S[n] holds m <= n from NAT_1:sch 18(A3);
  defpred P[Nat] means $1+1 <= m implies ex k st StepWhile>0(a,I,s)
  .($1+1)=Comput(ProgramPart(s1),s1,k);
A6: now
    let k be Element of NAT;
    assume
A7: P[k];
    now
      set sk1=StepWhile>0(a,I,s).(k+1);
      set sk=StepWhile>0(a,I,s).k;
      assume
A8:   (k+1)+ 1 <= m;
      k + 0 < k+ (1+ 1) by XREAL_1:8;
      then k < m by A8,XXREAL_0:2;
      then
A9:   sk.a > 0 by A5;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
      then consider n being Element of NAT such that
A10:  sk1 = Comput(ProgramPart(s1),s1,n) by A7,A8,XXREAL_0:2;
A11:  sk1 = Comput(ProgramPart((sk +* (while>0(a,I)+* SAt))),(sk +* (while>0(a,
I)+* SAt)), (LifeSpan(ProgramPart(sk +* (I
      +* SAt)),sk +* (I
      +* SAt)) + 3)) by SCMFSA_9:def 5;
      take m=n +(LifeSpan(ProgramPart(sk1 +* (I +* SAt)),sk1 +* (I +* SAt)) + 3
);
      I is_closed_on sk & I is_halting_on sk by A1,A9;
      then IC sk1 = 0 by A11,A9,SCMFSA_9:47;
      hence StepWhile>0(a,I,s).((k+1)+1)=Comput(ProgramPart(s1),s1,m) by A10,
SCMFSA_9:52;
    end;
    hence P[k+1];
  end;
A12: IC SCM+FSA in dom (while>0(a,I) +* SAt ) by COMPOS_1:141;
A13: P[0]
  proof
    assume 0+1 <= m;
    take n=(LifeSpan(ProgramPart(s+* (I +* SAt)),s+* (I +* SAt)) + 3);
    thus thesis by SCMFSA_9:51;
  end;
A14: for k being Element of NAT holds P[k] from NAT_1:sch 1(A13,A6);
  now
    per cases;
    suppose
      m=0;
      then s.a <= 0 by A4,SCMFSA_9:def 5;
      hence thesis by SCMFSA_9:43;
    end;
    suppose
A15:  m<>0;
      set p=(LifeSpan(ProgramPart(s+* (I +* SAt)),s+* (I +* SAt)) + 3);
      set sm=StepWhile>0(a,I,s).m;
      set sm1=sm +* (while>0(a,I)+* SAt);
      consider i being Nat such that
A16:  m=i+1 by A15,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      set si=StepWhile>0(a,I,s).i;
A17:  sm= Comput(ProgramPart((si +* (while>0(a,I)+* SAt))),(si +* (while>0(a,I)
+* SAt)), (LifeSpan(ProgramPart(si +* (I
      +* SAt)),si +* (I
      +* SAt)) + 3)) by A16,SCMFSA_9:def 5;
      m=i+1 by A16;
      then consider n being Element of NAT such that
A18:  sm = Comput(ProgramPart(s1),s1,n) by A14;
      i < m by A16,NAT_1:13;
      then
A19:  si.a > 0 by A5;
      then I is_closed_on si & I is_halting_on si by A1;
      then
A20:  IC sm = 0 by A17,A19,SCMFSA_9:47;
      ProgramPart sm =ProgramPart s1 by A18,AMI_1:123;
      then
A21:  DataPart sm1 = DataPart sm & ProgramPart sm1 = ProgramPart sm
    by FUNCT_4:100,SCMFSA8A:11;
      IC sm1 = IC(while>0(a,I) +* SAt) by A12,FUNCT_4:14
        .= IC sm by A20,COMPOS_1:142;
      then
A22:  sm1=sm by A21,SCMFSA_9:29;
      while>0(a,I) is_halting_on sm by A4,SCMFSA_9:43;
      then ProgramPart sm1 halts_on sm1 by SCMFSA7B:def 8;
      then consider j being Element of NAT such that
A23:  CurInstr(ProgramPart sm,Comput(ProgramPart(sm),
sm,j)) = halt SCM+FSA
by A22,EXTPRO_1:30;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),
s1,n)
by AMI_1:123;
x: Comput(ProgramPart(s1),s1,n+j)
 = Comput(ProgramPart(s1),Comput(ProgramPart(s1),s1,n),j) by EXTPRO_1:5;
      CurInstr(ProgramPart s1,Comput(ProgramPart(s1
),s1,n+j))
       = halt SCM+FSA by A18,A23,x,T;
      then ProgramPart s1 halts_on s1 by EXTPRO_1:30;
      hence while>0(a,I) is_halting_on s by SCMFSA7B:def 8;
      now
        let q be Element of NAT;
        per cases;
        suppose
A24:      q <= p;
A25:      StepWhile>0(a,I,s).0=s by SCMFSA_9:def 5;
          then
A26:      s.a > 0 by A5,A15;
          then I is_closed_on s & I is_halting_on s by A1,A25;
          hence IC Comput(ProgramPart(s1),s1,q) in dom while>0(a,I) by A24,A26,
SCMFSA_9:47
;
        end;
        suppose
A27:      q > p;
A28:      now
            take k=p;
            thus StepWhile>0(a,I,s).1=Comput(ProgramPart(s1),s1,k) & k <= q by
A27,SCMFSA_9:51;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 & (ex k st StepWhile>0(a,I,s).$1
          = Comput(ProgramPart(s1),s1,k) & k <= q);
A29:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A15,XREAL_1:8;
          then 1 <= m by NAT_1:13;
          then
A30:      ex k be Nat st P2[k] by A28;
          consider t being Nat such that
A31:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A29, A30);
          reconsider t as Element of NAT by ORDINAL1:def 13;
          now
            per cases;
            suppose
              t=m;
              then consider r being Element of NAT such that
A32:          sm=Comput(ProgramPart(s1),s1,r) and
A33:          r <= q by A31;
              consider x being Nat such that
A34:          q = r+x by A33,NAT_1:10;
A35:          while>0(a,I) is_closed_on sm by A4,SCMFSA_9:43;
              reconsider x as Element of NAT by ORDINAL1:def 13;
T: ProgramPart s1 = ProgramPart sm1
by A22,A32,AMI_1:123;
              Comput(ProgramPart(s1),s1,q) = Comput(ProgramPart(s1),sm1,x) by
A22,A32,A34,EXTPRO_1:5;
              hence IC Comput(ProgramPart(s1),s1,q) in dom while>0(a,I) by A35
,T,SCMFSA7B:def 7;
            end;
            suppose
A36:          t<>m;
              set Dt=StepWhile>0(a,I,s).t;
              consider y being Nat such that
A37:          t=y+1 by A31,NAT_1:6;
              reconsider y as Element of NAT by ORDINAL1:def 13;
              set Dy=StepWhile>0(a,I,s).y;
A38:          Dt= Comput(ProgramPart((Dy +* (while>0(a,I)+* SAt))),(Dy +* (
while>0(a,I)+* SAt)), (LifeSpan(ProgramPart(Dy
              +* (I +* SAt)),Dy
              +* (I +* SAt)) + 3)) by A37,SCMFSA_9:def 5;
              y+ 0 < t by A37,XREAL_1:8;
              then y < m by A31,XXREAL_0:2;
              then
A39:          Dy.a > 0 by A5;
              then I is_closed_on Dy & I is_halting_on Dy by A1;
              then
A40:          IC Dt = 0 by A38,A39,SCMFSA_9:47;
              consider z being Element of NAT such that
A41:          StepWhile>0(a,I,s).t=Comput(ProgramPart(s1),s1,z) and
A42:          z <= q by A31;
              consider w being Nat such that
A43:          q = z+w by A42,NAT_1:10;
              reconsider w as Element of NAT by ORDINAL1:def 13;
X: Dt = Dt +* (while>0(a,I)+* SAt) by A41,A40,SCMFSA_9:52;
T: ProgramPart s1 = ProgramPart Dt
by A41,AMI_1:123;
A44:          Comput(ProgramPart(s1),s1,q) = Comput(ProgramPart(s1),Dt,w) by
A41,A43,EXTPRO_1:5
                .= Comput(ProgramPart((Dt +* (while>0(a,I)+* SAt))),(Dt +* (
while>0(a,I)+* SAt)),w) by X,T;
              set z2=z +(LifeSpan(ProgramPart(Dt +* (I +* SAt)),Dt +* (I +* SAt
)) + 3);
A45:          t < m by A31,A36,XXREAL_0:1;
              now
                assume
A46:            z2 <= q;
A47:            now
                  take k=z2;
                  thus StepWhile>0(a,I,s).(t+1)=Comput(ProgramPart(s1),s1,k) &
k <= q by A41,A40,A46,SCMFSA_9:52;
                end;
                t+1 <= m by A45,NAT_1:13;
                hence contradiction by A31,A47,XREAL_1:31;
              end;
              then
A48:          w < LifeSpan(ProgramPart(Dt +* (I +* SAt)),Dt +* (I +* SAt)) + 3
by A43,XREAL_1:8;
A49:          Dt.a > 0 by A5,A45;
              then I is_closed_on Dt & I is_halting_on Dt by A1;
              hence IC Comput(ProgramPart(s1),s1,q) in dom while>0(a,I) by A48
,A44,A49,SCMFSA_9:47;
            end;
          end;
          hence IC Comput(ProgramPart(s1),s1,q) in dom while>0(a,I);
        end;
      end;
      hence while>0(a,I) is_closed_on s by SCMFSA7B:def 7;
    end;
  end;
  hence thesis;
end;

theorem Th34: :: SCMFSA_9:43, corrected
  for I being parahalting Program of SCM+FSA st WithVariantWhile>0
  a, I, s holds while>0(a,I) is_halting_on s & while>0(a,I) is_closed_on s
proof
  let I be parahalting Program of SCM+FSA such that
A1: WithVariantWhile>0 a, I, s;
  ProperBodyWhile>0 a, I, s
  proof
    let k be Element of NAT;
    assume StepWhile>0(a,I,s).k.a > 0;
    thus thesis by SCMFSA7B:24,25;
  end;
  hence thesis by A1,Th33;
end;

theorem Th35: :: based on SCMFSA_9:32
  while>0(a, I) +* (Start-At( 0,SCM+FSA)) c= s & s.a <= 0 implies
  LifeSpan(ProgramPart(s),s) = 4 & for k being Element of NAT holds DataPart
Comput(ProgramPart
(s),s,k) =
  DataPart s
proof
  assume that
A1: while>0(a, I) +* SAt c= s and
A2: s.a <= 0;
  set i = a >0_goto  4;
  set s1 = s +* (while>0(a,I) +* Start-At( 0,SCM+FSA));
A3: IC SCM+FSA in dom (while>0(a,I) +* Start-At( 0,SCM+FSA))
by COMPOS_1:141;
  while>0(a,I) c= while>0(a,I) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A4: dom while>0(a,I) c= dom (while>0(a,I) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
  not a in dom (while>0(a,I) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  then
A5: s1.a = s.a by FUNCT_4:12;
A6:  1 in dom while>0(a,I) by SCMFSA_9:10;
A7: Comput(ProgramPart(s1),s1,1). 1 = s1. 1 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)). 1
    by A4,A6,FUNCT_4:14
    .= while>0(a,I). 1 by A6,SCMFSA6B:7
    .= goto  2 by SCMFSA_9:11;
A8: IC s1 = IC(while>0(a,I) +* Start-At( 0,SCM+FSA)) by A3,FUNCT_4:14
    .=  0 by COMPOS_1:142;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by COMPOS_1:38;
A9:  0 in dom while>0(a,I) by SCMFSA_9:10;
  then s1. 0 = (while>0(a,I) +* Start-At( 0,SCM+FSA)). 0
  by A4,FUNCT_4:14
    .= while>0(a,I). 0 by A9,SCMFSA6B:7
    .= i by SCMFSA_9:11;
  then
A10: CurInstr(ProgramPart s1,s1) = i by A8,Y;
A11: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by EXTPRO_1:4
    .= Following(ProgramPart s1,s1) by EXTPRO_1:3
    .= Exec(i,s1) by A10;
  set loc5=  (card I +5);
  set s5 = Comput(ProgramPart(s1),s1,4);
  set s4 = Comput(ProgramPart(s1),s1,3);
  set s3 = Comput(ProgramPart(s1),s1,2);
  set s2 = Comput(ProgramPart(s1),s1,1);
A12:  2 in dom while>0(a,I) by SCMFSA_9:37;
A13: s3. 2 = s1. 2 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)). 2
    by A4,A12,FUNCT_4:14
    .= while>0(a,I). 2 by A12,SCMFSA6B:7
    .= goto  3 by SCMFSA_9:41;
A14:  3 in dom while>0(a,I) by SCMFSA_9:37;
A15: s4. 3 = s1. 3 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)). 3
    by A4,A14,FUNCT_4:14
    .= while>0(a,I). 3 by A14,SCMFSA6B:7
    .= goto loc5 by SCMFSA_9:40;
A16: loc5 in dom while>0(a,I) by SCMFSA_9:38;
A17: s5.loc5 = s1.loc5 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)).loc5 by A4,A16,FUNCT_4:14
    .= while>0(a,I).loc5 by A16,SCMFSA6B:7
    .= halt SCM+FSA by SCMFSA_9:39;
A18: ( for c being Int-Location holds Exec(goto loc5, s4).c = s4.c)& for f
  being FinSeq-Location holds Exec(goto loc5, s4).f = s4.f by SCMFSA_2:95;
A19: ( for c being Int-Location holds Exec(goto  2, s2).c = s2.c)& for
f being FinSeq-Location holds Exec(goto  2, s2).f = s2.f by SCMFSA_2:95;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,1))/.IC Comput(ProgramPart(s1),s1,1)
 = Comput(ProgramPart(s1),s1,1).IC Comput(ProgramPart(s1),s1,1) by COMPOS_1:38;
  IC Comput(ProgramPart(s1),s1,1) = Comput(ProgramPart(s1),s1,1).IC SCM+FSA
    .= succ  0 by A2,A8,A11,A5,SCMFSA_2:97
    .=  (0 + 1);
  then
A20: CurInstr(ProgramPart Comput(ProgramPart(s1),s1,1),Comput(ProgramPart(s1),
s1,1))
 = goto  2 by A7,Y;
T: ProgramPart s1 = ProgramPart s2
by AMI_1:123;
A21: Comput(ProgramPart(s1),s1,1+1) = Following(ProgramPart s1,s2) by
EXTPRO_1:4
    .= Exec(goto  2,s2) by A20,T;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
  IC s3 = s3.IC SCM+FSA
    .=  2 by A21,SCMFSA_2:95;
  then
A22: CurInstr(ProgramPart s3,s3) = goto  3 by A13,Y;
T: ProgramPart s1 = ProgramPart s3
by AMI_1:123;
A23: Comput(ProgramPart(s1),s1,2+1) = Following(ProgramPart s1,s3) by
EXTPRO_1:4
    .= Exec(goto  3,s3) by A22,T;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
  IC s4 = s4.IC SCM+FSA
    .=  3 by A23,SCMFSA_2:95;
  then
A24: CurInstr(ProgramPart s4,s4) = goto loc5 by A15,Y;
T: ProgramPart s1 = ProgramPart s4
by AMI_1:123;
A25: Comput(ProgramPart(s1),s1,3+1) = Following(ProgramPart s1,s4) by
EXTPRO_1:4
    .= Exec(goto loc5,s4) by A24,T;
Y:  (ProgramPart s5)/.IC s5
 = s5.IC s5 by COMPOS_1:38;
TX: ProgramPart s1 = ProgramPart s5
by AMI_1:123;
  IC s5 = s5.IC SCM+FSA
    .= loc5 by A25,SCMFSA_2:95;
  then
A26: CurInstr(ProgramPart s1,s5) = halt SCM+FSA by A17,Y,TX;
  then
A27: ProgramPart s1 halts_on s1 by EXTPRO_1:30;
A28: s = s1 by A1,FUNCT_4:79;
  now
    let k;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k)
by AMI_1:123;
    assume
A29: CurInstr(ProgramPart s,Comput(ProgramPart(s),s,k)
) = halt SCM+FSA;
    assume 4 > k;
    then 3+1 > k;
    then
A30: k <= 3 by NAT_1:13;
    per cases by A30,NAT_1:28;
    suppose
      k = 0;
      then Comput(ProgramPart(s),s,k) = s by EXTPRO_1:3;
      hence contradiction by A28,A10,A29,SCMFSA_2:49;
    end;
    suppose
      k = 1;
      hence contradiction by A28,A20,A29,TX,SCMFSA_2:47;
    end;
    suppose
      k = 2;
      hence contradiction by A28,A22,A29,TX,SCMFSA_2:47;
    end;
    suppose
      k = 3;
      hence contradiction by A28,A24,A29,TX,SCMFSA_2:47;
    end;
  end;
  hence
A31: LifeSpan(ProgramPart(s),s) = 4 by A28,A26,A27,EXTPRO_1:def 14;
A32: ( for c being Int-Location holds Exec(i, s1).c = s1.c)& for f being
  FinSeq-Location holds Exec(i, s1).f = s1.f by SCMFSA_2:97;
  then
A33: DataPart Comput(ProgramPart(s),s,1) = DataPart s by A28,A11,SCMFSA6A:38;
  then
A34: DataPart Comput(ProgramPart(s),s,2) = DataPart s by A28,A21,A19,
SCMFSA6A:38;
A35: ( for c being Int-Location holds Exec(goto  3, s3).c = s3.c)& for
f being FinSeq-Location holds Exec(goto  3, s3).f = s3.f by SCMFSA_2:95;
  then DataPart Comput(ProgramPart(s),s,3) = DataPart s by A28,A23,A34,
SCMFSA6A:38;
  then
A36: DataPart Comput(ProgramPart(s),s,4) = DataPart s by A28,A25,A18,
SCMFSA6A:38;
  let k be Element of NAT;
  k <= 3 or 3 < k;
  then
A37: k = 0 or k = 1 or k = 2 or k = 3 or 3+1 <= k by NAT_1:13,28;
  per cases by A37;
  suppose
    k = 0;
    hence thesis by EXTPRO_1:3;
  end;
  suppose
    k = 1;
    hence thesis by A28,A11,A32,SCMFSA6A:38;
  end;
  suppose
    k = 2;
    hence thesis by A28,A21,A19,A33,SCMFSA6A:38;
  end;
  suppose
    k = 3;
    hence thesis by A28,A23,A35,A34,SCMFSA6A:38;
  end;
  suppose
    4 <= k;
    then CurInstr(ProgramPart s,Comput(ProgramPart(s),s,k))
     = halt SCM+FSA by A28,A27,A31,SCMFSA8A:4;
    hence thesis by A31,A36,EXTPRO_1:24;
  end;
end;

theorem Th36: :: based on SCMFSA_9:36
  I is_closed_on s & I is_halting_on s & s.a > 0 implies DataPart
  Comput(ProgramPart((s +* (while>0(a,I) +* Start-At( 0,SCM+FSA)))),(s +* (
while>0(a,I) +* Start-At( 0,SCM+FSA))),
  (LifeSpan(ProgramPart(s +* (I +*
Start-At( 0,SCM+FSA))),s +* (I +*
Start-At( 0,SCM+FSA))) + 3)) =
DataPart Comput(ProgramPart((s +* (I +* Start-At( 0,SCM+FSA))
  )),(s +* (I +* Start-At( 0,SCM+FSA))
  ), (LifeSpan(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +*
Start-At( 0,SCM+FSA)))))
proof
  assume that
A1: I is_closed_on s & I is_halting_on s and
A2: s.a > 0;
  set sI = s +* (I +* Start-At( 0,SCM+FSA));
  set s1 = s +* (while>0(a,I) +* Start-At( 0,SCM+FSA));
  defpred P[Nat] means $1 <= LifeSpan(ProgramPart(sI),sI) implies IC Comput(
ProgramPart(s1),s1,
  1+$1) = IC Comput(ProgramPart(sI),sI,$1) + 4 & DataPart Comput(ProgramPart(s1
),s1,1+$1) = DataPart
  Comput(ProgramPart(sI),sI,$1);
A3: now
    let k be Element of NAT;
    assume
A4: P[k];
    now
A5:   k + 0 < k + 1 by XREAL_1:8;
      assume k + 1 <= LifeSpan(ProgramPart(sI),sI);
      then k < LifeSpan(ProgramPart(sI),sI) by A5,XXREAL_0:2;
      hence IC Comput(ProgramPart(s1),s1,1+k+1) = IC Comput(ProgramPart(sI),sI,
k+1) + 4 & DataPart
Comput(ProgramPart(s1),s1,1+k+1) = DataPart Comput(ProgramPart(sI),sI,k+1) by
A1,A4,SCMFSA_9:44;
    end;
    hence P[k + 1];
  end;
  set i = a >0_goto  4;
  set s2 = Comput(ProgramPart(s1),s1,1);
A6: IC SCM+FSA in dom (while>0(a,I) +* Start-At( 0,SCM+FSA))
by COMPOS_1:141;
A7: IC s1 = IC(while>0(a,I) +* Start-At( 0,SCM+FSA)) by A6,FUNCT_4:14
    .=  0 by COMPOS_1:142;
  not a in dom (while>0(a,I) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  then
A8: s1.a = s.a by FUNCT_4:12;
  set loc4 =  (card I + 4);
  while>0(a,I) c= while>0(a,I) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A9: dom while>0(a,I) c= dom (while>0(a,I) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by COMPOS_1:38;
A10:  0 in dom while>0(a,I) by SCMFSA_9:10;
  then s1. 0 = (while>0(a,I) +* Start-At( 0,SCM+FSA)). 0
  by A9,FUNCT_4:14
    .= while>0(a,I). 0 by A10,SCMFSA6B:7
    .= i by SCMFSA_9:11;
  then
A11: CurInstr(ProgramPart s1,s1) = i by A7,Y;
A12: Comput(ProgramPart(s1),s1,0+1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,0)
)
 by EXTPRO_1:4
    .= Following(ProgramPart s1,s1) by EXTPRO_1:3
    .= Exec(i,s1) by A11;
  then ( for c being Int-Location holds s2.c = s1.c)& for f being
  FinSeq-Location holds s2.f = s1.f by SCMFSA_2:97;
  then
A13: DataPart s2 = DataPart s1 by SCMFSA6A:38
    .= DataPart s by SCMFSA8A:11
    .= DataPart sI by SCMFSA8A:11;
A14: IC s2 = s2.IC SCM+FSA
    .=  4 by A2,A12,A8,SCMFSA_2:97;
A15: P[0]
  proof
    assume 0 <= LifeSpan(ProgramPart(sI),sI);
A16: IC SCM+FSA in dom (I +* Start-At( 0,SCM+FSA)) by COMPOS_1:141;
    IC Comput(ProgramPart(sI),sI,0) = IC sI by EXTPRO_1:3
      .= IC(I +* Start-At( 0,SCM+FSA)) by A16,FUNCT_4:14
      .=  0 by COMPOS_1:142;
    hence thesis by A14,A13,EXTPRO_1:3;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A15,A3);
  then
A17: P[LifeSpan(ProgramPart(sI),sI) qua Element of NAT];
  set s4=Comput(ProgramPart(s1),s1,1+LifeSpan(ProgramPart(sI),sI)+1+1);
  set s3 = Comput(ProgramPart(s1),s1,1+LifeSpan(ProgramPart(sI),sI)+1);
A18: loc4 in dom while>0(a,I) by SCMFSA_9:38;
  set s2 = Comput(ProgramPart(s1),s1,1+LifeSpan(ProgramPart(sI),sI));
A19: CurInstr(ProgramPart s2,s2) = goto loc4 by A1,A17,SCMFSA_9:45;
T: ProgramPart s1 = ProgramPart s2
by AMI_1:123;
A20: s3 = Following(ProgramPart s1,s2) by EXTPRO_1:4
    .= Exec(goto loc4,s2) by A19,T;
  then
A21: ( for c being Int-Location holds s3.c = s2.c)& for f being
  FinSeq-Location holds s3.f = s2.f by SCMFSA_2:95;
A22: s3.loc4 = s1.loc4 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)).loc4 by A9,A18,FUNCT_4:14
    .= while>0(a,I).loc4 by A18,SCMFSA6B:7
    .= goto  0 by SCMFSA_9:46;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
  IC s3 = s3.IC SCM+FSA
    .= loc4 by A20,SCMFSA_2:95;
  then
A23: CurInstr(ProgramPart s3,s3) = goto  0 by A22,Y;
T: ProgramPart s1 = ProgramPart s3
by AMI_1:123;
  s4 = Following(ProgramPart s1,s3) by EXTPRO_1:4
    .= Exec(goto  0,s3) by A23,T;
  then ( for c being Int-Location holds s4.c = s3.c)& for f being
  FinSeq-Location holds s4.f = s3.f by SCMFSA_2:95;
  hence DataPart Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(sI),sI)+3) =
DataPart s3 by SCMFSA6A:38
    .= DataPart Comput(ProgramPart(sI),sI,LifeSpan(ProgramPart(sI),sI)) by A17
,A21,SCMFSA6A:38;
end;

theorem Th37: :: Step_gt0_0:
  (StepWhile>0(a, I, s).k).a <= 0 implies DataPart StepWhile>0(a,
  I, s).(k+1) = DataPart StepWhile>0(a, I, s).k
proof
  assume
A1: (StepWhile>0(a, I, s).k).a <= 0;
  set SW = StepWhile>0(a, I, s);
A2: while>0(a,I) +* SAt c= SW.k +* (while>0(a,I) +* SAt) by FUNCT_4:26;
A3: DataPart(SW.k +* (while>0(a,I) +* SAt)) = DataPart SW.k by SCMFSA8A:11;
  then
A4: SW.k.a = (SW.k +* (while>0(a,I) +* SAt)).a by SCMFSA6A:38;
  thus DataPart SW.(k+1) = DataPart Comput(ProgramPart((SW.k +* (while>0(a,I)
+* SAt)
  )),(SW.k +* (while>0(a,I) +* SAt)
  ), (LifeSpan(ProgramPart(SW.k +* (I +* SAt)),SW.k +* (I +* SAt)) + 3)) by
SCMFSA_9:def 5
    .= DataPart StepWhile>0(a, I, s).k by A1,A3,A4,A2,Th35;
end;

theorem Th38: :: Step_gt0_1:
  ( I is_halting_on Initialized StepWhile>0(a, I, s).k & I
  is_closed_on Initialized StepWhile>0(a, I, s).k or I is parahalting) & (
  StepWhile>0(a, I, s).k).a > 0 & (StepWhile>0(a, I, s).k).intloc 0 = 1 implies
DataPart StepWhile>0(a, I, s).(k+1) = DataPart IExec(I, StepWhile>0(a, I, s).k)
proof
  set Ins = NAT;
  assume that
A1: I is_halting_on Initialized StepWhile>0(a, I, s).k & I is_closed_on
  Initialized StepWhile>0(a, I, s).k or I is parahalting and
A2: (StepWhile>0(a, I, s).k).a > 0 and
A3: (StepWhile>0(a, I, s).k).intloc 0 = 1;
  set ISWk = Initialized StepWhile>0(a, I, s).k;
  set SW = StepWhile>0(a, I, s);
  set SWkI = SW.k+*Initialized I;
  DataPart ISWk = DataPart SW.k by A3,SCMFSA8C:27;
  then
A4: I is_closed_on SW.k & I is_halting_on SW.k by A1,SCMFSA7B:24,25,SCMFSA8B:8;
  I is_halting_on ISWk by A1,SCMFSA7B:25;
  then Initialized I is_halting_on SW.k by SCMFSA8C:22;
  then
X:   SAt c= Initialized I &
  ProgramPart(SW.k+*(Initialized I +* SAt))
   halts_on SW.k+*(Initialized I +* SAt) by FUNCT_4:26,SCMFSA7B:def 8;
  then SWkI = SW.k+*(Initialized I +* SAt) by FUNCT_4:79;
  then
A5: ProgramPart SWkI halts_on SWkI by X;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A6: dom ProgramPart(SW.k) misses D by COMPOS_1:34;
  set IS = Initialize I;
  set SWkIS = SW.k+*IS;
A7: SWkI = SWkIS by A3,SCMFSA8C:18;
  set WHS = while>0(a, I) +* SAt;
A8: SW.(k+1) = Comput(ProgramPart((SW.k +* WHS)),(SW.k +* WHS),LifeSpan(
ProgramPart(SWkIS),SWkIS)
+ 3) by SCMFSA_9:def 5;
  DataPart IExec(I, SW.k) = DataPart(Result(ProgramPart(SWkI),SWkI) +* SW.k |
Ins) by SCMFSA6B:def 1
    .= DataPart(Result(ProgramPart(SWkI),SWkI)) by A6,FUNCT_4:76,SCMFSA_2:127
    .= DataPart Comput(ProgramPart(SWkIS),SWkIS,LifeSpan(ProgramPart(SWkIS),
SWkIS)) by A7,A5,EXTPRO_1:23;
  hence thesis by A2,A8,A4,Th36;
end;

theorem Th39: :: GoodStep0:
  (ProperBodyWhile>0 a, Ig, s or Ig is parahalting) & s.intloc 0 =
  1 implies for k holds StepWhile>0(a, Ig, s).k.intloc 0 = 1
proof
  set I = Ig;
  assume that
A1: ProperBodyWhile>0 a, I, s or I is parahalting and
A2: s.intloc 0 = 1;
  set SW = StepWhile>0(a, I, s);
  defpred X[Nat] means SW.$1.intloc 0 = 1;
A3: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT such that
A4: SW.k.intloc 0 = 1;
    per cases;
    suppose
      SW.k.a <= 0;
      then DataPart SW.(k+1) = DataPart SW.k by Th37;
      hence thesis by A4,SCMFSA6A:38;
    end;
    suppose
A5:   SW.k.a > 0;
      set SWkI = SW.k+*Initialized I;
      set ISWk = Initialized StepWhile>0(a, I, s).k;
A6:   DataPart SW.k = DataPart ISWk by A4,SCMFSA8C:27;
      set Ins = NAT;
      set SWkIS = SW.k+* Initialize I;
      Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
      then
A7:   dom ProgramPart(SW.k) misses D by COMPOS_1:34;
A8:   SWkI = SWkIS by A4,SCMFSA8C:18;
A9:   ProperBodyWhile>0 a, I, s by A1,Th32;
      then
A10:  I is_closed_on SW.k by A5,Def4;
      I is_halting_on SW.k by A5,A9,Def4;
      then
A11:  I is_halting_on Initialized SW.k by A10,A6,SCMFSA8B:8;
      then Initialized I is_halting_on SW.k by SCMFSA8C:22;
      then
X:       SAt c= Initialized I &
      ProgramPart(SW.k+*(Initialized I +* SAt))
       halts_on SW.k+*(Initialized I +* SAt) by FUNCT_4:26,SCMFSA7B:def 8;
  then SWkI = SW.k+*(Initialized I +* SAt) by FUNCT_4:79;
      then
A12:  ProgramPart SWkI halts_on SWkI by X;
A13:  DataPart IExec(I, SW.k) = DataPart(Result(ProgramPart(SWkI),SWkI) +* SW.k
| Ins) by SCMFSA6B:def 1
        .= DataPart Result(ProgramPart(SWkI),SWkI) by A7,FUNCT_4:76
,SCMFSA_2:127
        .= DataPart Comput(ProgramPart(SWkIS),SWkIS,LifeSpan(ProgramPart(SWkIS)
,SWkIS)) by A8,A12,EXTPRO_1:23;
      I is_closed_on Initialized SW.k by A10,A6,SCMFSA8B:6;
      then DataPart SW.(k+1) = DataPart IExec(I, SW.k) by A4,A5,A11,Th38;
      hence
      SW.(k+1).intloc 0 = (Comput(ProgramPart(SWkIS),SWkIS,LifeSpan(ProgramPart
(SWkIS),SWkIS))).
intloc 0 by A13,SCMFSA6A:38
        .= 1 by A4,A10,SCMFSA8C:97;
    end;
  end;
A14: X[0] by A2,SCMFSA_9:def 5;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A14,A3);
end;

theorem Th40:
  ProperBodyWhile>0 a, I, s1 & DataPart s1 = DataPart s2 implies
for k holds DataPart StepWhile>0(a, I, s1).k = DataPart StepWhile>0(a, I, s2).k
proof
  assume that
A1: ProperBodyWhile>0 a, I, s1 and
A2: DataPart s1 = DataPart s2;
  set WH = while>0(a,I);
  set ST2 = StepWhile>0(a, I, s2);
  set ST1 = StepWhile>0(a, I, s1);
  defpred X[Nat] means DataPart ST1.$1 = DataPart ST2.$1;
A3: for k st X[k] holds X[k+1]
  proof
    let k;
    set ST1kI = ST1.k +* (I +* SAt);
    set ST2kI = ST2.k +* (I +* SAt);
    assume
A4: DataPart ST1.k = DataPart ST2.k;
    then
A5: ST1.k.a = ST2.k.a by SCMFSA6A:38;
    per cases;
    suppose
A6:   ST1.k.a <= 0;
      hence DataPart ST1.(k+1) = DataPart ST1.k by Th37
        .= DataPart ST2.(k+1) by A4,A5,A6,Th37;
    end;
    suppose
A7:   ST1.k.a > 0;
      then
A8:   I is_closed_on ST1.k by A1,Def4;
A9:   I is_halting_on ST1.k by A1,A7,Def4;
      then
A10:  I is_closed_on ST2.k & I is_halting_on ST2.k by A4,A8,SCMFSA8B:8;
A11:  DataPart ST1.(k+1) = DataPart Comput(ProgramPart((ST1.k +* (WH +* SAt))),
(ST1.k +* (WH +* SAt)), (
      LifeSpan(ProgramPart(ST1kI),ST1kI) + 3)) by SCMFSA_9:def 5
        .= DataPart Comput(ProgramPart((ST1kI)),(ST1kI),LifeSpan(ProgramPart(
ST1kI),ST1kI)) by A7,A8,A9,Th36;
A12:  DataPart ST2.(k+1) = DataPart Comput(ProgramPart((ST2.k +* (WH +* SAt))),
(ST2.k +* (WH +* SAt)), (
      LifeSpan(ProgramPart(ST2kI),ST2kI) + 3)) by SCMFSA_9:def 5
        .= DataPart Comput(ProgramPart((ST2kI)),(ST2kI),LifeSpan(ProgramPart(
ST2kI),ST2kI)) by A5,A7,A10,Th36;
A13:  I +* SAt c= ST1kI & I +* SAt c= ST2kI by FUNCT_4:26;
A14:  DataPart ST1.k = DataPart ST1kI by SCMFSA8A:11;
      then
A15:  I is_closed_on (ST1kI) by A8,SCMFSA8B:6;
A16:  DataPart ST1kI = DataPart ST1.k by SCMFSA8A:11
        .= DataPart ST2kI by A4,SCMFSA8A:11;
      I is_halting_on ST1kI by A8,A9,A14,SCMFSA8B:8;
      then (LifeSpan(ProgramPart(ST1kI),ST1kI)) = (LifeSpan(ProgramPart(ST2kI),
ST2kI)) by A8,A16,A13,A14,SCMFSA8B:6,SCMFSA8C:44;
      hence thesis by A11,A12,A16,A13,A15,SCMFSA8C:43;
    end;
  end;
  DataPart ST1.0 = DataPart s1 by SCMFSA_9:def 5
    .= DataPart ST2.0 by A2,SCMFSA_9:def 5;
  then
A17: X[0];
  thus for k holds X[k] from NAT_1:sch 1(A17, A3);
end;

definition
  let s be State of SCM+FSA, a be read-write Int-Location, I be Program of
  SCM+FSA;
  assume that
A1: ProperBodyWhile>0 a, I, s or I is parahalting and
A2: WithVariantWhile>0 a, I, s;
  func ExitsAtWhile>0(a, I, s) -> Element of NAT means
  :Def6:
  ex k being
  Element of NAT st it = k & (StepWhile>0(a, I, s).k).a <= 0 & (for i being
  Element of NAT st (StepWhile>0(a, I, s).i).a <= 0 holds k <= i) & DataPart
  Comput(ProgramPart((s +* (while>0(a, I) +* (Start-At( 0,SCM+FSA))))),(s +* (
while>0(a, I) +* (Start-At( 0,SCM+FSA)))),
  (LifeSpan(ProgramPart(s +* (
  while>0(a, I) +* (Start-At( 0,SCM+FSA)))),s +* (
  while>0(a, I) +* (Start-At( 0,SCM+FSA)))))) =
  DataPart StepWhile>0(a, I, s).k;
  existence
  proof
    set S = s +* (while>0(a, I) +* SAt);
    set SW = StepWhile>0(a, I, s);
    defpred X[Nat] means SW.$1.a <= 0;
A3: while>0(a, I) +* SAt c= S by FUNCT_4:26;
    consider f being Function of product the Object-Kind of SCM+FSA, NAT such
    that
A4: for k being Element of NAT holds f.(SW.(k+1))<f.(SW.k) or X[k] by A2,Def5;
    deffunc U(Nat) = f.(SW.$1);
A5: for k being Element of NAT holds U(k+1)<U(k) or X[k] by A4;
    consider m such that
A6: X[m] and
A7: for n st X[n] holds m <= n from NAT_1:sch 18(A5);
    take m, m;
    thus m = m;
    thus SW.m.a <= 0 by A6;
    thus for n st SW.n.a <= 0 holds m <= n by A7;
    defpred P[Nat] means $1+1 <= m implies ex k st StepWhile>0(a,I,
    s).($1+1)=Comput(ProgramPart(S),S,k);
A8: ProperBodyWhile>0 a, I, s by A1,Th32;
A9: now
      let k be Element of NAT;
      assume
A10:  P[k];
      now
        set sk1=StepWhile>0(a,I,s).(k+1);
        set sk=StepWhile>0(a,I,s).k;
        assume
A11:    (k+1)+ 1 <= m;
        k + 0 < k+ (1+ 1) by XREAL_1:8;
        then k < m by A11,XXREAL_0:2;
        then
A12:    sk.a > 0 by A7;
        (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
        then consider n being Element of NAT such that
A13:    sk1 = Comput(ProgramPart(S),S,n) by A10,A11,XXREAL_0:2;
A14:    sk1 = Comput(ProgramPart((sk +* (while>0(a,I)+* SAt))),(sk +* (while>0(
a,I)+* SAt)), (LifeSpan(ProgramPart(sk +*
        (I +* SAt)),sk +*
        (I +* SAt)) + 3)) by SCMFSA_9:def 5;
        take m=n +(LifeSpan(ProgramPart(sk1 +* (I +* SAt)),sk1 +* (I +* SAt)) +
3);
        I is_closed_on sk & I is_halting_on sk by A8,A12,Def4;
        then IC sk1 = 0 by A14,A12,SCMFSA_9:47;
        hence StepWhile>0(a,I,s).((k+1)+1)=Comput(ProgramPart(S),S,m) by A13,
SCMFSA_9:52;
      end;
      hence P[k+1];
    end;
A15: IC SCM+FSA in dom (while>0(a,I) +* SAt ) by COMPOS_1:141;
A16: P[0]
    proof
      assume 0+1 <= m;
      take n=(LifeSpan(ProgramPart(s+* (I +* SAt)),s+* (I +* SAt)) + 3);
      thus thesis by SCMFSA_9:51;
    end;
A17: for k being Element of NAT holds P[k] from NAT_1:sch 1(A16,A9);
    per cases;
    suppose
A18:  m = 0;
A19:  DataPart S = DataPart s by SCMFSA8A:11
        .= DataPart SW.m by A18,SCMFSA_9:def 5;
      then S.a = SW.m.a by SCMFSA6A:38;
      hence thesis by A6,A3,A19,Th35;
    end;
    suppose
A20:  m <> 0;
      set sm = StepWhile>0(a,I,s).m;
      set sm1 = sm +* (while>0(a,I)+* SAt);
      consider i being Nat such that
A21:  m=i+1 by A20,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      set si = StepWhile>0(a,I,s).i;
A22:  sm = Comput(ProgramPart((si +* (while>0(a,I)+* SAt))),(si +* (while>0(a,I
)+* SAt)), (LifeSpan(ProgramPart(si +* (I
      +* SAt)),si +* (I
      +* SAt)) + 3)) by A21,SCMFSA_9:def 5;
      m=i+1 by A21;
      then consider n being Element of NAT such that
A23:  sm = Comput(ProgramPart(S),S,n) by A17;
      i < m by A21,NAT_1:13;
      then
A24:  si.a > 0 by A7;
      then I is_closed_on si & I is_halting_on si by A8,Def4;
      then
A25:  IC sm = 0 by A22,A24,SCMFSA_9:47;
A26:  IC sm1 = IC(while>0(a,I) +* SAt) by A15,FUNCT_4:14
        .= IC sm by A25,COMPOS_1:142;
      ProgramPart sm = ProgramPart S by A23,AMI_1:123;
      then DataPart sm1 = DataPart sm &
        ProgramPart sm1 = ProgramPart sm by FUNCT_4:100,SCMFSA8A:11;
      then
A27:  sm1 = sm by A26,SCMFSA_9:29;
      while>0(a,I) is_halting_on sm by A6,SCMFSA_9:43;
      then ProgramPart sm1 halts_on sm1 by SCMFSA7B:def 8;
      then consider j being Element of NAT such that
A28:  CurInstr(ProgramPart sm,Comput(ProgramPart(sm),sm,j))
 = halt SCM+FSA by A27,EXTPRO_1:30;
S: ProgramPart S = ProgramPart Comput(ProgramPart(S),S,n)

by AMI_1:123;
x: Comput(ProgramPart(S),S,n+j)
 = Comput(ProgramPart(S),Comput(ProgramPart(S),S,n),j) by EXTPRO_1:5;
T: ProgramPart S = ProgramPart sm
by A23,AMI_1:123;
      CurInstr(ProgramPart S,Comput(ProgramPart(S),S
,n+j))
       = halt SCM+FSA by A23,A28,x,S;
      then
A29:  Comput(ProgramPart(S),S,LifeSpan(ProgramPart(S),S)) = Comput(ProgramPart(
S),S,n+j) by EXTPRO_1:24
        .= Comput(ProgramPart(S),sm,j) by A23,EXTPRO_1:5
        .= Comput(ProgramPart(sm),sm,LifeSpan(ProgramPart(sm),sm)) by A28,T,
EXTPRO_1:24;
      while>0(a,I)+* SAt c= sm by A27,FUNCT_4:26;
      hence thesis by A6,A29,Th35;
    end;
  end;
  uniqueness
  proof
    let it1, it2 be Element of NAT;
    given k1 being Element of NAT such that
A30: it1 = k1 and
A31: (StepWhile>0(a, I, s).k1).a <= 0 & for i being Element of NAT st
    ( StepWhile>0(a, I, s).i).a <= 0 holds k1 <= i and
    DataPart(Comput(ProgramPart((s +* (while>0(a, I) +* SAt))),(s +* (while>0(a
, I) +* SAt)), (LifeSpan(ProgramPart(s +* (
    while>0(a, I) +* SAt)),s +* (
    while>0(a, I) +* SAt))))) = DataPart StepWhile>0(a, I, s).k1;
    given k2 being Element of NAT such that
A32: it2 = k2 and
A33: (StepWhile>0(a, I, s).k2).a <= 0 & for i being Element of NAT st
    ( StepWhile>0(a, I, s).i).a <= 0 holds k2 <= i and
    DataPart(Comput(ProgramPart((s +* (while>0(a, I) +* SAt))),(s +* (while>0(a
, I) +* SAt)), (LifeSpan(ProgramPart(s +* (
    while>0(a, I) +* SAt)),s +* (
    while>0(a, I) +* SAt))))) = DataPart StepWhile>0(a, I, s).k2;
    k1 <= k2 & k2 <= k1 by A31,A33;
    hence thesis by A30,A32,XXREAL_0:1;
  end;
end;

theorem :: IE_while_le0:
  s.intloc 0 = 1 & s.a <= 0 implies DataPart IExec(while>0(a, I), s) =
  DataPart s
proof
  set Ins = NAT;
  assume that
A1: s.intloc 0 = 1 and
A2: s.a <= 0;
  set WH = while>0(a, I);
  set Is = Initialized s;
  set Ids = s +* Initialized WH;
A3: Ids = Is +*(WH +* SAt) by SCMFSA8A:13;
  then
A4: WH +* SAt c= Ids by FUNCT_4:26;
  Is.a = s.a by SCMFSA6C:3;
  then WH is_halting_on Is by A2,SCMFSA_9:43;
  then
A5: ProgramPart Ids halts_on Ids by A3,SCMFSA7B:def 8;
  DataPart Is = DataPart Ids by SCMFSA8B:5;
  then
A6: Ids.a = Is.a by SCMFSA6A:38
    .= s.a by SCMFSA6C:3;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A7: dom ProgramPart s misses D by COMPOS_1:34;
  thus DataPart IExec(WH, s) = DataPart(Result(ProgramPart(s+*Initialized WH),s
+*Initialized WH) +* s | Ins)
  by SCMFSA6B:def 1
    .= DataPart(Result(ProgramPart(s+*Initialized WH),s+*Initialized WH)) by A7
,FUNCT_4:76,SCMFSA_2:127
    .= DataPart Comput(ProgramPart(Ids),Ids,LifeSpan(ProgramPart(Ids),Ids)) by
A5,EXTPRO_1:23
    .= DataPart Ids by A2,A6,A4,Th35
    .= DataPart Initialized s by SCMFSA8B:5
    .= DataPart s by A1,SCMFSA8C:27;
end;

theorem Th42: :: IE_while_gt0:
  (ProperBodyWhile>0 a, I, Initialized s or I is parahalting) &
WithVariantWhile>0 a, I, Initialized s implies DataPart IExec(while>0(a, I), s)
  = DataPart
  StepWhile>0(a, I, Initialized s).ExitsAtWhile>0(a, I, Initialized s)
proof
  set Ins = NAT;
  set WH = while>0(a, I);
  set Ids = s +* Initialized WH;
  set Is = Initialized s;
A1: Ids = Is +*(WH +* SAt) by SCMFSA8A:13;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A2: dom ProgramPart s misses D by COMPOS_1:34;
  assume
A3: ( ProperBodyWhile>0 a, I, Initialized s or I is parahalting)&
  WithVariantWhile>0 a, I, Initialized s;
  then
A4: ex k being Element of NAT st ExitsAtWhile>0(a, I, Is) = k & (StepWhile>0(
a, I, Is).k).a <= 0 &( for i being Element of NAT st ( StepWhile>0(a, I, Is).i)
.a <= 0 holds k <= i)& DataPart (Comput(ProgramPart((Is +* ( while>0(a, I) +*
SAt))),(Is +* ( while>0(a, I) +* SAt)), (
  LifeSpan(ProgramPart(Is +* (while>0(a, I) +* SAt)),Is +* (while>0(a, I) +*
SAt))))) = DataPart StepWhile>0(a, I, Is).k
  by Def6;
  WH is_halting_on Is by A3,Th33,Th34;
  then
A5: ProgramPart Ids halts_on Ids by A1,SCMFSA7B:def 8;
  thus DataPart IExec(WH, s) = DataPart(Result(ProgramPart(s+*Initialized WH),s
+*Initialized WH) +* s | Ins)
  by SCMFSA6B:def 1
    .= DataPart(Result(ProgramPart(s+*Initialized WH),s+*Initialized WH)) by A2
,FUNCT_4:76,SCMFSA_2:127
    .= DataPart StepWhile>0(a, I, Is).ExitsAtWhile>0(a, I, Is) by A1,A5,A4,
EXTPRO_1:23;
end;

theorem Th43:
  StepWhile>0(a, I, s).k.a <= 0 implies for n being Element of NAT
st k <= n holds DataPart StepWhile>0(a, I, s).n = DataPart StepWhile>0(a, I, s)
  .k
proof
  set SW = StepWhile>0(a, I, s);
  defpred P[Nat] means k <= $1 implies DataPart SW.$1 = DataPart SW
  .k;
  assume
A1: StepWhile>0(a, I, s).k.a <= 0;
A2: now
    let n be Element of NAT such that
A3: P[n];
    thus P[n+1]
    proof
      assume
A4:   k <= n+1;
      per cases by A4,NAT_1:8;
      suppose
A5:     k <= n;
        then SW.n.a <= 0 by A1,A3,SCMFSA6A:38;
        hence thesis by A3,A5,Th37;
      end;
      suppose
        k = n+1;
        hence thesis;
      end;
    end;
  end;
A6: P[0];
  thus for n being Element of NAT holds P[n] from NAT_1:sch 1(A6, A2 );
end;

theorem
  DataPart s1 = DataPart s2 & ProperBodyWhile>0 a, I, s1 implies
  ProperBodyWhile>0 a, I, s2
proof
  assume that
A1: DataPart s1 = DataPart s2 and
A2: ProperBodyWhile>0 a, I, s1;
  let k be Element of NAT such that
A3: StepWhile>0(a,I,s2).k.a > 0;
A4: DataPart StepWhile>0(a,I,s2).k = DataPart StepWhile>0(a,I,s1).k by A1,A2
,Th40;
  then StepWhile>0(a,I,s1).k.a > 0 by A3,SCMFSA6A:38;
  then
  I is_closed_on StepWhile>0(a,I,s1).k & I is_halting_on StepWhile>0(a,I,
  s1).k by A2,Def4;
  hence thesis by A4,SCMFSA8B:8;
end;

Lm7: s.intloc 0 = 1 implies (I is_closed_on s iff I is_closed_on Initialized s)
proof
  assume s.intloc 0 = 1;
  then DataPart Initialized s = DataPart s by SCMFSA8C:27;
  hence thesis by SCMFSA8B:6;
end;

Lm8: s.intloc 0 = 1 implies ( I is_closed_on s & I is_halting_on s iff I
is_closed_on Initialized s & I is_halting_on Initialized s)

proof
  assume s.intloc 0 = 1;
  then DataPart Initialized s = DataPart s by SCMFSA8C:27;
  hence thesis by SCMFSA8B:8;
end;

theorem Th45:
  s.intloc 0 = 1 & ProperBodyWhile>0 a, Ig, s & WithVariantWhile>0
  a, Ig, s implies for i, j st i <> j & i <= ExitsAtWhile>0(a, Ig, s) & j <=
ExitsAtWhile>0(a, Ig, s) holds StepWhile>0(a, Ig, s).i <> StepWhile>0(a, Ig, s)
  .j & DataPart StepWhile>0(a, Ig, s).i <> DataPart StepWhile>0(a, Ig, s).j
proof
  set I = Ig;
  assume that
A1: s.intloc 0 = 1 and
A2: ProperBodyWhile>0 a, I, s and
A3: WithVariantWhile>0 a, I, s;
  set SW = StepWhile>0(a, I, s);
  consider K being Element of NAT such that
A4: ExitsAtWhile>0(a, I, s) = K and
A5: SW.K.a <= 0 and
A6: for i being Element of NAT st SW.i.a <= 0 holds K <= i and
  DataPart Comput(ProgramPart((s +* (while>0(a, I) +* SAt))),(s +* (while>0(a,
I) +* SAt)), (LifeSpan(ProgramPart(s +* (
  while>0(a, I) +* SAt)),s +* (
  while>0(a, I) +* SAt)))) = DataPart SW.K by A2,A3,Def6;
  consider f being Function of product the Object-Kind of SCM+FSA, NAT such
  that
A7: for k being Element of NAT holds f.(SW.(k+1)) < f.(SW.k) or SW.k.a
  <= 0 by A3,Def5;
A8: for i, j being Element of NAT st i < j & i <= K & j <= K holds DataPart
  SW.i <> DataPart SW.j
  proof
    let i, j be Element of NAT such that
A9: i < j and
    i <= K and
A10: j <= K;
    per cases by A10,XXREAL_0:1;
    suppose
A11:  j = K;
      assume DataPart SW.i = DataPart SW.j;
      then SW.i.a <= 0 by A5,A11,SCMFSA6A:38;
      hence contradiction by A6,A9,A11;
    end;
    suppose
A12:  j < K;
      defpred X[Nat] means j+$1 <= K implies DataPart SW.(i+$1) =
      DataPart SW.(j+$1);
A13:  for k being Element of NAT st X[k] holds X[k+1]
      proof
        let k be Element of NAT such that
A14:    j+k <= K implies DataPart SW.(i+k) = DataPart SW.(j+k) and
A15:    j+(k+1) <= K;
A16:    SW.(j+k).intloc 0 = 1 by A1,A2,Th39;
A17:    j+k < (j+k)+1 by XREAL_1:31;
        then
A18:    j+k < K by A15,XXREAL_0:2;
        then
A19:    SW.(j+k).a > 0 by A6;
        then
A20:    I is_closed_on SW.(j+k) by A2,Def4;
        then
A21:    I is_closed_on Initialized SW.(j+k) by A16,Lm7;
A22:    I is_halting_on SW.(j+k) by A2,A19,Def4;
        then
A23:    I is_halting_on Initialized SW.(j+k) by A16,A20,Lm8;
A24:    SW.(i+k).intloc 0 = 1 by A1,A2,Th39;
A25:    SW.(i+k).a > 0
        proof
          assume not thesis;
          then
A26:      K <= i+k by A6;
          i+k < j+k by A9,XREAL_1:8;
          hence contradiction by A18,A26,XXREAL_0:2;
        end;
        then
A27:    I is_closed_on SW.(i+k) by A2,Def4;
        then
A28:    I is_closed_on Initialized SW.(i+k) by A24,Lm7;
        I is_halting_on SW.(i+k) by A2,A25,Def4;
        then
A29:    I is_halting_on Initialized SW.(i+k) by A24,A27,Lm8;
        thus DataPart SW.(i+(k+1)) = DataPart SW.(i+k+1)
          .= DataPart IExec(I, SW.(i+k)) by A24,A25,A28,A29,Th38
          .= DataPart IExec(I, SW.(j+k)) by A14,A15,A17,A16,A20,A22,SCMFSA8C:46
,XXREAL_0:2
          .= DataPart SW.(j+k+1) by A16,A19,A21,A23,Th38
          .= DataPart SW.(j+(k+1));
      end;
      consider p being Element of NAT such that
A30:  K = j+p and
      1 <= p by A12,FINSEQ_4:99;
      assume DataPart SW.i = DataPart SW.j;
      then
A31:  X[0];
      for k being Element of NAT holds X[k] from NAT_1:sch 1(A31, A13);
      then DataPart SW.(i+p) = DataPart SW.K by A30;
      then
A32:  SW.(i+p).a <= 0 by A5,SCMFSA6A:38;
      i+p < K by A9,A30,XREAL_1:8;
      hence contradiction by A6,A32;
    end;
  end;
A33: for i, j being Element of NAT st i < j & i <= K & j <= K holds SW.i <>
  SW.j
  proof
    let i, j be Element of NAT;
    assume that
A34: i < j and
    i <= K and
A35: j <= K;
    defpred X[Nat] means i < $1 & $1 <= j implies f.(SW.$1) < f.(SW
    .i);
A36: i < K by A34,A35,XXREAL_0:2;
A37: for k being Element of NAT st X[k] holds X[k+1]
    proof
      let k be Element of NAT such that
A38:  i < k & k <= j implies f.(SW.k) < f.(SW.i) and
A39:  i < k+1 and
A40:  k+1 <= j;
A41:  i <= k by A39,NAT_1:13;
      per cases by A41,XXREAL_0:1;
      suppose
A42:    i = k;
        not SW.i.a <= 0 by A6,A36;
        hence thesis by A7,A42;
      end;
      suppose
A43:    i < k;
A44:    k < j by A40,NAT_1:13;
        now
          assume SW.k.a <= 0;
          then K <= k by A6;
          hence contradiction by A35,A44,XXREAL_0:2;
        end;
        then f.(SW.(k+1)) < f.(SW.k) by A7;
        hence thesis by A38,A40,A43,NAT_1:13,XXREAL_0:2;
      end;
    end;
    assume
A45: SW.i = SW.j;
A46: X[0];
    for k being Element of NAT holds X[k] from NAT_1:sch 1(A46, A37 );
    hence contradiction by A34,A45;
  end;
  given i, j being Element of NAT such that
A47: i <> j and
A48: i <= ExitsAtWhile>0(a, I, s) & j <= ExitsAtWhile>0(a, I, s) &( SW.i
  = SW. j or DataPart SW.i = DataPart SW.j);
  i < j or j < i by A47,XXREAL_0:1;
  hence contradiction by A4,A33,A8,A48;
end;

definition
  let f be Function of product the Object-Kind of SCM+FSA, NAT;
  attr f is on_data_only means
  :Def7:
  for s1, s2 st DataPart s1 = DataPart s2
  holds f.s1 = f.s2;
end;

theorem Th46:
  s.intloc 0 = 1 & ProperBodyWhile>0 a, Ig, s & WithVariantWhile>0
a, Ig, s implies ex f being Function of product the Object-Kind of SCM+FSA, NAT
st f is on_data_only & for k being Element of NAT holds f.(StepWhile>0(a, Ig, s
  ).(k+1)) < f.(StepWhile>0(a, Ig, s).k) or StepWhile>0(a, Ig, s).k.a <= 0
proof
  set I = Ig;
  assume that
A1: s.intloc 0 = 1 and
A2: ProperBodyWhile>0 a, I, s and
A3: WithVariantWhile>0 a, I, s;
  set SW = StepWhile>0(a,I,s);
  consider K being Element of NAT such that
A4: ExitsAtWhile>0(a, I, s) = K and
A5: SW.K.a <= 0 and
  for i being Element of NAT st SW.i.a <= 0 holds K <= i and
  DataPart Comput(ProgramPart((s +* (while>0(a, I) +* SAt))),(s +* (while>0(a,
I) +* SAt)), (LifeSpan(ProgramPart(s +* (
  while>0(a, I) +* SAt)),s +* (
  while>0(a, I) +* SAt)))) = DataPart StepWhile>0(a, I, s).K by A2,A3,Def6;
  consider g being Function of product the Object-Kind of SCM+FSA, NAT such
  that
A6: for k being Element of NAT holds g.(SW.(k+1)) < g.(SW.k) or SW.k.a
  <= 0 by A3,Def5;
  defpred P[State of SCM+FSA, set] means (ex k being Element of NAT st k <= K
  & DataPart $1 = DataPart SW.k & $2 = g.(SW.k)) or not (ex k being Element of
  NAT st k <= K & DataPart $1 = DataPart SW.k) & $2 = 0;
A7: for x being Element of product the Object-Kind of SCM+FSA
 ex y being Element of NAT st P[x,y]
  proof
    let x be  Element of product the Object-Kind of SCM+FSA;
    per cases;
    suppose
      ex k being Element of NAT st k <= K & DataPart x = DataPart SW.k;
      then consider k being Element of NAT such that
A8:   k <= K & DataPart x = DataPart SW.k;
      take g.(SW.k);
      thus thesis by A8;
    end;
    suppose
A9:   not ex k being Element of NAT st k <= K & DataPart x = DataPart
      SW.k;
      take 0;
      thus thesis by A9;
    end;
  end;
  consider f being Function of product the Object-Kind of SCM+FSA, NAT such
  that
A10: for x being Element of product the Object-Kind of SCM+FSA
 holds P[x,f.x]
 from FUNCT_2:sch 3(A7);
  take f;
  hereby
    let s1, s2 such that
A11: DataPart s1 = DataPart s2;
     reconsider ss1=s1, ss2=s2 as
      Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
    ( P[ss1, f.ss1])& P[ss2, f.ss2] by A10;
    hence f.s1 = f.s2 by A1,A2,A3,A4,A11,Th45;
  end;
  let k be Element of NAT;
  per cases;
  suppose
A12: k < K;
    then
A13: k+1 <= K by NAT_1:13;
    then consider kk1 being Element of NAT such that
A14: kk1 <= K & DataPart SW.(k+1) = DataPart SW.kk1 and
A15: f.(SW.(k+1))=g.(SW.kk1) by A10;
A16: k+1 = kk1 by A1,A2,A3,A4,A13,A14,Th45;
    consider kk being Element of NAT such that
A17: kk <= K & DataPart SW.k = DataPart SW.kk and
A18: f.(SW.k) = g.(SW.kk) by A10,A12;
    k = kk by A1,A2,A3,A4,A12,A17,Th45;
    hence thesis by A6,A18,A15,A16;
  end;
  suppose
    K <= k;
    then DataPart SW.K = DataPart SW.k by A5,Th43;
    hence thesis by A5,SCMFSA6A:38;
  end;
end;

theorem
  s1.intloc 0 = 1 & DataPart s1 = DataPart s2 & ProperBodyWhile>0 a, Ig,
  s1 & WithVariantWhile>0 a, Ig, s1 implies WithVariantWhile>0 a, Ig, s2
proof
  set I = Ig;
  assume that
A1: s1.intloc 0 = 1 and
A2: DataPart s1 = DataPart s2 and
A3: ProperBodyWhile>0 a, I, s1 and
A4: WithVariantWhile>0 a, I, s1;
  set SW1 = StepWhile>0(a,I,s1);
  consider f being Function of product the Object-Kind of SCM+FSA, NAT such
  that
A5: f is on_data_only and
A6: for k being Element of NAT holds (f.(SW1.(k+1)) < f.(SW1.k) or SW1.k
  .a <= 0 ) by A1,A3,A4,Th46;
  take f;
  let k be Element of NAT;
  set SW2 = StepWhile>0(a,I,s2);
  DataPart SW1.(k+1) = DataPart SW2.(k+1) by A2,A3,Th40;
  then
A7: f.(SW1.(k+1)) = f.(SW2.(k+1)) by A5,Def7;
A8: DataPart SW1.k = DataPart SW2.k by A2,A3,Th40;
  then
A9: SW1.k.a = SW2.k.a by SCMFSA6A:38;
  f.(SW1.k) = f.(SW2.k) by A5,A8,Def7;
  hence thesis by A6,A9,A7;
end;

begin :: fusc using while>0, bottom-up

definition
  let N, result be Int-Location;
  func Fusc_macro ( N, result ) -> Program of SCM+FSA equals
  SubFrom(result,
  result) ';' ((1-stRWNotIn {N, result}) := intloc 0) ';' ((2-ndRWNotIn {N,
result}) := N) ';' while>0 ( 2-ndRWNotIn {N, result}, (3-rdRWNotIn {N, result})
:= 2 ';' Divide(2-ndRWNotIn {N, result}, 3-rdRWNotIn {N, result}) ';' if=0 ( 3
  -rdRWNotIn {N, result}, Macro AddTo(1-stRWNotIn {N, result}, result), Macro
  AddTo(result, 1-stRWNotIn {N, result}) ) );
  correctness;
end;
:: set next = 1-stRWNotIn {N, result};
:: set aux  = 2-ndRWNotIn {N, result};
:: set rem2 = 3-rdRWNotIn {N, result};
:: while and if do not allocate memory, no need to save anything

theorem
  for N, result being read-write Int-Location st N <> result for n being
Element of NAT st n = s.N holds IExec(Fusc_macro(N, result), s).result = Fusc n
  & IExec(Fusc_macro(N, result), s).N = n
proof
  let N, result be read-write Int-Location such that
A1: N <> result;
  set i0 = SubFrom(result, result);
  set rem2 = 3-rdRWNotIn {N, result};
  set aux = 2-ndRWNotIn {N, result};
  set next = 1-stRWNotIn {N, result};
  set I3i0 = rem2 := 2;
  set I3i1 = Divide(aux, rem2);
  set I3I2I0 = Macro AddTo(next, result);
  set I3I2I1 = Macro AddTo(result, next);
  set I3I2 = if=0 ( rem2, I3I2I0, I3I2I1 );
  set I = I3i0 ';' I3i1 ';' I3I2;
  let n be Element of NAT such that
A2: n = s.N;
A3: next <> rem2 by SFMASTR1:22;
A4: aux <> next by SFMASTR1:22;
  set I3 = while>0 ( aux, I );
  deffunc U(Element of product the Object-Kind of SCM+FSA) = abs($1.aux);
  set i2 = aux := N;
  set i1 = next := intloc 0;
  set t = IExec(i0 ';' i1 ';' i2, s);
  set It = Initialized t;
  set SWt = StepWhile>0(aux, I, It);
  defpred X[Nat] means ex au, ne, re being Element of NAT st SWt.$1
.aux = au & SWt.$1.next = ne & SWt.$1.result = re & SWt.$1.N = n & Fusc n = ne
  * Fusc au + re * Fusc (au+1);
  consider f being Function of product the Object-Kind of SCM+FSA,NAT such
  that
A5: for x being Element of product the Object-Kind of SCM+FSA holds f.x
  = U(x) from FUNCT_2:sch 4;
A6: N in {N, result} by TARSKI:def 2;
  then
A7: N <> next by SFMASTR1:21;
A8: result in {N, result} by TARSKI:def 2;
  then
A9: aux <> result by SFMASTR1:21;
A10: result <> rem2 by A8,SFMASTR1:21;
A11: next <> result by A8,SFMASTR1:21;
A12: N <> rem2 by A6,SFMASTR1:21;
A13: N <> aux by A6,SFMASTR1:21;
A14: aux <> rem2 by SFMASTR1:22;
A15: for u being State of SCM+FSA st ex au, ne, re being Element of NAT st u
.aux = au & u.next = ne & u.result = re & u.N = n & Fusc n = ne * Fusc au + re
* Fusc (au+1) ex au1, ne1, re1 being Element of NAT st IExec(I, u).aux = au1 &
IExec(I, u).next = ne1 & IExec(I, u).result = re1 & IExec(I, u).N = n & Fusc n
  = ne1 * Fusc au1 + re1 * Fusc (au1+1) & au1 = u.aux div 2
  proof
    let u be State of SCM+FSA;
    given au, ne, re being Element of NAT such that
A16: u.aux = au and
A17: u.next = ne and
A18: u.result = re and
A19: u.N = n and
A20: Fusc n = ne * Fusc au + re * Fusc (au+1);
A21: (Initialized IExec(I3i0 ';' I3i1, u)).next = IExec(I3i0 ';' I3i1, u).
    next by SCMFSA6C:3
      .= Exec(I3i1, IExec(I3i0, u)).next by SCMFSA6C:7
      .= IExec(I3i0, u).next by A4,A3,SCMFSA_2:93
      .= ne by A17,SCMFSA7B:9,SFMASTR1:22;
A22: (Initialized IExec(I3i0 ';' I3i1, u)).aux = IExec(I3i0 ';' I3i1, u).
    aux by SCMFSA6C:3
      .= Exec(I3i1, IExec(I3i0, u)).aux by SCMFSA6C:7
      .= IExec(I3i0, u).aux div IExec(I3i0, u).rem2 by A14,SCMFSA_2:93
      .= u.aux div IExec(I3i0, u).rem2 by SCMFSA7B:9,SFMASTR1:22
      .= u.aux div 2 by SCMFSA7B:9;
A23: (Initialized IExec(I3i0 ';' I3i1, u)).result = IExec(I3i0 ';' I3i1, u)
    .result by SCMFSA6C:3
      .= Exec(I3i1, IExec(I3i0, u)).result by SCMFSA6C:7
      .= IExec(I3i0, u).result by A9,A10,SCMFSA_2:93
      .= re by A10,A18,SCMFSA7B:9;
A24: (Initialized IExec(I3i0 ';' I3i1, u)).N = IExec(I3i0 ';' I3i1, u).N by
SCMFSA6C:3
      .= Exec(I3i1, IExec(I3i0, u)).N by SCMFSA6C:7
      .= IExec(I3i0, u).N by A12,A13,SCMFSA_2:93
      .= n by A12,A19,SCMFSA7B:9;
A25: IExec(I3i0 ';' I3i1, u).rem2 = Exec(I3i1, IExec(I3i0, u)).rem2 by
SCMFSA6C:7
      .= IExec(I3i0, u).aux mod IExec(I3i0, u).rem2 by SCMFSA_2:93
      .= u.aux mod IExec(I3i0, u).rem2 by SCMFSA7B:9,SFMASTR1:22
      .= u.aux mod 2 by SCMFSA7B:9;
    per cases;
    suppose
A26:  au is even;
      reconsider ne1 = ne + re as Element of NAT;
      reconsider au1 = u.aux div 2 as Element of NAT by A16,INT_1:16,82;
      take au1, ne1, re;
      consider k being Element of NAT such that
A27:  au = 2*k by A26,ABIAN:def 2;
A28:  u.aux mod 2 = (2*k + 0) mod 2 by A16,A27
        .= 0 mod 2 by NAT_D:21
        .= 0 by NAT_D:26;
      IExec(I, u).aux = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).aux by SCMFSA6C:1
        .= IExec(I3I2I0, IExec(I3i0 ';' I3i1, u)).aux by A25,A28,SCMFSA8B:21
        .= Exec(AddTo(next, result), Initialized IExec(I3i0 ';' I3i1, u)).aux
      by SCMFSA6C:6
        .= u.aux div 2 by A4,A22,SCMFSA_2:90;
      hence IExec(I, u).aux = au1;
      thus IExec(I, u).next = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).next by
SCMFSA6C:1
        .= IExec(I3I2I0, IExec(I3i0 ';' I3i1, u)).next by A25,A28,SCMFSA8B:21
        .= Exec(AddTo(next, result), Initialized IExec(I3i0 ';' I3i1, u)).
      next by SCMFSA6C:6
        .= ne1 by A21,A23,SCMFSA_2:90;
      thus IExec(I, u).result = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).result by
SCMFSA6C:1
        .= IExec(I3I2I0, IExec(I3i0 ';' I3i1, u)).result by A25,A28,SCMFSA8B:21
        .= Exec(AddTo(next, result), Initialized IExec(I3i0 ';' I3i1, u)).
      result by SCMFSA6C:6
        .= re by A11,A23,SCMFSA_2:90;
      thus IExec(I, u).N = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).N by SCMFSA6C:1
        .= IExec(I3I2I0, IExec(I3i0 ';' I3i1, u)).N by A25,A28,SCMFSA8B:21
        .= Exec(AddTo(next, result), Initialized IExec(I3i0 ';' I3i1, u)).N
      by SCMFSA6C:6
        .= n by A7,A24,SCMFSA_2:90;
      au1 = k by A16,A27,NAT_D:20;
      hence Fusc n = ne1 * Fusc au1 + re * Fusc (au1+1) by A20,A27,PRE_FF:22;
      thus thesis;
    end;
    suppose
A29:  au is odd;
      reconsider re1 = ne + re as Element of NAT;
      reconsider au1 = u.aux div 2 as Element of NAT by A16,INT_1:16,82;
      take au1, ne, re1;
      consider k being Element of NAT such that
A30:  au = 2*k +1 by A29,ABIAN:9;
A31:  u.aux mod 2 = 1 mod 2 by A16,A30,NAT_D:21
        .= 1 by NAT_D:24;
      IExec(I, u).aux = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).aux by SCMFSA6C:1
        .= IExec(I3I2I1, IExec(I3i0 ';' I3i1, u)).aux by A25,A31,SCMFSA8B:21
        .= Exec(AddTo(result, next), Initialized IExec(I3i0 ';' I3i1, u)).aux
      by SCMFSA6C:6
        .= u.aux div 2 by A9,A22,SCMFSA_2:90;
      hence IExec(I, u).aux = au1;
      thus IExec(I, u).next = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).next by
SCMFSA6C:1
        .= IExec(I3I2I1, IExec(I3i0 ';' I3i1, u)).next by A25,A31,SCMFSA8B:21
        .= Exec(AddTo(result, next), Initialized IExec(I3i0 ';' I3i1, u)).
      next by SCMFSA6C:6
        .= ne by A11,A21,SCMFSA_2:90;
      thus IExec(I, u).result = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).result by
SCMFSA6C:1
        .= IExec(I3I2I1, IExec(I3i0 ';' I3i1, u)).result by A25,A31,SCMFSA8B:21
        .= Exec(AddTo(result, next), Initialized IExec(I3i0 ';' I3i1, u)).
      result by SCMFSA6C:6
        .= re1 by A21,A23,SCMFSA_2:90;
      thus IExec(I, u).N = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).N by SCMFSA6C:1
        .= IExec(I3I2I1, IExec(I3i0 ';' I3i1, u)).N by A25,A31,SCMFSA8B:21
        .= Exec(AddTo(result, next), Initialized IExec(I3i0 ';' I3i1, u)).N
      by SCMFSA6C:6
        .= n by A1,A24,SCMFSA_2:90;
      au1 = 2*k div 2 by A16,A30,NAT_2:28
        .= k by NAT_D:20;
      hence Fusc n = ne * Fusc au1 + re1 * Fusc (au1+1) by A20,A30,PRE_FF:21;
      thus thesis;
    end;
  end;
A32: It.intloc 0 = 1 by SCMFSA6C:3;
A33: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT;
    given au, ne, re being Element of NAT such that
A34: SWt.k.aux = au and
A35: SWt.k.next = ne and
A36: SWt.k.result = re and
A37: SWt.k.N = n and
A38: Fusc n = ne * Fusc au + re * Fusc (au+1);
A39: SWt.k.intloc 0 = 1 by A32,Th39;
    per cases;
    suppose
A40:  SWt.k.aux > 0;
      consider au1, ne1, re1 being Element of NAT such that
A41:  IExec(I, SWt.k).aux = au1 and
A42:  IExec(I, SWt.k).next = ne1 and
A43:  IExec(I, SWt.k).result = re1 and
A44:  IExec(I, SWt.k).N = n and
A45:  Fusc n = ne1 * Fusc au1 + re1 * Fusc (au1+1) and
      au1 = SWt.k.aux div 2 by A15,A34,A35,A36,A37,A38;
      take au1, ne1, re1;
A46:  DataPart SWt.(k+1) = DataPart IExec(I, SWt.k) by A39,A40,Th38;
      hence SWt.(k+1).aux = au1 by A41,SCMFSA6A:38;
      thus SWt.(k+1).next = ne1 by A46,A42,SCMFSA6A:38;
      thus SWt.(k+1).result = re1 by A46,A43,SCMFSA6A:38;
      thus SWt.(k+1).N = n by A46,A44,SCMFSA6A:38;
      thus thesis by A45;
    end;
    suppose
A47:  SWt.k.aux <= 0;
      take au, ne, re;
A48:  DataPart SWt.(k+1) = DataPart SWt.k by A47,Th37;
      hence SWt.(k+1).aux = au by A34,SCMFSA6A:38;
      thus SWt.(k+1).next = ne by A35,A48,SCMFSA6A:38;
      thus SWt.(k+1).result = re by A36,A48,SCMFSA6A:38;
      thus SWt.(k+1).N = n by A37,A48,SCMFSA6A:38;
      thus thesis by A38;
    end;
  end;
  t.intloc 0 = 1 by SCMFSA6B:35;
  then
A49: DataPart t = DataPart It by SCMFSA8C:27;
A50: X[0]
  proof
    take au = n;
    take ne = 1;
    take re = 0;
A51: SWt.0 = It by SCMFSA_9:def 5;
    hence SWt.0.aux = t.aux by A49,SCMFSA6A:38
      .= Exec(i2, IExec(i0 ';' i1, s)).aux by SCMFSA6C:7
      .= IExec(i0 ';' i1, s).N by SCMFSA_2:89
      .= Exec(i1, Exec(i0, Initialized s)).N by SCMFSA6C:9
      .= Exec(i0, Initialized s).N by A7,SCMFSA_2:89
      .= (Initialized s).N by A1,SCMFSA_2:91
      .= au by A2,SCMFSA6C:3;
    thus SWt.0.next = t.next by A49,A51,SCMFSA6A:38
      .= Exec(i2, IExec(i0 ';' i1, s)).next by SCMFSA6C:7
      .= IExec(i0 ';' i1, s).next by A4,SCMFSA_2:89
      .= Exec(i1, Exec(i0, Initialized s)).next by SCMFSA6C:9
      .= Exec(i0, Initialized s).intloc 0 by SCMFSA_2:89
      .= (Initialized s).intloc 0 by SCMFSA_2:91
      .= ne by SCMFSA6C:3;
    thus SWt.0.result = t.result by A49,A51,SCMFSA6A:38
      .= Exec(i2, IExec(i0 ';' i1, s)).result by SCMFSA6C:7
      .= IExec(i0 ';' i1, s).result by A9,SCMFSA_2:89
      .= Exec(i1, Exec(i0, Initialized s)).result by SCMFSA6C:9
      .= Exec(i0, Initialized s).result by A11,SCMFSA_2:89
      .= (Initialized s).result - (Initialized s).result by SCMFSA_2:91
      .= re;
    thus SWt.0.N = t.N by A49,A51,SCMFSA6A:38
      .= Exec(i2, IExec(i0 ';' i1, s)).N by SCMFSA6C:7
      .= IExec(i0 ';' i1, s).N by A13,SCMFSA_2:89
      .= Exec(i1, Exec(i0, Initialized s)).N by SCMFSA6C:9
      .= Exec(i0, Initialized s).N by A7,SCMFSA_2:89
      .= (Initialized s).N by A1,SCMFSA_2:91
      .= n by A2,SCMFSA6C:3;
    thus thesis;
  end;
A52: for k being Element of NAT holds X[k] from NAT_1:sch 1(A50, A33);
  for k being Element of NAT holds f.(SWt.(k+1)) < f.(SWt.k) or SWt.k.aux
  <= 0
  proof
    let k be Element of NAT;
    consider au, ne, re being Element of NAT such that
A53: SWt.k.aux = au and
A54: SWt.k.next = ne & SWt.k.result = re & SWt.k.N = n & Fusc n = ne *
    Fusc au + re * Fusc (au+1) by A52;
A55: f.(SWt.k) = abs(SWt.k.aux) by A5
      .= au by A53,ABSVALUE:def 1;
    now
      consider au1, ne1, re1 being Element of NAT such that
A56:  IExec(I, SWt.k).aux = au1 and
      IExec(I, SWt.k).next = ne1 and
      IExec(I, SWt.k).result = re1 and
      IExec(I, SWt.k).N = n and
      Fusc n = ne1 * Fusc au1 + re1 * Fusc (au1+1) and
A57:  au1 = SWt.k.aux div 2 by A15,A53,A54;
      assume
A58:  au > 0;
      SWt.k.intloc 0 = 1 by A32,Th39;
      then DataPart SWt.(k+1) = DataPart IExec(I, SWt.k) by A53,A58,Th38;
      then
A59:  SWt.(k+1).aux = au1 by A56,SCMFSA6A:38;
      f.(SWt.(k+1)) = abs(SWt.(k+1).aux) by A5
        .= au1 by A59,ABSVALUE:def 1;
      hence f.(SWt.(k+1)) < f.(SWt.k) by A53,A55,A58,A57,INT_1:83;
    end;
    hence thesis by A53;
  end;
  then
A60: WithVariantWhile>0 aux, I, It by Def5;
  then consider k being Element of NAT such that
A61: ExitsAtWhile>0(aux, I, It) = k and
A62: (StepWhile>0(aux, I, It).k).aux <= 0 and
  for i being Element of NAT st SWt.i.aux <= 0 holds k <= i and
  DataPart (Comput(ProgramPart((It +* (while>0(aux, I) +* SAt))),(It +* (
while>0(aux, I) +* SAt)), (LifeSpan(ProgramPart(It +*
  (while>0(aux, I) +* SAt)),It +*
  (while>0(aux, I) +* SAt))))) = DataPart StepWhile>0(aux, I, It).k by Def6;
A63: DataPart IExec(I3, t) = DataPart SWt.k by A60,A61,Th42;
  consider au, ne, re being Element of NAT such that
A64: SWt.k.aux = au and
  SWt.k.next = ne and
A65: SWt.k.result = re and
A66: SWt.k.N = n and
A67: Fusc n = ne * Fusc au + re * Fusc (au+1) by A52;
A68: au = 0 by A62,A64;
  I3 is_closed_on It & I3 is_halting_on It by A60,Th34;
  then
A69: I3 is_closed_on t & I3 is_halting_on t by A49,SCMFSA8B:8;
  hence IExec(Fusc_macro(N, result), s).result = IExec(I3, t).result by
SFMASTR1:8
    .= Fusc n by A65,A67,A68,A63,PRE_FF:17,SCMFSA6A:38;
  thus IExec(Fusc_macro(N, result), s).N = IExec(I3, t).N by A69,SFMASTR1:8
    .= n by A66,A63,SCMFSA6A:38;
end;

