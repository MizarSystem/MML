:: The { \bf while } macro instructions of SCM+FSA, Part { II }
::  by Piotr Rudnicki
::
:: Received June 3, 1998
:: Copyright (c) 1998-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, INT_1, AMI_1, SCMFSA_2, SF_MASTR, FUNCOP_1,
      FUNCT_1, FINSUB_1, CARD_3, RELAT_1, TARSKI, AMISTD_2, XBOOLE_0, CARD_1,
      SCMFSA8A, AMI_3, FSM_1, SCMFSA7B, SCMFSA8B, ARYTM_3, TURING_1, SCMFSA6A,
      ARYTM_1, VALUED_1, FUNCT_4, SCMFSA_9, UNIALG_2, SCMFSA6B, XXREAL_0,
      CIRCUIT2, GRAPHSP, NAT_1, SCMFSA6C, MSUALG_1, SFMASTR1, PRE_FF, COMPLEX1,
      ABIAN, SCMFSA9A, ORDINAL1, PARTFUN1, EXTPRO_1, RELOC, PBOOLE, COMPOS_1,
      MEMSTR_0, SCMPDS_4;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, FINSUB_1,
      FUNCOP_1, INT_1, ABIAN, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, PRE_FF,
      CARD_3, FUNCT_4, PBOOLE, VALUED_1, INT_2, XXREAL_0, ORDINAL1, NAT_1,
      MEMSTR_0, COMPOS_0, COMPOS_1, EXTPRO_1, AMISTD_1, AMISTD_2, SCMFSA_2,
      SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA_7, SCMFSA7B, SCMFSA8A,
      SCMFSA8B, SCMFSA_9, SFMASTR1, SCMFSA_M;
 constructors NAT_D, PRE_FF, ABIAN, SCMFSA_7, SCMFSA6A, SCMFSA6B, MEMSTR_0,
      SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA_9, SFMASTR1, AMISTD_2, RELSET_1,
      PRE_POLY, XXREAL_2, PBOOLE, SCMFSA7B, SCMFSA8C, FUNCT_4, AMISTD_1, AMI_3,
      SCMFSA_M, SF_MASTR;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FINSET_1,
      FINSUB_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, ABIAN,
      SCMFSA_2, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B,
      SCMFSA_9, SFMASTR1, VALUED_1, FUNCT_2, RELAT_1, AFINSQ_1, FUNCT_4,
      FUNCOP_1, SCMFSA10, AMISTD_2, SCMFSA6A, COMPOS_1, EXTPRO_1, PBOOLE,
      STRUCT_0, MEMSTR_0, FINSEQ_1, AMI_3, COMPOS_0, SCMFSA_M;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, SCMFSA6A, AFINSQ_1, COMPOS_1, EXTPRO_1, AMISTD_2,
      MEMSTR_0, SCMFSA_M;
 theorems TARSKI, ZFMISC_1, ABSVALUE, NAT_1, INT_1, NAT_2, FUNCT_1, FUNCT_2,
      GRFUNC_1, FUNCOP_1, FUNCT_4, PRE_FF, ABIAN, SCMFSA_2, MEMSTR_0, SCMFSA_4,
      SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B,
      SCMFSA8C, SCMFSA_9, SFMASTR1, RELAT_1, XBOOLE_0, XBOOLE_1, CARD_3,
      XREAL_1, XXREAL_0, ORDINAL1, NAT_D, VALUED_1, PBOOLE, PARTFUN1, FINSEQ_4,
      COMPOS_1, EXTPRO_1, SCMFSA_M;
 schemes FUNCT_2, NAT_1;

begin :: SCM+FSA preliminaries

reserve p,p1,p2,h for Instruction-Sequence of SCM+FSA;

reserve k, l, n for Element of NAT,
  j for Integer,
  i for Instruction of SCM+FSA;

theorem Th1: :: singleUsed
  UsedIntLoc (l .--> i) = UsedIntLoc i
proof
  set p = (l .--> i);
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc p = Union (UIL * p) by SF_MASTR:def 2;
A3: dom UIL = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
  thus UsedIntLoc p = union rng (UIL * ({l} --> i)) by A2,CARD_3:def 4
    .= union rng ({l} --> UIL.i) by A3,FUNCOP_1:17
    .= union {UIL.i} by FUNCOP_1:8
    .= union {UsedIntLoc i} by A1
    .= UsedIntLoc i by ZFMISC_1:25;
end;

theorem Th2: :: singleUsedF:
  UsedInt*Loc (l .--> i) = UsedInt*Loc i
proof
  set p = (l .--> i);
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc p = Union (UIL * p) by SF_MASTR:def 4;
A3: dom UIL = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
  thus UsedInt*Loc p = union rng (UIL * ({l} --> i)) by A2,CARD_3:def 4
    .= union rng ({l} --> UIL.i) by A3,FUNCOP_1:17
    .= union {UIL.i} by FUNCOP_1:8
    .= union {UsedInt*Loc i} by A1
    .= UsedInt*Loc i by ZFMISC_1:25;
end;

theorem Th3: :: StopUsed:
  UsedIntLoc Stop SCM+FSA = {} by Th1,SF_MASTR:13;

theorem Th4: :: StopUsedF:
  UsedInt*Loc Stop SCM+FSA = {}
proof
  thus UsedInt*Loc Stop SCM+FSA
    = UsedInt*Loc halt SCM+FSA by Th2
    .= {} by SF_MASTR:32;
end;

theorem Th5: :: GotoUsed:
  UsedIntLoc Goto l = {}
proof
  Goto l =  0 .--> goto l by SCMFSA8A:def 1;
  hence UsedIntLoc Goto l = UsedIntLoc goto l by Th1
    .= {} by SF_MASTR:15;
end;

theorem Th6: :: GotoUsedF:
  UsedInt*Loc Goto l = {}
proof
  Goto l =  0 .--> goto l by SCMFSA8A:def 1;
  hence UsedInt*Loc Goto l = UsedInt*Loc goto l by Th2
    .= {} by SF_MASTR:32;
end;

reserve s, s1, s2 for State of SCM+FSA,
  a for read-write Int-Location,
  b for Int-Location,
  I, J for Program of SCM+FSA,
  Ig for good Program of SCM+FSA,
  i, j, k, m, n for Element of NAT;

set D = Int-Locations \/ FinSeq-Locations;
set SAt = Start-At(0,SCM+FSA);

theorem Th7:
  UsedIntLoc if=0(b, I, J) = {b} \/ UsedIntLoc I \/ UsedIntLoc J
proof
  set I5 = Stop SCM+FSA;
  set a = b;
  set I1 = a =0_goto  (card J + 3);
  set I3 = Goto  (card I + 1);
  thus UsedIntLoc if=0(a, I, J) = UsedIntLoc (I1 ";" J ";" I3 ";" I ";" I5) by
SCMFSA8B:def 1
    .= (UsedIntLoc (I1 ";" J ";" I3 ";" I)) \/ {} by Th3,SF_MASTR:27
    .= (UsedIntLoc (I1 ";" J ";" I3)) \/ UsedIntLoc I by SF_MASTR:27
    .= (UsedIntLoc (I1 ";" J)) \/ UsedIntLoc I3 \/ UsedIntLoc I by SF_MASTR:27
    .= (UsedIntLoc (I1 ";" J)) \/ {} \/ UsedIntLoc I by Th5
    .= UsedIntLoc I1 \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:29
    .= {a} \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:16
    .= {a} \/ UsedIntLoc I \/ UsedIntLoc J by XBOOLE_1:4;
end;

theorem Th8: :: eifUsedF:
  for a being Int-Location holds UsedInt*Loc if=0(a, I, J) =
  UsedInt*Loc I \/ UsedInt*Loc J
proof
  set I5 = Stop SCM+FSA;
  let a be Int-Location;
  set I1 = a =0_goto  (card J + 3);
  set I3 = Goto  (card I + 1);
  thus UsedInt*Loc if=0(a, I, J) = UsedInt*Loc (I1 ";" J ";" I3 ";" I ";" I5)
  by SCMFSA8B:def 1
    .= (UsedInt*Loc (I1 ";" J ";" I3 ";" I)) \/ {} by Th4,SF_MASTR:43
    .= (UsedInt*Loc (I1 ";" J ";" I3)) \/ UsedInt*Loc I by SF_MASTR:43
    .= (UsedInt*Loc (I1 ";" J)) \/ UsedInt*Loc I3 \/ UsedInt*Loc I by
SF_MASTR:43
    .= (UsedInt*Loc (I1 ";" J)) \/ {} \/ UsedInt*Loc I by Th6
    .= UsedInt*Loc I1 \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:45
    .= {} \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:32
    .= UsedInt*Loc I \/ UsedInt*Loc J;
end;

theorem Th9: :: ifUsed:
  UsedIntLoc if>0(b, I, J) = {b} \/ UsedIntLoc I \/ UsedIntLoc J
proof
  set I5 = Stop SCM+FSA;
  set a = b;
  set I1 = a >0_goto  (card J + 3);
  set I3 = Goto  (card I + 1);
  thus UsedIntLoc if>0(a, I, J) = UsedIntLoc (I1 ";" J ";" I3 ";" I ";" I5) by
SCMFSA8B:def 2
    .= (UsedIntLoc (I1 ";" J ";" I3 ";" I)) \/ {} by Th3,SF_MASTR:27
    .= (UsedIntLoc (I1 ";" J ";" I3)) \/ UsedIntLoc I by SF_MASTR:27
    .= (UsedIntLoc (I1 ";" J)) \/ UsedIntLoc I3 \/ UsedIntLoc I by SF_MASTR:27
    .= (UsedIntLoc (I1 ";" J)) \/ {} \/ UsedIntLoc I by Th5
    .= UsedIntLoc I1 \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:29
    .= {a} \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:16
    .= {a} \/ UsedIntLoc I \/ UsedIntLoc J by XBOOLE_1:4;
end;

theorem Th10: :: ifUsedF:
  UsedInt*Loc if>0(b, I, J) = UsedInt*Loc I \/ UsedInt*Loc J
proof
  set I5 = Stop SCM+FSA;
  set a = b;
  set I1 = a >0_goto  (card J + 3);
  set I3 = Goto  (card I + 1);
  thus UsedInt*Loc if>0(a, I, J) = UsedInt*Loc (I1 ";" J ";" I3 ";" I ";" I5)
  by SCMFSA8B:def 2
    .= (UsedInt*Loc (I1 ";" J ";" I3 ";" I)) \/ {} by Th4,SF_MASTR:43
    .= (UsedInt*Loc (I1 ";" J ";" I3)) \/ UsedInt*Loc I by SF_MASTR:43
    .= (UsedInt*Loc (I1 ";" J)) \/ UsedInt*Loc I3 \/ UsedInt*Loc I by
SF_MASTR:43
    .= (UsedInt*Loc (I1 ";" J)) \/ {} \/ UsedInt*Loc I by Th6
    .= UsedInt*Loc I1 \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:45
    .= {} \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:32
    .= UsedInt*Loc I \/ UsedInt*Loc J;
end;

begin :: while=0, general

Lm1: for a being Int-Location, I being Program of SCM+FSA holds card I +4 in
dom if=0(a,I ";" Goto  0,Stop SCM+FSA) & if=0(a,I ";" Goto  0,Stop
SCM+FSA).(card I +4) = goto (( 0)+(card I +4))

proof
  set J = Stop SCM+FSA;
  set G = Goto  0;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ";" G;
  set i = a =0_goto  (card J + 3);
  set c4 = card I + 4;
  set Lc4 = c4;
  set Mi= Macro i ";" J ";" Goto  (card I1 + 1) ";" I;
A1: card Stop SCM+FSA = 1 by COMPOS_1:4;
A2: card (G ";" J) = card G + card J by SCMFSA6A:21
    .= 1 + 1 by A1,SCMFSA8A:15
    .= 2;

A3: if=0(a, I1, J) = i ";" J ";" Goto  (card I1 + 1) ";" (I ";" G) ";"
  J by SCMFSA8B:def 1

    .= Mi ";" G ";" J by SCMFSA6A:25
    .= Mi ";" (G ";" J) by SCMFSA6A:25;
  then card if=0(a, I1,J) = card Mi + card (G ";" J) by SCMFSA6A:21;
  then
A4: card Mi = card if=0(a,I1,J)-card (G ";" J)
    .= card I + 6 - 2 by A2,SCMFSA_9:1
    .= c4;
  then
A5: not Lc4 in dom Mi;
  set GJ = G ";" J;
A6: G =  0 .--> goto  0 by SCMFSA8A:def 1;
  then
A7: G. 0 = goto  0 by FUNCOP_1:72;
  dom G = { 0} by A6,FUNCOP_1:13;
  then
A8:  0 in dom G by TARSKI:def 1;
A9: dom G c= dom GJ by SCMFSA6A:17;

  then  0 + c4 in { il+c4 where il is Element of NAT: il in dom GJ} by A8
;

  then
A10:  c4 in dom Shift(GJ,c4) by VALUED_1:def 12;
  then
A11: Shift(GJ,c4)/.Lc4 = Shift(GJ,c4).( 0 +c4) by PARTFUN1:def 6
    .= GJ. 0 by A8,A9,VALUED_1:def 12
    .= goto  0 by A8,A7,SCMFSA6A:15;
A12: card Stop SCM+FSA = 1 by COMPOS_1:4;
  card I1 = card I + card G by SCMFSA6A:21
    .= card I +1 by SCMFSA8A:15;
  then card I1 + card J + 3 = card I +4 +1 by A12;
  then c4 < card I1 + card J + 3 by NAT_1:13;
  hence
A13: Lc4 in dom if=0(a,I1,J) by SCMFSA8C:27;
A14: Reloc(GJ,c4) = IncAddr(Shift(GJ,c4),c4) by COMPOS_1:34;
A15: dom if=0(a,I1,J) = dom Directed Mi \/ dom Reloc(GJ, c4
  ) by A3,A4,FUNCT_4:def 1;

  then dom if=0(a,I1,J) = dom Mi \/ dom Reloc(GJ, c4) by FUNCT_4:99;

  then Lc4 in dom Reloc(GJ, c4) by A13,A5,XBOOLE_0:def 3;

  hence if=0(a,I1,J).Lc4 = (Reloc(GJ,c4)).Lc4 by A13,A3,A4,A15,FUNCT_4:def 1
    .= IncAddr( goto  0, c4 ) by A10,A11,A14,COMPOS_1:def 21
    .= goto (( 0)+c4) by SCMFSA_4:1;
end;

Lm2: for a being Int-Location, I being Program of SCM+FSA holds UsedIntLoc
if=0(a,I ";" Goto  0,Stop SCM+FSA) = UsedIntLoc (if=0(a,I ";" Goto
0,Stop SCM+FSA) +* (  (card I +4) .--> goto  0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 =  (card I + 4);
  set if0 = if=0(a,I ";" Goto  0,Stop SCM+FSA);
  set ic4 =  (card I +4) .--> goto  0;

  consider UIL1 being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedIntLoc i and
A2: UsedIntLoc if0 = Union (UIL1 * if0) by SF_MASTR:def 2;
A3: dom UIL1 = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,RELAT_1:def 19;
A6: dom ic4 = { (card I +4)} by FUNCOP_1:13;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
     (card I +4) in dom if0 by Lm1;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
FUNCT_4:def 1,ZFMISC_1:31;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,RELAT_1:def 19;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:27
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:27;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:12
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:11
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:12;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:12
        .= UIL1.(goto (( 0)+(card I +4))) by A12,Lm1
        .= UsedIntLoc goto (( 0)+(card I +4)) by A1
        .= {} by SF_MASTR:15
        .= UsedIntLoc goto  0 by SF_MASTR:15
        .= UIL1.(goto  0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:72
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:13
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:12;
    end;
  end;

  consider UIL2 being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A14: UsedIntLoc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 2;
  for c be Element of the InstructionsF of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedIntLoc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:63;
  hence thesis by A2,A14,A4,FUNCT_1:2;
end;

Lm3: for a being Int-Location, I being Program of SCM+FSA holds UsedInt*Loc
if=0(a,I ";" Goto  0,Stop SCM+FSA) = UsedInt*Loc (if=0(a,I ";" Goto
 0,Stop SCM+FSA) +* (  (card I +4) .--> goto  0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 =  (card I + 4);
  set if0 = if=0(a,I ";" Goto  0,Stop SCM+FSA);
  set ic4 =  (card I +4) .--> goto  0;

  consider UIL1 being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedInt*Loc i and
A2: UsedInt*Loc if0 = Union (UIL1 * if0) by SF_MASTR:def 4;
A3: dom UIL1 = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,RELAT_1:def 19;
A6: dom ic4 = { (card I +4)} by FUNCOP_1:13;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
     (card I +4) in dom if0 by Lm1;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
FUNCT_4:def 1,ZFMISC_1:31;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,RELAT_1:def 19;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:27
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:27;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:12
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:11
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:12;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:12
        .= UIL1.(goto (( 0)+(card I +4))) by A12,Lm1
        .= UsedInt*Loc goto (( 0)+(card I +4)) by A1
        .= {} by SF_MASTR:32
        .= UsedInt*Loc goto  0 by SF_MASTR:32
        .= UIL1.(goto  0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:72
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:13
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:12;
    end;
  end;

  consider UIL2 being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A14: UsedInt*Loc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 4;
  for c be Element of the InstructionsF of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedInt*Loc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:63;
  hence thesis by A2,A14,A4,FUNCT_1:2;
end;

theorem :: ewhileUsed:
  UsedIntLoc while=0(b, I) = {b} \/ UsedIntLoc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ";" Goto  0;
  while=0(a, I) = if=0(a, IG, J) +* (  (card I +4) .--> goto
  0 ) by SCMFSA_9:def 1;
  hence UsedIntLoc while=0(a, I) = (UsedIntLoc if=0(a, IG, J)) by Lm2
    .= {a} \/ UsedIntLoc IG \/ UsedIntLoc J by Th7
    .= {a} \/ (UsedIntLoc I \/ UsedIntLoc Goto  0) \/ UsedIntLoc J by
SF_MASTR:27
    .= {a} \/ (UsedIntLoc I \/ {}) \/ UsedIntLoc J by Th5
    .= {a} \/ UsedIntLoc I by Th3;
end;

theorem :: ewhileUsedF:
  UsedInt*Loc while=0(b, I) = UsedInt*Loc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ";" Goto  0;
  while=0(a, I) = if=0(a, IG, J) +* (  (card I +4) .--> goto
  0 ) by SCMFSA_9:def 1;
  hence UsedInt*Loc while=0(a, I) = (UsedInt*Loc if=0(a, IG, J)) by Lm3
    .= UsedInt*Loc IG \/ UsedInt*Loc J by Th8
    .= (UsedInt*Loc I \/ UsedInt*Loc Goto  0) \/ UsedInt*Loc J by SF_MASTR:43
    .= UsedInt*Loc I \/ {} by Th4,Th6
    .= UsedInt*Loc I;
end;

definition let p;
  let s be State of SCM+FSA, a be read-write Int-Location, I be Program of
  SCM+FSA;
  pred ProperBodyWhile=0 a, I, s, p means
  :Def1:
  for k being Element of NAT st StepWhile=0(a,I,p,s).k.a = 0 holds
   I is_closed_on StepWhile=0(a,I,p,s).k, p+*while=0(a,I) &
   I is_halting_on StepWhile=0(a,I,p,s).k, p+*while=0(a,I);
  pred WithVariantWhile=0 a, I, s, p means
  :Def2:
  ex f being Function of product the_Values_of SCM+FSA, NAT
   st for k being Element of NAT
    holds f.(StepWhile=0(a,I,p,s).(k+1)) < f.(StepWhile=0(a,I,p,s).k)
      or StepWhile=0(a,I,p,s).k.a <> 0;
end;

theorem Th13: :: eParaProper:
  for I being parahalting Program of SCM+FSA holds
  ProperBodyWhile=0 a,I,s,p
proof
  let I be parahalting Program of SCM+FSA;
  let k be Element of NAT such that
  StepWhile=0(a,I,p,s).k.a = 0;
  thus I is_closed_on StepWhile=0(a,I,p,s).k, p+*while=0(a,I) by SCMFSA7B:18;
  thus thesis by SCMFSA7B:19;
end;

theorem Th14: :: SCMFSA_9:24, corrected
  ProperBodyWhile=0 a,I,s,p & WithVariantWhile=0 a,I,s,p implies
  while=0(a,I) is_halting_on s,p & while=0(a,I) is_closed_on s,p
proof
  assume
A1: for k being Element of NAT st StepWhile=0(a,I,p,s).k.a = 0 holds I
  is_closed_on StepWhile=0(a,I,p,s).k, p+*while=0(a,I) &
  I is_halting_on StepWhile=0(a,I,p,s).k, p+*while=0(a,I);
  set s1 = Initialize s,
      p1 = p +* while=0(a,I);
A2:  p1 +* while=0(a,I) = p1;
  defpred S[Element of NAT] means StepWhile=0(a,I,p,s).$1.a <> 0;
  given f being Function of product the_Values_of SCM+FSA,NAT such that
A3: for k being Element of NAT holds (f.(StepWhile=0(a,I,p,s).(k+1)) < f.(
  StepWhile=0(a,I,p,s).k) or (StepWhile=0(a,I,p,s).k).a <> 0 );
  deffunc F(Nat) = f.(StepWhile=0(a,I,p,s).$1);
A4: for k holds ( F(k+1) < F(k) or S[k] ) by A3;
  consider m being Element of NAT such that
A5: S[m] and
A6: for n st S[n] holds m <= n from NAT_1:sch 18(A4);
  defpred P[Nat] means $1+1 <= m implies ex k st StepWhile=0(a,I,p,s)
  .($1+1)=Comput(p1,s1,k);
A7: now
    let k be Element of NAT;
    assume
A8: P[k];
    now
      set sk1=StepWhile=0(a,I,p,s).(k+1);
      set sk=StepWhile=0(a,I,p,s).k,
          pk = p +* while=0(a,I);
      assume
A9:   (k+1)+ 1 <= m;
      k + 0 < k+ (1+ 1) by XREAL_1:6;
      then k < m by A9,XXREAL_0:2;
      then
A10:   sk.a = 0 by A6;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:6;
      then consider n being Element of NAT such that
A11:  sk1 = Comput(p1,s1,n) by A8,A9,XXREAL_0:2;
A12:  sk1 = Comput(pk +* while=0(a,I), Initialize sk,
         LifeSpan(pk +* while=0(a,I) +* I,Initialize sk) + 3)
              by SCMFSA_9:def 4;
      take m=n +(LifeSpan(pk +* I,Initialize sk1) + 3);
      I is_closed_on sk,pk & I is_halting_on sk,pk by A1,A10;
      then IC sk1 =  0 by A12,A10,SCMFSA_9:22;
      then StepWhile=0(a,I,p,s).((k+1)+1)=Comput(p1,s1,
     (n +(LifeSpan(p1 +* I,
       Initialize(StepWhile=0(a,I,p,s).(k+1))) + 3)))
              by A11,SCMFSA_9:26;

     hence StepWhile=0(a,I,p,s).((k+1)+1)=Comput(p1,s1,m);
    end;
    hence P[k+1];
  end;
A13: P[0]
  proof
    assume 0+1 <= m;
    take n=(LifeSpan(p1 +* I,Initialize s) + 3);
    thus thesis by SCMFSA_9:25;
  end;
A14: for k being Element of NAT holds P[k] from NAT_1:sch 1(A13,A7);
    per cases;
    suppose
      m = 0;
      then s.a <> 0 by A5,SCMFSA_9:def 4;
      hence thesis by SCMFSA_9:18;
    end;
    suppose
A15:  m <> 0;
      set ii=(LifeSpan(p +* while=0(a,I) +* I,Initialize s) + 3);
      set sm=StepWhile=0(a,I,p,s).m,
          pm = p +* while=0(a,I);
      set sm1=Initialize sm,
          pm1 = pm +* while=0(a,I);
      consider i being Nat such that
A16:  m=i+1 by A15,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 12;
      set si=StepWhile=0(a,I,p,s).i,
          psi = p +* while=0(a,I);
A17:  sm= Comput(psi +* while=0(a,I),(Initialize si),
      (LifeSpan(psi +* I,Initialize si) + 3))
      by A16,SCMFSA_9:def 4;
      m=i+1 by A16;
      then consider n being Element of NAT such that
A18:  sm = Comput(p1,s1,n) by A14;
      i < m by A16,NAT_1:13;
      then
A19:  si.a = 0 by A6;
      then I is_closed_on si,psi & I is_halting_on si,psi by A1;
      then
      IC sm =  0 by A17,A19,SCMFSA_9:22;
      then Start-At(0,SCM+FSA) c= sm by MEMSTR_0:30;
      then
A20:  sm1=sm by FUNCT_4:98;
      while=0(a,I) is_halting_on sm,pm by A5,SCMFSA_9:18;
      then pm1 halts_on sm1 by SCMFSA7B:def 7;
      then consider j being Element of NAT such that
A21:  CurInstr(pm,Comput(pm,sm,j)) = halt SCM+FSA
by A20,EXTPRO_1:29;
A22: Comput(p1,s1,n+j)
 = Comput(p1,Comput(p1,s1,n),j) by EXTPRO_1:4;
      CurInstr(p1,Comput(p1,s1,n+j))
       = halt SCM+FSA by A18,A21,A22;
      then p1 halts_on s1 by EXTPRO_1:29;
      hence while=0(a,I) is_halting_on s,p by SCMFSA7B:def 7;
      now
        let q be Element of NAT;
        per cases;
        suppose
A23:      q <= ii;
A24:      StepWhile=0(a,I,p,s).0 = s by SCMFSA_9:def 4;
          then
A25:      s.a = 0 by A6,A15;
          then I is_closed_on s,p1 & I is_halting_on s,p1 by A1,A24;
          hence IC Comput(p1,s1,q) in dom while=0(a,I) by A23,A25,A2,
SCMFSA_9:22
;
        end;
        suppose
A26:      q > ii;
A27:      now
            take k=ii;
            thus StepWhile=0(a,I,p,s).1
            =Comput(p1,s1,k) & k <= q by A26,SCMFSA_9:25;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 &
           (ex k st StepWhile=0(a,I,p,s).$1
          = Comput(p1,s1,k) & k <= q);
A28:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A15,XREAL_1:6;
          then 1 <= m by NAT_1:13;
          then
A29:      ex k be Nat st P2[k] by A27;
          consider t be Nat such that
A30:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A28,A29);
          reconsider t as Element of NAT by ORDINAL1:def 12;
          per cases;
          suppose
            t=m;
            then consider r being Element of NAT such that
A31:          sm=Comput(p1,s1,r) and
A32:          r <= q by A30;
            consider x being Nat such that
A33:          q = r+x by A32,NAT_1:10;
A34:          while=0(a,I) is_closed_on sm,pm by A5,SCMFSA_9:18;
            reconsider x as Element of NAT by ORDINAL1:def 12;
            Comput(p1,s1,q) = Comput(p1,sm1,x) by A20,A31,A33,EXTPRO_1:4;
            hence IC Comput(p1,s1,q) in dom while=0(a,I) by A34,A2,
SCMFSA7B:def 6;
          end;
          suppose
A35:          t<>m;
            set Dt=StepWhile=0(a,I,p,s).t,
                pt = p +* while=0(a,I);
            consider y being Nat such that
A36:          t=y+1 by A30,NAT_1:6;
            reconsider y as Element of NAT by ORDINAL1:def 12;
            set Dy=StepWhile=0(a,I,p,s).y,
                py = p +* while=0(a,I);
A37:          Dt= Comput(py +* while=0(a,I),(Initialize Dy),
 (LifeSpan(py +* I,Initialize Dy) + 3)) by A36,SCMFSA_9:def 4;
            y+ 0 < t by A36,XREAL_1:6;
            then y < m by A30,XXREAL_0:2;
            then
A38:          Dy.a = 0 by A6;
            then I is_closed_on Dy,py & I is_halting_on Dy,py by A1;
            then
A39:          IC Dt = 0 by A37,A38,SCMFSA_9:22;
            consider z being Element of NAT such that
A40:          StepWhile=0(a,I,p,s).t=Comput(p1,s1,z) and
A41:          z <= q by A30;
            consider w being Nat such that
A42:          q = z+w by A41,NAT_1:10;
            reconsider w as Element of NAT by ORDINAL1:def 12;
A43: Dt = Initialize Dt by A40,A39,SCMFSA_9:26;
A44:          Comput(p1,s1,q)
              = Comput(pt +* while=0(a,I),Initialize Dt,w)
               by A43,A40,A42,EXTPRO_1:4;
            set z2=z +(LifeSpan(pt +* I,Initialize Dt) + 3);
A45:          t < m by A30,A35,XXREAL_0:1;
            now
              assume
A46:            z2 <= q;
A47:            now
                take k=z2;
                thus StepWhile=0(a,I,p,s).(t+1)
                =Comput(p1,s1,k) &
k <= q by A40,A39,A46,SCMFSA_9:26;
              end;
              t+1 <= m by A45,NAT_1:13;
              hence contradiction by A30,A47,XREAL_1:29;
            end;
            then
A48:          w < LifeSpan(pt +* I,Initialize Dt) + 3
by A42,XREAL_1:6;
A49:          Dt.a = 0 by A6,A45;
            then I is_closed_on Dt,pt & I is_halting_on Dt,pt by A1;
            hence IC Comput(p1,s1,q) in dom while=0(a,I)
             by A48,A44,A49,SCMFSA_9:22;
          end;
        end;
      end;
      hence while=0(a,I) is_closed_on s,p by SCMFSA7B:def 6;
    end;
end;

theorem Th15: :: SCMFSA_9:25, corrected
  for I being parahalting Program of SCM+FSA
   st WithVariantWhile=0 a, I, s, p
    holds while=0(a,I) is_halting_on s,p & while=0(a,I) is_closed_on s,p
proof
  let I be parahalting Program of SCM+FSA such that
A1: WithVariantWhile=0 a,I,s,p;
  ProperBodyWhile=0 a,I,s,p
  proof
    let k be Element of NAT;
    assume StepWhile=0(a,I,p,s).k.a = 0;
    thus thesis by SCMFSA7B:18,19;
  end;
  hence thesis by A1,Th14;
end;

theorem Th16: :: based on SCMFSA_9:10
  for s being 0-started State of SCM+FSA
   st while=0(a, I) c= p & s.a <> 0
  holds LifeSpan(p,s) = 4 & for k being Element of NAT
   holds DataPart Comput(p,s,k) = DataPart s
proof
  let s be 0-started State of SCM+FSA;
A1: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
  assume that
A2: while=0(a, I) c= p and
A3: s.a <> 0;
A4: p +* while=0(a, I) = p by A2,FUNCT_4:98;
  set i = a =0_goto  4;
  set s1 = Initialize s,
      p1 = p +* while=0(a,I);
A5: while=0(a,I) c= p1 by FUNCT_4:25;
A6: IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
  not a in dom Start-At(0,SCM+FSA) by SCMFSA_2:102;
  then
A7: s1.a = s.a by FUNCT_4:11;
A8:  1 in dom while=0(a,I) by SCMFSA_9:10;
A9: p1. 1 = while=0(a,I). 1 by A8,FUNCT_4:13
    .= goto  2 by SCMFSA_9:11;
A10: IC s1 = IC Start-At(0,SCM+FSA) by A6,FUNCT_4:13
    .=  0 by FUNCOP_1:72;
A11:  p1/.IC s1 = p1.IC s1 by PBOOLE:143;
  0 in dom while=0(a,I) by SCMFSA_9:10;
  then p1. 0 = while=0(a,I). 0 by FUNCT_4:13
    .= i by SCMFSA_9:11;
  then
A12: CurInstr(p1,s1) = i by A10,A11;
A13: Comput(p1,s1,0+1) = Following(p1,
Comput(p1,s1,0)) by EXTPRO_1:3
    .= Following(p1,s1)
    .= Exec(i,s1) by A12;
  set loc5=  (card I +5);
  set s5 = Comput(p1,s1,4),
      p5 = p1;
  set s4 = Comput(p1,s1,3),
      p4 = p1;
  set s3 = Comput(p1,s1,2),
      p3 = p1;
  set s2 = Comput(p1,s1,1);
A14:  2 in dom while=0(a,I) by SCMFSA_9:12;
A15: p3. 2 = while=0(a,I). 2
    by A14,FUNCT_4:13
    .= goto  3 by SCMFSA_9:16;
A16:  3 in dom while=0(a,I) by SCMFSA_9:12;
A17: p4. 3 = while=0(a,I) . 3 by A16,FUNCT_4:13
    .= goto loc5 by SCMFSA_9:15;
A18: loc5 in dom while=0(a,I) by SCMFSA_9:13;
A19: p5.loc5 = while=0(a,I).loc5 by A18,A5,GRFUNC_1:2
    .= halt SCM+FSA by SCMFSA_9:14;
A20: ( for c being Int-Location holds Exec(goto loc5, s4).c = s4.c)& for f
  being FinSeq-Location holds Exec(goto loc5, s4).f = s4.f by SCMFSA_2:69;
A21: ( for c being Int-Location holds Exec(goto  2, s2).c = s2.c)& for
f being FinSeq-Location holds Exec(goto  2, s2).f = s2.f by SCMFSA_2:69;
A22:  p1/.IC Comput(p1,s1,1) = p1.IC Comput(p1,s1,1) by PBOOLE:143;
  IC Comput(p1,s1,1) = succ  0 by A3,A10,A13,A7,SCMFSA_2:70
    .=  (0 + 1);
  then
A23: CurInstr(p1,Comput(p1,
s1,1)) = goto  2
by A9,A22;
A24: Comput(p1,s1,1+1) = Following(p1,s2) by EXTPRO_1:3
    .= Exec(goto  2,s2) by A23;
A25: p3/.IC s3 = p3.IC s3 by PBOOLE:143;
  IC s3 =  2 by A24,SCMFSA_2:69;
  then
A26: CurInstr(p3,s3) = goto  3 by A15,A25;
A27: Comput(p1,s1,2+1) = Following(p1,s3) by EXTPRO_1:3
    .= Exec(goto  3,s3) by A26;
A28:  p4/.IC s4 = p4.IC s4 by PBOOLE:143;
  IC s4 =  3 by A27,SCMFSA_2:69;
  then
A29: CurInstr(p4,s4) = goto loc5 by A17,A28;
A30: Comput(p1,s1,3+1) = Following(p1,s4) by EXTPRO_1:3
    .= Exec(goto loc5,s4) by A29;
A31:  p5/.IC s5 = p5.IC s5 by PBOOLE:143;
  IC s5 = loc5 by A30,SCMFSA_2:69;
  then
A32: CurInstr(p5,s5) = halt SCM+FSA by A19,A31;
  then
A33: p1 halts_on s1 by EXTPRO_1:29;
A34: s = s1 by A1,FUNCT_4:98;
  now
    let k;
    assume
A35: CurInstr(p,Comput(p,s,k)) = halt SCM+FSA;
    assume 4 > k;
    then 3+1 > k;
    then
A36: k <= 3 by NAT_1:13;
    per cases by A36,NAT_1:27;
    suppose
      k = 0;
      then Comput(p,s,k) = s by EXTPRO_1:2;
      hence contradiction by A34,A12,A35,A4;
    end;
    suppose
      k = 1;
      hence contradiction by A34,A23,A35,A4;
    end;
    suppose
      k = 2;
      hence contradiction by A34,A26,A35,A4;
    end;
    suppose
      k = 3;
      hence contradiction by A34,A29,A35,A4;
    end;
  end;
  hence
A37: LifeSpan(p,s) = 4 by A34,A32,A33,A4,EXTPRO_1:def 15;
A38: ( for c being Int-Location holds Exec(i, s1).c = s1.c)& for f being
  FinSeq-Location holds Exec(i, s1).f = s1.f by SCMFSA_2:70;
  then
A39: DataPart Comput(p,s,1) = DataPart s by A34,A13,A4,SCMFSA_M:2;
  then
A40: DataPart Comput(p,s,2) = DataPart s by A34,A24,A21,A4,SCMFSA_M:2;
A41: ( for c being Int-Location holds Exec(goto  3, s3).c = s3.c)& for
f being FinSeq-Location holds Exec(goto  3, s3).f = s3.f by SCMFSA_2:69;
  then DataPart Comput(p,s,3) = DataPart s by A34,A27,A40,A4,SCMFSA_M:2;
  then
A42: DataPart Comput(p,s,4) = DataPart s by A34,A30,A20,A4,SCMFSA_M:2;
  let k be Element of NAT;
  k <= 3 or 3 < k;
  then
A43: k = 0 or k = 1 or k = 2 or k = 3 or 3+1 <= k by NAT_1:13,27;
  per cases by A43;
  suppose
    k = 0;
    hence thesis by EXTPRO_1:2;
  end;
  suppose
    k = 1;
    hence thesis by A34,A13,A38,A4,SCMFSA_M:2;
  end;
  suppose
    k = 2;
    hence thesis by A34,A24,A21,A39,A4,SCMFSA_M:2;
  end;
  suppose
    k = 3;
    hence thesis by A34,A27,A41,A40,A4,SCMFSA_M:2;
  end;
  suppose
    4 <= k;
    then CurInstr(p,Comput(p,
s,k))
     = halt SCM+FSA by A34,A33,A37,A4,EXTPRO_1:36;
    hence thesis by A37,A42,EXTPRO_1:24;
  end;
end;

theorem Th17: :: based on SCMFSA_9:22
  I is_closed_on s,p & I is_halting_on s,p & s.a = 0 implies DataPart
  Comput(p +* while=0(a,I),(Initialize s),
  (LifeSpan(p+* I,Initialize s) + 3)) =
DataPart Comput(p +* I,
   (Initialize s), (LifeSpan(p+* I,Initialize s)))
proof
  assume that
A1: I is_closed_on s,p & I is_halting_on s,p and
A2: s.a = 0;
  set sI = Initialize s,
      pI = p +* I;
  set s1 = Initialize s,
      p1 = p +* while=0(a,I);
A3: while=0(a,I) c= p1 by FUNCT_4:25;
  defpred P[Nat] means $1 <= LifeSpan(p+*I,sI)
   implies IC Comput(p1,s1,1+$1) = IC Comput(p+*I,sI,$1) + 4 &
   DataPart Comput(p1,s1,1+$1) = DataPart Comput(p+*I,sI,$1);
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    now
A6:   k + 0 < k + 1 by XREAL_1:6;
      assume k + 1 <= LifeSpan(p+*I,sI);
      then k < LifeSpan(p+*I,sI) by A6,XXREAL_0:2;
      hence IC Comput(p1,s1,1+k+1) = IC Comput(pI,sI,k+1) + 4 &
      DataPart Comput(p1,s1,1+k+1) = DataPart Comput(pI,sI,k+1)
       by A1,A5,SCMFSA_9:19;
    end;
    hence P[k + 1];
  end;
  set i = a =0_goto  4;
  set s2 = Comput(p1,s1,1),
      p2 = p1;
A7: IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
A8: IC s1 = IC Start-At(0,SCM+FSA) by A7,FUNCT_4:13
    .=  0 by FUNCOP_1:72;
  not a in dom Start-At(0,SCM+FSA) by SCMFSA_2:102;
  then
A9: s1.a = s.a by FUNCT_4:11;
  set loc4 = card I + 4;
A10:  p1/.IC s1 = p1.IC s1 by PBOOLE:143;
  0 in dom while=0(a,I) by SCMFSA_9:10;
  then p1. 0 = while=0(a,I). 0
  by FUNCT_4:13
    .= i by SCMFSA_9:11;
  then
A11: CurInstr(p1,s1) = i by A8,A10;
A12: Comput(p1,s1,0+1) = Following(p1,Comput(p1,s1,0)) by EXTPRO_1:3
    .= Following(p1,s1)
    .= Exec(i,s1) by A11;
  then ( for c being Int-Location holds s2.c = s1.c)& for f being
  FinSeq-Location holds s2.f = s1.f by SCMFSA_2:70;
  then
A13: DataPart s2 = DataPart s1 by SCMFSA_M:2
    .= DataPart sI;
A14: IC s2 =  4 by A2,A12,A9,SCMFSA_2:70;
A15: P[0]
  proof
    assume 0 <= LifeSpan(p+*I,sI);
A16: IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
    IC Comput(pI,sI,0) = IC sI
      .= IC Start-At(0,SCM+FSA) by A16,FUNCT_4:13
      .=  0 by FUNCOP_1:72;
    hence thesis by A14,A13;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A15,A4);
  then
A17: P[LifeSpan(p+*I,sI) qua Element of NAT];
  set s4=Comput(p1,s1,1+LifeSpan(p+*I,sI)+1+1),
      p4 = p1;
  set s3 = Comput(p1,s1,1+LifeSpan(p+*I,sI)+1),
      p3 = p1;
A18: loc4 in dom while=0(a,I) by SCMFSA_9:13;
  set s2 = Comput(p1,s1,1+LifeSpan(p+*I,sI));
A19: CurInstr(p2,s2) = goto loc4 by A1,A17,SCMFSA_9:20;
A20: s3 = Following(p1,s2) by EXTPRO_1:3
    .= Exec(goto loc4,s2) by A19;
  then
A21: ( for c being Int-Location holds s3.c = s2.c)& for f being
  FinSeq-Location holds s3.f = s2.f by SCMFSA_2:69;
A22: p3.loc4 = while=0(a,I).loc4 by A18,A3,GRFUNC_1:2
    .= goto  0 by SCMFSA_9:21;
A23:  p3/.IC s3 = p3.IC s3 by PBOOLE:143;
  IC s3 = loc4 by A20,SCMFSA_2:69;
  then
A24: CurInstr(p3,s3) = goto  0 by A22,A23;
  s4 = Following(p1,s3) by EXTPRO_1:3
    .= Exec(goto  0,s3) by A24;
  then ( for c being Int-Location holds s4.c = s3.c)& for f being
  FinSeq-Location holds s4.f = s3.f by SCMFSA_2:69;
  hence DataPart Comput(p1,s1,LifeSpan(p+*I,sI)+3) =
       DataPart s3 by SCMFSA_M:2
    .= DataPart Comput(pI,sI,LifeSpan(p+*I,sI)) by A17,A21,SCMFSA_M:2;
end;

theorem Th18: :: Step_eq0_0:
  (StepWhile=0(a,I,p,s).k).a <> 0 implies
   DataPart StepWhile=0(a,I,p,s).(k+1) = DataPart StepWhile=0(a,I,p,s).k
proof
  assume
A1: (StepWhile=0(a,I,p,s).k).a <> 0;
  set SW = StepWhile=0(a,I,p,s),
      PW = p +* while=0(a,I);
A2: while=0(a,I) c= PW by FUNCT_4:25;
A3: DataPart(Initialize(SW.k)) = DataPart SW.k
by MEMSTR_0:79;
  then
A4: SW.k.a = (Initialize(SW.k)).a by SCMFSA_M:2;
  thus DataPart SW.(k+1) = DataPart Comput(PW +* while=0(a,I),
  (Initialize(SW.k)), (LifeSpan(PW +* I,Initialize(SW.k)) + 3))
   by SCMFSA_9:def 4
    .= DataPart StepWhile=0(a,I,p,s).k by A1,A3,A4,Th16,A2;
end;

theorem Th19: :: Step_eq0_1:
  ( I is_halting_on Initialized StepWhile=0(a,I,p,s).k ,p+*while=0(a,I) & I
  is_closed_on Initialized StepWhile=0(a,I,p,s).k ,p+*while=0(a,I) or
    I is parahalting) & (
  StepWhile=0(a,I,p,s).k).a = 0 & (StepWhile=0(a,I,p,s).k).intloc 0 = 1 implies
DataPart StepWhile=0(a,I,p,s).(k+1) =
 DataPart IExec(I,p+*while=0(a,I),StepWhile=0(a,I,p,s).k)
proof
  set Ins = NAT;
  assume that
A1: I is_halting_on Initialized StepWhile=0(a,I,p,s).k ,p+*while=0(a,I) &
    I is_closed_on Initialized StepWhile=0(a,I,p,s).k ,p+*while=0(a,I) or
     I is parahalting and
A2: (StepWhile=0(a,I,p,s).k).a = 0 and
A3: (StepWhile=0(a,I,p,s).k).intloc 0 = 1;
  set ISWk = Initialized StepWhile=0(a,I,p,s).k;
  set SW = StepWhile=0(a,I,p,s), PW = p +* while=0(a,I);
  set SWkI = Initialized(SW.k), PWI = p +* while=0(a,I) +* I;
  DataPart ISWk = DataPart SW.k by A3,SCMFSA_M:19;
  then
A4: I is_closed_on SW.k ,PW & I is_halting_on SW.k ,PW
       by A1,SCMFSA7B:18,19,SCMFSA8B:5;
  I is_halting_on ISWk ,PW by A1,SCMFSA7B:19;
  then
A5: I is_halting_on Initialized SW.k ,PW;
     Initialized SW.k = Initialize Initialized(SW.k) by MEMSTR_0:44;
    then
A6:  PW +* I halts_on Initialized(SW.k) by A5,SCMFSA7B:def 7;
A7: PWI halts_on SWkI by A6;
  set SWkIS = Initialize(SW.k),
      PWIS = PW +* I;
A8: SWkI = SWkIS by A3,SCMFSA_M:18;
A9: SW.(k+1) = Comput(PW +* while=0(a,I),
  (Initialize(SW.k)),LifeSpan(PWIS,SWkIS)+ 3)
   by SCMFSA_9:def 4;
A10: DataPart IExec(I,PW,SW.k)
     = DataPart(Result(PWI,SWkI)) by SCMFSA6B:def 1
    .= DataPart Result(PWI,SWkI)
    .= DataPart Comput(PWIS,SWkIS,LifeSpan(PWIS,SWkIS)) by A8,A7,EXTPRO_1:23;
  thus DataPart StepWhile=0(a,I,p,s).(k+1)
   = DataPart Comput(PWIS,SWkIS,LifeSpan(PWIS,SWkIS))
  by A2,A4,Th17,A9
   .= DataPart IExec(I,PW,StepWhile=0(a,I,p,s).k) by A10;
end;

theorem :: eGoodStep0:
  (ProperBodyWhile=0 a,Ig,s,p or Ig is parahalting) & s.intloc 0 = 1
  implies for k holds StepWhile=0(a,Ig,p,s).k.intloc 0 = 1
proof
  set I = Ig;
  assume that
A1: ProperBodyWhile=0 a,I,s,p or I is parahalting and
A2: s.intloc 0 = 1;
  set SW = StepWhile=0(a,I,p,s),
      PW = p +* while=0(a,I);
  defpred X[Nat] means SW.$1.intloc 0 = 1;
A3: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT such that
A4: SW.k.intloc 0 = 1;
    per cases;
    suppose
      SW.k.a <> 0;
      then DataPart SW.(k+1) = DataPart SW.k by Th18;
      hence thesis by A4,SCMFSA_M:2;
    end;
    suppose
A5:   SW.k.a = 0;
      set Ins = NAT;
      set SWkIS = Initialize(SW.k),
          PWIS = PW +* I;
      set SWkI = Initialized(SW.k), PWI = p +* while=0(a,I) +* I;
      set ISWk = Initialized StepWhile=0(a,I,p,s).k;
A6:   DataPart SW.k = DataPart ISWk by A4,SCMFSA_M:19;
A7:   ProperBodyWhile=0 a,I,s,p by A1,Th13;
      then
A8:   I is_closed_on SW.k ,PW by A5,Def1;
      I is_halting_on SW.k ,PW by A5,A7,Def1;
      then
A9:  I is_halting_on Initialized SW.k ,PW by A8,A6,SCMFSA8B:5;
     Initialized SW.k = Initialize Initialized(SW.k) by MEMSTR_0:44;
    then
A10:  PW +* I halts_on Initialized(SW.k) by A9,SCMFSA7B:def 7;
A11:  PWI halts_on SWkI by A10;
A12:  SWkI = SWkIS by A4,SCMFSA_M:18;
A13:  DataPart IExec(I,PW,SW.k) = DataPart(Result(PWI,SWkI)) by SCMFSA6B:def 1
        .= DataPart Result(PWI,SWkI)
        .= DataPart Comput(PWIS,SWkIS,LifeSpan(PWIS
,SWkIS)) by A12,A11,EXTPRO_1:23;
      I is_closed_on Initialized SW.k ,PW by A8,A6,SCMFSA8B:3;
      then DataPart SW.(k+1) = DataPart IExec(I,PW,SW.k) by A4,A5,A9,Th19;
      hence
      SW.(k+1).intloc 0 = (Comput(PWIS,SWkIS,LifeSpan(PWIS,SWkIS))).
intloc 0 by A13,SCMFSA_M:2
        .= 1 by A4,A8,SCMFSA8C:68;
    end;
  end;
A14: X[0] by A2,SCMFSA_9:def 4;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A14,A3);
end;

theorem
  ProperBodyWhile=0 a,I,s1,p1 & DataPart s1 = DataPart s2 implies for k
  holds DataPart StepWhile=0(a,I,p1,s1).k = DataPart StepWhile=0(a,I,p2,s2).k
proof
  assume that
A1: ProperBodyWhile=0 a,I,s1,p1 and
A2: DataPart s1 = DataPart s2;
  set WH = while=0(a,I);
  set ST2 = StepWhile=0(a,I,p2,s2),
      PT2 = p2 +* while=0(a,I);
  set ST1 = StepWhile=0(a,I,p1,s1),
      PT1 = p1 +* while=0(a,I);
  defpred X[Nat] means DataPart ST1.$1 = DataPart ST2.$1;
A3: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k;
    set ST1kI = Initialize(ST1.k),
        PT1I = PT1 +* I;
    set ST2kI = Initialize(ST2.k),
        PT2I = PT2 +* I;
A4: I c= PT1I by FUNCT_4:25;
A5: I c= PT2I by FUNCT_4:25;
    assume
A6: DataPart ST1.k = DataPart ST2.k;
    then
A7: ST1.k.a = ST2.k.a by SCMFSA_M:2;
    per cases;
    suppose
A8:   ST1.k.a <> 0;
      hence DataPart ST1.(k+1) = DataPart ST1.k by Th18
        .= DataPart ST2.(k+1) by A6,A7,A8,Th18;
    end;
    suppose
A9:   ST1.k.a = 0;
      then
A10:   I is_closed_on ST1.k, PT1 by A1,Def1;
A11:   I is_halting_on ST1.k, PT1 by A1,A9,Def1;
      then
A12:  I is_closed_on ST2.k, PT2 & I is_halting_on ST2.k, PT2
          by A6,A10,SCMFSA8B:5;
A13:  DataPart ST1.(k+1) = DataPart Comput(PT1 +* while=0(a,I),
(Initialize(ST1.k)), (
      LifeSpan(PT1I,ST1kI) + 3)) by SCMFSA_9:def 4
        .= DataPart Comput(PT1I,(ST1kI),LifeSpan(PT1I,ST1kI)) by A9,A10,A11
,Th17;
A14:  DataPart ST2.(k+1) = DataPart Comput(PT2 +* while=0(a,I),
(Initialize(ST2.k)), (
      LifeSpan(PT2I,ST2kI) + 3)) by SCMFSA_9:def 4
        .= DataPart Comput(PT2I,(ST2kI),
          LifeSpan(PT2I,ST2kI)) by A7,A9,A12,Th17;
A15:  DataPart ST1.k = DataPart ST1kI by MEMSTR_0:79;
      then
A16:  I is_closed_on ST1kI, PT1I by A10,SCMFSA8B:3;
A17:  DataPart ST1kI = DataPart ST1.k by MEMSTR_0:79
        .= DataPart ST2kI by A6,MEMSTR_0:79;
      I is_halting_on ST1kI, PT1I by A10,A11,A15,SCMFSA8B:5;
      then (LifeSpan(PT1I,ST1kI)) = (LifeSpan(PT2I,
ST2kI)) by A10,A17,A15,A4,A5,SCMFSA8B:3,SCMFSA8C:18;
      hence thesis by A13,A14,A17,A16,A4,A5,SCMFSA8C:17;
    end;
  end;
  DataPart ST1.0 = DataPart s1 by SCMFSA_9:def 4
    .= DataPart ST2.0 by A2,SCMFSA_9:def 4;
  then
A18: X[0];
  thus for k holds X[k] from NAT_1:sch 1(A18, A3);
end;

definition let p;
  let s be State of SCM+FSA, a be read-write Int-Location,
      I be Program of SCM+FSA;
  assume that
A1: ProperBodyWhile=0 a,I,s,p or I is parahalting and
A2: WithVariantWhile=0 a,I,s,p;
  func ExitsAtWhile=0(a, I, p, s) -> Element of NAT means
  :Def3:
  ex k being Element of NAT
   st it = k & (StepWhile=0(a,I,p,s).k).a <> 0 &
    (for i being Element of NAT
     st (StepWhile=0(a,I,p,s).i).a <> 0 holds k <= i) &
    DataPart Comput(p +* while=0(a, I),
      Initialize s,
       (LifeSpan(p +* while=0(a, I),
       Initialize s)))
     = DataPart StepWhile=0(a,I,p,s).k;
  existence
  proof
    set S = Initialize s,
        P = p +* while=0(a, I);
    set SW = StepWhile=0(a,I,p,s),
      PW = p +* while=0(a,I);
A3: while=0(a,I) c= PW by FUNCT_4:25;
    defpred X[Nat] means SW.$1.a <> 0;
    consider f being Function of product the_Values_of SCM+FSA, NAT such
    that
A4: for k being Element of NAT holds f.(SW.(k+1))<f.(SW.(k)) or X[k]
    by A2,Def2;
    deffunc U(Nat) = f.(SW.$1);
A5: for k being Element of NAT holds U(k+1)<U(k) or X[k] by A4;
    consider m such that
A6: X[m] and
A7: for n st X[n] holds m <= n from NAT_1:sch 18(A5);
    take m, m;
    thus m = m;
    thus SW.m.a <> 0 by A6;
    thus for n st SW.n.a <> 0 holds m <= n by A7;
    defpred P[Nat] means $1+1 <= m implies
     ex k st StepWhile=0(a,I,p,s).($1+1)=Comput(P,S,k);
A8: ProperBodyWhile=0 a,I,s,p by A1,Th13;
A9: now
      let k be Element of NAT;
      assume
A10:  P[k];
      now
        set sk1=StepWhile=0(a,I,p,s).(k+1);
        set sk=StepWhile=0(a,I,p,s).k,
          pk = p +* while=0(a,I);
        assume
A11:    (k+1)+ 1 <= m;
        k + 0 < k+ (1+ 1) by XREAL_1:6;
        then k < m by A11,XXREAL_0:2;
        then
A12:    sk.a = 0 by A7;
        (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:6;
        then consider n being Element of NAT such that
A13:    sk1 = Comput(P,S,n) by A10,A11,XXREAL_0:2;
A14:    sk1 = Comput(pk +* while=0(a,I),(Initialize sk),
        (LifeSpan(pk +* I,Initialize sk) + 3))
by SCMFSA_9:def 4;
        take m=n +(LifeSpan(pk +* I,Initialize sk1) +
3);
        I is_closed_on sk,pk & I is_halting_on sk,pk by A8,A12,Def1;
        then IC sk1 = 0 by A14,A12,SCMFSA_9:22;
        hence StepWhile=0(a,I,p,s).((k+1)+1)=Comput(P,S,m) by A13,SCMFSA_9:26;
      end;
      hence P[k+1];
    end;
A15: IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
A16: P[0]
    proof
      assume 0+1 <= m;
      take n=(LifeSpan(p+*while=0(a,I) +* I,Initialize s) + 3);
      thus thesis by SCMFSA_9:25;
    end;
A17: for k being Element of NAT holds P[k] from NAT_1:sch 1(A16,A9);
    per cases;
    suppose
A18:  m = 0;
A19:  DataPart S = DataPart s by MEMSTR_0:79
        .= DataPart SW.m by A18,SCMFSA_9:def 4;
      then S.a = SW.m.a by SCMFSA_M:2;
      hence thesis by A6,A19,Th16,A3;
    end;
    suppose
A20:  m <> 0;
      set sm = StepWhile=0(a,I,p,s).m,
          pm = p +* while=0(a,I);
      set sm1 = Initialize sm,
          pm1 = pm +* while=0(a,I);
      consider i being Nat such that
A21:  m=i+1 by A20,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 12;
      set si = StepWhile=0(a,I,p,s).i,
          psi = p +* while=0(a,I);
A22:  sm = Comput(psi +* while=0(a,I),(Initialize si),
      (LifeSpan(psi +* I,Initialize si) + 3))
      by A21,SCMFSA_9:def 4;
      m=i+1 by A21;
      then consider n being Element of NAT such that
A23:  sm = Comput(P,S,n) by A17;
      i < m by A21,NAT_1:13;
      then
A24:  si.a = 0 by A7;
      then I is_closed_on si,psi & I is_halting_on si,psi by A8,Def1;
      then
A25:  IC sm = 0 by A22,A24,SCMFSA_9:22;
A26:  IC sm1 = IC Start-At(0,SCM+FSA) by A15,FUNCT_4:13
        .= IC sm by A25,FUNCOP_1:72;
      DataPart sm1 = DataPart sm by MEMSTR_0:79;
      then
A27:  sm1 = sm by A26,MEMSTR_0:78;
      while=0(a,I) is_halting_on sm,pm by A6,SCMFSA_9:18;
      then pm1 halts_on sm1 by SCMFSA7B:def 7;
      then consider j being Element of NAT such that
A28:  CurInstr(pm,Comput(pm,sm,j)) = halt SCM+FSA by A27,EXTPRO_1:29;

A29: Comput(P,S,n+j)
 = Comput(P,Comput(P,S,n),j) by EXTPRO_1:4;
      CurInstr(P,Comput(P,S,n+j))
       = halt SCM+FSA by A23,A28,A29;
      then
A30:  Comput(P,S,LifeSpan(P,S)) = Comput(P,S,n+j) by EXTPRO_1:24
        .= Comput(P,sm,j) by A23,EXTPRO_1:4
        .= Comput(pm,sm,LifeSpan(pm,sm)) by A28,EXTPRO_1:24;
      Start-At(0,SCM+FSA) c= sm by A27,FUNCT_4:25;
      then sm is 0-started by MEMSTR_0:29;
      hence thesis by A6,A30,Th16,A3;
    end;
  end;
  uniqueness
  proof
    let it1, it2 be Element of NAT;
    given k1 being Element of NAT such that
A31: it1 = k1 and
A32: (StepWhile=0(a,I,p,s).k1).a <> 0 & for i being Element of NAT st
    ( StepWhile=0(a,I,p,s).i).a <> 0 holds k1 <= i and
    DataPart(Comput(p +* while=0(a,I),(Initialize s),
    (LifeSpan(p +* while=0(a,I),Initialize s))))
     = DataPart StepWhile=0(a,I,p,s).k1;
    given k2 being Element of NAT such that
A33: it2 = k2 and
A34: (StepWhile=0(a,I,p,s).k2).a <> 0 & for i being Element of NAT st
    ( StepWhile=0(a,I,p,s).i).a <> 0 holds k2 <= i and
    DataPart(Comput(p +* while=0(a,I),(Initialize s),
    (LifeSpan(p +* while=0(a,I),Initialize s))))
     = DataPart StepWhile=0(a,I,p,s).k2;
    k1 <= k2 & k2 <= k1 by A32,A34;
    hence thesis by A31,A33,XXREAL_0:1;
  end;
end;

theorem :: IE_while_ne0:
  s.intloc 0 = 1 & s.a <> 0 implies DataPart IExec(while=0(a,I),p,s) =
  DataPart s
proof
  set Ins = NAT;
  assume that
A1: s.intloc 0 = 1 and
A2: s.a <> 0;
  set WH = while=0(a, I);
  set Is = Initialized s, pds = p +* WH;
A3: while=0(a,I) c= pds by FUNCT_4:25;
A4: Is = Initialize Is by MEMSTR_0:44;
  Is.a = s.a by SCMFSA_M:37;
  then WH is_halting_on Is,p by A2,SCMFSA_9:18;
  then
A5: pds halts_on Is by A4,SCMFSA7B:def 7;
A6: Is.a = Is.a
    .= s.a by SCMFSA_M:37;
  thus DataPart IExec(WH,p,s)
     = DataPart Result(p +* WH,Initialized s) by SCMFSA6B:def 1
    .= DataPart Comput(pds,Is,LifeSpan(pds,Is)) by A5,EXTPRO_1:23
    .= DataPart Initialized s by A2,A6,Th16,A3
    .= DataPart s by A1,SCMFSA_M:19;
end;

theorem :: IE_while_eq0:
  (ProperBodyWhile=0 a,I,Initialized s,p or I is parahalting) &
WithVariantWhile=0 a,I,Initialized s,p
 implies
  DataPart IExec(while=0(a,I),p,s)
  = DataPart
   StepWhile=0(a,I,p,Initialized s).ExitsAtWhile=0(a,I,p,Initialized s)
proof
  set Ins = NAT;
  set WH = while=0(a, I);
  set Is = Initialized s, pds = p +* WH;
A1: Is = Initialize Is by MEMSTR_0:44;
  assume
A2: ( ProperBodyWhile=0 a,I,Initialized s,p or I is parahalting)&
  WithVariantWhile=0 a,I,Initialized s,p;
  then
A3: ex k being Element of NAT st ExitsAtWhile=0(a,I,p,Is) = k &
 (StepWhile=0(a, I, p, Is).k).a <> 0 &
 ( for i being Element of NAT st ( StepWhile=0(a,I,p,Is).i)
.a <> 0 holds k <= i)& DataPart(Comput(p +* while=0(a,I),
  Initialize Is, LifeSpan(p +* while=0(a,I),Initialize Is))) =
  DataPart StepWhile=0(a,I,p,Is).k
  by Def3;
  WH is_halting_on Is,p by A2,Th14,Th15;
  then
A4: pds halts_on Is by A1,SCMFSA7B:def 7;
  thus DataPart IExec(while=0(a, I),p,s)
     = DataPart Result(p +* WH,Initialized s) by SCMFSA6B:def 1
    .= DataPart(Result(p +* WH,s+*Initialize((intloc 0).-->1)))
    .= DataPart StepWhile=0(a,I,p,Is).ExitsAtWhile=0(a,I,p,Is) by A1,A4,A3,
EXTPRO_1:23;
end;

begin :: while>0, general

Lm4: for a being Int-Location, I being Program of SCM+FSA holds card I +4 in
dom if>0(a,I ";" Goto  0,Stop SCM+FSA) & if>0(a,I ";" Goto  0,Stop
SCM+FSA).(card I +4) = goto (( 0)+(card I +4))

proof
  set J = Stop SCM+FSA;
  set G = Goto  0;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ";" G;
  set i = a >0_goto  (card J + 3);
  set c4 = card I + 4;
  set Lc4 = c4;
  set Mi= Macro i ";" J ";" Goto  (card I1 + 1) ";" I;
A1: card Stop SCM+FSA = 1 by COMPOS_1:4;
A2: card (G ";" J) = card G + card J by SCMFSA6A:21
    .= 1 + 1 by A1,SCMFSA8A:15
    .= 2;

A3: if>0(a, I1, J) = i ";" J ";" Goto  (card I1 + 1) ";" (I ";" G) ";"
  J by SCMFSA8B:def 2

    .= Mi ";" G ";" J by SCMFSA6A:25
    .= Mi ";" (G ";" J) by SCMFSA6A:25;
  then card if>0(a, I1,J) = card Mi + card (G ";" J) by SCMFSA6A:21;
  then
A4: card Mi = card if>0(a,I1,J)-card (G ";" J)
    .= card I + 6 - 2 by A2,SCMFSA_9:2
    .= c4;
  then
A5: not Lc4 in dom Mi;
  set GJ = G ";" J;
A6: G =  0 .--> goto  0 by SCMFSA8A:def 1;
  then
A7: G. 0 = goto  0 by FUNCOP_1:72;
  dom G = { 0} by A6,FUNCOP_1:13;
  then
A8:  0 in dom G by TARSKI:def 1;
A9: dom G c= dom GJ by SCMFSA6A:17;

  then  0 + c4 in { il+c4 where il is Element of NAT: il in dom GJ} by A8
;

  then
A10:  c4 in dom Shift(GJ,c4) by VALUED_1:def 12;
  then
A11: Shift(GJ,c4)/.Lc4 = Shift(GJ,c4).( 0 +c4) by PARTFUN1:def 6
    .= GJ. 0 by A8,A9,VALUED_1:def 12
    .= goto  0 by A8,A7,SCMFSA6A:15;
A12: card Stop SCM+FSA = 1 by COMPOS_1:4;
  card I1 = card I + card G by SCMFSA6A:21
    .= card I +1 by SCMFSA8A:15;
  then card I1 + card J + 3 = card I +4 +1 by A12;
  then c4 < card I1 + card J + 3 by NAT_1:13;
  hence
A13: Lc4 in dom if>0(a,I1,J) by SCMFSA8C:28;
A14: Reloc(GJ,c4) = IncAddr(Shift(GJ,c4),c4) by COMPOS_1:34;
A15: dom if>0(a,I1,J) = dom Directed Mi \/ dom Reloc(GJ, c4
  ) by A3,A4,FUNCT_4:def 1;

  then dom if>0(a,I1,J) = dom Mi \/ dom Reloc(GJ, c4) by FUNCT_4:99;

  then Lc4 in dom Reloc(GJ, c4) by A13,A5,XBOOLE_0:def 3;

  hence if>0(a,I1,J).Lc4 = (Reloc(GJ,c4)).Lc4 by A13,A3,A4,A15,FUNCT_4:def 1
    .= IncAddr( goto  0, c4 ) by A10,A11,A14,COMPOS_1:def 21
    .= goto (( 0)+c4) by SCMFSA_4:1;
end;

Lm5: for a being Int-Location, I being Program of SCM+FSA holds UsedIntLoc
if>0(a,I ";" Goto  0,Stop SCM+FSA) = UsedIntLoc (if>0(a,I ";" Goto
0,Stop SCM+FSA) +* (  (card I +4) .--> goto  0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 =  (card I + 4);
  set if0 = if>0(a,I ";" Goto  0,Stop SCM+FSA);
  set ic4 =  (card I +4) .--> goto  0;

  consider UIL1 being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedIntLoc i and
A2: UsedIntLoc if0 = Union (UIL1 * if0) by SF_MASTR:def 2;
A3: dom UIL1 = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,RELAT_1:def 19;
A6: dom ic4 = { (card I +4)} by FUNCOP_1:13;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
     (card I +4) in dom if0 by Lm4;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
FUNCT_4:def 1,ZFMISC_1:31;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,RELAT_1:def 19;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:27
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:27;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:12
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:11
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:12;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:12
        .= UIL1.(goto (( 0)+(card I +4))) by A12,Lm4
        .= UsedIntLoc goto (( 0)+(card I +4)) by A1
        .= {} by SF_MASTR:15
        .= UsedIntLoc goto  0 by SF_MASTR:15
        .= UIL1.(goto  0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:72
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:13
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:12;
    end;
  end;

  consider UIL2 being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A14: UsedIntLoc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 2;
  for c be Element of the InstructionsF of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedIntLoc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:63;
  hence thesis by A2,A14,A4,FUNCT_1:2;
end;

Lm6: for a being Int-Location, I being Program of SCM+FSA holds UsedInt*Loc
if>0(a,I ";" Goto  0,Stop SCM+FSA) = UsedInt*Loc (if>0(a,I ";" Goto
 0,Stop SCM+FSA) +* (  (card I +4) .--> goto  0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 =  (card I + 4);
  set if0 = if>0(a,I ";" Goto  0,Stop SCM+FSA);
  set ic4 =  (card I +4) .--> goto  0;

  consider UIL1 being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedInt*Loc i and
A2: UsedInt*Loc if0 = Union (UIL1 * if0) by SF_MASTR:def 4;
A3: dom UIL1 = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,RELAT_1:def 19;
A6: dom ic4 = { (card I +4)} by FUNCOP_1:13;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
     (card I +4) in dom if0 by Lm4;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
FUNCT_4:def 1,ZFMISC_1:31;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,RELAT_1:def 19;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:27
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:27;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:12
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:11
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:12;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:12
        .= UIL1.(goto (( 0)+(card I +4))) by A12,Lm4
        .= UsedInt*Loc goto (( 0)+(card I +4)) by A1
        .= {} by SF_MASTR:32
        .= UsedInt*Loc goto  0 by SF_MASTR:32
        .= UIL1.(goto  0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:72
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:13
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:12;
    end;
  end;

  consider UIL2 being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A14: UsedInt*Loc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 4;
  for c be Element of the InstructionsF of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedInt*Loc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:63;
  hence thesis by A2,A14,A4,FUNCT_1:2;
end;

theorem :: whileUsed:
  UsedIntLoc while>0(b, I) = {b} \/ UsedIntLoc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ";" Goto  0;
  while>0(a, I) = if>0(a, IG, J) +* (  (card I +4) .--> goto
  0 ) by SCMFSA_9:def 2;
  hence UsedIntLoc while>0(a, I) = (UsedIntLoc if>0(a, IG, J)) by Lm5
    .= {a} \/ UsedIntLoc IG \/ UsedIntLoc J by Th9
    .= {a} \/ (UsedIntLoc I \/ UsedIntLoc Goto  0) \/ UsedIntLoc J by
SF_MASTR:27
    .= {a} \/ (UsedIntLoc I \/ {}) \/ UsedIntLoc J by Th5
    .= {a} \/ UsedIntLoc I by Th3;
end;

theorem :: whileUsedF:
  UsedInt*Loc while>0(b, I) = UsedInt*Loc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ";" Goto  0;
  while>0(a, I) = if>0(a, IG, J) +* (  (card I +4) .--> goto
  0 ) by SCMFSA_9:def 2;
  hence UsedInt*Loc while>0(a, I) = (UsedInt*Loc if>0(a, IG, J)) by Lm6
    .= UsedInt*Loc IG \/ UsedInt*Loc J by Th10
    .= (UsedInt*Loc I \/ UsedInt*Loc Goto  0) \/ UsedInt*Loc J by SF_MASTR:43
    .= UsedInt*Loc I \/ {} by Th4,Th6
    .= UsedInt*Loc I;
end;

definition let p;
  let s be State of SCM+FSA, a be read-write Int-Location, I be Program of
  SCM+FSA;
  pred ProperBodyWhile>0 a,I,s,p means
  :Def4:
  for k being Element of NAT st StepWhile>0(a,I,p,s).k.a > 0
   holds I is_closed_on StepWhile>0(a,I,p,s).k, p+*while>0(a,I) &
   I is_halting_on StepWhile>0(a,I,p,s).k, p+*while>0(a,I);
  pred WithVariantWhile>0 a,I,s,p means
  :Def5:
  ex f being Function of product the_Values_of SCM+FSA, NAT
   st for k being Element of NAT holds ( f.(
   StepWhile>0(a,I,p,s).(k+1)) < f.(StepWhile>0(a,I,p,s).k) or
   StepWhile>0(a,I,p,s).k.a <= 0 );
end;

theorem Th26: :: ParaProper:
  for I being parahalting Program of SCM+FSA holds
  ProperBodyWhile>0 a,I,s,p
proof
  let I be parahalting Program of SCM+FSA;
  let k be Element of NAT such that
  StepWhile>0(a,I,p,s).k.a > 0;
  thus I is_closed_on StepWhile>0(a,I,p,s).k, p+*while>0(a,I) by SCMFSA7B:18;
  thus thesis by SCMFSA7B:19;
end;

theorem Th27: :: SCMFSA_9:42, corrected
  ProperBodyWhile>0 a,I,s,p & WithVariantWhile>0 a,I,s,p implies
  while>0(a,I) is_halting_on s,p & while>0(a,I) is_closed_on s,p
proof
  assume
A1: for k being Element of NAT st StepWhile>0(a,I,p,s).k.a > 0 holds I
  is_closed_on StepWhile>0(a,I,p,s).k, p+*while>0(a,I) &
  I is_halting_on StepWhile>0(a,I,p,s).k, p+*while>0(a,I);
  set s1 = Initialize s,
      p1 = p +* while>0(a,I);
A2:  p1 +* while>0(a,I) = p1;
  defpred S[Nat] means StepWhile>0(a,I,p,s).$1.a <= 0;
  given f being Function of product the_Values_of SCM+FSA,NAT such that
A3: for k being Element of NAT holds (f.(StepWhile>0(a,I,p,s).(k+1)) < f.(
  StepWhile>0(a,I,p,s).k) or (StepWhile>0(a,I,p,s).k).a <= 0 );
  deffunc F(Nat) = f.(StepWhile>0(a,I,p,s).$1);
A4: for k holds F(k+1) < F(k) or S[k] by A3;
  consider m being Element of NAT such that
A5: S[m] and
A6: for n st S[n] holds m <= n from NAT_1:sch 18(A4);
  defpred P[Nat] means $1+1 <= m implies
   ex k st StepWhile>0(a,I,p,s).($1+1)=Comput(p1,s1,k);
A7: now
    let k be Element of NAT;
    assume
A8: P[k];
    now
      set sk1=StepWhile>0(a,I,p,s).(k+1);
      set sk=StepWhile>0(a,I,p,s).k,
          pk = p +* while>0(a,I);
      assume
A9:   (k+1)+ 1 <= m;
      k + 0 < k+ (1+ 1) by XREAL_1:6;
      then k < m by A9,XXREAL_0:2;
      then
A10:   sk.a > 0 by A6;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:6;
      then consider n being Element of NAT such that
A11:  sk1 = Comput(p1,s1,n) by A8,A9,XXREAL_0:2;
A12:  sk1 = Comput(pk +* while>0(a,I),(Initialize sk),
      (LifeSpan(pk +* I,Initialize sk) + 3))
by SCMFSA_9:def 5;
      take m=n +(LifeSpan(pk +* I,Initialize sk1) + 3);
      I is_closed_on sk,pk & I is_halting_on sk,pk by A1,A10;
      then IC sk1 = 0 by A12,A10,SCMFSA_9:42;
      hence StepWhile>0(a,I,p,s).((k+1)+1)=Comput(p1,s1,m) by A11,SCMFSA_9:45;
    end;
    hence P[k+1];
  end;
A13: P[0]
  proof
    assume 0+1 <= m;
    take n=(LifeSpan(p +* while>0(a,I) +* I,Initialize s) + 3);
    thus thesis by SCMFSA_9:44;
  end;
A14: for k being Element of NAT holds P[k] from NAT_1:sch 1(A13,A7);
    per cases;
    suppose
      m=0;
      then s.a <= 0 by A5,SCMFSA_9:def 5;
      hence thesis by SCMFSA_9:38;
    end;
    suppose
A15:  m<>0;
      set ii=(LifeSpan(p+* while>0(a,I) +* I,Initialize s) + 3);
      set sm=StepWhile>0(a,I,p,s).m,
          pm = p +* while>0(a,I);
      set sm1=Initialize sm,
          pm1 = pm +* while>0(a,I);
      consider i being Nat such that
A16:  m=i+1 by A15,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 12;
      set si=StepWhile>0(a,I,p,s).i,
          psi = p +* while>0(a,I);
A17:  sm= Comput(psi +* while>0(a,I),(Initialize si),
      (LifeSpan(psi +* I,Initialize si) + 3))
      by A16,SCMFSA_9:def 5;
      m=i+1 by A16;
      then consider n being Element of NAT such that
A18:  sm = Comput(p1,s1,n) by A14;
      i < m by A16,NAT_1:13;
      then
A19:  si.a > 0 by A6;
      then I is_closed_on si,psi & I is_halting_on si,psi by A1;
      then
      IC sm = 0 by A17,A19,SCMFSA_9:42;
      then Start-At(0,SCM+FSA) c= sm by MEMSTR_0:30;
      then
A20:  sm1=sm by FUNCT_4:98;
      while>0(a,I) is_halting_on sm,pm by A5,SCMFSA_9:38;
      then pm1 halts_on sm1 by SCMFSA7B:def 7;
      then consider j being Element of NAT such that
A21:  CurInstr(pm,Comput(pm,sm,j)) = halt SCM+FSA
by A20,EXTPRO_1:29;
A22: Comput(p1,s1,n+j)
 = Comput(p1,Comput(p1,s1,n),j) by EXTPRO_1:4;
      CurInstr(p1,Comput(p1,s1,n+j))
       = halt SCM+FSA by A18,A21,A22;
      then p1 halts_on s1 by EXTPRO_1:29;
      hence while>0(a,I) is_halting_on s,p by SCMFSA7B:def 7;
      now
        let q be Element of NAT;
        per cases;
        suppose
A23:      q <= ii;
A24:      StepWhile>0(a,I,p,s).0=s by SCMFSA_9:def 5;
          then
A25:      s.a > 0 by A6,A15;
          then I is_closed_on s,p1 & I is_halting_on s,p1 by A1,A24;
          hence IC Comput(p1,s1,q) in dom while>0(a,I) by A23,A25,A2,
SCMFSA_9:42;
        end;
        suppose
A26:      q > ii;
A27:      now
            take k=ii;
            thus StepWhile>0(a,I,p,s).1
            =Comput(p1,s1,k) & k <= q by A26,SCMFSA_9:44;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 &
          (ex k st StepWhile>0(a,I,p,s).$1 = Comput(p1,s1,k) & k <= q);
A28:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A15,XREAL_1:6;
          then 1 <= m by NAT_1:13;
          then
A29:      ex k be Nat st P2[k] by A27;
          consider t being Nat such that
A30:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A28, A29);
          reconsider t as Element of NAT by ORDINAL1:def 12;
            per cases;
            suppose
              t=m;
              then consider r being Element of NAT such that
A31:          sm=Comput(p1,s1,r) and
A32:          r <= q by A30;
              consider x being Nat such that
A33:          q = r+x by A32,NAT_1:10;
A34:          while>0(a,I) is_closed_on sm,pm by A5,SCMFSA_9:38;
              reconsider x as Element of NAT by ORDINAL1:def 12;
              Comput(p1,s1,q) = Comput(p1,sm1,x) by A20,A31,A33,EXTPRO_1:4;
              hence IC Comput(p1,s1,q) in dom while>0(a,I) by A34,A2,
SCMFSA7B:def 6;
            end;
            suppose
A35:          t<>m;
              set Dt=StepWhile>0(a,I,p,s).t,
                  pt = p +* while>0(a,I);
              consider y being Nat such that
A36:          t=y+1 by A30,NAT_1:6;
              reconsider y as Element of NAT by ORDINAL1:def 12;
              set Dy=StepWhile>0(a,I,p,s).y,
                  py = p +* while>0(a,I);
A37:          Dt= Comput(py +* while>0(a,I),(Initialize Dy),
 (LifeSpan(py +* I,Initialize Dy) + 3)) by A36,SCMFSA_9:def 5;
              y+ 0 < t by A36,XREAL_1:6;
              then y < m by A30,XXREAL_0:2;
              then
A38:          Dy.a > 0 by A6;
              then I is_closed_on Dy,py & I is_halting_on Dy,py by A1;
              then
A39:          IC Dt = 0 by A37,A38,SCMFSA_9:42;
              consider z being Element of NAT such that
A40:          StepWhile>0(a,I,p,s).t=Comput(p1,s1,z) and
A41:          z <= q by A30;
              consider w being Nat such that
A42:          q = z+w by A41,NAT_1:10;
              reconsider w as Element of NAT by ORDINAL1:def 12;
A43: Dt = Initialize Dt by A40,A39,SCMFSA_9:45;
A44:          Comput(p1,s1,q)
                = Comput(pt +* while>0(a,I),Initialize Dt,w)
                 by A43,A40,A42,EXTPRO_1:4;
              set z2=z +(LifeSpan(pt +* I,Initialize Dt) + 3);
A45:          t < m by A30,A35,XXREAL_0:1;
              now
                assume
A46:            z2 <= q;
A47:            now
                  take k=z2;
                  thus StepWhile>0(a,I,p,s).(t+1)
                  =Comput(p1,s1,k) &
k <= q by A40,A39,A46,SCMFSA_9:45;
                end;
                t+1 <= m by A45,NAT_1:13;
                hence contradiction by A30,A47,XREAL_1:29;
              end;
              then
A48:          w < LifeSpan(pt +* I,Initialize Dt) + 3 by A42,XREAL_1:6;
A49:          Dt.a > 0 by A6,A45;
              then I is_closed_on Dt,pt & I is_halting_on Dt,pt by A1;
              hence IC Comput(p1,s1,q) in dom while>0(a,I) by A48,A44,A49,
SCMFSA_9:42;
            end;
          end;
      end;
      hence while>0(a,I) is_closed_on s,p by SCMFSA7B:def 6;
    end;
end;

theorem Th28: :: SCMFSA_9:43, corrected
  for I being parahalting Program of SCM+FSA
   st WithVariantWhile>0 a, I, s, p
    holds while>0(a,I) is_halting_on s,p & while>0(a,I) is_closed_on s,p
proof
  let I be parahalting Program of SCM+FSA such that
A1: WithVariantWhile>0 a,I,s,p;
  ProperBodyWhile>0 a,I,s,p
  proof
    let k be Element of NAT;
    assume StepWhile>0(a,I,p,s).k.a > 0;
    thus thesis by SCMFSA7B:18,19;
  end;
  hence thesis by A1,Th27;
end;

theorem Th29: :: based on SCMFSA_9:32
  for s being 0-started State of SCM+FSA
   st while>0(a, I) c= p & s.a <= 0
  holds LifeSpan(p,s) = 4 & for k being Element of NAT
   holds DataPart Comput(p,s,k) = DataPart s
proof
 let s be 0-started State of SCM+FSA;
  assume that
A1: while>0(a, I) c= p and
A2: s.a <= 0;
A3: p +* while>0(a, I) = p by A1,FUNCT_4:98;
  set i = a >0_goto  4;
  set p1 = p +* while>0(a,I);
A4: while>0(a,I) c= p1 by FUNCT_4:25;
A5: IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
A6:  1 in dom while>0(a,I) by SCMFSA_9:10;
A7: p1. 1 = while>0(a,I). 1 by A6,FUNCT_4:13
    .= goto  2 by SCMFSA_9:11;
    s = Initialize s by MEMSTR_0:44;
    then
A8: IC s = IC Start-At(0,SCM+FSA) by A5,FUNCT_4:13
    .=  0 by FUNCOP_1:72;
A9:  p1/.IC s = p1.IC s by PBOOLE:143;
  0 in dom while>0(a,I) by SCMFSA_9:10;
  then p1. 0 = while>0(a,I). 0 by FUNCT_4:13
    .= i by SCMFSA_9:11;
  then
A10: CurInstr(p1,s) = i by A8,A9;
A11: Comput(p1,s,0+1) = Following(p1,Comput(p1,s,0)) by EXTPRO_1:3
    .= Following(p1,s)
    .= Exec(i,s) by A10;
  set loc5= card I +5;
  set s5 = Comput(p1,s,4), s4 = Comput(p1,s,3),
      s3 = Comput(p1,s,2), s2 = Comput(p1,s,1);
A12:  2 in dom while>0(a,I) by SCMFSA_9:32;
A13: p1. 2 = while>0(a,I). 2 by A12,FUNCT_4:13
    .= goto  3 by SCMFSA_9:36;
A14:  3 in dom while>0(a,I) by SCMFSA_9:32;
A15: p1. 3 = while>0(a,I). 3 by A14,FUNCT_4:13
    .= goto loc5 by SCMFSA_9:35;
A16: loc5 in dom while>0(a,I) by SCMFSA_9:33;
A17: p1.loc5 = while>0(a,I).loc5 by A16,A4,GRFUNC_1:2
    .= halt SCM+FSA by SCMFSA_9:34;
A18: ( for c being Int-Location holds Exec(goto loc5, s4).c = s4.c)& for f
  being FinSeq-Location holds Exec(goto loc5, s4).f = s4.f by SCMFSA_2:69;
A19: ( for c being Int-Location holds Exec(goto  2, s2).c = s2.c)& for
f being FinSeq-Location holds Exec(goto  2, s2).f = s2.f by SCMFSA_2:69;
A20:  p1/.IC Comput(p1,s,1) = p1.IC Comput(p1,s,1) by PBOOLE:143;
  IC Comput(p1,s,1) = succ  0 by A2,A8,A11,SCMFSA_2:71
    .= 0 + 1;
  then
A21: CurInstr(p1,Comput(p1,s,1))
 = goto  2 by A7,A20;
A22: Comput(p1,s,1+1) = Following(p1,s2) by EXTPRO_1:3
    .= Exec(goto  2,s2) by A21;
A23:  p1/.IC s3 = p1.IC s3 by PBOOLE:143;
  IC s3 =  2 by A22,SCMFSA_2:69;
  then
A24: CurInstr(p1,s3) = goto  3 by A13,A23;
A25: Comput(p1,s,2+1) = Following(p1,s3) by EXTPRO_1:3
    .= Exec(goto  3,s3) by A24;
A26:  p1/.IC s4 = p1.IC s4 by PBOOLE:143;
  IC s4 =  3 by A25,SCMFSA_2:69;
  then
A27: CurInstr(p1,s4) = goto loc5 by A15,A26;
A28: Comput(p1,s,3+1) = Following(p1,s4) by EXTPRO_1:3
    .= Exec(goto loc5,s4) by A27;
A29:  p1/.IC s5 = p1.IC s5 by PBOOLE:143;
  IC s5 = loc5 by A28,SCMFSA_2:69;
  then
A30: CurInstr(p1,s5) = halt SCM+FSA by A17,A29;
  then
A31: p1 halts_on s by EXTPRO_1:29;
  now
    let k;
    assume
A32: CurInstr(p,Comput(p,s,k)) = halt SCM+FSA;
    assume 4 > k;
    then 3+1 > k;
    then
A33: k <= 3 by NAT_1:13;
    per cases by A33,NAT_1:27;
    suppose
      k = 0;
      then Comput(p,s,k) = s by EXTPRO_1:2;
      hence contradiction by A10,A32,A3;
    end;
    suppose
      k = 1;
      hence contradiction by A21,A32,A3;
    end;
    suppose
      k = 2;
      hence contradiction by A24,A32,A3;
    end;
    suppose
      k = 3;
      hence contradiction by A27,A32,A3;
    end;
  end;
  hence
A34: LifeSpan(p,s) = 4 by A30,A31,A3,EXTPRO_1:def 15;
A35: ( for c being Int-Location holds Exec(i, s).c = s.c)& for f being
  FinSeq-Location holds Exec(i, s).f = s.f by SCMFSA_2:71;
  then
A36: DataPart Comput(p,s,1) = DataPart s by A11,A3,SCMFSA_M:2;
  then
A37: DataPart Comput(p,s,2) = DataPart s by A22,A19,A3,SCMFSA_M:2;
A38: ( for c being Int-Location holds Exec(goto  3, s3).c = s3.c)& for
f being FinSeq-Location holds Exec(goto  3, s3).f = s3.f by SCMFSA_2:69;
  then DataPart Comput(p,s,3) = DataPart s by A25,A37,A3,SCMFSA_M:2;
  then
A39: DataPart Comput(p,s,4) = DataPart s by A28,A18,A3,SCMFSA_M:2;
  let k be Element of NAT;
  k <= 3 or 3 < k;
  then
A40: k = 0 or k = 1 or k = 2 or k = 3 or 3+1 <= k by NAT_1:13,27;
  per cases by A40;
  suppose
    k = 0;
    hence thesis by EXTPRO_1:2;
  end;
  suppose
    k = 1;
    hence thesis by A11,A35,A3,SCMFSA_M:2;
  end;
  suppose
    k = 2;
    hence thesis by A22,A19,A36,A3,SCMFSA_M:2;
  end;
  suppose
    k = 3;
    hence thesis by A25,A38,A37,A3,SCMFSA_M:2;
  end;
  suppose
    4 <= k;
    then CurInstr(p,Comput(p,s,k))
     = halt SCM+FSA by A31,A34,A3,EXTPRO_1:36;
    hence thesis by A34,A39,EXTPRO_1:24;
  end;
end;

theorem Th30: :: based on SCMFSA_9:36
  I is_closed_on s,p & I is_halting_on s,p & s.a > 0 implies DataPart
  Comput(p +* while>0(a,I),Initialize s,LifeSpan(p +* I,Initialize s) + 3)
     = DataPart Comput(p +* I,Initialize s,LifeSpan(p +* I,Initialize s))
proof
  assume that
A1: I is_closed_on s,p & I is_halting_on s,p and
A2: s.a > 0;
  set sI = Initialize s,
      pI = p +* I;
  set s1 = Initialize s,
      p1 = p +* while>0(a,I);
A3: while>0(a,I) c= p1 by FUNCT_4:25;
  defpred P[Nat] means $1 <= LifeSpan(pI,sI) implies IC Comput(
p1,s1,
  1+$1) = IC Comput(pI,sI,$1) + 4 &
  DataPart Comput(p1,s1,1+$1) = DataPart Comput(pI,sI,$1);
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    now
A6:   k + 0 < k + 1 by XREAL_1:6;
      assume k + 1 <= LifeSpan(pI,sI);
      then k < LifeSpan(pI,sI) by A6,XXREAL_0:2;
      hence IC Comput(p1,s1,1+k+1) = IC Comput(pI,sI,
k+1) + 4 & DataPart
Comput(p1,s1,1+k+1) = DataPart Comput(pI,sI,k+1) by A1,A5,SCMFSA_9:39;
    end;
    hence P[k + 1];
  end;
  set i = a >0_goto  4;
  set s2 = Comput(p1,s1,1),
      p2 = p1;
A7: IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
A8: IC s1 = IC Start-At(0,SCM+FSA) by A7,FUNCT_4:13
    .=  0 by FUNCOP_1:72;
  not a in dom Start-At(0,SCM+FSA) by SCMFSA_2:102;
  then
A9: s1.a = s.a by FUNCT_4:11;
  set loc4 =  (card I + 4);
A10:  p1/.IC s1 = p1.IC s1 by PBOOLE:143;
  0 in dom while>0(a,I) by SCMFSA_9:10;
  then p1. 0 = while>0(a,I). 0
  by FUNCT_4:13
    .= i by SCMFSA_9:11;
  then
A11: CurInstr(p1,s1) = i by A8,A10;
A12: Comput(p1,s1,0+1) =
Following(p1,Comput(p1,s1,0)
)
 by EXTPRO_1:3
    .= Following(p1,s1)
    .= Exec(i,s1) by A11;
  then ( for c being Int-Location holds s2.c = s1.c)& for f being
  FinSeq-Location holds s2.f = s1.f by SCMFSA_2:71;
  then
A13: DataPart s2 = DataPart s1 by SCMFSA_M:2
    .= DataPart sI;
A14: IC s2 =  4 by A2,A12,A9,SCMFSA_2:71;
A15: P[0]
  proof
    assume 0 <= LifeSpan(pI,sI);
A16: IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
    IC Comput(pI,sI,0) = IC sI
      .= IC Start-At(0,SCM+FSA) by A16,FUNCT_4:13
      .=  0 by FUNCOP_1:72;
    hence thesis by A14,A13;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A15,A4);
  then
A17: P[LifeSpan(pI,sI) qua Element of NAT];
  set s4=Comput(p1,s1,1+LifeSpan(pI,sI)+1+1),
      p4 = p1;
  set s3 = Comput(p1,s1,1+LifeSpan(pI,sI)+1),
      p3 = p1;
A18: loc4 in dom while>0(a,I) by SCMFSA_9:33;
  set s2 = Comput(p1,s1,1+LifeSpan(pI,sI));
A19: CurInstr(p2,s2) = goto loc4 by A1,A17,SCMFSA_9:40;
A20: s3 = Following(p1,s2) by EXTPRO_1:3
    .= Exec(goto loc4,s2) by A19;
  then
A21: ( for c being Int-Location holds s3.c = s2.c)& for f being
  FinSeq-Location holds s3.f = s2.f by SCMFSA_2:69;
A22: p3.loc4 = while>0(a,I).loc4 by A18,A3,GRFUNC_1:2
    .= goto  0 by SCMFSA_9:41;
A23:  p3/.IC s3 = p3.IC s3 by PBOOLE:143;
  IC s3 = loc4 by A20,SCMFSA_2:69;
  then
A24: CurInstr(p3,s3) = goto  0 by A22,A23;
  s4 = Following(p1,s3) by EXTPRO_1:3
    .= Exec(goto  0,s3) by A24;
  then ( for c being Int-Location holds s4.c = s3.c)& for f being
  FinSeq-Location holds s4.f = s3.f by SCMFSA_2:69;
  hence DataPart Comput(p1,s1,LifeSpan(pI,sI)+3) =
DataPart s3 by SCMFSA_M:2
    .= DataPart Comput(pI,sI,LifeSpan(pI,sI)) by A17,A21,SCMFSA_M:2;
end;

theorem Th31: :: Step_gt0_0:
  (StepWhile>0(a,I,p,s).k).a <= 0 implies
   DataPart StepWhile>0(a,I,p,s).(k+1) = DataPart StepWhile>0(a,I,p,s).k
proof
  assume
A1: (StepWhile>0(a,I,p,s).k).a <= 0;
  set SW = StepWhile>0(a,I,p,s),
      PW = p +* while>0(a,I);
A2: while>0(a,I) c= PW by FUNCT_4:25;
A3: DataPart(Initialize(SW.k)) = DataPart SW.k
by MEMSTR_0:79;
  then
A4: SW.k.a = (Initialize(SW.k)).a by SCMFSA_M:2;
  thus DataPart SW.(k+1) = DataPart Comput(PW +* while>0(a,I),
     (Initialize(SW.k)
  ), (LifeSpan(PW +* I,Initialize(SW.k)) + 3)) by SCMFSA_9:def 5
    .= DataPart StepWhile>0(a,I,p,s).k by A1,A3,A4,Th29,A2;
end;

theorem Th32: :: Step_gt0_1:
  ( I is_halting_on Initialized StepWhile>0(a,I,p,s).k ,p+*while>0(a,I) & I
  is_closed_on Initialized StepWhile>0(a,I,p,s).k ,p+*while>0(a,I) or
  I is parahalting) & (
  StepWhile>0(a,I,p,s).k).a > 0 & (StepWhile>0(a,I,p,s).k).intloc 0 = 1 implies
DataPart StepWhile>0(a,I,p,s).(k+1)
 = DataPart IExec(I,p+*while>0(a,I),StepWhile>0(a,I,p,s).k)
proof
  set Ins = NAT;
  assume that
A1: I is_halting_on Initialized StepWhile>0(a,I,p,s).k ,p+*while>0(a,I) &
   I is_closed_on Initialized StepWhile>0(a,I,p,s).k ,p+*while>0(a,I) or
   I is parahalting and
A2: (StepWhile>0(a,I,p,s).k).a > 0 and
A3: (StepWhile>0(a,I,p,s).k).intloc 0 = 1;
  set SW = StepWhile>0(a,I,p,s), PW = p +* while>0(a,I);
  set ISWk = Initialized(SW.k);
  set SWkI = Initialized(SW.k), PWI = p +* while>0(a,I) +* I;
  DataPart ISWk = DataPart SW.k by A3,SCMFSA_M:19;
  then
A4: I is_closed_on SW.k ,PW & I is_halting_on SW.k ,PW
    by A1,SCMFSA7B:18,19,SCMFSA8B:5;
  I is_halting_on ISWk ,PW by A1,SCMFSA7B:19;
  then
A5: I is_halting_on Initialized SW.k ,PW;
    Initialized(SW.k) = Initialize Initialized(SW.k) by MEMSTR_0:44;
    then
A6:  PW +* I halts_on Initialized(SW.k) by A5,SCMFSA7B:def 7;
A7: PWI halts_on SWkI by A6;
  set SWkIS = Initialize(SW.k),
          PWIS = PW +* I;
A8: SWkI = SWkIS by A3,SCMFSA_M:18;
A9: SW.(k+1)
   = Comput(PW +* while>0(a,I),(Initialize(SW.k)),LifeSpan(PWIS,SWkIS)+ 3)
     by SCMFSA_9:def 5;
A10: DataPart IExec(I,PW,SW.k)
     = DataPart(Result(PWI,SWkI)) by SCMFSA6B:def 1
    .= DataPart Result(PWI,SWkI)
    .= DataPart Comput(PWIS,SWkIS,LifeSpan(PWIS,SWkIS)) by A8,A7,EXTPRO_1:23;
  thus
  DataPart StepWhile>0(a,I,p,s).(k+1)
   = DataPart Comput(PWIS,SWkIS,LifeSpan(PWIS,SWkIS))
  by A2,A4,Th30,A9
   .= DataPart IExec(I,PW,StepWhile>0(a,I,p,s).k) by A10;
end;

theorem Th33: :: GoodStep0:
  (ProperBodyWhile>0 a,Ig,s,p or Ig is parahalting) & s.intloc 0 =
  1 implies for k holds StepWhile>0(a,Ig,p,s).k.intloc 0 = 1
proof
  set I = Ig;
  assume that
A1: ProperBodyWhile>0 a,I,s,p or I is parahalting and
A2: s.intloc 0 = 1;
  set SW = StepWhile>0(a,I,p,s),
      PW = p +* while>0(a,I);
  defpred X[Nat] means SW.$1.intloc 0 = 1;
A3: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT such that
A4: SW.k.intloc 0 = 1;
    per cases;
    suppose
      SW.k.a <= 0;
      then DataPart SW.(k+1) = DataPart SW.k by Th31;
      hence thesis by A4,SCMFSA_M:2;
    end;
    suppose
A5:   SW.k.a > 0;
      set SWkI = Initialized SW.k, PWI = p +* while>0(a,I) +* I;
A6:   DataPart SW.k = DataPart SWkI by A4,SCMFSA_M:19;
      set Ins = NAT;
      set SWkIS = Initialize(SW.k),
          PWIS = PW +* I;
A7:   SWkI = SWkIS by A4,SCMFSA_M:18;
A8:   ProperBodyWhile>0 a,I,s,p by A1,Th26;
      then
A9:  I is_closed_on SW.k ,PW by A5,Def4;
      I is_halting_on SW.k ,PW by A5,A8,Def4;
      then
A10:  I is_halting_on Initialized SW.k ,PW by A9,A6,SCMFSA8B:5;
     Initialized SW.k = Initialize Initialized(SW.k) by MEMSTR_0:44;
    then
A11:  PW +* I halts_on Initialized SW.k by A10,SCMFSA7B:def 7;
A12:  PWI halts_on SWkI by A11;
A13:  DataPart IExec(I,PW,SW.k) = DataPart(Result(PWI,SWkI)) by SCMFSA6B:def 1
        .= DataPart Result(PWI,SWkI)
        .= DataPart Comput(PWIS,SWkIS,LifeSpan(PWIS,SWkIS))
         by A7,A12,EXTPRO_1:23;
      I is_closed_on Initialized SW.k ,PW by A9,A6,SCMFSA8B:3;
      then DataPart SW.(k+1) = DataPart IExec(I,PW,SW.k) by A4,A5,A10,Th32;
      hence
      SW.(k+1).intloc 0 = (Comput(PWIS,SWkIS,LifeSpan(PWIS,SWkIS))).intloc 0
            by A13,SCMFSA_M:2
        .= 1 by A4,A9,SCMFSA8C:68;
    end;
  end;
A14: X[0] by A2,SCMFSA_9:def 5;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A14,A3);
end;

theorem Th34:
  ProperBodyWhile>0 a,I,s1,p1 & DataPart s1 = DataPart s2 implies
for k holds DataPart StepWhile>0(a,I,p1,s1).k
 = DataPart StepWhile>0(a,I,p2,s2).k
proof
  assume that
A1: ProperBodyWhile>0 a,I,s1,p1 and
A2: DataPart s1 = DataPart s2;
  set WH = while>0(a,I);
  set ST2 = StepWhile>0(a,I,p2,s2),
      PT2 = p2 +* while>0(a,I);
  set ST1 = StepWhile>0(a,I,p1,s1),
      PT1 = p1 +* while>0(a,I);
  defpred X[Nat] means DataPart ST1.$1 = DataPart ST2.$1;
A3: for k st X[k] holds X[k+1]
  proof
    let k;
    set ST1kI = Initialize(ST1.k),
        PT1I = PT1 +* I;
    set ST2kI = Initialize(ST2.k),
        PT2I = PT2 +* I;
A4: I c= PT1I by FUNCT_4:25;
A5: I c= PT2I by FUNCT_4:25;
    assume
A6: DataPart ST1.k = DataPart ST2.k;
    then
A7: ST1.k.a = ST2.k.a by SCMFSA_M:2;
    per cases;
    suppose
A8:   ST1.k.a <= 0;
      hence DataPart ST1.(k+1) = DataPart ST1.k by Th31
        .= DataPart ST2.(k+1) by A6,A7,A8,Th31;
    end;
    suppose
A9:   ST1.k.a > 0;
      then
A10:   I is_closed_on ST1.k, PT1 by A1,Def4;
A11:   I is_halting_on ST1.k, PT1 by A1,A9,Def4;
      then
A12:  I is_closed_on ST2.k, PT2 & I is_halting_on ST2.k, PT2
         by A6,A10,SCMFSA8B:5;
A13:  DataPart ST1.(k+1) = DataPart Comput(PT1 +* while>0(a,I),
(Initialize(ST1.k)), (
      LifeSpan(PT1I,ST1kI) + 3)) by SCMFSA_9:def 5
        .= DataPart Comput(PT1I,(ST1kI),
        LifeSpan(PT1I,ST1kI)) by A9,A10,A11,Th30;
A14:  DataPart ST2.(k+1) = DataPart Comput(PT2 +* while>0(a,I),
(Initialize(ST2.k)), (
      LifeSpan(PT2I,ST2kI) + 3)) by SCMFSA_9:def 5
        .= DataPart Comput(PT2I,(ST2kI),
         LifeSpan(PT2I,ST2kI)) by A7,A9,A12,Th30;
A15:  DataPart ST1.k = DataPart ST1kI by MEMSTR_0:79;
      then
A16:  I is_closed_on ST1kI, PT1I by A10,SCMFSA8B:3;
A17:  DataPart ST1kI = DataPart ST1.k by MEMSTR_0:79
        .= DataPart ST2kI by A6,MEMSTR_0:79;
      I is_halting_on ST1kI, PT1I by A10,A11,A15,SCMFSA8B:5;
      then (LifeSpan(PT1I,ST1kI)) = (LifeSpan(PT2I,
ST2kI)) by A10,A17,A15,A4,A5,SCMFSA8B:3,SCMFSA8C:18;
      hence thesis by A13,A14,A17,A16,A4,A5,SCMFSA8C:17;
    end;
  end;
  DataPart ST1.0 = DataPart s1 by SCMFSA_9:def 5
    .= DataPart ST2.0 by A2,SCMFSA_9:def 5;
  then
A18: X[0];
  thus for k holds X[k] from NAT_1:sch 1(A18, A3);
end;

definition let p;
  let s be State of SCM+FSA, a be read-write Int-Location, I be Program of
  SCM+FSA;
  assume that
A1: ProperBodyWhile>0 a,I,s,p or I is parahalting and
A2: WithVariantWhile>0 a,I,s,p;
  func ExitsAtWhile>0(a, I, p, s) -> Element of NAT means
  :Def6:
  ex k being Element of NAT st it = k &
    (StepWhile>0(a,I,p,s).k).a <= 0 &
    (for i being Element of NAT st (StepWhile>0(a,I,p,s).i).a <= 0
     holds k <= i) &
    DataPart Comput(p +* while>0(a, I),
        Initialize s,
       (LifeSpan(p +* while>0(a, I),
        Initialize s)))
     = DataPart StepWhile>0(a,I,p,s).k;
  existence
  proof
    set S = Initialize s,
        P = p +* while>0(a, I);
    set SW = StepWhile>0(a,I,p,s),
      PW = p +* while>0(a,I);
A3: while>0(a,I) c= PW by FUNCT_4:25;
    defpred X[Nat] means SW.$1.a <= 0;
    consider f being Function of product the_Values_of SCM+FSA, NAT such
    that
A4: for k being Element of NAT holds f.(SW.(k+1))<f.(SW.k) or X[k] by A2,Def5;
    deffunc U(Nat) = f.(SW.$1);
A5: for k being Element of NAT holds U(k+1)<U(k) or X[k] by A4;
    consider m such that
A6: X[m] and
A7: for n st X[n] holds m <= n from NAT_1:sch 18(A5);
    take m, m;
    thus m = m;
    thus SW.m.a <= 0 by A6;
    thus for n st SW.n.a <= 0 holds m <= n by A7;
    defpred P[Nat] means $1+1 <= m implies
     ex k st StepWhile>0(a,I,p,s).($1+1)=Comput(P,S,k);
A8: ProperBodyWhile>0 a,I,s,p by A1,Th26;
A9: now
      let k be Element of NAT;
      assume
A10:  P[k];
      now
        set sk1=StepWhile>0(a,I,p,s).(k+1);
        set sk=StepWhile>0(a,I,p,s).k,
          pk = p +* while>0(a,I);
        assume
A11:    (k+1)+ 1 <= m;
        k + 0 < k+ (1+ 1) by XREAL_1:6;
        then k < m by A11,XXREAL_0:2;
        then
A12:    sk.a > 0 by A7;
        (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:6;
        then consider n being Element of NAT such that
A13:    sk1 = Comput(P,S,n) by A10,A11,XXREAL_0:2;
A14:    sk1 = Comput(pk +* while>0(a,I),(Initialize sk),
        (LifeSpan(pk +* I,Initialize sk) + 3)) by SCMFSA_9:def 5;
        take m=n +(LifeSpan(pk +* I,Initialize sk1) +
3);
        I is_closed_on sk,pk & I is_halting_on sk,pk by A8,A12,Def4;
        then IC sk1 = 0 by A14,A12,SCMFSA_9:42;
        hence StepWhile>0(a,I,p,s).((k+1)+1)=Comput(P,S,m) by A13,SCMFSA_9:45;
      end;
      hence P[k+1];
    end;
A15: IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
A16: P[0]
    proof
      assume 0+1 <= m;
      take n=(LifeSpan(p +*while>0(a,I) +* I,Initialize s) + 3);
      thus thesis by SCMFSA_9:44;
    end;
A17: for k being Element of NAT holds P[k] from NAT_1:sch 1(A16,A9);
    per cases;
    suppose
A18:  m = 0;
A19:  DataPart S = DataPart s by MEMSTR_0:79
        .= DataPart SW.m by A18,SCMFSA_9:def 5;
      then S.a = SW.m.a by SCMFSA_M:2;
      hence thesis by A6,A19,Th29,A3;
    end;
    suppose
A20:  m <> 0;
      set sm = StepWhile>0(a,I,p,s).m,
          pm = p +* while>0(a,I);
      set sm1 = Initialize sm,
          pm1 = pm +* while>0(a,I);
      consider i being Nat such that
A21:  m=i+1 by A20,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 12;
      set si = StepWhile>0(a,I,p,s).i,
          psi = p +* while>0(a,I);
A22:  sm = Comput(psi +* while>0(a,I),(Initialize si),
      (LifeSpan(psi +* I,Initialize si) + 3))
      by A21,SCMFSA_9:def 5;
      m=i+1 by A21;
      then consider n being Element of NAT such that
A23:  sm = Comput(P,S,n) by A17;
      i < m by A21,NAT_1:13;
      then
A24:  si.a > 0 by A7;
      then I is_closed_on si,psi & I is_halting_on si,psi by A8,Def4;
      then
A25:  IC sm = 0 by A22,A24,SCMFSA_9:42;
A26:  IC sm1 = IC Start-At(0,SCM+FSA) by A15,FUNCT_4:13
        .= IC sm by A25,FUNCOP_1:72;
      DataPart sm1 = DataPart sm by MEMSTR_0:79;
      then
A27:  sm1 = sm by A26,MEMSTR_0:78;
      while>0(a,I) is_halting_on sm,pm by A6,SCMFSA_9:38;
      then pm1 halts_on sm1 by SCMFSA7B:def 7;
      then consider j being Element of NAT such that
A28:  CurInstr(pm,Comput(pm,sm,j)) = halt SCM+FSA by A27,EXTPRO_1:29;
A29: Comput(P,S,n+j) = Comput(P,Comput(P,S,n),j) by EXTPRO_1:4;
      CurInstr(P,Comput(P,S,n+j)) = halt SCM+FSA by A23,A28,A29;
      then
A30:  Comput(P,S,LifeSpan(P,S)) = Comput(P,S,n+j) by EXTPRO_1:24
        .= Comput(P,sm,j) by A23,EXTPRO_1:4
        .= Comput(pm,sm,LifeSpan(pm,sm)) by A28,EXTPRO_1:24;
      Start-At(0,SCM+FSA) c= sm by A27,FUNCT_4:25;
      then sm is 0-started by MEMSTR_0:29;
      hence thesis by A6,A30,Th29,A3;
    end;
  end;
  uniqueness
  proof
    let it1, it2 be Element of NAT;
    given k1 being Element of NAT such that
A31: it1 = k1 and
A32: (StepWhile>0(a,I,p,s).k1).a <= 0 & for i being Element of NAT st
    ( StepWhile>0(a,I,p,s).i).a <= 0 holds k1 <= i and
    DataPart(Comput(p +* while>0(a,I),(Initialize s),
    (LifeSpan(p +* while>0(a,I),Initialize s)))) =
    DataPart StepWhile>0(a,I,p,s).k1;
    given k2 being Element of NAT such that
A33: it2 = k2 and
A34: (StepWhile>0(a,I,p,s).k2).a <= 0 & for i being Element of NAT st
    ( StepWhile>0(a,I,p,s).i).a <= 0 holds k2 <= i and
    DataPart(Comput(p +* while>0(a,I),(Initialize s),
    (LifeSpan(p +* while>0(a,I),Initialize s))))
     = DataPart StepWhile>0(a,I,p,s).k2;
    k1 <= k2 & k2 <= k1 by A32,A34;
    hence thesis by A31,A33,XXREAL_0:1;
  end;
end;

theorem :: IE_while_le0:
  s.intloc 0 = 1 & s.a <= 0 implies DataPart IExec(while>0(a,I),p,s) =
  DataPart s
proof
  assume that
A1: s.intloc 0 = 1 and
A2: s.a <= 0;
  set WH = while>0(a, I);
  set Is = Initialized s, pds = p +* WH;
A3: while>0(a,I) c= pds by FUNCT_4:25;
A4: Is = Initialize Is by MEMSTR_0:44;
  Is.a = s.a by SCMFSA_M:37;
  then WH is_halting_on Is,p by A2,SCMFSA_9:38;
  then
A5: pds halts_on Is by A4,SCMFSA7B:def 7;
A6: Is.a = Is.a
    .= s.a by SCMFSA_M:37;
  thus DataPart IExec(WH,p,s)
   = DataPart Result(p +* WH,Initialized s) by SCMFSA6B:def 1
    .= DataPart Comput(pds,Is,LifeSpan(pds,Is)) by A5,EXTPRO_1:23
    .= DataPart Initialized s by A2,A6,Th29,A3
    .= DataPart s by A1,SCMFSA_M:19;
end;

theorem Th36: :: IE_while_gt0:
  (ProperBodyWhile>0 a,I,Initialized s,p or I is parahalting) &
WithVariantWhile>0 a,I,Initialized s,p implies DataPart IExec(while>0(a,I),p,s)
  = DataPart
  StepWhile>0(a,I,p,Initialized s).ExitsAtWhile>0(a,I,p,Initialized s)
proof
  set Ins = NAT;
  set WH = while>0(a, I);
  set Is = Initialized s, pds = p +* WH;
A1: Is = Initialize Is by MEMSTR_0:44;
  assume
A2: ( ProperBodyWhile>0 a,I,Initialized s,p or I is parahalting)&
  WithVariantWhile>0 a,I,Initialized s,p;
  then
A3: ex k being Element of NAT st ExitsAtWhile>0(a,I,p,Is) = k &
 (StepWhile>0(a,I,p,Is).k).a <= 0 &
 ( for i being Element of NAT st ( StepWhile>0(a,I,p,Is).i)
.a <= 0 holds k <= i)& DataPart (Comput(p +* while>0(a,I),
  Initialize Is, LifeSpan(p +* while>0(a,I),Initialize Is)))
  = DataPart StepWhile>0(a,I,p,Is).k
  by Def6;
  WH is_halting_on Is,p by A2,Th27,Th28;
  then
A4: pds halts_on Is by A1,SCMFSA7B:def 7;
  thus DataPart IExec(WH,p,s)
   = DataPart Result(p +* WH,Initialized s) by SCMFSA6B:def 1
    .= DataPart StepWhile>0(a,I,p,Is).ExitsAtWhile>0(a,I,p,Is) by A1,A4,A3,
EXTPRO_1:23;
end;

theorem Th37:
  StepWhile>0(a,I,p,s).k.a <= 0 implies for n being Element of NAT
     st k <= n
    holds DataPart StepWhile>0(a,I,p,s).n = DataPart StepWhile>0(a,I,p,s).k
proof
  set SW = StepWhile>0(a,I,p,s),
      PW = p +* while>0(a,I);
  defpred P[Nat] means k <= $1 implies DataPart SW.$1 = DataPart SW.k;
  assume
A1: StepWhile>0(a,I,p,s).k.a <= 0;
A2: now
    let n be Element of NAT such that
A3: P[n];
    thus P[n+1]
    proof
      assume
A4:   k <= n+1;
      per cases by A4,NAT_1:8;
      suppose
A5:     k <= n;
        then SW.n.a <= 0 by A1,A3,SCMFSA_M:2;
        hence thesis by A3,A5,Th31;
      end;
      suppose
        k = n+1;
        hence thesis;
      end;
    end;
  end;
A6: P[0];
  thus for n being Element of NAT holds P[n] from NAT_1:sch 1(A6, A2 );
end;

theorem
  DataPart s1 = DataPart s2 & ProperBodyWhile>0 a,I,s1,p1 implies
  ProperBodyWhile>0 a,I,s2,p2
proof
  assume that
A1: DataPart s1 = DataPart s2 and
A2: ProperBodyWhile>0 a,I,s1,p1;
  let k be Element of NAT such that
A3: StepWhile>0(a,I,p2,s2).k.a > 0;
A4: DataPart StepWhile>0(a,I,p2,s2).k
     = DataPart StepWhile>0(a,I,p1,s1).k by A1,A2,Th34;
  then StepWhile>0(a,I,p1,s1).k.a > 0 by A3,SCMFSA_M:2;
  then
  I is_closed_on StepWhile>0(a,I,p1,s1).k, p1+*while>0(a,I) &
  I is_halting_on StepWhile>0(a,I,p1,s1).k, p1+*while>0(a,I) by A2,Def4;
  hence thesis by A4,SCMFSA8B:5;
end;

Lm7: s.intloc 0 = 1 implies
 (I is_closed_on s,p iff I is_closed_on Initialized s,p)
proof
  assume s.intloc 0 = 1;
  then DataPart Initialized s = DataPart s by SCMFSA_M:19;
  hence thesis by SCMFSA8B:3;
end;

Lm8: s.intloc 0 = 1 implies ( I is_closed_on s,p & I is_halting_on s,p iff I
is_closed_on Initialized s,p & I is_halting_on Initialized s,p)

proof
  assume s.intloc 0 = 1;
  then DataPart Initialized s = DataPart s by SCMFSA_M:19;
  hence thesis by SCMFSA8B:5;
end;

theorem Th39:
  s.intloc 0 = 1 & ProperBodyWhile>0 a,Ig,s,p &
   WithVariantWhile>0 a, Ig, s, p
    implies for i, j st i <> j & i <= ExitsAtWhile>0(a,Ig,p,s) & j <=
ExitsAtWhile>0(a,Ig,p,s) holds StepWhile>0(a,Ig,p,s).i <> StepWhile>0(a,Ig,p,s)
  .j & DataPart StepWhile>0(a,Ig,p,s).i <> DataPart StepWhile>0(a,Ig,p,s).j
proof
  set I = Ig;
  assume that
A1: s.intloc 0 = 1 and
A2: ProperBodyWhile>0 a,I,s,p and
A3: WithVariantWhile>0 a,I,s,p;
  set SW = StepWhile>0(a,I,p,s),
      PW = p +* while>0(a,I);
  consider K being Element of NAT such that
A4: ExitsAtWhile>0(a,I,p,s) = K and
A5: SW.K.a <= 0 and
A6: for i being Element of NAT st SW.i.a <= 0 holds K <= i and
  DataPart Comput(p +* while>0(a,I),(Initialize s),
  (LifeSpan(p +* while>0(a,I),s +* (
  Start-At(0,SCM+FSA))))) = DataPart SW.K by A2,A3,Def6;
  consider f being Function of product the_Values_of SCM+FSA, NAT such
  that
A7: for k being Element of NAT holds f.(SW.(k+1)) < f.(SW.k) or SW.k.a
  <= 0 by A3,Def5;
A8: for i, j being Element of NAT st i < j & i <= K & j <= K holds DataPart
  SW.i <> DataPart SW.j
  proof
    let i, j be Element of NAT such that
A9: i < j and
    i <= K and
A10: j <= K;
    per cases by A10,XXREAL_0:1;
    suppose
A11:  j = K;
      assume DataPart SW.i = DataPart SW.j;
      then SW.i.a <= 0 by A5,A11,SCMFSA_M:2;
      hence contradiction by A6,A9,A11;
    end;
    suppose
A12:  j < K;
      defpred X[Nat] means j+$1 <= K implies DataPart SW.(i+$1) =
      DataPart SW.(j+$1);
A13:  for k being Element of NAT st X[k] holds X[k+1]
      proof
        let k be Element of NAT such that
A14:    j+k <= K implies DataPart SW.(i+k) = DataPart SW.(j+k) and
A15:    j+(k+1) <= K;
A16:    SW.(j+k).intloc 0 = 1 by A1,A2,Th33;
A17:    j+k < (j+k)+1 by XREAL_1:29;
        then
A18:    j+k < K by A15,XXREAL_0:2;
        then
A19:    SW.(j+k).a > 0 by A6;
        then
A20:    I is_closed_on SW.(j+k), PW by A2,Def4;
        then
A21:    I is_closed_on Initialized SW.(j+k), PW by A16,Lm7;
A22:    I is_halting_on SW.(j+k), PW by A2,A19,Def4;
        then
A23:    I is_halting_on Initialized SW.(j+k), PW by A16,A20,Lm8;
A24:    SW.(i+k).intloc 0 = 1 by A1,A2,Th33;
A25:    SW.(i+k).a > 0
        proof
          assume not thesis;
          then
A26:      K <= i+k by A6;
          i+k < j+k by A9,XREAL_1:6;
          hence contradiction by A18,A26,XXREAL_0:2;
        end;
        then
A27:    I is_closed_on SW.(i+k), PW by A2,Def4;
        then
A28:    I is_closed_on Initialized SW.(i+k), PW by A24,Lm7;
        I is_halting_on SW.(i+k),PW by A2,A25,Def4;
        then
A29:    I is_halting_on Initialized SW.(i+k),PW by A24,A27,Lm8;
        thus DataPart SW.(i+(k+1)) = DataPart SW.(i+k+1)
          .= DataPart IExec(I,PW,SW.(i+k)) by A24,A25,A28,A29,Th32
          .= DataPart IExec(I,PW,SW.(j+k))
           by A14,A15,A17,A16,A20,A22,SCMFSA8C:20,XXREAL_0:2
          .= DataPart SW.(j+k+1) by A16,A19,A21,A23,Th32
          .= DataPart SW.(j+(k+1));
      end;
      consider p being Element of NAT such that
A30:  K = j+p and
      1 <= p by A12,FINSEQ_4:84;
      assume DataPart SW.i = DataPart SW.j;
      then
A31:  X[0];
      for k being Element of NAT holds X[k] from NAT_1:sch 1(A31, A13);
      then DataPart SW.(i+p) = DataPart SW.K by A30;
      then
A32:  SW.(i+p).a <= 0 by A5,SCMFSA_M:2;
      i+p < K by A9,A30,XREAL_1:6;
      hence contradiction by A6,A32;
    end;
  end;
A33: for i, j being Element of NAT st i < j & i <= K & j <= K holds SW.i <>
  SW.j
  proof
    let i, j be Element of NAT;
    assume that
A34: i < j and
    i <= K and
A35: j <= K;
    defpred X[Nat] means i < $1 & $1 <= j implies f.(SW.$1) < f.(SW
    .i);
A36: i < K by A34,A35,XXREAL_0:2;
A37: for k being Element of NAT st X[k] holds X[k+1]
    proof
      let k be Element of NAT such that
A38:  i < k & k <= j implies f.(SW.k) < f.(SW.i) and
A39:  i < k+1 and
A40:  k+1 <= j;
A41:  i <= k by A39,NAT_1:13;
      per cases by A41,XXREAL_0:1;
      suppose
A42:    i = k;
        not SW.i.a <= 0 by A6,A36;
        hence thesis by A7,A42;
      end;
      suppose
A43:    i < k;
A44:    k < j by A40,NAT_1:13;
        now
          assume SW.k.a <= 0;
          then K <= k by A6;
          hence contradiction by A35,A44,XXREAL_0:2;
        end;
        then f.(SW.(k+1)) < f.(SW.k) by A7;
        hence thesis by A38,A40,A43,NAT_1:13,XXREAL_0:2;
      end;
    end;
    assume
A45: SW.i = SW.j;
A46: X[0];
    for k being Element of NAT holds X[k] from NAT_1:sch 1(A46, A37 );
    hence contradiction by A34,A45;
  end;
  given i, j being Element of NAT such that
A47: i <> j and
A48: i <= ExitsAtWhile>0(a,I,p,s) & j <= ExitsAtWhile>0(a,I,p,s) &( SW.i
  = SW. j or DataPart SW.i = DataPart SW.j);
  i < j or j < i by A47,XXREAL_0:1;
  hence contradiction by A4,A33,A8,A48;
end;

definition
 canceled;
end;

theorem Th40:
  s.intloc 0 = 1 & ProperBodyWhile>0 a,Ig,s,p &
   WithVariantWhile>0 a, Ig, s, p
    implies ex f being Function of product the_Values_of SCM+FSA, NAT
st f is on_data_only & for k being Element of NAT
 holds f.(StepWhile>0(a,Ig,p,s).(k+1)) < f.(StepWhile>0(a,Ig,p,s).k) or
 StepWhile>0(a,Ig,p,s).k.a <= 0
proof
  set I = Ig;
  assume that
A1: s.intloc 0 = 1 and
A2: ProperBodyWhile>0 a,I,s,p and
A3: WithVariantWhile>0 a,I,s,p;
  set SW = StepWhile>0(a,I,p,s),
      PW = p +* while>0(a,I);
  consider K being Element of NAT such that
A4: ExitsAtWhile>0(a,I,p,s) = K and
A5: SW.K.a <= 0 and
  for i being Element of NAT st SW.i.a <= 0 holds K <= i and
  DataPart Comput(p +* while>0(a,I),(Initialize s),
  (LifeSpan(p +* while>0(a,I),Initialize s)))
   = DataPart StepWhile>0(a,I,p,s).K by A2,A3,Def6;
  consider g being Function of product the_Values_of SCM+FSA, NAT such
  that
A6: for k being Element of NAT holds g.(SW.(k+1)) < g.(SW.k) or SW.k.a
  <= 0 by A3,Def5;
  defpred P[State of SCM+FSA, set] means (ex k being Element of NAT st k <= K
  & DataPart $1 = DataPart SW.k & $2 = g.(SW.k)) or not (ex k being Element of
  NAT st k <= K & DataPart $1 = DataPart SW.k) & $2 = 0;
A7: for x being Element of product the_Values_of SCM+FSA
 ex y being Element of NAT st P[x,y]
  proof
    let x be  Element of product the_Values_of SCM+FSA;
    per cases;
    suppose
      ex k being Element of NAT st k <= K & DataPart x = DataPart SW.k;
      then consider k being Element of NAT such that
A8:   k <= K & DataPart x = DataPart SW.k;
      take g.(SW.k);
      thus thesis by A8;
    end;
    suppose
A9:   not ex k being Element of NAT st k <= K & DataPart x = DataPart
      SW.k;
      take 0;
      thus thesis by A9;
    end;
  end;
  consider f being Function of product the_Values_of SCM+FSA, NAT such
  that
A10: for x being Element of product the_Values_of SCM+FSA
 holds P[x,f.x]
 from FUNCT_2:sch 3(A7);
  take f;
  hereby
    let s1, s2 such that
A11: DataPart s1 = DataPart s2;
     reconsider ss1=s1, ss2=s2 as
      Element of product the_Values_of SCM+FSA by CARD_3:107;
    ( P[ss1, f.ss1])& P[ss2, f.ss2] by A10;
    hence f.s1 = f.s2 by A1,A2,A3,A4,A11,Th39;
  end;
  let k be Element of NAT;
  per cases;
  suppose
A12: k < K;
    then
A13: k+1 <= K by NAT_1:13;
    then consider kk1 being Element of NAT such that
A14: kk1 <= K & DataPart SW.(k+1) = DataPart SW.kk1 and
A15: f.(SW.(k+1))=g.(SW.kk1) by A10;
A16: k+1 = kk1 by A1,A2,A3,A4,A13,A14,Th39;
    consider kk being Element of NAT such that
A17: kk <= K & DataPart SW.k = DataPart SW.kk and
A18: f.(SW.k) = g.(SW.kk) by A10,A12;
    k = kk by A1,A2,A3,A4,A12,A17,Th39;
    hence thesis by A6,A18,A15,A16;
  end;
  suppose
    K <= k;
    then DataPart SW.K = DataPart SW.k by A5,Th37;
    hence thesis by A5,SCMFSA_M:2;
  end;
end;

theorem
  s1.intloc 0 = 1 & DataPart s1 = DataPart s2 &
   ProperBodyWhile>0 a,Ig,s1,p1 & WithVariantWhile>0 a,Ig,s1,p1
    implies WithVariantWhile>0 a,Ig,s2,p2
proof
  set I = Ig;
  assume that
A1: s1.intloc 0 = 1 and
A2: DataPart s1 = DataPart s2 and
A3: ProperBodyWhile>0 a,I,s1,p1 and
A4: WithVariantWhile>0 a,I,s1,p1;
  set SW1 = StepWhile>0(a,I,p1,s1);
  consider f being Function of product the_Values_of SCM+FSA, NAT such
  that
A5: f is on_data_only and
A6: for k being Element of NAT holds (f.(SW1.(k+1)) < f.(SW1.k) or SW1.k
  .a <= 0 ) by A1,A3,A4,Th40;
  take f;
  let k be Element of NAT;
  set SW2 = StepWhile>0(a,I,p2,s2);
  DataPart SW1.(k+1) = DataPart SW2.(k+1) by A2,A3,Th34;
  then
A7: f.(SW1.(k+1)) = f.(SW2.(k+1)) by A5,MEMSTR_0:def 18;
A8: DataPart SW1.k = DataPart SW2.k by A2,A3,Th34;
  then
A9: SW1.k.a = SW2.k.a by SCMFSA_M:2;
  f.(SW1.k) = f.(SW2.k) by A5,A8,MEMSTR_0:def 18;
  hence thesis by A6,A9,A7;
end;

begin :: fusc using while>0, bottom-up

definition
  let N, result be Int-Location;
  func Fusc_macro ( N, result ) -> Program of SCM+FSA equals
  SubFrom(result,
  result) ";" ((1-stRWNotIn {N, result}) := intloc 0) ";" ((2-ndRWNotIn {N,
result}) := N) ";" while>0 ( 2-ndRWNotIn {N, result}, (3-rdRWNotIn {N, result})
:= 2 ";" Divide(2-ndRWNotIn {N, result}, 3-rdRWNotIn {N, result}) ";" if=0 ( 3
  -rdRWNotIn {N, result}, Macro AddTo(1-stRWNotIn {N, result}, result), Macro
  AddTo(result, 1-stRWNotIn {N, result}) ) );
  correctness;
end;
:: set next = 1-stRWNotIn {N, result};
:: set aux  = 2-ndRWNotIn {N, result};
:: set rem2 = 3-rdRWNotIn {N, result};
:: while and if do not allocate memory, no need to save anything

theorem
  for N, result being read-write Int-Location st N <> result for n being
Element of NAT st n = s.N
 holds IExec(Fusc_macro(N,result),p,s).result = Fusc n
  & IExec(Fusc_macro(N,result),p,s).N = n
proof
  let N, result be read-write Int-Location such that
A1: N <> result;
  set i0 = SubFrom(result, result);
  set rem2 = 3-rdRWNotIn {N, result};
  set aux = 2-ndRWNotIn {N, result};
  set next = 1-stRWNotIn {N, result};
  set I3i0 = rem2 := 2;
  set I3i1 = Divide(aux, rem2);
  set I3I2I0 = Macro AddTo(next, result);
  set I3I2I1 = Macro AddTo(result, next);
  set I3I2 = if=0 ( rem2, I3I2I0, I3I2I1 );
  set I = I3i0 ";" I3i1 ";" I3I2;
  let n be Element of NAT such that
A2: n = s.N;
A3: next <> rem2 by SCMFSA_M:26;
A4: aux <> next by SCMFSA_M:26;
  set I3 = while>0 ( aux, I );
  deffunc U(Element of product the_Values_of SCM+FSA) = abs($1.aux);
  set i2 = aux := N;
  set i1 = next := intloc 0;
  set t = IExec(i0 ";" i1 ";" i2,p,s),
      q = p;
  set It = Initialized t;
  set SWt = StepWhile>0(aux,I,q,It),
      PWt = q +* while>0(aux,I);
  defpred X[Nat] means ex au, ne, re being Element of NAT st SWt.$1
.aux = au & SWt.$1.next = ne & SWt.$1.result = re & SWt.$1.N = n & Fusc n = ne
  * Fusc au + re * Fusc (au+1);
  consider f being Function of product the_Values_of SCM+FSA,NAT such
  that
A5: for x being Element of product the_Values_of SCM+FSA holds f.x
  = U(x) from FUNCT_2:sch 4;
A6: N in {N, result} by TARSKI:def 2;
  then
A7: N <> next by SCMFSA_M:25;
A8: result in {N, result} by TARSKI:def 2;
  then
A9: aux <> result by SCMFSA_M:25;
A10: result <> rem2 by A8,SCMFSA_M:25;
A11: next <> result by A8,SCMFSA_M:25;
A12: N <> rem2 by A6,SCMFSA_M:25;
A13: N <> aux by A6,SCMFSA_M:25;
A14: aux <> rem2 by SCMFSA_M:26;
A15: for u being State of SCM+FSA,h st
 ex au, ne, re being Element of NAT st u
.aux = au & u.next = ne & u.result = re & u.N = n & Fusc n = ne * Fusc au + re
* Fusc (au+1) ex au1, ne1, re1 being Element of NAT
 st IExec(I,h,u).aux = au1 &
IExec(I,h,u).next = ne1 & IExec(I,h,u).result = re1 & IExec(I,h,u).N = n &
Fusc n
  = ne1 * Fusc au1 + re1 * Fusc (au1+1) & au1 = u.aux div 2
  proof
    let u be State of SCM+FSA, h;
    given au, ne, re being Element of NAT such that
A16: u.aux = au and
A17: u.next = ne and
A18: u.result = re and
A19: u.N = n and
A20: Fusc n = ne * Fusc au + re * Fusc (au+1);
A21: (Initialized IExec(I3i0 ";" I3i1,h,u)).next = IExec(I3i0 ";" I3i1,h,u).
    next by SCMFSA_M:37
      .= Exec(I3i1, IExec(I3i0,h,u)).next by SCMFSA6C:6
      .= IExec(I3i0,h,u).next by A4,A3,SCMFSA_2:67
      .= ne by A17,SCMFSA7B:3,SCMFSA_M:26;
A22: (Initialized IExec(I3i0 ";" I3i1,h,u)).aux = IExec(I3i0 ";" I3i1,h,u).
    aux by SCMFSA_M:37
      .= Exec(I3i1, IExec(I3i0,h,u)).aux by SCMFSA6C:6
      .= IExec(I3i0,h,u).aux div IExec(I3i0,h,u).rem2 by A14,SCMFSA_2:67
      .= u.aux div IExec(I3i0,h,u).rem2 by SCMFSA7B:3,SCMFSA_M:26
      .= u.aux div 2 by SCMFSA7B:3;
A23: (Initialized IExec(I3i0 ";" I3i1,h,u)).result = IExec(I3i0 ";" I3i1,h,u)
    .result by SCMFSA_M:37
      .= Exec(I3i1, IExec(I3i0,h,u)).result by SCMFSA6C:6
      .= IExec(I3i0,h,u).result by A9,A10,SCMFSA_2:67
      .= re by A10,A18,SCMFSA7B:3;
A24: (Initialized IExec(I3i0 ";" I3i1,h,u)).N = IExec(I3i0 ";" I3i1,h,u).N by
SCMFSA_M:37
      .= Exec(I3i1, IExec(I3i0,h,u)).N by SCMFSA6C:6
      .= IExec(I3i0,h,u).N by A12,A13,SCMFSA_2:67
      .= n by A12,A19,SCMFSA7B:3;
A25: IExec(I3i0 ";" I3i1,h,u).rem2 = Exec(I3i1, IExec(I3i0,h,u)).rem2 by
SCMFSA6C:6
      .= IExec(I3i0,h,u).aux mod IExec(I3i0,h,u).rem2 by SCMFSA_2:67
      .= u.aux mod IExec(I3i0,h,u).rem2 by SCMFSA7B:3,SCMFSA_M:26
      .= u.aux mod 2 by SCMFSA7B:3;
    per cases;
    suppose
A26:  au is even;
      reconsider ne1 = ne + re as Element of NAT;
      reconsider au1 = u.aux div 2 as Element of NAT by A16,INT_1:3,55;
      take au1, ne1, re;
      consider k being Element of NAT such that
A27:  au = 2*k by A26,ABIAN:def 2;
A28:  u.aux mod 2 = (2*k + 0) mod 2 by A16,A27
        .= 0 mod 2 by NAT_D:21
        .= 0 by NAT_D:26;
      IExec(I,h,u).aux = IExec(I3I2,h,IExec(I3i0 ";" I3i1,h,u)).aux
       by SCMFSA6C:1
        .= IExec(I3I2I0,h,IExec(I3i0 ";" I3i1,h,u)).aux by A25,A28,SCMFSA8B:18
        .= (IExec(I3I2I0,h,IExec(I3i0 ";" I3i1,h,u))).aux
        .= (Exec(AddTo(next, result),
                   Initialized IExec(I3i0 ";" I3i1,h,u))).aux
      by SCMFSA6C:5
        .= Exec(AddTo(next, result), Initialized IExec(I3i0 ";" I3i1,h,u)).aux
        .= u.aux div 2 by A4,A22,SCMFSA_2:64;
      hence IExec(I,h,u).aux = au1;
      thus IExec(I,h,u).next = IExec(I3I2,h,IExec(I3i0 ";" I3i1,h,u)).next by
SCMFSA6C:1
        .= IExec(I3I2I0,h,IExec(I3i0 ";" I3i1,h,u)).next by A25,A28,SCMFSA8B:18
        .= (IExec(I3I2I0,h,IExec(I3i0 ";" I3i1,h,u))).next
        .= (Exec(AddTo(next, result),
         Initialized IExec(I3i0 ";" I3i1,h,u))).next by SCMFSA6C:5
        .= Exec(AddTo(next, result), Initialized IExec(I3i0 ";" I3i1,h,u)).
      next
        .= ne1 by A21,A23,SCMFSA_2:64;
      thus IExec(I,h,u).result = IExec(I3I2,h,IExec(I3i0 ";" I3i1,h,u)).result
       by SCMFSA6C:1
        .= IExec(I3I2I0,h,IExec(I3i0 ";" I3i1,h,u)).result
         by A25,A28,SCMFSA8B:18
        .= (IExec(I3I2I0,h,IExec(I3i0 ";" I3i1,h,u))).result
        .= (Exec(AddTo(next, result),
             Initialized IExec(I3i0 ";" I3i1,h,u))).result by SCMFSA6C:5
        .= Exec(AddTo(next, result), Initialized IExec(I3i0 ";" I3i1,h,u)).
      result
        .= re by A11,A23,SCMFSA_2:64;
      thus IExec(I,h,u).N = IExec(I3I2,h,IExec(I3i0 ";" I3i1,h,u)).N
       by SCMFSA6C:1
        .= IExec(I3I2I0,h,IExec(I3i0 ";" I3i1,h,u)).N by A25,A28,SCMFSA8B:18
        .= (IExec(I3I2I0,h,IExec(I3i0 ";" I3i1,h,u))).N
        .= (Exec(AddTo(next, result),
        Initialized IExec(I3i0 ";" I3i1,h,u))).N
      by SCMFSA6C:5
        .= Exec(AddTo(next, result), Initialized IExec(I3i0 ";" I3i1,h,u)).N
        .= n by A7,A24,SCMFSA_2:64;
      au1 = k by A16,A27,NAT_D:20;
      hence Fusc n = ne1 * Fusc au1 + re * Fusc (au1+1) by A20,A27,PRE_FF:20;
      thus thesis;
    end;
    suppose
A29:  au is odd;
      reconsider re1 = ne + re as Element of NAT;
      reconsider au1 = u.aux div 2 as Element of NAT by A16,INT_1:3,55;
      take au1, ne, re1;
      consider k being Element of NAT such that
A30:  au = 2*k +1 by A29,ABIAN:9;
A31:  u.aux mod 2 = 1 mod 2 by A16,A30,NAT_D:21
        .= 1 by NAT_D:24;
      IExec(I,h,u).aux = IExec(I3I2,h,IExec(I3i0 ";" I3i1,h,u)).aux
       by SCMFSA6C:1
        .= IExec(I3I2I1,h,IExec(I3i0 ";" I3i1,h,u)).aux by A25,A31,SCMFSA8B:18
        .= (IExec(I3I2I1,h,IExec(I3i0 ";" I3i1,h,u))).aux
        .= (Exec(AddTo(result, next),
         Initialized IExec(I3i0 ";" I3i1,h,u))).aux
      by SCMFSA6C:5
        .= Exec(AddTo(result, next), Initialized IExec(I3i0 ";" I3i1,h,u)).aux
        .= u.aux div 2 by A9,A22,SCMFSA_2:64;
      hence IExec(I,h,u).aux = au1;
      thus IExec(I,h,u).next = IExec(I3I2,h,IExec(I3i0 ";" I3i1,h,u)).next by
SCMFSA6C:1
        .= IExec(I3I2I1,h,IExec(I3i0 ";" I3i1,h,u)).next by A25,A31,SCMFSA8B:18
        .= (IExec(I3I2I1,h,IExec(I3i0 ";" I3i1,h,u))).next
        .= (Exec(AddTo(result, next),
        Initialized IExec(I3i0 ";" I3i1,h,u))).
      next by SCMFSA6C:5
        .= Exec(AddTo(result, next), Initialized IExec(I3i0 ";" I3i1,h,u)).
      next
        .= ne by A11,A21,SCMFSA_2:64;
      thus IExec(I,h,u).result
       = IExec(I3I2,h,IExec(I3i0 ";" I3i1,h,u)).result by SCMFSA6C:1
        .= IExec(I3I2I1,h,IExec(I3i0 ";" I3i1,h,u)).result
         by A25,A31,SCMFSA8B:18
        .= (IExec(I3I2I1,h,IExec(I3i0 ";" I3i1,h,u))).result
        .= (Exec(AddTo(result, next),
        Initialized IExec(I3i0 ";" I3i1,h,u))).
      result by SCMFSA6C:5
        .= Exec(AddTo(result, next), Initialized IExec(I3i0 ";" I3i1,h,u)).
      result
        .= re1 by A21,A23,SCMFSA_2:64;
      thus IExec(I,h,u).N = IExec(I3I2,h,IExec(I3i0 ";" I3i1,h,u)).N
       by SCMFSA6C:1
        .= IExec(I3I2I1,h,IExec(I3i0 ";" I3i1,h,u)).N by A25,A31,SCMFSA8B:18
        .= (IExec(I3I2I1,h,IExec(I3i0 ";" I3i1,h,u))).N
        .= (Exec(AddTo(result, next),
        Initialized IExec(I3i0 ";" I3i1,h,u))).N
      by SCMFSA6C:5
        .= Exec(AddTo(result, next), Initialized IExec(I3i0 ";" I3i1,h,u)).N
        .= n by A1,A24,SCMFSA_2:64;
      au1 = 2*k div 2 by A16,A30,NAT_2:26
        .= k by NAT_D:20;
      hence Fusc n = ne * Fusc au1 + re1 * Fusc (au1+1) by A20,A30,PRE_FF:19;
      thus thesis;
    end;
  end;
A32: It.intloc 0 = 1 by SCMFSA_M:9;
A33: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT;
    given au, ne, re being Element of NAT such that
A34: SWt.k.aux = au and
A35: SWt.k.next = ne and
A36: SWt.k.result = re and
A37: SWt.k.N = n and
A38: Fusc n = ne * Fusc au + re * Fusc (au+1);
A39: SWt.k.intloc 0 = 1 by A32,Th33;
    per cases;
    suppose
A40:  SWt.k.aux > 0;
      consider au1, ne1, re1 being Element of NAT such that
A41:  IExec(I,PWt,SWt.k).aux = au1 and
A42:  IExec(I,PWt,SWt.k).next = ne1 and
A43:  IExec(I,PWt,SWt.k).result = re1 and
A44:  IExec(I,PWt,SWt.k).N = n and
A45:  Fusc n = ne1 * Fusc au1 + re1 * Fusc (au1+1) and
      au1 = SWt.k.aux div 2 by A15,A34,A35,A36,A37,A38;
      take au1, ne1, re1;
A46:  DataPart SWt.(k+1) = DataPart IExec(I,PWt,SWt.k) by A39,A40,Th32;
      hence SWt.(k+1).aux = au1 by A41,SCMFSA_M:2;
      thus SWt.(k+1).next = ne1 by A46,A42,SCMFSA_M:2;
      thus SWt.(k+1).result = re1 by A46,A43,SCMFSA_M:2;
      thus SWt.(k+1).N = n by A46,A44,SCMFSA_M:2;
      thus thesis by A45;
    end;
    suppose
A47:  SWt.k.aux <= 0;
      take au, ne, re;
A48:  DataPart SWt.(k+1) = DataPart SWt.k by A47,Th31;
      hence SWt.(k+1).aux = au by A34,SCMFSA_M:2;
      thus SWt.(k+1).next = ne by A35,A48,SCMFSA_M:2;
      thus SWt.(k+1).result = re by A36,A48,SCMFSA_M:2;
      thus SWt.(k+1).N = n by A37,A48,SCMFSA_M:2;
      thus thesis by A38;
    end;
  end;
  t.intloc 0 = 1 by SCMFSA6B:11;
  then
A49: DataPart t = DataPart It by SCMFSA_M:19;
A50: X[0]
  proof
    take au = n;
    take ne = 1;
    take re = 0;
A51: SWt.0 = It by SCMFSA_9:def 5;
    hence SWt.0.aux = t.aux by A49,SCMFSA_M:2
      .= Exec(i2, IExec(i0 ";" i1,p,s)).aux by SCMFSA6C:6
      .= IExec(i0 ";" i1,p,s).N by SCMFSA_2:63
      .= Exec(i1, Exec(i0, Initialized s)).N by SCMFSA6C:8
      .= Exec(i0, Initialized s).N by A7,SCMFSA_2:63
      .= (Initialized s).N by A1,SCMFSA_2:65
      .= au by A2,SCMFSA_M:37;
    thus SWt.0.next = t.next by A49,A51,SCMFSA_M:2
      .= Exec(i2, IExec(i0 ";" i1,p,s)).next by SCMFSA6C:6
      .= IExec(i0 ";" i1,p,s).next by A4,SCMFSA_2:63
      .= Exec(i1, Exec(i0, Initialized s)).next by SCMFSA6C:8
      .= Exec(i0, Initialized s).intloc 0 by SCMFSA_2:63
      .= (Initialized s).intloc 0 by SCMFSA_2:65
      .= ne by SCMFSA_M:9;
    thus SWt.0.result = t.result by A49,A51,SCMFSA_M:2
      .= Exec(i2, IExec(i0 ";" i1,p,s)).result by SCMFSA6C:6
      .= IExec(i0 ";" i1,p,s).result by A9,SCMFSA_2:63
      .= Exec(i1, Exec(i0, Initialized s)).result by SCMFSA6C:8
      .= Exec(i0, Initialized s).result by A11,SCMFSA_2:63
      .= (Initialized s).result - (Initialized s).result by SCMFSA_2:65
      .= re;
    thus SWt.0.N = t.N by A49,A51,SCMFSA_M:2
      .= Exec(i2, IExec(i0 ";" i1,p,s)).N by SCMFSA6C:6
      .= IExec(i0 ";" i1,p,s).N by A13,SCMFSA_2:63
      .= Exec(i1, Exec(i0, Initialized s)).N by SCMFSA6C:8
      .= Exec(i0, Initialized s).N by A7,SCMFSA_2:63
      .= (Initialized s).N by A1,SCMFSA_2:65
      .= n by A2,SCMFSA_M:37;
    thus thesis;
  end;
A52: for k being Element of NAT holds X[k] from NAT_1:sch 1(A50, A33);
  for k being Element of NAT holds f.(SWt.(k+1)) < f.(SWt.k) or SWt.k.aux
  <= 0
  proof
    let k be Element of NAT;
    consider au, ne, re being Element of NAT such that
A53: SWt.k.aux = au and
A54: SWt.k.next = ne & SWt.k.result = re & SWt.k.N = n & Fusc n = ne *
    Fusc au + re * Fusc (au+1) by A52;
A55: f.(SWt.k) = abs(SWt.k.aux) by A5
      .= au by A53,ABSVALUE:def 1;
    now
      consider au1, ne1, re1 being Element of NAT such that
A56:  IExec(I,PWt,SWt.k).aux = au1 and
      IExec(I,PWt,SWt.k).next = ne1 and
      IExec(I,PWt,SWt.k).result = re1 and
      IExec(I,PWt,SWt.k).N = n and
      Fusc n = ne1 * Fusc au1 + re1 * Fusc (au1+1) and
A57:  au1 = SWt.k.aux div 2 by A15,A53,A54;
      assume
A58:  au > 0;
      SWt.k.intloc 0 = 1 by A32,Th33;
      then DataPart SWt.(k+1) = DataPart IExec(I,PWt,SWt.k) by A53,A58,Th32;
      then
A59:  SWt.(k+1).aux = au1 by A56,SCMFSA_M:2;
      f.(SWt.(k+1)) = abs(SWt.(k+1).aux) by A5
        .= au1 by A59,ABSVALUE:def 1;
      hence f.(SWt.(k+1)) < f.(SWt.k) by A53,A55,A58,A57,INT_1:56;
    end;
    hence thesis by A53;
  end;
  then
A60: WithVariantWhile>0 aux,I,It,q by Def5;
  then consider k being Element of NAT such that
A61: ExitsAtWhile>0(aux,I,q,It) = k and
A62: (StepWhile>0(aux,I,q,It).k).aux <= 0 and
  for i being Element of NAT st SWt.i.aux <= 0 holds k <= i and
  DataPart (Comput(q +* while>0(aux,I),(Initialize It),
   (LifeSpan(q +* while>0(aux,I),Initialize It))))
    = DataPart StepWhile>0(aux,I,q,It).k
  by Def6;
A63: DataPart IExec(I3,q,t) = DataPart SWt.k by A60,A61,Th36;
  consider au, ne, re being Element of NAT such that
A64: SWt.k.aux = au and
  SWt.k.next = ne and
A65: SWt.k.result = re and
A66: SWt.k.N = n and
A67: Fusc n = ne * Fusc au + re * Fusc (au+1) by A52;
A68: au = 0 by A62,A64;
  I3 is_closed_on It,q & I3 is_halting_on It,q by A60,Th28;
  then
A69: I3 is_closed_on t,q & I3 is_halting_on t,q by A49,SCMFSA8B:5;
  hence IExec(Fusc_macro(N,result),p,s).result = IExec(I3,q,t).result by
SFMASTR1:7
    .= Fusc n by A65,A67,A68,A63,PRE_FF:15,SCMFSA_M:2;
  thus IExec(Fusc_macro(N,result),p,s).N = IExec(I3,q,t).N by A69,SFMASTR1:7
    .= n by A66,A63,SCMFSA_M:2;
end;

