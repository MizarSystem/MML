:: The { \bf while } macro instructions of SCM+FSA, Part { II }
::  by Piotr Rudnicki
::
:: Received June 3, 1998
:: Copyright (c) 1998-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, INT_1, AMI_1, SCMFSA_2, SF_MASTR, FUNCOP_1,
      FUNCT_1, FINSUB_1, CARD_3, RELAT_1, TARSKI, AMISTD_2, XBOOLE_0, CARD_1,
      SCMFSA8A, AMI_3, FSM_1, SCMFSA7B, SCMFSA8B, ARYTM_3, TURING_1, SCMFSA6A,
      ARYTM_1, VALUED_1, FUNCT_4, SCMFSA_9, UNIALG_2, SCMFSA6B, XXREAL_0,
      CIRCUIT2, GRAPHSP, NAT_1, SCMFSA6C, MSUALG_1, SFMASTR1, PRE_FF, COMPLEX1,
      ABIAN, SCMFSA9A, ORDINAL1, PARTFUN1, SCMNORM, RELOC, PBOOLE;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, FINSUB_1,
      FUNCOP_1, INT_1, ABIAN, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, PRE_FF,
      CARD_3, FUNCT_4, PBOOLE, VALUED_1, INT_2, XXREAL_0, NAT_1, COMPOS_1,
      EXTPRO_1,
      AMISTD_2, SCMFSA_2, SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C,
      SCMFSA_7, SCMFSA7B, SCMFSA8A, SCMFSA8B, SCMFSA_9, SFMASTR1;
 constructors NAT_D, PRE_FF, ABIAN, SCMFSA_7, SCMFSA6A, SCMFSA6B,
      SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA_9, SFMASTR1, AMISTD_2,
      RELSET_1, PRE_POLY, XXREAL_2, PBOOLE, SCMFSA7B, SCMFSA8C;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FINSET_1,
      FINSUB_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, ABIAN,
      SCMFSA_2, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B,
      SCMFSA_9, SFMASTR1, VALUED_1, FUNCT_2, RELAT_1, AFINSQ_1,
      FUNCT_4, FUNCOP_1, SCMFSA10, AMISTD_2, SCMFSA6A, COMPOS_1, EXTPRO_1,
      PBOOLE, STRUCT_0;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, SCMFSA6A, AFINSQ_1, COMPOS_1, EXTPRO_1, AMISTD_2;
 theorems TARSKI, ZFMISC_1, ABSVALUE, NAT_1, INT_1, NAT_2, FUNCT_1, FUNCT_2,
      GRFUNC_1, FUNCOP_1, FUNCT_4, PRE_FF, ABIAN, SCMFSA_2,
      SCMFSA_4, SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SCMFSA8B, SCMFSA8C, SCMFSA_9, SFMASTR1, RELAT_1, XBOOLE_0,
      XBOOLE_1, CARD_3, XREAL_1, XXREAL_0, ORDINAL1, NAT_D, VALUED_1, PBOOLE,
      PARTFUN1, FINSEQ_4, COMPOS_1, EXTPRO_1;
 schemes FUNCT_2, NAT_1;

begin :: SCM+FSA preliminaries

reserve p,p1,p2,h
 for (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;

reserve k, l, n for Element of NAT,
  j for Integer,
  i for Instruction of SCM+FSA;

canceled 6;

theorem Th7: :: singleUsed
  UsedIntLoc (l .--> i) = UsedIntLoc i
proof
  set p = (l .--> i);
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc p = Union (UIL * p) by SF_MASTR:def 2;
A3: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
  thus UsedIntLoc p = union rng (UIL * ({l} --> i)) by A2,CARD_3:def 4
    .= union rng ({l} --> UIL.i) by A3,FUNCOP_1:23
    .= union {UIL.i} by FUNCOP_1:14
    .= union {UsedIntLoc i} by A1
    .= UsedIntLoc i by ZFMISC_1:31;
end;

theorem Th8: :: singleUsedF:
  UsedInt*Loc (l .--> i) = UsedInt*Loc i
proof
  set p = (l .--> i);
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc p = Union (UIL * p) by SF_MASTR:def 4;
A3: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
  thus UsedInt*Loc p = union rng (UIL * ({l} --> i)) by A2,CARD_3:def 4
    .= union rng ({l} --> UIL.i) by A3,FUNCOP_1:23
    .= union {UIL.i} by FUNCOP_1:14
    .= union {UsedInt*Loc i} by A1
    .= UsedInt*Loc i by ZFMISC_1:31;
end;

theorem Th9: :: StopUsed:
  UsedIntLoc Stop SCM+FSA = {} by Th7,SF_MASTR:17;

theorem Th10: :: StopUsedF:
  UsedInt*Loc Stop SCM+FSA = {}
proof
  thus UsedInt*Loc Stop SCM+FSA
    = UsedInt*Loc halt SCM+FSA by Th8
    .= {} by SF_MASTR:36;
end;

theorem Th11: :: GotoUsed:
  UsedIntLoc Goto l = {}
proof
  Goto l =  0 .--> goto l by SCMFSA8A:def 2;
  hence UsedIntLoc Goto l = UsedIntLoc goto l by Th7
    .= {} by SF_MASTR:19;
end;

theorem Th12: :: GotoUsedF:
  UsedInt*Loc Goto l = {}
proof
  Goto l =  0 .--> goto l by SCMFSA8A:def 2;
  hence UsedInt*Loc Goto l = UsedInt*Loc goto l by Th8
    .= {} by SF_MASTR:36;
end;

reserve s, s1, s2 for State of SCM+FSA,
  a for read-write Int-Location,
  b for Int-Location,
  I, J for Program of SCM+FSA,
  Ig for good Program of SCM+FSA,
  i, j, k, m, n for Element of NAT;

set D = Int-Locations \/ FinSeq-Locations;
set SAt = Start-At(0,SCM+FSA);

theorem Th13:
  UsedIntLoc if=0(b, I, J) = {b} \/ UsedIntLoc I \/ UsedIntLoc J
proof
  set I5 = Stop SCM+FSA;
  set a = b;
  set I1 = a =0_goto  (card J + 3);
  set I3 = Goto  (card I + 1);
  thus UsedIntLoc if=0(a, I, J) = UsedIntLoc (I1 ';' J ';' I3 ';' I ';' I5) by
SCMFSA8B:def 1
    .= (UsedIntLoc (I1 ';' J ';' I3 ';' I)) \/ {} by Th9,SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J ';' I3)) \/ UsedIntLoc I by SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J)) \/ UsedIntLoc I3 \/ UsedIntLoc I by SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J)) \/ {} \/ UsedIntLoc I by Th11
    .= UsedIntLoc I1 \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:33
    .= {a} \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:20
    .= {a} \/ UsedIntLoc I \/ UsedIntLoc J by XBOOLE_1:4;
end;

theorem Th14: :: eifUsedF:
  for a being Int-Location holds UsedInt*Loc if=0(a, I, J) =
  UsedInt*Loc I \/ UsedInt*Loc J
proof
  set I5 = Stop SCM+FSA;
  let a be Int-Location;
  set I1 = a =0_goto  (card J + 3);
  set I3 = Goto  (card I + 1);
  thus UsedInt*Loc if=0(a, I, J) = UsedInt*Loc (I1 ';' J ';' I3 ';' I ';' I5)
  by SCMFSA8B:def 1
    .= (UsedInt*Loc (I1 ';' J ';' I3 ';' I)) \/ {} by Th10,SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J ';' I3)) \/ UsedInt*Loc I by SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J)) \/ UsedInt*Loc I3 \/ UsedInt*Loc I by
SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J)) \/ {} \/ UsedInt*Loc I by Th12
    .= UsedInt*Loc I1 \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:49
    .= {} \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:36
    .= UsedInt*Loc I \/ UsedInt*Loc J;
end;

theorem Th15: :: ifUsed:
  UsedIntLoc if>0(b, I, J) = {b} \/ UsedIntLoc I \/ UsedIntLoc J
proof
  set I5 = Stop SCM+FSA;
  set a = b;
  set I1 = a >0_goto  (card J + 3);
  set I3 = Goto  (card I + 1);
  thus UsedIntLoc if>0(a, I, J) = UsedIntLoc (I1 ';' J ';' I3 ';' I ';' I5) by
SCMFSA8B:def 2
    .= (UsedIntLoc (I1 ';' J ';' I3 ';' I)) \/ {} by Th9,SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J ';' I3)) \/ UsedIntLoc I by SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J)) \/ UsedIntLoc I3 \/ UsedIntLoc I by SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J)) \/ {} \/ UsedIntLoc I by Th11
    .= UsedIntLoc I1 \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:33
    .= {a} \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:20
    .= {a} \/ UsedIntLoc I \/ UsedIntLoc J by XBOOLE_1:4;
end;

theorem Th16: :: ifUsedF:
  UsedInt*Loc if>0(b, I, J) = UsedInt*Loc I \/ UsedInt*Loc J
proof
  set I5 = Stop SCM+FSA;
  set a = b;
  set I1 = a >0_goto  (card J + 3);
  set I3 = Goto  (card I + 1);
  thus UsedInt*Loc if>0(a, I, J) = UsedInt*Loc (I1 ';' J ';' I3 ';' I ';' I5)
  by SCMFSA8B:def 2
    .= (UsedInt*Loc (I1 ';' J ';' I3 ';' I)) \/ {} by Th10,SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J ';' I3)) \/ UsedInt*Loc I by SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J)) \/ UsedInt*Loc I3 \/ UsedInt*Loc I by
SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J)) \/ {} \/ UsedInt*Loc I by Th12
    .= UsedInt*Loc I1 \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:49
    .= {} \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:36
    .= UsedInt*Loc I \/ UsedInt*Loc J;
end;

begin :: while=0, general

Lm1: for a being Int-Location, I being Program of SCM+FSA holds card I +4 in
dom if=0(a,I ';' Goto  0,Stop SCM+FSA) & if=0(a,I ';' Goto  0,Stop
SCM+FSA).(card I +4) = goto (( 0)+(card I +4))

proof
  set J = Stop SCM+FSA;
  set G = Goto  0;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' G;
  set i = a =0_goto  (card J + 3);
  set c4 = card I + 4;
  set Lc4 = c4;
  set Mi= Macro i ';' J ';' Goto  (card I1 + 1) ';' I;
A1: card Stop SCM+FSA = 1 by COMPOS_1:46;
A2: card (G ';' J) = card G + card J by SCMFSA6A:61
    .= 1 + 1 by A1,SCMFSA8A:29
    .= 2;

A3: if=0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' (I ';' G) ';'
  J by SCMFSA8B:def 1

    .= Mi ';' G ';' J by SCMFSA6A:67
    .= Mi ';' (G ';' J) by SCMFSA6A:67;
  then card if=0(a, I1,J) = card Mi + card (G ';' J) by SCMFSA6A:61;
  then
A4: card Mi = card if=0(a,I1,J)-card (G ';' J)
    .= card I + 6 - 2 by A2,SCMFSA_9:1
    .= c4;
  then
A5: not Lc4 in dom Mi;
  set GJ = G ';' J;
A7: G =  0 .--> goto  0 by SCMFSA8A:def 2;
  then
A8: G. 0 = goto  0 by FUNCOP_1:87;
  dom G = { 0} by A7,FUNCOP_1:19;
  then
A9:  0 in dom G by TARSKI:def 1;
A10: dom G c= dom GJ by SCMFSA6A:56;

  then  0 + c4 in { il+c4 where il is Element of NAT: il in dom GJ} by A9
;

  then
A11:  c4 in dom Shift(GJ,c4) by VALUED_1:def 12;
  then
A12: Shift(GJ,c4)/.Lc4 = Shift(GJ,c4).( 0 +c4) by PARTFUN1:def 8
    .= GJ. 0 by A9,A10,VALUED_1:def 12
    .= goto  0 by A9,A8,SCMFSA6A:54;
A13: card Stop SCM+FSA = 1 by COMPOS_1:46;
  card I1 = card I + card G by SCMFSA6A:61
    .= card I +1 by SCMFSA8A:29;
  then card I1 + card J + 3 = card I +4 +1 by A13;
  then c4 < card I1 + card J + 3 by NAT_1:13;
  hence
A14: Lc4 in dom if=0(a,I1,J) by SCMFSA8C:56;

A15: dom if=0(a,I1,J) = dom Directed Mi \/ dom Reloc(GJ, c4
  ) by A3,A4,FUNCT_4:def 1;

  then dom if=0(a,I1,J) = dom Mi \/ dom Reloc(GJ, c4) by FUNCT_4:105;

  then Lc4 in dom Reloc(GJ, c4) by A14,A5,XBOOLE_0:def 3;

  hence if=0(a,I1,J).Lc4 = (Reloc(GJ,c4)).Lc4 by A14,A3,A4,A15,FUNCT_4:def 1
    .= IncAddr( goto  0, c4 ) by A11,A12,COMPOS_1:def 40
    .= goto (( 0)+c4) by SCMFSA_4:14;
end;

Lm2: for a being Int-Location, I being Program of SCM+FSA holds UsedIntLoc
if=0(a,I ';' Goto  0,Stop SCM+FSA) = UsedIntLoc (if=0(a,I ';' Goto
0,Stop SCM+FSA) +* (  (card I +4) .--> goto  0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 =  (card I + 4);
  set if0 = if=0(a,I ';' Goto  0,Stop SCM+FSA);
  set ic4 =  (card I +4) .--> goto  0;

  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedIntLoc i and
A2: UsedIntLoc if0 = Union (UIL1 * if0) by SF_MASTR:def 2;
A3: dom UIL1 = the Instructions of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,RELAT_1:def 19;
A6: dom ic4 = { (card I +4)} by FUNCOP_1:19;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
     (card I +4) in dom if0 by Lm1;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
FUNCT_4:def 1,ZFMISC_1:37;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,RELAT_1:def 19;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:46
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:46;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:12
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.(goto (( 0)+(card I +4))) by A12,Lm1
        .= UsedIntLoc goto (( 0)+(card I +4)) by A1
        .= {} by SF_MASTR:19
        .= UsedIntLoc goto  0 by SF_MASTR:19
        .= UIL1.(goto  0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:87
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:14
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
  end;

  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A14: UsedIntLoc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 2;
  for c be Element of the Instructions of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedIntLoc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:113;
  hence thesis by A2,A14,A4,FUNCT_1:9;
end;

Lm3: for a being Int-Location, I being Program of SCM+FSA holds UsedInt*Loc
if=0(a,I ';' Goto  0,Stop SCM+FSA) = UsedInt*Loc (if=0(a,I ';' Goto
 0,Stop SCM+FSA) +* (  (card I +4) .--> goto  0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 =  (card I + 4);
  set if0 = if=0(a,I ';' Goto  0,Stop SCM+FSA);
  set ic4 =  (card I +4) .--> goto  0;

  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedInt*Loc i and
A2: UsedInt*Loc if0 = Union (UIL1 * if0) by SF_MASTR:def 4;
A3: dom UIL1 = the Instructions of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,RELAT_1:def 19;
A6: dom ic4 = { (card I +4)} by FUNCOP_1:19;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
     (card I +4) in dom if0 by Lm1;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
FUNCT_4:def 1,ZFMISC_1:37;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,RELAT_1:def 19;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:46
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:46;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:12
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.(goto (( 0)+(card I +4))) by A12,Lm1
        .= UsedInt*Loc goto (( 0)+(card I +4)) by A1
        .= {} by SF_MASTR:36
        .= UsedInt*Loc goto  0 by SF_MASTR:36
        .= UIL1.(goto  0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:87
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:14
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
  end;

  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A14: UsedInt*Loc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 4;
  for c be Element of the Instructions of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedInt*Loc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:113;
  hence thesis by A2,A14,A4,FUNCT_1:9;
end;

theorem :: ewhileUsed:
  UsedIntLoc while=0(b, I) = {b} \/ UsedIntLoc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ';' Goto  0;
  while=0(a, I) = if=0(a, IG, J) +* (  (card I +4) .--> goto
  0 ) by SCMFSA_9:def 1;
  hence UsedIntLoc while=0(a, I) = (UsedIntLoc if=0(a, IG, J)) by Lm2
    .= {a} \/ UsedIntLoc IG \/ UsedIntLoc J by Th13
    .= {a} \/ (UsedIntLoc I \/ UsedIntLoc Goto  0) \/ UsedIntLoc J by
SF_MASTR:31
    .= {a} \/ (UsedIntLoc I \/ {}) \/ UsedIntLoc J by Th11
    .= {a} \/ UsedIntLoc I by Th9;
end;

theorem :: ewhileUsedF:
  UsedInt*Loc while=0(b, I) = UsedInt*Loc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ';' Goto  0;
  while=0(a, I) = if=0(a, IG, J) +* (  (card I +4) .--> goto
  0 ) by SCMFSA_9:def 1;
  hence UsedInt*Loc while=0(a, I) = (UsedInt*Loc if=0(a, IG, J)) by Lm3
    .= UsedInt*Loc IG \/ UsedInt*Loc J by Th14
    .= (UsedInt*Loc I \/ UsedInt*Loc Goto  0) \/ UsedInt*Loc J by SF_MASTR:47
    .= UsedInt*Loc I \/ {} by Th10,Th12
    .= UsedInt*Loc I;
end;

definition let p;
  let s be State of SCM+FSA, a be read-write Int-Location, I be Program of
  SCM+FSA;
  pred ProperBodyWhile=0 a, I, s, p means
  :Def1:
  for k being Element of NAT st StepWhile=0(a,I,p,s).k.a = 0 holds
   I is_closed_on StepWhile=0(a,I,p,s).k, p+*while=0(a,I) &
   I is_halting_on StepWhile=0(a,I,p,s).k, p+*while=0(a,I);
  pred WithVariantWhile=0 a, I, s, p means
  :Def2:
  ex f being Function of product the Object-Kind of SCM+FSA, NAT
   st for k being Element of NAT
    holds f.(StepWhile=0(a,I,p,s).(k+1)) < f.(StepWhile=0(a,I,p,s).k)
      or StepWhile=0(a,I,p,s).k.a <> 0;
end;

theorem Th19: :: eParaProper:
  for I being parahalting Program of SCM+FSA holds
  ProperBodyWhile=0 a,I,s,p
proof
  let I be parahalting Program of SCM+FSA;
  let k be Element of NAT such that
  StepWhile=0(a,I,p,s).k.a = 0;
  thus I is_closed_on StepWhile=0(a,I,p,s).k, p+*while=0(a,I) by SCMFSA7B:24;
  thus thesis by SCMFSA7B:25;
end;

theorem Th20: :: SCMFSA_9:24, corrected
  ProperBodyWhile=0 a,I,s,p & WithVariantWhile=0 a,I,s,p implies
  while=0(a,I) is_halting_on s,p & while=0(a,I) is_closed_on s,p
proof
  assume
A1: for k being Element of NAT st StepWhile=0(a,I,p,s).k.a = 0 holds I
  is_closed_on StepWhile=0(a,I,p,s).k, p+*while=0(a,I) &
  I is_halting_on StepWhile=0(a,I,p,s).k, p+*while=0(a,I);
  set s1 = Initialize s,
      p1 = p +* while=0(a,I);
A3:  p1 +* while=0(a,I) = p1 by FUNCT_4:99;
  defpred S[Element of NAT] means StepWhile=0(a,I,p,s).$1.a <> 0;
  given f being Function of product the Object-Kind of SCM+FSA,NAT such that
A4: for k being Element of NAT holds (f.(StepWhile=0(a,I,p,s).(k+1)) < f.(
  StepWhile=0(a,I,p,s).k) or (StepWhile=0(a,I,p,s).k).a <> 0 );
  deffunc F(Nat) = f.(StepWhile=0(a,I,p,s).$1);
A5: for k holds ( F(k+1) < F(k) or S[k] ) by A4;
  consider m being Element of NAT such that
A6: S[m] and
A7: for n st S[n] holds m <= n from NAT_1:sch 18(A5);
  defpred P[Nat] means $1+1 <= m implies ex k st StepWhile=0(a,I,p,s)
  .($1+1)=Comput(p1,s1,k);
A8: now
    let k be Element of NAT;
    assume
A9: P[k];
    now
      set sk1=StepWhile=0(a,I,p,s).(k+1);
      set sk=StepWhile=0(a,I,p,s).k,
          pk = p +* while=0(a,I);
      assume
A10:   (k+1)+ 1 <= m;
      k + 0 < k+ (1+ 1) by XREAL_1:8;
      then k < m by A10,XXREAL_0:2;
      then
A11:   sk.a = 0 by A7;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
      then consider n being Element of NAT such that
A12:  sk1 = Comput(p1,s1,n) by A9,A10,XXREAL_0:2;
A13:  sk1 = Comput(pk +* while=0(a,I), Initialize sk,
         LifeSpan(pk +* while=0(a,I) +* I,Initialize sk) + 3)
              by A3,SCMFSA_9:def 4;
      take m=n +(LifeSpan(pk +* I,Initialize sk1) + 3);
      I is_closed_on sk,pk & I is_halting_on sk,pk by A1,A11;
      then IC sk1 =  0 by A13,A11,A3,SCMFSA_9:22;
      then StepWhile=0(a,I,p,s).((k+1)+1)=Comput(p1,s1,
     (n +(LifeSpan(p1 +* I,
       Initialize(StepWhile=0(a,I,p,s).(k+1))) + 3)))
              by A12,SCMFSA_9:31;

     hence StepWhile=0(a,I,p,s).((k+1)+1)=Comput(p1,s1,m);
    end;
    hence P[k+1];
  end;
A15: P[0]
  proof
    assume 0+1 <= m;
    take n=(LifeSpan(p1 +* I,Initialize s) + 3);
    thus thesis by SCMFSA_9:30;
  end;
A16: for k being Element of NAT holds P[k] from NAT_1:sch 1(A15,A8);
    per cases;
    suppose
      m = 0;
      then s.a <> 0 by A6,SCMFSA_9:def 4;
      hence thesis by SCMFSA_9:18;
    end;
    suppose
A17:  m <> 0;
      set ii=(LifeSpan(p +* while=0(a,I) +* I,Initialize s) + 3);
      set sm=StepWhile=0(a,I,p,s).m,
          pm = p +* while=0(a,I);
      set sm1=Initialize sm,
          pm1 = pm +* while=0(a,I);
      consider i being Nat such that
A18:  m=i+1 by A17,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      set si=StepWhile=0(a,I,p,s).i,
          psi = p +* while=0(a,I);
A19:  sm= Comput(psi +* while=0(a,I),(Initialize si),
      (LifeSpan(psi +* I,Initialize si) + 3))
      by A18,A3,SCMFSA_9:def 4;
      m=i+1 by A18;
      then consider n being Element of NAT such that
A20:  sm = Comput(p1,s1,n) by A16;
      i < m by A18,NAT_1:13;
      then
A21:  si.a = 0 by A7;
      then I is_closed_on si,psi & I is_halting_on si,psi by A1;
      then
      IC sm =  0 by A19,A21,SCMFSA_9:22;
      then Start-At(0,SCM+FSA) c= sm by COMPOS_1:164;
      then
A24:  sm1=sm by FUNCT_4:104;
      while=0(a,I) is_halting_on sm,pm by A6,SCMFSA_9:18;
      then pm1 halts_on sm1 by SCMFSA7B:def 8;
      then consider j being Element of NAT such that
A25:  CurInstr(pm,Comput(pm,sm,j)) = halt SCM+FSA
by A24,A3,EXTPRO_1:30;
A26: Comput(p1,s1,n+j)
 = Comput(p1,Comput(p1,s1,n),j) by EXTPRO_1:5;
      CurInstr(p1,Comput(p1,s1,n+j))
       = halt SCM+FSA by A20,A25,A26;
      then p1 halts_on s1 by EXTPRO_1:30;
      hence while=0(a,I) is_halting_on s,p by SCMFSA7B:def 8;
      now
        let q be Element of NAT;
        per cases;
        suppose
A27:      q <= ii;
A28:      StepWhile=0(a,I,p,s).0 = s by SCMFSA_9:def 4;
          then
A29:      s.a = 0 by A7,A17;
          then I is_closed_on s,p1 & I is_halting_on s,p1 by A1,A28;
          hence IC Comput(p1,s1,q) in dom while=0(a,I) by A27,A29,A3,
SCMFSA_9:22
;
        end;
        suppose
A30:      q > ii;
A31:      now
            take k=ii;
            thus StepWhile=0(a,I,p,s).1
            =Comput(p1,s1,k) & k <= q by A30,SCMFSA_9:30;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 &
           (ex k st StepWhile=0(a,I,p,s).$1
          = Comput(p1,s1,k) & k <= q);
A32:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A17,XREAL_1:8;
          then 1 <= m by NAT_1:13;
          then
A33:      ex k be Nat st P2[k] by A31;
          consider t be Nat such that
A34:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A32,A33);
          reconsider t as Element of NAT by ORDINAL1:def 13;
          per cases;
          suppose
            t=m;
            then consider r being Element of NAT such that
A35:          sm=Comput(p1,s1,r) and
A36:          r <= q by A34;
            consider x being Nat such that
A37:          q = r+x by A36,NAT_1:10;
A38:          while=0(a,I) is_closed_on sm,pm by A6,SCMFSA_9:18;
            reconsider x as Element of NAT by ORDINAL1:def 13;
            Comput(p1,s1,q) = Comput(p1,sm1,x) by A24,A35,A37,EXTPRO_1:5;
            hence IC Comput(p1,s1,q) in dom while=0(a,I) by A38,A3,
SCMFSA7B:def 7;
          end;
          suppose
A39:          t<>m;
            set Dt=StepWhile=0(a,I,p,s).t,
                pt = p +* while=0(a,I);
            consider y being Nat such that
A40:          t=y+1 by A34,NAT_1:6;
            reconsider y as Element of NAT by ORDINAL1:def 13;
            set Dy=StepWhile=0(a,I,p,s).y,
                py = p +* while=0(a,I);
A41:          Dt= Comput(py +* while=0(a,I),(Initialize Dy),
 (LifeSpan(py +* I,Initialize Dy) + 3)) by A40,A3,SCMFSA_9:def 4;
            y+ 0 < t by A40,XREAL_1:8;
            then y < m by A34,XXREAL_0:2;
            then
A42:          Dy.a = 0 by A7;
            then I is_closed_on Dy,py & I is_halting_on Dy,py by A1;
            then
A43:          IC Dt = 0 by A41,A42,SCMFSA_9:22;
            consider z being Element of NAT such that
A44:          StepWhile=0(a,I,p,s).t=Comput(p1,s1,z) and
A45:          z <= q by A34;
            consider w being Nat such that
A46:          q = z+w by A45,NAT_1:10;
            reconsider w as Element of NAT by ORDINAL1:def 13;
A47: Dt = Initialize Dt by A44,A43,SCMFSA_9:31;
A48:          Comput(p1,s1,q)
              = Comput(pt +* while=0(a,I),Initialize Dt,w)
               by A47,A3,A44,A46,EXTPRO_1:5;
            set z2=z +(LifeSpan(pt +* I,Initialize Dt) + 3);
A49:          t < m by A34,A39,XXREAL_0:1;
            now
              assume
A50:            z2 <= q;
A51:            now
                take k=z2;
                thus StepWhile=0(a,I,p,s).(t+1)
                =Comput(p1,s1,k) &
k <= q by A44,A43,A50,SCMFSA_9:31;
              end;
              t+1 <= m by A49,NAT_1:13;
              hence contradiction by A34,A51,XREAL_1:31;
            end;
            then
A52:          w < LifeSpan(pt +* I,Initialize Dt) + 3
by A46,XREAL_1:8;
A53:          Dt.a = 0 by A7,A49;
            then I is_closed_on Dt,pt & I is_halting_on Dt,pt by A1;
            hence IC Comput(p1,s1,q) in dom while=0(a,I)
             by A52,A48,A53,SCMFSA_9:22;
          end;
        end;
      end;
      hence while=0(a,I) is_closed_on s,p by SCMFSA7B:def 7;
    end;
end;

theorem Th21: :: SCMFSA_9:25, corrected
  for I being parahalting Program of SCM+FSA
   st WithVariantWhile=0 a, I, s, p
    holds while=0(a,I) is_halting_on s,p & while=0(a,I) is_closed_on s,p
proof
  let I be parahalting Program of SCM+FSA such that
A1: WithVariantWhile=0 a,I,s,p;
  ProperBodyWhile=0 a,I,s,p
  proof
    let k be Element of NAT;
    assume StepWhile=0(a,I,p,s).k.a = 0;
    thus thesis by SCMFSA7B:24,25;
  end;
  hence thesis by A1,Th20;
end;

theorem Th22: :: based on SCMFSA_9:10
  Start-At(0,SCM+FSA) c= s &
  while=0(a, I) c= p &
   s.a <> 0 implies
  LifeSpan(p,s) = 4 & for k being Element of NAT
   holds DataPart Comput(p,s,k) = DataPart s
proof
  assume that
A1: Start-At(0,SCM+FSA) c= s and
A2: while=0(a, I) c= p and
A3: s.a <> 0;
A4: p +* while=0(a, I) = p by A2,FUNCT_4:104;
  set i = a =0_goto  4;
  set s1 = Initialize s,
      p1 = p +* while=0(a,I);
A5: while=0(a,I) c= p1 by FUNCT_4:26;
B6: IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
    Start-At(0,SCM+FSA) c= Initialize while=0(a,I) by FUNCT_4:26;
    then
U1: dom Start-At(0,SCM+FSA) c= dom Initialize while=0(a,I)
             by RELAT_1:25;
  not a in dom (Initialize while=0(a,I)) by SCMFSA6B:12;
  then not a in dom Start-At(0,SCM+FSA) by U1;
  then
A7: s1.a = s.a by FUNCT_4:12;
A8:  1 in dom while=0(a,I) by SCMFSA_9:10;
A9: p1. 1 = while=0(a,I). 1 by A8,FUNCT_4:14
    .= goto  2 by SCMFSA_9:11;
A10: IC s1 = IC Start-At(0,SCM+FSA) by B6,FUNCT_4:14
    .=  0 by COMPOS_1:64;
A11:  p1/.IC s1 = p1.IC s1 by PBOOLE:158;
  0 in dom while=0(a,I) by SCMFSA_9:10;
  then p1. 0 = while=0(a,I). 0 by FUNCT_4:14
    .= i by SCMFSA_9:11;
  then
A12: CurInstr(p1,s1) = i by A10,A11;
A13: Comput(p1,s1,0+1) = Following(p1,
Comput(p1,s1,0)) by EXTPRO_1:4
    .= Following(p1,s1) by EXTPRO_1:3
    .= Exec(i,s1) by A12;
  set loc5=  (card I +5);
  set s5 = Comput(p1,s1,4),
      p5 = p1;
  set s4 = Comput(p1,s1,3),
      p4 = p1;
  set s3 = Comput(p1,s1,2),
      p3 = p1;
  set s2 = Comput(p1,s1,1);
A14:  2 in dom while=0(a,I) by SCMFSA_9:12;
A15: p3. 2 = while=0(a,I). 2
    by A14,FUNCT_4:14
    .= goto  3 by SCMFSA_9:16;
A16:  3 in dom while=0(a,I) by SCMFSA_9:12;
A17: p4. 3 = while=0(a,I) . 3 by A16,FUNCT_4:14
    .= goto loc5 by SCMFSA_9:15;
A18: loc5 in dom while=0(a,I) by SCMFSA_9:13;
A19: p5.loc5 = while=0(a,I).loc5 by A18,A5,GRFUNC_1:8
    .= halt SCM+FSA by SCMFSA_9:14;
A20: ( for c being Int-Location holds Exec(goto loc5, s4).c = s4.c)& for f
  being FinSeq-Location holds Exec(goto loc5, s4).f = s4.f by SCMFSA_2:95;
A21: ( for c being Int-Location holds Exec(goto  2, s2).c = s2.c)& for
f being FinSeq-Location holds Exec(goto  2, s2).f = s2.f by SCMFSA_2:95;
A22:  p1/.IC Comput(p1,s1,1) = p1.IC Comput(p1,s1,1) by PBOOLE:158;
  IC Comput(p1,s1,1) = succ  0 by A3,A10,A13,A7,SCMFSA_2:96
    .=  (0 + 1);
  then
A23: CurInstr(p1,Comput(p1,
s1,1)) = goto  2
by A9,A22;
A24: Comput(p1,s1,1+1) = Following(p1,s2) by EXTPRO_1:4
    .= Exec(goto  2,s2) by A23;
A25: p3/.IC s3 = p3.IC s3 by PBOOLE:158;
  IC s3 =  2 by A24,SCMFSA_2:95;
  then
A26: CurInstr(p3,s3) = goto  3 by A15,A25;
A27: Comput(p1,s1,2+1) = Following(p1,s3) by EXTPRO_1:4
    .= Exec(goto  3,s3) by A26;
A28:  p4/.IC s4 = p4.IC s4 by PBOOLE:158;
  IC s4 =  3 by A27,SCMFSA_2:95;
  then
A29: CurInstr(p4,s4) = goto loc5 by A17,A28;
A30: Comput(p1,s1,3+1) = Following(p1,s4) by EXTPRO_1:4
    .= Exec(goto loc5,s4) by A29;
A31:  p5/.IC s5 = p5.IC s5 by PBOOLE:158;
  IC s5 = loc5 by A30,SCMFSA_2:95;
  then
A32: CurInstr(p5,s5) = halt SCM+FSA by A19,A31;
  then
A33: p1 halts_on s1 by EXTPRO_1:30;
A34: s = s1 by A1,FUNCT_4:104;
  now
    let k;
    assume
A35: CurInstr(p,Comput(p,s,k)) = halt SCM+FSA;
    assume 4 > k;
    then 3+1 > k;
    then
A36: k <= 3 by NAT_1:13;
    per cases by A36,NAT_1:28;
    suppose
      k = 0;
      then Comput(p,s,k) = s by EXTPRO_1:3;
      hence contradiction by A34,A12,A35,A4;
    end;
    suppose
      k = 1;
      hence contradiction by A34,A23,A35,A4;
    end;
    suppose
      k = 2;
      hence contradiction by A34,A26,A35,A4;
    end;
    suppose
      k = 3;
      hence contradiction by A34,A29,A35,A4;
    end;
  end;
  hence
A37: LifeSpan(p,s) = 4 by A34,A32,A33,A4,EXTPRO_1:def 14;
A38: ( for c being Int-Location holds Exec(i, s1).c = s1.c)& for f being
  FinSeq-Location holds Exec(i, s1).f = s1.f by SCMFSA_2:96;
  then
A39: DataPart Comput(p,s,1) = DataPart s by A34,A13,A4,SCMFSA6A:38;
  then
A40: DataPart Comput(p,s,2) = DataPart s by A34,A24,A21,A4,SCMFSA6A:38;
A41: ( for c being Int-Location holds Exec(goto  3, s3).c = s3.c)& for
f being FinSeq-Location holds Exec(goto  3, s3).f = s3.f by SCMFSA_2:95;
  then DataPart Comput(p,s,3) = DataPart s by A34,A27,A40,A4,SCMFSA6A:38;
  then
A42: DataPart Comput(p,s,4) = DataPart s by A34,A30,A20,A4,SCMFSA6A:38;
  let k be Element of NAT;
  k <= 3 or 3 < k;
  then
A43: k = 0 or k = 1 or k = 2 or k = 3 or 3+1 <= k by NAT_1:13,28;
  per cases by A43;
  suppose
    k = 0;
    hence thesis by EXTPRO_1:3;
  end;
  suppose
    k = 1;
    hence thesis by A34,A13,A38,A4,SCMFSA6A:38;
  end;
  suppose
    k = 2;
    hence thesis by A34,A24,A21,A39,A4,SCMFSA6A:38;
  end;
  suppose
    k = 3;
    hence thesis by A34,A27,A41,A40,A4,SCMFSA6A:38;
  end;
  suppose
    4 <= k;
    then CurInstr(p,Comput(p,
s,k))
     = halt SCM+FSA by A34,A33,A37,A4,SCMFSA8A:4;
    hence thesis by A37,A42,EXTPRO_1:24;
  end;
end;

theorem Th23: :: based on SCMFSA_9:22
  I is_closed_on s,p & I is_halting_on s,p & s.a = 0 implies DataPart
  Comput(p +* while=0(a,I),(Initialize s),
  (LifeSpan(p+* I,Initialize s) + 3)) =
DataPart Comput(p +* I,
   (Initialize s), (LifeSpan(p+* I,Initialize s)))
proof
  assume that
A1: I is_closed_on s,p & I is_halting_on s,p and
A2: s.a = 0;
  set sI = Initialize s,
      pI = p +* I;
  set s1 = Initialize s,
      p1 = p +* while=0(a,I);
A3: while=0(a,I) c= p1 by FUNCT_4:26;
  defpred P[Nat] means $1 <= LifeSpan(p+*I,sI)
   implies IC Comput(p1,s1,1+$1) = IC Comput(p+*I,sI,$1) + 4 &
   DataPart Comput(p1,s1,1+$1) = DataPart Comput(p+*I,sI,$1);
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    now
A6:   k + 0 < k + 1 by XREAL_1:8;
      assume k + 1 <= LifeSpan(p+*I,sI);
      then k < LifeSpan(p+*I,sI) by A6,XXREAL_0:2;
      hence IC Comput(p1,s1,1+k+1) = IC Comput(pI,sI,k+1) + 4 &
      DataPart Comput(p1,s1,1+k+1) = DataPart Comput(pI,sI,k+1)
       by A1,A5,SCMFSA_9:19;
    end;
    hence P[k + 1];
  end;
  set i = a =0_goto  4;
  set s2 = Comput(p1,s1,1),
      p2 = p1;
B7: IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
A8: IC s1 = IC Start-At(0,SCM+FSA) by B7,FUNCT_4:14
    .=  0 by COMPOS_1:64;
    Start-At(0,SCM+FSA) c= Initialize while=0(a,I) by FUNCT_4:26;
    then
U1: dom Start-At(0,SCM+FSA) c= dom Initialize while=0(a,I)
             by RELAT_1:25;
  not a in dom (Initialize while=0(a,I)) by SCMFSA6B:12;
  then not a in dom Start-At(0,SCM+FSA) by U1;
  then
A9: s1.a = s.a by FUNCT_4:12;
  set loc4 = card I + 4;
A10:  p1/.IC s1 = p1.IC s1 by PBOOLE:158;
  0 in dom while=0(a,I) by SCMFSA_9:10;
  then p1. 0 = while=0(a,I). 0
  by FUNCT_4:14
    .= i by SCMFSA_9:11;
  then
A11: CurInstr(p1,s1) = i by A8,A10;
A12: Comput(p1,s1,0+1) = Following(p1,Comput(p1,s1,0)) by EXTPRO_1:4
    .= Following(p1,s1) by EXTPRO_1:3
    .= Exec(i,s1) by A11;
  then ( for c being Int-Location holds s2.c = s1.c)& for f being
  FinSeq-Location holds s2.f = s1.f by SCMFSA_2:96;
  then
A13: DataPart s2 = DataPart s1 by SCMFSA6A:38
    .= DataPart sI;
A14: IC s2 =  4 by A2,A12,A9,SCMFSA_2:96;
A15: P[0]
  proof
    assume 0 <= LifeSpan(p+*I,sI);
B16: IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
    IC Comput(pI,sI,0) = IC sI by EXTPRO_1:3
      .= IC Start-At(0,SCM+FSA) by B16,FUNCT_4:14
      .=  0 by COMPOS_1:64;
    hence thesis by A14,A13,EXTPRO_1:3;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A15,A4);
  then
A17: P[LifeSpan(p+*I,sI) qua Element of NAT];
  set s4=Comput(p1,s1,1+LifeSpan(p+*I,sI)+1+1),
      p4 = p1;
  set s3 = Comput(p1,s1,1+LifeSpan(p+*I,sI)+1),
      p3 = p1;
A18: loc4 in dom while=0(a,I) by SCMFSA_9:13;
  set s2 = Comput(p1,s1,1+LifeSpan(p+*I,sI));
A19: CurInstr(p2,s2) = goto loc4 by A1,A17,SCMFSA_9:20;
A20: s3 = Following(p1,s2) by EXTPRO_1:4
    .= Exec(goto loc4,s2) by A19;
  then
A21: ( for c being Int-Location holds s3.c = s2.c)& for f being
  FinSeq-Location holds s3.f = s2.f by SCMFSA_2:95;
A22: p3.loc4 = while=0(a,I).loc4 by A18,A3,GRFUNC_1:8
    .= goto  0 by SCMFSA_9:21;
A23:  p3/.IC s3 = p3.IC s3 by PBOOLE:158;
  IC s3 = loc4 by A20,SCMFSA_2:95;
  then
A24: CurInstr(p3,s3) = goto  0 by A22,A23;
  s4 = Following(p1,s3) by EXTPRO_1:4
    .= Exec(goto  0,s3) by A24;
  then ( for c being Int-Location holds s4.c = s3.c)& for f being
  FinSeq-Location holds s4.f = s3.f by SCMFSA_2:95;
  hence DataPart Comput(p1,s1,LifeSpan(p+*I,sI)+3) =
       DataPart s3 by SCMFSA6A:38
    .= DataPart Comput(pI,sI,LifeSpan(p+*I,sI)) by A17,A21,SCMFSA6A:38;
end;

theorem Th24: :: Step_eq0_0:
  (StepWhile=0(a,I,p,s).k).a <> 0 implies
   DataPart StepWhile=0(a,I,p,s).(k+1) = DataPart StepWhile=0(a,I,p,s).k
proof
  assume
A1: (StepWhile=0(a,I,p,s).k).a <> 0;
  set SW = StepWhile=0(a,I,p,s),
      PW = p +* while=0(a,I);
A2:  PW +* while=0(a,I) = PW by FUNCT_4:99;
A3: while=0(a,I) c= PW by FUNCT_4:26;
A4: Start-At(0,SCM+FSA) c= Initialize(SW.k)
by FUNCT_4:26;
A5: DataPart(Initialize(SW.k)) = DataPart SW.k
by SCMFSA8A:10;
  then
A6: SW.k.a = (Initialize(SW.k)).a by SCMFSA6A:38;
  thus DataPart SW.(k+1) = DataPart Comput(PW +* while=0(a,I),
  (Initialize(SW.k)
  ), (LifeSpan(PW +* I,Initialize(SW.k)) + 3)) by A2,SCMFSA_9:def 4
    .= DataPart StepWhile=0(a,I,p,s).k by A1,A5,A6,A4,Th22,A2,A3;
end;

theorem Th25: :: Step_eq0_1:
  ( I is_halting_on Initialized StepWhile=0(a,I,p,s).k ,p+*while=0(a,I) & I
  is_closed_on Initialized StepWhile=0(a,I,p,s).k ,p+*while=0(a,I) or
    I is parahalting) & (
  StepWhile=0(a,I,p,s).k).a = 0 & (StepWhile=0(a,I,p,s).k).intloc 0 = 1 implies
DataPart StepWhile=0(a,I,p,s).(k+1) =
 DataPart IExec(I,p+*while=0(a,I),StepWhile=0(a,I,p,s).k)
proof
  set Ins = NAT;
  assume that
A1: I is_halting_on Initialized StepWhile=0(a,I,p,s).k ,p+*while=0(a,I) &
    I is_closed_on Initialized StepWhile=0(a,I,p,s).k ,p+*while=0(a,I) or
     I is parahalting and
A2: (StepWhile=0(a,I,p,s).k).a = 0 and
A3: (StepWhile=0(a,I,p,s).k).intloc 0 = 1;
  set ISWk = Initialized StepWhile=0(a,I,p,s).k;
  set SW = StepWhile=0(a,I,p,s),
      PW = p +* while=0(a,I);
  set SWkI = SW.k+*Initialize((intloc 0).-->1),
      PWI = p +* while=0(a,I) +* I;
A5:  PW +* while=0(a,I) = PW by FUNCT_4:99;
  DataPart ISWk = DataPart SW.k by A3,SCMFSA8C:27;
  then
A6: I is_closed_on SW.k ,PW & I is_halting_on SW.k ,PW
       by A1,SCMFSA7B:24,25,SCMFSA8B:8;
  I is_halting_on ISWk ,PW by A1,SCMFSA7B:25;
  then
A7: I is_halting_on Initialized SW.k ,PW;
XX: Start-At(0,SCM+FSA) c= Initialized SW.k by SCMFSA6B:4;
 SW.k +*Initialize((intloc 0).-->1)
         = SW.k +*Initialize((intloc 0).-->1)
        .= Initialized SW.k
        .= Initialize Initialized(SW.k) by XX,FUNCT_4:104;
    then
A9:  PW +* I halts_on SW.k+*(Initialize((intloc 0).-->1))
    by A7,SCMFSA7B:def 8;
A10: PWI halts_on SWkI by A9;
A11:  dom(SW.k | Ins) c= NAT by RELAT_1:87;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A12: dom(SW.k | Ins) misses D by A11,XBOOLE_1:63;
  set IS = Initialize I;
  set SWkIS = Initialize(SW.k),
      PWIS = PW +* I;
A13: SWkI = SWkIS by A3,SCMFSA8C:18;
  set WHS = Initialize while=0(a,I);
A14: SW.(k+1)
  = Comput(PW +* while=0(a,I),
  (Initialize(SW.k)),LifeSpan(PWIS,SWkIS)+ 3)
   by A5,SCMFSA_9:def 4;
A15: DataPart IExec(I,PW,SW.k)
     = DataPart(Result(PWI,SWkI) +* SW.k | Ins) by SCMFSA6B:def 1
    .= DataPart Result(PWI,SWkI) by A12,FUNCT_4:76,SCMFSA_2:127
    .= DataPart Comput(PWIS,SWkIS,LifeSpan(PWIS,SWkIS)) by A13,A10,EXTPRO_1:23;
  thus DataPart StepWhile=0(a,I,p,s).(k+1)
   = DataPart Comput(PWIS,SWkIS,LifeSpan(PWIS,SWkIS))
  by A2,A6,Th23,A14
   .= DataPart IExec(I,PW,StepWhile=0(a,I,p,s).k) by A15;
end;

theorem :: eGoodStep0:
  (ProperBodyWhile=0 a,Ig,s,p or Ig is parahalting) & s.intloc 0 = 1
  implies for k holds StepWhile=0(a,Ig,p,s).k.intloc 0 = 1
proof
  set I = Ig;
  assume that
A1: ProperBodyWhile=0 a,I,s,p or I is parahalting and
A2: s.intloc 0 = 1;
  set SW = StepWhile=0(a,I,p,s),
      PW = p +* while=0(a,I);
  defpred X[Nat] means SW.$1.intloc 0 = 1;
A4: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT such that
A5: SW.k.intloc 0 = 1;
    per cases;
    suppose
      SW.k.a <> 0;
      then DataPart SW.(k+1) = DataPart SW.k by Th24;
      hence thesis by A5,SCMFSA6A:38;
    end;
    suppose
A6:   SW.k.a = 0;
      set Ins = NAT;
      set IS = Initialize I;
      set SWkIS = Initialize(SW.k),
          PWIS = PW +* I;
A7:  dom(SW.k | Ins) c= NAT by RELAT_1:87;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A8: dom(SW.k | Ins) misses D by A7,XBOOLE_1:63;
      set SWkI = SW.k+*Initialize((intloc 0).-->1),
      PWI = p +* while=0(a,I) +* I;
      set ISWk = Initialized StepWhile=0(a,I,p,s).k;
A9:   DataPart SW.k = DataPart ISWk by A5,SCMFSA8C:27;
A10:   ProperBodyWhile=0 a,I,s,p by A1,Th19;
      then
A11:   I is_closed_on SW.k ,PW by A6,Def1;
      I is_halting_on SW.k ,PW by A6,A10,Def1;
      then
A13:  I is_halting_on Initialized SW.k ,PW by A11,A9,SCMFSA8B:8;
XX: Start-At(0,SCM+FSA) c= Initialized SW.k by SCMFSA6B:4;
 SW.k +*Initialize((intloc 0).-->1)
         = SW.k +*Initialize((intloc 0).-->1)
        .= Initialized SW.k
        .= Initialize Initialized(SW.k) by XX,FUNCT_4:104;
    then
B14:  PW +* I halts_on SW.k+*(Initialize((intloc 0).-->1))
       by A13,SCMFSA7B:def 8;
A15:  PWI halts_on SWkI by B14;
A16:  SWkI = SWkIS by A5,SCMFSA8C:18;
A17:  DataPart IExec(I,PW,SW.k) = DataPart(Result(PWI,SWkI) +* SW.k
| Ins) by SCMFSA6B:def 1
        .= DataPart Result(PWI,SWkI) by A8,FUNCT_4:76,SCMFSA_2:127
        .= DataPart Comput(PWIS,SWkIS,LifeSpan(PWIS
,SWkIS)) by A16,A15,EXTPRO_1:23;
      I is_closed_on Initialized SW.k ,PW by A11,A9,SCMFSA8B:6;
      then DataPart SW.(k+1) = DataPart IExec(I,PW,SW.k) by A5,A6,A13,Th25;
      hence
      SW.(k+1).intloc 0 = (Comput(PWIS,SWkIS,LifeSpan(PWIS,SWkIS))).
intloc 0 by A17,SCMFSA6A:38
        .= 1 by A5,A11,SCMFSA8C:97;
    end;
  end;
A18: X[0] by A2,SCMFSA_9:def 4;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A18,A4);
end;

theorem
  ProperBodyWhile=0 a,I,s1,p1 & DataPart s1 = DataPart s2 implies for k
  holds DataPart StepWhile=0(a,I,p1,s1).k = DataPart StepWhile=0(a,I,p2,s2).k
proof
  assume that
A1: ProperBodyWhile=0 a,I,s1,p1 and
A2: DataPart s1 = DataPart s2;
  set WH = while=0(a,I);
  set ST2 = StepWhile=0(a,I,p2,s2),
      PT2 = p2 +* while=0(a,I);
  set ST1 = StepWhile=0(a,I,p1,s1),
      PT1 = p1 +* while=0(a,I);
A3:  PT2 +* while=0(a,I) = PT2 by FUNCT_4:99;
A4:  PT1 +* while=0(a,I) = PT1 by FUNCT_4:99;
  defpred X[Nat] means DataPart ST1.$1 = DataPart ST2.$1;
A5: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k;
    set ST1kI = Initialize(ST1.k),
        PT1I = PT1 +* I;
    set ST2kI = Initialize(ST2.k),
        PT2I = PT2 +* I;
A6: I c= PT1I by FUNCT_4:26;
A7: I c= PT2I by FUNCT_4:26;
    assume
A8: DataPart ST1.k = DataPart ST2.k;
    then
A9: ST1.k.a = ST2.k.a by SCMFSA6A:38;
    per cases;
    suppose
A10:   ST1.k.a <> 0;
      hence DataPart ST1.(k+1) = DataPart ST1.k by Th24
        .= DataPart ST2.(k+1) by A8,A9,A10,Th24;
    end;
    suppose
A11:   ST1.k.a = 0;
      then
A12:   I is_closed_on ST1.k, PT1 by A1,Def1;
A13:   I is_halting_on ST1.k, PT1 by A1,A11,Def1;
      then
A14:  I is_closed_on ST2.k, PT2 & I is_halting_on ST2.k, PT2
          by A8,A12,SCMFSA8B:8;
A15:  DataPart ST1.(k+1) = DataPart Comput(PT1 +* while=0(a,I),
(Initialize(ST1.k)), (
      LifeSpan(PT1I,ST1kI) + 3)) by A4,SCMFSA_9:def 4
        .= DataPart Comput(PT1I,(ST1kI),LifeSpan(PT1I,ST1kI)) by A11,A12,A13
,Th23;
A16:  DataPart ST2.(k+1) = DataPart Comput(PT2 +* while=0(a,I),
(Initialize(ST2.k)), (
      LifeSpan(PT2I,ST2kI) + 3)) by A3,SCMFSA_9:def 4
        .= DataPart Comput(PT2I,(ST2kI),
          LifeSpan(PT2I,ST2kI)) by A9,A11,A14,Th23;
A17:  Start-At(0,SCM+FSA) c= ST1kI & Start-At(0,SCM+FSA) c= ST2kI
 by FUNCT_4:26;
A18:  DataPart ST1.k = DataPart ST1kI by SCMFSA8A:10;
      then
A19:  I is_closed_on ST1kI, PT1I by A12,SCMFSA8B:6;
A20:  DataPart ST1kI = DataPart ST1.k by SCMFSA8A:10
        .= DataPart ST2kI by A8,SCMFSA8A:10;
      I is_halting_on ST1kI, PT1I by A12,A13,A18,SCMFSA8B:8;
      then (LifeSpan(PT1I,ST1kI)) = (LifeSpan(PT2I,
ST2kI)) by A12,A20,A17,A18,A6,A7,SCMFSA8B:6,SCMFSA8C:44;
      hence thesis by A15,A16,A20,A17,A19,A6,A7,SCMFSA8C:43;
    end;
  end;
  DataPart ST1.0 = DataPart s1 by SCMFSA_9:def 4
    .= DataPart ST2.0 by A2,SCMFSA_9:def 4;
  then
A21: X[0];
  thus for k holds X[k] from NAT_1:sch 1(A21, A5);
end;

definition let p;
  let s be State of SCM+FSA, a be read-write Int-Location,
      I be Program of SCM+FSA;
  assume that
A1: ProperBodyWhile=0 a,I,s,p or I is parahalting and
A2: WithVariantWhile=0 a,I,s,p;
  func ExitsAtWhile=0(a, I, p, s) -> Element of NAT means
  :Def3:
  ex k being Element of NAT
   st it = k & (StepWhile=0(a,I,p,s).k).a <> 0 &
    (for i being Element of NAT
     st (StepWhile=0(a,I,p,s).i).a <> 0 holds k <= i) &
    DataPart Comput(p +* while=0(a, I),
      Initialize s,
       (LifeSpan(p +* while=0(a, I),
       Initialize s)))
     = DataPart StepWhile=0(a,I,p,s).k;
  existence
  proof
    set S = Initialize s,
        P = p +* while=0(a, I);
    set SW = StepWhile=0(a,I,p,s),
      PW = p +* while=0(a,I);
A3: while=0(a,I) c= PW by FUNCT_4:26;
A4:  PW +* while=0(a,I) = PW by FUNCT_4:99;
    defpred X[Nat] means SW.$1.a <> 0;
A6: Start-At(0,SCM+FSA) c= S by FUNCT_4:26;
    consider f being Function of product the Object-Kind of SCM+FSA, NAT such
    that
A7: for k being Element of NAT holds f.(SW.(k+1))<f.(SW.(k)) or X[k]
    by A2,Def2;
    deffunc U(Nat) = f.(SW.$1);
A8: for k being Element of NAT holds U(k+1)<U(k) or X[k] by A7;
    consider m such that
A9: X[m] and
A10: for n st X[n] holds m <= n from NAT_1:sch 18(A8);
    take m, m;
    thus m = m;
    thus SW.m.a <> 0 by A9;
    thus for n st SW.n.a <> 0 holds m <= n by A10;
    defpred P[Nat] means $1+1 <= m implies
     ex k st StepWhile=0(a,I,p,s).($1+1)=Comput(P,S,k);
A11: ProperBodyWhile=0 a,I,s,p by A1,Th19;
A12: now
      let k be Element of NAT;
      assume
A13:  P[k];
      now
        set sk1=StepWhile=0(a,I,p,s).(k+1);
        set sk=StepWhile=0(a,I,p,s).k,
          pk = p +* while=0(a,I);
        assume
A14:    (k+1)+ 1 <= m;
        k + 0 < k+ (1+ 1) by XREAL_1:8;
        then k < m by A14,XXREAL_0:2;
        then
A15:    sk.a = 0 by A10;
        (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
        then consider n being Element of NAT such that
A16:    sk1 = Comput(P,S,n) by A13,A14,XXREAL_0:2;
A17:    sk1 = Comput(pk +* while=0(a,I),(Initialize sk),
        (LifeSpan(pk +* I,Initialize sk) + 3))
by A4,SCMFSA_9:def 4;
        take m=n +(LifeSpan(pk +* I,Initialize sk1) +
3);
        I is_closed_on sk,pk & I is_halting_on sk,pk by A11,A15,Def1;
        then IC sk1 = 0 by A17,A15,SCMFSA_9:22;
        hence StepWhile=0(a,I,p,s).((k+1)+1)=Comput(P,S,m) by A16,SCMFSA_9:31;
      end;
      hence P[k+1];
    end;
B18: IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
A19: P[0]
    proof
      assume 0+1 <= m;
      take n=(LifeSpan(p+*while=0(a,I) +* I,Initialize s) + 3);
      thus thesis by SCMFSA_9:30;
    end;
A20: for k being Element of NAT holds P[k] from NAT_1:sch 1(A19,A12);
    per cases;
    suppose
A21:  m = 0;
A22:  DataPart S = DataPart s by SCMFSA8A:10
        .= DataPart SW.m by A21,SCMFSA_9:def 4;
      then S.a = SW.m.a by SCMFSA6A:38;
      hence thesis by A9,A6,A22,Th22,A3;
    end;
    suppose
A23:  m <> 0;
      set sm = StepWhile=0(a,I,p,s).m,
          pm = p +* while=0(a,I);
      set sm1 = Initialize sm,
          pm1 = pm +* while=0(a,I);
      consider i being Nat such that
A24:  m=i+1 by A23,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      set si = StepWhile=0(a,I,p,s).i,
          psi = p +* while=0(a,I);
A25:  sm = Comput(psi +* while=0(a,I),(Initialize si),
      (LifeSpan(psi +* I,Initialize si) + 3))
      by A24,A4,SCMFSA_9:def 4;
      m=i+1 by A24;
      then consider n being Element of NAT such that
A26:  sm = Comput(P,S,n) by A20;
      i < m by A24,NAT_1:13;
      then
A27:  si.a = 0 by A10;
      then I is_closed_on si,psi & I is_halting_on si,psi by A11,Def1;
      then
A28:  IC sm = 0 by A25,A27,SCMFSA_9:22;
A29:  IC sm1 = IC Start-At(0,SCM+FSA) by B18,FUNCT_4:14
        .= IC sm by A28,COMPOS_1:64;
A30:   ProgramPart sm = ProgramPart sm +* {} by FUNCT_4:22
      .= ProgramPart sm +*
             ProgramPart Start-At(0,SCM+FSA) by COMPOS_1:27
      .= ProgramPart(Initialize sm) by FUNCT_4:75;
      DataPart sm1 = DataPart sm by SCMFSA8A:10;
      then
A31:  sm1 = sm by A29,A30,SCMFSA_9:29;
A32:   pm1 = pm by FUNCT_4:99;
      while=0(a,I) is_halting_on sm,pm by A9,SCMFSA_9:18;
      then pm1 halts_on sm1 by SCMFSA7B:def 8;
      then consider j being Element of NAT such that
A33:  CurInstr(pm,Comput(pm,sm,j)) = halt SCM+FSA by A31,A32,EXTPRO_1:30;

A34: Comput(P,S,n+j)
 = Comput(P,Comput(P,S,n),j) by EXTPRO_1:5;
      CurInstr(P,Comput(P,S,n+j))
       = halt SCM+FSA by A26,A33,A34;
      then
A35:  Comput(P,S,LifeSpan(P,S)) = Comput(P,S,n+j) by EXTPRO_1:24
        .= Comput(P,sm,j) by A26,EXTPRO_1:5
        .= Comput(pm,sm,LifeSpan(pm,sm)) by A33,EXTPRO_1:24;
      Start-At(0,SCM+FSA) c= sm by A31,FUNCT_4:26;
      hence thesis by A9,A35,Th22,A3;
    end;
  end;
  uniqueness
  proof
    let it1, it2 be Element of NAT;
    given k1 being Element of NAT such that
A36: it1 = k1 and
A37: (StepWhile=0(a,I,p,s).k1).a <> 0 & for i being Element of NAT st
    ( StepWhile=0(a,I,p,s).i).a <> 0 holds k1 <= i and
    DataPart(Comput(p +* while=0(a,I),(Initialize s),
    (LifeSpan(p +* while=0(a,I),Initialize s))))
     = DataPart StepWhile=0(a,I,p,s).k1;
    given k2 being Element of NAT such that
A38: it2 = k2 and
A39: (StepWhile=0(a,I,p,s).k2).a <> 0 & for i being Element of NAT st
    ( StepWhile=0(a,I,p,s).i).a <> 0 holds k2 <= i and
    DataPart(Comput(p +* while=0(a,I),(Initialize s),
    (LifeSpan(p +* while=0(a,I),Initialize s))))
     = DataPart StepWhile=0(a,I,p,s).k2;
    k1 <= k2 & k2 <= k1 by A37,A39;
    hence thesis by A36,A38,XXREAL_0:1;
  end;
end;

theorem :: IE_while_ne0:
  s.intloc 0 = 1 & s.a <> 0 implies DataPart IExec(while=0(a,I),p,s) =
  DataPart s
proof
  set Ins = NAT;
  assume that
A1: s.intloc 0 = 1 and
A2: s.a <> 0;
  set WH = while=0(a, I);
  set Is = Initialized s;
  set Ids = s +* Initialize((intloc 0).-->1),
      pds = p +* WH;
A3: while=0(a,I) c= pds by FUNCT_4:26;
A5: Ids = Initialize Is by SCMFSA8A:13;
  then
A6: Start-At(0,SCM+FSA) c= Ids by FUNCT_4:26;
  Is.a = s.a by SCMFSA6C:3;
  then WH is_halting_on Is,p by A2,SCMFSA_9:18;
  then
A7: pds halts_on Ids by A5,SCMFSA7B:def 8;
A8: Ids.a = Is.a
    .= s.a by SCMFSA6C:3;
A9:  dom(s | Ins) c= NAT by RELAT_1:87;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A10: dom(s | Ins) misses D by A9,XBOOLE_1:63;
  thus DataPart IExec(WH,p,s)
   = DataPart(Result(p +* WH,s+*Initialize((intloc 0).-->1)) +* s | Ins)
  by SCMFSA6B:def 1
    .= DataPart(Result(p +* WH,s+*Initialize((intloc 0).-->1))) by A10,
FUNCT_4:76,SCMFSA_2:127
    .= DataPart Comput(pds,Ids,LifeSpan(pds,Ids)) by A7,EXTPRO_1:23
    .= DataPart Initialized s by A2,A8,A6,Th22,A3
    .= DataPart s by A1,SCMFSA8C:27;
end;

theorem :: IE_while_eq0:
  (ProperBodyWhile=0 a,I,Initialized s,p or I is parahalting) &
WithVariantWhile=0 a,I,Initialized s,p
 implies
  DataPart IExec(while=0(a,I),p,s)
  = DataPart
   StepWhile=0(a,I,p,Initialized s).ExitsAtWhile=0(a,I,p,Initialized s)
proof
  set Ins = NAT;
  set WH = while=0(a, I);
  set Ids = s +* Initialize((intloc 0).-->1),
      pds = p +* WH;
  set Is = Initialized s;
A2: Ids = Initialize Is by SCMFSA8A:13;
A3:  dom(s | Ins) c= NAT by RELAT_1:87;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A4: dom(s | Ins) misses D by A3,XBOOLE_1:63;
  assume
A5: ( ProperBodyWhile=0 a,I,Initialized s,p or I is parahalting)&
  WithVariantWhile=0 a,I,Initialized s,p;
  then
A6: ex k being Element of NAT st ExitsAtWhile=0(a,I,p,Is) = k &
 (StepWhile=0(a, I, p, Is).k).a <> 0 &
 ( for i being Element of NAT st ( StepWhile=0(a,I,p,Is).i)
.a <> 0 holds k <= i)& DataPart(Comput(p +* while=0(a,I),
 (Is +* ( Start-At(0,SCM+FSA))), (
  LifeSpan(p +* while=0(a,I),Initialize Is)))) =
  DataPart StepWhile=0(a,I,p,Is).k
  by Def3;
  WH is_halting_on Is,p by A5,Th20,Th21;
  then
A7: pds halts_on Ids by A2,SCMFSA7B:def 8;
  thus DataPart IExec(while=0(a, I),p,s)
   = DataPart(Result(p +* WH,s+*Initialize((intloc 0).-->1)) +* s | Ins)
  by SCMFSA6B:def 1
    .= DataPart(Result(p +* WH,s+*Initialize((intloc 0).-->1))) by A4,
FUNCT_4:76,SCMFSA_2:127
    .= DataPart StepWhile=0(a,I,p,Is).ExitsAtWhile=0(a,I,p,Is) by A2,A7,A6,
EXTPRO_1:23;
end;

begin :: while>0, general

Lm4: for a being Int-Location, I being Program of SCM+FSA holds card I +4 in
dom if>0(a,I ';' Goto  0,Stop SCM+FSA) & if>0(a,I ';' Goto  0,Stop
SCM+FSA).(card I +4) = goto (( 0)+(card I +4))

proof
  set J = Stop SCM+FSA;
  set G = Goto  0;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' G;
  set i = a >0_goto  (card J + 3);
  set c4 = card I + 4;
  set Lc4 = c4;
  set Mi= Macro i ';' J ';' Goto  (card I1 + 1) ';' I;
A1: card Stop SCM+FSA = 1 by COMPOS_1:46;
A2: card (G ';' J) = card G + card J by SCMFSA6A:61
    .= 1 + 1 by A1,SCMFSA8A:29
    .= 2;

A3: if>0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' (I ';' G) ';'
  J by SCMFSA8B:def 2

    .= Mi ';' G ';' J by SCMFSA6A:67
    .= Mi ';' (G ';' J) by SCMFSA6A:67;
  then card if>0(a, I1,J) = card Mi + card (G ';' J) by SCMFSA6A:61;
  then
A4: card Mi = card if>0(a,I1,J)-card (G ';' J)
    .= card I + 6 - 2 by A2,SCMFSA_9:2
    .= c4;
  then
A5: not Lc4 in dom Mi;
  set GJ = G ';' J;
A7: G =  0 .--> goto  0 by SCMFSA8A:def 2;
  then
A8: G. 0 = goto  0 by FUNCOP_1:87;
  dom G = { 0} by A7,FUNCOP_1:19;
  then
A9:  0 in dom G by TARSKI:def 1;
A10: dom G c= dom GJ by SCMFSA6A:56;

  then  0 + c4 in { il+c4 where il is Element of NAT: il in dom GJ} by A9
;

  then
A11:  c4 in dom Shift(GJ,c4) by VALUED_1:def 12;
  then
A12: Shift(GJ,c4)/.Lc4 = Shift(GJ,c4).( 0 +c4) by PARTFUN1:def 8
    .= GJ. 0 by A9,A10,VALUED_1:def 12
    .= goto  0 by A9,A8,SCMFSA6A:54;
A13: card Stop SCM+FSA = 1 by COMPOS_1:46;
  card I1 = card I + card G by SCMFSA6A:61
    .= card I +1 by SCMFSA8A:29;
  then card I1 + card J + 3 = card I +4 +1 by A13;
  then c4 < card I1 + card J + 3 by NAT_1:13;
  hence
A14: Lc4 in dom if>0(a,I1,J) by SCMFSA8C:57;

A15: dom if>0(a,I1,J) = dom Directed Mi \/ dom Reloc(GJ, c4
  ) by A3,A4,FUNCT_4:def 1;

  then dom if>0(a,I1,J) = dom Mi \/ dom Reloc(GJ, c4) by FUNCT_4:105;

  then Lc4 in dom Reloc(GJ, c4) by A14,A5,XBOOLE_0:def 3;

  hence if>0(a,I1,J).Lc4 = (Reloc(GJ,c4)).Lc4 by A14,A3,A4,A15,FUNCT_4:def 1
    .= IncAddr( goto  0, c4 ) by A11,A12,COMPOS_1:def 40
    .= goto (( 0)+c4) by SCMFSA_4:14;
end;

Lm5: for a being Int-Location, I being Program of SCM+FSA holds UsedIntLoc
if>0(a,I ';' Goto  0,Stop SCM+FSA) = UsedIntLoc (if>0(a,I ';' Goto
0,Stop SCM+FSA) +* (  (card I +4) .--> goto  0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 =  (card I + 4);
  set if0 = if>0(a,I ';' Goto  0,Stop SCM+FSA);
  set ic4 =  (card I +4) .--> goto  0;

  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedIntLoc i and
A2: UsedIntLoc if0 = Union (UIL1 * if0) by SF_MASTR:def 2;
A3: dom UIL1 = the Instructions of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,RELAT_1:def 19;
A6: dom ic4 = { (card I +4)} by FUNCOP_1:19;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
     (card I +4) in dom if0 by Lm4;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
FUNCT_4:def 1,ZFMISC_1:37;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,RELAT_1:def 19;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:46
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:46;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:12
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.(goto (( 0)+(card I +4))) by A12,Lm4
        .= UsedIntLoc goto (( 0)+(card I +4)) by A1
        .= {} by SF_MASTR:19
        .= UsedIntLoc goto  0 by SF_MASTR:19
        .= UIL1.(goto  0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:87
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:14
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
  end;

  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A14: UsedIntLoc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 2;
  for c be Element of the Instructions of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedIntLoc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:113;
  hence thesis by A2,A14,A4,FUNCT_1:9;
end;

Lm6: for a being Int-Location, I being Program of SCM+FSA holds UsedInt*Loc
if>0(a,I ';' Goto  0,Stop SCM+FSA) = UsedInt*Loc (if>0(a,I ';' Goto
 0,Stop SCM+FSA) +* (  (card I +4) .--> goto  0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 =  (card I + 4);
  set if0 = if>0(a,I ';' Goto  0,Stop SCM+FSA);
  set ic4 =  (card I +4) .--> goto  0;

  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedInt*Loc i and
A2: UsedInt*Loc if0 = Union (UIL1 * if0) by SF_MASTR:def 4;
A3: dom UIL1 = the Instructions of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,RELAT_1:def 19;
A6: dom ic4 = { (card I +4)} by FUNCOP_1:19;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
     (card I +4) in dom if0 by Lm4;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
FUNCT_4:def 1,ZFMISC_1:37;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,RELAT_1:def 19;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:46
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:46;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:12
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.(goto (( 0)+(card I +4))) by A12,Lm4
        .= UsedInt*Loc goto (( 0)+(card I +4)) by A1
        .= {} by SF_MASTR:36
        .= UsedInt*Loc goto  0 by SF_MASTR:36
        .= UIL1.(goto  0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:87
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:14
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
  end;

  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A14: UsedInt*Loc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 4;
  for c be Element of the Instructions of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedInt*Loc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:113;
  hence thesis by A2,A14,A4,FUNCT_1:9;
end;

theorem :: whileUsed:
  UsedIntLoc while>0(b, I) = {b} \/ UsedIntLoc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ';' Goto  0;
  while>0(a, I) = if>0(a, IG, J) +* (  (card I +4) .--> goto
  0 ) by SCMFSA_9:def 2;
  hence UsedIntLoc while>0(a, I) = (UsedIntLoc if>0(a, IG, J)) by Lm5
    .= {a} \/ UsedIntLoc IG \/ UsedIntLoc J by Th15
    .= {a} \/ (UsedIntLoc I \/ UsedIntLoc Goto  0) \/ UsedIntLoc J by
SF_MASTR:31
    .= {a} \/ (UsedIntLoc I \/ {}) \/ UsedIntLoc J by Th11
    .= {a} \/ UsedIntLoc I by Th9;
end;

theorem :: whileUsedF:
  UsedInt*Loc while>0(b, I) = UsedInt*Loc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ';' Goto  0;
  while>0(a, I) = if>0(a, IG, J) +* (  (card I +4) .--> goto
  0 ) by SCMFSA_9:def 2;
  hence UsedInt*Loc while>0(a, I) = (UsedInt*Loc if>0(a, IG, J)) by Lm6
    .= UsedInt*Loc IG \/ UsedInt*Loc J by Th16
    .= (UsedInt*Loc I \/ UsedInt*Loc Goto  0) \/ UsedInt*Loc J by SF_MASTR:47
    .= UsedInt*Loc I \/ {} by Th10,Th12
    .= UsedInt*Loc I;
end;

definition let p;
  let s be State of SCM+FSA, a be read-write Int-Location, I be Program of
  SCM+FSA;
  pred ProperBodyWhile>0 a,I,s,p means
  :Def4:
  for k being Element of NAT st StepWhile>0(a,I,p,s).k.a > 0
   holds I is_closed_on StepWhile>0(a,I,p,s).k, p+*while>0(a,I) &
   I is_halting_on StepWhile>0(a,I,p,s).k, p+*while>0(a,I);
  pred WithVariantWhile>0 a,I,s,p means
  :Def5:
  ex f being Function of product
  the Object-Kind of SCM+FSA, NAT st for k being Element of NAT holds ( f.(
StepWhile>0(a,I,p,s).(k+1)) < f.(StepWhile>0(a,I,p,s).k) or
 StepWhile>0(a,I,p,s).k.a
  <= 0 );
end;

theorem Th32: :: ParaProper:
  for I being parahalting Program of SCM+FSA holds
  ProperBodyWhile>0 a,I,s,p
proof
  let I be parahalting Program of SCM+FSA;
  let k be Element of NAT such that
  StepWhile>0(a,I,p,s).k.a > 0;
  thus I is_closed_on StepWhile>0(a,I,p,s).k, p+*while>0(a,I) by SCMFSA7B:24;
  thus thesis by SCMFSA7B:25;
end;

theorem Th33: :: SCMFSA_9:42, corrected
  ProperBodyWhile>0 a,I,s,p & WithVariantWhile>0 a,I,s,p implies
  while>0(a,I) is_halting_on s,p & while>0(a,I) is_closed_on s,p
proof
  assume
A2: for k being Element of NAT st StepWhile>0(a,I,p,s).k.a > 0 holds I
  is_closed_on StepWhile>0(a,I,p,s).k, p+*while>0(a,I) &
  I is_halting_on StepWhile>0(a,I,p,s).k, p+*while>0(a,I);
  set s1 = Initialize s,
      p1 = p +* while>0(a,I);
A3:  p1 +* while>0(a,I) = p1 by FUNCT_4:99;
  defpred S[Nat] means StepWhile>0(a,I,p,s).$1.a <= 0;
  given f being Function of product the Object-Kind of SCM+FSA,NAT such that
A4: for k being Element of NAT holds (f.(StepWhile>0(a,I,p,s).(k+1)) < f.(
  StepWhile>0(a,I,p,s).k) or (StepWhile>0(a,I,p,s).k).a <= 0 );
  deffunc F(Nat) = f.(StepWhile>0(a,I,p,s).$1);
A5: for k holds ( F(k+1) < F(k) or S[k] ) by A4;
  consider m being Element of NAT such that
A6: S[m] and
A7: for n st S[n] holds m <= n from NAT_1:sch 18(A5);
  defpred P[Nat] means $1+1 <= m implies ex k st StepWhile>0(a,I,p,s)
  .($1+1)=Comput(p1,s1,k);
A8: now
    let k be Element of NAT;
    assume
A9: P[k];
    now
      set sk1=StepWhile>0(a,I,p,s).(k+1);
      set sk=StepWhile>0(a,I,p,s).k,
          pk = p +* while>0(a,I);
      assume
A10:   (k+1)+ 1 <= m;
      k + 0 < k+ (1+ 1) by XREAL_1:8;
      then k < m by A10,XXREAL_0:2;
      then
A11:   sk.a > 0 by A7;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
      then consider n being Element of NAT such that
A12:  sk1 = Comput(p1,s1,n) by A9,A10,XXREAL_0:2;
A13:  sk1 = Comput(pk +* while>0(a,I),(Initialize sk),
      (LifeSpan(pk +* I,Initialize sk) + 3))
by A3,SCMFSA_9:def 5;
      take m=n +(LifeSpan(pk +* I,Initialize sk1) + 3);
      I is_closed_on sk,pk & I is_halting_on sk,pk by A2,A11;
      then IC sk1 = 0 by A13,A11,SCMFSA_9:47;
      hence StepWhile>0(a,I,p,s).((k+1)+1)=Comput(p1,s1,m) by A12,SCMFSA_9:52;
    end;
    hence P[k+1];
  end;
A15: P[0]
  proof
    assume 0+1 <= m;
    take n=(LifeSpan(p +* while>0(a,I) +* I,Initialize s) + 3);
    thus thesis by SCMFSA_9:51;
  end;
A16: for k being Element of NAT holds P[k] from NAT_1:sch 1(A15,A8);
  now
    per cases;
    suppose
      m=0;
      then s.a <= 0 by A6,SCMFSA_9:def 5;
      hence thesis by SCMFSA_9:43;
    end;
    suppose
A17:  m<>0;
      set ii=(LifeSpan(p+* while>0(a,I) +* I,Initialize s) + 3);
      set sm=StepWhile>0(a,I,p,s).m,
          pm = p +* while>0(a,I);
      set sm1=Initialize sm,
          pm1 = pm +* while>0(a,I);
      consider i being Nat such that
A18:  m=i+1 by A17,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      set si=StepWhile>0(a,I,p,s).i,
          psi = p +* while>0(a,I);
A19:  sm= Comput(psi +* while>0(a,I),(Initialize si),
      (LifeSpan(psi +* I,Initialize si) + 3))
      by A18,A3,SCMFSA_9:def 5;
      m=i+1 by A18;
      then consider n being Element of NAT such that
A20:  sm = Comput(p1,s1,n) by A16;
      i < m by A18,NAT_1:13;
      then
A21:  si.a > 0 by A7;
      then I is_closed_on si,psi & I is_halting_on si,psi by A2;
      then
      IC sm = 0 by A19,A21,SCMFSA_9:47;
      then Start-At(0,SCM+FSA) c= sm by COMPOS_1:164;
      then
A24:  sm1=sm by FUNCT_4:104;
      while>0(a,I) is_halting_on sm,pm by A6,SCMFSA_9:43;
      then pm1 halts_on sm1 by SCMFSA7B:def 8;
      then consider j being Element of NAT such that
A25:  CurInstr(pm,Comput(pm,sm,j)) = halt SCM+FSA
by A24,A3,EXTPRO_1:30;
A26: Comput(p1,s1,n+j)
 = Comput(p1,Comput(p1,s1,n),j) by EXTPRO_1:5;
      CurInstr(p1,Comput(p1,s1,n+j))
       = halt SCM+FSA by A20,A25,A26;
      then p1 halts_on s1 by EXTPRO_1:30;
      hence while>0(a,I) is_halting_on s,p by SCMFSA7B:def 8;
      now
        let q be Element of NAT;
        per cases;
        suppose
A27:      q <= ii;
A28:      StepWhile>0(a,I,p,s).0=s by SCMFSA_9:def 5;
          then
A29:      s.a > 0 by A7,A17;
          then I is_closed_on s,p1 & I is_halting_on s,p1 by A2,A28;
          hence IC Comput(p1,s1,q) in dom while>0(a,I) by A27,A29,A3,
SCMFSA_9:47;
        end;
        suppose
A30:      q > ii;
A31:      now
            take k=ii;
            thus StepWhile>0(a,I,p,s).1
            =Comput(p1,s1,k) & k <= q by A30,SCMFSA_9:51;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 &
          (ex k st StepWhile>0(a,I,p,s).$1
          = Comput(p1,s1,k) & k <= q);
A32:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A17,XREAL_1:8;
          then 1 <= m by NAT_1:13;
          then
A33:      ex k be Nat st P2[k] by A31;
          consider t being Nat such that
A34:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A32, A33);
          reconsider t as Element of NAT by ORDINAL1:def 13;
          now
            per cases;
            suppose
              t=m;
              then consider r being Element of NAT such that
A35:          sm=Comput(p1,s1,r) and
A36:          r <= q by A34;
              consider x being Nat such that
A37:          q = r+x by A36,NAT_1:10;
A38:          while>0(a,I) is_closed_on sm,pm by A6,SCMFSA_9:43;
              reconsider x as Element of NAT by ORDINAL1:def 13;
              Comput(p1,s1,q) = Comput(p1,sm1,x) by A24,A35,A37,EXTPRO_1:5;
              hence IC Comput(p1,s1,q) in dom while>0(a,I) by A38,A3,
SCMFSA7B:def 7;
            end;
            suppose
A39:          t<>m;
              set Dt=StepWhile>0(a,I,p,s).t,
                  pt = p +* while>0(a,I);
              consider y being Nat such that
A40:          t=y+1 by A34,NAT_1:6;
              reconsider y as Element of NAT by ORDINAL1:def 13;
              set Dy=StepWhile>0(a,I,p,s).y,
                  py = p +* while>0(a,I);
A41:          Dt= Comput(py +* while>0(a,I),(Initialize Dy),
 (LifeSpan(py +* I,Initialize Dy) + 3)) by A40,A3,SCMFSA_9:def 5;
              y+ 0 < t by A40,XREAL_1:8;
              then y < m by A34,XXREAL_0:2;
              then
A42:          Dy.a > 0 by A7;
              then I is_closed_on Dy,py & I is_halting_on Dy,py by A2;
              then
A43:          IC Dt = 0 by A41,A42,SCMFSA_9:47;
              consider z being Element of NAT such that
A44:          StepWhile>0(a,I,p,s).t=Comput(p1,s1,z) and
A45:          z <= q by A34;
              consider w being Nat such that
A46:          q = z+w by A45,NAT_1:10;
              reconsider w as Element of NAT by ORDINAL1:def 13;
A47: Dt = Initialize Dt by A44,A43,SCMFSA_9:52;
A48:          Comput(p1,s1,q)
                = Comput(pt +* while>0(a,I),Initialize Dt,w)
                 by A47,A3,A44,A46,EXTPRO_1:5;
              set z2=z +(LifeSpan(pt +* I,Initialize Dt) + 3);
A49:          t < m by A34,A39,XXREAL_0:1;
              now
                assume
A50:            z2 <= q;
A51:            now
                  take k=z2;
                  thus StepWhile>0(a,I,p,s).(t+1)
                  =Comput(p1,s1,k) &
k <= q by A44,A43,A50,SCMFSA_9:52;
                end;
                t+1 <= m by A49,NAT_1:13;
                hence contradiction by A34,A51,XREAL_1:31;
              end;
              then
A52:          w < LifeSpan(pt +* I,Initialize Dt) + 3
by A46,XREAL_1:8;
A53:          Dt.a > 0 by A7,A49;
              then I is_closed_on Dt,pt & I is_halting_on Dt,pt by A2;
              hence IC Comput(p1,s1,q) in dom while>0(a,I) by A52,A48,A53,
SCMFSA_9:47;
            end;
          end;
          hence IC Comput(p1,s1,q) in dom while>0(a,I);
        end;
      end;
      hence while>0(a,I) is_closed_on s,p by SCMFSA7B:def 7;
    end;
  end;
  hence thesis;
end;

theorem Th34: :: SCMFSA_9:43, corrected
  for I being parahalting Program of SCM+FSA
   st WithVariantWhile>0 a, I, s, p
    holds while>0(a,I) is_halting_on s,p & while>0(a,I) is_closed_on s,p
proof
  let I be parahalting Program of SCM+FSA such that
A1: WithVariantWhile>0 a,I,s,p;
  ProperBodyWhile>0 a,I,s,p
  proof
    let k be Element of NAT;
    assume StepWhile>0(a,I,p,s).k.a > 0;
    thus thesis by SCMFSA7B:24,25;
  end;
  hence thesis by A1,Th33;
end;

theorem Th35: :: based on SCMFSA_9:32
  Start-At(0,SCM+FSA) c= s & while>0(a, I) c= p &
  s.a <= 0 implies
  LifeSpan(p,s) = 4 & for k being Element of NAT holds DataPart
Comput(p,s,k) = DataPart s
proof
  assume that
A1: Start-At(0,SCM+FSA) c= s and
A2: while>0(a, I) c= p and
A3: s.a <= 0;
A4: p +* while>0(a, I) = p by A2,FUNCT_4:104;
  set i = a >0_goto  4;
  set s1 = Initialize s,
      p1 = p +* while>0(a,I);
A5: while>0(a,I) c= p1 by FUNCT_4:26;
B6: IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
    Start-At(0,SCM+FSA) c= Initialize while>0(a,I) by FUNCT_4:26;
    then
U1: dom Start-At(0,SCM+FSA) c= dom Initialize while>0(a,I)
             by RELAT_1:25;
  not a in dom (Initialize while>0(a,I)) by SCMFSA6B:12;
  then not a in dom Start-At(0,SCM+FSA) by U1;
  then
A7: s1.a = s.a by FUNCT_4:12;
A8:  1 in dom while>0(a,I) by SCMFSA_9:10;
A9: p1. 1 = while>0(a,I). 1 by A8,FUNCT_4:14
    .= goto  2 by SCMFSA_9:11;
A10: IC s1 = IC Start-At(0,SCM+FSA) by B6,FUNCT_4:14
    .=  0 by COMPOS_1:64;
A11:  p1/.IC s1 = p1.IC s1 by PBOOLE:158;
  0 in dom while>0(a,I) by SCMFSA_9:10;
  then p1. 0 = while>0(a,I). 0
  by FUNCT_4:14
    .= i by SCMFSA_9:11;
  then
A12: CurInstr(p1,s1) = i by A10,A11;
A13: Comput(p1,s1,0+1) = Following(p1,
Comput(p1,s1,0)) by EXTPRO_1:4
    .= Following(p1,s1) by EXTPRO_1:3
    .= Exec(i,s1) by A12;
  set loc5=  (card I +5);
  set s5 = Comput(p1,s1,4),
      p5 = p1;
  set s4 = Comput(p1,s1,3),
      p4 = p1;
  set s3 = Comput(p1,s1,2),
      p3 = p1;
  set s2 = Comput(p1,s1,1);
A14:  2 in dom while>0(a,I) by SCMFSA_9:37;
A15: p3. 2 = while>0(a,I). 2 by A14,FUNCT_4:14
    .= goto  3 by SCMFSA_9:41;
A16:  3 in dom while>0(a,I) by SCMFSA_9:37;
A17: p4. 3 = while>0(a,I). 3 by A16,FUNCT_4:14
    .= goto loc5 by SCMFSA_9:40;
A18: loc5 in dom while>0(a,I) by SCMFSA_9:38;
A19: p5.loc5 = while>0(a,I).loc5 by A18,A5,GRFUNC_1:8
    .= halt SCM+FSA by SCMFSA_9:39;
A20: ( for c being Int-Location holds Exec(goto loc5, s4).c = s4.c)& for f
  being FinSeq-Location holds Exec(goto loc5, s4).f = s4.f by SCMFSA_2:95;
A21: ( for c being Int-Location holds Exec(goto  2, s2).c = s2.c)& for
f being FinSeq-Location holds Exec(goto  2, s2).f = s2.f by SCMFSA_2:95;
A22:  p1/.IC Comput(p1,s1,1) = p1.IC Comput(p1,s1,1) by PBOOLE:158;
  IC Comput(p1,s1,1) = succ  0 by A3,A10,A13,A7,SCMFSA_2:97
    .=  (0 + 1);
  then
A23: CurInstr(p1,Comput(p1,
s1,1))
 = goto  2 by A9,A22;
A24: Comput(p1,s1,1+1) = Following(p1,s2) by EXTPRO_1:4
    .= Exec(goto  2,s2) by A23;
A25:  p3/.IC s3 = p3.IC s3 by PBOOLE:158;
  IC s3 =  2 by A24,SCMFSA_2:95;
  then
A26: CurInstr(p3,s3) = goto  3 by A15,A25;
A27: Comput(p1,s1,2+1) = Following(p1,s3) by EXTPRO_1:4
    .= Exec(goto  3,s3) by A26;
A28:  p4/.IC s4 = p4.IC s4 by PBOOLE:158;
  IC s4 =  3 by A27,SCMFSA_2:95;
  then
A29: CurInstr(p4,s4) = goto loc5 by A17,A28;
A30: Comput(p1,s1,3+1) = Following(p1,s4) by EXTPRO_1:4
    .= Exec(goto loc5,s4) by A29;
A31:  p5/.IC s5 = p5.IC s5 by PBOOLE:158;
  IC s5 = loc5 by A30,SCMFSA_2:95;
  then
A32: CurInstr(p1,s5) = halt SCM+FSA by A19,A31;
  then
A33: p1 halts_on s1 by EXTPRO_1:30;
A34: s = s1 by A1,FUNCT_4:104;
  now
    let k;
    assume
A35: CurInstr(p,Comput(p,s,k)
) = halt SCM+FSA;
    assume 4 > k;
    then 3+1 > k;
    then
A36: k <= 3 by NAT_1:13;
    per cases by A36,NAT_1:28;
    suppose
      k = 0;
      then Comput(p,s,k) = s by EXTPRO_1:3;
      hence contradiction by A34,A12,A35,A4;
    end;
    suppose
      k = 1;
      hence contradiction by A34,A23,A35,A4;
    end;
    suppose
      k = 2;
      hence contradiction by A34,A26,A35,A4;
    end;
    suppose
      k = 3;
      hence contradiction by A34,A29,A35,A4;
    end;
  end;
  hence
A37: LifeSpan(p,s) = 4 by A34,A32,A33,A4,EXTPRO_1:def 14;
A38: ( for c being Int-Location holds Exec(i, s1).c = s1.c)& for f being
  FinSeq-Location holds Exec(i, s1).f = s1.f by SCMFSA_2:97;
  then
A39: DataPart Comput(p,s,1) = DataPart s by A34,A13,A4,SCMFSA6A:38;
  then
A40: DataPart Comput(p,s,2) = DataPart s by A34,A24,A21,A4,SCMFSA6A:38;
A41: ( for c being Int-Location holds Exec(goto  3, s3).c = s3.c)& for
f being FinSeq-Location holds Exec(goto  3, s3).f = s3.f by SCMFSA_2:95;
  then DataPart Comput(p,s,3) = DataPart s by A34,A27,A40,A4,SCMFSA6A:38;
  then
A42: DataPart Comput(p,s,4) = DataPart s by A34,A30,A20,A4,SCMFSA6A:38;
  let k be Element of NAT;
  k <= 3 or 3 < k;
  then
A43: k = 0 or k = 1 or k = 2 or k = 3 or 3+1 <= k by NAT_1:13,28;
  per cases by A43;
  suppose
    k = 0;
    hence thesis by EXTPRO_1:3;
  end;
  suppose
    k = 1;
    hence thesis by A34,A13,A38,A4,SCMFSA6A:38;
  end;
  suppose
    k = 2;
    hence thesis by A34,A24,A21,A39,A4,SCMFSA6A:38;
  end;
  suppose
    k = 3;
    hence thesis by A34,A27,A41,A40,A4,SCMFSA6A:38;
  end;
  suppose
    4 <= k;
    then CurInstr(p,Comput(p,s,k))
     = halt SCM+FSA by A34,A33,A37,A4,SCMFSA8A:4;
    hence thesis by A37,A42,EXTPRO_1:24;
  end;
end;

theorem Th36: :: based on SCMFSA_9:36
  I is_closed_on s,p & I is_halting_on s,p & s.a > 0 implies DataPart
  Comput(p +* while>0(a,I),(Initialize s),
  (LifeSpan(p +* I,Initialize s) + 3)) =
DataPart Comput(p +* I,(Initialize s),
 (LifeSpan(p +* I,Initialize s)))
proof
  assume that
A1: I is_closed_on s,p & I is_halting_on s,p and
A2: s.a > 0;
  set sI = Initialize s,
      pI = p +* I;
  set s1 = Initialize s,
      p1 = p +* while>0(a,I);
A3: while>0(a,I) c= p1 by FUNCT_4:26;
  defpred P[Nat] means $1 <= LifeSpan(pI,sI) implies IC Comput(
p1,s1,
  1+$1) = IC Comput(pI,sI,$1) + 4 &
  DataPart Comput(p1,s1,1+$1) = DataPart Comput(pI,sI,$1);
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    now
A6:   k + 0 < k + 1 by XREAL_1:8;
      assume k + 1 <= LifeSpan(pI,sI);
      then k < LifeSpan(pI,sI) by A6,XXREAL_0:2;
      hence IC Comput(p1,s1,1+k+1) = IC Comput(pI,sI,
k+1) + 4 & DataPart
Comput(p1,s1,1+k+1) = DataPart Comput(pI,sI,k+1) by A1,A5,SCMFSA_9:44;
    end;
    hence P[k + 1];
  end;
  set i = a >0_goto  4;
  set s2 = Comput(p1,s1,1),
      p2 = p1;
B7: IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
A8: IC s1 = IC Start-At(0,SCM+FSA) by B7,FUNCT_4:14
    .=  0 by COMPOS_1:64;
    Start-At(0,SCM+FSA) c= Initialize while>0(a,I) by FUNCT_4:26;
    then
U1: dom Start-At(0,SCM+FSA) c= dom Initialize while>0(a,I)
             by RELAT_1:25;
  not a in dom (Initialize while>0(a,I)) by SCMFSA6B:12;
  then not a in dom Start-At(0,SCM+FSA) by U1;
  then
A9: s1.a = s.a by FUNCT_4:12;
  set loc4 =  (card I + 4);
A10:  p1/.IC s1 = p1.IC s1 by PBOOLE:158;
  0 in dom while>0(a,I) by SCMFSA_9:10;
  then p1. 0 = while>0(a,I). 0
  by FUNCT_4:14
    .= i by SCMFSA_9:11;
  then
A11: CurInstr(p1,s1) = i by A8,A10;
A12: Comput(p1,s1,0+1) =
Following(p1,Comput(p1,s1,0)
)
 by EXTPRO_1:4
    .= Following(p1,s1) by EXTPRO_1:3
    .= Exec(i,s1) by A11;
  then ( for c being Int-Location holds s2.c = s1.c)& for f being
  FinSeq-Location holds s2.f = s1.f by SCMFSA_2:97;
  then
A13: DataPart s2 = DataPart s1 by SCMFSA6A:38
    .= DataPart sI;
A14: IC s2 =  4 by A2,A12,A9,SCMFSA_2:97;
A15: P[0]
  proof
    assume 0 <= LifeSpan(pI,sI);
B16: IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
    IC Comput(pI,sI,0) = IC sI by EXTPRO_1:3
      .= IC Start-At(0,SCM+FSA) by B16,FUNCT_4:14
      .=  0 by COMPOS_1:64;
    hence thesis by A14,A13,EXTPRO_1:3;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A15,A4);
  then
A17: P[LifeSpan(pI,sI) qua Element of NAT];
  set s4=Comput(p1,s1,1+LifeSpan(pI,sI)+1+1),
      p4 = p1;
  set s3 = Comput(p1,s1,1+LifeSpan(pI,sI)+1),
      p3 = p1;
A18: loc4 in dom while>0(a,I) by SCMFSA_9:38;
  set s2 = Comput(p1,s1,1+LifeSpan(pI,sI));
A19: CurInstr(p2,s2) = goto loc4 by A1,A17,SCMFSA_9:45;
A20: s3 = Following(p1,s2) by EXTPRO_1:4
    .= Exec(goto loc4,s2) by A19;
  then
A21: ( for c being Int-Location holds s3.c = s2.c)& for f being
  FinSeq-Location holds s3.f = s2.f by SCMFSA_2:95;
A22: p3.loc4 = while>0(a,I).loc4 by A18,A3,GRFUNC_1:8
    .= goto  0 by SCMFSA_9:46;
A23:  p3/.IC s3 = p3.IC s3 by PBOOLE:158;
  IC s3 = loc4 by A20,SCMFSA_2:95;
  then
A24: CurInstr(p3,s3) = goto  0 by A22,A23;
  s4 = Following(p1,s3) by EXTPRO_1:4
    .= Exec(goto  0,s3) by A24;
  then ( for c being Int-Location holds s4.c = s3.c)& for f being
  FinSeq-Location holds s4.f = s3.f by SCMFSA_2:95;
  hence DataPart Comput(p1,s1,LifeSpan(pI,sI)+3) =
DataPart s3 by SCMFSA6A:38
    .= DataPart Comput(pI,sI,LifeSpan(pI,sI)) by A17,A21,SCMFSA6A:38;
end;

theorem Th37: :: Step_gt0_0:
  (StepWhile>0(a,I,p,s).k).a <= 0 implies
   DataPart StepWhile>0(a,I,p,s).(k+1) = DataPart StepWhile>0(a,I,p,s).k
proof
  assume
A1: (StepWhile>0(a,I,p,s).k).a <= 0;
  set SW = StepWhile>0(a,I,p,s),
      PW = p +* while>0(a,I);
A2:  PW +* while>0(a,I) = PW by FUNCT_4:99;
A3: while>0(a,I) c= PW by FUNCT_4:26;
A4: Start-At(0,SCM+FSA) c= Initialize(SW.k)
by FUNCT_4:26;
A5: DataPart(Initialize(SW.k)) = DataPart SW.k
by SCMFSA8A:10;
  then
A6: SW.k.a = (Initialize(SW.k)).a by SCMFSA6A:38;
  thus DataPart SW.(k+1) = DataPart Comput(PW +* while>0(a,I),
     (Initialize(SW.k)
  ), (LifeSpan(PW +* I,Initialize(SW.k)) + 3)) by A2,SCMFSA_9:def 5
    .= DataPart StepWhile>0(a,I,p,s).k by A1,A5,A6,A4,Th35,A2,A3;
end;

theorem Th38: :: Step_gt0_1:
  ( I is_halting_on Initialized StepWhile>0(a,I,p,s).k ,p+*while>0(a,I) & I
  is_closed_on Initialized StepWhile>0(a,I,p,s).k ,p+*while>0(a,I) or
  I is parahalting) & (
  StepWhile>0(a,I,p,s).k).a > 0 & (StepWhile>0(a,I,p,s).k).intloc 0 = 1 implies
DataPart StepWhile>0(a,I,p,s).(k+1)
 = DataPart IExec(I,p+*while>0(a,I),StepWhile>0(a,I,p,s).k)
proof
  set Ins = NAT;
  assume that
A1: I is_halting_on Initialized StepWhile>0(a,I,p,s).k ,p+*while>0(a,I) &
   I is_closed_on Initialized StepWhile>0(a,I,p,s).k ,p+*while>0(a,I) or
   I is parahalting and
A2: (StepWhile>0(a,I,p,s).k).a > 0 and
A3: (StepWhile>0(a,I,p,s).k).intloc 0 = 1;
  set ISWk = Initialized StepWhile>0(a,I,p,s).k;
  set SW = StepWhile>0(a,I,p,s),
      PW = p +* while>0(a,I);
  set SWkI = SW.k+*Initialize((intloc 0).-->1),
      PWI = p +* while>0(a,I) +* I;
A5:  PW +* while>0(a,I) = PW by FUNCT_4:99;
  DataPart ISWk = DataPart SW.k by A3,SCMFSA8C:27;
  then
A6: I is_closed_on SW.k ,PW & I is_halting_on SW.k ,PW
    by A1,SCMFSA7B:24,25,SCMFSA8B:8;
  I is_halting_on ISWk ,PW by A1,SCMFSA7B:25;
  then
A7: I is_halting_on Initialized SW.k ,PW;
XX: Start-At(0,SCM+FSA) c= Initialized SW.k by SCMFSA6B:4;
 SW.k +*Initialize((intloc 0).-->1)
         = SW.k +*Initialize((intloc 0).-->1)
        .= Initialized SW.k
        .= Initialize Initialized(SW.k) by XX,FUNCT_4:104;
    then
A9:  PW +* I halts_on SW.k+*(Initialize((intloc 0).-->1))
    by A7,SCMFSA7B:def 8;
A10: PWI halts_on SWkI by A9;
A11:  dom(SW.k | Ins) c= NAT by RELAT_1:87;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A12: dom(SW.k | Ins) misses D by A11,XBOOLE_1:63;
  set IS = Initialize I;
  set SWkIS = Initialize(SW.k),
          PWIS = PW +* I;
A13: SWkI = SWkIS by A3,SCMFSA8C:18;
  set WHS = Initialize while>0(a, I);
A14: SW.(k+1)
  = Comput(PW +* while>0(a,I),
  (Initialize(SW.k)),LifeSpan(PWIS,SWkIS)+ 3)
   by A5,SCMFSA_9:def 5;
A15: DataPart IExec(I,PW,SW.k)
     = DataPart(Result(PWI,SWkI) +* SW.k | Ins) by SCMFSA6B:def 1
    .= DataPart Result(PWI,SWkI) by A12,FUNCT_4:76,SCMFSA_2:127
    .= DataPart Comput(PWIS,SWkIS,LifeSpan(PWIS,SWkIS)) by A13,A10,EXTPRO_1:23;
  thus :::thesis
  DataPart StepWhile>0(a,I,p,s).(k+1)
   = DataPart Comput(PWIS,SWkIS,LifeSpan(PWIS,SWkIS))
  by A2,A6,Th36,A14
   .= DataPart IExec(I,PW,StepWhile>0(a,I,p,s).k) by A15;
end;

theorem Th39: :: GoodStep0:
  (ProperBodyWhile>0 a,Ig,s,p or Ig is parahalting) & s.intloc 0 =
  1 implies for k holds StepWhile>0(a,Ig,p,s).k.intloc 0 = 1
proof
  set I = Ig;
  assume that
A1: ProperBodyWhile>0 a,I,s,p or I is parahalting and
A2: s.intloc 0 = 1;
  set SW = StepWhile>0(a,I,p,s),
      PW = p +* while>0(a,I);
  defpred X[Nat] means SW.$1.intloc 0 = 1;
A4: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT such that
A5: SW.k.intloc 0 = 1;
    per cases;
    suppose
      SW.k.a <= 0;
      then DataPart SW.(k+1) = DataPart SW.k by Th37;
      hence thesis by A5,SCMFSA6A:38;
    end;
    suppose
A6:   SW.k.a > 0;
      set SWkI = SW.k+*Initialize((intloc 0).-->1),
      PWI = p +* while>0(a,I) +* I;
      set ISWk = Initialized StepWhile>0(a,I,p,s).k;
A7:   DataPart SW.k = DataPart ISWk by A5,SCMFSA8C:27;
      set Ins = NAT;
      set SWkIS = Initialize(SW.k),
          PWIS = PW +* I;
A8:  dom(SW.k | Ins) c= NAT by RELAT_1:87;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A9: dom(SW.k | Ins) misses D by A8,XBOOLE_1:63;
A10:   SWkI = SWkIS by A5,SCMFSA8C:18;
A11:   ProperBodyWhile>0 a,I,s,p by A1,Th32;
      then
A12:  I is_closed_on SW.k ,PW by A6,Def4;
      I is_halting_on SW.k ,PW by A6,A11,Def4;
      then
A14:  I is_halting_on Initialized SW.k ,PW by A12,A7,SCMFSA8B:8;
XX: Start-At(0,SCM+FSA) c= Initialized SW.k by SCMFSA6B:4;
 SW.k +*Initialize((intloc 0).-->1)
         = SW.k +*Initialize((intloc 0).-->1)
        .= Initialized SW.k
        .= Initialize Initialized(SW.k) by XX,FUNCT_4:104;
    then
B15:  PW +* I halts_on SW.k+*(Initialize((intloc 0).-->1))
       by A14,SCMFSA7B:def 8;
A16:  PWI halts_on SWkI by B15;
A17:  DataPart IExec(I,PW,SW.k) = DataPart(Result(PWI,SWkI) +* SW.k
| Ins) by SCMFSA6B:def 1
        .= DataPart Result(PWI,SWkI) by A9,FUNCT_4:76,SCMFSA_2:127
        .= DataPart Comput(PWIS,SWkIS,LifeSpan(PWIS,SWkIS))
         by A10,A16,EXTPRO_1:23;
      I is_closed_on Initialized SW.k ,PW by A12,A7,SCMFSA8B:6;
      then DataPart SW.(k+1) = DataPart IExec(I,PW,SW.k) by A5,A6,A14,Th38;
      hence
      SW.(k+1).intloc 0 = (Comput(PWIS,SWkIS,LifeSpan(PWIS,SWkIS))).intloc 0
            by A17,SCMFSA6A:38
        .= 1 by A5,A12,SCMFSA8C:97;
    end;
  end;
A18: X[0] by A2,SCMFSA_9:def 5;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A18,A4);
end;

theorem Th40:
  ProperBodyWhile>0 a,I,s1,p1 & DataPart s1 = DataPart s2 implies
for k holds DataPart StepWhile>0(a,I,p1,s1).k
 = DataPart StepWhile>0(a,I,p2,s2).k
proof
  assume that
A1: ProperBodyWhile>0 a,I,s1,p1 and
A2: DataPart s1 = DataPart s2;
  set WH = while>0(a,I);
  set ST2 = StepWhile>0(a,I,p2,s2),
      PT2 = p2 +* while>0(a,I);
  set ST1 = StepWhile>0(a,I,p1,s1),
      PT1 = p1 +* while>0(a,I);
A3:  PT2 +* while>0(a,I) = PT2 by FUNCT_4:99;
A4:  PT1 +* while>0(a,I) = PT1 by FUNCT_4:99;
  defpred X[Nat] means DataPart ST1.$1 = DataPart ST2.$1;
A5: for k st X[k] holds X[k+1]
  proof
    let k;
    set ST1kI = Initialize(ST1.k),
        PT1I = PT1 +* I;
    set ST2kI = Initialize(ST2.k),
        PT2I = PT2 +* I;
A6: I c= PT1I by FUNCT_4:26;
A7: I c= PT2I by FUNCT_4:26;
    assume
A8: DataPart ST1.k = DataPart ST2.k;
    then
A9: ST1.k.a = ST2.k.a by SCMFSA6A:38;
    per cases;
    suppose
A10:   ST1.k.a <= 0;
      hence DataPart ST1.(k+1) = DataPart ST1.k by Th37
        .= DataPart ST2.(k+1) by A8,A9,A10,Th37;
    end;
    suppose
A11:   ST1.k.a > 0;
      then
A12:   I is_closed_on ST1.k, PT1 by A1,Def4;
A13:   I is_halting_on ST1.k, PT1 by A1,A11,Def4;
      then
A14:  I is_closed_on ST2.k, PT2 & I is_halting_on ST2.k, PT2
         by A8,A12,SCMFSA8B:8;
A15:  DataPart ST1.(k+1) = DataPart Comput(PT1 +* while>0(a,I),
(Initialize(ST1.k)), (
      LifeSpan(PT1I,ST1kI) + 3)) by A4,SCMFSA_9:def 5
        .= DataPart Comput(PT1I,(ST1kI),
        LifeSpan(PT1I,ST1kI)) by A11,A12,A13,Th36;
A16:  DataPart ST2.(k+1) = DataPart Comput(PT2 +* while>0(a,I),
(Initialize(ST2.k)), (
      LifeSpan(PT2I,ST2kI) + 3)) by A3,SCMFSA_9:def 5
        .= DataPart Comput(PT2I,(ST2kI),
         LifeSpan(PT2I,ST2kI)) by A9,A11,A14,Th36;
A17:  Start-At(0,SCM+FSA) c= ST1kI & Start-At(0,SCM+FSA) c= ST2kI
 by FUNCT_4:26;
A18:  DataPart ST1.k = DataPart ST1kI by SCMFSA8A:10;
      then
A19:  I is_closed_on ST1kI, PT1I by A12,SCMFSA8B:6;
A20:  DataPart ST1kI = DataPart ST1.k by SCMFSA8A:10
        .= DataPart ST2kI by A8,SCMFSA8A:10;
      I is_halting_on ST1kI, PT1I by A12,A13,A18,SCMFSA8B:8;
      then (LifeSpan(PT1I,ST1kI)) = (LifeSpan(PT2I,
ST2kI)) by A12,A20,A17,A18,A6,A7,SCMFSA8B:6,SCMFSA8C:44;
      hence thesis by A15,A16,A20,A17,A19,A6,A7,SCMFSA8C:43;
    end;
  end;
  DataPart ST1.0 = DataPart s1 by SCMFSA_9:def 5
    .= DataPart ST2.0 by A2,SCMFSA_9:def 5;
  then
A21: X[0];
  thus for k holds X[k] from NAT_1:sch 1(A21, A5);
end;

definition let p;
  let s be State of SCM+FSA, a be read-write Int-Location, I be Program of
  SCM+FSA;
  assume that
A1: ProperBodyWhile>0 a,I,s,p or I is parahalting and
A2: WithVariantWhile>0 a,I,s,p;
  func ExitsAtWhile>0(a, I, p, s) -> Element of NAT means
  :Def6:
  ex k being Element of NAT st it = k &
    (StepWhile>0(a,I,p,s).k).a <= 0 &
    (for i being Element of NAT st (StepWhile>0(a,I,p,s).i).a <= 0
     holds k <= i) &
    DataPart Comput(p +* while>0(a, I),
        Initialize s,
       (LifeSpan(p +* while>0(a, I),
        Initialize s)))
     = DataPart StepWhile>0(a,I,p,s).k;
  existence
  proof
    set S = Initialize s,
        P = p +* while>0(a, I);
    set SW = StepWhile>0(a,I,p,s),
      PW = p +* while>0(a,I);
A4: while>0(a,I) c= PW by FUNCT_4:26;
A5:  PW +* while>0(a,I) = PW by FUNCT_4:99;
    defpred X[Nat] means SW.$1.a <= 0;
A6: Start-At(0,SCM+FSA) c= S by FUNCT_4:26;
    consider f being Function of product the Object-Kind of SCM+FSA, NAT such
    that
A7: for k being Element of NAT holds f.(SW.(k+1))<f.(SW.k) or X[k] by A2,Def5;
    deffunc U(Nat) = f.(SW.$1);
A8: for k being Element of NAT holds U(k+1)<U(k) or X[k] by A7;
    consider m such that
A9: X[m] and
A10: for n st X[n] holds m <= n from NAT_1:sch 18(A8);
    take m, m;
    thus m = m;
    thus SW.m.a <= 0 by A9;
    thus for n st SW.n.a <= 0 holds m <= n by A10;
    defpred P[Nat] means $1+1 <= m implies
     ex k st StepWhile>0(a,I,p,s).($1+1)=Comput(P,S,k);
A11: ProperBodyWhile>0 a,I,s,p by A1,Th32;
A12: now
      let k be Element of NAT;
      assume
A13:  P[k];
      now
        set sk1=StepWhile>0(a,I,p,s).(k+1);
        set sk=StepWhile>0(a,I,p,s).k,
          pk = p +* while>0(a,I);
        assume
A14:    (k+1)+ 1 <= m;
        k + 0 < k+ (1+ 1) by XREAL_1:8;
        then k < m by A14,XXREAL_0:2;
        then
A15:    sk.a > 0 by A10;
        (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
        then consider n being Element of NAT such that
A16:    sk1 = Comput(P,S,n) by A13,A14,XXREAL_0:2;
A17:    sk1 = Comput(pk +* while>0(a,I),(Initialize sk),
        (LifeSpan(pk +* I,Initialize sk) + 3)) by A5,SCMFSA_9:def 5;
        take m=n +(LifeSpan(pk +* I,Initialize sk1) +
3);
        I is_closed_on sk,pk & I is_halting_on sk,pk by A11,A15,Def4;
        then IC sk1 = 0 by A17,A15,SCMFSA_9:47;
        hence StepWhile>0(a,I,p,s).((k+1)+1)=Comput(P,S,m) by A16,SCMFSA_9:52;
      end;
      hence P[k+1];
    end;
B18: IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
A19: P[0]
    proof
      assume 0+1 <= m;
      take n=(LifeSpan(p +*while>0(a,I) +* I,Initialize s) + 3);
      thus thesis by SCMFSA_9:51;
    end;
A20: for k being Element of NAT holds P[k] from NAT_1:sch 1(A19,A12);
    per cases;
    suppose
A21:  m = 0;
A22:  DataPart S = DataPart s by SCMFSA8A:10
        .= DataPart SW.m by A21,SCMFSA_9:def 5;
      then S.a = SW.m.a by SCMFSA6A:38;
      hence thesis by A9,A6,A22,Th35,A4;
    end;
    suppose
A23:  m <> 0;
      set sm = StepWhile>0(a,I,p,s).m,
          pm = p +* while>0(a,I);
      set sm1 = Initialize sm,
          pm1 = pm +* while>0(a,I);
      consider i being Nat such that
A24:  m=i+1 by A23,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      set si = StepWhile>0(a,I,p,s).i,
          psi = p +* while>0(a,I);
A25:  sm = Comput(psi +* while>0(a,I),(Initialize si),
      (LifeSpan(psi +* I,Initialize si) + 3))
      by A24,A5,SCMFSA_9:def 5;
      m=i+1 by A24;
      then consider n being Element of NAT such that
A26:  sm = Comput(P,S,n) by A20;
      i < m by A24,NAT_1:13;
      then
A27:  si.a > 0 by A10;
      then I is_closed_on si,psi & I is_halting_on si,psi by A11,Def4;
      then
A28:  IC sm = 0 by A25,A27,SCMFSA_9:47;
A29:  IC sm1 = IC Start-At(0,SCM+FSA) by B18,FUNCT_4:14
        .= IC sm by A28,COMPOS_1:64;
A30:   ProgramPart sm = ProgramPart sm +* {} by FUNCT_4:22
      .= ProgramPart sm +*
             ProgramPart Start-At(0,SCM+FSA) by COMPOS_1:27
      .= ProgramPart(Initialize sm) by FUNCT_4:75;
      DataPart sm1 = DataPart sm by SCMFSA8A:10;
      then
A31:  sm1 = sm by A29,A30,SCMFSA_9:29;
      while>0(a,I) is_halting_on sm,pm by A9,SCMFSA_9:43;
      then pm1 halts_on sm1 by SCMFSA7B:def 8;
      then consider j being Element of NAT such that
A32:  CurInstr(pm,Comput(pm,sm,j))
 = halt SCM+FSA by A31,A5,EXTPRO_1:30;
A33: Comput(P,S,n+j)
 = Comput(P,Comput(P,S,n),j) by EXTPRO_1:5;
      CurInstr(P,Comput(P,S,n+j))
       = halt SCM+FSA by A26,A32,A33;
      then
A34:  Comput(P,S,LifeSpan(P,S)) = Comput(P,S,n+j) by EXTPRO_1:24
        .= Comput(P,sm,j) by A26,EXTPRO_1:5
        .= Comput(pm,sm,LifeSpan(pm,sm)) by A32,EXTPRO_1:24;
      Start-At(0,SCM+FSA) c= sm by A31,FUNCT_4:26;
      hence thesis by A9,A34,Th35,A4;
    end;
  end;
  uniqueness
  proof
    let it1, it2 be Element of NAT;
    given k1 being Element of NAT such that
A35: it1 = k1 and
A36: (StepWhile>0(a,I,p,s).k1).a <= 0 & for i being Element of NAT st
    ( StepWhile>0(a,I,p,s).i).a <= 0 holds k1 <= i and
    DataPart(Comput(p +* while>0(a,I),(Initialize s),
    (LifeSpan(p +* while>0(a,I),Initialize s)))) =
    DataPart StepWhile>0(a,I,p,s).k1;
    given k2 being Element of NAT such that
A37: it2 = k2 and
A38: (StepWhile>0(a,I,p,s).k2).a <= 0 & for i being Element of NAT st
    ( StepWhile>0(a,I,p,s).i).a <= 0 holds k2 <= i and
    DataPart(Comput(p +* while>0(a,I),(Initialize s),
    (LifeSpan(p +* while>0(a,I),Initialize s))))
     = DataPart StepWhile>0(a,I,p,s).k2;
    k1 <= k2 & k2 <= k1 by A36,A38;
    hence thesis by A35,A37,XXREAL_0:1;
  end;
end;

theorem :: IE_while_le0:
  s.intloc 0 = 1 & s.a <= 0 implies DataPart IExec(while>0(a,I),p,s) =
  DataPart s
proof
  set Ins = NAT;
  assume that
A1: s.intloc 0 = 1 and
A2: s.a <= 0;
  set WH = while>0(a, I);
  set Is = Initialized s;
  set Ids = s +* Initialize((intloc 0).-->1),
      pds = p +* WH;
A3: while>0(a,I) c= pds by FUNCT_4:26;
A5: Ids = Initialize Is by SCMFSA8A:13;
  then
A6: Start-At(0,SCM+FSA) c= Ids by FUNCT_4:26;
  Is.a = s.a by SCMFSA6C:3;
  then WH is_halting_on Is,p by A2,SCMFSA_9:43;
  then
A7: pds halts_on Ids by A5,SCMFSA7B:def 8;
A8: Ids.a = Is.a
    .= s.a by SCMFSA6C:3;
A9:  dom(s | Ins) c= NAT by RELAT_1:87;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A10: dom(s | Ins) misses D by A9,XBOOLE_1:63;
  thus DataPart IExec(WH,p,s)
   = DataPart(Result(p +* WH,s
+*Initialize((intloc 0).-->1)) +* s | Ins)
  by SCMFSA6B:def 1
    .= DataPart(Result(p +* WH,s+*Initialize((intloc 0).-->1))) by A10,
FUNCT_4:76,SCMFSA_2:127
    .= DataPart Comput(pds,Ids,LifeSpan(pds,Ids)) by A7,EXTPRO_1:23
    .= DataPart Initialized s by A2,A8,A6,Th35,A3
    .= DataPart s by A1,SCMFSA8C:27;
end;

theorem Th42: :: IE_while_gt0:
  (ProperBodyWhile>0 a,I,Initialized s,p or I is parahalting) &
WithVariantWhile>0 a,I,Initialized s,p implies DataPart IExec(while>0(a,I),p,s)
  = DataPart
  StepWhile>0(a,I,p,Initialized s).ExitsAtWhile>0(a,I,p,Initialized s)
proof
  set Ins = NAT;
  set WH = while>0(a, I);
  set Ids = s +* Initialize((intloc 0).-->1),
      pds = p +* WH;
  set Is = Initialized s;
A2: Ids = Initialize Is by SCMFSA8A:13;
A3:  dom(s | Ins) c= NAT by RELAT_1:87;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A4: dom(s | Ins) misses D by A3,XBOOLE_1:63;
  assume
A5: ( ProperBodyWhile>0 a,I,Initialized s,p or I is parahalting)&
  WithVariantWhile>0 a,I,Initialized s,p;
  then
A6: ex k being Element of NAT st ExitsAtWhile>0(a,I,p,Is) = k &
 (StepWhile>0(a,I,p,Is).k).a <= 0 &
 ( for i being Element of NAT st ( StepWhile>0(a,I,p,Is).i)
.a <= 0 holds k <= i)& DataPart (Comput(p +* while>0(a,I),
  (Initialize Is), (
  LifeSpan(p +* while>0(a,I),Initialize Is))))
  = DataPart StepWhile>0(a,I,p,Is).k
  by Def6;
  WH is_halting_on Is,p by A5,Th33,Th34;
  then
A7: pds halts_on Ids by A2,SCMFSA7B:def 8;
  thus DataPart IExec(WH,p,s)
   = DataPart(Result(p +* WH,s+*Initialize((intloc 0).-->1)) +* s | Ins)
  by SCMFSA6B:def 1
    .= DataPart(Result(p +* WH,s+*Initialize((intloc 0).-->1))) by A4,
FUNCT_4:76,SCMFSA_2:127
    .= DataPart StepWhile>0(a,I,p,Is).ExitsAtWhile>0(a,I,p,Is) by A2,A7,A6,
EXTPRO_1:23;
end;

theorem Th43:
  StepWhile>0(a,I,p,s).k.a <= 0 implies for n being Element of NAT
st k <= n holds DataPart StepWhile>0(a,I,p,s).n = DataPart StepWhile>0(a,I,p,s)
  .k
proof
  set SW = StepWhile>0(a,I,p,s),
      PW = p +* while>0(a,I);
  defpred P[Nat] means k <= $1 implies DataPart SW.$1 = DataPart SW
  .k;
  assume
A1: StepWhile>0(a,I,p,s).k.a <= 0;
A2: now
    let n be Element of NAT such that
A3: P[n];
    thus P[n+1]
    proof
      assume
A4:   k <= n+1;
      per cases by A4,NAT_1:8;
      suppose
A5:     k <= n;
        then SW.n.a <= 0 by A1,A3,SCMFSA6A:38;
        hence thesis by A3,A5,Th37;
      end;
      suppose
        k = n+1;
        hence thesis;
      end;
    end;
  end;
A6: P[0];
  thus for n being Element of NAT holds P[n] from NAT_1:sch 1(A6, A2 );
end;

theorem
  DataPart s1 = DataPart s2 & ProperBodyWhile>0 a,I,s1,p1 implies
  ProperBodyWhile>0 a,I,s2,p2
proof
  assume that
A1: DataPart s1 = DataPart s2 and
A2: ProperBodyWhile>0 a,I,s1,p1;
  let k be Element of NAT such that
A3: StepWhile>0(a,I,p2,s2).k.a > 0;
A4: DataPart StepWhile>0(a,I,p2,s2).k
     = DataPart StepWhile>0(a,I,p1,s1).k by A1,A2,Th40;
  then StepWhile>0(a,I,p1,s1).k.a > 0 by A3,SCMFSA6A:38;
  then
  I is_closed_on StepWhile>0(a,I,p1,s1).k, p1+*while>0(a,I) &
  I is_halting_on StepWhile>0(a,I,p1,s1).k, p1+*while>0(a,I) by A2,Def4;
  hence thesis by A4,SCMFSA8B:8;
end;

Lm7: s.intloc 0 = 1 implies
 (I is_closed_on s,p iff I is_closed_on Initialized s,p)
proof
  assume s.intloc 0 = 1;
  then DataPart Initialized s = DataPart s by SCMFSA8C:27;
  hence thesis by SCMFSA8B:6;
end;

Lm8: s.intloc 0 = 1 implies ( I is_closed_on s,p & I is_halting_on s,p iff I
is_closed_on Initialized s,p & I is_halting_on Initialized s,p)

proof
  assume s.intloc 0 = 1;
  then DataPart Initialized s = DataPart s by SCMFSA8C:27;
  hence thesis by SCMFSA8B:8;
end;

theorem Th45:
  s.intloc 0 = 1 & ProperBodyWhile>0 a,Ig,s,p &
   WithVariantWhile>0 a, Ig, s, p
    implies for i, j st i <> j & i <= ExitsAtWhile>0(a,Ig,p,s) & j <=
ExitsAtWhile>0(a,Ig,p,s) holds StepWhile>0(a,Ig,p,s).i <> StepWhile>0(a,Ig,p,s)
  .j & DataPart StepWhile>0(a,Ig,p,s).i <> DataPart StepWhile>0(a,Ig,p,s).j
proof
  set I = Ig;
  assume that
A1: s.intloc 0 = 1 and
A2: ProperBodyWhile>0 a,I,s,p and
A3: WithVariantWhile>0 a,I,s,p;
  set SW = StepWhile>0(a,I,p,s),
      PW = p +* while>0(a,I);
  consider K being Element of NAT such that
A4: ExitsAtWhile>0(a,I,p,s) = K and
A5: SW.K.a <= 0 and
A6: for i being Element of NAT st SW.i.a <= 0 holds K <= i and
  DataPart Comput(p +* while>0(a,I),(Initialize s),
  (LifeSpan(p +* while>0(a,I),s +* (
  Start-At(0,SCM+FSA))))) = DataPart SW.K by A2,A3,Def6;
  consider f being Function of product the Object-Kind of SCM+FSA, NAT such
  that
A7: for k being Element of NAT holds f.(SW.(k+1)) < f.(SW.k) or SW.k.a
  <= 0 by A3,Def5;
A8: for i, j being Element of NAT st i < j & i <= K & j <= K holds DataPart
  SW.i <> DataPart SW.j
  proof
    let i, j be Element of NAT such that
A9: i < j and
    i <= K and
A10: j <= K;
    per cases by A10,XXREAL_0:1;
    suppose
A11:  j = K;
      assume DataPart SW.i = DataPart SW.j;
      then SW.i.a <= 0 by A5,A11,SCMFSA6A:38;
      hence contradiction by A6,A9,A11;
    end;
    suppose
A12:  j < K;
      defpred X[Nat] means j+$1 <= K implies DataPart SW.(i+$1) =
      DataPart SW.(j+$1);
A13:  for k being Element of NAT st X[k] holds X[k+1]
      proof
        let k be Element of NAT such that
A14:    j+k <= K implies DataPart SW.(i+k) = DataPart SW.(j+k) and
A15:    j+(k+1) <= K;
A16:    SW.(j+k).intloc 0 = 1 by A1,A2,Th39;
A17:    j+k < (j+k)+1 by XREAL_1:31;
        then
A18:    j+k < K by A15,XXREAL_0:2;
        then
A19:    SW.(j+k).a > 0 by A6;
        then
A20:    I is_closed_on SW.(j+k), PW by A2,Def4;
        then
A21:    I is_closed_on Initialized SW.(j+k), PW by A16,Lm7;
A22:    I is_halting_on SW.(j+k), PW by A2,A19,Def4;
        then
A23:    I is_halting_on Initialized SW.(j+k), PW by A16,A20,Lm8;
A24:    SW.(i+k).intloc 0 = 1 by A1,A2,Th39;
A25:    SW.(i+k).a > 0
        proof
          assume not thesis;
          then
A26:      K <= i+k by A6;
          i+k < j+k by A9,XREAL_1:8;
          hence contradiction by A18,A26,XXREAL_0:2;
        end;
        then
A27:    I is_closed_on SW.(i+k), PW by A2,Def4;
        then
A28:    I is_closed_on Initialized SW.(i+k), PW by A24,Lm7;
        I is_halting_on SW.(i+k),PW by A2,A25,Def4;
        then
A29:    I is_halting_on Initialized SW.(i+k),PW by A24,A27,Lm8;
        thus DataPart SW.(i+(k+1)) = DataPart SW.(i+k+1)
          .= DataPart IExec(I,PW,SW.(i+k)) by A24,A25,A28,A29,Th38
          .= DataPart IExec(I,PW,SW.(j+k))
           by A14,A15,A17,A16,A20,A22,SCMFSA8C:46,XXREAL_0:2
          .= DataPart SW.(j+k+1) by A16,A19,A21,A23,Th38
          .= DataPart SW.(j+(k+1));
      end;
      consider p being Element of NAT such that
A30:  K = j+p and
      1 <= p by A12,FINSEQ_4:99;
      assume DataPart SW.i = DataPart SW.j;
      then
A31:  X[0];
      for k being Element of NAT holds X[k] from NAT_1:sch 1(A31, A13);
      then DataPart SW.(i+p) = DataPart SW.K by A30;
      then
A32:  SW.(i+p).a <= 0 by A5,SCMFSA6A:38;
      i+p < K by A9,A30,XREAL_1:8;
      hence contradiction by A6,A32;
    end;
  end;
A33: for i, j being Element of NAT st i < j & i <= K & j <= K holds SW.i <>
  SW.j
  proof
    let i, j be Element of NAT;
    assume that
A34: i < j and
    i <= K and
A35: j <= K;
    defpred X[Nat] means i < $1 & $1 <= j implies f.(SW.$1) < f.(SW
    .i);
A36: i < K by A34,A35,XXREAL_0:2;
A37: for k being Element of NAT st X[k] holds X[k+1]
    proof
      let k be Element of NAT such that
A38:  i < k & k <= j implies f.(SW.k) < f.(SW.i) and
A39:  i < k+1 and
A40:  k+1 <= j;
A41:  i <= k by A39,NAT_1:13;
      per cases by A41,XXREAL_0:1;
      suppose
A42:    i = k;
        not SW.i.a <= 0 by A6,A36;
        hence thesis by A7,A42;
      end;
      suppose
A43:    i < k;
A44:    k < j by A40,NAT_1:13;
        now
          assume SW.k.a <= 0;
          then K <= k by A6;
          hence contradiction by A35,A44,XXREAL_0:2;
        end;
        then f.(SW.(k+1)) < f.(SW.k) by A7;
        hence thesis by A38,A40,A43,NAT_1:13,XXREAL_0:2;
      end;
    end;
    assume
A45: SW.i = SW.j;
A46: X[0];
    for k being Element of NAT holds X[k] from NAT_1:sch 1(A46, A37 );
    hence contradiction by A34,A45;
  end;
  given i, j being Element of NAT such that
A47: i <> j and
A48: i <= ExitsAtWhile>0(a,I,p,s) & j <= ExitsAtWhile>0(a,I,p,s) &( SW.i
  = SW. j or DataPart SW.i = DataPart SW.j);
  i < j or j < i by A47,XXREAL_0:1;
  hence contradiction by A4,A33,A8,A48;
end;

definition
  let f be Function of product the Object-Kind of SCM+FSA, NAT;
  attr f is on_data_only means
  :Def7:
  for s1, s2 st DataPart s1 = DataPart s2
  holds f.s1 = f.s2;
end;

theorem Th46:
  s.intloc 0 = 1 & ProperBodyWhile>0 a,Ig,s,p &
   WithVariantWhile>0 a, Ig, s, p
    implies ex f being Function of product the Object-Kind of SCM+FSA, NAT
st f is on_data_only & for k being Element of NAT
 holds f.(StepWhile>0(a,Ig,p,s).(k+1)) < f.(StepWhile>0(a,Ig,p,s).k) or
 StepWhile>0(a,Ig,p,s).k.a <= 0
proof
  set I = Ig;
  assume that
A1: s.intloc 0 = 1 and
A2: ProperBodyWhile>0 a,I,s,p and
A3: WithVariantWhile>0 a,I,s,p;
  set SW = StepWhile>0(a,I,p,s),
      PW = p +* while>0(a,I);
  consider K being Element of NAT such that
A4: ExitsAtWhile>0(a,I,p,s) = K and
A5: SW.K.a <= 0 and
  for i being Element of NAT st SW.i.a <= 0 holds K <= i and
  DataPart Comput(p +* while>0(a,I),(Initialize s),
  (LifeSpan(p +* while>0(a,I),Initialize s)))
   = DataPart StepWhile>0(a,I,p,s).K by A2,A3,Def6;
  consider g being Function of product the Object-Kind of SCM+FSA, NAT such
  that
A6: for k being Element of NAT holds g.(SW.(k+1)) < g.(SW.k) or SW.k.a
  <= 0 by A3,Def5;
  defpred P[State of SCM+FSA, set] means (ex k being Element of NAT st k <= K
  & DataPart $1 = DataPart SW.k & $2 = g.(SW.k)) or not (ex k being Element of
  NAT st k <= K & DataPart $1 = DataPart SW.k) & $2 = 0;
A7: for x being Element of product the Object-Kind of SCM+FSA
 ex y being Element of NAT st P[x,y]
  proof
    let x be  Element of product the Object-Kind of SCM+FSA;
    per cases;
    suppose
      ex k being Element of NAT st k <= K & DataPart x = DataPart SW.k;
      then consider k being Element of NAT such that
A8:   k <= K & DataPart x = DataPart SW.k;
      take g.(SW.k);
      thus thesis by A8;
    end;
    suppose
A9:   not ex k being Element of NAT st k <= K & DataPart x = DataPart
      SW.k;
      take 0;
      thus thesis by A9;
    end;
  end;
  consider f being Function of product the Object-Kind of SCM+FSA, NAT such
  that
A10: for x being Element of product the Object-Kind of SCM+FSA
 holds P[x,f.x]
 from FUNCT_2:sch 3(A7);
  take f;
  hereby
    let s1, s2 such that
A11: DataPart s1 = DataPart s2;
     reconsider ss1=s1, ss2=s2 as
      Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
    ( P[ss1, f.ss1])& P[ss2, f.ss2] by A10;
    hence f.s1 = f.s2 by A1,A2,A3,A4,A11,Th45;
  end;
  let k be Element of NAT;
  per cases;
  suppose
A12: k < K;
    then
A13: k+1 <= K by NAT_1:13;
    then consider kk1 being Element of NAT such that
A14: kk1 <= K & DataPart SW.(k+1) = DataPart SW.kk1 and
A15: f.(SW.(k+1))=g.(SW.kk1) by A10;
A16: k+1 = kk1 by A1,A2,A3,A4,A13,A14,Th45;
    consider kk being Element of NAT such that
A17: kk <= K & DataPart SW.k = DataPart SW.kk and
A18: f.(SW.k) = g.(SW.kk) by A10,A12;
    k = kk by A1,A2,A3,A4,A12,A17,Th45;
    hence thesis by A6,A18,A15,A16;
  end;
  suppose
    K <= k;
    then DataPart SW.K = DataPart SW.k by A5,Th43;
    hence thesis by A5,SCMFSA6A:38;
  end;
end;

theorem
  s1.intloc 0 = 1 & DataPart s1 = DataPart s2 &
   ProperBodyWhile>0 a,Ig,s1,p1 & WithVariantWhile>0 a,Ig,s1,p1
    implies WithVariantWhile>0 a,Ig,s2,p2
proof
  set I = Ig;
  assume that
A1: s1.intloc 0 = 1 and
A2: DataPart s1 = DataPart s2 and
A3: ProperBodyWhile>0 a,I,s1,p1 and
A4: WithVariantWhile>0 a,I,s1,p1;
  set SW1 = StepWhile>0(a,I,p1,s1);
  consider f being Function of product the Object-Kind of SCM+FSA, NAT such
  that
A5: f is on_data_only and
A6: for k being Element of NAT holds (f.(SW1.(k+1)) < f.(SW1.k) or SW1.k
  .a <= 0 ) by A1,A3,A4,Th46;
  take f;
  let k be Element of NAT;
  set SW2 = StepWhile>0(a,I,p2,s2);
  DataPart SW1.(k+1) = DataPart SW2.(k+1) by A2,A3,Th40;
  then
A7: f.(SW1.(k+1)) = f.(SW2.(k+1)) by A5,Def7;
A8: DataPart SW1.k = DataPart SW2.k by A2,A3,Th40;
  then
A9: SW1.k.a = SW2.k.a by SCMFSA6A:38;
  f.(SW1.k) = f.(SW2.k) by A5,A8,Def7;
  hence thesis by A6,A9,A7;
end;

begin :: fusc using while>0, bottom-up

definition
  let N, result be Int-Location;
  func Fusc_macro ( N, result ) -> Program of SCM+FSA equals
  SubFrom(result,
  result) ';' ((1-stRWNotIn {N, result}) := intloc 0) ';' ((2-ndRWNotIn {N,
result}) := N) ';' while>0 ( 2-ndRWNotIn {N, result}, (3-rdRWNotIn {N, result})
:= 2 ';' Divide(2-ndRWNotIn {N, result}, 3-rdRWNotIn {N, result}) ';' if=0 ( 3
  -rdRWNotIn {N, result}, Macro AddTo(1-stRWNotIn {N, result}, result), Macro
  AddTo(result, 1-stRWNotIn {N, result}) ) );
  correctness;
end;
:: set next = 1-stRWNotIn {N, result};
:: set aux  = 2-ndRWNotIn {N, result};
:: set rem2 = 3-rdRWNotIn {N, result};
:: while and if do not allocate memory, no need to save anything

theorem
  for N, result being read-write Int-Location st N <> result for n being
Element of NAT st n = s.N
 holds IExec(Fusc_macro(N,result),p,s).result = Fusc n
  & IExec(Fusc_macro(N,result),p,s).N = n
proof
  let N, result be read-write Int-Location such that
A1: N <> result;
  set i0 = SubFrom(result, result);
  set rem2 = 3-rdRWNotIn {N, result};
  set aux = 2-ndRWNotIn {N, result};
  set next = 1-stRWNotIn {N, result};
  set I3i0 = rem2 := 2;
  set I3i1 = Divide(aux, rem2);
  set I3I2I0 = Macro AddTo(next, result);
  set I3I2I1 = Macro AddTo(result, next);
  set I3I2 = if=0 ( rem2, I3I2I0, I3I2I1 );
  set I = I3i0 ';' I3i1 ';' I3I2;
  let n be Element of NAT such that
A2: n = s.N;
A3: next <> rem2 by SFMASTR1:22;
A4: aux <> next by SFMASTR1:22;
  set I3 = while>0 ( aux, I );
  deffunc U(Element of product the Object-Kind of SCM+FSA) = abs($1.aux);
  set i2 = aux := N;
  set i1 = next := intloc 0;
  set t = IExec(i0 ';' i1 ';' i2,p,s),
      q = p;
  set It = Initialized t;
  set SWt = StepWhile>0(aux,I,q,It),
      PWt = q +* while>0(aux,I);
  defpred X[Nat] means ex au, ne, re being Element of NAT st SWt.$1
.aux = au & SWt.$1.next = ne & SWt.$1.result = re & SWt.$1.N = n & Fusc n = ne
  * Fusc au + re * Fusc (au+1);
  consider f being Function of product the Object-Kind of SCM+FSA,NAT such
  that
A5: for x being Element of product the Object-Kind of SCM+FSA holds f.x
  = U(x) from FUNCT_2:sch 4;
A6: N in {N, result} by TARSKI:def 2;
  then
A7: N <> next by SFMASTR1:21;
A8: result in {N, result} by TARSKI:def 2;
  then
A9: aux <> result by SFMASTR1:21;
A10: result <> rem2 by A8,SFMASTR1:21;
A11: next <> result by A8,SFMASTR1:21;
A12: N <> rem2 by A6,SFMASTR1:21;
A13: N <> aux by A6,SFMASTR1:21;
A14: aux <> rem2 by SFMASTR1:22;
A15: for u being State of SCM+FSA,h st
 ex au, ne, re being Element of NAT st u
.aux = au & u.next = ne & u.result = re & u.N = n & Fusc n = ne * Fusc au + re
* Fusc (au+1) ex au1, ne1, re1 being Element of NAT
 st IExec(I,h,u).aux = au1 &
IExec(I,h,u).next = ne1 & IExec(I,h,u).result = re1 & IExec(I,h,u).N = n &
Fusc n
  = ne1 * Fusc au1 + re1 * Fusc (au1+1) & au1 = u.aux div 2
  proof
    let u be State of SCM+FSA, h;
    given au, ne, re being Element of NAT such that
A16: u.aux = au and
A17: u.next = ne and
A18: u.result = re and
A19: u.N = n and
A20: Fusc n = ne * Fusc au + re * Fusc (au+1);
A21: (Initialized IExec(I3i0 ';' I3i1,h,u)).next = IExec(I3i0 ';' I3i1,h,u).
    next by SCMFSA6C:3
      .= Exec(I3i1, IExec(I3i0,h,u)).next by SCMFSA6C:7
      .= IExec(I3i0,h,u).next by A4,A3,SCMFSA_2:93
      .= ne by A17,SCMFSA7B:9,SFMASTR1:22;
A22: (Initialized IExec(I3i0 ';' I3i1,h,u)).aux = IExec(I3i0 ';' I3i1,h,u).
    aux by SCMFSA6C:3
      .= Exec(I3i1, IExec(I3i0,h,u)).aux by SCMFSA6C:7
      .= IExec(I3i0,h,u).aux div IExec(I3i0,h,u).rem2 by A14,SCMFSA_2:93
      .= u.aux div IExec(I3i0,h,u).rem2 by SCMFSA7B:9,SFMASTR1:22
      .= u.aux div 2 by SCMFSA7B:9;
A23: (Initialized IExec(I3i0 ';' I3i1,h,u)).result = IExec(I3i0 ';' I3i1,h,u)
    .result by SCMFSA6C:3
      .= Exec(I3i1, IExec(I3i0,h,u)).result by SCMFSA6C:7
      .= IExec(I3i0,h,u).result by A9,A10,SCMFSA_2:93
      .= re by A10,A18,SCMFSA7B:9;
A24: (Initialized IExec(I3i0 ';' I3i1,h,u)).N = IExec(I3i0 ';' I3i1,h,u).N by
SCMFSA6C:3
      .= Exec(I3i1, IExec(I3i0,h,u)).N by SCMFSA6C:7
      .= IExec(I3i0,h,u).N by A12,A13,SCMFSA_2:93
      .= n by A12,A19,SCMFSA7B:9;
A25: IExec(I3i0 ';' I3i1,h,u).rem2 = Exec(I3i1, IExec(I3i0,h,u)).rem2 by
SCMFSA6C:7
      .= IExec(I3i0,h,u).aux mod IExec(I3i0,h,u).rem2 by SCMFSA_2:93
      .= u.aux mod IExec(I3i0,h,u).rem2 by SCMFSA7B:9,SFMASTR1:22
      .= u.aux mod 2 by SCMFSA7B:9;
    per cases;
    suppose
A26:  au is even;
      reconsider ne1 = ne + re as Element of NAT;
      reconsider au1 = u.aux div 2 as Element of NAT by A16,INT_1:16,82;
      take au1, ne1, re;
      consider k being Element of NAT such that
A27:  au = 2*k by A26,ABIAN:def 2;
A28:  u.aux mod 2 = (2*k + 0) mod 2 by A16,A27
        .= 0 mod 2 by NAT_D:21
        .= 0 by NAT_D:26;
      IExec(I,h,u).aux = IExec(I3I2,h,IExec(I3i0 ';' I3i1,h,u)).aux
       by SCMFSA6C:1
        .= IExec(I3I2I0,h,IExec(I3i0 ';' I3i1,h,u)).aux by A25,A28,SCMFSA8B:21
        .= (NPP IExec(I3I2I0,h,IExec(I3i0 ';' I3i1,h,u))).aux by SCMFSA6C:13
        .= (NPP Exec(AddTo(next, result),
                   Initialized IExec(I3i0 ';' I3i1,h,u))).aux
      by SCMFSA6C:6
        .= Exec(AddTo(next, result), Initialized IExec(I3i0 ';' I3i1,h,u)).aux
      by SCMFSA6C:13
        .= u.aux div 2 by A4,A22,SCMFSA_2:90;
      hence IExec(I,h,u).aux = au1;
      thus IExec(I,h,u).next = IExec(I3I2,h,IExec(I3i0 ';' I3i1,h,u)).next by
SCMFSA6C:1
        .= IExec(I3I2I0,h,IExec(I3i0 ';' I3i1,h,u)).next by A25,A28,SCMFSA8B:21
        .= (NPP IExec(I3I2I0,h,IExec(I3i0 ';' I3i1,h,u))).next by SCMFSA6C:13
        .= (NPP Exec(AddTo(next, result),
         Initialized IExec(I3i0 ';' I3i1,h,u))).next by SCMFSA6C:6
        .= Exec(AddTo(next, result), Initialized IExec(I3i0 ';' I3i1,h,u)).
      next by SCMFSA6C:13
        .= ne1 by A21,A23,SCMFSA_2:90;
      thus IExec(I,h,u).result = IExec(I3I2,h,IExec(I3i0 ';' I3i1,h,u)).result
       by SCMFSA6C:1
        .= IExec(I3I2I0,h,IExec(I3i0 ';' I3i1,h,u)).result
         by A25,A28,SCMFSA8B:21
        .= (NPP IExec(I3I2I0,h,IExec(I3i0 ';' I3i1,h,u))).result
         by SCMFSA6C:13
        .= (NPP Exec(AddTo(next, result),
             Initialized IExec(I3i0 ';' I3i1,h,u))).result by SCMFSA6C:6
        .= Exec(AddTo(next, result), Initialized IExec(I3i0 ';' I3i1,h,u)).
      result by SCMFSA6C:13
        .= re by A11,A23,SCMFSA_2:90;
      thus IExec(I,h,u).N = IExec(I3I2,h,IExec(I3i0 ';' I3i1,h,u)).N
       by SCMFSA6C:1
        .= IExec(I3I2I0,h,IExec(I3i0 ';' I3i1,h,u)).N by A25,A28,SCMFSA8B:21
        .= (NPP IExec(I3I2I0,h,IExec(I3i0 ';' I3i1,h,u))).N by SCMFSA6C:13
        .= (NPP Exec(AddTo(next, result),
        Initialized IExec(I3i0 ';' I3i1,h,u))).N
      by SCMFSA6C:6
        .= Exec(AddTo(next, result), Initialized IExec(I3i0 ';' I3i1,h,u)).N
      by SCMFSA6C:13
        .= n by A7,A24,SCMFSA_2:90;
      au1 = k by A16,A27,NAT_D:20;
      hence Fusc n = ne1 * Fusc au1 + re * Fusc (au1+1) by A20,A27,PRE_FF:22;
      thus thesis;
    end;
    suppose
A29:  au is odd;
      reconsider re1 = ne + re as Element of NAT;
      reconsider au1 = u.aux div 2 as Element of NAT by A16,INT_1:16,82;
      take au1, ne, re1;
      consider k being Element of NAT such that
A30:  au = 2*k +1 by A29,ABIAN:9;
A31:  u.aux mod 2 = 1 mod 2 by A16,A30,NAT_D:21
        .= 1 by NAT_D:24;
      IExec(I,h,u).aux = IExec(I3I2,h,IExec(I3i0 ';' I3i1,h,u)).aux
       by SCMFSA6C:1
        .= IExec(I3I2I1,h,IExec(I3i0 ';' I3i1,h,u)).aux by A25,A31,SCMFSA8B:21
        .= (NPP IExec(I3I2I1,h,IExec(I3i0 ';' I3i1,h,u))).aux by SCMFSA6C:13
        .= (NPP Exec(AddTo(result, next),
         Initialized IExec(I3i0 ';' I3i1,h,u))).aux
      by SCMFSA6C:6
        .= Exec(AddTo(result, next), Initialized IExec(I3i0 ';' I3i1,h,u)).aux
      by SCMFSA6C:13
        .= u.aux div 2 by A9,A22,SCMFSA_2:90;
      hence IExec(I,h,u).aux = au1;
      thus IExec(I,h,u).next = IExec(I3I2,h,IExec(I3i0 ';' I3i1,h,u)).next by
SCMFSA6C:1
        .= IExec(I3I2I1,h,IExec(I3i0 ';' I3i1,h,u)).next by A25,A31,SCMFSA8B:21
        .= (NPP IExec(I3I2I1,h,IExec(I3i0 ';' I3i1,h,u))).next by SCMFSA6C:13
        .= (NPP Exec(AddTo(result, next),
        Initialized IExec(I3i0 ';' I3i1,h,u))).
      next by SCMFSA6C:6
        .= Exec(AddTo(result, next), Initialized IExec(I3i0 ';' I3i1,h,u)).
      next by SCMFSA6C:13
        .= ne by A11,A21,SCMFSA_2:90;
      thus IExec(I,h,u).result
       = IExec(I3I2,h,IExec(I3i0 ';' I3i1,h,u)).result by SCMFSA6C:1
        .= IExec(I3I2I1,h,IExec(I3i0 ';' I3i1,h,u)).result
         by A25,A31,SCMFSA8B:21
        .= (NPP IExec(I3I2I1,h,IExec(I3i0 ';' I3i1,h,u))).result
         by SCMFSA6C:13
        .= (NPP Exec(AddTo(result, next),
        Initialized IExec(I3i0 ';' I3i1,h,u))).
      result by SCMFSA6C:6
        .= Exec(AddTo(result, next), Initialized IExec(I3i0 ';' I3i1,h,u)).
      result by SCMFSA6C:13
        .= re1 by A21,A23,SCMFSA_2:90;
      thus IExec(I,h,u).N = IExec(I3I2,h,IExec(I3i0 ';' I3i1,h,u)).N
       by SCMFSA6C:1
        .= IExec(I3I2I1,h,IExec(I3i0 ';' I3i1,h,u)).N by A25,A31,SCMFSA8B:21
        .= (NPP IExec(I3I2I1,h,IExec(I3i0 ';' I3i1,h,u))).N by SCMFSA6C:13
        .= (NPP Exec(AddTo(result, next),
        Initialized IExec(I3i0 ';' I3i1,h,u))).N
      by SCMFSA6C:6
        .= Exec(AddTo(result, next), Initialized IExec(I3i0 ';' I3i1,h,u)).N
      by SCMFSA6C:13
        .= n by A1,A24,SCMFSA_2:90;
      au1 = 2*k div 2 by A16,A30,NAT_2:28
        .= k by NAT_D:20;
      hence Fusc n = ne * Fusc au1 + re1 * Fusc (au1+1) by A20,A30,PRE_FF:21;
      thus thesis;
    end;
  end;
A32: It.intloc 0 = 1 by SCMFSA6C:3;
A33: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT;
    given au, ne, re being Element of NAT such that
A34: SWt.k.aux = au and
A35: SWt.k.next = ne and
A36: SWt.k.result = re and
A37: SWt.k.N = n and
A38: Fusc n = ne * Fusc au + re * Fusc (au+1);
A39: SWt.k.intloc 0 = 1 by A32,Th39;
    per cases;
    suppose
A40:  SWt.k.aux > 0;
      consider au1, ne1, re1 being Element of NAT such that
A41:  IExec(I,PWt,SWt.k).aux = au1 and
A42:  IExec(I,PWt,SWt.k).next = ne1 and
A43:  IExec(I,PWt,SWt.k).result = re1 and
A44:  IExec(I,PWt,SWt.k).N = n and
A45:  Fusc n = ne1 * Fusc au1 + re1 * Fusc (au1+1) and
      au1 = SWt.k.aux div 2 by A15,A34,A35,A36,A37,A38;
      take au1, ne1, re1;
A46:  DataPart SWt.(k+1) = DataPart IExec(I,PWt,SWt.k) by A39,A40,Th38;
      hence SWt.(k+1).aux = au1 by A41,SCMFSA6A:38;
      thus SWt.(k+1).next = ne1 by A46,A42,SCMFSA6A:38;
      thus SWt.(k+1).result = re1 by A46,A43,SCMFSA6A:38;
      thus SWt.(k+1).N = n by A46,A44,SCMFSA6A:38;
      thus thesis by A45;
    end;
    suppose
A47:  SWt.k.aux <= 0;
      take au, ne, re;
A48:  DataPart SWt.(k+1) = DataPart SWt.k by A47,Th37;
      hence SWt.(k+1).aux = au by A34,SCMFSA6A:38;
      thus SWt.(k+1).next = ne by A35,A48,SCMFSA6A:38;
      thus SWt.(k+1).result = re by A36,A48,SCMFSA6A:38;
      thus SWt.(k+1).N = n by A37,A48,SCMFSA6A:38;
      thus thesis by A38;
    end;
  end;
  t.intloc 0 = 1 by SCMFSA6B:35;
  then
A49: DataPart t = DataPart It by SCMFSA8C:27;
A50: X[0]
  proof
    take au = n;
    take ne = 1;
    take re = 0;
A51: SWt.0 = It by SCMFSA_9:def 5;
    hence SWt.0.aux = t.aux by A49,SCMFSA6A:38
      .= Exec(i2, IExec(i0 ';' i1,p,s)).aux by SCMFSA6C:7
      .= IExec(i0 ';' i1,p,s).N by SCMFSA_2:89
      .= Exec(i1, Exec(i0, Initialized s)).N by SCMFSA6C:9
      .= Exec(i0, Initialized s).N by A7,SCMFSA_2:89
      .= (Initialized s).N by A1,SCMFSA_2:91
      .= au by A2,SCMFSA6C:3;
    thus SWt.0.next = t.next by A49,A51,SCMFSA6A:38
      .= Exec(i2, IExec(i0 ';' i1,p,s)).next by SCMFSA6C:7
      .= IExec(i0 ';' i1,p,s).next by A4,SCMFSA_2:89
      .= Exec(i1, Exec(i0, Initialized s)).next by SCMFSA6C:9
      .= Exec(i0, Initialized s).intloc 0 by SCMFSA_2:89
      .= (Initialized s).intloc 0 by SCMFSA_2:91
      .= ne by SCMFSA6C:3;
    thus SWt.0.result = t.result by A49,A51,SCMFSA6A:38
      .= Exec(i2, IExec(i0 ';' i1,p,s)).result by SCMFSA6C:7
      .= IExec(i0 ';' i1,p,s).result by A9,SCMFSA_2:89
      .= Exec(i1, Exec(i0, Initialized s)).result by SCMFSA6C:9
      .= Exec(i0, Initialized s).result by A11,SCMFSA_2:89
      .= (Initialized s).result - (Initialized s).result by SCMFSA_2:91
      .= re;
    thus SWt.0.N = t.N by A49,A51,SCMFSA6A:38
      .= Exec(i2, IExec(i0 ';' i1,p,s)).N by SCMFSA6C:7
      .= IExec(i0 ';' i1,p,s).N by A13,SCMFSA_2:89
      .= Exec(i1, Exec(i0, Initialized s)).N by SCMFSA6C:9
      .= Exec(i0, Initialized s).N by A7,SCMFSA_2:89
      .= (Initialized s).N by A1,SCMFSA_2:91
      .= n by A2,SCMFSA6C:3;
    thus thesis;
  end;
A52: for k being Element of NAT holds X[k] from NAT_1:sch 1(A50, A33);
  for k being Element of NAT holds f.(SWt.(k+1)) < f.(SWt.k) or SWt.k.aux
  <= 0
  proof
    let k be Element of NAT;
    consider au, ne, re being Element of NAT such that
A53: SWt.k.aux = au and
A54: SWt.k.next = ne & SWt.k.result = re & SWt.k.N = n & Fusc n = ne *
    Fusc au + re * Fusc (au+1) by A52;
A55: f.(SWt.k) = abs(SWt.k.aux) by A5
      .= au by A53,ABSVALUE:def 1;
    now
      consider au1, ne1, re1 being Element of NAT such that
A56:  IExec(I,PWt,SWt.k).aux = au1 and
      IExec(I,PWt,SWt.k).next = ne1 and
      IExec(I,PWt,SWt.k).result = re1 and
      IExec(I,PWt,SWt.k).N = n and
      Fusc n = ne1 * Fusc au1 + re1 * Fusc (au1+1) and
A57:  au1 = SWt.k.aux div 2 by A15,A53,A54;
      assume
A58:  au > 0;
      SWt.k.intloc 0 = 1 by A32,Th39;
      then DataPart SWt.(k+1) = DataPart IExec(I,PWt,SWt.k) by A53,A58,Th38;
      then
A59:  SWt.(k+1).aux = au1 by A56,SCMFSA6A:38;
      f.(SWt.(k+1)) = abs(SWt.(k+1).aux) by A5
        .= au1 by A59,ABSVALUE:def 1;
      hence f.(SWt.(k+1)) < f.(SWt.k) by A53,A55,A58,A57,INT_1:83;
    end;
    hence thesis by A53;
  end;
  then
A60: WithVariantWhile>0 aux,I,It,q by Def5;
  then consider k being Element of NAT such that
A61: ExitsAtWhile>0(aux,I,q,It) = k and
A62: (StepWhile>0(aux,I,q,It).k).aux <= 0 and
  for i being Element of NAT st SWt.i.aux <= 0 holds k <= i and
  DataPart (Comput(q +* while>0(aux,I),(Initialize It),
   (LifeSpan(q +* while>0(aux,I),Initialize It))))
    = DataPart StepWhile>0(aux,I,q,It).k
  by Def6;
A63: DataPart IExec(I3,q,t) = DataPart SWt.k by A60,A61,Th42;
  consider au, ne, re being Element of NAT such that
A64: SWt.k.aux = au and
  SWt.k.next = ne and
A65: SWt.k.result = re and
A66: SWt.k.N = n and
A67: Fusc n = ne * Fusc au + re * Fusc (au+1) by A52;
A68: au = 0 by A62,A64;
  I3 is_closed_on It,q & I3 is_halting_on It,q by A60,Th34;
  then
A69: I3 is_closed_on t,q & I3 is_halting_on t,q by A49,SCMFSA8B:8;
  hence IExec(Fusc_macro(N,result),p,s).result = IExec(I3,q,t).result by
SFMASTR1:8
    .= Fusc n by A65,A67,A68,A63,PRE_FF:17,SCMFSA6A:38;
  thus IExec(Fusc_macro(N,result),p,s).N = IExec(I3,q,t).N by A69,SFMASTR1:8
    .= n by A66,A63,SCMFSA6A:38;
end;

