:: The { \bf while } macro instructions of SCM+FSA, Part { II }
::  by Piotr Rudnicki
::
:: Received June 3, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies AMI_3, INT_1, FUNCT_1, RELAT_1, MATRIX_2, ARYTM_1, NAT_1, AMI_1,
      SCMFSA_2, SCM_1, SF_MASTR, CAT_1, FINSUB_1, PROB_1, TARSKI, FUNCOP_1,
      BOOLE, SCMFSA8A, SCMFSA6A, SCMFSA7B, SCMFSA8B, CARD_1, FUNCT_4, AMI_5,
      RELOC, SCMFSA_9, UNIALG_2, CARD_3, SCMFSA6B, AMI_2, SCMFSA6C, SFMASTR1,
      PRE_FF, ABSVALUE, SCMFSA9A, ARYTM, AMISTD_2;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, FINSUB_1,
      FUNCOP_1, INT_1, NAT_1, ABIAN, RELAT_1, FUNCT_1, FUNCT_2, PRE_FF, CARD_3,
      AMI_1, SCMNORM, SCMFSA_2, SCMFSA_4, SCMFSA_5, SCMFSA6A, SCMFSA6B,
      SF_MASTR, SCMFSA6C, SCMFSA_7, SCMFSA7B, SCMFSA8A, SCMFSA8B, SCMFSA_9,
      SFMASTR1, INT_2, XXREAL_0;
 constructors XXREAL_0, NAT_1, NAT_D, SEQ_1, PRE_FF, ABIAN, SCMFSA_5, SCMFSA_7,
      SCMFSA6A, SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA_9, SFMASTR1,
      SCMNORM, SCMFSA_4, AFINSQ_1, RELSET_1, PRE_POLY;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FINSET_1,
      FINSUB_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, ABIAN,
      SCMFSA_2, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B,
      SCMFSA_9, SFMASTR1, SCMNORM, VALUED_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, SCMFSA_2, SCMFSA6A, AFINSQ_1, SCMNORM;
 theorems TARSKI, ZFMISC_1, ABSVALUE, NAT_1, INT_1, NAT_2, FUNCT_1, FUNCT_2,
      GRFUNC_1, FUNCOP_1, FUNCT_4, PRE_FF, ABIAN, FSM_1, AMI_1, SCMFSA_2,
      SCMFSA_4, SCMFSA_5, SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SCMFSA8B, SCMFSA8C, SCMFSA_9, SFMASTR1, RELAT_1, XBOOLE_0,
      XBOOLE_1, CARD_3, XREAL_1, XXREAL_0, ORDINAL1, NAT_D, VALUED_1;
 schemes FUNCT_2, NAT_1, SEQ_4;

begin :: SCM+FSA preliminaries

reserve k, n for Element of NAT,
  j for Integer;

reserve l for Instruction-Location of SCM+FSA,
  i for Instruction of SCM+FSA;

canceled 6;

theorem Th7: :: singleUsed
  UsedIntLoc (l .--> i) = UsedIntLoc i
proof
  set p = (l .--> i);
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc p = Union (UIL * p) by SF_MASTR:def 2;
A3: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
  thus UsedIntLoc p = union rng (UIL * ({l} --> i)) by A2,CARD_3:def 4
    .= union rng ({l} --> UIL.i) by A3,FUNCOP_1:23
    .= union {UIL.i} by FUNCOP_1:14
    .= union {UsedIntLoc i} by A1
    .= UsedIntLoc i by ZFMISC_1:31;
end;

theorem Th8: :: singleUsedF:
  UsedInt*Loc (l .--> i) = UsedInt*Loc i
proof
  set p = (l .--> i);
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc p = Union (UIL * p) by SF_MASTR:def 4;
A3: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
  thus UsedInt*Loc p = union rng (UIL * ({l} --> i)) by A2,CARD_3:def 4
    .= union rng ({l} --> UIL.i) by A3,FUNCOP_1:23
    .= union {UIL.i} by FUNCOP_1:14
    .= union {UsedInt*Loc i} by A1
    .= UsedInt*Loc i by ZFMISC_1:31;
end;

theorem Th9: :: StopUsed:
  UsedIntLoc Stop SCM+FSA = {}
proof
  Stop SCM+FSA = insloc 0 .--> halt SCM+FSA;
  hence thesis by Th7,SF_MASTR:17;
end;

theorem Th10: :: StopUsedF:
  UsedInt*Loc Stop SCM+FSA = {}
proof
  thus UsedInt*Loc Stop SCM+FSA = UsedInt*Loc(insloc 0 .--> halt SCM+FSA)
    .= UsedInt*Loc halt SCM+FSA by Th8
    .= {} by SF_MASTR:36;
end;

theorem Th11: :: GotoUsed:
  UsedIntLoc Goto l = {}
proof
  Goto l = insloc 0 .--> goto l by SCMFSA8A:def 2;
  hence UsedIntLoc Goto l = UsedIntLoc goto l by Th7
    .= {} by SF_MASTR:19;
end;

theorem Th12: :: GotoUsedF:
  UsedInt*Loc Goto l = {}
proof
  Goto l = insloc 0 .--> goto l by SCMFSA8A:def 2;
  hence UsedInt*Loc Goto l = UsedInt*Loc goto l by Th8
    .= {} by SF_MASTR:36;
end;

reserve s, s1, s2 for State of SCM+FSA,
  a for read-write Int-Location,
  b for
  Int-Location,
  I, J for Program of SCM+FSA,
  Ig for good Program of SCM+FSA,
  i, j
  , k, m, n for Element of NAT;
set D = Int-Locations \/ FinSeq-Locations;
set SAt = Start-At insloc 0;
set IL = NAT;

theorem Th13:
  UsedIntLoc if=0(b, I, J) = {b} \/ UsedIntLoc I \/ UsedIntLoc J
proof
  set I5 = Stop SCM+FSA;
  set a = b;
  set I1 = a =0_goto insloc (card J + 3);
  set I3 = Goto insloc (card I + 1);
  thus UsedIntLoc if=0(a, I, J) = UsedIntLoc (I1 ';' J ';' I3 ';' I ';' I5) by
  SCMFSA8B:def 1
    .= (UsedIntLoc (I1 ';' J ';' I3 ';' I)) \/ {} by Th9,SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J ';' I3)) \/ UsedIntLoc I by SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J)) \/ UsedIntLoc I3 \/ UsedIntLoc I by SF_MASTR:
  31
    .= (UsedIntLoc (I1 ';' J)) \/ {} \/ UsedIntLoc I by Th11
    .= UsedIntLoc I1 \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:33
    .= {a} \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:20
    .= {a} \/ UsedIntLoc I \/ UsedIntLoc J by XBOOLE_1:4;
end;

theorem Th14: :: eifUsedF:
  for a being Int-Location holds UsedInt*Loc if=0(a, I, J) =
  UsedInt*Loc I \/ UsedInt*Loc J
proof
  set I5 = Stop SCM+FSA;
  let a be Int-Location;
  set I1 = a =0_goto insloc (card J + 3);
  set I3 = Goto insloc (card I + 1);
  thus UsedInt*Loc if=0(a, I, J) = UsedInt*Loc (I1 ';' J ';' I3 ';' I ';' I5)
  by SCMFSA8B:def 1
    .= (UsedInt*Loc (I1 ';' J ';' I3 ';' I)) \/ {} by Th10,SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J ';' I3)) \/ UsedInt*Loc I by SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J)) \/ UsedInt*Loc I3 \/ UsedInt*Loc I by
  SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J)) \/ {} \/ UsedInt*Loc I by Th12
    .= UsedInt*Loc I1 \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:49
    .= {} \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:36
    .= UsedInt*Loc I \/ UsedInt*Loc J;
end;

theorem Th15: :: ifUsed:
  UsedIntLoc if>0(b, I, J) = {b} \/ UsedIntLoc I \/ UsedIntLoc J
proof
  set I5 = Stop SCM+FSA;
  set a = b;
  set I1 = a >0_goto insloc (card J + 3);
  set I3 = Goto insloc (card I + 1);
  thus UsedIntLoc if>0(a, I, J) = UsedIntLoc (I1 ';' J ';' I3 ';' I ';' I5) by
  SCMFSA8B:def 2
    .= (UsedIntLoc (I1 ';' J ';' I3 ';' I)) \/ {} by Th9,SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J ';' I3)) \/ UsedIntLoc I by SF_MASTR:31
    .= (UsedIntLoc (I1 ';' J)) \/ UsedIntLoc I3 \/ UsedIntLoc I by SF_MASTR:
  31
    .= (UsedIntLoc (I1 ';' J)) \/ {} \/ UsedIntLoc I by Th11
    .= UsedIntLoc I1 \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:33
    .= {a} \/ UsedIntLoc J \/ UsedIntLoc I by SF_MASTR:20
    .= {a} \/ UsedIntLoc I \/ UsedIntLoc J by XBOOLE_1:4;
end;

theorem Th16: :: ifUsedF:
  UsedInt*Loc if>0(b, I, J) = UsedInt*Loc I \/ UsedInt*Loc J
proof
  set I5 = Stop SCM+FSA;
  set a = b;
  set I1 = a >0_goto insloc (card J + 3);
  set I3 = Goto insloc (card I + 1);
  thus UsedInt*Loc if>0(a, I, J) = UsedInt*Loc (I1 ';' J ';' I3 ';' I ';' I5)
  by SCMFSA8B:def 2
    .= (UsedInt*Loc (I1 ';' J ';' I3 ';' I)) \/ {} by Th10,SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J ';' I3)) \/ UsedInt*Loc I by SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J)) \/ UsedInt*Loc I3 \/ UsedInt*Loc I by
  SF_MASTR:47
    .= (UsedInt*Loc (I1 ';' J)) \/ {} \/ UsedInt*Loc I by Th12
    .= UsedInt*Loc I1 \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:49
    .= {} \/ UsedInt*Loc J \/ UsedInt*Loc I by SF_MASTR:36
    .= UsedInt*Loc I \/ UsedInt*Loc J;
end;

begin :: while=0, general

Lm1: for a being Int-Location, I being Program of SCM+FSA holds card I +4 in
dom if=0(a,I ';' Goto insloc 0,Stop SCM+FSA) & if=0(a,I ';' Goto insloc 0,Stop
SCM+FSA).(card I +4) = goto ((insloc 0)+(card I +4))

proof
  set J = Stop SCM+FSA;
  set G = Goto insloc 0;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' G;
  set i = a =0_goto insloc (card J + 3);
  set c4 = card I + 4;
  set Lc4 = c4;
  set Mi= Macro i ';' J ';' Goto insloc (card I1 + 1) ';' I;
A1: card (G ';' J) = card G + card J by SCMFSA6A:61
    .= 1 + 1 by SCMFSA8A:17,29
    .= 2;

A2: if=0(a, I1, J) = i ';' J ';' Goto insloc (card I1 + 1) ';' (I ';' G) ';'
  J by SCMFSA8B:def 1

    .= Mi ';' G ';' J by SCMFSA6A:67
    .= Mi ';' (G ';' J) by SCMFSA6A:67;
  then card if=0(a, I1,J) = card Mi + card (G ';' J) by SCMFSA6A:61;
  then
A3: card Mi = card if=0(a,I1,J)-card (G ';' J)
    .= card I + 6 - 2 by A1,SCMFSA_9:1
    .= c4;
  then
A4: not Lc4 in dom Mi by SCMFSA6A:15;
  set GJ = G ';' J;
A5: InsCode goto insloc 0 = 6 by SCMFSA_2:47;
A6: G = insloc 0 .--> goto insloc 0 by SCMFSA8A:def 2;
  then
A7: G.insloc 0 = goto insloc 0 by FUNCOP_1:87;
  dom G = {insloc 0} by A6,FUNCOP_1:19;
  then
A8: insloc 0 in dom G by TARSKI:def 1;
A9: dom G c= dom GJ by SCMFSA6A:56;

  then insloc 0 + c4 in { il+c4 where il is Element of NAT: il in dom GJ} by
  A8;

  then
A10: insloc c4 in dom Shift(GJ,c4) by VALUED_1:def 12;
  then
A11: pi(Shift(GJ,c4),Lc4) = Shift(GJ,c4).(insloc 0 +c4) by AMI_1:def 47
    .= GJ.insloc 0 by A8,A9,VALUED_1:def 12
    .= goto insloc 0 by A8,A7,A5,SCMFSA6A:54,SCMFSA_2:124;
  card I1 = card I + card G by SCMFSA6A:61
    .= card I +1 by SCMFSA8A:29;
  then card I1 + card J + 3 = card I +4 +1 by SCMFSA8A:17;
  then c4 < card I1 + card J + 3 by NAT_1:13;
  hence
A12: Lc4 in dom if=0(a,I1,J) by SCMFSA8C:56;

A13: dom if=0(a,I1,J) = dom Directed Mi \/ dom ProgramPart Relocated(GJ, c4
  ) by A2,A3,FUNCT_4:def 1;

  then dom if=0(a,I1,J) = dom Mi \/ dom ProgramPart Relocated(GJ, c4) by
  FUNCT_4:105;

  then Lc4 in dom ProgramPart Relocated(GJ, c4) by A12,A4,XBOOLE_0:def 3;

  hence if=0(a,I1,J).Lc4 = (ProgramPart Relocated(GJ,c4)).Lc4 by A12,A2,A3,A13
  ,
  FUNCT_4:def 1

    .= IncAddr([Shift(ProgramPart(GJ),c4)],c4).Lc4 by SCMFSA_5:2
    .= IncAddr(Shift(GJ,c4),c4).Lc4 by AMI_1:105
    .= IncAddr( goto insloc 0, c4 ) by A10,A11,SCMFSA_4:24
    .= goto ((insloc 0)+c4) by SCMFSA_4:14;
end;

Lm2: for a being Int-Location, I being Program of SCM+FSA holds UsedIntLoc
if=0(a,I ';' Goto insloc 0,Stop SCM+FSA) = UsedIntLoc (if=0(a,I ';' Goto insloc
0,Stop SCM+FSA) +* ( insloc (card I +4) .--> goto insloc 0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 = insloc (card I + 4);
  set if0 = if=0(a,I ';' Goto insloc 0,Stop SCM+FSA);
  set ic4 = insloc (card I +4) .--> goto insloc 0;

  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedIntLoc i and
A2: UsedIntLoc if0 = Union (UIL1 * if0) by SF_MASTR:def 2;
A3: dom UIL1 = the Instructions of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,AMI_1:118;
A6: dom ic4 = {insloc (card I +4)} by FUNCOP_1:19;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
    insloc (card I +4) in dom if0 by Lm1;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
    FUNCT_4:def 1,ZFMISC_1:37;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,AMI_1:118;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:46
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:46;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:12
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.(goto ((insloc 0)+(card I +4))) by A12,Lm1
        .= UsedIntLoc goto ((insloc 0)+(card I +4)) by A1
        .= {} by SF_MASTR:19
        .= UsedIntLoc goto insloc 0 by SF_MASTR:19
        .= UIL1.(goto insloc 0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:87
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:14
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
  end;

  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A14: UsedIntLoc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 2;
  for c be Element of the Instructions of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedIntLoc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:113;
  hence thesis by A2,A14,A4,FUNCT_1:9;
end;

Lm3: for a being Int-Location, I being Program of SCM+FSA holds UsedInt*Loc
if=0(a,I ';' Goto insloc 0,Stop SCM+FSA) = UsedInt*Loc (if=0(a,I ';' Goto
insloc 0,Stop SCM+FSA) +* ( insloc (card I +4) .--> goto insloc 0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 = insloc (card I + 4);
  set if0 = if=0(a,I ';' Goto insloc 0,Stop SCM+FSA);
  set ic4 = insloc (card I +4) .--> goto insloc 0;

  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedInt*Loc i and
A2: UsedInt*Loc if0 = Union (UIL1 * if0) by SF_MASTR:def 4;
A3: dom UIL1 = the Instructions of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,AMI_1:118;
A6: dom ic4 = {insloc (card I +4)} by FUNCOP_1:19;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
    insloc (card I +4) in dom if0 by Lm1;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
    FUNCT_4:def 1,ZFMISC_1:37;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,AMI_1:118;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:46
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:46;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:12
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.(goto ((insloc 0)+(card I +4))) by A12,Lm1
        .= UsedInt*Loc goto ((insloc 0)+(card I +4)) by A1
        .= {} by SF_MASTR:36
        .= UsedInt*Loc goto insloc 0 by SF_MASTR:36
        .= UIL1.(goto insloc 0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:87
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:14
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
  end;

  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A14: UsedInt*Loc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 4;
  for c be Element of the Instructions of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedInt*Loc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:113;
  hence thesis by A2,A14,A4,FUNCT_1:9;
end;

theorem :: ewhileUsed:
  UsedIntLoc while=0(b, I) = {b} \/ UsedIntLoc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ';' Goto insloc 0;
  while=0(a, I) = if=0(a, IG, J) +* ( insloc (card I +4) .--> goto insloc
  0 ) by SCMFSA_9:def 1;
  hence UsedIntLoc while=0(a, I) = (UsedIntLoc if=0(a, IG, J)) by Lm2
    .= {a} \/ UsedIntLoc IG \/ UsedIntLoc J by Th13
    .= {a} \/ (UsedIntLoc I \/ UsedIntLoc Goto insloc 0) \/ UsedIntLoc J by
  SF_MASTR:31
    .= {a} \/ (UsedIntLoc I \/ {}) \/ UsedIntLoc J by Th11
    .= {a} \/ UsedIntLoc I by Th9;
end;

theorem :: ewhileUsedF:
  UsedInt*Loc while=0(b, I) = UsedInt*Loc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ';' Goto insloc 0;
  while=0(a, I) = if=0(a, IG, J) +* ( insloc (card I +4) .--> goto insloc
  0 ) by SCMFSA_9:def 1;
  hence UsedInt*Loc while=0(a, I) = (UsedInt*Loc if=0(a, IG, J)) by Lm3
    .= UsedInt*Loc IG \/ UsedInt*Loc J by Th14
    .= (UsedInt*Loc I \/ UsedInt*Loc Goto insloc 0) \/ UsedInt*Loc J by
  SF_MASTR:47
    .= UsedInt*Loc I \/ {} by Th10,Th12
    .= UsedInt*Loc I;
end;

definition
  let s be State of SCM+FSA, a be read-write Int-Location, I be Program of
  SCM+FSA;
  pred ProperBodyWhile=0 a, I, s means
  :Def1:
  for k being Element of NAT st
  StepWhile=0(a,I,s).k.a = 0 holds I is_closed_on StepWhile=0(a,I,s).k & I
  is_halting_on StepWhile=0(a,I,s).k;
  pred WithVariantWhile=0 a, I, s means
  :Def2:
  ex f being Function of product
  the Object-Kind of SCM+FSA, NAT st for k being Element of NAT holds ( f.(
StepWhile=0(a,I,s).(k+1)) < f.(StepWhile=0(a,I,s).k) or StepWhile=0(a,I,s).k.a
  <> 0 );
end;

theorem Th19: :: eParaProper:
  for I being parahalting Program of SCM+FSA holds
  ProperBodyWhile=0 a, I, s
proof
  let I be parahalting Program of SCM+FSA;
  let k be Element of NAT such that
  StepWhile=0(a,I,s).k.a = 0;
  thus I is_closed_on StepWhile=0(a,I,s).k by SCMFSA7B:24;
  thus thesis by SCMFSA7B:25;
end;

theorem Th20: :: SCMFSA_9:24, corrected
  ProperBodyWhile=0 a, I, s & WithVariantWhile=0 a, I, s implies
  while=0(a,I) is_halting_on s & while=0(a,I) is_closed_on s
proof
  assume
A1: for k being Element of NAT st StepWhile=0(a,I,s).k.a = 0 holds I
  is_closed_on StepWhile=0(a,I,s).k & I is_halting_on StepWhile=0(a,I,s).k;
  set s1 = s +* (while=0(a,I) +* Start-At insloc 0);
  defpred S[Element of NAT] means StepWhile=0(a,I,s).$1.a <> 0;
  given f being Function of product the Object-Kind of SCM+FSA,NAT such that
A2: for k being Element of NAT holds (f.(StepWhile=0(a,I,s).(k+1)) < f.(
  StepWhile=0(a,I,s).k) or (StepWhile=0(a,I,s).k).a <> 0 );
  deffunc F(Element of NAT) = f.(StepWhile=0(a,I,s).$1);
A3: for k holds ( F(k+1) < F(k) or S[k] ) by A2;
  consider m being Element of NAT such that
A4: S[m] and
A5: for n st S[n] holds m <= n from SEQ_4:sch 1(A3);
  defpred P[Element of NAT] means $1+1 <= m implies ex k st StepWhile=0(a,I,s)
  .($1+1)=Computation(s1,k);
A6: now
    let k be Element of NAT;
    assume
A7: P[k];
    now
      set sk1=StepWhile=0(a,I,s).(k+1);
      set sk=StepWhile=0(a,I,s).k;
      assume
A8:   (k+1)+ 1 <= m;
      k + 0 < k+ (1+ 1) by XREAL_1:8;
      then k < m by A8,XXREAL_0:2;
      then
A9:   sk.a = 0 by A5;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
      then consider n being Element of NAT such that
A10:  sk1 = Computation(s1,n) by A7,A8,XXREAL_0:2;
A11:  sk1 = Computation((sk +* (while=0(a,I)+* SAt)), (LifeSpan (sk +* (I
      +* SAt)) + 3)) by SCMFSA_9:def 4;
      take m=n +(LifeSpan (sk1 +* (I +* SAt)) + 3);
      I is_closed_on sk & I is_halting_on sk by A1,A9;
      then IC sk1 = insloc 0 by A11,A9,SCMFSA_9:22;
      hence StepWhile=0(a,I,s).((k+1)+1)=Computation(s1,m) by A10,SCMFSA_9:
      31;
    end;
    hence P[k+1];
  end;
A12: IC SCM+FSA in dom (while=0(a,I) +* SAt ) by SF_MASTR:65;
A13: P[0]
  proof
    assume
    0+1 <= m;
    take n=(LifeSpan (s+* (I +* SAt)) + 3);
    thus thesis by SCMFSA_9:30;
  end;
A14: for k being Element of NAT holds P[k] from NAT_1:sch 1(A13,A6);
  now
    per cases;
    suppose
      m = 0;
      then s.a <> 0 by A4,SCMFSA_9:def 4;
      hence thesis by SCMFSA_9:18;
    end;
    suppose
A15:  m <> 0;
      set p=(LifeSpan (s+* (I +* SAt)) + 3);
      set sm=StepWhile=0(a,I,s).m;
      set sm1=sm +* (while=0(a,I)+* SAt);
      consider i being Nat such that
A16:  m=i+1 by A15,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      set si=StepWhile=0(a,I,s).i;
A17:  sm= Computation((si +* (while=0(a,I)+* SAt)), (LifeSpan (si +* (I
      +* SAt)) + 3)) by A16,SCMFSA_9:def 4;
      m=i+1 by A16;
      then consider n being Element of NAT such that
A18:  sm = Computation(s1,n) by A14;
      i < m by A16,NAT_1:13;
      then
A19:  si.a = 0 by A5;
      then I is_closed_on si & I is_halting_on si by A1;
      then
A20:  IC sm = insloc 0 by A17,A19,SCMFSA_9:22;
      sm | IL =s1 | IL by A18,AMI_1:123;
      then
A21:  DataPart sm1 = DataPart sm & sm1 | IL = sm | IL by FUNCT_4:100
      ,SCMFSA8A:11;
      IC sm1 = sm1.IC SCM+FSA by AMI_1:def 15
        .= (while=0(a,I) +* SAt).IC SCM+FSA by A12,FUNCT_4:14
        .= IC sm by A20,SF_MASTR:66;
      then
A22:  sm1=sm by A21,SCMFSA_9:29;
      while=0(a,I) is_halting_on sm by A4,SCMFSA_9:18;
      then sm1 is halting by SCMFSA7B:def 8;
      then consider j being Element of NAT such that
A23:  CurInstr(Computation(sm,j)) = halt SCM+FSA by A22,AMI_1:def
      20;
      CurInstr Computation(s1,n+j) = halt SCM+FSA by A18,A23,AMI_1:51;
      then s1 is halting by AMI_1:def 20;
      hence while=0(a,I) is_halting_on s by SCMFSA7B:def 8;
      now
        let q be Element of NAT;
        per cases;
        suppose
A24:      q <= p;
A25:      StepWhile=0(a,I,s).0 = s by SCMFSA_9:def 4;
          then
A26:      s.a = 0 by A5,A15;
          then I is_closed_on s & I is_halting_on s by A1,A25;
          hence IC Computation(s1,q) in dom while=0(a,I) by A24,A26,
          SCMFSA_9:22;
        end;
        suppose
A27:      q > p;
A28:      now
            take k=p;
            thus StepWhile=0(a,I,s).1=Computation(s1,k) & k <= q by A27,
            SCMFSA_9:30;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 & (ex k st StepWhile=0(a,I,s).$1
          = Computation(s1,k) & k <= q);
A29:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A15,XREAL_1:8;
          then 1 <= m by NAT_1:13;
          then
A30:      ex k be Nat st P2[k] by A28;
          consider t be Nat such that
A31:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A29,A30);
          reconsider t as Element of NAT by ORDINAL1:def 13;
          now
            per cases;
            suppose
              t=m;
              then consider r being Element of NAT such that
A32:          sm=Computation(s1,r) and
A33:          r <= q by A31;
              consider x being Nat such that
A34:          q = r+x by A33,NAT_1:10;
A35:          while=0(a,I) is_closed_on sm by A4,SCMFSA_9:18;
              reconsider x as Element of NAT by ORDINAL1:def 13;
              Computation(s1,q) = Computation(sm1,x) by A22,A32,A34,AMI_1
              :51;
              hence IC Computation(s1,q) in dom while=0(a,I) by A35,
              SCMFSA7B:def 7;
            end;
            suppose
A36:          t<>m;
              set Dt=StepWhile=0(a,I,s).t;
              consider y being Nat such that
A37:          t=y+1 by A31,NAT_1:6;
              reconsider y as Element of NAT by ORDINAL1:def 13;
              set Dy=StepWhile=0(a,I,s).y;
A38:          Dt= Computation((Dy +* (while=0(a,I)+* SAt)), (LifeSpan (Dy
              +* (I +* SAt)) + 3)) by A37,SCMFSA_9:def 4;
              y+ 0 < t by A37,XREAL_1:8;
              then y < m by A31,XXREAL_0:2;
              then
A39:          Dy.a = 0 by A5;
              then I is_closed_on Dy & I is_halting_on Dy by A1;
              then
A40:          IC Dt =insloc 0 by A38,A39,SCMFSA_9:22;
              consider z being Element of NAT such that
A41:          StepWhile=0(a,I,s).t=Computation(s1,z) and
A42:          z <= q by A31;
              consider w being Nat such that
A43:          q = z+w by A42,NAT_1:10;
              reconsider w as Element of NAT by ORDINAL1:def 13;
A44:          Computation(s1,q) = Computation(Dt,w) by A41,A43,AMI_1:51
                .= Computation((Dt +* (while=0(a,I)+* SAt)),w) by A41,A40,
              SCMFSA_9:31;
              set z2=z +(LifeSpan (Dt +* (I +* SAt)) + 3);
A45:          t < m by A31,A36,XXREAL_0:1;
              now
                assume
A46:            z2 <= q;
A47:            now
                  take k=z2;
                  thus StepWhile=0(a,I,s).(t+1)=Computation(s1,k) & k <= q by
                  A41,A40,A46,SCMFSA_9:31;
                end;
                t+1 <= m by A45,NAT_1:13;
                hence contradiction by A31,A47,XREAL_1:31;
              end;
              then
A48:          w < LifeSpan (Dt +* (I +* SAt)) + 3 by A43,XREAL_1:8;
A49:          Dt.a = 0 by A5,A45;
              then I is_closed_on Dt & I is_halting_on Dt by A1;
              hence IC Computation(s1,q) in dom while=0(a,I) by A48,A44,A49,
              SCMFSA_9:22;
            end;
          end;
          hence IC Computation(s1,q) in dom while=0(a,I);
        end;
      end;
      hence while=0(a,I) is_closed_on s by SCMFSA7B:def 7;
    end;
  end;
  hence thesis;
end;

theorem Th21: :: SCMFSA_9:25, corrected
  for I being parahalting Program of SCM+FSA st WithVariantWhile=0
  a, I, s holds while=0(a,I) is_halting_on s & while=0(a,I) is_closed_on s
proof
  let I be parahalting Program of SCM+FSA such that
A1: WithVariantWhile=0 a, I, s;
  ProperBodyWhile=0 a, I, s
  proof
    let k be Element of NAT;
    assume
    StepWhile=0(a,I,s).k.a = 0;
    thus thesis by SCMFSA7B:24,25;
  end;
  hence thesis by A1,Th20;
end;

theorem Th22: :: based on SCMFSA_9:10
  while=0(a, I) +* (Start-At insloc 0) c= s & s.a <> 0 implies
  LifeSpan s = 4 & for k being Element of NAT holds DataPart Computation(s,k) =
  DataPart s
proof
  assume that
A1: while=0(a, I) +* SAt c= s and
A2: s.a <> 0;
  set i = a =0_goto insloc 4;
  set s1 = s +* (while=0(a,I) +* Start-At insloc 0);
A3: IC SCM+FSA in dom (while=0(a,I) +* Start-At insloc 0) by SF_MASTR:65;
  while=0(a,I) c= while=0(a,I) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A4: dom while=0(a,I) c= dom (while=0(a,I) +* Start-At insloc 0) by
  GRFUNC_1:8;
  not a in dom (while=0(a,I) +* Start-At insloc 0) by SCMFSA6B:12;
  then
A5: s1.a = s.a by FUNCT_4:12;
A6: insloc 1 in dom while=0(a,I) by SCMFSA_9:10;
A7: Computation(s1,1).insloc 1 = s1.insloc 1 by AMI_1:54
    .= (while=0(a,I) +* Start-At insloc 0).insloc 1 by A4,A6,FUNCT_4:14
    .= while=0(a,I).insloc 1 by A6,SCMFSA6B:7
    .= goto insloc 2 by SCMFSA_9:11;
A8: IC s1 = s1.IC SCM+FSA by AMI_1:def 15
    .= (while=0(a,I) +* Start-At insloc 0).IC SCM+FSA by A3,FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A9: insloc 0 in dom while=0(a,I) by SCMFSA_9:10;
  then s1.insloc 0 = (while=0(a,I) +* Start-At insloc 0).insloc 0 by A4,
  FUNCT_4:14
    .= while=0(a,I).insloc 0 by A9,SCMFSA6B:7
    .= i by SCMFSA_9:11;
  then
A10: CurInstr s1 = i by A8,AMI_1:def 17;
A11: Computation(s1,0+1) = Following Computation(s1,0) by AMI_1:14
    .= Following s1 by AMI_1:13
    .= Exec(i,s1) by A10,AMI_1:def 18;
  set loc5= insloc (card I +5);
  set s5 = Computation(s1,4);
  set s4 = Computation(s1,3);
  set s3 = Computation(s1,2);
  set s2 = Computation(s1,1);
A12: insloc 2 in dom while=0(a,I) by SCMFSA_9:12;
A13: s3.insloc 2 = s1.insloc 2 by AMI_1:54
    .= (while=0(a,I) +* Start-At insloc 0).insloc 2 by A4,A12,FUNCT_4:14
    .= while=0(a,I).insloc 2 by A12,SCMFSA6B:7
    .= goto insloc 3 by SCMFSA_9:16;
A14: insloc 3 in dom while=0(a,I) by SCMFSA_9:12;
A15: s4.insloc 3 = s1.insloc 3 by AMI_1:54
    .= (while=0(a,I) +* Start-At insloc 0).insloc 3 by A4,A14,FUNCT_4:14
    .= while=0(a,I).insloc 3 by A14,SCMFSA6B:7
    .= goto loc5 by SCMFSA_9:15;
A16: loc5 in dom while=0(a,I) by SCMFSA_9:13;
A17: s5.loc5 = s1.loc5 by AMI_1:54
    .= (while=0(a,I) +* Start-At insloc 0).loc5 by A4,A16,FUNCT_4:14
    .= while=0(a,I).loc5 by A16,SCMFSA6B:7
    .= halt SCM+FSA by SCMFSA_9:14;
A18: ( for c being Int-Location holds Exec(goto loc5, s4).c = s4.c)& for f
  being FinSeq-Location holds Exec(goto loc5, s4).f = s4.f by SCMFSA_2:95;
A19: ( for c being Int-Location holds Exec(goto insloc 2, s2).c = s2.c)& for
f being FinSeq-Location holds Exec(goto insloc 2, s2).f = s2.f by SCMFSA_2:95;
  IC Computation(s1,1) = Computation(s1,1).IC SCM+FSA by AMI_1:def 15
    .= Next insloc 0 by A2,A8,A11,A5,SCMFSA_2:96
    .= insloc (0 + 1);
  then
A20: CurInstr Computation(s1,1) = goto insloc 2 by A7,AMI_1:def 17;
A21: Computation(s1,1+1) = Following s2 by AMI_1:14
    .= Exec(goto insloc 2,s2) by A20,AMI_1:def 18;
  IC s3 = s3.IC SCM+FSA by AMI_1:def 15
    .= insloc 2 by A21,SCMFSA_2:95;
  then
A22: CurInstr s3 = goto insloc 3 by A13,AMI_1:def 17;
A23: Computation(s1,2+1) = Following s3 by AMI_1:14
    .= Exec(goto insloc 3,s3) by A22,AMI_1:def 18;
  IC s4 = s4.IC SCM+FSA by AMI_1:def 15
    .= insloc 3 by A23,SCMFSA_2:95;
  then
A24: CurInstr s4 = goto loc5 by A15,AMI_1:def 17;
A25: Computation(s1,3+1) = Following s4 by AMI_1:14
    .= Exec(goto loc5,s4) by A24,AMI_1:def 18;
  IC s5 = s5.IC SCM+FSA by AMI_1:def 15
    .= loc5 by A25,SCMFSA_2:95;
  then
A26: CurInstr s5 = halt SCM+FSA by A17,AMI_1:def 17;
  then
A27: s1 is halting by AMI_1:def 20;
A28: s = s1 by A1,FUNCT_4:79;
  now
    let k;
    assume
A29: CurInstr(Computation(s,k)) = halt SCM+FSA;
    assume
    4 > k;
    then 3+1 > k;
    then
A30: k <= 3 by NAT_1:13;
    per cases by A30,NAT_1:28;
    suppose
      k = 0;
      then Computation(s,k) = s by AMI_1:13;
      hence contradiction by A28,A10,A29,SCMFSA_2:48,124;
    end;
    suppose
      k = 1;
      hence contradiction by A28,A20,A29,SCMFSA_2:47,124;
    end;
    suppose
      k = 2;
      hence contradiction by A28,A22,A29,SCMFSA_2:47,124;
    end;
    suppose
      k = 3;
      hence contradiction by A28,A24,A29,SCMFSA_2:47,124;
    end;
  end;
  hence
A31: LifeSpan s = 4 by A28,A26,A27,AMI_1:def 46;
A32: ( for c being Int-Location holds Exec(i, s1).c = s1.c)& for f being
  FinSeq-Location holds Exec(i, s1).f = s1.f by SCMFSA_2:96;
  then
A33: DataPart Computation(s,1) = DataPart s by A28,A11,SCMFSA6A:38;
  then
A34: DataPart Computation(s,2) = DataPart s by A28,A21,A19
  ,SCMFSA6A:38;
A35: ( for c being Int-Location holds Exec(goto insloc 3, s3).c = s3.c)& for
f being FinSeq-Location holds Exec(goto insloc 3, s3).f = s3.f by SCMFSA_2:95;
  then DataPart Computation(s,3) = DataPart s by A28,A23,A34,SCMFSA6A:38;
  then
A36: DataPart Computation(s,4) = DataPart s by A28,A25,A18
  ,SCMFSA6A:38;
  let k be Element of NAT;
  k <= 3 or 3 < k;
  then
A37: k = 0 or k = 1 or k = 2 or k = 3 or 3+1 <= k by NAT_1:13,28;
  per cases by A37;
  suppose
    k = 0;
    hence thesis by AMI_1:13;
  end;
  suppose
    k = 1;
    hence thesis by A28,A11,A32,SCMFSA6A:38;
  end;
  suppose
    k = 2;
    hence thesis by A28,A21,A19,A33,SCMFSA6A:38;
  end;
  suppose
    k = 3;
    hence thesis by A28,A23,A35,A34,SCMFSA6A:38;
  end;
  suppose
    4 <= k;
    then CurInstr Computation(s,k) = halt SCM+FSA by A28,A27,A31,
    SCMFSA8A:4;
    hence thesis by A31,A36,AMI_1:127;
  end;
end;

theorem Th23: :: based on SCMFSA_9:22
  I is_closed_on s & I is_halting_on s & s.a = 0 implies DataPart
  Computation((s +* (while=0(a,I) +* Start-At insloc 0)), (LifeSpan (s +* (I +*
Start-At insloc 0)) + 3)) = DataPart Computation((s +* (I +* Start-At insloc 0)
  ), (LifeSpan (s +* (I +* Start-At insloc 0))))
proof
  assume that
A1: I is_closed_on s & I is_halting_on s and
A2: s.a = 0;
  set sI = s +* (I +* Start-At insloc 0);
  set s1 = s +* (while=0(a,I) +* Start-At insloc 0);
  defpred P[Element of NAT] means $1 <= LifeSpan sI implies IC Computation(s1,
  1+$1) = IC Computation(sI,$1) + 4 & DataPart Computation(s1,1+$1) = DataPart
  Computation(sI,$1);
A3: now
    let k be Element of NAT;
    assume
A4: P[k];
    now
A5:   k + 0 < k + 1 by XREAL_1:8;
      assume
      k + 1 <= LifeSpan sI;
      then k < LifeSpan sI by A5,XXREAL_0:2;
      hence IC Computation(s1,1+k+1) = IC Computation(sI,k+1) + 4 & DataPart
Computation(s1,1+k+1) = DataPart Computation(sI,k+1) by A1,A4,SCMFSA_9:19;
    end;
    hence P[k + 1];
  end;
  set i = a =0_goto insloc 4;
  set s2 = Computation(s1,1);
A6: IC SCM+FSA in dom (while=0(a,I) +* Start-At insloc 0) by SF_MASTR:65;
A7: IC s1 = s1.IC SCM+FSA by AMI_1:def 15
    .= (while=0(a,I) +* Start-At insloc 0).IC SCM+FSA by A6,FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
  not a in dom (while=0(a,I) +* Start-At insloc 0) by SCMFSA6B:12;
  then
A8: s1.a = s.a by FUNCT_4:12;
  set loc4 = insloc (card I + 4);
  while=0(a,I) c= while=0(a,I) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A9: dom while=0(a,I) c= dom (while=0(a,I) +* Start-At insloc 0) by
  GRFUNC_1:8;
A10: insloc 0 in dom while=0(a,I) by SCMFSA_9:10;
  then s1.insloc 0 = (while=0(a,I) +* Start-At insloc 0).insloc 0 by A9,
  FUNCT_4:14
    .= while=0(a,I).insloc 0 by A10,SCMFSA6B:7
    .= i by SCMFSA_9:11;
  then
A11: CurInstr s1 = i by A7,AMI_1:def 17;
A12: Computation(s1,0+1) = Following Computation(s1,0) by AMI_1:14
    .= Following s1 by AMI_1:13
    .= Exec(i,s1) by A11,AMI_1:def 18;
  then ( for c being Int-Location holds s2.c = s1.c)& for f being
  FinSeq-Location holds s2.f = s1.f by SCMFSA_2:96;
  then
A13: DataPart s2 = DataPart s1 by SCMFSA6A:38
    .= DataPart s by SCMFSA8A:11
    .= DataPart sI by SCMFSA8A:11;
A14: IC s2 = s2.IC SCM+FSA by AMI_1:def 15
    .= insloc 4 by A2,A12,A8,SCMFSA_2:96;
A15: P[0]
  proof
    assume
    0 <= LifeSpan sI;
A16: IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
    IC Computation(sI,0) = IC sI by AMI_1:13
      .= sI.IC SCM+FSA by AMI_1:def 15
      .= (I +* Start-At insloc 0).IC SCM+FSA by A16,FUNCT_4:14
      .= insloc 0 by SF_MASTR:66;
    hence thesis by A14,A13,AMI_1:13;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A15,A3);
  then
A17: P[LifeSpan sI qua Element of NAT];
  set s4=Computation(s1,1+LifeSpan sI+1+1);
  set s3 = Computation(s1,1+LifeSpan sI+1);
A18: loc4 in dom while=0(a,I) by SCMFSA_9:13;
  set s2 = Computation(s1,1+LifeSpan sI);
A19: CurInstr s2 = goto loc4 by A1,A17,SCMFSA_9:20;
A20: s3 = Following s2 by AMI_1:14
    .= Exec(goto loc4,s2) by A19,AMI_1:def 18;
  then
A21: ( for c being Int-Location holds s3.c = s2.c)& for f being
  FinSeq-Location holds s3.f = s2.f by SCMFSA_2:95;
A22: s3.loc4 = s1.loc4 by AMI_1:54
    .= (while=0(a,I) +* Start-At insloc 0).loc4 by A9,A18,FUNCT_4:14
    .= while=0(a,I).loc4 by A18,SCMFSA6B:7
    .= goto insloc 0 by SCMFSA_9:21;
  IC s3 = s3.IC SCM+FSA by AMI_1:def 15
    .= loc4 by A20,SCMFSA_2:95;
  then
A23: CurInstr s3 = goto insloc 0 by A22,AMI_1:def 17;
  s4 = Following s3 by AMI_1:14
    .= Exec(goto insloc 0,s3) by A23,AMI_1:def 18;
  then ( for c being Int-Location holds s4.c = s3.c)& for f being
  FinSeq-Location holds s4.f = s3.f by SCMFSA_2:95;
  hence DataPart Computation(s1,LifeSpan sI+3) = DataPart s3 by SCMFSA6A:38
    .= DataPart Computation(sI,LifeSpan sI) by A17,A21,SCMFSA6A:38;
end;

theorem Th24: :: Step_eq0_0:
  (StepWhile=0(a, I, s).k).a <> 0 implies DataPart StepWhile=0(a,
  I, s).(k+1) = DataPart StepWhile=0(a, I, s).k
proof
  assume
A1: (StepWhile=0(a, I, s).k).a <> 0;
  set SW = StepWhile=0(a, I, s);
A2: while=0(a,I) +* SAt c= SW.k +* (while=0(a,I) +* SAt) by FUNCT_4:26;
A3: DataPart(SW.k +* (while=0(a,I) +* SAt)) = DataPart SW.k by SCMFSA8A:11;
  then
A4: SW.k.a = (SW.k +* (while=0(a,I) +* SAt)).a by SCMFSA6A:38;
  thus DataPart SW.(k+1) = DataPart Computation((SW.k +* (while=0(a,I) +* SAt)
  ), (LifeSpan (SW.k +* (I +* SAt)) + 3)) by SCMFSA_9:def 4
    .= DataPart StepWhile=0(a, I, s).k by A1,A3,A4,A2,Th22;
end;

theorem Th25: :: Step_eq0_1:
  ( I is_halting_on Initialize StepWhile=0(a, I, s).k & I
  is_closed_on Initialize StepWhile=0(a, I, s).k or I is parahalting) & (
  StepWhile=0(a, I, s).k).a = 0 & (StepWhile=0(a, I, s).k).intloc 0 = 1 implies
DataPart StepWhile=0(a, I, s).(k+1) = DataPart IExec(I, StepWhile=0(a, I, s).k)
proof
  set Ins = NAT;
  assume that
A1: I is_halting_on Initialize StepWhile=0(a, I, s).k & I is_closed_on
  Initialize StepWhile=0(a, I, s).k or I is parahalting and
A2: (StepWhile=0(a, I, s).k).a = 0 and
A3: (StepWhile=0(a, I, s).k).intloc 0 = 1;
  set ISWk = Initialize StepWhile=0(a, I, s).k;
  set SW = StepWhile=0(a, I, s);
  set SWkI = SW.k+*Initialized I;
  DataPart ISWk = DataPart SW.k by A3,SCMFSA8C:27;
  then
A4: I is_closed_on SW.k & I is_halting_on SW.k by A1,SCMFSA7B:24,25 ,
  SCMFSA8B:6,8;
  I is_halting_on ISWk by A1,SCMFSA7B:25;
  then Initialized I is_halting_on SW.k by SCMFSA8C:22;
  then SAt c= Initialized I & SW.k+*(Initialized I +* SAt) is halting by
  SCMFSA6B:4,SCMFSA7B:def 8;
  then
A5: SWkI is halting by FUNCT_4:79;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A6: dom (SW.k | Ins) misses D by SCMFSA8A:3;
  set IS = I +* SAt;
  set SWkIS = SW.k+*IS;
A7: SWkI = SWkIS by A3,SCMFSA8C:18;
  set WHS = while=0(a, I) +* SAt;
A8: SW.(k+1) = Computation((SW.k +* WHS),LifeSpan (SWkIS) + 3) by SCMFSA_9:
  def 4;
  DataPart IExec(I, SW.k) = DataPart(Result(SWkI) +* SW.k | Ins) by
  SCMFSA6B:def 1
    .= DataPart Result(SWkI) by A6,FUNCT_4:94,SCMFSA_2:127
    .= DataPart Computation(SWkIS,LifeSpan SWkIS) by A7,A5,AMI_1:122;
  hence thesis by A2,A8,A4,Th23;
end;

theorem :: eGoodStep0:
  (ProperBodyWhile=0 a, Ig, s or Ig is parahalting) & s.intloc 0 = 1
  implies for k holds StepWhile=0(a, Ig, s).k.intloc 0 = 1
proof
  set I = Ig;
  assume that
A1: ProperBodyWhile=0 a, I, s or I is parahalting and
A2: s.intloc 0 = 1;
  set SW = StepWhile=0(a, I, s);
  defpred X[Element of NAT] means SW.$1.intloc 0 = 1;
A3: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT such that
A4: SW.k.intloc 0 = 1;
    per cases;
    suppose
      SW.k.a <> 0;
      then DataPart SW.(k+1) = DataPart SW.k by Th24;
      hence thesis by A4,SCMFSA6A:38;
    end;
    suppose
A5:   SW.k.a = 0;
      set Ins = NAT;
      set IS = I +* SAt;
      set SWkIS = SW.k+*IS;
      Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
      then
A6:   dom (SW.k | Ins) misses D by SCMFSA8A:3;
      set SWkI = SW.k+*Initialized I;
      set ISWk = Initialize StepWhile=0(a, I, s).k;
A7:   DataPart SW.k = DataPart ISWk by A4,SCMFSA8C:27;
A8:   ProperBodyWhile=0 a, I, s by A1,Th19;
      then
A9:   I is_closed_on SW.k by A5,Def1;
      I is_halting_on SW.k by A5,A8,Def1;
      then
A10:  I is_halting_on Initialize SW.k by A9,A7,SCMFSA8B:8;
      then Initialized I is_halting_on SW.k by SCMFSA8C:22;
      then SAt c= Initialized I & SW.k+*(Initialized I +* SAt) is halting by
      SCMFSA6B:4,SCMFSA7B:def 8;
      then
A11:  SWkI is halting by FUNCT_4:79;
A12:  SWkI = SWkIS by A4,SCMFSA8C:18;
A13:  DataPart IExec(I, SW.k) = DataPart(Result (SWkI) +* SW.k | Ins) by
      SCMFSA6B:def 1
        .= DataPart Result(SWkI) by A6,FUNCT_4:94,SCMFSA_2:127
        .= DataPart Computation(SWkIS,LifeSpan SWkIS) by A12,A11,AMI_1:122;
      I is_closed_on Initialize SW.k by A9,A7,SCMFSA8B:6;
      then DataPart SW.(k+1) = DataPart IExec(I, SW.k) by A4,A5,A10,Th25;
      hence
      SW.(k+1).intloc 0 = (Computation(SWkIS,LifeSpan SWkIS)).intloc 0 by
      A13,SCMFSA6A:38
        .= 1 by A4,A9,SCMFSA8C:97;
    end;
  end;
A14: X[0] by A2,SCMFSA_9:def 4;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A14,A3);
end;

theorem
  ProperBodyWhile=0 a, I, s1 & DataPart s1 = DataPart s2 implies for k
  holds DataPart StepWhile=0(a, I, s1).k = DataPart StepWhile=0(a, I, s2).k
proof
  assume that
A1: ProperBodyWhile=0 a, I, s1 and
A2: DataPart s1 = DataPart s2;
  set WH = while=0(a,I);
  set ST2 = StepWhile=0(a, I, s2);
  set ST1 = StepWhile=0(a, I, s1);
  defpred X[Element of NAT] means DataPart ST1.$1 = DataPart ST2.$1;
A3: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k;
    set ST1kI = ST1.k +* (I +* SAt);
    set ST2kI = ST2.k +* (I +* SAt);
    assume
A4: DataPart ST1.k = DataPart ST2.k;
    then
A5: ST1.k.a = ST2.k.a by SCMFSA6A:38;
    per cases;
    suppose
A6:   ST1.k.a <> 0;
      hence DataPart ST1.(k+1) = DataPart ST1.k by Th24
        .= DataPart ST2.(k+1) by A4,A5,A6,Th24;
    end;
    suppose
A7:   ST1.k.a = 0;
      then
A8:   I is_closed_on ST1.k by A1,Def1;
A9:   I is_halting_on ST1.k by A1,A7,Def1;
      then
A10:  I is_closed_on ST2.k & I is_halting_on ST2.k by A4,A8,
      SCMFSA8B
      :8;
A11:  DataPart ST1.(k+1) = DataPart Computation((ST1.k +* (WH +* SAt)), (
      LifeSpan (ST1kI) + 3)) by SCMFSA_9:def 4
        .= DataPart Computation((ST1kI),LifeSpan (ST1kI)) by A7,A8,A9,Th23;
A12:  DataPart ST2.(k+1) = DataPart Computation((ST2.k +* (WH +* SAt)), (
      LifeSpan (ST2kI) + 3)) by SCMFSA_9:def 4
        .= DataPart Computation((ST2kI),LifeSpan (ST2kI)) by A5,A7,A10,Th23;
A13:  I +* SAt c= ST1kI & I +* SAt c= ST2kI by FUNCT_4:26;
A14:  DataPart ST1.k = DataPart ST1kI by SCMFSA8A:11;
      then
A15:  I is_closed_on (ST1kI) by A8,SCMFSA8B:6;
A16:  DataPart ST1kI = DataPart ST1.k by SCMFSA8A:11
        .= DataPart ST2kI by A4,SCMFSA8A:11;
      I is_halting_on ST1kI by A8,A9,A14,SCMFSA8B:8;
      then (LifeSpan (ST1kI)) = (LifeSpan (ST2kI)) by A8,A16,A13,A14,
      SCMFSA8B:6,SCMFSA8C:44;
      hence thesis by A11,A12,A16,A13,A15,SCMFSA8C:43;
    end;
  end;
  DataPart ST1.0 = DataPart s1 by SCMFSA_9:def 4
    .= DataPart ST2.0 by A2,SCMFSA_9:def 4;
  then
A17: X[0];
  thus for k holds X[k] from NAT_1:sch 1(A17, A3);
end;

definition
  let s be State of SCM+FSA, a be read-write Int-Location, I be Program of
  SCM+FSA;
  assume that
A1: ProperBodyWhile=0 a, I, s or I is parahalting and
A2: WithVariantWhile=0 a, I, s;
  func ExitsAtWhile=0(a, I, s) -> Element of NAT means
  :Def3:
  ex k being
  Element of NAT st it = k & (StepWhile=0(a, I, s).k).a <> 0 & (for i being
  Element of NAT st (StepWhile=0(a, I, s).i).a <> 0 holds k <= i) & DataPart
  Computation((s +* (while=0(a, I) +* (Start-At insloc 0))), (LifeSpan (s +* (
  while=0(a, I) +* (Start-At insloc 0))))) = DataPart StepWhile=0(a, I, s).k;
  existence
  proof
    set S = s +* (while=0(a, I) +* SAt);
    set SW = StepWhile=0(a, I, s);
    defpred X[Element of NAT] means SW.$1.a <> 0;
A3: while=0(a, I) +* SAt c= S by FUNCT_4:26;
    consider f being Function of product the Object-Kind of SCM+FSA, NAT such
    that
A4: for k being Element of NAT holds f.(SW.(k+1))<f.(SW.(k)) or X[k]
    by A2,Def2;
    deffunc U(Element of NAT) = f.(SW.$1);
A5: for k being Element of NAT holds U(k+1)<U(k) or X[k] by A4;
    consider m such that
A6: X[m] and
A7: for n st X[n] holds m <= n from SEQ_4:sch 1(A5);
    take m, m;
    thus m = m;
    thus SW.m.a <> 0 by A6;
    thus for n st SW.n.a <> 0 holds m <= n by A7;
    defpred P[Element of NAT] means $1+1 <= m implies ex k st StepWhile=0(a,I,
    s).($1+1)=Computation(S,k);
A8: ProperBodyWhile=0 a, I, s by A1,Th19;
A9: now
      let k be Element of NAT;
      assume
A10:  P[k];
      now
        set sk1=StepWhile=0(a,I,s).(k+1);
        set sk=StepWhile=0(a,I,s).k;
        assume
A11:    (k+1)+ 1 <= m;
        k + 0 < k+ (1+ 1) by XREAL_1:8;
        then k < m by A11,XXREAL_0:2;
        then
A12:    sk.a = 0 by A7;
        (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
        then consider n being Element of NAT such that
A13:    sk1 = Computation(S,n) by A10,A11,XXREAL_0:2;
A14:    sk1 = Computation((sk +* (while=0(a,I)+* SAt)), (LifeSpan (sk +*
        (I +* SAt)) + 3)) by SCMFSA_9:def 4;
        take m=n +(LifeSpan (sk1 +* (I +* SAt)) + 3);
        I is_closed_on sk & I is_halting_on sk by A8,A12,Def1;
        then IC sk1 =insloc 0 by A14,A12,SCMFSA_9:22;
        hence StepWhile=0(a,I,s).((k+1)+1)=Computation(S,m) by A13,SCMFSA_9
        :31;
      end;
      hence P[k+1];
    end;
A15: IC SCM+FSA in dom (while=0(a,I) +* SAt ) by SF_MASTR:65;
A16: P[0]
    proof
      assume
      0+1 <= m;
      take n=(LifeSpan (s+* (I +* SAt)) + 3);
      thus thesis by SCMFSA_9:30;
    end;
A17: for k being Element of NAT holds P[k] from NAT_1:sch 1(A16,A9);
    per cases;
    suppose
A18:  m = 0;
A19:  DataPart S = DataPart s by SCMFSA8A:11
        .= DataPart SW.m by A18,SCMFSA_9:def 4;
      then S.a = SW.m.a by SCMFSA6A:38;
      hence thesis by A6,A3,A19,Th22;
    end;
    suppose
A20:  m <> 0;
      set sm = StepWhile=0(a,I,s).m;
      set sm1 = sm +* (while=0(a,I)+* SAt);
      consider i being Nat such that
A21:  m=i+1 by A20,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      set si = StepWhile=0(a,I,s).i;
A22:  sm = Computation((si +* (while=0(a,I)+* SAt)), (LifeSpan (si +* (I
      +* SAt)) + 3)) by A21,SCMFSA_9:def 4;
      m=i+1 by A21;
      then consider n being Element of NAT such that
A23:  sm = Computation(S,n) by A17;
      i < m by A21,NAT_1:13;
      then
A24:  si.a = 0 by A7;
      then I is_closed_on si & I is_halting_on si by A8,Def1;
      then
A25:  IC sm =insloc 0 by A22,A24,SCMFSA_9:22;
A26:  IC sm1 = sm1.IC SCM+FSA by AMI_1:def 15
        .= (while=0(a,I) +* SAt).IC SCM+FSA by A15,FUNCT_4:14
        .= IC sm by A25,SF_MASTR:66;
      sm | IL = S | IL by A23,AMI_1:123;
      then DataPart sm1 = DataPart sm & sm1 | IL = sm | IL by FUNCT_4:100
      ,SCMFSA8A:11;
      then
A27:  sm1 = sm by A26,SCMFSA_9:29;
      while=0(a,I) is_halting_on sm by A6,SCMFSA_9:18;
      then sm1 is halting by SCMFSA7B:def 8;
      then consider j being Element of NAT such that
A28:  CurInstr(Computation(sm,j)) = halt SCM+FSA by A27,AMI_1:def
      20;
      CurInstr Computation(S,n+j) = halt SCM+FSA by A23,A28,AMI_1:51;
      then
A29:  Computation(S,LifeSpan S) = Computation(S,n+j) by AMI_1:127
        .= Computation(sm,j) by A23,AMI_1:51
        .= Computation(sm,LifeSpan sm) by A28,AMI_1:127;
      while=0(a,I)+* SAt c= sm by A27,FUNCT_4:26;
      hence thesis by A6,A29,Th22;
    end;
  end;
  uniqueness
  proof
    let it1, it2 be Element of NAT;
    given k1 being Element of NAT such that
A30: it1 = k1 and
A31: (StepWhile=0(a, I, s).k1).a <> 0 & for i being Element of NAT st
    ( StepWhile=0(a, I, s).i).a <> 0 holds k1 <= i and
    DataPart(Computation((s +* (while=0(a, I) +* SAt)), (LifeSpan (s +* (
    while=0(a, I) +* SAt))))) = DataPart StepWhile=0(a, I, s).k1;
    given k2 being Element of NAT such that
A32: it2 = k2 and
A33: (StepWhile=0(a, I, s).k2).a <> 0 & for i being Element of NAT st
    ( StepWhile=0(a, I, s).i).a <> 0 holds k2 <= i and
    DataPart(Computation((s +* (while=0(a, I) +* SAt)), (LifeSpan (s +* (
    while=0(a, I) +* SAt))))) = DataPart StepWhile=0(a, I, s).k2;
    k1 <= k2 & k2 <= k1 by A31,A33;
    hence thesis by A30,A32,XXREAL_0:1;
  end;
end;

theorem :: IE_while_ne0:
  s.intloc 0 = 1 & s.a <> 0 implies DataPart IExec(while=0(a, I), s) =
  DataPart s
proof
  set Ins = NAT;
  assume that
A1: s.intloc 0 = 1 and
A2: s.a <> 0;
  set WH = while=0(a, I);
  set Is = Initialize s;
  set Ids = s +* Initialized WH;
A3: Ids = Is +*(WH +* SAt) by SCMFSA8A:13;
  then
A4: WH +* SAt c= Ids by FUNCT_4:26;
  Is.a = s.a by SCMFSA6C:3;
  then WH is_halting_on Is by A2,SCMFSA_9:18;
  then
A5: Ids is halting by A3,SCMFSA7B:def 8;
  DataPart Is = DataPart Ids by SCMFSA8B:5;
  then
A6: Ids.a = Is.a by SCMFSA6A:38
    .= s.a by SCMFSA6C:3;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A7: dom (s|Ins) misses D by SCMFSA8A:3;
  thus DataPart IExec(WH, s) = DataPart(Result(s+*Initialized WH) +* s | Ins)
  by SCMFSA6B:def 1
    .= DataPart(Result(s+*Initialized WH)) by A7,FUNCT_4:94,SCMFSA_2:127
    .= DataPart Computation(Ids,LifeSpan Ids) by A5,AMI_1:122
    .= DataPart Ids by A2,A6,A4,Th22
    .= DataPart Initialize s by SCMFSA8B:5
    .= DataPart s by A1,SCMFSA8C:27;
end;

theorem :: IE_while_eq0:
  (ProperBodyWhile=0 a, I, Initialize s or I is parahalting) &
WithVariantWhile=0 a, I, Initialize s implies DataPart IExec(while=0(a, I), s)
  = DataPart StepWhile=0(a, I, Initialize s).ExitsAtWhile=0(a, I, Initialize s)
proof
  set Ins = NAT;
  set WH = while=0(a, I);
  set Ids = s +* Initialized WH;
  set Is = Initialize s;
A1: Ids = Is +*(WH +* SAt) by SCMFSA8A:13;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A2: dom (s|Ins) misses D by SCMFSA8A:3;
  assume
A3: ( ProperBodyWhile=0 a, I, Initialize s or I is parahalting)&
  WithVariantWhile=0 a, I, Initialize s;
  then
A4: ex k being Element of NAT st ExitsAtWhile=0(a, I, Is) = k & (StepWhile=0(
a, I, Is).k).a <> 0 &( for i being Element of NAT st ( StepWhile=0(a, I, Is).i)
.a <> 0 holds k <= i)& DataPart(Computation((Is +* ( while=0(a, I) +* SAt)), (
  LifeSpan (Is +* (while=0(a, I) +* SAt))))) = DataPart StepWhile=0(a, I, Is).k
  by Def3;
  WH is_halting_on Is by A3,Th20,Th21;
  then
A5: Ids is halting by A1,SCMFSA7B:def 8;
  thus DataPart IExec(WH, s) = DataPart(Result(s+*Initialized WH) +* s | Ins)
  by SCMFSA6B:def 1
    .= DataPart(Result(s+*Initialized WH)) by A2,FUNCT_4:94,SCMFSA_2:127
    .= DataPart StepWhile=0(a, I, Is).ExitsAtWhile=0(a, I, Is) by A1,A5,A4,
  AMI_1:122;
end;

begin :: while>0, general

Lm4: for a being Int-Location, I being Program of SCM+FSA holds card I +4 in
dom if>0(a,I ';' Goto insloc 0,Stop SCM+FSA) & if>0(a,I ';' Goto insloc 0,Stop
SCM+FSA).(card I +4) = goto ((insloc 0)+(card I +4))

proof
  set J = Stop SCM+FSA;
  set G = Goto insloc 0;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' G;
  set i = a >0_goto insloc (card J + 3);
  set c4 = card I + 4;
  set Lc4 = c4;
  set Mi= Macro i ';' J ';' Goto insloc (card I1 + 1) ';' I;
A1: card (G ';' J) = card G + card J by SCMFSA6A:61
    .= 1 + 1 by SCMFSA8A:17,29
    .= 2;

A2: if>0(a, I1, J) = i ';' J ';' Goto insloc (card I1 + 1) ';' (I ';' G) ';'
  J by SCMFSA8B:def 2

    .= Mi ';' G ';' J by SCMFSA6A:67
    .= Mi ';' (G ';' J) by SCMFSA6A:67;
  then card if>0(a, I1,J) = card Mi + card (G ';' J) by SCMFSA6A:61;
  then
A3: card Mi = card if>0(a,I1,J)-card (G ';' J)
    .= card I + 6 - 2 by A1,SCMFSA_9:2
    .= c4;
  then
A4: not Lc4 in dom Mi by SCMFSA6A:15;
  set GJ = G ';' J;
A5: InsCode goto insloc 0 = 6 by SCMFSA_2:47;
A6: G = insloc 0 .--> goto insloc 0 by SCMFSA8A:def 2;
  then
A7: G.insloc 0 = goto insloc 0 by FUNCOP_1:87;
  dom G = {insloc 0} by A6,FUNCOP_1:19;
  then
A8: insloc 0 in dom G by TARSKI:def 1;
A9: dom G c= dom GJ by SCMFSA6A:56;

  then insloc 0 + c4 in { il+c4 where il is Element of NAT: il in dom GJ} by
  A8;

  then
A10: insloc c4 in dom Shift(GJ,c4) by VALUED_1:def 12;
  then
A11: pi(Shift(GJ,c4),Lc4) = Shift(GJ,c4).(insloc 0 +c4) by AMI_1:def 47
    .= GJ.insloc 0 by A8,A9,VALUED_1:def 12
    .= goto insloc 0 by A8,A7,A5,SCMFSA6A:54,SCMFSA_2:124;
  card I1 = card I + card G by SCMFSA6A:61
    .= card I +1 by SCMFSA8A:29;
  then card I1 + card J + 3 = card I +4 +1 by SCMFSA8A:17;
  then c4 < card I1 + card J + 3 by NAT_1:13;
  hence
A12: Lc4 in dom if>0(a,I1,J) by SCMFSA8C:57;

A13: dom if>0(a,I1,J) = dom Directed Mi \/ dom ProgramPart Relocated(GJ, c4
  ) by A2,A3,FUNCT_4:def 1;

  then dom if>0(a,I1,J) = dom Mi \/ dom ProgramPart Relocated(GJ, c4) by
  FUNCT_4:105;

  then Lc4 in dom ProgramPart Relocated(GJ, c4) by A12,A4,XBOOLE_0:def 3;

  hence if>0(a,I1,J).Lc4 = (ProgramPart Relocated(GJ,c4)).Lc4 by A12,A2,A3,A13
  ,
  FUNCT_4:def 1

    .= IncAddr([Shift(ProgramPart(GJ),c4)],c4).Lc4 by SCMFSA_5:2
    .= IncAddr(Shift(GJ,c4),c4).Lc4 by AMI_1:105
    .= IncAddr( goto insloc 0, c4 ) by A10,A11,SCMFSA_4:24
    .= goto ((insloc 0)+c4) by SCMFSA_4:14;
end;

Lm5: for a being Int-Location, I being Program of SCM+FSA holds UsedIntLoc
if>0(a,I ';' Goto insloc 0,Stop SCM+FSA) = UsedIntLoc (if>0(a,I ';' Goto insloc
0,Stop SCM+FSA) +* ( insloc (card I +4) .--> goto insloc 0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 = insloc (card I + 4);
  set if0 = if>0(a,I ';' Goto insloc 0,Stop SCM+FSA);
  set ic4 = insloc (card I +4) .--> goto insloc 0;

  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedIntLoc i and
A2: UsedIntLoc if0 = Union (UIL1 * if0) by SF_MASTR:def 2;
A3: dom UIL1 = the Instructions of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,AMI_1:118;
A6: dom ic4 = {insloc (card I +4)} by FUNCOP_1:19;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
    insloc (card I +4) in dom if0 by Lm4;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
    FUNCT_4:def 1,ZFMISC_1:37;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,AMI_1:118;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:46
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:46;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:12
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.(goto ((insloc 0)+(card I +4))) by A12,Lm4
        .= UsedIntLoc goto ((insloc 0)+(card I +4)) by A1
        .= {} by SF_MASTR:19
        .= UsedIntLoc goto insloc 0 by SF_MASTR:19
        .= UIL1.(goto insloc 0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:87
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:14
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
  end;

  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A14: UsedIntLoc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 2;
  for c be Element of the Instructions of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedIntLoc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:113;
  hence thesis by A2,A14,A4,FUNCT_1:9;
end;

Lm6: for a being Int-Location, I being Program of SCM+FSA holds UsedInt*Loc
if>0(a,I ';' Goto insloc 0,Stop SCM+FSA) = UsedInt*Loc (if>0(a,I ';' Goto
insloc 0,Stop SCM+FSA) +* ( insloc (card I +4) .--> goto insloc 0 ))

proof
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set Lc4 = insloc (card I + 4);
  set if0 = if>0(a,I ';' Goto insloc 0,Stop SCM+FSA);
  set ic4 = insloc (card I +4) .--> goto insloc 0;

  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that

A1: for i being Instruction of SCM+FSA holds UIL1.i = UsedInt*Loc i and
A2: UsedInt*Loc if0 = Union (UIL1 * if0) by SF_MASTR:def 4;
A3: dom UIL1 = the Instructions of SCM+FSA by FUNCT_2:def 1;
A4: now
    thus dom (UIL1*if0) = dom (UIL1*if0);
A5: rng (if0+*ic4) c= dom UIL1 by A3,AMI_1:118;
A6: dom ic4 = {insloc (card I +4)} by FUNCOP_1:19;
    then
A7: Lc4 in dom ic4 by TARSKI:def 1;
    insloc (card I +4) in dom if0 by Lm4;

    then dom (if0+*ic4) = dom if0 \/ dom ic4 & dom ic4 c= dom if0 by A6,
    FUNCT_4:def 1,ZFMISC_1:37;

    then
A8: dom if0 = dom (if0+*ic4) by XBOOLE_1:12;
    rng if0 c= dom UIL1 by A3,AMI_1:118;
    hence
A9: dom (UIL1*if0) = dom if0 by RELAT_1:46
      .= dom (UIL1*(if0+*ic4)) by A5,A8,RELAT_1:46;
    let x be set;
    assume
A10: x in dom (UIL1*if0);
    per cases;
    suppose
      x <> Lc4;
      then
A11:  not x in dom ic4 by A6,TARSKI:def 1;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.((if0+*ic4).x) by A11,FUNCT_4:12
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
    suppose
A12:  x = Lc4;
      thus (UIL1*if0).x = UIL1.(if0.x) by A10,FUNCT_1:22
        .= UIL1.(goto ((insloc 0)+(card I +4))) by A12,Lm4
        .= UsedInt*Loc goto ((insloc 0)+(card I +4)) by A1
        .= {} by SF_MASTR:36
        .= UsedInt*Loc goto insloc 0 by SF_MASTR:36
        .= UIL1.(goto insloc 0) by A1
        .= UIL1.(ic4.x) by A12,FUNCOP_1:87
        .= UIL1.((if0+*ic4).x) by A7,A12,FUNCT_4:14
        .= (UIL1*(if0+*ic4)).x by A9,A10,FUNCT_1:22;
    end;
  end;

  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that

A13: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A14: UsedInt*Loc (if0+*ic4) = Union (UIL2*(if0+*ic4)) by SF_MASTR:def 4;
  for c be Element of the Instructions of SCM+FSA holds UIL1.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL1.c = UsedInt*Loc d by A1
      .= UIL2.c by A13;
  end;
  then UIL1=UIL2 by FUNCT_2:113;
  hence thesis by A2,A14,A4,FUNCT_1:9;
end;

theorem :: whileUsed:
  UsedIntLoc while>0(b, I) = {b} \/ UsedIntLoc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ';' Goto insloc 0;
  while>0(a, I) = if>0(a, IG, J) +* ( insloc (card I +4) .--> goto insloc
  0 ) by SCMFSA_9:def 2;
  hence UsedIntLoc while>0(a, I) = (UsedIntLoc if>0(a, IG, J)) by Lm5
    .= {a} \/ UsedIntLoc IG \/ UsedIntLoc J by Th15
    .= {a} \/ (UsedIntLoc I \/ UsedIntLoc Goto insloc 0) \/ UsedIntLoc J by
  SF_MASTR:31
    .= {a} \/ (UsedIntLoc I \/ {}) \/ UsedIntLoc J by Th11
    .= {a} \/ UsedIntLoc I by Th9;
end;

theorem :: whileUsedF:
  UsedInt*Loc while>0(b, I) = UsedInt*Loc I
proof
  set J = Stop SCM+FSA;
  set a = b;
  set IG = I ';' Goto insloc 0;
  while>0(a, I) = if>0(a, IG, J) +* ( insloc (card I +4) .--> goto insloc
  0 ) by SCMFSA_9:def 2;
  hence UsedInt*Loc while>0(a, I) = (UsedInt*Loc if>0(a, IG, J)) by Lm6
    .= UsedInt*Loc IG \/ UsedInt*Loc J by Th16
    .= (UsedInt*Loc I \/ UsedInt*Loc Goto insloc 0) \/ UsedInt*Loc J by
  SF_MASTR:47
    .= UsedInt*Loc I \/ {} by Th10,Th12
    .= UsedInt*Loc I;
end;

definition
  let s be State of SCM+FSA, a be read-write Int-Location, I be Program of
  SCM+FSA;
  pred ProperBodyWhile>0 a, I, s means
  :Def4:
  for k being Element of NAT st
  StepWhile>0(a,I,s).k.a > 0 holds I is_closed_on StepWhile>0(a,I,s).k & I
  is_halting_on StepWhile>0(a,I,s).k;
  pred WithVariantWhile>0 a, I, s means
  :Def5:
  ex f being Function of product
  the Object-Kind of SCM+FSA, NAT st for k being Element of NAT holds ( f.(
StepWhile>0(a,I,s).(k+1)) < f.(StepWhile>0(a,I,s).k) or StepWhile>0(a,I,s).k.a
  <= 0 );
end;

theorem Th32: :: ParaProper:
  for I being parahalting Program of SCM+FSA holds
  ProperBodyWhile>0 a, I, s
proof
  let I be parahalting Program of SCM+FSA;
  let k be Element of NAT such that
  StepWhile>0(a,I,s).k.a > 0;
  thus I is_closed_on StepWhile>0(a,I,s).k by SCMFSA7B:24;
  thus thesis by SCMFSA7B:25;
end;

theorem Th33: :: SCMFSA_9:42, corrected
  ProperBodyWhile>0 a, I, s & WithVariantWhile>0 a, I, s implies
  while>0(a,I) is_halting_on s & while>0(a,I) is_closed_on s
proof
  assume
A1: for k being Element of NAT st StepWhile>0(a,I,s).k.a > 0 holds I
  is_closed_on StepWhile>0(a,I,s).k & I is_halting_on StepWhile>0(a,I,s).k;
  set s1 = s +* (while>0(a,I) +* Start-At insloc 0);
  defpred S[Element of NAT] means StepWhile>0(a,I,s).$1.a <= 0;
  given f being Function of product the Object-Kind of SCM+FSA,NAT such that
A2: for k being Element of NAT holds (f.(StepWhile>0(a,I,s).(k+1)) < f.(
  StepWhile>0(a,I,s).k) or (StepWhile>0(a,I,s).k).a <= 0 );
  deffunc F(Element of NAT) = f.(StepWhile>0(a,I,s).$1);
A3: for k holds ( F(k+1) < F(k) or S[k] ) by A2;
  consider m being Element of NAT such that
A4: S[m] and
A5: for n st S[n] holds m <= n from SEQ_4:sch 1(A3);
  defpred P[Element of NAT] means $1+1 <= m implies ex k st StepWhile>0(a,I,s)
  .($1+1)=Computation(s1,k);
A6: now
    let k be Element of NAT;
    assume
A7: P[k];
    now
      set sk1=StepWhile>0(a,I,s).(k+1);
      set sk=StepWhile>0(a,I,s).k;
      assume
A8:   (k+1)+ 1 <= m;
      k + 0 < k+ (1+ 1) by XREAL_1:8;
      then k < m by A8,XXREAL_0:2;
      then
A9:   sk.a > 0 by A5;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
      then consider n being Element of NAT such that
A10:  sk1 = Computation(s1,n) by A7,A8,XXREAL_0:2;
A11:  sk1 = Computation((sk +* (while>0(a,I)+* SAt)), (LifeSpan (sk +* (I
      +* SAt)) + 3)) by SCMFSA_9:def 5;
      take m=n +(LifeSpan (sk1 +* (I +* SAt)) + 3);
      I is_closed_on sk & I is_halting_on sk by A1,A9;
      then IC sk1 =insloc 0 by A11,A9,SCMFSA_9:47;
      hence StepWhile>0(a,I,s).((k+1)+1)=Computation(s1,m) by A10,SCMFSA_9:
      52;
    end;
    hence P[k+1];
  end;
A12: IC SCM+FSA in dom (while>0(a,I) +* SAt ) by SF_MASTR:65;
A13: P[0]
  proof
    assume
    0+1 <= m;
    take n=(LifeSpan (s+* (I +* SAt)) + 3);
    thus thesis by SCMFSA_9:51;
  end;
A14: for k being Element of NAT holds P[k] from NAT_1:sch 1(A13,A6);
  now
    per cases;
    suppose
      m=0;
      then s.a <= 0 by A4,SCMFSA_9:def 5;
      hence thesis by SCMFSA_9:43;
    end;
    suppose
A15:  m<>0;
      set p=(LifeSpan (s+* (I +* SAt)) + 3);
      set sm=StepWhile>0(a,I,s).m;
      set sm1=sm +* (while>0(a,I)+* SAt);
      consider i being Nat such that
A16:  m=i+1 by A15,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      set si=StepWhile>0(a,I,s).i;
A17:  sm= Computation((si +* (while>0(a,I)+* SAt)), (LifeSpan (si +* (I
      +* SAt)) + 3)) by A16,SCMFSA_9:def 5;
      m=i+1 by A16;
      then consider n being Element of NAT such that
A18:  sm = Computation(s1,n) by A14;
      i < m by A16,NAT_1:13;
      then
A19:  si.a > 0 by A5;
      then I is_closed_on si & I is_halting_on si by A1;
      then
A20:  IC sm =insloc 0 by A17,A19,SCMFSA_9:47;
      sm | IL =s1 | IL by A18,AMI_1:123;
      then
A21:  DataPart sm1 = DataPart sm & sm1 | IL = sm | IL by FUNCT_4:100
      ,SCMFSA8A:11;
      IC sm1 = sm1.IC SCM+FSA by AMI_1:def 15
        .= (while>0(a,I) +* SAt).IC SCM+FSA by A12,FUNCT_4:14
        .= IC sm by A20,SF_MASTR:66;
      then
A22:  sm1=sm by A21,SCMFSA_9:29;
      while>0(a,I) is_halting_on sm by A4,SCMFSA_9:43;
      then sm1 is halting by SCMFSA7B:def 8;
      then consider j being Element of NAT such that
A23:  CurInstr(Computation(sm,j)) = halt SCM+FSA by A22,AMI_1:def
      20;
      CurInstr Computation(s1,n+j) = halt SCM+FSA by A18,A23,AMI_1:51;
      then s1 is halting by AMI_1:def 20;
      hence while>0(a,I) is_halting_on s by SCMFSA7B:def 8;
      now
        let q be Element of NAT;
        per cases;
        suppose
A24:      q <= p;
A25:      StepWhile>0(a,I,s).0=s by SCMFSA_9:def 5;
          then
A26:      s.a > 0 by A5,A15;
          then I is_closed_on s & I is_halting_on s by A1,A25;
          hence IC Computation(s1,q) in dom while>0(a,I) by A24,A26,
          SCMFSA_9:47;
        end;
        suppose
A27:      q > p;
A28:      now
            take k=p;
            thus StepWhile>0(a,I,s).1=Computation(s1,k) & k <= q by A27,
            SCMFSA_9:51;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 & (ex k st StepWhile>0(a,I,s).$1
          = Computation(s1,k) & k <= q);
A29:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A15,XREAL_1:8;
          then 1 <= m by NAT_1:13;
          then
A30:      ex k be Nat st P2[k] by A28;
          consider t being Nat such that
A31:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A29, A30);
          reconsider t as Element of NAT by ORDINAL1:def 13;
          now
            per cases;
            suppose
              t=m;
              then consider r being Element of NAT such that
A32:          sm=Computation(s1,r) and
A33:          r <= q by A31;
              consider x being Nat such that
A34:          q = r+x by A33,NAT_1:10;
A35:          while>0(a,I) is_closed_on sm by A4,SCMFSA_9:43;
              reconsider x as Element of NAT by ORDINAL1:def 13;
              Computation(s1,q) = Computation(sm1,x) by A22,A32,A34,AMI_1
              :51;
              hence IC Computation(s1,q) in dom while>0(a,I) by A35,
              SCMFSA7B:def 7;
            end;
            suppose
A36:          t<>m;
              set Dt=StepWhile>0(a,I,s).t;
              consider y being Nat such that
A37:          t=y+1 by A31,NAT_1:6;
              reconsider y as Element of NAT by ORDINAL1:def 13;
              set Dy=StepWhile>0(a,I,s).y;
A38:          Dt= Computation((Dy +* (while>0(a,I)+* SAt)), (LifeSpan (Dy
              +* (I +* SAt)) + 3)) by A37,SCMFSA_9:def 5;
              y+ 0 < t by A37,XREAL_1:8;
              then y < m by A31,XXREAL_0:2;
              then
A39:          Dy.a > 0 by A5;
              then I is_closed_on Dy & I is_halting_on Dy by A1;
              then
A40:          IC Dt =insloc 0 by A38,A39,SCMFSA_9:47;
              consider z being Element of NAT such that
A41:          StepWhile>0(a,I,s).t=Computation(s1,z) and
A42:          z <= q by A31;
              consider w being Nat such that
A43:          q = z+w by A42,NAT_1:10;
              reconsider w as Element of NAT by ORDINAL1:def 13;
A44:          Computation(s1,q) = Computation(Dt,w) by A41,A43,AMI_1:51
                .= Computation((Dt +* (while>0(a,I)+* SAt)),w) by A41,A40,
              SCMFSA_9:52;
              set z2=z +(LifeSpan (Dt +* (I +* SAt)) + 3);
A45:          t < m by A31,A36,XXREAL_0:1;
              now
                assume
A46:            z2 <= q;
A47:            now
                  take k=z2;
                  thus StepWhile>0(a,I,s).(t+1)=Computation(s1,k) & k <= q by
                  A41,A40,A46,SCMFSA_9:52;
                end;
                t+1 <= m by A45,NAT_1:13;
                hence contradiction by A31,A47,XREAL_1:31;
              end;
              then
A48:          w < LifeSpan (Dt +* (I +* SAt)) + 3 by A43,XREAL_1:8;
A49:          Dt.a > 0 by A5,A45;
              then I is_closed_on Dt & I is_halting_on Dt by A1;
              hence IC Computation(s1,q) in dom while>0(a,I) by A48,A44,A49,
              SCMFSA_9:47;
            end;
          end;
          hence IC Computation(s1,q) in dom while>0(a,I);
        end;
      end;
      hence while>0(a,I) is_closed_on s by SCMFSA7B:def 7;
    end;
  end;
  hence thesis;
end;

theorem Th34: :: SCMFSA_9:43, corrected
  for I being parahalting Program of SCM+FSA st WithVariantWhile>0
  a, I, s holds while>0(a,I) is_halting_on s & while>0(a,I) is_closed_on s
proof
  let I be parahalting Program of SCM+FSA such that
A1: WithVariantWhile>0 a, I, s;
  ProperBodyWhile>0 a, I, s
  proof
    let k be Element of NAT;
    assume
    StepWhile>0(a,I,s).k.a > 0;
    thus thesis by SCMFSA7B:24,25;
  end;
  hence thesis by A1,Th33;
end;

theorem Th35: :: based on SCMFSA_9:32
  while>0(a, I) +* (Start-At insloc 0) c= s & s.a <= 0 implies
  LifeSpan s = 4 & for k being Element of NAT holds DataPart Computation(s,k) =
  DataPart s
proof
  assume that
A1: while>0(a, I) +* SAt c= s and
A2: s.a <= 0;
  set i = a >0_goto insloc 4;
  set s1 = s +* (while>0(a,I) +* Start-At insloc 0);
A3: IC SCM+FSA in dom (while>0(a,I) +* Start-At insloc 0) by SF_MASTR:65;
  while>0(a,I) c= while>0(a,I) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A4: dom while>0(a,I) c= dom (while>0(a,I) +* Start-At insloc 0) by
  GRFUNC_1:8;
  not a in dom (while>0(a,I) +* Start-At insloc 0) by SCMFSA6B:12;
  then
A5: s1.a = s.a by FUNCT_4:12;
A6: insloc 1 in dom while>0(a,I) by SCMFSA_9:10;
A7: Computation(s1,1).insloc 1 = s1.insloc 1 by AMI_1:54
    .= (while>0(a,I) +* Start-At insloc 0).insloc 1 by A4,A6,FUNCT_4:14
    .= while>0(a,I).insloc 1 by A6,SCMFSA6B:7
    .= goto insloc 2 by SCMFSA_9:11;
A8: IC s1 = s1.IC SCM+FSA by AMI_1:def 15
    .= (while>0(a,I) +* Start-At insloc 0).IC SCM+FSA by A3,FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A9: insloc 0 in dom while>0(a,I) by SCMFSA_9:10;
  then s1.insloc 0 = (while>0(a,I) +* Start-At insloc 0).insloc 0 by A4,
  FUNCT_4:14
    .= while>0(a,I).insloc 0 by A9,SCMFSA6B:7
    .= i by SCMFSA_9:11;
  then
A10: CurInstr s1 = i by A8,AMI_1:def 17;
A11: Computation(s1,0+1) = Following Computation(s1,0) by AMI_1:14
    .= Following s1 by AMI_1:13
    .= Exec(i,s1) by A10,AMI_1:def 18;
  set loc5= insloc (card I +5);
  set s5 = Computation(s1,4);
  set s4 = Computation(s1,3);
  set s3 = Computation(s1,2);
  set s2 = Computation(s1,1);
A12: insloc 2 in dom while>0(a,I) by SCMFSA_9:37;
A13: s3.insloc 2 = s1.insloc 2 by AMI_1:54
    .= (while>0(a,I) +* Start-At insloc 0).insloc 2 by A4,A12,FUNCT_4:14
    .= while>0(a,I).insloc 2 by A12,SCMFSA6B:7
    .= goto insloc 3 by SCMFSA_9:41;
A14: insloc 3 in dom while>0(a,I) by SCMFSA_9:37;
A15: s4.insloc 3 = s1.insloc 3 by AMI_1:54
    .= (while>0(a,I) +* Start-At insloc 0).insloc 3 by A4,A14,FUNCT_4:14
    .= while>0(a,I).insloc 3 by A14,SCMFSA6B:7
    .= goto loc5 by SCMFSA_9:40;
A16: loc5 in dom while>0(a,I) by SCMFSA_9:38;
A17: s5.loc5 = s1.loc5 by AMI_1:54
    .= (while>0(a,I) +* Start-At insloc 0).loc5 by A4,A16,FUNCT_4:14
    .= while>0(a,I).loc5 by A16,SCMFSA6B:7
    .= halt SCM+FSA by SCMFSA_9:39;
A18: ( for c being Int-Location holds Exec(goto loc5, s4).c = s4.c)& for f
  being FinSeq-Location holds Exec(goto loc5, s4).f = s4.f by SCMFSA_2:95;
A19: ( for c being Int-Location holds Exec(goto insloc 2, s2).c = s2.c)& for
f being FinSeq-Location holds Exec(goto insloc 2, s2).f = s2.f by SCMFSA_2:95;
  IC Computation(s1,1) = Computation(s1,1).IC SCM+FSA by AMI_1:def 15
    .= Next insloc 0 by A2,A8,A11,A5,SCMFSA_2:97
    .= insloc (0 + 1);
  then
A20: CurInstr Computation(s1,1) = goto insloc 2 by A7,AMI_1:def 17;
A21: Computation(s1,1+1) = Following s2 by AMI_1:14
    .= Exec(goto insloc 2,s2) by A20,AMI_1:def 18;
  IC s3 = s3.IC SCM+FSA by AMI_1:def 15
    .= insloc 2 by A21,SCMFSA_2:95;
  then
A22: CurInstr s3 = goto insloc 3 by A13,AMI_1:def 17;
A23: Computation(s1,2+1) = Following s3 by AMI_1:14
    .= Exec(goto insloc 3,s3) by A22,AMI_1:def 18;
  IC s4 = s4.IC SCM+FSA by AMI_1:def 15
    .= insloc 3 by A23,SCMFSA_2:95;
  then
A24: CurInstr s4 = goto loc5 by A15,AMI_1:def 17;
A25: Computation(s1,3+1) = Following s4 by AMI_1:14
    .= Exec(goto loc5,s4) by A24,AMI_1:def 18;
  IC s5 = s5.IC SCM+FSA by AMI_1:def 15
    .= loc5 by A25,SCMFSA_2:95;
  then
A26: CurInstr s5 = halt SCM+FSA by A17,AMI_1:def 17;
  then
A27: s1 is halting by AMI_1:def 20;
A28: s = s1 by A1,FUNCT_4:79;
  now
    let k;
    assume
A29: CurInstr(Computation(s,k)) = halt SCM+FSA;
    assume
    4 > k;
    then 3+1 > k;
    then
A30: k <= 3 by NAT_1:13;
    per cases by A30,NAT_1:28;
    suppose
      k = 0;
      then Computation(s,k) = s by AMI_1:13;
      hence contradiction by A28,A10,A29,SCMFSA_2:49,124;
    end;
    suppose
      k = 1;
      hence contradiction by A28,A20,A29,SCMFSA_2:47,124;
    end;
    suppose
      k = 2;
      hence contradiction by A28,A22,A29,SCMFSA_2:47,124;
    end;
    suppose
      k = 3;
      hence contradiction by A28,A24,A29,SCMFSA_2:47,124;
    end;
  end;
  hence
A31: LifeSpan s = 4 by A28,A26,A27,AMI_1:def 46;
A32: ( for c being Int-Location holds Exec(i, s1).c = s1.c)& for f being
  FinSeq-Location holds Exec(i, s1).f = s1.f by SCMFSA_2:97;
  then
A33: DataPart Computation(s,1) = DataPart s by A28,A11,SCMFSA6A:38;
  then
A34: DataPart Computation(s,2) = DataPart s by A28,A21,A19
  ,SCMFSA6A:38;
A35: ( for c being Int-Location holds Exec(goto insloc 3, s3).c = s3.c)& for
f being FinSeq-Location holds Exec(goto insloc 3, s3).f = s3.f by SCMFSA_2:95;
  then DataPart Computation(s,3) = DataPart s by A28,A23,A34,SCMFSA6A:38;
  then
A36: DataPart Computation(s,4) = DataPart s by A28,A25,A18
  ,SCMFSA6A:38;
  let k be Element of NAT;
  k <= 3 or 3 < k;
  then
A37: k = 0 or k = 1 or k = 2 or k = 3 or 3+1 <= k by NAT_1:13,28;
  per cases by A37;
  suppose
    k = 0;
    hence thesis by AMI_1:13;
  end;
  suppose
    k = 1;
    hence thesis by A28,A11,A32,SCMFSA6A:38;
  end;
  suppose
    k = 2;
    hence thesis by A28,A21,A19,A33,SCMFSA6A:38;
  end;
  suppose
    k = 3;
    hence thesis by A28,A23,A35,A34,SCMFSA6A:38;
  end;
  suppose
    4 <= k;
    then CurInstr Computation(s,k) = halt SCM+FSA by A28,A27,A31,
    SCMFSA8A:4;
    hence thesis by A31,A36,AMI_1:127;
  end;
end;

theorem Th36: :: based on SCMFSA_9:36
  I is_closed_on s & I is_halting_on s & s.a > 0 implies DataPart
  Computation((s +* (while>0(a,I) +* Start-At insloc 0)), (LifeSpan (s +* (I +*
Start-At insloc 0)) + 3)) = DataPart Computation((s +* (I +* Start-At insloc 0)
  ), (LifeSpan (s +* (I +* Start-At insloc 0))))
proof
  assume that
A1: I is_closed_on s & I is_halting_on s and
A2: s.a > 0;
  set sI = s +* (I +* Start-At insloc 0);
  set s1 = s +* (while>0(a,I) +* Start-At insloc 0);
  defpred P[Element of NAT] means $1 <= LifeSpan sI implies IC Computation(s1,
  1+$1) = IC Computation(sI,$1) + 4 & DataPart Computation(s1,1+$1) = DataPart
  Computation(sI,$1);
A3: now
    let k be Element of NAT;
    assume
A4: P[k];
    now
A5:   k + 0 < k + 1 by XREAL_1:8;
      assume
      k + 1 <= LifeSpan sI;
      then k < LifeSpan sI by A5,XXREAL_0:2;
      hence IC Computation(s1,1+k+1) = IC Computation(sI,k+1) + 4 & DataPart
Computation(s1,1+k+1) = DataPart Computation(sI,k+1) by A1,A4,SCMFSA_9:44;
    end;
    hence P[k + 1];
  end;
  set i = a >0_goto insloc 4;
  set s2 = Computation(s1,1);
A6: IC SCM+FSA in dom (while>0(a,I) +* Start-At insloc 0) by SF_MASTR:65;
A7: IC s1 = s1.IC SCM+FSA by AMI_1:def 15
    .= (while>0(a,I) +* Start-At insloc 0).IC SCM+FSA by A6,FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
  not a in dom (while>0(a,I) +* Start-At insloc 0) by SCMFSA6B:12;
  then
A8: s1.a = s.a by FUNCT_4:12;
  set loc4 = insloc (card I + 4);
  while>0(a,I) c= while>0(a,I) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A9: dom while>0(a,I) c= dom (while>0(a,I) +* Start-At insloc 0) by
  GRFUNC_1:8;
A10: insloc 0 in dom while>0(a,I) by SCMFSA_9:10;
  then s1.insloc 0 = (while>0(a,I) +* Start-At insloc 0).insloc 0 by A9,
  FUNCT_4:14
    .= while>0(a,I).insloc 0 by A10,SCMFSA6B:7
    .= i by SCMFSA_9:11;
  then
A11: CurInstr s1 = i by A7,AMI_1:def 17;
A12: Computation(s1,0+1) = Following Computation(s1,0) by AMI_1:14
    .= Following s1 by AMI_1:13
    .= Exec(i,s1) by A11,AMI_1:def 18;
  then ( for c being Int-Location holds s2.c = s1.c)& for f being
  FinSeq-Location holds s2.f = s1.f by SCMFSA_2:97;
  then
A13: DataPart s2 = DataPart s1 by SCMFSA6A:38
    .= DataPart s by SCMFSA8A:11
    .= DataPart sI by SCMFSA8A:11;
A14: IC s2 = s2.IC SCM+FSA by AMI_1:def 15
    .= insloc 4 by A2,A12,A8,SCMFSA_2:97;
A15: P[0]
  proof
    assume
    0 <= LifeSpan sI;
A16: IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
    IC Computation(sI,0) = IC sI by AMI_1:13
      .= sI.IC SCM+FSA by AMI_1:def 15
      .= (I +* Start-At insloc 0).IC SCM+FSA by A16,FUNCT_4:14
      .= insloc 0 by SF_MASTR:66;
    hence thesis by A14,A13,AMI_1:13;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A15,A3);
  then
A17: P[LifeSpan sI qua Element of NAT];
  set s4=Computation(s1,1+LifeSpan sI+1+1);
  set s3 = Computation(s1,1+LifeSpan sI+1);
A18: loc4 in dom while>0(a,I) by SCMFSA_9:38;
  set s2 = Computation(s1,1+LifeSpan sI);
A19: CurInstr s2 = goto loc4 by A1,A17,SCMFSA_9:45;
A20: s3 = Following s2 by AMI_1:14
    .= Exec(goto loc4,s2) by A19,AMI_1:def 18;
  then
A21: ( for c being Int-Location holds s3.c = s2.c)& for f being
  FinSeq-Location holds s3.f = s2.f by SCMFSA_2:95;
A22: s3.loc4 = s1.loc4 by AMI_1:54
    .= (while>0(a,I) +* Start-At insloc 0).loc4 by A9,A18,FUNCT_4:14
    .= while>0(a,I).loc4 by A18,SCMFSA6B:7
    .= goto insloc 0 by SCMFSA_9:46;
  IC s3 = s3.IC SCM+FSA by AMI_1:def 15
    .= loc4 by A20,SCMFSA_2:95;
  then
A23: CurInstr s3 = goto insloc 0 by A22,AMI_1:def 17;
  s4 = Following s3 by AMI_1:14
    .= Exec(goto insloc 0,s3) by A23,AMI_1:def 18;
  then ( for c being Int-Location holds s4.c = s3.c)& for f being
  FinSeq-Location holds s4.f = s3.f by SCMFSA_2:95;
  hence DataPart Computation(s1,LifeSpan sI+3) = DataPart s3 by SCMFSA6A:38
    .= DataPart Computation(sI,LifeSpan sI) by A17,A21,SCMFSA6A:38;
end;

theorem Th37: :: Step_gt0_0:
  (StepWhile>0(a, I, s).k).a <= 0 implies DataPart StepWhile>0(a,
  I, s).(k+1) = DataPart StepWhile>0(a, I, s).k
proof
  assume
A1: (StepWhile>0(a, I, s).k).a <= 0;
  set SW = StepWhile>0(a, I, s);
A2: while>0(a,I) +* SAt c= SW.k +* (while>0(a,I) +* SAt) by FUNCT_4:26;
A3: DataPart(SW.k +* (while>0(a,I) +* SAt)) = DataPart SW.k by SCMFSA8A:11;
  then
A4: SW.k.a = (SW.k +* (while>0(a,I) +* SAt)).a by SCMFSA6A:38;
  thus DataPart SW.(k+1) = DataPart Computation((SW.k +* (while>0(a,I) +* SAt)
  ), (LifeSpan (SW.k +* (I +* SAt)) + 3)) by SCMFSA_9:def 5
    .= DataPart StepWhile>0(a, I, s).k by A1,A3,A4,A2,Th35;
end;

theorem Th38: :: Step_gt0_1:
  ( I is_halting_on Initialize StepWhile>0(a, I, s).k & I
  is_closed_on Initialize StepWhile>0(a, I, s).k or I is parahalting) & (
  StepWhile>0(a, I, s).k).a > 0 & (StepWhile>0(a, I, s).k).intloc 0 = 1 implies
DataPart StepWhile>0(a, I, s).(k+1) = DataPart IExec(I, StepWhile>0(a, I, s).k)
proof
  set Ins = NAT;
  assume that
A1: I is_halting_on Initialize StepWhile>0(a, I, s).k & I is_closed_on
  Initialize StepWhile>0(a, I, s).k or I is parahalting and
A2: (StepWhile>0(a, I, s).k).a > 0 and
A3: (StepWhile>0(a, I, s).k).intloc 0 = 1;
  set ISWk = Initialize StepWhile>0(a, I, s).k;
  set SW = StepWhile>0(a, I, s);
  set SWkI = SW.k+*Initialized I;
  DataPart ISWk = DataPart SW.k by A3,SCMFSA8C:27;
  then
A4: I is_closed_on SW.k & I is_halting_on SW.k by A1,SCMFSA7B:24,25 ,
  SCMFSA8B:6,8;
  I is_halting_on ISWk by A1,SCMFSA7B:25;
  then Initialized I is_halting_on SW.k by SCMFSA8C:22;
  then SAt c= Initialized I & SW.k+*(Initialized I +* SAt) is halting by
  SCMFSA6B:4,SCMFSA7B:def 8;
  then
A5: SWkI is halting by FUNCT_4:79;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A6: dom (SW.k | Ins) misses D by SCMFSA8A:3;
  set IS = I +* SAt;
  set SWkIS = SW.k+*IS;
A7: SWkI = SWkIS by A3,SCMFSA8C:18;
  set WHS = while>0(a, I) +* SAt;
A8: SW.(k+1) = Computation((SW.k +* WHS),LifeSpan (SWkIS) + 3) by SCMFSA_9:
  def 5;
  DataPart IExec(I, SW.k) = DataPart(Result(SWkI) +* SW.k | Ins) by
  SCMFSA6B:def 1
    .= DataPart(Result(SWkI)) by A6,FUNCT_4:94,SCMFSA_2:127
    .= DataPart Computation(SWkIS,LifeSpan SWkIS) by A7,A5,AMI_1:122;
  hence thesis by A2,A8,A4,Th36;
end;

theorem Th39: :: GoodStep0:
  (ProperBodyWhile>0 a, Ig, s or Ig is parahalting) & s.intloc 0 =
  1 implies for k holds StepWhile>0(a, Ig, s).k.intloc 0 = 1
proof
  set I = Ig;
  assume that
A1: ProperBodyWhile>0 a, I, s or I is parahalting and
A2: s.intloc 0 = 1;
  set SW = StepWhile>0(a, I, s);
  defpred X[Element of NAT] means SW.$1.intloc 0 = 1;
A3: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT such that
A4: SW.k.intloc 0 = 1;
    per cases;
    suppose
      SW.k.a <= 0;
      then DataPart SW.(k+1) = DataPart SW.k by Th37;
      hence thesis by A4,SCMFSA6A:38;
    end;
    suppose
A5:   SW.k.a > 0;
      set SWkI = SW.k+*Initialized I;
      set ISWk = Initialize StepWhile>0(a, I, s).k;
A6:   DataPart SW.k = DataPart ISWk by A4,SCMFSA8C:27;
      set Ins = NAT;
      set SWkIS = SW.k+*(I +* SAt);
      Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
      then
A7:   dom (SW.k | Ins) misses D by SCMFSA8A:3;
A8:   SWkI = SWkIS by A4,SCMFSA8C:18;
A9:   ProperBodyWhile>0 a, I, s by A1,Th32;
      then
A10:  I is_closed_on SW.k by A5,Def4;
      I is_halting_on SW.k by A5,A9,Def4;
      then
A11:  I is_halting_on Initialize SW.k by A10,A6,SCMFSA8B:8;
      then Initialized I is_halting_on SW.k by SCMFSA8C:22;
      then SAt c= Initialized I & SW.k+*(Initialized I +* SAt) is halting by
      SCMFSA6B:4,SCMFSA7B:def 8;
      then
A12:  SWkI is halting by FUNCT_4:79;
A13:  DataPart IExec(I, SW.k) = DataPart(Result (SWkI) +* SW.k | Ins) by
      SCMFSA6B:def 1
        .= DataPart Result(SWkI) by A7,FUNCT_4:94,SCMFSA_2:127
        .= DataPart Computation(SWkIS,LifeSpan SWkIS) by A8,A12,AMI_1:122;
      I is_closed_on Initialize SW.k by A10,A6,SCMFSA8B:6;
      then DataPart SW.(k+1) = DataPart IExec(I, SW.k) by A4,A5,A11,Th38;
      hence
      SW.(k+1).intloc 0 = (Computation(SWkIS,LifeSpan SWkIS)).intloc 0 by
      A13,SCMFSA6A:38
        .= 1 by A4,A10,SCMFSA8C:97;
    end;
  end;
A14: X[0] by A2,SCMFSA_9:def 5;
  thus for k being Element of NAT holds X[k] from NAT_1:sch 1(A14,A3);
end;

theorem Th40:
  ProperBodyWhile>0 a, I, s1 & DataPart s1 = DataPart s2 implies
for k holds DataPart StepWhile>0(a, I, s1).k = DataPart StepWhile>0(a, I, s2).k
proof
  assume that
A1: ProperBodyWhile>0 a, I, s1 and
A2: DataPart s1 = DataPart s2;
  set WH = while>0(a,I);
  set ST2 = StepWhile>0(a, I, s2);
  set ST1 = StepWhile>0(a, I, s1);
  defpred X[Element of NAT] means DataPart ST1.$1 = DataPart ST2.$1;
A3: for k st X[k] holds X[k+1]
  proof
    let k;
    set ST1kI = ST1.k +* (I +* SAt);
    set ST2kI = ST2.k +* (I +* SAt);
    assume
A4: DataPart ST1.k = DataPart ST2.k;
    then
A5: ST1.k.a = ST2.k.a by SCMFSA6A:38;
    per cases;
    suppose
A6:   ST1.k.a <= 0;
      hence DataPart ST1.(k+1) = DataPart ST1.k by Th37
        .= DataPart ST2.(k+1) by A4,A5,A6,Th37;
    end;
    suppose
A7:   ST1.k.a > 0;
      then
A8:   I is_closed_on ST1.k by A1,Def4;
A9:   I is_halting_on ST1.k by A1,A7,Def4;
      then
A10:  I is_closed_on ST2.k & I is_halting_on ST2.k by A4,A8,
      SCMFSA8B
      :8;
A11:  DataPart ST1.(k+1) = DataPart Computation((ST1.k +* (WH +* SAt)), (
      LifeSpan (ST1kI) + 3)) by SCMFSA_9:def 5
        .= DataPart Computation((ST1kI),LifeSpan (ST1kI)) by A7,A8,A9,Th36;
A12:  DataPart ST2.(k+1) = DataPart Computation((ST2.k +* (WH +* SAt)), (
      LifeSpan (ST2kI) + 3)) by SCMFSA_9:def 5
        .= DataPart Computation((ST2kI),LifeSpan (ST2kI)) by A5,A7,A10,Th36;
A13:  I +* SAt c= ST1kI & I +* SAt c= ST2kI by FUNCT_4:26;
A14:  DataPart ST1.k = DataPart ST1kI by SCMFSA8A:11;
      then
A15:  I is_closed_on (ST1kI) by A8,SCMFSA8B:6;
A16:  DataPart ST1kI = DataPart ST1.k by SCMFSA8A:11
        .= DataPart ST2kI by A4,SCMFSA8A:11;
      I is_halting_on ST1kI by A8,A9,A14,SCMFSA8B:8;
      then (LifeSpan (ST1kI)) = (LifeSpan (ST2kI)) by A8,A16,A13,A14,
      SCMFSA8B:6,SCMFSA8C:44;
      hence thesis by A11,A12,A16,A13,A15,SCMFSA8C:43;
    end;
  end;
  DataPart ST1.0 = DataPart s1 by SCMFSA_9:def 5
    .= DataPart ST2.0 by A2,SCMFSA_9:def 5;
  then
A17: X[0];
  thus for k holds X[k] from NAT_1:sch 1(A17, A3);
end;

definition
  let s be State of SCM+FSA, a be read-write Int-Location, I be Program of
  SCM+FSA;
  assume that
A1: ProperBodyWhile>0 a, I, s or I is parahalting and
A2: WithVariantWhile>0 a, I, s;
  func ExitsAtWhile>0(a, I, s) -> Element of NAT means
  :Def6:
  ex k being
  Element of NAT st it = k & (StepWhile>0(a, I, s).k).a <= 0 & (for i being
  Element of NAT st (StepWhile>0(a, I, s).i).a <= 0 holds k <= i) & DataPart
  Computation((s +* (while>0(a, I) +* (Start-At insloc 0))), (LifeSpan (s +* (
  while>0(a, I) +* (Start-At insloc 0))))) = DataPart StepWhile>0(a, I, s).k;
  existence
  proof
    set S = s +* (while>0(a, I) +* SAt);
    set SW = StepWhile>0(a, I, s);
    defpred X[Element of NAT] means SW.$1.a <= 0;
A3: while>0(a, I) +* SAt c= S by FUNCT_4:26;
    consider f being Function of product the Object-Kind of SCM+FSA, NAT such
    that
A4: for k being Element of NAT holds f.(SW.(k+1))<f.(SW.k) or X[k] by
    A2,Def5;
    deffunc U(Element of NAT) = f.(SW.$1);
A5: for k being Element of NAT holds U(k+1)<U(k) or X[k] by A4;
    consider m such that
A6: X[m] and
A7: for n st X[n] holds m <= n from SEQ_4:sch 1(A5);
    take m, m;
    thus m = m;
    thus SW.m.a <= 0 by A6;
    thus for n st SW.n.a <= 0 holds m <= n by A7;
    defpred P[Element of NAT] means $1+1 <= m implies ex k st StepWhile>0(a,I,
    s).($1+1)=Computation(S,k);
A8: ProperBodyWhile>0 a, I, s by A1,Th32;
A9: now
      let k be Element of NAT;
      assume
A10:  P[k];
      now
        set sk1=StepWhile>0(a,I,s).(k+1);
        set sk=StepWhile>0(a,I,s).k;
        assume
A11:    (k+1)+ 1 <= m;
        k + 0 < k+ (1+ 1) by XREAL_1:8;
        then k < m by A11,XXREAL_0:2;
        then
A12:    sk.a > 0 by A7;
        (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
        then consider n being Element of NAT such that
A13:    sk1 = Computation(S,n) by A10,A11,XXREAL_0:2;
A14:    sk1 = Computation((sk +* (while>0(a,I)+* SAt)), (LifeSpan (sk +*
        (I +* SAt)) + 3)) by SCMFSA_9:def 5;
        take m=n +(LifeSpan (sk1 +* (I +* SAt)) + 3);
        I is_closed_on sk & I is_halting_on sk by A8,A12,Def4;
        then IC sk1 =insloc 0 by A14,A12,SCMFSA_9:47;
        hence StepWhile>0(a,I,s).((k+1)+1)=Computation(S,m) by A13,SCMFSA_9
        :52;
      end;
      hence P[k+1];
    end;
A15: IC SCM+FSA in dom (while>0(a,I) +* SAt ) by SF_MASTR:65;
A16: P[0]
    proof
      assume
      0+1 <= m;
      take n=(LifeSpan (s+* (I +* SAt)) + 3);
      thus thesis by SCMFSA_9:51;
    end;
A17: for k being Element of NAT holds P[k] from NAT_1:sch 1(A16,A9);
    per cases;
    suppose
A18:  m = 0;
A19:  DataPart S = DataPart s by SCMFSA8A:11
        .= DataPart SW.m by A18,SCMFSA_9:def 5;
      then S.a = SW.m.a by SCMFSA6A:38;
      hence thesis by A6,A3,A19,Th35;
    end;
    suppose
A20:  m <> 0;
      set sm = StepWhile>0(a,I,s).m;
      set sm1 = sm +* (while>0(a,I)+* SAt);
      consider i being Nat such that
A21:  m=i+1 by A20,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      set si = StepWhile>0(a,I,s).i;
A22:  sm = Computation((si +* (while>0(a,I)+* SAt)), (LifeSpan (si +* (I
      +* SAt)) + 3)) by A21,SCMFSA_9:def 5;
      m=i+1 by A21;
      then consider n being Element of NAT such that
A23:  sm = Computation(S,n) by A17;
      i < m by A21,NAT_1:13;
      then
A24:  si.a > 0 by A7;
      then I is_closed_on si & I is_halting_on si by A8,Def4;
      then
A25:  IC sm =insloc 0 by A22,A24,SCMFSA_9:47;
A26:  IC sm1 = sm1.IC SCM+FSA by AMI_1:def 15
        .= (while>0(a,I) +* SAt).IC SCM+FSA by A15,FUNCT_4:14
        .= IC sm by A25,SF_MASTR:66;
      sm | IL = S | IL by A23,AMI_1:123;
      then DataPart sm1 = DataPart sm & sm1 | IL = sm | IL by FUNCT_4:100
      ,SCMFSA8A:11;
      then
A27:  sm1 = sm by A26,SCMFSA_9:29;
      while>0(a,I) is_halting_on sm by A6,SCMFSA_9:43;
      then sm1 is halting by SCMFSA7B:def 8;
      then consider j being Element of NAT such that
A28:  CurInstr(Computation(sm,j)) = halt SCM+FSA by A27,AMI_1:def
      20;
      CurInstr Computation(S,n+j) = halt SCM+FSA by A23,A28,AMI_1:51;
      then
A29:  Computation(S,LifeSpan S) = Computation(S,n+j) by AMI_1:127
        .= Computation(sm,j) by A23,AMI_1:51
        .= Computation(sm,LifeSpan sm) by A28,AMI_1:127;
      while>0(a,I)+* SAt c= sm by A27,FUNCT_4:26;
      hence thesis by A6,A29,Th35;
    end;
  end;
  uniqueness
  proof
    let it1, it2 be Element of NAT;
    given k1 being Element of NAT such that
A30: it1 = k1 and
A31: (StepWhile>0(a, I, s).k1).a <= 0 & for i being Element of NAT st
    ( StepWhile>0(a, I, s).i).a <= 0 holds k1 <= i and
    DataPart(Computation((s +* (while>0(a, I) +* SAt)), (LifeSpan (s +* (
    while>0(a, I) +* SAt))))) = DataPart StepWhile>0(a, I, s).k1;
    given k2 being Element of NAT such that
A32: it2 = k2 and
A33: (StepWhile>0(a, I, s).k2).a <= 0 & for i being Element of NAT st
    ( StepWhile>0(a, I, s).i).a <= 0 holds k2 <= i and
    DataPart(Computation((s +* (while>0(a, I) +* SAt)), (LifeSpan (s +* (
    while>0(a, I) +* SAt))))) = DataPart StepWhile>0(a, I, s).k2;
    k1 <= k2 & k2 <= k1 by A31,A33;
    hence thesis by A30,A32,XXREAL_0:1;
  end;
end;

theorem :: IE_while_le0:
  s.intloc 0 = 1 & s.a <= 0 implies DataPart IExec(while>0(a, I), s) =
  DataPart s
proof
  set Ins = NAT;
  assume that
A1: s.intloc 0 = 1 and
A2: s.a <= 0;
  set WH = while>0(a, I);
  set Is = Initialize s;
  set Ids = s +* Initialized WH;
A3: Ids = Is +*(WH +* SAt) by SCMFSA8A:13;
  then
A4: WH +* SAt c= Ids by FUNCT_4:26;
  Is.a = s.a by SCMFSA6C:3;
  then WH is_halting_on Is by A2,SCMFSA_9:43;
  then
A5: Ids is halting by A3,SCMFSA7B:def 8;
  DataPart Is = DataPart Ids by SCMFSA8B:5;
  then
A6: Ids.a = Is.a by SCMFSA6A:38
    .= s.a by SCMFSA6C:3;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A7: dom (s|Ins) misses D by SCMFSA8A:3;
  thus DataPart IExec(WH, s) = DataPart(Result(s+*Initialized WH) +* s | Ins)
  by SCMFSA6B:def 1
    .= DataPart(Result(s+*Initialized WH)) by A7,FUNCT_4:94,SCMFSA_2:127
    .= DataPart Computation(Ids,LifeSpan Ids) by A5,AMI_1:122
    .= DataPart Ids by A2,A6,A4,Th35
    .= DataPart Initialize s by SCMFSA8B:5
    .= DataPart s by A1,SCMFSA8C:27;
end;

theorem Th42: :: IE_while_gt0:
  (ProperBodyWhile>0 a, I, Initialize s or I is parahalting) &
WithVariantWhile>0 a, I, Initialize s implies DataPart IExec(while>0(a, I), s)
  = DataPart StepWhile>0(a, I, Initialize s).ExitsAtWhile>0(a, I, Initialize s)
proof
  set Ins = NAT;
  set WH = while>0(a, I);
  set Ids = s +* Initialized WH;
  set Is = Initialize s;
A1: Ids = Is +*(WH +* SAt) by SCMFSA8A:13;
  Ins misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then
A2: dom (s|Ins) misses D by SCMFSA8A:3;
  assume
A3: ( ProperBodyWhile>0 a, I, Initialize s or I is parahalting)&
  WithVariantWhile>0 a, I, Initialize s;
  then
A4: ex k being Element of NAT st ExitsAtWhile>0(a, I, Is) = k & (StepWhile>0(
a, I, Is).k).a <= 0 &( for i being Element of NAT st ( StepWhile>0(a, I, Is).i)
.a <= 0 holds k <= i)& DataPart (Computation((Is +* ( while>0(a, I) +* SAt)), (
  LifeSpan (Is +* (while>0(a, I) +* SAt))))) = DataPart StepWhile>0(a, I, Is).k
  by Def6;
  WH is_halting_on Is by A3,Th33,Th34;
  then
A5: Ids is halting by A1,SCMFSA7B:def 8;
  thus DataPart IExec(WH, s) = DataPart(Result(s+*Initialized WH) +* s | Ins)
  by SCMFSA6B:def 1
    .= DataPart(Result(s+*Initialized WH)) by A2,FUNCT_4:94,SCMFSA_2:127
    .= DataPart StepWhile>0(a, I, Is).ExitsAtWhile>0(a, I, Is) by A1,A5,A4,
  AMI_1:122;
end;

theorem Th43:
  StepWhile>0(a, I, s).k.a <= 0 implies for n being Element of NAT
st k <= n holds DataPart StepWhile>0(a, I, s).n = DataPart StepWhile>0(a, I, s)
  .k
proof
  set SW = StepWhile>0(a, I, s);
  defpred P[Element of NAT] means k <= $1 implies DataPart SW.$1 = DataPart SW
  .k;
  assume
A1: StepWhile>0(a, I, s).k.a <= 0;
A2: now
    let n be Element of NAT such that
A3: P[n];
    thus P[n+1]
    proof
      assume
A4:   k <= n+1;
      per cases by A4,NAT_1:8;
      suppose
A5:     k <= n;
        then SW.n.a <= 0 by A1,A3,SCMFSA6A:38;
        hence thesis by A3,A5,Th37;
      end;
      suppose
        k = n+1;
        hence thesis;
      end;
    end;
  end;
A6: P[0];
  thus for n being Element of NAT holds P[n] from NAT_1:sch 1(A6, A2 );
end;

theorem
  DataPart s1 = DataPart s2 & ProperBodyWhile>0 a, I, s1 implies
  ProperBodyWhile>0 a, I, s2
proof
  assume that
A1: DataPart s1 = DataPart s2 and
A2: ProperBodyWhile>0 a, I, s1;
  let k be Element of NAT such that
A3: StepWhile>0(a,I,s2).k.a > 0;
A4: DataPart StepWhile>0(a,I,s2).k = DataPart StepWhile>0(a,I,s1).k by A1,A2
  ,Th40;
  then StepWhile>0(a,I,s1).k.a > 0 by A3,SCMFSA6A:38;
  then
  I is_closed_on StepWhile>0(a,I,s1).k & I is_halting_on StepWhile>0(a,I,
  s1).k by A2,Def4;
  hence thesis by A4,SCMFSA8B:8;
end;

Lm7: s.intloc 0 = 1 implies (I is_closed_on s iff I is_closed_on Initialize s)
proof
  assume
  s.intloc 0 = 1;
  then DataPart Initialize s = DataPart s by SCMFSA8C:27;
  hence thesis by SCMFSA8B:6;
end;

Lm8: s.intloc 0 = 1 implies ( I is_closed_on s & I is_halting_on s iff I
is_closed_on Initialize s & I is_halting_on Initialize s)

proof
  assume
  s.intloc 0 = 1;
  then DataPart Initialize s = DataPart s by SCMFSA8C:27;
  hence thesis by SCMFSA8B:8;
end;

theorem Th45:
  s.intloc 0 = 1 & ProperBodyWhile>0 a, Ig, s & WithVariantWhile>0
  a, Ig, s implies for i, j st i <> j & i <= ExitsAtWhile>0(a, Ig, s) & j <=
ExitsAtWhile>0(a, Ig, s) holds StepWhile>0(a, Ig, s).i <> StepWhile>0(a, Ig, s)
  .j & DataPart StepWhile>0(a, Ig, s).i <> DataPart StepWhile>0(a, Ig, s).j
proof
  set I = Ig;
  assume that
A1: s.intloc 0 = 1 and
A2: ProperBodyWhile>0 a, I, s and
A3: WithVariantWhile>0 a, I, s;
  set SW = StepWhile>0(a, I, s);
  consider K being Element of NAT such that
A4: ExitsAtWhile>0(a, I, s) = K and
A5: SW.K.a <= 0 and
A6: for i being Element of NAT st SW.i.a <= 0 holds K <= i and
  DataPart Computation((s +* (while>0(a, I) +* SAt)), (LifeSpan (s +* (
  while>0(a, I) +* SAt)))) = DataPart SW.K by A2,A3,Def6;
  consider f being Function of product the Object-Kind of SCM+FSA, NAT such
  that
A7: for k being Element of NAT holds f.(SW.(k+1)) < f.(SW.k) or SW.k.a
  <= 0 by A3,Def5;
A8: for i, j being Element of NAT st i < j & i <= K & j <= K holds DataPart
  SW.i <> DataPart SW.j
  proof
    let i, j be Element of NAT such that
A9: i < j and
    i <= K and
A10: j <= K;
    per cases by A10,XXREAL_0:1;
    suppose
A11:  j = K;
      assume
      DataPart SW.i = DataPart SW.j;
      then SW.i.a <= 0 by A5,A11,SCMFSA6A:38;
      hence contradiction by A6,A9,A11;
    end;
    suppose
A12:  j < K;
      defpred X[Element of NAT] means j+$1 <= K implies DataPart SW.(i+$1) =
      DataPart SW.(j+$1);
A13:  for k being Element of NAT st X[k] holds X[k+1]
      proof
        let k be Element of NAT such that
A14:    j+k <= K implies DataPart SW.(i+k) = DataPart SW.(j+k) and
A15:    j+(k+1) <= K;
A16:    SW.(j+k).intloc 0 = 1 by A1,A2,Th39;
A17:    j+k < (j+k)+1 by XREAL_1:31;
        then
A18:    j+k < K by A15,XXREAL_0:2;
        then
A19:    SW.(j+k).a > 0 by A6;
        then
A20:    I is_closed_on SW.(j+k) by A2,Def4;
        then
A21:    I is_closed_on Initialize SW.(j+k) by A16,Lm7;
A22:    I is_halting_on SW.(j+k) by A2,A19,Def4;
        then
A23:    I is_halting_on Initialize SW.(j+k) by A16,A20,Lm8;
A24:    SW.(i+k).intloc 0 = 1 by A1,A2,Th39;
A25:    SW.(i+k).a > 0
        proof
          assume
          not thesis;
          then
A26:      K <= i+k by A6;
          i+k < j+k by A9,XREAL_1:8;
          hence contradiction by A18,A26,XXREAL_0:2;
        end;
        then
A27:    I is_closed_on SW.(i+k) by A2,Def4;
        then
A28:    I is_closed_on Initialize SW.(i+k) by A24,Lm7;
        I is_halting_on SW.(i+k) by A2,A25,Def4;
        then
A29:    I is_halting_on Initialize SW.(i+k) by A24,A27,Lm8;
        thus DataPart SW.(i+(k+1)) = DataPart SW.(i+k+1)
          .= DataPart IExec(I, SW.(i+k)) by A24,A25,A28,A29,Th38
          .= DataPart IExec(I, SW.(j+k)) by A14,A15,A17,A16,A20,A22,SCMFSA8C
        :46 ,XXREAL_0:2
          .= DataPart SW.(j+k+1) by A16,A19,A21,A23,Th38
          .= DataPart SW.(j+(k+1));
      end;
      consider p being Element of NAT such that
A30:  K = j+p and
      1 <= p by A12,FSM_1:1;
      assume
      DataPart SW.i = DataPart SW.j;
      then
A31:  X[0];
      for k being Element of NAT holds X[k] from NAT_1:sch 1(A31, A13);
      then DataPart SW.(i+p) = DataPart SW.K by A30;
      then
A32:  SW.(i+p).a <= 0 by A5,SCMFSA6A:38;
      i+p < K by A9,A30,XREAL_1:8;
      hence contradiction by A6,A32;
    end;
  end;
A33: for i, j being Element of NAT st i < j & i <= K & j <= K holds SW.i <>
  SW.j
  proof
    let i, j be Element of NAT;
    assume that
A34: i < j and
    i <= K and
A35: j <= K;
    defpred X[Element of NAT] means i < $1 & $1 <= j implies f.(SW.$1) < f.(SW
    .i);
A36: i < K by A34,A35,XXREAL_0:2;
A37: for k being Element of NAT st X[k] holds X[k+1]
    proof
      let k be Element of NAT such that
A38:  i < k & k <= j implies f.(SW.k) < f.(SW.i) and
A39:  i < k+1 and
A40:  k+1 <= j;
A41:  i <= k by A39,NAT_1:13;
      per cases by A41,XXREAL_0:1;
      suppose
A42:    i = k;
        not SW.i.a <= 0 by A6,A36;
        hence thesis by A7,A42;
      end;
      suppose
A43:    i < k;
A44:    k < j by A40,NAT_1:13;
        now
          assume
          SW.k.a <= 0;
          then K <= k by A6;
          hence contradiction by A35,A44,XXREAL_0:2;
        end;
        then f.(SW.(k+1)) < f.(SW.k) by A7;
        hence thesis by A38,A40,A43,NAT_1:13,XXREAL_0:2;
      end;
    end;
    assume
A45: SW.i = SW.j;
A46: X[0];
    for k being Element of NAT holds X[k] from NAT_1:sch 1(A46, A37 );
    hence contradiction by A34,A45;
  end;
  given i, j being Element of NAT such that
A47: i <> j and
A48: i <= ExitsAtWhile>0(a, I, s) & j <= ExitsAtWhile>0(a, I, s) &( SW.i
  = SW. j or DataPart SW.i = DataPart SW.j);
  i < j or j < i by A47,XXREAL_0:1;
  hence contradiction by A4,A33,A8,A48;
end;

definition
  let f be Function of product the Object-Kind of SCM+FSA, NAT;
  attr f is on_data_only means
  :Def7:
  for s1, s2 st DataPart s1 = DataPart s2
  holds f.s1 = f.s2;
end;

theorem Th46:
  s.intloc 0 = 1 & ProperBodyWhile>0 a, Ig, s & WithVariantWhile>0
a, Ig, s implies ex f being Function of product the Object-Kind of SCM+FSA, NAT
st f is on_data_only & for k being Element of NAT holds f.(StepWhile>0(a, Ig, s
  ).(k+1)) < f.(StepWhile>0(a, Ig, s).k) or StepWhile>0(a, Ig, s).k.a <= 0
proof
  set I = Ig;
  assume that
A1: s.intloc 0 = 1 and
A2: ProperBodyWhile>0 a, I, s and
A3: WithVariantWhile>0 a, I, s;
  set SW = StepWhile>0(a,I,s);
  consider K being Element of NAT such that
A4: ExitsAtWhile>0(a, I, s) = K and
A5: SW.K.a <= 0 and
  for i being Element of NAT st SW.i.a <= 0 holds K <= i and
  DataPart Computation((s +* (while>0(a, I) +* SAt)), (LifeSpan (s +* (
  while>0(a, I) +* SAt)))) = DataPart StepWhile>0(a, I, s).K by A2,A3,Def6;
  consider g being Function of product the Object-Kind of SCM+FSA, NAT such
  that
A6: for k being Element of NAT holds g.(SW.(k+1)) < g.(SW.k) or SW.k.a
  <= 0 by A3,Def5;
  defpred P[State of SCM+FSA, set] means (ex k being Element of NAT st k <= K
  & DataPart $1 = DataPart SW.k & $2 = g.(SW.k)) or not (ex k being Element of
  NAT st k <= K & DataPart $1 = DataPart SW.k) & $2 = 0;
A7: for x being State of SCM+FSA ex y being Element of NAT st P[x,y]
  proof
    let x be State of SCM+FSA;
    per cases;
    suppose
      ex k being Element of NAT st k <= K & DataPart x = DataPart SW.k;
      then consider k being Element of NAT such that
A8:   k <= K & DataPart x = DataPart SW.k;
      take g.(SW.k);
      thus thesis by A8;
    end;
    suppose
A9:   not ex k being Element of NAT st k <= K & DataPart x = DataPart
      SW.k;
      take 0;
      thus thesis by A9;
    end;
  end;
  consider f being Function of product the Object-Kind of SCM+FSA, NAT such
  that
A10: for x being State of SCM+FSA holds P[x,f.x] from FUNCT_2:sch 3(A7);
  take f;
  hereby
    let s1, s2 such that
A11: DataPart s1 = DataPart s2;
    ( P[s1, f.s1])& P[s2, f.s2] by A10;
    hence f.s1 = f.s2 by A1,A2,A3,A4,A11,Th45;
  end;
  let k be Element of NAT;
  per cases;
  suppose
A12: k < K;
    then
A13: k+1 <= K by NAT_1:13;
    then consider kk1 being Element of NAT such that
A14: kk1 <= K & DataPart SW.(k+1) = DataPart SW.kk1 and
A15: f.(SW.(k+1))=g.(SW.kk1) by A10;
A16: k+1 = kk1 by A1,A2,A3,A4,A13,A14,Th45;
    consider kk being Element of NAT such that
A17: kk <= K & DataPart SW.k = DataPart SW.kk and
A18: f.(SW.k) = g.(SW.kk) by A10,A12;
    k = kk by A1,A2,A3,A4,A12,A17,Th45;
    hence thesis by A6,A18,A15,A16;
  end;
  suppose
    K <= k;
    then DataPart SW.K = DataPart SW.k by A5,Th43;
    hence thesis by A5,SCMFSA6A:38;
  end;
end;

theorem
  s1.intloc 0 = 1 & DataPart s1 = DataPart s2 & ProperBodyWhile>0 a, Ig,
  s1 & WithVariantWhile>0 a, Ig, s1 implies WithVariantWhile>0 a, Ig, s2
proof
  set I = Ig;
  assume that
A1: s1.intloc 0 = 1 and
A2: DataPart s1 = DataPart s2 and
A3: ProperBodyWhile>0 a, I, s1 and
A4: WithVariantWhile>0 a, I, s1;
  set SW1 = StepWhile>0(a,I,s1);
  consider f being Function of product the Object-Kind of SCM+FSA, NAT such
  that
A5: f is on_data_only and
A6: for k being Element of NAT holds (f.(SW1.(k+1)) < f.(SW1.k) or SW1.k
  .a <= 0 ) by A1,A3,A4,Th46;
  take f;
  let k be Element of NAT;
  set SW2 = StepWhile>0(a,I,s2);
  DataPart SW1.(k+1) = DataPart SW2.(k+1) by A2,A3,Th40;
  then
A7: f.(SW1.(k+1)) = f.(SW2.(k+1)) by A5,Def7;
A8: DataPart SW1.k = DataPart SW2.k by A2,A3,Th40;
  then
A9: SW1.k.a = SW2.k.a by SCMFSA6A:38;
  f.(SW1.k) = f.(SW2.k) by A5,A8,Def7;
  hence thesis by A6,A9,A7;
end;

begin :: fusc using while>0, bottom-up

definition
  let N, result be Int-Location;
  func Fusc_macro ( N, result ) -> Program of SCM+FSA equals
  SubFrom(result,
  result) ';' ((1-stRWNotIn {N, result}) := intloc 0) ';' ((2-ndRWNotIn {N,
result}) := N) ';' while>0 ( 2-ndRWNotIn {N, result}, (3-rdRWNotIn {N, result})
:= 2 ';' Divide(2-ndRWNotIn {N, result}, 3-rdRWNotIn {N, result}) ';' if=0 ( 3
  -rdRWNotIn {N, result}, Macro AddTo(1-stRWNotIn {N, result}, result), Macro
  AddTo(result, 1-stRWNotIn {N, result}) ) );
  correctness;
end;
:: set next = 1-stRWNotIn {N, result};
:: set aux  = 2-ndRWNotIn {N, result};
:: set rem2 = 3-rdRWNotIn {N, result};
:: while and if do not allocate memory, no need to save anything

theorem
  for N, result being read-write Int-Location st N <> result for n being
Element of NAT st n = s.N holds IExec(Fusc_macro(N, result), s).result = Fusc n
  & IExec(Fusc_macro(N, result), s).N = n
proof
  let N, result be read-write Int-Location such that
A1: N <> result;
  set i0 = SubFrom(result, result);
  set rem2 = 3-rdRWNotIn {N, result};
  set aux = 2-ndRWNotIn {N, result};
  set next = 1-stRWNotIn {N, result};
  set I3i0 = rem2 := 2;
  set I3i1 = Divide(aux, rem2);
  set I3I2I0 = Macro AddTo(next, result);
  set I3I2I1 = Macro AddTo(result, next);
  set I3I2 = if=0 ( rem2, I3I2I0, I3I2I1 );
  set I = I3i0 ';' I3i1 ';' I3I2;
  let n be Element of NAT such that
A2: n = s.N;
A3: next <> rem2 by SFMASTR1:22;
A4: aux <> next by SFMASTR1:22;
  set I3 = while>0 ( aux, I );
  deffunc U(Element of product the Object-Kind of SCM+FSA) = abs($1.aux);
  set i2 = aux := N;
  set i1 = next := intloc 0;
  set t = IExec(i0 ';' i1 ';' i2, s);
  set It = Initialize t;
  set SWt = StepWhile>0(aux, I, It);
  defpred X[Element of NAT] means ex au, ne, re being Element of NAT st SWt.$1
.aux = au & SWt.$1.next = ne & SWt.$1.result = re & SWt.$1.N = n & Fusc n = ne
  * Fusc au + re * Fusc (au+1);
  consider f being Function of product the Object-Kind of SCM+FSA,NAT such
  that
A5: for x being Element of product the Object-Kind of SCM+FSA holds f.x
  = U(x) from FUNCT_2:sch 4;
A6: N in {N, result} by TARSKI:def 2;
  then
A7: N <> next by SFMASTR1:21;
A8: result in {N, result} by TARSKI:def 2;
  then
A9: aux <> result by SFMASTR1:21;
A10: result <> rem2 by A8,SFMASTR1:21;
A11: next <> result by A8,SFMASTR1:21;
A12: N <> rem2 by A6,SFMASTR1:21;
A13: N <> aux by A6,SFMASTR1:21;
A14: aux <> rem2 by SFMASTR1:22;
A15: for u being State of SCM+FSA st ex au, ne, re being Element of NAT st u
.aux = au & u.next = ne & u.result = re & u.N = n & Fusc n = ne * Fusc au + re
* Fusc (au+1) ex au1, ne1, re1 being Element of NAT st IExec(I, u).aux = au1 &
IExec(I, u).next = ne1 & IExec(I, u).result = re1 & IExec(I, u).N = n & Fusc n
  = ne1 * Fusc au1 + re1 * Fusc (au1+1) & au1 = u.aux div 2
  proof
    let u be State of SCM+FSA;
    given au, ne, re being Element of NAT such that
A16: u.aux = au and
A17: u.next = ne and
A18: u.result = re and
A19: u.N = n and
A20: Fusc n = ne * Fusc au + re * Fusc (au+1);
A21: (Initialize IExec(I3i0 ';' I3i1, u)).next = IExec(I3i0 ';' I3i1, u).
    next by SCMFSA6C:3
      .= Exec(I3i1, IExec(I3i0, u)).next by SCMFSA6C:7
      .= IExec(I3i0, u).next by A4,A3,SCMFSA_2:93
      .= ne by A17,SCMFSA7B:9,SFMASTR1:22;
A22: (Initialize IExec(I3i0 ';' I3i1, u)).aux = IExec(I3i0 ';' I3i1, u).
    aux by SCMFSA6C:3
      .= Exec(I3i1, IExec(I3i0, u)).aux by SCMFSA6C:7
      .= IExec(I3i0, u).aux div IExec(I3i0, u).rem2 by A14,SCMFSA_2:93
      .= u.aux div IExec(I3i0, u).rem2 by SCMFSA7B:9,SFMASTR1:22
      .= u.aux div 2 by SCMFSA7B:9;
A23: (Initialize IExec(I3i0 ';' I3i1, u)).result = IExec(I3i0 ';' I3i1, u)
    .result by SCMFSA6C:3
      .= Exec(I3i1, IExec(I3i0, u)).result by SCMFSA6C:7
      .= IExec(I3i0, u).result by A9,A10,SCMFSA_2:93
      .= re by A10,A18,SCMFSA7B:9;
A24: (Initialize IExec(I3i0 ';' I3i1, u)).N = IExec(I3i0 ';' I3i1, u).N by
    SCMFSA6C:3
      .= Exec(I3i1, IExec(I3i0, u)).N by SCMFSA6C:7
      .= IExec(I3i0, u).N by A12,A13,SCMFSA_2:93
      .= n by A12,A19,SCMFSA7B:9;
A25: IExec(I3i0 ';' I3i1, u).rem2 = Exec(I3i1, IExec(I3i0, u)).rem2 by
    SCMFSA6C:7
      .= IExec(I3i0, u).aux mod IExec(I3i0, u).rem2 by SCMFSA_2:93
      .= u.aux mod IExec(I3i0, u).rem2 by SCMFSA7B:9,SFMASTR1:22
      .= u.aux mod 2 by SCMFSA7B:9;
    per cases;
    suppose
A26:  au is even;
      reconsider ne1 = ne + re as Element of NAT;
      reconsider au1 = u.aux div 2 as Element of NAT by A16,INT_1:16,82;
      take au1, ne1, re;
      consider k being Element of NAT such that
A27:  au = 2*k by A26,ABIAN:def 2;
A28:  u.aux mod 2 = (2*k + 0) mod 2 by A16,A27
        .= 0 mod 2 by NAT_D:21
        .= 0 by NAT_D:26;
      IExec(I, u).aux = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).aux by
      SCMFSA6C:1
        .= IExec(I3I2I0, IExec(I3i0 ';' I3i1, u)).aux by A25,A28,SCMFSA8B:21
        .= Exec(AddTo(next, result), Initialize IExec(I3i0 ';' I3i1, u)).aux
      by SCMFSA6C:6
        .= u.aux div 2 by A4,A22,SCMFSA_2:90;
      hence IExec(I, u).aux = au1;
      thus IExec(I, u).next = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).next by
      SCMFSA6C:1
        .= IExec(I3I2I0, IExec(I3i0 ';' I3i1, u)).next by A25,A28,SCMFSA8B:
      21
        .= Exec(AddTo(next, result), Initialize IExec(I3i0 ';' I3i1, u)).
      next by SCMFSA6C:6
        .= ne1 by A21,A23,SCMFSA_2:90;
      thus IExec(I, u).result = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).result by
      SCMFSA6C:1
        .= IExec(I3I2I0, IExec(I3i0 ';' I3i1, u)).result by A25,A28,SCMFSA8B
      :21
        .= Exec(AddTo(next, result), Initialize IExec(I3i0 ';' I3i1, u)).
      result by SCMFSA6C:6
        .= re by A11,A23,SCMFSA_2:90;
      thus IExec(I, u).N = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).N by SCMFSA6C:
      1
        .= IExec(I3I2I0, IExec(I3i0 ';' I3i1, u)).N by A25,A28,SCMFSA8B:21
        .= Exec(AddTo(next, result), Initialize IExec(I3i0 ';' I3i1, u)).N
      by SCMFSA6C:6
        .= n by A7,A24,SCMFSA_2:90;
      au1 = k by A16,A27,NAT_D:20;
      hence Fusc n = ne1 * Fusc au1 + re * Fusc (au1+1) by A20,A27, PRE_FF:
      22;
      thus thesis;
    end;
    suppose
A29:  au is odd;
      reconsider re1 = ne + re as Element of NAT;
      reconsider au1 = u.aux div 2 as Element of NAT by A16,INT_1:16,82;
      take au1, ne, re1;
      consider k being Element of NAT such that
A30:  au = 2*k +1 by A29,ABIAN:9;
A31:  u.aux mod 2 = 1 mod 2 by A16,A30,NAT_D:21
        .= 1 by NAT_D:24;
      IExec(I, u).aux = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).aux by
      SCMFSA6C:1
        .= IExec(I3I2I1, IExec(I3i0 ';' I3i1, u)).aux by A25,A31,SCMFSA8B:21
        .= Exec(AddTo(result, next), Initialize IExec(I3i0 ';' I3i1, u)).aux
      by SCMFSA6C:6
        .= u.aux div 2 by A9,A22,SCMFSA_2:90;
      hence IExec(I, u).aux = au1;
      thus IExec(I, u).next = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).next by
      SCMFSA6C:1
        .= IExec(I3I2I1, IExec(I3i0 ';' I3i1, u)).next by A25,A31,SCMFSA8B:
      21
        .= Exec(AddTo(result, next), Initialize IExec(I3i0 ';' I3i1, u)).
      next by SCMFSA6C:6
        .= ne by A11,A21,SCMFSA_2:90;
      thus IExec(I, u).result = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).result by
      SCMFSA6C:1
        .= IExec(I3I2I1, IExec(I3i0 ';' I3i1, u)).result by A25,A31,SCMFSA8B
      :21
        .= Exec(AddTo(result, next), Initialize IExec(I3i0 ';' I3i1, u)).
      result by SCMFSA6C:6
        .= re1 by A21,A23,SCMFSA_2:90;
      thus IExec(I, u).N = IExec(I3I2, IExec(I3i0 ';' I3i1, u)).N by SCMFSA6C:
      1
        .= IExec(I3I2I1, IExec(I3i0 ';' I3i1, u)).N by A25,A31,SCMFSA8B:21
        .= Exec(AddTo(result, next), Initialize IExec(I3i0 ';' I3i1, u)).N
      by SCMFSA6C:6
        .= n by A1,A24,SCMFSA_2:90;
      au1 = 2*k div 2 by A16,A30,NAT_2:28
        .= k by NAT_D:20;
      hence Fusc n = ne * Fusc au1 + re1 * Fusc (au1+1) by A20,A30, PRE_FF:
      21;
      thus thesis;
    end;
  end;
A32: It.intloc 0 = 1 by SCMFSA6C:3;
A33: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT;
    given au, ne, re being Element of NAT such that
A34: SWt.k.aux = au and
A35: SWt.k.next = ne and
A36: SWt.k.result = re and
A37: SWt.k.N = n and
A38: Fusc n = ne * Fusc au + re * Fusc (au+1);
A39: SWt.k.intloc 0 = 1 by A32,Th39;
    per cases;
    suppose
A40:  SWt.k.aux > 0;
      consider au1, ne1, re1 being Element of NAT such that
A41:  IExec(I, SWt.k).aux = au1 and
A42:  IExec(I, SWt.k).next = ne1 and
A43:  IExec(I, SWt.k).result = re1 and
A44:  IExec(I, SWt.k).N = n and
A45:  Fusc n = ne1 * Fusc au1 + re1 * Fusc (au1+1) and
      au1 = SWt.k.aux div 2 by A15,A34,A35,A36,A37,A38;
      take au1, ne1, re1;
A46:  DataPart SWt.(k+1) = DataPart IExec(I, SWt.k) by A39,A40,Th38;
      hence SWt.(k+1).aux = au1 by A41,SCMFSA6A:38;
      thus SWt.(k+1).next = ne1 by A46,A42,SCMFSA6A:38;
      thus SWt.(k+1).result = re1 by A46,A43,SCMFSA6A:38;
      thus SWt.(k+1).N = n by A46,A44,SCMFSA6A:38;
      thus thesis by A45;
    end;
    suppose
A47:  SWt.k.aux <= 0;
      take au, ne, re;
A48:  DataPart SWt.(k+1) = DataPart SWt.k by A47,Th37;
      hence SWt.(k+1).aux = au by A34,SCMFSA6A:38;
      thus SWt.(k+1).next = ne by A35,A48,SCMFSA6A:38;
      thus SWt.(k+1).result = re by A36,A48,SCMFSA6A:38;
      thus SWt.(k+1).N = n by A37,A48,SCMFSA6A:38;
      thus thesis by A38;
    end;
  end;
  t.intloc 0 = 1 by SCMFSA6B:35;
  then
A49: DataPart t = DataPart It by SCMFSA8C:27;
A50: X[0]
  proof
    take au = n;
    take ne = 1;
    take re = 0;
A51: SWt.0 = It by SCMFSA_9:def 5;
    hence SWt.0.aux = t.aux by A49,SCMFSA6A:38
      .= Exec(i2, IExec(i0 ';' i1, s)).aux by SCMFSA6C:7
      .= IExec(i0 ';' i1, s).N by SCMFSA_2:89
      .= Exec(i1, Exec(i0, Initialize s)).N by SCMFSA6C:9
      .= Exec(i0, Initialize s).N by A7,SCMFSA_2:89
      .= (Initialize s).N by A1,SCMFSA_2:91
      .= au by A2,SCMFSA6C:3;
    thus SWt.0.next = t.next by A49,A51,SCMFSA6A:38
      .= Exec(i2, IExec(i0 ';' i1, s)).next by SCMFSA6C:7
      .= IExec(i0 ';' i1, s).next by A4,SCMFSA_2:89
      .= Exec(i1, Exec(i0, Initialize s)).next by SCMFSA6C:9
      .= Exec(i0, Initialize s).intloc 0 by SCMFSA_2:89
      .= (Initialize s).intloc 0 by SCMFSA_2:91
      .= ne by SCMFSA6C:3;
    thus SWt.0.result = t.result by A49,A51,SCMFSA6A:38
      .= Exec(i2, IExec(i0 ';' i1, s)).result by SCMFSA6C:7
      .= IExec(i0 ';' i1, s).result by A9,SCMFSA_2:89
      .= Exec(i1, Exec(i0, Initialize s)).result by SCMFSA6C:9
      .= Exec(i0, Initialize s).result by A11,SCMFSA_2:89
      .= (Initialize s).result - (Initialize s).result by SCMFSA_2:91
      .= re;
    thus SWt.0.N = t.N by A49,A51,SCMFSA6A:38
      .= Exec(i2, IExec(i0 ';' i1, s)).N by SCMFSA6C:7
      .= IExec(i0 ';' i1, s).N by A13,SCMFSA_2:89
      .= Exec(i1, Exec(i0, Initialize s)).N by SCMFSA6C:9
      .= Exec(i0, Initialize s).N by A7,SCMFSA_2:89
      .= (Initialize s).N by A1,SCMFSA_2:91
      .= n by A2,SCMFSA6C:3;
    thus thesis;
  end;
A52: for k being Element of NAT holds X[k] from NAT_1:sch 1(A50, A33);
  for k being Element of NAT holds f.(SWt.(k+1)) < f.(SWt.k) or SWt.k.aux
  <= 0
  proof
    let k be Element of NAT;
    consider au, ne, re being Element of NAT such that
A53: SWt.k.aux = au and
A54: SWt.k.next = ne & SWt.k.result = re & SWt.k.N = n & Fusc n = ne *
    Fusc au + re * Fusc (au+1) by A52;
A55: f.(SWt.k) = abs(SWt.k.aux) by A5
      .= au by A53,ABSVALUE:def 1;
    now
      consider au1, ne1, re1 being Element of NAT such that
A56:  IExec(I, SWt.k).aux = au1 and
      IExec(I, SWt.k).next = ne1 and
      IExec(I, SWt.k).result = re1 and
      IExec(I, SWt.k).N = n and
      Fusc n = ne1 * Fusc au1 + re1 * Fusc (au1+1) and
A57:  au1 = SWt.k.aux div 2 by A15,A53,A54;
      assume
A58:  au > 0;
      SWt.k.intloc 0 = 1 by A32,Th39;
      then DataPart SWt.(k+1) = DataPart IExec(I, SWt.k) by A53,A58,Th38;
      then
A59:  SWt.(k+1).aux = au1 by A56,SCMFSA6A:38;
      f.(SWt.(k+1)) = abs(SWt.(k+1).aux) by A5
        .= au1 by A59,ABSVALUE:def 1;
      hence f.(SWt.(k+1)) < f.(SWt.k) by A53,A55,A58,A57,INT_1:83;
    end;
    hence thesis by A53;
  end;
  then
A60: WithVariantWhile>0 aux, I, It by Def5;
  then consider k being Element of NAT such that
A61: ExitsAtWhile>0(aux, I, It) = k and
A62: (StepWhile>0(aux, I, It).k).aux <= 0 and
  for i being Element of NAT st SWt.i.aux <= 0 holds k <= i and
  DataPart (Computation((It +* (while>0(aux, I) +* SAt)), (LifeSpan (It +*
  (while>0(aux, I) +* SAt))))) = DataPart StepWhile>0(aux, I, It).k by Def6;
A63: DataPart IExec(I3, t) = DataPart SWt.k by A60,A61,Th42;
  consider au, ne, re being Element of NAT such that
A64: SWt.k.aux = au and
  SWt.k.next = ne and
A65: SWt.k.result = re and
A66: SWt.k.N = n and
A67: Fusc n = ne * Fusc au + re * Fusc (au+1) by A52;
A68: au = 0 by A62,A64;
  I3 is_closed_on It & I3 is_halting_on It by A60,Th34;
  then
A69: I3 is_closed_on t & I3 is_halting_on t by A49,SCMFSA8B:8;
  hence IExec(Fusc_macro(N, result), s).result = IExec(I3, t).result by
  SFMASTR1:8
    .= Fusc n by A65,A67,A68,A63,PRE_FF:17,SCMFSA6A:38;
  thus IExec(Fusc_macro(N, result), s).N = IExec(I3, t).N by A69,SFMASTR1:8
    .= n by A66,A63,SCMFSA6A:38;
end;

