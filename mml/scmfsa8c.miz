:: The {\bf loop} and {\bf Times} Macroinstruction for {\SCMFSA}
::  by Noriko Asamoto
::
:: Received October 29, 1997
:: Copyright (c) 1997 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, FSM_1, SCMFSA_2, CAT_1, AMI_1, SCMFSA8A,
      XXREAL_0, CIRCUIT2, FUNCT_4, CARD_1, RELAT_1, ARYTM_3, AMISTD_2, GRAPHSP,
      AMI_3, SCMNORM, TARSKI, VALUED_1, CARD_3, FUNCT_1, ARYTM_1, TURING_1,
      SCMFSA6C, FUNCOP_1, SCMFSA6A, SCMFSA6B, XBOOLE_0, MSUALG_1, UNIALG_2,
      SCMFSA7B, GLIB_000, SF_MASTR, STRUCT_0, NAT_1, SCMFSA8B, FUNCT_7,
      SCMFSA8C, ORDINAL1, PARTFUN1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, FUNCOP_1, RELAT_1, FUNCT_1, PARTFUN1,
      FUNCT_4, FUNCT_7, CARD_3, VALUED_1, AFINSQ_1,
      STRUCT_0, AMI_1, SCMNORM, SCMFSA_2, SCMFSA_4, SCMFSA_5, SF_MASTR,
      SCMFSA6A, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B, NAT_D,
      XXREAL_0;
 constructors PARTFUN1, DOMAIN_1, XXREAL_0, REAL_1, NAT_1, SCMFSA_5, SCMFSA6A,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMNORM, SCMFSA_4,
      AFINSQ_1, NAT_D, RELSET_1, PRE_POLY, SCMFSA_1, SCMFSA_7;
 registrations SETFAM_1, FUNCT_1, RELSET_1, FUNCOP_1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, CARD_3, AMI_1, SCMFSA_2, SCMFSA6A, SF_MASTR,
      SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, ORDINAL1, XBOOLE_0, SCMNORM,
      AFINSQ_1, VALUED_1, FUNCT_4, RELAT_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, AMI_1, SCMFSA_2, SCMFSA8A, SCMFSA6A, SCMNORM;
 theorems FUNCT_4, SCMFSA_4, SCMFSA6A, SCMFSA8B, AMI_1, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SF_MASTR, NAT_1, SCMFSA6B, GRFUNC_1, SCMFSA_2, SCMFSA_5,
      FUNCT_1, FUNCT_7, TARSKI, ENUMSET1, FUNCOP_1, RELAT_1, CARD_1, SCMFSA_3,
      INT_1, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0, VALUED_1,
      SCMNORM, AFINSQ_1, XREAL_0, PBOOLE, PARTFUN1;
 schemes NAT_1;

begin :: Preliminaries

reserve m for Element of NAT;

canceled;

theorem Th2:
  for s being State of SCM+FSA,P being initial FinPartState of
  SCM+FSA st P is_pseudo-closed_on s for k being Element of NAT st (for n being
Element of NAT st n <= k
 holds IC Comput(ProgramPart( (s +* (P +* Start-At( 0,SCM+FSA)))), (s +* (P +*
Start-At( 0,SCM+FSA))),
  n) in dom P) holds k < pseudo-LifeSpan(s,P)
proof
  let s be State of SCM+FSA;
  let P be initial FinPartState of SCM+FSA;
  assume
  P is_pseudo-closed_on s;
  then
  IC Comput(ProgramPart( (s +* (P +*
   Start-At( 0,SCM+FSA)))), (s +* (P +*
   Start-At( 0,SCM+FSA))),pseudo-LifeSpan(s,P)) =
   card ProgramPart P by SCMFSA8A:def 5;
  then
A1: not IC Comput(ProgramPart( (s +* (P +* Start-At( 0,SCM+FSA)))), (s +* (P +*
Start-At( 0,SCM+FSA))),
 pseudo-LifeSpan(s,
  P)) in dom ProgramPart P by AFINSQ_1:70;
  let k be Element of NAT;
  assume
A2: for n being Element of NAT st n <= k holds IC Comput(ProgramPart( (s +* (P
  +* Start-At( 0,SCM+FSA)))), (s +* (P
  +* Start-At( 0,SCM+FSA))),n) in dom P;
  assume
  pseudo-LifeSpan(s,P) <= k;
  hence contradiction by A2,A1,AMI_1:106;
end;

canceled 5;

theorem Th8:
  for i being Instruction of SCM+FSA holds IncAddr(i,0) = i
proof
  let i be Instruction of SCM+FSA;
A1: InsCode i <= 11 + 1 by SCMFSA_2:35;
A2: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A3: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
  per cases by A1,A2,A3,NAT_1:8,33;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:122;
    hence thesis by SCMFSA_4:8;
  end;
  suppose
    InsCode i = 1;
    then ex a,b being Int-Location st i = a:=b by SCMFSA_2:54;
    hence thesis by SCMFSA_4:9;
  end;
  suppose
    InsCode i = 2;
    then ex a,b being Int-Location st i = AddTo(a,b) by SCMFSA_2:55;
    hence thesis by SCMFSA_4:10;
  end;
  suppose
    InsCode i = 3;
    then ex a,b being Int-Location st i = SubFrom(a,b) by SCMFSA_2:56;
    hence thesis by SCMFSA_4:11;
  end;
  suppose
    InsCode i = 4;
    then ex a,b being Int-Location st i = MultBy(a,b) by SCMFSA_2:57;
    hence thesis by SCMFSA_4:12;
  end;
  suppose
    InsCode i = 5;
    then ex a,b being Int-Location st i = Divide(a,b) by SCMFSA_2:58;
    hence thesis by SCMFSA_4:13;
  end;
  suppose
    InsCode i = 6;
    then consider l being Element of NAT such that
A4: i = goto l by SCMFSA_2:59;
    thus IncAddr(i,0) = goto (l + 0) by A4,SCMFSA_4:14
      .= i by A4;
  end;
  suppose
    InsCode i = 7;
    then consider
    l being Element of NAT,a being Int-Location such
    that
A5: i = a =0_goto l by SCMFSA_2:60;
    thus IncAddr(i,0) = a =0_goto (l + 0) by A5,SCMFSA_4:15
      .= i by A5;
  end;
  suppose
    InsCode i = 8;
    then consider
    l being Element of NAT,a being Int-Location such
    that
A6: i = a >0_goto l by SCMFSA_2:61;
    thus IncAddr(i,0) = a >0_goto (l + 0) by A6,SCMFSA_4:16
      .= i by A6;
  end;
  suppose
    InsCode i = 9;
    then ex a,b being Int-Location,f being FinSeq-Location st i = b:=(f,a) by
SCMFSA_2:62;
    hence thesis by SCMFSA_4:17;
  end;
  suppose
    InsCode i = 10;
    then ex a,b being Int-Location,f being FinSeq-Location st i = (f,a):=b by
SCMFSA_2:63;
    hence thesis by SCMFSA_4:18;
  end;
  suppose
    InsCode i = 11;
    then ex a being Int-Location,f being FinSeq-Location st i = a:=len f by
SCMFSA_2:64;
    hence thesis by SCMFSA_4:19;
  end;
  suppose
    InsCode i = 12;
    then ex a being Int-Location,f being FinSeq-Location st i = f:=<0,...,0>a
    by SCMFSA_2:65;
    hence thesis by SCMFSA_4:20;
  end;
end;

theorem Th9:
  for P being preProgram of SCM+FSA holds ProgramPart Relocated(P,0
  ) = P
proof
  let P be preProgram of SCM+FSA;
  now
    let x be set;
    hereby
      assume
A1:   x in dom P;
      dom P c= NAT by RELAT_1:def 18;
      then reconsider l = x as Element of NAT by A1;
      reconsider n = l as Element of NAT;
      l =  n;
      hence x in {m: m in dom P} by A1;
    end;
    assume
    x in {m: m in dom P};
    then ex m being Element of NAT st x = m & m in dom P;
    hence x in dom P;
  end;
  then
A2: dom P = {m: m in dom P} by TARSKI:2;
A3: dom ProgramPart P = dom P by AMI_1:105;
  now
    let x be set;
A4: dom ProgramPart Relocated(P,0) = {m + 0: m in dom P} by A3,SCMFSA_5:3;
    hereby
      assume
      x in dom ProgramPart Relocated(P,0);
      then ex n be Element of NAT st x = n + 0 & n in dom P by A4;
      hence x in { m: m in dom P};
    end;
    assume
    x in {m: m in dom P};
    then consider m being Element of NAT such that
A5: x = m and
A6: m in dom P;
    x =  (m + 0) by A5;
    hence x in dom ProgramPart Relocated(P,0) by A4,A6;
  end;
  then
A7: dom ProgramPart Relocated(P,0) = {m:m in dom P} by TARSKI:2;
  now
    let x be set;
    assume
    x in {m:m in dom P};
    then consider n being Element of NAT such that
A8: x = n and
A9: n in dom P;
A10:  n in dom ProgramPart P by A9,AMI_1:105;
    dom Shift(ProgramPart P,0) = {m + 0: m in dom ProgramPart P} by
VALUED_1:def 12;
    then
A11:  (n + 0) in dom Shift(ProgramPart P,0) by A3,A9;
    then
A12: pi(Shift(ProgramPart P,0),n + 0) = Shift(ProgramPart P,0). (n
    + 0) by AMI_1:def 47
      .= (ProgramPart P). n by A10,VALUED_1:def 12
      .= P. n by AMI_1:105;
    then consider i being Instruction of SCM+FSA such that
A13: i = P. n;
    thus (ProgramPart Relocated(P,0)).x = IncAddr(Shift(ProgramPart P,0),0).
     (n + 0) by A8,SCMFSA_5:2
      .= IncAddr(i,0) by A11,A12,A13,SCMFSA_4:def 6
      .= P.x by A8,A13,Th8;
  end;
  hence thesis by A2,A7,FUNCT_1:9;
end;

canceled 2;

theorem Th12:
  for P,Q being FinPartState of SCM+FSA, k being Element of NAT st
  P c= Q holds ProgramPart Relocated(P,k) c= ProgramPart Relocated(Q,k)
proof
  let P,Q be FinPartState of SCM+FSA;
  let k be Element of NAT;
  set rP = Relocated(P,k);
  set rQ = Relocated(Q,k);
A1: dom ProgramPart rP = {m + k: m in dom ProgramPart P} by SCMFSA_5:3;
A2: dom Shift(ProgramPart P,k) = {m + k: m in dom ProgramPart P} by
VALUED_1:def 12;
A3: dom Shift(ProgramPart Q,k) = {m + k: m in dom ProgramPart Q} by
VALUED_1:def 12;
  assume
  P c= Q;
  then
A4: ProgramPart P c= ProgramPart Q by RELAT_1:105;
  then
A5: Shift(ProgramPart P,k) c= Shift(ProgramPart Q,k) by VALUED_1:21;
A6: dom ProgramPart P c= dom ProgramPart Q by A4,GRFUNC_1:8;
A7: now
    let x be set;
    assume
    x in dom ProgramPart rP;
    then consider m1 being Element of NAT such that
A8: x = m1 + k and
A9: m1 in dom ProgramPart P by A1;
A10:  (m1 + k) in dom Shift(ProgramPart Q,k) by A6,A3,A9;
A11:  (m1 + k) in dom Shift(ProgramPart P,k) by A2,A9;
    then
A12: pi(Shift(ProgramPart P,k),m1 + k) = Shift(ProgramPart P,k). (
    m1 + k) by AMI_1:def 47
      .= Shift(ProgramPart Q,k). (m1 + k) by A5,A11,GRFUNC_1:8
      .= pi(Shift(ProgramPart Q,k),m1 + k) by A10,AMI_1:def 47;
    thus (ProgramPart rP).x = IncAddr(Shift(ProgramPart P,k),k). (m1 +
    k) by A8,SCMFSA_5:2
      .= IncAddr(pi(Shift(ProgramPart Q,k),m1 + k),k) by A11,A12,SCMFSA_4:def 6
      .= IncAddr(Shift(ProgramPart Q,k),k). (m1 + k) by A10,SCMFSA_4:def 6
      .= (ProgramPart rQ).x by A8,SCMFSA_5:2;
  end;
A13: ProgramPart rQ = IncAddr(Shift(ProgramPart Q,k),k) by SCMFSA_5:2;
A14: ProgramPart rP = IncAddr(Shift(ProgramPart P,k),k) by SCMFSA_5:2;
A15: dom Shift(ProgramPart P,k) c= dom Shift(ProgramPart Q,k) by A5,GRFUNC_1:8;
  now
    let x be set;
    assume
    x in dom ProgramPart rP;
    then x in dom Shift(ProgramPart P,k) by A14,SCMFSA_4:def 6;
    then x in dom Shift(ProgramPart Q,k) by A15;
    hence x in dom ProgramPart rQ by A13,SCMFSA_4:def 6;
  end;
  then dom ProgramPart rP c= dom ProgramPart rQ by TARSKI:def 3;
  hence thesis by A7,GRFUNC_1:8;
end;

theorem Th13:
  for I,J being Program of SCM+FSA, k being Element of NAT st card
I <= k & k < card I + card J holds for i being Instruction of SCM+FSA st i = J.
   (k -' card I) holds (I ';' J). k = IncAddr(i,card I)
proof
  let I,J be Program of SCM+FSA;
  let k be Element of NAT;
  assume
A1: card I <= k;
  assume
  k < card I + card J;
  then
A2: k + 0 < card J + card I;
A3: ProgramPart J = J by AMI_1:105;
  k -' card I = k - card I by A1,XREAL_1:235;
  then k -' card I < card J - 0 by A2,XREAL_1:23;
  then
A4:  (k -' card I) in dom ProgramPart J by A3,AFINSQ_1:70;
  let i be Instruction of SCM+FSA;
  assume
A5: i = J. (k -' card I);
A6: k -' card I + card I = k - card I + card I by A1,XREAL_1:235
    .= k;
  then  k in {m + card I: m in dom ProgramPart J} by A4;
  then
A7:  k in dom ProgramPart Relocated(J, card I) by SCMFSA_5:3;
  hence (I ';' J). k = (ProgramPart Relocated(J,card I)). k by FUNCT_4:14
    .= Relocated(J,card I). k by A7,SCMFSA6A:64
    .= IncAddr(i,card I) by A5,A4,A6,SCMFSA_5:7;
end;

theorem Th14:
  for s being State of SCM+FSA st s.intloc 0 = 1 & IC s =  0
  holds Initialize s = s
proof
  let s be State of SCM+FSA;
  assume
A1: s.intloc 0 = 1;
  assume
A2: IC s =  0;
A3: IC SCM+FSA in dom s by AMI_1:94;
A4: intloc 0 in dom s by SCMFSA_2:66;
  thus Initialize s = s +* (intloc 0 .--> 1) +* Start-At( 0,SCM+FSA) by
SCMFSA6C:def 3
    .= s +* (IC SCM+FSA .-->  0) by A1,A4,FUNCT_7:111
    .= s by A2,A3,FUNCT_7:111;
end;

theorem Th15:
  for s being State of SCM+FSA holds Initialize Initialize s =
  Initialize s
proof
  let s be State of SCM+FSA;
A1: IC Initialize s =  0 by SCMFSA6C:3;
  (Initialize s).intloc 0 = 1 by SCMFSA6C:3;
  hence thesis by A1,Th14;
end;

theorem Th16:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
   s +* (Initialized I +* Start-At( 0,SCM+FSA)) =
    Initialize s +* (I +* Start-At( 0,SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  Start-At( 0,SCM+FSA) c= Initialized I by SCMFSA6B:4;
  hence s +* (Initialized I +* Start-At( 0,SCM+FSA)) =
  s +* Initialized I by FUNCT_4:79
    .= Initialize s +* (I +* Start-At( 0,SCM+FSA)) by SCMFSA8A:13;
end;

theorem Th17:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  IExec(I,s) = IExec(I,Initialize s)
proof
  let s be State of SCM+FSA;
  set A = NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
A1: for x be set st x in A holds s.x = (Initialize s).x by SCMFSA6C:3;
  dom Initialize s = D \/ {IC SCM+FSA} \/ A by SCMFSA6A:34;
  then
A2: A c= dom Initialize s by XBOOLE_1:7;
  dom s = D \/ {IC SCM+FSA} \/ A by SCMFSA6A:34;
  then A c= dom s by XBOOLE_1:7;
  then
A3: s | A = (Initialize s) | A by A2,A1,FUNCT_1:165;
X: Initialize s +* Initialized I = s +* Initialized I by SCMFSA8A:8;
  thus IExec(I,s) = Result(ProgramPart(s +* Initialized I),s +* Initialized I)
+* s | A by SCMFSA6B:def 1
    .= Result(ProgramPart(Initialize s +* Initialized I),Initialize s +*
Initialized I) +* s | A by X
    .= IExec(I,Initialize s) by A3,SCMFSA6B:def 1;
end;

theorem Th18:
  for s being State of SCM+FSA, I being Program of SCM+FSA st s.
  intloc 0 = 1 holds s +* (I +* Start-At( 0,SCM+FSA)) =
  s +* Initialized I
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
A1: intloc 0 in dom s by SCMFSA_2:66;
  assume
  s.intloc 0 = 1;
  then
A2: s = s +* (intloc 0 .--> 1) by A1,FUNCT_7:111;
  thus s +* Initialized I = Initialize s +* (I +*
  Start-At( 0,SCM+FSA)) by SCMFSA8A:13
    .= Initialize s +* I +* Start-At( 0,SCM+FSA) by FUNCT_4:15
    .= Initialize s +* Start-At( 0,SCM+FSA) +* I by SCMFSA6B:14
    .= s +* Start-At( 0,SCM+FSA) +* Start-At( 0,SCM+FSA) +* I
     by A2,SCMFSA6C:def 3
    .= s +* (Start-At( 0,SCM+FSA) +* Start-At( 0,SCM+FSA)) +* I
    by FUNCT_4:15
    .= s +* I +* Start-At( 0,SCM+FSA) by SCMFSA6B:14
    .= s +* (I +* Start-At( 0,SCM+FSA)) by FUNCT_4:15;
end;

theorem Th19:
  for I being Program of SCM+FSA holds I +* Start-At( 0,SCM+FSA) c=
  Initialized I
proof
  let I be Program of SCM+FSA;
A1: Start-At( 0,SCM+FSA) c= Initialized I by SCMFSA6B:4;
  I c= Initialized I by SCMFSA6A:26;
  hence thesis by A1,FUNCT_4:92;
end;

theorem Th20:
  for l being Element of NAT, I being Program of
  SCM+FSA holds l in dom I iff l in dom Initialized I
proof
  let l be Element of NAT;
  let I be Program of SCM+FSA;
A2: (Initialized I) | NAT = I by SCMFSA6A:33;
  dom ((Initialized I) | NAT) c= dom Initialized I by RELAT_1:89;
  hence l in dom I implies l in dom Initialized I by A2;
A3: dom ((Initialized I) | NAT) = dom Initialized I /\ NAT by RELAT_1:90;
  assume
  l in dom Initialized I;
  hence thesis by A2,A3,XBOOLE_0:def 4;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  Initialized I is_closed_on s iff I is_closed_on Initialize s
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  hereby
    assume
A1: Initialized I is_closed_on s;
    now
      let k be Element of NAT;
X:  s +* (Initialized I +* Start-At( 0,SCM+FSA)) =
    Initialize s +* (I +* Start-At( 0,SCM+FSA)) by Th16;
      IC Comput(ProgramPart( (s +* (Initialized I +* Start-At( 0,SCM+FSA)))), (
s +* (Initialized I +* Start-At( 0,SCM+FSA))),k)
       in
      dom Initialized I by A1,SCMFSA7B:def 7;
      then
      IC Comput(ProgramPart( (Initialize s +* (I +* Start-At( 0,SCM+FSA)))), (
Initialize s +* (I +* Start-At( 0,SCM+FSA))),k)
       in dom
      Initialized I by X;
      hence IC Comput(ProgramPart( (Initialize s +* (I +*
      Start-At( 0,SCM+FSA)))), (Initialize s +* (I +*
      Start-At( 0,SCM+FSA))),k) in
      dom I by Th20;
    end;
    hence I is_closed_on Initialize s by SCMFSA7B:def 7;
  end;
  assume
A2: I is_closed_on Initialize s;
  now
    let k be Element of NAT;
X:  s +* (Initialized I +* Start-At( 0,SCM+FSA)) =
    Initialize s +* (I +* Start-At( 0,SCM+FSA)) by Th16;
    IC Comput(ProgramPart( (Initialize s +* (I +* Start-At( 0,SCM+FSA)))), (
Initialize s +* (I +* Start-At( 0,SCM+FSA))),k)
     in dom I
    by A2,SCMFSA7B:def 7;
    then IC Comput(ProgramPart( (Initialize s +* (I +* Start-At( 0,SCM+FSA)))),
(Initialize s +* (I +* Start-At( 0,SCM+FSA))),k)
     in dom
    Initialized I by Th20;
    hence
    IC Comput(ProgramPart( (s +* (Initialized I +* Start-At( 0,SCM+FSA)))), (s
+* (Initialized I +* Start-At( 0,SCM+FSA))),k)
     in dom
    Initialized I by X;
  end;
  hence thesis by SCMFSA7B:def 7;
end;

theorem Th22:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  Initialized I is_halting_on s iff I is_halting_on Initialize s
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
X:  s +* (Initialized I +* Start-At( 0,SCM+FSA))
    = Initialize s +* (I +* Start-At( 0,SCM+FSA)) by Th16;
  hereby
    assume
    Initialized I is_halting_on s;
    then ProgramPart(s +* (Initialized I +* Start-At( 0,SCM+FSA)))
     halts_on s +* (Initialized I +* Start-At( 0,SCM+FSA))
     by SCMFSA7B:def 8;
    then  ProgramPart(Initialize s +* (I +* Start-At( 0,SCM+FSA)))
   halts_on Initialize s +* (I +* Start-At( 0,SCM+FSA)) by X;
    hence I is_halting_on Initialize s by SCMFSA7B:def 8;
  end;
  assume
  I is_halting_on Initialize s;
  then ProgramPart(Initialize s +* (I +* Start-At( 0,SCM+FSA)))
   halts_on Initialize s +* (I +* Start-At( 0,SCM+FSA))
   by SCMFSA7B:def 8;
  then  ProgramPart(s +* (Initialized I +* Start-At( 0,SCM+FSA)))
     halts_on s +* (Initialized I +* Start-At( 0,SCM+FSA)) by X;
  hence thesis by SCMFSA7B:def 8;
end;

theorem
  for I being Program of SCM+FSA holds (for s being State of SCM+FSA
  holds I is_halting_on Initialize s) implies Initialized I is halting
proof
  let I be Program of SCM+FSA;
  assume
A1: for s being State of SCM+FSA holds I is_halting_on Initialize s;
  now
    let s be State of SCM+FSA;
    I is_halting_on Initialize s by A1;
    then
X:   ProgramPart(Initialize s +* (I +* Start-At( 0,SCM+FSA)))
     halts_on Initialize s +* (I +* Start-At( 0,SCM+FSA))
     by SCMFSA7B:def 8;
    Initialize s +* (I +* Start-At( 0,SCM+FSA)) = s +* Initialized I
                      by SCMFSA8A:13;
    then
A2: ProgramPart(s +* Initialized I)
      halts_on s +* Initialized I by X;
    assume Initialized I c= s;
     then s +* Initialized I = s by FUNCT_4:79;
    hence ProgramPart s halts_on s by A2;
  end;
  hence thesis by AMI_1:def 26;
end;

theorem Th24:
  for I being Program of SCM+FSA holds (for s being State of
  SCM+FSA holds Initialized I is_halting_on s) implies Initialized I is halting
proof
  let I be Program of SCM+FSA;
  assume
A1: for s being State of SCM+FSA holds Initialized I is_halting_on s;
  now
    let s be State of SCM+FSA;
    Start-At( 0,SCM+FSA) c= Initialized I by SCMFSA6B:4;
    then
A2: s +* (Initialized I +* Start-At( 0,SCM+FSA)) = s +* Initialized I by
FUNCT_4:79;
    Initialized I is_halting_on s by A1;
    then
A3: ProgramPart(s +* (Initialized I +* Start-At( 0,SCM+FSA)))
     halts_on s +* (Initialized I +* Start-At( 0,SCM+FSA))
            by SCMFSA7B:def 8;
    assume Initialized I c= s;
     then s +* (Initialized I +* Start-At( 0,SCM+FSA)) = s
     by A2,FUNCT_4:79;
    hence ProgramPart s halts_on s by A3;
  end;
  hence thesis by AMI_1:def 26;
end;

theorem
  for I being Program of SCM+FSA holds ProgramPart Initialized I = I by
SCMFSA6A:33;

theorem Th26:
  for s being State of SCM+FSA, I being Program of SCM+FSA, l
being Element of NAT, x being set holds x in dom I implies I.x
  = (s +* (I +* Start-At(l,SCM+FSA))).x
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let l be Element of NAT;
  let x be set;
  assume
A1: x in dom I;
  dom I c= NAT by RELAT_1:def 18;
  then reconsider y = x as Element of NAT by A1;
A2: not y in dom Start-At(l,SCM+FSA) by AMI_1:137;
  x in dom (I +* Start-At(l,SCM+FSA)) by A1,FUNCT_4:13;
  hence (s +* (I +* Start-At(l,SCM+FSA))).x = (I +* Start-At(l,SCM+FSA)).x
  by FUNCT_4:14
    .= I.x by A2,FUNCT_4:12;
end;

theorem Th27:
  for s being State of SCM+FSA st s.intloc 0 = 1 holds DataPart
  Initialize s = DataPart s
proof
  let s be State of SCM+FSA;
  assume
A1: s.intloc 0 = 1;
A2: intloc 0 in dom s by SCMFSA_2:66;
  Initialize s = s +* (intloc 0 .--> 1) +* Start-At( 0,SCM+FSA)
  by SCMFSA6C:def 3
    .= s +* Start-At( 0,SCM+FSA) by A1,A2,FUNCT_7:111;
  hence thesis by SCMFSA8A:10;
end;

theorem Th28:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
  being Int-Location, l being Element of NAT holds (s +* (I +*
  Start-At(l,SCM+FSA))).a = s.a
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  let l be Element of NAT;
  not a in dom (I +* Start-At(l,SCM+FSA)) by SCMFSA6B:12;
  hence thesis by FUNCT_4:12;
end;

theorem
  for I being preProgram of SCM+FSA, l being Element of NAT
   holds IC SCM+FSA in dom (I +* Start-At(l,SCM+FSA))
proof
  let I be preProgram of SCM+FSA;
  let l be Element of NAT;
  dom Start-At(l,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
  then IC SCM+FSA in dom Start-At(l,SCM+FSA) by TARSKI:def 1;
  hence thesis by FUNCT_4:13;
end;

theorem
  for I being preProgram of SCM+FSA, l being Element of NAT
   holds (I +* Start-At(l,SCM+FSA)).IC SCM+FSA = l
proof
  let I be preProgram of SCM+FSA;
  let l be Element of NAT;
  dom Start-At(l,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
  then
A1: IC SCM+FSA in dom Start-At(l,SCM+FSA) by TARSKI:def 1;
  (Start-At(l,SCM+FSA)).IC SCM+FSA = l by FUNCOP_1:87;
  hence thesis by A1,FUNCT_4:14;
end;

theorem Th31:
  for s being State of SCM+FSA, P being FinPartState of SCM+FSA, l
  being Element of NAT holds IC (s +* (P +*
  Start-At(l,SCM+FSA))) = l
proof
  let s be State of SCM+FSA;
  let I be FinPartState of SCM+FSA;
  let l be Element of NAT;
  thus IC (s +* (I +* Start-At(l,SCM+FSA))) = IC (s +* I +*
  Start-At(l,SCM+FSA)) by FUNCT_4:15
    .= l by AMI_1:111;
end;

theorem Th32:
  for s being State of SCM+FSA, i being Instruction of SCM+FSA st
  InsCode i in {0,6,7,8} holds DataPart Exec(i,s) = DataPart s
proof
  let s be State of SCM+FSA;
  let i be Instruction of SCM+FSA;
  assume
A1: InsCode i in {0,6,7,8};
  now
    let a be Int-Location;
    let f be FinSeq-Location;
    per cases by A1,ENUMSET1:def 2;
    suppose
      InsCode i = 0;
      then i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s).a = s.a & Exec(i,s).f = s.f by AMI_1:def 8;
    end;
    suppose
      InsCode i = 6;
      then ex lb being Element of NAT st i = goto lb by SCMFSA_2:59;
      hence Exec(i,s).a = s.a & Exec(i,s).f = s.f by SCMFSA_2:95;
    end;
    suppose
      InsCode i = 7;
      then
      ex lb being Element of NAT, b being Int-Location st
      i = b=0_goto lb by SCMFSA_2:60;
      hence Exec(i,s).a = s.a & Exec(i,s).f = s.f by SCMFSA_2:96;
    end;
    suppose
      InsCode i = 8;
      then
      ex lb being Element of NAT, b being Int-Location st
      i = b>0_goto lb by SCMFSA_2:61;
      hence Exec(i,s).a = s.a & Exec(i,s).f = s.f by SCMFSA_2:97;
    end;
  end;
  hence thesis by SCMFSA6A:38;
end;

theorem Th33:
  for s1,s2 being State of SCM+FSA st s1.intloc 0 = s2.intloc 0 &
  ((for a being read-write Int-Location holds s1.a = s2.a) & for f being
  FinSeq-Location holds s1.f = s2.f) holds DataPart s1 = DataPart s2
proof
  let s1,s2 be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  assume
A1: s1.intloc 0 = s2.intloc 0;
  assume
A2: for a being read-write Int-Location holds s1.a = s2.a;
A3: dom DataPart s1 = dom s1 /\ D by RELAT_1:90,SCMFSA_2:127
    .= (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} \/ NAT) /\ D by
SCMFSA6A:34
    .= dom s2 /\ D by SCMFSA6A:34
    .= dom DataPart s2 by RELAT_1:90,SCMFSA_2:127;
  assume
A4: for f being FinSeq-Location holds s1.f = s2.f;
  now
    let x be set;
    assume
A5: x in dom DataPart s1;
    then
A6: x in dom s1 /\ D by RELAT_1:90,SCMFSA_2:127;
    then
A7: x in dom s1 by XBOOLE_0:def 4;
A8: x in D by A6,XBOOLE_0:def 4;
    per cases by A7,SCMFSA6A:35;
    suppose
A9:   x is Int-Location;
      hereby
        per cases;
        suppose
A10:      x is read-write Int-Location;
          thus (DataPart s1).x = s1.x by A5,FUNCT_1:70
            .= s2.x by A2,A10
            .= (DataPart s2).x by A3,A5,FUNCT_1:70;
        end;
        suppose
A11:      not x is read-write Int-Location;
          reconsider a = x as Int-Location by A9;
          a = intloc 0 by A11,SF_MASTR:def 5;
          hence (DataPart s1).x = s2.a by A1,A5,FUNCT_1:70
            .= (DataPart s2).x by A3,A5,FUNCT_1:70;
        end;
      end;
    end;
    suppose
A12:  x is FinSeq-Location;
      thus (DataPart s1).x = s1.x by A5,FUNCT_1:70
        .= s2.x by A4,A12
        .= (DataPart s2).x by A3,A5,FUNCT_1:70;
    end;
    suppose
A13:  x = IC SCM+FSA;
      assume
      not (DataPart s1).x = (DataPart s2).x;
      thus contradiction by A6,A13,SCMFSA6A:37,XBOOLE_0:def 4;
    end;
    suppose
A14:  x is Element of NAT;
      assume
      not (DataPart s1).x = (DataPart s2).x;
      thus contradiction by A8,A14,SCMFSA6A:37;
    end;
  end;
  then DataPart s1 c= DataPart s2 by A3,GRFUNC_1:8;
  hence thesis by A3,GRFUNC_1:9;
end;

theorem
  for s being State of SCM+FSA,P being preProgram of SCM+FSA holds
  DataPart(s +* P) = DataPart s
proof
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  let P be preProgram of SCM+FSA;
A1: A misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  dom P c= A by RELAT_1:def 18;
  then dom P misses D by A1,XBOOLE_1:63;
  hence thesis by FUNCT_4:76,SCMFSA_2:127;
end;

theorem Th35:
  for s,ss being State of SCM+FSA holds DataPart(s +* ss | NAT) =
  DataPart s
proof
  let s,ss be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  dom (ss | A) = dom ss /\ A by RELAT_1:90
    .= (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} \/ A) /\ A by
SCMFSA6A:34
    .= A by XBOOLE_1:21;
  then dom (ss | A) misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  hence thesis by FUNCT_4:76,SCMFSA_2:127;
end;

theorem Th36:
  for s being State of SCM+FSA holds (Initialize s) | NAT = s |
  NAT
proof
  let s be State of SCM+FSA;
  set A = NAT;
  now
    let x be set;
A1: dom (intloc 0 .--> 1) = {intloc 0} by FUNCOP_1:19;
    assume
    x in A;
    then reconsider l = x as Element of NAT;
A2: not l in dom Start-At( 0,SCM+FSA) by AMI_1:137;
    l <> intloc 0 by SCMFSA_2:84;
    then not x in dom (intloc 0 .--> 1) by A1,TARSKI:def 1;
    hence not x in dom (intloc 0 .--> 1) \/ dom Start-At( 0,SCM+FSA)
    by A2,XBOOLE_0:def 3;
  end;
  then dom (intloc 0 .--> 1) \/ dom Start-At( 0,SCM+FSA) misses A
  by XBOOLE_0:3;
  then
A3: dom ((intloc 0 .--> 1) +* Start-At( 0,SCM+FSA)) misses A
by FUNCT_4:def 1;
  Initialize s = s +* (intloc 0 .--> 1) +* Start-At( 0,SCM+FSA)
  by SCMFSA6C:def 3
    .= s +* ((intloc 0 .--> 1) +* Start-At( 0,SCM+FSA)) by FUNCT_4:15;
  hence thesis by A3,FUNCT_4:94;
end;

theorem Th37:
  for s,ss being State of SCM+FSA, I being Program of SCM+FSA
  holds DataPart(ss +* (s | (NAT))) = DataPart ss
proof
  let s,ss be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  let I be Program of SCM+FSA;
A1: A misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  dom (s | A) = A by SCMFSA8A:3;
  hence thesis by A1,FUNCT_4:94,SCMFSA_2:127;
end;

theorem Th38:
  for s being State of SCM+FSA holds IExec(Stop SCM+FSA,s) =
  Initialize s +* Start-At( 0,SCM+FSA)
proof
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  set s1 = Initialize s +* (Stop SCM+FSA +* Start-At( 0,SCM+FSA));
A1: s1 = Comput(ProgramPart( s1), s1,0) by AMI_1:13;
A2: IExec(Stop SCM+FSA,s) = Result(ProgramPart(s +* Initialized Stop SCM+FSA),s
+* Initialized Stop SCM+FSA) +* s | A
  by SCMFSA6B:def 1;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by AMI_1:150;
y: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
x:  0 in dom Stop SCM+FSA by SCMNORM:2;
A3: s +* Initialized Stop SCM+FSA = s1 by SCMFSA8A:13;
  then
A4: CurInstr(ProgramPart s1,s1) = s1. 0 by Y,FUNCT_4:26,SCMFSA6B:34
    .= (Stop SCM+FSA). 0 by Th26,x;
  then ProgramPart s1 halts_on s1 by A1,y,AMI_1:146;
  then
A5: IExec(Stop SCM+FSA,s) = s1 +* s | A by A3,A4,A1,A2,y,AMI_1:def 22
;
  then
A6: DataPart IExec(Stop SCM+FSA,s) = DataPart s1 by Th37
    .= DataPart Initialize s by SCMFSA8A:11;
  hereby
A7: dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
A8: now
      let x be set;
      assume
A9:   x in dom IExec(Stop SCM+FSA,s);
      per cases by A9,SCMFSA6A:35;
      suppose
A10:    x is Int-Location;
        then x <> IC SCM+FSA by SCMFSA_2:81;
        then
A11:    not x in dom Start-At( 0,SCM+FSA) by A7,TARSKI:def 1;
        IExec(Stop SCM+FSA,s).x = (Initialize s).x by A6,A10,SCMFSA6A:38;
        hence IExec(Stop SCM+FSA,s).x = (Initialize s +*
        Start-At( 0,SCM+FSA)).x
        by A11,FUNCT_4:12;
      end;
      suppose
A12:    x is FinSeq-Location;
        then x <> IC SCM+FSA by SCMFSA_2:82;
        then
A13:    not x in dom Start-At( 0,SCM+FSA) by A7,TARSKI:def 1;
        IExec(Stop SCM+FSA,s).x = (Initialize s).x by A6,A12,SCMFSA6A:38;
        hence IExec(Stop SCM+FSA,s).x = (Initialize s +*
        Start-At( 0,SCM+FSA)).x
        by A13,FUNCT_4:12;
      end;
      suppose
A14:    x = IC SCM+FSA;
        then x in {IC SCM+FSA} by TARSKI:def 1;
        then
A15:    x in dom Start-At( 0,SCM+FSA) by FUNCOP_1:19;
        not x in A by A14,AMI_1:48;
        then not x in dom s /\ A by XBOOLE_0:def 4;
        then not x in dom (s | A) by RELAT_1:90;
        hence IExec(Stop SCM+FSA,s).x = s1.IC SCM+FSA by A5,A14,FUNCT_4:12
          .= (Initialize s +* Stop SCM+FSA +*
          Start-At( 0,SCM+FSA)).IC SCM+FSA
        by FUNCT_4:15
          .= (Start-At( 0,SCM+FSA)).IC SCM+FSA by A14,A15,FUNCT_4:14
          .= (Initialize s +* Start-At( 0,SCM+FSA)).x
          by A14,A15,FUNCT_4:14;
      end;
      suppose
A17:    x is Element of NAT;
        then x <> IC SCM+FSA by AMI_1:48;
        then
A18:    not x in dom Start-At( 0,SCM+FSA) by A7,TARSKI:def 1;
        IExec(Stop SCM+FSA,s) | A = s | A by A2,PBOOLE:157
          .= (Initialize s) | A by Th36;
        then IExec(Stop SCM+FSA,s).x = (Initialize s).x by A17,SCMFSA6A:36;
        hence IExec(Stop SCM+FSA,s).x = (Initialize s +*
        Start-At( 0,SCM+FSA)).x
        by A18,FUNCT_4:12;
      end;
    end;
    dom IExec(Stop SCM+FSA,s) = the carrier of SCM+FSA by PARTFUN1:def 4
      .= dom (Initialize s +* Start-At( 0,SCM+FSA)) by PARTFUN1:def 4;
    hence thesis by A8,FUNCT_1:9;
  end;
end;

theorem Th39:
  for s being State of SCM+FSA,I being Program of SCM+FSA st I
  is_closed_on s holds  0 in dom I
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  reconsider n = IC Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s
+* (I +* Start-At( 0,SCM+FSA))),0)
   as Element
  of NAT;
  assume
A1: I is_closed_on s;
  then
A2:  n in dom I by SCMFSA7B:def 7;
  per cases;
  suppose
    n = 0;
    hence thesis by A1,SCMFSA7B:def 7;
  end;
  suppose
    0 < n;
    hence thesis by A2,AFINSQ_1:def 13;
  end;
end;

canceled 2;

theorem Th42:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st I
  is_closed_on s1 & I +* Start-At( 0,SCM+FSA) c= s1
  for n being Element of NAT st
ProgramPart Relocated(I,n) c= s2 & IC s2 =  n & DataPart s1 = DataPart s2
for i being Element of NAT holds IC Comput(ProgramPart( s1), s1,i) + n = IC
Comput(ProgramPart( s2
), s2
,i) & IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(
ProgramPart(s1),s1,i)),n)
 = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),s2,
i)) &
  DataPart Comput(ProgramPart( s1), s1,i) = DataPart Comput(ProgramPart( s2),
s2,i)
proof
  let s1,s2 be State of SCM+FSA;
  let J be Program of SCM+FSA;
  set JAt = J +* Start-At( 0,SCM+FSA);
  assume
A1: J is_closed_on s1;
  then
A2:  0 in dom J by Th39;
  dom J misses dom Start-At( 0,SCM+FSA) by SF_MASTR:64;
  then
A3: J c= JAt by FUNCT_4:33;
  then
A4: dom J c= dom JAt by GRFUNC_1:8;
  assume
A5: J +* Start-At( 0,SCM+FSA) c= s1;
A6: IC SCM+FSA in dom JAt by SF_MASTR:65;
  then
A7: s1.IC s1 = s1.((JAt).IC SCM+FSA) by A5,GRFUNC_1:8
    .= s1. 0 by SF_MASTR:66
    .= (JAt). 0 by A5,A4,A2,GRFUNC_1:8
    .= J. 0 by A3,A2,GRFUNC_1:8;
A8: IC Comput(ProgramPart(s1),s1,0) = s1.IC SCM+FSA by AMI_1:13
    .= (JAt).IC SCM+FSA by A5,A6,GRFUNC_1:8
    .=  0 by SF_MASTR:66;
  ProgramPart J = J by AMI_1:105;
  then
A9:  0 in dom ProgramPart J by A1,Th39;
  let n be Element of NAT;
  defpred P[Nat] means IC Comput(ProgramPart(s1),s1,$1) + n = IC Comput(
ProgramPart(
s2),
s2,$1) &
IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,$1),Comput(ProgramPart(
s1),s1,$1)),n) =
 CurInstr(ProgramPart Comput(ProgramPart(s2),s2,$1),Comput(ProgramPart(s2),s2,
$1)) &
  DataPart Comput(ProgramPart(s1),s1,$1) = DataPart Comput(ProgramPart(s2),s2,
$1);
  assume that
A10: ProgramPart Relocated(J,n) c= s2 and
A11: IC s2 =  n and
A12: DataPart s1 = DataPart s2;
  let i be Element of NAT;
A13: DataPart Comput(ProgramPart(s1),s1,0) = DataPart s2 by A12,AMI_1:13
    .= DataPart Comput(ProgramPart(s2),s2,0) by AMI_1:13;
A14: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    dom J misses dom Start-At( 0,SCM+FSA) by SF_MASTR:64;
    then
A15: J c= JAt by FUNCT_4:33;
    then
A16: dom J c= dom JAt by GRFUNC_1:8;
    let k be Element of NAT;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(
s1),s1,k)
by AMI_1:144;
A17: Comput(ProgramPart(s1),s1,k+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,k)) by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(
ProgramPart(s1),s1,k)),
      Comput(ProgramPart(s1),s1,k)) by T;
    reconsider l = IC Comput(ProgramPart(s1),s1,k+1) as Element of NAT;
    reconsider
     j = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k+1),Comput(ProgramPart
(s1),s1,k+1))
     as Instruction of SCM+FSA;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,k+1))/.IC Comput(ProgramPart(s1),s1,
k+1)
 = Comput(ProgramPart(s1),s1,k+1).IC Comput(ProgramPart(s1),s1,k+1) by
AMI_1:150;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(
s2),s2,k)
by AMI_1:144;
A18: Comput(ProgramPart(s2),s2,k+1) = Following(ProgramPart s2,
Comput(ProgramPart(s2),s2,k)) by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(
ProgramPart(s2),s2,k)),
      Comput(ProgramPart(s2),s2,k)) by T;
    s1 +* (J +* Start-At( 0,SCM+FSA)) = s1 by A5,FUNCT_4:79;
    then
A20: IC Comput(ProgramPart(s1),s1,k+1) in dom J by A1,SCMFSA7B:def 7;
    assume
A21: P[k];
    hence
A22: IC Comput(ProgramPart(s1),s1,k+1) + n = IC Comput(ProgramPart(s2),s2,k+1)
by A17,A18,SCMFSA6A:41
;
    then IC Comput(ProgramPart(s2),s2,k+1) in dom Relocated(J,n) by A20,
SCMFSA_5:4;
    then IC Comput(ProgramPart(s2),s2,k+1) in dom Relocated(J,n) /\ NAT by
XBOOLE_0:def 4;
    then
A23: IC Comput(ProgramPart(s2),s2,k+1) in dom ProgramPart Relocated(J,n) by
RELAT_1:90;
    dom ProgramPart J = dom J /\ NAT by RELAT_1:90;
    then
A24: l in dom ProgramPart J by A20,XBOOLE_0:def 4;
U:  (ProgramPart Comput(ProgramPart(s2),s2,k+1))/.IC Comput(ProgramPart(s2),s2,
k+1)
 = Comput(ProgramPart(s2),s2,k+1).IC Comput(ProgramPart(s2),s2,k+1) by
AMI_1:150;
    j = s1.IC Comput(ProgramPart(s1),s1,k+1) by Y,AMI_1:54
      .= (JAt).IC Comput(ProgramPart(s1),s1,k+1) by A5,A16,A20,GRFUNC_1:8
      .= J.l by A15,A20,GRFUNC_1:8;
    hence IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k+1),
    Comput(ProgramPart(s1),s1,k+1)),n)
     = Relocated(J,n).(l + n) by A24,SCMFSA_5:7
      .= (ProgramPart Relocated(J,n)).(IC Comput(ProgramPart(s2),s2,k+1)) by
A22,FUNCT_1:72
      .= s2.IC Comput(ProgramPart(s2),s2,k+1) by A10,A23,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k+1),Comput(ProgramPart
(s2),s2,k+1))
       by U,AMI_1:54;
    thus thesis by A21,A17,A18,SCMFSA6A:41;
  end;
   0 in dom J by A1,Th39;
  then  0 + n in dom Relocated(J,n) by SCMFSA_5:4;
  then
A25:  (0 + n) in dom ProgramPart Relocated(J,n) by AMI_1:106;
V:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by AMI_1:150;
U:  (ProgramPart s2)/.IC s2
 = s2.IC s2 by AMI_1:150;
u: Comput(ProgramPart(s1),s1,0) = s1 by AMI_1:13;
v: Comput(ProgramPart(s2),s2,0) = s2 by AMI_1:13;
  IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,0),Comput(ProgramPart(
s1),s1,0)),n)
   = IncAddr(CurInstr(ProgramPart s1,s1),n) by u
    .= Relocated(J,n). (0 + n) by A7,A9,V,SCMFSA_5:7
    .= (ProgramPart Relocated(J,n)). n by FUNCT_1:72
    .= CurInstr(ProgramPart s2,s2) by A10,A11,A25,U,GRFUNC_1:8
    .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,0),Comput(ProgramPart(s2)
,s2,0))
     by v;
  then
A26: P[0] by A11,A8,A13,AMI_1:13;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A26,A14);
  hence thesis;
end;

theorem Th43:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st I
is_closed_on s1 & I +* Start-At( 0,SCM+FSA) c= s1 & I +*
 Start-At( 0,SCM+FSA) c= s2 &
DataPart s1 = DataPart s2 for i being Element of NAT holds IC Comput(
ProgramPart( s1), s1,i
) = IC Comput(ProgramPart( s2), s2,i) & CurInstr(ProgramPart Comput(ProgramPart
(s1),s1,i),
Comput(ProgramPart(s1),s1,i))
 = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),s2,
i)) &
  DataPart Comput(ProgramPart( s1), s1,i) = DataPart Comput(ProgramPart( s2),
s2,i)
proof
  let s1,s2 be State of SCM+FSA;
  let J be Program of SCM+FSA;
  assume that
A1: J is_closed_on s1 and
A2: J +* Start-At( 0,SCM+FSA) c= s1 and
A3: J +* Start-At( 0,SCM+FSA) c= s2 and
A4: DataPart s1 = DataPart s2;
A5: ProgramPart Relocated(J,0) = J by Th9;
  s2 = s2 +* (J +* Start-At( 0,SCM+FSA)) by A3,FUNCT_4:79
    .= s2 +* J +* Start-At( 0,SCM+FSA) by FUNCT_4:15
    .= s2 +* Start-At( 0,SCM+FSA) +* J by SCMFSA6B:14;
  then
A6: ProgramPart Relocated(J,0) c= s2 by A5,FUNCT_4:26;
  let i be Element of NAT;
A7: IC Comput(ProgramPart( s1), s1,i) + 0 = IC Comput(ProgramPart( s1), s1,i);
A8: IC s2 = IC (s2 +* (J +* Start-At( 0,SCM+FSA))) by A3,FUNCT_4:79
    .= IC (s2 +* J +* Start-At( 0,SCM+FSA)) by FUNCT_4:15
    .=  0 by AMI_1:111;
  IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(
s1),s1,i)),0)
   = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(s1),
s1,i)) by Th8;
  hence thesis by A1,A2,A4,A7,A6,A8,Th42;
end;

theorem Th44:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st I
  is_closed_on s1 & I is_halting_on s1 & I +* Start-At( 0,SCM+FSA) c= s1
   & I +*
  Start-At( 0,SCM+FSA) c= s2 & DataPart s1 = DataPart s2
  holds LifeSpan(ProgramPart(s1),s1) =
  LifeSpan(ProgramPart(s2),s2)
proof
  let s1,s2 be State of SCM+FSA;
  let J be Program of SCM+FSA;
  assume that
A1: J is_closed_on s1 and
A2: J is_halting_on s1 and
A3: J +* Start-At( 0,SCM+FSA) c= s1 and
A4: J +* Start-At( 0,SCM+FSA) c= s2 and
A5: DataPart s1 = DataPart s2;
  s1 = s1 +* (J +* Start-At( 0,SCM+FSA)) by A3,FUNCT_4:79;
  then
A6: ProgramPart s1 halts_on s1 by A2,SCMFSA7B:def 8;
A7: now
    let k be Element of NAT;
TX2: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:144;
TX1: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:144;
    assume
    CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k)) = halt SCM+FSA;
    then CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,k))
     = halt SCM+FSA by A1,A3,A4,A5,Th43,TX1,TX2;
    hence LifeSpan(ProgramPart(s1),s1) <= k by A6,AMI_1:def 46;
  end;
TX1: ProgramPart s1 = ProgramPart
Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))
by AMI_1:144;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)
)
by AMI_1:144;
  CurInstr(ProgramPart s1,
Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)))
   = halt SCM+FSA by A6,AMI_1:def 46;
  then
A8: CurInstr(ProgramPart s2,
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)))
 = halt SCM+FSA by A1,A3,A4,A5,Th43,TX1,TX2;
  then ProgramPart s2 halts_on s2 by AMI_1:146;
  hence thesis by A8,A7,AMI_1:def 46;
end;

theorem Th45:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
  s1.intloc 0 = 1 & I is_closed_on s1 & I is_halting_on s1 & ((for a being
read-write Int-Location holds s1.a = s2.a) & for f being FinSeq-Location holds
  s1.f = s2.f) holds DataPart IExec(I,s1) = DataPart IExec(I,s2)
proof
  let s1,s2 be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  set s11 = s1 +* Initialized I;
  set s21 = s2 +* Initialized I;
A1: I +* Start-At( 0,SCM+FSA) c= Initialized I by Th19;
  Initialized I c= s11 by FUNCT_4:26;
  then
A2: I +* Start-At( 0,SCM+FSA) c= s11 by A1,XBOOLE_1:1;
  Initialized I c= s21 by FUNCT_4:26;
  then
A3: I +* Start-At( 0,SCM+FSA) c= s21 by A1,XBOOLE_1:1;
  assume
  s1.intloc 0 = 1;
  then
A4: s11 = s1 +* (I +* Start-At( 0,SCM+FSA)) by Th18;
  then
A5: DataPart s11 = DataPart s1 by SCMFSA8A:11;
  assume that
A6: I is_closed_on s1 and
A7: I is_halting_on s1;
A8: I is_closed_on s11 by A6,A7,A5,SCMFSA8B:8;
  assume
A9: for a being read-write Int-Location holds s1.a = s2.a;
A10: now
    let a be read-write Int-Location;
A11: not a in dom Initialized I by SCMFSA6A:48;
    hence s11.a = s1.a by FUNCT_4:12
      .= s2.a by A9
      .= s21.a by A11,FUNCT_4:12;
  end;
  assume
A12: for f being FinSeq-Location holds s1.f = s2.f;
A13: now
    let f be FinSeq-Location;
A14: not f in dom Initialized I by SCMFSA6A:49;
    hence s11.f = s1.f by FUNCT_4:12
      .= s2.f by A12
      .= s21.f by A14,FUNCT_4:12;
  end;
A15: intloc 0 in dom Initialized I by SCMFSA6A:45;
  then s11.intloc 0 = (Initialized I).intloc 0 by FUNCT_4:14
    .= s21.intloc 0 by A15,FUNCT_4:14;
  then
A16: DataPart s11 = DataPart s21 by A10,A13,Th33;
TX11: ProgramPart s11 = ProgramPart
Comput(ProgramPart(s11),s11,LifeSpan(ProgramPart(
s11),s11))
by AMI_1:144;
TX21: ProgramPart s21 = ProgramPart
Comput(ProgramPart(s21),s21,LifeSpan(ProgramPart(
s11),s11))
by AMI_1:144;
A17: ProgramPart s11 halts_on s11 by A7,A4,SCMFSA7B:def 8;
  then CurInstr(ProgramPart s11,
  Comput(ProgramPart(s11),s11,LifeSpan(ProgramPart(s11),s11)))
  = halt SCM+FSA by AMI_1:def 46;
  then CurInstr(ProgramPart s21,
  Comput(ProgramPart(s21),s21,LifeSpan(ProgramPart(s11),s11)))
   = halt SCM+FSA by A8,A16,A2,A3,Th43,TX11,TX21;
  then
A18: ProgramPart s21 halts_on s21 by AMI_1:146;
  I is_halting_on s11 by A6,A7,A5,SCMFSA8B:8;
  then
A19: LifeSpan(ProgramPart(s11),s11) = LifeSpan(ProgramPart(s21),s21) by A8,A16,
A2,A3,Th44;
  thus DataPart IExec(I,s1) = DataPart Result(ProgramPart(s11),s11) by SCMFSA8B
:35
    .= DataPart Comput(ProgramPart( s11), s11,LifeSpan(ProgramPart(s11),s11))
by A17,AMI_1:122
    .= DataPart Comput(ProgramPart( s21), s21,LifeSpan(ProgramPart(s11),s11))
by A8,A16,A2,A3
,Th43
    .= DataPart Result(ProgramPart(s21),s21) by A19,A18,AMI_1:122
    .= DataPart IExec(I,s2) by SCMFSA8B:35;
end;

theorem Th46:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
  s1.intloc 0 = 1 & I is_closed_on s1 & I is_halting_on s1 & DataPart s1 =
  DataPart s2 holds DataPart IExec(I,s1) = DataPart IExec(I,s2)
proof
  let s1,s2 be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  set s11 = s1 +* Initialized I;
  set s21 = s2 +* Initialized I;
  assume that
A1: s1.intloc 0 = 1 and
A2: I is_closed_on s1 and
A3: I is_halting_on s1 and
A4: DataPart s1 = DataPart s2;
A5: s11 = s1 +* (I +* Start-At( 0,SCM+FSA)) by A1,Th18;
  then
A6: DataPart s11 = DataPart s1 by SCMFSA8A:11;
  then
A7: I is_closed_on s11 by A2,A3,SCMFSA8B:8;
  s2.intloc 0 = 1 by A1,A4,SCMFSA6A:38;
  then s21 = s2 +* (I +* Start-At( 0,SCM+FSA)) by Th18;
  then
A8: DataPart s11 = DataPart s21 by A4,A6,SCMFSA8A:11;
A9: I +* Start-At( 0,SCM+FSA) c= Initialized I by Th19;
  Initialized I c= s11 by FUNCT_4:26;
  then
A10: I +* Start-At( 0,SCM+FSA) c= s11 by A9,XBOOLE_1:1;
  Initialized I c= s21 by FUNCT_4:26;
  then
A11: I +* Start-At( 0,SCM+FSA) c= s21 by A9,XBOOLE_1:1;
TX11: ProgramPart s11 = ProgramPart
Comput(ProgramPart(s11),s11,LifeSpan(ProgramPart(
s11),s11))
by AMI_1:144;
TX21: ProgramPart s21 = ProgramPart
Comput(ProgramPart(s21),s21,LifeSpan(ProgramPart(
s11),s11))
by AMI_1:144;
A12: ProgramPart s11 halts_on s11 by A3,A5,SCMFSA7B:def 8;
  then CurInstr(ProgramPart s11,
  Comput(ProgramPart(s11),s11,LifeSpan(ProgramPart(s11),s11)))
  = halt SCM+FSA by AMI_1:def 46;
  then CurInstr(ProgramPart s21,
  Comput(ProgramPart(s21),s21,LifeSpan(ProgramPart(s11),s11)))
   = halt SCM+FSA by A7,A8,A10,A11,Th43,TX11,TX21;
  then
A13: ProgramPart s21 halts_on s21 by AMI_1:146;
  I is_halting_on s11 by A2,A3,A6,SCMFSA8B:8;
  then
A14: LifeSpan(ProgramPart(s11),s11) = LifeSpan(ProgramPart(s21),s21) by A7,A8,
A10,A11,Th44;
  thus DataPart IExec(I,s1) = DataPart Result(ProgramPart(s11),s11) by SCMFSA8B
:35
    .= DataPart Comput(ProgramPart( s11), s11,LifeSpan(ProgramPart(s11),s11))
by A12,AMI_1:122
    .= DataPart Comput(ProgramPart( s21), s21,LifeSpan(ProgramPart(s11),s11))
by A7,A8,A10,A11
,Th43
    .= DataPart Result(ProgramPart(s21),s21) by A14,A13,AMI_1:122
    .= DataPart IExec(I,s2) by SCMFSA8B:35;
end;

registration
  let I be Program of SCM+FSA;
  cluster Initialized I -> initial;
  correctness
  proof
    now
      let m,n be Nat;
      I c= Initialized I by SCMFSA6A:26;
      then
A1:   dom I c= dom Initialized I by GRFUNC_1:8;
X:    n in NAT by ORDINAL1:def 13;
      assume
      n in dom Initialized I;
      then
A2:    n in dom I by X,Th20;
      assume
      m < n;
      then  m in dom I by A2,AFINSQ_1:def 13;
      hence m in dom Initialized I by A1;
    end;
    hence thesis by AFINSQ_1:def 13;
  end;
end;

Lm1: now
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set k = pseudo-LifeSpan(Initialize s,I);
A1: ProgramPart Initialized I = I by SCMFSA6A:33;
  hereby
    set k = pseudo-LifeSpan(s,Initialized I);
X:  s +* (Initialized I +* Start-At( 0,SCM+FSA)) =
    Initialize s +* (I +* Start-At( 0,SCM+FSA)) by Th16;
    assume
A2: Initialized I is_pseudo-closed_on s;

    then IC Comput(ProgramPart( (s +* (Initialized I +*
    Start-At( 0,SCM+FSA)))), (s +* (Initialized I +*
    Start-At( 0,SCM+FSA))),k) =
     card ProgramPart Initialized I by SCMFSA8A:def 5;

    then
    IC Comput(ProgramPart( (Initialize s +* (I +*
    Start-At( 0,SCM+FSA)))), (Initialize s +* (I +*
    Start-At( 0,SCM+FSA))),k) =
    card ProgramPart Initialized I by X;

    then
A3: IC Comput(ProgramPart( (Initialize s +* (I +*
Start-At( 0,SCM+FSA)))), (Initialize s +* (I +*
Start-At( 0,SCM+FSA))),k) =
    card ProgramPart I by A1,AMI_1:105;

A4: now
      let n be Element of NAT;
X:  s +* (Initialized I +* Start-At( 0,SCM+FSA)) =
    Initialize s +* (I +* Start-At( 0,SCM+FSA)) by Th16;
      assume
      n < k;

      then IC Comput(ProgramPart( (s +* (Initialized I +*
      Start-At( 0,SCM+FSA)))), (s +* (Initialized I +*
      Start-At( 0,SCM+FSA))),n) in
      dom Initialized I by A2,SCMFSA8A:def 5;

      then
      IC Comput(ProgramPart( (Initialize s +* (I +*
      Start-At( 0,SCM+FSA)))), (Initialize s +* (I +*
      Start-At( 0,SCM+FSA))),n) in dom
      Initialized I by X;

      hence IC Comput(ProgramPart( (Initialize s +* (I +*
      Start-At( 0,SCM+FSA)))), (Initialize s +* (I +*
      Start-At( 0,SCM+FSA))),n) in
      dom I by Th20;

    end;
    hence
A5: I is_pseudo-closed_on Initialize s by A3,SCMFSA8A:def 3;

    for n be Element of NAT st not IC Comput(ProgramPart( (Initialize s +* (I
+*
    Start-At( 0,SCM+FSA)))), (Initialize s +* (I +*
    Start-At( 0,SCM+FSA))), n) in dom I holds k <= n by A4;

    hence
    pseudo-LifeSpan(s,Initialized I) =
pseudo-LifeSpan(Initialize s,I) by A3,A5
,SCMFSA8A:def 5;

  end;
X:  s +* (Initialized I +* Start-At( 0,SCM+FSA)) =
    Initialize s +* (I +* Start-At( 0,SCM+FSA)) by Th16;
  assume
A6: I is_pseudo-closed_on Initialize s;

  then IC Comput(ProgramPart( (Initialize s +* (I +* Start-At( 0,SCM+FSA)))), (
Initialize s +* (I +* Start-At( 0,SCM+FSA))),k)
   =
  card ProgramPart I by SCMFSA8A:def 5;

  then
  IC Comput(ProgramPart( (s +* (Initialized I +* Start-At( 0,SCM+FSA)))), (s +*
(Initialized I +* Start-At( 0,SCM+FSA))),k)
   =
  card ProgramPart I by X;

  then
A7: IC Comput(ProgramPart( (s +* (Initialized I +* Start-At( 0,SCM+FSA)))), (s
+* (Initialized I +* Start-At( 0,SCM+FSA))),k)
 =
  card ProgramPart Initialized I by A1,AMI_1:105;

A8: now
    let n be Element of NAT;
X:  s +* (Initialized I +* Start-At( 0,SCM+FSA)) =
    Initialize s +* (I +* Start-At( 0,SCM+FSA)) by Th16;
    assume
    n < k;

    then IC Comput(ProgramPart( (Initialize s +* (I +* Start-At( 0,SCM+FSA)))),
(Initialize s +* (I +* Start-At( 0,SCM+FSA))),n)
     in dom
    I by A6,SCMFSA8A:def 5;

    then
    IC Comput(ProgramPart( (s +* (Initialized I +* Start-At( 0,SCM+FSA)))), (s
+* (Initialized I +* Start-At( 0,SCM+FSA))),n)
     in dom
    I by X;

    hence
    IC Comput(ProgramPart( (s +* (Initialized I +* Start-At( 0,SCM+FSA)))), (s
+* (Initialized I +* Start-At( 0,SCM+FSA))),n)
     in dom
    Initialized I by Th20;

  end;
  hence
A9: Initialized I is_pseudo-closed_on s by A7,SCMFSA8A:def 3;

  for n be Element of NAT st not IC Comput(ProgramPart( (s +* (Initialized I +*
  Start-At( 0,SCM+FSA)))), (s +* (Initialized I +*
  Start-At( 0,SCM+FSA))),n) in dom Initialized I holds k <= n by A8;

  hence pseudo-LifeSpan(s,Initialized I) =
pseudo-LifeSpan(Initialize s,I) by
A7,A9,SCMFSA8A:def 5;

end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  Initialized I is_pseudo-closed_on s iff I is_pseudo-closed_on Initialize s
by Lm1;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_pseudo-closed_on Initialize s holds pseudo-LifeSpan(s,Initialized I) =
  pseudo-LifeSpan(Initialize s,I) by Lm1;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA st
  Initialized I is_pseudo-closed_on s holds pseudo-LifeSpan(s,Initialized I) =
  pseudo-LifeSpan(Initialize s,I) by Lm1;

theorem Th50:
  for s being State of SCM+FSA, I being initial FinPartState of
  SCM+FSA st I is_pseudo-closed_on s holds I is_pseudo-closed_on s +* (I +*
Start-At( 0,SCM+FSA)) & pseudo-LifeSpan(s,I) =
pseudo-LifeSpan(s +* (I +*
Start-At( 0,SCM+FSA)),I)
proof
  let s be State of SCM+FSA;
  let I be initial FinPartState of SCM+FSA;
  set s2 = s +* (I +* Start-At( 0,SCM+FSA)) +* (I +*
  Start-At( 0,SCM+FSA));
A1: s +* (I +* Start-At( 0,SCM+FSA)) +* (I +* Start-At( 0,SCM+FSA))
 = s +* ((I +*
  Start-At( 0,SCM+FSA)) +* (I +* Start-At( 0,SCM+FSA)))
  by FUNCT_4:15
    .= s +* (I +* Start-At( 0,SCM+FSA));
  assume
A2: I is_pseudo-closed_on s;
  then
A3: for n being Element of NAT st not IC Comput(ProgramPart( s2), s2,n) in dom
I holds
  pseudo-LifeSpan(s,I) <= n by A1,SCMFSA8A:def 5;
A4: for n being Element of NAT st n < pseudo-LifeSpan(s,I)
holds IC
  Comput(ProgramPart( s2), s2,n) in dom I by A2,A1,SCMFSA8A:def 5;
  IC Comput(ProgramPart( s2), s2,pseudo-LifeSpan(s,I)) =  card
ProgramPart I
by A2,A1,SCMFSA8A:def 5;
  hence
A5: I is_pseudo-closed_on s +* (I +* Start-At( 0,SCM+FSA))
by A4,SCMFSA8A:def 3;
  IC Comput(ProgramPart( s2), s2,pseudo-LifeSpan(s,I)) =  card
ProgramPart I
by A2,A1,SCMFSA8A:def 5;
  hence thesis by A3,A5,SCMFSA8A:def 5;
end;

theorem Th51:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
I +* Start-At( 0,SCM+FSA) c= s1 & I is_pseudo-closed_on s1
for n being Element of
  NAT st ProgramPart Relocated(I,n) c= s2 & IC s2 =  n & DataPart s1 =
  DataPart s2 holds ((for i being Element of NAT st i < pseudo-LifeSpan(
s1,I)
  holds IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(
ProgramPart(s1),s1,i)),n)
   = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),
s2,i))) &
for i being Element of NAT st i <= pseudo-LifeSpan(s1,I)
holds IC Comput(
ProgramPart(
  s1),
  s1,i) + n = IC Comput(ProgramPart( s2), s2,i) & DataPart Comput(ProgramPart(
s1), s1,i) = DataPart
  Comput(ProgramPart( s2), s2,i))
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: I +* Start-At( 0,SCM+FSA) c= s1;
  assume
A2: I is_pseudo-closed_on s1;
  let n be Element of NAT;
  assume
A3: ProgramPart Relocated(I,n) c= s2;
  defpred P[Nat] means $1 <= pseudo-LifeSpan(s1,I) implies IC
Comput(ProgramPart(s1),s1,$1) + n = IC Comput(ProgramPart(s2),s2,$1) & DataPart
Comput(ProgramPart(s1),s1,$1) =
  DataPart Comput(ProgramPart(s2),s2,$1);
  assume
A4: IC s2 =  n;
  assume
A5: DataPart s1 = DataPart s2;
  thus
A6: now
    defpred P[Nat] means $1 < pseudo-LifeSpan(s1,I) implies
IC
Comput(ProgramPart(s1),s1,$1) + n = IC Comput(ProgramPart(s2),s2,$1) &
IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,$1),Comput(ProgramPart(
s1),s1,$1)),n) =
   CurInstr(ProgramPart Comput(ProgramPart(s2),s2,$1),Comput(ProgramPart(s2),s2
,$1)) &
DataPart Comput(ProgramPart(s1),s1,$1) =
    DataPart Comput(ProgramPart(s2),s2,$1);
    let i be Element of NAT;
    assume
A7: i < pseudo-LifeSpan(s1,I);
A8: for k being Element of NAT st P[k] holds P[k + 1]
    proof
A9:   I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
      then
A10:  dom I c= dom (I +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
      let k be Element of NAT;
      assume
A11:  P[k];
      reconsider l = IC Comput(ProgramPart(s1),s1,k+1) as Element of NAT;
      reconsider j = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k+1),
      Comput(ProgramPart(s1),s1,k+1)) as Instruction of SCM+FSA;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,k+1))/.IC Comput(ProgramPart(s1),s1,
k+1)
 = Comput(ProgramPart(s1),s1,k+1).IC Comput(ProgramPart(s1),s1,k+1) by
AMI_1:150;
      assume
A12:  k + 1 < pseudo-LifeSpan(s1,I);
T: ProgramPart s1 = ProgramPart Comput(ProgramPart
(s1),s1,k)
by AMI_1:144;
A14:  Comput(ProgramPart(s1),s1,k+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,k)) by AMI_1:14
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(
ProgramPart(s1),s1,k)),
        Comput(ProgramPart(s1),s1,k)) by T;
      s1 +* (I +* Start-At( 0,SCM+FSA)) = s1 by A1,FUNCT_4:79;
      then
A15:  IC Comput(ProgramPart(s1),s1,k+1) in dom I by A2,A12,SCMFSA8A:def 5;
      dom ProgramPart I = dom I /\ NAT by RELAT_1:90;
      then
A16:  l in dom ProgramPart I by A15,XBOOLE_0:def 4;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart
(s2),s2,k)
by AMI_1:144;
A17:  Comput(ProgramPart(s2),s2,k+1) = Following(ProgramPart s2,
Comput(ProgramPart(s2),s2,k)) by AMI_1:14
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(
ProgramPart(s2),s2,k)),
        Comput(ProgramPart(s2),s2,k)) by T;
A18:  k + 0 < k + 1 by XREAL_1:8;
      hence
A19:  IC Comput(ProgramPart(s1),s1,k+1) + n = IC Comput(ProgramPart(s2),s2,k+1)
by A11,A12,A14,A17,SCMFSA6A:41,XXREAL_0:2;
      then IC Comput(ProgramPart(s2),s2,k+1) in dom Relocated(I,n) by A15,
SCMFSA_5:4;
      then IC Comput(ProgramPart(s2),s2,k+1) in dom Relocated(I,n) /\ NAT by
XBOOLE_0:def 4;
      then
A20:  IC Comput(ProgramPart(s2),s2,k+1) in dom ProgramPart Relocated(I,n) by
RELAT_1:90;
Z:  (ProgramPart Comput(ProgramPart(s2),s2,k+1))/.IC Comput(ProgramPart(s2),s2,
k+1)
 = Comput(ProgramPart(s2),s2,k+1).IC Comput(ProgramPart(s2),s2,k+1) by
AMI_1:150;
      j = s1.IC Comput(ProgramPart(s1),s1,k+1) by Y,AMI_1:54
        .= (I +* Start-At( 0,SCM+FSA)).IC Comput(ProgramPart(s1),s1,k+1)
        by A1,A10,A15,GRFUNC_1:8
        .= I.l by A9,A15,GRFUNC_1:8;
      hence
      IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k+1),Comput(
ProgramPart(s1),s1,k+1)),n)
       = Relocated(I,n).(l + n) by A16,SCMFSA_5:7
        .= (ProgramPart Relocated(I,n)).(IC Comput(ProgramPart(s2),s2,k+1)) by
A19,FUNCT_1:72
        .= s2.IC Comput(ProgramPart(s2),s2,k+1) by A3,A20,GRFUNC_1:8
        .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k+1),Comput(
ProgramPart(s2),s2,k+1))
         by Z,AMI_1:54;
      thus thesis by A11,A12,A18,A14,A17,SCMFSA6A:41,XXREAL_0:2;
    end;
A21: P[0]
    proof
A22:  IC Comput(ProgramPart( (s1 +* (I +* Start-At( 0,SCM+FSA)))), (s1 +* (I +*
Start-At( 0,SCM+FSA))),0) =
IC (s1 +* (I
      +* Start-At( 0,SCM+FSA))) by AMI_1:13
        .= IC (s1 +* I +* Start-At( 0,SCM+FSA)) by FUNCT_4:15
        .=  0 by AMI_1:111;
      assume
      0 < pseudo-LifeSpan(s1,I);
      then
A23:   0 in dom I by A2,A22,SCMFSA8A:def 5;
      then
A24:   0 in dom ProgramPart I by AMI_1:105;
A25:  IC SCM+FSA in dom (I +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
u: Comput(ProgramPart(s1),s1,0) = s1 by AMI_1:13;
v: Comput(ProgramPart(s2),s2,0) = s2 by AMI_1:13;
      IC Comput(ProgramPart(s1),s1,0) = s1.IC SCM+FSA by AMI_1:13
        .= (I +* Start-At( 0,SCM+FSA)).IC SCM+FSA by A1,A25,GRFUNC_1:8
        .=  0 by SF_MASTR:66;
      hence IC Comput(ProgramPart(s1),s1,0) + n = IC Comput(ProgramPart(s2),s2,
0) by A4,AMI_1:13;
A26:  I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
      then
A27:  dom I c= dom (I +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
       0 + n in dom Relocated(I,n) by A23,SCMFSA_5:4;
      then
A28:   (0 + n) in dom ProgramPart Relocated(I,n) by AMI_1:106;
      IC SCM+FSA in dom (I +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
      then
A29:  s1.IC s1 = s1.((I +* Start-At( 0,SCM+FSA)).IC SCM+FSA)
by A1,GRFUNC_1:8
        .= s1. 0 by SF_MASTR:66
        .= (I +* Start-At( 0,SCM+FSA)). 0 by A1,A27,A23,GRFUNC_1:8
        .= I. 0 by A26,A23,GRFUNC_1:8;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by AMI_1:150;
Z:  (ProgramPart s2)/.IC s2
 = s2.IC s2 by AMI_1:150;
      thus IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,0),
      Comput(ProgramPart(s1),s1,0)),n)
       = IncAddr(CurInstr(ProgramPart s1,s1),n) by u
        .= Relocated(I,n). (0 + n) by A29,A24,Y,SCMFSA_5:7
        .= (ProgramPart Relocated(I,n)). n by FUNCT_1:72
        .= CurInstr(ProgramPart s2,s2) by A3,A4,A28,Z,GRFUNC_1:8
        .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,0),Comput(ProgramPart
(s2),s2,0))
         by v;
      thus DataPart Comput(ProgramPart(s1),s1,0) = DataPart s2 by A5,AMI_1:13
        .= DataPart Comput(ProgramPart(s2),s2,0) by AMI_1:13;
    end;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A21,A8);
    hence IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(
ProgramPart(s1),s1,i)),n)
     = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2)
,s2,i)) by A7;
  end;
A30: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A31: P[k];
    set i = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(
ProgramPart(s1),s1,k));
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(
s2),s2,k)
by AMI_1:144;
A32: Comput(ProgramPart(s2),s2,k+1) = Following(ProgramPart s2,
Comput(ProgramPart(s2),s2,k)) by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(
ProgramPart(s2),s2,k)),
      Comput(ProgramPart(s2),s2,k)) by T;
    assume
A33: k + 1 <= pseudo-LifeSpan(s1,I);
    then
A34: k + 1 <= pseudo-LifeSpan(s1,I) + 1 by NAT_1:12;
A35: k < pseudo-LifeSpan(s1,I) by A33,NAT_1:13;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:144;
A36: Comput(ProgramPart(s1),s1,k+1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,k)
)
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(
ProgramPart(s1),s1,k)),
      Comput(ProgramPart(s1),s1,k)) by T;
    hence IC Comput(ProgramPart(s1),s1,k+1) + n = IC Exec(IncAddr(i,n),Comput(
ProgramPart(s2),s2,k))
    by A31,A34,SCMFSA6A:41,XREAL_1:8
      .= IC Comput(ProgramPart(s2),s2,k+1) by A6,A35,A32;
    thus DataPart Comput(ProgramPart(s1),s1,k+1) = DataPart Exec(IncAddr(i,n),
Comput(ProgramPart(s2),s2,k)) by A31,A34,A36,SCMFSA6A:41,XREAL_1:8
      .= DataPart Comput(ProgramPart(s2),s2,k+1) by A6,A35,A32;
  end;
  let i be Element of NAT;
  assume
A37: i <= pseudo-LifeSpan(s1,I);
A38: P[0]
  proof
    assume
    0 <= pseudo-LifeSpan(s1,I);
A39: IC SCM+FSA in dom (I +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
    IC Comput(ProgramPart(s1),s1,0) = s1.IC SCM+FSA by AMI_1:13
      .= (I +* Start-At( 0,SCM+FSA)).IC SCM+FSA by A1,A39,GRFUNC_1:8
      .=  0 by SF_MASTR:66;
    hence IC Comput(ProgramPart(s1),s1,0) + n = IC Comput(ProgramPart(s2),s2,0)
by A4,AMI_1:13;
    thus DataPart Comput(ProgramPart(s1),s1,0) = DataPart s2 by A5,AMI_1:13
      .= DataPart Comput(ProgramPart(s2),s2,0) by AMI_1:13;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A38,A30);
  hence thesis by A37;
end;

theorem Th52:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
  DataPart s1 = DataPart s2 holds I is_pseudo-closed_on s1 implies I
  is_pseudo-closed_on s2
proof
  let s1,s2 be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  set S1 = s1 +* (I +* Start-At( 0,SCM+FSA)), S2 = s2 +* (I +*
  Start-At( 0,SCM+FSA));
A1: I +* Start-At( 0,SCM+FSA) c= s1 +* (I +* Start-At( 0,SCM+FSA))
 by FUNCT_4:26;
A2: IC (s2 +* (I +* Start-At( 0,SCM+FSA))) = IC (s2 +* I +*
Start-At( 0,SCM+FSA))
  by FUNCT_4:15
    .=  0 by AMI_1:111;
A3: I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  I +* Start-At( 0,SCM+FSA) c= s2 +* (I +* Start-At( 0,SCM+FSA))
  by FUNCT_4:26;
  then I c= s2 +* (I +* Start-At( 0,SCM+FSA)) by A3,XBOOLE_1:1;
  then
A4: ProgramPart Relocated(I,0) c= s2 +* (I +* Start-At( 0,SCM+FSA))
by Th9;
  assume
  DataPart s1 = DataPart s2;
  then
A5: DataPart(s1 +* (I +* Start-At( 0,SCM+FSA))) = DataPart s2
by SCMFSA8A:11
    .= DataPart(s2 +* (I +* Start-At( 0,SCM+FSA))) by SCMFSA8A:11;
  assume
A6: I is_pseudo-closed_on s1;
  then
A7: IC Comput(ProgramPart(S1),S1,pseudo-LifeSpan(s1,I)) =
card ProgramPart I
by SCMFSA8A:def 5;
A8: I is_pseudo-closed_on s1 +* (I +* Start-At( 0,SCM+FSA)) by A6,Th50;
A9: now
    let k be Element of NAT;
    assume
A10: k < pseudo-LifeSpan(s1,I);
    then k <= pseudo-LifeSpan(
s1 +* (I +* Start-At( 0,SCM+FSA)),I)
    by A6,Th50;
    then
    IC Comput(ProgramPart(S2),S2,k) = IC Comput(ProgramPart(S1),S1,k) + 0 by A5
,A8,A1,A4,A2,Th51
      .= IC Comput(ProgramPart(S1),S1,k);
    hence IC Comput(ProgramPart(S2),S2,k) in dom I by A6,A10,SCMFSA8A:def 5;
  end;
  IC Comput(ProgramPart(S2),S2,pseudo-LifeSpan(s1,I)) = IC
Comput(ProgramPart(
S2),S2,
  pseudo-LifeSpan(s1 +* (I +*
Start-At( 0,SCM+FSA)),I)) by A6,Th50
    .= IC Comput(ProgramPart(S1),S1,pseudo-LifeSpan(
    s1 +* (I +*
    Start-At( 0,SCM+FSA)),I))
  + 0 by A5,A8,A1,A4,A2,Th51
    .= IC Comput(ProgramPart(S1),S1,pseudo-LifeSpan(s1,I)) by
A6,Th50;
  hence thesis by A7,A9,SCMFSA8A:def 3;
end;

theorem Th53:
  for s being State of SCM+FSA, I being Program of SCM+FSA st s.
intloc 0 = 1 holds I is_pseudo-closed_on s iff I is_pseudo-closed_on Initialize
  s
proof
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  assume
  s.intloc 0 = 1;
  then DataPart s = DataPart Initialize s by Th27;
  hence thesis by Th52;
end;

theorem Th54:
  for a being Int-Location, I,J being Program of SCM+FSA holds
   0 in dom if=0(a,I,J) &  1 in dom if=0(a,I,J) &  0 in dom
  if>0(a,I,J) &  1 in dom if>0(a,I,J)
proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  set i = a =0_goto  (card J + 3);
  if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I ';' Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  ));
  then
A1: dom Macro i c= dom if=0(a,I,J) by SCMFSA6A:56;
A2: dom Macro i = { 0,  1} by SCMFSA7B:4;
  then
A3:  1 in dom Macro i by TARSKI:def 2;
   0 in dom Macro i by A2,TARSKI:def 2;
  hence  0 in dom if=0(a,I,J) &  1 in dom if=0(a,I,J) by A1,A3;
  set i = a >0_goto  (card J + 3);
  if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I ';' Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  ));
  then
A4: dom Macro i c= dom if>0(a,I,J) by SCMFSA6A:56;
A5: dom Macro i = { 0,  1} by SCMFSA7B:4;
  then
A6:  1 in dom Macro i by TARSKI:def 2;
   0 in dom Macro i by A5,TARSKI:def 2;
  hence thesis by A4,A6;
end;

theorem Th55:
  for a being Int-Location, I,J being Program of SCM+FSA holds
  if=0(a,I,J). 0 = a =0_goto  (card J + 3) & if=0(a,I,J). 1 =
goto  2 & if>0(a,I,J). 0 = a >0_goto  (card J + 3) & if>0(a,I
  ,J). 1 = goto  2
proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  set i = a =0_goto  (card J + 3);
A1: i <> halt SCM+FSA by SCMFSA_2:48,124;
A2: if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I ';' Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  ));
A3: dom Macro i = { 0,  1} by SCMFSA7B:4;
  then  0 in dom Macro i by TARSKI:def 2;
  hence if=0(a,I,J). 0 = (Directed Macro i). 0 by A2,SCMFSA8A:28
    .= i by A1,SCMFSA7B:7;
   1 in dom Macro i by A3,TARSKI:def 2;
  hence if=0(a,I,J). 1 = (Directed Macro i). 1 by A2,SCMFSA8A:28
    .= goto  2 by SCMFSA7B:8;
  set i = a >0_goto  (card J + 3);
A4: i <> halt SCM+FSA by SCMFSA_2:49,124;
A5: if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I ';' Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  ));
A6: dom Macro i = { 0,  1} by SCMFSA7B:4;
  then  0 in dom Macro i by TARSKI:def 2;
  hence if>0(a,I,J). 0 = (Directed Macro i). 0 by A5,SCMFSA8A:28
    .= i by A4,SCMFSA7B:7;
   1 in dom Macro i by A6,TARSKI:def 2;
  hence if>0(a,I,J). 1 = (Directed Macro i). 1 by A5,SCMFSA8A:28
    .= goto  2 by SCMFSA7B:8;
end;

theorem Th56:
  for a being Int-Location, I,J being Program of SCM+FSA, n being
Element of NAT st n < card I + card J + 3 holds n in dom if=0(a,I,J) & if=0(a,I
  ,J).n <> halt SCM+FSA
proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  let n be Element of NAT;
  set J1 = a =0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
  ';' I;
A1: card J1 = card (Macro (a =0_goto  (card J + 3)) ';' J ';' Goto
   (card I + 1)) + card I by SCMFSA6A:61
    .= card (Macro (a =0_goto  (card J + 3)) ';' J) + card Goto
  (card I + 1) + card I by SCMFSA6A:61
    .= card (Macro (a =0_goto  (card J + 3)) ';' J) + 1 + card I by SCMFSA8A:29
    .= card Macro (a =0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
    .= 2 + card J + 1 + card I by SCMFSA7B:6
    .= card I + card J + 3;
  assume
  n < card I + card J + 3;
  then  n in dom J1 by A1,AFINSQ_1:70;
  then
A2:  n in dom Directed J1 by FUNCT_4:105;
  then
A3: (Directed J1). n in rng Directed J1 by FUNCT_1:def 5;
  if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  then
A4: Directed J1 c= if=0(a,I,J) by SCMFSA6A:55;
  then dom Directed J1 c= dom if=0(a,I,J) by GRFUNC_1:8;
  hence n in dom if=0(a,I,J) by A2;
  if=0(a,I,J). n = (Directed J1). n by A2,A4,GRFUNC_1:8;
  hence thesis by A3,AMI_1:def 12;
end;

theorem Th57:
  for a being Int-Location, I,J being Program of SCM+FSA, n being
Element of NAT st n < card I + card J + 3 holds n in dom if>0(a,I,J) & if>0(a,I
  ,J).n <> halt SCM+FSA
proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  let n be Element of NAT;
  set J1 = a >0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
  ';' I;
A1: card J1 = card (Macro (a >0_goto  (card J + 3)) ';' J ';' Goto
   (card I + 1)) + card I by SCMFSA6A:61
    .= card (Macro (a >0_goto  (card J + 3)) ';' J) + card Goto
  (card I + 1) + card I by SCMFSA6A:61
    .= card (Macro (a >0_goto  (card J + 3)) ';' J) + 1 + card I by SCMFSA8A:29
    .= card Macro (a >0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
    .= 2 + card J + 1 + card I by SCMFSA7B:6
    .= card I + card J + 3;
  assume
  n < card I + card J + 3;
  then  n in dom J1 by A1,AFINSQ_1:70;
  then
A2:  n in dom Directed J1 by FUNCT_4:105;
  then
A3: (Directed J1). n in rng Directed J1 by FUNCT_1:def 5;
  if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  then
A4: Directed J1 c= if>0(a,I,J) by SCMFSA6A:55;
  then dom Directed J1 c= dom if>0(a,I,J) by GRFUNC_1:8;
  hence n in dom if>0(a,I,J) by A2;
  if>0(a,I,J). n = (Directed J1). n by A2,A4,GRFUNC_1:8;
  hence thesis by A3,AMI_1:def 12;
end;

theorem Th58:
  for s being State of SCM+FSA, I being Program of SCM+FSA st
  Directed I is_pseudo-closed_on s holds I ';' Stop SCM+FSA is_closed_on s & I
  ';' Stop SCM+FSA is_halting_on s & LifeSpan(ProgramPart(s +* (I ';' Stop
SCM+FSA +*
  Start-At( 0,SCM+FSA))),s +* (I ';' Stop SCM+FSA +*
  Start-At( 0,SCM+FSA))) = pseudo-LifeSpan(s,Directed
I) &
  (for n being Element of
  NAT st n < pseudo-LifeSpan(s,Directed I) holds IC
Comput(ProgramPart( (s +* (
I +*
Start-At( 0,SCM+FSA)))), (s +* (I +*
Start-At( 0,SCM+FSA))),n) = IC Comput(ProgramPart( (s +* (I ';'
Stop SCM+FSA +* Start-At( 0,SCM+FSA)))), (s +* (I ';'
Stop SCM+FSA +* Start-At( 0,SCM+FSA))),n)) &
for n being Element of NAT st n <= pseudo-LifeSpan(
  s,Directed
  I) holds DataPart Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s
+* (I +* Start-At( 0,SCM+FSA))),n)
   = DataPart
  Comput(ProgramPart( (s +* (I ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA)))), (s
+* (I ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA))),n)
proof
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  let I be Program of SCM+FSA;
  set I0 = Directed I;
  set I1 = I ';' Stop SCM+FSA;
  set s00 = s +* (I0 +* Start-At( 0,SCM+FSA));
  set s10 = s +* (I1 +* Start-At( 0,SCM+FSA));
  reconsider k = pseudo-LifeSpan(s00,I0) as Element of NAT;
  (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
  then
A1: halt SCM+FSA = (Stop SCM+FSA). (card I -' card I) by XREAL_1:234;
A2: DataPart s00 = DataPart s by SCMFSA8A:11
    .= DataPart s10 by SCMFSA8A:11;
  assume
A3: I0 is_pseudo-closed_on s;
  then
A4: I0 is_pseudo-closed_on s00 by Th50;
  defpred P[Nat] means k <= $1 implies IC Comput(ProgramPart( s10), s10,$1) =
   card I & CurInstr(ProgramPart s10,Comput(ProgramPart(s10),s10,$1))
   = halt SCM+FSA;
A5: I1 +* Start-At( 0,SCM+FSA) c= s10 by FUNCT_4:26;
  I1 c= I1 +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A6: I1 c= s10 by A5,XBOOLE_1:1;
A7: I0 c= I1 by SCMFSA6A:55;
  then
A8: dom I0 c= dom I1 by GRFUNC_1:8;
  ProgramPart Relocated(I0,0) c= I1 by A7,Th9;
  then
A9: ProgramPart Relocated(I0,0) c= s10 by A6,XBOOLE_1:1;
  s10 = s +* I1 +* Start-At( 0,SCM+FSA) by FUNCT_4:15;
  then
A10: IC s10 =  0 by AMI_1:111;
A11: I0 +* Start-At( 0,SCM+FSA) c= s00 by FUNCT_4:26;
A12: now
    let n be Element of NAT;
    assume
A13: n <= pseudo-LifeSpan(s00,I0);
    then IC Comput(ProgramPart( s00), s00,n) + 0 = IC Comput(ProgramPart( s10),
s10,n) by A11,A4,A9,A10,A2,Th51;
    hence IC Comput(ProgramPart( s00), s00,n) = IC Comput(ProgramPart( s10),
s10,n);
    thus DataPart Comput(ProgramPart( s00), s00,n) = DataPart Comput(
ProgramPart( s10), s10,n) by A11,A4,A9,A10,A2,A13,Th51;
  end;
A14: k = pseudo-LifeSpan(s,I0) by A3,Th50;
A15: s00 +* (I0 +* Start-At( 0,SCM+FSA)) = s +* ((I0 +*
Start-At( 0,SCM+FSA)) +* (
  I0 +* Start-At( 0,SCM+FSA))) by FUNCT_4:15
    .= s00;
A16: now
    let n be Element of NAT;
    assume
A17: n < pseudo-LifeSpan(s00,I0);
    then
    IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s00),s00,n),Comput(
ProgramPart(s00),s00,n)),0)
     = CurInstr(ProgramPart Comput(ProgramPart(s10),s10,n),Comput(ProgramPart(
s10),s10,n))
      by A11,A4,A9,A10,A2,Th51;
    hence CurInstr(ProgramPart Comput(ProgramPart(s00),s00,n),Comput(
ProgramPart(s00),s00,n))
     = CurInstr(ProgramPart Comput(ProgramPart(s10),s10,n),Comput(ProgramPart(
s10),s10,n)) by Th8;
    thus IC Comput(ProgramPart( s00), s00,n) in dom I0 by A15,A4,A17,
SCMFSA8A:31;
    thus CurInstr(ProgramPart Comput(ProgramPart(s00),s00,n),Comput(ProgramPart
(s00),s00,n))
     <> halt SCM+FSA by A15,A4,A17,SCMFSA8A:31
;
  end;
A18: now
    let n be Element of NAT;
    assume
A19: CurInstr(ProgramPart (s10),Comput(ProgramPart(s10),s10,n))
 = halt SCM+FSA;
    reconsider l = IC Comput(ProgramPart( s00), s00,n) as Element of NAT;
Z:  (ProgramPart Comput(ProgramPart(s00),s00,n))/.IC Comput(ProgramPart(s00),
s00,n)
 = Comput(ProgramPart(s00),s00,n).IC Comput(ProgramPart(s00),s00,n) by
AMI_1:150;
TX10: ProgramPart s10 = ProgramPart Comput(ProgramPart(s10),s10,n)
by AMI_1:144;
    assume
A20: k > n;
    then
A21: l in dom I0 by A3,A14,SCMFSA8A:def 5;
    CurInstr(ProgramPart Comput(ProgramPart(s10),s10,n),Comput(ProgramPart(s10)
,s10,n)) =
     CurInstr(ProgramPart Comput(ProgramPart(s00),s00,n),Comput(ProgramPart(s00
),s00,n)) by A16,A20
      .= s00.l by Z,AMI_1:54
      .= I0.l by A21,Th26;
    then halt SCM+FSA in rng I0 by A19,A21,FUNCT_1:def 5,TX10;
    hence contradiction by AMI_1:def 12;
  end;
z: card Stop SCM+FSA = 1 by SCMNORM:3;
  then card I1 = card I + 1 by SCMFSA6A:61;
  then card I < card I1 by NAT_1:13;
  then
A22:  card I in dom I1 by AFINSQ_1:70;
  card I < card I + card Stop SCM+FSA by NAT_1:13,z;
  then I1. card I = IncAddr(halt SCM+FSA,card I) by A1,Th13
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A23: s10. card I = halt SCM+FSA by A22,Th26;
A24: for n being Element of NAT st P[n] holds P[n + 1]
  proof
    let n be Element of NAT;
    assume
A25: P[n];
Z:  (ProgramPart Comput(ProgramPart( s10), s10,n+1))/.IC Comput(ProgramPart(
s10), s10,n+1)
 = Comput(ProgramPart( s10), s10,n+1).IC Comput(ProgramPart( s10), s10,n+1) by
AMI_1:150;
    assume
A26: k <= n + 1;
TX: ProgramPart s10 = ProgramPart Comput(ProgramPart( s10), s10,n+1)
by AMI_1:144;
T: ProgramPart s10 = ProgramPart Comput(ProgramPart(s10),s10,n)
by AMI_1:144;
    thus
K:   now
      per cases by A26,NAT_1:8;
      suppose
        k = n + 1;
        hence IC Comput(ProgramPart( s10), s10,n+1) = IC Comput(ProgramPart(
s00), s00,k) by A12
          .=  card ProgramPart I0 by A3,A14,SCMFSA8A:def 5
          .=  card I0 by AMI_1:105
          .=  card I by SCMFSA8A:34;
      end;
      suppose
A27:    k <= n;
        Comput(ProgramPart( s10), s10,n+1) = Following(ProgramPart s10,
        Comput(ProgramPart(s10),s10,n)) by AMI_1:14
          .= Exec(CurInstr(ProgramPart (s10),Comput(ProgramPart(s10),s10,n)),
           Comput(ProgramPart( s10), s10,n)) by T;
        hence IC Comput(ProgramPart( s10), s10,n+1) =  card I by A25,A27,
AMI_1:def 8;
      end;
    end;
    hence thesis by A23,Z,AMI_1:54,TX,K;
  end;
Y:  (ProgramPart Comput(ProgramPart(s10),s10,0))/.IC Comput(ProgramPart(s10),
s10,0)
 = Comput(ProgramPart(s10),s10,0).IC Comput(ProgramPart(s10),s10,0) by
AMI_1:150;
TX0: ProgramPart s10 = ProgramPart Comput(ProgramPart(s10),s10,0)
by AMI_1:144;
A28: P[0]
  proof
    assume
    k <= 0;
    then k = 0;
    hence IC Comput(ProgramPart( s10), s10,0) = IC Comput(ProgramPart( s00),
s00,k) by A12
      .=  card ProgramPart I0 by A3,A14,SCMFSA8A:def 5
      .=  card I0 by AMI_1:105
      .=  card I by SCMFSA8A:34;
    hence thesis by A23,Y,AMI_1:13,TX0;
  end;
A29: for n being Element of NAT holds P[n] from NAT_1:sch 1(A28,A24);
  now
    let n be Element of NAT;
    per cases;
    suppose
A30:  n < k;
      then IC Comput(ProgramPart( s00), s00,n) = IC Comput(ProgramPart( s10),
s10,n) by A12;
      then IC Comput(ProgramPart( s10), s10,n) in dom I0 by A3,A14,A30,
SCMFSA8A:def 5;
      hence IC Comput(ProgramPart( s10), s10,n) in dom I1 by A8;
    end;
    suppose
      k <= n;
      hence IC Comput(ProgramPart( s10), s10,n) in dom I1 by A22,A29;
    end;
  end;
  hence I1 is_closed_on s by SCMFSA7B:def 7;
  set s1 = s +* (I +* Start-At( 0,SCM+FSA));
A31: card ProgramPart I0 = card I0 by AMI_1:105
    .= card I by SCMFSA8A:34;
  P[k] by A29;
  then
A32: ProgramPart s10 halts_on s10 by AMI_1:146;
  hence I1 is_halting_on s by SCMFSA7B:def 8;
TX10: ProgramPart s10 = ProgramPart Comput(ProgramPart(s10),s10,k)
by AMI_1:144;
  CurInstr(ProgramPart s10,Comput(ProgramPart(s10),
s10,k))
   = halt SCM+FSA by A29;
  then
A33: LifeSpan(ProgramPart(s10),s10) = k by A32,A18,AMI_1:def 46,TX10;
  defpred P[Nat] means $1 < pseudo-LifeSpan(s,I0) implies IC
Comput(ProgramPart( s1), s1,$1) in dom I & IC Comput(ProgramPart( s1), s1,$1) =
IC Comput(ProgramPart( s10), s10,$1)
  & DataPart Comput(ProgramPart( s1), s1,$1) = DataPart Comput(ProgramPart( s10
), s10,$1);
A34: for n being Element of NAT st P[n] holds P[n + 1]
  proof
    let n be Element of NAT;
    set l = IC Comput(ProgramPart( s1), s1,n);
    set l0 = IC Comput(ProgramPart( s10), s10,n);
    assume
A35: P[n];
    assume
A36: n + 1 < pseudo-LifeSpan(s,I0);
    then
A37: l0 in dom I0 by A35,FUNCT_4:105,NAT_1:12;
A38: for f being FinSeq-Location holds Comput(ProgramPart( s1), s1,n).f =
Comput(ProgramPart(
    s10),
    s10,n).f by A35,A36,NAT_1:12,SCMFSA6A:38;
    for a being Int-Location holds Comput(ProgramPart( s1), s1,n).a = Comput(
ProgramPart(
    s10),
    s10,n).a by A35,A36,NAT_1:12,SCMFSA6A:38;
    then
A39: Comput(ProgramPart( s1), s1,n), Comput(ProgramPart( s10), s10,n)
equal_outside A by A35,A36,A38,NAT_1:12,SCMFSA6A:28;
A40: now
A41:  dom I = dom I0 by FUNCT_4:105;
      assume
A42:  I.l = halt SCM+FSA;
Y:  (ProgramPart Comput(ProgramPart(s00),s00,n))/.IC Comput(ProgramPart(s00),
s00,n)
 = Comput(ProgramPart(s00),s00,n).IC Comput(ProgramPart(s00),s00,n) by
AMI_1:150;
      n < k by A14,A36,NAT_1:12;
      then
A43:  CurInstr(ProgramPart Comput(ProgramPart(s00),s00,n),Comput(ProgramPart(
s00),s00,n))
   = Comput(ProgramPart( s00), s00,n).l0 by A12,Y
        .= s00.l0 by AMI_1:54
        .= I0.l by A35,A36,A41,Th26,NAT_1:12
        .= goto  card I by A35,A36,A42,NAT_1:12,SCMFSA8A:30;
T: ProgramPart s00 = ProgramPart Comput(ProgramPart(s00),s00,n)
by AMI_1:144;
A44:  IC Comput(ProgramPart( s00), s00,n+1) =
IC Following(ProgramPart s00,Comput(ProgramPart(s00)
,s00,n))
 by AMI_1:14
        .=  card I by A43,T,SCMFSA_2:95
        .=  card I0 by SCMFSA8A:34;
      IC Comput(ProgramPart( s00), s00,n+1) in dom I0 by A3,A36,SCMFSA8A:31;
      hence contradiction by A44,AFINSQ_1:70;
    end;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,n))/.IC Comput(ProgramPart(s1),s1,n)
 = Comput(ProgramPart(s1),s1,n).IC Comput(ProgramPart(s1),s1,n) by AMI_1:150;
U:  (ProgramPart Comput(ProgramPart(s10),s10,n))/.IC Comput(ProgramPart(s10),
s10,n)
 = Comput(ProgramPart(s10),s10,n).IC Comput(ProgramPart(s10),s10,n) by
AMI_1:150;
A45: CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s1),
s1,n)) = s1.l
 by Y,AMI_1:54
      .= I.l by A35,A36,Th26,NAT_1:12
      .= I0.l0 by A35,A36,A40,NAT_1:12,SCMFSA8A:30
      .= I1.l0 by A7,A37,GRFUNC_1:8
      .= s10.l0 by A8,A37,Th26
      .= CurInstr(ProgramPart Comput(ProgramPart(s10),s10,n),Comput(ProgramPart
(s10),s10,n))
       by U,AMI_1:54;
T: ProgramPart s10 = ProgramPart Comput(ProgramPart(s10),s10,n)
by AMI_1:144;
A46: Comput(ProgramPart( s10), s10,n+1) =
Following(ProgramPart s10,Comput(ProgramPart(s10),
s10,n))
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(
ProgramPart(s1),s1,n)),
      Comput(ProgramPart( s10), s10,n)) by A45,T;
    pseudo-LifeSpan(s,I0) = k by A3,Th50;
    then
A47: IC Comput(ProgramPart( s00), s00,n+1) = IC Comput(ProgramPart( s10), s10,n
+1) by A12,A36;
A48: dom I0 = dom I by FUNCT_4:105;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,n)
by AMI_1:144;
A49: Comput(ProgramPart( s1), s1,n+1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,n)
)
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(
ProgramPart(s1),s1,n)),
      Comput(ProgramPart( s1), s1,n)) by T;
    then
A50: for f being FinSeq-Location holds Comput(ProgramPart( s1), s1,n+1).f =
    Comput(ProgramPart( s10), s10,n+1).f by A46,A39,SCMFSA6A:31,32;
    IC Comput(ProgramPart( s00), s00,n+1) in dom I0 by A3,A36,SCMFSA8A:31;
    hence IC Comput(ProgramPart( s1), s1,n+1) in dom I by A47,A49,A46,A39,A48,
AMI_1:121,SCMFSA6A:32;
    thus IC Comput(ProgramPart( s1), s1,n+1) = IC Comput(ProgramPart( s10), s10
,n+1) by A49,A46,A39,AMI_1:121,SCMFSA6A:32;
    for a being Int-Location holds Comput(ProgramPart( s1), s1,n+1).a = Comput(
ProgramPart(
    s10),
    s10,n+1).a by A49,A46,A39,SCMFSA6A:30,32;
    hence thesis by A50,SCMFSA6A:38;
  end;
  IC Comput(ProgramPart( s10), s10,k) =  card I by A29;
  then
A51: IC Comput(ProgramPart( s00), s00,LifeSpan(ProgramPart(s10),s10)) =  card I
by A12,A33;
  for n be Element of NAT st not IC Comput(ProgramPart( s00), s00,n) in dom I0
holds
  LifeSpan(ProgramPart(s10),s10) <= n by A16,A33;
  hence LifeSpan(ProgramPart(s10),s10) = pseudo-LifeSpan(s,I0
) by A3,A51,A31,SCMFSA8A:def 5;
A52: P[0]
  proof
A53: IC Comput(ProgramPart( s1), s1,0) = IC s1 by AMI_1:13
      .= IC (s +* I +* Start-At( 0,SCM+FSA)) by FUNCT_4:15
      .=  0 by AMI_1:111;
    assume
    0 < pseudo-LifeSpan(s,I0);
    then IC Comput(ProgramPart( (s +* (I0 +* Start-At( 0,SCM+FSA)))), (s +* (I0
+* Start-At( 0,SCM+FSA))),0)
     in dom I0 by A3,SCMFSA8A:31;
    then IC (s +* (I0 +* Start-At( 0,SCM+FSA))) in dom I0 by AMI_1:13;
    then  0 in dom I0 by Th31;
    hence IC Comput(ProgramPart( s1), s1,0) in dom I by A53,FUNCT_4:105;
    thus IC Comput(ProgramPart( s1), s1,0) = IC Comput(ProgramPart( s10), s10,0
) by A10,A53,AMI_1:13;
    thus DataPart Comput(ProgramPart( s1), s1,0) = DataPart s1 by AMI_1:13
      .= DataPart s by SCMFSA8A:11
      .= DataPart s10 by SCMFSA8A:11
      .= DataPart Comput(ProgramPart( s10), s10,0) by AMI_1:13;
  end;
A54: for n being Element of NAT holds P[n] from NAT_1:sch 1(A52,A34);
  hence for n be Element of NAT st n < pseudo-LifeSpan(s,I0)
holds IC
  Comput(ProgramPart( s1), s1,n) = IC Comput(ProgramPart( s10), s10,n);
  let n be Element of NAT;
  assume
A55: n <= pseudo-LifeSpan(s,Directed I);
  per cases by A55,XXREAL_0:1;
  suppose
    n < pseudo-LifeSpan(s,I0);
    hence thesis by A54;
  end;
  suppose
A56: n = pseudo-LifeSpan(s,I0);
    hereby
      per cases by NAT_1:6;
      suppose
A57:    n = 0;
        hence DataPart Comput(ProgramPart( s1), s1,n) = DataPart s1 by AMI_1:13
          .= DataPart s by SCMFSA8A:11
          .= DataPart s10 by SCMFSA8A:11
          .= DataPart Comput(ProgramPart( s10), s10,n) by A57,AMI_1:13;
      end;
      suppose
        ex m be Nat st n = m + 1;
        then consider m being Nat such that
A58:    n = m + 1;
        reconsider m as Element of NAT by ORDINAL1:def 13;
T: ProgramPart s10 = ProgramPart Comput(ProgramPart(s10),s10,m)
by AMI_1:144;
A59:    Comput(ProgramPart( s10), s10,n) =
Following(ProgramPart s10,Comput(ProgramPart(s10),
s10,m))
 by A58,AMI_1:14
          .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s10),s10,m),Comput(
ProgramPart(s10),s10,m)),
          Comput(ProgramPart( s10), s10,m)) by T;
        set i = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(
ProgramPart(s1),s1,m));
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m)
by AMI_1:144;
A60:    Comput(ProgramPart( s1), s1,n) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,m)
)
 by A58,AMI_1:14
          .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(
ProgramPart(s1),s1,m)),
          Comput(ProgramPart( s1), s1,m)) by T;
        set l0 = IC Comput(ProgramPart( s10), s10,m);
        set l = IC Comput(ProgramPart( s1), s1,m);
A61:    m + 0 < pseudo-LifeSpan(s,I0) by A56,A58,XREAL_1:8;
        then
A62:    l = l0 by A54;
A63:    l in dom I by A54,A61;
        then
A64:    l0 in dom I0 by A62,FUNCT_4:105;
Y:  (ProgramPart Comput(ProgramPart( s1), s1,m))/.IC Comput(ProgramPart( s1),
s1,m)
 = Comput(ProgramPart( s1), s1,m).IC Comput(ProgramPart( s1), s1,m) by
AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(s10),s10,m))/.IC Comput(ProgramPart(s10),
s10,m)
 = Comput(ProgramPart(s10),s10,m).IC Comput(ProgramPart(s10),s10,m) by
AMI_1:150;
A65:    i = s1.l by Y,AMI_1:54
          .= I.l by A54,A61,Th26;
        I0 c= I1 by SCMFSA6A:55;
        then
A66:    I0.l0 = I1.l0 by A64,GRFUNC_1:8
          .= s10.l0 by A8,A64,Th26
          .= CurInstr(ProgramPart Comput(ProgramPart(s10),s10,m),Comput(
ProgramPart(s10),s10,m))
           by Z,AMI_1:54;
A67:    DataPart Comput(ProgramPart( s1), s1,m) = DataPart Comput(ProgramPart(
s10), s10,m) by A54,A61;
        hereby
          per cases;
          suppose
A68:        i = halt SCM+FSA;
            then CurInstr(ProgramPart Comput(ProgramPart(s10),s10,m),Comput(
ProgramPart(s10),s10,m))
             = goto  card I by A63,A62,A65,A66,SCMFSA8A:30;
            then InsCode CurInstr(ProgramPart Comput(ProgramPart(s10),s10,m),
            Comput(ProgramPart(s10),s10,m)) = 6 by SCMFSA_2:47;
            then
A69:        InsCode CurInstr(ProgramPart Comput(ProgramPart(s10),s10,m),
Comput(ProgramPart(s10),s10,m)) in {0,6,7,8} by ENUMSET1:def 2
;
            thus DataPart Comput(ProgramPart( s1), s1,n) = DataPart Comput(
ProgramPart( s1), s1,m) by A60,A68,AMI_1:def 8
              .= DataPart Comput(ProgramPart( s10), s10,m) by A54,A61
              .= DataPart Comput(ProgramPart( s10), s10,n) by A59,A69,Th32;
          end;
          suppose
            i <> halt SCM+FSA;
            then
            CurInstr(ProgramPart Comput(ProgramPart(s10),s10,m),Comput(
ProgramPart(s10),s10,m))
             = i by A63,A62,A65,A66,SCMFSA8A:30;
            hence thesis by A60,A59,A67,SCMFSA6C:5;
          end;
        end;
      end;
    end;
  end;
end;

theorem Th59:
  for s being State of SCM+FSA, I being Program of SCM+FSA st
  Directed I is_pseudo-closed_on s holds DataPart Result(ProgramPart(s +* (I
';' Stop
  SCM+FSA +* Start-At( 0,SCM+FSA))),s +* (I ';' Stop
  SCM+FSA +* Start-At( 0,SCM+FSA))) =
  DataPart Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s +* (I +*
Start-At( 0,SCM+FSA))),
  pseudo-LifeSpan(s,Directed I))
proof
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  set I0 = Directed I;
  set I1 = I ';' Stop SCM+FSA;
  set s2 = s +* (I +* Start-At( 0,SCM+FSA));
  set s10 = s +* (I1 +* Start-At( 0,SCM+FSA));
  set k = pseudo-LifeSpan(s,I0);
  assume
A1: I0 is_pseudo-closed_on s;
  then
A2: DataPart Comput(ProgramPart( s2), s2,k) = DataPart Comput(ProgramPart( s10)
, s10,k) by Th58;
  I1 is_halting_on s by A1,Th58;
  then
A3: ProgramPart s10 halts_on s10 by SCMFSA7B:def 8;
  LifeSpan(ProgramPart(s10),s10) = k by A1,Th58;
  hence thesis by A2,A3,AMI_1:122;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA st s.intloc 0
= 1 & Directed I is_pseudo-closed_on s holds DataPart IExec(I ';' Stop SCM+FSA,
s) = DataPart Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s +* (I
+* Start-At( 0,SCM+FSA))),
pseudo-LifeSpan(
  s,
  Directed I))
proof
  let s be State of SCM+FSA;
  set A = NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  set I0 = Directed I;
  set I1 = I ';' Stop SCM+FSA;
  set s2 = s +* (I +* Start-At( 0,SCM+FSA));
  set s10 = s +* (I1 +* Start-At( 0,SCM+FSA));
  set k = pseudo-LifeSpan(s,I0);
  assume
A1: s.intloc 0 = 1;
  assume
A2: I0 is_pseudo-closed_on s;
X: s10 = s +* Initialized I1 by A1,Th18;
  thus DataPart IExec(I1,s) = DataPart (Result(ProgramPart(s +* Initialized I1)
,s +* Initialized I1) +* s | A)
  by SCMFSA6B:def 1
    .= DataPart (Result(ProgramPart(s +* Initialized I1),s +* Initialized I1))
by Th35
    .= DataPart(Result(ProgramPart(s10),s10)) by X
    .= DataPart Comput(ProgramPart( s2), s2,k) by A2,Th59;
end;

theorem Th61:
  for I,J being Program of SCM+FSA,a being Int-Location holds if=0
  (a,I,J). (card I + card J + 3) = halt SCM+FSA
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
A1: if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  set II = a =0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
  ';' I;
A2: card II = card (Macro (a =0_goto  (card J + 3)) ';' J ';' Goto
   (card I + 1)) + card I by SCMFSA6A:61
    .= card (Macro (a =0_goto  (card J + 3)) ';' J) + card Goto
  (card I + 1) + card I by SCMFSA6A:61
    .= card (Macro (a =0_goto  (card J + 3)) ';' J) + 1 + card I by SCMFSA8A:29
    .= card Macro (a =0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
    .= 2 + card J + 1 + card I by SCMFSA7B:6
    .= card I + card J + 3;
  then
A3: card I + card J + 3 -' card II = 0 by XREAL_1:234;
y: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
  card Stop SCM+FSA = 1 by SCMNORM:3;
  then card I + card J + 3 < card II + card Stop SCM+FSA by A2,NAT_1:13;
  hence
  if=0(a,I,J). (card I + card J + 3) = IncAddr(halt SCM+FSA,card II
  ) by A1,A2,A3,Th13,y
    .= halt SCM+FSA by SCMFSA_4:8;
end;

theorem Th62:
  for I,J being Program of SCM+FSA,a being Int-Location holds if>0
  (a,I,J). (card I + card J + 3) = halt SCM+FSA
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
A1: if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  set II = a >0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
  ';' I;
A2: card II = card (Macro (a >0_goto  (card J + 3)) ';' J ';' Goto
   (card I + 1)) + card I by SCMFSA6A:61
    .= card (Macro (a >0_goto  (card J + 3)) ';' J) + card Goto
  (card I + 1) + card I by SCMFSA6A:61
    .= card (Macro (a >0_goto  (card J + 3)) ';' J) + 1 + card I by SCMFSA8A:29
    .= card Macro (a >0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
    .= 2 + card J + 1 + card I by SCMFSA7B:6
    .= card I + card J + 3;
  then
A3: card I + card J + 3 -' card II = 0 by XREAL_1:234;
y: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
  card Stop SCM+FSA = 1 by SCMNORM:3;
  then card I + card J + 3 < card II + card Stop SCM+FSA by A2,NAT_1:13;
  hence
  if>0(a,I,J). (card I + card J + 3) = IncAddr(halt SCM+FSA,card II
  ) by A1,A2,A3,Th13,y
    .= halt SCM+FSA by SCMFSA_4:8;
end;

theorem Th63:
  for I,J being Program of SCM+FSA,a being Int-Location holds if=0
  (a,I,J). (card J + 2) = goto  (card I + card J + 3)
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  set JJ = a =0_goto  (card J + 3) ';' J;
  set J3 = a =0_goto  (card J + 3) ';' J ';' Goto  (card I + 1);
A1: if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
A2: InsCode goto  (card I + card J + 3) = 6 by SCMFSA_2:47;
A3: card JJ = card Macro (a =0_goto  (card J + 3)) + card J by SCMFSA6A:61
    .= 2 + card J by SCMFSA7B:6;
  then card J + 2 -' card JJ = 0 by XREAL_1:234;
  then
A4: goto  (card I + 1) = (Goto  (card I + 1)). (card J + 2
  -' card JJ) by SCMFSA8A:47;
  card Goto  (card I + 1) = 1 by SCMFSA8A:29;
  then card J + 2 < card JJ + card Goto  (card I + 1) by A3,NAT_1:13;
  then
A5: J3. (card J + 2) = IncAddr(goto  (card I + 1),card JJ) by A3,A4,Th13
    .= goto  (card I + 1 + (card J + 2)) by A3,SCMFSA_4:14
    .= goto  (card I + card J + (1 + 2));
  card Goto  (card I + 1) = 1 by SCMFSA8A:29;
  then card J3 = card J + 2 + 1 by A3,SCMFSA6A:61
    .= card J + (2 + 1);
  then card J3 = card J + 2 + 1;
  then card J + 2 < card J3 by NAT_1:13;
  then
A6:  (card J + 2) in dom J3 by AFINSQ_1:70;
  then (J3 ';' (I ';' Stop SCM+FSA)). (card J + 2) = (Directed J3).
   (card J + 2) by SCMFSA8A:28
    .= goto  (card I + card J + 3) by A5,A2,A6,SCMFSA8A:30,SCMFSA_2:124;
  hence thesis by A1,SCMFSA6A:67;
end;

theorem Th64:
  for I,J being Program of SCM+FSA,a being Int-Location holds if>0
  (a,I,J). (card J + 2) = goto  (card I + card J + 3)
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  set JJ = a >0_goto  (card J + 3) ';' J;
  set J3 = a >0_goto  (card J + 3) ';' J ';' Goto  (card I + 1);
A1: if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
A2: InsCode goto  (card I + card J + 3) = 6 by SCMFSA_2:47;
A3: card JJ = card Macro (a >0_goto  (card J + 3)) + card J by SCMFSA6A:61
    .= 2 + card J by SCMFSA7B:6;
  then card J + 2 -' card JJ = 0 by XREAL_1:234;
  then
A4: goto  (card I + 1) = (Goto  (card I + 1)). (card J + 2
  -' card JJ) by SCMFSA8A:47;
  card Goto  (card I + 1) = 1 by SCMFSA8A:29;
  then card J + 2 < card JJ + card Goto  (card I + 1) by A3,NAT_1:13;
  then
A5: J3. (card J + 2) = IncAddr(goto  (card I + 1),card JJ) by A3,A4,Th13
    .= goto  (card I + 1 + (card J + 2)) by A3,SCMFSA_4:14
    .= goto  (card I + card J + (1 + 2));
  card Goto  (card I + 1) = 1 by SCMFSA8A:29;
  then card J3 = card J + 2 + 1 by A3,SCMFSA6A:61
    .= card J + (2 + 1);
  then card J3 = card J + 2 + 1;
  then card J + 2 < card J3 by NAT_1:13;
  then
A6:  (card J + 2) in dom J3 by AFINSQ_1:70;
  then (J3 ';' (I ';' Stop SCM+FSA)). (card J + 2) = (Directed J3).
   (card J + 2) by SCMFSA8A:28
    .= goto  (card I + card J + 3) by A5,A2,A6,SCMFSA8A:30,SCMFSA_2:124;
  hence thesis by A1,SCMFSA6A:67;
end;

theorem Th65:
  for J being Program of SCM+FSA,a being Int-Location holds if=0(a
  ,Goto  2,J). (card J + 3) = goto  (card J + 5)
proof
  let J be Program of SCM+FSA;
  let a be Int-Location;
  set JJ = a =0_goto  (card J + 3) ';' J;
  set J3 = a =0_goto  (card J + 3) ';' J ';' Goto  2;
  set J4 = a =0_goto  (card J + 3) ';' J ';' Goto  2 ';' Goto
   2;
A1: card Goto  2 = 1 by SCMFSA8A:29;
  card JJ = card Macro (a =0_goto  (card J + 3)) + card J by SCMFSA6A:61
    .= 2 + card J by SCMFSA7B:6;
  then
A2: card J3 = card J + 2 + 1 by A1,SCMFSA6A:61
    .= card J + (2 + 1);
  then card J + 3 -' card J3 = 0 by XREAL_1:234;
  then
A3: goto  2 = (Goto  2). (card J + 3 -' card J3) by SCMFSA8A:47;
  card Goto  2 = 1 by SCMFSA8A:29;
  then card J + 3 < card J3 + card Goto  2 by A2,NAT_1:13;
  then
A4: J4. (card J + 3) = IncAddr(goto  2,card J3) by A2,A3,Th13
    .= goto  (2 + (card J + 3)) by A2,SCMFSA_4:14
    .= goto  (card J + (2 + 3));
  card Goto  2 = 1 by SCMFSA8A:29;
  then
A5: if=0(a,Goto  2,J) = (a =0_goto  (card J + 3) ';' J ';' Goto
   (1 + 1) ';' Goto  2) ';' Stop SCM+FSA by SCMFSA8B:def 1;
A6: InsCode goto  (card J + 5) = 6 by SCMFSA_2:47;
  card J4 = card J + 3 + 1 by A1,A2,SCMFSA6A:61
    .= card J + (3 + 1);
  then card J4 = card J + 3 + 1;
  then card J + 3 < card J4 by NAT_1:13;
  then
A7:  (card J + 3) in dom J4 by AFINSQ_1:70;
  then (J4 ';' Stop SCM+FSA). (card J + 3) = (Directed J4). (card
  J + 3) by SCMFSA8A:28
    .= goto  (card J + 5) by A4,A6,A7,SCMFSA8A:30,SCMFSA_2:124;
  hence thesis by A5;
end;

theorem Th66:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & Directed I is_pseudo-closed_on s
holds if=0(a,I,J) is_halting_on s & if=0(a,I,J) is_closed_on s & LifeSpan(
ProgramPart(s +*
  (if=0(a,I,J) +* Start-At( 0,SCM+FSA))),s +*
  (if=0(a,I,J) +* Start-At( 0,SCM+FSA))) = LifeSpan(ProgramPart(s +* (I ';'
  Stop SCM+FSA +*
  Start-At( 0,SCM+FSA))),s +* (I ';'
  Stop SCM+FSA +*
  Start-At( 0,SCM+FSA))) + 1
proof
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I0 = Directed I;
  set I1 = I ';' Stop SCM+FSA;
  set s00 = s +* (I0 +* Start-At( 0,SCM+FSA));
  set s3 = s +* (if=0(a,I,J) +* Start-At( 0,SCM+FSA));
  set s4 = Comput(ProgramPart( s3), s3,1);
  set i = a =0_goto  (card J + 3);
A1: I0 +* Start-At( 0,SCM+FSA) c= s00 by FUNCT_4:26;
  card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if=0(a,I,J) by NAT_1:13;
  then
A2:  (card I + card J + 3) in dom if=0(a,I,J) by AFINSQ_1:70;
A3: if=0(a,I,J) c= if=0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  if=0(a,I,J) +* Start-At( 0,SCM+FSA) c= s3 by FUNCT_4:26;
  then
A4: if=0(a,I,J) c= s3 by A3,XBOOLE_1:1;
A5: not a in dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
A6:  0 in dom if=0(a,I,J) by Th54;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA))
  by GRFUNC_1:8;
  then
A7: s3. 0 = (if=0(a,I,J) +* Start-At( 0,SCM+FSA)). 0
by A6,FUNCT_4:14
    .= if=0(a,I,J). 0 by A6,SCMFSA6B:7
    .= i by Th55;
A8: card (i ';' J ';' Goto  (card I + 1)) = card (Macro i ';' J) +
  card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by SCMFSA7B:6
    .= card J + (2 + 1);
  IC SCM+FSA in dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
  then
A9: IC s3 = (if=0(a,I,J) +* Start-At( 0,SCM+FSA)).IC SCM+FSA
by FUNCT_4:14
    .=  0 by SF_MASTR:66;
A10: if=0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
A11: Comput(ProgramPart( s3), s3,0+1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A9,A7,Y;
A12: if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  then if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
;
  then ProgramPart Relocated(I1,card J + 3) c= if=0(a,I,J) by A8,FUNCT_4:26;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A4,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:99;
  then
A13: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
  ProgramPart Relocated(I0,card J + 3) c= ProgramPart Relocated(I1,card J
  + 3) by Th12,SCMFSA6A:55;
  then
A14: ProgramPart Relocated(I0,card J + 3) c= s4 by A13,XBOOLE_1:1;
A15: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A16: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A15,SCMFSA6A:38
      .= s4.f by A11,SCMFSA_2:96;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A15,SCMFSA6A:38
      .= s4.a by A11,SCMFSA_2:96;
  end;
  then
A17: DataPart s00 = DataPart s4 by A16,SCMFSA6A:38;
  assume
  s.a = 0;
  then s3.a = 0 by A5,FUNCT_4:12;
  then
A18: IC Comput(ProgramPart(s3),s3,1) =  (card J + 3) by A11,SCMFSA_2:96;
  assume
A19: I0 is_pseudo-closed_on s;
  then
A20: pseudo-LifeSpan(s,I0) = LifeSpan(ProgramPart(s +* (I1 +*
Start-At( 0,SCM+FSA))),s +* (I1 +*
Start-At( 0,SCM+FSA))) by Th58;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A21: I0 is_pseudo-closed_on s00 by A19,Th52;
Y:  (ProgramPart Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,I0) + 1))/.
IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1)
 = Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1)
.
 IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1
) by AMI_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
TX: ProgramPart s3
 = ProgramPart Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,I0) +
1)
by AMI_1:144;
A22: IC Comput(ProgramPart(s3),s3,pseudo-LifeSpan(s00,I0) +
1) = IC Comput(
ProgramPart( s3), s4,
  pseudo-LifeSpan(s00,I0)) by AMI_1:51
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s00
,I0)) + (card J + 3)
by A1,A21,T,A14,A18,A17,Th51
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s,I0)
) + (card J + 3)
by A19,Th50
    .=  card ProgramPart I0 + (card J + 3) by A19,SCMFSA8A:def 5
    .=  card I0 + (card J + 3) by AMI_1:105
    .=  (card I + (card J + 3)) by SCMFSA8A:34
    .=  (card I + card J + 3);
  then
A23: CurInstr(ProgramPart s3,
     Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) +
1)) = s3. (card
  I + card J + 3) by Y,TX,AMI_1:54
    .= if=0(a,I,J). (card I + card J + 3) by A10,A2,GRFUNC_1:8
    .= halt SCM+FSA by Th61;
  then
A24: ProgramPart s3 halts_on s3 by TX,AMI_1:146;
  hence if=0(a,I,J) is_halting_on s by SCMFSA7B:def 8;
  now
    let k be Element of NAT;
    per cases;
    suppose
      k = 0;
      then Comput(ProgramPart( s3), s3,k) = s3 by AMI_1:13;
      then IC Comput(ProgramPart( s3), s3,k) =  0 by Th31;
      hence IC Comput(ProgramPart( s3), s3,k) in dom if=0(a,I,J) by Th54;
    end;
    suppose
A25:  0 < k & k < pseudo-LifeSpan(s00,I0) + 1;
      card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
        .= card I + card J + 3 + 1;
      then
A26:  card I + card J + 3 < card if=0(a,I,J) by XREAL_1:31;
      0 + 1 <= k by A25,INT_1:20;
      then consider k1 being Nat such that
A27:  1 + k1 = k by NAT_1:10;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider n = IC Comput(ProgramPart( s00), s00,k1) as Element of NAT;
A28:  k1 < pseudo-LifeSpan(s00,I0) by A25,A27,XREAL_1:8;
      then k1 < pseudo-LifeSpan(s,I0) by A19,Th50;
      then  n in dom I0 by A19,SCMFSA8A:31;
      then n < card I0 by AFINSQ_1:70;
      then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
      then n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
      then
A29:  n + (card J + 3) < card if=0(a,I,J) by A26,XXREAL_0:2;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
      IC Comput(ProgramPart( s3), s3,k) = IC Comput(ProgramPart( s3), s4,k1)
by A27,AMI_1:51
        .= IC Comput(ProgramPart( s00), s00,k1) + (card J + 3) by A1,A21,A14
,A18,A17,A28,T,Th51;
      hence IC Comput(ProgramPart( s3), s3,k) in dom if=0(a,I,J) by A29,
AFINSQ_1:70;
    end;
    suppose
      0 < k & pseudo-LifeSpan(s00,I0) + 1 <= k;
      hence IC Comput(ProgramPart( s3), s3,k) in dom if=0(a,I,J) by A2,A22,A23,
AMI_1:52;
    end;
  end;
  hence if=0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
  now
    set J1 = a =0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
    ';' I;
    let k be Element of NAT;
    assume
A30: CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,k)) = halt SCM+FSA;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:144;
    assume
    not pseudo-LifeSpan(s00,I0) + 1 <= k;
    then
A31: k <= pseudo-LifeSpan(s00,I0) by NAT_1:13;
A32:  0 in dom if=0(a,I,J) by Th54;
A33: InsCode (a =0_goto  (card J + 3)) = 7 by SCMFSA_2:48;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(s3),s3,k))/.IC Comput(ProgramPart(s3),s3,k)
 = Comput(ProgramPart(s3),s3,k).IC Comput(ProgramPart(s3),s3,k) by AMI_1:150;
    CurInstr(ProgramPart Comput(ProgramPart(s3),s3,0),Comput(ProgramPart(s3),s3
,0))
     = CurInstr(ProgramPart s3,s3) by u
      .= s3. 0 by Th31,Y
      .= if=0(a,I,J). 0 by A32,Th26
      .= a =0_goto  (card J + 3) by Th55;
    then k <> 0 by A30,A33,SCMFSA_2:124,TX3;
    then consider k1 being Nat such that
A34: k1 + 1 = k by NAT_1:6;
    reconsider k1 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(ProgramPart( s00), s00,k1) as Element of NAT;
    k1 < k by A34,XREAL_1:31;
    then
A35: k1 < pseudo-LifeSpan(s00,I0) by A31,XXREAL_0:2;
    then k1 < pseudo-LifeSpan(s,I0) by A19,Th50;
    then  n in dom I0 by A19,SCMFSA8A:31;
    then n < card I0 by AFINSQ_1:70;
    then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
    then
A36: n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
A37: IC Comput(ProgramPart( s3), s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A34,AMI_1:51
      .= IC Comput(ProgramPart( s00), s00,k1) + (card J + 3) by A1,A21,A14,A18
,A17,A35,Th51,T;
    card J1 = card (Macro (a =0_goto  (card J + 3)) ';' J ';' Goto
     (card I + 1)) + card I by SCMFSA6A:61
      .= card (Macro (a =0_goto  (card J + 3)) ';' J) + card Goto
     (card I + 1) + card I by SCMFSA6A:61
      .= card (Macro (a =0_goto  (card J + 3)) ';' J) + 1 + card I by
SCMFSA8A:29
      .= card Macro (a =0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
      .= 2 + card J + 1 + card I by SCMFSA7B:6
      .= card I + card J + 3;
    then IC Comput(ProgramPart( s3), s3,k) in dom J1 by A37,A36,AFINSQ_1:70;
    then
A38: IC Comput(ProgramPart( s3), s3,k) in dom Directed J1 by FUNCT_4:105;
    then
A39: (Directed J1).IC Comput(ProgramPart( s3), s3,k) in rng Directed J1 by
FUNCT_1:def 5;
    card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
      .= card I + card J + 3 + 1;
    then card I + card J + 3 < card if=0(a,I,J) by XREAL_1:31;
    then n + (card J + 3) < card if=0(a,I,J) by A36,XXREAL_0:2;
    then
A40: IC Comput(ProgramPart( s3), s3,k) in dom if=0(a,I,J) by A37,AFINSQ_1:70;
A41: CurInstr(ProgramPart Comput(ProgramPart(s3),s3,k),Comput(ProgramPart(s3),
s3,k))
 = s3.IC Comput(ProgramPart( s3), s3,k) by Z,AMI_1:54
      .= if=0(a,I,J).IC Comput(ProgramPart( s3), s3,k) by A40,Th26;
    Directed J1 c= if=0(a,I,J) by A12,SCMFSA6A:55;
    then
    if=0(a,I,J).IC Comput(ProgramPart( s3), s3,k) = (Directed J1).IC Comput(
ProgramPart( s3), s3,
    k) by A38,GRFUNC_1:8;
    hence contradiction by A30,A39,A41,AMI_1:def 12,TX3;
  end;
  then LifeSpan(ProgramPart(s3),s3) = pseudo-LifeSpan(s00,
I0) + 1 by A23,A24,TX,AMI_1:def 46;
  hence thesis by A19,A20,Th50;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
  read-write Int-Location st s.intloc 0 = 1 & s.a = 0 & Directed I
  is_pseudo-closed_on s holds DataPart IExec(if=0(a,I,J),s) = DataPart IExec(I
  ';' Stop SCM+FSA,s)
proof
  let ss be State of SCM+FSA;
  set A = NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I0 = Directed I;
  set s = Initialize ss;
  set I1 = I ';' Stop SCM+FSA;
  set s00 = s +* (I0 +* Start-At( 0,SCM+FSA));
  set s3 = s +* (if=0(a,I,J) +* Start-At( 0,SCM+FSA));
  set s4 = Comput(ProgramPart( s3), s3,1);
  set i = a =0_goto  (card J + 3);
  assume
A1: ss.intloc 0 = 1;
  set s1 = s +* (I1 +* Start-At( 0,SCM+FSA));
  assume
  ss.a = 0;
  then
A2: s.a = 0 by SCMFSA6C:3;
  IC SCM+FSA in dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
  then
A3: IC s3 = (if=0(a,I,J) +* Start-At( 0,SCM+FSA)).IC SCM+FSA
by FUNCT_4:14
    .=  0 by SF_MASTR:66;
A4:  0 in dom if=0(a,I,J) by Th54;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA))
  by GRFUNC_1:8;
  then
A5: s3. 0 = (if=0(a,I,J) +* Start-At( 0,SCM+FSA)). 0
by A4,FUNCT_4:14
    .= if=0(a,I,J). 0 by A4,SCMFSA6B:7
    .= i by Th55;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
A6: Comput(ProgramPart( s3), s3,0+1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A3,A5,Y;
  not a in dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  then s3.a = 0 by A2,FUNCT_4:12;
  then
A7: IC Comput(ProgramPart(s3),s3,1) =  (card J + 3) by A6,SCMFSA_2:96;
  assume
  I0 is_pseudo-closed_on ss;
  then
A8: I0 is_pseudo-closed_on s by A1,Th53;
  then
A9: LifeSpan(ProgramPart(s1),s1) = pseudo-LifeSpan(s,I0) by
Th58;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A10: I0 is_pseudo-closed_on s00 by A8,Th52;
A11: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A12: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A11,SCMFSA6A:38
      .= s4.f by A6,SCMFSA_2:96;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A11,SCMFSA6A:38
      .= s4.a by A6,SCMFSA_2:96;
  end;
  then
A13: DataPart s00 = DataPart s4 by A12,SCMFSA6A:38;
  card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if=0(a,I,J) by NAT_1:13;
  then
A14:  (card I + card J + 3) in dom if=0(a,I,J) by AFINSQ_1:70;
A15: card (i ';' J ';' Goto  (card I + 1)) = card (Macro i ';' J) +
  card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by SCMFSA7B:6
    .= card J + (2 + 1);
  s +* Initialized if=0(a,I,J) = Initialize s +* (if=0(a,I,J) +*
  Start-At( 0,SCM+FSA)) by SCMFSA8A:13;
  then
A16: s +* Initialized if=0(a,I,J) = s3 by Th15;
A17: if=0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
A18: if=0(a,I,J) c= if=0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  if=0(a,I,J) +* Start-At( 0,SCM+FSA) c= s3 by FUNCT_4:26;
  then
A19: if=0(a,I,J) c= s3 by A18,XBOOLE_1:1;
A20: I0 +* Start-At( 0,SCM+FSA) c= s00 by FUNCT_4:26;
A21: if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  then if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
;
  then ProgramPart Relocated(I1,card J + 3) c= if=0(a,I,J) by A15,FUNCT_4:26;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A19,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:99;
  then
A22: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
  ProgramPart Relocated(I0,card J + 3) c= ProgramPart Relocated(I1,card J
  + 3) by Th12,SCMFSA6A:55;
  then
A23: ProgramPart Relocated(I0,card J + 3) c= s4 by A22,XBOOLE_1:1;
Y:  (ProgramPart Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,I0) + 1))/.
IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1)
 = Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1)
.
 IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1
) by AMI_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
TX3: ProgramPart s3 = ProgramPart
Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,I0) +1)
by AMI_1:144;
  IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) +
1) = IC Comput(
ProgramPart( s3), s4,
  pseudo-LifeSpan(s00,I0)) by AMI_1:51
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s00
,I0)) + (card J + 3)
by A20,A10,A23,A7,A13,Th51,T
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s,I0)
) + (card J + 3)
by A8,Th50
    .=  card ProgramPart I0 + (card J + 3) by A8,SCMFSA8A:def 5
    .=  card I0 + (card J + 3) by AMI_1:105
    .=  (card I + (card J + 3)) by SCMFSA8A:34
    .=  (card I + card J + 3);
  then
A24: CurInstr(ProgramPart s3,
   Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1)) = s3. (card
  I + card J + 3) by Y,AMI_1:54,TX3
    .= if=0(a,I,J). (card I + card J + 3) by A17,A14,GRFUNC_1:8
    .= halt SCM+FSA by Th61;
  then
A25: ProgramPart s3 halts_on s3 by AMI_1:146;
  now
    set J1 = a =0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
    ';' I;
    let k be Element of NAT;
    assume
A26: CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,k)) = halt SCM+FSA;
    assume
    not pseudo-LifeSpan(s00,I0) + 1 <= k;
    then
A27: k <= pseudo-LifeSpan(s00,I0) by NAT_1:13;
A28:  0 in dom if=0(a,I,J) by Th54;
A29: InsCode (a =0_goto  (card J + 3)) = 7 by SCMFSA_2:48;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
    CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,0))
     = CurInstr(ProgramPart s3,s3) by u
      .= s3. 0 by Th31,Y
      .= if=0(a,I,J). 0 by A28,Th26
      .= a =0_goto  (card J + 3) by Th55;
    then k <> 0 by A26,A29,SCMFSA_2:124;
    then consider k1 being Nat such that
A30: k1 + 1 = k by NAT_1:6;
    reconsider k1 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(ProgramPart( s00), s00,k1) as Element of NAT;
    k1 < k by A30,XREAL_1:31;
    then
A31: k1 < pseudo-LifeSpan(s00,I0) by A27,XXREAL_0:2;
    then k1 < pseudo-LifeSpan(s,I0) by A8,Th50;
    then  n in dom I0 by A8,SCMFSA8A:31;
    then n < card I0 by AFINSQ_1:70;
    then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
    then
A32: n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
A33: IC Comput(ProgramPart( s3), s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A30,AMI_1:51
      .= IC Comput(ProgramPart( s00), s00,k1) + (card J + 3) by A20,A10,A23,A7
,A13,A31,Th51,T;
    card J1 = card (Macro (a =0_goto  (card J + 3)) ';' J ';' Goto
     (card I + 1)) + card I by SCMFSA6A:61
      .= card (Macro (a =0_goto  (card J + 3)) ';' J) + card Goto
     (card I + 1) + card I by SCMFSA6A:61
      .= card (Macro (a =0_goto  (card J + 3)) ';' J) + 1 + card I by
SCMFSA8A:29
      .= card Macro (a =0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
      .= 2 + card J + 1 + card I by SCMFSA7B:6
      .= card I + card J + 3;
    then IC Comput(ProgramPart( s3), s3,k) in dom J1 by A33,A32,AFINSQ_1:70;
    then
A34: IC Comput(ProgramPart( s3), s3,k) in dom Directed J1 by FUNCT_4:105;
    then
A35: (Directed J1).IC Comput(ProgramPart( s3), s3,k) in rng Directed J1 by
FUNCT_1:def 5;
    card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
      .= card I + card J + 3 + 1;
    then card I + card J + 3 < card if=0(a,I,J) by XREAL_1:31;
    then n + (card J + 3) < card if=0(a,I,J) by A32,XXREAL_0:2;
    then
A36: IC Comput(ProgramPart( s3), s3,k) in dom if=0(a,I,J) by A33,AFINSQ_1:70;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,k))/.IC Comput(ProgramPart(s3),s3,k)
 = Comput(ProgramPart(s3),s3,k).IC Comput(ProgramPart(s3),s3,k) by AMI_1:150;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:144;
A37: CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,k))
 = s3.IC Comput(ProgramPart( s3), s3,k) by Y,AMI_1:54,TX3
      .= if=0(a,I,J).IC Comput(ProgramPart( s3), s3,k) by A36,Th26;
    Directed J1 c= if=0(a,I,J) by A21,SCMFSA6A:55;
    then
    if=0(a,I,J).IC Comput(ProgramPart( s3), s3,k) = (Directed J1).IC Comput(
ProgramPart( s3), s3,
    k) by A34,GRFUNC_1:8;
    hence contradiction by A26,A35,A37,AMI_1:def 12;
  end;
  then
A38: LifeSpan(ProgramPart(s3),s3) = pseudo-LifeSpan(s00,I0)
+ 1 by A24,A25,AMI_1:def 46,TX3;
  s +* Initialized I1 = Initialize s +* (I1 +* Start-At( 0,SCM+FSA)) by
SCMFSA8A:13;
  then
A39: s +* Initialized I1 = s1 by Th15;
A40: I0 ';' Stop SCM+FSA = I1 by SCMFSA8A:41;
  Directed I0 = I0 by SCMFSA6A:63;
  then
A41: DataPart Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s
,I0)) = DataPart
Comput(ProgramPart( s1), s1,pseudo-LifeSpan(s,I0)) by A8,A40,
Th58;
  I1 is_halting_on s by A8,Th58;
  then
A42: ProgramPart s1 halts_on s1 by SCMFSA7B:def 8;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
  thus DataPart IExec(if=0(a,I,J),ss) = DataPart IExec(if=0(a,I,J),s) by Th17
    .= DataPart(Result(ProgramPart(s +* Initialized if=0(a,I,J)),s +*
Initialized if=0(a,I,J)) +* s | A) by
SCMFSA6B:def 1
    .= DataPart Result(ProgramPart(s3),s3) by A16,Th35
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s3),s3)) by
A25,AMI_1:122
    .= DataPart Comput(ProgramPart( s3), s4,pseudo-LifeSpan(
s00,I0)) by A38,
AMI_1:51
    .= DataPart Comput(ProgramPart( s00), s00,pseudo-LifeSpan(
s00,I0)) by A20
,A10,A23,A7,A13,T,Th51
    .= DataPart Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) by A8
,A9,A41,Th50
    .= DataPart Result(ProgramPart(s1),s1) by A42,AMI_1:122
    .= DataPart(Result(ProgramPart(s +* Initialized I1),s +* Initialized I1) +*
s | A) by A39,Th35
    .= DataPart IExec(I1,s) by SCMFSA6B:def 1
    .= DataPart IExec(I1,ss) by Th17;
end;

theorem Th68:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & Directed I is_pseudo-closed_on s
holds if>0(a,I,J) is_halting_on s & if>0(a,I,J) is_closed_on s & LifeSpan(
ProgramPart(s +*
  (if>0(a,I,J) +* Start-At( 0,SCM+FSA))),s +*
  (if>0(a,I,J) +* Start-At( 0,SCM+FSA))) = LifeSpan(ProgramPart(s +* (I ';'
  Stop SCM+FSA +*
  Start-At( 0,SCM+FSA))),s +* (I ';'
  Stop SCM+FSA +*
  Start-At( 0,SCM+FSA))) + 1
proof
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I0 = Directed I;
  set I1 = I ';' Stop SCM+FSA;
  set s00 = s +* (I0 +* Start-At( 0,SCM+FSA));
  set s3 = s +* (if>0(a,I,J) +* Start-At( 0,SCM+FSA));
  set s4 = Comput(ProgramPart( s3), s3,1);
  set i = a >0_goto  (card J + 3);
A1: I0 +* Start-At( 0,SCM+FSA) c= s00 by FUNCT_4:26;
  card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if>0(a,I,J) by NAT_1:13;
  then
A2:  (card I + card J + 3) in dom if>0(a,I,J) by AFINSQ_1:70;
  IC SCM+FSA in dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
  then
A3: IC s3 = (if>0(a,I,J) +* Start-At( 0,SCM+FSA)).IC SCM+FSA
by FUNCT_4:14
    .=  0 by SF_MASTR:66;
A4:  0 in dom if>0(a,I,J) by Th54;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA))
  by GRFUNC_1:8;
  then
A5: s3. 0 = (if>0(a,I,J) +* Start-At( 0,SCM+FSA)). 0
by A4,FUNCT_4:14
    .= if>0(a,I,J). 0 by A4,SCMFSA6B:7
    .= i by Th55;
A6: card (i ';' J ';' Goto  (card I + 1)) = card (Macro i ';' J) +
  card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by SCMFSA7B:6
    .= card J + (2 + 1);
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
A7: Comput(ProgramPart( s3), s3,0+1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A3,A5,Y;
A8: if>0(a,I,J) c= if>0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  if>0(a,I,J) +* Start-At( 0,SCM+FSA) c= s3 by FUNCT_4:26;
  then
A9: if>0(a,I,J) c= s3 by A8,XBOOLE_1:1;
A10: if>0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
A11: if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  then if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
;
  then ProgramPart Relocated(I1,card J + 3) c= if>0(a,I,J) by A6,FUNCT_4:26;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A9,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:99;
  then
A12: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
  ProgramPart Relocated(I0,card J + 3) c= ProgramPart Relocated(I1,card J
  + 3) by Th12,SCMFSA6A:55;
  then
A13: ProgramPart Relocated(I0,card J + 3) c= s4 by A12,XBOOLE_1:1;
A14: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A15: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A14,SCMFSA6A:38
      .= s4.f by A7,SCMFSA_2:97;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A14,SCMFSA6A:38
      .= s4.a by A7,SCMFSA_2:97;
  end;
  then
A16: DataPart s00 = DataPart s4 by A15,SCMFSA6A:38;
  not a in dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  then
A17: s3.a = s.a by FUNCT_4:12;
  assume
  s.a > 0;
  then
A18: IC Comput(ProgramPart(s3),s3,1) =  (card J + 3) by A7,A17,SCMFSA_2:97;
  assume
A19: I0 is_pseudo-closed_on s;
  then
A20: pseudo-LifeSpan(s,I0) = LifeSpan(ProgramPart(s +* (I1 +*
Start-At( 0,SCM+FSA))),s +* (I1 +*
Start-At( 0,SCM+FSA))) by Th58;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A21: I0 is_pseudo-closed_on s00 by A19,Th52;
Y:  (ProgramPart Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,I0) + 1))/.
IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1)
 = Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1)
.
 IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1
) by AMI_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
TX: ProgramPart s3 =
 ProgramPart Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,I0) +
1)
by AMI_1:144;
A22: IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0)
+ 1) = IC Comput(
ProgramPart( s3), s4,
  pseudo-LifeSpan(s00,I0)) by AMI_1:51
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s00
,I0)) + (card J + 3)
by A1,A21,A13,A18,A16,Th51,T
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s,I0)
) + (card J + 3)
by A19,Th50
    .=  card ProgramPart I0 + (card J + 3) by A19,SCMFSA8A:def 5
    .=  card I0 + (card J + 3) by AMI_1:105
    .=  (card I + (card J + 3)) by SCMFSA8A:34
    .=  (card I + card J + 3);
  then
A23: CurInstr(ProgramPart s3,
    Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1
)) = s3. (card
  I + card J + 3) by Y,TX,AMI_1:54
    .= if>0(a,I,J). (card I + card J + 3) by A10,A2,GRFUNC_1:8
    .= halt SCM+FSA by Th62;
  then
A24: ProgramPart s3 halts_on s3 by TX,AMI_1:146;
  hence if>0(a,I,J) is_halting_on s by SCMFSA7B:def 8;
  now
    let k be Element of NAT;
    per cases;
    suppose
      k = 0;
      then Comput(ProgramPart( s3), s3,k) = s3 by AMI_1:13;
      then IC Comput(ProgramPart( s3), s3,k) =  0 by Th31;
      hence IC Comput(ProgramPart( s3), s3,k) in dom if>0(a,I,J) by Th54;
    end;
    suppose
A25:  0 < k & k < pseudo-LifeSpan(s00,I0) + 1;
      card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
        .= card I + card J + 3 + 1;
      then
A26:  card I + card J + 3 < card if>0(a,I,J) by XREAL_1:31;
      0 + 1 <= k by A25,INT_1:20;
      then consider k1 being Nat such that
A27:  1 + k1 = k by NAT_1:10;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider n = IC Comput(ProgramPart( s00), s00,k1) as Element of NAT;
A28:  k1 < pseudo-LifeSpan(s00,I0) by A25,A27,XREAL_1:8;
      then k1 < pseudo-LifeSpan(s,I0) by A19,Th50;
      then  n in dom I0 by A19,SCMFSA8A:31;
      then n < card I0 by AFINSQ_1:70;
      then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
      then n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
      then
A29:  n + (card J + 3) < card if>0(a,I,J) by A26,XXREAL_0:2;
S: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
      IC Comput(ProgramPart( s3), s3,k) = IC Comput(ProgramPart( s3), s4,k1)
by A27,AMI_1:51
        .= IC Comput(ProgramPart( s00), s00,k1) + (card J + 3) by A1,A21,A13
,A18,A16,A28,T,Th51;
      hence IC Comput(ProgramPart( s3), s3,k) in dom if>0(a,I,J) by A29,
AFINSQ_1:70;
    end;
    suppose
      0 < k & pseudo-LifeSpan(s00,I0) + 1 <= k;
      hence IC Comput(ProgramPart( s3), s3,k) in dom if>0(a,I,J) by A2,A22,A23,
AMI_1:52;
    end;
  end;
  hence if>0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
  now
    set J1 = a >0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
    ';' I;
    let k be Element of NAT;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:144;
    assume
A30: CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,k)) = halt SCM+FSA;
    assume
    not pseudo-LifeSpan(s00,I0) + 1 <= k;
    then
A31: k <= pseudo-LifeSpan(s00,I0) by NAT_1:13;
A32:  0 in dom if>0(a,I,J) by Th54;
A33: InsCode (a >0_goto  (card J + 3)) = 8 by SCMFSA_2:49;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
    CurInstr(ProgramPart Comput(ProgramPart(s3),s3,0),Comput(ProgramPart(s3),s3
,0))
     = CurInstr(ProgramPart s3,s3) by u
      .= s3. 0 by Th31,Y
      .= if>0(a,I,J). 0 by A32,Th26
      .= a >0_goto  (card J + 3) by Th55;
    then k <> 0 by A30,A33,SCMFSA_2:124,TX3;
    then consider k1 being Nat such that
A34: k1 + 1 = k by NAT_1:6;
    reconsider k1 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(ProgramPart( s00), s00,k1) as Element of NAT;
    k1 < k by A34,XREAL_1:31;
    then
A35: k1 < pseudo-LifeSpan(s00,I0) by A31,XXREAL_0:2;
    then k1 < pseudo-LifeSpan(s,I0) by A19,Th50;
    then  n in dom I0 by A19,SCMFSA8A:31;
    then n < card I0 by AFINSQ_1:70;
    then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
    then
A36: n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
S: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
A37: IC Comput(ProgramPart( s3), s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A34,AMI_1:51
      .= IC Comput(ProgramPart( s00), s00,k1) + (card J + 3) by A1,A21,A13,A18
,A16,A35,Th51,T;
    card J1 = card (Macro (a >0_goto  (card J + 3)) ';' J ';' Goto
     (card I + 1)) + card I by SCMFSA6A:61
      .= card (Macro (a >0_goto  (card J + 3)) ';' J) + card Goto
     (card I + 1) + card I by SCMFSA6A:61
      .= card (Macro (a >0_goto  (card J + 3)) ';' J) + 1 + card I by
SCMFSA8A:29
      .= card Macro (a >0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
      .= 2 + card J + 1 + card I by SCMFSA7B:6
      .= card I + card J + 3;
    then IC Comput(ProgramPart( s3), s3,k) in dom J1 by A37,A36,AFINSQ_1:70;
    then
A38: IC Comput(ProgramPart( s3), s3,k) in dom Directed J1 by FUNCT_4:105;
    then
A39: (Directed J1).IC Comput(ProgramPart( s3), s3,k) in rng Directed J1 by
FUNCT_1:def 5;
    card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
      .= card I + card J + 3 + 1;
    then card I + card J + 3 < card if>0(a,I,J) by XREAL_1:31;
    then n + (card J + 3) < card if>0(a,I,J) by A36,XXREAL_0:2;
    then
A40: IC Comput(ProgramPart( s3), s3,k) in dom if>0(a,I,J) by A37,AFINSQ_1:70;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,k))/.IC Comput(ProgramPart(s3),s3,k)
 = Comput(ProgramPart(s3),s3,k).IC Comput(ProgramPart(s3),s3,k) by AMI_1:150;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:144;
A41: CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,k))
 = s3.IC Comput(ProgramPart( s3), s3,k) by Y,AMI_1:54,TX3
      .= if>0(a,I,J).IC Comput(ProgramPart( s3), s3,k) by A40,Th26;
    Directed J1 c= if>0(a,I,J) by A11,SCMFSA6A:55;
    then
    if>0(a,I,J).IC Comput(ProgramPart( s3), s3,k) = (Directed J1).IC Comput(
ProgramPart( s3), s3,
    k) by A38,GRFUNC_1:8;
    hence contradiction by A30,A39,A41,AMI_1:def 12,TX3;
  end;
  then LifeSpan(ProgramPart(s3),s3) = pseudo-LifeSpan(s00,
I0) + 1 by A23,A24,TX,AMI_1:def 46,T;
  hence thesis by A19,A20,Th50;
end;

theorem Th69:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.intloc 0 = 1 & s.a > 0 & Directed I
  is_pseudo-closed_on s holds DataPart IExec(if>0(a,I,J),s) = DataPart IExec(I
  ';' Stop SCM+FSA,s)
proof
  let ss be State of SCM+FSA;
  set A = NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I0 = Directed I;
  set s = Initialize ss;
  set I1 = I ';' Stop SCM+FSA;
  set s00 = s +* (I0 +* Start-At( 0,SCM+FSA));
  set s3 = s +* (if>0(a,I,J) +* Start-At( 0,SCM+FSA));
  set s4 = Comput(ProgramPart( s3), s3,1);
  set i = a >0_goto  (card J + 3);
  assume
A1: ss.intloc 0 = 1;
  set s1 = s +* (I1 +* Start-At( 0,SCM+FSA));
  assume
  ss.a > 0;
  then
A2: s.a > 0 by SCMFSA6C:3;
  IC SCM+FSA in dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
  then
A3: IC s3 = (if>0(a,I,J) +* Start-At( 0,SCM+FSA)).IC SCM+FSA
by FUNCT_4:14
    .=  0 by SF_MASTR:66;
A4:  0 in dom if>0(a,I,J) by Th54;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA))
  by GRFUNC_1:8;
  then
A5: s3. 0 = (if>0(a,I,J) +* Start-At( 0,SCM+FSA)). 0
by A4,FUNCT_4:14
    .= if>0(a,I,J). 0 by A4,SCMFSA6B:7
    .= i by Th55;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
A6: Comput(ProgramPart( s3), s3,0+1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A3,A5,Y;
  not a in dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  then s3.a = s.a by FUNCT_4:12;
  then
A7: IC Comput(ProgramPart(s3),s3,1) =  (card J + 3) by A2,A6,SCMFSA_2:97;
  assume
  I0 is_pseudo-closed_on ss;
  then
A8: I0 is_pseudo-closed_on s by A1,Th53;
  then
A9: LifeSpan(ProgramPart(s1),s1) = pseudo-LifeSpan(s,I0) by
Th58;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A10: I0 is_pseudo-closed_on s00 by A8,Th52;
A11: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A12: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A11,SCMFSA6A:38
      .= s4.f by A6,SCMFSA_2:97;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A11,SCMFSA6A:38
      .= s4.a by A6,SCMFSA_2:97;
  end;
  then
A13: DataPart s00 = DataPart s4 by A12,SCMFSA6A:38;
  card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if>0(a,I,J) by NAT_1:13;
  then
A14:  (card I + card J + 3) in dom if>0(a,I,J) by AFINSQ_1:70;
A15: card (i ';' J ';' Goto  (card I + 1)) = card (Macro i ';' J) +
  card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by SCMFSA7B:6
    .= card J + (2 + 1);
  s +* Initialized if>0(a,I,J) = Initialize s +* (if>0(a,I,J) +*
  Start-At( 0,SCM+FSA)) by SCMFSA8A:13;
  then
A16: s +* Initialized if>0(a,I,J) = s3 by Th15;
A17: if>0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
A18: if>0(a,I,J) c= if>0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  if>0(a,I,J) +* Start-At( 0,SCM+FSA) c= s3 by FUNCT_4:26;
  then
A19: if>0(a,I,J) c= s3 by A18,XBOOLE_1:1;
A20: I0 +* Start-At( 0,SCM+FSA) c= s00 by FUNCT_4:26;
A21: if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  then if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
;
  then ProgramPart Relocated(I1,card J + 3) c= if>0(a,I,J) by A15,FUNCT_4:26;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A19,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:99;
  then
A22: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
  ProgramPart Relocated(I0,card J + 3) c= ProgramPart Relocated(I1,card J
  + 3) by Th12,SCMFSA6A:55;
  then
A23: ProgramPart Relocated(I0,card J + 3) c= s4 by A22,XBOOLE_1:1;
Y:  (ProgramPart Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,I0) + 1))/.
IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1)
 = Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1)
.
 IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1
) by AMI_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
TX3: ProgramPart s3 = ProgramPart
Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,I0) +
1)
by AMI_1:144;
  IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) +
1) = IC Comput(
ProgramPart( s3), s4,
  pseudo-LifeSpan(s00,I0)) by AMI_1:51
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s00
,I0)) + (card J + 3)
by A20,A10,A23,A7,A13,Th51,T
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s,I0)
) + (card J + 3)
by A8,Th50
    .=  card ProgramPart I0 + (card J + 3) by A8,SCMFSA8A:def 5
    .=  card I0 + (card J + 3) by AMI_1:105
    .=  (card I + (card J + 3)) by SCMFSA8A:34
    .=  (card I + card J + 3);
  then
A24: CurInstr(ProgramPart s3,
   Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,I0) + 1))
     = s3. (card I + card J + 3) by Y,AMI_1:54,TX3
    .= if>0(a,I,J). (card I + card J + 3) by A17,A14,GRFUNC_1:8
    .= halt SCM+FSA by Th62;
  then
A25: ProgramPart s3 halts_on s3 by AMI_1:146;
  now
    set J1 = a >0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
    ';' I;
    let k be Element of NAT;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:144;
    assume
A26: CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,k)) = halt SCM+FSA;
    assume
    not pseudo-LifeSpan(s00,I0) + 1 <= k;
    then
A27: k <= pseudo-LifeSpan(s00,I0) by NAT_1:13;
A28:  0 in dom if>0(a,I,J) by Th54;
A29: InsCode (a >0_goto  (card J + 3)) = 8 by SCMFSA_2:49;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
TX0: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,0)
by AMI_1:144;
    CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3
,0))
     = CurInstr(ProgramPart s3,s3) by u
      .= s3. 0 by Th31,Y
      .= if>0(a,I,J). 0 by A28,Th26
      .= a >0_goto  (card J + 3) by Th55;
    then k <> 0 by A26,A29,SCMFSA_2:124;
    then consider k1 being Nat such that
A30: k1 + 1 = k by NAT_1:6;
    reconsider k1 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(ProgramPart( s00), s00,k1) as Element of NAT;
    k1 < k by A30,XREAL_1:31;
    then
A31: k1 < pseudo-LifeSpan(s00,I0) by A27,XXREAL_0:2;
    then k1 < pseudo-LifeSpan(s,I0) by A8,Th50;
    then  n in dom I0 by A8,SCMFSA8A:31;
    then n < card I0 by AFINSQ_1:70;
    then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
    then
A32: n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
A33: IC Comput(ProgramPart( s3), s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A30,AMI_1:51
      .= IC Comput(ProgramPart( s00), s00,k1) + (card J + 3) by A20,A10,A23,A7
,A13,A31,Th51,T;
    card J1 = card (Macro (a >0_goto  (card J + 3)) ';' J ';' Goto
     (card I + 1)) + card I by SCMFSA6A:61
      .= card (Macro (a >0_goto  (card J + 3)) ';' J) + card Goto
     (card I + 1) + card I by SCMFSA6A:61
      .= card (Macro (a >0_goto  (card J + 3)) ';' J) + 1 + card I by
SCMFSA8A:29
      .= card Macro (a >0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
      .= 2 + card J + 1 + card I by SCMFSA7B:6
      .= card I + card J + 3;
    then IC Comput(ProgramPart( s3), s3,k) in dom J1 by A33,A32,AFINSQ_1:70;
    then
A34: IC Comput(ProgramPart( s3), s3,k) in dom Directed J1 by FUNCT_4:105;
    then
A35: (Directed J1).IC Comput(ProgramPart( s3), s3,k) in rng Directed J1 by
FUNCT_1:def 5;
    card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
      .= card I + card J + 3 + 1;
    then card I + card J + 3 < card if>0(a,I,J) by XREAL_1:31;
    then n + (card J + 3) < card if>0(a,I,J) by A32,XXREAL_0:2;
    then
A36: IC Comput(ProgramPart( s3), s3,k) in dom if>0(a,I,J) by A33,AFINSQ_1:70;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,k))/.IC Comput(ProgramPart(s3),s3,k)
 = Comput(ProgramPart(s3),s3,k).IC Comput(ProgramPart(s3),s3,k) by AMI_1:150;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:144;
A37: CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,k))
 = s3.IC Comput(ProgramPart( s3), s3,k) by Y,AMI_1:54,TX3
      .= if>0(a,I,J).IC Comput(ProgramPart( s3), s3,k) by A36,Th26;
    Directed J1 c= if>0(a,I,J) by A21,SCMFSA6A:55;
    then
    if>0(a,I,J).IC Comput(ProgramPart( s3), s3,k) = (Directed J1).IC Comput(
ProgramPart( s3), s3,
    k) by A34,GRFUNC_1:8;
    hence contradiction by A26,A35,A37,AMI_1:def 12,TX0,TX3;
  end;
  then
A38: LifeSpan(ProgramPart(s3),s3) = pseudo-LifeSpan(s00,I0)
+ 1 by A24,A25,AMI_1:def 46;
  s +* Initialized I1 = Initialize s +* (I1 +* Start-At( 0,SCM+FSA)) by
SCMFSA8A:13;
  then
A39: s +* Initialized I1 = s1 by Th15;
A40: I0 ';' Stop SCM+FSA = I1 by SCMFSA8A:41;
  Directed I0 = I0 by SCMFSA6A:63;
  then
A41: DataPart Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s
,I0)) = DataPart
Comput(ProgramPart( s1), s1,pseudo-LifeSpan(s,I0)) by A8,A40,
Th58;
  I1 is_halting_on s by A8,Th58;
  then
A42: ProgramPart s1 halts_on s1 by SCMFSA7B:def 8;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
  thus DataPart IExec(if>0(a,I,J),ss) = DataPart IExec(if>0(a,I,J),s) by Th17
    .= DataPart(Result(ProgramPart(s +* Initialized if>0(a,I,J)),s +*
Initialized if>0(a,I,J)) +* s | A) by
SCMFSA6B:def 1
    .= DataPart Result(ProgramPart(s3),s3) by A16,Th35
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s3),s3)) by
A25,AMI_1:122
    .= DataPart Comput(ProgramPart( s3), s4,pseudo-LifeSpan(
s00,I0)) by A38,
AMI_1:51
    .= DataPart Comput(ProgramPart( s00), s00,pseudo-LifeSpan(
s00,I0)) by A20
,A10,A23,A7,A13,T,Th51
    .= DataPart Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) by A8
,A9,A41,Th50
    .= DataPart Result(ProgramPart(s1),s1) by A42,AMI_1:122
    .= DataPart(Result(ProgramPart(s +* Initialized I1),s +* Initialized I1) +*
s | A) by A39,Th35
    .= DataPart IExec(I1,s) by SCMFSA6B:def 1
    .= DataPart IExec(I1,ss) by Th17;
end;

theorem Th70:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a <> 0 & Directed J is_pseudo-closed_on s
holds if=0(a,I,J) is_halting_on s & if=0(a,I,J) is_closed_on s & LifeSpan(
ProgramPart(s +*
  (if=0(a,I,J) +* Start-At( 0,SCM+FSA))),s +*
  (if=0(a,I,J) +* Start-At( 0,SCM+FSA))) = LifeSpan(ProgramPart(s +* (J ';'
  Stop SCM+FSA +*
  Start-At( 0,SCM+FSA))),s +* (J ';'
  Stop SCM+FSA +*
  Start-At( 0,SCM+FSA))) + 3
proof
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set J0 = Directed J;
  set s0 = Initialize s;
  set J9 = J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA));
  set s00 = s +* (J0 +* Start-At( 0,SCM+FSA));
  set s3 = s +* (if=0(a,I,J) +* Start-At( 0,SCM+FSA));
  set s4 = Comput(ProgramPart( s3), s3,1);
  set s5 = Comput(ProgramPart( s3), s3,2);
  set i = a =0_goto  (card J + 3);
A1: J0 +* Start-At( 0,SCM+FSA) c= s00 by FUNCT_4:26;
  if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  then if=0(a,I,J) = Macro i ';' J ';' Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA) by SCMFSA6A:67;
  then if=0(a,I,J) = Macro i ';' J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA)) by SCMFSA6A:67;
  then
A2: if=0(a,I,J) = Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA))) by SCMFSA6A:67;
  card Macro i = 2 by SCMFSA7B:6;
  then
A3: ProgramPart Relocated(J9,2) c= if=0(a,I,J) by A2,FUNCT_4:26;
A4:  0 in dom if=0(a,I,J) by Th54;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA))
  by GRFUNC_1:8;
  then
A5: s3. 0 = (if=0(a,I,J) +* Start-At( 0,SCM+FSA)). 0
by A4,FUNCT_4:14
    .= if=0(a,I,J). 0 by A4,SCMFSA6B:7
    .= i by Th55;
  card if=0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:14
    .= card J + 2 + (card I + 2);
  then
A6: card J + 2 + 0 < card if=0(a,I,J) by XREAL_1:10;
  then
A7:  (card J + 2) in dom if=0(a,I,J) by AFINSQ_1:70;
  IC SCM+FSA in dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
  then
A8: IC s3 = (if=0(a,I,J) +* Start-At( 0,SCM+FSA)).IC SCM+FSA
by FUNCT_4:14
    .=  0 by SF_MASTR:66;
  set ss = Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,
J0) + 2);
A9: if=0(a,I,J) c= if=0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
A10: if=0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  if=0(a,I,J) +* Start-At( 0,SCM+FSA) c= s3 by FUNCT_4:26;
  then if=0(a,I,J) c= s3 by A9,XBOOLE_1:1;
  then ProgramPart Relocated(J9,2) c= s3 by A3,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(J9,2) c= s5 by AMI_1:99;
  then
A11: ProgramPart Relocated(J9,2) c= s5 by AMI_1:105;
  ProgramPart Relocated(J0,2) c= ProgramPart Relocated(J9,2) by Th12,
SCMFSA6A:55;
  then
A12: ProgramPart Relocated(J0,2) c= s5 by A11,XBOOLE_1:1;
  card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if=0(a,I,J) by NAT_1:13;
  then
A13:  (card I + card J + 3) in dom if=0(a,I,J) by AFINSQ_1:70;
  assume
  s.a <> 0;
  then
A14: s0.a <> 0 by SCMFSA6C:3;
A15:  1 in dom if=0(a,I,J) by Th54;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A16: dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
A17: if=0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  assume
A18: J0 is_pseudo-closed_on s;
  then
A19: pseudo-LifeSpan(s,J0) = LifeSpan(ProgramPart(s +* (J ';'
Stop SCM+FSA +*
Start-At( 0,SCM+FSA))),s +* (J ';' Stop SCM+FSA +*
Start-At( 0,SCM+FSA))) by Th58;
A20: s4. 1 = s3. 1 by AMI_1:54
    .= (if=0(a,I,J) +* Start-At( 0,SCM+FSA)). 1
    by A15,A16,FUNCT_4:14
    .= if=0(a,I,J). 1 by A15,SCMFSA6B:7
    .= goto  2 by Th55;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A21: J0 is_pseudo-closed_on s00 by A18,Th52;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
A22: Comput(ProgramPart( s3), s3,0+1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A8,A5,Y;
  s3.a = s.a by Th28
    .= s0.a by SCMFSA6C:3;
  then
A23: IC s4 = succ IC s3 by A14,A22,SCMFSA_2:96
    .=  (0 + 1) by A8;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
A24: Comput(ProgramPart( s3), s3,1+1) = Following(ProgramPart s3,s4) by
AMI_1:14
    .= Exec(goto  2,s4) by A23,A20,Y,T;
  then
A25: IC s5 =  2 by SCMFSA_2:95;
A26: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A27: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A26,SCMFSA6A:38
      .= s4.f by A22,SCMFSA_2:96
      .= s5.f by A24,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A26,SCMFSA6A:38
      .= s4.a by A22,SCMFSA_2:96
      .= s5.a by A24,SCMFSA_2:95;
  end;
  then
A28: DataPart s00 = DataPart s5 by A27,SCMFSA6A:38;
Y:  (ProgramPart ss)/.IC ss
 = ss.IC ss by AMI_1:150;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:144;
A29: IC ss = IC Comput(ProgramPart( s3), s5,pseudo-LifeSpan(
s00,J0)) by
AMI_1:51
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s00
,J0)) + 2 by A1,A21
,A12,A25,A28,T,Th51
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s,J0)
) + 2 by A18,Th50
    .=  card ProgramPart J0 + 2 by A18,SCMFSA8A:def 5
    .=  card J0 + 2 by AMI_1:105
    .=  (card J + 2) by SCMFSA8A:34;
  then
A30: CurInstr(ProgramPart ss,ss) = s3. (card J + 2) by Y,AMI_1:54
    .= if=0(a,I,J). (card J + 2) by A10,A7,GRFUNC_1:8
    .= goto  (card I + card J + 3) by Th63;
Y:  (ProgramPart Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,J0) + 2 + 1))
/.
IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2
+ 1)
 = Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2
+ 1).
 IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2
+ 1) by AMI_1:150;
T: ProgramPart s3 = ProgramPart ss
by AMI_1:144;
TX: ProgramPart s3 =
 ProgramPart Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,J0) +
2 + 1)
by AMI_1:144;
A31: IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0)
+ 2 + 1) =
IC Following(ProgramPart s3,ss)
  by AMI_1:14
    .=  (card I + card J + 3) by A30,T,SCMFSA_2:95;
  then
A32: CurInstr(ProgramPart s3,
      Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) +
2 + 1)) = s3. (
  card I + card J + 3) by Y,TX,AMI_1:54
    .= if=0(a,I,J). (card I + card J + 3) by A17,A13,GRFUNC_1:8
    .= halt SCM+FSA by Th61;
  then
A33: ProgramPart s3 halts_on s3 by TX,AMI_1:146;
  hence if=0(a,I,J) is_halting_on s by SCMFSA7B:def 8;
  now
    let k be Element of NAT;
    per cases;
    suppose
      k = 0;
      then Comput(ProgramPart( s3), s3,k) = s3 by AMI_1:13;
      then IC Comput(ProgramPart( s3), s3,k) =  0 by Th31;
      hence IC Comput(ProgramPart( s3), s3,k) in dom if=0(a,I,J) by Th54;
    end;
    suppose
      0 < k & k = 1;
      hence IC Comput(ProgramPart( s3), s3,k) in dom if=0(a,I,J) by A23,Th54;
    end;
    suppose
A34:  0 < k & k <> 1 & k < pseudo-LifeSpan(s00,J0) + 2;
      then 0 + 1 <= k by INT_1:20;
      then 1 < k by A34,XXREAL_0:1;
      then 0 + (1 + 1) <= k by INT_1:20;
      then consider k2 being Nat such that
A35:  2 + k2 = k by NAT_1:10;
      card if=0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:14
        .= card J + 2 + (card I + 2);
      then
A36:  card J + 2 <= card if=0(a,I,J) by NAT_1:12;
      reconsider k2 as Element of NAT by ORDINAL1:def 13;
      reconsider n = IC Comput(ProgramPart( s00), s00,k2) as Element of NAT;
A37:  k2 < pseudo-LifeSpan(s00,J0) by A34,A35,XREAL_1:8;
      then k2 < pseudo-LifeSpan(s,J0) by A18,Th50;
      then  n in dom J0 by A18,SCMFSA8A:31;
      then n < card J0 by AFINSQ_1:70;
      then n + 2 < card J0 + 2 by XREAL_1:8;
      then n + 2 < card J + 2 by SCMFSA8A:34;
      then
A38:  n + 2 < card if=0(a,I,J) by A36,XXREAL_0:2;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:144;
      IC Comput(ProgramPart( s3), s3,k) = IC Comput(ProgramPart( s3), s5,k2)
by A35,AMI_1:51
        .= IC Comput(ProgramPart( s00), s00,k2) + 2 by A1,A21,A12,A25,A28,A37
,Th51,T;
      hence IC Comput(ProgramPart( s3), s3,k) in dom if=0(a,I,J) by A38,
AFINSQ_1:70;
    end;
    suppose
A39:  0 < k & k <> 1 & pseudo-LifeSpan(s00,J0) + 2 <= k;
      hereby
        per cases by A39,XXREAL_0:1;
        suppose
          pseudo-LifeSpan(s00,J0) + 2 = k;
          hence IC Comput(ProgramPart( s3), s3,k) in dom if=0(a,I,J) by A6,A29,
AFINSQ_1:70;
        end;
        suppose
          pseudo-LifeSpan(s00,J0) + 2 < k;
          then pseudo-LifeSpan(s00,J0) + 2 + 1 <= k by
INT_1:20;
          hence IC Comput(ProgramPart( s3), s3,k) in dom if=0(a,I,J) by A13,A31
,A32,AMI_1:52;
        end;
      end;
    end;
  end;
  hence if=0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
A40: CurInstr(ProgramPart s3,s3) = i by A8,A5,Y;
  now
A41: 0 + 2 < card I + card J + 3 by XREAL_1:10;
    then
A42:  2 in dom if=0(a,I,J) by Th56;
A43: if=0(a,I,J). 2 <> halt SCM+FSA by A41,Th56;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,2))/.IC Comput(ProgramPart(s3),s3,2)
 = Comput(ProgramPart(s3),s3,2).IC Comput(ProgramPart(s3),s3,2) by AMI_1:150;
TX2: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,2)
by AMI_1:144;
A44: CurInstr(ProgramPart s3,Comput(ProgramPart(s3),
s3,2)) = s3. 2
 by A25,Y,AMI_1:54,TX2
      .= if=0(a,I,J). 2 by A42,Th26;
    let k be Element of NAT;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,k))/.IC Comput(ProgramPart(s3),s3,k)
 = Comput(ProgramPart(s3),s3,k).IC Comput(ProgramPart(s3),s3,k) by AMI_1:150;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:144;
TX0: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,0)
by AMI_1:144;
    assume
A45: CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,k)) = halt SCM+FSA;
    CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3
,0)) = i
     by A40,u;
    then
A46: k <> 0 by A45,SCMFSA_2:48,124;
xx:  k <> 1 by A23,A20,A45,Y,SCMFSA_2:47,124,TX0,TX3;
    k <> 2 by A45,A43,A44,TX0,TX2;
    then 2 < k by A46,xx,NAT_1:27;
    then consider k2 being Nat such that
A47: 2 + k2 = k by NAT_1:10;
    reconsider k2 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(ProgramPart( s00), s00,k2) as Element of NAT;
    assume
    not pseudo-LifeSpan(s00,J0) + (1 + 2) <= k;
    then k < pseudo-LifeSpan(s00,J0) + 1 + 2;
    then k2 < pseudo-LifeSpan(s00,J0) + 1 by A47,XREAL_1:8;
    then
A48: k2 <= pseudo-LifeSpan(s00,J0) by NAT_1:13;
    then
A49: k2 <= pseudo-LifeSpan(s,J0) by A18,Th50;
A50: now
      per cases by A49,XXREAL_0:1;
      suppose
A51:    k2 = pseudo-LifeSpan(s,J0);
        card I + card J + (2 + 1) = card J + 2 + 1 + card I;
        then
A52:    card J + 2 + 1 <= card I + card J + 3 by NAT_1:11;
        IC Comput(ProgramPart( s00), s00,k2) =  card ProgramPart J0 by A18,A51,
SCMFSA8A:def 5
          .=  card J0 by AMI_1:105;
        then n = card J by SCMFSA8A:34;
        hence n + 2 < card I + card J + 3 by A52,NAT_1:13;
      end;
      suppose
        k2 < pseudo-LifeSpan(s,J0);
        then  n in dom J0 by A18,SCMFSA8A:31;
        then n < card J0 by AFINSQ_1:70;
        then n + 2 < card J0 + 2 by XREAL_1:8;
        then
A53:    n + 2 < card J + 2 by SCMFSA8A:34;
        card I + card J + (1 + 2) = card J + 2 + (card I + 1);
        then card J + 2 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A53,XXREAL_0:2;
      end;
    end;
    then
A54:  (n + 2) in dom if=0(a,I,J) by Th56;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:144;
A55: IC Comput(ProgramPart( s3), s3,k) = IC Comput(ProgramPart( s3), s5,k2) by
A47,AMI_1:51
      .=  (n + 2) by A1,A21,A12,A25,A28,A48,Th51,T;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,k))/.IC Comput(ProgramPart(s3),s3,k)
 = Comput(ProgramPart(s3),s3,k).IC Comput(ProgramPart(s3),s3,k) by AMI_1:150;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:144;
    CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,k))
     = s3.IC Comput(ProgramPart( s3), s3,k) by Y,AMI_1:54,TX3
      .= if=0(a,I,J).IC Comput(ProgramPart( s3), s3,k) by A55,A54,Th26;
    hence contradiction by A45,A55,A50,Th56;
  end;
  then LifeSpan(ProgramPart(s3),s3) = pseudo-LifeSpan(s00,
J0) + 3 by A32,A33,TX,AMI_1:def 46,TX;
  hence thesis by A18,A19,Th50;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
  read-write Int-Location st s.intloc 0 = 1 & s.a <> 0 & Directed J
  is_pseudo-closed_on s holds DataPart IExec(if=0(a,I,J),s) = DataPart IExec(J
  ';' Stop SCM+FSA,s)
proof
  let ss be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set J0 = Directed J;
  set s = Initialize ss;
  set s0 = Initialize s;
  set J9 = J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA));
  set s00 = s +* (J0 +* Start-At( 0,SCM+FSA));
  set s3 = s +* (if=0(a,I,J) +* Start-At( 0,SCM+FSA));
  set s4 = Comput(ProgramPart( s3), s3,1);
  set s5 = Comput(ProgramPart( s3), s3,2);
  set i = a =0_goto  (card J + 3);
  assume
A1: ss.intloc 0 = 1;
  set s1 = s +* (J ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA));
  assume
  ss.a <> 0;
  then s.a <> 0 by SCMFSA6C:3;
  then
A2: s0.a <> 0 by SCMFSA6C:3;
A3:  0 in dom if=0(a,I,J) by Th54;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA))
  by GRFUNC_1:8;
  then
A4: s3. 0 = (if=0(a,I,J) +* Start-At( 0,SCM+FSA)). 0
by A3,FUNCT_4:14
    .= if=0(a,I,J). 0 by A3,SCMFSA6B:7
    .= i by Th55;
  s +* Initialized if=0(a,I,J) = Initialize s +* (if=0(a,I,J) +*
  Start-At( 0,SCM+FSA)) by SCMFSA8A:13;
  then
A5: s +* Initialized if=0(a,I,J) = s3 by Th15;
A6: if=0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A7: dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
A8: J0 ';' Stop SCM+FSA = J ';' Stop SCM+FSA by SCMFSA8A:41;
  IC SCM+FSA in dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
  then
A9: IC s3 = (if=0(a,I,J) +* Start-At( 0,SCM+FSA)).IC SCM+FSA
by FUNCT_4:14
    .=  0 by SF_MASTR:66;
  if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  then if=0(a,I,J) = Macro i ';' J ';' Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA) by SCMFSA6A:67;
  then if=0(a,I,J) = Macro i ';' J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA)) by SCMFSA6A:67;
  then
A10: if=0(a,I,J) = Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA))) by SCMFSA6A:67;
  card Macro i = 2 by SCMFSA7B:6;
  then
A11: ProgramPart Relocated(J9,2) c= if=0(a,I,J) by A10,FUNCT_4:26;
A12: if=0(a,I,J) c= if=0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  if=0(a,I,J) +* Start-At( 0,SCM+FSA) c= s3 by FUNCT_4:26;
  then if=0(a,I,J) c= s3 by A12,XBOOLE_1:1;
  then ProgramPart Relocated(J9,2) c= s3 by A11,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(J9,2) c= s5 by AMI_1:99;
  then
A13: ProgramPart Relocated(J9,2) c= s5 by AMI_1:105;
  ProgramPart Relocated(J0,2) c= ProgramPart Relocated(J9,2) by Th12,
SCMFSA6A:55;
  then
A14: ProgramPart Relocated(J0,2) c= s5 by A13,XBOOLE_1:1;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
A15: Comput(ProgramPart( s3), s3,0+1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A9,A4,Y;
  assume
  J0 is_pseudo-closed_on ss;
  then
A16: J0 is_pseudo-closed_on s by A1,Th53;
  then J ';' Stop SCM+FSA is_halting_on s by Th58;
  then
A17: ProgramPart s1 halts_on s1 by SCMFSA7B:def 8;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A18: J0 is_pseudo-closed_on s00 by A16,Th52;
  s +* Initialized (J ';' Stop SCM+FSA) = Initialize s +* (J ';' Stop
  SCM+FSA +* Start-At( 0,SCM+FSA)) by SCMFSA8A:13;
  then
A19: s +* Initialized (J ';' Stop SCM+FSA) = s1 by Th15;
A20: Directed J0 = J0 by SCMFSA6A:63;
  card if=0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:14
    .= card J + 2 + (card I + 2);
  then card J + 2 + 0 < card if=0(a,I,J) by XREAL_1:10;
  then
A21:  (card J + 2) in dom if=0(a,I,J) by AFINSQ_1:70;
  card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if=0(a,I,J) by NAT_1:13;
  then
A22:  (card I + card J + 3) in dom if=0(a,I,J) by AFINSQ_1:70;
A23: if=0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  set s9 = Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,
J0) + 2);
A24: J0 +* Start-At( 0,SCM+FSA) c= s00 by FUNCT_4:26;
  LifeSpan(ProgramPart(s1),s1) = pseudo-LifeSpan(s,J0) by A16
,Th58;
  then
A25: DataPart Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s
,J0)) = DataPart
Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) by A16,A20,A8,Th58;
A26:  1 in dom if=0(a,I,J) by Th54;
  s3.a = s.a by Th28
    .= s0.a by SCMFSA6C:3;
  then
A27: IC s4 = succ IC s3 by A2,A15,SCMFSA_2:96
    .=  (0 + 1) by A9;
A28: s4. 1 = s3. 1 by AMI_1:54
    .= (if=0(a,I,J) +* Start-At( 0,SCM+FSA)). 1
    by A26,A7,FUNCT_4:14
    .= if=0(a,I,J). 1 by A26,SCMFSA6B:7
    .= goto  2 by Th55;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
A29: Comput(ProgramPart( s3), s3,1+1) = Following(ProgramPart s3,s4) by
AMI_1:14
    .= Exec(goto  2,s4) by A27,A28,Y,T;
  then
A30: IC s5 =  2 by SCMFSA_2:95;
A31: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A32: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A31,SCMFSA6A:38
      .= s4.f by A15,SCMFSA_2:96
      .= s5.f by A29,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A31,SCMFSA6A:38
      .= s4.a by A15,SCMFSA_2:96
      .= s5.a by A29,SCMFSA_2:95;
  end;
  then
A33: DataPart s00 = DataPart s5 by A32,SCMFSA6A:38;
Y:  (ProgramPart s9)/.IC s9
 = s9.IC s9 by AMI_1:150;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:144;
A34: IC s9 = IC Comput(ProgramPart( s3), s5,pseudo-LifeSpan(
s00,J0)) by
AMI_1:51
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s00
,J0)) + 2 by A24,A18
,A14,A30,A33,T,Th51
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s,J0)
) + 2 by A16,Th50
    .=  card ProgramPart J0 + 2 by A16,SCMFSA8A:def 5
    .=  card J0 + 2 by AMI_1:105
    .=  (card J + 2) by SCMFSA8A:34;
  then
A35: CurInstr(ProgramPart s9,s9) = s3. (card J + 2) by Y,AMI_1:54
    .= if=0(a,I,J). (card J + 2) by A23,A21,GRFUNC_1:8
    .= goto  (card I + card J + 3) by Th63;
Y:  (ProgramPart Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,J0) + 2 + 1))
/.
IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2
+ 1)
 = Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2
+ 1).
 IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2
+ 1) by AMI_1:150;
T: ProgramPart s3 = ProgramPart s9
by AMI_1:144;
TX3: ProgramPart s3 = ProgramPart
Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,J0) +
2 + 1)
by AMI_1:144;
  IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) +
2 + 1) =
  IC Following(ProgramPart s3,s9)
  by AMI_1:14
    .=  (card I + card J + 3) by A35,T,SCMFSA_2:95;
  then
A36: CurInstr(ProgramPart s3,
   Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2
+ 1)) = s3. (
  card I + card J + 3) by Y,AMI_1:54,TX3
    .= if=0(a,I,J). (card I + card J + 3) by A6,A22,GRFUNC_1:8
    .= halt SCM+FSA by Th61;
  then
A37: ProgramPart s3 halts_on s3 by AMI_1:146;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
A38: CurInstr(ProgramPart s3,s3) = i by A9,A4,Y;
  now
A39: 0 + 2 < card I + card J + 3 by XREAL_1:10;
    then
A40:  2 in dom if=0(a,I,J) by Th56;
A41: if=0(a,I,J). 2 <> halt SCM+FSA by A39,Th56;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,2))/.IC Comput(ProgramPart(s3),s3,2)
 = Comput(ProgramPart(s3),s3,2).IC Comput(ProgramPart(s3),s3,2) by AMI_1:150;
TX2: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,2)
by AMI_1:144;
A42: CurInstr(ProgramPart s3,Comput(ProgramPart(s3),
s3,2)) = s3. 2
 by A30,Y,AMI_1:54,TX2
      .= if=0(a,I,J). 2 by A40,Th26;
    let k be Element of NAT;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:144;
    assume
A43: CurInstr(ProgramPart s3,Comput(ProgramPart(s3),
s3,k)) = halt SCM+FSA;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,k))/.IC Comput(ProgramPart(s3),s3,k)
 = Comput(ProgramPart(s3),s3,k).IC Comput(ProgramPart(s3),s3,k) by AMI_1:150;
TX0: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,0)
by AMI_1:144;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3
,0)) = i
     by A38,u;
    then
A44: k <> 0 by A43,SCMFSA_2:48,124;
xx:    k <> 1 by A27,A28,A43,Y,SCMFSA_2:47,124,TX0,TX3;
    2 <> k by A43,A41,A42,TX0,TX2;
    then 2 < k by A44,xx,NAT_1:27;
    then consider k2 being Nat such that
A45: 2 + k2 = k by NAT_1:10;
    reconsider k2 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(ProgramPart( s00), s00,k2) as Element of NAT;
    assume
    not pseudo-LifeSpan(s00,J0) + (1 + 2) <= k;
    then k < pseudo-LifeSpan(s00,J0) + 1 + 2;
    then k2 < pseudo-LifeSpan(s00,J0) + 1 by A45,XREAL_1:8;
    then
A46: k2 <= pseudo-LifeSpan(s00,J0) by NAT_1:13;
    then
A47: k2 <= pseudo-LifeSpan(s,J0) by A16,Th50;
A48: now
      per cases by A47,XXREAL_0:1;
      suppose
A49:    k2 = pseudo-LifeSpan(s,J0);
        card I + card J + (2 + 1) = card J + 2 + 1 + card I;
        then
A50:    card J + 2 + 1 <= card I + card J + 3 by NAT_1:11;
        IC Comput(ProgramPart( s00), s00,k2) =  card ProgramPart J0 by A16,A49,
SCMFSA8A:def 5
          .=  card J0 by AMI_1:105;
        then n = card J by SCMFSA8A:34;
        hence n + 2 < card I + card J + 3 by A50,NAT_1:13;
      end;
      suppose
        k2 < pseudo-LifeSpan(s,J0);
        then  n in dom J0 by A16,SCMFSA8A:31;
        then n < card J0 by AFINSQ_1:70;
        then n + 2 < card J0 + 2 by XREAL_1:8;
        then
A51:    n + 2 < card J + 2 by SCMFSA8A:34;
        card I + card J + (1 + 2) = card J + 2 + (card I + 1);
        then card J + 2 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A51,XXREAL_0:2;
      end;
    end;
    then
A52:  (n + 2) in dom if=0(a,I,J) by Th56;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:144;
A53: IC Comput(ProgramPart( s3), s3,k) = IC Comput(ProgramPart( s3), s5,k2) by
A45,AMI_1:51
      .=  (n + 2) by A24,A18,A14,A30,A33,A46,Th51,T;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,k))/.IC Comput(ProgramPart(s3),s3,k)
 = Comput(ProgramPart(s3),s3,k).IC Comput(ProgramPart(s3),s3,k) by AMI_1:150;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:144;
    CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,k))
     = s3.IC Comput(ProgramPart( s3), s3,k) by Y,AMI_1:54,TX3
      .= if=0(a,I,J).IC Comput(ProgramPart( s3), s3,k) by A53,A52,Th26;
    hence contradiction by A43,A53,A48,Th56;
  end;
  then
A54: LifeSpan(ProgramPart(s3),s3) = pseudo-LifeSpan(s00,J0)
+ 2 + 1 by A36,A37,AMI_1:def 46;
Y:  (ProgramPart s9)/.IC s9
 = s9.IC s9 by AMI_1:150;
  CurInstr(ProgramPart s9,s9) = s3. (card J + 2) by A34,Y,AMI_1:54
    .= if=0(a,I,J). (card J + 2) by A21,Th26
    .= goto  (card I + card J + 3) by Th63;
  then InsCode CurInstr(ProgramPart s9,s9) = 6 by SCMFSA_2:47;
  then InsCode CurInstr(ProgramPart s9,s9) in {0,6,7,8} by ENUMSET1:def 2;
  then
A55: DataPart s9 = DataPart Following(ProgramPart s9,s9) by Th32;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:144;
A56: DataPart s9 = DataPart Comput(ProgramPart( s3), s5,pseudo-LifeSpan(
s00,J0)
) by AMI_1:51
    .= DataPart Comput(ProgramPart( s00), s00,pseudo-LifeSpan(
s00,J0)) by A24
,A18,A14,A30,T,A33,Th51;
T: ProgramPart s3 = ProgramPart s9
by AMI_1:144;
  thus DataPart IExec(if=0(a,I,J),ss) = DataPart IExec(if=0(a,I,J),s) by Th17
    .= DataPart(Result(ProgramPart(s +* Initialized if=0(a,I,J)),s +*
Initialized if=0(a,I,J)) +* s | A) by
SCMFSA6B:def 1
    .= DataPart Result(ProgramPart(s3),s3) by A5,Th35
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s3),s3)) by
A37,AMI_1:122
    .= DataPart Following(ProgramPart s3,s9) by A54,AMI_1:14
    .= DataPart Comput(ProgramPart( s00), s00,pseudo-LifeSpan(
s,J0)) by A16,A56
,A55,Th50,T
    .= DataPart Result(ProgramPart(s1),s1) by A17,A25,AMI_1:122
    .= DataPart(Result(ProgramPart(s +* Initialized (J ';' Stop SCM+FSA)),s +*
Initialized (J ';' Stop SCM+FSA)) +* s | A) by A19
,Th35
    .= DataPart IExec(J ';' Stop SCM+FSA,s) by SCMFSA6B:def 1
    .= DataPart IExec(J ';' Stop SCM+FSA,ss) by Th17;
end;

theorem Th72:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a <= 0 & Directed J is_pseudo-closed_on s
holds if>0(a,I,J) is_halting_on s & if>0(a,I,J) is_closed_on s & LifeSpan(
ProgramPart(s +*
  (if>0(a,I,J) +* Start-At( 0,SCM+FSA))),s +*
  (if>0(a,I,J) +* Start-At( 0,SCM+FSA))) = LifeSpan(ProgramPart(s +* (J ';'
  Stop SCM+FSA +*
  Start-At( 0,SCM+FSA))),s +* (J ';'
  Stop SCM+FSA +*
  Start-At( 0,SCM+FSA))) + 3
proof
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set J0 = Directed J;
  set s0 = Initialize s;
  set J9 = J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA));
  set s00 = s +* (J0 +* Start-At( 0,SCM+FSA));
  set s3 = s +* (if>0(a,I,J) +* Start-At( 0,SCM+FSA));
  set s4 = Comput(ProgramPart( s3), s3,1);
  set s5 = Comput(ProgramPart( s3), s3,2);
  set i = a >0_goto  (card J + 3);
A1: J0 +* Start-At( 0,SCM+FSA) c= s00 by FUNCT_4:26;
  if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  then if>0(a,I,J) = Macro i ';' J ';' Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA) by SCMFSA6A:67;
  then if>0(a,I,J) = Macro i ';' J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA)) by SCMFSA6A:67;
  then
A2: if>0(a,I,J) = Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA))) by SCMFSA6A:67;
  card Macro i = 2 by SCMFSA7B:6;
  then
A3: ProgramPart Relocated(J9,2) c= if>0(a,I,J) by A2,FUNCT_4:26;
A4:  0 in dom if>0(a,I,J) by Th54;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA))
  by GRFUNC_1:8;
  then
A5: s3. 0 = (if>0(a,I,J) +* Start-At( 0,SCM+FSA)). 0
by A4,FUNCT_4:14
    .= if>0(a,I,J). 0 by A4,SCMFSA6B:7
    .= i by Th55;
  card if>0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:15
    .= card J + 2 + (card I + 2);
  then
A6: card J + 2 + 0 < card if>0(a,I,J) by XREAL_1:10;
  then
A7:  (card J + 2) in dom if>0(a,I,J) by AFINSQ_1:70;
  IC SCM+FSA in dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
  then
A8: IC s3 = (if>0(a,I,J) +* Start-At( 0,SCM+FSA)).IC SCM+FSA
by FUNCT_4:14
    .=  0 by SF_MASTR:66;
  set ss = Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,
J0) + 2);
A9: if>0(a,I,J) c= if>0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
A10: if>0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  if>0(a,I,J) +* Start-At( 0,SCM+FSA) c= s3 by FUNCT_4:26;
  then if>0(a,I,J) c= s3 by A9,XBOOLE_1:1;
  then ProgramPart Relocated(J9,2) c= s3 by A3,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(J9,2) c= s5 by AMI_1:99;
  then
A11: ProgramPart Relocated(J9,2) c= s5 by AMI_1:105;
  ProgramPart Relocated(J0,2) c= ProgramPart Relocated(J9,2) by Th12,
SCMFSA6A:55;
  then
A12: ProgramPart Relocated(J0,2) c= s5 by A11,XBOOLE_1:1;
  card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if>0(a,I,J) by NAT_1:13;
  then
A13:  (card I + card J + 3) in dom if>0(a,I,J) by AFINSQ_1:70;
  assume
  s.a <= 0;
  then
A14: s0.a <= 0 by SCMFSA6C:3;
A15:  1 in dom if>0(a,I,J) by Th54;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A16: dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
A17: if>0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  assume
A18: J0 is_pseudo-closed_on s;
  then
A19: pseudo-LifeSpan(s,J0) = LifeSpan(ProgramPart(s +* (J ';'
Stop SCM+FSA +*
Start-At( 0,SCM+FSA))),s +* (J ';' Stop SCM+FSA +*
Start-At( 0,SCM+FSA))) by Th58;
A20: s4. 1 = s3. 1 by AMI_1:54
    .= (if>0(a,I,J) +* Start-At( 0,SCM+FSA)). 1
    by A15,A16,FUNCT_4:14
    .= if>0(a,I,J). 1 by A15,SCMFSA6B:7
    .= goto  2 by Th55;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A21: J0 is_pseudo-closed_on s00 by A18,Th52;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
A22: Comput(ProgramPart( s3), s3,0+1) =
Following(ProgramPart s3,Comput(ProgramPart(s3),s3,0)
) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A8,A5,Y;
  s3.a = s.a by Th28
    .= s0.a by SCMFSA6C:3;
  then
A23: IC s4 = succ IC s3 by A14,A22,SCMFSA_2:97
    .=  (0 + 1) by A8;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
A24: Comput(ProgramPart( s3), s3,1+1) = Following(ProgramPart s3,s4) by
AMI_1:14
    .= Exec(goto  2,s4) by A23,A20,Y,T;
  then
A25: IC s5 =  2 by SCMFSA_2:95;
A26: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A27: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A26,SCMFSA6A:38
      .= s4.f by A22,SCMFSA_2:97
      .= s5.f by A24,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A26,SCMFSA6A:38
      .= s4.a by A22,SCMFSA_2:97
      .= s5.a by A24,SCMFSA_2:95;
  end;
  then
A28: DataPart s00 = DataPart s5 by A27,SCMFSA6A:38;
Y:  (ProgramPart ss)/.IC ss
 = ss.IC ss by AMI_1:150;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:144;
A29: IC ss = IC Comput(ProgramPart( s3), s5,pseudo-LifeSpan(
s00,J0)) by
AMI_1:51
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s00
,J0)) + 2 by A1,A21
,A12,A25,A28,T,Th51
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s,J0)
) + 2 by A18,Th50
    .=  card ProgramPart J0 + 2 by A18,SCMFSA8A:def 5
    .=  card J0 + 2 by AMI_1:105
    .=  (card J + 2) by SCMFSA8A:34;
  then
A30: CurInstr(ProgramPart ss,ss) = s3. (card J + 2) by Y,AMI_1:54
    .= if>0(a,I,J). (card J + 2) by A10,A7,GRFUNC_1:8
    .= goto  (card I + card J + 3) by Th64;
Y:  (ProgramPart Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,J0) + 2 + 1))
/.
IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2
+ 1)
 = Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2
+ 1).
 IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2
+ 1) by AMI_1:150;
T: ProgramPart s3 = ProgramPart ss
by AMI_1:144;
TX: ProgramPart s3 =
 ProgramPart Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,J0) +
2 + 1)
by AMI_1:144;
A31: IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0)
+ 2 + 1) =
IC Following(ProgramPart s3,ss)
  by AMI_1:14
    .=  (card I + card J + 3) by A30,T,SCMFSA_2:95;
  then
A32: CurInstr(ProgramPart s3,
   Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2
+ 1)) = s3. (
  card I + card J + 3) by Y,TX,AMI_1:54
    .= if>0(a,I,J). (card I + card J + 3) by A17,A13,GRFUNC_1:8
    .= halt SCM+FSA by Th62;
  then
A33: ProgramPart s3 halts_on s3 by TX,AMI_1:146;
  hence if>0(a,I,J) is_halting_on s by SCMFSA7B:def 8;
  now
    let k be Element of NAT;
    per cases;
    suppose
      k = 0;
      then Comput(ProgramPart( s3), s3,k) = s3 by AMI_1:13;
      then IC Comput(ProgramPart( s3), s3,k) =  0 by Th31;
      hence IC Comput(ProgramPart( s3), s3,k) in dom if>0(a,I,J) by Th54;
    end;
    suppose
      0 < k & k = 1;
      hence IC Comput(ProgramPart( s3), s3,k) in dom if>0(a,I,J) by A23,Th54;
    end;
    suppose
A34:  0 < k & k <> 1 & k < pseudo-LifeSpan(s00,J0) + 2;
      then 0 + 1 <= k by INT_1:20;
      then 1 < k by A34,XXREAL_0:1;
      then 0 + (1 + 1) <= k by INT_1:20;
      then consider k2 being Nat such that
A35:  2 + k2 = k by NAT_1:10;
      card if>0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:15
        .= card J + 2 + (card I + 2);
      then
A36:  card J + 2 <= card if>0(a,I,J) by NAT_1:12;
      reconsider k2 as Element of NAT by ORDINAL1:def 13;
      reconsider n = IC Comput(ProgramPart( s00), s00,k2) as Element of NAT;
A37:  k2 < pseudo-LifeSpan(s00,J0) by A34,A35,XREAL_1:8;
      then k2 < pseudo-LifeSpan(s,J0) by A18,Th50;
      then  n in dom J0 by A18,SCMFSA8A:31;
      then n < card J0 by AFINSQ_1:70;
      then n + 2 < card J0 + 2 by XREAL_1:8;
      then n + 2 < card J + 2 by SCMFSA8A:34;
      then
A38:  n + 2 < card if>0(a,I,J) by A36,XXREAL_0:2;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:144;
      IC Comput(ProgramPart( s3), s3,k) = IC Comput(ProgramPart( s3), s5,k2)
by A35,AMI_1:51
        .= IC Comput(ProgramPart( s00), s00,k2) + 2 by A1,A21,A12,A25,A28,A37
,Th51,T;
      hence IC Comput(ProgramPart( s3), s3,k) in dom if>0(a,I,J) by A38,
AFINSQ_1:70;
    end;
    suppose
A39:  0 < k & k <> 1 & pseudo-LifeSpan(s00,J0) + 2 <= k;
      hereby
        per cases by A39,XXREAL_0:1;
        suppose
          pseudo-LifeSpan(s00,J0) + 2 = k;
          hence IC Comput(ProgramPart( s3), s3,k) in dom if>0(a,I,J) by A6,A29,
AFINSQ_1:70;
        end;
        suppose
          pseudo-LifeSpan(s00,J0) + 2 < k;
          then pseudo-LifeSpan(s00,J0) + 2 + 1 <= k by
INT_1:20;
          hence IC Comput(ProgramPart( s3), s3,k) in dom if>0(a,I,J) by A13,A31
,A32,AMI_1:52;
        end;
      end;
    end;
  end;
  hence if>0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
V:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
A40: CurInstr(ProgramPart s3,s3) = i by A8,A5,V;
  now
A41: 0 + 2 < card I + card J + 3 by XREAL_1:10;
    then
A42:  2 in dom if>0(a,I,J) by Th57;
A43: if>0(a,I,J). 2 <> halt SCM+FSA by A41,Th57;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,2))/.IC Comput(ProgramPart(s3),s3,2)
 = Comput(ProgramPart(s3),s3,2).IC Comput(ProgramPart(s3),s3,2) by AMI_1:150;
A44: CurInstr(ProgramPart Comput(ProgramPart(s3),s3,2),Comput(ProgramPart(s3),
s3,2)) = s3. 2
 by A25,Y,AMI_1:54
      .= if>0(a,I,J). 2 by A42,Th26;
    let k be Element of NAT;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:144;
    assume
A45: CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,k)) = halt SCM+FSA;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
U:  (ProgramPart Comput(ProgramPart(s3),s3,k))/.IC Comput(ProgramPart(s3),s3,k)
 = Comput(ProgramPart(s3),s3,k).IC Comput(ProgramPart(s3),s3,k) by AMI_1:150;
TX0: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,0)
by AMI_1:144;
    CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3
,0)) = i
     by A40,u;
    then
A46: k <> 0 by A45,SCMFSA_2:49,124;
xx:    k <> 1 by A23,A20,A45,U,SCMFSA_2:47,124,TX0,TX3;
    2 <> k by A45,A43,A44,TX0,TX3;
    then 2 < k by A46,xx,NAT_1:27;
    then consider k2 being Nat such that
A47: 2 + k2 = k by NAT_1:10;
    reconsider k2 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(ProgramPart( s00), s00,k2) as Element of NAT;
    assume
    not pseudo-LifeSpan(s00,J0) + (1 + 2) <= k;
    then k < pseudo-LifeSpan(s00,J0) + 1 + 2;
    then k2 < pseudo-LifeSpan(s00,J0) + 1 by A47,XREAL_1:8;
    then
A48: k2 <= pseudo-LifeSpan(s00,J0) by NAT_1:13;
    then
A49: k2 <= pseudo-LifeSpan(s,J0) by A18,Th50;
A50: now
      per cases by A49,XXREAL_0:1;
      suppose
A51:    k2 = pseudo-LifeSpan(s,J0);
        card I + card J + (2 + 1) = card J + 2 + 1 + card I;
        then
A52:    card J + 2 + 1 <= card I + card J + 3 by NAT_1:11;
        IC Comput(ProgramPart( s00), s00,k2) =  card ProgramPart J0 by A18,A51,
SCMFSA8A:def 5
          .=  card J0 by AMI_1:105;
        then n = card J by SCMFSA8A:34;
        hence n + 2 < card I + card J + 3 by A52,NAT_1:13;
      end;
      suppose
        k2 < pseudo-LifeSpan(s,J0);
        then  n in dom J0 by A18,SCMFSA8A:31;
        then n < card J0 by AFINSQ_1:70;
        then n + 2 < card J0 + 2 by XREAL_1:8;
        then
A53:    n + 2 < card J + 2 by SCMFSA8A:34;
        card I + card J + (1 + 2) = card J + 2 + (card I + 1);
        then card J + 2 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A53,XXREAL_0:2;
      end;
    end;
    then
A54:  (n + 2) in dom if>0(a,I,J) by Th57;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:144;
A55: IC Comput(ProgramPart( s3), s3,k) = IC Comput(ProgramPart( s3), s5,k2) by
A47,AMI_1:51
      .=  (n + 2) by A1,A21,A12,A25,A28,A48,Th51,T;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,k))/.IC Comput(ProgramPart(s3),s3,k)
 = Comput(ProgramPart(s3),s3,k).IC Comput(ProgramPart(s3),s3,k) by AMI_1:150;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:144;
    CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,k))
     = s3.IC Comput(ProgramPart( s3), s3,k) by Y,AMI_1:54,TX3
      .= if>0(a,I,J).IC Comput(ProgramPart( s3), s3,k) by A55,A54,Th26;
    hence contradiction by A45,A55,A50,Th57,TX3;
  end;
  then LifeSpan(ProgramPart(s3),s3) = pseudo-LifeSpan(s00,
J0) + 3 by A32,A33,TX,AMI_1:def 46;
  hence thesis by A18,A19,Th50;
end;

theorem Th73:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.intloc 0 = 1 & s.a <= 0 & Directed J
  is_pseudo-closed_on s holds DataPart IExec(if>0(a,I,J),s) = DataPart IExec(J
  ';' Stop SCM+FSA,s)
proof
  let ss be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set J0 = Directed J;
  set s = Initialize ss;
  set s0 = Initialize s;
  set J9 = J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA));
  set s00 = s +* (J0 +* Start-At( 0,SCM+FSA));
  set s3 = s +* (if>0(a,I,J) +* Start-At( 0,SCM+FSA));
  set s4 = Comput(ProgramPart( s3), s3,1);
  set s5 = Comput(ProgramPart( s3), s3,2);
  set i = a >0_goto  (card J + 3);
  assume
A1: ss.intloc 0 = 1;
  set s1 = s +* (J ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA));
  assume
  ss.a <= 0;
  then s.a <= 0 by SCMFSA6C:3;
  then
A2: s0.a <= 0 by SCMFSA6C:3;
A3:  0 in dom if>0(a,I,J) by Th54;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA))
  by GRFUNC_1:8;
  then
A4: s3. 0 = (if>0(a,I,J) +* Start-At( 0,SCM+FSA)). 0
by A3,FUNCT_4:14
    .= if>0(a,I,J). 0 by A3,SCMFSA6B:7
    .= i by Th55;
  s +* Initialized if>0(a,I,J) = Initialize s +* (if>0(a,I,J) +*
  Start-At( 0,SCM+FSA)) by SCMFSA8A:13;
  then
A5: s +* Initialized if>0(a,I,J) = s3 by Th15;
A6: if>0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A7: dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
A8: J0 ';' Stop SCM+FSA = J ';' Stop SCM+FSA by SCMFSA8A:41;
  IC SCM+FSA in dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
  then
A9: IC s3 = (if>0(a,I,J) +* Start-At( 0,SCM+FSA)).IC SCM+FSA
by FUNCT_4:14
    .=  0 by SF_MASTR:66;
  if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  then if>0(a,I,J) = Macro i ';' J ';' Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA) by SCMFSA6A:67;
  then if>0(a,I,J) = Macro i ';' J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA)) by SCMFSA6A:67;
  then
A10: if>0(a,I,J) = Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA))) by SCMFSA6A:67;
  card Macro i = 2 by SCMFSA7B:6;
  then
A11: ProgramPart Relocated(J9,2) c= if>0(a,I,J) by A10,FUNCT_4:26;
A12: if>0(a,I,J) c= if>0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  if>0(a,I,J) +* Start-At( 0,SCM+FSA) c= s3 by FUNCT_4:26;
  then if>0(a,I,J) c= s3 by A12,XBOOLE_1:1;
  then ProgramPart Relocated(J9,2) c= s3 by A11,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(J9,2) c= s5 by AMI_1:99;
  then
A13: ProgramPart Relocated(J9,2) c= s5 by AMI_1:105;
  ProgramPart Relocated(J0,2) c= ProgramPart Relocated(J9,2) by Th12,
SCMFSA6A:55;
  then
A14: ProgramPart Relocated(J0,2) c= s5 by A13,XBOOLE_1:1;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
A15: Comput(ProgramPart( s3), s3,0+1) =
Following(ProgramPart s3,Comput(ProgramPart(s3),s3,0)
)
 by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A9,A4,Y;
  assume
  J0 is_pseudo-closed_on ss;
  then
A16: J0 is_pseudo-closed_on s by A1,Th53;
  then J ';' Stop SCM+FSA is_halting_on s by Th58;
  then
A17: ProgramPart s1 halts_on s1 by SCMFSA7B:def 8;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A18: J0 is_pseudo-closed_on s00 by A16,Th52;
  s +* Initialized (J ';' Stop SCM+FSA) = Initialize s +* (J ';' Stop
  SCM+FSA +* Start-At( 0,SCM+FSA)) by SCMFSA8A:13;
  then
A19: s +* Initialized (J ';' Stop SCM+FSA) = s1 by Th15;
A20: Directed J0 = J0 by SCMFSA6A:63;
  card if>0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:15
    .= card J + 2 + (card I + 2);
  then card J + 2 + 0 < card if>0(a,I,J) by XREAL_1:10;
  then
A21:  (card J + 2) in dom if>0(a,I,J) by AFINSQ_1:70;
  card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if>0(a,I,J) by NAT_1:13;
  then
A22:  (card I + card J + 3) in dom if>0(a,I,J) by AFINSQ_1:70;
A23: if>0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  set s9 = Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,
J0) + 2);
A24: J0 +* Start-At( 0,SCM+FSA) c= s00 by FUNCT_4:26;
  LifeSpan(ProgramPart(s1),s1) = pseudo-LifeSpan(s,J0) by A16
,Th58;
  then
A25: DataPart Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s
,J0)) = DataPart
Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) by A16,A20,A8,Th58;
A26:  1 in dom if>0(a,I,J) by Th54;
  s3.a = s.a by Th28
    .= s0.a by SCMFSA6C:3;
  then
A27: IC s4 = succ IC s3 by A2,A15,SCMFSA_2:97
    .=  (0 + 1) by A9;
A28: s4. 1 = s3. 1 by AMI_1:54
    .= (if>0(a,I,J) +* Start-At( 0,SCM+FSA)). 1
    by A26,A7,FUNCT_4:14
    .= if>0(a,I,J). 1 by A26,SCMFSA6B:7
    .= goto  2 by Th55;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:144;
A29: Comput(ProgramPart( s3), s3,1+1) = Following(ProgramPart s3,s4) by
AMI_1:14
    .= Exec(goto  2,s4) by A27,A28,Y,T;
  then
A30: IC s5 =  2 by SCMFSA_2:95;
A31: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A32: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A31,SCMFSA6A:38
      .= s4.f by A15,SCMFSA_2:97
      .= s5.f by A29,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A31,SCMFSA6A:38
      .= s4.a by A15,SCMFSA_2:97
      .= s5.a by A29,SCMFSA_2:95;
  end;
  then
A33: DataPart s00 = DataPart s5 by A32,SCMFSA6A:38;
Y:  (ProgramPart s9)/.IC s9
 = s9.IC s9 by AMI_1:150;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:144;
A34: IC s9 = IC Comput(ProgramPart( s3), s5,pseudo-LifeSpan(
s00,J0)) by
AMI_1:51
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s00
,J0)) + 2 by A24,A18
,A14,A30,A33,T,Th51
    .= IC Comput(ProgramPart( s00), s00,pseudo-LifeSpan(s,J0)
) + 2 by A16,Th50
    .=  card ProgramPart J0 + 2 by A16,SCMFSA8A:def 5
    .=  card J0 + 2 by AMI_1:105
    .=  (card J + 2) by SCMFSA8A:34;
  then
A35: CurInstr(ProgramPart s9,s9) = s3. (card J + 2) by Y,AMI_1:54
    .= if>0(a,I,J). (card J + 2) by A23,A21,GRFUNC_1:8
    .= goto  (card I + card J + 3) by Th64;
Y:  (ProgramPart Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,J0) + 2 + 1))
/.
IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2
+ 1)
 = Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2
+ 1).
 IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2
+ 1) by AMI_1:150;
T: ProgramPart s3 = ProgramPart s9
by AMI_1:144;
TX3: ProgramPart s3 = ProgramPart
Comput(ProgramPart( s3), s3,pseudo-LifeSpan(
s00,J0) +
2 + 1)
by AMI_1:144;
  IC Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) +
2 + 1) =
  IC Following(ProgramPart s3,s9)
  by AMI_1:14
    .=  (card I + card J + 3) by A35,T,SCMFSA_2:95;
  then
A36: CurInstr(ProgramPart s3,
  Comput(ProgramPart( s3), s3,pseudo-LifeSpan(s00,J0) + 2 +
1)) = s3. (
  card I + card J + 3) by Y,AMI_1:54,TX3
    .= if>0(a,I,J). (card I + card J + 3) by A6,A22,GRFUNC_1:8
    .= halt SCM+FSA by Th62;
  then
A37: ProgramPart s3 halts_on s3 by AMI_1:146;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
A38: CurInstr(ProgramPart s3,s3) = i by A9,A4,Y;
  now
A39: 0 + 2 < card I + card J + 3 by XREAL_1:10;
    then
A40:  2 in dom if>0(a,I,J) by Th57;
A41: if>0(a,I,J). 2 <> halt SCM+FSA by A39,Th57;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,2))/.IC Comput(ProgramPart(s3),s3,2)
 = Comput(ProgramPart(s3),s3,2).IC Comput(ProgramPart(s3),s3,2) by AMI_1:150;
TX2: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,2)
by AMI_1:144;
A42: CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,2))
 = s3. 2 by A30,Y,AMI_1:54,TX2
      .= if>0(a,I,J). 2 by A40,Th26;
    let k be Element of NAT;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:144;
    assume
A43: CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,k)) = halt SCM+FSA;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,k))/.IC Comput(ProgramPart(s3),s3,k)
 = Comput(ProgramPart(s3),s3,k).IC Comput(ProgramPart(s3),s3,k) by AMI_1:150;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    CurInstr(ProgramPart Comput(ProgramPart(s3),s3,0),Comput(ProgramPart(s3),s3
,0))
     = i by A38,u;
    then
A44: k <> 0 by A43,SCMFSA_2:49,124,TX3;
xx:    k <> 1 by A27,A28,A43,Y,SCMFSA_2:47,124,TX3;
    2 <> k by A43,A41,A42,TX3;
    then 2 < k by A44,xx,NAT_1:27;
    then consider k2 being Nat such that
A45: 2 + k2 = k by NAT_1:10;
    reconsider k2 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(ProgramPart( s00), s00,k2) as Element of NAT;
    assume
    not pseudo-LifeSpan(s00,J0) + (1 + 2) <= k;
    then k < pseudo-LifeSpan(s00,J0) + 1 + 2;
    then k2 < pseudo-LifeSpan(s00,J0) + 1 by A45,XREAL_1:8;
    then
A46: k2 <= pseudo-LifeSpan(s00,J0) by NAT_1:13;
    then
A47: k2 <= pseudo-LifeSpan(s,J0) by A16,Th50;
A48: now
      per cases by A47,XXREAL_0:1;
      suppose
A49:    k2 = pseudo-LifeSpan(s,J0);
        card I + card J + (2 + 1) = card J + 2 + 1 + card I;
        then
A50:    card J + 2 + 1 <= card I + card J + 3 by NAT_1:11;
        IC Comput(ProgramPart( s00), s00,k2) =  card ProgramPart J0 by A16,A49,
SCMFSA8A:def 5
          .=  card J0 by AMI_1:105;
        then n = card J by SCMFSA8A:34;
        hence n + 2 < card I + card J + 3 by A50,NAT_1:13;
      end;
      suppose
        k2 < pseudo-LifeSpan(s,J0);
        then  n in dom J0 by A16,SCMFSA8A:31;
        then n < card J0 by AFINSQ_1:70;
        then n + 2 < card J0 + 2 by XREAL_1:8;
        then
A51:    n + 2 < card J + 2 by SCMFSA8A:34;
        card I + card J + (1 + 2) = card J + 2 + (card I + 1);
        then card J + 2 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A51,XXREAL_0:2;
      end;
    end;
    then
A52:  (n + 2) in dom if>0(a,I,J) by Th57;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:144;
A53: IC Comput(ProgramPart( s3), s3,k) = IC Comput(ProgramPart( s3), s5,k2) by
A45,AMI_1:51
      .=  (n + 2) by A24,A18,A14,A30,A33,A46,Th51,T;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,k))/.IC Comput(ProgramPart(s3),s3,k)
 = Comput(ProgramPart(s3),s3,k).IC Comput(ProgramPart(s3),s3,k) by AMI_1:150;
    CurInstr(ProgramPart Comput(ProgramPart(s3),s3,k),Comput(ProgramPart(s3),s3
,k))
     = s3.IC Comput(ProgramPart( s3), s3,k) by Y,AMI_1:54
      .= if>0(a,I,J).IC Comput(ProgramPart( s3), s3,k) by A53,A52,Th26;
    hence contradiction by A43,A53,A48,Th57,TX3;
  end;
  then
A54: LifeSpan(ProgramPart(s3),s3) = pseudo-LifeSpan(s00,J0)
+ 2 + 1 by A36,A37,AMI_1:def 46;
Y:  (ProgramPart s9)/.IC s9
 = s9.IC s9 by AMI_1:150;
  CurInstr(ProgramPart s9,s9) = s3. (card J + 2) by A34,Y,AMI_1:54
    .= if>0(a,I,J). (card J + 2) by A21,Th26
    .= goto  (card I + card J + 3) by Th64;
  then InsCode CurInstr(ProgramPart s9,s9) = 6 by SCMFSA_2:47;
  then InsCode CurInstr(ProgramPart s9,s9) in {0,6,7,8} by ENUMSET1:def 2;
  then
A55: DataPart s9 = DataPart Following(ProgramPart s9,s9) by Th32;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:144;
A56: DataPart s9 = DataPart Comput(ProgramPart( s3), s5,pseudo-LifeSpan(
s00,J0)
) by AMI_1:51
    .= DataPart Comput(ProgramPart( s00), s00,pseudo-LifeSpan(
s00,J0)) by A24
,A18,A14,A30,T,A33,Th51;
T: ProgramPart s3 = ProgramPart s9
by AMI_1:144;
  thus DataPart IExec(if>0(a,I,J),ss) = DataPart IExec(if>0(a,I,J),s) by Th17
    .= DataPart(Result(ProgramPart(s +* Initialized if>0(a,I,J)),s +*
Initialized if>0(a,I,J)) +* s | A) by
SCMFSA6B:def 1
    .= DataPart(Result(ProgramPart(s3),s3)) by A5,Th35
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s3),s3)) by
A37,AMI_1:122
    .= DataPart Following(ProgramPart s3,s9) by A54,AMI_1:14
    .= DataPart Comput(ProgramPart( s00), s00,pseudo-LifeSpan(
s,J0)) by A16,A56
,A55,Th50,T
    .= DataPart Result(ProgramPart(s1),s1) by A17,A25,AMI_1:122
    .= DataPart(Result(ProgramPart(s +* Initialized (J ';' Stop SCM+FSA)),s +*
Initialized (J ';' Stop SCM+FSA)) +* s | A) by A19
,Th35
    .= DataPart IExec(J ';' Stop SCM+FSA,s) by SCMFSA6B:def 1
    .= DataPart IExec(J ';' Stop SCM+FSA,ss) by Th17;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
  read-write Int-Location st Directed I is_pseudo-closed_on s & Directed J
  is_pseudo-closed_on s holds if=0(a,I,J) is_closed_on s & if=0(a,I,J)
  is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: Directed I is_pseudo-closed_on s;
  assume
A2: Directed J is_pseudo-closed_on s;
  hereby
    per cases;
    suppose
A3:   s.a = 0;
      hence if=0(a,I,J) is_closed_on s by A1,Th66;
      thus if=0(a,I,J) is_halting_on s by A1,A3,Th66;
    end;
    suppose
A4:   s.a <> 0;
      hence if=0(a,I,J) is_closed_on s by A2,Th70;
      thus if=0(a,I,J) is_halting_on s by A2,A4,Th70;
    end;
  end;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
  read-write Int-Location st Directed I is_pseudo-closed_on s & Directed J
  is_pseudo-closed_on s holds if>0(a,I,J) is_closed_on s & if>0(a,I,J)
  is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: Directed I is_pseudo-closed_on s;
  assume
A2: Directed J is_pseudo-closed_on s;
  hereby
    per cases;
    suppose
A3:   s.a > 0;
      hence if>0(a,I,J) is_closed_on s by A1,Th68;
      thus if>0(a,I,J) is_halting_on s by A1,A3,Th68;
    end;
    suppose
A4:   s.a <= 0;
      hence if>0(a,I,J) is_closed_on s by A2,Th72;
      thus if>0(a,I,J) is_halting_on s by A2,A4,Th72;
    end;
  end;
end;

theorem
  for I being Program of SCM+FSA, a being Int-Location holds I
  does_not_destroy a implies Directed I does_not_destroy a by SCMFSA8A:27;

theorem Th77:
  for i being Instruction of SCM+FSA, a being Int-Location holds i
  does_not_destroy a implies Macro i does_not_destroy a
proof
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
A1: rng Macro i = {i,halt SCM+FSA} by FUNCT_4:67;
  assume
A2: i does_not_destroy a;
  now
    let ii be Instruction of SCM+FSA;
    assume
    ii in rng Macro i;
    then ii = i or ii = halt SCM+FSA by A1,TARSKI:def 2;
    hence ii does_not_destroy a by A2,SCMFSA7B:11;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th78:
  for a being Int-Location holds halt SCM+FSA does_not_refer a
proof
  let a be Int-Location;
  for b be Int-Location for l be Element of NAT for f be
  FinSeq-Location holds b := a <> halt SCM+FSA & AddTo(b,a) <> halt SCM+FSA &
  SubFrom(b,a) <> halt SCM+FSA & MultBy(b,a) <> halt SCM+FSA & Divide(a,b) <>
  halt SCM+FSA & Divide(b,a) <> halt SCM+FSA & a =0_goto l <> halt SCM+FSA & a
  >0_goto l <> halt SCM+FSA & b :=(f,a) <> halt SCM+FSA & (f,b):= a <> halt
  SCM+FSA & (f,a):= b <> halt SCM+FSA & f :=<0,...,0> a <> halt SCM+FSA by
SCMFSA_2:42,43,44,45,46,48,49,50,51,53,124;
  hence thesis by SCMFSA7B:def 1;
end;

theorem
  for a,b,c being Int-Location holds a <> b implies AddTo(c,b)
  does_not_refer a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let f be FinSeq-Location;
A2: InsCode AddTo(c,b) = 2 by SCMFSA_2:43;
    hence e := a <> AddTo(c,b) by SCMFSA_2:42;
    thus AddTo(e,a) <> AddTo(c,b) by A1,SF_MASTR:6;
    thus SubFrom(e,a) <> AddTo(c,b) by A2,SCMFSA_2:44;
    thus MultBy(e,a) <> AddTo(c,b) by A2,SCMFSA_2:45;
    thus Divide(a,e) <> AddTo(c,b) & Divide(e,a) <> AddTo(c,b) by A2,
SCMFSA_2:46;
    thus a =0_goto l <> AddTo(c,b) by A2,SCMFSA_2:48;
    thus a >0_goto l <> AddTo(c,b) by A2,SCMFSA_2:49;
    thus e :=(f,a) <> AddTo(c,b) by A2,SCMFSA_2:50;
    thus (f,e):= a <> AddTo(c,b) & (f,a):= e <> AddTo(c,b) by A2,SCMFSA_2:51;
    thus f :=<0,...,0> a <> AddTo(c,b) by A2,SCMFSA_2:53;
  end;
  hence thesis by SCMFSA7B:def 1;
end;

theorem
  for i being Instruction of SCM+FSA, a being Int-Location holds i
  does_not_refer a implies Macro i does_not_refer a
proof
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
A1: rng Macro i = {i,halt SCM+FSA} by FUNCT_4:67;
  assume
A2: i does_not_refer a;
  now
    let ii be Instruction of SCM+FSA;
    assume
    ii in rng Macro i;
    then ii = i or ii = halt SCM+FSA by A1,TARSKI:def 2;
    hence ii does_not_refer a by A2,Th78;
  end;
  hence thesis by SCMFSA7B:def 2;
end;

theorem Th81:
  for I,J being Program of SCM+FSA, a being Int-Location holds I
  does_not_destroy a & J does_not_destroy a implies I ';' J does_not_destroy a
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  assume that
A1: I does_not_destroy a and
A2: J does_not_destroy a;
A3: ProgramPart Relocated(J,card I) does_not_destroy a by A2,SCMFSA8A:23;
  Directed I does_not_destroy a by A1,SCMFSA8A:27;
  hence thesis by A3,SCMFSA8A:25;
end;

theorem Th82:
  for J being Program of SCM+FSA, i being Instruction of SCM+FSA,
a being Int-Location st i does_not_destroy a & J does_not_destroy a holds i ';'
  J does_not_destroy a
proof
  let J be Program of SCM+FSA;
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  assume that
A1: i does_not_destroy a and
A2: J does_not_destroy a;
  Macro i does_not_destroy a by A1,Th77;
  hence thesis by A2,Th81;
end;

theorem
  for I being Program of SCM+FSA, j being Instruction of SCM+FSA, a
being Int-Location st I does_not_destroy a & j does_not_destroy a holds I ';' j
  does_not_destroy a
proof
  let I be Program of SCM+FSA;
  let j be Instruction of SCM+FSA;
  let a be Int-Location;
  assume that
A1: I does_not_destroy a and
A2: j does_not_destroy a;
  Macro j does_not_destroy a by A2,Th77;
  hence thesis by A1,Th81;
end;

theorem
  for i,j being Instruction of SCM+FSA, a being Int-Location st i
  does_not_destroy a & j does_not_destroy a holds i ';' j does_not_destroy a
proof
  let i,j be Instruction of SCM+FSA;
  let a be Int-Location;
  assume that
A1: i does_not_destroy a and
A2: j does_not_destroy a;
A3: Macro j does_not_destroy a by A2,Th77;
  Macro i does_not_destroy a by A1,Th77;
  hence thesis by A3,Th81;
end;

theorem Th85:
  for a being Int-Location holds Stop SCM+FSA does_not_destroy a
proof
  let a be Int-Location;
  now
    let i be Instruction of SCM+FSA;
A1: rng Stop SCM+FSA = {halt SCM+FSA} by AFINSQ_1:36;
    assume
    i in rng Stop SCM+FSA;
    then i = halt SCM+FSA by A1,TARSKI:def 1;
    hence i does_not_destroy a by SCMFSA7B:11;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th86:
  for a being Int-Location, l being Element of NAT
   holds Goto l does_not_destroy a
proof
  let a be Int-Location;
  let l be Element of NAT;
  now
    let i be Instruction of SCM+FSA;
A1: rng Goto l = {goto l} by FUNCOP_1:14;
    assume
    i in rng Goto l;
    then i = goto l by A1,TARSKI:def 1;
    hence i does_not_destroy a by SCMFSA7B:17;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th87:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_halting_on Initialize s holds (for a being read-write Int-Location holds
IExec(I,s).a = Comput(ProgramPart(Initialize s +* (I +* Start-At( 0,SCM+FSA))),
Initialize s +* (I +* Start-At( 0,SCM+FSA)),
 (LifeSpan(ProgramPart(Initialize s +* (I +* Start-At( 0,SCM+FSA))),Initialize
s +* (I +* Start-At( 0,SCM+FSA))))).a) &
  for f being FinSeq-Location
  holds IExec(I,s).f = Comput(ProgramPart(Initialize s +* (I +*
  Start-At( 0,SCM+FSA))),Initialize s +* (I +*
  Start-At( 0,SCM+FSA)),
  LifeSpan(ProgramPart(Initialize s +* (I +* Start-At( 0,SCM+FSA))),Initialize
s +* (I +* Start-At( 0,SCM+FSA)))).f
proof
  let s be State of SCM+FSA;
  set A = NAT;
  let I be Program of SCM+FSA;
  set s0 = Initialize s;
  set s1 = s0 +* (I +* Start-At( 0,SCM+FSA));
  assume
  I is_halting_on s0;
  then
A1: ProgramPart s1 halts_on s1 by SCMFSA7B:def 8;
  hereby
    let a be read-write Int-Location;
    not a in A by SCMFSA_2:84;
    then not a in dom s /\ A by XBOOLE_0:def 4;
    then
A3: not a in dom (s | A) by RELAT_1:90;
    s +* Initialized I = s1 by SCMFSA8A:13;
    hence IExec(I,s).a = (Result(ProgramPart(s1),s1) +* s | A).a by SCMFSA6B:
def 1
      .= (Result(ProgramPart(s1),s1)).a by A3,FUNCT_4:12
      .= Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)).a by A1,
AMI_1:122;
  end;
  let f be FinSeq-Location;
  not f in A by SCMFSA_2:85;
  then not f in dom s /\ A by XBOOLE_0:def 4;
  then
A5: not f in dom (s | A) by RELAT_1:90;
  s +* Initialized I = s1 by SCMFSA8A:13;
  hence IExec(I,s).f = (Result(ProgramPart(s1),s1) +* s | A).f by SCMFSA6B:def
1
    .= (Result(ProgramPart(s1),s1)).f by A5,FUNCT_4:12
    .= Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)).f by A1,AMI_1:
122;
end;

theorem Th88:
  for s being State of SCM+FSA, I being parahalting Program of
  SCM+FSA, a being read-write Int-Location holds IExec(I,s).a = Comput(
ProgramPart(
  Initialize s +* (I +* Start-At( 0,SCM+FSA))),
  Initialize s +* (I +* Start-At( 0,SCM+FSA)),
  (LifeSpan(ProgramPart(Initialize s +* (I +*
  Start-At( 0,SCM+FSA))),Initialize s +* (I +*
  Start-At( 0,SCM+FSA))))).a
proof
  let s be State of SCM+FSA;
  let I be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  I is_halting_on Initialize s by SCMFSA7B:25;
  hence thesis by Th87;
end;

theorem Th89:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
  being Int-Location,k being Element of NAT st I is_closed_on Initialize s & I
  is_halting_on Initialize s & I does_not_destroy a holds IExec(I,s).a =
  Comput(ProgramPart( (Initialize s +* (I +* Start-At( 0,SCM+FSA)))), (
Initialize s +* (I +* Start-At( 0,SCM+FSA))),k).a
proof
  let s be State of SCM+FSA;
  set A = NAT;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  let k be Element of NAT;
  assume
A1: I is_closed_on Initialize s;
  not a in A by SCMFSA_2:84;
  then not a in dom s /\ A by XBOOLE_0:def 4;
  then
A3: not a in dom (s | A) by RELAT_1:90;
  set s0 = Initialize s;
  set s1 = s0 +* (I +* Start-At( 0,SCM+FSA));
  assume
  I is_halting_on Initialize s;
  then
A4: ProgramPart s1 halts_on s1 by SCMFSA7B:def 8;
  assume
A5: I does_not_destroy a;
  s +* Initialized I = s0 +* (I +* Start-At( 0,SCM+FSA)) by SCMFSA8A:13;
  hence IExec(I,s).a = (Result(ProgramPart(s1),s1) +* s | A).a by SCMFSA6B:def
1
    .= (Result(ProgramPart(s1),s1)).a by A3,FUNCT_4:12
    .= Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)).a by A4,AMI_1:
122
    .= s0.a by A1,A5,SCMFSA7B:27
    .= Comput(ProgramPart( (s0 +* (I +* Start-At( 0,SCM+FSA)))), (s0 +* (I +*
Start-At( 0,SCM+FSA))),k).a
    by A1,A5,SCMFSA7B:27;
end;

theorem Th90:
  for s being State of SCM+FSA, I being parahalting Program of
  SCM+FSA, a being Int-Location,k being Element of NAT st I does_not_destroy a
holds IExec(I,s).a = Comput(ProgramPart( (Initialize s +* (I +*
Start-At( 0,SCM+FSA)))), (Initialize s +* (I +*
Start-At( 0,SCM+FSA))),k)
  .a
proof
  let s be State of SCM+FSA;
  let I be parahalting Program of SCM+FSA;
  let a be Int-Location;
  let k be Element of NAT;
  set s0 = Initialize s;
  set s1 = s0 +* (I +* Start-At( 0,SCM+FSA));
A1: I is_closed_on s0 by SCMFSA7B:24;
  ProgramPart s1 halts_on s1 by FUNCT_4:26,SCMFSA6B:18;
  then
A2: I is_halting_on s0 by SCMFSA7B:def 8;
  assume
  I does_not_destroy a;
  hence thesis by A1,A2,Th89;
end;

theorem Th91:
  for s being State of SCM+FSA, I being parahalting Program of
  SCM+FSA, a being Int-Location st I does_not_destroy a holds IExec(I,s).a = (
  Initialize s).a
proof
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be parahalting Program of SCM+FSA;
  let a be Int-Location;
A1: DataPart Initialize s = DataPart(Initialize s +* (I +*
Start-At( 0,SCM+FSA)
  )) by SCMFSA8A:11;
  assume
  I does_not_destroy a;
  hence
  IExec(I,s).a = Comput(ProgramPart( (Initialize s +* (I +*
  Start-At( 0,SCM+FSA)))), (Initialize s +* (I +*
  Start-At( 0,SCM+FSA))),
  0).a by Th90
    .= (Initialize s +* (I +* Start-At( 0,SCM+FSA))).a by AMI_1:13
    .= (Initialize s).a by A1,SCMFSA6A:38;
end;

theorem Th92:
  for s being State of SCM+FSA, I being keeping_0 Program of
  SCM+FSA st I is_halting_on Initialize s holds IExec(I,s).intloc 0 = 1 & for k
being Element of NAT holds Comput(ProgramPart( (Initialize s +* (I +*
Start-At( 0,SCM+FSA)))), (Initialize s +* (I +*
Start-At( 0,SCM+FSA))),k).intloc 0 = 1
proof
  set a = intloc 0;
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  let I be keeping_0 Program of SCM+FSA;
  set s0 = Initialize s;
  set s1 = s0 +* (I +* Start-At( 0,SCM+FSA));
A1: I +* Start-At( 0,SCM+FSA) c= s1 by FUNCT_4:26;
A2: DataPart s0 = DataPart s1 by SCMFSA8A:11;
A3: now
    let k be Element of NAT;
    thus Comput(ProgramPart( s1), s1,k).a = s1.a by A1,SCMFSA6B:def 4
      .= s0.a by A2,SCMFSA6A:38
      .= 1 by SCMFSA6C:3;
  end;
  not a in A by SCMFSA_2:84;
  then not a in dom s /\ A by XBOOLE_0:def 4;
  then
A5: not a in dom (s | A) by RELAT_1:90;
  assume
  I is_halting_on s0;
  then
A6: ProgramPart s1 halts_on s1 by SCMFSA7B:def 8;
  s +* Initialized I = s1 by SCMFSA8A:13;
  hence IExec(I,s).a = (Result(ProgramPart(s1),s1) +* s | A).a by SCMFSA6B:def
1
    .= (Result(ProgramPart(s1),s1)).a by A5,FUNCT_4:12
    .= Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)).a by A6,AMI_1:
122
    .= 1 by A3;
  let k be Element of NAT;
  thus thesis by A3;
end;

theorem Th93:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does_not_destroy a holds for k being Element of NAT st
IC Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s +* (I +*
Start-At( 0,SCM+FSA))),k) in dom I
holds Comput(ProgramPart(
  (s +* (I +* Start-At( 0,SCM+FSA)))),
  (s +* (I +* Start-At( 0,SCM+FSA))),k + 1).a =
   Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s +* (I +*
Start-At( 0,SCM+FSA))),k).a
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does_not_destroy a;
  set s1 = s +* (I +* Start-At( 0,SCM+FSA));
  let k be Element of NAT;
  assume
A2: IC Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s +* (I +*
Start-At( 0,SCM+FSA))),k) in dom I;
  dom I misses dom Start-At( 0,SCM+FSA) by SF_MASTR:64;
  then
A3: I c= I +* Start-At( 0,SCM+FSA) by FUNCT_4:33;
  set l = IC Comput(ProgramPart( s1), s1,k);
  I +* Start-At( 0,SCM+FSA) c= s1 by FUNCT_4:26;
  then I c= s1 by A3,XBOOLE_1:1;
  then s1.l = I.l by A2,GRFUNC_1:8;
  then s1.l in rng I by A2,FUNCT_1:def 5;
  then
A4: s1.l does_not_destroy a by A1,SCMFSA7B:def 4;
Y:  (ProgramPart Comput(ProgramPart( s1), s1,k))/.IC Comput(ProgramPart( s1),
s1,k)
 = Comput(ProgramPart( s1), s1,k).IC Comput(ProgramPart( s1), s1,k) by
AMI_1:150;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:144;
  thus Comput(ProgramPart( s1), s1,k + 1).a =
  (Following(ProgramPart s1,Comput(ProgramPart(s1),s1
,k))).a by AMI_1:14
    .= Exec(s1.l, Comput(ProgramPart( s1), s1,k)).a by Y,T,AMI_1:54
    .= Comput(ProgramPart( s1), s1,k).a by A4,SCMFSA7B:26;
end;

theorem Th94:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does_not_destroy a holds for m being Element of NAT st
(for n being Element of NAT st n < m holds IC Comput(ProgramPart( (s +* (I +*
Start-At( 0,SCM+FSA)))), (s +* (I +*
Start-At( 0,SCM+FSA))),n) in dom I)
 for n being Element of NAT st n <= m holds
  Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s +* (I +* Start-At
( 0,SCM+FSA))),n).a = s.a
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does_not_destroy a;
  set s1 = s +* (I +* Start-At( 0,SCM+FSA));
  let m be Element of NAT;
  defpred P[Nat] means $1 <= m implies Comput(ProgramPart( s1), s1,$1).a = s.a;
  assume
A2: for n being Element of NAT st n < m holds IC Comput(ProgramPart( (s +* (I
  +* Start-At( 0,SCM+FSA)))), (s +* (I
  +* Start-At( 0,SCM+FSA))),n) in dom I;
A3: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A4: P[k];
A5: k + 0 < k + 1 by XREAL_1:8;
    assume
A6: k + 1 <= m;
    then k < m by A5,XXREAL_0:2;
    then IC Comput(ProgramPart( s1), s1,k) in dom I by A2;
    hence thesis by A1,A4,A6,A5,Th93,XXREAL_0:2;
  end;
  let n be Element of NAT;
  assume
A7: n <= m;
  Comput(ProgramPart( s1), s1,0).a = s1.a by AMI_1:13
    .= s.a by Th28;
  then
A8: P[0];
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A8,A3);
  hence thesis by A7;
end;

theorem Th95:
  for s being State of SCM+FSA, I being good Program of SCM+FSA
  for m being Element of NAT st (for n being Element of NAT st n < m holds IC
  Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s +* (I +* Start-At
( 0,SCM+FSA))),n) in dom I) holds
  for n being
Element of NAT st n <= m holds Comput(ProgramPart( (s +* (I +*
Start-At( 0,SCM+FSA)))), (s +* (I +*
Start-At( 0,SCM+FSA))),n).
  intloc 0 = s.intloc 0
proof
  let s be State of SCM+FSA;
  let I be good Program of SCM+FSA;
  let m be Element of NAT;
  assume
A1: for n being Element of NAT st n < m holds IC Comput(ProgramPart( (s +* (I
  +* Start-At( 0,SCM+FSA)))), (s +* (I
  +* Start-At( 0,SCM+FSA))),n) in dom I;
  let n be Element of NAT;
A2: I does_not_destroy intloc 0 by SCMFSA7B:def 5;
  assume
  n <= m;
  hence thesis by A1,A2,Th94;
end;

theorem Th96:
  for s being State of SCM+FSA, I being good Program of SCM+FSA st
  I is_halting_on Initialize s & I is_closed_on Initialize s holds IExec(I,s).
intloc 0 = 1 & for k being Element of NAT holds Comput(ProgramPart( (Initialize
s +* (
  I +* Start-At( 0,SCM+FSA)))), (Initialize s +* (
  I +* Start-At( 0,SCM+FSA))),k).intloc 0 = 1
proof
  set a = intloc 0;
  let s be State of SCM+FSA;
  set A = NAT;
  let I be good Program of SCM+FSA;
  set s0 = Initialize s;
  set s1 = s0 +* (I +* Start-At( 0,SCM+FSA));
  defpred P[Nat] means for n being Element of NAT st n <= $1 holds
  Comput(ProgramPart( s1), s1,n).intloc 0 = s0.intloc 0;
  assume
  I is_halting_on s0;
  then
A1: ProgramPart s1 halts_on s1 by SCMFSA7B:def 8;
A2: P[0]
  proof
    let n be Element of NAT;
A3: for i being Element of NAT st i < 0 holds IC Comput(ProgramPart( s1), s1,i)
in dom
    I;
    assume
    n <= 0;
    hence thesis by A3,Th95;
  end;
  assume
A4: I is_closed_on s0;
A5: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
    P[k];
    let n be Element of NAT;
    assume
A6: n <= k + 1;
    for i being Element of NAT st i < k + 1 holds IC Comput(ProgramPart( s1),
s1,i) in
    dom I by A4,SCMFSA7B:def 7;
    hence thesis by A6,Th95;
  end;
A7: for k being Element of NAT holds P[k] from NAT_1:sch 1(A2,A5);
A8: now
    let k be Element of NAT;
    thus Comput(ProgramPart( s1), s1,k).intloc 0 = s0.intloc 0 by A7
      .= 1 by SCMFSA6C:3;
  end;
  not a in A by SCMFSA_2:84;
  then not a in dom s /\ A by XBOOLE_0:def 4;
  then
A10: not a in dom (s | A) by RELAT_1:90;
  s +* Initialized I = s1 by SCMFSA8A:13;
  hence IExec(I,s).a = (Result(ProgramPart(s1),s1) +* s | A).a by SCMFSA6B:def
1
    .= (Result(ProgramPart(s1),s1)).a by A10,FUNCT_4:12
    .= Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)).a by A1,AMI_1:
122
    .= 1 by A8;
  thus thesis by A8;
end;

theorem
  for s being State of SCM+FSA, I being good Program of SCM+FSA st I
is_closed_on s holds for k being Element of NAT holds Comput(ProgramPart( (s +*
(I +*
  Start-At( 0,SCM+FSA)))), (s +* (I +*
  Start-At( 0,SCM+FSA))),k).intloc 0 = s.intloc 0
proof
  let s be State of SCM+FSA;
  let I be good Program of SCM+FSA;
  assume
A1: I is_closed_on s;
  let k be Element of NAT;
  I does_not_destroy intloc 0 by SCMFSA7B:def 5;
  hence thesis by A1,SCMFSA7B:27;
end;

theorem Th98:
  for s being State of SCM+FSA, I being keeping_0 parahalting
  Program of SCM+FSA, a being read-write Int-Location st I does_not_destroy a
  holds Comput(ProgramPart( (Initialize s +* (I ';' SubFrom(a,intloc 0) +*
  Start-At( 0,SCM+FSA)))), (Initialize s +* (I ';' SubFrom(a,intloc 0) +*
  Start-At( 0,SCM+FSA))),LifeSpan(ProgramPart(Initialize s +* (I ';'
  SubFrom(a,intloc 0) +*
  Start-At( 0,SCM+FSA))),Initialize s +* (I ';'
  SubFrom(a,intloc 0) +*
  Start-At( 0,SCM+FSA)))).a = s.a - 1
proof
  let s be State of SCM+FSA;
  let I be keeping_0 parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  set s0 = Initialize s;
  set s1 = s0 +* (I ';' SubFrom(a,intloc 0) +* Start-At( 0,SCM+FSA));
A2: not a in dom (I +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  IExec(I ';' SubFrom(a,intloc 0),s).a = Exec(SubFrom(a,intloc 0),IExec(I,
  s)).a by SCMFSA6C:7
    .= IExec(I,s).a - IExec(I,s).intloc 0 by SCMFSA_2:91
    .= IExec(I,s).a - 1 by SCMFSA6B:35
    .= Comput(ProgramPart( (s0 +* (I +* Start-At( 0,SCM+FSA)))), (s0 +* (I +*
Start-At( 0,SCM+FSA))),0).a - 1
    by A1,Th90
    .= (s0 +* (I +* Start-At( 0,SCM+FSA))).a - 1 by AMI_1:13
    .= s0.a - 1 by A2,FUNCT_4:12;
  hence Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)).a = s0.a - 1
by Th88
    .= s.a - 1 by SCMFSA6C:3;
end;

theorem Th99:
  for i being Instruction of SCM+FSA st i does_not_destroy intloc
  0 holds Macro i is good
proof
  let i be Instruction of SCM+FSA;
  assume
  i does_not_destroy intloc 0;
  then Macro i does_not_destroy intloc 0 by Th77;
  hence thesis by SCMFSA7B:def 5;
end;

theorem Th100:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
I is_closed_on s1 & I is_halting_on s1 & DataPart s1 = DataPart s2 holds for k
  being Element of NAT holds Comput(ProgramPart( (s1 +* (I +*
  Start-At( 0,SCM+FSA)))), (s1 +* (I +*
  Start-At( 0,SCM+FSA))),k),
  Comput(ProgramPart( (s2 +* (I +* Start-At( 0,SCM+FSA)))), (s2 +* (I +*
Start-At( 0,SCM+FSA))),k) equal_outside NAT
   & CurInstr(
ProgramPart Comput(ProgramPart( (s1 +* (I +* Start-At( 0,SCM+FSA)))), (s1 +* (I
+* Start-At( 0,SCM+FSA))),k),
    Comput(ProgramPart( (s1 +* (I +* Start-At( 0,SCM+FSA)))), (s1 +* (I +*
Start-At( 0,SCM+FSA))),k)) =
CurInstr(ProgramPart Comput(ProgramPart( (s2 +*
  (I +* Start-At( 0,SCM+FSA)))), (s2 +*
  (I +* Start-At( 0,SCM+FSA))),k),Comput(ProgramPart( (s2 +*
  (I +* Start-At( 0,SCM+FSA)))), (s2 +*
  (I +* Start-At( 0,SCM+FSA))),k))
proof
  let s1,s2 be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  assume
A1: I is_closed_on s1;
  set ss2 = s2 +* (I +* Start-At( 0,SCM+FSA));
  set ss1 = s1 +* (I +* Start-At( 0,SCM+FSA));
  assume
A2: I is_halting_on s1;
  assume
A3: DataPart s1 = DataPart s2;
A4: I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
A5: I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  I +* Start-At( 0,SCM+FSA) c= ss2 by FUNCT_4:26;
  then
A6: I c= ss2 by A4,XBOOLE_1:1;
  I +* Start-At( 0,SCM+FSA) c= ss1 by FUNCT_4:26;
  then
A7: I c= ss1 by A5,XBOOLE_1:1;
  hereby
    let k be Element of NAT;
A8: IC Comput(ProgramPart( ss1), ss1,k) in dom I by A1,SCMFSA7B:def 7;
    I is_closed_on s2 by A1,A2,A3,SCMFSA8B:8;
    then
A9: for m being Element of NAT st m < k holds IC Comput(ProgramPart( ss2), ss2,
m) in
    dom I by SCMFSA7B:def 7;
    ss1,ss2 equal_outside NAT by A3,SCMFSA8B:7;
    hence
    Comput(ProgramPart( ss1), ss1,k), Comput(ProgramPart( ss2), ss2,k)
equal_outside NAT by A7,A6,A9,SCMFSA6B:21;
    then
A10: IC Comput(ProgramPart( ss1), ss1,k) = IC Comput(ProgramPart( ss2), ss2,k)
by AMI_1:121;
    I is_closed_on s2 by A1,A2,A3,SCMFSA8B:8;
    then
A11: IC Comput(ProgramPart( ss2), ss2,k) in dom I by SCMFSA7B:def 7;
Y:  (ProgramPart Comput(ProgramPart(ss2),ss2,k))/.IC Comput(ProgramPart(ss2),
ss2,k)
 = Comput(ProgramPart(ss2),ss2,k).IC Comput(ProgramPart(ss2),ss2,k) by
AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(ss1),ss1,k))/.IC Comput(ProgramPart(ss1),
ss1,k)
 = Comput(ProgramPart(ss1),ss1,k).IC Comput(ProgramPart(ss1),ss1,k) by
AMI_1:150;
    thus CurInstr(ProgramPart Comput(ProgramPart(ss2),ss2,k),Comput(ProgramPart
(ss2),ss2,k))
     = ss2.IC Comput(ProgramPart( ss2), ss2,k) by Y,AMI_1:54
      .= I.IC Comput(ProgramPart( ss2), ss2,k) by A6,A11,GRFUNC_1:8
      .= ss1.IC Comput(ProgramPart( ss1), ss1,k) by A7,A10,A8,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(ss1),ss1,k),Comput(ProgramPart
(ss1),ss1,k))
       by Z,AMI_1:54;
  end;
end;

theorem Th101:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
  I is_closed_on s1 & I is_halting_on s1 & DataPart s1 = DataPart s2 holds
  LifeSpan(ProgramPart(s1 +* (I +* Start-At( 0,SCM+FSA))),s1 +* (I +* Start-At(
0,SCM+FSA))) =
  LifeSpan(ProgramPart(s2 +* (I +* Start-At( 0,SCM+FSA))),s2 +* (I +* Start-At(
0,SCM+FSA))) &
  Result(ProgramPart(s1 +* (I +* Start-At( 0,SCM+FSA))),s1 +* (I +* Start-At( 0
,SCM+FSA))),
  Result(ProgramPart(s2 +* (I +*
  Start-At( 0,SCM+FSA))),s2 +* (I +*
  Start-At( 0,SCM+FSA))) equal_outside NAT
proof
  let s1,s2 be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  assume
A1: I is_closed_on s1;
  set ss2 = s2 +* (I +* Start-At( 0,SCM+FSA));
  set ss1 = s1 +* (I +* Start-At( 0,SCM+FSA));
  assume
A2: I is_halting_on s1;
  then
A3: ProgramPart ss1 halts_on ss1 by SCMFSA7B:def 8;
  then
A4: Result(ProgramPart(ss1),ss1) = Comput(ProgramPart( ss1), ss1,LifeSpan(
ProgramPart(ss1),ss1)) by AMI_1:122;
  assume
A5: DataPart s1 = DataPart s2;
  then I is_halting_on s2 by A1,A2,SCMFSA8B:8;
  then
A6: ProgramPart ss2 halts_on ss2 by SCMFSA7B:def 8;
A7: now
    let l be Element of NAT;
TX2: ProgramPart ss2 = ProgramPart Comput(ProgramPart(ss2),ss2,l)
by AMI_1:144;
TX1: ProgramPart ss1 = ProgramPart Comput(ProgramPart(ss1),ss1,l)
by AMI_1:144;
    assume
A8: CurInstr(ProgramPart ss2,Comput(ProgramPart(ss2),ss2,l)) = halt SCM+FSA;
    CurInstr(ProgramPart ss1,Comput(ProgramPart(ss1),ss1,l))
     = CurInstr(ProgramPart (ss2),Comput(ProgramPart(ss2),ss2,l))
     by A1,A2,A5,Th100,TX1,TX2;
    hence LifeSpan(ProgramPart(ss1),ss1) <= l by A3,A8,AMI_1:def 46;
  end;
TX2: ProgramPart ss2 = ProgramPart
Comput(ProgramPart(ss2),ss2,LifeSpan(ProgramPart(ss1),
ss1))
by AMI_1:144;
TX1: ProgramPart ss1 = ProgramPart
Comput(ProgramPart(ss1),ss1,LifeSpan(ProgramPart(ss1)
,ss1))
by AMI_1:144;
  CurInstr(ProgramPart ss2,
  Comput(ProgramPart(ss2),ss2,LifeSpan(ProgramPart(ss1),ss1)))
   = CurInstr(ProgramPart ss1,
   Comput(ProgramPart(ss1),ss1,LifeSpan(ProgramPart(ss1),ss1)))
    by A1,A2,A5,Th100,TX1,TX2
    .= halt SCM+FSA by A3,AMI_1:def 46;
  hence LifeSpan(ProgramPart(ss1),ss1) = LifeSpan(ProgramPart(ss2),ss2) by A7,
A6,AMI_1:def 46;
  then Result(ProgramPart(ss2),ss2) = Comput(ProgramPart( ss2), ss2,LifeSpan(
ProgramPart(ss1),ss1)) by A6,AMI_1:122
;
  hence thesis by A1,A2,A5,A4,Th100;
end;

canceled;

theorem Th103:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
  I is_closed_on s1 & I is_halting_on s1 &
  I +* Start-At( 0,SCM+FSA) c= s1 & I +*
  Start-At( 0,SCM+FSA) c= s2 & ex k being Element of NAT
  st Comput(ProgramPart( s1), s1,k),s2
  equal_outside NAT holds Result(ProgramPart(s1),s1),Result(ProgramPart(s2),s2)
equal_outside NAT
proof
  let s1,s2 be State of SCM+FSA;
  set A = NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  assume
A1: I is_closed_on s1;
  assume
A2: I is_halting_on s1;
  assume
A3: I +* Start-At( 0,SCM+FSA) c= s1;
  then
A4: s1 = s1 +* (I +* Start-At( 0,SCM+FSA)) by FUNCT_4:79;
  then
A5: ProgramPart s1 halts_on s1 by A2,SCMFSA7B:def 8;
  then consider n being Element of NAT such that
A6: CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,n)) = halt SCM+FSA
 by AMI_1:146;
TX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,n)
by AMI_1:144;
  assume
  I +* Start-At( 0,SCM+FSA) c= s2;
  then
A7: s2 = s2 +* (I +* Start-At( 0,SCM+FSA)) by FUNCT_4:79;
  given k being Element of NAT such that
A8: Comput(ProgramPart( s1), s1,k),s2 equal_outside A;
  set s3 = Comput(ProgramPart( s1), s1,k);
A9: IC SCM+FSA in dom s3 by AMI_1:94;
  I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then I c= s1 by A3,XBOOLE_1:1;
  then
A10: I c= s3 by AMI_1:86;
  IC s3 = IC s2 by A8,SCMFSA8A:6
    .= IC (s2 +* I +* Start-At( 0,SCM+FSA)) by A7,FUNCT_4:15
    .=  0 by AMI_1:111;
  then IC SCM+FSA .-->  0 c= s3 by A9,FUNCOP_1:88;
  then I +* Start-At( 0,SCM+FSA) c= s3 by A10,FUNCT_4:92;
  then
A11: s3 = s3 +* (I +* Start-At( 0,SCM+FSA)) by FUNCT_4:79;
A12: now
    let n be Element of NAT;
T: ProgramPart s3 = ProgramPart s1
by AMI_1:144;
    IC Comput(ProgramPart( s1), s3,n) = IC Comput(ProgramPart( s1), s1,k + n)
by AMI_1:51;
    hence IC Comput(ProgramPart( s3), s3,n) in dom I by A1,A4,T,SCMFSA7B:def 7;
  end;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),
s1,k)
by AMI_1:144;
x: Comput(ProgramPart(s1),s1,n+k)
 = Comput(ProgramPart(s1),Comput(ProgramPart(s1),s1,k),n) by AMI_1:51;
  n <= n + k by NAT_1:11;
 then
yy:  Comput(ProgramPart(s1),s1,n+k) = Comput(ProgramPart(s1),s1,n) by A6,TX,
AMI_1:52;

TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,n)
by AMI_1:144;
TX1k: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k+n)
by AMI_1:144;
  CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,n))
   = CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,k+n)) by x,T
    .= CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,n))
     by yy;
  then ProgramPart s3 halts_on s3 by A6,AMI_1:146;
  then
A13: I is_halting_on s3 by A11,SCMFSA7B:def 8;
A14: DataPart s3 = DataPart s2 by A8,SCMFSA8A:6;
TX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:144;
  consider k being Element of NAT such that
A15: CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,k))
 = halt SCM+FSA by A5,AMI_1:146;
TTX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:144;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,k))/.IC Comput(ProgramPart(s1),s1,k)
 = Comput(ProgramPart(s1),s1,k).IC Comput(ProgramPart(s1),s1,k) by AMI_1:150;
A16: s1.IC Comput(ProgramPart( s1), s1,k)
      = Comput(ProgramPart(s1),s1,k).IC Comput(ProgramPart(s1),s1,k)
         by A15,Y,AMI_1:54,TX
     .= (ProgramPart Comput(ProgramPart(s1),s1,k))/.
           IC Comput(ProgramPart(s1),s1,k)
         by A15,Y,AMI_1:54,TX
     .= (ProgramPart s1)/.IC Comput(ProgramPart(s1),s1,k)
         by A15,Y,AMI_1:54,TTX
     .= CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,k))
     .= halt SCM+FSA
 by A15,Y,AMI_1:54,TX;
  I is_closed_on s3 by A11,A12,SCMFSA7B:def 7;
  then Result(ProgramPart(s3),s3),Result(ProgramPart(s2),s2) equal_outside A by
A7,A14,A11,A13,Th101;
  hence thesis by A16,AMI_1:57,TX3,TX;
end;

begin :: loop

registration
  let I be Program of SCM+FSA, k be Element of NAT;
  cluster IncAddr(I,k) -> initial NAT-defined;
  correctness
  proof
    now
      let m,n be Nat;
      assume
A1:   n in dom IncAddr(I,k);
A2:   dom IncAddr(I,k) = dom I by SCMFSA_4:def 6;
      assume
      m < n;
      hence m in dom IncAddr(I,k) by A1,A2,AFINSQ_1:def 13;
    end;
    hence thesis by AFINSQ_1:def 13;
  end;
end;

definition
  let I be Program of SCM+FSA;
  canceled 3;
  func loop I -> halt-free Program of SCM+FSA equals
  Directed(I, 0);
  coherence;
end;

canceled;

theorem
  for I being Program of SCM+FSA, a being Int-Location holds I
  does_not_destroy a implies loop I does_not_destroy a by SCMFSA8A:27;

registration
  let I be good Program of SCM+FSA;
  cluster loop I -> good;
  correctness;
end;

canceled;

theorem Th107:
  for I being Program of SCM+FSA holds not halt SCM+FSA in rng
  loop I
proof
  let I be Program of SCM+FSA;
  halt SCM+FSA <> goto  0 by SCMFSA_2:47,124;
  hence thesis by FUNCT_4:106;
end;

canceled;

theorem Th109:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
is_closed_on s & I is_halting_on s for m being Element of NAT st m <= LifeSpan(
ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +* Start-At( 0,SCM+FSA)))
holds Comput(ProgramPart( (s +* (I +*
Start-At( 0,SCM+FSA)))), (s +* (I +*
Start-At( 0,SCM+FSA))),m), Comput(ProgramPart((s +* (loop I +*
Start-At( 0,SCM+FSA)))),(s +* (loop I +*
Start-At( 0,SCM+FSA))),m)
  equal_outside NAT
proof
  let s be State of SCM+FSA;
  set A = NAT;
  let I be Program of SCM+FSA;
  set s1 = s +* (I +* Start-At( 0,SCM+FSA));
  set s2 = s +* (loop I +* Start-At( 0,SCM+FSA));
  assume
A1: I is_closed_on s;
  defpred X[Nat] means $1 <= LifeSpan(ProgramPart(s1),s1) implies Comput(
ProgramPart( s1), s1,$1
  ), Comput(ProgramPart( s2), s2,$1) equal_outside A;
  assume
  I is_halting_on s;
  then
A2: ProgramPart s1 halts_on s1 by SCMFSA7B:def 8;
A3: for m being Element of NAT st X[m] holds X[m+1]
  proof
A4: loop I c= loop I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
A5: I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
    let m be Element of NAT;
    assume
A6: m <= LifeSpan(ProgramPart(s1),s1) implies Comput(ProgramPart(s1),s1,m),
Comput(ProgramPart(s2
),s2,m)
    equal_outside A;
    loop I +* Start-At( 0,SCM+FSA) c= s2 by FUNCT_4:26;
    then loop I c= s2 by A4,XBOOLE_1:1;
    then
A7: loop I c= Comput(ProgramPart(s2),s2,m) by AMI_1:81;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m)
by AMI_1:144;
A8: Comput(ProgramPart(s1),s1,m+1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,m)
)
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(
ProgramPart(s1),s1,m)),
      Comput(ProgramPart(s1),s1,m)) by T;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,m)
by AMI_1:144;
A9: Comput(ProgramPart(s2),s2,m+1) =
Following(ProgramPart s2,Comput(ProgramPart(s2),s2,m)
)
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,m),Comput(
ProgramPart(s2),s2,m)),
      Comput(ProgramPart(s2),s2,m)) by T;
A10: IC Comput(ProgramPart(s1),s1,m) in dom I by A1,SCMFSA7B:def 7;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,m))/.IC Comput(ProgramPart(s1),s1,m)
 = Comput(ProgramPart(s1),s1,m).IC Comput(ProgramPart(s1),s1,m) by AMI_1:150;
TX1: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m)
by AMI_1:144;
    I +* Start-At( 0,SCM+FSA) c= s1 by FUNCT_4:26;
    then I c= s1 by A5,XBOOLE_1:1;
    then I c= Comput(ProgramPart(s1),s1,m) by AMI_1:81;
    then
A11: CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,m))
 = I.IC Comput(ProgramPart(s1),s1,m) by A10,Y,GRFUNC_1:8,TX1;
    assume
A12: m + 1 <= LifeSpan(ProgramPart(s1),s1);
    then
     m < LifeSpan(ProgramPart(s1),s1) by NAT_1:13;
    then I.IC Comput(ProgramPart(s1),s1,m) <> halt SCM+FSA by A2,A11,
AMI_1:def 46;
    then
A13: I.IC Comput(ProgramPart(s1),s1,m) = (loop I).IC Comput(ProgramPart(s1),s1,
m) by FUNCT_4:111;
Z:  (ProgramPart Comput(ProgramPart(s2),s2,m))/.IC Comput(ProgramPart(s2),s2,m)
 = Comput(ProgramPart(s2),s2,m).IC Comput(ProgramPart(s2),s2,m) by AMI_1:150;
    IC Comput(ProgramPart(s1),s1,m) in dom loop I by A10,FUNCT_4:105;
    then CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(ProgramPart(
s1),s1,m))
     = Comput(ProgramPart(s2),s2,m).IC Comput(ProgramPart(s1),s1,m)
    by A7,A11,A13,GRFUNC_1:8,TX1
      .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,m),Comput(ProgramPart(
s2),s2,m))
       by A6,A12,Z,AMI_1:121,NAT_1:13;
    hence thesis by A6,A12,A8,A9,NAT_1:13,SCMFSA6A:32;
  end;
A14: X[0]
  proof
    assume
    0 <= LifeSpan(ProgramPart(s1),s1);
A15: s,s +* loop I equal_outside A by AMI_1:120;
    s +* I,s equal_outside A by AMI_1:120,FUNCT_7:28;
    then s +* I,s +* loop I equal_outside A by A15,FUNCT_7:29;
    then s +* I +* Start-At( 0,SCM+FSA),s +* loop I +*
    Start-At( 0,SCM+FSA)
    equal_outside A by FUNCT_7:106;
    then s +* I +* Start-At( 0,SCM+FSA),s2 equal_outside A by FUNCT_4:15;
    then s1,s2 equal_outside A by FUNCT_4:15;
    then s1, Comput(ProgramPart( s2), s2,0) equal_outside A by AMI_1:13;
    hence thesis by AMI_1:13;
  end;
  thus for m being Element of NAT holds X[m] from NAT_1:sch 1(A14, A3);
end;

theorem Th110:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
is_closed_on s & I is_halting_on s for m being Element of NAT st m < LifeSpan(
ProgramPart(
s +* (I +* Start-At( 0,SCM+FSA))),
s +* (I +* Start-At( 0,SCM+FSA)))
holds CurInstr(ProgramPart Comput(ProgramPart( (s +* (I +*
Start-At( 0,SCM+FSA)))), (s +* (I +*
Start-At( 0,SCM+FSA))),m),
   Comput(ProgramPart( (s +* (I +*
Start-At( 0,SCM+FSA)))), (s +* (I +*
Start-At( 0,SCM+FSA))),m))
 = CurInstr(ProgramPart Comput(ProgramPart((s +* (loop I +*
  Start-At( 0,SCM+FSA)))),(s +* (loop I +*
  Start-At( 0,SCM+FSA))),m),
   Comput(ProgramPart((s +* (loop I +*
  Start-At( 0,SCM+FSA)))),(s +* (loop I +*
  Start-At( 0,SCM+FSA))),m))
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* (I +* Start-At( 0,SCM+FSA));
  set s2 = s +* (loop I +* Start-At( 0,SCM+FSA));
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s;
  let m be Element of NAT;
A3: IC Comput(ProgramPart(s1),s1,m) in dom I by A1,SCMFSA7B:def 7;
  then
A4: IC Comput(ProgramPart(s1),s1,m) in dom loop I by FUNCT_4:105;
A5: I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,m))/.IC Comput(ProgramPart(s1),s1,m)
 = Comput(ProgramPart(s1),s1,m).IC Comput(ProgramPart(s1),s1,m) by AMI_1:150;
TX1: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m)
by AMI_1:144;
  I +* Start-At( 0,SCM+FSA) c= s1 by FUNCT_4:26;
  then I c= s1 by A5,XBOOLE_1:1;
  then I c= Comput(ProgramPart(s1),s1,m) by AMI_1:81;
  then
A6: CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,m))
 = I.IC Comput(ProgramPart(s1),s1,m) by A3,Y,GRFUNC_1:8,TX1;
A7: loop I c= loop I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  loop I +* Start-At( 0,SCM+FSA) c= s2 by FUNCT_4:26;
  then loop I c= s2 by A7,XBOOLE_1:1;
  then
A8: loop I c= Comput(ProgramPart(s2),s2,m) by AMI_1:81;
  assume
A9: m < LifeSpan(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +*
Start-At( 0,SCM+FSA)));
Z:  (ProgramPart Comput(ProgramPart(s2),s2,m))/.IC Comput(ProgramPart(s2),s2,m)
 = Comput(ProgramPart(s2),s2,m).IC Comput(ProgramPart(s2),s2,m) by AMI_1:150;
  ProgramPart s1 halts_on s1 by A2,SCMFSA7B:def 8;
  then I.IC Comput(ProgramPart(s1),s1,m) <> halt SCM+FSA by A9,A6,AMI_1:def 46;
  then I.IC Comput(ProgramPart(s1),s1,m) = (loop I).IC Comput(ProgramPart(s1),
s1,m) by FUNCT_4:111;
  hence CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(ProgramPart(s1
),s1,m))
   = Comput(ProgramPart(s2),s2,m).IC Comput(ProgramPart(s1),s1,m) by A8,A4,A6,
GRFUNC_1:8,TX1
    .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,m),Comput(ProgramPart(s2)
,s2,m))
     by A1,A2,A9,Th109,Z,AMI_1:121;
end;

Lm2: for s being State of SCM+FSA, I being Program of SCM+FSA st I
is_closed_on s & I is_halting_on s holds
 (CurInstr(ProgramPart
 ( (s +* (loop I
+* Start-At( 0,SCM+FSA)))),
    Comput(ProgramPart( (s +* (loop I
+* Start-At( 0,SCM+FSA)))), (s +* (loop I
+* Start-At( 0,SCM+FSA))), LifeSpan(ProgramPart(s +* (I +*
Start-At( 0,SCM+FSA))),s +* (I +*
Start-At( 0,SCM+FSA))))) = goto
0 & for m being Element of NAT st m <= LifeSpan(ProgramPart(s +* (I +*
Start-At( 0,SCM+FSA))),s +* (I +*
Start-At( 0,SCM+FSA)))
holds CurInstr(
 ProgramPart Comput(ProgramPart( (s +* (loop I +* Start-At( 0,SCM+FSA)))), (s
+* (loop I +* Start-At( 0,SCM+FSA))),m),
    Comput(ProgramPart( (s +* (loop I +* Start-At( 0,SCM+FSA)))), (s +* (loop I
+* Start-At( 0,SCM+FSA))),m))
 <> halt
SCM+FSA)

proof

A1: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:71;

  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* (I +* Start-At( 0,SCM+FSA));
  set s2 = s +* (loop I +* Start-At( 0,SCM+FSA));
  assume that
A2: I is_closed_on s and
A3: I is_halting_on s;
  set k = LifeSpan(ProgramPart(s1),s1);
A4: not IC Comput(ProgramPart(s1),s1,k) in dom Start-At( 0,SCM+FSA) by
AMI_1:137;
A5: IC Comput(ProgramPart(s1),s1,k) in dom I by A2,SCMFSA7B:def 7;
  then
A6: IC Comput(ProgramPart(s1),s1,k) in dom (I +* Start-At( 0,SCM+FSA))
by FUNCT_4:13;
  dom loop I = dom I by FUNCT_4:105;

  then
A7: IC Comput(ProgramPart(s1),s1,k) in dom (loop I +* Start-At( 0,SCM+FSA))
by A5,FUNCT_4:13;

TX1: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:144;
A8: ProgramPart s1 halts_on s1 by A3,SCMFSA7B:def 8;
  then
A9: CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,k))
 = halt SCM+FSA by AMI_1:def 46;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,k))/.IC Comput(ProgramPart(s1),s1,k)
 = Comput(ProgramPart(s1),s1,k).IC Comput(ProgramPart(s1),s1,k) by AMI_1:150;
TX1: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:144;
A10: CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,k))
 = s1.IC Comput(ProgramPart(s1),s1,k) by Y,AMI_1:54,TX1
    .= (I +* Start-At( 0,SCM+FSA)).IC Comput(ProgramPart(s1),s1,k) by A6,
FUNCT_4:14
    .= I.IC Comput(ProgramPart(s1),s1,k) by A4,FUNCT_4:12;
A11: rng I c= the Instructions of SCM+FSA by AMI_1:118;

Y:  (ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)))/.IC
Comput(ProgramPart
(s2),s2,LifeSpan(ProgramPart(s1),s1))
 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)).IC Comput(
ProgramPart(s2),s2,LifeSpan
(ProgramPart s1,s1)) by AMI_1:150;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1
))
by AMI_1:144;
  thus
A12: CurInstr(ProgramPart s2,
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1))) = Comput(ProgramPart(
s2),s2,k).IC
  Comput(ProgramPart(s1),s1,k) by A2,A3,Th109,Y,AMI_1:121,TX2

    .= s2.IC Comput(ProgramPart(s1),s1,k) by AMI_1:54
    .= (loop I +* Start-At( 0,SCM+FSA)).IC Comput(ProgramPart(s1),s1,k)
    by A7,FUNCT_4:14
    .= (loop I).IC Comput(ProgramPart(s1),s1,k) by A4,FUNCT_4:12

    .= (((id the Instructions of SCM+FSA)+*(halt SCM+FSA,goto  0))*I )
  .IC Comput(ProgramPart(s1),s1,k) by A11,FUNCT_7:118

    .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA, goto  0)).
  halt SCM+FSA by A9,A5,A10,FUNCT_1:23,TX2,TX1

    .= goto  0 by A1,FUNCT_7:33;
  let m be Element of NAT;
  assume
A13: m <= LifeSpan(ProgramPart(s1),s1);
TX1: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m)
by AMI_1:144;
  per cases by A13,XXREAL_0:1;
  suppose
A14: m < LifeSpan(ProgramPart(s1),s1);
    then CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,m))
     <> halt SCM+FSA by A8,AMI_1:def 46;
    hence thesis by A2,A3,A14,Th110,TX1;
  end;
  suppose
    m = LifeSpan(ProgramPart(s1),s1);
    hence thesis by A12,SCMFSA_2:47,124,TX1,TX2;
  end;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
is_closed_on s & I is_halting_on s for m being Element of NAT st m <= LifeSpan(
ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +* Start-At( 0,SCM+FSA)))
  holds CurInstr(ProgramPart Comput(ProgramPart(s +* (loop I +*
  Start-At( 0,SCM+FSA))),s +* (loop I +*
  Start-At( 0,SCM+FSA)),m),
  Comput(ProgramPart(s +* (loop I +*
  Start-At( 0,SCM+FSA))),s +* (loop I +*
  Start-At( 0,SCM+FSA)),m)) <> halt SCM+FSA by Lm2;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
is_closed_on s & I is_halting_on s holds
 CurInstr(ProgramPart
 (s +* (loop I +*
Start-At( 0,SCM+FSA))),
  Comput(ProgramPart( (s +* (loop I +*
Start-At( 0,SCM+FSA)))), (s +* (loop I +*
Start-At( 0,SCM+FSA))), LifeSpan(ProgramPart(s +* (I +*
Start-At( 0,SCM+FSA))),s +* (I +*
Start-At( 0,SCM+FSA)))))
 = goto  0
  by Lm2;

theorem Th113:
  for s being State of SCM+FSA, I being paraclosed Program of
  SCM+FSA st I +* Start-At( 0,SCM+FSA) c= s & ProgramPart s halts_on s
   for m being Element of
  NAT st m <= LifeSpan(ProgramPart(s),s) holds Comput(ProgramPart( s), s,m),
Comput(ProgramPart
( (s +* loop I)), (s +* loop I),m)
  equal_outside NAT
proof
  let s be State of SCM+FSA;
  let I be paraclosed Program of SCM+FSA;
  assume
A1: I +* Start-At( 0,SCM+FSA) c= s;
  defpred X[Nat] means $1 <= LifeSpan(ProgramPart(s),s) implies Comput(
ProgramPart( s), s,$1),
  Comput(ProgramPart((s+*loop I)),(s+*loop I),$1) equal_outside NAT;
  assume
A2: ProgramPart s halts_on s;
A3: for m st X[m] holds X[m+1]
  proof
    set sI = s+*loop I;
    let m;
    assume
A4: m <= LifeSpan(ProgramPart(s),s) implies Comput(ProgramPart( s), s,m),
Comput(ProgramPart((s
+*loop I)
    ),(s+*loop I)
    ,m) equal_outside NAT;
A5: IC Comput(ProgramPart(s),s,m) in dom I by A1,SCMFSA6B:def 2;
    then
A6: IC Comput(ProgramPart(s),s,m) in dom loop I by FUNCT_4:105;
Y:  (ProgramPart Comput(ProgramPart(s),s,m))/.IC Comput(ProgramPart(s),s,m)
 = Comput(ProgramPart(s),s,m).IC Comput(ProgramPart(s),s,m) by AMI_1:150;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m)
by AMI_1:144;
    dom I misses dom Start-At( 0,SCM+FSA) by SF_MASTR:64;
    then I c= I +* Start-At( 0,SCM+FSA) by FUNCT_4:33;
    then I c= s by A1,XBOOLE_1:1;
    then I c= Comput(ProgramPart(s),s,m) by AMI_1:81;
    then
A7: CurInstr(ProgramPart s,Comput(ProgramPart(s),s,m))
 = I.IC(Comput(ProgramPart(s),s,m)) by A5,Y,GRFUNC_1:8,TX;
A8: loop I c= Comput(ProgramPart(sI),sI,m) by AMI_1:81,FUNCT_4:26;
T: ProgramPart sI = ProgramPart Comput(ProgramPart(sI),sI,m)
by AMI_1:144;
A9: Comput(ProgramPart(sI),sI,m+1) =
Following(ProgramPart sI,Comput(ProgramPart(sI),sI,m)
)
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(sI),sI,m),Comput(
ProgramPart(sI),sI,m))
      ,Comput(ProgramPart(sI),sI,m)) by T;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m)
by AMI_1:144;
A10: Comput(ProgramPart(s),s,m+1) =
Following(ProgramPart s,Comput(ProgramPart(s),s,m))
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s),s,m),Comput(
ProgramPart(s),s,m))
      ,Comput(ProgramPart(s),s,m)) by T;
Y:  (ProgramPart Comput(ProgramPart(sI),sI,m))/.IC Comput(ProgramPart(sI),sI,m)
 = Comput(ProgramPart(sI),sI,m).IC Comput(ProgramPart(sI),sI,m) by AMI_1:150;
    assume
A11: m+1 <= LifeSpan(ProgramPart(s),s);
    then m < LifeSpan(ProgramPart(s),s) by NAT_1:13;
    then I.IC(Comput(ProgramPart(s),s,m)) <> halt SCM+FSA by A2,A7,AMI_1:def 46
;
    then
CurInstr(ProgramPart Comput(ProgramPart(s),s,m),Comput(ProgramPart(s),s,m))
 = (loop I).IC(Comput(ProgramPart(s),s,m)) by A7,FUNCT_4:111,TX
      .= (Comput(ProgramPart(sI),sI,m)).IC(Comput(ProgramPart(s),s,m)) by A8,A6
,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(sI),sI,m),Comput(ProgramPart(
sI),sI,m))
       by A4,A11,Y,AMI_1:121,NAT_1:13;
    hence thesis by A4,A11,A10,A9,NAT_1:13,SCMFSA6A:32;
  end;
A12: Comput(ProgramPart((s+*loop I)),(s+*loop I),0) = s+*loop I by AMI_1:13;
  Comput(ProgramPart( s), s,0) = s by AMI_1:13;
  then
A13: X[0] by A12,AMI_1:120;
  thus for m being Element of NAT holds X[m] from NAT_1:sch 1(A13, A3);
end;

theorem
  for s being State of SCM+FSA, I being parahalting Program of SCM+FSA
st Initialized I c= s holds for k being Element of NAT st k <= LifeSpan(
ProgramPart(s),s) holds
  CurInstr(ProgramPart Comput(ProgramPart( (s +* loop I)), (s +* loop I),k),
   Comput(ProgramPart( (s +* loop I)), (s +* loop I),k)) <> halt SCM+FSA
proof
  let s be State of SCM+FSA;
  let I be parahalting Program of SCM+FSA;
  set s2 = s +* loop I;
  assume
A1: Initialized I c= s;
  then
A2: I +* Start-At( 0,SCM+FSA) c= s by SCMFSA6B:8;
A3: ProgramPart s halts_on s by A1,AMI_1:def 26;
  hereby
    let k be Element of NAT;
    assume
A4: k <= LifeSpan(ProgramPart(s),s);
    set lk = IC Comput(ProgramPart( s), s,k);
    assume
A5: CurInstr(ProgramPart Comput(ProgramPart( (s +* loop I)), (s +* loop I),k),
 Comput(ProgramPart( (s +* loop I)), (s +* loop I),k)) = halt SCM+FSA;
A6: dom I = dom loop I by FUNCT_4:105;
A7: IC Comput(ProgramPart( s), s,k) in dom I by A2,SCMFSA6B:def 2;
    then
A8: (loop I).lk in rng loop I by A6,FUNCT_1:def 5;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by AMI_1:150;
    CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(s2),s2
,k))
     = Comput(ProgramPart(s2),s2,k).lk by A3,A2,A4,Th113,Y,AMI_1:121
      .= s2.lk by AMI_1:54
      .= (loop I).lk by A7,A6,FUNCT_4:14;
    hence contradiction by A5,A8,Th107;
  end;
end;

begin :: Times

definition
  let a be Int-Location;
  let I be Program of SCM+FSA;
  func Times(a,I) -> Program of SCM+FSA equals
  if>0(a,loop if=0(a,Goto
  2,I ';' SubFrom(a,intloc 0)), Stop SCM+FSA);
  correctness;
end;

theorem Th115:
  for I being good Program of SCM+FSA, a being read-write
  Int-Location holds if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) is good
proof
  let I be good Program of SCM+FSA;
  let a be read-write Int-Location;
  reconsider J3 = Macro SubFrom(a,intloc 0) as good Program of SCM+FSA by Th99,
SCMFSA7B:14;
  I ';' SubFrom(a,intloc 0) = I ';' J3;
  then reconsider I1 = I ';' SubFrom(a,intloc 0) as good Program of SCM+FSA;
  reconsider J1 = Macro (a =0_goto  (card I1 + 3)) as good Program of
  SCM+FSA by Th99,SCMFSA7B:18;
  if=0(a,Goto  2,I1) = (a =0_goto  (card I1 + 3) ';' I1 ';'
  Goto  (card Goto  2 + 1)) ';' Goto  2 ';' Stop SCM+FSA by SCMFSA8B:def 1
    .= J1 ';' I1 ';' Goto  (card Goto  2 + 1) ';' Goto  2
  ';' Stop SCM+FSA;
  hence thesis;
end;

theorem Th116:
  for I,J being Program of SCM+FSA,a being Int-Location holds
if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)).  (card (I ';' SubFrom(a,
  intloc 0)) + 3) = goto  (card (I ';' SubFrom(a,intloc 0)) + 5)
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  set I1 = I ';' SubFrom(a,intloc 0);
  set J3 = a =0_goto  (card I1 + 3) ';' I1 ';' Goto  (card Goto
   2 + 1);
  set J4 = (a =0_goto  (card I1 + 3) ';' I1 ';' Goto  (card Goto
   2 + 1)) ';' Goto  2;
A1: card Goto  (card Goto  2 + 1) = 1 by SCMFSA8A:29;
  card (a =0_goto  (card I1 + 3) ';' I1) = card Macro (a =0_goto
   (card I1 + 3)) + card I1 by SCMFSA6A:61
    .= 2 + card I1 by SCMFSA7B:6;
  then
A2: card J3 = card I1 + 2 + 1 by A1,SCMFSA6A:61
    .= card I1 + (2 + 1);
  then card I1 + (2 + 1) -' card J3 = 0 by XREAL_1:234;
  then
A3: goto  2 = (Goto  2). (card I1 + (2 + 1) -' card J3 )
  by SCMFSA8A:47;
A4: card Goto  2 = 1 by SCMFSA8A:29;
  then card I1 + (2 + 1) < card J3 + card Goto  2 by A2,NAT_1:13;
  then
A5: J4. (card I1 + (2 + 1)) = IncAddr(goto  2,card J3) by A2,A3,Th13
    .= goto ( 2 + (card I1 + (2 + 1))) by A2,SCMFSA_4:14
    .= goto  (card I1 + (2 + 3));
A6: InsCode goto  (card I1 + 5) = 6 by SCMFSA_2:47;
  card J4 = card I1 + (2 + 1) + 1 by A2,A4,SCMFSA6A:61
    .= card I1 + (2 + 1 + 1);
  then card J4 = card I1 + 3 + 1;
  then card I1 + 3 < card J4 by NAT_1:13;
  then
A7:  (card I1 + 3) in dom J4 by AFINSQ_1:70;
  then
  (J4 ';' Stop SCM+FSA). (card I1 + 3) = (Directed J4). (card
  I1 + 3) by SCMFSA8A:28
    .= goto  (card I1 + 5) by A5,A6,A7,SCMFSA8A:30,SCMFSA_2:124;
  hence thesis by SCMFSA8B:def 1;
end;

theorem Th117:
  for s being State of SCM+FSA, I being good parahalting Program
of SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.intloc
  0 = 1 & s.a > 0 holds loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s
proof
  let s be State of SCM+FSA;
  set A = NAT;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  set P = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
  reconsider I1 = I ';' SubFrom(a,intloc 0) as parahalting Program of SCM+FSA;
  set i = a =0_goto  (card I1 + 3);
  defpred P[Nat] means for s being State of SCM+FSA st s.intloc 0 =
1 & s.a = $1 & s.a > 0 holds ( Comput(ProgramPart( (s +* (loop P +*
Start-At( 0,SCM+FSA))
)), (s +* (loop P +*
Start-At( 0,SCM+FSA))
), (LifeSpan(ProgramPart(s +* (P +* Start-At( 0,SCM+FSA))),s +* (P +* Start-At(
0,SCM+FSA))) + 1))).a = s.a - 1
 & ( Comput(ProgramPart( (s +* (loop P +* Start-At( 0,SCM+FSA)))), (s +* (loop
P +* Start-At( 0,SCM+FSA))),
(LifeSpan(ProgramPart(s +* (P +* Start-At( 0,SCM+FSA)
  )),s +* (P +* Start-At( 0,SCM+FSA)
  )) + 1))).intloc 0 = 1 & ex k being Element of NAT st IC Comput(ProgramPart(
(s +* (
loop P +* Start-At( 0,SCM+FSA)))), (s +* (
loop P +* Start-At( 0,SCM+FSA))),k) =  card ProgramPart loop P &
for n being
Element of NAT st n < k holds IC Comput(ProgramPart( (s +* (loop P +*
  Start-At( 0,SCM+FSA)))), (s +* (loop P +*
  Start-At( 0,SCM+FSA))),n) in dom loop P;
  assume
A1: I does_not_destroy a;
A2: for k being Element of NAT holds P[k] implies P[k + 1]
  proof
    let k be Element of NAT;
    assume
A3: P[k];
    let ss be State of SCM+FSA;
    assume
A4: ss.intloc 0 = 1;
    set s2 = ss +* (loop P +* Start-At( 0,SCM+FSA));
    set s1 = ss +* (P +* Start-At( 0,SCM+FSA));
    assume
A5: ss.a = k + 1;
    set s3 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1) + 1);
    assume
A6: ss.a > 0;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(
s1),s1))
by AMI_1:144;
A7: Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1) =
Following(ProgramPart s2,
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)))
    by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(
ProgramPart(s1),s1)),
      Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1))), Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart s1,
    s1))) by T;
A8: I1 is_halting_on ss by SCMFSA7B:25;
A9: I1 is_closed_on ss by SCMFSA7B:24;
    then
A10: P is_closed_on ss by A6,A8,SCMFSA8B:18;
A11: P is_halting_on ss by A6,A9,A8,SCMFSA8B:18;
A12: P is_closed_on ss by A6,A9,A8,SCMFSA8B:18;
    then
A13: IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1) = Exec(goto
0,Comput(
ProgramPart(s2),s2,
    LifeSpan(ProgramPart(s1),s1))).IC SCM+FSA by A11,A7,Lm2,T
      .=  0 by SCMFSA_2:95;
A14: Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1) = Exec(goto  0,
Comput(ProgramPart
(s2),s2,
    LifeSpan(ProgramPart(s1),s1))) by A12,A11,A7,Lm2,T;
A15: now
A16:  I1 is_halting_on Initialize ss by SCMFSA7B:25;
      I1 is_closed_on Initialize ss by SCMFSA7B:24;
      then
      IExec(P,ss) = IExec(I1,ss) +* Start-At( (card Goto  2 +
      card I1 + 3),SCM+FSA) by A6,A16,SCMFSA8B:19;
      then
A17:  IExec(P,ss).a = IExec(I1,ss).a by SCMFSA_3:11;
A18:  card P = card Goto  2 + card I1 + 4 by SCMFSA8B:14
        .= card I1 + 1 + 4 by SCMFSA8A:29
        .= card I1 + 3 + 2;
A19:  card loop P = card dom loop P by CARD_1:104
        .= card dom P by FUNCT_4:105
        .= card P by CARD_1:104;
      hereby
        thus  0 in dom loop P by A19,A18,AFINSQ_1:70;
        card I1 + 3 + (1 + 1) = (card I1 + 3 + 1) + 1;
        then card I1 + 3 + 1 < card P by A18,NAT_1:13;
        then card I1 + 3 < card loop P by A19,NAT_1:13;
        hence  (card I1 + 3) in dom loop P by AFINSQ_1:70;
      end;
A20:  dom P misses dom Start-At( 0,SCM+FSA) by SF_MASTR:64;
      thus intloc 0 in dom ss by SCMFSA_2:66;
      then
A21:  ss +* (intloc 0 .--> 1) = ss by A4,FUNCT_7:111;
A22:  I1 is_closed_on Initialize ss by SCMFSA7B:24;
A23:  I1 is_halting_on Initialize ss by SCMFSA7B:25;
A24:  (Initialize ss).a > 0 by A6,SCMFSA6C:3;
      then
A25:  P is_halting_on Initialize ss by A22,A23,SCMFSA8B:18;
A26:  P is_closed_on Initialize ss by A24,A22,A23,SCMFSA8B:18;
      consider Is being State of SCM+FSA such that
A27:  Is = Initialize ss +* (P +* Start-At( 0,SCM+FSA));
      Initialize ss = ss +* (intloc 0 .--> 1) +* Start-At( 0,SCM+FSA) by
SCMFSA6C:def 3;
      then
A28:  Initialize ss +* (P +* Start-At( 0,SCM+FSA)) =
ss +* Start-At( 0,SCM+FSA)
      +* (Start-At( 0,SCM+FSA) +* P) by A21,A20,FUNCT_4:36
        .= ss +* Start-At( 0,SCM+FSA) +* Start-At( 0,SCM+FSA) +* P
         by FUNCT_4:15
        .= ss +* (Start-At( 0,SCM+FSA) +*
        Start-At( 0,SCM+FSA)) +* P by FUNCT_4:15
        .= ss +* (Start-At( 0,SCM+FSA) +* P) by FUNCT_4:15
        .= ss +* (P +* Start-At( 0,SCM+FSA)) by A20,FUNCT_4:36;
A29:  now
        let b be Int-Location;
        Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).b = Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)).b
        by A14,SCMFSA_2:95;
        hence Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).b =
Comput(ProgramPart(
Is), Is,LifeSpan(ProgramPart(Is),Is)).b
        by A11,A10,A28,A27,Th109,SCMFSA6A:30;
      end;
      then Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).a = Comput
(ProgramPart( Is)
, Is,LifeSpan(ProgramPart(Is),Is)).a
        .= IExec(P,ss).a by A27,A25,Th87;
      hence Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).a =
Comput(ProgramPart( (
Initialize ss +* (
I1 +* Start-At( 0,SCM+FSA)))), (Initialize ss +* (
I1 +* Start-At( 0,SCM+FSA))), (LifeSpan(ProgramPart(Initialize ss +* (I1 +*
Start-At( 0,SCM+FSA)
      )),Initialize ss +* (I1 +*
Start-At( 0,SCM+FSA)
      )))).a by A16,A17,Th87
        .= ss.a - 1 by A1,Th98;
A30:  P is good by Th115;
      Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).intloc 0 =
Comput(ProgramPart(
Is), Is,LifeSpan (ProgramPart Is,
      Is)).intloc 0 by A29
        .= 1 by A27,A25,A26,A30,Th96;
      hence Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).intloc 0
= 1;
    end;
    hence s3.a = ss.a - 1 & s3.intloc 0 = 1;
A31: now
      InsCode i = 7 by SCMFSA_2:48;
      then
A32:  (Macro i). 0 <> halt SCM+FSA by SCMFSA6B:33,SCMFSA_2:124;
A33:   0 in dom Macro i by SCMFSA6B:32;
      P = i ';' I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA by SCMFSA8B:def 1
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1)) ';' Goto
       2 ';' Stop SCM+FSA by SCMFSA6A:71
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2) ';' Stop SCM+FSA by SCMFSA6A:71
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA) by SCMFSA6A:71
        .= Macro i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA);
      hence P. 0 = (Macro i). 0 by A33,A32,SCMFSA6A:54
        .= i by SCMFSA6B:33;
      hence P. 0 <> halt SCM+FSA by SCMFSA_2:48,124;
A34:  card P = card Goto  2 + card I1 + 4 by SCMFSA8B:14
        .= card I1 + 1 + 4 by SCMFSA8A:29
        .= card I1 + 3 + 2;
      hence  0 in dom P by AFINSQ_1:70;
      card loop P = card dom loop P by CARD_1:104
        .= card dom P by FUNCT_4:105
        .= card P by CARD_1:104;
      then card ProgramPart loop P = card I1 + (3 + 2) by A34,AMI_1:105;
      hence P. (card I1 + 3) = goto  card ProgramPart loop P
      by Th116;
      hence P. (card I1 + 3) <> halt SCM+FSA by SCMFSA_2:47,124;
      hereby
        card I1 + 3 + 0 < card P by A34,XREAL_1:8;
        hence  (card I1 + 3) in dom P by AFINSQ_1:70;
      end;
    end;
    hereby
      per cases;
      suppose
A35:    k = 0;
        take m = LifeSpan(ProgramPart(s1),s1) + 1 + 1 + 1;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1))/.
IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1)
 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).IC Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)+1) by AMI_1:150;
A36:    CurInstr(ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1)
,s1)+1),
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1))
 = s2. 0 by A13,Y,AMI_1:54
          .= (loop P). 0 by A15,Th26
          .= i by A31,FUNCT_4:111;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1))/.
IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1)
 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1).IC Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)+1+1)
 by AMI_1:150;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(
s1),s1)+1)
by AMI_1:144;
A37:    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1) =
Following(ProgramPart s2,
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1)) by AMI_1:14
          .= Exec(i,Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1))
by A36,T;
        then IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1) =
(card I1 + 3) by
A5,A15,A35,SCMFSA_2:96;
        then
A38:    CurInstr(ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1)
,s1)+1+1),
            Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1))
 = s2. (card I1 + 3
        ) by Y,AMI_1:54
          .= (loop P). (card I1 + 3) by A15,Th26
          .= goto  card ProgramPart loop P by A31,FUNCT_4:111;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(
s1),s1)+1+1)
by AMI_1:144;
        Comput(ProgramPart(s2),s2,m) =
        Following(ProgramPart s2,
        Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1+1)) by AMI_1:
14
          .= Exec(goto  card ProgramPart loop P, Comput(ProgramPart(s2),s2,
        LifeSpan(ProgramPart(s1),s1)+1+1)) by A38,T;
        hence IC Comput(ProgramPart(s2),s2,m) =  card ProgramPart loop P by
SCMFSA_2:95;
        hereby
          let n be Element of NAT;
          assume
          n < m;
          then n <= LifeSpan(ProgramPart(s1),s1) + 1 + 1 by NAT_1:13;
          then
A39:      n <= LifeSpan(ProgramPart(s1),s1) + 1 or n = LifeSpan(ProgramPart(s1)
,s1) + 1 + 1 by NAT_1:8;
          per cases by A39,NAT_1:8;
          suppose
A40:        n <= LifeSpan(ProgramPart(s1),s1);
A41:        I1 is_halting_on ss by SCMFSA7B:25;
A42:        I1 is_closed_on ss by SCMFSA7B:24;
            then
A43:        P is_closed_on ss by A6,A41,SCMFSA8B:18;
            P is_halting_on ss by A6,A42,A41,SCMFSA8B:18;
            then Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s2),s2,n)
equal_outside A by A40,A43,Th109;
            then
A44:        IC Comput(ProgramPart(s2),s2,n) = IC Comput(ProgramPart(s1),s1,n)
by SCMFSA8A:6;
            IC Comput(ProgramPart(s1),s1,n) in dom P by A43,SCMFSA7B:def 7;
            hence IC Comput(ProgramPart(s2),s2,n) in dom loop P by A44,
FUNCT_4:105;
          end;
          suppose
            n = LifeSpan(ProgramPart(s1),s1) + 1;
            hence IC Comput(ProgramPart(s2),s2,n) in dom loop P by A13,A15;
          end;
          suppose
            n = LifeSpan(ProgramPart(s1),s1) + 1 + 1;
            hence IC Comput(ProgramPart(s2),s2,n) in dom loop P by A5,A15,A35
,A37,SCMFSA_2:96;
          end;
        end;
      end;
      suppose
A45:    k > 0;
        consider Is3 being State of SCM+FSA such that
A46:    Is3 = Initialize s3;
A47:    dom loop P misses dom Start-At( 0,SCM+FSA) by SF_MASTR:64;
        then
        Initialize s3 +* (loop P +* Start-At( 0,SCM+FSA)) =
        Initialize s3 +*
        (Start-At( 0,SCM+FSA) +* loop P) by FUNCT_4:36
          .= Initialize s3 +* Start-At( 0,SCM+FSA) +* loop P
          by FUNCT_4:15;
        then
A48:    Initialize s3 +* (loop P +* Start-At( 0,SCM+FSA)) = s3 +* (IC
        SCM+FSA .-->  0) +*loop P by A13,A15,Th14;
        s2 = ss +* (Start-At( 0,SCM+FSA) +* loop P) by A47,FUNCT_4:36
          .= ss +* Start-At( 0,SCM+FSA) +* loop P by FUNCT_4:15;
        then ProgramPart loop P c= s3 by AMI_1:99,FUNCT_4:26;
        then
A49:    loop P c= s3 by AMI_1:105;
A50:    Is3.intloc 0 = 1 by A46,SCMFSA6C:3;
        Is3.a = k by A5,A15,A46,SCMFSA6C:3;
        then consider m0 being Element of NAT such that
A51:    IC Comput(ProgramPart( (Is3 +* (loop P +* Start-At( 0,SCM+FSA)))), (Is3
+* (loop P +* Start-At( 0,SCM+FSA))),m0) =
         card ProgramPart loop P and
A52:    for n being Element of NAT st n < m0 holds IC Comput(ProgramPart( (
        Is3 +* (loop P +* Start-At( 0,SCM+FSA)))), (
        Is3 +* (loop P +* Start-At( 0,SCM+FSA))),n) in dom loop P
        by A3,A45,A50;
        take m = LifeSpan(ProgramPart(s1),s1) + 1 + m0;
T: ProgramPart s2 = ProgramPart s3
by AMI_1:144;
        IC SCM+FSA in dom s3 by AMI_1:94;
        then
A53:    Initialize s3 +* (loop P +* Start-At( 0,SCM+FSA)) =
s3 +* loop P by A13,A48,FUNCT_7:111
          .= s3 by A49,FUNCT_4:79;
        hence
        IC Comput(ProgramPart(s2),s2,m) =  card ProgramPart loop P by A46,A51,T
,AMI_1:51;
        hereby
          let n be Element of NAT;
          assume
A54:      n < m;
A55:      I1 is_halting_on ss by SCMFSA7B:25;
A56:      I1 is_closed_on ss by SCMFSA7B:24;
          then
A57:      P is_closed_on ss by A6,A55,SCMFSA8B:18;
A58:      P is_halting_on ss by A6,A56,A55,SCMFSA8B:18;
          per cases by NAT_1:13;
          suppose
            n <= LifeSpan(ProgramPart(s1),s1);
            then Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s2),s2,n)
equal_outside A by A57,A58,Th109;
            then
A59:        IC Comput(ProgramPart(s2),s2,n) = IC Comput(ProgramPart(s1),s1,n)
by SCMFSA8A:6;
            IC Comput(ProgramPart(s1),s1,n) in dom P by A57,SCMFSA7B:def 7;
            hence IC Comput(ProgramPart(s2),s2,n) in dom loop P by A59,
FUNCT_4:105;
          end;
          suppose
A60:        LifeSpan(ProgramPart(s1),s1) + 1 <= n;
            consider mm being Element of NAT such that
A61:        mm = n -' (LifeSpan(ProgramPart(s1),s1) + 1);
            n - (LifeSpan(ProgramPart(s1),s1) + 1) >= 0 by A60,XREAL_1:50;
            then
A62:        mm = n - (LifeSpan(ProgramPart(s1),s1) + 1) by A61,XREAL_0:def 2;
T: ProgramPart s2 = ProgramPart s3
by AMI_1:144;
            mm + (LifeSpan(ProgramPart(s1),s1) + 1) = n by A60,A61,XREAL_1:237;
            then
A63:        IC Comput(ProgramPart(s2),s2,n) = IC Comput(ProgramPart( s2), s3,mm
) by AMI_1:51;
            m0 = m - (LifeSpan(ProgramPart(s1),s1) + 1);
            then mm < m0 by A54,A62,XREAL_1:11;
            hence IC Comput(ProgramPart(s2),s2,n) in dom loop P by A46,A52,A53
,A63,T;
          end;
        end;
      end;
    end;
  end;
  assume
A64: s.intloc 0 = 1;
  assume
A65: s.a > 0;
  then reconsider sa = s.a as Element of NAT by INT_1:16;
A66: P[0];
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A66,A2);
  then P[sa];
  then ex k being Element of NAT st IC Comput(ProgramPart( (s +* (loop P +*
  Start-At( 0,SCM+FSA)))), (s +* (loop P +*
  Start-At( 0,SCM+FSA))),k) =
    card ProgramPart loop P & for n being Element of NAT st
n < k holds IC Comput(ProgramPart( (s +* (loop P +* Start-At( 0,SCM+FSA)))), (s
+* (loop P +* Start-At( 0,SCM+FSA))),n)
 in dom loop
  P by A64,A65;
  hence thesis by SCMFSA8A:def 3;
end;

theorem
  for s being State of SCM+FSA, I being good parahalting Program of
  SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.a > 0
  holds Initialized loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s
proof
  let s be State of SCM+FSA;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
A2: (Initialize s).a = s.a by SCMFSA6C:3;
A3: (Initialize s).intloc 0 = 1 by SCMFSA6C:3;
  assume
  s.a > 0;
  then
  loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) is_pseudo-closed_on
  Initialize s by A1,A2,A3,Th117;
  hence thesis by Lm1;
end;

theorem
  for s being State of SCM+FSA, I being good parahalting Program of
SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.intloc 0 =
  1 holds Times(a,I) is_closed_on s & Times(a,I) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  assume
A2: s.intloc 0 = 1;
  per cases;
  suppose
A3: s.a > 0;
    Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) = loop
    if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) by SCMFSA6A:63;
    then Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
    is_pseudo-closed_on s by A1,A2,A3,Th117;
    hence thesis by A3,Th68;
  end;
  suppose
A4: s.a <= 0;
A5: Stop SCM+FSA is_halting_on s by SCMFSA7B:25;
    Stop SCM+FSA is_closed_on s by SCMFSA7B:24;
    hence thesis by A4,A5,SCMFSA8B:24;
  end;
end;

theorem
  for I being good parahalting Program of SCM+FSA, a being read-write
  Int-Location st I does_not_destroy a holds Initialized Times(a,I) is halting
proof
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  now
    let s be State of SCM+FSA;
    per cases;
    suppose
      s.a > 0;
      then
A2:   (Initialize s).a > 0 by SCMFSA6C:3;
A3:   Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) = loop
      if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) by SCMFSA6A:63;
      (Initialize s).intloc 0 = 1 by SCMFSA6C:3;
      then Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
      is_pseudo-closed_on Initialize s by A1,A2,A3,Th117;
      then Times(a,I) is_halting_on Initialize s by A2,Th68;
      hence Initialized Times(a,I) is_halting_on s by Th22;
    end;
    suppose
A4:   s.a <= 0;
A5:   Stop SCM+FSA is_closed_on Initialize s by SCMFSA7B:24;
A6:   Stop SCM+FSA is_halting_on Initialize s by SCMFSA7B:25;
      (Initialize s).a <= 0 by A4,SCMFSA6C:3;
      then Times(a,I) is_halting_on Initialize s by A5,A6,SCMFSA8B:24;
      hence Initialized Times(a,I) is_halting_on s by Th22;
    end;
  end;
  hence thesis by Th24;
end;

theorem
  for I,J being Program of SCM+FSA, a,c being Int-Location st I
does_not_destroy c & J does_not_destroy c holds if=0(a,I,J) does_not_destroy c
  & if>0(a,I,J) does_not_destroy c
proof
  let I,J be Program of SCM+FSA;
  let a,c be Int-Location;
  assume
A1: I does_not_destroy c;
A2: Goto  (card I + 1) does_not_destroy c by Th86;
  assume
A3: J does_not_destroy c;
  then a =0_goto  (card J + 3) ';' J does_not_destroy c by Th82,SCMFSA7B:18;
  then a =0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
  does_not_destroy c by A2,Th81;
  then
A4: a =0_goto  (card J + 3) ';' J ';' Goto  (card I + 1) ';' I
  does_not_destroy c by A1,Th81;
A5: Goto  (card I + 1) does_not_destroy c by Th86;
  a >0_goto  (card J + 3) ';' J does_not_destroy c by A3,Th82,SCMFSA7B:19
;
  then a >0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
  does_not_destroy c by A5,Th81;
  then
A6: a >0_goto  (card J + 3) ';' J ';' Goto  (card I + 1) ';' I
  does_not_destroy c by A1,Th81;
A7: if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  Stop SCM+FSA does_not_destroy c by Th85;
  hence if=0(a,I,J) does_not_destroy c by A4,A7,Th81;
A8: if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  Stop SCM+FSA does_not_destroy c by Th85;
  hence thesis by A6,A8,Th81;
end;

theorem Th122:
  for s being State of SCM+FSA, I being good parahalting Program
of SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.intloc
  0 = 1 & s.a > 0 holds ex s2 being State of SCM+FSA, k being Element of NAT st
  s2 = s +* (loop if=0(a,Goto  2, I ';' SubFrom(a,intloc 0)) +*
  Start-At( 0,SCM+FSA)) &
  k = LifeSpan(ProgramPart(s +* (if=0(a,Goto  2, I ';' SubFrom(a,intloc 0)
) +* Start-At( 0,SCM+FSA))),s +* (if=0(a,Goto  2, I ';' SubFrom(a,intloc 0)
) +* Start-At( 0,SCM+FSA))) + 1 & Comput(ProgramPart( s2), s2,k).a = s.a - 1 &
Comput(ProgramPart( s2
  ), s2
  ,k).intloc 0 = 1 & (for b being read-write Int-Location st b <> a holds
  Comput(ProgramPart( s2), s2,k).b = IExec(I,s).b) & (for f being
FinSeq-Location holds
Comput(ProgramPart( s2), s2,k).f = IExec(I,s).f) & IC Comput(ProgramPart( s2),
s2,k) =  0 & for n
being Element of NAT st n <= k holds IC Comput(ProgramPart( s2), s2,n) in dom
loop if=0(a,
  Goto  2,I ';' SubFrom(a,intloc 0))
proof
  let s be State of SCM+FSA;
  set A = NAT;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  reconsider I1 = I ';' SubFrom(a,intloc 0) as parahalting Program of SCM+FSA;
  set P = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
  set s1 = s +* (P +* Start-At( 0,SCM+FSA));
A2: I1 is_halting_on s by SCMFSA7B:25;
  set Is = Initialize s +* (P +* Start-At( 0,SCM+FSA));
A3: intloc 0 in dom s by SCMFSA_2:66;
  assume
  s.intloc 0 = 1;
  then
A4: s +* (intloc 0 .--> 1) = s by A3,FUNCT_7:111;
A5: I1 is_closed_on Initialize s by SCMFSA7B:24;
A6: I1 is_halting_on Initialize s by SCMFSA7B:25;
  assume
A7: s.a > 0;
  then
A8: (Initialize s).a > 0 by SCMFSA6C:3;
  then
A9: P is_halting_on Initialize s by A5,A6,SCMFSA8B:18;
A10: P is_closed_on Initialize s by A8,A5,A6,SCMFSA8B:18;
  take s2 = s +* (loop P +* Start-At( 0,SCM+FSA));
  take k = LifeSpan(ProgramPart(s1),s1) + 1;
  thus s2 = s +* (loop if=0(a,Goto  2, I ';' SubFrom(a,intloc 0)) +*
Start-At( 0,SCM+FSA)) & k = LifeSpan(ProgramPart(s +* (if=0(a,Goto  2, I ';'
SubFrom(a,
  intloc 0)) +* Start-At( 0,SCM+FSA))),s +* (if=0(a,Goto  2, I ';'
SubFrom(a,
  intloc 0)) +* Start-At( 0,SCM+FSA))) + 1;
A11: dom P misses dom Start-At( 0,SCM+FSA) by SF_MASTR:64;
  Initialize s = s +* (intloc 0 .--> 1) +* Start-At( 0,SCM+FSA)
  by SCMFSA6C:def 3;
  then
A12: Initialize s +* (P +* Start-At( 0,SCM+FSA)) =
s +* Start-At( 0,SCM+FSA) +* (
  Start-At( 0,SCM+FSA) +* P) by A4,A11,FUNCT_4:36
    .= s +* Start-At( 0,SCM+FSA) +* Start-At( 0,SCM+FSA) +* P
    by FUNCT_4:15
    .= s +* (Start-At( 0,SCM+FSA) +* Start-At( 0,SCM+FSA)) +* P
    by FUNCT_4:15
    .= s +* (Start-At( 0,SCM+FSA) +* P) by FUNCT_4:15
    .= s +* (P +* Start-At( 0,SCM+FSA)) by A11,FUNCT_4:36;
A13: I1 is_halting_on Initialize s by SCMFSA7B:25;
  I1 is_closed_on Initialize s by SCMFSA7B:24;
  then
A14: IExec(P,s) = IExec(I1,s) +* Start-At( (card Goto  2 + card
  I1 + 3),SCM+FSA) by A7,A13,SCMFSA8B:19;
  then
A15: IExec(P,s).a = IExec(I1,s).a by SCMFSA_3:11;
A16: I1 is_closed_on s by SCMFSA7B:24;
  then
A17: P is_closed_on s by A7,A2,SCMFSA8B:18;
A18: P is_halting_on s by A7,A16,A2,SCMFSA8B:18;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(
s1),s1))
by AMI_1:144;
A19: Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1) =
Following(ProgramPart s2,
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)))
 by AMI_1:14
    .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart
(s1),s1)),
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)))
    ,Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1))
  ) by T;
  then
A20: Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1) = Exec(goto  0,
Comput(ProgramPart
(s2),s2,
  LifeSpan(ProgramPart(s1),s1))) by A17,A18,Lm2,T;
A21: now
    let b be Int-Location;
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).b = Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)).b by A20,SCMFSA_2:95;
    hence Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).b = Comput(
ProgramPart( Is),
Is,LifeSpan(ProgramPart(Is),Is)).b by A17,A18,A12,Th109,SCMFSA6A:30;
  end;
  then Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).a = Comput(
ProgramPart( Is), Is
,LifeSpan(ProgramPart(Is),Is)).a
    .= IExec(P,s).a by A9,Th87;
  hence Comput(ProgramPart( s2), s2,k).a = Comput(ProgramPart( (Initialize s +*
(I1 +*
  Start-At( 0,SCM+FSA)))), (Initialize s +* (I1 +*
  Start-At( 0,SCM+FSA))), (LifeSpan(ProgramPart(Initialize s +* (I1 +*
   Start-At( 0,SCM+FSA))),Initialize s +* (I1 +*
   Start-At( 0,SCM+FSA))))).a by A13,A15,Th87
    .= s.a - 1 by A1,Th98;
A22: P is good by Th115;
  Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).intloc 0 = Comput(
ProgramPart( Is),
Is,LifeSpan(ProgramPart(Is),Is)).
  intloc 0 by A21
    .= 1 by A9,A10,A22,Th96;
  hence Comput(ProgramPart( s2), s2,k).intloc 0 = 1;
  hereby
    let b be read-write Int-Location;
    assume
A23: b <> a;
    thus Comput(ProgramPart( s2), s2,k).b = Comput(ProgramPart( Is), Is,
LifeSpan(ProgramPart(Is),Is)).b by A21
      .= IExec(P,s).b by A9,Th87
      .= IExec(I1,s).b by A14,SCMFSA_3:11
      .= Exec(SubFrom(a,intloc 0),IExec(I,s)).b by SCMFSA6C:7
      .= IExec(I,s).b by A23,SCMFSA_2:91;
  end;
  hereby
    let f be FinSeq-Location;
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).f = Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)).f by A20,SCMFSA_2:95;
    hence Comput(ProgramPart( s2), s2,k).f = Comput(ProgramPart( Is), Is,
LifeSpan(ProgramPart(Is),Is)).f by A17,A18,A12,Th109,SCMFSA6A:31
      .= IExec(P,s).f by A9,Th87
      .= IExec(I1,s).f by A14,SCMFSA_3:12
      .= Exec(SubFrom(a,intloc 0),IExec(I,s)).f by SCMFSA6C:8
      .= IExec(I,s).f by SCMFSA_2:91;
  end;
A24: IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1) = Exec(goto
0,Comput(
ProgramPart(s2),s2,
  LifeSpan(ProgramPart(s1),s1))).IC SCM+FSA by A17,A18,A19,Lm2,T
    .=  0 by SCMFSA_2:95;
  hence IC Comput(ProgramPart( s2), s2,k) =  0;
  hereby
    let n be Element of NAT;
    assume
A25: n <= k;
    per cases by A25,NAT_1:8;
    suppose
A26:  n <= LifeSpan(ProgramPart(s1),s1);
A27:  I1 is_halting_on s by SCMFSA7B:25;
A28:  I1 is_closed_on s by SCMFSA7B:24;
      then
A29:  P is_closed_on s by A7,A27,SCMFSA8B:18;
      P is_halting_on s by A7,A28,A27,SCMFSA8B:18;
      then Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s2),s2,n)
equal_outside A by A26,A29,Th109
;
      then
A30:  IC Comput(ProgramPart(s2),s2,n) = IC Comput(ProgramPart(s1),s1,n) by
SCMFSA8A:6;
      IC Comput(ProgramPart(s1),s1,n) in dom P by A29,SCMFSA7B:def 7;
      hence IC Comput(ProgramPart( s2), s2,n) in dom loop P by A30,FUNCT_4:105;
    end;
    suppose
A31:  n = LifeSpan(ProgramPart(s1),s1) + 1;
A32:  card P = card Goto  2 + card I1 + 4 by SCMFSA8B:14
        .= card I1 + 1 + 4 by SCMFSA8A:29
        .= card I1 + 3 + 2;
      card loop P = card dom loop P by CARD_1:104
        .= card dom P by FUNCT_4:105
        .= card P by CARD_1:104;
      hence IC Comput(ProgramPart( s2), s2,n) in dom loop P by A24,A31,A32,
AFINSQ_1:70;
    end;
  end;
end;

theorem Th123:
  for s being State of SCM+FSA, I being good parahalting Program
of SCM+FSA, a being read-write Int-Location st s.intloc 0 = 1 & s.a <= 0 holds
  DataPart IExec(Times(a,I),s) = DataPart s
proof
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.intloc 0 = 1;
  set s0 = Initialize s;
A2: Stop SCM+FSA is_halting_on Initialize s by SCMFSA7B:25;
  assume
  s.a <= 0;
  then
A3: (Initialize s).a <= 0 by SCMFSA6C:3;
A4: IExec(Stop SCM+FSA ';' Stop SCM+FSA,s0) = IExec(Stop SCM+FSA,IExec(Stop
SCM+FSA,s0)) +* Start-At((IC IExec(Stop SCM+FSA,IExec(Stop SCM+FSA,s0)) + card
  Stop SCM+FSA),SCM+FSA) by SCMFSA6B:44;
A5: for f being FinSeq-Location holds s0.f = s.f by SCMFSA6C:3;
A6: for a being read-write Int-Location holds s0.a = s.a by SCMFSA6C:3;
A7: s0.intloc 0 = 1 by SCMFSA6C:3;
A8: Stop SCM+FSA is_closed_on Initialize s by SCMFSA7B:24;
  then
A9: Times(a,I) is_halting_on Initialize s by A3,A2,SCMFSA8B:24;
A10: Stop SCM+FSA is_halting_on s0 by SCMFSA7B:25;
A11: Stop SCM+FSA is_closed_on s0 by SCMFSA7B:24;
A12: DataPart IExec(Stop SCM+FSA,s0) = DataPart(Initialize s0 +*
Start-At( 0,SCM+FSA)) by Th38
    .= DataPart (Initialize s +* Start-At( 0,SCM+FSA)) by Th15
    .= DataPart s0 by SCMFSA8A:10;
  Times(a,I) is_closed_on Initialize s by A3,A8,A2,SCMFSA8B:24;
  then DataPart IExec(Times(a,I),s) = DataPart IExec(Times(a,I),s0) by A9,A7,A6
,A5,Th45
    .= DataPart IExec(Stop SCM+FSA ';' Stop SCM+FSA,s0) by A3,A11,A10,A7,Th73,
SCMFSA8A:37;
  hence DataPart IExec(Times(a,I),s) = DataPart IExec(Stop SCM+FSA,IExec(Stop
  SCM+FSA,s0)) by A4,SCMFSA8A:10
    .= DataPart IExec(Stop SCM+FSA,s0) by A8,A2,A7,A12,Th46
    .= DataPart s by A1,A12,Th27;
end;

theorem Th124:
  for s being State of SCM+FSA, I being good parahalting Program
  of SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.a > 0
holds IExec(I ';' SubFrom(a,intloc 0),s).a = s.a - 1 & DataPart IExec(Times(a,I
  ),s) = DataPart IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s))
proof
  let s be State of SCM+FSA;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' SubFrom(a,intloc 0);
  set ss = IExec(I1,s);
  set s0 = Initialize s;
  set ss0 = Initialize ss;
  set P = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
  set s21 = s0 +* (loop P ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA));
  set s31 = ss0 +* (loop P ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA));
A1: I is_halting_on s0 by SCMFSA7B:25;
A2: I1 is_halting_on Initialize s by SCMFSA7B:25;
  reconsider J3 = Macro SubFrom(a,intloc 0) as good Program of SCM+FSA by Th99,
SCMFSA7B:14;
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  assume
A3: I does_not_destroy a;
   0 in dom P by Th54;
  then
A4:  0 in dom loop P by FUNCT_4:105;
A5: I1 is_closed_on Initialize s by SCMFSA7B:24;
A6: I1 = I ';' J3;
  then
A7: ss.intloc 0 = 1 by A2,A5,Th96;
  assume
A8: s.a > 0;
  then
A9: s0.a > 0 by SCMFSA6C:3;
A10: s0.intloc 0 = 1 by SCMFSA6C:3;
  then
A11: loop P is_pseudo-closed_on s0 by A3,A9,Th117;
A12: Directed loop P = loop P by SCMFSA6A:63;
  then
A13: Directed loop P is_pseudo-closed_on s0 by A3,A10,A9,Th117;
  consider s2 be State of SCM+FSA, k be Element of NAT such that
A14: s2 = s0 +* (loop P +* Start-At( 0,SCM+FSA)) and
  k = LifeSpan(ProgramPart(s0 +* (P +* Start-At( 0,SCM+FSA))),s0 +* (P +*
Start-At( 0,SCM+FSA))) + 1 and
A15: Comput(ProgramPart( s2), s2,k).a = s0.a - 1 and
A16: Comput(ProgramPart( s2), s2,k).intloc 0 = 1 and
A17: for b being read-write Int-Location st b <> a holds Comput(ProgramPart( s2
), s2,
  k).b = IExec(I,s0).b and
A18: for f being FinSeq-Location holds Comput(ProgramPart( s2), s2,k).f = IExec
(I,s0)
  .f and
A19: IC Comput(ProgramPart( s2), s2,k) =  0 and
A20: for n being Element of NAT st n <= k holds IC Comput(ProgramPart( s2), s2,
n) in
  dom loop P by A3,A10,A9,Th122;
A21: now
    let f be FinSeq-Location;
    thus Comput(ProgramPart(s2),s2,k).f = IExec(I,s0).f by A18
      .= Exec(SubFrom(a,intloc 0),IExec(I,s0)).f by SCMFSA_2:91
      .= IExec(I1,s0).f by SCMFSA6C:8
      .= IExec(I1,s).f by Th17;
  end;
  thus
A22: ss.a = Exec(SubFrom(a,intloc 0),IExec(I,s)).a by SCMFSA6C:7
    .= IExec(I,s).a - IExec(I,s).intloc 0 by SCMFSA_2:91
    .= IExec(I,s).a - 1 by A1,Th92
    .= s0.a - 1 by A3,Th91
    .= s.a - 1 by SCMFSA6C:3;
  now
    let b be Int-Location;
    per cases;
    suppose
      b = intloc 0;
      hence Comput(ProgramPart(s2),s2,k).b = IExec(I1,s).b by A16,A6,A2,A5,Th96
;
    end;
    suppose
      b = a;
      hence Comput(ProgramPart(s2),s2,k).b = IExec(I1,s).b by A15,A22,
SCMFSA6C:3;
    end;
    suppose
A23:  b <> a & b <> intloc 0;
      then reconsider bb = b as read-write Int-Location by SF_MASTR:def 5;
      thus Comput(ProgramPart(s2),s2,k).b = IExec(I,s0).bb by A17,A23
        .= Exec(SubFrom(a,intloc 0),IExec(I,s0)).b by A23,SCMFSA_2:91
        .= IExec(I1,s0).b by SCMFSA6C:7
        .= IExec(I1,s).b by Th17;
    end;
  end;
  then
A24: DataPart Comput(ProgramPart(s2),s2,k) = DataPart ss by A21,SCMFSA6A:38;
A25: DataPart IExec(Times(a,I),s0) = DataPart IExec(loop P ';' Stop SCM+FSA,
  s0) by A3,A10,A9,A12,Th69,Th117;
  per cases;
  suppose
A26: ss.a = 0;
    loop P c= loop P +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
    then
A27: dom loop P c= dom (loop P +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
A28: P. (card I1 + 3) = goto  (card I1 + 5) by Th65;
    then
A29: P. (card I1 + 3) <> halt SCM+FSA by SCMFSA_2:47,124;
A30: card I1 + (3 + 2) = card I1 + 1 + 4
      .= card Goto  2 + card I1 + 4 by SCMFSA8A:29
      .= card P by SCMFSA8B:14
      .= card dom P by CARD_1:104
      .= card dom loop P by FUNCT_4:105
      .= card loop P by CARD_1:104;
    then card I1 + 3 + 0 < card loop P by XREAL_1:8;
    then
A31:  (card I1 + 3) in dom loop P by AFINSQ_1:70;
    Comput(ProgramPart(s2),s2,k+1). (card I1 + 3) = s2. (card I1 + 3) by
AMI_1:54
      .= (loop P +* Start-At( 0,SCM+FSA)). (card I1 + 3)
      by A14,A31,A27,FUNCT_4:14
      .= (loop P). (card I1 + 3) by A31,SCMFSA6B:7;
    then
A32: Comput(ProgramPart(s2),s2,k+1). (card I1 + 3) = goto  (card I1 + 5)
    by A28,A29,FUNCT_4:111;
    then InsCode Comput(ProgramPart(s2),s2,k+1). (card I1 + 3) = 6 by
SCMFSA_2:47;
    then
A33: InsCode Comput(ProgramPart(s2),s2,k+1). (card I1 + 3) in {0,6,7,8} by
ENUMSET1:def 2;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by AMI_1:150;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:144;
A34: Comput(ProgramPart(s2),s2,k+1) =
Following(ProgramPart s2,Comput(ProgramPart(s2),s2,k)
)
 by AMI_1:14
      .= Exec(Comput(ProgramPart(s2),s2,k). 0,Comput(ProgramPart(s2),s2,k)) by
A19,Y,T;
    loop P c= loop P +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
    then
A35: dom loop P c= dom (loop P +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
A36: Comput(ProgramPart(s2),s2,k). 0 = s2. 0 by AMI_1:54
      .= (loop P +* Start-At( 0,SCM+FSA)). 0
      by A14,A4,A35,FUNCT_4:14
      .= (loop P). 0 by A4,SCMFSA6B:7;
A37: P. 0 = a =0_goto  (card I1 + 3) by Th55;
    then P. 0 <> halt SCM+FSA by SCMFSA_2:48,124;
    then
A38: Comput(ProgramPart(s2),s2,k). 0 = a =0_goto  (card I1 + 3) by A36,A37,
FUNCT_4:111;
A39: Comput(ProgramPart(s2),s2,k).a = 0 by A15,A22,A26,SCMFSA6C:3;
    then
A40: IC Comput(ProgramPart(s2),s2,k+1) =  (card I1 + 3) by A34,A38,SCMFSA_2:96;
A41: now
      let n be Element of NAT;
      assume
A42:  not IC Comput(ProgramPart( s2), s2,n) in dom loop P;
      then k < n by A20;
      then k + 1 <= n by INT_1:20;
      then k + 1 < n by A40,A31,A42,XXREAL_0:1;
      then k + 1 + 1 <= n by INT_1:20;
      hence k + (1 + 1) <= n;
    end;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,k+1))/.IC Comput(ProgramPart(s2),s2,
k+1)
 = Comput(ProgramPart(s2),s2,k+1).IC Comput(ProgramPart(s2),s2,k+1) by
AMI_1:150;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k+1)
by AMI_1:144;
A43: Comput(ProgramPart(s2),s2,k+(1+1)) = Comput(ProgramPart(s2),s2,k+1+1)
      .= Following(ProgramPart s2,Comput(
ProgramPart(s2),s2,k+1))
       by AMI_1:14
      .= Exec(Comput(ProgramPart(s2),s2,k+1). (card I1 + 3),Comput(ProgramPart(
s2),s2,k+1))
    by A39,A34,A38,Y,T,SCMFSA_2:96;
    then IC Comput(ProgramPart(s2),s2,k+2) =  (card I1 + 5) by A32,SCMFSA_2:95
      .=  card ProgramPart loop P by A30,AMI_1:105;
    then
A44: k + 2 = pseudo-LifeSpan(s0,loop P) by A14,A11,A41,
SCMFSA8A:def 5;
    InsCode Comput(ProgramPart(s2),s2,k). 0 = 7 by A38,SCMFSA_2:48;
    then InsCode Comput(ProgramPart(s2),s2,k). 0 in {0,6,7,8} by ENUMSET1:def 2
;
    then DataPart Comput(ProgramPart(s2),s2,k) = DataPart Comput(ProgramPart(s2
),s2,k+1) by A34,Th32;
    then
A45: DataPart Comput(ProgramPart(s2),s2,k) = DataPart Comput(ProgramPart(s2),s2
,k+2) by A43,A33,Th32;
X: s21 = s +* Initialized (loop P ';' Stop SCM+FSA) by SCMFSA8A:13;
    thus DataPart IExec(Times(a,I),s) = DataPart IExec(Times(a,I),s0) by Th17
      .= DataPart IExec(loop P ';' Stop SCM+FSA,s) by A25,Th17
      .= DataPart(Result(ProgramPart(s +* Initialized (loop P ';' Stop SCM+FSA)
),s +* Initialized (loop P ';' Stop SCM+FSA)) +* s |
    A) by SCMFSA6B:def 1
      .= DataPart(Result(ProgramPart(s21),s21) +* s | A) by X
      .= DataPart Result(ProgramPart(s21),s21) by Th35
      .= DataPart IExec(I1,s) by A3,A10,A9,A14,A12,A24,A44,A45,Th59,Th117
      .= DataPart IExec(Times(a,I),IExec(I1,s)) by A7,A26,Th123;
  end;
  suppose
A46: ss.a <> 0;
    s.a >= 0 + 1 by A8,INT_1:20;
    then
A47: ss.a > 0 by A22,A46,XREAL_1:21;
A48: DataPart s0 = DataPart s21 by SCMFSA8A:11;
A49: k < pseudo-LifeSpan(s0,loop P) by A3,A10,A9,A14,A20
,Th2,Th117;
    then
A50: DataPart Comput(ProgramPart( s21), s21,k) = DataPart ss by A14,A12,A13,A24
,Th58;
A51: now
A52:  DataPart ss0 = DataPart s31 by SCMFSA8A:11;
      hereby
        let a be Int-Location;
        per cases;
        suppose
A53:      a = intloc 0;
          thus Comput(ProgramPart( s21), s21,k).a = ss.a by A50,SCMFSA6A:38
            .= 1 by A53,SCMFSA6B:35
            .= ss0.a by A53,SCMFSA6C:3
            .= s31.a by A52,SCMFSA6A:38;
        end;
        suppose
          a <> intloc 0;
          then
A54:      a is read-write Int-Location by SF_MASTR:def 5;
          thus Comput(ProgramPart( s21), s21,k).a = ss.a by A50,SCMFSA6A:38
            .= ss0.a by A54,SCMFSA6C:3
            .= s31.a by A52,SCMFSA6A:38;
        end;
      end;
      let f be FinSeq-Location;
      thus Comput(ProgramPart( s21), s21,k).f = ss.f by A50,SCMFSA6A:38
        .= ss0.f by SCMFSA6C:3
        .= s31.f by A52,SCMFSA6A:38;
    end;
    IC Comput(ProgramPart( s21), s21,k) = IC Comput(ProgramPart(s2),s2,k) by
A14,A12,A13,A49,Th58
      .= IC (ss0 +* (loop P ';' Stop SCM+FSA) +* Start-At( 0,SCM+FSA))
      by A19,AMI_1:111
      .= IC s31 by FUNCT_4:15;
    then
A55: Comput(ProgramPart( s21), s21,k),s31 equal_outside A by A51,SCMFSA6A:28;
A56: loop P ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA) c= s21
by FUNCT_4:26;
    Directed loop P = loop P by SCMFSA6A:63;
    then
A57: Directed loop P is_pseudo-closed_on s21 by A3,A10,A9,A48,Th52,Th117;
    then
A58: loop P ';' Stop SCM+FSA is_closed_on s21 by Th58;
A59: loop P ';' Stop SCM+FSA is_halting_on s21 by A57,Th58;
A60: ss.intloc 0 = 1 by A6,A2,A5,Th96;
A61: loop P ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA) c= s31
by FUNCT_4:26;
X:  s21 = s +* Initialized (loop P ';' Stop SCM+FSA) by SCMFSA8A:13;
Y:  s31 = ss +* Initialized(loop P ';' Stop SCM+FSA) by SCMFSA8A:13;
    DataPart IExec(loop P ';' Stop SCM+FSA,s0) = DataPart IExec(loop P
    ';' Stop SCM+FSA,s) by Th17
      .= DataPart (Result(ProgramPart(s +* Initialized (loop P ';' Stop SCM+FSA
)),s +* Initialized (loop P ';' Stop SCM+FSA)) +* s
    | A) by SCMFSA6B:def 1
      .= DataPart(Result(ProgramPart(s21),s21) +* s | A) by X
      .= DataPart Result(ProgramPart(s21),s21) by Th35
      .= DataPart Result(ProgramPart(s31),s31) by A56,A61,A58,A59,A55,Th103,
SCMFSA6A:39
      .= DataPart(Result(ProgramPart(s31),s31) +* ss | A) by Th35
      .= DataPart(Result(ProgramPart(ss +* Initialized(loop P ';' Stop SCM+FSA)
),ss +* Initialized(loop P ';' Stop SCM+FSA)) +* ss |
    A) by Y
      .= DataPart IExec(loop P ';' Stop SCM+FSA,IExec(I1,s)) by SCMFSA6B:def 1
      .= DataPart IExec(Times(a,I),IExec(I1,s)) by A3,A12,A60,A47,Th69,Th117;
    hence thesis by A25,Th17;
  end;
end;

begin :: Example

theorem
  for s being State of SCM+FSA, a,b,c being read-write Int-Location st a
<> b & a <> c & b <> c & s.a >= 0 holds IExec(Times(a,Macro AddTo(b,c)),s).b =
  s.b + s.c * s.a
proof
  let s be State of SCM+FSA;
  let a,b,c be read-write Int-Location;
  set P = Times(a,Macro AddTo(b,c));
  defpred P[Nat] means for s being State of SCM+FSA st s.a = $1
  holds IExec(Times(a,Macro AddTo(b,c)),s).b = s.b + s.c * s.a;
  reconsider I = Macro AddTo(b,c) as good parahalting Program of SCM+FSA by
Th99,SCMFSA7B:13;
  set D = Int-Locations \/ FinSeq-Locations;
  assume that
A1: a <> b and
A2: a <> c and
A3: b <> c;
A4: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A5: P[k];
    let s be State of SCM+FSA;
    assume
A6: s.a = k + 1;
A7: I does_not_destroy a by A1,Th77,SCMFSA7B:13;
    then
A8: DataPart IExec(Times(a,I),s) = DataPart IExec(Times(a,I),IExec(I ';'
    SubFrom(a,intloc 0),s)) by A6,Th124;
A9: IExec(I ';' SubFrom(a,intloc 0),s).c = Exec(SubFrom(a,intloc 0),IExec
    (I,s)).c by SCMFSA6C:7
      .= IExec(I,s).c by A2,SCMFSA_2:91
      .= Exec(AddTo(b,c),Initialize s).c by SCMFSA6C:6
      .= (Initialize s).c by A3,SCMFSA_2:90
      .= s.c by SCMFSA6C:3;
A10: IExec(I ';' SubFrom(a,intloc 0),s).b = Exec(SubFrom(a,intloc 0),IExec
    (I,s)).b by SCMFSA6C:7
      .= IExec(I,s).b by A1,SCMFSA_2:91
      .= Exec(AddTo(b,c),Initialize s).b by SCMFSA6C:6
      .= (Initialize s).b + (Initialize s).c by SCMFSA_2:90
      .= (Initialize s).b + s.c by SCMFSA6C:3
      .= s.b + s.c by SCMFSA6C:3;
    IExec(I ';' SubFrom(a,intloc 0),s).a = s.a - 1 by A6,A7,Th124;
    then IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s)).b = s.b + s.c +
    s.c * (s.a - 1) by A5,A6,A10,A9
      .= s.b + s.c * s.a;
    hence thesis by A8,SCMFSA6A:38;
  end;
  assume
  s.a >= 0;
  then reconsider sa = s.a as Element of NAT by INT_1:16;
A11: P[0]
  proof
    let s be State of SCM+FSA;
    set s0 = Initialize s;
A12: s0.intloc 0 = 1 by SCMFSA6C:3;
    assume
A13: s.a = 0;
    then s0.a = 0 by SCMFSA6C:3;
    then
A14: DataPart IExec(Times(a,I),s0) = DataPart s0 by A12,Th123;
    thus IExec(P,s).b = IExec(P,s0).b by Th17
      .= s0.b by A14,SCMFSA6A:38
      .= s.b + s.c * s.a by A13,SCMFSA6C:3;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A11,A4);
  then P[sa];
  hence thesis;
end;

