:: The {\bf loop} and {\bf Times} Macroinstruction for {\SCMFSA}
::  by Noriko Asamoto
::
:: Received October 29, 1997
:: Copyright (c) 1997 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, FSM_1, SCMFSA_2, CAT_1, AMI_1, SCMFSA8A,
      XXREAL_0, CIRCUIT2, FUNCT_4, CARD_1, RELAT_1, ARYTM_3, AMISTD_2, GRAPHSP,
      AMI_3, SCMNORM, TARSKI, FUNCT_1, ARYTM_1, TURING_1, SCMFSA6C,
      FUNCOP_1, SCMFSA6A, SCMFSA6B, XBOOLE_0, MSUALG_1, UNIALG_2, SCMFSA7B,
      GLIB_000, SF_MASTR, STRUCT_0, NAT_1, SCMFSA8B, FUNCT_7, SCMFSA8C,
      ORDINAL1, PARTFUN1, RELOC, PBOOLE;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, FUNCOP_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7, PBOOLE,
      AFINSQ_1, STRUCT_0, COMPOS_1, EXTPRO_1, AMI_1, AMISTD_2, SCMFSA_2,
      SF_MASTR, SCMFSA6A, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B,
      NAT_D, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, SCMFSA6A, SF_MASTR,
      SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B, AMISTD_2, NAT_D, AMI_3,
      RELSET_1, PRE_POLY, SCMFSA7B, AMI_1, AMISTD_1, PBOOLE, SCMFSA_7;
 registrations SETFAM_1, FUNCT_1, FUNCOP_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, AMI_1, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SCMFSA8B, ORDINAL1, XBOOLE_0, AFINSQ_1, VALUED_1, RELAT_1,
      SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1, PBOOLE, FUNCT_4;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_1, SCMFSA8A, SCMFSA6A, AMISTD_2,
      SCMFSA6B;
 theorems FUNCT_4, SCMFSA_4, SCMFSA6A, SCMFSA8B, AMI_1, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SF_MASTR, NAT_1, SCMFSA6B, GRFUNC_1, SCMFSA_2,
      FUNCT_1, FUNCT_7, TARSKI, ENUMSET1, FUNCOP_1, RELAT_1, SCMFSA_3, INT_1,
      XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0, EXTPRO_1,
      AFINSQ_1, XREAL_0, PBOOLE, PARTFUN1, SCMFSA10, COMPOS_1, AMISTD_2;
 schemes NAT_1;
 constructors WELLORD2, INT_2, SCMFSA_2, VALUED_1;
 registrations RELSET_1, FINSET_1, STRUCT_0;

begin :: Preliminaries

reserve m for Element of NAT;
reserve P,PP,P1,P2
 for (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;

set SA0 = Start-At(0,SCM+FSA);
set Q = intloc 0 .--> 1;

canceled;

theorem Th2:
  for s being State of SCM+FSA,I being initial FinPartState of
  SCM+FSA st I is_pseudo-closed_on s,P
  for k being Element of NAT st
    for n being Element of NAT st n <= k
     holds IC Comput(P +* ProgramPart I,
        s +* (Initialize I),n) in dom I
  holds k < pseudo-LifeSpan(s,P,I)
proof
  let s be State of SCM+FSA;
  let I be initial FinPartState of SCM+FSA;
  assume I is_pseudo-closed_on s,P;
  then
  IC Comput(P +* ProgramPart I,
    (s +* (Initialize I)),pseudo-LifeSpan(s,P,I))
   = card ProgramPart I by SCMFSA8A:def 5;
  then
A1: not IC Comput(P +* ProgramPart I, s +* (Initialize I),
      pseudo-LifeSpan(s,P,I)) in dom ProgramPart I;
  let k be Element of NAT;
  assume
A2: for n being Element of NAT st n <= k
    holds IC Comput(P +* ProgramPart I,
      (s +* (Initialize I)),n) in dom I;
  assume pseudo-LifeSpan(s,P,I) <= k;
  hence contradiction by A2,A1,COMPOS_1:16;
end;

canceled 10;

theorem Th13:
  for I,J being Program of SCM+FSA, k being Element of NAT
     st card I <= k & k < card I + card J
  for i being Instruction of SCM+FSA st i = J.(k -' card I)
   holds (I ';' J). k = IncAddr(i,card I)
proof
  let I,J be Program of SCM+FSA;
  let k be Element of NAT;
  assume
A1: card I <= k;
  assume k < card I + card J;
  then
A2: k + 0 < card J + card I;
  k -' card I = k - card I by A1,XREAL_1:235;
  then k -' card I < card J - 0 by A2,XREAL_1:23;
  then
A3:  (k -' card I) in dom J by AFINSQ_1:70;
  let i be Instruction of SCM+FSA;
  assume
A4: i = J. (k -' card I);
A5: k -' card I + card I = k - card I + card I by A1,XREAL_1:235
    .= k;
  then  k in {m + card I: m in dom J} by A3;
  then  k in dom Reloc(J, card I) by COMPOS_1:117;
  then
  k in dom Reloc(J, card I);
  hence (I ';' J). k = (Reloc(J,card I)). k by FUNCT_4:14
    .= IncAddr(i,card I) by A4,A3,A5,COMPOS_1:122;
end;

theorem Th14:
  for s being State of SCM+FSA st s.intloc 0 = 1 & IC s =  0
  holds Initialized s = s
proof
  let s be State of SCM+FSA;
  assume
A1: s.intloc 0 = 1;
  assume
A2: IC s =  0;
A3: IC SCM+FSA in dom s by COMPOS_1:9;
A4: intloc 0 in dom s by SCMFSA_2:66;
  thus Initialized s = Initialize(s +* ((intloc 0) .--> 1)) by FUNCT_4:15
  .= s +* (IC SCM+FSA .-->  0) by A1,A4,FUNCT_7:111
    .= s by A2,A3,FUNCT_7:111;
end;

theorem Th15:
  for s being State of SCM+FSA holds Initialized Initialized s =
  Initialized s
proof
  let s be State of SCM+FSA;
A1: IC Initialized s =  0 by SCMFSA6C:3;
  (Initialized s).intloc 0 = 1 by SCMFSA6C:3;
  hence thesis by A1,Th14;
end;

theorem Th16:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
   s +* (Initialize Initialized I) =
    Initialized s +* (Initialize I)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  Initialized I = Initialize(I +* ((intloc 0) .--> 1)) by FUNCT_4:15;
  then SA0 c= Initialized I by FUNCT_4:26;
  hence s +* (Initialize Initialized I) =
  s +* Initialized I by FUNCT_4:79
    .= Initialized s +* (Initialize I) by SCMFSA8A:13;
end;

theorem Th17:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  IExec(I,P,s) = IExec(I,P,Initialized s)
proof
  let s be State of SCM+FSA;
  set A = NAT;
  set D = Data-Locations SCM+FSA;
  let I be Program of SCM+FSA;
A1: for x be set st x in A holds s.x = (Initialized s).x by SCMFSA6C:3;
  dom Initialized s = D \/ {IC SCM+FSA} \/ A by COMPOS_1:172;
  then
A2: A c= dom Initialized s by XBOOLE_1:7;
  dom s = D \/ {IC SCM+FSA} \/ A by COMPOS_1:172;
  then A c= dom s by XBOOLE_1:7;
  then
A3: s | A = (Initialized s) | A by A2,A1,FUNCT_1:165;
A4: Initialized s +* Initialized I = s +* Initialized I by SCMFSA8A:8;
  thus IExec(I,P,s)
   = Result(P +* I,s +* Initialized I) +* (s|NAT)
    .= IExec(I,P,Initialized s) by A3,A4;
end;

theorem Th18:
  for s being State of SCM+FSA, I being Program of SCM+FSA
   st s.intloc 0 = 1
  holds s +* Initialize I = s +* Initialized I
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
A1: intloc 0 in dom s by SCMFSA_2:66;
  assume s.intloc 0 = 1;
  then
A2: s = s +* Q by A1,FUNCT_7:111;
A3: Initialized s = Initialize(s +* ((intloc 0) .--> 1)) by FUNCT_4:15;
  thus s +* Initialized I = Initialized s +* (Initialize I) by SCMFSA8A:13
    .= Initialize(Initialized s +* I) by FUNCT_4:15
    .= Initialize Initialized s +* I by COMPOS_1:83
    .= Initialize s +* I by A2,A3
    .= Initialize(s +* I) by COMPOS_1:83
    .= s +* Initialize I by FUNCT_4:15;
end;

theorem Th19:
  for I being Program of SCM+FSA holds Initialize I c=
  Initialized I
proof
  let I be Program of SCM+FSA;
  Initialized I = Initialize(I +* ((intloc 0) .--> 1)) by FUNCT_4:15;
  then
A1: SA0 c= Initialized I by FUNCT_4:26;
  I c= Initialized I by SCMFSA6A:26;
  hence thesis by A1,FUNCT_4:92;
end;

theorem Th20:
  for l being Element of NAT, I being Program of
  SCM+FSA holds l in dom I iff l in dom Initialized I
proof
  let l be Element of NAT;
  let I be Program of SCM+FSA;
A1: (Initialized I) | NAT = I by SCMFSA6A:33;
  dom ((Initialized I) | NAT) c= dom Initialized I by RELAT_1:89;
  hence l in dom I implies l in dom Initialized I by A1;
A2: dom ((Initialized I) | NAT) = dom Initialized I /\ NAT by RELAT_1:90;
  assume l in dom Initialized I;
  hence thesis by A1,A2,XBOOLE_0:def 4;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  Initialized I is_closed_on s,P iff I is_closed_on Initialized s,P
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
A1: ProgramPart I = I by RELAT_1:209;
A2: ProgramPart Initialized I = I by SCMFSA6A:33;
  hereby
    assume
A3: Initialized I is_closed_on s,P;
    now
      let k be Element of NAT;
A4:  s +* (Initialize Initialized I) =
    Initialized s +* (Initialize I) by Th16;
      IC Comput(P +* I, s +* (Initialize Initialized I),k)
       in
      dom Initialized I by A3,SCMFSA7B:def 7,A2;
      then
      IC Comput(P +* I, Initialized s +* (Initialize I),k)
       in dom
      Initialized I by A4;
      hence IC Comput(P +* I, (Initialized s +* (Initialize I)),k)
          in dom I by Th20;
    end;
    hence I is_closed_on Initialized s,P by SCMFSA7B:def 7,A1;
  end;
  assume
A5: I is_closed_on Initialized s,P;
  now
    let k be Element of NAT;
A6:  s +* (Initialize Initialized I) =
    Initialized s +* (Initialize I) by Th16;
    IC Comput(P +* I, Initialized s +* (Initialize I),k)
     in dom I
    by A5,SCMFSA7B:def 7,A1;
    then IC Comput(P +* I, Initialized s +* (Initialize I),k)
     in dom
    Initialized I by Th20;
    hence
    IC Comput(P +* I, s +* (Initialize Initialized I),k)
     in dom Initialized I by A6;
  end;
  hence thesis by SCMFSA7B:def 7,A2;
end;

theorem Th22:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  Initialized I is_halting_on s,P iff I is_halting_on Initialized s,P
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
A1: ProgramPart I = I by RELAT_1:209;
A2: ProgramPart Initialized I = I by SCMFSA6A:33;
A3:  s +* (Initialize Initialized I)
    = Initialized s +* (Initialize I) by Th16;
  hereby
    assume Initialized I is_halting_on s,P;
    then P +* I
     halts_on s +* (Initialize Initialized I)
     by SCMFSA7B:def 8,A2;
    then P +* I
   halts_on Initialized s +* (Initialize I) by A3;
    hence I is_halting_on Initialized s,P by SCMFSA7B:def 8,A1;
  end;
  assume I is_halting_on Initialized s,P;
  then P +* I
   halts_on Initialized s +* (Initialize I)
   by SCMFSA7B:def 8,A1;
  then  P +* I
     halts_on s +* (Initialize Initialized I) by A3;
  hence thesis by SCMFSA7B:def 8,A2;
end;

theorem
  for I being Program of SCM+FSA holds
   (for s being State of SCM+FSA, P
  holds I is_halting_on Initialized s,P)
    implies Initialized I is halting
proof
  let I be Program of SCM+FSA;
A1: ProgramPart I = I by RELAT_1:209;
A2: ProgramPart Initialized I = I by SCMFSA6A:33;
  assume
A3: for s being State of SCM+FSA,P holds I is_halting_on Initialized s,P;
  now
    let s be State of SCM+FSA;
    assume
   Initialized I c= s;
     then
A4:   s +* Initialized I = s by FUNCT_4:79;
    let P1 such that
A5:  I c= P1;
A6: P1 +* I = P1 by A5,FUNCT_4:79;
    I is_halting_on Initialized s,P1 by A3;
    then
A7:   P1 +* I
     halts_on Initialized s +* (Initialize I)
     by SCMFSA7B:def 8,A1;
    Initialized s +* (Initialize I) = s +* Initialized I
                      by SCMFSA8A:13;
    then
 P1 +* I halts_on s +* Initialized I by A7;
    hence P1 halts_on s by A4,A6;
  end;
  hence thesis by EXTPRO_1:def 10,A2;
end;

theorem Th24:
  for I being Program of SCM+FSA holds (for s being State of
  SCM+FSA, P holds Initialized I is_halting_on s,P)
   implies Initialized I is halting
proof
  let I be Program of SCM+FSA;
A1: ProgramPart Initialized I = I by SCMFSA6A:33;
  assume
A2: for s being State of SCM+FSA, P holds Initialized I is_halting_on s,P;
  now
    let s be State of SCM+FSA;
    assume
A3:   Initialized I c= s;
    let P such that
A4:  I c= P;
A5: P +* I = P by A4,FUNCT_4:79;
     Initialized I = Initialize(I +* ((intloc 0) .--> 1)) by FUNCT_4:15;
     then SA0 c= Initialized I by FUNCT_4:26;
    then
A6: s +* (Initialize Initialized I) = s +* Initialized I by
FUNCT_4:79;
    Initialized I is_halting_on s,P by A2;
    then
A7: P +* I
     halts_on s +* (Initialize Initialized I)
            by SCMFSA7B:def 8,A1;
   s +* (Initialize Initialized I) = s
     by A3,A6,FUNCT_4:79;
    hence P halts_on s by A7,A5;
  end;
  hence thesis by EXTPRO_1:def 10,A1;
end;

canceled; ::SCMFSA6A:33;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA, l
being Element of NAT, x being set holds x in dom I implies I.x
  = (s +* (I +* Start-At(l,SCM+FSA))).x
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let l be Element of NAT;
  let x be set;
  assume
A1: x in dom I;
  reconsider y = x as Element of NAT by A1;
A2: not y in dom Start-At(l,SCM+FSA) by COMPOS_1:29;
  x in dom (I +* Start-At(l,SCM+FSA)) by A1,FUNCT_4:13;
  hence (s +* (I +* Start-At(l,SCM+FSA))).x = (I +* Start-At(l,SCM+FSA)).x
  by FUNCT_4:14
    .= I.x by A2,FUNCT_4:12;
end;

theorem Th27:
  for s being State of SCM+FSA st s.intloc 0 = 1 holds DataPart
  Initialized s = DataPart s
proof
  let s be State of SCM+FSA;
  assume
A1: s.intloc 0 = 1;
A2: intloc 0 in dom s by SCMFSA_2:66;
    Initialized s = Initialize(s +* ((intloc 0) .--> 1)) by FUNCT_4:15;
  then Initialized s = Initialize s by A1,A2,FUNCT_7:111;
  hence thesis by SCMFSA8A:10;
end;

theorem Th28:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
  being Int-Location, l being Element of NAT holds
  (s +* (I +* Start-At(l,SCM+FSA))).a = s.a
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  let l be Element of NAT;
  not a in dom (I +* Start-At(l,SCM+FSA)) by SCMFSA6B:12;
  hence thesis by FUNCT_4:12;
end;

theorem
  for I being preProgram of SCM+FSA, l being Element of NAT
   holds IC SCM+FSA in dom (I +* Start-At(l,SCM+FSA))
proof
  let I be preProgram of SCM+FSA;
  let l be Element of NAT;
  dom Start-At(l,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
  then IC SCM+FSA in dom Start-At(l,SCM+FSA) by TARSKI:def 1;
  hence thesis by FUNCT_4:13;
end;

theorem
  for I being preProgram of SCM+FSA, l being Element of NAT
   holds (I +* Start-At(l,SCM+FSA)).IC SCM+FSA = l
proof
  let I be preProgram of SCM+FSA;
  let l be Element of NAT;
  dom Start-At(l,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
  then
A1: IC SCM+FSA in dom Start-At(l,SCM+FSA) by TARSKI:def 1;
  (Start-At(l,SCM+FSA)).IC SCM+FSA = l by FUNCOP_1:87;
  hence thesis by A1,FUNCT_4:14;
end;

theorem Th31:
  for s being State of SCM+FSA, I being FinPartState of SCM+FSA, l
  being Element of NAT holds IC (s +* (I +* Start-At(l,SCM+FSA))) = l
proof
  let s be State of SCM+FSA;
  let I be FinPartState of SCM+FSA;
  let l be Element of NAT;
  thus IC (s +* (I +* Start-At(l,SCM+FSA))) = IC (s +* I +*
  Start-At(l,SCM+FSA)) by FUNCT_4:15
    .= l by FUNCT_4:121;
end;

theorem Th32:
  for s being State of SCM+FSA, i being Instruction of SCM+FSA st
  InsCode i in {0,6,7,8} holds DataPart Exec(i,s) = DataPart s
proof
  let s be State of SCM+FSA;
  let i be Instruction of SCM+FSA;
  assume
A1: InsCode i in {0,6,7,8};
  now
    let a be Int-Location;
    let f be FinSeq-Location;
    per cases by A1,ENUMSET1:def 2;
    suppose
      InsCode i = 0;
      then i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s).a = s.a & Exec(i,s).f = s.f by EXTPRO_1:def 3;
    end;
    suppose
      InsCode i = 6;
      then ex lb being Element of NAT st i = goto lb by SCMFSA_2:59;
      hence Exec(i,s).a = s.a & Exec(i,s).f = s.f by SCMFSA_2:95;
    end;
    suppose
      InsCode i = 7;
      then
      ex lb being Element of NAT, b being Int-Location st
      i = b=0_goto lb by SCMFSA_2:60;
      hence Exec(i,s).a = s.a & Exec(i,s).f = s.f by SCMFSA_2:96;
    end;
    suppose
      InsCode i = 8;
      then
      ex lb being Element of NAT, b being Int-Location st
      i = b>0_goto lb by SCMFSA_2:61;
      hence Exec(i,s).a = s.a & Exec(i,s).f = s.f by SCMFSA_2:97;
    end;
  end;
  hence thesis by SCMFSA6A:38;
end;

theorem Th33:
  for s1,s2 being State of SCM+FSA st s1.intloc 0 = s2.intloc 0 &
  ((for a being read-write Int-Location holds s1.a = s2.a) & for f being
  FinSeq-Location holds s1.f = s2.f) holds DataPart s1 = DataPart s2
proof
  let s1,s2 be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  assume
A1: s1.intloc 0 = s2.intloc 0;
  assume
A2: for a being read-write Int-Location holds s1.a = s2.a;
A3: dom DataPart s1 = dom s1 /\ D by RELAT_1:90
    .= (Data-Locations SCM+FSA \/ {IC SCM+FSA} \/ NAT) /\ D by
COMPOS_1:172
    .= dom s2 /\ D by COMPOS_1:172
    .= dom DataPart s2 by RELAT_1:90;
  assume
A4: for f being FinSeq-Location holds s1.f = s2.f;
  now
    let x be set;
    assume
A5: x in dom DataPart s1;
    then
A6: x in dom s1 /\ D by RELAT_1:90;
    then
A7: x in dom s1 by XBOOLE_0:def 4;
A8: x in D by A6,XBOOLE_0:def 4;
    per cases by A7,SCMFSA6A:35;
    suppose
A9:   x is Int-Location;
      hereby
        per cases;
        suppose
A10:      x is read-write Int-Location;
          thus (DataPart s1).x = s1.x by A5,FUNCT_1:70
            .= s2.x by A2,A10
            .= (DataPart s2).x by A3,A5,FUNCT_1:70;
        end;
        suppose
A11:      not x is read-write Int-Location;
          reconsider a = x as Int-Location by A9;
          a = intloc 0 by A11,SF_MASTR:def 5;
          hence (DataPart s1).x = s2.a by A1,A5,FUNCT_1:70
            .= (DataPart s2).x by A3,A5,FUNCT_1:70;
        end;
      end;
    end;
    suppose
A12:  x is FinSeq-Location;
      thus (DataPart s1).x = s1.x by A5,FUNCT_1:70
        .= s2.x by A4,A12
        .= (DataPart s2).x by A3,A5,FUNCT_1:70;
    end;
    suppose
A13:  x = IC SCM+FSA;
      assume not (DataPart s1).x = (DataPart s2).x;
      thus contradiction by A6,A13,SCMFSA6A:37,XBOOLE_0:def 4;
    end;
    suppose
A14:  x is Element of NAT;
      assume not (DataPart s1).x = (DataPart s2).x;
      thus contradiction by A8,A14,SCMFSA6A:37;
    end;
  end;
  then DataPart s1 c= DataPart s2 by A3,GRFUNC_1:8;
  hence thesis by A3,GRFUNC_1:9;
end;

canceled 2;     ::: COMPOS_1:82

theorem Th36:
  for s being State of SCM+FSA holds (Initialized s) | NAT = s | NAT
proof
  let s be State of SCM+FSA;
  set A = NAT;
  now
    let x be set;
A1: dom Q = {intloc 0} by FUNCOP_1:19;
    assume x in A;
    then reconsider l = x as Element of NAT;
A2: not l in dom SA0 by COMPOS_1:29;
    l <> intloc 0 by SCMFSA_2:84;
    then not x in dom Q by A1,TARSKI:def 1;
    hence not x in dom Q \/ dom SA0
    by A2,XBOOLE_0:def 3;
  end;
  then dom Q \/ dom SA0 misses A
  by XBOOLE_0:3;
  then
A3: dom (Initialize Q) misses A by FUNCT_4:def 1;
  Initialized s = s +* (Initialize Q) by FUNCT_4:15;
  hence thesis by A3,FUNCT_4:76;
end;

canceled; :::  COMPOS_1:82

theorem Th38:
  for s being State of SCM+FSA holds IExec(Stop SCM+FSA,P,s) =
  Initialize Initialized s
proof
  let s be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  set A = NAT;
  set s1 = Initialized s +* (Initialize Stop SCM+FSA),
      P1 = P +* Stop SCM+FSA;
A1: Stop SCM+FSA c= P1 by FUNCT_4:26;
A2: s1 = Comput(P1, s1,0) by EXTPRO_1:3;
A3:  P1/.IC s1 = P1.IC s1 by PBOOLE:158;
A4: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
A5:  0 in dom Stop SCM+FSA by COMPOS_1:45;
A6: s +* Initialized Stop SCM+FSA = s1 by SCMFSA8A:13;
  then
A7: CurInstr(P1,s1) = P1. 0 by A3,FUNCT_4:26,SCMFSA6B:34
    .= (Stop SCM+FSA). 0 by A5,A1,GRFUNC_1:8;
  then P1 halts_on s1 by A2,A4,EXTPRO_1:30;
  then
A8: IExec(Stop SCM+FSA,P,s) = s1 +* (s|NAT) by A6,A7,A2,A4,EXTPRO_1:def 8;
  then
A9: DataPart IExec(Stop SCM+FSA,P,s) = DataPart s1 by COMPOS_1:82
    .= DataPart Initialized s by SCMFSA8A:11;
  hereby
A10: dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
A11: now
      let x be set;
      assume
A12:   x in dom IExec(Stop SCM+FSA,P,s);
      per cases by A12,SCMFSA6A:35;
      suppose
A13:    x is Int-Location;
        then x <> IC SCM+FSA by SCMFSA_2:81;
        then
A14:    not x in dom SA0 by A10,TARSKI:def 1;
        IExec(Stop SCM+FSA,P,s).x = (Initialized s).x by A9,A13,SCMFSA6A:38;
        hence IExec(Stop SCM+FSA,P,s).x = (Initialize Initialized s).x
        by A14,FUNCT_4:12;
      end;
      suppose
A15:    x is FinSeq-Location;
        then x <> IC SCM+FSA by SCMFSA_2:82;
        then
A16:    not x in dom SA0 by A10,TARSKI:def 1;
        IExec(Stop SCM+FSA,P,s).x = (Initialized s).x by A9,A15,SCMFSA6A:38;
        hence IExec(Stop SCM+FSA,P,s).x = (Initialize Initialized s).x
        by A16,FUNCT_4:12;
      end;
      suppose
A17:    x = IC SCM+FSA;
        then x in {IC SCM+FSA} by TARSKI:def 1;
        then
A18:    x in dom SA0 by FUNCOP_1:19;
        not x in dom(s|NAT) by A17,COMPOS_1:139;
        hence IExec(Stop SCM+FSA,P,s).x
           = s1.IC SCM+FSA by A8,A17,FUNCT_4:12
          .= (Initialize (Initialized s +* Stop SCM+FSA)).IC SCM+FSA
        by FUNCT_4:15
          .= (SA0).IC SCM+FSA by A17,A18,FUNCT_4:14
          .= (Initialize Initialized s).x
          by A17,A18,FUNCT_4:14;
      end;
      suppose
A19:    x is Element of NAT;
        then x <> IC SCM+FSA by COMPOS_1:3;
        then
A20:    not x in dom SA0 by A10,TARSKI:def 1;
     dom ProgramPart s = NAT by COMPOS_1:34;
        then x in dom ProgramPart s by A19;
        hence IExec(Stop SCM+FSA,P,s).x
         = (s|NAT).x by FUNCT_4:14
        .= ((Initialized s)|NAT).x by Th36
        .= (Initialized s).x by A19,FUNCT_1:72
        .= (Initialize Initialized s).x
        by A20,FUNCT_4:12;
      end;
    end;
    dom IExec(Stop SCM+FSA,P,s) = the carrier of SCM+FSA by PARTFUN1:def 4
      .= dom (Initialize Initialized s) by PARTFUN1:def 4;
    hence thesis by A11,FUNCT_1:9;
  end;
end;

theorem Th39:
  for s being State of SCM+FSA,I being Program of SCM+FSA st I
  is_closed_on s,P holds  0 in dom I
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
A1: ProgramPart I = I by RELAT_1:209;
  reconsider n = IC Comput(P +* I, (s
+* (Initialize I)),0)
   as Element
  of NAT;
  assume
A2: I is_closed_on s,P;
  then
A3:  n in dom I by SCMFSA7B:def 7,A1;
  per cases;
  suppose
    n = 0;
    hence thesis by A2,SCMFSA7B:def 7,A1;
  end;
  suppose
    0 < n;
    hence thesis by A3,AFINSQ_1:def 13;
  end;
end;

canceled 2;

theorem Th42:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA
   st I is_closed_on s1,P1 &
     Initialize I c= s1 & I c= P1
  for n being Element of NAT st
   Reloc(I,n) c= P2 & IC s2 =  n & DataPart s1 = DataPart s2
  for i being Element of NAT holds
   IC Comput(P1, s1,i) + n = IC Comput(P2, s2,i) &
   IncAddr(CurInstr(P1,Comput(P1,s1,i)),n)
        = CurInstr(P2,Comput(P2,s2,i)) &
  DataPart Comput(P1, s1,i) = DataPart Comput(P2,s2,i)
proof
  let s1,s2 be State of SCM+FSA;
  let J be Program of SCM+FSA;
  set JAt = Initialize J;
  assume
A1: J is_closed_on s1,P1;
  then
A2:  0 in dom J by Th39;
  assume that
A3: Initialize J c= s1 and
A4: J c= P1;
   SA0 c= Initialize J by FUNCT_4:26;
   then SA0 c= s1 by A3,XBOOLE_1:1;
   then
A5: Initialize s1 = s1 by FUNCT_4:79;
A6: IC SCM+FSA in dom JAt by COMPOS_1:141;
A7: P1.IC s1 :::= P1.IC JAt by A5,GRFUNC_1:8
     = P1. 0 by A5,COMPOS_1:142
    .= J. 0 by A2,GRFUNC_1:8,A4;
A8: P1 = P1 +* J by A4,FUNCT_4:79;
A9: IC Comput(P1,s1,0) = s1.IC SCM+FSA by EXTPRO_1:3
    .= IC JAt by A3,A6,GRFUNC_1:8
    .=  0 by COMPOS_1:142;
A10:  0 in dom J by A1,Th39;
  let n be Element of NAT;
  defpred P[Nat] means IC Comput(P1,s1,$1) + n
    = IC Comput(P2,s2,$1) &
   IncAddr(CurInstr(P1,Comput(P1,s1,$1)),n) =
     CurInstr(P2,Comput(P2,s2,$1)) &
    DataPart Comput(P1,s1,$1) = DataPart Comput(P2,s2,$1);
  assume that
A11: Reloc(J,n) c= P2 and
A12: IC s2 =  n and
A13: DataPart s1 = DataPart s2;
  let i be Element of NAT;
A14: DataPart Comput(P1,s1,0) = DataPart s2 by A13,EXTPRO_1:3
    .= DataPart Comput(P2,s2,0) by EXTPRO_1:3;
A15: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
A16: Comput(P1,s1,k+1) = Following(P1,
Comput(P1,s1,k)) by EXTPRO_1:4
      .= Exec(CurInstr(P1,Comput(P1,s1,k)),
      Comput(P1,s1,k));
    reconsider l = IC Comput(P1,s1,k+1) as Element of NAT;
    reconsider
     j = CurInstr(P1,Comput(P1,s1,k+1))
     as Instruction of SCM+FSA;
A17:  P1/.IC Comput(P1,s1,k+1) = P1.IC Comput(P1,s1,k+1) by PBOOLE:158;
A18: Comput(P2,s2,k+1) = Following(P2,
Comput(P2,s2,k)) by EXTPRO_1:4
      .= Exec(CurInstr(P2,Comput(P2,s2,k)),
      Comput(P2,s2,k));
A19: ProgramPart J = J by RELAT_1:209;
    s1 +* (Initialize J) = s1 by A3,FUNCT_4:79;
    then
A20: IC Comput(P1,s1,k+1) in dom J by A1,SCMFSA7B:def 7,A19,A8;
    assume
A21: P[k];
    hence
A22: IC Comput(P1,s1,k+1) + n = IC Comput(P2,s2,k+1)
by A16,A18,SCMFSA6A:41;
    then IC Comput(P2,s2,k+1) in dom Reloc(J,n) by A20,
COMPOS_1:158;
    then
A23: IC Comput(P2,s2,k+1) in dom Reloc(J,n);
A24: l in dom J by A20;
A25:  P2/.IC Comput(P2,s2,k+1)
 = P2.IC Comput(P2,s2,k+1) by PBOOLE:158;
    j = P1.IC Comput(P1,s1,k+1) by A17
:::      .= (JAt).IC Comput(P1,s1,k+1) by A5,A16,A20,GRFUNC_1:8
      .= J.l by A20,GRFUNC_1:8,A4;
    hence IncAddr(CurInstr(P1,Comput(P1,s1,k+1)),n)
     = Reloc(J,n).(l + n) by A24,COMPOS_1:122
      .= P2.IC Comput(P2,s2,k+1) by A11,A22,A23,GRFUNC_1:8
      .= CurInstr(P2,Comput(P2,s2,k+1))
       by A25;
    thus thesis by A21,A16,A18,SCMFSA6A:41;
  end;
   0 in dom J by A1,Th39;
  then  0 + n in dom Reloc(J,n) by COMPOS_1:158;
  then
A26:  (0 + n) in dom Reloc(J,n);
A27:  P1/.IC s1 = P1.IC s1 by PBOOLE:158;
A28:  P2/.IC s2 = P2.IC s2 by PBOOLE:158;
A29: Comput(P1,s1,0) = s1 by EXTPRO_1:3;
A30: Comput(P2,s2,0) = s2 by EXTPRO_1:3;
  IncAddr(CurInstr(P1,Comput(P1,s1,0)),n)
    = Reloc(J,n). (0 + n) by A10,A27,COMPOS_1:122,A29,A7
    .= CurInstr(P2,Comput(P2,s2,0))
     by A30,A11,A12,A26,A28,GRFUNC_1:8;
  then
A31: P[0] by A12,A9,A14,EXTPRO_1:3;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A31,A15);
  hence thesis;
end;

theorem Th43:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA
   st I is_closed_on s1,P1 & Initialize I c= s1 &
   Initialize I c= s2 & I c= P1 & I c= P2 &
   DataPart s1 = DataPart s2
  for i being Element of NAT
  holds IC Comput(P1, s1,i) = IC Comput(P2, s2,i) &
  CurInstr(P1,Comput(P1,s1,i)) = CurInstr(P2,Comput(P2,s2,i)) &
  DataPart Comput(P1, s1,i) = DataPart Comput(P2,s2,i)
proof
  let s1,s2 be State of SCM+FSA;
  let J be Program of SCM+FSA;
  assume that
A1: J is_closed_on s1,P1 and
A2: Initialize J c= s1 and
A3: Initialize J c= s2 and
A4: J c= P1 and
A5: J c= P2 and
A6: DataPart s1 = DataPart s2;
A7: Reloc(J,0) = J by COMPOS_1:157;
  let i be Element of NAT;
A8: IC Comput(P1, s1,i) + 0 = IC Comput(P1, s1,i);
A9: IC s2 = IC (s2 +* (Initialize J)) by A3,FUNCT_4:79
    .= IC (Initialize (s2 +* J)) by FUNCT_4:15
    .=  0 by FUNCT_4:121;
  IncAddr(CurInstr(P1,Comput(P1,s1,i)),0)
   = CurInstr(P1,Comput(P1,s1,i)) by COMPOS_1:91;
  hence thesis by A1,A2,A6,A8,A9,Th42,A4,A5,A7;
end;

theorem Th44:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st I
  is_closed_on s1,P1 & I is_halting_on s1,P1 & Initialize I c= s1
   & Initialize I c= s2 & I c= P1 & I c= P2 &
    DataPart s1 = DataPart s2
  holds LifeSpan(P1,s1) = LifeSpan(P2,s2)
proof
  let s1,s2 be State of SCM+FSA;
  let J be Program of SCM+FSA;
  assume that
A1: J is_closed_on s1,P1 and
A2: J is_halting_on s1,P1 and
A3: Initialize J c= s1 and
A4: Initialize J c= s2 and
A5: J c= P1 and
A6: J c= P2 and
A7: DataPart s1 = DataPart s2;
A8: ProgramPart J = J by RELAT_1:209;
A9: P1 = P1 +* J by A5,FUNCT_4:79;
  s1 = s1 +* (Initialize J) by A3,FUNCT_4:79;
  then
A10: P1 halts_on s1 by A2,SCMFSA7B:def 8,A8,A9;
A11: now
    let k be Element of NAT;
    assume
    CurInstr(P2,Comput(P2,s2,k)) = halt SCM+FSA;
    then CurInstr(P1,Comput(P1,s1,k))
     = halt SCM+FSA by A1,A3,A4,A7,Th43,A5,A6;
    hence LifeSpan(P1,s1) <= k by A10,EXTPRO_1:def 14;
  end;
  CurInstr(P1,
Comput(P1,s1,LifeSpan(P1,s1)))
   = halt SCM+FSA by A10,EXTPRO_1:def 14;
  then
A12: CurInstr(P2,
Comput(P2,s2,LifeSpan(P1,s1)))
 = halt SCM+FSA by A1,A3,A4,A7,Th43,A5,A6;
  then P2 halts_on s2 by EXTPRO_1:30;
  hence thesis by A12,A11,EXTPRO_1:def 14;
end;

theorem Th45:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
  s1.intloc 0 = 1 & I is_closed_on s1,P1 & I is_halting_on s1,P1 &
   ((for a being read-write Int-Location holds s1.a = s2.a) &
  for f being FinSeq-Location holds s1.f = s2.f)
  holds DataPart IExec(I,P1,s1) = DataPart IExec(I,P2,s2)
proof
  let s1,s2 be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let I be Program of SCM+FSA;
  set s11 = s1 +* Initialized I,
      P11 = P1 +* I;
  set s21 = s2 +* Initialized I,
      P21 = P2 +* I;
A1: Initialize I c= Initialized I by Th19;
  Initialized I c= s11 by FUNCT_4:26;
  then
A2: Initialize I c= s11 by A1,XBOOLE_1:1;
  Initialized I c= s21 by FUNCT_4:26;
  then
A3: Initialize I c= s21 by A1,XBOOLE_1:1;
  assume s1.intloc 0 = 1;
  then
A4: s11 = s1 +* Initialize I by Th18;
  then
A5: DataPart s11 = DataPart s1 by SCMFSA8A:11;
  assume that
A6: I is_closed_on s1,P1 and
A7: I is_halting_on s1,P1;
A8: I is_closed_on s11,P11 by A6,A7,A5,SCMFSA8B:8;
  assume
A9: for a being read-write Int-Location holds s1.a = s2.a;
A10: now
    let a be read-write Int-Location;
A11: not a in dom Initialized I by SCMFSA6A:48;
    hence s11.a = s1.a by FUNCT_4:12
      .= s2.a by A9
      .= s21.a by A11,FUNCT_4:12;
  end;
  assume
A12: for f being FinSeq-Location holds s1.f = s2.f;
A13: now
    let f be FinSeq-Location;
A14: not f in dom Initialized I by SCMFSA6A:49;
    hence s11.f = s1.f by FUNCT_4:12
      .= s2.f by A12
      .= s21.f by A14,FUNCT_4:12;
  end;
A15: intloc 0 in dom Initialized I by SCMFSA6A:45;
  then s11.intloc 0 = (Initialized I).intloc 0 by FUNCT_4:14
    .= s21.intloc 0 by A15,FUNCT_4:14;
  then
A16: DataPart s11 = DataPart s21 by A10,A13,Th33;
A17: ProgramPart I = I by RELAT_1:209;
A18: I c= P21 by FUNCT_4:26;
A19: I c= P11 by FUNCT_4:26;
A20: P11 halts_on s11 by A7,A4,SCMFSA7B:def 8,A17;
  then CurInstr(P11,
  Comput(P11,s11,LifeSpan(P11,s11)))
  = halt SCM+FSA by EXTPRO_1:def 14;
  then CurInstr(P21,
  Comput(P21,s21,LifeSpan(P11,s11)))
   = halt SCM+FSA by A8,A16,A2,A3,Th43,A19,A18;
  then
A21: P21 halts_on s21 by EXTPRO_1:30;
  I is_halting_on s11,P11 by A6,A7,A5,SCMFSA8B:8;
  then
A22: LifeSpan(P11,s11) = LifeSpan(P21,s21) by A8,A16
,A2,A3,Th44,A19,A18;
  thus DataPart IExec(I,P1,s1) = DataPart Result(P11,s11) by
SCMFSA8B:35
    .= DataPart Comput(P11, s11,LifeSpan(P11,s11))
by A20,EXTPRO_1:23
    .= DataPart Comput(P21, s21,LifeSpan(P11,s11))
by A8,A16,A2,A3,Th43,A19,A18
    .= DataPart Result(P21,s21) by A22,A21,EXTPRO_1:23
    .= DataPart IExec(I,P2,s2) by SCMFSA8B:35;
end;

theorem Th46:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
  s1.intloc 0 = 1 & I is_closed_on s1,P1 & I is_halting_on s1,P1 &
  DataPart s1 =
  DataPart s2 holds DataPart IExec(I,P1,s1) = DataPart IExec(I,P2,s2)
proof
  let s1,s2 be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let I be Program of SCM+FSA;
  set s11 = s1 +* Initialized I,
      P11 = P1 +* I;
  set s21 = s2 +* Initialized I,
      P21 = P2 +* I;
A1: I c= P11 by FUNCT_4:26;
A2: I c= P21 by FUNCT_4:26;
  assume that
A3: s1.intloc 0 = 1 and
A4: I is_closed_on s1,P1 and
A5: I is_halting_on s1,P1 and
A6: DataPart s1 = DataPart s2;
A7: s11 = s1 +* Initialize I by A3,Th18;
  then
A8: DataPart s11 = DataPart s1 by SCMFSA8A:11;
  then
A9: I is_closed_on s11,P11 by A4,A5,SCMFSA8B:8;
  s2.intloc 0 = 1 by A3,A6,SCMFSA6A:38;
  then s21 = s2 +* Initialize I by Th18;
  then
A10: DataPart s11 = DataPart s21 by A6,A8,SCMFSA8A:11;
A11: Initialize I c= Initialized I by Th19;
  Initialized I c= s11 by FUNCT_4:26;
  then
A12: Initialize I c= s11 by A11,XBOOLE_1:1;
  Initialized I c= s21 by FUNCT_4:26;
  then
A13: Initialize I c= s21 by A11,XBOOLE_1:1;
  ProgramPart I = I by RELAT_1:209;
  then
A14: P11 halts_on s11 by A5,A7,SCMFSA7B:def 8;
  then CurInstr(P11,
  Comput(P11,s11,LifeSpan(P11,s11)))
  = halt SCM+FSA by EXTPRO_1:def 14;
  then CurInstr(P21,
  Comput(P21,s21,LifeSpan(P11,s11)))
   = halt SCM+FSA by A9,A10,A12,A13,Th43,A1,A2;
  then
A15: P21 halts_on s21 by EXTPRO_1:30;
  I is_halting_on s11,P11 by A4,A5,A8,SCMFSA8B:8;
  then
A16: LifeSpan(P11,s11) = LifeSpan(P21,s21) by A9,A10
,A12,A13,Th44,A1,A2;
  thus DataPart IExec(I,P1,s1) = DataPart Result(P11,s11) by
SCMFSA8B:35
    .= DataPart Comput(P11, s11,LifeSpan(P11,s11))
by A14,EXTPRO_1:23
    .= DataPart Comput(P21, s21,LifeSpan(P11,s11))
by A9,A10,A12,A13,Th43,A1,A2
    .= DataPart Result(P21,s21) by A16,A15,EXTPRO_1:23
    .= DataPart IExec(I,P2,s2) by SCMFSA8B:35;
end;

registration
  let I be Program of SCM+FSA;
  cluster Initialized I -> initial;
  correctness
  proof
    now
      let m,n be Nat;
      I c= Initialized I by SCMFSA6A:26;
      then
A1:   dom I c= dom Initialized I by GRFUNC_1:8;
A2:    n in NAT by ORDINAL1:def 13;
      assume n in dom Initialized I;
      then
A3:    n in dom I by A2,Th20;
      assume m < n;
      then  m in dom I by A3,AFINSQ_1:def 13;
      hence m in dom Initialized I by A1;
    end;
    hence thesis by AFINSQ_1:def 13;
  end;
end;

Lm1: now let P;
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set k = pseudo-LifeSpan(Initialized s,P,I);
A1: ProgramPart Initialized I = I by SCMFSA6A:33;
A2: ProgramPart I = I by RELAT_1:209;
  hereby
    set k = pseudo-LifeSpan(s,P,Initialized I);
A3:  s +* (Initialize Initialized I) =
    Initialized s +* (Initialize I) by Th16;
    assume
A4: Initialized I is_pseudo-closed_on s,P;

    then IC Comput(P +* I, (s +* (Initialize Initialized I)),k)
       = card I by SCMFSA8A:def 5,A1;
:::  IC Comput(P +* ProgramPart I,s+* (Initialize I),it)
:::   =  card ProgramPart I &

    then
    IC Comput(P +* I, (Initialized s +* (Initialize I)),k) =
    card I by A3;

    then
A5: IC Comput(P +* I, (Initialized s +* (Initialize I)),k) =
    card ProgramPart I by RELAT_1:209;

A6: now
      let n be Element of NAT;
A7:  s +* (Initialize Initialized I) =
    Initialized s +* (Initialize I) by Th16;
      assume n < k;

      then IC Comput(P +* I, (s +* (Initialize Initialized I)),n) in
      dom Initialized I by A4,SCMFSA8A:def 5,A1;

      then
      IC Comput(P +* I, (Initialized s +* (Initialize I)),n) in dom
      Initialized I by A7;

      hence IC Comput(P +* I, (Initialized s +* (Initialize I)),n) in
      dom I by Th20;

    end;
    hence
A8: I is_pseudo-closed_on Initialized s,P by A5,SCMFSA8A:def 3,A2;

    for n be Element of NAT st
     not IC Comput(P +* I, (Initialized s +* (Initialize I)), n) in dom I
     holds k <= n by A6;

    hence
    pseudo-LifeSpan(s,P,Initialized I) =
pseudo-LifeSpan(Initialized s,P,I) by A5,A8,SCMFSA8A:def 5,A2;

  end;
A9:  s +* (Initialize Initialized I) =
    Initialized s +* (Initialize I) by Th16;
  assume
A10: I is_pseudo-closed_on Initialized s,P;

  then IC Comput(P +* I,
   (
Initialized s +* (Initialize I)),k)
   =
  card ProgramPart I by SCMFSA8A:def 5,A2;

  then
  IC Comput(P +* I, (s +*
(Initialize Initialized I)),k)
   =
  card ProgramPart I by A9;

  then
A11: IC Comput(P +* I, (s
+* (Initialize Initialized I)),k)
 =
  card I by RELAT_1:209;

A12: now
    let n be Element of NAT;
A13:  s +* (Initialize Initialized I) =
    Initialized s +* (Initialize I) by Th16;
    assume n < k;

    then IC Comput(P +* I,
(Initialized s +* (Initialize I)),n)
     in dom
    I by A10,SCMFSA8A:def 5,A2;

    then
    IC Comput(P +* I, (s
+* (Initialize Initialized I)),n)
     in dom
    I by A13;

    hence
    IC Comput(P +* I, (s
+* (Initialize Initialized I)),n)
     in dom
    Initialized I by Th20;

  end;
  hence
A14: Initialized I is_pseudo-closed_on s,P by A11,SCMFSA8A:def 3,A1;

  for n be Element of NAT st
   not IC Comput(P +* I, (s +* (Initialize Initialized I)),n)
   in dom Initialized I holds k <= n by A12;

  hence pseudo-LifeSpan(s,P,Initialized I) =
pseudo-LifeSpan(Initialized s,P,I) by A11,A14,SCMFSA8A:def 5,A1;

end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  Initialized I is_pseudo-closed_on s,P
   iff I is_pseudo-closed_on Initialized s,P
by Lm1;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_pseudo-closed_on Initialized s,P
   holds pseudo-LifeSpan(s,P,Initialized I) =
  pseudo-LifeSpan(Initialized s,P,I) by Lm1;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA st
  Initialized I is_pseudo-closed_on s,P
   holds pseudo-LifeSpan(s,P,Initialized I) =
  pseudo-LifeSpan(Initialized s,P,I) by Lm1;

theorem Th50:
  for s being State of SCM+FSA,
      I being Program of SCM+FSA
       st I is_pseudo-closed_on s,P
 holds I is_pseudo-closed_on
    s +* (Initialize I),P+*I &
   pseudo-LifeSpan(s,P,I) =
pseudo-LifeSpan(s +* (Initialize I),P+*I,I)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s2 = s +* (Initialize I) +* (Initialize I),
      P2 = P +* I +* I;
A1: P2 = P +* I by FUNCT_4:99;
A2: s +* (Initialize I) +* (Initialize I)
 = s +* ((Initialize I) +* (Initialize I))
  by FUNCT_4:15
    .= s +* (Initialize I);
A3: ProgramPart I = I by RELAT_1:209;
  assume
A4: I is_pseudo-closed_on s,P;
  then
A5: for n being Element of NAT st not IC Comput(P2, s2,n) in dom I holds
  pseudo-LifeSpan(s,P,I) <= n by A2,SCMFSA8A:def 5,A3,A1;
A6: for n being Element of NAT st n < pseudo-LifeSpan(s,P,I)
holds IC
  Comput(P2, s2,n) in dom I by A4,A2,SCMFSA8A:def 5,A3,A1;
  IC Comput(P2, s2,pseudo-LifeSpan(s,P,I)) =  card I
by A4,A2,SCMFSA8A:def 5,A3,A1;
  hence
A7: I is_pseudo-closed_on s +* (Initialize I),P+*I
     by A6,SCMFSA8A:def 3,A3;
  IC Comput(P2, s2,pseudo-LifeSpan(s,P,I)) =  card I
by A4,A2,SCMFSA8A:def 5,A3,A1;
  hence thesis by A5,A7,SCMFSA8A:def 5,A3;
end;

theorem Th51:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
   Initialize I c= s1 & I c= P1 &
I is_pseudo-closed_on s1,P1
   for n being Element of NAT st Reloc(I,n) c= s2 & Reloc(I,n) c= P2 &
    IC s2 =  n & DataPart s1 =
  DataPart s2 holds ((for i being Element of NAT
   st i < pseudo-LifeSpan(s1,P1,I)
  holds IncAddr(CurInstr(P1,Comput(P1,s1,i)),n)
   = CurInstr(P2,Comput(P2,s2,i))) &
for i being Element of NAT st i <= pseudo-LifeSpan(s1,P1,I)
holds IC Comput(P1,
  s1,i) + n = IC Comput(P2, s2,i) & DataPart Comput(P1, s1,i) = DataPart
  Comput(P2, s2,i))
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: Initialize I c= s1;
  assume
A2: I c= P1;
   then
A3: P1 = P1 +* I by FUNCT_4:79;
  assume
A4: I is_pseudo-closed_on s1,P1;
A5: ProgramPart I = I by RELAT_1:209;
  let n be Element of NAT;
  assume
 Reloc(I,n) c= s2;
  assume
A6: Reloc(I,n) c= P2;
  defpred P[Nat] means $1 <= pseudo-LifeSpan(s1,P1,I) implies IC
Comput(P1,s1,$1) + n = IC Comput(P2,s2,$1) & DataPart
Comput(P1,s1,$1) =
  DataPart Comput(P2,s2,$1);
  assume
A7: IC s2 =  n;
  assume
A8: DataPart s1 = DataPart s2;
  thus
A9: now
    defpred P[Nat] means $1 < pseudo-LifeSpan(s1,P1,I) implies
IC
Comput(P1,s1,$1) + n = IC Comput(P2,s2,$1) &
IncAddr(CurInstr(P1,Comput(P1,s1,$1)),n) =
   CurInstr(P2,Comput(P2,s2
,$1)) &
DataPart Comput(P1,s1,$1) =
    DataPart Comput(P2,s2,$1);
    let i be Element of NAT;
    assume
A10: i < pseudo-LifeSpan(s1,P1,I);
A11: for k being Element of NAT st P[k] holds P[k + 1]
    proof
      let k be Element of NAT;
      assume
A12:  P[k];
      reconsider l = IC Comput(P1,s1,k+1) as Element of NAT;
      reconsider j = CurInstr(P1,Comput(P1,s1,k+1)) as Instruction of SCM+FSA;
A13:  P1/.IC Comput(P1,s1,k+1) = P1.IC Comput(P1,s1,k+1) by PBOOLE:158;
      assume
A14:  k + 1 < pseudo-LifeSpan(s1,P1,I);
A15:  Comput(P1,s1,k+1) = Following(P1,Comput(P1,s1,k)) by EXTPRO_1:4
        .= Exec(CurInstr(P1,Comput(P1,s1,k)),
        Comput(P1,s1,k));
      s1 +* (Initialize I) = s1 by A1,FUNCT_4:79;
      then
A16:  IC Comput(P1,s1,k+1) in dom I by A4,A14,SCMFSA8A:def 5,A5,A3;
A17:  l in dom I by A16;
A18:  Comput(P2,s2,k+1) = Following(P2,
Comput(P2,s2,k)) by EXTPRO_1:4
        .= Exec(CurInstr(P2,Comput(P2,s2,k)),
        Comput(P2,s2,k));
A19:  k + 0 < k + 1 by XREAL_1:8;
      hence
A20:  IC Comput(P1,s1,k+1) + n = IC Comput(P2,s2,k+1)
by A12,A14,A15,A18,SCMFSA6A:41,XXREAL_0:2;
      then IC Comput(P2,s2,k+1) in dom Reloc(I,n) by A16,
COMPOS_1:158;
      then
A21:  IC Comput(P2,s2,k+1) in dom Reloc(I,n);
A22:  P2/.IC Comput(P2,s2,k+1)
 = P2.IC Comput(P2,s2,k+1) by PBOOLE:158;
      j = P1.IC Comput(P1,s1,k+1) by A13
        .= I.IC Comput(P1,s1,k+1)
        by A16,GRFUNC_1:8,A2
        .= I.l;
      hence
      IncAddr(CurInstr(P1,Comput(
P1,s1,k+1)),n)
       = Reloc(I,n).(l + n) by A17,COMPOS_1:122
        .= P2.IC Comput(P2,s2,k+1) by A21,GRFUNC_1:8,A20,A6
        .= CurInstr(P2,Comput(P2,s2,k+1))
         by A22;
      thus thesis by A12,A14,A19,A15,A18,SCMFSA6A:41,XXREAL_0:2;
    end;
A23: P[0]
    proof
A24:  IC Comput(P1 +* I, (s1 +* (Initialize I)),0) =
      IC (s1 +* (Initialize I)) by EXTPRO_1:3
        .= IC Initialize (s1 +* I) by FUNCT_4:15
        .=  0 by FUNCT_4:121;
      assume 0 < pseudo-LifeSpan(s1,P1,I);
      then
A25:   0 in dom I by A4,A24,SCMFSA8A:def 5,A5;
      then
A26:   0 in dom I;
A27:  IC SCM+FSA in dom (Initialize I) by COMPOS_1:141;
A28: Comput(P1,s1,0) = s1 by EXTPRO_1:3;
A29: Comput(P2,s2,0) = s2 by EXTPRO_1:3;
      IC Comput(P1,s1,0) = s1.IC SCM+FSA by EXTPRO_1:3
        .= IC(Initialize I) by A1,A27,GRFUNC_1:8
        .=  0 by COMPOS_1:142;
      hence IC Comput(P1,s1,0) + n = IC Comput(P2,s2,
0) by A7,EXTPRO_1:3;
       0 + n in dom Reloc(I,n) by A25,COMPOS_1:158;
      then
A30:   (0 + n) in dom Reloc(I,n);
A31:  IC SCM+FSA in dom (Initialize I) by COMPOS_1:141;
A32:  P1.IC s1 = P1.IC(Initialize I) by A1,GRFUNC_1:8,A31
        .= P1. 0 by COMPOS_1:142
:::        .= (Initialize I). 0 by A1,A27,A23,GRFUNC_1:8
        .= I. 0 by A25,GRFUNC_1:8,A2;
A33:  P1/.IC s1 = P1.IC s1 by PBOOLE:158;
A34:  P2/.IC s2 = P2.IC s2 by PBOOLE:158;
      thus IncAddr(CurInstr(P1,
      Comput(P1,s1,0)),n)
        = Reloc(I,n). (0 + n) by A26,A33,COMPOS_1:122,A28,A32
        .= CurInstr(P2,Comput(P2,s2,0))
         by A29,A7,A30,A34,GRFUNC_1:8,A6;
      thus DataPart Comput(P1,s1,0) = DataPart s2 by A8,EXTPRO_1:3
        .= DataPart Comput(P2,s2,0) by EXTPRO_1:3;
    end;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A23,A11);
    hence IncAddr(CurInstr(P1,Comput(P1,s1,i)),n)
     = CurInstr(P2,Comput(P2,s2,i)) by A10;
  end;
A35: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A36: P[k];
    set i = CurInstr(P1,Comput(P1,s1,k));
A37: Comput(P2,s2,k+1) = Following(P2,
Comput(P2,s2,k)) by EXTPRO_1:4
      .= Exec(CurInstr(P2,Comput(P2,s2,k)),
      Comput(P2,s2,k));
    assume
A38: k + 1 <= pseudo-LifeSpan(s1,P1,I);
    then
A39: k + 1 <= pseudo-LifeSpan(s1,P1,I) + 1 by NAT_1:12;
A40: k < pseudo-LifeSpan(s1,P1,I) by A38,NAT_1:13;
A41: Comput(P1,s1,k+1) =
Following(P1,Comput(P1,s1,k)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(P1,Comput(P1,s1,k)),
      Comput(P1,s1,k));
    hence IC Comput(P1,s1,k+1) + n = IC Exec(IncAddr(i,n),Comput(
P2,s2,k))
    by A36,A39,SCMFSA6A:41,XREAL_1:8
      .= IC Comput(P2,s2,k+1) by A9,A40,A37;
    thus DataPart Comput(P1,s1,k+1) = DataPart Exec(IncAddr(i,n),
Comput(P2,s2,k)) by A36,A39,A41,SCMFSA6A:41,XREAL_1:8
      .= DataPart Comput(P2,s2,k+1) by A9,A40,A37;
  end;
  let i be Element of NAT;
  assume
A42: i <= pseudo-LifeSpan(s1,P1,I);
A43: P[0]
  proof
    assume 0 <= pseudo-LifeSpan(s1,P1,I);
A44: IC SCM+FSA in dom (Initialize I) by COMPOS_1:141;
    IC Comput(P1,s1,0) = s1.IC SCM+FSA by EXTPRO_1:3
      .= IC(Initialize I) by A1,A44,GRFUNC_1:8
      .=  0 by COMPOS_1:142;
    hence IC Comput(P1,s1,0) + n = IC Comput(P2,s2,0)
by A7,EXTPRO_1:3;
    thus DataPart Comput(P1,s1,0) = DataPart s2 by A8,EXTPRO_1:3
      .= DataPart Comput(P2,s2,0) by EXTPRO_1:3;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A43,A35);
  hence thesis by A42;
end;

theorem Th52:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
  DataPart s1 = DataPart s2 holds I is_pseudo-closed_on s1,P1 implies I
  is_pseudo-closed_on s2,P2
proof
  let s1,s2 be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let I be Program of SCM+FSA;
  set S1 = s1 +* (Initialize I),
      Q1 = P1 +* I,
      S2 = s2 +* (Initialize I),
      Q2 = P2 +* I;
A1: I c= Q1 by FUNCT_4:26;
A2: I c= Q2 by FUNCT_4:26;
A3: Reloc(I,0)= I by COMPOS_1:157;
A4: Initialize I c= s1 +* (Initialize I)
 by FUNCT_4:26;
A5: IC (s2 +* (Initialize I)) = IC (Initialize (s2 +* I))
  by FUNCT_4:15
    .=  0 by FUNCT_4:121;
A6: I c= Initialize I by SCMFSA8A:9;
  Initialize I c= s2 +* (Initialize I)
  by FUNCT_4:26;
  then I c= s2 +* (Initialize I) by A6,XBOOLE_1:1;
  then
A7: Reloc(I,0) c= s2 +* (Initialize I)
by COMPOS_1:157;
  assume DataPart s1 = DataPart s2;
  then
A8: DataPart(s1 +* (Initialize I)) = DataPart s2
by SCMFSA8A:11
    .= DataPart(s2 +* (Initialize I)) by SCMFSA8A:11;
A9: ProgramPart I = I by RELAT_1:209;
  assume
A10: I is_pseudo-closed_on s1,P1;
  then
A11: IC Comput(Q1,S1,pseudo-LifeSpan(s1,P1,I)) = card I
by SCMFSA8A:def 5,A9;
A12: I is_pseudo-closed_on s1 +* (Initialize I),P1+*I by A10,Th50;
A13: now
    let k be Element of NAT;
    assume
A14: k < pseudo-LifeSpan(s1,P1,I);
    then   k <= pseudo-LifeSpan(s1 +* (Initialize I),P1+*I,I)
    by A10,Th50;
    then
    IC Comput(Q2,S2,k) = IC Comput(Q1,S1,k) + 0
          by A8,A12,A4,A7,A5,Th51,A1,A2,A3
      .= IC Comput(Q1,S1,k);
    hence IC Comput(Q2,S2,k) in dom I by A10,A14,SCMFSA8A:def 5,A9;
  end;
  IC Comput(Q2,S2,pseudo-LifeSpan(s1,P1,I)) = IC
Comput(Q2,S2,
  pseudo-LifeSpan(s1 +* (Initialize I),P1+*I,I)) by A10,Th50
    .= IC Comput(Q1,S1,pseudo-LifeSpan(
    s1 +* (Initialize I),P1+*I,I))
  + 0 by A8,A12,A4,A7,A5,Th51,A1,A2,A3
    .= IC Comput(Q1,S1,pseudo-LifeSpan(s1,P1,I)) by A10,Th50;
  hence thesis by A11,A13,SCMFSA8A:def 3,A9;
end;

theorem Th53:
  for s being State of SCM+FSA, I being Program of SCM+FSA st s.
intloc 0 = 1 holds I is_pseudo-closed_on s,P iff
I is_pseudo-closed_on Initialized s,P
proof
  let s be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let I be Program of SCM+FSA;
  assume s.intloc 0 = 1;
  then DataPart s = DataPart Initialized s by Th27;
  hence thesis by Th52;
end;

theorem Th54:
  for a being Int-Location, I,J being Program of SCM+FSA holds
   0 in dom if=0(a,I,J) &  1 in dom if=0(a,I,J) &  0 in dom
  if>0(a,I,J) &  1 in dom if>0(a,I,J)
proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  set i = a =0_goto  (card J + 3);
  if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I ';' Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  ));
  then
A1: dom Macro i c= dom if=0(a,I,J) by SCMFSA6A:56;
A2: dom Macro i = { 0,  1} by COMPOS_1:149;
  then
A3:  1 in dom Macro i by TARSKI:def 2;
   0 in dom Macro i by A2,TARSKI:def 2;
  hence  0 in dom if=0(a,I,J) &  1 in dom if=0(a,I,J) by A1,A3;
  set i = a >0_goto  (card J + 3);
  if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I ';' Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  ));
  then
A4: dom Macro i c= dom if>0(a,I,J) by SCMFSA6A:56;
A5: dom Macro i = { 0,  1} by COMPOS_1:149;
  then
A6:  1 in dom Macro i by TARSKI:def 2;
   0 in dom Macro i by A5,TARSKI:def 2;
  hence thesis by A4,A6;
end;

theorem Th55:
  for a being Int-Location, I,J being Program of SCM+FSA holds
  if=0(a,I,J). 0 = a =0_goto  (card J + 3) & if=0(a,I,J). 1 =
goto  2 & if>0(a,I,J). 0 = a >0_goto  (card J + 3) & if>0(a,I
  ,J). 1 = goto  2
proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  set i = a =0_goto  (card J + 3);
A1: if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I ';' Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  ));
A2: dom Macro i = { 0,  1} by COMPOS_1:149;
  then  0 in dom Macro i by TARSKI:def 2;
  hence if=0(a,I,J). 0 = (Directed Macro i). 0 by A1,SCMFSA8A:28
    .= i by SCMFSA7B:7;
   1 in dom Macro i by A2,TARSKI:def 2;
  hence if=0(a,I,J). 1 = (Directed Macro i). 1 by A1,SCMFSA8A:28
    .= goto  2 by SCMFSA7B:8;
  set i = a >0_goto  (card J + 3);
A3: if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I ';' Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  ));
A4: dom Macro i = { 0,  1} by COMPOS_1:149;
  then  0 in dom Macro i by TARSKI:def 2;
  hence if>0(a,I,J). 0 = (Directed Macro i). 0 by A3,SCMFSA8A:28
    .= i by SCMFSA7B:7;
   1 in dom Macro i by A4,TARSKI:def 2;
  hence if>0(a,I,J). 1 = (Directed Macro i). 1 by A3,SCMFSA8A:28
    .= goto  2 by SCMFSA7B:8;
end;

theorem Th56:
  for a being Int-Location, I,J being Program of SCM+FSA, n being
Element of NAT st n < card I + card J + 3 holds n in dom if=0(a,I,J) & if=0(a,I
  ,J).n <> halt SCM+FSA
proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  let n be Element of NAT;
  set J1 = a =0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
  ';' I;
A1: card J1 = card (Macro (a =0_goto  (card J + 3)) ';' J ';' Goto
   (card I + 1)) + card I by SCMFSA6A:61
    .= card (Macro (a =0_goto  (card J + 3)) ';' J) + card Goto
  (card I + 1) + card I by SCMFSA6A:61
    .= card (Macro (a =0_goto  (card J + 3)) ';' J) + 1 + card I by SCMFSA8A:29
    .= card Macro (a =0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
    .= 2 + card J + 1 + card I by COMPOS_1:150
    .= card I + card J + 3;
  assume n < card I + card J + 3;
  then  n in dom J1 by A1,AFINSQ_1:70;
  then
A2:  n in dom Directed J1 by FUNCT_4:105;
  then
A3: (Directed J1). n in rng Directed J1 by FUNCT_1:def 5;
  if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  then
A4: Directed J1 c= if=0(a,I,J) by SCMFSA6A:55;
  then dom Directed J1 c= dom if=0(a,I,J) by GRFUNC_1:8;
  hence n in dom if=0(a,I,J) by A2;
  if=0(a,I,J). n = (Directed J1). n by A2,A4,GRFUNC_1:8;
  hence thesis by A3,COMPOS_1:def 7;
end;

theorem Th57:
  for a being Int-Location, I,J being Program of SCM+FSA, n being
Element of NAT st n < card I + card J + 3 holds n in dom if>0(a,I,J) & if>0(a,I
  ,J).n <> halt SCM+FSA
proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  let n be Element of NAT;
  set J1 = a >0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
  ';' I;
A1: card J1 = card (Macro (a >0_goto  (card J + 3)) ';' J ';' Goto
   (card I + 1)) + card I by SCMFSA6A:61
    .= card (Macro (a >0_goto  (card J + 3)) ';' J) + card Goto
  (card I + 1) + card I by SCMFSA6A:61
    .= card (Macro (a >0_goto  (card J + 3)) ';' J) + 1 + card I by SCMFSA8A:29
    .= card Macro (a >0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
    .= 2 + card J + 1 + card I by COMPOS_1:150
    .= card I + card J + 3;
  assume n < card I + card J + 3;
  then  n in dom J1 by A1,AFINSQ_1:70;
  then
A2:  n in dom Directed J1 by FUNCT_4:105;
  then
A3: (Directed J1). n in rng Directed J1 by FUNCT_1:def 5;
  if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  then
A4: Directed J1 c= if>0(a,I,J) by SCMFSA6A:55;
  then dom Directed J1 c= dom if>0(a,I,J) by GRFUNC_1:8;
  hence n in dom if>0(a,I,J) by A2;
  if>0(a,I,J). n = (Directed J1). n by A2,A4,GRFUNC_1:8;
  hence thesis by A3,COMPOS_1:def 7;
end;

theorem Th58:
  for s being State of SCM+FSA, I being Program of SCM+FSA st
  Directed I is_pseudo-closed_on s,P
   holds I ';' Stop SCM+FSA is_closed_on s,P & I
  ';' Stop SCM+FSA is_halting_on s,P &
   LifeSpan(P +* (I ';' Stop SCM+FSA),s +* (Initialize(I ';' Stop SCM+FSA))) =
   pseudo-LifeSpan(s,P,Directed I) &
  (for n being Element of
  NAT st n < pseudo-LifeSpan(s,P,Directed I) holds
   IC Comput(P +* I, (s +* (Initialize I)),n)
     = IC Comput(P +* (I ';' Stop SCM+FSA),
     (s +* (Initialize(I ';' Stop SCM+FSA))),n)) &
for n being Element of NAT st n <= pseudo-LifeSpan(
  s,P,Directed
  I) holds DataPart Comput(P +* I, (s +* (Initialize I)),n)
   = DataPart Comput(P+* (I ';' Stop SCM+FSA),
    s +* (Initialize(I ';' Stop SCM+FSA)),n)
proof
  let s be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  set A = NAT;
  let I be Program of SCM+FSA;
  set I0 = Directed I;
A1: Reloc(I0,0)= I0 by COMPOS_1:157;
A2: ProgramPart I0 = I0 by RELAT_1:209;
  set I1 = I ';' Stop SCM+FSA;
A3: ProgramPart(I ';' Stop SCM+FSA) = I ';' Stop SCM+FSA by RELAT_1:209;
A4: ProgramPart I0 = I0 by RELAT_1:209;
  set s00 = s +* (Initialize I0),
      P00 = P+*I0;
  set s10 = s +* (Initialize I1),
      P10 = P+*I1;
  reconsider k = pseudo-LifeSpan(s00,P00,I0) as Element of NAT;
  (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
  then
A5: halt SCM+FSA = (Stop SCM+FSA). (card I -' card I) by XREAL_1:234;
A6: DataPart s00 = DataPart s by SCMFSA8A:11
    .= DataPart s10 by SCMFSA8A:11;
  assume
A7: I0 is_pseudo-closed_on s,P;
  then
A8: I0 is_pseudo-closed_on s00,P00 by Th50;
  defpred P[Nat] means k <= $1 implies IC Comput(P10, s10,$1) =
   card I & CurInstr(P10,Comput(P10,s10,$1))
   = halt SCM+FSA;
A9: Initialize I1 c= s10 by FUNCT_4:26;
A10: I1 c= P10 by FUNCT_4:26;
  I1 c= Initialize I1 by SCMFSA8A:9;
  then
A11: I1 c= s10 by A9,XBOOLE_1:1;
A12: I0 c= I1 by SCMFSA6A:55;
  then
A13: dom I0 c= dom I1 by GRFUNC_1:8;
A14: I0 c= P10 by A12,A10,XBOOLE_1:1;
  Reloc(I0,0) c= I1 by A12,COMPOS_1:157;
  then
A15: Reloc(I0,0) c= s10 by A11,XBOOLE_1:1;
  s10 = Initialize (s +* I1) by FUNCT_4:15;
  then
A16: IC s10 =  0 by FUNCT_4:121;
A17: Initialize I0 c= s00 by FUNCT_4:26;
A18: I0 c= P00 by FUNCT_4:26;
A19: now
    let n be Element of NAT;
    assume
A20: n <= pseudo-LifeSpan(s00,P00,I0);
    then IC Comput(P00, s00,n) + 0 = IC Comput(P10,
s10,n) by A17,A8,A15,A16,A6,Th51,A1,A18,A14;
    hence IC Comput(P00, s00,n) = IC Comput(P10,s10,n);
    thus DataPart Comput(P00, s00,n) = DataPart Comput(P10, s10,n)
     by A17,A8,A15,A16,A6,A20,Th51,A1,A18,A14;
  end;
A21: k = pseudo-LifeSpan(s,P,I0) by A7,Th50;
A22: s00 +* (Initialize I0) = s +* ((Initialize I0) +* (Initialize I0))
     by FUNCT_4:15
    .= s00;
A23: P00 +* I0 = P +* (I0 +* I0) by FUNCT_4:15
    .= P00;
A24: now
    let n be Element of NAT;
    assume
A25: n < pseudo-LifeSpan(s00,P00,I0);
    then
    IncAddr(CurInstr(P00,Comput(P00,s00,n)),0)
     = CurInstr(P10,Comput(P10,s10,n))
      by A17,A8,A15,A16,A6,Th51,A1,A18,A14;
    hence CurInstr(P00,Comput(P00,s00,n))
     = CurInstr(P10,Comput(P10,s10,n))
      by COMPOS_1:91;
    thus IC Comput(P00, s00,n) in dom I0 by A22,A8,A25,
SCMFSA8A:31,A2,A23;
    thus CurInstr(P00,Comput(P00,s00,n))
     <> halt SCM+FSA by A22,A8,A25,SCMFSA8A:31,A2,A23;
  end;
A26: now
    let n be Element of NAT;
    assume
A27: CurInstr(P10,Comput(P10,s10,n))
 = halt SCM+FSA;
    reconsider l = IC Comput(P00, s00,n) as Element of NAT;
A28:  P00/.IC Comput(P00,s00,n)
 = P00.IC Comput(P00,s00,n) by PBOOLE:158;
    assume
A29: k > n;
    then
A30: l in dom I0 by A7,A21,SCMFSA8A:def 5,A4;
    CurInstr(P10,Comput(P10,s10,n)) =
     CurInstr(P00,Comput(P00,s00,n)) by A24,A29
      .= P00.l by A28
      .= I0.l by A30,GRFUNC_1:8,A18;
    then halt SCM+FSA in rng I0 by A27,A30,FUNCT_1:def 5;
    hence contradiction by COMPOS_1:def 7;
  end;
A31: card Stop SCM+FSA = 1 by COMPOS_1:46;
  then card I1 = card I + 1 by SCMFSA6A:61;
  then card I < card I1 by NAT_1:13;
  then
A32:  card I in dom I1 by AFINSQ_1:70;
  card I < card I + card Stop SCM+FSA by A31,NAT_1:13;
  then I1. card I = IncAddr(halt SCM+FSA,card I) by A5,Th13
    .= halt SCM+FSA by COMPOS_1:93;
  then
A33: P10. card I = halt SCM+FSA by A32,A10,GRFUNC_1:8;
A34: for n being Element of NAT st P[n] holds P[n + 1]
  proof
    let n be Element of NAT;
    assume
A35: P[n];
A36:  P10/.IC Comput(P10, s10,n+1)
 = P10.IC Comput(P10, s10,n+1) by PBOOLE:158;
    assume
A37: k <= n + 1;
    thus
   now
      per cases by A37,NAT_1:8;
      suppose
        k = n + 1;
        hence IC Comput(P10, s10,n+1)
            = IC Comput(P00, s00,k) by A19
          .=  card I0 by A7,A21,SCMFSA8A:def 5,A2
          .=  card I by SCMFSA8A:34;
      end;
      suppose
A38:    k <= n;
        Comput(P10, s10,n+1) = Following(P10,
        Comput(P10,s10,n)) by EXTPRO_1:4
          .= Exec(CurInstr(P10,Comput(P10,s10,n)),
           Comput(P10, s10,n));
        hence IC Comput(P10, s10,n+1) =  card I by A35,A38,
EXTPRO_1:def 3;
      end;
    end;
    hence thesis by A33,A36;
  end;
A39:  P10/.IC Comput(P10,s10,0)
 = P10.IC Comput(P10,s10,0) by PBOOLE:158;
A40: P[0]
  proof
    assume k <= 0;
    then k = 0;
    hence IC Comput(P10, s10,0) = IC Comput(P00,
s00,k) by A19
      .=  card I0 by A7,A21,SCMFSA8A:def 5,A2
      .=  card I by SCMFSA8A:34;
    hence thesis by A33,A39;
  end;
A41: for n being Element of NAT holds P[n] from NAT_1:sch 1(A40,A34);
  now
    let n be Element of NAT;
    per cases;
    suppose
A42:  n < k;
      then IC Comput(P00, s00,n) = IC Comput(P10,
s10,n) by A19;
      then IC Comput(P10, s10,n) in dom I0 by A7,A21,A42,
SCMFSA8A:def 5,A4;
      hence IC Comput(P10, s10,n) in dom I1 by A13;
    end;
    suppose
      k <= n;
      hence IC Comput(P10, s10,n) in dom I1 by A32,A41;
    end;
  end;
  hence I1 is_closed_on s,P by SCMFSA7B:def 7,A3;
  set s1 = s +* (Initialize I),
      P1 = P +* I;
A43: I c= P1 by FUNCT_4:26;
A44: card I0 = card I by SCMFSA8A:34;
  P[k] by A41;
  then
A45: P10 halts_on s10 by EXTPRO_1:30;
  hence I1 is_halting_on s,P by SCMFSA7B:def 8,A3;
  CurInstr(P10,Comput(P10,
s10,k))
   = halt SCM+FSA by A41;
  then
A46: LifeSpan(P10,s10) = k by A45,A26,EXTPRO_1:def 14;
  defpred P[Nat] means $1 < pseudo-LifeSpan(s,P,I0) implies
    IC Comput(P1, s1,$1) in dom I &
    IC Comput(P1, s1,$1) = IC Comput(P10, s10,$1) &
    DataPart Comput(P1, s1,$1) = DataPart Comput(P10, s10,$1);
A47: for n being Element of NAT st P[n] holds P[n + 1]
  proof
    let n be Element of NAT;
    set l = IC Comput(P1, s1,n);
    set l0 = IC Comput(P10, s10,n);
    assume
A48: P[n];
    assume
A49: n + 1 < pseudo-LifeSpan(s,P,I0);
    then
A50: l0 in dom I0 by A48,FUNCT_4:105,NAT_1:12;
A51: for f being FinSeq-Location holds Comput(P1, s1,n).f =
Comput(P10,
    s10,n).f by A48,A49,NAT_1:12,SCMFSA6A:38;
    for a being Int-Location holds Comput(P1, s1,n).a = Comput(
P10,
    s10,n).a by A48,A49,NAT_1:12,SCMFSA6A:38;
    then
A52: Comput(P1, s1,n), Comput(P10, s10,n)
equal_outside A by A48,A49,A51,NAT_1:12,SCMFSA10:91;
A53: now
      assume
A54:  I.l = halt SCM+FSA;
A55:  P00/.IC Comput(P00,s00,n)
 = P00.IC Comput(P00,s00,n) by PBOOLE:158;
      n < k by A21,A49,NAT_1:12;
      then
A56:  CurInstr(P00,Comput(P00,s00,n))
       = P00.l0 by A19,A55
        .= P00.l0
        .= I0.l0 by A50,A18,GRFUNC_1:8
        .= I0.l by A48,A49,NAT_1:12
        .= goto  card I by A48,A49,A54,NAT_1:12,SCMFSA8A:30;
A57:  IC Comput(P00, s00,n+1) =
IC Following(P00,Comput(P00,s00,n))
 by EXTPRO_1:4
        .=  card I by A56,SCMFSA_2:95
        .=  card I0 by SCMFSA8A:34;
      IC Comput(P00, s00,n+1) in dom I0 by A7,A49,SCMFSA8A:31,A2;
      hence contradiction by A57;
    end;
A58:  P1/.IC Comput(P1,s1,n) = P1.IC Comput(P1,s1,n) by PBOOLE:158;
A59:  P10/.IC Comput(P10,s10,n)
 = P10.IC Comput(P10,s10,n) by PBOOLE:158;
A60: CurInstr(P1,Comput(P1,s1,n)) = P1.l
 by A58
      .= I.l by A43,GRFUNC_1:8,A48,A49,NAT_1:12
      .= I0.l0 by A48,A49,A53,NAT_1:12,SCMFSA8A:30
:::      .= I1.l0 by A7,A37,GRFUNC_1:8
      .= P10.l0 by A50,A14,GRFUNC_1:8
      .= CurInstr(P10,Comput(P10,s10,n))
       by A59;
A61: Comput(P10, s10,n+1) =
Following(P10,Comput(P10,
s10,n))
 by EXTPRO_1:4
      .= Exec(CurInstr(P1,Comput(P1,s1,n)),
      Comput(P10, s10,n)) by A60;
    pseudo-LifeSpan(s,P,I0) = k by A7,Th50;
    then
A62: IC Comput(P00, s00,n+1) = IC Comput(P10, s10,n
+1) by A19,A49;
A63: dom I0 = dom I by FUNCT_4:105;
 Comput(P1, s1,n+1) =
Following(P1,Comput(P1,s1,n)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(P1,Comput(P1,s1,n)),
      Comput(P1, s1,n));
    then
A64: Comput(P1, s1,n+1), Comput(P10, s10,n+1)
    equal_outside NAT
     by A61,A52,AMISTD_2:def 20;
A65: for f being FinSeq-Location
 holds Comput(P1, s1,n+1).f =
    Comput(P10, s10,n+1).f
     by SCMFSA10:93,A64;
    IC Comput(P00, s00,n+1) in dom I0 by A7,A49,SCMFSA8A:31,A2;
    hence IC Comput(P1, s1,n+1) in dom I by A62,A63,
COMPOS_1:24,A64;
    thus IC Comput(P1, s1,n+1) = IC Comput(P10, s10
,n+1) by COMPOS_1:24,A64;
    for a being Int-Location holds Comput(P1, s1,n+1).a = Comput(
P10,
    s10,n+1).a by SCMFSA10:92,A64;
    hence thesis by A65,SCMFSA6A:38;
  end;
  IC Comput(P10, s10,k) =  card I by A41;
  then
A66: IC Comput(P00, s00,LifeSpan(P10,s10)) =  card I
by A19,A46;
  for n be Element of NAT st not IC Comput(P00, s00,n) in dom I0
holds
  LifeSpan(P10,s10) <= n by A24,A46;
  hence LifeSpan(P10,s10) = pseudo-LifeSpan(s,P,I0
) by A7,A66,A44,SCMFSA8A:def 5,A2;
A67: P[0]
  proof
A68: IC Comput(P1, s1,0) = IC s1 by EXTPRO_1:3
      .= IC Initialize (s +* I) by FUNCT_4:15
      .=  0 by FUNCT_4:121;
    assume 0 < pseudo-LifeSpan(s,P,I0);
    then IC Comput(P +* I0, (s +* (Initialize I0)),0)
     in dom I0 by A7,SCMFSA8A:31,A2;
    then IC (s +* (Initialize I0)) in dom I0 by EXTPRO_1:3;
    then  0 in dom I0 by Th31;
    hence IC Comput(P1, s1,0) in dom I by A68,FUNCT_4:105;
    thus IC Comput(P1, s1,0) = IC Comput(P10, s10,0
) by A16,A68,EXTPRO_1:3;
    thus DataPart Comput(P1, s1,0) = DataPart s1 by EXTPRO_1:3
      .= DataPart s by SCMFSA8A:11
      .= DataPart s10 by SCMFSA8A:11
      .= DataPart Comput(P10, s10,0) by EXTPRO_1:3;
  end;
A69: for n being Element of NAT holds P[n] from NAT_1:sch 1(A67,A47);
  hence for n be Element of NAT st n < pseudo-LifeSpan(s,P,I0)
holds IC
  Comput(P1, s1,n) = IC Comput(P10, s10,n);
  let n be Element of NAT;
  assume
A70: n <= pseudo-LifeSpan(s,P,Directed I);
  per cases by A70,XXREAL_0:1;
  suppose
    n < pseudo-LifeSpan(s,P,I0);
    hence thesis by A69;
  end;
  suppose
A71: n = pseudo-LifeSpan(s,P,I0);
    hereby
      per cases by NAT_1:6;
      suppose
A72:    n = 0;
        hence DataPart Comput(P1, s1,n) = DataPart s1 by
EXTPRO_1:3
          .= DataPart s by SCMFSA8A:11
          .= DataPart s10 by SCMFSA8A:11
          .= DataPart Comput(P10, s10,n) by A72,EXTPRO_1:3;
      end;
      suppose
        ex m be Nat st n = m + 1;
        then consider m being Nat such that
A73:    n = m + 1;
        reconsider m as Element of NAT by ORDINAL1:def 13;
A74:    Comput(P10, s10,n) =
Following(P10,Comput(P10,
s10,m))
 by A73,EXTPRO_1:4
          .= Exec(CurInstr(P10,Comput(P10,s10,m)),
          Comput(P10, s10,m));
        set i = CurInstr(P1,Comput(P1,s1,m));
A75:    Comput(P1, s1,n) =
Following(P1,Comput(P1,s1,m)
)
 by A73,EXTPRO_1:4
          .= Exec(CurInstr(P1,Comput(P1,s1,m)),
          Comput(P1, s1,m));
        set l0 = IC Comput(P10, s10,m);
        set l = IC Comput(P1, s1,m);
A76:    m + 0 < pseudo-LifeSpan(s,P,I0) by A71,A73,XREAL_1:8;
        then
A77:    l = l0 by A69;
A78:    l in dom I by A69,A76;
        then
A79:    l0 in dom I0 by A77,FUNCT_4:105;
A80:  P1/.IC Comput(P1,s1,m)
 = P1.IC Comput(P1, s1,m) by PBOOLE:158;
A81:  P10/.IC Comput(P10,s10,m)
 = P10.IC Comput(P10,s10,m) by PBOOLE:158;
A82:    i = P1.l by A80
          .= I.l by A43,GRFUNC_1:8,A78;
A83:     I0 c= I1 by SCMFSA6A:55;
        then dom I0 c= dom I1 by RELAT_1:25;
        then
A84:     l0 in dom I1 by A79;
A85:    I0.l0 = I1.l0 by A79,GRFUNC_1:8,A83
          .= P10.l0 by GRFUNC_1:8,A10,A84
          .= CurInstr(P10,Comput(P10,s10,m))
           by A81;
A86:    DataPart Comput(P1, s1,m) = DataPart Comput(P10, s10,m) by A69,A76;
        hereby
          per cases;
          suppose
A87:        i = halt SCM+FSA;
            then CurInstr(P10,Comput(P10,s10,m))
             = goto  card I by A78,A77,A82,A85,SCMFSA8A:30;
            then InsCode CurInstr(P10,
            Comput(P10,s10,m)) = 6 by SCMFSA_2:47;
            then
A88:        InsCode CurInstr(P10,
Comput(P10,s10,m)) in {0,6,7,8} by ENUMSET1:def 2
;
            thus DataPart Comput(P1, s1,n) = DataPart Comput(
P1, s1,m) by A75,A87,EXTPRO_1:def 3
              .= DataPart Comput(P10, s10,m) by A69,A76
              .= DataPart Comput(P10, s10,n) by A74,A88,Th32;
          end;
          suppose
            i <> halt SCM+FSA;
            then
            CurInstr(P10,Comput(P10,s10,m))
             = i by A78,A77,A82,A85,SCMFSA8A:30;
            hence thesis by A75,A74,A86,SCMFSA6C:5;
          end;
        end;
      end;
    end;
  end;
end;

theorem Th59:
  for s being State of SCM+FSA, I being Program of SCM+FSA st
  Directed I is_pseudo-closed_on s,P holds
   DataPart Result(P +* (I ';' Stop SCM+FSA),
   s +* Initialize (I ';' Stop SCM+FSA)) =
  DataPart Comput(P +* I, (s +* (Initialize I)),
  pseudo-LifeSpan(s,P,Directed I))
proof
  let s be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let I be Program of SCM+FSA;
  set I0 = Directed I;
  set I1 = I ';' Stop SCM+FSA;
  set s2 = s +* (Initialize I),
      P2 = P +* I;
  set s10 = s +* (Initialize I1),
      P10 = P+*I1;
A1: ProgramPart I1 = I1 by RELAT_1:209;
  set k = pseudo-LifeSpan(s,P,I0);
  assume
A2: I0 is_pseudo-closed_on s,P;
  then
A3: DataPart Comput(P2, s2,k) = DataPart Comput(P10, s10,k) by Th58;
  I1 is_halting_on s,P by A2,Th58;
  then
A4: P10 halts_on s10 by SCMFSA7B:def 8,A1;
  LifeSpan(P10,s10) = k by A2,Th58;
  then Result(P10,s10) = Comput(P10,s10,k) by A4,EXTPRO_1:23;
  hence thesis by A3;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA st s.intloc 0
= 1 & Directed I is_pseudo-closed_on s,P
 holds DataPart IExec(I ';' Stop SCM+FSA,P,s)
  = DataPart Comput(P +* I, (s +* (Initialize I)),
pseudo-LifeSpan(s,P,Directed I))
proof
  let s be State of SCM+FSA;
  set A = NAT;
  set D = Data-Locations SCM+FSA;
  let I be Program of SCM+FSA;
  set I0 = Directed I;
  set I1 = I ';' Stop SCM+FSA;
  set s2 = s +* (Initialize I),
      P2 = P +* I;
  set s10 = s +* Initialize I1,
      P10 = P+*I1;
  set k = pseudo-LifeSpan(s,P,I0);
  assume
A1: s.intloc 0 = 1;
  assume
A2: I0 is_pseudo-closed_on s,P;
A3: s10 = s +* Initialized I1 by A1,Th18;
  thus DataPart IExec(I1,P,s)
   = DataPart (Result(P +* I1,s +* Initialized I1) +* (s|NAT))
    .= DataPart(Result(P10,s10)) by A3,COMPOS_1:82
    .= DataPart Comput(P2, s2,k) by A2,Th59;
end;

theorem Th61:
  for I,J being Program of SCM+FSA,a being Int-Location holds if=0
  (a,I,J). (card I + card J + 3) = halt SCM+FSA
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
A1: if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  set II = a =0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
  ';' I;
A2: card II = card (Macro (a =0_goto  (card J + 3)) ';' J ';' Goto
   (card I + 1)) + card I by SCMFSA6A:61
    .= card (Macro (a =0_goto  (card J + 3)) ';' J) + card Goto
  (card I + 1) + card I by SCMFSA6A:61
    .= card (Macro (a =0_goto  (card J + 3)) ';' J) + 1 + card I by SCMFSA8A:29
    .= card Macro (a =0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
    .= 2 + card J + 1 + card I by COMPOS_1:150
    .= card I + card J + 3;
  then
A3: card I + card J + 3 -' card II = 0 by XREAL_1:234;
A4: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
  card Stop SCM+FSA = 1 by COMPOS_1:46;
  then card I + card J + 3 < card II + card Stop SCM+FSA by A2,NAT_1:13;
  hence
  if=0(a,I,J). (card I + card J + 3) = IncAddr(halt SCM+FSA,card II
  ) by A1,A2,A3,Th13,A4
    .= halt SCM+FSA by COMPOS_1:93;
end;

theorem Th62:
  for I,J being Program of SCM+FSA,a being Int-Location holds if>0
  (a,I,J). (card I + card J + 3) = halt SCM+FSA
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
A1: if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  set II = a >0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
  ';' I;
A2: card II = card (Macro (a >0_goto  (card J + 3)) ';' J ';' Goto
   (card I + 1)) + card I by SCMFSA6A:61
    .= card (Macro (a >0_goto  (card J + 3)) ';' J) + card Goto
  (card I + 1) + card I by SCMFSA6A:61
    .= card (Macro (a >0_goto  (card J + 3)) ';' J) + 1 + card I by SCMFSA8A:29
    .= card Macro (a >0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
    .= 2 + card J + 1 + card I by COMPOS_1:150
    .= card I + card J + 3;
  then
A3: card I + card J + 3 -' card II = 0 by XREAL_1:234;
A4: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
  card Stop SCM+FSA = 1 by COMPOS_1:46;
  then card I + card J + 3 < card II + card Stop SCM+FSA by A2,NAT_1:13;
  hence
  if>0(a,I,J). (card I + card J + 3) = IncAddr(halt SCM+FSA,card II
  ) by A1,A2,A3,Th13,A4
    .= halt SCM+FSA by COMPOS_1:93;
end;

theorem Th63:
  for I,J being Program of SCM+FSA,a being Int-Location holds if=0
  (a,I,J). (card J + 2) = goto  (card I + card J + 3)
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  set JJ = a =0_goto  (card J + 3) ';' J;
  set J3 = a =0_goto  (card J + 3) ';' J ';' Goto  (card I + 1);
A1: if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
A2: card JJ = card Macro (a =0_goto  (card J + 3)) + card J by SCMFSA6A:61
    .= 2 + card J by COMPOS_1:150;
  then card J + 2 -' card JJ = 0 by XREAL_1:234;
  then
A3: goto  (card I + 1) = (Goto  (card I + 1)). (card J + 2
  -' card JJ) by SCMFSA8A:47;
  card Goto  (card I + 1) = 1 by SCMFSA8A:29;
  then card J + 2 < card JJ + card Goto  (card I + 1) by A2,NAT_1:13;
  then
A4: J3. (card J + 2) = IncAddr(goto  (card I + 1),card JJ) by A2,A3,Th13
    .= goto  (card I + 1 + (card J + 2)) by A2,SCMFSA_4:14
    .= goto  (card I + card J + (1 + 2));
  card Goto  (card I + 1) = 1 by SCMFSA8A:29;
  then card J3 = card J + 2 + 1 by A2,SCMFSA6A:61
    .= card J + (2 + 1);
  then card J3 = card J + 2 + 1;
  then card J + 2 < card J3 by NAT_1:13;
  then
A5:  (card J + 2) in dom J3 by AFINSQ_1:70;
  then (J3 ';' (I ';' Stop SCM+FSA)). (card J + 2) = (Directed J3).
   (card J + 2) by SCMFSA8A:28
    .= goto  (card I + card J + 3) by A4,A5,SCMFSA8A:30;
  hence thesis by A1,SCMFSA6A:67;
end;

theorem Th64:
  for I,J being Program of SCM+FSA,a being Int-Location holds if>0
  (a,I,J). (card J + 2) = goto  (card I + card J + 3)
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  set JJ = a >0_goto  (card J + 3) ';' J;
  set J3 = a >0_goto  (card J + 3) ';' J ';' Goto  (card I + 1);
A1: if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
A2: card JJ = card Macro (a >0_goto  (card J + 3)) + card J by SCMFSA6A:61
    .= 2 + card J by COMPOS_1:150;
  then card J + 2 -' card JJ = 0 by XREAL_1:234;
  then
A3: goto  (card I + 1) = (Goto  (card I + 1)). (card J + 2
  -' card JJ) by SCMFSA8A:47;
  card Goto  (card I + 1) = 1 by SCMFSA8A:29;
  then card J + 2 < card JJ + card Goto  (card I + 1) by A2,NAT_1:13;
  then
A4: J3. (card J + 2) = IncAddr(goto  (card I + 1),card JJ) by A2,A3,Th13
    .= goto  (card I + 1 + (card J + 2)) by A2,SCMFSA_4:14
    .= goto  (card I + card J + (1 + 2));
  card Goto  (card I + 1) = 1 by SCMFSA8A:29;
  then card J3 = card J + 2 + 1 by A2,SCMFSA6A:61
    .= card J + (2 + 1);
  then card J3 = card J + 2 + 1;
  then card J + 2 < card J3 by NAT_1:13;
  then
A5:  (card J + 2) in dom J3 by AFINSQ_1:70;
  then (J3 ';' (I ';' Stop SCM+FSA)). (card J + 2) = (Directed J3).
   (card J + 2) by SCMFSA8A:28
    .= goto  (card I + card J + 3) by A4,A5,SCMFSA8A:30;
  hence thesis by A1,SCMFSA6A:67;
end;

theorem Th65:
  for J being Program of SCM+FSA,a being Int-Location holds if=0(a
  ,Goto  2,J). (card J + 3) = goto  (card J + 5)
proof
  let J be Program of SCM+FSA;
  let a be Int-Location;
  set JJ = a =0_goto  (card J + 3) ';' J;
  set J3 = a =0_goto  (card J + 3) ';' J ';' Goto  2;
  set J4 = a =0_goto  (card J + 3) ';' J ';' Goto  2 ';' Goto
   2;
A1: card Goto  2 = 1 by SCMFSA8A:29;
  card JJ = card Macro (a =0_goto  (card J + 3)) + card J by SCMFSA6A:61
    .= 2 + card J by COMPOS_1:150;
  then
A2: card J3 = card J + 2 + 1 by A1,SCMFSA6A:61
    .= card J + (2 + 1);
  then card J + 3 -' card J3 = 0 by XREAL_1:234;
  then
A3: goto  2 = (Goto  2). (card J + 3 -' card J3) by SCMFSA8A:47;
  card Goto  2 = 1 by SCMFSA8A:29;
  then card J + 3 < card J3 + card Goto  2 by A2,NAT_1:13;
  then
A4: J4. (card J + 3) = IncAddr(goto  2,card J3) by A2,A3,Th13
    .= goto  (2 + (card J + 3)) by A2,SCMFSA_4:14
    .= goto  (card J + (2 + 3));
  card Goto  2 = 1 by SCMFSA8A:29;
  then
A5: if=0(a,Goto  2,J) = (a =0_goto  (card J + 3) ';' J ';' Goto
   (1 + 1) ';' Goto  2) ';' Stop SCM+FSA by SCMFSA8B:def 1;
  card J4 = card J + 3 + 1 by A1,A2,SCMFSA6A:61
    .= card J + (3 + 1);
  then card J4 = card J + 3 + 1;
  then card J + 3 < card J4 by NAT_1:13;
  then
A6:  (card J + 3) in dom J4 by AFINSQ_1:70;
  then (J4 ';' Stop SCM+FSA). (card J + 3) = (Directed J4). (card
  J + 3) by SCMFSA8A:28
    .= goto  (card J + 5) by A4,A6,SCMFSA8A:30;
  hence thesis by A5;
end;

theorem Th66:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & Directed I is_pseudo-closed_on s,P
holds if=0(a,I,J) is_halting_on s,P & if=0(a,I,J) is_closed_on s,P & LifeSpan(
P +* if=0(a,I,J),s +*
  (Initialize if=0(a,I,J)))
   = LifeSpan(P +* (I ';' Stop SCM+FSA),s +*
   Initialize (I ';' Stop SCM+FSA)) + 1
proof
  let s be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I0 = Directed I;
  set I1 = I ';' Stop SCM+FSA;
  set s00 = s +* (Initialize I0),
      P00 = P+*I0;
  set s3 = s +* (Initialize if=0(a,I,J)),
      P3 = P +* if=0(a,I,J);
A1: if=0(a,I,J) c= P3 by FUNCT_4:26;
A2: ProgramPart if=0(a,I,J) = if=0(a,I,J) by RELAT_1:209;
  set s4 = Comput(P3, s3,1);
  set i = a =0_goto  (card J + 3);
A3: Initialize I0 c= s00 by FUNCT_4:26;
  card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if=0(a,I,J) by NAT_1:13;
  then
A4:  (card I + card J + 3) in dom if=0(a,I,J) by AFINSQ_1:70;
A5: if=0(a,I,J) c= Initialize if=0(a,I,J) by SCMFSA8A:9;
  Initialize if=0(a,I,J) c= s3 by FUNCT_4:26;
  then
A6: if=0(a,I,J) c= s3 by A5,XBOOLE_1:1;
A7: not a in dom (Initialize if=0(a,I,J)) by SCMFSA6B:12;
A8:  0 in dom if=0(a,I,J) by Th54;
A9: P3. 0 = (if=0(a,I,J)). 0 by A8,A1,GRFUNC_1:8
    .= if=0(a,I,J). 0
    .= i by Th55;
A10: card (i ';' J ';' Goto  (card I + 1)) = card (Macro i ';' J) +
  card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by COMPOS_1:150
    .= card J + (2 + 1);
  IC SCM+FSA in dom (Initialize if=0(a,I,J)) by COMPOS_1:141;
  then
A11: IC s3 = IC(Initialize if=0(a,I,J)) by FUNCT_4:14
    .=  0 by COMPOS_1:142;
A12:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
A13: Comput(P3, s3,0+1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A11,A9,A12;
A14: if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  then if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
;
  then
A15: Reloc(I1,card J + 3) c= if=0(a,I,J) by A10,FUNCT_4:26;
  then Reloc(I1,card J + 3) c= s3 by A6,XBOOLE_1:1;
  then Reloc(I1,card J + 3) c= s4 by AMI_1:81;
  then
A16: Reloc(I1,card J + 3) c= s4;
A17:  Reloc(I0,card J + 3) c= Reloc(I1,card J + 3) by COMPOS_1:156,SCMFSA6A:55;
  then
A18: Reloc(I0,card J + 3) c= s4 by A16,XBOOLE_1:1;
   Reloc(I0,card J + 3) c= if=0(a,I,J) by A15,A17,XBOOLE_1:1;
   then
A19: Reloc(I0,card J + 3) c= P3 by XBOOLE_1:1,A1;
A20: DataPart s00 = DataPart s3 by COMPOS_1:138,SCMFSA8A:14;
A21: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A20,SCMFSA6A:38
      .= s4.f by A13,SCMFSA_2:96;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A20,SCMFSA6A:38
      .= s4.a by A13,SCMFSA_2:96;
  end;
  then
A22: DataPart s00 = DataPart s4 by A21,SCMFSA6A:38;
  assume s.a = 0;
  then s3.a = 0 by A7,FUNCT_4:12;
  then
A23: IC Comput(P3,s3,1) =  (card J + 3) by A13,SCMFSA_2:96;
  assume
A24: I0 is_pseudo-closed_on s,P;
  then
A25: pseudo-LifeSpan(s,P,I0)
 = LifeSpan(P +* I1,s +* (Initialize I1)) by Th58;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A26: I0 is_pseudo-closed_on s00,P00 by A24,Th52;
A27:  P3/.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0) + 1)
 = P3.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0) + 1) by PBOOLE:158;
A28: ProgramPart I0 = I0 by RELAT_1:209;
A29: I0 c= P00 by FUNCT_4:26;
:::B5: I1 c= P by FUNCT_4:26;
:::C5: if=0(a,I,J) c= P3 by zif;
A30: IC Comput(P3,s3,pseudo-LifeSpan(s00,P00,I0) +
1) = IC Comput(
P3, s4,
  pseudo-LifeSpan(s00,P00,I0)) by EXTPRO_1:5
    .= IC Comput(P00, s00,pseudo-LifeSpan(s00,P00,I0)) + (card J + 3)
by A3,A26,A18,A23,A22,Th51,A29,A19
    .= IC Comput(P00, s00,pseudo-LifeSpan(s,P,I0)
) + (card J + 3)
by A24,Th50
    .=  card I0 + (card J + 3) by A24,SCMFSA8A:def 5,A28
    .=  (card I + (card J + 3)) by SCMFSA8A:34
    .=  (card I + card J + 3);
  then
A31: CurInstr(P3,
     Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0) +
1)) = P3. (card I + card J + 3) by A27
    .= if=0(a,I,J). (card I + card J + 3) by A4,GRFUNC_1:8,A1
    .= halt SCM+FSA by Th61;
  then
A32: P3 halts_on s3 by EXTPRO_1:30;
  hence if=0(a,I,J) is_halting_on s,P by SCMFSA7B:def 8,A2;
  now
    let k be Element of NAT;
    per cases;
    suppose
      k = 0;
      then Comput(P3, s3,k) = s3 by EXTPRO_1:3;
      then IC Comput(P3, s3,k) =  0 by Th31;
      hence IC Comput(P3, s3,k) in dom if=0(a,I,J) by Th54;
    end;
    suppose
A33:  0 < k & k < pseudo-LifeSpan(s00,P00,I0) + 1;
      card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
        .= card I + card J + 3 + 1;
      then
A34:  card I + card J + 3 < card if=0(a,I,J) by XREAL_1:31;
      0 + 1 <= k by A33,INT_1:20;
      then consider k1 being Nat such that
A35:  1 + k1 = k by NAT_1:10;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider n = IC Comput(P00, s00,k1) as Element of NAT;
A36:  k1 < pseudo-LifeSpan(s00,P00,I0) by A33,A35,XREAL_1:8;
      then k1 < pseudo-LifeSpan(s,P,I0) by A24,Th50;
      then  n in dom I0 by A24,SCMFSA8A:31,A28;
      then n < card I0 by AFINSQ_1:70;
      then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
      then n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
      then
A37:  n + (card J + 3) < card if=0(a,I,J) by A34,XXREAL_0:2;
      IC Comput(P3, s3,k) = IC Comput(P3, s4,k1)
by A35,EXTPRO_1:5
        .= IC Comput(P00, s00,k1) + (card J + 3) by A3,A26,A18
,A23,A22,A36,Th51,A29,A19;
      hence IC Comput(P3, s3,k) in dom if=0(a,I,J) by A37,
AFINSQ_1:70;
    end;
    suppose
      0 < k & pseudo-LifeSpan(s00,P00,I0) + 1 <= k;
      hence IC Comput(P3, s3,k) in dom if=0(a,I,J) by A4,A30,A31,
EXTPRO_1:6;
    end;
  end;
  hence if=0(a,I,J) is_closed_on s,P by SCMFSA7B:def 7,A2;
  now
    set J1 = a =0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
    ';' I;
    let k be Element of NAT;
    assume
A38: CurInstr(P3,Comput(P3,s3,k)) = halt SCM+FSA;
    assume not pseudo-LifeSpan(s00,P00,I0) + 1 <= k;
    then
A39: k <= pseudo-LifeSpan(s00,P00,I0) by NAT_1:13;
A40:  0 in dom if=0(a,I,J) by Th54;
A41: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
A42:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
A43:  P3/.IC Comput(P3,s3,k) = P3.IC Comput(P3,s3,k) by PBOOLE:158;
    CurInstr(P3,Comput(P3,s3,0))
      = P3. 0 by Th31,A42,A41
      .= if=0(a,I,J). 0 by A40,A1,GRFUNC_1:8
      .= a =0_goto  (card J + 3) by Th55;
    then k <> 0 by A38;
    then consider k1 being Nat such that
A44: k1 + 1 = k by NAT_1:6;
    reconsider k1 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(P00, s00,k1) as Element of NAT;
    k1 < k by A44,XREAL_1:31;
    then
A45: k1 < pseudo-LifeSpan(s00,P00,I0) by A39,XXREAL_0:2;
    then k1 < pseudo-LifeSpan(s,P,I0) by A24,Th50;
    then  n in dom I0 by A24,SCMFSA8A:31,A28;
    then n < card I0 by AFINSQ_1:70;
    then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
    then
A46: n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
A47: IC Comput(P3, s3,k) = IC Comput(P3, s4,k1) by
A44,EXTPRO_1:5
      .= IC Comput(P00, s00,k1) + (card J + 3) by A3,A26,A18,A23
,A22,A45,Th51,A29,A19;
    card J1 = card (Macro (a =0_goto  (card J + 3)) ';' J ';' Goto
     (card I + 1)) + card I by SCMFSA6A:61
      .= card (Macro (a =0_goto  (card J + 3)) ';' J) + card Goto
     (card I + 1) + card I by SCMFSA6A:61
      .= card (Macro (a =0_goto  (card J + 3)) ';' J) + 1 + card I by
SCMFSA8A:29
      .= card Macro (a =0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
      .= 2 + card J + 1 + card I by COMPOS_1:150
      .= card I + card J + 3;
    then IC Comput(P3, s3,k) in dom J1 by A47,A46,AFINSQ_1:70;
    then
A48: IC Comput(P3, s3,k) in dom Directed J1 by FUNCT_4:105;
    then
A49: (Directed J1).IC Comput(P3, s3,k) in rng Directed J1 by
FUNCT_1:def 5;
    card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
      .= card I + card J + 3 + 1;
    then card I + card J + 3 < card if=0(a,I,J) by XREAL_1:31;
    then n + (card J + 3) < card if=0(a,I,J) by A46,XXREAL_0:2;
    then
A50: IC Comput(P3, s3,k) in dom if=0(a,I,J) by A47,AFINSQ_1:70;
A51: CurInstr(P3,Comput(P3,s3,k))
       = P3.IC Comput(P3, s3,k) by A43
      .= if=0(a,I,J).IC Comput(P3, s3,k) by A50,A1,GRFUNC_1:8;
    Directed J1 c= if=0(a,I,J) by A14,SCMFSA6A:55;
    then
    if=0(a,I,J).IC Comput(P3, s3,k) = (Directed J1).IC Comput(
P3, s3,
    k) by A48,GRFUNC_1:8;
    hence contradiction by A38,A49,A51,COMPOS_1:def 7;
  end;
  then LifeSpan(P3,s3) = pseudo-LifeSpan(s00,P00,I0) + 1
   by A31,A32,EXTPRO_1:def 14;
  hence thesis by A24,A25,Th50;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
  read-write Int-Location st s.intloc 0 = 1 & s.a = 0 & Directed I
  is_pseudo-closed_on s,P holds DataPart IExec(if=0(a,I,J),P,s)
   = DataPart IExec(I ';' Stop SCM+FSA,P,s)
proof
  let ss be State of SCM+FSA;
  set A = NAT;
  set D = Data-Locations SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I0 = Directed I;
  set s = Initialized ss;
  set I1 = I ';' Stop SCM+FSA;
  set s00 = s +* (Initialize I0),
      P00 = P+*I0;
  set s3 = s +* (Initialize if=0(a,I,J)),
      P3 = P +* if=0(a,I,J);
A1: if=0(a,I,J) c= P3 by FUNCT_4:26;
  set s4 = Comput(P3, s3,1);
  set i = a =0_goto  (card J + 3);
A2: I0 c= P00 by FUNCT_4:26;
  assume
A3: ss.intloc 0 = 1;
  set s1 = s +* (Initialize I1),
      P1 = P +* I1;
A4: ProgramPart I1 = I1 by RELAT_1:209;
  assume ss.a = 0;
  then
A5: s.a = 0 by SCMFSA6C:3;
  IC SCM+FSA in dom (Initialize if=0(a,I,J)) by COMPOS_1:141;
  then
A6: IC s3 = IC(Initialize if=0(a,I,J)) by FUNCT_4:14
    .=  0 by COMPOS_1:142;
A7:  0 in dom if=0(a,I,J) by Th54;
A8: P3. 0 = if=0(a,I,J). 0 by A7,FUNCT_4:14
    .= if=0(a,I,J). 0
    .= i by Th55;
A9:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
A10: Comput(P3, s3,0+1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A6,A8,A9;
  not a in dom (Initialize if=0(a,I,J)) by SCMFSA6B:12;
  then s3.a = 0 by A5,FUNCT_4:12;
  then
A11: IC Comput(P3,s3,1) =  (card J + 3) by A10,SCMFSA_2:96;
  assume I0 is_pseudo-closed_on ss,P;
  then
A12: I0 is_pseudo-closed_on s,P by A3,Th53;
  then
A13: LifeSpan(P1,s1) = pseudo-LifeSpan(s,P,I0) by Th58;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A14: I0 is_pseudo-closed_on s00,P00 by A12,Th52;
A15: DataPart s00 = DataPart s3 by COMPOS_1:138,SCMFSA8A:14;
A16: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A15,SCMFSA6A:38
      .= s4.f by A10,SCMFSA_2:96;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A15,SCMFSA6A:38
      .= s4.a by A10,SCMFSA_2:96;
  end;
  then
A17: DataPart s00 = DataPart s4 by A16,SCMFSA6A:38;
  card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if=0(a,I,J) by NAT_1:13;
  then
A18:  (card I + card J + 3) in dom if=0(a,I,J) by AFINSQ_1:70;
A19: card (i ';' J ';' Goto  (card I + 1)) = card (Macro i ';' J) +
  card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by COMPOS_1:150
    .= card J + (2 + 1);
  s +* Initialized if=0(a,I,J) = Initialized s +* (Initialize if=0(a,I,J))
  by SCMFSA8A:13;
  then
A20: s +* Initialized if=0(a,I,J) = s3 by Th15;
A21: if=0(a,I,J) c= Initialize if=0(a,I,J) by SCMFSA8A:9;
  Initialize if=0(a,I,J) c= s3 by FUNCT_4:26;
  then
A22: if=0(a,I,J) c= s3 by A21,XBOOLE_1:1;
A23: Initialize I0 c= s00 by FUNCT_4:26;
A24: if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  then if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
;
  then
A25:  Reloc(I1,card J + 3) c= if=0(a,I,J) by A19,FUNCT_4:26;
  then Reloc(I1,card J + 3) c= s3 by A22,XBOOLE_1:1;
  then Reloc(I1,card J + 3) c= s4 by AMI_1:81;
  then
A26: Reloc(I1,card J + 3) c= s4;
A27: Reloc(I0,card J + 3) c= Reloc(I1,card J+ 3) by COMPOS_1:156,SCMFSA6A:55;
  then
A28: Reloc(I0,card J + 3) c= s4 by A26,XBOOLE_1:1;
   Reloc(I0,card J + 3) c= if=0(a,I,J) by A25,A27,XBOOLE_1:1;
   then
A29: Reloc(I0,card J + 3) c= P3 by XBOOLE_1:1,A1;
A30:  P3/.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0) + 1)
 = P3.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0) + 1) by PBOOLE:158;
A31: ProgramPart I0 = I0 by RELAT_1:209;
  IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0) +
1) = IC Comput(
P3, s4,
  pseudo-LifeSpan(s00,P00,I0)) by EXTPRO_1:5
    .= IC Comput(P00, s00,pseudo-LifeSpan(s00,P00,I0)) + (card J + 3)
by A23,A14,A28,A11,A17,Th51,A2,A29
    .= IC Comput(P00, s00,pseudo-LifeSpan(s,P,I0)
) + (card J + 3)
by A12,Th50
    .=  card I0 + (card J + 3) by A12,SCMFSA8A:def 5,A31
    .=  (card I + (card J + 3)) by SCMFSA8A:34
    .=  (card I + card J + 3);
  then
A32: CurInstr(P3,
   Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0) + 1))
     = P3. (card I + card J + 3) by A30
    .= if=0(a,I,J). (card I + card J + 3) by A18,GRFUNC_1:8,A1
    .= halt SCM+FSA by Th61;
  then
A33: P3 halts_on s3 by EXTPRO_1:30;
  now
    set J1 = a =0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
    ';' I;
    let k be Element of NAT;
    assume
A34: CurInstr(P3,Comput(P3,s3,k)) = halt SCM+FSA;
    assume not pseudo-LifeSpan(s00,P00,I0) + 1 <= k;
    then
A35: k <= pseudo-LifeSpan(s00,P00,I0) by NAT_1:13;
A36:  0 in dom if=0(a,I,J) by Th54;
A37: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
A38:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
    CurInstr(P3,Comput(P3,s3,0))
      = P3. 0 by Th31,A38,A37
     .= if=0(a,I,J). 0 by A36,GRFUNC_1:8,A1
      .= a =0_goto  (card J + 3) by Th55;
    then k <> 0 by A34;
    then consider k1 being Nat such that
A39: k1 + 1 = k by NAT_1:6;
    reconsider k1 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(P00, s00,k1) as Element of NAT;
    k1 < k by A39,XREAL_1:31;
    then
A40: k1 < pseudo-LifeSpan(s00,P00,I0) by A35,XXREAL_0:2;
    then k1 < pseudo-LifeSpan(s,P,I0) by A12,Th50;
    then  n in dom I0 by A12,SCMFSA8A:31,A31;
    then n < card I0 by AFINSQ_1:70;
    then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
    then
A41: n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
A42: IC Comput(P3, s3,k) = IC Comput(P3, s4,k1) by
A39,EXTPRO_1:5
      .= IC Comput(P00, s00,k1) + (card J + 3) by A23,A14,A28,A11
,A17,A40,Th51,A2,A29;
    card J1 = card (Macro (a =0_goto  (card J + 3)) ';' J ';' Goto
     (card I + 1)) + card I by SCMFSA6A:61
      .= card (Macro (a =0_goto  (card J + 3)) ';' J) + card Goto
     (card I + 1) + card I by SCMFSA6A:61
      .= card (Macro (a =0_goto  (card J + 3)) ';' J) + 1 + card I by
SCMFSA8A:29
      .= card Macro (a =0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
      .= 2 + card J + 1 + card I by COMPOS_1:150
      .= card I + card J + 3;
    then IC Comput(P3, s3,k) in dom J1 by A42,A41,AFINSQ_1:70;
    then
A43: IC Comput(P3, s3,k) in dom Directed J1 by FUNCT_4:105;
    then
A44: (Directed J1).IC Comput(P3, s3,k) in rng Directed J1 by
FUNCT_1:def 5;
    card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
      .= card I + card J + 3 + 1;
    then card I + card J + 3 < card if=0(a,I,J) by XREAL_1:31;
    then n + (card J + 3) < card if=0(a,I,J) by A41,XXREAL_0:2;
    then
A45: IC Comput(P3, s3,k) in dom if=0(a,I,J) by A42,AFINSQ_1:70;
A46:  P3/.IC Comput(P3,s3,k) = P3.IC Comput(P3,s3,k) by PBOOLE:158;
A47: CurInstr(P3,Comput(P3,s3,k))
 = P3.IC Comput(P3, s3,k) by A46
      .= if=0(a,I,J).IC Comput(P3, s3,k) by A45,A1,GRFUNC_1:8;
    Directed J1 c= if=0(a,I,J) by A24,SCMFSA6A:55;
    then
    if=0(a,I,J).IC Comput(P3, s3,k) = (Directed J1).IC Comput(
P3, s3,
    k) by A43,GRFUNC_1:8;
    hence contradiction by A34,A44,A47,COMPOS_1:def 7;
  end;
  then
A48: LifeSpan(P3,s3) = pseudo-LifeSpan(s00,P00,I0)
+ 1 by A32,A33,EXTPRO_1:def 14;
  s +* Initialized I1 = Initialized s +* (Initialize I1) by
SCMFSA8A:13;
  then
A49: s +* Initialized I1 = s1 by Th15;
A50: I0 ';' Stop SCM+FSA = I1 by SCMFSA8A:41;
  Directed I0 = I0 by SCMFSA6A:63;
  then
A51: DataPart Comput(P00, s00,pseudo-LifeSpan(s,P,I0)) = DataPart
Comput(P1, s1,pseudo-LifeSpan(s,P,I0)) by A12,A50,Th58;
  I1 is_halting_on s,P by A12,Th58;
  then
A52: P1 halts_on s1 by SCMFSA7B:def 8,A4;
  thus DataPart IExec(if=0(a,I,J),P,ss)
   = DataPart IExec(if=0(a,I,J),P,s) by Th17
    .= DataPart(Result(P +* if=0(a,I,J),
        s +* Initialized if=0(a,I,J)) +* (s|NAT))
    .= DataPart Result(P3,s3) by A20,COMPOS_1:82
    .= DataPart Comput(P3, s3,LifeSpan(P3,s3)) by
A33,EXTPRO_1:23
    .= DataPart Comput(P3, s4,pseudo-LifeSpan(s00,P00,I0)) by A48,EXTPRO_1:5
    .= DataPart Comput(P00, s00,pseudo-LifeSpan(s00,P00,I0))
     by A23,A14,A28,A11,A17,Th51,A2,A29
    .= DataPart Comput(P1, s1,LifeSpan(P1,s1)) by A12
,A13,A51,Th50
    .= DataPart Result(P1,s1) by A52,EXTPRO_1:23
    .= DataPart(Result(P +* I1,s +* Initialized I1) +*
(s|NAT)) by A49,COMPOS_1:82
    .= DataPart IExec(I1,P,s)
    .= DataPart IExec(I1,P,ss) by Th17;
end;

theorem Th68:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & Directed I is_pseudo-closed_on s,P
holds if>0(a,I,J) is_halting_on s,P & if>0(a,I,J) is_closed_on s,P &
 LifeSpan(
P+* if>0(a,I,J),s +*
  (Initialize if>0(a,I,J)))
   = LifeSpan(P +* (I ';' Stop SCM+FSA),
   s +* (Initialize(I ';' Stop SCM+FSA))) + 1
proof
  let s be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I0 = Directed I;
A1: ProgramPart I0 = I0 by RELAT_1:209;
  set I1 = I ';' Stop SCM+FSA;
  set s00 = s +* (Initialize I0),
      P00 = P+*I0;
  set s3 = s +* (Initialize if>0(a,I,J)),
      P3 = P +* if>0(a,I,J);
  set s4 = Comput(P3, s3,1);
  set i = a >0_goto  (card J + 3);
A2: I0 c= P00 by FUNCT_4:26;
A3: ProgramPart if>0(a,I,J) = if>0(a,I,J) by RELAT_1:209;
A4: Initialize I0 c= s00 by FUNCT_4:26;
A5: if>0(a,I,J) c= P3 by FUNCT_4:26;
  card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if>0(a,I,J) by NAT_1:13;
  then
A6:  (card I + card J + 3) in dom if>0(a,I,J) by AFINSQ_1:70;
  IC SCM+FSA in dom (Initialize if>0(a,I,J)) by COMPOS_1:141;
  then
A7: IC s3 = IC(Initialize if>0(a,I,J)) by FUNCT_4:14
    .=  0 by COMPOS_1:142;
A8:  0 in dom if>0(a,I,J) by Th54;
A9: P3. 0 = (if>0(a,I,J)). 0 by A8,FUNCT_4:14
    .= if>0(a,I,J). 0
    .= i by Th55;
A10: card (i ';' J ';' Goto  (card I + 1)) = card (Macro i ';' J) +
  card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by COMPOS_1:150
    .= card J + (2 + 1);
A11:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
A12: Comput(P3, s3,0+1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A7,A9,A11;
A13: if>0(a,I,J) c= Initialize if>0(a,I,J) by SCMFSA8A:9;
  Initialize if>0(a,I,J) c= s3 by FUNCT_4:26;
  then
A14: if>0(a,I,J) c= s3 by A13,XBOOLE_1:1;
A15: if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  then if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
;
  then
A16: Reloc(I1,card J + 3) c= if>0(a,I,J) by A10,FUNCT_4:26;
  then Reloc(I1,card J + 3) c= s3 by A14,XBOOLE_1:1;
  then Reloc(I1,card J + 3) c= s4 by AMI_1:81;
  then
A17: Reloc(I1,card J + 3) c= s4;
A18:  Reloc(I0,card J + 3) c= Reloc(I1,card J
  + 3) by COMPOS_1:156,SCMFSA6A:55;
  then
A19: Reloc(I0,card J + 3) c= s4 by A17,XBOOLE_1:1;
    Reloc(I0,card J + 3) c= if>0(a,I,J) by A16,A18,XBOOLE_1:1;
    then
A20: Reloc(I0,card J + 3) c= P3 by A5,XBOOLE_1:1;
A21: DataPart s00 = DataPart s3 by COMPOS_1:138,SCMFSA8A:14;
A22: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A21,SCMFSA6A:38
      .= s4.f by A12,SCMFSA_2:97;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A21,SCMFSA6A:38
      .= s4.a by A12,SCMFSA_2:97;
  end;
  then
A23: DataPart s00 = DataPart s4 by A22,SCMFSA6A:38;
  not a in dom (Initialize if>0(a,I,J)) by SCMFSA6B:12;
  then
A24: s3.a = s.a by FUNCT_4:12;
  assume s.a > 0;
  then
A25: IC Comput(P3,s3,1) =  (card J + 3) by A12,A24,SCMFSA_2:97;
  assume
A26: I0 is_pseudo-closed_on s,P;
  then
A27: pseudo-LifeSpan(s,P,I0) = LifeSpan(P +* I1,s +* (Initialize I1)) by Th58;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A28: I0 is_pseudo-closed_on s00,P00 by A26,Th52;
A29:  P3/.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0) + 1)
 = P3.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0) + 1) by PBOOLE:158;
A30: IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0)
+ 1) = IC Comput(
P3, s4,
  pseudo-LifeSpan(s00,P00,I0)) by EXTPRO_1:5
    .= IC Comput(P00, s00,pseudo-LifeSpan(s00,P00,I0)) + (card J + 3)
by A4,A28,A19,A25,A23,Th51,A2,A20
    .= IC Comput(P00, s00,pseudo-LifeSpan(s,P,I0)
) + (card J + 3)
by A26,Th50
    .=  card I0 + (card J + 3) by A26,SCMFSA8A:def 5,A1
    .=  (card I + (card J + 3)) by SCMFSA8A:34
    .=  (card I + card J + 3);
  then
A31: CurInstr(P3,
    Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0) + 1
)) = P3. (card I + card J + 3) by A29
    .= if>0(a,I,J). (card I + card J + 3) by A6,GRFUNC_1:8,A5
    .= halt SCM+FSA by Th62;
  then
A32: P3 halts_on s3 by EXTPRO_1:30;
  hence if>0(a,I,J) is_halting_on s,P by SCMFSA7B:def 8,A3;
  now
    let k be Element of NAT;
    per cases;
    suppose
      k = 0;
      then Comput(P3, s3,k) = s3 by EXTPRO_1:3;
      then IC Comput(P3, s3,k) =  0 by Th31;
      hence IC Comput(P3, s3,k) in dom if>0(a,I,J) by Th54;
    end;
    suppose
A33:  0 < k & k < pseudo-LifeSpan(s00,P00,I0) + 1;
      card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
        .= card I + card J + 3 + 1;
      then
A34:  card I + card J + 3 < card if>0(a,I,J) by XREAL_1:31;
      0 + 1 <= k by A33,INT_1:20;
      then consider k1 being Nat such that
A35:  1 + k1 = k by NAT_1:10;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider n = IC Comput(P00, s00,k1) as Element of NAT;
A36:  k1 < pseudo-LifeSpan(s00,P00,I0) by A33,A35,XREAL_1:8;
      then k1 < pseudo-LifeSpan(s,P,I0) by A26,Th50;
      then  n in dom I0 by A26,SCMFSA8A:31,A1;
      then n < card I0 by AFINSQ_1:70;
      then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
      then n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
      then
A37:  n + (card J + 3) < card if>0(a,I,J) by A34,XXREAL_0:2;
      IC Comput(P3, s3,k) = IC Comput(P3, s4,k1)
by A35,EXTPRO_1:5
        .= IC Comput(P00, s00,k1) + (card J + 3) by A4,A28,A19
          ,A25,A23,A36,Th51,A2,A20;
      hence IC Comput(P3, s3,k) in dom if>0(a,I,J) by A37,
AFINSQ_1:70;
    end;
    suppose
      0 < k & pseudo-LifeSpan(s00,P00,I0) + 1 <= k;
      hence IC Comput(P3, s3,k) in dom if>0(a,I,J) by A6,A30,A31,
EXTPRO_1:6;
    end;
  end;
  hence if>0(a,I,J) is_closed_on s,P by SCMFSA7B:def 7,A3;
  now
    set J1 = a >0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
    ';' I;
    let k be Element of NAT;
    assume
A38: CurInstr(P3,Comput(P3,s3,k)) = halt SCM+FSA;
    assume not pseudo-LifeSpan(s00,P00,I0) + 1 <= k;
    then
A39: k <= pseudo-LifeSpan(s00,P00,I0) by NAT_1:13;
A40:  0 in dom if>0(a,I,J) by Th54;
A41: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
A42:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
    CurInstr(P3,Comput(P3,s3,0))
      = P3. 0 by Th31,A42,A41
      .= if>0(a,I,J). 0 by A40,A5,GRFUNC_1:8
      .= a >0_goto  (card J + 3) by Th55;
    then k <> 0 by A38;
    then consider k1 being Nat such that
A43: k1 + 1 = k by NAT_1:6;
    reconsider k1 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(P00, s00,k1) as Element of NAT;
    k1 < k by A43,XREAL_1:31;
    then
A44: k1 < pseudo-LifeSpan(s00,P00,I0) by A39,XXREAL_0:2;
    then k1 < pseudo-LifeSpan(s,P,I0) by A26,Th50;
    then  n in dom I0 by A26,SCMFSA8A:31,A1;
    then n < card I0 by AFINSQ_1:70;
    then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
    then
A45: n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
A46: IC Comput(P3, s3,k) = IC Comput(P3, s4,k1) by
A43,EXTPRO_1:5
      .= IC Comput(P00, s00,k1) + (card J + 3) by A4,A28,A19,A25
,A23,A44,Th51,A2,A20;
    card J1 = card (Macro (a >0_goto  (card J + 3)) ';' J ';' Goto
     (card I + 1)) + card I by SCMFSA6A:61
      .= card (Macro (a >0_goto  (card J + 3)) ';' J) + card Goto
     (card I + 1) + card I by SCMFSA6A:61
      .= card (Macro (a >0_goto  (card J + 3)) ';' J) + 1 + card I by
SCMFSA8A:29
      .= card Macro (a >0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
      .= 2 + card J + 1 + card I by COMPOS_1:150
      .= card I + card J + 3;
    then IC Comput(P3, s3,k) in dom J1 by A46,A45,AFINSQ_1:70;
    then
A47: IC Comput(P3, s3,k) in dom Directed J1 by FUNCT_4:105;
    then
A48: (Directed J1).IC Comput(P3, s3,k) in rng Directed J1 by
FUNCT_1:def 5;
    card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
      .= card I + card J + 3 + 1;
    then card I + card J + 3 < card if>0(a,I,J) by XREAL_1:31;
    then n + (card J + 3) < card if>0(a,I,J) by A45,XXREAL_0:2;
    then
A49: IC Comput(P3, s3,k) in dom if>0(a,I,J) by A46,AFINSQ_1:70;
A50: P3/.IC Comput(P3,s3,k) = P3.IC Comput(P3,s3,k) by PBOOLE:158;
A51: CurInstr(P3,Comput(P3,s3,k))
 = P3.IC Comput(P3, s3,k) by A50
      .= if>0(a,I,J).IC Comput(P3, s3,k) by A49,GRFUNC_1:8,A5;
    Directed J1 c= if>0(a,I,J) by A15,SCMFSA6A:55;
    then
    if>0(a,I,J).IC Comput(P3, s3,k) = (Directed J1).IC Comput(
P3, s3,
    k) by A47,GRFUNC_1:8;
    hence contradiction by A38,A48,A51,COMPOS_1:def 7;
  end;
  then LifeSpan(P3,s3) = pseudo-LifeSpan(s00,P00,
I0) + 1 by A31,A32,EXTPRO_1:def 14;
  hence thesis by A26,A27,Th50;
end;

theorem Th69:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.intloc 0 = 1 & s.a > 0 & Directed I
  is_pseudo-closed_on s,P holds DataPart IExec(if>0(a,I,J),P,s)
   = DataPart IExec(I ';' Stop SCM+FSA,P,s)
proof
  let ss be State of SCM+FSA;
  set A = NAT;
  set D = Data-Locations SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I0 = Directed I;
A1: ProgramPart I0 = I0 by RELAT_1:209;
  set s = Initialized ss;
  set I1 = I ';' Stop SCM+FSA;
  set s00 = s +* (Initialize I0),
      P00 = P+*I0;
  set s3 = s +* (Initialize if>0(a,I,J)),
      P3 = P +* if>0(a,I,J);
  set s4 = Comput(P3, s3,1);
  set i = a >0_goto  (card J + 3);
A2: I0 c= P00 by FUNCT_4:26;
A3: if>0(a,I,J) c= P3 by FUNCT_4:26;
  assume
A4: ss.intloc 0 = 1;
  set s1 = s +* (Initialize I1),
      P1 = P +* I1;
A5: ProgramPart I1 = I1 by RELAT_1:209;
  assume ss.a > 0;
  then
A6: s.a > 0 by SCMFSA6C:3;
  IC SCM+FSA in dom (Initialize if>0(a,I,J)) by COMPOS_1:141;
  then
A7: IC s3 = IC(Initialize if>0(a,I,J)) by FUNCT_4:14
    .=  0 by COMPOS_1:142;
A8:  0 in dom if>0(a,I,J) by Th54;
A9: P3. 0 = (if>0(a,I,J)). 0
by A8,FUNCT_4:14
    .= if>0(a,I,J). 0
    .= i by Th55;
A10:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
A11: Comput(P3, s3,0+1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A7,A9,A10;
  not a in dom (Initialize if>0(a,I,J)) by SCMFSA6B:12;
  then s3.a = s.a by FUNCT_4:12;
  then
A12: IC Comput(P3,s3,1) =  (card J + 3) by A6,A11,SCMFSA_2:97;
  assume I0 is_pseudo-closed_on ss,P;
  then
A13: I0 is_pseudo-closed_on s,P by A4,Th53;
  then
A14: LifeSpan(P1,s1) = pseudo-LifeSpan(s,P,I0) by Th58;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A15: I0 is_pseudo-closed_on s00,P00 by A13,Th52;
A16: DataPart s00 = DataPart s3 by COMPOS_1:138,SCMFSA8A:14;
A17: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A16,SCMFSA6A:38
      .= s4.f by A11,SCMFSA_2:97;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A16,SCMFSA6A:38
      .= s4.a by A11,SCMFSA_2:97;
  end;
  then
A18: DataPart s00 = DataPart s4 by A17,SCMFSA6A:38;
  card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if>0(a,I,J) by NAT_1:13;
  then
A19:  (card I + card J + 3) in dom if>0(a,I,J) by AFINSQ_1:70;
A20: card (i ';' J ';' Goto  (card I + 1)) = card (Macro i ';' J) +
  card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by COMPOS_1:150
    .= card J + (2 + 1);
  s +* Initialized if>0(a,I,J) = Initialized s +* (Initialize if>0(a,I,J))
  by SCMFSA8A:13;
  then
A21: s +* Initialized if>0(a,I,J) = s3 by Th15;
A22: if>0(a,I,J) c= Initialize if>0(a,I,J) by SCMFSA8A:9;
  Initialize if>0(a,I,J) c= s3 by FUNCT_4:26;
  then
A23: if>0(a,I,J) c= s3 by A22,XBOOLE_1:1;
A24: Initialize I0 c= s00 by FUNCT_4:26;
A25: if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  then if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
;
  then
A26: Reloc(I1,card J + 3) c= if>0(a,I,J) by A20,FUNCT_4:26;
  then Reloc(I1,card J + 3) c= s3 by A23,XBOOLE_1:1;
  then Reloc(I1,card J + 3) c= s4 by AMI_1:81;
  then
A27: Reloc(I1,card J + 3) c= s4;
A28:  Reloc(I0,card J + 3) c= Reloc(I1,card J
  + 3) by COMPOS_1:156,SCMFSA6A:55;
  then
A29: Reloc(I0,card J + 3) c= s4 by A27,XBOOLE_1:1;
  Reloc(I0,card J + 3) c= if>0(a,I,J) by A26,A28,XBOOLE_1:1;
  then
A30: Reloc(I0,card J + 3) c= P3 by A3,XBOOLE_1:1;
A31:  P3/.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0) + 1)
 = P3.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0) + 1) by PBOOLE:158;
  IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0) +
1) = IC Comput(
P3, s4,
  pseudo-LifeSpan(s00,P00,I0)) by EXTPRO_1:5
    .= IC Comput(P00, s00,pseudo-LifeSpan(s00,P00,I0)) + (card J + 3)
by A24,A15,A29,A12,A18,Th51,A2,A30
    .= IC Comput(P00, s00,pseudo-LifeSpan(s,P,I0)
) + (card J + 3)
by A13,Th50
    .=  card I0 + (card J + 3) by A13,SCMFSA8A:def 5,A1
    .=  (card I + (card J + 3)) by SCMFSA8A:34
    .=  (card I + card J + 3);
  then
A32: CurInstr(P3,
   Comput(P3, s3,pseudo-LifeSpan(s00,P00,I0) + 1))
     = P3. (card I + card J + 3) by A31
    .= if>0(a,I,J). (card I + card J + 3) by A19,GRFUNC_1:8,A3
    .= halt SCM+FSA by Th62;
  then
A33: P3 halts_on s3 by EXTPRO_1:30;
  now
    set J1 = a >0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
    ';' I;
    let k be Element of NAT;
    assume
A34: CurInstr(P3,Comput(P3,s3,k)) = halt SCM+FSA;
    assume not pseudo-LifeSpan(s00,P00,I0) + 1 <= k;
    then
A35: k <= pseudo-LifeSpan(s00,P00,I0) by NAT_1:13;
A36:  0 in dom if>0(a,I,J) by Th54;
A37: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
A38:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
    CurInstr(P3,Comput(P3,s3,0))
      = P3. 0 by Th31,A38,A37
      .= if>0(a,I,J). 0 by A36,A3,GRFUNC_1:8
      .= a >0_goto  (card J + 3) by Th55;
    then k <> 0 by A34;
    then consider k1 being Nat such that
A39: k1 + 1 = k by NAT_1:6;
    reconsider k1 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(P00, s00,k1) as Element of NAT;
    k1 < k by A39,XREAL_1:31;
    then
A40: k1 < pseudo-LifeSpan(s00,P00,I0) by A35,XXREAL_0:2;
    then k1 < pseudo-LifeSpan(s,P,I0) by A13,Th50;
    then  n in dom I0 by A13,SCMFSA8A:31,A1;
    then n < card I0 by AFINSQ_1:70;
    then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
    then
A41: n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
A42: IC Comput(P3, s3,k) = IC Comput(P3, s4,k1) by
A39,EXTPRO_1:5
      .= IC Comput(P00, s00,k1) + (card J + 3) by A24,A15,A29,A12
,A18,A40,Th51,A2,A30;
    card J1 = card (Macro (a >0_goto  (card J + 3)) ';' J ';' Goto
     (card I + 1)) + card I by SCMFSA6A:61
      .= card (Macro (a >0_goto  (card J + 3)) ';' J) + card Goto
     (card I + 1) + card I by SCMFSA6A:61
      .= card (Macro (a >0_goto  (card J + 3)) ';' J) + 1 + card I by
SCMFSA8A:29
      .= card Macro (a >0_goto  (card J + 3)) + card J + 1 + card I by
SCMFSA6A:61
      .= 2 + card J + 1 + card I by COMPOS_1:150
      .= card I + card J + 3;
    then IC Comput(P3, s3,k) in dom J1 by A42,A41,AFINSQ_1:70;
    then
A43: IC Comput(P3, s3,k) in dom Directed J1 by FUNCT_4:105;
    then
A44: (Directed J1).IC Comput(P3, s3,k) in rng Directed J1 by
FUNCT_1:def 5;
    card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
      .= card I + card J + 3 + 1;
    then card I + card J + 3 < card if>0(a,I,J) by XREAL_1:31;
    then n + (card J + 3) < card if>0(a,I,J) by A41,XXREAL_0:2;
    then
A45: IC Comput(P3, s3,k) in dom if>0(a,I,J) by A42,AFINSQ_1:70;
A46:  P3/.IC Comput(P3,s3,k) = P3.IC Comput(P3,s3,k) by PBOOLE:158;
A47: CurInstr(P3,Comput(P3,s3,k))
 = P3.IC Comput(P3, s3,k) by A46
      .= if>0(a,I,J).IC Comput(P3, s3,k) by A45,GRFUNC_1:8,A3;
    Directed J1 c= if>0(a,I,J) by A25,SCMFSA6A:55;
    then
    if>0(a,I,J).IC Comput(P3, s3,k) = (Directed J1).IC Comput(
P3, s3,
    k) by A43,GRFUNC_1:8;
    hence contradiction by A34,A44,A47,COMPOS_1:def 7;
  end;
  then
A48: LifeSpan(P3,s3) = pseudo-LifeSpan(s00,P00,I0)
+ 1 by A32,A33,EXTPRO_1:def 14;
  s +* Initialized I1 = Initialized s +* (Initialize I1) by
SCMFSA8A:13;
  then
A49: s +* Initialized I1 = s1 by Th15;
A50: I0 ';' Stop SCM+FSA = I1 by SCMFSA8A:41;
  Directed I0 = I0 by SCMFSA6A:63;
  then
A51: DataPart Comput(P00, s00,pseudo-LifeSpan(s,P,
I0)) = DataPart
Comput(P1, s1,pseudo-LifeSpan(s,P,I0)) by A13,A50,Th58;
  I1 is_halting_on s,P by A13,Th58;
  then
A52: P1 halts_on s1 by SCMFSA7B:def 8,A5;
  thus DataPart IExec(if>0(a,I,J),P,ss)
   = DataPart IExec(if>0(a,I,J),P,s) by Th17
    .= DataPart(Result(P +* if>0(a,I,J),s +*
Initialized if>0(a,I,J)) +* (s|NAT))
    .= DataPart Result(P3,s3) by A21,COMPOS_1:82
    .= DataPart Comput(P3, s3,LifeSpan(P3,s3)) by
A33,EXTPRO_1:23
    .= DataPart Comput(P3, s4,pseudo-LifeSpan(
s00,P00,I0)) by A48,EXTPRO_1:5
    .= DataPart Comput(P00, s00,pseudo-LifeSpan(
s00,P00,I0)) by A24,A15,A29,A12,A18,Th51,A2,A30
    .= DataPart Comput(P1, s1,LifeSpan(P1,s1)) by A13
,A14,A51,Th50
    .= DataPart Result(P1,s1) by A52,EXTPRO_1:23
    .= DataPart(Result(P +* I1,s +* Initialized I1) +* (s|NAT))
     by A49,COMPOS_1:82
    .= DataPart IExec(I1,P,s)
    .= DataPart IExec(I1,P,ss) by Th17;
end;

theorem Th70:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a <> 0 &
   Directed J is_pseudo-closed_on s,P
holds if=0(a,I,J) is_halting_on s,P & if=0(a,I,J) is_closed_on s,P & LifeSpan(
P +* if=0(a,I,J),s +*
  (Initialize if=0(a,I,J)))
   = LifeSpan(P +* (J ';' Stop SCM+FSA),
   s +* (Initialize(J ';' Stop SCM+FSA))) + 3
proof
  let s be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set J0 = Directed J;
A1: ProgramPart J0 = J0 by RELAT_1:209;
  set s0 = Initialized s;
  set J9 = J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA));
  set s00 = s +* (Initialize J0),
      P00 = P+*J0;
  set s3 = s +* (Initialize if=0(a,I,J)),
      P3 = P +* if=0(a,I,J);
  set s4 = Comput(P3, s3,1);
  set s5 = Comput(P3, s3,2);
  set i = a =0_goto  (card J + 3);
A2: if=0(a,I,J) c= P3 by FUNCT_4:26;
A3: J0 c= P00 by FUNCT_4:26;
A4: ProgramPart if=0(a,I,J) = if=0(a,I,J) by RELAT_1:209;
A5: Initialize J0 c= s00 by FUNCT_4:26;
  if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  then if=0(a,I,J) = Macro i ';' J ';' Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA) by SCMFSA6A:67;
  then if=0(a,I,J) = Macro i ';' J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA)) by SCMFSA6A:67;
  then
A6: if=0(a,I,J) = Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA))) by SCMFSA6A:67;
  card Macro i = 2 by COMPOS_1:150;
  then
A7: Reloc(J9,2) c= if=0(a,I,J) by A6,FUNCT_4:26;
A8:  0 in dom if=0(a,I,J) by Th54;
A9: P3. 0 = (if=0(a,I,J)). 0 by A8,FUNCT_4:14
    .= if=0(a,I,J). 0
    .= i by Th55;
  card if=0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:14
    .= card J + 2 + (card I + 2);
  then
A10: card J + 2 + 0 < card if=0(a,I,J) by XREAL_1:10;
  then
A11:  (card J + 2) in dom if=0(a,I,J) by AFINSQ_1:70;
  IC SCM+FSA in dom (Initialize if=0(a,I,J)) by COMPOS_1:141;
  then
A12: IC s3 = IC(Initialize if=0(a,I,J)) by FUNCT_4:14
    .=  0 by COMPOS_1:142;
  set ss = Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2),
      PP = P3;
A13: if=0(a,I,J) c= Initialize if=0(a,I,J) by SCMFSA8A:9;
  Initialize if=0(a,I,J) c= s3 by FUNCT_4:26;
  then if=0(a,I,J) c= s3 by A13,XBOOLE_1:1;
  then Reloc(J9,2) c= s3 by A7,XBOOLE_1:1;
  then Reloc(J9,2) c= s5 by AMI_1:81;
  then
A14: Reloc(J9,2) c= s5;
A15: Reloc(J0,2) c= Reloc(J9,2) by COMPOS_1:156,SCMFSA6A:55;
  then
A16: Reloc(J0,2) c= s5 by A14,XBOOLE_1:1;
  Reloc(J0,2) c= if=0(a,I,J) by A7,A15,XBOOLE_1:1;
  then
A17: Reloc(J0,2) c= P3 by A2,XBOOLE_1:1;
  card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if=0(a,I,J) by NAT_1:13;
  then
A18:  (card I + card J + 3) in dom if=0(a,I,J) by AFINSQ_1:70;
  assume s.a <> 0;
  then
A19: s0.a <> 0 by SCMFSA6C:3;
A20:  1 in dom if=0(a,I,J) by Th54;
  assume
A21: J0 is_pseudo-closed_on s,P;
  then
A22: pseudo-LifeSpan(s,P,J0) = LifeSpan(P +* (J ';' Stop SCM+FSA),
  s +* Initialize(J ';' Stop SCM+FSA)) by Th58;
A23: P3. 1 = (if=0(a,I,J)). 1
    by A20,FUNCT_4:14
    .= if=0(a,I,J). 1
    .= goto  2 by Th55;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A24: J0 is_pseudo-closed_on s00,P00 by A21,Th52;
A25:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
A26: Comput(P3, s3,0+1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A12,A9,A25;
  s3.a = s.a by Th28
    .= s0.a by SCMFSA6C:3;
  then
A27: IC s4 = succ IC s3 by A19,A26,SCMFSA_2:96
    .=  (0 + 1) by A12;
A28:  P3/.IC s4 = P3.IC s4 by PBOOLE:158;
A29: Comput(P3, s3,1+1) = Following(P3,s4) by
EXTPRO_1:4
    .= Exec(goto  2,s4) by A27,A28,A23;
  then
A30: IC s5 =  2 by SCMFSA_2:95;
A31: DataPart s00 = DataPart s3 by COMPOS_1:138,SCMFSA8A:14;
A32: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A31,SCMFSA6A:38
      .= s4.f by A26,SCMFSA_2:96
      .= s5.f by A29,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A31,SCMFSA6A:38
      .= s4.a by A26,SCMFSA_2:96
      .= s5.a by A29,SCMFSA_2:95;
  end;
  then
A33: DataPart s00 = DataPart s5 by A32,SCMFSA6A:38;
A34:  P3/.IC ss = P3.IC ss by PBOOLE:158;
A35: IC ss = IC Comput(P3, s5,pseudo-LifeSpan(
s00,P00,J0)) by EXTPRO_1:5
    .= IC Comput(P00, s00,pseudo-LifeSpan(s00,P00
,J0)) + 2 by A5,A24,A16,A30,A33,Th51,A3,A17
    .= IC Comput(P00, s00,pseudo-LifeSpan(s,P,J0)
) + 2 by A21,Th50
    .=  card J0 + 2 by A21,SCMFSA8A:def 5,A1
    .=  (card J + 2) by SCMFSA8A:34;
  then
A36: CurInstr(P3,ss) = P3. (card J + 2) by A34
    .= if=0(a,I,J). (card J + 2) by A11,GRFUNC_1:8,A2
    .= goto  (card I + card J + 3) by Th63;
A37:  P3/.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2+ 1)
 = P3.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2+ 1) by PBOOLE:158;
A38: IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0)
+ 2 + 1) =
IC Following(P3,ss)
  by EXTPRO_1:4
    .=  (card I + card J + 3) by A36,SCMFSA_2:95;
  then
A39: CurInstr(P3,
      Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2 + 1))
     = P3. (card I + card J + 3) by A37
    .= if=0(a,I,J). (card I + card J + 3) by A18,GRFUNC_1:8,A2
    .= halt SCM+FSA by Th61;
  then
A40: P3 halts_on s3 by EXTPRO_1:30;
  hence if=0(a,I,J) is_halting_on s,P by SCMFSA7B:def 8,A4;
  now
    let k be Element of NAT;
    per cases;
    suppose
      k = 0;
      then Comput(P3, s3,k) = s3 by EXTPRO_1:3;
      then IC Comput(P3, s3,k) =  0 by Th31;
      hence IC Comput(P3, s3,k) in dom if=0(a,I,J) by Th54;
    end;
    suppose
      0 < k & k = 1;
      hence IC Comput(P3, s3,k) in dom if=0(a,I,J) by A27,Th54;
    end;
    suppose
A41:  0 < k & k <> 1 & k < pseudo-LifeSpan(s00,P00,J0) + 2;
      then 0 + 1 <= k by INT_1:20;
      then 1 < k by A41,XXREAL_0:1;
      then 0 + (1 + 1) <= k by INT_1:20;
      then consider k2 being Nat such that
A42:  2 + k2 = k by NAT_1:10;
      card if=0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:14
        .= card J + 2 + (card I + 2);
      then
A43:  card J + 2 <= card if=0(a,I,J) by NAT_1:12;
      reconsider k2 as Element of NAT by ORDINAL1:def 13;
      reconsider n = IC Comput(P00, s00,k2) as Element of NAT;
A44:  k2 < pseudo-LifeSpan(s00,P00,J0) by A41,A42,XREAL_1:8;
      then k2 < pseudo-LifeSpan(s,P,J0) by A21,Th50;
      then  n in dom J0 by A21,SCMFSA8A:31,A1;
      then n < card J0 by AFINSQ_1:70;
      then n + 2 < card J0 + 2 by XREAL_1:8;
      then n + 2 < card J + 2 by SCMFSA8A:34;
      then
A45:  n + 2 < card if=0(a,I,J) by A43,XXREAL_0:2;
      IC Comput(P3, s3,k) = IC Comput(P3, s5,k2)
by A42,EXTPRO_1:5
        .= IC Comput(P00, s00,k2) + 2 by A5,A24,A16,A30,A33,A44
,Th51,A3,A17;
      hence IC Comput(P3, s3,k) in dom if=0(a,I,J) by A45,
AFINSQ_1:70;
    end;
    suppose
A46:  0 < k & k <> 1 & pseudo-LifeSpan(s00,P00,J0) + 2 <= k;
      hereby
        per cases by A46,XXREAL_0:1;
        suppose
          pseudo-LifeSpan(s00,P00,J0) + 2 = k;
          hence IC Comput(P3, s3,k) in dom if=0(a,I,J) by A10,A35,
AFINSQ_1:70;
        end;
        suppose
          pseudo-LifeSpan(s00,P00,J0) + 2 < k;
          then pseudo-LifeSpan(s00,P00,J0) + 2 + 1 <= k by INT_1:20;
          hence IC Comput(P3, s3,k) in dom if=0(a,I,J) by A18,A38
,A39,EXTPRO_1:6;
        end;
      end;
    end;
  end;
  hence if=0(a,I,J) is_closed_on s,P by SCMFSA7B:def 7,A4;
A47:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
A48: CurInstr(P3,s3) = i by A12,A9,A47;
  now
A49: 0 + 2 < card I + card J + 3 by XREAL_1:10;
    then
A50:  2 in dom if=0(a,I,J) by Th56;
A51: if=0(a,I,J). 2 <> halt SCM+FSA by A49,Th56;
A52:  P3/.IC Comput(P3,s3,2) = P3.IC Comput(P3,s3,2) by PBOOLE:158;
A53: CurInstr(P3,Comput(P3,
s3,2)) = P3. 2
 by A30,A52
      .= if=0(a,I,J). 2 by A50,GRFUNC_1:8,A2;
    let k be Element of NAT;
A54:  P3/.IC Comput(P3,s3,k) = P3.IC Comput(P3,s3,k) by PBOOLE:158;
A55: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    assume
A56: CurInstr(P3,Comput(P3,s3,k)) = halt SCM+FSA;
    CurInstr(P3,Comput(P3,s3
,0)) = i
     by A48,A55;
    then
A57: k <> 0 by A56;
A58:  k <> 1 by A27,A56,A54,A23;
:::A23: IC s4 = .=  (0 + 1) by A8;
    k <> 2 by A56,A51,A53;
    then 2 < k by A57,A58,NAT_1:27;
    then consider k2 being Nat such that
A59: 2 + k2 = k by NAT_1:10;
    reconsider k2 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(P00, s00,k2) as Element of NAT;
    assume not pseudo-LifeSpan(s00,P00,J0) + (1 + 2) <= k;
    then k < pseudo-LifeSpan(s00,P00,J0) + 1 + 2;
    then k2 < pseudo-LifeSpan(s00,P00,J0) + 1 by A59,XREAL_1:8;
    then
A60: k2 <= pseudo-LifeSpan(s00,P00,J0) by NAT_1:13;
    then
A61: k2 <= pseudo-LifeSpan(s,P,J0) by A21,Th50;
A62: now
      per cases by A61,XXREAL_0:1;
      suppose
A63:    k2 = pseudo-LifeSpan(s,P,J0);
        card I + card J + (2 + 1) = card J + 2 + 1 + card I;
        then
A64:    card J + 2 + 1 <= card I + card J + 3 by NAT_1:11;
        IC Comput(P00, s00,k2) =  card J0 by A21,A63,
SCMFSA8A:def 5,A1;
        then n = card J by SCMFSA8A:34;
        hence n + 2 < card I + card J + 3 by A64,NAT_1:13;
      end;
      suppose
        k2 < pseudo-LifeSpan(s,P,J0);
        then  n in dom J0 by A21,SCMFSA8A:31,A1;
        then n < card J0 by AFINSQ_1:70;
        then n + 2 < card J0 + 2 by XREAL_1:8;
        then
A65:    n + 2 < card J + 2 by SCMFSA8A:34;
        card I + card J + (1 + 2) = card J + 2 + (card I + 1);
        then card J + 2 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A65,XXREAL_0:2;
      end;
    end;
    then
A66:  (n + 2) in dom if=0(a,I,J) by Th56;
A67: IC Comput(P3, s3,k) = IC Comput(P3, s5,k2) by
A59,EXTPRO_1:5
      .=  (n + 2) by A5,A24,A16,A30,A33,A60,Th51,A3,A17;
A68: P3/.IC Comput(P3,s3,k) = P3.IC Comput(P3,s3,k) by PBOOLE:158;
    CurInstr(P3,Comput(P3,s3,k))
     = P3.IC Comput(P3, s3,k) by A68
      .= if=0(a,I,J).IC Comput(P3, s3,k) by A67,A66,GRFUNC_1:8,A2;
    hence contradiction by A56,A67,A62,Th56;
  end;
  then LifeSpan(P3,s3) = pseudo-LifeSpan(s00,P00,
J0) + 3 by A39,A40,EXTPRO_1:def 14;
  hence thesis by A21,A22,Th50;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
  read-write Int-Location st s.intloc 0 = 1 & s.a <> 0 & Directed J
  is_pseudo-closed_on s,P holds
   DataPart IExec(if=0(a,I,J),P,s) = DataPart IExec(J ';' Stop SCM+FSA,P,s)
proof
  let ss be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  set A = NAT;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set J0 = Directed J;
A1: ProgramPart J0 = J0 by RELAT_1:209;
  set s = Initialized ss;
  set s0 = Initialized s;
  set J9 = J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA));
  set s00 = s +* (Initialize J0),
      P00 = P+*J0;
  set s3 = s +* (Initialize if=0(a,I,J)),
      P3 = P +* if=0(a,I,J);
  set s4 = Comput(P3, s3,1);
  set s5 = Comput(P3, s3,2);
  set i = a =0_goto  (card J + 3);
A2: J0 c= P00 by FUNCT_4:26;
A3: if=0(a,I,J) c= P3 by FUNCT_4:26;
  assume
A4: ss.intloc 0 = 1;
  set s1 = s +* Initialize (J ';' Stop SCM+FSA),
      P1 = P +* (J ';' Stop SCM+FSA);
A5: ProgramPart (J ';' Stop SCM+FSA) = (J ';' Stop SCM+FSA) by RELAT_1:209;
  assume ss.a <> 0;
  then s.a <> 0 by SCMFSA6C:3;
  then
A6: s0.a <> 0 by SCMFSA6C:3;
A7:  0 in dom if=0(a,I,J) by Th54;
A8: P3. 0 = (if=0(a,I,J)). 0
by A7,FUNCT_4:14
    .= if=0(a,I,J). 0
    .= i by Th55;
  s +* Initialized if=0(a,I,J) = Initialized s +* (Initialize if=0(a,I,J))
  by SCMFSA8A:13;
  then
A9: s +* Initialized if=0(a,I,J) = s3 by Th15;
A10: J0 ';' Stop SCM+FSA = J ';' Stop SCM+FSA by SCMFSA8A:41;
  IC SCM+FSA in dom (Initialize if=0(a,I,J)) by COMPOS_1:141;
  then
A11: IC s3 = IC(Initialize if=0(a,I,J)) by FUNCT_4:14
    .=  0 by COMPOS_1:142;
  if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  then if=0(a,I,J) = Macro i ';' J ';' Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA) by SCMFSA6A:67;
  then if=0(a,I,J) = Macro i ';' J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA)) by SCMFSA6A:67;
  then
A12: if=0(a,I,J) = Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA))) by SCMFSA6A:67;
  card Macro i = 2 by COMPOS_1:150;
  then
A13: Reloc(J9,2) c= if=0(a,I,J) by A12,FUNCT_4:26;
A14: if=0(a,I,J) c= Initialize if=0(a,I,J) by SCMFSA8A:9;
  Initialize if=0(a,I,J) c= s3 by FUNCT_4:26;
  then if=0(a,I,J) c= s3 by A14,XBOOLE_1:1;
  then Reloc(J9,2) c= s3 by A13,XBOOLE_1:1;
  then Reloc(J9,2) c= s5 by AMI_1:81;
  then
A15: Reloc(J9,2) c= s5;
A16: Reloc(J0,2) c= Reloc(J9,2) by COMPOS_1:156,
SCMFSA6A:55;
  then
A17: Reloc(J0,2) c= s5 by A15,XBOOLE_1:1;
   Reloc(J0,2) c= if=0(a,I,J) by A13,A16,XBOOLE_1:1;
   then
A18: Reloc(J0,2) c= P3 by XBOOLE_1:1,A3;
A19:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
A20: Comput(P3, s3,0+1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A11,A8,A19;
  assume J0 is_pseudo-closed_on ss,P;
  then
A21: J0 is_pseudo-closed_on s,P by A4,Th53;
  then J ';' Stop SCM+FSA is_halting_on s,P by Th58;
  then
A22: P1 halts_on s1 by SCMFSA7B:def 8,A5;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A23: J0 is_pseudo-closed_on s00,P00 by A21,Th52;
  s +* Initialized (J ';' Stop SCM+FSA) = Initialized s +*
  Initialize (J ';' Stop SCM+FSA) by SCMFSA8A:13;
  then
A24: s +* Initialized (J ';' Stop SCM+FSA) = s1 by Th15;
A25: Directed J0 = J0 by SCMFSA6A:63;
  card if=0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:14
    .= card J + 2 + (card I + 2);
  then card J + 2 + 0 < card if=0(a,I,J) by XREAL_1:10;
  then
A26:  (card J + 2) in dom if=0(a,I,J) by AFINSQ_1:70;
  card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if=0(a,I,J) by NAT_1:13;
  then
A27:  (card I + card J + 3) in dom if=0(a,I,J) by AFINSQ_1:70;
  set s9 = Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2);
A28: Initialize J0 c= s00 by FUNCT_4:26;
  LifeSpan(P1,s1) = pseudo-LifeSpan(s,P,J0) by A21,Th58;
  then
A29: DataPart Comput(P00, s00,pseudo-LifeSpan(s,P,J0)) = DataPart
Comput(P1, s1,LifeSpan(P1,s1)) by A21,A25,A10,Th58;
A30:  1 in dom if=0(a,I,J) by Th54;
  s3.a = s.a by Th28
    .= s0.a by SCMFSA6C:3;
  then
A31: IC s4 = succ IC s3 by A6,A20,SCMFSA_2:96
    .=  (0 + 1) by A11;
A32: P3. 1
    = (if=0(a,I,J)). 1
    by A30,FUNCT_4:14
    .= if=0(a,I,J). 1
    .= goto  2 by Th55;
A33:  P3/.IC s4 = P3.IC s4 by PBOOLE:158;
A34: Comput(P3, s3,1+1) = Following(P3,s4) by
EXTPRO_1:4
    .= Exec(goto  2,s4) by A31,A32,A33;
  then
A35: IC s5 =  2 by SCMFSA_2:95;
A36: DataPart s00 = DataPart s3 by COMPOS_1:138,SCMFSA8A:14;
A37: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A36,SCMFSA6A:38
      .= s4.f by A20,SCMFSA_2:96
      .= s5.f by A34,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A36,SCMFSA6A:38
      .= s4.a by A20,SCMFSA_2:96
      .= s5.a by A34,SCMFSA_2:95;
  end;
  then
A38: DataPart s00 = DataPart s5 by A37,SCMFSA6A:38;
A39:  P3/.IC s9 = P3.IC s9 by PBOOLE:158;
A40: IC s9 = IC Comput(P3, s5,pseudo-LifeSpan(
s00,P00,J0)) by EXTPRO_1:5
    .= IC Comput(P00, s00,pseudo-LifeSpan(s00,P00
,J0)) + 2 by A28,A23,A17,A35,A38,Th51,A2,A18
    .= IC Comput(P00, s00,pseudo-LifeSpan(s,P,J0)
) + 2 by A21,Th50
    .=  card J0 + 2 by A21,SCMFSA8A:def 5,A1
    .=  (card J + 2) by SCMFSA8A:34;
  then
A41: CurInstr(P3,s9) = P3. (card J + 2) by A39
    .= if=0(a,I,J). (card J + 2) by A26,GRFUNC_1:8,A3
    .= goto  (card I + card J + 3) by Th63;
A42:  P3/.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2+ 1)
 = P3.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2+ 1) by PBOOLE:158;
  IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) +
2 + 1) =
  IC Following(P3,s9)
  by EXTPRO_1:4
    .=  (card I + card J + 3) by A41,SCMFSA_2:95;
  then
A43: CurInstr(P3,
   Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2
+ 1)) = P3. (
  card I + card J + 3) by A42
    .= if=0(a,I,J). (card I + card J + 3) by A27,GRFUNC_1:8,A3
    .= halt SCM+FSA by Th61;
  then
A44: P3 halts_on s3 by EXTPRO_1:30;
A45:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
A46: CurInstr(P3,s3) = i by A11,A8,A45;
  now
A47: 0 + 2 < card I + card J + 3 by XREAL_1:10;
    then
A48:  2 in dom if=0(a,I,J) by Th56;
A49: if=0(a,I,J). 2 <> halt SCM+FSA by A47,Th56;
A50:  P3/.IC Comput(P3,s3,2) = P3.IC Comput(P3,s3,2) by PBOOLE:158;
A51: CurInstr(P3,Comput(P3,
s3,2)) = P3. 2
 by A35,A50
      .= if=0(a,I,J). 2 by A48,GRFUNC_1:8,A3;
    let k be Element of NAT;
    assume
A52: CurInstr(P3,Comput(P3,
s3,k)) = halt SCM+FSA;
A53: P3/.IC Comput(P3,s3,k) = P3.IC Comput(P3,s3,k) by PBOOLE:158;
A54: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    CurInstr(P3,Comput(P3,s3
,0)) = i
     by A46,A54;
    then
A55: k <> 0 by A52;
A56:    k <> 1 by A31,A32,A52,A53;
    2 <> k by A52,A49,A51;
    then 2 < k by A55,A56,NAT_1:27;
    then consider k2 being Nat such that
A57: 2 + k2 = k by NAT_1:10;
    reconsider k2 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(P00, s00,k2) as Element of NAT;
    assume not pseudo-LifeSpan(s00,P00,J0) + (1 + 2) <= k;
    then k < pseudo-LifeSpan(s00,P00,J0) + 1 + 2;
    then k2 < pseudo-LifeSpan(s00,P00,J0) + 1 by A57,XREAL_1:8;
    then
A58: k2 <= pseudo-LifeSpan(s00,P00,J0) by NAT_1:13;
    then
A59: k2 <= pseudo-LifeSpan(s,P,J0) by A21,Th50;
A60: now
      per cases by A59,XXREAL_0:1;
      suppose
A61:    k2 = pseudo-LifeSpan(s,P,J0);
        card I + card J + (2 + 1) = card J + 2 + 1 + card I;
        then
A62:    card J + 2 + 1 <= card I + card J + 3 by NAT_1:11;
        IC Comput(P00, s00,k2) =  card J0 by A21,A61,
SCMFSA8A:def 5,A1;
        then n = card J by SCMFSA8A:34;
        hence n + 2 < card I + card J + 3 by A62,NAT_1:13;
      end;
      suppose
        k2 < pseudo-LifeSpan(s,P,J0);
        then  n in dom J0 by A21,SCMFSA8A:31,A1;
        then n < card J0 by AFINSQ_1:70;
        then n + 2 < card J0 + 2 by XREAL_1:8;
        then
A63:    n + 2 < card J + 2 by SCMFSA8A:34;
        card I + card J + (1 + 2) = card J + 2 + (card I + 1);
        then card J + 2 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A63,XXREAL_0:2;
      end;
    end;
    then
A64:  (n + 2) in dom if=0(a,I,J) by Th56;
A65: IC Comput(P3, s3,k) = IC Comput(P3, s5,k2) by
A57,EXTPRO_1:5
      .=  (n + 2) by A28,A23,A17,A35,A38,A58,Th51,A2,A18;
A66:  P3/.IC Comput(P3,s3,k) = P3.IC Comput(P3,s3,k) by PBOOLE:158;
    CurInstr(P3,Comput(P3,s3,k))
     = P3.IC Comput(P3, s3,k) by A66
      .= if=0(a,I,J).IC Comput(P3, s3,k) by A65,A64,GRFUNC_1:8,A3;
    hence contradiction by A52,A65,A60,Th56;
  end;
  then
A67: LifeSpan(P3,s3) = pseudo-LifeSpan(s00,P00,J0)
+ 2 + 1 by A43,A44,EXTPRO_1:def 14;
A68:  P3/.IC s9 = P3.IC s9 by PBOOLE:158;
  CurInstr(P3,s9) = P3. (card J + 2) by A40,A68
    .= if=0(a,I,J). (card J + 2) by A26,GRFUNC_1:8,A3
    .= goto  (card I + card J + 3) by Th63;
  then InsCode CurInstr(P3,s9) = 6 by SCMFSA_2:47;
  then InsCode CurInstr(P3,s9) in {0,6,7,8} by ENUMSET1:def 2;
  then
A69: DataPart s9 = DataPart Following(P3,s9) by Th32;
A70: DataPart s9 = DataPart Comput(P3, s5,pseudo-LifeSpan(
s00,P00,J0)
) by EXTPRO_1:5
    .= DataPart Comput(P00, s00,pseudo-LifeSpan(
s00,P00,J0)) by A28,A23,A17,A35,A38,Th51,A2,A18;
  thus DataPart IExec(if=0(a,I,J),P,ss)
   = DataPart IExec(if=0(a,I,J),P,s) by Th17
    .= DataPart(Result(P +* if=0(a,I,J),s +*
Initialized if=0(a,I,J)) +* (s|NAT))
    .= DataPart Result(P3,s3) by A9,COMPOS_1:82
    .= DataPart Comput(P3, s3,LifeSpan(P3,s3)) by
A44,EXTPRO_1:23
    .= DataPart Following(P3,s9) by A67,EXTPRO_1:4
    .= DataPart Comput(P00, s00,pseudo-LifeSpan(s,P,J0))
             by A21,A70,A69,Th50
    .= DataPart Result(P1,s1) by A22,A29,EXTPRO_1:23
    .= DataPart(Result(P +* (J ';' Stop SCM+FSA),
         s +* Initialized (J ';' Stop SCM+FSA)) +* (s|NAT)) by A24,COMPOS_1:82
    .= DataPart IExec(J ';' Stop SCM+FSA,P,s)
    .= DataPart IExec(J ';' Stop SCM+FSA,P,ss) by Th17;
end;

theorem Th72:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a <= 0 &
   Directed J is_pseudo-closed_on s,P
holds if>0(a,I,J) is_halting_on s,P & if>0(a,I,J) is_closed_on s,P &
  LifeSpan(P +* if>0(a,I,J),s +*
  (Initialize if>0(a,I,J))) =
  LifeSpan(P +* (J ';' Stop SCM+FSA),s +* Initialize (J ';' Stop SCM+FSA)) + 3
proof
  let s be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set J0 = Directed J;
A1: ProgramPart J0 = J0 by RELAT_1:209;
  set s0 = Initialized s;
  set J9 = J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA));
  set s00 = s +* (Initialize J0),
      P00 = P+*J0;
  set s3 = s +* (Initialize if>0(a,I,J)),
      P3 = P +* if>0(a,I,J);
A2: if>0(a,I,J) c= P3 by FUNCT_4:26;
  set s4 = Comput(P3, s3,1);
  set s5 = Comput(P3, s3,2);
  set i = a >0_goto  (card J + 3);
A3: J0 c= P00 by FUNCT_4:26;
A4: ProgramPart if>0(a,I,J) = if>0(a,I,J) by RELAT_1:209;
A5: Initialize J0 c= s00 by FUNCT_4:26;
  if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  then if>0(a,I,J) = Macro i ';' J ';' Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA) by SCMFSA6A:67;
  then if>0(a,I,J) = Macro i ';' J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA)) by SCMFSA6A:67;
  then
A6: if>0(a,I,J) = Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA))) by SCMFSA6A:67;
  card Macro i = 2 by COMPOS_1:150;
  then
A7: Reloc(J9,2) c= if>0(a,I,J) by A6,FUNCT_4:26;
A8:  0 in dom if>0(a,I,J) by Th54;
A9: P3. 0 = (if>0(a,I,J)). 0 by A8,FUNCT_4:14
    .= if>0(a,I,J). 0
    .= i by Th55;
  card if>0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:15
    .= card J + 2 + (card I + 2);
  then
A10: card J + 2 + 0 < card if>0(a,I,J) by XREAL_1:10;
  then
A11:  (card J + 2) in dom if>0(a,I,J) by AFINSQ_1:70;
  IC SCM+FSA in dom (Initialize if>0(a,I,J)) by COMPOS_1:141;
  then
A12: IC s3 = IC(Initialize if>0(a,I,J)) by FUNCT_4:14
    .=  0 by COMPOS_1:142;
  set ss = Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2),
      PP = P3;
A13: if>0(a,I,J) c= Initialize if>0(a,I,J) by SCMFSA8A:9;
  Initialize if>0(a,I,J) c= s3 by FUNCT_4:26;
  then if>0(a,I,J) c= s3 by A13,XBOOLE_1:1;
  then Reloc(J9,2) c= s3 by A7,XBOOLE_1:1;
  then Reloc(J9,2) c= s5 by AMI_1:81;
  then
A14: Reloc(J9,2) c= s5;
A15: Reloc(J0,2) c= Reloc(J9,2) by COMPOS_1:156,
SCMFSA6A:55;
  then
A16: Reloc(J0,2) c= s5 by A14,XBOOLE_1:1;
   Reloc(J0,2) c= if>0(a,I,J) by A7,A15,XBOOLE_1:1;
   then
A17: Reloc(J0,2) c= P3 by XBOOLE_1:1,A2;
  card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if>0(a,I,J) by NAT_1:13;
  then
A18:  (card I + card J + 3) in dom if>0(a,I,J) by AFINSQ_1:70;
  assume s.a <= 0;
  then
A19: s0.a <= 0 by SCMFSA6C:3;
A20:  1 in dom if>0(a,I,J) by Th54;
  assume
A21: J0 is_pseudo-closed_on s,P;
  then
A22: pseudo-LifeSpan(s,P,J0) = LifeSpan(P +* (J ';' Stop SCM+FSA),
s +* Initialize(J ';' Stop SCM+FSA)) by Th58;
A23: P3. 1  = (if>0(a,I,J)). 1
    by A20,FUNCT_4:14
    .= if>0(a,I,J). 1
    .= goto  2 by Th55;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A24: J0 is_pseudo-closed_on s00,P00 by A21,Th52;
A25:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
A26: Comput(P3, s3,0+1) =
Following(P3,Comput(P3,s3,0)
) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A12,A9,A25;
  s3.a = s.a by Th28
    .= s0.a by SCMFSA6C:3;
  then
A27: IC s4 = succ IC s3 by A19,A26,SCMFSA_2:97
    .=  (0 + 1) by A12;
A28:  P3/.IC s4 = P3.IC s4 by PBOOLE:158;
A29: Comput(P3, s3,1+1) = Following(P3,s4) by
EXTPRO_1:4
    .= Exec(goto  2,s4) by A27,A28,A23;
  then
A30: IC s5 =  2 by SCMFSA_2:95;
A31: DataPart s00 = DataPart s3 by COMPOS_1:138,SCMFSA8A:14;
A32: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A31,SCMFSA6A:38
      .= s4.f by A26,SCMFSA_2:97
      .= s5.f by A29,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A31,SCMFSA6A:38
      .= s4.a by A26,SCMFSA_2:97
      .= s5.a by A29,SCMFSA_2:95;
  end;
  then
A33: DataPart s00 = DataPart s5 by A32,SCMFSA6A:38;
A34:  P3/.IC ss = P3.IC ss by PBOOLE:158;
A35: IC ss = IC Comput(P3, s5,pseudo-LifeSpan(
s00,P00,J0)) by EXTPRO_1:5
    .= IC Comput(P00, s00,pseudo-LifeSpan(s00,P00
,J0)) + 2 by A5,A24,A16,A30,A33,Th51,A3,A17
    .= IC Comput(P00, s00,pseudo-LifeSpan(s,P,J0)
) + 2 by A21,Th50
    .=  card J0 + 2 by A21,SCMFSA8A:def 5,A1
    .=  (card J + 2) by SCMFSA8A:34;
  then
A36: CurInstr(P3,ss) = P3. (card J + 2) by A34
    .= if>0(a,I,J). (card J + 2) by A11,GRFUNC_1:8,A2
    .= goto  (card I + card J + 3) by Th64;
A37:  P3/.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2+ 1)
 = P3.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2+ 1) by PBOOLE:158;
A38: IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0)
+ 2 + 1) =
IC Following(P3,ss)
  by EXTPRO_1:4
    .=  (card I + card J + 3) by A36,SCMFSA_2:95;
  then
A39: CurInstr(P3,
   Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2
+ 1)) = P3. (
  card I + card J + 3) by A37
    .= if>0(a,I,J). (card I + card J + 3) by A18,GRFUNC_1:8,A2
    .= halt SCM+FSA by Th62;
  then
A40: P3 halts_on s3 by EXTPRO_1:30;
  hence if>0(a,I,J) is_halting_on s,P by SCMFSA7B:def 8,A4;
  now
    let k be Element of NAT;
    per cases;
    suppose
      k = 0;
      then Comput(P3, s3,k) = s3 by EXTPRO_1:3;
      then IC Comput(P3, s3,k) =  0 by Th31;
      hence IC Comput(P3, s3,k) in dom if>0(a,I,J) by Th54;
    end;
    suppose
      0 < k & k = 1;
      hence IC Comput(P3, s3,k) in dom if>0(a,I,J) by A27,Th54;
    end;
    suppose
A41:  0 < k & k <> 1 & k < pseudo-LifeSpan(s00,P00,J0) + 2;
      then 0 + 1 <= k by INT_1:20;
      then 1 < k by A41,XXREAL_0:1;
      then 0 + (1 + 1) <= k by INT_1:20;
      then consider k2 being Nat such that
A42:  2 + k2 = k by NAT_1:10;
      card if>0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:15
        .= card J + 2 + (card I + 2);
      then
A43:  card J + 2 <= card if>0(a,I,J) by NAT_1:12;
      reconsider k2 as Element of NAT by ORDINAL1:def 13;
      reconsider n = IC Comput(P00, s00,k2) as Element of NAT;
A44:  k2 < pseudo-LifeSpan(s00,P00,J0) by A41,A42,XREAL_1:8;
      then k2 < pseudo-LifeSpan(s,P,J0) by A21,Th50;
      then  n in dom J0 by A21,SCMFSA8A:31,A1;
      then n < card J0 by AFINSQ_1:70;
      then n + 2 < card J0 + 2 by XREAL_1:8;
      then n + 2 < card J + 2 by SCMFSA8A:34;
      then
A45:  n + 2 < card if>0(a,I,J) by A43,XXREAL_0:2;
      IC Comput(P3, s3,k) = IC Comput(P3, s5,k2)
by A42,EXTPRO_1:5
        .= IC Comput(P00, s00,k2) + 2 by A5,A24,A16,A30,A33,A44
,Th51,A3,A17;
      hence IC Comput(P3, s3,k) in dom if>0(a,I,J) by A45,
AFINSQ_1:70;
    end;
    suppose
A46:  0 < k & k <> 1 & pseudo-LifeSpan(s00,P00,J0) + 2 <= k;
      hereby
        per cases by A46,XXREAL_0:1;
        suppose
          pseudo-LifeSpan(s00,P00,J0) + 2 = k;
          hence IC Comput(P3, s3,k) in dom if>0(a,I,J) by A10,A35,
AFINSQ_1:70;
        end;
        suppose
          pseudo-LifeSpan(s00,P00,J0) + 2 < k;
          then pseudo-LifeSpan(s00,P00,J0) + 2 + 1 <= k by INT_1:20;
          hence IC Comput(P3, s3,k) in dom if>0(a,I,J) by A18,A38
,A39,EXTPRO_1:6;
        end;
      end;
    end;
  end;
  hence if>0(a,I,J) is_closed_on s,P by SCMFSA7B:def 7,A4;
A47:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
A48: CurInstr(P3,s3) = i by A12,A9,A47;
  now
A49: 0 + 2 < card I + card J + 3 by XREAL_1:10;
    then
A50:  2 in dom if>0(a,I,J) by Th57;
A51: if>0(a,I,J). 2 <> halt SCM+FSA by A49,Th57;
A52:  P3/.IC Comput(P3,s3,2) = P3.IC Comput(P3,s3,2) by PBOOLE:158;
A53: CurInstr(P3,Comput(P3,s3,2)) = P3. 2
 by A30,A52
      .= if>0(a,I,J). 2 by A50,GRFUNC_1:8,A2;
    let k be Element of NAT;
    assume
A54: CurInstr(P3,Comput(P3,s3,k)) = halt SCM+FSA;
A55: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
A56: P3/.IC Comput(P3,s3,k) = P3.IC Comput(P3,s3,k) by PBOOLE:158;
    CurInstr(P3,Comput(P3,s3
,0)) = i
     by A48,A55;
    then
A57: k <> 0 by A54;
A58:    k <> 1 by A27,A54,A56,A23;
    2 <> k by A54,A51,A53;
    then 2 < k by A57,A58,NAT_1:27;
    then consider k2 being Nat such that
A59: 2 + k2 = k by NAT_1:10;
    reconsider k2 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(P00, s00,k2) as Element of NAT;
    assume not pseudo-LifeSpan(s00,P00,J0) + (1 + 2) <= k;
    then k < pseudo-LifeSpan(s00,P00,J0) + 1 + 2;
    then k2 < pseudo-LifeSpan(s00,P00,J0) + 1 by A59,XREAL_1:8;
    then
A60: k2 <= pseudo-LifeSpan(s00,P00,J0) by NAT_1:13;
    then
A61: k2 <= pseudo-LifeSpan(s,P,J0) by A21,Th50;
A62: now
      per cases by A61,XXREAL_0:1;
      suppose
A63:    k2 = pseudo-LifeSpan(s,P,J0);
        card I + card J + (2 + 1) = card J + 2 + 1 + card I;
        then
A64:    card J + 2 + 1 <= card I + card J + 3 by NAT_1:11;
        IC Comput(P00, s00,k2) =  card J0 by A21,A63,
SCMFSA8A:def 5,A1;
        then n = card J by SCMFSA8A:34;
        hence n + 2 < card I + card J + 3 by A64,NAT_1:13;
      end;
      suppose
        k2 < pseudo-LifeSpan(s,P,J0);
        then  n in dom J0 by A21,SCMFSA8A:31,A1;
        then n < card J0 by AFINSQ_1:70;
        then n + 2 < card J0 + 2 by XREAL_1:8;
        then
A65:    n + 2 < card J + 2 by SCMFSA8A:34;
        card I + card J + (1 + 2) = card J + 2 + (card I + 1);
        then card J + 2 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A65,XXREAL_0:2;
      end;
    end;
    then
A66:  (n + 2) in dom if>0(a,I,J) by Th57;
A67: IC Comput(P3, s3,k) = IC Comput(P3, s5,k2) by
A59,EXTPRO_1:5
      .=  (n + 2) by A5,A24,A16,A30,A33,A60,Th51,A3,A17;
A68:  P3/.IC Comput(P3,s3,k) = P3.IC Comput(P3,s3,k) by PBOOLE:158;
    CurInstr(P3,Comput(P3,s3,k))
     = P3.IC Comput(P3, s3,k) by A68
      .= if>0(a,I,J).IC Comput(P3, s3,k) by A67,A66,GRFUNC_1:8,A2;
    hence contradiction by A54,A67,A62,Th57;
  end;
  then LifeSpan(P3,s3) = pseudo-LifeSpan(s00,P00,
J0) + 3 by A39,A40,EXTPRO_1:def 14;
  hence thesis by A21,A22,Th50;
end;

theorem Th73:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.intloc 0 = 1 & s.a <= 0 & Directed J
  is_pseudo-closed_on s,P holds
   DataPart IExec(if>0(a,I,J),P,s) = DataPart IExec(J
  ';' Stop SCM+FSA,P,s)
proof
  let ss be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  set A = NAT;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set J0 = Directed J;
A1: ProgramPart J0 = J0 by RELAT_1:209;
  set s = Initialized ss;
  set s0 = Initialized s;
  set J9 = J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA));
  set s00 = s +* (Initialize J0),
      P00 = P+*J0;
  set s3 = s +* (Initialize if>0(a,I,J)),
      P3 = P +* if>0(a,I,J);
  set s4 = Comput(P3, s3,1);
  set s5 = Comput(P3, s3,2);
  set i = a >0_goto  (card J + 3);
A2: if>0(a,I,J) c= P3 by FUNCT_4:26;
A3: J0 c= P00 by FUNCT_4:26;
  assume
A4: ss.intloc 0 = 1;
  set s1 = s +* Initialize(J ';' Stop SCM+FSA),
     P1 = P +* (J ';' Stop SCM+FSA);
A5: ProgramPart(J ';' Stop SCM+FSA) = (J ';' Stop SCM+FSA) by RELAT_1:209;
  assume ss.a <= 0;
  then s.a <= 0 by SCMFSA6C:3;
  then
A6: s0.a <= 0 by SCMFSA6C:3;
A7:  0 in dom if>0(a,I,J) by Th54;
A8: P3. 0 = (if>0(a,I,J)). 0
by A7,FUNCT_4:14
    .= if>0(a,I,J). 0
    .= i by Th55;
  s +* Initialized if>0(a,I,J) = Initialized s +* (Initialize if>0(a,I,J))
  by SCMFSA8A:13;
  then
A9: s +* Initialized if>0(a,I,J) = s3 by Th15;
A10: J0 ';' Stop SCM+FSA = J ';' Stop SCM+FSA by SCMFSA8A:41;
  IC SCM+FSA in dom (Initialize if>0(a,I,J)) by COMPOS_1:141;
  then
A11: IC s3 = IC(Initialize if>0(a,I,J)) by FUNCT_4:14
    .=  0 by COMPOS_1:142;
  if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  then if>0(a,I,J) = Macro i ';' J ';' Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA) by SCMFSA6A:67;
  then if>0(a,I,J) = Macro i ';' J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA)) by SCMFSA6A:67;
  then
A12: if>0(a,I,J) = Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';'
  Stop SCM+FSA))) by SCMFSA6A:67;
  card Macro i = 2 by COMPOS_1:150;
  then
A13: Reloc(J9,2) c= if>0(a,I,J) by A12,FUNCT_4:26;
A14: if>0(a,I,J) c= Initialize if>0(a,I,J) by SCMFSA8A:9;
  Initialize if>0(a,I,J) c= s3 by FUNCT_4:26;
  then if>0(a,I,J) c= s3 by A14,XBOOLE_1:1;
  then Reloc(J9,2) c= s3 by A13,XBOOLE_1:1;
  then Reloc(J9,2) c= s5 by AMI_1:81;
  then
A15: Reloc(J9,2) c= s5;
A16: Reloc(J0,2) c= Reloc(J9,2) by COMPOS_1:156,
SCMFSA6A:55;
  then
A17: Reloc(J0,2) c= s5 by A15,XBOOLE_1:1;
   Reloc(J0,2) c= if>0(a,I,J) by A13,A16,XBOOLE_1:1;
   then
A18: Reloc(J0,2) c= P3 by XBOOLE_1:1,A2;
A19:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
A20: Comput(P3, s3,0+1) =
Following(P3,Comput(P3,s3,0)
)
 by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A11,A8,A19;
  assume J0 is_pseudo-closed_on ss,P;
  then
A21: J0 is_pseudo-closed_on s,P by A4,Th53;
  then J ';' Stop SCM+FSA is_halting_on s,P by Th58;
  then
A22: P1 halts_on s1 by SCMFSA7B:def 8,A5;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A23: J0 is_pseudo-closed_on s00,P00 by A21,Th52;
  s +* Initialized (J ';' Stop SCM+FSA) = Initialized s +*
  Initialize (J ';' Stop SCM+FSA) by SCMFSA8A:13;
  then
A24: s +* Initialized (J ';' Stop SCM+FSA) = s1 by Th15;
A25: Directed J0 = J0 by SCMFSA6A:63;
  card if>0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:15
    .= card J + 2 + (card I + 2);
  then card J + 2 + 0 < card if>0(a,I,J) by XREAL_1:10;
  then
A26:  (card J + 2) in dom if>0(a,I,J) by AFINSQ_1:70;
  card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
    .= card I + card J + 3 + 1;
  then card I + card J + 3 < card if>0(a,I,J) by NAT_1:13;
  then
A27:  (card I + card J + 3) in dom if>0(a,I,J) by AFINSQ_1:70;
  set s9 = Comput(P3, s3,pseudo-LifeSpan(s00,P00,
J0) + 2);
A28: Initialize J0 c= s00 by FUNCT_4:26;
  LifeSpan(P1,s1) = pseudo-LifeSpan(s,P,J0) by A21,Th58;
  then
A29: DataPart Comput(P00, s00,pseudo-LifeSpan(s,P
,J0)) = DataPart
Comput(P1, s1,LifeSpan(P1,s1)) by A21,A25,A10,Th58;
A30:  1 in dom if>0(a,I,J) by Th54;
  s3.a = s.a by Th28
    .= s0.a by SCMFSA6C:3;
  then
A31: IC s4 = succ IC s3 by A6,A20,SCMFSA_2:97
    .=  (0 + 1) by A11;
A32: P3. 1
    = (if>0(a,I,J)). 1
    by A30,FUNCT_4:14
    .= if>0(a,I,J). 1
    .= goto  2 by Th55;
A33:  P3/.IC s4 = P3.IC s4 by PBOOLE:158;
A34: Comput(P3, s3,1+1) = Following(P3,s4) by
EXTPRO_1:4
    .= Exec(goto  2,s4) by A31,A32,A33;
  then
A35: IC s5 =  2 by SCMFSA_2:95;
A36: DataPart s00 = DataPart s3 by COMPOS_1:138,SCMFSA8A:14;
A37: now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A36,SCMFSA6A:38
      .= s4.f by A20,SCMFSA_2:97
      .= s5.f by A34,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s00.a = s3.a by A36,SCMFSA6A:38
      .= s4.a by A20,SCMFSA_2:97
      .= s5.a by A34,SCMFSA_2:95;
  end;
  then
A38: DataPart s00 = DataPart s5 by A37,SCMFSA6A:38;
A39:  P3/.IC s9 = P3.IC s9 by PBOOLE:158;
A40: IC s9 = IC Comput(P3, s5,pseudo-LifeSpan(
s00,P00,J0)) by EXTPRO_1:5
    .= IC Comput(P00, s00,pseudo-LifeSpan(s00,P00
,J0)) + 2 by A28,A23,A17,A35,A38,Th51,A3,A18
    .= IC Comput(P00, s00,pseudo-LifeSpan(s,P,J0)
) + 2 by A21,Th50
    .=  card J0 + 2 by A21,SCMFSA8A:def 5,A1
    .=  (card J + 2) by SCMFSA8A:34;
  then
A41: CurInstr(P3,s9) = P3. (card J + 2) by A39
    .= if>0(a,I,J). (card J + 2) by A26,GRFUNC_1:8,A2
    .= goto  (card I + card J + 3) by Th64;
A42:  P3/.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2+ 1)
 = P3.IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2+ 1) by PBOOLE:158;
  IC Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) +
2 + 1) =
  IC Following(P3,s9)
  by EXTPRO_1:4
    .=  (card I + card J + 3) by A41,SCMFSA_2:95;
  then
A43: CurInstr(P3,
  Comput(P3, s3,pseudo-LifeSpan(s00,P00,J0) + 2 +
1)) = P3. (
  card I + card J + 3) by A42
    .= if>0(a,I,J). (card I + card J + 3) by A27,GRFUNC_1:8,A2
    .= halt SCM+FSA by Th62;
  then
A44: P3 halts_on s3 by EXTPRO_1:30;
A45:  P3/.IC s3 = P3.IC s3 by PBOOLE:158;
A46: CurInstr(P3,s3) = i by A11,A8,A45;
  now
A47: 0 + 2 < card I + card J + 3 by XREAL_1:10;
    then
A48:  2 in dom if>0(a,I,J) by Th57;
A49: if>0(a,I,J). 2 <> halt SCM+FSA by A47,Th57;
A50:  P3/.IC Comput(P3,s3,2) = P3.IC Comput(P3,s3,2) by PBOOLE:158;
A51: CurInstr(P3,Comput(P3,s3,2))
 = P3. 2 by A35,A50
      .= if>0(a,I,J). 2 by A48,GRFUNC_1:8,A2;
    let k be Element of NAT;
    assume
A52: CurInstr(P3,Comput(P3,s3,k)) = halt SCM+FSA;
A53: P3/.IC Comput(P3,s3,k) = P3.IC Comput(P3,s3,k) by PBOOLE:158;
A54: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    CurInstr(P3,Comput(P3,s3,0))
     = i by A46,A54;
    then
A55: k <> 0 by A52;
A56:    k <> 1 by A31,A32,A52,A53;
    2 <> k by A52,A49,A51;
    then 2 < k by A55,A56,NAT_1:27;
    then consider k2 being Nat such that
A57: 2 + k2 = k by NAT_1:10;
    reconsider k2 as Element of NAT by ORDINAL1:def 13;
    reconsider n = IC Comput(P00, s00,k2) as Element of NAT;
    assume not pseudo-LifeSpan(s00,P00,J0) + (1 + 2) <= k;
    then k < pseudo-LifeSpan(s00,P00,J0) + 1 + 2;
    then k2 < pseudo-LifeSpan(s00,P00,J0) + 1 by A57,XREAL_1:8;
    then
A58: k2 <= pseudo-LifeSpan(s00,P00,J0) by NAT_1:13;
    then
A59: k2 <= pseudo-LifeSpan(s,P,J0) by A21,Th50;
A60: now
      per cases by A59,XXREAL_0:1;
      suppose
A61:    k2 = pseudo-LifeSpan(s,P,J0);
        card I + card J + (2 + 1) = card J + 2 + 1 + card I;
        then
A62:    card J + 2 + 1 <= card I + card J + 3 by NAT_1:11;
        IC Comput(P00, s00,k2) =  card J0 by A21,A61,
SCMFSA8A:def 5,A1;
        then n = card J by SCMFSA8A:34;
        hence n + 2 < card I + card J + 3 by A62,NAT_1:13;
      end;
      suppose
        k2 < pseudo-LifeSpan(s,P,J0);
        then  n in dom J0 by A21,SCMFSA8A:31,A1;
        then n < card J0 by AFINSQ_1:70;
        then n + 2 < card J0 + 2 by XREAL_1:8;
        then
A63:    n + 2 < card J + 2 by SCMFSA8A:34;
        card I + card J + (1 + 2) = card J + 2 + (card I + 1);
        then card J + 2 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A63,XXREAL_0:2;
      end;
    end;
    then
A64:  (n + 2) in dom if>0(a,I,J) by Th57;
A65: IC Comput(P3, s3,k) = IC Comput(P3, s5,k2) by
A57,EXTPRO_1:5
      .=  (n + 2) by A28,A23,A17,A35,A38,A58,Th51,A3,A18;
A66:  P3/.IC Comput(P3,s3,k) = P3.IC Comput(P3,s3,k) by PBOOLE:158;
    CurInstr(P3,Comput(P3,s3,k))
     = P3.IC Comput(P3, s3,k) by A66
      .= if>0(a,I,J).IC Comput(P3, s3,k) by A65,A64,GRFUNC_1:8,A2;
    hence contradiction by A52,A65,A60,Th57;
  end;
  then
A67: LifeSpan(P3,s3) = pseudo-LifeSpan(s00,P00,J0)
+ 2 + 1 by A43,A44,EXTPRO_1:def 14;
A68:  P3/.IC s9 = P3.IC s9 by PBOOLE:158;
  CurInstr(P3,s9) = P3. (card J + 2) by A40,A68
    .= if>0(a,I,J). (card J + 2) by A26,A2,GRFUNC_1:8
    .= goto  (card I + card J + 3) by Th64;
  then InsCode CurInstr(P3,s9) = 6 by SCMFSA_2:47;
  then InsCode CurInstr(P3,s9) in {0,6,7,8} by ENUMSET1:def 2;
  then
A69: DataPart s9 = DataPart Following(P3,s9) by Th32;
A70: DataPart s9 = DataPart Comput(P3, s5,pseudo-LifeSpan(
s00,P00,J0)
) by EXTPRO_1:5
    .= DataPart Comput(P00, s00,pseudo-LifeSpan(
s00,P00,J0)) by A28,A23,A17,A35,A38,Th51,A3,A18;
  thus DataPart IExec(if>0(a,I,J),P,ss)
   = DataPart IExec(if>0(a,I,J),P,s) by Th17
    .= DataPart(Result(P +* if>0(a,I,J),s +*
Initialized if>0(a,I,J)) +* (s|NAT))
    .= DataPart(Result(P3,s3)) by A9,COMPOS_1:82
    .= DataPart Comput(P3, s3,LifeSpan(P3,s3)) by
A44,EXTPRO_1:23
    .= DataPart Following(P3,s9) by A67,EXTPRO_1:4
    .= DataPart Comput(P00, s00,pseudo-LifeSpan(
s,P,J0)) by A21,A70,A69,Th50
    .= DataPart Result(P1,s1) by A22,A29,EXTPRO_1:23
    .= DataPart(Result(P +* (J ';' Stop SCM+FSA),s +*
Initialized (J ';' Stop SCM+FSA)) +* (s|NAT)) by A24,COMPOS_1:82
    .= DataPart IExec(J ';' Stop SCM+FSA,P,s)
    .= DataPart IExec(J ';' Stop SCM+FSA,P,ss) by Th17;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
  read-write Int-Location st Directed I is_pseudo-closed_on s,P & Directed J
  is_pseudo-closed_on s,P holds if=0(a,I,J) is_closed_on s,P & if=0(a,I,J)
  is_halting_on s,P
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: Directed I is_pseudo-closed_on s,P;
  assume
A2: Directed J is_pseudo-closed_on s,P;
  hereby
    per cases;
    suppose
A3:   s.a = 0;
      hence if=0(a,I,J) is_closed_on s,P by A1,Th66;
      thus if=0(a,I,J) is_halting_on s,P by A1,A3,Th66;
    end;
    suppose
A4:   s.a <> 0;
      hence if=0(a,I,J) is_closed_on s,P by A2,Th70;
      thus if=0(a,I,J) is_halting_on s,P by A2,A4,Th70;
    end;
  end;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
  read-write Int-Location st Directed I is_pseudo-closed_on s,P & Directed J
  is_pseudo-closed_on s,P holds if>0(a,I,J) is_closed_on s,P & if>0(a,I,J)
  is_halting_on s,P
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: Directed I is_pseudo-closed_on s,P;
  assume
A2: Directed J is_pseudo-closed_on s,P;
  hereby
    per cases;
    suppose
A3:   s.a > 0;
      hence if>0(a,I,J) is_closed_on s,P by A1,Th68;
      thus if>0(a,I,J) is_halting_on s,P by A1,A3,Th68;
    end;
    suppose
A4:   s.a <= 0;
      hence if>0(a,I,J) is_closed_on s,P by A2,Th72;
      thus if>0(a,I,J) is_halting_on s,P by A2,A4,Th72;
    end;
  end;
end;

theorem
  for I being Program of SCM+FSA, a being Int-Location holds I
  does not destroy a implies Directed I does not destroy a by SCMFSA8A:27;

theorem Th77:
  for i being Instruction of SCM+FSA, a being Int-Location holds i
  does not destroy a implies Macro i does not destroy a
proof
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
A1: rng Macro i = {i,halt SCM+FSA} by FUNCT_4:67;
  assume
A2: i does not destroy a;
  now
    let ii be Instruction of SCM+FSA;
    assume ii in rng Macro i;
    then ii = i or ii = halt SCM+FSA by A1,TARSKI:def 2;
    hence ii does not destroy a by A2,SCMFSA7B:11;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th78:
  for a being Int-Location holds halt SCM+FSA does not refer a
proof
  let a be Int-Location;
  for b be Int-Location for l be Element of NAT for f be
  FinSeq-Location holds b := a <> halt SCM+FSA & AddTo(b,a) <> halt SCM+FSA &
  SubFrom(b,a) <> halt SCM+FSA & MultBy(b,a) <> halt SCM+FSA & Divide(a,b) <>
  halt SCM+FSA & Divide(b,a) <> halt SCM+FSA & a =0_goto l <> halt SCM+FSA & a
  >0_goto l <> halt SCM+FSA & b :=(f,a) <> halt SCM+FSA & (f,b):= a <> halt
  SCM+FSA & (f,a):= b <> halt SCM+FSA & f :=<0,...,0> a <> halt SCM+FSA;
  hence thesis by SCMFSA7B:def 1;
end;

theorem
  for a,b,c being Int-Location holds a <> b implies AddTo(c,b)
  does not refer a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Element of NAT;
    let f be FinSeq-Location;
A2: InsCode AddTo(c,b) = 2 by SCMFSA_2:43;
    hence e := a <> AddTo(c,b) by SCMFSA_2:42;
    thus AddTo(e,a) <> AddTo(c,b) by A1,SF_MASTR:6;
    thus SubFrom(e,a) <> AddTo(c,b) by A2,SCMFSA_2:44;
    thus MultBy(e,a) <> AddTo(c,b) by A2,SCMFSA_2:45;
    thus Divide(a,e) <> AddTo(c,b) & Divide(e,a) <> AddTo(c,b) by A2,
SCMFSA_2:46;
    thus a =0_goto l <> AddTo(c,b);
    thus a >0_goto l <> AddTo(c,b);
    thus e :=(f,a) <> AddTo(c,b) by A2,SCMFSA_2:50;
    thus (f,e):= a <> AddTo(c,b) & (f,a):= e <> AddTo(c,b) by A2,SCMFSA_2:51;
    thus f :=<0,...,0> a <> AddTo(c,b) by A2,SCMFSA_2:53;
  end;
  hence thesis by SCMFSA7B:def 1;
end;

theorem
  for i being Instruction of SCM+FSA, a being Int-Location holds i
  does not refer a implies Macro i does not refer a
proof
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
A1: rng Macro i = {i,halt SCM+FSA} by FUNCT_4:67;
  assume
A2: i does not refer a;
  now
    let ii be Instruction of SCM+FSA;
    assume ii in rng Macro i;
    then ii = i or ii = halt SCM+FSA by A1,TARSKI:def 2;
    hence ii does not refer a by A2,Th78;
  end;
  hence thesis by SCMFSA7B:def 2;
end;

theorem Th81:
  for I,J being Program of SCM+FSA, a being Int-Location holds I
  does not destroy a & J does not destroy a implies I ';' J does not destroy a
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  assume that
A1: I does not destroy a and
A2: J does not destroy a;
A3: Reloc(J,card I) does not destroy a by A2,SCMFSA8A:23;
  Directed I does not destroy a by A1,SCMFSA8A:27;
  hence thesis by A3,SCMFSA8A:25;
end;

theorem Th82:
  for J being Program of SCM+FSA, i being Instruction of SCM+FSA,
a being Int-Location st i does not destroy a & J does not destroy a holds i ';'
  J does not destroy a
proof
  let J be Program of SCM+FSA;
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  assume that
A1: i does not destroy a and
A2: J does not destroy a;
  Macro i does not destroy a by A1,Th77;
  hence thesis by A2,Th81;
end;

theorem
  for I being Program of SCM+FSA, j being Instruction of SCM+FSA, a
being Int-Location st I does not destroy a & j does not destroy a holds I ';' j
  does not destroy a
proof
  let I be Program of SCM+FSA;
  let j be Instruction of SCM+FSA;
  let a be Int-Location;
  assume that
A1: I does not destroy a and
A2: j does not destroy a;
  Macro j does not destroy a by A2,Th77;
  hence thesis by A1,Th81;
end;

theorem
  for i,j being Instruction of SCM+FSA, a being Int-Location st i
  does not destroy a & j does not destroy a holds i ';' j does not destroy a
proof
  let i,j be Instruction of SCM+FSA;
  let a be Int-Location;
  assume that
A1: i does not destroy a and
A2: j does not destroy a;
A3: Macro j does not destroy a by A2,Th77;
  Macro i does not destroy a by A1,Th77;
  hence thesis by A3,Th81;
end;

theorem Th85:
  for a being Int-Location holds Stop SCM+FSA does not destroy a
proof
  let a be Int-Location;
  now
    let i be Instruction of SCM+FSA;
A1: rng Stop SCM+FSA = {halt SCM+FSA} by AFINSQ_1:36;
    assume i in rng Stop SCM+FSA;
    then i = halt SCM+FSA by A1,TARSKI:def 1;
    hence i does not destroy a by SCMFSA7B:11;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th86:
  for a being Int-Location, l being Element of NAT
   holds Goto l does not destroy a
proof
  let a be Int-Location;
  let l be Element of NAT;
  now
    let i be Instruction of SCM+FSA;
A1: rng Goto l = {goto l} by FUNCOP_1:14;
    assume i in rng Goto l;
    then i = goto l by A1,TARSKI:def 1;
    hence i does not destroy a by SCMFSA7B:17;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th87:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_halting_on Initialized s,P holds
   (for a being read-write Int-Location holds
IExec(I,P,s).a = Comput(P +* I,Initialized s +* (Initialize I),
 (LifeSpan(P +* I,Initialized
s +* (Initialize I)))).a) &
  for f being FinSeq-Location
  holds IExec(I,P,s).f = Comput(P +* I,Initialized s +* (Initialize I),
  LifeSpan(P +* I,Initialized s +* (Initialize I))).f
proof
  let s be State of SCM+FSA;
  set A = NAT;
  let I be Program of SCM+FSA;
  set s0 = Initialized s;
  set s1 = s0 +* (Initialize I),
      P1 = P +* I;
A1: ProgramPart I = I by RELAT_1:209;
  assume I is_halting_on s0,P;
  then
A2: P1 halts_on s1 by SCMFSA7B:def 8,A1;
  hereby
    let a be read-write Int-Location;
    not a in A by SCMFSA_2:84;
    then not a in dom s /\ A by XBOOLE_0:def 4;
    then
A3: not a in dom (s | A) by RELAT_1:90;
    s +* Initialized I = s1 by SCMFSA8A:13;
    hence IExec(I,P,s).a = (Result(P1,s1) +* (s|NAT)).a
      .= (Result(P1,s1)).a by A3,FUNCT_4:12
      .= Comput(P1, s1,LifeSpan(P1,s1)).a by A2,
EXTPRO_1:23;
  end;
  let f be FinSeq-Location;
  not f in A by SCMFSA_2:85;
  then not f in dom s /\ A by XBOOLE_0:def 4;
  then
A4: not f in dom (s | A) by RELAT_1:90;
  s +* Initialized I = s1 by SCMFSA8A:13;
  hence IExec(I,P,s).f = (Result(P1,s1) +* (s|NAT)).f
    .= (Result(P1,s1)).f by A4,FUNCT_4:12
    .= Comput(P1, s1,LifeSpan(P1,s1)).f by A2,
EXTPRO_1:23;
end;

theorem Th88:
  for s being State of SCM+FSA, I being parahalting Program of
  SCM+FSA, a being read-write Int-Location holds IExec(I,P,s).a = Comput(
P +* I,
  Initialized s +* (Initialize I),
  (LifeSpan(P +* I,Initialized s +* (Initialize I)))).a
proof
  let s be State of SCM+FSA;
  let I be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  I is_halting_on Initialized s,P by SCMFSA7B:25;
  hence thesis by Th87;
end;

theorem Th89:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
  being Int-Location,k being Element of NAT
   st I is_closed_on Initialized s,P & I
  is_halting_on Initialized s,P & I does not destroy a holds IExec(I,P,s).a =
  Comput(P +* I, (Initialized s +* (Initialize I)),k).a
proof
  let s be State of SCM+FSA;
  set A = NAT;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  let k be Element of NAT;
  assume
A1: I is_closed_on Initialized s,P;
  not a in A by SCMFSA_2:84;
  then not a in dom s /\ A by XBOOLE_0:def 4;
  then
A2: not a in dom (s | A) by RELAT_1:90;
  set s0 = Initialized s;
  set s1 = s0 +* (Initialize I),
      P1 = P +* I;
A3: ProgramPart I = I by RELAT_1:209;
  assume I is_halting_on Initialized s,P;
  then
A4: P1 halts_on s1 by SCMFSA7B:def 8,A3;
  assume
A5: I does not destroy a;
  s +* Initialized I = s0 +* (Initialize I) by SCMFSA8A:13;
  hence IExec(I,P,s).a = (Result(P1,s1) +* (s|NAT)).a
    .= (Result(P1,s1)).a by A2,FUNCT_4:12
    .= Comput(P1, s1,LifeSpan(P1,s1)).a by A4,
EXTPRO_1:23
    .= s0.a by A1,A5,SCMFSA7B:27
    .= Comput(P +* I, (s0 +* (Initialize I)),k).a
    by A1,A5,SCMFSA7B:27;
end;

theorem Th90:
  for s being State of SCM+FSA, I being parahalting Program of
  SCM+FSA, a being Int-Location,k being Element of NAT st I does not destroy a
holds IExec(I,P,s).a = Comput(P +* I, (Initialized s +* (Initialize I)),k).a
proof
  let s be State of SCM+FSA;
  let I be parahalting Program of SCM+FSA;
  let a be Int-Location;
  let k be Element of NAT;
  set s0 = Initialized s;
  set s1 = s0 +* (Initialize I),
      P1 = P +* I;
A1: I c= P1 by FUNCT_4:26;
A2: Initialize I c= s1 by FUNCT_4:26;
A3: I is_closed_on s0,P by SCMFSA7B:24;
A4: ProgramPart I = I by RELAT_1:209;
  P1 halts_on s1 by SCMFSA6B:18,A1,A2;
  then
A5: I is_halting_on s0,P by SCMFSA7B:def 8,A4;
  assume I does not destroy a;
  hence thesis by A3,A5,Th89;
end;

theorem Th91:
  for s being State of SCM+FSA, I being parahalting Program of
  SCM+FSA, a being Int-Location st I does not destroy a
   holds IExec(I,P,s).a = (
  Initialized s).a
proof
  let s be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let I be parahalting Program of SCM+FSA;
  let a be Int-Location;
A1: DataPart Initialized s = DataPart(Initialized s +* (Initialize I
  )) by SCMFSA8A:11;
  assume I does not destroy a;
  hence
  IExec(I,P,s).a = Comput(P +* I, (Initialized s +* (Initialize I)),
  0).a by Th90
    .= (Initialized s +* (Initialize I)).a by EXTPRO_1:3
    .= (Initialized s).a by A1,SCMFSA6A:38;
end;

theorem Th92:
  for s being State of SCM+FSA, I being keeping_0 Program of
  SCM+FSA st I is_halting_on Initialized s,P
   holds IExec(I,P,s).intloc 0 = 1 & for k
being Element of NAT holds Comput(P +* I,
(Initialized s +* (Initialize I)),k).intloc 0 = 1
proof
  set a = intloc 0;
  let s be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  set A = NAT;
  let I be keeping_0 Program of SCM+FSA;
  set s0 = Initialized s;
  set s1 = s0 +* (Initialize I),
      P1 = P +* I;
A1: I c= P1 by FUNCT_4:26;
A2: ProgramPart I = I by RELAT_1:209;
A3: Initialize I c= s1 by FUNCT_4:26;
A4: DataPart s0 = DataPart s1 by SCMFSA8A:11;
A5: now
    let k be Element of NAT;
    thus Comput(P1, s1,k).a = s1.a by A3,SCMFSA6B:def 4,A1
      .= s0.a by A4,SCMFSA6A:38
      .= 1 by SCMFSA6C:3;
  end;
  not a in A by SCMFSA_2:84;
  then not a in dom s /\ A by XBOOLE_0:def 4;
  then
A6: not a in dom (s | A) by RELAT_1:90;
  assume I is_halting_on s0,P;
  then
A7: P1 halts_on s1 by SCMFSA7B:def 8,A2;
  s +* Initialized I = s1 by SCMFSA8A:13;
  hence IExec(I,P,s).a = (Result(P1,s1) +* (s|NAT)).a
    .= (Result(P1,s1)).a by A6,FUNCT_4:12
    .= Comput(P1, s1,LifeSpan(P1,s1)).a by A7,
EXTPRO_1:23
    .= 1 by A5;
  let k be Element of NAT;
  thus thesis by A5;
end;

theorem Th93:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does not destroy a holds for k being Element of NAT st
IC Comput(P +* I, (s +* (Initialize I)),k) in dom I
holds Comput(P +* I,
  (s +* (Initialize I)),k + 1).a =
   Comput(P +* I, (s +* (Initialize I)),k).a
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does not destroy a;
  set s1 = s +* (Initialize I),
      P1 = P +* I;
A2: I c= P1 by FUNCT_4:26;
  let k be Element of NAT;
  assume
A3: IC Comput(P +* I, (s +* (Initialize I)),k) in dom I;
  set l = IC Comput(P1, s1,k);
  P1.l = I.l by A3,GRFUNC_1:8,A2;
  then P1.l in rng I by A3,FUNCT_1:def 5;
  then
A4: P1.l does not destroy a by A1,SCMFSA7B:def 4;
A5: P1/.IC Comput(P1,s1,k) = P1.IC Comput(P1, s1,k) by PBOOLE:158;
  thus Comput(P1, s1,k + 1).a =
  (Following(P1,Comput(P1,s1
,k))).a by EXTPRO_1:4
    .= Exec(P1.l, Comput(P1, s1,k)).a by A5
    .= Comput(P1, s1,k).a by A4,SCMFSA7B:26;
end;

theorem Th94:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does not destroy a holds for m being Element of NAT st
(for n being Element of NAT st n < m
 holds IC Comput(P +* I, (s +* (Initialize I)),n) in dom I)
 for n being Element of NAT st n <= m holds
  Comput(P +* I, (s +* (Initialize I)),n).a = s.a
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does not destroy a;
  set s1 = s +* (Initialize I),
      P1 = P +* I;
  let m be Element of NAT;
  defpred P[Nat] means $1 <= m implies Comput(P1, s1,$1).a = s.a;
  assume
A2: for n being Element of NAT st n < m
   holds IC Comput(P +* I, (s +* (Initialize I)),n) in dom I;
A3: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A4: P[k];
A5: k + 0 < k + 1 by XREAL_1:8;
    assume
A6: k + 1 <= m;
    then k < m by A5,XXREAL_0:2;
    then IC Comput(P1, s1,k) in dom I by A2;
    hence thesis by A1,A4,A6,A5,Th93,XXREAL_0:2;
  end;
  let n be Element of NAT;
  assume
A7: n <= m;
  Comput(P1, s1,0).a = s1.a by EXTPRO_1:3
    .= s.a by Th28;
  then
A8: P[0];
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A8,A3);
  hence thesis by A7;
end;

theorem Th95:
  for s being State of SCM+FSA, I being good Program of SCM+FSA
  for m being Element of NAT st (for n being Element of NAT st n < m holds IC
  Comput(P +* I, (s +* (Initialize I)),n) in dom I) holds
  for n being
Element of NAT st n <= m holds Comput(P +* I, (s +* (Initialize I)),n).
  intloc 0 = s.intloc 0
proof
  let s be State of SCM+FSA;
  let I be good Program of SCM+FSA;
  let m be Element of NAT;
  assume
A1: for n being Element of NAT st n < m
 holds IC Comput(P +* I, (s +* (Initialize I)),n) in dom I;
  let n be Element of NAT;
A2: I does not destroy intloc 0 by SCMFSA7B:def 5;
  assume n <= m;
  hence thesis by A1,A2,Th94;
end;

theorem Th96:
  for s being State of SCM+FSA, I being good Program of SCM+FSA st
  I is_halting_on Initialized s,P & I is_closed_on Initialized s,P
   holds IExec(I,P,s).
intloc 0 = 1 & for k being Element of NAT
holds Comput(P +* I, (Initialized s +* (
  Initialize I)),k).intloc 0 = 1
proof
  set a = intloc 0;
  let s be State of SCM+FSA;
  set A = NAT;
  let I be good Program of SCM+FSA;
  set s0 = Initialized s;
  set s1 = s0 +* (Initialize I),
      P1 = P +* I;
A1: ProgramPart I = I by RELAT_1:209;
  defpred P[Nat] means for n being Element of NAT st n <= $1 holds
  Comput(P1, s1,n).intloc 0 = s0.intloc 0;
  assume I is_halting_on s0,P;
  then
A2: P1 halts_on s1 by SCMFSA7B:def 8,A1;
A3: P[0]
  proof
    let n be Element of NAT;
A4: for i being Element of NAT st i < 0 holds IC Comput(P1, s1,i)
in dom
    I;
    assume n <= 0;
    hence thesis by A4,Th95;
  end;
  assume
A5: I is_closed_on s0,P;
A6: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume P[k];
    let n be Element of NAT;
    assume
A7: n <= k + 1;
    for i being Element of NAT st i < k + 1 holds IC Comput(P1,
s1,i) in
    dom I by A5,SCMFSA7B:def 7,A1;
    hence thesis by A7,Th95;
  end;
A8: for k being Element of NAT holds P[k] from NAT_1:sch 1(A3,A6);
A9: now
    let k be Element of NAT;
    thus Comput(P1, s1,k).intloc 0 = s0.intloc 0 by A8
      .= 1 by SCMFSA6C:3;
  end;
  not a in A by SCMFSA_2:84;
  then not a in dom s /\ A by XBOOLE_0:def 4;
  then
A10: not a in dom (s | A) by RELAT_1:90;
  s +* Initialized I = s1 by SCMFSA8A:13;
  hence IExec(I,P,s).a = (Result(P1,s1) +* (s|NAT)).a
    .= (Result(P1,s1)).a by A10,FUNCT_4:12
    .= Comput(P1, s1,LifeSpan(P1,s1)).a by A2,
EXTPRO_1:23
    .= 1 by A9;
  thus thesis by A9;
end;

theorem
  for s being State of SCM+FSA, I being good Program of SCM+FSA st I
is_closed_on s,P holds for k being Element of NAT
 holds Comput(P +* I, (s +* (Initialize I)),k).intloc 0 = s.intloc 0
proof
  let s be State of SCM+FSA;
  let I be good Program of SCM+FSA;
  assume
A1: I is_closed_on s,P;
  let k be Element of NAT;
  I does not destroy intloc 0 by SCMFSA7B:def 5;
  hence thesis by A1,SCMFSA7B:27;
end;

theorem Th98:
  for P
  for s being State of SCM+FSA, I being keeping_0 parahalting
  Program of SCM+FSA, a being read-write Int-Location st I does not destroy a
  holds Comput(P +* (I ';' SubFrom(a,intloc 0)),
   (Initialized s +* (Initialize(I ';' SubFrom(a,intloc 0)))),
   LifeSpan(P +* (I ';' SubFrom(a,intloc 0)),
  Initialized s +* (Initialize(I ';' SubFrom(a,intloc 0))))).a = s.a - 1
proof let P;
  let s be State of SCM+FSA;
  let I be keeping_0 parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
  set s0 = Initialized s;
  set s1 = s0 +* Initialize(I ';' SubFrom(a,intloc 0)),
      P1 = P +* (I ';' SubFrom(a,intloc 0));
A2: not a in dom (Initialize I) by SCMFSA6B:12;
  IExec(I ';' SubFrom(a,intloc 0),P,s).a
   = Exec(SubFrom(a,intloc 0),IExec(I,P,s)).a by SCMFSA6C:7
    .= IExec(I,P,s).a - IExec(I,P,s).intloc 0 by SCMFSA_2:91
    .= IExec(I,P,s).a - 1 by SCMFSA6B:35
    .= Comput(P +* I, (s0 +* (Initialize I)),0).a - 1
    by A1,Th90
    .= (s0 +* (Initialize I)).a - 1 by EXTPRO_1:3
    .= s0.a - 1 by A2,FUNCT_4:12;
  hence Comput(P1, s1,LifeSpan(P1,s1)).a = s0.a - 1
by Th88
    .= s.a - 1 by SCMFSA6C:3;
end;

theorem Th99:
  for i being Instruction of SCM+FSA st i does not destroy intloc
  0 holds Macro i is good
proof
  let i be Instruction of SCM+FSA;
  assume i does not destroy intloc 0;
  then Macro i does not destroy intloc 0 by Th77;
  hence thesis by SCMFSA7B:def 5;
end;

theorem Th100:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
I is_closed_on s1,P1 & I is_halting_on s1,P1 & DataPart s1 = DataPart s2
  for k being Element of NAT holds
   Comput(P1 +* I,s1 +* (Initialize I),k),
   Comput(P2 +* I,s2 +* (Initialize I),k) equal_outside NAT
   & CurInstr(P1 +* I,Comput(P1 +* I,s1 +* (Initialize I),k))
    = CurInstr(P2 +* I,Comput(P2 +* I,s2 +* (Initialize I),k))
proof
  let s1,s2 be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: I is_closed_on s1,P1;
  set ss2 = s2 +* (Initialize I),
      PP2 = P2 +* I;
  set ss1 = s1 +* (Initialize I),
      PP1 = P1 +* I;
A2: I c= P1 +* I by FUNCT_4:26;
A3: I c= P2 +* I by FUNCT_4:26;
A4: ProgramPart I = I by RELAT_1:209;
  assume
A5: I is_halting_on s1,P1;
  assume
A6: DataPart s1 = DataPart s2;
:::  hereby
    let k be Element of NAT;
A7: IC Comput(PP1, ss1,k) in dom I by A1,SCMFSA7B:def 7,A4;
    I is_closed_on s2,P2 by A1,A5,A6,SCMFSA8B:8;
    then
A8: for m being Element of NAT st m < k holds IC Comput(PP2, ss2,
m) in
    dom I by SCMFSA7B:def 7,A4;
    ss1,ss2 equal_outside NAT by A6,SCMFSA8B:7;
    hence
    Comput(PP1, ss1,k), Comput(PP2, ss2,k)
equal_outside NAT by A8,AMISTD_2:66,A2,A3;
    then
A9: IC Comput(PP1, ss1,k) = IC Comput(PP2, ss2,k)
by COMPOS_1:24;
    I is_closed_on s2,P2 by A1,A5,A6,SCMFSA8B:8;
    then
A10: IC Comput(PP2, ss2,k) in dom I by SCMFSA7B:def 7,A4;
A11:  (PP2)/.IC Comput(PP2,ss2,k)
 = PP2.IC Comput(PP2,ss2,k) by PBOOLE:158;
A12:  PP1/.IC Comput(PP1,ss1,k)
 = PP1.IC Comput(PP1,ss1,k) by PBOOLE:158;
    thus CurInstr(PP2,Comput(PP2,ss2,k))
     = PP2.IC Comput(PP2, ss2,k) by A11
      .= I.IC Comput(PP2, ss2,k) by A10,GRFUNC_1:8,A3
      .= PP1.IC Comput(PP1, ss1,k) by A9,A7,GRFUNC_1:8,A2
      .= CurInstr(PP1,Comput(PP1,ss1,k)) by A12;
:::  end;
end;

theorem Th101:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
  I is_closed_on s1,P1 & I is_halting_on s1,P1 & DataPart s1 = DataPart s2
   holds
  LifeSpan(P1 +* I,s1 +* (Initialize I)) =
  LifeSpan(P2 +* I,s2 +* (Initialize I)) &
  Result(P1 +* I,s1 +* (Initialize I)),
  Result(P2 +* I,s2 +* (Initialize I)) equal_outside NAT
proof
  let s1,s2 be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: I is_closed_on s1,P1;
  set ss2 = s2 +* (Initialize I),
      PP2 = P2 +* I;
  set ss1 = s1 +* (Initialize I),
      PP1 = P1 +* I;
A2: ProgramPart I = I by RELAT_1:209;
  assume
A3: I is_halting_on s1,P1;
  then
A4: PP1 halts_on ss1 by SCMFSA7B:def 8,A2;
  then
A5: Result(PP1,ss1) = Comput(PP1, ss1,LifeSpan(
PP1,ss1)) by EXTPRO_1:23;
  assume
A6: DataPart s1 = DataPart s2;
  then I is_halting_on s2,P2 by A1,A3,SCMFSA8B:8;
  then
A7: PP2 halts_on ss2 by SCMFSA7B:def 8,A2;
A8: now
    let l be Element of NAT;
    assume
A9: CurInstr(PP2,Comput(PP2,ss2,l)) = halt SCM+FSA;
    CurInstr(PP1,Comput(PP1,ss1,l))
     = CurInstr(PP2,Comput(PP2,ss2,l))
     by A1,A3,A6,Th100;
    hence LifeSpan(PP1,ss1) <= l by A4,A9,EXTPRO_1:def 14;
  end;
  CurInstr(PP2,
  Comput(PP2,ss2,LifeSpan(PP1,ss1)))
   = CurInstr(PP1,
   Comput(PP1,ss1,LifeSpan(PP1,ss1)))
    by A1,A3,A6,Th100
    .= halt SCM+FSA by A4,EXTPRO_1:def 14;
  hence LifeSpan(PP1,ss1) = LifeSpan(PP2,ss2) by A8
,A7,EXTPRO_1:def 14;
  then Result(PP2,ss2) = Comput(PP2, ss2,LifeSpan(PP1,ss1)) by A7,EXTPRO_1:23
;
  hence thesis by A1,A3,A6,A5,Th100;
end;

canceled;

theorem Th103:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
  I is_closed_on s1,P1 & I is_halting_on s1,P1 &
  Initialize I c= s1 & Initialize I c= s2 &
  I c= P1 & I c= P2 &
   ex k being Element of NAT st Comput(P1, s1,k),s2 equal_outside NAT
  holds Result(P1,s1),Result(P2,s2)
equal_outside NAT
proof
  let s1,s2 be State of SCM+FSA;
  set A = NAT;
  set D = Data-Locations SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: I is_closed_on s1,P1;
A2: ProgramPart I = I by RELAT_1:209;
  assume
A3: I is_halting_on s1,P1;
  assume
A4: Initialize I c= s1;
  assume Initialize I c= s2;
  then
A5: s2 = s2 +* (Initialize I) by FUNCT_4:79;
  assume
 I c= P1;
   then
A6: P1 = P1 +* I by FUNCT_4:79;
  assume
 I c= P2;
   then
A7: P2 = P2 +* I by FUNCT_4:79;
A8: s1 = s1 +* (Initialize I) by FUNCT_4:79,A4;
  then
A9: P1 halts_on s1 by A3,SCMFSA7B:def 8,A2,A6;
  then consider n being Element of NAT such that
A10: CurInstr(P1,Comput(P1,s1,n)) = halt SCM+FSA
 by EXTPRO_1:30;
  given k being Element of NAT such that
A11: Comput(P1, s1,k),s2 equal_outside A;
  set s3 = Comput(P1, s1,k),
      P3 = P1;
A12: IC SCM+FSA in dom s3 by COMPOS_1:9;
  I c= Initialize I by SCMFSA8A:9;
  then I c= s1 by A4,XBOOLE_1:1;
  then
A13: I c= s3 by AMI_1:86;
  IC s3 = IC s2 by A11,SCMFSA8A:6
    .= IC Initialize (s2 +* I) by A5,FUNCT_4:15
    .= 0 by FUNCT_4:121;
  then IC SCM+FSA .-->  0 c= s3 by A12,FUNCOP_1:88;
  then Initialize I c= s3 by A13,FUNCT_4:92;
  then
A14: s3 = s3 +* (Initialize I) by FUNCT_4:79;
A15: now
    let n be Element of NAT;
    IC Comput(P1, s3,n) = IC Comput(P1, s1,k + n)
by EXTPRO_1:5;
    hence IC Comput(P3, s3,n) in dom I by A1,A8,SCMFSA7B:def 7,A2,A6;
  end;
A16: Comput(P1,s1,n+k)
 = Comput(P1,Comput(P1,s1,k),n) by EXTPRO_1:5;
  n <= n + k by NAT_1:11;
 then
A17:  Comput(P1,s1,n+k) = Comput(P1,s1,n) by A10,
EXTPRO_1:6;
  CurInstr(P3,Comput(P3,s3,n))
    = CurInstr(P1,Comput(P1,s1,n))
     by A17,A16;
  then P3 halts_on s3 by A10,EXTPRO_1:30;
  then
A18: I is_halting_on s3,P3 by A14,SCMFSA7B:def 8,A2,A6;
A19: DataPart s3 = DataPart s2 by A11,SCMFSA8A:6;
  consider k being Element of NAT such that
A20: CurInstr(P1,Comput(P1,s1,k))
 = halt SCM+FSA by A9,EXTPRO_1:30;
A21:  P1/.IC Comput(P1,s1,k) = P1.IC Comput(P1,s1,k) by PBOOLE:158;
A22: P1.IC Comput(P1, s1,k)
      = P1.IC Comput(P1, s1,k)
     .= halt SCM+FSA by A20,A21;
  I is_closed_on s3,P3 by A14,A15,SCMFSA7B:def 7,A2,A6;
  then Result(P3,s3),Result(P2,s2) equal_outside A
by A5,A19,A14,A18,Th101,A6,A7;
  hence thesis by A22,EXTPRO_1:9;
end;

begin :: loop

registration
  let I be Program of SCM+FSA, k be Element of NAT;
  cluster IncAddr(I,k) -> initial NAT-defined;
  correctness
  proof
    thus thesis;
  end;
end;

definition
  let I be Program of SCM+FSA;
  canceled 3;
  func loop I -> halt-free Program of SCM+FSA equals
  Directed(I, 0);
  coherence
   proof
     dom Directed(I, 0) = dom I by FUNCT_4:105;
     then Directed(I, 0) <> {};
    hence thesis;
   end;
end;

canceled;

theorem
  for I being Program of SCM+FSA, a being Int-Location holds
   loop I destroys a implies I destroys a by SCMFSA8A:27;

registration
  let I be good Program of SCM+FSA;
  cluster loop I -> good;
  correctness;
end;

canceled;

theorem Th107:
  for I being Program of SCM+FSA holds not halt SCM+FSA in rng
  loop I
proof
  let I be Program of SCM+FSA;
  thus thesis by FUNCT_4:106;
end;

canceled;

theorem Th109:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
is_closed_on s,P & I is_halting_on s,P
 for m being Element of NAT st m <= LifeSpan(
P +* I,s +* (Initialize I))
holds Comput(P +* I, (s +* (Initialize I)),m),
Comput(P +* loop I,(s +* (Initialize loop I)),m)
  equal_outside NAT
proof
  let s be State of SCM+FSA;
  set A = NAT;
  let I be Program of SCM+FSA;
A1: ProgramPart I = I by RELAT_1:209;
  set s1 = s +* (Initialize I),
      P1 = P +* I;
A2: I c= P1 by FUNCT_4:26;
  set s2 = s +* (Initialize loop I),
      P2 = P +* loop I;
A3: loop I c= P2 by FUNCT_4:26;
  assume
A4: I is_closed_on s,P;
  defpred X[Nat] means $1 <= LifeSpan(P1,s1) implies Comput(
P1, s1,$1
  ), Comput(P2, s2,$1) equal_outside A;
  assume I is_halting_on s,P;
  then
A5: P1 halts_on s1 by SCMFSA7B:def 8,A1;
A6: for m being Element of NAT st X[m] holds X[m+1]
  proof
    let m be Element of NAT;
    assume
A7: m <= LifeSpan(P1,s1) implies Comput(P1,s1,m),
Comput(P2,s2,m)
    equal_outside A;
A8: Comput(P1,s1,m+1) =
Following(P1,Comput(P1,s1,m)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(P1,Comput(P1,s1,m)),
      Comput(P1,s1,m));
A9: Comput(P2,s2,m+1) =
Following(P2,Comput(P2,s2,m)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(P2,Comput(P2,s2,m)),
      Comput(P2,s2,m));
A10: IC Comput(P1,s1,m) in dom I by A4,SCMFSA7B:def 7,A1;
A11: P1/.IC Comput(P1,s1,m) = P1.IC Comput(P1,s1,m) by PBOOLE:158;
A12: CurInstr(P1,Comput(P1,s1,m))
 = I.IC Comput(P1,s1,m) by A10,A11,GRFUNC_1:8,A2;
    assume
A13: m + 1 <= LifeSpan(P1,s1);
    then
     m < LifeSpan(P1,s1) by NAT_1:13;
    then I.IC Comput(P1,s1,m) <> halt SCM+FSA by A5,A12,
EXTPRO_1:def 14;
    then
A14: I.IC Comput(P1,s1,m) = (loop I).IC Comput(P1,s1,
m) by FUNCT_4:111;
A15:  P2/.IC Comput(P2,s2,m)
 = P2.IC Comput(P2,s2,m) by PBOOLE:158;
A16:   IC Comput(P1,s1,m) in dom loop I by A10,FUNCT_4:105;
    CurInstr(P1,Comput(P1,s1,m))
     = P1.IC Comput(P1,s1,m) by PBOOLE:158
    .= I.IC Comput(P1,s1,m) by GRFUNC_1:8,A2,A10
    .= (loop I).IC Comput(P1,s1,m) by A14
    .= P2.IC Comput(P1,s1,m) by GRFUNC_1:8,A3,A16
      .= CurInstr(P2,Comput(P2,s2,m))
       by A7,A13,A15,COMPOS_1:24,NAT_1:13;
    hence thesis by A7,A13,A8,A9,NAT_1:13,AMISTD_2:def 20;
  end;
A17: X[0]
  proof
    assume 0 <= LifeSpan(P1,s1);
A18: s,s +* loop I equal_outside A by FUNCT_7:132;
    s +* I,s equal_outside A by FUNCT_7:28,132;
    then s +* I,s +* loop I equal_outside A by A18,FUNCT_7:29;
    then Initialize(s +* I),Initialize(s +* loop I)
    equal_outside A by FUNCT_7:106;
    then Initialize(s +* I),s2 equal_outside A by FUNCT_4:15;
    then s1,s2 equal_outside A by FUNCT_4:15;
    then s1, Comput(P2, s2,0) equal_outside A by EXTPRO_1:3;
    hence thesis by EXTPRO_1:3;
  end;
  thus for m being Element of NAT holds X[m] from NAT_1:sch 1(A17, A6);
end;

theorem Th110:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
is_closed_on s,P & I is_halting_on s,P
 for m being Element of NAT st m < LifeSpan(
P +* I,
s +* (Initialize I))
holds CurInstr(P +* I,
   Comput(P +* I, (s +* (Initialize I)),m))
 = CurInstr(P +* loop I,
   Comput(P +* loop I,(s +* (Initialize loop I)),m))
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
A1: ProgramPart I = I by RELAT_1:209;
  set s1 = s +* (Initialize I),
      P1 = P +* I;
  set s2 = s +* (Initialize loop I),
      P2 = P +* loop I;
A2: I c= P1 by FUNCT_4:26;
A3: loop I c= P2 by FUNCT_4:26;
  assume that
A4: I is_closed_on s,P and
A5: I is_halting_on s,P;
  let m be Element of NAT;
A6: IC Comput(P1,s1,m) in dom I by A4,SCMFSA7B:def 7,A1;
  then
A7: IC Comput(P1,s1,m) in dom loop I by FUNCT_4:105;
A8:  P1/.IC Comput(P1,s1,m) = P1.IC Comput(P1,s1,m) by PBOOLE:158;
A9: CurInstr(P1,Comput(P1,s1,m))
 = I.IC Comput(P1,s1,m) by A6,A8,GRFUNC_1:8,A2;
  assume
A10: m < LifeSpan(P +* I,s +* (Initialize I));
A11:  P2/.IC Comput(P2,s2,m)
 = P2.IC Comput(P2,s2,m) by PBOOLE:158;
  P1 halts_on s1 by A5,SCMFSA7B:def 8,A1;
  then I.IC Comput(P1,s1,m) <> halt SCM+FSA by A10,A9,
EXTPRO_1:def 14;
  then
A12: I.IC Comput(P1,s1,m) = (loop I).IC Comput(P1,s1,m) by FUNCT_4:111;
  thus CurInstr(P1,Comput(P1,s1,m))
   = P1.IC Comput(P1,s1,m) by A8
  .= I.IC Comput(P1,s1,m) by GRFUNC_1:8,A2,A6
  .= (loop I).IC Comput(P1,s1,m) by A12
  .= P2.IC Comput(P1,s1,m) by A7,GRFUNC_1:8,A3
    .= CurInstr(P2,Comput(P2,s2,m))
     by A4,A5,A10,Th109,A11,COMPOS_1:24;
end;

Lm2: for s being State of SCM+FSA, I being Program of SCM+FSA st I
is_closed_on s,P & I is_halting_on s,P holds
 (CurInstr(P +* loop I,
    Comput(P +* loop I, (s +* (Initialize loop I)),
    LifeSpan(P +* I,s +* (Initialize I)))) = goto
0 & for m being Element of NAT
 st m <= LifeSpan(P +* I,s +* (Initialize I))
holds CurInstr( P +* loop I,
    Comput(P +* loop I, (s +* (Initialize loop I)),m))
 <> halt SCM+FSA)

proof
A1: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:71;

  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
A2: ProgramPart I = I by RELAT_1:209;
  set s1 = s +* (Initialize I),
      P1 = P +* I;
  set s2 = s +* (Initialize loop I),
      P2 = P +* loop I;
A3: I c= P1 by FUNCT_4:26;
  assume that
A4: I is_closed_on s,P and
A5: I is_halting_on s,P;
  set k = LifeSpan(P1,s1);
A6: IC Comput(P1,s1,k) in dom I by A4,SCMFSA7B:def 7,A2;
A7:  dom loop I = dom I by FUNCT_4:105;
A8: P1 halts_on s1 by A5,SCMFSA7B:def 8,A2;
  then
A9: CurInstr(P1,Comput(P1,s1,k))
 = halt SCM+FSA by EXTPRO_1:def 14;
A10: P1/.IC Comput(P1,s1,k) = P1.IC Comput(P1,s1,k) by PBOOLE:158;
A11: CurInstr(P1,Comput(P1,s1,k))
 = P1.IC Comput(P1,s1,k) by A10
    .= I.IC Comput(P1,s1,k) by A3,GRFUNC_1:8,A6
    .= I.IC Comput(P1,s1,k);
A12: rng I c= the Instructions of SCM+FSA by RELAT_1:def 19;

A13: P2/.IC Comput(P2,s2,LifeSpan(P1,s1))
 = P2.IC Comput(P2,s2,LifeSpan(P1,s1)) by PBOOLE:158;
  thus
A14: CurInstr(P2,Comput(P2,s2,LifeSpan(P1,s1)))
 = P2.IC Comput(P1,s1,k) by A4,A5,Th109,A13,COMPOS_1:24

    .= P2.IC Comput(P1,s1,k)
    .= (loop I).IC Comput(P1,s1,k)
    by FUNCT_4:14,A6,A7
    .= (loop I).IC Comput(P1,s1,k)

    .= (((id the Instructions of SCM+FSA)+*(halt SCM+FSA,goto  0))*I )
  .IC Comput(P1,s1,k) by A12,FUNCT_7:118

    .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA, goto  0)).
  halt SCM+FSA by A9,A6,A11,FUNCT_1:23

    .= goto  0 by A1,FUNCT_7:33;
  let m be Element of NAT;
  assume
A15: m <= LifeSpan(P1,s1);
  per cases by A15,XXREAL_0:1;
  suppose
A16: m < LifeSpan(P1,s1);
    then CurInstr(P1,Comput(P1,s1,m))
     <> halt SCM+FSA by A8,EXTPRO_1:def 14;
    hence thesis by A4,A5,A16,Th110;
  end;
  suppose
    m = LifeSpan(P1,s1);
    hence thesis by A14;
  end;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
is_closed_on s,P & I is_halting_on s,P
 for m being Element of NAT st m <= LifeSpan(
P +* I,s +* (Initialize I))
  holds CurInstr(P +* loop I,
  Comput(P +* loop I,s +* (Initialize loop I),m)) <> halt SCM+FSA by Lm2;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
is_closed_on s,P & I is_halting_on s,P holds
 CurInstr(P +* loop I,
  Comput(P +* loop I, (s +* (Initialize loop I)),
LifeSpan(P +* I,s +* (Initialize I))))
 = goto  0
  by Lm2;

theorem Th113:
  for s being State of SCM+FSA, I being paraclosed Program of
  SCM+FSA st Initialize I c= s & I c= P &
  P halts_on s
   for m being Element of
  NAT st m <= LifeSpan(P,s) holds Comput(P, s,m),
Comput(P +* loop I, s +* loop I,m)
  equal_outside NAT
proof
  let s be State of SCM+FSA;
  let I be paraclosed Program of SCM+FSA;
  assume
A1: Initialize I c= s;
  assume
A2: I c= P;
  defpred X[Nat] means $1 <= LifeSpan(P,s) implies Comput(
P, s,$1),
  Comput(P+*loop I,(s+*loop I),$1) equal_outside NAT;
  assume
A3: P halts_on s;
A4: for m st X[m] holds X[m+1]
  proof
    set sI = s+*loop I,
        PI = P+*loop I;
A5: loop I c= PI by FUNCT_4:26;
    let m;
    assume
A6: m <= LifeSpan(P,s) implies Comput(P, s,m),
Comput(P+*loop I,(s+*loop I)
    ,m) equal_outside NAT;
A7: IC Comput(P,s,m) in dom I by A1,SCMFSA6B:def 2,A2;
    then
A8: IC Comput(P,s,m) in dom loop I by FUNCT_4:105;
A9:  P/.IC Comput(P,s,m)
 = P.IC Comput(P,s,m) by PBOOLE:158;
A10: CurInstr(P,Comput(P,s,m))
 = I.IC(Comput(P,s,m)) by A7,A9,GRFUNC_1:8,A2;
A11: Comput(PI,sI,m+1) =
Following(PI,Comput(PI,sI,m)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(PI,Comput(PI,sI,m))
      ,Comput(PI,sI,m));
A12: Comput(P,s,m+1) =
Following(P,Comput(P,s,m))
 by EXTPRO_1:4
      .= Exec(CurInstr(P,Comput(P,s,m))
      ,Comput(P,s,m));
A13:  PI/.IC Comput(PI,sI,m)
 = PI.IC Comput(PI,sI,m) by PBOOLE:158;
    assume
A14: m+1 <= LifeSpan(P,s);
    then m < LifeSpan(P,s) by NAT_1:13;
    then I.IC(Comput(P,s,m)) <> halt SCM+FSA by A3,A10,
EXTPRO_1:def 14
;
    then
CurInstr(P,Comput(P,s,m))
 = (loop I).IC(Comput(P,s,m)) by A10,FUNCT_4:111
      .= PI.IC(Comput(P,s,m)) by A8,A5,GRFUNC_1:8
      .= CurInstr(PI,Comput(PI,sI,m))
       by A6,A14,A13,COMPOS_1:24,NAT_1:13;
    hence thesis by A6,A14,A12,A11,NAT_1:13,AMISTD_2:def 20;
  end;
A15: Comput(P+*loop I,(s+*loop I),0) = s+*loop I by EXTPRO_1:3;
  Comput(P, s,0) = s by EXTPRO_1:3;
  then
A16: X[0] by A15,FUNCT_7:132;
  thus for m being Element of NAT holds X[m] from NAT_1:sch 1(A16, A4);
end;

theorem
  for s being State of SCM+FSA, I being parahalting Program of SCM+FSA
st Initialized I c= s & I c= P
 holds for k being Element of NAT st k <= LifeSpan(
P,s) holds
  CurInstr(P +* loop I,
   Comput(P+*loop I, (s +* loop I),k)) <> halt SCM+FSA
proof
  let s be State of SCM+FSA;
  let I be parahalting Program of SCM+FSA;
  set s2 = s +* loop I,
      P2 = P +* loop I;
A1: ProgramPart Initialized I = I by SCMFSA6A:33;
  assume
A2: Initialized I c= s;
  then
A3: Initialize I c= s by SCMFSA6B:8;
  assume
A4: I c= P;
   then
A5: P halts_on s by A2,EXTPRO_1:def 10,A1;
:::  hereby
    let k be Element of NAT;
    assume
A6: k <= LifeSpan(P,s);
    set lk = IC Comput(P, s,k);
    assume
A7: CurInstr(P+*loop I,
 Comput(P+*loop I, (s +* loop I),k)) = halt SCM+FSA;
A8: dom I = dom loop I by FUNCT_4:105;
A9: IC Comput(P, s,k) in dom I by A3,SCMFSA6B:def 2,A4;
    then
A10: (loop I).lk in rng loop I by A8,FUNCT_1:def 5;
A11:  P2/.IC Comput(P2,s2,k)
 = P2.IC Comput(P2,s2,k) by PBOOLE:158;
    CurInstr(P2,Comput(P2,s2
,k))
     = P2.lk by A5,A3,A6,Th113,A11,COMPOS_1:24,A4
      .= P2.lk
      .= (loop I).lk by A9,A8,FUNCT_4:14;
    hence contradiction by A7,A10,Th107;
:::  end;
end;

begin :: Times

definition
  let a be Int-Location;
  let I be Program of SCM+FSA;
  func Times(a,I) -> Program of SCM+FSA equals
  if>0(a,loop if=0(a,Goto 2,I ';' SubFrom(a,intloc 0)), Stop SCM+FSA);
  correctness;
end;

registration
  let a be Int-Location;
  let I be Program of SCM+FSA;
  cluster Times(a,I) -> non halt-free;
  coherence;
end;

theorem Th115:
  for I being good Program of SCM+FSA, a being read-write
  Int-Location holds if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) is good
proof
  let I be good Program of SCM+FSA;
  let a be read-write Int-Location;
  reconsider J3 = Macro SubFrom(a,intloc 0) as good Program of SCM+FSA by Th99,
SCMFSA7B:14;
  I ';' SubFrom(a,intloc 0) = I ';' J3;
  then reconsider I1 = I ';' SubFrom(a,intloc 0) as good Program of SCM+FSA;
  reconsider J1 = Macro (a =0_goto  (card I1 + 3)) as good Program of
  SCM+FSA by Th99,SCMFSA7B:18;
  if=0(a,Goto  2,I1) = (a =0_goto  (card I1 + 3) ';' I1 ';'
  Goto  (card Goto  2 + 1)) ';' Goto  2 ';' Stop SCM+FSA by SCMFSA8B:def 1
    .= J1 ';' I1 ';' Goto  (card Goto  2 + 1) ';' Goto  2
  ';' Stop SCM+FSA;
  hence thesis;
end;

theorem Th116:
  for I,J being Program of SCM+FSA,a being Int-Location holds
if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)).  (card (I ';' SubFrom(a,
  intloc 0)) + 3) = goto  (card (I ';' SubFrom(a,intloc 0)) + 5)
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  set I1 = I ';' SubFrom(a,intloc 0);
  set J3 = a =0_goto  (card I1 + 3) ';' I1 ';' Goto  (card Goto
   2 + 1);
  set J4 = (a =0_goto  (card I1 + 3) ';' I1 ';' Goto  (card Goto
   2 + 1)) ';' Goto  2;
A1: card Goto  (card Goto  2 + 1) = 1 by SCMFSA8A:29;
  card (a =0_goto  (card I1 + 3) ';' I1) = card Macro (a =0_goto
   (card I1 + 3)) + card I1 by SCMFSA6A:61
    .= 2 + card I1 by COMPOS_1:150;
  then
A2: card J3 = card I1 + 2 + 1 by A1,SCMFSA6A:61
    .= card I1 + (2 + 1);
  then card I1 + (2 + 1) -' card J3 = 0 by XREAL_1:234;
  then
A3: goto  2 = (Goto  2). (card I1 + (2 + 1) -' card J3 )
  by SCMFSA8A:47;
A4: card Goto  2 = 1 by SCMFSA8A:29;
  then card I1 + (2 + 1) < card J3 + card Goto  2 by A2,NAT_1:13;
  then
A5: J4. (card I1 + (2 + 1)) = IncAddr(goto  2,card J3) by A2,A3,Th13
    .= goto ( 2 + (card I1 + (2 + 1))) by A2,SCMFSA_4:14
    .= goto  (card I1 + (2 + 3));
  card J4 = card I1 + (2 + 1) + 1 by A2,A4,SCMFSA6A:61
    .= card I1 + (2 + 1 + 1);
  then card J4 = card I1 + 3 + 1;
  then card I1 + 3 < card J4 by NAT_1:13;
  then
A6:  (card I1 + 3) in dom J4 by AFINSQ_1:70;
  then
  (J4 ';' Stop SCM+FSA). (card I1 + 3) = (Directed J4). (card
  I1 + 3) by SCMFSA8A:28
    .= goto  (card I1 + 5) by A5,A6,SCMFSA8A:30;
  hence thesis by SCMFSA8B:def 1;
end;

theorem Th117:
  for s being State of SCM+FSA, I being good parahalting Program
of SCM+FSA, a being read-write Int-Location st I does not destroy a & s.intloc
  0 = 1 & s.a > 0 holds loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s,P
proof
  let s be State of SCM+FSA;
  set A = NAT;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  set I2 = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
A1: ProgramPart I2 = I2 by RELAT_1:209;
A2: ProgramPart loop I2 = loop I2 by RELAT_1:209;
  reconsider I1 = I ';' SubFrom(a,intloc 0) as parahalting Program of SCM+FSA;
  set i = a =0_goto  (card I1 + 3);
  defpred P[Nat] means
   for s being State of SCM+FSA
    st s.intloc 0 = 1 & s.a = $1 & s.a > 0
   holds
    Comput(P +* loop I2, s +* (Initialize loop I2),
      (LifeSpan(P +* I2, s +* (Initialize I2)) + 1)).a = s.a - 1 &
    Comput(P +* loop I2, s +* (Initialize loop I2),
       LifeSpan(P +* I2,s +* (Initialize I2)) + 1).intloc 0 = 1 &
   ex k being Element of NAT
    st IC Comput(P +* loop I2,s +* (Initialize loop I2),k)
       =  card loop I2 &
   for n being Element of NAT st n < k
    holds IC Comput(P +* loop I2,s +* (Initialize loop I2),n)
      in dom loop I2;
  assume
A3: I does not destroy a;
A4: for k being Element of NAT holds P[k] implies P[k + 1]
  proof
    let k be Element of NAT;
    assume
A5: P[k];
    let ss be State of SCM+FSA;
    assume
A6: ss.intloc 0 = 1;
    set s2 = ss +* (Initialize loop I2),
        P2 = P +* loop I2;
    set s1 = ss +* (Initialize I2),
        P1 = P +* I2;
A7: loop I2 c= P2 by FUNCT_4:26;
    assume
A8: ss.a = k + 1;
    set s3 = Comput(P2,s2,LifeSpan(P1,s1) + 1),
        P3 = P2;
A9: P2 +* loop I2 = P3 by FUNCT_4:99;
    assume
A10: ss.a > 0;
A11: Comput(P2,s2,LifeSpan(P1,s1)+1) =
Following(P2,
Comput(P2,s2,LifeSpan(P1,s1)))
    by EXTPRO_1:4
      .= Exec(CurInstr(P2,
      Comput(P2,s2,LifeSpan(P1,s1))), Comput(
P2,s2,
LifeSpan(P1,
    s1)));
A12: I1 is_halting_on ss,P by SCMFSA7B:25;
A13: I1 is_closed_on ss,P by SCMFSA7B:24;
    then
A14: I2 is_closed_on ss,P by A10,A12,SCMFSA8B:18;
A15: I2 is_halting_on ss,P by A10,A13,A12,SCMFSA8B:18;
A16: I2 is_closed_on ss,P by A10,A13,A12,SCMFSA8B:18;
    then
A17: IC Comput(P2,s2,LifeSpan(P1,s1)+1) = Exec(goto
0,Comput(P2,s2,
    LifeSpan(P1,s1))).IC SCM+FSA by A15,A11,Lm2
      .=  0 by SCMFSA_2:95;
A18: Comput(P2,s2,LifeSpan(P1,s1)+1) = Exec(goto  0,
Comput(P2,s2,
    LifeSpan(P1,s1))) by A16,A15,A11,Lm2;
A19: now
A20:  I1 is_halting_on Initialized ss,P by SCMFSA7B:25;
      I1 is_closed_on Initialized ss,P by SCMFSA7B:24;
      then
      IExec(I2,P,ss) = IExec(I1,P,ss) +* Start-At((card Goto  2 +
      card I1 + 3),SCM+FSA) by A10,A20,SCMFSA8B:19;
      then
A21:  IExec(I2,P,ss).a = IExec(I1,P,ss).a by SCMFSA_3:11;
A22:  card I2 = card Goto  2 + card I1 + 4 by SCMFSA8B:14
        .= card I1 + 1 + 4 by SCMFSA8A:29
        .= card I1 + 3 + 2;
A23:  card loop I2 = card dom loop I2
        .= card dom I2 by FUNCT_4:105
        .= card I2;
      hereby
        thus  0 in dom loop I2 by A23,AFINSQ_1:70;
        card I1 + 3 + (1 + 1) = (card I1 + 3 + 1) + 1;
        then card I1 + 3 + 1 < card I2 by A22,NAT_1:13;
        then card I1 + 3 < card loop I2 by A23,NAT_1:13;
        hence  (card I1 + 3) in dom loop I2 by AFINSQ_1:70;
      end;
A24:  dom I2 misses dom SA0 by COMPOS_1:140;
      thus intloc 0 in dom ss by SCMFSA_2:66;
      then
A25:  ss +* Q = ss by A6,FUNCT_7:111;
A26:  I1 is_closed_on Initialized ss,P by SCMFSA7B:24;
A27:  I1 is_halting_on Initialized ss,P by SCMFSA7B:25;
A28:  (Initialized ss).a > 0 by A10,SCMFSA6C:3;
      then
A29:  I2 is_halting_on Initialized ss,P by A26,A27,SCMFSA8B:18;
A30:  I2 is_closed_on Initialized ss,P by A28,A26,A27,SCMFSA8B:18;
      consider Is being State of SCM+FSA such that
A31:  Is = Initialized ss +* (Initialize I2);
      set IP = P +* I2;
      Initialized ss = Initialize(ss +* ((intloc 0) .--> 1)) by FUNCT_4:15;
      then
A32:  Initialized ss +* (Initialize I2) =
Initialize ss +* (SA0 +* I2) by A25,A24,FUNCT_4:36
        .= Initialize Initialize ss +* I2 by FUNCT_4:15
        .= Initialize Initialize ss +* I2 by FUNCT_4:15
        .= ss +* (SA0 +* I2) by FUNCT_4:15
        .= ss +* (Initialize I2) by A24,FUNCT_4:36;
A33:  now
        let b be Int-Location;
        Comput(P2,s2,LifeSpan(P1,s1)+1).b = Comput(
P2,s2,
LifeSpan(P1,s1)).b
        by A18,SCMFSA_2:95;
        hence Comput(P2,s2,LifeSpan(P1,s1)+1).b =
Comput(IP, Is,LifeSpan(IP,Is)).b
        by A15,A14,A32,A31,Th109,SCMFSA10:92;
      end;
      then Comput(P2,s2,LifeSpan(P1,s1)+1).a = Comput
(IP
, Is,LifeSpan(IP,Is)).a
        .= IExec(I2,P,ss).a by A31,A29,Th87;
      hence Comput(P2,s2,LifeSpan(P1,s1)+1).a =
Comput(P +* I1, (Initialized ss +* (
Initialize I1)),
 (LifeSpan(P +* I1,Initialized ss +* (Initialize I1
      )))).a by A20,A21,Th87
        .= ss.a - 1 by A3,Th98;
A34:  I2 is good by Th115;
      Comput(P2,s2,LifeSpan(P1,s1)+1).intloc 0 =
Comput(IP, Is,LifeSpan (IP,
      Is)).intloc 0 by A33
        .= 1 by A31,A29,A30,A34,Th96;
      hence Comput(P2,s2,LifeSpan(P1,s1)+1).intloc 0 = 1;
    end;
    hence s3.a = ss.a - 1 & s3.intloc 0 = 1;
A35: now
A36:  (Macro i). 0 <> halt SCM+FSA by COMPOS_1:148;
A37:   0 in dom Macro i by COMPOS_1:147;
      I2 = i ';' I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA by SCMFSA8B:def 1
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1)) ';' Goto
       2 ';' Stop SCM+FSA by SCMFSA6A:71
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2) ';' Stop SCM+FSA by SCMFSA6A:71
        .= i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA) by SCMFSA6A:71
        .= Macro i ';' (I1 ';' Goto  (card Goto  2 + 1) ';' Goto
       2 ';' Stop SCM+FSA);
      hence I2. 0 = (Macro i). 0 by A37,A36,SCMFSA6A:54
        .= i by COMPOS_1:148;
      hence I2. 0 <> halt SCM+FSA;
A38:  card I2 = card Goto  2 + card I1 + 4 by SCMFSA8B:14
        .= card I1 + 1 + 4 by SCMFSA8A:29
        .= card I1 + 3 + 2;
      hence  0 in dom I2 by AFINSQ_1:70;
      card loop I2 = card dom loop I2
        .= card dom I2 by FUNCT_4:105
        .= card I2;
      then card loop I2 = card I1 + (3 + 2) by A38;
      hence I2. (card I1 + 3) = goto  card loop I2
      by Th116;
      hence I2. (card I1 + 3) <> halt SCM+FSA;
      hereby
        card I1 + 3 + 0 < card I2 by A38,XREAL_1:8;
        hence  (card I1 + 3) in dom I2 by AFINSQ_1:70;
      end;
    end;
    hereby
      per cases;
      suppose
A39:    k = 0;
        take m = LifeSpan(P1,s1) + 1 + 1 + 1;
A40:  P2/.IC Comput(P2,s2,LifeSpan(P1,s1)+1)
 = P2.IC Comput(P2,s2,LifeSpan(P1,s1)+1) by PBOOLE:158;
A41:    CurInstr(P2,
Comput(P2,s2,LifeSpan(P1,s1)+1))
           = P2. 0 by A17,A40
          .= (loop I2). 0 by A19,GRFUNC_1:8,A7
          .= i by A35,FUNCT_4:111;
A42:  P2/.IC Comput(P2,s2,LifeSpan(P1,s1)+1+1)
 = P2.IC Comput(P2,s2,LifeSpan(P1,s1)+1+1)
 by PBOOLE:158;
A43:    Comput(P2,s2,LifeSpan(P1,s1)+1+1) =
Following(P2,
Comput(P2,s2,LifeSpan(P1,s1)+1)) by EXTPRO_1:4
          .= Exec(i,Comput(P2,s2,LifeSpan(P1,s1)+1))
by A41;
        then IC Comput(P2,s2,LifeSpan(P1,s1)+1+1) =
(card I1 + 3) by A8,A19,A39,SCMFSA_2:96;
        then
A44:    CurInstr(P2,
            Comput(P2,s2,LifeSpan(P1,s1)+1+1))
 = P2. (card I1 + 3
        ) by A42
          .= (loop I2). (card I1 + 3) by A19,GRFUNC_1:8,A7
          .= goto  card loop I2 by A35,FUNCT_4:111;
        Comput(P2,s2,m) =
        Following(P2,
        Comput(P2,s2,LifeSpan(P1,s1)+1+1)) by
EXTPRO_1:4
          .= Exec(goto  card loop I2, Comput(P2,s2,
        LifeSpan(P1,s1)+1+1)) by A44;
        hence IC Comput(P2,s2,m) =  card loop I2 by
SCMFSA_2:95;
        hereby
          let n be Element of NAT;
          assume n < m;
          then n <= LifeSpan(P1,s1) + 1 + 1 by NAT_1:13;
          then
A45:      n <= LifeSpan(P1,s1) + 1 or n = LifeSpan(P1
,s1) + 1 + 1 by NAT_1:8;
          per cases by A45,NAT_1:8;
          suppose
A46:        n <= LifeSpan(P1,s1);
A47:        I1 is_halting_on ss,P by SCMFSA7B:25;
A48:        I1 is_closed_on ss,P by SCMFSA7B:24;
            then
A49:        I2 is_closed_on ss,P by A10,A47,SCMFSA8B:18;
            I2 is_halting_on ss,P by A10,A48,A47,SCMFSA8B:18;
            then Comput(P1,s1,n),Comput(P2,s2,n)
equal_outside A by A46,A49,Th109;
            then
A50:        IC Comput(P2,s2,n) = IC Comput(P1,s1,n)
by SCMFSA8A:6;

            IC Comput(P1,s1,n) in dom I2
             by A49,SCMFSA7B:def 7,A1;
            hence IC Comput(P2,s2,n) in dom loop I2 by A50,FUNCT_4:105;
          end;
          suppose
            n = LifeSpan(P1,s1) + 1;
            hence IC Comput(P2,s2,n) in dom loop I2 by A17,A19;
          end;
          suppose
            n = LifeSpan(P1,s1) + 1 + 1;
            hence IC Comput(P2,s2,n) in dom loop I2 by A8,A19,A39
,A43,SCMFSA_2:96;
          end;
        end;
      end;
      suppose
A51:    k > 0;
        consider Is3 being State of SCM+FSA such that
A52:    Is3 = Initialized s3;
A53:    dom loop I2 misses dom SA0 by COMPOS_1:140;
        then
        Initialized s3 +* (Initialize loop I2) =
        Initialized s3 +* (SA0 +* loop I2) by FUNCT_4:36
          .= Initialize Initialized s3 +* loop I2 by FUNCT_4:15;
        then
A54:    Initialized s3 +* (Initialize loop I2) = s3 +* (IC
        SCM+FSA .-->  0) +*loop I2 by A17,A19,Th14;
        s2 = ss +* (SA0 +* loop I2) by A53,FUNCT_4:36
          .= Initialize ss +* loop I2 by FUNCT_4:15;
        then loop I2 c= s2 by FUNCT_4:26;
        then loop I2 c= s3 by AMI_1:99,A2;
        then
A55:    loop I2 c= s3;
A56:    Is3.intloc 0 = 1 by A52,SCMFSA6C:3;
        Is3.a = k by A8,A19,A52,SCMFSA6C:3;
        then consider m0 being Element of NAT such that
A57:    IC Comput(P3 +* loop I2,(Is3 +* (Initialize loop I2)),m0)
            = card loop I2 and
A58:    for n being Element of NAT st n < m0
          holds IC Comput(P3 +* loop I2, (
        Is3 +* (Initialize loop I2)),n) in dom loop I2
        by A5,A51,A56,A9;
        take m = LifeSpan(P1,s1) + 1 + m0;
        IC SCM+FSA in dom s3 by COMPOS_1:9;
        then
A59:    Initialized s3 +* (Initialize loop I2) =
             s3 +* loop I2 by A17,A54,FUNCT_7:111
          .= s3 by A55,FUNCT_4:79;
        thus
        IC Comput(P2,s2,m)
          = IC Comput(P2,s2,m)
         .= card loop I2 by A52,A57,EXTPRO_1:5,A59
         ,A9;
        hereby
          let n be Element of NAT;
          assume
A60:      n < m;
A61:      I1 is_halting_on ss,P by SCMFSA7B:25;
A62:      I1 is_closed_on ss,P by SCMFSA7B:24;
          then
A63:      I2 is_closed_on ss,P by A10,A61,SCMFSA8B:18;
A64:      I2 is_halting_on ss,P by A10,A62,A61,SCMFSA8B:18;
          per cases by NAT_1:13;
          suppose
            n <= LifeSpan(P1,s1);
            then Comput(P1,s1,n),Comput(P2,s2,n)
equal_outside A by A63,A64,Th109;
            then
A65:        IC Comput(P2,s2,n) = IC Comput(P1,s1,n)
by SCMFSA8A:6;
            IC Comput(P1,s1,n) in dom I2 by A63,SCMFSA7B:def 7,A1;
            hence IC Comput(P2,s2,n) in dom loop I2 by A65,
FUNCT_4:105;
          end;
          suppose
A66:        LifeSpan(P1,s1) + 1 <= n;
            consider mm being Element of NAT such that
A67:        mm = n -' (LifeSpan(P1,s1) + 1);
            n - (LifeSpan(P1,s1) + 1) >= 0 by A66,XREAL_1:50;
            then
A68:        mm = n - (LifeSpan(P1,s1) + 1) by A67,XREAL_0:def 2;
            mm + (LifeSpan(P1,s1) + 1) = n by A66,A67,XREAL_1:237;
            then
A69:        IC Comput(P2,s2,n) = IC Comput(P2, s3,mm
) by EXTPRO_1:5;
            m0 = m - (LifeSpan(P1,s1) + 1);
            then mm < m0 by A60,A68,XREAL_1:11;
            hence IC Comput(P2,s2,n) in dom loop I2 by A52,A58,A59
,A69,A9;
          end;
        end;
      end;
    end;
  end;
  assume
A70: s.intloc 0 = 1;
  assume
A71: s.a > 0;
  then reconsider sa = s.a as Element of NAT by INT_1:16;
A72: P[0];
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A72,A4);
  then P[sa];
  then ex k being Element of NAT
   st IC Comput(P +* loop I2, (s +* (Initialize loop I2)),k)
     = card loop I2 &
  for n being Element of NAT st n < k
     holds IC Comput(P +* loop I2,(s+* (Initialize loop I2)),n)
     in dom loop I2 by A70,A71;
  hence thesis by SCMFSA8A:def 3,A2;
end;

theorem
  for s being State of SCM+FSA, I being good parahalting Program of
  SCM+FSA, a being read-write Int-Location st I does not destroy a & s.a > 0
  holds Initialized loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s,P
proof
  let s be State of SCM+FSA;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
A2: (Initialized s).a = s.a by SCMFSA6C:3;
A3: (Initialized s).intloc 0 = 1 by SCMFSA6C:3;
  assume s.a > 0;
  then
  loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) is_pseudo-closed_on
  Initialized s,P by A1,A2,A3,Th117;
  hence thesis by Lm1;
end;

theorem
  for s being State of SCM+FSA, I being good parahalting Program of
SCM+FSA, a being read-write Int-Location st I does not destroy a & s.intloc 0 =
  1 holds Times(a,I) is_closed_on s,P & Times(a,I) is_halting_on s,P
proof
  let s be State of SCM+FSA;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
  assume
A2: s.intloc 0 = 1;
  per cases;
  suppose
A3: s.a > 0;
    Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) = loop
    if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) by SCMFSA6A:63;
    then Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
    is_pseudo-closed_on s,P by A1,A2,A3,Th117;
    hence thesis by A3,Th68;
  end;
  suppose
A4: s.a <= 0;
A5: Stop SCM+FSA is_halting_on s,P by SCMFSA7B:25;
    Stop SCM+FSA is_closed_on s,P by SCMFSA7B:24;
    hence thesis by A4,A5,SCMFSA8B:24;
  end;
end;

theorem
  for I being good parahalting Program of SCM+FSA, a being read-write
  Int-Location st I does not destroy a holds Initialized Times(a,I) is halting
proof
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
  now
    let s be State of SCM+FSA;
    let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
    per cases;
    suppose
      s.a > 0;
      then
A2:   (Initialized s).a > 0 by SCMFSA6C:3;
A3:   Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) = loop
      if=0(a,Goto  2,I ';' SubFrom(a,intloc 0)) by SCMFSA6A:63;
      (Initialized s).intloc 0 = 1 by SCMFSA6C:3;
      then Directed loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
      is_pseudo-closed_on Initialized s,P by A1,A2,A3,Th117;
      then Times(a,I) is_halting_on Initialized s,P by A2,Th68;
      hence Initialized Times(a,I) is_halting_on s,P by Th22;
    end;
    suppose
A4:   s.a <= 0;
A5:   Stop SCM+FSA is_closed_on Initialized s,P by SCMFSA7B:24;
A6:   Stop SCM+FSA is_halting_on Initialized s,P by SCMFSA7B:25;
      (Initialized s).a <= 0 by A4,SCMFSA6C:3;
      then Times(a,I) is_halting_on Initialized s,P by A5,A6,SCMFSA8B:24;
      hence Initialized Times(a,I) is_halting_on s,P by Th22;
    end;
  end;
  hence thesis by Th24;
end;

theorem
  for I,J being Program of SCM+FSA, a,c being Int-Location st I
does not destroy c & J does not destroy c holds if=0(a,I,J) does not destroy c
  & if>0(a,I,J) does not destroy c
proof
  let I,J be Program of SCM+FSA;
  let a,c be Int-Location;
  assume
A1: I does not destroy c;
A2: Goto  (card I + 1) does not destroy c by Th86;
  assume
A3: J does not destroy c;
  then a =0_goto  (card J + 3) ';' J does not destroy c by Th82,SCMFSA7B:18;
  then a =0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
  does not destroy c by A2,Th81;
  then
A4: a =0_goto  (card J + 3) ';' J ';' Goto  (card I + 1) ';' I
  does not destroy c by A1,Th81;
A5: Goto  (card I + 1) does not destroy c by Th86;
  a >0_goto  (card J + 3) ';' J does not destroy c by A3,Th82,SCMFSA7B:19
;
  then a >0_goto  (card J + 3) ';' J ';' Goto  (card I + 1)
  does not destroy c by A5,Th81;
  then
A6: a >0_goto  (card J + 3) ';' J ';' Goto  (card I + 1) ';' I
  does not destroy c by A1,Th81;
A7: if=0(a,I,J) = a =0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  Stop SCM+FSA does not destroy c by Th85;
  hence if=0(a,I,J) does not destroy c by A4,A7,Th81;
A8: if>0(a,I,J) = a >0_goto  (card J + 3) ';' J ';' Goto  (card
  I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  Stop SCM+FSA does not destroy c by Th85;
  hence thesis by A6,A8,Th81;
end;

theorem Th122:
  for s being State of SCM+FSA, I being good parahalting Program of SCM+FSA,
      a being read-write Int-Location
       st I does not destroy a & s.intloc 0 = 1 & s.a > 0
 ex s2 being State of SCM+FSA,
    P2 being  (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
    k being Element of NAT st
  s2 = s +* Initialize (loop if=0(a,Goto  2, I ';' SubFrom(a,intloc 0))) &
  P2 = P +* (loop if=0(a,Goto  2, I ';' SubFrom(a,intloc 0))) &
  k = LifeSpan(P +* (if=0(a,Goto  2, I ';' SubFrom(a,intloc 0))),
  s +* Initialize (if=0(a,Goto  2, I ';' SubFrom(a,intloc 0)) )) + 1 &
  Comput(P2, s2,k).a = s.a - 1 &
  Comput(P2, s2,k).intloc 0 = 1 &
  (for b being read-write Int-Location st b <> a holds
   Comput(P2, s2,k).b = IExec(I,P,s).b) &
  (for f being FinSeq-Location holds Comput(P2, s2,k).f = IExec(I,P,s).f) &
    IC Comput(P2,s2,k) =  0 &
  for n being Element of NAT st n <= k
   holds IC Comput(P2, s2,n)
    in dom loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
proof
  let s be State of SCM+FSA;
  set A = NAT;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does not destroy a;
  reconsider I1 = I ';' SubFrom(a,intloc 0) as parahalting Program of SCM+FSA;
  set I2 = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
A2: ProgramPart I2 = I2 by RELAT_1:209;
  set s1 = s +* (Initialize I2),
      P1 = P +* I2;
A3: I1 is_halting_on s,P by SCMFSA7B:25;
  set Is = Initialized s +* (Initialize I2),
      IP = P +* I2;
A4: intloc 0 in dom s by SCMFSA_2:66;
  assume s.intloc 0 = 1;
  then
A5: s +* Q = s by A4,FUNCT_7:111;
A6: I1 is_closed_on Initialized s,P by SCMFSA7B:24;
A7: I1 is_halting_on Initialized s,P by SCMFSA7B:25;
  assume
A8: s.a > 0;
  then
A9: (Initialized s).a > 0 by SCMFSA6C:3;
  then
A10: I2 is_halting_on Initialized s,P by A6,A7,SCMFSA8B:18;
A11: I2 is_closed_on Initialized s,P by A9,A6,A7,SCMFSA8B:18;
  take s2 = s +* (Initialize loop I2),
       P2 = P +* loop I2;
   reconsider k = LifeSpan(P1,s1) + 1 as Element of NAT;
  take k;
  thus s2 = s +* Initialize (loop if=0(a,Goto  2, I ';' SubFrom(a,intloc 0)));
  thus P2 = P +* (loop if=0(a,Goto  2, I ';' SubFrom(a,intloc 0)));
  thus k = LifeSpan(P +* (if=0(a,Goto  2, I ';' SubFrom(a,intloc 0))),
       s +* (Initialize if=0(a,Goto  2, I ';' SubFrom(a,intloc 0)))) + 1;
A12: dom I2 misses dom SA0 by COMPOS_1:140;
     Initialized s = Initialize(s +* ((intloc 0) .--> 1)) by FUNCT_4:15;
     then
A13: Initialized s +* (Initialize I2) =
Initialize s +* (SA0 +* I2) by A5,A12,FUNCT_4:36
    .= Initialize Initialize s +* I2 by FUNCT_4:15
    .= s +* (Initialize SA0) +* I2
    by FUNCT_4:15
    .= s +* (SA0 +* I2) by FUNCT_4:15
    .= s +* (Initialize I2) by A12,FUNCT_4:36;
A14: I1 is_halting_on Initialized s,P by SCMFSA7B:25;
  I1 is_closed_on Initialized s,P by SCMFSA7B:24;
  then
A15: IExec(I2,P,s) = IExec(I1,P,s) +* Start-At((card Goto  2 + card
  I1 + 3),SCM+FSA) by A8,A14,SCMFSA8B:19;
  then
A16: IExec(I2,P,s).a = IExec(I1,P,s).a by SCMFSA_3:11;
A17: I1 is_closed_on s,P by SCMFSA7B:24;
  then
A18: I2 is_closed_on s,P by A8,A3,SCMFSA8B:18;
A19: I2 is_halting_on s,P by A8,A17,A3,SCMFSA8B:18;
A20: Comput(P2,s2,LifeSpan(P1,s1)+1) =
Following(P2,
Comput(P2,s2,LifeSpan(P1,s1)))
 by EXTPRO_1:4
    .= Exec(CurInstr(P2,
    Comput(P2,s2,LifeSpan(P1,s1)))
    ,Comput(P2,s2,LifeSpan(P1,s1))
  );
  then
A21: Comput(P2,s2,LifeSpan(P1,s1)+1) = Exec(goto  0,
Comput(P2,s2,
  LifeSpan(P1,s1))) by A18,A19,Lm2;
A22: now
    let b be Int-Location;
    Comput(P2,s2,LifeSpan(P1,s1)+1).b = Comput(
P2,s2,
LifeSpan(P1,s1)).b by A21,SCMFSA_2:95;
    hence Comput(P2,s2,LifeSpan(P1,s1)+1).b = Comput(
IP,
Is,LifeSpan(IP,Is)).b by A18,A19,A13,Th109,SCMFSA10:92;
  end;
  then Comput(P2,s2,LifeSpan(P1,s1)+1).a = Comput(
IP, Is
,LifeSpan(IP,Is)).a
    .= IExec(I2,P,s).a by A10,Th87;
  hence Comput(P2, s2,k).a =
  Comput(P +* I1, (Initialized s +* (Initialize I1)),
  (LifeSpan(P +* I1,Initialized s +* (Initialize I1)))).a by A14,A16,Th87
    .= s.a - 1 by A1,Th98;
A23: I2 is good by Th115;
  Comput(P2,s2,LifeSpan(P1,s1)+1).intloc 0 = Comput(
IP,
Is,LifeSpan(IP,Is)).
  intloc 0 by A22
    .= 1 by A10,A11,A23,Th96;
  hence Comput(P2, s2,k).intloc 0 = 1;
  hereby
    let b be read-write Int-Location;
    assume
A24: b <> a;
    thus Comput(P2, s2,k).b = Comput(IP, Is,
LifeSpan(IP,Is)).b by A22
      .= IExec(I2,P,s).b by A10,Th87
      .= IExec(I1,P,s).b by A15,SCMFSA_3:11
      .= Exec(SubFrom(a,intloc 0),IExec(I,P,s)).b by SCMFSA6C:7
      .= IExec(I,P,s).b by A24,SCMFSA_2:91;
  end;
  hereby
    let f be FinSeq-Location;
    Comput(P2,s2,LifeSpan(P1,s1)+1).f = Comput(
P2,s2,
LifeSpan(P1,s1)).f by A21,SCMFSA_2:95;
    hence Comput(P2, s2,k).f = Comput(IP, Is,
LifeSpan(IP,Is)).f by A18,A19,A13,Th109,SCMFSA10:93
      .= IExec(I2,P,s).f by A10,Th87
      .= IExec(I1,P,s).f by A15,SCMFSA_3:12
      .= Exec(SubFrom(a,intloc 0),IExec(I,P,s)).f by SCMFSA6C:8
      .= IExec(I,P,s).f by SCMFSA_2:91;
  end;
A25: IC Comput(P2,s2,LifeSpan(P1,s1)+1) = Exec(goto
0,Comput(
P2,s2,
  LifeSpan(P1,s1))).IC SCM+FSA by A18,A19,A20,Lm2
    .=  0 by SCMFSA_2:95;
  hence IC Comput(P2, s2,k) =  0;
  hereby
    let n be Element of NAT;
    assume
A26: n <= k;
    per cases by A26,NAT_1:8;
    suppose
A27:  n <= LifeSpan(P1,s1);
A28:  I1 is_halting_on s,P by SCMFSA7B:25;
A29:  I1 is_closed_on s,P by SCMFSA7B:24;
      then
A30:  I2 is_closed_on s,P by A8,A28,SCMFSA8B:18;
      I2 is_halting_on s,P by A8,A29,A28,SCMFSA8B:18;
      then Comput(P1,s1,n),Comput(P2,s2,n)
equal_outside A by A27,A30,Th109
;
      then
A31:  IC Comput(P2,s2,n) = IC Comput(P1,s1,n) by
SCMFSA8A:6;
      IC Comput(P1,s1,n) in dom I2 by A30,SCMFSA7B:def 7,A2;
      hence IC Comput(P2, s2,n) in dom loop I2
       by A31,FUNCT_4:105;
    end;
    suppose
A32:  n = LifeSpan(P1,s1) + 1;
      card loop I2 = card dom loop I2
        .= card dom I2 by FUNCT_4:105
        .= card I2;
      hence IC Comput(P2, s2,n) in dom loop I2 by A25,A32,
AFINSQ_1:70;
    end;
  end;
end;

theorem Th123:
  for s being State of SCM+FSA, I being good parahalting Program
of SCM+FSA, a being read-write Int-Location st s.intloc 0 = 1 & s.a <= 0 holds
  DataPart IExec(Times(a,I),P,s) = DataPart s
proof
  let s be State of SCM+FSA;
  set D = Data-Locations SCM+FSA;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.intloc 0 = 1;
  set s0 = Initialized s;
A2: Stop SCM+FSA is_halting_on Initialized s,P by SCMFSA7B:25;
  assume s.a <= 0;
  then
A3: (Initialized s).a <= 0 by SCMFSA6C:3;
A4: IExec(Stop SCM+FSA ';' Stop SCM+FSA,P,s0)
 = IExec(Stop SCM+FSA,P,IExec(Stop SCM+FSA,P,s0))
  +* Start-At((IC IExec(Stop SCM+FSA,P,IExec(Stop SCM+FSA,P,s0)) + card
  Stop SCM+FSA),SCM+FSA) by SCMFSA6B:44;
A5: for f being FinSeq-Location holds s0.f = s.f by SCMFSA6C:3;
A6: for a being read-write Int-Location holds s0.a = s.a by SCMFSA6C:3;
A7: s0.intloc 0 = 1 by SCMFSA6C:3;
A8: Stop SCM+FSA is_closed_on Initialized s,P by SCMFSA7B:24;
  then
A9: Times(a,I) is_halting_on Initialized s,P by A3,A2,SCMFSA8B:24;
A10: Stop SCM+FSA is_halting_on s0,P by SCMFSA7B:25;
A11: Stop SCM+FSA is_closed_on s0,P by SCMFSA7B:24;
A12: DataPart IExec(Stop SCM+FSA,P,s0) = DataPart(Initialize Initialized s0)
     by Th38
    .= DataPart (Initialize Initialized s) by Th15
    .= DataPart s0 by SCMFSA8A:10;
A13: Directed Stop SCM+FSA is_pseudo-closed_on s0,P
     by A11,A10,
SCMFSA8A:37;
  Times(a,I) is_closed_on Initialized s,P by A3,A8,A2,SCMFSA8B:24;
  then DataPart IExec(Times(a,I),P,s)
   = DataPart IExec(Times(a,I),P,s0) by A9,A7,A6
,A5,Th45
    .= DataPart IExec(Stop SCM+FSA ';' Stop SCM+FSA,P,s0)
     by A3,A7,Th73,A13;
  hence DataPart IExec(Times(a,I),P,s)
   = DataPart IExec(Stop SCM+FSA,P,IExec(Stop SCM+FSA,P,s0)) by A4,SCMFSA8A:10
    .= DataPart IExec(Stop SCM+FSA,P,s0) by A8,A2,A7,A12,Th46
    .= DataPart s by A1,A12,Th27;
end;

theorem Th124:
  for s being State of SCM+FSA, I being good parahalting Program
  of SCM+FSA, a being read-write Int-Location st I does not destroy a & s.a > 0
holds IExec(I ';' SubFrom(a,intloc 0),P,s).a = s.a - 1 &
   DataPart IExec(Times(a,I),P,s)
    = DataPart IExec(Times(a,I),P,IExec(I ';' SubFrom(a,intloc 0),P,s))
proof
  let s be State of SCM+FSA;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' SubFrom(a,intloc 0);
  set ss = IExec(I1,P,s),
      PP = P;
  set s0 = Initialized s;
  set ss0 = Initialized ss,
      PP0 = P;
  set I2 = if=0(a,Goto  2,I ';' SubFrom(a,intloc 0));
  set s21 = s0 +* Initialize (loop I2 ';' Stop SCM+FSA),
      P21 = P +* (loop I2 ';' Stop SCM+FSA);
  set s31 = ss0 +* Initialize (loop I2 ';' Stop SCM+FSA),
      P31 = PP0 +* (loop I2 ';' Stop SCM+FSA);
A1: loop I2 ';' Stop SCM+FSA c= P21 by FUNCT_4:26;
A2: I is_halting_on s0,P by SCMFSA7B:25;
A3: I1 is_halting_on Initialized s,P by SCMFSA7B:25;
  reconsider J3 = Macro SubFrom(a,intloc 0) as good Program of SCM+FSA by Th99,
SCMFSA7B:14;
  set D = Data-Locations SCM+FSA;
  set A = NAT;
  assume
A4: I does not destroy a;
   0 in dom I2 by Th54;
  then
A5:  0 in dom loop I2 by FUNCT_4:105;
A6: I1 is_closed_on Initialized s,P by SCMFSA7B:24;
A7: I1 = I ';' J3;
  then
A8: ss.intloc 0 = 1 by A3,A6,Th96;
  assume
A9: s.a > 0;
  then
A10: s0.a > 0 by SCMFSA6C:3;
A11: s0.intloc 0 = 1 by SCMFSA6C:3;
  then
A12: loop I2 is_pseudo-closed_on s0,P by A4,A10,Th117;
A13: ProgramPart loop I2 = loop I2 by RELAT_1:209;
A14: Directed loop I2 = loop I2 by SCMFSA6A:63;
  then
A15: Directed loop I2 is_pseudo-closed_on s0,P by A4,A11,A10,Th117;
  consider s2 being State of SCM+FSA,
    P2 being  (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
    k being Element of NAT such that
A16:  s2 = s0 +* (Initialize loop I2) and
A17:  P2 = P +* (loop if=0(a,Goto  2, I ';' SubFrom(a,intloc 0))) and
  k = LifeSpan(P +* I2,s0 +* (Initialize I2)) + 1 and
A18: Comput(P2, s2,k).a = s0.a - 1 and
A19: Comput(P2, s2,k).intloc 0 = 1 and
A20: for b being read-write Int-Location st b <> a holds
   Comput(P2, s2,k).b = IExec(I,P,s0).b and
A21: for f being FinSeq-Location holds Comput(P2, s2,k).f = IExec(I,P,s0).f and
A22: IC Comput(P2,s2,k) =  0 and
A23:  for n being Element of NAT st n <= k
   holds IC Comput(P2, s2,n)
    in dom loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
    by A4,A11,A10,Th122;
A24: now
    let f be FinSeq-Location;
    thus Comput(P2,s2,k).f = IExec(I,P,s0).f by A21
      .= Exec(SubFrom(a,intloc 0),IExec(I,P,s0)).f by SCMFSA_2:91
      .= IExec(I1,P,s0).f by SCMFSA6C:8
      .= IExec(I1,P,s).f by Th17;
  end;
  thus
A25: ss.a = Exec(SubFrom(a,intloc 0),IExec(I,P,s)).a by SCMFSA6C:7
    .= IExec(I,P,s).a - IExec(I,P,s).intloc 0 by SCMFSA_2:91
    .= IExec(I,P,s).a - 1 by A2,Th92
    .= s0.a - 1 by A4,Th91
    .= s.a - 1 by SCMFSA6C:3;
  now
    let b be Int-Location;
    per cases;
    suppose
      b = intloc 0;
      hence Comput(P2,s2,k).b = IExec(I1,P,s).b
       by A19,A7,A3,A6,Th96
;
    end;
    suppose
      b = a;
      hence Comput(P2,s2,k).b = IExec(I1,P,s).b by A18,A25,
SCMFSA6C:3;
    end;
    suppose
A26:  b <> a & b <> intloc 0;
      then reconsider bb = b as read-write Int-Location by SF_MASTR:def 5;
      thus Comput(P2,s2,k).b = IExec(I,P,s0).bb by A20,A26
        .= Exec(SubFrom(a,intloc 0),IExec(I,P,s0)).b by A26,SCMFSA_2:91
        .= IExec(I1,P,s0).b by SCMFSA6C:7
        .= IExec(I1,P,s).b by Th17;
    end;
  end;
  then
A27: DataPart Comput(P2,s2,k) = DataPart ss by A24,SCMFSA6A:38;
A28: DataPart IExec(Times(a,I),P,s0)
 = DataPart IExec(loop I2 ';' Stop SCM+FSA,P,s0) by A4,A11,A10,A14,Th69,Th117;
  per cases;
  suppose
A29: ss.a = 0;
A30: I2. (card I1 + 3) = goto  (card I1 + 5) by Th65;
A31: card I1 + (3 + 2) = card I1 + 1 + 4
      .= card Goto  2 + card I1 + 4 by SCMFSA8A:29
      .= card I2 by SCMFSA8B:14
      .= card dom I2
      .= card dom loop I2 by FUNCT_4:105
      .= card loop I2;
    then card I1 + 3 + 0 < card loop I2 by XREAL_1:8;
    then
A32:  (card I1 + 3) in dom loop I2 by AFINSQ_1:70;
    P2. (card I1 + 3) = P2. (card I1 + 3)
      .= (loop I2). (card I1 + 3)
      by A32,FUNCT_4:14,A17
      .= (loop I2). (card I1 + 3);
    then
A33: P2. (card I1 + 3) = goto  (card I1 + 5)
    by A30,FUNCT_4:111;
    then InsCode(P2. (card I1 + 3)) = 6 by
SCMFSA_2:47;
    then
A34: InsCode (P2. (card I1 + 3)) in {0,6,7,8} by
ENUMSET1:def 2;
A35:  P2/.IC Comput(P2,s2,k)
 = P2.IC Comput(P2,s2,k) by PBOOLE:158;
A36: Comput(P2,s2,k+1) = Following(P2,Comput(P2,s2,k)) by EXTPRO_1:4
      .= Exec(P2. 0,Comput(P2,s2,k)) by A22,A35;
A37: P2. 0 = P2. 0
      .= (loop I2). 0
      by A5,FUNCT_4:14,A17
      .= (loop I2). 0;
A38: I2. 0 = a =0_goto  (card I1 + 3) by Th55;
A39: P2. 0 = a =0_goto  (card I1 + 3) by A37,A38,
FUNCT_4:111;
A40: Comput(P2,s2,k).a = 0 by A18,A25,A29,SCMFSA6C:3;
    then
A41: IC Comput(P2,s2,k+1) =  (card I1 + 3) by A36,A39,SCMFSA_2:96;
A42: now
      let n be Element of NAT;
      assume
A43:  not IC Comput(P2, s2,n) in dom loop I2;
      then k < n by A23;
      then k + 1 <= n by INT_1:20;
      then k + 1 < n by A41,A32,A43,XXREAL_0:1;
      then k + 1 + 1 <= n by INT_1:20;
      hence k + (1 + 1) <= n;
    end;
A44:  P2/.IC Comput(P2,s2,k+1)
 = P2.IC Comput(P2,s2,k+1) by PBOOLE:158;
A45: Comput(P2,s2,k+(1+1)) = Comput(P2,s2,k+1+1)
      .= Following(P2,Comput(P2,s2,k+1))
       by EXTPRO_1:4
      .= Exec(P2. (card I1 + 3),Comput(P2,s2,k+1))
    by A40,A36,A39,A44,SCMFSA_2:96;
    then IC Comput(P2,s2,k+2) =  (card I1 + 5) by A33,SCMFSA_2:95
      .=  card loop I2 by A31;
    then
A46: k + 2 = pseudo-LifeSpan(s0,P,loop I2) by A16,A12,A42,SCMFSA8A:def 5,
     A17,A13;

    InsCode P2. 0 = 7 by A39,SCMFSA_2:48;
    then InsCode P2. 0 in {0,6,7,8} by ENUMSET1:def 2
;
    then DataPart Comput(P2,s2,k) = DataPart Comput(P2,s2,k+1) by A36,Th32;
    then
A47: DataPart Comput(P2,s2,k) = DataPart Comput(P2,s2
,k+2) by A45,A34,Th32;
A48: s21 = s +* Initialized (loop I2 ';' Stop SCM+FSA) by SCMFSA8A:13;
    thus DataPart IExec(Times(a,I),P,s)
     = DataPart IExec(Times(a,I),P,s0) by Th17
      .= DataPart IExec(loop I2 ';' Stop SCM+FSA,P,s) by A28,Th17
      .= DataPart(Result(P21,s21) +* (s|NAT)) by A48
      .= DataPart Result(P21,s21) by COMPOS_1:82
      .= DataPart IExec(I1,P,s) by A4,A11,A10,A16,A14,A27,A46,A47,Th59,Th117,
A17
      .= DataPart IExec(Times(a,I),P,IExec(I1,P,s)) by A8,A29,Th123;
  end;
  suppose
A49: ss.a <> 0;
    s.a >= 0 + 1 by A9,INT_1:20;
    then
A50: ss.a > 0 by A25,A49,XREAL_1:21;
A51: DataPart s0 = DataPart s21 by SCMFSA8A:11;
A52: k < pseudo-LifeSpan(s0,P,loop I2)
 by A4,A11,A10,A16,A23,Th2,Th117,A17,A13;
    then
A53: DataPart Comput(P21, s21,k) = DataPart ss by A16,A14,A15,A27
,Th58,A17;
A54: now
A55:  DataPart ss0 = DataPart s31 by SCMFSA8A:11;
      hereby
        let a be Int-Location;
        per cases;
        suppose
A56:      a = intloc 0;
          thus Comput(P21, s21,k).a = ss.a by A53,SCMFSA6A:38
            .= 1 by A56,SCMFSA6B:35
            .= ss0.a by A56,SCMFSA6C:3
            .= s31.a by A55,SCMFSA6A:38;
        end;
        suppose
          a <> intloc 0;
          then
A57:      a is read-write Int-Location by SF_MASTR:def 5;
          thus Comput(P21, s21,k).a = ss.a by A53,SCMFSA6A:38
            .= ss0.a by A57,SCMFSA6C:3
            .= s31.a by A55,SCMFSA6A:38;
        end;
      end;
      let f be FinSeq-Location;
      thus Comput(P21, s21,k).f = ss.f by A53,SCMFSA6A:38
        .= ss0.f by SCMFSA6C:3
        .= s31.f by A55,SCMFSA6A:38;
    end;
    IC Comput(P21, s21,k) = IC Comput(P2,s2,k) by A16,A14,A15,A52,Th58,A17
    .= IC Initialize (ss0 +* (loop I2 ';' Stop SCM+FSA)) by A22,FUNCT_4:121
      .= IC s31 by FUNCT_4:15;
    then
A58: Comput(P21, s21,k),s31 equal_outside A by A54,SCMFSA10:91;
A59: Initialize(loop I2 ';' Stop SCM+FSA) c= s21
by FUNCT_4:26;
    Directed loop I2 = loop I2 by SCMFSA6A:63;
    then
A60: Directed loop I2 is_pseudo-closed_on s21,P21 by A4,A11,A10,A51,Th52,Th117;
    then
A61: loop I2 ';' Stop SCM+FSA is_closed_on s21,P21 by Th58;
A62: loop I2 ';' Stop SCM+FSA is_halting_on s21,P21 by A60,Th58;
A63: ss.intloc 0 = 1 by A7,A3,A6,Th96;
A64: Initialize (loop I2 ';' Stop SCM+FSA) c= s31
by FUNCT_4:26;
A65:  s21 = s +* Initialized (loop I2 ';' Stop SCM+FSA) by SCMFSA8A:13;
A66:  s31 = ss +* Initialized(loop I2 ';' Stop SCM+FSA) by SCMFSA8A:13;
    DataPart IExec(loop I2 ';' Stop SCM+FSA,P,s0)
     = DataPart IExec(loop I2 ';' Stop SCM+FSA,P,s) by Th17
      .= DataPart(Result(P21,s21) +* (s|NAT)) by A65
      .= DataPart Result(P21,s21) by COMPOS_1:82
      .= DataPart Result(P31,s31) by A59,A64,A61,A62,A58,Th103,
COMPOS_1:138,A1
      .= DataPart(Result(P31,s31) +* (ss|NAT)) by COMPOS_1:82
      .= DataPart IExec(loop I2 ';' Stop SCM+FSA,P,IExec(I1,P,s))
            by A66
      .= DataPart IExec(Times(a,I),P,IExec(I1,P,s))
       by A4,A14,A63,A50,Th69,Th117;
    hence thesis by A28,Th17;
  end;
end;

begin :: Example

theorem
  for s being State of SCM+FSA, a,b,c being read-write Int-Location st a
<> b & a <> c & b <> c & s.a >= 0
 holds IExec(Times(a,Macro AddTo(b,c)),P,s).b =
  s.b + s.c * s.a
proof
  let s be State of SCM+FSA;
  let a,b,c be read-write Int-Location;
  set I2 = Times(a,Macro AddTo(b,c));
  defpred P[Nat] means for s being State of SCM+FSA st s.a = $1
  holds IExec(Times(a,Macro AddTo(b,c)),P,s).b = s.b + s.c * s.a;
  reconsider I = Macro AddTo(b,c) as good parahalting Program of SCM+FSA by
Th99,SCMFSA7B:13;
  set D = Data-Locations SCM+FSA;
  assume that
A1: a <> b and
A2: a <> c and
A3: b <> c;
A4: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A5: P[k];
    let s be State of SCM+FSA;
    assume
A6: s.a = k + 1;
A7: I does not destroy a by A1,Th77,SCMFSA7B:13;
    then
A8: DataPart IExec(Times(a,I),P,s)
 = DataPart IExec(Times(a,I),P,IExec(I ';' SubFrom(a,intloc 0),P,s))
  by A6,Th124;
A9: IExec(I ';' SubFrom(a,intloc 0),P,s).c
     = Exec(SubFrom(a,intloc 0),IExec(I,P,s)).c by SCMFSA6C:7
      .= IExec(I,P,s).c by A2,SCMFSA_2:91
      .= (NPP IExec(I,P,s)).c by SCMFSA6C:13
      .= (NPP Exec(AddTo(b,c),Initialized s)).c by SCMFSA6C:6
      .= Exec(AddTo(b,c),Initialized s).c by SCMFSA6C:13
      .= (Initialized s).c by A3,SCMFSA_2:90
      .= s.c by SCMFSA6C:3;
A10: IExec(I ';' SubFrom(a,intloc 0),P,s).b
      = Exec(SubFrom(a,intloc 0),IExec(I,P,s)).b by SCMFSA6C:7
      .= IExec(I,P,s).b by A1,SCMFSA_2:91
      .= (NPP IExec(I,P,s)).b by SCMFSA6C:13
      .= (NPP Exec(AddTo(b,c),Initialized s)).b by SCMFSA6C:6
      .= Exec(AddTo(b,c),Initialized s).b by SCMFSA6C:13
      .= (Initialized s).b + (Initialized s).c by SCMFSA_2:90
      .= (Initialized s).b + s.c by SCMFSA6C:3
      .= s.b + s.c by SCMFSA6C:3;
    IExec(I ';' SubFrom(a,intloc 0),P,s).a = s.a - 1 by A6,A7,Th124;
    then IExec(Times(a,I),P,IExec(I ';' SubFrom(a,intloc 0),P,s)).b
     = s.b + s.c + s.c * (s.a - 1) by A5,A6,A10,A9
      .= s.b + s.c * s.a;
    hence thesis by A8,SCMFSA6A:38;
  end;
  assume s.a >= 0;
  then reconsider sa = s.a as Element of NAT by INT_1:16;
A11: P[0]
  proof
    let s be State of SCM+FSA;
    set s0 = Initialized s;
A12: s0.intloc 0 = 1 by SCMFSA6C:3;
    assume
A13: s.a = 0;
    then s0.a = 0 by SCMFSA6C:3;
    then
A14: DataPart IExec(Times(a,I),P,s0) = DataPart s0 by A12,Th123;
    thus IExec(I2,P,s).b = IExec(I2,P,s0).b by Th17
      .= s0.b by A14,SCMFSA6A:38
      .= s.b + s.c * s.a by A13,SCMFSA6C:3;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A11,A4);
  then P[sa];
  hence thesis;
end;

