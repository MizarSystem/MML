:: The {\bf loop} and {\bf Times} Macroinstruction for {\SCMFSA}
::  by Noriko Asamoto
::
:: Received October 29, 1997
:: Copyright (c) 1997 Association of Mizar Users

environ

 vocabularies AMI_1, SCMFSA_2, BOOLE, SCMFSA8A, SCMFSA6A, CAT_1, FUNCT_4,
      AMI_3, FUNCT_1, RELAT_1, CARD_1, AMI_5, UNIALG_2, SCMFSA7B, SCM_1,
      FUNCT_7, RELOC, ARYTM_1, SCMFSA6C, SCMFSA6B, SF_MASTR, SCMFSA_4,
      FUNCOP_1, SCMFSA8B, AMI_2, SCMFSA8C, CARD_3, ARYTM, AMISTD_2, SCMNORM;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, FUNCOP_1, RELAT_1, FUNCT_1, FUNCT_4, FUNCT_7, CARD_3,
      STRUCT_0, AMI_1,
      SCMNORM, SCMFSA_2, SCMFSA_4, SCMFSA_5, SF_MASTR, SCMFSA6A, SCMFSA6B,
      SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8B, BINARITH, XXREAL_0;
 constructors PARTFUN1, DOMAIN_1, XXREAL_0, REAL_1, NAT_1, SCMFSA_5, SCMFSA6A,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMNORM, SCMFSA_4,
      AFINSQ_1;
 registrations SETFAM_1, FUNCT_1, RELSET_1, FUNCOP_1, FRAENKEL, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, AMI_1, SCMFSA_2,
      SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, ORDINAL1,
      XBOOLE_0, SCMNORM, FINSET_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, AMI_1, SCMFSA_2, SCMFSA8A, SCMFSA6A, SCMNORM;
 theorems FUNCT_4, SCMFSA_4, SCMFSA6A, SCMFSA8B, AMI_1, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SF_MASTR, NAT_1, SCMFSA6B, GRFUNC_1, SCMFSA_2, SCMFSA_5,
      FUNCT_1, FUNCT_7, REAL_1, TARSKI, ENUMSET1, FUNCOP_1, RELAT_1, PRE_CIRC,
      SCMFSA_3, BINARITH, INT_1, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1,
      XXREAL_0, VALUED_1, SCMNORM, AFINSQ_1, CARD_3;
 schemes NAT_1;

begin :: Preliminaries

reserve m for Element of NAT;

canceled;

theorem Th2: ::T4425 ** n.t
  for s being State of SCM+FSA,P being initial FinPartState of SCM+FSA
  st P is_pseudo-closed_on s for k being Element of NAT st
  (for n being Element of NAT st n <= k holds
  IC  Computation( (s +* (P +* Start-At insloc 0)),n) in dom P)
  holds k < pseudo-LifeSpan(s,P)
proof
  let s be State of SCM+FSA;
  let P be initial FinPartState of SCM+FSA;
  assume
A1: P is_pseudo-closed_on s;
  let k be Element of NAT;
  assume
A2: for n being Element of NAT st n <= k holds
  IC  Computation( (s +* (P +* Start-At insloc 0)),n) in dom P;
  IC  Computation( (s +* (P +* Start-At insloc 0)),pseudo-LifeSpan(s,P)) =
  insloc card ProgramPart P by A1,SCMFSA8A:def 5;
  then
A3: not IC  Computation( (s +* (P +* Start-At insloc 0)), pseudo-LifeSpan(s
  ,P)) in dom [ProgramPart P] by SCMFSA6A:15;
  assume pseudo-LifeSpan(s,P) <= k;
  hence contradiction by A2,A3,AMI_1:106;
end;

canceled 5;

theorem Th8:
  for i being Instruction of SCM+FSA holds IncAddr(i,0) = i
proof
  let i be Instruction of SCM+FSA;
A1: InsCode i <= 11 + 1 by SCMFSA_2:35;
A2: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A3: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
  per cases by A1,A2,A3,NAT_1:8,33;
  suppose InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:122;
    hence IncAddr(i,0) = i by SCMFSA_4:8;
  end;
  suppose InsCode i = 1;
    then ex a,b being Int-Location st i = a:=b by SCMFSA_2:54;
    hence IncAddr(i,0) = i by SCMFSA_4:9;
  end;
  suppose InsCode i = 2;
    then ex a,b being Int-Location st i = AddTo(a,b) by SCMFSA_2:55;
    hence IncAddr(i,0) = i by SCMFSA_4:10;
  end;
  suppose InsCode i = 3;
    then ex a,b being Int-Location st i = SubFrom(a,b) by SCMFSA_2:56;
    hence IncAddr(i,0) = i by SCMFSA_4:11;
  end;
  suppose InsCode i = 4;
    then ex a,b being Int-Location st i = MultBy(a,b) by SCMFSA_2:57;
    hence IncAddr(i,0) = i by SCMFSA_4:12;
  end;
  suppose InsCode i = 5;
    then ex a,b being Int-Location st i = Divide(a,b) by SCMFSA_2:58;
    hence IncAddr(i,0) = i by SCMFSA_4:13;
  end;
  suppose InsCode i = 6;
    then consider l being Instruction-Location of SCM+FSA such that
A4: i = goto l by SCMFSA_2:59;
    thus IncAddr(i,0) = goto (l + 0) by A4,SCMFSA_4:14
      .= i by A4;
  end;
  suppose InsCode i = 7;
    then consider l being Instruction-Location of SCM+FSA,a being Int-Location
    such that
A5: i = a =0_goto l by SCMFSA_2:60;
    thus IncAddr(i,0) = a =0_goto (l + 0) by A5,SCMFSA_4:15
      .= i by A5;
  end;
  suppose InsCode i = 8;
    then consider l being Instruction-Location of SCM+FSA,a being Int-Location
    such that
A6: i = a >0_goto l by SCMFSA_2:61;
    thus IncAddr(i,0) = a >0_goto (l + 0) by A6,SCMFSA_4:16
      .= i by A6;
  end;
  suppose InsCode i = 9;
    then ex a,b being Int-Location,f being FinSeq-Location
    st i = b:=(f,a) by SCMFSA_2:62;
    hence IncAddr(i,0) = i by SCMFSA_4:17;
  end;
  suppose InsCode i = 10;
    then ex a,b being Int-Location,f being FinSeq-Location
    st i = (f,a):=b by SCMFSA_2:63;
    hence IncAddr(i,0) = i by SCMFSA_4:18;
  end;
  suppose InsCode i = 11;
    then ex a being Int-Location,f being FinSeq-Location
    st i = a:=len f by SCMFSA_2:64;
    hence IncAddr(i,0) = i by SCMFSA_4:19;
  end;
  suppose InsCode i = 12;
    then ex a being Int-Location,f being FinSeq-Location
    st i = f:=<0,...,0>a by SCMFSA_2:65;
    hence IncAddr(i,0) = i by SCMFSA_4:20;
  end;
end;

theorem Th9:
  for P being preProgram of SCM+FSA holds
  ProgramPart Relocated(P,0) = P
proof
  let P be preProgram of SCM+FSA;
  now
    let x be set;
    hereby
      assume
A1:   x in dom P;
      dom P c= NAT by AMI_1:def 40;
      then reconsider l = x as Instruction-Location of SCM+FSA
      by A1,AMI_1:def 4;
  reconsider n = l as Element of NAT by ORDINAL1:def 13;
A2:   l = insloc n;
      thus x in {m: m in dom P} by A1,A2;
    end;
    assume x in {m: m in dom P};
    then consider m being Element of NAT such that
A3: x =  m &  m in dom P;
    thus x in dom P by A3;
  end;
  then
A4: dom P = {m: m in dom P} by TARSKI:2;
A5: dom ProgramPart P = dom P by AMI_1:105;
  now
    let x be set;
A6: dom ProgramPart Relocated(P,0) = {m + 0: m in dom P}
    by A5,SCMFSA_5:3;
    hereby
      assume x in dom ProgramPart Relocated(P,0);
      then consider n be Element of NAT such that
A7:   x = n + 0 & n in dom P by A6;
      thus x in { m: m in dom P} by A7;
    end;
    assume x in {m: m in dom P};
    then consider m being Element of NAT such that
A8: x = m & m in dom P;
    x = insloc (m + 0) & insloc m in dom P by A8;
    hence x in dom ProgramPart Relocated(P,0) by A6;
  end;
  then
A9: dom ProgramPart Relocated(P,0) = {m:m in dom P} by TARSKI:2;
  now
    let x be set;
    assume x in {m:m in dom P};
    then consider n being Element of NAT such that
A10: x = n and
A11: n in dom P;
A12: insloc n in dom ProgramPart P by A11,AMI_1:105;
    dom Shift(ProgramPart P,0) = {m + 0: m in
    dom ProgramPart P} by VALUED_1:def 12;
    then
A13: insloc (n + 0) in dom Shift(ProgramPart P,0) by A5,A11;
    then
A14: pi([Shift(ProgramPart P,0)],n + 0)
    = Shift(ProgramPart P,0).insloc (n + 0) by AMI_1:def 47
      .= (ProgramPart P).insloc n by A12,VALUED_1:def 12
      .= P.insloc n by AMI_1:105;
    then consider i being Instruction of SCM+FSA such that
A15: i = P.insloc n;
    thus (ProgramPart Relocated(P,0)).x
    = IncAddr([Shift(ProgramPart P,0)],0).insloc (n + 0) by A10,SCMFSA_5:2
      .= IncAddr(i,0) by A13,A14,A15,SCMFSA_4:def 6
      .= P.x by A10,A15,Th8;
  end;
  hence ProgramPart Relocated(P,0) = P by A4,A9,FUNCT_1:9;
end;

canceled 2;

theorem Th12:
  for P,Q being FinPartState of SCM+FSA, k being Element of NAT st P c= Q holds
  ProgramPart Relocated(P,k) c= ProgramPart Relocated(Q,k)
proof
  let P,Q be FinPartState of SCM+FSA;
  let k be Element of NAT;
  assume
A1: P c= Q;
  set rP = Relocated(P,k);
  set rQ = Relocated(Q,k);
A2: dom ProgramPart rP = {m + k: m in dom ProgramPart P}
  by SCMFSA_5:3;
A3: ProgramPart rP = IncAddr([Shift(ProgramPart P,k)],k) by SCMFSA_5:2;
A4: ProgramPart rQ = IncAddr([Shift(ProgramPart Q,k)],k) by SCMFSA_5:2;
A5: ProgramPart P c= ProgramPart Q by A1,RELAT_1:105;
  then
A6: Shift(ProgramPart P,k) c= Shift(ProgramPart Q,k) by VALUED_1:21;
  then
A7: dom Shift(ProgramPart P,k) c= dom Shift(ProgramPart Q,k) by GRFUNC_1 :8;
A8: dom ProgramPart P c= dom ProgramPart Q by A5,GRFUNC_1:8;
  now
    let x be set;
    assume x in dom ProgramPart rP;
    then x in dom Shift(ProgramPart P,k) by A3,SCMFSA_4:def 6;
    then x in dom Shift(ProgramPart Q,k) by A7;
    hence x in dom ProgramPart rQ by A4,SCMFSA_4:def 6;
  end;
  then
A9: dom ProgramPart rP c= dom ProgramPart rQ by TARSKI:def 3;
A10: dom Shift(ProgramPart P,k) = {m + k: m in
  dom ProgramPart P} by VALUED_1:def 12;
A11: dom Shift(ProgramPart Q,k) = {m + k: m in
  dom ProgramPart Q} by VALUED_1:def 12;
  now
    let x be set;
    assume x in dom ProgramPart rP;
    then consider m1 being Element of NAT such that
A12: x = m1 + k & m1 in dom ProgramPart P by A2;
A13: insloc (m1 + k) in dom Shift(ProgramPart P,k) &
    insloc (m1 + k) in dom Shift(ProgramPart Q,k) by A8,A10,A11,A12;
    then
A14: pi([Shift(ProgramPart P,k)],m1 + k)
    = Shift(ProgramPart P,k).insloc (m1 + k) by AMI_1:def 47
      .= Shift(ProgramPart Q,k).insloc (m1 + k) by A6,A13,GRFUNC_1:8
      .= pi([Shift(ProgramPart Q,k)],m1 + k) by A13,AMI_1:def 47;
    thus (ProgramPart rP).x
    = IncAddr([Shift(ProgramPart P,k)],k).insloc (m1 + k) by A12,SCMFSA_5:2
      .= IncAddr(pi([Shift(ProgramPart Q,k)],m1 + k),k) by A13,A14,
    SCMFSA_4:def 6
      .= IncAddr([Shift(ProgramPart Q,k)],k).insloc (m1 + k) by A13,
    SCMFSA_4:def 6
      .= (ProgramPart rQ).x by A12,SCMFSA_5:2;
  end;
  hence ProgramPart rP c= ProgramPart rQ by A9,GRFUNC_1:8;
end;

theorem Th13:
  for I,J being Program of SCM+FSA, k being Element of NAT st
  card I <= k & k < card I + card J holds
  for i being Instruction of SCM+FSA st i = J.insloc (k -' card I) holds
  (I ';' J).insloc k = IncAddr(i,card I)
proof
  let I,J be Program of SCM+FSA;
  let k be Element of NAT;
  assume
A1: card I <= k;
  assume k < card I + card J;
  then
A2: k + 0 < card J + card I;
  let i be Instruction of SCM+FSA;
  assume
A3: i = J.insloc (k -' card I);
  k -' card I = k - card I by A1,BINARITH:50;
  then
A5: k -' card I < card J - 0 by A2,XREAL_1:23;
  ProgramPart J = J by AMI_1:105;
  then
A6: insloc (k -' card I) in dom ProgramPart J by A5,SCMFSA6A:15;
A7: k -' card I + card I = k - card I + card I by A1,BINARITH:50
    .= k;
  insloc k in {m + card I: m in dom ProgramPart J} by A6,A7;
  then
A9: insloc k in dom ProgramPart Relocated(J, card I) by SCMFSA_5:3;
  hence (I ';' J).insloc k
  = (ProgramPart Relocated(J,card I)).insloc k by FUNCT_4:14
    .= Relocated(J,card I).insloc k by A9,SCMFSA6A:64
    .= IncAddr(i,card I) by A3,A6,A7,SCMFSA_5:7;
end;

theorem Th14:
  for s being State of SCM+FSA st s.intloc 0 = 1 & IC s = insloc 0 holds
  Initialize s = s
proof
  let s be State of SCM+FSA;
  assume
A1: s.intloc 0 = 1;
  assume
A2: IC s = insloc 0;
A3: intloc 0 in dom s & IC SCM+FSA in dom s by AMI_1:94,SCMFSA_2:66;
  thus Initialize s
  = s +* (intloc 0 .--> 1) +* Start-At insloc 0 by SCMFSA6C:def 3
    .= s +* (IC SCM+FSA .--> insloc 0) by A1,A3,FUNCT_7:111
    .= s by A2,A3,FUNCT_7:111;
end;

theorem Th15:
  for s being State of SCM+FSA holds Initialize Initialize s = Initialize s
proof
  let s be State of SCM+FSA;
  (Initialize s).intloc 0 = 1 & IC Initialize s = insloc 0 by SCMFSA6C:3;
  hence Initialize Initialize s = Initialize s by Th14;
end;

theorem Th16:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  s +* (Initialized I +* Start-At insloc 0) =
  Initialize s +* (I +* Start-At insloc 0)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  Start-At insloc 0 c= Initialized I by SCMFSA6B:4;
  hence s +* (Initialized I +* Start-At insloc 0)
  = s +* Initialized I by FUNCT_4:79
    .= Initialize s +* (I +* Start-At insloc 0) by SCMFSA8A:13;
end;

theorem Th17:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  IExec(I,s) = IExec(I,Initialize s)
proof
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  dom s = D \/ {IC SCM+FSA} \/ A by SCMFSA6A:34;
  then
A1: A c= dom s by XBOOLE_1:7;
  dom Initialize s = D \/ {IC SCM+FSA} \/ A by SCMFSA6A:34;
  then
A2: A c= dom Initialize s by XBOOLE_1:7;
  for x be set st x in A holds s.x = (Initialize s).x
  proof
    let x be set;
    assume x in A;
    then reconsider x as Instruction-Location of SCM+FSA by AMI_1:def 4;
    s.x = (Initialize s).x by SCMFSA6C:3;
    hence thesis;
  end;
  then
A3: s | A = (Initialize s) | A by A1,A2,FUNCT_1:165;
  thus IExec(I,s) = Result (s +* Initialized I) +* s | A by SCMFSA6B:def 1
    .= Result (Initialize s +* Initialized I) +* s | A by SCMFSA8A:8
    .= IExec(I,Initialize s) by A3,SCMFSA6B:def 1;
end;

theorem Th18:
  for s being State of SCM+FSA, I being Program of SCM+FSA
  st s.intloc 0 = 1 holds s +* (I +* Start-At insloc 0) = s +* Initialized I
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: s.intloc 0 = 1;
  intloc 0 in dom s by SCMFSA_2:66;
  then
A2: s = s +* (intloc 0 .--> 1) by A1,FUNCT_7:111;
  thus s +* Initialized I
  = Initialize s +* (I +* Start-At insloc 0) by SCMFSA8A:13
    .= Initialize s +* I +* Start-At insloc 0 by FUNCT_4:15
    .= Initialize s +* Start-At insloc 0 +* I by SCMFSA6B:14
    .= s +* Start-At insloc 0 +* Start-At insloc 0 +* I by A2,SCMFSA6C:def 3
    .= s +* (Start-At insloc 0 +* Start-At insloc 0) +* I by FUNCT_4:15
    .= s +* I +* Start-At insloc 0 by SCMFSA6B:14
    .= s +* (I +* Start-At insloc 0) by FUNCT_4:15;
end;

theorem Th19:
  for I being Program of SCM+FSA holds I +* Start-At insloc 0 c= Initialized I
proof
  let I be Program of SCM+FSA;
  I c= Initialized I & Start-At insloc 0 c= Initialized I
  by SCMFSA6A:26,SCMFSA6B:4;
  hence I +* Start-At insloc 0 c= Initialized I by FUNCT_4:92;
end;

theorem Th20:
  for l being Instruction-Location of SCM+FSA, I being Program of SCM+FSA holds
  l in dom I iff l in dom Initialized I
proof
  let l be Instruction-Location of SCM+FSA;
  let I be Program of SCM+FSA;
A1: l in NAT by AMI_1:def 4;
A2: (Initialized I) | NAT = I by SCMFSA6A:33;
A3: dom ((Initialized I) | NAT) c= dom Initialized I by RELAT_1:89;
A4: dom ((Initialized I) | NAT) = dom Initialized I /\ NAT by RELAT_1:90;
  thus l in dom I implies l in dom Initialized I by A2,A3;
  assume l in dom Initialized I;
  hence l in dom I by A1,A2,A4,XBOOLE_0:def 3;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  Initialized I is_closed_on s iff I is_closed_on Initialize s
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  hereby
    assume
A1: Initialized I is_closed_on s;
    now
      let k be Element of NAT;
      IC  Computation( (s +* (Initialized I +* Start-At insloc 0)),k) in
      dom Initialized I by A1,SCMFSA7B:def 7;
      then IC  Computation( (Initialize s +* (I +* Start-At insloc 0)),k) in
      dom Initialized I by Th16;
      hence IC  Computation( (Initialize s +* (I +* Start-At insloc 0)),k) in
      dom I by Th20;
    end;
    hence I is_closed_on Initialize s by SCMFSA7B:def 7;
  end;
  assume
A2: I is_closed_on Initialize s;
  now
    let k be Element of NAT;
    IC  Computation( (Initialize s +* (I +* Start-At insloc 0)),k) in
    dom I by A2,SCMFSA7B:def 7;
    then IC  Computation( (Initialize s +* (I +* Start-At insloc 0)),k) in
    dom Initialized I by Th20;
    hence IC  Computation( (s +* (Initialized I +* Start-At insloc 0)),k) in
    dom Initialized I by Th16;
  end;
  hence Initialized I is_closed_on s by SCMFSA7B:def 7;
end;

theorem Th22:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  Initialized I is_halting_on s iff I is_halting_on Initialize s
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  hereby
    assume Initialized I is_halting_on s;
    then s +* (Initialized I +* Start-At insloc 0) is halting
    by SCMFSA7B:def 8;
    then Initialize s +* (I +* Start-At insloc 0) is halting by Th16;
    hence I is_halting_on Initialize s by SCMFSA7B:def 8;
  end;
  assume I is_halting_on Initialize s;
  then Initialize s +* (I +* Start-At insloc 0) is halting by SCMFSA7B:def 8;
  then s +* (Initialized I +* Start-At insloc 0) is halting by Th16;
  hence Initialized I is_halting_on s by SCMFSA7B:def 8;
end;

theorem
  for I being Program of SCM+FSA holds
  (for s being State of SCM+FSA holds I is_halting_on Initialize s) implies
  Initialized I is halting
proof
  let I be Program of SCM+FSA;
  assume
A1: for s being State of SCM+FSA holds I is_halting_on Initialize s;
  now
    let s be State of SCM+FSA;
    assume
A2: Initialized I c= s;
    I is_halting_on Initialize s by A1;
    then Initialize s +* (I +* Start-At insloc 0) is halting
    by SCMFSA7B:def 8;
    then s +* Initialized I is halting by SCMFSA8A:13;
    hence s is halting by A2,FUNCT_4:79;
  end;
  hence Initialized I is halting by AMI_1:def 26;
end;

theorem Th24:
  for I being Program of SCM+FSA holds
  (for s being State of SCM+FSA holds Initialized I is_halting_on s) implies
  Initialized I is halting
proof
  let I be Program of SCM+FSA;
  assume
A1: for s being State of SCM+FSA holds Initialized I is_halting_on s;
  now
    let s be State of SCM+FSA;
    assume
A2: Initialized I c= s;
    Initialized I is_halting_on s by A1;
    then
A3: s +* (Initialized I +* Start-At insloc 0) is halting by SCMFSA7B: def 8;
    Start-At insloc 0 c= Initialized I by SCMFSA6B:4;
    then s +* (Initialized I +* Start-At insloc 0)
    = s +* Initialized I by FUNCT_4:79;
    hence s is halting by A2,A3,FUNCT_4:79;
  end;
  hence Initialized I is halting by AMI_1:def 26;
end;

theorem
  for I being Program of SCM+FSA holds
  ProgramPart Initialized I = I by SCMFSA6A:33;

theorem Th26:
  for s being State of SCM+FSA, I being Program of SCM+FSA,
  l being Instruction-Location of SCM+FSA, x being set holds
  x in dom I implies I.x = (s +* (I +* Start-At l)).x
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let l be Instruction-Location of SCM+FSA;
  let x be set;
  assume
A1: x in dom I;
  dom I c= NAT by AMI_1:def 40;
  then reconsider y = x as Instruction-Location of SCM+FSA by A1,AMI_1:def 4;
A2: not y in dom Start-At l by AMI_1:137;
  x in dom (I +* Start-At l) by A1,FUNCT_4:13;
  hence (s +* (I +* Start-At l)).x = (I +* Start-At l).x by FUNCT_4:14
    .= I.x by A2,FUNCT_4:12;
end;

theorem Th27:
  for s being State of SCM+FSA st s.intloc 0 = 1 holds
  DataPart Initialize s = DataPart s
proof
  let s be State of SCM+FSA;
  assume
A1: s.intloc 0 = 1;
A2: intloc 0 in dom s & IC SCM+FSA in dom s by AMI_1:94,SCMFSA_2:66;
  Initialize s = s +* (intloc 0 .--> 1) +* Start-At insloc 0 by SCMFSA6C:def 3
    .= s +* Start-At insloc 0 by A1,A2,FUNCT_7:111;
  hence thesis by SCMFSA8A:10;
end;

theorem Th28:
  for s being State of SCM+FSA, I being Program of SCM+FSA,
  a being Int-Location, l being Instruction-Location of SCM+FSA holds
  (s +* (I +* Start-At l)).a = s.a
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  let l be Instruction-Location of SCM+FSA;
  a in dom s & not a in dom (I +* Start-At l) by SCMFSA6B:12,SCMFSA_2:66;
  hence (s +* (I +* Start-At l)).a = s.a by FUNCT_4:12;
end;

theorem
  for I being preProgram of SCM+FSA,
  l being Instruction-Location of SCM+FSA holds
  IC SCM+FSA in dom (I +* Start-At l)
proof
  let I be preProgram of SCM+FSA;
  let l be Instruction-Location of SCM+FSA;
  dom Start-At l = {IC SCM+FSA} by FUNCOP_1:19;
  then IC SCM+FSA in dom Start-At l by TARSKI:def 1;
  hence IC SCM+FSA in dom (I +* Start-At l) by FUNCT_4:13;
end;

theorem
  for I being preProgram of SCM+FSA,
  l being Instruction-Location of SCM+FSA holds
  (I +* Start-At l).IC SCM+FSA = l
proof
  let I be preProgram of SCM+FSA;
  let l be Instruction-Location of SCM+FSA;
  dom Start-At l = {IC SCM+FSA} by FUNCOP_1:19;
  then
A1: IC SCM+FSA in dom Start-At l by TARSKI:def 1;
  (Start-At l).IC SCM+FSA = l by FUNCOP_1:87;
  hence (I +* Start-At l).IC SCM+FSA = l by A1,FUNCT_4:14;
end;

theorem Th31:
  for s being State of SCM+FSA, P being FinPartState of SCM+FSA,
  l being Instruction-Location of SCM+FSA holds
  IC (s +* (P +* Start-At l)) = l
proof
  let s be State of SCM+FSA;
  let I be FinPartState of SCM+FSA;
  let l be Instruction-Location of SCM+FSA;
  thus IC (s +* (I +* Start-At l)) = IC (s +* I +* Start-At l) by FUNCT_4:15
    .= l by AMI_1:111;
end;

theorem Th32:
  for s being State of SCM+FSA, i being Instruction of SCM+FSA st
  InsCode i in {0,6,7,8} holds
  DataPart Exec(i,s) = DataPart s
proof
  let s be State of SCM+FSA;
  let i be Instruction of SCM+FSA;
  assume
A1: InsCode i in {0,6,7,8};
  now
    let a be Int-Location;
    let f be FinSeq-Location;
    per cases by A1,ENUMSET1:def 2;
    suppose InsCode i = 0;
      then i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s).a = s.a & Exec(i,s).f = s.f by AMI_1:def 8;
    end;
    suppose InsCode i = 6;
      then consider lb being Instruction-Location of SCM+FSA such that
A2:   i = goto lb by SCMFSA_2:59;
      thus Exec(i,s).a = s.a & Exec(i,s).f = s.f by A2,SCMFSA_2:95;
    end;
    suppose InsCode i = 7;
      then consider lb being Instruction-Location of SCM+FSA, b being
      Int-Location such that
A3:   i = b=0_goto lb by SCMFSA_2:60;
      thus Exec(i,s).a = s.a & Exec(i,s).f = s.f by A3,SCMFSA_2:96;
    end;
    suppose InsCode i = 8;
      then consider lb being Instruction-Location of SCM+FSA, b being
      Int-Location such that
A4:   i = b>0_goto lb by SCMFSA_2:61;
      thus Exec(i,s).a = s.a & Exec(i,s).f = s.f by A4,SCMFSA_2:97;
    end;
  end;
  hence thesis by SCMFSA6A:38;
end;

theorem Th33:
  for s1,s2 being State of SCM+FSA st s1.intloc 0 = s2.intloc 0 &
  ((for a being read-write Int-Location holds s1.a = s2.a) &
  for f being FinSeq-Location holds s1.f = s2.f) holds
  DataPart s1 = DataPart s2
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s1,s2 be State of SCM+FSA;
  assume
A1: s1.intloc 0 = s2.intloc 0;
  assume
A2: for a being read-write Int-Location holds s1.a = s2.a;
  assume
A3: for f being FinSeq-Location holds s1.f = s2.f;
A4: dom DataPart s1 = dom s1 /\ D by RELAT_1:90,SCMFSA_2:127
    .= (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} \/
  NAT) /\ D by SCMFSA6A:34
    .= dom s2 /\ D by SCMFSA6A:34
    .= dom DataPart s2 by RELAT_1:90,SCMFSA_2:127;
  now
    let x be set;
    assume
A5: x in dom DataPart s1;
    then
A6: x in dom s1 /\ D by RELAT_1:90,SCMFSA_2:127;
    then
A7: x in dom s1 & x in D by XBOOLE_0:def 3;
    per cases by A7,SCMFSA6A:35;
    suppose
A8:   x is Int-Location;
      hereby per cases;
        suppose
A9:       x is read-write Int-Location;
          thus (DataPart s1).x = s1.x by A5,FUNCT_1:70
            .= s2.x by A2,A9
            .= (DataPart s2).x by A4,A5,FUNCT_1:70;
        end;
        suppose
A10:      not x is read-write Int-Location;
          reconsider a = x as Int-Location by A8;
          a = intloc 0 by A10,SF_MASTR:def 5;
          hence (DataPart s1).x = s2.a by A1,A5,FUNCT_1:70
            .= (DataPart s2).x by A4,A5,FUNCT_1:70;
        end;
      end;
    end;
    suppose
A11:  x is FinSeq-Location;
      thus (DataPart s1).x = s1.x by A5,FUNCT_1:70
        .= s2.x by A3,A11
        .= (DataPart s2).x by A4,A5,FUNCT_1:70;
    end;
    suppose
A12:  x = IC SCM+FSA;
      assume not (DataPart s1).x = (DataPart s2).x;
      thus contradiction by A6,A12,SCMFSA6A:37,XBOOLE_0:def 3;
    end;
    suppose
A13:  x is Instruction-Location of SCM+FSA;
      assume not (DataPart s1).x = (DataPart s2).x;
      thus contradiction by A7,A13,SCMFSA6A:37;
    end;
  end;
  then DataPart s1 c= DataPart s2 by A4,GRFUNC_1:8;
  hence DataPart s1 = DataPart s2 by A4,GRFUNC_1:9;
end;

theorem
  for s being State of SCM+FSA,P being preProgram of SCM+FSA
  holds DataPart(s +* P) = DataPart s
proof
  set A = NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let P be preProgram of SCM+FSA;
A1: dom P c= A by AMI_1:def 40;
  A misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  then dom P misses D by A1,XBOOLE_1:63;
  hence thesis by FUNCT_4:76,SCMFSA_2:127;
end;

theorem Th35:
  for s,ss being State of SCM+FSA holds
   DataPart(s +* ss | NAT) = DataPart s
proof
  set A = NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  let s,ss be State of SCM+FSA;
  dom (ss | A) = dom ss /\ A by RELAT_1:90
    .= (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} \/ A) /\
  A by SCMFSA6A:34
    .= A by XBOOLE_1:21;
  then dom (ss | A) misses D by SCMFSA_2:13,14,XBOOLE_1:70;
  hence thesis by FUNCT_4:76,SCMFSA_2:127;
end;

theorem Th36:
  for s being State of SCM+FSA holds (Initialize s) | NAT = s | NAT
proof
  set A = NAT;
  let s be State of SCM+FSA;
A1: Initialize s
  = s +* (intloc 0 .--> 1) +* Start-At insloc 0 by SCMFSA6C:def 3
    .= s +* ((intloc 0 .--> 1) +* Start-At insloc 0) by FUNCT_4:15;
  now
    let x be set;
    assume x in A;
    then reconsider l = x as Instruction-Location of SCM+FSA by AMI_1:def 4;
A2: not l in dom Start-At insloc 0 by AMI_1:137;
    l <> intloc 0 & dom (intloc 0 .--> 1) = {intloc 0}
    by FUNCOP_1:19,SCMFSA_2:84;
    then not x in dom (intloc 0 .--> 1) by TARSKI:def 1;
    hence not x in dom (intloc 0 .--> 1) \/ dom Start-At insloc 0
    by A2,XBOOLE_0:def 2;
  end;
  then dom (intloc 0 .--> 1) \/ dom Start-At insloc 0 misses A by XBOOLE_0:3;
  then dom ((intloc 0 .--> 1) +* Start-At insloc 0) misses A by FUNCT_4:def 1;
  hence thesis by A1,FUNCT_4:94;
end;

theorem Th37:
  for s,ss being State of SCM+FSA, I being Program of SCM+FSA holds
  DataPart(ss +* (s | (NAT))) = DataPart ss
proof
  set A = NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  let s,ss be State of SCM+FSA;
  let I be Program of SCM+FSA;
  dom (s | A) = A & A misses D by SCMFSA8A:3,SCMFSA_2:13,14,XBOOLE_1:70;
  hence thesis by FUNCT_4:94,SCMFSA_2:127;
end;

theorem Th38:
  for s being State of SCM+FSA holds
  IExec(Stop SCM+FSA,s) = Initialize s +* Start-At insloc 0
proof
  set A = NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  set s1 = Initialize s +* (Stop SCM+FSA +* Start-At insloc 0);
A1: s +* Initialized Stop SCM+FSA = s1 by SCMFSA8A:13;
  then CurInstr s1 = s1.insloc 0 by FUNCT_4:26,SCMFSA6B:34
    .= (Stop SCM+FSA).insloc 0 by Th26,SCMFSA8A:15;
  then
A2: CurInstr s1 = halt SCM+FSA & s1 =  Computation( s1,0)
  by AMI_1:13,SCMFSA8A:16;
  then
A3: s1 is halting by AMI_1:def 20;
A4: IExec(Stop SCM+FSA,s) = Result (s +* Initialized Stop SCM+FSA) +* s | A
  by SCMFSA6B:def 1;
  then
A5: IExec(Stop SCM+FSA,s) = s1 +* s | A by A1,A2,A3,AMI_1:def 22;
  then
A6: DataPart IExec(Stop SCM+FSA,s) = DataPart s1 by Th37
    .= DataPart Initialize s by SCMFSA8A:11;
  hereby
A7: dom IExec(Stop SCM+FSA,s) = the carrier of SCM+FSA by AMI_1:79
      .= dom (Initialize s +* Start-At insloc 0) by AMI_1:79;
A8: dom Start-At insloc 0 = {IC SCM+FSA} by FUNCOP_1:19;
    now
      let x be set;
      assume
A9:   x in dom IExec(Stop SCM+FSA,s);
      per cases by A9,SCMFSA6A:35;
      suppose
A10:    x is Int-Location;
        then
A11:    IExec(Stop SCM+FSA,s).x = (Initialize s).x by A6,SCMFSA6A: 38;
        x <> IC SCM+FSA by A10,SCMFSA_2:81;
        then not x in dom Start-At insloc 0 by A8,TARSKI:def 1;
        hence IExec(Stop SCM+FSA,s).x
        = (Initialize s +* Start-At insloc 0).x by A11,FUNCT_4:12;
      end;
      suppose
A12:    x is FinSeq-Location;
        then
A13:    IExec(Stop SCM+FSA,s).x = (Initialize s).x by A6,SCMFSA6A: 38;
        x <> IC SCM+FSA by A12,SCMFSA_2:82;
        then not x in dom Start-At insloc 0 by A8,TARSKI:def 1;
        hence IExec(Stop SCM+FSA,s).x
        = (Initialize s +* Start-At insloc 0).x by A13,FUNCT_4:12;
      end;
      suppose
A14:    x = IC SCM+FSA;
        then x in {IC SCM+FSA} by TARSKI:def 1;
        then
A15:    x in dom Start-At insloc 0 by FUNCOP_1:19;
        now
          assume
A16:      x in A;
          then reconsider x as Instruction-Location of SCM+FSA by AMI_1:def 4;
          x in A by A16;
          hence contradiction by A14,AMI_1:48;
        end;
        then not x in dom s /\ A by XBOOLE_0:def 3;
        then x in dom s1 & not x in dom (s | A) by A14,RELAT_1:90,SCMFSA8B:1;
        hence IExec(Stop SCM+FSA,s).x = s1.IC SCM+FSA by A5,A14,FUNCT_4:12
          .= (Initialize s +* Stop SCM+FSA +* Start-At insloc 0).IC SCM+FSA
        by FUNCT_4:15
          .= (Start-At insloc 0).IC SCM+FSA by A14,A15,FUNCT_4:14
          .= (Initialize s +* Start-At insloc 0).x by A14,A15,FUNCT_4:14;
      end;
      suppose
A17:    x is Instruction-Location of SCM+FSA;
        IExec(Stop SCM+FSA,s) | A = s | A by A4,CARD_3:99
          .= (Initialize s) | A by Th36;
        then
A18:    IExec(Stop SCM+FSA,s).x = (Initialize s).x by A17,SCMFSA6A :36;
        x <> IC SCM+FSA by A17,AMI_1:48;
        then not x in dom Start-At insloc 0 by A8,TARSKI:def 1;
        hence IExec(Stop SCM+FSA,s).x = (Initialize s +* Start-At insloc 0).x
        by A18,FUNCT_4:12;
      end;
    end;
    hence thesis by A7,FUNCT_1:9;
  end;
end;

theorem Th39:
  for s being State of SCM+FSA,I being Program of SCM+FSA
  st I is_closed_on s holds insloc 0 in dom I
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: I is_closed_on s;
  reconsider n = IC  Computation( (s +* (I +* Start-At insloc 0)),0)
  as Element of NAT by ORDINAL1:def 13;
A3: insloc n in dom I by A1,SCMFSA7B:def 7;
  per cases;
  suppose n = 0;
    hence insloc 0 in dom I by A1,SCMFSA7B:def 7;
  end;
  suppose 0 < n;
    hence insloc 0 in dom I by A3,SCMNORM:def 1;
  end;
end;

theorem
  for s being State of SCM+FSA,I being paraclosed Program of SCM+FSA holds
  insloc 0 in dom I
proof
  let s be State of SCM+FSA;
  let I be paraclosed Program of SCM+FSA;
  I is_closed_on s by SCMFSA7B:24;
  hence insloc 0 in dom I by Th39;
end;

theorem
  for i being Instruction of SCM+FSA holds rng Macro i = {i,halt SCM+FSA}
   by FUNCT_4:67;

theorem Th42:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
  I is_closed_on s1 & I +* Start-At insloc 0 c= s1
  for n being Element of NAT st ProgramPart Relocated(I,n) c= s2 &
  IC s2 = insloc n & DataPart s1 = DataPart s2
   for i being Element of NAT holds
  IC  Computation( s1,i) + n = IC  Computation( s2,i) &
  IncAddr(CurInstr ( Computation( s1,i)),n) = CurInstr ( Computation( s2,i)) &
   DataPart Computation( s1,i) = DataPart Computation( s2,i)
proof
  let s1,s2 be State of SCM+FSA;
  let J be Program of SCM+FSA;
  assume
A1: J is_closed_on s1;
  assume
A2: J +* Start-At insloc 0 c= s1;
  set JAt = J +* Start-At insloc 0;
  let n be Element of NAT;
  assume that
A3: ProgramPart Relocated(J,n) c= s2 and
A4: IC s2 = insloc n and
A5: DataPart s1 = DataPart s2;
  let i be Element of NAT;
  defpred P[Element of NAT] means
   IC Computation(s1,$1) + n = IC Computation(s2,$1) &
  IncAddr(CurInstr (Computation(s1,$1)),n) = CurInstr (Computation(s2,$1)) &
  DataPart Computation(s1,$1) = DataPart Computation(s2,$1);
A6: P[0]
  proof
A7: IC SCM+FSA in dom JAt by SF_MASTR:65;
    insloc 0 in dom J by A1,Th39;
    then insloc 0 + n in dom Relocated(J,n) by SCMFSA_5:4;
    then
A8: insloc (0 + n) in dom ProgramPart Relocated(J,n) by AMI_1:106;
    IC Computation(s1,0) = s1.IC SCM+FSA by AMI_1:13
      .= (JAt).IC SCM+FSA by A2,A7,GRFUNC_1:8
      .= insloc 0 by SF_MASTR:66;
    hence IC Computation(s1,0) + n
      = IC Computation(s2,0) by A4,AMI_1:13;
    dom J misses dom Start-At insloc 0 by SF_MASTR:64;
    then
A9: J c= JAt by FUNCT_4:33;
    then
A10: dom J c= dom JAt by GRFUNC_1:8;
A11: insloc 0 in dom J by A1,Th39;
A12: s1.IC s1 = s1.((JAt).IC SCM+FSA) by A2,A7,GRFUNC_1:8
      .= s1.insloc 0 by SF_MASTR:66
      .= (JAt).insloc 0 by A2,A10,A11,GRFUNC_1:8
      .= J.insloc 0 by A9,A11,GRFUNC_1:8;
    ProgramPart J = J by AMI_1:105;
    then
A13: insloc 0 in dom ProgramPart J by A1,Th39;
    thus IncAddr(CurInstr (Computation(s1,0)),n) = IncAddr(CurInstr s1,n)
     by AMI_1:13
      .= Relocated(J,n).insloc (0 + n) by A12,A13,SCMFSA_5:7
      .= (ProgramPart Relocated(J,n)).insloc n by FUNCT_1:72
      .= CurInstr s2 by A3,A4,A8,GRFUNC_1:8
      .= CurInstr (Computation(s2,0)) by AMI_1:13;
    thus DataPart Computation(s1,0)
    = DataPart s2 by A5,AMI_1:13
      .= DataPart Computation(s2,0) by AMI_1:13;
  end;
A14: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A15: P[k];
A16: Computation(s1,k+1) = Following Computation(s1,k) by AMI_1:14
      .= Exec(CurInstr Computation(s1,k),Computation(s1,k));
A17: Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
      .= Exec(CurInstr Computation(s2,k),Computation(s2,k));
    hence
A18: IC Computation(s1,k+1) + n = IC Computation(s2,k+1)
 by A15,A16,SCMFSA6A:41;
    reconsider j = CurInstr Computation(s1,k+1) as Instruction of SCM+FSA;
    reconsider l = IC Computation(s1,k+1) as Element of NAT by ORDINAL1:def 13;
    dom J misses dom Start-At insloc 0 by SF_MASTR:64;
    then
A19: J c= JAt by FUNCT_4:33;
    then
A20: dom J c= dom JAt by GRFUNC_1:8;
    s1 +* (J +* Start-At insloc 0) = s1 by A2,FUNCT_4:79;
    then
A22: IC Computation(s1,k+1) in dom J by A1,SCMFSA7B:def 7;
    dom ProgramPart J = dom J /\ NAT by FUNCT_1:68;
    then
A23: l in dom ProgramPart J by A22,XBOOLE_0:def 3;
A24: IC Computation(s2,k+1) in NAT by AMI_1:def 4;
A25: j = s1.IC Computation(s1,k+1) by AMI_1:54
      .= (JAt).IC Computation(s1,k+1) by A2,A20,A22,GRFUNC_1:8
      .= J.l by A19,A22,GRFUNC_1:8;
    IC Computation(s2,k+1) in dom Relocated(J,n) by A18,A22,SCMFSA_5:4;
    then IC Computation(s2,k+1) in dom Relocated(J,n) /\ NAT
     by A24,XBOOLE_0:def 3;
    then
A26: IC Computation(s2,k+1) in dom ProgramPart Relocated(J,n) by FUNCT_1:68;
    thus IncAddr(CurInstr Computation(s1,k+1),n)
    = Relocated(J,n).(l + n) by A23,A25,SCMFSA_5:7
      .= (ProgramPart Relocated(J,n)).(IC Computation(s2,k+1))
       by A18,FUNCT_1:72
      .= s2.IC Computation(s2,k+1) by A3,A26,GRFUNC_1:8
      .= CurInstr Computation(s2,k+1) by AMI_1:54;
    thus DataPart Computation(s1,k+1)
    = DataPart Computation(s2,k+1) by A15,A16,A17,SCMFSA6A:41;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A6,A14);
  hence thesis;
end;

theorem Th43:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
  I is_closed_on s1 &
  I +* Start-At insloc 0 c= s1 & I +* Start-At insloc 0 c= s2 &
  DataPart s1 = DataPart s2
   for i being Element of NAT holds
  IC  Computation( s1,i) = IC  Computation( s2,i) &
  CurInstr  Computation( s1,i) = CurInstr  Computation( s2,i) &
   DataPart Computation( s1,i) = DataPart Computation( s2,i)
proof
  let s1,s2 be State of SCM+FSA;
  let J be Program of SCM+FSA;
  assume
A1: J is_closed_on s1 &
  J +* Start-At insloc 0 c= s1 & J +* Start-At insloc 0 c= s2 &
  DataPart s1 = DataPart s2;
  let i be Element of NAT;
A2: IC  Computation( s1,i) + 0 = IC  Computation( s1,i);
A3: s2 = s2 +* (J +* Start-At insloc 0) by A1,FUNCT_4:79
    .= s2 +* J +* Start-At insloc 0 by FUNCT_4:15
    .= s2 +* Start-At insloc 0 +* J by SCMFSA6B:14;
  ProgramPart Relocated(J,0) = J by Th9;
  then
A4: ProgramPart Relocated(J,0) c= s2 by A3,FUNCT_4:26;
A5: IncAddr(CurInstr  Computation( s1,i),0) = CurInstr  Computation( s1,i)
  by Th8;
  IC s2 = IC (s2 +* (J +* Start-At insloc 0)) by A1,FUNCT_4:79
    .= IC (s2 +* J +* Start-At insloc 0) by FUNCT_4:15
    .= insloc 0 by AMI_1:111;
  hence IC  Computation( s1,i) = IC  Computation( s2,i) &
  CurInstr  Computation( s1,i) = CurInstr  Computation( s2,i) &
   DataPart Computation( s1,i) = DataPart Computation( s2,i)
  by A1,A2,A4,A5,Th42;
end;

theorem Th44:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
  I is_closed_on s1 & I is_halting_on s1 &
  I +* Start-At insloc 0 c= s1 & I +* Start-At insloc 0 c= s2 &
  DataPart s1 = DataPart s2 holds LifeSpan s1 = LifeSpan s2
proof
  let s1,s2 be State of SCM+FSA;
  let J be Program of SCM+FSA;
  assume
A1: J is_closed_on s1 & J is_halting_on s1 &
  J +* Start-At insloc 0 c= s1 & J +* Start-At insloc 0 c= s2 &
  DataPart s1 = DataPart s2;
  then s1 = s1 +* (J +* Start-At insloc 0) by FUNCT_4:79;
  then
A2: s1 is halting by A1,SCMFSA7B:def 8;
  then CurInstr  Computation( s1,LifeSpan  s1) = halt SCM+FSA &
  for k being Element of NAT
  st CurInstr  Computation( s1,k) = halt SCM+FSA holds
  LifeSpan s1 <= k by AMI_1:def 46;
  then
A3: CurInstr  Computation( s2,LifeSpan  s1) = halt SCM+FSA by A1,Th43;
  then
A4: s2 is halting by AMI_1:def 20;
  now
    let k be Element of NAT;
    assume CurInstr  Computation( s2,k) = halt SCM+FSA;
    then CurInstr  Computation( s1,k) = halt SCM+FSA by A1,Th43;
    hence LifeSpan s1 <= k by A2,AMI_1:def 46;
  end;
  hence LifeSpan s1 = LifeSpan s2 by A3,A4,AMI_1:def 46;
end;

theorem Th45:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
  s1.intloc 0 = 1 & I is_closed_on s1 & I is_halting_on s1 &
  ((for a being read-write Int-Location holds s1.a = s2.a) &
  for f being FinSeq-Location holds s1.f = s2.f) holds
  DataPart IExec(I,s1) = DataPart IExec(I,s2)
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s11 = s1 +* Initialized I;
  set s21 = s2 +* Initialized I;
  assume
A1: s1.intloc 0 = 1;
  assume
A2: I is_closed_on s1 & I is_halting_on s1;
  assume
A3: for a being read-write Int-Location holds s1.a = s2.a;
  assume
A4: for f being FinSeq-Location holds s1.f = s2.f;
A5: Initialized I c= s11 & Initialized I c= s21 by FUNCT_4:26;
A6: s11 = s1 +* (I +* Start-At insloc 0) by A1,Th18;
  then DataPart s11 = DataPart s1 by SCMFSA8A:11;
  then
A7: I is_closed_on s11 & I is_halting_on s11 by A2,SCMFSA8B:8;
A8: now
    let a be read-write Int-Location;
A9: a in dom s1 & a in dom s2 & not a in dom Initialized I
    by SCMFSA6A:48,SCMFSA_2:66;
    hence s11.a = s1.a by FUNCT_4:12
      .= s2.a by A3
      .= s21.a by A9,FUNCT_4:12;
  end;
A10: now
    let f be FinSeq-Location;
A11: f in dom s1 & f in dom s2 & not f in dom Initialized I
    by SCMFSA6A:49,SCMFSA_2:67;
    hence s11.f = s1.f by FUNCT_4:12
      .= s2.f by A4
      .= s21.f by A11,FUNCT_4:12;
  end;
A12: intloc 0 in dom Initialized I by SCMFSA6A:45;
  then s11.intloc 0 = (Initialized I).intloc 0 by FUNCT_4:14
    .= s21.intloc 0 by A12,FUNCT_4:14;
  then
A13: DataPart s11 = DataPart s21 by A8,A10,Th33;
  I +* Start-At insloc 0 c= Initialized I by Th19;
  then
A14: I +* Start-At insloc 0 c= s11 & I +* Start-At insloc 0 c= s21
  by A5,XBOOLE_1:1;
  then
A15: LifeSpan s11 = LifeSpan s21 by A7,A13,Th44;
A16: s11 is halting by A2,A6,SCMFSA7B:def 8;
  then CurInstr  Computation( s11,LifeSpan  s11) = halt SCM+FSA &
  for k being Element of NAT
  st CurInstr  Computation( s11,k) = halt SCM+FSA holds
  LifeSpan s11 <= k by AMI_1:def 46;
  then CurInstr  Computation( s21,LifeSpan  s11) = halt SCM+FSA
  by A7,A13,A14,Th43;
  then
A17: s21 is halting by AMI_1:def 20;
  thus DataPart IExec(I,s1)
  = DataPart Result s11 by SCMFSA8B:35
    .= DataPart Computation( s11,LifeSpan  s11) by A16,AMI_1:122
    .= DataPart  Computation( s21,LifeSpan  s11) by A7,A13,A14,Th43
    .= DataPart Result s21 by A15,A17,AMI_1:122
    .= DataPart IExec(I,s2) by SCMFSA8B:35;
end;

theorem Th46:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA st
  s1.intloc 0 = 1 & I is_closed_on s1 & I is_halting_on s1 &
  DataPart s1 = DataPart s2 holds
  DataPart IExec(I,s1) = DataPart IExec(I,s2)
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s11 = s1 +* Initialized I;
  set s21 = s2 +* Initialized I;
  assume
A1: s1.intloc 0 = 1 & I is_closed_on s1 & I is_halting_on s1 &
  DataPart s1 = DataPart s2;
A2: Initialized I c= s11 & Initialized I c= s21 by FUNCT_4:26;
  s2.intloc 0 = 1 by A1,SCMFSA6A:38;
  then
A3: s11 = s1 +* (I +* Start-At insloc 0) &
  s21 = s2 +* (I +* Start-At insloc 0) by A1,Th18;
  then
A4: DataPart s11 = DataPart s1 by SCMFSA8A:11;
  then
A5: I is_closed_on s11 & I is_halting_on s11 by A1,SCMFSA8B:8;
A6: DataPart s11 = DataPart s21 by A1,A3,A4,SCMFSA8A:11;
  I +* Start-At insloc 0 c= Initialized I by Th19;
  then
A7: I +* Start-At insloc 0 c= s11 & I +* Start-At insloc 0 c= s21
  by A2,XBOOLE_1:1;
  then
A8: LifeSpan s11 = LifeSpan s21 by A5,A6,Th44;
A9: s11 is halting by A1,A3,SCMFSA7B:def 8;
  then CurInstr  Computation( s11,LifeSpan  s11) = halt SCM+FSA &
  for k being Element of NAT
  st CurInstr  Computation( s11,k) = halt SCM+FSA holds
  LifeSpan s11 <= k by AMI_1:def 46;
  then CurInstr  Computation( s21,LifeSpan  s11) = halt SCM+FSA
  by A5,A6,A7,Th43;
  then
A10: s21 is halting by AMI_1:def 20;
  thus DataPart IExec(I,s1)
  = DataPart Result s11 by SCMFSA8B:35
    .= DataPart Computation( s11,LifeSpan  s11) by A9,AMI_1:122
    .= DataPart Computation( s21,LifeSpan  s11) by A5,A6,A7,Th43
    .= DataPart Result s21 by A8,A10,AMI_1:122
    .= DataPart IExec(I,s2) by SCMFSA8B:35;
end;

registration
  let I be Program of SCM+FSA;
  cluster Initialized I -> initial;
  correctness
  proof
    now
      let m,n be Nat;
      assume n in dom Initialized I;
      then
A1:   insloc n in dom I by Th20;
      I c= Initialized I by SCMFSA6A:26;
      then
A2:   dom I c= dom Initialized I by GRFUNC_1:8;
      assume m < n;
      then insloc m in dom I by A1,SCMNORM:def 1;
      hence m in dom Initialized I by A2;
    end;
    hence thesis by SCMNORM:def 1;
  end;
end;

Lm1: now
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
A1: ProgramPart Initialized I = I by SCMFSA6A:33;
  hereby
    assume
A2: Initialized I is_pseudo-closed_on s;
    set k = pseudo-LifeSpan(s,Initialized I);
    IC  Computation( (s +* (Initialized I +* Start-At insloc 0)),k) =
    insloc card ProgramPart Initialized I &
    for n being Element of NAT st n < k holds
    IC  Computation( (s +* (Initialized I +* Start-At insloc 0)),n) in
    dom Initialized I by A2,SCMFSA8A:def 5;
    then IC  Computation( (Initialize s +* (I +* Start-At insloc 0)),k) =
    insloc card ProgramPart Initialized I by Th16;
    then
A3: IC  Computation( (Initialize s +* (I +* Start-At insloc 0)),k) =
    insloc card ProgramPart I by A1,AMI_1:105;
A4: now
      let n be Element of NAT;
      assume n < k;
      then IC  Computation( (s +* (Initialized I +* Start-At insloc 0)),n) in
      dom Initialized I by A2,SCMFSA8A:def 5;
      then IC  Computation( (Initialize s +* (I +* Start-At insloc 0)),n) in
      dom Initialized I by Th16;
      hence IC  Computation( (Initialize s +* (I +* Start-At insloc 0)),n) in
      dom I by Th20;
    end;
    then
A5: for n be Element of NAT st
    not IC  Computation( (Initialize s +* (I +* Start-At insloc 0)),
    n) in dom I holds k <= n;
    thus I is_pseudo-closed_on Initialize s by A3,A4,SCMFSA8A:def 3;
    hence pseudo-LifeSpan(s,Initialized I) = pseudo-LifeSpan(Initialize s,I)
    by A3,A5,SCMFSA8A:def 5;
  end;
  assume
A6: I is_pseudo-closed_on Initialize s;
  set k = pseudo-LifeSpan(Initialize s,I);
  IC  Computation( (Initialize s +* (I +* Start-At insloc 0)),k) =
  insloc card ProgramPart I & for n being Element of NAT st n < k holds
  IC  Computation( (Initialize s +* (I +* Start-At insloc 0)),n) in
  dom I by A6,SCMFSA8A:def 5;
  then IC  Computation( (s +* (Initialized I +* Start-At insloc 0)),k) =
  insloc card ProgramPart I by Th16;
  then
A7: IC  Computation( (s +* (Initialized I +* Start-At insloc 0)),k) =
  insloc card ProgramPart Initialized I by A1,AMI_1:105;
A8: now
    let n be Element of NAT;
    assume n < k;
    then IC  Computation( (Initialize s +* (I +* Start-At insloc 0)),n) in
    dom I by A6,SCMFSA8A:def 5;
    then IC  Computation( (s +* (Initialized I +* Start-At insloc 0)),n) in
    dom I by Th16;
    hence IC  Computation( (s +* (Initialized I +* Start-At insloc 0)),n) in
    dom Initialized I by Th20;
  end;
  then
A9: for n be Element of NAT st not IC  Computation( (s +* (Initialized I +*
  Start-At insloc 0)),n) in dom Initialized I holds k <= n;
  thus Initialized I is_pseudo-closed_on s by A7,A8,SCMFSA8A:def 3;
  hence pseudo-LifeSpan(s,Initialized I) = pseudo-LifeSpan(Initialize s,I)
  by A7,A9,SCMFSA8A:def 5;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  Initialized I is_pseudo-closed_on s iff I is_pseudo-closed_on Initialize s
  by Lm1;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA
  st I is_pseudo-closed_on Initialize s holds
  pseudo-LifeSpan(s,Initialized I) = pseudo-LifeSpan(Initialize s,I) by Lm1;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA
  st Initialized I is_pseudo-closed_on s holds
  pseudo-LifeSpan(s,Initialized I) = pseudo-LifeSpan(Initialize s,I) by Lm1;

theorem Th50:
  for s being State of SCM+FSA, I being initial FinPartState of SCM+FSA
  st I is_pseudo-closed_on s holds
  I is_pseudo-closed_on s +* (I +* Start-At insloc 0) &
  pseudo-LifeSpan(s,I) = pseudo-LifeSpan(s +* (I +* Start-At insloc 0),I)
proof
  let s be State of SCM+FSA;
  let I be initial FinPartState of SCM+FSA;
  assume
A1: I is_pseudo-closed_on s;
  set s2 = s +* (I +* Start-At insloc 0) +* (I +* Start-At insloc 0);
A2: s +* (I +* Start-At insloc 0) +* (I +* Start-At insloc 0)
  = s +* ((I +* Start-At insloc 0) +* (I +* Start-At insloc 0)) by FUNCT_4:15
    .= s +* (I +* Start-At insloc 0);
  then
A3: IC  Computation( s2,pseudo-LifeSpan(s,I)) = insloc card ProgramPart I &
  for n being Element of NAT st not IC  Computation( s2,n) in dom I
  holds pseudo-LifeSpan(s,I) <= n by A1,SCMFSA8A:def 5;
  IC  Computation( s2,pseudo-LifeSpan(s,I)) = insloc card ProgramPart I &
  for n being Element of NAT st n < pseudo-LifeSpan(s,I) holds
  IC  Computation( s2,n) in dom I by A1,A2,SCMFSA8A:def 5;
  hence I is_pseudo-closed_on s +* (I +* Start-At insloc 0) by SCMFSA8A:def 3;
  hence pseudo-LifeSpan(s,I) =
  pseudo-LifeSpan(s +* (I +* Start-At insloc 0),I) by A3,SCMFSA8A:def 5;
end;

theorem Th51:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA
  st I +* Start-At insloc 0 c= s1 & I is_pseudo-closed_on s1
  for n being Element of NAT st ProgramPart Relocated(I,n) c= s2 &
  IC s2 = insloc n & DataPart s1 = DataPart s2  holds
  ((for i being Element of NAT st i < pseudo-LifeSpan(s1,I) holds
  IncAddr(CurInstr  Computation( s1,i),n) = CurInstr  Computation( s2,i)) &
  for i being Element of NAT st i <= pseudo-LifeSpan(s1,I) holds
  IC  Computation( s1,i) + n = IC  Computation( s2,i) &
   DataPart Computation( s1,i) = DataPart Computation( s2,i))
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: I +* Start-At insloc 0 c= s1;
  assume
A2: I is_pseudo-closed_on s1;
  let n be Element of NAT;
  assume
A3: ProgramPart Relocated(I,n) c= s2;
  assume
A4: IC s2 = insloc n;
  assume
A5: DataPart s1 = DataPart s2;
 thus
A6: now
    let i be Element of NAT;
    assume
A7: i < pseudo-LifeSpan(s1,I);
    defpred P[Element of NAT] means $1 < pseudo-LifeSpan(s1,I) implies
    IC Computation(s1,$1) + n = IC Computation(s2,$1) &
    IncAddr(CurInstr (Computation(s1,$1)),n) = CurInstr (Computation(s2,$1)) &
    DataPart Computation(s1,$1) = DataPart Computation(s2,$1);
A8: P[0]
    proof
      assume
A9:   0 < pseudo-LifeSpan(s1,I);
A10:  IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
      IC Computation(s1,0) = s1.IC SCM+FSA by AMI_1:13
        .= (I +* Start-At insloc 0).IC SCM+FSA by A1,A10,GRFUNC_1:8
        .= insloc 0 by SF_MASTR:66;
      hence IC Computation(s1,0) + n
        = IC Computation(s2,0) by A4,AMI_1:13;
A11:  I c= I +* Start-At insloc 0 by SCMFSA8A:9;
      then
A12:  dom I c= dom (I +* Start-At insloc 0) by GRFUNC_1:8;
      IC  Computation( (s1 +* (I +* Start-At insloc 0)),0)
      = IC (s1 +* (I +* Start-At insloc 0)) by AMI_1:13
        .= IC (s1 +* I +* Start-At insloc 0) by FUNCT_4:15
        .= insloc 0 by AMI_1:111;
      then
A13:  insloc 0 in dom I by A2,A9,SCMFSA8A:def 5;
      IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
      then
A14:  s1.IC s1 = s1.((I +* Start-At insloc 0).IC SCM+FSA) by A1, GRFUNC_1: 8
        .= s1.insloc 0 by SF_MASTR:66
        .= (I +* Start-At insloc 0).insloc 0 by A1,A12,A13,GRFUNC_1:8
        .= I.insloc 0 by A11,A13,GRFUNC_1:8;
      insloc 0 + n in dom Relocated(I,n) by A13,SCMFSA_5:4;
      then
A15:  insloc (0 + n) in dom ProgramPart Relocated(I,n) by AMI_1:106;
A16:  insloc 0 in dom ProgramPart I by A13,AMI_1:105;
      thus IncAddr(CurInstr (Computation(s1,0)),n) = IncAddr(CurInstr s1,n)
       by AMI_1:13
        .= Relocated(I,n).insloc (0 + n) by A14,A16,SCMFSA_5:7
        .= (ProgramPart Relocated(I,n)).insloc n by FUNCT_1:72
        .= CurInstr s2 by A3,A4,A15,GRFUNC_1:8
        .= CurInstr (Computation(s2,0)) by AMI_1:13;
      thus DataPart Computation(s1,0)
      = DataPart s2 by A5,AMI_1:13
        .= DataPart Computation(s2,0) by AMI_1:13;
    end;
A17: for k being Element of NAT st P[k] holds P[k + 1]
    proof
      let k be Element of NAT;
      assume
A18:  P[k];
      assume
A19:  k + 1 < pseudo-LifeSpan(s1,I);
A20:  k + 0 < k + 1 by XREAL_1:8;
A21:  Computation(s1,k+1) = Following Computation(s1,k) by AMI_1:14
        .= Exec(CurInstr Computation(s1,k),Computation(s1,k));
A22:  Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
        .= Exec(CurInstr Computation(s2,k),Computation(s2,k));
      hence
A23:  IC Computation(s1,k+1) + n
      = IC Computation(s2,k+1) by A18,A19,A20,A21,SCMFSA6A:41,XXREAL_0:2;
      reconsider j = CurInstr Computation(s1,k+1) as Instruction of SCM+FSA;
      reconsider l = IC Computation(s1,k+1) as Element of NAT
       by ORDINAL1:def 13;
A25:  I c= I +* Start-At insloc 0 by SCMFSA8A:9;
      then
A26:  dom I c= dom (I +* Start-At insloc 0) by GRFUNC_1:8;
      s1 +* (I +* Start-At insloc 0) = s1 by A1,FUNCT_4:79;
      then
A27:  IC Computation(s1,k+1) in dom I by A2,A19,SCMFSA8A:def 5;
      dom ProgramPart I = dom I /\ NAT by FUNCT_1:68;
      then
A28:  l in dom ProgramPart I by A27,XBOOLE_0:def 3;
A29:  IC Computation(s2,k+1) in NAT by AMI_1:def 4;
A30:  j = s1.IC Computation(s1,k+1) by AMI_1:54
        .= (I +* Start-At insloc 0).IC Computation(s1,k+1)
         by A1,A26,A27,GRFUNC_1:8
        .= I.l by A25,A27,GRFUNC_1:8;
      IC Computation(s2,k+1) in dom Relocated(I,n) by A23,A27,SCMFSA_5:4;
      then IC Computation(s2,k+1) in dom Relocated(I,n) /\ NAT
       by A29,XBOOLE_0:def 3;
      then
A31:  IC Computation(s2,k+1) in dom ProgramPart Relocated(I,n) by FUNCT_1:68;
      thus IncAddr(CurInstr Computation(s1,k+1),n)
      = Relocated(I,n).(l + n) by A28,A30,SCMFSA_5:7
        .= (ProgramPart Relocated(I,n)).(IC Computation(s2,k+1))
         by A23,FUNCT_1:72
        .= s2.IC Computation(s2,k+1) by A3,A31,GRFUNC_1:8
        .= CurInstr Computation(s2,k+1) by AMI_1:54;
      thus DataPart Computation(s1,k+1) = DataPart Computation(s2,k+1)
       by A18,A19,A20,A21
      ,A22,SCMFSA6A:41,XXREAL_0:2;
    end;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A8,A17);
    hence IncAddr(CurInstr ( Computation( s1,i)),n) =
    CurInstr ( Computation( s2,i)) by A7;
  end;
  let i be Element of NAT;
  assume
A32: i <= pseudo-LifeSpan(s1,I);
  defpred P[Element of NAT] means $1 <= pseudo-LifeSpan(s1,I) implies
  IC Computation(s1,$1) + n = IC Computation(s2,$1) &
   DataPart Computation(s1,$1) = DataPart Computation(s2,$1);
A33: P[0]
  proof
    assume 0 <= pseudo-LifeSpan(s1,I);
A34: IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
    IC Computation(s1,0) = s1.IC SCM+FSA by AMI_1:13
      .= (I +* Start-At insloc 0).IC SCM+FSA by A1,A34,GRFUNC_1:8
      .= insloc 0 by SF_MASTR:66;
    hence IC Computation(s1,0) + n
      = IC Computation(s2,0) by A4,AMI_1:13;
    thus DataPart Computation(s1,0)
    = DataPart s2 by A5,AMI_1:13
      .= DataPart Computation(s2,0) by AMI_1:13;
  end;
A35: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A36: P[k];
    assume
A37: k + 1 <= pseudo-LifeSpan(s1,I);
    then
A38: k + 1 <= pseudo-LifeSpan(s1,I) + 1 by NAT_1:12;
A39: k < pseudo-LifeSpan(s1,I) by A37,NAT_1:13;
    set i = CurInstr Computation(s1,k);
A40: Computation(s1,k+1) = Following Computation(s1,k) by AMI_1:14
      .= Exec(CurInstr Computation(s1,k),Computation(s1,k));
A41: Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
      .= Exec(CurInstr Computation(s2,k),Computation(s2,k));
    thus IC Computation(s1,k+1) + n
    = IC Exec(IncAddr(i,n),Computation(s2,k))
     by A36,A38,A40,SCMFSA6A:41,XREAL_1:8
      .= IC Computation(s2,k+1) by A6,A39,A41;
    thus DataPart Computation(s1,k+1)
    = DataPart Exec(IncAddr(i,n),Computation(s2,k))
    by A36,A38,A40,SCMFSA6A:41,XREAL_1:8
      .= DataPart Computation(s2,k+1)
       by A6,A39,A41;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A33,A35);
  hence thesis by A32;
end;

theorem Th52:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
  DataPart s1 = DataPart s2 holds
  I is_pseudo-closed_on s1 implies I is_pseudo-closed_on s2
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set S1 = s1 +* (I +* Start-At insloc 0),
      S2 = s2 +* (I +* Start-At insloc 0);
  assume DataPart s1 = DataPart s2;
  then
A1: DataPart(s1 +* (I +* Start-At insloc 0)) = DataPart s2 by SCMFSA8A:11
    .= DataPart(s2 +* (I +* Start-At insloc 0)) by SCMFSA8A:11;
  assume
A2: I is_pseudo-closed_on s1;
  then
A3: IC Computation(S1,pseudo-LifeSpan(s1,I)) = insloc card ProgramPart I &
  for n being Element of NAT st n < pseudo-LifeSpan(s1,I) holds
  IC Computation(S1,n) in dom I by SCMFSA8A:def 5;
A4: I is_pseudo-closed_on s1 +* (I +* Start-At insloc 0) by A2,Th50;
A5: I +* Start-At insloc 0 c= s1 +* (I +* Start-At insloc 0) by FUNCT_4:26;
A6: I +* Start-At insloc 0 c= s2 +* (I +* Start-At insloc 0) by FUNCT_4:26;
  I c= I +* Start-At insloc 0 by SCMFSA8A:9;
  then I c= s2 +* (I +* Start-At insloc 0) by A6,XBOOLE_1:1;
  then
A7: ProgramPart Relocated(I,0) c= s2 +* (I +* Start-At insloc 0) by Th9;
A8: IC (s2 +* (I +* Start-At insloc 0))
  = IC (s2 +* I +* Start-At insloc 0) by FUNCT_4:15
    .= insloc 0 by AMI_1:111;
A9: IC Computation(S2,pseudo-LifeSpan(s1,I))
  = IC Computation(S2,pseudo-LifeSpan(s1 +* (I +* Start-At insloc 0),I))
   by A2,Th50
    .= IC Computation(S1,pseudo-LifeSpan(s1 +* (I +* Start-At insloc 0),I)) + 0
  by A1,A4,A5,A7,A8,Th51
    .= IC Computation(S1,pseudo-LifeSpan(s1,I)) by A2,Th50;
  now
    let k be Element of NAT;
    assume
A10: k < pseudo-LifeSpan(s1,I);
    then k <= pseudo-LifeSpan(s1 +* (I +* Start-At insloc 0),I) by A2,Th50;
    then IC Computation(S2,k) = IC Computation(S1,k) + 0 by A1,A4,A5,A7,A8,Th51
      .= IC Computation(S1,k);
    hence IC Computation(S2,k) in dom I by A2,A10,SCMFSA8A:def 5;
  end;
  hence I is_pseudo-closed_on s2 by A3,A9,SCMFSA8A:def 3;
end;

theorem Th53:
  for s being State of SCM+FSA, I being Program of SCM+FSA
  st s.intloc 0 = 1 holds
  I is_pseudo-closed_on s iff I is_pseudo-closed_on Initialize s
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume s.intloc 0 = 1;
  then DataPart s = DataPart Initialize s by Th27;
  hence I is_pseudo-closed_on s iff I is_pseudo-closed_on Initialize s
  by Th52;
end;

theorem Th54: ::TD2' ** n.t
  for a being Int-Location, I,J being Program of SCM+FSA holds
  insloc 0 in dom if=0(a,I,J) & insloc 1 in dom if=0(a,I,J) &
  insloc 0 in dom if>0(a,I,J) & insloc 1 in dom if>0(a,I,J)
proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  set i = a =0_goto insloc (card J + 3);
  if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA
  by SCMFSA8B:def 1
    .= i ';' J ';' Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)
  by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA))
  by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)));
  then
A1: dom Macro i c= dom if=0(a,I,J) by SCMFSA6A:56;
  dom Macro i = {insloc 0, insloc 1} by SCMFSA7B:4;
  then insloc 0 in dom Macro i & insloc 1 in dom Macro i by TARSKI:def 2;
  hence insloc 0 in dom if=0(a,I,J) & insloc 1 in dom if=0(a,I,J) by A1;
  set i = a >0_goto insloc (card J + 3);
  if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA
  by SCMFSA8B:def 2
    .= i ';' J ';' Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)
  by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA))
  by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)));
  then
A2: dom Macro i c= dom if>0(a,I,J) by SCMFSA6A:56;
  dom Macro i = {insloc 0, insloc 1} by SCMFSA7B:4;
  then insloc 0 in dom Macro i & insloc 1 in dom Macro i by TARSKI:def 2;
  hence insloc 0 in dom if>0(a,I,J) & insloc 1 in dom if>0(a,I,J) by A2;
end;

theorem Th55: ::TD2 ** n.t
  for a being Int-Location, I,J being Program of SCM+FSA holds
  if=0(a,I,J).insloc 0 = a =0_goto insloc (card J + 3) &
  if=0(a,I,J).insloc 1 = goto insloc 2 &
  if>0(a,I,J).insloc 0 = a >0_goto insloc (card J + 3) &
  if>0(a,I,J).insloc 1 = goto insloc 2
proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  set i = a =0_goto insloc (card J + 3);
A1: i <> halt SCM+FSA by SCMFSA_2:48,124;
A2: if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA
  by SCMFSA8B:def 1
    .= i ';' J ';' Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)
  by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA))
  by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)));
  dom Macro i = {insloc 0, insloc 1} by SCMFSA7B:4;
  then
A3: insloc 0 in dom Macro i & insloc 1 in dom Macro i by TARSKI:def 2;
  hence if=0(a,I,J).insloc 0 = (Directed Macro i).insloc 0 by A2,SCMFSA8A:28
    .= i by A1,SCMFSA7B:7;
  thus if=0(a,I,J).insloc 1 = (Directed Macro i).insloc 1 by A2,A3,SCMFSA8A:
  28
    .= goto insloc 2 by SCMFSA7B:8;
  set i = a >0_goto insloc (card J + 3);
A4: i <> halt SCM+FSA by SCMFSA_2:49,124;
A5: if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA
  by SCMFSA8B:def 2
    .= i ';' J ';' Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)
  by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA))
  by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)));
  dom Macro i = {insloc 0, insloc 1} by SCMFSA7B:4;
  then
A6: insloc 0 in dom Macro i & insloc 1 in dom Macro i by TARSKI:def 2;
  hence if>0(a,I,J).insloc 0 = (Directed Macro i).insloc 0 by A5,SCMFSA8A:28
    .= i by A4,SCMFSA7B:7;
  thus if>0(a,I,J).insloc 1 = (Directed Macro i).insloc 1 by A5,A6,SCMFSA8A:
  28
    .= goto insloc 2 by SCMFSA7B:8;
end;

theorem Th56: ::T6327 ** n.t
  for a being Int-Location, I,J being Program of SCM+FSA,
  n being Element of NAT
  st n < card I + card J + 3 holds n in dom if=0(a,I,J) &
  if=0(a,I,J).n <> halt SCM+FSA
proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  let n be Element of NAT;
  assume
A1: n < card I + card J + 3;
A2: if=0(a,I,J) = a =0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  set J1 = a =0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I;
  card J1
    = card (Macro (a =0_goto insloc (card J + 3)) ';' J ';'
  Goto insloc (card I + 1)) + card I by SCMFSA6A:61
    .= card (Macro (a =0_goto insloc (card J + 3)) ';' J) +
  card Goto insloc (card I + 1) + card I by SCMFSA6A:61
    .= card (Macro (a =0_goto insloc (card J + 3)) ';' J) + 1 + card I
  by SCMFSA8A:29
    .= card Macro (a =0_goto insloc (card J + 3)) + card J + 1 + card I
  by SCMFSA6A:61
    .= 2 + card J + 1 + card I by SCMFSA7B:6
    .= card I + card J + 3;
  then insloc n in dom J1 by A1,SCMFSA6A:15;
  then
A3: insloc n in dom Directed J1 by FUNCT_4:105;
  Directed J1 c= if=0(a,I,J) by A2,SCMFSA6A:55;
  then
A4: dom Directed J1 c= dom if=0(a,I,J) &
  if=0(a,I,J).insloc n = (Directed J1).insloc n by A3,GRFUNC_1:8;
  hence n in dom if=0(a,I,J) by A3;
  (Directed J1).insloc n in rng Directed J1 by A3,FUNCT_1:def 5;
  hence if=0(a,I,J).n <> halt SCM+FSA by A4,AMI_1:def 52;
end;

theorem Th57: ::T6327' ** n.t
  for a being Int-Location, I,J being Program of SCM+FSA,
  n being Element of NAT
  st n < card I + card J + 3 holds n in dom if>0(a,I,J) &
  if>0(a,I,J).n <> halt SCM+FSA
proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  let n be Element of NAT;
  assume
A1: n < card I + card J + 3;
A2: if>0(a,I,J) = a >0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  set J1 = a >0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I;
  card J1
    = card (Macro (a >0_goto insloc (card J + 3)) ';' J ';'
  Goto insloc (card I + 1)) + card I by SCMFSA6A:61
    .= card (Macro (a >0_goto insloc (card J + 3)) ';' J) +
  card Goto insloc (card I + 1) + card I by SCMFSA6A:61
    .= card (Macro (a >0_goto insloc (card J + 3)) ';' J) + 1 + card I
  by SCMFSA8A:29
    .= card Macro (a >0_goto insloc (card J + 3)) + card J + 1 + card I
  by SCMFSA6A:61
    .= 2 + card J + 1 + card I by SCMFSA7B:6
    .= card I + card J + 3;
  then insloc n in dom J1 by A1,SCMFSA6A:15;
  then
A3: insloc n in dom Directed J1 by FUNCT_4:105;
  Directed J1 c= if>0(a,I,J) by A2,SCMFSA6A:55;
  then
A4: dom Directed J1 c= dom if>0(a,I,J) &
  if>0(a,I,J).insloc n = (Directed J1).insloc n by A3,GRFUNC_1:8;
  hence n in dom if>0(a,I,J) by A3;
  (Directed J1).insloc n in rng Directed J1 by A3,FUNCT_1:def 5;
  hence if>0(a,I,J).n <> halt SCM+FSA by A4,AMI_1:def 52;
end;

theorem Th58:
  for s being State of SCM+FSA, I being Program of SCM+FSA st
  Directed I is_pseudo-closed_on s holds I ';' Stop SCM+FSA is_closed_on s &
  I ';' Stop SCM+FSA is_halting_on s &
  LifeSpan (s +* (I ';' Stop SCM+FSA +* Start-At insloc 0)) =
  pseudo-LifeSpan(s,Directed I) &
  (for n being Element of NAT st n < pseudo-LifeSpan(s,Directed I) holds
  IC  Computation( (s +* (I +* Start-At insloc 0)),n) =
  IC  Computation( (s +* (I ';' Stop SCM+FSA +* Start-At insloc 0)),n)) &
  for n being Element of NAT st n <= pseudo-LifeSpan(s,Directed I) holds
  DataPart Computation( (s +* (I +* Start-At insloc 0)),n) =
  DataPart Computation( (s +* (I ';' Stop SCM+FSA +* Start-At insloc 0)),n)
proof
  set A = NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set I0 = Directed I;
  set I1 = I ';' Stop SCM+FSA;
  set s00 = s +* (I0 +* Start-At insloc 0);
  set s10 = s +* (I1 +* Start-At insloc 0);
  assume
A1: I0 is_pseudo-closed_on s;
  reconsider k = pseudo-LifeSpan(s00,I0) as Element of NAT;
A2: I0 c= I1 by SCMFSA6A:55;
  then
A3: dom I0 c= dom I1 by GRFUNC_1:8;
  card I1 = card I + 1 by SCMFSA6A:61,SCMFSA8A:17;
  then card I < card I1 by NAT_1:13;
  then
A4: insloc card I in dom I1 by SCMFSA6A:15;
A5: card I < card I + card Stop SCM+FSA by NAT_1:13,SCMFSA8A:17;
  halt SCM+FSA = (Stop SCM+FSA).insloc (card I -' card I)
  by BINARITH:51,SCMFSA8A:16;
  then I1.insloc card I = IncAddr(halt SCM+FSA,card I) by A5,Th13
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A6: s10.insloc card I = halt SCM+FSA by A4,Th26;
A7: I0 +* Start-At insloc 0 c= s00 by FUNCT_4:26;
A8: s00 +* (I0 +* Start-At insloc 0)
  = s +* ((I0 +* Start-At insloc 0) +* (I0 +* Start-At insloc 0))
  by FUNCT_4:15
    .= s00;
A9: I0 is_pseudo-closed_on s00 by A1,Th50;
A10: k = pseudo-LifeSpan(s,I0) by A1,Th50;
  I1 c= I1 +* Start-At insloc 0 & I1 +* Start-At insloc 0 c= s10
  by FUNCT_4:26,SCMFSA8A:9;
  then ProgramPart Relocated(I0,0) c= I1 & I1 c= s10 by A2,Th9,XBOOLE_1:1;
  then
A11: ProgramPart Relocated(I0,0) c= s10 by XBOOLE_1:1;
  s10 = s +* I1 +* Start-At insloc 0 by FUNCT_4:15;
  then
A12: IC s10 = insloc 0 by AMI_1:111;
A13: DataPart s00 = DataPart s by SCMFSA8A:11
    .= DataPart s10 by SCMFSA8A:11;
A14: now
    let n be Element of NAT;
    assume
A15: n < pseudo-LifeSpan(s00,I0);
    then IncAddr(CurInstr  Computation( s00,n),0) = CurInstr  Computation( s10
    ,n) by A7,A9,A11,A12,A13,Th51;
    hence CurInstr  Computation( s00,n) = CurInstr  Computation( s10,n) by Th8;
    thus IC  Computation( s00,n) in dom I0 by A8,A9,A15,SCMFSA8A:31;
    thus CurInstr  Computation( s00,n) <> halt SCM+FSA by A8,A9,A15,
    SCMFSA8A:31;
  end;
A16: now
    let n be Element of NAT;
    assume
A17: n <= pseudo-LifeSpan(s00,I0);
    then IC  Computation( s00,n) + 0 = IC  Computation( s10,n)
    by A7,A9,A11,A12,A13,Th51;
    hence IC  Computation( s00,n) = IC  Computation( s10,n);
    thus DataPart Computation( s00,n) = DataPart Computation( s10,n)
    by A7,A9,A11,A12,A13,A17,Th51;
  end;
  defpred P[Element of NAT] means
  k <= $1 implies IC  Computation( s10,$1) = insloc card I &
  CurInstr  Computation( s10,$1) = halt SCM+FSA;
A18: P[0]
  proof
    assume k <= 0;
    then k = 0;
    hence IC  Computation( s10,0) = IC  Computation( s00,k) by A16
      .= insloc card ProgramPart I0 by A1,A10,SCMFSA8A:def 5
      .= insloc card I0 by AMI_1:105
      .= insloc card I by SCMFSA8A:34;
    hence CurInstr  Computation( s10,0) = halt SCM+FSA by A6,AMI_1:13;
  end;
A19: for n being Element of NAT st P[n] holds P[n + 1]
  proof
    let n be Element of NAT;
    assume
A20: P[n];
    assume
A21: k <= n + 1; thus
    now per cases by A21,NAT_1:8;
      suppose k = n + 1;
        hence IC  Computation( s10,n+1) = IC  Computation( s00,k) by A16
          .= insloc card ProgramPart I0 by A1,A10,SCMFSA8A:def 5
          .= insloc card I0 by AMI_1:105
          .= insloc card I by SCMFSA8A:34;
      end;
      suppose
A22:    k <= n;
         Computation( s10,n+1) = Following  Computation( s10,n) by
        AMI_1:14
          .= Exec(CurInstr  Computation( s10,n), Computation( s10,n));
        hence IC  Computation( s10,n+1) = insloc card I by A20,A22,
        AMI_1:def 8;
      end;
    end;
    hence CurInstr  Computation( s10,n+1) = halt SCM+FSA by A6,AMI_1:54;
  end;
A23: for n being Element of NAT holds P[n] from NAT_1:sch 1(A18,A19);
  now
    let n be Element of NAT;
    per cases;
    suppose
A24:  n < k;
      then IC  Computation( s00,n) = IC  Computation( s10,n) by A16;
      then IC  Computation( s10,n) in dom I0 by A1,A10,A24,SCMFSA8A:def 5;
      hence IC  Computation( s10,n) in dom I1 by A3;
    end;
    suppose k <= n;
      hence IC  Computation( s10,n) in dom I1 by A4,A23;
    end;
  end;
  hence I1 is_closed_on s by SCMFSA7B:def 7;
  P[k] by A23;
  then
A25: s10 is halting by AMI_1:def 20;
  hence I1 is_halting_on s by SCMFSA7B:def 8;
A26: CurInstr  Computation( s10,k) = halt SCM+FSA by A23;
  now
    let n be Element of NAT;
    assume
A27: CurInstr  Computation( s10,n) = halt SCM+FSA;
    assume
A28: k > n;
    reconsider l = IC  Computation( s00,n) as Instruction-Location of SCM+FSA;
A29: l in dom I0 by A1,A10,A28,SCMFSA8A:def 5;
    CurInstr  Computation( s10,n) = CurInstr  Computation( s00,n) by A14,A28
      .= s00.l by AMI_1:54
      .= I0.l by A29,Th26;
    then halt SCM+FSA in rng I0 by A27,A29,FUNCT_1:def 5;
    hence contradiction by AMI_1:def 52;
  end;
  then
A30: LifeSpan s10 = k by A25,A26,AMI_1:def 46;
  IC  Computation( s10,k) = insloc card I by A23;
  then
A31: IC  Computation( s00,LifeSpan  s10) = insloc card I by A16,A30;
A32: card ProgramPart I0 = card I0 by AMI_1:105
    .= card I by SCMFSA8A:34;
  for n be Element of NAT st not IC  Computation( s00,n) in dom I0 holds
  LifeSpan s10 <= n by A14,A30;
  hence LifeSpan s10 = pseudo-LifeSpan(s,I0) by A1,A31,A32,SCMFSA8A:def 5;
  set s1 = s +* (I +* Start-At insloc 0);
  defpred P[Element of NAT] means $1 < pseudo-LifeSpan(s,I0) implies
  IC  Computation( s1,$1) in dom I &
  IC  Computation( s1,$1) = IC  Computation( s10,$1) &
   DataPart Computation( s1,$1) = DataPart Computation( s10,$1);
A33: P[0]
  proof
    assume 0 < pseudo-LifeSpan(s,I0);
    then IC  Computation( (s +* (I0 +* Start-At insloc 0)),0) in dom I0
    by A1,SCMFSA8A:31;
    then IC (s +* (I0 +* Start-At insloc 0)) in dom I0 by AMI_1:13;
    then
A34: insloc 0 in dom I0 by Th31;
A35: IC  Computation( s1,0) = IC s1 by AMI_1:13
      .= IC (s +* I +* Start-At insloc 0) by FUNCT_4:15
      .= insloc 0 by AMI_1:111;
    hence IC  Computation( s1,0) in dom I by A34,FUNCT_4:105;
    thus IC  Computation( s1,0) = IC  Computation( s10,0) by A12,A35,
    AMI_1:13;
    thus DataPart Computation( s1,0) = DataPart s1 by AMI_1:13
      .= DataPart s by SCMFSA8A:11
      .= DataPart s10 by SCMFSA8A:11
      .= DataPart Computation( s10,0) by AMI_1:13;
  end;
A36: for n being Element of NAT st P[n] holds P[n + 1]
  proof
    let n be Element of NAT;
    set l = IC  Computation( s1,n);
    set l0 = IC  Computation( s10,n);
    assume
A37: P[n];
    assume
A38: n + 1 < pseudo-LifeSpan(s,I0);
A39: pseudo-LifeSpan(s,I0) = k by A1,Th50;
    n < k by A10,A38,NAT_1:12;
    then
A40: IC  Computation( s00,n+1) = IC  Computation( s10,n+1) &
     DataPart Computation( s00,n) = DataPart Computation( s10,n) &
     l in dom I & l = l0 &
     DataPart Computation( s1,n) = DataPart Computation( s10,n)
      by A16,A37,A38,A39;
A41: l0 in dom I0 by A37,A38,NAT_1:12,FUNCT_4:105;
A42: now
      assume
A43:  I.l = halt SCM+FSA;
A44:  l0 in dom I & dom I = dom I0 by A37,A38,NAT_1:12,FUNCT_4:105;
      n < k by A10,A38,NAT_1:12;
      then
A45:  CurInstr  Computation( s00,n) =  Computation( s00,n).l0 by A16
        .= s00.l0 by AMI_1:54
        .= I0.l by A37,A38,A44,Th26,NAT_1:12
        .= goto insloc card I by A37,A38,A43,NAT_1:12,SCMFSA8A:30;
A46:  IC  Computation( s00,n+1)
      = IC Following  Computation( s00,n) by AMI_1:14
        .= insloc card I by A45,SCMFSA_2:95
        .= insloc card I0 by SCMFSA8A:34;
      IC  Computation( s00,n+1) in dom I0 by A1,A38,SCMFSA8A:31;
      hence contradiction by A46,SCMFSA6A:15;
    end;
A47: CurInstr  Computation( s1,n) = s1.l by AMI_1:54
      .= I.l by A37,A38,Th26,NAT_1:12
      .= I0.l0 by A37,A38,A42,NAT_1:12,SCMFSA8A:30
      .= I1.l0 by A2,A41,GRFUNC_1:8
      .= s10.l0 by A3,A41,Th26
      .= CurInstr  Computation( s10,n) by AMI_1:54;
A48:  Computation( s1,n+1) = Following  Computation( s1,n) by AMI_1:14
      .= Exec(CurInstr  Computation( s1,n), Computation( s1,n));
A49:  Computation( s10,n+1) = Following  Computation( s10,n) by AMI_1:14
      .= Exec(CurInstr  Computation( s1,n), Computation( s10,n)) by A47;
    (for a being Int-Location holds
     Computation( s1,n).a =  Computation( s10,n).a) &
    for f being FinSeq-Location holds
     Computation( s1,n).f =  Computation( s10,n).f
    by A37,A38,NAT_1:12,SCMFSA6A:38;
    then
A50:  Computation( s1,n), Computation( s10,n) equal_outside A
    by A37,A38,NAT_1:12,SCMFSA6A:28;
    then
A51:  Computation( s1,n+1), Computation( s10,n+1) equal_outside A
    by A48,A49,SCMFSA6A:32;
    dom I0 = dom I & IC  Computation( s00,n+1) in dom I0
    by A1,A38,FUNCT_4:105,SCMFSA8A:31;
    hence IC  Computation( s1,n+1) in dom I by A40,A48,A49,A50,AMI_1:121,
    SCMFSA6A:32;
    thus IC  Computation( s1,n+1) = IC  Computation( s10,n+1)
    by A48,A49,A50,AMI_1:121,SCMFSA6A:32;
    (for a being Int-Location holds
     Computation( s1,n+1).a =  Computation( s10,n+1).a) &
    for f being FinSeq-Location holds
     Computation( s1,n+1).f =  Computation( s10,n+1).f
    by A51,SCMFSA6A:30,31;
    hence DataPart Computation( s1,n+1) = DataPart Computation( s10,n+1)
    by SCMFSA6A:38;
  end;
A52: for n being Element of NAT holds P[n] from NAT_1:sch 1(A33,A36);
  hence for n be Element of NAT st n < pseudo-LifeSpan(s,I0) holds
  IC  Computation( s1,n) = IC  Computation( s10,n);
  let n be Element of NAT;
  assume
A53: n <= pseudo-LifeSpan(s,Directed I);
  per cases by A53,REAL_1:def 5;
  suppose n < pseudo-LifeSpan(s,I0);
    hence DataPart Computation( s1,n) = DataPart Computation( s10,n) by A52;
  end;
  suppose
A54: n = pseudo-LifeSpan(s,I0);
    hereby per cases by NAT_1:6;
      suppose
A55:    n = 0;
        hence DataPart Computation( s1,n) = DataPart s1 by AMI_1:13
          .= DataPart s by SCMFSA8A:11
          .= DataPart s10 by SCMFSA8A:11
          .= DataPart Computation( s10,n) by A55,AMI_1:13;
      end;
      suppose ex m be Nat st n = m + 1;
        then consider m being Nat such that
A56:    n = m + 1;
        reconsider m as Element of NAT by ORDINAL1:def 13;
A57:     Computation( s1,n) = Following  Computation( s1,m) by A56,AMI_1:14
          .= Exec(CurInstr  Computation( s1,m), Computation( s1,m));
A58:     Computation( s10,n) = Following  Computation( s10,m) by A56,AMI_1:14
          .= Exec(CurInstr  Computation( s10,m), Computation( s10,m));
        set i = CurInstr  Computation( s1,m);
        set l = IC  Computation( s1,m);
        set l0 = IC  Computation( s10,m);
A59:    m + 0 < pseudo-LifeSpan(s,I0) by A54,A56,XREAL_1:8;
        then
A60:    DataPart Computation( s1,m) = DataPart Computation( s10,m) &
 l in dom I & l = l0
        by A52;
        then
A61:    l0 in dom I0 by FUNCT_4:105;
A62:    i = s1.l by AMI_1:54
          .= I.l by A59,A52,Th26;
        I0 c= I1 by SCMFSA6A:55;
        then
A63:    I0.l0 = I1.l0 by A61,GRFUNC_1:8
          .= s10.l0 by A3,A61,Th26
          .= CurInstr  Computation( s10,m) by AMI_1:54;
        hereby per cases;
          suppose
A64:        i = halt SCM+FSA;
            then CurInstr  Computation( s10,m) = goto insloc card I
            by A60,A62,A63,SCMFSA8A:30;
            then InsCode CurInstr  Computation( s10,m) = 6 by SCMFSA_2:47;
            then
A65:        InsCode CurInstr  Computation( s10,m) in {0,6,7,8} by
            ENUMSET1:def 2;
            thus DataPart Computation( s1,n)
            = DataPart Computation( s1,m) by A57,A64,AMI_1:def 8
              .= DataPart Computation( s10,m) by A52,A59
              .= DataPart Computation( s10,n) by A58,A65,Th32;
          end;
          suppose i <> halt SCM+FSA;
            then CurInstr  Computation( s10,m) = i by A60,A62,A63,SCMFSA8A:30;
            hence DataPart Computation( s1,n) = DataPart Computation( s10,n)
            by A57,A58,A60,SCMFSA6C:5;
          end;
        end;
      end;
    end;
  end;
end;

theorem Th59:
  for s being State of SCM+FSA, I being Program of SCM+FSA st
  Directed I is_pseudo-closed_on s holds
  DataPart Result (s +* (I ';' Stop SCM+FSA +* Start-At insloc 0)) =
  DataPart Computation( (s +* (I +* Start-At insloc 0)),
  pseudo-LifeSpan(s,Directed I))
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set I0 = Directed I;
  set I1 = I ';' Stop SCM+FSA;
  set s2 = s +* (I +* Start-At insloc 0);
  set s10 = s +* (I1 +* Start-At insloc 0);
  set k = pseudo-LifeSpan(s,I0);
  assume I0 is_pseudo-closed_on s;
  then
A1: I1 is_halting_on s & LifeSpan s10 = k &
   DataPart Computation( s2,k) = DataPart Computation( s10,k) by Th58;
  then s10 is halting by SCMFSA7B:def 8;
  hence DataPart Result s10 = DataPart Computation( s2,k) by A1,AMI_1:122;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA st
  s.intloc 0 = 1 & Directed I is_pseudo-closed_on s holds
  DataPart IExec(I ';' Stop SCM+FSA,s) =
  DataPart Computation( (s +* (I +* Start-At insloc 0)),
  pseudo-LifeSpan(s,Directed I))
proof
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set I0 = Directed I;
  set I1 = I ';' Stop SCM+FSA;
  set s2 = s +* (I +* Start-At insloc 0);
  set s10 = s +* (I1 +* Start-At insloc 0);
  set k = pseudo-LifeSpan(s,I0);
  assume
A1: s.intloc 0 = 1;
  assume
A2: I0 is_pseudo-closed_on s;
  thus DataPart IExec(I1,s)
  = DataPart (Result (s +* Initialized I1) +* s | A) by SCMFSA6B:def 1
    .= DataPart (Result (s +* Initialized I1)) by Th35
    .= DataPart(Result s10) by A1,Th18
    .= DataPart Computation( s2,k) by A2,Th59;
end;

theorem Th61: ::TMP20 ** n.t
  for I,J being Program of SCM+FSA,a being Int-Location holds
  if=0(a,I,J).insloc (card I + card J + 3) = halt SCM+FSA
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
A1: if=0(a,I,J) = a =0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  set II =
  a =0_goto insloc (card J + 3) ';' J ';' Goto insloc (card I + 1) ';' I;
A2: card II
    = card (Macro (a =0_goto insloc (card J + 3)) ';' J ';'
  Goto insloc (card I + 1)) + card I by SCMFSA6A:61
    .= card (Macro (a =0_goto insloc (card J + 3)) ';' J) +
  card Goto insloc (card I + 1) + card I by SCMFSA6A:61
    .= card (Macro (a =0_goto insloc (card J + 3)) ';' J) + 1 + card I
  by SCMFSA8A:29
    .= card Macro (a =0_goto insloc (card J + 3)) + card J + 1 + card I
  by SCMFSA6A:61
    .= 2 + card J + 1 + card I by SCMFSA7B:6
    .= card I + card J + 3;
  then
A3: card I + card J + 3 < card II + card Stop SCM+FSA by NAT_1:13
  ,SCMFSA8A:17;
  card I + card J + 3 -' card II = 0 by A2,BINARITH:51;
  hence if=0(a,I,J).insloc (card I + card J + 3)
  = IncAddr(halt SCM+FSA,card II) by A1,A2,A3,Th13,SCMFSA8A:16
    .= halt SCM+FSA by SCMFSA_4:8;
end;

theorem Th62: ::TMP20' ** n.t
  for I,J being Program of SCM+FSA,a being Int-Location holds
  if>0(a,I,J).insloc (card I + card J + 3) = halt SCM+FSA
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
A1: if>0(a,I,J) = a >0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  set II =
  a >0_goto insloc (card J + 3) ';' J ';' Goto insloc (card I + 1) ';' I;
A2: card II
    = card (Macro (a >0_goto insloc (card J + 3)) ';' J ';'
  Goto insloc (card I + 1)) + card I by SCMFSA6A:61
    .= card (Macro (a >0_goto insloc (card J + 3)) ';' J) +
  card Goto insloc (card I + 1) + card I by SCMFSA6A:61
    .= card (Macro (a >0_goto insloc (card J + 3)) ';' J) + 1 + card I
  by SCMFSA8A:29
    .= card Macro (a >0_goto insloc (card J + 3)) + card J + 1 + card I
  by SCMFSA6A:61
    .= 2 + card J + 1 + card I by SCMFSA7B:6
    .= card I + card J + 3;
  then
A3: card I + card J + 3 < card II + card Stop SCM+FSA by NAT_1:13
  ,SCMFSA8A:17;
  card I + card J + 3 -' card II = 0 by A2,BINARITH:51;
  hence if>0(a,I,J).insloc (card I + card J + 3)
  = IncAddr(halt SCM+FSA,card II) by A1,A2,A3,Th13,SCMFSA8A:16
    .= halt SCM+FSA by SCMFSA_4:8;
end;

theorem Th63: ::TMP21 ** n.t
  for I,J being Program of SCM+FSA,a being Int-Location holds
  if=0(a,I,J).insloc (card J + 2) = goto insloc (card I + card J + 3)
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  set JJ = a =0_goto insloc (card J + 3) ';' J;
  set J3 = a =0_goto insloc (card J + 3) ';' J ';' Goto insloc (card I + 1);
A1: if=0(a,I,J) = a =0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
A2: card JJ
    = card Macro (a =0_goto insloc (card J + 3)) + card J by SCMFSA6A:61
    .= 2 + card J by SCMFSA7B:6;
  card Goto insloc (card I + 1) = 1 by SCMFSA8A:29;
  then
A3: card J3 = card J + 2 + 1 by A2,SCMFSA6A:61
    .= card J + (2 + 1);
  card J + 2 -' card JJ = 0 by A2,BINARITH:51;
  then
A4: goto insloc (card I + 1) =
  (Goto insloc (card I + 1)).insloc (card J + 2 -' card JJ) by SCMFSA8A:47;
  card Goto insloc (card I + 1) = 1 by SCMFSA8A:29;
  then card J + 2 < card JJ + card Goto insloc (card I + 1) by A2,NAT_1:13;
  then
A5: J3.insloc (card J + 2)
  = IncAddr(goto insloc (card I + 1),card JJ) by A2,A4,Th13
    .= goto insloc (card I + 1 + (card J + 2)) by A2,SCMFSA_4:14
    .= goto insloc (card I + card J + (1 + 2));
A6: 6 <> 0 & InsCode goto insloc (card I + card J + 3) = 6 &
  InsCode halt SCM+FSA = 0 by SCMFSA_2:47,124;
  card J3 = card J + 2 + 1 by A3;
  then card J + 2 < card J3 by NAT_1:13;
  then
A7: insloc (card J + 2) in dom J3 by SCMFSA6A:15;
  then (J3 ';' (I ';' Stop SCM+FSA)).insloc (card J + 2)
  = (Directed J3).insloc (card J + 2) by SCMFSA8A:28
    .= goto insloc (card I + card J + 3) by A5,A6,A7,SCMFSA8A:30;
  hence if=0(a,I,J).insloc (card J + 2)
  = goto insloc (card I + card J + 3) by A1,SCMFSA6A:67;
end;

theorem Th64: ::TMP21' ** n.t
  for I,J being Program of SCM+FSA,a being Int-Location holds
  if>0(a,I,J).insloc (card J + 2) = goto insloc (card I + card J + 3)
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  set JJ = a >0_goto insloc (card J + 3) ';' J;
  set J3 = a >0_goto insloc (card J + 3) ';' J ';' Goto insloc (card I + 1);
A1: if>0(a,I,J) = a >0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
A2: card JJ
    = card Macro (a >0_goto insloc (card J + 3)) + card J by SCMFSA6A:61
    .= 2 + card J by SCMFSA7B:6;
  card Goto insloc (card I + 1) = 1 by SCMFSA8A:29;
  then
A3: card J3 = card J + 2 + 1 by A2,SCMFSA6A:61
    .= card J + (2 + 1);
  card J + 2 -' card JJ = 0 by A2,BINARITH:51;
  then
A4: goto insloc (card I + 1) =
  (Goto insloc (card I + 1)).insloc (card J + 2 -' card JJ) by SCMFSA8A:47;
  card Goto insloc (card I + 1) = 1 by SCMFSA8A:29;
  then card J + 2 < card JJ + card Goto insloc (card I + 1) by A2,NAT_1:13;
  then
A5: J3.insloc (card J + 2)
  = IncAddr(goto insloc (card I + 1),card JJ) by A2,A4,Th13
    .= goto insloc (card I + 1 + (card J + 2)) by A2,SCMFSA_4:14
    .= goto insloc (card I + card J + (1 + 2));
A6: 6 <> 0 & InsCode goto insloc (card I + card J + 3) = 6 &
  InsCode halt SCM+FSA = 0 by SCMFSA_2:47,124;
  card J3 = card J + 2 + 1 by A3;
  then card J + 2 < card J3 by NAT_1:13;
  then
A7: insloc (card J + 2) in dom J3 by SCMFSA6A:15;
  then (J3 ';' (I ';' Stop SCM+FSA)).insloc (card J + 2)
  = (Directed J3).insloc (card J + 2) by SCMFSA8A:28
    .= goto insloc (card I + card J + 3) by A5,A6,A7,SCMFSA8A:30;
  hence if>0(a,I,J).insloc (card J + 2)
  = goto insloc (card I + card J + 3) by A1,SCMFSA6A:67;
end;

theorem Th65: ::T31139 ** n.t
  for J being Program of SCM+FSA,a being Int-Location holds
  if=0(a,Goto insloc 2,J).insloc (card J + 3) = goto insloc (card J + 5)
proof
  let J be Program of SCM+FSA;
  let a be Int-Location;
  set JJ = a =0_goto insloc (card J + 3) ';' J;
  set J3 = a =0_goto insloc (card J + 3) ';' J ';' Goto insloc 2;
  set J4 =
  a =0_goto insloc (card J + 3) ';' J ';' Goto insloc 2 ';' Goto insloc 2;
  card Goto insloc 2 = 1 by SCMFSA8A:29;
  then
A1: if=0(a,Goto insloc 2,J) = (a =0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (1 + 1) ';' Goto insloc 2) ';' Stop SCM+FSA by SCMFSA8B:def 1;
A2: card Goto insloc 2 = 1 by SCMFSA8A:29;
  card JJ
    = card Macro (a =0_goto insloc (card J + 3)) + card J by SCMFSA6A:61
    .= 2 + card J by SCMFSA7B:6;
  then
A3: card J3 = card J + 2 + 1 by A2,SCMFSA6A:61
    .= card J + (2 + 1);
  then
A4: card J4 = card J + 3 + 1 by A2,SCMFSA6A:61
    .= card J + (3 + 1);
  card J + 3 -' card J3 = 0 by A3,BINARITH:51;
  then
A5: goto insloc 2 = (Goto insloc 2).insloc (card J + 3 -' card J3)
  by SCMFSA8A:47;
  card Goto insloc 2 = 1 by SCMFSA8A:29;
  then card J + 3 < card J3 + card Goto insloc 2 by A3,NAT_1:13;
  then
A6: J4.insloc (card J + 3) = IncAddr(goto insloc 2,card J3) by A3,A5, Th13
    .= goto insloc (2 + (card J + 3)) by A3,SCMFSA_4:14
    .= goto insloc (card J + (2 + 3));
A7: 6 <> 0 & InsCode goto insloc (card J + 5) = 6 &
  InsCode halt SCM+FSA = 0 by SCMFSA_2:47,124;
  card J4 = card J + 3 + 1 by A4;
  then card J + 3 < card J4 by NAT_1:13;
  then
A8: insloc (card J + 3) in dom J4 by SCMFSA6A:15;
  then (J4 ';' Stop SCM+FSA).insloc (card J + 3)
  = (Directed J4).insloc (card J + 3) by SCMFSA8A:28
    .= goto insloc (card J + 5) by A6,A7,A8,SCMFSA8A:30;
  hence if=0(a,Goto insloc 2,J).insloc (card J + 3)
  = goto insloc (card J + 5) by A1;
end;

theorem Th66:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a = 0 & Directed I is_pseudo-closed_on s holds
  if=0(a,I,J) is_halting_on s & if=0(a,I,J) is_closed_on s &
  LifeSpan (s +* (if=0(a,I,J) +* Start-At insloc 0)) =
  LifeSpan (s +* (I ';' Stop SCM+FSA +* Start-At insloc 0)) + 1
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I0 = Directed I;
  set I1 = I ';' Stop SCM+FSA;
  set s00 = s +* (I0 +* Start-At insloc 0);
  set s3 = s +* (if=0(a,I,J) +* Start-At insloc 0);
  set s4 =  Computation( s3,1);
  set i = a =0_goto insloc (card J + 3);
  assume
A1: s.a = 0;
  assume
A2: I0 is_pseudo-closed_on s;
A3: if=0(a,I,J) = a =0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
A4: I0 +* Start-At insloc 0 c= s00 by FUNCT_4:26;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A5: I0 is_pseudo-closed_on s00 by A2,Th52;
A6: insloc 0 in dom if=0(a,I,J) by Th54;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A7: dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
A8: IC SCM+FSA in dom (if=0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
A9: now thus IC s3 = (if=0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by A8,
    FUNCT_4:14
      .= insloc 0 by SF_MASTR:66;
  end;
A10: now thus s3.insloc 0
    = (if=0(a,I,J) +* Start-At insloc 0).insloc 0 by A6,A7,FUNCT_4:14
      .= if=0(a,I,J).insloc 0 by A6,SCMFSA6B:7
      .= i by Th55;
  end;
A11: now thus  Computation( s3,0+1)
    = Following  Computation( s3,0) by AMI_1:14
      .= Following s3 by AMI_1:13
      .= Exec(i,s3) by A9,A10;
  end;
A12: now thus card (i ';' J ';' Goto insloc (card I + 1))
      = card (Macro i ';' J) + card Goto insloc (card I + 1) by SCMFSA6A:61
      .= card (Macro i ';' J) + 1 by SCMFSA8A:29
      .= card Macro i + card J + 1 by SCMFSA6A:61
      .= card J + 2 + 1 by SCMFSA7B:6
      .= card J + (2 + 1);
  end;
  not a in dom (if=0(a,I,J) +* Start-At insloc 0) & a in dom s
  by SCMFSA6B:12,SCMFSA_2:66;
  then
A13: s3.a = 0 by A1,FUNCT_4:12;
A14: if=0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A15: if=0(a,I,J) c= s3 by A14,XBOOLE_1:1;
  if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by A3,SCMFSA6A:67;
  then ProgramPart Relocated(I1,card J + 3) c= if=0(a,I,J) by A12,FUNCT_4:26;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A15,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(I1,card J + 3)] c= s4 by AMI_1:99;
  then
A16: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
  ProgramPart Relocated(I0,card J + 3) c= ProgramPart Relocated(I1,card J + 3)
  by Th12,SCMFSA6A:55;
  then
A17: ProgramPart Relocated(I0,card J + 3) c= s4 by A16,XBOOLE_1:1;
A18: IC Computation(s3,1) = insloc (card J + 3) by A11,A13,SCMFSA_2:96;
A19: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A20: now
    let a be Int-Location;
    thus s00.a = s3.a by A19,SCMFSA6A:38
      .= s4.a by A11,SCMFSA_2:96;
  end;
  now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A19,SCMFSA6A:38
      .= s4.f by A11,SCMFSA_2:96;
  end;
  then
A21: DataPart s00 = DataPart s4 by A20,SCMFSA6A:38;
A22: if=0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  now thus card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
      .= card I + card J + 3 + 1;
  end;
  then card I + card J + 3 < card if=0(a,I,J) by NAT_1:13;
  then
A23: insloc (card I + card J + 3) in dom if=0(a,I,J) by SCMFSA6A:15;
A24: now thus IC Computation(s3,pseudo-LifeSpan(s00,I0) + 1)
    = IC  Computation( s4,pseudo-LifeSpan(s00,I0)) by AMI_1:51
      .= IC  Computation( s00,pseudo-LifeSpan(s00,I0)) + (card J + 3)
    by A4,A5,A17,A18,A21,Th51
      .= IC  Computation( s00,pseudo-LifeSpan(s,I0)) + (card J + 3) by A2,Th50
      .= insloc card ProgramPart I0 + (card J + 3) by A2,SCMFSA8A:def 5
      .= insloc card I0 + (card J + 3) by AMI_1:105
      .= insloc (card I + (card J + 3)) by SCMFSA8A:34
      .= insloc (card I + card J + 3);
  end;
  then
A25: CurInstr  Computation( s3,pseudo-LifeSpan(s00,I0) + 1)
  = s3.insloc (card I + card J + 3) by AMI_1:54
    .= if=0(a,I,J).insloc (card I + card J + 3) by A22,A23,GRFUNC_1:8
    .= halt SCM+FSA by Th61;
  then
A26: s3 is halting by AMI_1:def 20;
  hence if=0(a,I,J) is_halting_on s by SCMFSA7B:def 8;
  now
    let k be Element of NAT;
    per cases;
    suppose k = 0;
      then  Computation( s3,k) = s3 by AMI_1:13;
      then IC  Computation( s3,k) = insloc 0 by Th31;
      hence IC  Computation( s3,k) in dom if=0(a,I,J) by Th54;
    end;
    suppose
A27:  0 < k & k < pseudo-LifeSpan(s00,I0) + 1;
      then 0 + 1 <= k by INT_1:20;
      then consider k1 being Nat such that
A28:  1 + k1 = k by NAT_1:10;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
A29:  k1 < pseudo-LifeSpan(s00,I0) by A27,A28,XREAL_1:8;
      then
A30:  k1 < pseudo-LifeSpan(s,I0) by A2,Th50;
A31:  IC  Computation( s3,k) = IC  Computation( s4,k1) by A28,AMI_1:51

.= IC  Computation( s00,k1) + (card J + 3) by A4,A5,A17,A18,A21,A29,Th51;
  reconsider n = IC  Computation( s00,k1) as Element of NAT by ORDINAL1:def 13;
      insloc n in dom I0 by A2,A30,SCMFSA8A:31;
      then n < card I0 by SCMFSA6A:15;
      then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
      then
A33:  n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
      card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
        .= card I + card J + 3 + 1;
      then card I + card J + 3 < card if=0(a,I,J) by XREAL_1:31;
      then n + (card J + 3) < card if=0(a,I,J) by A33,XXREAL_0:2;
      hence IC  Computation( s3,k) in dom if=0(a,I,J) by A31,SCMFSA6A:15;
    end;
    suppose 0 < k & pseudo-LifeSpan(s00,I0) + 1 <= k;
      hence IC  Computation( s3,k) in dom if=0(a,I,J) by A23,A24,A25,AMI_1:52;
    end;
  end;
  hence if=0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
  now
    let k be Element of NAT;
    assume
A34: CurInstr  Computation( s3,k) = halt SCM+FSA;
    assume not pseudo-LifeSpan(s00,I0) + 1 <= k;
    then
A35: k <= pseudo-LifeSpan(s00,I0) by NAT_1:13;
A36: insloc 0 in dom if=0(a,I,J) by Th54;
A37: InsCode halt SCM+FSA = 0 & InsCode (a =0_goto insloc (card J + 3)) = 7
    by SCMFSA_2:48,124;
    CurInstr  Computation( s3,0) = CurInstr s3 by AMI_1:13
      .= s3.insloc 0 by Th31
      .= if=0(a,I,J).insloc 0 by A36,Th26
      .= a =0_goto insloc (card J + 3) by Th55;
    then consider k1 being Nat such that
A38: k1 + 1 = k by A34,A37,NAT_1:6;
    reconsider k1 as Element of NAT by ORDINAL1:def 13;
    k1 < k by A38,XREAL_1:31;
    then
A39: k1 < pseudo-LifeSpan(s00,I0) by A35,XXREAL_0:2;
A40: IC  Computation( s3,k) = IC  Computation( s4,k1) by A38,AMI_1:51
      .= IC  Computation( s00,k1) + (card J + 3) by A4,A5,A17,A18,A21,A39,Th51;
  reconsider n = IC  Computation( s00,k1) as Element of NAT by ORDINAL1:def 13;
    k1 < pseudo-LifeSpan(s,I0) by A2,A39,Th50;
    then insloc n in dom I0 by A2,SCMFSA8A:31;
    then n < card I0 by SCMFSA6A:15;
    then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
    then
A42: n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
    card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
      .= card I + card J + 3 + 1;
    then card I + card J + 3 < card if=0(a,I,J) by XREAL_1:31;
    then n + (card J + 3) < card if=0(a,I,J) by A42,XXREAL_0:2;
    then
A43: IC  Computation( s3,k) in dom if=0(a,I,J) by A40,SCMFSA6A:15;
    set J1 = a =0_goto insloc (card J + 3) ';' J ';'
    Goto insloc (card I + 1) ';' I;
    card J1
      = card (Macro (a =0_goto insloc (card J + 3)) ';' J ';'
    Goto insloc (card I + 1)) + card I by SCMFSA6A:61
      .= card (Macro (a =0_goto insloc (card J + 3)) ';' J) +
    card Goto insloc (card I + 1) + card I by SCMFSA6A:61
      .= card (Macro (a =0_goto insloc (card J + 3)) ';' J) + 1 + card I
    by SCMFSA8A:29
      .= card Macro (a =0_goto insloc (card J + 3)) + card J + 1 + card I
    by SCMFSA6A:61
      .= 2 + card J + 1 + card I by SCMFSA7B:6
      .= card I + card J + 3;
    then IC  Computation( s3,k) in dom J1 by A40,A42,SCMFSA6A:15;
    then
A44: IC  Computation( s3,k) in dom Directed J1 by FUNCT_4:105;
    Directed J1 c= if=0(a,I,J) by A3,SCMFSA6A:55;
    then
A45: if=0(a,I,J).IC  Computation( s3,k) = (Directed J1).IC  Computation( s3,k)
    by A44,GRFUNC_1:8;
A46: (Directed J1).IC  Computation( s3,k) in rng Directed J1 by A44,
    FUNCT_1:def 5;
    CurInstr  Computation( s3,k) = s3.IC  Computation( s3,k) by AMI_1:54
      .= if=0(a,I,J).IC  Computation( s3,k) by A43,Th26;
    hence contradiction by A34,A45,A46,AMI_1:def 52;
  end;
  then
A47: LifeSpan s3 = pseudo-LifeSpan(s00,I0) + 1 by A25,A26,AMI_1:def 46;
  pseudo-LifeSpan(s,I0) = LifeSpan (s +* (I1 +* Start-At insloc 0))
  by A2,Th58;
  hence LifeSpan s3 = LifeSpan (s +* (I1 +* Start-At insloc 0)) + 1
  by A2,A47,Th50;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.intloc 0 = 1 & s.a = 0 & Directed I is_pseudo-closed_on s holds
  DataPart IExec(if=0(a,I,J),s) = DataPart IExec(I ';' Stop SCM+FSA,s)
proof
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  let ss be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I0 = Directed I;
  set s = Initialize ss;
  set I1 = I ';' Stop SCM+FSA;
  set s00 = s +* (I0 +* Start-At insloc 0);
  set s3 = s +* (if=0(a,I,J) +* Start-At insloc 0);
  set s4 =  Computation( s3,1);
  set i = a =0_goto insloc (card J + 3);
  assume
A1: ss.intloc 0 = 1;
  assume ss.a = 0;
  then
A2: s.a = 0 by SCMFSA6C:3;
  assume I0 is_pseudo-closed_on ss;
  then
A3: I0 is_pseudo-closed_on s by A1,Th53;
A4: if=0(a,I,J) = a =0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
A5: I0 +* Start-At insloc 0 c= s00 by FUNCT_4:26;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A6: I0 is_pseudo-closed_on s00 by A3,Th52;
A7: insloc 0 in dom if=0(a,I,J) by Th54;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A8: dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
A9: IC SCM+FSA in dom (if=0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
A10: now thus IC s3 = (if=0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by A9,
    FUNCT_4:14
      .= insloc 0 by SF_MASTR:66;
  end;
A11: now thus s3.insloc 0
    = (if=0(a,I,J) +* Start-At insloc 0).insloc 0 by A7,A8,FUNCT_4:14
      .= if=0(a,I,J).insloc 0 by A7,SCMFSA6B:7
      .= i by Th55;
  end;
A12: now thus  Computation( s3,0+1)
    = Following  Computation( s3,0) by AMI_1:14
      .= Following s3 by AMI_1:13
      .= Exec(i,s3) by A10,A11;
  end;
A13: now thus card (i ';' J ';' Goto insloc (card I + 1))
      = card (Macro i ';' J) + card Goto insloc (card I + 1) by SCMFSA6A:61
      .= card (Macro i ';' J) + 1 by SCMFSA8A:29
      .= card Macro i + card J + 1 by SCMFSA6A:61
      .= card J + 2 + 1 by SCMFSA7B:6
      .= card J + (2 + 1);
  end;
  not a in dom (if=0(a,I,J) +* Start-At insloc 0) & a in dom s
  by SCMFSA6B:12,SCMFSA_2:66;
  then
A14: s3.a = 0 by A2,FUNCT_4:12;
A15: if=0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A16: if=0(a,I,J) c= s3 by A15,XBOOLE_1:1;
  if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by A4,SCMFSA6A:67;
  then ProgramPart Relocated(I1,card J + 3) c= if=0(a,I,J) by A13,FUNCT_4:26;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A16,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(I1,card J + 3)] c= s4 by AMI_1:99;
  then
A17: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
  ProgramPart Relocated(I0,card J + 3) c= ProgramPart Relocated(I1,card J + 3)
  by Th12,SCMFSA6A:55;
  then
A18: ProgramPart Relocated(I0,card J + 3) c= s4 by A17,XBOOLE_1:1;
A19: IC Computation(s3,1) = insloc (card J + 3) by A12,A14,SCMFSA_2:96;
A20: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A21: now
    let a be Int-Location;
    thus s00.a = s3.a by A20,SCMFSA6A:38
      .= s4.a by A12,SCMFSA_2:96;
  end;
  now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A20,SCMFSA6A:38
      .= s4.f by A12,SCMFSA_2:96;
  end;
  then
A22: DataPart s00 = DataPart s4 by A21,SCMFSA6A:38;
A23: if=0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  now thus card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
      .= card I + card J + 3 + 1;
  end;
  then card I + card J + 3 < card if=0(a,I,J) by NAT_1:13;
  then
A24: insloc (card I + card J + 3) in dom if=0(a,I,J) by SCMFSA6A:15;
  now thus IC  Computation( s3,pseudo-LifeSpan(s00,I0) + 1)
    = IC  Computation( s4,pseudo-LifeSpan(s00,I0)) by AMI_1:51
      .= IC  Computation( s00,pseudo-LifeSpan(s00,I0)) + (card J + 3)
    by A5,A6,A18,A19,A22,Th51
      .= IC  Computation( s00,pseudo-LifeSpan(s,I0)) + (card J + 3) by A3,Th50
      .= insloc card ProgramPart I0 + (card J + 3) by A3,SCMFSA8A:def 5
      .= insloc card I0 + (card J + 3) by AMI_1:105
      .= insloc (card I + (card J + 3)) by SCMFSA8A:34
      .= insloc (card I + card J + 3);
  end;
  then
A25: CurInstr  Computation( s3,pseudo-LifeSpan(s00,I0) + 1)
  = s3.insloc (card I + card J + 3) by AMI_1:54
    .= if=0(a,I,J).insloc (card I + card J + 3) by A23,A24,GRFUNC_1:8
    .= halt SCM+FSA by Th61;
  then
A26: s3 is halting by AMI_1:def 20;
  now
    let k be Element of NAT;
    assume
A27: CurInstr  Computation( s3,k) = halt SCM+FSA;
    assume not pseudo-LifeSpan(s00,I0) + 1 <= k;
    then
A28: k <= pseudo-LifeSpan(s00,I0) by NAT_1:13;
A29: insloc 0 in dom if=0(a,I,J) by Th54;
A30: InsCode halt SCM+FSA = 0 & InsCode (a =0_goto insloc (card J + 3)) = 7
    by SCMFSA_2:48,124;
    CurInstr  Computation( s3,0) = CurInstr s3 by AMI_1:13
      .= s3.insloc 0 by Th31
      .= if=0(a,I,J).insloc 0 by A29,Th26
      .= a =0_goto insloc (card J + 3) by Th55;
    then consider k1 being Nat such that
A31: k1 + 1 = k by A27,A30,NAT_1:6;
    reconsider k1 as Element of NAT by ORDINAL1:def 13;
    k1 < k by A31,XREAL_1:31;
    then
A32: k1 < pseudo-LifeSpan(s00,I0) by A28,XXREAL_0:2;
A33: IC  Computation( s3,k) = IC  Computation( s4,k1) by A31,AMI_1:51
      .= IC  Computation( s00,k1) + (card J + 3) by A5,A6,A18,A19,A22,A32,Th51;
  reconsider n = IC  Computation( s00,k1) as Element of NAT by ORDINAL1:def 13;
    k1 < pseudo-LifeSpan(s,I0) by A3,A32,Th50;
    then insloc n in dom I0 by A3,SCMFSA8A:31;
    then n < card I0 by SCMFSA6A:15;
    then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
    then
A35: n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
    card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
      .= card I + card J + 3 + 1;
    then card I + card J + 3 < card if=0(a,I,J) by XREAL_1:31;
    then n + (card J + 3) < card if=0(a,I,J) by A35,XXREAL_0:2;
    then
A36: IC  Computation( s3,k) in dom if=0(a,I,J) by A33,SCMFSA6A:15;
    set J1 = a =0_goto insloc (card J + 3) ';' J ';'
    Goto insloc (card I + 1) ';' I;
    card J1
      = card (Macro (a =0_goto insloc (card J + 3)) ';' J ';'
    Goto insloc (card I + 1)) + card I by SCMFSA6A:61
      .= card (Macro (a =0_goto insloc (card J + 3)) ';' J) +
    card Goto insloc (card I + 1) + card I by SCMFSA6A:61
      .= card (Macro (a =0_goto insloc (card J + 3)) ';' J) + 1 + card I
    by SCMFSA8A:29
      .= card Macro (a =0_goto insloc (card J + 3)) + card J + 1 + card I
    by SCMFSA6A:61
      .= 2 + card J + 1 + card I by SCMFSA7B:6
      .= card I + card J + 3;
    then IC  Computation( s3,k) in dom J1 by A33,A35,SCMFSA6A:15;
    then
A37: IC  Computation( s3,k) in dom Directed J1 by FUNCT_4:105;
    Directed J1 c= if=0(a,I,J) by A4,SCMFSA6A:55;
    then
A38: if=0(a,I,J).IC  Computation( s3,k) = (Directed J1).IC  Computation( s3,k)
    by A37,GRFUNC_1:8;
A39: (Directed J1).IC  Computation( s3,k) in rng Directed J1 by A37,
    FUNCT_1:def 5;
    CurInstr  Computation( s3,k) = s3.IC  Computation( s3,k) by AMI_1:54
      .= if=0(a,I,J).IC  Computation( s3,k) by A36,Th26;
    hence contradiction by A27,A38,A39,AMI_1:def 52;
  end;
  then
A40: LifeSpan s3 = pseudo-LifeSpan(s00,I0) + 1 by A25,A26,AMI_1:def 46;
  set s1 = s +* (I1 +* Start-At insloc 0);
  s +* Initialized if=0(a,I,J) =
  Initialize s +* (if=0(a,I,J) +* Start-At insloc 0) &
  s +* Initialized I1 = Initialize s +* (I1 +* Start-At insloc 0)
  by SCMFSA8A:13;
  then
A41: s +* Initialized if=0(a,I,J) = s3 & s +* Initialized I1 = s1 by Th15;
A42: I1 is_halting_on s & LifeSpan s1 = pseudo-LifeSpan(s,I0) by A3,Th58;
  then
A43: s1 is halting by SCMFSA7B:def 8;
A44: Directed I0 = I0 by SCMFSA6A:63;
  I0 ';' Stop SCM+FSA = I1 & Directed I0 is_pseudo-closed_on s
  by A3,SCMFSA6A:63,SCMFSA8A:41;
  then
A45: DataPart Computation( s00,pseudo-LifeSpan(s,I0)) =
   DataPart Computation( s1,pseudo-LifeSpan(s,I0)) by A44,Th58;
  thus DataPart IExec(if=0(a,I,J),ss) = DataPart IExec(if=0(a,I,J),s) by Th17
    .= DataPart(Result (s +* Initialized if=0(a,I,J)) +* s | A)
     by SCMFSA6B:def 1
    .= DataPart Result s3 by A41,Th35
    .= DataPart Computation( s3,LifeSpan  s3) by A26,AMI_1:122
    .= DataPart Computation( s4,pseudo-LifeSpan(s00,I0)) by A40,AMI_1:51
    .= DataPart Computation( s00,pseudo-LifeSpan(s00,I0))
     by A5,A6,A18,A19,A22,Th51
    .= DataPart Computation( s1,LifeSpan  s1) by A3,A42,A45,Th50
    .= DataPart Result s1 by A43,AMI_1:122
    .= DataPart(Result (s +* Initialized I1) +* s | A) by A41,Th35
    .= DataPart IExec(I1,s) by SCMFSA6B:def 1
    .= DataPart IExec(I1,ss) by Th17;
end;

theorem Th68:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a > 0 & Directed I is_pseudo-closed_on s holds
  if>0(a,I,J) is_halting_on s & if>0(a,I,J) is_closed_on s &
  LifeSpan (s +* (if>0(a,I,J) +* Start-At insloc 0)) =
  LifeSpan (s +* (I ';' Stop SCM+FSA +* Start-At insloc 0)) + 1
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I0 = Directed I;
  set I1 = I ';' Stop SCM+FSA;
  set s00 = s +* (I0 +* Start-At insloc 0);
  set s3 = s +* (if>0(a,I,J) +* Start-At insloc 0);
  set s4 =  Computation( s3,1);
  set i = a >0_goto insloc (card J + 3);
  assume
A1: s.a > 0;
  assume
A2: I0 is_pseudo-closed_on s;
A3: if>0(a,I,J) = a >0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
A4: I0 +* Start-At insloc 0 c= s00 by FUNCT_4:26;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A5: I0 is_pseudo-closed_on s00 by A2,Th52;
A6: insloc 0 in dom if>0(a,I,J) by Th54;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A7: dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
A8: IC SCM+FSA in dom (if>0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
A9: now thus IC s3 = (if>0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by A8,
    FUNCT_4:14
      .= insloc 0 by SF_MASTR:66;
  end;
A10: now thus s3.insloc 0
    = (if>0(a,I,J) +* Start-At insloc 0).insloc 0 by A6,A7,FUNCT_4:14
      .= if>0(a,I,J).insloc 0 by A6,SCMFSA6B:7
      .= i by Th55;
  end;
A11: now thus  Computation( s3,0+1)
    = Following  Computation( s3,0) by AMI_1:14
      .= Following s3 by AMI_1:13
      .= Exec(i,s3) by A9,A10;
  end;
A12: now thus card (i ';' J ';' Goto insloc (card I + 1))
      = card (Macro i ';' J) + card Goto insloc (card I + 1) by SCMFSA6A:61
      .= card (Macro i ';' J) + 1 by SCMFSA8A:29
      .= card Macro i + card J + 1 by SCMFSA6A:61
      .= card J + 2 + 1 by SCMFSA7B:6
      .= card J + (2 + 1);
  end;
  not a in dom (if>0(a,I,J) +* Start-At insloc 0) & a in dom s
  by SCMFSA6B:12,SCMFSA_2:66;
  then
A13: s3.a = s.a by FUNCT_4:12;
A14: if>0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A15: if>0(a,I,J) c= s3 by A14,XBOOLE_1:1;
  if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by A3,SCMFSA6A:67;
  then ProgramPart Relocated(I1,card J + 3) c= if>0(a,I,J) by A12,FUNCT_4:26;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A15,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(I1,card J + 3)] c= s4 by AMI_1:99;
  then
A16: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
  ProgramPart Relocated(I0,card J + 3) c= ProgramPart Relocated(I1,card J + 3)
  by Th12,SCMFSA6A:55;
  then
A17: ProgramPart Relocated(I0,card J + 3) c= s4 by A16,XBOOLE_1:1;
A18: IC Computation(s3,1) = insloc (card J + 3) by A1,A11,A13,SCMFSA_2:97;
A19: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A20: now
    let a be Int-Location;
    thus s00.a = s3.a by A19,SCMFSA6A:38
      .= s4.a by A11,SCMFSA_2:97;
  end;
  now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A19,SCMFSA6A:38
      .= s4.f by A11,SCMFSA_2:97;
  end;
  then
A21: DataPart s00 = DataPart s4 by A20,SCMFSA6A:38;
A22: if>0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  now thus card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
      .= card I + card J + 3 + 1;
  end;
  then card I + card J + 3 < card if>0(a,I,J) by NAT_1:13;
  then
A23: insloc (card I + card J + 3) in dom if>0(a,I,J) by SCMFSA6A:15;
A24: now thus IC  Computation( s3,pseudo-LifeSpan(s00,I0) + 1)
    = IC  Computation( s4,pseudo-LifeSpan(s00,I0)) by AMI_1:51
      .= IC  Computation( s00,pseudo-LifeSpan(s00,I0)) + (card J + 3)
    by A4,A5,A17,A18,A21,Th51
      .= IC  Computation( s00,pseudo-LifeSpan(s,I0)) + (card J + 3) by A2,Th50
      .= insloc card ProgramPart I0 + (card J + 3) by A2,SCMFSA8A:def 5
      .= insloc card I0 + (card J + 3) by AMI_1:105
      .= insloc (card I + (card J + 3)) by SCMFSA8A:34
      .= insloc (card I + card J + 3);
  end;
  then
A25: CurInstr  Computation( s3,pseudo-LifeSpan(s00,I0) + 1)
  = s3.insloc (card I + card J + 3) by AMI_1:54
    .= if>0(a,I,J).insloc (card I + card J + 3) by A22,A23,GRFUNC_1:8
    .= halt SCM+FSA by Th62;
  then
A26: s3 is halting by AMI_1:def 20;
  hence if>0(a,I,J) is_halting_on s by SCMFSA7B:def 8;
  now
    let k be Element of NAT;
    per cases;
    suppose k = 0;
      then  Computation( s3,k) = s3 by AMI_1:13;
      then IC  Computation( s3,k) = insloc 0 by Th31;
      hence IC  Computation( s3,k) in dom if>0(a,I,J) by Th54;
    end;
    suppose
A27:  0 < k & k < pseudo-LifeSpan(s00,I0) + 1;
      then 0 + 1 <= k by INT_1:20;
      then consider k1 being Nat such that
A28:  1 + k1 = k by NAT_1:10;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
A29:  k1 < pseudo-LifeSpan(s00,I0) by A27,A28,XREAL_1:8;
      then
A30:  k1 < pseudo-LifeSpan(s,I0) by A2,Th50;
A31:  IC  Computation( s3,k) = IC  Computation( s4,k1) by A28,AMI_1:51

.= IC  Computation( s00,k1) + (card J + 3) by A4,A5,A17,A18,A21,A29,Th51;
  reconsider n = IC  Computation( s00,k1) as Element of NAT by ORDINAL1:def 13;
      insloc n in dom I0 by A2,A30,SCMFSA8A:31;
      then n < card I0 by SCMFSA6A:15;
      then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
      then
A33:  n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
      card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
        .= card I + card J + 3 + 1;
      then card I + card J + 3 < card if>0(a,I,J) by XREAL_1:31;
      then n + (card J + 3) < card if>0(a,I,J) by A33,XXREAL_0:2;
      hence IC Computation( s3,k) in dom if>0(a,I,J) by A31,SCMFSA6A:15;
    end;
    suppose 0 < k & pseudo-LifeSpan(s00,I0) + 1 <= k;
      hence IC  Computation( s3,k) in dom if>0(a,I,J) by A23,A24,A25,AMI_1:52;
    end;
  end;
  hence if>0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
  now
    let k be Element of NAT;
    assume
A34: CurInstr  Computation( s3,k) = halt SCM+FSA;
    assume not pseudo-LifeSpan(s00,I0) + 1 <= k;
    then
A35: k <= pseudo-LifeSpan(s00,I0) by NAT_1:13;
A36: insloc 0 in dom if>0(a,I,J) by Th54;
A37: InsCode halt SCM+FSA = 0 & InsCode (a >0_goto insloc (card J + 3)) = 8
    by SCMFSA_2:49,124;
    CurInstr  Computation( s3,0) = CurInstr s3 by AMI_1:13
      .= s3.insloc 0 by Th31
      .= if>0(a,I,J).insloc 0 by A36,Th26
      .= a >0_goto insloc (card J + 3) by Th55;
    then consider k1 being Nat such that
A38: k1 + 1 = k by A34,A37,NAT_1:6;
    reconsider k1 as Element of NAT by ORDINAL1:def 13;
    k1 < k by A38,XREAL_1:31;
    then
A39: k1 < pseudo-LifeSpan(s00,I0) by A35,XXREAL_0:2;
A40: IC  Computation( s3,k) = IC  Computation( s4,k1) by A38,AMI_1:51
      .= IC  Computation( s00,k1) + (card J + 3) by A4,A5,A17,A18,A21,A39,Th51;
  reconsider n = IC  Computation( s00,k1) as Element of NAT by ORDINAL1:def 13;
    k1 < pseudo-LifeSpan(s,I0) by A2,A39,Th50;
    then insloc n in dom I0 by A2,SCMFSA8A:31;
    then n < card I0 by SCMFSA6A:15;
    then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
    then
A42: n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
    card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
      .= card I + card J + 3 + 1;
    then card I + card J + 3 < card if>0(a,I,J) by XREAL_1:31;
    then n + (card J + 3) < card if>0(a,I,J) by A42,XXREAL_0:2;
    then
A43: IC  Computation( s3,k) in dom if>0(a,I,J) by A40,SCMFSA6A:15;
    set J1 = a >0_goto insloc (card J + 3) ';' J ';'
    Goto insloc (card I + 1) ';' I;
    card J1
      = card (Macro (a >0_goto insloc (card J + 3)) ';' J ';'
    Goto insloc (card I + 1)) + card I by SCMFSA6A:61
      .= card (Macro (a >0_goto insloc (card J + 3)) ';' J) +
    card Goto insloc (card I + 1) + card I by SCMFSA6A:61
      .= card (Macro (a >0_goto insloc (card J + 3)) ';' J) + 1 + card I
    by SCMFSA8A:29
      .= card Macro (a >0_goto insloc (card J + 3)) + card J + 1 + card I
    by SCMFSA6A:61
      .= 2 + card J + 1 + card I by SCMFSA7B:6
      .= card I + card J + 3;
    then IC  Computation( s3,k) in dom J1 by A40,A42,SCMFSA6A:15;
    then
A44: IC  Computation( s3,k) in dom Directed J1 by FUNCT_4:105;
    Directed J1 c= if>0(a,I,J) by A3,SCMFSA6A:55;
    then
A45: if>0(a,I,J).IC  Computation( s3,k) = (Directed J1).IC  Computation( s3,k)
    by A44,GRFUNC_1:8;
A46: (Directed J1).IC  Computation( s3,k) in
    rng Directed J1 by A44,FUNCT_1:def 5;
    CurInstr  Computation( s3,k) = s3.IC  Computation( s3,k) by AMI_1:54
      .= if>0(a,I,J).IC  Computation( s3,k) by A43,Th26;
    hence contradiction by A34,A45,A46,AMI_1:def 52;
  end;
  then
A47: LifeSpan s3 = pseudo-LifeSpan(s00,I0) + 1 by A25,A26,AMI_1:def 46;
  pseudo-LifeSpan(s,I0) =
  LifeSpan (s +* (I1 +* Start-At insloc 0)) by A2,Th58;
  hence LifeSpan s3 = LifeSpan (s +* (I1 +* Start-At insloc 0)) + 1
  by A2,A47,Th50;
end;

theorem Th69:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.intloc 0 = 1 & s.a > 0 & Directed I is_pseudo-closed_on s holds
  DataPart IExec(if>0(a,I,J),s) = DataPart IExec(I ';' Stop SCM+FSA,s)
proof
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  let ss be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I0 = Directed I;
  set s = Initialize ss;
  set I1 = I ';' Stop SCM+FSA;
  set s00 = s +* (I0 +* Start-At insloc 0);
  set s3 = s +* (if>0(a,I,J) +* Start-At insloc 0);
  set s4 =  Computation( s3,1);
  set i = a >0_goto insloc (card J + 3);
  assume
A1: ss.intloc 0 = 1;
  assume ss.a > 0;
  then
A2: s.a > 0 by SCMFSA6C:3;
  assume I0 is_pseudo-closed_on ss;
  then
A3: I0 is_pseudo-closed_on s by A1,Th53;
A4: if>0(a,I,J) = a >0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
A5: I0 +* Start-At insloc 0 c= s00 by FUNCT_4:26;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A6: I0 is_pseudo-closed_on s00 by A3,Th52;
A7: insloc 0 in dom if>0(a,I,J) by Th54;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A8: dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
A9: IC SCM+FSA in dom (if>0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
A10: now thus IC s3 = (if>0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by A9,
    FUNCT_4:14
      .= insloc 0 by SF_MASTR:66;
  end;
A11: now thus s3.insloc 0
    = (if>0(a,I,J) +* Start-At insloc 0).insloc 0 by A7,A8,FUNCT_4:14
      .= if>0(a,I,J).insloc 0 by A7,SCMFSA6B:7
      .= i by Th55;
  end;
A12: now thus  Computation( s3,0+1)
    = Following  Computation( s3,0) by AMI_1:14
      .= Following s3 by AMI_1:13
      .= Exec(i,s3) by A10,A11;
  end;
A13: now thus card (i ';' J ';' Goto insloc (card I + 1))
      = card (Macro i ';' J) + card Goto insloc (card I + 1) by SCMFSA6A:61
      .= card (Macro i ';' J) + 1 by SCMFSA8A:29
      .= card Macro i + card J + 1 by SCMFSA6A:61
      .= card J + 2 + 1 by SCMFSA7B:6
      .= card J + (2 + 1);
  end;
  not a in dom (if>0(a,I,J) +* Start-At insloc 0) & a in dom s
  by SCMFSA6B:12,SCMFSA_2:66;
  then
A14: s3.a = s.a by FUNCT_4:12;
A15: if>0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A16: if>0(a,I,J) c= s3 by A15,XBOOLE_1:1;
  if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by A4,SCMFSA6A:67;
  then ProgramPart Relocated(I1,card J + 3) c= if>0(a,I,J) by A13,FUNCT_4:26;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A16,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(I1,card J + 3)] c= s4 by AMI_1:99;
  then
A17: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
  ProgramPart Relocated(I0,card J + 3) c= ProgramPart Relocated(I1,card J + 3)
  by Th12,SCMFSA6A:55;
  then
A18: ProgramPart Relocated(I0,card J + 3) c= s4 by A17,XBOOLE_1:1;
A19: IC Computation(s3,1) = insloc (card J + 3) by A2,A12,A14,SCMFSA_2:97;
A20: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A21: now
    let a be Int-Location;
    thus s00.a = s3.a by A20,SCMFSA6A:38
      .= s4.a by A12,SCMFSA_2:97;
  end;
  now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A20,SCMFSA6A:38
      .= s4.f by A12,SCMFSA_2:97;
  end;
  then
A22: DataPart s00 = DataPart s4 by A21,SCMFSA6A:38;
A23: if>0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  now thus card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
      .= card I + card J + 3 + 1;
  end;
  then card I + card J + 3 < card if>0(a,I,J) by NAT_1:13;
  then
A24: insloc (card I + card J + 3) in dom if>0(a,I,J) by SCMFSA6A:15;
  now thus IC  Computation( s3,pseudo-LifeSpan(s00,I0) + 1)
    = IC  Computation( s4,pseudo-LifeSpan(s00,I0)) by AMI_1:51
      .= IC  Computation( s00,pseudo-LifeSpan(s00,I0)) + (card J + 3)
    by A5,A6,A18,A19,A22,Th51
      .= IC  Computation( s00,pseudo-LifeSpan(s,I0)) + (card J + 3) by A3,Th50
      .= insloc card ProgramPart I0 + (card J + 3) by A3,SCMFSA8A:def 5
      .= insloc card I0 + (card J + 3) by AMI_1:105
      .= insloc (card I + (card J + 3)) by SCMFSA8A:34
      .= insloc (card I + card J + 3);
  end;
  then
A25: CurInstr  Computation( s3,pseudo-LifeSpan(s00,I0) + 1)
  = s3.insloc (card I + card J + 3) by AMI_1:54
    .= if>0(a,I,J).insloc (card I + card J + 3) by A23,A24,GRFUNC_1:8
    .= halt SCM+FSA by Th62;
  then
A26: s3 is halting by AMI_1:def 20;
  now
    let k be Element of NAT;
    assume
A27: CurInstr  Computation( s3,k) = halt SCM+FSA;
    assume not pseudo-LifeSpan(s00,I0) + 1 <= k;
    then
A28: k <= pseudo-LifeSpan(s00,I0) by NAT_1:13;
A29: insloc 0 in dom if>0(a,I,J) by Th54;
A30: InsCode halt SCM+FSA = 0 & InsCode (a >0_goto insloc (card J + 3)) = 8
    by SCMFSA_2:49,124;
    CurInstr  Computation( s3,0) = CurInstr s3 by AMI_1:13
      .= s3.insloc 0 by Th31
      .= if>0(a,I,J).insloc 0 by A29,Th26
      .= a >0_goto insloc (card J + 3) by Th55;
    then consider k1 being Nat such that
A31: k1 + 1 = k by A27,A30,NAT_1:6;
    reconsider k1 as Element of NAT by ORDINAL1:def 13;
    k1 < k by A31,XREAL_1:31;
    then
A32: k1 < pseudo-LifeSpan(s00,I0) by A28,XXREAL_0:2;
A33: IC  Computation( s3,k) = IC  Computation( s4,k1) by A31,AMI_1:51
      .= IC  Computation( s00,k1) + (card J + 3) by A5,A6,A18,A19,A22,A32,Th51;
  reconsider n = IC  Computation( s00,k1) as Element of NAT by ORDINAL1:def 13;
    k1 < pseudo-LifeSpan(s,I0) by A3,A32,Th50;
    then insloc n in dom I0 by A3,SCMFSA8A:31;
    then n < card I0 by SCMFSA6A:15;
    then n + (card J + 3) < card I0 + (card J + 3) by XREAL_1:8;
    then
A35: n + (card J + 3) < card I + (card J + 3) by SCMFSA8A:34;
    card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
      .= card I + card J + 3 + 1;
    then card I + card J + 3 < card if>0(a,I,J) by XREAL_1:31;
    then n + (card J + 3) < card if>0(a,I,J) by A35,XXREAL_0:2;
    then
A36: IC  Computation( s3,k) in dom if>0(a,I,J) by A33,SCMFSA6A:15;
    set J1 = a >0_goto insloc (card J + 3) ';' J ';'
    Goto insloc (card I + 1) ';' I;
    card J1
      = card (Macro (a >0_goto insloc (card J + 3)) ';' J ';'
    Goto insloc (card I + 1)) + card I by SCMFSA6A:61
      .= card (Macro (a >0_goto insloc (card J + 3)) ';' J) +
    card Goto insloc (card I + 1) + card I by SCMFSA6A:61
      .= card (Macro (a >0_goto insloc (card J + 3)) ';' J) + 1 + card I
    by SCMFSA8A:29
      .= card Macro (a >0_goto insloc (card J + 3)) + card J + 1 + card I
    by SCMFSA6A:61
      .= 2 + card J + 1 + card I by SCMFSA7B:6
      .= card I + card J + 3;
    then IC  Computation( s3,k) in dom J1 by A33,A35,SCMFSA6A:15;
    then
A37: IC  Computation( s3,k) in dom Directed J1 by FUNCT_4:105;
    Directed J1 c= if>0(a,I,J) by A4,SCMFSA6A:55;
    then
A38: if>0(a,I,J).IC  Computation( s3,k) = (Directed J1).IC  Computation( s3,k)
    by A37,GRFUNC_1:8;
A39: (Directed J1).IC  Computation( s3,k) in
    rng Directed J1 by A37,FUNCT_1:def 5;
    CurInstr  Computation( s3,k) = s3.IC  Computation( s3,k) by AMI_1:54
      .= if>0(a,I,J).IC  Computation( s3,k) by A36,Th26;
    hence contradiction by A27,A38,A39,AMI_1:def 52;
  end;
  then
A40: LifeSpan s3 = pseudo-LifeSpan(s00,I0) + 1 by A25,A26,AMI_1:def 46;
  set s1 = s +* (I1 +* Start-At insloc 0);
  s +* Initialized if>0(a,I,J) =
  Initialize s +* (if>0(a,I,J) +* Start-At insloc 0) &
  s +* Initialized I1 = Initialize s +* (I1 +* Start-At insloc 0)
  by SCMFSA8A:13;
  then
A41: s +* Initialized if>0(a,I,J) = s3 & s +* Initialized I1 = s1 by Th15;
A42: I1 is_halting_on s & LifeSpan s1 = pseudo-LifeSpan(s,I0) by A3,Th58;
  then
A43: s1 is halting by SCMFSA7B:def 8;
A44: Directed I0 = I0 by SCMFSA6A:63;
  I0 ';' Stop SCM+FSA = I1 & Directed I0 is_pseudo-closed_on s
  by A3,SCMFSA6A:63,SCMFSA8A:41;
  then
A45: DataPart Computation( s00,pseudo-LifeSpan(s,I0)) =
   DataPart Computation( s1,pseudo-LifeSpan(s,I0)) by A44,Th58;
  thus DataPart IExec(if>0(a,I,J),ss) = DataPart IExec(if>0(a,I,J),s) by Th17
    .= DataPart(Result (s +* Initialized if>0(a,I,J)) +* s | A)
     by SCMFSA6B:def 1
    .= DataPart Result s3 by A41,Th35
    .= DataPart Computation( s3,LifeSpan  s3) by A26,AMI_1:122
    .= DataPart Computation( s4,pseudo-LifeSpan(s00,I0)) by A40,AMI_1:51
    .= DataPart Computation( s00,pseudo-LifeSpan(s00,I0))
     by A5,A6,A18,A19,A22,Th51
    .= DataPart Computation( s1,LifeSpan  s1) by A3,A42,A45,Th50
    .= DataPart Result s1 by A43,AMI_1:122
    .= DataPart(Result (s +* Initialized I1) +* s | A) by A41,Th35
    .= DataPart IExec(I1,s) by SCMFSA6B:def 1
    .= DataPart IExec(I1,ss) by Th17;
end;

theorem Th70:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a <> 0 & Directed J is_pseudo-closed_on s holds
  if=0(a,I,J) is_halting_on s & if=0(a,I,J) is_closed_on s &
  LifeSpan (s +* (if=0(a,I,J) +* Start-At insloc 0)) =
  LifeSpan (s +* (J ';' Stop SCM+FSA +* Start-At insloc 0)) + 3
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set J0 = Directed J;
  set s0 = Initialize s;
  set J9 = J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA));
  set s00 = s +* (J0 +* Start-At insloc 0);
  set s3 = s +* (if=0(a,I,J) +* Start-At insloc 0);
  set s4 =  Computation( s3,1);
  set s5 =  Computation( s3,2);
  set i = a =0_goto insloc (card J + 3);
  assume s.a <> 0;
  then
A1: s0.a <> 0 by SCMFSA6C:3;
A2: s3.a = s.a by Th28
    .= s0.a by SCMFSA6C:3;
  assume
A3: J0 is_pseudo-closed_on s;
A4: if=0(a,I,J) = a =0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
A5: J0 +* Start-At insloc 0 c= s00 by FUNCT_4:26;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A6: J0 is_pseudo-closed_on s00 by A3,Th52;
A7: insloc 0 in dom if=0(a,I,J) by Th54;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A8: dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
  IC SCM+FSA in dom (if=0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
  then
A9: IC s3 = (if=0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A10: s3.insloc 0 = (if=0(a,I,J) +* Start-At insloc 0).insloc 0 by A7,A8,
  FUNCT_4:14
    .= if=0(a,I,J).insloc 0 by A7,SCMFSA6B:7
    .= i by Th55;
  then
A11: CurInstr s3 = i by A9;
A12: now thus  Computation( s3,0+1)
    = Following  Computation( s3,0) by AMI_1:14
      .= Following s3 by AMI_1:13
      .= Exec(i,s3) by A9,A10;
  end;
A13: now thus IC s4 = Next IC s3 by A1,A2,A12,SCMFSA_2:96
      .= insloc (0 + 1) by A9;
  end;
A14: insloc 1 in dom if=0(a,I,J) by Th54;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A15: dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
A16: now thus s4.insloc 1 = s3.insloc 1 by AMI_1:54
      .= (if=0(a,I,J) +* Start-At insloc 0).insloc 1 by A14,A15,FUNCT_4:14
      .= if=0(a,I,J).insloc 1 by A14,SCMFSA6B:7
      .= goto insloc 2 by Th55;
  end;
A17:  Computation( s3,1+1) = Following s4 by AMI_1:14
    .= Exec(goto insloc 2,s4) by A13,A16;
A18: card Macro i = 2 by SCMFSA7B:6;
A19: if=0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A20: if=0(a,I,J) c= s3 by A19,XBOOLE_1:1;
  if=0(a,I,J) = Macro i ';' J ';' Goto insloc (card I + 1) ';'
  (I ';' Stop SCM+FSA) by A4,SCMFSA6A:67;
  then if=0(a,I,J) = Macro i ';' J ';' (Goto insloc (card I + 1) ';'
  (I ';' Stop SCM+FSA)) by SCMFSA6A:67;
  then if=0(a,I,J) = Macro i ';' (J ';' (Goto insloc (card I + 1) ';'
  (I ';' Stop SCM+FSA))) by SCMFSA6A:67;
  then ProgramPart Relocated(J9,2) c= if=0(a,I,J) by A18,FUNCT_4:26;
  then ProgramPart Relocated(J9,2) c= s3 by A20,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(J9,2)] c= s5 by AMI_1:99;
  then
A21: ProgramPart Relocated(J9,2) c= s5 by AMI_1:105;
  ProgramPart Relocated(J0,2) c= ProgramPart Relocated(J9,2) by Th12,SCMFSA6A
  :55;
  then
A22: ProgramPart Relocated(J0,2) c= s5 by A21,XBOOLE_1:1;
A23: IC s5 = insloc 2 by A17,SCMFSA_2:95;
A24: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A25: now
    let a be Int-Location;
    thus s00.a = s3.a by A24,SCMFSA6A:38
      .= s4.a by A12,SCMFSA_2:96
      .= s5.a by A17,SCMFSA_2:95;
  end;
  now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A24,SCMFSA6A:38
      .= s4.f by A12,SCMFSA_2:96
      .= s5.f by A17,SCMFSA_2:95;
  end;
  then
A26: DataPart s00 = DataPart s5 by A25,SCMFSA6A:38;
A27: if=0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  now thus card if=0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:14
      .= card J + 2 + (card I + 2);
  end;
  then
A28: card J + 2 + 0 < card if=0(a,I,J) by XREAL_1:10;
  then
A29: insloc (card J + 2) in dom if=0(a,I,J) by SCMFSA6A:15;
  set ss =  Computation( s3,pseudo-LifeSpan(s00,J0) + 2);
A30: now thus IC ss = IC  Computation( s5,pseudo-LifeSpan(s00,J0)) by AMI_1:51
      .= IC  Computation( s00,pseudo-LifeSpan(s00,J0)) + 2
    by A5,A6,A22,A23,A26,Th51
      .= IC  Computation( s00,pseudo-LifeSpan(s,J0)) + 2 by A3,Th50
      .= insloc card ProgramPart J0 + 2 by A3,SCMFSA8A:def 5
      .= insloc card J0 + 2 by AMI_1:105
      .= insloc (card J + 2) by SCMFSA8A:34;
  end;
  then
A31: CurInstr ss = s3.insloc (card J + 2) by AMI_1:54
    .= if=0(a,I,J).insloc (card J + 2) by A27,A29,GRFUNC_1:8
    .= goto insloc (card I + card J + 3) by Th63;
A32: if=0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  now thus card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
      .= card I + card J + 3 + 1;
  end;
  then card I + card J + 3 < card if=0(a,I,J) by NAT_1:13;
  then
A33: insloc (card I + card J + 3) in dom if=0(a,I,J) by SCMFSA6A:15;
A34: now thus IC  Computation( s3,pseudo-LifeSpan(s00,J0) + 2 + 1)
    = IC Following ss by AMI_1:14
      .= insloc (card I + card J + 3) by A31,SCMFSA_2:95;
  end;
  then
A35: CurInstr  Computation( s3,pseudo-LifeSpan(s00,J0) + 2 + 1)
  = s3.insloc (card I + card J + 3) by AMI_1:54
    .= if=0(a,I,J).insloc (card I + card J + 3) by A32,A33,GRFUNC_1:8
    .= halt SCM+FSA by Th61;
  then
A36: s3 is halting by AMI_1:def 20;
  hence if=0(a,I,J) is_halting_on s by SCMFSA7B:def 8;
  now
    let k be Element of NAT;
    per cases;
    suppose k = 0;
      then  Computation( s3,k) = s3 by AMI_1:13;
      then IC  Computation( s3,k) = insloc 0 by Th31;
      hence IC  Computation( s3,k) in dom if=0(a,I,J) by Th54;
    end;
    suppose 0 < k & k = 1;
      hence IC  Computation( s3,k) in dom if=0(a,I,J) by A13,Th54;
    end;
    suppose
A37:  0 < k & k <> 1 & k < pseudo-LifeSpan(s00,J0) + 2;
      then 0 + 1 <= k by INT_1:20;
      then 1 < k by A37,REAL_1:def 5;
      then 0 + (1 + 1) <= k by INT_1:20;
      then consider k2 being Nat such that
A38:  2 + k2 = k by NAT_1:10;
      reconsider k2 as Element of NAT by ORDINAL1:def 13;
A39:  k2 < pseudo-LifeSpan(s00,J0) by A37,A38,XREAL_1:8;
      then
A40:  k2 < pseudo-LifeSpan(s,J0) by A3,Th50;
A41:  IC  Computation( s3,k) = IC  Computation( s5,k2) by A38,AMI_1:51
        .= IC  Computation( s00,k2) + 2 by A5,A6,A22,A23,A26,A39,Th51;
  reconsider n = IC  Computation( s00,k2) as Element of NAT by ORDINAL1:def 13;
      insloc n in dom J0 by A3,A40,SCMFSA8A:31;
      then n < card J0 by SCMFSA6A:15;
      then n + 2 < card J0 + 2 by XREAL_1:8;
      then
A43:  n + 2 < card J + 2 by SCMFSA8A:34;
      card if=0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:14
        .= card J + 2 + (card I + 2);
      then card J + 2 <= card if=0(a,I,J) by NAT_1:12;
      then n + 2 < card if=0(a,I,J) by A43,XXREAL_0:2;
     hence IC  Computation( s3,k) in dom if=0(a,I,J) by A41,SCMFSA6A:15;
    end;
    suppose
A44:  0 < k & k <> 1 & pseudo-LifeSpan(s00,J0) + 2 <= k;
      hereby per cases by A44,REAL_1:def 5;
        suppose pseudo-LifeSpan(s00,J0) + 2 = k;

hence IC  Computation( s3,k) in dom if=0(a,I,J) by A28,A30,SCMFSA6A:15;
        end;
        suppose pseudo-LifeSpan(s00,J0) + 2 < k;
          then pseudo-LifeSpan(s00,J0) + 2 + 1 <= k by INT_1:20;

hence IC  Computation( s3,k) in dom if=0(a,I,J) by A33,A34,A35,AMI_1:52;
        end;
      end;
    end;
  end;
  hence if=0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
  now
    let k be Element of NAT;
    assume
A45: CurInstr  Computation( s3,k) = halt SCM+FSA;
    assume
A46: not pseudo-LifeSpan(s00,J0) + (1 + 2) <= k;
    CurInstr  Computation( s3,0) = i by A11,AMI_1:13;
    then
A47: k <> 0 & k <> 1 by A13,A16,A45,SCMFSA_2:47,48,124;
    0 + 2 < card I + card J + 3 by XREAL_1:10;
    then
A48: insloc 2 in dom if=0(a,I,J) & if=0(a,I,J).insloc 2 <> halt SCM+FSA
    by Th56;
    CurInstr  Computation( s3,2) = s3.insloc 2 by A23,AMI_1:54
      .= if=0(a,I,J).insloc 2 by A48,Th26;
    then 2 < k by A45,A47,A48,NAT_1:27;
    then consider k2 being Nat such that
A49: 2 + k2 = k by NAT_1:10;
    reconsider k2 as Element of NAT by ORDINAL1:def 13;
    k < pseudo-LifeSpan(s00,J0) + 1 + 2 by A46;
    then k2 < pseudo-LifeSpan(s00,J0) + 1 by A49,XREAL_1:8;
    then
A50: k2 <= pseudo-LifeSpan(s00,J0) by NAT_1:13;
  reconsider n = IC  Computation( s00,k2) as Element of NAT by ORDINAL1:def 13;
A52: IC  Computation( s3,k) = IC  Computation( s5,k2) by A49,AMI_1:51
      .= insloc (n + 2) by A5,A6,A22,A23,A26,A50,Th51;
A53: k2 <= pseudo-LifeSpan(s,J0) by A3,A50,Th50;
A54: now per cases by A53,REAL_1:def 5;
      suppose k2 = pseudo-LifeSpan(s,J0);
        then IC  Computation( s00,k2) = insloc card ProgramPart J0
        by A3,SCMFSA8A:def 5
          .= insloc card J0 by AMI_1:105;
        then
A55:    n = card J by SCMFSA8A:34;
        card I + card J + (2 + 1) = card J + 2 + 1 + card I;
        then card J + 2 + 1 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A55,NAT_1:13;
      end;
      suppose k2 < pseudo-LifeSpan(s,J0);
        then insloc n in dom J0 by A3,SCMFSA8A:31;
        then n < card J0 by SCMFSA6A:15;
        then n + 2 < card J0 + 2 by XREAL_1:8;
        then
A56:    n + 2 < card J + 2 by SCMFSA8A:34;
        card I + card J + (1 + 2) = card J + 2 + (card I + 1);
        then card J + 2 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A56,XXREAL_0:2;
      end;
    end;
    then
A57: insloc (n + 2) in dom if=0(a,I,J) &
    if=0(a,I,J).insloc (n + 2) <> halt SCM+FSA by Th56;
    CurInstr  Computation( s3,k) = s3.IC  Computation( s3,k) by AMI_1:54
      .= if=0(a,I,J).IC  Computation( s3,k) by A52,A57,Th26;
    hence contradiction by A45,A52,A54,Th56;
  end;
  then
A58: LifeSpan s3 = pseudo-LifeSpan(s00,J0) + 3 by A35,A36,AMI_1:def 46;
  pseudo-LifeSpan(s,J0) =
  LifeSpan (s +* (J ';' Stop SCM+FSA +* Start-At insloc 0)) by A3,Th58;
  hence LifeSpan (s +* (if=0(a,I,J) +* Start-At insloc 0)) =
  LifeSpan (s +* (J ';' Stop SCM+FSA +* Start-At insloc 0)) + 3
  by A3,A58,Th50;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.intloc 0 = 1 & s.a <> 0 & Directed J is_pseudo-closed_on s holds
  DataPart IExec(if=0(a,I,J),s) = DataPart IExec(J ';' Stop SCM+FSA,s)
proof
  set A = NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  let ss be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set J0 = Directed J;
  set s = Initialize ss;
  set s0 = Initialize s;
  set J9 = J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA));
  set s00 = s +* (J0 +* Start-At insloc 0);
  set s3 = s +* (if=0(a,I,J) +* Start-At insloc 0);
  set s4 =  Computation( s3,1);
  set s5 =  Computation( s3,2);
  set i = a =0_goto insloc (card J + 3);
  assume
A1: ss.intloc 0 = 1;
  assume ss.a <> 0;
  then s.a <> 0 by SCMFSA6C:3;
  then
A2: s0.a <> 0 by SCMFSA6C:3;
A3: s3.a = s.a by Th28
    .= s0.a by SCMFSA6C:3;
  assume J0 is_pseudo-closed_on ss;
  then
A4: J0 is_pseudo-closed_on s by A1,Th53;
A5: if=0(a,I,J) = a =0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
A6: J0 +* Start-At insloc 0 c= s00 by FUNCT_4:26;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A7: J0 is_pseudo-closed_on s00 by A4,Th52;
A8: insloc 0 in dom if=0(a,I,J) by Th54;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A9: dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
  IC SCM+FSA in dom (if=0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
  then
A10: IC s3 = (if=0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A11: s3.insloc 0 = (if=0(a,I,J) +* Start-At insloc 0).insloc 0 by A8,A9,
  FUNCT_4:14
    .= if=0(a,I,J).insloc 0 by A8,SCMFSA6B:7
    .= i by Th55;
  then
A12: CurInstr s3 = i by A10;
A13: now thus  Computation( s3,0+1)
    = Following  Computation( s3,0) by AMI_1:14
      .= Following s3 by AMI_1:13
      .= Exec(i,s3) by A10,A11;
  end;
A14: now thus IC s4 = Next IC s3 by A2,A3,A13,SCMFSA_2:96
      .= insloc (0 + 1) by A10;
  end;
A15: insloc 1 in dom if=0(a,I,J) by Th54;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A16: dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
A17: now thus s4.insloc 1 = s3.insloc 1 by AMI_1:54
      .= (if=0(a,I,J) +* Start-At insloc 0).insloc 1 by A15,A16,FUNCT_4:14
      .= if=0(a,I,J).insloc 1 by A15,SCMFSA6B:7
      .= goto insloc 2 by Th55;
  end;
A18:  Computation( s3,1+1) = Following s4 by AMI_1:14
    .= Exec(goto insloc 2,s4) by A14,A17;
A19: card Macro i = 2 by SCMFSA7B:6;
A20: if=0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A21: if=0(a,I,J) c= s3 by A20,XBOOLE_1:1;
  if=0(a,I,J) = Macro i ';' J ';' Goto insloc (card I + 1) ';'
  (I ';' Stop SCM+FSA) by A5,SCMFSA6A:67;
  then if=0(a,I,J) = Macro i ';' J ';' (Goto insloc (card I + 1) ';'
  (I ';' Stop SCM+FSA)) by SCMFSA6A:67;
  then if=0(a,I,J) = Macro i ';' (J ';' (Goto insloc (card I + 1) ';'
  (I ';' Stop SCM+FSA))) by SCMFSA6A:67;
  then ProgramPart Relocated(J9,2) c= if=0(a,I,J) by A19,FUNCT_4:26;
  then ProgramPart Relocated(J9,2) c= s3 by A21,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(J9,2)] c= s5 by AMI_1:99;
  then
A22: ProgramPart Relocated(J9,2) c= s5 by AMI_1:105;
  ProgramPart Relocated(J0,2) c= ProgramPart Relocated(J9,2) by Th12,SCMFSA6A
  :55;
  then
A23: ProgramPart Relocated(J0,2) c= s5 by A22,XBOOLE_1:1;
A24: IC s5 = insloc 2 by A18,SCMFSA_2:95;
A25: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A26: now
    let a be Int-Location;
    thus s00.a = s3.a by A25,SCMFSA6A:38
      .= s4.a by A13,SCMFSA_2:96
      .= s5.a by A18,SCMFSA_2:95;
  end;
  now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A25,SCMFSA6A:38
      .= s4.f by A13,SCMFSA_2:96
      .= s5.f by A18,SCMFSA_2:95;
  end;
  then
A27: DataPart s00 = DataPart s5 by A26,SCMFSA6A:38;
A28: if=0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  now thus card if=0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:14
      .= card J + 2 + (card I + 2);
  end;
  then card J + 2 + 0 < card if=0(a,I,J) by XREAL_1:10;
  then
A29: insloc (card J + 2) in dom if=0(a,I,J) by SCMFSA6A:15;
  set s9 =  Computation( s3,pseudo-LifeSpan(s00,J0) + 2);
A30: now thus IC s9 = IC  Computation( s5,pseudo-LifeSpan(s00,J0)) by AMI_1:51
      .= IC  Computation( s00,pseudo-LifeSpan(s00,J0)) + 2
    by A6,A7,A23,A24,A27,Th51
      .= IC  Computation( s00,pseudo-LifeSpan(s,J0)) + 2 by A4,Th50
      .= insloc card ProgramPart J0 + 2 by A4,SCMFSA8A:def 5
      .= insloc card J0 + 2 by AMI_1:105
      .= insloc (card J + 2) by SCMFSA8A:34;
  end;
  then
A31: CurInstr s9 = s3.insloc (card J + 2) by AMI_1:54
    .= if=0(a,I,J).insloc (card J + 2) by A28,A29,GRFUNC_1:8
    .= goto insloc (card I + card J + 3) by Th63;
A32: if=0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  now thus card if=0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:14
      .= card I + card J + 3 + 1;
  end;
  then card I + card J + 3 < card if=0(a,I,J) by NAT_1:13;
  then
A33: insloc (card I + card J + 3) in dom if=0(a,I,J) by SCMFSA6A:15;
  now thus IC  Computation( s3,pseudo-LifeSpan(s00,J0) + 2 + 1)
    = IC Following s9 by AMI_1:14
      .= insloc (card I + card J + 3) by A31,SCMFSA_2:95;
  end;
  then
A34: CurInstr  Computation( s3,pseudo-LifeSpan(s00,J0) + 2 + 1)
  = s3.insloc (card I + card J + 3) by AMI_1:54
    .= if=0(a,I,J).insloc (card I + card J + 3) by A32,A33,GRFUNC_1:8
    .= halt SCM+FSA by Th61;
  then
A35: s3 is halting by AMI_1:def 20;
A36: now
    let k be Element of NAT;
    assume
A37: CurInstr  Computation( s3,k) = halt SCM+FSA;
    assume
A38: not pseudo-LifeSpan(s00,J0) + (1 + 2) <= k;
    CurInstr  Computation( s3,0) = i by A12,AMI_1:13;
    then
A39: k <> 0 & k <> 1 by A14,A17,A37,SCMFSA_2:47,48,124;
    0 + 2 < card I + card J + 3 by XREAL_1:10;
    then
A40: insloc 2 in dom if=0(a,I,J) & if=0(a,I,J).insloc 2 <> halt SCM+FSA
    by Th56;
    CurInstr  Computation( s3,2) = s3.insloc 2 by A24,AMI_1:54
      .= if=0(a,I,J).insloc 2 by A40,Th26;
    then 2 < k by A37,A39,A40,NAT_1:27;
    then consider k2 being Nat such that
A41: 2 + k2 = k by NAT_1:10;
    reconsider k2 as Element of NAT by ORDINAL1:def 13;
    k < pseudo-LifeSpan(s00,J0) + 1 + 2 by A38;
    then k2 < pseudo-LifeSpan(s00,J0) + 1 by A41,XREAL_1:8;
    then
A42: k2 <= pseudo-LifeSpan(s00,J0) by NAT_1:13;
  reconsider n = IC  Computation( s00,k2) as Element of NAT by ORDINAL1:def 13;
A44: IC  Computation( s3,k) = IC  Computation( s5,k2) by A41,AMI_1:51
      .= insloc (n + 2) by A6,A7,A23,A24,A27,A42,Th51;
A45: k2 <= pseudo-LifeSpan(s,J0) by A4,A42,Th50;
A46: now per cases by A45,REAL_1:def 5;
      suppose k2 = pseudo-LifeSpan(s,J0);
        then IC  Computation( s00,k2) = insloc card ProgramPart J0
        by A4,SCMFSA8A:def 5
          .= insloc card J0 by AMI_1:105;
        then
A47:    n = card J by SCMFSA8A:34;
        card I + card J + (2 + 1) = card J + 2 + 1 + card I;
        then card J + 2 + 1 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A47,NAT_1:13;
      end;
      suppose k2 < pseudo-LifeSpan(s,J0);
        then insloc n in dom J0 by A4,SCMFSA8A:31;
        then n < card J0 by SCMFSA6A:15;
        then n + 2 < card J0 + 2 by XREAL_1:8;
        then
A48:    n + 2 < card J + 2 by SCMFSA8A:34;
        card I + card J + (1 + 2) = card J + 2 + (card I + 1);
        then card J + 2 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A48,XXREAL_0:2;
      end;
    end;
    then
A49: insloc (n + 2) in dom if=0(a,I,J) &
    if=0(a,I,J).insloc (n + 2) <> halt SCM+FSA by Th56;
    CurInstr  Computation( s3,k) = s3.IC  Computation( s3,k) by AMI_1:54
      .= if=0(a,I,J).IC  Computation( s3,k) by A44,A49,Th26;
    hence contradiction by A37,A44,A46,Th56;
  end;
  set s1 = s +* (J ';' Stop SCM+FSA +* Start-At insloc 0);
  s +* Initialized if=0(a,I,J) =
  Initialize s +* (if=0(a,I,J) +* Start-At insloc 0) &
  s +* Initialized (J ';' Stop SCM+FSA) =
  Initialize s +* (J ';' Stop SCM+FSA +* Start-At insloc 0) by SCMFSA8A:13;
  then
A50: s +* Initialized if=0(a,I,J) = s3 &
  s +* Initialized (J ';' Stop SCM+FSA) = s1 by Th15;
A51: J ';' Stop SCM+FSA is_halting_on s & LifeSpan s1 = pseudo-LifeSpan(s,J0)
  by A4,Th58;
  then
A52: s1 is halting by SCMFSA7B:def 8;
A53: Directed J0 = J0 by SCMFSA6A:63;
  J0 ';' Stop SCM+FSA = J ';' Stop SCM+FSA &
  Directed J0 is_pseudo-closed_on s by A4,SCMFSA6A:63,SCMFSA8A:41;
  then
A54: DataPart Computation( s00,pseudo-LifeSpan(s,J0)) =
   DataPart Computation( s1,LifeSpan  s1) by A51,A53,Th58;
A55: LifeSpan s3 = pseudo-LifeSpan(s00,J0) + 2 + 1 by A34,A35,A36,AMI_1:def 46;
A56: DataPart s9
     = DataPart Computation( s5,pseudo-LifeSpan(s00,J0)) by AMI_1:51
    .= DataPart Computation( s00,pseudo-LifeSpan(s00,J0))
     by A6,A7,A23,A24,A27,Th51;
  CurInstr s9 = s3.insloc (card J + 2) by A30,AMI_1:54
    .= if=0(a,I,J).insloc (card J + 2) by A29,Th26
    .= goto insloc (card I + card J + 3) by Th63;
  then InsCode CurInstr s9 = 6 by SCMFSA_2:47;
  then InsCode CurInstr s9 in {0,6,7,8} by ENUMSET1:def 2;
  then
A57: DataPart s9 = DataPart Following s9 by Th32;
  thus DataPart IExec(if=0(a,I,J),ss)
     = DataPart IExec(if=0(a,I,J),s) by Th17
    .= DataPart(Result (s +* Initialized if=0(a,I,J)) +* s | A)
           by SCMFSA6B:def 1
    .= DataPart Result s3 by A50,Th35
    .= DataPart Computation( s3,LifeSpan  s3) by A35,AMI_1:122
    .= DataPart Following s9 by A55,AMI_1:14
    .= DataPart Computation( s00,pseudo-LifeSpan(s,J0)) by A4,A56,A57,Th50
    .= DataPart Result s1 by A52,A54,AMI_1:122

.= DataPart(Result (s +* Initialized (J ';' Stop SCM+FSA)) +* s | A)
 by A50,Th35
    .= DataPart IExec(J ';' Stop SCM+FSA,s) by SCMFSA6B:def 1
    .= DataPart IExec(J ';' Stop SCM+FSA,ss) by Th17;
end;

theorem Th72:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a <= 0 & Directed J is_pseudo-closed_on s holds
  if>0(a,I,J) is_halting_on s & if>0(a,I,J) is_closed_on s &
  LifeSpan (s +* (if>0(a,I,J) +* Start-At insloc 0)) =
  LifeSpan (s +* (J ';' Stop SCM+FSA +* Start-At insloc 0)) + 3
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set J0 = Directed J;
  set s0 = Initialize s;
  set J9 = J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA));
  set s00 = s +* (J0 +* Start-At insloc 0);
  set s3 = s +* (if>0(a,I,J) +* Start-At insloc 0);
  set s4 =  Computation( s3,1);
  set s5 =  Computation( s3,2);
  set i = a >0_goto insloc (card J + 3);
  assume s.a <= 0;
  then
A1: s0.a <= 0 by SCMFSA6C:3;
A2: s3.a = s.a by Th28
    .= s0.a by SCMFSA6C:3;
  assume
A3: J0 is_pseudo-closed_on s;
A4: if>0(a,I,J) = a >0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
A5: J0 +* Start-At insloc 0 c= s00 by FUNCT_4:26;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A6: J0 is_pseudo-closed_on s00 by A3,Th52;
A7: insloc 0 in dom if>0(a,I,J) by Th54;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A8: dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
  IC SCM+FSA in dom (if>0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
  then
A9: IC s3 = (if>0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A10: s3.insloc 0 = (if>0(a,I,J) +* Start-At insloc 0).insloc 0 by A7,A8,
  FUNCT_4:14
    .= if>0(a,I,J).insloc 0 by A7,SCMFSA6B:7
    .= i by Th55;
  then
A11: CurInstr s3 = i by A9;
A12: now thus  Computation( s3,0+1)
    = Following  Computation( s3,0) by AMI_1:14
      .= Following s3 by AMI_1:13
      .= Exec(i,s3) by A9,A10;
  end;
A13: now thus IC s4 = Next IC s3 by A1,A2,A12,SCMFSA_2:97
      .= insloc (0 + 1) by A9;
  end;
A14: insloc 1 in dom if>0(a,I,J) by Th54;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A15: dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
A16: now thus s4.insloc 1 = s3.insloc 1 by AMI_1:54
      .= (if>0(a,I,J) +* Start-At insloc 0).insloc 1 by A14,A15,FUNCT_4:14
      .= if>0(a,I,J).insloc 1 by A14,SCMFSA6B:7
      .= goto insloc 2 by Th55;
  end;
A17:  Computation( s3,1+1) = Following s4 by AMI_1:14
    .= Exec(goto insloc 2,s4) by A13,A16;
A18: card Macro i = 2 by SCMFSA7B:6;
A19: if>0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A20: if>0(a,I,J) c= s3 by A19,XBOOLE_1:1;
  if>0(a,I,J) = Macro i ';' J ';' Goto insloc (card I + 1) ';'
  (I ';' Stop SCM+FSA) by A4,SCMFSA6A:67;
  then if>0(a,I,J) = Macro i ';' J ';' (Goto insloc (card I + 1) ';'
  (I ';' Stop SCM+FSA)) by SCMFSA6A:67;
  then if>0(a,I,J) = Macro i ';' (J ';' (Goto insloc (card I + 1) ';'
  (I ';' Stop SCM+FSA))) by SCMFSA6A:67;
  then ProgramPart Relocated(J9,2) c= if>0(a,I,J) by A18,FUNCT_4:26;
  then ProgramPart Relocated(J9,2) c= s3 by A20,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(J9,2)] c= s5 by AMI_1:99;
  then
A21: ProgramPart Relocated(J9,2) c= s5 by AMI_1:105;
  ProgramPart Relocated(J0,2) c= ProgramPart Relocated(J9,2) by Th12,SCMFSA6A
  :55;
  then
A22: ProgramPart Relocated(J0,2) c= s5 by A21,XBOOLE_1:1;
A23: IC s5 = insloc 2 by A17,SCMFSA_2:95;
A24: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A25: now
    let a be Int-Location;
    thus s00.a = s3.a by A24,SCMFSA6A:38
      .= s4.a by A12,SCMFSA_2:97
      .= s5.a by A17,SCMFSA_2:95;
  end;
  now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A24,SCMFSA6A:38
      .= s4.f by A12,SCMFSA_2:97
      .= s5.f by A17,SCMFSA_2:95;
  end;
  then
A26: DataPart s00 = DataPart s5 by A25,SCMFSA6A:38;
A27: if>0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  now thus card if>0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:15
      .= card J + 2 + (card I + 2);
  end;
  then
A28: card J + 2 + 0 < card if>0(a,I,J) by XREAL_1:10;
  then
A29: insloc (card J + 2) in dom if>0(a,I,J) by SCMFSA6A:15;
  set ss =  Computation( s3,pseudo-LifeSpan(s00,J0) + 2);
A30: now thus IC ss = IC  Computation( s5,pseudo-LifeSpan(s00,J0)) by AMI_1:51
      .= IC  Computation( s00,pseudo-LifeSpan(s00,J0)) + 2
    by A5,A6,A22,A23,A26,Th51
      .= IC  Computation( s00,pseudo-LifeSpan(s,J0)) + 2 by A3,Th50
      .= insloc card ProgramPart J0 + 2 by A3,SCMFSA8A:def 5
      .= insloc card J0 + 2 by AMI_1:105
      .= insloc (card J + 2) by SCMFSA8A:34;
  end;
  then
A31: CurInstr ss = s3.insloc (card J + 2) by AMI_1:54
    .= if>0(a,I,J).insloc (card J + 2) by A27,A29,GRFUNC_1:8
    .= goto insloc (card I + card J + 3) by Th64;
A32: if>0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  now thus card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
      .= card I + card J + 3 + 1;
  end;
  then card I + card J + 3 < card if>0(a,I,J) by NAT_1:13;
  then
A33: insloc (card I + card J + 3) in dom if>0(a,I,J) by SCMFSA6A:15;
A34: now thus IC  Computation( s3,pseudo-LifeSpan(s00,J0) + 2 + 1)
    = IC Following ss by AMI_1:14
      .= insloc (card I + card J + 3) by A31,SCMFSA_2:95;
  end;
  then
A35: CurInstr  Computation( s3,pseudo-LifeSpan(s00,J0) + 2 + 1)
  = s3.insloc (card I + card J + 3) by AMI_1:54
    .= if>0(a,I,J).insloc (card I + card J + 3) by A32,A33,GRFUNC_1:8
    .= halt SCM+FSA by Th62;
  then
A36: s3 is halting by AMI_1:def 20;
  hence if>0(a,I,J) is_halting_on s by SCMFSA7B:def 8;
  now
    let k be Element of NAT;
    per cases;
    suppose k = 0;
      then  Computation( s3,k) = s3 by AMI_1:13;
      then IC  Computation( s3,k) = insloc 0 by Th31;
      hence IC  Computation( s3,k) in dom if>0(a,I,J) by Th54;
    end;
    suppose 0 < k & k = 1;
      hence IC  Computation( s3,k) in dom if>0(a,I,J) by A13,Th54;
    end;
    suppose
A37:  0 < k & k <> 1 & k < pseudo-LifeSpan(s00,J0) + 2;
      then 0 + 1 <= k by INT_1:20;
      then 1 < k by A37,REAL_1:def 5;
      then 0 + (1 + 1) <= k by INT_1:20;
      then consider k2 being Nat such that
A38:  2 + k2 = k by NAT_1:10;
      reconsider k2 as Element of NAT by ORDINAL1:def 13;
A39:  k2 < pseudo-LifeSpan(s00,J0) by A37,A38,XREAL_1:8;
      then
A40:  k2 < pseudo-LifeSpan(s,J0) by A3,Th50;
A41:  IC  Computation( s3,k) = IC  Computation( s5,k2) by A38,AMI_1:51
        .= IC  Computation( s00,k2) + 2 by A5,A6,A22,A23,A26,A39,Th51;
  reconsider n = IC  Computation( s00,k2) as Element of NAT by ORDINAL1:def 13;
      insloc n in dom J0 by A3,A40,SCMFSA8A:31;
      then n < card J0 by SCMFSA6A:15;
      then n + 2 < card J0 + 2 by XREAL_1:8;
      then
A43:  n + 2 < card J + 2 by SCMFSA8A:34;
      card if>0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:15
        .= card J + 2 + (card I + 2);
      then card J + 2 <= card if>0(a,I,J) by NAT_1:12;
      then n + 2 < card if>0(a,I,J) by A43,XXREAL_0:2;
      hence IC  Computation( s3,k) in dom if>0(a,I,J) by A41,SCMFSA6A:15;
    end;
    suppose
A44:  0 < k & k <> 1 & pseudo-LifeSpan(s00,J0) + 2 <= k;
      hereby per cases by A44,REAL_1:def 5;
        suppose pseudo-LifeSpan(s00,J0) + 2 = k;

hence IC  Computation( s3,k) in dom if>0(a,I,J) by A28,A30,SCMFSA6A:15;
        end;
        suppose pseudo-LifeSpan(s00,J0) + 2 < k;
          then pseudo-LifeSpan(s00,J0) + 2 + 1 <= k by INT_1:20;

hence IC  Computation( s3,k) in dom if>0(a,I,J) by A33,A34,A35,AMI_1:52;
        end;
      end;
    end;
  end;
  hence if>0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
  now
    let k be Element of NAT;
    assume
A45: CurInstr  Computation( s3,k) = halt SCM+FSA;
    assume
A46: not pseudo-LifeSpan(s00,J0) + (1 + 2) <= k;
    CurInstr  Computation( s3,0) = i by A11,AMI_1:13;
    then
A47: k <> 0 & k <> 1 by A13,A16,A45,SCMFSA_2:47,49,124;
    0 + 2 < card I + card J + 3 by XREAL_1:10;
    then
A48: insloc 2 in dom if>0(a,I,J) & if>0(a,I,J).insloc 2 <> halt SCM+FSA
    by Th57;
    CurInstr  Computation( s3,2) = s3.insloc 2 by A23,AMI_1:54
      .= if>0(a,I,J).insloc 2 by A48,Th26;
    then 2 < k by A45,A47,A48,NAT_1:27;
    then consider k2 being Nat such that
A49: 2 + k2 = k by NAT_1:10;
    reconsider k2 as Element of NAT by ORDINAL1:def 13;
    k < pseudo-LifeSpan(s00,J0) + 1 + 2 by A46;
    then k2 < pseudo-LifeSpan(s00,J0) + 1 by A49,XREAL_1:8;
    then
A50: k2 <= pseudo-LifeSpan(s00,J0) by NAT_1:13;
  reconsider n = IC  Computation( s00,k2) as Element of NAT by ORDINAL1:def 13;
A52: IC  Computation( s3,k) = IC  Computation( s5,k2) by A49,AMI_1:51
      .= insloc (n + 2) by A5,A6,A22,A23,A26,A50,Th51;
A53: k2 <= pseudo-LifeSpan(s,J0) by A3,A50,Th50;
A54: now per cases by A53,REAL_1:def 5;
      suppose k2 = pseudo-LifeSpan(s,J0);
        then IC  Computation( s00,k2) = insloc card ProgramPart J0
        by A3,SCMFSA8A:def 5
          .= insloc card J0 by AMI_1:105;
        then
A55:    n = card J by SCMFSA8A:34;
        card I + card J + (2 + 1) = card J + 2 + 1 + card I;
        then card J + 2 + 1 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A55,NAT_1:13;
      end;
      suppose k2 < pseudo-LifeSpan(s,J0);
        then insloc n in dom J0 by A3,SCMFSA8A:31;
        then n < card J0 by SCMFSA6A:15;
        then n + 2 < card J0 + 2 by XREAL_1:8;
        then
A56:    n + 2 < card J + 2 by SCMFSA8A:34;
        card I + card J + (1 + 2) = card J + 2 + (card I + 1);
        then card J + 2 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A56,XXREAL_0:2;
      end;
    end;
    then
A57: insloc (n + 2) in dom if>0(a,I,J) &
    if>0(a,I,J).insloc (n + 2) <> halt SCM+FSA by Th57;
    CurInstr  Computation( s3,k) = s3.IC  Computation( s3,k) by AMI_1:54
      .= if>0(a,I,J).IC  Computation( s3,k) by A52,A57,Th26;
    hence contradiction by A45,A52,A54,Th57;
  end;
  then
A58: LifeSpan s3 = pseudo-LifeSpan(s00,J0) + 3 by A35,A36,AMI_1:def 46;
  pseudo-LifeSpan(s,J0) =
  LifeSpan (s +* (J ';' Stop SCM+FSA +* Start-At insloc 0)) by A3,Th58;
  hence LifeSpan (s +* (if>0(a,I,J) +* Start-At insloc 0)) =
  LifeSpan (s +* (J ';' Stop SCM+FSA +* Start-At insloc 0)) + 3
  by A3,A58,Th50;
end;

theorem Th73:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.intloc 0 = 1 & s.a <= 0 & Directed J is_pseudo-closed_on s holds
  DataPart IExec(if>0(a,I,J),s) = DataPart IExec(J ';' Stop SCM+FSA,s)
proof
  set A = NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  let ss be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set J0 = Directed J;
  set s = Initialize ss;
  set s0 = Initialize s;
  set J9 = J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA));
  set s00 = s +* (J0 +* Start-At insloc 0);
  set s3 = s +* (if>0(a,I,J) +* Start-At insloc 0);
  set s4 =  Computation( s3,1);
  set s5 =  Computation( s3,2);
  set i = a >0_goto insloc (card J + 3);
  assume
A1: ss.intloc 0 = 1;
  assume ss.a <= 0;
  then s.a <= 0 by SCMFSA6C:3;
  then
A2: s0.a <= 0 by SCMFSA6C:3;
A3: s3.a = s.a by Th28
    .= s0.a by SCMFSA6C:3;
  assume J0 is_pseudo-closed_on ss;
  then
A4: J0 is_pseudo-closed_on s by A1,Th53;
A5: if>0(a,I,J) = a >0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
A6: J0 +* Start-At insloc 0 c= s00 by FUNCT_4:26;
  DataPart s = DataPart s00 by SCMFSA8A:11;
  then
A7: J0 is_pseudo-closed_on s00 by A4,Th52;
A8: insloc 0 in dom if>0(a,I,J) by Th54;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A9: dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
  IC SCM+FSA in dom (if>0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
  then
A10: IC s3 = (if>0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A11: s3.insloc 0 = (if>0(a,I,J) +* Start-At insloc 0).insloc 0 by A8,A9,
  FUNCT_4:14
    .= if>0(a,I,J).insloc 0 by A8,SCMFSA6B:7
    .= i by Th55;
  then
A12: CurInstr s3 = i by A10;
A13: now thus  Computation( s3,0+1)
    = Following  Computation( s3,0) by AMI_1:14
      .= Following s3 by AMI_1:13
      .= Exec(i,s3) by A10,A11;
  end;
A14: now thus IC s4 = Next IC s3 by A2,A3,A13,SCMFSA_2:97
      .= insloc (0 + 1) by A10;
  end;
A15: insloc 1 in dom if>0(a,I,J) by Th54;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A16: dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
A17: now thus s4.insloc 1 = s3.insloc 1 by AMI_1:54
      .= (if>0(a,I,J) +* Start-At insloc 0).insloc 1 by A15,A16,FUNCT_4:14
      .= if>0(a,I,J).insloc 1 by A15,SCMFSA6B:7
      .= goto insloc 2 by Th55;
  end;
A18:  Computation( s3,1+1) = Following s4 by AMI_1:14
    .= Exec(goto insloc 2,s4) by A14,A17;
A19: card Macro i = 2 by SCMFSA7B:6;
A20: if>0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A21: if>0(a,I,J) c= s3 by A20,XBOOLE_1:1;
  if>0(a,I,J) = Macro i ';' J ';' Goto insloc (card I + 1) ';'
  (I ';' Stop SCM+FSA) by A5,SCMFSA6A:67;
  then if>0(a,I,J) = Macro i ';' J ';' (Goto insloc (card I + 1) ';'
  (I ';' Stop SCM+FSA)) by SCMFSA6A:67;
  then if>0(a,I,J) = Macro i ';' (J ';' (Goto insloc (card I + 1) ';'
  (I ';' Stop SCM+FSA))) by SCMFSA6A:67;
  then ProgramPart Relocated(J9,2) c= if>0(a,I,J) by A19,FUNCT_4:26;
  then ProgramPart Relocated(J9,2) c= s3 by A21,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(J9,2)] c= s5 by AMI_1:99;
  then
A22: ProgramPart Relocated(J9,2) c= s5 by AMI_1:105;
  ProgramPart Relocated(J0,2) c= ProgramPart Relocated(J9,2) by Th12,SCMFSA6A
  :55;
  then
A23: ProgramPart Relocated(J0,2) c= s5 by A22,XBOOLE_1:1;
A24: IC s5 = insloc 2 by A18,SCMFSA_2:95;
A25: DataPart s00 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A26: now
    let a be Int-Location;
    thus s00.a = s3.a by A25,SCMFSA6A:38
      .= s4.a by A13,SCMFSA_2:97
      .= s5.a by A18,SCMFSA_2:95;
  end;
  now
    let f be FinSeq-Location;
    thus s00.f = s3.f by A25,SCMFSA6A:38
      .= s4.f by A13,SCMFSA_2:97
      .= s5.f by A18,SCMFSA_2:95;
  end;
  then
A27: DataPart s00 = DataPart s5 by A26,SCMFSA6A:38;
A28: if>0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  now thus card if>0(a,I,J) = card I + card J + (2 + 2) by SCMFSA8B:15
      .= card J + 2 + (card I + 2);
  end;
  then card J + 2 + 0 < card if>0(a,I,J) by XREAL_1:10;
  then
A29: insloc (card J + 2) in dom if>0(a,I,J) by SCMFSA6A:15;
  set s9 =  Computation( s3,pseudo-LifeSpan(s00,J0) + 2);
A30: now thus IC s9 = IC  Computation( s5,pseudo-LifeSpan(s00,J0)) by AMI_1:51
      .= IC  Computation( s00,pseudo-LifeSpan(s00,J0)) + 2
    by A6,A7,A23,A24,A27,Th51
      .= IC  Computation( s00,pseudo-LifeSpan(s,J0)) + 2 by A4,Th50
      .= insloc card ProgramPart J0 + 2 by A4,SCMFSA8A:def 5
      .= insloc card J0 + 2 by AMI_1:105
      .= insloc (card J + 2) by SCMFSA8A:34;
  end;
  then
A31: CurInstr s9 = s3.insloc (card J + 2) by AMI_1:54
    .= if>0(a,I,J).insloc (card J + 2) by A28,A29,GRFUNC_1:8
    .= goto insloc (card I + card J + 3) by Th64;
A32: if>0(a,I,J) c= s3 by FUNCT_4:26,SCMFSA6B:5;
  now thus card if>0(a,I,J) = card I + card J + (3 + 1) by SCMFSA8B:15
      .= card I + card J + 3 + 1;
  end;
  then card I + card J + 3 < card if>0(a,I,J) by NAT_1:13;
  then
A33: insloc (card I + card J + 3) in dom if>0(a,I,J) by SCMFSA6A:15;
  now thus IC  Computation( s3,pseudo-LifeSpan(s00,J0) + 2 + 1)
    = IC Following s9 by AMI_1:14
      .= insloc (card I + card J + 3) by A31,SCMFSA_2:95;
  end;
  then
A34: CurInstr  Computation( s3,pseudo-LifeSpan(s00,J0) + 2 + 1)
  = s3.insloc (card I + card J + 3) by AMI_1:54
    .= if>0(a,I,J).insloc (card I + card J + 3) by A32,A33,GRFUNC_1:8
    .= halt SCM+FSA by Th62;
  then
A35: s3 is halting by AMI_1:def 20;
A36: now
    let k be Element of NAT;
    assume
A37: CurInstr  Computation( s3,k) = halt SCM+FSA;
    assume
A38: not pseudo-LifeSpan(s00,J0) + (1 + 2) <= k;
    CurInstr  Computation( s3,0) = i by A12,AMI_1:13;
    then
A39: k <> 0 & k <> 1 by A14,A17,A37,SCMFSA_2:47,49,124;
    0 + 2 < card I + card J + 3 by XREAL_1:10;
    then
A40: insloc 2 in dom if>0(a,I,J) & if>0(a,I,J).insloc 2 <> halt SCM+FSA
    by Th57;
    CurInstr  Computation( s3,2) = s3.insloc 2 by A24,AMI_1:54
      .= if>0(a,I,J).insloc 2 by A40,Th26;
    then 2 < k by A37,A39,A40,NAT_1:27;
    then consider k2 being Nat such that
A41: 2 + k2 = k by NAT_1:10;
    reconsider k2 as Element of NAT by ORDINAL1:def 13;
    k < pseudo-LifeSpan(s00,J0) + 1 + 2 by A38;
    then k2 < pseudo-LifeSpan(s00,J0) + 1 by A41,XREAL_1:8;
    then
A42: k2 <= pseudo-LifeSpan(s00,J0) by NAT_1:13;
  reconsider n = IC  Computation( s00,k2) as Element of NAT by ORDINAL1:def 13;
A44: IC  Computation( s3,k) = IC  Computation( s5,k2) by A41,AMI_1:51
      .= insloc (n + 2) by A6,A7,A23,A24,A27,A42,Th51;
A45: k2 <= pseudo-LifeSpan(s,J0) by A4,A42,Th50;
A46: now per cases by A45,REAL_1:def 5;
      suppose k2 = pseudo-LifeSpan(s,J0);
        then IC  Computation( s00,k2) = insloc card ProgramPart J0
        by A4,SCMFSA8A:def 5
          .= insloc card J0 by AMI_1:105;
        then
A47:    n = card J by SCMFSA8A:34;
        card I + card J + (2 + 1) = card J + 2 + 1 + card I;
        then card J + 2 + 1 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A47,NAT_1:13;
      end;
      suppose k2 < pseudo-LifeSpan(s,J0);
        then insloc n in dom J0 by A4,SCMFSA8A:31;
        then n < card J0 by SCMFSA6A:15;
        then n + 2 < card J0 + 2 by XREAL_1:8;
        then
A48:    n + 2 < card J + 2 by SCMFSA8A:34;
        card I + card J + (1 + 2) = card J + 2 + (card I + 1);
        then card J + 2 <= card I + card J + 3 by NAT_1:11;
        hence n + 2 < card I + card J + 3 by A48,XXREAL_0:2;
      end;
    end;
    then
A49: insloc (n + 2) in dom if>0(a,I,J) &
    if>0(a,I,J).insloc (n + 2) <> halt SCM+FSA by Th57;
    CurInstr  Computation( s3,k) = s3.IC  Computation( s3,k) by AMI_1:54
      .= if>0(a,I,J).IC  Computation( s3,k) by A44,A49,Th26;
    hence contradiction by A37,A44,A46,Th57;
  end;
  set s1 = s +* (J ';' Stop SCM+FSA +* Start-At insloc 0);
  s +* Initialized if>0(a,I,J) =
  Initialize s +* (if>0(a,I,J) +* Start-At insloc 0) &
  s +* Initialized (J ';' Stop SCM+FSA) =
  Initialize s +* (J ';' Stop SCM+FSA +* Start-At insloc 0) by SCMFSA8A:13;
  then
A50: s +* Initialized if>0(a,I,J) = s3 &
  s +* Initialized (J ';' Stop SCM+FSA) = s1 by Th15;
A51: J ';' Stop SCM+FSA is_halting_on s & LifeSpan s1 = pseudo-LifeSpan(s,J0)
  by A4,Th58;
  then
A52: s1 is halting by SCMFSA7B:def 8;
A53: Directed J0 = J0 by SCMFSA6A:63;
  J0 ';' Stop SCM+FSA = J ';' Stop SCM+FSA &
  Directed J0 is_pseudo-closed_on s by A4,SCMFSA6A:63,SCMFSA8A:41;
  then
A54: DataPart Computation( s00,pseudo-LifeSpan(s,J0)) =
   DataPart Computation( s1,LifeSpan  s1) by A51,A53,Th58;
A55: LifeSpan s3 = pseudo-LifeSpan(s00,J0) + 2 + 1 by A34,A35,A36,AMI_1:def 46;
A56: DataPart s9
     = DataPart Computation( s5,pseudo-LifeSpan(s00,J0)) by AMI_1:51
    .= DataPart Computation( s00,pseudo-LifeSpan(s00,J0))
     by A6,A7,A23,A24,A27,Th51;
  CurInstr s9 = s3.insloc (card J + 2) by A30,AMI_1:54
    .= if>0(a,I,J).insloc (card J + 2) by A29,Th26
    .= goto insloc (card I + card J + 3) by Th64;
  then InsCode CurInstr s9 = 6 by SCMFSA_2:47;
  then InsCode CurInstr s9 in {0,6,7,8} by ENUMSET1:def 2;
  then
A57: DataPart s9 = DataPart Following s9 by Th32;
  thus DataPart IExec(if>0(a,I,J),ss) = DataPart IExec(if>0(a,I,J),s) by Th17
    .= DataPart(Result (s +* Initialized if>0(a,I,J)) +* s | A)
     by SCMFSA6B:def 1
    .= DataPart(Result s3) by A50,Th35
    .= DataPart Computation( s3,LifeSpan  s3) by A35,AMI_1:122
    .= DataPart Following s9 by A55,AMI_1:14
    .= DataPart Computation( s00,pseudo-LifeSpan(s,J0)) by A4,A56,A57,Th50
    .= DataPart Result s1 by A52,A54,AMI_1:122

.= DataPart(Result (s +* Initialized (J ';' Stop SCM+FSA)) +* s | A)
              by A50,Th35
    .= DataPart IExec(J ';' Stop SCM+FSA,s) by SCMFSA6B:def 1
    .= DataPart IExec(J ';' Stop SCM+FSA,ss) by Th17;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location st Directed I is_pseudo-closed_on s &
  Directed J is_pseudo-closed_on s holds
  if=0(a,I,J) is_closed_on s & if=0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: Directed I is_pseudo-closed_on s;
  assume
A2: Directed J is_pseudo-closed_on s;
  hereby per cases;
    suppose
A3:   s.a = 0;
      hence if=0(a,I,J) is_closed_on s by A1,Th66;
      thus if=0(a,I,J) is_halting_on s by A1,A3,Th66;
    end;
    suppose
A4:   s.a <> 0;
      hence if=0(a,I,J) is_closed_on s by A2,Th70;
      thus if=0(a,I,J) is_halting_on s by A2,A4,Th70;
    end;
  end;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location st Directed I is_pseudo-closed_on s &
  Directed J is_pseudo-closed_on s holds
  if>0(a,I,J) is_closed_on s & if>0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: Directed I is_pseudo-closed_on s;
  assume
A2: Directed J is_pseudo-closed_on s;
  hereby per cases;
    suppose
A3:   s.a > 0;
      hence if>0(a,I,J) is_closed_on s by A1,Th68;
      thus if>0(a,I,J) is_halting_on s by A1,A3,Th68;
    end;
    suppose
A4:   s.a <= 0;
      hence if>0(a,I,J) is_closed_on s by A2,Th72;
      thus if>0(a,I,J) is_halting_on s by A2,A4,Th72;
    end;
  end;
end;

theorem
  for I being Program of SCM+FSA, a being Int-Location holds
  I does_not_destroy a implies Directed I does_not_destroy a by SCMFSA8A:27;

theorem Th77: ::Td1(@BBB8)
  for i being Instruction of SCM+FSA, a being Int-Location holds
  i does_not_destroy a implies Macro i does_not_destroy a
proof
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  assume
A1: i does_not_destroy a;
A2: rng Macro i = {i,halt SCM+FSA} by FUNCT_4:67;
  now
    let ii be Instruction of SCM+FSA;
    assume ii in rng Macro i;
    then ii = i or ii = halt SCM+FSA by A2,TARSKI:def 2;
    hence ii does_not_destroy a by A1,SCMFSA7B:11;
  end;
  hence Macro i does_not_destroy a by SCMFSA7B:def 4;
end;

theorem Th78:
  for a being Int-Location holds halt SCM+FSA does_not_refer a
proof
  let a be Int-Location;
  for b be Int-Location for l be Instruction-Location of SCM+FSA
  for f be FinSeq-Location holds b := a <> halt SCM+FSA &
  AddTo(b,a) <> halt SCM+FSA & SubFrom(b,a) <> halt SCM+FSA &
  MultBy(b,a) <> halt SCM+FSA &
  Divide(a,b) <> halt SCM+FSA & Divide(b,a) <> halt SCM+FSA &
  a =0_goto l <> halt SCM+FSA & a >0_goto l <> halt SCM+FSA &
  b :=(f,a) <> halt SCM+FSA &
  (f,b):= a <> halt SCM+FSA & (f,a):= b <> halt SCM+FSA &
  f :=<0,...,0> a <> halt SCM+FSA
  by SCMFSA_2:42,43,44,45,46,48,49,50,51,53,124;
  hence halt SCM+FSA does_not_refer a by SCMFSA7B:def 1;
end;

theorem
  for a,b,c being Int-Location holds
  a <> b implies AddTo(c,b) does_not_refer a
proof
  let a,b,c be Int-Location;
  assume
A1: a <> b;
  now
    let e be Int-Location;
    let l be Instruction-Location of SCM+FSA;
    let f be FinSeq-Location;
A2: 2 <> 1 & 2 <> 3 & 2 <> 4 & 2 <> 5 & 2 <> 7 & 2 <> 8 & 2 <> 9 & 2 <> 10 &
    2 <> 12 & InsCode AddTo(c,b) = 2 by SCMFSA_2:43;
    hence e := a <> AddTo(c,b) by SCMFSA_2:42;
    thus AddTo(e,a) <> AddTo(c,b) by A1,SF_MASTR:6;
    thus SubFrom(e,a) <> AddTo(c,b) by A2,SCMFSA_2:44;
    thus MultBy(e,a) <> AddTo(c,b) by A2,SCMFSA_2:45;
    thus Divide(a,e) <> AddTo(c,b) & Divide(e,a) <> AddTo(c,b)
    by A2,SCMFSA_2:46;
    thus a =0_goto l <> AddTo(c,b) by A2,SCMFSA_2:48;
    thus a >0_goto l <> AddTo(c,b) by A2,SCMFSA_2:49;
    thus e :=(f,a) <> AddTo(c,b) by A2,SCMFSA_2:50;
    thus (f,e):= a <> AddTo(c,b) & (f,a):= e <> AddTo(c,b) by A2,SCMFSA_2:51;
    thus f :=<0,...,0> a <> AddTo(c,b) by A2,SCMFSA_2:53;
  end;
  hence AddTo(c,b) does_not_refer a by SCMFSA7B:def 1;
end;

theorem
  for i being Instruction of SCM+FSA, a being Int-Location holds
  i does_not_refer a implies Macro i does_not_refer a
proof
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  assume
A1: i does_not_refer a;
A2: rng Macro i = {i,halt SCM+FSA} by FUNCT_4:67;
  now
    let ii be Instruction of SCM+FSA;
    assume ii in rng Macro i;
    then ii = i or ii = halt SCM+FSA by A2,TARSKI:def 2;
    hence ii does_not_refer a by A1,Th78;
  end;
  hence Macro i does_not_refer a by SCMFSA7B:def 2;
end;

theorem Th81:
  for I,J being Program of SCM+FSA, a being Int-Location holds
  I does_not_destroy a & J does_not_destroy a implies
  I ';' J does_not_destroy a
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does_not_destroy a & J does_not_destroy a;
A3: Directed I does_not_destroy a by A1,SCMFSA8A:27;
  [ProgramPart Relocated(J,card I)] does_not_destroy a by A1,SCMFSA8A:23;
  hence I ';' J does_not_destroy a by A3,SCMFSA8A:25;
end;

theorem Th82:
  for J being Program of SCM+FSA, i being Instruction of SCM+FSA,
  a being Int-Location st i does_not_destroy a & J does_not_destroy a holds
  i ';' J does_not_destroy a
proof
  let J be Program of SCM+FSA;
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  assume
A1: i does_not_destroy a & J does_not_destroy a;
  then
A2: Macro i does_not_destroy a by Th77;
  thus i ';' J does_not_destroy a by A1,A2,Th81;
end;

theorem
  for I being Program of SCM+FSA, j being Instruction of SCM+FSA,
  a being Int-Location st I does_not_destroy a & j does_not_destroy a holds
  I ';' j does_not_destroy a
proof
  let I be Program of SCM+FSA;
  let j be Instruction of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does_not_destroy a & j does_not_destroy a;
  then
A2: Macro j does_not_destroy a by Th77;
  thus I ';' j does_not_destroy a by A1,A2,Th81;
end;

theorem
  for i,j being Instruction of SCM+FSA,
  a being Int-Location st i does_not_destroy a & j does_not_destroy a holds
  i ';' j does_not_destroy a
proof
  let i,j be Instruction of SCM+FSA;
  let a be Int-Location;
  assume i does_not_destroy a & j does_not_destroy a;
  then
A1: Macro i does_not_destroy a & Macro j does_not_destroy a by Th77;
  thus i ';' j does_not_destroy a by A1,Th81;
end;

theorem Th85:
  for a being Int-Location holds Stop SCM+FSA does_not_destroy a
proof
  let a be Int-Location;
  now
    let i be Instruction of SCM+FSA;
    assume
A1: i in rng Stop SCM+FSA;
    rng Stop SCM+FSA = {halt SCM+FSA} by AFINSQ_1:36;
    then i = halt SCM+FSA by A1,TARSKI:def 1;
    hence i does_not_destroy a by SCMFSA7B:11;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th86:
  for a being Int-Location, l being Instruction-Location of SCM+FSA holds
  Goto l does_not_destroy a
proof
  let a be Int-Location;
  let l be Instruction-Location of SCM+FSA;
  now
    let i be Instruction of SCM+FSA;
    assume
A1: i in rng Goto l;
    rng Goto l = {goto l} by FUNCOP_1:14;
    then i = goto l by A1,TARSKI:def 1;
    hence i does_not_destroy a by SCMFSA7B:17;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th87:
  for s being State of SCM+FSA, I being Program of SCM+FSA
  st I is_halting_on Initialize s holds
  (for a being read-write Int-Location holds
  IExec(I,s).a =  Computation(Initialize s +* (I +* Start-At insloc 0),
  (LifeSpan (Initialize s +* (I +* Start-At insloc 0)))).a) &
  for f being FinSeq-Location holds
  IExec(I,s).f =  Computation(Initialize s +* (I +* Start-At insloc 0),
   LifeSpan(Initialize s +* (I +* Start-At insloc 0))).f
proof
  set A = NAT;
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s0 = Initialize s;
  set s1 = s0 +* (I +* Start-At insloc 0);
  assume I is_halting_on s0;
  then
A1: s1 is halting by SCMFSA7B:def 8;
  hereby
    let a be read-write Int-Location;
    now
      assume
A2:   a in A;
      then reconsider a as Instruction-Location of SCM+FSA by AMI_1:def 4;
      a in A by A2;
      hence contradiction by SCMFSA_2:84;
    end;
    then not a in dom s /\ A by XBOOLE_0:def 3;
    then
A3: a in dom Result s1 & not a in dom (s | A) by RELAT_1:90,SCMFSA_2: 66;
    s +* Initialized I = s1 by SCMFSA8A:13;
    hence IExec(I,s).a = (Result s1 +* s | A).a by SCMFSA6B:def 1
      .= (Result s1).a by A3,FUNCT_4:12
      .=  Computation( s1,LifeSpan  s1).a by A1,AMI_1:122;
  end;
  let f be FinSeq-Location;
  now
    assume
A4: f in A;
    then reconsider f as Instruction-Location of SCM+FSA by AMI_1:def 4;
    f in A by A4;
    hence contradiction by SCMFSA_2:85;
  end;
  then not f in dom s /\ A by XBOOLE_0:def 3;
  then
A5: f in dom Result s1 & not f in dom (s | A) by RELAT_1:90,SCMFSA_2:67;
  s +* Initialized I = s1 by SCMFSA8A:13;
  hence IExec(I,s).f = (Result s1 +* s | A).f by SCMFSA6B:def 1
    .= (Result s1).f by A5,FUNCT_4:12
    .=  Computation( s1,LifeSpan  s1).f by A1,AMI_1:122;
end;

theorem Th88:
  for s being State of SCM+FSA, I being parahalting Program of SCM+FSA,
  a being read-write Int-Location holds
  IExec(I,s).a =  Computation(Initialize s +* (I +* Start-At insloc 0),
  (LifeSpan (Initialize s +* (I +* Start-At insloc 0)))).a
proof
  let s be State of SCM+FSA;
  let I be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  I is_halting_on Initialize s by SCMFSA7B:25;
  hence thesis by Th87;
end;

theorem Th89:
  for s being State of SCM+FSA, I being Program of SCM+FSA,
  a being Int-Location,k being Element of NAT st
  I is_closed_on Initialize s & I is_halting_on Initialize s &
  I does_not_destroy a holds
  IExec(I,s).a =  Computation( (Initialize s +* (I +* Start-At insloc 0)),k).a
proof
  set A = NAT;
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  let k be Element of NAT;
  assume
A1: I is_closed_on Initialize s;
  assume
A2: I is_halting_on Initialize s;
  assume
A3: I does_not_destroy a;
  set s0 = Initialize s;
  set s1 = s0 +* (I +* Start-At insloc 0);
A4: s1 is halting by A2,SCMFSA7B:def 8;
  now
    assume
A5: a in A;
    then reconsider a as Instruction-Location of SCM+FSA by AMI_1:def 4;
    a in A by A5;
    hence contradiction by SCMFSA_2:84;
  end;
  then not a in dom s /\ A by XBOOLE_0:def 3;
  then
A6: a in dom Result s1 & not a in dom (s | A) by RELAT_1:90,SCMFSA_2:66;
  s +* Initialized I = s0 +* (I +* Start-At insloc 0) by SCMFSA8A:13;
  hence IExec(I,s).a = (Result s1 +* s | A).a by SCMFSA6B:def 1
    .= (Result s1).a by A6,FUNCT_4:12
    .=  Computation( s1,LifeSpan  s1).a by A4,AMI_1:122
    .= s0.a by A1,A3,SCMFSA7B:27
    .=  Computation( (s0 +* (I +* Start-At insloc 0)),k).a
     by A1,A3,SCMFSA7B:27;
end;

theorem Th90:
  for s being State of SCM+FSA, I being parahalting Program of SCM+FSA,
  a being Int-Location,k being Element of NAT st I does_not_destroy a holds
  IExec(I,s).a =  Computation( (Initialize s +* (I +* Start-At insloc 0)),k).a
proof
  let s be State of SCM+FSA;
  let I be parahalting Program of SCM+FSA;
  let a be Int-Location;
  let k be Element of NAT;
  assume
A1: I does_not_destroy a;
  set s0 = Initialize s;
  set s1 = s0 +* (I +* Start-At insloc 0);
A2: I is_closed_on s0 by SCMFSA7B:24;
  s1 is halting by FUNCT_4:26,SCMFSA6B:18;
  then I is_halting_on s0 by SCMFSA7B:def 8;
  hence thesis by A1,A2,Th89;
end;

theorem Th91:
  for s being State of SCM+FSA, I being parahalting Program of SCM+FSA,
  a being Int-Location st I does_not_destroy a holds
  IExec(I,s).a = (Initialize s).a
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let I be parahalting Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does_not_destroy a;
A2: DataPart Initialize s = DataPart(Initialize s +* (I +* Start-At insloc 0))
  by SCMFSA8A:11;
  thus IExec(I,s).a
  =  Computation( (Initialize s +* (I +* Start-At insloc 0)),0).a by A1,Th90
    .= (Initialize s +* (I +* Start-At insloc 0)).a by AMI_1:13
    .= (Initialize s).a by A2,SCMFSA6A:38;
end;

theorem Th92:
  for s being State of SCM+FSA, I being keeping_0 Program of SCM+FSA st
  I is_halting_on Initialize s holds IExec(I,s).intloc 0 = 1 &
  for k being Element of NAT holds
   Computation( (Initialize s +* (I +* Start-At insloc 0)),k).intloc 0 = 1
proof
  set A = NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let I be keeping_0 Program of SCM+FSA;
  set s0 = Initialize s;
  set s1 = s0 +* (I +* Start-At insloc 0);
  set a = intloc 0;
  assume I is_halting_on s0;
  then
A1: s1 is halting by SCMFSA7B:def 8;
  now
    assume
A2: a in A;
    then reconsider a as Instruction-Location of SCM+FSA by AMI_1:def 4;
    a in A by A2;
    hence contradiction by SCMFSA_2:84;
  end;
  then not a in dom s /\ A by XBOOLE_0:def 3;
  then
A3: a in dom Result s1 & not a in dom (s | A) by RELAT_1:90,SCMFSA_2:66;
A4: DataPart s0 = DataPart s1 by SCMFSA8A:11;
A5: I +* Start-At insloc 0 c= s1 by FUNCT_4:26;
A6: now
    let k be Element of NAT;
    thus  Computation( s1,k).a = s1.a by A5,SCMFSA6B:def 4
      .= s0.a by A4,SCMFSA6A:38
      .= 1 by SCMFSA6C:3;
  end;
  s +* Initialized I = s1 by SCMFSA8A:13;
  hence IExec(I,s).a = (Result s1 +* s | A).a by SCMFSA6B:def 1
    .= (Result s1).a by A3,FUNCT_4:12
    .=  Computation( s1,LifeSpan  s1).a by A1,AMI_1:122
    .= 1 by A6;
  let k be Element of NAT;
  thus  Computation( s1,k).a = 1 by A6;
end;

theorem Th93:
  for s being State of SCM+FSA, I being Program of SCM+FSA,
  a being Int-Location
  st I does_not_destroy a holds for k being Element of NAT
  st IC  Computation( (s +* (I +* Start-At insloc 0)),k) in dom I
  holds  Computation( (s +* (I +* Start-At insloc 0)),k + 1).a =
   Computation( (s +* (I +* Start-At insloc 0)),k).a
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does_not_destroy a;
  let k be Element of NAT;
  assume
A2: IC  Computation( (s +* (I +* Start-At insloc 0)),k) in dom I;
  set s1 = s +* (I +* Start-At insloc 0);
A3: I +* Start-At insloc 0 c= s1 by FUNCT_4:26;
  dom I misses dom Start-At insloc 0 by SF_MASTR:64;
  then I c= I +* Start-At insloc 0 by FUNCT_4:33;
  then
A4: I c= s1 by A3,XBOOLE_1:1;
  set l = IC  Computation( s1,k);
  s1.l = I.l by A2,A4,GRFUNC_1:8;
  then s1.l in rng I by A2,FUNCT_1:def 5;
  then
A5: s1.l does_not_destroy a by A1,SCMFSA7B:def 4;
  thus  Computation( s1,k + 1).a
  = (Following  Computation( s1,k)).a by AMI_1:14
    .= Exec(s1.l, Computation( s1,k)).a by AMI_1:54
    .=  Computation( s1,k).a by A5,SCMFSA7B:26;
end;

theorem Th94:
  for s being State of SCM+FSA, I being Program of SCM+FSA,
  a being Int-Location
  st I does_not_destroy a holds
  for m being Element of NAT st (for n being Element of NAT st n < m holds
  IC  Computation( (s +* (I +* Start-At insloc 0)),n) in dom I) holds
  for n being Element of NAT st n <= m holds
   Computation( (s +* (I +* Start-At insloc 0)),n).a = s.a
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does_not_destroy a;
  let m be Element of NAT;
  assume
A2: for n being Element of NAT st n < m holds
  IC  Computation( (s +* (I +* Start-At insloc 0)),n) in dom I;
  let n be Element of NAT;
  assume
A3: n <= m;
  set s1 = s +* (I +* Start-At insloc 0);
  defpred P[Element of NAT] means $1 <= m implies  Computation( s1,$1).a = s.a;
   Computation( s1,0).a = s1.a by AMI_1:13
    .= s.a by Th28;
  then
A4: P[0];
A5: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A6: P[k];
    assume
A7: k + 1 <= m;
A8: k + 0 < k + 1 by XREAL_1:8;
    then k < m by A7,XXREAL_0:2;
    then IC  Computation( s1,k) in dom I by A2;
    hence  Computation( s1,k + 1).a = s.a by A1,A6,A7,A8,Th93,XXREAL_0:2;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A4,A5);
  hence  Computation( (s +* (I +* Start-At insloc 0)),n).a = s.a by A3;
end;

theorem Th95:
  for s being State of SCM+FSA, I being good Program of SCM+FSA
  for m being Element of NAT st (for n being Element of NAT st n < m holds
  IC  Computation( (s +* (I +* Start-At insloc 0)),n) in dom I) holds
  for n being Element of NAT st n <= m holds
   Computation( (s +* (I +* Start-At insloc 0)),n).intloc 0 = s.intloc 0
proof
  let s be State of SCM+FSA;
  let I be good Program of SCM+FSA;
  let m be Element of NAT;
  assume
A1: for n being Element of NAT st n < m holds
  IC  Computation( (s +* (I +* Start-At insloc 0)),n) in dom I;
  let n be Element of NAT;
  assume
A2: n <= m;
  I does_not_destroy intloc 0 by SCMFSA7B:def 5;
  hence  Computation( (s +* (I +* Start-At insloc 0)),n).intloc 0 =
  s.intloc 0 by A1,A2,Th94;
end;

theorem Th96:
  for s being State of SCM+FSA, I being good Program of SCM+FSA st
  I is_halting_on Initialize s & I is_closed_on Initialize s holds
  IExec(I,s).intloc 0 = 1 & for k being Element of NAT holds
   Computation( (Initialize s +* (I +* Start-At insloc 0)),k).intloc 0 = 1
proof
  set A = NAT;
  let s be State of SCM+FSA;
  let I be good Program of SCM+FSA;
  set s0 = Initialize s;
  set s1 = s0 +* (I +* Start-At insloc 0);
  set a = intloc 0;
  assume I is_halting_on s0;
  then
A1: s1 is halting by SCMFSA7B:def 8;
  assume
A2: I is_closed_on s0;
  defpred P[Element of NAT] means for n being Element of NAT st n <= $1 holds
   Computation( s1,n).intloc 0 = s0.intloc 0;
A3: P[0]
  proof
    let n be Element of NAT;
    assume
A4: n <= 0;
    for i being Element of NAT st i < 0 holds IC  Computation( s1,i) in dom I;
    hence  Computation( s1,n).intloc 0 = s0.intloc 0 by A4,Th95;
  end;
A5: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume P[k];
    let n be Element of NAT;
    assume
A6: n <= k + 1;
    for i being Element of NAT
    st i < k + 1 holds IC  Computation( s1,i) in dom I by A2,SCMFSA7B:def 7;
    hence  Computation( s1,n).intloc 0 = s0.intloc 0 by A6,Th95;
  end;
A7: for k being Element of NAT holds P[k] from NAT_1:sch 1(A3,A5);
A8: now
    let k be Element of NAT;
    thus  Computation( s1,k).intloc 0 = s0.intloc 0 by A7
      .= 1 by SCMFSA6C:3;
  end;
  now
    assume
A9: a in A;
    then reconsider a as Instruction-Location of SCM+FSA by AMI_1:def 4;
    a in A by A9;
    hence contradiction by SCMFSA_2:84;
  end;
  then not a in dom s /\ A by XBOOLE_0:def 3;
  then
A10: a in dom Result s1 & not a in dom (s | A) by RELAT_1:90,SCMFSA_2:66;
  s +* Initialized I = s1 by SCMFSA8A:13;
  hence IExec(I,s).a = (Result s1 +* s | A).a by SCMFSA6B:def 1
    .= (Result s1).a by A10,FUNCT_4:12
    .=  Computation( s1,LifeSpan  s1).a by A1,AMI_1:122
    .= 1 by A8;
  thus thesis by A8;
end;

theorem
  for s being State of SCM+FSA, I being good Program of SCM+FSA
  st I is_closed_on s holds for k being Element of NAT holds
   Computation( (s +* (I +* Start-At insloc 0)),k).intloc 0 = s.intloc 0
proof
  let s be State of SCM+FSA;
  let I be good Program of SCM+FSA;
  assume
A1: I is_closed_on s;
  let k be Element of NAT;
  I does_not_destroy intloc 0 by SCMFSA7B:def 5;
  hence  Computation( (s +* (I +* Start-At insloc 0)),k).intloc 0 = s.intloc 0
  by A1,SCMFSA7B:27;
end;

theorem Th98:

for s being State of SCM+FSA, I being keeping_0 parahalting Program of SCM+FSA,
  a being read-write Int-Location st I does_not_destroy a holds
   Computation( (Initialize s +* (I ';' SubFrom(a,intloc 0) +*
  Start-At insloc 0)),LifeSpan (Initialize s +*
  (I ';' SubFrom(a,intloc 0) +* Start-At insloc 0))).a = s.a - 1
proof
  let s be State of SCM+FSA;
  let I be keeping_0 parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  set s0 = Initialize s;
  set s1 = s0 +* (I ';' SubFrom(a,intloc 0) +* Start-At insloc 0);
A2: a in dom s0 & not a in dom (I +* Start-At insloc 0)
  by SCMFSA6B:12,SCMFSA_2:66;
  IExec(I ';' SubFrom(a,intloc 0),s).a
  = Exec(SubFrom(a,intloc 0),IExec(I,s)).a by SCMFSA6C:7
    .= IExec(I,s).a - IExec(I,s).intloc 0 by SCMFSA_2:91
    .= IExec(I,s).a - 1 by SCMFSA6B:35
    .=  Computation( (s0 +* (I +* Start-At insloc 0)),0).a - 1 by A1,Th90
    .= (s0 +* (I +* Start-At insloc 0)).a - 1 by AMI_1:13
    .= s0.a - 1 by A2,FUNCT_4:12;
  hence  Computation( s1,LifeSpan  s1).a = s0.a - 1 by Th88
    .= s.a - 1 by SCMFSA6C:3;
end;

theorem Th99:
  for i being Instruction of SCM+FSA st i does_not_destroy intloc 0 holds
  Macro i is good
proof
  let i be Instruction of SCM+FSA;
  assume i does_not_destroy intloc 0;
  then Macro i does_not_destroy intloc 0 by Th77;
  hence Macro i is good by SCMFSA7B:def 5;
end;

theorem Th100: ::T13'   6B
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA
  st I is_closed_on s1 & I is_halting_on s1 &
  DataPart s1 = DataPart s2 holds
  for k being Element of NAT holds
   Computation( (s1 +* (I +* Start-At insloc 0)),k),
   Computation( (s2 +* (I +* Start-At insloc 0)),k) equal_outside NAT &
  CurInstr  Computation( (s1 +* (I +* Start-At insloc 0)),k) =
  CurInstr  Computation( (s2 +* (I +* Start-At insloc 0)),k)
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: I is_closed_on s1;
  assume
A2: I is_halting_on s1;
  assume
A3: DataPart s1 = DataPart s2;
  set ss1 = s1 +* (I +* Start-At insloc 0);
  set ss2 = s2 +* (I +* Start-At insloc 0);
  I +* Start-At insloc 0 c= ss1 & I c= I +* Start-At insloc 0
  by FUNCT_4:26,SCMFSA8A:9;
  then
A4: I c= ss1 by XBOOLE_1:1;
  I +* Start-At insloc 0 c= ss2 & I c= I +* Start-At insloc 0
  by FUNCT_4:26,SCMFSA8A:9;
  then
A5: I c= ss2 by XBOOLE_1:1;
  hereby
    let k be Element of NAT;
A6: ss1,ss2 equal_outside NAT by A3,SCMFSA8B:7;
    I is_closed_on s2 by A1,A2,A3,SCMFSA8B:8;
    then for m being Element of NAT
    st m < k holds IC  Computation( ss2,m) in dom I by SCMFSA7B:def 7;
    hence  Computation( ss1,k),  Computation( ss2,k) equal_outside
    NAT by A4,A5,A6,SCMFSA6B:21;
    then
A7: IC  Computation( ss1,k) = IC  Computation( ss2,k) by AMI_1:121;
A8: IC  Computation( ss1,k) in dom I by A1,SCMFSA7B:def 7;
    I is_closed_on s2 by A1,A2,A3,SCMFSA8B:8;
    then
A9: IC  Computation( ss2,k) in dom I by SCMFSA7B:def 7;
    thus CurInstr  Computation( ss2,k) = ss2.IC  Computation( ss2,k)
     by AMI_1:54
      .= I.IC  Computation( ss2,k) by A5,A9,GRFUNC_1:8
      .= ss1.IC  Computation( ss1,k) by A4,A7,A8,GRFUNC_1:8
      .= CurInstr  Computation( ss1,k) by AMI_1:54;
  end;
end;

theorem Th101: ::T14'   6B
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA
  st I is_closed_on s1 & I is_halting_on s1 &
  DataPart s1 = DataPart s2 holds
  LifeSpan (s1 +* (I +* Start-At insloc 0)) =
  LifeSpan (s2 +* (I +* Start-At insloc 0)) &
  Result (s1 +* (I +* Start-At insloc 0)),
  Result (s2 +* (I +* Start-At insloc 0)) equal_outside NAT
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: I is_closed_on s1;
  assume
A2: I is_halting_on s1;
  assume
A3: DataPart s1 = DataPart s2;
  set ss1 = s1 +* (I +* Start-At insloc 0);
  set ss2 = s2 +* (I +* Start-At insloc 0);
A4: ss1 is halting by A2,SCMFSA7B:def 8;
A5: now
    let l be Element of NAT;
    assume
A6: CurInstr  Computation( ss2,l) = halt SCM+FSA;
    CurInstr  Computation( ss1,l) = CurInstr  Computation( ss2,l)
    by A1,A2,A3,Th100;
    hence LifeSpan ss1 <= l by A4,A6,AMI_1:def 46;
  end;
A7: CurInstr  Computation( ss2,LifeSpan ss1)
  = CurInstr  Computation( ss1,LifeSpan ss1) by A1,A2,A3,Th100
    .= halt SCM+FSA by A4,AMI_1:def 46;
  I is_halting_on s2 by A1,A2,A3,SCMFSA8B:8;
  then
A8: ss2 is halting by SCMFSA7B:def 8;
  hence LifeSpan ss1 = LifeSpan ss2 by A5,A7,AMI_1:def 46;
  then
A9: Result ss2 =  Computation( ss2,LifeSpan ss1) by A8,AMI_1:122;
  Result ss1 =  Computation( ss1,LifeSpan ss1) by A4,AMI_1:122;
  hence Result ss1, Result ss2 equal_outside NAT by A1,A2,A3,A9,Th100;
end;

canceled;

theorem Th103:
  for s1,s2 being State of SCM+FSA,I being Program of SCM+FSA
  st I is_closed_on s1 & I is_halting_on s1 &
  I +* Start-At insloc 0 c= s1 & I +* Start-At insloc 0 c= s2 &
  ex k being Element of NAT st  Computation( s1,k),s2 equal_outside NAT holds
  Result s1,Result s2 equal_outside NAT
proof
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: I is_closed_on s1;
  assume
A2: I is_halting_on s1;
  assume
A3: I +* Start-At insloc 0 c= s1;
  assume
A4: I +* Start-At insloc 0 c= s2;
  given k being Element of NAT such that
A5:  Computation( s1,k),s2 equal_outside A;
  set s3 =  Computation( s1,k);
A6: s2 = s2 +* (I +* Start-At insloc 0) by A4,FUNCT_4:79;
  IC s3 = IC s2 by A5,SCMFSA8A:6
    .= IC (s2 +* I +* Start-At insloc 0) by A6,FUNCT_4:15
    .= insloc 0 by AMI_1:111;
  then IC SCM+FSA in dom s3 & s3.IC SCM+FSA = insloc 0 by AMI_1:94;
  then
A7: IC SCM+FSA .--> insloc 0 c= s3 by FUNCOP_1:88;
A8: DataPart s3 = DataPart s2 by A5,SCMFSA8A:6;
  I c= I +* Start-At insloc 0 by SCMFSA8A:9;
  then I c= s1 by A3,XBOOLE_1:1;
  then I c= s3 by AMI_1:86;
  then I +* Start-At insloc 0 c= s3 by A7,FUNCT_4:92;
  then
A9: s3 = s3 +* (I +* Start-At insloc 0) by FUNCT_4:79;
A10: s1 = s1 +* (I +* Start-At insloc 0) by A3,FUNCT_4:79;
  now
    let n be Element of NAT;
    IC  Computation( s3,n) = IC  Computation( s1,k + n) by AMI_1:51;
    hence IC  Computation( s3,n) in dom I by A1,A10,SCMFSA7B:def 7;
  end;
  then
A11: I is_closed_on s3 by A9,SCMFSA7B:def 7;
A12: s1 is halting by A2,A10,SCMFSA7B:def 8;
  then consider n being Element of NAT such that
A13: CurInstr  Computation( s1,n) = halt SCM+FSA by AMI_1:def 20;
  CurInstr  Computation( s3,n) = CurInstr  Computation( s1,k + n) by AMI_1:51
    .= CurInstr  Computation( s1,n) by A13,AMI_1:52,NAT_1:11;
  then s3 is halting by A13,AMI_1:def 20;
  then I is_halting_on s3 by A9,SCMFSA7B:def 8;
  then
A14: Result s3,Result s2 equal_outside A by A6,A8,A9,A11,Th101;
  consider k being Element of NAT such that
A15: CurInstr  Computation( s1,k) = halt SCM+FSA by A12,AMI_1:def 20;
  s1.IC  Computation( s1,k) = halt SCM+FSA by AMI_1:54,A15;
  hence Result s1,Result s2 equal_outside A by A14,AMI_1:57;
end;

begin :: loop

registration
  let I be Program of SCM+FSA, k be Element of NAT;
  cluster IncAddr(I,k) -> initial programmed;
  correctness
  proof
    now
      let m,n be Nat;
      assume
A1:    n in dom IncAddr(I,k);
      assume
A2:   m < n;
      dom IncAddr(I,k) = dom I by SCMFSA_4:def 6;
      hence  m in dom IncAddr(I,k) by A1,A2,SCMNORM:def 1;
    end;
    hence thesis by SCMNORM:def 1;
  end;
end;

definition
  let I be Program of SCM+FSA;
  canceled 3;
  func loop I -> halt-free Program of SCM+FSA equals
   Directed(I,insloc 0);
  coherence;
end;

canceled;

theorem
  for I being Program of SCM+FSA, a being Int-Location holds
  I does_not_destroy a implies loop I does_not_destroy a by SCMFSA8A:27;

registration
  let I be good Program of SCM+FSA;
  cluster loop I -> good;
  correctness;
end;

canceled;

theorem Th107: ::SCMFSA6A'18
  for I being Program of SCM+FSA holds not halt SCM+FSA in rng loop I
proof
  let I be Program of SCM+FSA;
   halt SCM+FSA <> goto insloc 0 by SCMFSA_2:47,124;
  hence not halt SCM+FSA in rng loop I by FUNCT_4:106;
end;

canceled;

theorem Th109:
  for s being State of SCM+FSA, I being Program of SCM+FSA
  st I is_closed_on s & I is_halting_on s
  for m being Element of NAT st m <= LifeSpan (s +* (I +* Start-At insloc 0))
  holds  Computation( (s +* (I +* Start-At insloc 0)),m),
   Computation((s +* (loop I +* Start-At insloc 0)),m) equal_outside NAT
proof
  set A = NAT;
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* (I +* Start-At insloc 0);
  set s2 = s +* (loop I +* Start-At insloc 0);
  assume
A1: I is_closed_on s;
  assume
A2: I is_halting_on s;
  defpred X[Element of NAT] means $1 <= LifeSpan s1 implies
   Computation( s1,$1), Computation( s2,$1) equal_outside A;
A3: X[0]
  proof
    assume 0 <= LifeSpan s1;
A4: s +* I,s equal_outside A by AMI_1:120,FUNCT_7:28;
    s,s +* loop I equal_outside A by AMI_1:120;
    then s +* I,s +* loop I equal_outside A by A4,FUNCT_7:29;
    then s +* I +* Start-At insloc 0,s +* loop I +* Start-At insloc 0
    equal_outside A by FUNCT_7:106;
    then s +* I +* Start-At insloc 0,s2 equal_outside A by FUNCT_4:15;
    then s1,s2 equal_outside A by FUNCT_4:15;
    then s1, Computation( s2,0) equal_outside A by AMI_1:13;
    hence  Computation( s1,0), Computation( s2,0) equal_outside A by
    AMI_1:13;
  end;
A5: s1 is halting by A2,SCMFSA7B:def 8;
A6: for m being Element of NAT st X[m] holds X[m+1]
  proof
    let m be Element of NAT;
    assume
A7: m <= LifeSpan s1 implies Computation(s1,m),Computation(s2,m)
 equal_outside A;
    assume
A8: m + 1 <= LifeSpan s1;
    then
A9: m < LifeSpan s1 by NAT_1:13;
A10: Computation(s1,m+1) = Following Computation(s1,m) by AMI_1:14
      .= Exec(CurInstr Computation(s1,m),Computation(s1,m));
A11: Computation(s2,m+1) = Following Computation(s2,m) by AMI_1:14
      .= Exec(CurInstr Computation(s2,m),Computation(s2,m));
    I +* Start-At insloc 0 c= s1 &
    I c= I +* Start-At insloc 0 by FUNCT_4:26,SCMFSA8A:9;
    then I c= s1 by XBOOLE_1:1;
    then
A12: I c= Computation(s1,m) by AMI_1:81;
    loop I +* Start-At insloc 0 c= s2 &
    loop I c= loop I +* Start-At insloc 0 by FUNCT_4:26,SCMFSA8A:9;
    then loop I c= s2 by XBOOLE_1:1;
    then
A13: loop I c= Computation(s2,m) by AMI_1:81;
A14: IC Computation(s1,m) in dom I by A1,SCMFSA7B:def 7;
    then
A15: IC Computation(s1,m) in dom loop I by FUNCT_4:105;
A16: CurInstr Computation(s1,m) = I.IC Computation(s1,m) by A12,A14,GRFUNC_1:8;
    then I.IC Computation(s1,m) <> halt SCM+FSA by A5,A9,AMI_1:def 46;
    then I.IC Computation(s1,m) = (loop I).IC Computation(s1,m) by FUNCT_4:111;
    then CurInstr Computation(s1,m) = Computation(s2,m).IC Computation(s1,m)
     by A13,A15,A16,GRFUNC_1:8
      .= CurInstr Computation(s2,m) by A7,A8,AMI_1:121,NAT_1:13;
    hence Computation(s1,m+1),Computation(s2,m+1) equal_outside A
     by A7,A8,A10,A11,NAT_1:13
    ,SCMFSA6A:32;
  end;
  thus for m being Element of NAT holds X[m] from NAT_1:sch 1(A3,A6);
end;

theorem Th110:
  for s being State of SCM+FSA, I being Program of SCM+FSA
  st I is_closed_on s & I is_halting_on s
  for m being Element of NAT st m < LifeSpan (s +* (I +* Start-At insloc 0))
  holds CurInstr  Computation( (s +* (I +* Start-At insloc 0)),m) =
  CurInstr  Computation((s +* (loop I +* Start-At insloc 0)),m)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* (I +* Start-At insloc 0);
  set s2 = s +* (loop I +* Start-At insloc 0);
  assume
A1: I is_closed_on s & I is_halting_on s;
  let m be Element of NAT;
  assume
A2: m < LifeSpan (s +* (I +* Start-At insloc 0));
  I +* Start-At insloc 0 c= s1 &
  I c= I +* Start-At insloc 0 by FUNCT_4:26,SCMFSA8A:9;
  then I c= s1 by XBOOLE_1:1;
  then
A3: I c= Computation(s1,m) by AMI_1:81;
  loop I +* Start-At insloc 0 c= s2 &
  loop I c= loop I +* Start-At insloc 0 by FUNCT_4:26,SCMFSA8A:9;
  then loop I c= s2 by XBOOLE_1:1;
  then
A4: loop I c= Computation(s2,m) by AMI_1:81;
A5: IC Computation(s1,m) in dom I by A1,SCMFSA7B:def 7;
  then
A6: IC Computation(s1,m) in dom loop I by FUNCT_4:105;
A7: s1 is halting by A1,SCMFSA7B:def 8;
A8: CurInstr Computation(s1,m) = I.IC Computation(s1,m) by A3,A5,GRFUNC_1:8;
  then I.IC Computation(s1,m) <> halt SCM+FSA by A2,A7,AMI_1:def 46;
  then I.IC Computation(s1,m) = (loop I).IC Computation(s1,m) by FUNCT_4:111;
  hence CurInstr Computation(s1,m) = Computation(s2,m).IC Computation(s1,m)
   by A4,A6,A8,GRFUNC_1:8
    .= CurInstr Computation(s2,m) by A1,A2,Th109,AMI_1:121;
end;

Lm3: for s being State of SCM+FSA, I being Program of SCM+FSA
st I is_closed_on s & I is_halting_on s holds
(CurInstr  Computation( (s +* (loop I +* Start-At insloc 0)),
LifeSpan (s +* (I +* Start-At insloc 0))) = goto insloc 0 &
for m being Element of NAT st m <= LifeSpan (s +* (I +* Start-At insloc 0))
holds CurInstr  Computation( (s +* (loop I +* Start-At insloc 0)),m) <>
halt SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* (I +* Start-At insloc 0);
  set s2 = s +* (loop I +* Start-At insloc 0);
  assume
A1: I is_closed_on s & I is_halting_on s;
  then
A2: s1 is halting by SCMFSA7B:def 8;
  set k = LifeSpan s1;
A3: CurInstr Computation(s1,k) = halt SCM+FSA by A2,AMI_1:def 46;
A4: not IC Computation(s1,k) in dom Start-At insloc 0 by AMI_1:137;
A5: IC Computation(s1,k) in dom I by A1,SCMFSA7B:def 7;
  then
A6: IC Computation(s1,k) in dom (I +* Start-At insloc 0) by FUNCT_4:13;
A7: CurInstr Computation(s1,k) = s1.IC Computation(s1,k) by AMI_1:54
      .= (I +* Start-At insloc 0).IC Computation(s1,k) by A6,FUNCT_4:14
      .= I.IC Computation(s1,k) by A4,FUNCT_4:12;
  dom loop I = dom I by FUNCT_4:105;
  then
A8: IC Computation(s1,k) in dom (loop I +* Start-At insloc 0) by A5,FUNCT_4:13;
X: rng I c= the Instructions of SCM+FSA by AMI_1:118;
y: dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA
                  by RELAT_1:71;
   thus
A11: CurInstr Computation(s2,LifeSpan s1)
 = Computation(s2,k).IC Computation(s1,k)
 by A1,Th109,AMI_1:121
      .= s2.IC Computation(s1,k) by AMI_1:54
      .= (loop I +* Start-At insloc 0).IC Computation(s1,k) by A8,FUNCT_4:14
      .= (loop I).IC Computation(s1,k) by A4,FUNCT_4:12
      .= (((id the Instructions of SCM+FSA)+*(halt SCM+FSA,goto insloc 0))*I
         ).IC Computation(s1,k) by X,FUNCT_7:118
      .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA,
          goto insloc 0)).halt SCM+FSA by A3,A5,A7,FUNCT_1:23
      .= goto insloc 0 by y,FUNCT_7:33;
  let m be Element of NAT;
  assume
A12: m <= LifeSpan s1;
  per cases by A12,REAL_1:def 5;
  suppose
A13: m < LifeSpan s1;
    then CurInstr Computation(s1,m) <> halt SCM+FSA by A2,AMI_1:def 46;
    hence CurInstr Computation(s2,m) <> halt SCM+FSA by A1,A13,Th110;
  end;
  suppose m = LifeSpan s1;
    hence CurInstr Computation(s2,m) <> halt SCM+FSA by A11,SCMFSA_2:47,124;
  end;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA
  st I is_closed_on s & I is_halting_on s
  for m being Element of NAT st m <= LifeSpan (s +* (I +* Start-At insloc 0))
  holds
  CurInstr  Computation(s +* (loop I +* Start-At insloc 0),m) <> halt SCM+FSA
  by Lm3;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA
  st I is_closed_on s & I is_halting_on s holds
  CurInstr  Computation( (s +* (loop I +* Start-At insloc 0)),
  LifeSpan (s +* (I +* Start-At insloc 0))) = goto insloc 0 by Lm3;

theorem Th113:
  for s being State of SCM+FSA, I being paraclosed Program of SCM+FSA
  st I +* Start-At insloc 0 c= s & s is halting
  for m being Element of NAT st m <= LifeSpan s
  holds  Computation( s,m), Computation( (s +* loop I),m) equal_outside NAT
proof
  let s be State of SCM+FSA;
  let I be paraclosed Program of SCM+FSA;
  assume
A1: I +* Start-At insloc 0 c= s;
  assume
A2: s is halting;
  defpred X[Element of NAT] means
  $1 <= LifeSpan s implies  Computation( s,$1), Computation((s+*loop I),$1)
  equal_outside NAT;
   Computation( s,0) = s &
   Computation((s+*loop I),0) = s+*loop I by AMI_1:13;
  then
A3: X[0] by AMI_1:120;
A4: for m st X[m] holds X[m+1]
  proof
    let m;
    assume
A5: m <= LifeSpan s implies  Computation( s,m), Computation((s+*loop I),m)
    equal_outside NAT;
    assume
A6: m+1 <= LifeSpan s;
    then
A7: m < LifeSpan s by NAT_1:13;
    set sI = s+*loop I;
A8: Computation(s,m+1) = Following Computation(s,m) by AMI_1:14
      .= Exec(CurInstr Computation(s,m),Computation(s,m));
A9: Computation(sI,m+1) = Following Computation(sI,m) by AMI_1:14
      .= Exec(CurInstr Computation(sI,m),Computation(sI,m));
A10: IC Computation(s,m) in dom I by A1,SCMFSA6B:def 2;
    dom I misses dom Start-At insloc 0 by SF_MASTR:64;
    then I c= I +* Start-At insloc 0 by FUNCT_4:33;
    then I c= s by A1,XBOOLE_1:1;
    then
A11: I c= Computation(s,m) by AMI_1:81;
A12: loop I c= Computation(sI,m) by AMI_1:81,FUNCT_4:26;
A13: IC Computation(s,m) in dom loop I by A10,FUNCT_4:105;
A14: CurInstr(Computation(s,m)) = I.IC(Computation(s,m)) by A10,A11,GRFUNC_1:8;
    then I.IC(Computation(s,m)) <> halt SCM+FSA by A2,A7,AMI_1:def 46;
    then CurInstr(Computation(s,m)) = (loop I).IC(Computation(s,m))
     by A14,FUNCT_4:111
      .= (Computation(sI,m)).IC(Computation(s,m)) by A12,A13,GRFUNC_1:8
      .= CurInstr(Computation(sI,m)) by A5,A6,AMI_1:121,NAT_1:13;
    hence  Computation( s,m+1), Computation((s+*loop I),m+1)
    equal_outside NAT by A5,A6,A8,A9,NAT_1:13,SCMFSA6A:32;
  end;
  thus for m being Element of NAT holds X[m] from NAT_1:sch 1(A3,A4);
end;

theorem
  for s being State of SCM+FSA, I being parahalting Program of SCM+FSA
  st Initialized I c= s holds
  for k being Element of NAT st k <= LifeSpan s holds
  CurInstr  Computation( (s +* loop I),k) <> halt SCM+FSA
proof
  let s be State of SCM+FSA;
  let I be parahalting Program of SCM+FSA;
  assume
A1: Initialized I c= s;
  then
A2: s is halting by AMI_1:def 26;
A3: I +* Start-At insloc 0 c= s by A1,SCMFSA6B:8;
  set s2 = s +* loop I;
  hereby
    let k be Element of NAT;
    assume
A4: k <= LifeSpan s;
    set lk = IC  Computation( s,k);
A5: IC  Computation( s,k) in dom I by A3,SCMFSA6B:def 2;
A6: dom I = dom loop I by FUNCT_4:105;
    assume
A7: CurInstr  Computation( (s +* loop I),k) = halt SCM+FSA;
A8: CurInstr  Computation( s2,k)
    =  Computation(s2,k).lk by A2,A3,A4,Th113,AMI_1:121
      .= s2.lk by AMI_1:54
      .= (loop I).lk by A5,A6,FUNCT_4:14;
    (loop I).lk in rng loop I by A5,A6,FUNCT_1:def 5;
    hence contradiction by A7,A8,Th107;
  end;
end;

begin :: Times

definition
  let a be Int-Location;
  let I be Program of SCM+FSA;
  func Times(a,I) -> Program of SCM+FSA equals
  if>0(a,loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0)), Stop SCM+FSA);
  correctness;
end;

theorem Th115: ::T211147 *** n.t
  for I being good Program of SCM+FSA, a being read-write Int-Location holds
  if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0)) is good
proof
  let I be good Program of SCM+FSA;
  let a be read-write Int-Location;
  reconsider J3 = Macro SubFrom(a,intloc 0) as good Program of SCM+FSA
  by Th99,SCMFSA7B:14;
  I ';' SubFrom(a,intloc 0) = I ';' J3;
  then reconsider I1 = I ';' SubFrom(a,intloc 0) as good Program of SCM+FSA;
  reconsider J1 = Macro (a =0_goto insloc (card I1 + 3))
  as good Program of SCM+FSA by Th99,SCMFSA7B:18;
  if=0(a,Goto insloc 2,I1) = (a =0_goto insloc (card I1 + 3) ';' I1 ';'
  Goto insloc (card Goto insloc 2 + 1)) ';' Goto insloc 2 ';' Stop SCM+FSA
  by SCMFSA8B:def 1
    .= J1 ';' I1 ';' Goto insloc (card Goto insloc 2 + 1) ';'
  Goto insloc 2 ';' Stop SCM+FSA;
  hence if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0)) is good;
end;

theorem Th116: ::T21921 ** n.t
  for I,J being Program of SCM+FSA,a being Int-Location holds
  if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0)).
  insloc (card (I ';' SubFrom(a,intloc 0)) + 3) =
  goto insloc (card (I ';' SubFrom(a,intloc 0)) + 5)
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  set I1 = I ';' SubFrom(a,intloc 0);
  set J3 = a =0_goto insloc (card I1 + 3) ';' I1 ';'
  Goto insloc (card Goto insloc 2 + 1);
  set J4 = (a =0_goto insloc (card I1 + 3) ';' I1 ';'
  Goto insloc (card Goto insloc 2 + 1)) ';' Goto insloc 2;
A1: card (a =0_goto insloc (card I1 + 3) ';' I1)
    = card Macro (a =0_goto insloc (card I1 + 3)) + card I1 by SCMFSA6A:61
    .= 2 + card I1 by SCMFSA7B:6;
  card Goto insloc (card Goto insloc 2 + 1) = 1 by SCMFSA8A:29;
  then
A2: card J3 = card I1 + 2 + 1 by A1,SCMFSA6A:61
    .= card I1 + (2 + 1);
A3: card Goto insloc 2 = 1 by SCMFSA8A:29;
  then
A4: card J4 = card I1 + (2 + 1) + 1 by A2,SCMFSA6A:61
    .= card I1 + (2 + 1 + 1);
  card I1 + (2 + 1) -' card J3 = 0 by A2,BINARITH:51;
  then
A5: goto insloc 2 = (Goto insloc 2).insloc (card I1 + (2 + 1) -' card J3 )
  by SCMFSA8A:47;
  card I1 + (2 + 1) < card J3 + card Goto insloc 2 by A2,A3,NAT_1:13;
  then
A6: J4.insloc (card I1 + (2 + 1))
  = IncAddr(goto insloc 2,card J3) by A2,A5,Th13
    .= goto (insloc 2 + (card I1 + (2 + 1))) by A2,SCMFSA_4:14
    .= goto insloc (card I1 + (2 + 3));
A7: 6 <> 0 & InsCode goto insloc (card I1 + 5) = 6 &
  InsCode halt SCM+FSA = 0 by SCMFSA_2:47,124;
  card J4 = card I1 + 3 + 1 by A4;
  then card I1 + 3 < card J4 by NAT_1:13;
  then
A8: insloc (card I1 + 3) in dom J4 by SCMFSA6A:15;
  then (J4 ';' Stop SCM+FSA).insloc (card I1 + 3)
  = (Directed J4).insloc (card I1 + 3) by SCMFSA8A:28
    .= goto insloc (card I1 + 5) by A6,A7,A8,SCMFSA8A:30;
  hence if=0(a,Goto insloc 2,I1).insloc (card I1 + 3)
  = goto insloc (card I1 + 5) by SCMFSA8B:def 1;
end;

theorem Th117:
  for s being State of SCM+FSA, I being good parahalting Program of SCM+FSA,
  a being read-write Int-Location st
  I does_not_destroy a & s.intloc 0 = 1 & s.a > 0 holds
  loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0)) is_pseudo-closed_on s
proof
  set A = NAT;
  let s be State of SCM+FSA;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  assume
A2: s.intloc 0 = 1;
  assume
A3: s.a > 0;
  set P = if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0));
  reconsider I1 = I ';' SubFrom(a,intloc 0) as parahalting Program of SCM+FSA;
  set i = a =0_goto insloc (card I1 + 3);
  defpred P[Element of NAT] means
  for s being State of SCM+FSA st s.intloc 0 = 1 & s.a = $1 & s.a > 0 holds
  ( Computation( (s +* (loop P +* Start-At insloc 0)),
  (LifeSpan (s +* (P +* Start-At insloc 0)) + 1))).a = s.a - 1 &
  ( Computation( (s +* (loop P +* Start-At insloc 0)),
  (LifeSpan (s +* (P +* Start-At insloc 0)) + 1))).intloc 0 = 1 &
  ex k being Element of NAT st
  IC  Computation( (s +* (loop P +* Start-At insloc 0)),k) =
  insloc card ProgramPart loop P & for n being Element of NAT st n < k holds
  IC  Computation( (s +* (loop P +* Start-At insloc 0)),n) in dom loop P;
A4: P[0];
A5: for k being Element of NAT holds P[k] implies P[k + 1]
  proof
    let k be Element of NAT;
    assume
A6: P[k];
    let ss be State of SCM+FSA;
    assume
A7: ss.intloc 0 = 1;
    assume
A8: ss.a = k + 1;
    assume
A9: ss.a > 0;
    set s1 = ss +* (P +* Start-At insloc 0);
    set s2 = ss +* (loop P +* Start-At insloc 0);
    set s3 = Computation(s2,LifeSpan s1 + 1);
A10: now
A11:  now thus card loop P = card dom loop P by PRE_CIRC:21
          .= card dom P by FUNCT_4:105
          .= card P by PRE_CIRC:21;
        thus card P = card Goto insloc 2 + card I1 + 4 by SCMFSA8B:14
          .= card I1 + 1 + 4 by SCMFSA8A:29
          .= card I1 + 3 + 2;
      end;
A12:  now thus P = i ';' I1 ';' Goto insloc (card Goto insloc 2 + 1) ';'
        Goto insloc 2 ';' Stop SCM+FSA by SCMFSA8B:def 1
          .= i ';' (I1 ';' Goto insloc (card Goto insloc 2 + 1)) ';'
        Goto insloc 2 ';' Stop SCM+FSA by SCMFSA6A:71
          .= i ';' (I1 ';' Goto insloc (card Goto insloc 2 + 1) ';'
        Goto insloc 2) ';' Stop SCM+FSA by SCMFSA6A:71
          .= i ';' (I1 ';' Goto insloc (card Goto insloc 2 + 1) ';'
        Goto insloc 2 ';' Stop SCM+FSA) by SCMFSA6A:71
          .= Macro i ';' (I1 ';' Goto insloc (card Goto insloc 2 + 1) ';'
        Goto insloc 2 ';' Stop SCM+FSA);
      end;
      InsCode i = 7 & InsCode halt SCM+FSA = 0 by SCMFSA_2:48,124;
      then insloc 0 in dom Macro i &
      (Macro i).insloc 0 <> halt SCM+FSA by SCMFSA6B:32,33;
      hence P.insloc 0 = (Macro i).insloc 0 by A12,SCMFSA6A:54
        .= i by SCMFSA6B:33;
      hence P.insloc 0 <> halt SCM+FSA by SCMFSA_2:48,124;
      thus insloc 0 in dom P by A11,SCMFSA6A:15;
      card ProgramPart loop P = card I1 + (3 + 2) by A11,AMI_1:105;
      hence P.insloc (card I1 + 3) = goto insloc card ProgramPart loop P by
      Th116;
      hence P.insloc (card I1 + 3) <> halt SCM+FSA by SCMFSA_2:47,124;
      hereby
        card I1 + 3 + 0 < card P by A11,XREAL_1:8;
        hence insloc (card I1 + 3) in dom P by SCMFSA6A:15;
      end;
    end;
A13: now
      I1 is_closed_on ss & I1 is_halting_on ss by SCMFSA7B:24,25;
      hence
A14:  P is_closed_on ss & P is_halting_on ss by A9,SCMFSA8B:18;
A15:  Computation(s2,LifeSpan s1+1) = Following Computation(s2,LifeSpan s1)
 by AMI_1:14
        .= Exec(CurInstr Computation(s2,LifeSpan s1),
        Computation(s2,LifeSpan s1));
      hence Computation(s2,LifeSpan s1+1) =
       Exec(goto insloc 0,Computation(s2,LifeSpan s1))
      by A14,Lm3;
      thus IC Computation(s2,LifeSpan s1+1)
      = Exec(goto insloc 0,Computation(s2,LifeSpan s1)).IC SCM+FSA
       by A14,A15,Lm3
        .= insloc 0 by SCMFSA_2:95;
    end;
A16: now
A17:  now thus card loop P = card dom loop P by PRE_CIRC:21
          .= card dom P by FUNCT_4:105
          .= card P by PRE_CIRC:21;
        thus card P = card Goto insloc 2 + card I1 + 4 by SCMFSA8B:14
          .= card I1 + 1 + 4 by SCMFSA8A:29
          .= card I1 + 3 + 2;
      end;
      hereby
        thus insloc 0 in dom loop P by A17,SCMFSA6A:15;
        card I1 + 3 + (1 + 1) = (card I1 + 3 + 1) + 1;
        then card I1 + 3 + 1 < card P by A17,NAT_1:13;
        then card I1 + 3 < card loop P by A17,NAT_1:13;
        hence insloc (card I1 + 3) in dom loop P by SCMFSA6A:15;
      end; thus
A18:  now intloc 0 in dom ss by SCMFSA_2:66;
        then
A19:    ss +* (intloc 0 .--> 1) = ss by A7,FUNCT_7:111;
A20:    dom P misses dom Start-At insloc 0 by SF_MASTR:64;
        Initialize ss = ss +* (intloc 0 .--> 1) +* Start-At insloc 0
        by SCMFSA6C:def 3;
        hence Initialize ss +* (P +* Start-At insloc 0)
        = ss +* Start-At insloc 0 +* (Start-At insloc 0 +* P)
        by A19,A20,FUNCT_4:36
          .= ss +* Start-At insloc 0 +* Start-At insloc 0 +* P by FUNCT_4:15
          .= ss +* (Start-At insloc 0 +* Start-At insloc 0) +* P by FUNCT_4:15
          .= ss +* (Start-At insloc 0 +* P) by FUNCT_4:15
          .= ss +* (P +* Start-At insloc 0) by A20,FUNCT_4:36;
      end;
      consider Is being State of SCM+FSA such that
A21:  Is = Initialize ss +* (P +* Start-At insloc 0);
A22:  I1 is_halting_on Initialize ss by SCMFSA7B:25;
A23:  now
A24:    now
          let b be Int-Location;
          Computation(s1,LifeSpan s1),Computation(s2,LifeSpan s1)
           equal_outside A &
          Computation(s2,LifeSpan s1+1).b = Computation(s2,LifeSpan s1).b
          by A13,Th109,SCMFSA_2:95;
          hence Computation(s2,LifeSpan s1+1).b =
           Computation( Is,LifeSpan Is).b by A18,A21,SCMFSA6A:30;
        end;
        (Initialize ss).a > 0 &
        I1 is_closed_on Initialize ss & I1 is_halting_on Initialize ss
        by A9,SCMFSA6C:3,SCMFSA7B:24,25;
        then
A25:    P is_halting_on Initialize ss & P is_closed_on Initialize ss
        by SCMFSA8B:18;
        thus Computation(s2,LifeSpan s1+1).a =
          Computation( Is,LifeSpan Is).a by A24
          .= IExec(P,ss).a by A21,A25,Th87;
A26:    P is good by Th115;
        thus Computation(s2,LifeSpan s1+1).intloc 0
        =  Computation( Is,LifeSpan Is).intloc 0 by A24
          .= 1 by A21,A25,A26,Th96;
      end;
      ss.a <> 0 & I1 is_closed_on Initialize ss by A9,SCMFSA7B:24;
      then IExec(P,ss) = IExec(I1,ss) +* Start-At insloc (card Goto
      insloc 2 + card I1 + 3) by A22,SCMFSA8B:19;
      then IExec(P,ss).a = IExec(I1,ss).a by SCMFSA_3:11;
      hence Computation(s2,LifeSpan s1+1).a
      =  Computation( (Initialize ss +* (I1 +* Start-At insloc 0)),
      (LifeSpan (Initialize ss +* (I1 +* Start-At insloc 0)))).a
      by A22,A23,Th87
        .= ss.a - 1 by A1,Th98;
      thus Computation(s2,LifeSpan s1+1).intloc 0 = 1 by A23;
    end;
    hence s3.a = ss.a - 1 & s3.intloc 0 = 1;
    hereby per cases;
      suppose
A27:    k = 0;
        take m = LifeSpan s1 + 1 + 1 + 1;
A28:    now thus CurInstr Computation(s2,LifeSpan s1+1) = s2.insloc 0
 by A13,AMI_1:54
            .= (loop P).insloc 0 by A16,Th26
            .= i by A10,FUNCT_4:111;
        end;
A29:    now thus
          Computation(s2,LifeSpan s1+1+1) =
           Following Computation(s2,LifeSpan s1+1) by
          AMI_1:14
            .= Exec(i,Computation(s2,LifeSpan s1+1)) by A28;
        end;
        then
A30:    IC Computation(s2,LifeSpan s1+1+1)
        = insloc (card I1 + 3) by A8,A16,A27,SCMFSA_2:96;
A31:    now thus CurInstr Computation(s2,LifeSpan s1+1+1)
          = s2.insloc (card I1 + 3) by A30,AMI_1:54
            .= (loop P).insloc (card I1 + 3) by A16,Th26
            .= goto insloc card ProgramPart loop P by A10,FUNCT_4:111;
        end;
        Computation(s2,m) = Following Computation(s2,LifeSpan s1+1+1)
         by AMI_1:14
          .= Exec(goto insloc card ProgramPart loop P,
          Computation(s2,LifeSpan s1+1+1))
        by A31;
        hence IC Computation(s2,m) = insloc card ProgramPart loop P
         by SCMFSA_2:95;
        hereby
          let n be Element of NAT;
          assume n < m;
          then n <= LifeSpan s1 + 1 + 1 by NAT_1:13;
          then
A32:      n <= LifeSpan s1 + 1 or n = LifeSpan s1 + 1 + 1 by NAT_1:8;
          per cases by A32,NAT_1:8;
          suppose
A33:        n <= LifeSpan s1;
            I1 is_closed_on ss & I1 is_halting_on ss by SCMFSA7B:24,25;
            then
A34:        P is_closed_on ss & P is_halting_on ss by A9, SCMFSA8B:18;
            then Computation(s1,n),Computation(s2,n) equal_outside A
             by A33,Th109;
            then
A35:        IC Computation(s2,n) = IC Computation(s1,n) by SCMFSA8A:6;
            IC Computation(s1,n) in dom P by A34,SCMFSA7B:def 7;
            hence IC Computation(s2,n) in dom loop P by A35,FUNCT_4:105;
          end;
          suppose n = LifeSpan s1 + 1;
            hence IC Computation(s2,n) in dom loop P by A13,A16;
          end;
          suppose n = LifeSpan s1 + 1 + 1;
            hence IC Computation(s2,n) in dom loop P
             by A8,A16,A27,A29,SCMFSA_2:96;
          end;
        end;
      end;
      suppose
A36:    k > 0;
        consider Is3 being State of SCM+FSA such that
A37:    Is3 = Initialize s3;
A38:    Is3.intloc 0 = 1 by A37,SCMFSA6C:3;
        Is3.a = k & Is3.a > 0 by A8,A16,A36,A37,SCMFSA6C:3;
        then consider m0 being Element of NAT such that
A39:    IC  Computation( (Is3 +* (loop P +* Start-At insloc 0)),m0) =
        insloc card ProgramPart loop P and
A40:    for n being Element of NAT st n < m0 holds
        IC  Computation( (Is3 +* (loop P +* Start-At insloc 0)),n)
        in dom loop P by A6,A38;
        take m = LifeSpan s1 + 1 + m0;
A41:    now thus
          s3.IC SCM+FSA = IC s3;
A42:      IC SCM+FSA in dom s3 by AMI_1:94;
A43:      dom loop P misses dom Start-At insloc 0 by SF_MASTR:64;
          now thus s2 = ss +* (Start-At insloc 0 +* loop P) by A43, FUNCT_4:
            36
              .= ss +* Start-At insloc 0 +* loop P by FUNCT_4:15;
          end;
          then ProgramPart loop P c= s3 by AMI_1:99,FUNCT_4:26;
          then
A44:      loop P c= s3 by AMI_1:105;
          now thus Initialize s3 +* (loop P +* Start-At insloc 0)
            = Initialize s3 +* (Start-At insloc 0 +* loop P) by A43,FUNCT_4:36
              .= Initialize s3 +* Start-At insloc 0 +* loop P by FUNCT_4:15;
          end;
          then Initialize s3 +* (loop P +* Start-At insloc 0)
          = s3 +* (IC SCM+FSA .--> insloc 0) +*loop P by A13,A16,Th14;
          hence Initialize s3 +* (loop P +* Start-At insloc 0)
          = s3 +* loop P by A13,A42,FUNCT_7:111
            .= s3 by A44,FUNCT_4:79;
        end;
        hence IC Computation(s2,m) = insloc card ProgramPart
         loop P by A37,A39,AMI_1:51;
        hereby
          let n be Element of NAT;
          assume
A45:      n < m;
          I1 is_closed_on ss & I1 is_halting_on ss by SCMFSA7B:24,25;
          then
A46:      P is_closed_on ss & P is_halting_on ss by A9,SCMFSA8B: 18;
          per cases by NAT_1:13;
          suppose n <= LifeSpan s1;
            then Computation(s1,n),Computation(s2,n) equal_outside A
             by A46,Th109;
            then
A47:        IC Computation(s2,n) = IC Computation(s1,n) by SCMFSA8A:6;
            IC Computation(s1,n) in dom P by A46,SCMFSA7B:def 7;
            hence IC Computation(s2,n) in dom loop P by A47,FUNCT_4:105;
          end;
          suppose
A48:        LifeSpan s1 + 1 <= n;
            consider mm being Element of NAT such that
A49:        mm = n -' (LifeSpan s1 + 1);
            mm + (LifeSpan s1 + 1) = n by A48,A49,BINARITH:53;
            then
A50:        IC Computation(s2,n) = IC  Computation( s3,mm) by AMI_1:51;
            n - (LifeSpan s1 + 1) >= 0 by A48,XREAL_1:50;
            then mm = n - (LifeSpan s1 + 1) & m0 = m - (LifeSpan s1 + 1)
            by A49,BINARITH:def 3;
            then mm < m0 by A45,XREAL_1:11;
            hence IC Computation(s2,n) in dom loop P by A37,A40,A41,A50;
          end;
        end;
      end;
    end;
  end;
  reconsider sa = s.a as Element of NAT by A3,INT_1:16;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A4,A5);
  then P[sa];
  then ex k being Element of NAT st
  IC  Computation( (s +* (loop P +* Start-At insloc 0)),k) =
  insloc card ProgramPart loop P & for n being Element of NAT st n < k holds
  IC  Computation( (s +* (loop P +* Start-At insloc 0)),n) in dom loop P
  by A2,A3;
  hence loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s by SCMFSA8A:def 3;
end;

theorem
  for s being State of SCM+FSA, I being good parahalting Program of SCM+FSA,
  a being read-write Int-Location st I does_not_destroy a & s.a > 0 holds
  Initialized loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s
proof
  let s be State of SCM+FSA;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  assume
A2: s.a > 0;
  (Initialize s).a = s.a & (Initialize s).intloc 0 = 1 by SCMFSA6C:3;
  then loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on Initialize s by A1,A2,Th117;
  hence Initialized loop if=0(a,Goto insloc 2,I ';'
  SubFrom(a,intloc 0)) is_pseudo-closed_on s by Lm1;
end;

theorem
  for s being State of SCM+FSA, I being good parahalting Program of SCM+FSA,
  a being read-write Int-Location
  st I does_not_destroy a & s.intloc 0 = 1 holds
  Times(a,I) is_closed_on s & Times(a,I) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  assume
A2: s.intloc 0 = 1;
  per cases;
  suppose
A3: s.a > 0;
    Directed loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0)) =
    loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0)) by SCMFSA6A:63;
    then Directed loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0))
    is_pseudo-closed_on s by A1,A2,A3,Th117;
    hence Times(a,I) is_closed_on s & Times(a,I) is_halting_on s by A3,Th68;
  end;
  suppose
A4: s.a <= 0;
    Stop SCM+FSA is_closed_on s & Stop SCM+FSA is_halting_on s
    by SCMFSA7B:24,25;
    hence Times(a,I) is_closed_on s & Times(a,I) is_halting_on s
    by A4,SCMFSA8B:24;
  end;
end;

theorem
  for I being good parahalting Program of SCM+FSA,
  a being read-write Int-Location st I does_not_destroy a holds
  Initialized Times(a,I) is halting
proof
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  now
    let s be State of SCM+FSA;
    per cases;
    suppose s.a > 0;
      then
A2:   (Initialize s).intloc 0 = 1 & (Initialize s).a > 0 by SCMFSA6C :3;
      Directed loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0)) =
      loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0)) by SCMFSA6A:63;
      then Directed loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0))
      is_pseudo-closed_on Initialize s by A1,A2,Th117;
      then Times(a,I) is_halting_on Initialize s by A2,Th68;
      hence Initialized Times(a,I) is_halting_on s by Th22;
    end;
    suppose s.a <= 0;
      then
A3:   (Initialize s).a <= 0 by SCMFSA6C:3;
      Stop SCM+FSA is_closed_on Initialize s &
      Stop SCM+FSA is_halting_on Initialize s by SCMFSA7B:24,25;
      then Times(a,I) is_halting_on Initialize s by A3,SCMFSA8B:24;
      hence Initialized Times(a,I) is_halting_on s by Th22;
    end;
  end;
  hence Initialized Times(a,I) is halting by Th24;
end;

theorem
  for I,J being Program of SCM+FSA, a,c being Int-Location st
  I does_not_destroy c & J does_not_destroy c holds
  if=0(a,I,J) does_not_destroy c & if>0(a,I,J) does_not_destroy c
proof
  let I,J be Program of SCM+FSA;
  let a,c be Int-Location;
  assume
A1: I does_not_destroy c;
  assume
A2: J does_not_destroy c;
  then
A3: a =0_goto insloc (card J + 3) ';' J does_not_destroy c by Th82,
  SCMFSA7B:18;
  Goto insloc (card I + 1) does_not_destroy c by Th86;
  then a =0_goto insloc (card J + 3) ';' J ';' Goto insloc (card I + 1)
  does_not_destroy c by A3,Th81;
  then
A4: a =0_goto insloc (card J + 3) ';' J ';' Goto insloc (card I + 1) ';' I
  does_not_destroy c by A1,Th81;
A5: Stop SCM+FSA does_not_destroy c by Th85;
  if=0(a,I,J) = a =0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 1;
  hence if=0(a,I,J) does_not_destroy c by A4,A5,Th81;
A6: a >0_goto insloc (card J + 3) ';' J does_not_destroy c by A2,Th82,SCMFSA7B:
  19;
  Goto insloc (card I + 1) does_not_destroy c by Th86;
  then a >0_goto insloc (card J + 3) ';' J ';' Goto insloc (card I + 1)
  does_not_destroy c by A6,Th81;
  then
A7: a >0_goto insloc (card J + 3) ';' J ';' Goto insloc (card I + 1) ';' I
  does_not_destroy c by A1,Th81;
A8: Stop SCM+FSA does_not_destroy c by Th85;
  if>0(a,I,J) = a >0_goto insloc (card J + 3) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA by SCMFSA8B:def 2;
  hence if>0(a,I,J) does_not_destroy c by A7,A8,Th81;
end;

theorem Th122:
  for s being State of SCM+FSA, I being good parahalting Program of SCM+FSA,
  a being read-write Int-Location st I does_not_destroy a &
  s.intloc 0 = 1 & s.a > 0 holds
  ex s2 being State of SCM+FSA, k being Element of NAT st
  s2 = s +* (loop if=0(a,Goto insloc 2,
  I ';' SubFrom(a,intloc 0)) +* Start-At insloc 0) &
  k = LifeSpan (s +* (if=0(a,Goto insloc 2,
  I ';' SubFrom(a,intloc 0)) +* Start-At insloc 0)) + 1 &
   Computation( s2,k).a = s.a - 1 &  Computation( s2,k).intloc 0 = 1 &
  (for b being read-write Int-Location st b <> a holds
   Computation( s2,k).b = IExec(I,s).b) &
  (for f being FinSeq-Location holds  Computation( s2,k).f = IExec(I,s).f) &
  IC  Computation( s2,k) = insloc 0 &
  for n being Element of NAT st n <= k holds IC  Computation( s2,n) in
  dom loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0))
proof
  set A = NAT;
  let s be State of SCM+FSA;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  assume
A2: s.intloc 0 = 1;
  assume
A3: s.a > 0;
  set P = if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0));
  reconsider I1 = I ';' SubFrom(a,intloc 0) as parahalting Program of SCM+FSA;
  set s1 = s +* (P +* Start-At insloc 0);
  take s2 = s +* (loop P +* Start-At insloc 0);
  take k = LifeSpan s1 + 1;
  thus s2 = s +* (loop if=0(a,Goto insloc 2,
  I ';' SubFrom(a,intloc 0)) +* Start-At insloc 0) &
  k = LifeSpan (s +* (if=0(a,Goto insloc 2,
  I ';' SubFrom(a,intloc 0)) +* Start-At insloc 0)) + 1;
  I1 is_closed_on s & I1 is_halting_on s by SCMFSA7B:24,25;
  then
A4: P is_closed_on s & P is_halting_on s by A3,SCMFSA8B:18;
A5: Computation(s2,LifeSpan s1+1) = Following Computation(s2,LifeSpan s1)
 by AMI_1:14
    .= Exec(CurInstr Computation(s2,LifeSpan s1),Computation(s2,LifeSpan s1));
  then
A6: Computation(s2,LifeSpan s1+1) =
Exec(goto insloc 0,Computation(s2,LifeSpan s1)) by A4,Lm3;
A7: IC Computation(s2,LifeSpan s1+1)
  = Exec(goto insloc 0,Computation(s2,LifeSpan s1)).IC SCM+FSA by A4,A5,Lm3
    .= insloc 0 by SCMFSA_2:95;
A8: now intloc 0 in dom s by SCMFSA_2:66;
    then
A9: s +* (intloc 0 .--> 1) = s by A2,FUNCT_7:111;
A10: dom P misses dom Start-At insloc 0 by SF_MASTR:64;
    Initialize s = s +* (intloc 0 .--> 1) +* Start-At insloc 0
    by SCMFSA6C:def 3;
    hence Initialize s +* (P +* Start-At insloc 0)
    = s +* Start-At insloc 0 +* (Start-At insloc 0 +* P) by A9,A10,FUNCT_4:36
      .= s +* Start-At insloc 0 +* Start-At insloc 0 +* P by FUNCT_4:15
      .= s +* (Start-At insloc 0 +* Start-At insloc 0) +* P by FUNCT_4:15
      .= s +* (Start-At insloc 0 +* P) by FUNCT_4:15
      .= s +* (P +* Start-At insloc 0) by A10,FUNCT_4:36;
  end;
  set Is = Initialize s +* (P +* Start-At insloc 0);
A11: now
    let b be Int-Location;
    Computation(s1,LifeSpan s1),Computation(s2,LifeSpan s1) equal_outside A &
    Computation(s2,LifeSpan s1+1).b = Computation(s2,LifeSpan s1).b
     by A4,A6,Th109,SCMFSA_2:95;
    hence Computation(s2,LifeSpan s1+1).b =  Computation( Is,LifeSpan Is).b
     by A8,
    SCMFSA6A:30;
  end;
A12: I1 is_halting_on Initialize s by SCMFSA7B:25;
  (Initialize s).a > 0 &
  I1 is_closed_on Initialize s & I1 is_halting_on Initialize s
  by A3,SCMFSA6C:3,SCMFSA7B:24,25;
  then
A13: P is_halting_on Initialize s & P is_closed_on Initialize s
  by SCMFSA8B:18;
A14: now
    thus Computation(s2,LifeSpan s1+1).a =  Computation( Is,LifeSpan Is).a
     by A11
      .= IExec(P,s).a by A13,Th87;
A15: P is good by Th115;
    thus Computation(s2,LifeSpan s1+1).intloc 0
    =  Computation( Is,LifeSpan Is).intloc 0 by A11
      .= 1 by A13,A15,Th96;
  end;
  s.a <> 0 & I1 is_closed_on Initialize s by A3,SCMFSA7B:24;
  then
A16: IExec(P,s) = IExec(I1,s) +* Start-At insloc (card Goto
  insloc 2 + card I1 + 3) by A12,SCMFSA8B:19;
  then IExec(P,s).a = IExec(I1,s).a by SCMFSA_3:11;
  hence  Computation( s2,k).a
  =  Computation( (Initialize s +* (I1 +* Start-At insloc 0)),
  (LifeSpan (Initialize s +* (I1 +* Start-At insloc 0)))).a by A12,A14,Th87
    .= s.a - 1 by A1,Th98;
  thus  Computation( s2,k).intloc 0 = 1 by A14;
  hereby
    let b be read-write Int-Location;
    assume
A17: b <> a;
    thus  Computation( s2,k).b =  Computation( Is,LifeSpan Is).b by A11
      .= IExec(P,s).b by A13,Th87
      .= IExec(I1,s).b by A16,SCMFSA_3:11
      .= Exec(SubFrom(a,intloc 0),IExec(I,s)).b by SCMFSA6C:7
      .= IExec(I,s).b by A17,SCMFSA_2:91;
  end;
  hereby
    let f be FinSeq-Location;
    Computation(s1,LifeSpan s1),Computation(s2,LifeSpan s1) equal_outside A &
    Computation(s2,LifeSpan s1+1).f = Computation(s2,LifeSpan s1).f
     by A4,A6,Th109,SCMFSA_2:95;
    hence  Computation( s2,k).f =  Computation( Is,LifeSpan Is).f by A8,
    SCMFSA6A:31
      .= IExec(P,s).f by A13,Th87
      .= IExec(I1,s).f by A16,SCMFSA_3:12
      .= Exec(SubFrom(a,intloc 0),IExec(I,s)).f by SCMFSA6C:8
      .= IExec(I,s).f by SCMFSA_2:91;
  end;
  thus IC  Computation( s2,k) = insloc 0 by A7;
  hereby
    let n be Element of NAT;
    assume
A18: n <= k;
    per cases by A18,NAT_1:8;
    suppose
A19:  n <= LifeSpan s1;
      I1 is_closed_on s & I1 is_halting_on s by SCMFSA7B:24,25;
      then
A20:  P is_closed_on s & P is_halting_on s by A3,SCMFSA8B:18;
      then Computation(s1,n),Computation(s2,n) equal_outside A by A19,Th109;
      then
A21:  IC Computation(s2,n) = IC Computation(s1,n) by SCMFSA8A:6;
      IC Computation(s1,n) in dom P by A20,SCMFSA7B:def 7;
      hence IC  Computation( s2,n) in dom loop P by A21,FUNCT_4:105;
    end;
    suppose
A22:  n = LifeSpan s1 + 1;
A23:  card loop P = card dom loop P by PRE_CIRC:21
        .= card dom P by FUNCT_4:105
        .= card P by PRE_CIRC:21;
      card P = card Goto insloc 2 + card I1 + 4 by SCMFSA8B:14
        .= card I1 + 1 + 4 by SCMFSA8A:29
        .= card I1 + 3 + 2;
      hence IC  Computation( s2,n) in dom loop P by A7,A22,A23,SCMFSA6A:15;
    end;
  end;
end;

theorem Th123:
  for s being State of SCM+FSA, I being good parahalting Program of SCM+FSA,
  a being read-write Int-Location st s.intloc 0 = 1 & s.a <= 0 holds
  DataPart IExec(Times(a,I),s) = DataPart s
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.intloc 0 = 1;
  assume s.a <= 0;
  then
A2: (Initialize s).a <= 0 by SCMFSA6C:3;
  set s0 = Initialize s;
A3: Stop SCM+FSA is_closed_on Initialize s &
  Stop SCM+FSA is_halting_on Initialize s by SCMFSA7B:24,25;
  then
A4: Times(a,I) is_closed_on Initialize s &
  Times(a,I) is_halting_on Initialize s by A2,SCMFSA8B:24;
B5:  Stop SCM+FSA is_closed_on s0 & Stop SCM+FSA is_halting_on s0
  by SCMFSA7B:24,25;
A6: s0.intloc 0 = 1 & (for a being read-write Int-Location holds s0.a = s.a) &
  for f being FinSeq-Location holds s0.f = s.f by SCMFSA6C:3;
  then
A7: DataPart IExec(Times(a,I),s) = DataPart IExec(Times(a,I),s0) by A4,Th45
    .= DataPart IExec(Stop SCM+FSA ';' Stop SCM+FSA,s0)
     by A2,B5,A6,Th73,SCMFSA8A:37;
A8: DataPart IExec(Stop SCM+FSA,s0)
  = DataPart(Initialize s0 +* Start-At insloc 0) by Th38
    .= DataPart (Initialize s +* Start-At insloc 0) by Th15
    .= DataPart s0 by SCMFSA8A:10;
  IExec(Stop SCM+FSA ';' Stop SCM+FSA,s0)
  = IExec(Stop SCM+FSA,IExec(Stop SCM+FSA,s0)) +*
  Start-At (IC IExec(Stop SCM+FSA,IExec(Stop SCM+FSA,s0)) +
  card Stop SCM+FSA) by SCMFSA6B:44;
  hence DataPart IExec(Times(a,I),s)
  = DataPart IExec(Stop SCM+FSA,IExec(Stop SCM+FSA,s0)) by A7,SCMFSA8A:10
    .= DataPart IExec(Stop SCM+FSA,s0) by A3,A6,A8,Th46
    .= DataPart s by A1,A8,Th27;
end;

theorem Th124:
  for s being State of SCM+FSA, I being good parahalting Program of SCM+FSA,
  a being read-write Int-Location st I does_not_destroy a & s.a > 0 holds
  IExec(I ';' SubFrom(a,intloc 0),s).a = s.a - 1 &
  DataPart IExec(Times(a,I),s)
   = DataPart IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s))
proof
  set D = Int-Locations \/ FinSeq-Locations;
  set A = NAT;
  let s be State of SCM+FSA;
  let I be good parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I does_not_destroy a;
  assume
A2: s.a > 0;
  set I1 = I ';' SubFrom(a,intloc 0);
  set ss = IExec(I1,s);
  set s0 = Initialize s;
  set ss0 = Initialize ss;
  set P = if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0));
  set s21 = s0 +* (loop P ';' Stop SCM+FSA +* Start-At insloc 0);
  set s31 = ss0 +* (loop P ';' Stop SCM+FSA +* Start-At insloc 0);
A3: s0.intloc 0 = 1 & s0.a > 0 by A2,SCMFSA6C:3;
  then consider s2 be State of SCM+FSA, k be Element of NAT such that
A4: s2 = s0 +* (loop P +* Start-At insloc 0) and
  k = LifeSpan (s0 +* (P +* Start-At insloc 0)) + 1 and
A5:  Computation( s2,k).a = s0.a - 1 and
A6:  Computation( s2,k).intloc 0 = 1 and
A7: (for b being read-write Int-Location st b <> a holds
   Computation( s2,k).b = IExec(I,s0).b) and
A8: (for f being FinSeq-Location holds  Computation( s2,k).f = IExec(I,s0).f)
  and
A9: IC  Computation( s2,k) = insloc 0 and
A10: for n being Element of NAT st n <= k holds
  IC  Computation( s2,n) in dom loop P by A1,Th122;
A11: I is_halting_on s0 by SCMFSA7B:25; thus
A12: now thus ss.a = Exec(SubFrom(a,intloc 0),IExec(I,s)).a by SCMFSA6C:7
      .= IExec(I,s).a - IExec(I,s).intloc 0 by SCMFSA_2:91
      .= IExec(I,s).a - 1 by A11,Th92
      .= s0.a - 1 by A1,Th91
      .= s.a - 1 by SCMFSA6C:3;
  end;
A13: Directed loop P = loop P by SCMFSA6A:63;
  then
A14: Directed loop P is_pseudo-closed_on s0 by A1,A3,Th117;
A15: DataPart IExec(Times(a,I),s0) = DataPart IExec(loop P ';' Stop SCM+FSA,s0)
  by A1,A3,A13,Th69,Th117;
  reconsider J3 = Macro SubFrom(a,intloc 0) as good Program of SCM+FSA
  by Th99,SCMFSA7B:14;
  I1 = I ';' J3;
  then
A16: I1 is good Program of SCM+FSA & I1 is_halting_on Initialize s &
  I1 is_closed_on Initialize s by SCMFSA7B:24,25;
  then
A17: ss.intloc 0 = 1 by Th96;
A18: now
    let b be Int-Location;
    per cases;
    suppose b = intloc 0;
      hence Computation(s2,k).b = IExec(I1,s).b by A6,A16,Th96;
    end;
    suppose b = a;
      hence Computation(s2,k).b = IExec(I1,s).b by A5,A12,SCMFSA6C:3;
    end;
    suppose
A19:  b <> a & b <> intloc 0;
      then reconsider bb = b as read-write Int-Location by SF_MASTR:def 5;
      thus Computation(s2,k).b = IExec(I,s0).bb by A7,A19
        .= Exec(SubFrom(a,intloc 0),IExec(I,s0)).b by A19,SCMFSA_2:91
        .= IExec(I1,s0).b by SCMFSA6C:7
        .= IExec(I1,s).b by Th17;
    end;
  end;
  now
    let f be FinSeq-Location;
    thus Computation(s2,k).f = IExec(I,s0).f by A8
      .= Exec(SubFrom(a,intloc 0),IExec(I,s0)).f by SCMFSA_2:91
      .= IExec(I1,s0).f by SCMFSA6C:8
      .= IExec(I1,s).f by Th17;
  end;
  then
A20: DataPart Computation(s2,k) = DataPart ss by A18,SCMFSA6A:38;
A21: loop P is_pseudo-closed_on s0 by A1,A3,Th117;
  insloc 0 in dom P by Th54;
  then
A22: insloc 0 in dom loop P by FUNCT_4:105;
  per cases;
  suppose
A23: ss.a = 0;
    loop P c= loop P +* Start-At insloc 0 by SCMFSA8A:9;
    then
A24: dom loop P c= dom (loop P +* Start-At insloc 0) by GRFUNC_1:8;
A25: Computation(s2,k).insloc 0 = s2.insloc 0 by AMI_1:54
      .= (loop P +* Start-At insloc 0).insloc 0 by A4,A22,A24,FUNCT_4:14
      .= (loop P).insloc 0 by A22,SCMFSA6B:7;
A26: Computation(s2,k).a = 0 by A5,A12,A23,SCMFSA6C:3;
A27: Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
      .= Exec(Computation(s2,k).insloc 0,Computation(s2,k)) by A9;
A28: P.insloc 0 = a =0_goto insloc (card I1 + 3) by Th55;
    then P.insloc 0 <> halt SCM+FSA & insloc 0 in dom P by Th54,SCMFSA_2:48,
    124;
    then
A29: Computation(s2,k).insloc 0 = a =0_goto insloc (card I1 + 3)
 by A25,A28,FUNCT_4:111;
    then InsCode Computation(s2,k).insloc 0 = 7 by SCMFSA_2:48;
    then InsCode Computation(s2,k).insloc 0 in {0,6,7,8} by ENUMSET1:def 2;
    then
A30: DataPart Computation(s2,k) = DataPart Computation(s2,k+1) by A27,Th32;
A31: IC Computation(s2,k+1) = insloc (card I1 + 3) by A26,A27,A29,SCMFSA_2:96;
A32: card I1 + (3 + 2) = card I1 + 1 + 4
      .= card Goto insloc 2 + card I1 + 4 by SCMFSA8A:29
      .= card P by SCMFSA8B:14
      .= card dom P by PRE_CIRC:21
      .= card dom loop P by FUNCT_4:105
      .= card loop P by PRE_CIRC:21;
    then card I1 + 3 + 0 < card loop P by XREAL_1:8;
    then
A33: insloc (card I1 + 3) in dom loop P by SCMFSA6A:15;
    loop P c= loop P +* Start-At insloc 0 by SCMFSA8A:9;
    then
A34: dom loop P c= dom (loop P +* Start-At insloc 0) by GRFUNC_1:8;
A35: Computation(s2,k+1).insloc (card I1 + 3) = s2.insloc (card I1 + 3)
 by AMI_1:54
      .= (loop P +* Start-At insloc 0).insloc (card I1 + 3) by A4,A33,A34,
    FUNCT_4:14
      .= (loop P).insloc (card I1 + 3) by A33,SCMFSA6B:7;
A36: P.insloc (card I1 + 3) = goto insloc (card I1 + 5) by Th65;
    then P.insloc (card I1 + 3) <> halt SCM+FSA by SCMFSA_2:47,124;
    then
A37: Computation(s2,k+1).insloc (card I1 + 3) = goto insloc (card I1 + 5)
    by A35,A36,FUNCT_4:111;
A38: Computation(s2,k+(1+1)) = Computation(s2,k+1+1)
      .= Following Computation(s2,k+1) by AMI_1:14

.= Exec(Computation(s2,k+1).insloc (card I1 + 3),Computation(s2,k+1))
 by A26,A27,A29,SCMFSA_2
    :96;
    then
A39: IC Computation(s2,k+2) = insloc (card I1 + 5) by A37,SCMFSA_2:95
      .= insloc card ProgramPart loop P by A32,AMI_1:105;
    now
      let n be Element of NAT;
      assume
A40:  not IC  Computation( s2,n) in dom loop P;
      then k < n by A10;
      then k + 1 <= n by INT_1:20;
      then k + 1 < n by A31,A33,A40,REAL_1:def 5;
      then k + 1 + 1 <= n by INT_1:20;
      hence k + (1 + 1) <= n;
    end;
    then
A41: k + 2 = pseudo-LifeSpan(s0,loop P) by A4,A21,A39,SCMFSA8A:def 5;
    InsCode Computation(s2,k+1).insloc (card I1 + 3) = 6 by A37,SCMFSA_2:47;
    then InsCode Computation(s2,k+1).insloc (card I1 + 3) in {0,6,7,8}
     by ENUMSET1:def
    2;
    then
A42: DataPart Computation(s2,k) = DataPart Computation(s2,k+2) by A30,A38,Th32;
    thus DataPart IExec(Times(a,I),s) = DataPart IExec(Times(a,I),s0) by Th17
      .= DataPart IExec(loop P ';' Stop SCM+FSA,s) by A15,Th17
      .= DataPart(Result (s +* Initialized (loop P ';' Stop SCM+FSA)) +* s | A)
    by SCMFSA6B:def 1
      .= DataPart(Result s21 +* s | A) by SCMFSA8A:13
      .= DataPart Result s21 by Th35
      .= DataPart IExec(I1,s) by A1,A3,A4,A13,A20,A41,A42,Th59,Th117
      .= DataPart IExec(Times(a,I),IExec(I1,s)) by A17,A23,Th123;
  end;
  suppose
A43: ss.a <> 0;
    s.a >= 0 + 1 by A2,INT_1:20;
    then
A44: ss.intloc 0 = 1 & ss.a > 0 by A12,A16,A43,Th96,XREAL_1:21;
A45: k < pseudo-LifeSpan(s0,loop P) by A4,A10,A1,A3,Th117,Th2;
    then
A46: DataPart Computation( s21,k) = DataPart ss by A4,A13,A14,A20,Th58;
A47: now
A48:  DataPart ss0 = DataPart s31 by SCMFSA8A:11;
      hereby
        let a be Int-Location;
        per cases;
        suppose
A49:      a = intloc 0;
          thus  Computation( s21,k).a = ss.a by A46,SCMFSA6A:38
            .= 1 by A49,SCMFSA6B:35
            .= ss0.a by A49,SCMFSA6C:3
            .= s31.a by A48,SCMFSA6A:38;
        end;
        suppose a <> intloc 0;
          then
A50:      a is read-write Int-Location by SF_MASTR:def 5;
          thus  Computation( s21,k).a = ss.a by A46,SCMFSA6A:38
            .= ss0.a by A50,SCMFSA6C:3
            .= s31.a by A48,SCMFSA6A:38;
        end;
      end;
      let f be FinSeq-Location;
      thus  Computation( s21,k).f = ss.f by A46,SCMFSA6A:38
        .= ss0.f by SCMFSA6C:3
        .= s31.f by A48,SCMFSA6A:38;
    end;
    Directed loop P = loop P by SCMFSA6A:63;
    then DataPart s0 = DataPart s21 &
    Directed loop P is_pseudo-closed_on s0 by A1,A3,Th117,SCMFSA8A:11;
    then Directed loop P is_pseudo-closed_on s21 by Th52;
    then
A51: loop P ';' Stop SCM+FSA +* Start-At insloc 0 c= s21 &
    loop P ';' Stop SCM+FSA +* Start-At insloc 0 c= s31 &
    loop P ';' Stop SCM+FSA is_closed_on s21 &
    loop P ';' Stop SCM+FSA is_halting_on s21 by Th58,FUNCT_4:26;
    IC  Computation( s21,k) = IC Computation(s2,k) by A4,A13,A14,A45,Th58
      .= IC (ss0 +* (loop P ';' Stop SCM+FSA) +* Start-At insloc 0) by A9,
    AMI_1:111
      .= IC s31 by FUNCT_4:15;
    then
A52:  Computation( s21,k),s31 equal_outside A by A47,SCMFSA6A:28;
    DataPart IExec(loop P ';' Stop SCM+FSA,s0)
    = DataPart IExec(loop P ';' Stop SCM+FSA,s) by Th17
   .= DataPart (Result (s +* Initialized (loop P ';' Stop SCM+FSA)) +* s | A)
    by SCMFSA6B:def 1
      .= DataPart(Result s21 +* s | A) by SCMFSA8A:13
      .= DataPart Result s21 by Th35
      .= DataPart Result s31 by A51,A52,Th103,SCMFSA6A:39
      .= DataPart(Result s31 +* ss | A) by Th35
      .= DataPart(Result(ss +* Initialized(loop P ';' Stop SCM+FSA)) +* ss | A)
    by SCMFSA8A:13
      .= DataPart IExec(loop P ';' Stop SCM+FSA,IExec(I1,s)) by SCMFSA6B:def 1
      .= DataPart IExec(Times(a,I),IExec(I1,s)) by A1,A13,A44,Th69,Th117;
    hence DataPart IExec(Times(a,I),s) =
    DataPart IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s)) by A15,Th17;
  end;
end;

begin :: Example

theorem
  for s being State of SCM+FSA, a,b,c being read-write Int-Location
  st a <> b & a <> c & b <> c & s.a >= 0 holds
  IExec(Times(a,Macro AddTo(b,c)),s).b = s.b + s.c * s.a
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let a,b,c be read-write Int-Location;
  assume
A1: a <> b & a <> c & b <> c;
  assume
A2: s.a >= 0;
  set P = Times(a,Macro AddTo(b,c));
  defpred P[Element of NAT] means
  for s being State of SCM+FSA st s.a = $1 holds
  IExec(Times(a,Macro AddTo(b,c)),s).b = s.b + s.c * s.a;
  reconsider I = Macro AddTo(b,c) as good parahalting Program of SCM+FSA
  by Th99,SCMFSA7B:13;
A3: P[0]
  proof
    let s be State of SCM+FSA;
    set s0 = Initialize s;
    assume
A4: s.a = 0;
    then s0.intloc 0 = 1 & s0.a = 0 by SCMFSA6C:3;
    then
A5: DataPart IExec(Times(a,I),s0) = DataPart s0 by Th123;
    thus IExec(P,s).b = IExec(P,s0).b by Th17
      .= s0.b by A5,SCMFSA6A:38
      .= s.b + s.c * s.a by A4,SCMFSA6C:3;
  end;
A6: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A7: P[k];
    let s be State of SCM+FSA;
    assume
A8: s.a = k + 1;
A9: IExec(I ';' SubFrom(a,intloc 0),s).b
    = Exec(SubFrom(a,intloc 0),IExec(I,s)).b by SCMFSA6C:7
      .= IExec(I,s).b by A1,SCMFSA_2:91
      .= Exec(AddTo(b,c),Initialize s).b by SCMFSA6C:6
      .= (Initialize s).b + (Initialize s).c by SCMFSA_2:90
      .= (Initialize s).b + s.c by SCMFSA6C:3
      .= s.b + s.c by SCMFSA6C:3;
A10: IExec(I ';' SubFrom(a,intloc 0),s).c
    = Exec(SubFrom(a,intloc 0),IExec(I,s)).c by SCMFSA6C:7
      .= IExec(I,s).c by A1,SCMFSA_2:91
      .= Exec(AddTo(b,c),Initialize s).c by SCMFSA6C:6
      .= (Initialize s).c by A1,SCMFSA_2:90
      .= s.c by SCMFSA6C:3;
    I does_not_destroy a by A1,Th77,SCMFSA7B:13;
    then
A11: IExec(I ';' SubFrom(a,intloc 0),s).a = s.a - 1 &
    DataPart IExec(Times(a,I),s) =
    DataPart IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s)) by A8,Th124;
    then IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s)).b
    = s.b + s.c + s.c * (s.a - 1) by A7,A8,A9,A10
      .= s.b + s.c * s.a;
    hence thesis by A11,SCMFSA6A:38;
  end;
A12: for k being Element of NAT holds P[k] from NAT_1:sch 1(A3,A6);
  reconsider sa = s.a as Element of NAT by A2,INT_1:16;
  P[sa] by A12;
  hence IExec(Times(a,Macro AddTo(b,c)),s).b = s.b + s.c * s.a;
end;

