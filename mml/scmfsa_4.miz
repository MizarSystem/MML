:: Modifying addresses of instructions of { \bf SCM_FSA }
::  by Andrzej Trybulec and Yatsuka Nakamura
::
:: Received February 14, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, AMI_3, SCMFSA_2, AMISTD_2, CARD_1,
      GRAPHSP, ARYTM_3, XXREAL_0, SCMNORM, RELAT_1, FUNCT_1, CARD_3, TARSKI,
      STRUCT_0, FUNCT_4, XBOOLE_0, FUNCOP_1, FSM_1, CIRCUIT2, ARYTM_1, INT_1,
      COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2, VALUED_1, ORDINAL1, FINSET_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, NUMBERS, CARD_3, XCMPLX_0,
      NAT_1, NAT_D, FINSET_1, VALUED_1, INT_1, INT_2, RELAT_1, FUNCT_1,
      PARTFUN1, FUNCT_2, FUNCT_4, FUNCOP_1, FUNCT_7, FINSEQ_1, FINSEQ_2,
      STRUCT_0, AMI_1, SCMNORM, AMI_3, RELOC, SCMFSA_2, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, AMI_5, RELOC, SCMFSA_2, SCMNORM, NAT_D,
      RELSET_1, VALUED_1;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1,
      NUMBERS, XREAL_0, INT_1, CARD_3, SCMFSA_2, SCMNORM, FINSET_1, VALUED_1,
      FUNCT_4, RELAT_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, AMI_1, SCMFSA_2, FUNCOP_1, RELAT_1;
 theorems SCMFSA_2, ZFMISC_1, RELOC, ENUMSET1, NAT_1, FUNCOP_1, RELAT_1,
      FUNCT_1, TARSKI, FUNCT_4, FUNCT_2, AMI_1, FINSET_1, SCMFSA_3, RELSET_1,
      XBOOLE_0, XBOOLE_1, CARD_3, VALUED_1, NAT_D, PARTFUN1;
 schemes CLASSES1;

begin :: Incrementing addresses

reserve L, j, k, l, m, n, p, q for Element of NAT,
  A for Data-Location,
  I for Instruction of SCM;

definition
  canceled 2;
  let i be Instruction of SCM+FSA , k be Element of NAT;
  func IncAddr (i,k) -> Instruction of SCM+FSA means
  :Def3:
  ex I being
  Instruction of SCM st I = i & it = IncAddr(I,k) if InsCode i in {6,7,8}
  otherwise it = i;
  existence
  proof
    hereby
      assume
      InsCode i in {6,7,8};
      then InsCode i = 6 or InsCode i = 7 or InsCode i = 8 by ENUMSET1:def 1;
      then reconsider I = i as Instruction of SCM by SCMFSA_2:34;
      reconsider ii = IncAddr(I,k) as Instruction of SCM+FSA by SCMFSA_2:38;
      take ii,I;
      thus I = i & ii = IncAddr(I,k);
    end;
    thus thesis;
  end;
  correctness;
end;

canceled 7;

theorem Th8:
  for k being Element of NAT holds IncAddr(halt SCM+FSA,k) = halt
  SCM+FSA
proof
  not 0 in {6,7,8};
  hence thesis by Def3,SCMFSA_2:124;
end;

theorem Th9:
  for k being Element of NAT, a,b being Int-Location holds IncAddr(
  a:=b,k) = a:=b
proof
  let k be Element of NAT, a,b be Int-Location;
  InsCode (a := b) = 1 & not 1 in {6,7,8} by ENUMSET1:def 1,SCMFSA_2:42;
  hence thesis by Def3;
end;

theorem Th10:
  for k being Element of NAT, a,b being Int-Location holds IncAddr
  (AddTo(a,b),k) = AddTo(a,b)
proof
  let k be Element of NAT, a,b be Int-Location;
  InsCode (AddTo(a,b)) = 2 & not 2 in {6,7,8} by ENUMSET1:def 1,SCMFSA_2:43;
  hence thesis by Def3;
end;

theorem Th11:
  for k being Element of NAT, a,b being Int-Location holds IncAddr
  (SubFrom(a,b),k) = SubFrom(a,b)
proof
  let k be Element of NAT, a,b be Int-Location;
  InsCode (SubFrom(a,b)) = 3 & not 3 in {6,7,8} by ENUMSET1:def 1,SCMFSA_2:44;
  hence thesis by Def3;
end;

theorem Th12:
  for k being Element of NAT, a,b being Int-Location holds IncAddr
  (MultBy(a,b),k) = MultBy(a,b)
proof
  let k be Element of NAT, a,b be Int-Location;
  InsCode (MultBy(a,b)) = 4 & not 4 in {6,7,8} by ENUMSET1:def 1,SCMFSA_2:45;
  hence thesis by Def3;
end;

theorem Th13:
  for k being Element of NAT, a,b being Int-Location holds IncAddr
  (Divide(a,b),k) = Divide(a,b)
proof
  let k be Element of NAT, a,b be Int-Location;
  InsCode (Divide(a,b)) = 5 & not 5 in {6,7,8} by ENUMSET1:def 1,SCMFSA_2:46;
  hence thesis by Def3;
end;

theorem Th14:
  for k being Element of NAT,loc being Element of NAT
  holds IncAddr(goto loc,k) = goto (loc + k)
proof
  let k be Element of NAT, loc be Element of NAT;
  consider L such that
A1: loc = L and
A2: goto loc = SCM-goto L by SCMFSA_2:def 16;
  reconsider i = SCM-goto(L+k) as Instruction of SCM+FSA by SCMFSA_2:38;
  InsCode (goto loc) = 6 by SCMFSA_2:47;
  then InsCode (goto loc) in {6,7,8} by ENUMSET1:def 1;
  then ex I being Instruction of SCM st I = goto loc &
   IncAddr( goto loc,k) = IncAddr(I,k) by Def3;
  hence IncAddr(goto loc,k) = i by A2,RELOC:10
    .= goto (loc + k) by A1,SCMFSA_2:def 16;
end;

theorem Th15:
  for k being Element of NAT,loc being Element of NAT
, a being Int-Location holds IncAddr(a=0_goto loc,k) = a=0_goto (loc + k
  )
proof
  let k be Element of NAT, loc be Element of NAT, a be
  Int-Location;
  consider A,L such that
A1: a = A & loc = L and
A2: a=0_goto loc = A=0_goto L by SCMFSA_2:def 17;
  reconsider i = A=0_goto(L+k) as Instruction of SCM+FSA by SCMFSA_2:38;
  InsCode (a=0_goto loc) = 7 by SCMFSA_2:48;
  then InsCode (a=0_goto loc) in {6,7,8} by ENUMSET1:def 1;
  then
  ex I being Instruction of SCM st I = a=0_goto loc & IncAddr(a=0_goto loc,
  k) = IncAddr(I,k) by Def3;
  hence IncAddr(a=0_goto loc,k) = i by A2,RELOC:11
    .= a=0_goto (loc + k) by A1,SCMFSA_2:def 17;
end;

theorem Th16:
  for k being Element of NAT,loc being Element of NAT
, a being Int-Location holds IncAddr(a>0_goto loc,k) = a>0_goto (loc + k
  )
proof
  let k be Element of NAT, loc be Element of NAT, a be
  Int-Location;
  consider A,L such that
A1: a = A & loc = L and
A2: a>0_goto loc = A>0_goto L by SCMFSA_2:def 18;
  reconsider i = A>0_goto(L+k) as Instruction of SCM+FSA by SCMFSA_2:38;
  InsCode (a>0_goto loc) = 8 by SCMFSA_2:49;
  then InsCode (a>0_goto loc) in {6,7,8} by ENUMSET1:def 1;
  then
  ex I being Instruction of SCM st I = a>0_goto loc & IncAddr(a>0_goto loc,
  k) = IncAddr(I,k) by Def3;
  hence IncAddr(a>0_goto loc,k) = i by A2,RELOC:12
    .= a>0_goto (loc + k) by A1,SCMFSA_2:def 18;
end;

theorem Th17:
  for k being Element of NAT, a,b being Int-Location, f being
  FinSeq-Location holds IncAddr(b:=(f,a),k) = b:=(f,a)
proof
  let k be Element of NAT, a,b be Int-Location, f be FinSeq-Location;
  InsCode (b:=(f,a)) = 9 & not 9 in {6,7,8} by ENUMSET1:def 1,SCMFSA_2:50;
  hence thesis by Def3;
end;

theorem Th18:
  for k being Element of NAT, a,b being Int-Location, f being
  FinSeq-Location holds IncAddr((f,a):=b,k) = (f,a):=b
proof
  let k be Element of NAT, a,b be Int-Location, f be FinSeq-Location;
  InsCode ((f,a):=b) = 10 & not 10 in {6,7,8} by ENUMSET1:def 1,SCMFSA_2:51;
  hence thesis by Def3;
end;

theorem Th19:
  for k being Element of NAT, a being Int-Location, f being
  FinSeq-Location holds IncAddr(a:=len f,k) = a:=len f
proof
  let k be Element of NAT, a be Int-Location, f be FinSeq-Location;
  InsCode (a:=len f) = 11 & not 11 in {6,7,8} by ENUMSET1:def 1,SCMFSA_2:52;
  hence thesis by Def3;
end;

theorem Th20:
  for k being Element of NAT, a being Int-Location, f being
  FinSeq-Location holds IncAddr(f:=<0,...,0>a,k) = f:=<0,...,0>a
proof
  let k be Element of NAT, a be Int-Location, f be FinSeq-Location;
  InsCode (f:=<0,...,0>a) = 12 & not 12 in {6,7,8} by ENUMSET1:def 1
,SCMFSA_2:53;
  hence thesis by Def3;
end;

theorem Th21:
  for i being Instruction of SCM+FSA, I st i = I holds IncAddr(i,k
  ) = IncAddr(I,k)
proof
  let i be Instruction of SCM+FSA, I;
  assume
A1: i = I;
  per cases;
  suppose
    InsCode i in {6,7,8};
    then ex I being Instruction of SCM st I = i & IncAddr(i,k) = IncAddr(I,k)
    by Def3;
    hence thesis by A1;
  end;
  suppose
A2: not InsCode i in {6,7,8};
    then
A3: InsCode I <> 8 by A1,ENUMSET1:def 1;
A4: InsCode I <> 6 & InsCode I <> 7 by A1,A2,ENUMSET1:def 1;
    thus IncAddr(i,k) = i by A2,Def3
      .= IncAddr(I,k) by A1,A4,A3,RELOC:def 3;
  end;
end;

theorem Th22:
  for I being Instruction of SCM+FSA, k being Element of NAT holds
  InsCode (IncAddr (I, k)) = InsCode I
proof
  let I be Instruction of SCM+FSA, k be Element of NAT;
A1: InsCode I <= 11+1 by SCMFSA_2:35;
A2: InsCode I <= 10+1 implies InsCode I <= 10 or InsCode I = 11 by NAT_1:8;
A3: InsCode I <= 9+1 implies InsCode I <= 8+1 or InsCode I = 10 by NAT_1:8;
  per cases by A1,A2,A3,NAT_1:8;
  suppose
    InsCode I <= 8;
    then reconsider i = I as Instruction of SCM by SCMFSA_2:34;
    IncAddr (I, k) = IncAddr (i, k) by Th21;
    hence thesis by RELOC:13;
  end;
  suppose
    InsCode I=9 or InsCode I=10 or InsCode I=11 or InsCode I=12;
    then not InsCode I in {6,7,8} by ENUMSET1:def 1;
    hence thesis by Def3;
  end;
end;

reserve i for Instruction of SCM+FSA;

theorem Th23:
  IncAddr(IncAddr(i,m),n) = IncAddr(i,m+n)
proof
  per cases by ENUMSET1:def 1;
  suppose
    InsCode i = 6;
    then consider l being Element of NAT such that
A1: i = goto l by SCMFSA_2:59;
    IncAddr(i,m) = goto(l+m) by A1,Th14;
    hence IncAddr(IncAddr(i,m),n) = goto(l+m+n) by Th14
      .= goto (l+(m+n))
      .= IncAddr(i,m+n) by A1,Th14;
  end;
  suppose
    InsCode i = 7;
    then consider
    l being Element of NAT, a being Int-Location
    such that
A2: i = a=0_goto l by SCMFSA_2:60;
    IncAddr(i,m) = a=0_goto(l+m) by A2,Th15;
    hence IncAddr(IncAddr(i,m),n) = a=0_goto(l+m+n) by Th15
      .= a=0_goto (l+(m+n))
      .= IncAddr(i,m+n) by A2,Th15;
  end;
  suppose
    InsCode i = 8;
    then consider
    l being Element of NAT, a being Int-Location
    such that
A3: i = a>0_goto l by SCMFSA_2:61;
    IncAddr(i,m) = a>0_goto(l+m) by A3,Th16;
    hence IncAddr(IncAddr(i,m),n) = a>0_goto(l+m+n) by Th16
      .= a>0_goto (l+(m+n))
      .= IncAddr(i,m+n) by A3,Th16;
  end;
  suppose
A4: not InsCode i in {6,7,8};
    then not InsCode IncAddr(i,m) in {6,7,8} by Th22;
    then IncAddr(IncAddr(i,m),n) = IncAddr(i,m) by Def3
      .= i by A4,Def3
      .= IncAddr(i,m+n) by A4,Def3;
    hence thesis;
  end;
end;

begin :: Incrementing Addresses in a finite partial state

definition
  canceled 2;
  let p be finite NAT-defined (the Instructions of SCM+FSA)-valued Function,
      k be Element of NAT;
  func IncAddr(p,k) -> preProgram of SCM+FSA means
  :Def6:
  dom it = dom p & for m st m in dom p holds it. m = IncAddr(p/.m,k);
  existence
  proof
    defpred P [set,set] means ex m st $1 = m & $2 = IncAddr(p/.m,k);
A1: for e being set st e in dom p ex u being set st P[e,u]
    proof
      let e be set;
A2:   dom p c= NAT by RELAT_1:def 18;
      assume
      e in dom p;
      then reconsider e as Element of NAT by A2;
      reconsider m = e as Element of NAT;
      take IncAddr(p/.m,k);
      thus thesis;
    end;
    consider f being Function such that
A3: dom f = dom p and
A4: for e being set st e in dom p holds P[e,f.e] from CLASSES1:sch 1(
    A1);
A5: dom p c= NAT by RELAT_1:def 18;
    then dom p c= the carrier of SCM+FSA by XBOOLE_1:1;
    then
A6: dom f c= dom the Object-Kind of SCM+FSA by A3,FUNCT_2:def 1;
    for x being set st x in dom f holds f.x in (the Object-Kind of SCM+FSA
    ).x
    proof
      let x be set;
      assume
A7:   x in dom f;
      then reconsider y = x as Element of NAT by A3,A5;
A8:   (the Object-Kind of SCM+FSA).y
        = the Instructions of SCM+FSA by AMI_1:def 14;
      ex m st x = m & f.x = IncAddr(p/.m,k) by A3,A4,A7;
      hence thesis by A8;
    end;
    then reconsider f as Element of sproduct the Object-Kind of SCM+FSA by A6,
CARD_3:def 9;
    reconsider f as FinPartState of SCM+FSA by A3,FINSET_1:29;
B:  f is (the Instructions of SCM+FSA)-valued
    proof
      let x be set;
      assume x in rng f;
       then consider y being set such that
W1:     y in dom f and
W2:     f.y = x by FUNCT_1:def 5;
       reconsider y as Element of NAT by W1,A3,A5;
       y in dom p by A3,W1;
       then P[y,x] by A4,W2;
       then consider m such that
W3:     y = m & x = IncAddr(p/.m,k);
       x = IncAddr(p/.m,k) by W3;
      hence x in the Instructions of SCM+FSA;
    end;
    f is NAT-defined
    proof
      let x be set;
      assume
      x in dom f;
      hence x in NAT by A3,A5;
    end;
    then reconsider IT = f as preProgram of SCM+FSA by B;
    take IT;
    thus dom IT = dom p by A3;
    let m;
    assume
     m in dom p;
    then ex j st  m = j & f. m = IncAddr(p/.j,k) by A4;
    hence thesis;
  end;
  uniqueness
  proof
    let IT1,IT2 be preProgram of SCM+FSA such that
A9: dom IT1 = dom p and
A10: for m st  m in dom p holds IT1. m = IncAddr(p/.m ,k) and
A11: dom IT2 = dom p and
A12: for m st  m in dom p holds IT2. m = IncAddr(p/.m ,k);
    for x being set st x in dom p holds IT1.x = IT2.x
    proof
      let x be set;
      assume
A13:  x in dom p;
      dom p c= NAT by RELAT_1:def 18;
      then reconsider l = x as Element of NAT by A13;
      reconsider m = l as Element of NAT;
      thus IT1.x = IncAddr(p/.m,k) by A10,A13
        .= IT2.x by A12,A13;
    end;
    hence thesis by A9,A11,FUNCT_1:9;
  end;
end;

registration
  let p be finite NAT-defined (the Instructions of SCM+FSA)-valued Function,
      k be Element of NAT;
  cluster IncAddr(p,k) -> (the Instructions of SCM+FSA)-valued;
  coherence by Def6,FUNCT_1:def 5,RELAT_1:def 18;
end;

theorem Th24:
  for p being finite NAT-defined (the Instructions of SCM+FSA)-valued Function,
      k being Element of NAT for l
  being Element of NAT st l in dom p holds IncAddr(p,k).l = IncAddr(p/.l,k)
             by Def6;

theorem
  for I,J being
   finite NAT-defined (the Instructions of SCM+FSA)-valued Function
    holds IncAddr(I +* J, n) = IncAddr
  (I,n) +* IncAddr(J,n)
proof
  let I,J be
   finite NAT-defined (the Instructions of SCM+FSA)-valued Function;
A1: dom IncAddr(J,n) = dom J by Def6;
A2: now
    let m such that
A3:  m in dom(I +* J);
    per cases;
    suppose
A4:    m in dom J;
A5:   (I+*J)/.m = (I +* J). m by A3,PARTFUN1:def 8
        .= J. m by A4,FUNCT_4:14
        .= J/.m by A4,PARTFUN1:def 8;
      thus (IncAddr(I,n) +* IncAddr(J,n)). m = IncAddr(J,n). m by A1,A4,
FUNCT_4:14
        .= IncAddr((I+*J)/.m,n) by A4,A5,Def6;
    end;
    suppose
A6:   not  m in dom J;
       m in dom I \/ dom J by A3,FUNCT_4:def 1;
      then
A7:    m in dom I by A6,XBOOLE_0:def 3;
A8:   (I+*J)/.m = (I +* J). m by A3,PARTFUN1:def 8
        .= I. m by A6,FUNCT_4:12
        .= I/.m by A7,PARTFUN1:def 8;
      thus (IncAddr(I,n) +* IncAddr(J,n)). m = IncAddr(I,n). m by A1,A6,
FUNCT_4:12
        .= IncAddr((I+*J)/.m,n) by A7,A8,Def6;
    end;
  end;
  dom IncAddr(I,n) = dom I by Def6;
  then dom(IncAddr(I,n) +* IncAddr(J,n)) = dom I \/ dom J by A1,FUNCT_4:def 1
    .= dom(I +* J) by FUNCT_4:def 1;
  hence thesis by A2,Def6;
end;

theorem
  for f being Function of the Instructions of SCM+FSA, the Instructions
of SCM+FSA st f = (id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> i) for
  s being finite NAT-defined (the Instructions of SCM+FSA)-valued Function
  holds IncAddr(f*s,n) = ((id the Instructions of
  SCM+FSA) +* (halt SCM+FSA .--> IncAddr(i,n)))* IncAddr(s,n)
proof
A1: dom(id the Instructions of SCM+FSA) = the Instructions of SCM+FSA by
RELAT_1:71;
  let f be Function of the Instructions of SCM+FSA, the Instructions of
  SCM+FSA such that
A2: f = (id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> i);
  let s be finite NAT-defined (the Instructions of SCM+FSA)-valued Function;
  rng(halt SCM+FSA .--> IncAddr(i,n)) = {IncAddr(i,n)} by FUNCOP_1:14;
  then
A3: rng((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> IncAddr(i,n))
  ) c= rng(id the Instructions of SCM+FSA) \/ {IncAddr(i,n)} by FUNCT_4:18;
  rng(id the Instructions of SCM+FSA) = the Instructions of SCM+FSA by
RELAT_1:71;
  then
A4: rng(id the Instructions of SCM+FSA) \/ {IncAddr(i,n)} = the Instructions
  of SCM+FSA by ZFMISC_1:46;
A5: dom(halt SCM+FSA .--> IncAddr(i,n)) = {halt SCM+FSA} by FUNCOP_1:19;
  then
  dom((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> IncAddr(i,n))
  ) = dom(id the Instructions of SCM+FSA) \/ {halt SCM+FSA} by FUNCT_4:def 1
    .= the Instructions of SCM+FSA by A1,ZFMISC_1:46;
  then reconsider g = (id the Instructions of SCM+FSA) +* (halt SCM+FSA .-->
  IncAddr(i,n)) as Function of the Instructions of SCM+FSA,the Instructions of
  SCM+FSA by A3,A4,FUNCT_2:def 1,RELSET_1:11;
A6: dom IncAddr(s,n) = dom s by Def6
    .= dom(f*s) by FUNCT_2:200;
A7: dom(halt SCM+FSA .--> i) = {halt SCM+FSA} by FUNCOP_1:19;
A8: now
    let m;
    assume
A9:  m in dom(f*s);
    then
A10:  m in dom s by FUNCT_2:200;
    per cases;
    suppose
A11:  s. m = halt SCM+FSA;
A12:  IncAddr(s,n). m = IncAddr(s/.m,n) by A10,Th24
        .= IncAddr(halt SCM+FSA,n) by A10,A11,PARTFUN1:def 8
        .= halt SCM+FSA by Th8;
A13:  halt SCM+FSA in {halt SCM+FSA} by TARSKI:def 1;
A14:  (f*s)/.m = (f*s). m by A9,PARTFUN1:def 8
        .= f.halt SCM+FSA by A10,A11,FUNCT_1:23
        .= (halt SCM+FSA .--> i).halt SCM+FSA by A2,A7,A13,FUNCT_4:14
        .= i by FUNCOP_1:87;
      thus (g*IncAddr(s,n)). m = g.(IncAddr(s,n). m) by A6,A9,FUNCT_1:23
        .= (halt SCM+FSA .--> IncAddr(i,n)).(IncAddr(s,n). m) by A5,A12,A13,
FUNCT_4:14
        .= IncAddr((f*s)/.m,n) by A12,A14,FUNCOP_1:87;
    end;
    suppose
A15:  s. m <> halt SCM+FSA;
A16:  InsCode IncAddr(s/.m,n) = InsCode s/.m by Th22;
A17:  s/.m = s. m by A10,PARTFUN1:def 8;
      then
A18:  not s/.m in {halt SCM+FSA} by A15,TARSKI:def 1;
      InsCode s/.m <> 0 by A15,A17,SCMFSA_2:122;
      then
A19:  not IncAddr(s/.m,n) in {halt SCM+FSA} by A16,SCMFSA_2:124,TARSKI:def 1
;
A20:  (f*s)/.m = (f*s). m by A9,PARTFUN1:def 8
        .= f.(s. m) by A10,FUNCT_1:23
        .= (id the Instructions of SCM+FSA).(s/.m) by A2,A7,A17,A18,FUNCT_4:12
        .= s/.m by FUNCT_1:35;
      thus (g*IncAddr(s,n)). m = g.(IncAddr(s,n). m) by A6,A9,FUNCT_1:23
        .= g.IncAddr(s/.m,n) by A10,Def6
        .= (id the Instructions of SCM+FSA).IncAddr(s/.m,n) by A5,A19,
FUNCT_4:12
        .= IncAddr((f*s)/.m,n) by A20,FUNCT_1:35;
    end;
  end;
  dom(g*IncAddr(s,n)) = dom IncAddr(s,n) by FUNCT_2:200;
  hence thesis by A6,A8,Def6;
end;

theorem
  for I being
  finite NAT-defined (the Instructions of SCM+FSA)-valued Function
   holds IncAddr(IncAddr(I,m),n) = IncAddr(I,m+n)
proof
  let I be
  finite NAT-defined (the Instructions of SCM+FSA)-valued Function;
A1: dom IncAddr(I,m) = dom I by Def6;
A2: now
    let l;
    assume
A3:  l in dom I;
    then IncAddr(I,m)/.l = IncAddr(I,m). l by A1,PARTFUN1:def 8
      .= IncAddr(I/.l,m) by A3,Th24;
    hence IncAddr(IncAddr(I,m),n). l = IncAddr(IncAddr(I/.l,m),n) by A1,A3,Th24
      .= IncAddr(I/.l,m+n) by Th23;
  end;
  dom IncAddr(IncAddr(I,m),n) = dom IncAddr(I,m) by Def6;
  hence thesis by A1,A2,Def6;
end;

theorem
  for p being (the Instructions of SCM+FSA)-valued Function
  for s being State of SCM+FSA
   holds Exec(IncAddr(CurInstr(p, s),k),s +*
  Start-At(IC s+k,SCM+FSA)) = Following(p,s) +*
   Start-At(IC Following(p,s)+k,SCM+FSA)
proof
  let p be (the Instructions of SCM+FSA)-valued Function;
  let s be State of SCM+FSA;
  set INS = CurInstr(p, s);
  reconsider m = IC s as Element of NAT;
A1: succ IC (s +* Start-At(IC s+k,SCM+FSA)) = succ ((m + k)) by FUNCT_4:121
    .= ((m + k) + 1) by NAT_1:39
    .= (m + 1 + k)
    .= (m + 1) + k
    .= ((succ IC s) qua Element of NAT) + k by NAT_1:39
    .= IC (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)) by FUNCT_4:121;
A2: InsCode INS <= 9+1 implies InsCode INS <= 8+1 or InsCode INS = 10 by
NAT_1:8;
A3: InsCode INS <= 10+1 implies InsCode INS <= 10 or InsCode INS = 11 by
NAT_1:8;
A4: InsCode INS <= 11+1 by SCMFSA_2:35;
A5: now
    let d be Element of NAT;
    thus Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d
     = (s +* Start-At(IC s+k,SCM+FSA)).d
    by AMI_1:def 13
      .= s.d by AMI_1:112
      .= Exec(INS, s).d by AMI_1:def 13
      .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d by AMI_1:112;
  end;
  per cases by A4,A3,A2,NAT_1:8,33;
  suppose
A6: InsCode INS = 0;
    then
A7: Following(p,s) = Exec(halt SCM+FSA, s) by SCMFSA_2:122
      .= s by AMI_1:def 8;
    INS = halt SCM+FSA by A6,SCMFSA_2:122;
    hence Exec(IncAddr(CurInstr(p, s),k),s +*
     Start-At(IC s+k,SCM+FSA)) = Exec(halt
    SCM+FSA, s +* Start-At(IC s+k,SCM+FSA)) by Th8
      .= Following(p,s) +*
      Start-At(IC Following(p,s)+k,SCM+FSA)
      by A7,AMI_1:def 8;
  end;
  suppose
    InsCode INS = 1;
    then consider da,db being Int-Location such that
A8: INS = da := db by SCMFSA_2:54;
A9: IncAddr(INS,k) = INS by A8,Th9;
A10: now
      let d be FinSeq-Location;
      thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d
       = (s +* Start-At(IC s+k,SCM+FSA)).d by A8,A9,SCMFSA_2:89
        .= s.d by SCMFSA_3:12
        .= Exec(INS, s).d by A8,SCMFSA_2:89
        .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d
         by SCMFSA_3:12;
    end;
A11: now
      let d be Int-Location;
      per cases;
      suppose
A12:    da = d;
        hence
        Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d
         = (s +* Start-At(IC s+k,SCM+FSA)
        ).db by A8,SCMFSA_2:89
          .= s.db by SCMFSA_3:11
          .= Exec(INS, s).d by A8,A12,SCMFSA_2:89
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d by SCMFSA_3:11;
      end;
      suppose
A13:    da <> d;
        hence
        Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d
         = (s +* Start-At(IC s+k,SCM+FSA)
        ).d by A8,SCMFSA_2:89
          .= s.d by SCMFSA_3:11
          .= Exec(INS, s).d by A8,A13,SCMFSA_2:89
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d by SCMFSA_3:11;
      end;
    end;
    IC Exec(INS, s) = succ IC s & IC Exec(INS, s +* Start-At(IC s+k,SCM+FSA))
    = IC ( Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA))
     by A1,A8,SCMFSA_2:89;
    hence thesis by A5,A9,A10,A11,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 2;
    then consider da,db being Int-Location such that
A14: INS = AddTo(da, db) by SCMFSA_2:55;
A15: IncAddr(INS, k) = INS by A14,Th10;
A16: now
      let d be FinSeq-Location;
      thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d
       = (s +* Start-At(IC s+k,SCM+FSA)).d by A14,A15,SCMFSA_2:90
        .= s.d by SCMFSA_3:12
        .= Exec(INS, s).d by A14,SCMFSA_2:90
        .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d
         by SCMFSA_3:12;
    end;
A17: now
      let d be Int-Location;
      per cases;
      suppose
A18:    da = d;
        hence
        Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d
         = (s +* Start-At(IC s+k,SCM+FSA)
        ).da + (s +* Start-At(IC s+k,SCM+FSA)).db by A14,SCMFSA_2:90
          .= s.da + (s +* Start-At(IC s+k,SCM+FSA)).db by SCMFSA_3:11
          .= s.da + s.db by SCMFSA_3:11
          .= Exec(INS, s).d by A14,A18,SCMFSA_2:90
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d by SCMFSA_3:11;
      end;
      suppose
A19:    da <> d;
        hence
        Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d
         = (s +* Start-At(IC s+k,SCM+FSA)
        ).d by A14,SCMFSA_2:90
          .= s.d by SCMFSA_3:11
          .= Exec(INS, s).d by A14,A19,SCMFSA_2:90
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d by SCMFSA_3:11;
      end;
    end;
    IC Exec(INS, s) = succ IC s & IC Exec(INS, s +* Start-At(IC s+k,SCM+FSA))
    = IC ( Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA))
     by A1,A14,SCMFSA_2:90;
    hence thesis by A5,A15,A16,A17,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 3;
    then consider da,db being Int-Location such that
A20: INS = SubFrom(da, db) by SCMFSA_2:56;
A21: IncAddr(INS, k) = INS by A20,Th11;
A22: now
      let d be FinSeq-Location;
      thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d
       = (s +* Start-At
      (IC s + k,SCM+FSA)).d by A20,A21,SCMFSA_2:91
        .= s.d by SCMFSA_3:12
        .= Exec(INS, s).d by A20,SCMFSA_2:91
        .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d
         by SCMFSA_3:12;
    end;
A23: now
      let d be Int-Location;
      per cases;
      suppose
A24:    da = d;
        hence
        Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d
         = (s +* Start-At(IC s+k,SCM+FSA)
        ).da - (s +* Start-At(IC s+k,SCM+FSA)).db by A20,SCMFSA_2:91
          .= s.da - (s +* Start-At(IC s+k,SCM+FSA)).db by SCMFSA_3:11
          .= s.da - s.db by SCMFSA_3:11
          .= Exec(INS, s).d by A20,A24,SCMFSA_2:91
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d by SCMFSA_3:11;
      end;
      suppose
A25:    da <> d;
        hence
        Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d =
         (s +* Start-At(IC s+k,SCM+FSA)
        ).d by A20,SCMFSA_2:91
          .= s.d by SCMFSA_3:11
          .= Exec(INS, s).d by A20,A25,SCMFSA_2:91
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d by SCMFSA_3:11;
      end;
    end;
    IC Exec(INS, s) = succ IC s & IC Exec(INS, s +* Start-At(IC s+k,SCM+FSA))
    = IC ( Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA))
     by A1,A20,SCMFSA_2:91;
    hence thesis by A5,A21,A22,A23,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 4;
    then consider da,db being Int-Location such that
A26: INS = MultBy(da, db) by SCMFSA_2:57;
A27: IncAddr(INS, k) = INS by A26,Th12;
A28: now
      let d be FinSeq-Location;
      thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d =
       (s +* Start-At
      (IC s+k,SCM+FSA)).d by A26,A27,SCMFSA_2:92
        .= s.d by SCMFSA_3:12
        .= Exec(INS, s).d by A26,SCMFSA_2:92
        .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d
         by SCMFSA_3:12;
    end;
A29: now
      let d be Int-Location;
      per cases;
      suppose
A30:    da = d;
        hence
        Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d =
         (s +* Start-At(IC s+k,SCM+FSA)
        ).da * (s +* Start-At(IC s+k,SCM+FSA)).db by A26,SCMFSA_2:92
          .= s.da * (s +* Start-At(IC s+k,SCM+FSA)).db by SCMFSA_3:11
          .= s.da * s.db by SCMFSA_3:11
          .= Exec(INS, s).d by A26,A30,SCMFSA_2:92
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d by SCMFSA_3:11;
      end;
      suppose
A31:    da <> d;
        hence
        Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d =
         (s +* Start-At(IC s+k,SCM+FSA)
        ).d by A26,SCMFSA_2:92
          .= s.d by SCMFSA_3:11
          .= Exec(INS, s).d by A26,A31,SCMFSA_2:92
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d by SCMFSA_3:11;
      end;
    end;
    IC Exec(INS, s) = succ IC s & IC Exec(INS, s +* Start-At(IC s+k,SCM+FSA))
    = IC ( Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA))
     by A1,A26,SCMFSA_2:92;
    hence thesis by A5,A27,A28,A29,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 5;
    then consider da,db being Int-Location such that
A32: INS = Divide(da, db) by SCMFSA_2:58;
A33: IncAddr(INS,k) = INS by A32,Th13;
A34: now
      let d be FinSeq-Location;
      thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d =
       (s +* Start-At
      (IC s+k,SCM+FSA)).d by A32,A33,SCMFSA_2:93
        .= s.d by SCMFSA_3:12
        .= Exec(INS, s).d by A32,SCMFSA_2:93
        .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d
         by SCMFSA_3:12;
    end;
A35: now
      let d be Int-Location;
      per cases;
      suppose
A36:    da <> db;
        hereby
          per cases;
          suppose
A37:        da = d;
            hence Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d =
             (s +* Start-At (IC s
            + k,SCM+FSA)).da div (s +* Start-At(IC s+k,SCM+FSA)).db
             by A32,A36,SCMFSA_2:93
              .= s.da div (s +* Start-At(IC s+k,SCM+FSA)).db by SCMFSA_3:11
              .= s.da div s.db by SCMFSA_3:11
              .= Exec(INS, s).d by A32,A36,A37,SCMFSA_2:93
              .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d
               by SCMFSA_3:11;
          end;
          suppose
A38:        db = d;
            hence Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d =
             (s +* Start-At (IC s
            + k,SCM+FSA)).da mod (s +* Start-At(IC s+k,SCM+FSA)).db
             by A32,SCMFSA_2:93
              .= s.da mod (s +* Start-At(IC s+k,SCM+FSA)).db by SCMFSA_3:11
              .= s.da mod s.db by SCMFSA_3:11
              .= Exec(INS, s).d by A32,A38,SCMFSA_2:93
              .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d
               by SCMFSA_3:11;
          end;
          suppose
A39:        da <> d & db <> d;
            hence Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d =
             (s +* Start-At (IC s
            + k,SCM+FSA)).d by A32,SCMFSA_2:93
              .= s.d by SCMFSA_3:11
              .= Exec(INS, s).d by A32,A39,SCMFSA_2:93
              .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d
               by SCMFSA_3:11;
          end;
        end;
      end;
      suppose
A40:    da = db;
        hereby
          per cases;
          suppose
A41:        da = d;
            hence Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d =
             (s +* Start-At (IC s
            + k,SCM+FSA)).da mod (s +* Start-At(IC s+k,SCM+FSA)).da
             by A32,A40,SCMFSA_2:94
              .= s.da mod (s +* Start-At(IC s+k,SCM+FSA)).da by SCMFSA_3:11
              .= s.da mod s.da by SCMFSA_3:11
              .= Exec(INS, s).d by A32,A40,A41,SCMFSA_2:94
              .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d
               by SCMFSA_3:11;
          end;
          suppose
A42:        da <> d;
            hence Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d =
             (s +* Start-At (IC s
            + k,SCM+FSA)).d by A32,A40,SCMFSA_2:94
              .= s.d by SCMFSA_3:11
              .= Exec(INS, s).d by A32,A40,A42,SCMFSA_2:94
              .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d
               by SCMFSA_3:11;
          end;
        end;
      end;
    end;
    IC Exec(INS, s) = succ IC s & IC Exec(INS, s +* Start-At(IC s+k,SCM+FSA))
    = IC ( Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA))
     by A1,A32,SCMFSA_2:93;
    hence thesis by A5,A33,A34,A35,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 6;
    then consider loc being Element of NAT such that
A43: INS = goto loc by SCMFSA_2:59;
A44: IncAddr(INS, k) = goto (loc + k) by A43,Th14;
A45: now
      let d be Int-Location;
      thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d =
       (s +* Start-At
      (IC s + k,SCM+FSA)).d by A44,SCMFSA_2:95
        .= s.d by SCMFSA_3:11
        .= Exec(INS, s).d by A43,SCMFSA_2:95
        .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d
         by SCMFSA_3:11;
    end;
A46: IC Exec(INS, s) = loc by A43,SCMFSA_2:95;
A47: now
      let d be Element of NAT;
      thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d =
       (s +* Start-At
      (IC s +k,SCM+FSA)).d by AMI_1:def 13
        .= s.d by AMI_1:112
        .= Exec(INS, s).d by AMI_1:def 13
        .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d by AMI_1:112;
    end;
A48: now
      let d be FinSeq-Location;
      thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d =
       (s +* Start-At
      (IC s +k,SCM+FSA)).d by A44,SCMFSA_2:95
        .= s.d by SCMFSA_3:12
        .= Exec(INS, s).d by A43,SCMFSA_2:95
        .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d
         by SCMFSA_3:12;
    end;
    IC Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)) = loc + k by A44,
SCMFSA_2:95
      .= IC (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)) by A46,
FUNCT_4:121;
    hence thesis by A45,A48,A47,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 7;
    then consider
    loc being Element of NAT, da being Int-Location
    such that
A49: INS = da=0_goto loc by SCMFSA_2:60;
A50: IncAddr(INS, k) = da=0_goto (loc + k) by A49,Th15;
    now
      per cases;
      suppose
A51:    s.da=0;
A52:    now
          let d be Int-Location;
          thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d = (s +*
          Start-At(IC s+k,SCM+FSA)).d by A50,SCMFSA_2:96
            .= s.d by SCMFSA_3:11
            .= Exec(INS, s).d by A49,SCMFSA_2:96
            .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d by
SCMFSA_3:11;
        end;
A53:    now
          let d be FinSeq-Location;
          thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d = (s +*
          Start-At(IC s+k,SCM+FSA)).d by A50,SCMFSA_2:96
            .= s.d by SCMFSA_3:12
            .= Exec(INS, s).d by A49,SCMFSA_2:96
            .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d by
SCMFSA_3:12;
        end;
A54:    IC Exec(INS, s) = loc by A49,A51,SCMFSA_2:96;
A55:    now
          let d be Element of NAT;
          thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d = (s +*
          Start-At(IC s+k,SCM+FSA)).d by AMI_1:def 13
            .= s.d by AMI_1:112
            .= Exec(INS, s).d by AMI_1:def 13
            .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d by
AMI_1:112;
        end;
        (s +* Start-At(IC s+k,SCM+FSA)).da=0 by A51,SCMFSA_3:11;
        then IC Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA))
         = loc + k by A50,SCMFSA_2:96
          .= IC (Exec(INS,s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA))
           by A54,FUNCT_4:121;
        hence
        Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)) = Exec(INS, s) +*
        Start-At(IC Exec(INS,s)+k,SCM+FSA) by A53,A52,A55,SCMFSA_2:86;
      end;
      suppose
A56:    s.da<>0;
A57:    now
          let d be Element of NAT;
          thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d = (s +*
          Start-At(IC s+k,SCM+FSA)).d by AMI_1:def 13
            .= s.d by AMI_1:112
            .= Exec(INS, s).d by AMI_1:def 13
            .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d by
AMI_1:112;
        end;
A58:    now
          let d be Int-Location;
          thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d = (s +*
          Start-At(IC s+k,SCM+FSA)).d by A50,SCMFSA_2:96
            .= s.d by SCMFSA_3:11
            .= Exec(INS, s).d by A49,SCMFSA_2:96
            .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d by
SCMFSA_3:11;
        end;
A59:    now
          let d be FinSeq-Location;
          thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d = (s +*
          Start-At(IC s+k,SCM+FSA)).d by A50,SCMFSA_2:96
            .= s.d by SCMFSA_3:12
            .= Exec(INS, s).d by A49,SCMFSA_2:96
            .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d by
SCMFSA_3:12;
        end;
        (s +* Start-At(IC s+k,SCM+FSA)).da<>0 & IC Exec(INS, s) = succ IC s by
A49,A56,SCMFSA_2:96,SCMFSA_3:11;
        then
        IC Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)) = IC (Exec(INS
        , s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)) by A1,A50,SCMFSA_2:96;
        hence Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA))
         = (Exec(INS, s)
        +* Start-At(IC Exec(INS,s)+k,SCM+FSA)) by A59,A58,A57,SCMFSA_2:86;
      end;
    end;
    hence thesis;
  end;
  suppose
    InsCode INS = 8;
    then consider
    loc being Element of NAT, da being Int-Location
    such that
A60: INS = da>0_goto loc by SCMFSA_2:61;
    now
      per cases;
      suppose
A61:    s.da > 0;
A62:    now
          let d be Int-Location;
          thus Exec(da>0_goto (loc + k), s +* Start-At(IC s+k,SCM+FSA)).d
           = (s +*
          Start-At(IC s+k,SCM+FSA)).d by SCMFSA_2:97
            .= s.d by SCMFSA_3:11
            .= Exec(INS, s).d by A60,SCMFSA_2:97
            .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d by
SCMFSA_3:11;
        end;
A63:    now
          let d be FinSeq-Location;
          thus Exec(da>0_goto (loc + k), s +* Start-At(IC s+k,SCM+FSA)).d
           = (s +*
          Start-At(IC s+k,SCM+FSA)).d by SCMFSA_2:97
            .= s.d by SCMFSA_3:12
            .= Exec(INS, s).d by A60,SCMFSA_2:97
            .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d by
SCMFSA_3:12;
        end;
A64:    IC Exec(INS, s) = loc by A60,A61,SCMFSA_2:97;
A65:    now
          let d be Element of NAT;
          thus Exec(da>0_goto (loc + k), s +* Start-At(IC s+k,SCM+FSA)).d
           = (s +*
          Start-At(IC s+k,SCM+FSA)).d by AMI_1:def 13
            .= s.d by AMI_1:112
            .= Exec(INS, s).d by AMI_1:def 13
            .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d by
AMI_1:112;
        end;
        (s +* Start-At(IC s+k,SCM+FSA)).da > 0 by A61,SCMFSA_3:11;
        then IC Exec(da>0_goto (loc + k), s +* Start-At(IC s+k,SCM+FSA))
         = loc + k
        by SCMFSA_2:97
          .= IC (Exec(INS,s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA))
           by A64,FUNCT_4:121;
        hence
        Exec(da>0_goto (loc + k), s +* Start-At(IC s+k,SCM+FSA)) = Exec(INS,s)
        +* Start-At(IC Exec(INS,s)+k,SCM+FSA) by A63,A62,A65,SCMFSA_2:86;
      end;
      suppose
A66:    s.da <= 0;
A67:    now
          let d be Element of NAT;
          thus Exec(da>0_goto (loc + k), s +* Start-At(IC s+k,SCM+FSA)).d
           = (s +*
          Start-At(IC s+k,SCM+FSA)).d by AMI_1:def 13
            .= s.d by AMI_1:112
            .= Exec(INS, s).d by AMI_1:def 13
            .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d by
AMI_1:112;
        end;
A68:    now
          let d be Int-Location;
          thus Exec(da>0_goto (loc + k), s +* Start-At(IC s+k,SCM+FSA)).d
           = (s +*
          Start-At(IC s+k,SCM+FSA)).d by SCMFSA_2:97
            .= s.d by SCMFSA_3:11
            .= Exec(INS, s).d by A60,SCMFSA_2:97
            .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d by
SCMFSA_3:11;
        end;
A69:    now
          let d be FinSeq-Location;
          thus Exec(da>0_goto (loc + k), s +* Start-At(IC s+k,SCM+FSA)).d
           = (s +*
          Start-At(IC s+k,SCM+FSA)).d by SCMFSA_2:97
            .= s.d by SCMFSA_3:12
            .= Exec(INS, s).d by A60,SCMFSA_2:97
            .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d by
SCMFSA_3:12;
        end;
        (s +* Start-At(IC s+k,SCM+FSA)).da <= 0 & IC Exec(INS, s) = succ IC s
        by A60,A66,SCMFSA_2:97,SCMFSA_3:11;
        then
        IC Exec(da>0_goto (loc + k), s +* Start-At(IC s+k,SCM+FSA)) = IC (Exec
        (INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)) by A1,SCMFSA_2:97;
        hence
        Exec(da>0_goto (loc + k), s +* Start-At(IC s+k,SCM+FSA)) = Exec(INS, s
        ) +* Start-At(IC Exec(INS,s)+k,SCM+FSA) by A69,A68,A67,SCMFSA_2:86;
      end;
    end;
    hence thesis by A60,Th16;
  end;
  suppose
    InsCode INS = 9;
    then consider db,da being Int-Location, f being FinSeq-Location such that
A70: INS = da :=(f, db) by SCMFSA_2:62;
A71: IncAddr(INS,k) = INS by A70,Th17;
A72: now
      let d be FinSeq-Location;
      thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d
       = (s +* Start-At
      (IC s +k,SCM+FSA)).d by A70,A71,SCMFSA_2:98
        .= s.d by SCMFSA_3:12
        .= Exec(INS, s).d by A70,SCMFSA_2:98
        .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d
         by SCMFSA_3:12;
    end;
A73: now
      let d be Int-Location;
      consider m being Element of NAT such that
A74:  m = abs(s.db) and
A75:  Exec(INS, s).da = (s.f)/.m by A70,SCMFSA_2:98;
A76:  ex m9 being Element of NAT st m9 = abs((s +* Start-At(IC s+k,SCM+FSA)).
db) & Exec(INS,s +* Start-At(IC s+k,SCM+FSA)).da =
 ((s +* Start-At(IC s+k,SCM+FSA)).f)/.
      m9 by A70,SCMFSA_2:98;
      per cases;
      suppose
A77:    da = d;
        (s +* Start-At(IC s+k,SCM+FSA)).db = s.db by SCMFSA_3:11;
        hence Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d = (s.f)/.m by A74,A76
,A77,SCMFSA_3:12
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d
           by A75,A77,SCMFSA_3:11;
      end;
      suppose
A78:    da <> d;
        hence
        Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d =
         (s +* Start-At(IC s+k,SCM+FSA)
        ).d by A70,SCMFSA_2:98
          .= s.d by SCMFSA_3:11
          .= Exec(INS, s).d by A70,A78,SCMFSA_2:98
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d by SCMFSA_3:11;
      end;
    end;
    IC Exec(INS, s) = succ IC s & IC Exec(INS, s +* Start-At(IC s+k,SCM+FSA))
    = IC ( Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA))
     by A1,A70,SCMFSA_2:98;
    hence thesis by A5,A71,A72,A73,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 10;
    then consider db,da being Int-Location, f being FinSeq-Location such that
A79: INS = (f, db):=da by SCMFSA_2:63;
A80: IncAddr(INS,k) = INS by A79,Th18;
A81: now
      let d be Int-Location;
      thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d =
       (s +* Start-At
      (IC s +k,SCM+FSA)).d by A79,A80,SCMFSA_2:99
        .= s.d by SCMFSA_3:11
        .= Exec(INS, s).d by A79,SCMFSA_2:99
        .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d
         by SCMFSA_3:11;
    end;
A82: now
      let g be FinSeq-Location;
      consider m being Element of NAT such that
A83:  m = abs(s.db) and
A84:  Exec(INS, s).f = s.f+*(m,s.da) by A79,SCMFSA_2:99;
A85:  ex m9 being Element of NAT st m9 = abs((s +* Start-At(IC s+k,SCM+FSA)).
db) & Exec(INS,s +* Start-At(IC s+k,SCM+FSA)).f =
 (s +* Start-At(IC s+k,SCM+FSA) ).f +*(
      m9,(s +* Start-At(IC s+k,SCM+FSA)).da) by A79,SCMFSA_2:99;
      per cases;
      suppose
A86:    f = g;
        (s +* Start-At(IC s+k,SCM+FSA)).f = s.f &
         (s +* Start-At(IC s+k,SCM+FSA)).
        db = s.db by SCMFSA_3:11,12;
        hence Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).g = s.f+*(m,s.da)
         by A83,A85,A86,SCMFSA_3:11
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).g
           by A84,A86,SCMFSA_3:12;
      end;
      suppose
A87:    f <> g;
        hence
        Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).g =
         (s +* Start-At(IC s+k,SCM+FSA)
        ).g by A79,SCMFSA_2:99
          .= s.g by SCMFSA_3:12
          .= Exec(INS, s).g by A79,A87,SCMFSA_2:99
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).g by SCMFSA_3:12;
      end;
    end;
    IC Exec(INS, s) = succ IC s & IC Exec(INS, s +* Start-At(IC s+k,SCM+FSA))
    = IC ( Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA))
     by A1,A79,SCMFSA_2:99;
    hence thesis by A5,A80,A81,A82,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 11;
    then consider da being Int-Location, f being FinSeq-Location such that
A88: INS = da :=len f by SCMFSA_2:64;
A89: IncAddr(INS,k) = INS by A88,Th19;
A90: now
      let d be FinSeq-Location;
      thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d =
       (s +* Start-At
      (IC s +k,SCM+FSA)).d by A88,A89,SCMFSA_2:100
        .= s.d by SCMFSA_3:12
        .= Exec(INS, s).d by A88,SCMFSA_2:100
        .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d
         by SCMFSA_3:12;
    end;
A91: now
      let d be Int-Location;
      per cases;
      suppose
A92:    da = d;
        hence Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d =
         len((s +* Start-At (IC s
        + k,SCM+FSA)).f) by A88,SCMFSA_2:100
          .= len(s.f) by SCMFSA_3:12
          .= Exec(INS, s).d by A88,A92,SCMFSA_2:100
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d by SCMFSA_3:11;
      end;
      suppose
A93:    da <> d;
        hence
        Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).d =
         (s +* Start-At(IC s+k,SCM+FSA)
        ).d by A88,SCMFSA_2:100
          .= s.d by SCMFSA_3:11
          .= Exec(INS, s).d by A88,A93,SCMFSA_2:100
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).d by SCMFSA_3:11;
      end;
    end;
    IC Exec(INS, s) = succ IC s & IC Exec(INS, s +* Start-At(IC s+k,SCM+FSA))
    = IC ( Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA))
     by A1,A88,SCMFSA_2:100;
    hence thesis by A5,A89,A90,A91,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 12;
    then consider da being Int-Location, f being FinSeq-Location such that
A94: INS = f:=<0,...,0>da by SCMFSA_2:65;
A95: IncAddr(INS,k) = INS by A94,Th20;
A96: now
      let d be Int-Location;
      thus Exec(IncAddr(INS, k), s +* Start-At(IC s+k,SCM+FSA)).d =
       (s +* Start-At
      (IC s +k,SCM+FSA)).d by A94,A95,SCMFSA_2:101
        .= s.d by SCMFSA_3:11
        .= Exec(INS, s).d by A94,SCMFSA_2:101
        .= (Exec(INS, s) +* Start-At(IC Exec(INS,s)+k,SCM+FSA)).d
         by SCMFSA_3:11;
    end;
A97: now
      let g be FinSeq-Location;
A98:  (ex m being Element of NAT st m = abs(s.da) & Exec(INS, s ).f = m
|-> 0 )& ex m9 being Element of NAT st m9 =
 abs((s +* Start-At(IC s+k,SCM+FSA)).da)
      & Exec (INS,s +* Start-At(IC s+k,SCM+FSA)).f = m9 |-> 0
       by A94,SCMFSA_2:101;
      per cases;
      suppose
A99:    f = g;
        (s +* Start-At(IC s+k,SCM+FSA)).da = s.da by SCMFSA_3:11;
        hence
        Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).g = (Exec(INS, s) +* Start-At
        (((succ IC s)) + k,SCM+FSA)).g by A98,A99,SCMFSA_3:12;
      end;
      suppose
A100:   f <> g;
        hence
        Exec(INS, s +* Start-At(IC s+k,SCM+FSA)).g =
         (s +* Start-At(IC s+k,SCM+FSA)
        ).g by A94,SCMFSA_2:101
          .= s.g by SCMFSA_3:12
          .= Exec(INS, s).g by A94,A100,SCMFSA_2:101
          .= (Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA)).g by SCMFSA_3:12;
      end;
    end;
    IC Exec(INS, s) = succ IC s & IC Exec(INS, s +* Start-At(IC s+k,SCM+FSA))
    = IC ( Exec(INS, s) +* Start-At(succ IC s+k,SCM+FSA))
     by A1,A94,SCMFSA_2:101;
    hence thesis by A5,A95,A96,A97,SCMFSA_2:86;
  end;
end;

theorem
  for INS being Instruction of SCM+FSA, s being State of SCM+FSA, p
being FinPartState of SCM+FSA, i, j, k being Element of NAT st IC s = j+k holds
Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = Exec(IncAddr(INS, k), s)
 +* Start-At (IC
  Exec(IncAddr(INS,k), s) -'k,SCM+FSA)
proof
  let INS be Instruction of SCM+FSA, s be State of SCM+FSA, p be FinPartState
  of SCM+FSA, i, j, k be Element of NAT;
A1: now
    let d be Element of NAT;
    thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
     (s +* Start-At(IC s -'k,SCM+FSA)).
    d by AMI_1:def 13
      .= s.d by AMI_1:112
      .= Exec(IncAddr(INS, k), s).d by AMI_1:def 13
      .= (Exec(IncAddr(INS, k), s) +* Start-At (IC Exec(IncAddr(INS,k), s)
    -'k,SCM+FSA)).d by AMI_1:112;
  end;
A2: InsCode INS <= 9+1 implies InsCode INS <= 8+1 or InsCode INS = 10 by
NAT_1:8;
A3: InsCode INS <= 10+1 implies InsCode INS <= 10 or InsCode INS = 11 by
NAT_1:8;
A4: InsCode INS <= 11+1 by SCMFSA_2:35;
  assume
A5: IC s = j+k;
  then
A6: succ (IC s -'k) = succ ( j + k -'k)
    .= succ ( j) by NAT_D:34
    .= (j+1) by NAT_1:39
    .= (j+1) + k -' k by NAT_D:34
    .= (j+1+k) -' k
    .= (j+k+1) -' k
    .= ((succ IC s)) -' k by A5,NAT_1:39;
  per cases by A4,A3,A2,NAT_1:8,33;
  suppose
A7: InsCode INS = 0;
A8: IncAddr (halt SCM+FSA, k) = halt SCM+FSA by Th8;
A9: INS = halt SCM+FSA by A7,SCMFSA_2:122;
    hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) =
     s +* Start-At(IC s -'k,SCM+FSA) by AMI_1:def 8
      .= s +* Start-At (IC Exec(IncAddr(INS,k), s) -'k,SCM+FSA)
       by A9,A8,AMI_1:def 8
      .= Exec(IncAddr(INS, k), s) +* Start-At (IC Exec(IncAddr(INS,k), s) -'
    k,SCM+FSA) by A9,A8,AMI_1:def 8;
  end;
  suppose
    InsCode INS = 1;
    then consider da,db being Int-Location such that
A10: INS = da := db by SCMFSA_2:54;
A11: IncAddr(INS, k) = da := db by A10,Th9;
A12: now
      let d be FinSeq-Location;
      thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
       (s +* Start-At(IC s -'k,SCM+FSA)
      ).d by A10,SCMFSA_2:89
        .= s.d by SCMFSA_3:12
        .= Exec(IncAddr(INS, k), s).d by A11,SCMFSA_2:89
        .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
      -'k,SCM+FSA)).d by SCMFSA_3:12;
    end;
A13: now
      let d be Int-Location;
      per cases;
      suppose
A14:    da = d;
        hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
         (s +* Start-At (IC s -'
        k,SCM+FSA)).db by A10,SCMFSA_2:89
          .= s.db by SCMFSA_3:11
          .= Exec(IncAddr(INS,k), s).d by A11,A14,SCMFSA_2:89
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by SCMFSA_3:11;
      end;
      suppose
A15:    da <> d;
        hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d
         = (s +* Start-At (IC s -'
        k,SCM+FSA)).d by A10,SCMFSA_2:89
          .= s.d by SCMFSA_3:11
          .= Exec(IncAddr(INS, k), s).d by A11,A15,SCMFSA_2:89
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by SCMFSA_3:11;
      end;
    end;
    IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = succ IC (s +* Start-At (IC
    s -'k,SCM+FSA)) by A10,SCMFSA_2:89
      .= ((succ IC s)) -' k by A6,FUNCT_4:121
      .= IC Exec(IncAddr(INS,k), s) -' k by A11,SCMFSA_2:89
      .= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s)
    -'k,SCM+FSA)) by FUNCT_4:121;
    hence thesis by A1,A12,A13,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 2;
    then consider da,db being Int-Location such that
A16: INS = AddTo(da, db) by SCMFSA_2:55;
A17: IncAddr(INS, k) = AddTo(da, db) by A16,Th10;
A18: now
      let d be FinSeq-Location;
      thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
       (s +* Start-At(IC s -'k,SCM+FSA)
      ).d by A16,SCMFSA_2:90
        .= s.d by SCMFSA_3:12
        .= Exec(IncAddr(INS, k), s).d by A17,SCMFSA_2:90
        .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
      -'k,SCM+FSA)).d by SCMFSA_3:12;
    end;
A19: now
      let d be Int-Location;
      per cases;
      suppose
A20:    da = d;
        hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
         (s +* Start-At (IC s -'
        k,SCM+FSA)).da + (s +* Start-At(IC s -'k,SCM+FSA)).db
         by A16,SCMFSA_2:90
          .= s.da + (s +* Start-At(IC s -'k,SCM+FSA)).db by SCMFSA_3:11
          .= s.da + s.db by SCMFSA_3:11
          .= Exec(IncAddr(INS,k), s).d by A17,A20,SCMFSA_2:90
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by SCMFSA_3:11;
      end;
      suppose
A21:    da <> d;
        hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
         (s +* Start-At (IC s -'
        k,SCM+FSA)).d by A16,SCMFSA_2:90
          .= s.d by SCMFSA_3:11
          .= Exec(IncAddr(INS, k), s).d by A17,A21,SCMFSA_2:90
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by SCMFSA_3:11;
      end;
    end;
    IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = succ IC (s +* Start-At (IC
    s -'k,SCM+FSA)) by A16,SCMFSA_2:90
      .= ((succ IC s)) -' k by A6,FUNCT_4:121
      .= IC Exec(IncAddr(INS,k), s) -' k by A17,SCMFSA_2:90
      .= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s)
    -'k,SCM+FSA)) by FUNCT_4:121;
    hence thesis by A1,A18,A19,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 3;
    then consider da,db being Int-Location such that
A22: INS = SubFrom(da, db) by SCMFSA_2:56;
A23: IncAddr(INS, k) = SubFrom(da, db) by A22,Th11;
A24: now
      let d be FinSeq-Location;
      thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
       (s +* Start-At(IC s -'k,SCM+FSA)
      ).d by A22,SCMFSA_2:91
        .= s.d by SCMFSA_3:12
        .= Exec(IncAddr(INS, k), s).d by A23,SCMFSA_2:91
        .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
      -'k,SCM+FSA)).d by SCMFSA_3:12;
    end;
A25: now
      let d be Int-Location;
      per cases;
      suppose
A26:    da = d;
        hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
         (s +* Start-At (IC s -'
        k,SCM+FSA)).da - (s +* Start-At(IC s -'k,SCM+FSA)).db
         by A22,SCMFSA_2:91
          .= s.da - (s +* Start-At(IC s -'k,SCM+FSA)).db by SCMFSA_3:11
          .= s.da - s.db by SCMFSA_3:11
          .= Exec(IncAddr(INS,k), s).d by A23,A26,SCMFSA_2:91
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by SCMFSA_3:11;
      end;
      suppose
A27:    da <> d;
        hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
         (s +* Start-At (IC s -'
        k,SCM+FSA)).d by A22,SCMFSA_2:91
          .= s.d by SCMFSA_3:11
          .= Exec(IncAddr(INS, k), s).d by A23,A27,SCMFSA_2:91
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by SCMFSA_3:11;
      end;
    end;
    IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = succ IC (s +* Start-At (IC
    s -'k,SCM+FSA)) by A22,SCMFSA_2:91
      .= ((succ IC s)) -' k by A6,FUNCT_4:121
      .= IC Exec(IncAddr(INS,k), s) -' k by A23,SCMFSA_2:91
      .= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s)
    -'k,SCM+FSA)) by FUNCT_4:121;
    hence thesis by A1,A24,A25,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 4;
    then consider da,db being Int-Location such that
A28: INS = MultBy(da, db) by SCMFSA_2:57;
A29: IncAddr(INS, k) = MultBy(da, db) by A28,Th12;
A30: now
      let d be FinSeq-Location;
      thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
       (s +* Start-At(IC s -'k,SCM+FSA)
      ).d by A28,SCMFSA_2:92
        .= s.d by SCMFSA_3:12
        .= Exec(IncAddr(INS, k), s).d by A29,SCMFSA_2:92
        .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
      -'k,SCM+FSA)).d by SCMFSA_3:12;
    end;
A31: now
      let d be Int-Location;
      per cases;
      suppose
A32:    da = d;
        hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
         (s +* Start-At (IC s -'
        k,SCM+FSA)).da * (s +* Start-At(IC s -'k,SCM+FSA)).db
         by A28,SCMFSA_2:92
          .= s.da * (s +* Start-At(IC s -'k,SCM+FSA)).db by SCMFSA_3:11
          .= s.da * s.db by SCMFSA_3:11
          .= Exec(IncAddr(INS,k), s).d by A29,A32,SCMFSA_2:92
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by SCMFSA_3:11;
      end;
      suppose
A33:    da <> d;
        hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
         (s +* Start-At (IC s -'
        k,SCM+FSA)).d by A28,SCMFSA_2:92
          .= s.d by SCMFSA_3:11
          .= Exec(IncAddr(INS, k), s).d by A29,A33,SCMFSA_2:92
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by SCMFSA_3:11;
      end;
    end;
    IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = succ IC (s +* Start-At (IC
    s -'k,SCM+FSA)) by A28,SCMFSA_2:92
      .= ((succ IC s)) -' k by A6,FUNCT_4:121
      .= IC Exec(IncAddr(INS,k), s) -' k by A29,SCMFSA_2:92
      .= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s)
    -'k,SCM+FSA)) by FUNCT_4:121;
    hence thesis by A1,A30,A31,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 5;
    then consider da,db being Int-Location such that
A34: INS = Divide(da, db) by SCMFSA_2:58;
A35: IncAddr(INS, k) = Divide(da, db) by A34,Th13;
    now
      per cases;
      suppose
A36:    da <> db;
A37:    now
          let d be Int-Location;
          per cases;
          suppose
A38:        da = d;
            hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
             (s +* Start-At(IC s
            -'k,SCM+FSA)).da div (s +* Start-At(IC s -'k,SCM+FSA)).db
             by A34,A36,SCMFSA_2:93
              .= s.da div (s +* Start-At(IC s -'k,SCM+FSA)).db by SCMFSA_3:11
              .= s.da div s.db by SCMFSA_3:11
              .= Exec(IncAddr(INS,k), s).d by A35,A36,A38,SCMFSA_2:93
              .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k
            ),s) -'k,SCM+FSA)).d by SCMFSA_3:11;
          end;
          suppose
A39:        db = d;
            hence
            Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d = (s +* Start-At (IC s
            -'k,SCM+FSA)).da mod (s +* Start-At(IC s -'k,SCM+FSA)).db
             by A34,SCMFSA_2:93
              .= s.da mod (s +* Start-At(IC s -'k,SCM+FSA)).db by SCMFSA_3:11
              .= s.da mod s.db by SCMFSA_3:11
              .= Exec(IncAddr(INS,k), s).d by A35,A39,SCMFSA_2:93
              .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k
            ),s) -'k,SCM+FSA)).d by SCMFSA_3:11;
          end;
          suppose
A40:        da <> d & db <> d;
            hence
            Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d = (s +* Start-At (IC s
            -'k,SCM+FSA)).d by A34,SCMFSA_2:93
              .= s.d by SCMFSA_3:11
              .= Exec(IncAddr(INS,k), s).d by A35,A40,SCMFSA_2:93
              .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k
            ),s) -'k,SCM+FSA)).d by SCMFSA_3:11;
          end;
        end;
A41:    now
          let d be FinSeq-Location;
          thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
           (s +* Start-At (IC s
          -'k,SCM+FSA)).d by A34,SCMFSA_2:93
            .= s.d by SCMFSA_3:12
            .= Exec(IncAddr(INS,k), s).d by A35,SCMFSA_2:93
            .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),
          s) -'k,SCM+FSA)).d by SCMFSA_3:12;
        end;
        IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = succ IC (s +* Start-At
        (IC s -'k,SCM+FSA)) by A34,SCMFSA_2:93
          .= ((succ IC s)) -' k by A6,FUNCT_4:121
          .= IC Exec(IncAddr(INS,k), s) -' k by A35,SCMFSA_2:93
          .= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),
        s) -'k,SCM+FSA)) by FUNCT_4:121;
        hence thesis by A1,A41,A37,SCMFSA_2:86;
      end;
      suppose
A42:    da = db;
A43:    now
          let d be Int-Location;
          per cases;
          suppose
A44:        da = d;
            hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
             (s +* Start-At(IC s
            -'k,SCM+FSA)).da mod (s +* Start-At(IC s -'k,SCM+FSA)).db
             by A34,A42,SCMFSA_2:94
              .= s.da mod (s +* Start-At(IC s -'k,SCM+FSA)).db by SCMFSA_3:11
              .= s.da mod s.db by SCMFSA_3:11
              .= Exec(IncAddr(INS,k), s).d by A35,A42,A44,SCMFSA_2:94
              .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k
            ),s) -'k,SCM+FSA)).d by SCMFSA_3:11;
          end;
          suppose
A45:        da <> d;
            hence
            Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d = (s +* Start-At (IC s
            -'k,SCM+FSA)).d by A34,A42,SCMFSA_2:94
              .= s.d by SCMFSA_3:11
              .= Exec(IncAddr(INS,k), s).d by A35,A42,A45,SCMFSA_2:94
              .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k
            ),s) -'k,SCM+FSA)).d by SCMFSA_3:11;
          end;
        end;
A46:    now
          let d be FinSeq-Location;
          thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
           (s +* Start-At (IC s
          -'k,SCM+FSA)).d by A34,A42,SCMFSA_2:94
            .= s.d by SCMFSA_3:12
            .= Exec(IncAddr(INS,k), s).d by A35,A42,SCMFSA_2:94
            .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),
          s) -'k,SCM+FSA)).d by SCMFSA_3:12;
        end;
        IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = succ IC (s +* Start-At
        (IC s -'k,SCM+FSA)) by A34,A42,SCMFSA_2:94
          .= ((succ IC s)) -' k by A6,FUNCT_4:121
          .= IC Exec(IncAddr(INS,k), s) -' k by A35,A42,SCMFSA_2:94
          .= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),
        s) -'k,SCM+FSA)) by FUNCT_4:121;
        hence thesis by A1,A46,A43,SCMFSA_2:86;
      end;
    end;
    hence thesis;
  end;
  suppose
    InsCode INS = 6;
    then consider loc being Element of NAT such that
A47: INS = goto loc by SCMFSA_2:59;
A48: IncAddr(INS, k) = goto (loc + k) by A47,Th14;
    then
A49: IC Exec(IncAddr(INS,k), s)= loc + k by SCMFSA_2:95;
A50: now
      let d be Int-Location;
      thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
       (s +* Start-At(IC s -'k,SCM+FSA)
      ).d by A47,SCMFSA_2:95
        .= s.d by SCMFSA_3:11
        .= Exec(IncAddr(INS,k), s).d by A48,SCMFSA_2:95
        .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
      -'k,SCM+FSA)).d by SCMFSA_3:11;
    end;
A51: now
      let d be FinSeq-Location;
      thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
       (s +* Start-At(IC s -'k,SCM+FSA)
      ).d by A47,SCMFSA_2:95
        .= s.d by SCMFSA_3:12
        .= Exec(IncAddr(INS, k), s).d by A48,SCMFSA_2:95
        .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
      -'k,SCM+FSA)).d by SCMFSA_3:12;
    end;
    IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = loc by A47,SCMFSA_2:95
      .= IC Exec(IncAddr(INS,k), s) -' k by A49,NAT_D:34
      .= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s)
    -'k,SCM+FSA)) by FUNCT_4:121;
    hence thesis by A1,A51,A50,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 7;
    then consider
    loc being Element of NAT, da being Int-Location
    such that
A52: INS = da=0_goto loc by SCMFSA_2:60;
A53: IncAddr(INS, k) = da=0_goto (loc + k) by A52,Th15;
A54: now
      let d be Int-Location;
      thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
       (s +* Start-At(IC s -'k,SCM+FSA)
      ).d by A52,SCMFSA_2:96
        .= s.d by SCMFSA_3:11
        .= Exec(IncAddr(INS,k), s).d by A53,SCMFSA_2:96
        .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
      -'k,SCM+FSA)).d by SCMFSA_3:11;
    end;
A55: now
      per cases;
      suppose
A56:    s.da = 0;
        then
A57:    IC Exec(IncAddr(INS,k), s)= loc + k by A53,SCMFSA_2:96;
        (s +* Start-At(IC s -'k,SCM+FSA)).da = 0 by A56,SCMFSA_3:11;
        then IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = loc by A52,
SCMFSA_2:96
          .= IC Exec(IncAddr(INS,k), s) -' k by A57,NAT_D:34
          .= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),
        s) -'k,SCM+FSA)) by FUNCT_4:121;
        hence
        IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = IC(Exec(IncAddr(INS,k),
        s) +* Start-At(IC Exec(IncAddr(INS,k),s)-'k,SCM+FSA));
      end;
      suppose
A58:    s.da <> 0;
        then (s +* Start-At(IC s -'k,SCM+FSA)).da <> 0 by SCMFSA_3:11;
        then IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) =
         succ IC (s +* Start-At
        (IC s -'k,SCM+FSA)) by A52,SCMFSA_2:96
          .= ((succ IC s)) -' k by A6,FUNCT_4:121
          .= IC Exec(IncAddr(INS,k), s) -' k by A53,A58,SCMFSA_2:96
          .= IC(Exec(IncAddr(INS,k),s) +* Start-At(IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)) by FUNCT_4:121;
        hence
        IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = IC(Exec(IncAddr(INS,k),
        s) +* Start-At(IC Exec(IncAddr(INS,k),s)-'k,SCM+FSA));
      end;
    end;
    now
      let d be FinSeq-Location;
      thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
       (s +* Start-At(IC s -'k,SCM+FSA)
      ).d by A52,SCMFSA_2:96
        .= s.d by SCMFSA_3:12
        .= Exec(IncAddr(INS, k), s).d by A53,SCMFSA_2:96
        .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
      -'k,SCM+FSA)).d by SCMFSA_3:12;
    end;
    hence thesis by A1,A55,A54,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 8;
    then consider
    loc being Element of NAT, da being Int-Location
    such that
A59: INS = da>0_goto loc by SCMFSA_2:61;
A60: IncAddr(INS, k) = da>0_goto (loc + k) by A59,Th16;
A61: now
      let d be Int-Location;
      thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
       (s +* Start-At(IC s -'k,SCM+FSA)
      ).d by A59,SCMFSA_2:97
        .= s.d by SCMFSA_3:11
        .= Exec(IncAddr(INS,k), s).d by A60,SCMFSA_2:97
        .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
      -'k,SCM+FSA)).d by SCMFSA_3:11;
    end;
A62: now
      per cases;
      suppose
A63:    s.da > 0;
        then
A64:    IC Exec(IncAddr(INS,k), s)= loc + k by A60,SCMFSA_2:97;
        (s +* Start-At(IC s -'k,SCM+FSA)).da > 0 by A63,SCMFSA_3:11;
        then IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = loc by A59,
SCMFSA_2:97
          .= IC Exec(IncAddr(INS,k), s) -' k by A64,NAT_D:34
          .= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),
        s) -'k,SCM+FSA)) by FUNCT_4:121;
        hence
        IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = IC (Exec(IncAddr(INS,k)
        ,s) +* Start-At(IC Exec(IncAddr(INS,k),s)-'k,SCM+FSA));
      end;
      suppose
A65:    s.da <= 0;
        then (s +* Start-At(IC s -'k,SCM+FSA)).da <= 0 by SCMFSA_3:11;
        then IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) =
         succ IC (s +* Start-At
        (IC s -'k,SCM+FSA)) by A59,SCMFSA_2:97
          .= ((succ IC s) ) -' k by A6,FUNCT_4:121
          .= IC Exec(IncAddr(INS,k), s) -' k by A60,A65,SCMFSA_2:97
          .= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),
        s) -'k,SCM+FSA)) by FUNCT_4:121;
        hence
        IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = IC (Exec(IncAddr(INS,k)
        ,s) +* Start-At(IC Exec(IncAddr(INS,k),s)-'k,SCM+FSA));
      end;
    end;
    now
      let d be FinSeq-Location;
      thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
       (s +* Start-At(IC s -'k,SCM+FSA)
      ).d by A59,SCMFSA_2:97
        .= s.d by SCMFSA_3:12
        .= Exec(IncAddr(INS, k), s).d by A60,SCMFSA_2:97
        .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
      -'k,SCM+FSA)).d by SCMFSA_3:12;
    end;
    hence thesis by A1,A62,A61,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 9;
    then consider db,da being Int-Location, f being FinSeq-Location such that
A66: INS = da := (f,db) by SCMFSA_2:62;
A67: IncAddr(INS, k) = da := (f,db) by A66,Th17;
A68: now
      let d be FinSeq-Location;
      thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
       (s +* Start-At(IC s -'k,SCM+FSA)
      ).d by A66,SCMFSA_2:98
        .= s.d by SCMFSA_3:12
        .= Exec(IncAddr(INS, k), s).d by A67,SCMFSA_2:98
        .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
      -'k,SCM+FSA)).d by SCMFSA_3:12;
    end;
A69: now
      let d be Int-Location;
      per cases;
      suppose
A70:    da = d;
        consider m being Element of NAT such that
A71:    m = abs(s.db) and
A72:    Exec(IncAddr(INS,k), s).da = (s.f)/.m by A67,SCMFSA_2:98;
        (ex m9 being Element of NAT st m9 = abs((s +* Start-At (IC s -'
k,SCM+FSA)).db) & Exec(INS,s +* Start-At(IC s -'k,SCM+FSA)).da =
 ((s +* Start-At(IC s -'k,SCM+FSA))
.f)/.m9 )& (s +* Start-At(IC s -'k,SCM+FSA)).db = s.db
 by A66,SCMFSA_2:98,SCMFSA_3:11
        ;
        hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
         (s.f)/.m by A70,A71,SCMFSA_3:12
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by A70,A72,SCMFSA_3:11;
      end;
      suppose
A73:    da <> d;
        hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
         (s +* Start-At (IC s -'
        k,SCM+FSA)).d by A66,SCMFSA_2:98
          .= s.d by SCMFSA_3:11
          .= Exec(IncAddr(INS, k), s).d by A67,A73,SCMFSA_2:98
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by SCMFSA_3:11;
      end;
    end;
    IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = succ IC (s +* Start-At (IC
    s -'k,SCM+FSA)) by A66,SCMFSA_2:98
      .= ((succ IC s) ) -' k by A6,FUNCT_4:121
      .= IC Exec(IncAddr(INS,k), s) -' k by A67,SCMFSA_2:98
      .= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s)
    -'k,SCM+FSA)) by FUNCT_4:121;
    hence thesis by A1,A68,A69,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 10;
    then consider db,da being Int-Location, f being FinSeq-Location such that
A74: INS = (f,db):= da by SCMFSA_2:63;
A75: IncAddr(INS, k) = (f,db):=da by A74,Th18;
A76: now
      let d be Int-Location;
      thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
       (s +* Start-At(IC s -'k,SCM+FSA)
      ).d by A74,SCMFSA_2:99
        .= s.d by SCMFSA_3:11
        .= Exec(IncAddr(INS, k), s).d by A75,SCMFSA_2:99
        .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
      -'k,SCM+FSA)).d by SCMFSA_3:11;
    end;
A77: now
      let d be FinSeq-Location;
      per cases;
      suppose
A78:    f = d;
A79:    (s +* Start-At(IC s -'k,SCM+FSA)).db = s.db by SCMFSA_3:11;
        consider m being Element of NAT such that
A80:    m = abs(s.db) and
A81:    Exec(IncAddr(INS,k), s).f = s.f+*(m,s.da) by A75,SCMFSA_2:99;
        (ex m9 being Element of NAT st m9 = abs((s +* Start-At (IC s -'
k,SCM+FSA)).db) & Exec(INS,s +* Start-At(IC s -'k,SCM+FSA)).f =
 (s +* Start-At(IC s -'k,SCM+FSA)).f
+*(m9,(s +* Start-At(IC s -'k,SCM+FSA)).da) )&
 (s +* Start-At(IC s -'k,SCM+FSA)).da = s.da
        by A74,SCMFSA_2:99,SCMFSA_3:11;
        hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
         s.f+*(m,s.da) by A78,A80,A79,SCMFSA_3:12
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by A78,A81,SCMFSA_3:12;
      end;
      suppose
A82:    f <> d;
        hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
         (s +* Start-At (IC s -'
        k,SCM+FSA)).d by A74,SCMFSA_2:99
          .= s.d by SCMFSA_3:12
          .= Exec(IncAddr(INS, k), s).d by A75,A82,SCMFSA_2:99
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by SCMFSA_3:12;
      end;
    end;
    IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = succ IC (s +* Start-At (IC
    s -'k,SCM+FSA)) by A74,SCMFSA_2:99
      .= ((succ IC s) ) -' k by A6,FUNCT_4:121
      .= IC Exec(IncAddr(INS,k), s) -' k by A75,SCMFSA_2:99
      .= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s)
    -'k,SCM+FSA)) by FUNCT_4:121;
    hence thesis by A1,A76,A77,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 11;
    then consider da being Int-Location, f being FinSeq-Location such that
A83: INS = da :=len f by SCMFSA_2:64;
A84: IncAddr(INS, k) = da :=len f by A83,Th19;
A85: now
      let d be FinSeq-Location;
      thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
       (s +* Start-At(IC s -'k,SCM+FSA)
      ).d by A83,SCMFSA_2:100
        .= s.d by SCMFSA_3:12
        .= Exec(IncAddr(INS, k), s).d by A84,SCMFSA_2:100
        .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
      -'k,SCM+FSA)).d by SCMFSA_3:12;
    end;
A86: now
      let d be Int-Location;
      per cases;
      suppose
A87:    da = d;
        hence
        Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d = len((s +* Start-At (IC s
        -'k,SCM+FSA)).f) by A83,SCMFSA_2:100
          .= len(s.f) by SCMFSA_3:12
          .= Exec(IncAddr(INS,k), s).d by A84,A87,SCMFSA_2:100
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by SCMFSA_3:11;
      end;
      suppose
A88:    da <> d;
        hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
         (s +* Start-At (IC s -'
        k,SCM+FSA)).d by A83,SCMFSA_2:100
          .= s.d by SCMFSA_3:11
          .= Exec(IncAddr(INS, k), s).d by A84,A88,SCMFSA_2:100
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by SCMFSA_3:11;
      end;
    end;
    IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = succ IC (s +* Start-At (IC
    s -'k,SCM+FSA)) by A83,SCMFSA_2:100
      .= ((succ IC s) ) -' k by A6,FUNCT_4:121
      .= IC Exec(IncAddr(INS,k), s) -' k by A84,SCMFSA_2:100
      .= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s)
    -'k,SCM+FSA)) by FUNCT_4:121;
    hence thesis by A1,A85,A86,SCMFSA_2:86;
  end;
  suppose
    InsCode INS = 12;
    then consider da being Int-Location, f being FinSeq-Location such that
A89: INS = f:=<0,...,0> da by SCMFSA_2:65;
A90: IncAddr(INS, k) = f:=<0,...,0>da by A89,Th20;
A91: now
      let d be Int-Location;
      thus Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
       (s +* Start-At(IC s -'k,SCM+FSA)
      ).d by A89,SCMFSA_2:101
        .= s.d by SCMFSA_3:11
        .= Exec(IncAddr(INS, k), s).d by A90,SCMFSA_2:101
        .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
      -'k,SCM+FSA)).d by SCMFSA_3:11;
    end;
A92: now
      let d be FinSeq-Location;
      per cases;
      suppose
A93:    f = d;
A94:    (s +* Start-At(IC s -'k,SCM+FSA)).da = s.da by SCMFSA_3:11;
        (ex m being Element of NAT st m = abs(s.da) & Exec( IncAddr(INS,
k), s).f = m |-> 0 )& ex m9 being Element of NAT st m9 = abs((s +* Start-At (IC
s -'k,SCM+FSA)). da) & Exec(INS,s +* Start-At(IC s -'k,SCM+FSA)).f = m9 |-> 0
 by A89,A90,SCMFSA_2:101;
        hence
        Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d = (Exec(IncAddr(INS,k), s)
+* Start-At (IC Exec(IncAddr(INS,k),s) -'k,SCM+FSA)).d by A93,A94,SCMFSA_3:12;
      end;
      suppose
A95:    f <> d;
        hence Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)).d =
         (s +* Start-At (IC s -'
        k,SCM+FSA)).d by A89,SCMFSA_2:101
          .= s.d by SCMFSA_3:12
          .= Exec(IncAddr(INS, k), s).d by A90,A95,SCMFSA_2:101
          .= (Exec(IncAddr(INS,k), s) +* Start-At (IC Exec(IncAddr(INS,k),s)
        -'k,SCM+FSA)).d by SCMFSA_3:12;
      end;
    end;
    IC Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = succ IC (s +* Start-At (IC
    s -'k,SCM+FSA)) by A89,SCMFSA_2:101
      .= ((succ IC s) ) -' k by A6,FUNCT_4:121
      .= IC Exec(IncAddr(INS,k), s) -' k by A90,SCMFSA_2:101
      .= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s)
    -'k,SCM+FSA)) by FUNCT_4:121;
    hence thesis by A1,A91,A92,SCMFSA_2:86;
  end;
end;

begin :: Shifting the finite partial state

canceled 5;

theorem
  for i,j being Element of NAT,
      p being
      finite NAT-defined (the Instructions of SCM+FSA)-valued Function
      holds
  Shift(IncAddr(p,i),j) = IncAddr(Shift(p,j),i)
proof
  let i,j be Element of NAT, p be
      finite NAT-defined (the Instructions of SCM+FSA)-valued Function;
  dom(IncAddr(p,i)) = dom p by Def6;
  then
A1: dom(Shift(p,j)) = { m+j: m in dom (IncAddr(p,i)) } by VALUED_1:def 12
    .= dom (Shift(IncAddr(p,i),j)) by VALUED_1:def 12;
A2: now
    let x be set;
    assume
A3: x in dom (Shift(IncAddr(p,i),j));
    then
A4: x in { m+j where m is Element of NAT: m in dom IncAddr(p,i) } by
VALUED_1:def 12;
    dom (Shift(IncAddr(p,i),j)) c= NAT by RELAT_1:def 18;
    then reconsider x9=x as Element of NAT by A3;
    reconsider xx=x9 as Element of NAT;
    consider m being Element of NAT such that
A5: x = m+j and
A6: m in dom IncAddr(p,i) by A4;
A7:  m in dom p by A6,Def6;
    dom Shift(p,j) = { mm+j where mm is Element of NAT : mm in dom p} by
VALUED_1:def 12;
    then
A8: x9 in dom Shift(p,j) by A5,A7;
A9: p/.m = p.( m) by A7,PARTFUN1:def 8
      .= Shift(p,j).(( m)+j) by A7,VALUED_1:def 12
      .= Shift(p,j).((m+j))
      .= Shift(p,j)/.xx by A5,A8,PARTFUN1:def 8;
    thus Shift(IncAddr(p,i),j).x = IncAddr(p,i).( m) by A5,A6,VALUED_1:def 12
      .= IncAddr(Shift(p,j)/.xx,i) by A7,A9,Th24
      .= IncAddr(Shift(p,j),i).x by A8,Th24;
  end;
  dom(IncAddr(Shift(p,j),i)) = dom (Shift(p,j)) by Def6;
  hence thesis by A1,A2,FUNCT_1:9;
end;

