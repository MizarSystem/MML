:: Modifying addresses of instructions of { \bf SCM_FSA }
::  by Andrzej Trybulec and Yatsuka Nakamura
::
:: Received February 14, 1996
:: Copyright (c) 1996-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, AMI_3, SCMFSA_2, AMISTD_2, CARD_1,
      GRAPHSP, ARYTM_3, SCMNORM, RELAT_1, FUNCT_1, FUNCT_4, XBOOLE_0, FSM_1,
      ARYTM_1, INT_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2, NAT_1, COMPOS_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, NUMBERS, CARD_3, XXREAL_0,
      XCMPLX_0, MCART_1, NAT_1, NAT_D, VALUED_1, INT_1, INT_2, RELAT_1,
      FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4, FUNCOP_1, FUNCT_7, FINSEQ_1,
      FINSEQ_2, STRUCT_0, MEMSTR_0, COMPOS_1, EXTPRO_1, AMI_3, SCMFSA_2,
      AMISTD_2, AMISTD_5;
 constructors DOMAIN_1, XXREAL_0, AMI_3, SCMFSA_2, NAT_D, RELSET_1, VALUED_1,
      AMISTD_2, AMISTD_5, PBOOLE, FUNCT_7, MEMSTR_0;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1,
      NUMBERS, XREAL_0, INT_1, CARD_3, SCMFSA_2, FINSET_1, VALUED_1, FUNCT_4,
      RELAT_1, AMI_3, AMI_6, RELOC, XXREAL_0, SCMFSA10, AMISTD_2, VALUED_0,
      COMPOS_1, EXTPRO_1, AMISTD_5, MEMSTR_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, COMPOS_1, EXTPRO_1, AMI_3, SCMFSA_2, FUNCOP_1, RELAT_1,
      AMISTD_2, FUNCT_1, AMISTD_5, MEMSTR_0;
 theorems SCMFSA_2, ENUMSET1, NAT_1, TARSKI, SCMFSA_3, VALUED_1, AMISTD_2,
      RECDEF_2, SCMFSA10, FINSEQ_1, ORDINAL1, COMPOS_1, EXTPRO_1, MEMSTR_0;

begin :: Incrementing addresses

reserve L, j, k, l, m, n, p, q for Element of NAT,
  A for Data-Location,
  I for Instruction of SCM;

registration
 let a,b be Int-Location;
 cluster a:=b -> ins-loc-free;
 coherence
  proof
     a := b = [1,{},<*a,b*>] by SCMFSA10:2;
   hence JumpPart(a:=b) is empty by RECDEF_2:def 2;
  end;
 cluster AddTo(a,b) -> ins-loc-free;
 coherence
  proof
    AddTo(a,b) = [2,{},<*a,b*>] by SCMFSA10:3;
   hence JumpPart AddTo(a,b) is empty by RECDEF_2:def 2;
  end;
 cluster SubFrom(a,b) -> ins-loc-free;
 coherence
  proof
    SubFrom(a,b) = [3,{},<*a,b*>] by SCMFSA10:4;
   hence JumpPart SubFrom(a,b) is empty by RECDEF_2:def 2;
  end;
 cluster MultBy(a,b) -> ins-loc-free;
 coherence
  proof
    MultBy(a,b) = [4,{},<*a,b*>] by SCMFSA10:5;
   hence JumpPart MultBy(a,b) is empty by RECDEF_2:def 2;
  end;
 cluster Divide(a,b) -> ins-loc-free;
 coherence
  proof
    Divide(a,b) = [5,{},<*a,b*>] by SCMFSA10:6;
   hence JumpPart Divide(a,b) is empty by RECDEF_2:def 2;
  end;
end;

theorem Th14:
  for k,loc being Element of NAT
  holds IncAddr(goto loc,k) = goto (loc + k)
proof
  let k,loc be Element of NAT;
A1: InsCode IncAddr(goto loc,k) = InsCode goto loc by COMPOS_1:def 17
     .= 6 by RECDEF_2:def 1
     .= InsCode goto (loc + k) by RECDEF_2:def 1;
A2: AddressPart IncAddr(goto loc,k) = AddressPart goto loc
           by COMPOS_1:def 17
     .= {} by RECDEF_2:def 3
     .= AddressPart goto (loc + k) by RECDEF_2:def 3;
A3: JumpPart IncAddr(goto loc,k) = k + JumpPart goto loc
                   by COMPOS_1:def 17;
  JumpPart IncAddr(goto loc,k) = JumpPart goto (loc + k)
   proof
    thus
A4:   dom JumpPart IncAddr(goto loc,k)
     = dom JumpPart goto (loc + k) by A1,COMPOS_1:def 12;
A5: JumpPart goto loc = <*loc*> by RECDEF_2:def 2;
A6: JumpPart goto(loc+k) = <*loc+k*> by RECDEF_2:def 2;
    let x be set;
    assume
A7:   x in dom JumpPart IncAddr(goto loc,k);
     dom <*loc+k*> = {1} by FINSEQ_1:2,38;
     then
A8:   x = 1 by A7,A4,A6,TARSKI:def 1;
    thus (JumpPart IncAddr(goto loc,k)).x
      = k + (JumpPart goto loc).x by A3,A7,VALUED_1:def 2
     .= loc + k by A5,A8,FINSEQ_1:40
     .= (JumpPart goto(loc + k)).x by A6,A8,FINSEQ_1:40;
   end;
 hence thesis by A1,A2,COMPOS_1:1;
end;

theorem Th15:
  for k,loc being Element of NAT, a being Int-Location
   holds IncAddr(a=0_goto loc,k) = a=0_goto (loc + k)
proof
  let k,loc be Element of NAT, a be Int-Location;
A1: a=0_goto loc = [7,<* loc *>,<*a*>] by SCMFSA10:7;
A2: a=0_goto (loc + k) = [7,<* loc + k *>,<*a*>] by SCMFSA10:7;
A3: InsCode IncAddr(a=0_goto loc,k) = InsCode(a=0_goto loc) by COMPOS_1:def 17
     .= 7 by A1,RECDEF_2:def 1
     .= InsCode(a=0_goto(loc + k)) by A2,RECDEF_2:def 1;
A4: AddressPart IncAddr(a=0_goto loc,k) = AddressPart(a=0_goto loc)
           by COMPOS_1:def 17
     .= <*a*> by A1,RECDEF_2:def 3
     .= AddressPart(a=0_goto (loc + k)) by A2,RECDEF_2:def 3;
A5: JumpPart IncAddr(a=0_goto loc,k) = k + JumpPart(a=0_goto loc)
                   by COMPOS_1:def 17;
  JumpPart IncAddr(a=0_goto loc,k) = JumpPart(a=0_goto (loc + k))
   proof
    thus
A6:   dom JumpPart IncAddr(a=0_goto loc,k)
     = dom JumpPart(a=0_goto (loc + k)) by A3,COMPOS_1:def 12;
A7: JumpPart(a=0_goto loc) = <*loc*> by A1,RECDEF_2:def 2;
A8: JumpPart(a=0_goto (loc+k)) = <*loc+k*> by A2,RECDEF_2:def 2;
    let x be set;
    assume
A9:   x in dom JumpPart IncAddr(a=0_goto loc,k);
     dom <*loc+k*> = {1} by FINSEQ_1:2,38;
     then
A10:   x = 1 by A9,A6,A8,TARSKI:def 1;
    thus (JumpPart IncAddr(a=0_goto loc,k)).x
      = k + (JumpPart(a=0_goto loc)).x by A5,A9,VALUED_1:def 2
     .= loc + k by A7,A10,FINSEQ_1:40
     .= (JumpPart(a=0_goto(loc + k))).x by A8,A10,FINSEQ_1:40;
   end;
 hence thesis by A3,A4,COMPOS_1:1;
end;

theorem Th16:
  for k,loc being Element of NAT, a being Int-Location
       holds IncAddr(a>0_goto loc,k) = a>0_goto (loc + k)
proof
  let k,loc be Element of NAT, a be Int-Location;
A1: a>0_goto loc = [8,<* loc *>,<*a*>] by SCMFSA10:8;
A2: a>0_goto (loc + k) = [8,<* loc + k *>,<*a*>] by SCMFSA10:8;
A3: InsCode IncAddr(a>0_goto loc,k) = InsCode(a>0_goto loc) by COMPOS_1:def 17
     .= 8 by A1,RECDEF_2:def 1
     .= InsCode(a>0_goto(loc + k)) by A2,RECDEF_2:def 1;
A4: AddressPart IncAddr(a>0_goto loc,k) = AddressPart(a>0_goto loc)
           by COMPOS_1:def 17
     .= <*a*> by A1,RECDEF_2:def 3
     .= AddressPart(a>0_goto (loc + k)) by A2,RECDEF_2:def 3;
A5: JumpPart IncAddr(a>0_goto loc,k) = k + JumpPart(a>0_goto loc)
                   by COMPOS_1:def 17;
  JumpPart IncAddr(a>0_goto loc,k) = JumpPart(a>0_goto (loc + k))
   proof
    thus
A6:   dom JumpPart IncAddr(a>0_goto loc,k)
     = dom JumpPart(a>0_goto (loc + k)) by A3,COMPOS_1:def 12;
A7: JumpPart(a>0_goto loc) = <*loc*> by A1,RECDEF_2:def 2;
A8: JumpPart(a>0_goto (loc+k)) = <*loc+k*> by A2,RECDEF_2:def 2;
    let x be set;
    assume
A9:   x in dom JumpPart IncAddr(a>0_goto loc,k);
     dom <*loc+k*> = {1} by FINSEQ_1:2,38;
     then
A10:   x = 1 by A9,A6,A8,TARSKI:def 1;
    thus (JumpPart IncAddr(a>0_goto loc,k)).x
      = k + (JumpPart(a>0_goto loc)).x by A5,A9,VALUED_1:def 2
     .= loc + k by A7,A10,FINSEQ_1:40
     .= (JumpPart(a>0_goto(loc + k))).x by A8,A10,FINSEQ_1:40;
   end;
 hence thesis by A3,A4,COMPOS_1:1;
end;

registration
 let a,b be Int-Location; let f be FinSeq-Location;
 cluster b:=(f,a) -> ins-loc-free;
 coherence
  proof
   thus JumpPart(b:=(f,a)) is empty by RECDEF_2:def 2;
  end;
 cluster (f,a):=b -> ins-loc-free;
 coherence
  proof
   thus JumpPart((f,a):=b) is empty by RECDEF_2:def 2;
  end;
end;

registration
 let a be Int-Location; let f be FinSeq-Location;
 cluster a:=len f -> ins-loc-free;
 coherence
  proof
   thus JumpPart(a:=len f) is empty by RECDEF_2:def 2;
  end;
 cluster f:=<0,...,0>a -> ins-loc-free;
 coherence
  proof
   thus JumpPart(f:=<0,...,0>a)  is empty by RECDEF_2:def 2;
  end;
end;

reserve i for Instruction of SCM+FSA;

begin :: Incrementing Addresses in a finite partial state

registration
 cluster SCM+FSA -> relocable;
 coherence
 proof let INS be Instruction of SCM+FSA, j,k be Nat;
   reconsider k as Element of NAT by ORDINAL1:def 12;
  let s be State of SCM+FSA;
A1: IC IncIC(Exec(IncAddr(INS,j),s),k)
       = IC Exec(IncAddr(INS,j),s) + k by MEMSTR_0:53
      .= IC Exec(IncAddr(INS,j+k),IncIC(s,k)) by AMISTD_2:def 3;
  per cases by NAT_1:36,SCMFSA_2:16;
  suppose InsCode INS = 0;
    then
A3: INS = halt SCM+FSA by SCMFSA_2:95;
    then
A4: IncAddr(INS,j) = halt SCM+FSA by COMPOS_1:11;
    Exec(IncAddr(INS,j+k),IncIC(s,k))
       = Exec(INS,IncIC(s,k)) by A3,COMPOS_1:11
      .= IncIC(s,k) by A3,EXTPRO_1:def 3
      .= IncIC(Exec(IncAddr(INS,j),s),k) by A4,EXTPRO_1:def 3;
   hence thesis;
  end;
  suppose InsCode INS = 1;
    then consider da,db being Int-Location such that
A5: INS = da := db by SCMFSA_2:30;
A6: now let f be FinSeq-Location;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).f
         = Exec(INS,IncIC(s,k)).f by A5,COMPOS_1:11
        .= IncIC(s,k).f by A5,SCMFSA_2:63
        .= s.f by SCMFSA_3:4
        .= Exec(INS, s).f by A5,SCMFSA_2:63
        .= Exec(IncAddr(INS,j), s).f by A5,COMPOS_1:11
        .= IncIC(Exec(IncAddr(INS,j),s),k).f by SCMFSA_3:4;
    end;
    now
      let d be Int-Location;
      per cases;
      suppose
A7:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A5,COMPOS_1:11
          .= IncIC(s,k).db by A5,A7,SCMFSA_2:63
          .= s.db by SCMFSA_3:3
          .= Exec(INS, s).d by A5,A7,SCMFSA_2:63
          .= Exec(IncAddr(INS,j), s).d by A5,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
      end;
      suppose
A8:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A5,COMPOS_1:11
          .= IncIC(s,k).d by A5,A8,SCMFSA_2:63
          .= s.d by SCMFSA_3:3
          .= Exec(INS, s).d by A5,A8,SCMFSA_2:63
          .= Exec(IncAddr(INS,j), s).d by A5,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
      end;
    end;
   hence thesis by A6,A1,SCMFSA_2:104;
  end;
  suppose InsCode INS = 2;
    then consider da,db being Int-Location such that
A9: INS = AddTo(da, db) by SCMFSA_2:31;
A10: now let f be FinSeq-Location;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).f
         = Exec(INS,IncIC(s,k)).f by A9,COMPOS_1:11
        .= IncIC(s,k).f by A9,SCMFSA_2:64
        .= s.f by SCMFSA_3:4
        .= Exec(INS, s).f by A9,SCMFSA_2:64
        .= Exec(IncAddr(INS,j), s).f by A9,COMPOS_1:11
        .= IncIC(Exec(IncAddr(INS,j),s),k).f by SCMFSA_3:4;
    end;
    now let d be Int-Location;
      per cases;
      suppose
A11:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A9,COMPOS_1:11
          .= IncIC(s,k).da + IncIC(s,k).db by A11,A9,SCMFSA_2:64
          .= s.da + IncIC(s,k).db by SCMFSA_3:3
          .= s.da + s.db by SCMFSA_3:3
          .= Exec(INS, s).d by A9,A11,SCMFSA_2:64
          .= Exec(IncAddr(INS,j), s).d by A9,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
      end;
      suppose
A12:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A9,COMPOS_1:11
          .= IncIC(s,k).d by A9,A12,SCMFSA_2:64
          .= s.d by SCMFSA_3:3
          .= Exec(INS, s).d by A9,A12,SCMFSA_2:64
          .= Exec(IncAddr(INS,j), s).d by A9,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
      end;
    end;
   hence thesis by A10,A1,SCMFSA_2:104;
  end;
  suppose InsCode INS = 3;
    then consider da,db being Int-Location such that
A13: INS = SubFrom(da, db) by SCMFSA_2:32;
A14: now let f be FinSeq-Location;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).f
         = Exec(INS,IncIC(s,k)).f by A13,COMPOS_1:11
        .= IncIC(s,k).f by A13,SCMFSA_2:65
        .= s.f by SCMFSA_3:4
        .= Exec(INS, s).f by A13,SCMFSA_2:65
        .= Exec(IncAddr(INS,j), s).f by A13,COMPOS_1:11
        .= IncIC(Exec(IncAddr(INS,j),s),k).f by SCMFSA_3:4;
    end;
    now let d be Int-Location;
      per cases;
      suppose
A15:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A13,COMPOS_1:11
          .= IncIC(s,k).da - IncIC(s,k).db by A15,A13,SCMFSA_2:65
          .= s.da - IncIC(s,k).db by SCMFSA_3:3
          .= s.da - s.db by SCMFSA_3:3
          .= Exec(INS, s).d by A13,A15,SCMFSA_2:65
          .= Exec(IncAddr(INS,j), s).d by A13,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
      end;
      suppose
A16:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A13,COMPOS_1:11
          .= IncIC(s,k).d by A13,A16,SCMFSA_2:65
          .= s.d by SCMFSA_3:3
          .= Exec(INS, s).d by A13,A16,SCMFSA_2:65
          .= Exec(IncAddr(INS,j), s).d by A13,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
      end;
    end;
    hence thesis by A14,A1,SCMFSA_2:104;
  end;
  suppose InsCode INS = 4;
    then consider da,db being Int-Location such that
A17: INS = MultBy(da, db) by SCMFSA_2:33;
A18: now let f be FinSeq-Location;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).f
         = Exec(INS,IncIC(s,k)).f by A17,COMPOS_1:11
        .= IncIC(s,k).f by A17,SCMFSA_2:66
        .= s.f by SCMFSA_3:4
        .= Exec(INS, s).f by A17,SCMFSA_2:66
        .= Exec(IncAddr(INS,j), s).f by A17,COMPOS_1:11
        .= IncIC(Exec(IncAddr(INS,j),s),k).f by SCMFSA_3:4;
    end;
    now let d be Int-Location;
      per cases;
      suppose
A19:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A17,COMPOS_1:11
          .= IncIC(s,k).da * IncIC(s,k).db by A19,A17,SCMFSA_2:66
          .= s.da * IncIC(s,k).db by SCMFSA_3:3
          .= s.da * s.db by SCMFSA_3:3
          .= Exec(INS, s).d by A17,A19,SCMFSA_2:66
          .= Exec(IncAddr(INS,j), s).d by A17,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
      end;
      suppose
A20:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A17,COMPOS_1:11
          .= IncIC(s,k).d by A17,A20,SCMFSA_2:66
          .= s.d by SCMFSA_3:3
          .= Exec(INS, s).d by A17,A20,SCMFSA_2:66
          .= Exec(IncAddr(INS,j), s).d by A17,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
      end;
    end;
    hence thesis by A18,A1,SCMFSA_2:104;
  end;
  suppose InsCode INS = 5;
    then consider da,db being Int-Location such that
A21: INS = Divide(da, db) by SCMFSA_2:34;
A22: now let f be FinSeq-Location;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).f
         = Exec(INS,IncIC(s,k)).f by A21,COMPOS_1:11
        .= IncIC(s,k).f by A21,SCMFSA_2:67
        .= s.f by SCMFSA_3:4
        .= Exec(INS, s).f by A21,SCMFSA_2:67
        .= Exec(IncAddr(INS,j), s).f by A21,COMPOS_1:11
        .= IncIC(Exec(IncAddr(INS,j),s),k).f by SCMFSA_3:4;
    end;
     now
      let d be Int-Location;
      per cases;
      suppose
A23:    da <> db;
        hereby
          per cases;
          suppose
A24:        da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A21,COMPOS_1:11
          .= IncIC(s,k).da div IncIC(s,k).db by A23,A24,A21,SCMFSA_2:67
          .= s.da div IncIC(s,k).db by SCMFSA_3:3
          .= s.da div s.db by SCMFSA_3:3
          .= Exec(INS, s).d by A21,A23,A24,SCMFSA_2:67
          .= Exec(IncAddr(INS,j), s).d by A21,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
          end;
          suppose
A25:        db = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A21,COMPOS_1:11
          .= IncIC(s,k).da mod IncIC(s,k).db by A25,A21,SCMFSA_2:67
          .= s.da mod IncIC(s,k).db by SCMFSA_3:3
          .= s.da mod s.db by SCMFSA_3:3
          .= Exec(INS, s).d by A21,A25,SCMFSA_2:67
          .= Exec(IncAddr(INS,j), s).d by A21,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
          end;
          suppose
A26:        da <> d & db <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A21,COMPOS_1:11
          .= IncIC(s,k).d by A21,A26,SCMFSA_2:67
          .= s.d by SCMFSA_3:3
          .= Exec(INS, s).d by A21,A26,SCMFSA_2:67
          .= Exec(IncAddr(INS,j), s).d by A21,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
          end;
        end;
      end;
      suppose
A27:    da = db;
          per cases;
          suppose
A28:        da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A21,COMPOS_1:11
          .= IncIC(s,k).da mod IncIC(s,k).db by A27,A28,A21,SCMFSA_2:67
          .= s.da mod IncIC(s,k).db by SCMFSA_3:3
          .= s.da mod s.db by SCMFSA_3:3
          .= Exec(INS, s).d by A21,A27,A28,SCMFSA_2:67
          .= Exec(IncAddr(INS,j), s).d by A21,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
          end;
       suppose
A29:        da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A21,COMPOS_1:11
          .= IncIC(s,k).d by A21,A27,A29,SCMFSA_2:67
          .= s.d by SCMFSA_3:3
          .= Exec(INS, s).d by A21,A27,A29,SCMFSA_2:67
          .= Exec(IncAddr(INS,j), s).d by A21,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
        end;
      end;
    end;
    hence thesis by A22,A1,SCMFSA_2:104;
  end;
  suppose InsCode INS = 6;
    then consider loc being Element of NAT such that
A30: INS = goto loc by SCMFSA_2:35;
A31: IncAddr(INS, j+k) = goto (loc + (j+k)) by A30,Th14;
    reconsider jj=j as Element of NAT by ORDINAL1:def 12;
A32: IncAddr(INS,jj) = goto (loc + jj) by A30,Th14;
A33: now let f be FinSeq-Location;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).f
         = IncIC(s,k).f by A31,SCMFSA_2:69
        .= s.f by SCMFSA_3:4
        .= Exec(IncAddr(INS,j), s).f by A32,SCMFSA_2:69
        .= IncIC(Exec(IncAddr(INS,j),s),k).f by SCMFSA_3:4;
    end;
    now let d be Int-Location;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = IncIC(s,k).d by A31,SCMFSA_2:69
          .= s.d by SCMFSA_3:3
          .= Exec(IncAddr(INS,j), s).d by A32,SCMFSA_2:69
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
    end;
    hence thesis by A33,A1,SCMFSA_2:104;
  end;
  suppose InsCode INS = 7;
    then consider loc being Element of NAT, da being Int-Location such that
A34: INS = da=0_goto loc by SCMFSA_2:36;
A35: IncAddr(INS, j+k) = da=0_goto (loc + (j+k)) by A34,Th15;
    reconsider jj=j as Element of NAT by ORDINAL1:def 12;
A36: IncAddr(INS,jj) = da=0_goto (loc + jj) by A34,Th15;
A37: now let f be FinSeq-Location;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).f
         = IncIC(s,k).f by A35,SCMFSA_2:70
        .= s.f by SCMFSA_3:4
        .= Exec(IncAddr(INS,j), s).f by A36,SCMFSA_2:70
        .= IncIC(Exec(IncAddr(INS,j),s),k).f by SCMFSA_3:4;
    end;
    now let d be Int-Location;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = IncIC(s,k).d by A35,SCMFSA_2:70
          .= s.d by SCMFSA_3:3
          .= Exec(IncAddr(INS,j), s).d by A36,SCMFSA_2:70
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
    end;
   hence thesis by A1,A37,SCMFSA_2:104;
  end;
  suppose InsCode INS = 8;
    then consider loc being Element of NAT, da being Int-Location such that
A38: INS = da>0_goto loc by SCMFSA_2:37;
A39: IncAddr(INS, j+k) = da>0_goto (loc + (j+k)) by A38,Th16;
    reconsider jj=j as Element of NAT by ORDINAL1:def 12;
A40: IncAddr(INS, jj) = da>0_goto (loc + jj) by A38,Th16;
A41: now let f be FinSeq-Location;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).f
         = IncIC(s,k).f by A39,SCMFSA_2:71
        .= s.f by SCMFSA_3:4
        .= Exec(IncAddr(INS,j), s).f by A40,SCMFSA_2:71
        .= IncIC(Exec(IncAddr(INS,j),s),k).f by SCMFSA_3:4;
    end;
    now let d be Int-Location;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = IncIC(s,k).d by A39,SCMFSA_2:71
          .= s.d by SCMFSA_3:3
          .= Exec(IncAddr(INS,j), s).d by A40,SCMFSA_2:71
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
     end;
   hence thesis by A41,A1,SCMFSA_2:104;
  end;
  suppose InsCode INS = 9;
    then consider db,da being Int-Location, f being FinSeq-Location such that
A42: INS = da :=(f, db) by SCMFSA_2:38;
A43: now let f be FinSeq-Location;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).f
         = Exec(INS,IncIC(s,k)).f by A42,COMPOS_1:11
        .= IncIC(s,k).f by A42,SCMFSA_2:72
        .= s.f by SCMFSA_3:4
        .= Exec(INS, s).f by A42,SCMFSA_2:72
        .= Exec(IncAddr(INS,j), s).f by A42,COMPOS_1:11
        .= IncIC(Exec(IncAddr(INS,j),s),k).f by SCMFSA_3:4;
    end;
    now let d be Int-Location;
      per cases;
      suppose
A44:     da = d;
      consider m being Element of NAT such that
A45:  m = abs(s.db) and
A46:  Exec(INS, s).da = (s.f)/.m by A42,SCMFSA_2:72;
A47:  ex m1 being Element of NAT st
        m1 = abs(IncIC(s,k).db) &
        Exec(INS,IncIC(s,k)).da = (IncIC(s,k).f)/.m1 by A42,SCMFSA_2:72;
A48:     (IncIC(s,k)).db = s.db by SCMFSA_3:3;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A42,COMPOS_1:11
          .= (s.f)/.m by A45,A47,A44,A48,SCMFSA_3:4
          .= IncIC(Exec(INS, s),k).d by A46,A44,SCMFSA_3:3
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by A42,COMPOS_1:11;
      end;
      suppose
A49:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A42,COMPOS_1:11
          .= IncIC(s,k).d by A42,A49,SCMFSA_2:72
          .= s.d by SCMFSA_3:3
          .= Exec(INS, s).d by A42,A49,SCMFSA_2:72
          .= Exec(IncAddr(INS,j), s).d by A42,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
      end;
    end;
   hence thesis by A43,A1,SCMFSA_2:104;
  end;
  suppose InsCode INS = 10;
    then consider db,da being Int-Location, f being FinSeq-Location such that
A50: INS = (f, db):=da by SCMFSA_2:39;
A51: now let g be FinSeq-Location;
      consider m being Element of NAT such that
A52:  m = abs(s.db) and
A53:  Exec(INS, s).f = s.f+*(m,s.da) by A50,SCMFSA_2:73;
A54:  ex m1 being Element of NAT
       st m1 = abs(IncIC(s,k).db) &
       Exec(INS,IncIC(s,k)).f = IncIC(s,k).f +*(m1,IncIC(s,k).da)
        by A50,SCMFSA_2:73;
      per cases;
      suppose
A55:    f = g;
A56:     IncIC(s,k).f = s.f & IncIC(s,k).db = s.db by SCMFSA_3:3,4;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).g
         =  Exec(INS, IncIC(s,k)).g by A50,COMPOS_1:11
        .= s.f+*(m,s.da) by A52,A54,A55,A56,SCMFSA_3:3
        .= IncIC(Exec(INS, s),k).g by A53,A55,SCMFSA_3:4
        .= IncIC(Exec(IncAddr(INS,j),s),k).g by A50,COMPOS_1:11;
     end;
      suppose
A57:    f <> g;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).g
           = Exec(INS,IncIC(s,k)).g by A50,COMPOS_1:11
          .= IncIC(s,k).g by A50,A57,SCMFSA_2:73
          .= s.g by SCMFSA_3:4
          .= Exec(INS, s).g by A50,A57,SCMFSA_2:73
          .= Exec(IncAddr(INS,j), s).g by A50,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).g by SCMFSA_3:4;
     end;
    end;
    now let d be Int-Location;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A50,COMPOS_1:11
          .= IncIC(s,k).d by A50,SCMFSA_2:73
          .= s.d by SCMFSA_3:3
          .= Exec(INS, s).d by A50,SCMFSA_2:73
          .= Exec(IncAddr(INS,j), s).d by A50,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
    end;
   hence thesis by A51,A1,SCMFSA_2:104;
  end;
  suppose InsCode INS = 11;
    then consider da being Int-Location, f being FinSeq-Location such that
A58: INS = da :=len f by SCMFSA_2:40;
A59: now let f be FinSeq-Location;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).f
         = Exec(INS,IncIC(s,k)).f by A58,COMPOS_1:11
        .= IncIC(s,k).f by A58,SCMFSA_2:74
        .= s.f by SCMFSA_3:4
        .= Exec(INS, s).f by A58,SCMFSA_2:74
        .= Exec(IncAddr(INS,j), s).f by A58,COMPOS_1:11
        .= IncIC(Exec(IncAddr(INS,j),s),k).f by SCMFSA_3:4;
    end;
    now let d be Int-Location;
      per cases;
      suppose
A60:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A58,COMPOS_1:11
          .= len(IncIC(s,k).f) by A60,A58,SCMFSA_2:74
          .= len(s.f) by SCMFSA_3:4
          .= Exec(INS, s).d by A58,A60,SCMFSA_2:74
          .= IncIC(Exec(INS, s),k).d by SCMFSA_3:3
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by A58,COMPOS_1:11;
      end;
      suppose
A61:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A58,COMPOS_1:11
          .= IncIC(s,k).d by A58,A61,SCMFSA_2:74
          .= s.d by SCMFSA_3:3
          .= Exec(INS, s).d by A58,A61,SCMFSA_2:74
          .= Exec(IncAddr(INS,j), s).d by A58,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
      end;
    end;
   hence thesis by A59,A1,SCMFSA_2:104;
  end;
  suppose InsCode INS = 12;
    then consider da being Int-Location, f being FinSeq-Location such that
A62: INS = f:=<0,...,0>da by SCMFSA_2:41;
A63: now let g be FinSeq-Location;
A64:  (ex m being Element of NAT
        st m = abs(s.da) & Exec(INS, s ).f = m|-> 0 ) &
       ex m being Element of NAT st m = abs(IncIC(s,k).da)
         & Exec (INS,IncIC(s,k)).f = m |-> 0 by A62,SCMFSA_2:75;
      per cases;
      suppose
A65:    f = g;
A66:     IncIC(s,k).da = s.da by SCMFSA_3:3;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).g
         =  Exec(INS, IncIC(s,k)).g by A62,COMPOS_1:11
        .= IncIC(Exec(INS, s),k).g by A64,A65,A66,SCMFSA_3:4
        .= IncIC(Exec(IncAddr(INS,j),s),k).g by A62,COMPOS_1:11;
      end;
      suppose
A67:    f <> g;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).g
           = Exec(INS,IncIC(s,k)).g by A62,COMPOS_1:11
          .= IncIC(s,k).g by A62,A67,SCMFSA_2:75
          .= s.g by SCMFSA_3:4
          .= Exec(INS, s).g by A62,A67,SCMFSA_2:75
          .= Exec(IncAddr(INS,j), s).g by A62,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).g by SCMFSA_3:4;
     end;
    end;
    now let d be Int-Location;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A62,COMPOS_1:11
          .= IncIC(s,k).d by A62,SCMFSA_2:75
          .= s.d by SCMFSA_3:3
          .= Exec(INS, s).d by A62,SCMFSA_2:75
          .= Exec(IncAddr(INS,j), s).d by A62,COMPOS_1:11
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by SCMFSA_3:3;
    end;
   hence thesis by A63,A1,SCMFSA_2:104;
  end;
 end;
end;

theorem
 not InsCode i in {6,7,8} implies IncAddr(i,k) = i
proof
 assume not InsCode i in {6,7,8};
  then
A1: InsCode i <> 6 & InsCode i <> 7 & InsCode i <> 8 by ENUMSET1:def 1;
  per cases by A1,NAT_1:36,SCMFSA_2:16;
  suppose InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:95;
   hence thesis by COMPOS_1:11;
  end;
  suppose
    InsCode i = 1;
    then consider da,db being Int-Location such that
A2: i = da := db by SCMFSA_2:30;
   thus thesis by A2,COMPOS_1:11;
  end;
  suppose
    InsCode i = 2;
    then consider da,db being Int-Location such that
A3: i = AddTo(da, db) by SCMFSA_2:31;
    thus thesis by A3,COMPOS_1:11;
  end;
  suppose
    InsCode i = 3;
    then consider da,db being Int-Location such that
A4: i = SubFrom(da, db) by SCMFSA_2:32;
    thus thesis by A4,COMPOS_1:11;
  end;
  suppose
    InsCode i = 4;
    then consider da,db being Int-Location such that
A5: i = MultBy(da, db) by SCMFSA_2:33;
    thus thesis by A5,COMPOS_1:11;
  end;
  suppose
    InsCode i = 5;
    then consider da,db being Int-Location such that
A6: i = Divide(da, db) by SCMFSA_2:34;
    thus thesis by A6,COMPOS_1:11;
  end;
  suppose
    InsCode i = 9;
    then consider db,da being Int-Location, f being FinSeq-Location such that
A7: i = da :=(f, db) by SCMFSA_2:38;
    thus thesis by A7,COMPOS_1:11;
  end;
  suppose
    InsCode i = 10;
    then consider db,da being Int-Location, f being FinSeq-Location such that
A8: i = (f, db):=da by SCMFSA_2:39;
    thus thesis by A8,COMPOS_1:11;
  end;
  suppose
    InsCode i = 11;
    then consider da being Int-Location, f being FinSeq-Location such that
A9: i = da :=len f by SCMFSA_2:40;
    thus thesis by A9,COMPOS_1:11;
  end;
  suppose
    InsCode i = 12;
    then consider da being Int-Location, f being FinSeq-Location such that
A10: i = f:=<0,...,0>da by SCMFSA_2:41;
   thus thesis by A10,COMPOS_1:11;
  end;
 end;
