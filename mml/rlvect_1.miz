:: Vectors in Real Linear Space
::  by Wojciech A. Trybulec
::
:: Received July 24, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies BINOP_1, FUNCT_1, ARYTM_1, RELAT_1, FINSEQ_1, BOOLE, RLVECT_1,
      ANPROJ_1, FUNCOP_1, COMPLEX1, REALSET1, STRUCT_0, ARYTM, ALGSTR_0,
      VECTSP_2, MIDSP_1, FUNCT_3;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XCMPLX_0, XXREAL_0,
      RELAT_1, FUNCT_1, FUNCT_2, BINOP_1, FUNCOP_1, REAL_1, FINSEQ_1, NAT_1,
      FUNCT_3, FUNCT_5, STRUCT_0, ALGSTR_0;
 constructors BINOP_1, FUNCOP_1, XXREAL_0, REAL_1, NAT_1, FINSEQ_1, FUNCT_3,
      FUNCT_5, ALGSTR_0, REALSET1;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      STRUCT_0, REAL_1, ALGSTR_0, REALSET1, FINSEQ_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCT_1, TARSKI, STRUCT_0, RELAT_1, ALGSTR_0;
 theorems FUNCT_1, NAT_1, REAL_1, TARSKI, RELAT_1, STRUCT_0, XBOOLE_0,
      XBOOLE_1, FINSEQ_1, XCMPLX_0, FUNCOP_1, XREAL_1, XXREAL_0, ORDINAL1,
      ALGSTR_0, CARD_1, CARD_2;
 schemes FINSEQ_1, FUNCT_2, NAT_1;

begin

definition
  struct (addLoopStr) RLSStruct (# carrier -> set,
    ZeroF -> Element of the carrier, addF -> BinOp of the carrier,
    Mult -> Function of [:REAL, the carrier:], the carrier #);
end;

registration
  cluster non empty RLSStruct;
  existence
  proof
    consider ZS being non empty set, O being Element of ZS,
    F being BinOp of ZS, G being Function of [:REAL,ZS:],ZS;
    take RLSStruct(#ZS,O,F,G#);
    thus the carrier of RLSStruct(#ZS,O,F,G#) is non empty;
  end;
end;

reserve V for non empty RLSStruct;
reserve x,y,y1,y2 for set;

definition
  let V be RLSStruct;
  mode VECTOR of V is Element of V;
end;

canceled 2;

theorem
  for V being non empty 1-sorted, v being Element of V
  holds v in V by STRUCT_0:def 5;

::
::   Definitons of functions on the Elements of the carrier of
::   Real Linear Space structure, i.e. zero element, addition of two
::   elements, and multiplication of the element by a real number.
::

reserve v for VECTOR of V;
reserve a,b for Real;

definition
  let V;
  let v;
  let a;
  canceled 3;
  func a * v -> Element of V equals

  (the Mult of V).(a,v);
  coherence;
end;

::
::   Definitional theorems of zero element, addition, multiplication.
::

canceled;

theorem
  for V being non empty addLoopStr, v,w being Element of V
  holds v + w = (the addF of V).(v,w);

registration
  let ZS be non empty set, O be Element of ZS,
  F be BinOp of ZS, G be Function of [:REAL,ZS:],ZS;
  cluster RLSStruct (# ZS,O,F,G #) -> non empty;
  coherence by STRUCT_0:def 1;
end;

definition
  let IT be addLoopStr;
  attr IT is Abelian means
  :Def5:
  for v,w being Element of IT holds v + w = w + v;
  attr IT is add-associative means
  :Def6:
  for u,v,w being Element of IT
  holds (u + v) + w = u + (v + w);
  attr IT is right_zeroed means
  :Def7:
  for v being Element of IT holds v + 0.IT = v;
end;

definition
  let IT be non empty RLSStruct;
  canceled;
  attr IT is RealLinearSpace-like means
  :Def9:
  (for a for v,w being VECTOR of IT holds a * (v + w) = a * v + a * w) &
  (for a,b for v being VECTOR of IT holds (a + b) * v = a * v + b * v) &
  (for a,b for v being VECTOR of IT holds (a * b) * v = a * (b * v)) &
  (for v being VECTOR of IT holds 1 * v = v);
end;

definition
  func Trivial-RLSStruct -> strict RLSStruct equals
  RLSStruct(#1,op0,op2,pr2(REAL,1)#);
  coherence;
end;

registration
  cluster Trivial-RLSStruct -> trivial non empty;
  coherence by CARD_1:87,STRUCT_0:def 9;
end;

registration
  cluster strict Abelian add-associative right_zeroed right_complementable
    (non empty addLoopStr);
  existence
  proof
    take S = Trivial-addLoopStr;
    thus S is strict;
    thus S is Abelian
    proof
      let x be Element of S;
      thus thesis by STRUCT_0:def 10;
    end;
    thus S is add-associative
    proof
      let x be Element of S;
      thus thesis by STRUCT_0:def 10;
    end;
    thus S is right_zeroed
    proof
      let x be Element of S;
      thus thesis by STRUCT_0:def 10;
    end;
    thus thesis;
  end;
end;

registration
  cluster strict Abelian add-associative right_zeroed
    right_complementable RealLinearSpace-like (non empty RLSStruct);
  existence
  proof
    take S = Trivial-RLSStruct;
    thus S is strict;
    thus S is Abelian
    proof
      let x be Element of S;
      thus thesis by STRUCT_0:def 10;
    end;
    thus S is add-associative
    proof
      let x be Element of S;
      thus thesis by STRUCT_0:def 10;
    end;
    thus S is right_zeroed
    proof
      let x be Element of S;
      thus thesis by STRUCT_0:def 10;
    end;
    thus S is right_complementable
    proof
      let x be Element of S;
      take x;
      thus thesis by STRUCT_0:def 10;
    end;
    thus for a for v,w being VECTOR of S holds a * (v + w) = a * v + a * w
    by STRUCT_0:def 10;
    thus for a,b for v being VECTOR of S holds (a + b) * v = a * v + b * v
    by STRUCT_0:def 10;
    thus for a,b for v being VECTOR of S holds (a * b) * v = a * (b * v)
    by STRUCT_0:def 10;
    thus for v being VECTOR of S holds 1 * v = v by STRUCT_0:def 10;
  end;
end;

definition
  mode RealLinearSpace is Abelian add-associative right_zeroed
    right_complementable RealLinearSpace-like (non empty RLSStruct);
end;

definition
  let V be Abelian (non empty addLoopStr), v,w be Element of V;
  redefine func v + w;
  commutativity by Def5;
end;

canceled 2;

::  Axioms of real linear space.

reserve V for RealLinearSpace;
reserve v,w for VECTOR of V;

Lm1: for V being
add-associative right_zeroed right_complementable (non empty addLoopStr),
v,w being Element of V st v + w = 0.V holds w + v = 0.V
proof
  let V be
  add-associative right_zeroed right_complementable (non empty addLoopStr),
  v,w be Element of V;
  assume
A1: v + w = 0.V;
  consider u being Element of V such that
A2: w + u = 0.V by ALGSTR_0:def 11;
  w + v = w + (v + (w + u)) by A2,Def7
    .= w + (v + w + u) by Def6
    .= w + (v + w) + u by Def6
    .= w + u by A1,Def7;
  hence thesis by A2;
end;

canceled;

theorem Th9:
  for V being add-associative right_zeroed right_complementable addLoopStr
  holds V is right_add-cancelable
proof
  let V being add-associative right_zeroed right_complementable addLoopStr;
  let v being Element of V;
  consider v1 being Element of V such that
A1: v + v1 = 0.V by ALGSTR_0:def 11;
  let u, w be Element of V;
  assume
A2: u + v = w + v;
  thus u = u + 0.V by Def7
    .= u + v + v1 by A1,Def6
    .= w + 0.V by A1,A2,Def6
    .= w by Def7;
end;

theorem Th10:
  for V being add-associative
  right_zeroed right_complementable (non empty addLoopStr),
  v being Element of V holds v + 0.V = v & 0.V + v = v
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr), v be Element of V; thus
A1: v + 0.V = v by Def7;
  consider w being Element of V such that
A2: v + w = 0.V by ALGSTR_0:def 11;
  w + v = 0.V by A2,Lm1;
  hence 0.V + v = v by A1,A2,Def6;
end;

::
::  Definitions of reverse element to the vector and of
::  subtraction of vectors.
::

definition
  let V be non empty addLoopStr;
  let v be Element of V;
  assume
A1: V is add-associative right_zeroed right_complementable;
  then
A2: v is right_complementable by ALGSTR_0:def 16;
  redefine func - v means
  :Def11:
  v + it = 0.V;
  compatibility
  proof
    let IT be Element of V;
    consider v1 being Element of V such that
A3: v + v1 = 0.V by A2,ALGSTR_0:def 11;
A4: V is right_add-cancelable by A1,Th9;
    then
A5: v is right_add-cancelable by ALGSTR_0:def 7;
A6: v1 is right_add-cancelable by A4,ALGSTR_0:def 7;
A7: v is left_complementable
    proof
      take v1;
      v1 + v + v1 = v1 + 0.V by A1,A3,Def6
        .= v1 by A1,Th10
        .= 0.V + v1 by A1,Th10;
      hence thesis by A6,ALGSTR_0:def 4;
    end;
    v + -v + v = v + (-v + v) by A1,Def6
      .= v + 0.V by A5,A7,ALGSTR_0:def 13
      .= v by A1,Th10
      .= 0.V + v by A1,Th10;
    hence IT = -v implies v + IT = 0.V by A5,ALGSTR_0:def 4;
    assume
A8: v + IT = 0.V;
    thus IT = 0.V + IT by A1,Th10
      .= -v + v + IT by A5,A7,ALGSTR_0:def 13
      .= -v + 0.V by A1,A8,Def6
      .= -v by A1,Th10;
  end;
end;

Lm2: for V being add-associative right_zeroed
right_complementable (non empty addLoopStr), v,u being Element of V
ex w being Element of V st v + w = u
proof
  let V be add-associative
  right_zeroed right_complementable (non empty addLoopStr);
  let v,u be Element of V;
  take w = (- v) + u;
  thus v + w = (v + (- v)) + u by Def6
    .= 0.V + u by Def11
    .= u by Th10;
end;

definition
  let V be addLoopStr;
  let v,w be Element of V;
  redefine func v - w -> Element of V equals
  v + (- w);
  correctness;
end;

::
::  Definitional theorems of reverse element and substraction.
::

canceled 5;

theorem Th16:
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v being Element of V
  holds v + -v = 0.V & -v + v = 0.V
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr), v be Element of V;
  thus v + -v = 0.V by Def11;
  hence -v + v = 0.V by Lm1;
end;

canceled 2;

theorem Th19:
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,w being Element of V
  holds v + w = 0.V implies v = - w
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr);
  let v,w be Element of V;
  assume v + w = 0.V;
  then w + v = 0.V by Lm1;
  hence thesis by Def11;
end;

theorem
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,u being Element of V
  ex w being Element of V st v + w = u by Lm2;

theorem Th21:
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), w,u,v1,v2 being Element of V
  st w + v1 = w + v2 or v1 + w = v2 + w holds v1 = v2
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr);
  let w,u,v1,v2 be Element of V;
A1: now
    assume that
A2: w + v1 = w + v2;
    thus v1 = 0.V + v1 by Th10
      .= -w + w + v1 by Th16
      .= -w + (w + v1) by Def6
      .= -w + w + v2 by A2,Def6
      .= 0.V + v2 by Th16
      .= v2 by Th10;
  end;
  now
    assume that
A3: v1 + w = v2 + w;
    thus v1 = v1 + 0.V by Th10
      .= v1 + (w + -w) by Th16
      .= v1 + w + -w by Def6
      .= v2 + (w + -w) by A3,Def6
      .= v2 + 0.V by Th16
      .= v2 by Th10;
  end;
  hence thesis by A1;
end;

theorem
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,w being Element of V
  holds v + w = v or w + v = v implies w = 0.V
proof
  let V be add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,w be Element of V;
  assume v + w = v or w + v = v;
  then v + w = v + 0.V or w + v = 0.V + v by Th10;
  hence thesis by Th21;
end;

theorem Th23:
  a = 0 or v = 0.V implies a * v = 0.V
proof
  assume
A1: a = 0 or v = 0.V;
  now per cases by A1;
    suppose
A2:   a = 0;
      v + 0 * v = 1 * v + 0 * v by Def9
        .= (1 + 0) * v by Def9
        .= v by Def9
        .= v + 0.V by Th10;
      hence a * v = 0.V by A2,Th21;
    end;
    suppose
A3:   v = 0.V;
      a * 0.V + a * 0.V = a * (0.V + 0.V) by Def9
        .= a * 0.V by Th10
        .= a * 0.V + 0.V by Th10;
      hence a * v = 0.V by A3,Th21;
    end;
  end;
  hence thesis;
end;

theorem Th24:
  a * v = 0.V implies a = 0 or v = 0.V
proof
  assume that
A1: a * v = 0.V and
A2: a <> 0;
  thus v = 1 * v by Def9
    .= (a" * a) * v by A2,XCMPLX_0:def 7
    .= a" * 0.V by A1,Def9
    .= 0.V by Th23;
end;

theorem Th25:
  for V being add-associative
  right_zeroed right_complementable (non empty addLoopStr) holds - 0.V = 0.V
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr);
  thus 0.V = 0.V + (- 0.V) by Def11
    .= - 0.V by Th10;
end;

theorem
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v being Element of V
  holds v - 0.V = v
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr);
  let v be Element of V;
  thus v - 0.V = v + 0.V by Th25
    .= v by Th10;
end;

theorem
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v being Element of V
  holds 0.V - v = - v by Th10;

theorem
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v being Element of V
  holds v - v = 0.V by Def11;

theorem Th29:
  - v = (- 1) * v
proof v + (- 1) * v = 1 * v + (- 1) * v by Def9
    .= (1 + (- 1)) * v by Def9
    .= 0.V by Th23;
  hence (- v) = (- v) + (v + (- 1) * v) by Th10
    .= ((- v) + v) + (- 1) * v by Def6
    .= 0.V + (- 1) * v by Def11
    .= (- 1) * v by Th10;
end;

theorem Th30:
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v being Element of V
  holds - (- v) = v
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr);
  let v be Element of V;
  v + -v = 0.V by Def11;
  hence thesis by Th19;
end;

theorem Th31:
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,w being Element of V
  holds - v = - w implies v = w
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr);
  let v,w be Element of V;
  assume - v = - w;
  hence v = - (- w) by Th30
    .= w by Th30;
end;

canceled;

theorem Th33:
  v = - v implies v = 0.V
proof
  assume v = - v;
  then 0.V = v + v by Def11
    .= 1 * v + v by Def9
    .= 1 * v + 1 * v by Def9
    .= (1 + 1) * v by Def9
    .= 2 * v;
  hence thesis by Th24;
end;

theorem
  v + v = 0.V implies v = 0.V
proof
  assume v + v = 0.V;
  then v = - v by Def11;
  hence thesis by Th33;
end;

theorem Th35:
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,w being Element of V
  holds v - w = 0.V implies v = w
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr);
  let v,w be Element of V;
  assume v - w = 0.V;
  then - v = - w by Def11;
  hence thesis by Th31;
end;

theorem
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), u,v being Element of V
  ex w being Element of V st v - w = u
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr);
  let u,v be Element of V;
  consider w being Element of V such that
A1: v + w = u by Lm2;
  take z = - w;
  thus v - z = u by A1,Th30;
end;

theorem
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), w,v1,v2 being Element of V
  st w - v1 = w - v2 holds v1 = v2
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr);
  let w,v1,v2 be Element of V;
  assume w - v1 = w - v2;
  then - v1 = - v2 by Th21;
  hence thesis by Th31;
end;

theorem Th38:
  a * (- v) = (- a) * v
proof
  thus a * (- v) = a * ((- 1) * v) by Th29
    .= (a *(- 1)) * v by Def9
    .= (- a) * v;
end;

theorem Th39:
  a * (- v) = - (a * v)
proof
  thus a * (- v) = (- (1 * a)) * v by Th38
    .= ((- 1) * a) * v
    .= (- 1) * (a * v) by Def9
    .= - (a * v) by Th29;
end;

theorem
  (- a) * (- v) = a * v
proof
  thus (- a) * (- v) = (- (- a)) * v by Th38
    .= a * v;
end;

Lm3: for V being add-associative right_zeroed
right_complementable (non empty addLoopStr), u,w being Element of V
holds - (u + w) = -w + -u
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr), u,w be Element of V;
  u + w + (-w + -u) = u + (w + (-w + -u)) by Def6
    .= u + (w + -w + -u) by Def6
    .= u + (0.V + -u) by Def11
    .= u + -u by Th10
    .= 0.V by Def11;
  hence -(u + w) = -w + -u by Def11;
end;

theorem Th41:
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,u,w being Element of V
  holds v - (u + w) = (v - w) - u
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr);
  let v,u,w be Element of V;
  thus v - (u + w) = v + (-w + -u) by Lm3
    .= (v - w) - u by Def6;
end;

theorem
  for V being add-associative (non empty addLoopStr), v,u,w being Element of V
  holds (v + u) - w = v + (u - w) by Def6;

theorem
  for V being Abelian add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,u,w being Element of V
  holds v - (u - w) = (v -u) + w
proof
  let V be Abelian add-associative right_zeroed
  right_complementable (non empty addLoopStr);
  let v,u,w be Element of V;
  thus v - (u - w) = v - (u + - w)
    .= (v - u) - - w by Th41
    .= (v - u) + w by Th30;
end;

theorem Th44:
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,w being Element of V
  holds - (v + w) = (- w) - v
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr);
  let v,w be Element of V;
  thus - (v + w) = 0.V - (v + w) by Th10
    .= (0.V - w) - v by Th41
    .= (- w) - v by Th10;
end;

theorem
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,w being Element of V
  holds - (v + w) = -w + -v by Lm3;

theorem
  for V being Abelian add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,w being Element of V
  holds (- v) - w = (- w) - v
proof
  let V be Abelian add-associative right_zeroed
  right_complementable (non empty addLoopStr);
  let v,w be Element of V;
  thus (- v) - w = - (w + v) by Th44
    .= (- w) - v by Th44;
end;

theorem
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,w being Element of V
  holds - (v - w) = w + (- v)
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr);
  let v,w be Element of V;
  thus - (v - w) = --w + -v by Lm3
    .= w + -v by Th30;
end;

theorem Th48:
  a * (v - w) = a * v - a * w
proof
  thus a * (v - w) = a * v + a * (- w) by Def9
    .= a * v - a * w by Th39;
end;

theorem Th49:
  (a - b) * v = a * v - b * v
proof
  thus (a - b) * v = (a + (- b)) * v
    .= a * v + (- b) * v by Def9
    .= a * v + b * (- v) by Th38
    .= a * v - b * v by Th39;
end;

theorem
  a <> 0 & a * v = a * w implies v = w
proof
  assume that
A1: a <> 0 and
A2: a * v = a * w;
  0.V = a * v - a * w by A2,Def11
    .= a * (v - w) by Th48;
  then v - w = 0.V by A1,Th24;
  hence thesis by Th35;
end;

theorem
  v <> 0.V & a * v = b * v implies a = b
proof
  assume that
A1: v <> 0.V and
A2: a * v = b * v;
  0.V = a * v - b * v by A2,Def11
    .= (a - b) * v by Th49;
  then (- b) + a = 0 by A1,Th24;
  hence thesis;
end;

::
::  Definition of the sum of the finite sequence of vectors.
::

definition
  let V be non empty 1-sorted;
  let v,u be Element of V;
  redefine func <* v,u *> -> FinSequence of the carrier of V;
  coherence
  proof
    <* v,u *> = <* v *> ^ <* u *> by FINSEQ_1:def 9;
    hence thesis;
  end;
end;

definition
  let V be non empty 1-sorted;
  let v,u,w be Element of V;
  redefine func <* v,u,w *> -> FinSequence of the carrier of V;
  coherence
  proof
    <* v,u,w *> = <* v,u *> ^ <* w *> by FINSEQ_1:60;
    hence thesis;
  end;
end;

reserve V for non empty addLoopStr;
reserve F,G,H for FinSequence of the carrier of V;
reserve f,f',g for Function of NAT, the carrier of V;
reserve v,u for Element of V;
reserve j,k,n for Element of NAT;

definition
  let V;
  let F;
  func Sum(F) -> Element of V means
  :Def13:
  ex f st it = f.(len F) &
  f.0 = 0.V & for j,v st j < len F & v = F.(j + 1) holds f.(j + 1) = f.j + v;
  existence
  proof
    defpred P[set] means for F st len F = $1 ex u st
    ex f st u = f.(len F) & f.0 = 0.V &
    for j,v st j < len F & v = F.(j + 1) holds f.(j + 1) = f.j + v;
A1: P[0]
    proof
      now
        let F;
        assume
A2:     len F = 0;
        reconsider f = NAT --> 0.V as Function of NAT, the carrier of V;
        take u = f.(len F);
        take f' = f;
        thus u = f'.(len F) & f'.0 = 0.V by FUNCOP_1:13;
        let j;
        thus for v st j < len F & v = F.(j + 1) holds f'.(j + 1) = f'.j + v
        by A2;
      end;
      hence thesis;
    end;
A3: for n be Element of NAT st P[n] holds P[n+1]
    proof
      now
        let n;
        assume
A4:     for F st len F = n ex u st ex f st u = f.(len F) & f.0 = 0.V &
        for j,v st j < len F & v = F.(j + 1) holds f.(j + 1) = f.j + v;
        let F;
        assume
A5:     len F = n + 1;
        reconsider G = F | Seg(n) as FinSequence of the carrier of V
        by FINSEQ_1:23;
A6:     n < n + 1 by NAT_1:13;
        then
A7:     len G = n by A5,FINSEQ_1:21;
        then consider u,f such that u = f.(len G) and
A8:     f.0 = 0.V and
A9:     for j,v st j < len G & v = G.(j + 1) holds f.(j + 1) = f.j + v by A4;
        dom F = Seg(n + 1) by A5,FINSEQ_1:def 3;
        then n + 1 in dom F by FINSEQ_1:6;
        then F.(n + 1) in rng F & rng F c= the carrier of V
        by FINSEQ_1:def 4,FUNCT_1:def 5;
        then reconsider u1 = F.(n + 1) as Element of V;
        defpred P[set,set] means for j st $1 = j holds
        (j < n + 1 implies $2 = f.$1) &
        (n + 1 <= j implies for u st u = F.(n + 1) holds $2 = f.(len G) + u);
A10:    for k being Element of NAT qua non empty set
        ex v being Element of V st P[k,v]
        proof
          let k be Element of NAT qua non empty set;
          reconsider i = k as Element of NAT;
A11:      now
            assume
A12:        i < n + 1;
            take v = f.k;
            let j such that
A13:        k = j;
            thus j < n + 1 implies v = f.k;
            thus n + 1 <= j implies for u st u = F.(n + 1) holds
            v = f.(len G) + u by A12,A13;
          end;
          now
            assume
A14:        n + 1 <= i;
            take v = f.(len G) + u1;
            let j;
            assume k = j;
            hence j < n + 1 implies v = f.k by A14;
            assume n + 1 <= j;
            let u2 be Element of V;
            assume u2 = F.(n + 1);
            hence v = f.(len G) + u2;
          end;
          hence thesis by A11;
        end;
        consider f' being Function of NAT qua non empty set, the carrier of V
        such that
A15:    for k being Element of NAT qua non empty set holds
        P[k,f'.k] from FUNCT_2:sch 3(A10);
        take z = f'.(n + 1);
        take f'' = f';
        thus z = f''.(len F) by A5;
        thus f''.0 = 0.V by A8,A15;
        let j,v;
        assume that
A16:    j < len F and
A17:    v = F.(j + 1);
A18:    now
          assume
A19:      j < n;
          then
A20:      j <= n & 1 <= 1 + j by NAT_1:11;
          1 <= j + 1 & j + 1 <= n + 1 by A19,NAT_1:11,XREAL_1:9;
          then j + 1 in Seg(n + 1) & j + 1 <= n by A19,FINSEQ_1:3,NAT_1:13;
          then j + 1 in dom F & j + 1 in Seg n by A5,A20,FINSEQ_1:3,def 3;
          then v = G.(j + 1) & j < len G by A5,A6,A17,A19,FINSEQ_1:21
          ,FUNCT_1:72;
          then f.(j + 1) = f.j + v & j < n + 1 by A9,A19,NAT_1:13;
          then f.(j + 1) = f'.j + v & j + 1 < n + 1 by A15,A19,XREAL_1:8;
          hence f''.(j + 1) = f''.j + v by A15;
        end;
A21:    now
          assume
A22:      j = n;
          then f''.(j + 1) = f.j + v by A7,A15,A17;
          hence f''.(j + 1) = f''.j + v by A6,A15,A22;
        end;
        j <= n by A5,A16,NAT_1:13;
        hence f''.(j + 1) = f''.j + v by A18,A21,REAL_1:def 5;
      end;
      hence thesis;
    end;
    for n holds P[n] from NAT_1:sch 1(A1,A3);
    then consider u such that
A23: ex f st u = f.(len F) & f.0 = 0.V &
    for j,v st j < len F & v = F.(j + 1) holds f.(j + 1) = f.j + v;
    thus thesis by A23;
  end;
  uniqueness
  proof
    let v1,v2 be Element of V;
    given f such that
A24: v1 = f.(len F) and
A25: f.0 = 0.V and
A26: for j,v st j < len F & v = F.(j + 1) holds f.(j + 1) = f.j + v;
    given f' such that
A27: v2 = f'.(len F) and
A28: f'.0 = 0.V and
A29: for j,v st j < len F & v = F.(j + 1) holds f'.(j + 1) = f'.j + v;
    defpred P[Element of NAT] means $1 <= len F implies f.$1 = f'.$1;
A30: P[0] by A25,A28;
A31: for k st P[k] holds P[k+1]
    proof
      now
        let k;
        assume
A32:    k <= len F implies f.k = f'.k;
        assume
A33:    k + 1 <= len F;
        1 <= k + 1 & dom F = Seg(len F) by FINSEQ_1:def 3,NAT_1:11;
        then k + 1 in dom F by A33,FINSEQ_1:3;
        then F.(k + 1) in rng F & rng F c= the carrier of V
        by FINSEQ_1:def 4,FUNCT_1:def 5;
        then reconsider u1 = F.(k + 1) as Element of V;
        k < len F by A33,NAT_1:13;
        then f.(k + 1) = f.k + u1 & f'.(k + 1) = f'.k + u1 & k <= len F
        by A26,A29;
        hence f.(k + 1) = f'.(k + 1) by A32;
      end;
      hence thesis;
    end;
    for k holds P[k] from NAT_1:sch 1(A30,A31);
    hence v1 = v2 by A24,A27;
  end;
end;

Lm4: Sum(<*>(the carrier of V)) = 0.V
proof
  set S = <*>(the carrier of V);
  ex f st Sum(S) = f.(len S) & f.0 = 0.V &
  for j,v st j < len S & v = S.(j + 1) holds f.(j + 1) = f.j + v by Def13;
  hence thesis by CARD_1:47;
end;

Lm5: len F = 0 implies Sum(F) = 0.V
proof
  assume len F = 0;
  then F = <*>(the carrier of V) by FINSEQ_1:32;
  hence thesis by Lm4;
end;

canceled 2;

theorem Th54:
  k in Seg n & len F = n implies F.k is Element of V
proof
  assume k in Seg n & len F = n;
  then k in dom F by FINSEQ_1:def 3;

then F.k in rng F & rng F c= the carrier of V by FINSEQ_1:def 4,FUNCT_1:def 5;
  hence thesis;
end;

theorem Th55:
  len F = len G + 1 & G = F | (dom G) & v = F.(len F) implies
  Sum(F) = Sum(G) + v
proof
  assume that
A1: len F = len G + 1 and
A2: G = F | (dom G) and
A3: v = F.(len F);
  consider f such that
A4: Sum(F) = f.(len F) and
A5: f.0 = 0.V and
A6: for j,v st j < len F & v = F.(j + 1) holds f.(j + 1) = f.j + v by Def13;
  consider g such that
A7: Sum(G) = g.(len G) and
A8: g.0 = 0.V and
A9: for j,v st j < len G & v = G.(j + 1) holds g.(j + 1) = g.j + v by Def13;
  defpred P[Element of NAT] means for H holds len H = $1 & H = F | (Seg $1)
  & len H <= len G implies f.(len H) = g.(len H);
A10: P[0] by A5,A8;
A11: for k st P[k] holds P[k+1]
  proof
    now
      let k;
      assume
A12:  for H st len H = k & H = F | (Seg k) & len H <= len G holds
      f.(len H) = g.(len H);
      let H;
      assume that
A13:  len H = k + 1 and
A14:  H = F | (Seg (k + 1)) and
A15:  len H <= len G;
      reconsider p = H | (Seg k) as FinSequence of the carrier of V
      by FINSEQ_1:23;
      1 <= k + 1 & k + 1 <= len F by A1,A13,A15,NAT_1:12;
      then k + 1 in Seg(len F) by FINSEQ_1:3;
      then reconsider v = F.(k + 1) as Element of V by Th54;
A16:  k <= len H by A13,NAT_1:12;
      then
A17:  len p = k by FINSEQ_1:21;
      Seg k c= Seg(k + 1) by A13,A16,FINSEQ_1:7;
      then
A18:  p = F | (Seg k) by A14,FUNCT_1:82;
      k <= len G & len G < len F by A1,A15,A16,XREAL_1:31,XXREAL_0:2;
      then
A19:  k < len F by XXREAL_0:2;
      1 <= k + 1 & k + 1 <= len G by A13,A15,NAT_1:12;
      then k + 1 in Seg(len G) by FINSEQ_1:3;
      then k + 1 in dom G by FINSEQ_1:def 3;
      then
A20:  v = G.(k + 1) by A2,FUNCT_1:70;
      k < k + 1 by XREAL_1:31;
      then k < len G by A13,A15,XXREAL_0:2;
      then f.(k + 1) = f.k + v & g.(k + 1) = g.k + v by A6,A9,A19,A20;
      hence f.(len H) = g.(len H) by A12,A13,A15,A16,A17,A18,XXREAL_0:2;
    end;
    hence thesis;
  end;
A21: dom G = Seg len G by FINSEQ_1:def 3;
  for k holds P[k] from NAT_1:sch 1(A10,A11);
  then f.(len G) = g.(len G) by A2,A21;
  hence thesis by A1,A3,A4,A6,A7,XREAL_1:31;
end;

reserve V for RealLinearSpace;
reserve v for VECTOR of V;
reserve F,G,H,I for FinSequence of the carrier of V;

theorem
  len F = len G & (for k,v st k in dom F & v = G.k holds F.k = a * v) implies
  Sum(F) = a * Sum(G)
proof
  defpred P[set] means for H,I st len H = len I & len H = $1 &
  (for k,v st k in Seg len H & v = I.k holds H.k = a * v) holds
  Sum(H) = a * Sum(I);
A1: P[0]
  proof
    now
      let H,I;
      assume that
A2:   len H = len I & len H = 0 and
      for k,v st k in Seg len H & v = I.k holds H.k = a * v;
      Sum(H) = 0.V & Sum(I) = 0.V by A2,Lm5;
      hence Sum(H) = a * Sum(I) by Th23;
    end;
    hence thesis;
  end;
A3: for n st P[n] holds P[n+1]
  proof
    now
      let n;
      assume
A4:   for H,I st len H = len I & len H = n &
      for k,v st k in Seg len H & v = I.k holds H.k = a * v holds
      Sum(H) = a * Sum(I);
      let H,I;
      assume that
A5:   len H = len I and
A6:   len H = n + 1 and
A7:   for k,v st k in Seg len H & v = I.k holds H.k = a * v;
      reconsider p = H | (Seg n),q = I | (Seg n)
      as FinSequence of the carrier of V by FINSEQ_1:23;
A8:   n <= n + 1 by NAT_1:12;
      then
A9:   len p = n & len q = n by A5,A6,FINSEQ_1:21;
A10:  now
        let k,v;
        assume that
A11:    k in Seg len p and
A12:    v = q.k;
        len p <= len H by A6,A8,FINSEQ_1:21;
        then
A13:    Seg len p c= Seg len H by FINSEQ_1:7;
        dom q = Seg n by A5,A6,A8,FINSEQ_1:21;
        then I.k = q.k by A9,A11,FUNCT_1:70;
        then
A14:    H.k = a * v by A7,A11,A12,A13;
        dom p = Seg n by A6,A8,FINSEQ_1:21;
        hence p.k = a * v by A9,A11,A14,FUNCT_1:70;
      end;
      n + 1 in Seg(n + 1) by FINSEQ_1:6;
      then reconsider v1 = H.(n + 1),v2 = I.(n + 1) as VECTOR of V
      by A5,A6,Th54;
A15:  v1 = a * v2 by A6,A7,FINSEQ_1:6;
A16:  dom q = Seg len q by FINSEQ_1:def 3;
      dom p = Seg len p by FINSEQ_1:def 3;
      hence Sum(H) = Sum(p) + v1 by A6,A9,Th55
        .= a * Sum(q) + a * v2 by A4,A9,A10,A15
        .= a * (Sum(q) + v2) by Def9
        .= a * Sum(I) by A5,A6,A9,A16,Th55;
    end;
    hence thesis;
  end;
A17: dom F = Seg len F by FINSEQ_1:def 3;
  for n holds P[n] from NAT_1:sch 1(A1,A3);
  hence thesis by A17;
end;

theorem
  for V being Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), F,G being FinSequence of the carrier of V st
  len F = len G & (for k for v being Element of V
  st k in dom F & v = G.k holds F.k = - v) holds Sum(F) = - Sum(G)
proof
  let V be Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), F,G be FinSequence of the carrier of V;
  defpred P[set] means for H,I being FinSequence of the carrier of V
  st len H = len I & len H = $1 & (for k for v being Element of V
  st k in Seg len H & v = I.k holds H.k = - v) holds Sum(H) = - Sum(I);
A1: P[0]
  proof
    now
      let H,I be FinSequence of the carrier of V;
      assume that
A2:   len H = len I & len H = 0 and for k for v being Element of V
      st k in Seg len H & v = I.k holds H.k = - v;
      Sum(H) = 0.V & Sum(I) = 0.V by A2,Lm5;
      hence Sum(H) = - Sum(I) by Th25;
    end;
    hence thesis;
  end;
A3: for n st P[n] holds P[n+1]
  proof
    now
      let n;
      assume
A4:   for H,I being FinSequence of the carrier of V
      st len H = len I & len H = n & for k for v being Element of V
      st k in Seg len H & v = I.k holds H.k = - v holds Sum(H) = - Sum(I);
      let H,I be FinSequence of the carrier of V;
      assume that
A5:   len H = len I and
A6:   len H = n + 1 and
A7:   for k for v being Element of V
      st k in Seg(len H) & v = I.k holds H.k = - v;
      reconsider p = H | (Seg n),q = I | (Seg n)
      as FinSequence of the carrier of V by FINSEQ_1:23;
A8:   n <= n + 1 by NAT_1:12;
      then
A9:   len p = n & len q = n by A5,A6,FINSEQ_1:21;
A10:  now
        let k;
        let v be Element of V;
        assume that
A11:    k in Seg(len p) and
A12:    v = q.k;
        len p <= len H by A6,A8,FINSEQ_1:21;
        then
A13:    Seg(len p) c= Seg(len H) by FINSEQ_1:7;
        dom q = Seg n by A5,A6,A8,FINSEQ_1:21;
        then I.k = q.k by A9,A11,FUNCT_1:70;
        then
A14:    H.k = - v by A7,A11,A12,A13;
        dom p = Seg n by A6,A8,FINSEQ_1:21;
        hence p.k = - v by A9,A11,A14,FUNCT_1:70;
      end;
      n + 1 in Seg(n + 1) by FINSEQ_1:6;
      then reconsider v1 = H.(n + 1),v2 = I.(n + 1) as Element of V
      by A5,A6,Th54;
A15:  v1 = - v2 by A6,A7,FINSEQ_1:6;
A16:  dom q = Seg len q by FINSEQ_1:def 3;
      dom p = Seg len p by FINSEQ_1:def 3;
      hence Sum(H) = Sum(p) + v1 by A6,A9,Th55
        .= - Sum(q) + - v2 by A4,A9,A10,A15
        .= - (Sum(q) + v2) by Lm3
        .= - Sum(I) by A5,A6,A9,A16,Th55;
    end;
    hence thesis;
  end;
A17: dom F = Seg len F by FINSEQ_1:def 3;
  for n holds P[n] from NAT_1:sch 1(A1,A3);
  hence thesis by A17;
end;

theorem Th58:
  for V being add-associative right_zeroed (non empty addLoopStr),
  F,G being FinSequence of the carrier of V holds Sum(F ^ G) = Sum(F) + Sum(G)
proof
  let V be add-associative right_zeroed (non empty addLoopStr),
  F,G be FinSequence of the carrier of V;
  defpred P[set] means for G be FinSequence of the carrier of V st len G = $1
  holds Sum(F ^ G) = Sum(F) + Sum(G);
A1: P[0]
  proof
    let G be FinSequence of the carrier of V;
    assume len G = 0;
    then G = <*>(the carrier of V) & G = {} by CARD_2:59;
    then F ^ G = F & Sum(G) = 0.V by Lm4,FINSEQ_1:47;
    hence thesis by Def7;
  end;
A2: for k st P[k] holds P[k+1]
  proof
    let k;
    assume
A3: for G being FinSequence of the carrier of V st len G = k
    holds Sum(F ^ G) = Sum(F) + Sum(G);
    let H be FinSequence of the carrier of V;
    assume
A4: len H = k + 1;
    reconsider p = H | (Seg k) as FinSequence of the carrier of V
    by FINSEQ_1:23;
A5: dom H = Seg(k + 1) by A4,FINSEQ_1:def 3;
    then
A6: k + 1 in dom H by FINSEQ_1:6;
    then H.(k + 1) in rng H & rng H c= the carrier of V
    by FINSEQ_1:def 4,FUNCT_1:def 5;
    then reconsider v = H.(k + 1) as Element of V;
A7: k <= k + 1 by NAT_1:12;
    then
A8: len p = k by A4,FINSEQ_1:21;
    then
A9: dom H = Seg(len p + len<* v *>) by A5,FINSEQ_1:56;
    dom p = Seg k by A4,A7,FINSEQ_1:21;
    then
A10: dom p c= dom H by A5,A7,FINSEQ_1:7;
A11: now
      let n be Nat;
      assume n in dom p;
      then n in dom H & n in Seg k by A4,A7,A10,FINSEQ_1:21;
      hence p.n = H.n by FUNCT_1:72;
    end;
    now
      let n be Nat;
      assume n in dom<* v *>;
      then n in {1} by FINSEQ_1:4,55;
      then n = 1 by TARSKI:def 1;
      hence H.(len p + n) = <* v *>.n by A8,FINSEQ_1:def 8;
    end;
    then H = p ^ <* v *> by A9,A11,FINSEQ_1:def 7;
    then F ^ H = (F ^ p) ^ <* v *> by FINSEQ_1:45;
    then len(F ^ H) = len(F ^ p) + len<* v *> by FINSEQ_1:35;
    then
A12: len(F ^ H) = len(F ^ p) + 1 by FINSEQ_1:56;
A13: dom(F ^ p) = Seg len(F ^ p) by FINSEQ_1:def 3;
A14: dom(F ^ H) = Seg len(F ^ H) by FINSEQ_1:def 3
      .= Seg(len F + len H) by FINSEQ_1:35;
A15: Seg(len(F ^ p)) = Seg(len F + len p) by FINSEQ_1:35;
    len F + len p <= len F + len H by A4,A7,A8,XREAL_1:9;
    then Seg len(F ^ p) c= dom(F ^ H) by A14,A15,FINSEQ_1:7;
    then
A16: dom(F ^ p) = dom(F ^ H) /\ Seg(len(F ^ p)) by A13,XBOOLE_1:28;
    now
      let x be set;
      assume
A17:  x in dom(F ^ p);
      then reconsider n = x as Element of NAT;
A18:  now
        assume n in dom F;
        then (F ^ p).n = F.n & (F ^ H).n = F.n by FINSEQ_1:def 7;
        hence (F ^ p).x = (F ^ H).x;
      end;
      now
        assume not n in dom F;
        then
A19:    not n in Seg(len F) by FINSEQ_1:def 3;
A20:    1 <= n by A13,A17,FINSEQ_1:3;
        then len F <= n by A19,FINSEQ_1:3;
        then consider j being Nat such that
A21:    n = len F + j by NAT_1:10;
A22:    now
          assume not 1 <= j;
          then j = 0 by NAT_1:14;
          hence contradiction by A19,A20,A21,FINSEQ_1:3;
        end;
        now
          assume not j <= k;
          then len F + k < n & n <= len F + len p
          by A13,A15,A17,A21,FINSEQ_1:3,XREAL_1:8;
          hence contradiction by A4,A7,FINSEQ_1:21;
        end;
        then j in Seg k by A22,FINSEQ_1:3;
        then
A23:    j in dom p by A4,A7,FINSEQ_1:21;
        then (F ^ p).n = p.j & (F ^ H).n = H.j by A10,A21,FINSEQ_1:def 7;
        hence (F ^ p).x = (F ^ H).x by A11,A23;
      end;
      hence (F ^ p).x = (F ^ H).x by A18;
    end;
    then
A24: F ^ p = (F ^ H) | (Seg len (F ^ p)) by A16,FUNCT_1:68
      .= (F ^ H) | (dom (F ^ p)) by FINSEQ_1:def 3;
A25: dom p = Seg len p by FINSEQ_1:def 3;
    v = (F ^ H).(len F + len H) by A4,A6,FINSEQ_1:def 7
      .= (F ^ H).(len(F ^ H)) by FINSEQ_1:35;
    hence Sum(F ^ H) = Sum(F ^ p) + v by A12,A24,Th55
      .= (Sum(F) + Sum(p)) + v by A3,A8
      .= Sum(F) + (Sum(p) + v) by Def6
      .= Sum(F) + Sum(H) by A4,A8,A25,Th55;
  end;
  for k holds P[k] from NAT_1:sch 1(A1,A2);
  then len G = len G implies thesis;
  hence thesis;
end;

reserve V for add-associative right_zeroed
  right_complementable (non empty addLoopStr);

reserve F for FinSequence of the carrier of V;
reserve v,v1,v2,u,w for Element of V;
reserve j,k for Element of NAT;

Lm6: for V being add-associative right_zeroed
right_complementable (non empty addLoopStr), v being Element of V
holds Sum<* v *> = v
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr), v be Element of V;
  set S = <* v *>;
  consider f being Function of NAT, the carrier of V such that
A1: Sum(S) = f.(len S) and
A2: f.0 = 0.V and
A3: for j for v being Element of V st j < len S & v = S.(j + 1) holds
  f.(j + 1) = f.j + v by Def13;
A4: len S = 1 by FINSEQ_1:56;
  0 < 1;
  then consider j such that
A5: j < len S by A4;
A6: j = 0 by A4,A5,NAT_1:14;
  S.(j + 1) = S.(0 + 1) by A4,A5,NAT_1:14
    .= v by FINSEQ_1:57;
  then f.1 = 0.V + v by A2,A3,A5,A6
    .= v by Th10;
  hence thesis by A1,FINSEQ_1:56;
end;

theorem
  for V being Abelian add-associative right_zeroed (non empty addLoopStr),
  F,G being FinSequence of the carrier of V st
  rng F = rng G & F is one-to-one & G is one-to-one holds Sum(F) = Sum(G)
proof
  let V be Abelian add-associative right_zeroed (non empty addLoopStr),
  F,G be FinSequence of the carrier of V;
  defpred P[set] means for H,I being FinSequence of the carrier of V
  st len H = $1 & rng H = rng I &
  H is one-to-one & I is one-to-one holds Sum(H) = Sum (I);
A1: P[0]
  proof
    now
      let H,I be FinSequence of the carrier of V;
      assume that
A2:   len H = 0 and
A3:   rng H = rng I and H is one-to-one & I is one-to-one;
      H = {} by A2,CARD_2:59;
      then rng H = {} by RELAT_1:60;
      then I = {} by A3,RELAT_1:64;
      then len I = 0 by CARD_1:47;
      then Sum(H) = 0.V & Sum(I) = 0.V by A2,Lm5;
      hence Sum(H) = Sum(I);
    end;
    hence thesis;
  end;
A4: for k st P[k] holds P[k+1]
  proof
    now
      let k;
      assume
A5:   for H,I being FinSequence of the carrier of V
      st len H = k & rng H = rng I &
      H is one-to-one & I is one-to-one holds Sum(H) = Sum(I);
      let H,I be FinSequence of the carrier of V;
      assume that
A6:   len H = k + 1 and
A7:   rng H = rng I and
A8:   H is one-to-one and
A9:   I is one-to-one;
A10:  len H = len I by A7,A8,A9,FINSEQ_1:65;
      reconsider p = H | (Seg k) as FinSequence of the carrier of V
      by FINSEQ_1:23;
A11:  k + 1 in Seg(k + 1) by FINSEQ_1:6;
      then k + 1 in dom H by A6,FINSEQ_1:def 3;
      then H.(k + 1) in rng I by A7,FUNCT_1:def 5;
      then consider x such that
A12:  x in dom I and
A13:  H.(k + 1) = I.x by FUNCT_1:def 5;
A14:  x in Seg(k + 1) by A6,A10,A12,FINSEQ_1:def 3;
      reconsider n = x as Element of NAT by A12;
      reconsider v = H.(k + 1) as Element of V by A6,A11,Th54;
A15:  1 <= n by A14,FINSEQ_1:3;
      then consider m1 being Nat such that
A16:  1 + m1 = n by NAT_1:10;
A17:  n <= k + 1 by A14,FINSEQ_1:3;
      then consider m2 being Nat such that
A18:  n + m2 = k + 1 by NAT_1:10;
      reconsider m2 as Element of NAT by ORDINAL1:def 13;
      reconsider q1 = I | (Seg m1) as FinSequence of the carrier of V
      by FINSEQ_1:23;
      defpred P[Nat,set] means $2 = I.(n + $1);
A19:  for j be Nat,y1,y2 st j in Seg m2 & P[j,y1] & P[j,y2] holds y1 = y2;
A20:  for j be Nat st j in Seg m2 ex x st P[j,x];
      consider q2 being FinSequence such that
A21:  dom q2 = Seg m2 and
A22:  for k be Nat st k in Seg m2 holds P[k,q2.k] from FINSEQ_1:sch 1
      (A20);
      rng q2 c= the carrier of V
      proof
        let x;
        assume x in rng q2;
        then consider y such that
A23:    y in dom q2 and
A24:    x = q2.y by FUNCT_1:def 5;
        reconsider y as Element of NAT by A23;
        1 <= y & y <= n + y by A21,A23,FINSEQ_1:3,NAT_1:12;
        then
A25:    1 <= n + y by XXREAL_0:2;
        y <= m2 by A21,A23,FINSEQ_1:3;
        then n + y <= len I by A6,A10,A18,XREAL_1:9;
        then n + y in Seg(len I) by A25,FINSEQ_1:3;
        then reconsider xx = I.(n + y) as Element of V by Th54;
        xx in the carrier of V;
        hence thesis by A21,A22,A23,A24;
      end;
      then reconsider q2 as FinSequence of the carrier of V by FINSEQ_1:def 4;
      set q = q1 ^ q2;
      k <= k + 1 by NAT_1:12;
      then
A26:  len p = k by A6,FINSEQ_1:21;
      m1 <= n by A16,NAT_1:11;
      then
A27:  m1 <= k + 1 by A17,XXREAL_0:2;
      then
A28:  len q1 = m1 & len q2 = m2 by A6,A10,A21,FINSEQ_1:21,def 3;
      then len(q1 ^ <* v *>) + len q2 = len q1 + len<* v *> + m2
      by FINSEQ_1:35
        .= k + 1 by A16,A18,A28,FINSEQ_1:57;
      then
A29:  dom I = Seg(len(q1 ^ <* v *>) + len q2) by A6,A10,FINSEQ_1:def 3;
A30:  now
        let j be Nat;
        assume
A31:    j in dom(q1 ^ <* v *>);
        len(q1 ^ <* v *>) = m1 + len <* v *> by A28,FINSEQ_1:35
          .= m1 + 1 by FINSEQ_1:57;
        then j in Seg(m1 + 1) by A31,FINSEQ_1:def 3;
        then
A32:    j in Seg m1 \/ {n} by A16,FINSEQ_1:11;
A33:    now
          assume j in Seg m1;
          then
A34:      j in dom q1 by A6,A10,A27,FINSEQ_1:21;
          then q1.j = I.j by FUNCT_1:70;
          hence I.j = (q1 ^ <* v *>).j by A34,FINSEQ_1:def 7;
        end;
        now
          assume j in {n};
          then
A35:      j = n by TARSKI:def 1;
          1 in Seg 1 & len<* v *> = 1 by FINSEQ_1:3,56;
          then 1 in dom <* v *> by FINSEQ_1:def 3;
          then (q1 ^ <* v *>).(len q1 + 1) = <* v *>.1 by FINSEQ_1:def 7;
          hence (q1 ^ <* v *>).j = I.j by A13,A16,A28,A35,FINSEQ_1:57;
        end;
        hence I.j = (q1 ^ <* v *>).j by A32,A33,XBOOLE_0:def 2;
      end;
      now
        let j be Nat;
        assume
A36:    j in dom q2;
        len(q1 ^ <* v *>) = m1 + len<* v *> by A28,FINSEQ_1:35
          .= n by A16,FINSEQ_1:56;
        hence I.(len(q1 ^ <* v *>) + j) = q2.j by A21,A22,A36;
      end;
      then
A37:  I = q1 ^ <* v *> ^ q2 by A29,A30,FINSEQ_1:def 7;
      then
A38:  rng I = rng(q1 ^ <* v *>) \/ rng q2 by FINSEQ_1:44
        .= rng <* v *> \/ rng q1 \/ rng q2 by FINSEQ_1:44
        .= {v} \/ rng q1 \/ rng q2 by FINSEQ_1:56
        .= {v} \/ (rng q1 \/ rng q2) by XBOOLE_1:4
        .= {v} \/ rng q by FINSEQ_1:44;
A39:  m1 < n by A16,XREAL_1:31;
      {v} misses rng q
      proof
        assume not thesis;
        then
A40:    {v} /\ rng q <> {} by XBOOLE_0:def 7;
        consider y being Element of {v} /\ rng q;
        y in rng q by A40,XBOOLE_0:def 3;
        then
A41:    y in rng q1 \/ rng q2 by FINSEQ_1:44;
A42:    y in {v} by A40,XBOOLE_0:def 3;
        then
A43:    y = I.n by A13,TARSKI:def 1;
A44:    now
          assume y in rng q1;
          then consider y1 such that
A45:      y1 in dom q1 and
A46:      y = q1.y1 by FUNCT_1:def 5;
A47:      y1 in Seg m1 by A6,A10,A27,A45,FINSEQ_1:21;
          reconsider y1 as Element of NAT by A45;
A48:      q1.y1 = I.y1 by A45,FUNCT_1:70;
A49:      y1 <= m1 by A47,FINSEQ_1:3;
A50:      y1 <> n by A39,A47,FINSEQ_1:3;
          1 <= y1 & y1 <= k + 1 by A27,A47,A49,FINSEQ_1:3,XXREAL_0:2;
          then y1 in Seg(k + 1) by FINSEQ_1:3;
          then y1 in dom I & n in dom I & I.y1 = I.n
          by A6,A10,A12,A13,A42,A46,A48,FINSEQ_1:def 3,TARSKI:def 1;
          hence contradiction by A9,A50,FUNCT_1:def 8;
        end;
        now
          assume y in rng q2;
          then consider y1 such that
A51:      y1 in dom q2 and
A52:      y = q2.y1 by FUNCT_1:def 5;
          reconsider y1 as Element of NAT by A51;
A53:      I.n = I.(n + y1) by A21,A22,A43,A51,A52;
A54:      1 <= n + y1 by A15,NAT_1:12;
          y1 <= m2 by A21,A51,FINSEQ_1:3;
          then n + y1 <= k + 1 by A18,XREAL_1:9;
          then n + y1 in Seg(k + 1) by A54,FINSEQ_1:3;
          then n in dom I & n + y1 in dom I by A6,A10,A12,FINSEQ_1:def 3;
          then
A55:      n = n + y1 by A9,A53,FUNCT_1:def 8;
          y1 <> 0 by A21,A51,FINSEQ_1:3;
          hence contradiction by A55;
        end;
        hence thesis by A41,A44,XBOOLE_0:def 2;
      end;
      then
A56:  rng q = rng I \ {v} by A38,XBOOLE_1:88;
A57:  Seg k = Seg(k + 1) \ {k + 1} by FINSEQ_1:12;
A58:  rng p = H .: (Seg k) by RELAT_1:148;
A59:  Seg(k + 1) = dom H by A6,FINSEQ_1:def 3;
      then
A60:  rng H = H .: (Seg(k + 1)) by RELAT_1:146;
      H .: (Seg k) = H .: Seg(k + 1) \ Im(H,k + 1) by A8,A57,FUNCT_1:123;
      then
A61:  rng p = rng q by A7,A56,A58,A59,A60,FINSEQ_1:6,FUNCT_1:117;
A62:  p is one-to-one by A8,FUNCT_1:84;
A63:  q is one-to-one
      proof
        let y1,y2 be set;
        assume that
A64:    y1 in dom q and
A65:    y2 in dom q and
A66:    q.y1 = q.y2;
        reconsider x1 = y1, x2 = y2 as Element of NAT by A64,A65;
A67:    q1 is one-to-one by A9,FUNCT_1:84;
A68:    now
          assume
A69:      x1 in dom q1 & x2 in dom q1;
          then q1.x1 = q.x1 & q1.x2 = q.x2 by FINSEQ_1:def 7;
          hence y1=y2 by A66,A67,A69,FUNCT_1:def 8;
        end;
A70:    now
          assume
A71:      x1 in dom q1;
          given j be Nat such that
A72:      j in dom q2 and
A73:      x2 = len q1 + j;
          q1.x1 = I.x1 by A71,FUNCT_1:70;
          then
A74:      q.x1 = I.x1 by A71,FINSEQ_1:def 7;
          q2.j = I.(n + j) by A21,A22,A72;
          then
A75:      I.x1 = I.(n + j) by A66,A72,A73,A74,FINSEQ_1:def 7;
          x1 in Seg m1 by A6,A10,A27,A71,FINSEQ_1:21;
          then
A76:      1 <= x1 & x1 <= m1 by FINSEQ_1:3;
          then
A77:      x1 <= k + 1 by A27,XXREAL_0:2;
A78:      1 <= n + j by A15,NAT_1:12;
          j <= m2 by A21,A72,FINSEQ_1:3;
          then n + j <= k + 1 by A18,XREAL_1:9;
          then n + j in Seg(k + 1) & x1 in Seg(k + 1)
          by A76,A77,A78,FINSEQ_1:3;
          then
A79:      x1 in dom I & n + j in dom I by A6,A10,FINSEQ_1:def 3;
          x1 < n & n <= n + j by A39,A76,NAT_1:12,XXREAL_0:2;
          hence y1 = y2 by A9,A75,A79,FUNCT_1:def 8;
        end;
A80:    now
          assume
A81:      x2 in dom q1;
          given j be Nat such that
A82:      j in dom q2 and
A83:      x1 = len q1 + j;
          q1.x2 = I.x2 by A81,FUNCT_1:70;
          then
A84:      q.x2 = I.x2 by A81,FINSEQ_1:def 7;
          q2.j = I.(n + j) by A21,A22,A82;
          then
A85:      I.x2 = I.(n + j) by A66,A82,A83,A84,FINSEQ_1:def 7;
          x2 in Seg m1 by A6,A10,A27,A81,FINSEQ_1:21;
          then
A86:      1 <= x2 & x2 <= m1 by FINSEQ_1:3;
          then
A87:      x2 <= k + 1 by A27,XXREAL_0:2;
A88:      1 <= n + j by A15,NAT_1:12;
          j <= m2 by A21,A82,FINSEQ_1:3;
          then n + j <= k + 1 by A18,XREAL_1:9;
          then n + j in Seg(k + 1) & x2 in Seg(k + 1)
          by A86,A87,A88,FINSEQ_1:3;
          then
A89:      x2 in dom I & n + j in dom I by A6,A10,FINSEQ_1:def 3;
          x2 < n & n <= n + j by A39,A86,NAT_1:12,XXREAL_0:2;
          hence y1 = y2 by A9,A85,A89,FUNCT_1:def 8;
        end;
        now
          given j1 being Nat such that
A90:      j1 in dom q2 and
A91:      x1 = len q1 + j1;
          given j2 being Nat such that
A92:      j2 in dom q2 and
A93:      x2 = len q1 + j2;
A94:      q2.j1 = I.(n + j1) & q2.j2 = I.(n + j2) by A21,A22,A90,A92;
A95:      q2.j1 = q.(m1 + j2) by A28,A66,A90,A91,A93,FINSEQ_1:def 7
            .= q2.j2 by A28,A92,FINSEQ_1:def 7;
A96:      1 <= n + j1 & 1 <= n + j2 by A15,NAT_1:12;
          j1 <= m2 & j2 <= m2 by A21,A90,A92,FINSEQ_1:3;
          then n + j1 <= k + 1 & n + j2 <= k + 1 by A18,XREAL_1:9;
          then n + j1 in Seg(k + 1) & n + j2 in Seg(k + 1) by A96,FINSEQ_1:3;
          then n + j1 in dom I & n + j2 in dom I by A6,A10,FINSEQ_1:def 3;
          then n + j1 = n + j2 by A9,A94,A95,FUNCT_1:def 8;
          hence thesis by A91,A93;
        end;
        hence y1=y2 by A64,A65,A68,A70,A80,FINSEQ_1:38;
      end;
A97:  len<* v *> = 1 by FINSEQ_1:56;
A98:  for k be Nat st k in dom p holds H.k=p.k by FUNCT_1:70;
      now
        let k be Nat;
        assume k in dom<* v *>;
        then k in Seg 1 by FINSEQ_1:55;
        then k = 1 by FINSEQ_1:4,TARSKI:def 1;
        hence H.(len p + k) = <* v *>.k by A26,FINSEQ_1:57;
      end;
      then H = p ^ <* v *> by A26,A59,A97,A98,FINSEQ_1:def 7;
      then
A99:  Sum(H) = Sum(p) + Sum<* v *> by Th58;
      Sum(I) = Sum(q1 ^ <* v *>) + Sum(q2) by A37,Th58
        .= (Sum(q1) + Sum<* v *>) + Sum(q2) by Th58
        .= Sum<* v *> + (Sum(q1) + Sum(q2)) by Def6
        .= Sum(q) + Sum<* v *> by Th58;
      hence Sum(H) = Sum(I) by A5,A26,A61,A62,A63,A99;
    end;
    hence thesis;
  end;
A100: for k holds P[k] from NAT_1:sch 1(A1,A4);
  len F = len F;
  hence thesis by A100;
end;

theorem
  for V being non empty addLoopStr holds
  Sum(<*>(the carrier of V)) = 0.V by Lm4;

theorem
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v being Element of V
  holds Sum<* v *> = v by Lm6;

theorem Th62:
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,u being Element of V
  holds Sum<* v,u *> = v + u
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,u be Element of V;
  <* v,u *> = <* v *> ^ <* u *> by FINSEQ_1:def 9;
  hence Sum<* v,u *> = Sum<* v *> + Sum<* u *> by Th58
    .= v + Sum<* u *> by Lm6
    .= v + u by Lm6;
end;

theorem Th63:
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,u,w being Element of V
  holds Sum<* v,u,w *> = v + u + w
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,u,w be Element of V;
  <* v,u,w *> = <* v,u *> ^ <* w *> by FINSEQ_1:60;
  hence Sum<* v,u,w *> = Sum<* v,u *> + Sum<* w *> by Th58
    .= Sum<* v,u *> + w by Lm6
    .= v + u + w by Th62;
end;

theorem
  for V being RealLinearSpace, a being Real
  holds a * Sum(<*>(the carrier of V)) = 0.V by Th23,Lm4;

canceled;

theorem
  for V being RealLinearSpace, a being Real, v,u being VECTOR of V
  holds a * Sum<* v,u *> = a * v + a * u
proof
  let V be RealLinearSpace, a be Real, v,u be VECTOR of V;
  thus a * Sum<* v,u *> = a * (v + u) by Th62
    .= a * v + a * u by Def9;
end;

theorem
  for V being RealLinearSpace, a being Real, v,u,w being VECTOR of V
  holds a * Sum<* v,u,w *> = a * v + a * u + a * w
proof
  let V be RealLinearSpace, a be Real, v,u,w be VECTOR of V;
  thus a * Sum<* v,u,w *> = a * (v + u + w) by Th63
    .= a * (v + u) + a * w by Def9
    .= a * v + a * u + a * w by Def9;
end;

theorem
  - Sum(<*>(the carrier of V)) = 0.V
proof
  thus - Sum(<*>(the carrier of V)) = - 0.V by Lm4
    .= 0.V by Th25;
end;

theorem
  - Sum<* v *> = - v by Lm6;

theorem
  for V being Abelian add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,u being Element of V
  holds - Sum<* v,u *> = (- v) - u
proof
  let V be Abelian add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,u be Element of V;
  thus - Sum<* v,u *> = - (v + u) by Th62
    .= (- v) - u by Th44;
end;

theorem
  for V being Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,u,w being Element of V
  holds - Sum<* v,u,w *> = ((- v) - u) - w
proof
  let V be Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,u,w be Element of V;
  thus - Sum<* v,u,w *> = - (v + u + w) by Th63
    .= (- (v + u)) - w by Th44
    .= ((- v) - u) - w by Th44;
end;

theorem
  for V being Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,w being Element of V
  holds Sum<* v,w *> = Sum<* w,v *>
proof
  let V be Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,w be Element of V;
  thus Sum<* v,w *> = v + w by Th62
    .= Sum<* w,v *> by Th62;
end;

theorem
  Sum<* v,w *> = Sum<* v *> + Sum<* w *>
proof
  thus Sum<* v,w *> = v + w by Th62
    .= Sum<* v *> + w by Lm6
    .= Sum<* v *> + Sum<* w *> by Lm6;
end;

theorem
  Sum<* 0.V,0.V *> = 0.V
proof
  thus Sum<* 0.V,0.V *> = 0.V + 0.V by Th62
    .= 0.V by Th10;
end;

theorem
  Sum<* 0.V,v *> = v & Sum<* v,0.V *> = v
proof
  thus Sum<* 0.V,v *> = 0.V + v by Th62
    .= v by Th10;
  thus Sum<* v,0.V *> = v + 0.V by Th62
    .= v by Th10;
end;

theorem
  Sum<* v,- v *> = 0.V & Sum<* - v,v *> = 0.V
proof
A1: v + - v = 0.V by Def11;
  hence Sum<* v,- v *> = 0.V by Th62;
  - v + v = 0.V by A1,Lm1;
  hence Sum<* - v, v *> = 0.V by Th62;
end;

theorem
  Sum<* v,- w *> = v - w by Th62;

theorem Th78:
  Sum<* - v,- w *> = - (w + v)
proof
  thus Sum<* - v,- w *> = (- v) + (- w) by Th62
    .= - (w + v) by Lm3;
end;

theorem Th79:
  for V being RealLinearSpace, v being VECTOR of V holds Sum<* v,v *> = 2 * v
proof
  let V be RealLinearSpace, v be VECTOR of V;
  thus Sum<* v,v *> = v + v by Th62
    .= 1 * v + v by Def9
    .= 1 * v + 1 * v by Def9
    .= (1 + 1) * v by Def9
    .= 2 * v;
end;

theorem
  for V being RealLinearSpace, v being VECTOR of V
  holds Sum<* - v,- v *> = (- 2) * v
proof
  let V be RealLinearSpace, v be VECTOR of V;
  thus Sum<* - v,- v *> = - (v + v) by Th78
    .= - Sum<* v,v *> by Th62
    .= - (2 * v) by Th79
    .= (- 1) * (2 * v) by Th29
    .= ((- 1) * 2) * v by Def9
    .= (- 2) * v;
end;

theorem
  Sum<* u,v,w *> = Sum<* u *> + Sum<* v *> + Sum<* w *>
proof
  thus Sum<* u,v,w *> = u + v + w by Th63
    .= Sum<* u *> + v + w by Lm6
    .= Sum<* u *> + v + Sum<* w *> by Lm6
    .= Sum<* u *> + Sum<* v *> + Sum<* w *> by Lm6;
end;

theorem
  Sum<* u,v,w *> = Sum<* u,v *> + w
proof
  thus Sum<* u,v,w *> = u + v + w by Th63
    .= Sum<* u,v *> + w by Th62;
end;

theorem
  for V being Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,u,w being Element of V
  holds Sum<* u,v,w *> = Sum<* v,w *> + u
proof
  let V be Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,u,w be Element of V;
  thus Sum<* u,v,w *> = u + v + w by Th63
    .= u + (v + w) by Def6
    .= Sum<* v,w *> + u by Th62;
end;

theorem Th84:
  for V being Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,u,w being Element of V
  holds Sum<* u,v,w *> = Sum<* u,w *> + v
proof
  let V be Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,u,w be Element of V;
  thus Sum<* u,v,w *> = u + v + w by Th63
    .= u + w + v by Def6
    .= Sum<* u,w *> + v by Th62;
end;

theorem Th85:
  for V being Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,u,w being Element of V
  holds Sum<* u,v,w *> = Sum<* u,w,v *>
proof
  let V be Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,u,w be Element of V;
  thus Sum<* u,v,w *> = u + v + w by Th63
    .= u + w + v by Def6
    .= Sum<* u,w,v *> by Th63;
end;

theorem Th86:
  for V being Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,u,w being Element of V
  holds Sum<* u,v,w *> = Sum<* v,u,w *>
proof
  let V be Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,u,w be Element of V;
  thus Sum<* u,v,w *> = u + v + w by Th63
    .= Sum<* v,u,w *> by Th63;
end;

theorem Th87:
  for V being Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,u,w being Element of V
  holds Sum<* u,v,w *> = Sum<* v,w,u *>
proof
  let V be Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,u,w be Element of V;
  thus Sum<* u,v,w *> = Sum<* v,u,w *> by Th86
    .= Sum<* v,w,u *> by Th85;
end;

canceled;

theorem
  for V being Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,u,w being Element of V
  holds Sum<* u,v,w *> = Sum<* w,v,u *>
proof
  let V be Abelian add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,u,w be Element of V;
  thus Sum<* u,v,w *> = Sum<* w,u,v *> by Th87
    .= Sum<* w,v,u *> by Th85;
end;

theorem
  Sum<* 0.V,0.V,0.V *> = 0.V
proof
  thus Sum<* 0.V,0.V,0.V *> = 0.V + 0.V + 0.V by Th63
    .= 0.V + 0.V by Th10
    .= 0.V by Th10;
end;

theorem
  Sum<* 0.V,0.V,v *> = v & Sum<* 0.V,v,0.V *> = v & Sum<* v,0.V,0.V *> = v
proof
  thus Sum<* 0.V,0.V,v *> = 0.V + 0.V + v by Th63
    .= 0.V + v by Th10
    .= v by Th10;
  thus Sum<* 0.V,v,0.V *> = 0.V + v + 0.V by Th63
    .= 0.V + v by Th10
    .= v by Th10;
  thus Sum<* v,0.V,0.V *> = v + 0.V + 0.V by Th63
    .= v + 0.V by Th10
    .= v by Th10;
end;

theorem
  Sum<* 0.V,u,v *> = u + v & Sum<* u,v,0.V *> = u + v & Sum<* u,0.V,v *> = u +
  v
proof
  thus Sum<* 0.V,u,v *> = 0.V + u + v by Th63
    .= u + v by Th10;
  thus Sum<* u,v,0.V *> = u + v + 0.V by Th63
    .= u + v by Th10;
  thus Sum<* u,0.V,v *> = u + 0.V + v by Th63
    .= u + v by Th10;
end;

theorem
  for V being RealLinearSpace, v being VECTOR of V
  holds Sum<* v,v,v *> = 3 * v
proof
  let V be RealLinearSpace, v be VECTOR of V;
  thus Sum<* v,v,v *> = Sum<* v,v *> + v by Th84
    .= 2 * v + v by Th79
    .= 2 * v + 1 * v by Def9
    .= (2 + 1) * v by Def9
    .= 3 * v;
end;

theorem
  len F = 0 implies Sum(F) = 0.V by Lm5;

theorem
  len F = 1 implies Sum(F) = F.1
proof
  assume
A1: len F = 1;
  then dom F = {1} by FINSEQ_1:4,def 3;
  then 1 in dom F by TARSKI:def 1;
  then F.1 in
  rng F & rng F c= the carrier of V by FINSEQ_1:def 4,FUNCT_1:def 5;
  then reconsider v = F.1 as Element of V;
  F = <* v *> by A1,FINSEQ_1:57;
  hence thesis by Lm6;
end;

theorem
  len F = 2 & v1 = F.1 & v2 = F.2 implies Sum(F) = v1 + v2
proof
  assume len F = 2 & v1 = F.1 & v2 = F.2;
  then F = <* v1,v2 *> by FINSEQ_1:61;
  hence thesis by Th62;
end;

theorem
  len F = 3 & v1 = F.1 & v2 = F.2 & v = F.3 implies Sum(F) = v1 + v2 + v
proof
  assume len F = 3 & v1 = F.1 & v2 = F.2 & v = F.3;
  then F = <* v1,v2,v *> by FINSEQ_1:62;
  hence thesis by Th63;
end;

definition
  let R be non empty ZeroStr, a be Element of R;
  attr a is non-zero means

  a <> 0.R;
end;

begin :: Addenda

:: from REALSET2, 2007.02.24, A.T

definition
  let L be non empty addLoopStr;
  attr L is zeroed means
  :Def15:
  for a being Element of L holds a+0.L = a & 0.L+a = a;
end;

registration
  cluster zeroed -> right_zeroed (non empty addLoopStr);
  coherence
  proof
    let L be non empty addLoopStr;
    assume L is zeroed;
    hence for v being Element of L holds v + 0.L = v by Def15;
  end;
end;

registration
  cluster Abelian right_zeroed -> zeroed (non empty addLoopStr);
  coherence
  proof
    let L be non empty addLoopStr;
    assume
A1: L is Abelian right_zeroed;
    let a be Element of L;
    thus a+0.L = a by A1,Def7;
    hence 0.L+a = a by A1,Def5;
  end;
  cluster Abelian right_complementable ->
    left_complementable (non empty addLoopStr);
  coherence
  proof
    let L be non empty addLoopStr;
    assume
A2: L is Abelian right_complementable;
    let a be Element of L;
    a is right_complementable by A2,ALGSTR_0:def 16;
    then consider w being Element of L such that
A3: a+w = 0.L by ALGSTR_0:def 11;
    take w;
    thus thesis by A2,A3,Def5;
  end;
end;

