:: Vectors in Real Linear Space
::  by Wojciech A. Trybulec
::
:: Received July 24, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabulary BINOP_1, FUNCT_1, ARYTM_1, RELAT_1, FINSEQ_1, BOOLE, RLVECT_1,
      ANPROJ_1, ORDINAL2, ARYTM;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, ORDINAL2, NUMBERS,
      XCMPLX_0, XREAL_0, DOMAIN_1, RELAT_1, FUNCT_1, FUNCT_2, BINOP_1, REAL_1,
      FINSEQ_1, NAT_1, STRUCT_0;
 constructors DOMAIN_1, BINOP_1, REAL_1, FINSEQ_1, NAT_1, STRUCT_0, XREAL_0,
      MEMBERED, XBOOLE_0, ORDINAL2;
 clusters RELSET_1, FINSEQ_1, STRUCT_0, XREAL_0, SUBSET_1, NAT_1, MEMBERED,
      ZFMISC_1, XBOOLE_0, ORDINAL2, NUMBERS, ARYTM_3, XCMPLX_0;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCT_1, TARSKI, STRUCT_0, XBOOLE_0;
 theorems AXIOMS, BINOP_1, FUNCT_1, NAT_1, REAL_1, TARSKI, RELAT_1, STRUCT_0,
      XBOOLE_0, XBOOLE_1, FINSEQ_1, XCMPLX_0, XCMPLX_1;
 schemes BINOP_1, FINSEQ_1, FUNCT_2, NAT_1;

begin

definition
 struct (ZeroStr) LoopStr (# carrier -> set,
                    add -> BinOp of the carrier,
                    Zero -> Element of the carrier #);
end;

definition
 struct (LoopStr) RLSStruct (# carrier -> set,
              Zero -> Element of the carrier,
              add -> BinOp of the carrier,
              Mult -> Function of [:REAL, the carrier:], the carrier
            #);
end;

registration
 cluster non empty RLSStruct;
 existence
  proof
   consider ZS being non empty set, O being Element of ZS,
      F being BinOp of ZS, G being Function of [:REAL,ZS:],ZS;
   take RLSStruct(#ZS,O,F,G#);
   thus the carrier of RLSStruct(#ZS,O,F,G#) is non empty;
  end;
end;

reserve V for non empty RLSStruct;
reserve x,y,y1,y2 for set;

definition let V be RLSStruct;
  mode VECTOR of V is Element of V;
end;

definition let V be 1-sorted; let x;
 pred x in V means
  :Def1: x in the carrier of V;
end;

canceled 2;

theorem
    for V being non empty 1-sorted, v being Element of V
  holds v in V by Def1;

::
::   Definitons of functions on the Elements of the carrier of
::   Real Linear Space structure, i.e. zero element, addition of two
::   elements, and multiplication of the element by a real number.
::

 definition let V be ZeroStr;
  func 0.V -> Element of V equals
   :Def2: the Zero of V;
  coherence;
 end;

reserve v for VECTOR of V;
reserve a,b for Real;

registration
 cluster strict non empty LoopStr;
 existence
  proof
   set ZS = {0};
   reconsider O = 0 as Element of ZS by TARSKI:def 1;
   consider F being BinOp of ZS;
   take LoopStr (# ZS,F,O #);
   thus LoopStr (# ZS,F,O #) is strict;
   thus the carrier of LoopStr (# ZS,F,O #) is non empty;
  end;
end;

 definition let V be non empty LoopStr, v,w be Element of V;
  func v + w -> Element of V equals
   :Def3: (the add of V).[v,w];
  coherence;
 end;

 definition let V; let v; let a;
  func a * v -> Element of V equals
   :Def4: (the Mult of V).[a,v];
  coherence;
 end;

::
::   Definitional theorems of zero element, addition, multiplication.
::

canceled;

theorem
    for V being non empty LoopStr, v,w being Element of V
   holds v + w = (the add of V).(v,w)
  proof let V be non empty LoopStr, v,w be Element of V;
   thus v + w = (the add of V).[v,w] by Def3
             .= (the add of V).(v,w) by BINOP_1:def 1;
  end;

registration let ZS be non empty set, O be Element of ZS,
      F be BinOp of ZS, G be Function of [:REAL,ZS:],ZS;
 cluster RLSStruct (# ZS,O,F,G #) -> non empty;
 coherence by STRUCT_0:def 1;
end;

Lm1: now
  take ZS = {0};
   reconsider O = 0 as Element of ZS by TARSKI:def 1;
  take O;
   deffunc A((Element of ZS), Element of ZS) = O;
   consider F being BinOp of ZS such that
     A1: for x,y being Element of ZS holds F.(x,y) = A(x,y) from BINOP_1:sch 2;
   deffunc M((Element of REAL), Element of ZS) = O;
   consider G being Function of [:REAL,ZS:],ZS such that
     A2: for a being Element of REAL for x being Element of ZS
         holds G.[a,x qua set] = M(a,x) from FUNCT_2:sch 8;
  take F,G;

  set W = RLSStruct (# ZS,O,F,G #);

  thus for x,y being VECTOR of W holds x + y = y + x
   proof let x,y be VECTOR of W;
         x + y = F.[x,y] & y + x = F.[y,x] by Def3;
      then A3: x + y = F.(x,y) & y + x = F.(y,x) by BINOP_1:def 1;
     reconsider X = x, Y = y as Element of ZS;
         x + y = A(X,Y) & y + x = A(Y,X) by A1,A3;
    hence thesis;
   end;

  thus for x,y,z being VECTOR of W holds (x + y) + z = x + (y + z)
   proof let x,y,z be VECTOR of W;
         (x + y) + z = F.[x + y,z] & x + (y + z) = F.[x,y + z] by Def3;
      then A4: (x + y) + z = F.(x + y,z) & x + (y + z) = F.(x,y + z)
                                                            by BINOP_1:def 1;
     reconsider X = x, Y = y, Z = z as Element of ZS;
         (x + y) + z = A(A(X,Y),Z) & x + (y + z) = A(X,A(Y,Z)) by A1,A4;
    hence thesis;
   end;

  thus for x being VECTOR of W holds x + 0.W = x
   proof let x be VECTOR of W;
     reconsider X = x as Element of ZS;
          x + 0.W = F.[x,0.W] by Def3
                .= F.(x,0.W) by BINOP_1:def 1
                .= A(X,O) by A1;
    hence thesis by TARSKI:def 1;
   end;

  thus for x being VECTOR of W ex y being VECTOR of W st x + y = 0.W
   proof let x be VECTOR of W;
     reconsider y = O as VECTOR of W;
    take y;
    thus x + y = F.[x,y] by Def3
              .= F.(x,y) by BINOP_1:def 1
              .= the Zero of W by A1
              .= 0.W by Def2;
   end;

  thus for a for x,y being VECTOR of W holds a * (x + y) = a * x + a * y
   proof let a; let x,y be VECTOR of W;
     reconsider X = x, Y = y as Element of ZS;
A5:      a * (x + y) = G.[a,x + y] by Def4;

         a * x + a * y = F.[a * x,a * y] by Def3
                   .= F.(a * x,a * y) by BINOP_1:def 1
                   .= A(M(a,X),M(a,Y)) by A1;
    hence thesis by A2,A5;
   end;

  thus for a,b for x being VECTOR of W holds (a + b) * x = a * x + b * x
   proof let a,b; let x be VECTOR of W;
      set c = a + b;
     reconsider X = x as Element of ZS;
      A6: c * x = G.[c,x] by Def4
              .= M(c,X) by A2;
         a * x + b * x = F.[a * x,b * x] by Def3
                   .= F.(a * x,b * x) by BINOP_1:def 1
                   .= A(M(a,X),M(b,X)) by A1;
    hence thesis by A6;
   end;

  thus for a,b for x being VECTOR of W holds (a * b) * x = a * (b * x)
    proof let a,b; let x be VECTOR of W;
       set c = a * b;
      reconsider X = x as Element of ZS;
       A7: c * x = G.[c,x] by Def4
               .= M(c,X) by A2;
          a * (b * x) = G.[a,b * x] by Def4
                  .= M(a,M(b,X)) by A2;
     hence thesis by A7;
    end;

  thus for x being VECTOR of W holds 1 * x = x
   proof let x be VECTOR of W;
     reconsider X = x as Element of ZS;
     reconsider A' = 1 as Element of REAL;
          1 * x = G.[1,x] by Def4
              .= M(A',X) by A2;
    hence thesis by TARSKI:def 1;
   end;
 end;

definition let IT be non empty LoopStr;
  attr IT is Abelian means
:Def5: for v,w being Element of IT holds v + w = w + v;
  attr IT is add-associative means
:Def6: for u,v,w being Element of IT
         holds (u + v) + w = u + (v + w);
  attr IT is right_zeroed means
:Def7: for v being Element of IT holds v + 0.IT = v;
  attr IT is right_complementable means
:Def8: for v being Element of IT
         ex w being Element of IT st v + w = 0.IT;
end;

definition let IT be non empty RLSStruct;
  attr IT is RealLinearSpace-like means :Def9:
  (for a for v,w being VECTOR of IT holds a * (v + w) = a * v + a * w) &
  (for a,b for v being VECTOR of IT holds (a + b) * v = a * v + b * v) &
  (for a,b for v being VECTOR of IT holds (a * b) * v = a * (b * v)) &
  (for v being VECTOR of IT holds 1 * v = v);
end;

registration
 cluster strict Abelian add-associative right_zeroed right_complementable
                (non empty LoopStr);
  existence
 proof
   set ZS = {0};
   reconsider O = 0 as Element of ZS by TARSKI:def 1;
   deffunc A((Element of ZS), Element of ZS) = O;
   consider F being BinOp of ZS such that
A1: for x,y being Element of ZS holds F.(x,y) = A(x,y)
        from BINOP_1:sch 2;
   reconsider W = LoopStr (# ZS,F,O #) as non empty LoopStr by STRUCT_0:def 1;
  take W;
  thus W is strict;
  thus for x,y being Element of W holds x + y = y + x
   proof let x,y be Element of W;
         x + y = F.[x,y] & y + x = F.[y,x] by Def3;
      then A2: x + y = F.(x,y) & y + x = F.(y,x) by BINOP_1:def 1;
     reconsider X = x, Y = y as Element of ZS;
         x + y = A(X,Y) & y + x = A(Y,X) by A1,A2;
    hence thesis;
   end;
  thus for x,y,z being Element of W
     holds (x + y) + z = x + (y + z)
   proof let x,y,z be Element of W;
         (x + y) + z = F.[x + y,z] & x + (y + z) = F.[x,y + z] by Def3;
      then A3: (x + y) + z = F.(x + y,z) & x + (y + z) = F.(x,y + z)
                                                            by BINOP_1:def 1;
     reconsider X = x, Y = y, Z = z as Element of ZS;
         (x + y) + z = A(A(X,Y),Z) & x + (y + z) = A(X,A(Y,Z)) by A1,A3;
    hence thesis;
   end;
  thus for x being Element of W holds x + 0.W = x
   proof let x be Element of W;
     reconsider X = x as Element of ZS;
          x + 0.W = F.[x,0.W] by Def3
                .= F.(x,0.W) by BINOP_1:def 1
                .= A(X,O) by A1;
    hence thesis by TARSKI:def 1;
   end;
  let x be Element of W;
     reconsider y = O as Element of W;
   take y;
   thus x + y = F.[x,y] by Def3
             .= F.(x,y) by BINOP_1:def 1
             .= the Zero of W by A1
             .= 0.W by Def2;
 end;
end;

registration
 cluster non empty strict Abelian add-associative right_zeroed
     right_complementable RealLinearSpace-like (non empty RLSStruct);
  existence
   proof
     consider ZS being non empty set, O being Element of ZS,
      F being BinOp of ZS, G being Function of [:REAL,ZS:],ZS such that
A1:   (for v,w being VECTOR of RLSStruct (# ZS,O,F,G #) holds v + w = w + v) &
     (for u,v,w being VECTOR of RLSStruct (# ZS,O,F,G #) holds
      (u + v) + w = u + (v + w)) &
     (for v being VECTOR of RLSStruct (# ZS,O,F,G #) holds
      v + 0.RLSStruct (# ZS,O,F,G #) = v) &
     (for v being VECTOR of RLSStruct (# ZS,O,F,G #)
       ex w being VECTOR of RLSStruct (# ZS,O,F,G #) st
        v + w = 0.RLSStruct (# ZS,O,F,G #)) &
     (for a for v,w being VECTOR of RLSStruct (# ZS,O,F,G #) holds
      a * (v + w) = a * v + a * w) &
     (for a,b for v being VECTOR of RLSStruct (# ZS,O,F,G #) holds
      (a + b) * v = a * v + b * v) &
     (for a,b for v being VECTOR of RLSStruct (# ZS,O,F,G #) holds
      (a * b) * v = a * (b * v)) &
     (for v being VECTOR of RLSStruct (# ZS,O,F,G #) holds 1 * v = v)
      by Lm1;
    take RLSStruct (# ZS,O,F,G #);
    thus RLSStruct (# ZS,O,F,G #) is non empty;
     thus thesis by A1,Def5,Def6,Def7,Def8,Def9;
   end;
end;

definition
  mode RealLinearSpace is Abelian add-associative right_zeroed
    right_complementable RealLinearSpace-like (non empty RLSStruct);
end;

definition let V be Abelian (non empty LoopStr),
                   v,w be Element of V;
 redefine func v + w;
 commutativity by Def5;
end;

canceled;

theorem
    (for v,w being VECTOR of V holds v + w = w + v) &
 (for u,v,w being VECTOR of V holds (u + v) + w = u + (v + w)) &
 (for v being VECTOR of V holds v + 0.V = v) &
 (for v being VECTOR of V
   ex w being VECTOR of V st v + w = 0.V) &
 (for a for v,w being VECTOR of V holds a * (v + w) = a * v + a * w) &
 (for a,b for v being VECTOR of V holds (a + b) * v = a * v + b * v) &
 (for a,b for v being VECTOR of V holds (a * b) * v = a * (b * v)) &
 (for v being VECTOR of V holds 1 * v = v)
  implies V is RealLinearSpace by Def5,Def6,Def7,Def8,Def9;

::
::  Axioms of real linear space.
::

reserve V for RealLinearSpace;
reserve v,w for VECTOR of V;

Lm2:
 for V being
  add-associative right_zeroed right_complementable (non empty LoopStr),
     v,w being Element of V
    st v + w = 0.V holds w + v = 0.V
  proof
   let V be
     add-associative right_zeroed right_complementable (non empty LoopStr),
       v,w be Element of V;
   assume
A1:  v + w = 0.V;
   consider u being Element of V such that
A2:   w + u = 0.V by Def8;
       w + v = w + (v + (w + u)) by A2,Def7
         .= w + (v + w + u) by Def6
         .= w + (v + w) + u by Def6
         .= w + u by A1,Def7;
    hence thesis by A2;
  end;

canceled 2;

theorem Th10:
 for V being add-associative
      right_zeroed right_complementable (non empty LoopStr),
     v being Element of V
   holds v + 0.V = v & 0.V + v = v
  proof
   let V be add-associative right_zeroed
                    right_complementable (non empty LoopStr),
       v be Element of V;
   thus
A1:   v + 0.V = v by Def7;
    consider w being Element of V such that
A2:   v + w = 0.V by Def8;
     w + v = 0.V by A2,Lm2;
   hence 0.V + v = v by A1,A2,Def6;
  end;

::
::  Definitions of reverse element to the vector and of
::  subtraction of vectors.
::

 definition let V be non empty LoopStr;
   let v be Element of V;
  assume A1: V is add-associative right_zeroed right_complementable;
  func - v -> Element of V means
   :Def10: v + it = 0.V;
  existence by A1,Def8;
  uniqueness
   proof let v1,v2 be Element of V;
    assume that A2: v + v1 = 0.V and A3: v + v2 = 0.V;
    thus v1 = v1 + (v + v2) by A1,A3,Th10
           .= (v1 + v) + v2 by A1,Def6
           .= 0.V + v2 by A1,A2,Lm2
           .= v2 by A1,Th10;
   end;
 end;

Lm3:
 for V being add-associative right_zeroed
           right_complementable (non empty LoopStr),
     v,u being Element of V
  ex w being Element of V st v + w = u
 proof let V be add-associative
      right_zeroed right_complementable (non empty LoopStr);
   let v,u be Element of V;
  take w = (- v) + u;
  thus v + w = (v + (- v)) + u by Def6
            .= 0.V + u by Def10
            .= u by Th10;
 end;

definition let V be non empty LoopStr;
   let v,w be Element of V;
  func v - w -> Element of V equals
   :Def11: v + (- w);
  correctness;
end;

::
::  Definitional theorems of reverse element and substraction.
::

canceled 5;

theorem Th16:
 for V being add-associative right_zeroed
             right_complementable (non empty LoopStr),
     v being Element of V
  holds v + -v = 0.V & -v + v = 0.V
 proof let V be add-associative right_zeroed
             right_complementable (non empty LoopStr),
           v be Element of V;
  thus v + -v = 0.V by Def10;
  hence -v + v = 0.V by Lm2;
 end;

canceled 2;

theorem Th19:
 for V being add-associative right_zeroed
                   right_complementable (non empty LoopStr),
     v,w being Element of V
   holds v + w = 0.V implies v = - w
  proof let V be add-associative right_zeroed
        right_complementable (non empty LoopStr);
   let v,w be Element of V;
   assume v + w = 0.V;
then w + v = 0.V by Lm2;
   hence thesis by Def10;
  end;

theorem
    for V being add-associative right_zeroed
          right_complementable (non empty LoopStr),
     v,u being Element of V
 ex w being Element of V st v + w = u by Lm3;

theorem Th21:
 for V being add-associative right_zeroed
         right_complementable (non empty LoopStr),
     w,u,v1,v2 being Element of V
   st w + v1 = w + v2 or v1 + w = v2 + w holds v1 = v2
  proof let V be add-associative right_zeroed
      right_complementable (non empty LoopStr);
   let w,u,v1,v2 be Element of V;
A1:  now assume that A2: w + v1 = w + v2;
    thus v1 = 0.V + v1 by Th10
           .= -w + w + v1 by Th16
           .= -w + (w + v1) by Def6
           .= -w + w + v2 by A2,Def6
           .= 0.V + v2 by Th16
           .= v2 by Th10;
    end;
       now assume that A3: v1 + w = v2 + w;
    thus v1 = v1 + 0.V by Th10
           .= v1 + (w + -w) by Th16
           .= v1 + w + -w by Def6
           .= v2 + (w + -w) by A3,Def6
           .= v2 + 0.V by Th16
           .= v2 by Th10;
    end;
   hence thesis by A1;
  end;

theorem
    for V being add-associative right_zeroed
                    right_complementable (non empty LoopStr),
     v,w being Element of V
   holds v + w = v or w + v = v implies w = 0.V
  proof let V be add-associative right_zeroed right_complementable
      (non empty LoopStr),
        v,w be Element of V;
   assume v + w = v or w + v = v;
   then v + w = v + 0.V or w + v = 0.V + v by Th10;
   hence thesis by Th21;
  end;

theorem Th23:
 a = 0 or v = 0.V implies a * v = 0.V
  proof
    assume A1: a = 0 or v = 0.V;
        now per cases by A1;
       suppose A2: a = 0;
            v + 0 * v = 1 * v + 0 * v by Def9
                  .= (1 + 0) * v by Def9
                  .= v by Def9
                  .= v + 0.V by Th10;
        hence a * v = 0.V by A2,Th21;
       end;
       suppose A3: v = 0.V;
            a * 0.V + a * 0.V = a * (0.V + 0.V) by Def9
                          .= a * 0.V by Th10
                          .= a * 0.V + 0.V by Th10;
        hence a * v = 0.V by A3,Th21;
     end;
     end;
   hence thesis;
  end;

theorem Th24:
 a * v = 0.V implies a = 0 or v = 0.V
  proof
    assume that A1: a * v = 0.V and A2: a <> 0;
   thus v = 1 * v by Def9
         .= (a" * a) * v by A2,XCMPLX_0:def 7
         .= a" * 0.V by A1,Def9
         .= 0.V by Th23;
  end;

theorem Th25:
  for V being add-associative
         right_zeroed right_complementable (non empty LoopStr)
    holds - 0.V = 0.V
  proof let V be add-associative right_zeroed
     right_complementable (non empty LoopStr);
   thus 0.V = 0.V + (- 0.V) by Def10
           .= - 0.V by Th10;
  end;

theorem
    for V being add-associative right_zeroed
      right_complementable (non empty LoopStr),
     v being Element of V
   holds v - 0.V = v
  proof let V be add-associative right_zeroed
     right_complementable (non empty LoopStr);
   let v be Element of V;
   thus v - 0.V = v + (- 0.V) by Def11
               .= v + 0.V by Th25
               .= v by Th10;
  end;

theorem Th27:
 for V being add-associative right_zeroed
       right_complementable (non empty LoopStr),
     v being Element of V
   holds 0.V - v = - v
  proof let V be add-associative right_zeroed
     right_complementable (non empty LoopStr);
   let v be Element of V;
   thus 0.V - v = 0.V + (- v) by Def11
               .= - v by Th10;
  end;

theorem Th28:
 for V being add-associative right_zeroed
      right_complementable (non empty LoopStr),
     v being Element of V
   holds v - v = 0.V
  proof let V be add-associative right_zeroed
     right_complementable (non empty LoopStr);
   let v be Element of V;
   thus v - v = v + (- v) by Def11
             .= 0.V by Def10;
  end;

theorem Th29:
 - v = (- 1) * v
  proof v + (- 1) * v = 1 * v + (- 1) * v by Def9
                        .= (1 + (- 1)) * v by Def9
                        .= 0.V by Th23;
   hence (- v) = (- v) + (v + (- 1) * v) by Th10
             .= ((- v) + v) + (- 1) * v by Def6
             .= 0.V + (- 1) * v by Def10
             .= (- 1) * v by Th10;
  end;

theorem Th30:
 for V being add-associative right_zeroed
     right_complementable (non empty LoopStr),
     v being Element of V
   holds - (- v) = v
  proof let V be add-associative right_zeroed
     right_complementable (non empty LoopStr);
   let v be Element of V;
        v + -v = 0.V by Def10;
    hence thesis by Th19;
  end;

theorem Th31:
 for V being add-associative right_zeroed
    right_complementable (non empty LoopStr),
     v,w being Element of V
   holds - v = - w implies v = w
  proof let V be add-associative right_zeroed
     right_complementable (non empty LoopStr);
   let v,w be Element of V;
   assume - v = - w;
   hence v = - (- w) by Th30
         .= w by Th30;
  end;

canceled;

theorem Th33:
 v = - v implies v = 0.V
  proof assume v = - v;
    then 0.V = v - (- v) by Th28
               .= v + (- (- v)) by Def11
               .= v + v by Th30
               .= 1 * v + v by Def9
               .= 1 * v + 1 * v by Def9
               .= (1 + 1) * v by Def9
               .= 2 * v;
   hence thesis by Th24;
  end;

theorem
    v + v = 0.V implies v = 0.V
  proof assume
   v + v = 0.V;
    then v = - v by Def10;
   hence thesis by Th33;
  end;

theorem Th35:
 for V being add-associative right_zeroed
     right_complementable (non empty LoopStr),
     v,w being Element of V
   holds v - w = 0.V implies v = w
  proof let V be add-associative right_zeroed
     right_complementable (non empty LoopStr);
   let v,w be Element of V;
    assume v - w = 0.V;
    then 0.V = v + (- w) by Def11;
    then - v = - w by Def10;
   hence thesis by Th31;
  end;

theorem
    for V being add-associative right_zeroed
     right_complementable (non empty LoopStr),
     u,v being Element of V
   ex w being Element of V st v - w = u
  proof let V be add-associative right_zeroed
      right_complementable (non empty LoopStr);
   let u,v be Element of V;
   consider w being Element of V such that
A1: v + w = u by Lm3;
   take z = - w;
   thus v - z = v + (- (- w)) by Def11
             .= u by A1,Th30;
  end;

theorem
    for V being add-associative right_zeroed
     right_complementable (non empty LoopStr),
     w,v1,v2 being Element of V
    st w - v1 = w - v2 holds v1 = v2
  proof let V be add-associative right_zeroed
      right_complementable (non empty LoopStr);
   let w,v1,v2 be Element of V;
   assume
A1:   w - v1 = w - v2;
        w + (- v1) = w - v1 & w + (- v2) = w - v2 by Def11;
    then - v1 = - v2 by A1,Th21;
   hence thesis by Th31;
  end;

theorem Th38:
 a * (- v) = (- a) * v
  proof
   thus a * (- v) = a * ((- 1) * v) by Th29
                 .= (a *(- 1)) * v by Def9
                 .= (- a) * v;
  end;

theorem Th39:
 a * (- v) = - (a * v)
  proof
   thus a * (- v) = (- (1 * a)) * v by Th38
                 .= ((- 1) * a) * v
                 .= (- 1) * (a * v) by Def9
                 .= - (a * v) by Th29;
  end;

theorem
    (- a) * (- v) = a * v
  proof
   thus (- a) * (- v) = (- (- a)) * v by Th38
                     .= a * v;
  end;

Lm4:
 for V being add-associative right_zeroed
    right_complementable (non empty LoopStr),
     u,w being Element of V
   holds - (u + w) = -w + -u
proof
 let V be add-associative right_zeroed
      right_complementable (non empty LoopStr),
     u,w be Element of V;
     u + w + (-w + -u)
        = u + (w + (-w + -u)) by Def6
       .= u + (w + -w + -u) by Def6
       .= u + (0.V + -u) by Def10
       .= u + -u by Th10
       .= 0.V by Def10;
 hence -(u + w) = -w + -u by Def10;
end;

theorem Th41:
 for V being add-associative right_zeroed
      right_complementable (non empty LoopStr),
     v,u,w being Element of V
   holds v - (u + w) = (v - w) - u
  proof let V be add-associative right_zeroed
     right_complementable (non empty LoopStr);
   let v,u,w be Element of V;
   thus v - (u + w) = v + - (u + w) by Def11
                   .= v + (-w + -u) by Lm4
                   .= (v + (- w)) + (- u) by Def6
                   .= (v - w) + (- u) by Def11
                   .= (v - w) - u by Def11;
  end;

theorem
    for V being add-associative (non empty LoopStr),
     v,u,w being Element of V
   holds (v + u) - w = v + (u - w)
  proof let V be add-associative (non empty LoopStr);
   let v,u,w be Element of V;
   thus (v + u) - w = (v + u) + - w by Def11
                   .= v + (u + - w) by Def6
                   .= v + (u - w) by Def11;
  end;

theorem
    for V being Abelian add-associative right_zeroed
     right_complementable (non empty LoopStr),
     v,u,w being Element of V
   holds v - (u - w) = (v -u) + w
  proof
   let V be Abelian add-associative right_zeroed
          right_complementable (non empty LoopStr);
   let v,u,w be Element of V;
   thus v - (u - w) = v - (u + - w) by Def11
                   .= (v - u) - - w by Th41
                   .= (v - u) + (- - w) by Def11
                   .= (v - u) + w by Th30;
  end;

theorem Th44:
 for V being add-associative right_zeroed
         right_complementable (non empty LoopStr),
     v,w being Element of V
   holds - (v + w) = (- w) - v
  proof let V be add-associative right_zeroed
      right_complementable (non empty LoopStr);
   let v,w be Element of V;
   thus - (v + w) = 0.V - (v + w) by Th27
                 .= (0.V - w) - v by Th41
                 .= (- w) - v by Th27;
  end;

theorem
   for V being add-associative right_zeroed
        right_complementable (non empty LoopStr),
     v,w being Element of V
   holds - (v + w) = -w + -v by Lm4;

theorem
    for V being Abelian add-associative right_zeroed
       right_complementable (non empty LoopStr),
     v,w being Element of V
   holds (- v) - w = (- w) - v
  proof
   let V be Abelian add-associative right_zeroed
      right_complementable (non empty LoopStr);
   let v,w be Element of V;
   thus (- v) - w = - (w + v) by Th44
                 .= (- w) - v by Th44;
  end;

theorem
    for V being add-associative right_zeroed
       right_complementable (non empty LoopStr),
     v,w being Element of V
   holds - (v - w) = w + (- v)
  proof let V be add-associative right_zeroed
      right_complementable (non empty LoopStr);
   let v,w be Element of V;
   thus - (v - w) = - (v + (- w)) by Def11
                 .= --w + -v by Lm4
                 .= w + -v by Th30;
  end;

theorem Th48:
 a * (v - w) = a * v - a * w
  proof
   thus a * (v - w) = a * (v + (- w)) by Def11
                   .= a * v + a * (- w) by Def9
                   .= a * v + (- (a * w)) by Th39
                   .= a * v - a * w by Def11;
  end;

theorem Th49:
 (a - b) * v = a * v - b * v
  proof
   thus (a - b) * v = (a + (- b)) * v
                   .= a * v + (- b) * v by Def9
                   .= a * v + b * (- v) by Th38
                   .= a * v + (- (b * v)) by Th39
                   .= a * v - b * v by Def11;
  end;

theorem
    a <> 0 & a * v = a * w implies v = w
  proof assume that A1: a <> 0 and A2: a * v = a * w;
        0.V = a * v - a * w by A2,Th28
        .= a * (v - w) by Th48;
     then v - w = 0.V by A1,Th24;
   hence thesis by Th35;
  end;

theorem
    v <> 0.V & a * v = b * v implies a = b
  proof assume that A1: v <> 0.V and A2: a * v = b * v;
       0.V = a * v - b * v by A2,Th28
       .= (a - b) * v by Th49;
    then (- b) + a = 0 by A1,Th24;
    then a = - (- b) by XCMPLX_0:def 6;
   hence thesis;
  end;

::
::  Definition of the sum of the finite sequence of vectors.
::

definition let V be non empty 1-sorted; let v,u be Element of V;
 redefine func <* v,u *> -> FinSequence of the carrier of V;
 coherence
  proof
       <* v,u *> = <* v *> ^ <* u *> by FINSEQ_1:def 9;
   hence thesis;
  end;
end;

definition let V be non empty 1-sorted;
 let v,u,w be Element of V;
 redefine func <* v,u,w *> -> FinSequence of the carrier of V;
 coherence
  proof
       <* v,u,w *> = <* v,u *> ^ <* w *> by FINSEQ_1:60;
   hence thesis;
  end;
end;

reserve V for non empty LoopStr;
reserve F,G,H for FinSequence of the carrier of V;
reserve f,f',g for Function of NAT, the carrier of V;
reserve v,u for Element of V;
reserve j,k,n for Nat;

definition let V; let F;
 func Sum(F) -> Element of V means
  :Def12: ex f st it = f.(len F) &
           f.0 = 0.V &
            for j,v st j < len F & v = F.(j + 1) holds f.(j + 1) = f.j + v;
 existence
  proof
    defpred P[set] means
      for F st len F = $1 ex u st
     ex f st u = f.(len F) & f.0 = 0.V &
      for j,v st j < len F & v = F.(j + 1) holds f.(j + 1) = f.j + v;
  A1: P[0]
   proof
     now let F;
      assume A2: len F = 0;
      deffunc G(Nat)=0.V;
       consider f being Function of NAT, the carrier of V
        such that A3: for j being Element of NAT holds f.j = G(j)
        from FUNCT_2:sch 4;
     take u = f.(len F);
     take f' = f;
     thus u = f'.(len F) & f'.0 = 0.V by A3;
     let j;
     thus for v st j < len F & v = F.(j + 1) holds f'.(j + 1) = f'.j + v
                                                               by A2,NAT_1:18;
    end;
    hence thesis;
    end;
  A4: for n be Nat st P[n] holds P[n+1]
  proof
     now let n;
      assume A5: for F st len F = n
        ex u st
         ex f st u = f.(len F) &
          f.0 = 0.V &
           for j,v st j < len F & v = F.(j + 1) holds f.(j + 1) = f.j + v;
     let F;
      assume A6: len F = n + 1;
       reconsider G = F | Seg(n) as FinSequence of the carrier of V
         by FINSEQ_1:23;
        A7: n < n + 1 by NAT_1:38;
        then A8: len G = n by A6,FINSEQ_1:21;
       then consider u,f such that u = f.(len G) and A9: f.0 = 0.V and
        A10: for j,v st j < len G & v = G.(j + 1) holds
         f.(j + 1) = f.j + v by A5;
           dom F = Seg(n + 1) by A6,FINSEQ_1:def 3;
        then n + 1 in dom F by FINSEQ_1:6;
        then F.(n + 1) in rng F & rng F c= the carrier of V
                                   by FINSEQ_1:def 4,FUNCT_1:def 5;
       then reconsider u1 = F.(n + 1) as Element of V;
       defpred P[set,set] means for j st $1 = j holds
         (j < n + 1 implies $2 = f.$1) &
           (n + 1 <= j implies for u st u = F.(n + 1) holds
            $2 = f.(len G) + u);

        A11: for k being Element of NAT qua non empty set
             ex v being Element of V st P[k,v]
         proof let k be Element of NAT qua non empty set;
           reconsider i = k as Element of NAT;
            A12: now assume A13: i < n + 1;
             take v = f.k;
             let j such that A14: k = j;
             thus j < n + 1 implies v = f.k;
             thus n + 1 <= j implies for u st u = F.(n + 1) holds
                   v = f.(len G) + u by A13,A14;
            end;
               now assume A15: n + 1 <= i;
             take v = f.(len G) + u1;
             let j; assume k = j;
             hence j < n + 1 implies v = f.k by A15;
              assume n + 1 <= j;
             let u2 be Element of V;
              assume u2 = F.(n + 1);
             hence v = f.(len G) + u2;
            end;
          hence thesis by A12;
         end;
       consider f' being Function of NAT qua non empty set, the carrier of V
        such that A16:
         for k being Element of NAT qua non empty set holds
           P[k,f'.k] from FUNCT_2:sch 3(A11);
     take z = f'.(n + 1);
     take f'' = f';
     thus z = f''.(len F) by A6;
        0 is Element of NAT & 0 < n + 1 by NAT_1:19;
     hence f''.0 = 0.V by A9,A16;
     let j,v;
      assume that A17: j < len F and A18: v = F.(j + 1);
       A19: now assume A20: j < n;
         then A21: j <= n & 1 <= 1 + j by NAT_1:29;
            1 <= j + 1 & j + 1 <= n + 1 by A20,NAT_1:29,REAL_1:55;
         then j + 1 in Seg(n + 1) & j + 1 <= n by A20,FINSEQ_1:3,NAT_1:38;
         then j + 1 in dom F & j + 1 in Seg n by A6,A21,FINSEQ_1:3,def 3;
         then v = G.(j + 1) & j < len G by A6,A7,A18,A20,FINSEQ_1:21,FUNCT_1:
72
;
         then f.(j + 1) = f.j + v & j < n + 1 by A10,A20,NAT_1:38;
         then f.(j + 1) = f'.j + v & j + 1 < n + 1 by A16,A20,REAL_1:53;
        hence f''.(j + 1) = f''.j + v by A16;
       end;
       A22: now assume A23: j = n;
         then f''.(j + 1) = f.j + v by A8,A16,A18;
        hence f''.(j + 1) = f''.j + v by A7,A16,A23;
       end;
          j <= n by A6,A17,NAT_1:38;
     hence f''.(j + 1) = f''.j + v by A19,A22,REAL_1:def 5;
    end;
    hence thesis;
    end;
       for n holds P[n] from NAT_1:sch 1(A1,A4);
   then consider u such that
A24:  ex f st u = f.(len F) & f.0 = 0.V &
      for j,v st j < len F & v = F.(j + 1) holds f.(j + 1) = f.j + v;
   thus thesis by A24;
  end;
 uniqueness
  proof
   let v1,v2 be Element of V;
    given f such that A25: v1 = f.(len F) and A26: f.0 = 0.V and
     A27: for j,v st j < len F & v = F.(j + 1) holds f.(j + 1) = f.j + v;
    given f' such that A28: v2 = f'.(len F) and A29: f'.0 = 0.V and
     A30: for j,v st j < len F & v = F.(j + 1) holds f'.(j + 1) = f'.j + v;
     defpred P[Nat] means $1 <= len F implies f.$1 = f'.$1;
      A31: P[0] by A26,A29;
      A32: for k st P[k] holds P[k+1]
      proof
       now let k;
        assume A33: k <= len F implies f.k = f'.k;
        assume A34: k + 1 <= len F;
            1 <= k + 1 & dom F = Seg(len F) by FINSEQ_1:def 3,NAT_1:29;
         then k + 1 in dom F by A34,FINSEQ_1:3;
         then F.(k + 1) in rng F & rng F c= the carrier of V
                                         by FINSEQ_1:def 4,FUNCT_1:def 5;
        then reconsider u1 = F.(k + 1) as Element of V;
            k < len F by A34,NAT_1:38;
         then f.(k + 1) = f.k + u1 & f'.(k + 1) = f'.k + u1 & k <= len F
                                                            by A27,A30;
       hence f.(k + 1) = f'.(k + 1) by A33;
      end;
      hence thesis;
      end;
          for k holds P[k] from NAT_1:sch 1(A31,A32);
   hence v1 = v2 by A25,A28;
  end;
end;

Lm5: Sum(<*>(the carrier of V)) = 0.V
 proof set S = <*>(the carrier of V);
       ex f st Sum(S) = f.(len S) & f.0 = 0.V &
    for j,v st j < len S & v = S.(j + 1) holds f.(j + 1) = f.j + v by Def12;
  hence thesis by FINSEQ_1:25;
 end;

Lm6:
  len F = 0 implies Sum(F) = 0.V
 proof
  assume len F = 0;
   then F = <*>(the carrier of V) by FINSEQ_1:32;
  hence thesis by Lm5;
 end;

canceled 2;

theorem Th54:
 k in Seg n & len F = n implies F.k is Element of V
  proof assume k in Seg n & len F = n;
    then k in dom F by FINSEQ_1:def 3;
    then F.k in rng F & rng F c= the carrier of V by FINSEQ_1:def 4,FUNCT_1:
def 5;
   hence thesis;
  end;

theorem Th55:
 len F = len G + 1 & G = F | (dom G) & v = F.(len F) implies
  Sum(F) = Sum(G) + v
   proof assume that A1: len F = len G + 1 and A2: G = F | (dom G) and
                     A3: v = F.(len F);
     consider f such that A4: Sum(F) = f.(len F) and A5: f.0 = 0.V and
      A6: for j,v st j < len F & v = F.(j + 1) holds
          f.(j + 1) = f.j + v by Def12;
     consider g such that A7: Sum(G) = g.(len G) and A8: g.0 = 0.V and
      A9: for j,v st j < len G & v = G.(j + 1) holds
          g.(j + 1) = g.j + v by Def12;
      defpred P[Nat] means for H holds len H = $1 & H = F | (Seg $1)
             & len H <= len G implies f.(len H) = g.(len H);
      A10:  P[0] by A5,A8;
      A11: for k st P[k] holds P[k+1]
      proof
       now let k;
        assume A12: for H st len H = k & H = F | (Seg k) & len H <= len G holds
                    f.(len H) = g.(len H);
       let H;
        assume that A13: len H = k + 1 and A14: H = F | (Seg (k + 1)) and
                    A15: len H <= len G;
         reconsider p = H | (Seg k) as FinSequence of the carrier of V
             by FINSEQ_1:23;
             1 <= k + 1 & k + 1 <= len F by A1,A13,A15,NAT_1:37;
          then k + 1 in Seg(len F) by FINSEQ_1:3;
         then reconsider v = F.(k + 1) as Element of V by Th54;
          A16: k <= len H by A13,NAT_1:37;
          then A17: len p = k by FINSEQ_1:21;
             Seg k c= Seg(k + 1) by A13,A16,FINSEQ_1:7;
          then A18: p = F | (Seg k) by A14,FUNCT_1:82;
A19:          len p <= len G by A15,A16,A17,AXIOMS:22;
             k <= len G & len G < len F by A1,A15,A16,AXIOMS:22,REAL_1:69;
          then A20: k < len F by AXIOMS:22;
             1 <= k + 1 & k + 1 <= len G by A13,A15,NAT_1:37;
          then k + 1 in Seg(len G) by FINSEQ_1:3;
          then k + 1 in dom G by FINSEQ_1:def 3;
          then A21: v = G.(k + 1) by A2,FUNCT_1:70;
             k < k + 1 by REAL_1:69;
          then k < len G by A13,A15,AXIOMS:22;
          then f.(k + 1) = f.k + v & g.(k + 1) = g.k + v by A6,A9,A20,A21;
       hence f.(len H) = g.(len H) by A12,A13,A17,A18,A19;
      end;
      hence thesis;
      end;
A22:    dom G = Seg len G by FINSEQ_1:def 3;

          for k holds P[k] from NAT_1:sch 1(A10,A11);
      then A23: f.(len G) = g.(len G) by A2,A22;
         len G < len F by A1,REAL_1:69;
    hence thesis by A1,A3,A4,A6,A7,A23;
   end;

reserve V for RealLinearSpace;
reserve v for VECTOR of V;
reserve F,G,H,I for FinSequence of the carrier of V;

theorem
    len F = len G &
  (for k,v st k in dom F & v = G.k holds F.k = a * v) implies
   Sum(F) = a * Sum(G)
    proof
     defpred P[set] means
     for H,I st len H = len I & len H = $1 &
          (for k,v st k in Seg len H & v = I.k holds H.k = a * v) holds
            Sum(H) = a * Sum(I);
     A1: P[0]
     proof
      now let H,I;
       assume that A2: len H = len I & len H = 0 and
                         for k,v st k in Seg len H & v = I.k holds H.k = a * v;
          Sum(H) = 0.V & Sum(I) = 0.V by A2,Lm6;
      hence Sum(H) = a * Sum(I) by Th23;
     end;
     hence thesis;
     end;
     A3: for n st P[n] holds P[n+1]
     proof
       now let n;
        assume A4: for H,I st len H = len I & len H = n &
                   for k,v st k in Seg len H & v = I.k holds H.k = a * v holds
                    Sum(H) = a * Sum(I);
       let H,I;
        assume that A5: len H = len I and A6: len H = n + 1 and
                    A7: for k,v st k in Seg len H & v = I.k holds H.k = a * v;
         reconsider p = H | (Seg n),q = I | (Seg n)
           as FinSequence of the carrier of V by FINSEQ_1:23;
A8:          n <= n + 1 by NAT_1:37;
          then A9: len p = n & len q = n by A5,A6,FINSEQ_1:21;
A10:          now let k,v;
            assume that A11: k in Seg len p and A12: v = q.k;
                len p <= len H by A6,A8,FINSEQ_1:21;
             then A13: Seg len p c= Seg len H by FINSEQ_1:7;
                dom q = Seg n by A5,A6,A8,FINSEQ_1:21;
             then I.k = q.k by A9,A11,FUNCT_1:70;
             then A14: H.k = a * v by A7,A11,A12,A13;
                dom p = Seg n by A6,A8,FINSEQ_1:21;
           hence p.k = a * v by A9,A11,A14,FUNCT_1:70;
          end;
          A15: n + 1 in Seg(n + 1) by FINSEQ_1:6;
         then reconsider v1 = H.(n + 1),v2 = I.(n + 1) as VECTOR of V
            by A5,A6,Th54;
          A16: v1 = a * v2 by A6,A7,A15;
A17:        dom q = Seg len q by FINSEQ_1:def 3;
           dom p = Seg len p by FINSEQ_1:def 3;
       hence Sum(H) = Sum(p) + v1 by A6,A9,Th55
                .= a * Sum(q) + a * v2 by A4,A9,A10,A16
                .= a * (Sum(q) + v2) by Def9
                .= a * Sum(I) by A5,A6,A9,A17,Th55;
      end;
      hence thesis;
      end;
A18:   dom F = Seg len F by FINSEQ_1:def 3;
          for n holds P[n] from NAT_1:sch 1(A1,A3);
     hence thesis by A18;
    end;

theorem
    for V being Abelian add-associative right_zeroed right_complementable
      (non empty LoopStr),
     F,G being FinSequence of the carrier of V st
   len F = len G &
  (for k for v being Element of V
     st k in dom F & v = G.k holds F.k = - v)
  holds Sum(F) = - Sum(G)
 proof
  let V be Abelian add-associative right_zeroed right_complementable
           (non empty LoopStr),
      F,G be FinSequence of the carrier of V;
  defpred P[set] means  for H,I being FinSequence of the carrier of V
      st len H = len I & len H = $1 &
        (for k for v being Element of V
         st k in Seg len H & v = I.k holds H.k = - v) holds
          Sum(H) = - Sum(I);
 A1: P[0]
  proof
    now let H,I be FinSequence of the carrier of V;
     assume that A2: len H = len I & len H = 0 and
                 for k for v being Element of V
                st k in Seg len H & v = I.k holds H.k = - v;
         Sum(H) = 0.V & Sum(I) = 0.V by A2,Lm6;
    hence Sum(H) = - Sum(I) by Th25;
   end;
   hence thesis;
   end;
 A3: for n st P[n] holds P[n+1]
  proof
     now let n;
      assume
A4:     for H,I being FinSequence of the carrier of V
          st len H = len I & len H = n &
            for k for v being Element of V
             st k in Seg len H & v = I.k holds H.k = - v holds
                  Sum(H) = - Sum(I);
     let H,I be FinSequence of the carrier of V;
      assume that A5: len H = len I and A6: len H = n + 1 and
                  A7: for k for v being Element of V
                   st k in Seg(len H) & v = I.k holds H.k = - v;
       reconsider p = H | (Seg n),q = I | (Seg n)
         as FinSequence of the carrier of V by FINSEQ_1:23;
A8:          n <= n + 1 by NAT_1:37;
        then A9: len p = n & len q = n by A5,A6,FINSEQ_1:21;
A10:          now let k; let v be Element of V;
          assume that A11: k in Seg(len p) and A12: v = q.k;
              len p <= len H by A6,A8,FINSEQ_1:21;
           then A13: Seg(len p) c= Seg(len H) by FINSEQ_1:7;
              dom q = Seg n by A5,A6,A8,FINSEQ_1:21;
           then I.k = q.k by A9,A11,FUNCT_1:70;
           then A14: H.k = - v by A7,A11,A12,A13;
              dom p = Seg n by A6,A8,FINSEQ_1:21;
         hence p.k = - v by A9,A11,A14,FUNCT_1:70;
        end;
        A15: n + 1 in Seg(n + 1) by FINSEQ_1:6;
       then reconsider v1 = H.(n + 1),v2 = I.(n + 1)
         as Element of V
          by A5,A6,Th54;
        A16: v1 = - v2 by A6,A7,A15;
A17:   dom q = Seg len q by FINSEQ_1:def 3;
     dom p = Seg len p by FINSEQ_1:def 3;
     hence Sum(H) = Sum(p) + v1 by A6,A9,Th55
              .= - Sum(q) + - v2 by A4,A9,A10,A16
              .= - (Sum(q) + v2) by Lm4
              .= - Sum(I) by A5,A6,A9,A17,Th55;
    end;
   hence thesis;
   end;
A18:   dom F = Seg len F by FINSEQ_1:def 3;
        for n holds P[n] from NAT_1:sch 1(A1,A3);
   hence thesis by A18;
 end;

Lm7: for j being natural number holds j < 1 implies j = 0 by NAT_1:39;

theorem Th58:
for V being add-associative right_zeroed (non empty LoopStr),
    F,G being FinSequence of the carrier of V
holds Sum(F ^ G) = Sum(F) + Sum(G)
  proof let V be add-associative right_zeroed (non empty LoopStr),
    F,G be FinSequence of the carrier of V;
    defpred P[set] means for G be FinSequence of the carrier of V st len G = $1
      holds Sum(F ^ G) = Sum(F) + Sum(G);
     A1: P[0]
      proof let G be FinSequence of the carrier of V;
        assume len G = 0;
        then G = <*>(the carrier of V) & G = {} by FINSEQ_1:25;
         then F ^ G = F & Sum(G) = 0.V by Lm5,FINSEQ_1:47;
       hence thesis by Def7;
      end;
     A2: for k st P[k] holds P[k+1]
      proof let k;
        assume A3: for G being FinSequence of the carrier of V st len G = k
         holds Sum(F ^ G) = Sum(F) + Sum(G);
       let H be FinSequence of the carrier of V;
        assume A4: len H = k + 1;
         reconsider p = H | (Seg k) as FinSequence of the carrier of V
           by FINSEQ_1:23;
          A5: dom H = Seg(k + 1) by A4,FINSEQ_1:def 3;
          then A6: k + 1 in dom H by FINSEQ_1:6;
          then H.(k + 1) in rng H & rng H c= the carrier of V
                                             by FINSEQ_1:def 4,FUNCT_1:def 5;
         then reconsider v = H.(k + 1) as Element of V;
          A7: k <= k + 1 by NAT_1:37;
          then A8: len p = k by A4,FINSEQ_1:21;
          then A9: dom H = Seg(len p + len<* v *>) by A5,FINSEQ_1:56;
             dom p = Seg k by A4,A7,FINSEQ_1:21;
          then A10: dom p c= dom H by A5,A7,FINSEQ_1:7;
          A11: now let n;
            assume n in dom p;
             then n in dom H & n in Seg k by A4,A7,A10,FINSEQ_1:21;
           hence p.n = H.n by FUNCT_1:72;
          end;
             now let n;
            assume n in dom<* v *>;
             then n in {1} by FINSEQ_1:4,55;
             then n = 1 by TARSKI:def 1;
           hence H.(len p + n) = <* v *>.n by A8,FINSEQ_1:def 8;
          end;
          then H = p ^ <* v *> by A9,A11,FINSEQ_1:def 7;
          then F ^ H = (F ^ p) ^ <* v *> by FINSEQ_1:45;
          then len(F ^ H) = len(F ^ p) + len<* v *> by FINSEQ_1:35;
          then A12: len(F ^ H) = len(F ^ p) + 1 by FINSEQ_1:56;
          A13: dom(F ^ p) = Seg len(F ^ p) by FINSEQ_1:def 3;
          A14: dom(F ^ H) = Seg len(F ^ H) by FINSEQ_1:def 3
                        .= Seg(len F + len H) by FINSEQ_1:35;
          A15: Seg(len(F ^ p)) = Seg(len F + len p) by FINSEQ_1:35;
             len F + len p <= len F + len H by A4,A7,A8,REAL_1:55;
          then Seg len(F ^ p) c= dom(F ^ H) by A14,A15,FINSEQ_1:7;
          then A16: dom(F ^ p) = dom(F ^ H) /\ Seg(len(F ^ p)) by A13,XBOOLE_1:
28;
             now let x be set;
            assume A17: x in dom(F ^ p);
             then reconsider n = x as Nat;
              A18: now assume n in dom F;
                then (F ^ p).n = F.n & (F ^ H).n = F.n by FINSEQ_1:def 7;
               hence (F ^ p).x = (F ^ H).x;
              end;
                 now assume not n in dom F;
                 then A19: not n in Seg(len F) by FINSEQ_1:def 3;
A20:                 1 <= n by A13,A17,FINSEQ_1:3;
                 then len F <= n by A19,FINSEQ_1:3;
                then consider j such that A21: n = len F + j by NAT_1:28;
                 A22: now assume not 1 <= j;
                   then j = 0 by Lm7;
                  hence contradiction by A19,A20,A21,FINSEQ_1:3;
                 end;
                    now assume not j <= k;
                   then len F + k < n & n <= len F + len p
                     by A13,A15,A17,A21,FINSEQ_1:3,REAL_1:53;
                  hence contradiction by A4,A7,FINSEQ_1:21;
                 end;
                 then j in Seg k by A22,FINSEQ_1:3;
                 then A23: j in dom p by A4,A7,FINSEQ_1:21;
                 then (F ^ p).n = p.j & (F ^ H).n = H.j by A10,A21,FINSEQ_1:
def 7;
               hence (F ^ p).x = (F ^ H).x by A11,A23;
              end;
           hence (F ^ p).x = (F ^ H).x by A18;
          end;

          then A24: F ^ p = (F ^ H) | (Seg len (F ^ p)) by A16,FUNCT_1:68
             .= (F ^ H) | (dom (F ^ p)) by FINSEQ_1:def 3;
A25:      dom p = Seg len p by FINSEQ_1:def 3;
           v = (F ^ H).(len F + len H) by A4,A6,FINSEQ_1:def 7
                .= (F ^ H).(len(F ^ H)) by FINSEQ_1:35;
        hence Sum(F ^ H) = Sum(F ^ p) + v by A12,A24,Th55
                      .= (Sum(F) + Sum(p)) + v by A3,A8
                      .= Sum(F) + (Sum(p) + v) by Def6
                      .= Sum(F) + Sum(H) by A4,A8,A25,Th55;
      end;
        for k holds P[k] from NAT_1:sch 1(A1,A2);
     then len G = len G implies thesis;
   hence thesis;
  end;

Lm8: for k, n being natural number holds k <> 0 implies n < n + k
  by NAT_1:41;

 reserve V for add-associative right_zeroed
             right_complementable (non empty LoopStr);
 reserve F for FinSequence of the carrier of V;
 reserve v,v1,v2,u,w for Element of V;
 reserve i,j,k,n for Nat;
 reserve p,q for FinSequence;

Lm10:
for V being add-associative right_zeroed
      right_complementable (non empty LoopStr),
    v being Element of V
holds Sum<* v *> = v
 proof let V be add-associative right_zeroed
      right_complementable (non empty LoopStr),
    v be Element of V;
    set S = <* v *>;
   consider f being Function of NAT, the carrier of V such that
A1: Sum(S) = f.(len S) and A2: f.0 = 0.V and
    A3: for j for v being Element of V
      st j < len S & v = S.(j + 1) holds
        f.(j + 1) = f.j + v by Def12;
    A4: len S = 1 by FINSEQ_1:56;
       0 < 1;
   then consider j such that A5: j < len S by A4;
    A6: j = 0 by A4,A5,Lm7;
       S.(j + 1) = S.(0 + 1) by A4,A5,Lm7
          .= v by FINSEQ_1:57;
    then f.1 = 0.V + v by A2,A3,A5,A6
             .= v by Th10;
  hence thesis by A1,FINSEQ_1:56;
 end;

theorem
    for V being Abelian add-associative right_zeroed (non empty LoopStr),
     F,G being FinSequence of the carrier of V st
   rng F = rng G & F is one-to-one & G is one-to-one
  holds Sum(F) = Sum(G)
 proof
  let V be Abelian add-associative right_zeroed (non empty LoopStr),
      F,G be FinSequence of the carrier of V;
  defpred P[set] means for H,I being FinSequence of the carrier of V
       st len H = $1 & rng H = rng I &
          H is one-to-one & I is one-to-one holds Sum(H) = Sum (I);
  A1: P[0]
   proof
      now let H,I be FinSequence of the carrier of V;
       assume that A2: len H = 0 and A3: rng H = rng I and
                         H is one-to-one & I is one-to-one;
           H = {} by A2,FINSEQ_1:25;
        then rng H = {} by FINSEQ_1:27;
        then I = {} by A3,FINSEQ_1:27;
        then len I = 0 by FINSEQ_1:25;
        then Sum(H) = 0.V & Sum(I) = 0.V by A2,Lm6;
      hence Sum(H) = Sum(I);
     end;
     hence thesis;
    end;
  A4: for k st P[k] holds P[k+1]
  proof
      now let k;
       assume
A5:     for H,I being FinSequence of the carrier of V
        st len H = k & rng H = rng I &
                  H is one-to-one & I is one-to-one holds Sum(H) = Sum(I);
      let H,I be FinSequence of the carrier of V;
       assume that A6: len H = k + 1 and A7: rng H = rng I and
                   A8: H is one-to-one and A9: I is one-to-one;
         A10: len H = len I by A7,A8,A9,FINSEQ_1:65;
        reconsider p = H | (Seg k) as FinSequence of the carrier of V
          by FINSEQ_1:23;
         A11: k + 1 in Seg(k + 1) by FINSEQ_1:6;
         then k + 1 in dom H by A6,FINSEQ_1:def 3;
         then H.(k + 1) in rng I by A7,FUNCT_1:def 5;
        then consider x such that A12: x in dom I and A13: H.(k + 1) = I.x
                                                             by FUNCT_1:def 5;
         A14: x in Seg(k + 1) by A6,A10,A12,FINSEQ_1:def 3;
        reconsider n = x as Nat by A12;
        reconsider v = H.(k + 1) as Element of V by A6,A11,Th54;
         A15: 1 <= n by A14,FINSEQ_1:3;
        then consider m1 being Nat such that A16: 1 + m1 = n by NAT_1:28;
         A17: n <= k + 1 by A14,FINSEQ_1:3;
        then consider m2 being Nat such that A18: n + m2 = k + 1 by NAT_1:28;
        reconsider q1 = I | (Seg m1) as FinSequence of the carrier of V
         by FINSEQ_1:23;
        defpred P[Nat,set] means $2 = I.(n + $1);
         A19: for j,y1,y2 st j in Seg m2 & P[j,y1] & P[j,y2] holds y1 = y2;
         A20: for j st j in Seg m2 ex x st P[j,x];
        consider q2 being FinSequence such that A21: dom q2 = Seg m2 and
         A22: for k st k in Seg m2 holds P[k,q2.k] from FINSEQ_1:sch 1
(A19,A20);
           rng q2 c= the carrier of V
         proof let x;
           assume x in rng q2;
            then consider y such that A23: y in dom q2 and A24: x = q2.y
                 by FUNCT_1:def 5;
            reconsider y as Nat by A23;
                1 <= y & y <= n + y by A21,A23,FINSEQ_1:3,NAT_1:37;
             then A25: 1 <= n + y by AXIOMS:22;
                y <= m2 by A21,A23,FINSEQ_1:3;
             then n + y <= len I by A6,A10,A18,REAL_1:55;
             then n + y in Seg(len I) by A25,FINSEQ_1:3;
            then reconsider xx = I.(n + y) as Element of V
             by Th54;
                xx in the carrier of V;
          hence thesis by A21,A22,A23,A24;
         end;
        then reconsider q2 as FinSequence of the carrier of V
         by FINSEQ_1:def 4;
        set q = q1 ^ q2;
            k <= k + 1 by NAT_1:37;
         then A26: len p = k by A6,FINSEQ_1:21;
            m1 <= n by A16,NAT_1:29;
         then A27: m1 <= k + 1 by A17,AXIOMS:22;
         then A28: len q1 = m1 & len q2 = m2
           by A6,A10,A21,FINSEQ_1:21,def 3;
         then len(q1 ^ <* v *>) + len q2 = len q1 + len<* v *> + m2
                                                            by FINSEQ_1:35
                                   .= k + 1 by A16,A18,A28,FINSEQ_1:57;
         then A29: dom I = Seg(len(q1 ^ <* v *>) + len q2)
          by A6,A10,FINSEQ_1:def 3;
         A30: now let j;
           assume A31: j in dom(q1 ^ <* v *>);
               len(q1 ^ <* v *>) = m1 + len <* v *> by A28,FINSEQ_1:35
                             .= m1 + 1 by FINSEQ_1:57;
            then j in Seg(m1 + 1) by A31,FINSEQ_1:def 3;
            then A32: j in Seg m1 \/ {n} by A16,FINSEQ_1:11;

            A33: now assume j in Seg m1;
              then A34: j in dom q1 by A6,A10,A27,FINSEQ_1:21;
              then q1.j = I.j by FUNCT_1:70;
             hence I.j = (q1 ^ <* v *>).j by A34,FINSEQ_1:def 7;
            end;
               now assume j in {n};
              then A35: j = n by TARSKI:def 1;
                 1 in Seg 1 & len<* v *> = 1 by FINSEQ_1:3,56;
              then 1 in dom <* v *> by FINSEQ_1:def 3;
              then (q1 ^ <* v *>).(len q1 + 1) = <* v *>.1 by FINSEQ_1:def 7;
             hence (q1 ^ <* v *>).j = I.j by A13,A16,A28,A35,FINSEQ_1:57;
            end;
          hence I.j = (q1 ^ <* v *>).j by A32,A33,XBOOLE_0:def 2;
         end;
            now let j;
           assume A36: j in dom q2;
               len(q1 ^ <* v *>) = m1 + len<* v *> by A28,FINSEQ_1:35
                             .= n by A16,FINSEQ_1:56;
          hence I.(len(q1 ^ <* v *>) + j) = q2.j by A21,A22,A36;
         end;
         then A37: I = q1 ^ <* v *> ^ q2 by A29,A30,FINSEQ_1:def 7;
         then A38: rng I = rng(q1 ^ <* v *>) \/ rng q2 by FINSEQ_1:44
                  .= rng <* v *> \/ rng q1 \/ rng q2 by FINSEQ_1:44
                  .= {v} \/ rng q1 \/ rng q2 by FINSEQ_1:56
                  .= {v} \/ (rng q1 \/ rng q2) by XBOOLE_1:4
                  .= {v} \/ rng q by FINSEQ_1:44;
         A39: m1 < n by A16,REAL_1:69;
            {v} misses rng q
          proof assume not thesis;
             then A40: {v} /\ rng q <> {} by XBOOLE_0:def 7;
            consider y being Element of {v} /\ rng q;
                 y in rng q by A40,XBOOLE_0:def 3;
             then A41: y in rng q1 \/ rng q2 by FINSEQ_1:44;
A42:             y in {v} by A40,XBOOLE_0:def 3;
             then A43: y = I.n by A13,TARSKI:def 1;
             A44: now assume y in rng q1;
               then consider y1 such that A45: y1 in dom q1 and A46: y = q1.y1
                                                           by FUNCT_1:def 5;
                A47: y1 in Seg m1 by A6,A10,A27,A45,FINSEQ_1:21;
               reconsider y1 as Nat by A45;
                A48: q1.y1 = I.y1 by A45,FUNCT_1:70;
                A49: y1 <= m1 by A47,FINSEQ_1:3;
                A50: y1 <> n by A39,A47,FINSEQ_1:3;
                   1 <= y1 & y1 <= k + 1 by A27,A47,A49,AXIOMS:22,FINSEQ_1:3;
                then y1 in Seg(k + 1) by FINSEQ_1:3;
                then y1 in dom I & n in dom I & I.y1 = I.n
                            by A6,A10,A12,A13,A42,A46,A48,FINSEQ_1:def 3,TARSKI
:def 1;
              hence contradiction by A9,A50,FUNCT_1:def 8;
             end;
                now assume y in rng q2;
               then consider y1 such that A51: y1 in dom q2 and A52: y = q2.y1
                                                                 by FUNCT_1:def
5;
               reconsider y1 as Nat by A51;
                A53: I.n = I.(n + y1) by A21,A22,A43,A51,A52;
                A54: 1 <= n + y1 by A15,NAT_1:37;
                   y1 <= m2 by A21,A51,FINSEQ_1:3;
                then n + y1 <= k + 1 by A18,REAL_1:55;
                then n + y1 in Seg(k + 1) by A54,FINSEQ_1:3;
                then n in dom I & n + y1 in dom I by A6,A10,A12,FINSEQ_1:def 3
;
                then A55: n = n + y1 by A9,A53,FUNCT_1:def 8;
                   y1 <> 0 by A21,A51,FINSEQ_1:3;
              hence contradiction by A55,Lm8;
             end;
           hence thesis by A41,A44,XBOOLE_0:def 2;
          end;
         then A56: rng q = rng I \ {v} by A38,XBOOLE_1:88;
         A57: Seg k = Seg(k + 1) \ {k + 1} by FINSEQ_1:12;
         A58: rng p = H .: (Seg k) by RELAT_1:148;
         A59: Seg(k + 1) = dom H by A6,FINSEQ_1:def 3;
         then A60: rng H = H .: (Seg(k + 1)) by RELAT_1:146;
            H .: (Seg k) = H .: Seg(k + 1) \ H .: {k + 1} by A8,A57,FUNCT_1:123
;
         then A61: rng p = rng q by A7,A11,A56,A58,A59,A60,FUNCT_1:117;
         A62: p is one-to-one by A8,FUNCT_1:84;
A63:         q is one-to-one
          proof let y1,y2 be set;
            assume that A64: y1 in dom q and A65: y2 in dom q and A66: q.y1 = q
.y2;
               reconsider x1 = y1, x2 = y2 as Nat by A64,A65;
              A67: q1 is one-to-one by A9,FUNCT_1:84;
              A68: now assume A69: x1 in dom q1 & x2 in dom q1;
                then q1.x1 = q.x1 & q1.x2 = q.x2 by FINSEQ_1:def 7;
               hence thesis by A66,A67,A69,FUNCT_1:def 8;
              end;
              A70: now assume A71: x1 in dom q1;
                given j such that A72: j in dom q2 and A73: x2 = len q1 + j;
                    q1.x1 = I.x1 by A71,FUNCT_1:70;
                 then A74: q.x1 = I.x1 by A71,FINSEQ_1:def 7;
                    q2.j = I.(n + j) by A21,A22,A72;
                 then A75: I.x1 = I.(n + j) by A66,A72,A73,A74,FINSEQ_1:def 7;
                    x1 in Seg m1 by A6,A10,A27,A71,FINSEQ_1:21;
                 then A76: 1 <= x1 & x1 <= m1 by FINSEQ_1:3;
                 then A77: x1 <= k + 1 by A27,AXIOMS:22;
                 A78: 1 <= n + j by A15,NAT_1:37;
                    j <= m2 by A21,A72,FINSEQ_1:3;
                 then n + j <= k + 1 by A18,REAL_1:55;
                 then n + j in Seg(k + 1) & x1 in Seg(k + 1)
                                               by A76,A77,A78,FINSEQ_1:3;
                 then A79: x1 in dom I & n + j in
 dom I by A6,A10,FINSEQ_1:def 3;
                    x1 < n & n <= n + j by A39,A76,AXIOMS:22,NAT_1:37;
               hence thesis by A9,A75,A79,FUNCT_1:def 8;
              end;
              A80: now assume A81: x2 in dom q1;
                given j such that A82: j in dom q2 and A83: x1 = len q1 + j;
                    q1.x2 = I.x2 by A81,FUNCT_1:70;
                 then A84: q.x2 = I.x2 by A81,FINSEQ_1:def 7;
                    q2.j = I.(n + j) by A21,A22,A82;
                 then A85: I.x2 = I.(n + j) by A66,A82,A83,A84,FINSEQ_1:def 7;
                    x2 in Seg m1 by A6,A10,A27,A81,FINSEQ_1:21;
                 then A86: 1 <= x2 & x2 <= m1 by FINSEQ_1:3;
                 then A87: x2 <= k + 1 by A27,AXIOMS:22;
                 A88: 1 <= n + j by A15,NAT_1:37;
                    j <= m2 by A21,A82,FINSEQ_1:3;
                 then n + j <= k + 1 by A18,REAL_1:55;
                 then n + j in Seg(k + 1) & x2 in Seg(k + 1)
                                               by A86,A87,A88,FINSEQ_1:3;
                 then A89: x2 in dom I & n + j in
 dom I by A6,A10,FINSEQ_1:def 3;
                    x2 < n & n <= n + j by A39,A86,AXIOMS:22,NAT_1:37;
               hence thesis by A9,A85,A89,FUNCT_1:def 8;
              end;
                 now
                given j1 being Nat such that A90: j1 in dom q2 and
                                             A91: x1 = len q1 + j1;
                given j2 being Nat such that A92: j2 in dom q2 and
                                             A93: x2 = len q1 + j2;
                 A94: q2.j1 = I.(n + j1) & q2.j2 = I.(n + j2) by A21,A22,A90,
A92;
                 A95: q2.j1 = q.(m1 + j2) by A28,A66,A90,A91,A93,FINSEQ_1:def 7
                               .= q2.j2 by A28,A92,FINSEQ_1:def 7;
                 A96: 1 <= n + j1 & 1 <= n + j2 by A15,NAT_1:37;
                    j1 <= m2 & j2 <= m2 by A21,A90,A92,FINSEQ_1:3;
                 then n + j1 <= k + 1 & n + j2 <= k + 1 by A18,REAL_1:55;
                 then n + j1 in Seg(k + 1) & n + j2 in Seg(k + 1)
                                                     by A96,FINSEQ_1:3;
                 then n + j1 in dom I & n + j2 in
 dom I by A6,A10,FINSEQ_1:def 3;
                 then n + j1 = n + j2 by A9,A94,A95,FUNCT_1:def 8;
               hence thesis by A91,A93,XCMPLX_1:2;
              end;
            hence thesis by A64,A65,A68,A70,A80,FINSEQ_1:38;
           end;
A97: len<* v *> = 1 by FINSEQ_1:56;
A98: for k st k in dom p holds H.k=p.k by FUNCT_1:70;
            now let k;
          assume k in dom<* v *>;
           then k in Seg 1 by FINSEQ_1:55;
            then k = 1 by FINSEQ_1:4,TARSKI:def 1;
          hence H.(len p + k) = <* v *>.k by A26,FINSEQ_1:57;
         end;
         then H = p ^ <* v *> by A26,A59,A97,A98,FINSEQ_1:def 7;
         then A99: Sum(H) = Sum(p) + Sum<* v *> by Th58;
            Sum(I) = Sum(q1 ^ <* v *>) + Sum(q2) by A37,Th58
                  .= (Sum(q1) + Sum<* v *>) + Sum(q2) by Th58
                  .= Sum<* v *> + (Sum(q1) + Sum(q2)) by Def6
                  .= Sum(q) + Sum<* v *> by Th58;
       hence Sum(H) = Sum(I) by A5,A26,A61,A62,A63,A99;
      end;
    hence thesis;
    end;
      A100: for k holds P[k] from NAT_1:sch 1(A1,A4);
         len F = len F;
    hence thesis by A100;
   end;

theorem
     for V being non empty LoopStr holds
    Sum(<*>(the carrier of V)) = 0.V by Lm5;

theorem
   for V being add-associative right_zeroed
       right_complementable (non empty LoopStr),
    v being Element of V
holds Sum<* v *> = v by Lm10;

theorem Th62:
for V being add-associative right_zeroed
       right_complementable (non empty LoopStr),
    v,u being Element of V
holds Sum<* v,u *> = v + u
  proof let V be add-associative right_zeroed
       right_complementable (non empty LoopStr),
    v,u be Element of V;
       <* v,u *> = <* v *> ^ <* u *> by FINSEQ_1:def 9;
   hence Sum<* v,u *> = Sum<* v *> + Sum<* u *> by Th58
                   .= v + Sum<* u *> by Lm10
                   .= v + u by Lm10;
  end;

theorem Th63:
for V being add-associative right_zeroed
       right_complementable (non empty LoopStr),
    v,u,w being Element of V
holds Sum<* v,u,w *> = v + u + w
  proof let V be add-associative right_zeroed
       right_complementable (non empty LoopStr),
    v,u,w be Element of V;
       <* v,u,w *> = <* v,u *> ^ <* w *> by FINSEQ_1:60;
   hence Sum<* v,u,w *> = Sum<* v,u *> + Sum<* w *> by Th58
                     .= Sum<* v,u *> + w by Lm10
                     .= v + u + w by Th62;
  end;

theorem
    for V being RealLinearSpace, a being Real
 holds a * Sum(<*>(the carrier of V)) = 0.V
  proof let V be RealLinearSpace, a be Real;
   thus a * Sum(<*>(the carrier of V)) = a * 0.V by Lm5
                                    .= 0.V by Th23;
  end;

canceled;

theorem
    for V being RealLinearSpace, a being Real,
  v,u being VECTOR of V
 holds a * Sum<* v,u *> = a * v + a * u
  proof
   let V be RealLinearSpace, a be Real,
       v,u be VECTOR of V;
   thus a * Sum<* v,u *> = a * (v + u) by Th62
                      .= a * v + a * u by Def9;
  end;

theorem
    for V being RealLinearSpace, a being Real,
  v,u,w being VECTOR of V
 holds a * Sum<* v,u,w *> = a * v + a * u + a * w
  proof
   let V be RealLinearSpace, a be Real,
       v,u,w be VECTOR of V;
   thus a * Sum<* v,u,w *> = a * (v + u + w) by Th63
                        .= a * (v + u) + a * w by Def9
                        .= a * v + a * u + a * w by Def9;
  end;

theorem
    - Sum(<*>(the carrier of V)) = 0.V
  proof
   thus - Sum(<*>(the carrier of V)) = - 0.V by Lm5
                                  .= 0.V by Th25;
  end;

theorem
    - Sum<* v *> = - v by Lm10;

theorem
    for V being Abelian add-associative right_zeroed
  right_complementable (non empty LoopStr),
     v,u being Element of V
 holds - Sum<* v,u *> = (- v) - u
  proof
   let V be Abelian add-associative right_zeroed
    right_complementable (non empty LoopStr),
     v,u be Element of V;
   thus - Sum<* v,u *> = - (v + u) by Th62
                    .= (- v) - u by Th44;
  end;

theorem
    for V being Abelian add-associative right_zeroed right_complementable
               (non empty LoopStr),
     v,u,w being Element of V
 holds - Sum<* v,u,w *> = ((- v) - u) - w
  proof
   let V be Abelian add-associative right_zeroed right_complementable
             (non empty LoopStr),
     v,u,w be Element of V;
   thus - Sum<* v,u,w *> = - (v + u + w) by Th63
                      .= (- (v + u)) - w by Th44
                      .= ((- v) - u) - w by Th44;
  end;

theorem
    for V being Abelian add-associative right_zeroed right_complementable
               (non empty LoopStr),
     v,w being Element of V
 holds Sum<* v,w *> = Sum<* w,v *>
  proof
   let V be Abelian add-associative right_zeroed right_complementable
            (non empty LoopStr),
     v,w be Element of V;
   thus Sum<* v,w *> = v + w by Th62
                  .= Sum<* w,v *> by Th62;
  end;

theorem
    Sum<* v,w *> = Sum<* v *> + Sum<* w *>
  proof
   thus Sum<* v,w *> = v + w by Th62
                  .= Sum<* v *> + w by Lm10
                  .= Sum<* v *> + Sum<* w *> by Lm10;
  end;

theorem
    Sum<* 0.V,0.V *> = 0.V
  proof
   thus Sum<* 0.V,0.V *> = 0.V + 0.V by Th62
                      .= 0.V by Th10;
  end;

theorem
    Sum<* 0.V,v *> = v & Sum<* v,0.V *> = v
  proof
   thus Sum<* 0.V,v *> = 0.V + v by Th62
                    .= v by Th10;
   thus Sum<* v,0.V *> = v + 0.V by Th62
                    .= v by Th10;
  end;

theorem
    Sum<* v,- v *> = 0.V & Sum<* - v,v *> = 0.V
  proof
A1:   v + - v = 0.V by Def10;
   hence Sum<* v,- v *> = 0.V by Th62;
        - v + v = 0.V by A1,Lm2;
   hence Sum<* - v, v *> = 0.V by Th62;
  end;

theorem
    Sum<* v,- w *> = v - w
  proof
   thus Sum<* v,- w *> = v + (- w) by Th62
                    .= v - w by Def11;
  end;

theorem Th78:
 Sum<* - v,- w *> = - (w + v)
  proof
   thus Sum<* - v,- w *> = (- v) + (- w) by Th62
                      .= - (w + v) by Lm4;
  end;

theorem Th79:
 for V being RealLinearSpace, v being VECTOR of V
 holds Sum<* v,v *> = 2 * v
  proof let V be RealLinearSpace, v be VECTOR of V;
   thus Sum<* v,v *> = v + v by Th62
                  .= 1 * v + v by Def9
                  .= 1 * v + 1 * v by Def9
                  .= (1 + 1) * v by Def9
                  .= 2 * v;
  end;

theorem
    for V being RealLinearSpace, v being VECTOR of V
 holds Sum<* - v,- v *> = (- 2) * v
  proof let V be RealLinearSpace, v be VECTOR of V;
   thus Sum<* - v,- v *> = - (v + v) by Th78
                      .= - Sum<* v,v *> by Th62
                      .= - (2 * v) by Th79
                      .= (- 1) * (2 * v) by Th29
                      .= ((- 1) * 2) * v by Def9
                      .= (- 2) * v;
  end;

theorem
    Sum<* u,v,w *> = Sum<* u *> + Sum<* v *> + Sum<* w *>
  proof
   thus Sum<* u,v,w *> = u + v + w by Th63
                    .= Sum<* u *> + v + w by Lm10
                    .= Sum<* u *> + v + Sum<* w *> by Lm10
                    .= Sum<* u *> + Sum<* v *> + Sum<* w *> by Lm10;
  end;

theorem
    Sum<* u,v,w *> = Sum<* u,v *> + w
  proof
   thus Sum<* u,v,w *> = u + v + w by Th63
                    .= Sum<* u,v *> + w by Th62;
  end;

theorem
    for V being Abelian add-associative right_zeroed right_complementable
                 (non empty LoopStr),
     v,u,w being Element of V
 holds Sum<* u,v,w *> = Sum<* v,w *> + u
  proof
   let V be Abelian add-associative right_zeroed right_complementable
                 (non empty LoopStr),
     v,u,w be Element of V;
   thus Sum<* u,v,w *> = u + v + w by Th63
                    .= u + (v + w) by Def6
                    .= Sum<* v,w *> + u by Th62;
  end;

theorem Th84:
 for V being Abelian add-associative right_zeroed right_complementable
                (non empty LoopStr),
     v,u,w being Element of V
 holds Sum<* u,v,w *> = Sum<* u,w *> + v
  proof
   let V be Abelian add-associative right_zeroed right_complementable
              (non empty LoopStr),
     v,u,w be Element of V;
   thus Sum<* u,v,w *> = u + v + w by Th63
                    .= u + w + v by Def6
                    .= Sum<* u,w *> + v by Th62;
  end;

theorem Th85:
 for V being Abelian add-associative right_zeroed right_complementable
                  (non empty LoopStr),
     v,u,w being Element of V
 holds Sum<* u,v,w *> = Sum<* u,w,v *>
  proof
   let V be Abelian add-associative right_zeroed right_complementable
                 (non empty LoopStr),
     v,u,w be Element of V;
   thus Sum<* u,v,w *> = u + v + w by Th63
                    .= u + w + v by Def6
                    .= Sum<* u,w,v *> by Th63;
  end;

theorem Th86:
 for V being Abelian add-associative right_zeroed right_complementable
                (non empty LoopStr),
     v,u,w being Element of V
 holds Sum<* u,v,w *> = Sum<* v,u,w *>
  proof
   let V be Abelian add-associative right_zeroed right_complementable
               (non empty LoopStr),
     v,u,w be Element of V;
   thus Sum<* u,v,w *> = u + v + w by Th63
                    .= Sum<* v,u,w *> by Th63;
  end;

theorem Th87:
 for V being Abelian add-associative right_zeroed right_complementable
                (non empty LoopStr),
     v,u,w being Element of V
 holds Sum<* u,v,w *> = Sum<* v,w,u *>
  proof
   let V be Abelian add-associative right_zeroed right_complementable
              (non empty LoopStr),
     v,u,w be Element of V;
   thus Sum<* u,v,w *> = Sum<* v,u,w *> by Th86
                    .= Sum<* v,w,u *> by Th85;
  end;

canceled;

theorem
    for V being Abelian add-associative right_zeroed right_complementable
                (non empty LoopStr),
     v,u,w being Element of V
 holds Sum<* u,v,w *> = Sum<* w,v,u *>
  proof
   let V be Abelian add-associative right_zeroed right_complementable
              (non empty LoopStr),
     v,u,w be Element of V;
   thus Sum<* u,v,w *> = Sum<* w,u,v *> by Th87
                    .= Sum<* w,v,u *> by Th85;
  end;

theorem
    Sum<* 0.V,0.V,0.V *> = 0.V
  proof
   thus Sum<* 0.V,0.V,0.V *> = 0.V + 0.V + 0.V by Th63
                          .= 0.V + 0.V by Th10
                          .= 0.V by Th10;
  end;

theorem
    Sum<* 0.V,0.V,v *> = v & Sum<* 0.V,v,0.V *> = v & Sum<* v,0.V,0.V *> = v
  proof
   thus Sum<* 0.V,0.V,v *> = 0.V + 0.V + v by Th63
                        .= 0.V + v by Th10
                        .= v by Th10;
   thus Sum<* 0.V,v,0.V *> = 0.V + v + 0.V by Th63
                        .= 0.V + v by Th10
                        .= v by Th10;
   thus Sum<* v,0.V,0.V *> = v + 0.V + 0.V by Th63
                        .= v + 0.V by Th10
                        .= v by Th10;
  end;

theorem
    Sum<* 0.V,u,v *> = u + v & Sum<* u,v,0.V *> = u + v & Sum<* u,0.V,v *> = u
+
v
  proof
   thus Sum<* 0.V,u,v *> = 0.V + u + v by Th63
                      .= u + v by Th10;
   thus Sum<* u,v,0.V *> = u + v + 0.V by Th63
                      .= u + v by Th10;
   thus Sum<* u,0.V,v *> = u + 0.V + v by Th63
                      .= u + v by Th10;
  end;

theorem
    for V being RealLinearSpace, v being VECTOR of V
 holds Sum<* v,v,v *> = 3 * v
  proof let V be RealLinearSpace, v be VECTOR of V;
   thus Sum<* v,v,v *> = Sum<* v,v *> + v by Th84
                    .= 2 * v + v by Th79
                    .= 2 * v + 1 * v by Def9
                    .= (2 + 1) * v by Def9
                    .= 3 * v;
  end;

theorem
    len F = 0 implies Sum(F) = 0.V by Lm6;

theorem
    len F = 1 implies Sum(F) = F.1
  proof assume A1: len F = 1;
     then dom F = {1} by FINSEQ_1:4,def 3;
     then 1 in dom F by TARSKI:def 1;
     then F.1 in
 rng F & rng F c= the carrier of V by FINSEQ_1:def 4,FUNCT_1:def 5;
    then reconsider v = F.1 as Element of V;
        F = <* v *> by A1,FINSEQ_1:57;
   hence thesis by Lm10;
  end;

theorem
    len F = 2 & v1 = F.1 & v2 = F.2 implies Sum(F) = v1 + v2
  proof assume len F = 2 & v1 = F.1 & v2 = F.2;
    then F = <* v1,v2 *> by FINSEQ_1:61;
   hence thesis by Th62;
  end;

theorem
    len F = 3 & v1 = F.1 & v2 = F.2 & v = F.3 implies Sum(F) = v1 + v2 + v
  proof assume len F = 3 & v1 = F.1 & v2 = F.2 & v = F.3;
    then F = <* v1,v2,v *> by FINSEQ_1:62;
   hence thesis by Th63;
  end;

definition
  let R be non empty ZeroStr,
      a be Element of R;
  attr a is non-zero means
      a <> 0.R;
end;
