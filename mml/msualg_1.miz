:: Many Sorted Algebras
::  by Andrzej Trybulec
::
:: Received April 21, 1994
:: Copyright (c) 1994 Association of Mizar Users

environ

 vocabularies ZF_REFLE, PBOOLE, BOOLE, RELAT_1, FUNCT_1, PRALG_1, TDGROUP,
      CARD_3, FINSEQ_2, FINSEQ_1, FUNCOP_1, FUNCT_2, AMI_1, QC_LANG1, UNIALG_1,
      PARTFUN1, REALSET1, MSUALG_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, NAT_1, RELAT_1, FUNCT_1,
      FUNCT_2, FINSEQ_1, STRUCT_0, FUNCOP_1, PARTFUN1, FINSEQ_2, CARD_3,
      PBOOLE, REALSET2, UNIALG_1;
 constructors REALSET2, PRALG_1, MEMBERED, XBOOLE_0;
 registrations FUNCT_1, PBOOLE, UNIALG_1, TEX_2, RELSET_1, STRUCT_0, FINSEQ_2,
      FUNCOP_1, ARYTM_3, XBOOLE_0, ORDINAL2;
 requirements BOOLE, SUBSET;
 definitions TARSKI, FINSEQ_1, FUNCT_1, PBOOLE, STRUCT_0, XBOOLE_0, FUNCOP_1,
      UNIALG_1;
 theorems TARSKI, FUNCT_1, PARTFUN1, FINSEQ_1, FUNCOP_1, UNIALG_1, PBOOLE,
      FUNCT_2, CARD_3, FINSEQ_3, FINSEQ_2, REALSET2, RELAT_1, RELSET_1,
      STRUCT_0;
 schemes FRAENKEL;

begin

reserve i,j for set,
        I for set;

canceled 5;

definition canceled 4; end;

begin :: Many Sorted Signatures

definition
 struct(1-sorted) ManySortedSign
       (# carrier -> set,
         OperSymbols -> set,
         Arity -> Function of the OperSymbols, the carrier*,
         ResultSort -> Function of the OperSymbols, the carrier
       #);
end;

definition let IT be ManySortedSign;
 attr IT is void means
:Def5: the OperSymbols of IT = {};
end;

registration
 cluster void strict non empty ManySortedSign;
 existence
  proof
       {} in {{}}* by FINSEQ_1:66;
    then reconsider f = {}-->{} as Function of {},{{}}* by FUNCOP_1:58;
    reconsider g = {}-->{} as Function of {},{{}};
   take ManySortedSign(#{{}},{},f,g#);
   thus thesis by Def5,STRUCT_0:def 1;
  end;
 cluster non void strict non empty ManySortedSign;
  existence
  proof
       {} in {{}}* by FINSEQ_1:66;
    then reconsider f = {{}}-->{} as Function of {{}},{{}}* by FUNCOP_1:58;
    reconsider g = {{}}-->{} as Function of {{}},{{}};
   take ManySortedSign(#{{}},{{}},f,g#);
   thus thesis by Def5,STRUCT_0:def 1;
  end;
end;

reserve S for non empty ManySortedSign;

definition let S;
 mode SortSymbol of S is Element of S;
 mode OperSymbol of S is Element of the OperSymbols of S;
end;

definition let S be non void non empty ManySortedSign;
 let o be OperSymbol of S;
 func the_arity_of o -> Element of (the carrier of S)* equals
:Def6:  (the Arity of S).o;
 coherence
  proof the OperSymbols of S <> {} by Def5;
    then o in the OperSymbols of S;
    then o in dom(the Arity of S) by FUNCT_2:def 1;
then A1:   (the Arity of S).o in rng(the Arity of S) by FUNCT_1:def 5;
       rng(the Arity of S) c= (the carrier of S)* by RELSET_1:12;
    hence thesis by A1;
  end;
 correctness;
 func the_result_sort_of o -> Element of S equals
     (the ResultSort of S).o;
 coherence
  proof the OperSymbols of S <> {} by Def5;
    then o in the OperSymbols of S;
    then o in dom(the ResultSort of S) by FUNCT_2:def 1;
    then A2:   (the ResultSort of S).o in rng(the ResultSort of S) by
FUNCT_1:def 5;
       rng(the ResultSort of S) c= the carrier of S by RELSET_1:12;
    hence thesis by A2;
  end;
end;

begin :: Many Sorted Algebras

definition let S be 1-sorted;
 struct many-sorted over S (# Sorts -> ManySortedSet of the carrier of S #);
end;

definition let S;
 struct(many-sorted over S) MSAlgebra over S (#
      Sorts -> ManySortedSet of the carrier of S,
      Charact -> ManySortedFunction of
       (the Sorts)# * the Arity of S, the Sorts * the ResultSort of S#);
end;

definition let S be 1-sorted; let A be many-sorted over S;
 attr A is non-empty means
:Def8: the Sorts of A is non-empty;
end;

registration let S;
 cluster strict non-empty MSAlgebra over S;
 existence
  proof
      dom((the carrier of S) --> {0}) = the carrier of S by FUNCOP_1:19;
   then reconsider s = (the carrier of S) --> {0}
            as ManySortedSet of the carrier of S by PBOOLE:def 3;
   consider o being ManySortedFunction of
       s# * the Arity of S, s * the ResultSort of S;
   take MSAlgebra(#s,o#);
   thus MSAlgebra(#s,o#) is strict;
   let i be set;
   assume i in the carrier of S;
   hence thesis by FUNCOP_1:13;
  end;
end;

registration let S be 1-sorted;
  cluster strict non-empty many-sorted over S;
  existence
  proof
      dom ((the carrier of S) --> {0}) = the carrier of S by FUNCOP_1:19;
   then reconsider s = (the carrier of S) --> {0}
            as ManySortedSet of the carrier of S by PBOOLE:def 3;
   take many-sorted(#s#);
   thus many-sorted (#s#) is strict;
   let i be set;
   assume i in the carrier of S;
   hence thesis by FUNCOP_1:13;
  end;
end;

registration let S be 1-sorted; let A be non-empty many-sorted over S;
 cluster the Sorts of A -> non-empty;
  coherence by Def8;
end;

registration let S; let A be non-empty MSAlgebra over S;
 cluster -> non empty Component of the Sorts of A;
  coherence
   proof let C be Component of the Sorts of A;
        ex i st i in the carrier of S & C = (the Sorts of A).i by PBOOLE:150;
    hence thesis by PBOOLE:def 16;
   end;
 cluster -> non empty Component of (the Sorts of A)#;
  coherence
   proof let C be Component of (the Sorts of A)#;
     ex i st i in (the carrier of S)* & C = (the Sorts of A)#.i by PBOOLE:150;
    hence thesis by PBOOLE:def 16;
   end;
end;

definition let S be non void non empty ManySortedSign;
 let o be OperSymbol of S; let A be MSAlgebra over S;
 func Args(o,A) -> Component of (the Sorts of A)# equals
:Def9:  ((the Sorts of A)# * the Arity of S).o;
 coherence
  proof
       the OperSymbols of S <> {} by Def5;
    then o in the OperSymbols of S;
    then o in dom((the Sorts of A)# * the Arity of S) by PBOOLE:def 3;
    then ((the Sorts of A)# * the Arity of S).o
         in rng((the Sorts of A)# * the Arity of S) by FUNCT_1:def 5;
   hence thesis by FUNCT_1:25;
  end;
 correctness;
 func Result(o,A) -> Component of the Sorts of A equals
:Def10: ((the Sorts of A) * the ResultSort of S).o;
 coherence
  proof
       the OperSymbols of S <> {} by Def5;
    then o in the OperSymbols of S;
    then o in dom((the Sorts of A) * the ResultSort of S) by PBOOLE:def 3;
    then ((the Sorts of A) * the ResultSort of S).o
         in rng((the Sorts of A) * the ResultSort of S) by FUNCT_1:def 5;
   hence thesis by FUNCT_1:25;
  end;
 correctness;
end;

definition let S be non void non empty ManySortedSign;
 let o be OperSymbol of S; let A be MSAlgebra over S;
 func Den(o,A) -> Function of Args(o,A), Result(o,A) equals
:Def11:  (the Charact of A).o;
 coherence
  proof
    A1: the OperSymbols of S <> {} by Def5;
       Result(o,A) = ((the Sorts of A) * the ResultSort of S).o &
    Args(o,A) = ((the Sorts of A)# * the Arity of S).o by Def9,Def10;
   hence thesis by A1,PBOOLE:def 18;
  end;
end;

theorem
 for S being non void non empty ManySortedSign, o being OperSymbol of S,
     A being non-empty MSAlgebra over S
  holds Den(o,A) is non empty by FUNCT_2:def 1,RELAT_1:60;

begin :: On the one-sorted algebras

 reserve D for non empty set,
         n for Nat;

 Lm1:
 for h being homogeneous quasi_total non empty PartFunc of D*,D
  holds dom h = (arity h)-tuples_on D
 proof let h be homogeneous quasi_total non empty PartFunc of D*,D;
A1: dom h c= D* by RELSET_1:12;
  thus dom h c= (arity h)-tuples_on D
   proof let x be set;
    assume
A2:   x in dom h;
     then reconsider f = x as FinSequence of D by A1,FINSEQ_1:def 11;
A3:   len f = arity h by A2,UNIALG_1:def 10;
        f is Element of (len f)-tuples_on D by FINSEQ_2:110;
    hence x in (arity h)-tuples_on D by A3;
   end;
  let x be set;
  assume x in (arity h)-tuples_on D;
   then reconsider f = x as Element of (arity h)-tuples_on D;
   consider x0 being Element of dom h;
   A4: dom h <> {} by RELAT_1:64;
   then x0 in dom h;
   then reconsider x0 as FinSequence of D by A1,FINSEQ_1:def 11;
      len x0 = arity h by A4,UNIALG_1:def 10 .= len f by FINSEQ_2:109;
  hence x in dom h by A4,UNIALG_1:def 2;
 end;

theorem Th7:
 for C being set, A,B being non empty set,
     F being PartFunc of C,A, G being Function of A,B
 holds G*F is Function of dom F,B
 proof let C be set; let A,B be non empty set;
 let F be PartFunc of C,A; let G be Function of A,B;
     now dom G = A by FUNCT_2:def 1;
    then rng F c= dom G by RELSET_1:12;
   hence dom(G*F) = dom F by RELAT_1:46;
   thus rng(G*F) c= B by RELSET_1:12;
  end;
 hence G*F is Function of dom F,B by FUNCT_2:def 1,RELSET_1:11;
end;

theorem Th8:
 for h being homogeneous quasi_total non empty PartFunc of D*,D
  holds dom h = Funcs(Seg(arity h),D)
  proof let h be homogeneous quasi_total non empty PartFunc of D*,D;
   thus dom h = (arity h)-tuples_on D by Lm1
             .= Funcs(Seg(arity h),D) by FINSEQ_2:111;
  end;

theorem Th9:
 for A being Universal_Algebra holds signature A is non empty
  proof let A be Universal_Algebra;
       len(the charact of A) <> 0 by FINSEQ_1:25;
    then len(signature A) <> 0 by UNIALG_1:def 11;
   hence signature A is non empty by FINSEQ_1:25;
  end;

begin :: Relationship to one sorted algebras

definition let A be Universal_Algebra;
 redefine func signature A -> FinSequence of NAT;
 coherence;
end;

definition let IT be ManySortedSign;
 attr IT is segmental means
:Def12:  ex n st the OperSymbols of IT = Seg n;
end;

theorem Th10:
 for S being non empty ManySortedSign st S is trivial
 for A being MSAlgebra over S,
     c1,c2 being Component of the Sorts of A holds c1 = c2
 proof let S be non empty ManySortedSign such that
A1: S is trivial;
  let A be MSAlgebra over S, c1,c2 be Component of the Sorts of A;
   consider i1 being set such that
A2: i1 in the carrier of S and
A3: c1 = (the Sorts of A).i1 by PBOOLE:150;
   consider i2 being set such that
A4: i2 in the carrier of S and
A5: c2 = (the Sorts of A).i2 by PBOOLE:150;
  thus c1 = c2 by A1,A2,A3,A4,A5,REALSET2:def 7;
 end;

Lm2:
 for A being Universal_Algebra
 for f being Function of dom signature A, {0}*
  st f = (*-->0)*(signature A)
 holds
 ManySortedSign
    (#{0},dom signature(A),f,dom signature(A)-->0#)
    is non empty segmental trivial non void strict
  proof let A be Universal_Algebra;
   let f be Function of dom signature A, {0}* such that
     f = (*-->0)*(signature A);
   set S = ManySortedSign(#{0},dom signature(A),f,dom signature(A)-->0#);
   thus
      the carrier of S is non empty;
       signature A <> {} by Th9;
    then A1: the OperSymbols of S <> {} by RELAT_1:64;
       S is segmental
     proof
      take len signature(A);
      thus the OperSymbols of S = Seg len signature(A) by FINSEQ_1:def 3;
     end;
   hence thesis by A1,Def5,REALSET2:def 5;
  end;

registration
 cluster segmental trivial non void strict non empty ManySortedSign;
 existence
  proof consider A being Universal_Algebra;
    reconsider f = (*-->0)*(signature A) as Function of dom signature A, {0}*
             by Th7;
       ManySortedSign(#{0},dom signature(A),f,dom signature(A)-->0#)
     is segmental trivial non void strict non empty by Lm2;
   hence thesis;
  end;
end;

definition let A be Universal_Algebra;
 func MSSign A -> non void strict segmental trivial ManySortedSign means
:Def13:
  the carrier of it = {0} &
  the OperSymbols of it = dom signature A &
  the Arity of it = (*-->0)*signature A &
  the ResultSort of it = dom signature(A)-->0;
 correctness
  proof
    reconsider f = (*-->0)*(signature A) as Function of dom signature A, {0}*
             by Th7;
       ManySortedSign(#{0},dom signature(A),f,dom signature(A)-->0#)
     is segmental trivial non void strict by Lm2;
   hence thesis;
  end;
end;

registration let A be Universal_Algebra;
 cluster MSSign A -> non empty;
 coherence
  proof
   thus the carrier of MSSign A is non empty by Def13;
  end;
end;

definition let A be Universal_Algebra;
 func MSSorts A -> non-empty ManySortedSet of the carrier of MSSign A equals
:Def14: {0}-->the carrier of A;
 coherence
  proof
    A1: the carrier of MSSign A = {0} &
    the OperSymbols of MSSign A = dom signature A &
    the Arity of MSSign A = (*-->0)*signature A &
    the ResultSort of MSSign A = dom signature(A)-->0 by Def13;
    set M = {0}-->the carrier of A;
     dom M = the carrier of MSSign A by A1,FUNCOP_1:19;
    then reconsider M as ManySortedSet of the carrier of MSSign A
     by PBOOLE:def 3;
       M is non-empty
     proof let i;
      assume
        i in the carrier of MSSign A;
      hence thesis by A1,FUNCOP_1:13;
     end;
   hence thesis;
  end;
 correctness;
end;

definition let A be Universal_Algebra;
 func MSCharact A -> ManySortedFunction of
  (MSSorts A)# * the Arity of MSSign A, (MSSorts A)* the ResultSort of MSSign A
     equals
:Def15:  the charact of A;
 coherence
  proof
   reconsider OS = the OperSymbols of MSSign A as non empty set by Def5;
    A1: the carrier of MSSign A = {0} &
    the OperSymbols of MSSign A = dom signature A &
    the Arity of MSSign A = (*-->0)*signature A &
    the ResultSort of MSSign A = dom signature(A)-->0 by Def13;
      len signature A = len the charact of A by UNIALG_1:def 11;
   then A2:  dom the charact of A = OS by A1,FINSEQ_3:31;
   then reconsider O = the charact of A as ManySortedSet of OS
     by PBOOLE:def 3;
      O is Function-yielding
    proof let i;
     assume
A3:    i in dom O;
         dom O = dom the charact of A;
      then reconsider n = i as Nat by A3;
         O.n is Function by A3,UNIALG_1:5;
     hence O.i is Function;
    end;
   then reconsider O as ManySortedFunction of OS;
   reconsider DO = (MSSorts A)# * the Arity of MSSign A,
               RO = (MSSorts A)* the ResultSort of MSSign A
    as ManySortedSet of OS;
      O is ManySortedFunction of DO,RO
   proof let i;
    assume
A4:   i in OS;
     then reconsider o = i as Element of OS;
     reconsider n = i as Nat by A1,A4;
     set D = the carrier of A;
     reconsider h = O.n as homogeneous quasi_total non empty PartFunc of D*,D
                             by A2,A4,FUNCT_1:def 15,UNIALG_1:5,def 4,def 5;
        dom({0}-->D) = {0} by FUNCOP_1:19;
     then reconsider M = {0}-->D as ManySortedSet of {0} by PBOOLE:def 3;
     A5:   n in dom(dom signature(A)-->0) by A1,A4,FUNCOP_1:19;
A6:   0 in {0} by TARSKI:def 1;
A7:   DO.i = ((MSSorts A)#*(*-->0)*signature A).n by A1,RELAT_1:55
         .= ((MSSorts A)#*(*-->0)).((signature A).n) by A1,A4,FUNCT_1:23
         .= (M#*(*-->0)).((signature A).n) by A1,Def14
         .= (M#*(*-->0)).arity h by A1,A4,UNIALG_1:def 11
         .= Funcs(Seg arity h,D) by PBOOLE:153
         .= dom(O.o) by Th8;
A8:   RO.i = (MSSorts A).((dom signature(A)-->0).n) by A1,A5,FUNCT_1:23
         .= (MSSorts A).0 by A1,A4,FUNCOP_1:13
         .= ({0}-->the carrier of A).0 by Def14
         .= the carrier of A by A6,FUNCOP_1:13;
     then rng h c= RO.i by RELSET_1:12;
    hence O.i is Function of DO.i,RO.i by A7,A8,FUNCT_2:def 1,RELSET_1:11;
   end;
   hence thesis;
  end;
 correctness;
end;

definition let A be Universal_Algebra;
 func MSAlg A -> strict MSAlgebra over MSSign A equals
:Def16:  MSAlgebra(#MSSorts A,MSCharact A#);
 correctness;
end;

registration let A be Universal_Algebra;
 cluster MSAlg A -> non-empty;
 coherence
  proof
   MSAlg A = MSAlgebra(#MSSorts A,MSCharact A#) by Def16;
   hence the Sorts of MSAlg A is non-empty;
  end;
end;

:: Manysorted Algebras with 1 Sort Only

definition let MS be trivial non empty ManySortedSign;
 let A be MSAlgebra over MS;
 func the_sort_of A -> set means
:Def17: ex c being Component of the Sorts of A st it = c;
 existence
  proof consider c being Component of the Sorts of A;
   take c; thus thesis;
  end;
 uniqueness by Th10;
end;

registration let MS be trivial non empty ManySortedSign;
 let A be non-empty MSAlgebra over MS;
 cluster the_sort_of A -> non empty;
 coherence
  proof
       ex c being Component of the Sorts of A st the_sort_of A = c by Def17;
   hence thesis;
  end;
end;

theorem Th11:
 for MS being segmental trivial non void non empty ManySortedSign,
     i being OperSymbol of MS,
     A being non-empty MSAlgebra over MS
 holds Args(i,A) = (len the_arity_of i)-tuples_on the_sort_of A
proof
 let MS be segmental trivial non void non empty ManySortedSign,
     i be OperSymbol of MS,
     A be non-empty MSAlgebra over MS;
  set m = len the_arity_of i;
A1: the OperSymbols of MS <> {} by Def5;
A2:    dom(the Arity of MS) = the OperSymbols of MS by FUNCT_2:def 1;
A3: Args(i,A) = ((the Sorts of A)# * the Arity of MS).i by Def9
            .= (the Sorts of A)# .((the Arity of MS).i) by A1,A2,FUNCT_1:23
            .= (the Sorts of A)# .the_arity_of i by Def6
            .= product((the Sorts of A)*the_arity_of i) by PBOOLE:def 19;
   consider n being Nat such that
A4:  dom the_arity_of i = Seg n by FINSEQ_1:def 2;
A5: rng the_arity_of i c= the carrier of MS by FINSEQ_1:def 4;
  then rng the_arity_of i c= dom the Sorts of A by PBOOLE:def 3;
  then A6: dom((the Sorts of A)*the_arity_of i) = dom the_arity_of i by
RELAT_1:46;
 thus Args(i,A) c= m-tuples_on the_sort_of A
  proof
   let x be set;
   assume x in Args(i,A);
    then consider g being Function such that
  A7: x = g and
  A8: dom g = dom((the Sorts of A)*the_arity_of i) and
  A9: for j being set st j in dom((the Sorts of A)*the_arity_of i)
         holds g.j in ((the Sorts of A)*the_arity_of i).j by A3,CARD_3:def 5;
    reconsider p = g as FinSequence by A4,A6,A8,FINSEQ_1:def 2;
       rng p c= the_sort_of A
     proof let j be set;
      assume j in rng p;
       then consider u being set such that
  A10:   u in dom g and
  A11:   p.u = j by FUNCT_1:def 5;
          g.u in ((the Sorts of A)*the_arity_of i).u by A8,A9,A10;
       then A12:    g.u in (the Sorts of A).((the_arity_of i).u) by A6,A8,A10,
FUNCT_1:23;
          (the_arity_of i).u in rng the_arity_of i by A6,A8,A10,FUNCT_1:def 5;
       then (the Sorts of A).((the_arity_of i).u) is
        Component of the Sorts of A by A5,PBOOLE:151;
      hence j in the_sort_of A by A11,A12,Def17;
     end;
    then A13:   p is FinSequence of the_sort_of A by FINSEQ_1:def 4;
       len p = m by A6,A8,FINSEQ_3:31;
    then x is Element of m-tuples_on the_sort_of A by A7,A13,FINSEQ_2:110;
   hence x in m-tuples_on the_sort_of A;
 end;
 let x be set;
 assume x in m-tuples_on the_sort_of A;
  then x in Funcs(Seg m, the_sort_of A) by FINSEQ_2:111;
  then consider g being Function such that
A14: x = g and
A15: dom g = Seg m and
A16: rng g c= the_sort_of A by FUNCT_2:def 2;
A17: dom g = dom((the Sorts of A)*the_arity_of i) by A6,A15,FINSEQ_1:def 3;
     now let x be set;
   assume
A18:  x in dom((the Sorts of A)*the_arity_of i);
    then g.x in rng g by A17,FUNCT_1:def 5;
    then A19:   g.x in the_sort_of A by A16;
       (the_arity_of i).x in rng the_arity_of i by A6,A18,FUNCT_1:def 5;
    then (the Sorts of A).((the_arity_of i).x) is
     Component of the Sorts of A by A5,PBOOLE:151;
    then g.x in (the Sorts of A).((the_arity_of i).x) by A19,Def17;
   hence g.x in ((the Sorts of A)*the_arity_of i).x by A6,A18,FUNCT_1:23;
  end;
 hence x in Args(i,A) by A3,A14,A17,CARD_3:18;
end;

theorem Th12:
 for A being non empty set, n holds n-tuples_on A c= A*
  proof let A be non empty set, n;
    defpred P[Element of A*] means len $1 = n;
       { s where s is Element of A*: P[s] } c= A* from FRAENKEL:sch 10;
   hence n-tuples_on A c= A* by FINSEQ_2:def 4;
  end;

theorem Th13:
 for MS being segmental trivial non void non empty ManySortedSign,
     i being OperSymbol of MS,
     A being non-empty MSAlgebra over MS holds Args(i,A) c= (the_sort_of A)*
proof
 let MS be segmental trivial non void non empty ManySortedSign,
     i be OperSymbol of MS,
     A be non-empty MSAlgebra over MS;
    Args(i,A) = (len the_arity_of i)-tuples_on the_sort_of A by Th11;
 hence Args(i,A) c= (the_sort_of A)* by Th12;
end;

theorem Th14:
 for MS being segmental trivial non void non empty ManySortedSign,
     A being non-empty MSAlgebra over MS holds
  the Charact of A is FinSequence of PFuncs((the_sort_of A)*,the_sort_of A)
 proof
  let MS be segmental trivial non void non empty ManySortedSign,
      A be non-empty MSAlgebra over MS;
A1: dom the Charact of A = the OperSymbols of MS by PBOOLE:def 3;
      ex n st the OperSymbols of MS = Seg n by Def12;
   then reconsider f = the Charact of A as FinSequence by A1,FINSEQ_1:def 2;
      f is FinSequence of PFuncs((the_sort_of A)*,the_sort_of A)
    proof let x be set;
     assume x in rng f;
      then consider i such that
A2:    i in the OperSymbols of MS and
A3:    f.i = x by A1,FUNCT_1:def 5;
      reconsider i as OperSymbol of MS by A2;
A4:    dom(the ResultSort of MS) = the OperSymbols of MS by FUNCT_2:def 1;
A5:    ((the Sorts of A)# * the Arity of MS).i = Args(i,A) by Def9;
         (the ResultSort of MS).i in the carrier of MS by A2,FUNCT_2:7;
      then A6:    (the Sorts of A).((the ResultSort of MS).i)
       is Component of the Sorts of A by PBOOLE:151;
A7:    Args(i,A) c= (the_sort_of A)* by Th13;
         ((the Sorts of A)*the ResultSort of MS).i
            = (the Sorts of A).((the ResultSort of MS).i) by A2,A4,FUNCT_1:23
           .= the_sort_of A by A6,Def17;
      then x is Function of Args(i,A),the_sort_of A by A2,A3,A5,PBOOLE:def 18;
      then x is PartFunc of (the_sort_of A)*,the_sort_of A by A7,PARTFUN1:30;
     hence x in PFuncs((the_sort_of A)*,the_sort_of A) by PARTFUN1:119;
    end;
  hence thesis;
 end;

definition let MS be segmental trivial non void non empty ManySortedSign;
 let A be non-empty MSAlgebra over MS;
 func the_charact_of A -> PFuncFinSequence of the_sort_of A equals
:Def18: the Charact of A;
 coherence by Th14;
end;

reserve MS for segmental trivial non void non empty ManySortedSign,
        A for non-empty MSAlgebra over MS,
        h for PartFunc of (the_sort_of A)*,(the_sort_of A),
        x,y for FinSequence of the_sort_of A;

definition let MS,A;
 func 1-Alg A -> non-empty strict Universal_Algebra equals
:Def19:   UAStr(#the_sort_of A, the_charact_of A#);
 coherence
  proof
    A1: the_charact_of A is quasi_total
     proof let n,h such that
A2:    n in dom(the_charact_of A) and
A3:    h = (the_charact_of A).n;
      let x,y such that
A4:   len x = len y and
A5:   x in dom h;
A6:     dom(the_charact_of A) = dom the Charact of A by Def18
          .= the OperSymbols of MS by PBOOLE:def 3;
       then reconsider o = n as OperSymbol of MS by A2;
A7:    dom(the ResultSort of MS) = the OperSymbols of MS by FUNCT_2:def 1;
A8:   ((the Sorts of A)# * the Arity of MS).o = Args(o,A) by Def9;
        (the ResultSort of MS).o in the carrier of MS by A2,A6,FUNCT_2:7;
     then A9:   (the Sorts of A).((the ResultSort of MS).o)
       is Component of the Sorts of A by PBOOLE:151;
    A10: ((the Sorts of A)*the ResultSort of MS).o
          = (the Sorts of A).((the ResultSort of MS).o) by A2,A6,A7,FUNCT_1:23
         .= the_sort_of A by A9,Def17;
          h = (the Charact of A).o by A3,Def18;
       then h is Function of
          ((the Sorts of A)# * the Arity of MS).o,
          ((the Sorts of A) * the ResultSort of MS).o by A2,A6,PBOOLE:def 18;

       then A11:     dom h = ((the Sorts of A)# * the Arity of MS).o by A10,
FUNCT_2:def 1
            .= (len the_arity_of o)-tuples_on the_sort_of A by A8,Th11;
       then len y = len the_arity_of o by A4,A5,FINSEQ_2:109;
       then y is Element of dom h by A11,FINSEQ_2:110;
      hence y in dom h by A5;
     end;
    A12: the_charact_of A is homogeneous
     proof let n,h such that
A13:    n in dom(the_charact_of A) and
A14:    h = (the_charact_of A).n;
      let x,y such that
A15:     x in dom h & y in dom h;
A16:     dom(the_charact_of A) = dom the Charact of A by Def18
          .= the OperSymbols of MS by PBOOLE:def 3;
       then reconsider o = n as OperSymbol of MS by A13;
A17:    dom(the ResultSort of MS) = the OperSymbols of MS by FUNCT_2:def 1;
A18:   ((the Sorts of A)# * the Arity of MS).o = Args(o,A) by Def9;
        (the ResultSort of MS).o in the carrier of MS by A13,A16,FUNCT_2:7;
     then A19:   (the Sorts of A).((the ResultSort of MS).o)
       is Component of the Sorts of A by PBOOLE:151;
    A20: ((the Sorts of A)*the ResultSort of MS).o
          = (the Sorts of A).((the ResultSort of MS).o) by A13,A16,A17,
FUNCT_1:23
         .= the_sort_of A by A19,Def17;
          h = (the Charact of A).o by A14,Def18;
       then h is Function of
          ((the Sorts of A)# * the Arity of MS).o,
          ((the Sorts of A) * the ResultSort of MS).o by A13,A16,PBOOLE:def 18;

       then A21:     dom h = ((the Sorts of A)# * the Arity of MS).o by A20,
FUNCT_2:def 1
            .= (len the_arity_of o)-tuples_on the_sort_of A by A18,Th11;
      hence len x = len the_arity_of o by A15,FINSEQ_2:109
        .= len y by A15,A21,FINSEQ_2:109;
     end;
     the OperSymbols of MS <> {} by Def5;
    then the Charact of A <> {} by PBOOLE:def 3,RELAT_1:60;
    then A22:  the_charact_of A <> {} by Def18;
       the_charact_of A is non-empty
     proof let n be set such that
A23:   n in dom the_charact_of A;
     set h = (the_charact_of A).n;
        dom(the_charact_of A) = dom the Charact of A by Def18
          .= the OperSymbols of MS by PBOOLE:def 3;
       then reconsider o = n as OperSymbol of MS by A23;
          h = (the Charact of A).o by Def18
        .= Den(o,A) by Def11;
      hence h is non empty by FUNCT_2:def 1,RELAT_1:60;
     end;
   hence thesis by A1,A12,A22,UNIALG_1:def 7,def 8,def 9;
  end;
 correctness;
end;

theorem
    for A being strict Universal_Algebra holds
  A = 1-Alg MSAlg A
proof let A be strict Universal_Algebra;
A1: MSAlg A = MSAlgebra(#MSSorts A,MSCharact A#) by Def16;
      the carrier of A in {the carrier of A} by TARSKI:def 1;
   then the carrier of A in rng({0}-->the carrier of A) by FUNCOP_1:14;
   then the carrier of A in rng the Sorts of MSAlg A by A1,Def14;
   then A2: the carrier of A = the_sort_of MSAlg A by Def17;
     the charact of A = MSCharact A by Def15
        .= the_charact_of MSAlg A by A1,Def18;
 hence A = 1-Alg MSAlg A by A2,Def19;
end;

theorem
    for A being Universal_Algebra
 for f being Function of dom signature A, {0}*
  st f = (*-->0)*signature A
 holds MSSign A = ManySortedSign(#{0},dom signature A,f,dom signature(A)-->0#)
proof let A be Universal_Algebra;
     the carrier of MSSign A = {0} &
  the OperSymbols of MSSign A = dom signature A &
  the Arity of MSSign A = (*-->0)*signature A &
  the ResultSort of MSSign A = dom signature(A)-->0 by Def13;
 hence thesis;
end;
