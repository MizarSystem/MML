:: Introduction to Turing Machines
::  by Jingchao Chen and Yatsuka Nakamura
::
:: Received July 27, 2001
:: Copyright (c) 2001 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, XBOOLE_0, FUNCT_1, PARTFUN1, FUNCT_4, RELAT_1,
      TARSKI, FUNCOP_1, ORDINAL1, XXREAL_0, FINSET_1, CARD_1, FINSEQ_1, NAT_1,
      CARD_3, ARYTM_3, QMAX_1, FSM_1, ZFMISC_1, ARYTM_1, FUNCT_2, LANG1, INT_1,
      MCART_1, CIRCUIT2, MSUALG_1, ORDINAL4, VALUED_2, FINSEQ_2, UNIALG_1,
      PRALG_3, TURING_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0,
      INT_1, FINSET_1, MCART_1, DOMAIN_1, FUNCT_1, FUNCT_2, FUNCT_4, FINSEQ_1,
      FINSEQ_2, FUNCOP_1, PARTFUN1, GR_CY_1, FINSEQ_4, RELAT_1, UNIALG_1,
      COMPUT_1, XXREAL_0, REAL_1, NAT_1;
 constructors DOMAIN_1, REAL_1, BINOP_2, FINSEQ_4, FINSOP_1, GR_CY_1, COMPUT_1,
      RECDEF_1, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1,
      FINSET_1, NUMBERS, XREAL_0, INT_1, COMPUT_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions GR_CY_1, COMPUT_1, FUNCOP_1;
 theorems FUNCOP_1, FUNCT_4, ZFMISC_1, TARSKI, FUNCT_2, INT_1, MCART_1, NAT_1,
      RELSET_1, PARTFUN1, DOMAIN_1, CQC_THE1, ENUMSET1, FINSEQ_2, FINSEQ_1,
      FINSEQ_3, FUNCT_1, RELAT_1, FINSEQ_6, FINSEQ_7, COMPUT_1, FINSEQ_4,
      ORDINAL1, XBOOLE_0, XBOOLE_1, NUMBERS, XREAL_1, FUNCT_7, FINSOP_1,
      XXREAL_0, RVSUM_1;
 schemes NAT_1, FUNCT_2, BINOP_2;

begin :: Preliminaries

reserve n,i,j,k for Element of NAT;

definition
  let A,B be non empty set, f be Function of A,B, g be PartFunc of A,B;
  redefine func f +* g -> Function of A,B;
  coherence
  proof
A1: now
      let x be set;
      assume
A2:   x in A;
      per cases;
      suppose
A3:     x in dom g;
        then (f +* g).x=g.x by FUNCT_4:14;
        hence (f +* g).x in B by A3,PARTFUN1:27;
      end;
      suppose
        not x in dom g;
        then (f +* g).x = f.x by FUNCT_4:12;
        hence (f +* g).x in B by A2,FUNCT_2:7;
      end;
    end;
A4: dom f = A & dom g c= A by FUNCT_2:def 1,RELAT_1:def 18;
    dom (f +* g) =dom f \/ dom g by FUNCT_4:def 1
      .=A by A4,XBOOLE_1:12;
    hence thesis by A1,FUNCT_2:5;
  end;
end;

definition
  let X,Y be non empty set, a be Element of X, b be Element of Y;
  redefine func a .--> b -> PartFunc of X,Y;
  coherence
  proof
    set p = a .--> b;
    dom p = {a} & rng p ={b} by FUNCOP_1:14,19;
    hence thesis by RELSET_1:17;
  end;
end;

notation
  let n be natural number;
  synonym SegM n for succ n;
end;

definition
  let n be natural number;
  redefine func SegM n -> Subset of NAT equals
  {k : k <= n};
  coherence
  proof
    SegM n in NAT by ORDINAL1:def 13;
    then SegM n c= NAT by ORDINAL1:7;
   hence thesis;
  end;
 compatibility by NAT_1:55;
end;

registration
  let n be natural number;
  cluster SegM n -> finite non empty;
  coherence
  proof
    n is Element of NAT by ORDINAL1:def 13;
    hence SegM n is finite by CQC_THE1:12;
    thus thesis;
  end;
end;

theorem Th1: :: GR_CY 10
  k in SegM n iff k <= n
proof
  thus k in SegM n implies k <= n
  proof
    assume
    k in SegM n;
    then ex i st k=i & i <= n;
    hence thesis;
  end;
  assume
  k <= n;
  hence thesis;
end;

theorem Th2:
  for f be Function,x,y,z,u,v be set st u <> x holds (f +* ([x,y]
  .--> z)).[u,v]=f.[u,v]
proof
  let f be Function,x,y,z,u,v be set;
  set p=[x,y] .--> z;
  assume
  u <> x;
  then
A1: [u,v]<>[x,y] by ZFMISC_1:33;
  dom p ={ [x,y] } by FUNCOP_1:19;
  then not [u,v] in dom p by A1,TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem Th3:
  for f be Function,x,y,z,u,v be set st v <> y holds (f +* ([x,y]
  .--> z)).[u,v]=f.[u,v]
proof
  let f be Function,x,y,z,u,v be set;
  set p=[x,y] .--> z;
  assume
  v <> y;
  then
A1: [u,v]<>[x,y] by ZFMISC_1:33;
  dom p ={ [x,y] } by FUNCOP_1:19;
  then not [u,v] in dom p by A1,TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

reserve i1,i2,i3,i4 for Element of INT;

canceled 3;

definition
  let f be FinSequence of NAT,i be Element of NAT;
  func Prefix(f,i) -> FinSequence of INT equals
  f| Seg i;
  coherence
  proof
    set p=f|Seg i;
A1: now
      let j be Nat;
      assume
A2:   j in dom p;
      then j in dom f by RELAT_1:86;
      then
A3:   f.j in NAT by FINSEQ_2:13;
      p.j=f.j by A2,FUNCT_1:70;
      hence p.j in INT by A3,NUMBERS:17;
    end;
    p is FinSequence by FINSEQ_1:19;
    hence thesis by A1,FINSEQ_2:14;
  end;
end;

theorem Th7:
  for x1,x2 being Element of NAT holds Sum Prefix(<*x1,x2*>,1)=x1 &
  Sum Prefix(<*x1,x2*>,2)=x1+x2
proof
  let x1,x2 be Element of NAT;
  reconsider y1=x1 as Element of INT by INT_1:def 2;
  thus Sum Prefix(<*x1,x2*>,1)=Sum<*y1*> by FINSEQ_6:5
    .=x1 by FINSOP_1:12;
  reconsider y2=x2 as Element of INT by INT_1:def 2;
  len <*x1,x2*>= 2 by FINSEQ_1:61;
  hence Sum Prefix(<*x1,x2*>,2)=Sum<*y1,y2*> by FINSEQ_3:55
    .=x1+x2 by RVSUM_1:107;
end;

theorem Th8:
  for x1,x2,x3 being Element of NAT holds Sum Prefix(<*x1,x2,x3*>,1
  )=x1 & Sum Prefix(<*x1,x2,x3*>,2)=x1+x2 & Sum Prefix(<*x1,x2,x3*>,3)=x1+x2+x3
proof
  let x1,x2,x3 be Element of NAT;
  reconsider y1=x1 as Element of INT by INT_1:def 2;
  thus Sum Prefix(<*x1,x2,x3*>,1)=Sum<*y1*> by FINSEQ_6:6
    .=x1 by FINSOP_1:12;
  reconsider y2=x2 as Element of INT by INT_1:def 2;
  thus Sum Prefix(<*x1,x2,x3*>,2)=Sum<*y1,y2*> by FINSEQ_6:7
    .=x1+x2 by RVSUM_1:107;
  reconsider y3=x3 as Element of INT by INT_1:def 2;
  len <*x1,x2,x3*>= 3 by FINSEQ_1:62;
  hence Sum Prefix(<*x1,x2,x3*>,3)=Sum<*y1,y2,y3*> by FINSEQ_3:55
    .=x1+x2+x3 by RVSUM_1:108;
end;

begin :: Definitions and terminology for TURING Machine

definition
  struct TuringStr (# Symbols, FStates -> finite non empty set,
    Tran -> Function of [: the FStates, the Symbols :],
         [: the FStates,the Symbols,{-1,0,1}
    :], InitS,AcceptS -> Element of the FStates #);
end;

definition
  let T be TuringStr;
  mode State of T is Element of the FStates of T;
  mode Tape of T is Element of Funcs(INT,the Symbols of T);
  mode Symbol of T is Element of the Symbols of T;
end;

definition
  let T be TuringStr,t be Tape of T, h be Integer,s be Symbol of T;
  func Tape-Chg(t,h,s) -> Tape of T equals
  t +* (h .--> s);
  coherence
  proof
    set X=INT, Y=the Symbols of T;
A1: ex f being Function st t = f & dom f = X & rng f c= Y by FUNCT_2:def 2;
    rng (h .--> s) ={s} by FUNCOP_1:14;
    then rng (t +* (h .--> s)) c= rng t \/ rng (h .--> s) & rng t \/ rng (h
    .--> s) c= Y by A1,FUNCT_4:18,XBOOLE_1:8;
    then
A2: rng (t +* (h .--> s)) c= Y by XBOOLE_1:1;
A3: h in INT by INT_1:def 2;
    dom(t +* (h .--> s)) = dom t \/ dom(h .--> s) by FUNCT_4:def 1
      .= dom t \/ {h} by FUNCOP_1:19
      .= X by A1,A3,ZFMISC_1:46;
    hence thesis by A2,FUNCT_2:def 2;
  end;
end;

definition
  let T be TuringStr;
  mode All-State of T is Element of [: the FStates of T, INT,
Funcs(INT,the
    Symbols of T) :];
  mode Tran-Source of T is Element of [: the FStates of T,the Symbols of T
:];
  mode Tran-Goal of T is Element of [: the FStates of T,the Symbols of T,
{-1,0
    ,1} :];
end;

definition
  let T be TuringStr, g be Tran-Goal of T;
  func offset(g) -> Integer equals
  g`3;
  coherence by ENUMSET1:def 1;
end;

definition
  let T be TuringStr, s be All-State of T;
  func Head(s) -> Integer equals
  s`2;
  coherence;
end;

definition
  let T be TuringStr, s be All-State of T;
  func TRAN(s) -> Tran-Goal of T equals
  (the Tran of T).[s`1, (s`3 qua Tape of
  T).Head(s)];
  correctness
  proof
    reconsider x=Head(s) as Element of INT;
    (the Tran of T).[s`1, (s`3 qua Tape of T).x] is Tran-Goal of T;
    hence thesis;
  end;
end;

definition
  let T be TuringStr, s be All-State of T;
  func Following s -> All-State of T equals
  :Def7:
  [(TRAN(s))`1, Head(s)+
offset TRAN (s), Tape-Chg(s`3, Head(s),(TRAN(s))`2)] if s`1 <> the AcceptS of T
  otherwise s;
  correctness
  proof
    Head(s) + offset TRAN(s) in INT by INT_1:def 2;
    hence thesis by MCART_1:73;
  end;
end;

definition
  let T be TuringStr, s be All-State of T;
  func Computation s -> Function of NAT, [: the FStates of T, INT,
Funcs(INT,
  the Symbols of T) :] means
  :Def8:
  it.0 = s & for i being Nat holds it.(i+1) =
  Following(it.i);
  existence
  proof
    deffunc U(set,All-State of T) = Following $2;
    consider f being Function of NAT, [: the FStates of T, INT,
Funcs(INT,the
    Symbols of T) :] such that
A1: f.0 = s & for n being Nat holds f.(n+1) = U(n,f.n) from NAT_1:sch
    12;
    take f;
    thus thesis by A1;
  end;
  uniqueness
  proof
    deffunc U(set,All-State of T) = Following $2;
    let F1,F2 be Function of NAT, [: the FStates of T, INT, Funcs(INT,the
    Symbols of T) :] such that
A2: F1.0 = s and
A3: for i being Nat holds F1.(i+1) = Following(F1.i) and
A4: F2.0 = s and
A5: for i being Nat holds F2.(i+1) = Following(F2.i);
A6: for i being Nat holds F1.(i+1) = U(i,F1.i) by A3;
A7: for i being Nat holds F2.(i+1) = U(i,F2.i) by A5;
A8: F2.0 = s by A4;
A9: F1.0 = s by A2;
    thus F1 = F2 from NAT_1:sch 16(A9,A6,A8,A7);
  end;
end;

reserve T for TuringStr,
  s for All-State of T;

theorem
  for T being TuringStr, s be All-State of T st s`1 = the AcceptS of T
  holds s = Following s by Def7;

theorem
  (Computation s).0 = s by Def8;

theorem
  (Computation s).(k+1) = Following (Computation s).k by Def8;

theorem Th12:
  (Computation s).1 = Following s
proof
  (Computation s).(0+1) = Following (Computation s).0 by Def8
    .=Following s by Def8;
  hence thesis;
end;

theorem Th13:
  (Computation s).(i+k) = (Computation (Computation s).i).k
proof
  defpred X[Element of NAT] means (Computation s).(i+$1) = (Computation (
  Computation s).i).$1;
A1: for k st X[k] holds X[k+1]
  proof
    let k;
    assume
A2: (Computation s).(i+k) = (Computation (Computation s).i).k;
    thus (Computation s).(i+(k+1)) = (Computation s).(i+k+1)
      .= Following (Computation s).(i+k) by Def8
      .= (Computation (Computation s).i).(k+1) by A2,Def8;
  end;
A3: X[0] by Def8;
  for k holds X[k] from NAT_1:sch 1(A3,A1);
  hence thesis;
end;

theorem Th14:
  i <= j & Following (Computation s).i = (Computation s).i implies
  (Computation s).j = (Computation s).i
proof
  assume that
A1: i <= j and
A2: Following (Computation s).i = (Computation s).i;
  consider k be Nat such that
A3: j = i + k by A1,NAT_1:10;
  defpred X[Element of NAT] means (Computation s).(i+$1) = (Computation s).i;
A4: for k st X[k] holds X[k+1]
  proof
    let k;
    assume
A5: (Computation s).(i+k) = (Computation s).i;
    thus (Computation s).(i+(k+1)) = (Computation s).(i+k+1)
      .= (Computation s).i by A2,A5,Def8;
  end;
A6: X[0];
A7: for k holds X[k] from NAT_1:sch 1(A6,A4);
  k in NAT by ORDINAL1:def 13;
  hence thesis by A3,A7;
end;

theorem Th15:
  i <= j & ((Computation s).i)`1 = the AcceptS of T implies (
  Computation s).j = (Computation s).i
proof
  assume that
A1: i <= j and
A2: ((Computation s).i)`1 = the AcceptS of T;
  Following (Computation s).i = (Computation s).i by A2,Def7;
  hence thesis by A1,Th14;
end;

definition
  let T be TuringStr, s be All-State of T;
  attr s is Accept-Halt means
  :Def9:
  ex k st ((Computation s).k)`1 = the
  AcceptS of T;
end;

definition
  let T be TuringStr, s be All-State of T such that
A1: s is Accept-Halt;
  func Result s -> All-State of T means
  :Def10:
  ex k st it = (Computation s).k
  & ((Computation s).k)`1 = the AcceptS of T;
  uniqueness
  proof
    let s1,s2 be All-State of T;
    given k1 being Element of NAT such that
A2: s1 = (Computation s).k1 & ((Computation s).k1)`1 = the AcceptS of
    T;
    given k2 being Element of NAT such that
A3: s2 = (Computation s).k2 & ((Computation s).k2)`1 = the AcceptS of
    T;
    k1 <= k2 or k2 <= k1;
    hence thesis by A2,A3,Th15;
  end;
  correctness
  proof
    ex k st ((Computation s).k)`1 = the AcceptS of T by A1,Def9;
    hence thesis;
  end;
end;

theorem Th16:
  for T being TuringStr,s be All-State of T st s is Accept-Halt
  holds ex k being Element of NAT st ((Computation s).k)`1 = the AcceptS of T &
  Result s = (Computation s).k & for i be Element of NAT st i < k holds ((
  Computation s).i)`1 <> the AcceptS of T
proof
  let T be TuringStr,s be All-State of T;
  defpred P[Nat] means ((Computation s).$1)`1 = the AcceptS of T;
  assume
A1: s is Accept-Halt;
  then ex k st ((Computation s).k)`1 = the AcceptS of T by Def9;
  then
A2: ex k be Nat st P[k];
  consider k being Nat such that
A3: P[k] & for n be Nat st P[n] holds k <= n from NAT_1:sch 5(A2);
  reconsider k as Element of NAT by ORDINAL1:def 13;
  take k;
  thus P[k] by A3;
  thus Result s=(Computation s).k by A1,A3,Def10;
  thus thesis by A3;
end;

definition
  let A, B be non empty set, y be set such that
A1: y in B;
  func id(A, B, y) -> Function of A, [: A, B :] means
  for x be Element of A
  holds it.x=[x,y];
  existence
  proof
    reconsider yy=y as Element of B by A1;
    deffunc U(Element of A) = [$1,yy];
    consider f being Function of A, [: A,B :] such that
A2: for x being Element of A holds f.x = U(x) from FUNCT_2:sch 4;
    take f;
    thus thesis by A2;
  end;
  uniqueness
  proof
    deffunc U(Element of A) = [$1,y];
    thus for f1,f2 being Function of A, [: A, B :] st (for x being Element of
A holds f1.x = U(x)) & (for x being Element of A holds f2.x = U(x)) holds f1 =
    f2 from BINOP_2:sch 1;
  end;
end;

definition
  func Sum_Tran -> Function of [: SegM 5,{0,1} :], [: SegM 5,{0,1},{ -1,0,1 }
  :] equals
  id([: SegM 5,{0,1} :],{ -1,0,1 }, 0) +* ([0,0] .--> [0,0,1]) +* ([0,1
] .--> [1,0,1]) +* ([1,1] .--> [1,1,1]) +* ([1,0] .--> [2,1,1]) +* ([2,1] .-->
[2,1,1]) +* ([2,0] .--> [3,0,-1]) +* ([3,1] .--> [4,0,-1]) +* ([4,1] .--> [4,1,
  -1]) +* ([4,0] .--> [5,0,0]);
  coherence
  proof
    reconsider p0=0, p1=1, p2=2, p3=3, p4=4, p5=5 as Element of SegM 5 by Th1;
    set A=[: SegM 5,{0,1} :], B= { -1,0,1 }, C=[: SegM 5,{0,1}, B :];
    reconsider b0=0,b1=1 as Element of {0,1} by TARSKI:def 2;
    reconsider L=-1 as Element of B by ENUMSET1:def 1;
    reconsider h=0,R=1 as Element of {-1,0,1} by ENUMSET1:def 1;
    C=[: A, B :] by ZFMISC_1:def 3;
    then reconsider OP=id(A,B,h) as Function of A,C;
    id(A,B,0) +* ([0,0] .--> [0,0,1]) +* ([0,1] .--> [1,0,1]) +* ([1,1]
.--> [1,1,1]) +* ([1,0] .--> [2,1,1]) +* ([2,1] .--> [2,1,1]) +* ([2,0] .--> [3
,0,-1]) +* ([3,1] .--> [4,0,-1]) +* ([4,1] .--> [4,1,-1]) +* ([4,0] .--> [5,0,0
]) =OP +* ([p0,b0] .--> [p0,b0,R]) +* ([p0,b1] .--> [p1,b0,R]) +* ([p1,b1] .-->
[p1,b1,R]) +* ([p1,b0] .--> [p2,b1,R]) +* ([p2,b1] .--> [p2,b1,R]) +* ([p2,b0]
.--> [p3,b0,L]) +* ([p3,b1] .--> [p4,b0,L]) +* ([p4,b1] .--> [p4,b1,L]) +* ([p4
    ,b0] .--> [p5,b0,h]);
    hence thesis;
  end;
end;

theorem Th17:
  Sum_Tran.[0,0]=[0,0,1] & Sum_Tran.[0,1]=[1,0,1] & Sum_Tran.[1,1]
=[1,1,1] & Sum_Tran.[1,0]=[2,1,1] & Sum_Tran.[2,1]=[2,1,1] & Sum_Tran.[2,0]=[3,
0,-1] & Sum_Tran.[3,1]=[4,0,-1] & Sum_Tran.[4,1]=[4,1,-1] & Sum_Tran.[4,0]=[5,0
  ,0]
proof
  set x=[0,1];
  set x1=[0,0];
  set p1=[0,0] .--> [0,0,1], p2=[0,1] .--> [1,0,1], p3=[1,1] .--> [1,1,1], p4=
  [1,0] .--> [2,1,1], p5=[2,1] .--> [2,1,1], p6=[2,0] .--> [3,0,-1], p7=[3,1]
.--> [4,0,-1], p8=[4,1] .--> [4,1,-1], f= id([: SegM 5,{0,1} :],{ -1,0,1 },0);
  thus Sum_Tran.x1=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7+* p8).x1 by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7).x1 by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5+* p6).x1 by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5).x1 by Th2
    .=(f +* p1+* p2+* p3+* p4).x1 by Th2
    .=(f +* p1+* p2+* p3).x1 by Th2
    .=(f +* p1+* p2).x1 by Th2
    .=(f +* p1).x1 by Th3
    .=[0,0,1] by FUNCT_7:96;
  thus Sum_Tran.x=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7+* p8).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5+* p6).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5).x by Th2
    .=(f +* p1+* p2+* p3+* p4).x by Th2
    .=(f +* p1+* p2+* p3).x by Th2
    .=(f +* p1+* p2).x by Th2
    .=[1,0,1] by FUNCT_7:96;
  set x=[1,1];
  thus Sum_Tran.x=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7+* p8).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5+* p6).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5).x by Th2
    .=(f +* p1+* p2+* p3+* p4).x by Th2
    .=(f +* p1+* p2+* p3).x by Th3
    .=[1,1,1] by FUNCT_7:96;
  set x=[1,0];
  thus Sum_Tran.x=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7+* p8).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5+* p6).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5).x by Th2
    .=(f +* p1+* p2+* p3+* p4).x by Th2
    .=[2,1,1] by FUNCT_7:96;
  set x=[2,1];
  thus Sum_Tran.x=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7+* p8).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5+* p6).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5).x by Th3
    .=[2,1,1] by FUNCT_7:96;
  set x=[2,0];
  thus Sum_Tran.x=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7+* p8).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5+* p6).x by Th2
    .=[3,0,-1] by FUNCT_7:96;
  set x=[3,1];
  thus Sum_Tran.x=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7+* p8).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7).x by Th2
    .=[4,0,-1] by FUNCT_7:96;
  set x=[4,1];
  thus Sum_Tran.x=(f +* p1+* p2+* p3+* p4+* p5+* p6+* p7+* p8).x by Th3
    .=[4,1,-1] by FUNCT_7:96;
  thus thesis by FUNCT_7:96;
end;

definition
  let T be TuringStr, t be Tape of T, i,j be Integer;
  pred t is_1_between i,j means
  :Def13:
  t.i=0 & t.j=0 & for k be Integer st i
  < k & k < j holds t.k=1;
end;

definition
  let f be FinSequence of NAT, T be TuringStr, t be Tape of T;
  pred t storeData f means
  :Def14:
  for i be Element of NAT st 1 <= i & i < len
  f holds t is_1_between Sum Prefix(f,i)+2*(i-1),Sum Prefix(f,i+1)+2*i;
end;

theorem Th18:
  for T being TuringStr,t be Tape of T, s,n be Element of NAT st t
  storeData <*s,n*> holds t is_1_between s,s+n+2
proof
  let T be TuringStr,t be Tape of T,s,n be Element of NAT;
  set f=<*s,n*>;
  assume
A1: t storeData f;
A2: len f=2 by FINSEQ_1:61;
  Sum Prefix(f,1)+2*(1-1)=s & Sum Prefix(f,1+1)+2*1=s+n+2 by Th7;
  hence thesis by A1,A2,Def14;
end;

theorem Th19:
  for T being TuringStr, t be Tape of T, s,n be Element of NAT st
  t is_1_between s,s+n+2 holds t storeData <*s,n*>
proof
  let T be TuringStr,t be Tape of T,s,n be Element of NAT;
  set f=<*s,n*>;
  assume
A1: t is_1_between s,s+n+2;
A2: Sum Prefix(f,1+1)+2*1=s+n+2 by Th7;
  now
    let i be Element of NAT;
    assume that
A3: 1 <= i and
A4: i < len f;
    len f=2 by FINSEQ_1:61;
    then i+1 <= 1+1 by A4,INT_1:20;
    then i <= 1 by XREAL_1:8;
    then i=1 by A3,XXREAL_0:1;
    hence
    t is_1_between Sum Prefix(f,i)+2*(i-1),Sum Prefix(f,i+1)+2*i by A1,A2,Th7;
  end;
  hence thesis by Def14;
end;

theorem Th20:
  for T being TuringStr, t be Tape of T, s,n be Element of NAT st
t storeData <*s,n *> holds t.s=0 & t.(s+n+2)=0 & for i be Integer st s < i & i
  < s+n+2 holds t.i=1
proof
  let T be TuringStr, t be Tape of T, s,n be Element of NAT;
  assume
  t storeData <*s,n*>;
  then
A1: t is_1_between s,s+n+2 by Th18;
  hence t.s=0 & t.(s+n+2)=0 by Def13;
  thus thesis by A1,Def13;
end;

theorem Th21:
  for T being TuringStr,t be Tape of T,s,n1,n2 be Element of NAT
st t storeData <*s,n1,n2*> holds t is_1_between s,s+n1+2 & t is_1_between s+n1+
  2,s+n1+n2+4
proof
  let T be TuringStr,t be Tape of T,s,n1,n2 be Element of NAT;
  set f=<*s,n1,n2*>;
  assume
A1: t storeData f;
A2: len f=3 by FINSEQ_1:62;
  Sum Prefix(f,1)+2*(1-1)=s & Sum Prefix(f,1+1)+2*1=s+n1+2 by Th8;
  hence t is_1_between s,s+n1+2 by A1,A2,Def14;
  Sum Prefix(f,2)+2*(2-1)=s+n1+2 & Sum Prefix(f,2+1)+2*2=s+n1+n2+4 by Th8;
  hence thesis by A1,A2,Def14;
end;

theorem Th22:
  for T being TuringStr, t be Tape of T, s,n1,n2 be Element of NAT
st t storeData <*s,n1,n2 *> holds t.s=0 & t.(s+n1+2)=0 & t.(s+n1+n2+4)=0 & (for
i be Integer st s < i & i < s+n1+2 holds t.i=1) & for i be Integer st s+n1+2 <
  i & i < s+n1+n2+4 holds t.i=1
proof
  let T be TuringStr, t be Tape of T, s,n1,n2 be Element of NAT;
  assume
  t storeData <*s,n1,n2 *>;
  then
A1: t is_1_between s,s+n1+2 & t is_1_between s+n1+2,s+n1+n2+4 by Th21;
  hence t.s=0 & t.(s+n1+2)=0 & t.(s+n1+n2+4)=0 by Def13;
  thus thesis by A1,Def13;
end;

theorem Th23:
  for f being FinSequence of NAT,s being Element of NAT st len f
  >= 1 holds Sum Prefix(<*s*>^f,1)=s & Sum Prefix(<*s*>^f,2)=s+f/.1
proof
  let f be FinSequence of NAT,s be Element of NAT;
  set g=<*s*>, h=g^f;
  reconsider x1=s as Element of INT by INT_1:def 2;
  reconsider x2=f/.1 as Element of INT by INT_1:def 2;
  assume
A1: len f >= 1;
  then consider n being Nat such that
A2: len f=1+n by NAT_1:10;
A3: len g=1 by FINSEQ_1:56;
  then Seg 1=dom g by FINSEQ_1:def 3;
  hence Sum Prefix(h,1)=Sum<*x1*> by FINSEQ_1:33
    .=s by FINSOP_1:12;
  len h=1+len f by A3,FINSEQ_1:35
    .=2+n by A2;
  then consider p2,q2 being FinSequence of NAT such that
A4: len p2 = 2 and
  len q2 = n and
A5: h = p2^q2 by FINSEQ_2:26;
  f/.1=f.1 by A1,FINSEQ_4:24
    .=h.(1+1) by A1,A3,FINSEQ_7:3;
  then
A6: p2.2=f/.1 by A4,A5,FINSEQ_1:85;
  Seg 2=dom p2 by A4,FINSEQ_1:def 3;
  then
A7: p2 =Prefix(h,2) by A5,FINSEQ_1:33;
  h.1=s by FINSEQ_1:58;
  then p2.1=s by A4,A5,FINSEQ_1:85;
  hence Sum Prefix(h,2)=Sum<*x1,x2*> by A4,A7,A6,FINSEQ_1:61
    .=s+f/.1 by RVSUM_1:107;
end;

theorem Th24:
  for f being FinSequence of NAT,s being Element of NAT st len f
>= 3 holds Sum Prefix(<*s*>^f,1)=s & Sum Prefix(<*s*>^f,2)=s+f/.1 & Sum Prefix(
  <*s*>^f,3)=s+f/.1+f/.2 & Sum Prefix(<*s*>^f,4)=s+f/.1+f/.2+f/.3
proof
  let f be FinSequence of NAT,s be Element of NAT;
  set g=<*s*>, h=g^f;
  reconsider x1=s as Element of INT by INT_1:def 2;
  reconsider x2=f/.1 as Element of INT by INT_1:def 2;
  reconsider x3=f/.2 as Element of INT by INT_1:def 2;
  reconsider x4=f/.3 as Element of INT by INT_1:def 2;
  assume
A1: len f >= 3;
  then consider n being Nat such that
A2: len f=3+n by NAT_1:10;
  reconsider n as Element of NAT by ORDINAL1:def 13;
A3: len g=1 by FINSEQ_1:56;
  then
A4: len h=1+len f by FINSEQ_1:35
    .=4+n by A2;
  then consider p4,q4 being FinSequence of NAT such that
A5: len p4 = 4 and
  len q4 = n and
A6: h = p4^q4 by FINSEQ_2:26;
  f/.3=f.3 by A1,FINSEQ_4:24
    .=h.(1+3) by A1,A3,FINSEQ_7:3;
  then
A7: p4.4=f/.3 by A5,A6,FINSEQ_1:85;
  Seg 4=dom p4 by A5,FINSEQ_1:def 3;
  then
A8: p4 =Prefix(h,4) by A6,FINSEQ_1:33;
A9: 1 <= len f by A1,XXREAL_0:2;
  hence Sum Prefix(<*s*>^f,1)=s & Sum Prefix(<*s*>^f,2)=s+f/.1 by Th23;
  len h=3+(1+n) by A4;
  then consider p3,q3 being FinSequence of NAT such that
A10: len p3 = 3 and
  len q3 = 1+n and
A11: h = p3^q3 by FINSEQ_2:26;
A12: f/.1=f.1 by A9,FINSEQ_4:24
    .=h.(1+1) by A9,A3,FINSEQ_7:3;
  then
A13: p4.2=f/.1 by A5,A6,FINSEQ_1:85;
A14: 2 <= len f by A1,XXREAL_0:2;
  then
A15: f/.2=f.2 by FINSEQ_4:24
    .=h.(1+2) by A3,A14,FINSEQ_7:3;
  then
A16: p4.3=f/.2 by A5,A6,FINSEQ_1:85;
A17: p3.2=f/.1 by A12,A10,A11,FINSEQ_1:85;
  Seg 3=dom p3 by A10,FINSEQ_1:def 3;
  then
A18: p3 =Prefix(h,3) by A11,FINSEQ_1:33;
A19: p3.3=f/.2 by A15,A10,A11,FINSEQ_1:85;
A20: h.1=s by FINSEQ_1:58;
  then p3.1=s by A10,A11,FINSEQ_1:85;
  then p3=<*s,f/.1,f/.2*> by A10,A17,A19,FINSEQ_1:62;
  hence Sum Prefix(h,3)=s+f/.1+f/.2 by A18,RVSUM_1:108;
  p4.1=s by A20,A5,A6,FINSEQ_1:85;
  then p4=<*s,f/.1,f/.2,f/.3*> by A5,A13,A16,A7,FINSEQ_4:91;
  hence Sum Prefix(h,4)=x1+x2+x3+x4 by A8,RVSUM_1:172
    .=s+f/.1+f/.2+f/.3;
end;

theorem Th25:
  for T being TuringStr,t be Tape of T, s be Element of NAT, f be
FinSequence of NAT st len f >=1 & t storeData <*s*>^f holds t is_1_between s,s+
  f/.1+2
proof
  let T be TuringStr,t be Tape of T,s be Element of NAT, f be FinSequence of
  NAT;
  set g=<*s*>^f;
  assume that
A1: len f >=1 and
A2: t storeData g;
  len <*s*>=1 by FINSEQ_1:56;
  then len g=1+len f by FINSEQ_1:35;
  then len g >= 1+1 by A1,XREAL_1:9;
  then
A3: 1 < len g by XXREAL_0:2;
  Sum Prefix(g,1)+2*(1-1)=s & Sum Prefix(g,1+1)+2*1=s+f/.1+2 by A1,Th23;
  hence thesis by A2,A3,Def14;
end;

theorem Th26:
  for T being TuringStr,t be Tape of T, s be Element of NAT, f be
FinSequence of NAT st len f >=3 & t storeData <*s*>^f holds t is_1_between s,s+
f/.1+2 & t is_1_between s+f/.1+2, s+f/.1+f/.2+4 & t is_1_between s+f/.1+f/.2+4,
  s+f/.1+f/.2+f/.3+6
proof
  let T be TuringStr,t be Tape of T, s be Element of NAT, f be FinSequence of
  NAT;
  set g=<*s*>^f;
  assume that
A1: len f >=3 and
A2: t storeData g;
  thus t is_1_between s,s+f/.1+2 by A1,A2,Th25,XXREAL_0:2;
  len <*s*>=1 by FINSEQ_1:56;
  then len g=1+len f by FINSEQ_1:35;
  then
A3: len g >= 3+1 by A1,XREAL_1:9;
  then
A4: 2 < len g by XXREAL_0:2;
  Sum Prefix(g,2)+2*(2-1)=s+f/.1+2 & Sum Prefix(g,2+1)+2*2=s+f/.1+f/.2+4
  by A1,Th24;
  hence t is_1_between s+f/.1+2,s+f/.1+f/.2+4 by A2,A4,Def14;
A5: 3 < len g by A3,XXREAL_0:2;
  Sum Prefix(g,3)+2*(3-1)=s+f/.1+f/.2+4 & Sum Prefix(g,3+1)+2*3=s+f/.1+f/.
  2+f /.3+6 by A1,Th24;
  hence thesis by A2,A5,Def14;
end;

begin :: Summation of two natural numbers

definition
  func SumTuring -> strict TuringStr means
  :Def15:
  the Symbols of it = { 0,1 }
& the FStates of it = SegM 5 & the Tran of it = Sum_Tran & the InitS of it
= 0 &
  the AcceptS of it = 5;
  existence
  proof
    set St=SegM 5;
    reconsider p0=0, qF=5 as Element of St by Th1;
    set Sym = { 0,1 };
    take TuringStr(# Sym,St, Sum_Tran, p0, qF #);
    thus thesis;
  end;
  uniqueness;
end;

Lm1: for n be Element of NAT st n <= 5 holds n is State of SumTuring
proof
  let n be Element of NAT;
  assume
A1: n <= 5;
  the FStates of SumTuring=SegM 5 by Def15;
  hence thesis by A1,Th1;
end;

canceled;

theorem Th28:
  for T be TuringStr,t be Tape of T, h be Integer,s be Symbol of T
  st t.h=s holds Tape-Chg(t,h,s) = t
proof
  let T be TuringStr,t be Tape of T, h be Integer,s be Symbol of T;
  ex f being Function st t = f & dom f = INT & rng f c= the Symbols of T by
FUNCT_2:def 2;
  then
A1: h in dom t by INT_1:def 2;
  assume
  t.h=s;
  hence thesis by A1,FUNCT_7:98;
end;

Lm2: 0 in the Symbols of SumTuring & 1 in the Symbols of SumTuring
proof
  0 in {0,1} & 1 in {0,1} by TARSKI:def 2;
  hence thesis by Def15;
end;

theorem Th29:
  for T be TuringStr, s be All-State of T, p,h,t be set st s=[p,h,
  t] & p <> the AcceptS of T holds Following s = [(TRAN(s))`1, Head(s)+offset
  TRAN(s),Tape-Chg(s`3,Head(s),(TRAN(s))`2)]
proof
  let T be TuringStr,s be All-State of T, p,h,t be set;
  assume that
A1: s=[p,h,t] and
A2: p <> the AcceptS of T;
  s`1=p by A1,MCART_1:68;
  hence thesis by A2,Def7;
end;

Lm3: for s being All-State of SumTuring, p,h,t be set st s=[p,h,t] & p <> 5
holds Following s = [(TRAN(s))`1,Head(s)+ offset TRAN(s),Tape-Chg(s`3,Head(s),(
TRAN(s))`2)]

proof
  let s be All-State of SumTuring, p,h,t be set;
  assume
A1: s=[p,h,t] & p <> 5;
  5=the AcceptS of SumTuring by Def15;
  hence thesis by A1,Th29;
end;

theorem Th30:
  for T being TuringStr,t be Tape of T, h be Integer, s be Symbol
of T,i be set holds Tape-Chg(t,h,s).h=s & ( i <> h implies Tape-Chg(t,h,s).i=t.
  i)
proof
  let tm be TuringStr,t be Tape of tm,h be Integer, s be Symbol of tm, i be
  set;
  set t1=Tape-Chg(t,h,s), p=h .--> s;
  thus t1.h=s by FUNCT_7:96;
A1: dom p ={ h } by FUNCOP_1:19;
  assume
  i <> h;
  then not i in dom p by A1,TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

Lm4: for tm being TuringStr,s be All-State of tm, p be State of tm, h be
Element of INT,t be Tape of tm, m,d be Element of NAT st d=h & 1 is Symbol of
tm & s=[p,h,t] & (the Tran of tm).[p,1]=[p,1,1] & p <> the AcceptS of tm & (for
i be Integer st d <= i & i < d+m holds t.i=1) holds (Computation s).m=[p,d+m,t]

proof

  let tm be TuringStr,s be All-State of tm, p be State of tm, h be Element of
  INT,t be Tape of tm, m,d be Element of NAT;

  assume that
A1: d=h and
A2: 1 is Symbol of tm and
A3: s=[p,h,t] and
A4: (the Tran of tm).[p,1]=[p,1,1] and
A5: p <> the AcceptS of tm and
A6: for i be Integer st d <= i & i < d+m holds t.i=1;

  defpred Q[Element of NAT] means $1 <= m implies (Computation s).$1=[p,d+$1,t
  ];

A7: for k being Element of NAT st Q[k] holds Q[k+1]
  proof
    let k be Element of NAT;
    assume
A8: Q[k];
    now
      reconsider T=1 as Symbol of tm by A2;
      set dk=d+k;
      reconsider ik=d+k as Element of INT by INT_1:def 2;
      set sk=[p,ik,t];
      reconsider tt=sk`3 as Tape of tm;
      assume
A9:   k+1 <= m;
      then k < m by NAT_1:13;
      then dk < d+m by XREAL_1:10;
      then
A10:  t.ik=1 by A6,NAT_1:11;
A11:  TRAN(sk) =(the Tran of tm).[p,tt.Head(sk)] by MCART_1:68
        .=(the Tran of tm).[p,t.Head(sk)] by MCART_1:68
        .=[p,1,1] by A4,A10,MCART_1:68;
      then
A12:  offset TRAN(sk)=1 by MCART_1:68;

A13:  Tape-Chg(sk`3, Head(sk),(TRAN(sk))`2)=Tape-Chg(t,Head(sk), (TRAN(sk
      ))`2) by MCART_1:68

        .=Tape-Chg(t,dk,(TRAN(sk))`2) by MCART_1:68
        .=Tape-Chg(t,dk,T) by A11,MCART_1:68
        .=t by A10,Th28;
      thus (Computation s).(k+1)=Following sk by A8,A9,Def8,NAT_1:13
        .= [(TRAN(sk))`1, Head(sk)+ offset TRAN(sk), t] by A5,A13,Th29
        .= [p, Head(sk)+ offset TRAN(sk), t] by A11,MCART_1:68
        .= [p, dk+1, t] by A12,MCART_1:68
        .= [p, d+(k+1), t];
    end;
    hence thesis;
  end;
A14: Q[0] by A1,A3,Def8;
  for k holds Q[k] from NAT_1:sch 1(A14,A7);
  hence thesis;
end;

theorem Th31:
  for s being All-State of SumTuring, t be Tape of SumTuring, head
,n1,n2 be Element of NAT st s=[0,head,t] & t storeData <*head,n1,n2 *> holds s
is Accept-Halt & (Result s)`2=1+head & (Result s)`3 storeData <*1+head,n1+n2 *>
proof
  reconsider F=0 as Symbol of SumTuring by Lm2;
  let s be All-State of SumTuring, t be Tape of SumTuring, h,n1,n2 be Element
  of NAT;
  assume that
A1: s=[0,h,t] and
A2: t storeData <*h,n1,n2 *>;
A3: t.(h+n1+2)=0 by A2,Th22;
  set j3=h+n1+n2+4-1;
  reconsider h1=h+1 as Element of INT by INT_1:def 2;
A4: h < h1 by XREAL_1:31;
  set t1=Tape-Chg(t,h1,F);
A5: h+1+1+n1=h+n1+2;
  reconsider p4=4 as State of SumTuring by Lm1;
  reconsider m3=j3 as Element of INT by INT_1:def 2;
  set j2=j3-1;
  reconsider m2=j2 as Element of INT by INT_1:def 2;
  set j1=n1+n2+1;
  set Rs=(Computation s).(n1+1+(n2+1)+1+1+(1+1)+(j1+1));
  reconsider p2=2 as State of SumTuring by Lm1;
  reconsider i2=h1+1 as Element of INT by INT_1:def 2;
  reconsider nk=h1+1+n1 as Element of INT by INT_1:def 2;
  set i3=h+1+1+n1+1;
  reconsider n3=i3 as Element of INT by INT_1:def 2;
A6: j2-1=h+j1;
  reconsider T=1 as Symbol of SumTuring by Lm2;
  set t2=Tape-Chg(t1,nk,T);
A7: h1+1 <= h+1+1+n1 & h1 < h1+1 by NAT_1:11,XREAL_1:31;
  set i4=h+n1+n2+4;
  reconsider p0=0 as State of SumTuring by Lm1;
A8: i4+ -1=j3;
  set s1= [p0,h1,t];
A9: t.h=0 by A2,Th22;
  h <= h+n1 by NAT_1:11;
  then
A10: h+2 <= h+n1+2 by XREAL_1:9;
A11: t.(h+n1+n2+4)=0 by A2,Th22;
  h <= h+(n1+n2) by NAT_1:11;
  then
A12: h+4 <= h+n1+n2+4 by XREAL_1:9;
  then
A13: h1 < h+3 & h+4-1 <= j3 by XREAL_1:10,11;
A14: h1 < h+2 by XREAL_1:10;
  then
A15: h1 < h+n1+2 by A10,XXREAL_0:2;
A16: t.h=0 by A2,Th22;
A17: t1.h=0 & t1.(h+n1+2)=0 & t1.(h+n1+n2+4)=0 & (for i be Integer st h1 < i
  & i < h+1+1+n1 holds t1.i=1) & for i be Integer st h+n1+2 < i & i < h+n1+n2+4
  holds t1.i=1
  proof
    thus t1.h=0 by A16,A4,Th30;
    thus t1.(h+n1+2)=0 by A3,A10,A14,Th30;
    h1 < h+4 by XREAL_1:10;
    hence t1.(h+n1+n2+4)=0 by A11,A12,Th30;
    hereby
      let i be Integer;
      assume that
A18:  h1 < i and
A19:  i < h+1+1+n1;
A20:  h < i by A4,A18,XXREAL_0:2;
      thus t1.i=t.i by A18,Th30
        .=1 by A2,A5,A19,A20,Th22;
    end;
    hereby
      let i be Integer;
      assume that
A21:  h+n1+2 < i and
A22:  i < h+n1+n2+4;
      thus t1.i=t.i by A15,A21,Th30
        .=1 by A2,A21,A22,Th22;
    end;
  end;
A23: for i be Integer st h+1+1 <= i & i < h+1+1+n1 holds t1.i=1
  proof
    let i be Integer;
    assume that
A24: h+1+1 <= i and
A25: i < h+1+1+n1;
    h1 < h1+1 by XREAL_1:31;
    then h1 < i by A24,XXREAL_0:2;
    hence thesis by A17,A25;
  end;
  set t3=Tape-Chg(t2,j3,F);
A26: t1.h1=0 by Th30;
A27: t2.h1=0 & t2.(h+n1+n2+4)=0 & for i be Integer st h1 < i & i < h+n1+n2+4
  holds t2.i=1
  proof
    thus t2.h1=0 by A26,A7,Th30;
    h+n1 <= h+n1+n2 by NAT_1:11;
    then
A28: h+1+1+n1 <= h+n1+n2+2 by A5,XREAL_1:9;
    h+n1+n2+2 < h+n1+n2+4 by XREAL_1:10;
    hence t2.(h+n1+n2+4)=0 by A17,A28,Th30;
    hereby
      let i be Integer;
      assume that
A29:  h1 < i and
A30:  i < h+n1+n2+4;
      per cases by XXREAL_0:1;
      suppose
A31:    i < h+1+1+n1;
        hence t2.i=t1.i by Th30
          .=1 by A17,A29,A31;
      end;
      suppose
        i = h+1+1+n1;
        hence t2.i=1 by Th30;
      end;
      suppose
A32:    i > h+1+1+n1;
        hence t2.i=t1.i by Th30
          .=1 by A17,A30,A32;
      end;
    end;
  end;
A33: t3.h1=0 & t3.j3=0 & for i be Integer st h1 < i & i < j3 holds t3.i=1
  proof
    thus t3.h1=0 by A27,A13,Th30;
    thus t3.j3=0 by Th30;
    hereby
      let i be Integer;
      assume that
A34:  h1 < i and
A35:  i < j3;
A36:  i < h+n1+n2+4 by A35,XREAL_1:148,XXREAL_0:2;
      thus t3.i=t2.i by A35,Th30
        .=1 by A27,A34,A36;
    end;
  end;
  then
A37: t3 is_1_between h1,h1+(n1+n2)+2 by Def13;
  reconsider p3=3 as State of SumTuring by Lm1;
  set sm=[p2,n3,t2];
  reconsider n4=i4 as Element of INT by INT_1:def 2;
  set sp2=[p2,n4,t2];
  set sp3=[p3,m3,t2];
  reconsider p1=1 as State of SumTuring by Lm1;
  set s2=[p1,i2,t1];
  set sn=[p1,nk,t1];
  reconsider sn3=sn`3 as Tape of SumTuring;
A38: j3+ -1=j2;
A39: TRAN(sn) =Sum_Tran.[sn`1, sn3.Head(sn)] by Def15
    .=Sum_Tran.[p1,sn3.Head(sn)] by MCART_1:68
    .=Sum_Tran.[p1,t1.Head(sn)] by MCART_1:68
    .=[2,1,1] by A17,Th17,MCART_1:68;
  then
A40: offset TRAN(sn)=1 by MCART_1:68;
  reconsider sn3=sp2`3 as Tape of SumTuring;
A41: TRAN(sp2) =Sum_Tran.[sp2`1, sn3.Head(sp2)] by Def15
    .=Sum_Tran.[p2,sn3.Head(sp2)] by MCART_1:68
    .=Sum_Tran.[p2,t2.Head(sp2)] by MCART_1:68
    .=[3,0,-1] by A27,Th17,MCART_1:68;
  then
A42: offset TRAN(sp2)=-1 by MCART_1:68;
  Tape-Chg(sp2`3, Head(sp2),(TRAN(sp2))`2)=Tape-Chg(t2, Head(sp2), (TRAN(
  sp2))`2) by MCART_1:68
    .=Tape-Chg(t2,i4,(TRAN(sp2))`2) by MCART_1:68
    .=Tape-Chg(t2,i4,F) by A41,MCART_1:68
    .=t2 by A27,Th28;
  then
A43: Following sp2 = [(TRAN(sp2))`1, Head(sp2)+ offset TRAN(sp2), t2] by Lm3
    .= [3, Head(sp2)+ offset TRAN(sp2), t2] by A41,MCART_1:68
    .= [3, j3,t2] by A42,A8,MCART_1:68;
  Tape-Chg(sn`3, Head(sn),(TRAN(sn))`2)=Tape-Chg(t1, Head(sn),(TRAN(sn))
  `2) by MCART_1:68
    .=Tape-Chg(t1,nk,(TRAN(sn))`2) by MCART_1:68
    .=t2 by A39,MCART_1:68;
  then
A44: Following sn = [(TRAN(sn))`1, Head(sn)+ offset TRAN(sn), t2] by Lm3
    .= [2, Head(sn)+ offset TRAN(sn), t2] by A39,MCART_1:68
    .= sm by A40,MCART_1:68;
  reconsider s3=s`3 as Tape of SumTuring;
A45: TRAN(s) =Sum_Tran.[s`1, s3.Head(s)] by Def15
    .=Sum_Tran.[0,s3.Head(s)] by A1,MCART_1:68
    .=Sum_Tran.[0,t.Head(s)] by A1,MCART_1:68
    .=Sum_Tran.[0,t.h ] by A1,MCART_1:68
    .=[0,0,1] by A2,Th17,Th22;
  then
A46: offset TRAN(s)=1 by MCART_1:68;
A47: h1 < h1+1+n1 by A7,XXREAL_0:2;
A48: for i be Integer st i3 <= i & i < i3+(n2+1) holds t2.i=1
  proof
    let i be Integer;
    assume that
A49: i3 <= i and
A50: i < i3+(n2+1);
    nk < i3 by XREAL_1:31;
    then h1 < i3 by A47,XXREAL_0:2;
    then h1 < i by A49,XXREAL_0:2;
    hence thesis by A27,A50;
  end;
  set sp5=[p4, h1, t3];
  set sp4=[p4,m2,t3];
  defpred R[Element of NAT] means h+$1 < j2 implies (Computation sp4).$1=[4,j2
  -$1,t3];
  (the Tran of SumTuring).[p2,1] =[p2,1,1] & p2 <> the AcceptS of
  SumTuring by Def15,Th17;
  then
A51: (Computation sm).(n2+1)=[2,h+n1+n2+4,t2] by A48,Lm4;
  h1 < j3 by A13,XXREAL_0:2;
  then
A52: t2.j3=1 by A27,XREAL_1:148;
  reconsider sn3=sp3`3 as Tape of SumTuring;
A53: TRAN(sp3) =Sum_Tran.[sp3`1, sn3.Head(sp3)] by Def15
    .=Sum_Tran.[p3,sn3.Head(sp3)] by MCART_1:68
    .=Sum_Tran.[p3,t2.Head(sp3)] by MCART_1:68
    .=[4,0,-1] by A52,Th17,MCART_1:68;
  then
A54: offset TRAN(sp3)=-1 by MCART_1:68;
A55: for k being Element of NAT st R[k] holds R[k+1]
  proof
    let k be Element of NAT;
    assume
A56: R[k];
    now
      reconsider ik=j2-k as Element of INT by INT_1:def 2;
      set k3=j2-k;
      set sk=[p4,ik,t3];
      reconsider tt=sk`3 as Tape of SumTuring;
      assume
A57:  h+(k+1) < j2;
      then h1+k < j2+0;
      then
A58:  h1-0 < j2-k by XREAL_1:23;
      h1 >= 0 by NAT_1:2;
      then reconsider ii=j2-k as Element of NAT by A58,INT_1:16,XXREAL_0:2;
      j2 <= j2+k by INT_1:19;
      then j2 -k <= j2 by XREAL_1:22;
      then j2 -k < j3 by XREAL_1:148,XXREAL_0:2;
      then
A59:  t3.ii=1 by A33,A58;
A60:  TRAN(sk) =Sum_Tran.[sk`1, tt.Head(sk)] by Def15
        .=Sum_Tran.[p4,tt.Head(sk)] by MCART_1:68
        .=Sum_Tran.[p4,t3.Head(sk)] by MCART_1:68
        .=[4,1,-1] by A59,Th17,MCART_1:68;
      then
A61:  offset TRAN(sk)=-1 by MCART_1:68;
A62:  Tape-Chg(sk`3, Head(sk),(TRAN(sk))`2)=Tape-Chg(t3,Head(sk), (TRAN(
      sk))`2) by MCART_1:68
        .=Tape-Chg(t3,k3,(TRAN(sk))`2) by MCART_1:68
        .=Tape-Chg(t3,k3,T) by A60,MCART_1:68
        .=t3 by A59,Th28;
      h+k < h+k+1 by XREAL_1:31;
      hence (Computation sp4).(k+1)=Following sk by A56,A57,Def8,XXREAL_0:2
        .= [(TRAN(sk))`1, Head(sk)+ offset TRAN(sk), t3] by A62,Lm3
        .= [4, Head(sk)+ offset TRAN(sk), t3] by A60,MCART_1:68
        .= [4, j2-k+-1, t3] by A61,MCART_1:68
        .= [4, j2-(k+1), t3];
    end;
    hence thesis;
  end;
A63: R[0] by Def8;
  for k being Element of NAT holds R[k] from NAT_1:sch 1(A63,A55);
  then
A64: (Computation sp4).j1=[4,j2-j1,t3] by A6,XREAL_1:148
    .=sp5;
  reconsider s3=s1`3 as Tape of SumTuring;
A65: TRAN(s1) =Sum_Tran.[s1`1, s3.Head(s1)] by Def15
    .=Sum_Tran.[p0,s3.Head(s1)] by MCART_1:68
    .=Sum_Tran.[p0,t.Head(s1)] by MCART_1:68
    .=Sum_Tran.[0,t.h1] by MCART_1:68
    .=[1,0,1] by A2,A4,A15,Th17,Th22;
  then
A66: offset TRAN(s1)=1 by MCART_1:68;
  Tape-Chg(sp3`3, Head(sp3),(TRAN(sp3))`2)=Tape-Chg(t2, Head(sp3), (TRAN(
  sp3))`2) by MCART_1:68
    .=Tape-Chg(t2,j3,(TRAN(sp3))`2) by MCART_1:68
    .=t3 by A53,MCART_1:68;
  then
A67: Following sp3 = [(TRAN(sp3))`1, Head(sp3)+ offset TRAN(sp3), t3] by Lm3
    .= [4, Head(sp3)+ offset TRAN(sp3), t3] by A53,MCART_1:68
    .= sp4 by A54,A38,MCART_1:68;
A68: now
    reconsider tt=sp5`3 as Tape of SumTuring;
A69: TRAN(sp5) =Sum_Tran.[sp5`1, tt.Head(sp5)] by Def15
      .=Sum_Tran.[4,tt.Head(sp5)] by MCART_1:68
      .=Sum_Tran.[4,t3.Head(sp5)] by MCART_1:68
      .=[5,0,0] by A33,Th17,MCART_1:68;
    then
A70: offset TRAN(sp5)=0 by MCART_1:68;
    Tape-Chg(sp5`3, Head(sp5),(TRAN(sp5))`2) =Tape-Chg(t3, Head(sp5),(
    TRAN(sp5))`2) by MCART_1:68
      .=Tape-Chg(t3,h1,(TRAN(sp5))`2) by MCART_1:68
      .=Tape-Chg(t3,h1,F) by A69,MCART_1:68
      .=t3 by A33,Th28;
    hence Following sp5 = [(TRAN(sp5))`1, Head(sp5)+ offset TRAN(sp5), t3] by
Lm3
      .= [5, Head(sp5)+ offset TRAN(sp5), t3] by A69,MCART_1:68
      .= [5, h1+ 0, t3] by A70,MCART_1:68;
  end;
  Tape-Chg(s1`3, Head(s1),(TRAN(s1))`2)=Tape-Chg(t, Head(s1),(TRAN(s1))`2
  ) by MCART_1:68
    .=Tape-Chg(t,h1,(TRAN(s1))`2) by MCART_1:68
    .=t1 by A65,MCART_1:68;
  then
A71: Following s1 = [(TRAN(s1))`1, Head(s1)+ offset TRAN(s1), t1] by Lm3
    .= [1, Head(s1)+ offset TRAN(s1), t1] by A65,MCART_1:68
    .= s2 by A66,MCART_1:68;
  Tape-Chg(s`3, Head(s),(TRAN(s))`2)=Tape-Chg(t, Head(s),(TRAN(s))`2) by A1,
MCART_1:68
    .=Tape-Chg(t,h,(TRAN(s))`2) by A1,MCART_1:68
    .=Tape-Chg(t,h,F) by A45,MCART_1:68
    .=t by A9,Th28;
  then
A72: Following s = [(TRAN(s))`1, Head(s)+offset TRAN(s),t] by A1,Lm3
    .= [0, Head(s)+ offset TRAN(s),t] by A45,MCART_1:68
    .= s1 by A1,A46,MCART_1:68;
  (Computation s).(1+1)= Following (Computation s).1 by Def8
    .=s2 by A72,A71,Th12;
  then (Computation s).(n1+1+(n2+1)+1+1+(1+1)) = (Computation s2).(n1+1+(n2+1
  )+1+1) by Th13;
  then (Computation s).(n1+1+(n2+1)+1+1+(1+1)) = Following (Computation s2).(
  n1+1+(n2+1)+1) by Def8
    .= Following Following (Computation s2).(n1+1+(n2+1)) by Def8
    .= Following Following (Computation (Computation s2).(n1+1)).(n2+1) by Th13
;
  then
A73: Rs=(Computation Following Following (Computation (Computation s2).(n1+
  1)).(n2+1)).(j1+1) by Th13
    .=(Computation Following Following (Computation Following (Computation
  s2).n1).(n2+1)).(j1+1) by Def8;
  (the Tran of SumTuring).[p1,1] =[p1,1,1] & p1 <> the AcceptS of
  SumTuring by Def15,Th17;
  then Rs=(Computation Following sp3).(j1+1) by A23,A44,A51,A43,A73,Lm4;
  then
A74: Rs=[5, h1, t3] by A67,A64,A68,Def8;
  then
A75: Rs`1 = 5 by MCART_1:68
    .=the AcceptS of SumTuring by Def15;
  hence s is Accept-Halt by Def9;
  then
A76: Result s =Rs by A75,Def10;
  hence (Result s)`2= 1+h by A74,MCART_1:68;
  (Result s)`3= t3 by A74,A76,MCART_1:68;
  hence thesis by A37,Th19;
end;

definition
  let T be TuringStr,F be Function;
  pred T computes F means
  :Def16:
  for s being All-State of T,t being Tape of T
  , a being Element of NAT, x being FinSequence of NAT st x in dom F & s=[the
  InitS of T,a,t] & t storeData <*a*>^x holds s is Accept-Halt & ex b, y being
Element of NAT st (Result s)`2=b & y=F.x & (Result s)`3 storeData <*b*>^<* y *>
  ;
end;

theorem Th32:
  dom [+] c= 2-tuples_on NAT
proof
  arity (1 proj 1)=1 by COMPUT_1:41;
  then dom [+] c= (1+1)-tuples_on NAT by COMPUT_1:60;
  hence thesis;
end;

theorem
  SumTuring computes [+]
proof
  now
    let s be All-State of SumTuring,t be Tape of SumTuring, h1 be Element of
    NAT, x be FinSequence of NAT;
    assume that
A1: x in dom [+] and
A2: s=[the InitS of SumTuring,h1,t] and
A3: t storeData <*h1*>^x;
    x is Tuple of 2,NAT by A1,Th32,FINSEQ_2:151;
    then consider i,j such that
A4: x = <*i,j*> by FINSEQ_2:120;
A5: s = [0,h1,t] by A2,Def15;
A6: <*h1*>^x=<*h1,i,j*> by A4,FINSEQ_1:60;
    hence s is Accept-Halt by A3,A5,Th31;
    take h2=1+h1;
    take y=i+j;
    t storeData <*h1,i,j *> by A3,A4,FINSEQ_1:60;
    hence (Result s)`2=h2 by A5,Th31;
    thus y=[+].x by A4,COMPUT_1:89;
    (Result s)`3 storeData <*1+h1,i+j *> by A3,A5,A6,Th31;
    hence (Result s)`3 storeData <*h2*>^<* y *> by FINSEQ_1:def 9;
  end;
  hence thesis by Def16;
end;

begin :: Computing successor function(i.e. s(x)=x+1)

definition
  func Succ_Tran -> Function of [: SegM 4,{0,1} :], [: SegM 4,{0,1},{ -1,0,1 }
  :] equals
  id([: SegM 4,{0,1} :],{ -1,0,1 }, 0) +* ([0,0] .--> [1,0,1]) +* ([1,1
] .--> [1,1,1]) +* ([1,0] .--> [2,1,1]) +* ([2,0] .--> [3,0,-1]) +* ([2,1] .-->
  [3,0,-1]) +* ([3,1] .--> [3,1,-1]) +* ([3,0] .--> [4,0,0]);
  coherence
  proof
    reconsider p0=0, p1=1, p2=2, p3=3, p4=4 as Element of SegM 4 by Th1;
    set A=[: SegM 4,{0,1} :], B= { -1,0,1 }, C=[: SegM 4,{0,1}, B :];
    reconsider b0=0, b1=1 as Element of {0,1} by TARSKI:def 2;
    reconsider L=-1 as Element of B by ENUMSET1:def 1;
    reconsider h=0, R=1 as Element of {-1,0,1} by ENUMSET1:def 1;
    C=[: A, B :] by ZFMISC_1:def 3;
    then reconsider OP=id(A,B,h) as Function of A,C;
    id(A,B,0) +* ([0,0] .--> [1,0,1]) +* ([1,1] .--> [1,1,1]) +* ([1,0]
.--> [2,1,1]) +* ([2,0] .--> [3,0,-1]) +* ([2,1] .--> [3,0,-1]) +* ([3,1] .-->
[3,1,-1]) +* ([3,0] .--> [4,0,0]) =OP +* ([p0,b0] .--> [p1,b0,R]) +* ([p1,b1]
.--> [p1,b1,R]) +* ([p1,b0] .--> [p2,b1,R]) +* ([p2,b0] .--> [p3,b0,L]) +* ([p2
,b1] .--> [p3,b0,L]) +* ([p3,b1] .--> [p3,b1,L]) +* ([p3,b0] .--> [p4,b0,h]);
    hence thesis;
  end;
end;

theorem Th34:
  Succ_Tran.[0,0]=[1,0,1] & Succ_Tran.[1,1]=[1,1,1] & Succ_Tran.[1
,0]=[2,1,1] & Succ_Tran.[2,0]=[3,0,-1] & Succ_Tran.[2,1]=[3,0,-1] & Succ_Tran.[
  3,1]=[3,1,-1] & Succ_Tran.[3,0]=[4,0,0]
proof
  set x=[1,1];
  set x1=[0,0];
  set p1=[0,0] .--> [1,0,1], p2=[1,1] .--> [1,1,1], p3=[1,0] .--> [2,1,1], p4=
  [2,0] .--> [3,0,-1], p5=[2,1] .--> [3,0,-1], p6=[3,1] .--> [3,1,-1], f= id([:
  SegM 4,{0,1} :],{ -1,0,1 },0);
  thus Succ_Tran.x1=(f +* p1+* p2+* p3+* p4+* p5+* p6).x1 by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5).x1 by Th2
    .=(f +* p1+* p2+* p3+* p4).x1 by Th2
    .=(f +* p1+* p2+* p3).x1 by Th2
    .=(f +* p1+* p2).x1 by Th2
    .=(f +* p1).x1 by Th3
    .=[1,0,1] by FUNCT_7:96;
  thus Succ_Tran.x=(f +* p1+* p2+* p3+* p4+* p5+* p6).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5).x by Th2
    .=(f +* p1+* p2+* p3+* p4).x by Th2
    .=(f +* p1+* p2+* p3).x by Th2
    .=(f +* p1+* p2).x by Th3
    .=[1,1,1] by FUNCT_7:96;
  set x=[1,0];
  thus Succ_Tran.x=(f +* p1+* p2+* p3+* p4+* p5+* p6).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5).x by Th2
    .=(f +* p1+* p2+* p3+* p4).x by Th2
    .=(f +* p1+* p2+* p3).x by Th2
    .=[2,1,1] by FUNCT_7:96;
  set x=[2,0];
  thus Succ_Tran.x=(f +* p1+* p2+* p3+* p4+* p5+* p6).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5).x by Th2
    .=(f +* p1+* p2+* p3+* p4).x by Th3
    .=[3,0,-1] by FUNCT_7:96;
  set x=[2,1];
  thus Succ_Tran.x=(f +* p1+* p2+* p3+* p4+* p5+* p6).x by Th2
    .=(f +* p1+* p2+* p3+* p4+* p5).x by Th2
    .=[3,0,-1] by FUNCT_7:96;
  set x=[3,1];
  thus Succ_Tran.x=(f +* p1+* p2+* p3+* p4+* p5+* p6).x by Th3
    .=[3,1,-1] by FUNCT_7:96;
  set x=[3,0];
  thus thesis by FUNCT_7:96;
end;

definition
  func SuccTuring -> strict TuringStr means
  :Def18:
  the Symbols of it = { 0,1
} & the FStates of it = SegM 4 & the Tran of it = Succ_Tran & the InitS of
it =
  0 & the AcceptS of it = 4;
  existence
  proof
    set St=SegM 4;
    reconsider p0=0, qF=4 as Element of St by Th1;
    set Sym = { 0,1 };
    take TuringStr(# Sym,St, Succ_Tran, p0, qF #);
    thus thesis;
  end;
  uniqueness;
end;

Lm5: for n be Element of NAT st n <= 4 holds n is State of SuccTuring
proof
  let n be Element of NAT;
  assume
A1: n <= 4;
  the FStates of SuccTuring=SegM 4 by Def18;
  hence thesis by A1,Th1;
end;

Lm6: 0 in the Symbols of SuccTuring & 1 in the Symbols of SuccTuring
proof
  0 in {0,1} & 1 in {0,1} by TARSKI:def 2;
  hence thesis by Def18;
end;

Lm7: for s being All-State of SuccTuring, p,h,t be set st s=[p,h,t] & p <> 4
holds Following s = [(TRAN(s))`1, Head(s)+ offset TRAN(s), Tape-Chg(s`3, Head(s
),(TRAN(s))`2)]

proof
  let s be All-State of SuccTuring, p,h,t be set;
  assume
A1: s=[p,h,t] & p <> 4;
  4=the AcceptS of SuccTuring by Def18;
  hence thesis by A1,Th29;
end;

canceled;

theorem Th36:
  for s being All-State of SuccTuring, t be Tape of SuccTuring,
  head,n be Element of NAT st s=[0,head,t] & t storeData <*head,n*> holds s is
  Accept-Halt & (Result s)`2=head & (Result s)`3 storeData <*head,n+1*>
proof
  reconsider F=0 as Symbol of SuccTuring by Lm6;
  let s be All-State of SuccTuring,t be Tape of SuccTuring, h,n be Element of
  NAT;
  assume that
A1: s=[0,h,t] and
A2: t storeData <*h,n *>;
A3: t.h=0 by A2,Th20;
  set i3=h+1+1+n+1;
  reconsider h1=h+1 as Element of INT by INT_1:def 2;
  reconsider p1=1 as State of SuccTuring by Lm5;
A4: h1+1+n < i3 by XREAL_1:31;
  h <= h+n by NAT_1:11;
  then
A5: h+2 <= h+n+2 by XREAL_1:9;
A6: h1 < h+2 by XREAL_1:10;
  then
A7: h1 < h+n+2 by A5,XXREAL_0:2;
  reconsider p2=2 as State of SuccTuring by Lm5;
  reconsider i2=h1+1 as Element of INT by INT_1:def 2;
  reconsider nk=h1+1+n as Element of INT by INT_1:def 2;
  reconsider hh=h as Element of INT by INT_1:def 2;
  reconsider n3=i3 as Element of INT by INT_1:def 2;
  reconsider T=1 as Symbol of SuccTuring by Lm6;
A8: n3+-1=h+1+1+n;
  set t1=Tape-Chg(t,h1,T);
A9: h < h1 by XREAL_1:31;
A10: t.(h+n+2)=0 by A2,Th20;
A11: t1.h=0 & t1.(h+n+2)=0 & for i be Integer st h < i & i < h+n+2 holds t1.
  i=1
  proof
    thus t1.h=0 by A3,A9,Th30;
    thus t1.(h+n+2)=0 by A10,A5,A6,Th30;
    hereby
      let i be Integer;
      assume
A12:  h < i & i < h+n+2;
      per cases;
      suppose
        h1=i;
        hence t1.i=1 by Th30;
      end;
      suppose
        h1<>i;
        hence t1.i=t.i by Th30
          .=1 by A2,A12,Th20;
      end;
    end;
  end;
A13: for i be Integer st h+1+1 <= i & i < h+1+1+n holds t1.i=1
  proof
    let i be Integer;
    assume that
A14: h+1+1 <= i and
A15: i < h+1+1+n;
    h1 < h1+1 by XREAL_1:31;
    then h1 < i by A14,XXREAL_0:2;
    then h < i by A9,XXREAL_0:2;
    hence thesis by A11,A15;
  end;
  reconsider s3=s`3 as Tape of SuccTuring;
A16: TRAN(s) =Succ_Tran.[s`1, s3.Head(s)] by Def18
    .=Succ_Tran.[0,s3.Head(s)] by A1,MCART_1:68
    .=Succ_Tran.[0,t.Head(s)] by A1,MCART_1:68
    .=[1,0,1] by A1,A3,Th34,MCART_1:68;
  then
A17: offset TRAN(s)=1 by MCART_1:68;
  set s1= [p1,h1,t];
  reconsider s3=s1`3 as Tape of SuccTuring;
  Tape-Chg(s`3, Head(s),(TRAN(s))`2)=Tape-Chg(t, Head(s),(TRAN(s))`2) by A1,
MCART_1:68
    .=Tape-Chg(t,h,(TRAN(s))`2) by A1,MCART_1:68
    .=Tape-Chg(t,h,F) by A16,MCART_1:68
    .=t by A3,Th28;
  then
A18: Following s = [(TRAN(s))`1, Head(s)+offset TRAN(s),t] by A1,Lm7
    .= [1, Head(s)+ offset TRAN(s),t] by A16,MCART_1:68
    .= s1 by A1,A17,MCART_1:68;
A19: TRAN(s1) =Succ_Tran.[s1`1, s3.Head(s1)] by Def18
    .=Succ_Tran.[p1,s3.Head(s1)] by MCART_1:68
    .=Succ_Tran.[p1,t.Head(s1)] by MCART_1:68
    .=Succ_Tran.[1,t.h1] by MCART_1:68
    .=[1,1,1] by A2,A9,A7,Th20,Th34;
  then
A20: offset TRAN(s1)=1 by MCART_1:68;
  reconsider p1=1 as State of SuccTuring by Lm5;
  set s2=[p1,i2,t1];
  Tape-Chg(s1`3, Head(s1),(TRAN(s1))`2)=Tape-Chg(t, Head(s1),(TRAN(s1))`2
  ) by MCART_1:68
    .=Tape-Chg(t,h1,(TRAN(s1))`2) by MCART_1:68
    .=t1 by A19,MCART_1:68;
  then
A21: Following s1 = [(TRAN(s1))`1,Head(s1)+ offset TRAN(s1),t1] by Lm7
    .= [1,Head(s1)+ offset TRAN(s1),t1] by A19,MCART_1:68
    .= s2 by A20,MCART_1:68;
  reconsider p3=3 as State of SuccTuring by Lm5;
  set sn=[p1,nk,t1];
  set t2=Tape-Chg(t1,nk,T);
  set t3=Tape-Chg(t2,n3,F);
  (the Tran of SuccTuring).[p1,1] =[p1,1,1] & p1 <> the AcceptS of
  SuccTuring by Def18,Th34;
  then
A22: (Computation s2).n=[p1,h+1+1+n,t1] by A13,Lm4;
  h1+1 <= h+1+1+n & h1 < h1+1 by NAT_1:11,XREAL_1:31;
  then
A23: h1 < h1+1+n by XXREAL_0:2;
A24: t2.h=0 & for i be Integer st h < i & i <= h+n+2 holds t2.i=1
  proof
    thus t2.h=0 by A9,A11,A23,Th30;
    hereby
      let i be Integer;
      assume that
A25:  h < i and
A26:  i <= h+n+2;
      per cases;
      suppose
A27:    i <> h+n+2;
        then
A28:    i < h+n+2 by A26,XXREAL_0:1;
        thus t2.i=t1.i by A27,Th30
          .=1 by A11,A25,A28;
      end;
      suppose
        i = h+n+2;
        hence t2.i=1 by Th30;
      end;
    end;
  end;
  set sp3=[p3,nk,t3];
  set sm=[p2,n3,t2];
  reconsider sm3=sm`3 as Tape of SuccTuring;
A29: the Symbols of SuccTuring = {0,1} by Def18;
A30: now
    per cases by A29,TARSKI:def 2;
    suppose
      t2.n3=1;
      hence Succ_Tran.[2,t2.n3 ]=[p3,0,-1] by Th34;
    end;
    suppose
      t2.n3=0;
      hence Succ_Tran.[2,t2.n3 ]=[p3,0,-1] by Th34;
    end;
  end;
A31: TRAN(sm) =Succ_Tran.[sm`1, sm3.Head(sm)] by Def18
    .=Succ_Tran.[2,sm3.Head(sm)] by MCART_1:68
    .=Succ_Tran.[2,t2.Head(sm)] by MCART_1:68
    .=[p3,0,-1] by A30,MCART_1:68;
  then
A32: offset TRAN(sm)=-1 by MCART_1:68;
  set j1=1+1+n, sp5=[p3,hh, t3];
  defpred R[Element of NAT] means h+$1 <= nk implies (Computation sp3).$1=[3,
  nk-$1,t3];
  reconsider sn3=sn`3 as Tape of SuccTuring;
A33: h+j1 =nk;
  set Rs=(Computation s).(1+1+(n+1+1+(j1+1)));
A34: TRAN(sn) =Succ_Tran.[sn`1, sn3.Head(sn)] by Def18
    .=Succ_Tran.[p1,sn3.Head(sn)] by MCART_1:68
    .=Succ_Tran.[p1,t1.Head(sn)] by MCART_1:68
    .=[2,1,1] by A11,Th34,MCART_1:68;
  then
A35: offset TRAN(sn)=1 by MCART_1:68;
A36: h < h1+1+n by A9,A23,XXREAL_0:2;
A37: t3.h=0 & t3.(h+(n+1)+2)=0 & for k be Integer st h < k & k < h+(n+1)+2
  holds t3.k=1
  proof
    thus t3.h=0 by A36,A24,A4,Th30;
    thus t3.(h+(n+1)+2)=0 by Th30;
    hereby
      let i be Integer;
      assume that
A38:  h < i and
A39:  i < h+(n+1)+2;
      i+1 <= h+(n+1)+2 by A39,INT_1:20;
      then
A40:  i <= h+(n+1)+2-1 by XREAL_1:21;
      thus t3.i=t2.i by A39,Th30
        .=1 by A24,A38,A40;
    end;
  end;
  then
A41: t3 is_1_between h,h+(n+1)+2 by Def13;
  Tape-Chg(sm`3, Head(sm),(TRAN(sm))`2) =Tape-Chg(t2, Head(sm),(TRAN(sm))
  `2) by MCART_1:68
    .=Tape-Chg(t2,n3,(TRAN(sm))`2) by MCART_1:68
    .=t3 by A31,MCART_1:68;
  then
A42: Following sm = [(TRAN(sm))`1, Head(sm)+ offset TRAN(sm), t3] by Lm7
    .= [p3,Head(sm)+ offset TRAN(sm),t3] by A31,MCART_1:68
    .= sp3 by A32,A8,MCART_1:68;
  Tape-Chg(sn`3,Head(sn),(TRAN(sn))`2)=Tape-Chg(t1, Head(sn),(TRAN(sn))`2
  ) by MCART_1:68
    .=Tape-Chg(t1,nk,(TRAN(sn))`2) by MCART_1:68
    .=t2 by A34,MCART_1:68;
  then
A43: Following sn = [(TRAN(sn))`1, Head(sn)+ offset TRAN(sn), t2] by Lm7
    .= [2, Head(sn)+ offset TRAN(sn), t2] by A34,MCART_1:68
    .= sm by A35,MCART_1:68;
A44: for k being Element of NAT st R[k] holds R[k+1]
  proof
    let k be Element of NAT;
    assume
A45: R[k];
    now
      reconsider ik=nk-k as Element of INT by INT_1:def 2;
      set k3=nk-k;
A46:  h+k < h+k+1 by XREAL_1:31;
      set sk=[p3,ik,t3];
      reconsider tt=sk`3 as Tape of SuccTuring;
      nk <= nk+k by INT_1:19;
      then
A47:  nk -k <= nk by XREAL_1:22;
      assume
A48:  h+(k+1) <= nk;
      then h+k < nk+0 by A46,XXREAL_0:2;
      then
A49:  h-0 < nk-k by XREAL_1:23;
      h >= 0 by NAT_1:2;
      then reconsider ii=nk-k as Element of NAT by A49,INT_1:16,XXREAL_0:2;
      h+n+2 < h+n+2+1 by XREAL_1:31;
      then ii < h+(n+1)+2 by A47,XXREAL_0:2;
      then
A50:  t3.ii=1 by A37,A49;
A51:  TRAN(sk) =Succ_Tran.[sk`1, tt.Head(sk)] by Def18
        .=Succ_Tran.[p3,tt.Head(sk)] by MCART_1:68
        .=Succ_Tran.[p3,t3.Head(sk)] by MCART_1:68
        .=[3,1,-1] by A50,Th34,MCART_1:68;
      then
A52:  offset TRAN(sk)=-1 by MCART_1:68;
A53:  Tape-Chg(sk`3, Head(sk),(TRAN(sk))`2)=Tape-Chg(t3,Head(sk), (TRAN(
      sk))`2) by MCART_1:68
        .=Tape-Chg(t3,k3,(TRAN(sk))`2) by MCART_1:68
        .=Tape-Chg(t3,k3,T) by A51,MCART_1:68
        .=t3 by A50,Th28;
      hereby
        thus (Computation sp3).(k+1)=Following sk by A45,A48,A46,Def8,
XXREAL_0:2
          .= [(TRAN(sk))`1, Head(sk)+ offset TRAN(sk), t3] by A53,Lm7
          .= [3, Head(sk)+ offset TRAN(sk), t3] by A51,MCART_1:68
          .= [3, nk-k+-1, t3] by A52,MCART_1:68
          .= [3, nk-(k+1), t3];
      end;
    end;
    hence thesis;
  end;
A54: R[0] by Def8;
  for k being Element of NAT holds R[k] from NAT_1:sch 1(A54,A44);
  then
A55: (Computation sp3).j1=[3,nk-j1,t3] by A33
    .=sp5;
A56: now
    reconsider tt=sp5`3 as Tape of SuccTuring;
A57: TRAN(sp5) =Succ_Tran.[sp5`1, tt.Head(sp5)] by Def18
      .=Succ_Tran.[3,tt.Head(sp5)] by MCART_1:68
      .=Succ_Tran.[3,t3.Head(sp5)] by MCART_1:68
      .=[4,0,0] by A37,Th34,MCART_1:68;
    then
A58: offset TRAN(sp5)=0 by MCART_1:68;
    Tape-Chg(sp5`3, Head(sp5),(TRAN(sp5))`2) =Tape-Chg(t3, Head(sp5),(
    TRAN(sp5))`2) by MCART_1:68
      .=Tape-Chg(t3,h,(TRAN(sp5))`2) by MCART_1:68
      .=Tape-Chg(t3,h,F) by A57,MCART_1:68
      .=t3 by A37,Th28;
    hence Following sp5 = [(TRAN(sp5))`1, Head(sp5)+ offset TRAN(sp5), t3] by
Lm7
      .= [4, Head(sp5)+ offset TRAN(sp5), t3] by A57,MCART_1:68
      .= [4, h+ 0, t3] by A58,MCART_1:68;
  end;
  Rs=(Computation (Computation s).(1+1)).(n+1+1+(j1+1)) by Th13
    .=(Computation Following (Computation s).1).(n+1+1+(j1+1)) by Def8
    .=(Computation Following s1).(n+1+1+(j1+1)) by A18,Th12
    .=(Computation (Computation s2).(n+1+1)).(j1+1) by A21,Th13
    .=(Computation Following (Computation s2).(n+1)).(j1+1) by Def8;
  then Rs=(Computation sp3).(j1+1) by A22,A43,A42,Def8;
  then
A59: Rs=[4, h, t3] by A55,A56,Def8;
  then
A60: Rs`1 = 4 by MCART_1:68
    .=the AcceptS of SuccTuring by Def18;
  hence s is Accept-Halt by Def9;
  then
A61: Result s =Rs by A60,Def10;
  hence (Result s)`2= h by A59,MCART_1:68;
  (Result s)`3= t3 by A59,A61,MCART_1:68;
  hence thesis by A41,Th19;
end;

theorem
  SuccTuring computes 1 succ 1
proof
  now
    set sc=1 succ 1;
    let s be All-State of SuccTuring,t be Tape of SuccTuring, h be Element of
    NAT, x be FinSequence of NAT;
    assume that
A1: x in dom sc and
A2: s=[the InitS of SuccTuring,h,t] and
A3: t storeData <*h*>^x;
A4: s = [0,h,t] by A2,Def18;
A5: dom sc = 1-tuples_on NAT by COMPUT_1:def 10;
    x is Tuple of 1,NAT by A1,A5,FINSEQ_2:151;
    then consider i such that
A6: x = <*i*> by FINSEQ_2:117;
A7: <*h*>^x=<*h,i*> by A6,FINSEQ_1:def 9;
    hence s is Accept-Halt by A3,A4,Th36;
    take h2=h;
    take y=i+1;
    thus (Result s)`2=h2 by A3,A4,A7,Th36;
    thus y=(x/.1)+1 by A6,FINSEQ_4:25
      .=sc.x by A1,A5,COMPUT_1:def 10;
    (Result s)`3 storeData <*h2,i+1 *> by A3,A4,A7,Th36;
    hence (Result s)`3 storeData <*h2*>^<* y *> by FINSEQ_1:def 9;
  end;
  hence thesis by Def16;
end;

begin :: Computing zero function (i.e. O(x)=0)

definition
  func Zero_Tran -> Function of [: SegM 4,{0,1} :], [: SegM 4,{0,1},{ -1,0,1 }
  :] equals
  id([: SegM 4,{0,1} :],{ -1,0,1 }, 1) +* ([0,0] .--> [1,0,1]) +* ([1,1
  ] .--> [2,1,1]) +* ([2,0] .--> [3,0,-1]) +* ([2,1] .--> [3,0,-1]) +* ([3,1]
  .--> [4,1,-1]);
  coherence
  proof
    reconsider p0=0, p1=1, p2=2, p3=3, p4=4 as Element of SegM 4 by Th1;
    set A=[: SegM 4,{0,1} :], B= { -1,0,1 }, C=[: SegM 4,{0,1}, B :];
    reconsider b0=0,b1=1 as Element of {0,1} by TARSKI:def 2;
    reconsider L=-1 as Element of B by ENUMSET1:def 1;
    reconsider R=1 as Element of {-1,0,1} by ENUMSET1:def 1;
    C=[: A, B :] by ZFMISC_1:def 3;
    then reconsider OP=id(A,B,R) as Function of A,C;
    id(A,B,1) +* ([0,0] .--> [1,0,1]) +* ([1,1] .--> [2,1,1]) +* ([2,0]
.--> [3,0,-1]) +* ([2,1] .--> [3,0,-1]) +* ([3,1] .--> [4,1,-1]) =OP +* ([p0,b0
] .--> [p1,b0,R]) +* ([p1,b1] .--> [p2,b1,R]) +* ([p2,b0] .--> [p3,b0,L]) +* ([
    p2,b1] .--> [p3,b0,L]) +* ([p3,b1] .--> [p4,b1,L]);
    hence thesis;
  end;
end;

theorem Th38:
  Zero_Tran.[0,0]=[1,0,1] & Zero_Tran.[1,1]=[2,1,1] & Zero_Tran.[2
  ,0]=[3,0,-1] & Zero_Tran.[2,1]=[3,0,-1] & Zero_Tran.[3,1]=[4,1,-1]
proof
  set x=[1,1];
  set x1=[0,0];
  set p1=[0,0] .--> [1,0,1], p2=[1,1] .--> [2,1,1], p3=[2,0] .--> [3,0,-1], p4
  =[2,1] .--> [3,0,-1], f= id([: SegM 4,{0,1} :],{ -1,0,1 },1);
  thus Zero_Tran.x1=(f +* p1+* p2+* p3+* p4).x1 by Th2
    .=(f +* p1+* p2+* p3).x1 by Th2
    .=(f +* p1+* p2).x1 by Th2
    .=(f +* p1).x1 by Th3
    .=[1,0,1] by FUNCT_7:96;
  thus Zero_Tran.x=(f +* p1+* p2+* p3+* p4).x by Th2
    .=(f +* p1+* p2+* p3).x by Th2
    .=(f +* p1+* p2).x by Th3
    .=[2,1,1] by FUNCT_7:96;
  set x=[2,0];
  thus Zero_Tran.x=(f +* p1+* p2+* p3+* p4).x by Th3
    .=(f +* p1+* p2+* p3).x by Th3
    .=[3,0,-1] by FUNCT_7:96;
  set x=[2,1];
  thus Zero_Tran.x=(f +* p1+* p2+* p3+* p4).x by Th2
    .=[3,0,-1] by FUNCT_7:96;
  set x=[3,1];
  thus thesis by FUNCT_7:96;
end;

definition
  func ZeroTuring -> strict TuringStr means
  :Def20:
  the Symbols of it = { 0,1
} & the FStates of it = SegM 4 & the Tran of it = Zero_Tran & the InitS of 
it =
  0 & the AcceptS of it = 4;
  existence
  proof
    set St=SegM 4;
    reconsider qF=4 as Element of St by Th1;
    reconsider p0=0 as Element of St by Th1;
    set Sym = { 0,1 };
    take TuringStr(# Sym,St, Zero_Tran, p0, qF #);
    thus thesis;
  end;
  uniqueness;
end;

Lm8: for n be Element of NAT st n <= 4 holds n is State of ZeroTuring
proof
  let n be Element of NAT;
  assume
A1: n <= 4;
  the FStates of ZeroTuring=SegM 4 by Def20;
  hence thesis by A1,Th1;
end;

Lm9: 0 in the Symbols of ZeroTuring & 1 in the Symbols of ZeroTuring
proof
  0 in {0,1} & 1 in {0,1} by TARSKI:def 2;
  hence thesis by Def20;
end;

Lm10: for s being All-State of ZeroTuring, p,h,t be set st s=[p,h,t] & p <> 4
holds Following s = [(TRAN(s))`1, Head(s)+ offset TRAN(s), Tape-Chg(s`3, Head(s
),(TRAN(s))`2)]

proof
  let s be All-State of ZeroTuring, p,h,t be set;
  assume
A1: s=[p,h,t] & p <> 4;
  4=the AcceptS of ZeroTuring by Def20;
  hence thesis by A1,Th29;
end;

theorem Th39:
  for s being All-State of ZeroTuring, t be Tape of ZeroTuring,
head be Element of NAT, f be FinSequence of NAT st len f >= 1 & s=[0,head,t] &
t storeData <*head*>^f holds s is Accept-Halt & (Result s)`2=head & (Result s)
  `3 storeData <*head,0*>
proof
  reconsider F=0 as Symbol of ZeroTuring by Lm9;
  let s be All-State of ZeroTuring, t be Tape of ZeroTuring, h be Element of
  NAT, f be FinSequence of NAT;
  assume that
A1: len f >= 1 and
A2: s=[0,h,t] and
A3: t storeData <*h*>^f;
  reconsider s3=s`3 as Tape of ZeroTuring;
  reconsider h1=h+1 as Element of INT by INT_1:def 2;
  set m=f/.1, n=h+f/.1+2;
A4: h < h1 by XREAL_1:31;
  reconsider p1=1 as State of ZeroTuring by Lm8;
A5: h1+-1= h;
  set s1= [p1,h1,t];
  reconsider i2=h1+1 as Element of INT by INT_1:def 2;
A6: h1 < i2 by XREAL_1:31;
  reconsider T=1 as Symbol of ZeroTuring by Lm9;
A7: i2+-1= h1;
  set t1=Tape-Chg(t,h1,T);
  set t2=Tape-Chg(t1,i2,F);
  set t3=Tape-Chg(t2,h1,T);
A8: t is_1_between h,n by A1,A3,Th25;
  then
A9: t.h=0 by Def13;
  then t1.h=0 by A4,Th30;
  then t2.h=0 by A4,A6,Th30;
  then
A10: t3.h=0 by A4,Th30;
A11: TRAN(s) =Zero_Tran.[s`1, s3.Head(s)] by Def20
    .=Zero_Tran.[0,s3.Head(s)] by A2,MCART_1:68
    .=Zero_Tran.[0,t.Head(s)] by A2,MCART_1:68
    .=[1,0,1] by A2,A9,Th38,MCART_1:68;
  then
A12: offset TRAN(s)=1 by MCART_1:68;
  set Rs=(Computation s).(1+1+1+1);
  reconsider p3=3 as State of ZeroTuring by Lm8;
A13: h+1+1=h+0+2;
A14: t3.(h+1)=1 by Th30;
A15: now
    let k be Integer;
    assume
    h < k & k < h+0+2;
    then h+1 <= k & k <= h+1 by A13,INT_1:20;
    hence t3.k=1 by A14,XXREAL_0:1;
  end;
  t1.(h+1)=1 by Th30;
  then
A16: t2.(h+1)=1 by A6,Th30;
  set s3=[p3,h1,t2];
  reconsider s33=s3`3 as Tape of ZeroTuring;
A17: TRAN(s3) =Zero_Tran.[s3`1, s33.Head(s3)] by Def20
    .=Zero_Tran.[p3,s33.Head(s3)] by MCART_1:68
    .=Zero_Tran.[p3,t2.Head(s3)] by MCART_1:68
    .=[4,1,-1] by A16,Th38,MCART_1:68;
  then
A18: offset TRAN(s3)=-1 by MCART_1:68;
  reconsider p2=2 as State of ZeroTuring by Lm8;
  reconsider s13=s1`3 as Tape of ZeroTuring;
  h <= h+m by NAT_1:11;
  then
A19: h+2 <= h+m+2 by XREAL_1:9;
  h1 < h+2 by XREAL_1:10;
  then
A20: h1 < n by A19,XXREAL_0:2;
A21: TRAN(s1) =Zero_Tran.[s1`1, s13.Head(s1)] by Def20
    .=Zero_Tran.[p1,s13.Head(s1)] by MCART_1:68
    .=Zero_Tran.[p1,t.Head(s1)] by MCART_1:68
    .=Zero_Tran.[1,t.h1] by MCART_1:68
    .=[2,1,1] by A8,A4,A20,Def13,Th38;
  then
A22: offset TRAN(s1)=1 by MCART_1:68;
A23: now
A24: the Symbols of ZeroTuring = {0,1} by Def20;
    per cases by A24,TARSKI:def 2;
    suppose
      t1.i2=1;
      hence Zero_Tran.[2,t1.i2 ]=[3,0,-1] by Th38;
    end;
    suppose
      t1.i2=0;
      hence Zero_Tran.[2,t1.i2 ]=[3,0,-1] by Th38;
    end;
  end;
  set s2=[p2,i2,t1];
  reconsider s23=s2`3 as Tape of ZeroTuring;
A25: TRAN(s2) =Zero_Tran.[s2`1, s23.Head(s2)] by Def20
    .=Zero_Tran.[p2,s23.Head(s2)] by MCART_1:68
    .=Zero_Tran.[p2,t1.Head(s2)] by MCART_1:68
    .=[3,0,-1] by A23,MCART_1:68;
  then
A26: offset TRAN(s2)=-1 by MCART_1:68;
  Tape-Chg(s2`3, Head(s2),(TRAN(s2))`2) =Tape-Chg(t1, Head(s2),(TRAN(s2))
  `2) by MCART_1:68
    .=Tape-Chg(t1,i2,(TRAN(s2))`2) by MCART_1:68
    .=t2 by A25,MCART_1:68;
  then
A27: Following s2 = [(TRAN(s2))`1, Head(s2)+ offset TRAN(s2), t2] by Lm10
    .= [3, Head(s2)+ offset TRAN(s2), t2] by A25,MCART_1:68
    .= s3 by A26,A7,MCART_1:68;
  reconsider p3=3 as State of ZeroTuring by Lm8;
A28: Tape-Chg(s3`3, Head(s3),(TRAN(s3))`2) =Tape-Chg(t2, Head(s3),(TRAN(s3))
  `2) by MCART_1:68
    .=Tape-Chg(t2,h1,(TRAN(s3))`2) by MCART_1:68
    .=t3 by A17,MCART_1:68;
  set s3=[p3,h1,t2];
A29: Following s3 = [(TRAN(s3))`1, Head(s3)+ offset TRAN(s3), t3] by A28,Lm10
    .= [4, Head(s3)+ offset TRAN(s3), t3] by A17,MCART_1:68
    .= [4, h,t3] by A18,A5,MCART_1:68;
  Tape-Chg(s`3, Head(s),(TRAN(s))`2)=Tape-Chg(t, Head(s),(TRAN(s))`2) by A2,
MCART_1:68
    .=Tape-Chg(t,h,(TRAN(s))`2) by A2,MCART_1:68
    .=Tape-Chg(t,h,F) by A11,MCART_1:68
    .=t by A9,Th28;
  then
A30: Following s = [(TRAN(s))`1, Head(s)+offset TRAN(s),t] by A2,Lm10
    .= [1, Head(s)+ offset TRAN(s),t] by A11,MCART_1:68
    .= s1 by A2,A12,MCART_1:68;
  Tape-Chg(s1`3,Head(s1),(TRAN(s1))`2) =Tape-Chg(t,Head(s1),(TRAN(s1))`2)
  by MCART_1:68
    .=Tape-Chg(t,h1,(TRAN(s1))`2) by MCART_1:68
    .=t1 by A21,MCART_1:68;
  then
A31: Following s1 = [(TRAN(s1))`1, Head(s1)+ offset TRAN(s1), t1] by Lm10
    .= [2, Head(s1)+ offset TRAN(s1), t1] by A21,MCART_1:68
    .= s2 by A22,MCART_1:68;
A32: Rs= Following (Computation s).(1+1+1) by Def8
    .= Following Following (Computation s).(1+1) by Def8
    .= Following Following Following (Computation s).1 by Def8
    .=[4, h,t3] by A30,A31,A27,A29,Th12;
  then
A33: Rs`1 = 4 by MCART_1:68
    .=the AcceptS of ZeroTuring by Def20;
  hence s is Accept-Halt by Def9;
  then
A34: Result s =Rs by A33,Def10;
  hence (Result s)`2= h by A32,MCART_1:68;
A35: (Result s)`3= t3 by A32,A34,MCART_1:68;
  t2.i2=0 by Th30;
  then t3.i2=0 by A6,Th30;
  then t3 is_1_between h,h+0+2 by A10,A15,Def13;
  hence thesis by A35,Th19;
end;

theorem
  n >=1 implies ZeroTuring computes n const 0
proof
  assume
A1: n>=1;
  now
    set cs=n const 0;
    let s be All-State of ZeroTuring,t be Tape of ZeroTuring, h be Element of
    NAT, x be FinSequence of NAT;
    assume that
A2: x in dom cs and
A3: s=[the InitS of ZeroTuring,h,t] and
A4: t storeData <*h*>^x;
    arity cs = n by COMPUT_1:35;
    then
A5: dom cs c= n-tuples_on NAT by COMPUT_1:24;
    then x in n-tuples_on NAT by A2;
    then x in { f where f is Element of NAT*: len f = n } by FINSEQ_2:def 4;
    then
A6: ex f be Element of NAT* st x = f & len f = n;
A7: s = [0,h,t] by A3,Def20;
    hence s is Accept-Halt by A1,A4,A6,Th39;
    take h2=h;
    take y=0;
    thus (Result s)`2=h2 by A1,A4,A6,A7,Th39;
    thus y=cs.x by A2,A5,FUNCOP_1:13;
    (Result s)`3 storeData <*h2,0*> by A1,A4,A6,A7,Th39;
    hence (Result s)`3 storeData <*h2*>^<*y*> by FINSEQ_1:def 9;
  end;
  hence thesis by Def16;
end;

begin :: Computing n-ary project function(i.e. U(x1,x2,...,xn)=x3)

definition
  func U3(n)Tran -> Function of [: SegM 3,{0,1} :], [: SegM 3,{0,1},{ -1,0,1 }
  :] equals
  id([: SegM 3,{0,1} :],{ -1,0,1 }, 0) +* ([0,0] .--> [1,0,1]) +* ([1,1
] .--> [1,0,1]) +* ([1,0] .--> [2,0,1]) +* ([2,1] .--> [2,0,1]) +* ([2,0] .-->
  [3,0,0]);
  coherence
  proof
    reconsider p0=0, p1=1, p2=2, p3=3 as Element of SegM 3 by Th1;
    set A=[: SegM 3,{0,1} :], B= { -1,0,1 }, C=[: SegM 3,{0,1}, B :];
    reconsider b0=0, b1=1 as Element of {0,1} by TARSKI:def 2;
    reconsider h=0, R=1 as Element of B by ENUMSET1:def 1;
    C=[: A, B :] by ZFMISC_1:def 3;
    then reconsider OP=id(A,B,h) as Function of A,C;
    id(A,B,0) +* ([0,0] .--> [1,0,1]) +* ([1,1] .--> [1,0,1]) +* ([1,0]
.--> [2,0,1]) +* ([2,1] .--> [2,0,1]) +* ([2,0] .--> [3,0,0]) =OP +* ([p0,b0]
.--> [p1,b0,R]) +* ([p1,b1] .--> [p1,b0,R]) +* ([p1,b0] .--> [p2,b0,R]) +* ([p2
    ,b1] .--> [p2,b0,R]) +* ([p2,b0] .--> [p3,b0,h]);
    hence thesis;
  end;
end;

theorem Th41:
  U3(n)Tran.[0,0]=[1,0,1] & U3(n)Tran.[1,1]=[1,0,1] & U3(n)Tran.[1
  ,0]=[2,0,1] & U3(n)Tran.[2,1]=[2,0,1] & U3(n)Tran.[2,0]=[3,0,0]
proof
  set x=[1,1];
  set x1=[0,0];
  set p1=[0,0] .--> [1,0,1], p2=[1,1] .--> [1,0,1], p3=[1,0] .--> [2,0,1], p4=
  [2,1] .--> [2,0,1], f= id([: SegM 3,{0,1} :],{ -1,0,1 },0);
  thus U3(n)Tran.x1=(f +* p1+* p2+* p3+* p4).x1 by Th2
    .=(f +* p1+* p2+* p3).x1 by Th2
    .=(f +* p1+* p2).x1 by Th2
    .=(f +* p1).x1 by Th3
    .=[1,0,1] by FUNCT_7:96;
  thus U3(n)Tran.x=(f +* p1+* p2+* p3+* p4).x by Th2
    .=(f +* p1+* p2+* p3).x by Th2
    .=(f +* p1+* p2).x by Th3
    .=[1,0,1] by FUNCT_7:96;
  set x=[1,0];
  thus U3(n)Tran.x=(f +* p1+* p2+* p3+* p4).x by Th2
    .=(f +* p1+* p2+* p3).x by Th3
    .=[2,0,1] by FUNCT_7:96;
  set x=[2,1];
  thus U3(n)Tran.x=(f +* p1+* p2+* p3+* p4).x by Th3
    .=[2,0,1] by FUNCT_7:96;
  set x=[2,0];
  thus thesis by FUNCT_7:96;
end;

definition
  func U3(n)Turing -> strict TuringStr means
  :Def22:
  the Symbols of it = { 0,1
} & the FStates of it = SegM 3 & the Tran of it = U3(n)Tran & the InitS of 
it =
  0 & the AcceptS of it = 3;
  existence
  proof
    set St=SegM 3;
    reconsider qF=3 as Element of St by Th1;
    reconsider p0=0 as Element of St by Th1;
    set Sym = { 0,1 };
    take TuringStr(# Sym,St, U3(n)Tran, p0, qF #);
    thus thesis;
  end;
  uniqueness;
end;

Lm11: for n be Element of NAT st n <= 3 holds n is State of U3(n)Turing
proof
  let n be Element of NAT;
  assume
A1: n <= 3;
  the FStates of U3(n)Turing=SegM 3 by Def22;
  hence thesis by A1,Th1;
end;

Lm12: 0 in the Symbols of U3(n)Turing & 1 in the Symbols of U3(n)Turing
proof
  0 in {0,1} & 1 in {0,1} by TARSKI:def 2;
  hence thesis by Def22;
end;

Lm13: for s being All-State of U3(n)Turing, p,h,t be set st s=[p,h,t] & p <> 3
holds Following s = [(TRAN(s))`1, Head(s)+ offset TRAN(s),Tape-Chg(s`3,Head(s),
(TRAN(s))`2)]

proof
  let s be All-State of U3(n)Turing, p,h,t be set;
  assume
A1: s=[p,h,t] & p <> 3;
  3=the AcceptS of U3(n)Turing by Def22;
  hence thesis by A1,Th29;
end;

Lm14: for tm being TuringStr,s be All-State of tm, p be State of tm, h be
Element of INT,t be Tape of tm, m,d be Element of NAT st d=h & 0 is Symbol of
tm & s=[p,h,t] & (the Tran of tm).[p,1]=[p,0,1] & p <> the AcceptS of tm & (for
i be Integer st d <= i & i < d+m holds t.i=1) holds ex t1 being Tape of tm st (
Computation s).m=[p,d+m,t1] & (for i be Integer st d <= i & i < d+m holds t1.i=
0) & for i be Integer st d > i or i >= d+m holds t1.i=t.i

proof

  let tm be TuringStr,s be All-State of tm, p be State of tm, h be Element of
  INT,t be Tape of tm, m,d be Element of NAT;

  assume that
A1: d=h and
A2: 0 is Symbol of tm and
A3: s=[p,h,t] and
A4: (the Tran of tm).[p,1]=[p,0,1] and
A5: p <> the AcceptS of tm and
A6: for i be Integer st d <= i & i < d+m holds t.i=1;

  defpred Q[Element of NAT] means $1 <= m implies ex t1 being Tape of tm st (

Computation s).$1=[p,d+$1,t1] & (for i be Integer st d <= i & i < d+$1 holds t1
  .i=0) & (for i be Integer st d > i or i >= d+$1 holds t1.i=t.i);

A7: for k being Element of NAT st Q[k] holds Q[k+1]
  proof
    let k be Element of NAT;
    assume
A8: Q[k];
    now
      reconsider F=0 as Symbol of tm by A2;
      set dk=d+k;
      reconsider ik=d+k as Element of INT by INT_1:def 2;
      assume
A9:   k+1 <= m;
      then consider t1 being Tape of tm such that
A10:  (Computation s).k=[p,d+k,t1] and
A11:  for i be Integer st d <= i & i < d+k holds t1.i=0 and

A12:  for i be Integer st d > i or i >= d+k holds t1.i=t.i by A8,NAT_1:13;

      k < m by A9,NAT_1:13;
      then
A13:  dk < d+m by XREAL_1:10;
A14:  t1.ik=t.ik by A12
        .=1 by A6,A13,NAT_1:11;
      take t2=Tape-Chg(t1,dk,F);
      set sk=[p,ik,t1];
      reconsider tt=sk`3 as Tape of tm;
A15:  TRAN(sk) =(the Tran of tm).[p,tt.Head(sk)] by MCART_1:68
        .=(the Tran of tm).[p,t1.Head(sk)] by MCART_1:68
        .=[p,0,1] by A4,A14,MCART_1:68;
      then
A16:  offset TRAN(sk)=1 by MCART_1:68;

A17:  Tape-Chg(sk`3, Head(sk),(TRAN(sk))`2) =Tape-Chg(t1,Head(sk),(TRAN(
      sk))`2) by MCART_1:68

        .=Tape-Chg(t1,dk,(TRAN(sk))`2) by MCART_1:68
        .=t2 by A15,MCART_1:68;
      thus (Computation s).(k+1)=Following sk by A10,Def8
        .= [(TRAN(sk))`1, Head(sk)+ offset TRAN(sk),t2] by A5,A17,Th29
        .= [p, Head(sk)+ offset TRAN(sk),t2] by A15,MCART_1:68
        .= [p, dk+1, t2] by A16,MCART_1:68
        .= [p, d+(k+1),t2];
      hereby
        let i be Integer;
        assume that
A18:    d <= i and
A19:    i < d+(k+1);
        per cases;
        suppose
          i=dk;
          hence t2.i=0 by Th30;
        end;
        suppose
A20:      i <> dk;
          i < d+k+1 by A19;
          then i <= d+k by INT_1:20;
          then
A21:      i < dk by A20,XXREAL_0:1;
          thus t2.i=t1.i by A20,Th30
            .=0 by A11,A18,A21;
        end;
      end;
      hereby
        let i be Integer;
        assume
A22:    d > i or i >= d+(k+1);
        per cases by A22;
        suppose
A23:      d > i;
          d <= d+k by NAT_1:12;
          hence t2.i=t1.i by A23,Th30
            .=t.i by A12,A23;
        end;
        suppose
A24:      i >= d+(k+1);
          k < k+1 by NAT_1:13;
          then
A25:      d+k < d+(k+1) by XREAL_1:10;
          then
A26:      i > d+k by A24,XXREAL_0:2;
          thus t2.i=t1.i by A24,A25,Th30
            .=t.i by A12,A26;
        end;
      end;
    end;
    hence thesis;
  end;
A27: Q[0]
  proof
    assume
    0 <= m;
    take t1=t;
    thus (Computation s).0=[p,d+0,t1] by A1,A3,Def8;
    thus for i be Integer st d <= i & i < d+0 holds t1.i=0;
    thus thesis;
  end;
  for k holds Q[k] from NAT_1:sch 1(A27,A7);
  hence thesis;
end;

theorem Th42:
  for s being All-State of U3(n)Turing, t be Tape of U3(n)Turing,
head be Element of NAT, f be FinSequence of NAT st len f >= 3 & s=[0,head,t] &
t storeData <*head*>^f holds s is Accept-Halt & (Result s)`2=head+f/.1+f/.2+4 &
  (Result s)`3 storeData <*head+f/.1+f/.2+4,f/.3*>
proof
  reconsider F=0 as Symbol of U3(n)Turing by Lm12;
  let s be All-State of U3(n)Turing, t be Tape of U3(n)Turing, h be Element of
  NAT, f be FinSequence of NAT;
  assume that
A1: len f >= 3 and
A2: s=[0,h,t] and
A3: t storeData <*h*>^f;
  set n1=h+ f/.1+2, n2=h+f/.1+f/.2+4, n3=h+f/.1+f/.2+f/.3+6;
  reconsider s03=s`3 as Tape of U3(n)Turing;
A4: t is_1_between h,n1 by A1,A3,Th26;
  then
A5: t.h=0 by Def13;
A6: TRAN(s) =U3(n)Tran.[s`1, s03.Head(s)] by Def22
    .=U3(n)Tran.[0,s03.Head(s)] by A2,MCART_1:68
    .=U3(n)Tran.[0,t.Head(s)] by A2,MCART_1:68
    .=[1,0,1] by A2,A5,Th41,MCART_1:68;
  then
A7: offset TRAN(s)=1 by MCART_1:68;
  reconsider p1=1 as State of U3(n)Turing by Lm11;
  set m1=f/.1+1;
  reconsider h1=h+1 as Element of INT by INT_1:def 2;
  set s1= [p1,h1,t];
A8: t is_1_between n1,n2 by A1,A3,Th26;
  then
A9: t.n2=0 by Def13;
  Tape-Chg(s`3, Head(s),(TRAN(s))`2)=Tape-Chg(t, Head(s),(TRAN(s))`2) by A2,
MCART_1:68
    .=Tape-Chg(t,h,(TRAN(s))`2) by A2,MCART_1:68
    .=Tape-Chg(t,h,F) by A6,MCART_1:68
    .=t by A5,Th28;
  then
A10: Following s = [(TRAN(s))`1, Head(s)+offset TRAN(s),t] by A2,Lm13
    .= [1, Head(s)+ offset TRAN(s),t] by A6,MCART_1:68
    .= s1 by A2,A7,MCART_1:68;
A11: t is_1_between n2,n3 by A1,A3,Th26;
  then
A12: t.n3=0 by Def13;
  reconsider p2=2 as State of U3(n)Turing by Lm11;
  set s2=(Computation s1).m1;
  reconsider s23=s2`3 as Tape of U3(n)Turing;
  set j1=h+1+m1+1;
  reconsider k1=j1 as Element of INT by INT_1:def 2;
  set m2=f/.2+1;
  set Rs=(Computation s).(m2+1+1+m1+1);
  set m3=n2+f/.3+2;
A13: now
    let i be Integer;
    assume that
A14: h+1 <= i and
A15: i < h+1+m1;
    h < h+1 by XREAL_1:31;
    then h < i by A14,XXREAL_0:2;
    hence t.i=1 by A4,A15,Def13;
  end;
  (the Tran of U3(n)Turing).[p1,1] =[p1,0,1] & p1 <> the AcceptS of
  U3(n)Turing by Def22,Th41;
  then consider t1 being Tape of U3(n)Turing such that
A16: s2=[p1,h+1+m1,t1] and
  for i be Integer st h+1 <= i & i < h+1+m1 holds t1.i=0 and
A17: for i be Integer st h+1 > i or i >= h+1+m1 holds t1.i=t.i by A13,Lm12,Lm14
;
  t.n1=0 by A4,Def13;
  then
A18: t1.(h+1+m1)=0 by A17;
A19: TRAN(s2) =U3(n)Tran.[s2`1, s23.Head(s2)] by Def22
    .=U3(n)Tran.[p1,s23.Head(s2)] by A16,MCART_1:68
    .=U3(n)Tran.[1,t1.Head(s2)] by A16,MCART_1:68
    .=[2,0,1] by A16,A18,Th41,MCART_1:68;
  then
A20: offset TRAN(s2)=1 by MCART_1:68;
  set s3= [p2,k1,t1];
  Tape-Chg(s2`3, Head(s2),(TRAN(s2))`2) =Tape-Chg(t1, Head(s2),(TRAN(s2))
  `2) by A16,MCART_1:68
    .=Tape-Chg(t1,h+1+m1,(TRAN(s2))`2) by A16,MCART_1:68
    .=Tape-Chg(t1,h+1+m1,F) by A19,MCART_1:68
    .=t1 by A18,Th28;
  then
A21: Following s2 = [(TRAN(s2))`1, Head(s2)+offset TRAN(s2),t1] by A16,Lm13
    .= [2, Head(s2)+ offset TRAN(s2),t1] by A19,MCART_1:68
    .= s3 by A16,A20,MCART_1:68;
A22: now
    let i be Integer;
    assume that
A23: j1 <= i and
A24: i < j1+m2;
    h+1+m1 < j1 by XREAL_1:31;
    then
A25: h+1+m1 < i by A23,XXREAL_0:2;
    hence t1.i=t.i by A17
      .=1 by A8,A24,A25,Def13;
  end;
  set s4=(Computation s3).m2;
  reconsider s43=s4`3 as Tape of U3(n)Turing;
  (the Tran of U3(n)Turing).[p2,1] =[p2,0,1] & p2 <> the AcceptS of
  U3(n)Turing by Def22,Th41;
  then consider t2 being Tape of U3(n)Turing such that
A26: s4=[p2,j1+m2,t2] and
  for i be Integer st j1 <= i & i < j1 + m2 holds t2.i=0 and
A27: for i be Integer st j1 > i or i >= j1 + m2 holds t2.i=t1.i by A22,Lm12
,Lm14;
  2 <= f/.2+4 by NAT_1:12;
  then
A28: n1 <= h+f/.1+(f/.2+4) by XREAL_1:9;
A29: now
    let k be Integer;
    assume that
A30: n2 < k and
A31: k < m3;
A32: n1 <= k by A28,A30,XXREAL_0:2;
    thus t2.k=t1.k by A27,A30
      .=t.k by A17,A32
      .=1 by A11,A30,A31,Def13;
  end;
A33: t2.(j1+m2)=t1.(j1+m2) by A27
    .=0 by A9,A17,A28;
A34: TRAN(s4) =U3(n)Tran.[s4`1, s43.Head(s4)] by Def22
    .=U3(n)Tran.[p2,s43.Head(s4)] by A26,MCART_1:68
    .=U3(n)Tran.[2,t2.Head(s4)] by A26,MCART_1:68
    .=[3,0,0] by A26,A33,Th41,MCART_1:68;
  then
A35: offset TRAN(s4)=0 by MCART_1:68;
  Tape-Chg(s4`3, Head(s4),(TRAN(s4))`2) =Tape-Chg(t2, Head(s4),(TRAN(s4))
  `2) by A26,MCART_1:68
    .=Tape-Chg(t2,j1+m2,(TRAN(s4))`2) by A26,MCART_1:68
    .=Tape-Chg(t2,j1+m2,F) by A34,MCART_1:68
    .=t2 by A33,Th28;
  then
A36: Following s4 = [(TRAN(s4))`1, Head(s4)+offset TRAN(s4),t2] by A26,Lm13
    .= [3, Head(s4)+ offset TRAN(s4),t2] by A34,MCART_1:68
    .= [3, j1+m2+0,t2] by A26,A35,MCART_1:68;
  Rs=(Computation (Computation s).1).(m2+1+1+m1) by Th13
    .=(Computation s1).(m2+1+1+m1) by A10,Th12
    .=(Computation s2).(m2+1+1) by Th13;
  then
A37: Rs=(Computation (Computation s2).1).(m2+1)by Th13
    .=(Computation s3).(m2+1) by A21,Th12
    .=[3, j1+m2,t2] by A36,Def8;
  then
A38: Rs`1 = 3 by MCART_1:68
    .=the AcceptS of U3(n)Turing by Def22;
  hence s is Accept-Halt by Def9;
  then
A39: Result s =Rs by A38,Def10;
  hence (Result s)`2=n2 by A37,MCART_1:68;
A40: (Result s)`3= t2 by A37,A39,MCART_1:68;
A41: n2 <= n2+(f/.3+2) by NAT_1:11;
  then
A42: n1 <= m3 by A28,XXREAL_0:2;
  t2.m3=t1.m3 by A27,A41
    .=0 by A12,A17,A42;
  then t2 is_1_between n2,n2+f/.3+2 by A33,A29,Def13;
  hence thesis by A40,Th19;
end;

theorem
  n >= 3 implies U3(n)Turing computes n proj 3
proof
  assume
A1: n >= 3;
  now
    set pj=n proj 3;
    let s be All-State of U3(n)Turing,t be Tape of U3(n)Turing, h be Element
    of NAT, x be FinSequence of NAT;
    assume that
A2: x in dom pj and
A3: s=[the InitS of U3(n)Turing,h,t] and
A4: t storeData <*h*>^x;
    arity pj = n by COMPUT_1:41;
    then
A5: dom pj c= n-tuples_on NAT by COMPUT_1:24;
    then x in n-tuples_on NAT by A2;
    then x in { f where f is Element of NAT*: len f = n } by FINSEQ_2:def 4;
    then
A6: ex f be Element of NAT* st x = f & len f = n;
A7: s = [0,h,t] by A3,Def22;
    hence s is Accept-Halt by A1,A4,A6,Th42;
    take h2=h+x/.1+x/.2+4;
    take y=x/.3;
    thus (Result s)`2=h2 by A1,A4,A6,A7,Th42;
    thus y=x.3 by A1,A6,FINSEQ_4:24
      .=pj.x by A2,A5,COMPUT_1:42;
    (Result s)`3 storeData <*h2,y*> by A1,A4,A6,A7,Th42;
    hence (Result s)`3 storeData <*h2*>^<*y*> by FINSEQ_1:def 9;
  end;
  hence thesis by Def16;
end;

begin :: Combining two Turing Machines into one Turing Machine

definition
  let t1,t2 be TuringStr;
  func UnionSt(t1,t2) -> finite non empty set equals
  [: the FStates of t1, {the
  InitS of t2} :] \/ [: {the AcceptS of t1}, the FStates of t2 :];
  correctness;
end;

theorem Th44:
  for t1,t2 being TuringStr holds [ the InitS of t1, the InitS of
t2 ] in UnionSt(t1,t2) & [ the AcceptS of t1,the AcceptS of t2 ] in UnionSt(t1,
  t2)
proof
  let t1,t2 be TuringStr;
  set p0=the InitS of t1, q0=the InitS of t2, p1=the AcceptS of t1, q1=the
AcceptS of t2, A= [: the FStates of t1, { q0 } :], 
   B= [: {p1}, the FStates 
of t2
  :];
  reconsider q=q0 as Element of { q0 } by TARSKI:def 1;
  reconsider p=p1 as Element of { p1 } by TARSKI:def 1;
  [ p0, q ] in A;
  hence [ p0, q0 ] in UnionSt(t1,t2) by XBOOLE_0:def 3;
  [ p, q1 ] in B;
  hence thesis by XBOOLE_0:def 3;
end;

theorem Th45:
  for s,t being TuringStr, x be State of s holds [ x, the InitS of
  t ] in UnionSt(s,t)
proof
  let s,t be TuringStr,x be State of s;
  set q0=the InitS of t, A= [: the FStates of s, { q0 } :];
  reconsider q=q0 as Element of { q0 } by TARSKI:def 1;
  [ x, q ] in A;
  hence thesis by XBOOLE_0:def 3;
end;

theorem Th46:
  for s,t being TuringStr, x be State of t holds [ the AcceptS of
  s, x] in UnionSt(s,t)
proof
  let s,t be TuringStr,x be State of t;
  set p1=the AcceptS of s, B= [:{p1},the FStates of t :];
  reconsider p=p1 as Element of { p1 } by TARSKI:def 1;
  [ p, x] in B;
  hence thesis by XBOOLE_0:def 3;
end;

theorem Th47:
  for s,t being TuringStr, x be Element of UnionSt(s,t) holds ex
  x1 be State of s, x2 be State of t st x=[x1, x2]
proof
  let s,t be TuringStr,x be Element of UnionSt(s,t);
  set q0=the InitS of t, p1=the AcceptS of s, 
  A= [: the FStates of s, { q0 } :]
  , B= [: { p1 }, the FStates of t :];
  per cases by XBOOLE_0:def 3;
  suppose
    x in A;
    then consider x1 being State of s, x2 be Element of { q0 } such that
A1: x= [x1, x2] by DOMAIN_1:9;
    take x1,q0;
    thus thesis by A1,TARSKI:def 1;
  end;
  suppose
    x in B;
    then consider x1 being Element of { p1 }, x2 being State of t such that
A2: x= [x1, x2] by DOMAIN_1:9;
    take p1,x2;
    thus thesis by A2,TARSKI:def 1;
  end;
end;

definition
  let s,t be TuringStr, x be Tran-Goal of s;
  func FirstTuringTran(s,t,x) -> Element of [: UnionSt(s,t),(the Symbols of s)
  \/ the Symbols of t,{-1,0,1} :] equals
  [[x`1,the InitS of t], x`2, x`3];
  coherence
  proof
    reconsider y1=[x`1,the InitS of t] as Element of UnionSt(s,t) by Th45;
    set Sym=(the Symbols of s) \/ the Symbols of t;
    reconsider y2=x`2 as Element of Sym by XBOOLE_0:def 3;
    [y1, y2, x`3] in [: UnionSt(s,t),Sym,{-1,0,1} :];
    hence thesis;
  end;
end;

definition
  let s,t be TuringStr, x be Tran-Goal of t;
  func SecondTuringTran(s,t,x) -> Element of [: UnionSt(s,t),(the Symbols of s
  ) \/ the Symbols of t,{-1,0,1} :] equals
  [[the AcceptS of s,x`1], x`2, x`3];
  coherence
  proof
    reconsider y1=[the AcceptS of s,x`1] as Element of UnionSt(s,t) by Th46;
    set Sym=(the Symbols of s) \/ the Symbols of t;
    reconsider y2=x`2 as Element of Sym by XBOOLE_0:def 3;
    [y1, y2, x`3] in [: UnionSt(s,t),Sym,{-1,0,1} :];
    hence thesis;
  end;
end;

definition
  let s,t be TuringStr;
  let x be Element of UnionSt(s,t);
  redefine func x`1 -> State of s;
  coherence
  proof
    ex x1 being State of s, x2 be State of t st x=[x1, x2] by Th47;
    hence thesis by MCART_1:def 1;
  end;
  func x`2 -> State of t;
  coherence
  proof
    ex x1 being State of s, x2 be State of t st x=[x1, x2] by Th47;
    hence thesis by MCART_1:def 2;
  end;
end;

definition
  let s,t be TuringStr, x be Element of [: UnionSt(s,t), (the Symbols of s) \/
  the Symbols of t :];
  func FirstTuringState x -> State of s equals
  x`1`1;
  correctness;
  func SecondTuringState x -> State of t equals
  x`1`2;
  correctness;
end;

definition
  let X,Y,Z be non empty set, x be Element of [: X, Y \/ Z :];
  given u being set,y be Element of Y such that
A1: x = [u,y];
  func FirstTuringSymbol(x) -> Element of Y equals
  :Def28:
  x`2;
  coherence by A1,MCART_1:def 2;
end;

definition
  let X,Y,Z be non empty set, x be Element of [: X, Y \/ Z :];
  given u being set,z be Element of Z such that
A1: x = [u, z];
  func SecondTuringSymbol(x) -> Element of Z equals
  :Def29:
  x`2;
  coherence by A1,MCART_1:def 2;
end;

definition
  let s,t be TuringStr, x be Element of [: UnionSt(s,t), (the Symbols of s) \/
  the Symbols of t :];
  func Uniontran(s,t,x) -> Element of [: UnionSt(s,t), (the Symbols of s) \/
  the Symbols of t,{-1,0,1} :] equals
  :Def30:
  FirstTuringTran(s,t,(the Tran of s)
  .[FirstTuringState x, FirstTuringSymbol(x)]) if ex p being State of s,y be
  Symbol of s st x = [ [p,the InitS of t],y] & p <> the AcceptS of s,
SecondTuringTran(s,t,(the Tran of t). [SecondTuringState x,SecondTuringSymbol(x
)]) if ex q being State of t, y be Symbol of t st x = [ [the AcceptS of s,q],y]
  otherwise [x`1,x`2,-1];
  consistency
  proof
    let w be Element of [: UnionSt(s,t), (the Symbols of s) \/ the Symbols of
    t,{-1,0,1} :];
    thus (ex p be State of s,y be Symbol of s st x = [ [p,the InitS of t],y] &
p <> the AcceptS of s) & (ex q being State of t, y be Symbol of t st x = [ [the
    AcceptS of s,q],y] ) implies ( w=FirstTuringTran(s,t,(the Tran of s). [
FirstTuringState x,FirstTuringSymbol(x)]) iff w=SecondTuringTran(s,t,(the Tran
    of t). [SecondTuringState x,SecondTuringSymbol(x)]))
    proof
      given p be State of s,y be Symbol of s such that
A1:   x = [ [p,the InitS of t],y] and
A2:   p <> the AcceptS of s;
      given q be State of t, z be Symbol of t such that
A3:   x = [ [the AcceptS of s,q],z];
      [p,the InitS of t]=[the AcceptS of s,q] by A1,A3,ZFMISC_1:33;
      hence thesis by A2,ZFMISC_1:33;
    end;
  end;
  coherence
  proof
    reconsider l=-1 as Element of { -1,0,1 } by ENUMSET1:def 1;
    [x`1,x`2,l] in [: UnionSt(s,t), (the Symbols of s) \/ the Symbols of t
    ,{-1,0,1} :];
    hence thesis;
  end;
end;

definition
  let s,t be TuringStr;
  func UnionTran(s,t) -> Function of [: UnionSt(s,t), (the Symbols of s) \/
the Symbols of t :], [: UnionSt(s,t), (the Symbols of s) \/ the Symbols of t,{-
  1,0,1} :] means
  :Def31:
  for x being Element of [: UnionSt(s,t), (the Symbols of
  s) \/ the Symbols of t :] holds it.x = Uniontran(s,t,x);
  existence
  proof
    set Sm=(the Symbols of s) \/ the Symbols of t, X=[: UnionSt(s,t),Sm :];
    deffunc U(Element of X) = Uniontran(s,t,$1);
    consider f being Function of X, [: UnionSt(s,t),Sm,{-1,0,1} :] such that
A1: for x being Element of X holds f.x = U(x) from FUNCT_2:sch 4;
    take f;
    thus thesis by A1;
  end;
  uniqueness
  proof
    set Sm=(the Symbols of s) \/ the Symbols of t, X=[: UnionSt(s,t), Sm :];
    let f,g be Function of X,[: UnionSt(s,t),Sm,{-1,0,1} :] such that
A2: for x being Element of X holds f.x = Uniontran(s,t,x) and
A3: for x being Element of X holds g.x = Uniontran(s,t,x);
    now
      let x be Element of X;
      thus f.x =Uniontran(s,t,x) by A2
        .=g.x by A3;
    end;
    hence thesis by FUNCT_2:113;
  end;
end;

definition
  let T1,T2 be TuringStr;
  func T1 ';' T2 -> strict TuringStr means
  :Def32:
  the Symbols of it = (the
  Symbols of T1) \/ the Symbols of T2 & 
  the FStates of it = UnionSt(T1,T2) & the
Tran of it = UnionTran(T1,T2) & the InitS of it = [the InitS of T1,the InitS of
  T2] & the AcceptS of it = [the AcceptS of T1,the AcceptS of T2];
  existence
  proof
    set St =UnionSt(T1,T2);
    reconsider q1=[the AcceptS of T1,the AcceptS of T2] as Element of St by
Th44;
    reconsider p0=[the InitS of T1,the InitS of T2] as Element of St by Th44;
    set Sym=(the Symbols of T1) \/ the Symbols of T2;
    take TuringStr(# Sym,St, UnionTran(T1,T2), p0, q1 #);
    thus thesis;
  end;
  uniqueness;
end;

theorem Th48:
  for T1,T2 being TuringStr, g be Tran-Goal of T1,p be State of T1
  , y be Symbol of T1 st p <> the AcceptS of T1 & g = (the Tran of T1).[p, y]
holds (the Tran of T1 ';' T2).[ [p,the InitS of T2],y] = [[g`1,the InitS of T2]
  , g`2, g`3]
proof
  let t1,t2 be TuringStr, g be Tran-Goal of t1,p be State of t1, y be Symbol
  of t1;
  assume that
A1: p <> the AcceptS of t1 and
A2: g = (the Tran of t1).[p, y];
  set q0=the InitS of t2;
  set x=[[p,q0],y];
  q0 in { q0 } by TARSKI:def 1;
  then [p,q0] in [: the FStates of t1, {q0} :] by ZFMISC_1:def 2;
  then
A3: [p,q0] in [: the FStates of t1, {q0} :] \/ [: {the AcceptS of t1}, the
  FStates of t2 :] by XBOOLE_0:def 3;
  y in (the Symbols of t1) \/ the Symbols of t2 by XBOOLE_0:def 3;
  then reconsider
  xx=x as Element of [: UnionSt(t1,t2), (the Symbols of t1) \/ the
  Symbols of t2 :] by A3,ZFMISC_1:def 2;
A4: FirstTuringState xx =[p,q0]`1 by MCART_1:def 1
    .=p by MCART_1:def 1;
A5: FirstTuringSymbol(xx)=xx`2 by Def28
    .=y by MCART_1:def 2;
  thus (the Tran of t1 ';' t2).x = UnionTran(t1,t2).xx by Def32
    .=Uniontran(t1,t2,xx) by Def31
    .=FirstTuringTran(t1,t2,(the Tran of t1).[p,y]) by A1,A4,A5,Def30
    .=[[g`1,q0], g`2, g`3] by A2;
end;

theorem Th49:
  for T1,T2 being TuringStr, g be Tran-Goal of T2, q be State of
T2, y be Symbol of T2 st g = (the Tran of T2).[q, y] holds (the Tran of T1 ';'
  T2).[ [the AcceptS of T1,q],y] = [[the AcceptS of T1,g`1], g`2, g`3]
proof
  let t1,t2 be TuringStr, g be Tran-Goal of t2,q be State of t2, y be Symbol
  of t2;
  assume
A1: g = (the Tran of t2).[q, y];
  set pF=the AcceptS of t1;
  set x=[[pF,q],y];
  pF in { pF } by TARSKI:def 1;
  then [pF,q] in [: {pF}, the FStates of t2 :] by ZFMISC_1:def 2;
  then
A2: [pF,q] in [: the FStates of t1, {the InitS of t2} :] \/ [: {pF}, the
  FStates of t2 :] by XBOOLE_0:def 3;
  y in (the Symbols of t1) \/ the Symbols of t2 by XBOOLE_0:def 3;
  then reconsider
  xx=x as Element of [: UnionSt(t1,t2), (the Symbols of t1) \/ the
  Symbols of t2 :] by A2,ZFMISC_1:def 2;
A3: SecondTuringState xx =[pF,q]`2 by MCART_1:def 1
    .=q by MCART_1:def 2;
A4: SecondTuringSymbol(xx)=xx`2 by Def29
    .=y by MCART_1:def 2;
  thus (the Tran of t1 ';' t2).x = UnionTran(t1,t2).xx by Def32
    .=Uniontran(t1,t2,xx) by Def31
    .=SecondTuringTran(t1,t2,(the Tran of t2).[q,y]) by A3,A4,Def30
    .=[[pF,g`1], g`2, g`3] by A1;
end;

theorem Th50:
  for T1,T2 being TuringStr,s1 be All-State of T1,h be Element of
  NAT, t be Tape of T1, s2 be All-State of T2,s3 be All-State of (T1 ';' T2) st
  s1 is Accept-Halt & s1=[the InitS of T1,h,t] & s2 is Accept-Halt & s2=[the
  InitS of T2,(Result s1)`2,(Result s1)`3] & s3=[the InitS of (T1 ';' T2),h,t]
  holds s3 is Accept-Halt & (Result s3)`2=(Result s2)`2 & (Result s3)`3=(Result
  s2)`3
proof
  let tm1,tm2 be TuringStr,s1 be All-State of tm1,h be Element of NAT, t be
  Tape of tm1, s2 be All-State of tm2, s3 be All-State of (tm1 ';' tm2);
  set p0=the InitS of tm1, q0=the InitS of tm2;
  assume that
A1: s1 is Accept-Halt and
A2: s1=[p0,h,t] and
A3: s2 is Accept-Halt and
A4: s2=[q0,(Result s1)`2,(Result s1)`3] and
A5: s3=[the InitS of (tm1 ';' tm2),h,t];
  set pF=the AcceptS of tm1, qF=the AcceptS of tm2;
  consider k such that
A6: ((Computation s1).k)`1 = pF and
A7: Result s1 = (Computation s1).k and
A8: for i be Element of NAT st i < k holds ((Computation s1).i)`1 <> pF
  by A1,Th16;
  defpred P[Element of NAT] means $1 <= k implies [((Computation s1).$1)`1,q0]
=((Computation s3).$1)`1 & ((Computation s1).$1)`2=((Computation s3).$1)`2 & ((
  Computation s1).$1)`3=((Computation s3).$1)`3;
A9: for i st P[i] holds P[i + 1]
  proof
    let i;
    assume
A10: P[i];
    now
      set s1i1=(Computation s1).(i+1), s1i=(Computation s1).i, s3i1=(
      Computation s3).(i+1), s3i=(Computation s3).i;
A11:  i < i+1 by XREAL_1:31;
      set f=TRAN(s3i);
      reconsider h=Head(s1i) as Element of INT;
      reconsider ss1=s1i`3 as Tape of tm1;
      reconsider y=ss1.h as Symbol of tm1;
      reconsider ss3=s3i`3 as Tape of tm1 ';' tm2;
      set p=s1i`1, g=TRAN(s1i);
      assume
A12:  i+1 <= k;
      then
A13:  i < k by A11,XXREAL_0:2;
      then
A14:  p <> pF by A8;
A15:  s3i`1 <> the AcceptS of tm1 ';' tm2
      proof
        assume
        s3i`1 = the AcceptS of tm1 ';' tm2;
        then [p,q0] = [pF,qF] by A10,A12,A11,Def32,XXREAL_0:2;
        hence contradiction by A14,ZFMISC_1:33;
      end;
A16:  f= (the Tran of tm1 ';' tm2).[[p,q0],y] by A10,A12,A11,XXREAL_0:2
        .= [[g`1,q0], g`2, g`3] by A8,A13,Th48;
      then
A17:  g`2=f`2 by MCART_1:def 6;
A18:  s3i1=Following s3i by Def8
        .= [f`1, Head(s3i)+ offset (f),Tape-Chg(ss3,Head(s3i),f`2)] by A15,Def7
;
A19:  s1i1=Following s1i by Def8
        .= [g`1, h+ offset(g),Tape-Chg(ss1,h,g`2)] by A14,Def7;
      hence [s1i1`1,q0]=[g`1,q0] by MCART_1:def 5
        .=f`1 by A16,MCART_1:def 5
        .=s3i1`1 by A18,MCART_1:def 5;
      offset g=offset f by A16,MCART_1:def 7;
      hence s1i1`2= Head(s3i) + offset f by A10,A12,A11,A19,MCART_1:def 6
,XXREAL_0:2
        .= s3i1`2 by A18,MCART_1:def 6;
      thus s1i1`3= ss3 +* (h .--> (g`2)) by A10,A12,A11,A19,MCART_1:def 7
,XXREAL_0:2
        .= s3i1`3 by A10,A12,A11,A17,A18,MCART_1:def 7,XXREAL_0:2;
    end;
    hence thesis;
  end;
  set s1k=(Computation s1).k, s3k=(Computation s3).k;
A20: s3=[[p0,q0],h,t] by A5,Def32;
A21: P[0]
  proof
    assume
    0 <= k;
A22: ((Computation s3).0)`1=s3`1 by Def8
      .=[p0,q0] by A20,MCART_1:68;
    ((Computation s1).0)`1=s1`1 by Def8
      .=p0 by A2,MCART_1:68;
    hence [((Computation s1).0)`1,q0]=((Computation s3).0)`1 by A22;
    thus ((Computation s1).0)`2=s1`2 by Def8
      .=h by A2,MCART_1:68
      .=s3`2 by A5,MCART_1:68
      .=((Computation s3).0)`2 by Def8;
    thus ((Computation s1).0)`3=s1`3 by Def8
      .=t by A2,MCART_1:68
      .=s3`3 by A5,MCART_1:68
      .=((Computation s3).0)`3 by Def8;
  end;
A23: for i holds P[i] from NAT_1:sch 1(A21,A9);
  then
A24: s1k`2=s3k`2;
  consider m be Element of NAT such that
A25: ((Computation s2).m)`1 = qF and
A26: Result s2 = (Computation s2).m and
A27: for i be Element of NAT st i < m holds ((Computation s2).i)`1 <> qF
  by A3,Th16;
  defpred Q[Element of NAT] means $1 <= m implies [pF,((Computation s2).$1)`1]
=((Computation s3k).$1)`1 & ((Computation s2).$1)`2=((Computation s3k).$1)`2 &
  ((Computation s2).$1)`3=((Computation s3k).$1)`3;
A28: for i st Q[i] holds Q[i + 1]
  proof
    let i;
    assume
A29: Q[i];
    now
      set s2i1=(Computation s2).(i+1), s2i=(Computation s2).i, ski1=(
      Computation s3k).(i+1), ski=(Computation s3k).i;
A30:  i < i+1 by XREAL_1:31;
      reconsider ssk=ski`3 as Tape of tm1 ';' tm2;
      set f=TRAN(ski);
      set q=s2i`1, g=TRAN(s2i);
      reconsider h=Head(s2i) as Element of INT;
      reconsider ss2=s2i`3 as Tape of tm2;
      reconsider y=ss2.h as Symbol of tm2;
      assume
A31:  i+1 <= m;
      then
A32:  f= (the Tran of tm1 ';' tm2).[[pF,q],y] by A29,A30,XXREAL_0:2
        .= [[pF,g`1], g`2, g`3] by Th49;
      then
A33:  g`2=f`2 by MCART_1:def 6;
      i < m by A31,A30,XXREAL_0:2;
      then
A34:  q <> qF by A27;
A35:  ski`1 <> the AcceptS of tm1 ';' tm2
      proof
        assume
        ski`1 = the AcceptS of tm1 ';' tm2;
        then [pF,q] = [pF,qF] by A29,A31,A30,Def32,XXREAL_0:2;
        hence contradiction by A34,ZFMISC_1:33;
      end;
A36:  ski1=Following ski by Def8
        .= [f`1, Head(ski)+ offset (f),Tape-Chg(ssk,Head(ski),f`2)] by A35,Def7
;
A37:  s2i1=Following s2i by Def8
        .= [g`1, h+ offset(g),Tape-Chg(ss2,h,g`2)] by A34,Def7;
      hence [pF,s2i1`1]=[pF,g`1] by MCART_1:def 5
        .=f`1 by A32,MCART_1:def 5
        .=ski1`1 by A36,MCART_1:def 5;
      offset g=offset f by A32,MCART_1:def 7;
      hence s2i1`2= Head(ski) + offset f by A29,A31,A30,A37,MCART_1:def 6
,XXREAL_0:2
        .= ski1`2 by A36,MCART_1:def 6;
      thus s2i1`3= ssk +* (h .--> (g`2)) by A29,A31,A30,A37,MCART_1:def 7
,XXREAL_0:2
        .= ski1`3 by A29,A31,A30,A33,A36,MCART_1:def 7,XXREAL_0:2;
    end;
    hence thesis;
  end;
A38: s1k`3=s3k`3 by A23;
  set s2m=(Computation s2).m, skm=(Computation s3k).m;
A39: (Computation s3).(k+m)=skm by Th13;
A40: [s1k`1,q0]=s3k`1 by A23;
A41: Q[0]
  proof
    assume
    0 <= m;
    thus [pF,((Computation s2).0)`1]=[pF,s2`1] by Def8
      .=[pF,q0] by A4,MCART_1:68
      .=((Computation s3k).0)`1 by A6,A40,Def8;
    thus ((Computation s2).0)`2=s2`2 by Def8
      .=s3k`2 by A4,A7,A24,MCART_1:68
      .=((Computation s3k).0)`2 by Def8;
    thus ((Computation s2).0)`3=s2`3 by Def8
      .=s3k`3 by A4,A7,A38,MCART_1:68
      .=((Computation s3k).0)`3 by Def8;
  end;
A42: for i holds Q[i] from NAT_1:sch 1(A41,A28);
  then [pF,s2m`1]=skm`1;
  then
A43: ((Computation s3).(k+m))`1=the AcceptS of tm1 ';' tm2 by A25,A39,Def32;
  hence
A44: s3 is Accept-Halt by Def9;
  s2m`2=skm`2 & s2m`3=skm`3 by A42;
  hence thesis by A26,A39,A43,A44,Def10;
end;

theorem
  for tm1,tm2 being TuringStr,t be Tape of tm1 st the Symbols of tm1 =
  the Symbols of tm2 holds t is Tape of tm1 ';' tm2
proof
  let tm1,tm2 be TuringStr,t be Tape of tm1;
  set S1=the Symbols of tm1, S2=the Symbols of tm2;
  assume
A1: S1=S2;
  the Symbols of tm1 ';' tm2=S1 \/ S2 by Def32
    .=S1 by A1;
  hence thesis;
end;

theorem
  for tm1,tm2 being TuringStr,t be Tape of tm1 ';' tm2 st the Symbols of
  tm1 = the Symbols of tm2 holds t is Tape of tm1 & t is Tape of tm2
proof
  let tm1,tm2 be TuringStr,t be Tape of tm1 ';' tm2;
  set S1=the Symbols of tm1, S2=the Symbols of tm2;
  assume
A1: S1=S2;
  the Symbols of tm1 ';' tm2=S1 \/ S2 by Def32
    .=S1 by A1;
  hence thesis by A1;
end;

theorem Th53:
  for f being FinSequence of NAT,tm1,tm2 be TuringStr,t1 be Tape
  of tm1, t2 be Tape of tm2 st t1=t2 & t1 storeData f holds t2 storeData f
proof
  let f be FinSequence of NAT,tm1,tm2 be TuringStr,t1 be Tape of tm1, t2 be
  Tape of tm2;
  assume that
A1: t1=t2 and
A2: t1 storeData f;
  now
    let i be Element of NAT;
    set m=Sum Prefix(f,i)+2*(i-1), n=Sum Prefix(f,i+1)+2*i;
    assume
    1 <= i & i < len f;
    then
A3: t1 is_1_between m,n by A2,Def14;
    then
A4: for k be Integer st m < k & k < n holds t1.k=1 by Def13;
    t1.m=0 & t1.n=0 by A3,Def13;
    hence t2 is_1_between m,n by A1,A4,Def13;
  end;
  hence thesis by Def14;
end;

Lm15: for s being All-State of ZeroTuring, t be Tape of ZeroTuring, head, n be
Element of NAT st s=[0,head,t] & t storeData <*head,n*> holds s is Accept-Halt
& (Result s)`2=head & (Result s)`3 storeData <*head,0*>

proof

  let s be All-State of ZeroTuring, t be Tape of ZeroTuring, h,n be Element of
  NAT;

  assume that
A1: s=[0,h,t] and
A2: t storeData <*h,n*>;
  set f=<*n*>;
A3: len f =1 by FINSEQ_1:56;
  t storeData <*h*>^f by A2,FINSEQ_1:def 9;
  hence thesis by A1,A3,Th39;
end;

theorem
  for s being All-State of ZeroTuring ';' SuccTuring, t be Tape of
ZeroTuring , head,n be Element of NAT st s=[[0,0],head,t] & t storeData <*head,
n*> holds s is Accept-Halt & (Result s)`2=head & (Result s)`3 storeData <*head,
  1*>
proof
  let s be All-State of ZeroTuring ';' SuccTuring, t be Tape of ZeroTuring, h,
  n be Element of NAT;
  assume that
A1: s=[[0,0],h,t] and
A2: t storeData <*h,n*>;
  reconsider h1=h as Element of INT by INT_1:def 2;
  set s1=[the InitS of ZeroTuring,h1,t];
A3: 0=the InitS of ZeroTuring by Def20;
  then
A4: s1 is Accept-Halt & (Result s1)`2=h by A2,Lm15;
  the Symbols of ZeroTuring={0,1} by Def20
    .=the Symbols of SuccTuring by Def18;
  then reconsider t2=(Result s1)`3 as Tape of SuccTuring;
  set s2=[the InitS of SuccTuring,h1,t2];
A5: 0=the InitS of SuccTuring by Def18;
  then
A6: s=[the InitS of ZeroTuring ';' SuccTuring,h,t] by A1,A3,Def32;
  (Result s1)`3 storeData <*h,0 *> by A2,A3,Lm15;
  then
A7: t2 storeData <*h,0*> by Th53;
  then
A8: (Result s2)`3 storeData <*h,0+ 1 *> by A5,Th36;
A9: s2 is Accept-Halt by A7,A5,Th36;
  hence s is Accept-Halt by A4,A6,Th50;
  (Result s2)`2=h by A7,A5,Th36;
  hence (Result s)`2=h by A4,A9,A6,Th50;
  (Result s)`3=(Result s2)`3 by A4,A9,A6,Th50;
  hence thesis by A8,Th53;
end;

