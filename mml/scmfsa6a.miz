:: On the compositions of macro instructions
::  by Andrzej Trybulec , Yatsuka Nakamura and Noriko Asamoto
::
:: Received June 20, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMFSA_2, SCMNORM, FUNCT_4, AMI_3,
      FUNCOP_1, RELAT_1, FUNCT_1, TARSKI, XBOOLE_0, CARD_1, CAT_1, NAT_1,
      ARYTM_3, FINSET_1, STRUCT_0, XXREAL_0, AMISTD_2, VALUED_1, FSM_1,
      GRAPHSP, FUNCT_7, ARYTM_1, INT_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2,
      TURING_1, SCMFSA6A, ORDINAL1, RELOC, SCMFSA6C;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, COMPLEX1,
      NAT_1, INT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FINSEQ_1, FINSEQ_2,
      FUNCOP_1, FINSET_1, FUNCT_4, DOMAIN_1, VALUED_1, AFINSQ_1, STRUCT_0,
      COMPOS_1, EXTPRO_1, AMI_1, FUNCT_7, SCMFSA_2, AMISTD_2, XXREAL_0;
 constructors WELLORD2, DOMAIN_1, XXREAL_0, INT_2, AMISTD_2, SCMFSA_2,
      RELSET_1, VALUED_1, AMI_3, AMI_1, PRE_POLY, AMISTD_1;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1,
      FINSET_1, NUMBERS, XREAL_0, INT_1, STRUCT_0, AMI_1, SCMFSA_2,
      FUNCT_4, RELAT_1, VALUED_1, SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCT_1, FUNCOP_1, SCMFSA_2, FUNCT_7, XBOOLE_0, TARSKI,
      COMPOS_1, EXTPRO_1, AMI_1, FUNCT_4,
      AFINSQ_1, AMISTD_2;
 theorems FUNCT_2, RELAT_1, FUNCT_7, FUNCT_4, FUNCT_1, ZFMISC_1, FUNCOP_1,
      TARSKI, NAT_1, SCMFSA_4, SCMFSA_2, CARD_1, CARD_2,
      ENUMSET1, INT_1, GRFUNC_1, FINSEQ_1, RELSET_1, XBOOLE_0,
      XBOOLE_1, XREAL_1, ORDINAL1, AMI_3, VALUED_1, PARTFUN1, AFINSQ_1,
      SCMFSA10, COMPOS_1, EXTPRO_1;
 schemes CLASSES1;

begin

reserve l, m, n for Element of NAT,
  i,j,k for Instruction of SCM+FSA,
  I,J,K for Program of SCM+FSA;

set SA0 = Start-At(0,SCM+FSA);

definition
  let P be NAT-defined (the Instructions of SCM+FSA)-valued finite Function;
  let l be Element of NAT;
  func Directed(P,l) -> preProgram of SCM+FSA equals
  P +~ (halt SCM+FSA,goto l);
  coherence;
end;

definition
  let P be NAT-defined (the Instructions of SCM+FSA)-valued finite Function;
  func Directed P -> preProgram of SCM+FSA equals
  Directed(P, card P);
  coherence;
end;

canceled 14;

registration
  let I be Program of SCM+FSA;
  cluster Directed I -> initial non empty;
  coherence
  proof
   thus Directed I is initial
    proof let m,n be Nat such that
A1: n in dom Directed I and
A2: m < n;
     n in dom I by A1,FUNCT_4:105;
    then  m in dom I by A2,AFINSQ_1:def 13;
    hence thesis by FUNCT_4:105;
   end;
   thus Directed I is non empty;
  end;
end;

canceled 3;

theorem
  not halt SCM+FSA in rng Directed I by FUNCT_4:106;

theorem
  Reloc(ProgramPart Directed I, m) = ((id the Instructions of
SCM+FSA) +* (halt SCM+FSA .--> goto (m + card I)))* Reloc
  (ProgramPart I, m)
proof
A1: dom(id the Instructions of SCM+FSA) = the Instructions of SCM+FSA by
RELAT_1:71;
  rng(halt SCM+FSA .--> goto (card I)) = {goto (card I)} by FUNCOP_1:14;
  then
A2: rng((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto (
  card I))) c= rng(id the Instructions of SCM+FSA) \/ {goto (card I)} by
FUNCT_4:18;
  rng(id the Instructions of SCM+FSA) = the Instructions of SCM+FSA by
RELAT_1:71;
  then
A3: rng(id the Instructions of SCM+FSA) \/ {goto (card I)} = the
  Instructions of SCM+FSA by ZFMISC_1:46;
  dom(halt SCM+FSA .--> goto (card I)) = {halt SCM+FSA} by FUNCOP_1:19;
  then
  dom((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto (
  card I))) = dom(id the Instructions of SCM+FSA) \/ {halt SCM+FSA} by
FUNCT_4:def 1
    .= the Instructions of SCM+FSA by A1,ZFMISC_1:46;
  then reconsider
  f = (id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto
 card I) as Function of the Instructions of SCM+FSA, the Instructions of
  SCM+FSA by A2,A3,FUNCT_2:def 1,RELSET_1:11;
A4: IncAddr(goto  card I,m) = goto (m + card I) by SCMFSA_4:14;
  dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:71;
  then
A5: f = (id the Instructions of SCM+FSA) +* (halt SCM+FSA, goto  card
  I) by FUNCT_7:def 3;
A6: ProgramPart I = I by RELAT_1:209;
A7: rng I c= the Instructions of SCM+FSA by RELAT_1:def 19;
  ProgramPart Directed I = Directed I by RELAT_1:209
    .= f*I by A5,A7,FUNCT_7:118;
  hence Reloc(ProgramPart Directed I, m)
     = IncAddr(f*Shift(I,m),m) by VALUED_1:23
    .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto (m
  + card I)))* Reloc(ProgramPart I, m) by A6,A4,COMPOS_1:167;
end;

reserve a,b for Int-Location,
  f for FinSeq-Location,
  s,s1,s2 for State of SCM+FSA;

  set q = (intloc 0) .--> 1;
  set f = the Object-Kind of SCM+FSA;
Lm1: dom q = {intloc 0} by FUNCOP_1:19;

registration
  let n be Nat;
  let i be Integer;
  cluster (intloc n) .--> i -> (the Object-Kind of SCM+FSA)-compatible;
  coherence
  proof
    set q = (intloc n) .--> i;
A1: dom q = {intloc n} by FUNCOP_1:19;
    i in INT by INT_1:def 2;
    then
A2: rng q = {i} & {i} c= INT by FUNCOP_1:14,ZFMISC_1:37;
    let x be set;
    assume
A3: x in dom q;
    intloc n in Int-Locations by SCMFSA_2:9;
    then dom q c= Int-Locations by A1,ZFMISC_1:37;
    then reconsider l = x as Int-Location by A3,SCMFSA_2:11;
A4: f.l = ObjectKind l
    .= INT by SCMFSA_2:26;
    q.x in rng q by A3,FUNCT_1:def 5;
    hence q.x in f.x by A4,A2;
  end;
end;

definition
 canceled;
  let I be PartState of SCM+FSA;
  func Initialized I -> PartState of SCM+FSA equals
  I +* Initialize ((intloc 0) .--> 1);
  coherence
  proof
A1: now
      1 in INT by INT_1:def 2;
      then
A2:   rng q = {1} & {1} c= INT by FUNCOP_1:14,ZFMISC_1:37;
      let x be set;
      assume
A3:   x in dom q;
      intloc 0 in Int-Locations by SCMFSA_2:9;
      then dom q c= Int-Locations by Lm1,ZFMISC_1:37;
      then reconsider l = x as Int-Location by A3,SCMFSA_2:11;
A4:   f.l = ObjectKind l
        .= INT by SCMFSA_2:26;
      q.x in rng q by A3,FUNCT_1:def 5;
      hence q.x in f.x by A4,A2;
    end;
    reconsider q as FinPartState of SCM+FSA by A1,FUNCT_1:def 20;
    I +* q +* SA0 is PartState of SCM+FSA;
    hence thesis;
  end;
end;

registration
  let I be FinPartState of SCM+FSA;
 cluster Initialized I -> finite;
 coherence;
end;

canceled 3;

theorem Th23:
  InsCode i in {0,6,7,8} or Exec(i,s).IC SCM+FSA = succ IC s
proof
A1: InsCode i <= 11+1 by SCMFSA_2:35;
A2: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A3: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
  assume
A4: not InsCode i in {0,6,7,8};
  then
A5: InsCode i <> 0 & InsCode i <> 6 by ENUMSET1:def 2;
A6: InsCode i <> 7 & InsCode i <> 8 by A4,ENUMSET1:def 2;
  per cases by A5,A6,A1,A2,A3,NAT_1:8,33;
  suppose
    InsCode i = 1;
    then ex a,b st i = a:=b by SCMFSA_2:54;
    hence thesis by SCMFSA_2:89;
  end;
  suppose
    InsCode i = 2;
    then ex a,b st i = AddTo(a,b) by SCMFSA_2:55;
    hence thesis by SCMFSA_2:90;
  end;
  suppose
    InsCode i = 3;
    then ex a,b st i = SubFrom(a,b) by SCMFSA_2:56;
    hence thesis by SCMFSA_2:91;
  end;
  suppose
    InsCode i = 4;
    then ex a,b st i = MultBy(a,b) by SCMFSA_2:57;
    hence thesis by SCMFSA_2:92;
  end;
  suppose
    InsCode i = 5;
    then ex a,b st i = Divide(a,b) by SCMFSA_2:58;
    hence thesis by SCMFSA_2:93;
  end;
  suppose
    InsCode i = 9;
    then ex a,b,f st i = b:=(f,a) by SCMFSA_2:62;
    hence thesis by SCMFSA_2:98;
  end;
  suppose
    InsCode i = 10;
    then ex a,b,f st i = (f,a):=b by SCMFSA_2:63;
    hence thesis by SCMFSA_2:99;
  end;
  suppose
    InsCode i = 11;
    then ex a,f st i = a:=len f by SCMFSA_2:64;
    hence thesis by SCMFSA_2:100;
  end;
  suppose
    InsCode i = 12;
    then ex a,f st i = f:=<0,...,0>a by SCMFSA_2:65;
    hence thesis by SCMFSA_2:101;
  end;
end;

theorem Th24:
  IC SCM+FSA in dom Initialized I
proof
A1: Initialized I = I +* q +* SA0 by FUNCT_4:15;
  dom SA0 = { IC SCM+FSA } by FUNCOP_1:19;
  then dom Initialized I = dom(I +* q) \/ dom SA0 & IC SCM+FSA in dom SA0
   by A1,FUNCT_4:def 1,TARSKI:def 1;
  hence thesis by XBOOLE_0:def 3;
end;

theorem
  IC Initialized I =  0
proof
A1: Initialized I = Initialize(I +* q) by FUNCT_4:15;
  dom SA0 = { IC SCM+FSA } by FUNCOP_1:19;
  then
A2: IC SCM+FSA in dom SA0 by TARSKI:def 1;
  thus IC Initialized I
     = SA0.IC SCM+FSA by A2,FUNCT_4:14,A1
    .=  0 by FUNCOP_1:87;
end;

Lm2: not intloc 0 in NAT by SCMFSA_2:84;

Lm3: not IC SCM+FSA in NAT by COMPOS_1:3;

theorem Th26:
  I c= Initialized I
proof
  set A = NAT;
A1: dom I c= A by RELAT_1:def 18;
A2: not IC SCM+FSA in dom I by A1,COMPOS_1:3;
A3: not intloc 0 in dom I by A1,SCMFSA_2:84;
  dom(Initialize q) =  dom q \/ dom SA0 by FUNCT_4:def 1
    .= { intloc 0 } \/ dom SA0 by FUNCOP_1:19
    .= { intloc 0 } \/ { IC SCM+FSA } by FUNCOP_1:19
    .= { IC SCM+FSA, intloc 0} by ENUMSET1:41;
  then dom I misses dom(Initialize q)
   by A2,A3,FUNCT_4:15,ZFMISC_1:57;
  hence thesis by FUNCT_4:33;
end;

registration
  let I be non halt-free Program of SCM+FSA;
  cluster Initialized I -> non halt-free;
  coherence
   proof
A1:   halt SCM+FSA in rng I by COMPOS_1:def 7;
     I c= Initialized I by Th26;
     then rng I c= rng Initialized I by RELAT_1:25;
    hence halt SCM+FSA in rng Initialized I by A1;
   end;
end;

canceled 6;

theorem
  (Initialized I) | NAT = I
proof
  dom SA0 = { IC SCM+FSA } by FUNCOP_1:19;
  then
A1: dom SA0 misses NAT by Lm3,ZFMISC_1:56;
A2: dom I c= NAT by FUNCT_4:15,RELAT_1:def 18;
  dom q = { intloc 0 } by FUNCOP_1:19;
  then
A3: dom q misses NAT by Lm2,ZFMISC_1:56;
  dom Initialize (q) =
   dom q \/ dom SA0 by FUNCT_4:def 1;
  then dom (Initialize q) misses NAT
   by A3,A1,XBOOLE_1:70;
  hence thesis by A2,FUNCT_4:82;
end;

scheme
  SCMFSAEx{ F(set) -> Element of the Instructions of SCM+FSA, G(set) ->
Integer, H(set) -> FinSequence of INT, I() -> Element of NAT }
: ex S being State of SCM+FSA st IC S = I() & for i being Element of NAT holds
  S. i = F(i) & S.intloc i = G(i) & S.fsloc i = H(i) proof
  defpred P[set,set] means ex m st $1 = IC SCM+FSA & $2 = I() or $1 =  m
  & $2 = F(m) or $1 = intloc m & $2 = G(m) or $1 = fsloc m & $2 = H(m);
A1: for e being set st e in the carrier of SCM+FSA ex u being set st P[e,u]
  proof
    let e be set;
    assume e in the carrier of SCM+FSA;
    then e in Data-Locations SCM+FSA \/ {IC SCM+FSA} \/ NAT
         by COMPOS_1:160;
    then
    e in Data-Locations SCM+FSA \/ {IC SCM+FSA} or e in NAT by
XBOOLE_0:def 3;
    then
A2: e in Data-Locations SCM+FSA or e in {IC SCM+FSA} or e in
    NAT by XBOOLE_0:def 3;
    now
      per cases by A2,XBOOLE_0:def 3,SCMFSA_2:127;
      case
        e in {IC SCM+FSA};
        hence e = IC SCM+FSA by TARSKI:def 1;
      end;
      case
        e in Int-Locations;
        then e is Int-Location by SCMFSA_2:11;
        hence ex m being Element of NAT st e = intloc m by SCMFSA_2:19;
      end;
      case
        e in FinSeq-Locations;
        then e is FinSeq-Location by SCMFSA_2:12;
        hence ex m being Element of NAT st e = fsloc m by SCMFSA_2:20;
      end;
      case
        e in NAT;
        then reconsider l = e as Element of NAT
        ;
        reconsider m = l as Element of NAT;
        take m;
        thus e =  m;
      end;
    end;
    then consider m such that
A3: e = IC SCM+FSA or e =  m or e = intloc m or e = fsloc m;
    per cases by A3;
    suppose
A4:   e = IC SCM+FSA;
      take u = I();
      thus thesis by A4;
    end;
    suppose
A5:   e =  m;
      take u = F(m);
      thus thesis by A5;
    end;
    suppose
A6:   e = intloc m;
      take u = G(m);
      thus thesis by A6;
    end;
    suppose
A7:   e = fsloc m;
      take u = H(m);
      thus thesis by A7;
    end;
  end;
  consider f being Function such that
A8: dom f = the carrier of SCM+FSA and
A9: for e being set st e in the carrier of SCM+FSA holds P[e,f.e] from
  CLASSES1:sch 1(A1);
A10: dom the Object-Kind of SCM+FSA = the carrier of SCM+FSA by FUNCT_2:def 1;
  now
    let x be set;
    assume
A11: x in dom the Object-Kind of SCM+FSA;
    then consider m such that
A12: x = IC SCM+FSA & f.x = I() or x =  m & f.x = F(m) or x =
    intloc m & f.x = G(m) or x = fsloc m & f.x = H(m) by A9,A10;
    x in Data-Locations SCM+FSA \/ {IC SCM+FSA} \/ NAT by A11,A10,COMPOS_1:160;
    then x in Data-Locations SCM+FSA \/ {IC SCM+FSA} or x in NAT by
XBOOLE_0:def 3;
    then
A13: x in Data-Locations SCM+FSA or x in {IC SCM+FSA} or x in
    NAT by XBOOLE_0:def 3;
    per cases by A13,XBOOLE_0:def 3,SCMFSA_2:127;
    suppose
      x in Int-Locations;
      then
A14:  x is Int-Location by SCMFSA_2:11;
      then (the Object-Kind of SCM+FSA).x = ObjectKind intloc m by A12,
SCMFSA_2:81,83,84
        .= INT by SCMFSA_2:26;
      hence f.x in (the Object-Kind of SCM+FSA).x by A12,A14,INT_1:def 2
,SCMFSA_2:83,84;
    end;
    suppose
      x in FinSeq-Locations;
      then
A15:  x is FinSeq-Location by SCMFSA_2:12;
      then (the Object-Kind of SCM+FSA).x = ObjectKind fsloc m by A12,
SCMFSA_2:82,83,85
        .= INT* by SCMFSA_2:27;
      hence f.x in (the Object-Kind of SCM+FSA).x by A12,A15,FINSEQ_1:def 11
,SCMFSA_2:82,83,85;
    end;
    suppose
A16:  x in {IC SCM+FSA};
      then
A17:  (the Object-Kind of SCM+FSA).x = ObjectKind IC SCM+FSA by TARSKI:def 1
        .= NAT by COMPOS_1:def 6;
      x = IC SCM+FSA by A16,TARSKI:def 1;
      hence f.x in (the Object-Kind of SCM+FSA).x by A12,A17,COMPOS_1:3
,SCMFSA_2:81,82;
    end;
    suppose
      x in NAT;
      then reconsider l = x as Element of NAT;
      (the Object-Kind of SCM+FSA).l = the Instructions of SCM+FSA
            by COMPOS_1:def 8;
      hence f.x in (the Object-Kind of SCM+FSA).x by A12,COMPOS_1:3,SCMFSA_2:84
,85;
    end;
  end;
  then reconsider f as State of SCM+FSA by A8,A10,FUNCT_1:def 20,PARTFUN1:def 4
,RELAT_1:def 18;
  take f;
  ex m st ( IC SCM+FSA = IC SCM+FSA & f.IC SCM+FSA = I() or IC SCM+FSA =
   m & f.IC SCM+FSA = F(m) or IC SCM+FSA = intloc m & f.IC SCM+FSA = G(m)
  or IC SCM+FSA = fsloc m & f.IC SCM+FSA = H(m)) by A9;
  hence IC f = I() by COMPOS_1:3,SCMFSA_2:81,82;
  let i be Element of NAT;
A18:   i in NAT;
  NAT c= the carrier of SCM+FSA by COMPOS_1:def 2;
  then
  ex m st (  i = IC SCM+FSA & f. i = I() or  i =
m & f. i = F(m) or  i = intloc m & f. i = G (m) or  i =
  fsloc m & f. i = H(m)) by A9,A18;

  hence f. i = F(i) by COMPOS_1:3,SCMFSA_2:84,85;
  ex m st ( intloc i = IC SCM+FSA & f.intloc i = I() or intloc i =
m & f.intloc i = F(m) or intloc i = intloc m & f.intloc i = G (m) or intloc i =
  fsloc m & f.intloc i = H(m)) by A9;
  hence f.intloc i = G(i) by AMI_3:52,SCMFSA_2:81,83,84;
  ex m st ( fsloc i = IC SCM+FSA & f.fsloc i = I() or fsloc i =  m &
f.fsloc i = F(m) or fsloc i = intloc m & f.fsloc i = G(m) or fsloc i = fsloc m
  & f.fsloc i = H(m)) by A9;
  hence thesis by SCMFSA_2:82,83,85;
end;

canceled;

theorem
  for s being State of SCM+FSA, x being set st x in dom s holds x is
  Int-Location or x is FinSeq-Location or x = IC SCM+FSA or x is
  Element of NAT
proof
  let s be State of SCM+FSA;
  let x be set;
  assume
A1: x in dom s;
  dom s = Data-Locations SCM+FSA \/ {IC SCM+FSA} \/ NAT by COMPOS_1:172;
  then x in Data-Locations SCM+FSA \/ {IC SCM+FSA} or x in NAT by A1
,XBOOLE_0:def 3;
  then
  x in Data-Locations SCM+FSA or x in {IC SCM+FSA} or x in NAT
  by XBOOLE_0:def 3;
  then x in Int-Locations or x in FinSeq-Locations or x = IC SCM+FSA or x is
  Element of NAT by TARSKI:def 1,XBOOLE_0:def 3,SCMFSA_2:127;
  hence thesis by SCMFSA_2:11,12;
end;

theorem
  for s1,s2 being State of SCM+FSA holds (for l being
  Element of NAT holds s1.l = s2.l) iff s1 | NAT = s2 | NAT
             by COMPOS_1:136;

theorem
  for i being Element of NAT holds not i in
  Data-Locations SCM+FSA & not IC SCM+FSA in Data-Locations SCM+FSA
proof
  let i be Element of NAT;
A1: now
    assume IC SCM+FSA in FinSeq-Locations;
    then IC SCM+FSA is FinSeq-Location by SCMFSA_2:12;
    hence contradiction by SCMFSA_2:82;
  end;
  ( not i in Int-Locations)& not i in FinSeq-Locations by SCMFSA_2:13,14
,XBOOLE_0:3;
  hence not i in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
  now
    assume IC SCM+FSA in Int-Locations;
    then IC SCM+FSA is Int-Location by SCMFSA_2:11;
    hence contradiction by SCMFSA_2:81;
  end;
  hence thesis by A1,XBOOLE_0:def 3,SCMFSA_2:127;
end;

theorem Th38:
  for s1,s2 being State of SCM+FSA holds ((for a being
Int-Location holds s1.a = s2.a) & for f being FinSeq-Location holds s1.f = s2.f
  ) iff DataPart s1 = DataPart s2
proof
  let s1,s2 be State of SCM+FSA;
A1: Data-Locations SCM+FSA \/ {IC SCM+FSA} \/ NAT = (
  Data-Locations SCM+FSA) \/ ({IC SCM+FSA} \/ NAT) by XBOOLE_1:4;
A2: now
    assume that
A3: for a being Int-Location holds s1.a = s2.a and
A4: for f being FinSeq-Location holds s1.f = s2.f;
    hereby
      let x be set;
      assume
A5:   x in Data-Locations SCM+FSA;
      per cases;
      suppose
        x in Int-Locations;
        then x is Int-Location by SCMFSA_2:11;
        hence s1.x = s2.x by A3;
      end;
      suppose
        not x in Int-Locations;
        then x in FinSeq-Locations by A5,XBOOLE_0:def 3,SCMFSA_2:127;
        then x is FinSeq-Location by SCMFSA_2:12;
        hence s1.x = s2.x by A4;
      end;
    end;
  end;
A6: now
    assume
A7: for x being set st x in Data-Locations SCM+FSA holds
    s1.x = s2.x;
    hereby
      let a be Int-Location;
      a in Int-Locations by SCMFSA_2:9;
      then a in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
      hence s1.a = s2.a by A7;
    end;
    hereby
      let f be FinSeq-Location;
      f in FinSeq-Locations by SCMFSA_2:10;
      then f in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
      hence s1.f = s2.f by A7;
    end;
  end;
  dom s2 = (Data-Locations SCM+FSA \/ {IC SCM+FSA} \/ NAT) by
COMPOS_1:172;
  then
A8: Data-Locations SCM+FSA c= dom s2 by A1,XBOOLE_1:7;
  dom s1 = (Data-Locations SCM+FSA \/ {IC SCM+FSA} \/ NAT) by
COMPOS_1:172;
  then Data-Locations SCM+FSA c= dom s1 by A1,XBOOLE_1:7;
  hence thesis by A8,A2,A6,FUNCT_1:165;
end;

canceled 2;

theorem
  for s1,s2 being State of SCM+FSA, n being Element of NAT, i being
  Instruction of SCM+FSA holds IC s1 + n = IC s2 & DataPart s1 = DataPart s2
  implies IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) & DataPart Exec(i,s1) =
  DataPart Exec(IncAddr(i,n),s2)
proof
  set D = Data-Locations SCM+FSA;
  let s1,s2 be State of SCM+FSA;
  let n be Element of NAT;
  let i be Instruction of SCM+FSA;
  assume that
A1: IC s1 + n = IC s2 and
A2: DataPart s1 = DataPart s2;
  reconsider k1 = IC s1 as Element of NAT;
A3: succ IC s1 + n =  (k1 + 1) + n by NAT_1:39
    .= k1 + n + 1
    .= succ (IC s2) by A1,NAT_1:39;
A4: now
    set I = InsCode i;
    assume that
A5: InsCode i < 6 or 8 < InsCode i and
A6: InsCode i <> 0;
    not InsCode i in {6,7,8}
    proof
      assume InsCode i in {6,7,8};
       then InsCode i = 6 or InsCode i = 7 or InsCode i = 8 by ENUMSET1:def 1;
      hence contradiction by A5;
    end;
    then
A7: IncAddr(i,n) = i by SCMFSA_4:30;
A8: not InsCode i in {0,6,7,8}
    proof
      assume
A9:  InsCode i in {0,6,7,8};
      per cases by A9,ENUMSET1:def 2;
      suppose
        I = 0;
        hence contradiction by A6;
      end;
      suppose
        I = 6;
        hence contradiction by A5;
      end;
      suppose
        I = 7;
        hence contradiction by A5;
      end;
      suppose
        I = 8;
        hence contradiction by A5;
      end;
    end;
    then IC Exec(i,s1) = succ IC s1 by Th23;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A3,A8,A7,Th23;
  end;
A10: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
A11: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A12: InsCode i <= 11+1 by SCMFSA_2:35;
  per cases by A12,A11,A10,NAT_1:8,33;
  suppose
    InsCode i = 0;
    then
A13: i = halt SCM+FSA by SCMFSA_2:122;
    then Exec(i,s1) = s1 & Exec(i,s2) = s2 by EXTPRO_1:def 3;
    hence thesis by A1,A2,A13,COMPOS_1:93;
  end;
  suppose
A14: InsCode i = 1;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider da, db being Int-Location such that
A15: i = da := db by A14,SCMFSA_2:54;
A16: IncAddr(i,n) = i by A15,COMPOS_1:92;
A17: now
      let c be Int-Location;
      per cases;
      suppose
A18:    c = da;
        hence Exec(i,s1).c = s1.db by A15,SCMFSA_2:89
          .= s2.db by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A15,A16,A18,SCMFSA_2:89;
      end;
      suppose
A19:    c <> da;
        hence Exec(i,s1).c = s1.c by A15,SCMFSA_2:89
          .= s2.c by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A15,A16,A19,SCMFSA_2:89;
      end;
    end;
    now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A15,SCMFSA_2:89
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A15,A16,SCMFSA_2:89;
    end;
    hence thesis by A17,Th38;
  end;
  suppose
A20: InsCode i = 2;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider da, db being Int-Location such that
A21: i = AddTo(da, db) by A20,SCMFSA_2:55;
A22: IncAddr(i,n) = i by A21,COMPOS_1:92;
A23: now
      let c be Int-Location;
      per cases;
      suppose
A24:    c = da;
        s1.da = s2.da & s1.db = s2.db by A2,Th38;
        hence Exec(i,s1).c = s2.da + s2.db by A21,A24,SCMFSA_2:90
          .= Exec(IncAddr(i,n),s2).c by A21,A22,A24,SCMFSA_2:90;
      end;
      suppose
A25:    c <> da;
        hence Exec(i,s1).c = s1.c by A21,SCMFSA_2:90
          .= s2.c by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A21,A22,A25,SCMFSA_2:90;
      end;
    end;
    now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A21,SCMFSA_2:90
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A21,A22,SCMFSA_2:90;
    end;
    hence thesis by A23,Th38;
  end;
  suppose
A26: InsCode i = 3;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider da, db being Int-Location such that
A27: i = SubFrom(da, db) by A26,SCMFSA_2:56;
A28: IncAddr(i,n) = i by A27,COMPOS_1:92;
A29: now
      let c be Int-Location;
      per cases;
      suppose
A30:    c = da;
        s1.da = s2.da & s1.db = s2.db by A2,Th38;
        hence Exec(i,s1).c = s2.da - s2.db by A27,A30,SCMFSA_2:91
          .= Exec(IncAddr(i,n),s2).c by A27,A28,A30,SCMFSA_2:91;
      end;
      suppose
A31:    c <> da;
        hence Exec(i,s1).c = s1.c by A27,SCMFSA_2:91
          .= s2.c by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A27,A28,A31,SCMFSA_2:91;
      end;
    end;
    now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A27,SCMFSA_2:91
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A27,A28,SCMFSA_2:91;
    end;
    hence thesis by A29,Th38;
  end;
  suppose
A32: InsCode i = 4;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider da, db being Int-Location such that
A33: i = MultBy(da, db) by A32,SCMFSA_2:57;
A34: IncAddr(i,n) = i by A33,COMPOS_1:92;
A35: now
      let c be Int-Location;
      per cases;
      suppose
A36:    c = da;
        s1.da = s2.da & s1.db = s2.db by A2,Th38;
        hence Exec(i,s1).c = s2.da * s2.db by A33,A36,SCMFSA_2:92
          .= Exec(IncAddr(i,n),s2).c by A33,A34,A36,SCMFSA_2:92;
      end;
      suppose
A37:    c <> da;
        hence Exec(i,s1).c = s1.c by A33,SCMFSA_2:92
          .= s2.c by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A33,A34,A37,SCMFSA_2:92;
      end;
    end;
    now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A33,SCMFSA_2:92
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A33,A34,SCMFSA_2:92;
    end;
    hence thesis by A35,Th38;
  end;
  suppose
A38: InsCode i = 5;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider da, db being Int-Location such that
A39: i = Divide(da, db) by A38,SCMFSA_2:58;
A40: IncAddr(i,n) = i by A39,COMPOS_1:92;
A41: now
      let c be Int-Location;
      per cases;
      suppose
A42:    c = db;
        s1.da = s2.da & s1.db = s2.db by A2,Th38;
        hence Exec(i,s1).c = s2.da mod s2.db by A39,A42,SCMFSA_2:93
          .= Exec(IncAddr(i,n),s2).c by A39,A40,A42,SCMFSA_2:93;
      end;
      suppose
A43:    c = da & c <> db;
        s1.da = s2.da & s1.db = s2.db by A2,Th38;
        hence Exec(i,s1).c = s2.da div s2.db by A39,A43,SCMFSA_2:93
          .= Exec(IncAddr(i,n),s2).c by A39,A40,A43,SCMFSA_2:93;
      end;
      suppose
A44:    c <> da & c <> db;
        hence Exec(i,s1).c = s1.c by A39,SCMFSA_2:93
          .= s2.c by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A39,A40,A44,SCMFSA_2:93;
      end;
    end;
    now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A39,SCMFSA_2:93
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A39,A40,SCMFSA_2:93;
    end;
    hence thesis by A41,Th38;
  end;
  suppose
    InsCode i = 6;
    then consider loc being Element of NAT such that
A45: i = goto loc by SCMFSA_2:59;
A46: IncAddr(i,n) = goto (loc + n) by A45,SCMFSA_4:14;
A47: now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A45,SCMFSA_2:95
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A46,SCMFSA_2:95;
    end;
    IC Exec(i,s1) = loc by A45,SCMFSA_2:95;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A46,SCMFSA_2:95;
    now
      let c be Int-Location;
      thus Exec(i,s1).c = s1.c by A45,SCMFSA_2:95
        .= s2.c by A2,Th38
        .= Exec(IncAddr(i,n),s2).c by A46,SCMFSA_2:95;
    end;
    hence thesis by A47,Th38;
  end;
  suppose
    InsCode i = 7;
    then consider
    loc being Element of NAT, da being Int-Location
    such that
A48: i = da=0_goto loc by SCMFSA_2:60;
A49: IncAddr(i,n) = da=0_goto (loc + n) by A48,SCMFSA_4:15;
A50: now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A48,SCMFSA_2:96
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A49,SCMFSA_2:96;
    end;
    hereby
      per cases;
      suppose
        s1.da = 0;
        then s2.da = 0 & IC Exec(i,s1) = loc by A2,A48,Th38,SCMFSA_2:96;
        hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A49,SCMFSA_2:96;
      end;
      suppose
        s1.da <> 0;
        then s2.da <> 0 & IC Exec(i,s1) = succ IC s1 by A2,A48,Th38,SCMFSA_2:96
;
        hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A3,A49,
SCMFSA_2:96;
      end;
    end;
    now
      let c be Int-Location;
      thus Exec(i,s1).c = s1.c by A48,SCMFSA_2:96
        .= s2.c by A2,Th38
        .= Exec(IncAddr(i,n),s2).c by A49,SCMFSA_2:96;
    end;
    hence thesis by A50,Th38;
  end;
  suppose
    InsCode i = 8;
    then consider
    loc being Element of NAT, da being Int-Location
    such that
A51: i = da>0_goto loc by SCMFSA_2:61;
A52: IncAddr(i,n) = da>0_goto (loc + n) by A51,SCMFSA_4:16;
A53: now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A51,SCMFSA_2:97
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A52,SCMFSA_2:97;
    end;
    hereby
      per cases;
      suppose
        s1.da > 0;
        then s2.da > 0 & IC Exec(i,s1) = loc by A2,A51,Th38,SCMFSA_2:97;
        hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A52,SCMFSA_2:97;
      end;
      suppose
        s1.da <= 0;
        then s2.da <= 0 & IC Exec(i,s1) = succ IC s1 by A2,A51,Th38,SCMFSA_2:97
;
        hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A3,A52,
SCMFSA_2:97;
      end;
    end;
    now
      let c be Int-Location;
      thus Exec(i,s1).c = s1.c by A51,SCMFSA_2:97
        .= s2.c by A2,Th38
        .= Exec(IncAddr(i,n),s2).c by A52,SCMFSA_2:97;
    end;
    hence thesis by A53,Th38;
  end;
  suppose
A54: InsCode i = 9;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider db, da being Int-Location, f being FinSeq-Location such that
A55: i = da := (f,db) by A54,SCMFSA_2:62;
A56: IncAddr(i,n) = i by A55,COMPOS_1:92;
A57: now
      let c be Int-Location;
      per cases;
      suppose
A58:    c = da;
        then consider m being Element of NAT such that
A59:    m = abs(s1.db) and
A60:    Exec(da:=(f,db), s1).c = (s1.f)/.m by SCMFSA_2:98;
A61:    s1.f = s2.f by A2,Th38;
        consider m2 being Element of NAT such that
A62:    m2 = abs(s2.db) and
A63:    Exec(da:=(f,db), s2).c = (s2.f)/.m2 by A58,SCMFSA_2:98;
        m = m2 by A2,A59,A62,Th38;
        hence Exec(i,s1).c = Exec(IncAddr(i,n),s2).c by A55,A60,A63,A61,
COMPOS_1:92;
      end;
      suppose
A64:    c <> da;
        hence Exec(i,s1).c = s1.c by A55,SCMFSA_2:98
          .= s2.c by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A55,A56,A64,SCMFSA_2:98;
      end;
    end;
    now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A55,SCMFSA_2:98
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A55,A56,SCMFSA_2:98;
    end;
    hence thesis by A57,Th38;
  end;
  suppose
A65: InsCode i = 10;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider db, da being Int-Location, f being FinSeq-Location such that
A66: i = (f,db):=da by A65,SCMFSA_2:63;
A67: IncAddr(i,n) = i by A66,COMPOS_1:92;
A68: now
      let g be FinSeq-Location;
      per cases;
      suppose
A69:    g = f;
A70:    s1.da = s2.da & s1.f = s2.f by A2,Th38;
        consider m2 being Element of NAT such that
A71:    m2 = abs(s2.db) and
A72:    Exec((f,db):=da, s2).f = s2.f+*(m2,s2.da) by SCMFSA_2:99;
        consider m1 being Element of NAT such that
A73:    m1 = abs(s1.db) and
A74:    Exec((f,db):=da, s1).f = s1.f+*(m1,s1.da) by SCMFSA_2:99;
        m1 = m2 by A2,A73,A71,Th38;
        hence Exec(i,s1).g = Exec(IncAddr(i,n),s2).g by A66,A69,A74,A72,A70,
COMPOS_1:92;
      end;
      suppose
A75:    g <> f;
        hence Exec(i,s1).g = s1.g by A66,SCMFSA_2:99
          .= s2.g by A2,Th38
          .= Exec(IncAddr(i,n),s2).g by A66,A67,A75,SCMFSA_2:99;
      end;
    end;
    now
      let c be Int-Location;
      thus Exec(i,s1).c = s1.c by A66,SCMFSA_2:99
        .= s2.c by A2,Th38
        .= Exec(IncAddr(i,n),s2).c by A66,A67,SCMFSA_2:99;
    end;
    hence thesis by A68,Th38;
  end;
  suppose
A76: InsCode i = 11;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider da being Int-Location, f being FinSeq-Location such that
A77: i = da :=len f by A76,SCMFSA_2:64;
A78: IncAddr(i,n) = i by A77,COMPOS_1:92;
A79: now
      let c be Int-Location;
      per cases;
      suppose
A80:    c = da;
        hence Exec(i,s1).c = len(s1.f) by A77,SCMFSA_2:100
          .= len(s2.f) by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A77,A78,A80,SCMFSA_2:100;
      end;
      suppose
A81:    c <> da;
        hence Exec(i,s1).c = s1.c by A77,SCMFSA_2:100
          .= s2.c by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A77,A78,A81,SCMFSA_2:100;
      end;
    end;
    now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A77,SCMFSA_2:100
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A77,A78,SCMFSA_2:100;
    end;
    hence thesis by A79,Th38;
  end;
  suppose
A82: InsCode i = 12;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider da being Int-Location, f being FinSeq-Location such that
A83: i = f:=<0,...,0>da by A82,SCMFSA_2:65;
A84: IncAddr(i,n) = i by A83,COMPOS_1:92;
A85: now
      let g be FinSeq-Location;
      per cases;
      suppose
A86:    g = f;
        (ex m1 being Element of NAT st m1 = abs(s1.da) & Exec(f
:=<0,...,0>da, s1).f = m1 |-> 0 )& ex m2 being Element of NAT st m2 = abs(s2.da
        ) & Exec(f :=<0,...,0>da, s2).f = m2 |-> 0 by SCMFSA_2:101;
        hence Exec(i,s1).g = Exec(IncAddr(i,n),s2).g by A2,A83,A84,A86,Th38;
      end;
      suppose
A87:    g <> f;
        hence Exec(i,s1).g = s1.g by A83,SCMFSA_2:101
          .= s2.g by A2,Th38
          .= Exec(IncAddr(i,n),s2).g by A83,A84,A87,SCMFSA_2:101;
      end;
    end;
    now
      let c be Int-Location;
      thus Exec(i,s1).c = s1.c by A83,SCMFSA_2:101
        .= s2.c by A2,Th38
        .= Exec(IncAddr(i,n),s2).c by A83,A84,SCMFSA_2:101;
    end;
    hence thesis by A85,Th38;
  end;
end;

canceled;

theorem Th43:
  for p being PartState of SCM+FSA holds dom Initialized p = dom p
  \/ {intloc 0} \/ {IC SCM+FSA}
proof let p be PartState of SCM+FSA;
A1: dom q = {intloc 0} & dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    Initialized p = Initialize(p +* q) by FUNCT_4:15;
  hence dom Initialized p = dom (p +* q) \/ dom SA0 by FUNCT_4:def 1
    .= dom p \/ {intloc 0} \/ {IC SCM+FSA} by A1,FUNCT_4:def 1;
end;

theorem Th44:
  for I being Program of SCM+FSA, x being set st x in dom
  Initialized I holds x in dom I or x = intloc 0 or x = IC SCM+FSA
proof
  let I be Program of SCM+FSA;
  let x be set;
A1: dom q = {intloc 0} & dom SA0 = {IC
  SCM+FSA} by FUNCOP_1:19;
  assume
A2: x in dom Initialized I;
    Initialized I = Initialize(I +* q) by FUNCT_4:15;
  then dom Initialized I = dom (I +* q) \/ dom SA0 by FUNCT_4:def 1
    .= dom I \/ {intloc 0} \/ {IC SCM+FSA} by A1,FUNCT_4:def 1;
  then x in dom I \/ {intloc 0} or x in {IC SCM+FSA} by A2,XBOOLE_0:def 3;
  then x in dom I or x in {intloc 0} or x in {IC SCM+FSA} by XBOOLE_0:def 3;
  hence thesis by TARSKI:def 1;
end;

theorem Th45:
  for I being Program of SCM+FSA holds intloc 0 in dom Initialized I
proof
  let I be Program of SCM+FSA;
A1: dom q = {intloc 0} & dom SA0 = {IC
  SCM+FSA} by FUNCOP_1:19;
  intloc 0 in {intloc 0} by TARSKI:def 1;
  then
A2: intloc 0 in dom I \/ {intloc 0} by XBOOLE_0:def 3;
    Initialized I = Initialize(I +* q) by FUNCT_4:15;
  then dom Initialized I = dom (I +* q) \/ dom SA0 by FUNCT_4:def 1
    .= dom I \/ {intloc 0} \/ {IC SCM+FSA} by A1,FUNCT_4:def 1;
  hence thesis by A2,XBOOLE_0:def 3;
end;

theorem Th46:
  for I being Program of SCM+FSA holds (Initialized I).intloc 0 =
  1 & (Initialized I).IC SCM+FSA =  0
proof
  let I be Program of SCM+FSA;
  intloc 0 in {intloc 0} by TARSKI:def 1;
  then
A1: intloc 0 in dom q by FUNCOP_1:19;
A2: Initialized I = Initialize(I +* q) by FUNCT_4:15;
  intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
  then not intloc 0 in {IC SCM+FSA} by TARSKI:def 1;
  then not intloc 0 in dom SA0 by FUNCOP_1:19;
  hence (Initialized I).intloc 0 = (I +* q).intloc 0 by FUNCT_4:12,A2
    .= q.intloc 0 by A1,FUNCT_4:14
    .= 1 by FUNCOP_1:87;
  IC SCM+FSA in {IC SCM+FSA} by TARSKI:def 1;
  then IC SCM+FSA in dom SA0 by FUNCOP_1:19;
  hence (Initialized I).IC SCM+FSA = SA0.IC SCM+FSA by FUNCT_4:14,A2
    .=  0 by FUNCOP_1:87;
end;

theorem Th47:
  for I being Program of SCM+FSA holds not intloc 0 in dom I
proof
  let I be Program of SCM+FSA;
 dom I c= NAT by RELAT_1:def 18;
  hence not intloc 0 in dom I by SCMFSA_2:84;
end;

theorem Th48:
  for I being Program of SCM+FSA, a being Int-Location st a <>
  intloc 0 holds not a in dom Initialized I
proof
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: a <> intloc 0;
  assume a in dom Initialized I;
  then a in dom I \/ {intloc 0} \/ {IC SCM+FSA} by Th43;
  then
A2: a in (dom I \/ {intloc 0}) or a in {IC SCM+FSA} by XBOOLE_0:def 3;
  per cases by A2,XBOOLE_0:def 3;
  suppose
A3: a in dom I;
    dom I c= NAT by RELAT_1:def 18;
    then reconsider a as Element of NAT by A3;
    a in dom I by A3;
    hence contradiction by SCMFSA_2:84;
  end;
  suppose
    a in {intloc 0};
    hence contradiction by A1,TARSKI:def 1;
  end;
  suppose
    a in {IC SCM+FSA};
    then a = IC SCM+FSA by TARSKI:def 1;
    hence contradiction by SCMFSA_2:81;
  end;
end;

theorem Th49:
  for I being Program of SCM+FSA, f being FinSeq-Location holds
  not f in dom Initialized I
proof
  let I be Program of SCM+FSA;
  let f be FinSeq-Location;
  assume f in dom Initialized I;
  then f in dom I \/ {intloc 0} \/ {IC SCM+FSA} by Th43;
  then
A1: f in (dom I \/ {intloc 0}) or f in {IC SCM+FSA} by XBOOLE_0:def 3;
  per cases by A1,XBOOLE_0:def 3;
  suppose
A2: f in dom I;
    dom I c= NAT by RELAT_1:def 18;
    then reconsider f as Element of NAT by A2;
    f in dom I by A2;
    hence contradiction by SCMFSA_2:85;
  end;
  suppose
    f in {intloc 0};
    then f = intloc 0 by TARSKI:def 1;
    hence contradiction by SCMFSA_2:83;
  end;
  suppose
    f in {IC SCM+FSA};
    then f = IC SCM+FSA by TARSKI:def 1;
    hence contradiction by SCMFSA_2:82;
  end;
end;

theorem Th50:
  for I being Program of SCM+FSA, x being set st x in dom I holds
  I.x = (Initialized I).x
proof
  let I be Program of SCM+FSA, x be set;
  assume
A1: x in dom I;
  then dom q = {intloc 0} & x <> intloc 0 by Th47,FUNCOP_1:19;
  then
A2: not x in dom q by TARSKI:def 1;
A3: Initialized I = Initialize(I +* q) by FUNCT_4:15;
  dom SA0 = {IC SCM+FSA} & x <> IC SCM+FSA
   by A1,COMPOS_1:139,FUNCOP_1:19;
  then not x in dom SA0 by TARSKI:def 1;
  hence (Initialized I).x = (I +* q).x by FUNCT_4:12,A3
    .= I.x by A2,FUNCT_4:12;
end;

theorem Th51:
  for I,J being Program of SCM+FSA for s being State of SCM+FSA st
  Initialized J c= s holds s +* Initialized I = s +* I
proof
  let I,J be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s1 = s +* I;
A1: dom (s +* I) = dom s \/ dom I by FUNCT_4:def 1;
  assume
A2: Initialized J c= s;
  then
A3: dom Initialized J c= dom s by GRFUNC_1:8;
A4: dom (s +* Initialized I) = dom s \/ dom Initialized I by FUNCT_4:def 1;
  dom J \/ dom Initialized I = dom J \/ ({intloc 0} \/ dom I \/ {IC
  SCM+FSA}) by Th43
    .= dom J \/ ({intloc 0} \/ {IC SCM+FSA} \/ dom I) by XBOOLE_1:4
    .= dom J \/ ({intloc 0} \/ {IC SCM+FSA}) \/ dom I by XBOOLE_1:4
    .= dom J \/ {intloc 0} \/ {IC SCM+FSA} \/ dom I by XBOOLE_1:4
    .= dom Initialized J \/ dom I by Th43;
  then dom J \/ dom Initialized I c= dom s \/ dom I by A3,XBOOLE_1:13;
  then dom J \/ dom Initialized I c= dom s1 by FUNCT_4:def 1;
  then dom Initialized I c= dom s1 by XBOOLE_1:11;
  then dom (s +* Initialized I) c= dom s \/ (dom s \/ dom I) by A1,A4,
XBOOLE_1:9;
  then
A5: dom (s +* Initialized I) c= dom s \/ dom s \/ dom I by XBOOLE_1:4;
  I c= Initialized I by Th26;
  then
A6: dom I c= dom Initialized I by GRFUNC_1:8;
A7: now
    let x be set;
    assume
A8: x in dom Initialized I;
    per cases by A8,Th44;
    suppose
A9:   x in dom I;
      hence (Initialized I).x = I.x by Th50
        .= s1.x by A9,FUNCT_4:14;
    end;
    suppose
A10:  x = intloc 0;
      then
A11:  x in dom Initialized J by Th45;
A12:  not x in dom I by A10,Th47;
      thus (Initialized I).x = 1 by A10,Th46
        .= (Initialized J).x by A10,Th46
        .= s.x by A2,A11,GRFUNC_1:8
        .= s1.x by A12,FUNCT_4:12;
    end;
    suppose
A13:  x = IC SCM+FSA;
      then
A14:  x in dom Initialized J by Th24;
A15:  not x in dom I by A13,COMPOS_1:139;
      thus (Initialized I).x =  0 by A13,Th46
        .= (Initialized J).x by A13,Th46
        .= s.x by A2,A14,GRFUNC_1:8
        .= s1.x by A15,FUNCT_4:12;
    end;
  end;
A16: now
    let x be set;
    assume x in dom (s +* Initialized I);
    per cases;
    suppose
A17:  x in dom Initialized I;
      hence (s +* Initialized I).x = (Initialized I).x by FUNCT_4:14
        .= (s +* I).x by A7,A17;
    end;
    suppose
A18:  not x in dom Initialized I;
      then
A19:  not x in dom I by A6;
      thus (s +* Initialized I).x = s.x by A18,FUNCT_4:12
        .= (s +* I).x by A19,FUNCT_4:12;
    end;
  end;
  dom (s +* I) c= dom (s +* Initialized I) by A1,A4,A6,XBOOLE_1:9;
  then dom (s +* Initialized I) = dom (s +* I) by A1,A5,XBOOLE_0:def 10;
  hence thesis by A16,FUNCT_1:9;
end;

theorem
  for I,J being Program of SCM+FSA for s being State of SCM+FSA st
  Initialized J c= s holds Initialized I c= s +* I
proof
  let I,J be Program of SCM+FSA;
  let s be State of SCM+FSA;
  assume Initialized J c= s;
  then s +* Initialized I = s +* I by Th51;
  hence thesis by FUNCT_4:26;
end;

theorem
  for I,J being Program of SCM+FSA for s being State of SCM+FSA holds s
  +* Initialized I, s +* Initialized J equal_outside NAT
proof
  let I,J be Program of SCM+FSA;
  let s be State of SCM+FSA;
A1: IC SCM+FSA in dom Initialized I by Th24;
A2: intloc 0 in dom Initialized J by Th45;
A3: intloc 0 in dom Initialized I by Th45;
A4: now
    let a be Int-Location;
    per cases;
    suppose
A5:   a = intloc 0;
      hence (s +* Initialized J).a = (Initialized J).a by A2,FUNCT_4:14
        .= 1 by A5,Th46
        .= (Initialized I).a by A5,Th46
        .= (s +* Initialized I).a by A3,A5,FUNCT_4:14;
    end;
    suppose
A6:   a <> intloc 0;
      then
A7:   not a in dom Initialized I by Th48;
      not a in dom Initialized J by A6,Th48;
      hence (s +* Initialized J).a = s.a by FUNCT_4:12
        .= (s +* Initialized I).a by A7,FUNCT_4:12;
    end;
  end;
A8: now
    let f be FinSeq-Location;
A9: not f in dom Initialized I by Th49;
    not f in dom Initialized J by Th49;
    hence (s +* Initialized J).f = s.f by FUNCT_4:12
      .= (s +* Initialized I).f by A9,FUNCT_4:12;
  end;
  IC SCM+FSA in dom Initialized J by Th24;
  then IC (s +* Initialized J) = (Initialized J).IC SCM+FSA by FUNCT_4:14
    .=  0 by Th46
    .= (Initialized I).IC SCM+FSA by Th46
    .= IC (s +* Initialized I) by A1,FUNCT_4:14;
  hence thesis by A4,A8,SCMFSA10:91;
end;

begin :: The composition of macroinstructions

definition
  let I,J be Program of SCM+FSA;
  func I ';' J -> Program of SCM+FSA equals
  Directed I +* Reloc(J, card I);
  coherence
  proof
    set P = Directed I +* Reloc(J, card I);
    P is initial
    proof
      set D = {l+card I: l in dom J};
      let m,n be Nat such that
A1:   n in dom(P) and
A2:   m < n;
      dom Directed I = dom I & dom Reloc(J,card I) = D by
COMPOS_1:117,FUNCT_4:105;
      then
A3:   dom(P) = dom I \/ D by FUNCT_4:def 1;
      per cases by A1,A3,XBOOLE_0:def 3;
      suppose
         n in dom I;
        then  m in dom I by A2,AFINSQ_1:def 13;
        hence thesis by A3,XBOOLE_0:def 3;
      end;
      suppose
         n in D;
        then consider l such that
A4:      n = l+card I and
A5:     l in dom J;
        now
          per cases;
          case
            m < card I;
            then  m in dom I by AFINSQ_1:70;
            hence  m in dom(P) by A3,XBOOLE_0:def 3;
          end;
          case
            m >= card I;
            then consider l1 being Nat such that
A6:         m = card I + l1 by NAT_1:10;
            reconsider l1 as Element of NAT by ORDINAL1:def 13;
            l1 < l by A2,A4,A6,XREAL_1:8;
            then l1 in dom J by A5,AFINSQ_1:def 13;
            hence  m in D by A6;
          end;
        end;
        hence thesis by A3,XBOOLE_0:def 3;
      end;
    end;
    hence thesis;
  end;
  correctness;
end;

registration
 let I be Program of SCM+FSA, J be non halt-free Program of SCM+FSA;
  cluster I ';' J -> non halt-free;
  coherence;
end;

theorem
  for I,J being Program of SCM+FSA, l being Element of NAT
   st l in dom I & I.l <> halt SCM+FSA holds (I ';' J).l = I.l
proof
  let I,J be Program of SCM+FSA, l be Element of NAT such
  that
A1: l in dom I and
A2: I.l <> halt SCM+FSA;
A3: dom Reloc(J, card I) = dom Shift(J,card I)
  by COMPOS_1:def 40;
  now
    assume l in dom(Reloc(J, card I));
    then l in { m+card I: m in dom J } by A3,VALUED_1:def 12;
    then consider m such that
A4: l = m+card I and
    m in dom J;
    m + card I < card I by A1,A4,AFINSQ_1:70;
    hence contradiction by NAT_1:11;
  end;
  hence (I ';' J).l = (Directed I).l by FUNCT_4:12
    .= I.l by A2,FUNCT_4:111;
end;

theorem
  for I,J being Program of SCM+FSA holds Directed I c= I ';' J
proof
  let I,J be Program of SCM+FSA;
A1: now
    let x be set;
    assume x in dom Directed I;
    then
A2: x in dom I by FUNCT_4:105;
 ProgramPart J = J by RELAT_1:209;
    then dom I misses dom Reloc(J,card I) by COMPOS_1:173;
    then not x in dom Reloc(J,card I) by A2,XBOOLE_0:3;
    hence (Directed I).x = (I ';' J).x by FUNCT_4:12;
  end;
  dom (I ';' J) = dom Directed I \/ dom Reloc(J,card I) by
FUNCT_4:def 1;
  then dom Directed I c= dom (I ';' J) by XBOOLE_1:7;
  hence thesis by A1,GRFUNC_1:8;
end;

theorem Th56:
  for I,J being Program of SCM+FSA holds dom I c= dom (I ';' J)
proof
  let I,J be Program of SCM+FSA;
  dom (I ';' J) = dom Directed I \/ dom Reloc(J,card I) by
FUNCT_4:def 1
    .= dom I \/ dom Reloc(J,card I) by FUNCT_4:105;
  hence thesis by XBOOLE_1:7;
end;

theorem
  for I,J being Program of SCM+FSA holds I +* (I ';' J) = (I ';' J)
proof
  let I,J be Program of SCM+FSA;
A1: for x be set st x in dom (I ';' J) holds (I +* (I ';' J)).x = (I ';' J).
  x by FUNCT_4:14;
  dom (I +* (I ';' J)) = dom I \/ dom (I ';' J) by FUNCT_4:def 1
    .= dom (I ';' J) by Th56,XBOOLE_1:12;
  hence thesis by A1,FUNCT_1:9;
end;

theorem
  for I,J being Program of SCM+FSA holds Initialized I +* (I ';' J) =
  Initialized (I ';' J)
proof
  let I,J be Program of SCM+FSA;
A1: dom I \/ dom (I ';' J) = dom (I ';' J) by Th56,XBOOLE_1:12;
A2: now
    let x be set;
    assume
A3: x in dom Initialized (I ';' J);
    per cases by A3,Th44;
    suppose
A4:   x in dom (I ';' J);
      then x <> IC SCM+FSA by COMPOS_1:139;
      then not x in {IC SCM+FSA} by TARSKI:def 1;
      then
A5:   not x in dom SA0 by FUNCOP_1:19;
      x <> intloc 0 by A4,Th47;
      then not x in {intloc 0} by TARSKI:def 1;
      then
A6:   not x in dom q by FUNCOP_1:19;
A7:   Initialized (I ';' J) = Initialize((I ';' J) +* q) by FUNCT_4:15;
      thus (Initialized I+*(I ';' J)).x = (I ';' J).x by A4,FUNCT_4:14
        .= ((I ';' J) +* q).x by A6,FUNCT_4:12
        .= (Initialized (I ';' J)).x by A5,FUNCT_4:12,A7;
    end;
    suppose
A8:   x = intloc 0;
      then not x in dom (I ';' J) by Th47;
      hence (Initialized I+*(I ';' J)).x = (Initialized I).x by FUNCT_4:12
        .= 1 by A8,Th46
        .= (Initialized (I ';' J)).x by A8,Th46;
    end;
    suppose
A9:   x = IC SCM+FSA;
      then not x in dom (I ';' J) by COMPOS_1:139;
      hence (Initialized I+*(I ';' J)).x = (Initialized I).x by FUNCT_4:12
        .=  0 by A9,Th46
        .= (Initialized (I ';' J)).x by A9,Th46;
    end;
  end;
  dom (Initialized I+*(I ';' J)) = dom Initialized I \/ dom (I ';' J) by
FUNCT_4:def 1
    .= dom I \/ {intloc 0} \/ {IC SCM+FSA} \/ dom (I ';' J) by Th43
    .= dom I \/ {intloc 0} \/ ({IC SCM+FSA} \/ dom (I ';' J)) by XBOOLE_1:4
    .= dom I \/ ({intloc 0} \/ (dom (I ';' J) \/ {IC SCM+FSA})) by XBOOLE_1:4
    .= dom I \/ ({intloc 0} \/ dom (I ';' J) \/ {IC SCM+FSA}) by XBOOLE_1:4
    .= dom I \/ (dom (I ';' J) \/ {intloc 0}) \/ {IC SCM+FSA} by XBOOLE_1:4
    .= dom (I ';' J) \/ {intloc 0} \/ {IC SCM+FSA} by A1,XBOOLE_1:4
    .= dom Initialized (I ';' J) by Th43;
  hence thesis by A2,FUNCT_1:9;
end;

begin :: The compostion of instruction and macroinstructions

definition
  let i, J;
  func i ';' J -> Program of SCM+FSA equals
  Macro i ';' J;
  correctness;
end;

definition
  let I, j;
  func I ';' j -> Program of SCM+FSA equals
  I ';' Macro j;
  correctness;
end;

definition
  let i,j;
  func i ';' j -> Program of SCM+FSA equals
  Macro i ';' Macro j;
  correctness;
end;

theorem
  i ';' j = Macro i ';' j;

theorem
  i ';' j = i ';' Macro j;

theorem Th61:
  card(I ';' J) = card I + card J
proof
A1: card dom(I ';' J) = card(I ';' J) & card dom I = card I by CARD_1:104;
A2: card dom J = card J by CARD_1:104;
A3: dom(I ';' J) = dom Directed I \/ dom Reloc(J, card I) by
FUNCT_4:def 1
    .= dom I \/ dom Reloc(J, card I) by FUNCT_4:105;
A4: ProgramPart J = J by RELAT_1:209;
  card dom Reloc(J, card I) = card Reloc(J, card I) by CARD_1:104
    .= card J by COMPOS_1:174,A4
    .= card dom J by CARD_1:104;
  hence thesis by A1,A2,A3,COMPOS_1:173,CARD_2:53,A4;
end;

registration
  let P be preProgram of SCM+FSA;
  let l be Element of NAT;
  cluster Directed(P,l) -> halt-free;
  correctness
  proof
     not halt SCM+FSA in rng Directed(P,l) by FUNCT_4:106;
    hence thesis by COMPOS_1:def 7;
  end;
end;

registration
  let P be preProgram of SCM+FSA;
  cluster Directed P -> halt-free;
  correctness;
end;

canceled;

theorem Th63:
  for I being preProgram of SCM+FSA, l being Element of NAT
   holds I is halt-free implies Directed(I,l) = I
proof
  let I be preProgram of SCM+FSA;
  let l be Element of NAT;
  assume I is halt-free;
  then not halt SCM+FSA in rng I by COMPOS_1:def 7;
  hence thesis by FUNCT_4:109;
end;

canceled;

theorem Th65:
  for I being preProgram of SCM+FSA, k being Element of NAT holds
  Reloc(Directed I,k) = Directed(Reloc(I,k),(card I + k))
proof
  let I be preProgram of SCM+FSA;
  let k be Element of NAT;
A1: dom Reloc(I,k) = {m + k: m in dom I} by COMPOS_1:117;
A2: dom Directed I = dom I by FUNCT_4:105;
A3: dom Reloc(Directed I,k) = {m + k: m in dom I} by A2,COMPOS_1:117;
A4: now
    let x be set;
    assume
A5: x in {m + k: m in dom I};
    then consider n being Element of NAT such that
A6: x = n + k and
A7: n in dom I;
    dom Directed I = dom I by FUNCT_4:105;
    then reconsider i = (Directed I). n as Instruction of SCM+FSA by A7,
FUNCT_1:176;
    reconsider i0 = I. n as Instruction of SCM+FSA by A7,FUNCT_1:176;
A8: now
      per cases;
      suppose
A9:    i0 = halt SCM+FSA;
        then
A10:    i = goto  card I by A7,FUNCT_4:112;
A11:    (Reloc(I,k)).x
           = IncAddr(i0,k) by A6,A7,COMPOS_1:122
          .= halt SCM+FSA by A9,COMPOS_1:93;
        then (Reloc(I,k)).x in {halt SCM+FSA} by TARSKI:def 1;
        then (Reloc(I,k)).x in dom (halt SCM+FSA .--> goto
         (card I + k)) by FUNCOP_1:19;
        then x in dom ((halt SCM+FSA .--> goto  (card I + k))*
        Reloc(I,k)) by A1,A5,FUNCT_1:21;
        hence (Directed(Reloc(I,k), (card I + k))).x =
((halt SCM+FSA .--> goto  (card I + k))* Reloc(I,k)).x
by FUNCT_4:14
          .= (halt SCM+FSA .--> goto  (card I + k)). ((
        Reloc(I,k)).x) by A1,A5,FUNCT_1:23
          .= goto  (card I + k) by A11,FUNCOP_1:87
          .= IncAddr(i,k) by A10,SCMFSA_4:14;
      end;
      suppose
A12:    i0 <> halt SCM+FSA;
A13:    (Reloc(I,k)).x = IncAddr(i0,k) by A6,A7,COMPOS_1:122;
        InsCode i0 <> 0 by A12,SCMFSA_2:122;
        then IncAddr(i0,k) <> halt SCM+FSA by COMPOS_1:def 38,SCMFSA_2:124;
        then not (Reloc(I,k)).x in {halt SCM+FSA} by A13,
TARSKI:def 1;
        then
        not (Reloc(I,k)).x in dom (halt SCM+FSA .--> goto
         (card I + k)) by FUNCOP_1:19;
        then not x in dom ((halt SCM+FSA .--> goto  (card I + k)) *
        Reloc(I,k)) by FUNCT_1:21;
        hence (Directed(Reloc(I,k), (card I + k))).x =
        (Reloc(I,k)).x by FUNCT_4:12
          .= IncAddr(i,k) by A12,A13,FUNCT_4:111;
      end;
    end;
    thus (Reloc(Directed I,k)).x = (Directed(Reloc(I,k), (card I + k))).x
        by A8,A2,A6,A7,COMPOS_1:122;
  end;
  dom Directed(Reloc(I,k), (card I + k)) = {m + k:
  m in dom I} by A1,FUNCT_4:105;
  hence thesis by A3,A4,FUNCT_1:9;
end;

theorem Th66:
  for I,J being Program of SCM+FSA holds Directed (I ';' J) = I
  ';' Directed J
proof
  let I,J be Program of SCM+FSA;
  thus I ';' Directed J = Directed I +* Directed(Reloc(J,card
  I),  (card I + card J)) by Th65
    .= Directed I +* Directed(Reloc(J,card I), card
  (I ';' J)) by Th61
    .= Directed(Directed I, card (I ';' J)) +* Directed(
  Reloc(J,card I), card (I ';' J)) by Th63
    .= Directed (I ';' J) by FUNCT_7:119;
end;

theorem Th67:
  I ';' J ';' K = I ';' (J ';' K)
proof
A1: Reloc(J ';' K, card I)
   = Reloc(Directed J, card I) +* Reloc(Reloc(K, card J), card I)
               by COMPOS_1:154
  .= Reloc(Directed J, card I) +* Reloc(K,card J + card I) by COMPOS_1:155;
  thus I ';' J ';' K
   = (I ';' Directed J) +* Reloc(K, card (I ';' J)) by Th66
  .= Directed I +* (Reloc(Directed J, card I) +*
         Reloc(K, card (I ';' J))) by FUNCT_4:15
  .= I ';' (J ';' K) by A1,Th61;
end;

theorem
  I ';' J ';' k = I ';' (J ';' k) by Th67;

theorem
  I ';' j ';' K = I ';' (j ';' K) by Th67;

theorem
  I ';' j ';' k = I ';' (j ';' k) by Th67;

theorem
  i ';' J ';' K = i ';' (J ';' K) by Th67;

theorem
  i ';' J ';' k = i ';' (J ';' k) by Th67;

theorem
  i ';' j ';' K = i ';' (j ';' K) by Th67;

theorem
  i ';' j ';' k = i ';' (j ';' k) by Th67;

theorem
 card(i ';' J) = card J + 2
 proof
  thus card(i ';' J) = card Macro i + card J by Th61
     .= card J + 2 by COMPOS_1:150;
 end;

theorem
 card(I ';' j) = card I + 2
 proof
  thus card(I ';' j) = card Macro j + card I by Th61
     .= card I + 2 by COMPOS_1:150;
 end;

theorem
 card(i ';' j) = 4
 proof
  thus card(i ';' j) = card Macro i + card Macro j by Th61
     .= card Macro i + 2 by COMPOS_1:150
     .= 2 + 2 by COMPOS_1:150
     .= 4;
 end;
