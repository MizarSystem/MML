:: On the compositions of macro instructions
::  by Andrzej Trybulec , Yatsuka Nakamura and Noriko Asamoto
::
:: Received June 20, 1996
:: Copyright (c) 1996-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMFSA_2, SCMNORM, FUNCT_4, AMI_3,
      FUNCOP_1, RELAT_1, FUNCT_1, TARSKI, XBOOLE_0, CARD_1, CAT_1, NAT_1,
      ARYTM_3, FINSET_1, STRUCT_0, XXREAL_0, AMISTD_2, VALUED_1, FSM_1,
      GRAPHSP, FUNCT_7, ARYTM_1, INT_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2,
      TURING_1, SCMFSA6A, ORDINAL1, RELOC, SCMFSA6C;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, COMPLEX1,
      NAT_1, INT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FINSEQ_1, FINSEQ_2,
      FINSET_1, FUNCT_4, DOMAIN_1, VALUED_1, AFINSQ_1, STRUCT_0, MEMSTR_0,
      COMPOS_1, EXTPRO_1, FUNCT_7, SCMFSA_2, AMISTD_2, FUNCOP_1, XXREAL_0;
 constructors WELLORD2, DOMAIN_1, XXREAL_0, INT_2, AMISTD_2, SCMFSA_2,
      RELSET_1, VALUED_1, AMI_3, PRE_POLY, AMISTD_1, FUNCT_7, MEMSTR_0;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1,
      FINSET_1, NUMBERS, XREAL_0, INT_1, STRUCT_0, SCMFSA_2, FUNCT_4, RELAT_1,
      VALUED_1, SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1, SCMFSA_4, MEMSTR_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCT_1, FUNCOP_1, SCMFSA_2, FUNCT_7, XBOOLE_0, TARSKI, COMPOS_1,
      EXTPRO_1, FUNCT_4, AFINSQ_1, AMISTD_2, MEMSTR_0, PARTFUN1;
 theorems FUNCT_2, RELAT_1, FUNCT_7, FUNCT_4, FUNCT_1, ZFMISC_1, FUNCOP_1,
      TARSKI, NAT_1, SCMFSA_4, SCMFSA_2, CARD_1, CARD_2, MEMSTR_0, ENUMSET1,
      INT_1, GRFUNC_1, FINSEQ_1, RELSET_1, XBOOLE_0, XBOOLE_1, XREAL_1,
      ORDINAL1, AMI_3, VALUED_1, PARTFUN1, AFINSQ_1, SCMFSA10, COMPOS_1,
      EXTPRO_1, STRUCT_0;
 schemes CLASSES1;

begin

reserve l, m, n for Element of NAT,
  i,j,k for Instruction of SCM+FSA,
  I,J,K for Program of SCM+FSA;

set SA0 = Start-At(0,SCM+FSA);

definition
  let P be NAT-defined (the Instructions of SCM+FSA)-valued finite Function;
  let l be Element of NAT;
  func Directed(P,l) -> preProgram of SCM+FSA equals
  P +~ (halt SCM+FSA,goto l);
  coherence;
end;

definition
  let P be NAT-defined (the Instructions of SCM+FSA)-valued finite Function;
  func Directed P -> preProgram of SCM+FSA equals
  Directed(P, card P);
  coherence;
end;

registration
  let I be Program of SCM+FSA;
  cluster Directed I -> initial non empty;
  coherence
  proof
   thus Directed I is initial
    proof let m,n be Nat such that
A1: n in dom Directed I and
A2: m < n;
     n in dom I by A1,FUNCT_4:99;
    then  m in dom I by A2,AFINSQ_1:def 12;
    hence thesis by FUNCT_4:99;
   end;
   thus Directed I is non empty;
  end;
end;



theorem
  not halt SCM+FSA in rng Directed I by FUNCT_4:100;

theorem
  Reloc(Directed I, m) = ((id the Instructions of
SCM+FSA) +* (halt SCM+FSA .--> goto (m + card I)))* Reloc(I, m)
proof
A1: dom(id the Instructions of SCM+FSA) = the Instructions of SCM+FSA by
RELAT_1:45;
  rng(halt SCM+FSA .--> goto (card I)) = {goto (card I)} by FUNCOP_1:8;
  then
A2: rng((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto (
  card I))) c= rng(id the Instructions of SCM+FSA) \/ {goto (card I)} by
FUNCT_4:17;
  rng(id the Instructions of SCM+FSA) = the Instructions of SCM+FSA by
RELAT_1:45;
  then
A3: rng(id the Instructions of SCM+FSA) \/ {goto (card I)} = the
  Instructions of SCM+FSA by ZFMISC_1:40;
  dom(halt SCM+FSA .--> goto (card I)) = {halt SCM+FSA} by FUNCOP_1:13;
  then
  dom((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto (
  card I))) = dom(id the Instructions of SCM+FSA) \/ {halt SCM+FSA} by
FUNCT_4:def 1
    .= the Instructions of SCM+FSA by A1,ZFMISC_1:40;
  then reconsider
  f = (id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto
 card I) as Function of the Instructions of SCM+FSA, the Instructions of
  SCM+FSA by A2,A3,FUNCT_2:def 1,RELSET_1:4;
A4: IncAddr(goto  card I,m) = goto (m + card I) by SCMFSA_4:1;
  dom id the Instructions of SCM+FSA = the Instructions of SCM+FSA by
RELAT_1:45;
  then
A5: f = (id the Instructions of SCM+FSA) +* (halt SCM+FSA, goto  card
  I) by FUNCT_7:def 3;
A7: rng I c= the Instructions of SCM+FSA by RELAT_1:def 19;
  Directed I = Directed I
    .= f*I by A5,A7,FUNCT_7:116;
  hence Reloc(Directed I, m)
     = IncAddr(f*Shift(I,m),m) by VALUED_1:22
    .= ((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> goto (m
  + card I)))* Reloc(I, m) by A4,COMPOS_1:47;
end;

reserve a,b for Int-Location,
  f for FinSeq-Location,
  s,s1,s2 for State of SCM+FSA;

  set q = (intloc 0) .--> 1;
  set f = the Object-Kind of SCM+FSA;

registration
  let n be Nat;
  let i be Integer;
  cluster (intloc n) .--> i -> (the Object-Kind of SCM+FSA)-compatible;
  coherence
  proof
    set q = (intloc n) .--> i;
A1: dom q = {intloc n} by FUNCOP_1:13;
    i in INT by INT_1:def 2;
    then
A2: rng q = {i} & {i} c= INT by FUNCOP_1:8,ZFMISC_1:31;
    let x be set;
    assume
A3: x in dom q;
    intloc n in Int-Locations by SCMFSA_2:2;
    then dom q c= Int-Locations by A1,ZFMISC_1:31;
    then reconsider l = x as Int-Location by A3,SCMFSA_2:4;
A4: f.l = ObjectKind l
    .= INT by SCMFSA_2:11;
    q.x in rng q by A3,FUNCT_1:def 3;
    hence q.x in f.x by A4,A2;
  end;
end;

definition
  let I be PartState of SCM+FSA;
  func Initialized I -> PartState of SCM+FSA equals
  I +* Initialize ((intloc 0) .--> 1);
  coherence;
 projectivity
 proof
  let IT,s be PartState of SCM+FSA;
  assume
Z: IT = s +* Initialize ((intloc 0) .--> 1);
  dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
  then
A2: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A3: s +* Initialize ((intloc 0) .--> 1)
   = Initialize(s +* ((intloc 0) .--> 1)) by FUNCT_4:14;
 dom ((intloc 0) .--> 1) = {intloc 0} by FUNCOP_1:13;
  then
A5: intloc 0 in dom ((intloc 0) .--> 1) by TARSKI:def 1;
A6:  not intloc 0 in dom SA0 by SCMFSA_2:102;
B1: (s +* Initialize ((intloc 0) .--> 1)).intloc 0
   = (Initialize(s +* ((intloc 0) .--> 1))).intloc 0 by FUNCT_4:14
  .= (s +* ((intloc 0) .--> 1)).intloc 0 by A6,FUNCT_4:11
  .= (((intloc 0) .--> 1)).intloc 0 by A5,FUNCT_4:13
    .= 1 by FUNCOP_1:72;
  SA0.IC SCM+FSA =  0 by FUNCOP_1:72;
 then
B2: IC IT =  0 by Z,A2,A3,FUNCT_4:13;
A3: IC SCM+FSA in dom IT by Z,MEMSTR_0:49;
X1:  dom IT = dom s \/ dom Initialize ((intloc 0) .--> 1) by Z,FUNCT_4:def 1;
X2:   dom Initialize ((intloc 0) .--> 1)
        = dom ((intloc 0) .--> 1) \/ dom Start-At(0,SCM+FSA) by FUNCT_4:def 1;
    dom ((intloc 0) .--> 1) = {intloc 0} by FUNCOP_1:13;
    then intloc 0 in dom ((intloc 0) .--> 1) by TARSKI:def 1;
    then intloc 0 in dom Initialize ((intloc 0) .--> 1) by X2,XBOOLE_0:def 3;
    then
A4: intloc 0 in dom IT by X1,XBOOLE_0:def 3;
  thus IT +* Initialize ((intloc 0) .--> 1)
     = Initialize(IT +* ((intloc 0) .--> 1)) by FUNCT_4:14
    .= IT +* (IC SCM+FSA .-->  0) by B1,A4,Z,FUNCT_7:109
    .= IT by B2,A3,FUNCT_7:109;
 end;
end;

registration
  let I be PartState of SCM+FSA;
 cluster Initialized I -> 0-started;
 coherence;
end;

registration
  let I be FinPartState of SCM+FSA;
 cluster Initialized I -> finite;
 coherence;
end;

theorem Th23:
  InsCode i in {0,6,7,8} or Exec(i,s).IC SCM+FSA = succ IC s
proof
A1: InsCode i <= 12 by SCMFSA_2:16;
  assume
A4: not InsCode i in {0,6,7,8};
  then
A5: InsCode i <> 0 & InsCode i <> 6 by ENUMSET1:def 2;
A6: InsCode i <> 7 & InsCode i <> 8 by A4,ENUMSET1:def 2;
  per cases by A5,A6,A1,NAT_1:36;
  suppose
    InsCode i = 1;
    then ex a,b st i = a:=b by SCMFSA_2:30;
    hence thesis by SCMFSA_2:63;
  end;
  suppose
    InsCode i = 2;
    then ex a,b st i = AddTo(a,b) by SCMFSA_2:31;
    hence thesis by SCMFSA_2:64;
  end;
  suppose
    InsCode i = 3;
    then ex a,b st i = SubFrom(a,b) by SCMFSA_2:32;
    hence thesis by SCMFSA_2:65;
  end;
  suppose
    InsCode i = 4;
    then ex a,b st i = MultBy(a,b) by SCMFSA_2:33;
    hence thesis by SCMFSA_2:66;
  end;
  suppose
    InsCode i = 5;
    then ex a,b st i = Divide(a,b) by SCMFSA_2:34;
    hence thesis by SCMFSA_2:67;
  end;
  suppose
    InsCode i = 9;
    then ex a,b,f st i = b:=(f,a) by SCMFSA_2:38;
    hence thesis by SCMFSA_2:72;
  end;
  suppose
    InsCode i = 10;
    then ex a,b,f st i = (f,a):=b by SCMFSA_2:39;
    hence thesis by SCMFSA_2:73;
  end;
  suppose
    InsCode i = 11;
    then ex a,f st i = a:=len f by SCMFSA_2:40;
    hence thesis by SCMFSA_2:74;
  end;
  suppose
    InsCode i = 12;
    then ex a,f st i = f:=<0,...,0>a by SCMFSA_2:41;
    hence thesis by SCMFSA_2:75;
  end;
end;

scheme
  SCMFSAEx{ G(set) -> Integer, H(set) -> FinSequence of INT,
        I() -> Element of NAT }:
 ex S being State of SCM+FSA st IC S = I() &
   for i being Element of NAT holds S.intloc i = G(i) & S.fsloc i = H(i)
 proof
  defpred P[set,set] means ex m st $1 = IC SCM+FSA & $2 = I() or
   $1 = intloc m & $2 = G(m) or $1 = fsloc m & $2 = H(m);
A1: for e being set st e in the carrier of SCM+FSA ex u being set st P[e,u]
  proof
    let e be set;
    assume e in the carrier of SCM+FSA;
    then e in Data-Locations SCM+FSA \/ {IC SCM+FSA} by STRUCT_0:4;
    then
    e in Data-Locations SCM+FSA \/ {IC SCM+FSA};
    then
A2: e in Data-Locations SCM+FSA or e in {IC SCM+FSA} by XBOOLE_0:def 3;
    now
      per cases by A2,SCMFSA_2:100,XBOOLE_0:def 3;
      case
        e in {IC SCM+FSA};
        hence e = IC SCM+FSA by TARSKI:def 1;
      end;
      case
        e in Int-Locations;
        then e is Int-Location by SCMFSA_2:4;
        hence ex m being Element of NAT st e = intloc m by SCMFSA_2:8;
      end;
      case
        e in FinSeq-Locations;
        then e is FinSeq-Location by SCMFSA_2:5;
        hence ex m being Element of NAT st e = fsloc m by SCMFSA_2:9;
      end;
    end;
    then consider m such that
A3: e = IC SCM+FSA or e = intloc m or e = fsloc m;
    per cases by A3;
    suppose
A4:   e = IC SCM+FSA;
      take u = I();
      thus thesis by A4;
    end;
    suppose
A6:   e = intloc m;
      take u = G(m);
      thus thesis by A6;
    end;
    suppose
A7:   e = fsloc m;
      take u = H(m);
      thus thesis by A7;
    end;
  end;
  consider f being Function such that
A8: dom f = the carrier of SCM+FSA and
A9: for e being set st e in the carrier of SCM+FSA holds P[e,f.e] from
  CLASSES1:sch 1(A1);
A10: dom the Object-Kind of SCM+FSA = the carrier of SCM+FSA by FUNCT_2:def 1;
  now
    let x be set;
    assume
A11: x in dom the Object-Kind of SCM+FSA;
    then consider m such that
A12: x = IC SCM+FSA & f.x = I() or x =
    intloc m & f.x = G(m) or x = fsloc m & f.x = H(m) by A9,A10;
    x in Data-Locations SCM+FSA \/ {IC SCM+FSA} by A11,A10,STRUCT_0:4;
    then x in Data-Locations SCM+FSA \/ {IC SCM+FSA};
    then
A13: x in Data-Locations SCM+FSA or x in {IC SCM+FSA} by XBOOLE_0:def 3;
    per cases by A13,SCMFSA_2:100,XBOOLE_0:def 3;
    suppose
      x in Int-Locations;
      then
A14:  x is Int-Location by SCMFSA_2:4;
      then (the Object-Kind of SCM+FSA).x = ObjectKind intloc m by A12,
SCMFSA_2:56,58
        .= INT by SCMFSA_2:11;
      hence f.x in (the Object-Kind of SCM+FSA).x by A12,A14,INT_1:def 2
,SCMFSA_2:58;
    end;
    suppose
      x in FinSeq-Locations;
      then
A15:  x is FinSeq-Location by SCMFSA_2:5;
      then (the Object-Kind of SCM+FSA).x = ObjectKind fsloc m by A12,
SCMFSA_2:57,58
        .= INT* by SCMFSA_2:12;
      hence f.x in (the Object-Kind of SCM+FSA).x by A12,A15,FINSEQ_1:def 11
,SCMFSA_2:57,58;
    end;
    suppose
A16:  x in {IC SCM+FSA};
      then
A17:  (the Object-Kind of SCM+FSA).x = ObjectKind IC SCM+FSA by TARSKI:def 1
        .= NAT by MEMSTR_0:def 3;
      x = IC SCM+FSA by A16,TARSKI:def 1;
      hence f.x in (the Object-Kind of SCM+FSA).x by A12,A17,SCMFSA_2:56,57;
    end;
  end;
  then reconsider f as State of SCM+FSA by A8,A10,FUNCT_1:def 14,PARTFUN1:def 2
,RELAT_1:def 18;
  take f;
  ex m st ( IC SCM+FSA = IC SCM+FSA & f.IC SCM+FSA = I()
   or IC SCM+FSA = intloc m & f.IC SCM+FSA = G(m)
  or IC SCM+FSA = fsloc m & f.IC SCM+FSA = H(m)) by A9;
  hence IC f = I() by SCMFSA_2:56,57;
  let i be Element of NAT;

  ex m st ( intloc i = IC SCM+FSA & f.intloc i = I() or
   intloc i = intloc m & f.intloc i = G (m) or intloc i =
  fsloc m & f.intloc i = H(m)) by A9;
  hence f.intloc i = G(i) by AMI_3:10,SCMFSA_2:56,58;
  ex m st ( fsloc i = IC SCM+FSA & f.fsloc i = I() or
   fsloc i = intloc m & f.fsloc i = G(m) or fsloc i = fsloc m
  & f.fsloc i = H(m)) by A9;
  hence thesis by SCMFSA_2:57,58;
end;

canceled;

theorem
  for s being State of SCM+FSA, x being set st x in dom s holds x is
  Int-Location or x is FinSeq-Location or x = IC SCM+FSA
proof
  let s be State of SCM+FSA;
  let x be set;
  assume
A1: x in dom s;
  dom s = Data-Locations SCM+FSA \/ {IC SCM+FSA} by MEMSTR_0:13;
  then x in Data-Locations SCM+FSA \/ {IC SCM+FSA} by A1;
  then
  x in Data-Locations SCM+FSA or x in {IC SCM+FSA}
  by XBOOLE_0:def 3;
  then x in Int-Locations or x in FinSeq-Locations or x = IC SCM+FSA
   by SCMFSA_2:100,TARSKI:def 1,XBOOLE_0:def 3;
  hence thesis by SCMFSA_2:4,5;
end;

canceled;

theorem Th38:
  for s1,s2 being State of SCM+FSA holds ((for a being
Int-Location holds s1.a = s2.a) & for f being FinSeq-Location
 holds s1.f = s2.f) iff DataPart s1 = DataPart s2
proof
  let s1,s2 be State of SCM+FSA;
A2: now
    assume that
A3: for a being Int-Location holds s1.a = s2.a and
A4: for f being FinSeq-Location holds s1.f = s2.f;
    hereby
      let x be set;
      assume
A5:   x in Data-Locations SCM+FSA;
      per cases;
      suppose
        x in Int-Locations;
        then x is Int-Location by SCMFSA_2:4;
        hence s1.x = s2.x by A3;
      end;
      suppose
        not x in Int-Locations;
        then x in FinSeq-Locations by A5,SCMFSA_2:100,XBOOLE_0:def 3;
        then x is FinSeq-Location by SCMFSA_2:5;
        hence s1.x = s2.x by A4;
      end;
    end;
  end;
A6: now
    assume
A7: for x being set st x in Data-Locations SCM+FSA holds
    s1.x = s2.x;
    hereby
      let a be Int-Location;
      a in Int-Locations by SCMFSA_2:2;
      then a in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
      hence s1.a = s2.a by A7;
    end;
    hereby
      let f be FinSeq-Location;
      f in FinSeq-Locations by SCMFSA_2:3;
      then f in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
      hence s1.f = s2.f by A7;
    end;
  end;
  dom s2 = Data-Locations SCM+FSA \/ {IC SCM+FSA} by MEMSTR_0:13;
  then
A8: Data-Locations SCM+FSA c= dom s2 by XBOOLE_1:7;
  dom s1 = Data-Locations SCM+FSA \/ {IC SCM+FSA} by MEMSTR_0:13;
  then Data-Locations SCM+FSA c= dom s1 by XBOOLE_1:7;
  hence thesis by A8,A2,A6,FUNCT_1:95;
end;

theorem
  for s1,s2 being State of SCM+FSA, n being Element of NAT, i being
  Instruction of SCM+FSA holds IC s1 + n = IC s2 & DataPart s1 = DataPart s2
  implies IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) & DataPart Exec(i,s1) =
  DataPart Exec(IncAddr(i,n),s2)
proof
  set D = Data-Locations SCM+FSA;
  let s1,s2 be State of SCM+FSA;
  let n be Element of NAT;
  let i be Instruction of SCM+FSA;
  assume that
A1: IC s1 + n = IC s2 and
A2: DataPart s1 = DataPart s2;
  reconsider k1 = IC s1 as Element of NAT;
A3: succ IC s1 + n =  (k1 + 1) + n by NAT_1:38
    .= k1 + n + 1
    .= succ (IC s2) by A1,NAT_1:38;
A4: now
    set I = InsCode i;
    assume that
A5: I < 6 or 8 < I and
A6: I <> 0;
    not(I = 6 or I = 7 or I = 8) by A5;
    then not I in {6,7,8} by ENUMSET1:def 1;
    then
A7: IncAddr(i,n) = i by SCMFSA_4:4;
    not(I = 0 or I = 6 or I = 7 or I = 8) by A5,A6;
    then
A8: not I in {0,6,7,8} by ENUMSET1:def 2;
    then IC Exec(i,s1) = succ IC s1 by Th23;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A3,A8,A7,Th23;
  end;
A12: InsCode i <= 12 by SCMFSA_2:16;
  per cases by A12,NAT_1:36;
  suppose
    InsCode i = 0;
    then
A13: i = halt SCM+FSA by SCMFSA_2:95;
    then Exec(i,s1) = s1 & Exec(i,s2) = s2 by EXTPRO_1:def 3;
    hence thesis by A1,A2,A13,COMPOS_1:11;
  end;
  suppose
A14: InsCode i = 1;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider da, db being Int-Location such that
A15: i = da := db by A14,SCMFSA_2:30;
A16: IncAddr(i,n) = i by A15,COMPOS_1:11;
A17: now
      let c be Int-Location;
      per cases;
      suppose
A18:    c = da;
        hence Exec(i,s1).c = s1.db by A15,SCMFSA_2:63
          .= s2.db by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A15,A16,A18,SCMFSA_2:63;
      end;
      suppose
A19:    c <> da;
        hence Exec(i,s1).c = s1.c by A15,SCMFSA_2:63
          .= s2.c by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A15,A16,A19,SCMFSA_2:63;
      end;
    end;
    now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A15,SCMFSA_2:63
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A15,A16,SCMFSA_2:63;
    end;
    hence thesis by A17,Th38;
  end;
  suppose
A20: InsCode i = 2;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider da, db being Int-Location such that
A21: i = AddTo(da, db) by A20,SCMFSA_2:31;
A22: IncAddr(i,n) = i by A21,COMPOS_1:11;
A23: now
      let c be Int-Location;
      per cases;
      suppose
A24:    c = da;
        s1.da = s2.da & s1.db = s2.db by A2,Th38;
        hence Exec(i,s1).c = s2.da + s2.db by A21,A24,SCMFSA_2:64
          .= Exec(IncAddr(i,n),s2).c by A21,A22,A24,SCMFSA_2:64;
      end;
      suppose
A25:    c <> da;
        hence Exec(i,s1).c = s1.c by A21,SCMFSA_2:64
          .= s2.c by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A21,A22,A25,SCMFSA_2:64;
      end;
    end;
    now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A21,SCMFSA_2:64
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A21,A22,SCMFSA_2:64;
    end;
    hence thesis by A23,Th38;
  end;
  suppose
A26: InsCode i = 3;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider da, db being Int-Location such that
A27: i = SubFrom(da, db) by A26,SCMFSA_2:32;
A28: IncAddr(i,n) = i by A27,COMPOS_1:11;
A29: now
      let c be Int-Location;
      per cases;
      suppose
A30:    c = da;
        s1.da = s2.da & s1.db = s2.db by A2,Th38;
        hence Exec(i,s1).c = s2.da - s2.db by A27,A30,SCMFSA_2:65
          .= Exec(IncAddr(i,n),s2).c by A27,A28,A30,SCMFSA_2:65;
      end;
      suppose
A31:    c <> da;
        hence Exec(i,s1).c = s1.c by A27,SCMFSA_2:65
          .= s2.c by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A27,A28,A31,SCMFSA_2:65;
      end;
    end;
    now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A27,SCMFSA_2:65
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A27,A28,SCMFSA_2:65;
    end;
    hence thesis by A29,Th38;
  end;
  suppose
A32: InsCode i = 4;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider da, db being Int-Location such that
A33: i = MultBy(da, db) by A32,SCMFSA_2:33;
A34: IncAddr(i,n) = i by A33,COMPOS_1:11;
A35: now
      let c be Int-Location;
      per cases;
      suppose
A36:    c = da;
        s1.da = s2.da & s1.db = s2.db by A2,Th38;
        hence Exec(i,s1).c = s2.da * s2.db by A33,A36,SCMFSA_2:66
          .= Exec(IncAddr(i,n),s2).c by A33,A34,A36,SCMFSA_2:66;
      end;
      suppose
A37:    c <> da;
        hence Exec(i,s1).c = s1.c by A33,SCMFSA_2:66
          .= s2.c by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A33,A34,A37,SCMFSA_2:66;
      end;
    end;
    now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A33,SCMFSA_2:66
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A33,A34,SCMFSA_2:66;
    end;
    hence thesis by A35,Th38;
  end;
  suppose
A38: InsCode i = 5;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider da, db being Int-Location such that
A39: i = Divide(da, db) by A38,SCMFSA_2:34;
A40: IncAddr(i,n) = i by A39,COMPOS_1:11;
A41: now
      let c be Int-Location;
      per cases;
      suppose
A42:    c = db;
        s1.da = s2.da & s1.db = s2.db by A2,Th38;
        hence Exec(i,s1).c = s2.da mod s2.db by A39,A42,SCMFSA_2:67
          .= Exec(IncAddr(i,n),s2).c by A39,A40,A42,SCMFSA_2:67;
      end;
      suppose
A43:    c = da & c <> db;
        s1.da = s2.da & s1.db = s2.db by A2,Th38;
        hence Exec(i,s1).c = s2.da div s2.db by A39,A43,SCMFSA_2:67
          .= Exec(IncAddr(i,n),s2).c by A39,A40,A43,SCMFSA_2:67;
      end;
      suppose
A44:    c <> da & c <> db;
        hence Exec(i,s1).c = s1.c by A39,SCMFSA_2:67
          .= s2.c by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A39,A40,A44,SCMFSA_2:67;
      end;
    end;
    now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A39,SCMFSA_2:67
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A39,A40,SCMFSA_2:67;
    end;
    hence thesis by A41,Th38;
  end;
  suppose
    InsCode i = 6;
    then consider loc being Element of NAT such that
A45: i = goto loc by SCMFSA_2:35;
A46: IncAddr(i,n) = goto (loc + n) by A45,SCMFSA_4:1;
A47: now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A45,SCMFSA_2:69
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A46,SCMFSA_2:69;
    end;
    IC Exec(i,s1) = loc by A45,SCMFSA_2:69;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A46,SCMFSA_2:69;
    now
      let c be Int-Location;
      thus Exec(i,s1).c = s1.c by A45,SCMFSA_2:69
        .= s2.c by A2,Th38
        .= Exec(IncAddr(i,n),s2).c by A46,SCMFSA_2:69;
    end;
    hence thesis by A47,Th38;
  end;
  suppose
    InsCode i = 7;
    then consider
    loc being Element of NAT, da being Int-Location
    such that
A48: i = da=0_goto loc by SCMFSA_2:36;
A49: IncAddr(i,n) = da=0_goto (loc + n) by A48,SCMFSA_4:2;
A50: now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A48,SCMFSA_2:70
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A49,SCMFSA_2:70;
    end;
    hereby
      per cases;
      suppose
        s1.da = 0;
        then s2.da = 0 & IC Exec(i,s1) = loc by A2,A48,Th38,SCMFSA_2:70;
        hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A49,SCMFSA_2:70;
      end;
      suppose
        s1.da <> 0;
        then s2.da <> 0 & IC Exec(i,s1) = succ IC s1 by A2,A48,Th38,SCMFSA_2:70
;
        hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A3,A49,
SCMFSA_2:70;
      end;
    end;
    now
      let c be Int-Location;
      thus Exec(i,s1).c = s1.c by A48,SCMFSA_2:70
        .= s2.c by A2,Th38
        .= Exec(IncAddr(i,n),s2).c by A49,SCMFSA_2:70;
    end;
    hence thesis by A50,Th38;
  end;
  suppose
    InsCode i = 8;
    then consider
    loc being Element of NAT, da being Int-Location
    such that
A51: i = da>0_goto loc by SCMFSA_2:37;
A52: IncAddr(i,n) = da>0_goto (loc + n) by A51,SCMFSA_4:3;
A53: now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A51,SCMFSA_2:71
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A52,SCMFSA_2:71;
    end;
    hereby
      per cases;
      suppose
        s1.da > 0;
        then s2.da > 0 & IC Exec(i,s1) = loc by A2,A51,Th38,SCMFSA_2:71;
        hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A52,SCMFSA_2:71;
      end;
      suppose
        s1.da <= 0;
        then s2.da <= 0 & IC Exec(i,s1) = succ IC s1 by A2,A51,Th38,SCMFSA_2:71
;
        hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A3,A52,
SCMFSA_2:71;
      end;
    end;
    now
      let c be Int-Location;
      thus Exec(i,s1).c = s1.c by A51,SCMFSA_2:71
        .= s2.c by A2,Th38
        .= Exec(IncAddr(i,n),s2).c by A52,SCMFSA_2:71;
    end;
    hence thesis by A53,Th38;
  end;
  suppose
A54: InsCode i = 9;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider db, da being Int-Location, f being FinSeq-Location such that
A55: i = da := (f,db) by A54,SCMFSA_2:38;
A56: IncAddr(i,n) = i by A55,COMPOS_1:11;
A57: now
      let c be Int-Location;
      per cases;
      suppose
A58:    c = da;
        then consider m being Element of NAT such that
A59:    m = abs(s1.db) and
A60:    Exec(da:=(f,db), s1).c = (s1.f)/.m by SCMFSA_2:72;
A61:    s1.f = s2.f by A2,Th38;
        consider m2 being Element of NAT such that
A62:    m2 = abs(s2.db) and
A63:    Exec(da:=(f,db), s2).c = (s2.f)/.m2 by A58,SCMFSA_2:72;
        m = m2 by A2,A59,A62,Th38;
        hence Exec(i,s1).c = Exec(IncAddr(i,n),s2).c by A55,A60,A63,A61,
COMPOS_1:11;
      end;
      suppose
A64:    c <> da;
        hence Exec(i,s1).c = s1.c by A55,SCMFSA_2:72
          .= s2.c by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A55,A56,A64,SCMFSA_2:72;
      end;
    end;
    now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A55,SCMFSA_2:72
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A55,A56,SCMFSA_2:72;
    end;
    hence thesis by A57,Th38;
  end;
  suppose
A65: InsCode i = 10;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider db, da being Int-Location, f being FinSeq-Location such that
A66: i = (f,db):=da by A65,SCMFSA_2:39;
A67: IncAddr(i,n) = i by A66,COMPOS_1:11;
A68: now
      let g be FinSeq-Location;
      per cases;
      suppose
A69:    g = f;
A70:    s1.da = s2.da & s1.f = s2.f by A2,Th38;
        consider m2 being Element of NAT such that
A71:    m2 = abs(s2.db) and
A72:    Exec((f,db):=da, s2).f = s2.f+*(m2,s2.da) by SCMFSA_2:73;
        consider m1 being Element of NAT such that
A73:    m1 = abs(s1.db) and
A74:    Exec((f,db):=da, s1).f = s1.f+*(m1,s1.da) by SCMFSA_2:73;
        m1 = m2 by A2,A73,A71,Th38;
        hence Exec(i,s1).g = Exec(IncAddr(i,n),s2).g by A66,A69,A74,A72,A70,
COMPOS_1:11;
      end;
      suppose
A75:    g <> f;
        hence Exec(i,s1).g = s1.g by A66,SCMFSA_2:73
          .= s2.g by A2,Th38
          .= Exec(IncAddr(i,n),s2).g by A66,A67,A75,SCMFSA_2:73;
      end;
    end;
    now
      let c be Int-Location;
      thus Exec(i,s1).c = s1.c by A66,SCMFSA_2:73
        .= s2.c by A2,Th38
        .= Exec(IncAddr(i,n),s2).c by A66,A67,SCMFSA_2:73;
    end;
    hence thesis by A68,Th38;
  end;
  suppose
A76: InsCode i = 11;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider da being Int-Location, f being FinSeq-Location such that
A77: i = da :=len f by A76,SCMFSA_2:40;
A78: IncAddr(i,n) = i by A77,COMPOS_1:11;
A79: now
      let c be Int-Location;
      per cases;
      suppose
A80:    c = da;
        hence Exec(i,s1).c = len(s1.f) by A77,SCMFSA_2:74
          .= len(s2.f) by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A77,A78,A80,SCMFSA_2:74;
      end;
      suppose
A81:    c <> da;
        hence Exec(i,s1).c = s1.c by A77,SCMFSA_2:74
          .= s2.c by A2,Th38
          .= Exec(IncAddr(i,n),s2).c by A77,A78,A81,SCMFSA_2:74;
      end;
    end;
    now
      let f be FinSeq-Location;
      thus Exec(i,s1).f = s1.f by A77,SCMFSA_2:74
        .= s2.f by A2,Th38
        .= Exec(IncAddr(i,n),s2).f by A77,A78,SCMFSA_2:74;
    end;
    hence thesis by A79,Th38;
  end;
  suppose
A82: InsCode i = 12;
    hence IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) by A4;
    consider da being Int-Location, f being FinSeq-Location such that
A83: i = f:=<0,...,0>da by A82,SCMFSA_2:41;
A84: IncAddr(i,n) = i by A83,COMPOS_1:11;
A85: now
      let g be FinSeq-Location;
      per cases;
      suppose
A86:    g = f;
        (ex m1 being Element of NAT st m1 = abs(s1.da) & Exec(f
:=<0,...,0>da, s1).f = m1 |-> 0 )& ex m2 being Element of NAT st m2 = abs(s2.da
        ) & Exec(f :=<0,...,0>da, s2).f = m2 |-> 0 by SCMFSA_2:75;
        hence Exec(i,s1).g = Exec(IncAddr(i,n),s2).g by A2,A83,A84,A86,Th38;
      end;
      suppose
A87:    g <> f;
        hence Exec(i,s1).g = s1.g by A83,SCMFSA_2:75
          .= s2.g by A2,Th38
          .= Exec(IncAddr(i,n),s2).g by A83,A84,A87,SCMFSA_2:75;
      end;
    end;
    now
      let c be Int-Location;
      thus Exec(i,s1).c = s1.c by A83,SCMFSA_2:75
        .= s2.c by A2,Th38
        .= Exec(IncAddr(i,n),s2).c by A83,A84,SCMFSA_2:75;
    end;
    hence thesis by A85,Th38;
  end;
end;

theorem Th43:
  for p being PartState of SCM+FSA holds dom Initialized p = dom p
  \/ {intloc 0} \/ {IC SCM+FSA}
proof let p be PartState of SCM+FSA;
A1: dom q = {intloc 0} & dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    Initialized p = Initialize(p +* q) by FUNCT_4:14;
  hence dom Initialized p = dom (p +* q) \/ dom SA0 by FUNCT_4:def 1
    .= dom p \/ {intloc 0} \/ {IC SCM+FSA} by A1,FUNCT_4:def 1;
end;

registration
  let s be State of SCM+FSA;
  cluster Initialized s -> total;
  coherence;
end;

theorem
  for p being PartState of SCM+FSA holds intloc 0 in dom Initialized p
proof
  let p be PartState of SCM+FSA;
A1: dom q = {intloc 0} & dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
  intloc 0 in {intloc 0} by TARSKI:def 1;
  then
A2: intloc 0 in dom p \/ {intloc 0} by XBOOLE_0:def 3;
    Initialized p = Initialize(p +* q) by FUNCT_4:14;
  then dom Initialized p = dom (p +* q) \/ dom SA0 by FUNCT_4:def 1
    .= dom p \/ {intloc 0} \/ {IC SCM+FSA} by A1,FUNCT_4:def 1;
  hence thesis by A2,XBOOLE_0:def 3;
end;

theorem
  for p being PartState of SCM+FSA holds (Initialized p).intloc 0 =
  1 & (Initialized p).IC SCM+FSA =  0
proof
  let p be PartState of SCM+FSA;
  intloc 0 in {intloc 0} by TARSKI:def 1;
  then
A1: intloc 0 in dom q by FUNCOP_1:13;
A2: Initialized p = Initialize(p +* q) by FUNCT_4:14;
  intloc 0 <> IC SCM+FSA by SCMFSA_2:56;
  then not intloc 0 in {IC SCM+FSA} by TARSKI:def 1;
  then not intloc 0 in dom SA0 by FUNCOP_1:13;
  hence (Initialized p).intloc 0 = (p +* q).intloc 0 by A2,FUNCT_4:11
    .= q.intloc 0 by A1,FUNCT_4:13
    .= 1 by FUNCOP_1:72;
  IC SCM+FSA in {IC SCM+FSA} by TARSKI:def 1;
  then IC SCM+FSA in dom SA0 by FUNCOP_1:13;
  hence (Initialized p).IC SCM+FSA = SA0.IC SCM+FSA by A2,FUNCT_4:13
    .=  0 by FUNCOP_1:72;
end;

theorem
  for I being Program of SCM+FSA holds not intloc 0 in dom I
proof
  let I be Program of SCM+FSA;
 dom I c= NAT by RELAT_1:def 18;
  hence not intloc 0 in dom I by SCMFSA_2:59;
end;

theorem
  for p being PartState of SCM+FSA, a being Int-Location
   st  a <> intloc 0 & not a in dom p
  holds not a in dom Initialized p
proof
  let p be PartState of SCM+FSA;
  let a be Int-Location;
  assume that
A1: a <> intloc 0 and
Z: not a in dom p;
  assume a in dom Initialized p;
  then a in dom p \/ {intloc 0} \/ {IC SCM+FSA} by Th43;
  then
A2: a in (dom p \/ {intloc 0}) or a in {IC SCM+FSA} by XBOOLE_0:def 3;
  per cases by A2,Z,XBOOLE_0:def 3;
  suppose
    a in {intloc 0};
    hence contradiction by A1,TARSKI:def 1;
  end;
  suppose
    a in {IC SCM+FSA};
    then a = IC SCM+FSA by TARSKI:def 1;
    hence contradiction by SCMFSA_2:56;
  end;
end;

theorem
  for p being PartState of SCM+FSA, f being FinSeq-Location
     st not f in dom p
    holds not f in dom Initialized p
proof
  let p be PartState of SCM+FSA;
  let f be FinSeq-Location;
  assume
Z:  not f in dom p;
  assume f in dom Initialized p;
  then f in dom p \/ {intloc 0} \/ {IC SCM+FSA} by Th43;
  then
A1: f in (dom p \/ {intloc 0}) or f in {IC SCM+FSA} by XBOOLE_0:def 3;
  per cases by A1,Z,XBOOLE_0:def 3;
  suppose
    f in {intloc 0};
    then f = intloc 0 by TARSKI:def 1;
    hence contradiction by SCMFSA_2:58;
  end;
  suppose
    f in {IC SCM+FSA};
    then f = IC SCM+FSA by TARSKI:def 1;
    hence contradiction by SCMFSA_2:57;
  end;
end;



begin :: The composition of macroinstructions

definition
  let I,J be Program of SCM+FSA;
  func I ';' J -> Program of SCM+FSA equals
  Directed I +* Reloc(J, card I);
  coherence
  proof
    set P = Directed I +* Reloc(J, card I);
    P is initial
    proof
      set D = {l+card I: l in dom J};
      let m,n be Nat such that
A1:   n in dom(P) and
A2:   m < n;
      dom Directed I = dom I & dom Reloc(J,card I) = D by COMPOS_1:33
,FUNCT_4:99;
      then
A3:   dom(P) = dom I \/ D by FUNCT_4:def 1;
      per cases by A1,A3,XBOOLE_0:def 3;
      suppose
         n in dom I;
        then  m in dom I by A2,AFINSQ_1:def 12;
        hence thesis by A3,XBOOLE_0:def 3;
      end;
      suppose
         n in D;
        then consider l such that
A4:      n = l+card I and
A5:     l in dom J;
        now
          per cases;
          case
            m < card I;
            then  m in dom I by AFINSQ_1:66;
            hence  m in dom(P) by A3,XBOOLE_0:def 3;
          end;
          case
            m >= card I;
            then consider l1 being Nat such that
A6:         m = card I + l1 by NAT_1:10;
            reconsider l1 as Element of NAT by ORDINAL1:def 12;
            l1 < l by A2,A4,A6,XREAL_1:6;
            then l1 in dom J by A5,AFINSQ_1:def 12;
            hence  m in D by A6;
          end;
        end;
        hence thesis by A3,XBOOLE_0:def 3;
      end;
    end;
    hence thesis;
  end;
  correctness;
end;

registration
 let I be Program of SCM+FSA, J be non halt-free Program of SCM+FSA;
  cluster I ';' J -> non halt-free;
  coherence;
end;



theorem
  for I,J being Program of SCM+FSA, l being Element of NAT
   st l in dom I & I.l <> halt SCM+FSA holds (I ';' J).l = I.l
proof
  let I,J be Program of SCM+FSA, l be Element of NAT such
  that
A1: l in dom I and
A2: I.l <> halt SCM+FSA;
A3: dom Reloc(J, card I) = dom Shift(J,card I)
  by COMPOS_1:def 19;
  now
    assume l in dom(Reloc(J, card I));
    then l in { m+card I: m in dom J } by A3,VALUED_1:def 12;
    then consider m such that
A4: l = m+card I and
    m in dom J;
    m + card I < card I by A1,A4,AFINSQ_1:66;
    hence contradiction by NAT_1:11;
  end;
  hence (I ';' J).l = (Directed I).l by FUNCT_4:11
    .= I.l by A2,FUNCT_4:105;
end;

theorem
  for I,J being Program of SCM+FSA holds Directed I c= I ';' J
proof
  let I,J be Program of SCM+FSA;
A1: now
    let x be set;
    assume x in dom Directed I;
    then
A2: x in dom I by FUNCT_4:99;
    dom I misses dom Reloc(J,card I) by COMPOS_1:48;
    then not x in dom Reloc(J,card I) by A2,XBOOLE_0:3;
    hence (Directed I).x = (I ';' J).x by FUNCT_4:11;
  end;
  dom (I ';' J) = dom Directed I \/ dom Reloc(J,card I) by FUNCT_4:def 1;
  then dom Directed I c= dom (I ';' J) by XBOOLE_1:7;
  hence thesis by A1,GRFUNC_1:2;
end;

theorem Th56:
  for I,J being Program of SCM+FSA holds dom I c= dom (I ';' J)
proof
  let I,J be Program of SCM+FSA;
  dom (I ';' J) = dom Directed I \/ dom Reloc(J,card I) by FUNCT_4:def 1
    .= dom I \/ dom Reloc(J,card I) by FUNCT_4:99;
  hence thesis by XBOOLE_1:7;
end;

theorem
  for I,J being Program of SCM+FSA holds I +* (I ';' J) = (I ';' J)
proof
  let I,J be Program of SCM+FSA;
A1: for x be set st x in dom (I ';' J) holds (I +* (I ';' J)).x = (I ';' J).
  x by FUNCT_4:13;
  dom (I +* (I ';' J)) = dom I \/ dom (I ';' J) by FUNCT_4:def 1
    .= dom (I ';' J) by Th56,XBOOLE_1:12;
  hence thesis by A1,FUNCT_1:2;
end;

begin :: The compostion of instruction and macroinstructions

definition
  let i, J;
  func i ';' J -> Program of SCM+FSA equals
  Macro i ';' J;
  correctness;
end;

definition
  let I, j;
  func I ';' j -> Program of SCM+FSA equals
  I ';' Macro j;
  correctness;
end;

definition
  let i,j;
  func i ';' j -> Program of SCM+FSA equals
  Macro i ';' Macro j;
  correctness;
end;



theorem
  i ';' j = Macro i ';' j;

theorem
  i ';' j = i ';' Macro j;

theorem Th61:
  card(I ';' J) = card I + card J
proof
A1: card dom(I ';' J) = card(I ';' J) & card dom I = card I by CARD_1:62;
A2: card dom J = card J by CARD_1:62;
A3: dom(I ';' J) = dom Directed I \/ dom Reloc(J, card I) by FUNCT_4:def 1
    .= dom I \/ dom Reloc(J, card I) by FUNCT_4:99;
  card dom Reloc(J, card I) = card Reloc(J, card I) by CARD_1:62
    .= card J by COMPOS_1:49
    .= card dom J by CARD_1:62;
  hence thesis by A1,A2,A3,CARD_2:40,COMPOS_1:48;
end;

registration
  let P be preProgram of SCM+FSA;
  let l be Element of NAT;
  cluster Directed(P,l) -> halt-free;
  correctness
  proof
     not halt SCM+FSA in rng Directed(P,l) by FUNCT_4:100;
    hence thesis by COMPOS_1:def 3;
  end;
end;

registration
  let P be preProgram of SCM+FSA;
  cluster Directed P -> halt-free;
  correctness;
end;



theorem Th63:
  for I being preProgram of SCM+FSA, l being Element of NAT
   holds I is halt-free implies Directed(I,l) = I
proof
  let I be preProgram of SCM+FSA;
  let l be Element of NAT;
  assume I is halt-free;
  then not halt SCM+FSA in rng I by COMPOS_1:def 3;
  hence thesis by FUNCT_4:103;
end;



theorem Th65:
  for I being preProgram of SCM+FSA, k being Element of NAT holds
  Reloc(Directed I,k) = Directed(Reloc(I,k),(card I + k))
proof
  let I be preProgram of SCM+FSA;
  let k be Element of NAT;
A1: dom Reloc(I,k) = {m + k: m in dom I} by COMPOS_1:33;
A2: dom Directed I = dom I by FUNCT_4:99;
A3: dom Reloc(Directed I,k) = {m + k: m in dom I} by A2,COMPOS_1:33;
A4: now
    let x be set;
    assume
A5: x in {m + k: m in dom I};
    then consider n being Element of NAT such that
A6: x = n + k and
A7: n in dom I;
    dom Directed I = dom I by FUNCT_4:99;
    then reconsider i = (Directed I). n as Instruction of SCM+FSA by A7,
FUNCT_1:106;
    reconsider i0 = I. n as Instruction of SCM+FSA by A7,FUNCT_1:106;
A8: now
      per cases;
      suppose
A9:    i0 = halt SCM+FSA;
        then
A10:    i = goto  card I by A7,FUNCT_4:106;
A11:    (Reloc(I,k)).x
           = IncAddr(i0,k) by A6,A7,COMPOS_1:35
          .= halt SCM+FSA by A9,COMPOS_1:11;
        then (Reloc(I,k)).x in {halt SCM+FSA} by TARSKI:def 1;
        then (Reloc(I,k)).x in dom (halt SCM+FSA .--> goto
         (card I + k)) by FUNCOP_1:13;
        then x in dom ((halt SCM+FSA .--> goto  (card I + k))*
        Reloc(I,k)) by A1,A5,FUNCT_1:11;
        hence (Directed(Reloc(I,k), (card I + k))).x =
((halt SCM+FSA .--> goto  (card I + k))* Reloc(I,k)).x
by FUNCT_4:13
          .= (halt SCM+FSA .--> goto  (card I + k)). ((
        Reloc(I,k)).x) by A1,A5,FUNCT_1:13
          .= goto  (card I + k) by A11,FUNCOP_1:72
          .= IncAddr(i,k) by A10,SCMFSA_4:1;
      end;
      suppose
A12:    i0 <> halt SCM+FSA;
A13:    (Reloc(I,k)).x = IncAddr(i0,k) by A6,A7,COMPOS_1:35;
        InsCode i0 <> 0 by A12,SCMFSA_2:95;
        then IncAddr(i0,k) <> halt SCM+FSA by COMPOS_1:def 17,SCMFSA_2:97;
        then not (Reloc(I,k)).x in {halt SCM+FSA} by A13,TARSKI:def 1;
        then
        not (Reloc(I,k)).x in dom (halt SCM+FSA .--> goto
         (card I + k)) by FUNCOP_1:13;
        then not x in dom ((halt SCM+FSA .--> goto  (card I + k)) *
        Reloc(I,k)) by FUNCT_1:11;
        hence (Directed(Reloc(I,k), (card I + k))).x =
        (Reloc(I,k)).x by FUNCT_4:11
          .= IncAddr(i,k) by A12,A13,FUNCT_4:105;
      end;
    end;
    thus (Reloc(Directed I,k)).x = (Directed(Reloc(I,k), (card I + k))).x
        by A8,A2,A6,A7,COMPOS_1:35;
  end;
  dom Directed(Reloc(I,k), (card I + k)) = {m + k:
  m in dom I} by A1,FUNCT_4:99;
  hence thesis by A3,A4,FUNCT_1:2;
end;

theorem Th66:
  for I,J being Program of SCM+FSA holds Directed (I ';' J) = I
  ';' Directed J
proof
  let I,J be Program of SCM+FSA;
  thus I ';' Directed J = Directed I +* Directed(Reloc(J,card
  I),  (card I + card J)) by Th65
    .= Directed I +* Directed(Reloc(J,card I), card
  (I ';' J)) by Th61
    .= Directed(Directed I, card (I ';' J)) +* Directed(
  Reloc(J,card I), card (I ';' J)) by Th63
    .= Directed (I ';' J) by FUNCT_7:117;
end;

theorem Th67:
  I ';' J ';' K = I ';' (J ';' K)
proof
A1: Reloc(J ';' K, card I)
   = Reloc(Directed J, card I) +* Reloc(Reloc(K, card J), card I)
               by COMPOS_1:42
  .= Reloc(Directed J, card I) +* Reloc(K,card J + card I) by COMPOS_1:43;
  thus I ';' J ';' K
   = (I ';' Directed J) +* Reloc(K, card (I ';' J)) by Th66
  .= Directed I +* (Reloc(Directed J, card I) +*
         Reloc(K, card (I ';' J))) by FUNCT_4:14
  .= I ';' (J ';' K) by A1,Th61;
end;

theorem
  I ';' J ';' k = I ';' (J ';' k) by Th67;

theorem
  I ';' j ';' K = I ';' (j ';' K) by Th67;

theorem
  I ';' j ';' k = I ';' (j ';' k) by Th67;

theorem
  i ';' J ';' K = i ';' (J ';' K) by Th67;

theorem
  i ';' J ';' k = i ';' (J ';' k) by Th67;

theorem
  i ';' j ';' K = i ';' (j ';' K) by Th67;

theorem
  i ';' j ';' k = i ';' (j ';' k) by Th67;

theorem
 card(i ';' J) = card J + 2
 proof
  thus card(i ';' J) = card Macro i + card J by Th61
     .= card J + 2 by COMPOS_1:56;
 end;

theorem
 card(I ';' j) = card I + 2
 proof
  thus card(I ';' j) = card Macro j + card I by Th61
     .= card I + 2 by COMPOS_1:56;
 end;

theorem
 card(i ';' j) = 4
 proof
  thus card(i ';' j) = card Macro i + card Macro j by Th61
     .= card Macro i + 2 by COMPOS_1:56
     .= 2 + 2 by COMPOS_1:56
     .= 4;
 end;

canceled;

theorem  :: from SCMFSA8C
  for s being State of SCM+FSA st s.intloc 0 = 1 & IC s =  0
  holds Initialized s = s
proof
  let s be State of SCM+FSA;
  assume
A1: s.intloc 0 = 1;
  assume
A2: IC s =  0;
A3: IC SCM+FSA in dom s by MEMSTR_0:2;
A4: intloc 0 in dom s by SCMFSA_2:42;
  thus Initialized s = Initialize(s +* ((intloc 0) .--> 1)) by FUNCT_4:14
  .= s +* (IC SCM+FSA .-->  0) by A1,A4,FUNCT_7:109
    .= s by A2,A3,FUNCT_7:109;
end;

theorem
 for p being PartState of SCM+FSA holds
   (Initialized p).intloc 0 = 1
proof
 let p be PartState of SCM+FSA;
A1: ((intloc 0) .--> 1).intloc 0 = 1 by FUNCOP_1:72;
A3: Initialized p = Initialize(p +* ((intloc 0) .--> 1)) by FUNCT_4:14;
 dom ((intloc 0) .--> 1) = {intloc 0} by FUNCOP_1:13;
  then
A5: intloc 0 in dom ((intloc 0) .--> 1) by TARSKI:def 1;
  not intloc 0 in dom SA0 by SCMFSA_2:102;
  hence (Initialized p).intloc 0 = (p+*((intloc 0) .--> 1)).intloc 0
         by A3,FUNCT_4:11
    .= 1 by A5,A1,FUNCT_4:13;
 end;

canceled 2;

theorem
 intloc 0 in dom Initialize ((intloc 0).-->1)
proof
A: dom Initialize ((intloc 0).-->1)
   = dom Start-At(0,SCM+FSA) \/ dom((intloc 0).-->1) by FUNCT_4:def 1;
  dom((intloc 0).-->1) = {intloc 0} by FUNCOP_1:13;
  then intloc 0 in dom((intloc 0).-->1) by TARSKI:def 1;
 hence intloc 0 in dom Initialize ((intloc 0).-->1) by A,XBOOLE_0:def 3;
end;

theorem
  dom Initialize ((intloc 0) .--> 1) = {intloc 0,IC SCM+FSA}
proof
  thus dom( Initialize((intloc 0) .--> 1) )
  =dom ((intloc 0) .--> 1) \/ dom SA0 by FUNCT_4:def 1
    .=dom ((intloc 0) .--> 1) \/ {IC SCM+FSA} by FUNCOP_1:13
    .={intloc 0} \/ {IC SCM+FSA} by FUNCOP_1:13
    .={intloc 0,IC SCM+FSA} by ENUMSET1:1;
end;

theorem
 (Initialize((intloc 0).-->1)).intloc 0 = 1
proof
  not intloc 0 in dom Start-At(0,SCM+FSA) by SCMFSA_2:102;
 hence (Initialize((intloc 0).-->1)).intloc 0
         = ((intloc 0).-->1).intloc 0 by FUNCT_4:11
        .= 1 by FUNCOP_1:72;
end;

theorem
 for p being PartState of SCM+FSA holds
 Initialize((intloc 0).-->1) c= Initialized p by FUNCT_4:25;
