:: Abelian Groups, Fields and Vector Spaces
::  by Eugeniusz Kusak, Wojciech Leo\'nczuk and Micha{\l} Muzalewski
::
:: Received November 23, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies RLVECT_1, BINOP_1, ARYTM_1, FUNCT_1, LATTICES, RELAT_1, ARYTM_3,
      VECTSP_1, ALGSTR_2, REALSET1, GROUP_1;
 notations XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, FUNCT_1, FUNCT_2, BINOP_1,
      BINOP_2, STRUCT_0, RLVECT_1, GROUP_1;
 constructors BINOP_1, BINOP_2, RLVECT_1, MEMBERED, GROUP_1;
 registrations STRUCT_0, RLVECT_1, RELSET_1, MEMBERED, GROUP_1;
 requirements NUMERALS, SUBSET, ARITHM;
 theorems FUNCT_2, RLVECT_1, XCMPLX_0, BINOP_2, GROUP_1;
 schemes FUNCT_2;
 definitions RLVECT_1, STRUCT_0, GROUP_1;

begin
::
::                         1. GROUP STRUCTURE
::

 reserve GS for non empty LoopStr;

 defpred Lm1[Element of REAL,set] means $2 = -$1;

definition
 canceled 5;

 func G_Real -> strict LoopStr equals
   LoopStr (# REAL,addreal,0 #);
  coherence;
end;

registration
 cluster G_Real -> non empty;
 coherence;
end;

registration
 cluster G_Real -> Abelian add-associative right_zeroed right_complementable;
 coherence
  proof
   hereby
    let x,y be Element of G_Real;
     reconsider x'=x ,y'=y as Element of REAL;
    thus x+y = (the add of G_Real).(x,y) by RLVECT_1:5
               .= y'+x' by BINOP_2:def 9
               .= addreal.(y',x') by BINOP_2:def 9
               .= y+x by RLVECT_1:5;
   end;
   hereby
    let x,y,z be Element of G_Real;
     reconsider x'=x ,y'=y , z'=z as Element of REAL;
    thus (x+y)+z = (the add of G_Real).(x+y,z) by RLVECT_1:5
               .= (the add of G_Real).((the add of G_Real).(x,y),z)
                  by RLVECT_1:5
               .= addreal.((x'+y'),z') by BINOP_2:def 9
               .= (x'+y')+z' by BINOP_2:def 9
               .= x'+(y'+z')
               .= addreal.(x',(y'+z')) by BINOP_2:def 9
               .= addreal.(x',addreal.(y',z')) by BINOP_2:def 9
               .= (the add of G_Real).(x,y+z) by RLVECT_1:5
               .= x+(y+z) by RLVECT_1:5;
   end;
   hereby
    let x be Element of G_Real;
     reconsider x'=x as Element of REAL;
    thus x+0.G_Real = (the add of G_Real).(x,0.G_Real) by RLVECT_1:5
         .= x'+0 by BINOP_2:def 9
         .= x;
   end;
   let x be Element of G_Real;
   reconsider x'=x as Element of REAL;
   reconsider y = -x' as Element of G_Real;
   take y;
   thus x+ y = (the add of G_Real).(x,y) by RLVECT_1:5
              .= x'+ -x' by BINOP_2:def 9
              .= 0
              .= 0.G_Real;
  end;
end;

canceled 5;

theorem
    for x,y,z being Element of G_Real holds
            x+y = y+x &
            (x+y)+z = x+(y+z) &
            x+(0.G_Real) = x &
            x+(-x) = 0.G_Real by RLVECT_1:def 6,def 7,def 10;

registration
 cluster strict add-associative right_zeroed right_complementable
   Abelian (non empty LoopStr);
  existence proof take G_Real; thus thesis; end;
end;

definition
 mode AbGroup is add-associative right_zeroed right_complementable
   Abelian (non empty LoopStr);
end;

theorem  (for x,y,z being Element of GS holds
             x+y = y+x &
             (x+y)+z = x+(y+z) &
             x+(0.GS) = x &
             ex x' being Element of GS st x+x' = 0.GS)
     iff GS is AbGroup by RLVECT_1:def 5,def 6,def 7,def 8;

::
::                         4. FIELD STRUCTURE
::

definition
 struct(HGrStr) multLoopStr (# carrier -> set,
                        mult -> BinOp of the carrier,
                        unity -> Element of the carrier #);
end;

registration
 cluster non empty strict multLoopStr;
  existence
   proof
     consider A being non empty set, m being BinOp of A, u being Element of A;
    take multLoopStr(#A,m,u#);
    thus the carrier of multLoopStr(#A,m,u#) is non empty;
    thus thesis;
   end;
end;

definition let FS be multLoopStr;
 canceled 2;

 func 1_ FS -> Element of FS equals
   the unity of FS;
  coherence;
end;

definition
 struct(multLoopStr,ZeroStr) multLoopStr_0 (# carrier -> set,
                        mult -> BinOp of the carrier,
                        unity -> Element of the carrier,
                        Zero -> Element of the carrier #);
end;

registration
 cluster non empty strict multLoopStr_0;
 existence
  proof
    consider A being non empty set,
             m being BinOp of A, u,Z being Element of A;
   take multLoopStr_0(#A,m,u,Z#);
   thus the carrier of multLoopStr_0(#A,m,u,Z#) is non empty;
   thus thesis;
  end;
end;

definition
 struct(LoopStr,multLoopStr_0) doubleLoopStr (# carrier -> set,
                         add, mult -> BinOp of the carrier,
                         unity, Zero -> Element of the carrier #);
end;

registration
 cluster non empty strict doubleLoopStr;
 existence
  proof
    consider A being non empty set,
             m,a being BinOp of A, u,Z being Element of A;
   take doubleLoopStr(#A,m,a,u,Z#);
   thus the carrier of doubleLoopStr(#A,m,a,u,Z#) is non empty;
   thus thesis;
  end;
end;

definition let IT be non empty doubleLoopStr;
 canceled;

 attr IT is right-distributive means :Def11:
   for a, b, c being Element of IT holds a*(b+c) = a*b + a*c;
 attr IT is left-distributive means :Def12:
   for a, b, c being Element of IT holds (b+c)*a = b*a + c*a;
end;

definition let IT be non empty multLoopStr;
 attr IT is right_unital means :Def13:
  for x being Element of IT holds x * 1.IT = x;
end;

definition
 canceled;

 func F_Real -> strict doubleLoopStr equals
  doubleLoopStr (# REAL,addreal,multreal,1,0 #);
  correctness;
end;

definition let IT be non empty doubleLoopStr;
 canceled 2;

 attr IT is distributive means
 :Def18: for x,y,z being Element of IT holds
           x*(y+z) = x*y+x*z & (y+z)*x = y*x+z*x;
end;

definition let IT be non empty multLoopStr;
 attr IT is left_unital means
 :Def19: for x being Element of IT holds 1.IT * x = x;
end;

definition let IT be non empty multLoopStr_0;
 attr IT is Field-like means
 :Def20: for x being Element of IT st x <> 0.IT
     ex y be Element of IT st x*y = 1.IT;
end;

definition let IT be non empty multLoopStr_0;
 attr IT is degenerated means
 :Def21:  0.IT = 1.IT;
end;

registration
 cluster F_Real -> non empty;
 coherence
  proof
    thus the carrier of F_Real is non empty;
  end;
end;

set FR = F_Real;
Lm1: now
  let h, a be Element of FR;
  assume
A1: a = 1;
  reconsider g = h as Element of REAL;
  thus h * a = multreal.(h,a)
  .= g*1 by A1,BINOP_2:def 11
  .= h;
  thus a * h = multreal.(a,h)
  .= 1*g by A1,BINOP_2:def 11
  .= h;
end;

registration
 cluster F_Real -> unital;
 coherence
 proof
   reconsider e = 1 as Element of FR;
   take e;
   thus thesis by Lm1;
 end;
end;

Lm2:
 1.F_Real = 1
proof
  reconsider e = 1 as Element of FR;
  for h being Element of FR holds h * e = h & e * h = h by Lm1;
  hence thesis by GROUP_1:def 5;
end;

registration
 cluster F_Real -> add-associative right_zeroed right_complementable Abelian
   commutative associative left_unital right_unital distributive Field-like
   non degenerated;
 coherence
  proof
   hereby let x,y,z be Element of F_Real;
     reconsider x'=x ,y'=y , z'=z as Element of REAL;
    thus (x+y)+z = (the add of F_Real).(x+y,z) by RLVECT_1:5
               .= (the add of F_Real).((the add of F_Real).(x,y),z)
                  by RLVECT_1:5
               .= addreal.((x'+y'),z') by BINOP_2:def 9
               .= (x'+y')+z' by BINOP_2:def 9
               .= x'+(y'+z')
               .= addreal.(x',(y'+z')) by BINOP_2:def 9
               .= addreal.(x',addreal.(y',z')) by BINOP_2:def 9
               .= (the add of F_Real).(x,y+z) by RLVECT_1:5
               .= x+(y+z) by RLVECT_1:5;
   end;
   hereby let x be Element of F_Real;
     reconsider x'=x as Element of REAL;
   thus x+0.F_Real = (the add of F_Real).(x,0.F_Real) by RLVECT_1:5
               .= x'+0 by BINOP_2:def 9
               .= x;
   end;
   hereby let x be Element of F_Real;
     reconsider x'=x as Element of REAL;
     reconsider y=-x' as Element of F_Real;
     take y' = y;
    thus x+ y' = addreal.(x',y') by RLVECT_1:5
               .= x'+ -x' by BINOP_2:def 9
               .= 0
               .= 0.F_Real;
   end;
   hereby let x,y be Element of F_Real;
     reconsider x'=x ,y'=y as Element of REAL;
    thus x+y = (the add of F_Real).(x,y) by RLVECT_1:5
             .= y'+x' by BINOP_2:def 9
             .= addreal.(y',x') by BINOP_2:def 9
             .= y+x by RLVECT_1:5;
   end;
   hereby let x,y be Element of F_Real;
     reconsider x'=x ,y'=y as Element of REAL;
    thus x*y = (the mult of F_Real).(x,y)
               .= y'*x' by BINOP_2:def 11
               .= multreal.(y',x') by BINOP_2:def 11
               .= y*x;
   end;
   hereby let x,y,z be Element of F_Real;
     reconsider x'=x ,y'=y , z'=z as Element of REAL;
    thus (x*y)*z = (the mult of F_Real).(x*y,z)
               .= multreal.((x'*y'),z') by BINOP_2:def 11
               .= (x'*y')*z' by BINOP_2:def 11
               .= x'*(y'*z')
               .= multreal.(x',(y'*z')) by BINOP_2:def 11
               .= multreal.(x',multreal.(y',z')) by BINOP_2:def 11
               .= x*(y*z);
   end;
   hereby let x be Element of F_Real;
     reconsider x'=x as Element of REAL;
    thus (1.F_Real)*x = (the mult of F_Real).((1.F_Real),x)
               .= 1*x' by Lm2,BINOP_2:def 11
               .= x;
   end;
   hereby let x be Element of F_Real;
     reconsider x'=x as Element of REAL;
    thus x*(1.F_Real) = (the mult of F_Real).(x,(1.F_Real))
               .= 1*x' by Lm2,BINOP_2:def 11
               .= x;
   end;
   hereby let x,y,z be Element of F_Real;
     reconsider x'=x ,y'=y , z'=z as Element of REAL;
    thus x*(y+z) = (the mult of F_Real).(x,(y+z))
               .= (the mult of F_Real).(x,(the add of F_Real).(y,z))
                  by RLVECT_1:5
               .= multreal.(x',(y'+z')) by BINOP_2:def 9
               .= x'*(y'+z') by BINOP_2:def 11
               .= x'*y'+x'*z'
               .= addreal.(x'*y',x'*z') by BINOP_2:def 9
               .= addreal.(multreal.(x',y'),x'*z') by BINOP_2:def 11
               .= addreal.(multreal.(x',y'),multreal.(x',z'))
                  by BINOP_2:def 11
               .= x*y+x*z by RLVECT_1:5;
    thus (y+z)*x = (the mult of F_Real).(y+z,x)
               .= (the mult of F_Real).((the add of F_Real).(y,z),x)
                  by RLVECT_1:5
               .= multreal.((y'+z'),x') by BINOP_2:def 9
               .= (y'+z')*x' by BINOP_2:def 11
               .= y'*x'+z'*x'
               .= addreal.(y'*x',z'*x') by BINOP_2:def 9
               .= addreal.(multreal.(y',x'),z'*x') by BINOP_2:def 11
               .= addreal.(multreal.(y',x'),multreal.(z',x'))
                  by BINOP_2:def 11
               .= y*x+z*x by RLVECT_1:5;
   end;
   hereby let x be Element of F_Real;
     reconsider x'=x as Element of REAL;
    assume x<>0.F_Real;
    then A1: x'*(x')" =1 by XCMPLX_0:def 7;
    reconsider y = (x')" as Element of F_Real;
    take y;
    thus x*y = (the mult of F_Real).(x,y)
            .= 1.F_Real by A1,Lm2,BINOP_2:def 11;
   end;
   thus 0.F_Real <> 1.F_Real by Lm2;
  end;
end;

Lm3: for L being non empty doubleLoopStr st
   L is distributive holds L is right-distributive left-distributive
proof
   let L be non empty doubleLoopStr;
   assume A1:L is distributive;
   then (for a,b,c being Element of L holds a*(b+c) = a*b + a*c)
      by Def18;
   hence L is right-distributive by Def11;
      (for a,b,c being Element of L holds (b+c)*a = b*a + c*a)
      by A1,Def18; hence thesis by Def12;
end;

registration
  cluster distributive -> left-distributive right-distributive
    (non empty doubleLoopStr);
  coherence by Lm3;
  cluster left-distributive right-distributive -> distributive
    (non empty doubleLoopStr);
  coherence
  proof
    let D be non empty doubleLoopStr;
    assume (for a,b,c being Element of D
            holds (b+c)*a = b*a + c*a) &
           for a,b,c being Element of D
            holds a*(b+c) = a*b+ a*c;
    hence for x,y,z be Element of D holds
       x*(y+z) = x*y+x*z & (y+z)*x = y*x+z*x;
  end;
end;

registration
  cluster unital -> left_unital right_unital (non empty multLoopStr);
coherence
proof
  let L be non empty multLoopStr;
  assume
A1: L is unital;
  then consider e being Element of L such that
A2: for h being Element of L holds h * e = h & e * h = h by GROUP_1:def 2;
A3: e = 1.L by A1,A2,GROUP_1:def 5;
  hence for x being Element of L holds 1.L * x = x by A2;
  thus for x being Element of L holds x * 1.L = x by A2,A3;
end;
  cluster left_unital right_unital -> unital (non empty multLoopStr);
coherence
proof
  let L be non empty multLoopStr such that
A4: (for x being Element of L holds 1.L * x = x) &
    for x being Element of L holds x * 1.L = x;
  take 1.L;
  thus thesis by A4;
end;
end;

registration
 cluster commutative associative (non empty HGrStr);
  existence proof take F_Real; thus thesis; end;
end;

registration
 cluster commutative associative unital (non empty multLoopStr);
 existence proof take F_Real; thus thesis; end;
end;

registration
 cluster add-associative right_zeroed right_complementable Abelian
   commutative associative left_unital right_unital distributive Field-like
   non degenerated strict (non empty doubleLoopStr);
  existence proof take F_Real; thus thesis; end;
end;

definition
 mode Field is add-associative right_zeroed right_complementable
    Abelian commutative associative left_unital distributive
      Field-like non degenerated (non empty doubleLoopStr);
end;

canceled 12;

theorem
  1.F_Real = 1 by Lm2;

theorem
  for x,y,z being Element of F_Real holds
  x+y = y+x &
  (x+y)+z = x+(y+z) &
  x+(0.F_Real) = x &
  x+(-x) = 0.F_Real &
  x*y = y*x &
  (x*y)*z = x*(y*z) &
  (1.F_Real)*x = x &
  (x <> 0.F_Real implies ex y be Element of F_Real st x*y = 1.F_Real) &
  x*(y+z) = x*y+x*z & (y+z)*x = y*x+z*x
  by Def18,Def19,Def20,GROUP_1:def 4,RLVECT_1:def 6,def 7,def 10;

theorem
  for FS being non empty doubleLoopStr holds
  (for x,y,z being Element of FS holds
      (x <> 0.FS implies ex y be Element of FS
      st x*y = 1.FS)
       & x*(y+z) = x*y+x*z & (y+z)*x = y*x+z*x ) iff
      FS is distributive Field-like (non empty doubleLoopStr)
       by Def18,Def20;

::
::                        6. AXIOMS OF FIELD
::

canceled 10;

theorem Th33:
 for F being associative commutative left_unital distributive
         Field-like (non empty doubleLoopStr),
     x,y,z being Element of F
  holds (x <> 0.F & x*y = x*z) implies y = z
 proof let F be associative commutative left_unital distributive
       Field-like (non empty doubleLoopStr),
     x,y,z be Element of F;
  assume A1: x<>0.F;
  assume A2: x*y = x*z;
   consider x1 being Element of F such that
   A3:  x*x1 = 1.F by A1,Def20;
       x1*x*y = x1*(x*y) & x1*(x*z) = x1*x*z by GROUP_1:def 4;
    then x*x1*y = z by A2,A3,Def19;
   hence thesis by A3,Def19;
  end;

definition let F be associative commutative left_unital distributive
    Field-like (non empty doubleLoopStr),
   x be Element of F;
 assume A1: x <> 0.F;
 func x" -> Element of F means
 :Def22:  x*it = 1.F;
  existence by A1,Def20;
  uniqueness by A1,Th33;
end;

definition let F be associative commutative left_unital distributive
    Field-like (non empty doubleLoopStr),
   x,y be Element of F;
 func x/y ->Element of F equals
     x*y";
  coherence;
end;

canceled 2;

theorem Th36:
 for F being add-associative right_zeroed right_complementable
             right-distributive (non empty doubleLoopStr),
     x being Element of F
  holds x*(0.F) = 0.F
 proof
  let F be add-associative right_zeroed right_complementable
           right-distributive (non empty doubleLoopStr);
  let x be Element of F;
     x*(0.F)+(0.F) = x*((0.F)+(0.F))+(0.F) by RLVECT_1:10
               .= x*((0.F)+(0.F)) by RLVECT_1:10
               .= x*(0.F)+x*(0.F) by Def11;
  hence x*(0.F) = 0.F by RLVECT_1:21;
 end;

canceled 2;

theorem Th39:
 for F being add-associative right_zeroed right_complementable
             left-distributive (non empty doubleLoopStr),
     x being Element of F
  holds (0.F)*x = 0.F
 proof
  let F be add-associative right_zeroed right_complementable
           left-distributive (non empty doubleLoopStr);
  let x be Element of F;
      (0.F)*x+(0.F) = ((0.F)+(0.F))*x+(0.F) by RLVECT_1:10
               .= ((0.F)+(0.F))*x by RLVECT_1:10
               .= (0.F)*x+(0.F)*x by Def12;
  hence 0.F = (0.F)*x by RLVECT_1:21;
 end;

theorem Th40:
 for F be add-associative right_zeroed right_complementable
          right-distributive (non empty doubleLoopStr),
     x,y being Element of F
  holds x*(-y) = -x*y
proof
  let F be add-associative right_zeroed right_complementable
           right-distributive (non empty doubleLoopStr),
     x,y be Element of F;
    x*y +x*(-y) = x*(y+(-y)) by Def11
            .= x*(0.F) by RLVECT_1:def 10
            .= 0.F by Th36;
 hence x*(-y) = -x*y by RLVECT_1:def 10;
end;

theorem Th41:
 for F be add-associative right_zeroed right_complementable
          left-distributive (non empty doubleLoopStr),
     x,y being Element of F
  holds (-x)*y = -x*y
proof
  let F be add-associative right_zeroed right_complementable
           left-distributive (non empty doubleLoopStr),
     x,y be Element of F;
    x*y +(-x)*y = (x+(-x))*y by Def12
            .= (0.F)*y by RLVECT_1:def 10
            .= 0.F by Th39;
 hence (-x)*y = -x*y by RLVECT_1:def 10;
end;

theorem Th42:
 for F be add-associative right_zeroed right_complementable
          distributive (non empty doubleLoopStr),
     x,y being Element of F
  holds (-x)*(-y) = x*y
proof
  let F be add-associative right_zeroed right_complementable
           distributive (non empty doubleLoopStr),
     x,y be Element of F;
 thus (-x)*(-y) = -x*(-y) by Th41
          .= --x*y by Th40
          .= x*y by RLVECT_1:30;
end;

theorem
    for F be add-associative right_zeroed right_complementable
          right-distributive (non empty doubleLoopStr),
     x,y,z being Element of F holds
 x*(y-z) = x*y - x*z
proof
let F be add-associative right_zeroed right_complementable
          right-distributive (non empty doubleLoopStr),
     x,y,z be Element of F;
    x*(y-z) = x*(y+(-z))
          .= x*y+x*(-z) by Def11
          .= x*y+(-x*z) by Th40
          .= x*y - x*z;
 hence thesis;
end;

theorem Th44:
 for F being add-associative right_zeroed right_complementable
             associative commutative left_unital Field-like
             distributive (non empty doubleLoopStr),
     x,y being Element of F holds
 x*y=0.F iff x=0.F or y=0.F
proof
 let F be add-associative right_zeroed right_complementable
          associative commutative left_unital Field-like distributive
          (non empty doubleLoopStr),
     x,y be Element of F;
    x*y=0.F implies x=0.F or y=0.F
 proof
  assume A1: x*y = 0.F;
  assume A2: x<>0.F;
  x"*(0.F) = x"*x*y by A1,GROUP_1:def 4
     .= (1.F)*y by A2,Def22
     .= y by Def19;
  hence thesis by Th39;
 end;
 hence thesis by Th39;
end;

theorem
   for K being add-associative right_zeroed right_complementable
            left-distributive (non empty doubleLoopStr)
for a,b,c be Element of K holds (a-b)*c =a*c -b*c
 proof
  let K be add-associative right_zeroed right_complementable
             left-distributive (non empty doubleLoopStr);
  let y,z,x be Element of K;
  thus (y-z)*x = (y+-z )*x
   .= y*x+(-z)*x by Def12
   .= y*x+-z*x by Th41
   .= y*x -z*x;
 end;

::
::                      8. VECTOR SPACE STRUCTURE
::

definition let F be 1-sorted;
 struct(LoopStr) VectSpStr over F (#
                   carrier -> set,
                    add -> BinOp of the carrier,
                    Zero -> Element of the carrier,
                   lmult -> Function of [:the carrier of F,the carrier:],
                                      the carrier #);
end;

registration let F be 1-sorted;
 cluster non empty strict VectSpStr over F;
  existence
   proof
     consider A being non empty set,
              a being BinOp of A,
              Z being Element of A,
              l being Function of [:the carrier of F,A:], A;
    take VectSpStr(#A,a,Z,l#);
    thus the carrier of VectSpStr(#A,a,Z,l#) is non empty;
    thus thesis;
   end;
end;

registration let F be 1-sorted;
  let A be non empty set,
      a be BinOp of A, Z be Element of A,
      l be Function of [:the carrier of F,A:], A;
 cluster VectSpStr(#A,a,Z,l#) -> non empty;
  coherence
   proof
    thus the carrier of VectSpStr(#A,a,Z,l#) is non empty;
   end;
end;

definition let F be 1-sorted;
 mode Scalar of F is Element of F;
end;

definition let F be 1-sorted;
           let VS be VectSpStr over F;
 mode Scalar of VS is Scalar of F;
 mode Vector of VS is Element of VS;
end;

definition let F be non empty 1-sorted, V be non empty VectSpStr over F;
  let x be Element of F;
  let v be Element of V;
 func x*v -> Element of V equals
  (the lmult of V).(x,v);
  coherence;
end;

definition let F be non empty LoopStr;
 func comp F -> UnOp of the carrier of F means
     for x being Element of F holds it.x = -x;
existence
 proof
  deffunc F(Element of F) = -$1;
   thus ex f being UnOp of the carrier of F st
    for x being Element of F holds f.x = F(x) from FUNCT_2:sch 4;
 end;
uniqueness
  proof
    let f, g be UnOp of the carrier of F such that
A1:  for x being Element of F holds f.x = -x and
A2:  for x being Element of F holds g.x = -x;
       now let x be set;
      assume x in the carrier of F;
      then reconsider y = x as Element of F;
     thus f.x = -y by A1
        .= g.x by A2;
    end;
    hence thesis by FUNCT_2:18;
  end;
end;

Lm4:
 now let F be add-associative right_zeroed right_complementable Abelian
   associative left_unital distributive (non empty doubleLoopStr);
  let MLT be
   Function of [:the carrier of F,the carrier of F:],the carrier of F;
  set GF = VectSpStr
  (# the carrier of F,the add of F,the Zero of F,MLT #);
       for x,y,z being Element of GF holds
            x+y = y+x &
            (x+y)+z = x+(y+z) &
            x+(0.GF) = x &
            ex x' being Element of GF st x+x' = 0.GF
      proof
       let x,y,z be Element of GF;
       reconsider x'=x,y'=y,z'=z as Element of F;
       thus x+y = (the add of GF).(x,y) by RLVECT_1:5
                  .= y'+x' by RLVECT_1:5
                  .= (the add of F).(y',x') by RLVECT_1:5
                  .= y+x by RLVECT_1:5;
       thus (x+y)+z = (the add of GF).(x+y,z) by RLVECT_1:5
                  .= (the add of GF).((the add of GF).(x,y),z)
                     by RLVECT_1:5
                  .= (the add of F).((x'+y'),z') by RLVECT_1:5
                  .= (x'+y')+z' by RLVECT_1:5
                  .= x'+(y'+z') by RLVECT_1:def 6
                  .= (the add of F).(x',(y'+z')) by RLVECT_1:5
                  .= (the add of F).(x',(the add of F).(y',z'))
                     by RLVECT_1:5
                  .= (the add of GF).(x,y+z) by RLVECT_1:5
                  .= x+(y+z) by RLVECT_1:5;
       thus x+0.GF = (the add of GF).(x,0.GF) by RLVECT_1:5
                  .= x'+(0.F) by RLVECT_1:5
                  .= x by RLVECT_1:10;
       consider t being Element of F such that
A1:     x' + t = 0.F by RLVECT_1:def 8;
       reconsider t' = t as Element of GF;
       take t';
       thus x + t' = (the add of GF).(x,t') by RLVECT_1:5
                 .= x'+ t by RLVECT_1:5
                 .= 0.GF by A1;
      end;
  hence GF is AbGroup by RLVECT_1:def 5,def 6,def 7,def 8;
 end;

Lm5:
 now let F be add-associative right_zeroed right_complementable
   associative left_unital distributive (non empty doubleLoopStr);
  let MLT be
    Function of [:the carrier of F,the carrier of F:],the carrier of F
 such that
A1: MLT = the mult of F;
  set LS = VectSpStr (# the carrier of F,the add of F,the Zero of F,
    MLT #);
   let x,y be Element of F;
   let v,w be Element of LS;
   reconsider v' = v , w' = w as Element of F;
  thus x*(v+w) = (the lmult of LS).(x,(v+w))
          .= MLT.(x,(the add of F).(v',w')) by RLVECT_1:5
          .= MLT.(x,v'+w') by RLVECT_1:5
          .= x*(v'+w') by A1
          .= x*v'+x*w' by Def18
          .= (the add of F).(x*v',x*w') by RLVECT_1:5
          .= (the add of F).(MLT.(x,v'),x*w') by A1
          .= (the add of F).
             ((the lmult of LS).(x,v),(the lmult of LS).(x,w))
             by A1
          .= x*v+x*w by RLVECT_1:5;
  thus (x+y)*v = (the lmult of LS).((x+y),v)
          .= (x+y)*v' by A1
          .= x*v'+y*v' by Def18
          .= (the add of F).(x*v',y*v') by RLVECT_1:5
          .= (the add of F).(MLT.(x,v'),y*v') by A1
          .= (the add of F).
             ((the lmult of LS).(x,v),(the lmult of LS).(y,v))
             by A1
          .= x*v+y*v by RLVECT_1:5;
  thus (x*y)*v = (the lmult of LS).((x*y),v)
          .= (x*y)*v' by A1
          .= x*(y*v') by GROUP_1:def 4
          .= MLT.(x,y*v') by A1
          .= x*(y*v) by A1;
  thus (1.F)*v = MLT.(1.F,v')
          .= (1.F)*v' by A1
          .= v by Def19;
 end;

definition let F be non empty doubleLoopStr;
 let IT be non empty VectSpStr over F;
 attr IT is VectSp-like means
:Def26: for x,y being Element of F
         for v,w being Element of IT holds
               x*(v+w) = x*v+x*w &
               (x+y)*v = x*v+y*v &
               (x*y)*v = x*(y*v) &
               (1.F)*v = v;
end;

registration let F be add-associative right_zeroed right_complementable Abelian
   associative left_unital distributive (non empty doubleLoopStr);
 cluster VectSp-like add-associative right_zeroed right_complementable Abelian
   strict (non empty VectSpStr over F);
  existence
  proof
    take V = VectSpStr (# the carrier of F,the add of F,
                         the Zero of F,the mult of F#);
    thus for x,y being Element of F
    for v,w being Element of V holds
     x*(v+w) = x*v+x*w &
     (x+y)*v = x*v+y*v &
     (x*y)*v = x*(y*v) &
     (1.F)*v = v by Lm5;
   thus thesis by Lm4;
  end;
end;

definition let F be add-associative right_zeroed right_complementable Abelian
   associative left_unital distributive (non empty doubleLoopStr);
 mode VectSp of F is VectSp-like
  add-associative right_zeroed right_complementable Abelian
   (non empty VectSpStr over F);
end;

 reserve F for Field,
         x for Element of F,
         V for VectSp-like add-associative right_zeroed right_complementable
           (non empty VectSpStr over F),
         v for Element of V;

canceled 13;

theorem Th59:
 for F being add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr),
     x being Element of F
 for V being add-associative right_zeroed
             right_complementable VectSp-like (non empty VectSpStr over F),
     v being Element of V
 holds (0.F)*v = 0.V & (-1.F)*v = -v & x*(0.V) = 0.V
proof
 let F be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr);
 let x be Element of F;
 let V be add-associative right_zeroed
          right_complementable VectSp-like (non empty VectSpStr over F),
     v be Element of V;
    v+(0.F)*v = (1.F)*v + (0.F)*v by Def26
       .= ((1.F)+(0.F))*v by Def26
       .= (1.F)*v by RLVECT_1:10
       .= v by Def26
       .= v+0.V by RLVECT_1:10;
 hence A1: (0.F)*v = 0.V by RLVECT_1:21;
    (-(1.F))*v+v = (-(1.F))*v + (1.F)*v by Def26
       .= ((1.F)+(-(1.F)))*v by Def26
       .= 0.V by A1,RLVECT_1:def 10;
  then (-(1.F))*v + (v+(-v)) = 0.V + -v by RLVECT_1:def 6;
  then 0.V + -v = (-(1.F))*v + 0.V by RLVECT_1:16
            .= (-(1.F))*v by RLVECT_1:10;
 hence (-1.F)*v = -v by RLVECT_1:10;
    x*(0.V) = (x*(0.F))*v by A1,Def26
       .= 0.V by A1,Th36;
 hence thesis;
end;

theorem
    x*v = 0.V iff x = 0.F or v = 0.V
proof
    x*v = 0.V implies x = 0.F or v = 0.V
 proof
  assume A1: x*v = 0.V;
  assume A2: x<>(0.F);
      x"*x*v = x"*(0.V) by A1,Def26
              .= 0.V by Th59;
   then 0.V = (1.F)*v by A2,Def22;
  hence thesis by Def26;
 end;
hence thesis by Th59;
end;

::
::                          13. APPENDIX
::

canceled 2;

theorem
    for V being add-associative right_zeroed
              right_complementable (non empty LoopStr),
     v,w being Element of V holds
   v+w=0.V iff -v=w
proof let V be add-associative right_zeroed
                    right_complementable (non empty LoopStr),
   v,w be Element of V;
     v+w=0.V implies -v=w
   proof
    assume
A1:   v+w=0.V;
    thus w = 0.V + w by RLVECT_1:10
          .= -v + v + w by RLVECT_1:16
          .= -v + 0.V by A1,RLVECT_1:def 6
          .= -v by RLVECT_1:10;
   end;
  hence thesis by RLVECT_1:16;
 end;

Lm6:
for V being add-associative right_zeroed
                     right_complementable (non empty LoopStr),
    v,w being Element of V
holds -(w+-v)=v-w
 proof let V be add-associative right_zeroed
                  right_complementable (non empty LoopStr),
    v,w be Element of V;
       -(w+-v)=-(-v)-w by RLVECT_1:44;
    hence thesis by RLVECT_1:30;
 end;

Lm7:
for V being add-associative right_zeroed
                     right_complementable (non empty LoopStr),
  v,w being Element of V holds -(-v-w)=w+v
 proof let V be add-associative right_zeroed
                      right_complementable (non empty LoopStr),
    v,w be Element of V;
     -(-v-w)=w+-(-v) by RLVECT_1:47;
  hence thesis by RLVECT_1:30;
 end;

theorem
    for V being add-associative right_zeroed
                    right_complementable (non empty LoopStr),
    u,v,w being Element of V holds
  -(v+w)=-w-v & -(w+-v)=v-w & -(v-w)=w+-v & -(-v-w)=w+v &
      u-(w+v)=u-v-w by Lm6,Lm7,RLVECT_1:41,44,47;

theorem
    for V being add-associative right_zeroed
                     right_complementable (non empty LoopStr),
     v being Element of V holds
  0.V-v=-v & v-0.V=v by RLVECT_1:26,27;

theorem Th66:
 for F being add-associative right_zeroed
                   right_complementable (non empty LoopStr),
     x,y being Element of F holds
  (x+(-y)=0.F iff x=y) & (x-y=0.F iff x=y)
 proof let F be add-associative right_zeroed
                right_complementable (non empty LoopStr),
    x,y be Element of F;
       x+(-y)=0.F iff x=y
     proof
          x+(-y)=0.F implies x=y
       proof
        assume x+(-y)=0.F;
        then x+((-y)+y)=0.F+y by RLVECT_1:def 6;
        then x+0.F=0.F+y by RLVECT_1:16;
        then x=0.F+y by RLVECT_1:10;
        hence thesis by RLVECT_1:10;
       end;
      hence thesis by RLVECT_1:16;
     end;
   hence thesis;
 end;

theorem
    x<>0.F implies x"*(x*v)=v
 proof
  assume A1: x<>0.F;
     x"*(x*v)=(x"*x)*v by Def26
         .=1.F*v by A1,Def22
         .=v by Def26;
  hence thesis;
 end;

theorem Th68:
 for F be add-associative right_zeroed right_complementable Abelian
          associative left_unital distributive (non empty doubleLoopStr),
     V be VectSp-like add-associative right_zeroed right_complementable
        (non empty VectSpStr over F),
     x being Element of F,
     v,w being Element of V holds
  -x*v=(-x)*v & w-x*v=w+(-x)*v
 proof
  let F be add-associative right_zeroed right_complementable Abelian
          associative left_unital distributive (non empty doubleLoopStr),
     V be VectSp-like add-associative right_zeroed right_complementable
       (non empty VectSpStr over F),
     x be Element of F,
     v,w be Element of V;
        -x*v=(-1.F)*(x*v) by Th59
        .=((-1.F)*x)*v by Def26
        .=(-(1.F*x))*v by Th41;
    hence -x*v=(-x)*v by Def19;
    hence thesis;
 end;

registration
  cluster commutative left_unital -> right_unital (non empty multLoopStr);
  coherence
  proof let F be non empty multLoopStr;
   assume
A1:  F is commutative left_unital;
   let x be Scalar of F;
      for F be commutative (non empty HGrStr),
    x,y being Element of F holds x*y = y*x;
    then x*(1.F) = (1.F)*x by A1;
   hence x*(1.F) = x by A1,Def19;
  end;
end;

theorem Th69:
 for F be add-associative right_zeroed right_complementable Abelian
         associative left_unital right_unital distributive
         (non empty doubleLoopStr),
     V be VectSp-like add-associative right_zeroed right_complementable
        (non empty VectSpStr over F),
     x being Element of F,
     v being Element of V holds
  x*(-v)=-x*v
  proof
  let F be add-associative right_zeroed right_complementable Abelian
         associative left_unital right_unital distributive
         (non empty doubleLoopStr),
     V be VectSp-like add-associative right_zeroed right_complementable
        (non empty VectSpStr over F),
     x be Element of F,
     v be Element of V;
      x*(-v)=x*((-1.F)*v) by Th59
        .=(x*(-1.F))*v by Def26
        .=(-(x*1.F))*v by Th40
        .=(-x)*v by Def13;
   hence thesis by Th68;
  end;

theorem
    for F be add-associative right_zeroed right_complementable Abelian
         associative left_unital right_unital distributive
         (non empty doubleLoopStr),
     V be VectSp-like add-associative right_zeroed right_complementable
        (non empty VectSpStr over F),
     x being Element of F,
     v,w being Element of V holds
  x*(v-w)=x*v-x*w
  proof
  let F be add-associative right_zeroed right_complementable Abelian
       associative left_unital right_unital distributive
       (non empty doubleLoopStr),
     V be VectSp-like add-associative right_zeroed right_complementable
        (non empty VectSpStr over F),
     x be Element of F,
     v,w be Element of V;
      x*(v-w)=x*(v+(-w))
         .=x*v+x*(-w) by Def26
         .=x*v+(-x*w) by Th69;
   hence thesis;
  end;

canceled 2;

theorem
    for F being add-associative right_zeroed right_complementable
             commutative associative left_unital non degenerated
             Field-like distributive (non empty doubleLoopStr),
     x being Element of F holds
 x <> 0.F implies (x")" = x
  proof
 let F be add-associative right_zeroed right_complementable commutative
             associative left_unital non degenerated
             Field-like distributive (non empty doubleLoopStr),
     x be Element of F;
   A1: x <> 0.F implies x" <> 0.F
    proof
     assume A2: x <> 0.F;
     assume not thesis;
     then 1.F = x*0.F by A2,Def22;
     then 1.F = 0.F by Th39;
     hence contradiction by Def21;
    end;
   assume A3: x <> 0.F;
   then x"*(x")" = 1.F by A1,Def22;
   then (x*x")*(x")" = x*1.F by GROUP_1:def 4;
   then 1.F*(x")" = x*1.F by A3,Def22;
   then (x")" = 1.F*x by Def19;
   hence thesis by Def19;
  end;

theorem
    for F being Field,
     x being Element of F holds
 x <> 0.F implies x" <> 0.F & -x" <> 0.F
  proof
 let F be Field,
     x be Element of F;
   assume A1: x <> 0.F; assume A2: not thesis;
   A3: now assume x" = 0.F;
    then 1.F = x*0.F by A1,Def22;
    then 1.F = 0.F by Th39;
    hence contradiction by Def21;
   end;
      now assume -x" = 0.F;
    then 1.F*x" = (-1.F)*0.F by Th42;
    then 1.F*x" = 0.F by Th39;
    then x*x" = x*0.F by Def19;
    then 1.F = x*0.F by A1,Def22;
    then 1.F = 0.F by Th39;
    hence contradiction by Def21;
   end;
  hence contradiction by A2,A3;
 end;

canceled 3;

theorem
Th78: 1.F_Real + 1.F_Real <> 0.F_Real
 proof
  1.FR+1.FR=1+1
   proof
    reconsider t=1 as Element of REAL;
    reconsider t as Element of FR;
    1.FR+1.FR=(the add of FR).(t,t) by Lm2,RLVECT_1:5;
    hence thesis by BINOP_2:def 9;
   end;
  hence thesis;
 end;

definition
 let IT be non empty LoopStr;
 canceled;

 attr IT is Fanoian means
:Def28: for a being Element of IT st a + a = 0.IT
   holds a = 0.IT;
end;

registration
 cluster Fanoian (non empty LoopStr);
 existence
  proof
   take F = F_Real;
   let a be Element of F such that
A1: a + a = 0.F;
       a = 1.F * a by Def19;
    then a + a = (1.F + 1.F) * a by Def18;
   hence a = 0.F by A1,Th44,Th78;
  end;
end;

definition let F be add-associative right_zeroed right_complementable
             commutative associative left_unital Field-like
             non degenerated distributive (non empty doubleLoopStr);
 redefine attr F is Fanoian means
:Def29:  1.F+1.F<>0.F;
 compatibility
  proof
       0.F <> 1.F by Def21;
   hence F is Fanoian implies 1.F+1.F<>0.F by Def28;
   assume
A1: 1.F+1.F<>0.F;
   let a be Element of F such that
A2: a + a = 0.F;
       a = 1.F * a by Def19;
    then a + a = (1.F + 1.F) * a by Def18;
   hence a = 0.F by A1,A2,Th44;
  end;
end;

registration
 cluster strict Fanoian Field;
  existence
   proof
       F_Real is Fanoian by Def29,Th78;
    hence thesis;
   end;
end;

canceled 2;

theorem Th81:
 for F being add-associative right_zeroed
                 right_complementable (non empty LoopStr),
     a, b being Element of F holds
  -(a-b) = b-a by RLVECT_1:47;

canceled 2;

theorem
    for F being add-associative right_zeroed
                   right_complementable (non empty LoopStr),
     a,b being Element of F holds
 a - b = 0.F implies a = b by Th66;

canceled;

theorem Th86:
 for F being add-associative right_zeroed
                      right_complementable (non empty LoopStr),
     a being Element of F holds
  -a = 0.F implies a = 0.F
 proof let F be add-associative right_zeroed
                       right_complementable (non empty LoopStr),
   a be Element of F;
     --a = a by RLVECT_1:30; hence thesis by RLVECT_1:25;
 end;

theorem
    for F being add-associative right_zeroed
                     right_complementable (non empty LoopStr),
     a, b being Element of F holds
   a - b = 0.F implies b - a = 0.F
 proof let F be add-associative right_zeroed
                      right_complementable (non empty LoopStr),
    a,b be Element of F;
     a - b = -(b - a) by Th81; hence thesis by Th86;
 end;

theorem
    for a, b, c being Element of F holds
 (a <> 0.F & a*c - b = 0.F implies c = b*a") &
       (a <> 0.F & b - c*a = 0.F implies c = b*a")
 proof
  let a, b, c be Element of F;
  thus
A1:  a <> 0.F & a*c - b = 0.F implies c = b*a"
  proof
   assume A2: a <> 0.F;
   assume a*c - b = 0.F;
   then a"*(a*c) = b*a" by RLVECT_1:35;
   then (a"*a)*c = b*a" & a"*a = 1.F & c*(1.F) =(1.F)*c
   by A2,Def22,GROUP_1:def 4;
   hence c = b*a" by Def19;
  end;
  assume A3: a <> 0.F;
  assume b - c*a = 0.F;
then A4:  -(b - c*a) = 0.F by RLVECT_1:25;
     a*c - b = c*a + (- b)
    .= 0.F by A4,RLVECT_1:47;
  hence thesis by A1,A3;
 end;

theorem
    for F being add-associative right_zeroed
                          right_complementable (non empty LoopStr),
     a, b being Element of F holds
  a + b = -(-b + -a)
 proof let F be add-associative right_zeroed
                         right_complementable (non empty LoopStr),
   a,b be Element of F;
  thus a + b = --(a + b) by RLVECT_1:30 .= -(-b + -a) by RLVECT_1:45;
 end;

theorem
    for F being add-associative right_zeroed
                     right_complementable (non empty LoopStr),
     a, b, c being Element of F holds
  (b+a)-(c+a) = b-c
 proof let F be add-associative right_zeroed
                     right_complementable (non empty LoopStr),
    a,b,c be Element of F;
    thus (b+a)-(c+a) = (b+a)+-(c+a)
                    .= (b+a)+(-a+-c) by RLVECT_1:45
                    .= ((b+a)+-a)+-c by RLVECT_1:def 6
                    .= (b+(a+-a))+-c by RLVECT_1:def 6
                    .= (b+0.F)+-c by RLVECT_1:16
                    .= b+-c by RLVECT_1:10
                    .= b-c;
 end;

canceled;

theorem
  for G being add-associative right_zeroed right_complementable
                        (non empty LoopStr),
      v,w being Element of G holds
  -(-v+w) = -w+v
proof
  let G be add-associative right_zeroed right_complementable
                        (non empty LoopStr),
      v,w be Element of G;
  thus -(-v+w) = -w + --v by RLVECT_1:45
              .= -w + v by RLVECT_1:30;
end;

theorem
  for G being Abelian add-associative (non empty LoopStr),
      u,v,w being Element of G holds
   u - v - w = u - w - v
proof
  let G be Abelian add-associative (non empty LoopStr),
      u,v,w be Element of G;
  thus u - v - w = u + -v - w
                .= u + -v + -w
                .= u + -w + -v by RLVECT_1:def 6
                .= u - w - v;
 end;

theorem
  for B being AbGroup holds
  HGrStr (# the carrier of B, the add of B #) is commutative Group
  proof let B be AbGroup;
    set G = HGrStr (# the carrier of B, the add of B #);
    A1: for a,b be Element of G,
       x,y be Element of B st a = x & b = y
     holds a * b = x + y by RLVECT_1:5;
    A2: G is associative Group-like
     proof
      thus for a,b,c being Element of G
        holds a * b * c = a * (b * c)
       proof let a,b,c be Element of G;
         reconsider x = a, y = b, z = c as Element of B;
          A3: a * b = x + y & b * c = y + z by A1;
        hence a * b * c = x + y + z by A1
                      .= x + (y + z) by RLVECT_1:def 6
                      .= a * (b * c) by A1,A3;
       end;
       reconsider e = 0.B as Element of G;
      take e;
      let a be Element of G;
       reconsider x = a as Element of B;
      thus a * e = x + 0.B by A1
                .= a by RLVECT_1:10;
      thus e * a = x + 0.B by A1
                .= a by RLVECT_1:10;
       reconsider b = - x as Element of G;
      take b;
      thus a * b = x + (- x) by A1
                .= e by RLVECT_1:16;
      thus b * a = x + (- x) by A1
                .= e by RLVECT_1:16;
     end;
       now let a,b be Element of G;
      reconsider x = a, y = b as Element of B;
     thus a * b = y + x by A1
               .= b * a by A1;
    end;
   hence thesis by A2,GROUP_1:def 16;
  end;
