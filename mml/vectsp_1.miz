:: Abelian Groups, Fields and Vector Spaces
::  by Eugeniusz Kusak, Wojciech Leo\'nczuk and Micha{\l} Muzalewski
::
:: Received November 23, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies RLVECT_1, BINOP_1, ARYTM_1, FUNCT_1, LATTICES, RELAT_1, ARYTM_3,
      VECTSP_1, ALGSTR_2, REALSET1, GROUP_1, ARYTM, VECTSP_2, STRUCT_0,
      ALGSTR_0, BOOLE;
 notations XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, FUNCT_1, FUNCT_2, BINOP_1,
      ORDINAL1, XCMPLX_0, XXREAL_0, XREAL_0, NAT_D, BINARITH, BINOP_2,
      STRUCT_0, ALGSTR_0, RLVECT_1, GROUP_1;
 constructors BINOP_1, XXREAL_0, NAT_1, BINARITH, RLVECT_1, GROUP_1, BINOP_2,
      NAT_D;
 registrations ORDINAL1, RELSET_1, NUMBERS, XREAL_0, STRUCT_0, GROUP_1,
      ALGSTR_0;
 requirements NUMERALS, SUBSET, ARITHM, BOOLE;
 definitions RLVECT_1, STRUCT_0, GROUP_1, ALGSTR_0;
 theorems FUNCT_2, RLVECT_1, XCMPLX_0, BINOP_2, GROUP_1, NAT_1, XREAL_1,
      XREAL_0, ALGSTR_0;
 schemes FUNCT_2;

begin

::
::                         1_ GROUP STRUCTURE
::

reserve GS for non empty addLoopStr;

definition
  canceled 5;
  func G_Real -> strict addLoopStr equals

  addLoopStr (# REAL,addreal,0 #);
  coherence;
end;

registration
  cluster G_Real -> non empty;
  coherence;
end;

registration
  cluster -> real Element of G_Real;
  coherence by XREAL_0:def 1;
end;

registration
  let a,b be Element of G_Real, x,y be real number;
  identify a+b with x+y when a = x, b = y;
  compatibility by BINOP_2:def 9;
end;

registration
  cluster G_Real -> Abelian add-associative right_zeroed right_complementable;
  coherence
  proof
    thus for x,y being Element of G_Real holds x+y = y+x;
    thus for x,y,z being Element of G_Real holds (x+y)+z = x+(y+z);
    thus for x being Element of G_Real holds x+0.G_Real = x;
    let x be Element of G_Real;
    reconsider x'=x as Element of REAL;
    reconsider y = -x' as Element of G_Real;
    take y;
    thus x+ y = 0.G_Real;
  end;
end;

registration
  let a be Element of G_Real, x be real number;
  identify -a with -x when a = x;
  compatibility
  proof
    assume
A1: x = a;
    reconsider b = -x as Element of G_Real by XREAL_0:def 1;
    b + a = 0.G_Real by A1;
    hence thesis by RLVECT_1:19;
  end;
end;

canceled 5;

theorem
  for x,y,z being Element of G_Real holds x+y = y+x & (x+y)+z = x+(y+z) &
  x+(0.G_Real) = x & x+(-x) = 0.G_Real;

registration
  cluster strict add-associative right_zeroed right_complementable
    Abelian (non empty addLoopStr);
  existence
  proof
    take G_Real; thus thesis;
  end;
end;

definition
  mode AddGroup is add-associative right_zeroed right_complementable
    (non empty addLoopStr);
end;

definition
  mode AbGroup is Abelian AddGroup;
end;

::
::                         4. FIELD STRUCTURE
::

definition
  let IT be non empty doubleLoopStr;
  canceled 4;
  attr IT is right-distributive means
  :Def11:
  for a, b, c being Element of IT holds a*(b+c) = a*b + a*c;
  attr IT is left-distributive means
  :Def12:
  for a, b, c being Element of IT holds (b+c)*a = b*a + c*a;
end;

definition
  let IT be non empty multLoopStr;
  attr IT is right_unital means
  :Def13:
  for x being Element of IT holds x * 1.IT = x;
end;

definition
  canceled;
  func F_Real -> strict doubleLoopStr equals
  doubleLoopStr (# REAL,addreal,multreal,1,0 #);
  correctness;
end;

registration
  cluster F_Real -> non empty;
  coherence;
end;

registration
  cluster -> real Element of F_Real;
  coherence by XREAL_0:def 1;
end;

registration
  let a,b be Element of F_Real, x,y be real number;
  identify a+b with x+y when a = x, b = y;
  compatibility by BINOP_2:def 9;
end;

registration
  let a,b be Element of F_Real, x,y be real number;
  identify a*b with x*y when a = x, b = y;
  compatibility by BINOP_2:def 11;
end;

definition
  let IT be non empty multLoopStr;
  attr IT is well-unital means
  :Def16:
  for x being Element of IT holds x * 1.IT = x & 1.IT * x = x;
end;

Lm1: for L being non empty multLoopStr st L is well-unital holds L is unital
proof
  let L being non empty multLoopStr such that
A1: L is well-unital;
  take 1.L;
  thus for h being Element of L holds h * 1.L = h & 1.L * h = h by A1,Def16;
end;

Lm2: for L being non empty multLoopStr st L is well-unital holds 1.L = 1_L
proof
  let L be non empty multLoopStr;
  assume
A1: L is well-unital;
  then
A2: for h being Element of L holds h * 1.L = h & 1.L * h = h by Def16;
  L is unital by A1,Lm1;
  hence 1.L = 1_L by A2,GROUP_1:def 5;
end;

registration
  cluster F_Real -> well-unital;
  coherence
  proof
    let x be Element of F_Real;
    thus thesis;
  end;
end;

registration
  cluster well-unital (non empty multLoopStr_0);
  existence
  proof
    take F_Real;
    thus thesis;
  end;
end;

definition
  let IT be non empty doubleLoopStr;
  canceled;
  attr IT is distributive means
  :Def18:
  for x,y,z being Element of IT holds
  x*(y+z) = x*y+x*z & (y+z)*x = y*x+z*x;
end;

definition
  let IT be non empty multLoopStr;
  attr IT is left_unital means
  :Def19:
  for x being Element of IT holds 1.IT * x = x;
end;

definition
  let IT be non empty multLoopStr_0;
  redefine attr IT is almost_left_invertible means
  :Def20:
  for x being Element of IT st x <> 0.IT ex y be Element of IT st y*x = 1.IT;
  compatibility
  proof
    thus IT is almost_left_invertible
    implies for x being Element of IT st x <> 0.IT
    ex y be Element of IT st y*x = 1.IT
    proof
      assume
A1:   IT is almost_left_invertible;
      let x be Element of IT;
      assume x <> 0.IT;
      then x is left_invertible by A1,ALGSTR_0:def 39;
      hence ex y be Element of IT st y*x = 1.IT by ALGSTR_0:def 27;
    end;
    assume
A2: for x being Element of IT st x <> 0.IT
    ex y be Element of IT st y*x = 1.IT;
    let x be Element of IT;
    assume x <> 0.IT;
    hence ex y be Element of IT st y*x = 1.IT by A2;
  end;
end;
set FR = F_Real;

registration
  cluster F_Real -> unital;
  coherence
  proof
    reconsider e = 1 as Element of FR;
    take e;
    thus thesis;
  end;
end;

registration
  cluster F_Real -> add-associative right_zeroed right_complementable Abelian
    commutative associative left_unital right_unital distributive
    almost_left_invertible non degenerated;
  coherence
  proof
    thus for x,y,z being Element of F_Real holds (x+y)+z = x+(y+z);
    thus for x being Element of F_Real holds x+0.F_Real = x;
    thus F_Real is right_complementable
    proof
      let x be Element of F_Real;
      reconsider x'=x as Element of REAL;
      reconsider y=-x' as Element of F_Real;
      take y' = y;
      thus x+ y' = 0.F_Real;
    end;
    thus for x,y being Element of F_Real holds x+y = y+x;
    thus for x,y being Element of F_Real holds x*y = y*x;
    thus for x,y,z being Element of F_Real holds (x*y)*z = x*(y*z);
    thus for x being Element of F_Real holds (1.F_Real)*x = x;
    thus for x being Element of F_Real holds x*(1.F_Real) = x;
    thus for x,y,z being Element of F_Real holds
    x*(y+z) = x*y+x*z & (y+z)*x = y*x+z*x;
    hereby
      let x be Element of F_Real;
      reconsider x'=x as Element of REAL;
      assume
A1:   x<>0.F_Real;
      reconsider y = (x')" as Element of F_Real;
      take y;
      thus y*x = 1.F_Real by A1,XCMPLX_0:def 7;
    end;
    thus 0.F_Real <> 1.F_Real;
  end;
end;

registration
  let a be Element of F_Real, x be real number;
  identify -a with -x when a = x;
  compatibility
  proof
    assume
A1: x = a;
    reconsider b = -x as Element of FR by XREAL_0:def 1;
    b + a = 0.FR by A1;
    hence thesis by RLVECT_1:19;
  end;
end;

Lm3: for L being non empty doubleLoopStr st
L is distributive holds L is right-distributive left-distributive
proof
  let L be non empty doubleLoopStr;
  assume
A1: L is distributive;
  then (for a,b,c being Element of L holds a*(b+c) = a*b + a*c) by Def18;
  hence L is right-distributive by Def11;
  (for a,b,c being Element of L holds (b+c)*a = b*a + c*a) by A1,Def18;
  hence thesis by Def12;
end;

registration
  cluster distributive -> left-distributive right-distributive
    (non empty doubleLoopStr);
  coherence by Lm3;
  cluster left-distributive right-distributive -> distributive
    (non empty doubleLoopStr);
  coherence
  proof
    let D be non empty doubleLoopStr;
    assume (for a,b,c being Element of D holds (b+c)*a = b*a + c*a) &
    for a,b,c being Element of D holds a*(b+c) = a*b+ a*c;
    hence for x,y,z be Element of D holds
    x*(y+z) = x*y+x*z & (y+z)*x = y*x+z*x;
  end;
end;

registration
  cluster well-unital -> left_unital right_unital (non empty multLoopStr);
  coherence
  proof
    let L be non empty multLoopStr;
    assume
A1: L is well-unital;
    hence for x being Element of L holds 1.L * x = x by Def16;
    thus for x being Element of L holds x * 1.L = x by A1,Def16;
  end;
  cluster left_unital right_unital -> unital (non empty multLoopStr);
  coherence
  proof
    let L be non empty multLoopStr such that
A2: (for x being Element of L holds 1.L * x = x) &
    for x being Element of L holds x * 1.L = x;
    take 1.L;
    thus thesis by A2;
  end;
end;

registration
  cluster commutative associative (non empty multMagma);
  existence
  proof
    take F_Real; thus thesis;
  end;
end;

registration
  cluster commutative associative unital (non empty multLoopStr);
  existence
  proof
    take F_Real; thus thesis;
  end;
end;

registration
  cluster add-associative right_zeroed right_complementable Abelian
    commutative associative left_unital right_unital distributive
    almost_left_invertible
    non degenerated well-unital strict (non empty doubleLoopStr);
  existence
  proof
    take F_Real; thus thesis;
  end;
end;

definition
  mode Field is add-associative right_zeroed right_complementable
    Abelian commutative associative well-unital distributive
    almost_left_invertible non degenerated (non empty doubleLoopStr);
end;

canceled 13;

theorem
  1.F_Real = 1;

theorem
  for x,y,z being Element of F_Real holds x+y = y+x & (x+y)+z = x+(y+z) &
  x+(0.F_Real) = x & x+(-x) = 0.F_Real & x*y = y*x & (x*y)*z = x*(y*z) &
  (1.F_Real)*x = x &
  (x <> 0.F_Real implies ex y be Element of F_Real st y*x = 1.F_Real) &
  x*(y+z) = x*y+x*z & (y+z)*x = y*x+z*x by Def20;

theorem
  for FS being non empty doubleLoopStr holds
  (for x,y,z being Element of FS holds
  (x <> 0.FS implies ex y be Element of FS st y*x = 1.FS)
  & x*(y+z) = x*y+x*z & (y+z)*x = y*x+z*x ) iff
  FS is distributive almost_left_invertible (non empty doubleLoopStr)
  by Def18,Def20;

::
::                        6. AXIOMS OF FIELD
::

canceled 10;

registration
  cluster well-unital -> unital (non empty multLoopStr);
  coherence;
end;

theorem
  for F being associative commutative well-unital distributive
  almost_left_invertible (non empty doubleLoopStr), x,y,z being Element of F
  holds (x <> 0.F & x*y = x*z) implies y = z
proof
  let F be associative commutative well-unital distributive
  almost_left_invertible (non empty doubleLoopStr), x,y,z be Element of F;
  assume x<>0.F;
  then consider x1 being Element of F such that
A1: x1*x = 1.F by Def20;
  assume
A2: x*y = x*z;
  x1*x*y = x1*(x*y) & x1*(x*z) = x1*x*z by GROUP_1:def 4;
  then x*x1*y = z by A1,A2,Def19;
  hence thesis by A1,Def19;
end;

definition
  let F be associative commutative well-unital
  almost_left_invertible (non empty doubleLoopStr), x be Element of F;
  canceled;
  assume
A1: x <> 0.F;
  redefine func x" means
  :Def22:
  it*x = 1.F;
  compatibility
  proof
    let IT be Element of F;
A2: x is left_invertible by A1,ALGSTR_0:def 39;
    then consider x1 being Element of F such that
A3: x1*x = 1.F by ALGSTR_0:def 27;
    x is right_mult-cancelable
    proof
      let y,z be Element of F;
      assume
A4:   y*x = z*x;
      thus y = y * 1.F by Def16
        .= z * x*x1 by A3,A4,GROUP_1:def 4
        .= z * 1.F by A3,GROUP_1:def 4
        .= z by Def16;
    end;
    hence thesis by A2,ALGSTR_0:def 35;
  end;
end;

definition
  let F be associative commutative well-unital distributive
  almost_left_invertible (non empty doubleLoopStr), x,y be Element of F;
  func x/y ->Element of F equals

  x*y";
  coherence;
end;

canceled 2;

theorem Th36:
  for F being add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr), x being Element of F
  holds x*(0.F) = 0.F
proof
  let F be add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr);
  let x be Element of F;
  x*(0.F)+(0.F) = x*((0.F)+(0.F))+(0.F) by RLVECT_1:10
    .= x*((0.F)+(0.F)) by RLVECT_1:10
    .= x*(0.F)+x*(0.F) by Def11;
  hence x*(0.F) = 0.F by RLVECT_1:21;
end;

canceled 2;

theorem Th39:
  for F being add-associative right_zeroed right_complementable
  left-distributive (non empty doubleLoopStr), x being Element of F
  holds (0.F)*x = 0.F
proof
  let F be add-associative right_zeroed right_complementable
  left-distributive (non empty doubleLoopStr);
  let x be Element of F;
  (0.F)*x+(0.F) = ((0.F)+(0.F))*x+(0.F) by RLVECT_1:10
    .= ((0.F)+(0.F))*x by RLVECT_1:10
    .= (0.F)*x+(0.F)*x by Def12;
  hence 0.F = (0.F)*x by RLVECT_1:21;
end;

theorem Th40:
  for F be add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr), x,y being Element of F
  holds x*(-y) = -x*y
proof
  let F be add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr), x,y be Element of F;
  x*y +x*(-y) = x*(y+(-y)) by Def11
    .= x*(0.F) by RLVECT_1:def 11
    .= 0.F by Th36;
  hence x*(-y) = -x*y by RLVECT_1:def 11;
end;

theorem Th41:
  for F be add-associative right_zeroed right_complementable
  left-distributive (non empty doubleLoopStr), x,y being Element of F
  holds (-x)*y = -x*y
proof
  let F be add-associative right_zeroed right_complementable
  left-distributive (non empty doubleLoopStr), x,y be Element of F;
  x*y +(-x)*y = (x+(-x))*y by Def12
    .= (0.F)*y by RLVECT_1:def 11
    .= 0.F by Th39;
  hence (-x)*y = -x*y by RLVECT_1:def 11;
end;

theorem Th42:
  for F be add-associative right_zeroed right_complementable
  distributive (non empty doubleLoopStr), x,y being Element of F
  holds (-x)*(-y) = x*y
proof
  let F be add-associative right_zeroed right_complementable
  distributive (non empty doubleLoopStr), x,y be Element of F;
  thus (-x)*(-y) = -x*(-y) by Th41
    .= --x*y by Th40
    .= x*y by RLVECT_1:30;
end;

theorem
  for F be add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr), x,y,z being Element of F holds
  x*(y-z) = x*y - x*z
proof
  let F be add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr), x,y,z be Element of F;
  x*(y-z) = x*y+x*(-z) by Def11
    .= x*y - x*z by Th40;
  hence thesis;
end;

theorem Th44:
  for F being add-associative right_zeroed right_complementable
  associative commutative well-unital almost_left_invertible
  distributive (non empty doubleLoopStr), x,y being Element of F holds
  x*y=0.F iff x=0.F or y=0.F
proof
  let F be add-associative right_zeroed right_complementable
  associative commutative well-unital almost_left_invertible
  distributive (non empty doubleLoopStr), x,y be Element of F;
  x*y=0.F implies x=0.F or y=0.F
  proof
    assume
A1: x*y = 0.F;
    assume
A2: x<>0.F;
    x"*(0.F) = x"*x*y by A1,GROUP_1:def 4
      .= (1.F)*y by A2,Def22
      .= y by Def19;
    hence thesis by Th39;
  end;
  hence thesis by Th39;
end;

theorem
  for K being add-associative right_zeroed right_complementable
  left-distributive (non empty doubleLoopStr)
  for a,b,c be Element of K holds (a-b)*c =a*c -b*c
proof
  let K be add-associative right_zeroed right_complementable
  left-distributive (non empty doubleLoopStr);
  let y,z,x be Element of K;
  thus (y-z)*x = y*x+(-z)*x by Def12
    .= y*x -z*x by Th41;
end;

::
::                      8. VECTOR SPACE STRUCTURE
::

definition
  let F be 1-sorted;
  struct(addLoopStr) VectSpStr over F (# carrier -> set,
    addF -> BinOp of the carrier, ZeroF -> Element of the carrier,
    lmult -> Function of [:the carrier of F,the carrier:], the carrier #);
end;

registration
  let F be 1-sorted, V be VectSpStr over F;
  cluster empty Subset of V;
  existence
   proof take {}V;
    thus thesis;
   end;
end;

registration
  let F be 1-sorted;
  cluster non empty strict VectSpStr over F;
  existence
  proof
    consider A being non empty set, a being BinOp of A, Z being Element of A,
    l being Function of [:the carrier of F,A:], A;
    take VectSpStr(#A,a,Z,l#);
    thus the carrier of VectSpStr(#A,a,Z,l#) is non empty;
    thus thesis;
  end;
end;

registration
  let F be 1-sorted;
  let A be non empty set, a be BinOp of A, Z be Element of A,
  l be Function of [:the carrier of F,A:], A;
  cluster VectSpStr(#A,a,Z,l#) -> non empty;
  coherence;
end;

definition
  let F be 1-sorted;
  mode Scalar of F is Element of F;
end;

definition
  let F be 1-sorted;
  let VS be VectSpStr over F;
  mode Scalar of VS is Scalar of F;
  mode Vector of VS is Element of VS;
end;

definition
  let F be non empty 1-sorted, V be non empty VectSpStr over F;
  let x be Element of F;
  let v be Element of V;
  func x*v -> Element of V equals

  (the lmult of V).(x,v);
  coherence;
end;

definition
  let F be non empty addLoopStr;
  func comp F -> UnOp of the carrier of F means
  for x being Element of F holds it.x = -x;
  existence
  proof
    deffunc F(Element of F) = -$1;
    thus ex f being UnOp of the carrier of F st
    for x being Element of F holds f.x = F(x) from FUNCT_2:sch 4;
  end;
  uniqueness
  proof
    let f, g be UnOp of the carrier of F such that
A1: for x being Element of F holds f.x = -x and
A2: for x being Element of F holds g.x = -x;
    now
      let x be set;
      assume x in the carrier of F;
      then reconsider y = x as Element of F;
      thus f.x = -y by A1
        .= g.x by A2;
    end;
    hence thesis by FUNCT_2:18;
  end;
end;

Lm4: now
  let F be add-associative right_zeroed right_complementable Abelian
  associative left_unital distributive (non empty doubleLoopStr);
  let MLT be
  Function of [:the carrier of F,the carrier of F:],the carrier of F;
  set GF = VectSpStr(# the carrier of F,the addF of F,0.F,MLT #);
  thus GF is Abelian
  proof
    let x,y be Element of GF;
    reconsider x'=x,y'=y as Element of F;
    thus x+y = y'+x' by RLVECT_1:5
      .= y+x;
  end;
  thus GF is add-associative
  proof
    let x,y,z be Element of GF;
    reconsider x'=x,y'=y,z'=z as Element of F;
    thus (x+y)+z = (x'+y')+z'
      .= x'+(y'+z') by RLVECT_1:def 6
      .= x+(y+z);
  end;
  thus GF is right_zeroed
  proof
    let x be Element of GF;
    reconsider x'=x as Element of F;
    thus x+0.GF = x'+(0.F)
      .= x by RLVECT_1:10;
  end;
  thus GF is right_complementable
  proof
    let x be Element of GF;
    reconsider x'=x as Element of F;
    consider t being Element of F such that
A1: x' + t = 0.F by ALGSTR_0:def 11;
    reconsider t' = t as Element of GF;
    take t';
    thus x + t' = 0.GF by A1;
  end;
end;

Lm5: now
  let F be add-associative right_zeroed right_complementable
  associative well-unital distributive (non empty doubleLoopStr);
  let MLT be
  Function of [:the carrier of F,the carrier of F:],the carrier of F such that
A1: MLT = the multF of F;
  set LS = VectSpStr (# the carrier of F,the addF of F,0.F, MLT #);
  let x,y be Element of F;
  let v,w be Element of LS;
  reconsider v' = v, w' = w as Element of F;
  thus x*(v+w) = x*(v'+w') by A1
    .= x*v'+x*w' by Def18
    .= x*v+x*w by A1;
  thus (x+y)*v = (x+y)*v' by A1
    .= x*v'+y*v' by Def18
    .= x*v+y*v by A1;
  thus (x*y)*v = (x*y)*v' by A1
    .= x*(y*v') by GROUP_1:def 4
    .= x*(y*v) by A1;
  thus (1.F)*v = (1.F)*v' by A1
    .= v by Def19;
end;

definition
  let F be non empty doubleLoopStr;
  let IT be non empty VectSpStr over F;
  attr IT is VectSp-like means
  :Def26:
  for x,y being Element of F
  for v,w being Element of IT holds x*(v+w) = x*v+x*w & (x+y)*v = x*v+y*v &
  (x*y)*v = x*(y*v) & (1.F)*v = v;
end;

registration
  let F be add-associative right_zeroed right_complementable Abelian
  associative well-unital distributive (non empty doubleLoopStr);
  cluster VectSp-like add-associative right_zeroed right_complementable Abelian
    strict (non empty VectSpStr over F);
  existence
  proof
    take V = VectSpStr (# the carrier of F,the addF of F,
      0.F,the multF of F#);
    thus for x,y being Element of F for v,w being Element of V holds
    x*(v+w) = x*v+x*w & (x+y)*v = x*v+y*v & (x*y)*v = x*(y*v) &
    (1.F)*v = v by Lm5;
    thus thesis by Lm4;
  end;
end;

definition
  let F be add-associative right_zeroed right_complementable Abelian
  associative well-unital distributive (non empty doubleLoopStr);
  mode VectSp of F is VectSp-like
    add-associative right_zeroed right_complementable Abelian
    (non empty VectSpStr over F);
end;

reserve F for Field,
  x for Element of F,
  V for VectSp of F,
  v for Element of V;

registration let F,V;
 cluster empty Subset of V;
 existence
  proof
   take {}V;
   thus thesis;
  end;
end;

canceled 13;

theorem Th59:
  for F being add-associative right_zeroed right_complementable
  Abelian associative well-unital distributive (non empty doubleLoopStr),
  x being Element of F for V being add-associative right_zeroed
  right_complementable VectSp-like (non empty VectSpStr over F),
  v being Element of V holds (0.F)*v = 0.V & (-1.F)*v = -v & x*(0.V) = 0.V
proof
  let F be add-associative right_zeroed right_complementable
  Abelian associative well-unital distributive (non empty doubleLoopStr);
  let x be Element of F;
  let V be add-associative right_zeroed
  right_complementable VectSp-like (non empty VectSpStr over F),
  v be Element of V;
  v+(0.F)*v = (1.F)*v + (0.F)*v by Def26
    .= ((1.F)+(0.F))*v by Def26
    .= (1.F)*v by RLVECT_1:10
    .= v by Def26
    .= v+0.V by RLVECT_1:10;
  hence
A1: (0.F)*v = 0.V by RLVECT_1:21;
  (-(1.F))*v+v = (-(1.F))*v + (1.F)*v by Def26
    .= ((1.F)+(-(1.F)))*v by Def26
    .= 0.V by A1,RLVECT_1:def 11;
  then (-(1.F))*v + (v+(-v)) = 0.V + -v by RLVECT_1:def 6;
  then 0.V + -v = (-(1.F))*v + 0.V by RLVECT_1:16
    .= (-(1.F))*v by RLVECT_1:10;
  hence (-1.F)*v = -v by RLVECT_1:10;
  x*(0.V) = (x*(0.F))*v by A1,Def26
    .= 0.V by A1,Th36;
  hence thesis;
end;

theorem
  x*v = 0.V iff x = 0.F or v = 0.V
proof
  x*v = 0.V implies x = 0.F or v = 0.V
  proof
    assume
A1: x*v = 0.V;
    assume
A2: x<>(0.F);
    x"*x*v = x"*(0.V) by A1,Def26
      .= 0.V by Th59;
    then 0.V = (1.F)*v by A2,Def22;
    hence thesis by Def26;
  end;
  hence thesis by Th59;
end;

::
::                          13. APPENDIX
::

canceled 2;

theorem
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,w being Element of V holds
  v+w=0.V iff -v=w
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,w be Element of V;
  v+w=0.V implies -v=w
  proof
    assume
A1: v+w=0.V;
    thus w = 0.V + w by RLVECT_1:10
      .= -v + v + w by RLVECT_1:16
      .= -v + 0.V by A1,RLVECT_1:def 6
      .= -v by RLVECT_1:10;
  end;
  hence thesis by RLVECT_1:16;
end;

Lm6: for V being add-associative right_zeroed
right_complementable (non empty addLoopStr), v,w being Element of V
holds -(w+-v)=v-w
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,w be Element of V;
  -(w+-v)=-(-v)-w by RLVECT_1:44;
  hence thesis by RLVECT_1:30;
end;

Lm7: for V being add-associative right_zeroed
right_complementable (non empty addLoopStr),
v,w being Element of V holds -(-v-w)=w+v
proof
  let V be add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,w be Element of V;
  -(-v-w)=w+-(-v) by RLVECT_1:47;
  hence thesis by RLVECT_1:30;
end;

theorem
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), u,v,w being Element of V holds
  -(v+w)=-w-v & -(w+-v)=v-w & -(v-w)=w+-v & -(-v-w)=w+v &
  u-(w+v)=u-v-w by Lm6,Lm7,RLVECT_1:41,44,47;

theorem
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v being Element of V holds
  0.V-v=-v & v-0.V=v by RLVECT_1:26,27;

theorem Th66:
  for F being add-associative right_zeroed
  right_complementable (non empty addLoopStr), x,y being Element of F holds
  (x+(-y)=0.F iff x=y) & (x-y=0.F iff x=y)
proof
  let F be add-associative right_zeroed
  right_complementable (non empty addLoopStr), x,y be Element of F;
  x+(-y)=0.F iff x=y
  proof
    x+(-y)=0.F implies x=y
    proof
      assume x+(-y)=0.F;
      then x+((-y)+y)=0.F+y by RLVECT_1:def 6;
      then x+0.F=0.F+y by RLVECT_1:16;
      then x=0.F+y by RLVECT_1:10;
      hence thesis by RLVECT_1:10;
    end;
    hence thesis by RLVECT_1:16;
  end;
  hence thesis;
end;

theorem
  x<>0.F implies x"*(x*v)=v
proof
  assume
A1: x<>0.F;
  x"*(x*v)=(x"*x)*v by Def26
    .=1.F*v by A1,Def22
    .=v by Def26;
  hence thesis;
end;

theorem Th68:
  for F be add-associative right_zeroed right_complementable Abelian
  associative well-unital distributive (non empty doubleLoopStr),
  V be VectSp-like add-associative right_zeroed right_complementable
  (non empty VectSpStr over F), x being Element of F,
  v,w being Element of V holds -x*v=(-x)*v & w-x*v=w+(-x)*v
proof
  let F be add-associative right_zeroed right_complementable Abelian
  associative well-unital distributive (non empty doubleLoopStr),
  V be VectSp-like add-associative right_zeroed right_complementable
  (non empty VectSpStr over F), x be Element of F, v,w be Element of V;
A1: -x*v=(-1.F)*(x*v) by Th59
    .=((-1.F)*x)*v by Def26
    .=(-(1.F*x))*v by Th41;
  hence -x*v=(-x)*v by Def19;
  thus thesis by A1,Def19;
end;

registration
  cluster commutative left_unital -> right_unital (non empty multLoopStr);
  coherence
  proof
    let F be non empty multLoopStr;
    assume
A1: F is commutative left_unital;
    let x be Scalar of F;
    for F be commutative (non empty multMagma),
    x,y being Element of F holds x*y = y*x;
    then x*(1.F) = (1.F)*x by A1;
    hence x*(1.F) = x by A1,Def19;
  end;
end;

theorem Th69:
  for F be add-associative right_zeroed right_complementable Abelian
  associative well-unital right_unital distributive (non empty doubleLoopStr),
  V be VectSp-like add-associative right_zeroed right_complementable
  (non empty VectSpStr over F), x being Element of F,
  v being Element of V holds x*(-v)=-x*v
proof
  let F be add-associative right_zeroed right_complementable Abelian
  associative well-unital right_unital distributive (non empty doubleLoopStr),
  V be VectSp-like add-associative right_zeroed right_complementable
  (non empty VectSpStr over F), x be Element of F, v be Element of V;
  x*(-v)=x*((-1.F)*v) by Th59
    .=(x*(-1.F))*v by Def26
    .=(-(x*1.F))*v by Th40
    .=(-x)*v by Def13;
  hence thesis by Th68;
end;

theorem
  for F be add-associative right_zeroed right_complementable Abelian
  associative well-unital right_unital distributive (non empty doubleLoopStr),
  V be VectSp-like add-associative right_zeroed right_complementable
  (non empty VectSpStr over F), x being Element of F,
  v,w being Element of V holds x*(v-w)=x*v-x*w
proof
  let F be add-associative right_zeroed right_complementable Abelian
  associative well-unital right_unital distributive (non empty doubleLoopStr),
  V be VectSp-like add-associative right_zeroed right_complementable
  (non empty VectSpStr over F), x be Element of F, v,w be Element of V;
  x*(v-w)=x*v+x*(-w) by Def26
    .=x*v+(-x*w) by Th69;
  hence thesis;
end;

canceled 2;

theorem
  for F being add-associative right_zeroed right_complementable
  commutative associative well-unital non degenerated
  almost_left_invertible distributive (non empty doubleLoopStr),
  x being Element of F holds x <> 0.F implies (x")" = x
proof
  let F be add-associative right_zeroed right_complementable commutative
  associative well-unital non degenerated
  almost_left_invertible distributive (non empty doubleLoopStr),
  x be Element of F;
A1: x <> 0.F implies x" <> 0.F
  proof
    assume
A2: x <> 0.F;
    assume not thesis;
    then 1.F = x*0.F by A2,Def22;
    hence contradiction by Th39;
  end;
  assume
A3: x <> 0.F;
  then x"*(x")" = 1.F by A1,Def22;
  then (x*x")*(x")" = x*1.F by GROUP_1:def 4;
  then 1.F*(x")" = x*1.F by A3,Def22;
  then (x")" = x*1.F by Def16;
  hence thesis by Def16;
end;

theorem
  for F being Field, x being Element of F holds
  x <> 0.F implies x" <> 0.F & -x" <> 0.F
proof
  let F be Field, x be Element of F;
  assume
A1: x <> 0.F;
  hereby
    assume x" = 0.F;
    then 1.F = x*0.F by A1,Def22;
    hence contradiction by Th39;
  end;
  assume -x" = 0.F;
  then 1.F*x" = (-1.F)*0.F by Th42;
  then 1.F*x" = 0.F by Th39;
  then x*x" = x*0.F by Def19;
  then 1.F = x*0.F by A1,Def22;
  hence contradiction by Th39;
end;

canceled 3;

theorem Th78:
  1.F_Real + 1.F_Real <> 0.F_Real;

definition
  let IT be non empty addLoopStr;
  canceled;
  attr IT is Fanoian means
  :Def28:
  for a being Element of IT st a + a = 0.IT
  holds a = 0.IT;
end;

registration
  cluster Fanoian (non empty addLoopStr);
  existence
  proof
    take F = F_Real;
    let a be Element of F such that
A1: a + a = 0.F;
    a = 1.F * a by Def19;
    then a + a = (1.F + 1.F) * a by Def18;
    hence a = 0.F by A1,Th44,Th78;
  end;
end;

definition
  let F be add-associative right_zeroed right_complementable
  commutative associative well-unital almost_left_invertible
  non degenerated distributive (non empty doubleLoopStr);
  redefine attr F is Fanoian means
  :Def29:
  1.F+1.F<>0.F;
  compatibility
  proof
    thus F is Fanoian implies 1.F+1.F<>0.F by Def28;
    assume
A1: 1.F+1.F<>0.F;
    let a be Element of F such that
A2: a + a = 0.F;
    a = 1.F * a by Def19;
    then a + a = (1.F + 1.F) * a by Def18;
    hence a = 0.F by A1,A2,Th44;
  end;
end;

registration
  cluster strict Fanoian Field;
  existence
  proof
    F_Real is Fanoian by Def29,Th78;
    hence thesis;
  end;
end;

canceled 5;

theorem
  for F being add-associative right_zeroed
  right_complementable (non empty addLoopStr), a,b being Element of F holds
  a - b = 0.F implies a = b by Th66;

canceled;

theorem Th86:
  for F being add-associative right_zeroed
  right_complementable (non empty addLoopStr), a being Element of F holds
  -a = 0.F implies a = 0.F
proof
  let F be add-associative right_zeroed
  right_complementable (non empty addLoopStr), a be Element of F;
  --a = a by RLVECT_1:30;
  hence thesis by RLVECT_1:25;
end;

theorem
  for F being add-associative right_zeroed
  right_complementable (non empty addLoopStr), a, b being Element of F holds
  a - b = 0.F implies b - a = 0.F
proof
  let F be add-associative right_zeroed
  right_complementable (non empty addLoopStr), a,b be Element of F;
  a - b = -(b - a) by RLVECT_1:47;
  hence thesis by Th86;
end;

theorem
  for a, b, c being Element of F holds
  (a <> 0.F & a*c - b = 0.F implies c = b*a") &
  (a <> 0.F & b - c*a = 0.F implies c = b*a")
proof
  let a, b, c be Element of F; thus
A1: a <> 0.F & a*c - b = 0.F implies c = b*a"
  proof
    assume
A2: a <> 0.F;
    assume a*c - b = 0.F;
    then a"*(a*c) = b*a" by RLVECT_1:35;
    then (a"*a)*c = b*a" & a"*a = 1.F & c*(1.F) =(1.F)*c
    by A2,Def22,GROUP_1:def 4;
    hence c = b*a" by Def16;
  end;
  assume
A3: a <> 0.F;
  assume b - c*a = 0.F;
  then -(b - c*a) = 0.F by RLVECT_1:25;
  hence thesis by A1,A3,RLVECT_1:47;
end;

theorem
  for F being add-associative right_zeroed
  right_complementable (non empty addLoopStr), a, b being Element of F holds
  a + b = -(-b + -a)
proof
  let F be add-associative right_zeroed
  right_complementable (non empty addLoopStr), a,b be Element of F;
  thus a + b = --(a + b) by RLVECT_1:30
    .= -(-b + -a) by RLVECT_1:45;
end;

theorem
  for F being add-associative right_zeroed
  right_complementable (non empty addLoopStr),
  a, b, c being Element of F holds (b+a)-(c+a) = b-c
proof
  let F be add-associative right_zeroed
  right_complementable (non empty addLoopStr), a,b,c be Element of F;
  thus (b+a)-(c+a) = (b+a)+(-a+-c) by RLVECT_1:45
    .= ((b+a)+-a)+-c by RLVECT_1:def 6
    .= (b+(a+-a))+-c by RLVECT_1:def 6
    .= (b+0.F)+-c by RLVECT_1:16
    .= b-c by RLVECT_1:10;
end;

canceled;

theorem
  for G being add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,w being Element of G holds -(-v+w) = -w+v
proof
  let G be add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,w be Element of G;
  thus -(-v+w) = -w + --v by RLVECT_1:45
    .= -w + v by RLVECT_1:30;
end;

theorem
  for G being Abelian add-associative (non empty addLoopStr),
  u,v,w being Element of G holds u - v - w = u - w - v
proof
  let G be Abelian add-associative (non empty addLoopStr),
  u,v,w be Element of G;
  thus u - v - w = u + -v + -w
    .= u + -w + -v by RLVECT_1:def 6
    .= u - w - v;
end;

theorem
  for B being AbGroup holds
  multMagma (# the carrier of B, the addF of B #) is commutative Group
proof
  let B be AbGroup;
  set G = multMagma (# the carrier of B, the addF of B #);
A1: for a,b be Element of G, x,y be Element of B st a = x & b = y
  holds a * b = x + y;
A2: G is associative Group-like
  proof
    thus for a,b,c being Element of G holds a * b * c = a * (b * c)
    proof
      let a,b,c be Element of G;
      reconsider x = a, y = b, z = c as Element of B;
      thus a * b * c = x + y + z
        .= x + (y + z) by RLVECT_1:def 6
        .= a * (b * c);
    end;
    reconsider e = 0.B as Element of G;
    take e;
    let a be Element of G;
    reconsider x = a as Element of B;
    thus a * e = x + 0.B
      .= a by RLVECT_1:10;
    thus e * a = x + 0.B by A1
      .= a by RLVECT_1:10;
    reconsider b = - x as Element of G;
    take b;
    thus a * b = x + (- x)
      .= e by RLVECT_1:16;
    thus b * a = x + (- x) by A1
      .= e by RLVECT_1:16;
  end;
  now
    let a,b be Element of G;
    reconsider x = a, y = b as Element of B;
    thus a * b = y + x by A1
      .= b * a;
  end;
  hence thesis by A2,GROUP_1:def 16;
end;

begin :: Addenda

:: from COMPTRIG, 2006.08.12, A.T.

theorem
  for L be add-associative right_zeroed right_complementable
  right-distributive unital (non empty doubleLoopStr)
  for n be Element of NAT st n > 0 holds (power L).(0.L,n) = 0.L
proof
  let L be add-associative right_zeroed right_complementable
  right-distributive unital (non empty doubleLoopStr);
  let n be Element of NAT;
  assume n > 0;
  then n >= 0+1 by NAT_1:13;
  then
A1: n-1 >= 0 by XREAL_1:21;
  n = n-1+1
    .= n-'1+1 by A1,XREAL_0:def 2;
  hence (power L).(0.L,n) = (power L).(0.L,n-'1)*0.L by GROUP_1:def 8
    .= 0.L by Th36;
end;

:: 2007.02.14, A.T.

registration
  cluster well-unital (non empty multLoopStr);
  existence
  proof
    take F_Real;
    thus thesis;
  end;
end;

registration
  let S be well-unital (non empty multLoopStr);
  identify 1_S with 1.S;
  compatibility by Lm2;
end;

theorem
  for L being non empty multLoopStr st L is well-unital holds 1.L = 1_L by Lm2;

