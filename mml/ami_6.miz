:: On the Instructions of { \bf SCM }
::  by Artur Korni{\l}owicz
::
:: Received May 8, 2001
:: Copyright (c) 2001-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, AMI_3, AMI_1, FSM_1, ORDINAL1, AMI_2, CAT_1, XBOOLE_0,
      FUNCT_1, RELAT_1, STRUCT_0, FINSEQ_1, CARD_1, AMISTD_2, GRAPHSP,
      CARD_3, AMISTD_1, SUBSET_1, CIRCUIT2, FUNCT_4, FUNCOP_1, SETFAM_1,
      ZFMISC_1, XXREAL_0, TARSKI, ARYTM_3, GOBOARD5, FRECHET, ARYTM_1,
      INT_1, UNIALG_1, CARD_5, PARTFUN1, NAT_1, SCMNORM, COMPOS_1, PBOOLE;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1, FUNCT_2,
      REALSET1, ORDINAL1, NAT_1, NUMBERS, XCMPLX_0, INT_1, FUNCOP_1, PARTFUN1,
      PBOOLE,
      FINSEQ_1, FUNCT_4, XXREAL_0, MCART_1, VALUED_1, STRUCT_0, CARD_3,
      FUNCT_7, COMPOS_1, EXTPRO_1, AMI_2, AMI_3, AMISTD_1, AMISTD_2;
 constructors XXREAL_0, NAT_1, NAT_D, REALSET1, AMI_3, AMISTD_2, RELSET_1,
      RECDEF_2, MCART_1, VALUED_1, AMI_2, EXTPRO_1, AMISTD_1, PRE_POLY;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      NUMBERS, XREAL_0, NAT_1, INT_1, FINSEQ_1, CARD_3, AMI_3, AMISTD_2,
      RELSET_1, ZFMISC_1, FUNCT_2, FUNCT_4, VALUED_0, COMPOS_1, EXTPRO_1,
      PBOOLE, FUNCT_7, PRE_POLY;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;
 definitions TARSKI, FUNCT_1, FUNCT_7, AMISTD_1, AMISTD_2, XBOOLE_0, AMI_3,
      FUNCOP_1, AMI_2, COMPOS_1, EXTPRO_1, CARD_3, NAT_1, MCART_1;
 theorems TARSKI, NAT_1, AMI_3, FUNCT_4, AMI_5, FUNCT_1,
      FUNCOP_1, SETFAM_1, AMI_2, AMISTD_1, MCART_1, FINSEQ_1,
      AMISTD_2, FUNCT_7, CARD_3, XBOOLE_0, XBOOLE_1, NAT_D, RELAT_1, ORDINAL1,
      PARTFUN1, PBOOLE, RECDEF_2, VALUED_1, COMPOS_1, EXTPRO_1;

begin

reserve a, b, d1, d2 for Data-Location,
  il, i1, i2 for Element of NAT,
  I for Instruction of SCM,
  s, s1, s2 for State of SCM,
  T for InsType of SCM,
  k,k1 for natural number;

theorem Th1:
  not a in NAT
proof
  a in SCM-Data-Loc by AMI_3:def 2;
  hence thesis by AMI_2:29,XBOOLE_0:3;
end;

theorem
  SCM-Data-Loc <> NAT by AMI_2:12;

theorem Th3:
  for o being Object of SCM holds o = IC SCM or o in NAT or o is
  Data-Location
proof
  let o be Object of SCM;
  the carrier of SCM = {IC SCM} \/ Data-Locations SCM \/ NAT
                   by COMPOS_1:160;
  then o in {IC SCM} \/ Data-Locations SCM or o in NAT by XBOOLE_0:def 3;
  then o in {IC SCM} or o in Data-Locations SCM
   or o in NAT by XBOOLE_0:def 3;
  hence thesis by AMI_3:72,def 2,TARSKI:def 1;
end;

canceled;

theorem Th5:
  NPP s1 = NPP s2 implies s1.a = s2.a
proof
  assume
A1: NPP s1 = NPP s2;
A2: not a in NAT by Th1;
  dom s2 = the carrier of SCM by PARTFUN1:def 4;
  then a in dom s2 \ NAT by A2,XBOOLE_0:def 5;
  then
A3: a in dom s2 /\ (dom s2 \ NAT) by XBOOLE_0:def 4;
  dom s1 = the carrier of SCM by PARTFUN1:def 4;
  then a in dom s1 \ NAT by A2,XBOOLE_0:def 5;
  then a in dom s1 /\ (dom s1 \ NAT) by XBOOLE_0:def 4;
  hence s1.a = (s1|(dom s1 \ NAT)).a by FUNCT_1:71
    .= (s2|(dom s2 \ NAT)).a by A1,COMPOS_1:233
    .= s2.a by A3,FUNCT_1:71;
end;


registration
 cluster InsCodes SCM -> non empty;
 coherence;
end;

canceled;

theorem
Th7: T = 0 or T = 1 or T = 2 or T = 3 or T = 4 or T = 5 or T = 6 or T = 7 or T
= 8

proof
  consider y being set such that
A1: [T,y] in proj1 the Instructions of SCM by RELAT_1:def 4;
  consider x being set such that
A2: [[T,y],x] in the Instructions of SCM by A1,RELAT_1:def 4;
   reconsider I = [T,y,x] as Instruction of SCM by A2;
   T = InsCode I by RECDEF_2:def 1;
  hence thesis by AMI_5:36,NAT_1:33;
end;

canceled;

theorem Th9:
  JumpPart halt SCM = {};

canceled 8;

theorem Th18:
  T = 0 implies JumpParts T = {0}
proof
  assume
A1: T = 0;
  hereby
    let a be set;
    assume a in JumpParts T;
    then consider I such that
A2: a = JumpPart I and
A3: InsCode I = T;
    I = halt SCM by A1,A3,AMI_5:46;
    hence a in {0} by A2,Th9,TARSKI:def 1;
  end;
  let a be set;
  assume a in {0};
  then a = 0 by TARSKI:def 1;
  hence thesis by A1,Th9,AMI_5:37;
end;

theorem Th19:
  T = 1 implies JumpParts T = {{}}
proof
  assume
A1: T = 1;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM such that
A2:   x = JumpPart I and
A3:   InsCode I = T;
     consider a,b such that
A4:   I = a:=b by A1,A3,AMI_5:47;
     x = {} by A2,A4,RECDEF_2:def 2;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Data-Location;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
A5:  x = JumpPart(a:= a) by RECDEF_2:def 2;
    InsCode(a:= a) = 1 by RECDEF_2:def 1;
  hence thesis by A5,A1;
end;

theorem Th20:
  T = 2 implies JumpParts T = {{}}
proof
  assume
A1: T = 2;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM such that
A2:   x = JumpPart I and
A3:   InsCode I = T;
     consider a,b such that
A4:   I = AddTo(a,b) by A1,A3,AMI_5:48;
     x = {} by A2,A4,RECDEF_2:def 2;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Data-Location;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
A5:  x = JumpPart AddTo(a,a) by RECDEF_2:def 2;
    InsCode AddTo(a,a) = 2 by RECDEF_2:def 1;
  hence thesis by A5,A1;
end;

theorem Th21:
  T = 3 implies JumpParts T = {{}}
proof
  assume
A1: T = 3;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM such that
A2:   x = JumpPart I and
A3:   InsCode I = T;
     consider a,b such that
A4:   I = SubFrom(a,b) by A1,A3,AMI_5:49;
     x = {} by A2,A4,RECDEF_2:def 2;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Data-Location;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
A5:  x = JumpPart SubFrom(a,a) by RECDEF_2:def 2;
    InsCode SubFrom(a,a) = 3 by RECDEF_2:def 1;
  hence thesis by A5,A1;
end;

theorem Th22:
  T = 4 implies JumpParts T = {{}}
proof
  assume
A1: T = 4;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM such that
A2:   x = JumpPart I and
A3:   InsCode I = T;
     consider a,b such that
A4:   I = MultBy(a,b) by A1,A3,AMI_5:50;
     x = {} by A2,A4,RECDEF_2:def 2;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Data-Location;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
A5:  x = JumpPart MultBy(a,a) by RECDEF_2:def 2;
    InsCode MultBy(a,a) = 4 by RECDEF_2:def 1;
  hence thesis by A5,A1;
end;

theorem Th23:
  T = 5 implies JumpParts T = {{}}
proof
  assume
A1: T = 5;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM such that
A2:   x = JumpPart I and
A3:   InsCode I = T;
     consider a,b such that
A4:   I = Divide(a,b) by A1,A3,AMI_5:51;
     x = {} by A2,A4,RECDEF_2:def 2;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Data-Location;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
A5:  x = JumpPart Divide(a,a) by RECDEF_2:def 2;
    InsCode Divide(a,a) = 5 by RECDEF_2:def 1;
  hence thesis by A5,A1;
end;

theorem Th24:
  T = 6 implies dom product" JumpParts T = {1}
proof
  set i1 =the  Element of NAT;
  assume
A1: T = 6;
A2: JumpPart SCM-goto i1 = <*i1*> by RECDEF_2:def 2;
  hereby
    let x be set;
    InsCode SCM-goto i1 = 6 by RECDEF_2:def 1;
    then
A3: JumpPart SCM-goto i1 in JumpParts T by A1;
    assume x in dom product" JumpParts T;
    then x in dom JumpPart SCM-goto i1 by A3,CARD_3:def 13;
    hence x in {1} by A2,FINSEQ_1:4,def 8;
  end;
  let x be set;
  assume
A4: x in {1};
  for f being Function st f in JumpParts T holds x in dom f
  proof
    let f be Function;
    assume f in JumpParts T;
    then consider I being Instruction of SCM such that
A5: f = JumpPart I and
A6: InsCode I = T;
    consider i1 such that
A7: I = SCM-goto i1 by A1,A6,AMI_5:52;
    f = <*i1*> by A5,A7,RECDEF_2:def 2;
    hence thesis by A4,FINSEQ_1:4,def 8;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th25:
  T = 7 implies dom product" JumpParts T = {1}
proof
  set i1 =the  Element of NAT,a =the  Data-Location;
  assume
A1: T = 7;
A2: JumpPart (a =0_goto i1) = <*i1*> by RECDEF_2:def 2;
  hereby
    let x be set;
    InsCode (a =0_goto i1) = 7 by RECDEF_2:def 1;
    then
A3: JumpPart (a =0_goto i1) in JumpParts T by A1;
    assume x in dom product" JumpParts T;
    then x in dom JumpPart (a =0_goto i1) by A3,CARD_3:def 13;
    hence x in {1} by A2,FINSEQ_1:4,55;
  end;
  let x be set;
  assume
A4: x in {1};
  for f being Function st f in JumpParts T holds x in dom f
  proof
    let f be Function;
    assume f in JumpParts T;
    then consider I being Instruction of SCM such that
A5: f = JumpPart I and
A6: InsCode I = T;
    consider i1, a such that
A7: I = a =0_goto i1 by A1,A6,AMI_5:53;
    f = <*i1*> by A5,A7,RECDEF_2:def 2;
    hence thesis by A4,FINSEQ_1:4,55;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th26:
  T = 8 implies dom product" JumpParts T = {1}
proof
  set i1 =the  Element of NAT,a =the  Data-Location;
  assume
A1: T = 8;
A2: JumpPart (a >0_goto i1) = <*i1*> by RECDEF_2:def 2;
  hereby
    let x be set;
    InsCode (a >0_goto i1) = 8 by RECDEF_2:def 1;
    then
A3: JumpPart (a >0_goto i1) in JumpParts T by A1;
    assume x in dom product" JumpParts T;
    then x in dom JumpPart (a >0_goto i1) by A3,CARD_3:def 13;
    hence x in {1} by A2,FINSEQ_1:4,55;
  end;
  let x be set;
  assume
A4: x in {1};
  for f being Function st f in JumpParts T holds x in dom f
  proof
    let f be Function;
    assume f in JumpParts T;
    then consider I being Instruction of SCM such that
A5: f = JumpPart I and
A6: InsCode I = T;
    consider i1, a such that
A7: I = a >0_goto i1 by A1,A6,AMI_5:54;
    f = <*i1*> by A5,A7,RECDEF_2:def 2;
    hence thesis by A4,FINSEQ_1:4,55;
  end;
  hence thesis by CARD_3:def 13;
end;

canceled 10;

theorem Th37:
  (product" JumpParts InsCode SCM-goto k1).1 = NAT
proof
 InsCode SCM-goto k1 = 6 by RECDEF_2:def 1;
 then dom product" JumpParts InsCode SCM-goto k1 = {1}
   by Th24;
  then
A1: 1 in dom product" JumpParts InsCode SCM-goto k1 by TARSKI:def 1;
  hereby
    let x be set;
    assume x in (product" JumpParts InsCode SCM-goto k1).1;
    then x in pi(JumpParts InsCode SCM-goto k1,1) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in JumpParts InsCode SCM-goto k1 and
A3: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM such that
A4: g = JumpPart I and
A5: InsCode I = InsCode SCM-goto k1 by A2;
    InsCode I = 6 by A5,RECDEF_2:def 1;
    then consider i2 such that
A6: I = SCM-goto i2 by AMI_5:52;
    g = <*i2*> by A4,A6,RECDEF_2:def 2;
    then x = i2 by A3,FINSEQ_1:def 8;
    hence x in NAT;
  end;
  let x be set;
  assume x in NAT;
  then reconsider x as Element of NAT;
  InsCode SCM-goto k1 = 6 by RECDEF_2:def 1;
  then JumpPart SCM-goto x = <*x*> & InsCode SCM-goto k1
   = InsCode SCM-goto x by RECDEF_2:def 1,def 2;
  then
A7: <*x*> in JumpParts InsCode SCM-goto k1;
  <*x*>.1 = x by FINSEQ_1:def 8;
  then x in pi(JumpParts InsCode SCM-goto k1,1) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th38:
  (product" JumpParts InsCode (a =0_goto k1)).1 = NAT
proof
 InsCode (a =0_goto k1) = 7 by RECDEF_2:def 1;
 then dom product" JumpParts InsCode (a =0_goto k1) = {1} by Th25;
  then
A1: 1 in dom product" JumpParts InsCode (a =0_goto k1) by TARSKI:def 1;
  hereby
    let x be set;
    assume x in (product" JumpParts InsCode (a =0_goto k1)).1;
    then x in pi(JumpParts InsCode (a =0_goto k1),1) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in JumpParts InsCode (a =0_goto k1) and
A3: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM such that
A4: g = JumpPart I and
A5: InsCode I = InsCode (a =0_goto k1) by A2;
    InsCode I = 7 by A5,RECDEF_2:def 1;
    then consider i2, b such that
A6: I = b =0_goto i2 by AMI_5:53;
    g = <*i2*> by A4,A6,RECDEF_2:def 2;
    then x = i2 by A3,FINSEQ_1:57;
    hence x in NAT;
  end;
  let x be set;
  assume x in NAT;
  then reconsider x as Element of NAT;
  InsCode (a =0_goto k1) = 7 by RECDEF_2:def 1;
  then JumpPart (a =0_goto x) = <*x*> & InsCode (a =0_goto k1) = InsCode
  (a =0_goto x) by RECDEF_2:def 1,def 2;
  then
A7: <*x*> in JumpParts InsCode (a =0_goto k1);
  <*x*>.1 = x by FINSEQ_1:57;
  then x in pi(JumpParts InsCode (a =0_goto k1),1) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

canceled;

theorem Th40:
  (product" JumpParts InsCode (a >0_goto k1)).1 = NAT
proof
 InsCode (a >0_goto k1) = 8 by RECDEF_2:def 1;
 then dom product" JumpParts InsCode (a >0_goto k1) = {1} by Th26;
  then
A1: 1 in dom product" JumpParts InsCode (a >0_goto k1) by TARSKI:def 1;
  hereby
    let x be set;
    assume x in (product" JumpParts InsCode (a >0_goto k1)).1;
    then x in pi(JumpParts InsCode (a >0_goto k1),1) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in JumpParts InsCode (a >0_goto k1) and
A3: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM such that
A4: g = JumpPart I and
A5: InsCode I = InsCode (a >0_goto k1) by A2;
    InsCode I = 8 by A5,RECDEF_2:def 1;
    then consider i2, b such that
A6: I = b >0_goto i2 by AMI_5:54;
    g = <*i2*> by A4,A6,RECDEF_2:def 2;
    then x = i2 by A3,FINSEQ_1:57;
    hence x in NAT;
  end;
  let x be set;
  assume x in NAT;
  then reconsider x as Element of NAT;
  InsCode (a >0_goto k1) = 8 by RECDEF_2:def 1;
  then JumpPart (a >0_goto x) = <*x*> & InsCode (a >0_goto k1) = InsCode
  (a >0_goto x) by RECDEF_2:def 1,def 2;
  then
A7: <*x*> in JumpParts InsCode (a >0_goto k1);
  <*x*>.1 = x by FINSEQ_1:57;
  then x in pi(JumpParts InsCode (a >0_goto k1),1) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

Lm2: for i being Instruction of SCM holds (for l being Element of NAT
holds NIC(i,l)={succ l}) implies JUMP i is empty

proof
  set p=1, q=2;
  let i be Instruction of SCM;
  assume
A1: for l being Element of NAT holds NIC(i,l)={succ l};

  set X = { NIC(i,f) where f is Element of NAT: not contradiction
  };

  reconsider p, q as Element of NAT;
  assume not thesis;
  then consider x being set such that
A2: x in meet X by XBOOLE_0:def 1;
  NIC(i,p) = {succ p} by A1;
  then {succ p} in X;
  then x in {succ p} by A2,SETFAM_1:def 1;
  then
A3: x = succ p by TARSKI:def 1;
  NIC(i,q) = {succ q} by A1;
  then {succ q} in X;
  then x in {succ q} by A2,SETFAM_1:def 1;
  hence contradiction by A3,TARSKI:def 1;
end;

registration
  cluster JUMP halt SCM -> empty;
  coherence;
end;

registration
  let a, b;
  cluster a:=b -> sequential;
  coherence
  proof
    let s be State of SCM;
    thus thesis by AMI_3:8;
  end;
  cluster AddTo(a,b) -> sequential;
  coherence
  proof
    let s be State of SCM;
    thus thesis by AMI_3:9;
  end;
  cluster SubFrom(a,b) -> sequential;
  coherence
  proof
    let s be State of SCM;
    thus thesis by AMI_3:10;
  end;
  cluster MultBy(a,b) -> sequential;
  coherence
  proof
    let s be State of SCM;
    thus thesis by AMI_3:11;
  end;
  cluster Divide(a,b) -> sequential;
  coherence
  proof
    let s be State of SCM;
    thus thesis by AMI_3:12;
  end;
end;

registration
  let a, b;
  cluster JUMP (a := b) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(a:=b,l)={succ l} by AMISTD_1:41;
    hence thesis by Lm2;
  end;
end;

registration
  let a, b;
  cluster JUMP AddTo(a, b) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(AddTo(a,b),l)={succ
    l} by AMISTD_1:41;
    hence thesis by Lm2;
  end;
end;

registration
  let a, b;
  cluster JUMP SubFrom(a, b) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(SubFrom(a,b),l)={
    succ l} by AMISTD_1:41;
    hence thesis by Lm2;
  end;
end;

registration
  let a, b;
  cluster JUMP MultBy(a,b) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(MultBy(a,b),l)={succ
    l} by AMISTD_1:41;
    hence thesis by Lm2;
  end;
end;

registration
  let a, b;
  cluster JUMP Divide(a,b) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(Divide(a,b),l)={succ
    l} by AMISTD_1:41;
    hence thesis by Lm2;
  end;
end;

canceled 7;

theorem Th48:
  NIC(SCM-goto k, il) = {k}
proof
  now
    let x be set;
A1: now
      reconsider il1 = il as Element of ObjectKind IC SCM by COMPOS_1:def 6;
      reconsider I = SCM-goto k as Element of (the Object-Kind of SCM).il
       by COMPOS_1:def 8;
      set t =the  State of SCM,
      Q = the (the Instructions of SCM)-valued ManySortedSet of NAT;
      assume
A2:   x = k;
      reconsider n = il as Element of NAT;
      reconsider u = t+*(IC SCM,il1)
       as Element of product the Object-Kind of SCM by PBOOLE:155;
      reconsider P = Q +* (il,I)
       as (the Instructions of SCM)-valued ManySortedSet of NAT;
A3:   P/.il = P.il by PBOOLE:158;
    IC SCM in dom t by COMPOS_1:9;
    then
A4: IC u = n by FUNCT_7:33;
    il in NAT;
    then il in dom Q by PARTFUN1:def 4;
    then
B4: P.n = I by FUNCT_7:33;
    then IC Following(P,u) = k by A3,A4,AMI_3:13;
      hence x in {IC Exec(SCM-goto k,s)
       where s is Element of product the Object-Kind of SCM
       : IC s = il} by A2,A4,A3,B4;
    end;
    now
      assume x in {IC Exec(SCM-goto k,s)
       where s is Element of product the Object-Kind of SCM
       : IC s = il};
      then ex s being Element of product the Object-Kind of SCM
      st x = IC Exec(SCM-goto k,s) & IC s = il;
      hence x = k by AMI_3:13;
    end;
    hence
    x in {k} iff x in {IC Exec(SCM-goto k,s)
       where s is Element of product the Object-Kind of SCM
     : IC s = il} by A1,TARSKI:def 1;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th49:
  JUMP SCM-goto k = {k}
proof
  set X = { NIC(SCM-goto k, il) : not contradiction };
  now
    let x be set;
    hereby
      set il1 = 1;
A1:   NIC(SCM-goto k, il1) in X;
      assume x in meet X;
      then x in NIC(SCM-goto k, il1) by A1,SETFAM_1:def 1;
      hence x in {k} by Th48;
    end;
    assume x in {k};
    then
A2: x = k by TARSKI:def 1;
A3: now
      let Y be set;
      assume Y in X;
      then consider il being Element of NAT such that
A4:   Y = NIC(SCM-goto k, il);
      NIC(SCM-goto k, il) = {k} by Th48;
      hence k in Y by A4,TARSKI:def 1;
    end;
    reconsider k as Element of NAT by ORDINAL1:def 13;
    NIC(SCM-goto k, k) in X;
    hence x in meet X by A2,A3,SETFAM_1:def 1;
  end;
  hence thesis by TARSKI:2;
end;

registration
  let i1;
  cluster JUMP SCM-goto i1 -> non empty trivial;
  coherence
  proof
    JUMP SCM-goto i1 = {i1} by Th49;
    hence thesis;
  end;
end;

theorem Th50:
  NIC(a=0_goto k, il) = {k, succ il}
proof
  set t =the  State of SCM,
      Q = the (the Instructions of SCM)-valued ManySortedSet of NAT;
  hereby
    let x be set;
    assume x in NIC(a=0_goto k, il);
    then consider s being Element of product the Object-Kind of SCM
    such that
A1: x = IC Exec(a=0_goto k,s) & IC s = il;
    per cases;
    suppose
      s.a = 0;
      then x = k by A1,AMI_3:14;
      hence x in {k, succ il} by TARSKI:def 2;
    end;
    suppose
      s.a <> 0;
      then x = succ il by A1,AMI_3:14;
      hence x in {k, succ il} by TARSKI:def 2;
    end;
  end;
  let x be set;
  reconsider I = a=0_goto k as Element of (the Object-Kind of SCM).il
   by COMPOS_1:def 8;
A2: IC SCM <> a by AMI_5:20;
  reconsider il1 = il as Element of ObjectKind IC SCM by COMPOS_1:def 6;
  reconsider n = il as Element of NAT;
      reconsider u = t+*(IC SCM,il1)
       as Element of product the Object-Kind of SCM by PBOOLE:155;
      reconsider P = Q +* (il,I)
       as (the Instructions of SCM)-valued ManySortedSet of NAT;
  assume
A4: x in {k,succ il};
  per cases by A4,TARSKI:def 2;
  suppose
A5: x = k;
    reconsider v = u+*(a .--> 0)
     as Element of product the Object-Kind of SCM by PBOOLE:155;
xx: IC SCM in dom t by COMPOS_1:9;
A6: dom (a .--> 0) = {a} by FUNCOP_1:19;
    then not IC SCM in dom (a .--> 0) by A2,TARSKI:def 1;
    then
A7: IC v = IC u by FUNCT_4:12
      .= n by FUNCT_7:33,xx;
B9:   P/.il = P.il by PBOOLE:158;
    il in NAT;
    then il in dom Q by PARTFUN1:def 4;
    then
A9: P.il = I by FUNCT_7:33;
    a in dom (a .--> 0) by A6,TARSKI:def 1;
    then
   v.a = (a .--> 0).a by FUNCT_4:14
      .= 0 by FUNCOP_1:87;
    then IC Following(P,v) = k by A7,A9,AMI_3:14,B9;
    hence thesis by A5,A7,A9,B9;
  end;
  suppose
A10: x = succ il;
    reconsider v = u+*(a .--> 1)
     as Element of product the Object-Kind of SCM by PBOOLE:155;
xx: IC SCM in dom t by COMPOS_1:9;
A11: dom (a .--> 1) = {a} by FUNCOP_1:19;
    then not IC SCM in dom (a .--> 1) by A2,TARSKI:def 1;
    then
A12: IC v = IC u by FUNCT_4:12
      .= n by FUNCT_7:33,xx;
B14:   P/.il = P.il by PBOOLE:158;
    il in NAT;
    then il in dom Q by PARTFUN1:def 4;
    then
A14: P.il = I by FUNCT_7:33;
    a in dom (a .--> 1) by A11,TARSKI:def 1;
    then v.a = (a .--> 1).a by FUNCT_4:14
      .= 1 by FUNCOP_1:87;
    then IC Following(P,v) = succ il by A12,A14,AMI_3:14,B14;
    hence thesis by A10,A12,A14,B14;
  end;
end;

theorem Th51:
  JUMP (a=0_goto k) = {k}
proof
  set X = { NIC(a=0_goto k, il) : not contradiction };
  now
    let x be set;
A1: now
      let Y be set;
      assume Y in X;
      then consider il being Element of NAT such that
A2:   Y = NIC(a=0_goto k, il);
      NIC(a=0_goto k, il) = {k, succ il} by Th50;
      hence k in Y by A2,TARSKI:def 2;
    end;
    hereby
      set il1 = 1, il2 = 2;
      assume
A3:   x in meet X;
A4:   NIC(a=0_goto k, il2) = {k, succ il2} by Th50;
      NIC(a=0_goto k, il2) in X;
      then x in NIC(a=0_goto k, il2) by A3,SETFAM_1:def 1;
      then
A5:   x = k or x = succ il2 by A4,TARSKI:def 2;
A6:   NIC(a=0_goto k, il1) = {k, succ il1} by Th50;
      NIC(a=0_goto k, il1) in X;
      then x in NIC(a=0_goto k, il1) by A3,SETFAM_1:def 1;
      then x = k or x = succ il1 by A6,TARSKI:def 2;
      hence x in {k} by A5,TARSKI:def 1;
    end;
    assume x in {k};
    then
A7: x = k by TARSKI:def 1;
    reconsider k as Element of NAT by ORDINAL1:def 13;
    NIC(a=0_goto k, k) in X;
    hence x in meet X by A7,A1,SETFAM_1:def 1;
  end;
  hence thesis by TARSKI:2;
end;

registration
  let a, i1;
  cluster JUMP (a =0_goto i1) -> non empty trivial;
  coherence
  proof
    JUMP (a =0_goto i1) = {i1} by Th51;
    hence thesis;
  end;
end;

theorem Th52:
  NIC(a>0_goto k, il) = {k, succ il}
proof
  set t =the  State of SCM,
      Q = the (the Instructions of SCM)-valued ManySortedSet of NAT;
  hereby
    let x be set;
    assume x in NIC(a>0_goto k, il);
    then consider s being Element of product the Object-Kind of SCM
    such that
A1: x = IC Exec(a>0_goto k,s) & IC s = il;
    per cases;
    suppose
      s.a > 0;
      then x = k by A1,AMI_3:15;
      hence x in {k, succ il} by TARSKI:def 2;
    end;
    suppose
      s.a <= 0;
      then x = succ il by A1,AMI_3:15;
      hence x in {k, succ il} by TARSKI:def 2;
    end;
  end;
  let x be set;
  reconsider I = a>0_goto k as Element of (the Object-Kind of SCM).il
   by COMPOS_1:def 8;
A2: IC SCM <> a by AMI_5:20;
  reconsider il1 = il as Element of ObjectKind IC SCM by COMPOS_1:def 6;
      reconsider u = t+*(IC SCM,il1)
       as Element of product the Object-Kind of SCM by PBOOLE:155;
      reconsider P = Q +* (il,I)
       as (the Instructions of SCM)-valued ManySortedSet of NAT;
   reconsider n = il1 as Element of NAT;
  assume
A4: x in {k,succ il};
  per cases by A4,TARSKI:def 2;
  suppose
A5: x = k;
    reconsider v = u+*(a .--> 1)
     as Element of product the Object-Kind of SCM by PBOOLE:155;
xx: IC SCM in dom t by COMPOS_1:9;
A6: dom (a .--> 1) = {a} by FUNCOP_1:19;
    then not IC SCM in dom (a .--> 1) by A2,TARSKI:def 1;
    then
A7: IC v = IC u by FUNCT_4:12
      .= n by FUNCT_7:33,xx;
B9:   P/.il = P.il by PBOOLE:158;
    il in NAT;
    then il in dom Q by PARTFUN1:def 4;
    then
A9: P.il = I by FUNCT_7:33;
    a in dom (a .--> 1) by A6,TARSKI:def 1;
    then v.a = (a .--> 1).a by FUNCT_4:14
      .= 1 by FUNCOP_1:87;
    then IC Following(P,v) = k by A7,A9,AMI_3:15,B9;
    hence thesis by A5,A7,A9,B9;
  end;
  suppose
A10: x = succ il;
    reconsider v = u+*(a .--> 0)
     as Element of product the Object-Kind of SCM by PBOOLE:155;
xx: IC SCM in dom t by COMPOS_1:9;
A11: dom (a .--> 0) = {a} by FUNCOP_1:19;
    then not IC SCM in dom (a .--> 0) by A2,TARSKI:def 1;
    then
A12: IC v = IC u by FUNCT_4:12
      .= n by FUNCT_7:33,xx;
B14:   P/.il = P.il by PBOOLE:158;
    il in NAT;
    then il in dom Q by PARTFUN1:def 4;
    then
A14: P.il = I by FUNCT_7:33;
    a in dom (a .--> 0) by A11,TARSKI:def 1;
    then v.a = (a .--> 0).a by FUNCT_4:14
      .= 0 by FUNCOP_1:87;
    then IC Following(P,v) = succ il by A12,A14,AMI_3:15,B14;
    hence thesis by A10,A12,A14,B14;
  end;
end;

theorem Th53:
  JUMP (a>0_goto k) = {k}
proof
  set X = { NIC(a>0_goto k, il) : not contradiction };
  now
    let x be set;
A1: now
      let Y be set;
      assume Y in X;
      then consider il being Element of NAT such that
A2:   Y = NIC(a>0_goto k, il);
      NIC(a>0_goto k, il) = {k, succ il} by Th52;
      hence k in Y by A2,TARSKI:def 2;
    end;
    hereby
      set il1 = 1, il2 = 2;
      assume
A3:   x in meet X;
A4:   NIC(a>0_goto k, il2) = {k, succ il2} by Th52;
      NIC(a>0_goto k, il2) in X;
      then x in NIC(a>0_goto k, il2) by A3,SETFAM_1:def 1;
      then
A5:   x = k or x = succ il2 by A4,TARSKI:def 2;
A6:   NIC(a>0_goto k, il1) = {k, succ il1} by Th52;
      NIC(a>0_goto k, il1) in X;
      then x in NIC(a>0_goto k, il1) by A3,SETFAM_1:def 1;
      then x = k or x = succ il1 by A6,TARSKI:def 2;
      hence x in {k} by A5,TARSKI:def 1;
    end;
    assume x in {k};
    then
A7: x = k by TARSKI:def 1;
    reconsider k as Element of NAT by ORDINAL1:def 13;
    NIC(a>0_goto k, k) in X;
    hence x in meet X by A7,A1,SETFAM_1:def 1;
  end;
  hence thesis by TARSKI:2;
end;

registration
  let a, i1;
  cluster JUMP (a >0_goto i1) -> non empty trivial;
  coherence
  proof
    JUMP (a >0_goto i1) = {i1} by Th53;
    hence thesis;
  end;
end;

theorem Th54:
  SUCC(il,SCM) = {il, succ il}
proof
  set X = { NIC(I, il) \ JUMP I where I is Element of the Instructions of SCM:
  not contradiction };
  set N = {il, succ il};
  now
    let x be set;
    hereby
      assume x in union X;
      then consider Y being set such that
A1:   x in Y and
A2:   Y in X by TARSKI:def 4;
      consider i being Element of the Instructions of SCM such that
A3:   Y = NIC(i, il) \ JUMP i by A2;
      per cases by AMI_3:69;
      suppose
        i = [0,{},{}];
        then x in {il} \ JUMP halt SCM by A1,A3,AMISTD_1:15,AMI_3:71;
        then x = il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = a:=b;
        then consider a, b such that
A4:     i = a:=b;
        x in {succ il} \ JUMP (a:=b) by A1,A3,A4,AMISTD_1:41;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = AddTo(a,b);
        then consider a, b such that
A5:     i = AddTo(a,b);
        x in {succ il} \ JUMP AddTo(a,b) by A1,A3,A5,AMISTD_1:41;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = SubFrom(a,b);
        then consider a, b such that
A6:     i = SubFrom(a,b);
        x in {succ il} \ JUMP SubFrom(a,b) by A1,A3,A6,AMISTD_1:41;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = MultBy(a,b);
        then consider a, b such that
A7:     i = MultBy(a,b);
        x in {succ il} \ JUMP MultBy(a,b) by A1,A3,A7,AMISTD_1:41;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = Divide(a,b);
        then consider a, b such that
A8:     i = Divide(a,b);
        x in {succ il} \ JUMP Divide(a,b) by A1,A3,A8,AMISTD_1:41;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex k st i = SCM-goto k;
        then consider k such that
A9:     i = SCM-goto k;
        x in {k} \ JUMP i by A1,A3,A9,Th48;
        then x in {k} \ {k} by A9,Th49;
        hence x in N by XBOOLE_1:37;
      end;
      suppose
        ex a,k st i = a=0_goto k;
        then consider a, k such that
A10:    i = a=0_goto k;
A11:    NIC(i, il) = {k, succ il} by A10,Th50;
        x in NIC(i, il) by A1,A3,XBOOLE_0:def 5;
        then
A12:    x = k or x = succ il by A11,TARSKI:def 2;
        x in NIC(i, il) \ {k} by A1,A3,A10,Th51;
        then not x in {k} by XBOOLE_0:def 5;
        hence x in N by A12,TARSKI:def 1,def 2;
      end;
      suppose
        ex a,k st i = a>0_goto k;
        then consider a, k such that
A13:    i = a>0_goto k;
A14:    NIC(i, il) = {k, succ il} by A13,Th52;
        x in NIC(i, il) by A1,A3,XBOOLE_0:def 5;
        then
A15:    x = k or x = succ il by A14,TARSKI:def 2;
        x in NIC(i, il) \ {k} by A1,A3,A13,Th53;
        then not x in {k} by XBOOLE_0:def 5;
        hence x in N by A15,TARSKI:def 1,def 2;
      end;
    end;
    assume
A16: x in {il, succ il};
    per cases by A16,TARSKI:def 2;
    suppose
A17:  x = il;
      set i = halt SCM;
      NIC(i, il) \ JUMP i = {il} by AMISTD_1:15;
      then
A18:  {il} in X;
      x in {il} by A17,TARSKI:def 1;
      hence x in union X by A18,TARSKI:def 4;
    end;
    suppose
A19:  x = succ il;
      set a =the  Data-Location;
      set i = AddTo(a,a);
      NIC(i, il) \ JUMP i = {succ il} by AMISTD_1:41;
      then
A20:  {succ il} in X;
      x in {succ il} by A19,TARSKI:def 1;
      hence x in union X by A20,TARSKI:def 4;
    end;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th55:
for k being Element of NAT holds k+1 in SUCC(k,SCM) &
 for j being Element of NAT st j in SUCC(k,SCM) holds k <= j
proof
  let k be Element of NAT;
  reconsider fk = k as Element of NAT;
A1: SUCC(k,SCM) = {k, succ (fk)} by Th54;
  hence k+1 in SUCC(k,SCM) by TARSKI:def 2;
  let j be Element of NAT;
  assume
A2: j in SUCC(k,SCM);
  reconsider fk = k as Element of NAT;
  per cases by A1,A2,TARSKI:def 2;
  suppose
    j = k;
    hence thesis;
  end;
  suppose
    j = succ (fk);
    hence thesis by NAT_1:11;
  end;
end;

registration
  cluster SCM -> standard;
  coherence by Th55,AMISTD_1:19;
end;

registration
  cluster InsCode halt SCM -> jump-only InsType of SCM;
  coherence
  proof
    now
      let s be State of SCM, o be Object of SCM, I be Instruction of SCM;
      assume that
A1:   InsCode I = InsCode halt SCM and
      o in Data-Locations SCM;
      I = halt SCM by A1,AMI_5:37,46;
      hence Exec(I, s).o = s.o by EXTPRO_1:def 3;
    end;
    hence thesis by AMISTD_1:def 3;
  end;
end;

registration
  cluster halt SCM -> jump-only;
  coherence
  proof
    thus InsCode halt SCM is jump-only;
  end;
end;

registration
  let i1;
  cluster InsCode SCM-goto i1 -> jump-only InsType of SCM;
  coherence
  proof
   let T be InsType of SCM such that
A1:  T = InsCode SCM-goto i1;
      let s be State of SCM, o be Object of SCM, I be Instruction of SCM;
      assume that
A2:   InsCode I = T and
A3:   o in Data-Locations SCM;
      InsCode I = 6 by A2,A1,RECDEF_2:def 1;
      then
A4:   ex i2 st I = SCM-goto i2 by AMI_5:52;
        o is Data-Location by A3,AMI_3:72,def 2;
        hence Exec(I, s).o = s.o by A4,AMI_3:13;
  end;
end;

registration
  let i1;
  cluster SCM-goto i1 -> jump-only non sequential non ins-loc-free;
  coherence
  proof
    thus InsCode SCM-goto i1 is jump-only;
    JUMP SCM-goto i1 <> {};
    hence SCM-goto i1 is non sequential by AMISTD_1:43;
    dom JumpPart SCM-goto i1 = dom <*i1*> by RECDEF_2:def 2
      .= {1} by FINSEQ_1:4,def 8;
   hence JumpPart SCM-goto i1 is not empty;
  end;
end;

registration
  let a, i1;
  cluster InsCode (a =0_goto i1) -> jump-only InsType of SCM;
  coherence
  proof
    set S = SCM;
    now
      let s be State of S, o be Object of S, I be Instruction of S;
      assume that
A1:   InsCode I = InsCode (a =0_goto i1) and
A2:   o in Data-Locations SCM;
      InsCode I = 7 by A1,RECDEF_2:def 1;
      then
A3:   ex i2, b st I = (b =0_goto i2) by AMI_5:53;
        o is Data-Location by A2,AMI_3:72,def 2;
        hence Exec(I, s).o = s.o by A3,AMI_3:14;
    end;
    hence thesis by AMISTD_1:def 3;
  end;
  cluster InsCode (a >0_goto i1) -> jump-only InsType of SCM;
  coherence
  proof
    set S = SCM;
    now
      let s be State of S, o be Object of S, I be Instruction of S;
      assume that
A4:   InsCode I = InsCode (a >0_goto i1) and
A5:   o in Data-Locations SCM;
      InsCode I = 8 by A4,RECDEF_2:def 1;
      then
A6:   ex i2, b st I = (b >0_goto i2) by AMI_5:54;
        o is Data-Location by A5,AMI_3:72,def 2;
        hence Exec(I, s).o = s.o by A6,AMI_3:15;
    end;
    hence thesis by AMISTD_1:def 3;
  end;
end;

registration
  let a, i1;
  cluster a =0_goto i1 -> jump-only non sequential non ins-loc-free;
  coherence
  proof
    thus InsCode (a =0_goto i1) is jump-only;
    JUMP (a =0_goto i1) <> {};
    hence a =0_goto i1 is non sequential by AMISTD_1:43;
    dom JumpPart (a =0_goto i1) = dom <*i1*> by RECDEF_2:def 2
      .= {1} by FINSEQ_1:4,55;
    hence JumpPart(a =0_goto i1) is not empty;
  end;
  cluster a >0_goto i1 -> jump-only non sequential non ins-loc-free;
  coherence
  proof
    thus InsCode (a >0_goto i1) is jump-only;
    JUMP (a >0_goto i1) <> {};
    hence a >0_goto i1 is non sequential by AMISTD_1:43;
    dom JumpPart (a >0_goto i1) = dom <*i1*> by RECDEF_2:def 2
      .= {1} by FINSEQ_1:4,55;
   hence JumpPart(a >0_goto i1) is not empty;
  end;
end;

Lm3: dl.0 <> dl.1 by AMI_3:52;

registration
  let a, b;
  cluster InsCode (a:=b) -> non jump-only InsType of SCM;
  coherence
  proof
    set w =the  State of SCM;
    set t = w+*((dl.0, dl.1)-->(0,1));
A1: InsCode (a:=b) = 1 by RECDEF_2:def 1
      .= InsCode (dl.0:=dl.1) by RECDEF_2:def 1;
A2: dl.0 in Data-Locations SCM by AMI_3:73;
A3: dom ((dl.0, dl.1)-->(0,1)) = {dl.0, dl.1} by FUNCT_4:65;
    then
A4: dl.1 in dom ((dl.0, dl.1)-->(0,1)) by TARSKI:def 2;
    dl.0 in dom ((dl.0, dl.1)-->(0,1)) by A3,TARSKI:def 2;
    then
A5: t.dl.0 = (dl.0, dl.1)-->(0,1).dl.0 by FUNCT_4:14
      .= 0 by AMI_3:52,FUNCT_4:66;
    Exec((dl.0:=dl.1), t).dl.0 = t.dl.1 by AMI_3:8
      .= (dl.0, dl.1)-->(0,1).dl.1 by A4,FUNCT_4:14
      .= 1 by FUNCT_4:66;
    hence thesis by A1,A2,A5,AMISTD_1:def 3;
  end;
  cluster InsCode AddTo(a,b) -> non jump-only InsType of SCM;
  coherence
  proof
    set w =the  State of SCM;
    set t = w+*((dl.0, dl.1)-->(0,1));
A6: InsCode AddTo(a,b) = 2 by RECDEF_2:def 1
      .= InsCode AddTo(dl.0, dl.1) by RECDEF_2:def 1;
A7: dom ((dl.0, dl.1)-->(0,1)) = {dl.0, dl.1} by FUNCT_4:65;
    then dl.0 in dom ((dl.0, dl.1)-->(0,1)) by TARSKI:def 2;
    then
A8: t.dl.0 = (dl.0, dl.1)-->(0,1).dl.0 by FUNCT_4:14
      .= 0 by AMI_3:52,FUNCT_4:66;
A9: dl.0 in Data-Locations SCM by AMI_3:73;
    dl.1 in dom ((dl.0, dl.1)-->(0,1)) by A7,TARSKI:def 2;
    then t.dl.1 = (dl.0, dl.1)-->(0,1).dl.1 by FUNCT_4:14
      .= 1 by FUNCT_4:66;
    then dl.0 <> IC SCM &
    Exec(AddTo(dl.0, dl.1), t).dl.0 = (0 qua Nat)+1 by A8,AMI_3:9,57;
    hence thesis by A6,A8,AMISTD_1:def 3,A9;
  end;
  cluster InsCode SubFrom(a,b) -> non jump-only InsType of SCM;
  coherence
  proof
    set w =the  State of SCM;
    set t = w+*((dl.0, dl.1)-->(0,1));
A10: InsCode SubFrom(a,b) = 3 by RECDEF_2:def 1
      .= InsCode SubFrom(dl.0, dl.1) by RECDEF_2:def 1;
A11: dom ((dl.0, dl.1)-->(0,1)) = {dl.0, dl.1} by FUNCT_4:65;
    then dl.0 in dom ((dl.0, dl.1)-->(0,1)) by TARSKI:def 2;
    then
A12: t.dl.0 = (dl.0, dl.1)-->(0,1).dl.0 by FUNCT_4:14
      .= 0 by AMI_3:52,FUNCT_4:66;
A13: dl.0 in Data-Locations SCM by AMI_3:73;
    dl.1 in dom ((dl.0, dl.1)-->(0,1)) by A11,TARSKI:def 2;
    then
A14: t.dl.1 = (dl.0, dl.1)-->(0,1).dl.1 by FUNCT_4:14
      .= 1 by FUNCT_4:66;
    Exec(SubFrom(dl.0, dl.1), t).dl.0 = t.dl.0 - t.dl.1 by AMI_3:10
      .= -1 by A12,A14;
    hence thesis by A10,A12,AMISTD_1:def 3,A13;
  end;
  cluster InsCode MultBy(a,b) -> non jump-only InsType of SCM;
  coherence
  proof
    set w =the  State of SCM;
    set t = w+*((dl.0, dl.1)-->(1,0));
A15: InsCode MultBy(a,b) = 4 by RECDEF_2:def 1
      .= InsCode MultBy(dl.0, dl.1) by RECDEF_2:def 1;
A16: dom ((dl.0, dl.1)-->(1,0)) = {dl.0, dl.1} by FUNCT_4:65;
    then dl.0 in dom ((dl.0, dl.1)-->(1,0)) by TARSKI:def 2;
    then
A17: t.dl.0 = (dl.0, dl.1)-->(1,0).dl.0 by FUNCT_4:14
      .= 1 by AMI_3:52,FUNCT_4:66;
A18: dl.0 in Data-Locations SCM by AMI_3:73;
    dl.1 in dom ((dl.0, dl.1)-->(1,0)) by A16,TARSKI:def 2;
    then
A19: t.dl.1 = (dl.0, dl.1)-->(1,0).dl.1 by FUNCT_4:14
      .= 0 by FUNCT_4:66;
    Exec(MultBy(dl.0, dl.1), t).dl.0 = t.dl.0 * t.dl.1 by AMI_3:11
      .= 0 by A19;
    hence thesis by A15,A17,AMISTD_1:def 3,A18;
  end;
  cluster InsCode Divide(a,b) -> non jump-only InsType of SCM;
  coherence
  proof
    set w =the  State of SCM;
    set t = w+*((dl.0, dl.1)-->(7,3));
A20: InsCode Divide(a,b) = 5 by RECDEF_2:def 1
      .= InsCode Divide(dl.0, dl.1) by RECDEF_2:def 1;
A21: dom ((dl.0, dl.1)-->(7,3)) = {dl.0, dl.1} by FUNCT_4:65;
    then dl.0 in dom ((dl.0, dl.1)-->(7,3)) by TARSKI:def 2;
    then
A22: t.dl.0 = (dl.0, dl.1)-->(7,3).dl.0 by FUNCT_4:14
      .= 7 by AMI_3:52,FUNCT_4:66;
A23: 7 = 2 * 3 + 1;
A24: dl.0 in Data-Locations SCM by AMI_3:73;
    dl.1 in dom ((dl.0, dl.1)-->(7,3)) by A21,TARSKI:def 2;
    then t.dl.1 = (dl.0, dl.1)-->(7,3).dl.1 by FUNCT_4:14
      .= 3 by FUNCT_4:66;
    then Exec(Divide(dl.0, dl.1), t).dl.0 = 7 div (3 qua Element of NAT) by A22
,Lm3,AMI_3:12
      .= 2 by A23,NAT_D:def 1;
    hence thesis by A20,A22,AMISTD_1:def 3,A24;
  end;
end;

registration
  let a, b;
  cluster a:=b -> non jump-only;
  coherence
  proof
    thus InsCode (a:=b) is not jump-only;
  end;
  cluster AddTo(a,b) -> non jump-only;
  coherence
  proof
    thus InsCode AddTo(a,b) is not jump-only;
  end;
  cluster SubFrom(a,b) -> non jump-only;
  coherence
  proof
    thus InsCode SubFrom(a,b) is not jump-only;
  end;
  cluster MultBy(a,b) -> non jump-only;
  coherence
  proof
    thus InsCode MultBy(a,b) is not jump-only;
  end;
  cluster Divide(a,b) -> non jump-only;
  coherence
  proof
    thus InsCode Divide(a,b) is not jump-only;
  end;
end;

registration
  cluster SCM -> homogeneous with_explicit_jumps;
  coherence
  proof
    thus SCM is homogeneous
    proof
      let I, J be Instruction of SCM such that
A1:   InsCode I = InsCode J;
A2:   J = [0,{},{}] or (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or
(ex a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex k st J = SCM-goto k) or (ex a,k st J = a=0_goto k) or ex a,
      k st J = a>0_goto k by AMI_3:69;
      per cases by AMI_3:69;
      suppose
        I = [0,{},{}];
        hence thesis by A1,A2,AMI_3:71,AMI_5:37,RECDEF_2:def 1;
      end;
      suppose
        ex a,b st I = a:=b;
        then consider a, b such that
A3:     I = a:=b;
A4:     InsCode I = 1 by A3,RECDEF_2:def 1;
        now
          per cases by AMI_3:69;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A3,AMI_3:71;
          end;
          suppose
            ex a,b st J = a:=b;
            then consider d1, d2 such that
A5:         J = d1:=d2;
            thus dom JumpPart I = dom {} by A3,RECDEF_2:def 2
              .= dom JumpPart J by A5,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = AddTo(a,b)) or (ex a,b st J = SubFrom(a,b)
) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J = Divide(a,b)) or (ex k st J
= SCM-goto k) or (ex a,k st J = a=0_goto k) or ex a,k st J = a>0_goto k;
            hence thesis by A1,A4,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = AddTo(a,b);
        then consider a, b such that
A6:     I = AddTo(a,b);
A7:     InsCode I = 2 by A6,RECDEF_2:def 1;
        now
          per cases by AMI_3:69;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A6,AMI_3:71;
          end;
          suppose
            ex a,b st J = AddTo(a,b);
            then consider d1, d2 such that
A8:         J = AddTo(d1,d2);
            thus dom JumpPart I = dom {} by A6,RECDEF_2:def 2
              .= dom JumpPart J by A8,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = SubFrom(a,b)) or (
ex a,b st J = MultBy(a,b)) or (ex a,b st J = Divide(a,b)) or
 (ex k st J = SCM-goto
            k) or (ex a,k st J = a=0_goto k) or ex a,k st J = a>0_goto k;
            hence thesis by A1,A7,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = SubFrom(a,b);
        then consider a, b such that
A9:     I = SubFrom(a,b);
A10:    InsCode I = 3 by A9,RECDEF_2:def 1;
        now
          per cases by AMI_3:69;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A9,AMI_3:71;
          end;
          suppose
            ex a,b st J = SubFrom(a,b);
            then consider d1, d2 such that
A11:        J = SubFrom(d1,d2);
            thus dom JumpPart I = dom {} by A9,RECDEF_2:def 2
              .= dom JumpPart J by A11,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = MultBy(a,b)) or (ex a,b st J = Divide(a,b)) or
 (ex k st J = SCM-goto k
            ) or (ex a,k st J = a=0_goto k) or ex a,k st J = a>0_goto k;
            hence thesis by A1,A10,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = MultBy(a,b);
        then consider a, b such that
A12:    I = MultBy(a,b);
A13:    InsCode I = 4 by A12,RECDEF_2:def 1;
        now
          per cases by AMI_3:69;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A12,AMI_3:71;
          end;
          suppose
            ex a,b st J = MultBy(a,b);
            then consider d1, d2 such that
A14:        J = MultBy(d1,d2);
            thus dom JumpPart I = dom {} by A12,RECDEF_2:def 2
              .= dom JumpPart J by A14,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = Divide(a,b)) or
 (ex k st J = SCM-goto
            k) or (ex a,k st J = a=0_goto k) or ex a,k st J = a>0_goto k;
            hence thesis by A1,A13,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = Divide(a,b);
        then consider a, b such that
A15:    I = Divide(a,b);
A16:    InsCode I = 5 by A15,RECDEF_2:def 1;
        now
          per cases by AMI_3:69;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A15,AMI_3:71;
          end;
          suppose
            ex a,b st J = Divide(a,b);
            then consider d1, d2 such that
A17:        J = Divide(d1,d2);
            thus dom JumpPart I = dom {} by A15,RECDEF_2:def 2
              .= dom JumpPart J by A17,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or
 (ex k st J = SCM-goto
            k) or (ex a,k st J = a=0_goto k) or ex a,k st J = a>0_goto k;
            hence thesis by A1,A16,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex k st I = SCM-goto k;
        then consider k such that
A18:    I = SCM-goto k;
A19:    InsCode I = 6 by A18,RECDEF_2:def 1;
        now
          per cases by AMI_3:69;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A18,AMI_3:71,AMI_5:37,RECDEF_2:def 1;
          end;
          suppose
            ex k st J = SCM-goto k;
            then consider k1 such that
A20:        J = SCM-goto k1;
            thus dom JumpPart I = dom <*k*> by A18,RECDEF_2:def 2
              .= Seg 1 by FINSEQ_1:def 8
              .= dom <*k1*> by FINSEQ_1:def 8
              .= dom JumpPart J by A20,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex a,k st J = a=0_goto k) or ex a,k st J = a>0_goto k;
            hence thesis by A1,A19,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,k st I = a=0_goto k;
        then consider a, k such that
A21:    I = a=0_goto k;
A22:    InsCode I = 7 by A21,RECDEF_2:def 1;
        now
          per cases by AMI_3:69;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A21,AMI_3:71,AMI_5:37,RECDEF_2:def 1;
          end;
          suppose
            ex d1,k st J = d1 =0_goto k;
            then consider d1, k1 such that
A23:        J = d1 =0_goto k1;
            thus dom JumpPart I = dom <*k*> by A21,RECDEF_2:def 2
              .= Seg 1 by FINSEQ_1:55
              .= dom <*k1*> by FINSEQ_1:55
              .= dom JumpPart J by A23,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex k st J = SCM-goto k) or ex a,k st J = a>0_goto k;
            hence thesis by A1,A22,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,k st I = a>0_goto k;
        then consider a, k such that
A24:    I = a>0_goto k;
A25:    InsCode I = 8 by A24,RECDEF_2:def 1;
        now
          per cases by AMI_3:69;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A24,AMI_3:71,AMI_5:37,RECDEF_2:def 1;
          end;
          suppose
            ex d1,k st J = d1 >0_goto k;
            then consider d1, k1 such that
A26:        J = d1 >0_goto k1;
            thus dom JumpPart I = dom <*k*> by A24,RECDEF_2:def 2
              .= Seg 1 by FINSEQ_1:55
              .= dom <*k1*> by FINSEQ_1:55
              .= dom JumpPart J by A26,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex k st J = SCM-goto k) or ex a,k st J = a=0_goto k;
            hence thesis by A1,A25,RECDEF_2:def 1;
          end;
        end;
        hence thesis;
      end;
    end;
    thus SCM is with_explicit_jumps
    proof
     let I be Instruction of SCM;
     thus JUMP I c= rng JumpPart I
     proof
      let f be set such that
A27:  f in JUMP I;
      per cases by AMI_3:69;
      suppose
        I = [0,{},{}];
        hence thesis by A27,AMI_3:71;
      end;
      suppose
        ex a,b st I = a:=b;
        hence thesis by A27;
      end;
      suppose
        ex a,b st I = AddTo(a,b);
        hence thesis by A27;
      end;
      suppose
        ex a,b st I = SubFrom(a,b);
        hence thesis by A27;
      end;
      suppose
        ex a,b st I = MultBy(a,b);
        hence thesis by A27;
      end;
      suppose
        ex a,b st I = Divide(a,b);
        hence thesis by A27;
      end;
      suppose
A28:    ex k st I = SCM-goto k;
        consider k1 such that
A29:    I = SCM-goto k1 by A28;
A30:    JumpPart SCM-goto k1 = <*k1*> by RECDEF_2:def 2;
A31:      rng<*k1*> = {k1} by FINSEQ_1:56;
        JUMP SCM-goto k1 = {k1} by Th49;
:::        then f = k1 by A27,A29,TARSKI:def 1;
        hence thesis by A27,A29,A30,A31,TARSKI:def 1;
      end;
      suppose
A32:    ex a,k1 st I = a=0_goto k1;
        consider a, k1 such that
A33:    I = a=0_goto k1 by A32;
A34:    JumpPart (a=0_goto k1) = <*k1*> by RECDEF_2:def 2;
A35:      rng<*k1*> = {k1} by FINSEQ_1:56;
        JUMP (a=0_goto k1) = {k1} by Th51;
:::        then f = k1 by A27,A33,TARSKI:def 1;
        hence thesis by A27,A33,A34,A35,TARSKI:def 1;
      end;
      suppose
A36:    ex a,k1 st I = a>0_goto k1;
        consider a, k1 such that
A37:    I = a>0_goto k1 by A36;
A38:    JumpPart (a>0_goto k1) = <*k1*> by RECDEF_2:def 2;
A39:      rng<*k1*> = {k1} by FINSEQ_1:56;
        JUMP (a>0_goto k1) = {k1} by Th53;
:::        then f = k1 by A27,A37,TARSKI:def 1;
        hence thesis by A27,A37,A38,A39,TARSKI:def 1;
      end;
    end;
    let f being set;
    assume f in rng JumpPart I;
    then consider k being set such that
A40: k in dom JumpPart I and
A41: f = (JumpPart I).k by FUNCT_1:def 5;
    per cases by AMI_3:69;
    suppose
      I = [0,{},{}];
      then dom JumpPart I = dom {} by RECDEF_2:def 2;
      hence thesis by A40;
    end;
    suppose
      ex a,b st I = a:=b;
      then consider a, b such that
A42:  I = a:=b;
      k in dom {} by A40,A42,RECDEF_2:def 2;
      hence thesis;
    end;
    suppose
      ex a,b st I = AddTo(a,b);
      then consider a, b such that
A43:  I = AddTo(a,b);
      k in dom {} by A40,A43,RECDEF_2:def 2;
      hence thesis;
    end;
    suppose
      ex a,b st I = SubFrom(a,b);
      then consider a, b such that
A44:  I = SubFrom(a,b);
      k in dom {} by A40,A44,RECDEF_2:def 2;
      hence thesis;
    end;
    suppose
      ex a,b st I = MultBy(a,b);
      then consider a, b such that
A45:  I = MultBy(a,b);
      k in dom {} by A40,A45,RECDEF_2:def 2;
      hence thesis;
    end;
    suppose
      ex a,b st I = Divide(a,b);
      then consider a, b such that
A46:  I = Divide(a,b);
      k in dom {} by A40,A46,RECDEF_2:def 2;
      hence thesis;
    end;
    suppose
      ex k st I = SCM-goto k;
      then consider k1 such that
A47:  I = SCM-goto k1;
A48:  JumpPart I = <*k1*> by A47,RECDEF_2:def 2;
      then k = 1 by A40,FINSEQ_1:111;
      then
A49:  f = k1 by A48,A41,FINSEQ_1:def 8;
      JUMP I = {k1} by A47,Th49;
      hence thesis by A49,TARSKI:def 1;
    end;
    suppose
      ex a,k st I = a=0_goto k;
      then consider a, k1 such that
A50:  I = a=0_goto k1;
A51:  JumpPart I = <*k1*> by A50,RECDEF_2:def 2;
      then k = 1  by A40,FINSEQ_1:111;
      then
A52:  f = k1 by A51,A41,FINSEQ_1:57;
      JUMP I = {k1} by A50,Th51;
      hence thesis by A52,TARSKI:def 1;
    end;
    suppose
      ex a,k1 st I = a>0_goto k1;
      then consider a, k1 such that
A53:  I = a>0_goto k1;
A54:  JumpPart I = <*k1*> by A53,RECDEF_2:def 2;
      then k = 1 by A40,FINSEQ_1:111;
      then
A55:  f = k1 by A54,A41,FINSEQ_1:57;
      JUMP I = {k1} by A53,Th53;
      hence thesis by A55,TARSKI:def 1;
    end;
   end;
  end;
end;

registration
  cluster SCM -> regular J/A-independent;
  coherence
  proof
   thus SCM is regular
    proof
    let I be Instruction of SCM;
     set T = InsCode I;
A1:   JumpPart I in JumpParts T;
    per cases by Th7;
    suppose T = 0;
      then I = halt SCM by AMI_5:46;
     hence thesis;
    end;
    suppose T = 1;
      then JumpParts T = {{}} by Th19;
      then JumpPart I = {} by A1,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 2;
      then JumpParts T = {{}} by Th20;
      then JumpPart I = {} by A1,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 3;
      then JumpParts T = {{}} by Th21;
      then JumpPart I = {} by A1,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 4;
      then JumpParts T = {{}} by Th22;
      then JumpPart I = {} by A1,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 5;
      then JumpParts T = {{}} by Th23;
      then JumpPart I = {} by A1,TARSKI:def 1;
     hence thesis;
    end;
    suppose
A2: T = 6;
     then consider i2 such that
A3:    I = SCM-goto i2 by AMI_5:52;
     let k be set;
     assume
A4:      k in dom JumpPart I;
      for f being Function st f in JumpParts T holds k in dom f
       proof let f be Function;
        assume f in JumpParts T;
         then consider J being Instruction of SCM such that
A5:       f = JumpPart J and
A6:       InsCode J = T;
        thus k in dom f by A4,A5,A6,COMPOS_1:def 33;
       end;
      then k in dom product" JumpParts T by CARD_3:def 13;
      then k in {1} by A2,Th24;
      then k = 1 by TARSKI:def 1;
     hence (product" JumpParts InsCode I).k = NAT by A3,Th37;
    end;
    suppose
A7: T = 7;
     then consider i1,a such that
A8:    I = a=0_goto i1 by AMI_5:53;
     let k be set;
     assume
A9:      k in dom JumpPart I;
      for f being Function st f in JumpParts T holds k in dom f
       proof let f be Function;
        assume f in JumpParts T;
         then consider J being Instruction of SCM such that
A10:       f = JumpPart J and
A11:       InsCode J = T;
        thus k in dom f by A9,A10,A11,COMPOS_1:def 33;
       end;
      then k in dom product" JumpParts T by CARD_3:def 13;
      then k in {1} by A7,Th25;
      then k = 1 by TARSKI:def 1;
     hence (product" JumpParts InsCode I).k = NAT by A8,Th38;
    end;
    suppose
A12: T = 8;
     then consider i1,a such that
A13:    I = a>0_goto i1 by AMI_5:54;
     let k be set;
     assume
A14:      k in dom JumpPart I;
      for f being Function st f in JumpParts T holds k in dom f
       proof let f be Function;
        assume f in JumpParts T;
         then consider J being Instruction of SCM such that
A15:       f = JumpPart J and
A16:       InsCode J = T;
        thus k in dom f by A14,A15,A16,COMPOS_1:def 33;
       end;
      then k in dom product" JumpParts T by CARD_3:def 13;
      then k in {1} by A12,Th26;
      then k = 1 by TARSKI:def 1;
     hence (product" JumpParts InsCode I).k = NAT by A13,Th40;
    end;
   end;
   let T be InsType of SCM, f1,f2 be Function, p be set such that
A17: f1 in JumpParts T and
A18: f2 in product product" JumpParts T and
A19: [T,f1,p] in the Instructions of SCM;
    per cases by Th7;
    suppose T = 0 or T = 1 or T = 2 or T = 3 or T = 4 or T = 5;
     then
A20:  JumpParts T = {0} by Th18,Th19,Th20,Th21,Th22,Th23;
     f1 = 0 by A20,A17,TARSKI:def 1 .= f2 by A18,A20
,CARD_3:19,156,TARSKI:def 1;
    hence [T,f2,p] in the Instructions of SCM by A19;
    end;
    suppose
A21:    T = 6;
    reconsider J = [T,f1,p] as Instruction of SCM by A19;
A22: InsCode J = 6 by A21,RECDEF_2:def 1;
    then consider i1 being Element of NAT such that
A23:  J = SCM-goto i1 by AMI_5:52;
A24:   p = {} by A23,MCART_1:28;
A25: dom f2 = dom product" JumpParts T  by A18,CARD_3:18;
A26: dom f2 = {1} by A21,A25,Th24;
    then 1 in dom f2 by TARSKI:def 1;
    then f2.1 in (product" JumpParts T).1 by A25,A18,CARD_3:18;
    then reconsider l = f2.1 as Element of NAT by A23,A21,A22,Th37;
    set I = [T,f2,{}];
    I = SCM-goto l by A21,A26,FINSEQ_1:4,def 8;
    then  reconsider I as Instruction of SCM;
    f2 = JumpPart I by RECDEF_2:def 2;
    hence [T,f2,p] in the Instructions of SCM by A24;
    end;
    suppose
A27:    T = 7;
    reconsider J = [T,f1,p] as Instruction of SCM by A19;
A28: InsCode J = T by RECDEF_2:def 1;
    then consider i1,a such that
A29:  J = a=0_goto i1 by A27,AMI_5:53;
A30:   p = <*a*> by A29,MCART_1:28;
A31: dom f2 = dom product" JumpParts T  by A18,CARD_3:18;
A32: dom f2 = {1} by A27,A31,Th25;
    then 1 in dom f2 by TARSKI:def 1;
    then f2.1 in (product" JumpParts T).1 by A31,A18,CARD_3:18;
    then reconsider l = f2.1 as Element of NAT by A29,A28,Th38;
    set I = [T,f2,p];
    I = a=0_goto l by A30,A27,A32,FINSEQ_1:4,def 8;
    then  reconsider I as Instruction of SCM;
A33: InsCode I = T by RECDEF_2:def 1;
    consider i2,b such that
A34: I = b=0_goto i2 by A27,A33,AMI_5:53;
    thus [T,f2,p] in the Instructions of SCM by A34;
    end;
    suppose
A35:    T = 8;
    reconsider J = [T,f1,p] as Instruction of SCM by A19;
A36: InsCode J = T by RECDEF_2:def 1;
    then consider i1,a such that
A37:  J = a>0_goto i1 by A35,AMI_5:54;
A38:   p = <*a*> by A37,MCART_1:28;
A39: dom f2 = dom product" JumpParts T  by A18,CARD_3:18;
A40: dom f2 = {1} by A35,A39,Th26;
    then 1 in dom f2 by TARSKI:def 1;
    then f2.1 in (product" JumpParts T).1 by A39,A18,CARD_3:18;
    then reconsider l = f2.1 as Element of NAT by A37,A36,Th40;
    set I = [T,f2,p];
    I = a>0_goto l by A38,A35,A40,FINSEQ_1:4,def 8;
    then  reconsider I as Instruction of SCM;
A41: InsCode I = T by RECDEF_2:def 1;
    consider i2,b such that
A42: I = b>0_goto i2 by A35,A41,AMI_5:54;
    thus [T,f2,p] in the Instructions of SCM by A42;
    end;
  end;
end;

canceled 3;

theorem Th59:
  IncAddr(SCM-goto i1,k) = SCM-goto(i1+k)
proof
A1: JumpPart IncAddr(SCM-goto i1,k) = k + JumpPart SCM-goto i1
   by COMPOS_1:def 38;
 then
A2: dom JumpPart IncAddr(SCM-goto i1,k) = dom JumpPart SCM-goto i1
   by VALUED_1:def 2;
A3: dom JumpPart SCM-goto(i1+k)
 = dom <*i1+k*> by RECDEF_2:def 2
    .= Seg 1 by FINSEQ_1:def 8
    .= dom <*i1*> by FINSEQ_1:def 8
    .= dom JumpPart SCM-goto i1 by RECDEF_2:def 2;
A4: for x being set st x in dom JumpPart SCM-goto i1 holds (JumpPart
  IncAddr(SCM-goto i1,k)).x = (JumpPart SCM-goto(i1+k)).x
  proof
    let x be set;
    assume
A5: x in dom JumpPart SCM-goto i1;
    then x in dom <*i1*> by RECDEF_2:def 2;
    then
A6: x = 1 by FINSEQ_1:111;
    set f = (JumpPart SCM-goto i1).x;
A7: (JumpPart IncAddr(SCM-goto i1,k)).x = k + f by A5,A2,A1,VALUED_1:def 2;
    f = <*i1*>.x by RECDEF_2:def 2
      .= i1 by A6,FINSEQ_1:def 8;
    hence
    (JumpPart IncAddr(SCM-goto i1,k)).x = <*i1+k*>.x
     by A6,A7,FINSEQ_1:def 8
      .= (JumpPart SCM-goto(i1+k)).x
       by RECDEF_2:def 2;
  end;
A8: AddressPart IncAddr(SCM-goto i1,k) = AddressPart SCM-goto i1
          by COMPOS_1:def 38
    .= {} by RECDEF_2:def 3
    .= AddressPart SCM-goto(i1+k) by RECDEF_2:def 3;
A9: InsCode IncAddr(SCM-goto i1,k) = InsCode SCM-goto i1 by COMPOS_1:def 38
    .= 6 by RECDEF_2:def 1
    .= InsCode SCM-goto(i1+k) by RECDEF_2:def 1;
   JumpPart IncAddr(SCM-goto i1,k) = JumpPart SCM-goto(i1+k)
     by A2,A3,A4,FUNCT_1:9;
  hence thesis by A8,A9,COMPOS_1:7;
end;

theorem Th60:
  IncAddr(a=0_goto i1,k) = a=0_goto(i1+k)
proof
A1: JumpPart IncAddr(a=0_goto i1,k) = k + JumpPart (a=0_goto i1)
  by COMPOS_1:def 38;
  then
A2: dom JumpPart IncAddr(a=0_goto i1,k) = dom JumpPart (a=0_goto i1)
  by VALUED_1:def 2;
A3: dom JumpPart (a=0_goto(i1+k)) = dom <*i1 + k*> by RECDEF_2:def 2
    .= Seg 1 by FINSEQ_1:55
    .= dom <*i1*> by FINSEQ_1:55
    .= dom JumpPart (a=0_goto i1) by RECDEF_2:def 2;
A4: for x being set st x in dom JumpPart (a=0_goto i1) holds (JumpPart
IncAddr(a=0_goto i1,k)).x =
 (JumpPart (a=0_goto(i1+k))).x
  proof
    let x be set;
    assume
A5: x in dom JumpPart (a=0_goto i1);
    then x in dom <*i1*> by RECDEF_2:def 2;
    then
A6:   x = 1 by FINSEQ_1:111;
    set f = (JumpPart (a=0_goto i1)).x;
A7:   (JumpPart IncAddr(a=0_goto i1,k)).x = k + f by A1,A2,A5,VALUED_1:def 2;
      f = <*i1*>.x by RECDEF_2:def 2
        .= i1 by A6,FINSEQ_1:57;
      hence
      (JumpPart IncAddr(a=0_goto i1,k)).x
         = <*i1+k*>.x by A6,A7,FINSEQ_1:57
        .= (JumpPart (a=0_goto(i1+k))).x
         by RECDEF_2:def 2;
  end;
A8: AddressPart IncAddr(a=0_goto i1,k) = AddressPart (a=0_goto i1)
       by COMPOS_1:def 38
    .= <*a*> by RECDEF_2:def 3
    .= AddressPart (a=0_goto(i1+k)) by RECDEF_2:def 3;
A9: InsCode IncAddr(a=0_goto i1,k) = InsCode (a=0_goto i1) by COMPOS_1:def 38
    .= 7 by RECDEF_2:def 1
    .= InsCode (a=0_goto(i1+k)) by RECDEF_2:def 1;
   JumpPart IncAddr(a=0_goto i1,k) = JumpPart (a=0_goto(i1+k))
       by A2,A3,A4,FUNCT_1:9;
  hence thesis by A8,A9,COMPOS_1:7;
end;

theorem Th61:
  IncAddr(a>0_goto i1,k) = a>0_goto(i1+k)
proof
A1: JumpPart IncAddr(a>0_goto i1,k) = k + JumpPart (a>0_goto i1)
  by COMPOS_1:def 38;
  then
A2: dom JumpPart IncAddr(a>0_goto i1,k) = dom JumpPart (a>0_goto i1)
  by VALUED_1:def 2;
A3: dom JumpPart (a>0_goto(i1+k)) = dom <*i1 + k*> by RECDEF_2:def 2
    .= Seg 1 by FINSEQ_1:55
    .= dom <*i1*> by FINSEQ_1:55
    .= dom JumpPart (a>0_goto i1) by RECDEF_2:def 2;
A4: for x being set st x in dom JumpPart (a>0_goto i1) holds (JumpPart
IncAddr(a>0_goto i1,k)).x = (JumpPart (a>0_goto(i1+k))).x
  proof
    let x be set;
    assume
A5: x in dom JumpPart (a>0_goto i1);
    then x in dom <*i1*> by RECDEF_2:def 2;
      then
A6:   x = 1 by FINSEQ_1:111;
     set f = (JumpPart (a>0_goto i1)).x;
A7:   (JumpPart IncAddr(a>0_goto i1,k)).x = k + f by A1,A2,A5,VALUED_1:def 2;
      f = <*i1*>.x by RECDEF_2:def 2
        .= i1 by A6,FINSEQ_1:57;
      hence
      (JumpPart IncAddr(a>0_goto i1,k)).x
         = <*i1+k*>.x by A6,A7,FINSEQ_1:57
        .= (JumpPart (a>0_goto(i1+k))).x
         by RECDEF_2:def 2;
  end;
A8: AddressPart IncAddr(a>0_goto i1,k) = AddressPart (a>0_goto i1)
           by COMPOS_1:def 38
    .= <*a*> by RECDEF_2:def 3
    .= AddressPart (a>0_goto(i1+k)) by RECDEF_2:def 3;
A9:  InsCode IncAddr(a>0_goto i1,k) = InsCode (a>0_goto i1) by COMPOS_1:def 38
    .= 8 by RECDEF_2:def 1
    .= InsCode (a>0_goto(i1+k)) by RECDEF_2:def 1;
   JumpPart IncAddr(a>0_goto i1,k) = JumpPart (a>0_goto(i1+k))
      by A2,A3,A4,FUNCT_1:9;
  hence thesis by A8,A9,COMPOS_1:7;
end;

registration
  cluster SCM -> IC-relocable Exec-preserving;
  coherence
  proof
    thus SCM is IC-relocable
    proof
      let I be Instruction of SCM;
      per cases by AMI_3:69;
      suppose
        I = [0,{},{}];
        hence thesis by AMI_3:71;
      end;
      suppose
        ex a,b st I = a:=b;
        hence thesis;
      end;
      suppose
        ex a,b st I = AddTo(a,b);
        hence thesis;
      end;
      suppose
        ex a,b st I = SubFrom(a,b);
        hence thesis;
      end;
      suppose
        ex a,b st I = MultBy(a,b);
        hence thesis;
      end;
      suppose
        ex a,b st I = Divide(a,b);
        hence thesis;
      end;
      suppose
A1:     ex k st I = SCM-goto k;

        let j,k be Nat, s1 be State of SCM;
        set s2 = IncIC(s1,k);
        consider k1 such that
A2:     I = SCM-goto k1 by A1;
        reconsider i1=k1 as Element of NAT by ORDINAL1:def 13;
       IC Exec(I,s1) = k1 by A2,AMI_3:13;
        hence IC Exec(IncAddr(I,j),s1) + k
         = IC Exec(SCM-goto(j+k1),s1) + k by A2,Th59
        .= j+k1+k by AMI_3:13
        .= IC Exec(SCM-goto(j+i1+k),s2) by AMI_3:13
        .= IC Exec(SCM-goto(j+k+i1),s2)
        .= IC Exec(IncAddr(I,j+k), s2) by A2,Th59;
      end;
      suppose
        ex a,k st I = a=0_goto k;
        then consider a, k1 such that
A3:     I = a=0_goto k1;
        reconsider i1=k1 as Element of NAT by ORDINAL1:def 13;
        let j,k be natural number, s1 be State of SCM;
        set s2 = IncIC(s1,k);
        a <> IC SCM & dom (IC SCM .--> (IC s1 + k)) = {IC SCM}
        by AMI_5:20,FUNCOP_1:19;
        then not a in dom (IC SCM .--> (IC s1 + k)) by TARSKI:def 1;
        then
A4:     s1.a = s2.a by FUNCT_4:12;
        now
          per cases;
          suppose
A5:         s1.a = 0;
            then IC Exec(I,s1) = k1 by A3,AMI_3:14;
            hence IC Exec(IncAddr(I,j),s1) + k
         = IC Exec(a=0_goto(j+k1),s1) + k by A3,Th60
        .= j+k1+k by A5,AMI_3:14
        .= IC Exec(a=0_goto(j+i1+k),s2) by A4,A5,AMI_3:14
        .= IC Exec(a=0_goto(j+k+i1),s2)
            .= IC Exec(IncAddr(I,j+k), s2) by A3,Th60;
          end;
          suppose
A6:         s1.a <> 0;
A7:         IncAddr(I,j) = a=0_goto(i1+j) by A3,Th60;
A8:         IncAddr(I,j+k) = a=0_goto(i1+(j+k)) by A3,Th60;
            dom (IC SCM .--> (IC s1 + k)) = {IC SCM} by FUNCOP_1:19;
            then IC SCM in dom (IC SCM .--> (IC s1 + k)) by TARSKI:def 1;
            then
A9:         IC s2 = (IC SCM .--> (IC s1 + k)).IC SCM by FUNCT_4:14
              .= (IC s1 + k) by FUNCOP_1:87;
            thus IC Exec(IncAddr(I,j),s1) + k
              = succ IC s1 + k by A7,A6,AMI_3:14
             .= IC s1 + 1 + k
             .= succ IC s2 by A9
             .= IC Exec(IncAddr(I,j+k), s2) by A8,A6,A4,AMI_3:14;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,k st I = a>0_goto k;
        then consider a, k1 such that
A10:    I = a>0_goto k1;
        reconsider i1=k1 as Element of NAT by ORDINAL1:def 13;
        let j,k be natural number, s1 be State of SCM;
        set s2 = IncIC(s1,k);
        a <> IC SCM & dom (IC SCM .--> (IC s1 + k)) = {IC SCM}
        by AMI_5:20,FUNCOP_1:19;
        then not a in dom (IC SCM .--> (IC s1 + k)) by TARSKI:def 1;
        then
A11:    s1.a = s2.a by FUNCT_4:12;
          per cases;
          suppose
A12:        s1.a > 0;
            then IC Exec(I,s1) = k1 by A10,AMI_3:15;
            hence IC Exec(IncAddr(I,j),s1) + k
         = IC Exec(a>0_goto(j+k1),s1) + k by A10,Th61
        .= j+k1+k by A12,AMI_3:15
        .= IC Exec(a>0_goto(j+i1+k),s2) by A11,A12,AMI_3:15
        .= IC Exec(a>0_goto(j+k+i1),s2)
            .= IC Exec(IncAddr(I,j+k), s2) by A10,Th61;
          end;
          suppose
A13:         s1.a <= 0;
A14:         IncAddr(I,j) = a>0_goto(i1+j) by A10,Th61;
A15:         IncAddr(I,j+k) = a>0_goto(i1+(j+k)) by A10,Th61;
            dom (IC SCM .--> (IC s1 + k)) = {IC SCM} by FUNCOP_1:19;
            then IC SCM in dom (IC SCM .--> (IC s1 + k)) by TARSKI:def 1;
            then
A16:         IC s2 = (IC SCM .--> (IC s1 + k)).IC SCM by FUNCT_4:14
              .= (IC s1 + k) by FUNCOP_1:87;
            thus IC Exec(IncAddr(I,j),s1) + k
              = succ IC s1 + k by A14,A13,AMI_3:15
             .= IC s1 + 1 + k
             .= succ IC s2 by A16
             .= IC Exec(IncAddr(I,j+k), s2) by A15,A13,A11,AMI_3:15;
          end;
      end;
    end;
    let I be Instruction of SCM;
    let s1, s2 be State of SCM such that
A17: NPP s1 = NPP s2;
A18: IC s1 = IC s2 by A17,COMPOS_1:230;
A19: dom Exec(I,s1) = the carrier of SCM
 by PARTFUN1:def 4;
    then
A20: dom Exec(I,s1) = dom Exec(I,s2) by PARTFUN1:def 4;
    per cases by AMI_3:69;
    suppose
      I = [0,{},{}];
      hence thesis by A17,AMISTD_2:def 20,AMI_3:71;
    end;
    suppose
      ex a,b st I = a:=b;
      then consider a, b such that
A21:  I = a:=b;
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A22:    x in dom Exec(I,s1) \ NAT;
        then
A23:    not x in NAT by XBOOLE_0:def 5;
        per cases by A19,A22,A23,Th3;
        suppose
A24:      x = IC SCM;
          hence Exec(I,s1).x = succ IC s1 by A21,AMI_3:8
            .= Exec(I,s2).x by A18,A21,A24,AMI_3:8;
        end;
        suppose
A25:      x = a;
          hence Exec(I,s1).x = s1.b by A21,AMI_3:8
            .= s2.b by A17,Th5
            .= Exec(I,s2).x by A21,A25,AMI_3:8;
        end;
        suppose that
A26:      x is Data-Location and
A27:      x <> a;
          thus Exec(I,s1).x = s1.x by A21,A26,A27,AMI_3:8
            .= s2.x by A17,A26,Th5
            .= Exec(I,s2).x by A21,A26,A27,AMI_3:8;
        end;
      end;
      then Exec(I,s1)|(dom Exec(I,s1) \ NAT)
       = Exec(I,s2)|(dom Exec(I,s2) \
       NAT) by A20,FUNCT_1:165;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by COMPOS_1:233;
    end;
    suppose
      ex a,b st I = AddTo(a,b);
      then consider a, b such that
A28:  I = AddTo(a,b);
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A29:    x in dom Exec(I,s1) \ NAT;
        then
A30:    not x in NAT by XBOOLE_0:def 5;
        per cases by A19,A29,A30,Th3;
        suppose
A31:      x = IC SCM;
          hence Exec(I,s1).x = succ IC s1 by A28,AMI_3:9
            .= Exec(I,s2).x by A18,A28,A31,AMI_3:9;
        end;
        suppose
A32:      x = a;
          hence Exec(I,s1).x = s1.a + s1.b by A28,AMI_3:9
            .= s1.a + s2.b by A17,Th5
            .= s2.a + s2.b by A17,Th5
            .= Exec(I,s2).x by A28,A32,AMI_3:9;
        end;
        suppose that
A33:      x is Data-Location and
A34:      x <> a;
          thus Exec(I,s1).x = s1.x by A28,A33,A34,AMI_3:9
            .= s2.x by A17,A33,Th5
            .= Exec(I,s2).x by A28,A33,A34,AMI_3:9;
        end;
      end;
      then Exec(I,s1)|(dom Exec(I,s1) \ NAT) = Exec(I,s2)|(dom Exec(I,s2) \
      NAT) by A20,FUNCT_1:165;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by COMPOS_1:233;
    end;
    suppose
      ex a,b st I = SubFrom(a,b);
      then consider a, b such that
A35:  I = SubFrom(a,b);
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A36:    x in dom Exec(I,s1) \ NAT;
        then
A37:    not x in NAT by XBOOLE_0:def 5;
        per cases by A19,A36,A37,Th3;
        suppose
A38:      x = IC SCM;
          hence Exec(I,s1).x = succ IC s1 by A35,AMI_3:10
            .= Exec(I,s2).x by A18,A35,A38,AMI_3:10;
        end;
        suppose
A39:      x = a;
          hence Exec(I,s1).x = s1.a - s1.b by A35,AMI_3:10
            .= s1.a - s2.b by A17,Th5
            .= s2.a - s2.b by A17,Th5
            .= Exec(I,s2).x by A35,A39,AMI_3:10;
        end;
        suppose that
A40:      x is Data-Location and
A41:      x <> a;
          thus Exec(I,s1).x = s1.x by A35,A40,A41,AMI_3:10
            .= s2.x by A17,A40,Th5
            .= Exec(I,s2).x by A35,A40,A41,AMI_3:10;
        end;
      end;
      then Exec(I,s1)|(dom Exec(I,s1) \ NAT) = Exec(I,s2)|(dom Exec(I,s2) \
      NAT) by A20,FUNCT_1:165;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by COMPOS_1:233;
    end;
    suppose
      ex a,b st I = MultBy(a,b);
      then consider a, b such that
A42:  I = MultBy(a,b);
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A43:    x in dom Exec(I,s1) \ NAT;
        then
A44:    not x in NAT by XBOOLE_0:def 5;
        per cases by A19,A43,A44,Th3;
        suppose
A45:      x = IC SCM;
          hence Exec(I,s1).x = succ IC s1 by A42,AMI_3:11
            .= Exec(I,s2).x by A18,A42,A45,AMI_3:11;
        end;
        suppose
A46:      x = a;
          hence Exec(I,s1).x = s1.a * s1.b by A42,AMI_3:11
            .= s1.a * s2.b by A17,Th5
            .= s2.a * s2.b by A17,Th5
            .= Exec(I,s2).x by A42,A46,AMI_3:11;
        end;
        suppose that
A47:      x is Data-Location and
A48:      x <> a;
          thus Exec(I,s1).x = s1.x by A42,A47,A48,AMI_3:11
            .= s2.x by A17,A47,Th5
            .= Exec(I,s2).x by A42,A47,A48,AMI_3:11;
        end;
      end;
      then Exec(I,s1)|(dom Exec(I,s1) \ NAT) = Exec(I,s2)|(dom Exec(I,s2) \
      NAT) by A20,FUNCT_1:165;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by COMPOS_1:233;
    end;
    suppose
      ex a,b st I = Divide(a,b);
      then consider a, b such that
A49:  I = Divide(a,b);
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A50:    x in dom Exec(I,s1) \ NAT;
        then
A51:    not x in NAT by XBOOLE_0:def 5;
        per cases by A19,A50,A51,Th3;
        suppose
A52:      x = IC SCM;
          hence Exec(I,s1).x = succ IC s1 by A49,AMI_3:12
            .= Exec(I,s2).x by A18,A49,A52,AMI_3:12;
        end;
        suppose
A53:      x is Data-Location;
A54:      s1.a = s2.a & s1.b = s2.b by A17,Th5;
          now
            let c be Data-Location;
            per cases;
            suppose
A55:          c = b;
              hence Exec(I,s1).c = s2.a mod s2.b by A49,A54,AMI_3:12
                .= Exec(I,s2).c by A49,A55,AMI_3:12;
            end;
            suppose
A56:          c = a & c <> b;
              hence Exec(I,s1).c = s2.a div s2.b by A49,A54,AMI_3:12
                .= Exec(I,s2).c by A49,A56,AMI_3:12;
            end;
            suppose
A57:          c <> a & c <> b;
              hence Exec(I,s1).c = s1.c by A49,AMI_3:12
                .= s2.c by A17,Th5
                .= Exec(I,s2).c by A49,A57,AMI_3:12;
            end;
          end;
          hence thesis by A53;
        end;
      end;
      then Exec(I,s1)|(dom Exec(I,s1) \ NAT) = Exec(I,s2)|(dom Exec(I,s2) \
      NAT) by A20,FUNCT_1:165;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by COMPOS_1:233;
    end;
    suppose
      ex k st I = SCM-goto k;
      then consider k1 such that
A58:  I = SCM-goto k1;
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A59:    x in dom Exec(I,s1) \ NAT;
        then
A60:    not x in NAT by XBOOLE_0:def 5;
        per cases by A19,A59,A60,Th3;
        suppose
A61:      x = IC SCM;
          hence Exec(I,s1).x = k1 by A58,AMI_3:13
            .= Exec(I,s2).x by A58,A61,AMI_3:13;
        end;
        suppose
A62:      x is Data-Location;
          hence Exec(I,s1).x = s1.x by A58,AMI_3:13
            .= s2.x by A17,A62,Th5
            .= Exec(I,s2).x by A58,A62,AMI_3:13;
        end;
      end;
      then Exec(I,s1)|(dom Exec(I,s1) \ NAT) = Exec(I,s2)|(dom Exec(I,s2) \
      NAT) by A20,FUNCT_1:165;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by COMPOS_1:233;
    end;
    suppose
      ex a,k st I = a=0_goto k;
      then consider a, k1 such that
A63:  I = a=0_goto k1;
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A64:    x in dom Exec(I,s1) \ NAT;
        then
A65:    not x in NAT by XBOOLE_0:def 5;
A66:    s1.a = s2.a by A17,Th5;
        per cases by A19,A64,A65,Th3;
        suppose that
A67:      x = IC SCM & s1.a = 0;
          thus Exec(I,s1).x = k1 by A63,A67,AMI_3:14
            .= Exec(I,s2).x by A63,A66,A67,AMI_3:14;
        end;
        suppose that
A68:      x = IC SCM & s1.a <> 0;
          thus Exec(I,s1).x = succ IC s1 by A63,A68,AMI_3:14
            .= Exec(I,s2).x by A18,A63,A66,A68,AMI_3:14;
        end;
        suppose
A69:      x is Data-Location;
          hence Exec(I,s1).x = s1.x by A63,AMI_3:14
            .= s2.x by A17,A69,Th5
            .= Exec(I,s2).x by A63,A69,AMI_3:14;
        end;
      end;
      then Exec(I,s1)|(dom Exec(I,s1) \ NAT) = Exec(I,s2)|(dom Exec(I,s2) \
      NAT) by A20,FUNCT_1:165;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by COMPOS_1:233;
    end;
    suppose
      ex a,k st I = a>0_goto k;
      then consider a, k such that
A70:  I = a>0_goto k;
      for x being set st x in dom Exec(I,s1) \ NAT holds Exec(I,s1).x =
      Exec(I,s2).x
      proof
        let x be set;
        assume
A71:    x in dom Exec(I,s1) \ NAT;
        then
A72:    not x in NAT by XBOOLE_0:def 5;
A73:    s1.a = s2.a by A17,Th5;
        per cases by A19,A71,A72,Th3;
        suppose that
A74:      x = IC SCM & s1.a > 0;
          thus Exec(I,s1).x = k by A70,A74,AMI_3:15
            .= Exec(I,s2).x by A70,A73,A74,AMI_3:15;
        end;
        suppose that
A75:      x = IC SCM & s1.a <= 0;
          thus Exec(I,s1).x = succ IC s1 by A70,A75,AMI_3:15
            .= Exec(I,s2).x by A18,A70,A73,A75,AMI_3:15;
        end;
        suppose
A76:      x is Data-Location;
          hence Exec(I,s1).x = s1.x by A70,AMI_3:15
            .= s2.x by A17,A76,Th5
            .= Exec(I,s2).x by A70,A76,AMI_3:15;
        end;
      end;
      then Exec(I,s1)|(dom Exec(I,s1) \ NAT) = Exec(I,s2)|(dom Exec(I,s2) \
      NAT) by A20,FUNCT_1:165;
      hence NPP Exec(I,s1) = NPP Exec(I,s2) by COMPOS_1:233;
    end;
  end;
end;

