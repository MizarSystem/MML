:: Conditional branch macro instructions of SCM+FSA, Part I (preliminary)
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, SCMFSA_2, XBOOLE_0, FSM_1, RELAT_1, AMI_1,
      GRAPHSP, XXREAL_0, CIRCUIT2, ARYTM_3, CARD_1, FUNCT_7, FUNCT_1, SCMFSA6B,
      MSUALG_1, FUNCT_4, SCMFSA6A, SCMFSA6C, FUNCOP_1, TARSKI, SF_MASTR,
      STRUCT_0, AMISTD_2, SCMNORM, AMI_3, SCMFSA7B, VALUED_1, CAT_1, NAT_1,
      TURING_1, SCMFSA_7, FINSEQ_1, UNIALG_2, SCMFSA8A, PARTFUN1, RELOC,
      AFINSQ_1, FRECHET, ORDINAL1;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, NAT_1, FUNCOP_1,
      RELAT_1, FUNCT_1, PARTFUN1, AFINSQ_1, FUNCT_4, FUNCT_7, FINSEQ_1,
      VALUED_1, STRUCT_0, COMPOS_1,
      EXTPRO_1, AMI_1, AMISTD_1, AMISTD_2, SCMFSA_2,
      SCMFSA10,
      SCMFSA_7, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, SCMFSA_7, SCMFSA6A, SF_MASTR, AMI_1,
      SCMFSA6B, SCMFSA6C, SCMFSA7B, AMISTD_2, RELSET_1, PRE_POLY, SCMFSA10;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, FUNCOP_1, NUMBERS, XXREAL_0,
      MEMBERED, AMI_1, SCMFSA_2, SCMFSA6A, SF_MASTR, AFINSQ_1, SCMFSA7B,
      FINSET_1, FINSEQ_1, SCMFSA10, AMISTD_2, VALUED_1, SCMFSA_4,
      SCMFSA6C, COMPOS_1, RELAT_1, EXTPRO_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_1, SCMFSA6A, AMISTD_2;
 theorems TARSKI, FUNCOP_1, SCMFSA_7, NAT_1, FUNCT_1, FUNCT_4, FUNCT_7,
      RELAT_1, FINSEQ_1, AMI_1, SCMFSA_2, SCMFSA_4, SCMFSA6A, SCMFSA_5,
      GRFUNC_1, SF_MASTR, SCMFSA6B, SCMFSA6C, CARD_1, SCMFSA7B, XBOOLE_0,
      XBOOLE_1, XREAL_1, XXREAL_0, VALUED_1, AFINSQ_1, PARTFUN1,
      AMISTD_2, SCMFSA10, COMPOS_1, AMISTD_1, EXTPRO_1;
 schemes NAT_1;

begin

reserve m for Element of NAT;
set A = NAT;
set D = Int-Locations \/ FinSeq-Locations;

canceled 3;

theorem Th4:
  for s being State of SCM+FSA st ProgramPart s halts_on s for k being Element
  of NAT st LifeSpan(ProgramPart(s),s) <= k holds
  CurInstr(ProgramPart(s),Comput(ProgramPart(s),s,k))= halt SCM+FSA
proof
  let s be State of SCM+FSA;
  assume ProgramPart s halts_on s;
  then
A1: CurInstr(ProgramPart(s),
    Comput(ProgramPart(s),s,LifeSpan(ProgramPart(s),s)))
 = halt SCM+FSA by EXTPRO_1:def 14;
  let k be Element of NAT;
  set i=LifeSpan(ProgramPart(s),s);
  assume LifeSpan(ProgramPart(s),s) <= k;
   then
  Comput(ProgramPart(s),s,k) = Comput(ProgramPart(s),s,i) by A1,EXTPRO_1:6;
  hence CurInstr(ProgramPart s,Comput(ProgramPart(s),s,k))
   = halt SCM+FSA by A1;
end;

theorem Th5:
  for s being State of SCM+FSA st ProgramPart s halts_on s for k being Element
of NAT st LifeSpan(ProgramPart(s),s) <= k holds IC Comput(ProgramPart(s),s,k) =
IC Comput(
ProgramPart(s),s,LifeSpan(ProgramPart s,
  s))
proof
  let s be State of SCM+FSA;
  defpred P[Nat] means LifeSpan(ProgramPart(s),s) <= $1 implies IC Comput(
ProgramPart(s),s,$1
  ) = IC Comput(ProgramPart(s),s,LifeSpan(ProgramPart(s),s));
  assume
A1: ProgramPart s halts_on s;
A2: now
    let k be Element of NAT;
    assume
A3: P[k];
    now
      assume
A4:   LifeSpan(ProgramPart(s),s) <= k + 1;
      per cases by A4,XXREAL_0:1;
      suppose
        k + 1 = LifeSpan(ProgramPart(s),s);
        hence IC Comput(ProgramPart(s),s,k+1) = IC Comput(ProgramPart(s),s,
LifeSpan(ProgramPart(s),s));
      end;
      suppose
A5:     k + 1 > LifeSpan(ProgramPart(s),s);
        then
A6:     LifeSpan(ProgramPart(s),s) <= k by NAT_1:13;
        thus IC Comput(ProgramPart(s),s,k+1) =
        IC Following(ProgramPart s,Comput(ProgramPart(
s),s,k))
         by EXTPRO_1:4
          .= IC Exec(halt SCM+FSA, Comput(ProgramPart(s),s,k)) by A1,A6,Th4
          .= IC Comput(ProgramPart(s),s,LifeSpan(ProgramPart(s),s)) by A3,A5,
EXTPRO_1:def 3,NAT_1:13;
      end;
    end;
    hence P[k + 1];
  end;
  let k be Element of NAT;
  assume
A7: LifeSpan(ProgramPart(s),s) <= k;
A8: P[0]
  proof
A9: 0 <= LifeSpan(ProgramPart(s),s) by NAT_1:2;
    assume LifeSpan(ProgramPart(s),s) <= 0;
    hence thesis by A9;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A8,A2);
  hence thesis by A7;
end;

theorem Th6:
  for s1,s2 being State of SCM+FSA holds s1,s2 equal_outside NAT
  iff IC s1 = IC s2 & DataPart s1 = DataPart s2
proof
  let s1,s2 be State of SCM+FSA;
  hereby
    assume
A1: s1,s2 equal_outside NAT;
    hence IC s1 = IC s2 by COMPOS_1:24;
    ( for a being Int-Location holds s1.a = s2.a)& for f being
    FinSeq-Location holds s1.f = s2.f by A1,SCMFSA10:92,93;
    hence DataPart s1 = DataPart s2 by SCMFSA6A:38;
  end;
  assume that
A2: IC s1 = IC s2 and
A3: DataPart s1 = DataPart s2;
  ( for a being Int-Location holds s1.a = s2.a)& for f being
  FinSeq-Location holds s1.f = s2.f by A3,SCMFSA6A:38;
  hence thesis by A2,SCMFSA10:91;
end;

theorem Th7:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds IC
  IExec(I,s) = IC Result(ProgramPart(s +* Initialized I),s +* Initialized I)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
A1: dom s = Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} \/ NAT by
SCMFSA6A:34;
A2: dom (s | NAT) = dom s /\ NAT by RELAT_1:90
    .= NAT by A1,XBOOLE_1:21;
A3: not IC SCM+FSA in dom (s | NAT) by A2,COMPOS_1:3;
  IExec(I,s) = Result(ProgramPart(s +* Initialized I),s +* Initialized I) +* s
| NAT by SCMFSA6B:def 1;
  hence thesis by A3,FUNCT_4:12;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  Initialized s +* Initialized I = s +* Initialized I
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
A1: dom I misses dom Start-At( 0,SCM+FSA) by COMPOS_1:140;
  now
    let x be set;
A2: dom (intloc 0 .--> 1) = {intloc 0} by FUNCOP_1:19;
    assume x in dom (intloc 0 .--> 1);
    then x = intloc 0 by A2,TARSKI:def 1;
    hence not x in dom I by SCMFSA6A:47;
  end;
  then
A3: dom I misses dom (intloc 0 .--> 1) by XBOOLE_0:3;
  thus Initialized s +* Initialized I = s +* (intloc 0 .--> 1) +* Start-At(
   0,SCM+FSA) +* Initialized I
    .= s +* (intloc 0 .--> 1) +* Start-At( 0,SCM+FSA)
     +* (I +* ((intloc 0 .-->
  1) +* Start-At( 0,SCM+FSA))) by FUNCT_4:15
    .= s +* (intloc 0 .--> 1) +* Start-At( 0,SCM+FSA) +* I
     +* ((intloc 0 .--> 1
  ) +* Start-At( 0,SCM+FSA)) by FUNCT_4:15
    .= s +* (intloc 0 .--> 1) +* (Start-At( 0,SCM+FSA) +* I)
     +* ((intloc 0 .-->
  1) +* Start-At( 0,SCM+FSA)) by FUNCT_4:15
    .= s +* (intloc 0 .--> 1) +* (I +* Start-At( 0,SCM+FSA))
     +* ((intloc 0 .-->
  1) +* Start-At( 0,SCM+FSA)) by A1,FUNCT_4:36
    .= s +* (intloc 0 .--> 1) +* I +* Start-At( 0,SCM+FSA)
     +* ((intloc 0 .--> 1
  ) +* Start-At( 0,SCM+FSA)) by FUNCT_4:15
    .= s +* ((intloc 0 .--> 1) +* I) +* Start-At( 0,SCM+FSA)
     +* ((intloc 0 .-->
  1) +* Start-At( 0,SCM+FSA)) by FUNCT_4:15
    .= s +* (I +* (intloc 0 .--> 1)) +* Start-At( 0,SCM+FSA)
     +* ((intloc 0 .-->
  1) +* Start-At( 0,SCM+FSA)) by A3,FUNCT_4:36
    .= s +* I +* (intloc 0 .--> 1) +* Start-At( 0,SCM+FSA)
     +* ((intloc 0 .--> 1
  ) +* Start-At( 0,SCM+FSA)) by FUNCT_4:15
    .= s +* I +* ((intloc 0 .--> 1) +* Start-At( 0,SCM+FSA))
     +* ((intloc 0 .-->
  1) +* Start-At( 0,SCM+FSA)) by FUNCT_4:15
    .= s +* I +* ((intloc 0 .--> 1) +* Start-At( 0,SCM+FSA)
     +* ((intloc 0 .-->
  1) +* Start-At( 0,SCM+FSA))) by FUNCT_4:15
    .= s +* I +* (intloc 0 .--> 1) +* Start-At( 0,SCM+FSA) by FUNCT_4:15
    .= s +* (I +* (intloc 0 .--> 1)) +* Start-At( 0,SCM+FSA)
     by FUNCT_4:15
    .= s +* Initialized I by FUNCT_4:15;
end;

theorem Th9:
  for I being Program of SCM+FSA, l being Element of NAT
   holds I c= I +* Start-At(l,SCM+FSA)
proof
  let I be Program of SCM+FSA;
  let l be Element of NAT;
  reconsider n = l as Element of NAT;
  dom I misses dom Start-At(l,SCM+FSA) by COMPOS_1:140;
  hence thesis by FUNCT_4:33;
end;

theorem Th10:
  for s being State of SCM+FSA, l being Element of NAT
   holds DataPart s = DataPart(s +* Start-At(l,SCM+FSA))
proof
  let s be State of SCM+FSA;
  let l be Element of NAT;
  now
    let x be set;
    assume x in dom Start-At(l,SCM+FSA);
    then x in {IC SCM+FSA} by FUNCOP_1:19;
    hence not x in D by SCMFSA6A:37,TARSKI:def 1;
  end;
  then dom Start-At(l,SCM+FSA) misses D by XBOOLE_0:3;
  hence thesis by FUNCT_4:76,SCMFSA_2:127;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA, l being
  Element of NAT holds DataPart s = DataPart (s +* (I +*
  Start-At(l,SCM+FSA)))
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let l be Element of NAT;
  now
    let x be set;
    assume x in dom (I +* Start-At(l,SCM+FSA));
    then x in dom I \/ dom Start-At(l,SCM+FSA) by FUNCT_4:def 1;
    then x in dom I or x in dom Start-At(l,SCM+FSA) by XBOOLE_0:def 3;
    then
A1: x in dom I or x in {IC SCM+FSA} by FUNCOP_1:19;
    per cases by A1,TARSKI:def 1;
    suppose
A2:   x in dom I;
      dom I c= NAT & D misses NAT by SCMFSA_2:13,14,XBOOLE_1:70;
      hence not x in D by A2,XBOOLE_0:3;
    end;
    suppose
      x = IC SCM+FSA;
      hence not x in D by SCMFSA6A:37;
    end;
  end;
  then dom (I +* Start-At(l,SCM+FSA)) misses D by XBOOLE_0:3;
  hence thesis by FUNCT_4:76,SCMFSA_2:127;
end;

theorem Th12:
  for s being State of SCM+FSA, l being Element of NAT
   holds dom ProgramPart s misses dom Start-At(l,SCM+FSA)
proof
  let s be State of SCM+FSA;
  let l be Element of NAT;
  now
    let x be set;
    assume x in dom ProgramPart s;
    then x in NAT by COMPOS_1:34;
    then x is Element of NAT;
    then x <> IC SCM+FSA by COMPOS_1:3;
    then not x in {IC SCM+FSA} by TARSKI:def 1;
    hence not x in dom Start-At(l,SCM+FSA) by FUNCOP_1:19;
  end;
  hence thesis by XBOOLE_0:3;
end;

theorem Th13:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds s
  +* Initialized I = Initialized s +* (I +* Start-At( 0,SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
A1: now
    let x be set;
    I c= Initialized I by SCMFSA6A:26;
    then
A2: dom I c= dom Initialized I by GRFUNC_1:8;
    assume
A3: x in dom (s +* Initialized I);
    per cases by A3,SCMFSA6A:35;
    suppose
A4:   x = intloc 0;
      then
A5:   not x in dom (I +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
      x in dom Initialized I by A4,SCMFSA6A:45;
      hence (s +* Initialized I).x = (Initialized I).x by FUNCT_4:14
        .= 1 by A4,SCMFSA6A:46
        .= (Initialized s).x by A4,SCMFSA6C:3
        .= (Initialized s +* (I +* Start-At( 0,SCM+FSA))).x
         by A5,FUNCT_4:12;
    end;
    suppose
A6:   x = IC SCM+FSA;
      then
A7:   x in dom (I +* Start-At( 0,SCM+FSA)) by COMPOS_1:141;
      x in dom (Initialized I) by A6,SCMFSA6A:24;
      hence (s +* Initialized I).x = (Initialized I).x by FUNCT_4:14
        .=  0 by A6,SCMFSA6A:46
        .= IC(I +* Start-At( 0,SCM+FSA)) by A6,COMPOS_1:142
        .= (Initialized s +* (I +* Start-At( 0,SCM+FSA))).x
          by A6,A7,FUNCT_4:14;
    end;
    suppose
A8:   x in dom I;
      then x in dom I \/ (dom Start-At( 0,SCM+FSA)) by XBOOLE_0:def 3;
      then
A9:   x in dom (I +* Start-At( 0,SCM+FSA)) by FUNCT_4:def 1;
      thus (s +* Initialized I).x = (Initialized I).x by A2,A8,FUNCT_4:14
        .= I.x by A8,SCMFSA6A:50
        .= (I +* Start-At( 0,SCM+FSA)).x by A8,COMPOS_1:145
        .= (Initialized s +* (I +* Start-At( 0,SCM+FSA))).x
         by A9,FUNCT_4:14;
    end;
    suppose
A10:  x is Element of NAT & not x in dom I;
      then not x = IC SCM+FSA by COMPOS_1:3;
      then not x in {IC SCM+FSA} by TARSKI:def 1;
      then not x in dom I \/ {IC SCM+FSA} by A10,XBOOLE_0:def 3;
      then not x in dom I \/ dom Start-At( 0,SCM+FSA) by FUNCOP_1:19;
      then
A11:  not x in dom (I +* Start-At( 0,SCM+FSA)) by FUNCT_4:def 1;
      x <> IC SCM+FSA by A10,COMPOS_1:3;
      then not x in dom Initialized I by A10,SCMFSA6A:44,SCMFSA_2:84;
      hence (s +* Initialized I).x = s.x by FUNCT_4:12
        .= (Initialized s).x by A10,SCMFSA6C:3
        .= (Initialized s +* (I +* Start-At( 0,SCM+FSA))).x
         by A11,FUNCT_4:12;
    end;
    suppose
A12:  x is FinSeq-Location;
      then not x = IC SCM+FSA by SCMFSA_2:82;
      then
A13:  not x in {IC SCM+FSA} by TARSKI:def 1;
      not x in dom I by A2,A12,SCMFSA6A:49;
      then not x in dom I \/ {IC SCM+FSA} by A13,XBOOLE_0:def 3;
      then not x in dom I \/ dom Start-At( 0,SCM+FSA) by FUNCOP_1:19;
      then
A14:  not x in dom (I +* Start-At( 0,SCM+FSA)) by FUNCT_4:def 1;
      not x in dom Initialized I by A12,SCMFSA6A:49;
      hence (s +* Initialized I).x = s.x by FUNCT_4:12
        .= (Initialized s).x by A12,SCMFSA6C:3
        .= (Initialized s +* (I +* Start-At( 0,SCM+FSA))).x
         by A14,FUNCT_4:12;
    end;
    suppose
A15:  x is Int-Location & x <> intloc 0;
      then not x = IC SCM+FSA by SCMFSA_2:81;
      then
A16:  not x in {IC SCM+FSA} by TARSKI:def 1;
      not x in dom I by A2,A15,SCMFSA6A:48;
      then not x in dom I \/ {IC SCM+FSA} by A16,XBOOLE_0:def 3;
      then not x in dom I \/ dom Start-At( 0,SCM+FSA) by FUNCOP_1:19;
      then
A17:  not x in dom (I +* Start-At( 0,SCM+FSA)) by FUNCT_4:def 1;
A18:  x is read-write Int-Location by A15,SF_MASTR:def 5;
      not x in dom Initialized I by A15,SCMFSA6A:48;
      hence (s +* Initialized I).x = s.x by FUNCT_4:12
        .= (Initialized s).x by A18,SCMFSA6C:3
        .= (Initialized s +* (I +* Start-At( 0,SCM+FSA))).x
         by A17,FUNCT_4:12;
    end;
  end;
  dom (s +* Initialized I) = the carrier of SCM+FSA by PARTFUN1:def 4
    .= dom (Initialized s +* (I +* Start-At( 0,SCM+FSA))) by PARTFUN1:def 4;
  hence thesis by A1,FUNCT_1:9;
end;

theorem Th14:
  for s being State of SCM+FSA, I1,I2 being Program of SCM+FSA, l
  being Element of NAT holds s +* (I1 +* Start-At(l,SCM+FSA)),
   s +* (I2
  +* Start-At(l,SCM+FSA)) equal_outside NAT
proof
  let s be State of SCM+FSA;
  let I1,I2 be Program of SCM+FSA;
  let l be Element of NAT;
A1: now
    let a be Int-Location;
A2: not a in dom (I1 +* Start-At(l,SCM+FSA)) by SCMFSA6B:12;
    not a in dom (I2 +* Start-At(l,SCM+FSA)) by SCMFSA6B:12;
    hence (s +* (I2 +* Start-At(l,SCM+FSA))).a = s.a by FUNCT_4:12
      .= (s +* (I1 +* Start-At(l,SCM+FSA))).a by A2,FUNCT_4:12;
  end;
A3: now
    let f be FinSeq-Location;
A4: not f in dom (I1 +* Start-At(l,SCM+FSA)) by SCMFSA6B:13;
    not f in dom (I2 +* Start-At(l,SCM+FSA)) by SCMFSA6B:13;
    hence (s +* (I2 +* Start-At(l,SCM+FSA))).f = s.f by FUNCT_4:12
      .= (s +* (I1 +* Start-At(l,SCM+FSA))).f by A4,FUNCT_4:12;
  end;
  IC (s +* (I2 +* Start-At(l,SCM+FSA))) = IC (s +* I2 +* Start-At(l,SCM+FSA))
   by FUNCT_4:15
    .= l by FUNCT_4:121
    .= IC (s +* I1 +* Start-At(l,SCM+FSA)) by FUNCT_4:121
    .= IC (s +* (I1 +* Start-At(l,SCM+FSA))) by FUNCT_4:15;
  hence thesis by A1,A3,SCMFSA10:91;
end;

canceled 6;

theorem
  for P being preProgram of SCM+FSA, l being Element of NAT
, x being set st x in dom P holds (P.x = halt SCM+FSA implies Directed(P
  ,l).x = goto l) & (P.x <> halt SCM+FSA implies Directed(P,l).x = P.x) by
FUNCT_4:111,112;

theorem Th22:
  for i being Instruction of SCM+FSA, a being Int-Location, n
  being Element of NAT holds i does not destroy a implies IncAddr(i,n)
  does not destroy a
proof
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  let n be Element of NAT;
  assume
A1: i does not destroy a;
A2: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
A3: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A4: InsCode i <= 11+1 by SCMFSA_2:35;
  per cases by A4,A3,A2,NAT_1:8,33;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:122;
    then IncAddr(i,n) = halt SCM+FSA by SCMFSA_4:8;
    hence thesis by SCMFSA7B:11;
  end;
  suppose
    InsCode i = 1;
    then ex da, db being Int-Location st i = da := db by SCMFSA_2:54;
    hence thesis by A1,SCMFSA_4:9;
  end;
  suppose
    InsCode i = 2;
    then ex da, db being Int-Location st i = AddTo(da,db) by SCMFSA_2:55;
    hence thesis by A1,SCMFSA_4:10;
  end;
  suppose
    InsCode i = 3;
    then ex da, db being Int-Location st i = SubFrom(da, db) by SCMFSA_2:56;
    hence thesis by A1,SCMFSA_4:11;
  end;
  suppose
    InsCode i = 4;
    then ex da, db being Int-Location st i = MultBy(da,db) by SCMFSA_2:57;
    hence thesis by A1,SCMFSA_4:12;
  end;
  suppose
    InsCode i = 5;
    then ex da, db being Int-Location st i = Divide(da, db) by SCMFSA_2:58;
    hence thesis by A1,SCMFSA_4:13;
  end;
  suppose
    InsCode i = 6;
    then consider loc being Element of NAT such that
A5: i = goto loc by SCMFSA_2:59;
    IncAddr(i,n) = goto (loc + n) by A5,SCMFSA_4:14;
    hence thesis by SCMFSA7B:17;
  end;
  suppose
    InsCode i = 7;
    then consider
    loc being Element of NAT, da being Int-Location
    such that
A6: i = da =0_goto loc by SCMFSA_2:60;
    IncAddr(i,n) = da =0_goto (loc + n) by A6,SCMFSA_4:15;
    hence thesis by SCMFSA7B:18;
  end;
  suppose
    InsCode i = 8;
    then consider
    loc being Element of NAT, da being Int-Location
    such that
A7: i = da >0_goto loc by SCMFSA_2:61;
    IncAddr(i,n) = da >0_goto (loc + n) by A7,SCMFSA_4:16;
    hence thesis by SCMFSA7B:19;
  end;
  suppose
    InsCode i = 9;
    then
    ex db, da being Int-Location, g being FinSeq-Location st i = da := (g,
    db) by SCMFSA_2:62;
    hence thesis by A1,SCMFSA_4:17;
  end;
  suppose
    InsCode i = 10;
    then ex db, da being Int-Location, g being FinSeq-Location st i = (g,db):=
    da by SCMFSA_2:63;
    hence thesis by A1,SCMFSA_4:18;
  end;
  suppose
    InsCode i = 11;
    then
    ex da being Int-Location, g being FinSeq-Location st i = da :=len g by
SCMFSA_2:64;
    hence thesis by A1,SCMFSA_4:19;
  end;
  suppose
    InsCode i = 12;
    then
    ex da being Int-Location, g being FinSeq-Location st i = g :=<0,...,0>
    da by SCMFSA_2:65;
    hence thesis by A1,SCMFSA_4:20;
  end;
end;

theorem Th23:
  for P being preProgram of SCM+FSA, n being Element of NAT, a
being Int-Location holds P does not destroy a implies ProgramPart Relocated(P,
  n) does not destroy a
proof
  let I be preProgram of SCM+FSA;
  let n be Element of NAT;
  let a be Int-Location;
A1: ProgramPart Relocated(I,n) = Reloc(ProgramPart I,n) by COMPOS_1:116
    .= Reloc(I,n) by RELAT_1:209
    .= Shift(IncAddr(I,n),n) by COMPOS_1:121;
A2: dom IncAddr(I,n) = dom I by COMPOS_1:def 40;
A3: dom Shift(IncAddr(I,n),n) = { m+n: m in dom IncAddr(I,n) } by
VALUED_1:def 12;
  assume
A4: I does not destroy a;
  now
    let i be Instruction of SCM+FSA;
    assume i in rng ProgramPart Relocated(I,n);
    then consider x being set such that
A5: x in dom Shift(IncAddr(I,n),n) and
A6: i = Shift(IncAddr(I,n),n).x by A1,FUNCT_1:def 5;
    consider m being Element of NAT such that
A7: x = m + n and
A8: m in dom IncAddr(I,n) by A3,A5;
A9: I. m in rng I by A2,A8,FUNCT_1:def 5;
    rng I c= the Instructions of SCM+FSA by RELAT_1:def 19;
    then reconsider ii = I. m as Instruction of SCM+FSA by A9;
A10: ii does not destroy a by A4,A9,SCMFSA7B:def 4;
    i = IncAddr(I,n). m by A6,A7,A8,VALUED_1:def 12
      .= IncAddr(I/.m,n) by A2,A8,COMPOS_1:def 40
      .= IncAddr(ii,n) by A2,A8,PARTFUN1:def 8;
    hence i does not destroy a by A10,Th22;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th24:
  for P being good preProgram of SCM+FSA, n being Element of NAT
  holds ProgramPart Relocated(P,n) is good
proof
  let I be good preProgram of SCM+FSA;
  let n be Element of NAT;
  I does not destroy intloc 0 by SCMFSA7B:def 5;
  then ProgramPart Relocated(I,n) does not destroy intloc 0 by Th23;
  hence thesis by SCMFSA7B:def 5;
end;

theorem Th25:
  for I,J being preProgram of SCM+FSA, a being Int-Location holds
  I does not destroy a & J does not destroy a implies I +* J does not destroy a
proof
  let I,J be preProgram of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does not destroy a;
  assume
A2: J does not destroy a;
  now
    let i be Instruction of SCM+FSA;
A3: rng (I +* J) c= rng I \/ rng J by FUNCT_4:18;
    assume
A4: i in rng (I +* J);
    per cases by A4,A3,XBOOLE_0:def 3;
    suppose
      i in rng I;
      hence i does not destroy a by A1,SCMFSA7B:def 4;
    end;
    suppose
      i in rng J;
      hence i does not destroy a by A2,SCMFSA7B:def 4;
    end;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th26:
  for I,J being good preProgram of SCM+FSA holds I +* J is good
proof
  let I,J be good preProgram of SCM+FSA;
  I does not destroy intloc 0 & J does not destroy intloc 0 by SCMFSA7B:def 5;
  then I +* J does not destroy intloc 0 by Th25;
  hence thesis by SCMFSA7B:def 5;
end;

theorem Th27:
  for I being preProgram of SCM+FSA, l being Element of NAT
, a being Int-Location holds I does not destroy a implies Directed(I,
  l) does not destroy a
proof
  let I be preProgram of SCM+FSA;
  let l be Element of NAT;
  let a be Int-Location;
  assume
A1: I does not destroy a;
  now
    let i be Instruction of SCM+FSA;
A2: dom Directed(I,l) = dom I by FUNCT_4:105;
    assume i in rng Directed(I,l);
    then consider x being set such that
A3: x in dom Directed(I,l) and
A4: i = Directed(I,l).x by FUNCT_1:def 5;
    per cases;
    suppose
      I.x <> halt SCM+FSA;
      then i = I.x by A4,FUNCT_4:111;
      then i in rng I by A3,A2,FUNCT_1:def 5;
      hence i does not destroy a by A1,SCMFSA7B:def 4;
    end;
    suppose
      I.x = halt SCM+FSA;
      then i = goto l by A3,A4,A2,FUNCT_4:112;
      hence i does not destroy a by SCMFSA7B:17;
    end;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

registration
  let I be good preProgram of SCM+FSA;
  let l be Element of NAT;
  cluster Directed(I,l) -> good;
  correctness
  proof
    I does not destroy intloc 0 by SCMFSA7B:def 5;
    then Directed(I,l) does not destroy intloc 0 by Th27;
    hence thesis by SCMFSA7B:def 5;
  end;
end;

registration
  let I be good Program of SCM+FSA;
  cluster Directed I -> good;
  correctness;
end;

registration
  let I be Program of SCM+FSA, l be Element of NAT;
  cluster Directed(I,l) -> initial;
  correctness
  proof
    now
      let m,n be Nat;
      assume n in dom Directed(I,l);
      then
A1:    n in dom I by FUNCT_4:105;
      assume m < n;
      then  m in dom I by A1,AFINSQ_1:def 13;
      hence m in dom Directed(I,l) by FUNCT_4:105;
    end;
    hence thesis by AFINSQ_1:def 13;
  end;
end;

registration
  let I,J be good Program of SCM+FSA;
  cluster I ';' J -> good;
  coherence
  proof
    ProgramPart Relocated(J,card I) is good by Th24;
    hence thesis by Th26;
  end;
end;

Lm1: for l being Element of NAT holds dom ( 0 .--> goto
l) = { 0} &  0 in dom ( 0 .--> goto l) & ( 0 .--> goto
l). 0 = goto l & card ( 0 .--> goto l) = 1 & not halt SCM+FSA in
rng ( 0 .--> goto l)

proof
  let l be Element of NAT;
  thus dom ( 0 .--> goto l) = { 0} by FUNCOP_1:19;
  hence  0 in dom ( 0 .--> goto l) by TARSKI:def 1;
  thus ( 0 .--> goto l). 0 = goto l by FUNCOP_1:87;
  thus card ( 0 .--> goto l) = card <% goto l %> by AFINSQ_1:def 2
    .= len <% goto l %>
    .= 1 by AFINSQ_1:38;
  now
A1: rng ( 0 .--> goto l) = {goto l} by FUNCOP_1:14;
    assume halt SCM+FSA in rng ( 0 .--> goto l);
    then halt SCM+FSA = goto l by A1,TARSKI:def 1;
    hence contradiction by SCMFSA_2:47;
  end;
  hence thesis;
end;

definition
  canceled;
  let l be Element of NAT;
  func Goto l -> Program of SCM+FSA equals
   0 .--> goto l;
  coherence
  proof
     0 .--> goto l = <% goto l %> by AFINSQ_1:def 2;
    then reconsider I =  0 .--> goto l as Program of SCM+FSA;
    not halt SCM+FSA in rng I by Lm1;
    then reconsider I as :::halt-free
    Program of SCM+FSA by COMPOS_1:def 7;
    now
      let x be Instruction of SCM+FSA;
A1:   rng ( 0 .--> goto l) = {goto l} by FUNCOP_1:14;
      assume x in rng ( 0 .--> goto l);
      then x = goto l by A1,TARSKI:def 1;
      hence x does not destroy intloc 0 by SCMFSA7B:17;
    end;
    then I does not destroy intloc 0 by SCMFSA7B:def 4;
    hence thesis by SCMFSA7B:def 5;
  end;
end;

registration
  let l be Element of NAT;
  cluster Goto l -> halt-free good;
  coherence
  proof
     0 .--> goto l = <% goto l %> by AFINSQ_1:def 2;
    then reconsider I =  0 .--> goto l as Program of SCM+FSA;
    not halt SCM+FSA in rng I by Lm1;
   hence Goto l is halt-free by COMPOS_1:def 7;
    then reconsider I as :::halt-free
    Program of SCM+FSA by COMPOS_1:def 7;
    now
      let x be Instruction of SCM+FSA;
A1:   rng ( 0 .--> goto l) = {goto l} by FUNCOP_1:14;
      assume x in rng ( 0 .--> goto l);
      then x = goto l by A1,TARSKI:def 1;
      hence x does not destroy intloc 0 by SCMFSA7B:17;
    end;
    then I does not destroy intloc 0 by SCMFSA7B:def 4;
    hence thesis by SCMFSA7B:def 5;
  end;
end;

registration
 cluster halt-free good Program of SCM+FSA;
 existence
  proof
   take Goto 0;
   thus thesis;
  end;
end;

definition
  let s be State of SCM+FSA;
  let P be initial FinPartState of SCM+FSA;
  pred P is_pseudo-closed_on s means
  :Def3:
  ex k being Element of NAT st
   IC Comput(ProgramPart(s +* (P +* Start-At( 0,SCM+FSA))),
  s +* (P +* Start-At( 0, SCM+FSA)),k) =
  card ProgramPart P &
  for
  n being Element of NAT st n < k holds IC Comput(ProgramPart(s +* (P +*
Start-At(
   0,SCM+FSA))),s +* (P +* Start-At(
   0,SCM+FSA)),n) in dom P;
end;

definition
  let P be initial FinPartState of SCM+FSA;
  attr P is pseudo-paraclosed means

  for s being State of SCM+FSA holds
  P is_pseudo-closed_on s;
end;

registration
 cluster sequential Instruction of SCM+FSA;
 existence
  proof take intloc 0:= intloc 0; thus thesis; end;
end;

registration let i be sequential Instruction of SCM+FSA;
 cluster <%i%> -> pseudo-paraclosed;
 coherence
  proof
   set P = <%i%>;
   let s be State of SCM+FSA;
    set s1 = s +* (P +* Start-At( 0, SCM+FSA));
    dom P = 1 by AFINSQ_1:36;
    then
F:  0 in dom P by CARD_1:87,TARSKI:def 1;
    s1 = Initialize(s +* P) by FUNCT_4:15;
    then
E:  ProgramPart s1 = ProgramPart(s +* P) +* ProgramPart Start-At( 0, SCM+FSA)
            by FUNCT_4:75
      .= ProgramPart(s +* P) +* {} by COMPOS_1:27
      .= ProgramPart(s +* P) by FUNCT_4:22
      .= ProgramPart s +* ProgramPart P by FUNCT_4:75
      .= ProgramPart s +* P by RELAT_1:209;
    dom(ProgramPart s +* P) = dom ProgramPart s \/ dom P by FUNCT_4:def 1;
    then
G:  0 in dom(ProgramPart s +* P) by F,XBOOLE_0:def 3;
D:  IC s1 = 0 by COMPOS_1:def 16;
   then
C: CurInstr(ProgramPart s1,s1)
        = (ProgramPart s1)/.0
       .= (ProgramPart s1).0 by G,E,PARTFUN1:def 8
       .= (ProgramPart s +* P).0 by E
       .= P.0 by F,FUNCT_4:14
       .= i by AFINSQ_1:38;
   take 1;
   thus IC Comput(ProgramPart s1, s1,1)
    = IC Comput(ProgramPart s1, s1,0+1)
   .= IC Following(ProgramPart s1,Comput(ProgramPart s1,s1,0)) by EXTPRO_1:4
   .= IC Following(ProgramPart s1,s1) by EXTPRO_1:3
   .= IC Exec(CurInstr(ProgramPart s1,s1),s1)
   .= IC Exec(i,s1) by C
   .= succ IC s1 by AMISTD_1:def 16
   .= succ 0 by D
   .= card P by AFINSQ_1:38
   .= card ProgramPart P by RELAT_1:209;
   let n be Element of NAT;
   assume n < 1;
    then n = 0 by NAT_1:14;
    then
A:   IC Comput(ProgramPart s1,s1,n)
     = IC s1 by EXTPRO_1:3
    .= 0 by D;
    dom P = 1 by AFINSQ_1:36;
   hence IC Comput(ProgramPart s1,s1,n) in dom P by A,CARD_1:87,TARSKI:def 1;

  end;
end;

registration
  cluster pseudo-paraclosed Program of SCM+FSA;
  existence
  proof
   take <%the sequential Instruction of SCM+FSA%>;
   thus thesis;
  end;
end;

definition
  let s be State of SCM+FSA,
      P be initial FinPartState of SCM+FSA such that
A1: P is_pseudo-closed_on s;
  func pseudo-LifeSpan(s,P) -> Element of NAT means
  :Def5:
  IC Comput(ProgramPart((s +* (P +* Start-At( 0,SCM+FSA)))),(s
  +* (P +* Start-At( 0,SCM+FSA))),it) =  card ProgramPart P &
   for n being Element of NAT st not IC Comput(ProgramPart(
 (s +* (P +* Start-At( 0,SCM+FSA)))),
 (s +* (P +* Start-At( 0,SCM+FSA))),n) in dom
  P holds it <= n;
  existence
  proof
    consider k being Element of NAT such that
A2: IC Comput(ProgramPart( (s +* (P +* Start-At( 0,SCM+FSA)))), (s +* (P +*
Start-At( 0,SCM+FSA))),k) =  card
ProgramPart P & for n being Element of NAT st n < k holds IC Comput(ProgramPart
( (s +*
    (P +* Start-At( 0,SCM+FSA)))), (s +*
    (P +* Start-At( 0,SCM+FSA))),n) in dom P by A1,Def3;
    take k;
    thus thesis by A2;
  end;
  uniqueness
  proof
    reconsider I = ProgramPart P
      as initial preProgram of SCM+FSA;
    let k1,k2 be Element of NAT such that
A3: IC Comput(ProgramPart( (s +* (P +* Start-At( 0,SCM+FSA)))), (s +* (P +*
Start-At( 0,SCM+FSA))),k1) =  card
    ProgramPart P and
A4: ( for n being Element of NAT st not IC Comput(ProgramPart( (s +* (P +*
    Start-At( 0,SCM+FSA)))), (s +* (P +*
    Start-At( 0,SCM+FSA))),n) in dom P holds k1 <= n)&
     IC Comput(ProgramPart( (s +* (P +*
    Start-At( 0,SCM+FSA)) )), (s +* (P +*
    Start-At( 0,SCM+FSA)) ),k2) =  card ProgramPart P and
A5: for n being Element of NAT st not IC Comput(ProgramPart( (s +* (P +*
    Start-At( 0,SCM+FSA)))), (s +* (P +*
    Start-At( 0,SCM+FSA))),n) in dom P holds k2 <= n;
A6: now
      assume k2 < k1;
      then  card I in dom I by A4,COMPOS_1:16;
      hence contradiction;
    end;
    now
      assume k1 < k2;
      then  card I in dom I by A3,A5,COMPOS_1:16;
      hence contradiction;
    end;
    hence thesis by A6,XXREAL_0:1;
  end;
end;

theorem Th28:
  for I,J being Program of SCM+FSA, x being set holds x in dom I
  implies (I ';' J).x = (Directed I).x
proof
  let I,J be Program of SCM+FSA;
  let x be set;
  assume x in dom I;
  then
A1: x in dom Directed I by FUNCT_4:105;
  Directed I c= I ';' J by SCMFSA6A:55;
  hence thesis by A1,GRFUNC_1:8;
end;

theorem
  for l being Element of NAT holds card Goto l = 1 by Lm1;

theorem
  for P being preProgram of SCM+FSA, x being set st x in dom P holds (P.
  x = halt SCM+FSA implies (Directed P).x = goto  card P) & (P.x <> halt
  SCM+FSA implies (Directed P).x = P.x) by FUNCT_4:111,112;

theorem Th31:
  for s being State of SCM+FSA, P being initial FinPartState of
  SCM+FSA st P is_pseudo-closed_on s holds for n being Element of NAT st n <
pseudo-LifeSpan(s,P) holds IC ( Comput(ProgramPart( (s +* (P
+*
 Start-At( 0,SCM+FSA)))), (s +* (P +*
 Start-At( 0,SCM+FSA))),n)
  ) in dom P & CurInstr ( ProgramPart Comput(ProgramPart( (s +* (P +*
   Start-At( 0,SCM+FSA)))), (s +* (P +*
   Start-At( 0,SCM+FSA))),n),
    Comput(ProgramPart( (s +* (P +*
   Start-At( 0,SCM+FSA)))), (s +* (P +*
   Start-At( 0,SCM+FSA))),n)) <>
  halt SCM+FSA
proof
  let s be State of SCM+FSA;
  let P be initial FinPartState of SCM+FSA;
  set k = pseudo-LifeSpan(s,P);
  assume
A1: P is_pseudo-closed_on s;
  then
A2: IC ( Comput(ProgramPart( (s +* (P +* Start-At( 0,SCM+FSA)))), (s +* (P +*
Start-At( 0,SCM+FSA))),k)) =
  card
  ProgramPart P by Def5;
  hereby
    let n be Element of NAT;
    assume
A3: n < k;
    hence IC ( Comput(ProgramPart( (s +* (P +* Start-At( 0,SCM+FSA))) ), (s +*
(P +* Start-At( 0,SCM+FSA))) ,n))
     in dom P
    by A1,Def5;
    then
A4: IC ( Comput(ProgramPart( (s +* (P +* Start-At( 0,SCM+FSA)))), (s +* (P +*
Start-At( 0,SCM+FSA))),n)) in dom
    ProgramPart P by COMPOS_1:16;
T: ProgramPart (s +* (P +* Start-At( 0,SCM+FSA))) =
  ProgramPart Comput(ProgramPart( (s +* (P +* Start-At( 0,SCM+FSA))
)), (s +* (P +* Start-At( 0,SCM+FSA))),n)
by AMI_1:123;
    assume
    CurInstr (ProgramPart Comput(ProgramPart( (s +* (P +* Start-At( 0,SCM+FSA))
)), (s +* (P +* Start-At( 0,SCM+FSA))),n),
     Comput(ProgramPart( (s +* (P +* Start-At( 0,SCM+FSA)))), (s +* (P +*
Start-At( 0,SCM+FSA))),n)) = halt
    SCM+FSA;
    then
    IC Comput(ProgramPart( (s +* (P +* Start-At( 0,SCM+FSA)))), (s +* (P +*
Start-At( 0,SCM+FSA))),k) =
     IC Comput(ProgramPart( (
    s +* (P +* Start-At( 0,SCM+FSA)))), (
    s +* (P +* Start-At( 0,SCM+FSA))),n) by A3,T,EXTPRO_1:6;
    hence contradiction by A2,A4;
  end;
end;

theorem Th32:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA st I
  is_pseudo-closed_on s for k being Element of NAT st k <= pseudo-LifeSpan(
s,I)
  holds Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s +* (I +*
Start-At( 0,SCM+FSA))),k),
   Comput(ProgramPart( (s +* ((I
  ';' J) +* Start-At( 0,SCM+FSA)))), (s +* ((I
  ';' J) +* Start-At( 0,SCM+FSA))),k) equal_outside NAT
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  set s1 = s +* (I +* Start-At( 0,SCM+FSA));
  set s2 = s +* ((I ';' J) +* Start-At( 0,SCM+FSA));
  set I1 = I +* Start-At( 0,SCM+FSA);
  set I2 = (I ';' J) +* Start-At( 0,SCM+FSA);
  defpred P[Nat] means $1 <= pseudo-LifeSpan(s,I) implies
  Comput(ProgramPart(s1),s1,$1), Comput(ProgramPart(s2),s2,$1) equal_outside A;
  assume
A1: I is_pseudo-closed_on s;
A2: now
    let k be Element of NAT;
    assume
A3: P[k];
    thus P[k+1]
    proof
T: ProgramPart s2 = ProgramPart Comput(ProgramPart
(s2),s2,k)
by AMI_1:123;
A4:   Comput(ProgramPart(s2),s2,k+1) = Following(ProgramPart s2,
Comput(ProgramPart(s2),s2,k)) by EXTPRO_1:4
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(
ProgramPart(s2),s2,k)),
        Comput(ProgramPart(s2),s2,k)) by T;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart
(s1),s1,k)
by AMI_1:123;
A5:   Comput(ProgramPart(s1),s1,k+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,k)) by EXTPRO_1:4
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(
ProgramPart(s1),s1,k)),
        Comput(ProgramPart(s1),s1,k)) by T;
A6:   dom I c= dom (I ';' J) by SCMFSA6A:56;
      I ';' J c= I2 & I2 c= s2 by Th9,FUNCT_4:26;
      then I ';' J c= s2 by XBOOLE_1:1;
      then
A7:   I ';' J c= Comput(ProgramPart(s2),s2,k) by AMI_1:81;
A8:   k + 0 < k + 1 by XREAL_1:8;
      assume
A9:   k + 1 <= pseudo-LifeSpan(s,I);
      then
A10:  k < pseudo-LifeSpan(s,I) by A8,XXREAL_0:2;
      then
A11:  IC Comput(ProgramPart(s1),s1,k) in dom I by A1,Th31;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,k))/.IC Comput(ProgramPart(s1),s1,k)
 = Comput(ProgramPart(s1),s1,k).IC Comput(ProgramPart(s1),s1,k) by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by COMPOS_1:38;
      I c= I1 & I1 c= s1 by Th9,FUNCT_4:26;
      then I c= s1 by XBOOLE_1:1;
      then I c= Comput(ProgramPart(s1),s1,k) by AMI_1:81;
      then
A12:  CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(ProgramPart(s1),
s1,k))
 = I.IC Comput(ProgramPart(s1),s1,k) by A11,Y,GRFUNC_1:8;
      then I.IC Comput(ProgramPart(s1),s1,k) <> halt SCM+FSA by A1,A10,Th31;
      then
      CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(ProgramPart(s1),
s1,k))
       = (I ';' J).IC Comput(ProgramPart(s1),s1,k) by A11,A12,SCMFSA6A:54
        .= Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s1),s1,k) by A7
,A11,A6,GRFUNC_1:8
        .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart
(s2),s2,k))
         by A3,A9,A8,Z,COMPOS_1:24,XXREAL_0:2;
      hence thesis by A3,A9,A8,A5,A4,SCMFSA6A:32,XXREAL_0:2;
    end;
  end;
A13: P[0]
  proof
    assume 0 <= pseudo-LifeSpan(s,I);
    s1,s2 equal_outside A by Th14;
    then Comput(ProgramPart(s1),s1,0),s2 equal_outside A by EXTPRO_1:3;
    hence thesis by EXTPRO_1:3;
  end;
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A13,A2);
end;

theorem Th33:
  for I being preProgram of SCM+FSA, l being Element of NAT
  holds card Directed(I,l) = card I
proof
  let I be preProgram of SCM+FSA;
  let l be Element of NAT;
  thus card Directed(I,l) = card dom Directed(I,l) by CARD_1:104
    .= card dom I by FUNCT_4:105
    .= card I by CARD_1:104;
end;

theorem
  for I being Program of SCM+FSA holds card Directed I = card I by Th33;

theorem Th35:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_on s & I is_halting_on s holds for k being Element of NAT st k <=
  LifeSpan(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +* Start-At( 0
,SCM+FSA)))
   holds Comput(ProgramPart( (s +* (I +*
Start-At( 0,SCM+FSA)))), (s +* (I +*
Start-At( 0,SCM+FSA))),k), Comput(ProgramPart( (s +* (Directed I +*
 Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
 Start-At( 0,SCM+FSA))),k
  ) equal_outside NAT &
   CurInstr(ProgramPart (s +* (Directed I +* Start-At(
   0,SCM+FSA))),
    Comput(ProgramPart( (s +* (Directed I +* Start-At(
   0,SCM+FSA)))), (s +* (Directed I +* Start-At(
   0,SCM+FSA))),k)) <> halt SCM+FSA
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s;
  set s2 = s +* (Directed I +* Start-At( 0,SCM+FSA));
  set s1 = s +* (I +* Start-At( 0,SCM+FSA));
  defpred P[Nat] means $1 <= LifeSpan(ProgramPart(s1),s1) implies ( Comput(
ProgramPart(s1),s1,
  $1), Comput(ProgramPart(s2),s2,$1) equal_outside A &
  CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,$1)) <> halt SCM+FSA);
A3: now
    let k be Element of NAT;
    dom Directed I = dom I by FUNCT_4:105;
    then
A4: IC Comput(ProgramPart(s1),s1,k) in dom Directed I by A1,SCMFSA7B:def 7;
    Directed I c= (Directed I +* Start-At( 0,SCM+FSA)) & (Directed I +*
    Start-At( 0,SCM+FSA)) c= s2 by Th9,FUNCT_4:26;
    then Directed I c= s2 by XBOOLE_1:1;
    then
A5: Directed I c= Comput(ProgramPart(s2),s2,k) by AMI_1:81;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by COMPOS_1:38;
    assume
    Comput(ProgramPart(s1),s1,k), Comput(ProgramPart(s2),s2,k) equal_outside A;
    then CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(
s2),s2,k))
     = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s1),s1,k)
    by Y,COMPOS_1:24
      .= (Directed I).IC Comput(ProgramPart(s1),s1,k) by A5,A4,GRFUNC_1:8;
    then
A6: CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(s2),s2
,k)) in rng Directed I
 by A4,FUNCT_1:def 5;
    assume
    CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(s2),s2
,k)) = halt SCM+FSA;
    hence contradiction by A6,SCMFSA6A:18;
  end;
  now
A7: ProgramPart s1 halts_on s1 by A2,SCMFSA7B:def 8;
A8: dom I c= dom Directed I by FUNCT_4:105;
    let k be Element of NAT;
    assume
A9: k <= LifeSpan(ProgramPart(s1),s1) implies Comput(ProgramPart(s1),s1,k),
Comput(ProgramPart(s2),s2,k)
    equal_outside A;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:123;
A10: Comput(ProgramPart(s2),s2,k+1) = Following(ProgramPart s2,
Comput(ProgramPart(s2),s2,k)) by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(
ProgramPart(s2),s2,k)),
      Comput(ProgramPart(s2),s2,k)) by T;
A11: IC Comput(ProgramPart(s1),s1,k) in dom I by A1,SCMFSA7B:def 7;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,k))/.IC Comput(ProgramPart(s1),s1,k)
 = Comput(ProgramPart(s1),s1,k).IC Comput(ProgramPart(s1),s1,k) by COMPOS_1:38;
TX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:123;
    I c= I +* Start-At( 0,SCM+FSA) & I +* Start-At( 0,SCM+FSA)
     c= s1 by Th9,FUNCT_4:26;
    then I c= s1 by XBOOLE_1:1;
    then I c= Comput(ProgramPart(s1),s1,k) by AMI_1:81;
    then
A12: CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,k))
 = I.IC Comput(ProgramPart(s1),s1,k) by A11,Y,TX,GRFUNC_1:8;
    Directed I c= (Directed I +* Start-At( 0,SCM+FSA)) & (Directed I +*
    Start-At( 0,SCM+FSA)) c= s2 by Th9,FUNCT_4:26;
    then Directed I c= s2 by XBOOLE_1:1;
    then
A13: Directed I c= Comput(ProgramPart(s2),s2,k) by AMI_1:81;
A14: k + 0 < k + 1 by XREAL_1:8;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by COMPOS_1:38;
    assume
A15: k + 1 <= LifeSpan(ProgramPart(s1),s1);
    then k < LifeSpan(ProgramPart(s1),s1) by A14,XXREAL_0:2;
    then I.IC Comput(ProgramPart(s1),s1,k) <> halt SCM+FSA by A12,A7,
EXTPRO_1:def 14;
    then
A16: CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,k))
 = (Directed I).IC Comput(ProgramPart(s1),s1,k) by A12,FUNCT_4:111
      .= Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s1),s1,k) by A13
,A11,A8,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(
s2),s2,k))
      by A9,A15,A14,Y,COMPOS_1:24,XXREAL_0:2;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:123;
TY: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k+1)
by AMI_1:123;
A17: Comput(ProgramPart(s1),s1,k+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,k)) by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(
ProgramPart(s1),s1,k)),
      Comput(ProgramPart(s1),s1,k)) by T;
    hence Comput(ProgramPart(s1),s1,k+1), Comput(ProgramPart(s2),s2,k+1)
equal_outside A by A9,A15,TX,A14,A16,A10,SCMFSA6A:32,XXREAL_0:2;
    thus CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k+1)) <>
     halt SCM+FSA by A3,A9,A15,A14,A16,A17,TX,TY,A10,SCMFSA6A:32,XXREAL_0:2;
  end;
  then
A18: for k being Element of NAT st P[k] holds P[k + 1];
  now
    assume 0 <= LifeSpan(ProgramPart(s1),s1);
A19: Comput(ProgramPart(s1),s1,0) = s1 & Comput(ProgramPart(s2),s2,0) = s2 by
EXTPRO_1:3;
    hence Comput(ProgramPart(s1),s1,0), Comput(ProgramPart(s2),s2,0)
equal_outside A by Th14;
    thus CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,0)) <>
     halt SCM+FSA by A3,A19,Th14;
  end;
  then
A20: P[0];
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A20,A18);
end;

theorem Th36:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_on s & I is_halting_on s holds IC Comput(ProgramPart( (s +* (
Directed I +*
  Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
  Start-At( 0,SCM+FSA))), (LifeSpan(ProgramPart(s +*
   (I +* Start-At( 0,SCM+FSA))),s +*
   (I +* Start-At( 0,SCM+FSA))) + 1)) =
card I & DataPart Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s
+* (I +* Start-At( 0,SCM+FSA))),
 (LifeSpan(ProgramPart(s +*
  (I +* Start-At( 0,SCM+FSA))),s +*
  (I +* Start-At( 0,SCM+FSA))))) =
   DataPart Comput(ProgramPart( (s +* (Directed I +*
  Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
  Start-At( 0,SCM+FSA))),
   (LifeSpan(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +* Start-At(
0,SCM+FSA))) + 1))
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* (I +* Start-At( 0,SCM+FSA));
  set s2 = s +* (Directed I +* Start-At( 0,SCM+FSA));
  set m1 = LifeSpan(ProgramPart(s1),s1);
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s;
A3: ProgramPart s1 halts_on s1 by A2,SCMFSA7B:def 8;
  set l1 = IC Comput(ProgramPart( s1), s1,m1);
A4: l1 in dom I by A1,SCMFSA7B:def 7;
  then IC Comput(ProgramPart( s2), s2,m1) in dom I by A1,A2,Th35,COMPOS_1:24;
  then
A5: IC Comput(ProgramPart( s2), s2,m1) in dom Directed I by FUNCT_4:105;
  Directed I c= Directed I +* Start-At( 0,SCM+FSA) by Th9;
  then
A6: dom Directed I c= dom (Directed I +* Start-At( 0,SCM+FSA))
 by GRFUNC_1:8;
A7: dom I = dom Directed I by FUNCT_4:105;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,m1))/.IC Comput(ProgramPart(s1),s1,
m1)
 = Comput(ProgramPart(s1),s1,m1).IC Comput(ProgramPart(s1),s1,m1) by
COMPOS_1:38;
TX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m1)
by AMI_1:123;
  I c= I +* Start-At( 0,SCM+FSA) by Th9;
  then dom I c= dom (I +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
  then s1.l1 = (I +* Start-At( 0,SCM+FSA)).l1 by A4,FUNCT_4:14;
  then
A8: I.l1 = s1.l1 by A4,COMPOS_1:145
    .= CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,m1))
    by Y,TX,AMI_1:54
    .= halt SCM+FSA by A3,EXTPRO_1:def 14;
  l1 = IC Comput(ProgramPart( s2), s2,m1) by A1,A2,Th35,COMPOS_1:24;
  then
A9: s2.l1 = (Directed I +* Start-At( 0,SCM+FSA)).l1 by A5,A6,FUNCT_4:14
    .= (Directed I).l1 by A4,A7,COMPOS_1:145
    .= goto  card I by A4,A8,FUNCT_4:112;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,m1))/.IC Comput(ProgramPart(s2),s2,
m1)
 = Comput(ProgramPart(s2),s2,m1).IC Comput(ProgramPart(s2),s2,m1) by
COMPOS_1:38;
A10: CurInstr(ProgramPart Comput(ProgramPart(s2),s2,m1),Comput(ProgramPart(s2),
s2,m1))
 = Comput(ProgramPart( s2), s2,m1).l1 by A1,A2,Th35,Y,COMPOS_1:24
    .= goto  card I by A9,AMI_1:54;
T: ProgramPart s2 = ProgramPart Comput(
ProgramPart(s2),s2,m1)
by AMI_1:123;
A11: Comput(ProgramPart( s2), s2,m1 + 1) = Following(ProgramPart s2,
Comput(ProgramPart(s2),s2,m1)) by EXTPRO_1:4
    .= Exec(goto  card I, Comput(ProgramPart( s2), s2,m1)) by A10,T;
  hence IC Comput(ProgramPart( s2), s2,m1 + 1) =  card I by SCMFSA_2:95;
A12: ( for a being Int-Location holds Comput(ProgramPart( s2), s2,m1 + 1).a =
Comput(ProgramPart( s2), s2, m1).a)& for f being FinSeq-Location holds Comput(
ProgramPart( s2), s2,m1
  + 1).f = Comput(ProgramPart( s2), s2,m1).f by A11,SCMFSA_2:95;
  DataPart Comput(ProgramPart( s1), s1,m1) = DataPart Comput(ProgramPart( s2),
s2,m1) by A1,A2,Th35,SCMFSA6A:39;
  hence thesis by A12,SCMFSA6A:38;
end;

Lm2: for s being State of SCM+FSA, I being Program of SCM+FSA holds I
is_closed_on s & I is_halting_on s implies Directed I is_pseudo-closed_on s &
pseudo-LifeSpan(s,Directed I) =
 LifeSpan(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +* Start-At( 0,
SCM+FSA))) + 1

proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* (I +* Start-At( 0,SCM+FSA));
  set s2 = s +* (Directed I +* Start-At( 0,SCM+FSA));
  set m1 = LifeSpan(ProgramPart(s1),s1);
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s;
A3: dom I = dom Directed I by FUNCT_4:105;
A4: now
    let n be Element of NAT;
    assume n < m1 + 1;
    then n <= m1 by NAT_1:13;

    then IC Comput(ProgramPart( s1), s1,n) = IC Comput(ProgramPart( s2), s2,n)
by A1,A2,Th35,COMPOS_1:24;

    hence IC Comput(ProgramPart( s2), s2,n) in dom Directed I by A1,A3,
SCMFSA7B:def 7;
  end;
  ProgramPart Directed I = Directed I by RELAT_1:209;
  then card I = card ProgramPart Directed I by Th33;

  then
A5: IC Comput(ProgramPart( s2), s2,m1 + 1) =  card ProgramPart Directed I by A1
,A2,Th36;

  hence
A6: Directed I is_pseudo-closed_on s by A4,Def3;

  for n be Element of NAT st not IC Comput(ProgramPart( s2), s2,n) in dom
Directed I
  holds m1 + 1 <= n by A4;

  hence thesis by A5,A6,Def5;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA holds I
is_closed_on s & I is_halting_on s implies Directed I is_pseudo-closed_on s by
Lm2;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA holds I
  is_closed_on s & I is_halting_on s implies pseudo-LifeSpan(
s,Directed I) =
  LifeSpan(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +* Start-At( 0
,SCM+FSA))) + 1 by Lm2;

canceled 2;

theorem Th41:
  for I,J being Program of SCM+FSA holds Directed I ';' J = I ';'
  J
proof
  let I,J be Program of SCM+FSA;
  thus Directed I ';' J = Directed I +* ProgramPart Relocated(J,card Directed
  I) by SCMFSA6A:63
    .= I ';' J by Th33;
end;

theorem Th42:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA st I
  is_closed_on s & I is_halting_on s holds (for k being Element of NAT st k <=
LifeSpan(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +* Start-At( 0,
SCM+FSA)))
 holds IC Comput(ProgramPart( (s +* (Directed
  I +* Start-At( 0,SCM+FSA)))), (s +* (Directed
  I +* Start-At( 0,SCM+FSA))),k) = IC Comput(ProgramPart( (s +* ((I ';' J)
   +* Start-At(
 0,SCM+FSA)))), (s +* ((I ';' J)
   +* Start-At(
 0,SCM+FSA))),k) & CurInstr(ProgramPart Comput(ProgramPart( (s +* (Directed I
+*
 Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
 Start-At( 0,SCM+FSA))),
  k),
   Comput(ProgramPart( (s +* (Directed I +*
 Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
 Start-At( 0,SCM+FSA))),
  k)) = CurInstr(ProgramPart Comput(ProgramPart( (s +* ((I ';' J) +*
   Start-At( 0,SCM+FSA)))), (s +* ((I ';' J) +*
   Start-At( 0,SCM+FSA))),k),
    Comput(ProgramPart( (s +* ((I ';' J) +*
   Start-At( 0,SCM+FSA)))), (s +* ((I ';' J) +*
   Start-At( 0,SCM+FSA))),k))) &
DataPart Comput(ProgramPart( (s +* (Directed I +* Start-At( 0,SCM+FSA)))), (s
+* (Directed I +* Start-At( 0,SCM+FSA))),
 (LifeSpan(ProgramPart(s +*
  (I +* Start-At( 0,SCM+FSA))),s +*
  (I +* Start-At( 0,SCM+FSA))) + 1)) =
   DataPart Comput(ProgramPart( (s +* ((I ';' J) +*
  Start-At( 0,SCM+FSA)))), (s +* ((I ';' J) +*
  Start-At( 0,SCM+FSA))), (LifeSpan(ProgramPart(s +* (I +*
   Start-At( 0,SCM+FSA))),s +* (I +*
   Start-At( 0,SCM+FSA))) + 1)) & IC
  Comput(ProgramPart( (s +* (Directed I +* Start-At( 0,SCM+FSA)))), (s +* (
Directed I +* Start-At( 0,SCM+FSA))),
   (LifeSpan(ProgramPart(s +* (I +*
Start-At( 0,SCM+FSA))),s +* (I +*
Start-At( 0,SCM+FSA))) + 1)) = IC Comput(ProgramPart( (s +* ((I ';' J) +*
 Start-At(
  0,SCM+FSA)))), (s +* ((I ';' J) +*
 Start-At(
  0,SCM+FSA))), (LifeSpan(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I
+* Start-At( 0,SCM+FSA))) + 1))
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  assume
A1: I is_closed_on s;
  set s2 = s +* ((I ';' J) +* Start-At( 0,SCM+FSA));
A2: Directed I ';' J = I ';' J by Th41;
  set s1 = s +* (I +* Start-At( 0,SCM+FSA));
  assume
A3: I is_halting_on s;
  then
A4: LifeSpan(ProgramPart(s1),s1) + 1 = pseudo-LifeSpan(
s,Directed I) by A1,Lm2;
A5: Directed I is_pseudo-closed_on s by A1,A3,Lm2;
  hereby
A6: I ';' J c= (I ';' J +* Start-At( 0,SCM+FSA)) by Th9;
    then
A7: dom (I ';' J) c= dom (I ';' J +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
    let k be Element of NAT;
A8: Directed I c= (Directed I +* Start-At( 0,SCM+FSA)) by Th9;
    then
A9: dom Directed I c= dom (Directed I +* Start-At( 0,SCM+FSA))
 by GRFUNC_1:8;
    assume k <= LifeSpan(ProgramPart(s1),s1);
    then
A10: k < pseudo-LifeSpan(s,Directed I) by A4,NAT_1:13
;
    then
A11: IC Comput(ProgramPart( (s +* (Directed I +* Start-At( 0,SCM+FSA)))), (s +*
(Directed I +* Start-At( 0,SCM+FSA))),k)
 in dom
    Directed I by A5,Def5;
    thus
A12: IC ( Comput(ProgramPart(s +* (Directed I +* Start-At( 0,SCM+FSA))),s +* (
Directed I +* Start-At( 0,SCM+FSA)),k)) = IC
    Comput(ProgramPart( s2), s2,k) by A2,A5,A10,Th32,COMPOS_1:24;
Y:  (ProgramPart Comput(ProgramPart( (s +* (Directed I +*
     Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
     Start-At( 0,SCM+FSA))),k))/.IC Comput(ProgramPart( (s +* (Directed I +*
     Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
     Start-At( 0,SCM+FSA))),k)
 = Comput(ProgramPart( (s +* (Directed I +*
     Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
     Start-At( 0,SCM+FSA))),k).IC Comput(ProgramPart( (s +* (Directed I +*
     Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
     Start-At( 0,SCM+FSA))),k) by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by COMPOS_1:38;
A13: Directed I c= I ';' J by SCMFSA6A:55;
    then
A14: dom Directed I c= dom (I ';' J) by GRFUNC_1:8;
    then
A15: IC Comput(ProgramPart( (s +* (Directed I +* Start-At( 0,SCM+FSA)))), (s +*
(Directed I +* Start-At( 0,SCM+FSA))),k)
 in dom (I
    ';' J) by A11;
    thus CurInstr(ProgramPart Comput(ProgramPart( (s +* (Directed I +*
     Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
     Start-At( 0,SCM+FSA))),k), Comput(ProgramPart( (s +* (Directed I +*
     Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
     Start-At( 0,SCM+FSA))),k)) = (
s +* (Directed I +* Start-At( 0,SCM+FSA))). IC Comput(ProgramPart( (s +*
 (Directed I +*
    Start-At( 0,SCM+FSA)))), (s +*
 (Directed I +*
    Start-At( 0,SCM+FSA))),k) by Y,AMI_1:54
      .= (Directed I +* Start-At( 0,SCM+FSA)). IC Comput(ProgramPart( (s +*
       (Directed
    I +* Start-At( 0,SCM+FSA)))), (s +*
       (Directed
    I +* Start-At( 0,SCM+FSA))),k) by A11,A9,FUNCT_4:14
      .= (Directed I). IC Comput(ProgramPart( (s +* (Directed I +* Start-At(
    0,SCM+FSA)))), (s +* (Directed I +* Start-At(
    0,SCM+FSA))),k) by A11,A8,GRFUNC_1:8
      .= (I ';' J).IC Comput(ProgramPart( (s +* (Directed I +*
       Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
       Start-At( 0,SCM+FSA))),
    k) by A11,A13,GRFUNC_1:8
      .= (I ';' J +* Start-At( 0,SCM+FSA)).IC Comput(ProgramPart( (s +*
       (Directed I +*
    Start-At( 0,SCM+FSA)))), (s +*
       (Directed I +*
    Start-At( 0,SCM+FSA))),k) by A11,A14,A6,GRFUNC_1:8
      .= s2.IC Comput(ProgramPart( s2), s2,k) by A12,A15,A7,FUNCT_4:14
      .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(
s2),s2,k))
       by Z,AMI_1:54;
  end;
  Comput(ProgramPart( (s +* (Directed I +* Start-At( 0,SCM+FSA)))), (s +* (
Directed I +* Start-At( 0,SCM+FSA))),
  LifeSpan(ProgramPart(s1),s1) + 1 )
  , Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1) equal_outside
A by A1,A3,A2,A4,Lm2,Th32;
  hence thesis by COMPOS_1:24,SCMFSA6A:39;
end;

theorem Th43:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA st I
  is_closed_on Initialized s & I is_halting_on Initialized s holds (for k being
  Element of NAT st k <= LifeSpan(ProgramPart(s +* Initialized I),s +*
Initialized I)
 holds IC Comput(ProgramPart(s+* Initialized Directed I),
           s+* Initialized Directed I,k)
 = IC Comput(ProgramPart(s +* Initialized (I ';'J)),
          s +* Initialized (I ';' J),k)
&
CurInstr(ProgramPart(s +* Initialized Directed I),
         Comput(ProgramPart(s +* Initialized Directed I),
         s +* Initialized Directed I,k))
 = CurInstr(ProgramPart(s +* Initialized (I ';' J)),
        Comput(ProgramPart(s +* Initialized (I ';' J)),
        s +* Initialized (I ';' J),k)))
&
  DataPart Comput(ProgramPart(s +* Initialized Directed I),
         s +* Initialized Directed I,
         LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) + 1)
  = DataPart Comput(ProgramPart(s +* Initialized (I ';' J)),
          s +* Initialized (I ';' J),
          LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) + 1)
&
 IC Comput(ProgramPart(s +* Initialized Directed I),
           s +* Initialized Directed I,
           LifeSpan(ProgramPart(s +* Initialized I),s +*Initialized I) + 1)
 = IC Comput(ProgramPart(s +* Initialized (I ';' J)),
           s +* Initialized (I ';' J),
           LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) + 1)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  assume
A1: I is_closed_on Initialized s;
  set s2 = s +* Initialized (I ';' J);
A2: s +* Initialized Directed I = Initialized s +* (Directed I +* Start-At(
   0,SCM+FSA)) & s2 = Initialized s +* (I ';' J +*
   Start-At( 0,SCM+FSA))
   by Th13;
A3: Directed I ';' J = I ';' J by Th41;
  set s1 = s +* Initialized I;
  assume
A4: I is_halting_on Initialized s;
  s1 = Initialized s +* (I +* Start-At( 0,SCM+FSA)) by Th13;
  then
A5: LifeSpan(ProgramPart(s1),s1) + 1 = pseudo-LifeSpan(
Initialized s,Directed I) by A1,A4,Lm2;
A6: Directed I is_pseudo-closed_on Initialized s by A1,A4,Lm2;
  hereby
    let k be Element of NAT;
A7: Directed I c= Initialized Directed I by SCMFSA6A:26;
    then
A8: dom Directed I c= dom Initialized Directed I by GRFUNC_1:8;
    assume k <= LifeSpan(ProgramPart(s1),s1);
    then
A9: k < pseudo-LifeSpan(Initialized s,
Directed I) by A5,NAT_1:13;
    hence
A10: IC Comput(ProgramPart(s +* Initialized Directed I), (s +* Initialized
Directed I),k) = IC
    Comput(ProgramPart( s2), s2,k) by A2,A3,A6,Th32,COMPOS_1:24;
A11: I ';' J c= Initialized (I ';' J) by SCMFSA6A:26;
    then
A12: dom (I ';' J) c= dom Initialized (I ';' J) by GRFUNC_1:8;
    s +* Initialized Directed I = Initialized s +* (Directed I +* Start-At(
     0,SCM+FSA)) by Th13;
    then
A13: IC Comput(ProgramPart( (s +* Initialized Directed I)), (s +* Initialized
Directed I),k) in dom Directed I by A6,A9,Def5;
Y:  (ProgramPart Comput(ProgramPart( (s +* Initialized Directed I)), (s +*
Initialized Directed I),k))/.
IC Comput(ProgramPart( (s +* Initialized Directed I)), (s +* Initialized
Directed I),k)
 = Comput(ProgramPart( (s +* Initialized Directed I)), (s +* Initialized
Directed I),k).
 IC Comput(ProgramPart( (s +* Initialized Directed I)), (s +* Initialized
Directed I),k) by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by COMPOS_1:38;
A14: Directed I c= I ';' J by SCMFSA6A:55;
    then
A15: dom Directed I c= dom (I ';' J) by GRFUNC_1:8;
    then
A16: IC Comput(ProgramPart( (s +* Initialized Directed I)), (s +* Initialized
Directed I),k) in dom (I ';' J) by A13;
TX: ProgramPart (s +* Initialized Directed I) =
ProgramPart Comput(ProgramPart( (s +* Initialized Directed I)
), (s +* Initialized Directed I),k)
by AMI_1:123;
TY: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:123;
    thus CurInstr(ProgramPart (s +* Initialized Directed I),
     Comput(ProgramPart( (s +* Initialized Directed I)), (s +* Initialized
Directed I),k))
     = (s +*
Initialized Directed I). IC Comput(ProgramPart( (s +* Initialized Directed I)),
(s +* Initialized Directed I),k) by Y,TX,AMI_1:54
      .= (Initialized Directed I). IC Comput(ProgramPart( (s +* Initialized
    Directed I)), (s +* Initialized
    Directed I),k) by A13,A8,FUNCT_4:14
      .= (Directed I).IC Comput(ProgramPart( (s +* Initialized Directed I)), (s
+* Initialized Directed I),k) by A13,A7,GRFUNC_1:8
      .= (I ';' J).IC Comput(ProgramPart( (s +* Initialized Directed I)), (s +*
Initialized Directed I),k) by A13,A14,GRFUNC_1:8
      .= (Initialized (I ';' J)).IC Comput(ProgramPart( (s +* Initialized
Directed
    I)), (s +* Initialized Directed
    I),k) by A13,A15,A11,GRFUNC_1:8
      .= s2.IC Comput(ProgramPart( s2), s2,k) by A10,A16,A12,FUNCT_4:14
      .= CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k))
      by Z,TY,AMI_1:54;
  end;
  Comput(ProgramPart( (s +* Initialized Directed I)), (s +* Initialized
Directed I),LifeSpan(ProgramPart(s1),s1) + 1),
  Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1) equal_outside A
by A1,A4,A2,A3,A5,Lm2,Th32;
  hence thesis by COMPOS_1:24,SCMFSA6A:39;
end;

theorem Th44:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_on Initialized s & I is_halting_on Initialized s holds for k being
  Element of NAT st k <= LifeSpan(ProgramPart(s +* Initialized I),s +*
Initialized I) holds
Comput(ProgramPart(s +*Initialized I),
           s +* Initialized I,k),
           Comput(ProgramPart(s +* Initialized Directed I),
             s +* Initialized Directed I,k) equal_outside NAT
&
  CurInstr(ProgramPart(s +* Initialized Directed I),
        Comput(ProgramPart(s +* Initialized Directed I),
        s +* Initialized Directed I,k))
   <> halt SCM+FSA
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized Directed I;
  defpred P[Nat] means $1 <= LifeSpan(ProgramPart(s1),s1) implies ( Comput(
ProgramPart(s1),s1,
  $1), Comput(ProgramPart(s2),s2,$1) equal_outside A &
   CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,$1)) <> halt
  SCM+FSA);
A1: s1 = Initialized s +* (I +* Start-At( 0,SCM+FSA)) by Th13;
  assume
A2: I is_closed_on Initialized s;
A3: now
    let k be Element of NAT;
    Directed I c= Initialized Directed I & Initialized Directed I c= s2 by
FUNCT_4:26,SCMFSA6A:26;
    then Directed I c= s2 by XBOOLE_1:1;
    then
A4: Directed I c= Comput(ProgramPart(s2),s2,k) by AMI_1:81;
    dom Directed I = dom I by FUNCT_4:105;
    then
A5: IC Comput(ProgramPart(s1),s1,k) in dom Directed I by A2,A1,SCMFSA7B:def 7;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by COMPOS_1:38;
    assume
    Comput(ProgramPart(s1),s1,k), Comput(ProgramPart(s2),s2,k) equal_outside A;
    then CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(
s2),s2,k))
     = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s1),s1,k)
    by Y,COMPOS_1:24
      .= (Directed I).IC Comput(ProgramPart(s1),s1,k) by A4,A5,GRFUNC_1:8;
    then
A6: CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(s2),s2
,k)) in rng Directed I
 by A5,FUNCT_1:def 5;
    assume
    CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(s2),s2
,k)) = halt SCM+FSA;
    hence contradiction by A6,SCMFSA6A:18;
  end;
  assume
A7: I is_halting_on Initialized s;
  now
A8: ProgramPart s1 halts_on s1 by A7,A1,SCMFSA7B:def 8;
A9: dom I c= dom Directed I by FUNCT_4:105;
    let k be Element of NAT;
    assume
A10: k <= LifeSpan(ProgramPart(s1),s1) implies Comput(ProgramPart(s1),s1,k),
Comput(ProgramPart(
s2),s2,k)
    equal_outside A;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:123;
A11: Comput(ProgramPart(s2),s2,k+1) =
Following(ProgramPart s2,Comput(ProgramPart(s2),s2,k)
)
by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(
ProgramPart(s2),s2,k)),
      Comput(ProgramPart(s2),s2,k)) by T;
A12: IC Comput(ProgramPart(s1),s1,k) in dom I by A2,A1,SCMFSA7B:def 7;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,k))/.IC Comput(ProgramPart(s1),s1,k)
 = Comput(ProgramPart(s1),s1,k).IC Comput(ProgramPart(s1),s1,k) by COMPOS_1:38;
TX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:123;
    I c= Initialized I & Initialized I c= s1 by FUNCT_4:26,SCMFSA6A:26;
    then I c= s1 by XBOOLE_1:1;
    then I c= Comput(ProgramPart(s1),s1,k) by AMI_1:81;
    then
A13: CurInstr(ProgramPart s1,Comput(ProgramPart(s1),
s1,k))
 = I.IC Comput(ProgramPart(s1),s1,k) by A12,Y,TX,GRFUNC_1:8;
    Directed I c= Initialized Directed I & Initialized Directed I c= s2
    by FUNCT_4:26,SCMFSA6A:26;
    then Directed I c= s2 by XBOOLE_1:1;
    then
A14: Directed I c= Comput(ProgramPart(s2),s2,k) by AMI_1:81;
A15: k + 0 < k + 1 by XREAL_1:8;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by COMPOS_1:38;
    assume
A16: k + 1 <= LifeSpan(ProgramPart(s1),s1);
    then k < LifeSpan(ProgramPart(s1),s1) by A15,XXREAL_0:2;
    then I.IC Comput(ProgramPart(s1),s1,k) <> halt SCM+FSA by A13,A8,
EXTPRO_1:def 14;
    then
A17: CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(ProgramPart(s1),
s1,k))
 = (Directed I).IC Comput(ProgramPart(s1),s1,k) by A13,TX,FUNCT_4:111
      .= Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s1),s1,k) by A14
,A12,A9,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(
s2),s2,k))
       by A10,A16,A15,Y,COMPOS_1:24,XXREAL_0:2;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:123;
TU: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k+1)
by AMI_1:123;
A18: Comput(ProgramPart(s1),s1,k+1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,k)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(
ProgramPart(s1),s1,k)),
      Comput(ProgramPart(s1),s1,k)) by T;
    hence Comput(ProgramPart(s1),s1,k+1), Comput(ProgramPart(s2),s2,k+1)
equal_outside A by A10,A16,A15,A17,A11,SCMFSA6A:32,XXREAL_0:2;
    thus CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k+1)) <>
    halt SCM+FSA
    by A3,A10,A16,A15,A17,A18,A11,TU,SCMFSA6A:32,XXREAL_0:2;
  end;
  then
A19: for k being Element of NAT st P[k] holds P[k + 1];
  now
    assume 0 <= LifeSpan(ProgramPart(s1),s1);
A20: Comput(ProgramPart(s1),s1,0) = s1 & Comput(ProgramPart(s2),s2,0) = s2 by
EXTPRO_1:3;
    hence Comput(ProgramPart(s1),s1,0), Comput(ProgramPart(s2),s2,0)
equal_outside A by SCMFSA6A:53;
    thus CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,0))
     <> halt SCM+FSA by A3,A20,SCMFSA6A:53;
  end;
  then
A21: P[0];
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A21,A19);
end;

theorem Th45:
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
is_closed_on Initialized s & I is_halting_on Initialized s holds IC Comput(
ProgramPart(
  (s +* Initialized Directed I)),
  (s +* Initialized Directed I), (LifeSpan(ProgramPart(s +* Initialized I),s +*
Initialized I) + 1)) =
card I & DataPart Comput(ProgramPart( (s +* Initialized I)), (s +* Initialized
I),LifeSpan(ProgramPart(s +* Initialized
  I),s +* Initialized
  I)) = DataPart Comput(ProgramPart( (s +* Initialized Directed I)), (s +*
Initialized Directed I), (LifeSpan(ProgramPart(s +*
  Initialized I),s +*
  Initialized I) + 1))
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized Directed I;
  set m1 = LifeSpan(ProgramPart(s1),s1);
  assume
A1: I is_closed_on Initialized s;
  Directed I c= Initialized Directed I by SCMFSA6A:26;
  then
A2: dom Directed I c= dom Initialized Directed I by GRFUNC_1:8;
A3: dom I = dom Directed I by FUNCT_4:105;
  set l1 = IC Comput(ProgramPart( s1), s1,m1);
A4: s1 = Initialized s +* (I +* Start-At( 0,SCM+FSA)) by Th13;
  then
A5: l1 in dom I by A1,SCMFSA7B:def 7;
  assume
A6: I is_halting_on Initialized s;
  then IC Comput(ProgramPart( s2), s2,m1) in dom I by A1,A5,Th44,COMPOS_1:24;
  then
A7: IC Comput(ProgramPart( s2), s2,m1) in dom Directed I by FUNCT_4:105;
A8: ProgramPart s1 halts_on s1 by A6,A4,SCMFSA7B:def 8;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,m1))/.IC Comput(ProgramPart(s1),s1,
m1)
 = Comput(ProgramPart(s1),s1,m1).IC Comput(ProgramPart(s1),s1,m1) by
COMPOS_1:38;
TX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m1)
by AMI_1:123;
  I c= Initialized I by SCMFSA6A:26;
  then dom I c= dom Initialized I by GRFUNC_1:8;
  then s1.l1 = (Initialized I).l1 by A5,FUNCT_4:14;
  then
A9: I.l1 = s1.l1 by A5,SCMFSA6A:50
    .= CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,m1))
       by Y,TX,AMI_1:54
    .= halt SCM+FSA by A8,EXTPRO_1:def 14;
  l1 = IC Comput(ProgramPart( s2), s2,m1) by A1,A6,Th44,COMPOS_1:24;
  then
A10: s2.l1 = (Initialized Directed I).l1 by A7,A2,FUNCT_4:14
    .= (Directed I).l1 by A5,A3,SCMFSA6A:50
    .= goto  card I by A5,A9,FUNCT_4:112;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,m1))/.IC Comput(ProgramPart(s2),s2,
m1)
 = Comput(ProgramPart(s2),s2,m1).IC Comput(ProgramPart(s2),s2,m1) by
COMPOS_1:38;
A11: CurInstr(ProgramPart Comput(ProgramPart(s2),s2,m1),Comput(ProgramPart(s2),
s2,m1))
 = Comput(ProgramPart( s2), s2,m1).l1 by A1,A6,Th44,Y,COMPOS_1:24
    .= goto  card I by A10,AMI_1:54;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,m1)
by AMI_1:123;
A12: Comput(ProgramPart( s2), s2,m1 + 1) =
Following(ProgramPart s2,Comput(ProgramPart(s2),s2,
m1))
 by EXTPRO_1:4
    .= Exec(goto  card I, Comput(ProgramPart( s2), s2,m1)) by A11,T;
  hence IC Comput(ProgramPart( s2), s2,m1 + 1) =  card I by SCMFSA_2:95;
A13: ( for a being Int-Location holds Comput(ProgramPart( s2), s2,m1 + 1).a =
Comput(ProgramPart( s2), s2, m1).a)& for f being FinSeq-Location holds Comput(
ProgramPart( s2), s2,m1
  + 1).f = Comput(ProgramPart( s2), s2,m1).f by A12,SCMFSA_2:95;
  DataPart Comput(ProgramPart( s1), s1,m1) = DataPart Comput(ProgramPart( s2),
s2,m1) by A1,A6,Th44,SCMFSA6A:39;
  hence thesis by A13,SCMFSA6A:38;
end;

Lm3: for I being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on s & I is_halting_on s holds IC Comput(ProgramPart( (s +* ((I ';'
Stop
SCM+FSA) +* Start-At( 0,SCM+FSA)))), (s +* ((I ';' Stop
SCM+FSA) +* Start-At( 0,SCM+FSA))), (LifeSpan(ProgramPart(s +* (I +*
 Start-At( 0,SCM+FSA))),s +* (I +*
 Start-At( 0,SCM+FSA))) + 1)
) =  card I & DataPart Comput(ProgramPart( (s +* (I +*
 Start-At( 0,SCM+FSA)))), (s +* (I +*
 Start-At( 0,SCM+FSA))), (
LifeSpan(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +* Start-At( 0,
SCM+FSA))))) =
 DataPart Comput(ProgramPart( (s +* ((I
';' Stop SCM+FSA) +* Start-At( 0,SCM+FSA)))), (s +* ((I
';' Stop SCM+FSA) +* Start-At( 0,SCM+FSA))),
 (LifeSpan(ProgramPart(s +* (I +* Start-At(
0,SCM+FSA))),s +* (I +* Start-At(
0,SCM+FSA))) + 1)) &
 ProgramPart(s +* ((I ';' Stop SCM+FSA) +* Start-At( 0,SCM+FSA)))
  halts_on s +* ((I ';' Stop SCM+FSA) +* Start-At( 0,SCM+FSA)) &
LifeSpan(ProgramPart(s +* ((I ';' Stop SCM+FSA) +* Start-At( 0,SCM+FSA))),s +*
((I ';' Stop SCM+FSA) +* Start-At( 0,SCM+FSA))) =
 LifeSpan(ProgramPart(s +* (I
+* Start-At( 0,SCM+FSA))),s +* (I
+* Start-At( 0,SCM+FSA))) + 1 & I ';' Stop SCM+FSA is_closed_on s
 & I ';' Stop
SCM+FSA is_halting_on s

proof
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  assume
A1: I is_closed_on s;
  card Stop SCM+FSA = 1 by COMPOS_1:46;
  then card (I ';' Stop SCM+FSA) = card I + 1 by SCMFSA6A:61;
  then card I < card (I ';' Stop SCM+FSA) by NAT_1:13;
  then
A2:  card I in dom (I ';' Stop SCM+FSA) by AFINSQ_1:70;

A3: ProgramPart Relocated(Stop SCM+FSA,card I) c= Relocated(Stop SCM+FSA,
  card I) by RELAT_1:88;

x: 0 in dom Stop SCM+FSA by COMPOS_1:45;
A4: dom ProgramPart Stop SCM+FSA = dom Stop SCM+FSA by RELAT_1:209;

  then  (0 + card I) in {m + card I: m in dom ProgramPart Stop SCM+FSA}
  by x;

  then (0 + card I) in dom Reloc(ProgramPart Stop SCM+FSA,card I )
  by COMPOS_1:117;
  then
A5:  (0 + card I) in dom ProgramPart Relocated(Stop SCM+FSA,card I )
  by COMPOS_1:116;

  set s2 = s +* (I ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA));
  set s1 = s +* (I +* Start-At( 0,SCM+FSA));
x: 0 in dom Stop SCM+FSA by COMPOS_1:45;
y: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
  assume
A6: I is_halting_on s;

  then
A7: IC Comput(ProgramPart( (s +* (Directed I +* Start-At( 0,SCM+FSA)))), (s +*
(Directed I +* Start-At( 0,SCM+FSA))),
 (LifeSpan(ProgramPart(s1),s1)
  + 1)) = IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1) by
A1,Th42;

  I ';' Stop SCM+FSA c= I ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA)
   by Th9;

  then
  dom (I ';' Stop SCM+FSA) c= dom (I ';' Stop SCM+FSA +*
   Start-At( 0,SCM+FSA)
  ) by GRFUNC_1:8;

  then
A8: s2. card I = (I ';' Stop SCM+FSA +*
 Start-At( 0,SCM+FSA)).
  card I by A2,FUNCT_4:14

    .= (I ';' Stop SCM+FSA). card I by A2,COMPOS_1:145

    .= (ProgramPart Relocated(Stop SCM+FSA,card I)). card I by A5,FUNCT_4:14

    .= Relocated(Stop SCM+FSA,card I). (0 + card I) by A5,A3,GRFUNC_1:8

    .= IncAddr(halt SCM+FSA,card I) by A4,y,x,COMPOS_1:122
    .= halt SCM+FSA by SCMFSA_4:8;

  DataPart Comput(ProgramPart( (s +* (Directed I +* Start-At( 0,SCM+FSA)))), (s
+* (Directed I +* Start-At( 0,SCM+FSA))),
  LifeSpan(ProgramPart s1,
  s1) + 1) = DataPart Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1)
   +
1) by A1,A6,Th42
;

  hence IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1) + 1) =  card
I & DataPart

Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) = DataPart Comput(
ProgramPart( s2), s2
,LifeSpan(ProgramPart(s1),s1) + 1) by A1,A6,A7,Th36;

Y:  (ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1))/.
IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1)
 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).IC Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)+1) by COMPOS_1:38;
TX: ProgramPart s2 =
ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1)
by AMI_1:123;
A9: CurInstr(ProgramPart s2,
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1))
 = Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1)
  + 1). card I by A1,A6,A7,Th36,Y,TX

    .= halt SCM+FSA by A8,AMI_1:54;
  hence
A10: ProgramPart s2 halts_on s2 by EXTPRO_1:30;
A11: now
    let k be Element of NAT;
    assume
A12: k <= LifeSpan(ProgramPart(s1),s1);

    then
    IC Comput(ProgramPart( s1), s1,k) = IC Comput(ProgramPart( (s +* (Directed
I +* Start-At(
     0,SCM+FSA)))), (s +* (Directed I +* Start-At(
     0,SCM+FSA))),k) by A1,A6,Th35,COMPOS_1:24;

    then
A13: IC Comput(ProgramPart( s2), s2,k) = IC Comput(ProgramPart( s1), s1,k) by
A1,A6,A12,Th42;

    IC Comput(ProgramPart( s1), s1,k) in dom I & dom I c= dom (I ';' Stop
SCM+FSA) by A1,SCMFSA6A:56,SCMFSA7B:def 7;

    hence IC Comput(ProgramPart( s2), s2,k) in dom (I ';' Stop SCM+FSA) by A13;
  end;

  defpred P[Nat] means (LifeSpan(ProgramPart(s1),s1) < $1 implies IC Comput(
ProgramPart(s2),s2,
  $1) =  card I) & IC Comput(ProgramPart(s2),s2,$1) in dom (I ';' Stop SCM+FSA)
;

  card Stop SCM+FSA = 1 by COMPOS_1:46;
  then card (I ';' Stop SCM+FSA) = card I + 1 by SCMFSA6A:61;
  then
A14: card I + 0 < card (I ';' Stop SCM+FSA) by XREAL_1:8;
  then
A15:  card I in dom (I ';' Stop SCM+FSA) by AFINSQ_1:70;
A16: now
    let k be Element of NAT;
    assume
A17: P[k];
    per cases by XXREAL_0:1;
    suppose
      k < LifeSpan(ProgramPart(s1),s1);
      then k + 1 <= LifeSpan(ProgramPart(s1),s1) by NAT_1:13;
      hence P[k + 1] by A11;
    end;
    suppose
      k = LifeSpan(ProgramPart(s1),s1);
      hence P[k + 1] by A1,A6,A7,A15,Th36;
    end;
    suppose
A18:  k > LifeSpan(ProgramPart(s1),s1);
A19:  now
        assume k + 1 > LifeSpan(ProgramPart(s1),s1);

Y:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by COMPOS_1:38;
A20:    CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(s2
),s2,k))
 = halt SCM+FSA by A8,A17,A18,Y,AMI_1:54;

T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:123;
        thus IC Comput(ProgramPart( s2), s2,k + 1) =
        IC Following(ProgramPart s2,Comput(
ProgramPart(s2),s2,k))
         by EXTPRO_1:4

          .=  card I by A17,A18,A20,T,EXTPRO_1:def 3;
      end;
      k + 1 > k + 0 by XREAL_1:8;
      hence P[k + 1] by A14,A18,A19,AFINSQ_1:70,XXREAL_0:2;
    end;
  end;
  now
    let k be Element of NAT;
TY: ProgramPart (s +* (Directed I +*
     Start-At( 0,SCM+FSA)))
= ProgramPart Comput(ProgramPart( (s +* (Directed I +*
     Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
     Start-At( 0,SCM+FSA))),k)
by AMI_1:123;
TU: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:123;
    assume k < LifeSpan(ProgramPart(s1),s1) + 1;
    then
A21: k <= LifeSpan(ProgramPart(s1),s1) by NAT_1:13;

    then CurInstr(ProgramPart (s +* (Directed I +*
     Start-At( 0,SCM+FSA))),
    Comput(ProgramPart( (s +* (Directed I +*
     Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
     Start-At( 0,SCM+FSA))),k)) <>
    halt SCM+FSA by A1,A6,Th35;

    hence CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k)) <>
     halt SCM+FSA by A1,A6,A21,Th42,TY,TU;
  end;

  then for k be Element of NAT st
  CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k)) = halt SCM+FSA
  holds LifeSpan(ProgramPart(s1),s1) + 1 <= k;

  hence LifeSpan(ProgramPart(s2),s2) = LifeSpan(ProgramPart(s1),s1) + 1 by A9
,A10,EXTPRO_1:def 14;
A22: P[0] by A11,NAT_1:2;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A22,A16);
  hence I ';' Stop SCM+FSA is_closed_on s by SCMFSA7B:def 7;
  thus thesis by A10,SCMFSA7B:def 8;
end;

theorem
  for I being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on s & I is_halting_on s holds I ';' Stop SCM+FSA is_closed_on s & I
  ';' Stop SCM+FSA is_halting_on s by Lm3;

theorem
  for l being Element of NAT holds  0 in dom Goto
  l & (Goto l). 0 = goto l by Lm1;

Lm4: for I being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on Initialized s & I is_halting_on Initialized s holds IC Comput(
ProgramPart(
(s +* Initialized (I ';' Stop SCM+FSA))),
(s +* Initialized (I ';' Stop SCM+FSA)), (LifeSpan(ProgramPart(s +* Initialized
I),s +* Initialized I) + 1)) =
 card I & DataPart Comput(ProgramPart( (s +* Initialized I)), (s +* Initialized
I),LifeSpan(ProgramPart(s +*
Initialized I),s +*
Initialized I)) = DataPart Comput(ProgramPart( (s +* Initialized (I ';' Stop
SCM+FSA))
), (s +* Initialized (I ';' Stop SCM+FSA))
, (LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) + 1)) &
 ProgramPart(s +* Initialized (I ';' Stop SCM+FSA))
   halts_on s +* Initialized (I ';' Stop SCM+FSA) &
 LifeSpan(ProgramPart(s +* Initialized (I ';' Stop SCM+FSA)),s +* Initialized (
I ';' Stop SCM+FSA)) = LifeSpan(ProgramPart(s +*
Initialized I),s +*
Initialized I) + 1

proof
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  assume
A1: I is_closed_on Initialized s;
  card Stop SCM+FSA = 1 by COMPOS_1:46;
  then card (I ';' Stop SCM+FSA) = card I + 1 by SCMFSA6A:61;
  then card I < card (I ';' Stop SCM+FSA) by NAT_1:13;
  then
A2:  card I in dom (I ';' Stop SCM+FSA) by AFINSQ_1:70;

x: 0 in dom Stop SCM+FSA by COMPOS_1:45;
A3: ProgramPart Relocated(Stop SCM+FSA,card I) c= Relocated(Stop SCM+FSA,
  card I) by RELAT_1:88;

A4: dom ProgramPart Stop SCM+FSA = dom Stop SCM+FSA by RELAT_1:209;

  then  (0 + card I) in {m + card I: m in dom ProgramPart Stop SCM+FSA}
  by x;

  then (0 + card I) in dom Reloc(ProgramPart Stop SCM+FSA,card I )
  by COMPOS_1:117;
  then
A5:  (0 + card I) in dom ProgramPart Relocated(Stop SCM+FSA,card I )
  by COMPOS_1:116;

  set s2 = s +* Initialized (I ';' Stop SCM+FSA);
  set s1 = s +* Initialized I;
  assume
A6: I is_halting_on Initialized s;

  then
A7: IC Comput(ProgramPart( (s +* Initialized Directed I)), (s +* Initialized
Directed I),LifeSpan(ProgramPart(s1),s1) + 1) = IC
  Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1) by A1,Th43;

x: 0 in dom Stop SCM+FSA by COMPOS_1:45;
y: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
  I ';' Stop SCM+FSA c= Initialized (I ';' Stop SCM+FSA) by SCMFSA6A:26;

  then dom (I ';' Stop SCM+FSA) c= dom Initialized (I ';' Stop SCM+FSA) by
GRFUNC_1:8;

  then
A8: s2. card I = (Initialized (I ';' Stop SCM+FSA)). card I by A2,FUNCT_4:14

    .= (I ';' Stop SCM+FSA). card I by A2,SCMFSA6A:50

    .= (ProgramPart Relocated(Stop SCM+FSA,card I)). card I by A5,FUNCT_4:14

    .= Relocated(Stop SCM+FSA,card I). (0 + card I) by A5,A3,GRFUNC_1:8

    .= IncAddr(halt SCM+FSA,card I) by A4,y,x,COMPOS_1:122
    .= halt SCM+FSA by SCMFSA_4:8;

  DataPart Comput(ProgramPart( (s +* Initialized Directed I)), (s +*
Initialized Directed I),LifeSpan(ProgramPart(s1),s1) + 1) =
  DataPart Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1) by A1
,A6,Th43;

  hence IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1) + 1) =  card
I & DataPart

Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) = DataPart Comput(
ProgramPart( s2), s2
,LifeSpan(ProgramPart(s1),s1) + 1) by A1,A6,A7,Th45;

TX: ProgramPart s2 =
  ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1)
by AMI_1:123;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1))/.
IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1)
 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).IC Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)+1) by COMPOS_1:38;
A9: CurInstr(ProgramPart s2,
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1))
 = Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1)
  + 1). card I by A1,A6,A7,Th45,Y,TX

    .= halt SCM+FSA by A8,AMI_1:54;
  hence
A10: ProgramPart s2 halts_on s2 by EXTPRO_1:30;
  now
    let k be Element of NAT;
    assume k < LifeSpan(ProgramPart(s1),s1) + 1;
    then
A11: k <= LifeSpan(ProgramPart(s1),s1) by NAT_1:13;

    then CurInstr(ProgramPart (s +* Initialized Directed I),
     Comput(ProgramPart(s +* Initialized Directed I), (s +* Initialized
Directed I),k)) <> halt
    SCM+FSA by A1,A6,Th44;

    hence CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k)) <>
     halt SCM+FSA by A1,A6,A11,Th43;
  end;

  then for k be Element of NAT st
   CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,
k)) = halt SCM+FSA
  holds LifeSpan(ProgramPart(s1),s1) + 1 <= k;

  hence thesis by A9,A10,EXTPRO_1:def 14;
end;

canceled 5;

theorem
  for I being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on Initialized s & I is_halting_on Initialized s holds IC Comput(
ProgramPart(
(s +* Initialized (I ';' Stop SCM+FSA))),
(s +* Initialized (I ';' Stop SCM+FSA)), (LifeSpan(ProgramPart(s +* Initialized
I),s +* Initialized I) + 1)) =
   card I by Lm4;

theorem
  for I being Program of SCM+FSA, s being State of SCM+FSA st I
  is_closed_on Initialized s & I is_halting_on Initialized s holds DataPart
  Comput(ProgramPart( (s +* Initialized I)), (s +* Initialized I),LifeSpan(
ProgramPart(s
+* Initialized I),s
+* Initialized I)) = DataPart
  Comput(ProgramPart( (s +* Initialized (I ';' Stop SCM+FSA))), (s +*
Initialized (I ';' Stop SCM+FSA)), (LifeSpan(ProgramPart(s +*
  Initialized I),s +*
  Initialized I) + 1)) by Lm4;

theorem
  for I being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on Initialized s & I is_halting_on Initialized s
 holds ProgramPart(s +* Initialized(I ';' Stop SCM+FSA))
  halts_on s +* Initialized(I ';' Stop SCM+FSA) by Lm4;

theorem
  for I being Program of SCM+FSA, s being State of SCM+FSA st I
  is_closed_on Initialized s & I is_halting_on Initialized s holds LifeSpan(
ProgramPart(s +*
  Initialized (I ';' Stop SCM+FSA)),s +*
  Initialized (I ';' Stop SCM+FSA)) = LifeSpan(ProgramPart(s +* Initialized I),
s +* Initialized I) + 1 by Lm4;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
is_closed_on Initialized s & I is_halting_on Initialized s
holds IExec(I ';' Stop
  SCM+FSA,s) = IExec(I,s) +* Start-At( card I,SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: I is_closed_on Initialized s;
  set s2 = s +* Initialized (I ';' Stop SCM+FSA);
  set s1 = s +* Initialized I;
  assume
A2: I is_halting_on Initialized s;
  s1 = Initialized s +* (I +* Start-At( 0,SCM+FSA)) by Th13;
  then
A3: ProgramPart s1 halts_on s1 by A2,SCMFSA7B:def 8;
  ProgramPart s2 halts_on s2 & LifeSpan(ProgramPart(s2),s2) = LifeSpan(
ProgramPart(s1),s1) + 1 by A1,A2,Lm4;
  then
A4: Result(ProgramPart(s2),s2) = Comput(ProgramPart( s2), s2,LifeSpan(
ProgramPart(s1),s1) + 1) by EXTPRO_1:23;
  then DataPart Result(ProgramPart(s2),s2) = DataPart Comput(ProgramPart( s1),
s1,LifeSpan(ProgramPart(s1),s1))
by A1,A2,Lm4;
  then
A5: DataPart Result(ProgramPart(s2),s2) = DataPart Result(ProgramPart(s1),s1)
by A3,EXTPRO_1:23
    .= DataPart(Result(ProgramPart(s1),s1) +* Start-At( card I,SCM+FSA)) by
Th10;
  IC Result(ProgramPart(s2),s2) =  card I by A1,A2,A4,Lm4
    .= IC (Result(ProgramPart(s1),s1) +* Start-At( card I,SCM+FSA)) by
FUNCT_4:121;
  then
A6: Result(ProgramPart(s2),s2),Result(ProgramPart(s1),s1) +* Start-At( card I,
SCM+FSA) equal_outside A
 by A5,Th6;
  dom ProgramPart s = A by COMPOS_1:34;
  then
A7: Result(ProgramPart(s2),s2) +* s | A = Result(ProgramPart(s1),s1) +*
Start-At( card I,SCM+FSA)
 +* s | A by A6,FUNCT_7:108;
A8: dom ProgramPart s misses dom Start-At( card I,SCM+FSA) by Th12;
  thus IExec(I ';' Stop SCM+FSA,s) = Result(ProgramPart(s2),s2) +* s | A by
SCMFSA6B:def 1
    .= Result(ProgramPart(s1),s1) +* (Start-At( card I,SCM+FSA) +* s | A) by A7
,FUNCT_4:15
    .= Result(ProgramPart(s1),s1) +* (s | A +* Start-At( card I,SCM+FSA)) by A8
,FUNCT_4:36
    .= Result(ProgramPart(s1),s1) +* s | A +* Start-At( card I,SCM+FSA) by
FUNCT_4:15
    .= IExec(I,s) +* Start-At( card I,SCM+FSA) by SCMFSA6B:def 1;
end;

Lm5: for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on s & I is_halting_on s holds
IC Comput(ProgramPart( (s +* (I ';'
Goto
 (card J + 1) ';' J ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA)))), (s +* (I ';'
Goto
 (card J + 1) ';' J ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA))),
 (LifeSpan(ProgramPart(s
+* (I +* Start-At( 0,SCM+FSA))),s
+* (I +* Start-At( 0,SCM+FSA))) + 2)) =  (card I + card J + 1)
 &
DataPart
Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s +* (I +* Start-At(
0,SCM+FSA))), (LifeSpan(ProgramPart(s +* (I
 +* Start-At(
 0,SCM+FSA))),s +* (I
 +* Start-At(
 0,SCM+FSA))))) = DataPart Comput(ProgramPart( (s +* (I ';'
 Goto  (card J + 1) ';'
J ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA)))), (s +* (I ';'
 Goto  (card J + 1) ';'
J ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA))), (LifeSpan(ProgramPart(s +* (I
 +* Start-At(
 0,SCM+FSA))),s +* (I
 +* Start-At(
 0,SCM+FSA))) + 2)) &
 (for k being Element of NAT st
 k < LifeSpan(ProgramPart(s +* (I +*Start-At( 0,SCM+FSA))),
          s +* (I +*Start-At( 0,SCM+FSA))) + 2
 holds CurInstr(ProgramPart (s +*
(I ';'
 Goto  (
card J + 1) ';' J ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA))),
 Comput(ProgramPart( (s +* (I ';'
 Goto  (
card J + 1) ';' J ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA)))), (s +* (I ';'
 Goto  (
card J + 1) ';' J ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA))),k))
 <> halt SCM+FSA) &
(for k being Element of NAT st k <= LifeSpan(ProgramPart(s +* (I +*
 Start-At( 0,SCM+FSA))),s +* (I +*
 Start-At( 0,SCM+FSA)))
holds IC Comput(ProgramPart( (s +* (I ';' Goto  (card J + 1) ';' J ';' Stop
SCM+FSA +* Start-At( 0,SCM+FSA)))), (s +* (I ';' Goto  (card J + 1) ';' J ';'
Stop
SCM+FSA +* Start-At( 0,SCM+FSA))),k) = IC Comput(ProgramPart( (s +* (I +*
 Start-At(
0,SCM+FSA)))), (s +* (I +*
 Start-At(
0,SCM+FSA))),k)) & IC Comput(ProgramPart( (s +* (I ';'
 Goto  (card J + 1) ';' J ';' Stop
SCM+FSA +* Start-At( 0,SCM+FSA)))), (s +* (I ';'
 Goto  (card J + 1) ';' J ';' Stop
SCM+FSA +* Start-At( 0,SCM+FSA))), (LifeSpan(ProgramPart(s +* (I +*
 Start-At( 0,SCM+FSA))),s +* (I +*
 Start-At( 0,SCM+FSA))) + 1))
=  card I &
 ProgramPart(s +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA
+* Start-At( 0,SCM+FSA)))
 halts_on s +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA
+* Start-At( 0,SCM+FSA))
 &
 LifeSpan(ProgramPart(s +* (I ';' Goto  (card J +
1) ';' J ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA))),s +* (I ';' Goto  (card J +
1) ';' J ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA))) =
 LifeSpan(ProgramPart(s +* (I +*
Start-At( 0,SCM+FSA))),s +* (I +*
Start-At( 0,SCM+FSA))) + 2

proof
  let I,J be Program of SCM+FSA;
  let s be State of SCM+FSA;
  assume
A1: I is_closed_on s;

A2: card (Goto  (card J + 1) ';' J) = card Goto  (card J + 1) +
  card J by SCMFSA6A:61

    .= 1 + card J by Lm1;

A3: ProgramPart Relocated(Stop SCM+FSA,card J + 1) c= Relocated(Stop
  SCM+FSA,card J + 1) by RELAT_1:88;

x: 0 in dom Stop SCM+FSA by COMPOS_1:45;
A4: card (Goto  (card J + 1) ';' J) = card Goto  (card J + 1) +
  card J by SCMFSA6A:61

    .= card J + 1 by Lm1;
A5:  (card I + card J + 1) =  ((card J + 1) + card I);
A6:  0 in dom ProgramPart Stop SCM+FSA by x,RELAT_1:209;
  set J2 = Goto  (card J + 1) ';' (J ';' Stop SCM+FSA);

  set s2 = s +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA +*
  Start-At( 0,SCM+FSA));

  set s1 = s +* (I +* Start-At( 0,SCM+FSA));
  assume
A7: I is_halting_on s;

  dom ProgramPart Relocated(Stop SCM+FSA,card J + 1)
   = dom Reloc(ProgramPart Stop SCM+FSA,card J + 1) by COMPOS_1:116
  .= {m + (card J + 1): m in dom ProgramPart Stop SCM+FSA} by COMPOS_1:117;

  then
A8:  (0 + (card J + 1)) in dom ProgramPart Relocated(Stop SCM+FSA,
  card J + 1) by A6;

A9: dom Goto  (card J + 1) c= dom (Goto  (card J + 1) ';' J) by SCMFSA6A:56;

A10:  0 in dom Goto  (card J + 1) by Lm1;

A11: J2. 0 = (Goto  (card J + 1) ';' J ';' Stop SCM+FSA).
  0 by SCMFSA6A:67

    .= (Directed (Goto  (card J + 1) ';' J)). 0 by A10,A9,Th28
    .= (Goto  (card J + 1) ';' Directed J). 0 by SCMFSA6A:66
    .= (Directed Goto  (card J + 1)). 0 by A10,Th28
    .= (Goto  (card J + 1)). 0 by SCMFSA6A:63
    .= goto  (card J + 1) by Lm1;
A12: ProgramPart Relocated(J2,card I) c= Relocated(J2,card I) by RELAT_1:88;

A13: I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA = I ';' Goto
   (card J + 1) ';' (J ';' Stop SCM+FSA) by SCMFSA6A:67

    .= I ';' J2 by SCMFSA6A:67;

  then
A14: DataPart Comput(ProgramPart( (s +* (Directed I +* Start-At( 0,SCM+FSA)))),
(s +* (Directed I +* Start-At( 0,SCM+FSA))), (
  LifeSpan(ProgramPart(s1),s1) + 1)) = DataPart Comput(ProgramPart( s2), s2,
LifeSpan(ProgramPart(s1),s1) + 1) by A1,A7,Th42;

  I ';' J2 c= I ';' J2 +* Start-At( 0,SCM+FSA) by Th9;

  then
A15: dom (I ';' J2) c= dom (I ';' J2 +* Start-At( 0,SCM+FSA))
 by GRFUNC_1:8;

  I ';' J2 c= I ';' J2 +* Start-At( 0,SCM+FSA) by Th9;
  then
A16: dom (I ';' J2) c= dom (I ';' J2 +* Start-At( 0,SCM+FSA))
 by GRFUNC_1:8;

A17: card J2 = card Goto  (card J + 1) + card (J ';' Stop SCM+FSA) by
SCMFSA6A:61

    .= 1 + card (J ';' Stop SCM+FSA) by Lm1;
  then
A18: 0 + 1 <= card J2 by NAT_1:11;
A19: card (I ';' J2) = card I + card J2 by SCMFSA6A:61;
  then card I + 0 < card (I ';' J2) by A18,XREAL_1:8;
  then
A20:  card I in dom (I ';' J2) by AFINSQ_1:70;

x: card Stop SCM+FSA = 1 by COMPOS_1:46;
  card (I ';' J2) = card I + card (Goto  (card J + 1) ';' J ';'
  Stop SCM+FSA) by A19,SCMFSA6A:67

    .= card I + (card J + 1 + 1) by A4,x,SCMFSA6A:61
    .= card I + card J + 1 + 1;
  then card I + card J + 1 < card (I ';' J2) by NAT_1:13;
  then
A21:  (card I + card J + 1) in dom (I ';' J2) by AFINSQ_1:70;
  dom ProgramPart J2 = dom J2 by RELAT_1:209;
  then
A22:  0 in dom ProgramPart J2 by A18,AFINSQ_1:70;
  then  (0 + card I) in {m + card I: m in dom ProgramPart J2};

  then (0 + card I) in dom Reloc(ProgramPart J2,card I) by COMPOS_1:117;
  then
A23:  (0 + card I) in dom ProgramPart Relocated(J2,card I) by COMPOS_1:116;

x: card Stop SCM+FSA = 1 by COMPOS_1:46;
y: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
  card J2 = 1 + (card J + card Stop SCM+FSA) by A17,SCMFSA6A:61
    .= card J + (1 + card Stop SCM+FSA);
  then card J + 1 < card J2 by x,XREAL_1:8;
  then  (card J + 1) in dom J2 by AFINSQ_1:70;
  then
A24:  (card J + 1) in dom ProgramPart J2 by RELAT_1:209;

A25: J2. (card J + 1) = (Goto  (card J + 1) ';' J ';' Stop
  SCM+FSA). (card J + 1) by SCMFSA6A:67

    .= (ProgramPart Relocated(Stop SCM+FSA,card J + 1)). (card J + 1)
  by A2,A8,FUNCT_4:14

    .= Relocated(Stop SCM+FSA,card J + 1). (0 + (card J + 1)) by A3,A8,
GRFUNC_1:8

    .= IncAddr(halt SCM+FSA,card J + 1) by A6,y,COMPOS_1:122
    .= halt SCM+FSA by SCMFSA_4:8;
A26: ProgramPart Relocated(J2,card I) c= Relocated(J2,card I) by RELAT_1:88;

  dom ProgramPart Relocated(J2,card I)
  = dom Reloc(ProgramPart J2,card I) by COMPOS_1:116
 .= {m + card I: m in dom ProgramPart J2} by COMPOS_1:117;

  then
A27:  (card I + card J + 1) in dom ProgramPart Relocated(J2,card I )
  by A24,A5;

Y:  (ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1))/.
IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1)
 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).IC Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)+1) by COMPOS_1:38;
A28: IC Comput(ProgramPart( (s +* (Directed I +* Start-At( 0,SCM+FSA)))), (s +*
(Directed I +* Start-At( 0,SCM+FSA))),
 (LifeSpan(ProgramPart(s1),s1)
  + 1))= IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1) by A1
,A7,A13,Th42;

  then
A29: CurInstr(ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1
)+1),
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1))
 = Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1)
  + 1). card I by A1,A7,Th36,Y

    .= s2. card I by AMI_1:54
    .= (I ';' J2 +* Start-At( 0,SCM+FSA)). card I
     by A13,A16,A20,FUNCT_4:14
    .= (I ';' J2). card I by A20,COMPOS_1:145
    .= (ProgramPart Relocated(J2,card I)). card I by A23,FUNCT_4:14
    .= Relocated(J2,card I). (0 + card I) by A23,A12,GRFUNC_1:8
    .= IncAddr(goto  (card J + 1),card I) by A22,A11,COMPOS_1:122
    .= goto ( (card J + 1) + card I) by SCMFSA_4:14
    .= goto  (card I + card J + 1);
A30: now
    let f be FinSeq-Location;

T: ProgramPart s2 = ProgramPart Comput(ProgramPart( s2), s2,LifeSpan(
ProgramPart(s1),s1) + 1)
by AMI_1:123;
    thus Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + (1 + 1)).f
= Comput(
ProgramPart( s2), s2,LifeSpan(ProgramPart s1,
    s1) + 1 + 1).f

      .= (Following(ProgramPart s2,
      Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1))).f
      by EXTPRO_1:4
      .= Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1).f by A29
,T,SCMFSA_2:95;
  end;

Y:  (ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+2))/.
IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+2)
 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+2).IC Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)+2) by COMPOS_1:38;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart( s2), s2,LifeSpan(
ProgramPart(s1),s1) + 1)
by AMI_1:123;
TX: ProgramPart s2 =
ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1
)+2)
by AMI_1:123;
  thus IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 2) = IC
Comput(ProgramPart(
s2), s2,LifeSpan(ProgramPart s1,
  s1) + 1 + 1)

    .= IC Following(ProgramPart s2,
    Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1)) by
EXTPRO_1:4
    .=  (card I + card J + 1) by A29,T,SCMFSA_2:95;

  then
A31: CurInstr(ProgramPart s2,
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+2))
 = s2. (card I + card J
  + 1) by Y,TX,AMI_1:54

    .= (I ';' J2 +* Start-At( 0,SCM+FSA)). (card I + card J + 1)
     by A13,A21,A15,FUNCT_4:14

    .= (I ';' J2). (card I + card J + 1) by A21,COMPOS_1:145

    .= (ProgramPart Relocated(J2,card I)). (card I + card J + 1) by A27,
FUNCT_4:14

    .= Relocated(J2,card I). ((card J + 1) + card I) by A27,A26,GRFUNC_1:8

    .= IncAddr(halt SCM+FSA,card I) by A24,A25,COMPOS_1:122
    .= halt SCM+FSA by SCMFSA_4:8;
  now
    let a be Int-Location;

T: ProgramPart s2 = ProgramPart Comput(ProgramPart( s2), s2,LifeSpan(
ProgramPart(s1),s1) + 1)
by AMI_1:123;
    thus Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + (1 + 1)).a
= Comput(
ProgramPart( s2), s2,LifeSpan(ProgramPart s1,
    s1) + 1 + 1).a

      .= (Following(ProgramPart s2,
      Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1))).a by
EXTPRO_1:4
      .= Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1).a by A29
,T,SCMFSA_2:95;
  end;

  then DataPart Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1) =
DataPart Comput(
ProgramPart( s2), s2,
  LifeSpan(ProgramPart(s1),s1) + 2) by A30,SCMFSA6A:38;

  hence DataPart Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)) =
DataPart Comput(
ProgramPart( s2), s2,
  LifeSpan(ProgramPart(s1),s1) + 2) by A1,A7,A14,Th36;

  thus
A32: now
    let k be Element of NAT;
    assume
A33: k < LifeSpan(ProgramPart(s1),s1) + 2;
TY: ProgramPart (s +* (Directed I +*
       Start-At( 0,SCM+FSA))) = ProgramPart
Comput(ProgramPart( (s +* (Directed I +*
       Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
       Start-At( 0,SCM+FSA))),k)
by AMI_1:123;
TU: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:123;
    per cases;
    suppose
A34:  k <= LifeSpan(ProgramPart(s1),s1);

      then CurInstr(ProgramPart (s +* (Directed I +*
       Start-At( 0,SCM+FSA))),
        Comput(ProgramPart( (s +* (Directed I +*
       Start-At( 0,SCM+FSA)))), (s +* (Directed I +*
       Start-At( 0,SCM+FSA))),k))
      <> halt SCM+FSA by A1,A7,Th35;

      hence CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k)) <>
       halt SCM+FSA by A1,A7,A13,A34,Th42,TY,TU;

    end;
    suppose
A35:  LifeSpan(ProgramPart(s1),s1) < k;
      k < LifeSpan(ProgramPart(s1),s1) + 1 + 1 by A33;
      then
A37:  k <= LifeSpan(ProgramPart(s1),s1) + 1 by NAT_1:13;
      LifeSpan(ProgramPart(s1),s1) + 1 <= k by A35,NAT_1:13;
      then LifeSpan(ProgramPart(s1),s1) + 1 = k by A37,XXREAL_0:1;
      hence CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k))
       <> halt SCM+FSA by A29,TU,SCMFSA_2:124;

    end;
  end;
  hereby
    let k be Element of NAT;
    assume
A38: k <= LifeSpan(ProgramPart(s1),s1);

    then
    IC Comput(ProgramPart( s1), s1,k) = IC Comput(ProgramPart( (s +* (Directed
I +* Start-At(
     0,SCM+FSA)))), (s +* (Directed I +* Start-At(
     0,SCM+FSA))),k) by A1,A7,Th35,COMPOS_1:24;

    hence IC Comput(ProgramPart( s2), s2,k) = IC Comput(ProgramPart( s1), s1,k)
by A1,A7,A13,A38,Th42;

  end;
  thus IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1) =  card
I by A1,A7,A28,Th36;
  thus
A39: ProgramPart s2 halts_on s2 by A31,EXTPRO_1:30;

  for k be Element of NAT st
   CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k)) = halt SCM+FSA
  holds LifeSpan(ProgramPart(s1),s1) + 2 <= k by A32;

  hence thesis by A31,A39,EXTPRO_1:def 14;
end;

theorem
  for I,J being Program of SCM+FSA,s being State of SCM+FSA st I
  is_closed_on s & I is_halting_on s holds I ';' Goto  (card J + 1) ';' J
';' Stop SCM+FSA is_closed_on s & I ';' Goto  (card J + 1) ';' J ';' Stop
  SCM+FSA is_halting_on s
proof
  let I,J be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set IJ2 = I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA;
  assume
A1: I is_closed_on s;
  set s1 = s +* (I +* Start-At( 0,SCM+FSA));
  set s2 = s +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA +*
  Start-At( 0,SCM+FSA));
  assume
A2: I is_halting_on s;
  then
A3: ProgramPart s2 halts_on s2 by A1,Lm5;
A4: LifeSpan(ProgramPart(s2),s2) = LifeSpan(ProgramPart(s1),s1) + 2 by A1,A2
,Lm5;
  now
    let k be Element of NAT;
    k <= LifeSpan(ProgramPart(s1),s1) or k >= LifeSpan(ProgramPart(s1),s1) + 1
by NAT_1:13;
    then k <= LifeSpan(ProgramPart(s1),s1) or k = LifeSpan(ProgramPart(s1),s1)
+ 1 or k > LifeSpan(ProgramPart(s1),s1) + 1 by XXREAL_0:1;
    then
A5: k <= LifeSpan(ProgramPart(s1),s1) or k = LifeSpan(ProgramPart(s1),s1) + 1
or k >= LifeSpan(ProgramPart(s1),s1) + 1 + 1 by NAT_1:13;
    card Stop SCM+FSA = 1 by COMPOS_1:46;
    then
A6: card IJ2 = card (I ';' Goto  (card J + 1) ';' J) + 1 by SCMFSA6A:61
      .= card (I ';' Goto  (card J + 1)) + card J + 1 by SCMFSA6A:61
      .= card I + card Goto  (card J + 1) + card J + 1 by SCMFSA6A:61
      .= card I + 1 + card J + 1 by Lm1
      .= card I + (card J + 1 + 1);
    0 <= card J + 1 by NAT_1:2;
    then 0 + 0 < card J + 1 + 1 by XREAL_1:10;
    then
A7: card I + 0 < card IJ2 by A6,XREAL_1:8;
    per cases by A5;
    suppose
A8:   k <= LifeSpan(ProgramPart(s1),s1);
      reconsider n = IC Comput(ProgramPart( s2), s2,k) as Element of NAT;
      IC Comput(ProgramPart( s2), s2,k) = IC Comput(ProgramPart( s1), s1,k) by
A1,A2,A8,Lm5;
      then IC Comput(ProgramPart( s2), s2,k) in dom I by A1,SCMFSA7B:def 7;
      then n < card I by AFINSQ_1:70;
      then n < card IJ2 by A7,XXREAL_0:2;
      hence IC Comput(ProgramPart( s2), s2,k) in dom IJ2 by AFINSQ_1:70;
    end;
    suppose
      k = LifeSpan(ProgramPart(s1),s1) + 1;
      then IC Comput(ProgramPart( s2), s2,k) =  card I by A1,A2,Lm5;
      hence IC Comput(ProgramPart( s2), s2,k) in dom IJ2 by A7,AFINSQ_1:70;
    end;
    suppose
A9:   k >= LifeSpan(ProgramPart(s1),s1) + 2;
      card IJ2 = card I + card J + 1 + 1 by A6;
      then
A10:  card I + card J + 1 + 0 < card IJ2 by XREAL_1:8;
      k >= LifeSpan(ProgramPart(s2),s2) by A1,A2,A9,Lm5;
      then IC Comput(ProgramPart( s2), s2,k) = IC Comput(ProgramPart( s2), s2,
LifeSpan(ProgramPart(s2),s2)) by A3,Th5
        .=  (card I + card J + 1) by A1,A2,A4,Lm5;
      hence IC Comput(ProgramPart( s2), s2,k) in dom IJ2 by A10,AFINSQ_1:70;
    end;
  end;
  hence IJ2 is_closed_on s by SCMFSA7B:def 7;
  thus thesis by A3,SCMFSA7B:def 8;
end;

theorem
  for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
  is_closed_on s & I is_halting_on s
   holds ProgramPart(s +* (I ';' Goto  (card J + 1)
  ';' J ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA)))
   halts_on s +* (I ';' Goto  (card J + 1)
  ';' J ';' Stop SCM+FSA +* Start-At( 0,SCM+FSA)) by Lm5;

Lm6: for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on Initialized s & I is_halting_on Initialized s holds IC Comput(
ProgramPart(
(s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA))),
(s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA)),
LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) + 2) =  (card I +
card J + 1) &
DataPart
Comput(ProgramPart( (s +* Initialized I)), (s +* Initialized I),LifeSpan(
ProgramPart(s +*
Initialized I),s +*
Initialized I)) = DataPart
Comput(ProgramPart( (s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop
SCM+FSA))), (s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop
SCM+FSA)),LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) + 2) & (
for k being Element of NAT st k
< LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) + 2
 holds CurInstr(ProgramPart ( (s +*
Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA))),
   Comput(ProgramPart( (s +*
Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA))), (s +*
Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA)),k))
 <> halt
SCM+FSA) & (for k being Element of NAT st k <= LifeSpan(ProgramPart(s +*
Initialized I),s +* Initialized I)
holds IC Comput(ProgramPart( (s +* Initialized (I ';' Goto  (card J + 1) ';' J
';' Stop SCM+FSA))), (s +* Initialized (I ';' Goto  (card J + 1) ';' J
';' Stop SCM+FSA)),k) = IC Comput(ProgramPart( (s +* Initialized I)), (s +*
Initialized I),k)) & IC
Comput(ProgramPart( (s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop
SCM+FSA))), (s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop
SCM+FSA)),LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) + 1) =
card I &
 ProgramPart(s +* Initialized
(I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA))
 halts_on s +* Initialized
(I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA)
 & LifeSpan(ProgramPart(
s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA)),
s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA)) =
LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) + 2

proof
  let I,J be Program of SCM+FSA;
  let s be State of SCM+FSA;
  assume
A1: I is_closed_on Initialized s;

A2: card (Goto  (card J + 1) ';' J) = card Goto  (card J + 1) +
  card J by SCMFSA6A:61

    .= 1 + card J by Lm1;

A3: ProgramPart Relocated(Stop SCM+FSA,card J + 1) c= Relocated(Stop
  SCM+FSA,card J + 1) by RELAT_1:88;

x: 0 in dom Stop SCM+FSA by COMPOS_1:45;
A4: card (Goto  (card J + 1) ';' J) = card Goto  (card J + 1) +
  card J by SCMFSA6A:61

    .= card J + 1 by Lm1;
A5:  (card I + card J + 1) =  ((card J + 1) + card I);
A6:  0 in dom ProgramPart Stop SCM+FSA by x,RELAT_1:209;
  set J2 = Goto  (card J + 1) ';' (J ';' Stop SCM+FSA);

  set s2 = s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop
  SCM+FSA);

  set s1 = s +* Initialized I;
  assume
A7: I is_halting_on Initialized s;

  dom ProgramPart Relocated(Stop SCM+FSA,card J + 1)
   = dom Reloc(ProgramPart Stop SCM+FSA,card J + 1) by COMPOS_1:116
  .= {m + (card J + 1):
  m in dom ProgramPart Stop SCM+FSA} by COMPOS_1:117;

  then
A8:  (0 + (card J + 1)) in dom ProgramPart Relocated(Stop SCM+FSA,
  card J + 1) by A6;

A9: dom Goto  (card J + 1) c= dom (Goto  (card J + 1) ';' J) by SCMFSA6A:56;

A10:  0 in dom Goto  (card J + 1) by Lm1;

A11: J2. 0 = (Goto  (card J + 1) ';' J ';' Stop SCM+FSA).
  0 by SCMFSA6A:67

    .= (Directed (Goto  (card J + 1) ';' J)). 0 by A10,A9,Th28
    .= (Goto  (card J + 1) ';' Directed J). 0 by SCMFSA6A:66
    .= (Directed Goto  (card J + 1)). 0 by A10,Th28
    .= (Goto  (card J + 1)). 0 by SCMFSA6A:63
    .= goto  (card J + 1) by Lm1;
A12: ProgramPart Relocated(J2,card I) c= Relocated(J2,card I) by RELAT_1:88;

A13: I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA = I ';' Goto
   (card J + 1) ';' (J ';' Stop SCM+FSA) by SCMFSA6A:67

    .= I ';' J2 by SCMFSA6A:67;

  then
A14: DataPart Comput(ProgramPart( (s +* Initialized Directed I)), (s +*
Initialized Directed I),LifeSpan(ProgramPart(s1),s1) + 1) =
  DataPart Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1) by A1
,A7,Th43;

  I ';' J2 c= Initialized (I ';' J2) by SCMFSA6A:26;
  then
A15: dom (I ';' J2) c= dom Initialized (I ';' J2) by GRFUNC_1:8;
  I ';' J2 c= Initialized (I ';' J2) by SCMFSA6A:26;
  then
A16: dom (I ';' J2) c= dom Initialized (I ';' J2) by GRFUNC_1:8;

A17: card J2 = card Goto  (card J + 1) + card (J ';' Stop SCM+FSA) by
SCMFSA6A:61

    .= 1 + card (J ';' Stop SCM+FSA) by Lm1;
  then
A18: 0 + 1 <= card J2 by NAT_1:11;
A19: card (I ';' J2) = card I + card J2 by SCMFSA6A:61;
  then card I + 0 < card (I ';' J2) by A18,XREAL_1:8;
  then
A20:  card I in dom (I ';' J2) by AFINSQ_1:70;

x: card Stop SCM+FSA = 1 by COMPOS_1:46;
  card (I ';' J2) = card I + card (Goto  (card J + 1) ';' J ';'
  Stop SCM+FSA) by A19,SCMFSA6A:67

    .= card I + (card J + 1 + 1) by A4,x,SCMFSA6A:61
    .= card I + card J + 1 + 1;
  then card I + card J + 1 < card (I ';' J2) by NAT_1:13;
  then
A21:  (card I + card J + 1) in dom (I ';' J2) by AFINSQ_1:70;
  dom ProgramPart J2 = dom J2 by RELAT_1:209;
  then
A22:  0 in dom ProgramPart J2 by A18,AFINSQ_1:70;
  then  (0 + card I) in {m + card I: m in dom ProgramPart J2};

  then (0 + card I) in dom Reloc(ProgramPart J2,card I) by COMPOS_1:117;
  then
A23:  (0 + card I) in dom ProgramPart Relocated(J2,card I) by COMPOS_1:116;

x: card Stop SCM+FSA = 1 by COMPOS_1:46;
y: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
  card J2 = 1 + (card J + card Stop SCM+FSA) by A17,SCMFSA6A:61
    .= card J + (1 + card Stop SCM+FSA);
  then card J + 1 < card J2 by x,XREAL_1:8;
  then  (card J + 1) in dom J2 by AFINSQ_1:70;
  then
A24:  (card J + 1) in dom ProgramPart J2 by RELAT_1:209;

Y:  (ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1))/.
IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1)
 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1).IC Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)+1) by COMPOS_1:38;
A25: J2. (card J + 1) = (Goto  (card J + 1) ';' J ';' Stop
  SCM+FSA). (card J + 1) by SCMFSA6A:67

    .= (ProgramPart Relocated(Stop SCM+FSA,card J + 1)). (card J + 1)
  by A2,A8,FUNCT_4:14

    .= Relocated(Stop SCM+FSA,card J + 1). (0 + (card J + 1)) by A3,A8,
GRFUNC_1:8

    .= IncAddr(halt SCM+FSA,card J + 1) by A6,y,COMPOS_1:122
    .= halt SCM+FSA by SCMFSA_4:8;
A26: ProgramPart Relocated(J2,card I) c= Relocated(J2,card I) by RELAT_1:88;

  dom ProgramPart Relocated(J2,card I)
   = dom Reloc(ProgramPart J2,card I) by COMPOS_1:116
  .= {m + card I: m in dom
  ProgramPart J2} by COMPOS_1:117;

  then
A27:  (card I + card J + 1) in dom ProgramPart Relocated(J2,card I )
  by A24,A5;

A28: IC Comput(ProgramPart( (s +* Initialized Directed I)), (s +* Initialized
Directed I),LifeSpan(ProgramPart(s1),s1) + 1) = IC
  Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1) by A1,A7,A13
,Th43;

  then
A29: CurInstr(ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1
)+1),
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+1))
 = Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1)
  + 1). card I by A1,A7,Th45,Y

    .= s2. card I by AMI_1:54
    .= (Initialized (I ';' J2)). card I by A13,A16,A20,FUNCT_4:14
    .= (I ';' J2). card I by A20,SCMFSA6A:50
    .= (ProgramPart Relocated(J2,card I)). card I by A23,FUNCT_4:14
    .= Relocated(J2,card I). (0 + card I) by A23,A12,GRFUNC_1:8
    .= IncAddr(goto  (card J + 1),card I) by A22,A11,COMPOS_1:122
    .= goto ( (card J + 1) + card I) by SCMFSA_4:14
    .= goto  (card I + card J + 1);
A30: now
    let f be FinSeq-Location;

T: ProgramPart s2 = ProgramPart Comput(ProgramPart( s2), s2,LifeSpan(
ProgramPart(s1),s1) + 1)
by AMI_1:123;
    thus Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + (1 + 1)).f
= Comput(
ProgramPart( s2), s2,LifeSpan(ProgramPart s1,
    s1) + 1 + 1).f

      .= (Following(ProgramPart s2,
      Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1))).f by
EXTPRO_1:4
      .= Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1).f by A29
,T,SCMFSA_2:95;
  end;

Y:  (ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+2))/.
IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+2)
 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+2).IC Comput(
ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)+2) by COMPOS_1:38;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart( s2), s2,LifeSpan(
ProgramPart(s1),s1) + 1)
by AMI_1:123;
TZ: ProgramPart s2 =
ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+2)
by AMI_1:123;
  thus IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 2) = IC
Comput(ProgramPart(
s2), s2,LifeSpan(ProgramPart s1,
  s1) + 1 + 1)

    .= IC Following(ProgramPart s2,
    Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1)) by
EXTPRO_1:4
    .=  (card I + card J + 1) by A29,T,SCMFSA_2:95;

  then
A31: CurInstr(ProgramPart s2,
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)+2))
 = s2. (card I + card J
  + 1) by Y,TZ,AMI_1:54

    .= (Initialized (I ';' J2)). (card I + card J + 1)
    by A13,A21,A15,FUNCT_4:14

    .= (I ';' J2). (card I + card J + 1) by A21,SCMFSA6A:50

    .= (ProgramPart Relocated(J2,card I)). (card I + card J + 1) by A27,
FUNCT_4:14

    .= Relocated(J2,card I). ((card J + 1) + card I) by A27,A26,GRFUNC_1:8

    .= IncAddr(halt SCM+FSA,card I) by A24,A25,COMPOS_1:122
    .= halt SCM+FSA by SCMFSA_4:8;
  now
    let a be Int-Location;

T: ProgramPart s2 = ProgramPart Comput(ProgramPart( s2), s2,LifeSpan(
ProgramPart(s1),s1) + 1)
by AMI_1:123;
    thus Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + (1 + 1)).a
= Comput(
ProgramPart( s2), s2,LifeSpan(ProgramPart s1,
    s1) + 1 + 1).a

      .= (Following(ProgramPart s2,
      Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1))).a by
EXTPRO_1:4
      .= Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1).a by A29
,T,SCMFSA_2:95;
  end;

  then DataPart Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1) =
DataPart Comput(
ProgramPart( s2), s2,
  LifeSpan(ProgramPart(s1),s1) + 2) by A30,SCMFSA6A:38;

  hence DataPart Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)) =
DataPart Comput(
ProgramPart( s2), s2,
  LifeSpan(ProgramPart(s1),s1) + 2) by A1,A7,A14,Th45;

  thus
A32: now
    let k be Element of NAT;
    assume
A33: k < LifeSpan(ProgramPart(s1),s1) + 2;
TZ: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:123;
    per cases;
    suppose
A34:  k <= LifeSpan(ProgramPart(s1),s1);

      then CurInstr(ProgramPart (s +* Initialized Directed I),
       Comput(ProgramPart( (s +* Initialized Directed I)), (s +* Initialized
Directed I),k))
       <> halt
      SCM+FSA by A1,A7,Th44;

      hence CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k)) <>
       halt SCM+FSA by A1,A7,A13,A34,Th43;

    end;
    suppose
A35:  LifeSpan(ProgramPart(s1),s1) < k;
      k < LifeSpan(ProgramPart(s1),s1) + 1 + 1 by A33;
      then
A37:  k <= LifeSpan(ProgramPart(s1),s1) + 1 by NAT_1:13;
      LifeSpan(ProgramPart(s1),s1) + 1 <= k by A35,NAT_1:13;
      then LifeSpan(ProgramPart(s1),s1) + 1 = k by A37,XXREAL_0:1;
      hence CurInstr(ProgramPart(s2),Comput(ProgramPart(s2),s2,k)) <>
       halt SCM+FSA by A29,TZ,SCMFSA_2:124;

    end;
  end;
  hereby
    let k be Element of NAT;
    assume
A38: k <= LifeSpan(ProgramPart(s1),s1);

    then
    IC Comput(ProgramPart( s1), s1,k) = IC Comput(ProgramPart( (s +*
Initialized Directed I)
    ), (s +* Initialized Directed I)
    ,k) by A1,A7,Th44,COMPOS_1:24;

    hence IC Comput(ProgramPart( s2), s2,k) = IC Comput(ProgramPart( s1), s1,k)
by A1,A7,A13,A38,Th43;

  end;
  thus IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1) =  card
I by A1,A7,A28,Th45;
  thus
A39: ProgramPart s2 halts_on s2 by A31,EXTPRO_1:30;

  for k be Element of NAT
   st CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k))
   = halt SCM+FSA
  holds LifeSpan(ProgramPart(s1),s1) + 2 <= k by A32;

  hence thesis by A31,A39,EXTPRO_1:def 14;
end;

theorem
  for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on Initialized s & I is_halting_on Initialized s
 holds ProgramPart(s +* Initialized
  (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA))
   halts_on s +* Initialized
  (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA) by Lm6;

theorem
  for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
  is_closed_on Initialized s & I is_halting_on Initialized s
  holds IC IExec(I ';'
Goto  (card J + 1) ';' J ';' Stop SCM+FSA,s) =  (card I + card J +
  1)
proof
  let I,J be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s2 = s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop
  SCM+FSA);
  assume
A1: I is_closed_on Initialized s & I is_halting_on Initialized s;
  then ProgramPart s2 halts_on s2 & LifeSpan(ProgramPart(s2),s2)
   = LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) + 2 by Lm6;
  then
  IC Result(ProgramPart(s2),s2) = IC Comput(ProgramPart( s2), s2,LifeSpan(
ProgramPart(s +* Initialized I),s +* Initialized I) +
2) by EXTPRO_1:23
    .=  (card I + card J + 1) by A1,Lm6;
  hence thesis by Th7;
end;

theorem
  for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on Initialized s & I is_halting_on Initialized s
holds IExec(I ';' Goto
 (card J + 1) ';' J ';' Stop SCM+FSA,s) = IExec(I,s) +* Start-At( (
  card I + card J + 1),SCM+FSA)
proof
  let I,J be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop
  SCM+FSA);
  assume that
A1: I is_closed_on Initialized s and
A2: I is_halting_on Initialized s;
  s1 = Initialized s +* (I +* Start-At( 0,SCM+FSA)) by Th13;
  then
A3: ProgramPart s1 halts_on s1 by A2,SCMFSA7B:def 8;
  ProgramPart s2 halts_on s2 & LifeSpan(ProgramPart(s2),s2) = LifeSpan(
ProgramPart(s1),s1) + 2 by A1,A2,Lm6;
  then
A4: Result(ProgramPart(s2),s2) = Comput(ProgramPart( s2), s2,LifeSpan(
ProgramPart(s1),s1) + 2) by EXTPRO_1:23;
  then DataPart Result(ProgramPart(s2),s2) = DataPart Comput(ProgramPart( s1),
s1,LifeSpan(ProgramPart(s1),s1))
by A1,A2,Lm6;
  then
A5: DataPart Result(ProgramPart(s2),s2) = DataPart Result(ProgramPart(s1),s1)
by A3,EXTPRO_1:23
    .= DataPart(Result(ProgramPart(s1),s1) +* Start-At((card I+card J +1),
SCM+FSA))
     by Th10;
  IC Result(ProgramPart(s2),s2) =  (card I + card J + 1) by A1,A2,A4,Lm6
    .= IC (Result(ProgramPart(s1),s1) +* Start-At((card I+card J +1),SCM+FSA))
     by FUNCT_4:121;
  then
A6: Result(ProgramPart(s2),s2),Result(ProgramPart(s1),s1) +* Start-At((card I+
card J +1),SCM+FSA)
  equal_outside A by A5,Th6;
  dom ProgramPart s = A by COMPOS_1:34;
  then
A7: Result(ProgramPart(s2),s2) +* s | A = Result(ProgramPart(s1),s1) +*
Start-At( (card I + card J + 1
  ),SCM+FSA) +* s | A by A6,FUNCT_7:108;
A8: dom ProgramPart s misses dom Start-At((card I+card J +1),SCM+FSA) by Th12;

  thus IExec(I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA,s)
   = Result(ProgramPart s2,
  s2) +* s | A by SCMFSA6B:def 1
    .= Result(ProgramPart(s1),s1) +* (Start-At((card I+card J +1),SCM+FSA) +* s
| A)
     by A7,FUNCT_4:15
    .= Result(ProgramPart(s1),s1) +* (s | A +* Start-At((card I+card J +1),
SCM+FSA))
     by A8,FUNCT_4:36
    .= Result(ProgramPart(s1),s1) +* s | A +* Start-At((card I+card J +1),
SCM+FSA) by FUNCT_4:15
    .= IExec(I,s) +* Start-At((card I+card J +1),SCM+FSA)
     by SCMFSA6B:def 1;
end;

