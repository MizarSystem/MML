:: Conditional branch macro instructions of SCM+FSA, Part I (preliminary)
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, SCMFSA_2, XBOOLE_0, FSM_1, RELAT_1, AMI_1,
      GRAPHSP, XXREAL_0, CIRCUIT2, ARYTM_3, CARD_1, FUNCT_7, FUNCT_1, SCMFSA6B,
      MSUALG_1, FUNCT_4, SCMFSA6A, FUNCOP_1, TARSKI, SF_MASTR,
      STRUCT_0, AMISTD_2, SCMNORM, AMI_3, SCMFSA7B, VALUED_1, CAT_1, NAT_1,
      TURING_1, UNIALG_2, SCMFSA8A, PARTFUN1, RELOC, SCMFSA6C,
      AFINSQ_1, FRECHET, ORDINAL1, PBOOLE;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, NAT_1, FUNCOP_1,
      RELAT_1, FUNCT_1, PARTFUN1, AFINSQ_1, FUNCT_4, FUNCT_7, FINSEQ_1,
      VALUED_1, PBOOLE, STRUCT_0, COMPOS_1,
      EXTPRO_1, AMI_1, AMISTD_1, AMISTD_2, SCMFSA_2,
      SCMFSA10,
      SCMFSA_7, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, SCMFSA_7, SCMFSA6A, SF_MASTR, AMI_1,
      SCMFSA6B, SCMFSA6C, SCMFSA7B, AMISTD_2, RELSET_1, PRE_POLY, SCMFSA10,
      AMISTD_1, PBOOLE, AMISTD_5;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, FUNCOP_1, NUMBERS, XXREAL_0,
      MEMBERED, AMI_1, SCMFSA_2, SCMFSA6A, SF_MASTR, AFINSQ_1, SCMFSA7B,
      FINSET_1, FINSEQ_1, SCMFSA10, AMISTD_2, VALUED_1, SCMFSA_4,
      SCMFSA6C, COMPOS_1, RELAT_1, EXTPRO_1, FUNCT_4, PBOOLE, ORDINAL1,
      STRUCT_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_1, SCMFSA6A, AMISTD_2, STRUCT_0;
 theorems TARSKI, FUNCOP_1, NAT_1, FUNCT_1, FUNCT_4, FUNCT_7,
      RELAT_1, SCMFSA_2, SCMFSA_4, SCMFSA6A,
      GRFUNC_1, SF_MASTR, SCMFSA6B, SCMFSA6C, CARD_1, SCMFSA7B, XBOOLE_0,
      XREAL_1, XXREAL_0, VALUED_1, AFINSQ_1, PARTFUN1,
      AMISTD_2, SCMFSA10, COMPOS_1, AMISTD_1, EXTPRO_1, PBOOLE;
 schemes NAT_1;

begin

reserve m for Element of NAT;
reserve P for (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
set A = NAT;
set D = Data-Locations SCM+FSA;
set SA0 = Start-At(0,SCM+FSA);
set T = intloc 0 .--> 1;

canceled 3;

theorem Th4:
  for s being State of SCM+FSA st P halts_on s for k being Element
  of NAT st LifeSpan(P,s) <= k holds
  CurInstr(P,Comput(P,s,k))= halt SCM+FSA
proof
  let s be State of SCM+FSA;
  assume P halts_on s;
  then
A1: CurInstr(P,Comput(P,s,LifeSpan(P,s))) = halt SCM+FSA by EXTPRO_1:def 14;
  let k be Element of NAT;
  set i=LifeSpan(P,s);
  assume LifeSpan(P,s) <= k;
  hence CurInstr(P,Comput(P,s,k))
   = halt SCM+FSA by A1,EXTPRO_1:6;
end;

theorem Th5:
  for s being State of SCM+FSA st P halts_on s for k being Element
of NAT st LifeSpan(P,s) <= k holds IC Comput(P,s,k) =
IC Comput(P,s,LifeSpan(P, s))
proof
  let s be State of SCM+FSA;
  defpred P[Nat] means LifeSpan(P,s) <= $1 implies IC Comput(
P,s,$1) = IC Comput(P,s,LifeSpan(P,s));
  assume
A1: P halts_on s;
A2: now
    let k be Element of NAT;
    assume
A3: P[k];
    now
      assume
A4:   LifeSpan(P,s) <= k + 1;
      per cases by A4,XXREAL_0:1;
      suppose
        k + 1 = LifeSpan(P,s);
        hence IC Comput(P,s,k+1) = IC Comput(P,s,
LifeSpan(P,s));
      end;
      suppose
A5:     k + 1 > LifeSpan(P,s);
        then
A6:     LifeSpan(P,s) <= k by NAT_1:13;
        thus IC Comput(P,s,k+1) =
        IC Following(P,Comput(P,s,k)) by EXTPRO_1:4
          .= IC Exec(halt SCM+FSA, Comput(P,s,k)) by A1,A6,Th4
          .= IC Comput(P,s,LifeSpan(P,s)) by A3,A5,EXTPRO_1:def 3,NAT_1:13;
      end;
    end;
    hence P[k + 1];
  end;
  let k be Element of NAT;
  assume
A7: LifeSpan(P,s) <= k;
A8: P[0]
  proof
A9: 0 <= LifeSpan(P,s) by NAT_1:2;
    assume LifeSpan(P,s) <= 0;
    hence thesis by A9;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A8,A2);
  hence thesis by A7;
end;

theorem Th6:
  for s1,s2 being State of SCM+FSA holds s1,s2 equal_outside NAT
  iff IC s1 = IC s2 & DataPart s1 = DataPart s2
proof
  let s1,s2 be State of SCM+FSA;
  hereby
    assume
A1: s1,s2 equal_outside NAT;
    hence IC s1 = IC s2 by COMPOS_1:24;
    ( for a being Int-Location holds s1.a = s2.a)& for f being
    FinSeq-Location holds s1.f = s2.f by A1,SCMFSA10:92,93;
    hence DataPart s1 = DataPart s2 by SCMFSA6A:38;
  end;
  assume that
A2: IC s1 = IC s2 and
A3: DataPart s1 = DataPart s2;
  ( for a being Int-Location holds s1.a = s2.a)& for f being
  FinSeq-Location holds s1.f = s2.f by A3,SCMFSA6A:38;
  hence thesis by A2,SCMFSA10:91;
end;

theorem Th7:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
   IC IExec(I,P,s) = IC Result(P +* I,s +* Initialized I)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
    not IC SCM+FSA in NAT by COMPOS_1:def 12;
    then
A1: not IC SCM+FSA in dom ProgramPart s by COMPOS_1:34;
  IExec(I,P,s) = Result(P +* I,s +* Initialized I) +* (s|NAT)
   by SCMFSA6B:def 1;
  hence thesis by A1,FUNCT_4:12;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  Initialized s +* Initialized I = s +* Initialized I
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
A1: dom I misses dom SA0 by COMPOS_1:140;
  now
    let x be set;
A2: dom T = {intloc 0} by FUNCOP_1:19;
    assume x in dom T;
    then x = intloc 0 by A2,TARSKI:def 1;
    hence not x in dom I by SCMFSA6A:47;
  end;
  then
A3: dom I misses dom T by XBOOLE_0:3;
A4: Initialized I = Initialize(I +* ((intloc 0) .--> 1)) by FUNCT_4:15;
  thus Initialized s +* Initialized I
    = Initialize(s +* T) +* (I +* (Initialize T)) by FUNCT_4:15
    .= Initialize (s +* T) +* I +* (Initialize T) by FUNCT_4:15
    .= s +* T +* (SA0 +* I) +* (Initialize T) by FUNCT_4:15
    .= s +* T +* (Initialize I)+* (Initialize T) by A1,FUNCT_4:36
    .= Initialize (s +* T +* I) +* (Initialize T) by FUNCT_4:15
    .= Initialize (s +* (T +* I)) +* (Initialize T) by FUNCT_4:15
    .= Initialize (s +* (I +* T)) +* (Initialize T) by A3,FUNCT_4:36
    .= Initialize (s +* I +* T) +* (Initialize T) by FUNCT_4:15
    .= s +* I +* (Initialize T) +* (Initialize T) by FUNCT_4:15
    .= s +* I +* (Initialize T +* (Initialize T)) by FUNCT_4:15
    .= Initialize (s +* I +* T) by FUNCT_4:15
    .= Initialize (s +* (I +* T)) by FUNCT_4:15
    .= s +* Initialized I by FUNCT_4:15,A4;
end;

theorem
  for I being Program of SCM+FSA, l being Element of NAT
   holds I c= I +* Start-At(l,SCM+FSA)
proof
  let I be Program of SCM+FSA;
  let l be Element of NAT;
  reconsider n = l as Element of NAT;
  dom I misses dom Start-At(l,SCM+FSA) by COMPOS_1:140;
  hence thesis by FUNCT_4:33;
end;

theorem Th10:
  for s being State of SCM+FSA, l being Element of NAT
   holds DataPart s = DataPart(s +* Start-At(l,SCM+FSA))
proof
  let s be State of SCM+FSA;
  let l be Element of NAT;
  now
    let x be set;
    assume x in dom Start-At(l,SCM+FSA);
    then x in {IC SCM+FSA} by FUNCOP_1:19;
    then x = IC SCM+FSA by TARSKI:def 1;
    hence not x in D by COMPOS_1:56;
  end;
  then dom Start-At(l,SCM+FSA) misses D by XBOOLE_0:3;
  hence thesis by FUNCT_4:76;
end;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA, l being
  Element of NAT holds DataPart s = DataPart (s +* (I +*
  Start-At(l,SCM+FSA)))
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let l be Element of NAT;
  now
    let x be set;
    assume x in dom (I +* Start-At(l,SCM+FSA));
    then x in dom I \/ dom Start-At(l,SCM+FSA) by FUNCT_4:def 1;
    then x in dom I or x in dom Start-At(l,SCM+FSA) by XBOOLE_0:def 3;
    then
A1: x in dom I or x in {IC SCM+FSA} by FUNCOP_1:19;
    per cases by A1,TARSKI:def 1;
    suppose
A2:   x in dom I;
      dom I c= NAT & D misses NAT by COMPOS_1:51;
      hence not x in D by A2,XBOOLE_0:3;
    end;
    suppose
      x = IC SCM+FSA;
      hence not x in D by COMPOS_1:56;
    end;
  end;
  then dom (I +* Start-At(l,SCM+FSA)) misses D by XBOOLE_0:3;
  hence thesis by FUNCT_4:76;
end;

canceled;

theorem Th13:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  s +* Initialized I = Initialized s +* (Initialize I)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
A1: now
    let x be set;
    I c= Initialized I by SCMFSA6A:26;
    then
A2: dom I c= dom Initialized I by GRFUNC_1:8;
    assume
A3: x in dom (s +* Initialized I);
    per cases by A3,SCMFSA6A:35;
    suppose
A4:   x = intloc 0;
      then
A5:   not x in dom (Initialize I) by SCMFSA6B:12;
      x in dom Initialized I by A4,SCMFSA6A:45;
      hence (s +* Initialized I).x = (Initialized I).x by FUNCT_4:14
        .= 1 by A4,SCMFSA6A:46
        .= (Initialized s).x by A4,SCMFSA6C:3
        .= (Initialized s +* (Initialize I)).x
         by A5,FUNCT_4:12;
    end;
    suppose
A6:   x = IC SCM+FSA;
      then
A7:   x in dom (Initialize I) by COMPOS_1:141;
      x in dom (Initialized I) by A6,SCMFSA6A:24;
      hence (s +* Initialized I).x = (Initialized I).x by FUNCT_4:14
        .=  0 by A6,SCMFSA6A:46
        .= IC(Initialize I) by COMPOS_1:142
        .= (Initialized s +* (Initialize I)).x
          by A6,A7,FUNCT_4:14;
    end;
    suppose
A8:   x in dom I;
      then x in dom I \/ (dom SA0) by XBOOLE_0:def 3;
      then
A9:   x in dom (Initialize I) by FUNCT_4:def 1;
      thus (s +* Initialized I).x = (Initialized I).x by A2,A8,FUNCT_4:14
        .= I.x by A8,SCMFSA6A:50
        .= (Initialize I).x by A8,COMPOS_1:145
        .= (Initialized s +* (Initialize I)).x
         by A9,FUNCT_4:14;
    end;
    suppose
A10:  x is Element of NAT & not x in dom I;
      then not x = IC SCM+FSA by COMPOS_1:3;
      then not x in {IC SCM+FSA} by TARSKI:def 1;
      then not x in dom I \/ {IC SCM+FSA} by A10,XBOOLE_0:def 3;
      then not x in dom I \/ dom SA0 by FUNCOP_1:19;
      then
A11:  not x in dom (Initialize I) by FUNCT_4:def 1;
      x <> IC SCM+FSA by A10,COMPOS_1:3;
      then not x in dom Initialized I by A10,SCMFSA6A:44,SCMFSA_2:84;
      hence (s +* Initialized I).x = s.x by FUNCT_4:12
        .= (Initialized s).x by A10,SCMFSA6C:3
        .= (Initialized s +* (Initialize I)).x
         by A11,FUNCT_4:12;
    end;
    suppose
A12:  x is FinSeq-Location;
      then not x = IC SCM+FSA by SCMFSA_2:82;
      then
A13:  not x in {IC SCM+FSA} by TARSKI:def 1;
      not x in dom I by A2,A12,SCMFSA6A:49;
      then not x in dom I \/ {IC SCM+FSA} by A13,XBOOLE_0:def 3;
      then not x in dom I \/ dom SA0 by FUNCOP_1:19;
      then
A14:  not x in dom (Initialize I) by FUNCT_4:def 1;
      not x in dom Initialized I by A12,SCMFSA6A:49;
      hence (s +* Initialized I).x = s.x by FUNCT_4:12
        .= (Initialized s).x by A12,SCMFSA6C:3
        .= (Initialized s +* (Initialize I)).x
         by A14,FUNCT_4:12;
    end;
    suppose
A15:  x is Int-Location & x <> intloc 0;
      then not x = IC SCM+FSA by SCMFSA_2:81;
      then
A16:  not x in {IC SCM+FSA} by TARSKI:def 1;
      not x in dom I by A2,A15,SCMFSA6A:48;
      then not x in dom I \/ {IC SCM+FSA} by A16,XBOOLE_0:def 3;
      then not x in dom I \/ dom SA0 by FUNCOP_1:19;
      then
A17:  not x in dom (Initialize I) by FUNCT_4:def 1;
A18:  x is read-write Int-Location by A15,SF_MASTR:def 5;
      not x in dom Initialized I by A15,SCMFSA6A:48;
      hence (s +* Initialized I).x = s.x by FUNCT_4:12
        .= (Initialized s).x by A18,SCMFSA6C:3
        .= (Initialized s +* (Initialize I)).x
         by A17,FUNCT_4:12;
    end;
  end;
  dom (s +* Initialized I) = the carrier of SCM+FSA by PARTFUN1:def 4
    .= dom (Initialized s +* (Initialize I)) by PARTFUN1:def 4;
  hence thesis by A1,FUNCT_1:9;
end;

theorem Th14:
  for s being State of SCM+FSA, I1,I2 being Program of SCM+FSA, l
  being Element of NAT holds s +* (I1 +* Start-At(l,SCM+FSA)),
   s +* (I2
  +* Start-At(l,SCM+FSA)) equal_outside NAT
proof
  let s be State of SCM+FSA;
  let I1,I2 be Program of SCM+FSA;
  let l be Element of NAT;
A1: now
    let a be Int-Location;
A2: not a in dom (I1 +* Start-At(l,SCM+FSA)) by SCMFSA6B:12;
    not a in dom (I2 +* Start-At(l,SCM+FSA)) by SCMFSA6B:12;
    hence (s +* (I2 +* Start-At(l,SCM+FSA))).a = s.a by FUNCT_4:12
      .= (s +* (I1 +* Start-At(l,SCM+FSA))).a by A2,FUNCT_4:12;
  end;
A3: now
    let f be FinSeq-Location;
A4: not f in dom (I1 +* Start-At(l,SCM+FSA)) by SCMFSA6B:13;
    not f in dom (I2 +* Start-At(l,SCM+FSA)) by SCMFSA6B:13;
    hence (s +* (I2 +* Start-At(l,SCM+FSA))).f = s.f by FUNCT_4:12
      .= (s +* (I1 +* Start-At(l,SCM+FSA))).f by A4,FUNCT_4:12;
  end;
  IC (s +* (I2 +* Start-At(l,SCM+FSA))) = IC (s +* I2 +* Start-At(l,SCM+FSA))
   by FUNCT_4:15
    .= l by FUNCT_4:121
    .= IC (s +* I1 +* Start-At(l,SCM+FSA)) by FUNCT_4:121
    .= IC (s +* (I1 +* Start-At(l,SCM+FSA))) by FUNCT_4:15;
  hence thesis by A1,A3,SCMFSA10:91;
end;

canceled 6;

theorem
  for P being preProgram of SCM+FSA, l being Element of NAT
, x being set st x in dom P holds (P.x = halt SCM+FSA implies Directed(P
  ,l).x = goto l) & (P.x <> halt SCM+FSA implies Directed(P,l).x = P.x) by
FUNCT_4:111,112;

theorem Th22:
  for i being Instruction of SCM+FSA, a being Int-Location, n
  being Element of NAT holds i does not destroy a implies IncAddr(i,n)
  does not destroy a
proof
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  let n be Element of NAT;
  assume
A1: i does not destroy a;
A2: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
A3: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A4: InsCode i <= 11+1 by SCMFSA_2:35;
  per cases by A4,A3,A2,NAT_1:8,33;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:122;
    then IncAddr(i,n) = halt SCM+FSA by COMPOS_1:93;
    hence thesis by SCMFSA7B:11;
  end;
  suppose
    InsCode i = 1;
    then ex da, db being Int-Location st i = da := db by SCMFSA_2:54;
    hence thesis by A1,COMPOS_1:92;
  end;
  suppose
    InsCode i = 2;
    then ex da, db being Int-Location st i = AddTo(da,db) by SCMFSA_2:55;
    hence thesis by A1,COMPOS_1:92;
  end;
  suppose
    InsCode i = 3;
    then ex da, db being Int-Location st i = SubFrom(da, db) by SCMFSA_2:56;
    hence thesis by A1,COMPOS_1:92;
  end;
  suppose
    InsCode i = 4;
    then ex da, db being Int-Location st i = MultBy(da,db) by SCMFSA_2:57;
    hence thesis by A1,COMPOS_1:92;
  end;
  suppose
    InsCode i = 5;
    then ex da, db being Int-Location st i = Divide(da, db) by SCMFSA_2:58;
    hence thesis by A1,COMPOS_1:92;
  end;
  suppose
    InsCode i = 6;
    then consider loc being Element of NAT such that
A5: i = goto loc by SCMFSA_2:59;
    IncAddr(i,n) = goto (loc + n) by A5,SCMFSA_4:14;
    hence thesis by SCMFSA7B:17;
  end;
  suppose
    InsCode i = 7;
    then consider
    loc being Element of NAT, da being Int-Location
    such that
A6: i = da =0_goto loc by SCMFSA_2:60;
    IncAddr(i,n) = da =0_goto (loc + n) by A6,SCMFSA_4:15;
    hence thesis by SCMFSA7B:18;
  end;
  suppose
    InsCode i = 8;
    then consider
    loc being Element of NAT, da being Int-Location
    such that
A7: i = da >0_goto loc by SCMFSA_2:61;
    IncAddr(i,n) = da >0_goto (loc + n) by A7,SCMFSA_4:16;
    hence thesis by SCMFSA7B:19;
  end;
  suppose
    InsCode i = 9;
    then
    ex db, da being Int-Location, g being FinSeq-Location st i = da := (g,
    db) by SCMFSA_2:62;
    hence thesis by A1,COMPOS_1:92;
  end;
  suppose
    InsCode i = 10;
    then ex db, da being Int-Location, g being FinSeq-Location st i = (g,db):=
    da by SCMFSA_2:63;
    hence thesis by A1,COMPOS_1:92;
  end;
  suppose
    InsCode i = 11;
    then
    ex da being Int-Location, g being FinSeq-Location st i = da :=len g by
SCMFSA_2:64;
    hence thesis by A1,COMPOS_1:92;
  end;
  suppose
    InsCode i = 12;
    then
    ex da being Int-Location, g being FinSeq-Location st i = g :=<0,...,0>
    da by SCMFSA_2:65;
    hence thesis by A1,COMPOS_1:92;
  end;
end;

theorem Th23:
  for P being preProgram of SCM+FSA, n being Element of NAT, a
being Int-Location holds P does not destroy a implies Reloc(P,
  n) does not destroy a
proof
  let I be preProgram of SCM+FSA;
  let n be Element of NAT;
  let a be Int-Location;
A1: Reloc(I,n) = Shift(IncAddr(I,n),n) by COMPOS_1:121;
A2: dom IncAddr(I,n) = dom I by COMPOS_1:def 40;
A3: dom Shift(IncAddr(I,n),n) = { m+n: m in dom IncAddr(I,n) } by
VALUED_1:def 12;
  assume
A4: I does not destroy a;
  now
    let i be Instruction of SCM+FSA;
    assume i in rng Reloc(I,n);
    then consider x being set such that
A5: x in dom Shift(IncAddr(I,n),n) and
A6: i = Shift(IncAddr(I,n),n).x by A1,FUNCT_1:def 5;
    consider m being Element of NAT such that
A7: x = m + n and
A8: m in dom IncAddr(I,n) by A3,A5;
A9: I. m in rng I by A2,A8,FUNCT_1:def 5;
    rng I c= the Instructions of SCM+FSA by RELAT_1:def 19;
    then reconsider ii = I. m as Instruction of SCM+FSA by A9;
A10: ii does not destroy a by A4,A9,SCMFSA7B:def 4;
    i = IncAddr(I,n). m by A6,A7,A8,VALUED_1:def 12
      .= IncAddr(I/.m,n) by A2,A8,COMPOS_1:def 40
      .= IncAddr(ii,n) by A2,A8,PARTFUN1:def 8;
    hence i does not destroy a by A10,Th22;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th24:
  for P being good preProgram of SCM+FSA, n being Element of NAT
  holds Reloc(P,n) is good
proof
  let I be good preProgram of SCM+FSA;
  let n be Element of NAT;
  I does not destroy intloc 0 by SCMFSA7B:def 5;
  then Reloc(I,n) does not destroy intloc 0 by Th23;
  hence thesis by SCMFSA7B:def 5;
end;

theorem Th25:
  for I,J being preProgram of SCM+FSA, a being Int-Location holds
  I does not destroy a & J does not destroy a implies I +* J does not destroy a
proof
  let I,J be preProgram of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does not destroy a;
  assume
A2: J does not destroy a;
  now
    let i be Instruction of SCM+FSA;
A3: rng (I +* J) c= rng I \/ rng J by FUNCT_4:18;
    assume
A4: i in rng (I +* J);
    per cases by A4,A3,XBOOLE_0:def 3;
    suppose
      i in rng I;
      hence i does not destroy a by A1,SCMFSA7B:def 4;
    end;
    suppose
      i in rng J;
      hence i does not destroy a by A2,SCMFSA7B:def 4;
    end;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th26:
  for I,J being good preProgram of SCM+FSA holds I +* J is good
proof
  let I,J be good preProgram of SCM+FSA;
  I does not destroy intloc 0 & J does not destroy intloc 0 by SCMFSA7B:def 5;
  then I +* J does not destroy intloc 0 by Th25;
  hence thesis by SCMFSA7B:def 5;
end;

theorem Th27:
  for I being preProgram of SCM+FSA, l being Element of NAT
, a being Int-Location holds I does not destroy a implies Directed(I,
  l) does not destroy a
proof
  let I be preProgram of SCM+FSA;
  let l be Element of NAT;
  let a be Int-Location;
  assume
A1: I does not destroy a;
  now
    let i be Instruction of SCM+FSA;
A2: dom Directed(I,l) = dom I by FUNCT_4:105;
    assume i in rng Directed(I,l);
    then consider x being set such that
A3: x in dom Directed(I,l) and
A4: i = Directed(I,l).x by FUNCT_1:def 5;
    per cases;
    suppose
      I.x <> halt SCM+FSA;
      then i = I.x by A4,FUNCT_4:111;
      then i in rng I by A3,A2,FUNCT_1:def 5;
      hence i does not destroy a by A1,SCMFSA7B:def 4;
    end;
    suppose
      I.x = halt SCM+FSA;
      then i = goto l by A3,A4,A2,FUNCT_4:112;
      hence i does not destroy a by SCMFSA7B:17;
    end;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

registration
  let I be good preProgram of SCM+FSA;
  let l be Element of NAT;
  cluster Directed(I,l) -> good;
  correctness
  proof
    I does not destroy intloc 0 by SCMFSA7B:def 5;
    then Directed(I,l) does not destroy intloc 0 by Th27;
    hence thesis by SCMFSA7B:def 5;
  end;
end;

registration
  let I be good Program of SCM+FSA;
  cluster Directed I -> good;
  correctness;
end;

registration
  let I be Program of SCM+FSA, l be Element of NAT;
  cluster Directed(I,l) -> initial;
  correctness
  proof
    now
      let m,n be Nat;
      assume n in dom Directed(I,l);
      then
A1:    n in dom I by FUNCT_4:105;
      assume m < n;
      then  m in dom I by A1,AFINSQ_1:def 13;
      hence m in dom Directed(I,l) by FUNCT_4:105;
    end;
    hence thesis by AFINSQ_1:def 13;
  end;
end;

registration
  let I,J be good Program of SCM+FSA;
  cluster I ';' J -> good;
  coherence
  proof
    Reloc(J,card I) is good by Th24;
    hence thesis by Th26;
  end;
end;

Lm1: for l being Element of NAT holds dom ( 0 .--> goto
l) = { 0} &  0 in dom ( 0 .--> goto l) & ( 0 .--> goto
l). 0 = goto l & card ( 0 .--> goto l) = 1 & not halt SCM+FSA in
rng ( 0 .--> goto l)

proof
  let l be Element of NAT;
  thus dom ( 0 .--> goto l) = { 0} by FUNCOP_1:19;
  hence  0 in dom ( 0 .--> goto l) by TARSKI:def 1;
  thus ( 0 .--> goto l). 0 = goto l by FUNCOP_1:87;
  thus card ( 0 .--> goto l) = card <% goto l %> by AFINSQ_1:def 2
    .= 1 by AFINSQ_1:38;
  now
A1: rng ( 0 .--> goto l) = {goto l} by FUNCOP_1:14;
    assume halt SCM+FSA in rng ( 0 .--> goto l);
    hence contradiction by A1,TARSKI:def 1;
  end;
  hence thesis;
end;

definition
  canceled;
  let l be Element of NAT;
  func Goto l -> Program of SCM+FSA equals
   0 .--> goto l;
  coherence
  proof
     0 .--> goto l = <% goto l %> by AFINSQ_1:def 2;
    then reconsider I =  0 .--> goto l as Program of SCM+FSA;
    reconsider I as Program of SCM+FSA;
    now
      let x be Instruction of SCM+FSA;
A1:   rng ( 0 .--> goto l) = {goto l} by FUNCOP_1:14;
      assume x in rng ( 0 .--> goto l);
      then x = goto l by A1,TARSKI:def 1;
      hence x does not destroy intloc 0 by SCMFSA7B:17;
    end;
    then I does not destroy intloc 0 by SCMFSA7B:def 4;
    hence thesis;
  end;
end;

registration
  let l be Element of NAT;
  cluster Goto l -> halt-free good;
  coherence
  proof
     0 .--> goto l = <% goto l %> by AFINSQ_1:def 2;
    then reconsider I =  0 .--> goto l as Program of SCM+FSA;
    not halt SCM+FSA in rng I by Lm1;
   hence Goto l is halt-free by COMPOS_1:def 7;
    reconsider I as Program of SCM+FSA;
    now
      let x be Instruction of SCM+FSA;
A1:   rng ( 0 .--> goto l) = {goto l} by FUNCOP_1:14;
      assume x in rng ( 0 .--> goto l);
      then x = goto l by A1,TARSKI:def 1;
      hence x does not destroy intloc 0 by SCMFSA7B:17;
    end;
    then I does not destroy intloc 0 by SCMFSA7B:def 4;
    hence thesis by SCMFSA7B:def 5;
  end;
end;

registration
 cluster halt-free good Program of SCM+FSA;
 existence
  proof
   take Goto 0;
   thus thesis;
  end;
end;

definition
  let s be State of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  let I be initial FinPartState of SCM+FSA;
  pred I is_pseudo-closed_on s,P means
  :Def3:
  ex k being Element of NAT st
   IC Comput(P +* ProgramPart I, s +* (Initialize I),k)
    = card ProgramPart I &
  for n being Element of NAT st n < k
   holds IC Comput(P +* ProgramPart I,s +* (Initialize I),n)
       in dom I;
end;

definition
  let I be initial FinPartState of SCM+FSA;
  attr I is pseudo-paraclosed means

  for s being State of SCM+FSA,
      P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
      holds
  I is_pseudo-closed_on s,P;
end;

registration
 cluster sequential Instruction of SCM+FSA;
 existence
  proof take intloc 0:= intloc 0; thus thesis; end;
end;

registration let i be sequential Instruction of SCM+FSA;
 cluster <%i%> -> pseudo-paraclosed;
 coherence
  proof
   set I = <%i%>;
A1: ProgramPart I = I by RELAT_1:209;
   let s be State of SCM+FSA;
   let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
    set s1 = s +* (Initialize I);
    dom I = 1 by AFINSQ_1:36;
    then
A2:  0 in dom I by CARD_1:87,TARSKI:def 1;
    dom(P +* I) = dom P \/ dom I by FUNCT_4:def 1;
    then
A3:  0 in dom(P +* I) by A2,XBOOLE_0:def 3;
A4: CurInstr(P+*I,s1)
        = (P+*I)/.0 by COMPOS_1:def 16
       .= (P +* I).0 by A3,PARTFUN1:def 8
       .= I.0 by A2,FUNCT_4:14
       .= i by AFINSQ_1:38;
   take 1;
   thus IC Comput(P+*ProgramPart I, s1,1)
    = IC Comput(P+*I, s1,0+1) by A1
   .= IC Following(P+*I,Comput(P+*I,s1,0)) by EXTPRO_1:4
   .= IC Following(P+*I,s1) by EXTPRO_1:3
   .= succ IC s1 by A4,AMISTD_1:def 16
   .= succ 0 by COMPOS_1:def 16
   .= card I by AFINSQ_1:38
   .= card ProgramPart I by RELAT_1:209;
   let n be Element of NAT;
   assume n < 1;
    then n = 0 by NAT_1:14;
    then
A5:   IC Comput(P+*I,s1,n)
     = IC s1 by EXTPRO_1:3
    .= 0 by COMPOS_1:def 16;
    dom I = 1 by AFINSQ_1:36;
   hence IC Comput(P+*ProgramPart I,s1,n) in dom I
    by A5,CARD_1:87,TARSKI:def 1,A1;
  end;
end;

registration
  cluster pseudo-paraclosed Program of SCM+FSA;
  existence
  proof
   take <%the sequential Instruction of SCM+FSA%>;
   thus thesis;
  end;
end;

definition
  let s be State of SCM+FSA,
      P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
      I be initial FinPartState of SCM+FSA such that
A1: I is_pseudo-closed_on s,P;
  func pseudo-LifeSpan(s,P,I) -> Element of NAT means
  :Def5:
  IC Comput(P +* ProgramPart I,s+* (Initialize I),it)
   =  card ProgramPart I &
   for n being Element of NAT
    st not IC Comput(P +* ProgramPart I, (s +* (Initialize I)),n)
      in dom I
     holds it <= n;
  existence
  proof
    consider k being Element of NAT such that
A2: IC Comput(P+*ProgramPart I, (s +* (Initialize I)),k)
       =  card ProgramPart I &
      for n being Element of NAT st n < k holds
       IC Comput(P+*ProgramPart I, (s +* (Initialize I)),n)
          in dom I
        by A1,Def3;
    take k;
    thus thesis by A2;
  end;
  uniqueness
  proof
    reconsider II = ProgramPart I as initial preProgram of SCM+FSA;
    let k1,k2 be Element of NAT such that
A3: IC Comput(P+*ProgramPart I, (s +* (Initialize I)),k1)
       =  card ProgramPart I and
A4: ( for n being Element of NAT st
     not IC Comput(P+*ProgramPart I,(s +* (Initialize I)),n) in dom I holds
     k1 <= n)&
     IC Comput(P+*ProgramPart I, (s +* (Initialize I) ),k2)
      =  card ProgramPart I and
A5: for n being Element of NAT st
     not IC Comput(P+*ProgramPart I,(s +* (Initialize I)),n) in dom I holds
     k2 <= n;
A6: now
      assume k2 < k1;
      then  card II in dom II by A4,COMPOS_1:16;
      hence contradiction;
    end;
    now
      assume k1 < k2;
      then  card II in dom II by A3,A5,COMPOS_1:16;
      hence contradiction;
    end;
    hence thesis by A6,XXREAL_0:1;
  end;
end;

theorem Th28:
  for I,J being Program of SCM+FSA, x being set holds x in dom I
  implies (I ';' J).x = (Directed I).x
proof
  let I,J be Program of SCM+FSA;
  let x be set;
  assume x in dom I;
  then
A1: x in dom Directed I by FUNCT_4:105;
  Directed I c= I ';' J by SCMFSA6A:55;
  hence thesis by A1,GRFUNC_1:8;
end;

theorem
  for l being Element of NAT holds card Goto l = 1 by Lm1;

theorem
  for P being preProgram of SCM+FSA, x being set st x in dom P holds (P.
  x = halt SCM+FSA implies (Directed P).x = goto  card P) & (P.x <> halt
  SCM+FSA implies (Directed P).x = P.x) by FUNCT_4:111,112;

theorem Th31:
  for s being State of SCM+FSA,
  P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
  I being initial FinPartState of
  SCM+FSA st I is_pseudo-closed_on s,P
   holds for n being Element of NAT st n < pseudo-LifeSpan(s,P,I)
    holds IC ( Comput(P+* ProgramPart I,
       s +* (Initialize I),n)) in dom I &
  CurInstr(P+*ProgramPart I,Comput(P+*ProgramPart I,
     (s +* (Initialize I)),n)) <>
          halt SCM+FSA
proof
  let s be State of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  let I be initial FinPartState of SCM+FSA;
  set k = pseudo-LifeSpan(s,P,I);
  assume
A1: I is_pseudo-closed_on s,P;
  then
A2: IC Comput(P+*ProgramPart I, (s +* (Initialize I)),k) =
      card ProgramPart I by Def5;
  hereby
    let n be Element of NAT;
    assume
A3: n < k;
    hence IC Comput(P+*ProgramPart I, (s +* (Initialize I)) ,n)
     in dom I by A1,Def5;
    then
A4: IC Comput(P+*ProgramPart I, (s +* (Initialize I)),n) in dom
       ProgramPart I by COMPOS_1:16;
    assume
    CurInstr (P+*ProgramPart I,
     Comput(P+*ProgramPart I, (s +* (Initialize I)),n))
        = halt SCM+FSA;
    then
    IC Comput(P+*ProgramPart I, (s +* (Initialize I)),k) =
     IC Comput(P+*ProgramPart I, s +* (Initialize I),n)
       by A3,EXTPRO_1:6;
    hence contradiction by A2,A4;
  end;
end;

theorem Th32:
  for s being State of SCM+FSA,
  P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
  I,J being Program of SCM+FSA st I
  is_pseudo-closed_on s,P for k being Element of NAT st
   k <= pseudo-LifeSpan(s,P,I)
  holds Comput(P+*I, (s +* (Initialize I)),k),
   Comput(P+*(I ';' J), (s +* (Initialize (I ';' J))),k)
      equal_outside NAT
proof
  let s be State of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  let I,J be Program of SCM+FSA;
  set s1 = s +* (Initialize I);
  set s2 = s +* (Initialize (I ';' J));
  set I1 = Initialize I;
  set I2 = Initialize (I ';' J);
A1: ProgramPart I = I by RELAT_1:209;
  defpred P[Nat] means $1 <= pseudo-LifeSpan(s,P,I) implies
  Comput(P+*I,s1,$1), Comput(P+*(I ';' J),s2,$1) equal_outside A;
A2: dom(P+*I) = NAT by PARTFUN1:def 4;
A3: dom(P+*(I ';' J)) = NAT by PARTFUN1:def 4;
  assume
A4: I is_pseudo-closed_on s,P;
A5: now
    let k be Element of NAT;
    assume
A6: P[k];
    thus P[k+1]
    proof
A7:   Comput(P+*(I ';' J),s2,k+1) = Following(P+*(I ';' J),
Comput(P+*(I ';' J),s2,k)) by EXTPRO_1:4
        .= Exec(CurInstr(P+*(I ';' J),Comput(P+*(I ';' J),s2,k)),
        Comput(P+*(I ';' J),s2,k));
A8:   Comput(P+*I,s1,k+1) = Following(P+*I,
Comput(P+*I,s1,k)) by EXTPRO_1:4
        .= Exec(CurInstr(P+*I,Comput(P+*I,s1,k)),
        Comput(P+*I,s1,k));
A9:   dom I c= dom (I ';' J) by SCMFSA6A:56;
A10:   k + 0 < k + 1 by XREAL_1:8;
      assume
A11:   k + 1 <= pseudo-LifeSpan(s,P,I);
      then
A12:  k < pseudo-LifeSpan(s,P,I) by A10,XXREAL_0:2;
      then
A13:  IC Comput(P+*I,s1,k) in dom I by A4,Th31,A1;
A14:  I c= P+*I by FUNCT_4:26;
A15:  I ';' J c= P+*(I ';' J) by FUNCT_4:26;
A16:  CurInstr(P+*I,Comput(P+*I,s1,k))
         = (P+*I).IC Comput(P+*I,s1,k) by A2,PARTFUN1:def 8
        .= I.IC Comput(P+*I,s1,k) by A13,GRFUNC_1:8,A14;
      then I.IC Comput(P+*I,s1,k) <> halt SCM+FSA by A4,A12,Th31,A1;
      then
      CurInstr(P+*I,Comput(P+*I,s1,k))
       = (I ';' J).IC Comput(P+*I,s1,k) by A13,A16,SCMFSA6A:54
        .= (P+*(I ';' J)).IC Comput(P+*I,s1,k)
         by A13,A9,GRFUNC_1:8,A15
        .= (P+*(I ';' J)).IC Comput(P+*(I ';' J),s2,k)
             by A6,A11,A10,COMPOS_1:24,XXREAL_0:2
        .= CurInstr(P+*(I ';' J),Comput(P+*(I ';' J),s2,k))
         by A3,PARTFUN1:def 8;
      hence thesis by A6,A11,A10,A8,A7,AMISTD_2:def 20,XXREAL_0:2;
    end;
  end;
A17: P[0]
  proof
    assume 0 <= pseudo-LifeSpan(s,P,I);
    s1,s2 equal_outside A by Th14;
    then Comput(P+*I,s1,0),s2 equal_outside A by EXTPRO_1:3;
    hence thesis by EXTPRO_1:3;
  end;
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A17,A5);
end;

theorem Th33:
  for I being preProgram of SCM+FSA, l being Element of NAT
  holds card Directed(I,l) = card I
proof
  let I be preProgram of SCM+FSA;
  let l be Element of NAT;
  thus card Directed(I,l) = card dom Directed(I,l) by CARD_1:104
    .= card dom I by FUNCT_4:105
    .= card I by CARD_1:104;
end;

theorem
  for I being Program of SCM+FSA holds card Directed I = card I by Th33;

theorem Th35:
  for s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
  I being Program of SCM+FSA st I
  is_closed_on s,P & I is_halting_on s,P
  for k being Element of NAT
  st k <= LifeSpan(P+*I,s +* (Initialize I))
   holds Comput(P+*I, (s +* (Initialize I)),k),
      Comput(P+*Directed I, (s +* (Initialize Directed I)),k)
     equal_outside NAT &
   CurInstr(P+*Directed I,
     Comput(P+*Directed I, (s +* (Initialize Directed I)),k))
      <> halt SCM+FSA
proof
  let s be State of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  let I be Program of SCM+FSA;
  assume that
A1: I is_closed_on s,P and
A2: I is_halting_on s,P;
A3: dom(P+*Directed I) = NAT by PARTFUN1:def 4;
A4: dom(P+*I) = NAT by PARTFUN1:def 4;
A5: ProgramPart I = I by RELAT_1:209;
  set s2 = s +* (Initialize Directed I);
  set s1 = s +* (Initialize I);
  defpred P[Nat] means $1 <= LifeSpan(P+*I,s1)
   implies ( Comput(P+*I,s1,$1), Comput(P+*Directed I,s2,$1)
      equal_outside A &
  CurInstr(P+*Directed I,Comput(P+*Directed I,s2,$1)) <> halt SCM+FSA);
A6: now
    let k be Element of NAT;
    dom Directed I = dom I by FUNCT_4:105;
    then
A7: IC Comput(P+*I,s1,k) in dom Directed I by A1,SCMFSA7B:def 7,A5;
A8:  (P+*Directed I)/.IC Comput(P+*Directed I,s2,k)
      = (P+*Directed I).IC Comput(P+*Directed I,s2,k) by A3,PARTFUN1:def 8;
A9: Directed I c= P+*Directed I by FUNCT_4:26;
    assume
    Comput(P+*I,s1,k), Comput(P+*Directed I,s2,k) equal_outside A;
    then CurInstr(P+*Directed I,Comput(P+*Directed I,s2,k))
      = (P+*Directed I).IC Comput(P+*I,s1,k) by A8,COMPOS_1:24
      .= (Directed I).IC Comput(P+*I,s1,k) by A7,GRFUNC_1:8,A9;
    then
     A10: CurInstr(P+*Directed I,Comput(P+*Directed I,s2,k)) in rng Directed I
         by A7,FUNCT_1:def 5;
    assume
    CurInstr(P+*Directed I,Comput(P+*Directed I,s2,k)) = halt SCM+FSA;
    hence contradiction by A10,SCMFSA6A:18;
  end;
  now
A11: P+*I halts_on s1 by A2,SCMFSA7B:def 8,A5;
A12: dom I c= dom Directed I by FUNCT_4:105;
    let k be Element of NAT;
    assume
A13: k <= LifeSpan(P+*I,s1) implies Comput(P+*I,s1,k),
Comput(P+*Directed I,s2,k)
    equal_outside A;
A14: Comput(P+*Directed I,s2,k+1) = Following(P+*Directed I,
Comput(P+*Directed I,s2,k)) by EXTPRO_1:4
      .= Exec(CurInstr(P+*Directed I,Comput(P+*Directed I,s2,k)),
      Comput(P+*Directed I,s2,k));
A15: IC Comput(P+*I,s1,k) in dom I by A1,SCMFSA7B:def 7,A5;
A16: I c=P+*I by FUNCT_4:26;
A17: CurInstr(P+*I,Comput(P+*I,s1,k))
      = (P+*I).IC Comput(P+*I,s1,k) by A4,PARTFUN1:def 8
     .= I.IC Comput(P+*I,s1,k) by A15,GRFUNC_1:8,A16;
A18: k + 0 < k + 1 by XREAL_1:8;
A19:  (P+*Directed I)/.IC Comput(P+*Directed I,s2,k)
    = (P+*Directed I).IC Comput(P+*Directed I,s2,k) by A3,PARTFUN1:def 8;
A20: Directed I c= P+*Directed I by FUNCT_4:26;
    assume
A21: k + 1 <= LifeSpan(P+*I,s1);
    then k < LifeSpan(P+*I,s1) by A18,XXREAL_0:2;
    then I.IC Comput(P+*I,s1,k) <> halt SCM+FSA by A17,A11,
EXTPRO_1:def 14;
    then
A22: CurInstr(P+*I,Comput(P+*I,s1,k))
 = (Directed I).IC Comput(P+*I,s1,k) by A17,FUNCT_4:111
      .= (P+*Directed I).IC Comput(P+*I,s1,k) by A15,A12,GRFUNC_1:8,A20
      .= CurInstr(P+*Directed I,Comput(P+*Directed I,s2,k))
      by A13,A21,A18,A19,COMPOS_1:24,XXREAL_0:2;
 Comput(P+*I,s1,k+1) = Following(P+*I,Comput(P+*I,s1,k)) by EXTPRO_1:4
      .= Exec(CurInstr(P+*I,Comput(P+*I,s1,k)),
      Comput(P+*I,s1,k));
    hence Comput(P+*I,s1,k+1), Comput(P+*Directed I,s2,k+1)
equal_outside A by A13,A21,A18,A22,A14,AMISTD_2:def 20,XXREAL_0:2;
    hence CurInstr(P+*Directed I,Comput(P+*Directed I,s2,k+1)) <>
     halt SCM+FSA
      by A6;
  end;
  then
A23: for k being Element of NAT st P[k] holds P[k + 1];
  now
    assume 0 <= LifeSpan(P+*I,s1);
A24: Comput(P+*I,s1,0) = s1 & Comput(P+*Directed I,s2,0) = s2 by
EXTPRO_1:3;
    hence Comput(P+*I,s1,0), Comput(P+*Directed I,s2,0)
equal_outside A by Th14;
    thus CurInstr(P+*Directed I,Comput(P+*Directed I,s2,0)) <>
     halt SCM+FSA by A6,A24,Th14;
  end;
  then
A25: P[0];
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A25,A23);
end;

theorem Th36:
  for s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
  I being Program of SCM+FSA
   st I is_closed_on s,P & I is_halting_on s,P
  holds
   IC Comput(P+*Directed I, (s +* (Initialize Directed I)),
    (LifeSpan(P+*I,s +* (Initialize I)) + 1)) = card I &
    DataPart Comput(P+*I, (s +* (Initialize I)),
   (LifeSpan(P+*I,s +* (Initialize I)))) =
   DataPart Comput(P+*Directed I, (s +* (Initialize Directed I)),
   (LifeSpan(P+*I,s +* (Initialize I)) + 1))
proof
  let s be State of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  let I be Program of SCM+FSA;
  set s1 = s +* (Initialize I);
  set s2 = s +* (Initialize Directed I);
  set m1 = LifeSpan(P+*I,s1);
A1: ProgramPart I = I by RELAT_1:209;
A2: dom(P+*I) = NAT by PARTFUN1:def 4;
A3: dom(P+*Directed I) = NAT by PARTFUN1:def 4;
  assume that
A4: I is_closed_on s,P and
A5: I is_halting_on s,P;
A6: P+*I halts_on s1 by A5,SCMFSA7B:def 8,A1;
  set l1 = IC Comput(P+*I, s1,m1);
A7: l1 in dom I by A4,SCMFSA7B:def 7,A1;
  then IC Comput(P+*Directed I, s2,m1) in dom I by A4,A5,Th35,COMPOS_1:24;
  then
A8: IC Comput(P+*Directed I, s2,m1) in dom Directed I by FUNCT_4:105;
:::  then P.l1 = I.l1 by A4,FUNCT_4:14;
  I c= P+*I by FUNCT_4:26;
  then
A9: I.l1
::: = P.l1 by A4,COMPOS_1:145
     = (P+*I).IC Comput(P+*I,s1,m1) by GRFUNC_1:8,A7
    .= CurInstr(P+*I,Comput(P+*I,s1,m1)) by A2,PARTFUN1:def 8
    .= halt SCM+FSA by A6,EXTPRO_1:def 14;
 l1 = IC Comput(P+*Directed I, s2,m1) by A4,A5,Th35,COMPOS_1:24;
  then
A10: (P+*Directed I).l1 = (Directed I).l1 by A8,FUNCT_4:14
    .= (Directed I).l1
    .= goto  card I by A7,A9,FUNCT_4:112;
A11: CurInstr(P+*Directed I,Comput(P+*Directed I,s2,m1))
     = (P+*Directed I).IC Comput(P+*Directed I,s2,m1) by A3,PARTFUN1:def 8
    .= (P+*Directed I).l1 by A4,A5,Th35,COMPOS_1:24
    .= goto  card I by A10;
A12: Comput(P+*Directed I, s2,m1 + 1) = Following(P+*Directed I,
Comput(P+*Directed I,s2,m1)) by EXTPRO_1:4
    .= Exec(goto  card I, Comput(P+*Directed I, s2,m1)) by A11;
  hence IC Comput(P+*Directed I, s2,m1 + 1) =  card I by SCMFSA_2:95;
A13: ( for a being Int-Location holds Comput(P+*Directed I, s2,m1 + 1).a =
Comput(P+*Directed I, s2, m1).a)& for f being FinSeq-Location holds Comput(
P+*Directed I, s2,m1
  + 1).f = Comput(P+*Directed I, s2,m1).f by A12,SCMFSA_2:95;
  DataPart Comput(P+*I, s1,m1) = DataPart Comput(P+*Directed I,
s2,m1) by A4,A5,Th35,COMPOS_1:138;
  hence thesis by A13,SCMFSA6A:38;
end;

Lm2: for s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
 I being Program of SCM+FSA holds I
is_closed_on s,P & I is_halting_on s,P implies
 Directed I is_pseudo-closed_on s,P &
  pseudo-LifeSpan(s,P,Directed I) =
     LifeSpan(P+*I,s +* (Initialize I)) + 1
proof
  let s be State of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  let I be Program of SCM+FSA;
  set s1 = s +* (Initialize I);
  set s2 = s +* (Initialize Directed I);
  set m1 = LifeSpan(P+*I,s1);
A1: ProgramPart I = I by RELAT_1:209;
A2: ProgramPart Directed I = Directed I by RELAT_1:209;
  assume that
A3: I is_closed_on s,P and
A4: I is_halting_on s,P;
A5: dom I = dom Directed I by FUNCT_4:105;
A6: now
    let n be Element of NAT;
    assume n < m1 + 1;
    then n <= m1 by NAT_1:13;
    then Comput(P+*I, s1,n), Comput(P+*Directed I, s2,n)
     equal_outside NAT by A3,A4,Th35;
    then IC Comput(P+*I, s1,n)
     = IC Comput(P+*Directed I, s2,n) by COMPOS_1:24;
    hence IC Comput(P+*Directed I, s2,n) in dom Directed I by A3,A5,
SCMFSA7B:def 7,A1;
  end;
  ProgramPart Directed I = Directed I by RELAT_1:209;
  then card I = card ProgramPart Directed I by Th33;
  then
A7: IC Comput(P+*Directed I, s2,m1 + 1) =  card ProgramPart Directed I by A3
,A4,Th36;

  hence
A8: Directed I is_pseudo-closed_on s,P by A6,Def3,A2;

  for n be Element of NAT st not IC Comput(P+*Directed I, s2,n) in dom
Directed I
  holds m1 + 1 <= n by A6;

  hence thesis by A7,A8,Def5,A2;
end;

theorem
  for s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
  I being Program of SCM+FSA st I is_closed_on s,P & I is_halting_on s,P
   holds Directed I is_pseudo-closed_on s,P by
Lm2;

theorem
  for s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
  I being Program of SCM+FSA st I is_closed_on s,P & I is_halting_on s,P
  holds pseudo-LifeSpan(s,P,Directed I) =
   LifeSpan(P +* I,s +* (Initialize I)) + 1 by Lm2;

canceled 2;

theorem Th41:
  for I,J being Program of SCM+FSA holds Directed I ';' J = I ';' J
proof
  let I,J be Program of SCM+FSA;
  thus Directed I ';' J = Directed I +* Reloc(J,card Directed
  I) by SCMFSA6A:63
    .= I ';' J by Th33;
end;

theorem Th42:
  for s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
  I,J being Program of SCM+FSA st I
  is_closed_on s,P & I is_halting_on s,P holds
  (for k being Element of NAT st
    k <= LifeSpan(P+*I,s +* (Initialize I))
 holds IC Comput(P+*Directed I, (s +* (Initialize Directed I)),k)
  = IC Comput(P+*(I ';' J), (s +* (Initialize (I ';' J))),k) &
   CurInstr(P+*Directed I,
      Comput(P+*Directed I, (s +* (Initialize Directed I)),k))
= CurInstr(P+*(I ';' J),
    Comput(P+*(I ';' J), (s +* (Initialize (I ';' J))),k))) &
DataPart Comput(P+*Directed I, (s +* (Initialize Directed I)),
 (LifeSpan(P+*I,s +* (Initialize I)) + 1)) =
   DataPart Comput(P+*(I ';' J), (s +* (Initialize (I ';' J))),
     (LifeSpan(P+*I,s +* (Initialize I)) + 1)) &
   IC Comput(P+*Directed I, (s +* (Initialize Directed I)),
   (LifeSpan(P+*I,s +* (Initialize I)) + 1))
 = IC Comput(P+*(I ';' J), (s +* (Initialize (I ';' J))),
     (LifeSpan(P+*I,s +* (Initialize I)) + 1))
proof
  let s be State of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  let I,J be Program of SCM+FSA;
A1: ProgramPart Directed I = Directed I by RELAT_1:209;
A2: dom(P+*Directed I) = NAT by PARTFUN1:def 4;
A3: dom(P+*(I ';' J)) = NAT by PARTFUN1:def 4;
  assume
A4: I is_closed_on s,P;
  set s2 = s +* (Initialize (I ';' J));
A5: Directed I ';' J = I ';' J by Th41;
  set s1 = s +* (Initialize I);
  assume
A6: I is_halting_on s,P;
  then
A7: LifeSpan(P+*I,s1) + 1 = pseudo-LifeSpan(s,P,Directed I)
 by A4,Lm2;
A8: Directed I is_pseudo-closed_on s,P by A4,A6,Lm2;
  hereby
    let k be Element of NAT;
    assume k <= LifeSpan(P+*I,s1);
    then
A9: k < pseudo-LifeSpan(s,P,Directed I) by A7,NAT_1:13;
    then
A10: IC Comput(P+*Directed I, (s +* (Initialize Directed I)),k)
          in dom Directed I by A8,Def5,A1;
    thus
A11: IC ( Comput(P+*Directed I,s +* (Initialize Directed I),k))
 = IC Comput(P+*(I ';' J), s2,k) by A5,A8,A9,Th32,COMPOS_1:24;
A12
:  (P+*Directed I)/.IC Comput(P+*Directed I, (s +* (Initialize Directed I)),k)
 = (P+*Directed I).IC Comput(P+*Directed I, (s +* (Initialize Directed I)),k)
 by A2,PARTFUN1:def 8;
A13: Directed I c= I ';' J by SCMFSA6A:55;
    then
 dom Directed I c= dom (I ';' J) by GRFUNC_1:8;
    then
A14: IC Comput(P+*Directed I, (s +*
(Initialize Directed I)),k)
 in dom (I
    ';' J) by A10;
    thus CurInstr(P +* Directed I, Comput(P+*Directed I,
     (s +* (Initialize Directed I)),k))
       = (P+*Directed I). IC Comput(P+*Directed I,
           (s +* (Initialize Directed I)),k) by A12
      .= (Directed I).
       IC Comput(P+*Directed I,
            (s +* (Initialize Directed I)),k) by A10,FUNCT_4:14
      .= (Directed I). IC Comput(P+*Directed I,
         (s +* (Initialize Directed I)),k)
      .= (I ';' J).IC Comput(P+*Directed I,
         (s +* (Initialize Directed I)),k) by A10,A13,GRFUNC_1:8
      .= (I ';' J).IC Comput(P+*Directed I, (s +*
       (Initialize Directed I)),k)
      .= (P+*(I ';' J)).IC Comput(P+*(I ';' J), s2,k)
       by A11,A14,FUNCT_4:14
      .= CurInstr(P+*(I ';' J),Comput(P+*(I ';' J),s2,k))
       by A3,PARTFUN1:def 8;
  end;
  Comput(P+*Directed I, (s +* (Initialize Directed I)),
  LifeSpan(P+*I,s1) + 1 )
  , Comput(P+*(I ';' J), s2,LifeSpan(P+*I,s1) + 1) equal_outside
A by A4,A6,A5,A7,Lm2,Th32;
  hence thesis by COMPOS_1:24,COMPOS_1:138;
end;

theorem Th43:
  for s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
  I,J being Program of SCM+FSA st I
  is_closed_on Initialized s,P & I is_halting_on Initialized s,P
   holds (for k being
  Element of NAT st k <= LifeSpan(P+*I,s +* Initialized I)
 holds IC Comput(P+*Directed I, s+* Initialized Directed I,k)
 = IC Comput(P+*(I ';' J), s +* Initialized (I ';' J),k) &
    CurInstr(P+*Directed I,Comput(P+*Directed I,
         s +* Initialized Directed I,k))
 = CurInstr(P+*(I ';' J),
        Comput(P+*(I ';' J),
        s +* Initialized (I ';' J),k)))
&
  DataPart Comput(P+*Directed I,
         s +* Initialized Directed I,
         LifeSpan(P+*I,s +* Initialized I) + 1)
  = DataPart Comput(P+*(I ';' J),
          s +* Initialized (I ';' J),
          LifeSpan(P+*I,s +* Initialized I) + 1)
&
 IC Comput(P+*Directed I,
           s +* Initialized Directed I,
           LifeSpan(P+*I,s +*Initialized I) + 1)
 = IC Comput(P+*(I ';' J),
           s +* Initialized (I ';' J),
           LifeSpan(P+*I,s +* Initialized I) + 1)
proof
  let s be State of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  let I,J be Program of SCM+FSA;
A1: ProgramPart Directed I = Directed I by RELAT_1:209;
A2: dom(P +* (I ';' J)) = NAT by PARTFUN1:def 4;
A3: dom(P +* Directed I) = NAT by PARTFUN1:def 4;
  assume
A4: I is_closed_on Initialized s,P;
  set s2 = s +* Initialized (I ';' J);
A5: s +* Initialized Directed I = Initialized s +* (Initialize Directed I) &
    s2 = Initialized s +* Initialize(I ';' J) by Th13;
A6: Directed I ';' J = I ';' J by Th41;
  set s1 = s +* Initialized I;
  assume
A7: I is_halting_on Initialized s,P;
  s1 = Initialized s +* (Initialize I) by Th13;
  then
A8: LifeSpan(P+*I,s1) + 1 = pseudo-LifeSpan(
Initialized s,P,Directed I) by A4,A7,Lm2;
A9: Directed I is_pseudo-closed_on Initialized s,P by A4,A7,Lm2;
  hereby
    let k be Element of NAT;
    assume k <= LifeSpan(P+*I,s1);
    then
A10: k < pseudo-LifeSpan(Initialized s,P,
Directed I) by A8,NAT_1:13;
    hence
A11: IC Comput(P+*Directed I, (s +* Initialized
Directed I),k) = IC
    Comput(P+*(I ';' J), s2,k) by A5,A6,A9,Th32,COMPOS_1:24;
    s +* Initialized Directed I = Initialized s +* (Initialize Directed I)
    by Th13;
    then
A12: IC Comput(P+*Directed I, (s +* Initialized
Directed I),k) in dom Directed I by A9,A10,Def5,A1;
A13: Directed I c= I ';' J by SCMFSA6A:55;
    then
 dom Directed I c= dom (I ';' J) by GRFUNC_1:8;
    then
A14: IC Comput(P+*Directed I, (s +* Initialized
Directed I),k) in dom (I ';' J) by A12;
    thus CurInstr(P+*Directed I,
     Comput(P+*Directed I, (s +* Initialized Directed I),k))
     = (P+*Directed I). IC Comput(P+*Directed I,
        (s +* Initialized Directed I),k) by A3,PARTFUN1:def 8
      .= (Directed I). IC Comput(P+*Directed I,
       (s +* Initialized Directed I),k) by A12,FUNCT_4:14
      .= (Directed I).IC Comput(P+*Directed I, (s
+* Initialized Directed I),k)
      .= (I ';' J).IC Comput(P+*Directed I, (s +*
Initialized Directed I),k) by A12,A13,GRFUNC_1:8
      .= (I ';' J).IC Comput(P+*Directed I,
       (s +* Initialized Directed
    I),k)
      .= (P+*(I ';' J)).IC Comput(P+*(I ';' J), s2,k) by A11,A14,FUNCT_4:14
      .= CurInstr(P+*(I ';' J),Comput(P+*(I ';' J),s2,k))
      by A2,PARTFUN1:def 8;
  end;
  Comput(P+*Directed I, (s +* Initialized
Directed I),LifeSpan(P+*I,s1) + 1),
  Comput(P+*(I ';' J), s2,LifeSpan(P+*I,s1) + 1) equal_outside A
by A4,A7,A5,A6,A8,Lm2,Th32;
  hence thesis by COMPOS_1:24,COMPOS_1:138;
end;

theorem Th44:
  for s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
  I being Program of SCM+FSA st I
  is_closed_on Initialized s,P & I is_halting_on Initialized s,P
   holds for k being
  Element of NAT st k <= LifeSpan(P+*I,s +* Initialized I) holds
     Comput(P+*I,s +* Initialized I,k),
     Comput(P+*Directed I, s +* Initialized Directed I,k) equal_outside NAT
&
  CurInstr(P+*Directed I,Comput(P+*Directed I,s +* Initialized Directed I,k))
   <> halt SCM+FSA
proof
  let s be State of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized Directed I;
A1: ProgramPart I = I by RELAT_1:209;
A2: dom(P+*Directed I) = NAT by PARTFUN1:def 4;
A3: dom(P+*I) = NAT by PARTFUN1:def 4;
A4: Directed I c= P+*Directed I by FUNCT_4:26;
  defpred P[Nat] means $1 <= LifeSpan(P+*I,s1) implies ( Comput(
P+*I,s1,
  $1), Comput(P+*Directed I,s2,$1) equal_outside A &
   CurInstr(P+*Directed I,Comput(P+*Directed I,s2,$1)) <> halt
  SCM+FSA);
A5: s1 = Initialized s +* (Initialize I) by Th13;
  assume
A6: I is_closed_on Initialized s,P;
A7: now
    let k be Element of NAT;
    dom Directed I = dom I by FUNCT_4:105;
    then
A8: IC Comput(P+*I,s1,k) in dom Directed I by A6,A5,SCMFSA7B:def 7,A1;
A9:  (P+*Directed I)/.IC Comput(P+*Directed I,s2,k)
 = (P+*Directed I).IC Comput(P+*Directed I,s2,k) by A2,PARTFUN1:def 8;
    assume
    Comput(P+*I,s1,k), Comput(P+*Directed I,s2,k) equal_outside A;
    then CurInstr(P+*Directed I,Comput(P+*Directed I,s2,k))
     = (P+*Directed I).IC Comput(P+*I,s1,k) by A9,COMPOS_1:24
      .= (Directed I).IC Comput(P+*I,s1,k) by A8,GRFUNC_1:8,A4;
    then
A10: CurInstr(P+*Directed I,Comput(P+*Directed I,s2
,k)) in rng Directed I
 by A8,FUNCT_1:def 5;
    assume
    CurInstr(P+*Directed I,Comput(P+*Directed I,s2
,k)) = halt SCM+FSA;
    hence contradiction by A10,SCMFSA6A:18;
  end;
  assume
A11: I is_halting_on Initialized s,P;
  now
A12: P+*I halts_on s1 by A11,A5,SCMFSA7B:def 8,A1;
A13: dom I c= dom Directed I by FUNCT_4:105;
    let k be Element of NAT;
    assume
A14: k <= LifeSpan(P+*I,s1) implies Comput(P+*I,s1,k),
Comput(P+*Directed I,s2,k)
    equal_outside A;
A15: Comput(P+*Directed I,s2,k+1) =
Following(P+*Directed I,Comput(P+*Directed I,s2,k)
)
by EXTPRO_1:4
      .= Exec(CurInstr(P+*Directed I,Comput(
P+*Directed I,s2,k)),
      Comput(P+*Directed I,s2,k));
A16: IC Comput(P+*I,s1,k) in dom I by A6,A5,SCMFSA7B:def 7,A1;
A17: I c= P+* I by FUNCT_4:26;
A18: CurInstr(P+*I,Comput(P+*I,s1,k))
     = (P+*I).IC Comput(P+*I,s1,k) by A3,PARTFUN1:def 8
    .= I.IC Comput(P+*I,s1,k) by A16,A17,GRFUNC_1:8;
A19: k + 0 < k + 1 by XREAL_1:8;
    assume
A20: k + 1 <= LifeSpan(P+*I,s1);
    then k < LifeSpan(P+*I,s1) by A19,XXREAL_0:2;
    then I.IC Comput(P+*I,s1,k) <> halt SCM+FSA by A18,A12,
EXTPRO_1:def 14;
    then
A21: CurInstr(P+*I,Comput(P+*I,
s1,k))
 = (Directed I).IC Comput(P+*I,s1,k) by A18,FUNCT_4:111
      .= (P+*Directed I).IC Comput(P+*I,s1,k) by A4
,A16,A13,GRFUNC_1:8
      .= (P+*Directed I).IC Comput(P+*Directed I,s2,k)
       by A14,A20,A19,COMPOS_1:24,XXREAL_0:2
      .= CurInstr(P+*Directed I,Comput(P+*Directed I,s2,k))
       by A2,PARTFUN1:def 8;
 Comput(P+*I,s1,k+1) =
Following(P+*I,Comput(P+*I,s1,k)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(P+*I,Comput(
P+*I,s1,k)),
      Comput(P+*I,s1,k));
    hence Comput(P+*I,s1,k+1), Comput(P+*Directed I,s2,k+1)
equal_outside A by A14,A20,A19,A21,A15,AMISTD_2:def 20,XXREAL_0:2;
    hence CurInstr(P+*Directed I,Comput(P+*Directed I,s2,k+1)) <>
    halt SCM+FSA
    by A7;
  end;
  then
A22: for k being Element of NAT st P[k] holds P[k + 1];
  now
    assume 0 <= LifeSpan(P+*I,s1);
A23: Comput(P+*I,s1,0) = s1 & Comput(P+*Directed I,s2,0) = s2 by
EXTPRO_1:3;
    hence Comput(P+*I,s1,0), Comput(P+*Directed I,s2,0)
equal_outside A by SCMFSA6A:53;
    thus CurInstr(P+*Directed I,Comput(P+*Directed I,s2,0))
     <> halt SCM+FSA by A7,A23,SCMFSA6A:53;
  end;
  then
A24: P[0];
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A24,A22);
end;

theorem Th45:
  for s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
  I being Program of SCM+FSA st I
is_closed_on Initialized s,P & I is_halting_on Initialized s,P
 holds IC Comput(P+*Directed I,
  (s +* Initialized Directed I), (LifeSpan(P+*I,s +*
Initialized I) + 1)) =
card I & DataPart Comput(P+*I, (s +* Initialized
I),LifeSpan(P+*I,s +* Initialized
  I)) = DataPart Comput(P+*Directed I, (s +*
Initialized Directed I), (LifeSpan(P+*I,s +*
  Initialized I) + 1))
proof
  let s be State of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized Directed I;
  set m1 = LifeSpan(P+*I,s1);
A1: ProgramPart I = I by RELAT_1:209;
A2: dom(P+*I) = NAT by PARTFUN1:def 4;
A3: dom(P+*Directed I) = NAT by PARTFUN1:def 4;
  assume
A4: I is_closed_on Initialized s,P;
  set l1 = IC Comput(P+*I, s1,m1);
A5: s1 = Initialized s +* (Initialize I) by Th13;
  then
A6: l1 in dom I by A4,SCMFSA7B:def 7,A1;
  assume
A7: I is_halting_on Initialized s,P;
  then IC Comput(P+*Directed I, s2,m1) in dom I by A4,A6,Th44,COMPOS_1:24;
  then
A8: IC Comput(P+*Directed I, s2,m1) in dom Directed I by FUNCT_4:105;
A9: P+*I halts_on s1 by A7,A5,SCMFSA7B:def 8,A1;
A10: I c= P+*I by FUNCT_4:26;
A11: I.l1 = (P+*I).l1 by A6,A10,GRFUNC_1:8
    .= CurInstr(P+*I,Comput(P+*I,s1,m1))
       by A2,PARTFUN1:def 8
    .= halt SCM+FSA by A9,EXTPRO_1:def 14;
  l1 = IC Comput(P+*Directed I, s2,m1) by A4,A7,Th44,COMPOS_1:24;
  then
A12: (P+*Directed I).l1 = (Directed I).l1 by A8,FUNCT_4:14
    .= (Directed I).l1
    .= goto  card I by A6,A11,FUNCT_4:112;
A13:  (P+*Directed I)/.IC Comput(P+*Directed I,s2,
m1)
 = (P+*Directed I).IC Comput(P+*Directed I,s2,m1) by
A3,PARTFUN1:def 8;
A14: CurInstr(P+*Directed I,Comput(P+*Directed I,
s2,m1))
 = (P+*Directed I).l1 by A4,A7,Th44,A13,COMPOS_1:24
    .= goto  card I by A12;
A15: Comput(P+*Directed I, s2,m1 + 1) =
Following(P+*Directed I,Comput(P+*Directed I,s2,
m1))
 by EXTPRO_1:4
    .= Exec(goto  card I, Comput(P+*Directed I, s2,m1)) by A14;
  hence IC Comput(P+*Directed I, s2,m1 + 1) =  card I by SCMFSA_2:95;
A16: ( for a being Int-Location holds Comput(P+*Directed I, s2,m1 + 1).a =
Comput(P+*Directed I, s2, m1).a)& for f being FinSeq-Location holds Comput(
P+*Directed I, s2,m1
  + 1).f = Comput(P+*Directed I, s2,m1).f by A15,SCMFSA_2:95;
  DataPart Comput(P+*I, s1,m1) = DataPart Comput(P+*Directed I,
s2,m1) by A4,A7,Th44,COMPOS_1:138;
  hence thesis by A16,SCMFSA6A:38;
end;

Lm3: for I being Program of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
s being State of SCM+FSA st I
is_closed_on s,P & I is_halting_on s,P
 holds IC Comput(P +* (I ';' Stop SCM+FSA),
   s +* (Initialize (I ';' Stop SCM+FSA)),
   LifeSpan(P+*I,s +* (Initialize I)) + 1) =  card I &
  DataPart Comput(P+*I, s +* (Initialize I),
         LifeSpan(P+*I,s +* (Initialize I))) =
   DataPart Comput(P +* (I ';' Stop SCM+FSA),
     s +* (Initialize (I ';' Stop SCM+FSA)),
     LifeSpan(P+*I,s +* (Initialize I)) + 1) &
  P +* (I ';' Stop SCM+FSA) halts_on
    s +* (Initialize (I ';' Stop SCM+FSA)) &
  LifeSpan(P +* (I ';' Stop SCM+FSA),s +*
       (Initialize (I ';' Stop SCM+FSA))) =
   LifeSpan(P+*I,s +* (Initialize I)) + 1 &
  I ';' Stop SCM+FSA is_closed_on s,P &
  I ';' Stop SCM+FSA is_halting_on s,P

proof
  let I be Program of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  let s be State of SCM+FSA;
  assume
A1: I is_closed_on s,P;
  card Stop SCM+FSA = 1 by COMPOS_1:46;
  then card (I ';' Stop SCM+FSA) = card I + 1 by SCMFSA6A:61;
  then card I < card (I ';' Stop SCM+FSA) by NAT_1:13;
  then
A2:  card I in dom (I ';' Stop SCM+FSA) by AFINSQ_1:70;

A3: 0 in dom Stop SCM+FSA by COMPOS_1:45;

  (0 + card I) in {m + card I: m in dom Stop SCM+FSA}
  by A3;
  then
A4:  (0 + card I) in dom Reloc(Stop SCM+FSA,card I ) by COMPOS_1:117;

  set s2 = s +* Initialize (I ';' Stop SCM+FSA);
  set s1 = s +* (Initialize I);
A5: 0 in dom Stop SCM+FSA by COMPOS_1:45;
A6: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
  assume
A7: I is_halting_on s,P;

  then
A8: IC Comput(P+*Directed I, (s +*
(Initialize Directed I)),
 (LifeSpan(P+*I,s1)
  + 1)) = IC Comput(P +* (I ';' Stop SCM+FSA), s2,LifeSpan(P+*I,s1) + 1) by
A1,Th42;
A9: (P +* (I ';' Stop SCM+FSA)). card I = (I ';' Stop SCM+FSA).card I
      by A2,FUNCT_4:14

    .= (I ';' Stop SCM+FSA). card I

    .= Reloc(Stop SCM+FSA,card I). (0 + card I) by A4,FUNCT_4:14

    .= IncAddr(halt SCM+FSA,card I) by A6,A5,COMPOS_1:122
    .= halt SCM+FSA by COMPOS_1:93;

  DataPart Comput(P+*Directed I, (s
+* (Initialize Directed I)),
  LifeSpan(P+*I,
  s1) + 1) = DataPart Comput(P +* (I ';' Stop SCM+FSA), s2,LifeSpan(P+*I,s1)
   +
1) by A1,A7,Th42
;

  hence IC Comput(P +* (I ';' Stop SCM+FSA),s2,LifeSpan(P+*I,s1) + 1) =  card
I
 &
 DataPart

Comput(P+*I, s1,LifeSpan(P+*I,s1)) = DataPart Comput(
P +* (I ';' Stop SCM+FSA), s2
,LifeSpan(P+*I,s1) + 1) by A1,A7,A8,Th36;

 dom(P +* (I ';' Stop SCM+FSA)) = NAT by PARTFUN1:def 4;
then
A10:  (P +* (I ';' Stop SCM+FSA))/.
IC Comput(P +* (I ';' Stop SCM+FSA),s2,LifeSpan(P+*I,s1)+1)
 = (P +* (I ';' Stop SCM+FSA)).IC Comput(P +* (I ';' Stop SCM+FSA),s2,
   LifeSpan(P+*I,s1)+1) by PARTFUN1:def 8;
A11: CurInstr(P +* (I ';' Stop SCM+FSA),
   Comput(P +* (I ';' Stop SCM+FSA),s2,LifeSpan(P+*I,s1)+1))
     = (P +* (I ';' Stop SCM+FSA)).card I by A1,A7,A8,Th36,A10

    .= halt SCM+FSA by A9;
  hence
A12: P +* (I ';' Stop SCM+FSA) halts_on s2 by EXTPRO_1:30;
A13: now
    let k be Element of NAT;
    assume
A14: k <= LifeSpan(P+*I,s1);

    then
    IC Comput(P+*I, s1,k) = IC Comput(P+*Directed I,
     (s +* (Initialize Directed I)),k) by A1,A7,Th35,COMPOS_1:24;

    then
A15: IC Comput(P +* (I ';' Stop SCM+FSA), s2,k) = IC Comput(P+*I, s1,k) by
A1,A7,A14,Th42;
A16: ProgramPart I = I by RELAT_1:209;
A17:  IC Comput(P+*I, s1,k) in dom I by A1,SCMFSA7B:def 7,A16;
    dom I c= dom (I ';' Stop SCM+FSA) by SCMFSA6A:56;

    hence IC Comput(P +* (I ';' Stop SCM+FSA), s2,k)
     in dom (I ';' Stop SCM+FSA) by A15,A17;
  end;

  defpred P[Nat] means (LifeSpan(P+*I,s1) < $1 implies IC Comput(
P +* (I ';' Stop SCM+FSA),s2,
  $1) =  card I) & IC Comput(P +* (I ';' Stop SCM+FSA),s2,$1)
   in dom (I ';' Stop SCM+FSA)
;

  card Stop SCM+FSA = 1 by COMPOS_1:46;
  then card (I ';' Stop SCM+FSA) = card I + 1 by SCMFSA6A:61;
  then
A18: card I + 0 < card (I ';' Stop SCM+FSA) by XREAL_1:8;
  then
A19:  card I in dom (I ';' Stop SCM+FSA) by AFINSQ_1:70;
A20: now
    let k be Element of NAT;
    assume
A21: P[k];
    per cases by XXREAL_0:1;
    suppose
      k < LifeSpan(P+*I,s1);
      then k + 1 <= LifeSpan(P+*I,s1) by NAT_1:13;
      hence P[k + 1] by A13;
    end;
    suppose
      k = LifeSpan(P+*I,s1);
      hence P[k + 1] by A1,A7,A8,A19,Th36;
    end;
    suppose
A22:  k > LifeSpan(P+*I,s1);
A23:  now
        assume k + 1 > LifeSpan(P+*I,s1);
  dom(P +* (I ';' Stop SCM+FSA)) = NAT by PARTFUN1:def 4;
  then
A24:  (P +* (I ';' Stop SCM+FSA))/.IC Comput(P +* (I ';' Stop SCM+FSA),s2,k)
 = (P +* (I ';' Stop SCM+FSA)).IC Comput(P +* (I ';' Stop SCM+FSA),s2,k)
         by PARTFUN1:def 8;
A25:    CurInstr(P +* (I ';' Stop SCM+FSA),
           Comput(P +* (I ';' Stop SCM+FSA),s2,k))
     = halt SCM+FSA by A9,A21,A22,A24;
        thus IC Comput(P +* (I ';' Stop SCM+FSA), s2,k + 1) =
        IC Following(P +* (I ';' Stop SCM+FSA),Comput(
P +* (I ';' Stop SCM+FSA),s2,k))
         by EXTPRO_1:4

          .=  card I by A21,A22,A25,EXTPRO_1:def 3;
      end;
      k + 1 > k + 0 by XREAL_1:8;
      hence P[k + 1] by A18,A22,A23,AFINSQ_1:70,XXREAL_0:2;
    end;
  end;
  now
    let k be Element of NAT;
    assume k < LifeSpan(P+*I,s1) + 1;
    then
A26: k <= LifeSpan(P+*I,s1) by NAT_1:13;

    then CurInstr(P+*Directed I,
    Comput(P+*Directed I,
     (s +* (Initialize Directed I)),k)) <> halt SCM+FSA by A1,A7,Th35;

    hence CurInstr(P +* (I ';' Stop SCM+FSA),
    Comput(P +* (I ';' Stop SCM+FSA),s2,k)) <>
     halt SCM+FSA by A1,A7,A26,Th42;
  end;

  then for k be Element of NAT st
  CurInstr(P +* (I ';' Stop SCM+FSA),Comput(P +* (I ';' Stop SCM+FSA),s2,k))
   = halt SCM+FSA
  holds LifeSpan(P+*I,s1) + 1 <= k;

  hence LifeSpan(P +* (I ';' Stop SCM+FSA),s2) = LifeSpan(P+*I,s1) + 1 by A11
,A12,EXTPRO_1:def 14;
A27: P[0] by A13,NAT_1:2;
A28: ProgramPart(I ';' Stop SCM+FSA) = I ';' Stop SCM+FSA by RELAT_1:209;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A27,A20);
  hence I ';' Stop SCM+FSA is_closed_on s,P by SCMFSA7B:def 7,A28;
  thus thesis by A12,SCMFSA7B:def 8,A28;
end;

theorem
  for I being Program of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
  s being State of SCM+FSA st I
is_closed_on s,P & I is_halting_on s,P
holds I ';' Stop SCM+FSA is_closed_on s,P & I
  ';' Stop SCM+FSA is_halting_on s,P by Lm3;

theorem
  for l being Element of NAT holds  0 in dom Goto
  l & (Goto l). 0 = goto l by Lm1;

Lm4: for I being Program of SCM+FSA, s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
 st I is_closed_on Initialized s,P & I is_halting_on Initialized s,P
 holds IC Comput(P +* (I ';' Stop SCM+FSA),
(s +* Initialized (I ';' Stop SCM+FSA)),
(LifeSpan(P+*I,s +* Initialized I) + 1)) =
 card I &
 DataPart Comput(P+*I, (s +* Initialized
I),LifeSpan(P+*I,s +*
Initialized I)) = DataPart Comput(P +* (I ';' Stop SCM+FSA),
(s +* Initialized (I ';' Stop SCM+FSA))
, (LifeSpan(P+*I,s +* Initialized I) + 1)) &
 P+* (I ';' Stop SCM+FSA)
   halts_on s +* Initialized (I ';' Stop SCM+FSA) &
 LifeSpan(P+*(I ';' Stop SCM+FSA),s +* Initialized(I ';' Stop SCM+FSA))
  = LifeSpan(P+*I,s +*Initialized I) + 1

proof
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  assume
A1: I is_closed_on Initialized s,P;
  card Stop SCM+FSA = 1 by COMPOS_1:46;
  then card (I ';' Stop SCM+FSA) = card I + 1 by SCMFSA6A:61;
  then card I < card (I ';' Stop SCM+FSA) by NAT_1:13;
  then
A2:  card I in dom (I ';' Stop SCM+FSA) by AFINSQ_1:70;

A3: 0 in dom Stop SCM+FSA by COMPOS_1:45;

  (0 + card I) in {m + card I: m in dom Stop SCM+FSA}
  by A3;
  then
A4:  (0 + card I) in dom Reloc(Stop SCM+FSA,card I ) by COMPOS_1:117;

  set s2 = s +* Initialized (I ';' Stop SCM+FSA);
  set s1 = s +* Initialized I;
  assume
A5: I is_halting_on Initialized s,P;

  then
A6: IC Comput(P+*Directed I, (s +* Initialized
Directed I),LifeSpan(P+*I,s1) + 1) = IC
  Comput(P +* (I ';' Stop SCM+FSA), s2,LifeSpan(P+*I,s1) + 1) by A1,Th43;

A7: 0 in dom Stop SCM+FSA by COMPOS_1:45;
A8: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
A9: (P +* (I ';' Stop SCM+FSA)). card I
     = (I ';' Stop SCM+FSA). card I by A2,FUNCT_4:14

    .= (I ';' Stop SCM+FSA). card I

    .= Reloc(Stop SCM+FSA,card I). (0 + card I) by A4,FUNCT_4:14

    .= IncAddr(halt SCM+FSA,card I) by A8,A7,COMPOS_1:122
    .= halt SCM+FSA by COMPOS_1:93;

  DataPart Comput(P+*Directed I, (s +*
Initialized Directed I),LifeSpan(P+*I,s1) + 1) =
  DataPart Comput(P +* (I ';' Stop SCM+FSA), s2,LifeSpan(P+*I,s1) + 1) by A1
,A5,Th43;

  hence IC Comput(P +* (I ';' Stop SCM+FSA),s2,LifeSpan(P+*I,s1) + 1) =  card
I & DataPart

Comput(P+*I, s1,LifeSpan(P+*I,s1)) = DataPart Comput(
P +* (I ';' Stop SCM+FSA), s2
,LifeSpan(P+*I,s1) + 1) by A1,A5,A6,Th45;
dom(P +* (I ';' Stop SCM+FSA)) = NAT by PARTFUN1:def 4;
then
A10:  (P +* (I ';' Stop SCM+FSA))/.
IC Comput(P +* (I ';' Stop SCM+FSA),s2,LifeSpan(P+*I,s1)+1)
 = (P +* (I ';' Stop SCM+FSA)).
IC Comput(P +* (I ';' Stop SCM+FSA),s2,LifeSpan(P+*I,s1)+1)
 by PARTFUN1:def 8;
A11: CurInstr(P +* (I ';' Stop SCM+FSA),
     Comput(P +* (I ';' Stop SCM+FSA),s2,LifeSpan(P+*I,s1)+1))
     = (P +* (I ';' Stop SCM+FSA)). card I by A1,A5,A6,Th45,A10

    .= halt SCM+FSA by A9;
  hence
A12: P +* (I ';' Stop SCM+FSA) halts_on s2 by EXTPRO_1:30;
  now
    let k be Element of NAT;
    assume k < LifeSpan(P+*I,s1) + 1;
    then
A13: k <= LifeSpan(P+*I,s1) by NAT_1:13;

    then CurInstr(P+*Directed I,
     Comput(P+*Directed I, (s +* Initialized
Directed I),k)) <> halt
    SCM+FSA by A1,A5,Th44;

    hence CurInstr(P +* (I ';' Stop SCM+FSA),
    Comput(P +* (I ';' Stop SCM+FSA),s2,k)) <>
     halt SCM+FSA by A1,A5,A13,Th43;
  end;
  then for k be Element of NAT st
   CurInstr(P +* (I ';' Stop SCM+FSA),
     Comput(P +* (I ';' Stop SCM+FSA),s2,k)) = halt SCM+FSA
  holds LifeSpan(P+*I,s1) + 1 <= k;

  hence thesis by A11,A12,EXTPRO_1:def 14;
end;

canceled 5;

theorem
  for I being Program of SCM+FSA, s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  st I
is_closed_on Initialized s,P & I is_halting_on Initialized s,P
holds IC Comput(P +* (I ';' Stop SCM+FSA),
(s +* Initialized (I ';' Stop SCM+FSA)),
  (LifeSpan(P+*I,s +* Initialized I) + 1)) = card I by Lm4;

theorem
  for I being Program of SCM+FSA, s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  st I
  is_closed_on Initialized s,P & I is_halting_on Initialized s,P
   holds DataPart Comput(P+*I, (s +* Initialized I),LifeSpan(P+*I,s
+* Initialized I)) = DataPart
  Comput(P +* (I ';' Stop SCM+FSA), (s +*
Initialized (I ';' Stop SCM+FSA)),
(LifeSpan(P+*I,s +* Initialized I) + 1)) by Lm4;

theorem
  for I being Program of SCM+FSA, s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  st I
is_closed_on Initialized s,P & I is_halting_on Initialized s,P
 holds P+*(I ';' Stop SCM+FSA)
  halts_on s +* Initialized(I ';' Stop SCM+FSA) by Lm4;

theorem
  for I being Program of SCM+FSA, s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  st I
  is_closed_on Initialized s,P & I is_halting_on Initialized s,P
   holds LifeSpan(P+*(I ';' Stop SCM+FSA),
   s +* Initialized (I ';' Stop SCM+FSA)) = LifeSpan(P+*I,
s +* Initialized I) + 1 by Lm4;

theorem
  for s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT,
  I being Program of SCM+FSA st I
is_closed_on Initialized s,P & I is_halting_on Initialized s,P
holds IExec(I ';' Stop SCM+FSA,P,s) = IExec(I,P,s) +* Start-At(card I,SCM+FSA)
proof
  let s be State of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  let I be Program of SCM+FSA;
  assume
A1: I is_closed_on Initialized s,P;
  set s2 = s +* Initialized (I ';' Stop SCM+FSA);
  set s1 = s +* Initialized I;
  assume
A2: I is_halting_on Initialized s,P;
A3: ProgramPart I = I by RELAT_1:209;
  s1 = Initialized s +* (Initialize I) by Th13;
  then
A4: P+*I halts_on s1 by A2,SCMFSA7B:def 8,A3;
  P +* (I ';' Stop SCM+FSA) halts_on s2 &
  LifeSpan(P +* (I ';' Stop SCM+FSA),s2) = LifeSpan(
P+*I,s1) + 1 by A1,A2,Lm4;
  then
A5: Result(P +* (I ';' Stop SCM+FSA),s2) =
Comput(P +* (I ';' Stop SCM+FSA), s2,LifeSpan(
P+*I,s1) + 1) by EXTPRO_1:23;
  then DataPart Result(P +* (I ';' Stop SCM+FSA),s2) = DataPart Comput(P+*I,
s1,LifeSpan(P+*I,s1))
by A1,A2,Lm4;
  then
A6: DataPart Result(P +* (I ';' Stop SCM+FSA),s2) = DataPart Result(P+*I,s1)
by A4,EXTPRO_1:23
    .= DataPart(Result(P+*I,s1) +* Start-At(card I,SCM+FSA)) by
Th10;
  IC Result(P +* (I ';' Stop SCM+FSA),s2) =  card I by A1,A2,A5,Lm4
    .= IC (Result(P+*I,s1) +* Start-At(card I,SCM+FSA)) by
FUNCT_4:121;
  then
A7: Result(P +* (I ';' Stop SCM+FSA),s2),
     Result(P+*I,s1) +* Start-At(card I,SCM+FSA) equal_outside A
 by A6,Th6;
  dom ProgramPart s = A by COMPOS_1:34;
  then
A8: Result(P +* (I ';' Stop SCM+FSA),s2) +* s|NAT = Result(P+*I,s1) +*
Start-At(card I,SCM+FSA)
 +* s|NAT by A7,FUNCT_7:108;
A9: dom(s|NAT) misses dom Start-At(card I,SCM+FSA) by COMPOS_1:130;
  thus IExec(I ';' Stop SCM+FSA,P,s)
   = Result(P +* (I ';' Stop SCM+FSA),s2) +* s|NAT by
             SCMFSA6B:def 1
    .= Result(P+*I,s1) +* (Start-At(card I,SCM+FSA) +* s|NAT) by A8
,FUNCT_4:15
    .= Result(P+*I,s1) +* (s|NAT +* Start-At(card I,SCM+FSA)) by A9
,FUNCT_4:36
    .= Result(P+*I,s1) +* s|NAT +* Start-At(card I,SCM+FSA) by
FUNCT_4:15
    .= IExec(I,P,s) +* Start-At(card I,SCM+FSA) by SCMFSA6B:def 1;
end;

Lm5: for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on s,P & I is_halting_on s,P holds
IC Comput(P +* (I ';' Goto (card J + 1) ';' J ';' Stop SCM+FSA),
    s +*
     Initialize (I ';' Goto (card J + 1) ';' J ';' Stop SCM+FSA),
     LifeSpan(P+*I,s +* (Initialize I)) + 2)
   = card I + card J + 1
 &
 DataPart Comput(P+*I,(s +* (Initialize I)),
     LifeSpan(P+*I,s +* (Initialize I)))
  = DataPart Comput(P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
       s +* Initialize (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
     LifeSpan(P+*I,s +* (Initialize I)) + 2) &
 (for k being Element of NAT st
 k < LifeSpan(P+*I,s +* (Initialize I)) + 2
 holds CurInstr(P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
   Comput(P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
    s +* Initialize (I ';' Goto(card J + 1) ';' J ';' Stop SCM+FSA),k))
       <> halt SCM+FSA) &
(for k being Element of NAT st
   k <= LifeSpan(P+*I,s +* (Initialize I))
 holds IC Comput(P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
  s +* Initialize (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),k)
   = IC Comput(P+*I, (s +* (Initialize I)),k)) &
 IC Comput(P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
  s +* Initialize (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
   (LifeSpan(P+*I,s +* (Initialize I)) + 1)) =  card I &
  P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA)
    halts_on s +* Initialize (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA)
    &
 LifeSpan(P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
    s +* Initialize (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA))
     = LifeSpan(P+*I,s +* (Initialize I)) + 2
proof
  let I,J be Program of SCM+FSA;
  let s be State of SCM+FSA;
  assume
A1: I is_closed_on s,P;

A2: card (Goto  (card J + 1) ';' J) = card Goto  (card J + 1) +
  card J by SCMFSA6A:61

    .= 1 + card J by Lm1;

A3: 0 in dom Stop SCM+FSA by COMPOS_1:45;
A4: card (Goto  (card J + 1) ';' J) = card Goto  (card J + 1) +
  card J by SCMFSA6A:61

    .= card J + 1 by Lm1;
A5:  (card I + card J + 1) =  ((card J + 1) + card I);
A6:  0 in dom Stop SCM+FSA by A3;
  set J2 = Goto  (card J + 1) ';' (J ';' Stop SCM+FSA);
  set s2 = s +* Initialize (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA);
  set P2 = P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA);

  set s1 = s +* (Initialize I);
  assume
A7: I is_halting_on s,P;

  dom Reloc(Stop SCM+FSA,card J + 1)
   = dom Reloc(Stop SCM+FSA,card J + 1)
  .= {m + (card J + 1): m in dom Stop SCM+FSA} by COMPOS_1:117;

  then
A8:  (0 + (card J + 1)) in dom Reloc(Stop SCM+FSA,card J + 1) by A6;

A9: dom Goto  (card J + 1) c= dom (Goto  (card J + 1) ';' J) by SCMFSA6A:56;

A10:  0 in dom Goto  (card J + 1) by Lm1;

A11: J2. 0 = (Goto  (card J + 1) ';' J ';' Stop SCM+FSA).
  0 by SCMFSA6A:67

    .= (Directed (Goto  (card J + 1) ';' J)). 0 by A10,A9,Th28
    .= (Goto  (card J + 1) ';' Directed J). 0 by SCMFSA6A:66
    .= (Directed Goto  (card J + 1)). 0 by A10,Th28
    .= (Goto  (card J + 1)). 0 by SCMFSA6A:63
    .= goto  (card J + 1) by Lm1;

A12: I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA = I ';' Goto
   (card J + 1) ';' (J ';' Stop SCM+FSA) by SCMFSA6A:67

    .= I ';' J2 by SCMFSA6A:67;

  then
A13: DataPart Comput(P +* Directed I,
  (s +* (Initialize Directed I)), LifeSpan(P+*I,s1) + 1)
   = DataPart Comput(P2, s2,
LifeSpan(P+*I,s1) + 1) by A1,A7,Th42;

A14: card J2 = card Goto  (card J + 1) + card (J ';' Stop SCM+FSA) by
SCMFSA6A:61

    .= 1 + card (J ';' Stop SCM+FSA) by Lm1;
  then
A15: 0 + 1 <= card J2 by NAT_1:11;
A16: card (I ';' J2) = card I + card J2 by SCMFSA6A:61;
  then card I + 0 < card (I ';' J2) by A15,XREAL_1:8;
  then
A17:  card I in dom (I ';' J2) by AFINSQ_1:70;

A18: card Stop SCM+FSA = 1 by COMPOS_1:46;
  card (I ';' J2) = card I + card (Goto  (card J + 1) ';' J ';'
  Stop SCM+FSA) by A16,SCMFSA6A:67

    .= card I + (card J + 1 + 1) by A4,A18,SCMFSA6A:61
    .= card I + card J + 1 + 1;
  then card I + card J + 1 < card (I ';' J2) by NAT_1:13;
  then
A19:  (card I + card J + 1) in dom (I ';' J2) by AFINSQ_1:70;
A20:  0 in dom J2 by A15,AFINSQ_1:70;
  then  (0 + card I) in {m + card I: m in dom J2};

  then (0 + card I) in dom Reloc(J2,card I) by COMPOS_1:117;
  then
A21:  (0 + card I) in dom Reloc(J2,card I);

A22: card Stop SCM+FSA = 1 by COMPOS_1:46;
A23: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
  card J2 = 1 + (card J + card Stop SCM+FSA) by A14,SCMFSA6A:61
    .= card J + (1 + card Stop SCM+FSA);
  then card J + 1 < card J2 by A22,XREAL_1:8;
  then  (card J + 1) in dom J2 by AFINSQ_1:70;
  then
A24:  (card J + 1) in dom J2;

A25: J2. (card J + 1) = (Goto  (card J + 1) ';' J ';' Stop
  SCM+FSA). (card J + 1) by SCMFSA6A:67

    .= (Reloc(Stop SCM+FSA,card J + 1)). (card J + 1) by A2,A8,FUNCT_4:14

    .= Reloc(Stop SCM+FSA,card J + 1). (0 + (card J + 1))

    .= IncAddr(halt SCM+FSA,card J + 1) by A6,A23,COMPOS_1:122
    .= halt SCM+FSA by COMPOS_1:93;

  dom Reloc(J2,card I)
  = dom Reloc(J2,card I)
 .= {m + card I: m in dom J2} by COMPOS_1:117;

  then
A26:  (card I + card J + 1) in dom Reloc(J2,card I )
  by A24,A5;

A27:  P2/.IC Comput(P2,s2,LifeSpan(P+*I,s1)+1)
 = P2.IC Comput(P2,s2,LifeSpan(P+*I,s1)+1) by PBOOLE:158;
A28: IC Comput(P+*Directed I, (s +* (Initialize Directed I)),
    (LifeSpan(P+*I,s1)+ 1))
  = IC Comput(P2, s2,LifeSpan(P+*I,s1) + 1) by A1
,A7,A12,Th42;
A29: CurInstr(P2,Comput(P2,s2,LifeSpan(P+*I,s1)+1))
     = P2.IC Comput(P2,s2,LifeSpan(P+*I,s1)+1) by A27
    .= P2.IC Comput(P+*Directed I, (s +* (Initialize Directed I)),
              (LifeSpan(P+*I,s1) + 1)) by A28
    .= P2. card I by A1,A7,Th36

    .= P2. card I
    .= (I ';' J2). card I by A12,A17,FUNCT_4:14
    .= (I ';' J2). card I
    .= (Reloc(J2,card I)). card I by A21,FUNCT_4:14
    .= Reloc(J2,card I). (0 + card I)
    .= IncAddr(goto  (card J + 1),card I) by A20,A11,COMPOS_1:122
    .= goto ( (card J + 1) + card I) by SCMFSA_4:14
    .= goto  (card I + card J + 1);
A30: now
    let f be FinSeq-Location;
    thus Comput(P2, s2,LifeSpan(P+*I,s1) + (1 + 1)).f
= Comput(P2, s2,LifeSpan(P+*I,s1) + 1 + 1).f

      .= (Following(P2,
      Comput(P2, s2,LifeSpan(P+*I,s1) + 1))).f
      by EXTPRO_1:4
      .= Comput(P2, s2,LifeSpan(P+*I,s1) + 1).f by A29
,SCMFSA_2:95;
  end;

A31:  P2/.IC Comput(P2,s2,LifeSpan(P+*I,s1)+2)
 = P2.IC Comput(P2,s2,LifeSpan(P+*I,s1)+2) by PBOOLE:158;
  thus IC Comput(P2, s2,LifeSpan(P+*I,s1) + 2) = IC
Comput(P2, s2,LifeSpan(P+*I,s1) + 1 + 1)

    .= IC Following(P2,
    Comput(P2, s2,LifeSpan(P+*I,s1) + 1)) by
EXTPRO_1:4
    .=  (card I + card J + 1) by A29,SCMFSA_2:95;

  then
A32: CurInstr(P2,Comput(P2,s2,LifeSpan(P+*I,s1)+2))
     = P2. (card I + card J + 1) by A31

    .= (I ';' J2). (card I + card J + 1) by A12,A19,FUNCT_4:14

    .= (I ';' J2). (card I + card J + 1)

    .= (Reloc(J2,card I)). (card I + card J + 1) by A26,
FUNCT_4:14

    .= Reloc(J2,card I). ((card J + 1) + card I)

    .= IncAddr(halt SCM+FSA,card I) by A24,A25,COMPOS_1:122
    .= halt SCM+FSA by COMPOS_1:93;
  now
    let a be Int-Location;
    thus Comput(P2, s2,LifeSpan(P+*I,s1) + (1 + 1)).a
= Comput(
P2, s2,LifeSpan(P+*I,s1) + 1 + 1).a

      .= (Following(P2,
      Comput(P2, s2,LifeSpan(P+*I,s1) + 1))).a by
EXTPRO_1:4
      .= Comput(P2, s2,LifeSpan(P+*I,s1) + 1).a by A29
,SCMFSA_2:95;
  end;

  then DataPart Comput(P2, s2,LifeSpan(P+*I,s1) + 1) =
DataPart Comput(
P2, s2,
  LifeSpan(P+*I,s1) + 2) by A30,SCMFSA6A:38;

  hence DataPart Comput(P+*I,s1,LifeSpan(P+*I,s1)) =
DataPart Comput(
P2, s2,
  LifeSpan(P+*I,s1) + 2) by A1,A7,A13,Th36;

  thus
A33: now
    let k be Element of NAT;
    assume
A34: k < LifeSpan(P+*I,s1) + 2;
    per cases;
    suppose
A35:  k <= LifeSpan(P+*I,s1);

      then CurInstr(P +* Directed I,
        Comput(P+* Directed I, (s +* (Initialize Directed I)),k))
      <> halt SCM+FSA by A1,A7,Th35;

      hence CurInstr(P2,Comput(P2,s2,k)) <>
       halt SCM+FSA by A1,A7,A12,A35,Th42;

    end;
    suppose
A36:  LifeSpan(P+*I,s1) < k;
      k < LifeSpan(P+*I,s1) + 1 + 1 by A34;
      then
A37:  k <= LifeSpan(P+*I,s1) + 1 by NAT_1:13;
      LifeSpan(P+*I,s1) + 1 <= k by A36,NAT_1:13;
      then LifeSpan(P+*I,s1) + 1 = k by A37,XXREAL_0:1;
      hence CurInstr(P2,Comput(P2,s2,k))
       <> halt SCM+FSA by A29;

    end;
  end;
  hereby
    let k be Element of NAT;
    assume
A38: k <= LifeSpan(P+*I,s1);

    then
    IC Comput(P+*I, s1,k) = IC Comput(P +* Directed I,
      (s +* (Initialize Directed I)),k) by A1,A7,Th35,COMPOS_1:24;

    hence IC Comput(P2, s2,k) = IC Comput(P+*I, s1,k)
by A1,A7,A12,A38,Th42;

  end;
  thus IC Comput(P2, s2,LifeSpan(P+*I,s1) + 1) =  card
I by A1,A7,A28,Th36;
  thus
A39: P2 halts_on s2 by A32,EXTPRO_1:30;

  for k be Element of NAT st
   CurInstr(P2,Comput(P2,s2,k)) = halt SCM+FSA
  holds LifeSpan(P+*I,s1) + 2 <= k by A33;

  hence thesis by A32,A39,EXTPRO_1:def 14;
end;

theorem
  for I,J being Program of SCM+FSA,s being State of SCM+FSA
   st I is_closed_on s,P & I is_halting_on s,P
   holds I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA is_closed_on s,P &
     I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA is_halting_on s,P
proof
  let I,J be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set IJ2 = I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA;
A1: ProgramPart IJ2 = IJ2 by RELAT_1:209;
A2: ProgramPart I = I by RELAT_1:209;
  assume
A3: I is_closed_on s,P;
  set s1 = s +* (Initialize I);
  set s2 = s +* Initialize (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA);
  set P2 = P +* IJ2;
  assume
A4: I is_halting_on s,P;
  then
A5: P2 halts_on s2 by A3,Lm5;
A6: LifeSpan(P2,s2) = LifeSpan(P+*I,s1) + 2 by A3,A4
,Lm5;
  now
    let k be Element of NAT;
    k <= LifeSpan(P+*I,s1) or k >= LifeSpan(P+*I,s1) + 1
by NAT_1:13;
    then k <= LifeSpan(P+*I,s1) or k = LifeSpan(P+*I,s1)
+ 1 or k > LifeSpan(P+*I,s1) + 1 by XXREAL_0:1;
    then
A7: k <= LifeSpan(P+*I,s1) or k = LifeSpan(P+*I,s1) + 1
or k >= LifeSpan(P+*I,s1) + 1 + 1 by NAT_1:13;
    card Stop SCM+FSA = 1 by COMPOS_1:46;
    then
A8: card IJ2 = card (I ';' Goto  (card J + 1) ';' J) + 1 by SCMFSA6A:61
      .= card (I ';' Goto  (card J + 1)) + card J + 1 by SCMFSA6A:61
      .= card I + card Goto  (card J + 1) + card J + 1 by SCMFSA6A:61
      .= card I + 1 + card J + 1 by Lm1
      .= card I + (card J + 1 + 1);
    0 <= card J + 1 by NAT_1:2;
    then 0 + 0 < card J + 1 + 1 by XREAL_1:10;
    then
A9: card I + 0 < card IJ2 by A8,XREAL_1:8;
    per cases by A7;
    suppose
A10:   k <= LifeSpan(P+*I,s1);
      reconsider n = IC Comput(P2, s2,k) as Element of NAT;
      IC Comput(P2, s2,k) = IC Comput(P+*I, s1,k) by A3,A4,A10,Lm5;
:::      then
:::  for k being Element of NAT holds
:::   IC Comput(P+*ProgramPart I,s +* (Initialize I),k)
:::         in dom I
:::                 by A1,SCMFSA7B:def 7;
      then IC Comput(P2, s2,k) in dom I by A3,SCMFSA7B:def 7,A2;
      then n < card I by AFINSQ_1:70;
      then n < card IJ2 by A9,XXREAL_0:2;
      hence IC Comput(P2, s2,k) in dom IJ2 by AFINSQ_1:70;
    end;
    suppose
      k = LifeSpan(P+*I,s1) + 1;
      then IC Comput(P2, s2,k) =  card I by A3,A4,Lm5;
      hence IC Comput(P2, s2,k) in dom IJ2 by A9,AFINSQ_1:70;
    end;
    suppose
A11:   k >= LifeSpan(P+*I,s1) + 2;
      card IJ2 = card I + card J + 1 + 1 by A8;
      then
A12:  card I + card J + 1 + 0 < card IJ2 by XREAL_1:8;
      k >= LifeSpan(P2,s2) by A3,A4,A11,Lm5;
      then IC Comput(P2, s2,k) = IC Comput(P2, s2,
LifeSpan(P2,s2)) by A5,Th5
        .=  (card I + card J + 1) by A3,A4,A6,Lm5;
      hence IC Comput(P2, s2,k) in dom IJ2 by A12,AFINSQ_1:70;
    end;
  end;
  hence IJ2 is_closed_on s,P by SCMFSA7B:def 7,A1;
  thus thesis by A5,SCMFSA7B:def 8,A1;
end;

theorem
  for I,J being Program of SCM+FSA, s being State of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  st I is_closed_on s,P & I is_halting_on s,P
   holds
    P+*(I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA)
   halts_on s +* Initialize (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA)
   by Lm5;

Lm6: for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on Initialized s,P & I is_halting_on Initialized s,P
 holds IC Comput(P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
    s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
      LifeSpan(P+*I,s +* Initialized I) + 2)
 =  (card I + card J + 1) &
DataPart
Comput(P+*I, (s +* Initialized I),LifeSpan(P +* I,s +*Initialized I))
 = DataPart
Comput(P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
 (s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop
SCM+FSA)),LifeSpan(P+*I,s +* Initialized I) + 2) & (
for k being Element of NAT st k
< LifeSpan(P+*I,s +* Initialized I) + 2
 holds CurInstr(P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
   Comput(P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
    (s +*
Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA)),k))
 <> halt
SCM+FSA) & (for k being Element of NAT
 st k <= LifeSpan(P +* I,s +* Initialized I)
holds IC Comput(P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
 (s +* Initialized (I ';' Goto  (card J + 1) ';' J
';' Stop SCM+FSA)),k) = IC Comput(P+*I, (s +* Initialized I),k)) &
 IC Comput(P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
    s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
    LifeSpan(P+*I,s +* Initialized I) + 1)
     = card I &
 P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA)
   halts_on
    s +* Initialized(I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA)
 & LifeSpan(P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA),
    s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA))
     = LifeSpan(P+*I,s +* Initialized I) + 2

proof
  let I,J be Program of SCM+FSA;
  let s be State of SCM+FSA;
  assume
A1: I is_closed_on Initialized s,P;

A2: card (Goto  (card J + 1) ';' J) = card Goto  (card J + 1) +
  card J by SCMFSA6A:61

    .= 1 + card J by Lm1;

A3: 0 in dom Stop SCM+FSA by COMPOS_1:45;
A4: card (Goto  (card J + 1) ';' J) = card Goto  (card J + 1) +
  card J by SCMFSA6A:61

    .= card J + 1 by Lm1;
A5:  (card I + card J + 1) =  ((card J + 1) + card I);
A6:  0 in dom Stop SCM+FSA by A3;
  set J2 = Goto  (card J + 1) ';' (J ';' Stop SCM+FSA);

  set s2 = s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA);
  set P2 = P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA);

  set s1 = s +* Initialized I;
  assume
A7: I is_halting_on Initialized s,P;

  dom Reloc(Stop SCM+FSA,card J + 1)
   = dom Reloc(Stop SCM+FSA,card J + 1)
  .= {m + (card J + 1):
  m in dom Stop SCM+FSA} by COMPOS_1:117;

  then
A8:  (0 + (card J + 1)) in dom Reloc(Stop SCM+FSA,
  card J + 1) by A6;

A9: dom Goto  (card J + 1) c= dom (Goto  (card J + 1) ';' J) by SCMFSA6A:56;

A10:  0 in dom Goto  (card J + 1) by Lm1;

A11: J2. 0 = (Goto  (card J + 1) ';' J ';' Stop SCM+FSA).
  0 by SCMFSA6A:67

    .= (Directed (Goto  (card J + 1) ';' J)). 0 by A10,A9,Th28
    .= (Goto  (card J + 1) ';' Directed J). 0 by SCMFSA6A:66
    .= (Directed Goto  (card J + 1)). 0 by A10,Th28
    .= (Goto  (card J + 1)). 0 by SCMFSA6A:63
    .= goto  (card J + 1) by Lm1;

A12: I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA = I ';' Goto
   (card J + 1) ';' (J ';' Stop SCM+FSA) by SCMFSA6A:67

    .= I ';' J2 by SCMFSA6A:67;

  then
A13: DataPart Comput(P+*Directed I, (s +*
Initialized Directed I),LifeSpan(P+*I,s1) + 1) =
  DataPart Comput(P2, s2,LifeSpan(P+*I,s1) + 1) by A1
,A7,Th43;

A14: card J2 = card Goto  (card J + 1) + card (J ';' Stop SCM+FSA) by
SCMFSA6A:61

    .= 1 + card (J ';' Stop SCM+FSA) by Lm1;
  then
A15: 0 + 1 <= card J2 by NAT_1:11;
A16: card (I ';' J2) = card I + card J2 by SCMFSA6A:61;
  then card I + 0 < card (I ';' J2) by A15,XREAL_1:8;
  then
A17:  card I in dom (I ';' J2) by AFINSQ_1:70;

A18: card Stop SCM+FSA = 1 by COMPOS_1:46;
  card (I ';' J2) = card I + card (Goto  (card J + 1) ';' J ';'
  Stop SCM+FSA) by A16,SCMFSA6A:67

    .= card I + (card J + 1 + 1) by A4,A18,SCMFSA6A:61
    .= card I + card J + 1 + 1;
  then card I + card J + 1 < card (I ';' J2) by NAT_1:13;
  then
A19:  (card I + card J + 1) in dom (I ';' J2) by AFINSQ_1:70;
A20:  0 in dom J2 by A15,AFINSQ_1:70;
  then  (0 + card I) in {m + card I: m in dom J2};

  then (0 + card I) in dom Reloc(J2,card I) by COMPOS_1:117;
  then
A21:  (0 + card I) in dom Reloc(J2,card I);

A22: card Stop SCM+FSA = 1 by COMPOS_1:46;
A23: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
  card J2 = 1 + (card J + card Stop SCM+FSA) by A14,SCMFSA6A:61
    .= card J + (1 + card Stop SCM+FSA);
  then card J + 1 < card J2 by A22,XREAL_1:8;
  then  (card J + 1) in dom J2 by AFINSQ_1:70;
  then
A24:  (card J + 1) in dom J2;

A25:  P2/.IC Comput(P2,s2,LifeSpan(P+*I,s1)+1)
 = P2.IC Comput(P2,s2,LifeSpan(P+*I,s1)+1) by PBOOLE:158;
A26: J2. (card J + 1) = (Goto  (card J + 1) ';' J ';' Stop
  SCM+FSA). (card J + 1) by SCMFSA6A:67

    .= (Reloc(Stop SCM+FSA,card J + 1)). (card J + 1)
  by A2,A8,FUNCT_4:14

    .= Reloc(Stop SCM+FSA,card J + 1). (0 + (card J + 1))

    .= IncAddr(halt SCM+FSA,card J + 1) by A6,A23,COMPOS_1:122
    .= halt SCM+FSA by COMPOS_1:93;

  dom Reloc(J2,card I)
   = dom Reloc(J2,card I)
  .= {m + card I: m in dom
  J2} by COMPOS_1:117;

  then
A27:  (card I + card J + 1) in dom Reloc(J2,card I )
  by A24,A5;

A28: IC Comput(P+*Directed I, (s +* Initialized
Directed I),LifeSpan(P+*I,s1) + 1) = IC
  Comput(P2, s2,LifeSpan(P+*I,s1) + 1) by A1,A7,A12
,Th43;

  then
A29: CurInstr(P2,Comput(P2,s2,LifeSpan(P+*I,s1)+1))
 = P2. card I by A1,A7,Th45,A25

    .= P2. card I
    .= (I ';' J2). card I by A12,A17,FUNCT_4:14
    .= (I ';' J2). card I
    .= (Reloc(J2,card I)). card I by A21,FUNCT_4:14
    .= Reloc(J2,card I). (0 + card I)
    .= IncAddr(goto  (card J + 1),card I) by A20,A11,COMPOS_1:122
    .= goto ( (card J + 1) + card I) by SCMFSA_4:14
    .= goto  (card I + card J + 1);
A30: now
    let f be FinSeq-Location;
    thus Comput(P2, s2,LifeSpan(P+*I,s1) + (1 + 1)).f
= Comput(
P2, s2,LifeSpan(P+*I,
    s1) + 1 + 1).f

      .= (Following(P2,
      Comput(P2, s2,LifeSpan(P+*I,s1) + 1))).f by
EXTPRO_1:4
      .= Comput(P2, s2,LifeSpan(P+*I,s1) + 1).f by A29
,SCMFSA_2:95;
  end;

A31:  P2/.IC Comput(P2,s2,LifeSpan(P+*I,s1)+2)
 = P2.IC Comput(P2,s2,LifeSpan(P+*I,s1)+2) by PBOOLE:158;
  thus IC Comput(P2, s2,LifeSpan(P+*I,s1) + 2)
     = IC Comput(P2, s2,LifeSpan(P+*I,s1) + 1 + 1)

    .= IC Following(P2,Comput(P2, s2,LifeSpan(P+*I,s1) + 1)) by EXTPRO_1:4
    .=  (card I + card J + 1) by A29,SCMFSA_2:95;

  then
A32: CurInstr(P2,Comput(P2,s2,LifeSpan(P+*I,s1)+2))
 = P2. (card I + card J+ 1) by A31

    .= (I ';' J2). (card I + card J + 1)
    by A12,A19,FUNCT_4:14

    .= (I ';' J2). (card I + card J + 1)

    .= (Reloc(J2,card I)). (card I + card J + 1) by A27,
FUNCT_4:14

    .= Reloc(J2,card I). ((card J + 1) + card I)

    .= IncAddr(halt SCM+FSA,card I) by A24,A26,COMPOS_1:122
    .= halt SCM+FSA by COMPOS_1:93;
  now
    let a be Int-Location;
    thus Comput(P2, s2,LifeSpan(P+*I,s1) + (1 + 1)).a
= Comput(
P2, s2,LifeSpan(P+*I,
    s1) + 1 + 1).a

      .= (Following(P2,
      Comput(P2, s2,LifeSpan(P+*I,s1) + 1))).a by
EXTPRO_1:4
      .= Comput(P2, s2,LifeSpan(P+*I,s1) + 1).a by A29
,SCMFSA_2:95;
  end;

  then DataPart Comput(P2, s2,LifeSpan(P+*I,s1) + 1) =
DataPart Comput(
P2, s2,
  LifeSpan(P+*I,s1) + 2) by A30,SCMFSA6A:38;

  hence DataPart Comput(P+*I,s1,LifeSpan(P+*I,s1)) =
DataPart Comput(
P2, s2,
  LifeSpan(P+*I,s1) + 2) by A1,A7,A13,Th45;

  thus
A33: now
    let k be Element of NAT;
    assume
A34: k < LifeSpan(P+*I,s1) + 2;
    per cases;
    suppose
A35:  k <= LifeSpan(P+*I,s1);

      then CurInstr(P +* Directed I,
       Comput(P+*Directed I, (s +* Initialized
Directed I),k))
       <> halt
      SCM+FSA by A1,A7,Th44;

      hence CurInstr(P2,Comput(P2,s2,k)) <>
       halt SCM+FSA by A1,A7,A12,A35,Th43;

    end;
    suppose
A36:  LifeSpan(P+*I,s1) < k;
      k < LifeSpan(P+*I,s1) + 1 + 1 by A34;
      then
A37:  k <= LifeSpan(P+*I,s1) + 1 by NAT_1:13;
      LifeSpan(P+*I,s1) + 1 <= k by A36,NAT_1:13;
      then LifeSpan(P+*I,s1) + 1 = k by A37,XXREAL_0:1;
      hence CurInstr(P2,Comput(P2,s2,k)) <>
       halt SCM+FSA by A29;

    end;
  end;
  hereby
    let k be Element of NAT;
    assume
A38: k <= LifeSpan(P+*I,s1);

    then
    IC Comput(P+*I, s1,k) = IC Comput(P +* Directed I,
     (s +* Initialized Directed I)
    ,k) by A1,A7,Th44,COMPOS_1:24;

    hence IC Comput(P2, s2,k) = IC Comput(P+*I, s1,k)
by A1,A7,A12,A38,Th43;

  end;
  thus IC Comput(P2, s2,LifeSpan(P+*I,s1) + 1) =  card
I by A1,A7,A28,Th45;
  thus
A39: P2 halts_on s2 by A32,EXTPRO_1:30;

  for k be Element of NAT
   st CurInstr(P2,Comput(P2,s2,k))
   = halt SCM+FSA
  holds LifeSpan(P+*I,s1) + 2 <= k by A33;

  hence thesis by A32,A39,EXTPRO_1:def 14;
end;

theorem
  for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on Initialized s,P & I is_halting_on Initialized s,P
 holds P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA)
   halts_on s +* Initialized
  (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA) by Lm6;

theorem
  for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
  is_closed_on Initialized s,P & I is_halting_on Initialized s,P
  holds IC IExec(I ';'
Goto  (card J + 1) ';' J ';' Stop SCM+FSA,P,s) =  (card I + card J +
  1)
proof
  let I,J be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s2 = s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA);
  set P2 = P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA);
  assume
A1: I is_closed_on Initialized s,P & I is_halting_on Initialized s,P;
  then P2 halts_on s2 & LifeSpan(P2,s2)
   = LifeSpan(P+*I,s +* Initialized I) + 2 by Lm6;
  then
  IC Result(P2,s2) =
   IC Comput(P2, s2,LifeSpan(P+*I,s +* Initialized I) +2) by EXTPRO_1:23
    .=  (card I + card J + 1) by A1,Lm6;
  hence thesis by Th7;
end;

theorem
  for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on Initialized s,P & I is_halting_on Initialized s,P
holds IExec(I ';' Goto
 (card J + 1) ';' J ';' Stop SCM+FSA,P,s) = IExec(I,P,s) +*
 Start-At(( card I + card J + 1),SCM+FSA)
proof
  let I,J be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s1 = s +* Initialized I;
  set s2 = s +* Initialized (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA);
  set P2 = P +* (I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA);
  assume that
A1: I is_closed_on Initialized s,P and
A2: I is_halting_on Initialized s,P;
A3: ProgramPart I = I by RELAT_1:209;
  s1 = Initialized s +* (Initialize I) by Th13;
  then
A4: P+*I halts_on s1 by A2,SCMFSA7B:def 8,A3;
  P2 halts_on s2 & LifeSpan(P2,s2) = LifeSpan(
P+*I,s1) + 2 by A1,A2,Lm6;
  then
A5: Result(P2,s2) = Comput(P2, s2,LifeSpan(
P+*I,s1) + 2) by EXTPRO_1:23;
  then DataPart Result(P2,s2) = DataPart Comput(P+*I,
s1,LifeSpan(P+*I,s1))
by A1,A2,Lm6;
  then
A6: DataPart Result(P2,s2) = DataPart Result(P+*I,s1)
by A4,EXTPRO_1:23
    .= DataPart(Result(P+*I,s1) +* Start-At((card I+card J +1),
SCM+FSA))
     by Th10;
  IC Result(P2,s2) =  (card I + card J + 1) by A1,A2,A5,Lm6
    .= IC (Result(P+*I,s1) +* Start-At((card I+card J +1),SCM+FSA))
     by FUNCT_4:121;
  then
A7: Result(P2,s2),Result(P+*I,s1) +* Start-At((card I+
card J +1),SCM+FSA)
  equal_outside A by A6,Th6;
  dom ProgramPart s = NAT by COMPOS_1:34;
  then
A8: Result(P2,s2) +* s|NAT = Result(P+*I,s1) +*
Start-At((card I + card J + 1
  ),SCM+FSA) +* s|NAT by A7,FUNCT_7:108;
A9: dom(s|NAT) misses dom Start-At((card I+card J +1),SCM+FSA)
      by COMPOS_1:130;

  thus IExec(I ';' Goto  (card J + 1) ';' J ';' Stop SCM+FSA,P,s)
   = Result(P2,
  s2) +* s|NAT by SCMFSA6B:def 1
    .= Result(P+*I,s1) +* (Start-At((card I+card J +1),SCM+FSA) +* s|NAT)
     by A8,FUNCT_4:15
    .= Result(P+*I,s1) +* (s|NAT +* Start-At((card I+card J +1),
SCM+FSA))
     by A9,FUNCT_4:36
    .= Result(P+*I,s1) +* s|NAT +* Start-At((card I+card J +1),
SCM+FSA) by FUNCT_4:15
    .= IExec(I,P,s) +* Start-At((card I+card J +1),SCM+FSA)
     by SCMFSA6B:def 1;
end;

