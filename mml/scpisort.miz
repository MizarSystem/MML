:: Insert Sort on SCMPDS
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SCMPDS_2, SUBSET_1, FINSEQ_1, FSM_1, XXREAL_0, FUNCT_1,
      SCMP_GCD, ARYTM_3, GRAPH_2, NAT_1, RELAT_1, CLASSES1, AMI_2,
      AMI_1, SCMFSA6B, SCMPDS_4, UNIALG_2, SCMFSA7B, TURING_1, SCMFSA_7, INT_1,
      CARD_1, SCMPDS_7, AMI_3, ARYTM_1, VALUED_1, TARSKI, FUNCT_4, CIRCUIT2,
      GRAPHSP, MSUALG_1, XBOOLE_0, SCMISORT, SCMFSA_9, SCMFSA8B, COMPLEX1,
      SCPISORT, ORDINAL1, SCMNORM, SCMFSA6C, COMPOS_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, RELAT_1, FUNCT_1,
      PARTFUN1, VALUED_1, XCMPLX_0, FUNCT_4, INT_1, NAT_1, COMPLEX1,
      MEMSTR_0, EXTPRO_1, COMPOS_1, AMI_2, SCMPDS_2, SCMPDS_4, SCMPDS_5,
      SCMPDS_6, SCMP_GCD, DOMAIN_1, FINSEQ_1, SCMPDS_7, SCMPDS_8, GRAPH_2,
      CLASSES1, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, INT_2, SCM_1, SCMPDS_4, SCMPDS_5,
      SCMPDS_6, SCMP_GCD, SCMPDS_7, SCMPDS_8, CLASSES1, PRE_POLY, GRAPH_2,
      AMI_2, MEMSTR_0, RELSET_1;
 registrations SETFAM_1, RELAT_1, FUNCT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, MEMBERED, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMPDS_7,
      SCMPDS_8, XBOOLE_0, VALUED_0, ORDINAL1, CARD_1, VALUED_1, GRFUNC_1,
      COMPOS_1, AFINSQ_1, EXTPRO_1, FUNCT_4, MEMSTR_0, RELSET_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions SCMPDS_2, SCMP_GCD, AMI_3, COMPOS_1, EXTPRO_1, MEMSTR_0;
 theorems AMI_3, NAT_1, TARSKI, FUNCT_4, INT_1, SCMPDS_2, GRFUNC_1, SCMPDS_4,
      SCMPDS_5, SCMPDS_6, ENUMSET1, SCMP_GCD, SCMPDS_7, SCMPDS_8, ABSVALUE,
      FINSEQ_1, FINSEQ_2, RFINSEQ, XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0,
      GRAPH_2, ZFMISC_1, FINSEQ_3, CLASSES1, AFINSQ_1, COMPOS_1, EXTPRO_1,
      PBOOLE, MEMSTR_0;
 schemes NAT_1, FINSEQ_1;

begin :: Preliminaries

reserve x for Int_position,
  n,p0 for Element of NAT;

definition
  let f be FinSequence of INT,s be State of SCMPDS,m be Element of NAT;
  pred f is_FinSequence_on s,m means
  :Def1:
  for i be Element of NAT st 1 <= i
  & i <= len f holds f.i=s.intpos(m+i);
end;

theorem Th2:
  for s being State of SCMPDS,n,m be Element of NAT holds ex f be
  FinSequence of INT st len f=n & for i be Element of NAT st 1<=i & i <= len f
  holds f.i=s.intpos(m+i)
proof
  let s be State of SCMPDS,n,m be Element of NAT;
  deffunc U(Nat) = s.intpos (m+$1);
  consider f being FinSequence such that
A1: len f = n & for i be Nat st i in dom f holds f.i=U(i) from FINSEQ_1:
  sch 2;
  now
    let i be Nat;
    reconsider a = i as Element of NAT by ORDINAL1:def 12;
    assume
    i in dom f;
    then f.i = s.intpos (m+a) by A1;
    hence f.i in INT by INT_1:def 2;
  end;
  then reconsider f as FinSequence of INT by FINSEQ_2:12;
  take f;
  thus len f=n by A1;
  hereby
    let i be Element of NAT;
    assume
    1<=i & i <= len f;
    then i in dom f by FINSEQ_3:25;
    hence f.i = s.intpos (m+i) by A1;
  end;
end;

theorem
  for s being State of SCMPDS,n,m be Element of NAT holds ex f be
  FinSequence of INT st len f=n & f is_FinSequence_on s,m
proof
  let s be State of SCMPDS,n,m be Element of NAT;
  consider f be FinSequence of INT such that
A1: len f=n and
A2: for i be Element of NAT st 1<=i & i <= len f holds f.i=s.intpos(m+i)
  by Th2;
  take f;
  thus len f=n by A1;
  thus thesis by A2,Def1;
end;

theorem Th4:
  for f,g be FinSequence of INT,m,n be Element of NAT st 1<=n & n
  <= len f & 1<=m & m <= len f & len f=len g & f.m=g.n & f.n=g.m & (for k be
  Element of NAT st k<>m & k<>n & 1<=k & k <= len f holds f.k=g.k) holds f,g
  are_fiberwise_equipotent
proof
  let f,g be FinSequence of INT,m,n be Element of NAT;
  assume that
A1: 1<=n & n <= len f and
A2: 1<=m & m <= len f and
A3: len f=len g and
A4: f.m=g.n & f.n=g.m and
A5: for k be Element of NAT st k<>m & k<>n & 1<=k & k <= len f holds f.k
  =g.k;
A6: m in Seg (len f) by A2,FINSEQ_1:1;
A7: Seg (len f) = dom f by FINSEQ_1:def 3;
A8: now
    let k be set;
    assume that
A9: k<>m & k<>n and
A10: k in dom f;
    reconsider i=k as Element of NAT by A10;
    1 <= i & i <= len f by A7,A10,FINSEQ_1:1;
    hence f.k=g.k by A5,A9;
  end;
  n in dom f & dom f=dom g by A1,A3,A7,FINSEQ_1:1,def 3;
  hence thesis by A4,A7,A6,A8,RFINSEQ:28;
end;
set A = NAT, D = SCM-Data-Loc;

theorem Th5: ::see SCMPDS_8:2
  for s1,s2 being State of SCMPDS st (for a being Int_position
  holds s1.a = s2.a) holds Initialize (s1)=Initialize (s2)
proof
  let s1,s2 be State of SCMPDS;
  assume
  for a being Int_position holds s1.a = s2.a;
  then DataPart s1 = DataPart s2 by SCMPDS_4:8;
  hence thesis by MEMSTR_0:80;
end;

reserve P,Q,U,V for Instruction-Sequence of SCMPDS;

theorem Th6: :: see SCMPDS_7:50
  for s being State of SCMPDS, I being halt-free Program of
SCMPDS, j being parahalting shiftable Instruction of SCMPDS
 st I is_closed_on s,P
& I is_halting_on s,P holds (I ';' j) is_closed_on s,P
 & (I ';' j) is_halting_on s,P
proof
  let s be State of SCMPDS,I be halt-free Program of SCMPDS,j be parahalting
  shiftable Instruction of SCMPDS;
  set Mj = Load j;
A1: Mj is_closed_on IExec(I,P,Initialize s),P &
Mj is_halting_on IExec(I,P,Initialize s),P
 by SCMPDS_6:20,21;
  assume
  I is_closed_on s,P & I is_halting_on s,P;
  then (I ';' Mj) is_closed_on s,P & (I ';' Mj) is_halting_on s,P
   by A1,SCMPDS_7:24;
  hence thesis by SCMPDS_4:def 3;
end;

theorem :: see SCMPDS_7:49
  for s being 0-started State of SCMPDS, I being halt-free Program of SCMPDS, J
  being shiftable parahalting Program of SCMPDS,a be Int_position st I
is_closed_on s,P & I is_halting_on s,P holds IExec(I ';' J,P,s).a
 = IExec(J,P,Initialize IExec(I,P,s)).a
proof
 let s be 0-started State of SCMPDS,I be halt-free Program of SCMPDS,
      J be shiftable parahalting Program of SCMPDS,a be Int_position;
  J is_closed_on IExec(I,P,s),P & J is_halting_on IExec(I,P,s),P
    by SCMPDS_6:20,21;
 hence thesis by SCMPDS_7:30;
end;

theorem :: see SCMPDS_7:49
  for s being 0-started State of SCMPDS, I being halt-free parahalting Program
  of SCMPDS , J being shiftable Program of SCMPDS,a be Int_position
   st J is_closed_on IExec(I,P,s),P & J is_halting_on IExec(I,P,s),P
 holds IExec(I ';' J,P,s).a = IExec(J,P,Initialize IExec(I,P,s)).a
proof
  let s be 0-started State of SCMPDS,
      I be halt-free parahalting Program of SCMPDS, J
  be shiftable Program of SCMPDS,a be Int_position;
  I is_closed_on s,P & I is_halting_on s,P by SCMPDS_6:20,21;
  hence thesis by SCMPDS_7:30;
end;

theorem :: SCMPDS_7:43
  for s being State of SCMPDS, I being Program of SCMPDS,J being
shiftable parahalting Program of SCMPDS st I is_closed_on s,P
 & I is_halting_on s,P
  holds I ';' J is_closed_on s,P & I ';' J is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be shiftable parahalting
  Program of SCMPDS;
A1: J is_closed_on IExec(I,P,Initialize s),P &
J is_halting_on IExec(I,P,Initialize s),P
 by SCMPDS_6:20,21;
  assume
  I is_closed_on s,P & I is_halting_on s,P;
  hence thesis by A1,SCMPDS_7:24;
end;

theorem :: SCMPDS_7:43
  for s being State of SCMPDS, I being parahalting Program of SCMPDS,J
  being shiftable Program of SCMPDS st
  J is_closed_on IExec(I,P,Initialize s),P & J
is_halting_on IExec(I,P,Initialize s),P holds I ';' J is_closed_on s,P
 & I ';' J is_halting_on s,P
proof
  let s be State of SCMPDS,I be parahalting Program of SCMPDS,J be shiftable
  Program of SCMPDS;
A1: I is_closed_on s,P & I is_halting_on s,P by SCMPDS_6:20,21;
  assume
  J is_closed_on IExec(I,P,Initialize s),P &
  J is_halting_on IExec(I,P,Initialize s),P;
  hence thesis by A1,SCMPDS_7:24;
end;

theorem :: SCMPDS_7:43
  for s being State of SCMPDS, I being Program of SCMPDS, j being
  parahalting shiftable Instruction of SCMPDS st I is_closed_on s,P & I
  is_halting_on s,P holds I ';' j is_closed_on s,P & I ';' j is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS,j be shiftable parahalting
  Instruction of SCMPDS;
A1: Load j is_closed_on IExec(I,P,Initialize s),P &
Load j is_halting_on IExec(I,P,Initialize s),P
by SCMPDS_6:20,21;
  assume
  I is_closed_on s,P & I is_halting_on s,P;
  then I ';' Load j is_closed_on s,P & I ';' Load j is_halting_on s,P by A1,
SCMPDS_7:24;
  hence thesis by SCMPDS_4:def 3;
end;

Lm2: for a be Int_position,i be Integer,n be Element of NAT, I be Program of
SCMPDS holds card stop for-down(a,i,n,I)= card I+4

proof

  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;

  thus card stop for-down(a,i,n,I)= card for-down(a,i,n,I) +1 by COMPOS_1:55
    .= card I +3+1 by SCMPDS_7:41
    .= card I + 4;
end;

Lm3: for a be Int_position,i be Integer,n be Element of NAT, I be Program of
SCMPDS holds for-down(a,i,n,I)= ((a,i)<=0_goto (card I +3)) ';' (I ';' AddTo(a,
i,-n) ';' goto -(card I+2))

proof

  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;

  set i1=(a,i)<=0_goto (card I +3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
  thus for-down(a,i,n,I) = i1 ';' I ';' i2 ';' i3 by SCMPDS_7:def 2
    .= i1 ';' (I ';' i2 ';' i3) by SCMPDS_7:2;
end;

Lm4: for I being Program of SCMPDS,a being Int_position,i being Integer, n be
Element of NAT holds Shift(I ';' AddTo(a,i,-n),1) c= for-down(a,i,n,I)

proof

  let I be Program of SCMPDS,a be Int_position,i be Integer, n be Element of
  NAT;

  set i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
A1: for-down(a,i,n,I) = i1 ';' I ';' i2 ';' i3 by SCMPDS_7:def 2
    .= i1 ';' (I ';' i2) ';' i3 by SCMPDS_4:15
    .= Load i1 ';' (I ';' i2) ';' i3 by SCMPDS_4:def 2
    .= Load i1 ';' (I ';' i2) ';' Load i3 by SCMPDS_4:def 3;
  card Load i1=1 by COMPOS_1:54;
  hence thesis by A1,SCMPDS_7:3;
end;

begin :: Computing the Execution Result(,) For-loop Program by Loop-Invariant

scheme
  ForDownHalt { P[set],
  s() -> 0-started State of SCMPDS,
  P() -> Instruction-Sequence of SCMPDS,
  I() -> halt-free shiftable
Program of SCMPDS, a() -> Int_position,i() -> Integer,n() -> Element of NAT}:
for-down(a(),i(),n(),I()) is_closed_on s(), P()
 & for-down(a(),i(),n(),I()) is_halting_on s(), P()
provided
A1: n() > 0 and
A2: P[s()] and
A3: for t be 0-started State of SCMPDS,Q
  st P[t] & t.a()=s().a() & t.DataLoc(s().a(),i()) > 0
 holds IExec(I() ';' AddTo(a(),i(),-n()),Q,t).a()=t.a()
 & IExec(I() ';' AddTo(a(),i(),-n()),Q,t).DataLoc(s().a(),i())
 =t.DataLoc(s().a(),i())-n()
& I() is_closed_on t,Q & I() is_halting_on t,Q
 & P[Initialize (IExec(I() ';' AddTo(a(),i(),-n()),Q,t))]
proof
  set i1=(a(),i())<=0_goto (card I()+3), J=I() ';' AddTo(a(),i(),-n()), i3=
  goto -(card I()+2);
  set b=DataLoc(s().a(),i());
  set FOR=for-down(a(),i(),n(),I()), pFOR=stop FOR,
  pJ= stop J;
  defpred Q[Nat] means
   for t be 0-started State of SCMPDS,Q st t.b <= $1 & P[t] & t.a()=s().a()
    holds FOR is_closed_on t,Q & FOR is_halting_on t,Q;
A4: for k be Element of NAT st Q[k] holds Q[k + 1]
  proof
    let k be Element of NAT;
    assume
A5: Q[k];
    now
      let t be 0-started State of SCMPDS;
      let Q;
T:   Initialize t = t by MEMSTR_0:44;
      assume
A6:   t.b <= k+1;
      assume
A7:   P[t];
      assume
A8:   t.a()=s().a();
      per cases;
      suppose
        t.b <= 0;
        hence FOR is_closed_on t,Q & FOR is_halting_on t,Q by A8,SCMPDS_7:44;
      end;
      suppose
A9:     t.b > 0;
A13:     0 in dom pFOR by COMPOS_1:36;
        -(-n()) > 0 by A1;
        then -n() < 0;
        then -n() <= -1 by INT_1:8;
        then
A14:    -n()+t.b <= -1+t.b by XREAL_1:6;
        t.b-1 <= k by A6,XREAL_1:20;
        then
A15:    -n()+t.b <= k by A14,XXREAL_0:2;
        set Q2 = Q +* pJ, Q3 = Q +* pFOR, t4 = Comput(Q3,t,1), Q4 = Q3,
        Jt = IExec(J,Q,t);
A18:    pJ c= Q2 by FUNCT_4:25;
A19:    FOR = i1 ';' (J ';' i3) by Lm3;
A20:    Comput(Q3,t,0+1) = Following(Q3,Comput(Q3,t,0)) by EXTPRO_1:3
          .= Following(Q3,t) by EXTPRO_1:2
          .= Exec(i1,t) by A19,T,SCMPDS_6:11;
        for x holds t.x = t4.x by A20,SCMPDS_2:56;
        then
A22:    DataPart t = DataPart t4 by SCMPDS_4:8;
A23:    Jt.b=t.b-n() by A3,A7,A8,A9;
A24:    Jt.a()=t.a() by A3,A7,A8,A9;
        set m2=LifeSpan(Q2,t), t5=Comput(Q4,t4,m2), Q5 = Q4,
l1= (card J + 1);
A25:    card J = card I()+1 by SCMP_GCD:4;
A28:    t.DataLoc(t.a(),i())= t.b by A8;
A29:    IC t = 0 by T,MEMSTR_0:47;
A30:    I() is_closed_on t,Q & I() is_halting_on t,Q by A3,A7,A8,A9;
        then
A31:    J is_closed_on t,Q by Th6;
        then
A32:    J is_closed_on t,Q2 by T,SCMPDS_6:24;
        card I() + 2 < card I() + 3 by XREAL_1:6;
        then
A33:    l1 in dom FOR by A25,SCMPDS_7:42;
        set m3=m2 +1;
        set t6=Comput(Q3,t,m3), Q6 = Q3;
A34:    t6=t5 by EXTPRO_1:4;
A36:    J is_halting_on t,Q by A30,Th6;
        then
A37:    Q2 halts_on t by T,SCMPDS_6:def 3;
        Q2 = Q2+*pJ by FUNCT_4:25,98;
        then Q2+*pJ halts_on t by A36,T,SCMPDS_6:def 3;
        then
A38:    J is_halting_on t,Q2 by T,SCMPDS_6:def 3;
        set m4=m3+1, t7=Comput(Q3,t,m4), Q7 = Q3;
A40:    pFOR c= Q3 by FUNCT_4:25;
XX:     FOR c= pFOR by AFINSQ_1:74;
        then
YY:     FOR c= Q3 by A40,XBOOLE_1:1;
        Shift(J,1) c= FOR by Lm4;
        then Shift(J,1) c= pFOR by XX,XBOOLE_1:1;
        then
A41:    Shift(J,1) c= Q4 by A40,XBOOLE_1:1;
A42:    IC t4 = succ IC t by A9,A20,A28,SCMPDS_2:56
          .= (0+1) by A29;
        then
A43:    DataPart Comput(Q2,t,m2) = DataPart t5 by A18,A38,A32,A22,A41,
SCMPDS_7:18;
        then
A44:    DataPart t5 = DataPart(Result(Q2,t)) by A37,EXTPRO_1:23
          .= DataPart Jt by SCMPDS_4:def 5;
A45:    IC t5=l1 by A18,A38,A32,A42,A22,A41,SCMPDS_7:18;
        then
A46:    CurInstr(Q6,t6) =Q4.l1 by A34,PBOOLE:143
          .=FOR.l1 by A33,YY,GRFUNC_1:2
          .=i3 by A25,SCMPDS_7:43;
A47:    t7 = Following(Q3,t6) by EXTPRO_1:3
          .= Exec(i3,t6) by A46;
        IC t7 =ICplusConst(t6,0-(card I()+2)) by A47,SCMPDS_2:54
          .= 0 by A25,A45,A34,SCMPDS_7:1;
        then
B49:    Initialize t7 = t7 by MEMSTR_0:46;
        InsCode i3=0 by SCMPDS_2:12;
        then InsCode i3 in {0,4,5,6} by ENUMSET1:def 2;
        then t7 =Initialize (t6) by A47,B49,SCMPDS_8:3
          .=Initialize (Jt) by A44,A34,MEMSTR_0:80;
        then
A48:    P[t7] by A3,A7,A8,A9;
A49:    Q7 +* pFOR= Q7 by FUNCT_4:25,98;
        t5.b=Comput(Q2,t,m2).b by A43,SCMPDS_4:8
          .=(Result(Q2,t)).b by A37,EXTPRO_1:23
          .=t.b - n() by A23,SCMPDS_4:def 5;
        then
A50:    t7.b=-n()+t.b by A34,A47,SCMPDS_2:54;
        t5.a()=Comput(Q2,t,m2).a() by A43,SCMPDS_4:8
          .=(Result(Q2,t)).a() by A37,EXTPRO_1:23
          .=s().a() by A8,A24,SCMPDS_4:def 5;
        then
A51:    t7.a()=s().a() by A34,A47,SCMPDS_2:54;
        then
A52:    FOR is_closed_on t7,Q7 by A5,A48,A50,A15,B49;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m4;
            then
A53:        k <= m3 by INT_1:7;
            hereby
              per cases by A53,NAT_1:8;
              suppose
A54:            k <= m2;
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(Q3,t,k) in dom pFOR by A13,A29,EXTPRO_1:2;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A55:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 12;
                    reconsider lm = IC Comput(Q2,t,kn) as Element
of NAT;
                    kn < k by A55,XREAL_1:29;
                    then kn < m2 by A54,XXREAL_0:2;
                    then IC Comput(Q2,t,kn) + 1 = IC Comput(
Q4,t4,kn) by A18,A38,A32,A42,A22,A41,SCMPDS_7:16;
                    then
A57:                IC Comput(Q3,t,k) = (lm+1) by A55,EXTPRO_1:4;
                    IC Comput(Q2,t,kn) in dom pJ by A31,T,SCMPDS_6:def 2;
                    then lm < card pJ by AFINSQ_1:66;
                    then lm < card J+1 by COMPOS_1:55;
                    then
A58:                lm+1 <= card J +1 by INT_1:7;
                    card I() + 2 < card I() + 4 by XREAL_1:6;
                    then lm+1 < card I() +4 by A25,A58,XXREAL_0:2;
                    then lm+1 < card pFOR by Lm2;
                    hence IC Comput(Q3,t,k) in dom pFOR by A57,AFINSQ_1:66;
                  end;
              end;
              suppose
A59:            k=m3;
                l1 in dom pFOR by A33,COMPOS_1:62;
                hence
                IC Comput(Q3,t,k) in dom pFOR by A18,A38,A32,A42,A22,A41,A34
,A59,SCMPDS_7:18;
              end;
            end;
          end;
          suppose
            k >= m4;
            then consider nn be Nat such that
A60:        k=m4+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 12;
            Comput(Q3,t,k)
        = Comput(Q3,Comput(Q3,t,m4),nn) by A60,EXTPRO_1:4
       .= Comput(Q7+*pFOR,t7,nn) by FUNCT_4:25,98;
            hence IC Comput(Q3,t,k) in dom pFOR by A52,B49,SCMPDS_6:def 2;
          end;
        end;
        hence FOR is_closed_on t,Q by T,SCMPDS_6:def 2;
        FOR is_halting_on t7,Q7 by A5,A51,A48,A50,A15,B49;
        then Q7 halts_on t7 by A49,B49,SCMPDS_6:def 3;
        then Q3 halts_on t by EXTPRO_1:22;
        hence FOR is_halting_on t,Q by T,SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
A61: Q[0] by SCMPDS_7:44;
A62: for k being Element of NAT holds Q[k] from NAT_1:sch 1(A61,A4);
  per cases;
  suppose
    s().b <= 0;
    hence thesis by SCMPDS_7:44;
  end;
  suppose
    s().b > 0;
    then reconsider m=s().b as Element of NAT by INT_1:3;
    Q[m] by A62;
    hence thesis by A2;
  end;
end;

scheme
  ForDownExec { P[set], s() -> 0-started State of SCMPDS,
  P() -> Instruction-Sequence of SCMPDS,
  I() -> halt-free shiftable
Program of SCMPDS, a() -> Int_position,i() -> Integer,n() -> Element of NAT}:
 IExec(for-down(a(),i(),n(),I()),P(),s())
 = IExec(for-down(a(),i(),n(),I()),P(),
     Initialize IExec(I() ';' AddTo(a(),i(),-n()),P(), s()))
provided
A1: n() > 0 and
A2: s().DataLoc(s().a(),i()) > 0 and
A3: P[s()] and
A4: for t be 0-started State of SCMPDS,Q
 st P[t] & t.a()=s().a() & t.DataLoc(s().a(),i()) > 0
 holds IExec(I() ';' AddTo(a(),i(),-n()),Q,t).a()=t.a() &
IExec(I
() ';' AddTo(a(),i(),-n()),Q,t).DataLoc(s().a(),i())
 =t.DataLoc(s().a(),i())-n()
& I() is_closed_on t,Q & I() is_halting_on t,Q
 & P[Initialize IExec(I() ';' AddTo(a(),i(),-n()),Q,t)]
proof
  set i1=(a(),i())<=0_goto (card I()+3), J=I() ';' AddTo(a(),i(),-n()), i3=
  goto -(card I()+2);
  set FOR=for-down(a(),i(),n(),I()), pFOR = stop FOR, P1 = P() +* pFOR;
  set PJ = P() +* stop J, mJ=LifeSpan(PJ,s()),
  m1=mJ+2, s2=Initialize IExec(J,P(),s()), m2= LifeSpan(P1,s2);
A8: stop J c= PJ by FUNCT_4:25;
I: Initialize s() = s() by MEMSTR_0:44;
A9: I() is_closed_on s(), P() & I() is_halting_on s(), P() by A2,A3,A4;
  then J is_closed_on s(), P() by Th6;
  then
A10: J is_closed_on s(),PJ by I,SCMPDS_6:24;
A11: J is_halting_on s(), P() by A9,Th6;
  then
A12: PJ halts_on s() by I,SCMPDS_6:def 3;
  PJ = PJ+*stop J by FUNCT_4:25,98;
  then PJ+*stop J halts_on Initialize s() by A11,SCMPDS_6:def 3;
  then
A14: J is_halting_on s(),PJ by SCMPDS_6:def 3;
A15: FOR = i1 ';' (J ';' i3) by Lm3;
A16: Comput(P1,s(),0+1) = Following(P1,
Comput(P1,s(),0)) by EXTPRO_1:3
    .= Following(P1,s()) by EXTPRO_1:2
    .= Exec(i1,s()) by A15,I,SCMPDS_6:11;
  set m3=mJ +1;
  set s4 = Comput(P1,s(),1), P4 = P1;
  set b=DataLoc(s().a(),i());
A17: card J = card I()+1 by SCMP_GCD:4;
  set s6=Comput(P1,s(),m3), P6 = P1;
  set s5=Comput(P4,s4,mJ), l1= (card J + 1), P5 = P4;
  card I() + 2 < card I() + 3 by XREAL_1:6;
  then
A20: l1 in dom FOR by A17,SCMPDS_7:42;
A21: s6=s5 by EXTPRO_1:4;
  for x holds s().x = s4.x by A16,SCMPDS_2:56;
  then
A23: DataPart s() = DataPart s4 by SCMPDS_4:8;
A24: IC s() = 0 by MEMSTR_0:def 9;
A25: pFOR c= P1 by FUNCT_4:25;
XX: FOR c= pFOR by AFINSQ_1:74;
   then
YY: FOR c= P1 by A25,XBOOLE_1:1;
  Shift(J,1) c= FOR by Lm4;
  then Shift(J,1) c= pFOR by XX,XBOOLE_1:1;
  then
A26: Shift(J,1) c= P4 by A25,XBOOLE_1:1;
  set m0=LifeSpan(P1,s());
  set m4=m3+1, s7=Comput(P1,s(),m4);
A30: IC s4 = succ IC s() by A2,A16,SCMPDS_2:56
    .= (0+1) by A24;
  then
A31: IC s5=l1 by A8,A14,A10,A23,A26,SCMPDS_7:18;
  then
A32: CurInstr(P6,s6) =P4.l1 by A21,PBOOLE:143
    .=FOR.l1 by A20,YY,GRFUNC_1:2
    .=i3 by A17,SCMPDS_7:43;
A33: s7 = Following(P1,s6) by EXTPRO_1:3
    .= Exec(i3,s6) by A32;
A34: DataPart Comput(PJ,s(),mJ) = DataPart s5 by A8,A14,A10,A30,A23,A26,
SCMPDS_7:18;
  now
    let x be Int_position;
    not x in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
    then
A35: s2.x=IExec(J,P(),s()).x by FUNCT_4:11;
    s5.x=Comput(PJ,s(),mJ).x by A34,SCMPDS_4:8
      .=(Result(PJ,s())).x by A12,EXTPRO_1:23
      .=IExec(J,P(),s()).x by SCMPDS_4:def 5;
    hence s7.x=s2.x by A21,A33,A35,SCMPDS_2:54;
  end;
  then
A37: DataPart s7 = DataPart s2 by SCMPDS_4:8;
A38: for t be 0-started State of SCMPDS,Q
 st P[t] & t.a()=s().a() & t.DataLoc(s().
  a(),i()) > 0 holds
   IExec(I() ';' AddTo(a(),i(),-n()),Q,t).a()=t.a() &
   IExec(I()
';' AddTo(a(),i(),-n()),Q,t).DataLoc(s().a(),i())
 =t.DataLoc(s().a(),i())-n() & I
() is_closed_on t,Q & I() is_halting_on t,Q
 & P[Initialize (IExec(I() ';' AddTo(a(),i(),-n()),Q,t))] by A4;
A39: P[s()] by A3;
  for-down(a(),i(),n(),I()) is_closed_on s(), P() &
  for-down(a(),i(),n(),I()) is_halting_on s(), P()
   from ForDownHalt(A1,A39,A38);
  then
A40: P1 halts_on s() by I,SCMPDS_6:def 3;
  set Es=IExec(J,P(),s()), bj=DataLoc((Initialize Es).a(),i());
  (Initialize Es).a() = Es.a() by SCMPDS_5:15
       .=s().a() by A2,A3,A4;
  then
A41: for t be 0-started State of SCMPDS,Q
  st P[t] & t.a()=(Initialize Es).a() & t.DataLoc((Initialize Es).a(),i()) > 0
 holds IExec(I() ';' AddTo(a(),i(),-n()),Q,t).a()=t.a()
 & IExec(I() ';' AddTo(a(),i(),-n()),Q,t).DataLoc((Initialize Es).a(),i())
 =t.DataLoc((Initialize Es).a(),i())-n()
& I() is_closed_on t,Q & I() is_halting_on t,Q
 & P[Initialize (IExec(I() ';' AddTo(a(),i
(),-n()),Q,t))] by A4;
A42: P[Initialize  Es] by A2,A3,A4;
  FOR is_closed_on Initialize Es,P() &
   FOR is_halting_on Initialize Es,P() from ForDownHalt(A1,A42,A41);
  then
A43: P1 halts_on Initialize s2 by SCMPDS_6:def 3;
  IC s7 =ICplusConst(s6,0-(card I()+2)) by A33,SCMPDS_2:54
    .= 0 by A17,A31,A21,SCMPDS_7:1;
  then
A44: IC s2 =IC Comput(P1,s(),m1) by MEMSTR_0:47;
A48: Comput(P1,s(),m1)=s2 by A37,A44,MEMSTR_0:78;
  then CurInstr(P1,Comput(P1,s(),m1))=i1
   by A15,SCMPDS_6:11;
  then m0 > m1 by A40,EXTPRO_1:36,SCMPDS_6:17;
  then consider nn be Nat such that
A49: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 12;
  Comput(P1,s(),m1+m2) = Comput(P1,s2,m2) by A48,EXTPRO_1:4;
  then CurInstr(P1,Comput(P1,s(),m1+m2))
   = halt SCMPDS by A43,EXTPRO_1:def 15;
  then m1 + m2 >= m0 by A40,EXTPRO_1:def 15;
  then
A51: m2 >= nn by A49,XREAL_1:6;
A52: Comput(P1,s(),m0) = Comput(P1,s2,nn) by A48,A49,EXTPRO_1:4;
  then CurInstr(P1,Comput(P1,s2,nn))
   =halt SCMPDS by A40,EXTPRO_1:def 15;
  then nn >= m2 by A43,EXTPRO_1:def 15;
  then nn=m2 by A51,XXREAL_0:1;
  then Result(P1,s()) = Comput(P1,s2,m2) by A40,A52,EXTPRO_1:23;
  hence IExec(FOR,P(),s()) = Comput(P1,s2,m2) by SCMPDS_4:def 5
    .= Result(P1,s2) by A43,EXTPRO_1:23
    .= IExec(FOR,P(),Initialize IExec(J,P(),s())) by SCMPDS_4:def 5;
end;

scheme
  ForDownEnd { P[set], s() -> 0-started State of SCMPDS,
    I() -> halt-free shiftable Program of SCMPDS,
  P() -> Instruction-Sequence of SCMPDS,
a() -> Int_position,i() -> Integer,n() -> Element of NAT}:
 IExec(for-down(a(),i(),n(),I()),P(),s()).DataLoc(s().a(),i(
  )) <= 0 & P[Initialize  IExec(for-down(a(),i(),n(),I()),P(),s())]
provided
A1: n() > 0 and
A2: P[s()] and
A3: for t be 0-started State of SCMPDS st P[t] &
 t.a()=s().a() & t.DataLoc(s().a(),i()) > 0 holds
 IExec(I() ';' AddTo(a(),i(),-n()),Q,t).a()=t.a() & IExec(I
() ';' AddTo(a(),i(),-n()),Q,t).DataLoc(s().a(),i())
 =t.DataLoc(s().a(),i())-n()
& I() is_closed_on t,Q & I() is_halting_on t,Q
 & P[Initialize (IExec(I() ';' AddTo(a(),i(),-n()),Q,t))]
proof
  set b=DataLoc(s().a(),i()), FR=for-down(a(),i(),n(),I());
  defpred Q[Nat] means
   for t be 0-started State of SCMPDS,Q st t.b <= $1 & t.a()=s().a() &
  P[t] holds IExec(FR,Q,t).b <= 0 & P[Initialize IExec(FR,Q,t)];
A4: Q[0 qua Nat]
  proof
    let t be 0-started State of SCMPDS, Q;
    assume that
A5: t.b <= 0 & t.a()=s().a() and
A6: P[t];
T:   Initialize t = t by MEMSTR_0:44;
    hence IExec(FR,Q,t).b <= 0 by A5,SCMPDS_7:47;
    for x be Int_position holds IExec(FR,Q,t).x = t.x
     by A5,T,SCMPDS_7:47;
    hence thesis by A6,Th5,T;
  end;
A7: now
    let k be Element of NAT;
    assume
A8: Q[k];
    thus Q[k+1]
    proof
      let u be 0-started State of SCMPDS;
      let U;
      assume that
A9:   u.b <= k+1 and
A10:  u.a()=s().a() and
A11:  P[u];
      per cases;
      suppose
      u.b <= 0;
        hence IExec(FR,U,u).b <= 0 &
        P[Initialize IExec(FR,U,u)] by A4,A10,A11;
      end;
      suppose
A12:    u.b > 0;
        set Ad=AddTo(a(),i(),-n());
        set Iu=IExec(I() ';' Ad,U,u);
A13:    Iu.a()=s().a() & P[Initialize  Iu] by A3,A10,A11,A12;
        Iu.b=u.b-n() by A3,A10,A11,A12;
        then Iu.b+1 <= u.b by A1,INT_1:7,XREAL_1:44;
        then Iu.b+1 <= k+1 by A9,XXREAL_0:2;
        then
A14:    Iu.b <= k by XREAL_1:6;
A15:    P[u] by A11;
A16:    for t being 0-started State of SCMPDS,Q
 st P[t] & t.a()=u.a() & t.DataLoc(u.a(),i()) > 0
  holds IExec(I() ';' Ad,Q,t).a()=t.a() &
IExec(I() ';' Ad,Q,t).DataLoc(u.a(),i()) =t.DataLoc(u.a(),i())-n()
 & I() is_closed_on t,Q & I()
        is_halting_on t,Q &
        P[Initialize (IExec(I() ';' Ad,Q,t))] by A3,A10;
A17:    u.DataLoc(u.a(),i()) > 0 by A10,A12;
X1: (Initialize Iu).b = Iu.b by SCMPDS_5:15;
X2: (Initialize Iu).a() = Iu.a() by SCMPDS_5:15;
       IExec(FR,U,u) = IExec(FR,U,Initialize Iu)
           from ForDownExec(A1,A17,A15,A16);
        hence IExec(FR,U,u).b <= 0 &
        P[Initialize IExec(FR,U,u)] by A8,A14,A13,X1,X2;
      end;
    end;
  end;
A18: for k being Element of NAT holds Q[k] from NAT_1:sch 1(A4,A7);
  per cases;
  suppose
    s().b > 0;
    then reconsider m=s().b as Element of NAT by INT_1:3;
    Q[m] by A18;
    hence thesis by A2;
  end;
  suppose
    s().b <= 0;
    hence thesis by A2,A4;
  end;
end;

theorem Th12:
  for s being 0-started State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a,x,y be Int_position, i,c be Integer,n be Element of NAT st
n > 0 & s.x >= s.y +c &
 for t be 0-started State of SCMPDS,Q st t.x >= t.y +c & t.a=s.a & t
  .DataLoc(s.a,i) > 0 holds
   IExec(I ';' AddTo(a,i,-n),Q,t).a=t.a & IExec(I ';'
  AddTo(a,i,-n),Q,t).DataLoc(s.a,i)=t.DataLoc(s.a,i)-n
   & I is_closed_on t,Q & I
is_halting_on t,Q
 & IExec(I ';' AddTo(a,i,-n),Q,t).x >=IExec(I ';' AddTo(a,i,-n),Q,t).y+c
  holds for-down(a,i,n,I) is_closed_on s,P &
        for-down(a,i,n,I) is_halting_on s,P
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, a,x,y
  be Int_position, i,c be Integer,n be Element of NAT;
  set b=DataLoc(s.a,i), J=I ';' AddTo(a,i,-n);
  assume
A1: n > 0;
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.x >= t.y+c;
  assume
A2: s.x >= s.y +c;
A3: P[s] by A2;
  assume
A4: for t be 0-started State of SCMPDS,Q
   st t.x >= t.y +c & t.a=s.a & t.b > 0 holds
   IExec(J,Q,t).a=t.a & IExec(J,Q,t).b=t.b-n &
I is_closed_on t,Q
 & I is_halting_on t,Q &
  IExec(J,Q,t).x>=IExec(J,Q,t).y+c;
A5: now
    let t be 0-started State of SCMPDS, Q;
    assume that
A6: P[t] and
A7: t.a=s.a & t.b > 0;
    consider v be State of SCMPDS such that
A8: v= t and
A9: v.x>=v.y+c by A6;
    thus IExec(J,Q,t).a=t.a & IExec(J,Q,t).b=t.b-n &
    I is_closed_on t,Q & I
    is_halting_on t,Q by A4,A7,A8,A9;
    thus P[Initialize IExec(J,Q,t)]
    proof
      take v=Initialize  IExec(J,Q,t);
      thus v=Initialize  IExec(J,Q,t);
      v.x=IExec(J,Q,t).x by SCMPDS_5:15;
      then v.x>=IExec(J,Q,t).y+c by A4,A7,A8,A9;
      hence thesis by SCMPDS_5:15;
    end;
  end;
  for-down(a,i,n,I) is_closed_on s,P &
  for-down(a,i,n,I) is_halting_on s,P
   from ForDownHalt(A1,A3,A5);
  hence thesis;
end;

theorem Th13:
  for s being 0-started State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a,x,y be Int_position, i,c be Integer,n be Element of NAT st
n > 0 & s.x >= s.y +c & s.DataLoc(s.a,i) > 0 &
for t be 0-started State of SCMPDS,Q st t.x
>= t.y +c & t.a=s.a & t.DataLoc(s.a,i) > 0
 holds IExec(I ';' AddTo(a,i,-n),Q,t).a
  =t.a & IExec(I ';' AddTo(a,i,-n),Q,t).DataLoc(s.a,i)
  =t.DataLoc(s.a,i)-n & I
  is_closed_on t,Q & I is_halting_on t,Q
   & IExec(I ';' AddTo(a,i,-n),Q,t).x>=IExec(I
';' AddTo(a,i,-n),Q,t).y+c
holds IExec(for-down(a,i,n,I),P,s) = IExec(for-down(a,i,
  n,I),P,Initialize IExec(I ';' AddTo(a,i,-n),P,s))
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, a,x,y
  be Int_position, i,c be Integer,n be Element of NAT;
  set b=DataLoc(s.a,i), J=I ';' AddTo(a,i,-n);
  assume
A1: n > 0;
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.x>=t.y+c;
  assume
A2: s.x >= s.y +c;
A3: P[s] by A2;
  assume
A4: s.b > 0;
  assume
A5: for t be 0-started State of SCMPDS,Q
    st t.x >= t.y +c & t.a=s.a & t.b > 0 holds
IExec(J,Q,t).a=t.a & IExec(J,Q,t).b=t.b-n &
 I is_closed_on t,Q & I is_halting_on t,Q & IExec(J,Q,t).x>=IExec(J,Q,t).y+c;
A6: now
    let t be 0-started State of SCMPDS, Q;
    assume that
A7: P[t] and
A8: t.a=s.a & t.b > 0;
    consider v be State of SCMPDS such that
A9: v= t and
A10: v.x>=v.y+c by A7;
    thus IExec(J,Q,t).a=t.a & IExec(J,Q,t).b=t.b-n &
    I is_closed_on t,Q & I is_halting_on t,Q by A5,A8,A9,A10;
    thus P[Initialize IExec(J,Q,t) ]
    proof
      take v=Initialize IExec(J,Q,t);
      thus v=Initialize IExec(J,Q,t);
      v.x=IExec(J,Q,t).x by SCMPDS_5:15;
      then v.x>=IExec(J,Q,t).y+c by A5,A8,A9,A10;
      hence thesis by SCMPDS_5:15;
    end;
  end;
  IExec(for-down(a,i,n,I),P,s)
   = IExec(for-down(a,i,n,I),P,
        Initialize IExec(I ';' AddTo(a,i,-n),P,s))
    from ForDownExec(A1,A4,A3,A6);
  hence thesis;
end;

theorem
  for s being 0-started State of SCMPDS,I being halt-free shiftable Program of
SCMPDS , a be Int_position, i be Integer,n be Element of NAT
 st s.DataLoc(s.a,i) > 0 & n > 0 & a <> DataLoc(s.a,i) &
 (for t be 0-started State of SCMPDS,Q st t.a=s.a
 holds IExec(I,Q,t).a=t.a
 & IExec(I,Q,t).DataLoc(s.a,i)=t.DataLoc(s.a,i) & I
  is_closed_on t,Q & I is_halting_on t,Q) holds
   for-down(a,i,n,I) is_closed_on s,P &
  for-down(a,i,n,I) is_halting_on s,P
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS,
      a be Int_position, i be Integer,n be Element of NAT;
  assume that
A1: s.DataLoc(s.a,i) > 0 & n > 0 & a <> DataLoc(s.a,i) and
A2: for t be 0-startedState of SCMPDS,Q
 st t.a=s.a holds IExec(I,Q,t).a=t.a
  & IExec(I,Q,t).DataLoc(s.a,i)=t.DataLoc(s.a,i) & I is_closed_on t,Q
   & I is_halting_on t,Q;
  for t being 0-started State of SCMPDS,Q st
    (for x be Int_position st x in {} holds t.x=s.x) & t.a=s.a
     holds IExec(I,Q,t).a=t.a
 & IExec(I,Q,t).DataLoc(s.a,i)=t.DataLoc(
  s.a,i) & I is_closed_on t,Q & I is_halting_on t,Q
   & for y be Int_position st y in
  {} holds IExec(I,Q,t).y=t.y by A2;
  hence thesis by A1,SCMPDS_7:48;
end;

begin :: A Program for Insert Sort

:: n -> intpos 2,  x1 -> intpos 3

definition
  let n,p0 be Element of NAT;
  func insert-sort(n,p0) -> Program of SCMPDS equals
  ((GBP:=0) ';' ((GBP,1):=0
) ';' ((GBP,2):=(n-1)) ';' ((GBP,3):=p0)) ';' for-down(GBP,2,1, AddTo(GBP,3,1)
  ';' ((GBP,4):=(GBP,3)) ';' AddTo(GBP,1,1) ';' ((GBP,6):=(GBP,1)) ';' while>0(
GBP,6, ((GBP,5):=(intpos 4,-1)) ';' SubFrom(GBP,5,intpos 4,0) ';' if>0(GBP,5, (
(GBP,5):=(intpos 4,-1)) ';' ((intpos 4,-1):=(intpos 4,0)) ';' ((intpos 4,0 ):=(
  GBP,5)) ';' AddTo(GBP,4,-1) ';' AddTo(GBP,6,-1), Load ((GBP,6):=0) ) ) );
  coherence;
end;

set j1= AddTo(GBP,3,1), j2= (GBP,4):=(GBP,3), j3= AddTo(GBP,1,1), j4= (GBP,6)
:=(GBP,1), k1= (GBP,5):=(intpos 4,-1), k2= SubFrom(GBP,5,intpos 4,0), k3= (GBP,
5):=(intpos 4,-1), k4= (intpos 4,-1):=(intpos 4,0), k5= (intpos 4,0 ):=(GBP,5),
k6= AddTo(GBP,4,-1), k7= AddTo(GBP,6,-1), FA= Load ((GBP,6):=0), TR= ((GBP,5):=
(intpos 4,-1)) ';' ((intpos 4,-1):=(intpos 4,0)) ';' ((intpos 4,0 ):=(GBP,5))
';' (AddTo(GBP,4,-1)) ';' (AddTo(GBP,6,-1)), IF= if>0(GBP,5, TR,FA), B1= ((GBP,
5):=(intpos 4,-1)) ';' (SubFrom(GBP,5,intpos 4,0)) ';' (if>0(GBP,5, TR,FA)),
  WH = while>0(GBP,6,B1),
  J4= j1 ';' j2 ';' j3 ';' j4, B2= J4 ';' WH, FR= for-down(
GBP,2,1,B2);

Lm5: card B1=10
proof
  thus card B1=card (k1 ';' k2)+card IF by AFINSQ_1:17
    .=2+card IF by SCMP_GCD:5
    .=2+(card TR+card FA+2) by SCMPDS_6:65
    .=2+(card (k3 ';' k4 ';' k5 ';' k6) +1+card FA+2) by SCMP_GCD:4
    .=2+(card (k3 ';' k4 ';' k5)+1 +1+card FA+2) by SCMP_GCD:4
    .=2+(card (k3 ';' k4)+1+1 +1+card FA+2) by SCMP_GCD:4
    .=2+(2+1+1 +1+card FA+2) by SCMP_GCD:5
    .=2+(2+1+1+1+1+2) by COMPOS_1:54
    .=10;
end;

Lm6: card B2=16
proof
  thus card B2=card (j1 ';' j2 ';' j3 ';' j4) + card WH by AFINSQ_1:17
    .=card (j1 ';' j2 ';' j3)+1+ card WH by SCMP_GCD:4
    .=card (j1 ';' j2 )+1+1+ card WH by SCMP_GCD:4
    .=2+1+1+ card WH by SCMP_GCD:5
    .=2+1+1+(10+2) by Lm5,SCMPDS_8:17
    .=16;
end;

set a1=intpos 1, a2=intpos 2, a3=intpos 3, a4=intpos 4, a5=intpos 5,
    a6=intpos 6;

Lm7: for s being 0-started State of SCMPDS
 st s.a4 >= 7+s.a6 & s.GBP=0 & s.a6 > 0 holds
IExec(B1,P,s).GBP=0 & IExec(B1,P,s).a1=s.a1
proof
  let s be 0-started State of SCMPDS;
  set a=GBP, x=DataLoc(s.a4,-1), y=DataLoc(s.a4,0);
  assume that
A1: s.a4 >= 7+s.a6 and
A2: s.a=0 and
A3: s.a6 > 0;
A4: 7+s.a6>7+0 by A3,XREAL_1:6;
  set t0=s, t1=Exec(k1, t0), t2=IExec(k1 ';' k2,P,s),
   Q2 = P;
A6: DataLoc(t0.a,5)=intpos (0+5) by A2,SCMP_GCD:1;
  then
A7: t1.a=0 by A2,AMI_3:10,SCMPDS_2:47;
  then
A8: DataLoc(t1.a,5)=intpos (0+5) by SCMP_GCD:1;
A9: t1.a4=s.a4 by A6,AMI_3:10,SCMPDS_2:47;
A10: s.a4>=1+(6+s.a6) by A1;
  then
A11: s.a4-1 >= 6+s.a6 by XREAL_1:19;

  set Fi= (a,6):=0, t02=Initialize t2, Q02 = Q2,
  t3=IExec(k3 ';' k4 ';' k5 ';' k6,Q2,Initialize t2),
  t4=IExec(k3 ';' k4 ';' k5,Q2,Initialize t2),
  t5=IExec(k3 ';' k4,Q2,Initialize t2),
  t6=Exec(k3,t02);
  t2.a=Exec(k2,t1).a by SCMPDS_5:42
    .=0 by A7,A8,AMI_3:10,SCMPDS_2:50;
  then
A15: t02.a=0 by SCMPDS_5:15;
  then
A16: DataLoc(t02.a,5)=intpos (0+5) by SCMP_GCD:1;
  then
A17: t6.a=0 by A15,AMI_3:10,SCMPDS_2:47;
  t2.a4=Exec(k2,t1).a4 by SCMPDS_5:42
    .=s.a4 by A9,A8,AMI_3:10,SCMPDS_2:50;
  then t02.a4=s.a4 by SCMPDS_5:15;
  then
A18: t6.a4=s.a4 by A16,AMI_3:10,SCMPDS_2:47;
A19: 6+s.a6>6+0 by A3,XREAL_1:6;
  then 0<>abs(t6.a4+-1) by A11,A18,ABSVALUE:def 1;
  then
A20: a<>DataLoc(t6.a4,-1) by ZFMISC_1:27;
  s.a4-1 > 0 by A3,A10,XREAL_1:19;
  then
A21: abs(t6.a4+-1) =s.a4-1 by A18,ABSVALUE:def 1;
  then 4<>abs(t6.a4+-1) by A11,A19,XXREAL_0:2;
  then
A22: a4<>DataLoc(t6.a4,-1) by ZFMISC_1:27;
A24: t5.a4 =Exec(k4, t6).a4 by SCMPDS_5:42
    .=s.a4 by A18,A22,SCMPDS_2:47;
  then 0<>abs(t5.a4+0) by A1,A4,ABSVALUE:def 1;
  then
A25: a<>DataLoc(t5.a4,0) by ZFMISC_1:27;
A26: t5.a =Exec(k4, t6).a by SCMPDS_5:42
    .=0 by A17,A20,SCMPDS_2:47;
A27: t4.a=Exec(k5,t5).a by SCMPDS_5:41
    .=0 by A26,A25,SCMPDS_2:47;
  then
A28: a<>DataLoc(t4.a,4) by AMI_3:10,SCMP_GCD:1;
A29: t1.a1=s.a1 by A6,AMI_3:10,SCMPDS_2:47;
  t2.a1=Exec(k2, t1).a1 by SCMPDS_5:42
    .=s.a1 by A29,A8,AMI_3:10,SCMPDS_2:50;
  then
A30: t02.a1=s.a1 by SCMPDS_5:15;
  then
A31: t6.a1=s.a1 by A16,AMI_3:10,SCMPDS_2:47;
A32: t3.a=Exec(k6,t4).a by SCMPDS_5:41
    .=0 by A27,A28,SCMPDS_2:48;
  then
A33: DataLoc(t3.a,6)=intpos (0+6) by SCMP_GCD:1;
A34: DataLoc(t02.a,6)=intpos (0+6) by A15,SCMP_GCD:1;
  now
    per cases;
    suppose
      (Initialize t2).DataLoc((Initialize t2).a,5) <= 0;
      hence IExec(IF,Q2,Initialize t2).a=IExec(FA,Q2,Initialize t2).a
       by SCMPDS_6:74
        .=Exec(Fi,t02).a by SCMPDS_5:40
        .=0 by A15,A34,AMI_3:10,SCMPDS_2:46;
    end;
    suppose (Initialize t2).DataLoc((Initialize t2).a,5) > 0;
      hence IExec(IF,Q2,Initialize t2).a=IExec(TR,Q2,Initialize t2).a
       by SCMPDS_6:73
        .=Exec(k7,t3).a by SCMPDS_5:41
        .=0 by A32,A33,AMI_3:10,SCMPDS_2:48;
    end;
  end;
  hence IExec(B1,P,s).a=0 by SCMPDS_5:35;
A36: a1<>DataLoc(t4.a,4) by A27,AMI_3:10,SCMP_GCD:1;
  abs(t5.a4+0) = s.a4 by A1,A4,A24,ABSVALUE:def 1;
  then 1<>abs(t5.a4+0) by A1,A4,XXREAL_0:2;
  then
A37: a1<>DataLoc(t5.a4,0) by ZFMISC_1:27;
  1<>abs(t6.a4+-1) by A11,A19,A21,XXREAL_0:2;
  then
A38: a1<>DataLoc(t6.a4,-1) by ZFMISC_1:27;
A39: t5.a1 =Exec(k4, t6).a1 by SCMPDS_5:42
    .=s.a1 by A31,A38,SCMPDS_2:47;
A40: t4.a1=Exec(k5,t5).a1 by SCMPDS_5:41
    .=s.a1 by A39,A37,SCMPDS_2:47;
A41: t3.a1=Exec(k6,t4).a1 by SCMPDS_5:41
    .=s.a1 by A40,A36,SCMPDS_2:48;
  now
    per cases;
    suppose
      (Initialize t2).DataLoc((Initialize t2).a,5) <= 0;
      hence IExec(IF,Q2,Initialize t2).a1=IExec(FA,Q2,Initialize t2).a1
       by SCMPDS_6:74
        .=Exec(Fi,t02).a1 by SCMPDS_5:40
        .=s.a1 by A30,A34,AMI_3:10,SCMPDS_2:46;
    end;
    suppose
      (Initialize t2).DataLoc((Initialize t2).a,5) > 0;
      hence IExec(IF,Q2,Initialize t2).a1=IExec(TR,Q2,Initialize t2).a1
       by SCMPDS_6:73
        .=Exec(k7,t3).a1 by SCMPDS_5:41
        .=s.a1 by A41,A33,AMI_3:10,SCMPDS_2:48;
    end;
  end;
  hence thesis by SCMPDS_5:35;
end;

Lm8: for s being 0-started State of SCMPDS
 st s.a4 >= 7+s.a6 & s.GBP=0 & s.a6 > 0 holds
IExec(B1,P,s).a2=s.a2 & IExec(B1,P,s).a3=s.a3 &
IExec(B1,P,s).a6 < s.a6
 & IExec(B1,P,s).a4 >= 7+IExec(B1,P,s).a6 & (for i be Nat
 st i>=7 & i<>s.a4-1 & i<>s.a4 holds
IExec(B1,P,s).intpos i=s.intpos i) &
 (s.DataLoc(s.a4,-1) > s.DataLoc(s.a4,0)
implies IExec(B1,P,s).DataLoc(s.a4,-1)=s.DataLoc(s.a4,0)
 & IExec(B1,P,s).DataLoc(s.a4,0) =s.DataLoc(s.a4,-1)
 & IExec(B1,P,s).a6=s.a6-1
 & IExec(B1,P,s).a4=s.a4-1 )
 & (s.DataLoc(s.a4,-1) <= s.DataLoc(s.a4,0)
   implies IExec(B1,P,s).DataLoc(s.a4,-1)
   =s.DataLoc(s.a4,-1) & IExec(B1,P,s).DataLoc(s.a4,0) =s.DataLoc(s.a4,0)
 & IExec(B1,P,s).a6=0)
proof
  let s be 0-started State of SCMPDS;
  set a=GBP, x=DataLoc(s.a4,-1), y=DataLoc(s.a4,0);
  assume that
A1: s.a4 >= 7+s.a6 and
A2: s.a=0 and
A3: s.a6 > 0;
  set t0=s, t1=Exec(k1, t0),
  t2=IExec(k1 ';' k2,P,s), Q2 = P;
A4: 7+s.a6>7+0 by A3,XREAL_1:6;
  then
A5: abs(s.a4)=s.a4 by A1,ABSVALUE:def 1;
  set Fi= (a,6):=0, t02=Initialize t2, Q02 = Q2,
  t3=IExec(k3 ';' k4 ';' k5 ';' k6,Q2,Initialize t2),
  t4=IExec(k3 ';' k4 ';' k5,Q2,Initialize t2),
  t5=IExec(k3 ';' k4,Q2,Initialize t2),
  t6=Exec(k3, t02);
A12: DataLoc(t0.a,5)=intpos (0+5) by A2,SCMP_GCD:1;
  then
A13: t1.a=0 by A2,AMI_3:10,SCMPDS_2:47;
  then
A14: DataLoc(t1.a,5)=intpos (0+5) by SCMP_GCD:1;
  then
A15: abs(t1.a+5)=0+5 by ZFMISC_1:27;
  then abs(s.a4+0)<>abs(t1.a+5) by A1,A4,A5,XXREAL_0:2;
  then
A16: y<>DataLoc(t1.a,5) by ZFMISC_1:27;
A17: abs(t0.a+5)=0+5 by A12,ZFMISC_1:27;
  then abs(s.a4+0)<>abs(t0.a+5) by A1,A4,A5,XXREAL_0:2;
  then t0.y=s.y & y<>DataLoc(t0.a,5) by ZFMISC_1:27;
  then
A18: t1.y=s.y by SCMPDS_2:47;
A20: t1.a5=s.x by A12,SCMPDS_2:47;
A21: t1.a4=s.a4 by A12,AMI_3:10,SCMPDS_2:47;
  t2.y=Exec(k2, t1).y by SCMPDS_5:42
    .=s.y by A18,A16,SCMPDS_2:50;
  then
A22: t02.y=s.y by SCMPDS_5:15;
A23: t02.a = t2.a by SCMPDS_5:15
    .=Exec(k2, t1).a by SCMPDS_5:42
    .=0 by A13,A14,AMI_3:10,SCMPDS_2:50;
A25: DataLoc(t02.a,5)=intpos (0+5) by A23,SCMP_GCD:1;
  then
A26: t6.a=0 by A23,AMI_3:10,SCMPDS_2:47;
  abs(t02.a+5)=0+5 by A25,ZFMISC_1:27;
  then abs(s.a4+0)<>abs(t02.a+5) by A1,A4,A5,XXREAL_0:2;
  then y<>DataLoc(t02.a,5) by ZFMISC_1:27;
  then
A27: t6.y=s.y by A22,SCMPDS_2:47;
  t2.a4=Exec(k2, t1).a4 by SCMPDS_5:42
    .=s.a4 by A21,A14,AMI_3:10,SCMPDS_2:50;
  then
A28: t02.a4=s.a4 by SCMPDS_5:15;
  then
A29: t6.a4=s.a4 by A25,AMI_3:10,SCMPDS_2:47;
  then
A30: t5.x =Exec(k4, t6).DataLoc(t6.a4,-1) by SCMPDS_5:42
    .=s.y by A29,A27,SCMPDS_2:47;
A31: t1.a3=s.a3 by A12,AMI_3:10,SCMPDS_2:47;
  t2.a3=Exec(k2, t1).a3 by SCMPDS_5:42
    .=s.a3 by A31,A14,AMI_3:10,SCMPDS_2:50;
  then
A32: t02.a3=s.a3 by SCMPDS_5:15;
  then
A33: t6.a3=s.a3 by A25,AMI_3:10,SCMPDS_2:47;
A34: s.a4>=1+(6+s.a6) by A1;
  then
A35: s.a4-1 >= 6+s.a6 by XREAL_1:19;
A36: t1.a2=s.a2 by A12,AMI_3:10,SCMPDS_2:47;
  t2.a2=Exec(k2, t1).a2 by SCMPDS_5:42
    .=s.a2 by A36,A14,AMI_3:10,SCMPDS_2:50;
  then
A37: t02.a2=s.a2 by SCMPDS_5:15;
  then
A38: t6.a2=s.a2 by A25,AMI_3:10,SCMPDS_2:47;
A39: t1.a6=s.a6 by A12,AMI_3:10,SCMPDS_2:47;
  t2.a6=Exec(k2, t1).a6 by SCMPDS_5:42
    .=s.a6 by A39,A14,AMI_3:10,SCMPDS_2:50;
  then t02.a6=s.a6 by SCMPDS_5:15;
  then
A40: t6.a6=s.a6 by A25,AMI_3:10,SCMPDS_2:47;
A41: DataLoc(t02.a,6)=intpos (0+6) by A23,SCMP_GCD:1;
A42: now
    assume
    t02.DataLoc(t02.a,5) <= 0;
    then IExec(IF,Q2,Initialize t2).a6=IExec(FA,Q2,Initialize t2).a6
     by SCMPDS_6:74
      .=Exec(Fi,t02).a6 by SCMPDS_5:40
      .=0 by A41,SCMPDS_2:46;
    hence IExec(B1,P,s).a6 =0 by SCMPDS_5:35;
  end;
A43: 6+s.a6>6+0 by A3,XREAL_1:6;
  then 0<>abs(t6.a4+-1) by A35,A29,ABSVALUE:def 1;
  then
A44: a<>DataLoc(t6.a4,-1) by ZFMISC_1:27;
A45: s.a4-1 > 0 by A3,A34,XREAL_1:19;
  then
A46: abs(t6.a4+-1) =s.a4-1 by A29,ABSVALUE:def 1;
  then 4<>abs(t6.a4+-1) by A35,A43,XXREAL_0:2;
  then
A47: a4<>DataLoc(t6.a4,-1) by ZFMISC_1:27;
A48: t5.a4 =Exec(k4, t6).a4 by SCMPDS_5:42
    .=s.a4 by A29,A47,SCMPDS_2:47;
  then
A49: abs(t5.a4+0) = s.a4 by A1,A4,ABSVALUE:def 1;
  then 4<>abs(t5.a4+0) by A1,A4,XXREAL_0:2;
  then
A50: a4<>DataLoc(t5.a4,0) by ZFMISC_1:27;
  3<>abs(t6.a4+-1) by A35,A43,A46,XXREAL_0:2;
  then
A51: a3<>DataLoc(t6.a4,-1) by ZFMISC_1:27;
  3<>abs(t5.a4+0) by A1,A4,A49,XXREAL_0:2;
  then
A52: a3<>DataLoc(t5.a4,0) by ZFMISC_1:27;
A53: t5.a3 =Exec(k4, t6).a3 by SCMPDS_5:42
    .=s.a3 by A33,A51,SCMPDS_2:47;
A54: t4.a3=Exec(k5,t5).a3 by SCMPDS_5:41
    .=s.a3 by A53,A52,SCMPDS_2:47;
  2<>abs(t5.a4+0) by A1,A4,A49,XXREAL_0:2;
  then
A55: a2<>DataLoc(t5.a4,0) by ZFMISC_1:27;
A56: t4.a4=Exec(k5,t5).a4 by SCMPDS_5:41
    .=s.a4 by A48,A50,SCMPDS_2:47;
A57: t5.a =Exec(k4, t6).a by SCMPDS_5:42
    .=0 by A26,A44,SCMPDS_2:47;
A58: 2*abs((s.a4+-1))+1=2*(s.a4-1)+1 by A35,A43,ABSVALUE:def 1;
  then abs(s.a4+-1)<>abs(t1.a+5) by A3,A35,A15,XREAL_1:6;
  then
A59: x<>DataLoc(t1.a,5) by ZFMISC_1:27;
  0<>abs(t5.a4+0) by A1,A4,A48,ABSVALUE:def 1;
  then
A60: a<>DataLoc(t5.a4,0) by ZFMISC_1:27;
A61: t4.a=Exec(k5,t5).a by SCMPDS_5:41
    .=0 by A57,A60,SCMPDS_2:47;
  then
A62: a<>DataLoc(t4.a,4) by AMI_3:10,SCMP_GCD:1;
  2<>abs(t6.a4+-1) by A35,A43,A46,XXREAL_0:2;
  then
A63: a2<>DataLoc(t6.a4,-1) by ZFMISC_1:27;
A64: t5.a2 =Exec(k4, t6).a2 by SCMPDS_5:42
    .=s.a2 by A38,A63,SCMPDS_2:47;
A65: t4.a2=Exec(k5,t5).a2 by SCMPDS_5:41
    .=s.a2 by A64,A55,SCMPDS_2:47;
A66: a2<>DataLoc(t4.a,4) by A61,AMI_3:10,SCMP_GCD:1;
  t3.a=Exec(k6,t4).a by SCMPDS_5:41
    .=0 by A61,A62,SCMPDS_2:48;
  then
A67: DataLoc(t3.a,6)=intpos (0+6) by SCMP_GCD:1;
  then
A68: abs(t3.a+6)=0+6 by ZFMISC_1:27;
A69: DataLoc(t4.a,4)=intpos (0+4) by A61,SCMP_GCD:1;
  then
A70: abs(t4.a+4)=0+4 by ZFMISC_1:27;
  then abs(s.a4+-1)<>abs(t4.a+4) by A35,A43,A58,XXREAL_0:2;
  then
A71: x<>DataLoc(t4.a,4) by ZFMISC_1:27;
A72: t3.a2=Exec(k6,t4).a2 by SCMPDS_5:41
    .=s.a2 by A65,A66,SCMPDS_2:48;
  now
    per cases;
    suppose
      t02.DataLoc(t02.a,5) <= 0;
      hence IExec(IF,Q2,Initialize t2).a2=IExec(FA,Q2,Initialize t2).a2
       by SCMPDS_6:74
        .=Exec(Fi,t02).a2 by SCMPDS_5:40
        .=s.a2 by A37,A41,AMI_3:10,SCMPDS_2:46;
    end;
    suppose
      t02.DataLoc(t02.a,5) > 0;
      hence IExec(IF,Q2,Initialize t2).a2=IExec(TR,Q2,Initialize t2).a2
       by SCMPDS_6:73
        .=Exec(k7,t3).a2 by SCMPDS_5:41
        .=s.a2 by A72,A67,AMI_3:10,SCMPDS_2:48;
    end;
  end;
  hence IExec(B1,P,s).a2=s.a2 by SCMPDS_5:35;
A74: a3<>DataLoc(t4.a,4) by A61,AMI_3:10,SCMP_GCD:1;
A75: t3.a3=Exec(k6,t4).a3 by SCMPDS_5:41
    .=s.a3 by A54,A74,SCMPDS_2:48;
  now
    per cases;
    suppose
      t02.DataLoc(t02.a,5) <= 0;
      hence IExec(IF,Q2,Initialize t2).a3=IExec(FA,Q2,Initialize t2).a3
       by SCMPDS_6:74
        .=Exec(Fi,t02).a3 by SCMPDS_5:40
        .=s.a3 by A32,A41,AMI_3:10,SCMPDS_2:46;
    end;
    suppose
      t02.DataLoc(t02.a,5) > 0;
      hence IExec(IF,Q2,Initialize t2).a3=IExec(TR,Q2,Initialize t2).a3
       by SCMPDS_6:73
        .=Exec(k7,t3).a3 by SCMPDS_5:41
        .=s.a3 by A75,A67,AMI_3:10,SCMPDS_2:48;
    end;
  end;
  hence IExec(B1,P,s).a3=s.a3 by SCMPDS_5:35;
A76: a6<>DataLoc(t4.a,4) by A61,AMI_3:10,SCMP_GCD:1;
  6<>abs(t6.a4+-1) by A34,A43,A46,XREAL_1:19;
  then
A77: a6<>DataLoc(t6.a4,-1) by ZFMISC_1:27;
A78: t5.a6 =Exec(k4, t6).a6 by SCMPDS_5:42
    .=s.a6 by A40,A77,SCMPDS_2:47;
  6<>abs(t5.a4+0) by A1,A4,A49,XXREAL_0:2;
  then
A79: a6<>DataLoc(t5.a4,0) by ZFMISC_1:27;
A80: t4.a6=Exec(k5,t5).a6 by SCMPDS_5:41
    .=s.a6 by A78,A79,SCMPDS_2:47;
A81: t3.a6=Exec(k6,t4).a6 by SCMPDS_5:41
    .=s.a6 by A80,A76,SCMPDS_2:48;
A82: t3.a4=Exec(k6,t4).a4 by SCMPDS_5:41
    .=t4.a4+-1 by A69,SCMPDS_2:48
    .=s.a4-1 by A56;
A83: now
    assume
A84: t02.DataLoc(t02.a,5) > 0;
    then IExec(IF,Q2,Initialize t2).a6=IExec(TR,Q2,Initialize t2).a6
     by SCMPDS_6:73
      .=Exec(k7,t3).a6 by SCMPDS_5:41
      .=s.a6+ -1 by A81,A67,SCMPDS_2:48
      .=s.a6-1;
    hence IExec(B1,P,s).a6=s.a6-1 by SCMPDS_5:35;
    IExec(IF,Q2,Initialize t2).a4=IExec(TR,Q2,Initialize t2).a4
     by A84,SCMPDS_6:73
      .=Exec(k7,t3).a4 by SCMPDS_5:41
      .=s.a4-1 by A82,A67,AMI_3:10,SCMPDS_2:48;
    hence IExec(B1,P,s).a4=s.a4-1 by SCMPDS_5:35;
  end;
  hereby
    per cases;
    suppose
      t02.DataLoc(t02.a,5) <= 0;
      hence IExec(B1,P,s).a6 < s.a6 by A3,A42;
    end;
    suppose
      t02.DataLoc(t02.a,5) > 0;
      hence IExec(B1,P,s).a6 < s.a6 by A83,XREAL_1:146;
    end;
  end;
  hereby
    per cases;
    suppose
A85:  t02.DataLoc(t02.GBP,5) <= 0;
      then IExec(IF,Q2,Initialize t2).a4=IExec(FA,Q2,Initialize t2).a4
       by SCMPDS_6:74
        .=Exec(Fi,t02).a4 by SCMPDS_5:40
        .=s.a4 by A28,A41,AMI_3:10,SCMPDS_2:46;
      then IExec(B1,P,s).a4=s.a4 by SCMPDS_5:35;

      hence IExec(B1,P,s).a4 >= 7+IExec(B1,P,s).a6
       by A1,A4,A42,A85,XXREAL_0:2;

    end;
    suppose
A86:  t02.DataLoc(t02.a,5) > 0;
      s.a4-1 >= 7+s.a6-1 by A1,XREAL_1:9;
      hence IExec(B1,P,s).a4 >= 7+IExec(B1,P,s).a6
       by A83,A86;
    end;
  end;
A87: now
    let i be Element of NAT;
    assume that
A88: i>=7 and
    i<>s.a4-1 and
    i <> s.a4;
    i>5 by A88,XXREAL_0:2;
    hence t1.intpos i =s.intpos i by A12,AMI_3:10,SCMPDS_2:47;
  end;
A89: now
    let i be Element of NAT;
    assume that
A90: i>=7 and
A91: i<>s.a4-1 & i <> s.a4;
A92: i>5 by A90,XXREAL_0:2;
    thus t2.intpos i=Exec(k2, t1).intpos i by SCMPDS_5:42
      .=t1.intpos i by A14,A92,AMI_3:10,SCMPDS_2:50
      .=s.intpos i by A87,A90,A91;
  end;
A93: now
    let i be Element of NAT;
    assume that
A94: i>=7 and
A95: i<>s.a4-1 & i <> s.a4;
    i>5 by A94,XXREAL_0:2;
    hence t6.intpos i=t02.intpos i by A25,AMI_3:10,SCMPDS_2:47
      .=t2.intpos i by SCMPDS_5:15
      .=s.intpos i by A89,A94,A95;
  end;
A96: now
    let i be Element of NAT;
    assume that
A97: i>=7 and
A98: i<>s.a4-1 and
A99: i <> s.a4;
A100: intpos i <> DataLoc(t6.a4,-1)
    proof
      assume
      intpos i=DataLoc(t6.a4,-1);
      then i =abs(t6.a4+-1) by ZFMISC_1:27;
      hence contradiction by A45,A29,A98,ABSVALUE:def 1;
    end;
    thus t5.intpos i=Exec(k4, t6).intpos i by SCMPDS_5:42
      .=t6.intpos i by A100,SCMPDS_2:47
      .=s.intpos i by A93,A97,A98,A99;
  end;
A101: now
    let i be Element of NAT;
    assume that
A102: i>=7 & i<>s.a4-1 and
A103: i <> s.a4;
A104: intpos i <> DataLoc(t5.a4,0)
    proof
      assume
      intpos i=DataLoc(t5.a4,0);
      then i=abs(t5.a4+0) by ZFMISC_1:27;
      hence contradiction by A1,A4,A48,A103,ABSVALUE:def 1;
    end;
    thus t4.intpos i=Exec(k5, t5).intpos i by SCMPDS_5:41
      .=t5.intpos i by A104,SCMPDS_2:47
      .=s.intpos i by A96,A102,A103;
  end;
A105: now
    let i be Element of NAT;
    assume that
A106: i>=7 and
A107: i<>s.a4-1 & i <> s.a4;
    i>4 by A106,XXREAL_0:2;
    then
A108: intpos i <> DataLoc(t4.a,4) by A61,AMI_3:10,SCMP_GCD:1;
    thus t3.intpos i=Exec(k6, t4).intpos i by SCMPDS_5:41
      .=t4.intpos i by A108,SCMPDS_2:48
      .=s.intpos i by A101,A106,A107;
  end;
  hereby
    let i be Nat;
A109: i in NAT by ORDINAL1:def 12;
    set xi=intpos i;
    assume that
A110: i>=7 and
A111: i<>s.a4-1 & i <> s.a4;
A112: i>6 by A110,XXREAL_0:2;
    per cases;
    suppose
      t02.DataLoc(t02.a,5) <= 0;
      then IExec(IF,Q2,Initialize t2).xi=IExec(FA,Q2,Initialize t2).xi
       by SCMPDS_6:74
        .=Exec(Fi,t02).xi by SCMPDS_5:40
        .=t02.xi by A41,A112,AMI_3:10,SCMPDS_2:46
        .=t2.xi by SCMPDS_5:15
        .=s.xi by A89,A109,A110,A111;
      hence IExec(B1,P,s).xi=s.xi by SCMPDS_5:35;
    end;
    suppose
      t02.DataLoc(t02.a,5) > 0;
      then IExec(IF,Q2,Initialize t2).xi=IExec(TR,Q2,Initialize t2).xi
       by SCMPDS_6:73
        .=Exec(k7,t3).xi by SCMPDS_5:41
        .=t3.xi by A67,A112,AMI_3:10,SCMPDS_2:48
        .=s.xi by A105,A109,A110,A111;
      hence IExec(B1,P,s).xi=s.xi by SCMPDS_5:35;
    end;
  end;
A113: t02.a5 = t2.a5 by SCMPDS_5:15
    .=Exec(k2, t1).a5 by SCMPDS_5:42
    .=s.x-s.y by A21,A20,A18,A14,SCMPDS_2:50;
  then
A114: t02.DataLoc(t02.a,5)=s.x-s.y by A23,SCMP_GCD:1;
  abs(s.a4+-1)<>abs(t0.a+5) by A3,A35,A58,A17,XREAL_1:6;
  then x<>DataLoc(t0.a,5) by ZFMISC_1:27;
  then
A115: t1.x=s.x by SCMPDS_2:47;
  t2.x=Exec(k2, t1).x by SCMPDS_5:42
    .=s.x by A115,A59,SCMPDS_2:50;
  then
A116: t02.x=s.x by SCMPDS_5:15;
  then
A117: t6.a5=s.x by A28,A25,SCMPDS_2:47;
  5<>abs(t6.a4+-1) by A35,A43,A46,XXREAL_0:2;
  then
A118: a5<>DataLoc(t6.a4,-1) by ZFMISC_1:27;
A119: t5.a5 =Exec(k4, t6).a5 by SCMPDS_5:42
    .=s.x by A117,A118,SCMPDS_2:47;
  abs(s.a4+0)<>abs(t4.a+4) by A1,A4,A5,A70,XXREAL_0:2;
  then
A120: y<>DataLoc(t4.a,4) by ZFMISC_1:27;
A121: t4.y =Exec(k5, t5).DataLoc(t5.a4,0) by A48,SCMPDS_5:41
    .=t5.DataLoc(t5.a,5) by SCMPDS_2:47
    .=s.x by A57,A119,SCMP_GCD:1;
A122: t3.y=Exec(k6, t4).y by SCMPDS_5:41
    .=s.x by A121,A120,SCMPDS_2:48;
  abs(s.a4+-1)<>abs(t5.a4+0) by A58,A49;
  then
A123: x<>DataLoc(t5.a4,0) by ZFMISC_1:27;
A124: t4.x=Exec(k5,t5).x by SCMPDS_5:41
    .=s.y by A30,A123,SCMPDS_2:47;
A125: t3.x=Exec(k6, t4).x by SCMPDS_5:41
    .=s.y by A124,A71,SCMPDS_2:48;
  hereby
A126: x<>DataLoc(t3.a,6) by A35,A43,A58,A67,ZFMISC_1:27;
    assume
    s.x > s.y;
    then
A127: s.x-s.y > s.y-s.y by XREAL_1:9;
    then IExec(IF,Q2,Initialize t2).x=IExec(TR,Q2,Initialize t2).x
     by A114,SCMPDS_6:73
      .=Exec(k7,t3).x by SCMPDS_5:41
      .=s.y by A125,A126,SCMPDS_2:48;
    hence IExec(B1,P,s).x=s.y by SCMPDS_5:35;
    abs(s.a4+0)<>abs(t3.a+6) by A1,A4,A5,A68,XXREAL_0:2;
    then
A128: y<>DataLoc(t3.a,6) by ZFMISC_1:27;
    IExec(IF,Q2,Initialize t2).y=IExec(TR,Q2,Initialize t2).y
     by A114,A127,SCMPDS_6:73
      .=Exec(k7,t3).y by SCMPDS_5:41
      .=s.x by A122,A128,SCMPDS_2:48;
    hence IExec(B1,P,s).y=s.x by SCMPDS_5:35;

    thus IExec(B1,P,s).a6=s.a6-1 &
    IExec(B1,P,s).a4=s.a4-1
     by A23,A113,A83,A127,SCMP_GCD:1;

  end;
A129: abs(t02.a+6)=0+6 by A41,ZFMISC_1:27;
  hereby
A130: x<>DataLoc(t02.a,6) by A35,A43,A58,A41,ZFMISC_1:27;
    assume
    s.x <= s.y;
    then
A131: s.x-s.y <= s.y-s.y by XREAL_1:9;
    then IExec(IF,Q2,Initialize t2).x=IExec(FA,Q2,Initialize t2).x
     by A114,SCMPDS_6:74
      .=Exec(Fi,t02).x by SCMPDS_5:40
      .=s.x by A116,A130,SCMPDS_2:46;
    hence IExec(B1,P,s).x=s.x by SCMPDS_5:35;
    abs(s.a4+0)<>abs(t02.a+6) by A1,A4,A5,A129,XXREAL_0:2;
    then
A132: y<>DataLoc(t02.a,6) by ZFMISC_1:27;
    IExec(IF,Q2,Initialize t2).y=IExec(FA,Q2,Initialize t2).y
     by A114,A131,SCMPDS_6:74
      .=Exec(Fi,t02).y by SCMPDS_5:40
      .=s.y by A22,A132,SCMPDS_2:46;
    hence IExec(B1,P,s).y=s.y by SCMPDS_5:35;
    thus IExec(B1,P,s).a6 =0 by A23,A113,A42,A131,SCMP_GCD:1;
  end;
end;

Lm9: for s being 0-started State of SCMPDS
 st s.a4 >= 7+s.DataLoc(s.GBP,6) & s.GBP=0
holds WH is_closed_on s,P & WH is_halting_on s,P
proof
  let s be 0-started State of SCMPDS;
  set a=GBP, b=DataLoc(s.a,6);
  assume that
A1: s.a4 >= 7+s.b and
A2: s.a=0;
A3: b=intpos(0+6) by A2,SCMP_GCD:1;
A4: now
    let t be 0-started State of SCMPDS;
    let Q;
    assume that
A5: for x st x in {a4} holds t.x >= 7+t.b and
A6: t.a=s.a & t.b >0;
    set Bt=IExec(B1,Q,t);
A11: a4 in {a4} by TARSKI:def 1;
    then
A12: t.a4 >= 7+t.a6 by A3,A5;
    hence IExec(B1,Q,t).a=t.a by A2,A3,A6,Lm7;
    thus B1 is_closed_on t,Q & B1 is_halting_on t,Q by SCMPDS_6:20,21;
    thus IExec(B1,Q,t).b < t.b by A2,A3,A6,A12,Lm8;
    t.a4 >= 7+t.b by A5,A11;
    then Bt.a4 >= 7+Bt.a6 by A2,A3,A6,Lm8;
    hence for x st x in {a4} holds IExec(B1,Q,t).x >=
     7+IExec(B1,Q,t).b by A3,TARSKI:def 1;
  end;

  for x st x in {a4} holds s.x >= 7+s.b by A1,TARSKI:def 1;
  hence thesis by A4,SCMPDS_8:29;
end;

Lm10: for s being 0-started State of SCMPDS
 st s.a4 >= 7+s.DataLoc(s.GBP,6) & s.GBP=0
holds IExec(WH,P,s).GBP=0 & IExec(WH,P,s).a1=s.a1 &
IExec(WH,P,s).a2=s.a2 & IExec(WH,P,s).a3=s.a3
proof
  let s be 0-started State of SCMPDS;
  set b=DataLoc(s.GBP,6), a=GBP;
  assume that
A1: s.a4 >= 7+s.b and
A2: s.a=0;
A3: b=intpos (0+6) by A2,SCMP_GCD:1;
  defpred P[Nat] means for t be 0-started State of SCMPDS,Q
   st t.a6 <= $1 & t.a4 >= 7+t.a6
  & t.a=0 holds IExec(WH,Q,t).a=0 &
  IExec(WH,Q,t).a1=t.a1 & IExec(WH,Q,t).a2=t.a2 &
  IExec(WH,Q,t).a3=t.a3;

A4: P[0 qua Nat]
  proof
    let t be 0-started State of SCMPDS, Q;
    assume that
A5: t.a6 <= 0 and
    t.a4 >= 7+t.a6 and
A6: t.a=0;
A7: DataLoc(t.a,6)=intpos (0+6) by A6,SCMP_GCD:1;
    hence IExec(WH,Q,t).a=0 by A5,A6,SCMPDS_8:23;
    thus thesis by A5,A7,SCMPDS_8:23;
  end;
A8: for k be Element of NAT st P[k] holds P[k+1]
  proof
    let k be Element of NAT;
    assume
A9: P[k];
    thus P[k+1]
    proof
      let t be 0-started State of SCMPDS, Q;
      set bt=DataLoc(t.a,6);
      assume that
A10:  t.a6 <= k+1 and
A11:  t.a4 >= 7+t.a6 and
A12:  t.a=0;
A13:  bt=intpos (0+6) by A12,SCMP_GCD:1;
      per cases;
      suppose
        t.bt <= 0;
        hence thesis by A12,SCMPDS_8:23;
      end;
      suppose
A14:    t.bt > 0;
A15:
 (for v be 0-started State of SCMPDS,Q st
   (for x st x in {a4} holds v.x >= 7+v.DataLoc(t.GBP,6)) & v.GBP=t.GBP &
   v.DataLoc(t.GBP,6) > 0
 holds
IExec(B1,Q,v).GBP=v.GBP & B1 is_closed_on v,Q & B1 is_halting_on v,Q
 & IExec(B1,Q,v).DataLoc(t.GBP,6) < v.DataLoc(t.GBP,6) & for x st x in {a4}
   holds IExec(B1,Q,v).x >= 7+IExec(B1,Q,v).DataLoc(t.GBP,6))
    proof
          let v be 0-started State of SCMPDS;
          let V;
V:   Initialize v = v by MEMSTR_0:44;
          assume that
A16:      for x st x in {a4} holds v.x >= 7+v.bt and
A17:      v.a=t.a & v.bt > 0;
          set Iv=IExec(B1,V,Initialize Initialize v);
A19:       v.a = (Initialize v).a by SCMPDS_5:15;
A20:       v.a4 = (Initialize v).a4 by SCMPDS_5:15;
A21:       v.a6 = (Initialize v).a6 by SCMPDS_5:15;
A22:      a4 in {a4} by TARSKI:def 1;
          then
A23:      v.a4 >= 7+v.a6 by A13,A16;
          hence IExec(B1,V,v).a=v.a
           by A12,A13,A17,Lm7;
          thus B1 is_closed_on v,V & B1 is_halting_on v,V by SCMPDS_6:20,21;
          thus IExec(B1,V,v).bt < v.bt
           by A12,A13,A17,A23,Lm8;
          v.a4 >= 7+v.bt by A16,A22;
          then Iv.a4 >= 7+Iv.a6 by A12,A13,A17,Lm8,A19,A20,A21;

          hence for x st x in {a4}
           holds IExec(B1,V,v).x >= 7+IExec(B1,V,v).bt
            by A13,V,TARSKI:def 1;

        end;
        set It=IExec(B1,Q,t), IT = Q;
A25: It.a1 = (Initialize It).a1 by SCMPDS_5:15;
A26: It.a6 = (Initialize It).a6 by SCMPDS_5:15;
A27: It.a4 = (Initialize It).a4 by SCMPDS_5:15;
A28: It.GBP = (Initialize It).GBP by SCMPDS_5:15;
A29: It.a2 = (Initialize It).a2 by SCMPDS_5:15;
A30: It.a3 = (Initialize It).a3 by SCMPDS_5:15;
        It.a6 < t.a6 by A11,A12,A13,A14,Lm8;
        then It.a6 +1 <= t.a6 by INT_1:7;
        then It.a6 +1 <= k+1 by A10,XXREAL_0:2;
        then
A31:    It.a6 <= k by XREAL_1:6;
A32:    It.GBP=0 & It.a4 >= 7+It.a6 by A11,A12,A13,A14,Lm7,Lm8;
        then
A33:    IExec(WH,IT,Initialize It).a1=It.a1 by A9,A31,A25,A26,A27,A28;
A34:    IExec(WH,IT,Initialize It).a3=It.a3 by A9,A32,A31,A26,A27,A28,A30;
A35:    IExec(WH,IT,Initialize It).a2=It.a2 by A9,A32,A31,A26,A27,A28,A29;
A36:    for x st x in {a4} holds t.x >= 7+t.bt by A11,A13,TARSKI:def 1;
        IExec(WH,IT,Initialize It).a=0 by A9,A32,A31,A26,A27,A28;
        hence IExec(WH,Q,t).a=0 by A14,A36,A15,SCMPDS_8:29;
        It.a1=t.a1 by A11,A12,A13,A14,Lm7;
        hence IExec(WH,Q,t).a1=t.a1
         by A14,A36,A15,A33,SCMPDS_8:29;
        It.a2=t.a2 by A11,A12,A13,A14,Lm8;
        hence IExec(WH,Q,t).a2=t.a2
         by A14,A36,A15,A35,SCMPDS_8:29;
        It.a3=t.a3 by A11,A12,A13,A14,Lm8;
        hence thesis by A14,A36,A15,A34,SCMPDS_8:29;
      end;
    end;
  end;
  per cases;
  suppose
    s.a6 <= 0;
    hence thesis by A2,A3,SCMPDS_8:23;
  end;
  suppose
    s.a6 > 0;
    then reconsider m=s.a6 as Element of NAT by INT_1:3;
    for k be Element of NAT holds P[k] from NAT_1:sch 1(A4,A8);
    then P[m];
    hence thesis by A1,A2,A3;
  end;
end;

Lm11: for s being 0-started State of SCMPDS
 st s.GBP=0 holds IExec(J4,P,s).GBP =0 &
 IExec(J4,P,s).a1 = s.a1+1 &
 IExec(J4,P,s).a2=s.a2 &
 IExec(J4,P,s).a3 =s.a3+1 & IExec(J4,P,s).
a4 =s.a3+1 & IExec(J4,P,s).a6 =s.a1+1
 & for i be Element of NAT st i >= 7 holds
IExec(J4,P,s).intpos i=s.intpos i
proof
  set a=GBP;
  let s be 0-started State of SCMPDS;
UU: Initialize s = s by MEMSTR_0:44;
  set t0=Initialize s, t1=IExec(J4,P,s),
  t2=IExec(j1 ';' j2 ';' j3,P,s), t3=IExec(j1 ';' j2,P,s), t4=Exec(j1,s);
  assume
Z:   s.a=0;
  then
A1: t0.a=0 by SCMPDS_5:15;
  then
A2: DataLoc(t0.a,3)=intpos (0+3) by SCMP_GCD:1;
  then
A3: t4.a=0 by A1,Z,AMI_3:10,SCMPDS_2:48;
  then
A4: DataLoc(t4.a,4)=intpos (0+4) by SCMP_GCD:1;
A5: t4.a2=s.a2 by A2,Z,A1,AMI_3:10,SCMPDS_2:48;
A6: t3.a2 =Exec(j2, t4).a2 by SCMPDS_5:42
    .=s.a2 by A5,A4,AMI_3:10,SCMPDS_2:47;
A7: t4.a1=s.a1 by A2,Z,A1,AMI_3:10,SCMPDS_2:48;
A8: t3.a1 =Exec(j2, t4).a1 by SCMPDS_5:42
    .=s.a1 by A7,A4,AMI_3:10,SCMPDS_2:47;
A9: t4.a3=s.a3+1 by A2,UU,SCMPDS_2:48;
A10: t3.a =Exec(j2, t4).a by SCMPDS_5:42
    .=0 by A3,A4,AMI_3:10,SCMPDS_2:47;
  then
A11: DataLoc(t3.a,1)=intpos (0+1) by SCMP_GCD:1;
A12: DataLoc(t4.a,3)=intpos (0+3) by A3,SCMP_GCD:1;
A13: t3.a4 =Exec(j2,t4).a4 by SCMPDS_5:42
    .=s.a3+1 by A9,A4,A12,SCMPDS_2:47;
A14: t2.a4 =Exec(j3, t3).a4 by SCMPDS_5:41
    .=s.a3+1 by A13,A11,AMI_3:10,SCMPDS_2:48;
A15: t2.a2 =Exec(j3, t3).a2 by SCMPDS_5:41
    .=s.a2 by A6,A11,AMI_3:10,SCMPDS_2:48;
A16: t2.a1 =Exec(j3, t3).a1 by SCMPDS_5:41
    .=s.a1+1 by A8,A11,SCMPDS_2:48;
A17: t3.a3 =Exec(j2, t4).a3 by SCMPDS_5:42
    .=s.a3+1 by A9,A4,AMI_3:10,SCMPDS_2:47;
A18: t2.a3 =Exec(j3, t3).a3 by SCMPDS_5:41
    .=s.a3+1 by A17,A11,AMI_3:10,SCMPDS_2:48;
A19: t2.a =Exec(j3, t3).a by SCMPDS_5:41
    .=0 by A10,A11,AMI_3:10,SCMPDS_2:48;
  then
A20: DataLoc(t2.a,6)=intpos (0+6) by SCMP_GCD:1;
  thus t1.a =Exec(j4, t2).a by SCMPDS_5:41
    .=0 by A19,A20,AMI_3:10,SCMPDS_2:47;
  thus t1.a1 =Exec(j4, t2).a1 by SCMPDS_5:41
    .=s.a1+1 by A16,A20,AMI_3:10,SCMPDS_2:47;
  thus t1.a2 =Exec(j4, t2).a2 by SCMPDS_5:41
    .=s.a2 by A15,A20,AMI_3:10,SCMPDS_2:47;
A21: DataLoc(t2.a,1)=intpos (0+1) by A19,SCMP_GCD:1;
  thus t1.a3 =Exec(j4, t2).a3 by SCMPDS_5:41
    .=s.a3+1 by A18,A20,AMI_3:10,SCMPDS_2:47;
  thus t1.a4 =Exec(j4, t2).a4 by SCMPDS_5:41
    .=s.a3+1 by A14,A20,AMI_3:10,SCMPDS_2:47;
  thus t1.a6 =Exec(j4, t2).a6 by SCMPDS_5:41
    .=s.a1+1 by A16,A20,A21,SCMPDS_2:47;
A22: now
    let i be Element of NAT;
    assume
    i >= 7;
    then i > 3 by XXREAL_0:2;
    hence t4.intpos i=t0.intpos i by A2,UU,AMI_3:10,SCMPDS_2:48
      .=s.intpos i by SCMPDS_5:15;
  end;
A23: now
    let i be Element of NAT;
    assume
A24: i >= 7;
    then
A25: i > 4 by XXREAL_0:2;
    thus t3.intpos i =Exec(j2, t4).intpos i by SCMPDS_5:42
      .=t4.intpos i by A4,A25,AMI_3:10,SCMPDS_2:47
      .=s.intpos i by A22,A24;
  end;
A26: now
    let i be Element of NAT;
    assume
A27: i >= 7;
    then
A28: i > 1 by XXREAL_0:2;
    thus t2.intpos i =Exec(j3, t3).intpos i by SCMPDS_5:41
      .=t3.intpos i by A11,A28,AMI_3:10,SCMPDS_2:48
      .=s.intpos i by A23,A27;
  end;
  hereby
    let i be Element of NAT;
    assume
A29: i >= 7;
    then
A30: i > 6 by XXREAL_0:2;
    thus t1.intpos i =Exec(j4, t2).intpos i by SCMPDS_5:41
      .=t2.intpos i by A20,A30,AMI_3:10,SCMPDS_2:47
      .=s.intpos i by A26,A29;
  end;
end;
set jf=AddTo(GBP,2,-1), B3=B2 ';' jf;

Lm12: for s being 0-started State of SCMPDS
 st s.a3 >= s.a1+7 & s.GBP=0 holds IExec(B3,P,s).GBP=0 &
 IExec(B3,P,s).a2=s.a2-1 & IExec(B3,P,s).a3=s.a3+1 &
IExec(B3,P,s).a1=s.a1+1
& for i be Element of NAT st i <> 2
 holds IExec(B3,P,s).intpos i
 =IExec(WH,P,Initialize IExec(J4,P,s)).intpos i
proof
  set a=GBP;
  let s be 0-started State of SCMPDS;
  set s1=IExec(J4,P,s),
      Bt=IExec(B2,P,s), P1 = P;
I: Initialize s = s by MEMSTR_0:44;
A1: s1.a = (Initialize s1).a by SCMPDS_5:15;
A2: s1.a4 = (Initialize s1).a4 by SCMPDS_5:15;
A3: s1.a6 = (Initialize s1).a6 by SCMPDS_5:15;
A4: s1.a3 = (Initialize s1).a3 by SCMPDS_5:15;
A5: s1.a1 = (Initialize s1).a1 by SCMPDS_5:15;
A6: s1.a2 = (Initialize s1).a2 by SCMPDS_5:15;
  assume that
A8: s.a3 >= s.a1+7 and
A9: s.a=0;
A10: s1.a1 = s.a1+1 by A9,Lm11;
A11: s1.a3 =s.a3+1 by A9,Lm11;
A12: s1.a2=s.a2 by A9,Lm11;
  s1.a6 =s.a1+1 & s.a3+1 >= 7+s.a1+1 by A8,A9,Lm11,XREAL_1:6;
  then
A13: s1.a4 >= 7+s1.a6 by A9,Lm11;
A14: s1.GBP =0 by A9,Lm11;
  then
A15: DataLoc(s1.a,6)=intpos (0+6) by SCMP_GCD:1;
  then WH is_closed_on Initialize s1,P1 & WH is_halting_on Initialize s1,P1
 by A14,A13,Lm9,A1,A2,A3;
  then
A16: WH is_closed_on s1,P1 & WH is_halting_on s1,P1 by SCMPDS_6:125,126;
A17: J4 is_closed_on s,P & J4 is_halting_on s,P by SCMPDS_6:20,21;
  then
A18: Bt.a =IExec(WH,P1,Initialize s1).a by A16,SCMPDS_7:30
    .=0 by A14,A15,A13,Lm10,A1,A2,A3;
  then
A19: DataLoc(Bt.a,2)=intpos (0+2) by SCMP_GCD:1;
A20: B2 is_closed_on s,P & B2 is_halting_on s,P by A16,A17,I,SCMPDS_7:24;
  hence IExec(B3,P,s).a=Exec(jf, Bt).a by SCMPDS_7:31
    .=0 by A18,A19,AMI_3:10,SCMPDS_2:48;
  thus IExec(B3,P,s).a2=Exec(jf, Bt).a2 by A20,SCMPDS_7:31
    .=Bt.a2+ -1 by A19,SCMPDS_2:48
    .=Bt.a2-1
    .=IExec(WH,P1,Initialize s1).a2 -1 by A16,A17,SCMPDS_7:30
    .=s.a2-1 by A14,A12,A15,A13,Lm10,A1,A2,A3,A6;
  thus IExec(B3,P,s).a3=Exec(jf, Bt).a3 by A20,SCMPDS_7:31
    .=Bt.a3 by A19,AMI_3:10,SCMPDS_2:48
    .=IExec(WH,P1,Initialize s1).a3 by A16,A17,SCMPDS_7:30
    .=s.a3+1 by A14,A11,A15,A13,Lm10,A1,A2,A3,A4;
  thus IExec(B3,P,s).a1=Exec(jf, Bt).a1 by A20,SCMPDS_7:31
    .=Bt.a1 by A19,AMI_3:10,SCMPDS_2:48
    .=IExec(WH,P1,Initialize s1).a1 by A16,A17,SCMPDS_7:30
    .=s.a1+1 by A14,A10,A15,A13,Lm10,A1,A2,A3,A5;
  hereby
    let i be Element of NAT;
    assume
A21: i<> 2;
    thus IExec(B3,P,s).intpos i=Exec(jf, Bt).intpos i
     by A20,SCMPDS_7:31
      .=Bt.intpos i by A19,A21,AMI_3:10,SCMPDS_2:48
      .=IExec(WH,P1,Initialize s1).intpos i by A16,A17,SCMPDS_7:30;
  end;
end;

Lm13: for s being 0-started State of SCMPDS st s.a3 >= s.a1+7 & s.GBP=0
holds FR is_closed_on s,P & FR is_halting_on s,P
proof
  let s be 0-started State of SCMPDS;
  set a=GBP, b=DataLoc(s.a,2);
  assume that
A1: s.a3 >= s.a1+7 and
A2: s.a=0;
A3: b=intpos(0+2) by A2,SCMP_GCD:1;
  now
    let t be 0-started State of SCMPDS;
    let Q;
T: Initialize t = t by MEMSTR_0:44;
    assume that
A4: t.a3 >= t.a1+7 and
A5: t.a=s.a and
    t.b >0;
    set t1=IExec(J4,Q,t), Q1 = Q;
A11: t1.a = (Initialize t1).a by SCMPDS_5:15;
A12: t1.a4 = (Initialize t1).a4 by SCMPDS_5:15;
A13: t1.a6 = (Initialize t1).a6 by SCMPDS_5:15;
A15: t.a3+1 >= 7+t.a1+1 by A4,XREAL_1:6;
    thus IExec(B3,Q,t).a=t.a by A2,A4,A5,Lm12;
    thus IExec(B3,Q,t).b=t.b-1 by A2,A3,A4,A5,Lm12;
A16: J4 is_closed_on t,Q & J4 is_halting_on t,Q by SCMPDS_6:20,21;
    t1.a6 =t.a1+1 by A2,A5,Lm11;
    then
A17: t1.a4 >= 7+t1.a6 by A2,A5,A15,Lm11;
A18: t1.a =0 by A2,A5,Lm11;
    then DataLoc(t1.a,6)=intpos (0+6) by SCMP_GCD:1;
    then WH is_closed_on Initialize t1,Q1 & WH is_halting_on Initialize t1,Q1
     by A18,A17,Lm9,A12,A13,A11;
    then WH is_closed_on t1,Q1 & WH is_halting_on t1,Q1 by SCMPDS_6:125,126;
    hence B2 is_closed_on t,Q & B2 is_halting_on t,Q by A16,T,SCMPDS_7:24;
    IExec(B3,Q,t).a1=t.a1+1 by A2,A4,A5,Lm12;
    hence IExec(B3,Q,t).a3>=IExec(B3,Q,t).a1+7
     by A2,A4,A5,A15,Lm12;
  end;
  hence thesis by A1,Th12;
end;

Lm14: for s being 0-started State of SCMPDS
 st s.a3 >= s.a1+7 & s.GBP=0 & s.a2 > 0 holds
IExec(FR,P,s) = IExec(FR,P,Initialize IExec(B3,P,s))

proof
  let s be 0-started State of SCMPDS;
  set a=GBP, b=DataLoc(s.a,2);
  assume that
A1: s.a3 >= s.a1+7 and
A2: s.a=0 and
A3: s.a2 > 0;
A4: b=intpos(0+2) by A2,SCMP_GCD:1;
  now
    let t be 0-started State of SCMPDS;
    let Q;
T: Initialize t = t by MEMSTR_0:44;
    assume that
A5: t.a3 >= t.a1+7 and
A6: t.a=s.a and
  t.b >0;

    set t1=IExec(J4,Q,t), Q1 = Q;
A13: t.a3+1 >= 7+t.a1+1 by A5,XREAL_1:6;
    thus IExec(B3,Q,t).a=t.a by A2,A5,A6,Lm12;

    thus IExec(B3,Q,t).b=t.b-1
     by A2,A4,A5,A6,Lm12;
A14: J4 is_closed_on t,Q & J4 is_halting_on t,Q by SCMPDS_6:20,21;
    t1.a6 =t.a1+1 by A2,A6,Lm11;
    then
A15: t1.a4 >= 7+t1.a6 by A2,A6,A13,Lm11;
A16: t1.a = (Initialize t1).a by SCMPDS_5:15;
A17: t1.a4 = (Initialize t1).a4 by SCMPDS_5:15;
A18: t1.a6 = (Initialize t1).a6 by SCMPDS_5:15;
A19: t1.a =0 by A2,A6,Lm11;
    then DataLoc(t1.a,6)=intpos (0+6) by SCMP_GCD:1;
    then WH is_closed_on Initialize t1,Q1 & WH is_halting_on Initialize t1,Q1
    by A19,A15,Lm9,A16,A17,A18;
    then WH is_closed_on t1,Q1 & WH is_halting_on t1,Q1 by SCMPDS_6:125,126;
    hence B2 is_closed_on t,Q & B2 is_halting_on t,Q by A14,T,SCMPDS_7:24;
    IExec(B3,Q,t).a1=t.a1+1 by A2,A5,A6,Lm12;
    hence IExec(B3,Q,t).a3>=IExec(B3,Q,t).a1+7
       by A2,A5,A6,A13,Lm12;
  end;
  hence thesis by A1,A3,A4,Th13;
end;

begin :: The Property of Insert Sort and Its Correctness

theorem
  card insert-sort (n,p0) = 23
proof
  set i1= GBP:=0, i2= (GBP,1):=0, i3= (GBP,2):=(n-1), i4= (GBP,3):=p0;
  thus card insert-sort (n,p0) =card(i1 ';' i2 ';' i3 ';' i4) + card FR by
AFINSQ_1:17
    .=card(i1 ';' i2 ';' i3)+1 + card FR by SCMP_GCD:4
    .=card(i1 ';' i2)+1+1 + card FR by SCMP_GCD:4
    .=2+1+1+card FR by SCMP_GCD:5
    .=4+(card B2+3) by SCMPDS_7:41
    .=23 by Lm6;
end;

theorem
  p0 >= 7 implies insert-sort (n,p0) is parahalting
proof
  set a=GBP, i1= a:=0, i2= (a,1):=0, i3= (a,2):=(n-1), i4= (a,3):=p0, I= i1
  ';' i2 ';' i3 ';' i4;
  assume
A1: p0 >= 7;
  now
    let s be State of SCMPDS;
    let P;
    set s1=IExec(I,P,Initialize s),
    s2=IExec(i1 ';' i2 ';' i3,P,Initialize s), P1 = P,
    s3=IExec(i1 ';' i2,P,Initialize s), s4
    =Exec(i1, Initialize s);
A5: s1.a = (Initialize s1).a by SCMPDS_5:15;
A6: s1.a1 = (Initialize s1).a1 by SCMPDS_5:15;
A7: s1.a3 = (Initialize s1).a3 by SCMPDS_5:15;
A9: I is_closed_on s,P & I is_halting_on s,P by SCMPDS_6:20,21;
A10: s4.a=0 by SCMPDS_2:45;
    then
A11: DataLoc(s4.a,1)=intpos (0+1) by SCMP_GCD:1;
A12: s3.a=Exec(i2,s4).a by SCMPDS_5:42
      .=0 by A10,A11,AMI_3:10,SCMPDS_2:46;
    then
A13: DataLoc(s3.a,2)=intpos (0+2) by SCMP_GCD:1;
A14: s3.a1=Exec(i2,s4).a1 by SCMPDS_5:42
      .=0 by A11,SCMPDS_2:46;
A15: s2.a1=Exec(i3,s3).a1 by SCMPDS_5:41
      .=0 by A14,A13,AMI_3:10,SCMPDS_2:46;
A16: s2.a=Exec(i3,s3).a by SCMPDS_5:41
      .=0 by A12,A13,AMI_3:10,SCMPDS_2:46;
    then
A17: DataLoc(s2.a,3)=intpos (0+3) by SCMP_GCD:1;
A18: s1.a3=Exec(i4,s2).a3 by SCMPDS_5:41
      .=p0 by A17,SCMPDS_2:46;
    s1.a1=Exec(i4,s2).a1 by SCMPDS_5:41
      .=0 by A15,A17,AMI_3:10,SCMPDS_2:46;
    then
A19: s1.a3 >= s1.a1+7 by A1,A18;
    s1.a=Exec(i4,s2).a by SCMPDS_5:41
      .=0 by A16,A17,AMI_3:10,SCMPDS_2:46;
    then FR is_closed_on Initialize s1,P1 & FR is_halting_on Initialize s1,P1
        by A19,Lm13,A5,A6,A7;
    then FR is_closed_on s1,P1 & FR is_halting_on s1,P1 by SCMPDS_6:125,126;
    hence insert-sort (n,p0) is_halting_on s,P by A9,SCMPDS_7:24;
  end;
  hence thesis by SCMPDS_6:21;
end;

Lm15: for s being 0-started State of SCMPDS
 st s.a4 >= 7+s.a6 & s.GBP=0 & s.a6 >0 holds
IExec(WH,P,s) =IExec(WH,P,Initialize IExec(B1,P,s))
proof
  let s be 0-started State of SCMPDS;
  set a=GBP, b=DataLoc(s.a,6);
  assume that
A1: s.a4 >= 7+s.a6 and
A2: s.a=0 and
A3: s.a6 > 0;
A4: b=intpos(0+6) by A2,SCMP_GCD:1;
A5: now
    let t be 0-started State of SCMPDS;
    let Q;
T: Initialize t = t by MEMSTR_0:44;
    assume that
A6: for x st x in {a4} holds t.x >= 7+t.b and
A7: t.a=s.a & t.b >0;
    set Bt=IExec(B1,Q,Initialize t);
A12: a4 in {a4} by TARSKI:def 1;
    then
A13: t.a4 >= 7+t.a6 by A4,A6;
    hence IExec(B1,Q,t).a=t.a by A2,A4,A7,Lm7;
    thus B1 is_closed_on t,Q & B1 is_halting_on t,Q by SCMPDS_6:20,21;
    thus IExec(B1,Q,t).b < t.b by A2,A4,A7,A13,Lm8;
    t.a4 >= 7+t.b by A6,A12;
    then Bt.a4 >= 7+Bt.a6 by A2,A4,A7,Lm8,T;

    hence for x st x in {a4} holds IExec(B1,Q,t).x
     >= 7+IExec(B1,Q,t).b by A4,T,TARSKI:def 1;

  end;
  for x st x in {a4} holds s.x >= 7+s.b by A1,A4,TARSKI:def 1;
  hence thesis by A3,A4,A5,SCMPDS_8:29;
end;

theorem Th17:
  for s being 0-started State of SCMPDS,
  f,g be FinSequence of INT, k0,k
being Element of NAT st s.(intpos 4) >= 7+s.(intpos 6) & s.GBP=0 & k=s.(intpos
  6) & k0=s.(intpos 4)-s.(intpos 6)-1 & f is_FinSequence_on s,k0 & g
is_FinSequence_on IExec(while>0(GBP,6,((GBP,5):=(intpos 4,-1)) ';' (SubFrom(GBP
,5,intpos 4,0)) ';' (if>0(GBP,5, ((GBP,5):=(intpos 4,-1)) ';' ((intpos 4,-1):=(
intpos 4,0)) ';' ((intpos 4,0 ):=(GBP,5)) ';' (AddTo(GBP,4,-1)) ';' (AddTo(GBP,
  6,-1)),Load ((GBP,6):=0)))),P,s),k0 &
   len f=len g & len f > k & f
  is_non_decreasing_on 1,k holds f,g are_fiberwise_equipotent & g
  is_non_decreasing_on 1,k+1 & (for i be Element of NAT st i>k+1 & i <= len f
  holds f.i=g.i) & for i be Element of NAT st 1 <= i & i <= k+1 holds ex j be
  Element of NAT st 1 <= j & j <= k+1 & g.i=f.j
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,
      f,g be FinSequence of INT,m,n be Element of NAT;
  assume
A1: s.a4 >= 7+s.a6 & s.a=0 & n=s.a6 & m=s.a4-s.a6-1;
  defpred P[Element of NAT] means for t be 0-started State of SCMPDS,Q
   for f1,f2 be
  FinSequence of INT st t.a4 >= 7+t.a6 & t.a=0 & $1=t.a6 & m=t.a4-t.a6-1 & f1
  is_FinSequence_on t,m & f2 is_FinSequence_on IExec(WH,Q,t),m
   & len f1=len f2 &
len f1 > $1 & f1 is_non_decreasing_on 1,$1 holds f1,f2 are_fiberwise_equipotent
  & f2 is_non_decreasing_on 1,$1+1 & (for i be Element of NAT st i>$1+1 & i <=
  len f1 holds f1.i=f2.i) & (for i be Element of NAT st 1 <= i & i <= $1+1 ex j
  be Element of NAT st 1 <= j & j <= $1+1 & f2.i=f1.j);
  assume
A2: f is_FinSequence_on s,m & g is_FinSequence_on IExec(WH,P,s),m;
A3: now
    let k be Element of NAT;
    assume
A4: P[k];
    thus P[k+1 qua Element of NAT]
    proof
      let t be 0-started State of SCMPDS,Q;
      let f1,f2 be FinSequence of INT;
T: Initialize t = t by MEMSTR_0:44;
      assume that
A5:   t.a4 >= 7+t.a6 and
A6:   t.a=0 and
A7:   k+1=t.a6 and
A8:   m=t.a4-t.a6-1 and
A9:   f1 is_FinSequence_on t,m and
A10:  f2 is_FinSequence_on IExec(WH,Q,t),m and
A11:  len f1=len f2 and
A12:  len f1 > k+1 and
A13:  f1 is_non_decreasing_on 1,k+1;
      set Bt=IExec(B1,Q,t), x=DataLoc(t.a4,-1), y=DataLoc(t.a4,0);
A20:  Bt.a=0 by A5,A6,A7,Lm7;
      m+1+(k+1) >= 7+t.a6 by A5,A7,A8;
      then
A21:  m+1 >= 7 by A7,XREAL_1:6;
A22:  x=DataLoc(m,k+1) by A7,A8
        .=intpos(m+(k+1)) by SCMP_GCD:1;
X3:  Bt.a6 = (Initialize Bt).a6 by SCMPDS_5:15;
X4:  Bt.a4 = (Initialize Bt).a4 by SCMPDS_5:15;
X5: (Initialize Bt).a = Bt.a by SCMPDS_5:15;
A23:  t.x > t.y implies Bt.x=t.y & Bt.y =t.x & Bt.a6=t.a6-1
      & Bt.a4=t.a4-1 by A5,A6,A7,Lm8;
A24:  t.x <= t.y implies Bt.x=t.x & Bt.y =t.y & Bt.a6=0
 by A5,A6,A7,Lm8;
A25:  y=intpos(m+(k+2)) by A7,A8,SCMP_GCD:1;
A26:  Bt.a4 >= 7+Bt.a6 by A5,A6,A7,Lm8;
      per cases;
      suppose
A27:    t.x > t.y;
        now
          let i be Element of NAT;
          assume
          1<=i & i <= len f2;
          hence f2.i=IExec(WH,Q,t).intpos(m+i) by A10,Def1
            .=IExec(WH,Q,Initialize Bt).intpos(m+i) by A5,A6,A7,Lm15;
        end;
        then
A28:    f2 is_FinSequence_on IExec(WH,Q,Initialize Bt),m by Def1;
A29:    k+1 < k+2 by XREAL_1:6;
        consider h be FinSequence of INT such that
A30:    len h=len f1 and
A31:    for i be Element of NAT st 1<=i & i <= len h holds h.i=Bt.
        intpos(m+ i) by Th2;
        k+1 > k by XREAL_1:29;
        then
A32:    len h > k by A12,A30,XXREAL_0:2;
A33:    now
          let i be Element of NAT;
          assume that
A34:      i <> k+1 & i<>k+2 and
A35:      1 <= i and
A36:      i <= len f1;
A37:      m+i <> t.a4-1 & m+i <> t.a4 by A7,A8,A34;
          m+i >= m+1 by A35,XREAL_1:6;
          then
A38:      m+i >= 7 by A21,XXREAL_0:2;
          thus h.i=Bt.intpos(m+i) by A30,A31,A35,A36
            .=t.intpos(m+i) by A5,A6,A7,A38,A37,Lm8
            .=f1.i by A9,A35,A36,Def1;
        end;
        now
          let i,j be Element of NAT;
          assume that
A40:      1 <= i and
A41:      i <= j and
A42:      j <= k;
A43:      j <= len f1 by A30,A32,A42,XXREAL_0:2;
          then
A44:      i <= len f1 by A41,XXREAL_0:2;
A45:      k < k+1 by XREAL_1:29;
          then
A46:      j < k+1 by A42,XXREAL_0:2;
          k+1 < k+1+1 by XREAL_1:29;
          then
A47:      k < k+1+1 by A45,XXREAL_0:2;
          j >= 1 by A40,A41,XXREAL_0:2;
          then
A48:      h.j=f1.j by A33,A42,A45,A47,A43;
          j < k+2 by A42,A47,XXREAL_0:2;
          then h.i=f1.i by A33,A40,A41,A46,A44;
          hence h.i <= h.j by A13,A40,A41,A46,A48,GRAPH_2:def 12;
        end;
        then
A49:    h is_non_decreasing_on 1,k by GRAPH_2:def 12;
A50:    len f1 >= k+1+1 by A12,INT_1:7;
A51:    1 <= k+1 by NAT_1:11;
        then
A52:    1 <= k+2 by A29,XXREAL_0:2;
        then
A53:    h.(k+2)=t.x by A25,A23,A27,A30,A31,A50;
        then
A54:    h.(k+2)=f1.(k+1) by A9,A12,A22,A51,Def1;
A55:    Bt.a4-Bt.a6-1=m by A8,A23,A27;
A56:    h.(k+1)=t.y by A12,A22,A23,A27,A30,A31,NAT_1:11;
        then h.(k+1)=f1.(k+2) by A9,A25,A52,A50,Def1;
        then
A57:    f1,h are_fiberwise_equipotent by A12,A30,A33,A51,A52,A50,A54,Th4;
A58:    h is_FinSequence_on Initialize Bt,m
         proof let i be Element of NAT;
          assume 1 <= i & i <= len h;
           then h.i=Bt.intpos(m+i) by A31;
          hence thesis by SCMPDS_5:15;
         end;
        h,f2 are_fiberwise_equipotent
         by A4,A7,A11,A20,A26,A23,A27,A30,A55,A28,A32,A49,A58,X3,X4,X5;
        hence f1,f2 are_fiberwise_equipotent by A57,CLASSES1:76;
A59:    f2 is_non_decreasing_on 1, k+1
 by A4,A7,A11,A20,A26,A23,A27,A30,A55,A58,X3,X4,X5,A28,A32,A49;
        now
          let i,j be Element of NAT;
          assume that
A60:      1 <= i and
A61:      i <= j and
A62:      j <= (k+1)+1;
          per cases by A62,NAT_1:8;
          suppose
            j <= k+1;
            hence f2.i <= f2.j by A59,A60,A61,GRAPH_2:def 12;
          end;
          suppose
A63:        j = k+1+1;
            hereby
              per cases;
              suppose
                i=j;
                hence f2.i <= f2.j;
              end;
              suppose
                i<>j;
                then i < j by A61,XXREAL_0:1;
                then i <= k+1 by A63,NAT_1:13;
                then consider mm be Element of NAT such that
A64:            1 <= mm and
A65:            mm <= k+1 and
A66:            f2.i=h.mm by A4,A7,A11,A20,A26,A23,A27,A30,A55,A58,A28,A32,A49
,A60,X3,X4,X5;
A67:            f2.j=h.(k+2) by A4,A7,A11,A20,A26,A23,A27,A30,A55,A58,A28,A32
,A49,A29,A50,A63,X3,X4,X5;
                hereby
                  per cases;
                  suppose
                    mm=k+1;
                    hence
                    f2.i <= f2.j by A12,A22,A23,A24,A30,A31,A53,A64,A66,A67;
                  end;
                  suppose
A68:                mm<>k+1;
                    mm < k+2 by A29,A65,XXREAL_0:2;
                    then mm < len h by A30,A50,XXREAL_0:2;
                    then
A69:                h.mm=f1.mm by A30,A33,A29,A64,A65,A68;
                    f2.j=f1.(k+1) by A9,A12,A22,A51,A53,A67,Def1;
                    hence f2.i <= f2.j by A13,A64,A65,A66,A69,GRAPH_2:def 12;
                  end;
                end;
              end;
            end;
          end;
        end;
        hence f2 is_non_decreasing_on 1,(k+1)+1 by GRAPH_2:def 12;
        hereby
          let i be Element of NAT;
          assume that
A70:      i>(k+1)+1 and
A71:      i <= len f1;
A72:      k+1 < k+1+1 by XREAL_1:29;
          then
A73:      i > k+1 by A70,XXREAL_0:2;
          1 <= k+1 by NAT_1:11;
          then
A74:      1 <= i by A73,XXREAL_0:2;
          thus f2.i=h.i by A4,A7,A11,A20,A26,A23,A27,A30,A55,A58,A28,A32,A49
,A71,A73,X3,X4,X5
            .=f1.i by A33,A70,A71,A72,A74;
        end;
        hereby
          let i be Element of NAT;
          assume that
A75:      1 <= i and
A76:      i <= (k+1)+1;
          per cases;
          suppose
A77:        i=k+1+1;
            take j=k+1;
            thus 1 <= j by NAT_1:11;
            thus j <= (k+1)+1 by NAT_1:11;
            thus f2.i=f1.j by A4,A7,A11,A20,A26,A23,A27,A30,A55,A58,A28,A32,A49
,A29,A50,A54,A77,X3,X4,X5;
          end;
          suppose
            i<>k+1+1;
            then i < k+1+1 by A76,XXREAL_0:1;
            then i <= k+1 by NAT_1:13;
            then consider mm be Element of NAT such that
A78:        1 <= mm and
A79:        mm <= k+1 and
A80:        f2.i=h.mm by A4,A7,A11,A20,A26,A23,A27,A30,A55,A58,A28,A32,A49,A75
,X3,X4,X5;
            hereby
A81:          k+2=(k+1)+1;
              per cases;
              suppose
A82:            mm=k+1;
                take j=k+2;
                thus 1 <= j by A81,NAT_1:11;
                thus j <= k+1+1;
                thus f2.i=f1.j by A9,A25,A52,A50,A56,A80,A82,Def1;
              end;
              suppose
A83:            mm<>k+1;
                take mm;
                thus 1 <= mm by A78;
                thus mm <= k+1+1 by A29,A79,XXREAL_0:2;
                mm < k+2 by A29,A79,XXREAL_0:2;
                then mm < len f1 by A50,XXREAL_0:2;
                hence f2.i=f1.mm by A33,A29,A78,A79,A80,A83;
              end;
            end;
          end;
        end;
      end;
      suppose
A84:    t.x <= t.y;
A85:    now
          let i be Nat;
          assume that
A86:      i>=1 and
A87:      i <= len f1;
A88:      i in NAT by ORDINAL1:def 12;
          then
A89:      f1.i=t.intpos(m+i) by A9,A86,A87,Def1;
      Bt.DataLoc(Bt.a,6) =0 by A20,A24,A84,SCMP_GCD:1;
          then
B90:      (Initialize Bt).DataLoc(Bt.a,6) =0 by SCMPDS_5:15;
          m+i >= m+1 by A86,XREAL_1:6;
          then
A91:      m+i >= 7 by A21,XXREAL_0:2;
H2: (Initialize Bt).intpos(m+i) = Bt.intpos(m+i) by SCMPDS_5:15;
H3: (Initialize Bt).DataLoc((Initialize Bt).GBP,6) <= 0 by B90,SCMPDS_5:15;
          per cases;
          suppose
A93:        m+i=t.a4-1;
            hence f1.i=IExec(WH,Q,Initialize Bt).x
             by A7,A8,A22,A24,A84,A89,H2,H3,SCMPDS_8:23
              .=IExec(WH,Q,Initialize t).x by A5,A6,A7,Lm15,T
              .=f2.i by A7,A8,A10,A11,A12,A22,A86,A93,Def1,T;
          end;
          suppose
A94:        m+i=t.a4;
            hence f1.i=IExec(WH,Q,Initialize Bt).y
             by A7,A8,A25,A24,A84,A89,H2,H3,SCMPDS_8:23
              .=IExec(WH,Q,Initialize t).y by A5,A6,A7,Lm15,T
              .=f2.i by A7,A8,A10,A11,A25,A86,A87,A94,Def1,T;
          end;
          suppose
            m+i<>t.a4-1 & m+i<>t.a4;
            hence f1.i=Bt.intpos (m+i)
             by A5,A6,A7,A91,A89,Lm8
              .=IExec(WH,Q,Initialize Bt).intpos (m+i) by H2,H3,SCMPDS_8:23
              .=IExec(WH,Q,Initialize t).intpos (m+i) by A5,A6,A7,Lm15,T
              .=f2.i by A10,A11,A88,A86,A87,Def1,T;
          end;
        end;
        then
A95:    f1=f2 by A11,FINSEQ_1:14;
        thus f1,f2 are_fiberwise_equipotent by A11,A85,FINSEQ_1:14;
        now
          let i, j be Element of NAT;
          assume that
A96:      1 <= i and
A97:      i <= j and
A98:      j <= (k+1)+1;
          per cases by A98,NAT_1:8;
          suppose
            j <= k+1;
            hence f1.i <= f1.j by A13,A96,A97,GRAPH_2:def 12;
          end;
          suppose
A99:        j = k+1+1;
            hereby
              per cases;
              suppose
                i=j;
                hence f1.i <= f1.j;
              end;
              suppose
                i<>j;
                then i < j by A97,XXREAL_0:1;
                then i <= k+1 by A99,NAT_1:13;
                then
A100:            f1.i <= f1.(k+1) by A13,A96,GRAPH_2:def 12;
                1<=k+1 by NAT_1:11;
                then
A101:            f1.(k+1)=t.x by A9,A12,A22,Def1;
                1<=(k+1)+1 & j<=len f1 by A12,A99,INT_1:7,NAT_1:11;
                then f1.j=t.y by A9,A25,A99,Def1;
                hence f1.i <= f1.j by A84,A100,A101,XXREAL_0:2;
              end;
            end;
          end;
        end;
        hence f2 is_non_decreasing_on 1,(k+1)+1 by A95,GRAPH_2:def 12;
        thus for i be Element of NAT st i>(k+1)+1 & i <= len f1 holds f1.i=f2.
        i by A11,A85,FINSEQ_1:14;
        thus for i be Element of NAT st 1 <= i & i <= (k+1)+1 ex j be Element
        of NAT st 1 <= j & j <= (k+1)+1 & f2.i=f1.j by A95;
      end;
    end;
  end;
A102: P[0 qua Element of NAT]
  proof
    let t be 0-started State of SCMPDS, Q;
    let f1,f2 be FinSequence of INT;
T: Initialize t = t by MEMSTR_0:44;
    assume that
    t.a4 >= 7+t.a6 and
A103: t.a=0 & 0=t.a6 and
    m=t.a4-t.a6-1 and
A104: f1 is_FinSequence_on t,m and
A105: f2 is_FinSequence_on IExec(WH,Q,t),m and
A106: len f1=len f2 and
    len f1 > 0 and
    f1 is_non_decreasing_on 1,0;
A107: t.DataLoc(t.a,6) =0 by A103,SCMP_GCD:1;
A108: now
      let i be Nat;
      assume
A109: 1 <= i & i <= len f1;
A110: i in NAT by ORDINAL1:def 12;
      hence f1.i=t.intpos(m+i) by A104,A109,Def1
        .=IExec(WH,Q,Initialize t).intpos(m+i) by A107,T,SCMPDS_8:23
        .=f2.i by A105,A106,A110,A109,Def1,T;
    end;
    hence f1,f2 are_fiberwise_equipotent by A106,FINSEQ_1:14;
    thus f2 is_non_decreasing_on 1,0+1 by GRAPH_2:63;
    thus for i be Element of NAT st i>0+1 & i <= len f1 holds f1.i=f2.i by A108
;
    f1=f2 by A106,A108,FINSEQ_1:14;
    hence thesis;
  end;
A111: for k be Element of NAT holds P[k] from NAT_1:sch 1(A102,A3);
  assume
  len f= len g & len f > n & f is_non_decreasing_on 1,n;
  hence thesis by A1,A2,A111;
end;

Lm16: for s being 0-started State of SCMPDS,
f,g be FinSequence of INT, p0,n being
Element of NAT st s.GBP=0 & s.a2=n-1 & s.a3=p0+1 & s.a1=0 & p0 >= 6 & f
is_FinSequence_on s,p0 & g is_FinSequence_on IExec(FR,P,s),p0
 & len f=n & len g =
n holds f,g are_fiberwise_equipotent & g is_non_decreasing_on 1,n
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,
      f,g be FinSequence of INT,p0,n be Element of NAT;
  assume that
A1: s.a=0 and
A2: s.a2=n-1 and
A3: s.a3=p0+1 and
A4: s.a1=0 and
A5: p0 >= 6 and
A6: f is_FinSequence_on s,p0 & g is_FinSequence_on IExec(FR,P,s),p0 and
A7: len f=n and
A8: len g = n;
  per cases;
  suppose
A9: n=0;
    then g={} by A8;
    hence f,g are_fiberwise_equipotent by A7,A9;
    thus thesis by A9,GRAPH_2:63;
  end;
  suppose
    n<>0;
    then n >= 1+0 by INT_1:7;
    then n-1 >= 0 by XREAL_1:19;
    then reconsider n1=n-1 as Element of NAT by INT_1:3;
    defpred P[Nat] means for t be 0-started State of SCMPDS,Q
    for f1,f2 be FinSequence of INT, m be Element of NAT
     st t.a=0 & t.a2+t.a1=n-1 & t.a2=$1 & m=n-t.a2 & p0=t.a3-t.
    a1-1 & f1 is_FinSequence_on t,p0
     & f2 is_FinSequence_on IExec(FR,Q,t),p0 & f1
    is_non_decreasing_on 1,m & len f1=n & len f2 = n holds f1,f2
    are_fiberwise_equipotent & f2 is_non_decreasing_on 1,n;
A10: s.a2+s.a1=n-1+0 & 1=n-s.a2 by A2,A4;
A11: now
      let k be Element of NAT;
      assume
A12:  P[k];
      now
        let t be 0-started State of SCMPDS,
            f1,f2 be FinSequence of INT, m be Element of NAT;
        let Q;
        assume that
A13:    t.a=0 and
A14:    t.a2+t.a1=n-1 and
A15:    t.a2=k+1 and
A16:    m=n-t.a2 and
A17:    p0=t.a3-t.a1-1 and
A18:    f1 is_FinSequence_on t,p0 and
A19:    f2 is_FinSequence_on IExec(FR,Q,t),p0 and
A20:    f1 is_non_decreasing_on 1,m & len f1=n and
A21:    len f2 = n;
        set t1=IExec(J4,Q,t), Bt=IExec(B3,Q,t), Q1 = Q;
A28: t1.a = (Initialize t1).a by SCMPDS_5:15;
A29: t1.a4 = (Initialize t1).a4 by SCMPDS_5:15;
A30: t1.a6 = (Initialize t1).a6 by SCMPDS_5:15;
A31:    t1.a4 =t.a3+1 by A13,Lm11;
        p0+(t.a1+1)=t.a3 by A17;
        then t.a3 >= 6+(t.a1+1) by A5,XREAL_1:6;
        then
A32:    t.a3 >= 6+1+t.a1;
        then
A33:    Bt.a=0 by A13,Lm12;
A34:    Bt.a2=t.a2-1 by A13,A32,Lm12;
        then
A35:    n-Bt.a2=m+1 by A16;
A36:    Bt.a1=t.a1+1 by A13,A32,Lm12;
        then
A37:    Bt.a2+Bt.a1=n-1 by A14,A34;
        Bt.a3=t.a3+1 by A13,A32,Lm12;
        then
A38:    Bt.a3-Bt.a1-1=p0 by A17,A36;
A39:    t1.a6 =t.a1+1 by A13,Lm11;
        then
A40:    p0=t1.a4-t1.a6-1 by A17,A31;
        now
          let i be Element of NAT;
          assume
          1 <= i & i <= len f2;
          hence f2.i=IExec(FR,Q,t).intpos(p0+i) by A19,Def1
            .= IExec(FR,Q,Initialize Bt).intpos(p0+i)
             by A13,A15,A32,Lm14;
        end;
        then
A42:    f2 is_FinSequence_on IExec(FR,Q,Initialize Bt),p0 by Def1;
B48:    now
A43:      p0+1 >= 6+1 by A5,XREAL_1:6;
          let i be Element of NAT;
          assume that
A44:      1 <= i and
A45:      i <= len f1;
          p0+1 <= p0+i by A44,XREAL_1:6;
          then
A46:      p0+i >= 7 by A43,XXREAL_0:2;
          thus f1.i=t.intpos(p0+i) by A18,A44,A45,Def1
            .= t1.intpos(p0+i)
             by A13,A46,Lm11;
        end;
        t1.a4=p0+(t1.a6+1) by A17,A31,A39;
        then t1.a4 >= 6+(t1.a6+1) by A5,XREAL_1:6;
        then
A49:    t1.a4 >= 6+1+t1.a6;
        m+(k+1)=n by A15,A16;
        then
A50:    n > 0+m by XREAL_1:6;
        consider h be FinSequence of INT such that
A51:    len h=n and
A52:    for i be Element of NAT st 1<=i & i <= len h holds h.i=IExec(
        WH,Q1,Initialize t1) .intpos(p0+i) by Th2;
A54:    h is_FinSequence_on IExec(WH,Q1,Initialize t1),p0 by A52,Def1;
B59:    now
A55:      p0+1 >= 6+1 by A5,XREAL_1:6;
          let i be Element of NAT;
          assume that
A56:      1 <= i and
A57:      i <= len h;
          p0+1 <= p0+i by A56,XREAL_1:6;
          then p0+i >= 7 by A55,XXREAL_0:2;
          then
A58:      p0+i > 2 by XXREAL_0:2;
          thus h.i=IExec(WH,Q1,Initialize t1).intpos(p0+i) by A52,A56,A57
            .= Bt.intpos(p0+i) by A13,A32,A58,Lm12;
        end;
A60: f1 is_FinSequence_on (Initialize t1),p0
  proof let i be Element of NAT;
   assume 1 <= i & i <= len f1;
    then f1.i=t1.intpos(p0+i) by B48;
   hence thesis by SCMPDS_5:15;
  end;
A61:    t1.a =0 by A13,Lm11;
        then
A62:    f1,h are_fiberwise_equipotent by A14,A16,A17,A20,A31,A51,A40,A49,A54
,A50,Th17,A29,A30,A28,A60;

A63:    h is_non_decreasing_on 1,m +1 by A14,A16,A17,A20,A31,A51,A40,A49,A54
,A50,Th17,A29,A30,A28,A60,A61;
X1: (Initialize Bt).a = Bt.a by SCMPDS_5:15;
X2: (Initialize Bt).a1 = Bt.a1 by SCMPDS_5:15;
X3: (Initialize Bt).a2 = Bt.a2 by SCMPDS_5:15;
X4: (Initialize Bt).a3 = Bt.a3 by SCMPDS_5:15;
X5: h is_FinSequence_on (Initialize Bt),p0
 proof let i be Element of NAT such that
Z: 1 <= i & i <= len h;
  thus h.i=Bt.intpos(p0+i) by Z,B59
       .=(Initialize Bt).intpos(p0+i) by SCMPDS_5:15;
 end;
        then h,f2 are_fiberwise_equipotent by A12,A15,A16,A21,A51,A33,A37,A35
,A38,A42,A63,X1,X2,X3,X4;
        hence f1,f2 are_fiberwise_equipotent by A62,CLASSES1:76;

        thus f2 is_non_decreasing_on 1,n by A12,A15,A16,A21,A51,A63,A33,A37,A35
,A38,A42,X1,X2,X3,X4,X5;
      end;
      hence P[k+1];
    end;
A64: P[0 qua Nat]
    proof
      let t be 0-started State of SCMPDS, Q;
      let f1,f2 be FinSequence of INT, m be Element of
      NAT;
T:   Initialize t = t by MEMSTR_0:44;
      assume that
A65:  t.a=0 and
      t.a2+t.a1=n-1 and
A66:  t.a2=0 and
A67:  m=n-t.a2 and
      p0=t.a3-t.a1-1 and
A68:  f1 is_FinSequence_on t,p0 and
A69:  f2 is_FinSequence_on IExec(FR,Q,t),p0 and
A70:  f1 is_non_decreasing_on 1,m and
A71:  len f1=n & len f2 = n;
A72:  t.DataLoc(t.a,2)=0 by A65,A66,SCMP_GCD:1;
A73:  now
        let i be Nat;
        assume
A74:    1 <= i & i <= len f2;
A75:    i in NAT by ORDINAL1:def 12;
        hence f2.i=IExec(FR,Q,Initialize t).intpos(p0+i) by A69,A74,Def1,T
          .=t.intpos(p0+i) by A72,SCMPDS_7:47
          .=f1.i by A68,A71,A75,A74,Def1;
      end;
      hence f1,f2 are_fiberwise_equipotent by A71,FINSEQ_1:14;
      thus thesis by A66,A67,A70,A71,A73,FINSEQ_1:14;
    end;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A64,A11);
    then
A76: P[n1];
    p0=s.a3-s.a1-1 & f is_non_decreasing_on 1,1 by A3,A4,GRAPH_2:63;
    hence thesis by A1,A6,A7,A8,A10,A76;
  end;
end;

theorem
  for s being 0-started State of SCMPDS,f,g be FinSequence of INT,p0,
      n being Element of NAT
     st p0 >= 6 & len f=n & len g = n & f is_FinSequence_on s,p0 &
     g is_FinSequence_on IExec(insert-sort(n,p0+1),P,s),p0
      holds f,g are_fiberwise_equipotent & g is_non_decreasing_on 1,n
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,f,g be FinSequence of INT,p0,
      n be Element of NAT;
  assume that
A1: p0 >= 6 and
A2: len f=n & len g = n and
A3: f is_FinSequence_on s,p0 and
A4: g is_FinSequence_on IExec(insert-sort(n,p0+1),P,s),p0;
A5: p0+1 >= 6+1 by A1,XREAL_1:6;
  set i1= GBP:=0, i2= (GBP,1):=0, i3= (GBP,2):=(n-1), i4= (GBP,3):=(p0+1);
  set I4=i1 ';' i2 ';' i3 ';' i4, t1=IExec(I4,P,s),
   t2=IExec(i1 ';' i2 ';' i3,P,s), t3=IExec(i1 ';' i2,P,s), t4=Exec(i1,s);
A6: t4.a=0 by SCMPDS_2:45;
  then
A7: DataLoc(t4.a,1)=intpos (0+1) by SCMP_GCD:1;
A8: t3.a =Exec(i2, t4).a by SCMPDS_5:42
    .=0 by A6,A7,AMI_3:10,SCMPDS_2:46;
  then
A9: DataLoc(t3.a,2)=intpos (0+2) by SCMP_GCD:1;
A10: t2.a =Exec(i3, t3).a by SCMPDS_5:41
    .=0 by A8,A9,AMI_3:10,SCMPDS_2:46;
  then
A11: DataLoc(t2.a,3)=intpos (0+3) by SCMP_GCD:1;
A13: now
    let i be Element of NAT;
    assume
A14: i > 3;
    then
A15: i > 1 by XXREAL_0:2;
    thus t3.intpos i =Exec(i2, t4).intpos i by SCMPDS_5:42
      .=t4.intpos i by A7,A15,AMI_3:10,SCMPDS_2:46
      .=s.intpos i by A14,AMI_3:10,SCMPDS_2:45;
  end;
A16: now
    let i be Element of NAT;
    assume
A17: i > 3;
    then
A18: i > 2 by XXREAL_0:2;
    thus t2.intpos i =Exec(i3, t3).intpos i by SCMPDS_5:41
      .=t3.intpos i by A9,A18,AMI_3:10,SCMPDS_2:46
      .=s.intpos i by A13,A17;
  end;
  now
    let i be Element of NAT;
    assume that
A19: 1 <= i and
A20: i <= len f;
    set pi=p0+i;
    pi >= p0+1 by A19,XREAL_1:6;
    then pi >= 7 by A5,XXREAL_0:2;
    then
A21: pi > 3 by XXREAL_0:2;
    thus (Initialize t1).intpos pi = t1.intpos pi by SCMPDS_5:15
      .=Exec(i4, t2).intpos pi by SCMPDS_5:41
      .=t2.intpos pi by A11,A21,AMI_3:10,SCMPDS_2:46
      .=s.intpos pi by A16,A21
      .=f.i by A3,A19,A20,Def1;
  end;
  then
A22: f is_FinSequence_on Initialize t1,p0 by Def1;
A23: t3.a1 =Exec(i2, t4).a1 by SCMPDS_5:42
    .=0 by A7,SCMPDS_2:46;
A24: t2.a1 =Exec(i3, t3).a1 by SCMPDS_5:41
    .=0 by A23,A9,AMI_3:10,SCMPDS_2:46;
A25: I4 is_closed_on s,P & I4 is_halting_on s,P by SCMPDS_6:20,21;
A26: t1.a =Exec(i4, t2).a by SCMPDS_5:41
    .=0 by A10,A11,AMI_3:10,SCMPDS_2:46;
A27: t2.a2 =Exec(i3, t3).a2 by SCMPDS_5:41
    .=n-1 by A9,SCMPDS_2:46;
A28: t1.a3 =Exec(i4, t2).a3 by SCMPDS_5:41
    .=p0+1 by A11,SCMPDS_2:46;
A29:  t1.a3 = (Initialize t1).a3 by SCMPDS_5:15;
A30:  t1.a1 = (Initialize t1).a1 by SCMPDS_5:15;
A31:  t1.a = (Initialize t1).a by SCMPDS_5:15;
A32:  t1.a2 = (Initialize t1).a2 by SCMPDS_5:15;
A33: t1.a1 =Exec(i4, t2).a1 by SCMPDS_5:41
    .=0 by A24,A11,AMI_3:10,SCMPDS_2:46;
  then t1.a3 >= t1.a1+7 by A28,A5;
  then FR is_closed_on Initialize t1,P & FR is_halting_on Initialize t1,P
     by A26,Lm13,A29,A30,A31;
  then
A34: FR is_closed_on t1,P & FR is_halting_on t1,P by SCMPDS_6:125,126;
  now
    let i be Element of NAT;
    assume
    1 <= i & i <= len g;
    hence g.i=IExec(I4 ';' FR,P,s).intpos(p0+i) by A4,Def1
      .=IExec(FR,P,Initialize t1).intpos(p0+i) by A25,A34,SCMPDS_7:30;
  end;
  then
A35: g is_FinSequence_on IExec(FR,P,Initialize t1),p0 by Def1;
  t1.a2 =Exec(i4, t2).a2 by SCMPDS_5:41
    .=n-1 by A27,A11,AMI_3:10,SCMPDS_2:46;
  hence thesis by A1,A2,A26,A33,A28,A22,A35,Lm16,A29,A30,A31,A32;
end;

