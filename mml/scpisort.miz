:: Insert Sort on SCMPDS
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies NUMBERS, SCMPDS_2, SUBSET_1, FINSEQ_1, FSM_1, XXREAL_0, FUNCT_1,
      SCMP_GCD, ARYTM_3, GRAPH_2, NAT_1, RELAT_1, CLASSES1, AMI_2, SCMPDS_8,
      AMI_1, SCMFSA6B, SCMPDS_4, UNIALG_2, SCMFSA7B, TURING_1, SCMFSA_7, INT_1,
      CARD_1, SCMPDS_7, AMI_3, ARYTM_1, VALUED_1, TARSKI, SCMFSA6A, FUNCT_4,
      CIRCUIT2, GRAPHSP, MSUALG_1, XBOOLE_0, SCMISORT, SCMFSA_9, SCMFSA8B,
      COMPLEX1, SCPISORT, ORDINAL1, PARTFUN1, SCMNORM, SCMFSA6C, SCMPDS_5;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, RELAT_1, FUNCT_1,
      PARTFUN1, VALUED_1, XCMPLX_0, FUNCT_4, INT_1, NAT_1, COMPLEX1, EXTPRO_1,
      AMI_1, COMPOS_1,
      AMI_2, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD,
      DOMAIN_1, FINSEQ_1, SCMPDS_7, SCMPDS_8, GRAPH_2, CLASSES1, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, INT_2, SCM_1, SCMPDS_4, SCMPDS_5,
      SCMPDS_6, SCMP_GCD, SCMPDS_7, SCMPDS_8, CLASSES1, PRE_POLY,
      GRAPH_2, AMI_1, AMI_2;
 registrations SETFAM_1, RELAT_1, FUNCT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, MEMBERED, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMPDS_7,
      SCMPDS_8, XBOOLE_0, VALUED_0, ORDINAL1, CARD_1, VALUED_1, AMI_1,
      GRFUNC_1, COMPOS_1, AFINSQ_1, EXTPRO_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions SCMPDS_2, SCMP_GCD, AMI_3, COMPOS_1, EXTPRO_1, AMI_1;
 theorems AMI_1, AMI_3, NAT_1, TARSKI, FUNCT_4, INT_1, SCMPDS_2, GRFUNC_1,
      SCMPDS_4, SCMPDS_5, SCMPDS_6, ENUMSET1, SCMP_GCD, SCMPDS_7, SCMPDS_8,
      ABSVALUE, FINSEQ_1, FINSEQ_2, RFINSEQ, RELAT_1, XBOOLE_1, XREAL_1,
      ORDINAL1, XXREAL_0, GRAPH_2, AMI_2, ZFMISC_1, FINSEQ_3, CLASSES1,
      AFINSQ_1, COMPOS_1, FUNCT_7, EXTPRO_1;
 schemes NAT_1, FINSEQ_1;

begin :: Preliminaries

reserve x for Int_position,
  n,p0 for Element of NAT;

definition
  let f be FinSequence of INT,s be State of SCMPDS,m be Element of NAT;
  pred f is_FinSequence_on s,m means
  :Def1:
  for i be Element of NAT st 1 <= i
  & i <= len f holds f.i=s.intpos(m+i);
end;

Lm1: for f being FinSequence of INT,k be Element of NAT holds f
is_non_decreasing_on k,k

proof
  let f be FinSequence of INT,k be Element of NAT;
  now
    let i, j be Element of NAT;
    assume that
A1: k <= i & i <= j and
A2: j <= k;
    k <= j by A1,XXREAL_0:2;
    then j=k by A2,XXREAL_0:1;
    hence f.i <= f.j by A1,XXREAL_0:1;
  end;
  hence thesis by GRAPH_2:def 13;
end;

theorem Th1:
  for f being FinSequence of INT,m,n be Element of NAT st m >= n
  holds f is_non_decreasing_on m,n
proof
  let f be FinSequence of INT,m,n be Element of NAT;
  assume
A1: m>=n;
  per cases by A1,XXREAL_0:1;
  suppose
    m=n;
    hence thesis by Lm1;
  end;
  suppose
A2: m>n;
    now
      let i, j be Element of NAT;
      assume that
A3:   m <= i & i <= j and
A4:   j <= n;
      assume
      f.i > f.j;
      m <= j by A3,XXREAL_0:2;
      hence contradiction by A2,A4,XXREAL_0:2;
    end;
    hence thesis by GRAPH_2:def 13;
  end;
end;

theorem Th2:
  for s being State of SCMPDS,n,m be Element of NAT holds ex f be
  FinSequence of INT st len f=n & for i be Element of NAT st 1<=i & i <= len f
  holds f.i=s.intpos(m+i)
proof
  let s be State of SCMPDS,n,m be Element of NAT;
  deffunc U(Nat) = s.intpos (m+$1);
  consider f being FinSequence such that
A1: len f = n & for i be Nat st i in dom f holds f.i=U(i) from FINSEQ_1:
  sch 2;
  now
    let i be Nat;
    reconsider a = i as Element of NAT by ORDINAL1:def 13;
    assume
    i in dom f;
    then f.i = s.intpos (m+a) by A1;
    hence f.i in INT by INT_1:def 2;
  end;
  then reconsider f as FinSequence of INT by FINSEQ_2:14;
  take f;
  thus len f=n by A1;
  hereby
    let i be Element of NAT;
    assume
    1<=i & i <= len f;
    then i in dom f by FINSEQ_3:27;
    hence f.i = s.intpos (m+i) by A1;
  end;
end;

theorem
  for s being State of SCMPDS,n,m be Element of NAT holds ex f be
  FinSequence of INT st len f=n & f is_FinSequence_on s,m
proof
  let s be State of SCMPDS,n,m be Element of NAT;
  consider f be FinSequence of INT such that
A1: len f=n and
A2: for i be Element of NAT st 1<=i & i <= len f holds f.i=s.intpos(m+i)
  by Th2;
  take f;
  thus len f=n by A1;
  thus thesis by A2,Def1;
end;

theorem Th4:
  for f,g be FinSequence of INT,m,n be Element of NAT st 1<=n & n
  <= len f & 1<=m & m <= len f & len f=len g & f.m=g.n & f.n=g.m & (for k be
  Element of NAT st k<>m & k<>n & 1<=k & k <= len f holds f.k=g.k) holds f,g
  are_fiberwise_equipotent
proof
  let f,g be FinSequence of INT,m,n be Element of NAT;
  assume that
A1: 1<=n & n <= len f and
A2: 1<=m & m <= len f and
A3: len f=len g and
A4: f.m=g.n & f.n=g.m and
A5: for k be Element of NAT st k<>m & k<>n & 1<=k & k <= len f holds f.k
  =g.k;
A6: m in Seg (len f) by A2,FINSEQ_1:3;
A7: Seg (len f) = dom f by FINSEQ_1:def 3;
A8: now
    let k be set;
    assume that
A9: k<>m & k<>n and
A10: k in dom f;
    reconsider i=k as Element of NAT by A10;
    1 <= i & i <= len f by A7,A10,FINSEQ_1:3;
    hence f.k=g.k by A5,A9;
  end;
  n in dom f & dom f=dom g by A1,A3,A7,FINSEQ_1:3,def 3;
  hence thesis by A4,A7,A6,A8,RFINSEQ:41;
end;
set A = NAT, D = SCM-Data-Loc;

theorem Th5: ::see SCMPDS_8:2
  for s1,s2 being State of SCMPDS st (for a being Int_position
  holds s1.a = s2.a) holds Dstate(s1)=Dstate(s2)
proof
  let s1,s2 be State of SCMPDS;
  assume
  for a being Int_position holds s1.a = s2.a;
  then DataPart s1 = DataPart s2 by SCMPDS_4:23;
  hence thesis by SCMPDS_8:2;
end;

theorem Th6: :: see SCMPDS_7:50
  for s being State of SCMPDS, I being halt-free Program of
SCMPDS, j being parahalting shiftable Instruction of SCMPDS st I is_closed_on s
& I is_halting_on s holds (I ';' j) is_closed_on s & (I ';' j) is_halting_on s
proof
  let s be State of SCMPDS,I be halt-free Program of SCMPDS,j be parahalting
  shiftable Instruction of SCMPDS;
  set Mj = Load j;
A1: Mj is_closed_on IExec(I,s) & Mj is_halting_on IExec(I,s) by SCMPDS_6:34,35;
  assume
  I is_closed_on s & I is_halting_on s;
  then (I ';' Mj) is_closed_on s & (I ';' Mj) is_halting_on s by A1,SCMPDS_7:43
;
  hence thesis by SCMPDS_4:def 5;
end;

theorem :: see SCMPDS_7:49
  for s being State of SCMPDS, I being halt-free Program of SCMPDS, J
  being shiftable parahalting Program of SCMPDS,a be Int_position st I
is_closed_on s & I is_halting_on s holds IExec(I ';' J, s).a = IExec(J,IExec(I,
  s)).a
proof
  let s be State of SCMPDS,I be halt-free Program of SCMPDS, J be shiftable
  parahalting Program of SCMPDS,a be Int_position;
A1: J is_closed_on IExec(I,s) & J is_halting_on IExec(I,s) by SCMPDS_6:34,35;
  assume
  I is_closed_on s & I is_halting_on s;
  hence thesis by A1,SCMPDS_7:49;
end;

theorem :: see SCMPDS_7:49
  for s being State of SCMPDS, I being halt-free parahalting Program
  of SCMPDS , J being shiftable Program of SCMPDS,a be Int_position st J
is_closed_on IExec(I,s) & J is_halting_on IExec(I,s) holds IExec(I ';' J, s).a
  = IExec(J,IExec(I,s)).a
proof
  let s be State of SCMPDS,I be halt-free parahalting Program of SCMPDS, J
  be shiftable Program of SCMPDS,a be Int_position;
A1: I is_closed_on s & I is_halting_on s by SCMPDS_6:34,35;
  assume
  J is_closed_on IExec(I,s) & J is_halting_on IExec(I,s);
  hence thesis by A1,SCMPDS_7:49;
end;

theorem :: SCMPDS_7:43
  for s being State of SCMPDS, I being Program of SCMPDS,J being
shiftable parahalting Program of SCMPDS st I is_closed_on s & I is_halting_on s
  holds I ';' J is_closed_on s & I ';' J is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be shiftable parahalting
  Program of SCMPDS;
A1: J is_closed_on IExec(I,s) & J is_halting_on IExec(I,s) by SCMPDS_6:34,35;
  assume
  I is_closed_on s & I is_halting_on s;
  hence thesis by A1,SCMPDS_7:43;
end;

theorem :: SCMPDS_7:43
  for s being State of SCMPDS, I being parahalting Program of SCMPDS,J
  being shiftable Program of SCMPDS st J is_closed_on IExec(I,s) & J
is_halting_on IExec(I,s) holds I ';' J is_closed_on s & I ';' J is_halting_on s
proof
  let s be State of SCMPDS,I be parahalting Program of SCMPDS,J be shiftable
  Program of SCMPDS;
A1: I is_closed_on s & I is_halting_on s by SCMPDS_6:34,35;
  assume
  J is_closed_on IExec(I,s) & J is_halting_on IExec(I,s);
  hence thesis by A1,SCMPDS_7:43;
end;

theorem :: SCMPDS_7:43
  for s being State of SCMPDS, I being Program of SCMPDS, j being
  parahalting shiftable Instruction of SCMPDS st I is_closed_on s & I
  is_halting_on s holds I ';' j is_closed_on s & I ';' j is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS,j be shiftable parahalting
  Instruction of SCMPDS;
A1: Load j is_closed_on IExec(I,s) & Load j is_halting_on IExec(I,s) by
SCMPDS_6:34,35;
  assume
  I is_closed_on s & I is_halting_on s;
  then I ';' Load j is_closed_on s & I ';' Load j is_halting_on s by A1,
SCMPDS_7:43;
  hence thesis by SCMPDS_4:def 5;
end;

Lm2: for a be Int_position,i be Integer,n be Element of NAT, I be Program of
SCMPDS holds card stop for-down(a,i,n,I)= card I+4

proof

  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;

  thus card stop for-down(a,i,n,I)= card for-down(a,i,n,I) +1 by SCMPDS_5:7
    .= card I +3+1 by SCMPDS_7:60
    .= card I + 4;
end;

Lm3: for a be Int_position,i be Integer,n be Element of NAT, I be Program of
SCMPDS holds for-down(a,i,n,I)= ((a,i)<=0_goto (card I +3)) ';' (I ';' AddTo(a,
i,-n) ';' goto -(card I+2))

proof

  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;

  set i1=(a,i)<=0_goto (card I +3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
  thus for-down(a,i,n,I) = i1 ';' I ';' i2 ';' i3 by SCMPDS_7:def 2
    .= i1 ';' (I ';' i2 ';' i3) by SCMPDS_7:15;
end;

Lm4: for I being Program of SCMPDS,a being Int_position,i being Integer, n be
Element of NAT holds Shift(I ';' AddTo(a,i,-n),1) c= for-down(a,i,n,I)

proof

  let I be Program of SCMPDS,a be Int_position,i be Integer, n be Element of
  NAT;

  set i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
A1: for-down(a,i,n,I) = i1 ';' I ';' i2 ';' i3 by SCMPDS_7:def 2
    .= i1 ';' (I ';' i2) ';' i3 by SCMPDS_4:51
    .= Load i1 ';' (I ';' i2) ';' i3 by SCMPDS_4:def 4
    .= Load i1 ';' (I ';' i2) ';' Load i3 by SCMPDS_4:def 5;
  card Load i1=1 by SCMPDS_5:6;
  hence thesis by A1,SCMPDS_7:16;
end;

begin :: Computing the Execution Result(ProgramPart(of),of) For-loop Program by Loop-Invariant

scheme
  ForDownHalt { P[set], s() -> State of SCMPDS,I() -> halt-free shiftable
Program of SCMPDS, a() -> Int_position,i() -> Integer,n() -> Element of NAT}: (
P[s()] or not P[s()]) & for-down(a(),i(),n(),I()) is_closed_on s() & for-down(a
  (),i(),n(),I()) is_halting_on s()
provided
A1: n() > 0 and
A2: P[Dstate s()] and
A3: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) > 0 holds IExec(I() ';' AddTo(a(),i(),-n()),t).a()=t.a() & IExec(I
() ';' AddTo(a(),i(),-n()),t).DataLoc(s().a(),i()) =t.DataLoc(s().a(),i())-n()
& I() is_closed_on t & I() is_halting_on t & P[Dstate(IExec(I() ';' AddTo(a(),i
(),-n()),t))]
proof
  set i1=(a(),i())<=0_goto (card I()+3), J=I() ';' AddTo(a(),i(),-n()), i3=
  goto -(card I()+2);
  set b=DataLoc(s().a(),i());
  set FOR=for-down(a(),i(),n(),I()), pFOR=stop FOR,
  pJ= stop J;
  defpred Q[Nat] means for t be State of SCMPDS st t.b <= $1 & P[Dstate t] & t
  .a()=s().a() holds FOR is_closed_on t & FOR is_halting_on t;
A4: for k be Element of NAT st Q[k] holds Q[k + 1]
  proof
    let k be Element of NAT;
    assume
A5: Q[k];
    now
      let t be State of SCMPDS;
      assume
A6:   t.b <= k+1;
      assume
A7:   P[Dstate t];
      assume
A8:   t.a()=s().a();
      per cases;
      suppose
        t.b <= 0;
        hence FOR is_closed_on t & FOR is_halting_on t by A8,SCMPDS_7:63;
      end;
      suppose
A9:     t.b > 0;
A10:    dom ProgramPart t = A by COMPOS_1:34;
A11:    not a() in dom (t | A) by A10,SCMPDS_2:53;
A12:    not b in dom (t | A) by A10,SCMPDS_2:53;
A13:     0 in dom pFOR by COMPOS_1:135;
        -(-n()) > 0 by A1;
        then -n() < 0;
        then -n() <= -1 by INT_1:21;
        then
A14:    -n()+t.b <= -1+t.b by XREAL_1:8;
        t.b-1 <= k by A6,XREAL_1:22;
        then
A15:    -n()+t.b <= k by A14,XXREAL_0:2;
        set t2 = Initialize t +* pJ, t3 = Initialize t +* pFOR,
        t4 = Comput(ProgramPart(t3),t3,1),
        Jt = IExec(J,t);
A16:     Initialize t +* pJ = t +* Initialize pJ by COMPOS_1:125;
A17:     Initialize t +* pFOR = t +* Initialize pFOR by COMPOS_1:125;
A18:    Initialize pJ c= t2 by A16,FUNCT_4:26;
A19:    FOR = i1 ';' (J ';' i3) by Lm3;
A20:    Comput(ProgramPart(t3),t3,0+1) = Following(ProgramPart t3,
Comput(ProgramPart(t3),t3,0)) by EXTPRO_1:4
          .= Following(ProgramPart t3,t3) by EXTPRO_1:3
          .= Exec(i1,t3) by A19,A17,SCMPDS_6:22;
A21:    DataPart t2 = DataPart t3 by COMPOS_1:138,FUNCT_7:134;
        now
          let x;
          thus t2.x = t3.x by A21,SCMPDS_4:23
            .= t4.x by A20,SCMPDS_2:68;
        end;
        then
A22:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
A23:    Jt.b=t.b-n() by A3,A7,A8,A9;
A24:    Jt.a()=t.a() by A3,A7,A8,A9;
        set m2=LifeSpan(ProgramPart(t2),t2), t5=Comput(ProgramPart(t4),t4,m2),
l1= (card J + 1);
A25:    card J = card I()+1 by SCMP_GCD:8;
A26:    dom ProgramPart t = A by COMPOS_1:34;
A27:    not b in dom Initialize pFOR by SCMPDS_4:31;
        not a() in dom Initialize pFOR by SCMPDS_4:31;
        then
A28:    t3.DataLoc(t3.a(),i())= t3.b by A8,A17,FUNCT_4:12
          .= t.b by A27,A17,FUNCT_4:12;
A29:    IC t3 = 0 by SCMPDS_6:21;
A30:    I() is_closed_on t & I() is_halting_on t by A3,A7,A8,A9;
        then
A31:    J is_closed_on t by Th6;
        then
A32:    J is_closed_on t2 by SCMPDS_6:38;
        card I() + 2 < card I() + 3 by XREAL_1:8;
        then
A33:    l1 in dom FOR by A25,SCMPDS_7:61;
        set m3=m2 +1;
        set t6=Comput(ProgramPart(t3),t3,m3);
 ProgramPart t3 = ProgramPart t4
by AMI_1:123;
 then
A34:    t6=t5 by EXTPRO_1:5;
A35:     Initialize t2+*pJ = t2+*Initialize pJ by COMPOS_1:125;
A36:    J is_halting_on t by A30,Th6;
        then
A37:    ProgramPart t2 halts_on t2 by SCMPDS_6:def 3;
        t2 = Initialize t2+*pJ by A18,A35,FUNCT_4:79;
        then ProgramPart(Initialize t2+*pJ) halts_on Initialize t2+*pJ
           by A36,SCMPDS_6:def 3;
        then
A38:    J is_halting_on t2 by SCMPDS_6:def 3;
        set m4=m3+1, t7=Comput(ProgramPart(t3),t3,m4);
A39:    IExec(J,t) = Result(ProgramPart(t2),t2) +* t | A by SCMPDS_4:def 8;
        FOR c= Initialize pFOR & Initialize pFOR c= t3
         by A17,FUNCT_4:26,SCMPDS_6:17;
        then
A40:    FOR c= t3 by XBOOLE_1:1;
        Shift(J,1) c= FOR by Lm4;
        then Shift(J,1) c= t3 by A40,XBOOLE_1:1;
        then
A41:    Shift(J,1) c= t4 by AMI_1:81;
A42:    IC t4 = t4.IC SCMPDS
          .= succ IC t3 by A9,A20,A28,SCMPDS_2:68
          .= (0+1) by A29;
        then
A43:    DataPart Comput(ProgramPart(t2),t2,m2) = DataPart t5 by A25,A18,A38,A32
,A22,A41,SCMPDS_7:36;
        then
A44:    DataPart t5 = DataPart(Result(ProgramPart(t2),t2)) by A37,EXTPRO_1:23
          .= DataPart(Result(ProgramPart(t2),t2) +* t | A) by A26,AMI_2:29
,FUNCT_4:76,SCMPDS_2:100
          .= DataPart Jt by SCMPDS_4:def 8;
A45:    IC t5=l1 by A25,A18,A38,A32,A42,A22,A41,SCMPDS_7:36;
        then
A46:    CurInstr(ProgramPart t6,t6)=t5.l1 by A34,COMPOS_1:38
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=FOR.l1 by A33,A40,GRFUNC_1:8
          .=i3 by A25,SCMPDS_7:62;
A47:    t7 = Following(ProgramPart t3,t6) by EXTPRO_1:4
          .= Exec(i3,t6) by A46,AMI_1:123;
        InsCode i3=0 by SCMPDS_2:21;
        then InsCode i3 in {0,4,5,6} by ENUMSET1:def 2;
        then Dstate(t7)=Dstate(t6) by A47,SCMPDS_8:3
          .=Dstate(Jt) by A44,A34,SCMPDS_8:2;
        then
A48:    P[Dstate t7] by A3,A7,A8,A9;
        IC t7=t7.IC SCMPDS
          .=ICplusConst(t6,0-(card I()+2)) by A47,SCMPDS_2:66
          .= 0 by A25,A45,A34,SCMPDS_7:1;
        then
A49:    Initialize t7 +* pFOR=t7 by SCMPDS_7:37;
        t5.b=Comput(ProgramPart(t2),t2,m2).b by A43,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).b by A37,EXTPRO_1:23
          .=t.b - n() by A23,A39,A12,FUNCT_4:12;
        then
A50:    t7.b=-n()+t.b by A34,A47,SCMPDS_2:66;
        t5.a()=Comput(ProgramPart(t2),t2,m2).a() by A43,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).a() by A37,EXTPRO_1:23
          .=s().a() by A8,A24,A39,A11,FUNCT_4:12;
        then
A51:    t7.a()=s().a() by A34,A47,SCMPDS_2:66;
        then
A52:    FOR is_closed_on t7 by A5,A48,A50,A15;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m4;
            then
A53:        k <= m3 by INT_1:20;
            hereby
              per cases by A53,NAT_1:8;
              suppose
A54:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pFOR by A13
,A29,EXTPRO_1:3;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A55:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(ProgramPart(t2),t2,kn) as Element
of NAT;
A56: ProgramPart t3 = ProgramPart t4
by AMI_1:123;
                    kn < k by A55,XREAL_1:31;
                    then kn < m2 by A54,XXREAL_0:2;
                    then IC Comput(ProgramPart(t2),t2,kn) + 1 = IC Comput(
ProgramPart(t4),t4,kn) by A25,A18,A38,A32,A42,A22,A41,SCMPDS_7:34;
                    then
A57:                IC Comput(ProgramPart(t3),t3,k) = (lm+1) by A55,A56,
EXTPRO_1:5;
                    IC Comput(ProgramPart(t2),t2,kn) in dom pJ by A31,
SCMPDS_6:def 2;
                    then lm < card pJ by AFINSQ_1:70;
                    then lm < card J+1 by SCMPDS_5:7;
                    then
A58:                lm+1 <= card J +1 by INT_1:20;
                    card I() + 2 < card I() + 4 by XREAL_1:8;
                    then lm+1 < card I() +4 by A25,A58,XXREAL_0:2;
                    then lm+1 < card pFOR by Lm2;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pFOR by A57,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A59:            k=m3;
                l1 in dom pFOR by A33,SCMPDS_6:18;
                hence
                IC Comput(ProgramPart(t3),t3,k) in dom pFOR by A25,A18,A38,A32
,A42,A22,A41,A34,A59,SCMPDS_7:36;
              end;
            end;
          end;
          suppose
            k >= m4;
            then consider nn be Nat such that
A60:        k=m4+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
 ProgramPart t3 = ProgramPart t7
by AMI_1:123;
then
            Comput(ProgramPart(t3),t3,k)=
            Comput(ProgramPart(Initialize t7+*pFOR),Initialize t7+*pFOR,
nn) by A49,A60,EXTPRO_1:5;
            hence IC Comput(ProgramPart(t3),t3,k) in dom pFOR by A52,
SCMPDS_6:def 2;
          end;
        end;
        hence FOR is_closed_on t by SCMPDS_6:def 2;
        FOR is_halting_on t7 by A5,A51,A48,A50,A15;
        then ProgramPart t7 halts_on t7 by A49,SCMPDS_6:def 3;
        then ProgramPart t3 halts_on t7 by AMI_1:123;
        then ProgramPart t3 halts_on t3 by EXTPRO_1:22;
        hence FOR is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  thus P[s()] or not P[s()];
A61: Q[0] by SCMPDS_7:63;
A62: for k being Element of NAT holds Q[k] from NAT_1:sch 1(A61,A4);
  per cases;
  suppose
    s().b <= 0;
    hence thesis by SCMPDS_7:63;
  end;
  suppose
    s().b > 0;
    then reconsider m=s().b as Element of NAT by INT_1:16;
    Q[m] by A62;
    hence thesis by A2;
  end;
end;

scheme
  ForDownExec { P[set], s() -> State of SCMPDS,I() -> halt-free shiftable
Program of SCMPDS, a() -> Int_position,i() -> Integer,n() -> Element of NAT}: (
P[s()] or not P[s()]) & IExec(for-down(a(),i(),n(),I()),s()) = IExec(for-down(a
  (),i(),n(),I()),IExec(I() ';' AddTo(a(),i(),-n()),s()))
provided
A1: n() > 0 and
A2: s().DataLoc(s().a(),i()) > 0 and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) > 0 holds IExec(I() ';' AddTo(a(),i(),-n()),t).a()=t.a() & IExec(I
() ';' AddTo(a(),i(),-n()),t).DataLoc(s().a(),i()) =t.DataLoc(s().a(),i())-n()
& I() is_closed_on t & I() is_halting_on t & P[Dstate(IExec(I() ';' AddTo(a(),i
(),-n()),t))]
proof
  set i1=(a(),i())<=0_goto (card I()+3), J=I() ';' AddTo(a(),i(),-n()), i3=
  goto -(card I()+2);
  set FOR=for-down(a(),i(),n(),I()), pFOR = stop FOR,
  s1= Initialize s() +* pFOR, ps= ProgramPart s();
  set sJ= Initialize s() +* stop J, mJ=LifeSpan(ProgramPart(sJ),sJ),
  m1=mJ+2, s2=Initialize IExec(J,s()) +* pFOR, m2=
  LifeSpan(ProgramPart(s2),s2);
A5: Initialize s() +* stop J = s() +* Initialize stop J by COMPOS_1:125;
A6: Initialize IExec(J,s()) +* pFOR = IExec(J,s()) +* Initialize pFOR
       by COMPOS_1:125;
A7: Initialize s() +* pFOR = s() +* Initialize pFOR by COMPOS_1:125;
A8: Initialize stop J c= sJ by A5,FUNCT_4:26;
A9: I() is_closed_on s() & I() is_halting_on s() by A2,A3,A4;
  then J is_closed_on s() by Th6;
  then
A10: J is_closed_on sJ by SCMPDS_6:38;
A11: J is_halting_on s() by A9,Th6;
  then
A12: ProgramPart sJ halts_on sJ by SCMPDS_6:def 3;
A13: Initialize sJ+*stop J = sJ+*Initialize stop J by COMPOS_1:125;
  sJ = Initialize sJ+*stop J by A8,A13,FUNCT_4:79;
  then ProgramPart(Initialize sJ+*stop J) halts_on Initialize sJ+*stop J
   by A11,SCMPDS_6:def 3;
  then
A14: J is_halting_on sJ by SCMPDS_6:def 3;
A15: FOR = i1 ';' (J ';' i3) by Lm3;
A16: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by EXTPRO_1:4
    .= Following(ProgramPart s1,s1) by EXTPRO_1:3
    .= Exec(i1,s1) by A15,A7,SCMPDS_6:22;
  set m3=mJ +1;
  set s4 = Comput(ProgramPart(s1),s1,1);
  set b=DataLoc(s().a(),i());
A17: card J = card I()+1 by SCMP_GCD:8;
  set s6=Comput(ProgramPart(s1),s1,m3);
A18: not b in dom Initialize pFOR by SCMPDS_4:31;
  not a() in dom Initialize pFOR by SCMPDS_4:31;
  then
A19: s1.DataLoc(s1.a(),i())=s1.b by A7,FUNCT_4:12
    .= s().b by A18,A7,FUNCT_4:12;
  set s5=Comput(ProgramPart(s4),s4,mJ), l1= (card J + 1);
  card I() + 2 < card I() + 3 by XREAL_1:8;
  then
A20: l1 in dom FOR by A17,SCMPDS_7:61;
 ProgramPart s1 = ProgramPart s4
by AMI_1:123;
 then
A21: s6=s5 by EXTPRO_1:5;
A22: DataPart sJ = DataPart s1 by COMPOS_1:138,FUNCT_7:134;
  now
    let x;
    thus sJ.x = s1.x by A22,SCMPDS_4:23
      .= s4.x by A16,SCMPDS_2:68;
  end;
  then
A23: DataPart sJ = DataPart s4 by SCMPDS_4:23;
A24: IC s1 = 0 by SCMPDS_6:21;
  FOR c= Initialize pFOR & Initialize pFOR c= s1
    by A7,FUNCT_4:26,SCMPDS_6:17;
  then
A25: FOR c= s1 by XBOOLE_1:1;
  Shift(J,1) c= FOR by Lm4;
  then Shift(J,1) c= s1 by A25,XBOOLE_1:1;
  then
A26: Shift(J,1) c= s4 by AMI_1:81;
  set m0=LifeSpan(ProgramPart(s1),s1);
A27: IExec(J,s()) = Result(ProgramPart(sJ),sJ) +* s() | A by SCMPDS_4:def 8;
  thus P[s()] or not P[s()];
A28: dom ProgramPart s() = A by COMPOS_1:34;
  set m4=m3+1, s7=Comput(ProgramPart(s1),s1,m4);
A29: dom ps = dom s() /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
A30: IC s4 = s4.IC SCMPDS
    .= succ IC s1 by A2,A16,A19,SCMPDS_2:68
    .= (0+1) by A24;
  then
A31: IC s5=l1 by A17,A8,A14,A10,A23,A26,SCMPDS_7:36;
  then
A32: CurInstr(ProgramPart s6,s6)=s5.l1 by A21,COMPOS_1:38
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=FOR.l1 by A20,A25,GRFUNC_1:8
    .=i3 by A17,SCMPDS_7:62;
A33: s7 = Following(ProgramPart s1,s6) by EXTPRO_1:4
    .= Exec(i3,s6) by A32,AMI_1:123;
A34: DataPart Comput(ProgramPart(sJ),sJ,mJ) = DataPart s5 by A17,A8,A14,A10,A30
,A23,A26,SCMPDS_7:36;
  now
    let x be Int_position;
    not x in dom Initialize pFOR by SCMPDS_4:31;
    then
A35: s2.x=IExec(J,s()).x by A6,FUNCT_4:12;
A36: not x in dom (s() | A) by A28,SCMPDS_2:53;
    s5.x=Comput(ProgramPart(sJ),sJ,mJ).x by A34,SCMPDS_4:23
      .=(Result(ProgramPart(sJ),sJ)).x by A12,EXTPRO_1:23
      .=IExec(J,s()).x by A27,A36,FUNCT_4:12;
    hence s7.x=s2.x by A21,A33,A35,SCMPDS_2:66;
  end;
  then
A37: DataPart s7 = DataPart s2 by SCMPDS_4:23;
A38: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(s().
  a(),i()) > 0 holds IExec(I() ';' AddTo(a(),i(),-n()),t).a()=t.a() & IExec(I()
';' AddTo(a(),i(),-n()),t).DataLoc(s().a(),i()) =t.DataLoc(s().a(),i())-n() & I
() is_closed_on t & I() is_halting_on t & P[Dstate(IExec(I() ';' AddTo(a(),i(),
  -n()),t))] by A4;
A39: P[Dstate s()] by A3;
  (P[s()] or not P[s()]) & for-down(a(),i(),n(),I()) is_closed_on s() &
  for-down(a(),i(),n(),I()) is_halting_on s() from ForDownHalt(A1,A39,A38);
  then
A40: ProgramPart s1 halts_on s1 by SCMPDS_6:def 3;
  set Es=IExec(J,s()), bj=DataLoc(Es.a(),i());
  Es.a()=s().a() by A2,A3,A4;
  then
A41: for t being State of SCMPDS st P[Dstate t] & t.a()=Es.a() & t.bj > 0
holds IExec(J,t).a()=t.a() & IExec(J,t).bj=t.bj-n() & I() is_closed_on t & I()
  is_halting_on t & P[Dstate IExec(J,t) ] by A4;
A42: P[Dstate Es] by A2,A3,A4;
  (P[Es] or not P[Es]) & FOR is_closed_on Es & FOR is_halting_on Es from
  ForDownHalt(A1,A42,A41);
  then
A43: ProgramPart s2 halts_on s2 by SCMPDS_6:def 3;
  IC s7=s7.IC SCMPDS
    .=ICplusConst(s6,0-(card I()+2)) by A33,SCMPDS_2:66
    .= 0 by A17,A31,A21,SCMPDS_7:1;
  then
A44: IC s2 =IC Comput(ProgramPart(s1),s1,m1) by SCMPDS_6:21;
A45: IExec(J,s()) | A= (Result(ProgramPart(sJ),sJ) +* ps) | A
      by SCMPDS_4:def 8
    .= ps by A29,FUNCT_4:24;
A46: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m1)
by AMI_1:123;
A47:  ProgramPart s2
     = ProgramPart(Result(ProgramPart(sJ),sJ) +* ps +* Initialize pFOR)
        by A6,SCMPDS_4:def 8
    .= ProgramPart(Result(ProgramPart(sJ),sJ) +* ps)+*
    ProgramPart Initialize pFOR
     by FUNCT_4:75
    .= ps +* ProgramPart Initialize pFOR by A29,FUNCT_4:24
    .= ProgramPart s1 by A7,FUNCT_4:75
    .= ProgramPart Comput(ProgramPart(s1),s1,m1) by AMI_1:123;
  then
A48: Comput(ProgramPart(s1),s1,m1)=s2 by A37,A44,SCMPDS_7:7;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1))=i1
   by A15,A46,A6,SCMPDS_6:22;
  then m0 > m1 by A40,SCMPDS_6:2,30;
  then consider nn be Nat such that
A49: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
A50: ProgramPart s1 = ProgramPart s2
by A47,AMI_1:123;
  then
  Comput(ProgramPart(s1),s1,m1+m2) = Comput(ProgramPart(s2),s2,m2) by A48,
EXTPRO_1:5;
  then CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,m1+m2))
   = halt SCMPDS by A43,A50,EXTPRO_1:def 14;
  then m1 + m2 >= m0 by A40,EXTPRO_1:def 14;
  then
A51: m2 >= nn by A49,XREAL_1:8;
A52: Comput(ProgramPart(s1),s1,m0) = Comput(ProgramPart(s2),s2,nn) by A48,A49,
A50
,EXTPRO_1:5;
  then CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,nn))
   =halt SCMPDS by A40,A50,EXTPRO_1:def 14;
  then nn >= m2 by A43,EXTPRO_1:def 14;
  then nn=m2 by A51,XXREAL_0:1;
  then Result(ProgramPart(s1),s1) = Comput(ProgramPart(s2),s2,m2) by A40,A52,
EXTPRO_1:23;
  hence IExec(FOR,s()) = Comput(ProgramPart(s2),s2,m2) +* ps
     by SCMPDS_4:def 8
    .= Result(ProgramPart(s2),s2) +* IExec(J,s()) | A by A43,A45,EXTPRO_1:23
    .= IExec(FOR,IExec(J,s())) by SCMPDS_4:def 8;
end;

scheme
  ForDownEnd { P[set], s() -> State of SCMPDS,I() -> halt-free shiftable
Program of SCMPDS, a() -> Int_position,i() -> Integer,n() -> Element of NAT}: (
P[s()] or not P[s()]) & IExec(for-down(a(),i(),n(),I()),s()).DataLoc(s().a(),i(
  )) <= 0 & P[Dstate IExec(for-down(a(),i(),n(),I()),s())]
provided
A1: n() > 0 and
A2: P[Dstate s()] and
A3: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) > 0 holds IExec(I() ';' AddTo(a(),i(),-n()),t).a()=t.a() & IExec(I
() ';' AddTo(a(),i(),-n()),t).DataLoc(s().a(),i()) =t.DataLoc(s().a(),i())-n()
& I() is_closed_on t & I() is_halting_on t & P[Dstate(IExec(I() ';' AddTo(a(),i
(),-n()),t))]
proof
  set b=DataLoc(s().a(),i()), FR=for-down(a(),i(),n(),I());
  defpred Q[Nat] means for t be State of SCMPDS st t.b <= $1 & t.a()=s().a() &
  P[Dstate t] holds IExec(FR,t).b <= 0 & P[Dstate IExec(FR,t)];
A4: Q[0]
  proof
    let t be State of SCMPDS;
    assume that
A5: t.b <= 0 & t.a()=s().a() and
A6: P[Dstate t];
    thus IExec(FR,t).b <= 0 by A5,SCMPDS_7:66;
    for x be Int_position holds IExec(FR,t).x = t.x by A5,SCMPDS_7:66;
    hence thesis by A6,Th5;
  end;
A7: now
    let k be Element of NAT;
    assume
A8: Q[k];
    now
      let u be State of SCMPDS;
      assume that
A9:   u.b <= k+1 and
A10:  u.a()=s().a() and
A11:  P[Dstate u];
      per cases;
      suppose
        u.b <= 0;
        hence IExec(FR,u).b <= 0 & P[Dstate IExec(FR,u)] by A4,A10,A11;
      end;
      suppose
A12:    u.b > 0;
        set Ad=AddTo(a(),i(),-n());
        set Iu=IExec(I() ';' Ad,u);
A13:    Iu.a()=s().a() & P[Dstate Iu] by A3,A10,A11,A12;
        Iu.b=u.b-n() by A3,A10,A11,A12;
        then Iu.b+1 <= u.b by A1,INT_1:20,XREAL_1:46;
        then Iu.b+1 <= k+1 by A9,XXREAL_0:2;
        then
A14:    Iu.b <= k by XREAL_1:8;
A15:    P[Dstate u] by A11;
A16:    for t being State of SCMPDS st P[Dstate t] & t.a()=u.a() & t.
DataLoc(u.a(),i()) > 0 holds IExec(I() ';' Ad,t).a()=t.a() & IExec(I() ';' Ad,t
).DataLoc(u.a(),i()) =t.DataLoc(u.a(),i())-n() & I() is_closed_on t & I()
        is_halting_on t & P[Dstate(IExec(I() ';' Ad,t))] by A3,A10;
A17:    u.DataLoc(u.a(),i()) > 0 by A10,A12;
        (P[u] or not P[u]) & IExec(FR,u) = IExec(FR,Iu) from ForDownExec(
        A1,A17,A15,A16);
        hence IExec(FR,u).b <= 0 & P[Dstate IExec(FR,u)] by A8,A14,A13;
      end;
    end;
    hence Q[k+1];
  end;
A18: for k being Element of NAT holds Q[k] from NAT_1:sch 1(A4,A7);
  thus P[s()] or not P[s()];
  per cases;
  suppose
    s().b > 0;
    then reconsider m=s().b as Element of NAT by INT_1:16;
    Q[m] by A18;
    hence thesis by A2;
  end;
  suppose
    s().b <= 0;
    hence thesis by A2,A4;
  end;
end;

theorem Th12:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a,x,y be Int_position, i,c be Integer,n be Element of NAT st
n > 0 & s.x >= s.y +c & for t be State of SCMPDS st t.x >= t.y +c & t.a=s.a & t
  .DataLoc(s.a,i) > 0 holds IExec(I ';' AddTo(a,i,-n),t).a=t.a & IExec(I ';'
  AddTo(a,i,-n),t).DataLoc(s.a,i)=t.DataLoc(s.a,i)-n & I is_closed_on t & I
is_halting_on t & IExec(I ';' AddTo(a,i,-n),t).x>=IExec(I ';' AddTo(a,i,-n),t).
y+c holds for-down(a,i,n,I) is_closed_on s & for-down(a,i,n,I) is_halting_on s
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a,x,y
  be Int_position, i,c be Integer,n be Element of NAT;
  set b=DataLoc(s.a,i), J=I ';' AddTo(a,i,-n);
  assume
A1: n > 0;
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.x >= t.y+c;
  assume
A2: s.x >= s.y +c;
A3: P[Dstate s]
  proof
    take t=Dstate s;
    thus t=Dstate s;
    t.x>= s.y+c by A2,SCMPDS_8:4;
    hence thesis by SCMPDS_8:4;
  end;
  assume
A4: for t be State of SCMPDS st t.x >= t.y +c & t.a=s.a & t.b > 0 holds
IExec(J,t).a=t.a & IExec(J,t).b=t.b-n & I is_closed_on t & I is_halting_on t &
  IExec(J,t).x>=IExec(J,t).y+c;
A5: now
    let t be State of SCMPDS;
    assume that
A6: P[Dstate t] and
A7: t.a=s.a & t.b > 0;
    consider v be State of SCMPDS such that
A8: v=Dstate t and
A9: v.x>=v.y+c by A6;
    t.x=v.x by A8,SCMPDS_8:4;
    then
A10: t.x>=t.y+c by A8,A9,SCMPDS_8:4;
    hence IExec(J,t).a=t.a & IExec(J,t).b=t.b-n & I is_closed_on t & I
    is_halting_on t by A4,A7;
    thus P[Dstate IExec(J,t)]
    proof
      take v=Dstate IExec(J,t);
      thus v=Dstate IExec(J,t);
      v.x=IExec(J,t).x by SCMPDS_8:4;
      then v.x>=IExec(J,t).y+c by A4,A7,A10;
      hence thesis by SCMPDS_8:4;
    end;
  end;
  (P[s] or not P[s]) & for-down(a,i,n,I) is_closed_on s & for-down(a,i,n,
  I) is_halting_on s from ForDownHalt(A1,A3,A5);
  hence thesis;
end;

theorem Th13:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a,x,y be Int_position, i,c be Integer,n be Element of NAT st
n > 0 & s.x >= s.y +c & s.DataLoc(s.a,i) > 0 &
for t be State of SCMPDS st t.x
>= t.y +c & t.a=s.a & t.DataLoc(s.a,i) > 0 holds IExec(I ';' AddTo(a,i,-n),t).a
  =t.a & IExec(I ';' AddTo(a,i,-n),t).DataLoc(s.a,i)=t.DataLoc(s.a,i)-n & I
  is_closed_on t & I is_halting_on t & IExec(I ';' AddTo(a,i,-n),t).x>=IExec(I
';' AddTo(a,i,-n),t).y+c
holds IExec(for-down(a,i,n,I),s) = IExec(for-down(a,i,
  n,I),IExec(I ';' AddTo(a,i,-n),s))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a,x,y
  be Int_position, i,c be Integer,n be Element of NAT;
  set b=DataLoc(s.a,i), J=I ';' AddTo(a,i,-n);
  assume
A1: n > 0;
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.x>=t.y+c;
  assume
A2: s.x >= s.y +c;
A3: P[Dstate s]
  proof
    take t=Dstate s;
    thus t=Dstate s;
    t.x>= s.y+c by A2,SCMPDS_8:4;
    hence thesis by SCMPDS_8:4;
  end;
  assume
A4: s.b > 0;
  assume
A5: for t be State of SCMPDS st t.x >= t.y +c & t.a=s.a & t.b > 0 holds
IExec(J,t).a=t.a & IExec(J,t).b=t.b-n & I is_closed_on t & I is_halting_on t &
  IExec(J,t).x>=IExec(J,t).y+c;
A6: now
    let t be State of SCMPDS;
    assume that
A7: P[Dstate t] and
A8: t.a=s.a & t.b > 0;
    consider v be State of SCMPDS such that
A9: v=Dstate t and
A10: v.x>=v.y+c by A7;
    t.x=v.x by A9,SCMPDS_8:4;
    then
A11: t.x>=t.y+c by A9,A10,SCMPDS_8:4;
    hence IExec(J,t).a=t.a & IExec(J,t).b=t.b-n & I is_closed_on t & I
    is_halting_on t by A5,A8;
    thus P[Dstate IExec(J,t) ]
    proof
      take v=Dstate IExec(J,t);
      thus v=Dstate IExec(J,t);
      v.x=IExec(J,t).x by SCMPDS_8:4;
      then v.x>=IExec(J,t).y+c by A5,A8,A11;
      hence thesis by SCMPDS_8:4;
    end;
  end;
  (P[s] or not P[s]) & IExec(for-down(a,i,n,I),s) = IExec(for-down(a,i,n,
  I),IExec(I ';' AddTo(a,i,-n),s)) from ForDownExec(A1,A4,A3,A6);
  hence thesis;
end;

theorem
  for s being 0-started State of SCMPDS,I being halt-free shiftable Program of
SCMPDS , a be Int_position, i be Integer,n be Element of NAT st s.DataLoc(s.a,i
) > 0 & n > 0 & card I > 0 & a <> DataLoc(s.a,i) & (for t be State of SCMPDS st
t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i)=t.DataLoc(s.a,i) & I
  is_closed_on t & I is_halting_on t) holds for-down(a,i,n,I) is_closed_on s &
  for-down(a,i,n,I) is_halting_on s
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS,
      a be Int_position, i be Integer,n be Element of NAT;
  assume that
A1: s.DataLoc(s.a,i) > 0 & n > 0 & card I > 0 & a <> DataLoc(s.a,i) and
A2: for t be State of SCMPDS st t.a=s.a holds IExec(I,t).a=t.a & IExec(
  I,t).DataLoc(s.a,i)=t.DataLoc(s.a,i) & I is_closed_on t & I is_halting_on t;
  for t being 0-started State of SCMPDS st
    (for x be Int_position st x in {} holds t
.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i)=t.DataLoc(
  s.a,i) & I is_closed_on t & I is_halting_on t & for y be Int_position st y in
  {} holds IExec(I,t).y=t.y by A2;
  hence thesis by A1,SCMPDS_7:67;
end;

begin :: A Program for Insert Sort

:: n -> intpos 2,  x1 -> intpos 3

definition
  let n,p0 be Element of NAT;
  func insert-sort(n,p0) -> Program of SCMPDS equals
  ((GBP:=0) ';' ((GBP,1):=0
) ';' ((GBP,2):=(n-1)) ';' ((GBP,3):=p0)) ';' for-down(GBP,2,1, AddTo(GBP,3,1)
  ';' ((GBP,4):=(GBP,3)) ';' AddTo(GBP,1,1) ';' ((GBP,6):=(GBP,1)) ';' while>0(
GBP,6, ((GBP,5):=(intpos 4,-1)) ';' SubFrom(GBP,5,intpos 4,0) ';' if>0(GBP,5, (
(GBP,5):=(intpos 4,-1)) ';' ((intpos 4,-1):=(intpos 4,0)) ';' ((intpos 4,0 ):=(
  GBP,5)) ';' AddTo(GBP,4,-1) ';' AddTo(GBP,6,-1), Load ((GBP,6):=0) ) ) );
  coherence;
end;

set j1= AddTo(GBP,3,1), j2= (GBP,4):=(GBP,3), j3= AddTo(GBP,1,1), j4= (GBP,6)
:=(GBP,1), k1= (GBP,5):=(intpos 4,-1), k2= SubFrom(GBP,5,intpos 4,0), k3= (GBP,
5):=(intpos 4,-1), k4= (intpos 4,-1):=(intpos 4,0), k5= (intpos 4,0 ):=(GBP,5),
k6= AddTo(GBP,4,-1), k7= AddTo(GBP,6,-1), FA= Load ((GBP,6):=0), TR= ((GBP,5):=
(intpos 4,-1)) ';' ((intpos 4,-1):=(intpos 4,0)) ';' ((intpos 4,0 ):=(GBP,5))
';' (AddTo(GBP,4,-1)) ';' (AddTo(GBP,6,-1)), IF= if>0(GBP,5, TR,FA), B1= ((GBP,
5):=(intpos 4,-1)) ';' (SubFrom(GBP,5,intpos 4,0)) ';' (if>0(GBP,5, TR,FA)), WH
= while>0(GBP,6,B1), J4= j1 ';' j2 ';' j3 ';' j4, B2= J4 ';' WH, FR= for-down(
GBP,2,1,B2);

Lm5: card B1=10
proof
  thus card B1=card (k1 ';' k2)+card IF by AFINSQ_1:20
    .=2+card IF by SCMP_GCD:9
    .=2+(card TR+card FA+2) by SCMPDS_6:79
    .=2+(card (k3 ';' k4 ';' k5 ';' k6) +1+card FA+2) by SCMP_GCD:8
    .=2+(card (k3 ';' k4 ';' k5)+1 +1+card FA+2) by SCMP_GCD:8
    .=2+(card (k3 ';' k4)+1+1 +1+card FA+2) by SCMP_GCD:8
    .=2+(2+1+1 +1+card FA+2) by SCMP_GCD:9
    .=2+(2+1+1+1+1+2) by SCMPDS_5:6
    .=10;
end;

Lm6: card B2=16
proof
  thus card B2=card (j1 ';' j2 ';' j3 ';' j4) + card WH by AFINSQ_1:20
    .=card (j1 ';' j2 ';' j3)+1+ card WH by SCMP_GCD:8
    .=card (j1 ';' j2 )+1+1+ card WH by SCMP_GCD:8
    .=2+1+1+ card WH by SCMP_GCD:9
    .=2+1+1+(10+2) by Lm5,SCMPDS_8:17
    .=16;
end;

set a1=intpos 1, a2=intpos 2, a3=intpos 3, a4=intpos 4, a5=intpos 5,
    a6=intpos 6;

Lm7: for s being 0-started State of SCMPDS
 st s.a4 >= 7+s.a6 & s.GBP=0 & s.a6 > 0 holds
IExec(B1,s).GBP=0 & IExec(B1,s).a1=s.a1

proof
  let s be 0-started State of SCMPDS;
  set a=GBP, x=DataLoc(s.a4,-1), y=DataLoc(s.a4,0);
  assume that
A1: s.a4 >= 7+s.a6 and
A2: s.a=0 and
A3: s.a6 > 0;
A4: 7+s.a6>7+0 by A3,XREAL_1:8;
  set t0=Initialize s, t1=Exec(k1, t0), t2=IExec(k1 ';' k2,s);
A5: t0.a=0 by A2,SCMPDS_5:40;
  then
A6: DataLoc(t0.a,5)=intpos (0+5) by SCMP_GCD:5;
  then
A7: t1.a=0 by A5,AMI_3:52,SCMPDS_2:59;
  then
A8: DataLoc(t1.a,5)=intpos (0+5) by SCMP_GCD:5;
  t0.a4=s.a4 by SCMPDS_5:40;
  then
A9: t1.a4=s.a4 by A6,AMI_3:52,SCMPDS_2:59;
A10: s.a4>=1+(6+s.a6) by A1;
  then
A11: s.a4-1 >= 6+s.a6 by XREAL_1:21;

  set Fi= (a,6):=0, t02=Initialize t2, t3=IExec(k3 ';' k4 ';' k5 ';' k6,t2),
  t4=IExec(k3 ';' k4 ';' k5,t2), t5=IExec(k3 ';' k4,t2), t6=Exec(k3, t02);
A12: IExec(k3 ';' k4 ';' k5 ';' k6,t2) = IExec(k3 ';' k4 ';' k5 ';' k6,t02)
       by SCMPDS_5:48;
A13: IExec(k3 ';' k4 ';' k5,t2) = IExec(k3 ';' k4 ';' k5,t02) by SCMPDS_5:48;
A14: IExec(k3 ';' k4,t2) = IExec(k3 ';' k4,t02) by SCMPDS_5:48;
  t2.a=Exec(k2, t1).a by SCMPDS_5:47
    .=0 by A7,A8,AMI_3:52,SCMPDS_2:62;
  then
A15: t02.a=0 by SCMPDS_5:40;
  then
A16: DataLoc(t02.a,5)=intpos (0+5) by SCMP_GCD:5;
  then
A17: t6.a=0 by A15,AMI_3:52,SCMPDS_2:59;
  t2.a4=Exec(k2, t1).a4 by SCMPDS_5:47
    .=s.a4 by A9,A8,AMI_3:52,SCMPDS_2:62;
  then t02.a4=s.a4 by SCMPDS_5:40;
  then
A18: t6.a4=s.a4 by A16,AMI_3:52,SCMPDS_2:59;
A19: 6+s.a6>6+0 by A3,XREAL_1:8;
  then 0<>abs(t6.a4+-1) by A11,A18,ABSVALUE:def 1;
  then
A20: a<>DataLoc(t6.a4,-1) by ZFMISC_1:33;
  s.a4-1 > 0 by A3,A10,XREAL_1:21;
  then
A21: abs(t6.a4+-1) =s.a4-1 by A18,ABSVALUE:def 1;
  then 4<>abs(t6.a4+-1) by A11,A19,XXREAL_0:2;
  then
A22: a4<>DataLoc(t6.a4,-1) by ZFMISC_1:33;
A23: Initialize t02 = t02;
:::  then
A24: t5.a4 =Exec(k4, t6).a4 by A14,A23,SCMPDS_5:47
    .=s.a4 by A18,A22,SCMPDS_2:59;
  then 0<>abs(t5.a4+0) by A1,A4,ABSVALUE:def 1;
  then
A25: a<>DataLoc(t5.a4,0) by ZFMISC_1:33;
A26: t5.a =Exec(k4, t6).a by A14,A23,SCMPDS_5:47
    .=0 by A17,A20,SCMPDS_2:59;
A27: t4.a=Exec(k5,t5).a by A13,A14,SCMPDS_5:46
    .=0 by A26,A25,SCMPDS_2:59;
  then
A28: a<>DataLoc(t4.a,4) by AMI_3:52,SCMP_GCD:5;
  t0.a1=s.a1 by SCMPDS_5:40;
  then
A29: t1.a1=s.a1 by A6,AMI_3:52,SCMPDS_2:59;
  t2.a1=Exec(k2, t1).a1 by SCMPDS_5:47
    .=s.a1 by A29,A8,AMI_3:52,SCMPDS_2:62;
  then
A30: t02.a1=s.a1 by SCMPDS_5:40;
  then
A31: t6.a1=s.a1 by A16,AMI_3:52,SCMPDS_2:59;
A32: t3.a=Exec(k6,t4).a by A12,A13,SCMPDS_5:46
    .=0 by A27,A28,SCMPDS_2:60;
  then
A33: DataLoc(t3.a,6)=intpos (0+6) by SCMP_GCD:5;
A34: DataLoc(t02.a,6)=intpos (0+6) by A15,SCMP_GCD:5;
A35: IExec(TR,t2) = IExec(TR,t02) by SCMPDS_5:48;
  now
    per cases;
    suppose
      t2.DataLoc(t2.a,5) <= 0;
      hence IExec(IF,t2).a=IExec(FA,t2).a by SCMPDS_6:88
        .=Exec(Fi,t02).a by SCMPDS_5:45
        .=0 by A15,A34,AMI_3:52,SCMPDS_2:58;
    end;
    suppose t2.DataLoc(t2.a,5) > 0;
      hence IExec(IF,t2).a=IExec(TR,t2).a by SCMPDS_6:87
        .=Exec(k7,t3).a by A12,A35,SCMPDS_5:46
        .=0 by A32,A33,AMI_3:52,SCMPDS_2:60;
    end;
  end;
  hence IExec(B1,s).a=0 by SCMPDS_5:39;
A36: a1<>DataLoc(t4.a,4) by A27,AMI_3:52,SCMP_GCD:5;
  abs(t5.a4+0) = s.a4 by A1,A4,A24,ABSVALUE:def 1;
  then 1<>abs(t5.a4+0) by A1,A4,XXREAL_0:2;
  then
A37: a1<>DataLoc(t5.a4,0) by ZFMISC_1:33;
  1<>abs(t6.a4+-1) by A11,A19,A21,XXREAL_0:2;
  then
A38: a1<>DataLoc(t6.a4,-1) by ZFMISC_1:33;
A39: t5.a1 =Exec(k4, t6).a1 by A14,A23,SCMPDS_5:47
    .=s.a1 by A31,A38,SCMPDS_2:59;
A40: t4.a1=Exec(k5,t5).a1 by A13,A14,SCMPDS_5:46
    .=s.a1 by A39,A37,SCMPDS_2:59;
A41: t3.a1=Exec(k6,t4).a1 by A12,A13,SCMPDS_5:46
    .=s.a1 by A40,A36,SCMPDS_2:60;
  now
    per cases;
    suppose
      t2.DataLoc(t2.a,5) <= 0;
      hence IExec(IF,t2).a1=IExec(FA,t2).a1 by SCMPDS_6:88
        .=Exec(Fi,t02).a1 by SCMPDS_5:45
        .=s.a1 by A30,A34,AMI_3:52,SCMPDS_2:58;
    end;
    suppose
      t2.DataLoc(t2.a,5) > 0;
      hence IExec(IF,t2).a1=IExec(TR,t2).a1 by SCMPDS_6:87
        .=Exec(k7,t3).a1 by A12,A35,SCMPDS_5:46
        .=s.a1 by A41,A33,AMI_3:52,SCMPDS_2:60;
    end;
  end;
  hence thesis by SCMPDS_5:39;
end;

Lm8: for s being 0-started State of SCMPDS
 st s.a4 >= 7+s.a6 & s.GBP=0 & s.a6 > 0 holds
IExec(B1,s).a2=s.a2 & IExec(B1,s).a3=s.a3 & IExec(B1,s).a6 < s.a6 & IExec(B1,s)
.a4 >= 7+IExec(B1,s).a6 & (for i be Nat st i>=7 & i<>s.a4-1 & i<>s.a4 holds
IExec(B1,s).intpos i=s.intpos i) & (s.DataLoc(s.a4,-1) > s.DataLoc(s.a4,0)
implies IExec(B1,s).DataLoc(s.a4,-1)=s.DataLoc(s.a4,0) & IExec(B1,s).DataLoc(s.
a4,0) =s.DataLoc(s.a4,-1) & IExec(B1,s).a6=s.a6-1 & IExec(B1,s).a4=s.a4-1 ) & (
s.DataLoc(s.a4,-1) <= s.DataLoc(s.a4,0) implies IExec(B1,s).DataLoc(s.a4,-1)=s.
DataLoc(s.a4,-1) & IExec(B1,s).DataLoc(s.a4,0) =s.DataLoc(s.a4,0) & IExec(B1,s)
.a6=0)

proof
  let s be 0-started State of SCMPDS;
  set a=GBP, x=DataLoc(s.a4,-1), y=DataLoc(s.a4,0);
  assume that
A1: s.a4 >= 7+s.a6 and
A2: s.a=0 and
A3: s.a6 > 0;
  set t0=Initialize s, t1=Exec(k1, t0), t2=IExec(k1 ';' k2,s);
A4: 7+s.a6>7+0 by A3,XREAL_1:8;
  then
A5: abs(s.a4)=s.a4 by A1,ABSVALUE:def 1;

  set Fi= (a,6):=0, t02=Initialize t2, t3=IExec(k3 ';' k4 ';' k5 ';' k6,t2),
  t4=IExec(k3 ';' k4 ';' k5,t2), t5=IExec(k3 ';' k4,t2), t6=Exec(k3, t02);
A6: t02=Initialize t02;
A7: t3=IExec(k3 ';' k4 ';' k5 ';' k6,t02) by SCMPDS_5:48;
A8: t4=IExec(k3 ';' k4 ';' k5,t02) by SCMPDS_5:48;
A9: t5=IExec(k3 ';' k4,t02) by SCMPDS_5:48;

A10: t0.x=s.x by SCMPDS_5:40;
A11: t0.a=0 by A2,SCMPDS_5:40;
  then
A12: DataLoc(t0.a,5)=intpos (0+5) by SCMP_GCD:5;
  then
A13: t1.a=0 by A11,AMI_3:52,SCMPDS_2:59;
  then
A14: DataLoc(t1.a,5)=intpos (0+5) by SCMP_GCD:5;
  then
A15: abs(t1.a+5)=0+5 by ZFMISC_1:33;
  then abs(s.a4+0)<>abs(t1.a+5) by A1,A4,A5,XXREAL_0:2;
  then
A16: y<>DataLoc(t1.a,5) by ZFMISC_1:33;
A17: abs(t0.a+5)=0+5 by A12,ZFMISC_1:33;
  then abs(s.a4+0)<>abs(t0.a+5) by A1,A4,A5,XXREAL_0:2;
  then t0.y=s.y & y<>DataLoc(t0.a,5) by SCMPDS_5:40,ZFMISC_1:33;
  then
A18: t1.y=s.y by SCMPDS_2:59;
A19: t0.a4=s.a4 by SCMPDS_5:40;
  then
A20: t1.a5=s.x by A10,A12,SCMPDS_2:59;
A21: t1.a4=s.a4 by A19,A12,AMI_3:52,SCMPDS_2:59;
  t2.y=Exec(k2, t1).y by SCMPDS_5:47
    .=s.y by A18,A16,SCMPDS_2:62;
  then
A22: t02.y=s.y by SCMPDS_5:40;
A23: t2.a=Exec(k2, t1).a by SCMPDS_5:47
    .=0 by A13,A14,AMI_3:52,SCMPDS_2:62;
  then
A24: t02.a=0 by SCMPDS_5:40;
  then
A25: DataLoc(t02.a,5)=intpos (0+5) by SCMP_GCD:5;
  then
A26: t6.a=0 by A24,AMI_3:52,SCMPDS_2:59;
  abs(t02.a+5)=0+5 by A25,ZFMISC_1:33;
  then abs(s.a4+0)<>abs(t02.a+5) by A1,A4,A5,XXREAL_0:2;
  then y<>DataLoc(t02.a,5) by ZFMISC_1:33;
  then
A27: t6.y=s.y by A22,SCMPDS_2:59;
  t2.a4=Exec(k2, t1).a4 by SCMPDS_5:47
    .=s.a4 by A21,A14,AMI_3:52,SCMPDS_2:62;
  then
A28: t02.a4=s.a4 by SCMPDS_5:40;
  then
A29: t6.a4=s.a4 by A25,AMI_3:52,SCMPDS_2:59;
  then
A30: t5.x =Exec(k4, t6).DataLoc(t6.a4,-1) by A6,A9,SCMPDS_5:47
    .=s.y by A29,A27,SCMPDS_2:59;
  t0.a3=s.a3 by SCMPDS_5:40;
  then
A31: t1.a3=s.a3 by A12,AMI_3:52,SCMPDS_2:59;
  t2.a3=Exec(k2, t1).a3 by SCMPDS_5:47
    .=s.a3 by A31,A14,AMI_3:52,SCMPDS_2:62;
  then
A32: t02.a3=s.a3 by SCMPDS_5:40;
  then
A33: t6.a3=s.a3 by A25,AMI_3:52,SCMPDS_2:59;
A34: s.a4>=1+(6+s.a6) by A1;
  then
A35: s.a4-1 >= 6+s.a6 by XREAL_1:21;
  t0.a2=s.a2 by SCMPDS_5:40;
  then
A36: t1.a2=s.a2 by A12,AMI_3:52,SCMPDS_2:59;
  t2.a2=Exec(k2, t1).a2 by SCMPDS_5:47
    .=s.a2 by A36,A14,AMI_3:52,SCMPDS_2:62;
  then
A37: t02.a2=s.a2 by SCMPDS_5:40;
  then
A38: t6.a2=s.a2 by A25,AMI_3:52,SCMPDS_2:59;
  t0.a6=s.a6 by SCMPDS_5:40;
  then
A39: t1.a6=s.a6 by A12,AMI_3:52,SCMPDS_2:59;
  t2.a6=Exec(k2, t1).a6 by SCMPDS_5:47
    .=s.a6 by A39,A14,AMI_3:52,SCMPDS_2:62;
  then t02.a6=s.a6 by SCMPDS_5:40;
  then
A40: t6.a6=s.a6 by A25,AMI_3:52,SCMPDS_2:59;
A41: DataLoc(t02.a,6)=intpos (0+6) by A24,SCMP_GCD:5;
A42: now
    assume
    t2.DataLoc(t2.a,5) <= 0;
    then IExec(IF,t2).a6=IExec(FA,t2).a6 by SCMPDS_6:88
      .=Exec(Fi,t02).a6 by SCMPDS_5:45
      .=0 by A41,SCMPDS_2:58;
    hence IExec(B1,s).a6 =0 by SCMPDS_5:39;
  end;
A43: 6+s.a6>6+0 by A3,XREAL_1:8;
  then 0<>abs(t6.a4+-1) by A35,A29,ABSVALUE:def 1;
  then
A44: a<>DataLoc(t6.a4,-1) by ZFMISC_1:33;
A45: s.a4-1 > 0 by A3,A34,XREAL_1:21;
  then
A46: abs(t6.a4+-1) =s.a4-1 by A29,ABSVALUE:def 1;
  then 4<>abs(t6.a4+-1) by A35,A43,XXREAL_0:2;
  then
A47: a4<>DataLoc(t6.a4,-1) by ZFMISC_1:33;
A48: t5.a4 =Exec(k4, t6).a4 by A6,A9,SCMPDS_5:47
    .=s.a4 by A29,A47,SCMPDS_2:59;
  then
A49: abs(t5.a4+0) = s.a4 by A1,A4,ABSVALUE:def 1;
  then 4<>abs(t5.a4+0) by A1,A4,XXREAL_0:2;
  then
A50: a4<>DataLoc(t5.a4,0) by ZFMISC_1:33;
  3<>abs(t6.a4+-1) by A35,A43,A46,XXREAL_0:2;
  then
A51: a3<>DataLoc(t6.a4,-1) by ZFMISC_1:33;
  3<>abs(t5.a4+0) by A1,A4,A49,XXREAL_0:2;
  then
A52: a3<>DataLoc(t5.a4,0) by ZFMISC_1:33;
A53: t5.a3 =Exec(k4, t6).a3 by A6,A9,SCMPDS_5:47
    .=s.a3 by A33,A51,SCMPDS_2:59;
A54: t4.a3=Exec(k5,t5).a3 by A8,A9,SCMPDS_5:46
    .=s.a3 by A53,A52,SCMPDS_2:59;
  2<>abs(t5.a4+0) by A1,A4,A49,XXREAL_0:2;
  then
A55: a2<>DataLoc(t5.a4,0) by ZFMISC_1:33;
A56: t4.a4=Exec(k5,t5).a4 by A8,A9,SCMPDS_5:46
    .=s.a4 by A48,A50,SCMPDS_2:59;
A57: t5.a =Exec(k4, t6).a by A6,A9,SCMPDS_5:47
    .=0 by A26,A44,SCMPDS_2:59;
A58: 2*abs((s.a4+-1))+1=2*(s.a4-1)+1 by A35,A43,ABSVALUE:def 1;
  then abs(s.a4+-1)<>abs(t1.a+5) by A3,A35,A15,XREAL_1:8;
  then
A59: x<>DataLoc(t1.a,5) by ZFMISC_1:33;
  0<>abs(t5.a4+0) by A1,A4,A48,ABSVALUE:def 1;
  then
A60: a<>DataLoc(t5.a4,0) by ZFMISC_1:33;
A61: t4.a=Exec(k5,t5).a by A8,A9,SCMPDS_5:46
    .=0 by A57,A60,SCMPDS_2:59;
  then
A62: a<>DataLoc(t4.a,4) by AMI_3:52,SCMP_GCD:5;
  2<>abs(t6.a4+-1) by A35,A43,A46,XXREAL_0:2;
  then
A63: a2<>DataLoc(t6.a4,-1) by ZFMISC_1:33;
A64: t5.a2 =Exec(k4, t6).a2 by A6,A9,SCMPDS_5:47
    .=s.a2 by A38,A63,SCMPDS_2:59;
A65: t4.a2=Exec(k5,t5).a2 by A8,A9,SCMPDS_5:46
    .=s.a2 by A64,A55,SCMPDS_2:59;
A66: a2<>DataLoc(t4.a,4) by A61,AMI_3:52,SCMP_GCD:5;
  t3.a=Exec(k6,t4).a by A7,A8,SCMPDS_5:46
    .=0 by A61,A62,SCMPDS_2:60;
  then
A67: DataLoc(t3.a,6)=intpos (0+6) by SCMP_GCD:5;
  then
A68: abs(t3.a+6)=0+6 by ZFMISC_1:33;
A69: DataLoc(t4.a,4)=intpos (0+4) by A61,SCMP_GCD:5;
  then
A70: abs(t4.a+4)=0+4 by ZFMISC_1:33;
  then abs(s.a4+-1)<>abs(t4.a+4) by A35,A43,A58,XXREAL_0:2;
  then
A71: x<>DataLoc(t4.a,4) by ZFMISC_1:33;
A72: t3.a2=Exec(k6,t4).a2 by A7,A8,SCMPDS_5:46
    .=s.a2 by A65,A66,SCMPDS_2:60;
A73: IExec(TR,t2) = IExec(TR,t02) by SCMPDS_5:48;
  now
    per cases;
    suppose
      t2.DataLoc(t2.a,5) <= 0;
      hence IExec(IF,t2).a2=IExec(FA,t2).a2 by SCMPDS_6:88
        .=Exec(Fi,t02).a2 by SCMPDS_5:45
        .=s.a2 by A37,A41,AMI_3:52,SCMPDS_2:58;
    end;
    suppose
      t2.DataLoc(t2.a,5) > 0;
      hence IExec(IF,t2).a2=IExec(TR,t2).a2 by SCMPDS_6:87
        .=Exec(k7,t3).a2 by A7,A73,SCMPDS_5:46
        .=s.a2 by A72,A67,AMI_3:52,SCMPDS_2:60;
    end;
  end;
  hence IExec(B1,s).a2=s.a2 by SCMPDS_5:39;
A74: a3<>DataLoc(t4.a,4) by A61,AMI_3:52,SCMP_GCD:5;
A75: t3.a3=Exec(k6,t4).a3 by A7,A8,SCMPDS_5:46
    .=s.a3 by A54,A74,SCMPDS_2:60;
  now
    per cases;
    suppose
      t2.DataLoc(t2.a,5) <= 0;
      hence IExec(IF,t2).a3=IExec(FA,t2).a3 by SCMPDS_6:88
        .=Exec(Fi,t02).a3 by SCMPDS_5:45
        .=s.a3 by A32,A41,AMI_3:52,SCMPDS_2:58;
    end;
    suppose
      t2.DataLoc(t2.a,5) > 0;
      hence IExec(IF,t2).a3=IExec(TR,t2).a3 by SCMPDS_6:87
        .=Exec(k7,t3).a3 by A7,A73,SCMPDS_5:46
        .=s.a3 by A75,A67,AMI_3:52,SCMPDS_2:60;
    end;
  end;
  hence IExec(B1,s).a3=s.a3 by SCMPDS_5:39;
A76: a6<>DataLoc(t4.a,4) by A61,AMI_3:52,SCMP_GCD:5;
  6<>abs(t6.a4+-1) by A34,A43,A46,XREAL_1:21;
  then
A77: a6<>DataLoc(t6.a4,-1) by ZFMISC_1:33;
A78: t5.a6 =Exec(k4, t6).a6 by A6,A9,SCMPDS_5:47
    .=s.a6 by A40,A77,SCMPDS_2:59;
  6<>abs(t5.a4+0) by A1,A4,A49,XXREAL_0:2;
  then
A79: a6<>DataLoc(t5.a4,0) by ZFMISC_1:33;
A80: t4.a6=Exec(k5,t5).a6 by A8,A9,SCMPDS_5:46
    .=s.a6 by A78,A79,SCMPDS_2:59;
A81: t3.a6=Exec(k6,t4).a6 by A7,A8,SCMPDS_5:46
    .=s.a6 by A80,A76,SCMPDS_2:60;
A82: t3.a4=Exec(k6,t4).a4 by A7,A8,SCMPDS_5:46
    .=t4.a4+-1 by A69,SCMPDS_2:60
    .=s.a4-1 by A56;
A83: now
    assume
A84: t2.DataLoc(t2.a,5) > 0;
    then IExec(IF,t2).a6=IExec(TR,t2).a6 by SCMPDS_6:87
      .=Exec(k7,t3).a6 by A7,A73,SCMPDS_5:46
      .=s.a6+ -1 by A81,A67,SCMPDS_2:60
      .=s.a6-1;
    hence IExec(B1,s).a6=s.a6-1 by SCMPDS_5:39;
    IExec(IF,t2).a4=IExec(TR,t2).a4 by A84,SCMPDS_6:87
      .=Exec(k7,t3).a4 by A7,A73,SCMPDS_5:46
      .=s.a4-1 by A82,A67,AMI_3:52,SCMPDS_2:60;
    hence IExec(B1,s).a4=s.a4-1 by SCMPDS_5:39;
  end;
  hereby
    per cases;
    suppose
      t2.DataLoc(t2.a,5) <= 0;
      hence IExec(B1,s).a6 < s.a6 by A3,A42;
    end;
    suppose
      t2.DataLoc(t2.a,5) > 0;
      hence IExec(B1,s).a6 < s.a6 by A83,XREAL_1:148;
    end;
  end;
  hereby
    per cases;
    suppose
A85:  t2.DataLoc(t2.GBP,5) <= 0;
      then IExec(IF,t2).a4=IExec(FA,t2).a4 by SCMPDS_6:88
        .=Exec(Fi,t02).a4 by SCMPDS_5:45
        .=s.a4 by A28,A41,AMI_3:52,SCMPDS_2:58;
      then IExec(B1,s).a4=s.a4 by SCMPDS_5:39;

      hence IExec(B1,s).a4 >= 7+IExec(B1,s).a6 by A1,A4,A42,A85,XXREAL_0:2;

    end;
    suppose
A86:  t2.DataLoc(t2.a,5) > 0;
      s.a4-1 >= 7+s.a6-1 by A1,XREAL_1:11;
      hence IExec(B1,s).a4 >= 7+IExec(B1,s).a6 by A83,A86;
    end;
  end;
A87: now
    let i be Element of NAT;
    assume that
A88: i>=7 and
    i<>s.a4-1 and
    i <> s.a4;
    i>5 by A88,XXREAL_0:2;
    hence t1.intpos i=t0.intpos i by A12,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by SCMPDS_5:40;
  end;
A89: now
    let i be Element of NAT;
    assume that
A90: i>=7 and
A91: i<>s.a4-1 & i <> s.a4;
A92: i>5 by A90,XXREAL_0:2;
    thus t2.intpos i=Exec(k2, t1).intpos i by SCMPDS_5:47
      .=t1.intpos i by A14,A92,AMI_3:52,SCMPDS_2:62
      .=s.intpos i by A87,A90,A91;
  end;
A93: now
    let i be Element of NAT;
    assume that
A94: i>=7 and
A95: i<>s.a4-1 & i <> s.a4;
    i>5 by A94,XXREAL_0:2;
    hence t6.intpos i=t02.intpos i by A25,AMI_3:52,SCMPDS_2:59
      .=t2.intpos i by SCMPDS_5:40
      .=s.intpos i by A89,A94,A95;
  end;
A96: now
    let i be Element of NAT;
    assume that
A97: i>=7 and
A98: i<>s.a4-1 and
A99: i <> s.a4;
A100: intpos i <> DataLoc(t6.a4,-1)
    proof
      assume
      intpos i=DataLoc(t6.a4,-1);
      then i =abs(t6.a4+-1) by ZFMISC_1:33;
      hence contradiction by A45,A29,A98,ABSVALUE:def 1;
    end;
    thus t5.intpos i=Exec(k4, t6).intpos i by A6,A9,SCMPDS_5:47
      .=t6.intpos i by A100,SCMPDS_2:59
      .=s.intpos i by A93,A97,A98,A99;
  end;
A101: now
    let i be Element of NAT;
    assume that
A102: i>=7 & i<>s.a4-1 and
A103: i <> s.a4;
A104: intpos i <> DataLoc(t5.a4,0)
    proof
      assume
      intpos i=DataLoc(t5.a4,0);
      then i=abs(t5.a4+0) by ZFMISC_1:33;
      hence contradiction by A1,A4,A48,A103,ABSVALUE:def 1;
    end;
    thus t4.intpos i=Exec(k5, t5).intpos i by A8,A9,SCMPDS_5:46
      .=t5.intpos i by A104,SCMPDS_2:59
      .=s.intpos i by A96,A102,A103;
  end;
A105: now
    let i be Element of NAT;
    assume that
A106: i>=7 and
A107: i<>s.a4-1 & i <> s.a4;
    i>4 by A106,XXREAL_0:2;
    then
A108: intpos i <> DataLoc(t4.a,4) by A61,AMI_3:52,SCMP_GCD:5;
    thus t3.intpos i=Exec(k6, t4).intpos i by A7,A8,SCMPDS_5:46
      .=t4.intpos i by A108,SCMPDS_2:60
      .=s.intpos i by A101,A106,A107;
  end;
  hereby
    let i be Nat;
A109: i in NAT by ORDINAL1:def 13;
    set xi=intpos i;
    assume that
A110: i>=7 and
A111: i<>s.a4-1 & i <> s.a4;
A112: i>6 by A110,XXREAL_0:2;
    per cases;
    suppose
      t2.DataLoc(t2.a,5) <= 0;
      then IExec(IF,t2).xi=IExec(FA,t2).xi by SCMPDS_6:88
        .=Exec(Fi,t02).xi by SCMPDS_5:45
        .=t02.xi by A41,A112,AMI_3:52,SCMPDS_2:58
        .=t2.xi by SCMPDS_5:40
        .=s.xi by A89,A109,A110,A111;
      hence IExec(B1,s).xi=s.xi by SCMPDS_5:39;
    end;
    suppose
      t2.DataLoc(t2.a,5) > 0;
      then IExec(IF,t2).xi=IExec(TR,t2).xi by SCMPDS_6:87
        .=Exec(k7,t3).xi by A7,A73,SCMPDS_5:46
        .=t3.xi by A67,A112,AMI_3:52,SCMPDS_2:60
        .=s.xi by A105,A109,A110,A111;
      hence IExec(B1,s).xi=s.xi by SCMPDS_5:39;
    end;
  end;
A113: t2.a5=Exec(k2, t1).a5 by SCMPDS_5:47
    .=s.x-s.y by A21,A20,A18,A14,SCMPDS_2:62;
  then
A114: t2.DataLoc(t2.a,5)=s.x-s.y by A23,SCMP_GCD:5;
  abs(s.a4+-1)<>abs(t0.a+5) by A3,A35,A58,A17,XREAL_1:8;
  then x<>DataLoc(t0.a,5) by ZFMISC_1:33;
  then
A115: t1.x=s.x by A10,SCMPDS_2:59;
  t2.x=Exec(k2, t1).x by SCMPDS_5:47
    .=s.x by A115,A59,SCMPDS_2:62;
  then
A116: t02.x=s.x by SCMPDS_5:40;
  then
A117: t6.a5=s.x by A28,A25,SCMPDS_2:59;
  5<>abs(t6.a4+-1) by A35,A43,A46,XXREAL_0:2;
  then
A118: a5<>DataLoc(t6.a4,-1) by ZFMISC_1:33;
A119: t5.a5 =Exec(k4, t6).a5 by A6,A9,SCMPDS_5:47
    .=s.x by A117,A118,SCMPDS_2:59;
  abs(s.a4+0)<>abs(t4.a+4) by A1,A4,A5,A70,XXREAL_0:2;
  then
A120: y<>DataLoc(t4.a,4) by ZFMISC_1:33;
A121: t4.y =Exec(k5, t5).DataLoc(t5.a4,0) by A48,A8,A9,SCMPDS_5:46
    .=t5.DataLoc(t5.a,5) by SCMPDS_2:59
    .=s.x by A57,A119,SCMP_GCD:5;
A122: t3.y=Exec(k6, t4).y by A7,A8,SCMPDS_5:46
    .=s.x by A121,A120,SCMPDS_2:60;
  abs(s.a4+-1)<>abs(t5.a4+0) by A58,A49;
  then
A123: x<>DataLoc(t5.a4,0) by ZFMISC_1:33;
A124: t4.x=Exec(k5,t5).x by A8,A9,SCMPDS_5:46
    .=s.y by A30,A123,SCMPDS_2:59;
A125: t3.x=Exec(k6, t4).x by A7,A8,SCMPDS_5:46
    .=s.y by A124,A71,SCMPDS_2:60;
  hereby
A126: x<>DataLoc(t3.a,6) by A35,A43,A58,A67,ZFMISC_1:33;
    assume
    s.x > s.y;
    then
A127: s.x-s.y > s.y-s.y by XREAL_1:11;
    then IExec(IF,t2).x=IExec(TR,t2).x by A114,SCMPDS_6:87
      .=Exec(k7,t3).x by A7,A73,SCMPDS_5:46
      .=s.y by A125,A126,SCMPDS_2:60;
    hence IExec(B1,s).x=s.y by SCMPDS_5:39;
    abs(s.a4+0)<>abs(t3.a+6) by A1,A4,A5,A68,XXREAL_0:2;
    then
A128: y<>DataLoc(t3.a,6) by ZFMISC_1:33;
    IExec(IF,t2).y=IExec(TR,t2).y by A114,A127,SCMPDS_6:87
      .=Exec(k7,t3).y by A7,A73,SCMPDS_5:46
      .=s.x by A122,A128,SCMPDS_2:60;
    hence IExec(B1,s).y=s.x by SCMPDS_5:39;

    thus IExec(B1,s).a6=s.a6-1 & IExec(B1,s).a4=s.a4-1 by A23,A113,A83,A127,
SCMP_GCD:5;

  end;
A129: abs(t02.a+6)=0+6 by A41,ZFMISC_1:33;
  hereby
A130: x<>DataLoc(t02.a,6) by A35,A43,A58,A41,ZFMISC_1:33;
    assume
    s.x <= s.y;
    then
A131: s.x-s.y <= s.y-s.y by XREAL_1:11;
    then IExec(IF,t2).x=IExec(FA,t2).x by A114,SCMPDS_6:88
      .=Exec(Fi,t02).x by SCMPDS_5:45
      .=s.x by A116,A130,SCMPDS_2:58;
    hence IExec(B1,s).x=s.x by SCMPDS_5:39;
    abs(s.a4+0)<>abs(t02.a+6) by A1,A4,A5,A129,XXREAL_0:2;
    then
A132: y<>DataLoc(t02.a,6) by ZFMISC_1:33;
    IExec(IF,t2).y=IExec(FA,t2).y by A114,A131,SCMPDS_6:88
      .=Exec(Fi,t02).y by SCMPDS_5:45
      .=s.y by A22,A132,SCMPDS_2:58;
    hence IExec(B1,s).y=s.y by SCMPDS_5:39;
    thus IExec(B1,s).a6 =0 by A23,A113,A42,A131,SCMP_GCD:5;
  end;
end;

Lm9: for s being 0-started State of SCMPDS
 st s.a4 >= 7+s.DataLoc(s.GBP,6) & s.GBP=0
holds WH is_closed_on s & WH is_halting_on s

proof
  let s be 0-started State of SCMPDS;
  set a=GBP, b=DataLoc(s.a,6);
  assume that
A1: s.a4 >= 7+s.b and
A2: s.a=0;
A3: b=intpos(0+6) by A2,SCMP_GCD:5;
A4: now
    let t be State of SCMPDS;
    assume that
A5: for x st x in {a4} holds t.x >= 7+t.b and
A6: t.a=s.a & t.b >0;
    set Bt=IExec(B1,t);
A7: Bt=IExec(B1,Initialize t) by SCMPDS_5:48;
A8: t.b = (Initialize t).b by SCMPDS_5:40;
A9: t.a = (Initialize t).a by SCMPDS_5:40;
A10: t.a4 = (Initialize t).a4 by SCMPDS_5:40;
A11: a4 in {a4} by TARSKI:def 1;
    then
A12: t.a4 >= 7+t.a6 by A3,A5;
    hence IExec(B1,t).a=t.a by A2,A3,A6,Lm7,A7,A8,A9,A10;
    thus B1 is_closed_on t & B1 is_halting_on t by SCMPDS_6:34,35;
    thus IExec(B1,t).b < t.b by A2,A3,A6,A12,Lm8,A7,A8,A9,A10;
    t.a4 >= 7+t.b by A5,A11;
    then Bt.a4 >= 7+Bt.a6 by A2,A3,A6,Lm8,A7,A8,A9,A10;

    hence for x st x in {a4} holds IExec(B1,t).x >= 7+IExec(B1,t).b by A3,
TARSKI:def 1;

  end;

  for x st x in {a4} holds s.x >= 7+s.b by A1,TARSKI:def 1;
  hence thesis by A4,Lm5,SCMPDS_8:29;
end;

Lm10: for s being 0-started State of SCMPDS
 st s.a4 >= 7+s.DataLoc(s.GBP,6) & s.GBP=0
holds IExec(WH,s).GBP=0 & IExec(WH,s).a1=s.a1 & IExec(WH,s).a2=s.a2 & IExec(WH,
s).a3=s.a3

proof
  let s be 0-started State of SCMPDS;
  set b=DataLoc(s.GBP,6), a=GBP;
  assume that
A1: s.a4 >= 7+s.b and
A2: s.a=0;
A3: b=intpos (0+6) by A2,SCMP_GCD:5;

  defpred P[Nat] means for t be 0-started State of SCMPDS
   st t.a6 <= $1 & t.a4 >= 7+t.a6
  & t.a=0 holds IExec(WH,t).a=0 & IExec(WH,t).a1=t.a1 & IExec(WH,t).a2=t.a2 &
  IExec(WH,t).a3=t.a3;

A4: P[0]
  proof
    let t be 0-started State of SCMPDS;
    assume that
A5: t.a6 <= 0 and
    t.a4 >= 7+t.a6 and
A6: t.a=0;
A7: DataLoc(t.a,6)=intpos (0+6) by A6,SCMP_GCD:5;
    hence IExec(WH,t).a=0 by A5,A6,SCMPDS_8:23;
    thus thesis by A5,A7,SCMPDS_8:23;
  end;
A8: for k be Element of NAT st P[k] holds P[k+1]
  proof
    let k be Element of NAT;
    assume
A9: P[k];
    thus P[k+1]
    proof
      let t be 0-started State of SCMPDS;
      set bt=DataLoc(t.a,6);
      assume that
A10:  t.a6 <= k+1 and
A11:  t.a4 >= 7+t.a6 and
A12:  t.a=0;
A13:  bt=intpos (0+6) by A12,SCMP_GCD:5;
      per cases;
      suppose
        t.bt <= 0;
        hence thesis by A12,SCMPDS_8:23;
      end;
      suppose
A14:    t.bt > 0;
A15:    now
          let v be State of SCMPDS;
          assume that
A16:      for x st x in {a4} holds v.x >= 7+v.bt and
A17:      v.a=t.a & v.bt > 0;
          set Iv=IExec(B1,v);
A18:       Iv=IExec(B1,Initialize v) by SCMPDS_5:48;
A19:       v.a = (Initialize v).a by SCMPDS_5:40;
A20:       v.a4 = (Initialize v).a4 by SCMPDS_5:40;
A21:       v.a6 = (Initialize v).a6 by SCMPDS_5:40;
A22:      a4 in {a4} by TARSKI:def 1;
          then
A23:      v.a4 >= 7+v.a6 by A13,A16;
          hence IExec(B1,v).a=v.a by A12,A13,A17,Lm7,A18,A19,A20,A21;
          thus B1 is_closed_on v & B1 is_halting_on v by SCMPDS_6:34,35;
          thus IExec(B1,v).bt < v.bt by A12,A13,A17,A23,Lm8,A18,A19,A20,A21;
          v.a4 >= 7+v.bt by A16,A22;
          then Iv.a4 >= 7+Iv.a6 by A12,A13,A17,Lm8,A18,A19,A20,A21;

          hence for x st x in {a4} holds IExec(B1,v).x >= 7+IExec(B1,v).bt by
A13,TARSKI:def 1;

        end;
        set It=IExec(B1,t);
A24: IExec(WH,It) = IExec(WH,Initialize It) by SCMPDS_5:48;
A25: It.a1 = (Initialize It).a1 by SCMPDS_5:40;
A26: It.a6 = (Initialize It).a6 by SCMPDS_5:40;
A27: It.a4 = (Initialize It).a4 by SCMPDS_5:40;
A28: It.GBP = (Initialize It).GBP by SCMPDS_5:40;
A29: It.a2 = (Initialize It).a2 by SCMPDS_5:40;
A30: It.a3 = (Initialize It).a3 by SCMPDS_5:40;
        It.a6 < t.a6 by A11,A12,A13,A14,Lm8;
        then It.a6 +1 <= t.a6 by INT_1:20;
        then It.a6 +1 <= k+1 by A10,XXREAL_0:2;
        then
A31:    It.a6 <= k by XREAL_1:8;
A32:    It.GBP=0 & It.a4 >= 7+It.a6 by A11,A12,A13,A14,Lm7,Lm8;
        then
A33:    IExec(WH,It).a1=It.a1 by A9,A31,A24,A25,A26,A27,A28;
A34:    IExec(WH,It).a3=It.a3 by A9,A32,A31,A24,A26,A27,A28,A30;
A35:    IExec(WH,It).a2=It.a2 by A9,A32,A31,A24,A26,A27,A28,A29;
A36:    for x st x in {a4} holds t.x >= 7+t.bt by A11,A13,TARSKI:def 1;
        IExec(WH,It).a=0 by A9,A32,A31,A24,A26,A27,A28;
        hence IExec(WH,t).a=0 by A14,A36,A15,Lm5,SCMPDS_8:29
        ;
        It.a1=t.a1 by A11,A12,A13,A14,Lm7;
        hence IExec(WH,t).a1=t.a1 by A14,A36,A15,A33,Lm5,SCMPDS_8:29;
        It.a2=t.a2 by A11,A12,A13,A14,Lm8;
        hence IExec(WH,t).a2=t.a2 by A14,A36,A15,A35,Lm5,SCMPDS_8:29;
        It.a3=t.a3 by A11,A12,A13,A14,Lm8;
        hence thesis by A14,A36,A15,A34,Lm5,SCMPDS_8:29;
      end;
    end;
  end;
  per cases;
  suppose
    s.a6 <= 0;
    hence thesis by A2,A3,SCMPDS_8:23;
  end;
  suppose
    s.a6 > 0;
    then reconsider m=s.a6 as Element of NAT by INT_1:16;
    for k be Element of NAT holds P[k] from NAT_1:sch 1(A4,A8);
    then P[m];
    hence thesis by A1,A2,A3;
  end;
end;

Lm11: for s being 0-started State of SCMPDS
 st s.GBP=0 holds IExec(J4,s).GBP =0 & IExec(
J4,s).a1 = s.a1+1 & IExec(J4,s).a2=s.a2 & IExec(J4,s).a3 =s.a3+1 & IExec(J4,s).
a4 =s.a3+1 & IExec(J4,s).a6 =s.a1+1 & for i be Element of NAT st i >= 7 holds
IExec(J4,s).intpos i=s.intpos i

proof
  set a=GBP;
  let s be 0-started State of SCMPDS;

  set t0=Initialize s, t1=IExec(J4,s), t2=IExec(j1 ';' j2 ';' j3,s), t3=IExec
  (j1 ';' j2,s), t4=Exec(j1, t0);

  assume
  s.a=0;
  then
A1: t0.a=0 by SCMPDS_5:40;
  then
A2: DataLoc(t0.a,3)=intpos (0+3) by SCMP_GCD:5;
  then
A3: t4.a=0 by A1,AMI_3:52,SCMPDS_2:60;
  then
A4: DataLoc(t4.a,4)=intpos (0+4) by SCMP_GCD:5;
  t0.a2=s.a2 by SCMPDS_5:40;
  then
A5: t4.a2=s.a2 by A2,AMI_3:52,SCMPDS_2:60;
A6: t3.a2 =Exec(j2, t4).a2 by SCMPDS_5:47
    .=s.a2 by A5,A4,AMI_3:52,SCMPDS_2:59;
  t0.a1=s.a1 by SCMPDS_5:40;
  then
A7: t4.a1=s.a1 by A2,AMI_3:52,SCMPDS_2:60;
A8: t3.a1 =Exec(j2, t4).a1 by SCMPDS_5:47
    .=s.a1 by A7,A4,AMI_3:52,SCMPDS_2:59;
  t0.a3=s.a3 by SCMPDS_5:40;
  then
A9: t4.a3=s.a3+1 by A2,SCMPDS_2:60;
A10: t3.a =Exec(j2, t4).a by SCMPDS_5:47
    .=0 by A3,A4,AMI_3:52,SCMPDS_2:59;
  then
A11: DataLoc(t3.a,1)=intpos (0+1) by SCMP_GCD:5;
A12: DataLoc(t4.a,3)=intpos (0+3) by A3,SCMP_GCD:5;
A13: t3.a4 =Exec(j2,t4).a4 by SCMPDS_5:47
    .=s.a3+1 by A9,A4,A12,SCMPDS_2:59;
A14: t2.a4 =Exec(j3, t3).a4 by SCMPDS_5:46
    .=s.a3+1 by A13,A11,AMI_3:52,SCMPDS_2:60;
A15: t2.a2 =Exec(j3, t3).a2 by SCMPDS_5:46
    .=s.a2 by A6,A11,AMI_3:52,SCMPDS_2:60;
A16: t2.a1 =Exec(j3, t3).a1 by SCMPDS_5:46
    .=s.a1+1 by A8,A11,SCMPDS_2:60;
A17: t3.a3 =Exec(j2, t4).a3 by SCMPDS_5:47
    .=s.a3+1 by A9,A4,AMI_3:52,SCMPDS_2:59;
A18: t2.a3 =Exec(j3, t3).a3 by SCMPDS_5:46
    .=s.a3+1 by A17,A11,AMI_3:52,SCMPDS_2:60;
A19: t2.a =Exec(j3, t3).a by SCMPDS_5:46
    .=0 by A10,A11,AMI_3:52,SCMPDS_2:60;
  then
A20: DataLoc(t2.a,6)=intpos (0+6) by SCMP_GCD:5;
  thus t1.a =Exec(j4, t2).a by SCMPDS_5:46
    .=0 by A19,A20,AMI_3:52,SCMPDS_2:59;
  thus t1.a1 =Exec(j4, t2).a1 by SCMPDS_5:46
    .=s.a1+1 by A16,A20,AMI_3:52,SCMPDS_2:59;
  thus t1.a2 =Exec(j4, t2).a2 by SCMPDS_5:46
    .=s.a2 by A15,A20,AMI_3:52,SCMPDS_2:59;
A21: DataLoc(t2.a,1)=intpos (0+1) by A19,SCMP_GCD:5;
  thus t1.a3 =Exec(j4, t2).a3 by SCMPDS_5:46
    .=s.a3+1 by A18,A20,AMI_3:52,SCMPDS_2:59;
  thus t1.a4 =Exec(j4, t2).a4 by SCMPDS_5:46
    .=s.a3+1 by A14,A20,AMI_3:52,SCMPDS_2:59;
  thus t1.a6 =Exec(j4, t2).a6 by SCMPDS_5:46
    .=s.a1+1 by A16,A20,A21,SCMPDS_2:59;
A22: now
    let i be Element of NAT;
    assume
    i >= 7;
    then i > 3 by XXREAL_0:2;
    hence t4.intpos i=t0.intpos i by A2,AMI_3:52,SCMPDS_2:60
      .=s.intpos i by SCMPDS_5:40;
  end;
A23: now
    let i be Element of NAT;
    assume
A24: i >= 7;
    then
A25: i > 4 by XXREAL_0:2;
    thus t3.intpos i =Exec(j2, t4).intpos i by SCMPDS_5:47
      .=t4.intpos i by A4,A25,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by A22,A24;
  end;
A26: now
    let i be Element of NAT;
    assume
A27: i >= 7;
    then
A28: i > 1 by XXREAL_0:2;
    thus t2.intpos i =Exec(j3, t3).intpos i by SCMPDS_5:46
      .=t3.intpos i by A11,A28,AMI_3:52,SCMPDS_2:60
      .=s.intpos i by A23,A27;
  end;
  hereby
    let i be Element of NAT;
    assume
A29: i >= 7;
    then
A30: i > 6 by XXREAL_0:2;
    thus t1.intpos i =Exec(j4, t2).intpos i by SCMPDS_5:46
      .=t2.intpos i by A20,A30,AMI_3:52,SCMPDS_2:59
      .=s.intpos i by A26,A29;
  end;
end;
set jf=AddTo(GBP,2,-1), B3=B2 ';' jf;

Lm12: for s being 0-started State of SCMPDS
 st s.a3 >= s.a1+7 & s.GBP=0 holds IExec(B3,s
).GBP=0 & IExec(B3,s).a2=s.a2-1 & IExec(B3,s).a3=s.a3+1 & IExec(B3,s).a1=s.a1+1
& for i be Element of NAT st i <> 2 holds IExec(B3,s).intpos i=IExec(WH,IExec(
J4,s)).intpos i

proof
  set a=GBP;
  let s be 0-started State of SCMPDS;
  set s1=IExec(J4,s), Bt=IExec(B2, s);
A1: s1.a = (Initialize s1).a by SCMPDS_5:40;
A2: s1.a4 = (Initialize s1).a4 by SCMPDS_5:40;
A3: s1.a6 = (Initialize s1).a6 by SCMPDS_5:40;
A4: s1.a3 = (Initialize s1).a3 by SCMPDS_5:40;
A5: s1.a1 = (Initialize s1).a1 by SCMPDS_5:40;
A6: s1.a2 = (Initialize s1).a2 by SCMPDS_5:40;
A7: IExec(WH,s1) = IExec(WH,Initialize s1) by SCMPDS_5:48;
  assume that
A8: s.a3 >= s.a1+7 and
A9: s.a=0;
A10: s1.a1 = s.a1+1 by A9,Lm11;
A11: s1.a3 =s.a3+1 by A9,Lm11;
A12: s1.a2=s.a2 by A9,Lm11;
  s1.a6 =s.a1+1 & s.a3+1 >= 7+s.a1+1 by A8,A9,Lm11,XREAL_1:8;
  then
A13: s1.a4 >= 7+s1.a6 by A9,Lm11;
A14: s1.GBP =0 by A9,Lm11;
  then
A15: DataLoc(s1.a,6)=intpos (0+6) by SCMP_GCD:5;
  then WH is_closed_on Initialize s1 & WH is_halting_on Initialize s1
 by A14,A13,Lm9,A1,A2,A3;
  then
A16: WH is_closed_on s1 & WH is_halting_on s1 by SCMPDS_6:139,140;
A17: J4 is_closed_on s & J4 is_halting_on s by SCMPDS_6:34,35;
  then
A18: Bt.a =IExec(WH,s1).a by A16,SCMPDS_7:49
    .=0 by A14,A15,A13,Lm10,A1,A2,A3,A7;
  then
A19: DataLoc(Bt.a,2)=intpos (0+2) by SCMP_GCD:5;
A20: B2 is_closed_on s & B2 is_halting_on s by A16,A17,SCMPDS_7:43;
  hence IExec(B3,s).a=Exec(jf, Bt).a by SCMPDS_7:50
    .=0 by A18,A19,AMI_3:52,SCMPDS_2:60;
  thus IExec(B3,s).a2=Exec(jf, Bt).a2 by A20,SCMPDS_7:50
    .=Bt.a2+ -1 by A19,SCMPDS_2:60
    .=Bt.a2-1
    .=IExec(WH,s1).a2 -1 by A16,A17,SCMPDS_7:49
    .=s.a2-1 by A14,A12,A15,A13,Lm10,A1,A2,A3,A6,A7;
  thus IExec(B3,s).a3=Exec(jf, Bt).a3 by A20,SCMPDS_7:50
    .=Bt.a3 by A19,AMI_3:52,SCMPDS_2:60
    .=IExec(WH,s1).a3 by A16,A17,SCMPDS_7:49
    .=s.a3+1 by A14,A11,A15,A13,Lm10,A1,A2,A3,A4,A7;
  thus IExec(B3,s).a1=Exec(jf, Bt).a1 by A20,SCMPDS_7:50
    .=Bt.a1 by A19,AMI_3:52,SCMPDS_2:60
    .=IExec(WH,s1).a1 by A16,A17,SCMPDS_7:49
    .=s.a1+1 by A14,A10,A15,A13,Lm10,A1,A2,A3,A5,A7;
  hereby
    let i be Element of NAT;
    assume
A21: i<> 2;
    thus IExec(B3,s).intpos i=Exec(jf, Bt).intpos i by A20,SCMPDS_7:50
      .=Bt.intpos i by A19,A21,AMI_3:52,SCMPDS_2:60
      .=IExec(WH,s1).intpos i by A16,A17,SCMPDS_7:49;
  end;
end;

Lm13: for s being 0-started State of SCMPDS st s.a3 >= s.a1+7 & s.GBP=0
holds FR
is_closed_on s & FR is_halting_on s

proof
  let s be 0-started State of SCMPDS;
  set a=GBP, b=DataLoc(s.a,2);
  assume that
A1: s.a3 >= s.a1+7 and
A2: s.a=0;
A3: b=intpos(0+2) by A2,SCMP_GCD:5;
  now
    let t be State of SCMPDS;
    assume that
A4: t.a3 >= t.a1+7 and
A5: t.a=s.a and
    t.b >0;
    set t1=IExec(J4,t);
A6: t1=IExec(J4,Initialize t) by SCMPDS_5:48;
A7: t.a = (Initialize t).a by SCMPDS_5:40;
A8: t.b = (Initialize t).b by SCMPDS_5:40;
A9: t.a1 = (Initialize t).a1 by SCMPDS_5:40;
A10: t.a3 = (Initialize t).a3 by SCMPDS_5:40;
A11: t1.a = (Initialize t1).a by SCMPDS_5:40;
A12: t1.a4 = (Initialize t1).a4 by SCMPDS_5:40;
A13: t1.a6 = (Initialize t1).a6 by SCMPDS_5:40;
A14: IExec(B3,t)=IExec(B3,Initialize t) by SCMPDS_5:48;
A15: t.a3+1 >= 7+t.a1+1 by A4,XREAL_1:8;
    thus IExec(B3,t).a=t.a by A2,A4,A5,Lm12,A7,A9,A10,A14;
    thus IExec(B3,t).b=t.b-1 by A2,A3,A4,A5,Lm12,A7,A9,A10,A14,A8;
A16: J4 is_closed_on t & J4 is_halting_on t by SCMPDS_6:34,35;
    t1.a6 =t.a1+1 by A2,A5,Lm11,A6,A7,A9;
    then
A17: t1.a4 >= 7+t1.a6 by A2,A5,A15,Lm11,A6,A7,A10;
A18: t1.a =0 by A2,A5,Lm11,A6,A7;
    then DataLoc(t1.a,6)=intpos (0+6) by SCMP_GCD:5;
    then WH is_closed_on Initialize t1 & WH is_halting_on Initialize t1
     by A18,A17,Lm9,A12,A13,A11;
    then WH is_closed_on t1 & WH is_halting_on t1 by SCMPDS_6:139,140;
    hence B2 is_closed_on t & B2 is_halting_on t by A16,SCMPDS_7:43;
    IExec(B3,t).a1=t.a1+1 by A2,A4,A5,Lm12,A7,A9,A10,A14;
    hence IExec(B3,t).a3>=IExec(B3,t).a1+7 by A2,A4,A5,A15,Lm12,A7,A9,A10,A14;
  end;
  hence thesis by A1,Th12;
end;

Lm14: for s being 0-started State of SCMPDS
 st s.a3 >= s.a1+7 & s.GBP=0 & s.a2 > 0 holds
IExec(FR,s) = IExec(FR,IExec(B3,s))

proof
  let s be 0-started State of SCMPDS;
  set a=GBP, b=DataLoc(s.a,2);
  assume that
A1: s.a3 >= s.a1+7 and
A2: s.a=0 and
A3: s.a2 > 0;
A4: b=intpos(0+2) by A2,SCMP_GCD:5;
  now
    let t be State of SCMPDS;
    assume that
A5: t.a3 >= t.a1+7 and
A6: t.a=s.a and
    t.b >0;
    set t1=IExec(J4,t);
A7: t1=IExec(J4,Initialize t) by SCMPDS_5:48;
A8: IExec(B3,Initialize t)=IExec(B3,t) by SCMPDS_5:48;
A9: t.a = (Initialize t).a by SCMPDS_5:40;
A10: t.b = (Initialize t).b by SCMPDS_5:40;
A11: t.a3 = (Initialize t).a3 by SCMPDS_5:40;
A12: t.a1 = (Initialize t).a1 by SCMPDS_5:40;
A13: t.a3+1 >= 7+t.a1+1 by A5,XREAL_1:8;
    thus IExec(B3,t).a=t.a by A2,A5,A6,Lm12,A8,A9,A12,A11;
    thus IExec(B3,t).b=t.b-1 by A2,A4,A5,A6,Lm12,A8,A9,A10,A12,A11;
A14: J4 is_closed_on t & J4 is_halting_on t by SCMPDS_6:34,35;
    t1.a6 =t.a1+1 by A2,A6,Lm11,A7,A9,A12;
    then
A15: t1.a4 >= 7+t1.a6 by A2,A6,A13,Lm11,A7,A9,A11;
A16: t1.a = (Initialize t1).a by SCMPDS_5:40;
A17: t1.a4 = (Initialize t1).a4 by SCMPDS_5:40;
A18: t1.a6 = (Initialize t1).a6 by SCMPDS_5:40;
A19: t1.a =0 by A2,A6,Lm11,A7,A9;
    then DataLoc(t1.a,6)=intpos (0+6) by SCMP_GCD:5;
    then WH is_closed_on Initialize t1 & WH is_halting_on Initialize t1
    by A19,A15,Lm9,A16,A17,A18;
    then WH is_closed_on t1 & WH is_halting_on t1 by SCMPDS_6:139,140;
    hence B2 is_closed_on t & B2 is_halting_on t by A14,SCMPDS_7:43;
    IExec(B3,t).a1=t.a1+1 by A2,A5,A6,Lm12,A8,A9,A12,A11;
    hence IExec(B3,t).a3>=IExec(B3,t).a1+7
       by A2,A5,A6,A13,Lm12,A8,A9,A12,A11;
  end;
  hence thesis by A1,A3,A4,Th13;
end;

begin :: The Property of Insert Sort and Its Correctness

theorem
  card insert-sort (n,p0) = 23
proof
  set i1= GBP:=0, i2= (GBP,1):=0, i3= (GBP,2):=(n-1), i4= (GBP,3):=p0;
  thus card insert-sort (n,p0) =card(i1 ';' i2 ';' i3 ';' i4) + card FR by
AFINSQ_1:20
    .=card(i1 ';' i2 ';' i3)+1 + card FR by SCMP_GCD:8
    .=card(i1 ';' i2)+1+1 + card FR by SCMP_GCD:8
    .=2+1+1+card FR by SCMP_GCD:9
    .=4+(card B2+3) by SCMPDS_7:60
    .=23 by Lm6;
end;

theorem
  p0 >= 7 implies insert-sort (n,p0) is parahalting
proof
  set a=GBP, i1= a:=0, i2= (a,1):=0, i3= (a,2):=(n-1), i4= (a,3):=p0, I= i1
  ';' i2 ';' i3 ';' i4;
  assume
A1: p0 >= 7;
  now
    let s be State of SCMPDS;
    set s1=IExec(I,s), s2=IExec(i1 ';' i2 ';' i3,s), s3=IExec(i1 ';' i2,s), s4
    =Exec(i1, Initialize s);
A2: s1=IExec(I,Initialize s) by SCMPDS_5:48;
A3: s2=IExec(i1 ';' i2 ';' i3,Initialize s) by SCMPDS_5:48;
A4: s3=IExec(i1 ';' i2,Initialize s) by SCMPDS_5:48;
A5: s1.a = (Initialize s1).a by SCMPDS_5:40;
A6: s1.a1 = (Initialize s1).a1 by SCMPDS_5:40;
A7: s1.a3 = (Initialize s1).a3 by SCMPDS_5:40;
A8: Initialize Initialize s = Initialize s;
A9: I is_closed_on s & I is_halting_on s by SCMPDS_6:34,35;
A10: s4.a=0 by SCMPDS_2:57;
    then
A11: DataLoc(s4.a,1)=intpos (0+1) by SCMP_GCD:5;
A12: s3.a=Exec(i2,s4).a by A4,A8,SCMPDS_5:47
      .=0 by A10,A11,AMI_3:52,SCMPDS_2:58;
    then
A13: DataLoc(s3.a,2)=intpos (0+2) by SCMP_GCD:5;
A14: s3.a1=Exec(i2,s4).a1 by A4,A8,SCMPDS_5:47
      .=0 by A11,SCMPDS_2:58;
A15: s2.a1=Exec(i3,s3).a1 by A3,A4,SCMPDS_5:46
      .=0 by A14,A13,AMI_3:52,SCMPDS_2:58;
A16: s2.a=Exec(i3,s3).a by A3,A4,SCMPDS_5:46
      .=0 by A12,A13,AMI_3:52,SCMPDS_2:58;
    then
A17: DataLoc(s2.a,3)=intpos (0+3) by SCMP_GCD:5;
A18: s1.a3=Exec(i4,s2).a3 by A2,A3,SCMPDS_5:46
      .=p0 by A17,SCMPDS_2:58;
    s1.a1=Exec(i4,s2).a1 by A2,A3,SCMPDS_5:46
      .=0 by A15,A17,AMI_3:52,SCMPDS_2:58;
    then
A19: s1.a3 >= s1.a1+7 by A1,A18;
    s1.a=Exec(i4,s2).a by A2,A3,SCMPDS_5:46
      .=0 by A16,A17,AMI_3:52,SCMPDS_2:58;
    then FR is_closed_on Initialize s1 & FR is_halting_on Initialize s1
        by A19,Lm13,A5,A6,A7;
    then FR is_closed_on s1 & FR is_halting_on s1 by SCMPDS_6:139,140;
    hence insert-sort (n,p0) is_halting_on s by A9,SCMPDS_7:43;
  end;
  hence thesis by SCMPDS_6:35;
end;

Lm15: for s being State of SCMPDS st s.a4 >= 7+s.a6 & s.GBP=0 & s.a6 >0 holds
IExec(WH,s) =IExec(WH,IExec(B1,s))

proof
  let s be State of SCMPDS;
  set a=GBP, b=DataLoc(s.a,6);
  assume that
A1: s.a4 >= 7+s.a6 and
A2: s.a=0 and
A3: s.a6 > 0;
A4: b=intpos(0+6) by A2,SCMP_GCD:5;
A5: now
    let t be State of SCMPDS;
    assume that
A6: for x st x in {a4} holds t.x >= 7+t.b and
A7: t.a=s.a & t.b >0;
A8: IExec(B1,t) = IExec(B1,Initialize t) by SCMPDS_5:48;
A9: t.a = (Initialize t).a by SCMPDS_5:40;
A10: t.b = (Initialize t).b by SCMPDS_5:40;
A11: t.a4 = (Initialize t).a4 by SCMPDS_5:40;
    set Bt=IExec(B1,t);
A12: a4 in {a4} by TARSKI:def 1;
    then
A13: t.a4 >= 7+t.a6 by A4,A6;
    hence IExec(B1,t).a=t.a by A2,A4,A7,Lm7,A8,A9,A10,A11;
    thus B1 is_closed_on t & B1 is_halting_on t by SCMPDS_6:34,35;
    thus IExec(B1,t).b < t.b by A2,A4,A7,A13,Lm8,A8,A9,A10,A11;
    t.a4 >= 7+t.b by A6,A12;
    then Bt.a4 >= 7+Bt.a6 by A2,A4,A7,Lm8,A8,A9,A10,A11;

    hence for x st x in {a4} holds IExec(B1,t).x >= 7+IExec(B1,t).b by A4,
TARSKI:def 1;

  end;
  for x st x in {a4} holds s.x >= 7+s.b by A1,A4,TARSKI:def 1;
  hence thesis by A3,A4,A5,Lm5,SCMPDS_8:29;
end;

theorem Th17:
  for s being 0-started State of SCMPDS,
  f,g be FinSequence of INT, k0,k
being Element of NAT st s.(intpos 4) >= 7+s.(intpos 6) & s.GBP=0 & k=s.(intpos
  6) & k0=s.(intpos 4)-s.(intpos 6)-1 & f is_FinSequence_on s,k0 & g
is_FinSequence_on IExec(while>0(GBP,6,((GBP,5):=(intpos 4,-1)) ';' (SubFrom(GBP
,5,intpos 4,0)) ';' (if>0(GBP,5, ((GBP,5):=(intpos 4,-1)) ';' ((intpos 4,-1):=(
intpos 4,0)) ';' ((intpos 4,0 ):=(GBP,5)) ';' (AddTo(GBP,4,-1)) ';' (AddTo(GBP,
  6,-1)),Load ((GBP,6):=0)))),s),k0 & len f=len g & len f > k & f
  is_non_decreasing_on 1,k holds f,g are_fiberwise_equipotent & g
  is_non_decreasing_on 1,k+1 & (for i be Element of NAT st i>k+1 & i <= len f
  holds f.i=g.i) & for i be Element of NAT st 1 <= i & i <= k+1 holds ex j be
  Element of NAT st 1 <= j & j <= k+1 & g.i=f.j
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,
      f,g be FinSequence of INT,m,n be Element of NAT;
  assume
A1: s.a4 >= 7+s.a6 & s.a=0 & n=s.a6 & m=s.a4-s.a6-1;
  defpred P[Element of NAT] means for t be State of SCMPDS,f1,f2 be
  FinSequence of INT st t.a4 >= 7+t.a6 & t.a=0 & $1=t.a6 & m=t.a4-t.a6-1 & f1
  is_FinSequence_on t,m & f2 is_FinSequence_on IExec(WH,t),m & len f1=len f2 &
len f1 > $1 & f1 is_non_decreasing_on 1,$1 holds f1,f2 are_fiberwise_equipotent
  & f2 is_non_decreasing_on 1,$1+1 & (for i be Element of NAT st i>$1+1 & i <=
  len f1 holds f1.i=f2.i) & (for i be Element of NAT st 1 <= i & i <= $1+1 ex j
  be Element of NAT st 1 <= j & j <= $1+1 & f2.i=f1.j);
  assume
A2: f is_FinSequence_on s,m & g is_FinSequence_on IExec(WH,s),m;
A3: now
    let k be Element of NAT;
    assume
A4: P[k];
    now
      let t be State of SCMPDS,f1,f2 be FinSequence of INT;
      assume that
A5:   t.a4 >= 7+t.a6 and
A6:   t.a=0 and
A7:   k+1=t.a6 and
A8:   m=t.a4-t.a6-1 and
A9:   f1 is_FinSequence_on t,m and
A10:  f2 is_FinSequence_on IExec(WH,t),m and
A11:  len f1=len f2 and
A12:  len f1 > k+1 and
A13:  f1 is_non_decreasing_on 1,k+1;
      set Bt=IExec(B1,t), x=DataLoc(t.a4,-1), y=DataLoc(t.a4,0);
A14:   Bt=IExec(B1,Initialize t) by SCMPDS_5:48;
A15:   t.a = (Initialize t).a by SCMPDS_5:40;
A16:   t.a4 = (Initialize t).a4 by SCMPDS_5:40;
A17:   t.a6 = (Initialize t).a6 by SCMPDS_5:40;
A18:   t.x = (Initialize t).x by SCMPDS_5:40;
A19:   t.y = (Initialize t).y by SCMPDS_5:40;
A20:  Bt.a=0 by A5,A6,A7,Lm7,A14,A15,A16,A17;
      m+1+(k+1) >= 7+t.a6 by A5,A7,A8;
      then
A21:  m+1 >= 7 by A7,XREAL_1:8;
A22:  x=DataLoc(m,k+1) by A7,A8
        .=intpos(m+(k+1)) by SCMP_GCD:5;
A23:  t.x > t.y implies Bt.x=t.y & Bt.y =t.x & Bt.a6=t.a6-1 & Bt.a4=t.a4-
      1 by A5,A6,A7,Lm8,A14,A15,A16,A17,A18,A19;
A24:  t.x <= t.y implies Bt.x=t.x & Bt.y =t.y & Bt.a6=0
 by A5,A6,A7,Lm8,A14,A15,A16,A17,A18,A19;
A25:  y=intpos(m+(k+2)) by A7,A8,SCMP_GCD:5;
A26:  Bt.a4 >= 7+Bt.a6 by A5,A6,A7,Lm8,A14,A15,A16,A17;
      per cases;
      suppose
A27:    t.x > t.y;
        now
          let i be Element of NAT;
          assume
          1<=i & i <= len f2;
          hence f2.i=IExec(WH,t).intpos(m+i) by A10,Def1
            .=IExec(WH,Bt).intpos(m+i) by A5,A6,A7,Lm15;
        end;
        then
A28:    f2 is_FinSequence_on IExec(WH,Bt),m by Def1;
A29:    k+1 < k+2 by XREAL_1:8;
        consider h be FinSequence of INT such that
A30:    len h=len f1 and
A31:    for i be Element of NAT st 1<=i & i <= len h holds h.i=Bt.
        intpos(m+ i) by Th2;
        k+1 > k by XREAL_1:31;
        then
A32:    len h > k by A12,A30,XXREAL_0:2;
A33:    now
          let i be Element of NAT;
          assume that
A34:      i <> k+1 & i<>k+2 and
A35:      1 <= i and
A36:      i <= len f1;
A37:      m+i <> t.a4-1 & m+i <> t.a4 by A7,A8,A34;
          m+i >= m+1 by A35,XREAL_1:8;
          then
A38:      m+i >= 7 by A21,XXREAL_0:2;
A39:       t.intpos(m+i) = (Initialize t).intpos(m+i) by SCMPDS_5:40;
          thus h.i=Bt.intpos(m+i) by A30,A31,A35,A36
            .=t.intpos(m+i) by A5,A6,A7,A38,A37,Lm8,A14,A15,A16,A17,A39
            .=f1.i by A9,A35,A36,Def1;
        end;
        now
          let i,j be Element of NAT;
          assume that
A40:      1 <= i and
A41:      i <= j and
A42:      j <= k;
A43:      j <= len f1 by A30,A32,A42,XXREAL_0:2;
          then
A44:      i <= len f1 by A41,XXREAL_0:2;
A45:      k < k+1 by XREAL_1:31;
          then
A46:      j < k+1 by A42,XXREAL_0:2;
          k+1 < k+1+1 by XREAL_1:31;
          then
A47:      k < k+1+1 by A45,XXREAL_0:2;
          j >= 1 by A40,A41,XXREAL_0:2;
          then
A48:      h.j=f1.j by A33,A42,A45,A47,A43;
          j < k+2 by A42,A47,XXREAL_0:2;
          then h.i=f1.i by A33,A40,A41,A46,A44;
          hence h.i <= h.j by A13,A40,A41,A46,A48,GRAPH_2:def 13;
        end;
        then
A49:    h is_non_decreasing_on 1,k by GRAPH_2:def 13;
A50:    len f1 >= k+1+1 by A12,INT_1:20;
A51:    1 <= k+1 by NAT_1:11;
        then
A52:    1 <= k+2 by A29,XXREAL_0:2;
        then
A53:    h.(k+2)=t.x by A25,A23,A27,A30,A31,A50;
        then
A54:    h.(k+2)=f1.(k+1) by A9,A12,A22,A51,Def1;
A55:    Bt.a4-Bt.a6-1=m by A8,A23,A27;
A56:    h.(k+1)=t.y by A12,A22,A23,A27,A30,A31,NAT_1:11;
        then h.(k+1)=f1.(k+2) by A9,A25,A52,A50,Def1;
        then
A57:    f1,h are_fiberwise_equipotent by A12,A30,A33,A51,A52,A50,A54,Th4;
A58:    h is_FinSequence_on Bt,m by A31,Def1;
        then
        h,f2 are_fiberwise_equipotent by A4,A7,A11,A20,A26,A23,A27,A30,A55,A28
,A32,A49;
        hence f1,f2 are_fiberwise_equipotent by A57,CLASSES1:84;
A59:    f2 is_non_decreasing_on 1, k+1 by A4,A7,A11,A20,A26,A23,A27,A30,A55,A58
,A28,A32,A49;
        now
          let i,j be Element of NAT;
          assume that
A60:      1 <= i and
A61:      i <= j and
A62:      j <= (k+1)+1;
          per cases by A62,NAT_1:8;
          suppose
            j <= k+1;
            hence f2.i <= f2.j by A59,A60,A61,GRAPH_2:def 13;
          end;
          suppose
A63:        j = k+1+1;
            hereby
              per cases;
              suppose
                i=j;
                hence f2.i <= f2.j;
              end;
              suppose
                i<>j;
                then i < j by A61,XXREAL_0:1;
                then i <= k+1 by A63,NAT_1:13;
                then consider mm be Element of NAT such that
A64:            1 <= mm and
A65:            mm <= k+1 and
A66:            f2.i=h.mm by A4,A7,A11,A20,A26,A23,A27,A30,A55,A58,A28,A32,A49
,A60;
A67:            f2.j=h.(k+2) by A4,A7,A11,A20,A26,A23,A27,A30,A55,A58,A28,A32
,A49,A29,A50,A63;
                hereby
                  per cases;
                  suppose
                    mm=k+1;
                    hence
                    f2.i <= f2.j by A12,A22,A23,A24,A30,A31,A53,A64,A66,A67;
                  end;
                  suppose
A68:                mm<>k+1;
                    mm < k+2 by A29,A65,XXREAL_0:2;
                    then mm < len h by A30,A50,XXREAL_0:2;
                    then
A69:                h.mm=f1.mm by A30,A33,A29,A64,A65,A68;
                    f2.j=f1.(k+1) by A9,A12,A22,A51,A53,A67,Def1;
                    hence f2.i <= f2.j by A13,A64,A65,A66,A69,GRAPH_2:def 13;
                  end;
                end;
              end;
            end;
          end;
        end;
        hence f2 is_non_decreasing_on 1,(k+1)+1 by GRAPH_2:def 13;
        hereby
          let i be Element of NAT;
          assume that
A70:      i>(k+1)+1 and
A71:      i <= len f1;
A72:      k+1 < k+1+1 by XREAL_1:31;
          then
A73:      i > k+1 by A70,XXREAL_0:2;
          1 <= k+1 by NAT_1:11;
          then
A74:      1 <= i by A73,XXREAL_0:2;
          thus f2.i=h.i by A4,A7,A11,A20,A26,A23,A27,A30,A55,A58,A28,A32,A49
,A71,A73
            .=f1.i by A33,A70,A71,A72,A74;
        end;
        hereby
          let i be Element of NAT;
          assume that
A75:      1 <= i and
A76:      i <= (k+1)+1;
          per cases;
          suppose
A77:        i=k+1+1;
            take j=k+1;
            thus 1 <= j by NAT_1:11;
            thus j <= (k+1)+1 by NAT_1:11;
            thus f2.i=f1.j by A4,A7,A11,A20,A26,A23,A27,A30,A55,A58,A28,A32,A49
,A29,A50,A54,A77;
          end;
          suppose
            i<>k+1+1;
            then i < k+1+1 by A76,XXREAL_0:1;
            then i <= k+1 by NAT_1:13;
            then consider mm be Element of NAT such that
A78:        1 <= mm and
A79:        mm <= k+1 and
A80:        f2.i=h.mm by A4,A7,A11,A20,A26,A23,A27,A30,A55,A58,A28,A32,A49,A75;
            hereby
A81:          k+2=(k+1)+1;
              per cases;
              suppose
A82:            mm=k+1;
                take j=k+2;
                thus 1 <= j by A81,NAT_1:11;
                thus j <= k+1+1;
                thus f2.i=f1.j by A9,A25,A52,A50,A56,A80,A82,Def1;
              end;
              suppose
A83:            mm<>k+1;
                take mm;
                thus 1 <= mm by A78;
                thus mm <= k+1+1 by A29,A79,XXREAL_0:2;
                mm < k+2 by A29,A79,XXREAL_0:2;
                then mm < len f1 by A50,XXREAL_0:2;
                hence f2.i=f1.mm by A33,A29,A78,A79,A80,A83;
              end;
            end;
          end;
        end;
      end;
      suppose
A84:    t.x <= t.y;
A85:    now
          let i be Nat;
          assume that
A86:      i>=1 and
A87:      i <= len f1;
A88:      i in NAT by ORDINAL1:def 13;
          then
A89:      f1.i=t.intpos(m+i) by A9,A86,A87,Def1;
A90:      Bt.DataLoc(Bt.a,6) =0 by A20,A24,A84,SCMP_GCD:5;
          m+i >= m+1 by A86,XREAL_1:8;
          then
A91:      m+i >= 7 by A21,XXREAL_0:2;
A92:       t.intpos(m+i) = (Initialize t).intpos(m+i) by SCMPDS_5:40;
          per cases;
          suppose
A93:        m+i=t.a4-1;
            hence f1.i=IExec(WH,Bt).x by A7,A8,A22,A24,A84,A89,A90,SCMPDS_8:23
              .=IExec(WH,t).x by A5,A6,A7,Lm15
              .=f2.i by A7,A8,A10,A11,A12,A22,A86,A93,Def1;
          end;
          suppose
A94:        m+i=t.a4;
            hence f1.i=IExec(WH,Bt).y by A7,A8,A25,A24,A84,A89,A90,SCMPDS_8:23
              .=IExec(WH,t).y by A5,A6,A7,Lm15
              .=f2.i by A7,A8,A10,A11,A25,A86,A87,A94,Def1;
          end;
          suppose
            m+i<>t.a4-1 & m+i<>t.a4;
            hence f1.i=Bt.intpos (m+i)
             by A5,A6,A7,A91,A89,Lm8,A14,A15,A16,A17,A92
              .=IExec(WH,Bt).intpos (m+i) by A90,SCMPDS_8:23
              .=IExec(WH,t).intpos (m+i) by A5,A6,A7,Lm15
              .=f2.i by A10,A11,A88,A86,A87,Def1;
          end;
        end;
        then
A95:    f1=f2 by A11,FINSEQ_1:18;
        thus f1,f2 are_fiberwise_equipotent by A11,A85,FINSEQ_1:18;
        now
          let i, j be Element of NAT;
          assume that
A96:      1 <= i and
A97:      i <= j and
A98:      j <= (k+1)+1;
          per cases by A98,NAT_1:8;
          suppose
            j <= k+1;
            hence f1.i <= f1.j by A13,A96,A97,GRAPH_2:def 13;
          end;
          suppose
A99:        j = k+1+1;
            hereby
              per cases;
              suppose
                i=j;
                hence f1.i <= f1.j;
              end;
              suppose
                i<>j;
                then i < j by A97,XXREAL_0:1;
                then i <= k+1 by A99,NAT_1:13;
                then
A100:            f1.i <= f1.(k+1) by A13,A96,GRAPH_2:def 13;
                1<=k+1 by NAT_1:11;
                then
A101:            f1.(k+1)=t.x by A9,A12,A22,Def1;
                1<=(k+1)+1 & j<=len f1 by A12,A99,INT_1:20,NAT_1:11;
                then f1.j=t.y by A9,A25,A99,Def1;
                hence f1.i <= f1.j by A84,A100,A101,XXREAL_0:2;
              end;
            end;
          end;
        end;
        hence f2 is_non_decreasing_on 1,(k+1)+1 by A95,GRAPH_2:def 13;
        thus for i be Element of NAT st i>(k+1)+1 & i <= len f1 holds f1.i=f2.
        i by A11,A85,FINSEQ_1:18;
        thus for i be Element of NAT st 1 <= i & i <= (k+1)+1 ex j be Element
        of NAT st 1 <= j & j <= (k+1)+1 & f2.i=f1.j by A95;
      end;
    end;
    hence P[k+1 qua Element of NAT];
  end;
A102: P[0 qua Element of NAT]
  proof
    let t be State of SCMPDS,f1,f2 be FinSequence of INT;
    assume that
    t.a4 >= 7+t.a6 and
A103: t.a=0 & 0=t.a6 and
    m=t.a4-t.a6-1 and
A104: f1 is_FinSequence_on t,m and
A105: f2 is_FinSequence_on IExec(WH,t),m and
A106: len f1=len f2 and
    len f1 > 0 and
    f1 is_non_decreasing_on 1,0;
A107: t.DataLoc(t.a,6) =0 by A103,SCMP_GCD:5;
A108: now
      let i be Nat;
      assume
A109: 1 <= i & i <= len f1;
A110: i in NAT by ORDINAL1:def 13;
      hence f1.i=t.intpos(m+i) by A104,A109,Def1
        .=IExec(WH,t).intpos(m+i) by A107,SCMPDS_8:23
        .=f2.i by A105,A106,A110,A109,Def1;
    end;
    hence f1,f2 are_fiberwise_equipotent by A106,FINSEQ_1:18;
    thus f2 is_non_decreasing_on 1,0+1 by Th1;
    thus for i be Element of NAT st i>0+1 & i <= len f1 holds f1.i=f2.i by A108
;
    f1=f2 by A106,A108,FINSEQ_1:18;
    hence thesis;
  end;
A111: for k be Element of NAT holds P[k] from NAT_1:sch 1(A102,A3);
  assume
  len f= len g & len f > n & f is_non_decreasing_on 1,n;
  hence thesis by A1,A2,A111;
end;

Lm16: for s being 0-started State of SCMPDS,
f,g be FinSequence of INT, p0,n being
Element of NAT st s.GBP=0 & s.a2=n-1 & s.a3=p0+1 & s.a1=0 & p0 >= 6 & f
is_FinSequence_on s,p0 & g is_FinSequence_on IExec(FR,s),p0 & len f=n & len g =
n holds f,g are_fiberwise_equipotent & g is_non_decreasing_on 1,n

proof
  set a=GBP;
  let s be 0-started State of SCMPDS,
      f,g be FinSequence of INT,p0,n be Element of NAT;
  assume that
A1: s.a=0 and
A2: s.a2=n-1 and
A3: s.a3=p0+1 and
A4: s.a1=0 and
A5: p0 >= 6 and
A6: f is_FinSequence_on s,p0 & g is_FinSequence_on IExec(FR,s),p0 and
A7: len f=n and
A8: len g = n;
  per cases;
  suppose
A9: n=0;
    then g={} by A8;
    hence f,g are_fiberwise_equipotent by A7,A9;
    thus thesis by A9,Th1;
  end;
  suppose
    n<>0;
    then n >= 1+0 by INT_1:20;
    then n-1 >= 0 by XREAL_1:21;
    then reconsider n1=n-1 as Element of NAT by INT_1:16;

    defpred P[Nat] means for t be State of SCMPDS,f1,f2 be FinSequence of INT,

m be Element of NAT st t.a=0 & t.a2+t.a1=n-1 & t.a2=$1 & m=n-t.a2 & p0=t.a3-t.
    a1-1 & f1 is_FinSequence_on t,p0 & f2 is_FinSequence_on IExec(FR,t),p0 & f1
    is_non_decreasing_on 1,m & len f1=n & len f2 = n holds f1,f2
    are_fiberwise_equipotent & f2 is_non_decreasing_on 1,n;

A10: s.a2+s.a1=n-1+0 & 1=n-s.a2 by A2,A4;
A11: now
      let k be Element of NAT;
      assume
A12:  P[k];
      now

        let t be State of SCMPDS,f1,f2 be FinSequence of INT, m be Element of
        NAT;

        assume that
A13:    t.a=0 and
A14:    t.a2+t.a1=n-1 and
A15:    t.a2=k+1 and
A16:    m=n-t.a2 and
A17:    p0=t.a3-t.a1-1 and
A18:    f1 is_FinSequence_on t,p0 and
A19:    f2 is_FinSequence_on IExec(FR,t),p0 and
A20:    f1 is_non_decreasing_on 1,m & len f1=n and
A21:    len f2 = n;
        set t1=IExec(J4,t), Bt=IExec(B3,t);
A22: t1=IExec(J4,Initialize t) by SCMPDS_5:48;
A23: Bt=IExec(B3,Initialize t) by SCMPDS_5:48;
A24: t.a = (Initialize t).a by SCMPDS_5:40;
A25: t.a3 = (Initialize t).a3 by SCMPDS_5:40;
A26: t.a1 = (Initialize t).a1 by SCMPDS_5:40;
A27: t.a2 = (Initialize t).a2 by SCMPDS_5:40;
A28: t1.a = (Initialize t1).a by SCMPDS_5:40;
A29: t1.a4 = (Initialize t1).a4 by SCMPDS_5:40;
A30: t1.a6 = (Initialize t1).a6 by SCMPDS_5:40;
A31:    t1.a4 =t.a3+1 by A13,Lm11,A22,A24,A25;
        p0+(t.a1+1)=t.a3 by A17;
        then t.a3 >= 6+(t.a1+1) by A5,XREAL_1:8;
        then
A32:    t.a3 >= 6+1+t.a1;
        then
A33:    Bt.a=0 by A13,Lm12,A23,A24,A25,A26;
A34:    Bt.a2=t.a2-1 by A13,A32,Lm12,A23,A24,A25,A26,A27;
        then
A35:    n-Bt.a2=m+1 by A16;
A36:    Bt.a1=t.a1+1 by A13,A32,Lm12,A23,A24,A25,A26;
        then
A37:    Bt.a2+Bt.a1=n-1 by A14,A34;
        Bt.a3=t.a3+1 by A13,A32,Lm12,A23,A24,A25,A26;
        then
A38:    Bt.a3-Bt.a1-1=p0 by A17,A36;
A39:    t1.a6 =t.a1+1 by A13,Lm11,A22,A24,A26;
        then
A40:    p0=t1.a4-t1.a6-1 by A17,A31;
A41:    IExec(FR,t) = IExec(FR,Initialize t) by SCMPDS_5:48;
        now
          let i be Element of NAT;
          assume
          1 <= i & i <= len f2;
          hence f2.i=IExec(FR,t).intpos(p0+i) by A19,Def1
            .= IExec(FR,Bt).intpos(p0+i)
             by A13,A15,A32,Lm14,A23,A24,A25,A26,A27,A41;
        end;
        then
A42:    f2 is_FinSequence_on IExec(FR,Bt),p0 by Def1;
        now
A43:      p0+1 >= 6+1 by A5,XREAL_1:8;
          let i be Element of NAT;
          assume that
A44:      1 <= i and
A45:      i <= len f1;
          p0+1 <= p0+i by A44,XREAL_1:8;
          then
A46:      p0+i >= 7 by A43,XXREAL_0:2;
A47:      t.intpos(p0+i) = (Initialize t).intpos(p0+i) by SCMPDS_5:40;
          thus f1.i=t.intpos(p0+i) by A18,A44,A45,Def1
            .= t1.intpos(p0+i)
             by A13,A46,Lm11,A22,A24,A47;
        end;
        then
A48:    f1 is_FinSequence_on t1,p0 by Def1;
        t1.a4=p0+(t1.a6+1) by A17,A31,A39;
        then t1.a4 >= 6+(t1.a6+1) by A5,XREAL_1:8;
        then
A49:    t1.a4 >= 6+1+t1.a6;
        m+(k+1)=n by A15,A16;
        then
A50:    n > 0+m by XREAL_1:8;
        consider h be FinSequence of INT such that
A51:    len h=n and

A52:    for i be Element of NAT st 1<=i & i <= len h holds h.i=IExec(
        WH,t1) .intpos(p0+i) by Th2;
A53:     IExec(WH,t1) = IExec(WH,Initialize t1) by SCMPDS_5:48;
A54:    h is_FinSequence_on IExec(WH,t1),p0 by A52,Def1;
        now
A55:      p0+1 >= 6+1 by A5,XREAL_1:8;
          let i be Element of NAT;
          assume that
A56:      1 <= i and
A57:      i <= len h;
          p0+1 <= p0+i by A56,XREAL_1:8;
          then p0+i >= 7 by A55,XXREAL_0:2;
          then
A58:      p0+i > 2 by XXREAL_0:2;
          thus h.i=IExec(WH,t1).intpos(p0+i) by A52,A56,A57
            .= Bt.intpos(p0+i) by A13,A32,A58,Lm12,A22,A23,A24,A25,A26;
        end;
        then
A59:    h is_FinSequence_on Bt,p0 by Def1;
A60: f1 is_FinSequence_on (Initialize t1),p0
  proof let i be Element of NAT;
   assume 1 <= i & i <= len f1;
    then f1.i=t1.intpos(p0+i) by A48,Def1;
   hence thesis by SCMPDS_5:40;
  end;
A61:    t1.a =0 by A13,Lm11,A22,A24;
        then
A62:    f1,h are_fiberwise_equipotent by A14,A16,A17,A20,A31,A51,A40,A49,A54
,A50,Th17,A29,A30,A53,A28,A60;

A63:    h is_non_decreasing_on 1,m +1 by A14,A16,A17,A20,A31,A51,A40,A49,A54
,A50,Th17,A29,A30,A53,A28,A60,A61;
        then h,f2 are_fiberwise_equipotent by A12,A15,A16,A21,A51,A33,A37,A35
,A38,A59,A42;
        hence f1,f2 are_fiberwise_equipotent by A62,CLASSES1:84;

        thus f2 is_non_decreasing_on 1,n by A12,A15,A16,A21,A51,A63,A33,A37,A35
,A38,A59,A42;

      end;
      hence P[k+1];
    end;
A64: P[0]
    proof

      let t be State of SCMPDS,f1,f2 be FinSequence of INT, m be Element of
      NAT;

      assume that
A65:  t.a=0 and
      t.a2+t.a1=n-1 and
A66:  t.a2=0 and
A67:  m=n-t.a2 and
      p0=t.a3-t.a1-1 and
A68:  f1 is_FinSequence_on t,p0 and
A69:  f2 is_FinSequence_on IExec(FR,t),p0 and
A70:  f1 is_non_decreasing_on 1,m and
A71:  len f1=n & len f2 = n;
A72:  t.DataLoc(t.a,2)=0 by A65,A66,SCMP_GCD:5;
A73:  now
        let i be Nat;
        assume
A74:    1 <= i & i <= len f2;
A75:    i in NAT by ORDINAL1:def 13;
        hence f2.i=IExec(FR,t).intpos(p0+i) by A69,A74,Def1
          .=t.intpos(p0+i) by A72,SCMPDS_7:66
          .=f1.i by A68,A71,A75,A74,Def1;
      end;
      hence f1,f2 are_fiberwise_equipotent by A71,FINSEQ_1:18;
      thus thesis by A66,A67,A70,A71,A73,FINSEQ_1:18;
    end;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A64,A11);
    then
A76: P[n1];
    p0=s.a3-s.a1-1 & f is_non_decreasing_on 1,1 by A3,A4,Th1;
    hence thesis by A1,A6,A7,A8,A10,A76;
  end;
end;

theorem
  for s being 0-started State of SCMPDS,f,g be FinSequence of INT,p0,
      n being Element of NAT
     st p0 >= 6 & len f=n & len g = n & f is_FinSequence_on s,p0 &
     g is_FinSequence_on IExec(insert-sort(n,p0+1),s),p0
      holds f,g are_fiberwise_equipotent & g is_non_decreasing_on 1,n
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,f,g be FinSequence of INT,p0,
      n be Element of NAT;
  assume that
A1: p0 >= 6 and
A2: len f=n & len g = n and
A3: f is_FinSequence_on s,p0 and
A4: g is_FinSequence_on IExec(insert-sort(n,p0+1),s),p0;
A5: p0+1 >= 6+1 by A1,XREAL_1:8;
  set i1= GBP:=0, i2= (GBP,1):=0, i3= (GBP,2):=(n-1), i4= (GBP,3):=(p0+1);
  set t0=Initialize s, I4=i1 ';' i2 ';' i3 ';' i4, t1=IExec(I4,s), t2=IExec(
  i1 ';' i2 ';' i3,s), t3=IExec(i1 ';' i2,s), t4=Exec(i1, t0);
A6: t4.a=0 by SCMPDS_2:57;
  then
A7: DataLoc(t4.a,1)=intpos (0+1) by SCMP_GCD:5;
A8: t3.a =Exec(i2, t4).a by SCMPDS_5:47
    .=0 by A6,A7,AMI_3:52,SCMPDS_2:58;
  then
A9: DataLoc(t3.a,2)=intpos (0+2) by SCMP_GCD:5;
A10: t2.a =Exec(i3, t3).a by SCMPDS_5:46
    .=0 by A8,A9,AMI_3:52,SCMPDS_2:58;
  then
A11: DataLoc(t2.a,3)=intpos (0+3) by SCMP_GCD:5;
A12: now
    let i be Element of NAT;
    assume
    i > 3;
    hence t4.intpos i=t0.intpos i by AMI_3:52,SCMPDS_2:57
      .=s.intpos i by SCMPDS_5:40;
  end;
A13: now
    let i be Element of NAT;
    assume
A14: i > 3;
    then
A15: i > 1 by XXREAL_0:2;
    thus t3.intpos i =Exec(i2, t4).intpos i by SCMPDS_5:47
      .=t4.intpos i by A7,A15,AMI_3:52,SCMPDS_2:58
      .=s.intpos i by A12,A14;
  end;
A16: now
    let i be Element of NAT;
    assume
A17: i > 3;
    then
A18: i > 2 by XXREAL_0:2;
    thus t2.intpos i =Exec(i3, t3).intpos i by SCMPDS_5:46
      .=t3.intpos i by A9,A18,AMI_3:52,SCMPDS_2:58
      .=s.intpos i by A13,A17;
  end;
  now
    let i be Element of NAT;
    assume that
A19: 1 <= i and
A20: i <= len f;
    set pi=p0+i;
    pi >= p0+1 by A19,XREAL_1:8;
    then pi >= 7 by A5,XXREAL_0:2;
    then
A21: pi > 3 by XXREAL_0:2;
    thus (Initialize t1).intpos pi = t1.intpos pi by SCMPDS_5:40
      .=Exec(i4, t2).intpos pi by SCMPDS_5:46
      .=t2.intpos pi by A11,A21,AMI_3:52,SCMPDS_2:58
      .=s.intpos pi by A16,A21
      .=f.i by A3,A19,A20,Def1;
  end;
  then
A22: f is_FinSequence_on Initialize t1,p0 by Def1;
A23: t3.a1 =Exec(i2, t4).a1 by SCMPDS_5:47
    .=0 by A7,SCMPDS_2:58;
A24: t2.a1 =Exec(i3, t3).a1 by SCMPDS_5:46
    .=0 by A23,A9,AMI_3:52,SCMPDS_2:58;
A25: I4 is_closed_on s & I4 is_halting_on s by SCMPDS_6:34,35;
A26: t1.a =Exec(i4, t2).a by SCMPDS_5:46
    .=0 by A10,A11,AMI_3:52,SCMPDS_2:58;
A27: t2.a2 =Exec(i3, t3).a2 by SCMPDS_5:46
    .=n-1 by A9,SCMPDS_2:58;
A28: t1.a3 =Exec(i4, t2).a3 by SCMPDS_5:46
    .=p0+1 by A11,SCMPDS_2:58;
A29:  t1.a3 = (Initialize t1).a3 by SCMPDS_5:40;
A30:  t1.a1 = (Initialize t1).a1 by SCMPDS_5:40;
A31:  t1.a = (Initialize t1).a by SCMPDS_5:40;
A32:  t1.a2 = (Initialize t1).a2 by SCMPDS_5:40;
A33: t1.a1 =Exec(i4, t2).a1 by SCMPDS_5:46
    .=0 by A24,A11,AMI_3:52,SCMPDS_2:58;
  then t1.a3 >= t1.a1+7 by A28,A5;
  then FR is_closed_on Initialize t1 & FR is_halting_on Initialize t1
     by A26,Lm13,A29,A30,A31;
  then
A34: FR is_closed_on t1 & FR is_halting_on t1 by SCMPDS_6:139,140;
  now
    let i be Element of NAT;
    assume
    1 <= i & i <= len g;
    hence g.i=IExec(I4 ';' FR,s).intpos(p0+i) by A4,Def1
      .=IExec(FR,t1).intpos(p0+i) by A25,A34,SCMPDS_7:49;
  end;
  then
A35: g is_FinSequence_on IExec(FR,t1),p0 by Def1;
A36: IExec(FR,t1) = IExec(FR,Initialize t1) by SCMPDS_5:48;
  t1.a2 =Exec(i4, t2).a2 by SCMPDS_5:46
    .=n-1 by A27,A11,AMI_3:52,SCMPDS_2:58;
  hence thesis by A1,A2,A26,A33,A28,A22,A35,Lm16,A29,A30,A31,A32,A36;
end;

