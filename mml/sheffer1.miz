:: Axiomatization of {B}oolean Algebras Based on Sheffer Stroke
::  by Violetta Kozarkiewicz and Adam Grabowski
::
:: Received May 31, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabularies LATTICES, BINOP_1, BOOLE, MIDSP_1, VECTSP_2, REALSET1, SUBSET_1,
      FUNCT_1, ARYTM_3, ROBBINS1, SHEFFER1, RELAT_1;
 notations TARSKI, XBOOLE_0, STRUCT_0, LATTICES, VECTSP_2, BINOP_1, MIDSP_1,
      ROBBINS1;
 constructors BINOP_1, REALSET1, MIDSP_1, VECTSP_2, ROBBINS1;
 registrations SUBSET_1, STRUCT_0, LATTICES, TEX_2, LATTICE6, ROBBINS1;
 definitions LATTICES, ROBBINS1;
 theorems STRUCT_0, ROBBINS1, LATTICES;

begin :: Preliminaries

theorem Th1: :: ROBBINS1:18
  for L being join-commutative join-associative Huntington
    (non empty ComplLattStr),
      a, b being Element of L holds
     (a + b)` = a` *' b`
  proof
    let L be join-commutative join-associative Huntington
    (non empty ComplLattStr);
    let a, b be Element of L;
     a + b = (a` *' b`)` by ROBBINS1:18;
    hence thesis by ROBBINS1:3;
  end;

begin :: Huntington's First Axiomatization of Boolean Algebras

definition let IT be non empty LattStr;
  attr IT is upper-bounded' means :Def1:
    ex c being Element of IT st
    for a being Element of IT holds c "/\" a = a & a "/\" c = a;
end;

definition let L be non empty LattStr;
  assume A1: L is upper-bounded';
  func Top' L -> Element of L means :Def2:
    for a being Element of L holds it "/\" a = a & a "/\" it = a;
  existence by A1,Def1;
  uniqueness
    proof
     let c1,c2 be Element of L such that
A2:  for a being Element of L holds c1"/\"a = a & a"/\"c1 = a and
A3:  for a being Element of L holds c2"/\"a = a & a"/\"c2 = a;
     thus c1 = c2"/\"c1 by A3
            .= c2 by A2;
    end;
end;

definition let IT be non empty LattStr;
  attr IT is lower-bounded' means :Def3:
    ex c being Element of IT st
      for a being Element of IT holds c "\/" a = a & a "\/" c = a;
end;

definition let L be non empty LattStr;
  assume A1: L is lower-bounded';
  func Bot' L -> Element of L means :Def4:
    for a being Element of L holds it "\/" a = a & a "\/" it = a;
  existence by A1,Def3;
  uniqueness
  proof
    let c1,c2 be Element of L such that
A2: for a being Element of L holds c1"\/"a = a & a"\/"c1 = a and
A3: for a being Element of L holds c2"\/"a = a & a"\/"c2 = a;
    thus c1 = c2"\/"c1 by A3
           .= c2 by A2;
  end;
end;

definition let IT be non empty LattStr;
  attr IT is distributive' means :Def5:
    for a, b, c being Element of IT holds
      a "\/" (b "/\" c) = (a "\/" b) "/\" (a "\/" c);
end;

definition let L be non empty LattStr,
               a, b be Element of L;
  pred a is_a_complement'_of b means :Def6:
    b "\/" a = Top' L & a "\/" b = Top' L &
    b "/\" a = Bot' L & a "/\" b = Bot' L;
end;

definition let IT be non empty LattStr;
  attr IT is complemented' means :Def7:
    for b being Element of IT
    ex a being Element of IT st a is_a_complement'_of b;
end;

definition let L be non empty LattStr,
               x be Element of L;
  assume A1:L is complemented' distributive upper-bounded' meet-commutative;
  func x `# -> Element of L means :Def8:
    it is_a_complement'_of x;
  existence by A1,Def7;
  uniqueness
    proof
     let a,b be Element of L such that
A2:           a is_a_complement'_of x and
A3:           b is_a_complement'_of x;
      b = b "/\" Top' L by A1,Def2
      .= b "/\" (x "\/" a) by A2,Def6
      .= (b "/\" x) "\/" (b "/\" a) by A1,LATTICES:def 11
      .= (x "/\" b) "\/" (b "/\" a) by A1,LATTICES:def 6
      .= (x "/\" b) "\/" (a "/\" b) by A1,LATTICES:def 6
      .= (Bot' L) "\/" (a "/\" b) by A3,Def6
      .= (a "/\" x) "\/" (a "/\" b) by A2,Def6
      .= a "/\" (x "\/" b) by A1,LATTICES:def 11
      .= a "/\" Top' L by A3,Def6
      .= a by A1,Def2;
     hence thesis;
   end;
end;

registration
  cluster Boolean join-idempotent upper-bounded' complemented'
     distributive' lower-bounded' Lattice-like (non empty LattStr);
  existence
  proof
    consider L being trivial non empty Lattice;
     for b being Element of L
     ex a being Element of L st a is_a_complement_of b
    proof
      let b be Element of L;
      take a = b;
       b "\/" a = Top L & a "\/" b = Top L &
      b "/\" a = Bottom L & a "/\" b = Bottom L by STRUCT_0:def 10;
      hence thesis by LATTICES:def 18;
    end;
then A1: L is complemented by LATTICES:def 19;
     for a, b, c being Element of L holds
      a "/\" (b "\/" c) = (a "/\" b) "\/" (a "/\" c) by STRUCT_0:def 10;
then A2: L is distributive by LATTICES:def 11;
A3: L is lower-bounded
    proof
      consider x being Element of L;
       for y be Element of L holds
        x "/\" y = x & y "/\" x = x by STRUCT_0:def 10;
      hence thesis by LATTICES:def 13;
    end;
     L is upper-bounded
    proof
      consider x being Element of L;
       for y be Element of L holds
        x "\/" y = x & y "\/" x = x by STRUCT_0:def 10;
      hence thesis by LATTICES:def 14;
    end;
    then L is bounded by A3,LATTICES:def 15;
then A4: L is Boolean by A1,A2,LATTICES:def 20;
A5: L is join-idempotent
    proof
      let x be Element of L;
      thus thesis by STRUCT_0:def 10;
    end;
A6: L is upper-bounded'
    proof
      consider x being Element of L;
       for y be Element of L holds
        x "/\" y = y & y "/\" x = y by STRUCT_0:def 10;
      hence thesis by Def1;
    end;
     for b being Element of L
     ex a being Element of L st a is_a_complement'_of b
    proof
      let b be Element of L;
      take a = b;
       b "\/" a = Top' L & a "\/" b = Top' L &
      b "/\" a = Bot' L & a "/\" b = Bot' L by STRUCT_0:def 10;
      hence thesis by Def6;
    end;
then A7: L is complemented' by Def7;
     for a, b, c being Element of L holds
      a "\/" (b "/\" c) = (a "\/" b) "/\" (a "\/" c) by STRUCT_0:def 10;
then A8: L is distributive' by Def5;
     L is lower-bounded'
    proof
      consider x being Element of L;
       for y be Element of L holds
        x "\/" y = y & y "\/" x = y by STRUCT_0:def 10;
      hence thesis by Def3;
    end;
    hence thesis by A4,A5,A6,A7,A8;
  end;
end;

canceled;

theorem Th3:
  for L being complemented' join-commutative meet-commutative
     distributive upper-bounded' distributive' (non empty LattStr)
  for x be Element of L holds
    x "\/" x `# = Top' L
  proof
    let L be complemented' join-commutative meet-commutative
      distributive upper-bounded' distributive' (non empty LattStr);
    let x be Element of L;
     x `# is_a_complement'_of x by Def8;
    hence thesis by Def6;
  end;

theorem Th4:
  for L being complemented' join-commutative meet-commutative distributive
    upper-bounded' distributive' (non empty LattStr)
  for x being Element of L holds
    x "/\" x `# = Bot' L
  proof
    let L be complemented' join-commutative meet-commutative
      distributive upper-bounded' distributive' (non empty LattStr);
    let x be Element of L;
     x `# is_a_complement'_of x by Def8;
    hence thesis by Def6;
  end;

theorem Th5:
  for L being complemented' join-commutative meet-commutative
    join-idempotent distributive upper-bounded' distributive'
    (non empty LattStr)
  for x being Element of L holds
    x "\/" Top' L = Top' L
  proof
    let L be complemented' join-commutative meet-commutative
      join-idempotent distributive upper-bounded' distributive'
         (non empty LattStr);
    let x be Element of L;
     x "\/" Top' L = (x "\/" Top' L) "/\" Top' L by Def2
                 .= (x "\/" Top' L) "/\" (x "\/" (x `# )) by Th3
                 .= x "\/" (Top' L "/\" x`# ) by Def5
                 .= x "\/" x `# by Def2
                 .= Top' L by Th3;
    hence thesis;
  end;

theorem Th6:
  for L being complemented' join-commutative meet-commutative
    join-idempotent distributive upper-bounded' lower-bounded' distributive'
        (non empty LattStr)
  for x being Element of L holds
    x "/\" Bot' L = Bot' L
  proof
    let L be complemented' join-commutative meet-commutative
          join-idempotent distributive upper-bounded'
          lower-bounded' distributive' (non empty LattStr);
    let x be Element of L;
     x "/\" Bot' L = (x "/\" Bot' L) "\/" Bot' L by Def4
                 .= (x "/\" Bot' L) "\/" (x "/\" x`# ) by Th4
                 .= x "/\" (Bot' L "\/" x`# ) by LATTICES:def 11
                 .= x "/\" x`# by Def4
                 .= Bot' L by Th4;
    hence thesis;
  end;

theorem Th7:
  for L being join-commutative meet-absorbing meet-commutative
    join-absorbing join-idempotent distributive (non empty LattStr)
  for x, y, z being Element of L holds
    ((x "\/" y) "\/" z) "/\" x = x
  proof
    let L be join-commutative meet-absorbing meet-commutative join-absorbing
      join-idempotent distributive (non empty LattStr);
    let x, y, z be Element of L;
     ((x "\/" y) "\/" z) "/\" x
      = (x "/\" (x "\/" y)) "\/" (x "/\" z) by LATTICES:def 11
     .= (x "/\" x) "\/" (x "/\" y) "\/" (x "/\" z) by LATTICES:def 11
     .= x "\/" (x "/\" y) "\/" (x "/\" z) by LATTICES:18
     .= x "\/" (x "/\" z) by LATTICES:def 8
     .= x by LATTICES:def 8;
    hence thesis;
  end;

theorem Th8:
  for L being join-commutative meet-absorbing meet-commutative
    join-absorbing join-idempotent distributive' (non empty LattStr)
  for x, y, z being Element of L holds
    ((x "/\" y) "/\" z) "\/" x = x
  proof
    let L be join-commutative meet-absorbing meet-commutative join-absorbing
          join-idempotent distributive' (non empty LattStr);
    let x, y, z be Element of L;
     ((x "/\" y) "/\" z) "\/" x
         = (x "\/" (x "/\" y)) "/\" (x "\/" z) by Def5
        .= (x "\/" x) "/\" (x "\/" y) "/\" (x "\/" z) by Def5
        .= x "/\" (x "\/" y) "/\" (x "\/" z) by LATTICES:17
        .= x "/\" (x "\/" z) by LATTICES:def 9
        .= x by LATTICES:def 9;
    hence thesis;
  end;

definition let G be non empty /\-SemiLattStr;
  attr G is meet-idempotent means :Def9:
    for x being Element of G holds
      x "/\" x = x;
end;

theorem Th9:
  for L being complemented' join-commutative meet-commutative distributive
    upper-bounded' lower-bounded' distributive' (non empty LattStr) holds
      L is meet-idempotent
  proof
    let L be complemented' join-commutative meet-commutative distributive
       upper-bounded' lower-bounded' distributive' (non empty LattStr);
     now let x be Element of L;
      thus x "/\" x = (x "/\" x) "\/" Bot' L by Def4
                   .= (x "/\" x) "\/" (x "/\" x`# ) by Th4
                   .= x "/\" (x "\/" x`# ) by LATTICES:def 11
                   .= x "/\" Top' L by Th3
                   .= x by Def2;
    end;
    hence thesis by Def9;
  end;

theorem Th10:
  for L being complemented' join-commutative meet-commutative distributive
      upper-bounded' lower-bounded' distributive' (non empty LattStr) holds
      L is join-idempotent
  proof
    let L be complemented' join-commutative meet-commutative distributive
      upper-bounded' lower-bounded' distributive' (non empty LattStr);
    let x be Element of L;
    thus x "\/" x = (x "\/" x) "/\" Top' L by Def2
                 .= (x "\/" x) "/\" (x "\/" x`# ) by Th3
                 .= x "\/" (x "/\" x`# ) by Def5
                 .= x "\/" Bot' L by Th4
                 .= x by Def4;
  end;

theorem Th11:
  for L being complemented' join-commutative meet-commutative
    join-idempotent distributive upper-bounded' distributive'
      (non empty LattStr) holds
      L is meet-absorbing
  proof
    let L be complemented' join-commutative meet-commutative
      join-idempotent distributive upper-bounded' distributive'
        (non empty LattStr);
    let y, x be Element of L;
     x "\/" (x "/\" y) = (Top' L "/\" x) "\/" (x "/\" y) by Def2
                     .= x "/\" (Top' L "\/" y) by LATTICES:def 11
                     .= x "/\" Top' L by Th5
                     .= x by Def2;
    hence thesis;
  end;

theorem Th12:
  for L being complemented' join-commutative upper-bounded'
    meet-commutative join-idempotent distributive distributive'
      lower-bounded' (non empty LattStr) holds
      L is join-absorbing
  proof
    let L be complemented' join-commutative upper-bounded'
       meet-commutative join-idempotent distributive distributive'
       lower-bounded' (non empty LattStr);
    let x, y be Element of L;
A1: L is meet-idempotent by Th9;
A2: L is meet-absorbing by Th11;
     x "/\" (x "\/" y) = (x "/\" x) "\/" (x "/\" y) by LATTICES:def 11
                     .= x "\/" (x "/\" y) by A1,Def9
                     .= x by A2,LATTICES:def 8;
    hence thesis;
  end;

theorem Th13:
  for L being complemented' join-commutative meet-commutative
    upper-bounded' lower-bounded' join-idempotent distributive
      distributive' (non empty LattStr) holds
      L is upper-bounded
  proof
    let L be complemented' join-commutative meet-commutative
       upper-bounded' lower-bounded' join-idempotent
         distributive distributive' (non empty LattStr);
     ex c being Element of L st
    for a being Element of L holds c"\/"a = c & a"\/"c = c
    proof
      take c = Top' L;
      let a be Element of L;
      thus thesis by Th5;
    end;
    hence thesis by LATTICES:def 14;
  end;

theorem Th14:
  for L being Boolean Lattice-like (non empty LattStr) holds
    L is upper-bounded'
  proof
    let L be Boolean Lattice-like (non empty LattStr);
     ex c being Element of L st
    for a being Element of L holds c "/\" a = a & a "/\" c = a
    proof
      take c = Top L;
      let a be Element of L;
       a [= c by LATTICES:45;
      hence thesis by LATTICES:21;
    end;
    hence thesis by Def1;
  end;

theorem Th15:
  for L being complemented' join-commutative meet-commutative
      upper-bounded' lower-bounded' join-idempotent
        distributive distributive' (non empty LattStr) holds
      L is lower-bounded
  proof
    let L be complemented' join-commutative meet-commutative
      upper-bounded' lower-bounded' join-idempotent
        distributive distributive' (non empty LattStr);
     ex c being Element of L st
    for a being Element of L holds c"/\"a = c & a"/\"c = c
    proof
      take c = Bot' L;
      let a be Element of L;
      thus thesis by Th6;
    end;
    hence thesis by LATTICES:def 13;
  end;

theorem Th16:
  for L being Boolean Lattice-like (non empty LattStr) holds
      L is lower-bounded'
  proof
    let L be Boolean Lattice-like (non empty LattStr);
     ex c being Element of L st
    for a being Element of L holds c "\/" a = a & a "\/" c = a
    proof
      take c = Bottom L;
      let a be Element of L;
       c [= a by LATTICES:41;
      hence thesis by LATTICES:def 3;
    end;
    hence thesis by Def3;
  end;

theorem Th17:
  for L being join-commutative meet-commutative meet-absorbing
    join-absorbing join-idempotent distributive (non empty LattStr) holds
      L is join-associative
  proof
    let L be join-commutative meet-commutative meet-absorbing
      join-absorbing join-idempotent distributive (non empty LattStr);
    let x, y, z be Element of L;
A1: ((x "\/" y) "\/" z) "/\" x = x by Th7;
A2: ((y "\/" z) "\/" x) "/\" y = y
    proof
      ((y "\/" z) "\/" x) "/\" y
        = (y "/\" (y "\/" z)) "\/" (y "/\" x) by LATTICES:def 11
       .= (y "/\" y) "\/" (y "/\" z) "\/" (y "/\" x) by LATTICES:def 11
       .= y "\/" (y "/\" z) "\/" (y "/\" x) by LATTICES:18
       .= y "\/" (y "/\" x) by LATTICES:def 8
       .= y by LATTICES:def 8;
      hence thesis;
    end;
     x "\/" (y "\/" z) = (x "\/" y) "\/" z
    proof
      set A = ((x "\/" y) "\/" z) "/\" (x "\/" (y "\/" z));
A3:    A = (((x "\/" y) "\/" z) "/\" x) "\/" (((x "\/" y) "\/" z) "/\"
           (y "\/" z)) by LATTICES:def 11
        .= x "\/" ((((x "\/" y) "\/" z) "/\" y) "\/"
           (((x "\/" y) "\/" z) "/\" z)) by A1,LATTICES:def 11
        .= x "\/" (y "\/" (((x "\/" y) "\/" z) "/\" z)) by Th7
        .= x "\/" (y "\/" (((x "\/" y ) "/\" z) "\/" (z "/\" z)))
           by LATTICES:def 11
        .= x "\/" (y "\/" (((x "\/" y ) "/\" z) "\/" z)) by LATTICES:18
        .= x "\/" (y "\/" z) by LATTICES:def 8;
        A = ((x "\/" y) "/\" (x "\/" (y "\/" z))) "\/"
           (z "/\" (x "\/" (y "\/" z))) by LATTICES:def 11
        .= ((x "\/" y) "/\" (x "\/" (y "\/" z))) "\/" z by Th7
        .= ((x "/\" (x "\/" (y "\/" z))) "\/" (y "/\" (x "\/" (y "\/" z))))
           "\/" z by LATTICES:def 11
        .= (x "\/" y) "\/" z by A2,LATTICES:def 9;
        hence thesis by A3;
     end;
   hence thesis;
  end;

theorem Th18:
  for L being join-commutative meet-commutative meet-absorbing
    join-absorbing join-idempotent distributive' (non empty LattStr) holds
      L is meet-associative
  proof
    let L be join-commutative meet-commutative meet-absorbing
      join-absorbing join-idempotent distributive' (non empty LattStr);
    let x, y, z be Element of L;
A1: ((x "/\" y) "/\" z) "\/" x = x by Th8;
A2: ((y "/\" z) "/\" x) "\/" y = y
    proof
       ((y "/\" z) "/\" x) "\/" y
        = (y "\/" (y "/\" z)) "/\" (y "\/" x) by Def5
       .= (y "\/" y) "/\" (y "\/" z) "/\" (y "\/" x) by Def5
       .= y "/\" (y "\/" z) "/\" (y "\/" x) by LATTICES:17
       .= y "/\" (y "\/" x) by LATTICES:def 9
       .= y by LATTICES:def 9;
         hence thesis;
     end;
     x "/\" (y "/\" z) = (x "/\" y) "/\" z
    proof
      set A = ((x "/\" y) "/\" z) "\/" (x "/\" (y "/\" z));
A3:    A = (((x "/\" y) "/\" z) "\/" x) "/\" (((x "/\" y) "/\" z) "\/"
           (y "/\" z)) by Def5
        .= x "/\" ((((x "/\" y) "/\" z) "\/" y) "/\"
           (((x "/\" y) "/\" z) "\/" z)) by A1,Def5
        .= x "/\" (y "/\" (((x "/\" y) "/\" z) "\/" z)) by Th8
        .= x "/\" (y "/\" (((x "/\" y ) "\/" z) "/\" (z "\/" z)))
           by Def5
        .= x "/\" (y "/\" (((x "/\" y ) "\/" z) "/\" z)) by LATTICES:17
        .= x "/\" (y "/\" z) by LATTICES:def 9;
        A = ((x "/\" y) "\/" (x "/\" (y "/\" z))) "/\"
           (z "\/" (x "/\" (y "/\" z))) by Def5
        .= ((x "/\" y) "\/" (x "/\" (y "/\" z))) "/\" z by Th8
        .= ((x "\/" (x "/\" (y "/\" z))) "/\" (y "\/" (x "/\" (y "/\" z))))
           "/\" z by Def5
        .= (x "/\" y) "/\" z by A2,LATTICES:def 8;
        hence thesis by A3;
    end;
    hence thesis;
  end;

theorem Th19:
  for L being complemented' join-commutative meet-commutative
      lower-bounded' upper-bounded' join-idempotent distributive
        distributive' (non empty LattStr) holds
      Top L = Top' L
  proof
    let L be complemented' join-commutative meet-commutative
       lower-bounded' upper-bounded' join-idempotent distributive
         distributive' (non empty LattStr);
A1: L is upper-bounded by Th13;
    set Y = Top' L;
     for a being Element of L holds Y "\/" a = Y & a "\/" Y = Y by Th5;
    hence thesis by A1,LATTICES:def 17;
  end;

theorem Th20:
  for L being complemented' join-commutative meet-commutative
     lower-bounded' upper-bounded' join-idempotent distributive
       distributive' (non empty LattStr) holds
      Bottom L = Bot' L
  proof
    let L be complemented' join-commutative meet-commutative
      lower-bounded' upper-bounded' join-idempotent distributive
        distributive' (non empty LattStr);
A1: L is lower-bounded by Th15;
    set Y = Bot' L;
     for a being Element of L holds Y "/\" a = Y & a "/\" Y = Y by Th6;
    hence thesis by A1,LATTICES:def 16;
  end;

theorem Th21:
  for L being Boolean distributive' Lattice-like (non empty LattStr) holds
    Top L = Top' L
  proof
    let L be Boolean distributive' Lattice-like (non empty LattStr);
A1: L is upper-bounded' by Th14;
    set Y = Top L;
     for a being Element of L holds Y "/\" a = a & a "/\" Y = a
      by LATTICES:43;
    hence thesis by A1,Def2;
  end;

theorem Th22:
  for L being Boolean complemented lower-bounded upper-bounded distributive
    distributive' Lattice-like (non empty LattStr) holds
      Bottom L = Bot' L
  proof
    let L be Boolean complemented lower-bounded upper-bounded distributive
      distributive' Lattice-like (non empty LattStr);
A1: L is lower-bounded' by Th16;
    set Y = Bottom L;
     for a being Element of L holds Y "\/" a = a & a "\/" Y = a
      by LATTICES:39;
    hence thesis by A1,Def4;
  end;

theorem
   for L being complemented' lower-bounded' upper-bounded' join-commutative
    meet-commutative join-idempotent distributive distributive'
              (non empty LattStr),
      x, y being Element of L holds
      x is_a_complement'_of y iff x is_a_complement_of y
  proof
    let L be complemented' lower-bounded' upper-bounded' join-commutative
      meet-commutative join-idempotent distributive distributive'
           (non empty LattStr),
        x, y be Element of L;
    hereby assume x is_a_complement'_of y;
      then x "\/" y = Top' L & y "\/" x = Top' L & x "/\" y = Bot' L &
        y "/\" x = Bot' L by Def6;
      then x "\/" y = Top L & y "\/" x = Top L & x "/\" y = Bottom L &
        y "/\" x = Bottom L by Th19,Th20;
      hence x is_a_complement_of y by LATTICES:def 18;
    end;
    assume x is_a_complement_of y;
    then x "\/" y = Top L & y "\/" x = Top L & x "/\" y = Bottom L &
      y "/\" x = Bottom L by LATTICES:def 18;
    then x "\/" y = Top' L & y "\/" x = Top' L & x "/\" y = Bot' L &
      y "/\" x = Bot' L by Th19,Th20;
    hence thesis by Def6;
   end;

theorem Th24:
  for L being complemented' join-commutative meet-commutative lower-bounded'
    upper-bounded' join-idempotent distributive distributive'
             (non empty LattStr) holds
      L is complemented
  proof
    let L be complemented' join-commutative meet-commutative lower-bounded'
       upper-bounded' join-idempotent distributive distributive'
         (non empty LattStr);
    for b being Element of L
    ex a being Element of L st a is_a_complement_of b
   proof
     let b be Element of L;
     consider a being Element of L such that
A1:  a is_a_complement'_of b by Def7;
      b "\/" a = Top' L & b "/\" a = Bot' L by A1,Def6;
     then b "\/" a = Top L & b "/\" a = Bottom L by Th19,Th20;
     then a is_a_complement_of b by LATTICES:def 18;
     hence thesis;
   end;
   hence thesis by LATTICES:def 19;
  end;

theorem Th25:
  for L being Boolean lower-bounded' upper-bounded' distributive'
    Lattice-like (non empty LattStr) holds
      L is complemented'
  proof
    let L be Boolean lower-bounded' upper-bounded' distributive'
      Lattice-like (non empty LattStr);
    for b being Element of L
    ex a being Element of L st a is_a_complement'_of b
   proof
     let b be Element of L;
     consider a being Element of L such that
A1:  a is_a_complement_of b by LATTICES:def 19;
      b "\/" a = Top L & b "/\" a = Bottom L by A1,LATTICES:def 18;
     then b "\/" a = Top' L & b "/\" a = Bot' L by Th21,Th22;
     then a is_a_complement'_of b by Def6;
     hence thesis;
   end;
   hence thesis by Def7;
  end;

theorem Th26:
  for L being non empty LattStr holds
    L is Boolean Lattice iff
      L is lower-bounded' upper-bounded' join-commutative meet-commutative
      distributive distributive' complemented'
  proof
    let L be non empty LattStr;
    thus L is Boolean Lattice implies
      L is lower-bounded' upper-bounded'
      join-commutative meet-commutative
      distributive distributive' complemented'
    proof
      assume A1: L is Boolean Lattice;
      then reconsider L' = L as Boolean Lattice;
       ex c being Element of L' st
        for a being Element of L' holds c "\/" a = a & a "\/" c = a
      proof
        take c = Bottom L';
        thus thesis by LATTICES:39;
      end;
      hence A2: L is lower-bounded' by Def3;
       ex c being Element of L' st
        for a being Element of L' holds c "/\" a = a & a "/\" c = a
      proof
        take c = Top L';
        thus thesis by LATTICES:43;
      end;
      hence A3: L is upper-bounded' by Def1;
      thus L is join-commutative meet-commutative by A1;
       for a,b,c being Element of L' holds
      a "/\" (b "\/" c) = (a "/\" b) "\/" (a "/\" c)
        by LATTICES:def 11;
      then for a, b, c being Element of L' holds
        a "\/" (b "/\" c) = (a "\/" b) "/\" (a "\/" c) by LATTICES:19;
      hence L is distributive distributive' by Def5;
      hence L is complemented' by A1,A2,A3,Th25;
    end;
    thus L is lower-bounded' upper-bounded'
         join-commutative meet-commutative
         distributive distributive' complemented' implies
      L is Boolean Lattice
    proof
      assume L is lower-bounded' upper-bounded'
      join-commutative meet-commutative
      distributive distributive' complemented';
      then reconsider L' = L as lower-bounded' upper-bounded' complemented'
      join-commutative meet-commutative join-idempotent
      distributive distributive' (non empty LattStr) by Th10;
A4:   L' is lower-bounded by Th15;
       L' is upper-bounded by Th13;
then A5:   L' is bounded by A4,LATTICES:def 15;
A6:   L' is complemented by Th24;
A7:   L' is meet-absorbing join-absorbing by Th11,Th12;
then A8:   L' is join-associative by Th17;
       L' is meet-associative by A7,Th18;
      hence thesis by A5,A6,A7,A8,LATTICES:def 10,def 20;
    end;
  end;

registration
  cluster Boolean Lattice-like -> lower-bounded' upper-bounded' complemented'
    join-commutative meet-commutative distributive distributive'
    (non empty LattStr);
  coherence by Th26;
  cluster lower-bounded' upper-bounded' complemented'
    join-commutative meet-commutative distributive distributive' ->
    Boolean Lattice-like (non empty LattStr);
  coherence by Th26;
end;

begin :: Axiomatization Based on Sheffer Stroke

definition
  struct (1-sorted) ShefferStr (# carrier -> set,
                                  stroke -> BinOp of the carrier #);
end;

definition
  struct (ShefferStr,LattStr) ShefferLattStr
                              (# carrier -> set,
                                  L_join -> BinOp of the carrier,
                                  L_meet -> BinOp of the carrier,
                                  stroke -> BinOp of the carrier #);
end;

definition
  struct (ShefferStr,OrthoLattStr) ShefferOrthoLattStr
                              (# carrier -> set,
                                  L_join -> BinOp of the carrier,
                                  L_meet -> BinOp of the carrier,
                                  Compl -> UnOp of the carrier,
                                  stroke -> BinOp of the carrier #);
end;

definition
  func TrivShefferOrthoLattStr -> ShefferOrthoLattStr equals
     ShefferOrthoLattStr (# {{}}, op2, op2, op1, op2 #);
  coherence;
end;

registration
  cluster non empty ShefferStr;
  existence
  proof
    set S = {{}};
    consider B being BinOp of S;
    take L = ShefferStr (#S, B#);
    thus thesis by STRUCT_0:def 1;
  end;
  cluster non empty ShefferLattStr;
  existence
  proof
    set S = {{}};
    consider B, C, D being BinOp of S;
    take L = ShefferLattStr (#S, B, C, D#);
    thus thesis by STRUCT_0:def 1;
  end;
  cluster non empty ShefferOrthoLattStr;
  existence
  proof
    set S = {{}};
    consider B, C, D being BinOp of S;
    consider A being UnOp of S;
    take L = ShefferOrthoLattStr (#S, B, C, A, D#);
    thus thesis by STRUCT_0:def 1;
  end;
end;

definition let L be non empty ShefferStr;
           let x, y be Element of L;
  func x | y -> Element of L equals
     (the stroke of L).(x,y);
  coherence;
end;

definition let L be non empty ShefferOrthoLattStr;
  attr L is properly_defined means :Def12:
    (for x being Element of L holds x | x = x`) &
    (for x, y being Element of L holds x "\/" y = (x | x) | (y | y)) &
    (for x, y being Element of L holds x "/\" y = (x | y) | (x | y)) &
    (for x, y being Element of L holds x | y = x` + y`);
end;

definition let L be non empty ShefferStr;
  attr L is satisfying_Sheffer_1 means :Def13:
    for x being Element of L holds
      (x | x) | (x | x) = x;
  attr L is satisfying_Sheffer_2 means :Def14:
    for x, y being Element of L holds
      x | (y | (y | y)) = x | x;
  attr L is satisfying_Sheffer_3 means :Def15:
    for x, y, z being Element of L holds
      (x | (y | z)) | (x | (y | z)) = ((y | y) | x) | ((z | z) | x);
end;

registration
  cluster trivial ->
    satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
      (non empty ShefferStr);
  coherence
  proof
    let L be non empty ShefferStr;
    assume
A1: L is trivial;
    thus L is satisfying_Sheffer_1
    proof
      let x be Element of L;
      thus thesis by A1,STRUCT_0:def 10;
    end;
    thus L is satisfying_Sheffer_2
    proof
      let x,y be Element of L;
      thus thesis by A1,STRUCT_0:def 10;
    end;
    let x, y, z be Element of L;
    thus thesis by A1,STRUCT_0:def 10;
  end;
end;

registration
  cluster trivial -> join-commutative join-associative
    (non empty \/-SemiLattStr);
  coherence
  proof
    let L be non empty \/-SemiLattStr;
    assume
A1: L is trivial;
    thus L is join-commutative
    proof
      let x, y be Element of L;
      thus thesis by A1,STRUCT_0:def 10;
    end;
    let x, y, z be Element of L;
    thus thesis by A1,STRUCT_0:def 10;
  end;
  cluster trivial -> meet-commutative meet-associative
    (non empty /\-SemiLattStr);
  coherence
  proof
    let L be non empty /\-SemiLattStr;
    assume
A2: L is trivial;
    thus L is meet-commutative
    proof
      let x, y be Element of L;
      thus thesis by A2,STRUCT_0:def 10;
    end;
    let x, y, z be Element of L;
    thus thesis by A2,STRUCT_0:def 10;
  end;
end;

registration
  cluster trivial -> join-absorbing meet-absorbing Boolean
    (non empty LattStr);
  coherence
  proof
    let L be non empty LattStr;
    assume
A1: L is trivial;
    thus L is join-absorbing
    proof
      let x, y be Element of L;
      thus thesis by A1,STRUCT_0:def 10;
    end;
    thus L is meet-absorbing
    proof
      let x, y be Element of L;
      thus thesis by A1,STRUCT_0:def 10;
    end;
A2: L is bounded
    proof
A3:   L is lower-bounded
      proof
        consider c being Element of L;
        take c;
        let a be Element of L;
        thus thesis by A1,STRUCT_0:def 10;
      end;
       L is upper-bounded
      proof
        consider c being Element of L;
        take c;
        let a be Element of L;
        thus thesis by A1,STRUCT_0:def 10;
      end;
      hence thesis by A3,LATTICES:def 15;
    end;
A4: L is complemented
    proof
      let b be Element of L;
      consider a being Element of L;
      take a;
       a "\/" b = Top L & b "\/" a = Top L &
        a "/\" b = Bottom L & b "/\" a = Bottom L
          by A1,STRUCT_0:def 10;
      hence thesis by LATTICES:def 18;
    end;
     L is distributive
    proof
      let a, b, c be Element of L;
      thus thesis by A1,STRUCT_0:def 10;
    end;
    hence thesis by A2,A4,LATTICES:def 20;
  end;
end;

registration
  cluster TrivShefferOrthoLattStr -> non empty;
  coherence by STRUCT_0:def 1;
  cluster TrivShefferOrthoLattStr -> trivial;
  coherence by STRUCT_0:def 9;
  cluster TrivShefferOrthoLattStr -> properly_defined well-complemented;
  coherence
  proof
    set L = TrivShefferOrthoLattStr;
    thus L is properly_defined
    proof
       (for x being Element of L holds x | x = x`) &
      (for x, y being Element of L holds x "\/" y = (x | x) | (y | y)) &
      (for x, y being Element of L holds x "/\" y = (x | y) | (x | y)) &
      (for x, y being Element of L holds x | y = x` + y`)
        by STRUCT_0:def 10;
      hence thesis by Def12;
    end;
     L is well-complemented
    proof
      let a be Element of L;
       a "\/" a` = Top L & a` "\/" a = Top L &
        a "/\" a` = Bottom L & a` "/\" a = Bottom L
          by STRUCT_0:def 10;
      hence thesis by LATTICES:def 18;
    end;
    hence thesis;
  end;
end;

registration
  cluster properly_defined Boolean well-complemented Lattice-like
    satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
     (non empty ShefferOrthoLattStr);
  existence
  proof
    take TrivShefferOrthoLattStr;
    thus thesis;
  end;
end;

theorem
   for L being properly_defined Boolean well-complemented
    Lattice-like (non empty ShefferOrthoLattStr) holds
      L is satisfying_Sheffer_1
  proof
    let L be properly_defined Boolean well-complemented
      Lattice-like (non empty ShefferOrthoLattStr);
    let x be Element of L;
     x`` = x by ROBBINS1:3;
    then (x | x)` = x by Def12;
    hence thesis by Def12;
  end;

theorem
   for L being properly_defined Boolean well-complemented Lattice-like
    (non empty ShefferOrthoLattStr) holds
      L is satisfying_Sheffer_2
  proof
    let L be properly_defined Boolean well-complemented Lattice-like
      (non empty ShefferOrthoLattStr);
    let x, y be Element of L;
      x` + Bot L = x` by ROBBINS1:14;
     then x` + (y`` *' y`) = x` by ROBBINS1:16;
     then x` + (y` + y)` = x` by Th1;
     then x | (y` + y) = x` by Def12;
     then x | (y` + y``) = x` by ROBBINS1:3;
     then x | (y | (y`)) = x` by Def12;
     then x | (y | (y | y)) = x` by Def12
                      .= x | x by Def12;
    hence thesis;
  end;

theorem
   for L being properly_defined Boolean well-complemented Lattice-like
    (non empty ShefferOrthoLattStr) holds
      L is satisfying_Sheffer_3
  proof
    let L be properly_defined Boolean well-complemented Lattice-like
      (non empty ShefferOrthoLattStr);
    let x, y, z be Element of L;
     x *' (y` + z`) = (y` *' x) + (z` *' x) by ROBBINS1:31;
    then (x` + (y | z)`)` = (y` *' x) + (z` *' x) by Def12;
    then (x | (y | z))` = (y` *' x) + (z` *' x) by Def12;
    then (x | (y | z)) | (x | (y | z)) = (y` *' x) + (z` *' x) by Def12
            .= (y` *' x``) + (z` *' x) by ROBBINS1:3
            .= (y` *' x``) + (z` *' x``) by ROBBINS1:3
            .= (y + x`)` + (z` *' x``) by Th1
            .= (y + x`)` + (z + x`)` by Th1
            .= (y + x`) | (z + x`) by Def12
            .= (y`` + x`) | (z + x`) by ROBBINS1:3
            .= (y`` + x`) | (z`` + x`) by ROBBINS1:3
            .= (y` | x) | (z`` + x`) by Def12
            .= (y` | x) | (z` | x) by Def12
            .= ((y | y) | x) | (z` | x) by Def12
            .= ((y | y) | x) | ((z | z) | x) by Def12;
    hence thesis;
  end;

definition let L be non empty ShefferStr;
           let a be Element of L;
  func a" -> Element of L equals
     a | a;
  coherence;
end;

theorem
  for L being satisfying_Sheffer_3 (non empty ShefferOrthoLattStr),
      x, y, z being Element of L holds
      (x | (y | z))" = (y" | x) | (z" | x) by Def15;

theorem
  for L being satisfying_Sheffer_1 (non empty ShefferOrthoLattStr),
      x being Element of L holds
      x = (x")" by Def13;

theorem Th32:
  for L being satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
    properly_defined (non empty ShefferOrthoLattStr),
      x, y being Element of L holds
      x | y = y | x
  proof
    let L be satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
          properly_defined (non empty ShefferOrthoLattStr);
    let x, y be Element of L;
     x | y = ((x | y)")" by Def13
         .= ((x | (y")")")" by Def13
         .= (((y")" |x)")" by Def15
         .= ((y | x)")" by Def13
         .= y | x by Def13;
    hence thesis;
  end;

theorem Th33:
  for L being satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
           properly_defined (non empty ShefferOrthoLattStr),
      x, y being Element of L holds
      x | (x | x) = y | (y | y)
  proof
    let L be satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
              properly_defined (non empty ShefferOrthoLattStr);
    let x, y be Element of L;
     x | (x | x) = ((x | x") | (x | x"))" by Def13
      .= ((x | x") | (y | y"))" by Def14
      .= ((y | y") | (x | (x | x)))" by Th32
      .= ((y | y")")" by Def14
      .= y | (y | y) by Def13;
    hence thesis;
  end;

theorem Th34:
  for L being satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
     properly_defined (non empty ShefferOrthoLattStr) holds
    L is join-commutative
  proof
    let L be satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
     properly_defined (non empty ShefferOrthoLattStr);
    let x, y be Element of L;
     x "\/" y = x" | (y | y) by Def12
             .= (y | y) | (x | x) by Th32
             .= y "\/" x by Def12;
    hence thesis;
  end;

theorem Th35:
  for L being satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
     properly_defined (non empty ShefferOrthoLattStr) holds
    L is meet-commutative
  proof
    let L be satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
        properly_defined (non empty ShefferOrthoLattStr);
    let x, y be Element of L;
     x "/\" y = (x | y) | (x | y) by Def12
            .= (y | x) | (x | y) by Th32
            .= (y | x) | (y | x) by Th32
            .= y "/\" x by Def12;
    hence thesis;
  end;

theorem Th36:
  for L being satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
     properly_defined (non empty ShefferOrthoLattStr) holds
    L is distributive
  proof
    let L be satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
        properly_defined (non empty ShefferOrthoLattStr);
    let x, y, z be Element of L;
    set Y = y";
    set Z = z";
     x "/\" (y "\/" z) = x "/\" ((y | y) | (z | z)) by Def12
          .= (x | (Y | Z))" by Def12
          .= (Y" | x) | (Z" | x) by Def15
          .= (y | x) | (Z" | x) by Def13
          .= (y | x) | (z | x) by Def13
          .= (x | y) | (z | x) by Th32
          .= (x | y) | (x | z) by Th32
          .= ((x | y)")" | (x | z) by Def13
          .= ((x | y) | (x | y))" | ((x | z)")" by Def13
          .= ((x "/\" y) | ((x | y) | (x | y))) |
            (((x | z) | (x | z)) | ((x | z) | (x | z))) by Def12
          .= ((x "/\" y) | (x "/\" y)) | (((x | z) | (x | z)) |
            ((x | z) | (x | z))) by Def12
          .= ((x "/\" y) | (x "/\" y)) | ((x "/\" z) | ((x | z) | (x | z)))
            by Def12
          .= ((x "/\" y) | (x "/\" y)) | ((x "/\" z) | (x "/\" z)) by Def12
          .= (x "/\" y) "\/" (x "/\" z) by Def12;
     hence thesis;
  end;

theorem Th37:
  for L being satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
     properly_defined (non empty ShefferOrthoLattStr) holds
    L is distributive'
  proof
    let L be satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
        properly_defined (non empty ShefferOrthoLattStr);
    let x, y, z be Element of L;
    set X = (x | x);
     x "\/" (y "/\" z) = x "\/" ((y | z) | (y | z)) by Def12
        .= X | ((y | z)")" by Def12
        .= X | (y | z) by Def13
        .= ((X |(y | z))")" by Def13
        .= ((y" | X) | (z" | X))" by Def15
        .= ((X | y") | (z" | X))" by Th32
        .= ((X | (y | y)) | (X | z"))" by Th32
        .= (((x "\/" y) | (X | (z | z))) | ((X | (y | y)) |
           (X | (z | z)))) by Def12
        .= (((x "\/" y) | (x "\/" z)) | ((X | (y | y)) | (X | (z | z))))
           by Def12
        .= (((x "\/" y) | (x "\/" z)) | ((x "\/" y)  | (X | (z | z))))
           by Def12
        .= (((x "\/" y) | (x "\/" z)) | ((x "\/" y) | (x "\/" z))) by Def12
        .= (x "\/" y) "/\" (x "\/" z) by Def12;
    hence thesis;
  end;

theorem
   for L being satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
    properly_defined (non empty ShefferOrthoLattStr) holds
      L is Boolean Lattice
  proof
    let L be satisfying_Sheffer_1 satisfying_Sheffer_2
    satisfying_Sheffer_3 properly_defined (non empty ShefferOrthoLattStr);
     ex c being Element of L st
    for a being Element of L holds c "\/" a = a & a "\/" c = a
    proof
      consider b being Element of L;
      take c = (b | (b | b)) | (b | (b | b));
      let a be Element of L;
      thus c "\/" a = a
      proof
         c "\/" a = ((b | (b | b))")" | (a | a) by Def12
          .= ((a | (a | a))")" | (a | a) by Th33
          .= (a | (a | a)) | (a | a) by Def13
          .= (a | a) | (a | (a | a)) by Th32
          .= (a | a) | (a | a) by Def14
          .= a by Def13;
        hence thesis;
      end;
      thus a "\/" c = a
      proof
         a "\/" c = (a | a) | ((b | (b | b))")" by Def12
          .= (a | a) | ((a | (a | a))")" by Th33
          .= (a | a) | (a | (a | a)) by Def13
          .= (a | a) | (a | a) by Def14
          .= a by Def13;
        hence thesis;
      end;
    end;
then A1: L is lower-bounded' by Def3;
     ex c being Element of L st
    for a being Element of L holds c "/\" a = a & a "/\" c = a
    proof
      consider b being Element of L;
      take c = (b|b) | ((b|b)|(b|b));
      let a be Element of L;
      thus c "/\" a = a
      proof
        set X = b";
         c "/\" a = (((b | b) | (X | X)) | a)" by Def12
          .= (a | (X | (X | X)))" by Th32
          .= (a | a)" by Def14
          .= a by Def13;
        hence thesis;
      end;
      thus a "/\" c = a
      proof
        set X = b";
         a "/\" c = (a | ((b | b) | (X | X)))" by Def12
          .= (a | a)" by Def14
          .= a by Def13;
        hence thesis;
      end;
    end;
then A2: L is upper-bounded' by Def1;
     for b being Element of L
    ex a being Element of L st a is_a_complement'_of b
    proof
      let b be Element of L;
A3:   Top' L = (b | b) | ((b | b)|(b | b))
      proof
        set X = (b | b) | ((b | b)|(b | b));
         for a being Element of L holds
        X "/\" a = a & a "/\" X = a
        proof
          let a be Element of L;
          thus X "/\" a = a
          proof
            set Y = b";
             X "/\" a = (((b | b) | (Y | Y)) | a)" by Def12
              .= (a | (Y | (Y | Y)))" by Th32
              .= (a | a)" by Def14
              .= a by Def13;
            hence thesis;
          end;
          thus a "/\" X = a
          proof
            set Y = b";
             a "/\" X = (a | ((b | b) | (Y | Y)))" by Def12
              .= (a | a)" by Def14
              .= a by Def13;
            hence thesis;
          end;
          thus thesis;
        end;
        hence thesis by A2,Def2;
      end;
A4:   Bot' L = (b | (b | b)) | (b | (b | b))
      proof
        set X = (b | (b | b)) | (b | (b | b));
         for a being Element of L holds
        X "\/" a = a & a "\/" X = a
        proof
          let a be Element of L;
          thus X "\/" a = a
          proof
             X "\/" a = ((b | (b | b))")" | (a | a) by Def12
              .= ((a | (a | a))")" | (a | a) by Th33
              .= (a | (a | a)) | (a | a) by Def13
              .= (a | a) | (a | (a | a)) by Th32
              .= (a | a) | (a | a) by Def14
              .= a by Def13;
            hence thesis;
          end;
          thus a "\/" X = a
          proof
             a "\/" X = (a | a) | ((b | (b | b))")" by Def12
              .= (a | a) | ((a | (a | a))")" by Th33
              .= (a | a) | (a | (a | a)) by Def13
              .= (a | a) | (a | a) by Def14
              .= a by Def13;
            hence thesis;
          end;
          thus thesis;
        end;
        hence thesis by A1,Def4;
      end;
      set a = b | b;
      take a;
A5:   a "\/" b = ((b | b) | (b | b)) | (b | b) by Def12
        .= Top' L by A3,Th32;
A6:   b "\/" a = Top' L by A3,Def12;
A7:   a "/\" b = ((b | b) | b) | ((b | b) | b) by Def12
        .= (b | (b | b)) | ((b | b) | b) by Th32
        .= Bot' L by A4,Th32;
       b "/\" a = Bot' L by A4,Def12;
      hence thesis by A5,A6,A7,Def6;
    end;
then A8: L is complemented' by Def7;
A9: L is join-commutative by Th34;
A10: L is meet-commutative by Th35;
A11: L is distributive by Th36;
     L is distributive' by Th37;
    hence thesis by A1,A2,A8,A9,A10,A11,Th26;
  end;

