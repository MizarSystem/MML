:: Axiomatization of {B}oolean Algebras Based on Sheffer Stroke
::  by Violetta Kozarkiewicz and Adam Grabowski
::
:: Received May 31, 2004
:: Copyright (c) 2004 Association of Mizar Users
 
environ

 vocabularies LATTICES, ROBBINS1, XBOOLE_0, SUBSET_1, ARYTM_3, EQREL_1,
      ZFMISC_1, PBOOLE, STRUCT_0, BINOP_1, FUNCT_5, RELAT_1, FUNCT_1, SHEFFER1;
 notations TARSKI, XBOOLE_0, FUNCT_5, STRUCT_0, LATTICES, BINOP_1, ROBBINS1;
 constructors BINOP_1, ROBBINS1, FUNCT_5;
 registrations LATTICES, LATTICE6, ROBBINS1, XBOOLE_0, ZFMISC_1;
 definitions LATTICES, ROBBINS1;
 theorems STRUCT_0, ROBBINS1, LATTICES, CARD_1;

begin :: Preliminaries

theorem Th1:
  for L being join-commutative join-associative Huntington (non
  empty ComplLLattStr), a, b being Element of L holds (a + b)` = a` *' b`
proof
  let L be join-commutative join-associative Huntington (non empty
  ComplLLattStr);
  let a, b be Element of L;
  a + b = (a` *' b`)` by ROBBINS1:18;
  hence thesis by ROBBINS1:3;
end;

begin :: Huntington's First Axiomatization of Boolean Algebras

definition
  let IT be non empty LattStr;
  attr IT is upper-bounded' means
  :Def1:
  ex c being Element of IT st for a
  being Element of IT holds c "/\" a = a & a "/\" c = a;
end;

definition
  let L be non empty LattStr;
  assume
A1: L is upper-bounded';
  func Top' L -> Element of L means
  :Def2:
  for a being Element of L holds it "/\" a = a & a "/\" it = a;
  existence by A1,Def1;
  uniqueness
  proof
    let c1,c2 be Element of L such that
A2: for a being Element of L holds c1"/\"a = a & a"/\"c1 = a and
A3: for a being Element of L holds c2"/\"a = a & a"/\"c2 = a;
    thus c1 = c2"/\"c1 by A3
      .= c2 by A2;
  end;
end;

definition
  let IT be non empty LattStr;
  attr IT is lower-bounded' means
  :Def3:
  ex c being Element of IT st for a
  being Element of IT holds c "\/" a = a & a "\/" c = a;
end;

definition
  let L be non empty LattStr;
  assume
A1: L is lower-bounded';
  func Bot' L -> Element of L means
  :Def4:
  for a being Element of L holds it "\/" a = a & a "\/" it = a;
  existence by A1,Def3;
  uniqueness
  proof
    let c1,c2 be Element of L such that
A2: for a being Element of L holds c1"\/"a = a & a"\/"c1 = a and
A3: for a being Element of L holds c2"\/"a = a & a"\/"c2 = a;
    thus c1 = c2"\/"c1 by A3
      .= c2 by A2;
  end;
end;

definition
  let IT be non empty LattStr;
  attr IT is distributive' means
  :Def5:
  for a, b, c being Element of IT holds
  a "\/" (b "/\" c) = (a "\/" b) "/\" (a "\/" c);
end;

definition
  let L be non empty LattStr, a, b be Element of L;
  pred a is_a_complement'_of b means
  :Def6:
  b "\/" a = Top' L & a "\/" b =
  Top' L & b "/\" a = Bot' L & a "/\" b = Bot' L;
end;

definition
  let IT be non empty LattStr;
  attr IT is complemented' means
  :Def7:
  for b being Element of IT ex a being
  Element of IT st a is_a_complement'_of b;
end;

definition
  let L be non empty LattStr, x be Element of L;
  assume
A1: L is complemented' distributive upper-bounded' meet-commutative;
  func x `# -> Element of L means
  :Def8:
  it is_a_complement'_of x;
  existence by A1,Def7;
  uniqueness
  proof
    let a,b be Element of L such that
A2: a is_a_complement'_of x and
A3: b is_a_complement'_of x;
    b = b "/\" Top' L by A1,Def2
      .= b "/\" (x "\/" a) by A2,Def6
      .= (b "/\" x) "\/" (b "/\" a) by A1,LATTICES:def 11
      .= (x "/\" b) "\/" (b "/\" a) by A1,LATTICES:def 6
      .= (x "/\" b) "\/" (a "/\" b) by A1,LATTICES:def 6
      .= (Bot' L) "\/" (a "/\" b) by A3,Def6
      .= (a "/\" x) "\/" (a "/\" b) by A2,Def6
      .= a "/\" (x "\/" b) by A1,LATTICES:def 11
      .= a "/\" Top' L by A3,Def6
      .= a by A1,Def2;
    hence thesis;
  end;
end;

registration
  cluster Boolean join-idempotent upper-bounded' complemented' distributive'
    lower-bounded' Lattice-like (non empty LattStr);
  existence
  proof
    consider L being trivial non empty Lattice;
A1: L is lower-bounded
    proof
      consider x being Element of L;
      for y be Element of L holds x "/\" y = x & y "/\" x = x by STRUCT_0:
      def 10;
      hence thesis by LATTICES:def 13;
    end;
A2: L is upper-bounded
    proof
      consider x being Element of L;
      for y be Element of L holds x "\/" y = x & y "\/" x = x by STRUCT_0:
      def 10;
      hence thesis by LATTICES:def 14;
    end;
    for b being Element of L ex a being Element of L st a is_a_complement_of b
    proof
      let b be Element of L;
      take a = b;
      b "\/" a = Top L & b "/\" a = Bottom L by STRUCT_0:def 10;
      hence thesis by LATTICES:def 18;
    end;
    then
A3: L is complemented by LATTICES:def 19;
A4: L is join-idempotent
    proof
      let x be Element of L;
      thus thesis by STRUCT_0:def 10;
    end;
    for b being Element of L ex a being Element of L st a is_a_complement'_of b
    proof
      let b be Element of L;
      take a = b;
      b "\/" a = Top' L & b "/\" a = Bot' L by STRUCT_0:def 10;
      hence thesis by Def6;
    end;
    then
A5: L is complemented' by Def7;
    for a, b, c being Element of L holds a "/\" (b "\/" c) = (a "/\" b)
    "\/" (a "/\" c) by STRUCT_0:def 10;
    then
A6: L is distributive by LATTICES:def 11;
A7: L is lower-bounded'
    proof
      consider x being Element of L;
      for y be Element of L holds x "\/" y = y & y "\/" x = y by STRUCT_0
      :def 10;
      hence thesis by Def3;
    end;
A8: L is upper-bounded'
    proof
      consider x being Element of L;
      for y be Element of L holds x "/\" y = y & y "/\" x = y by STRUCT_0
      :def 10;
      hence thesis by Def1;
    end;
    for a, b, c being Element of L holds a "\/" (b "/\" c) = (a "\/" b)
    "/\" (a "\/" c) by STRUCT_0:def 10;
    then L is distributive' by Def5;
    hence thesis by A3,A6,A1,A2,A4,A8,A5,A7;
  end;
end;

canceled;

theorem Th3:
  for L being complemented' join-commutative meet-commutative
distributive upper-bounded' distributive' (non empty LattStr) for x be Element
  of L holds x "\/" x `# = Top' L
proof
  let L be complemented' join-commutative meet-commutative distributive
  upper-bounded' distributive' (non empty LattStr);
  let x be Element of L;
  x `# is_a_complement'_of x by Def8;
  hence thesis by Def6;
end;

theorem Th4:
  for L being complemented' join-commutative meet-commutative
  distributive upper-bounded' distributive' (non empty LattStr) for x being
  Element of L holds x "/\" x `# = Bot' L
proof
  let L be complemented' join-commutative meet-commutative distributive
  upper-bounded' distributive' (non empty LattStr);
  let x be Element of L;
  x `# is_a_complement'_of x by Def8;
  hence thesis by Def6;
end;

theorem Th5:
  for L being complemented' join-commutative meet-commutative
  join-idempotent distributive upper-bounded' distributive' (non empty LattStr)
  for x being Element of L holds x "\/" Top' L = Top' L
proof
  let L be complemented' join-commutative meet-commutative join-idempotent
  distributive upper-bounded' distributive' (non empty LattStr);
  let x be Element of L;
  x "\/" Top' L = (x "\/" Top' L) "/\" Top' L by Def2
    .= (x "\/" Top' L) "/\" (x "\/" (x `# )) by Th3
    .= x "\/" (Top' L "/\" x`# ) by Def5
    .= x "\/" x `# by Def2
    .= Top' L by Th3;
  hence thesis;
end;

theorem Th6:
  for L being complemented' join-commutative meet-commutative
  join-idempotent distributive upper-bounded' lower-bounded' distributive' (non
  empty LattStr) for x being Element of L holds x "/\" Bot' L = Bot' L
proof
  let L be complemented' join-commutative meet-commutative join-idempotent
  distributive upper-bounded' lower-bounded' distributive' (non empty LattStr);
  let x be Element of L;
  x "/\" Bot' L = (x "/\" Bot' L) "\/" Bot' L by Def4
    .= (x "/\" Bot' L) "\/" (x "/\" x`# ) by Th4
    .= x "/\" (Bot' L "\/" x`# ) by LATTICES:def 11
    .= x "/\" x`# by Def4
    .= Bot' L by Th4;
  hence thesis;
end;

theorem Th7:
  for L being join-commutative meet-absorbing meet-commutative
  join-absorbing join-idempotent distributive (non empty LattStr) for x, y, z
  being Element of L holds ((x "\/" y) "\/" z) "/\" x = x
proof
  let L be join-commutative meet-absorbing meet-commutative join-absorbing
  join-idempotent distributive (non empty LattStr);
  let x, y, z be Element of L;
  ((x "\/" y) "\/" z) "/\" x = (x "/\" (x "\/" y)) "\/" (x "/\" z) by
  LATTICES:def 11
    .= (x "/\" x) "\/" (x "/\" y) "\/" (x "/\" z) by LATTICES:def 11
    .= x "\/" (x "/\" y) "\/" (x "/\" z) by LATTICES:18
    .= x "\/" (x "/\" z) by LATTICES:def 8
    .= x by LATTICES:def 8;
  hence thesis;
end;

theorem Th8:
  for L being join-commutative meet-absorbing meet-commutative
  join-absorbing join-idempotent distributive' (non empty LattStr) for x, y, z
  being Element of L holds ((x "/\" y) "/\" z) "\/" x = x
proof
  let L be join-commutative meet-absorbing meet-commutative join-absorbing
  join-idempotent distributive' (non empty LattStr);
  let x, y, z be Element of L;
  ((x "/\" y) "/\" z) "\/" x = (x "\/" (x "/\" y)) "/\" (x "\/" z) by Def5
    .= (x "\/" x) "/\" (x "\/" y) "/\" (x "\/" z) by Def5
    .= x "/\" (x "\/" y) "/\" (x "\/" z) by LATTICES:17
    .= x "/\" (x "\/" z) by LATTICES:def 9
    .= x by LATTICES:def 9;
  hence thesis;
end;

definition
  let G be non empty /\-SemiLattStr;
  attr G is meet-idempotent means
  :Def9:
  for x being Element of G holds x "/\" x = x;
end;

theorem Th9:
  for L being complemented' join-commutative meet-commutative
  distributive upper-bounded' lower-bounded' distributive' (non empty LattStr)
  holds L is meet-idempotent
proof
  let L be complemented' join-commutative meet-commutative distributive
  upper-bounded' lower-bounded' distributive' (non empty LattStr);
  now
    let x be Element of L;
    thus x "/\" x = (x "/\" x) "\/" Bot' L by Def4
      .= (x "/\" x) "\/" (x "/\" x`# ) by Th4
      .= x "/\" (x "\/" x`# ) by LATTICES:def 11
      .= x "/\" Top' L by Th3
      .= x by Def2;
  end;
  hence thesis by Def9;
end;

theorem Th10:
  for L being complemented' join-commutative meet-commutative
  distributive upper-bounded' lower-bounded' distributive' (non empty LattStr)
  holds L is join-idempotent
proof
  let L be complemented' join-commutative meet-commutative distributive
  upper-bounded' lower-bounded' distributive' (non empty LattStr);
  let x be Element of L;
  thus x "\/" x = (x "\/" x) "/\" Top' L by Def2
    .= (x "\/" x) "/\" (x "\/" x`# ) by Th3
    .= x "\/" (x "/\" x`# ) by Def5
    .= x "\/" Bot' L by Th4
    .= x by Def4;
end;

theorem Th11:
  for L being complemented' join-commutative meet-commutative
  join-idempotent distributive upper-bounded' distributive' (non empty LattStr)
  holds L is meet-absorbing
proof
  let L be complemented' join-commutative meet-commutative join-idempotent
  distributive upper-bounded' distributive' (non empty LattStr);
  let y, x be Element of L;
  x "\/" (x "/\" y) = (Top' L "/\" x) "\/" (x "/\" y) by Def2
    .= x "/\" (Top' L "\/" y) by LATTICES:def 11
    .= x "/\" Top' L by Th5
    .= x by Def2;
  hence thesis;
end;

theorem Th12:
  for L being complemented' join-commutative upper-bounded'
meet-commutative join-idempotent distributive distributive' lower-bounded' (non
  empty LattStr) holds L is join-absorbing
proof
  let L be complemented' join-commutative upper-bounded' meet-commutative
join-idempotent distributive distributive' lower-bounded' (non empty LattStr);
  let x, y be Element of L;
A1: L is meet-idempotent by Th9;
A2: L is meet-absorbing by Th11;
  x "/\" (x "\/" y) = (x "/\" x) "\/" (x "/\" y) by LATTICES:def 11
    .= x "\/" (x "/\" y) by A1,Def9
    .= x by A2,LATTICES:def 8;
  hence thesis;
end;

theorem Th13:
  for L being complemented' join-commutative meet-commutative
  upper-bounded' lower-bounded' join-idempotent distributive distributive' (non
  empty LattStr) holds L is upper-bounded
proof
  let L be complemented' join-commutative meet-commutative upper-bounded'
lower-bounded' join-idempotent distributive distributive' (non empty LattStr);
  ex c being Element of L st for a being Element of L holds c"\/"a = c & a
  "\/"c = c
  proof
    take Top' L;
    let a be Element of L;
    thus thesis by Th5;
  end;
  hence thesis by LATTICES:def 14;
end;

theorem Th14:
  for L being Boolean Lattice-like (non empty LattStr) holds L is
  upper-bounded'
proof
  let L be Boolean Lattice-like (non empty LattStr);
  ex c being Element of L st for a being Element of L holds c "/\" a = a &
  a "/\" c = a
  proof
    take c = Top L;
    let a be Element of L;
    a [= c by LATTICES:45;
    hence thesis by LATTICES:21;
  end;
  hence thesis by Def1;
end;

theorem Th15:
  for L being complemented' join-commutative meet-commutative
  upper-bounded' lower-bounded' join-idempotent distributive distributive' (non
  empty LattStr) holds L is lower-bounded
proof
  let L be complemented' join-commutative meet-commutative upper-bounded'
lower-bounded' join-idempotent distributive distributive' (non empty LattStr);
  ex c being Element of L st for a being Element of L holds c"/\"a = c & a
  "/\"c = c
  proof
    take Bot' L;
    let a be Element of L;
    thus thesis by Th6;
  end;
  hence thesis by LATTICES:def 13;
end;

theorem Th16:
  for L being Boolean Lattice-like (non empty LattStr) holds L is
  lower-bounded'
proof
  let L be Boolean Lattice-like (non empty LattStr);
  ex c being Element of L st for a being Element of L holds c "\/" a = a &
  a "\/" c = a
  proof
    take c = Bottom L;
    let a be Element of L;
    c [= a by LATTICES:41;
    hence thesis by LATTICES:def 3;
  end;
  hence thesis by Def3;
end;

theorem Th17:
  for L being join-commutative meet-commutative meet-absorbing
  join-absorbing join-idempotent distributive (non empty LattStr) holds L is
  join-associative
proof
  let L be join-commutative meet-commutative meet-absorbing join-absorbing
  join-idempotent distributive (non empty LattStr);
  let x, y, z be Element of L;
A1: ((y "\/" z) "\/" x) "/\" y = (y "/\" (y "\/" z)) "\/" (y "/\" x) by
  LATTICES:def 11
    .= (y "/\" y) "\/" (y "/\" z) "\/" (y "/\" x) by LATTICES:def 11
    .= y "\/" (y "/\" z) "\/" (y "/\" x) by LATTICES:18
    .= y "\/" (y "/\" x) by LATTICES:def 8
    .= y by LATTICES:def 8;
A2: ((x "\/" y) "\/" z) "/\" x = x by Th7;
  x "\/" (y "\/" z) = (x "\/" y) "\/" z
  proof
    set A = ((x "\/" y) "\/" z) "/\" (x "\/" (y "\/" z));
A3: A = ((x "\/" y) "/\" (x "\/" (y "\/" z))) "\/" (z "/\" (x "\/" (y "\/"
    z))) by LATTICES:def 11
      .= ((x "\/" y) "/\" (x "\/" (y "\/" z))) "\/" z by Th7
      .= ((x "/\" (x "\/" (y "\/" z))) "\/" (y "/\" (x "\/" (y "\/" z))))
    "\/" z by LATTICES:def 11
      .= (x "\/" y) "\/" z by A1,LATTICES:def 9;
    A = (((x "\/" y) "\/" z) "/\" x) "\/" (((x "\/" y) "\/" z) "/\" (y
    "\/" z)) by LATTICES:def 11
      .= x "\/" ((((x "\/" y) "\/" z) "/\" y) "\/" (((x "\/" y) "\/" z) "/\"
    z)) by A2,LATTICES:def 11
      .= x "\/" (y "\/" (((x "\/" y) "\/" z) "/\" z)) by Th7
      .= x "\/" (y "\/" (((x "\/" y ) "/\" z) "\/" (z "/\" z))) by LATTICES:
    def 11
      .= x "\/" (y "\/" (((x "\/" y ) "/\" z) "\/" z)) by LATTICES:18
      .= x "\/" (y "\/" z) by LATTICES:def 8;
    hence thesis by A3;
  end;
  hence thesis;
end;

theorem Th18:
  for L being join-commutative meet-commutative meet-absorbing
  join-absorbing join-idempotent distributive' (non empty LattStr) holds L is
  meet-associative
proof
  let L be join-commutative meet-commutative meet-absorbing join-absorbing
  join-idempotent distributive' (non empty LattStr);
  let x, y, z be Element of L;
A1: ((x "/\" y) "/\" z) "\/" x = x by Th8;
A2: ((y "/\" z) "/\" x) "\/" y = (y "\/" (y "/\" z)) "/\" (y "\/" x) by Def5
    .= (y "\/" y) "/\" (y "\/" z) "/\" (y "\/" x) by Def5
    .= y "/\" (y "\/" z) "/\" (y "\/" x) by LATTICES:17
    .= y "/\" (y "\/" x) by LATTICES:def 9
    .= y by LATTICES:def 9;
  x "/\" (y "/\" z) = (x "/\" y) "/\" z
  proof
    set A = ((x "/\" y) "/\" z) "\/" (x "/\" (y "/\" z));
A3: A = ((x "/\" y) "\/" (x "/\" (y "/\" z))) "/\" (z "\/" (x "/\" (y "/\"
    z))) by Def5
      .= ((x "/\" y) "\/" (x "/\" (y "/\" z))) "/\" z by Th8
      .= ((x "\/" (x "/\" (y "/\" z))) "/\" (y "\/" (x "/\" (y "/\" z))))
    "/\" z by Def5
      .= (x "/\" y) "/\" z by A2,LATTICES:def 8;
    A = (((x "/\" y) "/\" z) "\/" x) "/\" (((x "/\" y) "/\" z) "\/" (y
    "/\" z)) by Def5
      .= x "/\" ((((x "/\" y) "/\" z) "\/" y) "/\" (((x "/\" y) "/\" z) "\/"
    z)) by A1,Def5
      .= x "/\" (y "/\" (((x "/\" y) "/\" z) "\/" z)) by Th8
      .= x "/\" (y "/\" (((x "/\" y ) "\/" z) "/\" (z "\/" z))) by Def5
      .= x "/\" (y "/\" (((x "/\" y ) "\/" z) "/\" z)) by LATTICES:17
      .= x "/\" (y "/\" z) by LATTICES:def 9;
    hence thesis by A3;
  end;
  hence thesis;
end;

theorem Th19:
  for L being complemented' join-commutative meet-commutative
  lower-bounded' upper-bounded' join-idempotent distributive distributive' (non
  empty LattStr) holds Top L = Top' L
proof
  let L be complemented' join-commutative meet-commutative lower-bounded'
upper-bounded' join-idempotent distributive distributive' (non empty LattStr);
  set Y = Top' L;
  L is upper-bounded & for a being Element of L holds Y "\/" a = Y & a
  "\/" Y = Y by Th5,Th13;
  hence thesis by LATTICES:def 17;
end;

theorem Th20:
  for L being complemented' join-commutative meet-commutative
  lower-bounded' upper-bounded' join-idempotent distributive distributive' (non
  empty LattStr) holds Bottom L = Bot' L
proof
  let L be complemented' join-commutative meet-commutative lower-bounded'
upper-bounded' join-idempotent distributive distributive' (non empty LattStr);
  set Y = Bot' L;
  L is lower-bounded & for a being Element of L holds Y "/\" a = Y & a
  "/\" Y = Y by Th6,Th15;
  hence thesis by LATTICES:def 16;
end;

theorem Th21:
  for L being Boolean distributive' Lattice-like (non empty
  LattStr) holds Top L = Top' L
proof
  let L be Boolean distributive' Lattice-like (non empty LattStr);
  set Y = Top L;
  L is upper-bounded' & for a being Element of L holds Y "/\" a = a & a
  "/\" Y = a by Th14,LATTICES:43;
  hence thesis by Def2;
end;

theorem Th22:
  for L being Boolean complemented lower-bounded upper-bounded
  distributive distributive' Lattice-like (non empty LattStr) holds Bottom L =
  Bot' L
proof
  let L be Boolean complemented lower-bounded upper-bounded distributive
  distributive' Lattice-like (non empty LattStr);
  set Y = Bottom L;
  L is lower-bounded' & for a being Element of L holds Y "\/" a = a & a
  "\/" Y = a by Th16,LATTICES:39;
  hence thesis by Def4;
end;

theorem
  for L being complemented' lower-bounded' upper-bounded'
join-commutative meet-commutative join-idempotent distributive distributive' (
non empty LattStr), x, y being Element of L holds x is_a_complement'_of y iff x
  is_a_complement_of y
proof
  let L be complemented' lower-bounded' upper-bounded' join-commutative
meet-commutative join-idempotent distributive distributive' (non empty LattStr)
  , x, y be Element of L;
  hereby
    assume
A1: x is_a_complement'_of y;
    then x "/\" y = Bot' L by Def6;
    then
A2: x "/\" y = Bottom L by Th20;
    x "\/" y = Top' L by A1,Def6;
    then x "\/" y = Top L by Th19;
    hence x is_a_complement_of y by A2,LATTICES:def 18;
  end;
  assume
A3: x is_a_complement_of y;
  then x "/\" y = Bottom L by LATTICES:def 18;
  then
A4: x "/\" y = Bot' L by Th20;
  x "\/" y = Top L by A3,LATTICES:def 18;
  then x "\/" y = Top' L by Th19;
  hence thesis by A4,Def6;
end;

theorem Th24:
  for L being complemented' join-commutative meet-commutative
  lower-bounded' upper-bounded' join-idempotent distributive distributive' (non
  empty LattStr) holds L is complemented
proof
  let L be complemented' join-commutative meet-commutative lower-bounded'
upper-bounded' join-idempotent distributive distributive' (non empty LattStr);
  for b being Element of L ex a being Element of L st a is_a_complement_of b
  proof
    let b be Element of L;
    consider a being Element of L such that
A1: a is_a_complement'_of b by Def7;
    b "/\" a = Bot' L by A1,Def6;
    then
A2: b "/\" a = Bottom L by Th20;
    b "\/" a = Top' L by A1,Def6;
    then b "\/" a = Top L by Th19;
    then a is_a_complement_of b by A2,LATTICES:def 18;
    hence thesis;
  end;
  hence thesis by LATTICES:def 19;
end;

theorem Th25:
  for L being Boolean lower-bounded' upper-bounded' distributive'
  Lattice-like (non empty LattStr) holds L is complemented'
proof
  let L be Boolean lower-bounded' upper-bounded' distributive' Lattice-like (
  non empty LattStr);
  for b being Element of L ex a being Element of L st a is_a_complement'_of b
  proof
    let b be Element of L;
    consider a being Element of L such that
A1: a is_a_complement_of b by LATTICES:def 19;
    b "/\" a = Bottom L by A1,LATTICES:def 18;
    then
A2: b "/\" a = Bot' L by Th22;
    b "\/" a = Top L by A1,LATTICES:def 18;
    then b "\/" a = Top' L by Th21;
    then a is_a_complement'_of b by A2,Def6;
    hence thesis;
  end;
  hence thesis by Def7;
end;

theorem Th26:
  for L being non empty LattStr holds L is Boolean Lattice iff L
is lower-bounded' upper-bounded' join-commutative meet-commutative distributive
  distributive' complemented'
proof
  let L be non empty LattStr;
  thus L is Boolean Lattice implies L is lower-bounded' upper-bounded'
  join-commutative meet-commutative distributive distributive' complemented'
  proof
    assume
A1: L is Boolean Lattice;
    then reconsider L9 = L as Boolean Lattice;
    ex c being Element of L9 st for a being Element of L9 holds c "\/" a =
    a & a "\/" c = a
    proof
      take Bottom L9;
      thus thesis by LATTICES:39;
    end;
    hence
A2: L is lower-bounded' by Def3;
    ex c being Element of L9 st for a being Element of L9 holds c "/\" a =
    a & a "/\" c = a
    proof
      take Top L9;
      thus thesis by LATTICES:43;
    end;
    hence
A3: L is upper-bounded' by Def1;
    thus L is join-commutative meet-commutative by A1;
    for a,b,c being Element of L9 holds a "/\" (b "\/" c) = (a "/\" b)
    "\/" (a "/\" c) by LATTICES:def 11;
    then for a, b, c being Element of L9 holds a "\/" (b "/\" c) = (a "\/" b)
    "/\" (a "\/" c) by LATTICES:19;
    hence L is distributive distributive' by Def5;
    hence thesis by A1,A2,A3,Th25;
  end;
  thus L is lower-bounded' upper-bounded' join-commutative meet-commutative
  distributive distributive' complemented' implies L is Boolean Lattice
  proof
    assume L is lower-bounded' upper-bounded' join-commutative
    meet-commutative distributive distributive' complemented';
    then reconsider L9 = L as lower-bounded' upper-bounded' complemented'
join-commutative meet-commutative join-idempotent distributive distributive' (
    non empty LattStr) by Th10;
A4: L9 is complemented by Th24;
A5: L9 is lower-bounded & L9 is upper-bounded by Th13,Th15;
A6: L9 is meet-absorbing join-absorbing by Th11,Th12;
    then L9 is join-associative & L9 is meet-associative by Th17,Th18;
    hence thesis by A5,A4,A6;
  end;
end;

registration
  cluster Boolean Lattice-like -> lower-bounded' upper-bounded' complemented'
join-commutative meet-commutative distributive distributive' (non empty LattStr
    );
  coherence by Th26;
  cluster lower-bounded' upper-bounded' complemented' join-commutative
meet-commutative distributive distributive' -> Boolean Lattice-like (non empty
    LattStr);
  coherence by Th26;
end;

begin :: Axiomatization Based on Sheffer Stroke

definition
  struct (1-sorted) ShefferStr (# carrier -> set, stroke -> BinOp of the
    carrier #);
end;

definition
  struct (ShefferStr,LattStr) ShefferLattStr (# carrier -> set, L_join ->
BinOp of the carrier, L_meet -> BinOp of the carrier, stroke -> BinOp of the
    carrier #);
end;

definition
  struct (ShefferStr,OrthoLattStr) ShefferOrthoLattStr (# carrier -> set,
L_join -> BinOp of the carrier, L_meet -> BinOp of the carrier, Compl -> UnOp
    of the carrier, stroke -> BinOp of the carrier #);
end;

definition
  func TrivShefferOrthoLattStr -> ShefferOrthoLattStr equals
  ShefferOrthoLattStr (# 1, op2, op2, op1, op2 #);
  coherence;
end;

registration
  cluster non empty ShefferStr;
  existence
  proof
    set S = {{}};
    consider B being BinOp of S;
    take ShefferStr (#S, B#);
    thus thesis by STRUCT_0:def 1;
  end;
  cluster non empty ShefferLattStr;
  existence
  proof
    set S = {{}};
    consider B, C, D being BinOp of S;
    take ShefferLattStr (#S, B, C, D#);
    thus thesis by STRUCT_0:def 1;
  end;
  cluster non empty ShefferOrthoLattStr;
  existence
  proof
    set S = {{}};
    consider B, C, D being BinOp of S;
    consider A being UnOp of S;
    take ShefferOrthoLattStr (#S, B, C, A, D#);
    thus thesis by STRUCT_0:def 1;
  end;
end;

definition
  let L be non empty ShefferStr;
  let x, y be Element of L;
  func x | y -> Element of L equals
  (the stroke of L).(x,y);
  coherence;
end;

definition
  let L be non empty ShefferOrthoLattStr;
  attr L is properly_defined means
  :Def12:
  (for x being Element of L holds x |
x = x`) & (for x, y being Element of L holds x "\/" y = (x | x) | (y | y)) & (
  for x, y being Element of L holds x "/\" y = (x | y) | (x | y)) & for x, y
  being Element of L holds x | y = x` + y`;
end;

definition
  let L be non empty ShefferStr;
  attr L is satisfying_Sheffer_1 means
  :Def13:
  for x being Element of L holds (x | x) | (x | x) = x;
  attr L is satisfying_Sheffer_2 means
  :Def14:
  for x, y being Element of L holds x | (y | (y | y)) = x | x;
  attr L is satisfying_Sheffer_3 means
  :Def15:
  for x, y, z being Element of L
  holds (x | (y | z)) | (x | (y | z)) = ((y | y) | x) | ((z | z) | x);
end;

registration
  cluster trivial -> satisfying_Sheffer_1 satisfying_Sheffer_2
    satisfying_Sheffer_3 (non empty ShefferStr);
  coherence
  proof
    let L be non empty ShefferStr;
    assume
A1: L is trivial;
    thus L is satisfying_Sheffer_1
    proof
      let x be Element of L;
      thus thesis by A1,STRUCT_0:def 10;
    end;
    thus L is satisfying_Sheffer_2
    proof
      let x,y be Element of L;
      thus thesis by A1,STRUCT_0:def 10;
    end;
    let x, y, z be Element of L;
    thus thesis by A1,STRUCT_0:def 10;
  end;
end;

registration
  cluster trivial -> join-commutative join-associative (non empty
    \/-SemiLattStr);
  coherence
  proof
    let L be non empty \/-SemiLattStr;
    assume
A1: L is trivial;
    thus L is join-commutative
    proof
      let x, y be Element of L;
      thus thesis by A1,STRUCT_0:def 10;
    end;
    let x, y, z be Element of L;
    thus thesis by A1,STRUCT_0:def 10;
  end;
  cluster trivial -> meet-commutative meet-associative (non empty
    /\-SemiLattStr);
  coherence
  proof
    let L be non empty /\-SemiLattStr;
    assume
A2: L is trivial;
    thus L is meet-commutative
    proof
      let x, y be Element of L;
      thus thesis by A2,STRUCT_0:def 10;
    end;
    let x, y, z be Element of L;
    thus thesis by A2,STRUCT_0:def 10;
  end;
end;

registration
  cluster trivial -> join-absorbing meet-absorbing Boolean (non empty LattStr);
  coherence
  proof
    let L be non empty LattStr;
    assume
A1: L is trivial;
    thus L is join-absorbing
    proof
      let x, y be Element of L;
      thus thesis by A1,STRUCT_0:def 10;
    end;
A2: L is upper-bounded
    proof
      consider c being Element of L;
      take c;
      let a be Element of L;
      thus thesis by A1,STRUCT_0:def 10;
    end;
    thus L is meet-absorbing
    proof
      let x, y be Element of L;
      thus thesis by A1,STRUCT_0:def 10;
    end;
A3: L is lower-bounded
    proof
      consider c being Element of L;
      take c;
      let a be Element of L;
      thus thesis by A1,STRUCT_0:def 10;
    end;
A4: L is complemented
    proof
      consider a being Element of L;
      let b be Element of L;
      take a;
A5:   a "/\" b = Bottom L & b "/\" a = Bottom L by A1,STRUCT_0:def 10;
      a "\/" b = Top L & b "\/" a = Top L by A1,STRUCT_0:def 10;
      hence thesis by A5,LATTICES:def 18;
    end;
    L is distributive
    proof
      let a, b, c be Element of L;
      thus thesis by A1,STRUCT_0:def 10;
    end;
    hence thesis by A3,A2,A4;
  end;
end;

registration
  cluster TrivShefferOrthoLattStr -> non empty;
  coherence by CARD_1:87,STRUCT_0:def 1;
  cluster TrivShefferOrthoLattStr -> trivial;
  coherence by CARD_1:87,STRUCT_0:def 9;
  cluster TrivShefferOrthoLattStr -> properly_defined well-complemented;
  coherence
  proof
    set L = TrivShefferOrthoLattStr;
A1: ( for x, y being Element of L holds x "/\" y = (x | y) | (x | y))& for
    x, y being Element of L holds x | y = x` + y` by STRUCT_0:def 10;
    ( for x being Element of L holds x | x = x`)& for x, y being Element
    of L holds x "\/" y = (x | x) | (y | y) by STRUCT_0:def 10;
    hence L is properly_defined by A1,Def12;
    L is well-complemented
    proof
      let a be Element of L;
      a "\/" a` = Top L & a "/\" a` = Bottom L by STRUCT_0:def 10;
      hence thesis by LATTICES:def 18;
    end;
    hence thesis;
  end;
end;

registration
  cluster properly_defined Boolean well-complemented Lattice-like
    satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3 (non empty
    ShefferOrthoLattStr);
  existence
  proof
    take TrivShefferOrthoLattStr;
    thus thesis;
  end;
end;

theorem
  for L being properly_defined Boolean well-complemented Lattice-like (
  non empty ShefferOrthoLattStr) holds L is satisfying_Sheffer_1
proof
  let L be properly_defined Boolean well-complemented Lattice-like (non empty
  ShefferOrthoLattStr);
  let x be Element of L;
  x`` = x by ROBBINS1:3;
  then (x | x)` = x by Def12;
  hence thesis by Def12;
end;

theorem
  for L being properly_defined Boolean well-complemented Lattice-like (
  non empty ShefferOrthoLattStr) holds L is satisfying_Sheffer_2
proof
  let L be properly_defined Boolean well-complemented Lattice-like (non empty
  ShefferOrthoLattStr);
  let x, y be Element of L;
  x` + Bot L = x` by ROBBINS1:14;
  then x` + (y`` *' y`) = x` by ROBBINS1:16;
  then x` + (y` + y)` = x` by Th1;
  then x | (y` + y) = x` by Def12;
  then x | (y` + y``) = x` by ROBBINS1:3;
  then x | (y | (y`)) = x` by Def12;
  then x | (y | (y | y)) = x` by Def12
    .= x | x by Def12;
  hence thesis;
end;

theorem
  for L being properly_defined Boolean well-complemented Lattice-like (
  non empty ShefferOrthoLattStr) holds L is satisfying_Sheffer_3
proof
  let L be properly_defined Boolean well-complemented Lattice-like (non empty
  ShefferOrthoLattStr);
  let x, y, z be Element of L;
  x *' (y` + z`) = (y` *' x) + (z` *' x) by ROBBINS1:31;
  then (x` + (y | z)`)` = (y` *' x) + (z` *' x) by Def12;
  then (x | (y | z))` = (y` *' x) + (z` *' x) by Def12;
  then (x | (y | z)) | (x | (y | z)) = (y` *' x) + (z` *' x) by Def12
    .= (y` *' x``) + (z` *' x) by ROBBINS1:3
    .= (y` *' x``) + (z` *' x``) by ROBBINS1:3
    .= (y + x`)` + (z` *' x``) by Th1
    .= (y + x`)` + (z + x`)` by Th1
    .= (y + x`) | (z + x`) by Def12
    .= (y`` + x`) | (z + x`) by ROBBINS1:3
    .= (y`` + x`) | (z`` + x`) by ROBBINS1:3
    .= (y` | x) | (z`` + x`) by Def12
    .= (y` | x) | (z` | x) by Def12
    .= ((y | y) | x) | (z` | x) by Def12
    .= ((y | y) | x) | ((z | z) | x) by Def12;
  hence thesis;
end;

definition
  let L be non empty ShefferStr;
  let a be Element of L;
  func a" -> Element of L equals
  a | a;
  coherence;
end;

theorem
  for L being satisfying_Sheffer_3 (non empty ShefferOrthoLattStr), x, y
  , z being Element of L holds (x | (y | z))" = (y" | x) | (z" | x) by Def15;

theorem
  for L being satisfying_Sheffer_1 (non empty ShefferOrthoLattStr), x
  being Element of L holds x = (x")" by Def13;

theorem Th32:
  for L being satisfying_Sheffer_1 satisfying_Sheffer_2
  satisfying_Sheffer_3 properly_defined (non empty ShefferOrthoLattStr), x, y
  being Element of L holds x | y = y | x
proof
  let L be satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
  properly_defined (non empty ShefferOrthoLattStr);
  let x, y be Element of L;
  x | y = ((x | y)")" by Def13
    .= ((x | (y")")")" by Def13
    .= (((y")" |x)")" by Def15
    .= ((y | x)")" by Def13
    .= y | x by Def13;
  hence thesis;
end;

theorem Th33:
  for L being satisfying_Sheffer_1 satisfying_Sheffer_2
  satisfying_Sheffer_3 properly_defined (non empty ShefferOrthoLattStr), x, y
  being Element of L holds x | (x | x) = y | (y | y)
proof
  let L be satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
  properly_defined (non empty ShefferOrthoLattStr);
  let x, y be Element of L;
  x | (x | x) = ((x | x") | (x | x"))" by Def13
    .= ((x | x") | (y | y"))" by Def14
    .= ((y | y") | (x | (x | x)))" by Th32
    .= ((y | y")")" by Def14
    .= y | (y | y) by Def13;
  hence thesis;
end;

theorem Th34:
  for L being satisfying_Sheffer_1 satisfying_Sheffer_2
  satisfying_Sheffer_3 properly_defined (non empty ShefferOrthoLattStr) holds L
  is join-commutative
proof
  let L be satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
  properly_defined (non empty ShefferOrthoLattStr);
  let x, y be Element of L;
  x "\/" y = x" | (y | y) by Def12
    .= (y | y) | (x | x) by Th32
    .= y "\/" x by Def12;
  hence thesis;
end;

theorem Th35:
  for L being satisfying_Sheffer_1 satisfying_Sheffer_2
  satisfying_Sheffer_3 properly_defined (non empty ShefferOrthoLattStr) holds L
  is meet-commutative
proof
  let L be satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
  properly_defined (non empty ShefferOrthoLattStr);
  let x, y be Element of L;
  x "/\" y = (x | y) | (x | y) by Def12
    .= (y | x) | (x | y) by Th32
    .= (y | x) | (y | x) by Th32
    .= y "/\" x by Def12;
  hence thesis;
end;

theorem Th36:
  for L being satisfying_Sheffer_1 satisfying_Sheffer_2
  satisfying_Sheffer_3 properly_defined (non empty ShefferOrthoLattStr) holds L
  is distributive
proof
  let L be satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
  properly_defined (non empty ShefferOrthoLattStr);
  let x, y, z be Element of L;
  set Y = y";
  set Z = z";
  x "/\" (y "\/" z) = x "/\" ((y | y) | (z | z)) by Def12
    .= (x | (Y | Z))" by Def12
    .= (Y" | x) | (Z" | x) by Def15
    .= (y | x) | (Z" | x) by Def13
    .= (y | x) | (z | x) by Def13
    .= (x | y) | (z | x) by Th32
    .= (x | y) | (x | z) by Th32
    .= ((x | y)")" | (x | z) by Def13
    .= ((x | y) | (x | y))" | ((x | z)")" by Def13
    .= ((x "/\" y) | ((x | y) | (x | y))) | (((x | z) | (x | z)) | ((x | z)
  | (x | z))) by Def12
    .= ((x "/\" y) | (x "/\" y)) | (((x | z) | (x | z)) | ((x | z) | (x | z)
  )) by Def12
    .= ((x "/\" y) | (x "/\" y)) | ((x "/\" z) | ((x | z) | (x | z))) by
  Def12
    .= ((x "/\" y) | (x "/\" y)) | ((x "/\" z) | (x "/\" z)) by Def12
    .= (x "/\" y) "\/" (x "/\" z) by Def12;
  hence thesis;
end;

theorem Th37:
  for L being satisfying_Sheffer_1 satisfying_Sheffer_2
  satisfying_Sheffer_3 properly_defined (non empty ShefferOrthoLattStr) holds L
  is distributive'
proof
  let L be satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
  properly_defined (non empty ShefferOrthoLattStr);
  let x, y, z be Element of L;
  set X = (x | x);
  x "\/" (y "/\" z) = x "\/" ((y | z) | (y | z)) by Def12
    .= X | ((y | z)")" by Def12
    .= X | (y | z) by Def13
    .= ((X |(y | z))")" by Def13
    .= ((y" | X) | (z" | X))" by Def15
    .= ((X | y") | (z" | X))" by Th32
    .= ((X | (y | y)) | (X | z"))" by Th32
    .= (((x "\/" y) | (X | (z | z))) | ((X | (y | y)) | (X | (z | z)))) by
  Def12
    .= (((x "\/" y) | (x "\/" z)) | ((X | (y | y)) | (X | (z | z)))) by
  Def12
    .= (((x "\/" y) | (x "\/" z)) | ((x "\/" y) | (X | (z | z)))) by Def12
    .= (((x "\/" y) | (x "\/" z)) | ((x "\/" y) | (x "\/" z))) by Def12
    .= (x "\/" y) "/\" (x "\/" z) by Def12;
  hence thesis;
end;

theorem
  for L being satisfying_Sheffer_1 satisfying_Sheffer_2
  satisfying_Sheffer_3 properly_defined (non empty ShefferOrthoLattStr) holds L
  is Boolean Lattice
proof
  let L be satisfying_Sheffer_1 satisfying_Sheffer_2 satisfying_Sheffer_3
  properly_defined (non empty ShefferOrthoLattStr);
A1: L is distributive & L is distributive' by Th36,Th37;
  ex c being Element of L st for a being Element of L holds c "/\" a = a &
  a "/\" c = a
  proof
    consider b being Element of L;
    take c = (b|b) | ((b|b)|(b|b));
    let a be Element of L;
    thus c "/\" a = a
    proof
      set X = b";
      c "/\" a = (((b | b) | (X | X)) | a)" by Def12
        .= (a | (X | (X | X)))" by Th32
        .= (a | a)" by Def14
        .= a by Def13;
      hence thesis;
    end;
    thus a "/\" c = a
    proof
      set X = b";
      a "/\" c = (a | ((b | b) | (X | X)))" by Def12
        .= (a | a)" by Def14
        .= a by Def13;
      hence thesis;
    end;
  end;
  then
A2: L is upper-bounded' by Def1;
  ex c being Element of L st for a being Element of L holds c "\/" a = a &
  a "\/" c = a
  proof
    consider b being Element of L;
    take c = (b | (b | b)) | (b | (b | b));
    let a be Element of L;
    c "\/" a = ((b | (b | b))")" | (a | a) by Def12
      .= ((a | (a | a))")" | (a | a) by Th33
      .= (a | (a | a)) | (a | a) by Def13
      .= (a | a) | (a | (a | a)) by Th32
      .= (a | a) | (a | a) by Def14
      .= a by Def13;
    hence c "\/" a = a;
    a "\/" c = (a | a) | ((b | (b | b))")" by Def12
      .= (a | a) | ((a | (a | a))")" by Th33
      .= (a | a) | (a | (a | a)) by Def13
      .= (a | a) | (a | a) by Def14
      .= a by Def13;
    hence a "\/" c = a;
  end;
  then
A3: L is lower-bounded' by Def3;
  for b being Element of L ex a being Element of L st a is_a_complement'_of b
  proof
    let b be Element of L;
    set a = b | b;
    take a;
A4: Top' L = (b | b) | ((b | b)|(b | b))
    proof
      set X = (b | b) | ((b | b)|(b | b));
      for a being Element of L holds X "/\" a = a & a "/\" X = a
      proof
        let a be Element of L;
        set Y = b";
        thus X "/\" a = (((b | b) | (Y | Y)) | a)" by Def12
        .= (a | (Y | (Y | Y)))" by Th32
        .= (a | a)" by Def14
        .= a by Def13;
        thus a "/\" X = (a | ((b | b) | (Y | Y)))" by Def12
        .= (a | a)" by Def14
        .= a by Def13;
      end;
      hence thesis by A2,Def2;
    end;
    then
A5: b "\/" a = Top' L by Def12;
A6: Bot' L = (b | (b | b)) | (b | (b | b))
    proof
      set X = (b | (b | b)) | (b | (b | b));
      for a being Element of L holds X "\/" a = a & a "\/" X = a
      proof
        let a be Element of L;
        thus X "\/" a = ((b | (b | b))")" | (a | a) by Def12
          .= ((a | (a | a))")" | (a | a) by Th33
          .= (a | (a | a)) | (a | a) by Def13
          .= (a | a) | (a | (a | a)) by Th32
          .= (a | a) | (a | a) by Def14
          .= a by Def13;
        thus a "\/" X = (a | a) | ((b | (b | b))")" by Def12
          .= (a | a) | ((a | (a | a))")" by Th33
          .= (a | a) | (a | (a | a)) by Def13
          .= (a | a) | (a | a) by Def14
          .= a by Def13;
      end;
      hence thesis by A3,Def4;
    end;
    then
A7: b "/\" a = Bot' L by Def12;
A8: a "\/" b = ((b | b) | (b | b)) | (b | b) by Def12
      .= Top' L by A4,Th32;
    a "/\" b = ((b | b) | b) | ((b | b) | b) by Def12
      .= (b | (b | b)) | ((b | b) | b) by Th32
      .= Bot' L by A6,Th32;
    hence thesis by A8,A5,A7,Def6;
  end;
  then
A9: L is complemented' by Def7;
  L is join-commutative & L is meet-commutative by Th34,Th35;
  hence thesis by A3,A2,A9,A1;
end;
