:: The Construction and Computation of While-loop Programs for SCMPDS
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies NUMBERS, SCMPDS_2, FSM_1, AMI_2, SUBSET_1, SCMP_GCD, AMI_3,
      FUNCT_1, CARD_1, AMI_1, ARYTM_3, CARD_3, XXREAL_0, INT_1, SCMFSA_9,
      TURING_1, ARYTM_1, SCMPDS_4, SCMFSA_7, RELAT_1, UNIALG_2, SCMFSA7B,
      SCMFSA6A, FUNCT_4, CIRCUIT2, TARSKI, SCMFSA6B, MSUALG_1, GRAPHSP,
      STRUCT_0, VALUED_1, NAT_1, XBOOLE_0, SCMPDS_8, ORDINAL1, PARTFUN1,
      SCMNORM, SCMFSA6C;
 notations TARSKI, XBOOLE_0, SUBSET_1, FUNCT_2, CARD_1, NUMBERS, RELAT_1,
      FUNCT_1, PARTFUN1, VALUED_1, XCMPLX_0, FUNCT_4, RECDEF_1, NAT_1, INT_1,
      STRUCT_0, COMPOS_1, EXTPRO_1, AMI_1, AMI_2, AMI_3, SCMPDS_2, SCMPDS_4,
      SCMPDS_6, SCMP_GCD, CARD_3, DOMAIN_1, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, RECDEF_1, SCM_1, SCMPDS_4, SCMPDS_5,
      SCMPDS_6, SCMP_GCD, PRE_POLY, AMI_1, AMI_2;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, CARD_3, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6,
      XBOOLE_0, VALUED_0, VALUED_1, AMI_1, RELAT_1, GRFUNC_1, FUNCT_2,
      COMPOS_1, AFINSQ_1, EXTPRO_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_1, AMI_3, AMI_2;
 theorems AMI_1, NAT_1, TARSKI, FUNCT_4, FUNCT_1, INT_1, SCMPDS_2, AMI_2,
      SCMPDS_3, GRFUNC_1, SCMPDS_4, SCMPDS_5, SCMPDS_6, ENUMSET1, SCMP_GCD,
      SCMPDS_7, RELAT_1, XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0,
      ZFMISC_1, PBOOLE, PARTFUN1, AFINSQ_1, COMPOS_1, FUNCT_7, EXTPRO_1;
 schemes NAT_1, SCMPDS_4, FUNCT_2;

begin :: Preliminaries

reserve x,a for Int_position,
  s for State of SCMPDS;
set A = NAT, D = SCM-Data-Loc;

theorem Th1: :: see SCMPDS_3:32
  for a be Int_position ex i being Element of NAT st a = intpos i
proof
  let a be Int_position;
  a in D by SCMPDS_2:def 2;
  then consider x,y be set such that
A1: x in {1} and
A2: y in NAT and
A3: a=[x,y] by ZFMISC_1:103;
  reconsider k = y as Element of NAT by A2;
  take k;
  thus intpos k=dl.k by SCMP_GCD:def 1
    .=a by A1,A3,TARSKI:def 1;
end;

definition
  let t be State of SCMPDS;
  func Dstate(t) -> State of SCMPDS means
  :Def1:
  for x be set holds (x in
  SCM-Data-Loc implies it.x = t.x) & ( x in NAT implies it.x = goto 0) & (x=IC
  SCMPDS implies it.x= 0);
  existence
  proof
    deffunc V(Element of NAT) = t.DataLoc($1,0);
    deffunc U(Element of NAT) = goto 0;
    consider s being State of SCMPDS such that
A1: IC s =  0 & for i being Element of NAT holds s. i = U(
    i) & s.DataLoc(i,0) = V(i) from SCMPDS_4:sch 1;
    take s;
    now
      let x be set;
      thus x in D implies s.x = t.x
      proof
        assume x in D;
        then x is Int_position by SCMPDS_2:9;
        then consider i be Element of NAT such that
A2:     x=intpos i by Th1;
        x=intpos(i+0) by A2
          .=DataLoc(i,0) by SCMP_GCD:5;
        hence thesis by A1;
      end;
      thus x in A implies s.x = goto 0 by A1;
      thus x=IC SCMPDS implies s.x= 0 by A1;
    end;
    hence thesis;
  end;
  uniqueness
  proof
    let s1,s2 be State of SCMPDS such that
A3: for x be set holds (x in D implies s1.x = t.x) & ( x in A implies
    s1.x = goto 0) & ( x=IC SCMPDS implies s1.x= 0) and
A4: for x be set holds (x in D implies s2.x = t.x) & ( x in A implies
    s2.x = goto 0) & (x=IC SCMPDS implies s2.x= 0);
A5: now
      let a be Int_position;
A6:   a in D by SCMPDS_2:def 2;
      hence s1.a=t.a by A3
        .=s2.a by A4,A6;
    end;
A7: now
      let i be Element of NAT;
      thus s1.i = goto 0 by A3
        .=s2.i by A4;
    end;
    IC s1 = 0 by A3
      .=IC s2 by A4;
    hence thesis by A5,A7,SCMPDS_2:54;
  end;
end;

theorem Th2:
  for t1,t2 being State of SCMPDS st DataPart t1=DataPart t2 holds
  Dstate(t1)=Dstate(t2)
proof
  let t1,t2 be State of SCMPDS;
  set s1=Dstate(t1), s2=Dstate(t2);
A1: now
    let i be Element of NAT;
    thus s1.i = goto 0 by Def1
      .=s2.i by Def1;
  end;
  assume
A2: DataPart t1=DataPart t2;
A3: now
    let a be Int_position;
A4: a in D by SCMPDS_2:def 2;
    hence s1.a=t1.a by Def1
      .=t2.a by A2,SCMPDS_3:4
      .=s2.a by A4,Def1;
  end;
  IC s1 = 0 by Def1
    .=IC s2 by Def1;
  hence thesis by A3,A1,SCMPDS_2:54;
end;

theorem Th3:
  for t being State of SCMPDS,i being Instruction of SCMPDS st
  InsCode i in {0,4,5,6} holds Dstate(t)=Dstate(Exec(i,t))
proof
  let t be State of SCMPDS,i be Instruction of SCMPDS;
  assume InsCode i in {0,4,5,6};
  then DataPart Exec(i,t) = DataPart t by SCMPDS_7:20;
  hence thesis by Th2;
end;

theorem Th4:
  (Dstate(s)).a=s.a
proof
  a in D implies (Dstate s).a = s.a by Def1;
  hence thesis by SCMPDS_2:def 2;
end;

theorem Th5:
  for a be Int_position holds ex f be Function of product the
  Object-Kind of SCMPDS,NAT st for s being State of SCMPDS holds (s.a <= 0
  implies f.s =0) & (s.a > 0 implies f.s=s.a)
proof
  let a be Int_position;
  defpred P[set,set] means ex t be State of SCMPDS st t=$1 & (t.a <= 0 implies
  $2 =0) & (t.a > 0 implies $2=t.a);
A1: now
    let s be Element of product the Object-Kind of SCMPDS;
    per cases;
    suppose
A2:   s.a <= 0;
      reconsider y=0 as Element of NAT;
      take y;
      thus P[s,y] by A2;
    end;
    suppose
A3:   s.a > 0;
      then reconsider y=s.a as Element of NAT by INT_1:16;
      take y;
      thus P[s,y] by A3;
    end;
  end;
  consider
  f be Function of product the Object-Kind of SCMPDS,NAT such that
A4: for s being Element of product the Object-Kind of SCMPDS holds P[s,f.s]
    from FUNCT_2:sch 3(A1);
A5: for s holds P[s,f.s]
   proof
    let s;
    reconsider s as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
     P[s,f.s] by A4;
   hence thesis;
   end;
  take f;
  hereby
    let s;
    P[s,f.s] by A5;
    hence (s.a <= 0 implies f.s =0) & (s.a > 0 implies f.s=s.a);
  end;
end;

begin :: The construction and several basic properties of while<0 program

:: while (a,i)<0 do I

definition
  let a be Int_position, i be Integer,I be Program of SCMPDS;
  func while<0(a,i,I) -> Program of SCMPDS equals
  (a,i)>=0_goto (card I +2)
  ';' I ';' goto -(card I+1);
  coherence;
end;

registration
  let I be shiftable Program of SCMPDS,a be Int_position,i be Integer;
  cluster while<0(a,i,I) -> shiftable;
  correctness
  proof
    set WHL=while<0(a,i,I), i1= (a,i)>=0_goto (card I +2);
    set PF= Load i1 ';' I;
A1: PF=i1 ';' I by SCMPDS_4:def 4;
    then card PF=card I + 1 by SCMPDS_6:15;
    then card PF+ -(card I+1) =0;
    hence thesis by A1,SCMPDS_4:78;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,i be Integer;
  cluster while<0(a,i,I) -> halt-free;
  correctness;
end;

theorem Th6:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
  card while<0(a,i,I)= card I +2
proof
  let a be Int_position,i be Integer, I be Program of SCMPDS;
  set i1=(a,i)>=0_goto (card I +2);
  set I4=i1 ';' I;
  thus card while<0(a,i,I)=card I4+1 by SCMP_GCD:8
    .=card I +1 +1 by SCMPDS_6:15
    .=card I + 2;
end;

Lm1: for a be Int_position,i be Integer,I be Program of SCMPDS holds card stop
while<0(a,i,I)= card I+3

proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  thus card stop while<0(a,i,I)= card while<0(a,i,I) +1 by SCMPDS_5:7
    .= card I +2+1 by Th6
    .= card I + 3;
end;

theorem Th7:
  for a be Int_position,i be Integer,m be Element of NAT,I be
  Program of SCMPDS holds m < card I+2 iff  m in dom while<0(a,i,I)
proof
  let a be Int_position,i be Integer,m be Element of NAT, I be Program of
  SCMPDS;
  card while<0(a,i,I)=card I + 2 by Th6;
  hence thesis by AFINSQ_1:70;
end;

theorem Th8:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
while<0(a,i,I). 0=(a,i)>=0_goto (card I +2) & while<0(a,i,I). (card
  I+1)=goto -(card I+1)
proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  set i1=(a,i)>=0_goto (card I +2), i2=goto -(card I+1);
  set I4=i1 ';' I;
  set J5=I ';' i2;
  set FLOOP=while<0(a,i,I);
  FLOOP=i1 ';' J5 by SCMPDS_4:51;
  hence FLOOP. 0=i1 by SCMPDS_6:16;
  card I4=card I+1 by SCMPDS_6:15;
  hence thesis by SCMP_GCD:10;
end;

theorem Th9:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer st s.DataLoc(s.a,i) >= 0 holds while<0(a,i,I)
  is_closed_on s & while<0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer;
  set d1=DataLoc(s.a,i);
  assume
A1: s.d1 >= 0;
  set i1=(a,i)>=0_goto (card I+2), i2=goto -(card I+1);
  set WHL=while<0(a,i,I), pWHL=stop WHL,
      s3 = Initialize s +* pWHL, s4 = Comput(ProgramPart(s3),s3,1);
A2: s +* Initialize pWHL = Initialize s +* pWHL by COMPOS_1:125;
A3: IC s3 = 0 by SCMPDS_6:21;
A4: not d1 in dom Initialize pWHL by SCMPDS_4:31;
  not a in dom Initialize pWHL by SCMPDS_4:31;
  then
A5: s3.DataLoc(s3.a,i)=s3.d1 by A2,FUNCT_4:12
    .= s.d1 by A4,A2,FUNCT_4:12;
A6: WHL = i1 ';' (I ';' i2 ) by SCMPDS_4:51;
  Comput(ProgramPart(s3),s3,0+1) = Following(ProgramPart s3,
  Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i1,s3) by A6,A2,SCMPDS_6:22;
  then
A7: IC s4 = ICplusConst(s3,(card I+2)) by A1,A5,SCMPDS_2:69
    .= (0+(card I+2)) by A3,SCMPDS_6:23;
A8: card WHL=card I+2 by Th6;
  then
A9: (card I+2) in dom pWHL by SCMPDS_6:25;
A10:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
  Initialize pWHL c= s3 by A2,FUNCT_4:26;
  then pWHL c= s4 by AMI_1:81,COMPOS_1:132;
  then s4.(card I+2) = pWHL.(card I+2) by A9,GRFUNC_1:8
    .=halt SCMPDS by A8,SCMPDS_6:25;
  then
A11: CurInstr(ProgramPart s4,s4) = halt SCMPDS by A7,A10;
A12: ProgramPart s4 = ProgramPart s3
by AMI_1:123;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:20;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pWHL
      by A9,A7,A11,A12,EXTPRO_1:6;
    end;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pWHL by A3,COMPOS_1:135;
    end;
  end;
  hence WHL is_closed_on s by SCMPDS_6:def 2;
  ProgramPart s3 halts_on s3 by A11,A12,EXTPRO_1:30;
  hence thesis by SCMPDS_6:def 3;
end;

theorem Th10:
  for s being State of SCMPDS,I being Program of SCMPDS,a,c being
Int_position, i being Integer st s.DataLoc(s.a,i) >= 0 holds IExec(while<0(a,i,
  I),s) = s +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a,c be Int_position, i be
  Integer;
  set d1=DataLoc(s.a,i);
  set WHL=while<0(a,i,I), pWHL=stop WHL,
     s3 = Initialize s +* pWHL,
     s4 = Comput(ProgramPart(s3),s3,1),
     i1=(a,i)>=0_goto (card I+2), i2=goto -(card I+1);
A1: s +* Initialize pWHL = Initialize s +* pWHL by COMPOS_1:125;
  set SAl=Start-At((card I+2),SCMPDS);
A2: IC s3 = 0 by SCMPDS_6:21;
A3: WHL = i1 ';' (I ';' i2) by SCMPDS_4:51;
A4: not d1 in dom Initialize pWHL by SCMPDS_4:31;
  not a in dom Initialize pWHL by SCMPDS_4:31;
  then
A5: s3.DataLoc(s3.a,i)=s3.d1 by A1,FUNCT_4:12
    .= s.d1 by A4,A1,FUNCT_4:12;
A6: Comput(ProgramPart(s3),s3,0+1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i1,s3) by A3,A1,SCMPDS_6:22;
  Initialize pWHL c= s3 by A1,FUNCT_4:26;
  then
A7: pWHL c= s4 by AMI_1:81,COMPOS_1:132;
A8: IExec(WHL,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
  assume s.d1 >= 0;
  then
A9: IC s4 = ICplusConst(s3,(card I+2)) by A6,A5,SCMPDS_2:69
    .= (0+(card I+2)) by A2,SCMPDS_6:23;
A10:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
A11: ProgramPart s4 = ProgramPart s3
by AMI_1:123;
A12: card WHL=card I+2 by Th6;
  then (card I+2) in dom pWHL by SCMPDS_6:25;
  then s4.(card I+2) = pWHL.(card I+2) by A7,GRFUNC_1:8
    .=halt SCMPDS by A12,SCMPDS_6:25;
  then
A13: CurInstr(ProgramPart s4,s4) = halt SCMPDS by A9,A10;
  then
A14: ProgramPart s3 halts_on s3 by A11,EXTPRO_1:30;
A15: CurInstr(ProgramPart s3,s3) = i1 by A3,A1,SCMPDS_6:22;
  now
    let l be Element of NAT;
A16: Comput(ProgramPart(s3),s3,0) = s3 by EXTPRO_1:3;
    assume l < 0+1;
    then l=0 by NAT_1:13;
    then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
     = CurInstr(ProgramPart s3,s3) by A16;
    hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) <>
     halt SCMPDS by A15,SCMPDS_6:31;
  end;
  then for l be Element of NAT
   st CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan(ProgramPart(s3),s3) = 1 by A13,A14,A11,EXTPRO_1:def 14;
  then
A17: s4 = Result(ProgramPart(s3),s3) by A14,EXTPRO_1:23;
A18: dom ProgramPart s = A by COMPOS_1:34;
A19: now
    let x be set;
A20: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A21: x in dom IExec(WHL,s);
    per cases by A21,SCMPDS_4:20;
    suppose
A22:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A23:  not x in dom SAl by A20,TARSKI:def 1;
      not x in dom (s | A) by A18,A22,SCMPDS_2:53;
      hence IExec(WHL,s).x = s4.x by A17,A8,FUNCT_4:12
        .= s3.x by A6,A22,SCMPDS_2:69
        .= s.x by A22,SCMPDS_5:19
        .= (s +* SAl).x by A23,FUNCT_4:12;
    end;
    suppose
A24:  x = IC SCMPDS;
      not x in dom (s | A) by A18,A24,COMPOS_1:3;
      hence IExec(WHL,s).x = (card I + 2) by A9,A17,A8,A24,FUNCT_4:12
        .= (s +* SAl).x by A24,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(WHL,s).x = (s +* SAl).x by SCMPDS_6:27;
    end;
  end;
  dom IExec(WHL,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A19,FUNCT_1:9;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, i being Integer st s.DataLoc(s.a,i) >= 0 holds IC IExec(while<0(a
  ,i,I),s) =  (card I + 2)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer;
  assume s.DataLoc(s.a,i) >= 0;
  then IExec(while<0(a,i,I),s) =s +* Start-At((card I+2),SCMPDS) by Th10;
  hence thesis by FUNCT_4:121;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS, a,b being
Int_position , i being Integer st s.DataLoc(s.a,i) >= 0 holds IExec(while<0(a,i
  ,I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, i be
  Integer;
  assume s.DataLoc(s.a,i) >= 0;
  then
A1: IExec(while<0(a,i,I),s) = s +* Start-At((card I+2),SCMPDS) by Th10;
  not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

Lm2: for I being Program of SCMPDS,a being Int_position,i being Integer holds
Shift(I,1) c= while<0(a,i,I)

proof
  let I be Program of SCMPDS,a be Int_position,i be Integer;
  set i1=(a,i)>=0_goto (card I+2), i2=goto -(card I+1);
A1: while<0(a,i,I) = i1 ';' I ';' Load i2 by SCMPDS_4:def 5
    .= Load i1 ';' I ';' Load i2 by SCMPDS_4:def 4;
  card Load i1=1 by SCMPDS_5:6;
  hence thesis by A1,SCMPDS_7:16;
end;

scheme
  WhileLHalt { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
  P[State of SCMPDS]}: (F(s())=F(s()) or P[s()]) & while<0(a(),i(),I())
  is_closed_on s() & while<0(a(),i(),I()) is_halting_on s()
provided
A1: card I() > 0 and
A2: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.
DataLoc(s().a(),i()) >= 0 and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) < 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
]
proof
  set i1=(a(),i())>=0_goto (card I()+2), i2=goto -(card I()+1);
  set WHL=while<0(a(),i(),I()), pWHL=stop WHL,
  pI=stop I();
  set b=DataLoc(s().a(),i());
  defpred Q[Element of NAT] means for t be State of SCMPDS st F(Dstate(t)) <=
$1 & P[Dstate t] & t.a()=s().a() holds WHL is_closed_on t & WHL is_halting_on t
  ;
A5: for k be Element of NAT st Q[k] holds Q[k + 1]
  proof
    let k be Element of NAT;
    assume
A6: Q[k];
    now
      let t be State of SCMPDS;
      assume
A7:   F(Dstate(t)) <= k+1;
      assume
A8:   P[Dstate t];
      assume
A9:   t.a()=s().a();
      per cases;
      suppose
        t.b >= 0;
        hence WHL is_closed_on t & WHL is_halting_on t by A9,Th9;
      end;
      suppose
A10:    t.b < 0;
A11:    dom ProgramPart t = A by COMPOS_1:34;
A12: not a() in dom (t | A) by A11,SCMPDS_2:53;
A13:    IExec(I(),t).a()=t.a() by A4,A8,A9,A10;
A14:     0 in dom pWHL by COMPOS_1:135;
A15:    dom ProgramPart t = A by COMPOS_1:34;
A16:    not b in dom Initialize pWHL by SCMPDS_4:31;
A17:    WHL = i1 ';' (I() ';' i2) by SCMPDS_4:51;
        set t2 = Initialize t +* pI, t3 = Initialize t +* pWHL,
        t4 = Comput(ProgramPart(t3),t3,1);
A18:     Initialize t +* pI =  t +* Initialize pI by COMPOS_1:125;
A19:     Initialize t +* pWHL = t +* Initialize pWHL by COMPOS_1:125;
A20:    Initialize pI c= t2 by A18,FUNCT_4:26;
        set m2=LifeSpan(ProgramPart(t2),t2), t5=Comput(ProgramPart(t4),t4,m2),
l1= (card I() + 1
);
A21:    IC t3 = 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6=Comput(ProgramPart(t3),t3,m3);
        set t7=Comput(ProgramPart(t3),t3,m3+1);
        card I() + 1 < card I() + 2 by XREAL_1:8;
        then
A22:    l1 in dom WHL by Th7;
        WHL c= Initialize pWHL & Initialize pWHL c= t3
           by A19,FUNCT_4:26,SCMPDS_6:17;
        then
A23:    WHL c= t3 by XBOOLE_1:1;
        Shift(I(),1) c= WHL by Lm2;
        then Shift(I(),1) c= t3 by A23,XBOOLE_1:1;
        then
A24:    Shift(I(),1) c= t4 by AMI_1:81;
A25:    Comput(ProgramPart(t3),t3,0+1) = Following(ProgramPart t3,
Comput(ProgramPart(t3),t3,0)) by EXTPRO_1:4
          .= Following(ProgramPart t3,t3) by EXTPRO_1:3
          .= Exec(i1,t3) by A17,A19,SCMPDS_6:22;
A26:    DataPart t2 = DataPart t3 by COMPOS_1:138,FUNCT_7:134;
        now
          let a;
          thus t2.a = t3.a by A26,SCMPDS_4:23
            .= t4.a by A25,SCMPDS_2:69;
        end;
        then
A27:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
        I() is_halting_on t by A4,A8,A9,A10;
        then
A28:    ProgramPart t2 halts_on t2 by SCMPDS_6:def 3;
A29:     Initialize t2+*pI = t2+*Initialize pI by COMPOS_1:125;
        t2 = Initialize t2+*pI by A20,A29,FUNCT_4:79;
        then ProgramPart(Initialize t2+*pI) halts_on Initialize t2+*pI by A28;
        then
A30:    I() is_halting_on t2 by SCMPDS_6:def 3;
A31:    IExec(I(),t) = Result(ProgramPart(t2),t2) +* t | A
by SCMPDS_4:def 8;
A32:    P[Dstate(IExec(I(),t))] by A4,A8,A9,A10;
A33:    I() is_closed_on t by A4,A8,A9,A10;
        then
A34:    I() is_closed_on t2 by SCMPDS_6:38;
        not a() in dom Initialize pWHL by SCMPDS_4:31;
        then t3.DataLoc(t3.a(),i())= t3.b by A9,A19,FUNCT_4:12
          .= t.b by A16,A19,FUNCT_4:12;
        then
A35:    IC t4 = succ IC t3 by A10,A25,SCMPDS_2:69
          .= (0+1) by A21;
        then
A36:    IC t5=l1 by A1,A20,A30,A34,A27,A24,SCMPDS_7:36;
A37:  (ProgramPart t6)/.IC t6
 = t6.IC t6 by COMPOS_1:38;
 ProgramPart t3 = ProgramPart t4
by AMI_1:123;
 then
A38:    t6=t5 by EXTPRO_1:5;
        then
A39:    CurInstr(ProgramPart t6,t6)=t5.l1
 by A1,A20,A30,A34,A35,A27,A24,A37,SCMPDS_7:36
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=WHL.l1 by A22,A23,GRFUNC_1:8
          .=i2 by Th8;
A40: ProgramPart t3 = ProgramPart t6
by AMI_1:123;
A41:    t7 = Following(ProgramPart t3,t6) by EXTPRO_1:4
          .= Exec(i2,t6) by A39,A40;
        then IC t7=ICplusConst(t6,0-(card I()+1)) by SCMPDS_2:66
          .= 0 by A36,A38,SCMPDS_7:1;
        then
A42:    Initialize t7 +* pWHL=t7 by SCMPDS_7:37;
A43:    DataPart Comput(ProgramPart(t2),t2,m2) = DataPart t5 by A1,A20,A30,A34
,A35,A27,A24,SCMPDS_7:36;
        then
A44:    DataPart t5 = DataPart Result(ProgramPart(t2),t2) by A28,EXTPRO_1:23
          .= DataPart(Result(ProgramPart(t2),t2) +* t | A) by A15,AMI_2:29
,FUNCT_4:76,SCMPDS_2:100
          .=DataPart IExec(I(),t) by SCMPDS_4:def 8;
        InsCode i2=0 by SCMPDS_2:21;
        then InsCode i2 in {0,4,5,6} by ENUMSET1:def 2;
        then
A45:    Dstate(t7)=Dstate(t6) by A41,Th3
          .=Dstate(IExec(I(),t)) by A44,A38,Th2;
A46:    now
          F(Dstate(IExec(I(),t))) < F(Dstate(t)) by A4,A8,A9,A10;
          then
A47:      F(Dstate(t7)) < k+1 by A7,A45,XXREAL_0:2;
          assume F(Dstate(t7)) > k;
          hence contradiction by A47,INT_1:20;
        end;
A48:    t5.a()=Comput(ProgramPart(t2),t2,m2).a() by A43,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).a() by A28,EXTPRO_1:23
          .=s().a() by A9,A13,A31,A12,FUNCT_4:12;
A49: ProgramPart t4 = ProgramPart t3
by AMI_1:123;
A50:    t7.a()=t6.a() by A41,SCMPDS_2:66
          .=s().a() by A48,A49,EXTPRO_1:5;
        then
A51:    WHL is_closed_on t7 by A6,A32,A45,A46;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m3+1;
            then
A52:        k <= m3 by INT_1:20;
            hereby
              per cases by A52,NAT_1:8;
              suppose
A53:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A14
,A21,EXTPRO_1:3;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A54:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(ProgramPart(t2),t2,kn) as Element
of NAT;
A55: ProgramPart t3 = ProgramPart t4
by AMI_1:123;
                    kn < k by A54,XREAL_1:31;
                    then kn < m2 by A53,XXREAL_0:2;
                    then IC Comput(ProgramPart(t2),t2,kn) + 1 = IC Comput(
ProgramPart(t4),t4,kn) by A1,A20,A30,A34,A35,A27,A24,SCMPDS_7:34;
                    then
A56:                IC Comput(ProgramPart(t3),t3,k) = (lm+1) by A54,A55,
EXTPRO_1:5;
                    IC Comput(ProgramPart(t2),t2,kn) in dom pI by A33,
SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:70;
                    then lm < card I()+1 by SCMPDS_5:7;
                    then
A57:                lm+1 <= card I() +1 by INT_1:20;
                    card I() + 1 < card I() + 3 by XREAL_1:8;
                    then lm+1 < card I() +3 by A57,XXREAL_0:2;
                    then lm+1 < card pWHL by Lm1;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A56,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A58:            k=m3;
                l1 in dom pWHL by A22,SCMPDS_6:18;
                hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A1,A20,A30
,A34,A35,A27,A24,A38,A58,SCMPDS_7:36;
              end;
            end;
          end;
          suppose
            k >= m3+1;
            then consider nn be Nat such that
A59:        k=m3+1+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
 ProgramPart t3 = ProgramPart t7
by AMI_1:123;
then
            Comput(ProgramPart(t3),t3,k)=
            Comput(ProgramPart(Initialize t7+*pWHL),Initialize t7+*pWHL,
nn) by A42,A59,EXTPRO_1:5;
            hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A51,
SCMPDS_6:def 2;
          end;
        end;
        hence WHL is_closed_on t by SCMPDS_6:def 2;
        WHL is_halting_on t7 by A6,A32,A50,A45,A46;
        then ProgramPart t7 halts_on t7 by A42,SCMPDS_6:def 3;
        then ProgramPart t3 halts_on t7 by AMI_1:123;
        then ProgramPart t3 halts_on t3 by EXTPRO_1:22;
        hence WHL is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  set n=F(Dstate s());
  thus F(s())=F(s()) or P[s()];
A60: Q[0]
  proof
    let t be State of SCMPDS;
    assume that
A61: F(Dstate(t)) <= 0 and
A62: P[Dstate t] and
A63: t.a()=s().a();
    F(Dstate(t))=0 by A61;
    then t.b >= 0 by A2,A62;
    hence thesis by A63,Th9;
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A60,A5);
  then Q[n];
  hence thesis by A3;
end;

scheme
  WhileLExec { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
P[State of SCMPDS]}: (F(s())=F(s()) or P[s()]) & IExec(while<0(a(),i(),I()),s()
  ) = IExec(while<0(a(),i(),I()),IExec(I(),s()))
provided
A1: card I() > 0 and
A2: s().DataLoc(s().a(),i()) < 0 and
A3: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.
DataLoc(s().a(),i()) >= 0 and
A4: P[Dstate s()] and
A5: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) < 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
]
proof
  set WHL=while<0(a(),i(),I()),
  pWHL = stop WHL,
  s1= Initialize s() +* pWHL, ps= ProgramPart s();
  set sI= Initialize s() +* stop I(), m1=LifeSpan(ProgramPart(sI),sI)+2,
  s2=Initialize IExec(I(),s()) +* pWHL, m2=LifeSpan(ProgramPart s2,
  s2);
A6: Initialize s() +* pWHL = s() +* Initialize pWHL by COMPOS_1:125;
A7: Initialize s() +* stop I() = s() +* Initialize stop I() by COMPOS_1:125;
A8: Initialize IExec(I(),s()) +* pWHL = IExec(I(),s()) +* Initialize pWHL
  by COMPOS_1:125;
A9: P[Dstate s()] by A4;
A10: Initialize stop I() c= sI by A7,FUNCT_4:26;
  I() is_closed_on s() by A2,A4,A5;
  then
A11: I() is_closed_on sI by SCMPDS_6:38;
  I() is_halting_on s() by A2,A4,A5;
  then
A12: ProgramPart sI halts_on sI by SCMPDS_6:def 3;
A13: Initialize sI+*stop I() = sI+*Initialize stop I() by COMPOS_1:125;
  sI = Initialize sI+*stop I() by A10,A13,FUNCT_4:79;
  then ProgramPart(Initialize sI+*stop I()) halts_on Initialize sI+*stop I()
   by A12;
  then
A14: I() is_halting_on sI by SCMPDS_6:def 3;
  set Es=IExec(I(),s()), bj=DataLoc(Es.a(),i());
  deffunc U(State of SCMPDS) = F($1);
A15: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(s().
  a(),i()) < 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & U(Dstate IExec(I(),t)) < U(Dstate t) & P[Dstate(IExec(I(),t))
  ] by A5;
A16: for t be State of SCMPDS st P[Dstate t] & U(Dstate(t))=0 holds t.DataLoc
  (s().a(),i()) >= 0 by A3;
  (U(s())=U(s()) or P[s()]) & WHL is_closed_on s() & WHL is_halting_on s()
  from WhileLHalt(A1,A16,A9,A15);
  then
A17: ProgramPart s1 halts_on s1 by SCMPDS_6:def 3;
  deffunc U(State of SCMPDS) = F($1);
A18: IExec(I(), s()).a()=s().a() by A2,A4,A5;
  then
A19: for t be State of SCMPDS st P[Dstate(t)] & U(Dstate(t))=0 holds t.bj >=
  0 by A3;
A20: for t being State of SCMPDS st P[Dstate t] & t.a()=Es.a() & t.bj < 0
  holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I() is_halting_on t & U(
  Dstate IExec(I(),t)) < U(Dstate t) & P[Dstate(IExec(I(),t))] by A5,A18;
A21: P[Dstate Es] by A2,A4,A5;
  (U(Es)=U(Es) or P[Es]) & WHL is_closed_on Es & WHL is_halting_on Es
  from WhileLHalt(A1,A19,A21,A20);
  then
A22: ProgramPart s2 halts_on s2 by SCMPDS_6:def 3;
  set s4 = Comput(ProgramPart(s1),s1,1);
  set i1=(a(),i())>=0_goto (card I()+2), i2=goto -(card I()+1);
  set b=DataLoc(s().a(),i());
A23: WHL = i1 ';' (I() ';' i2) by SCMPDS_4:51;
  set mI=LifeSpan(ProgramPart(sI),sI), s5=Comput(ProgramPart(s4),s4,mI), l1= (
card I() + 1);
A24: IC s1 = 0 by SCMPDS_6:21;
A25: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by EXTPRO_1:4
    .= Following(ProgramPart s1,s1) by EXTPRO_1:3
    .= Exec(i1,s1) by A23,A6,SCMPDS_6:22;
A26: DataPart sI = DataPart s1 by COMPOS_1:138,FUNCT_7:134;
  now
    let a;
    thus sI.a = s1.a by A26,SCMPDS_4:23
      .= s4.a by A25,SCMPDS_2:69;
  end;
  then
A27: DataPart sI = DataPart s4 by SCMPDS_4:23;
  set m3=mI +1;
  set s6=Comput(ProgramPart(s1),s1,m3);
  card I() + 1 < card I() + 2 by XREAL_1:8;
  then
A28: l1 in dom WHL by Th7;
  thus F(s())=F(s()) or P[s()];
  set m0=LifeSpan(ProgramPart(s1),s1);
A29: dom ps = dom s() /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
A30: IExec(I(),s()) | A= (Result(ProgramPart(sI),sI) +* ps) | A by
SCMPDS_4:def 8
    .= ps by A29,FUNCT_4:24;
  set s7=Comput(ProgramPart(s1),s1,m3+1);
A31: IExec(I(),s()) = Result(ProgramPart(sI),sI) +* s() | A
by SCMPDS_4:def 8;
A32: dom ProgramPart s() = A by COMPOS_1:34;
  WHL c= Initialize pWHL & Initialize pWHL c= s1
  by A6,FUNCT_4:26,SCMPDS_6:17;
  then
A33: WHL c= s1 by XBOOLE_1:1;
  Shift(I(),1) c= WHL by Lm2;
  then Shift(I(),1) c= s1 by A33,XBOOLE_1:1;
  then
A34: Shift(I(),1) c= s4 by AMI_1:81;
  s1.DataLoc(s1.a(),i())=s1.b by SCMPDS_5:19
    .= s().b by SCMPDS_5:19;
  then
A35: IC s4 = succ IC s1 by A2,A25,SCMPDS_2:69
    .= (0+1) by A24;
  then
A36: IC s5=l1 by A1,A10,A14,A11,A27,A34,SCMPDS_7:36;
A37:  (ProgramPart s6)/.IC s6
 = s6.IC s6 by COMPOS_1:38;
 ProgramPart s1 = ProgramPart s4
by AMI_1:123;
 then
A38: s6=s5 by EXTPRO_1:5;
  then
A39: CurInstr(ProgramPart s6,s6)=s5.l1 by A1,A10,A14,A11,A35,A27,A34,A37,
SCMPDS_7:36
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=WHL.l1 by A28,A33,GRFUNC_1:8
    .=i2 by Th8;
A40: ProgramPart s1 = ProgramPart s6
by AMI_1:123;
A41: s7 = Following(ProgramPart s1,s6) by EXTPRO_1:4
    .= Exec(i2,s6) by A39,A40;
  then IC s7=ICplusConst(s6,0-(card I()+1)) by SCMPDS_2:66
    .= 0 by A36,A38,SCMPDS_7:1;
  then
A42: IC s2 =IC Comput(ProgramPart(s1),s1,m1) by SCMPDS_6:21;
A43: DataPart Comput(ProgramPart(sI),sI,mI) = DataPart s5 by A1,A10,A14,A11,A35
,A27,A34,SCMPDS_7:36;
  now
    let x be Int_position;
A44: not x in dom Initialize pWHL by SCMPDS_4:31;
A45: not x in dom (s() | A) by A32,SCMPDS_2:53;
    s5.x=Comput(ProgramPart(sI),sI,mI).x by A43,SCMPDS_4:23
      .=(Result(ProgramPart(sI),sI)).x by A12,EXTPRO_1:23
      .=IExec(I(),s()).x by A31,A45,FUNCT_4:12;
    hence s7.x=IExec(I(),s()).x by A38,A41,SCMPDS_2:66
      .=s2.x by A44,A8,FUNCT_4:12;
  end;
  then
A46: DataPart s7 = DataPart s2 by SCMPDS_4:23;
A47: ProgramPart(s1) = ProgramPart Comput(ProgramPart(s1),s1,m1)
by AMI_1:123;
  ProgramPart s2
     =ProgramPart (Result(ProgramPart(sI),sI) +* ps +* Initialize pWHL)
     by A8,SCMPDS_4:def 8
    .=ProgramPart (Result(ProgramPart(sI),sI) +* ps) +*
    ProgramPart Initialize pWHL
         by FUNCT_4:75
    .= ps +* ProgramPart Initialize pWHL by A29,FUNCT_4:24
    .= ProgramPart s1 by A6,FUNCT_4:75
    .= ProgramPart Comput(ProgramPart(s1),s1,m1) by AMI_1:123;
  then
A48: Comput(ProgramPart(s1),s1,m1)=s2 by A46,A42,SCMPDS_7:7;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1))=i1
   by A23,A47,A8,SCMPDS_6:22;
  then m0 > m1 by A17,SCMPDS_6:2,31;
  then consider nn be Nat such that
A49: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
A50: ProgramPart s1 = ProgramPart s2
by A48,AMI_1:123;
  Comput(ProgramPart(s1),s1,m1+m2) = Comput(ProgramPart(s1),s2,m2) by A48,
EXTPRO_1:5;
  then CurInstr(ProgramPart s1 ,Comput(ProgramPart(s1),s1,m1+m2))
   = halt SCMPDS by A22,A50,EXTPRO_1:def 14;
  then m1 + m2 >= m0 by A17,EXTPRO_1:def 14;
  then
A51: m2 >= nn by A49,XREAL_1:8;
A52: Comput(ProgramPart(s1),s1,m0) = Comput(ProgramPart(s1),s2,nn) by A48,A49,
EXTPRO_1:5;
  then CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,nn))
   =halt SCMPDS by A17,A50,EXTPRO_1:def 14;
  then nn >= m2 by A22,EXTPRO_1:def 14;
  then nn=m2 by A51,XXREAL_0:1;
  then Result(ProgramPart(s1),s1) = Comput(ProgramPart(s2),s2,m2) by A17,A52,
A50,
EXTPRO_1:23;
  hence IExec(WHL,s()) = Comput(ProgramPart(s2),s2,m2) +* ps
  by SCMPDS_4:def 8
    .= Result(ProgramPart(s2),s2) +* IExec(I(),s()) | A by A22,A30,EXTPRO_1:23
    .= IExec(WHL,IExec(I(),s())) by SCMPDS_4:def 8;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable Program of
SCMPDS , a be Int_position, i be Integer,X be set, f being Function of product
the Object-Kind of SCMPDS,NAT st card I > 0 & ( for t be State of SCMPDS st f.
Dstate(t)=0 holds t.DataLoc(s.a,i) >= 0 ) & (for t be State of SCMPDS st (for x
be Int_position st x in X holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) < 0 holds
  IExec(I,t).a=t.a & f.Dstate(IExec(I,t)) < f.Dstate(t) & I is_closed_on t & I
is_halting_on t & for x be Int_position st x in X holds IExec(I,t).x=t.x) holds
  while<0(a,i,I) is_closed_on s & while<0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
Int_position, i be Integer,X be set,f be Function of product the Object-Kind of
  SCMPDS,NAT;
  set b=DataLoc(s.a,i);
  set WHL=while<0(a,i,I), pWHL=stop WHL,
  pI=stop I;
  set i1=(a,i)>=0_goto (card I+2), i2=goto -(card I+1);
  assume
A1: card I > 0;
  defpred P[Element of NAT] means for t be State of SCMPDS st f.Dstate(t) <=
  $1 & (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a holds WHL
  is_closed_on t & WHL is_halting_on t;
  assume
A2: for t be State of SCMPDS st f.Dstate(t)=0 holds t.b >= 0;
  assume
A3: for t be State of SCMPDS st (for x st x in X holds t.x=s.x) & t.a=s.
  a & t.b < 0 holds IExec(I,t).a=t.a & f.Dstate(IExec(I,t)) < f.Dstate(t) & I
  is_closed_on t & I is_halting_on t & for x st x in X holds IExec(I,t).x=t.x;
A4: for k be Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A5: P[k];
    now
      let t be State of SCMPDS;
      assume
A6:   f.Dstate(t) <= k+1;
      assume
A7:   for x st x in X holds t.x=s.x;
      assume
A8:   t.a=s.a;
      per cases;
      suppose
        t.b >= 0;
        hence WHL is_closed_on t & WHL is_halting_on t by A8,Th9;
      end;
      suppose
A9:     t.b < 0;
A10:    dom ProgramPart t = A by COMPOS_1:34;
A11: not a in dom (t | A) by A10,SCMPDS_2:53;
A12:    IExec(I,t).a=t.a by A3,A7,A8,A9;
A13:     0 in dom pWHL by COMPOS_1:135;
A14:    not b in dom Initialize pWHL by SCMPDS_4:31;
A15:    WHL = i1 ';' (I ';' i2) by SCMPDS_4:51;
A16:    f.Dstate(IExec(I,t)) < f.Dstate(t) by A3,A7,A8,A9;
A17:    dom ProgramPart t = A by COMPOS_1:34;
        set t2 = Initialize t +* pI, t3 = Initialize t +* pWHL,
        t4 = Comput(ProgramPart(t3),t3,1);
A18:     Initialize t +* pI = t +* Initialize pI by COMPOS_1:125;
A19:     Initialize t +* pWHL = t +* Initialize pWHL by COMPOS_1:125;
A20:    Initialize pI c= t2 by A18,FUNCT_4:26;
A21:    Comput(ProgramPart(t3),t3,0+1) = Following(ProgramPart t3,
Comput(ProgramPart(t3),t3,0)) by EXTPRO_1:4
          .= Following(ProgramPart t3,t3) by EXTPRO_1:3
          .= Exec(i1,t3) by A15,A19,SCMPDS_6:22;
A22:    DataPart t2 = DataPart t3 by COMPOS_1:138,FUNCT_7:134;
        now
          let a;
          thus t2.a = t3.a by A22,SCMPDS_4:23
            .= t4.a by A21,SCMPDS_2:69;
        end;
        then
A23:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
        WHL c= Initialize pWHL & Initialize pWHL c= t3
        by A19,FUNCT_4:26,SCMPDS_6:17;
        then
A24:    WHL c= t3 by XBOOLE_1:1;
        Shift(I,1) c= WHL by Lm2;
        then Shift(I,1) c= t3 by A24,XBOOLE_1:1;
        then
A25:    Shift(I,1) c= t4 by AMI_1:81;
        set m2=LifeSpan(ProgramPart(t2),t2), t5=Comput(ProgramPart(t4),t4,m2),
l1= (card I + 1);
A26:    IC t3 = 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6=Comput(ProgramPart(t3),t3,m3);
        set t7=Comput(ProgramPart(t3),t3,m3+1);
        card I + 1 < card I + 2 by XREAL_1:8;
        then
A27:    l1 in dom WHL by Th7;
A28:    I is_closed_on t by A3,A7,A8,A9;
        then
A29:    I is_closed_on t2 by SCMPDS_6:38;
        I is_halting_on t by A3,A7,A8,A9;
        then
A30:    ProgramPart t2 halts_on t2 by SCMPDS_6:def 3;
A31:     Initialize t2+*pI = t2+*Initialize pI by COMPOS_1:125;
        t2 = Initialize t2+*pI by A20,A31,FUNCT_4:79;
        then ProgramPart(Initialize t2+*pI) halts_on Initialize t2+*pI by A30;
        then
A32:    I is_halting_on t2 by SCMPDS_6:def 3;
        not a in dom Initialize pWHL by SCMPDS_4:31;
        then t3.DataLoc(t3.a,i)= t3.b by A8,A19,FUNCT_4:12
          .= t.b by A14,A19,FUNCT_4:12;
        then
A33:    IC t4 = succ IC t3 by A9,A21,SCMPDS_2:69
          .= (0+1) by A26;
        then
A34:    IC t5=l1 by A1,A20,A32,A29,A23,A25,SCMPDS_7:36;
A35:  (ProgramPart t6)/.IC t6
 = t6.IC t6 by COMPOS_1:38;
 ProgramPart t3 = ProgramPart t4
by AMI_1:123;
 then
A36:    t6=t5 by EXTPRO_1:5;
        then
A37:    CurInstr(ProgramPart t6,t6)=t5.l1
 by A1,A20,A32,A29,A33,A23,A25,A35,SCMPDS_7:36
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=WHL.l1 by A27,A24,GRFUNC_1:8
          .=i2 by Th8;
A38:    DataPart Comput(ProgramPart(t2),t2,m2) = DataPart t5 by A1,A20,A32,A29
,A33,A23,A25,SCMPDS_7:36;
        then
A39:    DataPart t5 =DataPart Result(ProgramPart(t2),t2) by A30,EXTPRO_1:23
          .= DataPart(Result(ProgramPart(t2),t2) +* t | A) by A17,AMI_2:29
,FUNCT_4:76,SCMPDS_2:100
          .=DataPart IExec(I,t) by SCMPDS_4:def 8;
A40: ProgramPart t3 = ProgramPart t6
by AMI_1:123;
A41:    t7 = Following(ProgramPart t3,t6) by EXTPRO_1:4
          .= Exec(i2,t6) by A37,A40;
        then IC t7=ICplusConst(t6,0-(card I+1)) by SCMPDS_2:66
          .= 0 by A34,A36,SCMPDS_7:1;
        then
A42:    Initialize t7 +* pWHL=t7 by SCMPDS_7:37;
A43:    IExec(I,t) = Result(ProgramPart(t2),t2) +* t | A
by SCMPDS_4:def 8;
A44:    now
          let x be Int_position;
          assume
A45:      x in X;
A46: not x in dom (t | A) by A10,SCMPDS_2:53;
          t5.x=Comput(ProgramPart(t2),t2,m2).x by A38,SCMPDS_4:23
            .=(Result(ProgramPart(t2),t2)).x by A30,EXTPRO_1:23
            .=IExec(I,t).x by A43,A46,FUNCT_4:12
            .=t.x by A3,A7,A8,A9,A45
            .=s.x by A7,A45;
          hence t7.x=s.x by A36,A41,SCMPDS_2:66;
        end;
        InsCode i2=0 by SCMPDS_2:21;
        then InsCode i2 in {0,4,5,6} by ENUMSET1:def 2;
        then
A47:    Dstate(t7)=Dstate(t6) by A41,Th3
          .=Dstate(IExec(I,t)) by A39,A36,Th2;
A48:    now
          assume
A49:      f.Dstate(t7) > k;
          f.Dstate(t7) < k+1 by A6,A16,A47,XXREAL_0:2;
          hence contradiction by A49,INT_1:20;
        end;
A50:    t5.a=Comput(ProgramPart(t2),t2,m2).a by A38,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).a by A30,EXTPRO_1:23
          .=s.a by A8,A12,A43,A11,FUNCT_4:12;
A51: ProgramPart t4 = ProgramPart t3
by AMI_1:123;
A52:    t7.a=t6.a by A41,SCMPDS_2:66
          .=s.a by A50,A51,EXTPRO_1:5;
        then
A53:    WHL is_closed_on t7 by A5,A44,A48;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m3+1;
            then
A54:        k <= m3 by INT_1:20;
            hereby
              per cases by A54,NAT_1:8;
              suppose
A55:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A13
,A26,EXTPRO_1:3;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A56:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(ProgramPart(t2),t2,kn) as Element
of NAT;
A57: ProgramPart t3 = ProgramPart t4
by AMI_1:123;
                    kn < k by A56,XREAL_1:31;
                    then kn < m2 by A55,XXREAL_0:2;
                    then IC Comput(ProgramPart(t2),t2,kn) + 1 = IC Comput(
ProgramPart(t4),t4,kn) by A1,A20,A32,A29,A33,A23,A25,SCMPDS_7:34;
                    then
A58:                IC Comput(ProgramPart(t3),t3,k) = (lm+1) by A56,A57,
EXTPRO_1:5;
                    IC Comput(ProgramPart(t2),t2,kn) in dom pI by A28,
SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:70;
                    then lm < card I+1 by SCMPDS_5:7;
                    then
A59:                lm+1 <= card I +1 by INT_1:20;
                    card I + 1 < card I + 3 by XREAL_1:8;
                    then lm+1 < card I +3 by A59,XXREAL_0:2;
                    then lm+1 < card pWHL by Lm1;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A58,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A60:            k=m3;
                l1 in dom pWHL by A27,SCMPDS_6:18;
                hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A1,A20,A32
,A29,A33,A23,A25,A36,A60,SCMPDS_7:36;
              end;
            end;
          end;
          suppose
            k >= m3+1;
            then consider nn be Nat such that
A61:        k=m3+1+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
 ProgramPart t3 = ProgramPart t7
by AMI_1:123;
            then
            Comput(ProgramPart(t3),t3,k)=
            Comput(ProgramPart(Initialize t7+*pWHL),Initialize t7+*pWHL,
nn) by A42,A61,EXTPRO_1:5;
            hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A53,
SCMPDS_6:def 2;
          end;
        end;
        hence WHL is_closed_on t by SCMPDS_6:def 2;
        WHL is_halting_on t7 by A5,A52,A44,A48;
        then ProgramPart t7 halts_on t7 by A42,SCMPDS_6:def 3;
        then ProgramPart t3 halts_on t7 by AMI_1:123;
        then ProgramPart t3 halts_on t3 by EXTPRO_1:22;
        hence WHL is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  set n=f.Dstate(s);
A62: P[0]
  proof
    let t be State of SCMPDS;
    assume f.Dstate(t) <= 0;
    then f.Dstate(t)=0;
    then
A63: t.b >= 0 by A2;
    assume for x st x in X holds t.x=s.x;
    assume
    t.a=s.a;
    hence thesis by A63,Th9;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A62,A4);
  then
A64: P[n];
  for x be Int_position st x in X holds s.x=s.x;
  hence thesis by A64;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable Program of
  SCMPDS, a be Int_position, i be Integer,X be set,f being Function of product
the Object-Kind of SCMPDS,NAT st card I > 0 & s.DataLoc(s.a,i) < 0 & (for t be
  State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i) >= 0 ) & (for t be
State of SCMPDS st (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a &
  t.DataLoc(s.a,i) < 0 holds IExec(I,t).a=t.a & I is_closed_on t & I
is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & for x be Int_position st
x in X holds IExec(I,t).x=t.x) holds IExec(while<0(a,i,I),s) =IExec(while<0(a,i
  ,I),IExec(I,s))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i be Integer,X be set, f be Function of product the Object-Kind
  of SCMPDS,NAT;
  set b=DataLoc(s.a,i);
  assume
A1: card I > 0;
  deffunc F(State of SCMPDS) = f.$1;
  defpred P[State of SCMPDS] means for x st x in X holds $1.x=s.x;
  assume
A2: s.b < 0;
  assume for t be State of SCMPDS st f.Dstate(t)=0 holds t.b >= 0;
  then
A3: for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.b >= 0;
  assume
A4: for t be State of SCMPDS st (for x be Int_position st x in X holds t
  .x=s.x) & t.a=s.a & t.b < 0 holds IExec(I,t).a=t.a & I is_closed_on t & I
is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & for x be Int_position st
  x in X holds IExec(I,t).x=t.x;
A5: now
    let t be State of SCMPDS;
    set v=Dstate t;
    assume that
A6: P[v] and
A7: t.a=s.a & t.b < 0;
    set It=IExec(I,t);
A8: now
      let x;
      assume x in X;
      then v.x =s.x by A6;
      hence t.x=s.x by Th4;
    end;
    hence It.a=t.a & I is_closed_on t & I is_halting_on t & F(Dstate It) < F(
    Dstate t) by A4,A7;
    thus P[Dstate It]
    proof
      set v=Dstate It;
      hereby
        let x;
        assume
A9:     x in X;
        then It.x=t.x by A4,A7,A8;
        then v.x=t.x by Th4;
        hence v.x=s.x by A8,A9;
      end;
    end;
  end;
A10: P[Dstate s] by Th4;
  (F(s)=F(s) or P[s]) & IExec(while<0(a,i,I),s) =IExec(while<0(a,i,I),
  IExec(I,s)) from WhileLExec(A1,A2,A3,A10,A5);
  hence thesis;
end;

theorem Th15:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a be Int_position, i be Integer,X be set st card I > 0 & (
for t be State of SCMPDS st (for x be Int_position st x in X holds t.x=s.x) & t
.a=s.a & t.DataLoc(s.a,i) < 0 holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i
  ) > t.DataLoc(s.a,i) & I is_closed_on t & I is_halting_on t & for x be
  Int_position st x in X holds IExec(I,t).x=t.x) holds while<0(a,i,I)
  is_closed_on s & while<0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i be Integer,X be set;
  set b=DataLoc(s.a,i);
  set WHL=while<0(a,i,I), pWHL=stop WHL,
  pI=stop I;
  set i1=(a,i)>=0_goto (card I+2), i2=goto -(card I+1);
  assume
A1: card I > 0;
  defpred P[Element of NAT] means for t be State of SCMPDS st -t.b <= $1 & (
  for x st x in X holds t.x=s.x) & t.a=s.a holds WHL is_closed_on t & WHL
  is_halting_on t;
  assume
A2: for t be State of SCMPDS st (for x st x in X holds t.x=s.x) & t.a=s.
a & t.b < 0 holds IExec(I,t).a=t.a & IExec(I,t).b > t.b & I is_closed_on t & I
  is_halting_on t & for x st x in X holds IExec(I,t).x=t.x;
A3: for k be Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A4: P[k];
    now
      let t be State of SCMPDS;
      assume
A5:   -t.b <= k+1;
      assume
A6:   for x st x in X holds t.x=s.x;
      assume
A7:   t.a=s.a;
      per cases;
      suppose
        t.b >= 0;
        hence WHL is_closed_on t & WHL is_halting_on t by A7,Th9;
      end;
      suppose
A8:     t.b < 0;
A9:     dom ProgramPart t = A by COMPOS_1:34;
A10: not a in dom (t | A) by A9,SCMPDS_2:53;
A11: not b in dom (t | A) by A9,SCMPDS_2:53;
A12:    IExec(I,t).b > t.b by A2,A6,A7,A8;
A13:     0 in dom pWHL by COMPOS_1:135;
A14:    IExec(I,t).a=t.a by A2,A6,A7,A8;
A15:    not b in dom Initialize pWHL by SCMPDS_4:31;
A16:    WHL = i1 ';' (I ';' i2) by SCMPDS_4:51;
        set t2 = Initialize t +* pI, t3 = Initialize t +* pWHL,
        t4 = Comput(ProgramPart(t3),t3,1);
A17:     Initialize t +* pI = t +* Initialize pI by COMPOS_1:125;
A18:     Initialize t +* pWHL = t +* Initialize pWHL by COMPOS_1:125;
A19:    Initialize pI c= t2 by A17,FUNCT_4:26;
A20:    Comput(ProgramPart(t3),t3,0+1) = Following(ProgramPart t3,
Comput(ProgramPart(t3),t3,0)) by EXTPRO_1:4
          .= Following(ProgramPart t3,t3) by EXTPRO_1:3
          .= Exec(i1,t3) by A16,A18,SCMPDS_6:22;
A21:    DataPart t2 = DataPart t3 by COMPOS_1:138,FUNCT_7:134;
        now
          let a;
          thus t2.a = t3.a by A21,SCMPDS_4:23
            .= t4.a by A20,SCMPDS_2:69;
        end;
        then
A22:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
        WHL c= Initialize pWHL & Initialize pWHL c= t3
        by A18,FUNCT_4:26,SCMPDS_6:17;
        then
A23:    WHL c= t3 by XBOOLE_1:1;
        Shift(I,1) c= WHL by Lm2;
        then Shift(I,1) c= t3 by A23,XBOOLE_1:1;
        then
A24:    Shift(I,1) c= t4 by AMI_1:81;
        set m2=LifeSpan(ProgramPart(t2),t2), t5=Comput(ProgramPart(t4),t4,m2),
l1= (card I + 1);
A25:    IC t3 = 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6=Comput(ProgramPart(t3),t3,m3);
        set t7=Comput(ProgramPart(t3),t3,m3+1);
        card I + 1 < card I + 2 by XREAL_1:8;
        then
A26:    l1 in dom WHL by Th7;
A27:    IExec(I,t) = Result(ProgramPart(t2),t2) +* t | A
by SCMPDS_4:def 8;
A28:    I is_closed_on t by A2,A6,A7,A8;
        then
A29:    I is_closed_on t2 by SCMPDS_6:38;
        I is_halting_on t by A2,A6,A7,A8;
        then
A30:    ProgramPart t2 halts_on t2 by SCMPDS_6:def 3;
A31:     Initialize t2+*pI = t2+*Initialize pI by COMPOS_1:125;
        t2 = Initialize t2+*pI by A19,A31,FUNCT_4:79;
        then ProgramPart(Initialize t2+*pI) halts_on Initialize t2+*pI by A30;
        then
A32:    I is_halting_on t2 by SCMPDS_6:def 3;
        not a in dom Initialize pWHL by SCMPDS_4:31;
        then t3.DataLoc(t3.a,i)= t3.b by A7,A18,FUNCT_4:12
          .= t.b by A15,A18,FUNCT_4:12;
        then
A33:    IC t4 = succ IC t3 by A8,A20,SCMPDS_2:69
          .= (0+1) by A25;
        then
A34:    IC t5=l1 by A1,A19,A32,A29,A22,A24,SCMPDS_7:36;
A35:  (ProgramPart t6)/.IC t6
 = t6.IC t6 by COMPOS_1:38;
 ProgramPart t3 = ProgramPart t4
by AMI_1:123;
 then
A36:    t6=t5 by EXTPRO_1:5;
        then
A37:    CurInstr(ProgramPart t6,t6)=t5.l1
 by A1,A19,A32,A29,A33,A22,A24,A35,SCMPDS_7:36
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=WHL.l1 by A26,A23,GRFUNC_1:8
          .=i2 by Th8;
A38:    DataPart Comput(ProgramPart(t2),t2,m2) = DataPart t5 by A1,A19,A32,A29
,A33,A22,A24,SCMPDS_7:36;
        then
A39:    t5.a=Comput(ProgramPart(t2),t2,m2).a by SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).a by A30,EXTPRO_1:23
          .=s.a by A7,A14,A27,A10,FUNCT_4:12;
A40: ProgramPart t3 = ProgramPart t6
by AMI_1:123;
A41:    t7 = Following(ProgramPart t3,t6) by EXTPRO_1:4
          .= Exec(i2,t6) by A37,A40;
        then IC t7=ICplusConst(t6,0-(card I+1)) by SCMPDS_2:66
          .= 0 by A34,A36,SCMPDS_7:1;
        then
A42:    Initialize t7 +* pWHL=t7 by SCMPDS_7:37;
A43:    now
          let x be Int_position;
          assume
A44:      x in X;
A45: not x in dom (t | A) by A9,SCMPDS_2:53;
          t5.x=Comput(ProgramPart(t2),t2,m2).x by A38,SCMPDS_4:23
            .=(Result(ProgramPart(t2),t2)).x by A30,EXTPRO_1:23
            .=IExec(I,t).x by A27,A45,FUNCT_4:12
            .=t.x by A2,A6,A7,A8,A44
            .=s.x by A6,A44;
          hence t7.x=s.x by A36,A41,SCMPDS_2:66;
        end;
        t5.b=Comput(ProgramPart(t2),t2,m2).b by A38,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).b by A30,EXTPRO_1:23
          .=IExec(I,t).b by A27,A11,FUNCT_4:12;
        then
A46:    t7.b=IExec(I,t).b by A36,A41,SCMPDS_2:66;
A47:    now
          -t7.b < -t.b by A12,A46,XREAL_1:26;
          then
A48:      -t7.b < k+1 by A5,XXREAL_0:2;
          assume -t7.b > k;
          hence contradiction by A48,INT_1:20;
        end;
A49: ProgramPart t4 = ProgramPart t3
by AMI_1:123;
A50:    t7.a=t6.a by A41,SCMPDS_2:66
          .=s.a by A39,A49,EXTPRO_1:5;
        then
A51:    WHL is_closed_on t7 by A4,A43,A47;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m3+1;
            then
A52:        k <= m3 by INT_1:20;
            hereby
              per cases by A52,NAT_1:8;
              suppose
A53:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A13
,A25,EXTPRO_1:3;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A54:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(ProgramPart(t2),t2,kn) as Element
of NAT;
A55: ProgramPart t3 = ProgramPart t4
by AMI_1:123;
                    kn < k by A54,XREAL_1:31;
                    then kn < m2 by A53,XXREAL_0:2;
                    then IC Comput(ProgramPart(t2),t2,kn) + 1 = IC Comput(
ProgramPart(t4),t4,kn) by A1,A19,A32,A29,A33,A22,A24,SCMPDS_7:34;
                    then
A56:                IC Comput(ProgramPart(t3),t3,k) = (lm+1) by A54,A55,
EXTPRO_1:5;
                    IC Comput(ProgramPart(t2),t2,kn) in dom pI by A28,
SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:70;
                    then lm < card I+1 by SCMPDS_5:7;
                    then
A57:                lm+1 <= card I +1 by INT_1:20;
                    card I + 1 < card I + 3 by XREAL_1:8;
                    then lm+1 < card I +3 by A57,XXREAL_0:2;
                    then lm+1 < card pWHL by Lm1;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A56,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A58:            k=m3;
                l1 in dom pWHL by A26,SCMPDS_6:18;
                hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A1,A19,A32
,A29,A33,A22,A24,A36,A58,SCMPDS_7:36;
              end;
            end;
          end;
          suppose
            k >= m3+1;
            then consider nn be Nat such that
A59:        k=m3+1+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
 ProgramPart t3 = ProgramPart t7
by AMI_1:123;
then
            Comput(ProgramPart(t3),t3,k)=
            Comput(ProgramPart(Initialize t7+*pWHL),Initialize t7+*pWHL,
nn) by A42,A59,EXTPRO_1:5;
            hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A51,
SCMPDS_6:def 2;
          end;
        end;
        hence WHL is_closed_on t by SCMPDS_6:def 2;
        WHL is_halting_on t7 by A4,A50,A43,A47;
        then ProgramPart t7 halts_on t7 by A42,SCMPDS_6:def 3;
        then ProgramPart t3 halts_on t7 by AMI_1:123;
        then ProgramPart t3 halts_on t3 by EXTPRO_1:22;
        hence WHL is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
A60: P[0]
  proof
    let t be State of SCMPDS;
    assume -t.b <= 0;
    then -t.b <= -0;
    then
A61: t.b >= 0 by XREAL_1:26;
    assume for x st x in X holds t.x=s.x;
    assume
    t.a=s.a;
    hence thesis by A61,Th9;
  end;
A62: for k being Element of NAT holds P[k] from NAT_1:sch 1(A60,A3);
  per cases;
  suppose
    s.b >= 0;
    hence thesis by Th9;
  end;
  suppose
    s.b <0;
    then reconsider n=-s.b as Element of NAT by INT_1:16;
    ( P[n])& for x be Int_position st x in X holds s.x=s.x by A62;
    hence thesis;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable Program of
SCMPDS , a be Int_position,i be Integer,X be set st s.DataLoc(s.a,i) < 0 & card
I > 0 & (for t be State of SCMPDS st (for x be Int_position st x in X holds t.x
  =s.x) & t.a=s.a & t.DataLoc(s.a,i) < 0 holds IExec(I,t).a=t.a & IExec(I,t).
DataLoc(s.a,i) > t.DataLoc(s.a,i) & I is_closed_on t & I is_halting_on t & for
x be Int_position st x in X holds IExec(I,t).x=t.x) holds IExec(while<0(a,i,I),
  s) =IExec(while<0(a,i,I),IExec(I,s))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i be Integer,X be set;
  set b=DataLoc(s.a,i);
  set WHL=while<0(a,i,I), pWHL = stop WHL,
  s1= Initialize s +* pWHL, ps= ProgramPart s;
A1: Initialize s +* pWHL = s +* Initialize pWHL by COMPOS_1:125;
  set i1=(a,i)>=0_goto (card I+2), i2=goto -(card I+1);
  assume
A2: s.b < 0;
  set Es=IExec(I,s), bj=DataLoc(Es.a,i);
  set sI= Initialize s +* stop I, m1=LifeSpan(ProgramPart(sI),sI)+2,
  s2=Initialize IExec(I,s) +* pWHL,
  m2=LifeSpan(ProgramPart(s2),s2);
A3: Initialize s +* stop I = s +* Initialize stop I by COMPOS_1:125;
A4: Initialize IExec(I,s) +* pWHL = IExec(I,s) +* Initialize pWHL
    by COMPOS_1:125;
  assume
A5: card I > 0;
  assume
A6: for t be State of SCMPDS st (for x st x in X holds t.x=s.x) & t.a=s.
a & t.b < 0 holds IExec(I,t).a=t.a & IExec(I,t).b > t.b & I is_closed_on t & I
  is_halting_on t & for x st x in X holds IExec(I,t).x=t.x;
  then WHL is_halting_on s by A5,Th15;
  then
A7: ProgramPart s1 halts_on s1 by SCMPDS_6:def 3;
A8: Initialize stop I c= sI by A3,FUNCT_4:26;
A9: for x st x in X holds s.x=s.x;
  then I is_halting_on s by A2,A6;
  then
A10: ProgramPart sI halts_on sI by SCMPDS_6:def 3;
A11: Initialize sI+*stop I = sI+*Initialize stop I by COMPOS_1:125;
  sI = Initialize sI+*stop I by A8,A11,FUNCT_4:79;
  then ProgramPart(sI+*Initialize stop I) halts_on
   Initialize sI+*stop I by A10,A11;
  then
A12: I is_halting_on sI by A11,SCMPDS_6:def 3;
A13: Es.a=s.a by A2,A6,A9;
  now
    let t be State of SCMPDS;
    assume that
A14: for x st x in X holds t.x=Es.x and
A15: t.a=Es.a & t.bj < 0;
A16: now
      let x be Int_position;
      assume
A17:  x in X;
      hence t.x=Es.x by A14
        .=s.x by A2,A6,A9,A17;
    end;
    hence IExec(I,t).a=t.a by A6,A13,A15;
    thus IExec(I,t).bj > t.bj by A6,A13,A15,A16;
    thus I is_closed_on t & I is_halting_on t & for x st x in X holds IExec(I,
    t).x=t.x by A6,A13,A15,A16;
  end;
  then WHL is_halting_on Es by A5,Th15;
  then
A18: ProgramPart s2 halts_on s2 by SCMPDS_6:def 3;
  set m0=LifeSpan(ProgramPart(s1),s1);
A19: dom ProgramPart s = A by COMPOS_1:34;
A20: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
  set s4 = Comput(ProgramPart(s1),s1,1);
A21: IC s1 = 0 by SCMPDS_6:21;
A22: WHL = i1 ';' (I ';' i2) by SCMPDS_4:51;
A23: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by EXTPRO_1:4
    .= Following(ProgramPart s1,s1) by EXTPRO_1:3
    .= Exec(i1,s1) by A22,A1,SCMPDS_6:22;
A24: IExec(I,s) | A= (Result(ProgramPart(sI),sI) +* ps) | A
by SCMPDS_4:def 8
    .= ps by A20,FUNCT_4:24;
A25: not b in dom Initialize pWHL by SCMPDS_4:31;
  not a in dom Initialize pWHL by SCMPDS_4:31;
  then s1.DataLoc(s1.a,i)=s1.b by A1,FUNCT_4:12
    .= s.b by A25,A1,FUNCT_4:12;
  then
A26: IC s4 = succ IC s1 by A2,A23,SCMPDS_2:69
    .= (0+1) by A21;
  set mI=LifeSpan(ProgramPart(sI),sI), s5=Comput(ProgramPart(s4),s4,mI), l1= (
card I + 1);
A27: DataPart sI = DataPart s1 by COMPOS_1:138,FUNCT_7:134;
  now
    let a;
    thus sI.a = s1.a by A27,SCMPDS_4:23
      .= s4.a by A23,SCMPDS_2:69;
  end;
  then
A28: DataPart sI = DataPart s4 by SCMPDS_4:23;
  set m3=mI +1;
  set s6=Comput(ProgramPart(s1),s1,m3);
  card I + 1 < card I + 2 by XREAL_1:8;
  then
A29: l1 in dom WHL by Th7;
  set s7=Comput(ProgramPart(s1),s1,m3+1);
A30: IExec(I,s) = Result(ProgramPart(sI),sI) +* s | A by SCMPDS_4:def 8;
  WHL c= Initialize pWHL & Initialize pWHL c= s1 by A1,FUNCT_4:26,SCMPDS_6:17;
  then
A31: WHL c= s1 by XBOOLE_1:1;
  Shift(I,1) c= WHL by Lm2;
  then Shift(I,1) c= s1 by A31,XBOOLE_1:1;
  then
A32: Shift(I,1) c= s4 by AMI_1:81;
  I is_closed_on s by A2,A6,A9;
  then
A33: I is_closed_on sI by SCMPDS_6:38;
  then
A34: IC s5=l1 by A5,A8,A12,A26,A28,A32,SCMPDS_7:36;
A35:  (ProgramPart s6)/.IC s6
 = s6.IC s6 by COMPOS_1:38;
 ProgramPart s1 = ProgramPart s4
by AMI_1:123;
 then
A36: s6=s5 by EXTPRO_1:5;
  then
A37: CurInstr(ProgramPart s6,s6)=s5.l1 by A5,A8,A12,A33,A26,A28,A32,A35,
SCMPDS_7:36
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=WHL.l1 by A29,A31,GRFUNC_1:8
    .=i2 by Th8;
A38: ProgramPart s1 = ProgramPart s6
by AMI_1:123;
A39: s7 = Following(ProgramPart s1,s6) by EXTPRO_1:4
    .= Exec(i2,s6) by A37,A38;
  then IC s7=ICplusConst(s6,0-(card I+1)) by SCMPDS_2:66
    .= 0 by A34,A36,SCMPDS_7:1;
  then
A40: IC s2 =IC Comput(ProgramPart(s1),s1,m1) by SCMPDS_6:21;
A41: DataPart Comput(ProgramPart(sI),sI,mI) = DataPart s5 by A5,A8,A12,A33,A26
,A28,A32,SCMPDS_7:36;
  now
    let x be Int_position;
A42: not x in dom Initialize pWHL by SCMPDS_4:31;
A43: not x in dom (s | A) by A19,SCMPDS_2:53;
    s5.x=Comput(ProgramPart(sI),sI,mI).x by A41,SCMPDS_4:23
      .=(Result(ProgramPart(sI),sI)).x by A10,EXTPRO_1:23
      .=IExec(I,s).x by A30,A43,FUNCT_4:12;
    hence s7.x=IExec(I,s).x by A36,A39,SCMPDS_2:66
      .=s2.x by A42,A4,FUNCT_4:12;
  end;
  then
A44: DataPart s7 = DataPart s2 by SCMPDS_4:23;
A45: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m1)
by AMI_1:123;
  ProgramPart s2
     = ProgramPart (Result(ProgramPart(sI),sI) +* ps +* Initialize pWHL)
              by A4,SCMPDS_4:def 8
    .=ProgramPart (Result(ProgramPart(sI),sI) +* ps) +*
    ProgramPart Initialize pWHL
             by FUNCT_4:75
    .= ps +* ProgramPart Initialize pWHL by A20,FUNCT_4:24
    .= ProgramPart s1 by A1,FUNCT_4:75
    .= ProgramPart Comput(ProgramPart(s1),s1,m1) by AMI_1:123;
  then
A46: Comput(ProgramPart(s1),s1,m1)=s2 by A44,A40,SCMPDS_7:7;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1))=i1
   by A22,A45,A4,SCMPDS_6:22;
  then m0 > m1 by A7,SCMPDS_6:2,31;
  then consider nn be Nat such that
A47: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
A48: ProgramPart s1 = ProgramPart s2
by A46,AMI_1:123;
  Comput(ProgramPart(s1),s1,m1+m2) = Comput(ProgramPart(s1),s2,m2) by A46,
EXTPRO_1:5;
  then CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,m1+m2))
   = halt SCMPDS by A18,A48,EXTPRO_1:def 14;
  then m1 + m2 >= m0 by A7,EXTPRO_1:def 14;
  then
A49: m2 >= nn by A47,XREAL_1:8;
A50: Comput(ProgramPart(s1),s1,m0) = Comput(ProgramPart(s1),s2,nn) by A46,A47,
EXTPRO_1:5;
  then CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,nn))
   =halt SCMPDS by A7,A48,EXTPRO_1:def 14;
  then nn >= m2 by A18,EXTPRO_1:def 14;
  then nn=m2 by A49,XXREAL_0:1;
  then Result(ProgramPart(s1),s1) = Comput(ProgramPart(s2),s2,m2) by A7,A50,A48
,
EXTPRO_1:23;
  hence IExec(WHL,s) = Comput(ProgramPart(s2),s2,m2) +* ps by SCMPDS_4:def 8
    .= Result(ProgramPart(s2),s2) +* IExec(I,s) | A by A18,A24,EXTPRO_1:23
    .= IExec(WHL,IExec(I,s)) by SCMPDS_4:def 8;
end;

begin :: The construction and basic properties of while>0 program

:: while (a,i)>0 do I

definition
  let a be Int_position, i be Integer,I be Program of SCMPDS;
  func while>0(a,i,I) -> Program of SCMPDS equals
  (a,i)<=0_goto (card I +2)
  ';' I ';' goto -(card I+1);
  coherence;
end;

registration
  let I be shiftable Program of SCMPDS,a be Int_position,i be Integer;
  cluster while>0(a,i,I) -> shiftable;
  correctness
  proof
    set WHL=while>0(a,i,I), i1= (a,i)<=0_goto (card I +2);
    reconsider PF= Load i1 ';' I as shiftable Program of SCMPDS;
A1: PF=i1 ';' I by SCMPDS_4:def 4;
    then card PF=card I + 1 by SCMPDS_6:15;
    then card PF+ -(card I+1) =0;
    hence thesis by A1,SCMPDS_4:78;
  end;
end;

registration
  let I be halt-free Program of SCMPDS,a be Int_position,i be Integer;
  cluster while>0(a,i,I) -> halt-free;
  correctness;
end;

theorem Th17:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
  card while>0(a,i,I)= card I +2
proof
  let a be Int_position,i be Integer, I be Program of SCMPDS;
  set i1=(a,i)<=0_goto (card I +2);
  set I4=i1 ';' I;
  thus card while>0(a,i,I)=card I4+1 by SCMP_GCD:8
    .=card I +1 +1 by SCMPDS_6:15
    .=card I + 2;
end;

Lm3: for a be Int_position,i be Integer,I be Program of SCMPDS holds card stop
while>0(a,i,I)= card I+3

proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  thus card stop while>0(a,i,I)= card while>0(a,i,I) +1 by SCMPDS_5:7
    .= card I +2+1 by Th17
    .= card I + 3;
end;

theorem Th18:
  for a be Int_position,i be Integer,m be Element of NAT,I be
  Program of SCMPDS holds m < card I+2 iff  m in dom while>0(a,i,I)
proof
  let a be Int_position,i be Integer,m be Element of NAT, I be Program of
  SCMPDS;
  card while>0(a,i,I)=card I + 2 by Th17;
  hence thesis by AFINSQ_1:70;
end;

theorem Th19:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
while>0(a,i,I). 0=(a,i)<=0_goto (card I +2) & while>0(a,i,I). (card
  I+1)=goto -(card I+1)
proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  set i1=(a,i)<=0_goto (card I +2), i2=goto -(card I+1);
  set I4=i1 ';' I;
  set J5=I ';' i2;
  set WHL=while>0(a,i,I);
  WHL=i1 ';' J5 by SCMPDS_4:51;
  hence WHL. 0=i1 by SCMPDS_6:16;
  card I4=card I+1 by SCMPDS_6:15;
  hence thesis by SCMP_GCD:10;
end;

theorem Th20:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer st s.DataLoc(s.a,i) <= 0 holds while>0(a,i,I)
  is_closed_on s & while>0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer;
  set d1=DataLoc(s.a,i);
  assume
A1: s.d1 <= 0;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
  set WHL=while>0(a,i,I), pWHL=stop WHL,
  s3 = Initialize s +* pWHL
  , s4 = Comput(ProgramPart(s3),s3,1);
A2: Initialize s +* pWHL = s +* Initialize pWHL by COMPOS_1:125;
A3: IC s3 = 0 by SCMPDS_6:21;
A4: not d1 in dom Initialize pWHL by SCMPDS_4:31;
  not a in dom Initialize pWHL by SCMPDS_4:31;
  then
A5: s3.DataLoc(s3.a,i)=s3.d1 by A2,FUNCT_4:12
    .= s.d1 by A4,A2,FUNCT_4:12;
A6: WHL = i1 ';' (I ';' i2 ) by SCMPDS_4:51;
  Comput(ProgramPart(s3),s3,0+1) = Following(ProgramPart s3,
  Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i1,s3) by A6,A2,SCMPDS_6:22;
  then
A7: IC s4 = ICplusConst(s3,(card I+2)) by A1,A5,SCMPDS_2:68
    .= (0+(card I+2)) by A3,SCMPDS_6:23;
A8: card WHL=card I+2 by Th17;
  then
A9: (card I+2) in dom pWHL by SCMPDS_6:25;
A10:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
  Initialize pWHL c= s3 by A2,FUNCT_4:26;
  then pWHL c= s4 by AMI_1:81,COMPOS_1:132;
  then s4.(card I+2) = pWHL.(card I+2) by A9,GRFUNC_1:8
    .=halt SCMPDS by A8,SCMPDS_6:25;
  then
A11: CurInstr(ProgramPart s4,s4) = halt SCMPDS by A7,A10;
A12: ProgramPart s4 = ProgramPart s3
by AMI_1:123;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:20;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pWHL
      by A9,A7,A11,A12,EXTPRO_1:6;
    end;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pWHL by A3,COMPOS_1:135;
    end;
  end;
  hence WHL is_closed_on s by SCMPDS_6:def 2;
  ProgramPart s3 halts_on s3 by A11,A12,EXTPRO_1:30;
  hence thesis by SCMPDS_6:def 3;
end;

theorem Th21:
  for s being State of SCMPDS,I being Program of SCMPDS,a,c being
Int_position, i being Integer st s.DataLoc(s.a,i) <= 0 holds IExec(while>0(a,i,
  I),s) = s +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a,c be Int_position, i be
  Integer;
  set d1=DataLoc(s.a,i);
  set WHL=while>0(a,i,I), pWHL=stop WHL,
  s3 = Initialize s +* pWHL
  , s4 = Comput(ProgramPart(s3),s3,1), i1=(a,i)<=0_goto (card I+2), i2=goto -(
card I+1);
A1: Initialize s +* pWHL = s +* Initialize pWHL by COMPOS_1:125;
  set SAl=Start-At((card I+2),SCMPDS);
A2: IC s3 = 0 by SCMPDS_6:21;
A3: WHL = i1 ';' (I ';' i2) by SCMPDS_4:51;
A4: not d1 in dom Initialize pWHL by SCMPDS_4:31;
  not a in dom Initialize pWHL by SCMPDS_4:31;
  then
A5: s3.DataLoc(s3.a,i)=s3.d1 by A1,FUNCT_4:12
    .= s.d1 by A4,A1,FUNCT_4:12;
A6: Comput(ProgramPart(s3),s3,0+1) =
Following(ProgramPart s3,Comput(ProgramPart(s3),s3,0)
)
 by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i1,s3) by A3,A1,SCMPDS_6:22;
  Initialize pWHL c= s3 by A1,FUNCT_4:26;
  then
A7: pWHL c= s4 by AMI_1:81,COMPOS_1:132;
A8: IExec(WHL,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
  assume s.d1 <= 0;
  then
A9: IC s4 = ICplusConst(s3,(card I+2)) by A6,A5,SCMPDS_2:68
    .= (0+(card I+2)) by A2,SCMPDS_6:23;
A10:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
A11: ProgramPart s4 = ProgramPart s3
by AMI_1:123;
A12: card WHL=card I+2 by Th17;
  then (card I+2) in dom pWHL by SCMPDS_6:25;
  then s4.(card I+2) = pWHL.(card I+2) by A7,GRFUNC_1:8
    .=halt SCMPDS by A12,SCMPDS_6:25;
  then
A13: CurInstr(ProgramPart s4,s4) = halt SCMPDS by A9,A10;
  then
A14: ProgramPart s3 halts_on s3 by A11,EXTPRO_1:30;
A15: CurInstr(ProgramPart s3,s3) = i1 by A3,A1,SCMPDS_6:22;
  now
    let l be Element of NAT;
A16: Comput(ProgramPart(s3),s3,0) = s3 by EXTPRO_1:3;
    assume l < 0+1;
    then l=0 by NAT_1:13;
    then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
     = CurInstr(ProgramPart s3,s3) by A16;
    hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) <>
     halt SCMPDS by A15,SCMPDS_6:30;
  end;
  then for l be Element of NAT st
   CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan(ProgramPart(s3),s3) = 1 by A13,A14,A11,EXTPRO_1:def 14;
  then
A17: s4 = Result(ProgramPart(s3),s3) by A14,EXTPRO_1:23;
A18: dom ProgramPart s = A by COMPOS_1:34;
A19: now
    let x be set;
A20: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A21: x in dom IExec(WHL,s);
    per cases by A21,SCMPDS_4:20;
    suppose
A22:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A23:  not x in dom SAl by A20,TARSKI:def 1;
      not x in dom (s | A) by A18,A22,SCMPDS_2:53;
      hence IExec(WHL,s).x = s4.x by A17,A8,FUNCT_4:12
        .= s3.x by A6,A22,SCMPDS_2:68
        .= s.x by A22,SCMPDS_5:19
        .= (s +* SAl).x by A23,FUNCT_4:12;
    end;
    suppose
A24:  x = IC SCMPDS;
      not x in dom (s | A) by A18,A24,COMPOS_1:3;
      hence IExec(WHL,s).x = (card I + 2) by A9,A17,A8,A24,FUNCT_4:12
        .= (s +* SAl).x by A24,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(WHL,s).x = (s +* SAl).x by SCMPDS_6:27;
    end;
  end;
  dom IExec(WHL,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A19,FUNCT_1:9;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, i being Integer st s.DataLoc(s.a,i) <= 0 holds IC IExec(while>0(a
  ,i,I),s) =  (card I + 2)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer;
  assume s.DataLoc(s.a,i) <= 0;
  then IExec(while>0(a,i,I),s) =s +* Start-At((card I+2),SCMPDS) by Th21;
  hence thesis by FUNCT_4:121;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS, a,b being
Int_position , i being Integer st s.DataLoc(s.a,i) <= 0 holds IExec(while>0(a,i
  ,I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, i be
  Integer;
  assume s.DataLoc(s.a,i) <= 0;
  then
A1: IExec(while>0(a,i,I),s) = s +* Start-At((card I+2),SCMPDS) by Th21;
  not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

Lm4: for I being Program of SCMPDS,a being Int_position,i being Integer holds
Shift(I,1) c= while>0(a,i,I)

proof
  let I be Program of SCMPDS,a be Int_position,i be Integer;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
A1: while>0(a,i,I) = i1 ';' I ';' Load i2 by SCMPDS_4:def 5
    .= Load i1 ';' I ';' Load i2 by SCMPDS_4:def 4;
  card Load i1=1 by SCMPDS_5:6;
  hence thesis by A1,SCMPDS_7:16;
end;

scheme
  WhileGHalt { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
  P[State of SCMPDS]}: (F(s())=F(s()) or P[s()]) & while>0(a(),i(),I())
  is_closed_on s() & while>0(a(),i(),I()) is_halting_on s()
provided
A1: card I() > 0 and
A2: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.
DataLoc(s().a(),i()) <= 0 and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) > 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
]
proof
  set i1=(a(),i())<=0_goto (card I()+2), i2=goto -(card I()+1);
  set WHL=while>0(a(),i(),I()), pWHL=stop WHL,
  pI=stop I();
  set b=DataLoc(s().a(),i());
  defpred Q[Element of NAT] means for t be State of SCMPDS st F(Dstate(t)) <=
$1 & P[Dstate t] & t.a()=s().a() holds WHL is_closed_on t & WHL is_halting_on t
  ;
A5: for k be Element of NAT st Q[k] holds Q[k + 1]
  proof
    let k be Element of NAT;
    assume
A6: Q[k];
    now
      let t be State of SCMPDS;
      assume
A7:   F(Dstate(t)) <= k+1;
      assume
A8:   P[Dstate t];
      assume
A9:   t.a()=s().a();
      per cases;
      suppose
        t.b <= 0;
        hence WHL is_closed_on t & WHL is_halting_on t by A9,Th20;
      end;
      suppose
A10:    t.b > 0;
A11:    dom ProgramPart t = A by COMPOS_1:34;
A12:  not a() in dom (t | A) by A11,SCMPDS_2:53;
A13:    IExec(I(),t).a()=t.a() by A4,A8,A9,A10;
A14:     0 in dom pWHL by COMPOS_1:135;
A15:    dom ProgramPart t = A by COMPOS_1:34;
A16:    not b in dom Initialize pWHL by SCMPDS_4:31;
A17:    WHL = i1 ';' (I() ';' i2) by SCMPDS_4:51;
A18:     Initialize t +* pI = t +* Initialize pI by COMPOS_1:125;
A19:     Initialize t +* pWHL = t +* Initialize pWHL by COMPOS_1:125;
        set t2 = Initialize t +* pI, t3 = Initialize t +* pWHL,
        t4 = Comput(ProgramPart(t3),t3,1);
A20:    Initialize pI c= t2 by A18,FUNCT_4:26;
        set m2=LifeSpan(ProgramPart(t2),t2), t5=Comput(ProgramPart(t4),t4,m2),
l1= (card I() + 1
);
A21:    IC t3 = 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6=Comput(ProgramPart(t3),t3,m3);
        set t7=Comput(ProgramPart(t3),t3,m3+1);
        card I() + 1 < card I() + 2 by XREAL_1:8;
        then
A22:    l1 in dom WHL by Th18;
        WHL c= Initialize pWHL & Initialize pWHL c= t3
        by A19,FUNCT_4:26,SCMPDS_6:17;
        then
A23:    WHL c= t3 by XBOOLE_1:1;
        Shift(I(),1) c= WHL by Lm4;
        then Shift(I(),1) c= t3 by A23,XBOOLE_1:1;
        then
A24:    Shift(I(),1) c= t4 by AMI_1:81;
A25:    Comput(ProgramPart(t3),t3,0+1) = Following(ProgramPart t3,
Comput(ProgramPart(t3),t3,0)) by EXTPRO_1:4
          .= Following(ProgramPart t3,t3) by EXTPRO_1:3
          .= Exec(i1,t3) by A17,A19,SCMPDS_6:22;
A26:    DataPart t2 = DataPart t3 by COMPOS_1:138,FUNCT_7:134;
        now
          let a;
          thus t2.a = t3.a by A26,SCMPDS_4:23
            .= t4.a by A25,SCMPDS_2:68;
        end;
        then
A27:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
        I() is_halting_on t by A4,A8,A9,A10;
        then
A28:    ProgramPart t2 halts_on t2 by SCMPDS_6:def 3;
A29:     Initialize t2+*pI = t2+*Initialize pI by COMPOS_1:125;
        t2 = Initialize t2+*pI by A20,A29,FUNCT_4:79;
        then ProgramPart(Initialize t2+*pI) halts_on Initialize t2+*pI by A28;
        then
A30:    I() is_halting_on t2 by SCMPDS_6:def 3;
A31:    IExec(I(),t) = Result(ProgramPart(t2),t2) +* t | A
by SCMPDS_4:def 8;
A32:    P[Dstate(IExec(I(),t))] by A4,A8,A9,A10;
A33:    I() is_closed_on t by A4,A8,A9,A10;
        then
A34:    I() is_closed_on t2 by SCMPDS_6:38;
        not a() in dom Initialize pWHL by SCMPDS_4:31;
        then t3.DataLoc(t3.a(),i())= t3.b by A9,A19,FUNCT_4:12
          .= t.b by A16,A19,FUNCT_4:12;
        then
A35:    IC t4 = succ IC t3 by A10,A25,SCMPDS_2:68
          .= (0+1) by A21;
        then
A36:    IC t5=l1 by A1,A20,A30,A34,A27,A24,SCMPDS_7:36;
A37:  (ProgramPart t6)/.IC t6
 = t6.IC t6 by COMPOS_1:38;
 ProgramPart t3 = ProgramPart t4
by AMI_1:123;
 then
A38:    t6=t5 by EXTPRO_1:5;
        then
A39:    CurInstr(ProgramPart t6,t6)=t5.l1
 by A1,A20,A30,A34,A35,A27,A24,A37,SCMPDS_7:36
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=WHL.l1 by A22,A23,GRFUNC_1:8
          .=i2 by Th19;
A40: ProgramPart t3 = ProgramPart t6
by AMI_1:123;
A41:    t7 = Following(ProgramPart t3,t6) by EXTPRO_1:4
          .= Exec(i2,t6) by A39,A40;
        then IC t7=ICplusConst(t6,0-(card I()+1)) by SCMPDS_2:66
          .= 0 by A36,A38,SCMPDS_7:1;
        then
A42:    Initialize t7 +* pWHL=t7 by SCMPDS_7:37;
A43:    DataPart Comput(ProgramPart(t2),t2,m2) = DataPart t5 by A1,A20,A30,A34
,A35,A27,A24,SCMPDS_7:36;
        then
A44:    DataPart t5 =DataPart Result(ProgramPart(t2),t2) by A28,EXTPRO_1:23
          .= DataPart(Result(ProgramPart(t2),t2) +* t | A) by A15,AMI_2:29
,FUNCT_4:76,SCMPDS_2:100
          .=DataPart IExec(I(),t) by SCMPDS_4:def 8;
        InsCode i2=0 by SCMPDS_2:21;
        then InsCode i2 in {0,4,5,6} by ENUMSET1:def 2;
        then
A45:    Dstate(t7)=Dstate(t6) by A41,Th3
          .=Dstate(IExec(I(),t)) by A44,A38,Th2;
A46:    now
          F(Dstate(IExec(I(),t))) < F(Dstate(t)) by A4,A8,A9,A10;
          then
A47:      F(Dstate(t7)) < k+1 by A7,A45,XXREAL_0:2;
          assume F(Dstate(t7)) > k;
          hence contradiction by A47,INT_1:20;
        end;
A48:    t5.a()=Comput(ProgramPart(t2),t2,m2).a() by A43,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).a() by A28,EXTPRO_1:23
          .=s().a() by A9,A13,A31,A12,FUNCT_4:12;
A49: ProgramPart t4 = ProgramPart t3
by AMI_1:123;
A50:    t7.a()=t6.a() by A41,SCMPDS_2:66
          .=s().a() by A48,A49,EXTPRO_1:5;
        then
A51:    WHL is_closed_on t7 by A6,A32,A45,A46;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m3+1;
            then
A52:        k <= m3 by INT_1:20;
            hereby
              per cases by A52,NAT_1:8;
              suppose
A53:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A14
,A21,EXTPRO_1:3;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A54:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(ProgramPart(t2),t2,kn) as Element
of NAT;
A55: ProgramPart t3 = ProgramPart t4
by AMI_1:123;
                    kn < k by A54,XREAL_1:31;
                    then kn < m2 by A53,XXREAL_0:2;
                    then IC Comput(ProgramPart(t2),t2,kn) + 1 = IC Comput(
ProgramPart(t4),t4,kn) by A1,A20,A30,A34,A35,A27,A24,SCMPDS_7:34;
                    then
A56:                IC Comput(ProgramPart(t3),t3,k) = (lm+1) by A54,A55,
EXTPRO_1:5;
                    IC Comput(ProgramPart(t2),t2,kn) in dom pI by A33,
SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:70;
                    then lm < card I()+1 by SCMPDS_5:7;
                    then
A57:                lm+1 <= card I() +1 by INT_1:20;
                    card I() + 1 < card I() + 3 by XREAL_1:8;
                    then lm+1 < card I() +3 by A57,XXREAL_0:2;
                    then lm+1 < card pWHL by Lm3;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A56,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A58:            k=m3;
                l1 in dom pWHL by A22,SCMPDS_6:18;
                hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A1,A20,A30
,A34,A35,A27,A24,A38,A58,SCMPDS_7:36;
              end;
            end;
          end;
          suppose
            k >= m3+1;
            then consider nn be Nat such that
A59:        k=m3+1+nn by NAT_1:10;
A60: ProgramPart t3 = ProgramPart t7
by AMI_1:123;
A61:        nn in NAT by ORDINAL1:def 13;
            then Comput(ProgramPart(t3),t3,k)=
            Comput(ProgramPart(Initialize t7+*pWHL),Initialize t7+*pWHL,nn)
             by A42,A59,A60,EXTPRO_1:5
;
            hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A51,A61,
SCMPDS_6:def 2;
          end;
        end;
        hence WHL is_closed_on t by SCMPDS_6:def 2;
        WHL is_halting_on t7 by A6,A32,A50,A45,A46;
        then ProgramPart t7 halts_on t7 by A42,SCMPDS_6:def 3;
        then ProgramPart t3 halts_on t7 by AMI_1:123;
        then ProgramPart t3 halts_on t3 by EXTPRO_1:22;
        hence WHL is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  set n=F(Dstate s());
  thus F(s())=F(s()) or P[s()];
A62: Q[0]
  proof
    let t be State of SCMPDS;
    assume that
A63: F(Dstate(t)) <= 0 and
A64: P[Dstate t] and
A65: t.a()=s().a();
    F(Dstate(t))=0 by A63;
    then t.b <= 0 by A2,A64;
    hence thesis by A65,Th20;
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A62,A5);
  then Q[n];
  hence thesis by A3;
end;

scheme
  WhileGExec { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
P[State of SCMPDS]}: (F(s())=F(s()) or P[s()]) & IExec(while>0(a(),i(),I()),s()
  ) = IExec(while>0(a(),i(),I()),IExec(I(),s()))
provided
A1: card I() > 0 and
A2: s().DataLoc(s().a(),i()) > 0 and
A3: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.
DataLoc(s().a(),i()) <= 0 and
A4: P[Dstate s()] and
A5: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) > 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
]
proof
  set WHL=while>0(a(),i(),I()),
      pWHL = stop WHL,
      s1= Initialize s() +* pWHL, ps= ProgramPart s();
  set sI= Initialize s() +* stop I(), m1=LifeSpan(ProgramPart(sI),sI)+2,
  s2=Initialize IExec(I(),s()) +* pWHL,
  m2=LifeSpan(ProgramPart s2,s2);
A6: Initialize s() +* pWHL = s() +* Initialize pWHL by COMPOS_1:125;
A7: Initialize s() +* stop I() = s() +* Initialize stop I() by COMPOS_1:125;
A8: Initialize IExec(I(),s()) +* pWHL = IExec(I(),s()) +* Initialize pWHL
    by COMPOS_1:125;
A9: P[Dstate s()] by A4;
A10: Initialize stop I() c= sI by A7,FUNCT_4:26;
  I() is_closed_on s() by A2,A4,A5;
  then
A11: I() is_closed_on sI by SCMPDS_6:38;
  I() is_halting_on s() by A2,A4,A5;
  then
A12: ProgramPart sI halts_on sI by SCMPDS_6:def 3;
A13: Initialize sI+*stop I() = sI+*Initialize stop I() by COMPOS_1:125;
  sI = Initialize sI+*stop I() by A10,A13,FUNCT_4:79;
  then ProgramPart(Initialize sI+*stop I()) halts_on
  Initialize sI+*stop I() by A12;
  then
A14: I() is_halting_on sI by SCMPDS_6:def 3;
  set Es=IExec(I(),s()), bj=DataLoc(Es.a(),i());
  deffunc U(State of SCMPDS) = F($1);
A15: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(s().
  a(),i()) > 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & U(Dstate IExec(I(),t)) < U(Dstate t) & P[Dstate(IExec(I(),t))
  ] by A5;
A16: for t be State of SCMPDS st P[Dstate t] & U(Dstate(t))=0 holds t.DataLoc
  (s().a(),i()) <= 0 by A3;
  (U(s())=U(s()) or P[s()]) & WHL is_closed_on s() & WHL is_halting_on s()
  from WhileGHalt(A1,A16,A9,A15);
  then
A17: ProgramPart s1 halts_on s1 by SCMPDS_6:def 3;
  deffunc U(State of SCMPDS) = F($1);
A18: IExec(I(), s()).a()=s().a() by A2,A4,A5;
  then
A19: for t be State of SCMPDS st P[Dstate t] & U(Dstate(t))=0 holds t.bj <=
  0 by A3;
A20: for t be State of SCMPDS st P[Dstate t] & t.a()=Es.a() & t.bj > 0 holds
  IExec(I(),t).a()=t.a() & I() is_closed_on t & I() is_halting_on t & U(Dstate
  IExec(I(),t)) < U(Dstate t) & P[Dstate(IExec(I(),t))] by A5,A18;
A21: P[Dstate Es] by A2,A4,A5;
  (U(Es)=U(Es) or P[Es]) & WHL is_closed_on Es & WHL is_halting_on Es
  from WhileGHalt(A1,A19,A21,A20);
  then
A22: ProgramPart s2 halts_on s2 by SCMPDS_6:def 3;
  set s4 = Comput(ProgramPart(s1),s1,1);
  set i1=(a(),i())<=0_goto (card I()+2), i2=goto -(card I()+1);
  set b=DataLoc(s().a(),i());
A23: WHL = i1 ';' (I() ';' i2) by SCMPDS_4:51;
  set mI=LifeSpan(ProgramPart(sI),sI), s5=Comput(ProgramPart(s4),s4,mI), l1= (
card I() + 1);
A24: IC s1 = 0 by SCMPDS_6:21;
A25: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by EXTPRO_1:4
    .= Following(ProgramPart s1,s1) by EXTPRO_1:3
    .= Exec(i1,s1) by A23,A6,SCMPDS_6:22;
A26: DataPart sI = DataPart s1 by COMPOS_1:138,FUNCT_7:134;
  now
    let a;
    thus sI.a = s1.a by A26,SCMPDS_4:23
      .= s4.a by A25,SCMPDS_2:68;
  end;
  then
A27: DataPart sI = DataPart s4 by SCMPDS_4:23;
  set m3=mI +1;
  set s6=Comput(ProgramPart(s1),s1,m3);
  card I() + 1 < card I() + 2 by XREAL_1:8;
  then
A28: l1 in dom WHL by Th18;
  thus F(s())=F(s()) or P[s()];
  set m0=LifeSpan(ProgramPart(s1),s1);
A29: dom ps = dom s() /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
A30: IExec(I(),s()) | A= (Result(ProgramPart(sI),sI) +* ps) | A by
SCMPDS_4:def 8
    .= ps by A29,FUNCT_4:24;
  set s7=Comput(ProgramPart(s1),s1,m3+1);
A31: IExec(I(),s()) = Result(ProgramPart(sI),sI) +* s() | A
by SCMPDS_4:def 8;
A32: dom ProgramPart s() = A by COMPOS_1:34;
  WHL c= Initialize pWHL & Initialize pWHL c= s1
  by A6,FUNCT_4:26,SCMPDS_6:17;
  then
A33: WHL c= s1 by XBOOLE_1:1;
  Shift(I(),1) c= WHL by Lm4;
  then Shift(I(),1) c= s1 by A33,XBOOLE_1:1;
  then
A34: Shift(I(),1) c= s4 by AMI_1:81;
  s1.DataLoc(s1.a(),i())=s1.b by SCMPDS_5:19
    .= s().b by SCMPDS_5:19;
  then
A35: IC s4 = succ IC s1 by A2,A25,SCMPDS_2:68
    .= (0+1) by A24;
  then
A36: IC s5=l1 by A1,A10,A14,A11,A27,A34,SCMPDS_7:36;
A37:  (ProgramPart s6)/.IC s6
 = s6.IC s6 by COMPOS_1:38;
 ProgramPart s1 = ProgramPart s4
by AMI_1:123;
 then
A38: s6=s5 by EXTPRO_1:5;
  then
A39: CurInstr(ProgramPart s6,s6)=s5.l1 by A1,A10,A14,A11,A35,A27,A34,A37,
SCMPDS_7:36
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=WHL.l1 by A28,A33,GRFUNC_1:8
    .=i2 by Th19;
A40: ProgramPart s1 = ProgramPart s6
by AMI_1:123;
A41: s7 = Following(ProgramPart s1,s6) by EXTPRO_1:4
    .= Exec(i2,s6) by A39,A40;
  then IC s7=ICplusConst(s6,0-(card I()+1)) by SCMPDS_2:66
    .= 0 by A36,A38,SCMPDS_7:1;
  then
A42: IC s2 =IC Comput(ProgramPart(s1),s1,m1) by SCMPDS_6:21;
A43: DataPart Comput(ProgramPart(sI),sI,mI) = DataPart s5 by A1,A10,A14,A11,A35
,A27,A34,SCMPDS_7:36;
  now
    let x be Int_position;
A44: not x in dom Initialize pWHL by SCMPDS_4:31;
A45: not x in dom (s() | A) by A32,SCMPDS_2:53;
    s5.x=Comput(ProgramPart(sI),sI,mI).x by A43,SCMPDS_4:23
      .=(Result(ProgramPart(sI),sI)).x by A12,EXTPRO_1:23
      .=IExec(I(),s()).x by A31,A45,FUNCT_4:12;
    hence s7.x=IExec(I(),s()).x by A38,A41,SCMPDS_2:66
      .=s2.x by A44,A8,FUNCT_4:12;
  end;
  then
A46: DataPart s7 = DataPart s2 by SCMPDS_4:23;
A47: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m1)
by AMI_1:123;
  ProgramPart s2= ProgramPart (Result(ProgramPart(sI),sI) +* ps +*
  Initialize pWHL) by A8,SCMPDS_4:def 8
    .=ProgramPart (Result(ProgramPart(sI),sI) +* ps)+*
    ProgramPart Initialize pWHL
           by FUNCT_4:75
    .= ps +* ProgramPart Initialize pWHL by A29,FUNCT_4:24
    .= ProgramPart s1 by A6,FUNCT_4:75
    .= ProgramPart Comput(ProgramPart(s1),s1,m1) by AMI_1:123;
  then
A48: Comput(ProgramPart(s1),s1,m1)=s2 by A46,A42,SCMPDS_7:7;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1))=i1
   by A23,A47,A8,SCMPDS_6:22;
  then m0 > m1 by A17,SCMPDS_6:2,30;
  then consider nn be Nat such that
A49: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
A50: ProgramPart s1 = ProgramPart s2
by A48,AMI_1:123;
  Comput(ProgramPart(s1),s1,m1+m2) = Comput(ProgramPart(s1),s2,m2) by A48,
EXTPRO_1:5;
  then CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,m1+m2))
   = halt SCMPDS by A22,A50,EXTPRO_1:def 14;
  then m1 + m2 >= m0 by A17,EXTPRO_1:def 14;
  then
A51: m2 >= nn by A49,XREAL_1:8;
A52: Comput(ProgramPart(s1),s1,m0) = Comput(ProgramPart(s1),s2,nn) by A48,A49,
EXTPRO_1:5;
  then CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,nn))
   =halt SCMPDS by A17,A50,EXTPRO_1:def 14;
  then nn >= m2 by A22,EXTPRO_1:def 14;
  then nn=m2 by A51,XXREAL_0:1;
  then Result(ProgramPart(s1),s1) = Comput(ProgramPart(s2),s2,m2) by A17,A52,
A50,
EXTPRO_1:23;
  hence IExec(WHL,s()) = Comput(ProgramPart(s2),s2,m2) +* ps
  by SCMPDS_4:def 8
    .= Result(ProgramPart(s2),s2) +* IExec(I(),s()) | A by A22,A30,EXTPRO_1:23
    .= IExec(WHL,IExec(I(),s())) by SCMPDS_4:def 8;
end;

theorem Th24:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a be Int_position,i,c be Integer,X,Y be set, f being
  Function of product the Object-Kind of SCMPDS,NAT st card I > 0 & ( for t be
State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i) <= 0 ) & (for x st x in
  X holds s.x >= c+s.DataLoc(s.a,i)) & (for t be State of SCMPDS st (for x st x
in X holds t.x >= c+t.DataLoc(s.a,i)) & (for x st x in Y holds t.x=s.x) & t.a=s
  .a & t.DataLoc(s.a,i) > 0 holds IExec(I,t).a=t.a & I is_closed_on t & I
  is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & (for x st x in X holds
IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i)) & for x st x in Y holds IExec(I,t)
  .x=t.x) holds while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,i,c be Integer,X,Y be set, f be Function of product the
  Object-Kind of SCMPDS,NAT;
  set b=DataLoc(s.a,i);
  set WHL=while>0(a,i,I), pWHL=stop WHL,
  pI=stop I;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
  assume
A1: card I > 0;
  defpred P[Element of NAT] means for t be State of SCMPDS st f.Dstate(t) <=
$1 & (for x st x in X holds t.x >= c+t.b) & (for x st x in Y holds t.x=s.x) & t
  .a=s.a holds WHL is_closed_on t & WHL is_halting_on t;
  assume
A2: for t be State of SCMPDS st f.Dstate(t)=0 holds t.b <= 0;
  assume
A3: for x st x in X holds s.x >= c+s.b;
  assume
A4: for t be State of SCMPDS st (for x st x in X holds t.x >= c+t.b) & (
  for x st x in Y holds t.x=s.x) & t.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & (for
  x st x in X holds IExec(I,t).x >= c+IExec(I,t).b ) & for x st x in Y holds
  IExec(I,t).x=t.x;
A5: for k be Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A6: P[k];
    now
      let t be State of SCMPDS;
      assume
A7:   f.Dstate(t) <= k+1;
      assume
A8:   for x st x in X holds t.x >= c+t.b;
      assume
A9:   for x st x in Y holds t.x=s.x;
      assume
A10:  t.a=s.a;
      per cases;
      suppose
        t.b <= 0;
        hence WHL is_closed_on t & WHL is_halting_on t by A10,Th20;
      end;
      suppose
A11:    t.b > 0;
A12:    dom ProgramPart t = A by COMPOS_1:34;
A13: not a in dom (t | A) by A12,SCMPDS_2:53;
A14:    IExec(I,t).a=t.a by A4,A8,A9,A10,A11;
A15:     0 in dom pWHL by COMPOS_1:135;
A16:    dom ProgramPart t = A by COMPOS_1:34;
A17:    not b in dom Initialize pWHL by SCMPDS_4:31;
A18:    WHL = i1 ';' (I ';' i2) by SCMPDS_4:51;
        set t2 = Initialize t +* pI, t3 = Initialize t +* pWHL,
        t4 = Comput(ProgramPart(t3),t3,1);
A19:     Initialize t +* pI = t +* Initialize pI by COMPOS_1:125;
A20:     Initialize t +* pWHL = t +* Initialize pWHL by COMPOS_1:125;
A21:    Initialize pI c= t2 by A19,FUNCT_4:26;
A22:    Comput(ProgramPart(t3),t3,0+1) = Following(ProgramPart t3,
Comput(ProgramPart(t3),t3,0)) by EXTPRO_1:4
          .= Following(ProgramPart t3,t3) by EXTPRO_1:3
          .= Exec(i1,t3) by A18,A20,SCMPDS_6:22;
A23:    DataPart t2 = DataPart t3 by COMPOS_1:138,FUNCT_7:134;
        now
          let a;
          thus t2.a = t3.a by A23,SCMPDS_4:23
            .= t4.a by A22,SCMPDS_2:68;
        end;
        then
A24:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
        WHL c= Initialize pWHL & Initialize pWHL c= t3
        by A20,FUNCT_4:26,SCMPDS_6:17;
        then
A25:    WHL c= t3 by XBOOLE_1:1;
        Shift(I,1) c= WHL by Lm4;
        then Shift(I,1) c= t3 by A25,XBOOLE_1:1;
        then
A26:    Shift(I,1) c= t4 by AMI_1:81;
A27:    IExec(I,t) = Result(ProgramPart(t2),t2) +* t | A
by SCMPDS_4:def 8;
        set m2=LifeSpan(ProgramPart(t2),t2), t5=Comput(ProgramPart(t4),t4,m2),
l1= (card I + 1);
A28:    IC t3 = 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6=Comput(ProgramPart(t3),t3,m3);
        set t7=Comput(ProgramPart(t3),t3,m3+1);
        card I + 1 < card I + 2 by XREAL_1:8;
        then
A29:    l1 in dom WHL by Th18;
A30:    I is_closed_on t by A4,A8,A9,A10,A11;
        then
A31:    I is_closed_on t2 by SCMPDS_6:38;
        I is_halting_on t by A4,A8,A9,A10,A11;
        then
A32:    ProgramPart t2 halts_on t2 by SCMPDS_6:def 3;
A33:     Initialize t2+*pI = t2+*Initialize pI by COMPOS_1:125;
        t2 = Initialize t2+*pI by A21,A33,FUNCT_4:79;
        then ProgramPart(Initialize t2+*pI) halts_on Initialize t2+*pI by A32;
        then
A34:    I is_halting_on t2 by SCMPDS_6:def 3;
        not a in dom Initialize pWHL by SCMPDS_4:31;
        then t3.DataLoc(t3.a,i)= t3.b by A10,A20,FUNCT_4:12
          .= t.b by A17,A20,FUNCT_4:12;
        then
A35:    IC t4 = succ IC t3 by A11,A22,SCMPDS_2:68
          .= (0+1) by A28;
        then
A36:    IC t5=l1 by A1,A21,A34,A31,A24,A26,SCMPDS_7:36;
A37:  (ProgramPart t6)/.IC t6
 = t6.IC t6 by COMPOS_1:38;
 ProgramPart t3 = ProgramPart t4
by AMI_1:123;
 then
A38:    t6=t5 by EXTPRO_1:5;
        then
A39:    CurInstr(ProgramPart t6,t6)=t5.l1
 by A1,A21,A34,A31,A35,A24,A26,A37,SCMPDS_7:36
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=WHL.l1 by A29,A25,GRFUNC_1:8
          .=i2 by Th19;
A40: ProgramPart t3 = ProgramPart t6
by AMI_1:123;
A41:    t7 = Following(ProgramPart t3,t6) by EXTPRO_1:4
          .= Exec(i2,t6) by A39,A40;
        then IC t7=ICplusConst(t6,0-(card I+1)) by SCMPDS_2:66
          .= 0 by A36,A38,SCMPDS_7:1;
        then
A42:    Initialize t7 +* pWHL=t7 by SCMPDS_7:37;
A43:    DataPart Comput(ProgramPart(t2),t2,m2) = DataPart t5 by A1,A21,A34,A31
,A35,A24,A26,SCMPDS_7:36;
        then
A44:    DataPart t5 =DataPart Result(ProgramPart(t2),t2) by A32,EXTPRO_1:23
          .= DataPart(Result(ProgramPart(t2),t2) +* t | A) by A16,AMI_2:29
,FUNCT_4:76,SCMPDS_2:100
          .=DataPart IExec(I,t) by SCMPDS_4:def 8;
A45:    now
          let x be Int_position;
          assume
A46:      x in Y;
          thus t7.x=t5.x by A38,A41,SCMPDS_2:66
            .=IExec(I,t).x by A44,SCMPDS_3:4
            .=t.x by A4,A8,A9,A10,A11,A46
            .=s.x by A9,A46;
        end;
        InsCode i2=0 by SCMPDS_2:21;
        then InsCode i2 in {0,4,5,6} by ENUMSET1:def 2;
        then
A47:    Dstate(t7)=Dstate(t6) by A41,Th3
          .=Dstate(IExec(I,t)) by A44,A38,Th2;
A48:    now
          f.Dstate(IExec(I,t)) < f.Dstate(t) by A4,A8,A9,A10,A11;
          then
A49:      f.Dstate(t7) < k+1 by A7,A47,XXREAL_0:2;
          assume f.Dstate(t7) > k;
          hence contradiction by A49,INT_1:20;
        end;
A50:    t7.b=t5.b by A38,A41,SCMPDS_2:66
          .=IExec(I,t).b by A44,SCMPDS_3:4;
A51:    now
          let x be Int_position;
          assume
A52:      x in X;
          t7.x=t5.x by A38,A41,SCMPDS_2:66
            .=IExec(I,t).x by A44,SCMPDS_3:4;
          hence t7.x >= c+t7.b by A4,A8,A9,A10,A11,A50,A52;
        end;
A53:    t5.a=Comput(ProgramPart(t2),t2,m2).a by A43,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).a by A32,EXTPRO_1:23
          .=s.a by A10,A14,A27,A13,FUNCT_4:12;
A54: ProgramPart t4 = ProgramPart t3
by AMI_1:123;
A55:    t7.a=t6.a by A41,SCMPDS_2:66
          .=s.a by A53,A54,EXTPRO_1:5;
        then
A56:    WHL is_closed_on t7 by A6,A51,A45,A48;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m3+1;
            then
A57:        k <= m3 by INT_1:20;
            hereby
              per cases by A57,NAT_1:8;
              suppose
A58:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A15
,A28,EXTPRO_1:3;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A59:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(ProgramPart(t2),t2,kn) as Element
of NAT;
A60: ProgramPart t3 = ProgramPart t4
by AMI_1:123;
                    kn < k by A59,XREAL_1:31;
                    then kn < m2 by A58,XXREAL_0:2;
                    then IC Comput(ProgramPart(t2),t2,kn) + 1 = IC Comput(
ProgramPart(t4),t4,kn) by A1,A21,A34,A31,A35,A24,A26,SCMPDS_7:34;
                    then
A61:                IC Comput(ProgramPart(t3),t3,k) = (lm+1) by A59,A60,
EXTPRO_1:5;
                    IC Comput(ProgramPart(t2),t2,kn) in dom pI by A30,
SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:70;
                    then lm < card I+1 by SCMPDS_5:7;
                    then
A62:                lm+1 <= card I +1 by INT_1:20;
                    card I + 1 < card I + 3 by XREAL_1:8;
                    then lm+1 < card I +3 by A62,XXREAL_0:2;
                    then lm+1 < card pWHL by Lm3;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A61,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A63:            k=m3;
                l1 in dom pWHL by A29,SCMPDS_6:18;
                hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A1,A21,A34
,A31,A35,A24,A26,A38,A63,SCMPDS_7:36;
              end;
            end;
          end;
          suppose
            k >= m3+1;
            then consider nn be Nat such that
A64:        k=m3+1+nn by NAT_1:10;
A65: ProgramPart t3 = ProgramPart t7
by AMI_1:123;
A66:        nn in NAT by ORDINAL1:def 13;
            then Comput(ProgramPart(t3),t3,k)=
            Comput(ProgramPart(Initialize t7+*pWHL),Initialize t7+*
pWHL,nn) by A42,A64,A65,EXTPRO_1:5;
            hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A56,A66,
SCMPDS_6:def 2;
          end;
        end;
        hence WHL is_closed_on t by SCMPDS_6:def 2;
        WHL is_halting_on t7 by A6,A55,A51,A45,A48;
        then ProgramPart t7 halts_on t7 by A42,SCMPDS_6:def 3;
        then ProgramPart t3 halts_on t7 by AMI_1:123;
        then ProgramPart t3 halts_on t3 by EXTPRO_1:22;
        hence WHL is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  set n=f.Dstate(s);
A67: for x st x in Y holds s.x=s.x;
A68: P[0]
  proof
    let t be State of SCMPDS;
    assume f.Dstate(t) <= 0;
    then f.Dstate(t)=0;
    then
A69: t.b <= 0 by A2;
    assume for x be Int_position st x in X holds t.x >= c+t.b;
    assume
    for x st x in Y holds t.x=s.x;
    assume t.a=s.a;
    hence thesis by A69,Th20;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A68,A5);
  then P[n];
  hence thesis by A3,A67;
end;

theorem Th25:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a be Int_position, i,c be Integer,X,Y be set,f being
  Function of product the Object-Kind of SCMPDS,NAT st s.DataLoc(s.a,i) > 0 &
card I > 0 & ( for t be State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i)
<= 0 ) & (for x st x in X holds s.x >= c+s.DataLoc(s.a,i)) & (for t be State of
SCMPDS st (for x st x in X holds t.x >= c+t.DataLoc(s.a,i)) & (for x st x in Y
  holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0 holds IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & (for
x st x in X holds IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i)) & for x st x in
Y holds IExec(I,t).x=t.x) holds IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),
  IExec(I,s))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,X,Y be set, f be Function of product the
  Object-Kind of SCMPDS,NAT;
  set b=DataLoc(s.a,i);
  set WHL=while>0(a,i,I), pWHL=stop WHL,
  s1= Initialize s +* pWHL, ps= ProgramPart s;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
A1: Initialize s +* pWHL = s +* Initialize pWHL by COMPOS_1:125;
  assume
A2: s.b > 0;
  set s4 = Comput(ProgramPart(s1),s1,1);
A3: IC s1 = 0 by SCMPDS_6:21;
A4: WHL = i1 ';' (I ';' i2) by SCMPDS_4:51;
A5: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by EXTPRO_1:4
    .= Following(ProgramPart s1,s1) by EXTPRO_1:3
    .= Exec(i1,s1) by A4,A1,SCMPDS_6:22;
  set m0=LifeSpan(ProgramPart(s1),s1);
A6: dom ProgramPart s = A by COMPOS_1:34;
A7: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
  set Es=IExec(I,s), bj=DataLoc(Es.a,i);
  assume
A8: card I > 0;
  assume
A9: for t be State of SCMPDS st f.Dstate(t)=0 holds t.b <= 0;
  assume
A10: for x st x in X holds s.x >= c+s.b;
  assume
A11: for t be State of SCMPDS st (for x st x in X holds t.x >= c+t.b) & (
  for x st x in Y holds t.x=s.x) & t.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & (for
x st x in X holds IExec(I,t).x >= c+IExec(I,t).b) & for x st x in Y holds IExec
  (I,t).x=t.x;
  then WHL is_halting_on s by A8,A9,A10,Th24;
  then
A12: ProgramPart s1 halts_on s1 by SCMPDS_6:def 3;
A13: for x st x in Y holds s.x=s.x;
  then
A14: bj=b by A2,A10,A11;
  set sI= Initialize s +* stop I, m1=LifeSpan(ProgramPart(sI),sI)+2,
  s2=Initialize IExec(I,s) +* pWHL,
  m2 =LifeSpan(ProgramPart(s2),s2);
A15: Initialize s +* stop I = s +* Initialize stop I by COMPOS_1:125;
A16: Initialize IExec(I,s) +* pWHL = IExec(I,s) +* Initialize pWHL
          by COMPOS_1:125;
A17: Initialize stop I c= sI by A15,FUNCT_4:26;
A18: IExec(I, s).a=s.a by A2,A10,A11,A13;
A19: now
    let t be State of SCMPDS;
    assume that
A20: for x st x in X holds t.x >= c+t.bj and
A21: for x st x in Y holds t.x=Es.x and
A22: t.a=Es.a and
A23: t.bj > 0;
A24: now
      let x;
      assume
A25:  x in Y;
      hence t.x=Es.x by A21
        .=s.x by A2,A10,A11,A13,A25;
    end;
    hence IExec(I,t).a=t.a by A11,A18,A20,A22,A23;
A26: t.a=s.a by A2,A10,A11,A13,A22;
    hence I is_closed_on t & I is_halting_on t by A11,A20,A22,A23,A24;
    thus f.Dstate(IExec(I,t)) < f.Dstate(t) by A11,A20,A22,A23,A24,A26;
    thus for x st x in X holds IExec(I,t).x >= c+IExec(I,t).bj by A11,A18,A20
,A22,A23,A24;
    thus for x st x in Y holds IExec(I,t).x=t.x by A11,A20,A22,A23,A24,A26;
  end;
  for x st x in X holds Es.x >= c+Es.bj by A2,A10,A11,A13,A18;
  then WHL is_halting_on Es by A8,A9,A14,A19,Th24;
  then
A27: ProgramPart s2 halts_on s2 by SCMPDS_6:def 3;
A28: DataPart sI = DataPart s1 by COMPOS_1:138,FUNCT_7:134;
  now
    let a;
    thus sI.a = s1.a by A28,SCMPDS_4:23
      .= s4.a by A5,SCMPDS_2:68;
  end;
  then
A29: DataPart sI = DataPart s4 by SCMPDS_4:23;
  set mI=LifeSpan(ProgramPart(sI),sI), s5=Comput(ProgramPart(s4),s4,mI), l1= (
card I + 1);
  WHL c= Initialize pWHL & Initialize pWHL c= s1 by A1,FUNCT_4:26,SCMPDS_6:17;
  then
A30: WHL c= s1 by XBOOLE_1:1;
  set m3=mI +1;
A31: IExec(I,s) = Result(ProgramPart(sI),sI) +* s | A by SCMPDS_4:def 8;
  set s7=Comput(ProgramPart(s1),s1,m3+1);
  set s6=Comput(ProgramPart(s1),s1,m3);
  card I + 1 < card I + 2 by XREAL_1:8;
  then
A32: l1 in dom WHL by Th18;
  Shift(I,1) c= WHL by Lm4;
  then Shift(I,1) c= s1 by A30,XBOOLE_1:1;
  then
A33: Shift(I,1) c= s4 by AMI_1:81;
  I is_halting_on s by A2,A10,A11,A13;
  then
A34: ProgramPart sI halts_on sI by SCMPDS_6:def 3;
A35: Initialize sI+*stop I = sI+*Initialize stop I by COMPOS_1:125;
  sI = Initialize sI+*stop I by A17,A35,FUNCT_4:79;
  then ProgramPart(Initialize sI+*stop I) halts_on Initialize sI+*stop I
   by A34;
  then
A36: I is_halting_on sI by SCMPDS_6:def 3;
A37: ProgramPart IExec(I,s)
    = ProgramPart (Result(ProgramPart(sI),sI) +* ps) by SCMPDS_4:def 8
    .= ps by A7,FUNCT_4:24;
A38: not b in dom Initialize pWHL by SCMPDS_4:31;
  not a in dom Initialize pWHL by SCMPDS_4:31;
  then s1.DataLoc(s1.a,i)=s1.b by A1,FUNCT_4:12
    .= s.b by A38,A1,FUNCT_4:12;
  then
A39: IC s4 = succ IC s1 by A2,A5,SCMPDS_2:68
    .= (0+1) by A3;
  I is_closed_on s by A2,A10,A11,A13;
  then
A40: I is_closed_on sI by SCMPDS_6:38;
  then
A41: IC s5=l1 by A8,A17,A36,A39,A29,A33,SCMPDS_7:36;
A42:  (ProgramPart s6)/.IC s6
 = s6.IC s6 by COMPOS_1:38;
 ProgramPart s1 = ProgramPart s4
by AMI_1:123;
 then
A43: s6=s5 by EXTPRO_1:5;
  then
A44: CurInstr(ProgramPart s6,s6)=s5.l1
 by A8,A17,A36,A40,A39,A29,A33,A42,SCMPDS_7:36
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=WHL.l1 by A32,A30,GRFUNC_1:8
    .=i2 by Th19;
A45: ProgramPart s1 = ProgramPart s6
by AMI_1:123;
A46: s7 = Following(ProgramPart s1,s6) by EXTPRO_1:4
    .= Exec(i2,s6) by A44,A45;
  then IC s7=ICplusConst(s6,0-(card I+1)) by SCMPDS_2:66
    .= 0 by A41,A43,SCMPDS_7:1;
  then
A47: IC s2 =IC Comput(ProgramPart(s1),s1,m1) by SCMPDS_6:21;
A48: DataPart Comput(ProgramPart(sI),sI,mI) = DataPart s5 by A8,A17,A36,A40,A39
,A29,A33,SCMPDS_7:36;
  now
    let x be Int_position;
A49: not x in dom Initialize pWHL by SCMPDS_4:31;
A50: not x in dom (s | A) by A6,SCMPDS_2:53;
    s5.x=Comput(ProgramPart(sI),sI,mI).x by A48,SCMPDS_4:23
      .=(Result(ProgramPart(sI),sI)).x by A34,EXTPRO_1:23
      .=IExec(I,s).x by A31,A50,FUNCT_4:12;
    hence s7.x=IExec(I,s).x by A43,A46,SCMPDS_2:66
      .=s2.x by A49,A16,FUNCT_4:12;
  end;
  then
A51: DataPart s7 = DataPart s2 by SCMPDS_4:23;
A52: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m1)
by AMI_1:123;
  ProgramPart s2
     = ProgramPart (Result(ProgramPart(sI),sI) +* ps +* Initialize pWHL)
              by A16,SCMPDS_4:def 8
    .=ProgramPart (Result(ProgramPart(sI),sI) +* ps)+*
        ProgramPart Initialize pWHL
        by FUNCT_4:75
    .= ps +* ProgramPart Initialize pWHL by A7,FUNCT_4:24
    .= ProgramPart s1 by A1,FUNCT_4:75
    .= ProgramPart Comput(ProgramPart(s1),s1,m1) by AMI_1:123;
  then
A53: Comput(ProgramPart(s1),s1,m1)=s2 by A51,A47,SCMPDS_7:7;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1))=i1
   by A4,A52,A16,SCMPDS_6:22;
  then m0 > m1 by A12,SCMPDS_6:2,30;
  then consider nn be Nat such that
A54: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
A55: ProgramPart s1 = ProgramPart s2
by A53,AMI_1:123;
  Comput(ProgramPart(s1),s1,m1+m2) = Comput(ProgramPart(s1),s2,m2) by A53,
EXTPRO_1:5;
  then CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,m1+m2))
   = halt SCMPDS by A27,A55,EXTPRO_1:def 14;
  then m1 + m2 >= m0 by A12,EXTPRO_1:def 14;
  then
A56: m2 >= nn by A54,XREAL_1:8;
A57: Comput(ProgramPart(s1),s1,m0) = Comput(ProgramPart(s1),s2,nn) by A53,A54,
EXTPRO_1:5;
  then CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,nn))
   =halt SCMPDS by A12,A55,EXTPRO_1:def 14;
  then nn >= m2 by A27,EXTPRO_1:def 14;
  then nn=m2 by A56,XXREAL_0:1;
  then Result(ProgramPart(s1),s1) = Comput(ProgramPart(s2),s2,m2) by A12,A57,
A55,
EXTPRO_1:23;
  hence IExec(WHL,s) = Comput(ProgramPart(s2),s2,m2) +* ps by SCMPDS_4:def 8
    .= Result(ProgramPart(s2),s2) +* IExec(I,s) | A by A27,A37,EXTPRO_1:23
    .= IExec(WHL,IExec(I,s)) by SCMPDS_4:def 8;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable Program of
SCMPDS , a be Int_position, i be Integer,X be set, f being Function of product
  the Object-Kind of SCMPDS,NAT st card I > 0 & (for t be State of SCMPDS st f.
Dstate(t)=0 holds t.DataLoc(s.a,i) <= 0 ) & (for t be State of SCMPDS st (for x
st x in X holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0 holds IExec(I,t).a=t.
a & I is_closed_on t & I is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) &
  for x st x in X holds IExec(I,t).x=t.x) holds while>0(a,i,I) is_closed_on s &
while>0(a,i,I) is_halting_on s & (s.DataLoc(s.a,i) > 0 implies IExec(while>0(a,
  i,I),s) =IExec(while>0(a,i,I),IExec(I,s)))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
Int_position, i be Integer,X be set,f be Function of product the Object-Kind of
  SCMPDS,NAT;
  set b=DataLoc(s.a,i);
  assume
A1: card I > 0;
  assume
A2: for t be State of SCMPDS st f.Dstate(t)=0 holds t.b <= 0;
  assume
A3: for t be State of SCMPDS st (for x st x in X holds t.x=s.x) & t.a=s.
a & t.b > 0 holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t & f.
  Dstate(IExec(I,t)) < f.Dstate(t) & for x st x in X holds IExec(I,t).x=t.x;
  then
A4: for t being State of SCMPDS st (for x st x in {} holds t.x >= 0+t.b) & (
  for x st x in X holds t.x=s.x) & t.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & (for
  x st x in {} holds IExec(I,t).x >= 0+IExec(I,t).b) & for x st x in X holds
  IExec(I,t).x=t.x;
A5: for x st x in {} holds s.x >= 0+s.b;
  for t being State of SCMPDS st (for x st x in {} holds t.x >= 0+t.b) & (
  for x st x in X holds t.x=s.x) & t.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & (for
  x st x in {} holds IExec(I,t).x >= 0+IExec(I,t).b) & for x st x in X holds
  IExec(I,t).x=t.x by A3;
  hence
  while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s by A1,A2,A5
,Th24;
  assume s.b > 0;
  hence thesis by A1,A2,A5,A4,Th25;
end;

theorem Th27:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a be Int_position, i,c be Integer,X,Y be set st card I > 0 &
  (for x st x in X holds s.x >= c+s.DataLoc(s.a,i)) & (for t be State of SCMPDS
st (for x st x in X holds t.x >= c+t.DataLoc(s.a,i)) & (for x st x in Y holds t
  .x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0 holds IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & IExec(I,t).DataLoc(s.a,i) < t.DataLoc(s.a,
i) & (for x st x in X holds IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i)) & for
  x st x in Y holds IExec(I,t).x=t.x) holds while>0(a,i,I) is_closed_on s &
while>0(a,i,I) is_halting_on s & ( s.DataLoc(s.a,i) > 0 implies IExec(while>0(a
  ,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,X,Y be set;
  set b=DataLoc(s.a,i);
  assume
A1: card I > 0;
  defpred P[State of SCMPDS] means (for x st x in X holds $1.x >= c+$1.b) & (
  for x st x in Y holds $1.x=s.x);
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A2: for s holds (s.b <= 0 implies f.s =0) & (s.b > 0 implies f.s=s.b) by Th5;
  deffunc F(State of SCMPDS) = f.$1;
A3: for t be State of SCMPDS holds F(Dstate t)=0 iff t.b <= 0
  proof
    let t be State of SCMPDS;
    thus F(Dstate t)=0 implies t.b <= 0
    proof
      assume
A4:   F(Dstate t)=0;
      assume t.b > 0;
      then (Dstate t).b > 0 by Th4;
      hence contradiction by A2,A4;
    end;
    assume t.b <= 0;
    then (Dstate t).b <= 0 by Th4;
    hence thesis by A2;
  end;
  then
A5: for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.b <= 0;
  assume
A6: for x st x in X holds s.x >= c+s.b;
A7: P[Dstate s]
  proof
    set t=Dstate s;
    hereby
      let x;
      assume x in X;
      then s.x >= c+s.b by A6;
      then t.x >= c+s.b by Th4;
      hence t.x >= c+t.b by Th4;
    end;
    thus thesis by Th4;
  end;
  assume
A8: for t be State of SCMPDS st (for x st x in X holds t.x >= c+t.b) & (
  for x st x in Y holds t.x=s.x) & t.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I
  is_closed_on t & I is_halting_on t & IExec(I,t).b < t.b & (for x st x in X
holds IExec(I,t).x >= c+IExec(I,t).b) & for x st x in Y holds IExec(I,t).x=t.x;
A9: now
    let t be State of SCMPDS;
    assume that
A10: P[Dstate t] and
A11: t.a=s.a and
A12: t.b > 0;
    set It=IExec(I,t), t2=Dstate It, t1=Dstate t;
    consider v be State of SCMPDS such that
A13: v=Dstate t and
A14: for x st x in X holds v.x >= c+v.b and
A15: for x st x in Y holds v.x=s.x by A10;
A16: now
      let x;
      assume x in Y;
      then v.x =s.x by A15;
      hence t.x=s.x by A13,Th4;
    end;
A17: now
      let x;
      assume x in X;
      then v.x >= c+v.b by A14;
      then t.x >= c+v.b by A13,Th4;
      hence t.x >= c+t.b by A13,Th4;
    end;
    hence
    IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t by A8,A11,A12,A16;
    thus F(t2) < F(t1)
    proof
      t1.b > 0 by A12,Th4;
      then
A18:  F(t1)=t1.b by A2
        .=t.b by Th4;
      assume
A19:  F(t2) >= F(t1);
      then It.b > 0 by A3,A12,A18;
      then t2.b > 0 by Th4;
      then F(t2)=t2.b by A2
        .=It.b by Th4;
      hence contradiction by A8,A11,A12,A17,A16,A19,A18;
    end;
    thus P[Dstate It]
    proof
      set v=Dstate It;
      hereby
        let x;
        assume x in X;
        then It.x >= c+It.b by A8,A11,A12,A17,A16;
        then v.x >= c+It.b by Th4;
        hence v.x >= c+v.b by Th4;
      end;
      hereby
        let x;
        assume
A20:    x in Y;
        then It.x=t.x by A8,A11,A12,A17,A16;
        then v.x=t.x by Th4;
        hence v.x=s.x by A16,A20;
      end;
    end;
  end;
  (F(s)=F(s) or P[s]) & while>0(a,i,I) is_closed_on s & while>0(a,i,I)
  is_halting_on s from WhileGHalt(A1,A5,A7,A9);
  hence while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s;
  assume
A21: s.b > 0;
  (F(s)=F(s) or P[s]) & IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),
  IExec(I,s)) from WhileGExec(A1,A21,A5,A7,A9);
  hence thesis;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable Program of
  SCMPDS , a be Int_position, i be Integer,X be set st card I > 0 & (for t be
State of SCMPDS st (for x st x in X holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i)
> 0 holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t & IExec(I,t).
  DataLoc(s.a,i) < t.DataLoc(s.a,i) & for x st x in X holds IExec(I,t).x=t.x)
  holds while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s & (s.
DataLoc(s.a,i) > 0 implies IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(
  I,s)))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i be Integer,X be set;
  set b=DataLoc(s.a,i);
  assume
A1: card I > 0;
  assume
A2: for t be State of SCMPDS st (for x st x in X holds t.x=s.x) & t.a=s.
  a & t.b > 0 holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
  IExec(I,t).b < t.b & for x st x in X holds IExec(I,t).x=t.x;
  then
A3: for t being State of SCMPDS st (for x st x in {} holds t.x >= 0+t.b) & (
  for x st x in X holds t.x=s.x) & t.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I
  is_closed_on t & I is_halting_on t & IExec(I,t).b < t.b & (for x st x in {}
holds IExec(I,t).x >= 0+IExec(I,t).b) & for x st x in X holds IExec(I,t).x=t.x;
A4: for x st x in {} holds s.x >= 0+s.b;
  for t being State of SCMPDS st (for x st x in {} holds t.x >= 0+t.b) & (
  for x st x in X holds t.x=s.x) & t.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I
  is_closed_on t & I is_halting_on t & IExec(I,t).b < t.b & (for x st x in {}
holds IExec(I,t).x >= 0+IExec(I,t).b) & for x st x in X holds IExec(I,t).x=t.x
  by A2;
  hence
  while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s by A1,A4,Th27;
  assume s.b > 0;
  hence thesis by A1,A4,A3,Th27;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable Program of
SCMPDS , a be Int_position, i,c be Integer,X be set st card I > 0 & (for x st x
in X holds s.x >= c+s.DataLoc(s.a,i)) & (for t be State of SCMPDS st (for x st
x in X holds t.x >= c+t.DataLoc(s.a,i)) & t.a=s.a & t.DataLoc(s.a,i) > 0 holds
IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t & IExec(I,t).DataLoc(s.
  a,i) < t.DataLoc(s.a,i) & for x st x in X holds IExec(I,t).x >= c+IExec(I,t).
  DataLoc(s.a,i)) holds while>0(a,i,I) is_closed_on s & while>0(a,i,I)
is_halting_on s & (s.DataLoc(s.a,i) > 0 implies IExec(while>0(a,i,I),s) =IExec(
  while>0(a,i,I),IExec(I,s)))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,X be set;
  set b=DataLoc(s.a,i);
  assume
A1: card I > 0;
  assume
A2: for x st x in X holds s.x >= c+s.b;
  assume
A3: for t be State of SCMPDS st (for x st x in X holds t.x >= c+t.b) & t
.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t
  & IExec(I,t).b < t.b & for x st x in X holds IExec(I,t).x >= c+IExec(I,t).b;
  then
  for t being State of SCMPDS st (for x st x in X holds t.x >= c+t.b) & (
for x st x in {} holds t.x=s.x) & t.a=s.a & t.b > 0 holds (IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & IExec(I,t).b < t.b & for x st x in X holds
  IExec(I,t).x >= c+IExec(I,t).b) & for x st x in {} holds IExec(I,t).x=t.x;
  hence
  while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s by A1,A2,Th27;
  assume
A4: s.b > 0;
  for t being State of SCMPDS st (for x st x in X holds t.x >= c+t.b) & (
for x st x in {} holds t.x=s.x) & t.a=s.a & t.b > 0 holds (IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & IExec(I,t).b < t.b & for x st x in X holds
IExec(I,t).x >= c+IExec(I,t).b) & for x st x in {} holds IExec(I,t).x=t.x by A3
  ;
  hence thesis by A1,A2,A4,Th27;
end;

