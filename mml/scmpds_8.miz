:: The Construction and Computation of While-loop Programs for SCMPDS
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies NUMBERS, SCMPDS_2, FSM_1, AMI_2, SUBSET_1, SCMP_GCD, AMI_3,
      FUNCT_1, CARD_1, AMI_1, ARYTM_3, CARD_3, XXREAL_0, INT_1, SCMFSA_9,
      TURING_1, ARYTM_1, SCMPDS_4, SCMFSA_7, RELAT_1, UNIALG_2,
      SCMFSA7B, SCMFSA6A, FUNCT_4, CIRCUIT2, TARSKI, SCMFSA6B, MSUALG_1,
      GRAPHSP, STRUCT_0, VALUED_1, NAT_1, XBOOLE_0, SCMPDS_8, ORDINAL1,
      PARTFUN1, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, FUNCT_2,
      ORDINAL1, CARD_1, NUMBERS,
      RELAT_1, FUNCT_1, PARTFUN1, VALUED_1, XCMPLX_0,
      FUNCT_4, RECDEF_1, NAT_1, INT_1, STRUCT_0, AMI_1,
      SCMNORM, AMI_2, AMI_3, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD,
      CARD_3, DOMAIN_1, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, NAT_1, RECDEF_1, SCM_1, SCMPDS_4,
      SCMPDS_5, SCMPDS_6, SCMP_GCD, SCMNORM, SCMPDS_3, PRE_POLY, PBOOLE,
      SCMPDS_1, RELSET_1, SCMPDS_7, COMPLEX1, INT_2;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, CARD_3, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6,
      XBOOLE_0, VALUED_0, SCMNORM, VALUED_1, AMI_1, FUNCT_4, RELAT_1, PBOOLE,
      GRFUNC_1, FRAENKEL, FUNCT_2;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, AMI_1, AMI_3, AMI_2, SCMNORM;
 theorems AMI_1, NAT_1, TARSKI, FUNCT_4, FUNCT_1, INT_1, SCMPDS_2, AMI_2,
      SCMPDS_3, GRFUNC_1, SCMPDS_4, SCMPDS_5, SCMPDS_6, ENUMSET1, SCMP_GCD,
      SCMPDS_7, RELAT_1, XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0,
      ZFMISC_1, PBOOLE, PARTFUN1, AFINSQ_1;
 schemes NAT_1, SCMPDS_4, FUNCT_2;

begin :: Preliminaries

reserve x,a for Int_position,
  s for State of SCMPDS;
set A = NAT, D = SCM-Data-Loc;

theorem Th1: :: see SCMPDS_3:32
  for a be Int_position ex i being Element of NAT st a = intpos i
proof
  let a be Int_position;
  a in D by SCMPDS_2:def 2;
  then consider x,y be set such that
A1: x in {1} and
A2: y in NAT and
A3: a=[x,y] by ZFMISC_1:103;
  reconsider k = y as Element of NAT by A2;
  take k;
  thus intpos k=dl.k by SCMP_GCD:def 1
    .=a by A1,A3,TARSKI:def 1;
end;

definition
  let t be State of SCMPDS;
  func Dstate(t) -> State of SCMPDS means
  :Def1:
  for x be set holds (x in
  SCM-Data-Loc implies it.x = t.x) & ( x in NAT implies it.x = goto 0) & (x=IC
  SCMPDS implies it.x= 0);
  existence
  proof
    deffunc V(Element of NAT) = t.DataLoc($1,0);
    deffunc U(Element of NAT) = goto 0;
    consider s being State of SCMPDS such that
A1: IC s =  0 & for i being Element of NAT holds s. i = U(
    i) & s.DataLoc(i,0) = V(i) from SCMPDS_4:sch 1;
    take s;
    now
      let x be set;
      thus x in D implies s.x = t.x
      proof
        assume
        x in D;
        then x is Int_position by SCMPDS_2:9;
        then consider i be Element of NAT such that
A2:     x=intpos i by Th1;
        x=intpos(i+0) by A2
          .=DataLoc(i,0) by SCMP_GCD:5;
        hence thesis by A1;
      end;
      thus x in A implies s.x = goto 0 by A1;
      thus x=IC SCMPDS implies s.x= 0 by A1;
    end;
    hence thesis;
  end;
  uniqueness
  proof
    let s1,s2 be State of SCMPDS such that
A3: for x be set holds (x in D implies s1.x = t.x) & ( x in A implies
    s1.x = goto 0) & ( x=IC SCMPDS implies s1.x= 0) and
A4: for x be set holds (x in D implies s2.x = t.x) & ( x in A implies
    s2.x = goto 0) & (x=IC SCMPDS implies s2.x= 0);
A5: now
      let a be Int_position;
A6:   a in D by SCMPDS_2:def 2;
      hence s1.a=t.a by A3
        .=s2.a by A4,A6;
    end;
A7: now
      let i be Element of NAT;
      thus s1.i = goto 0 by A3
        .=s2.i by A4;
    end;
    IC s1 = 0 by A3
      .=IC s2 by A4;
    hence thesis by A5,A7,SCMPDS_2:54;
  end;
end;

theorem Th2:
  for t1,t2 being State of SCMPDS st DataPart t1=DataPart t2 holds
  Dstate(t1)=Dstate(t2)
proof
  let t1,t2 be State of SCMPDS;
  set s1=Dstate(t1), s2=Dstate(t2);
A1: now
    let i be Element of NAT;
    thus s1.i = goto 0 by Def1
      .=s2.i by Def1;
  end;
  assume
A3: DataPart t1=DataPart t2;
A4: now
    let a be Int_position;
A5: a in D by SCMPDS_2:def 2;
    hence s1.a=t1.a by Def1
      .=t2.a by A3,SCMPDS_3:4
      .=s2.a by A5,Def1;
  end;
  IC s1 = 0 by Def1
    .=IC s2 by Def1;
  hence thesis by A4,A1,SCMPDS_2:54;
end;

theorem Th3:
  for t being State of SCMPDS,i being Instruction of SCMPDS st
  InsCode i in {0,4,5,6} holds Dstate(t)=Dstate(Exec(i,t))
proof
  let t be State of SCMPDS,i be Instruction of SCMPDS;
  assume
  InsCode i in {0,4,5,6};
  then DataPart Exec(i,t) = DataPart t by SCMPDS_7:20;
  hence thesis by Th2;
end;

theorem Th4:
  (Dstate(s)).a=s.a
proof
  a in D implies (Dstate s).a = s.a by Def1;
  hence thesis by SCMPDS_2:def 2;
end;

theorem Th5:
  for a be Int_position holds ex f be Function of product the
  Object-Kind of SCMPDS,NAT st for s being State of SCMPDS holds (s.a <= 0
  implies f.s =0) & (s.a > 0 implies f.s=s.a)
proof
  let a be Int_position;
  defpred P[set,set] means ex t be State of SCMPDS st t=$1 & (t.a <= 0 implies
  $2 =0) & (t.a > 0 implies $2=t.a);
A1: now
    let s be Element of product the Object-Kind of SCMPDS;
    per cases;
    suppose
A2:   s.a <= 0;
      reconsider y=0 as Element of NAT;
      take y;
      thus P[s,y] by A2;
    end;
    suppose
A3:   s.a > 0;
      then reconsider y=s.a as Element of NAT by INT_1:16;
      take y;
      thus P[s,y] by A3;
    end;
  end;
  consider
  f be Function of product the Object-Kind of SCMPDS,NAT such that
B4: for s being Element of product the Object-Kind of SCMPDS holds P[s,f.s]
    from FUNCT_2:sch 3(A1);
A4: for s holds P[s,f.s]
   proof
    let s;
    reconsider s as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
     P[s,f.s] by B4;
   hence thesis;
   end;
  take f;
  hereby
    let s;
    P[s,f.s] by A4;
    hence (s.a <= 0 implies f.s =0) & (s.a > 0 implies f.s=s.a);
  end;
end;

begin :: The construction and several basic properties of while<0 program

:: while (a,i)<0 do I

definition
  let a be Int_position, i be Integer,I be Program of SCMPDS;
  func while<0(a,i,I) -> Program of SCMPDS equals
  (a,i)>=0_goto (card I +2)
  ';' I ';' goto -(card I+1);
  coherence;
end;

registration
  let I be shiftable Program of SCMPDS,a be Int_position,i be Integer;
  cluster while<0(a,i,I) -> shiftable;
  correctness
  proof
    set WHL=while<0(a,i,I), i1= (a,i)>=0_goto (card I +2);
    set PF= Load i1 ';' I;
A1: PF=i1 ';' I by SCMPDS_4:def 4;
    then card PF=card I + 1 by SCMPDS_6:15;
    then card PF+ -(card I+1) =0;
    hence thesis by A1,SCMPDS_4:78;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,i be Integer;
  cluster while<0(a,i,I) -> halt-free;
  correctness;
end;

theorem Th6:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
  card while<0(a,i,I)= card I +2
proof
  let a be Int_position,i be Integer, I be Program of SCMPDS;
  set i1=(a,i)>=0_goto (card I +2);
  set I4=i1 ';' I;
  thus card while<0(a,i,I)=card I4+1 by SCMP_GCD:8
    .=card I +1 +1 by SCMPDS_6:15
    .=card I + 2;
end;

Lm1: for a be Int_position,i be Integer,I be Program of SCMPDS holds card stop
while<0(a,i,I)= card I+3

proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  thus card stop while<0(a,i,I)= card while<0(a,i,I) +1 by SCMPDS_5:7
    .= card I +2+1 by Th6
    .= card I + 3;
end;

theorem Th7:
  for a be Int_position,i be Integer,m be Element of NAT,I be
  Program of SCMPDS holds m < card I+2 iff  m in dom while<0(a,i,I)
proof
  let a be Int_position,i be Integer,m be Element of NAT, I be Program of
  SCMPDS;
  card while<0(a,i,I)=card I + 2 by Th6;
  hence thesis by AFINSQ_1:70;
end;

theorem Th8:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
while<0(a,i,I). 0=(a,i)>=0_goto (card I +2) & while<0(a,i,I). (card
  I+1)=goto -(card I+1)
proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  set i1=(a,i)>=0_goto (card I +2), i2=goto -(card I+1);
  set I4=i1 ';' I;
  set J5=I ';' i2;
  set FLOOP=while<0(a,i,I);
  FLOOP=i1 ';' J5 by SCMPDS_4:51;
  hence FLOOP. 0=i1 by SCMPDS_6:16;
  card I4=card I+1 by SCMPDS_6:15;
  hence thesis by SCMP_GCD:10;
end;

theorem Th9:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer st s.DataLoc(s.a,i) >= 0 holds while<0(a,i,I)
  is_closed_on s & while<0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer;
  set d1=DataLoc(s.a,i);
  assume
A1: s.d1 >= 0;
  set i1=(a,i)>=0_goto (card I+2), i2=goto -(card I+1);
  set WHL=while<0(a,i,I), pWHL=stop WHL, iWHL=Initialized pWHL, s3 = s +* iWHL
  , s4 = Comput(ProgramPart(s3),s3,1);
A2: IC s3 = 0 by SCMPDS_6:21;
A3: not d1 in dom iWHL by SCMPDS_4:31;
  not a in dom iWHL by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
    .= s.d1 by A3,FUNCT_4:12;
A5: WHL = i1 ';' (I ';' i2 ) by SCMPDS_4:51;
  Comput(ProgramPart(s3),s3,0+1) = Following(ProgramPart s3,
  Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i1,s3) by A5,SCMPDS_6:22;
  then
A6: IC s4 = ICplusConst(s3,(card I+2)) by A1,A4,SCMPDS_2:69
    .= (0+(card I+2)) by A2,SCMPDS_6:23;
A7: card WHL=card I+2 by Th6;
  then
A8: (card I+2) in dom pWHL by SCMPDS_6:25;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
  iWHL c= s3 by FUNCT_4:26;
  then pWHL c= s4 by AMI_1:81,SCMPDS_4:57;
  then s4.(card I+2) = pWHL.(card I+2) by A8,GRFUNC_1:8
    .=halt SCMPDS by A7,SCMPDS_6:25;
  then
A9: CurInstr(ProgramPart s4,s4) = halt SCMPDS by A6,Y;
TX: ProgramPart s4 = ProgramPart s3
by AMI_1:123;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:20;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pWHL
      by A8,A6,A9,TX,AMI_1:52;
    end;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by AMI_1:13;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pWHL by A2,SCMPDS_4:75;
    end;
  end;
  hence WHL is_closed_on s by SCMPDS_6:def 2;
  ProgramPart s3 halts_on s3 by A9,TX,AMI_1:146;
  hence thesis by SCMPDS_6:def 3;
end;

theorem Th10:
  for s being State of SCMPDS,I being Program of SCMPDS,a,c being
Int_position, i being Integer st s.DataLoc(s.a,i) >= 0 holds IExec(while<0(a,i,
  I),s) = s +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a,c be Int_position, i be
  Integer;
  set d1=DataLoc(s.a,i);
  set WHL=while<0(a,i,I), pWHL=stop WHL, iWHL=Initialized pWHL, s3 = s +* iWHL
  , s4 = Comput(ProgramPart(s3),s3,1), i1=(a,i)>=0_goto (card I+2), i2=goto -(
card I+1);
  set SAl=Start-At((card I+2),SCMPDS);
A1: IC s3 = 0 by SCMPDS_6:21;
A2: WHL = i1 ';' (I ';' i2) by SCMPDS_4:51;
A3: not d1 in dom iWHL by SCMPDS_4:31;
  not a in dom iWHL by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
    .= s.d1 by A3,FUNCT_4:12;
A5: Comput(ProgramPart(s3),s3,0+1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i1,s3) by A2,SCMPDS_6:22;
  iWHL c= s3 by FUNCT_4:26;
  then
A6: pWHL c= s4 by AMI_1:81,SCMPDS_4:57;
A7: IExec(WHL,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
  assume
  s.d1 >= 0;
  then
A8: IC s4 = ICplusConst(s3,(card I+2)) by A5,A4,SCMPDS_2:69
    .= (0+(card I+2)) by A1,SCMPDS_6:23;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
TX: ProgramPart s4 = ProgramPart s3
by AMI_1:123;
A9: card WHL=card I+2 by Th6;
  then (card I+2) in dom pWHL by SCMPDS_6:25;
  then s4.(card I+2) = pWHL.(card I+2) by A6,GRFUNC_1:8
    .=halt SCMPDS by A9,SCMPDS_6:25;
  then
A10: CurInstr(ProgramPart s4,s4) = halt SCMPDS by A8,Y;
  then
A11: ProgramPart s3 halts_on s3 by TX,AMI_1:146;
A12: CurInstr(ProgramPart s3,s3) = i1 by A2,SCMPDS_6:22;
  now
    let l be Element of NAT;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    assume
    l < 0+1;
    then l=0 by NAT_1:13;
    then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
     = CurInstr(ProgramPart s3,s3) by u;
    hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) <>
     halt SCMPDS by A12,SCMPDS_6:31;
  end;
  then for l be Element of NAT
   st CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan(ProgramPart(s3),s3) = 1 by A10,A11,TX,AMI_1:def 46;
  then
A13: s4 = Result(ProgramPart(s3),s3) by A11,AMI_1:122;
A14: dom ProgramPart s = A by AMI_1:143;
A15: now
    let x be set;
A16: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A17: x in dom IExec(WHL,s);
    per cases by A17,SCMPDS_4:20;
    suppose
A18:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A19:  not x in dom SAl by A16,TARSKI:def 1;
      not x in dom (s | A) by A14,A18,SCMPDS_2:53;
      hence IExec(WHL,s).x = s4.x by A13,A7,FUNCT_4:12
        .= s3.x by A5,A18,SCMPDS_2:69
        .= s.x by A18,SCMPDS_5:19
        .= (s +* SAl).x by A19,FUNCT_4:12;
    end;
    suppose
A20:  x = IC SCMPDS;
      not x in dom (s | A) by A14,A20,AMI_1:48;
      hence IExec(WHL,s).x = (card I + 2) by A8,A13,A7,A20,FUNCT_4:12
        .= (s +* SAl).x by A20,SCMPDS_7:12;
    end;
    suppose
      x is Element of NAT;
      hence IExec(WHL,s).x = (s +* SAl).x by SCMPDS_6:27;
    end;
  end;
  dom IExec(WHL,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A15,FUNCT_1:9;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, i being Integer st s.DataLoc(s.a,i) >= 0 holds IC IExec(while<0(a
  ,i,I),s) =  (card I + 2)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer;
  assume
  s.DataLoc(s.a,i) >= 0;
  then IExec(while<0(a,i,I),s) =s +* Start-At((card I+2),SCMPDS) by Th10;
  hence thesis by FUNCT_4:121;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS, a,b being
Int_position , i being Integer st s.DataLoc(s.a,i) >= 0 holds IExec(while<0(a,i
  ,I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, i be
  Integer;
  assume
  s.DataLoc(s.a,i) >= 0;
  then
A1: IExec(while<0(a,i,I),s) = s +* Start-At((card I+2),SCMPDS) by Th10;
  not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

Lm2: for I being Program of SCMPDS,a being Int_position,i being Integer holds
Shift(I,1) c= while<0(a,i,I)

proof
  let I be Program of SCMPDS,a be Int_position,i be Integer;
  set i1=(a,i)>=0_goto (card I+2), i2=goto -(card I+1);
A1: while<0(a,i,I) = i1 ';' I ';' Load i2 by SCMPDS_4:def 5
    .= Load i1 ';' I ';' Load i2 by SCMPDS_4:def 4;
  card Load i1=1 by SCMPDS_5:6;
  hence thesis by A1,SCMPDS_7:16;
end;

scheme
  WhileLHalt { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
  P[State of SCMPDS]}: (F(s())=F(s()) or P[s()]) & while<0(a(),i(),I())
  is_closed_on s() & while<0(a(),i(),I()) is_halting_on s()
provided
A1: card I() > 0 and
A2: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.
DataLoc(s().a(),i()) >= 0 and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) < 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
]
proof
  set i1=(a(),i())>=0_goto (card I()+2), i2=goto -(card I()+1);
  set WHL=while<0(a(),i(),I()), pWHL=stop WHL, iWHL=Initialized pWHL, pI=stop
  I(), IsI= Initialized pI;
  set b=DataLoc(s().a(),i());
  defpred Q[Element of NAT] means for t be State of SCMPDS st F(Dstate(t)) <=
$1 & P[Dstate t] & t.a()=s().a() holds WHL is_closed_on t & WHL is_halting_on t
  ;
A5: for k be Element of NAT st Q[k] holds Q[k + 1]
  proof
    let k be Element of NAT;
    assume
A6: Q[k];
    now
      let t be State of SCMPDS;
      assume
A7:   F(Dstate(t)) <= k+1;
      assume
A8:   P[Dstate t];
      assume
A9:   t.a()=s().a();
      per cases;
      suppose
        t.b >= 0;
        hence WHL is_closed_on t & WHL is_halting_on t by A9,Th9;
      end;
      suppose
A10:    t.b < 0;
A11:    dom ProgramPart t = A by AMI_1:143;
A12: not a() in dom (t | A) by A11,SCMPDS_2:53;
A13:    IExec(I(),t).a()=t.a() by A4,A8,A9,A10;
A14:     0 in dom pWHL by SCMPDS_4:75;
A15:    dom ProgramPart t = A by AMI_1:143;
A16:    not b in dom iWHL by SCMPDS_4:31;
A17:    WHL = i1 ';' (I() ';' i2) by SCMPDS_4:51;
        set t2 = t +* IsI, t3 = t +* iWHL, t4 = Comput(ProgramPart(t3),t3,1);
A18:    IsI c= t2 by FUNCT_4:26;
        set m2=LifeSpan(ProgramPart(t2),t2), t5=Comput(ProgramPart(t4),t4,m2),
l1= (card I() + 1
);
A19:    IC t3 = 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6=Comput(ProgramPart(t3),t3,m3);
        set t7=Comput(ProgramPart(t3),t3,m3+1);
        card I() + 1 < card I() + 2 by XREAL_1:8;
        then
A20:    l1 in dom WHL by Th7;
        WHL c= iWHL & iWHL c= t3 by FUNCT_4:26,SCMPDS_6:17;
        then
A21:    WHL c= t3 by XBOOLE_1:1;
        Shift(I(),1) c= WHL by Lm2;
        then Shift(I(),1) c= t3 by A21,XBOOLE_1:1;
        then
A22:    Shift(I(),1) c= t4 by AMI_1:81;
A23:    Comput(ProgramPart(t3),t3,0+1) = Following(ProgramPart t3,
Comput(ProgramPart(t3),t3,0)) by AMI_1:14
          .= Following(ProgramPart t3,t3) by AMI_1:13
          .= Exec(i1,t3) by A17,SCMPDS_6:22;
A24:    DataPart t2 = DataPart t3 by SCMPDS_4:24,36;
        now
          let a;
          thus t2.a = t3.a by A24,SCMPDS_4:23
            .= t4.a by A23,SCMPDS_2:69;
        end;
        then
A25:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
        I() is_halting_on t by A4,A8,A9,A10;
        then
A26:    ProgramPart t2 halts_on t2 by SCMPDS_6:def 3;
        t2 = t2+*IsI by A18,FUNCT_4:79;
        then ProgramPart(t2+*IsI) halts_on t2+*IsI by A26;
        then
A27:    I() is_halting_on t2 by SCMPDS_6:def 3;
A28:    IExec(I(),t) = Result(ProgramPart(t2),t2) +* t | A by SCMPDS_4:def 8;
A29:    P[Dstate(IExec(I(),t))] by A4,A8,A9,A10;
A30:    I() is_closed_on t by A4,A8,A9,A10;
        then
A31:    I() is_closed_on t2 by SCMPDS_6:38;
        not a() in dom iWHL by SCMPDS_4:31;
        then t3.DataLoc(t3.a(),i())= t3.b by A9,FUNCT_4:12
          .= t.b by A16,FUNCT_4:12;
        then
A32:    IC t4 = succ IC t3 by A10,A23,SCMPDS_2:69
          .= (0+1) by A19;
        then
A33:    IC t5=l1 by A1,A18,A27,A31,A25,A22,SCMPDS_7:36;
Y:  (ProgramPart t6)/.IC t6
 = t6.IC t6 by AMI_1:150;
 ProgramPart t3 = ProgramPart t4
by AMI_1:123;
 then
A34:    t6=t5 by AMI_1:51;
        then
A35:    CurInstr(ProgramPart t6,t6)=t5.l1
 by A1,A18,A27,A31,A32,A25,A22,Y,SCMPDS_7:36
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=WHL.l1 by A20,A21,GRFUNC_1:8
          .=i2 by Th8;
T: ProgramPart t3 = ProgramPart t6
by AMI_1:123;
A36:    t7 = Following(ProgramPart t3,t6) by AMI_1:14
          .= Exec(i2,t6) by A35,T;
        then IC t7=ICplusConst(t6,0-(card I()+1)) by SCMPDS_2:66
          .= 0 by A33,A34,SCMPDS_7:1;
        then
A37:    t7 +* iWHL=t7 by SCMPDS_7:37;
A38:    DataPart Comput(ProgramPart(t2),t2,m2) = DataPart t5 by A1,A18,A27,A31
,A32,A25,A22,SCMPDS_7:36;
        then
A39:    DataPart t5 = DataPart Result(ProgramPart(t2),t2) by A26,AMI_1:122
          .= DataPart(Result(ProgramPart(t2),t2) +* t | A) by A15,AMI_2:29
,FUNCT_4:76,SCMPDS_2:100
          .=DataPart IExec(I(),t) by SCMPDS_4:def 8;
        InsCode i2=0 by SCMPDS_2:21;
        then InsCode i2 in {0,4,5,6} by ENUMSET1:def 2;
        then
A40:    Dstate(t7)=Dstate(t6) by A36,Th3
          .=Dstate(IExec(I(),t)) by A39,A34,Th2;
A41:    now
          F(Dstate(IExec(I(),t))) < F(Dstate(t)) by A4,A8,A9,A10;
          then
A42:      F(Dstate(t7)) < k+1 by A7,A40,XXREAL_0:2;
          assume
          F(Dstate(t7)) > k;
          hence contradiction by A42,INT_1:20;
        end;
A43:    t5.a()=Comput(ProgramPart(t2),t2,m2).a() by A38,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).a() by A26,AMI_1:122
          .=s().a() by A9,A13,A28,A12,FUNCT_4:12;
T1: ProgramPart t4 = ProgramPart t3
by AMI_1:123;
A44:    t7.a()=t6.a() by A36,SCMPDS_2:66
          .=s().a() by A43,T1,AMI_1:51;
        then
A45:    WHL is_closed_on t7 by A6,A29,A40,A41;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m3+1;
            then
A46:        k <= m3 by INT_1:20;
            hereby
              per cases by A46,NAT_1:8;
              suppose
A47:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A14
,A19,AMI_1:13;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A48:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(ProgramPart(t2),t2,kn) as Element
of NAT;
t: ProgramPart t3 = ProgramPart t4
by AMI_1:123;
                    kn < k by A48,XREAL_1:31;
                    then kn < m2 by A47,XXREAL_0:2;
                    then IC Comput(ProgramPart(t2),t2,kn) + 1 = IC Comput(
ProgramPart(t4),t4,kn) by A1,A18,A27,A31,A32,A25,A22,SCMPDS_7:34;
                    then
A49:                IC Comput(ProgramPart(t3),t3,k) = (lm+1) by A48,t,AMI_1:51;
                    IC Comput(ProgramPart(t2),t2,kn) in dom pI by A30,
SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:70;
                    then lm < card I()+1 by SCMPDS_5:7;
                    then
A50:                lm+1 <= card I() +1 by INT_1:20;
                    card I() + 1 < card I() + 3 by XREAL_1:8;
                    then lm+1 < card I() +3 by A50,XXREAL_0:2;
                    then lm+1 < card pWHL by Lm1;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A49,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A51:            k=m3;
                l1 in dom pWHL by A20,SCMPDS_6:18;
                hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A1,A18,A27
,A31,A32,A25,A22,A34,A51,SCMPDS_7:36;
              end;
            end;
          end;
          suppose
            k >= m3+1;
            then consider nn be Nat such that
A52:        k=m3+1+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
 ProgramPart t3 = ProgramPart t7
by AMI_1:123;
then
            Comput(ProgramPart(t3),t3,k)=Comput(ProgramPart(t7+*iWHL),t7+*iWHL,
nn) by A37,A52,AMI_1:51;
            hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A45,
SCMPDS_6:def 2;
          end;
        end;
        hence WHL is_closed_on t by SCMPDS_6:def 2;
        WHL is_halting_on t7 by A6,A29,A44,A40,A41;
        then ProgramPart t7 halts_on t7 by A37,SCMPDS_6:def 3;
        then ProgramPart t3 halts_on t7 by AMI_1:123;
        then ProgramPart t3 halts_on t3 by AMI_1:93;
        hence WHL is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  set n=F(Dstate s());
  thus F(s())=F(s()) or P[s()];
A53: Q[0]
  proof
    let t be State of SCMPDS;
    assume that
A54: F(Dstate(t)) <= 0 and
A55: P[Dstate t] and
A56: t.a()=s().a();
    F(Dstate(t))=0 by A54;
    then t.b >= 0 by A2,A55;
    hence thesis by A56,Th9;
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A53,A5);
  then Q[n];
  hence thesis by A3;
end;

scheme
  WhileLExec { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
P[State of SCMPDS]}: (F(s())=F(s()) or P[s()]) & IExec(while<0(a(),i(),I()),s()
  ) = IExec(while<0(a(),i(),I()),IExec(I(),s()))
provided
A1: card I() > 0 and
A2: s().DataLoc(s().a(),i()) < 0 and
A3: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.
DataLoc(s().a(),i()) >= 0 and
A4: P[Dstate s()] and
A5: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) < 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
]
proof
  set WHL=while<0(a(),i(),I()), iWHL=Initialized stop WHL, iI= Initialized
  stop I(), s1= s() +* iWHL, ps= ProgramPart s();
  set sI= s() +* iI, m1=LifeSpan(ProgramPart(sI),sI)+2, s2=IExec(I(),s()) +*
iWHL, m2=LifeSpan(ProgramPart s2,
  s2);
A6: P[Dstate s()] by A4;
A7: iI c= sI by FUNCT_4:26;
  I() is_closed_on s() by A2,A4,A5;
  then
A8: I() is_closed_on sI by SCMPDS_6:38;
  I() is_halting_on s() by A2,A4,A5;
  then
A9: ProgramPart sI halts_on sI by SCMPDS_6:def 3;
  sI = sI+*iI by A7,FUNCT_4:79;
  then ProgramPart(sI+*iI) halts_on sI+*iI by A9;
  then
A10: I() is_halting_on sI by SCMPDS_6:def 3;
  set Es=IExec(I(),s()), bj=DataLoc(Es.a(),i());
  deffunc U(State of SCMPDS) = F($1);
A11: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(s().
  a(),i()) < 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & U(Dstate IExec(I(),t)) < U(Dstate t) & P[Dstate(IExec(I(),t))
  ] by A5;
A12: for t be State of SCMPDS st P[Dstate t] & U(Dstate(t))=0 holds t.DataLoc
  (s().a(),i()) >= 0 by A3;
  (U(s())=U(s()) or P[s()]) & WHL is_closed_on s() & WHL is_halting_on s()
  from WhileLHalt(A1,A12,A6,A11);
  then
A13: ProgramPart s1 halts_on s1 by SCMPDS_6:def 3;
  deffunc U(State of SCMPDS) = F($1);
A14: IExec(I(), s()).a()=s().a() by A2,A4,A5;
  then
A15: for t be State of SCMPDS st P[Dstate(t)] & U(Dstate(t))=0 holds t.bj >=
  0 by A3;
A16: for t being State of SCMPDS st P[Dstate t] & t.a()=Es.a() & t.bj < 0
  holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I() is_halting_on t & U(
  Dstate IExec(I(),t)) < U(Dstate t) & P[Dstate(IExec(I(),t))] by A5,A14;
A17: P[Dstate Es] by A2,A4,A5;
  (U(Es)=U(Es) or P[Es]) & WHL is_closed_on Es & WHL is_halting_on Es
  from WhileLHalt(A1,A15,A17,A16);
  then
A18: ProgramPart s2 halts_on s2 by SCMPDS_6:def 3;
  set s4 = Comput(ProgramPart(s1),s1,1);
  set i1=(a(),i())>=0_goto (card I()+2), i2=goto -(card I()+1);
  set b=DataLoc(s().a(),i());
A19: WHL = i1 ';' (I() ';' i2) by SCMPDS_4:51;
  set mI=LifeSpan(ProgramPart(sI),sI), s5=Comput(ProgramPart(s4),s4,mI), l1= (
card I() + 1);
A20: IC s1 = 0 by SCMPDS_6:21;
A21: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by AMI_1:14
    .= Following(ProgramPart s1,s1) by AMI_1:13
    .= Exec(i1,s1) by A19,SCMPDS_6:22;
A22: DataPart sI = DataPart s1 by SCMPDS_4:24,36;
  now
    let a;
    thus sI.a = s1.a by A22,SCMPDS_4:23
      .= s4.a by A21,SCMPDS_2:69;
  end;
  then
A23: DataPart sI = DataPart s4 by SCMPDS_4:23;
  set m3=mI +1;
  set s6=Comput(ProgramPart(s1),s1,m3);
  card I() + 1 < card I() + 2 by XREAL_1:8;
  then
A24: l1 in dom WHL by Th7;
  thus F(s())=F(s()) or P[s()];
  set m0=LifeSpan(ProgramPart(s1),s1);
A25: dom ps = dom s() /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
A26: IExec(I(),s()) | A= (Result(ProgramPart(sI),sI) +* ps) | A by
SCMPDS_4:def 8
    .= ps by A25,FUNCT_4:24;
  set s7=Comput(ProgramPart(s1),s1,m3+1);
A27: IExec(I(),s()) = Result(ProgramPart(sI),sI) +* s() | A by SCMPDS_4:def 8;
A28: dom ProgramPart s() = A by AMI_1:143;
  WHL c= iWHL & iWHL c= s1 by FUNCT_4:26,SCMPDS_6:17;
  then
A29: WHL c= s1 by XBOOLE_1:1;
  Shift(I(),1) c= WHL by Lm2;
  then Shift(I(),1) c= s1 by A29,XBOOLE_1:1;
  then
A30: Shift(I(),1) c= s4 by AMI_1:81;
  s1.DataLoc(s1.a(),i())=s1.b by SCMPDS_5:19
    .= s().b by SCMPDS_5:19;
  then
A31: IC s4 = succ IC s1 by A2,A21,SCMPDS_2:69
    .= (0+1) by A20;
  then
A32: IC s5=l1 by A1,A7,A10,A8,A23,A30,SCMPDS_7:36;
Y:  (ProgramPart s6)/.IC s6
 = s6.IC s6 by AMI_1:150;
 ProgramPart s1 = ProgramPart s4
by AMI_1:123;
 then
A33: s6=s5 by AMI_1:51;
  then
A34: CurInstr(ProgramPart s6,s6)=s5.l1 by A1,A7,A10,A8,A31,A23,A30,Y,
SCMPDS_7:36
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=WHL.l1 by A24,A29,GRFUNC_1:8
    .=i2 by Th8;
T: ProgramPart s1 = ProgramPart s6
by AMI_1:123;
A35: s7 = Following(ProgramPart s1,s6) by AMI_1:14
    .= Exec(i2,s6) by A34,T;
  then IC s7=ICplusConst(s6,0-(card I()+1)) by SCMPDS_2:66
    .= 0 by A32,A33,SCMPDS_7:1;
  then
A36: IC s2 =IC Comput(ProgramPart(s1),s1,m1) by SCMPDS_6:21;
A37: DataPart Comput(ProgramPart(sI),sI,mI) = DataPart s5 by A1,A7,A10,A8,A31
,A23,A30,SCMPDS_7:36;
  now
    let x be Int_position;
A38: not x in dom iWHL by SCMPDS_4:31;
A39: not x in dom (s() | A) by A28,SCMPDS_2:53;
    s5.x=Comput(ProgramPart(sI),sI,mI).x by A37,SCMPDS_4:23
      .=(Result(ProgramPart(sI),sI)).x by A9,AMI_1:122
      .=IExec(I(),s()).x by A27,A39,FUNCT_4:12;
    hence s7.x=IExec(I(),s()).x by A33,A35,SCMPDS_2:66
      .=s2.x by A38,FUNCT_4:12;
  end;
  then
A40: DataPart s7 = DataPart s2 by SCMPDS_4:23;
TX: ProgramPart(s1) = ProgramPart Comput(ProgramPart(s1),s1,m1)
by AMI_1:123;
  ProgramPart s2
     =ProgramPart (Result(ProgramPart(sI),sI) +* ps +* iWHL) by SCMPDS_4:def 8
    .=ProgramPart (Result(ProgramPart(sI),sI) +* ps) +* ProgramPart iWHL
         by FUNCT_4:75
    .= ps +* ProgramPart iWHL by A25,FUNCT_4:24
    .= ProgramPart s1 by FUNCT_4:75
    .= ProgramPart Comput(ProgramPart(s1),s1,m1) by AMI_1:123;
  then
A41: Comput(ProgramPart(s1),s1,m1)=s2 by A40,A36,SCMPDS_7:7;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1))=i1
   by A19,TX,SCMPDS_6:22;
  then m0 > m1 by A13,SCMPDS_6:2,31;
  then consider nn be Nat such that
A42: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
T: ProgramPart s1 = ProgramPart s2
by A41,AMI_1:123;
  Comput(ProgramPart(s1),s1,m1+m2) = Comput(ProgramPart(s1),s2,m2) by A41,
AMI_1:51;
  then CurInstr(ProgramPart s1 ,Comput(ProgramPart(s1),s1,m1+m2))
   = halt SCMPDS by A18,T,AMI_1:def 46;
  then m1 + m2 >= m0 by A13,AMI_1:def 46;
  then
A43: m2 >= nn by A42,XREAL_1:8;
A44: Comput(ProgramPart(s1),s1,m0) = Comput(ProgramPart(s1),s2,nn) by A41,A42,
AMI_1:51;
  then CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,nn))
   =halt SCMPDS by A13,T,AMI_1:def 46;
  then nn >= m2 by A18,AMI_1:def 46;
  then nn=m2 by A43,XXREAL_0:1;
  then Result(ProgramPart(s1),s1) = Comput(ProgramPart(s2),s2,m2) by A13,A44,T,
AMI_1:122;
  hence IExec(WHL,s()) = Comput(ProgramPart(s2),s2,m2) +* ps by SCMPDS_4:def 8
    .= Result(ProgramPart(s2),s2) +* IExec(I(),s()) | A by A18,A26,AMI_1:122
    .= IExec(WHL,IExec(I(),s())) by SCMPDS_4:def 8;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable Program of
SCMPDS , a be Int_position, i be Integer,X be set, f being Function of product
the Object-Kind of SCMPDS,NAT st card I > 0 & ( for t be State of SCMPDS st f.
Dstate(t)=0 holds t.DataLoc(s.a,i) >= 0 ) & (for t be State of SCMPDS st (for x
be Int_position st x in X holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) < 0 holds
  IExec(I,t).a=t.a & f.Dstate(IExec(I,t)) < f.Dstate(t) & I is_closed_on t & I
is_halting_on t & for x be Int_position st x in X holds IExec(I,t).x=t.x) holds
  while<0(a,i,I) is_closed_on s & while<0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
Int_position, i be Integer,X be set,f be Function of product the Object-Kind of
  SCMPDS,NAT;
  set b=DataLoc(s.a,i);
  set WHL=while<0(a,i,I), pWHL=stop WHL, iWHL=Initialized pWHL, pI=stop I, IsI
  = Initialized pI;
  set i1=(a,i)>=0_goto (card I+2), i2=goto -(card I+1);
  assume
A1: card I > 0;
  defpred P[Element of NAT] means for t be State of SCMPDS st f.Dstate(t) <=
  $1 & (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a holds WHL
  is_closed_on t & WHL is_halting_on t;
  assume
A2: for t be State of SCMPDS st f.Dstate(t)=0 holds t.b >= 0;
  assume
A3: for t be State of SCMPDS st (for x st x in X holds t.x=s.x) & t.a=s.
  a & t.b < 0 holds IExec(I,t).a=t.a & f.Dstate(IExec(I,t)) < f.Dstate(t) & I
  is_closed_on t & I is_halting_on t & for x st x in X holds IExec(I,t).x=t.x;
A4: for k be Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A5: P[k];
    now
      let t be State of SCMPDS;
      assume
A6:   f.Dstate(t) <= k+1;
      assume
A7:   for x st x in X holds t.x=s.x;
      assume
A8:   t.a=s.a;
      per cases;
      suppose
        t.b >= 0;
        hence WHL is_closed_on t & WHL is_halting_on t by A8,Th9;
      end;
      suppose
A9:     t.b < 0;
A10:    dom ProgramPart t = A by AMI_1:143;
A11: not a in dom (t | A) by A10,SCMPDS_2:53;
A12:    IExec(I,t).a=t.a by A3,A7,A8,A9;
A13:     0 in dom pWHL by SCMPDS_4:75;
A14:    not b in dom iWHL by SCMPDS_4:31;
A15:    WHL = i1 ';' (I ';' i2) by SCMPDS_4:51;
A16:    f.Dstate(IExec(I,t)) < f.Dstate(t) by A3,A7,A8,A9;
A17:    dom ProgramPart t = A by AMI_1:143;
        set t2 = t +* IsI, t3 = t +* iWHL, t4 = Comput(ProgramPart(t3),t3,1);
A18:    IsI c= t2 by FUNCT_4:26;
A19:    Comput(ProgramPart(t3),t3,0+1) = Following(ProgramPart t3,
Comput(ProgramPart(t3),t3,0)) by AMI_1:14
          .= Following(ProgramPart t3,t3) by AMI_1:13
          .= Exec(i1,t3) by A15,SCMPDS_6:22;
A20:    DataPart t2 = DataPart t3 by SCMPDS_4:24,36;
        now
          let a;
          thus t2.a = t3.a by A20,SCMPDS_4:23
            .= t4.a by A19,SCMPDS_2:69;
        end;
        then
A21:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
        WHL c= iWHL & iWHL c= t3 by FUNCT_4:26,SCMPDS_6:17;
        then
A22:    WHL c= t3 by XBOOLE_1:1;
        Shift(I,1) c= WHL by Lm2;
        then Shift(I,1) c= t3 by A22,XBOOLE_1:1;
        then
A23:    Shift(I,1) c= t4 by AMI_1:81;
        set m2=LifeSpan(ProgramPart(t2),t2), t5=Comput(ProgramPart(t4),t4,m2),
l1= (card I + 1);
A24:    IC t3 = 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6=Comput(ProgramPart(t3),t3,m3);
        set t7=Comput(ProgramPart(t3),t3,m3+1);
        card I + 1 < card I + 2 by XREAL_1:8;
        then
A25:    l1 in dom WHL by Th7;
A26:    I is_closed_on t by A3,A7,A8,A9;
        then
A27:    I is_closed_on t2 by SCMPDS_6:38;
        I is_halting_on t by A3,A7,A8,A9;
        then
A28:    ProgramPart t2 halts_on t2 by SCMPDS_6:def 3;
        t2 = t2+*IsI by A18,FUNCT_4:79;
        then ProgramPart(t2+*IsI) halts_on t2+*IsI by A28;
        then
A29:    I is_halting_on t2 by SCMPDS_6:def 3;
        not a in dom iWHL by SCMPDS_4:31;
        then t3.DataLoc(t3.a,i)= t3.b by A8,FUNCT_4:12
          .= t.b by A14,FUNCT_4:12;
        then
A30:    IC t4 = succ IC t3 by A9,A19,SCMPDS_2:69
          .= (0+1) by A24;
        then
A31:    IC t5=l1 by A1,A18,A29,A27,A21,A23,SCMPDS_7:36;
Y:  (ProgramPart t6)/.IC t6
 = t6.IC t6 by AMI_1:150;
 ProgramPart t3 = ProgramPart t4
by AMI_1:123;
 then
A32:    t6=t5 by AMI_1:51;
        then
A33:    CurInstr(ProgramPart t6,t6)=t5.l1
 by A1,A18,A29,A27,A30,A21,A23,Y,SCMPDS_7:36
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=WHL.l1 by A25,A22,GRFUNC_1:8
          .=i2 by Th8;
A34:    DataPart Comput(ProgramPart(t2),t2,m2) = DataPart t5 by A1,A18,A29,A27
,A30,A21,A23,SCMPDS_7:36;
        then
A35:    DataPart t5 =DataPart Result(ProgramPart(t2),t2) by A28,AMI_1:122
          .= DataPart(Result(ProgramPart(t2),t2) +* t | A) by A17,AMI_2:29
,FUNCT_4:76,SCMPDS_2:100
          .=DataPart IExec(I,t) by SCMPDS_4:def 8;
T: ProgramPart t3 = ProgramPart t6
by AMI_1:123;
A36:    t7 = Following(ProgramPart t3,t6) by AMI_1:14
          .= Exec(i2,t6) by A33,T;
        then IC t7=ICplusConst(t6,0-(card I+1)) by SCMPDS_2:66
          .= 0 by A31,A32,SCMPDS_7:1;
        then
A37:    t7 +* iWHL=t7 by SCMPDS_7:37;
A38:    IExec(I,t) = Result(ProgramPart(t2),t2) +* t | A by SCMPDS_4:def 8;
A39:    now
          let x be Int_position;
          assume
A40:      x in X;
A41: not x in dom (t | A) by A10,SCMPDS_2:53;
          t5.x=Comput(ProgramPart(t2),t2,m2).x by A34,SCMPDS_4:23
            .=(Result(ProgramPart(t2),t2)).x by A28,AMI_1:122
            .=IExec(I,t).x by A38,A41,FUNCT_4:12
            .=t.x by A3,A7,A8,A9,A40
            .=s.x by A7,A40;
          hence t7.x=s.x by A32,A36,SCMPDS_2:66;
        end;
        InsCode i2=0 by SCMPDS_2:21;
        then InsCode i2 in {0,4,5,6} by ENUMSET1:def 2;
        then
A42:    Dstate(t7)=Dstate(t6) by A36,Th3
          .=Dstate(IExec(I,t)) by A35,A32,Th2;
A43:    now
          assume
A44:      f.Dstate(t7) > k;
          f.Dstate(t7) < k+1 by A6,A16,A42,XXREAL_0:2;
          hence contradiction by A44,INT_1:20;
        end;
A45:    t5.a=Comput(ProgramPart(t2),t2,m2).a by A34,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).a by A28,AMI_1:122
          .=s.a by A8,A12,A38,A11,FUNCT_4:12;
T1: ProgramPart t4 = ProgramPart t3
by AMI_1:123;
A46:    t7.a=t6.a by A36,SCMPDS_2:66
          .=s.a by A45,T1,AMI_1:51;
        then
A47:    WHL is_closed_on t7 by A5,A39,A43;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m3+1;
            then
A48:        k <= m3 by INT_1:20;
            hereby
              per cases by A48,NAT_1:8;
              suppose
A49:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A13
,A24,AMI_1:13;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A50:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(ProgramPart(t2),t2,kn) as Element
of NAT;
t: ProgramPart t3 = ProgramPart t4
by AMI_1:123;
                    kn < k by A50,XREAL_1:31;
                    then kn < m2 by A49,XXREAL_0:2;
                    then IC Comput(ProgramPart(t2),t2,kn) + 1 = IC Comput(
ProgramPart(t4),t4,kn) by A1,A18,A29,A27,A30,A21,A23,SCMPDS_7:34;
                    then
A51:                IC Comput(ProgramPart(t3),t3,k) = (lm+1) by A50,t,AMI_1:51;
                    IC Comput(ProgramPart(t2),t2,kn) in dom pI by A26,
SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:70;
                    then lm < card I+1 by SCMPDS_5:7;
                    then
A52:                lm+1 <= card I +1 by INT_1:20;
                    card I + 1 < card I + 3 by XREAL_1:8;
                    then lm+1 < card I +3 by A52,XXREAL_0:2;
                    then lm+1 < card pWHL by Lm1;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A51,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A53:            k=m3;
                l1 in dom pWHL by A25,SCMPDS_6:18;
                hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A1,A18,A29
,A27,A30,A21,A23,A32,A53,SCMPDS_7:36;
              end;
            end;
          end;
          suppose
            k >= m3+1;
            then consider nn be Nat such that
A54:        k=m3+1+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
 ProgramPart t3 = ProgramPart t7
by AMI_1:123;
            then
            Comput(ProgramPart(t3),t3,k)=Comput(ProgramPart(t7+*iWHL),t7+*iWHL,
nn) by A37,A54,AMI_1:51;
            hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A47,
SCMPDS_6:def 2;
          end;
        end;
        hence WHL is_closed_on t by SCMPDS_6:def 2;
        WHL is_halting_on t7 by A5,A46,A39,A43;
        then ProgramPart t7 halts_on t7 by A37,SCMPDS_6:def 3;
        then ProgramPart t3 halts_on t7 by AMI_1:123;
        then ProgramPart t3 halts_on t3 by AMI_1:93;
        hence WHL is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  set n=f.Dstate(s);
A55: P[0]
  proof
    let t be State of SCMPDS;
    assume
    f.Dstate(t) <= 0;
    then f.Dstate(t)=0;
    then
A56: t.b >= 0 by A2;
    assume
    for x st x in X holds t.x=s.x;
    assume
    t.a=s.a;
    hence thesis by A56,Th9;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A55,A4);
  then
A57: P[n];
  for x be Int_position st x in X holds s.x=s.x;
  hence thesis by A57;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable Program of
  SCMPDS, a be Int_position, i be Integer,X be set,f being Function of product
the Object-Kind of SCMPDS,NAT st card I > 0 & s.DataLoc(s.a,i) < 0 & (for t be
  State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i) >= 0 ) & (for t be
State of SCMPDS st (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a &
  t.DataLoc(s.a,i) < 0 holds IExec(I,t).a=t.a & I is_closed_on t & I
is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & for x be Int_position st
x in X holds IExec(I,t).x=t.x) holds IExec(while<0(a,i,I),s) =IExec(while<0(a,i
  ,I),IExec(I,s))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i be Integer,X be set, f be Function of product the Object-Kind
  of SCMPDS,NAT;
  set b=DataLoc(s.a,i);
  assume
A1: card I > 0;
  deffunc F(State of SCMPDS) = f.$1;
  defpred P[State of SCMPDS] means for x st x in X holds $1.x=s.x;
  assume
A2: s.b < 0;
  assume
  for t be State of SCMPDS st f.Dstate(t)=0 holds t.b >= 0;
  then
A3: for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.b >= 0;
  assume
A4: for t be State of SCMPDS st (for x be Int_position st x in X holds t
  .x=s.x) & t.a=s.a & t.b < 0 holds IExec(I,t).a=t.a & I is_closed_on t & I
is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & for x be Int_position st
  x in X holds IExec(I,t).x=t.x;
A5: now
    let t be State of SCMPDS;
    set v=Dstate t;
    assume that
A6: P[v] and
A7: t.a=s.a & t.b < 0;
    set It=IExec(I,t);
A8: now
      let x;
      assume
      x in X;
      then v.x =s.x by A6;
      hence t.x=s.x by Th4;
    end;
    hence It.a=t.a & I is_closed_on t & I is_halting_on t & F(Dstate It) < F(
    Dstate t) by A4,A7;
    thus P[Dstate It]
    proof
      set v=Dstate It;
      hereby
        let x;
        assume
A9:     x in X;
        then It.x=t.x by A4,A7,A8;
        then v.x=t.x by Th4;
        hence v.x=s.x by A8,A9;
      end;
    end;
  end;
A10: P[Dstate s] by Th4;
  (F(s)=F(s) or P[s]) & IExec(while<0(a,i,I),s) =IExec(while<0(a,i,I),
  IExec(I,s)) from WhileLExec(A1,A2,A3,A10,A5);
  hence thesis;
end;

theorem Th15:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a be Int_position, i be Integer,X be set st card I > 0 & (
for t be State of SCMPDS st (for x be Int_position st x in X holds t.x=s.x) & t
.a=s.a & t.DataLoc(s.a,i) < 0 holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i
  ) > t.DataLoc(s.a,i) & I is_closed_on t & I is_halting_on t & for x be
  Int_position st x in X holds IExec(I,t).x=t.x) holds while<0(a,i,I)
  is_closed_on s & while<0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i be Integer,X be set;
  set b=DataLoc(s.a,i);
  set WHL=while<0(a,i,I), pWHL=stop WHL, iWHL=Initialized pWHL, pI=stop I, IsI
  = Initialized pI;
  set i1=(a,i)>=0_goto (card I+2), i2=goto -(card I+1);
  assume
A1: card I > 0;
  defpred P[Element of NAT] means for t be State of SCMPDS st -t.b <= $1 & (
  for x st x in X holds t.x=s.x) & t.a=s.a holds WHL is_closed_on t & WHL
  is_halting_on t;
  assume
A2: for t be State of SCMPDS st (for x st x in X holds t.x=s.x) & t.a=s.
a & t.b < 0 holds IExec(I,t).a=t.a & IExec(I,t).b > t.b & I is_closed_on t & I
  is_halting_on t & for x st x in X holds IExec(I,t).x=t.x;
A3: for k be Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A4: P[k];
    now
      let t be State of SCMPDS;
      assume
A5:   -t.b <= k+1;
      assume
A6:   for x st x in X holds t.x=s.x;
      assume
A7:   t.a=s.a;
      per cases;
      suppose
        t.b >= 0;
        hence WHL is_closed_on t & WHL is_halting_on t by A7,Th9;
      end;
      suppose
A8:     t.b < 0;
A9:     dom ProgramPart t = A by AMI_1:143;
A10: not a in dom (t | A) by A9,SCMPDS_2:53;
A11: not b in dom (t | A) by A9,SCMPDS_2:53;
A12:    IExec(I,t).b > t.b by A2,A6,A7,A8;
A13:     0 in dom pWHL by SCMPDS_4:75;
A14:    IExec(I,t).a=t.a by A2,A6,A7,A8;
A15:    not b in dom iWHL by SCMPDS_4:31;
A16:    WHL = i1 ';' (I ';' i2) by SCMPDS_4:51;
        set t2 = t +* IsI, t3 = t +* iWHL, t4 = Comput(ProgramPart(t3),t3,1);
A17:    IsI c= t2 by FUNCT_4:26;
A18:    Comput(ProgramPart(t3),t3,0+1) = Following(ProgramPart t3,
Comput(ProgramPart(t3),t3,0)) by AMI_1:14
          .= Following(ProgramPart t3,t3) by AMI_1:13
          .= Exec(i1,t3) by A16,SCMPDS_6:22;
A19:    DataPart t2 = DataPart t3 by SCMPDS_4:24,36;
        now
          let a;
          thus t2.a = t3.a by A19,SCMPDS_4:23
            .= t4.a by A18,SCMPDS_2:69;
        end;
        then
A20:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
        WHL c= iWHL & iWHL c= t3 by FUNCT_4:26,SCMPDS_6:17;
        then
A21:    WHL c= t3 by XBOOLE_1:1;
        Shift(I,1) c= WHL by Lm2;
        then Shift(I,1) c= t3 by A21,XBOOLE_1:1;
        then
A22:    Shift(I,1) c= t4 by AMI_1:81;
        set m2=LifeSpan(ProgramPart(t2),t2), t5=Comput(ProgramPart(t4),t4,m2),
l1= (card I + 1);
A23:    IC t3 = 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6=Comput(ProgramPart(t3),t3,m3);
        set t7=Comput(ProgramPart(t3),t3,m3+1);
        card I + 1 < card I + 2 by XREAL_1:8;
        then
A24:    l1 in dom WHL by Th7;
A25:    IExec(I,t) = Result(ProgramPart(t2),t2) +* t | A by SCMPDS_4:def 8;
A26:    I is_closed_on t by A2,A6,A7,A8;
        then
A27:    I is_closed_on t2 by SCMPDS_6:38;
        I is_halting_on t by A2,A6,A7,A8;
        then
A28:    ProgramPart t2 halts_on t2 by SCMPDS_6:def 3;
        t2 = t2+*IsI by A17,FUNCT_4:79;
        then ProgramPart(t2+*IsI) halts_on t2+*IsI by A28;
        then
A29:    I is_halting_on t2 by SCMPDS_6:def 3;
        not a in dom iWHL by SCMPDS_4:31;
        then t3.DataLoc(t3.a,i)= t3.b by A7,FUNCT_4:12
          .= t.b by A15,FUNCT_4:12;
        then
A30:    IC t4 = succ IC t3 by A8,A18,SCMPDS_2:69
          .= (0+1) by A23;
        then
A31:    IC t5=l1 by A1,A17,A29,A27,A20,A22,SCMPDS_7:36;
Y:  (ProgramPart t6)/.IC t6
 = t6.IC t6 by AMI_1:150;
 ProgramPart t3 = ProgramPart t4
by AMI_1:123;
 then
A32:    t6=t5 by AMI_1:51;
        then
A33:    CurInstr(ProgramPart t6,t6)=t5.l1
 by A1,A17,A29,A27,A30,A20,A22,Y,SCMPDS_7:36
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=WHL.l1 by A24,A21,GRFUNC_1:8
          .=i2 by Th8;
A34:    DataPart Comput(ProgramPart(t2),t2,m2) = DataPart t5 by A1,A17,A29,A27
,A30,A20,A22,SCMPDS_7:36;
        then
A35:    t5.a=Comput(ProgramPart(t2),t2,m2).a by SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).a by A28,AMI_1:122
          .=s.a by A7,A14,A25,A10,FUNCT_4:12;
T: ProgramPart t3 = ProgramPart t6
by AMI_1:123;
A36:    t7 = Following(ProgramPart t3,t6) by AMI_1:14
          .= Exec(i2,t6) by A33,T;
        then IC t7=ICplusConst(t6,0-(card I+1)) by SCMPDS_2:66
          .= 0 by A31,A32,SCMPDS_7:1;
        then
A37:    t7 +* iWHL=t7 by SCMPDS_7:37;
A38:    now
          let x be Int_position;
          assume
A39:      x in X;
A40: not x in dom (t | A) by A9,SCMPDS_2:53;
          t5.x=Comput(ProgramPart(t2),t2,m2).x by A34,SCMPDS_4:23
            .=(Result(ProgramPart(t2),t2)).x by A28,AMI_1:122
            .=IExec(I,t).x by A25,A40,FUNCT_4:12
            .=t.x by A2,A6,A7,A8,A39
            .=s.x by A6,A39;
          hence t7.x=s.x by A32,A36,SCMPDS_2:66;
        end;
        t5.b=Comput(ProgramPart(t2),t2,m2).b by A34,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).b by A28,AMI_1:122
          .=IExec(I,t).b by A25,A11,FUNCT_4:12;
        then
A41:    t7.b=IExec(I,t).b by A32,A36,SCMPDS_2:66;
A42:    now
          -t7.b < -t.b by A12,A41,XREAL_1:26;
          then
A43:      -t7.b < k+1 by A5,XXREAL_0:2;
          assume
          -t7.b > k;
          hence contradiction by A43,INT_1:20;
        end;
T1: ProgramPart t4 = ProgramPart t3
by AMI_1:123;
A44:    t7.a=t6.a by A36,SCMPDS_2:66
          .=s.a by A35,T1,AMI_1:51;
        then
A45:    WHL is_closed_on t7 by A4,A38,A42;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m3+1;
            then
A46:        k <= m3 by INT_1:20;
            hereby
              per cases by A46,NAT_1:8;
              suppose
A47:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A13
,A23,AMI_1:13;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A48:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(ProgramPart(t2),t2,kn) as Element
of NAT;
t: ProgramPart t3 = ProgramPart t4
by AMI_1:123;
                    kn < k by A48,XREAL_1:31;
                    then kn < m2 by A47,XXREAL_0:2;
                    then IC Comput(ProgramPart(t2),t2,kn) + 1 = IC Comput(
ProgramPart(t4),t4,kn) by A1,A17,A29,A27,A30,A20,A22,SCMPDS_7:34;
                    then
A49:                IC Comput(ProgramPart(t3),t3,k) = (lm+1) by A48,t,AMI_1:51;
                    IC Comput(ProgramPart(t2),t2,kn) in dom pI by A26,
SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:70;
                    then lm < card I+1 by SCMPDS_5:7;
                    then
A50:                lm+1 <= card I +1 by INT_1:20;
                    card I + 1 < card I + 3 by XREAL_1:8;
                    then lm+1 < card I +3 by A50,XXREAL_0:2;
                    then lm+1 < card pWHL by Lm1;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A49,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A51:            k=m3;
                l1 in dom pWHL by A24,SCMPDS_6:18;
                hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A1,A17,A29
,A27,A30,A20,A22,A32,A51,SCMPDS_7:36;
              end;
            end;
          end;
          suppose
            k >= m3+1;
            then consider nn be Nat such that
A52:        k=m3+1+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
 ProgramPart t3 = ProgramPart t7
by AMI_1:123;
then
            Comput(ProgramPart(t3),t3,k)=Comput(ProgramPart(t7+*iWHL),t7+*iWHL,
nn) by A37,A52,AMI_1:51;
            hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A45,
SCMPDS_6:def 2;
          end;
        end;
        hence WHL is_closed_on t by SCMPDS_6:def 2;
        WHL is_halting_on t7 by A4,A44,A38,A42;
        then ProgramPart t7 halts_on t7 by A37,SCMPDS_6:def 3;
        then ProgramPart t3 halts_on t7 by AMI_1:123;
        then ProgramPart t3 halts_on t3 by AMI_1:93;
        hence WHL is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
A53: P[0]
  proof
    let t be State of SCMPDS;
    assume
    -t.b <= 0;
    then -t.b <= -0;
    then
A54: t.b >= 0 by XREAL_1:26;
    assume
    for x st x in X holds t.x=s.x;
    assume
    t.a=s.a;
    hence thesis by A54,Th9;
  end;
A55: for k being Element of NAT holds P[k] from NAT_1:sch 1(A53,A3);
  per cases;
  suppose
    s.b >= 0;
    hence thesis by Th9;
  end;
  suppose
    s.b <0;
    then reconsider n=-s.b as Element of NAT by INT_1:16;
    ( P[n])& for x be Int_position st x in X holds s.x=s.x by A55;
    hence thesis;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable Program of
SCMPDS , a be Int_position,i be Integer,X be set st s.DataLoc(s.a,i) < 0 & card
I > 0 & (for t be State of SCMPDS st (for x be Int_position st x in X holds t.x
  =s.x) & t.a=s.a & t.DataLoc(s.a,i) < 0 holds IExec(I,t).a=t.a & IExec(I,t).
DataLoc(s.a,i) > t.DataLoc(s.a,i) & I is_closed_on t & I is_halting_on t & for
x be Int_position st x in X holds IExec(I,t).x=t.x) holds IExec(while<0(a,i,I),
  s) =IExec(while<0(a,i,I),IExec(I,s))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i be Integer,X be set;
  set b=DataLoc(s.a,i);
  set WHL=while<0(a,i,I), iWHL=Initialized stop WHL, iI= Initialized stop I,
  s1= s +* iWHL, ps= ProgramPart s;
  set i1=(a,i)>=0_goto (card I+2), i2=goto -(card I+1);
  assume
A1: s.b < 0;
  set Es=IExec(I,s), bj=DataLoc(Es.a,i);
  set sI= s +* iI, m1=LifeSpan(ProgramPart(sI),sI)+2, s2=IExec(I,s) +* iWHL, m2
=LifeSpan(ProgramPart(s2),s2);
  assume
A2: card I > 0;
  assume
A3: for t be State of SCMPDS st (for x st x in X holds t.x=s.x) & t.a=s.
a & t.b < 0 holds IExec(I,t).a=t.a & IExec(I,t).b > t.b & I is_closed_on t & I
  is_halting_on t & for x st x in X holds IExec(I,t).x=t.x;
  then WHL is_halting_on s by A2,Th15;
  then
A4: ProgramPart s1 halts_on s1 by SCMPDS_6:def 3;
A5: iI c= sI by FUNCT_4:26;
A6: for x st x in X holds s.x=s.x;
  then I is_halting_on s by A1,A3;
  then
A7: ProgramPart sI halts_on sI by SCMPDS_6:def 3;
  sI = sI+*iI by A5,FUNCT_4:79;
  then ProgramPart(sI+*iI) halts_on sI+*iI by A7;
  then
A8: I is_halting_on sI by SCMPDS_6:def 3;
A9: Es.a=s.a by A1,A3,A6;
  now
    let t be State of SCMPDS;
    assume that
A10: for x st x in X holds t.x=Es.x and
A11: t.a=Es.a & t.bj < 0;
A12: now
      let x be Int_position;
      assume
A13:  x in X;
      hence t.x=Es.x by A10
        .=s.x by A1,A3,A6,A13;
    end;
    hence IExec(I,t).a=t.a by A3,A9,A11;
    thus IExec(I,t).bj > t.bj by A3,A9,A11,A12;
    thus I is_closed_on t & I is_halting_on t & for x st x in X holds IExec(I,
    t).x=t.x by A3,A9,A11,A12;
  end;
  then WHL is_halting_on Es by A2,Th15;
  then
A14: ProgramPart s2 halts_on s2 by SCMPDS_6:def 3;
  set m0=LifeSpan(ProgramPart(s1),s1);
A15: dom ProgramPart s = A by AMI_1:143;
A16: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
  set s4 = Comput(ProgramPart(s1),s1,1);
A17: IC s1 = 0 by SCMPDS_6:21;
A18: WHL = i1 ';' (I ';' i2) by SCMPDS_4:51;
A19: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by AMI_1:14
    .= Following(ProgramPart s1,s1) by AMI_1:13
    .= Exec(i1,s1) by A18,SCMPDS_6:22;
A20: IExec(I,s) | A= (Result(ProgramPart(sI),sI) +* ps) | A by SCMPDS_4:def 8
    .= ps by A16,FUNCT_4:24;
A21: not b in dom iWHL by SCMPDS_4:31;
  not a in dom iWHL by SCMPDS_4:31;
  then s1.DataLoc(s1.a,i)=s1.b by FUNCT_4:12
    .= s.b by A21,FUNCT_4:12;
  then
A22: IC s4 = succ IC s1 by A1,A19,SCMPDS_2:69
    .= (0+1) by A17;
  set mI=LifeSpan(ProgramPart(sI),sI), s5=Comput(ProgramPart(s4),s4,mI), l1= (
card I + 1);
A23: DataPart sI = DataPart s1 by SCMPDS_4:24,36;
  now
    let a;
    thus sI.a = s1.a by A23,SCMPDS_4:23
      .= s4.a by A19,SCMPDS_2:69;
  end;
  then
A24: DataPart sI = DataPart s4 by SCMPDS_4:23;
  set m3=mI +1;
  set s6=Comput(ProgramPart(s1),s1,m3);
  card I + 1 < card I + 2 by XREAL_1:8;
  then
A25: l1 in dom WHL by Th7;
  set s7=Comput(ProgramPart(s1),s1,m3+1);
A26: IExec(I,s) = Result(ProgramPart(sI),sI) +* s | A by SCMPDS_4:def 8;
  WHL c= iWHL & iWHL c= s1 by FUNCT_4:26,SCMPDS_6:17;
  then
A27: WHL c= s1 by XBOOLE_1:1;
  Shift(I,1) c= WHL by Lm2;
  then Shift(I,1) c= s1 by A27,XBOOLE_1:1;
  then
A28: Shift(I,1) c= s4 by AMI_1:81;
  I is_closed_on s by A1,A3,A6;
  then
A29: I is_closed_on sI by SCMPDS_6:38;
  then
A30: IC s5=l1 by A2,A5,A8,A22,A24,A28,SCMPDS_7:36;
Y:  (ProgramPart s6)/.IC s6
 = s6.IC s6 by AMI_1:150;
 ProgramPart s1 = ProgramPart s4
by AMI_1:123;
 then
A31: s6=s5 by AMI_1:51;
  then
A32: CurInstr(ProgramPart s6,s6)=s5.l1 by A2,A5,A8,A29,A22,A24,A28,Y,
SCMPDS_7:36
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=WHL.l1 by A25,A27,GRFUNC_1:8
    .=i2 by Th8;
T: ProgramPart s1 = ProgramPart s6
by AMI_1:123;
A33: s7 = Following(ProgramPart s1,s6) by AMI_1:14
    .= Exec(i2,s6) by A32,T;
  then IC s7=ICplusConst(s6,0-(card I+1)) by SCMPDS_2:66
    .= 0 by A30,A31,SCMPDS_7:1;
  then
A34: IC s2 =IC Comput(ProgramPart(s1),s1,m1) by SCMPDS_6:21;
A35: DataPart Comput(ProgramPart(sI),sI,mI) = DataPart s5 by A2,A5,A8,A29,A22
,A24,A28,SCMPDS_7:36;
  now
    let x be Int_position;
A36: not x in dom iWHL by SCMPDS_4:31;
A37: not x in dom (s | A) by A15,SCMPDS_2:53;
    s5.x=Comput(ProgramPart(sI),sI,mI).x by A35,SCMPDS_4:23
      .=(Result(ProgramPart(sI),sI)).x by A7,AMI_1:122
      .=IExec(I,s).x by A26,A37,FUNCT_4:12;
    hence s7.x=IExec(I,s).x by A31,A33,SCMPDS_2:66
      .=s2.x by A36,FUNCT_4:12;
  end;
  then
A38: DataPart s7 = DataPart s2 by SCMPDS_4:23;
TX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m1)
by AMI_1:123;
  ProgramPart s2
     = ProgramPart (Result(ProgramPart(sI),sI) +* ps +* iWHL)
              by SCMPDS_4:def 8
    .=ProgramPart (Result(ProgramPart(sI),sI) +* ps) +* ProgramPart iWHL
             by FUNCT_4:75
    .= ps +* ProgramPart iWHL by A16,FUNCT_4:24
    .= ProgramPart s1 by FUNCT_4:75
    .= ProgramPart Comput(ProgramPart(s1),s1,m1) by AMI_1:123;
  then
A39: Comput(ProgramPart(s1),s1,m1)=s2 by A38,A34,SCMPDS_7:7;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1))=i1
   by A18,TX,SCMPDS_6:22;
  then m0 > m1 by A4,SCMPDS_6:2,31;
  then consider nn be Nat such that
A40: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
T: ProgramPart s1 = ProgramPart s2
by A39,AMI_1:123;
  Comput(ProgramPart(s1),s1,m1+m2) = Comput(ProgramPart(s1),s2,m2) by A39,
AMI_1:51;
  then CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,m1+m2))
   = halt SCMPDS by A14,T,AMI_1:def 46;
  then m1 + m2 >= m0 by A4,AMI_1:def 46;
  then
A41: m2 >= nn by A40,XREAL_1:8;
A42: Comput(ProgramPart(s1),s1,m0) = Comput(ProgramPart(s1),s2,nn) by A39,A40,
AMI_1:51;
  then CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,nn))
   =halt SCMPDS by A4,T,AMI_1:def 46;
  then nn >= m2 by A14,AMI_1:def 46;
  then nn=m2 by A41,XXREAL_0:1;
  then Result(ProgramPart(s1),s1) = Comput(ProgramPart(s2),s2,m2) by A4,A42,T,
AMI_1:122;
  hence IExec(WHL,s) = Comput(ProgramPart(s2),s2,m2) +* ps by SCMPDS_4:def 8
    .= Result(ProgramPart(s2),s2) +* IExec(I,s) | A by A14,A20,AMI_1:122
    .= IExec(WHL,IExec(I,s)) by SCMPDS_4:def 8;
end;

begin :: The construction and basic properties of while>0 program

:: while (a,i)>0 do I

definition
  let a be Int_position, i be Integer,I be Program of SCMPDS;
  func while>0(a,i,I) -> Program of SCMPDS equals
  (a,i)<=0_goto (card I +2)
  ';' I ';' goto -(card I+1);
  coherence;
end;

registration
  let I be shiftable Program of SCMPDS,a be Int_position,i be Integer;
  cluster while>0(a,i,I) -> shiftable;
  correctness
  proof
    set WHL=while>0(a,i,I), i1= (a,i)<=0_goto (card I +2);
    reconsider PF= Load i1 ';' I as shiftable Program of SCMPDS;
A1: PF=i1 ';' I by SCMPDS_4:def 4;
    then card PF=card I + 1 by SCMPDS_6:15;
    then card PF+ -(card I+1) =0;
    hence thesis by A1,SCMPDS_4:78;
  end;
end;

registration
  let I be halt-free Program of SCMPDS,a be Int_position,i be Integer;
  cluster while>0(a,i,I) -> halt-free;
  correctness;
end;

theorem Th17:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
  card while>0(a,i,I)= card I +2
proof
  let a be Int_position,i be Integer, I be Program of SCMPDS;
  set i1=(a,i)<=0_goto (card I +2);
  set I4=i1 ';' I;
  thus card while>0(a,i,I)=card I4+1 by SCMP_GCD:8
    .=card I +1 +1 by SCMPDS_6:15
    .=card I + 2;
end;

Lm3: for a be Int_position,i be Integer,I be Program of SCMPDS holds card stop
while>0(a,i,I)= card I+3

proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  thus card stop while>0(a,i,I)= card while>0(a,i,I) +1 by SCMPDS_5:7
    .= card I +2+1 by Th17
    .= card I + 3;
end;

theorem Th18:
  for a be Int_position,i be Integer,m be Element of NAT,I be
  Program of SCMPDS holds m < card I+2 iff  m in dom while>0(a,i,I)
proof
  let a be Int_position,i be Integer,m be Element of NAT, I be Program of
  SCMPDS;
  card while>0(a,i,I)=card I + 2 by Th17;
  hence thesis by AFINSQ_1:70;
end;

theorem Th19:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
while>0(a,i,I). 0=(a,i)<=0_goto (card I +2) & while>0(a,i,I). (card
  I+1)=goto -(card I+1)
proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  set i1=(a,i)<=0_goto (card I +2), i2=goto -(card I+1);
  set I4=i1 ';' I;
  set J5=I ';' i2;
  set WHL=while>0(a,i,I);
  WHL=i1 ';' J5 by SCMPDS_4:51;
  hence WHL. 0=i1 by SCMPDS_6:16;
  card I4=card I+1 by SCMPDS_6:15;
  hence thesis by SCMP_GCD:10;
end;

theorem Th20:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer st s.DataLoc(s.a,i) <= 0 holds while>0(a,i,I)
  is_closed_on s & while>0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer;
  set d1=DataLoc(s.a,i);
  assume
A1: s.d1 <= 0;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
  set WHL=while>0(a,i,I), pWHL=stop WHL, iWHL=Initialized pWHL, s3 = s +* iWHL
  , s4 = Comput(ProgramPart(s3),s3,1);
A2: IC s3 = 0 by SCMPDS_6:21;
A3: not d1 in dom iWHL by SCMPDS_4:31;
  not a in dom iWHL by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
    .= s.d1 by A3,FUNCT_4:12;
A5: WHL = i1 ';' (I ';' i2 ) by SCMPDS_4:51;
  Comput(ProgramPart(s3),s3,0+1) = Following(ProgramPart s3,
  Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i1,s3) by A5,SCMPDS_6:22;
  then
A6: IC s4 = ICplusConst(s3,(card I+2)) by A1,A4,SCMPDS_2:68
    .= (0+(card I+2)) by A2,SCMPDS_6:23;
A7: card WHL=card I+2 by Th17;
  then
A8: (card I+2) in dom pWHL by SCMPDS_6:25;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
  iWHL c= s3 by FUNCT_4:26;
  then pWHL c= s4 by AMI_1:81,SCMPDS_4:57;
  then s4.(card I+2) = pWHL.(card I+2) by A8,GRFUNC_1:8
    .=halt SCMPDS by A7,SCMPDS_6:25;
  then
A9: CurInstr(ProgramPart s4,s4) = halt SCMPDS by A6,Y;
TX: ProgramPart s4 = ProgramPart s3
by AMI_1:123;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:20;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pWHL
      by A8,A6,A9,TX,AMI_1:52;
    end;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by AMI_1:13;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pWHL by A2,SCMPDS_4:75;
    end;
  end;
  hence WHL is_closed_on s by SCMPDS_6:def 2;
  ProgramPart s3 halts_on s3 by A9,TX,AMI_1:146;
  hence thesis by SCMPDS_6:def 3;
end;

theorem Th21:
  for s being State of SCMPDS,I being Program of SCMPDS,a,c being
Int_position, i being Integer st s.DataLoc(s.a,i) <= 0 holds IExec(while>0(a,i,
  I),s) = s +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a,c be Int_position, i be
  Integer;
  set d1=DataLoc(s.a,i);
  set WHL=while>0(a,i,I), pWHL=stop WHL, iWHL=Initialized pWHL, s3 = s +* iWHL
  , s4 = Comput(ProgramPart(s3),s3,1), i1=(a,i)<=0_goto (card I+2), i2=goto -(
card I+1);
  set SAl=Start-At((card I+2),SCMPDS);
A1: IC s3 = 0 by SCMPDS_6:21;
A2: WHL = i1 ';' (I ';' i2) by SCMPDS_4:51;
A3: not d1 in dom iWHL by SCMPDS_4:31;
  not a in dom iWHL by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
    .= s.d1 by A3,FUNCT_4:12;
A5: Comput(ProgramPart(s3),s3,0+1) =
Following(ProgramPart s3,Comput(ProgramPart(s3),s3,0)
)
 by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i1,s3) by A2,SCMPDS_6:22;
  iWHL c= s3 by FUNCT_4:26;
  then
A6: pWHL c= s4 by AMI_1:81,SCMPDS_4:57;
A7: IExec(WHL,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
  assume
  s.d1 <= 0;
  then
A8: IC s4 = ICplusConst(s3,(card I+2)) by A5,A4,SCMPDS_2:68
    .= (0+(card I+2)) by A1,SCMPDS_6:23;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
TX: ProgramPart s4 = ProgramPart s3
by AMI_1:123;
A9: card WHL=card I+2 by Th17;
  then (card I+2) in dom pWHL by SCMPDS_6:25;
  then s4.(card I+2) = pWHL.(card I+2) by A6,GRFUNC_1:8
    .=halt SCMPDS by A9,SCMPDS_6:25;
  then
A10: CurInstr(ProgramPart s4,s4) = halt SCMPDS by A8,Y;
  then
A11: ProgramPart s3 halts_on s3 by TX,AMI_1:146;
A12: CurInstr(ProgramPart s3,s3) = i1 by A2,SCMPDS_6:22;
  now
    let l be Element of NAT;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    assume
    l < 0+1;
    then l=0 by NAT_1:13;
    then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
     = CurInstr(ProgramPart s3,s3) by u;
    hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) <>
     halt SCMPDS by A12,SCMPDS_6:30;
  end;
  then for l be Element of NAT st
   CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan(ProgramPart(s3),s3) = 1 by A10,A11,TX,AMI_1:def 46;
  then
A13: s4 = Result(ProgramPart(s3),s3) by A11,AMI_1:122;
A14: dom ProgramPart s = A by AMI_1:143;
A15: now
    let x be set;
A16: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A17: x in dom IExec(WHL,s);
    per cases by A17,SCMPDS_4:20;
    suppose
A18:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A19:  not x in dom SAl by A16,TARSKI:def 1;
      not x in dom (s | A) by A14,A18,SCMPDS_2:53;
      hence IExec(WHL,s).x = s4.x by A13,A7,FUNCT_4:12
        .= s3.x by A5,A18,SCMPDS_2:68
        .= s.x by A18,SCMPDS_5:19
        .= (s +* SAl).x by A19,FUNCT_4:12;
    end;
    suppose
A20:  x = IC SCMPDS;
      not x in dom (s | A) by A14,A20,AMI_1:48;
      hence IExec(WHL,s).x = (card I + 2) by A8,A13,A7,A20,FUNCT_4:12
        .= (s +* SAl).x by A20,SCMPDS_7:12;
    end;
    suppose
      x is Element of NAT;
      hence IExec(WHL,s).x = (s +* SAl).x by SCMPDS_6:27;
    end;
  end;
  dom IExec(WHL,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A15,FUNCT_1:9;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, i being Integer st s.DataLoc(s.a,i) <= 0 holds IC IExec(while>0(a
  ,i,I),s) =  (card I + 2)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer;
  assume
  s.DataLoc(s.a,i) <= 0;
  then IExec(while>0(a,i,I),s) =s +* Start-At((card I+2),SCMPDS) by Th21;
  hence thesis by FUNCT_4:121;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS, a,b being
Int_position , i being Integer st s.DataLoc(s.a,i) <= 0 holds IExec(while>0(a,i
  ,I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, i be
  Integer;
  assume
  s.DataLoc(s.a,i) <= 0;
  then
A1: IExec(while>0(a,i,I),s) = s +* Start-At((card I+2),SCMPDS) by Th21;
  not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

Lm4: for I being Program of SCMPDS,a being Int_position,i being Integer holds
Shift(I,1) c= while>0(a,i,I)

proof
  let I be Program of SCMPDS,a be Int_position,i be Integer;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
A1: while>0(a,i,I) = i1 ';' I ';' Load i2 by SCMPDS_4:def 5
    .= Load i1 ';' I ';' Load i2 by SCMPDS_4:def 4;
  card Load i1=1 by SCMPDS_5:6;
  hence thesis by A1,SCMPDS_7:16;
end;

scheme
  WhileGHalt { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
  P[State of SCMPDS]}: (F(s())=F(s()) or P[s()]) & while>0(a(),i(),I())
  is_closed_on s() & while>0(a(),i(),I()) is_halting_on s()
provided
A1: card I() > 0 and
A2: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.
DataLoc(s().a(),i()) <= 0 and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) > 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
]
proof
  set i1=(a(),i())<=0_goto (card I()+2), i2=goto -(card I()+1);
  set WHL=while>0(a(),i(),I()), pWHL=stop WHL, iWHL=Initialized pWHL, pI=stop
  I(), IsI= Initialized pI;
  set b=DataLoc(s().a(),i());
  defpred Q[Element of NAT] means for t be State of SCMPDS st F(Dstate(t)) <=
$1 & P[Dstate t] & t.a()=s().a() holds WHL is_closed_on t & WHL is_halting_on t
  ;
A5: for k be Element of NAT st Q[k] holds Q[k + 1]
  proof
    let k be Element of NAT;
    assume
A6: Q[k];
    now
      let t be State of SCMPDS;
      assume
A7:   F(Dstate(t)) <= k+1;
      assume
A8:   P[Dstate t];
      assume
A9:   t.a()=s().a();
      per cases;
      suppose
        t.b <= 0;
        hence WHL is_closed_on t & WHL is_halting_on t by A9,Th20;
      end;
      suppose
A10:    t.b > 0;
A11:    dom ProgramPart t = A by AMI_1:143;
A12:  not a() in dom (t | A) by A11,SCMPDS_2:53;
A13:    IExec(I(),t).a()=t.a() by A4,A8,A9,A10;
A14:     0 in dom pWHL by SCMPDS_4:75;
A15:    dom ProgramPart t = A by AMI_1:143;
A16:    not b in dom iWHL by SCMPDS_4:31;
A17:    WHL = i1 ';' (I() ';' i2) by SCMPDS_4:51;
        set t2 = t +* IsI, t3 = t +* iWHL, t4 = Comput(ProgramPart(t3),t3,1);
A18:    IsI c= t2 by FUNCT_4:26;
        set m2=LifeSpan(ProgramPart(t2),t2), t5=Comput(ProgramPart(t4),t4,m2),
l1= (card I() + 1
);
A19:    IC t3 = 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6=Comput(ProgramPart(t3),t3,m3);
        set t7=Comput(ProgramPart(t3),t3,m3+1);
        card I() + 1 < card I() + 2 by XREAL_1:8;
        then
A20:    l1 in dom WHL by Th18;
        WHL c= iWHL & iWHL c= t3 by FUNCT_4:26,SCMPDS_6:17;
        then
A21:    WHL c= t3 by XBOOLE_1:1;
        Shift(I(),1) c= WHL by Lm4;
        then Shift(I(),1) c= t3 by A21,XBOOLE_1:1;
        then
A22:    Shift(I(),1) c= t4 by AMI_1:81;
A23:    Comput(ProgramPart(t3),t3,0+1) = Following(ProgramPart t3,
Comput(ProgramPart(t3),t3,0)) by AMI_1:14
          .= Following(ProgramPart t3,t3) by AMI_1:13
          .= Exec(i1,t3) by A17,SCMPDS_6:22;
A24:    DataPart t2 = DataPart t3 by SCMPDS_4:24,36;
        now
          let a;
          thus t2.a = t3.a by A24,SCMPDS_4:23
            .= t4.a by A23,SCMPDS_2:68;
        end;
        then
A25:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
        I() is_halting_on t by A4,A8,A9,A10;
        then
A26:    ProgramPart t2 halts_on t2 by SCMPDS_6:def 3;
        t2 = t2+*IsI by A18,FUNCT_4:79;
        then ProgramPart(t2+*IsI) halts_on t2+*IsI by A26;
        then
A27:    I() is_halting_on t2 by SCMPDS_6:def 3;
A28:    IExec(I(),t) = Result(ProgramPart(t2),t2) +* t | A by SCMPDS_4:def 8;
A29:    P[Dstate(IExec(I(),t))] by A4,A8,A9,A10;
A30:    I() is_closed_on t by A4,A8,A9,A10;
        then
A31:    I() is_closed_on t2 by SCMPDS_6:38;
        not a() in dom iWHL by SCMPDS_4:31;
        then t3.DataLoc(t3.a(),i())= t3.b by A9,FUNCT_4:12
          .= t.b by A16,FUNCT_4:12;
        then
A32:    IC t4 = succ IC t3 by A10,A23,SCMPDS_2:68
          .= (0+1) by A19;
        then
A33:    IC t5=l1 by A1,A18,A27,A31,A25,A22,SCMPDS_7:36;
Y:  (ProgramPart t6)/.IC t6
 = t6.IC t6 by AMI_1:150;
 ProgramPart t3 = ProgramPart t4
by AMI_1:123;
 then
A34:    t6=t5 by AMI_1:51;
        then
A35:    CurInstr(ProgramPart t6,t6)=t5.l1
 by A1,A18,A27,A31,A32,A25,A22,Y,SCMPDS_7:36
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=WHL.l1 by A20,A21,GRFUNC_1:8
          .=i2 by Th19;
T: ProgramPart t3 = ProgramPart t6
by AMI_1:123;
A36:    t7 = Following(ProgramPart t3,t6) by AMI_1:14
          .= Exec(i2,t6) by A35,T;
        then IC t7=ICplusConst(t6,0-(card I()+1)) by SCMPDS_2:66
          .= 0 by A33,A34,SCMPDS_7:1;
        then
A37:    t7 +* iWHL=t7 by SCMPDS_7:37;
A38:    DataPart Comput(ProgramPart(t2),t2,m2) = DataPart t5 by A1,A18,A27,A31
,A32,A25,A22,SCMPDS_7:36;
        then
A39:    DataPart t5 =DataPart Result(ProgramPart(t2),t2) by A26,AMI_1:122
          .= DataPart(Result(ProgramPart(t2),t2) +* t | A) by A15,AMI_2:29
,FUNCT_4:76,SCMPDS_2:100
          .=DataPart IExec(I(),t) by SCMPDS_4:def 8;
        InsCode i2=0 by SCMPDS_2:21;
        then InsCode i2 in {0,4,5,6} by ENUMSET1:def 2;
        then
A40:    Dstate(t7)=Dstate(t6) by A36,Th3
          .=Dstate(IExec(I(),t)) by A39,A34,Th2;
A41:    now
          F(Dstate(IExec(I(),t))) < F(Dstate(t)) by A4,A8,A9,A10;
          then
A42:      F(Dstate(t7)) < k+1 by A7,A40,XXREAL_0:2;
          assume
          F(Dstate(t7)) > k;
          hence contradiction by A42,INT_1:20;
        end;
A43:    t5.a()=Comput(ProgramPart(t2),t2,m2).a() by A38,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).a() by A26,AMI_1:122
          .=s().a() by A9,A13,A28,A12,FUNCT_4:12;
T1: ProgramPart t4 = ProgramPart t3
by AMI_1:123;
A44:    t7.a()=t6.a() by A36,SCMPDS_2:66
          .=s().a() by A43,T1,AMI_1:51;
        then
A45:    WHL is_closed_on t7 by A6,A29,A40,A41;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m3+1;
            then
A46:        k <= m3 by INT_1:20;
            hereby
              per cases by A46,NAT_1:8;
              suppose
A47:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A14
,A19,AMI_1:13;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A48:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(ProgramPart(t2),t2,kn) as Element
of NAT;
t: ProgramPart t3 = ProgramPart t4
by AMI_1:123;
                    kn < k by A48,XREAL_1:31;
                    then kn < m2 by A47,XXREAL_0:2;
                    then IC Comput(ProgramPart(t2),t2,kn) + 1 = IC Comput(
ProgramPart(t4),t4,kn) by A1,A18,A27,A31,A32,A25,A22,SCMPDS_7:34;
                    then
A49:                IC Comput(ProgramPart(t3),t3,k) = (lm+1) by A48,t,AMI_1:51;
                    IC Comput(ProgramPart(t2),t2,kn) in dom pI by A30,
SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:70;
                    then lm < card I()+1 by SCMPDS_5:7;
                    then
A50:                lm+1 <= card I() +1 by INT_1:20;
                    card I() + 1 < card I() + 3 by XREAL_1:8;
                    then lm+1 < card I() +3 by A50,XXREAL_0:2;
                    then lm+1 < card pWHL by Lm3;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A49,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A51:            k=m3;
                l1 in dom pWHL by A20,SCMPDS_6:18;
                hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A1,A18,A27
,A31,A32,A25,A22,A34,A51,SCMPDS_7:36;
              end;
            end;
          end;
          suppose
            k >= m3+1;
            then consider nn be Nat such that
A52:        k=m3+1+nn by NAT_1:10;
T: ProgramPart t3 = ProgramPart t7
by AMI_1:123;
A53:        nn in NAT by ORDINAL1:def 13;
            then Comput(ProgramPart(t3),t3,k)=Comput(ProgramPart(t7+*iWHL),t7+*
iWHL,nn) by A37,A52,T,AMI_1:51
;
            hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A45,A53,
SCMPDS_6:def 2;
          end;
        end;
        hence WHL is_closed_on t by SCMPDS_6:def 2;
        WHL is_halting_on t7 by A6,A29,A44,A40,A41;
        then ProgramPart t7 halts_on t7 by A37,SCMPDS_6:def 3;
        then ProgramPart t3 halts_on t7 by AMI_1:123;
        then ProgramPart t3 halts_on t3 by AMI_1:93;
        hence WHL is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  set n=F(Dstate s());
  thus F(s())=F(s()) or P[s()];
A54: Q[0]
  proof
    let t be State of SCMPDS;
    assume that
A55: F(Dstate(t)) <= 0 and
A56: P[Dstate t] and
A57: t.a()=s().a();
    F(Dstate(t))=0 by A55;
    then t.b <= 0 by A2,A56;
    hence thesis by A57,Th20;
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A54,A5);
  then Q[n];
  hence thesis by A3;
end;

scheme
  WhileGExec { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
P[State of SCMPDS]}: (F(s())=F(s()) or P[s()]) & IExec(while>0(a(),i(),I()),s()
  ) = IExec(while>0(a(),i(),I()),IExec(I(),s()))
provided
A1: card I() > 0 and
A2: s().DataLoc(s().a(),i()) > 0 and
A3: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.
DataLoc(s().a(),i()) <= 0 and
A4: P[Dstate s()] and
A5: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) > 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
]
proof
  set WHL=while>0(a(),i(),I()), iWHL=Initialized stop WHL, iI= Initialized
  stop I(), s1= s() +* iWHL, ps= ProgramPart s();
  set sI= s() +* iI, m1=LifeSpan(ProgramPart(sI),sI)+2, s2=IExec(I(),s()) +*
iWHL, m2=LifeSpan(ProgramPart s2,
  s2);
A6: P[Dstate s()] by A4;
A7: iI c= sI by FUNCT_4:26;
  I() is_closed_on s() by A2,A4,A5;
  then
A8: I() is_closed_on sI by SCMPDS_6:38;
  I() is_halting_on s() by A2,A4,A5;
  then
A9: ProgramPart sI halts_on sI by SCMPDS_6:def 3;
  sI = sI+*iI by A7,FUNCT_4:79;
  then ProgramPart(sI+*iI) halts_on sI+*iI by A9;
  then
A10: I() is_halting_on sI by SCMPDS_6:def 3;
  set Es=IExec(I(),s()), bj=DataLoc(Es.a(),i());
  deffunc U(State of SCMPDS) = F($1);
A11: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(s().
  a(),i()) > 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & U(Dstate IExec(I(),t)) < U(Dstate t) & P[Dstate(IExec(I(),t))
  ] by A5;
A12: for t be State of SCMPDS st P[Dstate t] & U(Dstate(t))=0 holds t.DataLoc
  (s().a(),i()) <= 0 by A3;
  (U(s())=U(s()) or P[s()]) & WHL is_closed_on s() & WHL is_halting_on s()
  from WhileGHalt(A1,A12,A6,A11);
  then
A13: ProgramPart s1 halts_on s1 by SCMPDS_6:def 3;
  deffunc U(State of SCMPDS) = F($1);
A14: IExec(I(), s()).a()=s().a() by A2,A4,A5;
  then
A15: for t be State of SCMPDS st P[Dstate t] & U(Dstate(t))=0 holds t.bj <=
  0 by A3;
A16: for t be State of SCMPDS st P[Dstate t] & t.a()=Es.a() & t.bj > 0 holds
  IExec(I(),t).a()=t.a() & I() is_closed_on t & I() is_halting_on t & U(Dstate
  IExec(I(),t)) < U(Dstate t) & P[Dstate(IExec(I(),t))] by A5,A14;
A17: P[Dstate Es] by A2,A4,A5;
  (U(Es)=U(Es) or P[Es]) & WHL is_closed_on Es & WHL is_halting_on Es
  from WhileGHalt(A1,A15,A17,A16);
  then
A18: ProgramPart s2 halts_on s2 by SCMPDS_6:def 3;
  set s4 = Comput(ProgramPart(s1),s1,1);
  set i1=(a(),i())<=0_goto (card I()+2), i2=goto -(card I()+1);
  set b=DataLoc(s().a(),i());
A19: WHL = i1 ';' (I() ';' i2) by SCMPDS_4:51;
  set mI=LifeSpan(ProgramPart(sI),sI), s5=Comput(ProgramPart(s4),s4,mI), l1= (
card I() + 1);
A20: IC s1 = 0 by SCMPDS_6:21;
A21: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by AMI_1:14
    .= Following(ProgramPart s1,s1) by AMI_1:13
    .= Exec(i1,s1) by A19,SCMPDS_6:22;
A22: DataPart sI = DataPart s1 by SCMPDS_4:24,36;
  now
    let a;
    thus sI.a = s1.a by A22,SCMPDS_4:23
      .= s4.a by A21,SCMPDS_2:68;
  end;
  then
A23: DataPart sI = DataPart s4 by SCMPDS_4:23;
  set m3=mI +1;
  set s6=Comput(ProgramPart(s1),s1,m3);
  card I() + 1 < card I() + 2 by XREAL_1:8;
  then
A24: l1 in dom WHL by Th18;
  thus F(s())=F(s()) or P[s()];
  set m0=LifeSpan(ProgramPart(s1),s1);
A25: dom ps = dom s() /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
A26: IExec(I(),s()) | A= (Result(ProgramPart(sI),sI) +* ps) | A by
SCMPDS_4:def 8
    .= ps by A25,FUNCT_4:24;
  set s7=Comput(ProgramPart(s1),s1,m3+1);
A27: IExec(I(),s()) = Result(ProgramPart(sI),sI) +* s() | A by SCMPDS_4:def 8;
A28: dom ProgramPart s() = A by AMI_1:143;
  WHL c= iWHL & iWHL c= s1 by FUNCT_4:26,SCMPDS_6:17;
  then
A29: WHL c= s1 by XBOOLE_1:1;
  Shift(I(),1) c= WHL by Lm4;
  then Shift(I(),1) c= s1 by A29,XBOOLE_1:1;
  then
A30: Shift(I(),1) c= s4 by AMI_1:81;
  s1.DataLoc(s1.a(),i())=s1.b by SCMPDS_5:19
    .= s().b by SCMPDS_5:19;
  then
A31: IC s4 = succ IC s1 by A2,A21,SCMPDS_2:68
    .= (0+1) by A20;
  then
A32: IC s5=l1 by A1,A7,A10,A8,A23,A30,SCMPDS_7:36;
Y:  (ProgramPart s6)/.IC s6
 = s6.IC s6 by AMI_1:150;
 ProgramPart s1 = ProgramPart s4
by AMI_1:123;
 then
A33: s6=s5 by AMI_1:51;
  then
A34: CurInstr(ProgramPart s6,s6)=s5.l1 by A1,A7,A10,A8,A31,A23,A30,Y,
SCMPDS_7:36
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=WHL.l1 by A24,A29,GRFUNC_1:8
    .=i2 by Th19;
T: ProgramPart s1 = ProgramPart s6
by AMI_1:123;
A35: s7 = Following(ProgramPart s1,s6) by AMI_1:14
    .= Exec(i2,s6) by A34,T;
  then IC s7=ICplusConst(s6,0-(card I()+1)) by SCMPDS_2:66
    .= 0 by A32,A33,SCMPDS_7:1;
  then
A36: IC s2 =IC Comput(ProgramPart(s1),s1,m1) by SCMPDS_6:21;
A37: DataPart Comput(ProgramPart(sI),sI,mI) = DataPart s5 by A1,A7,A10,A8,A31
,A23,A30,SCMPDS_7:36;
  now
    let x be Int_position;
A38: not x in dom iWHL by SCMPDS_4:31;
A39: not x in dom (s() | A) by A28,SCMPDS_2:53;
    s5.x=Comput(ProgramPart(sI),sI,mI).x by A37,SCMPDS_4:23
      .=(Result(ProgramPart(sI),sI)).x by A9,AMI_1:122
      .=IExec(I(),s()).x by A27,A39,FUNCT_4:12;
    hence s7.x=IExec(I(),s()).x by A33,A35,SCMPDS_2:66
      .=s2.x by A38,FUNCT_4:12;
  end;
  then
A40: DataPart s7 = DataPart s2 by SCMPDS_4:23;
TX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m1)
by AMI_1:123;
  ProgramPart s2= ProgramPart (Result(ProgramPart(sI),sI) +* ps +* iWHL)
         by SCMPDS_4:def 8
    .=ProgramPart (Result(ProgramPart(sI),sI) +* ps)+* ProgramPart iWHL
           by FUNCT_4:75
    .= ps +* ProgramPart iWHL by A25,FUNCT_4:24
    .= ProgramPart s1 by FUNCT_4:75
    .= ProgramPart Comput(ProgramPart(s1),s1,m1) by AMI_1:123;
  then
A41: Comput(ProgramPart(s1),s1,m1)=s2 by A40,A36,SCMPDS_7:7;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1))=i1
   by A19,TX,SCMPDS_6:22;
  then m0 > m1 by A13,SCMPDS_6:2,30;
  then consider nn be Nat such that
A42: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
T: ProgramPart s1 = ProgramPart s2
by A41,AMI_1:123;
  Comput(ProgramPart(s1),s1,m1+m2) = Comput(ProgramPart(s1),s2,m2) by A41,
AMI_1:51;
  then CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,m1+m2))
   = halt SCMPDS by A18,T,AMI_1:def 46;
  then m1 + m2 >= m0 by A13,AMI_1:def 46;
  then
A43: m2 >= nn by A42,XREAL_1:8;
A44: Comput(ProgramPart(s1),s1,m0) = Comput(ProgramPart(s1),s2,nn) by A41,A42,
AMI_1:51;
  then CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,nn))
   =halt SCMPDS by A13,T,AMI_1:def 46;
  then nn >= m2 by A18,AMI_1:def 46;
  then nn=m2 by A43,XXREAL_0:1;
  then Result(ProgramPart(s1),s1) = Comput(ProgramPart(s2),s2,m2) by A13,A44,T,
AMI_1:122;
  hence IExec(WHL,s()) = Comput(ProgramPart(s2),s2,m2) +* ps by SCMPDS_4:def 8
    .= Result(ProgramPart(s2),s2) +* IExec(I(),s()) | A by A18,A26,AMI_1:122
    .= IExec(WHL,IExec(I(),s())) by SCMPDS_4:def 8;
end;

theorem Th24:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a be Int_position,i,c be Integer,X,Y be set, f being
  Function of product the Object-Kind of SCMPDS,NAT st card I > 0 & ( for t be
State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i) <= 0 ) & (for x st x in
  X holds s.x >= c+s.DataLoc(s.a,i)) & (for t be State of SCMPDS st (for x st x
in X holds t.x >= c+t.DataLoc(s.a,i)) & (for x st x in Y holds t.x=s.x) & t.a=s
  .a & t.DataLoc(s.a,i) > 0 holds IExec(I,t).a=t.a & I is_closed_on t & I
  is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & (for x st x in X holds
IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i)) & for x st x in Y holds IExec(I,t)
  .x=t.x) holds while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,i,c be Integer,X,Y be set, f be Function of product the
  Object-Kind of SCMPDS,NAT;
  set b=DataLoc(s.a,i);
  set WHL=while>0(a,i,I), pWHL=stop WHL, iWHL=Initialized pWHL, pI=stop I, IsI
  = Initialized pI;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
  assume
A1: card I > 0;
  defpred P[Element of NAT] means for t be State of SCMPDS st f.Dstate(t) <=
$1 & (for x st x in X holds t.x >= c+t.b) & (for x st x in Y holds t.x=s.x) & t
  .a=s.a holds WHL is_closed_on t & WHL is_halting_on t;
  assume
A2: for t be State of SCMPDS st f.Dstate(t)=0 holds t.b <= 0;
  assume
A3: for x st x in X holds s.x >= c+s.b;
  assume
A4: for t be State of SCMPDS st (for x st x in X holds t.x >= c+t.b) & (
  for x st x in Y holds t.x=s.x) & t.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & (for
  x st x in X holds IExec(I,t).x >= c+IExec(I,t).b ) & for x st x in Y holds
  IExec(I,t).x=t.x;
A5: for k be Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A6: P[k];
    now
      let t be State of SCMPDS;
      assume
A7:   f.Dstate(t) <= k+1;
      assume
A8:   for x st x in X holds t.x >= c+t.b;
      assume
A9:   for x st x in Y holds t.x=s.x;
      assume
A10:  t.a=s.a;
      per cases;
      suppose
        t.b <= 0;
        hence WHL is_closed_on t & WHL is_halting_on t by A10,Th20;
      end;
      suppose
A11:    t.b > 0;
A12:    dom ProgramPart t = A by AMI_1:143;
A13: not a in dom (t | A) by A12,SCMPDS_2:53;
A14:    IExec(I,t).a=t.a by A4,A8,A9,A10,A11;
A15:     0 in dom pWHL by SCMPDS_4:75;
A16:    dom ProgramPart t = A by AMI_1:143;
A17:    not b in dom iWHL by SCMPDS_4:31;
A18:    WHL = i1 ';' (I ';' i2) by SCMPDS_4:51;
        set t2 = t +* IsI, t3 = t +* iWHL, t4 = Comput(ProgramPart(t3),t3,1);
A19:    IsI c= t2 by FUNCT_4:26;
A20:    Comput(ProgramPart(t3),t3,0+1) = Following(ProgramPart t3,
Comput(ProgramPart(t3),t3,0)) by AMI_1:14
          .= Following(ProgramPart t3,t3) by AMI_1:13
          .= Exec(i1,t3) by A18,SCMPDS_6:22;
A21:    DataPart t2 = DataPart t3 by SCMPDS_4:24,36;
        now
          let a;
          thus t2.a = t3.a by A21,SCMPDS_4:23
            .= t4.a by A20,SCMPDS_2:68;
        end;
        then
A22:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
        WHL c= iWHL & iWHL c= t3 by FUNCT_4:26,SCMPDS_6:17;
        then
A23:    WHL c= t3 by XBOOLE_1:1;
        Shift(I,1) c= WHL by Lm4;
        then Shift(I,1) c= t3 by A23,XBOOLE_1:1;
        then
A24:    Shift(I,1) c= t4 by AMI_1:81;
A25:    IExec(I,t) = Result(ProgramPart(t2),t2) +* t | A by SCMPDS_4:def 8;
        set m2=LifeSpan(ProgramPart(t2),t2), t5=Comput(ProgramPart(t4),t4,m2),
l1= (card I + 1);
A26:    IC t3 = 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6=Comput(ProgramPart(t3),t3,m3);
        set t7=Comput(ProgramPart(t3),t3,m3+1);
        card I + 1 < card I + 2 by XREAL_1:8;
        then
A27:    l1 in dom WHL by Th18;
A28:    I is_closed_on t by A4,A8,A9,A10,A11;
        then
A29:    I is_closed_on t2 by SCMPDS_6:38;
        I is_halting_on t by A4,A8,A9,A10,A11;
        then
A30:    ProgramPart t2 halts_on t2 by SCMPDS_6:def 3;
        t2 = t2+*IsI by A19,FUNCT_4:79;
        then ProgramPart(t2+*IsI) halts_on t2+*IsI by A30;
        then
A31:    I is_halting_on t2 by SCMPDS_6:def 3;
        not a in dom iWHL by SCMPDS_4:31;
        then t3.DataLoc(t3.a,i)= t3.b by A10,FUNCT_4:12
          .= t.b by A17,FUNCT_4:12;
        then
A32:    IC t4 = succ IC t3 by A11,A20,SCMPDS_2:68
          .= (0+1) by A26;
        then
A33:    IC t5=l1 by A1,A19,A31,A29,A22,A24,SCMPDS_7:36;
Y:  (ProgramPart t6)/.IC t6
 = t6.IC t6 by AMI_1:150;
 ProgramPart t3 = ProgramPart t4
by AMI_1:123;
 then
A34:    t6=t5 by AMI_1:51;
        then
A35:    CurInstr(ProgramPart t6,t6)=t5.l1
 by A1,A19,A31,A29,A32,A22,A24,Y,SCMPDS_7:36
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=WHL.l1 by A27,A23,GRFUNC_1:8
          .=i2 by Th19;
T: ProgramPart t3 = ProgramPart t6
by AMI_1:123;
A36:    t7 = Following(ProgramPart t3,t6) by AMI_1:14
          .= Exec(i2,t6) by A35,T;
        then IC t7=ICplusConst(t6,0-(card I+1)) by SCMPDS_2:66
          .= 0 by A33,A34,SCMPDS_7:1;
        then
A37:    t7 +* iWHL=t7 by SCMPDS_7:37;
A38:    DataPart Comput(ProgramPart(t2),t2,m2) = DataPart t5 by A1,A19,A31,A29
,A32,A22,A24,SCMPDS_7:36;
        then
A39:    DataPart t5 =DataPart Result(ProgramPart(t2),t2) by A30,AMI_1:122
          .= DataPart(Result(ProgramPart(t2),t2) +* t | A) by A16,AMI_2:29
,FUNCT_4:76,SCMPDS_2:100
          .=DataPart IExec(I,t) by SCMPDS_4:def 8;
A40:    now
          let x be Int_position;
          assume
A41:      x in Y;
          thus t7.x=t5.x by A34,A36,SCMPDS_2:66
            .=IExec(I,t).x by A39,SCMPDS_3:4
            .=t.x by A4,A8,A9,A10,A11,A41
            .=s.x by A9,A41;
        end;
        InsCode i2=0 by SCMPDS_2:21;
        then InsCode i2 in {0,4,5,6} by ENUMSET1:def 2;
        then
A42:    Dstate(t7)=Dstate(t6) by A36,Th3
          .=Dstate(IExec(I,t)) by A39,A34,Th2;
A43:    now
          f.Dstate(IExec(I,t)) < f.Dstate(t) by A4,A8,A9,A10,A11;
          then
A44:      f.Dstate(t7) < k+1 by A7,A42,XXREAL_0:2;
          assume
          f.Dstate(t7) > k;
          hence contradiction by A44,INT_1:20;
        end;
A45:    t7.b=t5.b by A34,A36,SCMPDS_2:66
          .=IExec(I,t).b by A39,SCMPDS_3:4;
A46:    now
          let x be Int_position;
          assume
A47:      x in X;
          t7.x=t5.x by A34,A36,SCMPDS_2:66
            .=IExec(I,t).x by A39,SCMPDS_3:4;
          hence t7.x >= c+t7.b by A4,A8,A9,A10,A11,A45,A47;
        end;
A48:    t5.a=Comput(ProgramPart(t2),t2,m2).a by A38,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).a by A30,AMI_1:122
          .=s.a by A10,A14,A25,A13,FUNCT_4:12;
T1: ProgramPart t4 = ProgramPart t3
by AMI_1:123;
A49:    t7.a=t6.a by A36,SCMPDS_2:66
          .=s.a by A48,T1,AMI_1:51;
        then
A50:    WHL is_closed_on t7 by A6,A46,A40,A43;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m3+1;
            then
A51:        k <= m3 by INT_1:20;
            hereby
              per cases by A51,NAT_1:8;
              suppose
A52:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A15
,A26,AMI_1:13;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A53:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(ProgramPart(t2),t2,kn) as Element
of NAT;
t: ProgramPart t3 = ProgramPart t4
by AMI_1:123;
                    kn < k by A53,XREAL_1:31;
                    then kn < m2 by A52,XXREAL_0:2;
                    then IC Comput(ProgramPart(t2),t2,kn) + 1 = IC Comput(
ProgramPart(t4),t4,kn) by A1,A19,A31,A29,A32,A22,A24,SCMPDS_7:34;
                    then
A54:                IC Comput(ProgramPart(t3),t3,k) = (lm+1) by A53,t,AMI_1:51;
                    IC Comput(ProgramPart(t2),t2,kn) in dom pI by A28,
SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:70;
                    then lm < card I+1 by SCMPDS_5:7;
                    then
A55:                lm+1 <= card I +1 by INT_1:20;
                    card I + 1 < card I + 3 by XREAL_1:8;
                    then lm+1 < card I +3 by A55,XXREAL_0:2;
                    then lm+1 < card pWHL by Lm3;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A54,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A56:            k=m3;
                l1 in dom pWHL by A27,SCMPDS_6:18;
                hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A1,A19,A31
,A29,A32,A22,A24,A34,A56,SCMPDS_7:36;
              end;
            end;
          end;
          suppose
            k >= m3+1;
            then consider nn be Nat such that
A57:        k=m3+1+nn by NAT_1:10;
T: ProgramPart t3 = ProgramPart t7
by AMI_1:123;
A58:        nn in NAT by ORDINAL1:def 13;
            then Comput(ProgramPart(t3),t3,k)=Comput(ProgramPart(t7+*iWHL),t7+*
iWHL,nn) by A37,A57,T,AMI_1:51
;
            hence IC Comput(ProgramPart(t3),t3,k) in dom pWHL by A50,A58,
SCMPDS_6:def 2;
          end;
        end;
        hence WHL is_closed_on t by SCMPDS_6:def 2;
        WHL is_halting_on t7 by A6,A49,A46,A40,A43;
        then ProgramPart t7 halts_on t7 by A37,SCMPDS_6:def 3;
        then ProgramPart t3 halts_on t7 by AMI_1:123;
        then ProgramPart t3 halts_on t3 by AMI_1:93;
        hence WHL is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  set n=f.Dstate(s);
A59: for x st x in Y holds s.x=s.x;
A60: P[0]
  proof
    let t be State of SCMPDS;
    assume
    f.Dstate(t) <= 0;
    then f.Dstate(t)=0;
    then
A61: t.b <= 0 by A2;
    assume
    for x be Int_position st x in X holds t.x >= c+t.b;
    assume
    for x st x in Y holds t.x=s.x;
    assume
    t.a=s.a;
    hence thesis by A61,Th20;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A60,A5);
  then P[n];
  hence thesis by A3,A59;
end;

theorem Th25:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a be Int_position, i,c be Integer,X,Y be set,f being
  Function of product the Object-Kind of SCMPDS,NAT st s.DataLoc(s.a,i) > 0 &
card I > 0 & ( for t be State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i)
<= 0 ) & (for x st x in X holds s.x >= c+s.DataLoc(s.a,i)) & (for t be State of
SCMPDS st (for x st x in X holds t.x >= c+t.DataLoc(s.a,i)) & (for x st x in Y
  holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0 holds IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & (for
x st x in X holds IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i)) & for x st x in
Y holds IExec(I,t).x=t.x) holds IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),
  IExec(I,s))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,X,Y be set, f be Function of product the
  Object-Kind of SCMPDS,NAT;
  set b=DataLoc(s.a,i);
  set WHL=while>0(a,i,I), iWHL=Initialized stop WHL, iI= Initialized stop I,
  s1= s +* iWHL, ps= ProgramPart s;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
  assume
A1: s.b > 0;
  set s4 = Comput(ProgramPart(s1),s1,1);
A2: IC s1 = 0 by SCMPDS_6:21;
A3: WHL = i1 ';' (I ';' i2) by SCMPDS_4:51;
A4: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by AMI_1:14
    .= Following(ProgramPart s1,s1) by AMI_1:13
    .= Exec(i1,s1) by A3,SCMPDS_6:22;
  set m0=LifeSpan(ProgramPart(s1),s1);
A5: dom ProgramPart s = A by AMI_1:143;
A6: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
  set Es=IExec(I,s), bj=DataLoc(Es.a,i);
  assume
A7: card I > 0;
  assume
A8: for t be State of SCMPDS st f.Dstate(t)=0 holds t.b <= 0;
  assume
A9: for x st x in X holds s.x >= c+s.b;
  assume
A10: for t be State of SCMPDS st (for x st x in X holds t.x >= c+t.b) & (
  for x st x in Y holds t.x=s.x) & t.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & (for
x st x in X holds IExec(I,t).x >= c+IExec(I,t).b) & for x st x in Y holds IExec
  (I,t).x=t.x;
  then WHL is_halting_on s by A7,A8,A9,Th24;
  then
A11: ProgramPart s1 halts_on s1 by SCMPDS_6:def 3;
A12: for x st x in Y holds s.x=s.x;
  then
A13: bj=b by A1,A9,A10;
  set sI= s +* iI, m1=LifeSpan(ProgramPart(sI),sI)+2, s2=IExec(I,s) +* iWHL, m2
=LifeSpan(ProgramPart(s2),s2);
A14: iI c= sI by FUNCT_4:26;
A15: IExec(I, s).a=s.a by A1,A9,A10,A12;
A16: now
    let t be State of SCMPDS;
    assume that
A17: for x st x in X holds t.x >= c+t.bj and
A18: for x st x in Y holds t.x=Es.x and
A19: t.a=Es.a and
A20: t.bj > 0;
A21: now
      let x;
      assume
A22:  x in Y;
      hence t.x=Es.x by A18
        .=s.x by A1,A9,A10,A12,A22;
    end;
    hence IExec(I,t).a=t.a by A10,A15,A17,A19,A20;
A23: t.a=s.a by A1,A9,A10,A12,A19;
    hence I is_closed_on t & I is_halting_on t by A10,A17,A19,A20,A21;
    thus f.Dstate(IExec(I,t)) < f.Dstate(t) by A10,A17,A19,A20,A21,A23;
    thus for x st x in X holds IExec(I,t).x >= c+IExec(I,t).bj by A10,A15,A17
,A19,A20,A21;
    thus for x st x in Y holds IExec(I,t).x=t.x by A10,A17,A19,A20,A21,A23;
  end;
  for x st x in X holds Es.x >= c+Es.bj by A1,A9,A10,A12,A15;
  then WHL is_halting_on Es by A7,A8,A13,A16,Th24;
  then
A24: ProgramPart s2 halts_on s2 by SCMPDS_6:def 3;
A25: DataPart sI = DataPart s1 by SCMPDS_4:24,36;
  now
    let a;
    thus sI.a = s1.a by A25,SCMPDS_4:23
      .= s4.a by A4,SCMPDS_2:68;
  end;
  then
A26: DataPart sI = DataPart s4 by SCMPDS_4:23;
  set mI=LifeSpan(ProgramPart(sI),sI), s5=Comput(ProgramPart(s4),s4,mI), l1= (
card I + 1);
  WHL c= iWHL & iWHL c= s1 by FUNCT_4:26,SCMPDS_6:17;
  then
A27: WHL c= s1 by XBOOLE_1:1;
  set m3=mI +1;
A28: IExec(I,s) = Result(ProgramPart(sI),sI) +* s | A by SCMPDS_4:def 8;
  set s7=Comput(ProgramPart(s1),s1,m3+1);
  set s6=Comput(ProgramPart(s1),s1,m3);
  card I + 1 < card I + 2 by XREAL_1:8;
  then
A29: l1 in dom WHL by Th18;
  Shift(I,1) c= WHL by Lm4;
  then Shift(I,1) c= s1 by A27,XBOOLE_1:1;
  then
A30: Shift(I,1) c= s4 by AMI_1:81;
  I is_halting_on s by A1,A9,A10,A12;
  then
A31: ProgramPart sI halts_on sI by SCMPDS_6:def 3;
  sI = sI+*iI by A14,FUNCT_4:79;
  then ProgramPart(sI+*iI) halts_on sI+*iI by A31;
  then
A32: I is_halting_on sI by SCMPDS_6:def 3;
A33: ProgramPart IExec(I,s)
    = ProgramPart (Result(ProgramPart(sI),sI) +* ps) by SCMPDS_4:def 8
    .= ps by A6,FUNCT_4:24;
A34: not b in dom iWHL by SCMPDS_4:31;
  not a in dom iWHL by SCMPDS_4:31;
  then s1.DataLoc(s1.a,i)=s1.b by FUNCT_4:12
    .= s.b by A34,FUNCT_4:12;
  then
A35: IC s4 = succ IC s1 by A1,A4,SCMPDS_2:68
    .= (0+1) by A2;
  I is_closed_on s by A1,A9,A10,A12;
  then
A36: I is_closed_on sI by SCMPDS_6:38;
  then
A37: IC s5=l1 by A7,A14,A32,A35,A26,A30,SCMPDS_7:36;
Y:  (ProgramPart s6)/.IC s6
 = s6.IC s6 by AMI_1:150;
 ProgramPart s1 = ProgramPart s4
by AMI_1:123;
 then
A38: s6=s5 by AMI_1:51;
  then
A39: CurInstr(ProgramPart s6,s6)=s5.l1
 by A7,A14,A32,A36,A35,A26,A30,Y,SCMPDS_7:36
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=WHL.l1 by A29,A27,GRFUNC_1:8
    .=i2 by Th19;
T: ProgramPart s1 = ProgramPart s6
by AMI_1:123;
A40: s7 = Following(ProgramPart s1,s6) by AMI_1:14
    .= Exec(i2,s6) by A39,T;
  then IC s7=ICplusConst(s6,0-(card I+1)) by SCMPDS_2:66
    .= 0 by A37,A38,SCMPDS_7:1;
  then
A41: IC s2 =IC Comput(ProgramPart(s1),s1,m1) by SCMPDS_6:21;
A42: DataPart Comput(ProgramPart(sI),sI,mI) = DataPart s5 by A7,A14,A32,A36,A35
,A26,A30,SCMPDS_7:36;
  now
    let x be Int_position;
A43: not x in dom iWHL by SCMPDS_4:31;
A44: not x in dom (s | A) by A5,SCMPDS_2:53;
    s5.x=Comput(ProgramPart(sI),sI,mI).x by A42,SCMPDS_4:23
      .=(Result(ProgramPart(sI),sI)).x by A31,AMI_1:122
      .=IExec(I,s).x by A28,A44,FUNCT_4:12;
    hence s7.x=IExec(I,s).x by A38,A40,SCMPDS_2:66
      .=s2.x by A43,FUNCT_4:12;
  end;
  then
A45: DataPart s7 = DataPart s2 by SCMPDS_4:23;
TX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m1)
by AMI_1:123;
  ProgramPart s2
     = ProgramPart (Result(ProgramPart(sI),sI) +* ps +* iWHL)
              by SCMPDS_4:def 8
    .=ProgramPart (Result(ProgramPart(sI),sI) +* ps)+* ProgramPart iWHL
        by FUNCT_4:75
    .= ps +* ProgramPart iWHL by A6,FUNCT_4:24
    .= ProgramPart s1 by FUNCT_4:75
    .= ProgramPart Comput(ProgramPart(s1),s1,m1) by AMI_1:123;
  then
A46: Comput(ProgramPart(s1),s1,m1)=s2 by A45,A41,SCMPDS_7:7;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1))=i1
   by A3,TX,SCMPDS_6:22;
  then m0 > m1 by A11,SCMPDS_6:2,30;
  then consider nn be Nat such that
A47: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
T: ProgramPart s1 = ProgramPart s2
by A46,AMI_1:123;
  Comput(ProgramPart(s1),s1,m1+m2) = Comput(ProgramPart(s1),s2,m2) by A46,
AMI_1:51;
  then CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,m1+m2))
   = halt SCMPDS by A24,T,AMI_1:def 46;
  then m1 + m2 >= m0 by A11,AMI_1:def 46;
  then
A48: m2 >= nn by A47,XREAL_1:8;
A49: Comput(ProgramPart(s1),s1,m0) = Comput(ProgramPart(s1),s2,nn) by A46,A47,
AMI_1:51;
  then CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,nn))
   =halt SCMPDS by A11,T,AMI_1:def 46;
  then nn >= m2 by A24,AMI_1:def 46;
  then nn=m2 by A48,XXREAL_0:1;
  then Result(ProgramPart(s1),s1) = Comput(ProgramPart(s2),s2,m2) by A11,A49,T,
AMI_1:122;
  hence IExec(WHL,s) = Comput(ProgramPart(s2),s2,m2) +* ps by SCMPDS_4:def 8
    .= Result(ProgramPart(s2),s2) +* IExec(I,s) | A by A24,A33,AMI_1:122
    .= IExec(WHL,IExec(I,s)) by SCMPDS_4:def 8;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable Program of
SCMPDS , a be Int_position, i be Integer,X be set, f being Function of product
  the Object-Kind of SCMPDS,NAT st card I > 0 & (for t be State of SCMPDS st f.
Dstate(t)=0 holds t.DataLoc(s.a,i) <= 0 ) & (for t be State of SCMPDS st (for x
st x in X holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0 holds IExec(I,t).a=t.
a & I is_closed_on t & I is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) &
  for x st x in X holds IExec(I,t).x=t.x) holds while>0(a,i,I) is_closed_on s &
while>0(a,i,I) is_halting_on s & (s.DataLoc(s.a,i) > 0 implies IExec(while>0(a,
  i,I),s) =IExec(while>0(a,i,I),IExec(I,s)))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
Int_position, i be Integer,X be set,f be Function of product the Object-Kind of
  SCMPDS,NAT;
  set b=DataLoc(s.a,i);
  assume
A1: card I > 0;
  assume
A2: for t be State of SCMPDS st f.Dstate(t)=0 holds t.b <= 0;
  assume
A3: for t be State of SCMPDS st (for x st x in X holds t.x=s.x) & t.a=s.
a & t.b > 0 holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t & f.
  Dstate(IExec(I,t)) < f.Dstate(t) & for x st x in X holds IExec(I,t).x=t.x;
  then
A4: for t being State of SCMPDS st (for x st x in {} holds t.x >= 0+t.b) & (
  for x st x in X holds t.x=s.x) & t.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & (for
  x st x in {} holds IExec(I,t).x >= 0+IExec(I,t).b) & for x st x in X holds
  IExec(I,t).x=t.x;
A5: for x st x in {} holds s.x >= 0+s.b;
  for t being State of SCMPDS st (for x st x in {} holds t.x >= 0+t.b) & (
  for x st x in X holds t.x=s.x) & t.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & f.Dstate(IExec(I,t)) < f.Dstate(t) & (for
  x st x in {} holds IExec(I,t).x >= 0+IExec(I,t).b) & for x st x in X holds
  IExec(I,t).x=t.x by A3;
  hence
  while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s by A1,A2,A5
,Th24;
  assume
  s.b > 0;
  hence thesis by A1,A2,A5,A4,Th25;
end;

theorem Th27:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a be Int_position, i,c be Integer,X,Y be set st card I > 0 &
  (for x st x in X holds s.x >= c+s.DataLoc(s.a,i)) & (for t be State of SCMPDS
st (for x st x in X holds t.x >= c+t.DataLoc(s.a,i)) & (for x st x in Y holds t
  .x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0 holds IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & IExec(I,t).DataLoc(s.a,i) < t.DataLoc(s.a,
i) & (for x st x in X holds IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i)) & for
  x st x in Y holds IExec(I,t).x=t.x) holds while>0(a,i,I) is_closed_on s &
while>0(a,i,I) is_halting_on s & ( s.DataLoc(s.a,i) > 0 implies IExec(while>0(a
  ,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,X,Y be set;
  set b=DataLoc(s.a,i);
  assume
A1: card I > 0;
  defpred P[State of SCMPDS] means (for x st x in X holds $1.x >= c+$1.b) & (
  for x st x in Y holds $1.x=s.x);
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A2: for s holds (s.b <= 0 implies f.s =0) & (s.b > 0 implies f.s=s.b) by Th5;
  deffunc F(State of SCMPDS) = f.$1;
A3: for t be State of SCMPDS holds F(Dstate t)=0 iff t.b <= 0
  proof
    let t be State of SCMPDS;
    thus F(Dstate t)=0 implies t.b <= 0
    proof
      assume
A4:   F(Dstate t)=0;
      assume
      t.b > 0;
      then (Dstate t).b > 0 by Th4;
      hence contradiction by A2,A4;
    end;
    assume
    t.b <= 0;
    then (Dstate t).b <= 0 by Th4;
    hence thesis by A2;
  end;
  then
A5: for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.b <= 0;
  assume
A6: for x st x in X holds s.x >= c+s.b;
A7: P[Dstate s]
  proof
    set t=Dstate s;
    hereby
      let x;
      assume
      x in X;
      then s.x >= c+s.b by A6;
      then t.x >= c+s.b by Th4;
      hence t.x >= c+t.b by Th4;
    end;
    thus thesis by Th4;
  end;
  assume
A8: for t be State of SCMPDS st (for x st x in X holds t.x >= c+t.b) & (
  for x st x in Y holds t.x=s.x) & t.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I
  is_closed_on t & I is_halting_on t & IExec(I,t).b < t.b & (for x st x in X
holds IExec(I,t).x >= c+IExec(I,t).b) & for x st x in Y holds IExec(I,t).x=t.x;
A9: now
    let t be State of SCMPDS;
    assume that
A10: P[Dstate t] and
A11: t.a=s.a and
A12: t.b > 0;
    set It=IExec(I,t), t2=Dstate It, t1=Dstate t;
    consider v be State of SCMPDS such that
A13: v=Dstate t and
A14: for x st x in X holds v.x >= c+v.b and
A15: for x st x in Y holds v.x=s.x by A10;
A16: now
      let x;
      assume
      x in Y;
      then v.x =s.x by A15;
      hence t.x=s.x by A13,Th4;
    end;
A17: now
      let x;
      assume
      x in X;
      then v.x >= c+v.b by A14;
      then t.x >= c+v.b by A13,Th4;
      hence t.x >= c+t.b by A13,Th4;
    end;
    hence
    IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t by A8,A11,A12,A16;
    thus F(t2) < F(t1)
    proof
      t1.b > 0 by A12,Th4;
      then
A18:  F(t1)=t1.b by A2
        .=t.b by Th4;
      assume
A19:  F(t2) >= F(t1);
      then It.b > 0 by A3,A12,A18;
      then t2.b > 0 by Th4;
      then F(t2)=t2.b by A2
        .=It.b by Th4;
      hence contradiction by A8,A11,A12,A17,A16,A19,A18;
    end;
    thus P[Dstate It]
    proof
      set v=Dstate It;
      hereby
        let x;
        assume
        x in X;
        then It.x >= c+It.b by A8,A11,A12,A17,A16;
        then v.x >= c+It.b by Th4;
        hence v.x >= c+v.b by Th4;
      end;
      hereby
        let x;
        assume
A20:    x in Y;
        then It.x=t.x by A8,A11,A12,A17,A16;
        then v.x=t.x by Th4;
        hence v.x=s.x by A16,A20;
      end;
    end;
  end;
  (F(s)=F(s) or P[s]) & while>0(a,i,I) is_closed_on s & while>0(a,i,I)
  is_halting_on s from WhileGHalt(A1,A5,A7,A9);
  hence while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s;
  assume
A21: s.b > 0;
  (F(s)=F(s) or P[s]) & IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),
  IExec(I,s)) from WhileGExec(A1,A21,A5,A7,A9);
  hence thesis;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable Program of
  SCMPDS , a be Int_position, i be Integer,X be set st card I > 0 & (for t be
State of SCMPDS st (for x st x in X holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i)
> 0 holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t & IExec(I,t).
  DataLoc(s.a,i) < t.DataLoc(s.a,i) & for x st x in X holds IExec(I,t).x=t.x)
  holds while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s & (s.
DataLoc(s.a,i) > 0 implies IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(
  I,s)))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i be Integer,X be set;
  set b=DataLoc(s.a,i);
  assume
A1: card I > 0;
  assume
A2: for t be State of SCMPDS st (for x st x in X holds t.x=s.x) & t.a=s.
  a & t.b > 0 holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
  IExec(I,t).b < t.b & for x st x in X holds IExec(I,t).x=t.x;
  then
A3: for t being State of SCMPDS st (for x st x in {} holds t.x >= 0+t.b) & (
  for x st x in X holds t.x=s.x) & t.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I
  is_closed_on t & I is_halting_on t & IExec(I,t).b < t.b & (for x st x in {}
holds IExec(I,t).x >= 0+IExec(I,t).b) & for x st x in X holds IExec(I,t).x=t.x;
A4: for x st x in {} holds s.x >= 0+s.b;
  for t being State of SCMPDS st (for x st x in {} holds t.x >= 0+t.b) & (
  for x st x in X holds t.x=s.x) & t.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I
  is_closed_on t & I is_halting_on t & IExec(I,t).b < t.b & (for x st x in {}
holds IExec(I,t).x >= 0+IExec(I,t).b) & for x st x in X holds IExec(I,t).x=t.x
  by A2;
  hence
  while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s by A1,A4,Th27;
  assume
  s.b > 0;
  hence thesis by A1,A4,A3,Th27;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable Program of
SCMPDS , a be Int_position, i,c be Integer,X be set st card I > 0 & (for x st x
in X holds s.x >= c+s.DataLoc(s.a,i)) & (for t be State of SCMPDS st (for x st
x in X holds t.x >= c+t.DataLoc(s.a,i)) & t.a=s.a & t.DataLoc(s.a,i) > 0 holds
IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t & IExec(I,t).DataLoc(s.
  a,i) < t.DataLoc(s.a,i) & for x st x in X holds IExec(I,t).x >= c+IExec(I,t).
  DataLoc(s.a,i)) holds while>0(a,i,I) is_closed_on s & while>0(a,i,I)
is_halting_on s & (s.DataLoc(s.a,i) > 0 implies IExec(while>0(a,i,I),s) =IExec(
  while>0(a,i,I),IExec(I,s)))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,X be set;
  set b=DataLoc(s.a,i);
  assume
A1: card I > 0;
  assume
A2: for x st x in X holds s.x >= c+s.b;
  assume
A3: for t be State of SCMPDS st (for x st x in X holds t.x >= c+t.b) & t
.a=s.a & t.b > 0 holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t
  & IExec(I,t).b < t.b & for x st x in X holds IExec(I,t).x >= c+IExec(I,t).b;
  then
  for t being State of SCMPDS st (for x st x in X holds t.x >= c+t.b) & (
for x st x in {} holds t.x=s.x) & t.a=s.a & t.b > 0 holds (IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & IExec(I,t).b < t.b & for x st x in X holds
  IExec(I,t).x >= c+IExec(I,t).b) & for x st x in {} holds IExec(I,t).x=t.x;
  hence
  while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s by A1,A2,Th27;
  assume
A4: s.b > 0;
  for t being State of SCMPDS st (for x st x in X holds t.x >= c+t.b) & (
for x st x in {} holds t.x=s.x) & t.a=s.a & t.b > 0 holds (IExec(I,t).a=t.a & I
is_closed_on t & I is_halting_on t & IExec(I,t).b < t.b & for x st x in X holds
IExec(I,t).x >= c+IExec(I,t).b) & for x st x in {} holds IExec(I,t).x=t.x by A3
  ;
  hence thesis by A1,A2,A4,Th27;
end;

