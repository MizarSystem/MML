:: The Construction and Computation of While-loop Programs for SCMPDS
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies AMI_3, SCMPDS_2, AMI_1, AMI_2, SCMP_GCD, FUNCT_1, SCMPDS_3,
      RELAT_1, AMI_5, CARD_3, INT_1, SCMPDS_4, SCMFSA_9, CARD_1, SCMFSA6A,
      ARYTM_1, SCMFSA_7, SCMPDS_5, UNIALG_2, SCMFSA7B, FUNCT_4, SCMFSA6B,
      SCM_1, RELOC, FUNCT_7, BOOLE, SCMPDS_8, NAT_1;
 notations XBOOLE_0, SUBSET_1, FUNCT_2, NUMBERS, XCMPLX_0, RELAT_1, FUNCT_1,
      FUNCT_4, RECDEF_1, INT_1, NAT_1, STRUCT_0, AMI_1, AMI_2, AMI_3, AMI_5,
      FUNCT_7, SCMPDS_2, SCMPDS_3, CARD_1, SCMPDS_4, SCM_1, SCMPDS_5, SCMPDS_6,
      SCMP_GCD, CARD_3, DOMAIN_1, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, NAT_1, RECDEF_1, SCM_1, AMI_5, SCMPDS_1,
      SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD;
 registrations SUBSET_1, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, ARYTM_3,
      FRAENKEL, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, STRUCT_0,
      AMI_1, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, AMI_3, SCMPDS_2;
 theorems AMI_1, AMI_3, NAT_1, TARSKI, FUNCT_4, FUNCT_1, INT_1, AMI_5,
      SCMPDS_2, AMI_2, SCMPDS_3, GRFUNC_1, SCM_1, SCMFSA6B, SCMPDS_4, SCMPDS_5,
      SCMPDS_6, ENUMSET1, SCMP_GCD, SCMPDS_7, RELAT_1, XBOOLE_1, XREAL_1,
      ORDINAL1, FUNCOP_1, XXREAL_0;
 schemes NAT_1, SCMPDS_4, FUNCT_2;

begin :: Preliminaries

reserve x,a for Int_position,
        s for State of SCMPDS;

set A = the Instruction-Locations of SCMPDS,
    D = SCM-Data-Loc;

theorem Th1:    :: see SCMPDS_3:32
 for a be Int_position ex i being Element of NAT
  st a = intpos i
proof
   let a be Int_position;
        a in D by SCMPDS_2:def 2;
   then consider k be Element of NAT such that
A1: a=2*k + 1 by AMI_2:def 2;
    take k;
    thus intpos k=dl.k by SCMP_GCD:def 1
    .=a by A1;
end;

definition
 let t be State of SCMPDS;
 func Dstate(t) -> State of SCMPDS means
:Def1:  for x be set holds
    (x in SCM-Data-Loc implies it.x = t.x)
    & ( x in the Instruction-Locations of SCMPDS implies it.x = goto 0) &
    (x=IC SCMPDS implies it.x=inspos 0);
 existence
 proof
  deffunc U(Element of NAT) = goto 0;
  deffunc V(Element of NAT) = t.DataLoc($1,0);
  consider s being State of SCMPDS such that
A1: IC s = inspos 0 &
  for i being Element of NAT holds
    s.inspos i = U(i) & s.DataLoc(i,0) = V(i) from SCMPDS_4:sch 1;
    take s;
         now
      let x be set;
      thus x in D implies s.x = t.x
      proof
         assume x in D;
         then x is Int_position by SCMPDS_2:9;
        then consider i be Element of NAT such that
      A2: x=intpos i by Th1;
            x=intpos(i+0) by A2
          .=DataLoc(i,0) by SCMP_GCD:5;
          hence s.x=t.x by A1;
      end;
      thus x in A implies s.x = goto 0
      proof
        assume x in A;
        then reconsider l=x as Instruction-Location of SCMPDS by AMI_1:def 4;
        consider i be Element of NAT such that
      A3: l=inspos i by SCMPDS_3:32;
        thus s.x=goto 0 by A1,A3;
      end;
      thus x=IC SCMPDS implies s.x=inspos 0 by A1,AMI_1:def 15;
    end;
    hence thesis;
 end;
 uniqueness
 proof let s1,s2 be State of SCMPDS such that
A4:  for x be set
   holds (x in D implies s1.x = t.x) & ( x in A implies s1.x = goto 0) &
   ( x=IC SCMPDS implies s1.x=inspos 0) and
A5:  for x be set
   holds (x in D implies s2.x = t.x) & ( x in A implies s2.x = goto 0) &
   (x=IC SCMPDS implies s2.x=inspos 0);

A6: IC s1 = s1.IC SCMPDS by AMI_1:def 15
    .=inspos 0 by A4
    .=s2.IC SCMPDS by A5
    .=IC s2 by AMI_1:def 15;
A7: now
       let a be Int_position;
      A8: a in D by SCMPDS_2:def 2;
      hence s1.a=t.a by A4
      .=s2.a by A5,A8;
     end;
          now
        let i be Instruction-Location of SCMPDS;
        thus s1.i = goto 0 by A4
        .=s2.i by A5;
     end;
     hence s1=s2 by A6,A7,SCMPDS_2:54;
 end;
end;

theorem Th2:
 for t1,t2 being State of SCMPDS st t1|SCM-Data-Loc=t2|SCM-Data-Loc
 holds Dstate(t1)=Dstate(t2)
proof
   let t1,t2 be State of SCMPDS;
   set s1=Dstate(t1),
       s2=Dstate(t2);
   assume A1: t1|D=t2|D;

A2: IC s1 = s1.IC SCMPDS by AMI_1:def 15
    .=inspos 0 by Def1
    .=s2.IC SCMPDS by Def1
    .=IC s2 by AMI_1:def 15;
A3: now
       let a be Int_position;
      A4: a in D by SCMPDS_2:def 2;
      hence s1.a=t1.a by Def1
      .=t2.a by A1,SCMPDS_3:4
      .=s2.a by A4,Def1;
     end;
          now
        let i be Instruction-Location of SCMPDS;
        thus s1.i = goto 0 by Def1
        .=s2.i by Def1;
     end;
     hence s1=s2 by A2,A3,SCMPDS_2:54;
end;

theorem Th3:
 for t being State of SCMPDS,i being Instruction of SCMPDS
 st InsCode i in {0,4,5,6} holds Dstate(t)=Dstate(Exec(i,t))
proof
    let t be State of SCMPDS,i be Instruction of SCMPDS;
    assume InsCode i in {0,4,5,6};
    then Exec(i,t) | D = t | D by SCMPDS_7:20;
    hence thesis by Th2;
end;

theorem Th4:
 (Dstate(s)).a=s.a
proof
     a in D implies (Dstate s).a = s.a by Def1;
    hence thesis by SCMPDS_2:def 2;
end;

theorem Th5:
 for a be Int_position holds
 (ex f be Function of product the Object-Kind of SCMPDS,NAT st
     for s being State of SCMPDS holds
 (s.a <= 0 implies f.s =0) & (s.a > 0 implies f.s=s.a))
proof let a be Int_position;
    defpred P[set,set] means ex t be State of SCMPDS st
    t=$1 & (t.a <= 0 implies $2 =0) & (t.a > 0 implies $2=t.a);
A1: now let s be State of SCMPDS;
       per cases;
       suppose A2:s.a <= 0;
        reconsider y=0 as Element of NAT;
        take y;
        thus P[s,y] by A2;
       end;
       suppose A3: s.a > 0;
        then reconsider y=s.a as Element of NAT by INT_1:16;
        take y;
        thus P[s,y] by A3;
   end;
   end;
     ex f be Function of product the Object-Kind of SCMPDS,NAT st
     for s being State of SCMPDS holds P[s,f.s] from FUNCT_2:sch 3(A1);
   then consider f be Function of product the Object-Kind of SCMPDS,NAT
   such that
A4: for s holds P[s,f.s];
    take f;
    hereby
       let s;
            P[s,f.s] by A4;
       hence (s.a <= 0 implies f.s =0) & (s.a > 0 implies f.s=s.a);
    end;
end;

begin :: The construction and several basic properties of while<0 program
:: while (a,i)<0 do I

definition
 let a be Int_position, i be Integer,I be Program-block;
 func while<0(a,i,I) -> Program-block equals
    (a,i)>=0_goto (card I +2) ';' I ';' goto -(card I+1);
 coherence;
end;

registration
   let I be shiftable Program-block,a be Int_position,i be Integer;
   cluster while<0(a,i,I) -> shiftable;
   correctness
   proof
    set WHL=while<0(a,i,I),
        i1= (a,i)>=0_goto (card I +2),
        i2= goto -(card I+1);
   set PF= Load i1 ';' I;
A1: PF=i1 ';' I by SCMPDS_4:def 4;
    then card PF=card I + 1 by SCMPDS_6:15;
then A2:  card PF+ -(card I+1) =0;
          WHL= PF ';' i2 by A1;
     hence WHL is shiftable by A2,SCMPDS_4:78;
  end;
end;

registration
   let I be No-StopCode Program-block, a be Int_position,i be Integer;
   cluster while<0(a,i,I) -> No-StopCode;
   correctness;
end;

theorem Th6:
 for a be Int_position,i be Integer,I be Program-block holds
  card while<0(a,i,I)= card I +2
proof
  let a be Int_position,i be Integer, I be Program-block;
  set i1=(a,i)>=0_goto (card I +2),
      i2=goto -(card I+1);
  set I4=i1 ';' I;
    thus card while<0(a,i,I)=card I4+1 by SCMP_GCD:8
    .=card I +1 +1 by SCMPDS_6:15
    .=card I + 2;
end;

Lm1:
 for a be Int_position,i be Integer,I be Program-block holds
  card stop while<0(a,i,I)= card I+3
proof
   let a be Int_position,i be Integer,I be Program-block;
   thus card stop while<0(a,i,I)= card while<0(a,i,I) +1 by SCMPDS_5:7
   .= card I +2+1 by Th6
   .= card I + 3;
end;

theorem Th7:
 for a be Int_position,i be Integer,m be Element of NAT,I be Program-block
 holds
   m < card I+2 iff inspos m in dom while<0(a,i,I)
proof
   let a be Int_position,i be Integer,m be Element of NAT,I be Program-block;
        card while<0(a,i,I)=card I + 2 by Th6;
   hence thesis by SCMPDS_4:1;
end;

theorem Th8:
 for a be Int_position,i be Integer,I be Program-block holds
    while<0(a,i,I).inspos 0=(a,i)>=0_goto (card I +2) &
    while<0(a,i,I).inspos (card I+1)=goto -(card I+1)
proof
    let a be Int_position,i be Integer,I be Program-block;
    set i1=(a,i)>=0_goto (card I +2),
        i2=goto -(card I+1);
    set I4=i1 ';' I;
A1: card I4=card I+1 by SCMPDS_6:15;
    set J5=I ';' i2;
    set FLOOP=while<0(a,i,I);
    FLOOP=i1 ';' J5 by SCMPDS_4:51;
   hence FLOOP.inspos 0=i1 by SCMPDS_6:16;
   thus FLOOP.inspos(card I+1)=i2 by A1,SCMP_GCD:10;
end;

Lm2:
 for a be Int_position,i be Integer,I be Program-block holds
   while<0(a,i,I)= ((a,i)>=0_goto (card I +2)) ';' (I ';'
   goto -(card I+1)) by SCMPDS_4:51;

theorem Th9:
 for s being State of SCMPDS,I being Program-block,a being Int_position,
 i being Integer st s.DataLoc(s.a,i) >= 0 holds
 while<0(a,i,I) is_closed_on s & while<0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program-block,a be Int_position,
  i be Integer;
  set d1=DataLoc(s.a,i);
  assume A1: s.d1 >= 0;
  set WHL=while<0(a,i,I),
       pWHL=stop WHL,
       iWHL=Initialized pWHL,
       s3 = s +* iWHL,
       C3 = Computation s3,
       s4 = C3.1;
  set i1=(a,i)>=0_goto (card I+2),
       i2=goto -(card I+1);

A2: IC s3 =inspos 0 by SCMPDS_6:21;
         WHL = i1 ';' (I ';' i2 ) by Lm2;
then A3: CurInstr s3 = i1 by SCMPDS_6:22;
A4: (Computation s3).(0 + 1) = Following (Computation s3).0 by AMI_1:def 19
     .= Following s3 by AMI_1:def 19
     .= Exec(i1,s3) by A3,AMI_1:def 18;
A5:  not d1 in dom iWHL & d1 in dom s by SCMPDS_2:49,SCMPDS_4:31;
          not a in dom iWHL & a in dom s by SCMPDS_2:49,SCMPDS_4:31;
then A6: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
     .= s.d1 by A5,FUNCT_4:12;

          iWHL c= s3 by FUNCT_4:26;
     then pWHL c= s3 by SCMPDS_4:57;
then A7:  pWHL c= s4 by AMI_3:38;

A8: card WHL=card I+2 by Th6;
then A9: inspos(card I+2) in dom pWHL by SCMPDS_6:25;
A10: IC s4 = s4.IC SCMPDS by AMI_1:def 15
     .= ICplusConst(s3,(card I+2)) by A1,A4,A6,SCMPDS_2:69
     .= inspos(0+(card I+2)) by A2,SCMPDS_6:23;
          s4.inspos(card I+2) = pWHL.inspos(card I+2) by A7,A9,GRFUNC_1:8
     .=halt SCMPDS by A8,SCMPDS_6:25;
then A11: CurInstr s4 = halt SCMPDS by A10,AMI_1:def 17;
          now
       let k be Element of NAT;
       per cases;
       suppose 0 < k;
         then 1+0 <= k by INT_1:20;
         hence IC C3.k in dom pWHL by A9,A10,A11,AMI_1:52;
      end;
      suppose k = 0;
          then C3.k = s3 by AMI_1:def 19;
         hence IC C3.k in dom pWHL by A2,SCMPDS_4:75;
     end;
     end;
     hence WHL is_closed_on s by SCMPDS_6:def 2;
          s3 is halting by A11,AMI_1:def 20;
     hence WHL is_halting_on s by SCMPDS_6:def 3;
end;

theorem Th10:
 for s being State of SCMPDS,I being Program-block,a,c being Int_position,
 i being Integer st s.DataLoc(s.a,i) >= 0 holds
 IExec(while<0(a,i,I),s) = s +* Start-At inspos (card I + 2)
proof
   let s be State of SCMPDS,I be Program-block, a,c be Int_position,
   i be Integer;
   set d1=DataLoc(s.a,i);
   assume A1: s.d1 >= 0;
   set WHL=while<0(a,i,I),
       pWHL=stop WHL,
       iWHL=Initialized pWHL,
       s3 = s +* iWHL,
       s4 = (Computation s3).1,
       i1=(a,i)>=0_goto (card I+2),
       i2=goto -(card I+1);
   set SAl=Start-At inspos (card I + 2);

A2: IC s3 =inspos 0 by SCMPDS_6:21;
         WHL = i1 ';' (I ';' i2) by Lm2;
then A3: CurInstr s3 = i1 by SCMPDS_6:22;
A4: (Computation s3).(0 + 1) = Following (Computation s3).0 by AMI_1:def 19
     .= Following s3 by AMI_1:def 19
     .= Exec(i1,s3) by A3,AMI_1:def 18;
A5: not d1 in dom iWHL & d1 in dom s by SCMPDS_2:49,SCMPDS_4:31;
         not a in dom iWHL & a in dom s by SCMPDS_2:49,SCMPDS_4:31;
then A6: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
     .= s.d1 by A5,FUNCT_4:12;
A7:  dom (s | A) = A by SCMPDS_6:1;
          iWHL c= s3 by FUNCT_4:26;
     then pWHL c= s3 by SCMPDS_4:57;
then A8:  pWHL c= s4 by AMI_3:38;
A9: card WHL=card I+2 by Th6;
then A10: inspos(card I+2) in dom pWHL by SCMPDS_6:25;
A11: IC s4 = s4.IC SCMPDS by AMI_1:def 15
     .= ICplusConst(s3,(card I+2)) by A1,A4,A6,SCMPDS_2:69
     .= inspos(0+(card I+2)) by A2,SCMPDS_6:23;
          s4.inspos(card I+2) = pWHL.inspos(card I+2) by A8,A10,GRFUNC_1:8
     .=halt SCMPDS by A9,SCMPDS_6:25;
then A12: CurInstr s4 = halt SCMPDS by A11,AMI_1:def 17;
then A13: s3 is halting by AMI_1:def 20;
      now let l be Element of NAT;
       assume l < 0+1;
        then l <= 0 by NAT_1:13;
        then l=0;
then CurInstr (Computation s3).l = CurInstr s3 by AMI_1:def 19;
         hence CurInstr (Computation s3).l <> halt SCMPDS by A3,SCMPDS_6:31;
      end;
      then for l be Element of NAT st CurInstr (Computation s3).l = halt SCMPDS
        holds 1 <= l;
then LifeSpan s3 = 1 by A12,A13,SCM_1:def 2;
then A14:  s4 = Result s3 by A13,SCMFSA6B:16;
A15:  dom IExec(WHL,s) = the carrier of SCMPDS by AMI_3:36
      .= dom (s +* SAl) by AMI_3:36;
A16:  IExec(WHL,s) = Result s3 +* s | A by SCMPDS_4:def 8;
           now let x be set;
      assume
A17:    x in dom IExec(WHL,s);
A18:    dom SAl = {IC SCMPDS} by FUNCOP_1:19;
       per cases by A17,SCMPDS_4:20;
       suppose
A19:    x is Int_position;
        then x <> IC SCMPDS by SCMPDS_2:52;
then A20:    not x in dom SAl by A18,TARSKI:def 1;
    now assume x in dom (s | A);
      then reconsider l=x as Instruction-Location of SCMPDS
             by A7,AMI_1:def 4;
      l=x;
     hence contradiction by A7,A19,SCMPDS_2:53;
    end;
      hence
             IExec(WHL,s).x = s4.x by A14,A16,FUNCT_4:12
       .= s3.x by A4,A19,SCMPDS_2:69
       .= s.x by A19,SCMPDS_5:19
       .= (s +* SAl).x by A20,FUNCT_4:12;
      end;
      suppose
A21:    x = IC SCMPDS;
     now assume x in dom (s | A);
      then reconsider l=x as Instruction-Location of SCMPDS
             by A7,AMI_1:def 4;
      l=x;
     hence contradiction by A7,AMI_1:48,AMI_5:25,A21;
    end;
        then x in dom Result s3 & not x in dom (s | A) by A7,AMI_1:48,AMI_5:25
,A21;
      hence
              IExec(WHL,s).x = s4.x by A14,A16,FUNCT_4:12
       .= inspos(card I + 2) by A11,A21,AMI_1:def 15
       .= (s +* SAl).x by A21,SCMPDS_7:12;
       end;
       suppose x is Instruction-Location of SCMPDS;
       hence IExec(WHL,s).x = (s +* SAl).x by SCMPDS_6:27;
    end;
    end;
    hence IExec(WHL,s) = s +* SAl by A15,FUNCT_1:9;
end;

theorem
      for s being State of SCMPDS,I being Program-block,a being Int_position,
 i being Integer st s.DataLoc(s.a,i) >= 0 holds
   IC IExec(while<0(a,i,I),s) = inspos (card I + 2)
proof
  let s be State of SCMPDS,I be Program-block,a be Int_position,
  i be Integer;
  assume s.DataLoc(s.a,i) >= 0;
      then IExec(while<0(a,i,I),s) =s +* Start-At inspos (card I+ 2) by Th10;
      hence thesis by AMI_5:79;
end;

theorem
      for s being State of SCMPDS,I being Program-block,a,b being Int_position,
 i being Integer st s.DataLoc(s.a,i) >= 0 holds
   IExec(while<0(a,i,I),s).b = s.b
proof
   let s be State of SCMPDS,I be Program-block,a,b be Int_position,
   i be Integer;
    assume s.DataLoc(s.a,i) >= 0;
then A1: IExec(while<0(a,i,I),s) = s +* Start-At inspos (card I + 2) by Th10;
         not b in dom Start-At inspos (card I + 2) by SCMPDS_4:59;
    hence IExec(while<0(a,i,I),s).b = s.b by A1,FUNCT_4:12;
end;

Lm3:
 for I being Program-block,a being Int_position,i being Integer
 holds Shift(I,1) c= while<0(a,i,I)
proof
  let I be Program-block,a be Int_position,i be Integer;
   set i1=(a,i)>=0_goto (card I+2),
       i2=goto -(card I+1);
A1: card Load i1=1 by SCMPDS_5:6;
         while<0(a,i,I) = i1 ';' I ';' Load i2 by SCMPDS_4:def 5
     .= Load i1 ';' I ';' Load i2 by SCMPDS_4:def 4;
    hence thesis by A1,SCMPDS_7:16;
end;

scheme WhileLHalt { F(State of SCMPDS)-> Element of NAT,
 s() -> State of SCMPDS,I() -> No-StopCode shiftable Program-block,
 a() -> Int_position,i() -> Integer,P[State of SCMPDS]}:
   (F(s())=F(s()) or P[s()]) &
   while<0(a(),i(),I()) is_closed_on s() &
   while<0(a(),i(),I()) is_halting_on s()
provided
A1: card I() > 0 and
A2: (for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds
    t.DataLoc(s().a(),i()) >= 0) and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS st
       P[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) < 0
    holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
        I() is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) &
        P[Dstate(IExec(I(),t))]
proof
   set b=DataLoc(s().a(),i());
   set WHL=while<0(a(),i(),I()),
       pWHL=stop WHL,
       iWHL=Initialized pWHL,
       pI=stop I(),
       IsI= Initialized pI;
   set i1=(a(),i())>=0_goto (card I()+2),
       i2=goto -(card I()+1);

    defpred Q[Element of NAT] means
       for t be State of SCMPDS st F(Dstate(t)) <= $1 & P[Dstate t] &
       t.a()=s().a()
       holds WHL is_closed_on t & WHL is_halting_on t;
A5:  Q[0]
      proof
        let t be State of SCMPDS;
        assume A6: F(Dstate(t)) <= 0 & P[Dstate t] & t.a()=s().a();
        then F(Dstate(t))=0;
        then t.b >= 0 by A2,A6;
        hence WHL is_closed_on t & WHL is_halting_on t by A6,Th9;
      end;
A7:  for k be Element of NAT st Q[k] holds Q[k + 1]
     proof
     let k be Element of NAT;
     assume A8: Q[k];
           now
        let t be State of SCMPDS;
        assume A9: F(Dstate(t)) <= k+1;
        assume A10: P[Dstate t];
        assume A11: t.a()=s().a();
        per cases;
        suppose t.b >= 0;
          hence WHL is_closed_on t & WHL is_halting_on t by A11,Th9;
        end;
        suppose A12: t.b < 0;
        set t2 = t +* IsI,
            t3 = t +* iWHL,
            C3 = Computation t3,
            t4 = C3.1;
A13:     IExec(I(),t).a()=t.a() & I() is_closed_on t & I() is_halting_on t &
        F(Dstate IExec(I(),t)) < F(Dstate t) &
        P[Dstate(IExec(I(),t))] by A4,A10,A11,A12;
A14:     IsI c= t2 by FUNCT_4:26;
A15:     t2 is halting by A13,SCMPDS_6:def 3;
        then t2 +* IsI is halting by A14,FUNCT_4:79;
then A16:     I() is_halting_on t2 by SCMPDS_6:def 3;
A17:     I() is_closed_on t2 by A13,SCMPDS_6:38;
A18:     inspos 0 in dom pWHL by SCMPDS_4:75;
A19:     IC t3 =inspos 0 by SCMPDS_6:21;
             WHL = i1 ';' (I() ';' i2) by Lm2;
then A20:     CurInstr t3 = i1 by SCMPDS_6:22;
A21:     (Computation t3).(0 + 1) = Following (Computation t3).0 by
AMI_1:def 19
        .= Following t3 by AMI_1:def 19
        .= Exec(i1,t3) by A20,AMI_1:def 18;
A22:     not a() in dom iWHL & a() in dom t by SCMPDS_2:49,SCMPDS_4:31;
A23:     not b in dom iWHL & b in dom t by SCMPDS_2:49,SCMPDS_4:31;
        A24: t3.DataLoc(t3.a(),i())= t3.b by A11,A22,FUNCT_4:12
        .= t.b by A23,FUNCT_4:12;
A25:     IC t4 = t4.IC SCMPDS by AMI_1:def 15
        .= Next IC t3 by A12,A21,A24,SCMPDS_2:69
        .= inspos(0+1) by A19,SCMPDS_4:70;
             t2,t3 equal_outside A by SCMPDS_4:36;
then A26:     t2 | D = t3 | D by SCMPDS_4:24;
             now let a;
          thus t2.a = t3.a by A26,SCMPDS_4:23
          .= t4.a by A21,SCMPDS_2:69;
        end;
then A27:    t2 | D = t4 | D by SCMPDS_4:23;

        set m2=LifeSpan t2,
            t5=(Computation t4).m2,
            l1=inspos (card I() + 1);

A28:     IExec(I(),t) = Result t2 +* t | A by SCMPDS_4:def 8;
X:       dom (t | A) = A by SCMPDS_6:1;
A29: now assume a() in dom (t | A);
      then reconsider l=a() as Instruction-Location of SCMPDS
             by X,AMI_1:def 4;
      l=a();
     hence contradiction by X,SCMPDS_2:53;
    end;
             card I() + 1 < card I() + 2 by XREAL_1:8;
then A30:     l1 in dom WHL by Th7;
A31:     WHL c= iWHL by SCMPDS_6:17;
             iWHL c= t3 by FUNCT_4:26;
then A32:     WHL c= t3 by A31,XBOOLE_1:1;
             Shift(I(),1) c= WHL by Lm3;
        then Shift(I(),1) c= t3 by A32,XBOOLE_1:1;
then A33:     Shift(I(),1) c= t4 by AMI_3:38;
then A34:     (Computation t2).m2 | D = t5 | D by A1,A14,A16,A17,A25,A27,
SCMPDS_7:36;
then A35:     t5.a()=(Computation t2).m2.a() by SCMPDS_4:23
        .=(Result t2).a() by A15,SCMFSA6B:16
        .=s().a() by A11,A13,A28,A29,FUNCT_4:12;
        A36: dom (t | A) = A by SCMPDS_6:1;
A37:     t5|D =(Result t2)|D by A15,A34,SCMFSA6B:16
        .= (Result t2 +* t | A)|D by A36,FUNCT_4:76,AMI_5:33
        .=IExec(I(),t)|D by SCMPDS_4:def 8;

        set m3=m2 +1;
        set t6=(Computation t3).m3;
A38:     IC t5=l1 by A1,A14,A16,A17,A25,A27,A33,SCMPDS_7:36;
A39:     t6=t5 by AMI_1:51;
then A40:     CurInstr t6=t5.l1 by A38,AMI_1:def 17
        .=t4.l1 by AMI_1:54
        .=t3.l1 by AMI_1:54
        .=WHL.l1 by A30,A32,GRFUNC_1:8
        .=i2 by Th8;
        set t7=(Computation t3).(m3+ 1);
A41:     t7 = Following t6 by AMI_1:def 19
        .= Exec(i2,t6) by A40,AMI_1:def 18;
A42:    IC t7=t7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(t6,0-(card I()+1)) by A41,SCMPDS_2:66
       .=inspos 0 by A38,A39,SCMPDS_7:1;
A43:    t7.a()=t6.a() by A41,SCMPDS_2:66
       .=s().a() by A35,AMI_1:51;

            InsCode i2=0 by SCMPDS_2:21;
       then InsCode i2 in {0,4,5,6} by ENUMSET1:def 2;
then A44:    Dstate(t7)=Dstate(t6) by A41,Th3
       .=Dstate(IExec(I(),t)) by A37,A39,Th2;
           now
         assume A45:F(Dstate(t7)) > k;
              F(Dstate(IExec(I(),t))) < F(Dstate(t)) by A4,A10,A11,A12;
    then F(Dstate(t7)) < k+1 by A9,A44,XXREAL_0:2;
         hence contradiction by A45,INT_1:20;
       end;
then A46:    WHL is_closed_on t7 & WHL is_halting_on t7 by A8,A13,A43,A44;
A47:    t7 +* iWHL=t7 by A42,SCMPDS_7:37;
            now
          let k be Element of NAT;
          per cases;
          suppose k < m3+1;
           then A48: k <= m3 by INT_1:20;
           hereby
              per cases by A48,NAT_1:8;
              suppose A49:k <= m2;
               hereby
               per cases;
                 suppose k=0;
                 hence IC (Computation t3).k in dom pWHL by A18,A19,
AMI_1:def 19;
                 end;
                 suppose k<>0;
                  then consider kn be Nat such that
              A50: k=kn+1 by NAT_1:6;
                  reconsider kn as Element of NAT by ORDINAL1:def 13;
                  kn < k by A50,XREAL_1:31;
                  then kn < m2 by A49,XXREAL_0:2;
              then A51: IC (Computation t2).kn + 1 = IC (Computation t4).kn
                  by A1,A14,A16,A17,A25,A27,A33,SCMPDS_7:34;
              A52: IC (Computation t2).kn in dom pI by A13,SCMPDS_6:def 2;
                  consider lm be Element of NAT such that
              A53: IC (Computation t2).kn=inspos lm by SCMPDS_3:32;
                       lm < card pI by A52,A53,SCMPDS_4:1;
                  then lm < card I()+1 by SCMPDS_5:7;
              then A54: lm+1 <= card I() +1 by INT_1:20;
                       card I() + 1 < card I() + 3 by XREAL_1:8;
                  then lm+1 < card I() +3 by A54,XXREAL_0:2;
                  then A55: lm+1 < card pWHL by Lm1;
                       IC (Computation t3).k=inspos lm +1 by A50,A51,A53,
AMI_1:51
                  .=inspos (lm+1) by SCMPDS_3:def 3;
                  hence IC (Computation t3).k in dom pWHL by A55,SCMPDS_4:1;
               end;
               end;
              end;
              suppose A56:k=m3;
               l1 in dom pWHL by A30,SCMPDS_6:18;
               hence IC (Computation t3).k in dom pWHL by A1,A14,A16,A17,A25
,A27,A33,A39,A56,SCMPDS_7:36;
            end;
            end;
          end;
          suppose k >= m3+1;
          then consider nn be Nat such that
         A57: k=m3+1+nn by NAT_1:10;
          reconsider nn as Element of NAT by ORDINAL1:def 13;
           C3.k=(Computation (t7 +* iWHL)).nn by A47,A57,AMI_1:51;
           hence IC (Computation t3).k in dom pWHL by A46,SCMPDS_6:def 2;
       end;
       end;
       hence WHL is_closed_on t by SCMPDS_6:def 2;
       t7 is halting by A46,A47,SCMPDS_6:def 3;
       then t3 is halting by SCM_1:27;
       hence WHL is_halting_on t by SCMPDS_6:def 3;
     end;
     end;
     hence Q[k+1];
     end;
A58:  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A5,A7);
     set n=F(Dstate s());
     A59: Q[n] by A58;
     thus F(s())=F(s()) or P[s()];
     thus WHL is_closed_on s() & WHL is_halting_on s() by A3,A59;
end;

scheme WhileLExec { F(State of SCMPDS)-> Element of NAT,
 s() -> State of SCMPDS,I() -> No-StopCode shiftable Program-block,
 a() -> Int_position,i() -> Integer,P[State of SCMPDS]}:
   (F(s())=F(s()) or P[s()]) &
   IExec(while<0(a(),i(),I()),s()) =
    IExec(while<0(a(),i(),I()),IExec(I(),s()))
provided
A1: card I() > 0 and
A2: s().DataLoc(s().a(),i()) < 0 and
A3: (for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds
    t.DataLoc(s().a(),i()) >= 0) and
A4: P[Dstate s()] and
A5: for t be State of SCMPDS st
       P[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) < 0
    holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
        I() is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) &
        P[Dstate(IExec(I(),t))]
proof
   set b=DataLoc(s().a(),i());
   set WHL=while<0(a(),i(),I()),
       iWHL=Initialized stop WHL,
       iI= Initialized stop I(),
       s1= s() +* iWHL,
       C1=Computation s1,
       ps= s() | A;
   set i1=(a(),i())>=0_goto (card I()+2),
       i2=goto -(card I()+1);
   deffunc U(State of SCMPDS) = F($1);
A6: (for t be State of SCMPDS st P[Dstate t] & U(Dstate(t))=0 holds
    t.DataLoc(s().a(),i()) >= 0) by A3;
A7: P[Dstate s()] by A4;
A8: for t be State of SCMPDS st
       P[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) < 0
    holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
        I() is_halting_on t & U(Dstate IExec(I(),t)) < U(Dstate t) &
        P[Dstate(IExec(I(),t))] by A5;

         (U(s())=U(s()) or P[s()]) & WHL is_closed_on s() &
    WHL is_halting_on s() from WhileLHalt(A1,A6,A7,A8);
then A9: s1 is halting by SCMPDS_6:def 3;
    set sI= s() +* iI,
       m1=LifeSpan sI+2,
       s2=IExec(I(),s()) +* iWHL,
       C2=Computation s2,
       m2=LifeSpan s2;
       set Es=IExec(I(),s()),
           bj=DataLoc(Es.a(),i());
A10: I() is_closed_on s() & I() is_halting_on s() by A2,A4,A5;
A11: IExec(I(), s()).a()=s().a() by A2,A4,A5;
   deffunc U(State of SCMPDS) = F($1);
 A12: for t be State of SCMPDS st P[Dstate(t)] & U(Dstate(t))=0 holds
    t.bj >= 0 by A3,A11;
A13: P[Dstate Es] by A2,A4,A5;
A14: for t being State of SCMPDS st P[Dstate t] & t.a()=Es.a() & t.bj < 0
      holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
          I() is_halting_on t & U(Dstate IExec(I(),t)) < U(Dstate t)
          & P[Dstate(IExec(I(),t))] by A5,A11;

A15:  (U(Es)=U(Es) or P[Es]) & WHL is_closed_on Es &
     WHL is_halting_on Es from WhileLHalt(A1,A12,A13,A14);
   set s4 = C1.1;
A16:   sI is halting by A10,SCMPDS_6:def 3;
A17:   iI c= sI by FUNCT_4:26;
      then sI +* iI is halting by A16,FUNCT_4:79;
then A18:   I() is_halting_on sI by SCMPDS_6:def 3;
A19:   I() is_closed_on sI by A10,SCMPDS_6:38;
A20:   WHL = i1 ';' (I() ';' i2) by Lm2;
then A21:  CurInstr s1 = i1 by SCMPDS_6:22;
A22:  IC s1 =inspos 0 by SCMPDS_6:21;
A23:  (Computation s1).(0 + 1) = Following (Computation s1).0 by AMI_1:def 19
     .= Following s1 by AMI_1:def 19
     .= Exec(i1,s1) by A21,AMI_1:def 18;
     A24: s1.DataLoc(s1.a(),i())=s1.b by SCMPDS_5:19
     .= s().b by SCMPDS_5:19;
A25:  IC s4 = s4.IC SCMPDS by AMI_1:def 15
     .= Next IC s1 by A2,A23,A24,SCMPDS_2:69
     .= inspos(0+1) by A22,SCMPDS_4:70;
          sI,s1 equal_outside A by SCMPDS_4:36;
then A26:  sI | D = s1 | D by SCMPDS_4:24;
          now let a;
         thus sI.a = s1.a by A26,SCMPDS_4:23
          .= s4.a by A23,SCMPDS_2:69;
     end;
then A27:  sI | D = s4 | D by SCMPDS_4:23;

     set mI=LifeSpan sI,
         s5=(Computation s4).mI,
         l1=inspos (card I() + 1);

A28:    IExec(I(),s()) = Result sI +* s() | A by SCMPDS_4:def 8;
A29:    dom (s() | A) = A by SCMPDS_6:1;
            card I() + 1 < card I() + 2 by XREAL_1:8;
then A30:    l1 in dom WHL by Th7;
A31:    WHL c= iWHL by SCMPDS_6:17;
            iWHL c= s1 by FUNCT_4:26;
then A32:    WHL c= s1 by A31,XBOOLE_1:1;
            Shift(I(),1) c= WHL by Lm3;
       then Shift(I(),1) c= s1 by A32,XBOOLE_1:1;
then A33:    Shift(I(),1) c= s4 by AMI_3:38;
then A34:    (Computation sI).mI | D = s5 | D
       by A1,A17,A18,A19,A25,A27,SCMPDS_7:36;
        set m3=mI +1;
        set s6=(Computation s1).m3;
A35:     IC s5=l1 by A1,A17,A18,A19,A25,A27,A33,SCMPDS_7:36;
A36:     s6=s5 by AMI_1:51;
then A37:     CurInstr s6=s5.l1 by A35,AMI_1:def 17
        .=s4.l1 by AMI_1:54
        .=s1.l1 by AMI_1:54
        .=WHL.l1 by A30,A32,GRFUNC_1:8
        .=i2 by Th8;
        set s7=(Computation s1).(m3+ 1);
A38:     s7 = Following s6 by AMI_1:def 19
        .= Exec(i2,s6) by A37,AMI_1:def 18;
A39:    IC s7=s7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(s6,0-(card I()+1)) by A38,SCMPDS_2:66
       .=inspos 0 by A35,A36,SCMPDS_7:1;
            now
          let x be Int_position;
  A40:     not x in dom iWHL & x in dom IExec(I(),s())
          by SCMPDS_2:49,SCMPDS_4:31;
A41: now assume x in dom (s() | A);
      then reconsider l=x as Instruction-Location of SCMPDS
             by A29,AMI_1:def 4;
      l=x;
     hence contradiction by A29,SCMPDS_2:53;
    end;
           s5.x=(Computation sI).mI.x by A34,SCMPDS_4:23
         .=(Result sI).x by A16,SCMFSA6B:16
         .=IExec(I(),s()).x by A28,A41,FUNCT_4:12;
       hence s7.x=IExec(I(),s()).x by A36,A38,SCMPDS_2:66
         .=s2.x by A40,FUNCT_4:12;
     end;
     then A42: s7 | D = s2 | D by SCMPDS_4:23;
A43:  IC s2 =IC C1.m1 by A39,SCMPDS_6:21;
A44: s2 is halting by A15,SCMPDS_6:def 3;
A45: dom ps = dom s() /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
         s2 | A= (Result sI +* ps +* iWHL) | A by SCMPDS_4:def 8
    .=(Result sI +* ps)|A +* iWHL | A by FUNCT_4:75
    .= ps +* iWHL | A by A45,FUNCT_4:24
    .= s1 | A by FUNCT_4:75
    .= C1.m1 | A by SCMPDS_7:6;
then A46: C1.m1=s2 by A42,A43,SCMPDS_7:7;
    then CurInstr C1.m1=i1 by A20,SCMPDS_6:22;
then A47: CurInstr C1.m1 <> halt SCMPDS by SCMPDS_6:31;
    set m0=LifeSpan s1;
         m0 > m1 by A9,A47,SCMPDS_6:2;
    then consider nn be Nat such that
A48: m0=m1+nn by NAT_1:10;
    reconsider nn as Element of NAT by ORDINAL1:def 13;
A49: C1.m0 = C2.nn by A46,A48,AMI_1:51;
    then CurInstr C2.nn =halt SCMPDS by A9,SCM_1:def 2;
then A50: nn >= m2 by A44,SCM_1:def 2;
         C1.(m1 + m2) = C2.m2 by A46,AMI_1:51;
    then CurInstr C1.(m1 + m2) = halt SCMPDS by A44,SCM_1:def 2;
    then m1 + m2 >= m0 by A9,SCM_1:def 2;
    then m2 >= nn by A48,XREAL_1:8;
then nn=m2 by A50,XXREAL_0:1;
then A51: Result s1 = C2.m2 by A9,A49,SCMFSA6B:16;
A52: IExec(I(),s()) | A= (Result sI +* ps) | A by SCMPDS_4:def 8
    .= ps by A45,FUNCT_4:24;
    thus F(s())=F(s()) or P[s()];
    thus IExec(WHL,s())
      = C2.m2 +* ps by A51,SCMPDS_4:def 8
     .= Result s2 +* IExec(I(),s()) | A by A44,A52,SCMFSA6B:16
     .= IExec(WHL,IExec(I(),s())) by SCMPDS_4:def 8;
end;

theorem
      for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i be Integer,X be set, f being Function of
 product the Object-Kind of SCMPDS,NAT st card I > 0 &
 ( for t be State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i) >= 0 ) &
 (for t be State of SCMPDS st
    (for x be Int_position st x in X holds t.x=s.x) &
    t.a=s.a & t.DataLoc(s.a,i) < 0
   holds IExec(I,t).a=t.a & f.Dstate(IExec(I,t)) < f.Dstate(t) &
    I is_closed_on t & I is_halting_on t &
     for x be Int_position st x in X holds IExec(I,t).x=t.x)
 holds
     while<0(a,i,I) is_closed_on s & while<0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
    a be Int_position, i be Integer,X be set,f be Function of product the
    Object-Kind of SCMPDS,NAT;

   set b=DataLoc(s.a,i);
   set WHL=while<0(a,i,I),
       pWHL=stop WHL,
       iWHL=Initialized pWHL,
       pI=stop I,
       IsI= Initialized pI;
   set i1=(a,i)>=0_goto (card I+2),
       i2=goto -(card I+1);

   assume A1: card I > 0;
   assume A2: for t be State of SCMPDS st f.Dstate(t)=0 holds t.b >= 0;
   assume A3: for t be State of SCMPDS st
      (for x st x in X holds t.x=s.x) & t.a=s.a & t.b < 0
    holds IExec(I,t).a=t.a & f.Dstate(IExec(I,t)) < f.Dstate(t) &
      I is_closed_on t & I is_halting_on t &
      for x st x in X holds IExec(I,t).x=t.x;
    defpred P[Element of NAT] means
       for t be State of SCMPDS st f.Dstate(t) <= $1 &
      (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a
      holds WHL is_closed_on t & WHL is_halting_on t;
A4:  P[0]
     proof
       let t be State of SCMPDS;
        assume A5: f.Dstate(t) <= 0;
        assume for x st x in X holds t.x=s.x;
        assume A6: t.a=s.a;
            f.Dstate(t)=0 by A5;
        then t.b >= 0 by A2;
        hence WHL is_closed_on t & WHL is_halting_on t by A6,Th9;
      end;
A7:  for k be Element of NAT st P[k] holds P[k + 1]
     proof
     let k be Element of NAT;
     assume A8: P[k];
           now
        let t be State of SCMPDS;
        assume A9: f.Dstate(t) <= k+1;
        assume A10: for x st x in X holds t.x=s.x;
        assume A11: t.a=s.a;
        per cases;
        suppose t.b >= 0;
        hence WHL is_closed_on t & WHL is_halting_on t
         by A11,Th9;
        end;
        suppose A12: t.b < 0;
        set t2 = t +* IsI,
            t3 = t +* iWHL,
            C3 = Computation t3,
            t4 = C3.1;
A13:     IExec(I,t).a=t.a & f.Dstate(IExec(I,t)) < f.Dstate(t) &
        I is_closed_on t & I is_halting_on t &
        for x st x in X holds IExec(I,t).x=t.x by A3,A10,A11,A12;
A14:     IsI c= t2 by FUNCT_4:26;
A15:     t2 is halting by A13,SCMPDS_6:def 3;
        then t2 +* IsI is halting by A14,FUNCT_4:79;
then A16:     I is_halting_on t2 by SCMPDS_6:def 3;
A17:     I is_closed_on t2 by A13,SCMPDS_6:38;
A18:     inspos 0 in dom pWHL by SCMPDS_4:75;
A19:     IC t3 =inspos 0 by SCMPDS_6:21;
             WHL = i1 ';' (I ';' i2) by Lm2;
then A20:     CurInstr t3 = i1 by SCMPDS_6:22;
A21:     (Computation t3).(0 + 1) = Following (Computation t3).0 by
AMI_1:def 19
        .= Following t3 by AMI_1:def 19
        .= Exec(i1,t3) by A20,AMI_1:def 18;
A22:     not a in dom iWHL & a in dom t by SCMPDS_2:49,SCMPDS_4:31;
A23:     not b in dom iWHL & b in dom t by SCMPDS_2:49,SCMPDS_4:31;
        A24: t3.DataLoc(t3.a,i)= t3.b by A11,A22,FUNCT_4:12
        .= t.b by A23,FUNCT_4:12;
A25:     IC t4 = t4.IC SCMPDS by AMI_1:def 15
        .= Next IC t3 by A12,A21,A24,SCMPDS_2:69
        .= inspos(0+1) by A19,SCMPDS_4:70;
             t2,t3 equal_outside A by SCMPDS_4:36;
then A26:     t2 | D = t3 | D by SCMPDS_4:24;
             now let a;
          thus t2.a = t3.a by A26,SCMPDS_4:23
          .= t4.a by A21,SCMPDS_2:69;
        end;
then A27:    t2 | D = t4 | D by SCMPDS_4:23;

        set m2=LifeSpan t2,
            t5=(Computation t4).m2,
            l1=inspos (card I + 1);

A28:     IExec(I,t) = Result t2 +* t | A by SCMPDS_4:def 8;
A29:     dom (t | A) = A by SCMPDS_6:1;
A30: now assume a in dom (t | A);
      then reconsider l=a as Instruction-Location of SCMPDS
             by A29,AMI_1:def 4;
      l=a;
     hence contradiction by A29,SCMPDS_2:53;
    end;
             card I + 1 < card I + 2 by XREAL_1:8;
then A31:     l1 in dom WHL by Th7;
A32:     WHL c= iWHL by SCMPDS_6:17;
             iWHL c= t3 by FUNCT_4:26;
then A33:     WHL c= t3 by A32,XBOOLE_1:1;
             Shift(I,1) c= WHL by Lm3;
        then Shift(I,1) c= t3 by A33,XBOOLE_1:1;
then A34:     Shift(I,1) c= t4 by AMI_3:38;
then A35:     (Computation t2).m2 | D = t5 | D
          by A1,A14,A16,A17,A25,A27,SCMPDS_7:36;
then A36:     t5.a=(Computation t2).m2.a by SCMPDS_4:23
        .=(Result t2).a by A15,SCMFSA6B:16
        .=s.a by A11,A13,A28,A30,FUNCT_4:12;
        A37: dom (t | A) = A by SCMPDS_6:1;
A38:     t5|D =(Result t2)|D by A15,A35,SCMFSA6B:16
        .= (Result t2 +* t | A)|D by A37,FUNCT_4:76,AMI_5:33
        .=IExec(I,t)|D by SCMPDS_4:def 8;

        set m3=m2 +1;
        set t6=(Computation t3).m3;
A39:     IC t5=l1 by A1,A14,A16,A17,A25,A27,A34,SCMPDS_7:36;
A40:     t6=t5 by AMI_1:51;
then A41:     CurInstr t6=t5.l1 by A39,AMI_1:def 17
        .=t4.l1 by AMI_1:54
        .=t3.l1 by AMI_1:54
        .=WHL.l1 by A31,A33,GRFUNC_1:8
        .=i2 by Th8;
        set t7=(Computation t3).(m3+ 1);
A42:     t7 = Following t6 by AMI_1:def 19
        .= Exec(i2,t6) by A41,AMI_1:def 18;
A43:    IC t7=t7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(t6,0-(card I+1)) by A42,SCMPDS_2:66
       .=inspos 0 by A39,A40,SCMPDS_7:1;
A44:    t7.a=t6.a by A42,SCMPDS_2:66
       .=s.a by A36,AMI_1:51;

A45:   now
         let x be Int_position;
         assume A46:x in X;
A47: now assume x in dom (t | A);
      then reconsider l=x as Instruction-Location of SCMPDS
             by A29,AMI_1:def 4;
      l=x;
     hence contradiction by A29,SCMPDS_2:53;
    end;
             t5.x=(Computation t2).m2.x by A35,SCMPDS_4:23
            .=(Result t2).x by A15,SCMFSA6B:16
            .=IExec(I,t).x by A28,A47,FUNCT_4:12
            .=t.x by A3,A10,A11,A12,A46
            .=s.x by A10,A46;
       hence t7.x=s.x by A40,A42,SCMPDS_2:66;
       end;
            InsCode i2=0 by SCMPDS_2:21;
       then InsCode i2 in {0,4,5,6} by ENUMSET1:def 2;
then A48:    Dstate(t7)=Dstate(t6) by A42,Th3
       .=Dstate(IExec(I,t)) by A38,A40,Th2;
            now
         assume A49:f.Dstate(t7) > k;
                  f.Dstate(t7) < k+1 by A9,A13,A48,XXREAL_0:2;
                 hence contradiction by A49,INT_1:20;
       end;
then A50:    WHL is_closed_on t7 & WHL is_halting_on t7 by A8,A44,A45;
A51:    t7 +* iWHL=t7 by A43,SCMPDS_7:37;
            now
          let k be Element of NAT;
          per cases;
          suppose k < m3+1;
           then A52: k <= m3 by INT_1:20;
           hereby
              per cases by A52,NAT_1:8;
              suppose A53:k <= m2;
               hereby
               per cases;
                 suppose k=0;
                 hence IC (Computation t3).k in dom pWHL by A18,A19,
AMI_1:def 19;
                 end;
                 suppose k<>0;
                  then consider kn be Nat such that
              A54: k=kn+1 by NAT_1:6;
                  reconsider kn as Element of NAT by ORDINAL1:def 13;
                  kn < k by A54,XREAL_1:31;
                  then kn < m2 by A53,XXREAL_0:2;
              then A55: IC (Computation t2).kn + 1 = IC (Computation t4).kn
                  by A1,A14,A16,A17,A25,A27,A34,SCMPDS_7:34;
              A56: IC (Computation t2).kn in dom pI by A13,SCMPDS_6:def 2;
                  consider lm be Element of NAT such that
              A57: IC (Computation t2).kn=inspos lm by SCMPDS_3:32;
                       lm < card pI by A56,A57,SCMPDS_4:1;
                  then lm < card I+1 by SCMPDS_5:7;
              then A58: lm+1 <= card I +1 by INT_1:20;
                       card I + 1 < card I + 3 by XREAL_1:8;
                  then lm+1 < card I +3 by A58,XXREAL_0:2;
                  then A59: lm+1 < card pWHL by Lm1;
                       IC (Computation t3).k=inspos lm +1 by A54,A55,A57,
AMI_1:51
                  .=inspos (lm+1) by SCMPDS_3:def 3;
                  hence IC (Computation t3).k in dom pWHL by A59,SCMPDS_4:1;
               end;
               end;
              end;
              suppose A60:k=m3;
                    l1 in dom pWHL by A31,SCMPDS_6:18;
               hence IC (Computation t3).k in dom pWHL by A1,A14,A16,A17,A25
,A27,A34,A40,A60,SCMPDS_7:36;
            end;
            end;
          end;
          suppose k >= m3+1;
          then consider nn be Nat such that
         A61: k=m3+1+nn by NAT_1:10;
           reconsider nn as Element of NAT by ORDINAL1:def 13;
           C3.k=(Computation (t7 +* iWHL)).nn by A51,A61,AMI_1:51;
           hence IC (Computation t3).k in dom pWHL by A50,SCMPDS_6:def 2;
       end;
       end;
       hence WHL is_closed_on t by SCMPDS_6:def 2;
       t7 is halting by A50,A51,SCMPDS_6:def 3;
       then t3 is halting by SCM_1:27;
       hence WHL is_halting_on t by SCMPDS_6:def 3;
     end;
     end;
     hence P[k+1];
     end;
A62:  for k being Element of NAT holds P[k] from NAT_1:sch 1(A4,A7);
     set n=f.Dstate(s);
     A63: P[n] by A62;
      for x be Int_position st x in X holds s.x=s.x;
     hence WHL is_closed_on s & WHL is_halting_on s by A63;
end;

theorem
  for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i be Integer,X be set,f being Function of product the
 Object-Kind of SCMPDS,NAT st card I > 0 & s.DataLoc(s.a,i) < 0 &
 (for t be State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i) >= 0 ) &
 (for t be State of SCMPDS st
    (for x be Int_position st x in X holds t.x=s.x) &
    t.a=s.a & t.DataLoc(s.a,i) < 0
   holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    f.Dstate(IExec(I,t)) < f.Dstate(t) &
    for x be Int_position st x in X holds IExec(I,t).x=t.x)
 holds
    IExec(while<0(a,i,I),s) =IExec(while<0(a,i,I),IExec(I,s))
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
    a be Int_position, i be Integer,X be set, f be Function of product
    the Object-Kind of SCMPDS,NAT;

   set b=DataLoc(s.a,i);
   assume A1: card I > 0;
   assume A2: s.b < 0;
   assume A3: for t be State of SCMPDS st f.Dstate(t)=0 holds t.b >= 0;
   assume A4: for t be State of SCMPDS st
     (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a & t.b < 0
  holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
     f.Dstate(IExec(I,t)) < f.Dstate(t) &
      for x be Int_position st x in X holds IExec(I,t).x=t.x;

     defpred P[State of SCMPDS] means for x st x in X holds $1.x=s.x;
     deffunc F(State of SCMPDS) = f.$1;

A5: for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.b >= 0
     by A3;
A6: P[Dstate s] by Th4;
A7:  now
         let t be State of SCMPDS;
         set v=Dstate t;
         assume A8:P[v] & t.a=s.a & t.b < 0;
     A9: now
           let x;
           assume x in X;
           then v.x =s.x by A8;
           hence t.x=s.x by Th4;
         end;
        set It=IExec(I,t);
        thus It.a=t.a & I is_closed_on t & I is_halting_on t &
           F(Dstate It) < F(Dstate t) by A4,A8,A9;
        thus P[Dstate It]
        proof
           set v=Dstate It;
           hereby
              let x;
              assume A10:x in X;
              then It.x=t.x by A4,A8,A9;
              then v.x=t.x by Th4;
              hence v.x=s.x by A9,A10;
           end;
        end;
    end;
          (F(s)=F(s) or P[s]) &
     IExec(while<0(a,i,I),s) =IExec(while<0(a,i,I),IExec(I,s))
      from WhileLExec(A1,A2,A5,A6,A7);
     hence thesis;
end;

theorem Th15:
 for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i be Integer,X be set st card I > 0 &
 (for t be State of SCMPDS st
   (for x be Int_position st x in X holds t.x=s.x) &
   t.a=s.a & t.DataLoc(s.a,i) < 0
 holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i) > t.DataLoc(s.a,i) &
   I is_closed_on t & I is_halting_on t &
  for x be Int_position st x in X holds IExec(I,t).x=t.x)
 holds
     while<0(a,i,I) is_closed_on s & while<0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
  a be Int_position, i be Integer,X be set;
   set b=DataLoc(s.a,i);
   set WHL=while<0(a,i,I),
       pWHL=stop WHL,
       iWHL=Initialized pWHL,
       pI=stop I,
       IsI= Initialized pI;
   set i1=(a,i)>=0_goto (card I+2),
       i2=goto -(card I+1);
   assume A1: card I > 0;
   assume A2: for t be State of SCMPDS st
      (for x st x in X holds t.x=s.x) & t.a=s.a & t.b < 0
    holds IExec(I,t).a=t.a & IExec(I,t).b > t.b &
      I is_closed_on t & I is_halting_on t &
      for x st x in X holds IExec(I,t).x=t.x;
    defpred P[Element of NAT] means
      for t be State of SCMPDS st -t.b <= $1 &
      (for x st x in X holds t.x=s.x) & t.a=s.a
    holds WHL is_closed_on t & WHL is_halting_on t;
A3:  P[0]
      proof
       let t be State of SCMPDS;
        assume A4: -t.b <= 0;
        assume for x st x in X holds t.x=s.x;
        assume A5: t.a=s.a;
             -t.b <= -0 by A4;
        then t.b >= 0 by XREAL_1:26;
        hence WHL is_closed_on t & WHL is_halting_on t by A5,Th9;
      end;
A6:  for k be Element of NAT st P[k] holds P[k + 1]
     proof
     let k be Element of NAT;
     assume A7: P[k];
           now
        let t be State of SCMPDS;
        assume A8: -t.b <= k+1;
        assume A9: for x st x in X holds t.x=s.x;
        assume A10: t.a=s.a;
        per cases;
        suppose t.b >= 0;
        hence WHL is_closed_on t & WHL is_halting_on t
         by A10,Th9;
        end;
        suppose A11: t.b < 0;
        set t2 = t +* IsI,
            t3 = t +* iWHL,
            C3 = Computation t3,
            t4 = C3.1;
A12:     IExec(I,t).a=t.a & IExec(I,t).b > t.b &
        I is_closed_on t & I is_halting_on t &
        for x st x in X holds IExec(I,t).x=t.x by A2,A9,A10,A11;
A13:     IsI c= t2 by FUNCT_4:26;
A14:     t2 is halting by A12,SCMPDS_6:def 3;
        then t2 +* IsI is halting by A13,FUNCT_4:79;
then A15:     I is_halting_on t2 by SCMPDS_6:def 3;
A16:     I is_closed_on t2 by A12,SCMPDS_6:38;
A17:     inspos 0 in dom pWHL by SCMPDS_4:75;
A18:     IC t3 =inspos 0 by SCMPDS_6:21;
             WHL = i1 ';' (I ';' i2) by Lm2;
then A19:     CurInstr t3 = i1 by SCMPDS_6:22;
A20:     (Computation t3).(0 + 1) = Following (Computation t3).0 by
AMI_1:def 19
        .= Following t3 by AMI_1:def 19
        .= Exec(i1,t3) by A19,AMI_1:def 18;
A21:     not a in dom iWHL & a in dom t by SCMPDS_2:49,SCMPDS_4:31;
A22:    not b in dom iWHL & b in dom t by SCMPDS_2:49,SCMPDS_4:31;
        A23: t3.DataLoc(t3.a,i)= t3.b by A10,A21,FUNCT_4:12
        .= t.b by A22,FUNCT_4:12;
A24:     IC t4 = t4.IC SCMPDS by AMI_1:def 15
        .= Next IC t3 by A11,A20,A23,SCMPDS_2:69
        .= inspos(0+1) by A18,SCMPDS_4:70;
             t2,t3 equal_outside A by SCMPDS_4:36;
then A25:     t2 | D = t3 | D by SCMPDS_4:24;
             now let a;
          thus t2.a = t3.a by A25,SCMPDS_4:23
          .= t4.a by A20,SCMPDS_2:69;
        end;
then A26:    t2 | D = t4 | D by SCMPDS_4:23;

        set m2=LifeSpan t2,
            t5=(Computation t4).m2,
            l1=inspos (card I + 1);

A27:     IExec(I,t) = Result t2 +* t | A by SCMPDS_4:def 8;
A28:     dom (t | A) = A by SCMPDS_6:1;
A29: now assume a in dom (t | A);
      then reconsider l=a as Instruction-Location of SCMPDS
             by A28,AMI_1:def 4;
      l=a;
     hence contradiction by A28,SCMPDS_2:53;
    end;
A30: now assume b in dom (t | A);
      then reconsider l=b as Instruction-Location of SCMPDS
             by A28,AMI_1:def 4;
      l=b;
     hence contradiction by A28,SCMPDS_2:53;
    end;
             card I + 1 < card I + 2 by XREAL_1:8;
then A31:     l1 in dom WHL by Th7;
A32:     WHL c= iWHL by SCMPDS_6:17;
             iWHL c= t3 by FUNCT_4:26;
then A33:     WHL c= t3 by A32,XBOOLE_1:1;
             Shift(I,1) c= WHL by Lm3;
        then Shift(I,1) c= t3 by A33,XBOOLE_1:1;
then A34:     Shift(I,1) c= t4 by AMI_3:38;
then A35:     (Computation t2).m2 | D = t5 | D
          by A1,A13,A15,A16,A24,A26,SCMPDS_7:36;
then A36:     t5.a=(Computation t2).m2.a by SCMPDS_4:23
        .=(Result t2).a by A14,SCMFSA6B:16
        .=s.a by A10,A12,A27,A29,FUNCT_4:12;

A37:     t5.b=(Computation t2).m2.b by A35,SCMPDS_4:23
        .=(Result t2).b by A14,SCMFSA6B:16
        .=IExec(I,t).b by A27,A30,FUNCT_4:12;

        set m3=m2 +1;
        set t6=(Computation t3).m3;
A38:     IC t5=l1 by A1,A13,A15,A16,A24,A26,A34,SCMPDS_7:36;
A39:     t6=t5 by AMI_1:51;
then A40:     CurInstr t6=t5.l1 by A38,AMI_1:def 17
        .=t4.l1 by AMI_1:54
        .=t3.l1 by AMI_1:54
        .=WHL.l1 by A31,A33,GRFUNC_1:8
        .=i2 by Th8;
        set t7=(Computation t3).(m3+ 1);
A41:     t7 = Following t6 by AMI_1:def 19
        .= Exec(i2,t6) by A40,AMI_1:def 18;
A42:    IC t7=t7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(t6,0-(card I+1)) by A41,SCMPDS_2:66
       .=inspos 0 by A38,A39,SCMPDS_7:1;
A43:    t7.a=t6.a by A41,SCMPDS_2:66
       .=s.a by A36,AMI_1:51;

A44:   now
         let x be Int_position;
         assume A45:x in X;
A46: now assume x in dom (t | A);
      then reconsider l=x as Instruction-Location of SCMPDS
             by A28,AMI_1:def 4;
      l=x;
     hence contradiction by A28,SCMPDS_2:53;
    end;
             t5.x=(Computation t2).m2.x by A35,SCMPDS_4:23
            .=(Result t2).x by A14,SCMFSA6B:16
            .=IExec(I,t).x by A27,A46,FUNCT_4:12
            .=t.x by A2,A9,A10,A11,A45
            .=s.x by A9,A45;
       hence t7.x=s.x by A39,A41,SCMPDS_2:66;
       end;
A47:    t7.b=IExec(I,t).b by A37,A39,A41,SCMPDS_2:66;
            now
         assume A48:-t7.b > k;
                -t7.b < -t.b by A12,A47,XREAL_1:26;
      then -t7.b < k+1 by A8,XXREAL_0:2;
           hence contradiction by A48,INT_1:20;
       end;
then A49:    WHL is_closed_on t7 & WHL is_halting_on t7 by A7,A43,A44;
A50:    t7 +* iWHL=t7 by A42,SCMPDS_7:37;
            now
          let k be Element of NAT;
          per cases;
          suppose k < m3+1;
           then A51: k <= m3 by INT_1:20;
           hereby
              per cases by A51,NAT_1:8;
              suppose A52:k <= m2;
               hereby
               per cases;
                 suppose k=0;
                 hence IC (Computation t3).k in dom pWHL by A17,A18,
AMI_1:def 19;
                 end;
                 suppose k<>0;
                  then consider kn be Nat such that
              A53: k=kn+1 by NAT_1:6;
                  reconsider kn as Element of NAT by ORDINAL1:def 13;
                  kn < k by A53,XREAL_1:31;
                  then kn < m2 by A52,XXREAL_0:2;
              then A54: IC (Computation t2).kn + 1 = IC (Computation t4).kn
                  by A1,A13,A15,A16,A24,A26,A34,SCMPDS_7:34;
              A55: IC (Computation t2).kn in dom pI by A12,SCMPDS_6:def 2;
                  consider lm be Element of NAT such that
              A56: IC (Computation t2).kn=inspos lm by SCMPDS_3:32;
                       lm < card pI by A55,A56,SCMPDS_4:1;
                  then lm < card I+1 by SCMPDS_5:7;
              then A57: lm+1 <= card I +1 by INT_1:20;
                       card I + 1 < card I + 3 by XREAL_1:8;
                  then lm+1 < card I +3 by A57,XXREAL_0:2;
                  then A58: lm+1 < card pWHL by Lm1;
                       IC (Computation t3).k=inspos lm +1 by A53,A54,A56,
AMI_1:51
                  .=inspos (lm+1) by SCMPDS_3:def 3;
                  hence IC (Computation t3).k in dom pWHL by A58,SCMPDS_4:1;
               end;
               end;
              end;
              suppose A59:k=m3;
                    l1 in dom pWHL by A31,SCMPDS_6:18;
               hence IC (Computation t3).k in dom pWHL by A1,A13,A15,A16,A24
,A26,A34,A39,A59,SCMPDS_7:36;
            end;
            end;
          end;
          suppose k >= m3+1;
          then consider nn be Nat such that
         A60: k=m3+1+nn by NAT_1:10;
           reconsider nn as Element of NAT by ORDINAL1:def 13;
           C3.k=(Computation (t7 +* iWHL)).nn by A50,A60,AMI_1:51;
           hence IC (Computation t3).k in dom pWHL by A49,SCMPDS_6:def 2;
       end;
       end;
       hence WHL is_closed_on t by SCMPDS_6:def 2;
       t7 is halting by A49,A50,SCMPDS_6:def 3;
       then t3 is halting by SCM_1:27;
       hence WHL is_halting_on t by SCMPDS_6:def 3;
     end;
     end;
     hence P[k+1];
     end;
A61:  for k being Element of NAT holds P[k] from NAT_1:sch 1(A3,A6);
     per cases;
     suppose s.b >= 0;
       hence WHL is_closed_on s & WHL is_halting_on s by Th9;
     end;
     suppose s.b <0;
        then -s.b > 0 by XREAL_1:60;
        then reconsider n=-s.b as Element of NAT by INT_1:16;
       A62: P[n] by A61;
       for x be Int_position st x in X holds s.x=s.x;
       hence WHL is_closed_on s & WHL is_halting_on s by A62;
end;
end;

theorem
      for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position,i be Integer,X be set st
  s.DataLoc(s.a,i) < 0 & card I > 0 &
  (for t be State of SCMPDS st
    (for x be Int_position st x in X holds t.x=s.x) &
    t.a=s.a & t.DataLoc(s.a,i) < 0
   holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i) > t.DataLoc(s.a,i) &
    I is_closed_on t & I is_halting_on t &
    for x be Int_position st x in X holds IExec(I,t).x=t.x)
 holds
   IExec(while<0(a,i,I),s) =IExec(while<0(a,i,I),IExec(I,s))
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
  a be Int_position, i be Integer,X be set;
   set b=DataLoc(s.a,i);
   set WHL=while<0(a,i,I),
       iWHL=Initialized stop WHL,
       iI= Initialized stop I,
       s1= s +* iWHL,
       C1=Computation s1,
       ps= s | A;
   set i1=(a,i)>=0_goto (card I+2),
       i2=goto -(card I+1);

   assume A1: s.b < 0;
   assume A2: card I > 0;
   assume A3: for t be State of SCMPDS st
     (for x st x in X holds t.x=s.x) & t.a=s.a & t.b < 0
    holds IExec(I,t).a=t.a & IExec(I,t).b > t.b &
     I is_closed_on t & I is_halting_on t &
     for x st x in X holds IExec(I,t).x=t.x;

    then WHL is_halting_on s by A2,Th15;
then A4: s1 is halting by SCMPDS_6:def 3;
   set sI= s +* iI,
       m1=LifeSpan sI+2,
       s2=IExec(I,s) +* iWHL,
       C2=Computation s2,
       m2=LifeSpan s2;
       set Es=IExec(I,s),
           bj=DataLoc(Es.a,i);
A5: (for x st x in X holds s.x=s.x) & s.a=s.a;
then A6: I is_closed_on s & I is_halting_on s by A1,A3;
A7: Es.a=s.a by A1,A3,A5;
         now
      let t be State of SCMPDS;
      assume
A8:  (for x st x in X holds t.x=Es.x) & t.a=Es.a & t.bj < 0;
A9:   now
         let x be Int_position;
         assume A10: x in X;
         hence t.x=Es.x by A8
          .=s.x by A1,A3,A5,A10;
      end;
      hence IExec(I,t).a=t.a by A3,A7,A8;
      thus IExec(I,t).bj > t.bj by A3,A7,A8,A9;
      thus I is_closed_on t & I is_halting_on t &
       for x st x in X holds IExec(I,t).x=t.x by A3,A7,A8,A9;
     end;
then A11:  WHL is_halting_on Es by A2,Th15;
   set s4 = C1.1;
A12:     iI c= sI by FUNCT_4:26;
A13:     sI is halting by A6,SCMPDS_6:def 3;
        then sI +* iI is halting by A12,FUNCT_4:79;
then A14:     I is_halting_on sI by SCMPDS_6:def 3;
A15:     I is_closed_on sI by A6,SCMPDS_6:38;
A16:     IC s1 =inspos 0 by SCMPDS_6:21;
A17:     WHL = i1 ';' (I ';' i2) by Lm2;
then A18:     CurInstr s1 = i1 by SCMPDS_6:22;
A19:     (Computation s1).(0 + 1) = Following (Computation s1).0 by
AMI_1:def 19
        .= Following s1 by AMI_1:def 19
        .= Exec(i1,s1) by A18,AMI_1:def 18;
A20:     not a in dom iWHL & a in dom s by SCMPDS_2:49,SCMPDS_4:31;
A21:    not b in dom iWHL & b in dom s by SCMPDS_2:49,SCMPDS_4:31;
        A22: s1.DataLoc(s1.a,i)=s1.b by A20,FUNCT_4:12
        .= s.b by A21,FUNCT_4:12;
A23:    IC s4 = s4.IC SCMPDS by AMI_1:def 15
        .= Next IC s1 by A1,A19,A22,SCMPDS_2:69
        .= inspos(0+1) by A16,SCMPDS_4:70;
             sI,s1 equal_outside A by SCMPDS_4:36;
then A24:    sI | D = s1 | D by SCMPDS_4:24;
             now let a;
          thus sI.a = s1.a by A24,SCMPDS_4:23
          .= s4.a by A19,SCMPDS_2:69;
        end;
then A25:    sI | D = s4 | D by SCMPDS_4:23;

        set mI=LifeSpan sI,
            s5=(Computation s4).mI,
            l1=inspos (card I + 1);

A26:     IExec(I,s) = Result sI +* s | A by SCMPDS_4:def 8;
A27:     dom (s | A) = A by SCMPDS_6:1;
             card I + 1 < card I + 2 by XREAL_1:8;
then A28:    l1 in dom WHL by Th7;
A29:    WHL c= iWHL by SCMPDS_6:17;
             iWHL c= s1 by FUNCT_4:26;
then A30:    WHL c= s1 by A29,XBOOLE_1:1;
             Shift(I,1) c= WHL by Lm3;
        then Shift(I,1) c= s1 by A30,XBOOLE_1:1;
then A31:     Shift(I,1) c= s4 by AMI_3:38;
then A32:     (Computation sI).mI | D = s5 | D
        by A2,A12,A14,A15,A23,A25,SCMPDS_7:36;
        set m3=mI +1;
        set s6=(Computation s1).m3;
A33:     IC s5=l1 by A2,A12,A14,A15,A23,A25,A31,SCMPDS_7:36;
A34:     s6=s5 by AMI_1:51;
then A35:     CurInstr s6=s5.l1 by A33,AMI_1:def 17
        .=s4.l1 by AMI_1:54
        .=s1.l1 by AMI_1:54
        .=WHL.l1 by A28,A30,GRFUNC_1:8
        .=i2 by Th8;
        set s7=(Computation s1).(m3+ 1);
A36:     s7 = Following s6 by AMI_1:def 19
        .= Exec(i2,s6) by A35,AMI_1:def 18;
A37:    IC s7=s7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(s6,0-(card I+1)) by A36,SCMPDS_2:66
       .=inspos 0 by A33,A34,SCMPDS_7:1;
          now
       let x be Int_position;
A38:    not x in dom iWHL & x in dom IExec(I,s) by SCMPDS_2:49,SCMPDS_4:31;
A39: now assume x in dom (s | A);
      then reconsider l=x as Instruction-Location of SCMPDS
             by A27,AMI_1:def 4;
      l=x;
     hence contradiction by A27,SCMPDS_2:53;
    end;
        s5.x=(Computation sI).mI.x by A32,SCMPDS_4:23
       .=(Result sI).x by A13,SCMFSA6B:16
       .=IExec(I,s).x by A26,A39,FUNCT_4:12;
  hence s7.x=IExec(I,s).x by A34,A36,SCMPDS_2:66
        .=s2.x by A38,FUNCT_4:12;
     end;
     then A40: s7 | D = s2 | D by SCMPDS_4:23;
A41:  IC s2 =IC C1.m1 by A37,SCMPDS_6:21;

A42: s2 is halting by A11,SCMPDS_6:def 3;
A43: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
         s2 | A= (Result sI +* ps +* iWHL) | A by SCMPDS_4:def 8
    .=(Result sI +* ps)|A +* iWHL | A by FUNCT_4:75
    .= ps +* iWHL | A by A43,FUNCT_4:24
    .= s1 | A by FUNCT_4:75
    .= C1.m1 | A by SCMPDS_7:6;
then A44: C1.m1=s2 by A40,A41,SCMPDS_7:7;
    then CurInstr C1.m1=i1 by A17,SCMPDS_6:22;
then A45: CurInstr C1.m1 <> halt SCMPDS by SCMPDS_6:31;
    set m0=LifeSpan s1;
    m0 > m1 by A4,A45,SCMPDS_6:2;
    then consider nn be Nat such that
A46: m0=m1+nn by NAT_1:10;
     reconsider nn as Element of NAT by ORDINAL1:def 13;
A47: C1.m0 = C2.nn by A44,A46,AMI_1:51;
    then CurInstr C2.nn =halt SCMPDS by A4,SCM_1:def 2;
then A48: nn >= m2 by A42,SCM_1:def 2;
         C1.(m1 + m2) = C2.m2 by A44,AMI_1:51;
    then CurInstr C1.(m1 + m2) = halt SCMPDS by A42,SCM_1:def 2;
    then m1 + m2 >= m0 by A4,SCM_1:def 2;
    then m2 >= nn by A46,XREAL_1:8;
then nn=m2 by A48,XXREAL_0:1;
then A49: Result s1 = C2.m2 by A4,A47,SCMFSA6B:16;
A50: IExec(I,s) | A= (Result sI +* ps) | A by SCMPDS_4:def 8
    .= ps by A43,FUNCT_4:24;
    thus IExec(WHL,s)
     = C2.m2 +* ps by A49,SCMPDS_4:def 8
    .= Result s2 +* IExec(I,s) | A by A42,A50,SCMFSA6B:16
    .= IExec(WHL,IExec(I,s)) by SCMPDS_4:def 8;
end;

begin :: The construction and basic properties of while>0 program
:: while (a,i)>0 do I

definition
 let a be Int_position, i be Integer,I be Program-block;
 func while>0(a,i,I) -> Program-block equals
   (a,i)<=0_goto (card I +2) ';' I ';' goto -(card I+1);
 coherence;
end;

registration
   let I be shiftable Program-block,a be Int_position,i be Integer;
   cluster while>0(a,i,I) -> shiftable;
   correctness
   proof
    set WHL=while>0(a,i,I),
        i1= (a,i)<=0_goto (card I +2),
        i2= goto -(card I+1);
   reconsider PF= Load i1 ';' I as shiftable Program-block;
A1: PF=i1 ';' I by SCMPDS_4:def 4;
    then card PF=card I + 1 by SCMPDS_6:15;
then A2:  card PF+ -(card I+1) =0;
          WHL= PF ';' i2 by A1;
     hence WHL is shiftable by A2,SCMPDS_4:78;
  end;
end;

registration
   let I be No-StopCode Program-block,a be Int_position,i be Integer;
   cluster while>0(a,i,I) -> No-StopCode;
   correctness;
end;

theorem Th17:
 for a be Int_position,i be Integer,I be Program-block holds
  card while>0(a,i,I)= card I +2
proof
  let a be Int_position,i be Integer, I be Program-block;
  set i1=(a,i)<=0_goto (card I +2),
      i2=goto -(card I+1);
  set I4=i1 ';' I;
    thus card while>0(a,i,I)=card I4+1 by SCMP_GCD:8
    .=card I +1 +1 by SCMPDS_6:15
    .=card I + 2;
end;

Lm4:
 for a be Int_position,i be Integer,I be Program-block holds
  card stop while>0(a,i,I)= card I+3
proof
   let a be Int_position,i be Integer,I be Program-block;
   thus card stop while>0(a,i,I)= card while>0(a,i,I) +1 by SCMPDS_5:7
   .= card I +2+1 by Th17
   .= card I + 3;
end;

theorem Th18:
 for a be Int_position,i be Integer,m be Element of NAT,I be Program-block
 holds
   m < card I+2 iff inspos m in dom while>0(a,i,I)
proof
   let a be Int_position,i be Integer,m be Element of NAT,I be Program-block;
        card while>0(a,i,I)=card I + 2 by Th17;
   hence thesis by SCMPDS_4:1;
end;

theorem Th19:
 for a be Int_position,i be Integer,I be Program-block holds
    while>0(a,i,I).inspos 0=(a,i)<=0_goto (card I +2) &
    while>0(a,i,I).inspos (card I+1)=goto -(card I+1)
proof
    let a be Int_position,i be Integer,I be Program-block;
    set i1=(a,i)<=0_goto (card I +2),
        i2=goto -(card I+1);
    set I4=i1 ';' I;
A1: card I4=card I+1 by SCMPDS_6:15;
    set J5=I ';' i2;
    set WHL=while>0(a,i,I);
    WHL=i1 ';' J5 by SCMPDS_4:51;
   hence WHL.inspos 0=i1 by SCMPDS_6:16;
   thus WHL.inspos(card I+1)=i2 by A1,SCMP_GCD:10;
end;

Lm5:
 for a be Int_position,i be Integer,I be Program-block holds
   while>0(a,i,I)= ((a,i)<=0_goto (card I +2)) ';' (I ';'
   goto -(card I+1)) by SCMPDS_4:51;

theorem Th20:
 for s being State of SCMPDS,I being Program-block,a being Int_position,
 i being Integer st s.DataLoc(s.a,i) <= 0 holds
 while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program-block,a be Int_position,
  i be Integer;
  set d1=DataLoc(s.a,i);
  assume A1: s.d1 <= 0;
  set WHL=while>0(a,i,I),
       pWHL=stop WHL,
       iWHL=Initialized pWHL,
       s3 = s +* iWHL,
       C3 = Computation s3,
       s4 = C3.1;
  set i1=(a,i)<=0_goto (card I+2),
       i2=goto -(card I+1);

A2: IC s3 =inspos 0 by SCMPDS_6:21;
         WHL = i1 ';' (I ';' i2 ) by Lm5;
then A3: CurInstr s3 = i1 by SCMPDS_6:22;
A4: (Computation s3).(0 + 1) = Following (Computation s3).0 by AMI_1:def 19
     .= Following s3 by AMI_1:def 19
     .= Exec(i1,s3) by A3,AMI_1:def 18;
A5:  not d1 in dom iWHL & d1 in dom s by SCMPDS_2:49,SCMPDS_4:31;
          not a in dom iWHL & a in dom s by SCMPDS_2:49,SCMPDS_4:31;
then A6: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
     .= s.d1 by A5,FUNCT_4:12;

          iWHL c= s3 by FUNCT_4:26;
     then pWHL c= s3 by SCMPDS_4:57;
then A7:  pWHL c= s4 by AMI_3:38;

A8: card WHL=card I+2 by Th17;
then A9: inspos(card I+2) in dom pWHL by SCMPDS_6:25;
A10: IC s4 = s4.IC SCMPDS by AMI_1:def 15
     .= ICplusConst(s3,(card I+2)) by A1,A4,A6,SCMPDS_2:68
     .= inspos(0+(card I+2)) by A2,SCMPDS_6:23;
          s4.inspos(card I+2) = pWHL.inspos(card I+2) by A7,A9,GRFUNC_1:8
     .=halt SCMPDS by A8,SCMPDS_6:25;
then A11: CurInstr s4 = halt SCMPDS by A10,AMI_1:def 17;
          now
       let k be Element of NAT;
       per cases;
       suppose 0 < k;
         then 1+0 <= k by INT_1:20;
         hence IC C3.k in dom pWHL by A9,A10,A11,AMI_1:52;
      end;
      suppose k = 0;
          then C3.k = s3 by AMI_1:def 19;
         hence IC C3.k in dom pWHL by A2,SCMPDS_4:75;
     end;
     end;
     hence WHL is_closed_on s by SCMPDS_6:def 2;
          s3 is halting by A11,AMI_1:def 20;
     hence WHL is_halting_on s by SCMPDS_6:def 3;
end;

theorem Th21:
 for s being State of SCMPDS,I being Program-block,a,c being Int_position,
 i being Integer st s.DataLoc(s.a,i) <= 0 holds
 IExec(while>0(a,i,I),s) = s +* Start-At inspos (card I + 2)
proof
   let s be State of SCMPDS,I be Program-block, a,c be Int_position,
   i be Integer;
   set d1=DataLoc(s.a,i);
   assume A1: s.d1 <= 0;
   set WHL=while>0(a,i,I),
       pWHL=stop WHL,
       iWHL=Initialized pWHL,
       s3 = s +* iWHL,
       s4 = (Computation s3).1,
       i1=(a,i)<=0_goto (card I+2),
       i2=goto -(card I+1);
   set SAl=Start-At inspos (card I + 2);

A2: IC s3 =inspos 0 by SCMPDS_6:21;
         WHL = i1 ';' (I ';' i2) by Lm5;
then A3: CurInstr s3 = i1 by SCMPDS_6:22;
A4: (Computation s3).(0 + 1) = Following (Computation s3).0 by AMI_1:def 19
     .= Following s3 by AMI_1:def 19
     .= Exec(i1,s3) by A3,AMI_1:def 18;
A5: not d1 in dom iWHL & d1 in dom s by SCMPDS_2:49,SCMPDS_4:31;
         not a in dom iWHL & a in dom s by SCMPDS_2:49,SCMPDS_4:31;
then A6: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
     .= s.d1 by A5,FUNCT_4:12;
A7:  dom (s | A) = A by SCMPDS_6:1;
          iWHL c= s3 by FUNCT_4:26;
     then pWHL c= s3 by SCMPDS_4:57;
then A8:  pWHL c= s4 by AMI_3:38;
A9: card WHL=card I+2 by Th17;
then A10: inspos(card I+2) in dom pWHL by SCMPDS_6:25;
A11: IC s4 = s4.IC SCMPDS by AMI_1:def 15
     .= ICplusConst(s3,(card I+2)) by A1,A4,A6,SCMPDS_2:68
     .= inspos(0+(card I+2)) by A2,SCMPDS_6:23;
          s4.inspos(card I+2) = pWHL.inspos(card I+2) by A8,A10,GRFUNC_1:8
     .=halt SCMPDS by A9,SCMPDS_6:25;
then A12: CurInstr s4 = halt SCMPDS by A11,AMI_1:def 17;
then A13: s3 is halting by AMI_1:def 20;
      now let l be Element of NAT;
       assume l < 0+1;
        then l <= 0 by NAT_1:13;
        then l=0;
then CurInstr (Computation s3).l = CurInstr s3 by AMI_1:def 19;
         hence CurInstr (Computation s3).l <> halt SCMPDS by A3,SCMPDS_6:30;
      end;
      then for l be Element of NAT st CurInstr (Computation s3).l = halt SCMPDS
        holds 1 <= l;
then LifeSpan s3 = 1 by A12,A13,SCM_1:def 2;
then A14:  s4 = Result s3 by A13,SCMFSA6B:16;
A15:  dom IExec(WHL,s) = the carrier of SCMPDS by AMI_3:36
      .= dom (s +* SAl) by AMI_3:36;
A16:  IExec(WHL,s) = Result s3 +* s | A by SCMPDS_4:def 8;
           now let x be set;
      assume
A17:    x in dom IExec(WHL,s);
A18:    dom SAl = {IC SCMPDS} by FUNCOP_1:19;
       per cases by A17,SCMPDS_4:20;
       suppose
A19:    x is Int_position;
        then x <> IC SCMPDS by SCMPDS_2:52;
then A20:    not x in dom SAl by A18,TARSKI:def 1;
     now assume x in dom (s | A);
      then reconsider l=x as Instruction-Location of SCMPDS
             by A7,AMI_1:def 4;
      l=x;
     hence contradiction by A7,A19,SCMPDS_2:53;
    end;
      hence
             IExec(WHL,s).x = s4.x by A14,A16,FUNCT_4:12
       .= s3.x by A4,A19,SCMPDS_2:68
       .= s.x by A19,SCMPDS_5:19
       .= (s +* SAl).x by A20,FUNCT_4:12;
      end;
      suppose
A21:    x = IC SCMPDS;
     now assume x in dom (s | A);
      then reconsider l=x as Instruction-Location of SCMPDS
             by A7,AMI_1:def 4;
      l=x;
     hence contradiction by A7,AMI_1:48,AMI_5:25,A21;
    end;
        then x in dom Result s3 & not x in dom (s | A) by A7,AMI_1:48,AMI_5:25
,A21;
      hence
              IExec(WHL,s).x = s4.x by A14,A16,FUNCT_4:12
       .= inspos(card I + 2) by A11,A21,AMI_1:def 15
       .= (s +* SAl).x by A21,SCMPDS_7:12;
       end;
       suppose x is Instruction-Location of SCMPDS;
       hence IExec(WHL,s).x = (s +* SAl).x by SCMPDS_6:27;
    end;
    end;
    hence IExec(WHL,s) = s +* SAl by A15,FUNCT_1:9;
end;

theorem
      for s being State of SCMPDS,I being Program-block,a being Int_position,
 i being Integer st s.DataLoc(s.a,i) <= 0 holds
    IC IExec(while>0(a,i,I),s) = inspos (card I + 2)
proof
  let s be State of SCMPDS,I be Program-block,a be Int_position,
  i be Integer;
  assume s.DataLoc(s.a,i) <= 0;
      then IExec(while>0(a,i,I),s) =s +* Start-At inspos (card I+ 2) by Th21;
      hence thesis by AMI_5:79;
end;

theorem
      for s being State of SCMPDS,I being Program-block,a,b being Int_position,
 i being Integer st s.DataLoc(s.a,i) <= 0 holds
   IExec(while>0(a,i,I),s).b = s.b
proof
   let s be State of SCMPDS,I be Program-block,a,b be Int_position,
    i be Integer;
    assume s.DataLoc(s.a,i) <= 0;
then A1: IExec(while>0(a,i,I),s) = s +* Start-At inspos (card I + 2) by Th21;
         not b in dom Start-At inspos (card I + 2) by SCMPDS_4:59;
    hence IExec(while>0(a,i,I),s).b = s.b by A1,FUNCT_4:12;
end;

Lm6:
 for I being Program-block,a being Int_position,i being Integer
 holds Shift(I,1) c= while>0(a,i,I)
proof
  let I be Program-block,a be Int_position,i be Integer;
   set i1=(a,i)<=0_goto (card I+2),
       i2=goto -(card I+1);
A1: card Load i1=1 by SCMPDS_5:6;
         while>0(a,i,I) = i1 ';' I ';' Load i2 by SCMPDS_4:def 5
     .= Load i1 ';' I ';' Load i2 by SCMPDS_4:def 4;
    hence thesis by A1,SCMPDS_7:16;
end;

scheme WhileGHalt { F(State of SCMPDS)-> Element of NAT,
 s() -> State of SCMPDS,I() -> No-StopCode shiftable Program-block,
 a() -> Int_position,i() -> Integer,P[State of SCMPDS]}:
   (F(s())=F(s()) or P[s()]) &
   while>0(a(),i(),I()) is_closed_on s() &
   while>0(a(),i(),I()) is_halting_on s()
provided
A1: card I() > 0 and
A2: (for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds
    t.DataLoc(s().a(),i()) <= 0) and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS st
       P[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) > 0
    holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
        I() is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) &
        P[Dstate(IExec(I(),t))]
proof
   set b=DataLoc(s().a(),i());
   set WHL=while>0(a(),i(),I()),
       pWHL=stop WHL,
       iWHL=Initialized pWHL,
       pI=stop I(),
       IsI= Initialized pI;
   set i1=(a(),i())<=0_goto (card I()+2),
       i2=goto -(card I()+1);
    defpred Q[Element of NAT] means
       for t be State of SCMPDS st F(Dstate(t)) <= $1 & P[Dstate t] &
       t.a()=s().a()
       holds WHL is_closed_on t & WHL is_halting_on t;
A5:  Q[0]
      proof
        let t be State of SCMPDS;
        assume A6: F(Dstate(t)) <= 0 & P[Dstate t] & t.a()=s().a();
        then F(Dstate(t))=0;
        then t.b <= 0 by A2,A6;
        hence WHL is_closed_on t & WHL is_halting_on t by A6,Th20;
      end;
A7:  for k be Element of NAT st Q[k] holds Q[k + 1]
     proof
     let k be Element of NAT;
     assume A8: Q[k];
           now
        let t be State of SCMPDS;
        assume A9: F(Dstate(t)) <= k+1;
        assume A10: P[Dstate t];
        assume A11: t.a()=s().a();
        per cases;
        suppose t.b <= 0;
          hence WHL is_closed_on t & WHL is_halting_on t by A11,Th20;
        end;
        suppose A12: t.b > 0;
        set t2 = t +* IsI,
            t3 = t +* iWHL,
            C3 = Computation t3,
            t4 = C3.1;
A13:     IExec(I(),t).a()=t.a() & I() is_closed_on t & I() is_halting_on t &
        F(Dstate IExec(I(),t)) < F(Dstate t) &
        P[Dstate(IExec(I(),t))] by A4,A10,A11,A12;
A14:     IsI c= t2 by FUNCT_4:26;
A15:     t2 is halting by A13,SCMPDS_6:def 3;
        then t2 +* IsI is halting by A14,FUNCT_4:79;
then A16:     I() is_halting_on t2 by SCMPDS_6:def 3;
A17:     I() is_closed_on t2 by A13,SCMPDS_6:38;
A18:     inspos 0 in dom pWHL by SCMPDS_4:75;
A19:     IC t3 =inspos 0 by SCMPDS_6:21;
             WHL = i1 ';' (I() ';' i2) by Lm5;
then A20:     CurInstr t3 = i1 by SCMPDS_6:22;
A21:     (Computation t3).(0 + 1) = Following (Computation t3).0 by
AMI_1:def 19
        .= Following t3 by AMI_1:def 19
        .= Exec(i1,t3) by A20,AMI_1:def 18;
A22:     not a() in dom iWHL & a() in dom t by SCMPDS_2:49,SCMPDS_4:31;
A23:     not b in dom iWHL & b in dom t by SCMPDS_2:49,SCMPDS_4:31;
        A24: t3.DataLoc(t3.a(),i())= t3.b by A11,A22,FUNCT_4:12
        .= t.b by A23,FUNCT_4:12;
A25:     IC t4 = t4.IC SCMPDS by AMI_1:def 15
        .= Next IC t3 by A12,A21,A24,SCMPDS_2:68
        .= inspos(0+1) by A19,SCMPDS_4:70;
             t2,t3 equal_outside A by SCMPDS_4:36;
then A26:     t2 | D = t3 | D by SCMPDS_4:24;
             now let a;
          thus t2.a = t3.a by A26,SCMPDS_4:23
          .= t4.a by A21,SCMPDS_2:68;
        end;
then A27:    t2 | D = t4 | D by SCMPDS_4:23;

        set m2=LifeSpan t2,
            t5=(Computation t4).m2,
            l1=inspos (card I() + 1);

A28:     IExec(I(),t) = Result t2 +* t | A by SCMPDS_4:def 8;
X:       dom (t | A) = A by SCMPDS_6:1;
A29: now assume a() in dom (t | A);
      then reconsider l=a() as Instruction-Location of SCMPDS
             by X,AMI_1:def 4;
      l=a();
     hence contradiction by X,SCMPDS_2:53;
    end;
             card I() + 1 < card I() + 2 by XREAL_1:8;
then A30:     l1 in dom WHL by Th18;
A31:     WHL c= iWHL by SCMPDS_6:17;
             iWHL c= t3 by FUNCT_4:26;
then A32:     WHL c= t3 by A31,XBOOLE_1:1;
             Shift(I(),1) c= WHL by Lm6;
        then Shift(I(),1) c= t3 by A32,XBOOLE_1:1;
then A33:     Shift(I(),1) c= t4 by AMI_3:38;
then A34:     (Computation t2).m2 | D = t5 | D by A1,A14,A16,A17,A25,A27,
SCMPDS_7:36;
then A35:     t5.a()=(Computation t2).m2.a() by SCMPDS_4:23
        .=(Result t2).a() by A15,SCMFSA6B:16
        .=s().a() by A11,A13,A28,A29,FUNCT_4:12;
        A36: dom (t | A) = A by SCMPDS_6:1;
A37:     t5|D =(Result t2)|D by A15,A34,SCMFSA6B:16
        .= (Result t2 +* t | A)|D by A36,FUNCT_4:76,AMI_5:33
        .=IExec(I(),t)|D by SCMPDS_4:def 8;

        set m3=m2 +1;
        set t6=(Computation t3).m3;
A38:     IC t5=l1 by A1,A14,A16,A17,A25,A27,A33,SCMPDS_7:36;
A39:     t6=t5 by AMI_1:51;
then A40:     CurInstr t6=t5.l1 by A38,AMI_1:def 17
        .=t4.l1 by AMI_1:54
        .=t3.l1 by AMI_1:54
        .=WHL.l1 by A30,A32,GRFUNC_1:8
        .=i2 by Th19;
        set t7=(Computation t3).(m3+ 1);
A41:     t7 = Following t6 by AMI_1:def 19
        .= Exec(i2,t6) by A40,AMI_1:def 18;
A42:    IC t7=t7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(t6,0-(card I()+1)) by A41,SCMPDS_2:66
       .=inspos 0 by A38,A39,SCMPDS_7:1;
A43:    t7.a()=t6.a() by A41,SCMPDS_2:66
       .=s().a() by A35,AMI_1:51;

            InsCode i2=0 by SCMPDS_2:21;
       then InsCode i2 in {0,4,5,6} by ENUMSET1:def 2;
then A44:    Dstate(t7)=Dstate(t6) by A41,Th3
       .=Dstate(IExec(I(),t)) by A37,A39,Th2;
           now
         assume A45:F(Dstate(t7)) > k;
              F(Dstate(IExec(I(),t))) < F(Dstate(t)) by A4,A10,A11,A12;
    then F(Dstate(t7)) < k+1 by A9,A44,XXREAL_0:2;
         hence contradiction by A45,INT_1:20;
       end;
then A46:    WHL is_closed_on t7 & WHL is_halting_on t7 by A8,A13,A43,A44;
A47:    t7 +* iWHL=t7 by A42,SCMPDS_7:37;
            now
          let k be Element of NAT;
          per cases;
          suppose k < m3+1;
           then A48: k <= m3 by INT_1:20;
           hereby
              per cases by A48,NAT_1:8;
              suppose A49:k <= m2;
               hereby
               per cases;
                 suppose k=0;
                 hence IC (Computation t3).k in dom pWHL by A18,A19,
AMI_1:def 19;
                 end;
                 suppose k<>0;
                  then consider kn be Nat such that
              A50: k=kn+1 by NAT_1:6;
                  reconsider kn as Element of NAT by ORDINAL1:def 13;
                  kn < k by A50,XREAL_1:31;
                  then kn < m2 by A49,XXREAL_0:2;
              then A51: IC (Computation t2).kn + 1 = IC (Computation t4).kn
                  by A1,A14,A16,A17,A25,A27,A33,SCMPDS_7:34;
              A52: IC (Computation t2).kn in dom pI by A13,SCMPDS_6:def 2;
                  consider lm be Element of NAT such that
              A53: IC (Computation t2).kn=inspos lm by SCMPDS_3:32;
                       lm < card pI by A52,A53,SCMPDS_4:1;
                  then lm < card I()+1 by SCMPDS_5:7;
              then A54: lm+1 <= card I() +1 by INT_1:20;
                       card I() + 1 < card I() + 3 by XREAL_1:8;
                  then lm+1 < card I() +3 by A54,XXREAL_0:2;
                  then A55: lm+1 < card pWHL by Lm4;
                       IC (Computation t3).k=inspos lm +1 by A50,A51,A53,
AMI_1:51
                  .=inspos (lm+1) by SCMPDS_3:def 3;
                  hence IC (Computation t3).k in dom pWHL by A55,SCMPDS_4:1;
               end;
               end;
              end;
              suppose A56:k=m3;
              l1 in dom pWHL by A30,SCMPDS_6:18;
               hence IC (Computation t3).k in dom pWHL by A1,A14,A16,A17,A25
,A27,A33,A39,A56,SCMPDS_7:36;
            end;
            end;
          end;
          suppose k >= m3+1;
          then consider nn be Nat such that
         A57: k=m3+1+nn by NAT_1:10;
A58:        nn in NAT by ORDINAL1:def 13; then
           C3.k=(Computation (t7 +* iWHL)).nn by A47,A57,AMI_1:51;
           hence IC (Computation t3).k in dom pWHL by A46,A58,SCMPDS_6:def 2;
       end;
       end;
       hence WHL is_closed_on t by SCMPDS_6:def 2;
       t7 is halting by A46,A47,SCMPDS_6:def 3;
       then t3 is halting by SCM_1:27;
       hence WHL is_halting_on t by SCMPDS_6:def 3;
     end;
     end;
     hence Q[k+1];
     end;
A59:  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A5,A7);
     set n=F(Dstate s());
     A60: Q[n] by A59;
     thus F(s())=F(s()) or P[s()];
     thus WHL is_closed_on s() & WHL is_halting_on s() by A3,A60;
end;

scheme WhileGExec { F(State of SCMPDS)-> Element of NAT,
 s() -> State of SCMPDS,I() -> No-StopCode shiftable Program-block,
 a() -> Int_position,i() -> Integer,P[State of SCMPDS]}:
   (F(s())=F(s()) or P[s()]) &
   IExec(while>0(a(),i(),I()),s()) =
    IExec(while>0(a(),i(),I()),IExec(I(),s()))
provided
A1: card I() > 0 and
A2: s().DataLoc(s().a(),i()) > 0 and
A3: (for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds
    t.DataLoc(s().a(),i()) <= 0) and
A4: P[Dstate s()] and
A5: for t be State of SCMPDS st
       P[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) > 0
    holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
        I() is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) &
        P[Dstate(IExec(I(),t))]
proof
   set b=DataLoc(s().a(),i());
   set WHL=while>0(a(),i(),I()),
       iWHL=Initialized stop WHL,
       iI= Initialized stop I(),
       s1= s() +* iWHL,
       C1=Computation s1,
       ps= s() | A;
   set i1=(a(),i())<=0_goto (card I()+2),
       i2=goto -(card I()+1);
   deffunc U(State of SCMPDS) = F($1);
A6: (for t be State of SCMPDS st P[Dstate t] & U(Dstate(t))=0 holds
    t.DataLoc(s().a(),i()) <= 0) by A3;
A7: P[Dstate s()] by A4;
A8: for t be State of SCMPDS st
       P[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) > 0
    holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
        I() is_halting_on t & U(Dstate IExec(I(),t)) < U(Dstate t) &
        P[Dstate(IExec(I(),t))] by A5;

         (U(s())=U(s()) or P[s()]) & WHL is_closed_on s() &
    WHL is_halting_on s() from WhileGHalt(A1,A6,A7,A8);
then A9: s1 is halting by SCMPDS_6:def 3;
    set sI= s() +* iI,
       m1=LifeSpan sI+2,
       s2=IExec(I(),s()) +* iWHL,
       C2=Computation s2,
       m2=LifeSpan s2;
       set Es=IExec(I(),s()),
           bj=DataLoc(Es.a(),i());
A10: I() is_closed_on s() & I() is_halting_on s() by A2,A4,A5;
A11: IExec(I(), s()).a()=s().a() by A2,A4,A5;
   deffunc U(State of SCMPDS) = F($1);
 A12: for t be State of SCMPDS st P[Dstate t] & U(Dstate(t))=0
    holds t.bj <= 0 by A3,A11;
A13: P[Dstate Es] by A2,A4,A5;
A14: for t be State of SCMPDS st
      P[Dstate t] & t.a()=Es.a() & t.bj > 0 holds
      IExec(I(),t).a()=t.a() & I() is_closed_on t &
          I() is_halting_on t & U(Dstate IExec(I(),t)) < U(Dstate t)
          & P[Dstate(IExec(I(),t))] by A5,A11;
A15:  (U(Es)=U(Es) or P[Es]) & WHL is_closed_on Es &
     WHL is_halting_on Es from WhileGHalt(A1,A12,A13,A14);
   set s4 = C1.1;
A16:   sI is halting by A10,SCMPDS_6:def 3;
A17:   iI c= sI by FUNCT_4:26;
      then sI +* iI is halting by A16,FUNCT_4:79;
then A18:   I() is_halting_on sI by SCMPDS_6:def 3;
A19:   I() is_closed_on sI by A10,SCMPDS_6:38;
A20:   WHL = i1 ';' (I() ';' i2) by Lm5;
then A21:  CurInstr s1 = i1 by SCMPDS_6:22;
A22:  IC s1 =inspos 0 by SCMPDS_6:21;
A23:  (Computation s1).(0 + 1) = Following (Computation s1).0 by AMI_1:def 19
     .= Following s1 by AMI_1:def 19
     .= Exec(i1,s1) by A21,AMI_1:def 18;
     A24: s1.DataLoc(s1.a(),i())=s1.b by SCMPDS_5:19
     .= s().b by SCMPDS_5:19;
A25:  IC s4 = s4.IC SCMPDS by AMI_1:def 15
     .= Next IC s1 by A2,A23,A24,SCMPDS_2:68
     .= inspos(0+1) by A22,SCMPDS_4:70;
          sI,s1 equal_outside A by SCMPDS_4:36;
then A26:  sI | D = s1 | D by SCMPDS_4:24;
          now let a;
         thus sI.a = s1.a by A26,SCMPDS_4:23
          .= s4.a by A23,SCMPDS_2:68;
     end;
then A27:  sI | D = s4 | D by SCMPDS_4:23;

     set mI=LifeSpan sI,
         s5=(Computation s4).mI,
         l1=inspos (card I() + 1);

A28:    IExec(I(),s()) = Result sI +* s() | A by SCMPDS_4:def 8;
A29:    dom (s() | A) = A by SCMPDS_6:1;
            card I() + 1 < card I() + 2 by XREAL_1:8;
then A30:    l1 in dom WHL by Th18;
A31:    WHL c= iWHL by SCMPDS_6:17;
            iWHL c= s1 by FUNCT_4:26;
then A32:    WHL c= s1 by A31,XBOOLE_1:1;
            Shift(I(),1) c= WHL by Lm6;
       then Shift(I(),1) c= s1 by A32,XBOOLE_1:1;
then A33:    Shift(I(),1) c= s4 by AMI_3:38;
then A34:    (Computation sI).mI | D = s5 | D
       by A1,A17,A18,A19,A25,A27,SCMPDS_7:36;
        set m3=mI +1;
        set s6=(Computation s1).m3;
A35:     IC s5=l1 by A1,A17,A18,A19,A25,A27,A33,SCMPDS_7:36;
A36:     s6=s5 by AMI_1:51;
then A37:     CurInstr s6=s5.l1 by A35,AMI_1:def 17
        .=s4.l1 by AMI_1:54
        .=s1.l1 by AMI_1:54
        .=WHL.l1 by A30,A32,GRFUNC_1:8
        .=i2 by Th19;
        set s7=(Computation s1).(m3+ 1);
A38:     s7 = Following s6 by AMI_1:def 19
        .= Exec(i2,s6) by A37,AMI_1:def 18;
A39:    IC s7=s7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(s6,0-(card I()+1)) by A38,SCMPDS_2:66
       .=inspos 0 by A35,A36,SCMPDS_7:1;
            now
          let x be Int_position;
  A40:     not x in dom iWHL & x in dom IExec(I(),s())
          by SCMPDS_2:49,SCMPDS_4:31;
A41: now assume x in dom (s() | A);
      then reconsider l=x as Instruction-Location of SCMPDS
             by A29,AMI_1:def 4;
      l=x;
     hence contradiction by A29,SCMPDS_2:53;
    end;
           s5.x=(Computation sI).mI.x by A34,SCMPDS_4:23
         .=(Result sI).x by A16,SCMFSA6B:16
         .=IExec(I(),s()).x by A28,A41,FUNCT_4:12;
       hence s7.x=IExec(I(),s()).x by A36,A38,SCMPDS_2:66
         .=s2.x by A40,FUNCT_4:12;
     end;
     then A42: s7 | D = s2 | D by SCMPDS_4:23;
A43:  IC s2 =IC C1.m1 by A39,SCMPDS_6:21;
A44: s2 is halting by A15,SCMPDS_6:def 3;
A45: dom ps = dom s() /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
         s2 | A= (Result sI +* ps +* iWHL) | A by SCMPDS_4:def 8
    .=(Result sI +* ps)|A +* iWHL | A by FUNCT_4:75
    .= ps +* iWHL | A by A45,FUNCT_4:24
    .= s1 | A by FUNCT_4:75
    .= C1.m1 | A by SCMPDS_7:6;
then A46: C1.m1=s2 by A42,A43,SCMPDS_7:7;
    then CurInstr C1.m1=i1 by A20,SCMPDS_6:22;
then A47: CurInstr C1.m1 <> halt SCMPDS by SCMPDS_6:30;
    set m0=LifeSpan s1;
         m0 > m1 by A9,A47,SCMPDS_6:2;
    then consider nn be Nat such that
A48: m0=m1+nn by NAT_1:10;
     reconsider nn as Element of NAT by ORDINAL1:def 13;
A49: C1.m0 = C2.nn by A46,A48,AMI_1:51;
    then CurInstr C2.nn =halt SCMPDS by A9,SCM_1:def 2;
then A50: nn >= m2 by A44,SCM_1:def 2;
         C1.(m1 + m2) = C2.m2 by A46,AMI_1:51;
    then CurInstr C1.(m1 + m2) = halt SCMPDS by A44,SCM_1:def 2;
    then m1 + m2 >= m0 by A9,SCM_1:def 2;
    then m2 >= nn by A48,XREAL_1:8;
then nn=m2 by A50,XXREAL_0:1;
then A51: Result s1 = C2.m2 by A9,A49,SCMFSA6B:16;
A52: IExec(I(),s()) | A= (Result sI +* ps) | A by SCMPDS_4:def 8
    .= ps by A45,FUNCT_4:24;
    thus F(s())=F(s()) or P[s()];
    thus IExec(WHL,s())
      = C2.m2 +* ps by A51,SCMPDS_4:def 8
     .= Result s2 +* IExec(I(),s()) | A by A44,A52,SCMFSA6B:16
     .= IExec(WHL,IExec(I(),s())) by SCMPDS_4:def 8;
end;

theorem Th24:
 for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position,i,c be Integer,X,Y be set, f being Function of
 product the Object-Kind of SCMPDS,NAT st card I > 0 &
 ( for t be State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i) <= 0 ) &
  (for x st x in X holds s.x >= c+s.DataLoc(s.a,i)) &
  (for t be State of SCMPDS st
    (for x st x in X holds t.x >= c+t.DataLoc(s.a,i)) &
    (for x st x in Y holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0
   holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    f.Dstate(IExec(I,t)) < f.Dstate(t) &
    (for x st x in X holds IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i)) &
    for x st x in Y holds IExec(I,t).x=t.x)
holds
     while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
  a be Int_position,i,c be Integer,X,Y be set,
  f be Function of product the Object-Kind of SCMPDS,NAT;

   set b=DataLoc(s.a,i);
   set WHL=while>0(a,i,I),
       pWHL=stop WHL,
       iWHL=Initialized pWHL,
       pI=stop I,
       IsI= Initialized pI;
   set i1=(a,i)<=0_goto (card I+2),
       i2=goto -(card I+1);

   assume A1: card I > 0;
   assume A2: for t be State of SCMPDS st f.Dstate(t)=0 holds t.b <= 0;
   assume A3: for x st x in X holds s.x >= c+s.b;
   assume A4: for t be State of SCMPDS st (for x st x in X holds t.x >= c+t.b)
       & (for x st x in Y holds t.x=s.x) & t.a=s.a & t.b > 0
    holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
      f.Dstate(IExec(I,t)) < f.Dstate(t) &
      (for x st x in X holds IExec(I,t).x >= c+IExec(I,t).b ) &
      for x st x in Y holds IExec(I,t).x=t.x;
    defpred P[Element of NAT] means
       for t be State of SCMPDS st f.Dstate(t) <= $1 &
      (for x st x in X holds t.x >= c+t.b) &
      (for x st x in Y holds t.x=s.x) & t.a=s.a
      holds WHL is_closed_on t & WHL is_halting_on t;
A5:  P[0]
      proof
        let t be State of SCMPDS;
        assume A6: f.Dstate(t) <= 0;
        assume for x be Int_position st x in X holds t.x >= c+t.b;
        assume for x st x in Y holds t.x=s.x;
        assume A7: t.a=s.a;
            f.Dstate(t)=0 by A6;
        then t.b <= 0 by A2;
        hence WHL is_closed_on t & WHL is_halting_on t by A7,Th20;
      end;
A8:  for k be Element of NAT st P[k] holds P[k + 1]
     proof
     let k be Element of NAT;
     assume A9: P[k];
           now
        let t be State of SCMPDS;
        assume A10: f.Dstate(t) <= k+1;
        assume A11: for x st x in X holds t.x >= c+t.b;
        assume A12: for x st x in Y holds t.x=s.x;
        assume A13: t.a=s.a;
        per cases;
        suppose t.b <= 0;
          hence WHL is_closed_on t & WHL is_halting_on t by A13,Th20;
        end;
        suppose A14: t.b > 0;
        set t2 = t +* IsI,
            t3 = t +* iWHL,
            C3 = Computation t3,
            t4 = C3.1;
A15:     IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
        f.Dstate(IExec(I,t)) < f.Dstate(t) &
        (for x st x in X holds IExec(I,t).x >= c+IExec(I,t).b)
        & for x st x in Y holds IExec(I,t).x=t.x by A4,A11,A12,A13,A14;
A16:     IsI c= t2 by FUNCT_4:26;
A17:     t2 is halting by A15,SCMPDS_6:def 3;
        then t2 +* IsI is halting by A16,FUNCT_4:79;
then A18:     I is_halting_on t2 by SCMPDS_6:def 3;
A19:     I is_closed_on t2 by A15,SCMPDS_6:38;
A20:     inspos 0 in dom pWHL by SCMPDS_4:75;
A21:     IC t3 =inspos 0 by SCMPDS_6:21;
             WHL = i1 ';' (I ';' i2) by Lm5;
then A22:     CurInstr t3 = i1 by SCMPDS_6:22;
A23:     (Computation t3).(0 + 1) = Following (Computation t3).0 by
AMI_1:def 19
        .= Following t3 by AMI_1:def 19
        .= Exec(i1,t3) by A22,AMI_1:def 18;
A24:     not a in dom iWHL & a in dom t by SCMPDS_2:49,SCMPDS_4:31;
A25:     not b in dom iWHL & b in dom t by SCMPDS_2:49,SCMPDS_4:31;
        A26: t3.DataLoc(t3.a,i)= t3.b by A13,A24,FUNCT_4:12
        .= t.b by A25,FUNCT_4:12;
A27:     IC t4 = t4.IC SCMPDS by AMI_1:def 15
        .= Next IC t3 by A14,A23,A26,SCMPDS_2:68
        .= inspos(0+1) by A21,SCMPDS_4:70;
             t2,t3 equal_outside A by SCMPDS_4:36;
then A28:     t2 | D = t3 | D by SCMPDS_4:24;
             now let a;
          thus t2.a = t3.a by A28,SCMPDS_4:23
          .= t4.a by A23,SCMPDS_2:68;
        end;
then A29:    t2 | D = t4 | D by SCMPDS_4:23;

        set m2=LifeSpan t2,
            t5=(Computation t4).m2,
            l1=inspos (card I + 1);

A30:     IExec(I,t) = Result t2 +* t | A by SCMPDS_4:def 8;
X:       dom (t | A) = A by SCMPDS_6:1;
A31: now assume a in dom (t | A);
      then reconsider l=a as Instruction-Location of SCMPDS
             by X,AMI_1:def 4;
      l=a;
     hence contradiction by X,SCMPDS_2:53;
    end;
             card I + 1 < card I + 2 by XREAL_1:8;
then A32:     l1 in dom WHL by Th18;
A33:     WHL c= iWHL by SCMPDS_6:17;
             iWHL c= t3 by FUNCT_4:26;
then A34:     WHL c= t3 by A33,XBOOLE_1:1;
             Shift(I,1) c= WHL by Lm6;
        then Shift(I,1) c= t3 by A34,XBOOLE_1:1;
then A35:     Shift(I,1) c= t4 by AMI_3:38;
then A36:     (Computation t2).m2 | D = t5 | D
          by A1,A16,A18,A19,A27,A29,SCMPDS_7:36;
then A37:     t5.a=(Computation t2).m2.a by SCMPDS_4:23
        .=(Result t2).a by A17,SCMFSA6B:16
        .=s.a by A13,A15,A30,A31,FUNCT_4:12;
        A38: dom (t | A) = A by SCMPDS_6:1;
A39:     t5|D =(Result t2)|D by A17,A36,SCMFSA6B:16
        .= (Result t2 +* t | A)|D by A38,FUNCT_4:76,AMI_5:33
        .=IExec(I,t)|D by SCMPDS_4:def 8;

        set m3=m2 +1;
        set t6=(Computation t3).m3;
A40:     IC t5=l1 by A1,A16,A18,A19,A27,A29,A35,SCMPDS_7:36;
A41:     t6=t5 by AMI_1:51;
then A42:     CurInstr t6=t5.l1 by A40,AMI_1:def 17
        .=t4.l1 by AMI_1:54
        .=t3.l1 by AMI_1:54
        .=WHL.l1 by A32,A34,GRFUNC_1:8
        .=i2 by Th19;
        set t7=(Computation t3).(m3+ 1);
A43:     t7 = Following t6 by AMI_1:def 19
        .= Exec(i2,t6) by A42,AMI_1:def 18;
A44:    IC t7=t7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(t6,0-(card I+1)) by A43,SCMPDS_2:66
       .=inspos 0 by A40,A41,SCMPDS_7:1;
A45:    t7.a=t6.a by A43,SCMPDS_2:66
       .=s.a by A37,AMI_1:51;

            InsCode i2=0 by SCMPDS_2:21;
       then InsCode i2 in {0,4,5,6} by ENUMSET1:def 2;
then A46:    Dstate(t7)=Dstate(t6) by A43,Th3
       .=Dstate(IExec(I,t)) by A39,A41,Th2;
A47:    t7.b=t5.b by A41,A43,SCMPDS_2:66
      .=IExec(I,t).b by A39,SCMPDS_3:4;
A48:   now
         let x be Int_position;
         assume A49:x in X;
             t7.x=t5.x by A41,A43,SCMPDS_2:66
            .=IExec(I,t).x by A39,SCMPDS_3:4;
           hence t7.x >= c+t7.b by A4,A11,A12,A13,A14,A47,A49;
       end;
A50:   now
         let x be Int_position;
         assume A51:x in Y;
       thus t7.x=t5.x by A41,A43,SCMPDS_2:66
            .=IExec(I,t).x by A39,SCMPDS_3:4
            .=t.x by A4,A11,A12,A13,A14,A51
            .=s.x by A12,A51;
       end;
            now
         assume A52:f.Dstate(t7) > k;
              f.Dstate(IExec(I,t)) < f.Dstate(t) by A4,A11,A12,A13,A14;
    then f.Dstate(t7) < k+1 by A10,A46,XXREAL_0:2;
         hence contradiction by A52,INT_1:20;
       end;
then A53:    WHL is_closed_on t7 & WHL is_halting_on t7 by A9,A45,A48,A50;
A54:    t7 +* iWHL=t7 by A44,SCMPDS_7:37;
            now
          let k be Element of NAT;
          per cases;
          suppose k < m3+1;
           then A55: k <= m3 by INT_1:20;
           hereby
              per cases by A55,NAT_1:8;
              suppose A56:k <= m2;
               hereby
               per cases;
                 suppose k=0;
                 hence IC (Computation t3).k in dom pWHL by A20,A21,
AMI_1:def 19;
                 end;
                 suppose k<>0;
                  then consider kn be Nat such that
              A57: k=kn+1 by NAT_1:6;
                  reconsider kn as Element of NAT by ORDINAL1:def 13;
                  kn < k by A57,XREAL_1:31;
                  then kn < m2 by A56,XXREAL_0:2;
              then A58: IC (Computation t2).kn + 1 = IC (Computation t4).kn
                  by A1,A16,A18,A19,A27,A29,A35,SCMPDS_7:34;
              A59: IC (Computation t2).kn in dom pI by A15,SCMPDS_6:def 2;
                  consider lm be Element of NAT such that
              A60: IC (Computation t2).kn=inspos lm by SCMPDS_3:32;
                       lm < card pI by A59,A60,SCMPDS_4:1;
                  then lm < card I+1 by SCMPDS_5:7;
              then A61: lm+1 <= card I +1 by INT_1:20;
                       card I + 1 < card I + 3 by XREAL_1:8;
                  then lm+1 < card I +3 by A61,XXREAL_0:2;
                  then A62: lm+1 < card pWHL by Lm4;
                       IC (Computation t3).k=inspos lm +1 by A57,A58,A60,
AMI_1:51
                  .=inspos (lm+1) by SCMPDS_3:def 3;
                  hence IC (Computation t3).k in dom pWHL by A62,SCMPDS_4:1;
               end;
               end;
              end;
              suppose A63:k=m3;
               l1 in dom pWHL by A32,SCMPDS_6:18;
               hence IC (Computation t3).k in dom pWHL by A1,A16,A18,A19,A27
,A29,A35,A41,A63,SCMPDS_7:36;
            end;
            end;
          end;
          suppose k >= m3+1;
          then consider nn be Nat such that
         A64: k=m3+1+nn by NAT_1:10;
A65:        nn in NAT by ORDINAL1:def 13; then
           C3.k=(Computation (t7 +* iWHL)).nn by A54,A64,AMI_1:51;
           hence IC (Computation t3).k in dom pWHL by A53,A65,SCMPDS_6:def 2;
       end;
       end;
       hence WHL is_closed_on t by SCMPDS_6:def 2;
       t7 is halting by A53,A54,SCMPDS_6:def 3;
       then t3 is halting by SCM_1:27;
       hence WHL is_halting_on t by SCMPDS_6:def 3;
     end;
     end;
     hence P[k+1];
     end;
A66:  for k being Element of NAT holds P[k] from NAT_1:sch 1(A5,A8);
     set n=f.Dstate(s);
     A67: P[n] by A66;
     for x st x in Y holds s.x=s.x;
     hence WHL is_closed_on s & WHL is_halting_on s by A3,A67;
end;

theorem Th25:
 for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i,c be Integer,X,Y be set,f being Function of product
 the Object-Kind of SCMPDS,NAT st s.DataLoc(s.a,i) > 0 & card I > 0 &
 ( for t be State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i) <= 0 ) &
 (for x st x in X holds s.x >= c+s.DataLoc(s.a,i)) &
 (for t be State of SCMPDS st
    (for x st x in X holds t.x >= c+t.DataLoc(s.a,i)) &
    (for x st x in Y holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0
   holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    f.Dstate(IExec(I,t)) < f.Dstate(t) &
    (for x st x in X holds IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i)) &
    for x st x in Y holds IExec(I,t).x=t.x)
holds
   IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s))
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
  a be Int_position, i,c be Integer,X,Y be set,
  f be Function of product the Object-Kind of SCMPDS,NAT;

   set b=DataLoc(s.a,i);
   set WHL=while>0(a,i,I),
       iWHL=Initialized stop WHL,
       iI= Initialized stop I,
       s1= s +* iWHL,
       C1=Computation s1,
       ps= s | A;

   set i1=(a,i)<=0_goto (card I+2),
       i2=goto -(card I+1);

   assume A1: s.b > 0;
   assume A2: card I > 0;
   assume A3: for t be State of SCMPDS st f.Dstate(t)=0 holds t.b <= 0;
   assume A4: for x st x in X holds s.x >= c+s.b;
   assume A5: for t be State of SCMPDS st
       (for x st x in X holds t.x >= c+t.b) &
       (for x st x in Y holds t.x=s.x) & t.a=s.a & t.b > 0
       holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
       f.Dstate(IExec(I,t)) < f.Dstate(t) &
       (for x st x in X holds IExec(I,t).x >= c+IExec(I,t).b) &
       for x st x in Y holds IExec(I,t).x=t.x;
    then WHL is_halting_on s by A2,A3,A4,Th24;
then A6: s1 is halting by SCMPDS_6:def 3;
   set sI= s +* iI,
       m1=LifeSpan sI+2,
       s2=IExec(I,s) +* iWHL,
       C2=Computation s2,
       m2=LifeSpan s2;
       set Es=IExec(I,s),
           bj=DataLoc(Es.a,i);
A7: (for x st x in Y holds s.x=s.x) & s.a=s.a;
then A8: I is_closed_on s & I is_halting_on s by A1,A4,A5;
A9: IExec(I, s).a=s.a by A1,A4,A5,A7;
A10: bj=b by A1,A4,A5,A7;
A11: for x st x in X holds Es.x >= c+Es.bj by A1,A4,A5,A7,A9;
         now
      let t be State of SCMPDS;
      assume A12:(for x st x in X holds t.x >= c+t.bj) &
          (for x st x in Y holds t.x=Es.x) & t.a=Es.a & t.bj > 0;
A13:   now
         let x;
         assume A14: x in Y;
         hence t.x=Es.x by A12
          .=s.x by A1,A4,A5,A7,A14;
      end;
A15:   t.a=s.a by A1,A4,A5,A7,A12;
      thus IExec(I,t).a=t.a by A5,A9,A12,A13;
      thus I is_closed_on t & I is_halting_on t by A5,A12,A13,A15;
      thus f.Dstate(IExec(I,t)) < f.Dstate(t) by A5,A12,A13,A15;
      thus for x st x in X holds
              IExec(I,t).x >= c+IExec(I,t).bj by A5,A9,A12,A13;
      thus for x st x in Y holds IExec(I,t).x=t.x by A5,A12,A13,A15;
     end;
then A16:  WHL is_halting_on Es by A2,A3,A10,A11,Th24;
     set s4 = C1.1;
A17:     iI c= sI by FUNCT_4:26;
A18:     sI is halting by A8,SCMPDS_6:def 3;
        then sI +* iI is halting by A17,FUNCT_4:79;
then A19:     I is_halting_on sI by SCMPDS_6:def 3;
A20:     I is_closed_on sI by A8,SCMPDS_6:38;
A21:     IC s1 =inspos 0 by SCMPDS_6:21;
A22:     WHL = i1 ';' (I ';' i2) by Lm5;
then A23:     CurInstr s1 = i1 by SCMPDS_6:22;
A24:     (Computation s1).(0 + 1) = Following (Computation s1).0 by
AMI_1:def 19
        .= Following s1 by AMI_1:def 19
        .= Exec(i1,s1) by A23,AMI_1:def 18;
A25:     not a in dom iWHL & a in dom s by SCMPDS_2:49,SCMPDS_4:31;
A26:    not b in dom iWHL & b in dom s by SCMPDS_2:49,SCMPDS_4:31;
        A27: s1.DataLoc(s1.a,i)=s1.b by A25,FUNCT_4:12
        .= s.b by A26,FUNCT_4:12;
A28:    IC s4 = s4.IC SCMPDS by AMI_1:def 15
        .= Next IC s1 by A1,A24,A27,SCMPDS_2:68
        .= inspos(0+1) by A21,SCMPDS_4:70;
             sI,s1 equal_outside A by SCMPDS_4:36;
then A29:    sI | D = s1 | D by SCMPDS_4:24;
             now let a;
          thus sI.a = s1.a by A29,SCMPDS_4:23
          .= s4.a by A24,SCMPDS_2:68;
        end;
then A30:    sI | D = s4 | D by SCMPDS_4:23;

        set mI=LifeSpan sI,
            s5=(Computation s4).mI,
            l1=inspos (card I + 1);

A31:     IExec(I,s) = Result sI +* s | A by SCMPDS_4:def 8;
A32:     dom (s | A) = A by SCMPDS_6:1;
             card I + 1 < card I + 2 by XREAL_1:8;
then A33:    l1 in dom WHL by Th18;
A34:    WHL c= iWHL by SCMPDS_6:17;
             iWHL c= s1 by FUNCT_4:26;
then A35:    WHL c= s1 by A34,XBOOLE_1:1;
            Shift(I,1) c= WHL by Lm6;
        then Shift(I,1) c= s1 by A35,XBOOLE_1:1;
then A36:     Shift(I,1) c= s4 by AMI_3:38;
then A37:     (Computation sI).mI | D = s5 | D
        by A2,A17,A19,A20,A28,A30,SCMPDS_7:36;
        set m3=mI +1;
        set s6=(Computation s1).m3;
A38:     IC s5=l1 by A2,A17,A19,A20,A28,A30,A36,SCMPDS_7:36;
A39:     s6=s5 by AMI_1:51;
then A40:     CurInstr s6=s5.l1 by A38,AMI_1:def 17
        .=s4.l1 by AMI_1:54
        .=s1.l1 by AMI_1:54
        .=WHL.l1 by A33,A35,GRFUNC_1:8
        .=i2 by Th19;
        set s7=(Computation s1).(m3+ 1);
A41:     s7 = Following s6 by AMI_1:def 19
        .= Exec(i2,s6) by A40,AMI_1:def 18;
A42:    IC s7=s7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(s6,0-(card I+1)) by A41,SCMPDS_2:66
       .=inspos 0 by A38,A39,SCMPDS_7:1;
          now
       let x be Int_position;
A43:    not x in dom iWHL & x in dom IExec(I,s) by SCMPDS_2:49,SCMPDS_4:31;
A44: now assume x in dom (s | A);
      then reconsider l=x as Instruction-Location of SCMPDS
             by A32,AMI_1:def 4;
      l=x;
     hence contradiction by A11,A32,SCMPDS_2:53;
    end;
        s5.x=(Computation sI).mI.x by A37,SCMPDS_4:23
        .=(Result sI).x by A18,SCMFSA6B:16
       .=IExec(I,s).x by A31,A44,FUNCT_4:12;
       hence s7.x=IExec(I,s).x by A39,A41,SCMPDS_2:66
            .=s2.x by A43,FUNCT_4:12;
     end;
     then A45: s7 | D = s2 | D by SCMPDS_4:23;
A46:  IC s2 =IC C1.m1 by A42,SCMPDS_6:21;

A47: s2 is halting by A16,SCMPDS_6:def 3;
A48: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
         s2 | A= (Result sI +* ps +* iWHL) | A by SCMPDS_4:def 8
    .=(Result sI +* ps)|A +* iWHL | A by FUNCT_4:75
    .= ps +* iWHL | A by A48,FUNCT_4:24
    .= s1 | A by FUNCT_4:75
    .= C1.m1 | A by SCMPDS_7:6;
then A49: C1.m1=s2 by A45,A46,SCMPDS_7:7;
    then CurInstr C1.m1=i1 by A22,SCMPDS_6:22;
then A50: CurInstr C1.m1 <> halt SCMPDS by SCMPDS_6:30;
    set m0=LifeSpan s1;
         m0 > m1 by A6,A50,SCMPDS_6:2;
    then consider nn be Nat such that
A51: m0=m1+nn by NAT_1:10;
     reconsider nn as Element of NAT by ORDINAL1:def 13;
A52: C1.m0 = C2.nn by A49,A51,AMI_1:51;
    then CurInstr C2.nn =halt SCMPDS by A6,SCM_1:def 2;
then A53: nn >= m2 by A47,SCM_1:def 2;
         C1.(m1 + m2) = C2.m2 by A49,AMI_1:51;
    then CurInstr C1.(m1 + m2) = halt SCMPDS by A47,SCM_1:def 2;
    then m1 + m2 >= m0 by A6,SCM_1:def 2;
    then m2 >= nn by A51,XREAL_1:8;
then nn=m2 by A53,XXREAL_0:1;
then A54: Result s1 = C2.m2 by A6,A52,SCMFSA6B:16;
A55: IExec(I,s) | A= (Result sI +* ps) | A by SCMPDS_4:def 8
    .= ps by A48,FUNCT_4:24;
    thus IExec(WHL,s)
     = C2.m2 +* ps by A54,SCMPDS_4:def 8
    .= Result s2 +* IExec(I,s) | A by A47,A55,SCMFSA6B:16
    .= IExec(WHL,IExec(I,s)) by SCMPDS_4:def 8;
end;

theorem
      for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i be Integer,X be set, f being Function of
 product the Object-Kind of SCMPDS,NAT st card I > 0 &
 (for t be State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i) <= 0 ) &
 (for t be State of SCMPDS st
    (for x st x in X holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0
   holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    f.Dstate(IExec(I,t)) < f.Dstate(t) &
    for x st x in X holds IExec(I,t).x=t.x)
 holds
    while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s &
    (s.DataLoc(s.a,i) > 0 implies
    IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)))
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
    a be Int_position, i be Integer,X be set,f be Function of product
    the Object-Kind of SCMPDS,NAT;
  set b=DataLoc(s.a,i);
   assume A1: card I > 0;
   assume A2: for t be State of SCMPDS st f.Dstate(t)=0 holds t.b <= 0;
   assume A3: for t be State of SCMPDS st
       (for x st x in X holds t.x=s.x) & t.a=s.a & t.b > 0
       holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
       f.Dstate(IExec(I,t)) < f.Dstate(t) &
       for x st x in X holds IExec(I,t).x=t.x;
A4: for x st x in {} holds s.x >= 0+s.b;
         for t being State of SCMPDS st (for x st x in {} holds t.x >= 0+t.b) &
       (for x st x in X holds t.x=s.x) & t.a=s.a & t.b > 0
       holds (IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
          f.Dstate(IExec(I,t)) < f.Dstate(t)) &
       (for x st x in {} holds IExec(I,t).x >= 0+IExec(I,t).b) &
       for x st x in X holds IExec(I,t).x=t.x by A3;
    hence while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s
      by A1,A2,A4,Th24;
    assume A5: s.b > 0;
         for t being State of SCMPDS st (for x st x in {} holds t.x >= 0+t.b) &
       (for x st x in X holds t.x=s.x) & t.a=s.a & t.b > 0 holds
       (IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
          f.Dstate(IExec(I,t)) < f.Dstate(t)) &
       (for x st x in {} holds IExec(I,t).x >= 0+IExec(I,t).b) &
       for x st x in X holds IExec(I,t).x=t.x by A3;
    hence thesis by A1,A2,A4,A5,Th25;
end;

theorem Th27:
 for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i,c be Integer,X,Y be set st
 card I > 0 & (for x st x in X holds s.x >= c+s.DataLoc(s.a,i)) &
 (for t be State of SCMPDS st
   (for x st x in X holds t.x >= c+t.DataLoc(s.a,i)) &
   (for x st x in Y holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0
 holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
   IExec(I,t).DataLoc(s.a,i) < t.DataLoc(s.a,i) &
   (for x st x in X holds IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i)) &
   for x st x in Y holds IExec(I,t).x=t.x)
holds
   while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s &
   ( s.DataLoc(s.a,i) > 0 implies
      IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)))
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
  a be Int_position, i,c be Integer,X,Y be set;
   set b=DataLoc(s.a,i);

   assume A1: card I > 0;
   assume A2: for x st x in X holds s.x >= c+s.b;
   assume A3: for t be State of SCMPDS st
     (for x st x in X holds t.x >= c+t.b) &
     (for x st x in Y holds t.x=s.x) & t.a=s.a & t.b > 0
 holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
     IExec(I,t).b < t.b &
     (for x st x in X holds IExec(I,t).x >= c+IExec(I,t).b) &
     for x st x in Y holds IExec(I,t).x=t.x;

     defpred P[State of SCMPDS] means (for x st x in X holds $1.x >= c+$1.b) &
    (for x st x in Y holds $1.x=s.x);

    consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A4:  for s holds (s.b <= 0 implies f.s =0) & (s.b > 0 implies f.s=s.b)
     by Th5;
     deffunc F(State of SCMPDS) = f.$1;
A5:  for t be State of SCMPDS holds F(Dstate t)=0 iff t.b <= 0
     proof
       let t be State of SCMPDS;
       thus F(Dstate t)=0 implies t.b <= 0
       proof
         assume A6: F(Dstate t)=0;
         assume t.b > 0;
        then (Dstate t).b > 0 by Th4;
         hence contradiction by A4,A6;
       end;
       assume t.b <= 0;
        then (Dstate t).b <= 0 by Th4;
        hence thesis by A4;
     end;
then A7: for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.b <= 0
;
A8: P[Dstate s]
    proof
       set t=Dstate s;
       hereby
            let x;
            assume x in X;
            then s.x >= c+s.b by A2;
            then t.x >= c+s.b by Th4;
          hence t.x >= c+t.b by Th4;
       end;
       thus thesis by Th4;
    end;
A9:  now
         let t be State of SCMPDS;
         assume A10:P[Dstate t] & t.a=s.a & t.b > 0;
         then consider v be State of SCMPDS such that
     A11: v=Dstate t & (for x st x in X holds v.x >= c+v.b) &
         (for x st x in Y holds v.x=s.x);
     A12: now
           let x;
           assume x in X;
           then v.x >= c+v.b by A11;
           then t.x >= c+v.b by A11,Th4;
           hence t.x >= c+t.b by A11,Th4;
         end;
     A13: now
           let x;
           assume x in Y;
           then v.x =s.x by A11;
           hence t.x=s.x by A11,Th4;
         end;
        hence IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t
        by A3,A10,A12;
        set It=IExec(I,t),
            t2=Dstate It,
            t1=Dstate t;
        thus F(t2) < F(t1)
        proof
          assume A14: F(t2) >= F(t1);
               t1.b > 0 by A10,Th4;
      then A15: F(t1)=t1.b by A4
           .=t.b by Th4;
           then It.b > 0 by A5,A10,A14;
           then t2.b > 0 by Th4;
           then F(t2)=t2.b by A4
           .=It.b by Th4;
           hence contradiction by A3,A10,A12,A13,A14,A15;
       end;
        thus P[Dstate It]
        proof
            set v=Dstate It;
            hereby
               let x;
               assume x in X;
               then It.x >= c+It.b by A3,A10,A12,A13;
               then v.x >= c+It.b by Th4;
               hence v.x >= c+v.b by Th4;
           end;
           hereby
              let x;
              assume A16:x in Y;
              then It.x=t.x by A3,A10,A12,A13;
              then v.x=t.x by Th4;
              hence v.x=s.x by A13,A16;
           end;
        end;
    end;
         (F(s)=F(s) or P[s]) &
    while>0(a,i,I) is_closed_on s &
    while>0(a,i,I) is_halting_on s from WhileGHalt(A1,A7,A8,A9);
     hence while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s;
     assume
A17:  s.b > 0;
          (F(s)=F(s) or P[s]) &
     IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s))
     from WhileGExec(A1,A17,A7,A8,A9);
     hence thesis;
end;

theorem
      for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i be Integer,X be set st card I > 0 &
 (for t be State of SCMPDS st
    (for x st x in X holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0
   holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    IExec(I,t).DataLoc(s.a,i) < t.DataLoc(s.a,i) &
    for x st x in X holds IExec(I,t).x=t.x)
 holds
    while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s &
    (s.DataLoc(s.a,i) > 0 implies
     IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)))
proof
   let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
   a be Int_position, i be Integer,X be set;
   set b=DataLoc(s.a,i);

   assume A1: card I > 0;
   assume A2: for t be State of SCMPDS st
       (for x st x in X holds t.x=s.x) & t.a=s.a & t.b > 0
    holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    IExec(I,t).b < t.b & for x st x in X holds IExec(I,t).x=t.x;
A3: for x st x in {} holds s.x >= 0+s.b;
         for t being State of SCMPDS st
       (for x st x in {} holds t.x >= 0+t.b) &
       (for x st x in X holds t.x=s.x) & t.a=s.a & t.b > 0
       holds (IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
          IExec(I,t).b < t.b) &
       (for x st x in {} holds IExec(I,t).x >= 0+IExec(I,t).b) &
       for x st x in X holds IExec(I,t).x=t.x by A2;
    hence while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s
       by A1,A3,Th27;
    assume A4: s.b > 0;
         for t being State of SCMPDS st
     (for x st x in {} holds t.x >= 0+t.b) &
      (for x st x in X holds t.x=s.x) & t.a=s.a & t.b > 0
     holds (IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
          IExec(I,t).b < t.b) &
     (for x st x in {} holds IExec(I,t).x >= 0+IExec(I,t).b) &
     for x st x in X holds IExec(I,t).x=t.x by A2;
    hence thesis by A1,A3,A4,Th27;
end;

theorem
      for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i,c be Integer,X be set st card I > 0 &
  (for x st x in X holds s.x >= c+s.DataLoc(s.a,i)) &
  (for t be State of SCMPDS st
    (for x st x in X holds t.x >= c+t.DataLoc(s.a,i)) &
    t.a=s.a & t.DataLoc(s.a,i) > 0
  holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    IExec(I,t).DataLoc(s.a,i) < t.DataLoc(s.a,i) &
    for x st x in X holds IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i))
 holds
   while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s &
   (s.DataLoc(s.a,i) > 0 implies
     IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)))
proof
   let s be State of SCMPDS,I be No-StopCode shiftable Program-block,
   a be Int_position, i,c be Integer,X be set;
   set b=DataLoc(s.a,i);
   assume A1: card I > 0;
   assume A2: for x st x in X holds s.x >= c+s.b;
   assume A3: for t be State of SCMPDS st
       (for x st x in X holds t.x >= c+t.b) & t.a=s.a & t.b > 0
    holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    IExec(I,t).b < t.b & for x st x in X holds IExec(I,t).x >= c+IExec(I,t).b;
    then for t being State of SCMPDS st
       (for x st x in X holds t.x >= c+t.b) &
       (for x st x in {} holds t.x=s.x) & t.a=s.a & t.b > 0
       holds (IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
          IExec(I,t).b < t.b &
          for x st x in X holds IExec(I,t).x >= c+IExec(I,t).b) &
        for x st x in {} holds IExec(I,t).x=t.x;
    hence while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s
       by A1,A2,Th27;
   assume A4: s.b > 0;
        for t being State of SCMPDS st
       (for x st x in X holds t.x >= c+t.b) &
       (for x st x in {} holds t.x=s.x) & t.a=s.a & t.b > 0
       holds (IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
          IExec(I,t).b < t.b &
          for x st x in X holds IExec(I,t).x >= c+IExec(I,t).b) &
       for x st x in {} holds IExec(I,t).x=t.x by A3;
    hence thesis by A1,A2,A4,Th27;
end;

