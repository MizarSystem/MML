:: Properties of Number-Valued Functions
::  by Library Committee
::
:: Received December 18, 2007
:: Copyright (c) 2007 Association of Mizar Users

environ

 vocabularies NUMBERS, FINSEQ_1, FUNCT_1, RELAT_1, XBOOLE_0, ORDINAL1,
      XXREAL_0, VALUED_0, RAT_1, COMPLEX1, ARYTM_1, ARYTM_3, MEMBERED,
      PARTFUN1, TARSKI, SUBSET_1, CARD_1, XCMPLX_0, XREAL_0, INT_1, SQUARE_1,
      FUNCT_4, FINSET_1, NAT_1, ORDINAL2, VALUED_1, AMISTD_1, FUNCOP_1,
      AMISTD_2, CAT_1, AMISTD_3, ZFMISC_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, FINSET_1, CARD_1,
      XCMPLX_0, NUMBERS,
      ZFMISC_1, COMPLEX1, XXREAL_0, XXREAL_2, FUNCOP_1,
      XREAL_0, RAT_1, INT_1, INT_2, SQUARE_1, RELAT_1,
      FUNCT_1, RELSET_1, PARTFUN1, FUNCT_2, FUNCT_4, FINSEQ_1, MEMBERED, NAT_1,
      VALUED_0;
 constructors PARTFUN1, RAT_1, VALUED_0, SQUARE_1, MEMBERED, INT_2, FINSEQ_1,
      NAT_1, FUNCT_4, NAT_D, RELSET_1, XXREAL_2, FUNCOP_1, DOMAIN_1, WELLORD2;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, FUNCT_2, NUMBERS, XREAL_0,
      MEMBERED, VALUED_0, RAT_1, INT_1, NAT_1, FUNCT_1, FINSET_1, XXREAL_0,
      RELAT_1, XXREAL_2, FUNCOP_1, REALSET1;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM, REAL;
 definitions TARSKI, XBOOLE_0, RELAT_1, XCMPLX_0, SQUARE_1, FUNCT_1, FUNCT_2,
      FINSEQ_1, VALUED_0, WELLORD2, FUNCOP_1;
 theorems FUNCT_1, FUNCT_2, RELSET_1, PARTFUN1, VALUED_0, COMPLEX1, FINSEQ_1,
      XBOOLE_0, TARSKI, GRFUNC_1, RELAT_1, FUNCT_4, FINSET_1, NAT_1, INT_1,
      ORDINAL1, XXREAL_0, FUNCOP_1, ZFMISC_1, XXREAL_2, XBOOLE_1, CARD_1,
      CARD_2, DOMAIN_1, WELLORD2;
 schemes FUNCT_1, CLASSES1, FRAENKEL, RECDEF_1, NAT_1, DOMAIN_1;

begin :: f1 + f2

Lm1: for f being FinSequence, h being Function st dom h = dom f holds h is
FinSequence
proof
  let f be FinSequence, h be Function such that
A1: dom h = dom f;
  h is FinSequence-like
  proof
    take len f;
    thus thesis by A1,FINSEQ_1:def 3;
  end;
  hence thesis;
end;

Lm2: for f, g being FinSequence, h being Function st dom h = dom f /\ dom g
holds h is FinSequence
proof
  let f, g be FinSequence, h be Function such that
A1: dom h = dom f /\ dom g;
  consider n being natural number such that
A2: dom f = Seg n by FINSEQ_1:def 2;
  consider m being natural number such that
A3: dom g = Seg m by FINSEQ_1:def 2;
  h is FinSequence-like
  proof
    per cases;
    suppose
A4:   n <= m;
      take n;
      thus thesis by A1,A2,A3,A4,FINSEQ_1:9;
    end;
    suppose
A5:   m <= n;
      take m;
      thus thesis by A1,A2,A3,A5,FINSEQ_1:9;
    end;
  end;
  hence thesis;
end;

registration
  cluster complex-valued FinSequence;
  existence
  proof
    take <*>COMPLEX;
    thus thesis;
  end;
end;
:: move somewhere

registration
  let r be rational number;
  cluster |. r .| -> rational;
  coherence
  proof
    |. r .| = -r or |. r .| = r by COMPLEX1:157;
    hence thesis;
  end;
end;

definition
  let f1,f2 be complex-valued Function;
  deffunc F(set) = f1.$1 + f2.$1;
  set X = dom f1 /\ dom f2;
  func f1 + f2 -> Function means
  :Def1:
  dom it = dom f1 /\ dom f2 &
  for c being set st c in dom it holds it.c = f1.c + f2.c;
  existence
  proof
    ex f being Function st dom f = X & for x being set st x in X holds f.x
    = F(x) from FUNCT_1:sch 3;
    hence thesis;
  end;
  uniqueness
  proof
    let f, g be Function such that
A1: dom f = X and
A2: for c being set st c in dom f holds f.c = F(c) and
A3: dom g = X and
A4: for c being set st c in dom g holds g.c = F(c);
    now
      let x be set;
      assume
A5:   x in dom f;
      hence f.x = F(x) by A2
        .= g.x by A1,A3,A4,A5;
    end;
    hence thesis by A1,A3,FUNCT_1:9;
  end;
  commutativity;
end;

registration
  let f1,f2 be complex-valued Function;
  cluster f1+f2 -> complex-valued;
  coherence
  proof
    let x be set;
    assume x in dom (f1+f2);
    then (f1+f2).x = f1.x + f2.x by Def1;
    hence thesis;
  end;
end;

registration
  let f1,f2 be real-valued Function;
  cluster f1+f2 -> real-valued;
  coherence
  proof
    let x be set;
    assume x in dom (f1+f2);
    then (f1+f2).x = f1.x + f2.x by Def1;
    hence thesis;
  end;
end;

registration
  let f1,f2 be rational-valued Function;
  cluster f1+f2 -> rational-valued;
  coherence
  proof
    let x be set;
    assume x in dom (f1+f2);
    then (f1+f2).x = f1.x + f2.x by Def1;
    hence thesis;
  end;
end;

registration
  let f1,f2 be integer-valued Function;
  cluster f1+f2 -> integer-valued;
  coherence
  proof
    let x be set;
    assume x in dom (f1+f2);
    then (f1+f2).x = f1.x + f2.x by Def1;
    hence thesis;
  end;
end;

registration
  let f1,f2 be natural-valued Function;
  cluster f1+f2 -> natural-valued;
  coherence
  proof
    let x be set;
    assume x in dom (f1+f2);
    then (f1+f2).x = f1.x + f2.x by Def1;
    hence thesis;
  end;
end;

definition
  let C be set;
  let D1,D2 be complex-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1+f2 -> PartFunc of C,COMPLEX;
  coherence
  proof
    dom (f1+f2) = dom f1 /\ dom f2 & rng (f1+f2) c= COMPLEX by Def1,
    VALUED_0:def 1;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D1,D2 be real-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1+f2 -> PartFunc of C,REAL;
  coherence
  proof
    dom (f1+f2) = dom f1 /\ dom f2 & rng (f1+f2) c= REAL by Def1,VALUED_0:
    def 3;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D1,D2 be rational-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1+f2 -> PartFunc of C,RAT;
  coherence
  proof
    dom (f1+f2) = dom f1 /\ dom f2 & rng (f1+f2) c= RAT by Def1,VALUED_0:
    def 4;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D1,D2 be integer-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1+f2 -> PartFunc of C,INT;
  coherence
  proof
    dom (f1+f2) = dom f1 /\ dom f2 & rng (f1+f2) c= INT by Def1,VALUED_0:
    def 5;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D1,D2 be natural-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1+f2 -> PartFunc of C,NAT;
  coherence
  proof
    dom (f1+f2) = dom f1 /\ dom f2 & rng (f1+f2) c= NAT by Def1,VALUED_0:
    def 6;
    hence thesis by RELSET_1:11;
  end;
end;

registration
  let C be set;
  let D1,D2 be complex-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1+f2 -> total PartFunc of C,COMPLEX;
  coherence
  proof
    dom f1 = C & dom f2 = C by FUNCT_2:def 1;
    then dom(f1+f2) = C /\ C by Def1
      .= C;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D1,D2 be real-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1+f2 -> total PartFunc of C,REAL;
  coherence
  proof
    dom f1 = C & dom f2 = C by FUNCT_2:def 1;
    then dom(f1+f2) = C /\ C by Def1
      .= C;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D1,D2 be rational-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1+f2 -> total PartFunc of C,RAT;
  coherence
  proof
    dom f1 = C & dom f2 = C by FUNCT_2:def 1;
    then dom(f1+f2) = C /\ C by Def1
      .= C;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D1,D2 be integer-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1+f2 -> total PartFunc of C,INT;
  coherence
  proof
    dom f1 = C & dom f2 = C by FUNCT_2:def 1;
    then dom(f1+f2) = C /\ C by Def1
      .= C;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D1,D2 be natural-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1+f2 -> total PartFunc of C,NAT;
  coherence
  proof
    dom f1 = C & dom f2 = C by FUNCT_2:def 1;
    then dom(f1+f2) = C /\ C by Def1
      .= C;
    hence thesis by PARTFUN1:def 4;
  end;
end;

theorem
  for C being set, D1,D2 being complex-membered non empty set for f1
  being Function of C,D1, f2 being Function of C,D2 for c being Element of C
  holds (f1+f2).c = f1.c + f2.c
proof
  let C be set;
  let D1,D2 be complex-membered non empty set;
  let f1 be Function of C,D1, f2 be Function of C,D2;
A1: dom(f1+f2) = C by FUNCT_2:def 1;
  let c be Element of C;
  per cases;
  suppose
    C is non empty;
    hence thesis by A1,Def1;
  end;
  suppose
A2: C is empty;
    then dom f1 = {};
    then f1.c = 0 by FUNCT_1:def 4;
    hence thesis by A2;
  end;
end;

registration
  let f1, f2 be complex-valued FinSequence;
  cluster f1+f2 -> FinSequence-like;
  coherence
  proof
    dom(f1+f2) = dom f1 /\ dom f2 by Def1;
    hence thesis by Lm2;
  end;
end;

begin :: r + f

definition
  let f be complex-valued Function, r be complex number;
  deffunc F(set) = r + f.$1;
  func r + f -> Function means
  :Def2:
  dom it = dom f &
  for c being set st c in dom it holds it.c = r + f.c;
  existence
  proof
    ex g being Function st dom g = dom f & for x being set st x in dom f
    holds g.x = F(x) from FUNCT_1:sch 3;
    hence thesis;
  end;
  uniqueness
  proof
    let h, g be Function such that
A1: dom h = dom f and
A2: for c being set st c in dom h holds h.c = F(c) and
A3: dom g = dom f and
A4: for c being set st c in dom g holds g.c = F(c);
    now
      let x be set;
      assume
A5:   x in dom h;
      hence h.x = F(x) by A2
        .= g.x by A1,A3,A4,A5;
    end;
    hence thesis by A1,A3,FUNCT_1:9;
  end;
end;

notation
  let f be complex-valued Function, r be complex number;
  synonym f + r for r + f;
end;

registration
  let f be complex-valued Function, r be complex number;
  cluster r+f -> complex-valued;
  coherence
  proof
    let x be set;
    assume x in dom (r+f);
    then (r+f).x = r + f.x by Def2;
    hence thesis;
  end;
end;

registration
  let f be real-valued Function, r be real number;
  cluster r+f -> real-valued;
  coherence
  proof
    let x be set;
    assume x in dom (r+f);
    then (r+f).x = r + f.x by Def2;
    hence thesis;
  end;
end;

registration
  let f be rational-valued Function, r be rational number;
  cluster r+f -> rational-valued;
  coherence
  proof
    let x be set;
    assume x in dom (r+f);
    then (r+f).x = r + f.x by Def2;
    hence thesis;
  end;
end;

registration
  let f be integer-valued Function, r be integer number;
  cluster r+f -> integer-valued;
  coherence
  proof
    let x be set;
    assume x in dom (r+f);
    then (r+f).x = r + f.x by Def2;
    hence thesis;
  end;
end;

registration
  let f be natural-valued Function, r be natural number;
  cluster r+f -> natural-valued;
  coherence
  proof
    let x be set;
    assume x in dom (r+f);
    then (r+f).x = r + f.x by Def2;
    hence thesis;
  end;
end;

definition
  let C be set;
  let D be complex-membered set;
  let f be PartFunc of C,D;
  let r be complex number;
  redefine func r+f -> PartFunc of C,COMPLEX;
  coherence
  proof
    dom (r+f) = dom f & rng (r+f) c= COMPLEX by Def2,VALUED_0:def 1;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be real-membered set;
  let f be PartFunc of C,D;
  let r be real number;
  redefine func r+f -> PartFunc of C,REAL;
  coherence
  proof
    dom (r+f) = dom f & rng (r+f) c= REAL by Def2,VALUED_0:def 3;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be rational-membered set;
  let f be PartFunc of C,D;
  let r be rational number;
  redefine func r+f -> PartFunc of C,RAT;
  coherence
  proof
    dom (r+f) = dom f & rng (r+f) c= RAT by Def2,VALUED_0:def 4;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be integer-membered set;
  let f be PartFunc of C,D;
  let r be integer number;
  redefine func r+f -> PartFunc of C,INT;
  coherence
  proof
    dom (r+f) = dom f & rng (r+f) c= INT by Def2,VALUED_0:def 5;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be natural-membered set;
  let f be PartFunc of C,D;
  let r be natural number;
  redefine func r+f -> PartFunc of C,NAT;
  coherence
  proof
    dom (r+f) = dom f & rng (r+f) c= NAT by Def2,VALUED_0:def 6;
    hence thesis by RELSET_1:11;
  end;
end;

registration
  let C be set;
  let D be complex-membered non empty set;
  let f be Function of C,D;
  let r be complex number;
  cluster r+f -> total PartFunc of C,COMPLEX;
  coherence
  proof
    dom(r+f) = dom f by Def2
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D be real-membered non empty set;
  let f be Function of C,D;
  let r be real number;
  cluster r+f -> total PartFunc of C,REAL;
  coherence
  proof
    dom(r+f) = dom f by Def2
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D be rational-membered non empty set;
  let f be Function of C,D;
  let r be rational number;
  cluster r+f -> total PartFunc of C,RAT;
  coherence
  proof
    dom(r+f) = dom f by Def2
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D be integer-membered non empty set;
  let f be Function of C,D;
  let r be integer number;
  cluster r+f -> total PartFunc of C,INT;
  coherence
  proof
    dom(r+f) = dom f by Def2
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D be natural-membered non empty set;
  let f be Function of C,D;
  let r be natural number;
  cluster r+f -> total PartFunc of C,NAT;
  coherence
  proof
    dom(r+f) = dom f by Def2
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

theorem
  for C being non empty set, D being complex-membered non empty set
  for f being Function of C,D, r being complex number
  for c being Element of C holds
  (r+f).c = r + f.c
proof
  let C be non empty set;
  let D be complex-membered non empty set;
  let f be Function of C,D, r be complex number;
  dom(r+f) = C by FUNCT_2:def 1;
  hence thesis by Def2;
end;

registration
  let f be complex-valued FinSequence, r be complex number;
  cluster r+f -> FinSequence-like;
  coherence
  proof
    dom (r+f) = dom f by Def2;
    hence thesis by Lm1;
  end;
end;

begin :: f - r

definition
  let f be complex-valued Function, r be complex number;
  func f - r -> Function equals
  -r + f;
  coherence;
end;

theorem
  for f being complex-valued Function, r being complex number holds dom
  (f-r) = dom f & for c being set st c in dom f holds (f-r).c = f.c - r
proof
  let f be complex-valued Function, r be complex number;
  dom (f-r) = dom f by Def2;
  hence thesis by Def2;
end;

registration
  let f be complex-valued Function, r be complex number;
  cluster f-r -> complex-valued;
  coherence;
end;

registration
  let f be real-valued Function, r be real number;
  cluster f-r -> real-valued;
  coherence;
end;

registration
  let f be rational-valued Function, r be rational number;
  cluster f-r -> rational-valued;
  coherence;
end;

registration
  let f be integer-valued Function, r be integer number;
  cluster f-r -> integer-valued;
  coherence;
end;

definition
  let C be set;
  let D be complex-membered set;
  let f be PartFunc of C,D;
  let r be complex number;
  redefine func f-r -> PartFunc of C,COMPLEX;
  coherence
  proof
    dom (f-r) = dom f & rng (f-r) c= COMPLEX by Def2,VALUED_0:def 1;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be real-membered set;
  let f be PartFunc of C,D;
  let r be real number;
  redefine func f-r -> PartFunc of C,REAL;
  coherence
  proof
    dom (f-r) = dom f & rng (f-r) c= REAL by Def2,VALUED_0:def 3;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be rational-membered set;
  let f be PartFunc of C,D;
  let r be rational number;
  redefine func f-r -> PartFunc of C,RAT;
  coherence
  proof
    dom (f-r) = dom f & rng (f-r) c= RAT by Def2,VALUED_0:def 4;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be integer-membered set;
  let f be PartFunc of C,D;
  let r be integer number;
  redefine func f-r -> PartFunc of C,INT;
  coherence
  proof
    dom (f-r) = dom f & rng (f-r) c= INT by Def2,VALUED_0:def 5;
    hence thesis by RELSET_1:11;
  end;
end;

registration
  let C be set;
  let D be complex-membered non empty set;
  let f be Function of C,D;
  let r be complex number;
  cluster f-r -> total PartFunc of C,COMPLEX;
  coherence;
end;

registration
  let C be set;
  let D be real-membered non empty set;
  let f be Function of C,D;
  let r be real number;
  cluster f-r -> total PartFunc of C,REAL;
  coherence;
end;

registration
  let C be set;
  let D be rational-membered non empty set;
  let f be Function of C,D;
  let r be rational number;
  cluster f-r -> total PartFunc of C,RAT;
  coherence;
end;

registration
  let C be set;
  let D be integer-membered non empty set;
  let f be Function of C,D;
  let r be integer number;
  cluster f-r -> total PartFunc of C,INT;
  coherence;
end;

theorem
  for C being non empty set, D being complex-membered non empty set for
f being Function of C,D, r being complex number for c being Element of C holds
  (f-r).c = f.c - r
proof
  let C be non empty set;
  let D be complex-membered non empty set;
  let f be Function of C,D, r be complex number;
  dom (f-r) = C by FUNCT_2:def 1;
  hence thesis by Def2;
end;

registration
  let f be complex-valued FinSequence, r be complex number;
  cluster f-r -> FinSequence-like;
  coherence;
end;

begin :: f1 (#) f2

definition
  let f1,f2 be complex-valued Function;
  deffunc F(set) = f1.$1 * f2.$1;
  set X = dom f1 /\ dom f2;
  func f1 (#) f2 -> Function means
  :Def4:
  dom it = dom f1 /\ dom f2 & for c
  being set st c in dom it holds it.c = f1.c * f2.c;
  existence
  proof
    ex f being Function st dom f = X & for x being set st x in X holds f.x
    = F(x) from FUNCT_1:sch 3;
    hence thesis;
  end;
  uniqueness
  proof
    let f, g be Function such that
A1: dom f = X and
A2: for c being set st c in dom f holds f.c = F(c) and
A3: dom g = X and
A4: for c being set st c in dom g holds g.c = F(c);
    now
      let x be set;
      assume
A5:   x in dom f;
      hence f.x = F(x) by A2
        .= g.x by A1,A3,A4,A5;
    end;
    hence thesis by A1,A3,FUNCT_1:9;
  end;
  commutativity;
end;

theorem
  for f1,f2 being complex-valued Function for c being set holds (f1(#)f2
  ).c = f1.c * f2.c
proof
  let f1,f2 be complex-valued Function;
  let c be set;
A1: dom (f1(#)f2) = dom f1 /\ dom f2 by Def4;
  per cases;
  suppose
    c in dom (f1(#)f2);
    hence thesis by Def4;
  end;
  suppose
A2: not c in dom (f1(#)f2);
    then not c in dom f1 or not c in dom f2 by A1,XBOOLE_0:def 4;
    then f1.c = 0 or f2.c = 0 by FUNCT_1:def 4;
    hence thesis by A2,FUNCT_1:def 4;
  end;
end;

registration
  let f1,f2 be complex-valued Function;
  cluster f1(#)f2 -> complex-valued;
  coherence
  proof
    let x be set;
    assume x in dom (f1(#)f2);
    then (f1(#)f2).x = f1.x * f2.x by Def4;
    hence thesis;
  end;
end;

registration
  let f1,f2 be real-valued Function;
  cluster f1(#)f2 -> real-valued;
  coherence
  proof
    let x be set;
    assume x in dom (f1(#)f2);
    then (f1(#)f2).x = f1.x * f2.x by Def4;
    hence thesis;
  end;
end;

registration
  let f1,f2 be rational-valued Function;
  cluster f1(#)f2 -> rational-valued;
  coherence
  proof
    let x be set;
    assume x in dom (f1(#)f2);
    then (f1(#)f2).x = f1.x * f2.x by Def4;
    hence thesis;
  end;
end;

registration
  let f1,f2 be integer-valued Function;
  cluster f1(#)f2 -> integer-valued;
  coherence
  proof
    let x be set;
    assume x in dom (f1(#)f2);
    then (f1(#)f2).x = f1.x * f2.x by Def4;
    hence thesis;
  end;
end;

registration
  let f1,f2 be natural-valued Function;
  cluster f1(#)f2 -> natural-valued;
  coherence
  proof
    let x be set;
    assume x in dom (f1(#)f2);
    then (f1(#)f2).x = f1.x * f2.x by Def4;
    hence thesis;
  end;
end;

definition
  let C be set;
  let D1,D2 be complex-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1(#)f2 -> PartFunc of C,COMPLEX;
  coherence
  proof
    dom (f1(#)f2) = dom f1 /\ dom f2 & rng (f1(#)f2) c= COMPLEX by Def4,
    VALUED_0:def 1;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D1,D2 be real-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1(#)f2 -> PartFunc of C,REAL;
  coherence
  proof
    dom (f1(#)f2) = dom f1 /\ dom f2 & rng (f1(#)f2) c= REAL by Def4,
    VALUED_0:def 3;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D1,D2 be rational-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1(#)f2 -> PartFunc of C,RAT;
  coherence
  proof
    dom (f1(#)f2) = dom f1 /\ dom f2 & rng (f1(#)f2) c= RAT by Def4,
    VALUED_0:def 4;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D1,D2 be integer-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1(#)f2 -> PartFunc of C,INT;
  coherence
  proof
    dom (f1(#)f2) = dom f1 /\ dom f2 & rng (f1(#)f2) c= INT by Def4,
    VALUED_0:def 5;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D1,D2 be natural-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1(#)f2 -> PartFunc of C,NAT;
  coherence
  proof
    dom (f1(#)f2) = dom f1 /\ dom f2 & rng (f1(#)f2) c= NAT by Def4,
    VALUED_0:def 6;
    hence thesis by RELSET_1:11;
  end;
end;

registration
  let C be set;
  let D1,D2 be complex-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1(#)f2 -> total PartFunc of C,COMPLEX;
  coherence
  proof
    dom f1 = C & dom f2 = C by FUNCT_2:def 1;
    then dom(f1(#)f2) = C /\ C by Def4
      .= C;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D1,D2 be real-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1(#)f2 -> total PartFunc of C,REAL;
  coherence
  proof
    dom f1 = C & dom f2 = C by FUNCT_2:def 1;
    then dom(f1(#)f2) = C /\ C by Def4
      .= C;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D1,D2 be rational-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1(#)f2 -> total PartFunc of C,RAT;
  coherence
  proof
    dom f1 = C & dom f2 = C by FUNCT_2:def 1;
    then dom(f1(#)f2) = C /\ C by Def4
      .= C;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D1,D2 be integer-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1(#)f2 -> total PartFunc of C,INT;
  coherence
  proof
    dom f1 = C & dom f2 = C by FUNCT_2:def 1;
    then dom(f1(#)f2) = C /\ C by Def4
      .= C;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D1,D2 be natural-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1(#)f2 -> total PartFunc of C,NAT;
  coherence
  proof
    dom f1 = C & dom f2 = C by FUNCT_2:def 1;
    then dom(f1(#)f2) = C /\ C by Def4
      .= C;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let f1, f2 be complex-valued FinSequence;
  cluster f1(#)f2 -> FinSequence-like;
  coherence
  proof
    dom(f1(#)f2) = dom f1 /\ dom f2 by Def4;
    hence thesis by Lm2;
  end;
end;

begin :: r (#) f

definition
  let f be complex-valued Function, r be complex number;
  deffunc F(set) = r * f.$1;
  func r (#) f -> Function means
  :Def5:
  dom it = dom f & for c being set st c
  in dom it holds it.c = r * f.c;
  existence
  proof
    ex g being Function st dom g = dom f & for x being set st x in dom f
    holds g.x = F(x) from FUNCT_1:sch 3;
    hence thesis;
  end;
  uniqueness
  proof
    let h, g be Function such that
A1: dom h = dom f and
A2: for c being set st c in dom h holds h.c = F(c) and
A3: dom g = dom f and
A4: for c being set st c in dom g holds g.c = F(c);
    now
      let x be set;
      assume
A5:   x in dom h;
      hence h.x = F(x) by A2
        .= g.x by A1,A3,A4,A5;
    end;
    hence thesis by A1,A3,FUNCT_1:9;
  end;
end;

notation
  let f be complex-valued Function, r be complex number;
  synonym f (#) r for r (#) f;
end;

theorem Th6:
  for f being complex-valued Function, r being complex number for c
  being set holds (r(#)f).c = r * f.c
proof
  let f be complex-valued Function, r be complex number;
  let c be set;
A1: dom f = dom (r(#)f) by Def5;
  per cases;
  suppose
    c in dom f;
    hence thesis by A1,Def5;
  end;
  suppose
A2: not c in dom f;
    hence (r(#)f).c = r*0 by A1,FUNCT_1:def 4
      .= r * f.c by A2,FUNCT_1:def 4;
  end;
end;

registration
  let f be complex-valued Function, r be complex number;
  cluster r(#)f -> complex-valued;
  coherence
  proof
    let x be set;
    assume x in dom (r(#)f);
    then (r(#)f).x = r * f.x by Def5;
    hence thesis;
  end;
end;

registration
  let f be real-valued Function, r be real number;
  cluster r(#)f -> real-valued;
  coherence
  proof
    let x be set;
    assume x in dom (r(#)f);
    then (r(#)f).x = r * f.x by Def5;
    hence thesis;
  end;
end;

registration
  let f be rational-valued Function, r be rational number;
  cluster r(#)f -> rational-valued;
  coherence
  proof
    let x be set;
    assume x in dom (r(#)f);
    then (r(#)f).x = r * f.x by Def5;
    hence thesis;
  end;
end;

registration
  let f be integer-valued Function, r be integer number;
  cluster r(#)f -> integer-valued;
  coherence
  proof
    let x be set;
    assume x in dom (r(#)f);
    then (r(#)f).x = r * f.x by Def5;
    hence thesis;
  end;
end;

registration
  let f be natural-valued Function, r be natural number;
  cluster r(#)f -> natural-valued;
  coherence
  proof
    let x be set;
    assume x in dom (r(#)f);
    then (r(#)f).x = r * f.x by Def5;
    hence thesis;
  end;
end;

definition
  let C be set;
  let D be complex-membered set;
  let f be PartFunc of C,D;
  let r be complex number;
  redefine func r(#)f -> PartFunc of C,COMPLEX;
  coherence
  proof
    dom (r(#)f) = dom f & rng (r(#)f) c= COMPLEX by Def5,VALUED_0:def 1;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be real-membered set;
  let f be PartFunc of C,D;
  let r be real number;
  redefine func r(#)f -> PartFunc of C,REAL;
  coherence
  proof
    dom (r(#)f) = dom f & rng (r(#)f) c= REAL by Def5,VALUED_0:def 3;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be rational-membered set;
  let f be PartFunc of C,D;
  let r be rational number;
  redefine func r(#)f -> PartFunc of C,RAT;
  coherence
  proof
    dom (r(#)f) = dom f & rng (r(#)f) c= RAT by Def5,VALUED_0:def 4;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be integer-membered set;
  let f be PartFunc of C,D;
  let r be integer number;
  redefine func r(#)f -> PartFunc of C,INT;
  coherence
  proof
    dom (r(#)f) = dom f & rng (r(#)f) c= INT by Def5,VALUED_0:def 5;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be natural-membered set;
  let f be PartFunc of C,D;
  let r be natural number;
  redefine func r(#)f -> PartFunc of C,NAT;
  coherence
  proof
    dom (r(#)f) = dom f & rng (r(#)f) c= NAT by Def5,VALUED_0:def 6;
    hence thesis by RELSET_1:11;
  end;
end;

registration
  let C be set;
  let D be complex-membered non empty set;
  let f be Function of C,D;
  let r be complex number;
  cluster r(#)f -> total PartFunc of C,COMPLEX;
  coherence
  proof
    dom(r(#)f) = dom f by Def5
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D be real-membered non empty set;
  let f be Function of C,D;
  let r be real number;
  cluster r(#)f -> total PartFunc of C,REAL;
  coherence
  proof
    dom(r(#)f) = dom f by Def5
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D be rational-membered non empty set;
  let f be Function of C,D;
  let r be rational number;
  cluster r(#)f -> total PartFunc of C,RAT;
  coherence
  proof
    dom(r(#)f) = dom f by Def5
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D be integer-membered non empty set;
  let f be Function of C,D;
  let r be integer number;
  cluster r(#)f -> total PartFunc of C,INT;
  coherence
  proof
    dom(r(#)f) = dom f by Def5
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D be natural-membered non empty set;
  let f be Function of C,D;
  let r be natural number;
  cluster r(#)f -> total PartFunc of C,NAT;
  coherence
  proof
    dom(r(#)f) = dom f by Def5
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

theorem
  for C being non empty set, D being complex-membered non empty set for
  f being Function of C,D, r being complex number for g being Function of C,
  COMPLEX st for c being Element of C holds g.c = r * f.c holds g = r(#)f
proof
  let C be non empty set, D be complex-membered non empty set;
  let f be Function of C,D, r be complex number;
  let g be Function of C,COMPLEX such that
A1: for c being Element of C holds g.c = r * f.c;
  let x be Element of C;
  thus g.x = r*f.x by A1
    .= (r(#)f).x by Th6;
end;

registration
  let f be complex-valued FinSequence, r be complex number;
  cluster r(#)f -> FinSequence-like;
  coherence
  proof
    dom (r(#)f) = dom f by Def5;
    hence thesis by Lm1;
  end;
end;

begin :: -f

definition
  let f be complex-valued Function;
  func -f -> complex-valued Function equals
  (-1) (#) f;
  coherence;
  involutiveness
  proof
    let r, h be complex-valued Function;
    assume
A1: r = (-1)(#)h;
    thus dom ((-1)(#)r) = dom r by Def5
      .= dom h by A1,Def5;
    let c be set;
    assume c in dom h;
    reconsider a = (-1)*(h.c) as complex number;
    thus h.c = (-1) * a
      .= (-1)*r.c by A1,Th6
      .= ((-1)(#)r).c by Th6;
  end;
end;

theorem Th8:
  for f being complex-valued Function holds dom -f = dom f & for c
  being set holds (-f).c = -(f.c)
proof
  let f be complex-valued Function;
  thus
A1: dom -f = dom f by Def5;
  let c be set;
  per cases;
  suppose
    c in dom f;
    hence (-f).c = (-1)*f.c by A1,Def5
      .= -(f.c);
  end;
  suppose
A2: not c in dom f;
    hence (-f).c = -(0 qua complex number) by A1,FUNCT_1:def 4
      .= -(f.c) by A2,FUNCT_1:def 4;
  end;
end;

theorem
  for f being complex-valued Function, g being Function st dom f = dom g
  & for c being set st c in dom f holds g.c = -(f.c) holds g = -f
proof
  let f be complex-valued Function, g be Function;
  assume that
A1: dom f = dom g and
A2: for c being set st c in dom f holds g.c = -(f.c);
  thus dom -f = dom g by A1,Def5;
  let c be set;
  assume
A3: c in dom g;
  thus (-f).c = -f.c by Th8
    .= g.c by A1,A2,A3;
end;

registration
  let f be complex-valued Function;
  cluster -f -> complex-valued;
  coherence;
end;

registration
  let f be real-valued Function;
  cluster -f -> real-valued;
  coherence;
end;

registration
  let f be rational-valued Function;
  cluster -f -> rational-valued;
  coherence;
end;

registration
  let f be integer-valued Function;
  cluster -f -> integer-valued;
  coherence;
end;

definition
  let C be set;
  let D be complex-membered set;
  let f be PartFunc of C,D;
  redefine func -f -> PartFunc of C,COMPLEX;
  coherence
  proof
    dom -f = dom f & rng -f c= COMPLEX by Def5,VALUED_0:def 1;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be real-membered set;
  let f be PartFunc of C,D;
  redefine func -f -> PartFunc of C,REAL;
  coherence
  proof
    dom -f = dom f & rng -f c= REAL by Def5,VALUED_0:def 3;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be rational-membered set;
  let f be PartFunc of C,D;
  redefine func -f -> PartFunc of C,RAT;
  coherence
  proof
    dom -f = dom f & rng -f c= RAT by Def5,VALUED_0:def 4;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be integer-membered set;
  let f be PartFunc of C,D;
  redefine func -f -> PartFunc of C,INT;
  coherence
  proof
    dom -f = dom f & rng -f c= INT by Def5,VALUED_0:def 5;
    hence thesis by RELSET_1:11;
  end;
end;

registration
  let C be set;
  let D be complex-membered non empty set;
  let f be Function of C,D;
  cluster -f -> total PartFunc of C,COMPLEX;
  coherence;
end;

registration
  let C be set;
  let D be real-membered non empty set;
  let f be Function of C,D;
  cluster -f -> total PartFunc of C,REAL;
  coherence;
end;

registration
  let C be set;
  let D be rational-membered non empty set;
  let f be Function of C,D;
  cluster -f -> total PartFunc of C,RAT;
  coherence;
end;

registration
  let C be set;
  let D be integer-membered non empty set;
  let f be Function of C,D;
  cluster -f -> total PartFunc of C,INT;
  coherence;
end;

registration
  let f be complex-valued FinSequence;
  cluster -f -> FinSequence-like;
  coherence;
end;

begin :: f"

definition
  let f be complex-valued Function;
  deffunc F(set) = (f.$1)";
  func f" -> complex-valued Function means
  :Def7:
  dom it = dom f & for c being
  set st c in dom it holds it.c = (f.c)";
  existence
  proof
    consider g being Function such that
A1: dom g = dom f & for x being set st x in dom f holds g.x = F(x)
    from FUNCT_1:sch 3;
    g is complex-valued
    proof
      let x be set;
      assume x in dom g;
      then g.x = (f.x)" by A1;
      hence thesis;
    end;
    hence thesis by A1;
  end;
  uniqueness
  proof
    let h, g be complex-valued Function such that
A2: dom h = dom f and
A3: for c being set st c in dom h holds h.c = F(c) and
A4: dom g = dom f and
A5: for c being set st c in dom g holds g.c = F(c);
    now
      let x be set;
      assume
A6:   x in dom h;
      hence h.x = F(x) by A3
        .= g.x by A2,A4,A5,A6;
    end;
    hence thesis by A2,A4,FUNCT_1:9;
  end;
  involutiveness
  proof
    let r, h be complex-valued Function;
    assume that
A7: dom r = dom h and
A8: for c being set st c in dom r holds r.c = (h.c)";
    thus dom r = dom h by A7;
    let c be set;
    assume
A9: c in dom h;
    thus h.c = (h.c)""
      .= (r.c)" by A7,A8,A9;
  end;
end;
::better name

theorem Th10:
  for f being complex-valued Function holds for c being set holds
  f".c = (f.c)"
proof
  let f be complex-valued Function;
  let c be set;
A1: dom (f") = dom f by Def7;
  per cases;
  suppose
    c in dom f;
    hence thesis by A1,Def7;
  end;
  suppose
A2: not c in dom f;
    hence f".c = 0 qua complex number" by A1,FUNCT_1:def 4
      .= (f.c)" by A2,FUNCT_1:def 4;
  end;
end;

registration
  let f be real-valued Function;
  cluster f" -> real-valued;
  coherence
  proof
    let x be set;
    assume x in dom (f");
    then f".x = (f.x)" by Def7;
    hence thesis;
  end;
end;

registration
  let f be rational-valued Function;
  cluster f" -> rational-valued;
  coherence
  proof
    let x be set;
    assume x in dom (f");
    then f".x = (f.x)" by Def7;
    hence thesis;
  end;
end;

definition
  let C be set;
  let D be complex-membered set;
  let f be PartFunc of C,D;
  redefine func f" -> PartFunc of C,COMPLEX;
  coherence
  proof
    dom (f") = dom f & rng (f") c= COMPLEX by Def7,VALUED_0:def 1;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be real-membered set;
  let f be PartFunc of C,D;
  redefine func f" -> PartFunc of C,REAL;
  coherence
  proof
    dom (f") = dom f & rng (f") c= REAL by Def7,VALUED_0:def 3;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be rational-membered set;
  let f be PartFunc of C,D;
  redefine func f" -> PartFunc of C,RAT;
  coherence
  proof
    dom (f") = dom f & rng (f") c= RAT by Def7,VALUED_0:def 4;
    hence thesis by RELSET_1:11;
  end;
end;

registration
  let C be set;
  let D be complex-membered non empty set;
  let f be Function of C,D;
  cluster f" -> total PartFunc of C,COMPLEX;
  coherence
  proof
    dom (f") = dom f by Def7
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D be real-membered non empty set;
  let f be Function of C,D;
  cluster f" -> total PartFunc of C,REAL;
  coherence
  proof
    dom (f") = dom f by Def7
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D be rational-membered non empty set;
  let f be Function of C,D;
  cluster f" -> total PartFunc of C,RAT;
  coherence
  proof
    dom (f") = dom f by Def7
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let f be complex-valued FinSequence;
  cluster f" -> FinSequence-like;
  coherence
  proof
    dom (f") = dom f by Def7;
    hence thesis by Lm1;
  end;
end;

begin :: f^2

definition
  let f be complex-valued Function;
  func f^2 -> Function equals
  f (#) f;
  coherence;
end;

theorem Th11:
  for f being complex-valued Function holds dom (f^2) = dom f &
  for c being set holds f^2.c = (f.c)^2
proof
  let f be complex-valued Function;
  thus
A1: dom (f^2) = dom f /\ dom f by Def4
    .= dom f;
  let c be set;
  per cases;
  suppose
    c in dom f;
    hence thesis by A1,Def4;
  end;
  suppose
A2: not c in dom f;
    hence f^2.c = 0 qua complex number^2 by A1,FUNCT_1:def 4
      .= (f.c)^2 by A2,FUNCT_1:def 4;
  end;
end;

registration
  let f be complex-valued Function;
  cluster f^2 -> complex-valued;
  coherence;
end;

registration
  let f be real-valued Function;
  cluster f^2 -> real-valued;
  coherence;
end;

registration
  let f be rational-valued Function;
  cluster f^2 -> rational-valued;
  coherence;
end;

registration
  let f be integer-valued Function;
  cluster f^2 -> integer-valued;
  coherence;
end;

registration
  let f be natural-valued Function;
  cluster f^2 -> natural-valued;
  coherence;
end;

definition
  let C be set;
  let D be complex-membered set;
  let f be PartFunc of C,D;
  redefine func f^2 -> PartFunc of C,COMPLEX;
  coherence
  proof
    dom (f^2) = dom f & rng (f^2) c= COMPLEX by Th11,VALUED_0:def 1;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be real-membered set;
  let f be PartFunc of C,D;
  redefine func f^2 -> PartFunc of C,REAL;
  coherence
  proof
    dom (f^2) = dom f & rng (f^2) c= REAL by Th11,VALUED_0:def 3;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be rational-membered set;
  let f be PartFunc of C,D;
  redefine func f^2 -> PartFunc of C,RAT;
  coherence
  proof
    dom (f^2) = dom f & rng (f^2) c= RAT by Th11,VALUED_0:def 4;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be integer-membered set;
  let f be PartFunc of C,D;
  redefine func f^2 -> PartFunc of C,INT;
  coherence
  proof
    dom (f^2) = dom f & rng (f^2) c= INT by Th11,VALUED_0:def 5;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be natural-membered set;
  let f be PartFunc of C,D;
  redefine func f^2 -> PartFunc of C,NAT;
  coherence
  proof
    dom (f^2) = dom f & rng (f^2) c= NAT by Th11,VALUED_0:def 6;
    hence thesis by RELSET_1:11;
  end;
end;

registration
  let C be set;
  let D be complex-membered non empty set;
  let f be Function of C,D;
  cluster f^2 -> total PartFunc of C,COMPLEX;
  coherence;
end;

registration
  let C be set;
  let D be real-membered non empty set;
  let f be Function of C,D;
  cluster f^2 -> total PartFunc of C,REAL;
  coherence;
end;

registration
  let C be set;
  let D be rational-membered non empty set;
  let f be Function of C,D;
  cluster f^2 -> total PartFunc of C,RAT;
  coherence;
end;

registration
  let C be set;
  let D be integer-membered non empty set;
  let f be Function of C,D;
  cluster f^2 -> total PartFunc of C,INT;
  coherence;
end;

registration
  let C be set;
  let D be natural-membered non empty set;
  let f be Function of C,D;
  cluster f^2 -> total PartFunc of C,NAT;
  coherence;
end;

registration
  let f be complex-valued FinSequence;
  cluster f^2 -> FinSequence-like;
  coherence;
end;

begin :: f1 - f2

definition
  let f1,f2 be complex-valued Function;
  func f1 - f2 -> Function equals
  f1 + - f2;
  coherence;
end;

registration
  let f1,f2 be complex-valued Function;
  cluster f1-f2 -> complex-valued;
  coherence;
end;

registration
  let f1,f2 be real-valued Function;
  cluster f1-f2 -> real-valued;
  coherence;
end;

registration
  let f1,f2 be rational-valued Function;
  cluster f1-f2 -> rational-valued;
  coherence;
end;

registration
  let f1,f2 be integer-valued Function;
  cluster f1-f2 -> integer-valued;
  coherence;
end;

theorem Th12:
  for f1,f2 being complex-valued Function holds dom (f1-f2) = dom
  f1 /\ dom f2
proof
  let f1,f2 be complex-valued Function;
  thus dom (f1-f2) = dom f1 /\ dom -f2 by Def1
    .= dom f1 /\ dom f2 by Def5;
end;

theorem
  for f1,f2 being complex-valued Function for c being set st c in dom (
  f1-f2) holds (f1-f2).c = f1.c - f2.c
proof
  let f1,f2 be complex-valued Function;
  let c be set;
  assume c in dom (f1-f2);
  hence (f1-f2).c = f1.c+(-f2).c by Def1
    .= f1.c-f2.c by Th8;
end;

theorem
  for f1,f2 being complex-valued Function, f being Function st dom f =
  dom (f1-f2) & for c being set st c in dom f holds f.c = f1.c - f2.c holds f =
  f1-f2
proof
  let f1,f2 be complex-valued Function, f be Function such that
A1: dom f = dom (f1-f2) and
A2: for c being set st c in dom f holds f.c = f1.c - f2.c;
  thus dom f = dom (f1-f2) by A1;
  let c be set;
  assume
A3: c in dom f;
  hence f.c = f1.c - f2.c by A2
    .= f1.c+(-f2).c by Th8
    .= (f1-f2).c by A1,A3,Def1;
end;

definition
  let C be set;
  let D1,D2 be complex-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1-f2 -> PartFunc of C,COMPLEX;
  coherence
  proof
    dom (f1-f2) = dom f1 /\ dom f2 & rng (f1-f2) c= COMPLEX by Th12,
    VALUED_0:def 1;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D1,D2 be real-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1-f2 -> PartFunc of C,REAL;
  coherence
  proof
    dom (f1-f2) = dom f1 /\ dom f2 & rng (f1-f2) c= REAL by Th12,VALUED_0:
    def 3;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D1,D2 be rational-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1-f2 -> PartFunc of C,RAT;
  coherence
  proof
    dom (f1-f2) = dom f1 /\ dom f2 & rng (f1-f2) c= RAT by Th12,VALUED_0:
    def 4;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D1,D2 be integer-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1-f2 -> PartFunc of C,INT;
  coherence
  proof
    dom (f1-f2) = dom f1 /\ dom f2 & rng (f1-f2) c= INT by Th12,VALUED_0:
    def 5;
    hence thesis by RELSET_1:11;
  end;
end;

Lm3: for C being set, D1,D2 being complex-membered non empty set, f1 being
Function of C,D1, f2 being Function of C,D2 holds dom(f1-f2) = C

proof
  let C be set;
  let D1,D2 be complex-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  thus dom(f1-f2) = dom f1 /\ dom -f2 by Def1
    .= C /\ dom -f2 by FUNCT_2:def 1
    .= C /\ C by FUNCT_2:def 1
    .= C;
end;

registration
  let C be set;
  let D1,D2 be complex-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1-f2 -> total PartFunc of C,COMPLEX;
  coherence
  proof
    dom(f1-f2) = C by Lm3;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D1,D2 be real-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1-f2 -> total PartFunc of C,REAL;
  coherence
  proof
    dom(f1-f2) = C by Lm3;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D1,D2 be rational-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1-f2 -> total PartFunc of C,RAT;
  coherence
  proof
    dom(f1-f2) = C by Lm3;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D1,D2 be integer-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1-f2 -> total PartFunc of C,INT;
  coherence
  proof
    dom(f1-f2) = C by Lm3;
    hence thesis by PARTFUN1:def 4;
  end;
end;

theorem
  for C being set, D1,D2 being complex-membered non empty set for f1
  being Function of C,D1, f2 being Function of C,D2 for c being Element of C
  holds (f1-f2).c = f1.c - f2.c
proof
  let C be set;
  let D1,D2 be complex-membered non empty set;
  let f1 be Function of C,D1, f2 be Function of C,D2;
  let c be Element of C;
A1: dom(f1-f2) = C by FUNCT_2:def 1;
  per cases;
  suppose
    C is non empty;
    hence (f1-f2).c = f1.c + (-f2).c by A1,Def1
      .= f1.c - f2.c by Th8;
  end;
  suppose
A2: C is empty;
    then dom f2 = {};
    then f2.c = 0 by FUNCT_1:def 4;
    hence thesis by A2;
  end;
end;

registration
  let f1, f2 be complex-valued FinSequence;
  cluster f1-f2 -> FinSequence-like;
  coherence;
end;

begin :: f1 /" f2

definition
  let f1,f2 be complex-valued Function;
  func f1 /" f2 -> Function equals
  f1 (#) (f2");
  coherence;
end;

theorem Th16:
  for f1,f2 being complex-valued Function holds dom (f1/"f2) = dom
  f1 /\ dom f2
proof
  let f1,f2 be complex-valued Function;
  thus dom (f1/"f2) = dom f1 /\ dom (f2") by Def4
    .= dom f1 /\ dom f2 by Def7;
end;

theorem
  for f1,f2 being complex-valued Function for c being set holds (f1/"f2)
  .c = f1.c / f2.c
proof
  let f1,f2 be complex-valued Function;
  let c be set;
A1: dom (f1/"f2) = dom f1 /\ dom f2 by Th16;
  per cases;
  suppose
    c in dom (f1/"f2);
    hence (f1/"f2).c = f1.c * (f2").c by Def4
      .= f1.c / f2.c by Th10;
  end;
  suppose
A2: not c in dom (f1/"f2);
    then not c in dom f1 or not c in dom f2 by A1,XBOOLE_0:def 4;
    then
A3: f1.c = 0 or f2.c = 0 by FUNCT_1:def 4;
    thus (f1/"f2).c = 0 / 0 by A2,FUNCT_1:def 4
      .= f1.c / f2.c by A3;
  end;
end;

registration
  let f1,f2 be complex-valued Function;
  cluster f1/"f2 -> complex-valued;
  coherence;
end;

registration
  let f1,f2 be real-valued Function;
  cluster f1/"f2 -> real-valued;
  coherence;
end;

registration
  let f1,f2 be rational-valued Function;
  cluster f1/"f2 -> rational-valued;
  coherence;
end;

definition
  let C be set;
  let D1,D2 be complex-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1/"f2 -> PartFunc of C,COMPLEX;
  coherence
  proof
    dom (f1/"f2) = dom f1 /\ dom f2 & rng (f1/"f2) c= COMPLEX by Th16,
    VALUED_0:def 1;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D1,D2 be real-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1/"f2 -> PartFunc of C,REAL;
  coherence
  proof
    dom (f1/"f2) = dom f1 /\ dom f2 & rng (f1/"f2) c= REAL by Th16,
    VALUED_0:def 3;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D1,D2 be rational-membered set;
  let f1 be PartFunc of C,D1;
  let f2 be PartFunc of C,D2;
  redefine func f1/"f2 -> PartFunc of C,RAT;
  coherence
  proof
    dom (f1/"f2) = dom f1 /\ dom f2 & rng (f1/"f2) c= RAT by Th16,
    VALUED_0:def 4;
    hence thesis by RELSET_1:11;
  end;
end;

Lm4: for C being set, D1,D2 being complex-membered non empty set for f1 being
Function of C,D1, f2 being Function of C,D2 holds dom(f1/"f2) = C

proof
  let C be set;
  let D1,D2 be complex-membered non empty set;
  let f1 be Function of C,D1, f2 be Function of C,D2;
  thus dom(f1/"f2) = dom f1 /\ dom f2 by Th16
    .= C /\ dom f2 by FUNCT_2:def 1
    .= C /\ C by FUNCT_2:def 1
    .= C;
end;

registration
  let C be set;
  let D1,D2 be complex-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1/"f2 -> total PartFunc of C,COMPLEX;
  coherence
  proof
    dom(f1/"f2) = C by Lm4;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D1,D2 be real-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1/"f2 -> total PartFunc of C,REAL;
  coherence
  proof
    dom(f1/"f2) = C by Lm4;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D1,D2 be rational-membered non empty set;
  let f1 be Function of C,D1;
  let f2 be Function of C,D2;
  cluster f1/"f2 -> total PartFunc of C,RAT;
  coherence
  proof
    dom(f1/"f2) = C by Lm4;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let f1, f2 be complex-valued FinSequence;
  cluster f1/"f2 -> FinSequence-like;
  coherence;
end;

begin :: abs f

definition
  let f be complex-valued Function;
  deffunc F(set) = |.f.$1.|;
  func |. f .| -> real-valued Function means
  :Def11:
  dom it = dom f & for c
  being set st c in dom it holds it.c = |. f.c .|;
  existence
  proof
    consider g being Function such that
A1: dom g = dom f & for x being set st x in dom f holds g.x = F(x)
    from FUNCT_1:sch 3;
    g is real-valued
    proof
      let x be set;
      assume x in dom g;
      then g.x = |. f.x .| by A1;
      hence thesis;
    end;
    hence thesis by A1;
  end;
  uniqueness
  proof
    let h, g be real-valued Function such that
A2: dom h = dom f and
A3: for c being set st c in dom h holds h.c = F(c) and
A4: dom g = dom f and
A5: for c being set st c in dom g holds g.c = F(c);
    now
      let x be set;
      assume
A6:   x in dom h;
      hence h.x = F(x) by A3
        .= g.x by A2,A4,A5,A6;
    end;
    hence thesis by A2,A4,FUNCT_1:9;
  end;
  projectivity
  proof
    let r be real-valued Function;
    let h be real-valued Function;
    assume that
    dom r = dom h and
A7: for c being set st c in dom r holds r.c = |.h.c.|;
    thus dom r = dom r;
    let c be set;
    assume
A8: c in dom r;
    hence r.c = |.|.h.c.|.| by A7
      .= |.r.c.| by A7,A8;
  end;
end;

notation
  let f be complex-valued Function;
  synonym abs f for |. f .|;
end;

theorem
  for f being complex-valued Function holds for c being set holds |.f.|.
  c = |.f.c.|
proof
  let f be complex-valued Function;
  let c be set;
A1: dom |.f.| = dom f by Def11;
  per cases;
  suppose
    c in dom f;
    hence thesis by A1,Def11;
  end;
  suppose
A2: not c in dom f;
    hence |.f.|.c = |.0 qua complex number.| by A1,COMPLEX1:130 ,FUNCT_1:def
    4
      .= |.f.c.| by A2,FUNCT_1:def 4;
  end;
end;

registration
  let f be rational-valued Function;
  cluster |.f.| -> rational-valued;
  coherence
  proof
    let x be set;
    assume x in dom |.f.|;
    then |.f.|.x = |.f.x.| by Def11;
    hence thesis;
  end;
end;

registration
  let f be integer-valued Function;
  cluster |.f.| -> natural-valued;
  coherence
  proof
    let x be set;
    abs(f.x) is natural;
    hence thesis by Def11;
  end;
end;

definition
  let C be set;
  let D be complex-membered set;
  let f be PartFunc of C,D;
  redefine func |.f.| -> PartFunc of C,REAL;
  coherence
  proof
    dom |.f.| = dom f & rng |.f.| c= REAL by Def11,VALUED_0:def 3;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be complex-membered set;
  let f be PartFunc of C,D;
  redefine func abs(f) -> PartFunc of C,REAL;
  coherence
  proof
    abs(f) = |.f.|;
    hence thesis;
  end;
end;

definition
  let C be set;
  let D be rational-membered set;
  let f be PartFunc of C,D;
  redefine func |.f.| -> PartFunc of C,RAT;
  coherence
  proof
    dom |.f.| = dom f & rng |.f.| c= RAT by Def11,VALUED_0:def 4;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be rational-membered set;
  let f be PartFunc of C,D;
  redefine func abs(f) -> PartFunc of C,RAT;
  coherence
  proof
    abs(f) = |.f.|;
    hence thesis;
  end;
end;

definition
  let C be set;
  let D be integer-membered set;
  let f be PartFunc of C,D;
  redefine func |.f.| -> PartFunc of C,NAT;
  coherence
  proof
    dom |.f.| = dom f & rng |.f.| c= NAT by Def11,VALUED_0:def 6;
    hence thesis by RELSET_1:11;
  end;
end;

definition
  let C be set;
  let D be integer-membered set;
  let f be PartFunc of C,D;
  redefine func abs(f) -> PartFunc of C,NAT;
  coherence
  proof
    abs(f) = |.f.|;
    hence thesis;
  end;
end;

registration
  let C be set;
  let D be complex-membered non empty set;
  let f be Function of C,D;
  cluster |.f.| -> total PartFunc of C,REAL;
  coherence
  proof
    dom |.f.| = dom f by Def11
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D be rational-membered non empty set;
  let f be Function of C,D;
  cluster |.f.| -> total PartFunc of C,RAT;
  coherence
  proof
    dom |.f.| = dom f by Def11
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let C be set;
  let D be integer-membered non empty set;
  let f be Function of C,D;
  cluster |.f.| -> total PartFunc of C,NAT;
  coherence
  proof
    dom |.f.| = dom f by Def11
      .= C by FUNCT_2:def 1;
    hence thesis by PARTFUN1:def 4;
  end;
end;

registration
  let f be complex-valued FinSequence;
  cluster |.f.| -> FinSequence-like;
  coherence
  proof
    dom abs f = dom f by Def11;
    hence thesis by Lm1;
  end;
end;

theorem
  for f, g being FinSequence, h being Function st dom h = dom f /\ dom g
  holds h is FinSequence by Lm2;

begin :: Addenda

:: from RELOC, 2008.02.14, A.T.

reserve m,j,p,q,n,l for Element of NAT;

definition
  let p be Function, k be Element of NAT;
  func Shift(p,k) -> Function means
  :Def12:
  dom it = { m+k:m in dom p } & for
  m st m in dom p holds it.(m+k) = p.m;
  existence
  proof
    defpred P [set,set] means ex m st $1 = m+k & $2 = p.m;
    set A = { m+k:m in dom p };
A1: for e being set st e in A ex u being set st P[e,u]
    proof
      let e be set;
      assume e in A;
      then consider m such that
A2:   e = m+k and
      m in dom p;
      take p.m;
      thus thesis by A2;
    end;
    consider f being Function such that
A3: dom f = A and
A4: for e being set st e in A holds P[e,f.e] from CLASSES1:sch 1(A1);
    take f;
    thus dom f = { m+k:m in dom p } by A3;
    let m;
    assume m in dom p;
    then m+k in A;
    then ex j st m+k = j+k & f.(m+k) = p.j by A4;
    hence thesis;
  end;
  uniqueness
  proof
    let IT1,IT2 be Function such that
A5: dom IT1 = { m+k:m in dom p } and
A6: for m st m in dom p holds IT1.(m+k) = p.m and
A7: dom IT2 = { m+k:m in dom p } and
A8: for m st m in dom p holds IT2.(m+k) = p.m;
    for x being set st x in dom IT1 holds IT1.x = IT2.x
    proof
      let x be set;
      assume x in dom IT1;
      then consider m such that
A9:   x = m+k & m in dom p by A5;
      thus IT1.x = p.m by A6,A9
        .= IT2.x by A8,A9;
    end;
    hence thesis by A5,A7,FUNCT_1:9;
  end;
end;

registration
  let p be Function, k be Element of NAT;
  cluster Shift(p,k) -> NAT-defined;
  coherence
  proof
A1: dom Shift(p,k) = { m+k:m in dom p } by Def12;
    Shift(p,k) is NAT-defined
    proof
      let x be set;
      assume x in dom Shift(p,k);
      then ex m st x = m+k & m in dom p by A1;
      hence thesis;
    end;
    hence thesis;
  end;
end;

canceled;

theorem :: SCMFSA8C:11
  for P,Q being Function, k being Element of NAT st P c= Q holds Shift(P
  ,k) c= Shift(Q,k)
proof
  let P,Q be Function;
  let k be Element of NAT;
  assume
A1: P c= Q;
  then
A2: dom P c= dom Q by GRFUNC_1:8;
A3: dom Shift(P,k) = {m + k: m in dom P} by Def12;
A4: dom Shift(Q,k) = {m + k: m in dom Q} by Def12;
  now
    let x be set;
    assume x in dom Shift(P,k);
    then ex m1 being Element of NAT st x = m1 + k & m1 in dom P by A3;
    hence x in dom Shift(Q,k) by A2,A4;
  end;
  then
A5: dom Shift(P,k) c= dom Shift(Q,k) by TARSKI:def 3;
  now
    let x be set;
    assume x in dom Shift(P,k);
    then consider m1 being Element of NAT such that
A6: x = m1 + k and
A7: m1 in dom P by A3;
    thus Shift(P,k).x = Shift(P,k).(m1 + k) by A6
      .= P.m1 by A7,Def12
      .= Q.m1 by A1,A7,GRFUNC_1:8
      .= Shift(Q,k).(m1 + k) by A2,A7,Def12
      .= Shift(Q,k).x by A6;
  end;
  hence thesis by A5,GRFUNC_1:8;
end;

theorem :: SCMFSA_4:32
  for I being Function holds Shift(Shift(I,m),n) = Shift(I,m+n)
proof
  let I be Function;
  set A = {l+m:l in dom I };
A1: dom Shift(I,m) = A by Def12;
A2: now
    let l;
    assume
A3: l in dom I;
    then
A4: l+m in dom Shift(I,m) by A1;
    thus Shift(Shift(I,m),n).(l+(m+n)) = Shift(Shift(I,m),n).(l+m+n)
      .= Shift(I,m).(l+m) by A4,Def12
      .= I.l by A3,Def12;
  end;
  {p+n: p in A } = { q+(m+n): q in dom I}
  proof
    thus {p+n: p in A } c= { q+(m+n): q in dom I}
    proof
      let x be set;
      assume x in {p+n: p in A };
      then consider p such that
A5:   x = p+n and
A6:   p in A;
      consider l such that
A7:   p = l+m and
A8:   l in dom I by A6;
      x = l+(m+n) by A5,A7;
      hence thesis by A8;
    end;
    let x be set;
    assume x in { q+(m+n): q in dom I};
    then consider q such that
A9: x = q+(m+n) & q in dom I;
    x = (q+m)+n & q+m in A by A9;
    hence thesis;
  end;
  then dom Shift(Shift(I,m),n) = { l+(m+n): l in dom I} by A1,Def12;
  hence thesis by A2,Def12;
end;

theorem :: SCMFSA_4:33
  for s,f be Function for n holds Shift(f*s,n) = f*Shift(s,n)
proof
  let s,f be Function;
  let n;
A1: dom(f*s) c= dom s by RELAT_1:44;
A2: dom Shift(s,n)= { m+n: m in dom s } by Def12;
  now
    let e be set;
    thus e in { m+n: m in dom(f*s) } implies e in dom Shift(s,n) & Shift(s,n).
    e in dom f
    proof
      assume e in { m+n: m in dom(f*s) };
      then consider m such that
A3:   e = m+n and
A4:   m in dom(f*s);
      thus e in dom Shift(s,n) by A2,A1,A3,A4;
      Shift(s,n).e = s.m by A1,A3,A4,Def12;
      hence thesis by A4,FUNCT_1:21;
    end;
    assume e in dom Shift(s,n);
    then consider m0 being Element of NAT such that
A5: e = m0+n and
A6: m0 in dom s by A2;
    assume Shift(s,n).e in dom f;
    then s.m0 in dom f by A5,A6,Def12;
    then m0 in dom(f*s) by A6,FUNCT_1:21;
    hence e in { m+n: m in dom(f*s) } by A5;
  end;
  then Shift(s,n)"dom f = { m+n: m in dom(f*s) } by FUNCT_1:def 13;
  then
A7: dom(f*Shift(s,n)) = { m+n: m in dom(f*s) } by RELAT_1:182;
  now
    let m;
    assume
A8: m in dom(f*s);
    then m+n in dom Shift(s,n) by A2,A1;
    hence (f*Shift(s,n)).(m+n) = f.(Shift(s,n).(m+n)) by FUNCT_1:23
      .= f.(s.m) by A1,A8,Def12
      .= (f*s).m by A8,FUNCT_1:22;
  end;
  hence thesis by A7,Def12;
end;

theorem :: SCMFSA_4:34
  for I,J being Function holds Shift(I +* J, n) = Shift(I,n) +* Shift(J,
  n)
proof
  let I,J be Function;
A1: dom Shift(J,n) = { m+n: m in dom J } by Def12;
A2: now
    let m such that
A3: m in dom(I +* J);
    per cases;
    suppose
A4:   m in dom J;
      then m+n in dom Shift(J,n) by A1;
      hence (Shift(I,n) +* Shift(J,n)).(m+n) = Shift(J,n).(m+n) by FUNCT_4:
      14
        .= J.m by A4,Def12
        .= (I +* J).m by A4,FUNCT_4:14;
    end;
    suppose
A5:   not m in dom J;
      m in dom I \/ dom J by A3,FUNCT_4:def 1;
      then
A6:   m in dom I by A5,XBOOLE_0:def 3;
      not ex l st m+n = l+n & l in dom J by A5;
      then not m+n in dom Shift(J,n) by A1;
      hence (Shift(I,n) +* Shift(J,n)).(m+n) = Shift(I,n).(m+n) by FUNCT_4:
      12
        .= I.m by A6,Def12
        .= (I +* J).m by A5,FUNCT_4:12;
    end;
  end;
A7: dom Shift(I,n) = { m+n: m in dom I } by Def12;
A8: dom Shift(I,n) \/ dom Shift(J,n) = { m+n: m in dom I \/ dom J }
  proof
    hereby
      let x be set;
      assume x in dom Shift(I,n) \/ dom Shift(J,n);
      then x in dom Shift(I,n) or x in dom Shift(J,n) by XBOOLE_0:def 3;
      then consider m such that
A9:   x = m+n & m in dom J or x = m+n & m in dom I by A1,A7;
      m in dom I \/ dom J by A9,XBOOLE_0:def 3;
      hence x in { l+n: l in dom I \/ dom J } by A9;
    end;
    let x be set;
    assume x in { m+n: m in dom I \/ dom J };
    then consider m such that
A10: x = m+n and
A11: m in dom I \/ dom J;
    m in dom I or m in dom J by A11,XBOOLE_0:def 3;
    then x in dom Shift(I,n) or x in dom Shift(J,n) by A1,A7,A10;
    hence thesis by XBOOLE_0:def 3;
  end;
  dom(I +* J) = dom I \/ dom J by FUNCT_4:def 1;
  then dom(Shift(I,n) +* Shift(J,n)) = { m+n: m in dom(I +* J ) } by A8,
  FUNCT_4:def 1;
  hence thesis by A2,Def12;
end;

:: from SCMPDS_4, 2008.03.16, A.T.

theorem Th25:
  for p being Function,k,il being Element of NAT st il in dom p
  holds il+k in dom Shift(p,k)
proof
  let p be Function,k be Element of NAT;
  dom Shift(p,k) = { loc+k where loc is Element of NAT : loc in dom p} by
  Def12;
  hence thesis;
end;

:: missing, 2008.03.16, A.T.

theorem Th26:
  for p being Function, k being Element of NAT holds
  rng Shift(p,k) c= rng p
proof
  let p be Function, k being Element of NAT;
  let y be set;
  assume y in rng Shift(p,k);
  then consider x being set such that
A1: x in dom Shift(p,k) and
A2: y = Shift(p,k).x by FUNCT_1:def 5;
  x in { m+k:m in dom p } by A1,Def12;
  then consider m such that
A3: x = m+k and
A4: m in dom p;
  p.m = Shift(p,k).x by A3,A4,Def12;
  hence thesis by A2,A4,FUNCT_1:def 5;
end;

theorem
  for p being Function st dom p c= NAT for k being Element of NAT holds
  rng Shift(p,k) = rng p
proof
  let p be Function such that
A1: dom p c= NAT;
  let k be Element of NAT;
  thus rng Shift(p,k) c= rng p by Th26;
  let y be set;
  assume y in rng p;
  then consider x being set such that
A2: x in dom p and
A3: y = p.x by FUNCT_1:def 5;
  reconsider x as Element of NAT by A1,A2;
  x+k in dom Shift(p,k) & Shift(p,k).(x+k) = y by A2,A3,Def12,Th25;
  hence thesis by FUNCT_1:def 5;
end;

registration
  let p be finite Function, k be Element of NAT;
  cluster Shift(p,k) -> finite;
  coherence
  proof
    deffunc F(Element of NAT) = $1+k;
A1: dom p is finite;
    { F(w) where w is Element of NAT: w in dom p } is finite from FRAENKEL
    :sch 21(A1);
    then dom Shift(p,k) is finite by Def12;
    hence thesis by FINSET_1:29;
  end;
end;

reserve e1,e2 for ext-real number;

definition
  let X be non empty ext-real-membered set, s be sequence of X;
  redefine attr s is increasing means
  for n being Nat holds s.n < s.(n+1);
  compatibility
  proof
    thus s is increasing implies for n being Nat holds s.n < s.(n+1 )
    proof
      assume
A1:   s is increasing;
      let n be Nat;
A2:   n < n+1 by NAT_1:13;
      dom s = NAT & n in NAT by FUNCT_2:def 1,ORDINAL1:def 13;
      hence thesis by A1,A2,VALUED_0:def 13;
    end;
    assume
A3: for n being Nat holds s.n < s.(n+1);
    let e1,e2;
    assume e1 in dom s & e2 in dom s;
    then reconsider m=e1, n=e2 as Nat;
    defpred P[Nat] means m < $1 implies s.m < s.$1;
A4: for j being Nat st P[j] holds P[j+1]
    proof
      let j being Nat such that
A5:   P[j];
      assume m < j+1;
      then m <= j by NAT_1:13;
      then s.m < s.j or m = j by A5,XXREAL_0:1;
      hence thesis by A3,XXREAL_0:2;
    end;
    assume
A6: e1 < e2;
A7: P[0];
    for j being Nat holds P[j] from NAT_1:sch 2(A7,A4);
    then s.m < s.n by A6;
    hence thesis;
  end;
  redefine attr s is decreasing means
  for n being Nat holds s.n > s.(n+1);
  compatibility
  proof
    thus s is decreasing implies for n being Nat holds s.n > s.(n+1 )
    proof
      assume
A8:   s is decreasing;
      let n be Nat;
A9:   n < n+1 by NAT_1:13;
      dom s = NAT & n in NAT by FUNCT_2:def 1,ORDINAL1:def 13;
      hence thesis by A8,A9,VALUED_0:def 14;
    end;
    assume
A10: for n being Nat holds s.n > s.(n+1);
    let e1,e2;
    assume e1 in dom s & e2 in dom s;
    then reconsider m=e1, n=e2 as Nat;
    defpred P[Nat] means m < $1 implies s.m > s.$1;
A11: for j being Nat st P[j] holds P[j+1]
    proof
      let j being Nat such that
A12:  P[j];
      assume m < j+1;
      then m <= j by NAT_1:13;
      then s.m > s.j or m = j by A12,XXREAL_0:1;
      hence thesis by A10,XXREAL_0:2;
    end;
    assume
A13: e1 < e2;
A14: P[0];
    for j being Nat holds P[j] from NAT_1:sch 2(A14,A11);
    then s.m > s.n by A13;
    hence thesis;
  end;
  redefine attr s is non-decreasing means
  for n being Nat holds s.n <= s.(n+1);
  compatibility
  proof
    thus s is non-decreasing implies for n being Nat holds s.n <= s.(n+1 )
    proof
      assume
A15:  s is non-decreasing;
      let n be Nat;
A16:  n < n+1 by NAT_1:13;
      dom s = NAT & n in NAT by FUNCT_2:def 1,ORDINAL1:def 13;
      hence thesis by A15,A16,VALUED_0:def 15;
    end;
    assume
A17: for n being Nat holds s.n <= s.(n+1);
    let e1,e2;
    assume e1 in dom s & e2 in dom s;
    then reconsider m=e1, n=e2 as Nat;
    defpred P[Nat] means m <= $1 implies s.m <= s.$1;
A18: for j being Nat st P[j] holds P[j+1]
    proof
      let j being Nat such that
A19:  P[j];
      assume m <= j+1;
      then
A20:  m < j+1 or m = j+1 by XXREAL_0:1;
      s.j <= s.(j+1) by A17;
      hence thesis by A19,A20,NAT_1:13,XXREAL_0:2;
    end;
    assume
A21: e1 <= e2;
A22: P[0];
    for j being Nat holds P[j] from NAT_1:sch 2(A22,A18);
    then s.m <= s.n by A21;
    hence thesis;
  end;
  redefine attr s is non-increasing means
  for n being Nat holds s.n >= s.(n+1);
  compatibility
  proof
    thus s is non-increasing implies for n being Nat holds s.n >= s.(n+1 )
    proof
      assume
A23:  s is non-increasing;
      let n be Nat;
A24:  n < n+1 by NAT_1:13;
      dom s = NAT & n in NAT by FUNCT_2:def 1,ORDINAL1:def 13;
      hence thesis by A23,A24,VALUED_0:def 16;
    end;
    assume
A25: for n being Nat holds s.n >= s.(n+1);
    let e1,e2;
    assume e1 in dom s & e2 in dom s;
    then reconsider m=e1, n=e2 as Nat;
    defpred P[Nat] means m <= $1 implies s.m >= s.$1;
A26: for j being Nat st P[j] holds P[j+1]
    proof
      let j being Nat such that
A27:  P[j];
      assume m <= j+1;
      then
A28:  m < j+1 or m = j+1 by XXREAL_0:1;
      s.j >= s.(j+1) by A25;
      hence thesis by A27,A28,NAT_1:13,XXREAL_0:2;
    end;
    assume
A29: e1 <= e2;
A30: P[0];
    for j being Nat holds P[j] from NAT_1:sch 2(A30,A26);
    then s.m >= s.n by A29;
    hence thesis;
  end;
end;

:: from KURATO_2, 2008.09.05, A.T.

scheme
  SubSeqChoice { X() -> non empty set, S() -> sequence of X(), P[set]} :
   ex S1 being subsequence of S() st for n being Element of NAT holds P[S1.n]
provided
A1: for n being Element of NAT ex m being Element of NAT st n <= m & P[S
().m]
proof
  defpred P1[set,set,set] means $3 in NAT & (for m,k being Element of NAT st m
  = $2 & k = $3 holds m < k & P[S().k]);
  consider n0 being Element of NAT such that
  0 <= n0 and
A2: P[S().n0] by A1;
A3: for n being Element of NAT for x being set ex y being set st P1[n,x,y]
  proof
    let n be Element of NAT, x be set;
    per cases;
    suppose
      x in NAT;
      then reconsider mx = x as Element of NAT;
      consider my being Element of NAT such that
A4:   mx + 1 <= my & P[S().my] by A1;
      take my;
      thus my in NAT;
      thus thesis by A4,NAT_1:13;
    end;
    suppose
A5:   not x in NAT;
      take 0;
      set y = 0;
      thus y in NAT;
      let m, k be Element of NAT;
      assume that
A6:   m = x and
      k = y;
      thus thesis by A5,A6;
    end;
  end;
  consider g being Function such that
A7: dom g = NAT and
A8: g.0 = n0 and
A9: for n being Element of NAT holds P1[n,g.n,g.(n+1)] from RECDEF_1:
  sch 1(A3);
  rng g c= NAT
  proof
    defpred P[Element of NAT] means g.$1 in NAT;
    let y be set;
    assume y in rng g;
    then consider x being set such that
A10: x in dom g and
A11: g.x = y by FUNCT_1:def 5;
    reconsider n = x as Element of NAT by A7,A10;
A12: for k being Element of NAT holds P[k] implies P[k+1] by A9;
A13: P[0] by A8;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A13,A12);
    then g.n in NAT;
    hence thesis by A11;
  end;
  then reconsider g as sequence of NAT by A7,FUNCT_2:4;
  g is increasing
  proof
    let n be Nat;
    reconsider n as Element of NAT by ORDINAL1:def 13;
    g.n < g.(n+1) by A9;
    hence thesis;
  end;
  then reconsider g as increasing sequence of NAT;
  reconsider S1 = S() * g as sequence of X();
A14: dom S1 = NAT by FUNCT_2:def 1;
  reconsider S1 as subsequence of S();
  take S1;
  thus for n being Element of NAT holds P[S1.n]
  proof
    let n be Element of NAT;
    per cases;
    suppose
      n = 0;
      hence thesis by A2,A8,A14,FUNCT_1:22;
    end;
    suppose
      n <> 0;
      then n >= 0 qua Nat + 1 by NAT_1:13;
      then reconsider n9 = n-1 as Element of NAT by INT_1:18;
      reconsider k = g.(n9+1) as Element of NAT;
      for m,k being Element of NAT st m = g.n9 & k = g.(n9+1) holds P[S()
      .k] by A9;
      then P[S().k];
      hence thesis by A14,FUNCT_1:22;
    end;
  end;
end;

:: from AMISTD_2, 2010.02.05, A.T.

theorem
  for k being Element of NAT
  for F being NAT-defined Function
  holds dom F,dom Shift(F,k) are_equipotent
proof
  let k be Element of NAT;
  let F be NAT-defined Function;
A1: dom F c= NAT by RELAT_1:def 18;
  defpred P[set,set] means
  ex il being Element of NAT
   st $1 = il & $2 = k+il;
A2: for e being set st e in dom F ex u being set st P[e,u]
  proof
    let e be set;
    assume e in dom F;
    then reconsider e as Element of NAT by A1;
    take k+e, e;
    thus thesis;
  end;
  consider f being Function such that
A3: dom f = dom F and
A4: for x being set st x in dom F holds P[x,f.x] from CLASSES1:sch 1(A2);
  take f;
  hereby
    let x1, x2 be set such that
A5: x1 in dom f and
A6: x2 in dom f and
A7: f.x1 = f.x2;
    consider i1 being Element of NAT such that
A8: x1 = i1 and
A9: f.x1 = k+i1 by A3,A4,A5;
    consider i2 being Element of NAT such that
A10: x2 = i2 and
A11: f.x2 = k+i2 by A3,A4,A6;
    thus x1 = x2 by A8,A7,A9,A11,A10;
  end;
  thus dom f = dom F by A3;
A12: dom Shift(F,k) =
  { (m+k) where m is Element of NAT: m in dom F } by Def12;
  hereby
    let y be set;
    assume y in rng f;
    then consider x being set such that
A13: x in dom f and
A14: f.x = y by FUNCT_1:def 5;
    consider il being Element of NAT such that
A15: x = il and
A16: f.x = k+il by A3,A4,A13;
   thus y in dom Shift(F,k) by A3,A12,A13,A14,A15,A16;
  end;
  let y be set;
  assume y in dom Shift(F,k);
  then consider m being Element of NAT such that
A18: y = (m+k) and
A19: m in dom F by A12;
  consider il being Element of NAT such that
A20: m = il and
A21: f.m = k+il by A4,A19;
  thus thesis by A3,A18,A19,A20,A21,FUNCT_1:def 5;
end;

theorem
  for F being NAT-defined Function holds Shift(F,0) = F
proof
  let F be NAT-defined Function;
A1: dom F c= NAT by RELAT_1:def 18;
A2: dom F = { m+(0 qua complex number) where m is Element of NAT: m in dom F }
  proof
    hereby
     let a be set;
     assume
A3:   a in dom F;
      then reconsider l=a as Element of NAT by A1;
      a = (l qua complex number)+(0 qua complex number);
     hence a in { m+(0 qua complex number)
      where m is Element of NAT: m in dom F } by A3;
    end;
    let a be set;
    assume
    a in { m+(0 qua complex number) where m is Element of NAT: m in dom F };
    then ex m being Element of NAT
     st a = m+(0 qua complex number) & m in dom F;
    hence thesis;
  end;
  for m being Element of NAT st m in dom F
   holds F.(m+(0 qua complex number)) = F.m;
  hence thesis by A2,Def12;
end;

registration
  let X be non empty set;
  let F be X-valued Function,
  k be Element of NAT;
  cluster Shift(F,k) -> X-valued;
  coherence
  proof
A1: dom Shift(F,k) =
    { (m+k) where m is Element of NAT: m in dom F } by Def12;
    thus rng Shift(F,k) c= X
     proof let x be set;
      assume x in rng Shift(F,k);
       then consider y being set such that
W1:     y in dom Shift(F,k) and
W2:     x = Shift(F,k).y by FUNCT_1:def 5;
       consider m being Element of NAT such that
W3:     y = (m+k) and
W4:     m in dom F by W1,A1;
       Shift(F,k).(m+k) = F.m by W4,Def12
            .= F/.m by W4,PARTFUN1:def 8;
      hence x in X by W2,W3;
     end;
  end;
end;

registration  :: move somewhere !!!
 cluster non empty NAT-defined Function;
 existence
  proof
   take id NAT;
   thus thesis;
  end;
end;

registration
  let F be empty Function, k be Element of NAT;
  cluster Shift(F,k) -> empty;
  coherence
  proof
A1: dom Shift(F,k) =
    { (m+k) where m is Element of NAT: m in dom F } by Def12;
    assume Shift(F,k) is non empty;
    then reconsider f = Shift(F,k) as non empty Function;
    dom f is non empty;
    then consider a being set such that
A2: a in dom Shift(F,k) by XBOOLE_0:def 1;
    ex m being Element of NAT st a = (m+k) & m in dom F by A1,A2;
    hence thesis;
  end;
end;

registration
  let F be non empty NAT-defined Function, k be Element of NAT;
  cluster Shift(F,k) -> non empty;
  coherence
  proof
A1: dom Shift(F,k) =
    { (m+k) where m is Element of NAT: m in dom F } by Def12;
    consider a being set such that
A2: a in dom F by XBOOLE_0:def 1;
    dom F c= NAT by RELAT_1:def 18;
    then reconsider a as Element of NAT by A2;
    consider m being natural number such that
A3: a = m;
    reconsider m as Element of NAT by ORDINAL1:def 13;
    (m+k) in dom Shift(F,k) by A1,A2,A3;
    hence thesis;
  end;
end;

theorem
  for F being Function, k being Element of NAT st k > 0
  holds not 0 in dom Shift(F,k)
proof
  let F be Function,
  k be Element of NAT such that
A1: k > 0 and
A2: 0 in dom Shift(F,k);
  dom Shift(F,k) = { m+k where m is Element of NAT: m in dom F } by Def12;
  then ex m being Element of NAT st 0 = m+k &  m in dom F by A2;
  hence contradiction by A1;
end;

registration
 cluster NAT-defined finite non empty Function;
 existence
  proof
   take f = 0 .--> 0;
X:  0 in NAT;
    dom f = {0} by FUNCOP_1:19;
   hence dom f c= NAT by ZFMISC_1:37;
   thus thesis;
  end;
end;

registration
  let F be NAT-defined Relation;
  cluster dom F -> natural-membered;
 coherence
  proof
    dom F c= NAT by RELAT_1:def 18;
   hence thesis;
  end;
end;

definition
  let F be non empty NAT-defined finite Function;
  func LastLoc F -> Element of NAT equals
   max dom F;
 coherence by ORDINAL1:def 13;
end;

definition
  let F be non empty NAT-defined finite Function;
  func CutLastLoc F -> Function equals
  F \ ( LastLoc F .--> F.LastLoc F );
  coherence;
end;

registration
 let F be non empty NAT-defined finite Function;
 cluster CutLastLoc F -> NAT-defined finite;
 coherence;
end;

theorem Th31:
  for F being non empty NAT-defined finite Function holds
  LastLoc F in dom F by XXREAL_2:def 8;

theorem
  for F, G being non empty NAT-defined finite Function st F c= G holds
  LastLoc F <= LastLoc G by RELAT_1:25,XXREAL_2:59;

theorem
  for F being non empty NAT-defined finite Function, l being
  Element of NAT st l in dom F holds l <= LastLoc F by XXREAL_2:def 8;

definition
  let F be non empty NAT-defined Function;
  func FirstLoc F -> Element of NAT equals
   min dom F;
  coherence by ORDINAL1:def 13;
end;

theorem
  for F being non empty NAT-defined finite Function holds
  FirstLoc F in dom F
proof
  let F be non empty NAT-defined finite Function;
   set M = dom F;
  min M in M by XXREAL_2:def 7;
  hence thesis;
end;

theorem
  for F, G being non empty NAT-defined finite Function st F c= G holds
  FirstLoc G <= FirstLoc F
proof
  let F, G be non empty NAT-defined finite Function such that
A1: F c= G;
    set N = dom G;
A3: FirstLoc G = min N;
   set M = dom F;
  M c= N by A1,RELAT_1:25;
  then min N <= min M by XXREAL_2:60;
  hence thesis;
end;

theorem
  for l1 being Element of NAT
  for F being non empty NAT-defined finite Function st l1 in dom
  F holds FirstLoc F <= l1
proof let l1 be Element of NAT;
  let F be non empty NAT-defined finite Function such that
A1: l1 in dom F;
   set M = dom F;
  l1 in M by A1;
  then min M <= l1 by XXREAL_2:def 7;
  hence thesis;
end;

theorem Th47:
  for F being non empty NAT-defined finite Function
  holds dom CutLastLoc F = (dom F) \ {LastLoc F}
proof
  let F be non empty NAT-defined finite Function;
A1: dom (LastLoc F .--> (F.LastLoc F)) = {LastLoc F} by FUNCOP_1:19;
  reconsider R = {[LastLoc F, F.LastLoc F]} as Relation;
A2: R = LastLoc F .--> (F.LastLoc F) by FUNCT_4:87;
  then
A3: dom R = {LastLoc F} by FUNCOP_1:19;
  thus dom CutLastLoc F c= (dom F) \ {LastLoc F}
  proof
    let x be set;
    assume x in dom CutLastLoc F;
    then consider y being set such that
A4: [x,y] in F \ R by A2,RELAT_1:def 4;
A5: not [x,y] in R by A4,XBOOLE_0:def 5;
A6: x in dom F by A4,RELAT_1:def 4;
    per cases by A5,TARSKI:def 1;
    suppose x <> LastLoc F;
      then not x in dom R by A3,TARSKI:def 1;
      hence thesis by A1,A2,A6,XBOOLE_0:def 5;
    end;
    suppose
A7:   y <> F.LastLoc F;
      now
        assume x in dom R;
        then x = LastLoc F by A3,TARSKI:def 1;
        hence contradiction by A4,A7,FUNCT_1:8;
      end;
      hence thesis by A1,A2,A6,XBOOLE_0:def 5;
    end;
  end;
  thus thesis by A1,RELAT_1:15;
end;

theorem Th48:
  for F being non empty NAT-defined finite Function
  holds dom F = dom CutLastLoc F \/ {LastLoc F}
proof
  let F be non empty NAT-defined finite Function;
  LastLoc F in dom F by Th31;
  then
A1: {LastLoc F} c= dom F by ZFMISC_1:37;
  dom CutLastLoc F = (dom F) \ {LastLoc F} by Th47;
  hence thesis by A1,XBOOLE_1:45;
end;

registration
 cluster non empty trivial NAT-defined finite Function;
 existence
  proof
   take 0 .--> 0;
   thus thesis;
  end;
end;

registration
  let F be non empty trivial NAT-defined finite Function;
  cluster CutLastLoc F -> empty;
  coherence
  proof
    LastLoc F in dom F by Th31;
    then
A1: [LastLoc F,F.LastLoc F] in F by FUNCT_1:def 4;
    assume not thesis;
    then consider a being set such that
A2: a in CutLastLoc F by XBOOLE_0:def 1;
A3: a = [LastLoc F,F.LastLoc F] by A1,A2,ZFMISC_1:def 10;
    not a in LastLoc F .--> F.LastLoc F by A2,XBOOLE_0:def 5;
    then not a in {[LastLoc F,F.LastLoc F]} by FUNCT_4:87;
    hence thesis by A3,TARSKI:def 1;
  end;
end;

theorem Th49:
  for F being non empty NAT-defined finite Function
  holds card CutLastLoc F = card F - 1
proof
  let F be non empty NAT-defined finite Function;
  LastLoc F .--> F.LastLoc F c= F
  proof
    let a, b be set;
    assume [a,b] in LastLoc F .--> F.LastLoc F;
    then [a,b] in {[LastLoc F,F.LastLoc F]} by FUNCT_4:87;
    then
A1: [a,b] = [LastLoc F,F.LastLoc F] by TARSKI:def 1;
    LastLoc F in dom F by Th31;
    hence thesis by A1,FUNCT_1:def 4;
  end;
  hence card CutLastLoc F = card F - card (LastLoc F .--> F.LastLoc F)
  by CARD_2:63
    .= card F - card {[LastLoc F,F.LastLoc F]} by FUNCT_4:87
    .= card F - 1 by CARD_1:50;
end;

