:: The Field of Complex Numbers
::  by Anna Justyna Milewska
::
:: Received January 18, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies COMPLEX1, VECTSP_1, RLVECT_1, COMPLSP1, BINOP_1, LATTICES,
      FUNCT_1, ARYTM_1, RELAT_1, ARYTM_3, ABSVALUE, COMPLFLD, XCMPLX_0,
      GROUP_1, ARYTM, COMPTRIG, VECTSP_2, ALGSTR_0;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0, COMPLEX1,
      NAT_1, FUNCT_1, XXREAL_0, COMPTRIG, BINOP_1, BINOP_2, STRUCT_0, ALGSTR_0,
      RLVECT_1, GROUP_1, NEWTON, VECTSP_1;
 constructors BINOP_1, XXREAL_0, REAL_1, NAT_1, BINOP_2, NEWTON, COMPTRIG,
      VECTSP_1, RLVECT_1;
 registrations ORDINAL1, RELSET_1, NUMBERS, XCMPLX_0, NAT_1, COMPLEX1,
      STRUCT_0, VECTSP_1, XREAL_0, XBOOLE_0;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions RLVECT_1, GROUP_1, VECTSP_1, BINOP_1, COMPTRIG, STRUCT_0,
      COMPLEX1, ALGSTR_0;
 theorems COMPLEX1, RLVECT_1, VECTSP_1, XREAL_0, XCMPLX_0, XCMPLX_1, BINOP_2,
      GROUP_1, COMPTRIG, NEWTON, ORDINAL1, NAT_1, XREAL_1;
 schemes NAT_1;

begin

canceled 2;

definition
  func F_Complex -> strict doubleLoopStr means
  :Def1:
  the carrier of it = COMPLEX & the addF of it = addcomplex &
  the multF of it = multcomplex & 1.it = 1r & 0.it = 0c;
  existence
  proof
    take doubleLoopStr (# COMPLEX,addcomplex,multcomplex,1r,0c #);
    thus thesis;
  end;
  uniqueness;
end;

registration
  cluster F_Complex -> non empty;
  coherence by Def1;
end;

registration
  cluster -> complex Element of F_Complex;
  coherence
  proof
    let c be Element of F_Complex;
    c in the carrier of F_Complex;
    then c in COMPLEX by Def1;
    hence thesis;
  end;
end;

registration
  let a,b be complex number;
  let x,y be Element of F_Complex;
  identify x+y with a+b when x=a, y=b;
  compatibility
  proof
    assume
A1: x=a & y=b;
    reconsider a'=a, b'=b as Element of COMPLEX by XCMPLX_0:def 2;
    thus x+y = addcomplex.(a',b') by A1,Def1
      .= a+b by BINOP_2:def 3;
  end;
  identify x*y with a*b when x=a, y=b;
  compatibility
  proof
    assume
A2: x=a & y=b;
    reconsider a'=a, b'=b as Element of COMPLEX by XCMPLX_0:def 2;
    thus x*y = multcomplex.(a',b') by A2,Def1
      .= a*b by BINOP_2:def 5;
  end;
end;

registration
  cluster F_Complex -> well-unital;
  coherence
  proof
    let x be Element of F_Complex;
    1.F_Complex = 1r by Def1;
    hence thesis;
  end;
end;

Lm1: 1_F_Complex = 1r by Def1;

Lm2: 1.F_Complex = 1r by Def1;

registration
  cluster F_Complex -> add-associative right_zeroed right_complementable
    Abelian commutative associative left_unital
    right_unital distributive almost_left_invertible non degenerated;
  coherence
  proof
    thus F_Complex is add-associative
    proof
      let x,y,z be Element of F_Complex;
      reconsider x1=x, y1=y, z1=z as Element of COMPLEX by Def1;
      thus (x + y) + z = addcomplex.[(the addF of F_Complex).[x1,y1],z1]
      by Def1
        .= addcomplex.(addcomplex.(x1,y1),z1) by Def1
        .= addcomplex.(x1 + y1,z1) by BINOP_2:def 3
        .=(x1 + y1) + z1 by BINOP_2:def 3
        .= x1 + (y1 + z1)
        .= addcomplex.(x1,y1 + z1) by BINOP_2:def 3
        .= addcomplex.[x1,addcomplex.(y1,z1)] by BINOP_2:def 3
        .= addcomplex.[x1,(the addF of F_Complex).[y1,z1]] by Def1
        .= x + (y + z) by Def1;
    end;
    thus F_Complex is right_zeroed
    proof
      let x be Element of F_Complex;
      reconsider x1=x as Element of COMPLEX by Def1;
      thus x + 0.F_Complex = (the addF of F_Complex).(x1,0c) by Def1
        .= addcomplex.(x1,0c) by Def1
        .= x1 + 0c by BINOP_2:def 3
        .= x;
    end;
    thus F_Complex is right_complementable
    proof
      let x be Element of F_Complex;
      reconsider x1=x as Element of COMPLEX by Def1;
      reconsider y=-x1 as Element of F_Complex by Def1;
      take y;
      thus thesis by Def1;
    end;
    thus F_Complex is Abelian
    proof
      let x,y be Element of F_Complex;
      thus thesis;
    end;
    thus F_Complex is commutative
    proof
      let x,y be Element of F_Complex;
      thus thesis;
    end;
    thus F_Complex is associative
    proof
      let x,y,z be Element of F_Complex;
      reconsider x1=x, y1=y, z1=z as Element of COMPLEX by Def1;
      thus (x * y) * z =
      multcomplex.((the multF of F_Complex).(x1,y1),z1) by Def1
        .= multcomplex.(multcomplex.(x1,y1),z1) by Def1
        .= multcomplex.(x1 * y1,z1) by BINOP_2:def 5
        .= (x1 * y1) * z1 by BINOP_2:def 5
        .= x1 * (y1 * z1)
        .= multcomplex.(x1,y1 * z1) by BINOP_2:def 5
        .= multcomplex.(x1,multcomplex.(y1,z1)) by BINOP_2:def 5
        .= multcomplex.(x1,(the multF of F_Complex).(y1,z1)) by Def1
        .= x * (y * z) by Def1;
    end;
    thus F_Complex is left_unital;
    thus F_Complex is right_unital;
    thus F_Complex is distributive
    proof
      let x,y,z be Element of F_Complex;
      reconsider x1=x, y1=y, z1=z as Element of COMPLEX by Def1;
      thus x*(y+z)= multcomplex.(x1,(the addF of F_Complex).(y1,z1)) by Def1
        .= multcomplex.(x1,addcomplex.(y1,z1)) by Def1
        .= multcomplex.(x1,y1 + z1) by BINOP_2:def 3
        .= x1 * (y1 + z1) by BINOP_2:def 5
        .= x1 * y1 + x1 * z1
        .= addcomplex.(x1 * y1,x1 * z1) by BINOP_2:def 3
        .= addcomplex.(multcomplex.(x1,y1),x1 * z1) by BINOP_2:def 5
        .= addcomplex.(multcomplex.(x1,y1),multcomplex.(x1,z1))
      by BINOP_2:def 5
        .= (the addF of F_Complex).(multcomplex.(x1,y1),multcomplex.(x1,z1))
      by Def1
        .= (the addF of F_Complex).((the multF of F_Complex).(x1,y1),
      multcomplex.(x1,z1)) by Def1
        .= x*y+x*z by Def1;
      thus (y+z)*x = multcomplex.((the addF of F_Complex).(y1,z1),x1) by Def1
        .= multcomplex.(addcomplex.(y1,z1),x1) by Def1
        .= multcomplex.(y1 + z1,x1) by BINOP_2:def 3
        .= (y1 + z1) * x1 by BINOP_2:def 5
        .= y1 * x1 + z1 * x1
        .= addcomplex.(y1 * x1,z1 * x1) by BINOP_2:def 3
        .= addcomplex.(multcomplex.(y1,x1),z1 * x1) by BINOP_2:def 5
        .= addcomplex.(multcomplex.(y1,x1),multcomplex.(z1,x1))
      by BINOP_2:def 5
        .= (the addF of F_Complex).(multcomplex.(y1,x1),multcomplex.(z1,x1))
      by Def1
        .= (the addF of F_Complex).((the multF of F_Complex).(y1,x1),
      multcomplex.(z1,x1)) by Def1
        .= y * x + z * x by Def1;
    end;
    thus F_Complex is almost_left_invertible
    proof
      let x be Element of F_Complex;
      assume
A1:   x <> 0.F_Complex;
      reconsider x1=x as Element of COMPLEX by Def1;
      reconsider y=x1" as Element of F_Complex by Def1;
      take y;
      x1<>0c by A1,Def1;
      hence thesis by Lm2,XCMPLX_0:def 7;
    end;
    thus F_Complex is non degenerated
    proof
      thus 0.F_Complex <> 1.F_Complex by Def1,Lm1;
    end;
  end;
end;

theorem
  for x1,y1 be Element of F_Complex
  for x2,y2 be complex number st x1 = x2 & y1 = y2 holds x1 + y1 = x2 + y2;

theorem Th4:
  for x1 be Element of F_Complex for x2 be complex number st x1 = x2 holds
  - x1 = - x2
proof
  let x1 be Element of F_Complex;
  let x2 be complex number;
  assume
A1: x1 = x2;
  reconsider x2 as Element of COMPLEX by XCMPLX_0:def 2;
  reconsider x'=-x2 as Element of F_Complex by Def1;
  x1 + x' = 0.F_Complex by A1,Def1;
  hence thesis by RLVECT_1:def 11;
end;

theorem Th5:
  for x1,y1 be Element of F_Complex
  for x2,y2 be complex number st x1 = x2 & y1 = y2 holds x1 - y1 = x2 - y2
proof
  let x1,y1 be Element of F_Complex;
  let x2,y2 be complex number;
  assume
A1: x1 = x2 & y1 = y2;
  then - y1 = -y2 by Th4;
  hence thesis by A1;
end;

theorem
  for x1,y1 be Element of F_Complex
  for x2,y2 be complex number st x1 = x2 & y1 = y2 holds x1 * y1 = x2 * y2;

theorem Th7:
  for x1 be Element of F_Complex
  for x2 be complex number st x1 = x2 & x1 <> 0.F_Complex holds x1" = x2"
proof
  let x1 be Element of F_Complex;
  let x2 be complex number;
  assume
A1: x1 = x2 & x1 <> 0.F_Complex;
A2: 0c = 0.F_Complex by Def1;
  reconsider x4 = x2 as Element of COMPLEX by XCMPLX_0:def 2;
  reconsider x'= x4" as Element of F_Complex by Def1;
  x1 * x' = 1.F_Complex by A1,A2,Lm2,XCMPLX_0:def 7;
  hence thesis by A1,VECTSP_1:def 22;
end;

theorem Th8:
  for x1,y1 be Element of F_Complex for x2,y2 be complex number st
  x1 = x2 & y1 = y2 & y1 <> 0.F_Complex holds x1/y1 = x2/y2
proof
  let x1,y1 be Element of F_Complex;
  let x2,y2 be complex number;
  assume
A1: x1 = x2 & y1 = y2;
  assume y1 <> 0.F_Complex;
  then y1" = y2" by A1,Th7;
  hence thesis by A1,XCMPLX_0:def 9;
end;

theorem Th9:
  0.F_Complex = 0c by Def1;

theorem
  1_F_Complex = 1r by Def1;

theorem
  1_F_Complex + 1_F_Complex <> 0.F_Complex by Def1,Lm1;

definition
  let z be Element of F_Complex;
  redefine func z *' -> Element of F_Complex;
  coherence
  proof
    z *' in COMPLEX;
    hence thesis by Def1;
  end;
  redefine func |.z.| -> Element of REAL;
  coherence by XREAL_0:def 1;
end;

reserve z,z1,z2,z3,z4 for Element of F_Complex;

canceled 17;

theorem
  -z = (-1_F_Complex) * z
proof
  reconsider z'=z as Element of COMPLEX by Def1;
A1: -1r = -1_F_Complex by Lm1,Th4;
  thus -z = -z' by Th4
    .= (-1_F_Complex) * z by A1;
end;

canceled 5;

theorem
  z1 - -z2 = z1 + z2
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  -z2 = -z2' by Th4;
  hence z1 - -z2 = z1'- -z2' by Th5
    .= z1 + z2;
end;

canceled 5;

theorem
  z1 = z1 + z - z
proof
  reconsider z1'=z1,z'=z as Element of COMPLEX by Def1;
  thus z1 + z - z = z1' + z' - z' by Th5
    .= z1;
end;

theorem
  z1 = z1 - z + z
proof
  reconsider z1'=z1,z'=z as Element of COMPLEX by Def1;
  z1 - z = z1' - z' by Th5;
  hence thesis;
end;

canceled 4;

theorem
  z1 <> 0.F_Complex & z2 <> 0.F_Complex & z1" = z2" implies z1 = z2
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z1 <> 0.F_Complex;
  assume
A2: z2 <> 0.F_Complex;
  assume z1" = z2";
  then z1'" = z2" by A1,Th7
    .= z2'" by A2,Th7;
  hence thesis by XCMPLX_1:202;
end;

theorem
  z2 <> 0.F_Complex & (z1 * z2 = 1.F_Complex or z2 * z1 = 1.F_Complex)
  implies z1 = z2"
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z2 <> 0.F_Complex;
  assume
A2: z1 * z2 = 1.F_Complex or z2 * z1 = 1.F_Complex;
  per cases by A2;
  suppose z1 * z2 = 1.F_Complex;
    then
A3: z1' * z2' = 1r by Def1;
    z2" = z2'" by A1,Th7;
    hence thesis by A1,A3,Th9,XCMPLX_0:def 7;
  end;
  suppose z2 * z1 = 1.F_Complex;
    then
A4: z2' * z1' = 1r by Def1;
    z2" = z2'" by A1,Th7;
    hence thesis by A1,A4,Th9,XCMPLX_0:def 7;
  end;
end;

theorem
  z2 <> 0.F_Complex & (z1 * z2 = z3 or z2 * z1 = z3) implies
  z1 = z3 * z2" & z1 = z2" * z3
proof
  reconsider z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z2 <> 0.F_Complex;
  assume
A2: (z1 * z2 = z3 or z2 * z1 = z3);
A3: z2" = z2'" by A1,Th7;
  per cases by A2;
  suppose z1 * z2 = z3;
    hence thesis by A1,A3,Th9,XCMPLX_1:204;
  end;
  suppose z2 * z1 = z3;
    hence thesis by A1,A3,Th9,XCMPLX_1:204;
  end;
end;

theorem
  (1.F_Complex)" = 1.F_Complex
proof
  1.F_Complex = 1r" by Def1;
  hence thesis by Th7;
end;

theorem
  z1 <> 0.F_Complex & z2 <> 0.F_Complex implies (z1 * z2)" = z1" * z2"
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z1 <> 0.F_Complex;
  assume
A2: z2 <> 0.F_Complex;
A3: z1" = z1'" by A1,Th7;
A4: z2" = z2'" by A2,Th7;
  z1 * z2 <> 0.F_Complex by A1,A2,VECTSP_1:44;
  hence (z1 * z2)" = (z1' * z2')" by Th7
    .= z1" * z2" by A3,A4,XCMPLX_1:205;
end;

canceled;

theorem
  z <> 0.F_Complex implies (-z)" = -(z")
proof
  reconsider z1=z as Element of COMPLEX by Def1;
  assume
A1: z <> 0.F_Complex;
  then
A2: z1" = z" by Th7;
A3: -z <> 0.F_Complex by A1,VECTSP_1:86;
  -z = -z1 by Th4;
  hence (-z)" = (-z1)" by A3,Th7
    .= -(z1") by XCMPLX_1:224
    .= -(z") by A2,Th4;
end;

canceled;

theorem
  z1 <> 0.F_Complex & z2 <> 0.F_Complex implies
  z1" + z2" = (z1 + z2) * (z1 * z2)"
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z1 <> 0.F_Complex;
  then
A2: z1" = z1'" by Th7;
  assume
A3: z2 <> 0.F_Complex;
  then
A4: z2" = z2'" by Th7;
  z1 * z2 <> 0.F_Complex by A1,A3,VECTSP_1:44;
  then (z1 * z2)" = (z1' * z2')" by Th7;
  hence thesis by A1,A2,A3,A4,Th9,XCMPLX_1:213;
end;

theorem
  z1 <> 0.F_Complex & z2 <> 0.F_Complex implies
  z1" - z2" = (z2 - z1) * (z1 * z2)"
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z1 <> 0.F_Complex;
  then
A2: z1" = z1'" by Th7;
  assume
A3: z2 <> 0.F_Complex;
  then
A4: z2" = z2'" by Th7;
A5: z2 - z1 = z2' - z1' by Th5;
  z1 * z2 <> 0.F_Complex by A1,A3,VECTSP_1:44;
  then
A6: (z1 * z2)" = (z1' * z2')" by Th7;
  thus z1" - z2" = z1'" - z2'" by A2,A4,Th5
    .= (z2 - z1) * (z1 * z2)" by A1,A3,A5,A6,Th9,XCMPLX_1:214;
end;

canceled;

theorem
  z <> 0.F_Complex implies z" = (1.F_Complex) / z
proof
  reconsider z1=z as Element of COMPLEX by Def1;
  assume
A1: z <> 0.F_Complex;
A2: 1.F_Complex = 1r by Def1;
  thus z" = z1" by A1,Th7
    .= 1r / z1 by XCMPLX_1:217
    .= (1.F_Complex) / z by A1,A2,Th8;
end;

theorem
  z / (1.F_Complex) = z
proof
  reconsider z1=z as Element of COMPLEX by Def1;
  1.F_Complex = 1r by Def1;
  hence z / (1.F_Complex) = z1 / 1r by Th8
    .= z;
end;

theorem
  z <> 0.F_Complex implies z / z = 1.F_Complex
proof
  reconsider z1=z as Element of COMPLEX by Def1;
  assume
A1: z <> 0.F_Complex;
  hence z / z = z1 / z1 by Th8
    .= 1r by A1,Th9,XCMPLX_1:60
    .= 1.F_Complex by Def1;
end;

theorem
  z <> 0.F_Complex implies (0.F_Complex) / z = 0.F_Complex by Th9;

theorem Th62:
  z2 <> 0.F_Complex & z1 / z2 = 0.F_Complex implies z1 = 0.F_Complex
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z2 <> 0.F_Complex;
  assume z1 / z2 = 0.F_Complex;
  then z1' / z2' = 0.F_Complex by A1,Th8;
  hence thesis by A1,Th9;
end;

theorem
  z2 <> 0.F_Complex & z4 <> 0.F_Complex implies
  (z1 / z2) * (z3 / z4) = (z1 * z3) / (z2 * z4)
proof
  reconsider z1'=z1,z2'=z2,z3'=z3,z4'=z4 as Element of COMPLEX by Def1;
  assume
A1: z2 <> 0.F_Complex;
  assume
A2: z4 <> 0.F_Complex;
  then
A3: z2 * z4 <> 0.F_Complex by A1,VECTSP_1:44;
A4: z1' / z2' = z1 / z2 by A1,Th8;
  z3' / z4' = z3 / z4 by A2,Th8;
  hence (z1 / z2) * (z3 / z4) = (z1' * z3') / (z2' * z4') by A4,XCMPLX_1:77
    .= (z1 * z3) / (z2 * z4) by A3,Th8;
end;

theorem
  z2 <> 0.F_Complex implies z * (z1 / z2) = (z * z1) / z2;

theorem
  z2 <> 0.F_Complex & z1 / z2 = 1.F_Complex implies z1 = z2
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z2 <> 0.F_Complex;
  assume z1 / z2 = 1.F_Complex;
  then z1' / z2' = 1.F_Complex by A1,Th8;
  then z1' / z2' = 1 by Def1;
  hence thesis by XCMPLX_1:58;
end;

theorem
  z <> 0.F_Complex implies z1 = (z1 * z) / z
proof
  reconsider z1'=z1,z'=z as Element of COMPLEX by Def1;
  assume
A1: z <> 0.F_Complex;
  hence z1 = (z1' * z') / z' by Th9,XCMPLX_1:90
    .= (z1 * z) / z by A1,Th8;
end;

theorem
  z1 <> 0.F_Complex & z2 <> 0.F_Complex implies (z1 / z2)" = z2 / z1
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z1 <> 0.F_Complex;
  assume
A2: z2 <> 0.F_Complex;
  then
A3: z1 / z2 <> 0.F_Complex by A1,Th62;
  z1' / z2' = z1 / z2 by A2,Th8;
  hence (z1 / z2)" = (z1' / z2')" by A3,Th7
    .= z2' / z1' by XCMPLX_1:215
    .= z2 / z1 by A1,Th8;
end;

theorem
  z1 <> 0.F_Complex & z2 <> 0.F_Complex implies (z1" / z2") = z2 / z1
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z1 <> 0.F_Complex;
  assume
A2: z2 <> 0.F_Complex;
A3: z1" = z1'" by A1,Th7;
A4: z2" = z2'" by A2,Th7;
  z2" <> 0.F_Complex by A2,VECTSP_1:74;
  hence (z1" / z2") = (z1'" / z2'") by A3,A4,Th8
    .= z2' / z1' by XCMPLX_1:216
    .= z2 / z1 by A1,Th8;
end;

theorem
  z2 <> 0.F_Complex implies z1 / z2" = z1 * z2
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z2 <> 0.F_Complex;
  then
A2: z2" <> 0.F_Complex by VECTSP_1:74;
  z2" = z2'" by A1,Th7;
  hence z1 / z2" = z1' / z2'" by A2,Th8
    .= z1 * z2 by XCMPLX_1:221;
end;

theorem
  z1 <> 0.F_Complex & z2 <> 0.F_Complex implies z1" / z2 = (z1 * z2)"
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z1 <> 0.F_Complex;
  assume
A2: z2 <> 0.F_Complex;
  then
A3: z1 * z2 <> 0.F_Complex by A1,VECTSP_1:44;
  z1" = z1'" by A1,Th7;
  hence z1" / z2 = z1'" / z2' by A2,Th8
    .= (z1' * z2')" by XCMPLX_1:223
    .= (z1 * z2)" by A3,Th7;
end;

theorem
  z1 <> 0.F_Complex & z2 <> 0.F_Complex implies z1"* (z / z2) = z / (z1 * z2)
proof
  reconsider z1'=z1,z2'=z2,z'=z as Element of COMPLEX by Def1;
  assume
A1: z1 <> 0.F_Complex;
  assume
A2: z2 <> 0.F_Complex;
  then
A3: z1 * z2 <> 0.F_Complex by A1,VECTSP_1:44;
A4: z1" = z1'" by A1,Th7;
  z' / z2' = z / z2 by A2,Th8;
  hence z1"* (z / z2) = z' / (z1' * z2') by A4,XCMPLX_1:222
    .= z / (z1 * z2) by A3,Th8;
end;

theorem
  z <> 0.F_Complex & z2 <> 0.F_Complex implies
  (z1 / z2) = (z1 * z) / (z2 * z) & (z1 / z2) = (z * z1) / (z * z2)
proof
  reconsider z1'=z1,z2'=z2,z'=z as Element of COMPLEX by Def1;
  assume
A1: z <> 0.F_Complex;
  assume
A2: z2 <> 0.F_Complex;
  then
A3: z2 * z <> 0.F_Complex by A1,VECTSP_1:44;
  thus (z1 / z2) = (z1' / z2') by A2,Th8
    .= (z1' * z') / (z2' * z') by A1,Th9,XCMPLX_1:92
    .= (z1 * z) / (z2 * z) by A3,Th8;
  hence thesis;
end;

theorem
  z2 <> 0.F_Complex & z3 <> 0.F_Complex implies z1 / (z2 * z3) = z1 / z2 / z3
proof
  reconsider z1'=z1,z2'=z2,z3'=z3 as Element of COMPLEX by Def1;
  assume
A1: z2 <> 0.F_Complex;
  assume
A2: z3 <> 0.F_Complex;
  then
A3: z2 * z3 <> 0.F_Complex by A1,VECTSP_1:44;
A4: z1 / z2 = z1' / z2' by A1,Th8;
  thus z1 / (z2 * z3) = z1' / (z2' * z3') by A3,Th8
    .= z1' / z2' / z3' by XCMPLX_1:79
    .= z1 / z2 / z3 by A2,A4,Th8;
end;

theorem
  z2 <> 0.F_Complex & z3 <> 0.F_Complex implies
  (z1 * z3) / z2 = z1 / (z2 / z3)
proof
  reconsider z1'=z1,z2'=z2,z3'=z3 as Element of COMPLEX by Def1;
  assume
A1: z2 <> 0.F_Complex;
  assume
A2: z3 <> 0.F_Complex;
  then
A3: z2 / z3 = z2' / z3' by Th8;
A4: z2 / z3 <> 0.F_Complex by A1,A2,Th62;
  thus (z1 * z3) / z2 = (z1' * z3') / z2' by A1,Th8
    .= z1' / (z2' / z3') by XCMPLX_1:78
    .= z1 / (z2 / z3) by A3,A4,Th8;
end;

theorem
  z2 <> 0.F_Complex & z3 <> 0.F_Complex & z4 <> 0.F_Complex implies
  (z1 / z2) / (z3 / z4) = (z1 * z4) / (z2 * z3)
proof
  reconsider z1'=z1,z2'=z2,z3'=z3,z4'=z4 as Element of COMPLEX by Def1;
  assume
A1: z2 <> 0.F_Complex;
  assume
A2: z3 <> 0.F_Complex;
  assume
A3: z4 <> 0.F_Complex;
A4: z2 * z3 <> 0.F_Complex by A1,A2,VECTSP_1:44;
A5: z1 / z2 = z1' / z2' by A1,Th8;
A6: z3 / z4 = z3' / z4' by A3,Th8;
  z3 / z4 <> 0.F_Complex by A2,A3,Th62;
  hence (z1 / z2) / (z3 / z4) = (z1' / z2') / (z3' / z4') by A5,A6,Th8
    .= (z1' * z4') / (z2' * z3') by XCMPLX_1:85
    .= (z1 * z4) / (z2 * z3) by A4,Th8;
end;

theorem
  z2 <> 0.F_Complex & z4 <> 0.F_Complex implies
  z1 / z2 + z3 / z4 = (z1 * z4 + z3 * z2) / (z2 * z4)
proof
  reconsider z1'=z1,z2'=z2,z3'=z3,z4'=z4 as Element of COMPLEX by Def1;
  assume
A1: z2 <> 0.F_Complex;
  assume
A2: z4 <> 0.F_Complex;
  then
A3: z2 * z4 <> 0.F_Complex by A1,VECTSP_1:44;
A4: z1 / z2 = z1' / z2' by A1,Th8;
  z3 / z4 = z3' / z4' by A2,Th8;
  hence z1 / z2 + z3 / z4 = (z1' * z4' + z3' * z2') / (z2' * z4') by A1,A2,A4,
  Th9,XCMPLX_1:117
    .= (z1 * z4 + z3 * z2) / (z2 * z4) by A3,Th8;
end;

theorem
  z <> 0.F_Complex implies z1 / z + z2 / z = (z1 + z2) / z;

theorem
  z2 <> 0.F_Complex implies -(z1 / z2) = (-z1) / z2 & -(z1 / z2) = z1 / (-z2)
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
A1: -z1 = -z1' by Th4;
A2: -z2 = -z2' by Th4;
  assume
A3: z2 <> 0.F_Complex;
  then
A4: -z2 <> 0.F_Complex by VECTSP_1:86;
  z1 / z2 = z1' / z2' by A3,Th8;
  hence -(z1 / z2) = -(z1' / z2') by Th4
    .= (-z1') / z2' by XCMPLX_1:188
    .= (-z1) / z2 by A1,A3,Th8;
  z1 / z2 = z1' / z2' by A3,Th8;
  hence -(z1 / z2) = -(z1' / z2') by Th4
    .= z1' / -(z2') by XCMPLX_1:189
    .= z1 / -z2 by A2,A4,Th8;
end;

theorem
  z2 <> 0.F_Complex implies z1 / z2 = (-z1) / (-z2)
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z2 <> 0.F_Complex;
  then
A2: -z2 <> 0.F_Complex by VECTSP_1:86;
A3: -z1' = -z1 & -z2' = -z2 by Th4;
  thus z1 / z2 = z1' / z2' by A1,Th8
    .= (-z1') / (-z2') by XCMPLX_1:192
    .= (-z1) / (-z2) by A2,A3,Th8;
end;

theorem
  z2 <> 0.F_Complex & z4 <> 0.F_Complex implies
  z1 / z2 - z3 / z4 = (z1 * z4 - z3 * z2) / (z2 * z4)
proof
  reconsider z1'=z1,z2'=z2,z3'=z3,z4'=z4 as Element of COMPLEX by Def1;
  assume
A1: z2 <> 0.F_Complex;
  assume
A2: z4 <> 0.F_Complex;
  then
A3: z1' / z2' = z1 / z2 & z3' / z4' = z3 / z4 by A1,Th8;
A4: z2 * z4 <> 0.F_Complex by A1,A2,VECTSP_1:44;
A5: z1 * z4 - z3 * z2 = z1' * z4' - z3' * z2' by Th5;
  thus z1 / z2 - z3 / z4 = z1' / z2' - z3' / z4' by A3,Th5
    .= (z1' * z4' - z3' * z2') / (z2' * z4') by A1,A2,Th9,XCMPLX_1:131
    .= (z1 * z4 - z3 * z2) / (z2 * z4) by A4,A5,Th8;
end;

theorem
  z <> 0.F_Complex implies z1 / z - z2 / z = (z1 - z2) / z
proof
  reconsider z'=z,z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z <> 0.F_Complex;
A2: z1' - z2' = z1 - z2 by Th5;
  z1' / z' = z1 / z & z2' / z' = z2 / z by A1,Th8;
  hence z1 / z - z2 / z = z1' / z' - z2' / z' by Th5
    .= (z1' - z2') / z' by XCMPLX_1:121
    .= (z1 - z2) / z by A1,A2,Th8;
end;

theorem
  z2 <> 0.F_Complex & (z1 * z2 = z3 or z2 * z1 = z3) implies z1 = z3 / z2
proof
  reconsider z3'=z3,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z2 <> 0.F_Complex;
  assume
A2: z1 * z2 = z3 or z2 * z1 = z3;
  per cases by A2;
  suppose z1 * z2 = z3;
    hence z1 = z3' / z2' by A1,Th9,XCMPLX_1:90
      .= z3 / z2 by A1,Th8;
  end;
  suppose z2 * z1 = z3;
    hence z1 = z3' / z2' by A1,Th9,XCMPLX_1:90
      .= z3 / z2 by A1,Th8;
  end;
end;

theorem
  (0.F_Complex)*' = 0.F_Complex
proof
  0.F_Complex = 0c by Def1;
  hence thesis by COMPLEX1:113;
end;

theorem Th84:
  z*' = 0.F_Complex implies z = 0.F_Complex
proof
  assume z*' = 0.F_Complex;
  then z*' = 0c by Def1;
  then z = 0c by COMPLEX1:114;
  hence thesis by Def1;
end;

theorem
  (1.F_Complex)*' = 1.F_Complex
proof
  1.F_Complex = 1r by Def1;
  hence thesis by COMPLEX1:115;
end;

theorem
  z*'*' = z;

theorem
  (z1 + z2)*' = z1*' + z2*' by COMPLEX1:118;

theorem
  (-z)*' = -(z*')
proof
  reconsider z'=z as Element of COMPLEX by Def1;
  -z = -z' by Th4;
  hence (-z)*' = -(z'*') by COMPLEX1:119
    .= -(z*') by Th4;
end;

theorem
  (z1 - z2)*' = z1*' - z2*'
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  z1' - z2' = z1 - z2 by Th5;
  hence (z1 - z2)*' = z1'*' - z2'*' by COMPLEX1:120
    .= z1*' - z2*' by Th5;
end;

theorem
  (z1 * z2)*' = z1*' * z2*' by COMPLEX1:121;

theorem
  z <> 0.F_Complex implies z"*' = z*'"
proof
  reconsider z1=z as Element of COMPLEX by Def1;
  assume
A1: z <> 0.F_Complex;
  then
A2: z*' <> 0.F_Complex by Th84;
  z" = z1" by A1,Th7;
  hence z"*' = z1*'" by COMPLEX1:122
    .= z*'" by A2,Th7;
end;

theorem
  z2 <> 0.F_Complex implies (z1 / z2)*' = (z1*') / (z2*')
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume
A1: z2 <> 0.F_Complex;
  then
A2: z2*' <> 0.F_Complex by Th84;
  z1' / z2' = z1 / z2 by A1,Th8;
  hence (z1 / z2)*' = (z1'*') / (z2'*') by COMPLEX1:123
    .= (z1*') / (z2*') by A2,Th8;
end;

theorem
  |.0.F_Complex.| = 0 by Def1,COMPLEX1:130;

theorem
  |.z.| = 0 implies z = 0.F_Complex by Th9,COMPLEX1:131;

canceled;

theorem
  z <> 0.F_Complex iff 0 < |.z.| by Th9,COMPLEX1:133;

theorem
  |.1.F_Complex.| = 1 by Def1,COMPLEX1:134;

theorem
  |.-z.| = |.z.|
proof
  reconsider z1=z as Element of COMPLEX by Def1;
  -z1 = -z by Th4;
  hence thesis by COMPLEX1:138;
end;

canceled;

theorem
  |.z1 + z2.| <= |.z1.| + |.z2.| by COMPLEX1:142;

theorem
  |.z1 - z2.| <= |.z1.| + |.z2.|
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  z1' - z2' = z1 - z2 by Th5;
  hence thesis by COMPLEX1:143;
end;

theorem
  |.z1.| - |.z2.| <= |.z1 + z2.| by COMPLEX1:144;

theorem
  |.z1.| - |.z2.| <= |.z1 - z2.|
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  z1' - z2' = z1 - z2 by Th5;
  hence thesis by COMPLEX1:145;
end;

theorem
  |.z1 - z2.| = |.z2 - z1.|
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
A1: z2' - z1' = z2 - z1 by Th5;
  z1' - z2' = z1 - z2 by Th5;
  hence thesis by A1,COMPLEX1:146;
end;

theorem
  |.z1 - z2.| = 0 iff z1 = z2
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  thus |.z1 - z2.| = 0 implies z1 = z2
  proof
    assume
A1: |.z1 - z2.| = 0;
    z1 - z2 = z1' - z2' by Th5;
    hence thesis by A1,COMPLEX1:147;
  end;
A2: z1' - z2' = z1 - z2 by Th5;
  assume z1 = z2;
  hence thesis by A2,COMPLEX1:147;
end;

theorem
  z1 <> z2 iff 0 < |.z1 - z2.|
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  thus z1 <> z2 implies 0 < |.z1 - z2.|
  proof
    assume
A1: z1 <> z2;
    z1 - z2 = z1' - z2' by Th5;
    hence thesis by A1,COMPLEX1:148;
  end;
  assume
A2: 0 < |.z1 - z2.|;
  z1 - z2 = z1' - z2' by Th5;
  hence thesis by A2,COMPLEX1:148;
end;

theorem
  |.z1 - z2.| <= |.z1 - z.| + |.z - z2.|
proof
  reconsider z'=z,z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
A1: |.z1' - z2'.| = |.z1 - z2.| by Th5;
A2: |.z1' - z'.| = |.z1 - z.| by Th5;
  z' - z2' = z - z2 by Th5;
  hence thesis by A1,A2,COMPLEX1:149;
end;

theorem
  abs(|.z1.| - |.z2.|) <= |.z1 - z2.|
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  z1' - z2' = z1 - z2 by Th5;
  hence thesis by COMPLEX1:150;
end;

theorem
  |.z1*z2.| = |.z1.|*|.z2.| by COMPLEX1:151;

theorem
  z <> 0.F_Complex implies |.z".| = |.z.|"
proof
  reconsider z1=z as Element of COMPLEX by Def1;
  assume z <> 0.F_Complex;
  then z" = z1" by Th7;
  hence thesis by COMPLEX1:152;
end;

theorem
  z2 <> 0.F_Complex implies |.z1.| / |.z2.| = |.z1 / z2.|
proof
  reconsider z1'=z1,z2'=z2 as Element of COMPLEX by Def1;
  assume z2 <> 0.F_Complex;
  then z1' / z2' = z1 / z2 by Th8;
  hence thesis by COMPLEX1:153;
end;

begin :: Addenda

:: from COMPTRIG, 2006.08.12, A.T.

scheme Regrwithout0 { P[Nat] } : P[1]
provided
A1: ex k be non empty Element of NAT st P[k]
and
A2: for k be non empty Element of NAT st k <> 1 & P[k]
ex n be non empty Element of NAT st n < k & P[n]
proof
  defpred R[Nat] means P[$1+1];
  consider t be non empty Element of NAT such that
A3: P[t] by A1;
  consider s be Nat such that
A4: t = s+1 by NAT_1:6;
A5: ex k be Nat st R[k] by A3,A4;
A6: now
    let k be Nat;
    assume that
A7: k <> 0 and
A8: R[k];
    reconsider k1=k+1 as non empty Element of NAT;
    k > 0 by A7,NAT_1:3;
    then k+1 > 0+1 by XREAL_1:8;
    then consider n be non empty Element of NAT such that
A9: n < k1 and
A10: P[n] by A2,A8;
    consider l be Nat such that
A11: n = l+1 by NAT_1:6;
    take l;
    thus l < k by A9,A11,XREAL_1:8;
    thus R[l] by A10,A11;
  end;
  R[0] from NAT_1:sch 7(A5,A6);
  hence thesis;
end;

theorem Th112:
  for e being Element of F_Complex, n be non empty Nat
  holds (power F_Complex).(e,n) = e|^n
proof
  let e be Element of F_Complex;
  defpred P[Nat] means (power F_Complex).(e,$1) = e|^$1;
  (power F_Complex).(e,1) = e by GROUP_1:98;
  then
A1: P[1] by NEWTON:10;
A2: now
    let n be non empty Nat;
    reconsider n' = n as Element of NAT by ORDINAL1:def 13;
    reconsider p = (power F_Complex).(e,n') as Element of F_Complex;
    assume
A3: P[n];
    (power F_Complex).(e,n+1) = p*e by GROUP_1:def 8
      .= e|^(n+1) by A3,NEWTON:11;
    hence P[n+1];
  end;
  thus for n being non empty Nat holds P[n] from NAT_1:sch 10(A1,A2);
end;

definition
  let x be Element of F_Complex;
  let n be non empty Element of NAT;
  redefine
  mode CRoot of n,x -> Element of F_Complex means
    :Def2:
    (power F_Complex).(it,n) = x;
  coherence
  proof
    let e be CRoot of n,x;
    e is Element of COMPLEX by XCMPLX_0:def 2;
    hence thesis by Def1;
  end;
  compatibility
  proof
    let e be Element of F_Complex;
    thus e is CRoot of n,x implies (power F_Complex).(e,n) = x
    proof
      assume e is CRoot of n,x;
      then e|^n = x by COMPTRIG:def 2;
      hence thesis by Th112;
    end;
    assume (power F_Complex).(e,n) = x;
    hence e|^n = x by Th112;
  end;
end;

theorem
  for x be Element of F_Complex for v be CRoot of 1,x holds v = x
proof
  let x be Element of F_Complex;
  let v be CRoot of 1,x;
  (power F_Complex).(v,1) = x by Def2;
  hence thesis by GROUP_1:98;
end;

theorem
  for n be non empty Element of NAT for v be CRoot of n,0.F_Complex holds
  v = 0.F_Complex
proof
  let n be non empty Element of NAT;
  let v be CRoot of n,0.F_Complex;
  defpred P[Element of NAT] means (power F_Complex).(v,$1) = 0.F_Complex;
A1: ex n be non empty Element of NAT st P[n]
  proof
    take n;
    thus thesis by Def2;
  end;
A2: now
    let k be non empty Element of NAT;
    assume that
A3: k <> 1 and
A4: P[k];
    consider t be Nat such that
A5: k = t+1 by NAT_1:6;
    reconsider t as Element of NAT by ORDINAL1:def 13;
    reconsider t as non empty Element of NAT by A3,A5;
    take t;
    thus t < k by A5,NAT_1:13;
    (power F_Complex).(v,k) = (power F_Complex).(v,t)*v by A5,GROUP_1:def 8;
    then (power F_Complex).(v,t) = 0.F_Complex or v = 0.F_Complex
    by A4,VECTSP_1:44;
    hence P[t] by NAT_1:3,VECTSP_1:95;
  end;
  P[1] from Regrwithout0(A1,A2);
  hence thesis by GROUP_1:98;
end;

theorem
  for n be non empty Element of NAT for x be Element of F_Complex
  for v be CRoot of n,x st v = 0.F_Complex holds x = 0.F_Complex
proof
  let n be non empty Element of NAT;
  let x be Element of F_Complex;
  let v be CRoot of n,x;
  assume v = 0.F_Complex;
  then (power F_Complex).(0.F_Complex,n) = x by Def2;
  hence thesis by NAT_1:3,VECTSP_1:95;
end;

