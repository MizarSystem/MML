:: Conditional branch macro instructions of SCM+FSA, Part II
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies AMI_1, SCMFSA_2, BOOLE, AMI_3, SCMFSA6A, AMI_5, RELOC, CARD_1,
      FUNCT_4, RELAT_1, UNIALG_2, FUNCT_1, SCMFSA6C, SF_MASTR, FUNCT_7,
      SCMFSA7B, SCMFSA6B, SCMFSA8A, SCM_1, AMI_2, ARYTM_1, NAT_1, ABSVALUE,
      FINSEQ_1, FINSEQ_2, SCMFSA8B, FINSEQ_4, ARYTM, AMISTD_2;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, NAT_1, INT_1,
      RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7, FINSEQ_1, FINSEQ_2,
      STRUCT_0, AMI_1, SCMNORM, SCMFSA_2, SCMFSA_4, SCMFSA_5, SCMFSA6A,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, INT_2, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, NAT_1, INT_2, SCMFSA_5, PARTFUN1, SCMFSA6A,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMNORM, SCMFSA_4, RELSET_1;
 registrations SETFAM_1, RELAT_1, FUNCT_1, FRAENKEL, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, CARD_3, AMI_1, SCMFSA_2, SF_MASTR, SCMFSA6B,
      SCMFSA6C, ORDINAL1, XBOOLE_0, SCMNORM, FINSEQ_1, FINSET_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, AMI_1, SCMFSA_2, SCMNORM;
 theorems TARSKI, NAT_1, FUNCT_1, FUNCT_4, AMI_1, SCMFSA_2, SCMFSA_4, SCMFSA_5,
      SCMFSA6A, GRFUNC_1, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A,
      RELAT_1, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0;
 schemes NAT_1;

begin
set A = NAT;
set D = Int-Locations \/ FinSeq-Locations;

Lm1: for I,J being Program of SCM+FSA holds
ProgramPart Relocated(J,card I) c= I ';' J
proof
  let I,J be Program of SCM+FSA;
  I ';' J = Directed I +* ProgramPart Relocated(J,card I) by SCMFSA6A:def 5;
  hence thesis by FUNCT_4:26;
end;

theorem  ::TA7(@BBB8)
  for s being State of SCM+FSA holds IC SCM+FSA in dom s
proof
  let s be State of SCM+FSA;
  dom s = D \/ {IC SCM+FSA} \/ A by SCMFSA6A:34;
  then
A1: {IC SCM+FSA} c= dom s by XBOOLE_1:7,11;
  IC SCM+FSA in {IC SCM+FSA} by TARSKI:def 1;
  hence thesis by A1;
end;

theorem Th2: ::TA8(@BBB8)
  for s being State of SCM+FSA, l being Instruction-Location of SCM+FSA holds
  l in dom s
proof
  let s be State of SCM+FSA;
  let l be Instruction-Location of SCM+FSA;
  dom s = D \/ {IC SCM+FSA} \/ A by SCMFSA6A:34;
  then
A1: A c= dom s by XBOOLE_1:7;
  l in A by AMI_1:def 4;
  hence thesis by A1;
end;

theorem Th3: ::BBBB'53
  for I being Program of SCM+FSA, s being State of SCM+FSA st I is_closed_on s
  holds insloc 0 in dom I
proof
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  assume
A1: I is_closed_on s;
A2: IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
  IC  Computation( (s +* (I +* Start-At insloc 0)),0)
  = (s +* (I +* Start-At insloc 0)).IC SCM+FSA by AMI_1:13
    .= (I +* Start-At insloc 0).IC SCM+FSA by A2,FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
  hence thesis by A1,SCMFSA7B:def 7;
end;

canceled;

theorem Th5: ::TI1 <> PRE8'82'
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  DataPart Initialize s = DataPart(s +* Initialized I)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
A1: now
    let a be Int-Location;
    per cases;
    suppose
A2:   intloc 0 = a;
      then a in dom Initialized I by SCMFSA6A:45;
      hence s1.a = (Initialized I).intloc 0 by A2,FUNCT_4:14
        .= 1 by SCMFSA6A:46
        .= (Initialize s).a by A2,SCMFSA6C:3;
    end;
    suppose
A3:   intloc 0 <> a;
      then
A4:   a is read-write by SF_MASTR:def 5;
      a in dom s & not a in dom Initialized I by A3,SCMFSA6A:48,SCMFSA_2:66;
      hence s1.a = s.a by FUNCT_4:12
        .= (Initialize s).a by A4,SCMFSA6C:3;
    end;
  end;
  now
    let f be FinSeq-Location;
    f in dom s & not f in dom Initialized I by SCMFSA6A:49,SCMFSA_2:67;
    hence s1.f = s.f by FUNCT_4:12
      .= (Initialize s).f by SCMFSA6C:3;
  end;
  hence thesis by A1,SCMFSA6A:38;
end;

theorem Th6: ::T8'
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
  DataPart s1 = DataPart s2 holds
  I is_closed_on s1 implies I is_closed_on s2
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set S1 = s1 +* (I +* Start-At insloc 0),
      S2 = s2 +* (I +* Start-At insloc 0);
  assume
A1: DataPart s1 = DataPart s2;
  assume
A2: I is_closed_on s1;
  defpred P[Element of NAT] means
   IC  Computation(S1,$1) = IC  Computation(S2,$1) &
  CurInstr  Computation(S1,$1) = CurInstr  Computation(S2,$1) &
   DataPart Computation(S1,$1) =  DataPart Computation(S2,$1);
A3: IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
A4:  Computation(S1,0) = s1 +* (I +* Start-At insloc 0) &
   Computation(S2,0) = s2 +* (I +* Start-At insloc 0) by AMI_1:13;
  then
A5: IC  Computation(S1,0) = (I +* Start-At insloc 0).IC SCM+FSA
 by A3,FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A6: IC  Computation(S2,0) = (I +* Start-At insloc 0).IC SCM+FSA
 by A3,A4,FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A7: I c= I +* Start-At insloc 0 by SCMFSA8A:9;
  then
A8: dom I c= dom (I +* Start-At insloc 0) by GRFUNC_1:8;
A9: insloc 0 in dom I by A2,Th3;
  then
A10: CurInstr  Computation(S1,0) = (I +* Start-At insloc 0).insloc 0
 by A4,A5,A8,FUNCT_4:14
    .= CurInstr  Computation(S2,0) by A4,A6,A8,A9,FUNCT_4:14;
    DataPart Computation(S1,0) = DataPart s1 by A4,SCMFSA8A:11
    .= DataPart Computation(S2,0) by A1,A4,SCMFSA8A:11;
  then
A11: P[0] by A5,A6,A10;
A12: now
    let k be Element of NAT;
    assume
A13: P[k];
    then (for a being Int-Location holds
     Computation(S1,k).a =  Computation(S2,k).a) &
    for f being FinSeq-Location holds
     Computation(S1,k).f =  Computation(S2,k).f
     by SCMFSA6A:38;
    then
A14:  Computation(S1,k), Computation(S2,k) equal_outside A by A13,SCMFSA6A:28;
    I +* Start-At insloc 0 c= s1 +* (I +* Start-At insloc 0) &
    I +* Start-At insloc 0 c= s2 +* (I +* Start-At insloc 0) by FUNCT_4:26;
    then I c= s1 +* (I +* Start-At insloc 0) &
    I c= s2 +* (I +* Start-At insloc 0) by A7,XBOOLE_1:1;
    then
A15: I c=  Computation(S1,k+1) & I c=  Computation(S2,k+1) by AMI_1:81;
A16:  Computation(S1,k+1) = Following  Computation(S1,k) by AMI_1:14
      .= Exec(CurInstr  Computation(S1,k), Computation(S1,k));
    thus P[k+1]
    proof
A17:   Computation(S2,k+1) = Following  Computation(S2,k) by AMI_1:14
        .= Exec(CurInstr  Computation(S2,k), Computation(S2,k));
      hence
A18:  IC  Computation(S1,k+1) = IC  Computation(S2,k+1)
 by A13,A14,A16,AMI_1:121,SCMFSA6A:32;
A19:  IC  Computation(S1,k+1) in dom I by A2,SCMFSA7B:def 7;
      hence CurInstr  Computation(S1,k+1) = I.IC  Computation(S1,k+1)
       by A15,GRFUNC_1:8
        .= CurInstr  Computation(S2,k+1) by A15,A18,A19,GRFUNC_1:8;
      thus thesis
       by A13,A14,A16,A17,SCMFSA6A:32,39;
    end;
  end;
  now
    let k be Element of NAT;
A20: IC  Computation(S1,k) in dom I by A2,SCMFSA7B:def 7;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A11,A12);
    hence IC  Computation(S2,k) in dom I by A20;
  end;
  hence thesis by SCMFSA7B:def 7;
end;

theorem Th7: ::TQ40'
  for s1,s2 being State of SCM+FSA, I,J being Program of SCM+FSA holds
  DataPart s1 = DataPart s2 implies
  s1 +* (I +* Start-At insloc 0),s2 +* (J +* Start-At insloc 0)
  equal_outside NAT
proof
  let s1,s2 be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  assume
A1: DataPart s1 = DataPart s2;
  set S1 = s1 +* (I +* Start-At insloc 0);
  set S2 = s2 +* (J +* Start-At insloc 0);
A2: DataPart S1 = DataPart s1 by SCMFSA8A:11
    .= DataPart S2 by A1,SCMFSA8A:11;
  IC S1 = insloc 0 & IC S2 = insloc 0 by FUNCT_4:26,SF_MASTR:67;
  hence thesis by A2,SCMFSA8A:6;
end;

theorem Th8: ::TQ38' <> T8'
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA
  st DataPart s1 = DataPart s2 holds
  I is_closed_on s1 & I is_halting_on s1 implies
  I is_closed_on s2 & I is_halting_on s2
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set S1 = s1 +* (I +* Start-At insloc 0),
      S2 = s2 +* (I +* Start-At insloc 0);
  assume
A1: DataPart s1 = DataPart s2;
  assume
A2: I is_closed_on s1;
  assume I is_halting_on s1;
  then s1 +* (I +* Start-At insloc 0) is halting by SCMFSA7B:def 8;
  then consider m being Element of NAT such that
A3: CurInstr  Computation(S1,m) = halt SCM+FSA by AMI_1:def 20;
  defpred P[Element of NAT] means
   IC  Computation(S1,$1) = IC  Computation(S2,$1) &
  CurInstr  Computation(S1,$1) = CurInstr  Computation(S2,$1) &
  DataPart Computation(S1,$1) = DataPart Computation(S2,$1);
A4: IC SCM+FSA in {IC SCM+FSA} & {IC SCM+FSA} = dom Start-At insloc 0
  by FUNCOP_1:19,TARSKI:def 1;
  Start-At insloc 0 c= I +* Start-At insloc 0 by FUNCT_4:26;
  then
A5: dom Start-At insloc 0 c= dom (I +* Start-At insloc 0) by GRFUNC_1:8;
A6:  Computation(S1,0) = s1 +* (I +* Start-At insloc 0) &
   Computation(S2,0) = s2 +* (I +* Start-At insloc 0) by AMI_1:13;
  then
A7: IC  Computation(S1,0) = (I +* Start-At insloc 0).IC SCM+FSA
 by A4,A5,FUNCT_4:14
    .= (Start-At insloc 0).IC SCM+FSA by A4,FUNCT_4:14
    .= insloc 0 by FUNCOP_1:87;
A8: IC  Computation(S2,0) = (I +* Start-At insloc 0).IC SCM+FSA
 by A4,A5,A6,FUNCT_4:14
    .= (Start-At insloc 0).IC SCM+FSA by A4,FUNCT_4:14
    .= insloc 0 by FUNCOP_1:87;
A9: I c= (I +* Start-At insloc 0) by SCMFSA8A:9;
  then
A10: dom I c= dom (I +* Start-At insloc 0) by GRFUNC_1:8;
A11: insloc 0 in dom I by A2,Th3;
  then
A12: CurInstr  Computation(S1,0) = (I +* Start-At insloc 0).insloc 0
 by A6,A7,A10,FUNCT_4:14
    .= CurInstr  Computation(S2,0) by A6,A8,A10,A11,FUNCT_4:14;
   Computation(S1,0), Computation(S2,0) equal_outside A by A1,A6,Th7;
  then
A13: P[0] by A7,A8,A12,SCMFSA6A:39;
A14: now
    let k be Element of NAT;
    assume
A15: P[k];
    then (for a being Int-Location holds
     Computation(S1,k).a =  Computation(S2,k).a) &
    for f being FinSeq-Location holds
     Computation(S1,k).f =  Computation(S2,k).f
     by SCMFSA6A:38;
    then
A16:  Computation(S1,k), Computation(S2,k) equal_outside A by A15,SCMFSA6A:28;
    (I +* Start-At insloc 0) c= s1 +* (I +* Start-At insloc 0) &
    (I +* Start-At insloc 0) c= s2 +* (I +* Start-At insloc 0) by FUNCT_4:26;
    then I c= s1 +* (I +* Start-At insloc 0) &
    I c= s2 +* (I +* Start-At insloc 0) by A9,XBOOLE_1:1;
    then
A17: I c=  Computation(S1,k+1) & I c=  Computation(S2,k+1) by AMI_1:81;
A18:  Computation(S1,k+1) = Following  Computation(S1,k) by AMI_1:14
      .= Exec(CurInstr  Computation(S1,k), Computation(S1,k));
    thus P[k+1]
    proof
A19:   Computation(S2,k+1) = Following  Computation(S2,k) by AMI_1:14
        .= Exec(CurInstr  Computation(S2,k), Computation(S2,k));
      hence
A20:  IC  Computation(S1,k+1) = IC  Computation(S2,k+1)
 by A15,A16,A18,AMI_1:121,SCMFSA6A:32;
A21:  IC  Computation(S1,k+1) in dom I by A2,SCMFSA7B:def 7;
      hence CurInstr  Computation(S1,k+1) = I.IC  Computation(S1,k+1)
       by A17,GRFUNC_1:8
        .= CurInstr  Computation(S2,k+1) by A17,A20,A21,GRFUNC_1:8;
      thus thesis
       by A15,A16,A18,A19,SCMFSA6A:32,39;
    end;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A13,A14);
  then CurInstr  Computation(S2,m) = halt SCM+FSA by A3;
  then
A22: s2 +* (I +* Start-At insloc 0) is halting by AMI_1:def 20;
  now
    let k be Element of NAT;
A23: IC  Computation(S1,k) in dom I by A2,SCMFSA7B:def 7;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A13,A14);
    hence IC  Computation(S2,k) in dom I by A23;
  end;
  hence I is_closed_on s2 by SCMFSA7B:def 7;
  thus thesis by A22,SCMFSA7B:def 8;
end;

theorem Th9: ::T61''
  for s being State of SCM+FSA, I,J being Program of SCM+FSA holds
  I is_closed_on Initialize s iff I is_closed_on s +* Initialized J
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  DataPart Initialize s = DataPart(s +* Initialized J) by Th5;
  hence thesis by Th6;
end;

theorem Th10: ::TI11 <> T61
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  l being Instruction-Location of SCM+FSA holds
  I is_closed_on s iff I is_closed_on s +* (I +* Start-At l)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let l be Instruction-Location of SCM+FSA;
  DataPart s = DataPart(s +* (I +* Start-At l)) by SCMFSA8A:11;
  hence thesis by Th6;
end;

theorem Th11: ::PRE8'115'(@AAAA)
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA
  st I +* Start-At insloc 0 c= s1 & I is_closed_on s1
  for n being Element of NAT st ProgramPart Relocated(I,n) c= s2 &
  IC s2 = insloc n & DataPart s1 = DataPart s2
   for i being Element of NAT holds
  IC  Computation( s1,i) + n = IC  Computation( s2,i) &
  IncAddr(CurInstr ( Computation( s1,i)),n) = CurInstr ( Computation( s2,i)) &
  DataPart Computation( s1,i) = DataPart Computation( s2,i)
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: I +* Start-At insloc 0 c= s1;
  assume
A2: I is_closed_on s1;
  let n be Element of NAT;
  assume
A3: ProgramPart Relocated(I,n) c= s2;
  assume
A4: IC s2 = insloc n;
  assume
A5: DataPart s1 = DataPart s2;
  let i be Element of NAT;
  defpred P[Element of NAT] means
   IC  Computation(s1,$1) + n = IC  Computation(s2,$1) &
  IncAddr(CurInstr ( Computation(s1,$1)),n) = CurInstr ( Computation(s2,$1)) &
  DataPart Computation(s1,$1) = DataPart Computation(s2,$1);
A6: P[0]
  proof
A7: IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
    IC  Computation(s1,0) = s1.IC SCM+FSA by AMI_1:13
      .= (I +* Start-At insloc 0).IC SCM+FSA by A1,A7,GRFUNC_1:8
      .= insloc 0 by SF_MASTR:66;
    hence IC  Computation(s1,0) + n = IC  Computation(s2,0) by A4,AMI_1:13;
A8: I c= I +* Start-At insloc 0 by SCMFSA8A:9;
    then
A9: dom I c= dom (I +* Start-At insloc 0) by GRFUNC_1:8;
A10: insloc 0 in dom I by A2,Th3;
    IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
    then
A11: s1.IC s1 = s1.((I +* Start-At insloc 0).IC SCM+FSA) by A1,GRFUNC_1:8
      .= s1.insloc 0 by SF_MASTR:66
      .= (I +* Start-At insloc 0).insloc 0 by A1,A9,A10,GRFUNC_1:8
      .= I.insloc 0 by A8,A10,GRFUNC_1:8;
    insloc 0 + n in dom Relocated(I,n) by A10,SCMFSA_5:4;
    then
A12: insloc (0 + n) in dom ProgramPart Relocated(I,n) by AMI_1:106;
    ProgramPart I = I by AMI_1:105;
    then
A13: insloc 0 in dom ProgramPart I by A2,Th3;
    thus IncAddr(CurInstr ( Computation(s1,0)),n) = IncAddr(CurInstr s1,n)
     by AMI_1:13
      .= Relocated(I,n).(insloc 0 + n) by A11,A13,SCMFSA_5:7
      .= (ProgramPart Relocated(I,n)).insloc n by FUNCT_1:72
      .= CurInstr s2 by A3,A4,A12,GRFUNC_1:8
      .= CurInstr ( Computation(s2,0)) by AMI_1:13;
    thus DataPart Computation(s1,0) = DataPart s2 by A5,AMI_1:13
      .= DataPart Computation(s2,0) by AMI_1:13;
  end;
A15: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A16: P[k];
A17:  Computation(s1,k+1) = Following  Computation(s1,k) by AMI_1:14
      .= Exec(CurInstr  Computation(s1,k), Computation(s1,k));
A18:  Computation(s2,k+1) = Following  Computation(s2,k) by AMI_1:14
      .= Exec(CurInstr  Computation(s2,k), Computation(s2,k));
    hence
A19: IC  Computation(s1,k+1) + n = IC  Computation(s2,k+1)
 by A16,A17,SCMFSA6A:41;
    reconsider j = CurInstr  Computation(s1,k+1) as Instruction of SCM+FSA;
    reconsider l = IC  Computation(s1,k+1) as Element of NAT
     by ORDINAL1:def 13;
A20: I c= I +* Start-At insloc 0 by SCMFSA8A:9;
    then
A21: dom I c= dom (I +* Start-At insloc 0) by GRFUNC_1:8;
    s1 +* (I +* Start-At insloc 0) = s1 by A1,FUNCT_4:79;
    then
A22: IC  Computation(s1,k+1) in dom I by A2,SCMFSA7B:def 7;
A24: IC  Computation(s2,k+1) in NAT by AMI_1:def 4;
    dom ProgramPart I = dom I /\ NAT by RELAT_1:90;
    then
A25: l in dom ProgramPart I by A22,XBOOLE_0:def 4;
A26: j = s1.IC  Computation(s1,k+1) by AMI_1:54
      .= (I +* Start-At insloc 0).IC  Computation(s1,k+1)
       by A1,A21,A22,GRFUNC_1:8
      .= I.l by A20,A22,GRFUNC_1:8;
    IC  Computation(s2,k+1) in dom Relocated(I,n) by A19,A22,SCMFSA_5:4;
    then IC  Computation(s2,k+1) in dom Relocated(I,n) /\ NAT
     by A24,XBOOLE_0:def 4;
    then
A27: IC  Computation(s2,k+1) in dom ProgramPart Relocated(I,n) by RELAT_1:90;
    thus IncAddr(CurInstr  Computation(s1,k+1),n)
    = Relocated(I,n).(l + n) by A25,A26,SCMFSA_5:7
      .= (ProgramPart Relocated(I,n)).(IC  Computation(s2,k+1))
       by A19,FUNCT_1:72
      .= s2.IC  Computation(s2,k+1) by A3,A27,GRFUNC_1:8
      .= CurInstr  Computation(s2,k+1) by AMI_1:54;
    thus thesis
     by A16,A17,A18,SCMFSA6A:41;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A6,A15);
  hence thesis;
end;

theorem Th12: ::TG25
  for s being State of SCM+FSA,
  i being keeping_0 parahalting Instruction of SCM+FSA,
  J being parahalting Program of SCM+FSA, a being Int-Location
  holds IExec(i ';' J,s).a = IExec(J,Exec(i,Initialize s)).a
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be parahalting Program of SCM+FSA;
  let a be Int-Location;
  thus IExec(i ';' J,s).a = IExec(Macro i ';' J,s).a by SCMFSA6A:def 6
    .= IExec(J,IExec(Macro i,s)).a by SCMFSA6C:1
    .= IExec(J,Exec(i,Initialize s)).a by SCMFSA6C:6;
end;

theorem Th13: ::TG26
  for s being State of SCM+FSA,
  i being keeping_0 parahalting Instruction of SCM+FSA,
  J being parahalting Program of SCM+FSA, f being FinSeq-Location
  holds IExec(i ';' J,s).f = IExec(J,Exec(i,Initialize s)).f
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be parahalting Program of SCM+FSA;
  let f be FinSeq-Location;
  thus IExec(i ';' J,s).f = IExec(Macro i ';' J,s).f by SCMFSA6A:def 6
    .= IExec(J,IExec(Macro i,s)).f by SCMFSA6C:2
    .= IExec(J,Exec(i,Initialize s)).f by SCMFSA6C:6;
end;

definition
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  func if=0(a,I,J) -> Program of SCM+FSA equals

::Di2
  a =0_goto insloc (card J + 3) ';' J ';' Goto insloc (card I + 1) ';'
  I ';' Stop SCM+FSA;
  coherence;
  func if>0(a,I,J) -> Program of SCM+FSA equals

::Di3
  a >0_goto insloc (card J + 3) ';' J ';' Goto insloc (card I + 1) ';'
  I ';' Stop SCM+FSA;
  coherence;
end;

definition
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  func if<0(a,I,J) -> Program of SCM+FSA equals

::Di4
  if=0(a,J,if>0(a,J,I));
  coherence;
end;

Lm2: for a being Int-Location, I,J being Program of SCM+FSA holds
insloc 0 in dom if=0(a,I,J) & insloc 1 in dom if=0(a,I,J) &
insloc 0 in dom if>0(a,I,J) & insloc 1 in dom if>0(a,I,J)
proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  set i = a =0_goto insloc (card J + 3);
  if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)
  by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA))
  by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)))
  by SCMFSA6A:def 6;
  then
A1: dom Macro i c= dom if=0(a,I,J) by SCMFSA6A:56;
  dom Macro i = {insloc 0, insloc 1} by SCMFSA7B:4;
  then insloc 0 in dom Macro i & insloc 1 in dom Macro i by TARSKI:def 2;
  hence insloc 0 in dom if=0(a,I,J) & insloc 1 in dom if=0(a,I,J) by A1;
  set i = a >0_goto insloc (card J + 3);
  if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)
  by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA))
  by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)))
  by SCMFSA6A:def 6;
  then
A2: dom Macro i c= dom if>0(a,I,J) by SCMFSA6A:56;
  dom Macro i = {insloc 0, insloc 1} by SCMFSA7B:4;
  then insloc 0 in dom Macro i & insloc 1 in dom Macro i by TARSKI:def 2;
  hence thesis by A2;
end;

Lm3: for a being Int-Location, I,J being Program of SCM+FSA holds
if=0(a,I,J).insloc 0 = a =0_goto insloc (card J + 3) &
if=0(a,I,J).insloc 1 = goto insloc 2 &
if>0(a,I,J).insloc 0 = a >0_goto insloc (card J + 3) &
if>0(a,I,J).insloc 1 = goto insloc 2
proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  set i = a =0_goto insloc (card J + 3);
A1: i <> halt SCM+FSA by SCMFSA_2:48,124;
A2: if=0(a,I,J)
  = i ';' J ';' Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)
  by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA))
  by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)))
  by SCMFSA6A:def 6;
  dom Macro i = {insloc 0, insloc 1} by SCMFSA7B:4;
  then
A3: insloc 0 in dom Macro i & insloc 1 in dom Macro i by TARSKI:def 2;
  hence if=0(a,I,J).insloc 0 = (Directed Macro i).insloc 0 by A2,SCMFSA8A:28
    .= i by A1,SCMFSA7B:7;
  thus if=0(a,I,J).insloc 1 = (Directed Macro i).insloc 1 by A2,A3,SCMFSA8A:28
    .= goto insloc 2 by SCMFSA7B:8;
  set i = a >0_goto insloc (card J + 3);
A4: i <> halt SCM+FSA by SCMFSA_2:49,124;
A5: if>0(a,I,J)
  = i ';' J ';' Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)
  by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA))
  by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)))
  by SCMFSA6A:def 6;
  dom Macro i = {insloc 0, insloc 1} by SCMFSA7B:4;
  then
A6: insloc 0 in dom Macro i & insloc 1 in dom Macro i by TARSKI:def 2;
  hence if>0(a,I,J).insloc 0 = (Directed Macro i).insloc 0 by A5,SCMFSA8A:28
    .= i by A4,SCMFSA7B:7;
  thus if>0(a,I,J).insloc 1 = (Directed Macro i).insloc 1 by A5,A6,SCMFSA8A:28
    .= goto insloc 2 by SCMFSA7B:8;
end;

theorem Th14: ::T17
  for I,J being Program of SCM+FSA, a being Int-Location holds
  card if=0(a,I,J) = card I + card J + 4
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  thus card if=0(a,I,J)
  = card (Macro (a =0_goto insloc (card J + 3)) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA) by SCMFSA6A:def 6
    .= card (Macro (a =0_goto insloc (card J + 3)) ';' J ';'
  Goto insloc (card I + 1) ';' I) + 1 by SCMFSA6A:61,SCMFSA8A:17
    .= card (Macro (a =0_goto insloc (card J + 3)) ';' J ';'
  Goto insloc (card I + 1)) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a =0_goto insloc (card J + 3)) ';' J) +
  card Goto insloc (card I + 1) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a =0_goto insloc (card J + 3)) ';' J) + 1 + card I + 1
  by SCMFSA8A:29
    .= card Macro (a =0_goto insloc (card J + 3)) + card J + 1 + card I + 1
  by SCMFSA6A:61
    .= 2 + card J + 1 + card I + 1 by SCMFSA7B:6
    .= card I + card J + 4;
end;

theorem Th15: ::T18
  for I,J being Program of SCM+FSA, a being Int-Location holds
  card if>0(a,I,J) = card I + card J + 4
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  thus card if>0(a,I,J)
  = card (Macro (a >0_goto insloc (card J + 3)) ';' J ';'
  Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA) by SCMFSA6A:def 6
    .= card (Macro (a >0_goto insloc (card J + 3)) ';' J ';'
  Goto insloc (card I + 1) ';' I) + 1 by SCMFSA6A:61,SCMFSA8A:17
    .= card (Macro (a >0_goto insloc (card J + 3)) ';' J ';'
  Goto insloc (card I + 1)) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a >0_goto insloc (card J + 3)) ';' J) +
  card Goto insloc (card I + 1) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a >0_goto insloc (card J + 3)) ';' J) + 1 + card I + 1
  by SCMFSA8A:29
    .= card Macro (a >0_goto insloc (card J + 3)) + card J + 1 + card I + 1
  by SCMFSA6A:61
    .= 2 + card J + 1 + card I + 1 by SCMFSA7B:6
    .= card I + card J + 4;
end;

theorem Th16: ::ThIF0_1'
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a = 0 & I is_closed_on s & I is_halting_on s holds
  if=0(a,I,J) is_closed_on s & if=0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  assume
A2: I is_closed_on s;
  assume
A3: I is_halting_on s;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = s +* (I1 +* Start-At insloc 0);
  set s3 = s +* (if=0(a,I,J) +* Start-At insloc 0);
  set s4 =  Computation(s3,1);
  set i = a =0_goto insloc (card J + 3);
A4: I1 +* Start-At insloc 0 c= s1 by FUNCT_4:26;
  I1 is_halting_on s by A2,A3,SCMFSA8A:46;
  then
A5: s1 is halting by SCMFSA7B:def 8;
A6: I1 is_closed_on s by A2,A3,SCMFSA8A:46;
  DataPart s = DataPart s1 by SCMFSA8A:11;
  then
A7: I1 is_closed_on s1 by A6,Th6;
A8: insloc 0 in dom if=0(a,I,J) by Lm2;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A9: dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
  IC SCM+FSA in dom (if=0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
  then
A10: IC s3 = (if=0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A11: s3.insloc 0 = (if=0(a,I,J) +* Start-At insloc 0).insloc 0 by A8,A9,
FUNCT_4:14
    .= if=0(a,I,J).insloc 0 by A8,SCMFSA6B:7
    .= i by Lm3;
A12:  Computation( s3,0 + 1) = Following  Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A10,A11;
A13: card (i ';' J ';' Goto insloc (card I + 1))
  = card (Macro i ';' J ';' Goto insloc (card I + 1)) by SCMFSA6A:def 6
    .= card (Macro i ';' J) + card Goto insloc (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by SCMFSA7B:6
    .= card J + (2 + 1);
  not a in dom (if=0(a,I,J) +* Start-At insloc 0) & a in dom s
  by SCMFSA6B:12,SCMFSA_2:66;
  then
A14: s3.a = 0 by A1,FUNCT_4:12;
A15: if=0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A16: if=0(a,I,J) c= s3 by A15,XBOOLE_1:1;
  if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67;
  then ProgramPart Relocated(I1,card J + 3) c= if=0(a,I,J) by A13,Lm1;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A16,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(I1,card J + 3)] c= s4 by AMI_1:99;
  then
A17: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
A18: IC  Computation(s3,1) = insloc (card J + 3) by A12,A14,SCMFSA_2:96;
A19: DataPart s1 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A20: now
    let a be Int-Location;
    thus s1.a = s3.a by A19,SCMFSA6A:38
      .= s4.a by A12,SCMFSA_2:96;
  end;
  now
    let f be FinSeq-Location;
    thus s1.f = s3.f by A19,SCMFSA6A:38
      .= s4.f by A12,SCMFSA_2:96;
  end;
  then
A21: DataPart s1 = DataPart s4 by A20,SCMFSA6A:38;
  CurInstr  Computation( s3,LifeSpan s1 + 1)
  = CurInstr  Computation( s4,LifeSpan s1) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s1,LifeSpan s1)),(card J + 3))
  by A4,A7,A17,A18,A21,Th11
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A5,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A22: s3 is halting by AMI_1:def 20;
  now
    let k be Element of NAT;
    per cases;
    suppose 0 < k;
      then consider k1 being Nat such that
A23:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
  reconsider m = IC  Computation( s1,k1) as Element of NAT by ORDINAL1:def 13;
A25:  card I1 = card I + 1 by SCMFSA6A:61,SCMFSA8A:17;
A26:  card if=0(a,I,J) = card I + card J + 4 by Th14
        .= card J + 3 + card I1 by A25;
      insloc m in dom I1 by A6,SCMFSA7B:def 7;
      then m < card I1 by SCMFSA6A:15;
      then
A27:  m + (card J + 3) < card if=0(a,I,J) by A26,XREAL_1:8;
      IC  Computation(s3,k) = IC  Computation( s4,k1) by A23,AMI_1:51
        .= insloc (m + (card J + 3)) by A4,A7,A17,A18,A21,Th11;
      hence IC  Computation(s3,k) in dom if=0(a,I,J) by A27,SCMFSA6A:15;
    end;
    suppose k = 0;
      hence IC  Computation(s3,k) in dom if=0(a,I,J) by A8,A10,AMI_1:13;
    end;
  end;
  hence if=0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
  thus thesis by A22,SCMFSA7B:def 8;
end;

theorem Th17: ::ThIF0_1(@BBB8)
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a = 0 & I is_closed_on Initialize s & I is_halting_on Initialize s holds
  IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I + card J + 3)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  assume
A2: I is_closed_on Initialize s;
  assume
A3: I is_halting_on Initialize s;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = s +* Initialized I1;
  set s3 = s +* Initialized if=0(a,I,J);
  set s4 =  Computation(s3,1);
  set i = a =0_goto insloc (card J + 3);
A4: I1 +* Start-At insloc 0 c= s1 by FUNCT_4:26,SCMFSA6B:8;
A5: s1 is halting by A2,A3,SCMFSA8A:55;
  I1 is_closed_on Initialize s by A2,A3,SCMFSA8A:46;
  then
A6: I1 is_closed_on s1 by Th9;
A7: insloc 0 in dom if=0(a,I,J) by Lm2;
  if=0(a,I,J) c= Initialized if=0(a,I,J) by SCMFSA6A:26;
  then
A8: dom if=0(a,I,J) c= dom Initialized if=0(a,I,J) by GRFUNC_1:8;
  IC SCM+FSA in dom Initialized if=0(a,I,J) by SCMFSA6A:24;
  then
A9: IC s3 = (Initialized if=0(a,I,J)).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SCMFSA6A:46;
A10: s3.insloc 0 = (Initialized if=0(a,I,J)).insloc 0 by A7,A8,FUNCT_4:14
    .= if=0(a,I,J).insloc 0 by A7,SCMFSA6A:50
    .= i by Lm3;
A11:  Computation( s3,0 + 1) = Following  Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A9,A10;
A12: card (i ';' J ';' Goto insloc (card I + 1))
  = card (Macro i ';' J ';' Goto insloc (card I + 1)) by SCMFSA6A:def 6
    .= card (Macro i ';' J) + card Goto insloc (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by SCMFSA7B:6
    .= card J + (2 + 1);
A13: dom (s | A) = A by SCMFSA8A:3;
  not a in dom Initialized if=0(a,I,J) & a in dom s
  by SCMFSA6A:48,SCMFSA_2:66;
  then
A14: s3.a = 0 by A1,FUNCT_4:12;
A15: Initialized if=0(a,I,J) c= s3 by FUNCT_4:26;
  if=0(a,I,J) c= Initialized if=0(a,I,J) by SCMFSA6A:26;
  then
A16: if=0(a,I,J) c= s3 by A15,XBOOLE_1:1;
  if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67;
  then ProgramPart Relocated(I1,card J + 3) c= if=0(a,I,J) by A12,Lm1;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A16,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(I1,card J + 3)] c= s4 by AMI_1:99;
  then
A17: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
A18: IC  Computation(s3,1) = insloc (card J + 3) by A11,A14,SCMFSA_2:96;
A19: DataPart s1 = DataPart s3 by SCMFSA6A:39,53;
A20: now
    let a be Int-Location;
    thus s1.a = s3.a by A19,SCMFSA6A:38
      .= s4.a by A11,SCMFSA_2:96;
  end;
  now
    let f be FinSeq-Location;
    thus s1.f = s3.f by A19,SCMFSA6A:38
      .= s4.f by A11,SCMFSA_2:96;
  end;
  then
A21: DataPart s1 = DataPart s4 by A20,SCMFSA6A:38;
A22: CurInstr  Computation( s3,LifeSpan s1 + 1)
  = CurInstr  Computation( s4,LifeSpan s1) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s1,LifeSpan s1)),(card J + 3))
  by A4,A6,A17,A18,A21,Th11
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A5,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A23: s3 is halting by AMI_1:def 20;
  now
    let l be Element of NAT;
    assume
A24: l < LifeSpan s1 + 1;
    per cases;
    suppose l = 0;
      then CurInstr  Computation( s3,l) = CurInstr s3 by AMI_1:13;
      hence CurInstr  Computation( s3,l) <> halt SCM+FSA by A9,A10,SCMFSA_2:48
,124;
    end;
    suppose l <> 0;
      then consider n being Nat such that
A25:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A26:  n < LifeSpan s1 by A24,A25,XREAL_1:8;
      assume
A27:  CurInstr  Computation( s3,l) = halt SCM+FSA;
      InsCode CurInstr  Computation( s1,n)
      = InsCode IncAddr(CurInstr  Computation( s1,n),(card J + 3))
      by SCMFSA_4:22
        .= InsCode CurInstr  Computation( s4,n) by A4,A6,A17,A18,A21,Th11
        .= 0 by A25,A27,AMI_1:51,SCMFSA_2:124;
      then CurInstr  Computation( s1,n) = halt SCM+FSA by SCMFSA_2:122;
      hence contradiction by A5,A26,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr  Computation( s3,l) = halt SCM+FSA
  holds LifeSpan s1 + 1 <= l;
  then
A28: LifeSpan s3 = LifeSpan s1 + 1 by A22,A23,AMI_1:def 46;
A29: DataPart Result s1 = DataPart Computation( s1,LifeSpan s1)
 by A2,A3,AMI_1:122,SCMFSA8A:55
    .= DataPart Computation( s4,LifeSpan s1) by A4,A6,A17,A18,A21,Th11
    .= DataPart Computation( s3,LifeSpan s1 + 1) by AMI_1:51
    .= DataPart Result s3 by A23,A28,AMI_1:122;
A30: dom IExec(if=0(a,I,J),s) = the carrier of SCM+FSA by AMI_1:79
    .= dom (IExec(I1,s) +* Start-At insloc (card I + card J + 3)) by AMI_1:79;
  now
    let x be set;
A31: IExec(I1,s) = Result s1 +* s | A by SCMFSA6B:def 1;
A32: IExec(if=0(a,I,J),s) = (Result s3) +* (s | A) by SCMFSA6B:def 1;
    assume
A33: x in dom IExec(if=0(a,I,J),s);
A34: dom Start-At insloc (card I + card J + 3) = {IC SCM+FSA} by FUNCOP_1:19;
A35: now
      assume x in dom (s | A);
      then x in A by RELAT_1:86;
      hence x is Instruction-Location of SCM+FSA by AMI_1:def 4;
    end;
    per cases by A33,SCMFSA6A:35;
    suppose
A36:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A37:  x in dom IExec(I1,s) &
      not x in dom Start-At insloc (card I + card J + 3)
      by A34,A36,SCMFSA_2:66,TARSKI:def 1;
      thus IExec(if=0(a,I,J),s).x
      = (Result s3).x by A32,A35,A36,FUNCT_4:12,SCMFSA_2:84
        .= (Result s1).x by A29,A36,SCMFSA6A:38
        .= IExec(I1,s).x by A31,A35,A36,FUNCT_4:12,SCMFSA_2:84
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x
      by A37,FUNCT_4:12;
    end;
    suppose
A38:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A39:  x in dom IExec(I1,s) &
      not x in dom Start-At insloc (card I + card J + 3)
      by A34,A38,SCMFSA_2:67,TARSKI:def 1;
      thus IExec(if=0(a,I,J),s).x
      = (Result s3).x by A32,A35,A38,FUNCT_4:12,SCMFSA_2:85
        .= (Result s1).x by A29,A38,SCMFSA6A:38
        .= IExec(I1,s).x by A31,A35,A38,FUNCT_4:12,SCMFSA_2:85
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x
      by A39,FUNCT_4:12;
    end;
    suppose
A40:  x = IC SCM+FSA;
      then
A41:  x in dom Start-At insloc (card I + card J + 3) by A34,TARSKI:def 1;
A42:  IC Result s1 = IExec(I1,s).IC SCM+FSA by A31,A35,A40,AMI_1:48,FUNCT_4:12
        .= IC (IExec(I,s) +* Start-At insloc card I) by A2,A3,SCMFSA8A:57
        .= insloc card I by AMI_1:111;
      thus IExec(if=0(a,I,J),s).x
      = (Result s3).x by A32,A35,A40,AMI_1:48,FUNCT_4:12
        .=  Computation( s3,LifeSpan s1 + 1).x by A23,A28,AMI_1:122
        .= IC  Computation( s4,LifeSpan s1) by A40,AMI_1:51
        .= IC  Computation( s1,LifeSpan s1) + (card J + 3)
      by A4,A6,A17,A18,A21,Th11
        .= IC Result s1 + (card J + 3) by A2,A3,AMI_1:122,SCMFSA8A:55
        .= (Start-At (insloc card I + (card J + 3))).IC SCM+FSA by A42,
FUNCOP_1:87
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x
      by A40,A41,FUNCT_4:14;
    end;
    suppose
A43:  x is Instruction-Location of SCM+FSA;
      then x <> IC SCM+FSA by AMI_1:48;
      then
A44:  x in dom IExec(I1,s) &
      not x in dom Start-At insloc (card I + card J + 3)
      by A34,A43,Th2,TARSKI:def 1;
A45:  x in NAT by A43,AMI_1:def 4;
      hence IExec(if=0(a,I,J),s).x = (s | A).x by A13,A32,FUNCT_4:14
        .= IExec(I1,s).x by A13,A31,A45,FUNCT_4:14
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x
      by A44,FUNCT_4:12;
    end;
  end;
  hence IExec(if=0(a,I,J),s)
  = IExec(I1,s) +* Start-At insloc (card I + card J + 3) by A30,FUNCT_1:9
    .= IExec(I,s) +* Start-At insloc card I
  +* Start-At insloc (card I + card J + 3) by A2,A3,SCMFSA8A:57
    .= IExec(I,s) +* Start-At insloc (card I + card J + 3) by AMI_1:141;
end;

theorem Th18: ::ThIF0_2'
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a <> 0 & J is_closed_on s & J is_halting_on s holds
  if=0(a,I,J) is_closed_on s & if=0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a <> 0;
  assume
A2: J is_closed_on s;
  assume
A3: J is_halting_on s;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = s +* (JI2 +* Start-At insloc 0);
  set s3 = s +* (if=0(a,I,J) +* Start-At insloc 0);
  set s4 =  Computation(s3,1);
  set s5 =  Computation(s3,2);
  set i = a =0_goto insloc (card J + 3);
A4: JI2 +* Start-At insloc 0 c= s2 by FUNCT_4:26;
A5: s2 is halting by A2,A3,SCMFSA8A:59;
A6: JI2 is_closed_on s by A2,A3,SCMFSA8A:58;
  then
A7: JI2 is_closed_on s2 by Th10;
A8: insloc 0 in dom if=0(a,I,J) by Lm2;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A9: dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
  IC SCM+FSA in dom (if=0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
  then
A10: IC s3 = (if=0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A11: s3.insloc 0 = (if=0(a,I,J) +* Start-At insloc 0).insloc 0 by A8,A9,
FUNCT_4:14
    .= if=0(a,I,J).insloc 0 by A8,SCMFSA6B:7
    .= i by Lm3;
A12:  Computation( s3,0 + 1) = Following  Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A10,A11;
  not a in dom (if=0(a,I,J) +* Start-At insloc 0) & a in dom s
  by SCMFSA6B:12,SCMFSA_2:66;
  then
A13: s3.a <> 0 by A1,FUNCT_4:12;
A14: if=0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A15: if=0(a,I,J) c= s3 by A14,XBOOLE_1:1;
A16: if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' JI2 by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:def 6;
  then ProgramPart Relocated(JI2,card Macro i) c= if=0(a,I,J) by Lm1;
  then ProgramPart Relocated(JI2,2) c= if=0(a,I,J) by SCMFSA7B:6;
  then ProgramPart Relocated(JI2,2) c= s3 by A15,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(JI2,2)] c= s5 by AMI_1:99;
  then
A17: ProgramPart Relocated(JI2,2) c= s5 by AMI_1:105;
A18: IC  Computation(s3,1) = Next insloc 0 by A10,A12,A13,SCMFSA_2:96
    .= insloc (0 + 1);
A19: insloc 1 in dom if=0(a,I,J) by Lm2;
A20:  Computation(s3,1).insloc 1 = s3.insloc 1 by AMI_1:54
    .= (if=0(a,I,J) +* Start-At insloc 0).insloc 1 by A9,A19,FUNCT_4:14
    .= if=0(a,I,J).insloc 1 by A19,SCMFSA6B:7
    .= goto insloc 2 by Lm3;
A21:  Computation( s3,1 + 1) = Following s4 by AMI_1:14
    .= Exec(goto insloc 2,s4) by A18,A20;
  then
A22: IC s5 = insloc 2 by SCMFSA_2:95;
A23: DataPart s2 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A24: now
    let a be Int-Location;
    thus s2.a = s3.a by A23,SCMFSA6A:38
      .=  Computation(s3,1).a by A12,SCMFSA_2:96
      .= s5.a by A21,SCMFSA_2:95;
  end;
  now
    let f be FinSeq-Location;
    thus s2.f = s3.f by A23,SCMFSA6A:38
      .=  Computation(s3,1).f by A12,SCMFSA_2:96
      .= s5.f by A21,SCMFSA_2:95;
  end;
  then
A25: DataPart s2 = DataPart s5 by A24,SCMFSA6A:38;
  CurInstr  Computation( s3,LifeSpan s2 + 2)
  = CurInstr  Computation( s5,LifeSpan s2) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s2,LifeSpan s2)),2)
  by A4,A7,A17,A22,A25,Th11
    .= IncAddr(halt SCM+FSA,2) by A5,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A26: s3 is halting by AMI_1:def 20;
  now
    let k be Element of NAT;
    k = 0 or 0 + 1 < k + 1 by XREAL_1:8;
    then
A27: k = 0 or 1 <= k by NAT_1:13;
    per cases by A27,XXREAL_0:1;
    suppose
A28:  1 < k;
      then consider k1 being Nat such that
A29:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      0 + 1 < k1 + 1 by A28,A29;
      then consider k2 being Nat such that
A30:  k2 + 1 = k1 by NAT_1:6;
      reconsider k2 as Element of NAT by ORDINAL1:def 13;
  reconsider m = IC Computation( s2,k2) as Element of NAT by ORDINAL1:def 13;
A32:  card if=0(a,I,J) = card Macro i + card JI2 by A16,SCMFSA6A:61
        .= 2 + card JI2 by SCMFSA7B:6;
      insloc m in dom JI2 by A6,SCMFSA7B:def 7;
      then m < card JI2 by SCMFSA6A:15;
      then
A33:  m + 2 < card if=0(a,I,J) by A32,XREAL_1:8;
      IC  Computation(s3,k) = IC  Computation( s4,k1) by A29,AMI_1:51
        .= IC  Computation(  Computation( s4,1),k2) by A30,AMI_1:51
        .= IC  Computation(  Computation( s3,1 + 1),k2) by AMI_1:51
        .= insloc (m + 2) by A4,A7,A17,A22,A25,Th11;
      hence IC  Computation(s3,k) in dom if=0(a,I,J) by A33,SCMFSA6A:15;
    end;
    suppose k = 0;
      hence IC  Computation(s3,k) in dom if=0(a,I,J) by A8,A10,AMI_1:13;
    end;
    suppose k = 1;
      hence IC  Computation(s3,k) in dom if=0(a,I,J) by A18,Lm2;
    end;
  end;
  hence if=0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
  thus thesis by A26,SCMFSA7B:def 8;
end;

theorem Th19: ::ThIF0_2(@BBB8)
  for I,J being Program of SCM+FSA, a being read-write Int-Location holds
  for s being State of SCM+FSA

st s.a <> 0 & J is_closed_on Initialize s & J is_halting_on Initialize s holds
  IExec(if=0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card I + card J + 3)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  assume
A1: s.a <> 0;
  assume
A2: J is_closed_on Initialize s;
  assume
A3: J is_halting_on Initialize s;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = s +* Initialized JI2;
  set s3 = s +* Initialized if=0(a,I,J);
  set s4 =  Computation( s3,1);
  set s5 =  Computation( s3,2);
  set i = a =0_goto insloc (card J + 3);
A4: JI2 +* Start-At insloc 0 c= s2 by FUNCT_4:26,SCMFSA6B:8;
A5: s2 is halting by A2,A3,SCMFSA8A:60;
  JI2 is_closed_on Initialize s by A2,A3,SCMFSA8A:58;
  then
A6: JI2 is_closed_on s2 by Th9;
A7: insloc 0 in dom if=0(a,I,J) by Lm2;
  if=0(a,I,J) c= Initialized if=0(a,I,J) by SCMFSA6A:26;
  then
A8: dom if=0(a,I,J) c= dom Initialized if=0(a,I,J) by GRFUNC_1:8;
  IC SCM+FSA in dom Initialized if=0(a,I,J) by SCMFSA6A:24;
  then
A9: IC s3 = (Initialized if=0(a,I,J)).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SCMFSA6A:46;
A10: s3.insloc 0 = (Initialized if=0(a,I,J)).insloc 0 by A7,A8,FUNCT_4:14
    .= if=0(a,I,J).insloc 0 by A7,SCMFSA6A:50
    .= i by Lm3;
A11:  Computation( s3,0 + 1) = Following  Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A9,A10;
A12: dom (s | A) = dom s /\ A by RELAT_1:90
    .= (D \/ {IC SCM+FSA} \/ A) /\ A by SCMFSA6A:34
    .= A by XBOOLE_1:21;
  not a in dom Initialized if=0(a,I,J) & a in dom s
  by SCMFSA6A:48,SCMFSA_2:66;
  then
A13: s3.a <> 0 by A1,FUNCT_4:12;
A14: Initialized if=0(a,I,J) c= s3 by FUNCT_4:26;
  if=0(a,I,J) c= Initialized if=0(a,I,J) by SCMFSA6A:26;
  then
A15: if=0(a,I,J) c= s3 by A14,XBOOLE_1:1;
  if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' JI2 by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:def 6;
  then ProgramPart Relocated(JI2,card Macro i) c= if=0(a,I,J) by Lm1;
  then ProgramPart Relocated(JI2,2) c= if=0(a,I,J) by SCMFSA7B:6;
  then ProgramPart Relocated(JI2,2) c= s3 by A15,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(JI2,2)] c= s5 by AMI_1:99;
  then
A16: ProgramPart Relocated(JI2,2) c= s5 by AMI_1:105;
A17: IC  Computation(s3,1) = Next insloc 0 by A9,A11,A13,SCMFSA_2:96
    .= insloc (0 + 1);
A18: insloc 1 in dom if=0(a,I,J) by Lm2;
A19:  Computation(s3,1).insloc 1 = s3.insloc 1 by AMI_1:54
    .= (Initialized if=0(a,I,J)).insloc 1 by A8,A18,FUNCT_4:14
    .= if=0(a,I,J).insloc 1 by A18,SCMFSA6A:50
    .= goto insloc 2 by Lm3;
A20:  Computation( s3,1 + 1) = Following s4 by AMI_1:14
    .= Exec(goto insloc 2,s4) by A17,A19;
  then
A21: IC s5 = insloc 2 by SCMFSA_2:95;
A22: DataPart s2 = DataPart s3 by SCMFSA6A:39,53;
A23: now
    let a be Int-Location;
    thus s2.a = s3.a by A22,SCMFSA6A:38
      .=  Computation(s3,1).a by A11,SCMFSA_2:96
      .= s5.a by A20,SCMFSA_2:95;
  end;
  now
    let f be FinSeq-Location;
    thus s2.f = s3.f by A22,SCMFSA6A:38
      .=  Computation(s3,1).f by A11,SCMFSA_2:96
      .= s5.f by A20,SCMFSA_2:95;
  end;
  then
A24: DataPart s2 = DataPart s5 by A23,SCMFSA6A:38;
A25: CurInstr  Computation( s3,LifeSpan s2 + 2)
  = CurInstr  Computation( s5,LifeSpan s2) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s2,LifeSpan s2)),2)
  by A4,A6,A16,A21,A24,Th11
    .= IncAddr(halt SCM+FSA,2) by A5,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A26: s3 is halting by AMI_1:def 20;
  now
    let l be Element of NAT;
    assume
A27: l < LifeSpan s2 + 2;
    per cases;
    suppose l = 0;
      then CurInstr  Computation( s3,l) = CurInstr s3 by AMI_1:13;
      hence CurInstr  Computation( s3,l) <> halt SCM+FSA by A9,A10,SCMFSA_2:48
,124;
    end;
    suppose l = 1;
      hence CurInstr  Computation( s3,l) <> halt SCM+FSA by A17,A19,SCMFSA_2:47
,124;
    end;
    suppose
A28:  l <> 0 & l <> 1;
      then consider n being Nat such that
A29:  l = n + 1 by NAT_1:6;
      n + 1 < LifeSpan s2 + 1 + 1 by A27,A29;
      then
A30:  n < LifeSpan s2 + 1 by XREAL_1:8;
      n <> 0 by A28,A29;
      then consider l2 being Nat such that
A31:  n = l2 + 1 by NAT_1:6;
      reconsider l2 as Element of NAT by ORDINAL1:def 13;
A32:  l2 < LifeSpan s2 by A30,A31,XREAL_1:8;
      assume
A33:  CurInstr  Computation( s3,l) = halt SCM+FSA;
      InsCode CurInstr  Computation( s2,l2)
      = InsCode IncAddr(CurInstr  Computation( s2,l2),2) by SCMFSA_4:22
        .= InsCode CurInstr  Computation( s5,l2) by A4,A6,A16,A21,A24,Th11
        .= InsCode CurInstr  Computation( s3,l2 + (1 + 1)) by AMI_1:51
        .= 0 by A29,A31,A33,SCMFSA_2:124;
      then CurInstr  Computation( s2,l2) = halt SCM+FSA by SCMFSA_2:122;
      hence contradiction by A5,A32,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr  Computation( s3,l) = halt SCM+FSA
  holds LifeSpan s2 + 2 <= l;
  then
A34: LifeSpan s3 = LifeSpan s2 + 2 by A25,A26,AMI_1:def 46;
A35: DataPart Result s2
     = DataPart Computation( s2,LifeSpan s2) by A2,A3,AMI_1:122,SCMFSA8A:60
    .= DataPart Computation( s5,LifeSpan s2) by A4,A6,A16,A21,A24,Th11
    .= DataPart Computation( s3,LifeSpan s2 + 2) by AMI_1:51
    .= DataPart Result s3 by A26,A34,AMI_1:122;
A36: dom IExec(if=0(a,I,J),s) = the carrier of SCM+FSA by AMI_1:79
    .= dom (IExec(JI2,s) +* Start-At insloc (card I + card J + 3))
  by AMI_1:79;
  now
    let x be set;
A37: now
      assume x in dom (s | A);
      then x in A by RELAT_1:86;
      hence x is Instruction-Location of SCM+FSA by AMI_1:def 4;
    end;
A38: IExec(JI2,s) = Result s2 +* s | A by SCMFSA6B:def 1;
A39: IExec(if=0(a,I,J),s) = (Result s3) +* (s | A) by SCMFSA6B:def 1;
    assume
A40: x in dom IExec(if=0(a,I,J),s);
A41: dom Start-At insloc (card I + card J + 3) = {IC SCM+FSA} by FUNCOP_1:19;
    per cases by A40,SCMFSA6A:35;
    suppose
A42:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A43:  x in dom IExec(JI2,s) &
      not x in dom Start-At insloc (card I + card J + 3)
      by A41,A42,SCMFSA_2:66,TARSKI:def 1;
      thus IExec(if=0(a,I,J),s).x
      = (Result s3).x by A37,A39,A42,FUNCT_4:12,SCMFSA_2:84
        .= (Result s2).x by A35,A42,SCMFSA6A:38
        .= IExec(JI2,s).x by A37,A38,A42,FUNCT_4:12,SCMFSA_2:84
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x
      by A43,FUNCT_4:12;
    end;
    suppose
A44:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A45:  x in dom IExec(JI2,s) &
      not x in dom Start-At insloc (card I + card J + 3)
      by A41,A44,SCMFSA_2:67,TARSKI:def 1;
      thus IExec(if=0(a,I,J),s).x
      = (Result s3).x by A37,A39,A44,FUNCT_4:12,SCMFSA_2:85
        .= (Result s2).x by A35,A44,SCMFSA6A:38
        .= IExec(JI2,s).x by A37,A38,A44,FUNCT_4:12,SCMFSA_2:85
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x
      by A45,FUNCT_4:12;
    end;
    suppose
A46:  x = IC SCM+FSA;
      then
A47:  x in dom Start-At insloc (card I + card J + 3) by A41,TARSKI:def 1;
A48:  IC Result s2 = IC IExec(JI2,s) by A37,A38,A46,AMI_1:48,FUNCT_4:12
        .= insloc (card I + card J + 1) by A2,A3,SCMFSA8A:61;
      thus IExec(if=0(a,I,J),s).x
      = (Result s3).x by A37,A39,A46,AMI_1:48,FUNCT_4:12
        .=  Computation( s3,LifeSpan s2 + 2).x by A26,A34,AMI_1:122
        .= IC  Computation( s5,LifeSpan s2) by A46,AMI_1:51
        .= IC  Computation( s2,LifeSpan s2) + 2 by A4,A6,A16,A21,A24,Th11
        .= IC Result s2 + 2 by A2,A3,AMI_1:122,SCMFSA8A:60
        .= (Start-At (insloc (card I + card J + 1) + 2)).IC SCM+FSA
      by A48,FUNCOP_1:87
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x
      by A46,A47,FUNCT_4:14;
    end;
    suppose
A49:  x is Instruction-Location of SCM+FSA;
      then x <> IC SCM+FSA by AMI_1:48;
      then
A50:  x in dom IExec(JI2,s) &
      not x in dom Start-At insloc (card I + card J + 3)
      by A41,A49,Th2,TARSKI:def 1;
A51:  x in NAT by A49,AMI_1:def 4;
      hence IExec(if=0(a,I,J),s).x = (s | A).x by A12,A39,FUNCT_4:14
        .= IExec(JI2,s).x by A12,A38,A51,FUNCT_4:14
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x
      by A50,FUNCT_4:12;
    end;
  end;
  hence IExec(if=0(a,I,J),s)
  = IExec(JI2,s) +* Start-At insloc (card I + card J + 3) by A36,FUNCT_1:9
    .= IExec(J,s) +* Start-At insloc (card I + card J + 1)
  +* Start-At insloc (card I + card J + 3) by A2,A3,SCMFSA8A:62
    .= IExec(J,s) +* Start-At insloc (card I + card J + 3) by AMI_1:141;
end;

theorem Th20: ::ThIF0(@BBB8)
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA,
  a being read-write Int-Location holds if=0(a,I,J) is parahalting &
  (s.a = 0 implies IExec(if=0(a,I,J),s) =
  IExec(I,s) +* Start-At insloc (card I + card J + 3)) &
  (s.a <> 0 implies IExec(if=0(a,I,J),s) =
  IExec(J,s) +* Start-At insloc (card I + card J + 3))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
A1: I is_closed_on Initialize s & I is_halting_on Initialize s
  by SCMFSA7B:24,25;
A2: J is_closed_on Initialize s & J is_halting_on Initialize s
  by SCMFSA7B:24,25;
  now
    let s be State of SCM+FSA;
    assume if=0(a,I,J) +* Start-At insloc 0 c= s;
    then
A3: s = s +* (if=0(a,I,J) +* Start-At insloc 0) by FUNCT_4:79;
A4: I is_closed_on s & I is_halting_on s by SCMFSA7B:24,25;
A5: J is_closed_on s & J is_halting_on s by SCMFSA7B:24,25;
    per cases;
    suppose s.a = 0;
      then if=0(a,I,J) is_halting_on s by A4,Th16;
      hence s is halting by A3,SCMFSA7B:def 8;
    end;
    suppose s.a <> 0;
      then if=0(a,I,J) is_halting_on s by A5,Th18;
      hence s is halting by A3,SCMFSA7B:def 8;
    end;
  end;
  then if=0(a,I,J) +* Start-At insloc 0 is halting by AMI_1:def 26;
  hence if=0(a,I,J) is parahalting by SCMFSA6B:def 3;
  thus s.a = 0 implies IExec(if=0(a,I,J),s) =
  IExec(I,s) +* Start-At insloc (card I + card J + 3) by A1,Th17;
  thus thesis by A2,Th19;
end;

theorem Th21: ::ThIF0'
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA,
  a being read-write Int-Location holds
  IC IExec(if=0(a,I,J),s) = insloc (card I + card J + 3) & (s.a = 0 implies
  ((for d being Int-Location holds IExec(if=0(a,I,J),s).d = IExec(I,s).d) &
  for f being FinSeq-Location holds IExec(if=0(a,I,J),s).f = IExec(I,s).f)) &
  (s.a <> 0 implies ((for d being Int-Location holds
  IExec(if=0(a,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if=0(a,I,J),s).f = IExec(J,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby per cases;
    suppose s.a = 0;
      then IExec(if=0(a,I,J),s) =
      IExec(I,s) +* Start-At insloc (card I + card J + 3) by Th20;
      hence IC IExec(if=0(a,I,J),s) = insloc (card I + card J + 3)
      by AMI_1:111;
    end;
    suppose s.a <> 0;
      then IExec(if=0(a,I,J),s) =
      IExec(J,s) +* Start-At insloc (card I + card J + 3) by Th20;
      hence IC IExec(if=0(a,I,J),s) = insloc (card I + card J + 3)
      by AMI_1:111;
    end;
  end;
  hereby
    assume s.a = 0;
    then
A1: IExec(if=0(a,I,J),s) =
    IExec(I,s) +* Start-At insloc (card I + card J + 3) by Th20;
    hereby
      let d be Int-Location;
      not d in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:9;
      hence IExec(if=0(a,I,J),s).d = IExec(I,s).d by A1,FUNCT_4:12;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:10;
    hence IExec(if=0(a,I,J),s).f = IExec(I,s).f by A1,FUNCT_4:12;
  end;
  assume s.a <> 0;
  then
A2: IExec(if=0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card I + card J + 3)
  by Th20;
  hereby
    let d be Int-Location;
    not d in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:9;
    hence IExec(if=0(a,I,J),s).d = IExec(J,s).d by A2,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:10;
  hence thesis by A2,FUNCT_4:12;
end;

theorem Th22: ::ThIFg0_1'
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a > 0 & I is_closed_on s & I is_halting_on s holds
  if>0(a,I,J) is_closed_on s & if>0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  assume
A2: I is_closed_on s;
  assume
A3: I is_halting_on s;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = s +* (I1 +* Start-At insloc 0);
  set s3 = s +* (if>0(a,I,J) +* Start-At insloc 0);
  set s4 =  Computation( s3,1);
  set i = a >0_goto insloc (card J + 3);
A4: I1 +* Start-At insloc 0 c= s1 by FUNCT_4:26;
  I1 is_halting_on s by A2,A3,SCMFSA8A:46;
  then
A5: s1 is halting by SCMFSA7B:def 8;
A6: I1 is_closed_on s by A2,A3,SCMFSA8A:46;
  DataPart s = DataPart s1 by SCMFSA8A:11;
  then
A7: I1 is_closed_on s1 by A6,Th6;
A8: insloc 0 in dom if>0(a,I,J) by Lm2;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A9: dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
  IC SCM+FSA in dom (if>0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
  then
A10: IC s3 = (if>0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A11: s3.insloc 0 = (if>0(a,I,J) +* Start-At insloc 0).insloc 0 by A8,A9,
FUNCT_4:14
    .= if>0(a,I,J).insloc 0 by A8,SCMFSA6B:7
    .= i by Lm3;
A12:  Computation( s3,0 + 1) = Following  Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A10,A11;
A13: card (i ';' J ';' Goto insloc (card I + 1))
  = card (Macro i ';' J ';' Goto insloc (card I + 1)) by SCMFSA6A:def 6
    .= card (Macro i ';' J) + card Goto insloc (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by SCMFSA7B:6
    .= card J + (2 + 1);
  not a in dom (if>0(a,I,J) +* Start-At insloc 0) & a in dom s
  by SCMFSA6B:12,SCMFSA_2:66;
  then
A14: s3.a > 0 by A1,FUNCT_4:12;
A15: if>0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A16: if>0(a,I,J) c= s3 by A15,XBOOLE_1:1;
  if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67;
  then ProgramPart Relocated(I1,card J + 3) c= if>0(a,I,J) by A13,Lm1;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A16,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(I1,card J + 3)] c= s4 by AMI_1:99;
  then
A17: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
A18: IC  Computation(s3,1) = insloc (card J + 3) by A12,A14,SCMFSA_2:97;
A19: DataPart s1 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A20: now
    let a be Int-Location;
    thus s1.a = s3.a by A19,SCMFSA6A:38
      .= s4.a by A12,SCMFSA_2:97;
  end;
  now
    let f be FinSeq-Location;
    thus s1.f = s3.f by A19,SCMFSA6A:38
      .= s4.f by A12,SCMFSA_2:97;
  end;
  then
A21: DataPart s1 = DataPart s4 by A20,SCMFSA6A:38;
  CurInstr  Computation( s3,LifeSpan s1 + 1)
  = CurInstr  Computation( s4,LifeSpan s1) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s1,LifeSpan s1)),(card J + 3))
  by A4,A7,A17,A18,A21,Th11
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A5,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A22: s3 is halting by AMI_1:def 20;
  now
    let k be Element of NAT;
    per cases;
    suppose 0 < k;
      then consider k1 being Nat such that
A23:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
  reconsider m = IC  Computation( s1,k1) as Element of NAT by ORDINAL1:def 13;
A25:  card I1 = card I + 1 by SCMFSA6A:61,SCMFSA8A:17;
A26:  card if>0(a,I,J) = card I + card J + 4 by Th15
        .= card J + 3 + card I1 by A25;
      insloc m in dom I1 by A6,SCMFSA7B:def 7;
      then m < card I1 by SCMFSA6A:15;
      then
A27:  m + (card J + 3) < card if>0(a,I,J) by A26,XREAL_1:8;
      IC  Computation(s3,k) = IC  Computation( s4,k1) by A23,AMI_1:51
        .= insloc (m + (card J + 3)) by A4,A7,A17,A18,A21,Th11;
      hence IC  Computation(s3,k) in dom if>0(a,I,J) by A27,SCMFSA6A:15;
    end;
    suppose k = 0;
      hence IC  Computation(s3,k) in dom if>0(a,I,J) by A8,A10,AMI_1:13;
    end;
  end;
  hence if>0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
  thus thesis by A22,SCMFSA7B:def 8;
end;

theorem Th23: ::ThIFg0_1(@BBB8)
  for I,J being Program of SCM+FSA, a being read-write Int-Location holds
  for s being State of SCM+FSA
  st s.a > 0 & I is_closed_on Initialize s & I is_halting_on Initialize s holds
  IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I + card J + 3)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  assume
A1: s.a > 0;
  assume
A2: I is_closed_on Initialize s;
  assume
A3: I is_halting_on Initialize s;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = s +* Initialized I1;
  set s3 = s +* Initialized if>0(a,I,J);
  set s4 =  Computation( s3,1);
  set i = a >0_goto insloc (card J + 3);
A4: I1 +* Start-At insloc 0 c= s1 by FUNCT_4:26,SCMFSA6B:8;
A5: s1 is halting by A2,A3,SCMFSA8A:55;
  I1 is_closed_on Initialize s by A2,A3,SCMFSA8A:46;
  then
A6: I1 is_closed_on s1 by Th9;
A7: insloc 0 in dom if>0(a,I,J) by Lm2;
  if>0(a,I,J) c= Initialized if>0(a,I,J) by SCMFSA6A:26;
  then
A8: dom if>0(a,I,J) c= dom Initialized if>0(a,I,J) by GRFUNC_1:8;
  IC SCM+FSA in dom Initialized if>0(a,I,J) by SCMFSA6A:24;
  then
A9: IC s3 = (Initialized if>0(a,I,J)).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SCMFSA6A:46;
A10: s3.insloc 0 = (Initialized if>0(a,I,J)).insloc 0 by A7,A8,FUNCT_4:14
    .= if>0(a,I,J).insloc 0 by A7,SCMFSA6A:50
    .= i by Lm3;
A11:  Computation( s3,0 + 1) = Following  Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A9,A10;
A12: card (i ';' J ';' Goto insloc (card I + 1))
  = card (Macro i ';' J ';' Goto insloc (card I + 1)) by SCMFSA6A:def 6
    .= card (Macro i ';' J) + card Goto insloc (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by SCMFSA7B:6
    .= card J + (2 + 1);
A13: dom (s | A) = A by SCMFSA8A:3;
  not a in dom Initialized if>0(a,I,J) & a in dom s
  by SCMFSA6A:48,SCMFSA_2:66;
  then
A14: s3.a > 0 by A1,FUNCT_4:12;
A15: Initialized if>0(a,I,J) c= s3 by FUNCT_4:26;
  if>0(a,I,J) c= Initialized if>0(a,I,J) by SCMFSA6A:26;
  then
A16: if>0(a,I,J) c= s3 by A15,XBOOLE_1:1;
  if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67;
  then ProgramPart Relocated(I1,card J + 3) c= if>0(a,I,J) by A12,Lm1;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A16,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(I1,card J + 3)] c= s4 by AMI_1:99;
  then
A17: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
A18: IC  Computation(s3,1) = insloc (card J + 3) by A11,A14,SCMFSA_2:97;
A19: DataPart s1 = DataPart s3 by SCMFSA6A:39,53;
A20: now
    let a be Int-Location;
    thus s1.a = s3.a by A19,SCMFSA6A:38
      .= s4.a by A11,SCMFSA_2:97;
  end;
  now
    let f be FinSeq-Location;
    thus s1.f = s3.f by A19,SCMFSA6A:38
      .= s4.f by A11,SCMFSA_2:97;
  end;
  then
A21: DataPart s1 = DataPart s4 by A20,SCMFSA6A:38;
A22: CurInstr  Computation( s3,LifeSpan s1 + 1)
  = CurInstr  Computation( s4,LifeSpan s1) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s1,LifeSpan s1)),(card J + 3))
  by A4,A6,A17,A18,A21,Th11
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A5,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A23: s3 is halting by AMI_1:def 20;
  now
    let l be Element of NAT;
    assume
A24: l < LifeSpan s1 + 1;
    per cases;
    suppose l = 0;
      then CurInstr  Computation( s3,l) = CurInstr s3 by AMI_1:13;
      hence CurInstr  Computation( s3,l) <> halt SCM+FSA by A9,A10,SCMFSA_2:49
,124;
    end;
    suppose l <> 0;
      then consider n being Nat such that
A25:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A26:  n < LifeSpan s1 by A24,A25,XREAL_1:8;
      assume
A27:  CurInstr  Computation( s3,l) = halt SCM+FSA;
      InsCode CurInstr  Computation( s1,n)
      = InsCode IncAddr(CurInstr  Computation( s1,n),(card J + 3))
      by SCMFSA_4:22
        .= InsCode CurInstr  Computation( s4,n) by A4,A6,A17,A18,A21,Th11
        .= 0 by A25,A27,AMI_1:51,SCMFSA_2:124;
      then CurInstr  Computation( s1,n) = halt SCM+FSA by SCMFSA_2:122;
      hence contradiction by A5,A26,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr  Computation( s3,l) = halt SCM+FSA
  holds LifeSpan s1 + 1 <= l;
  then
A28: LifeSpan s3 = LifeSpan s1 + 1 by A22,A23,AMI_1:def 46;
A29: DataPart Result s1
     = DataPart Computation( s1,LifeSpan s1) by A2,A3,AMI_1:122,SCMFSA8A:55
    .= DataPart Computation( s4,LifeSpan s1) by A4,A6,A17,A18,A21,Th11
    .= DataPart Computation( s3,LifeSpan s1 + 1) by AMI_1:51
    .= DataPart Result s3 by A23,A28,AMI_1:122;
A30: dom IExec(if>0(a,I,J),s) = the carrier of SCM+FSA by AMI_1:79
    .= dom (IExec(I1,s) +* Start-At insloc (card I + card J + 3)) by AMI_1:79;
  now
    let x be set;
A31: now
      assume x in dom (s | A);
      then x in A by RELAT_1:86;
      hence x is Instruction-Location of SCM+FSA by AMI_1:def 4;
    end;
A32: IExec(I1,s) = Result s1 +* s | A by SCMFSA6B:def 1;
A33: IExec(if>0(a,I,J),s) = (Result s3) +* (s | A) by SCMFSA6B:def 1;
    assume
A34: x in dom IExec(if>0(a,I,J),s);
A35: dom Start-At insloc (card I + card J + 3) = {IC SCM+FSA} by FUNCOP_1:19;
    per cases by A34,SCMFSA6A:35;
    suppose
A36:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A37:  x in dom IExec(I1,s) &
      not x in dom Start-At insloc (card I + card J + 3)
      by A35,A36,SCMFSA_2:66,TARSKI:def 1;
      thus IExec(if>0(a,I,J),s).x
      = (Result s3).x by A31,A33,A36,FUNCT_4:12,SCMFSA_2:84
        .= (Result s1).x by A29,A36,SCMFSA6A:38
        .= IExec(I1,s).x by A31,A32,A36,FUNCT_4:12,SCMFSA_2:84
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x
      by A37,FUNCT_4:12;
    end;
    suppose
A38:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A39:  x in dom IExec(I1,s) &
      not x in dom Start-At insloc (card I + card J + 3)
      by A35,A38,SCMFSA_2:67,TARSKI:def 1;
      thus IExec(if>0(a,I,J),s).x
      = (Result s3).x by A31,A33,A38,FUNCT_4:12,SCMFSA_2:85
        .= (Result s1).x by A29,A38,SCMFSA6A:38
        .= IExec(I1,s).x by A31,A32,A38,FUNCT_4:12,SCMFSA_2:85
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x
      by A39,FUNCT_4:12;
    end;
    suppose
A40:  x = IC SCM+FSA;
      then
A41:  x in dom Start-At insloc (card I + card J + 3) by A35,TARSKI:def 1;
A42:  IC Result s1 = IExec(I1,s).IC SCM+FSA by A31,A32,A40,AMI_1:48,FUNCT_4:12
        .= IC (IExec(I,s) +* Start-At insloc card I) by A2,A3,SCMFSA8A:57
        .= insloc card I by AMI_1:111;
      thus IExec(if>0(a,I,J),s).x
      = (Result s3).x by A31,A33,A40,AMI_1:48,FUNCT_4:12
        .=  Computation( s3,LifeSpan s1 + 1).x by A23,A28,AMI_1:122
        .= IC  Computation( s4,LifeSpan s1) by A40,AMI_1:51
        .= IC  Computation( s1,LifeSpan s1) + (card J + 3)
      by A4,A6,A17,A18,A21,Th11
        .= IC Result s1 + (card J + 3) by A2,A3,AMI_1:122,SCMFSA8A:55
        .= (Start-At (insloc card I + (card J + 3))).IC SCM+FSA by A42,
FUNCOP_1:87
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x
      by A40,A41,FUNCT_4:14;
    end;
    suppose
A43:  x is Instruction-Location of SCM+FSA;
      then x <> IC SCM+FSA by AMI_1:48;
      then
A44:  x in dom IExec(I1,s) &
      not x in dom Start-At insloc (card I + card J + 3)
      by A35,A43,Th2,TARSKI:def 1;
A45:  x in NAT by A43,AMI_1:def 4;
      hence IExec(if>0(a,I,J),s).x = (s | A).x by A13,A33,FUNCT_4:14
        .= IExec(I1,s).x by A13,A32,A45,FUNCT_4:14
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x
      by A44,FUNCT_4:12;
    end;
  end;
  hence IExec(if>0(a,I,J),s)
  = IExec(I1,s) +* Start-At insloc (card I + card J + 3) by A30,FUNCT_1:9
    .= IExec(I,s) +* Start-At insloc card I
  +* Start-At insloc (card I + card J + 3) by A2,A3,SCMFSA8A:57
    .= IExec(I,s) +* Start-At insloc (card I + card J + 3) by AMI_1:141;
end;

theorem Th24: ::ThIFg0_2'
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a <= 0 & J is_closed_on s & J is_halting_on s holds
  if>0(a,I,J) is_closed_on s & if>0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a <= 0;
  assume
A2: J is_closed_on s;
  assume
A3: J is_halting_on s;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = s +* (JI2 +* Start-At insloc 0);
  set s3 = s +* (if>0(a,I,J) +* Start-At insloc 0);
  set s4 =  Computation( s3,1);
  set s5 =   Computation(s3,2);
  set i = a >0_goto insloc (card J + 3);
A4: JI2 +* Start-At insloc 0 c= s2 by FUNCT_4:26;
A5: s2 is halting by A2,A3,SCMFSA8A:59;
A6: JI2 is_closed_on s by A2,A3,SCMFSA8A:58;
  then
A7: JI2 is_closed_on s2 by Th10;
A8: insloc 0 in dom if>0(a,I,J) by Lm2;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A9: dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
  IC SCM+FSA in dom (if>0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
  then
A10: IC s3 = (if>0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A11: s3.insloc 0 = (if>0(a,I,J) +* Start-At insloc 0).insloc 0 by A8,A9,
FUNCT_4:14
    .= if>0(a,I,J).insloc 0 by A8,SCMFSA6B:7
    .= i by Lm3;
A12:  Computation( s3,0 + 1) = Following  Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A10,A11;
  not a in dom (if>0(a,I,J) +* Start-At insloc 0) & a in dom s
  by SCMFSA6B:12,SCMFSA_2:66;
  then
A13: s3.a <= 0 by A1,FUNCT_4:12;
A14: if>0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A15: if>0(a,I,J) c= s3 by A14,XBOOLE_1:1;
A16: if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' JI2 by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:def 6;
  then ProgramPart Relocated(JI2,card Macro i) c= if>0(a,I,J) by Lm1;
  then ProgramPart Relocated(JI2,2) c= if>0(a,I,J) by SCMFSA7B:6;
  then ProgramPart Relocated(JI2,2) c= s3 by A15,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(JI2,2)] c= s5 by AMI_1:99;
  then
A17: ProgramPart Relocated(JI2,2) c= s5 by AMI_1:105;
A18: IC  Computation(s3,1) = Next insloc 0 by A10,A12,A13,SCMFSA_2:97
    .= insloc (0 + 1);
A19: insloc 1 in dom if>0(a,I,J) by Lm2;
A20:  Computation(s3,1).insloc 1 = s3.insloc 1 by AMI_1:54
    .= (if>0(a,I,J) +* Start-At insloc 0).insloc 1 by A9,A19,FUNCT_4:14
    .= if>0(a,I,J).insloc 1 by A19,SCMFSA6B:7
    .= goto insloc 2 by Lm3;
A21:  Computation( s3,1 + 1) = Following s4 by AMI_1:14
    .= Exec(goto insloc 2,s4) by A18,A20;
  then
A22: IC s5 = insloc 2 by SCMFSA_2:95;
A23: DataPart s2 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A24: now
    let a be Int-Location;
    thus s2.a = s3.a by A23,SCMFSA6A:38
      .=  Computation(s3,1).a by A12,SCMFSA_2:97
      .= s5.a by A21,SCMFSA_2:95;
  end;
  now
    let f be FinSeq-Location;
    thus s2.f = s3.f by A23,SCMFSA6A:38
      .=  Computation(s3,1).f by A12,SCMFSA_2:97
      .= s5.f by A21,SCMFSA_2:95;
  end;
  then
A25: DataPart s2 = DataPart s5 by A24,SCMFSA6A:38;
  CurInstr  Computation( s3,LifeSpan s2 + 2)
  = CurInstr  Computation( s5,LifeSpan s2) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s2,LifeSpan s2)),2)
  by A4,A7,A17,A22,A25,Th11
    .= IncAddr(halt SCM+FSA,2) by A5,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A26: s3 is halting by AMI_1:def 20;
  now
    let k be Element of NAT;
    k = 0 or 0 + 1 < k + 1 by XREAL_1:8;
    then
A27: k = 0 or 1 <= k by NAT_1:13;
    per cases by A27,XXREAL_0:1;
    suppose
A28:  1 < k;
      then consider k1 being Nat such that
A29:  k1 + 1 = k by NAT_1:6;
      0 + 1 < k1 + 1 by A28,A29;
      then consider k2 being Nat such that
A30:  k2 + 1 = k1 by NAT_1:6;
      reconsider k1,k2 as Element of NAT by ORDINAL1:def 13;
  reconsider m = IC  Computation( s2,k2) as Element of NAT by ORDINAL1:def 13;
A32:  card if>0(a,I,J) = card Macro i + card JI2 by A16,SCMFSA6A:61
        .= 2 + card JI2 by SCMFSA7B:6;
      insloc m in dom JI2 by A6,SCMFSA7B:def 7;
      then m < card JI2 by SCMFSA6A:15;
      then
A33:  m + 2 < card if>0(a,I,J) by A32,XREAL_1:8;
      IC  Computation(s3,k) = IC  Computation( s4,k1) by A29,AMI_1:51
        .= IC  Computation(  Computation( s4,1),k2) by A30,AMI_1:51
        .= IC  Computation(  Computation( s3,1 + 1),k2) by AMI_1:51
        .= insloc (m + 2) by A4,A7,A17,A22,A25,Th11;
      hence IC  Computation(s3,k) in dom if>0(a,I,J) by A33,SCMFSA6A:15;
    end;
    suppose k = 0;
      hence IC  Computation(s3,k) in dom if>0(a,I,J) by A8,A10,AMI_1:13;
    end;
    suppose k = 1;
      hence IC  Computation(s3,k) in dom if>0(a,I,J) by A18,Lm2;
    end;
  end;
  hence if>0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
  thus thesis by A26,SCMFSA7B:def 8;
end;

theorem Th25: ::ThIFg0_2(@BBB8)
  for I,J being Program of SCM+FSA, a being read-write Int-Location holds
  for s being State of SCM+FSA

st s.a <= 0 & J is_closed_on Initialize s & J is_halting_on Initialize s holds
  IExec(if>0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card I + card J + 3)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  assume
A1: s.a <= 0;
  assume
A2: J is_closed_on Initialize s;
  assume
A3: J is_halting_on Initialize s;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = s +* Initialized JI2;
  set s3 = s +* Initialized if>0(a,I,J);
  set s4 =  Computation( s3,1);
  set s5 =   Computation(s3,2);
  set i = a >0_goto insloc (card J + 3);
A4: JI2 +* Start-At insloc 0 c= s2 by FUNCT_4:26,SCMFSA6B:8;
A5: s2 is halting by A2,A3,SCMFSA8A:60;
  JI2 is_closed_on Initialize s by A2,A3,SCMFSA8A:58;
  then
A6: JI2 is_closed_on s2 by Th9;
A7: insloc 0 in dom if>0(a,I,J) by Lm2;
  if>0(a,I,J) c= Initialized if>0(a,I,J) by SCMFSA6A:26;
  then
A8: dom if>0(a,I,J) c= dom Initialized if>0(a,I,J) by GRFUNC_1:8;
  IC SCM+FSA in dom Initialized if>0(a,I,J) by SCMFSA6A:24;
  then
A9: IC s3 = (Initialized if>0(a,I,J)).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SCMFSA6A:46;
A10: s3.insloc 0 = (Initialized if>0(a,I,J)).insloc 0 by A7,A8,FUNCT_4:14
    .= if>0(a,I,J).insloc 0 by A7,SCMFSA6A:50
    .= i by Lm3;
A11:  Computation( s3,0 + 1) = Following  Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A9,A10;
A12: dom (s | A) = dom s /\ A by RELAT_1:90
    .= (D \/ {IC SCM+FSA} \/ A) /\ A by SCMFSA6A:34
    .= A by XBOOLE_1:21;
  not a in dom Initialized if>0(a,I,J) & a in dom s
  by SCMFSA6A:48,SCMFSA_2:66;
  then
A13: s3.a <= 0 by A1,FUNCT_4:12;
A14: Initialized if>0(a,I,J) c= s3 by FUNCT_4:26;
  if>0(a,I,J) c= Initialized if>0(a,I,J) by SCMFSA6A:26;
  then
A15: if>0(a,I,J) c= s3 by A14,XBOOLE_1:1;
  if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' JI2 by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:def 6;
  then ProgramPart Relocated(JI2,card Macro i) c= if>0(a,I,J) by Lm1;
  then ProgramPart Relocated(JI2,2) c= if>0(a,I,J) by SCMFSA7B:6;
  then ProgramPart Relocated(JI2,2) c= s3 by A15,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(JI2,2)] c= s5 by AMI_1:99;
  then
A16: ProgramPart Relocated(JI2,2) c= s5 by AMI_1:105;
A17: IC  Computation(s3,1) = Next insloc 0 by A9,A11,A13,SCMFSA_2:97
    .= insloc (0 + 1);
A18: insloc 1 in dom if>0(a,I,J) by Lm2;
A19:  Computation(s3,1).insloc 1 = s3.insloc 1 by AMI_1:54
    .= (Initialized if>0(a,I,J)).insloc 1 by A8,A18,FUNCT_4:14
    .= if>0(a,I,J).insloc 1 by A18,SCMFSA6A:50
    .= goto insloc 2 by Lm3;
A20:  Computation( s3,1 + 1) = Following s4 by AMI_1:14
    .= Exec(goto insloc 2,s4) by A17,A19;
  then
A21: IC s5 = insloc 2 by SCMFSA_2:95;
A22: DataPart s2 = DataPart s3 by SCMFSA6A:39,53;
A23: now
    let a be Int-Location;
    thus s2.a = s3.a by A22,SCMFSA6A:38
      .=  Computation(s3,1).a by A11,SCMFSA_2:97
      .= s5.a by A20,SCMFSA_2:95;
  end;
  now
    let f be FinSeq-Location;
    thus s2.f = s3.f by A22,SCMFSA6A:38
      .=  Computation(s3,1).f by A11,SCMFSA_2:97
      .= s5.f by A20,SCMFSA_2:95;
  end;
  then
A24: DataPart s2 = DataPart s5 by A23,SCMFSA6A:38;
A25: CurInstr  Computation( s3,LifeSpan s2 + 2)
  = CurInstr  Computation( s5,LifeSpan s2) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s2,LifeSpan s2)),2)
  by A4,A6,A16,A21,A24,Th11
    .= IncAddr(halt SCM+FSA,2) by A5,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A26: s3 is halting by AMI_1:def 20;
  now
    let l be Element of NAT;
    assume
A27: l < LifeSpan s2 + 2;
    per cases;
    suppose l = 0;
      then CurInstr  Computation( s3,l) = CurInstr s3 by AMI_1:13;
      hence CurInstr  Computation( s3,l) <> halt SCM+FSA by A9,A10,SCMFSA_2:49
,124;
    end;
    suppose l = 1;
      hence CurInstr  Computation( s3,l) <> halt SCM+FSA by A17,A19,SCMFSA_2:47
,124;
    end;
    suppose
A28:  l <> 0 & l <> 1;
      then consider n being Nat such that
A29:  l = n + 1 by NAT_1:6;
      n + 1 < LifeSpan s2 + 1 + 1 by A27,A29;
      then
A30:  n < LifeSpan s2 + 1 by XREAL_1:8;
      n <> 0 by A28,A29;
      then consider l2 being Nat such that
A31:  n = l2 + 1 by NAT_1:6;
      reconsider l2 as Element of NAT by ORDINAL1:def 13;
A32:  l2 < LifeSpan s2 by A30,A31,XREAL_1:8;
      assume
A33:  CurInstr  Computation( s3,l) = halt SCM+FSA;
      InsCode CurInstr  Computation( s2,l2)
      = InsCode IncAddr(CurInstr  Computation( s2,l2),2) by SCMFSA_4:22
        .= InsCode CurInstr  Computation( s5,l2) by A4,A6,A16,A21,A24,Th11
        .= InsCode CurInstr  Computation( s3,l2 + (1 + 1)) by AMI_1:51
        .= 0 by A29,A31,A33,SCMFSA_2:124;
      then CurInstr  Computation( s2,l2) = halt SCM+FSA by SCMFSA_2:122;
      hence contradiction by A5,A32,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr  Computation( s3,l) = halt SCM+FSA
  holds LifeSpan s2 + 2 <= l;
  then
A34: LifeSpan s3 = LifeSpan s2 + 2 by A25,A26,AMI_1:def 46;
A35: DataPart Result s2
     = DataPart Computation( s2,LifeSpan s2) by A2,A3,AMI_1:122,SCMFSA8A:60
    .= DataPart Computation( s5,LifeSpan s2) by A4,A6,A16,A21,A24,Th11
    .= DataPart Computation( s3,LifeSpan s2 + 2) by AMI_1:51
    .= DataPart Result s3 by A26,A34,AMI_1:122;
A36: dom IExec(if>0(a,I,J),s) = the carrier of SCM+FSA by AMI_1:79
    .= dom (IExec(JI2,s) +* Start-At insloc (card I + card J + 3))
  by AMI_1:79;
  now
    let x be set;
A37: now
      assume x in dom (s | A);
      then x in A by RELAT_1:86;
      hence x is Instruction-Location of SCM+FSA by AMI_1:def 4;
    end;
A38: IExec(JI2,s) = Result s2 +* s | A by SCMFSA6B:def 1;
A39: IExec(if>0(a,I,J),s) = (Result s3) +* (s | A) by SCMFSA6B:def 1;
    assume
A40: x in dom IExec(if>0(a,I,J),s);
A41: dom Start-At insloc (card I + card J + 3) = {IC SCM+FSA} by FUNCOP_1:19;
    per cases by A40,SCMFSA6A:35;
    suppose
A42:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A43:  x in dom IExec(JI2,s) &
      not x in dom Start-At insloc (card I + card J + 3)
      by A41,A42,SCMFSA_2:66,TARSKI:def 1;
      thus IExec(if>0(a,I,J),s).x
      = (Result s3).x by A37,A39,A42,FUNCT_4:12,SCMFSA_2:84
        .= (Result s2).x by A35,A42,SCMFSA6A:38
        .= IExec(JI2,s).x by A37,A38,A42,FUNCT_4:12,SCMFSA_2:84
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x
      by A43,FUNCT_4:12;
    end;
    suppose
A44:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A45:  x in dom IExec(JI2,s) &
      not x in dom Start-At insloc (card I + card J + 3)
      by A41,A44,SCMFSA_2:67,TARSKI:def 1;
      thus IExec(if>0(a,I,J),s).x
      = (Result s3).x by A37,A39,A44,FUNCT_4:12,SCMFSA_2:85
        .= (Result s2).x by A35,A44,SCMFSA6A:38
        .= IExec(JI2,s).x by A37,A38,A44,FUNCT_4:12,SCMFSA_2:85
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x
      by A45,FUNCT_4:12;
    end;
    suppose
A46:  x = IC SCM+FSA;
      then
A47:  x in dom Start-At insloc (card I + card J + 3) by A41,TARSKI:def 1;
A48:  IC Result s2 = IC IExec(JI2,s) by A37,A38,A46,AMI_1:48,FUNCT_4:12
        .= insloc (card I + card J + 1) by A2,A3,SCMFSA8A:61;
      thus IExec(if>0(a,I,J),s).x
      = (Result s3).x by A37,A39,A46,AMI_1:48,FUNCT_4:12
        .=  Computation( s3,LifeSpan s2 + 2).x by A26,A34,AMI_1:122
        .= IC  Computation( s5,LifeSpan s2) by A46,AMI_1:51
        .= IC  Computation( s2,LifeSpan s2) + 2 by A4,A6,A16,A21,A24,Th11
        .= IC Result s2 + 2 by A2,A3,AMI_1:122,SCMFSA8A:60
        .= (Start-At (insloc (card I + card J + 1) + 2)).IC SCM+FSA
      by A48,FUNCOP_1:87
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x
      by A46,A47,FUNCT_4:14;
    end;
    suppose
A49:  x is Instruction-Location of SCM+FSA;
      then x <> IC SCM+FSA by AMI_1:48;
      then
A50:  x in dom IExec(JI2,s) &
      not x in dom Start-At insloc (card I + card J + 3)
      by A41,A49,Th2,TARSKI:def 1;
A51:  x in NAT by A49,AMI_1:def 4;
      hence IExec(if>0(a,I,J),s).x = (s | A).x by A12,A39,FUNCT_4:14
        .= IExec(JI2,s).x by A12,A38,A51,FUNCT_4:14
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x
      by A50,FUNCT_4:12;
    end;
  end;
  hence IExec(if>0(a,I,J),s)
  = IExec(JI2,s) +* Start-At insloc (card I + card J + 3) by A36,FUNCT_1:9
    .= IExec(J,s) +* Start-At insloc (card I + card J + 1)
  +* Start-At insloc (card I + card J + 3) by A2,A3,SCMFSA8A:62
    .= IExec(J,s) +* Start-At insloc (card I + card J + 3) by AMI_1:141;
end;

theorem Th26: ::ThIFg0(@BBB8)
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA,
  a being read-write Int-Location holds if>0(a,I,J) is parahalting &
  (s.a > 0 implies IExec(if>0(a,I,J),s) =
  IExec(I,s) +* Start-At insloc (card I + card J + 3)) &
  (s.a <= 0 implies IExec(if>0(a,I,J),s) =
  IExec(J,s) +* Start-At insloc (card I + card J + 3))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
A1: I is_closed_on Initialize s & I is_halting_on Initialize s
  by SCMFSA7B:24,25;
A2: J is_closed_on Initialize s & J is_halting_on Initialize s
  by SCMFSA7B:24,25;
  now
    let s be State of SCM+FSA;
    assume if>0(a,I,J) +* Start-At insloc 0 c= s;
    then
A3: s = s +* (if>0(a,I,J) +* Start-At insloc 0) by FUNCT_4:79;
A4: I is_closed_on s & I is_halting_on s by SCMFSA7B:24,25;
A5: J is_closed_on s & J is_halting_on s by SCMFSA7B:24,25;
    per cases;
    suppose s.a > 0;
      then if>0(a,I,J) is_halting_on s by A4,Th22;
      hence s is halting by A3,SCMFSA7B:def 8;
    end;
    suppose s.a <= 0;
      then if>0(a,I,J) is_halting_on s by A5,Th24;
      hence s is halting by A3,SCMFSA7B:def 8;
    end;
  end;
  then if>0(a,I,J) +* Start-At insloc 0 is halting by AMI_1:def 26;
  hence if>0(a,I,J) is parahalting by SCMFSA6B:def 3;
  thus s.a > 0 implies IExec(if>0(a,I,J),s) =
  IExec(I,s) +* Start-At insloc (card I + card J + 3) by A1,Th23;
  thus thesis by A2,Th25;
end;

theorem Th27: ::ThIFg0'
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA,
  a being read-write Int-Location holds
  IC IExec(if>0(a,I,J),s) = insloc (card I + card J + 3) & (s.a > 0 implies
  ((for d being Int-Location holds IExec(if>0(a,I,J),s).d = IExec(I,s).d) &
  for f being FinSeq-Location holds IExec(if>0(a,I,J),s).f = IExec(I,s).f)) &
  (s.a <= 0 implies ((for d being Int-Location holds
  IExec(if>0(a,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if>0(a,I,J),s).f = IExec(J,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby per cases;
    suppose s.a > 0;
      then IExec(if>0(a,I,J),s) =
      IExec(I,s) +* Start-At insloc (card I + card J + 3) by Th26;
      hence IC IExec(if>0(a,I,J),s) = insloc (card I + card J + 3)
      by AMI_1:111;
    end;
    suppose s.a <= 0;
      then IExec(if>0(a,I,J),s) =
      IExec(J,s) +* Start-At insloc (card I + card J + 3) by Th26;
      hence IC IExec(if>0(a,I,J),s) = insloc (card I + card J + 3)
      by AMI_1:111;
    end;
  end;
  hereby
    assume s.a > 0;
    then
A1: IExec(if>0(a,I,J),s) =
    IExec(I,s) +* Start-At insloc (card I + card J + 3) by Th26;
    hereby
      let d be Int-Location;
      not d in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:9;
      hence IExec(if>0(a,I,J),s).d = IExec(I,s).d by A1,FUNCT_4:12;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:10;
    hence IExec(if>0(a,I,J),s).f = IExec(I,s).f by A1,FUNCT_4:12;
  end;
  assume s.a <= 0;
  then
A2: IExec(if>0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card I + card J + 3)
  by Th26;
  hereby
    let d be Int-Location;
    not d in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:9;
    hence IExec(if>0(a,I,J),s).d = IExec(J,s).d by A2,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:10;
  hence thesis by A2,FUNCT_4:12;
end;

theorem  ::ThIFl0_1' -- ???
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a < 0 & I is_closed_on s & I is_halting_on s holds
  if<0(a,I,J) is_closed_on s & if<0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a < 0;
  assume I is_closed_on s & I is_halting_on s;
  then if>0(a,J,I) is_closed_on s & if>0(a,J,I) is_halting_on s by A1,Th24;
  hence thesis by A1,Th18;
end;

theorem Th29: ::ThIFl0_1(@BBB8)
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a < 0 & I is_closed_on Initialize s & I is_halting_on Initialize s holds
  IExec(if<0(a,I,J),s) =
  IExec(I,s) +* Start-At insloc (card I + card J + card J + 7)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a < 0;
  assume
A2: I is_closed_on Initialize s & I is_halting_on Initialize s;
  (Initialize s).a <= 0 by A1,SCMFSA6C:3;
  then if>0(a,J,I) is_closed_on Initialize s &
  if>0(a,J,I) is_halting_on Initialize s by A2,Th24;
  hence IExec(if<0(a,I,J),s)
  = IExec(if>0(a,J,I),s) +* Start-At insloc (card if>0(a,J,I) + card J + 3)
  by A1,Th19
    .= IExec(if>0(a,J,I),s) +* Start-At insloc (card I + card J + 4 +
  card J + 3) by Th15
    .= IExec(I,s) +* Start-At insloc (card I + card J + 3) +*
  Start-At insloc (card I + card J + 4 + card J + 3) by A1,A2,Th25
    .= IExec(I,s) +* Start-At insloc (card I + card J + card J + 7)
     by AMI_1:141;
end;

theorem  ::ThIFl0_2' --- ??
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a = 0 & J is_closed_on s & J is_halting_on s holds
  if<0(a,I,J) is_closed_on s & if<0(a,I,J) is_halting_on s by Th16;

theorem Th31: ::ThIFl0_2(@BBB8)
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a = 0 & J is_closed_on Initialize s & J is_halting_on Initialize s holds
  IExec(if<0(a,I,J),s) =
  IExec(J,s) +* Start-At insloc (card I + card J + card J + 7)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  assume J is_closed_on Initialize s & J is_halting_on Initialize s;
  hence IExec(if<0(a,I,J),s)
  = IExec(J,s) +* Start-At insloc (card if>0(a,J,I) + card J + 3) by A1,Th17
    .= IExec(J,s) +* Start-At insloc (card I + card J + 4 + card J + 3) by Th15
    .= IExec(J,s) +* Start-At insloc (card I + card J + card J + 7);
end;

theorem  ::ThIFl0_3' --- ???
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a > 0 & J is_closed_on s & J is_halting_on s holds
  if<0(a,I,J) is_closed_on s & if<0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  assume J is_closed_on s & J is_halting_on s;
  then if>0(a,J,I) is_closed_on s & if>0(a,J,I) is_halting_on s by A1,Th22;
  hence thesis by A1,Th18;
end;

theorem Th33: ::ThIFl0_3(@BBB8)
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  a being read-write Int-Location
  st s.a > 0 & J is_closed_on Initialize s & J is_halting_on Initialize s holds
  IExec(if<0(a,I,J),s) =
  IExec(J,s) +* Start-At insloc (card I + card J + card J + 7)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  assume
A2: J is_closed_on Initialize s & J is_halting_on Initialize s;
  (Initialize s).a > 0 by A1,SCMFSA6C:3;
  then if>0(a,J,I) is_closed_on Initialize s &
  if>0(a,J,I) is_halting_on Initialize s by A2,Th22;
  hence IExec(if<0(a,I,J),s)
  = IExec(if>0(a,J,I),s) +* Start-At insloc (card if>0(a,J,I) + card J + 3)
  by A1,Th19
    .= IExec(if>0(a,J,I),s) +* Start-At insloc (card I + card J + 4 +
  card J + 3) by Th15
    .= IExec(J,s) +* Start-At insloc (card I + card J + 3) +*
  Start-At insloc (card I + card J + 4 + card J + 3) by A1,A2,Th23
    .= IExec(J,s) +* Start-At insloc (card I + card J + card J + 7)
     by AMI_1:141;
end;

theorem  ::ThIFl0(@BBB8)
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA,
  a being read-write Int-Location holds (if<0(a,I,J) is parahalting &
  (s.a < 0 implies IExec(if<0(a,I,J),s) =
  IExec(I,s) +* Start-At insloc (card I + card J + card J + 7)) &
  (s.a >= 0 implies IExec(if<0(a,I,J),s) =
  IExec(J,s) +* Start-At insloc (card I + card J + card J + 7)))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  if>0(a,J,I) is parahalting by Th26;
  hence if<0(a,I,J) is parahalting by Th20;
  hereby
    assume
A1: s.a < 0;
    I is_closed_on Initialize s & I is_halting_on Initialize s
    by SCMFSA7B:24,25;
    hence IExec(if<0(a,I,J),s) =
    IExec(I,s) +* Start-At insloc (card I + card J + card J + 7) by A1,Th29;
  end;
  hereby
    assume
A2: s.a >= 0;
A3: J is_closed_on Initialize s & J is_halting_on Initialize s
    by SCMFSA7B:24,25;
    per cases;
    suppose s.a = 0;
      hence IExec(if<0(a,I,J),s) =
      IExec(J,s) +* Start-At insloc (card I + card J + card J + 7) by A3,Th31;
    end;
    suppose s.a <> 0;
      hence IExec(if<0(a,I,J),s) =
      IExec(J,s) +* Start-At insloc (card I + card J + card J + 7)
      by A2,A3,Th33;
    end;
  end;
end;

registration
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  cluster if=0(a,I,J) -> parahalting;
  correctness by Th20;
  cluster if>0(a,I,J) -> parahalting;
  correctness by Th26;
end;

definition
  let a,b be Int-Location;
  let I,J be Program of SCM+FSA;
  func if=0(a,b,I,J) -> Program of SCM+FSA equals

  SubFrom(a,b) ';' if=0(a,I,J);
  coherence;
  func if>0(a,b,I,J) -> Program of SCM+FSA equals

  SubFrom(a,b) ';' if>0(a,I,J);
  coherence;
end;

notation
  let a,b be Int-Location;
  let I,J be Program of SCM+FSA;
  synonym if<0(b,a,I,J) for if>0(a,b,I,J);
end;

registration
  let I,J be parahalting Program of SCM+FSA;
  let a,b be read-write Int-Location;
  cluster if=0(a,b,I,J) -> parahalting;
  correctness;
  cluster if>0(a,b,I,J) -> parahalting;
  correctness;
end;

theorem Th35: ::PRE8'90'(@AAAA)
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  DataPart Result (s +* Initialized I) = DataPart IExec(I,s)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
A1: IExec(I,s) = Result s1 +* s | A by SCMFSA6B:def 1;
A2: now
    let b be Int-Location;
    now
      assume b in dom (s | A);
      then b in A by RELAT_1:86;
      hence b is Instruction-Location of SCM+FSA by AMI_1:def 4;
    end;
    hence IExec(I,s).b = (Result s1).b by A1,FUNCT_4:12,SCMFSA_2:84;
  end;
  now
    let f be FinSeq-Location;
    now
      assume f in dom (s | A);
      then f in A by RELAT_1:86;
      hence f is Instruction-Location of SCM+FSA by AMI_1:def 4;
    end;
    hence IExec(I,s).f = (Result s1).f by A1,FUNCT_4:12,SCMFSA_2:85;
  end;
  hence thesis by A2,SCMFSA6A:38;
end;

theorem Th36: ::PRE8'91(@AAAA)
  for s being State of SCM+FSA, I being Program of SCM+FSA,
  a being Int-Location holds
  Result (s +* Initialized I),IExec(I,s) equal_outside NAT
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  set s1 = s +* Initialized I;
  DataPart Result s1 = DataPart IExec(I,s) by Th35;
  then
A1: (for a being Int-Location holds (Result s1).a = IExec(I,s).a) &
  for f being FinSeq-Location holds (Result s1).f = IExec(I,s).f
  by SCMFSA6A:38;
  IC Result s1 = IC IExec(I,s) by SCMFSA8A:7;
  hence thesis by A1,SCMFSA6A:28;
end;

theorem Th37: ::T81'
  for s1,s2 being State of SCM+FSA, i being Instruction of SCM+FSA,
  a being Int-Location holds
  (for b being Int-Location st a <> b holds s1.b = s2.b) &
  (for f being FinSeq-Location holds s1.f = s2.f) &
  i does_not_refer a & IC s1 = IC s2 implies
  (for b being Int-Location st a <> b holds Exec(i,s1).b = Exec(i,s2).b) &
  (for f being FinSeq-Location holds Exec(i,s1).f = Exec(i,s2).f) &
  IC Exec(i,s1) = IC Exec(i,s2)
proof
  let s1,s2 be State of SCM+FSA;
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  defpred S[State of SCM+FSA,State of SCM+FSA] means
  (for b being Int-Location st a <> b holds $1.b = $2.b) &
  for f being FinSeq-Location holds $1.f = $2.f;
  assume
A1: S[s1,s2];
  assume
A2: i does_not_refer a;
  assume
A3: IC s1 = IC s2;
A4: InsCode i <= 11+1 by SCMFSA_2:35;
A5: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A6: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
A7: now
    let b be Int-Location;
    assume
A8: a <> b;
    per cases by A4,A5,A6,NAT_1:8,33;
    suppose InsCode i = 0;
      then
A9:   i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s1).b = s1.b by AMI_1:def 8
        .= s2.b by A1,A8
        .= Exec(i,s2).b by A9,AMI_1:def 8;
    end;
    suppose InsCode i = 1;
      then consider da, db being Int-Location such that
A10:  i = da := db by SCMFSA_2:54;
A11:  a <> db by A2,A10,SCMFSA7B:def 1;
      hereby per cases;
        suppose
A12:      b = da;
          hence Exec(i,s1).b = s1.db by A10,SCMFSA_2:89
            .= s2.db by A1,A11
            .= Exec(i,s2).b by A10,A12,SCMFSA_2:89;
        end;
        suppose
A13:      b <> da;
          hence Exec(i,s1).b = s1.b by A10,SCMFSA_2:89
            .= s2.b by A1,A8
            .= Exec(i,s2).b by A10,A13,SCMFSA_2:89;
        end;
      end;
    end;
    suppose InsCode i = 2;
      then consider da, db being Int-Location such that
A14:  i = AddTo(da,db) by SCMFSA_2:55;
A15:  a <> db by A2,A14,SCMFSA7B:def 1;
      hereby per cases;
        suppose
A16:      b = da;
          hence Exec(i,s1).b = s1.b + s1.db by A14,SCMFSA_2:90
            .= s2.b + s1.db by A1,A8
            .= s2.b + s2.db by A1,A15
            .= Exec(i,s2).b by A14,A16,SCMFSA_2:90;
        end;
        suppose
A17:      b <> da;
          hence Exec(i,s1).b = s1.b by A14,SCMFSA_2:90
            .= s2.b by A1,A8
            .= Exec(i,s2).b by A14,A17,SCMFSA_2:90;
        end;
      end;
    end;
    suppose InsCode i = 3;
      then consider da, db being Int-Location such that
A18:  i = SubFrom(da, db) by SCMFSA_2:56;
A19:  a <> db by A2,A18,SCMFSA7B:def 1;
      hereby per cases;
        suppose
A20:      b = da;
          hence Exec(i,s1).b = s1.b - s1.db by A18,SCMFSA_2:91
            .= s2.b - s1.db by A1,A8
            .= s2.b - s2.db by A1,A19
            .= Exec(i,s2).b by A18,A20,SCMFSA_2:91;
        end;
        suppose
A21:      b <> da;
          hence Exec(i,s1).b = s1.b by A18,SCMFSA_2:91
            .= s2.b by A1,A8
            .= Exec(i,s2).b by A18,A21,SCMFSA_2:91;
        end;
      end;
    end;
    suppose InsCode i = 4;
      then consider da, db being Int-Location such that
A22:  i = MultBy(da,db) by SCMFSA_2:57;
A23:  a <> db by A2,A22,SCMFSA7B:def 1;
      hereby per cases;
        suppose
A24:      b = da;
          hence Exec(i,s1).b = s1.b * s1.db by A22,SCMFSA_2:92
            .= s2.b * s1.db by A1,A8
            .= s2.b * s2.db by A1,A23
            .= Exec(i,s2).b by A22,A24,SCMFSA_2:92;
        end;
        suppose
A25:      b <> da;
          hence Exec(i,s1).b = s1.b by A22,SCMFSA_2:92
            .= s2.b by A1,A8
            .= Exec(i,s2).b by A22,A25,SCMFSA_2:92;
        end;
      end;
    end;
    suppose InsCode i = 5;
      then consider da, db being Int-Location such that
A26:  i = Divide(da, db) by SCMFSA_2:58;
A27:  a <> da & a <> db by A2,A26,SCMFSA7B:def 1;
      hereby per cases;
        suppose
A28:      b = db;
          hence Exec(i,s1).b = s1.da mod s1.db by A26,SCMFSA_2:93
            .= s2.da mod s1.db by A1,A27
            .= s2.da mod s2.db by A1,A27
            .= Exec(i,s2).b by A26,A28,SCMFSA_2:93;
        end;
        suppose
A29:      b = da & b <> db;
          hence Exec(i,s1).b = s1.da div s1.db by A26,SCMFSA_2:93
            .= s1.da div s2.db by A1,A27
            .= s2.da div s2.db by A1,A27
            .= Exec(i,s2).b by A26,A29,SCMFSA_2:93;
        end;
        suppose
A30:      b <> da & b <> db;
          hence Exec(i,s1).b = s1.b by A26,SCMFSA_2:93
            .= s2.b by A1,A8
            .= Exec(i,s2).b by A26,A30,SCMFSA_2:93;
        end;
      end;
    end;
    suppose InsCode i = 6;
      then consider loc being Instruction-Location of SCM+FSA such that
A31:  i = goto loc by SCMFSA_2:59;
      thus Exec(i,s1).b = s1.b by A31,SCMFSA_2:95
        .= s2.b by A1,A8
        .= Exec(i,s2).b by A31,SCMFSA_2:95;
    end;
    suppose InsCode i = 7;
      then consider loc being Instruction-Location of SCM+FSA,
      da being Int-Location such that
A32:  i = da =0_goto loc by SCMFSA_2:60;
      thus Exec(i,s1).b = s1.b by A32,SCMFSA_2:96
        .= s2.b by A1,A8
        .= Exec(i,s2).b by A32,SCMFSA_2:96;
    end;
    suppose InsCode i = 8;
      then consider loc being Instruction-Location of SCM+FSA,
      da being Int-Location such that
A33:  i = da >0_goto loc by SCMFSA_2:61;
      thus Exec(i,s1).b = s1.b by A33,SCMFSA_2:97
        .= s2.b by A1,A8
        .= Exec(i,s2).b by A33,SCMFSA_2:97;
    end;
    suppose InsCode i = 9;
      then consider db, da being Int-Location, g being FinSeq-Location such
      that
A34:  i = da := (g,db) by SCMFSA_2:62;
A35:  a <> db by A2,A34,SCMFSA7B:def 1;
      hereby per cases;
        suppose
A36:      b = da;
          then consider m1 being Element of NAT such that
A37:      m1 = abs(s1.db) and
A38:      Exec(da:=(g,db), s1).b = (s1.g)/.m1 by SCMFSA_2:98;
          consider m2 being Element of NAT such that
A39:      m2 = abs(s2.db) and
A40:      Exec(da:=(g,db), s2).b = (s2.g)/.m2 by A36,SCMFSA_2:98;
          m1 = m2 & s1.g = s2.g by A1,A35,A37,A39;
          hence Exec(i,s1).b = Exec(i,s2).b by A34,A38,A40;
        end;
        suppose
A41:      b <> da;
          hence Exec(i,s1).b = s1.b by A34,SCMFSA_2:98
            .= s2.b by A1,A8
            .= Exec(i,s2).b by A34,A41,SCMFSA_2:98;
        end;
      end;
    end;
    suppose InsCode i = 10;
      then consider db, da being Int-Location, g being FinSeq-Location such
      that
A42:  i = (g,db):= da by SCMFSA_2:63;
      thus Exec(i,s1).b = s1.b by A42,SCMFSA_2:99
        .= s2.b by A1,A8
        .= Exec(i,s2).b by A42,SCMFSA_2:99;
    end;
    suppose InsCode i = 11;
      then consider da being Int-Location, g being FinSeq-Location such that
A43:  i = da :=len g by SCMFSA_2:64;
      hereby per cases;
        suppose
A44:      b = da;
          hence Exec(i,s1).b = len (s1.g) by A43,SCMFSA_2:100
            .= len (s2.g) by A1
            .= Exec(i,s2).b by A43,A44,SCMFSA_2:100;
        end;
        suppose
A45:      b <> da;
          hence Exec(i,s1).b = s1.b by A43,SCMFSA_2:100
            .= s2.b by A1,A8
            .= Exec(i,s2).b by A43,A45,SCMFSA_2:100;
        end;
      end;
    end;
    suppose InsCode i = 12;
      then consider da being Int-Location, g being FinSeq-Location such that
A46:  i = g:=<0,...,0>da by SCMFSA_2:65;
      thus Exec(i,s1).b = s1.b by A46,SCMFSA_2:101
        .= s2.b by A1,A8
        .= Exec(i,s2).b by A46,SCMFSA_2:101;
    end;
  end;
  now
    let f be FinSeq-Location;
    per cases by A4,A5,A6,NAT_1:8,33;
    suppose InsCode i = 0;
      then
A47:  i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s1).f = s1.f by AMI_1:def 8
        .= s2.f by A1
        .= Exec(i,s2).f by A47,AMI_1:def 8;
    end;
    suppose InsCode i = 1;
      then consider da, db being Int-Location such that
A48:  i = da := db by SCMFSA_2:54;
      thus Exec(i,s1).f = s1.f by A48,SCMFSA_2:89
        .= s2.f by A1
        .= Exec(i,s2).f by A48,SCMFSA_2:89;
    end;
    suppose InsCode i = 2;
      then consider da, db being Int-Location such that
A49:  i = AddTo(da,db) by SCMFSA_2:55;
      thus Exec(i,s1).f = s1.f by A49,SCMFSA_2:90
        .= s2.f by A1
        .= Exec(i,s2).f by A49,SCMFSA_2:90;
    end;
    suppose InsCode i = 3;
      then consider da, db being Int-Location such that
A50:  i = SubFrom(da, db) by SCMFSA_2:56;
      thus Exec(i,s1).f = s1.f by A50,SCMFSA_2:91
        .= s2.f by A1
        .= Exec(i,s2).f by A50,SCMFSA_2:91;
    end;
    suppose InsCode i = 4;
      then consider da, db being Int-Location such that
A51:  i = MultBy(da,db) by SCMFSA_2:57;
      thus Exec(i,s1).f = s1.f by A51,SCMFSA_2:92
        .= s2.f by A1
        .= Exec(i,s2).f by A51,SCMFSA_2:92;
    end;
    suppose InsCode i = 5;
      then consider da, db being Int-Location such that
A52:  i = Divide(da, db) by SCMFSA_2:58;
      thus Exec(i,s1).f = s1.f by A52,SCMFSA_2:93
        .= s2.f by A1
        .= Exec(i,s2).f by A52,SCMFSA_2:93;
    end;
    suppose InsCode i = 6;
      then consider loc being Instruction-Location of SCM+FSA such that
A53:  i = goto loc by SCMFSA_2:59;
      thus Exec(i,s1).f = s1.f by A53,SCMFSA_2:95
        .= s2.f by A1
        .= Exec(i,s2).f by A53,SCMFSA_2:95;
    end;
    suppose InsCode i = 7;
      then consider loc being Instruction-Location of SCM+FSA,
      da being Int-Location such that
A54:  i = da=0_goto loc by SCMFSA_2:60;
      thus Exec(i,s1).f = s1.f by A54,SCMFSA_2:96
        .= s2.f by A1
        .= Exec(i,s2).f by A54,SCMFSA_2:96;
    end;
    suppose InsCode i = 8;
      then consider loc being Instruction-Location of SCM+FSA,
      da being Int-Location such that
A55:  i = da>0_goto loc by SCMFSA_2:61;
      thus Exec(i,s1).f = s1.f by A55,SCMFSA_2:97
        .= s2.f by A1
        .= Exec(i,s2).f by A55,SCMFSA_2:97;
    end;
    suppose InsCode i = 9;
      then consider db, da being Int-Location, g being FinSeq-Location such
      that
A56:  i = da := (g,db) by SCMFSA_2:62;
      thus Exec(i,s1).f = s1.f by A56,SCMFSA_2:98
        .= s2.f by A1
        .= Exec(i,s2).f by A56,SCMFSA_2:98;
    end;
    suppose InsCode i = 10;
      then consider db, da being Int-Location, g being FinSeq-Location such
      that
A57:  i = (g,db):=da by SCMFSA_2:63;
A58:  a <> da & a <> db by A2,A57,SCMFSA7B:def 1;
      hereby per cases;
        suppose
A59:      f = g;
          consider m1 being Element of NAT such that
A60:      m1 = abs(s1.db) and
A61:      Exec((g,db):=da,s1).g = s1.g+*(m1,s1.da) by SCMFSA_2:99;
          consider m2 being Element of NAT such that
A62:      m2 = abs(s2.db) and
A63:      Exec((g,db):=da,s2).g = s2.g+*(m2,s2.da) by SCMFSA_2:99;
A64:      m1 = m2 by A1,A58,A60,A62;
          s1.da = s2.da by A1,A58;
          hence Exec(i,s1).f = Exec(i,s2).f by A1,A57,A59,A61,A63,A64;
        end;
        suppose
A65:      f <> g;
          hence Exec(i,s1).f = s1.f by A57,SCMFSA_2:99
            .= s2.f by A1
            .= Exec(i,s2).f by A57,A65,SCMFSA_2:99;
        end;
      end;
    end;
    suppose InsCode i = 11;
      then consider da being Int-Location, g being FinSeq-Location such that
A66:  i = da :=len g by SCMFSA_2:64;
      thus Exec(i,s1).f = s1.f by A66,SCMFSA_2:100
        .= s2.f by A1
        .= Exec(i,s2).f by A66,SCMFSA_2:100;
    end;
    suppose InsCode i = 12;
      then consider da being Int-Location, g being FinSeq-Location such that
A67:  i = g:=<0,...,0>da by SCMFSA_2:65;
A68:  a <> da by A2,A67,SCMFSA7B:def 1;
      hereby per cases;
        suppose
A69:      f = g;
          consider m1 being Element of NAT such that
A70:      m1 = abs(s1.da) and
A71:      Exec(g:=<0,...,0>da, s1).g = m1 |-> 0 by SCMFSA_2:101;
          consider m2 being Element of NAT such that
A72:      m2 = abs(s2.da) and
A73:      Exec(g:=<0,...,0>da, s2).g = m2 |-> 0 by SCMFSA_2:101;
          thus Exec(i,s1).f = Exec(i,s2).f by A1,A67,A68,A69,A70,A71,A72,A73;
        end;
        suppose
A74:      f <> g;
          hence Exec(i,s1).f = s1.f by A67,SCMFSA_2:101
            .= s2.f by A1
            .= Exec(i,s2).f by A67,A74,SCMFSA_2:101;
        end;
      end;
    end;
  end;
  hence S[Exec(i,s1),Exec(i,s2)] by A7;
  now per cases by A4,A5,A6,NAT_1:8,33;
    suppose InsCode i = 0;
      then
A75:  i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s1).IC SCM+FSA = IC s1 by AMI_1:def 8
        .= Exec(i,s2).IC SCM+FSA by A3,A75,AMI_1:def 8;
    end;
    suppose InsCode i = 1;
      then consider da, db being Int-Location such that
A76:  i = da := db by SCMFSA_2:54;
      thus Exec(i,s1).IC SCM+FSA = Next IC s1 by A76,SCMFSA_2:89
        .= Exec(i,s2).IC SCM+FSA by A3,A76,SCMFSA_2:89;
    end;
    suppose InsCode i = 2;
      then consider da, db being Int-Location such that
A77:  i = AddTo(da,db) by SCMFSA_2:55;
      thus Exec(i,s1).IC SCM+FSA = Next IC s1 by A77,SCMFSA_2:90
        .= Exec(i,s2).IC SCM+FSA by A3,A77,SCMFSA_2:90;
    end;
    suppose InsCode i = 3;
      then consider da, db being Int-Location such that
A78:  i = SubFrom(da, db) by SCMFSA_2:56;
      thus Exec(i,s1).IC SCM+FSA = Next IC s1 by A78,SCMFSA_2:91
        .= Exec(i,s2).IC SCM+FSA by A3,A78,SCMFSA_2:91;
    end;
    suppose InsCode i = 4;
      then consider da, db being Int-Location such that
A79:  i = MultBy(da,db) by SCMFSA_2:57;
      thus Exec(i,s1).IC SCM+FSA = Next IC s1 by A79,SCMFSA_2:92
        .= Exec(i,s2).IC SCM+FSA by A3,A79,SCMFSA_2:92;
    end;
    suppose InsCode i = 5;
      then consider da, db being Int-Location such that
A80:  i = Divide(da, db) by SCMFSA_2:58;
      thus Exec(i,s1).IC SCM+FSA = Next IC s1 by A80,SCMFSA_2:93
        .= Exec(i,s2).IC SCM+FSA by A3,A80,SCMFSA_2:93;
    end;
    suppose InsCode i = 6;
      then consider loc being Instruction-Location of SCM+FSA such that
A81:  i = goto loc by SCMFSA_2:59;
      thus Exec(i,s1).IC SCM+FSA = loc by A81,SCMFSA_2:95
        .= Exec(i,s2).IC SCM+FSA by A81,SCMFSA_2:95;
    end;
    suppose InsCode i = 7;
      then consider loc being Instruction-Location of SCM+FSA,
      da being Int-Location such that
A82:  i = da =0_goto loc by SCMFSA_2:60;
      a <> da by A2,A82,SCMFSA7B:def 1;
      then
A83:  s1.da = s2.da by A1;
      hereby per cases;
        suppose
A84:      s1.da = 0;
          hence Exec(i,s1).IC SCM+FSA = loc by A82,SCMFSA_2:96
            .= Exec(i,s2).IC SCM+FSA by A82,A83,A84,SCMFSA_2:96;
        end;
        suppose
A85:      s1.da <> 0;
          hence Exec(i,s1).IC SCM+FSA = Next IC s1 by A82,SCMFSA_2:96
            .= Exec(i,s2).IC SCM+FSA by A3,A82,A83,A85,SCMFSA_2:96;
        end;
      end;
    end;
    suppose InsCode i = 8;
      then consider loc being Instruction-Location of SCM+FSA,
      da being Int-Location such that
A86:  i = da>0_goto loc by SCMFSA_2:61;
      a <> da by A2,A86,SCMFSA7B:def 1;
      then
A87:  s1.da = s2.da by A1;
      hereby per cases;
        suppose
A88:      s1.da > 0;
          hence Exec(i,s1).IC SCM+FSA = loc by A86,SCMFSA_2:97
            .= Exec(i,s2).IC SCM+FSA by A86,A87,A88,SCMFSA_2:97;
        end;
        suppose
A89:      s1.da <= 0;
          hence Exec(i,s1).IC SCM+FSA = Next IC s1 by A86,SCMFSA_2:97
            .= Exec(i,s2).IC SCM+FSA by A3,A86,A87,A89,SCMFSA_2:97;
        end;
      end;
    end;
    suppose InsCode i = 9;
      then consider db, da being Int-Location, g being FinSeq-Location such
      that
A90:  i = da := (g,db) by SCMFSA_2:62;
      thus Exec(i,s1).IC SCM+FSA = Next IC s1 by A90,SCMFSA_2:98
        .= Exec(i,s2).IC SCM+FSA by A3,A90,SCMFSA_2:98;
    end;
    suppose InsCode i = 10;
      then consider db, da being Int-Location, g being FinSeq-Location such
      that
A91:  i = (g,db):=da by SCMFSA_2:63;
      thus Exec(i,s1).IC SCM+FSA = Next IC s1 by A91,SCMFSA_2:99
        .= Exec(i,s2).IC SCM+FSA by A3,A91,SCMFSA_2:99;
    end;
    suppose InsCode i = 11;
      then consider da being Int-Location, g being FinSeq-Location such that
A92:  i = da :=len g by SCMFSA_2:64;
      thus Exec(i,s1).IC SCM+FSA = Next IC s1 by A92,SCMFSA_2:100
        .= Exec(i,s2).IC SCM+FSA by A3,A92,SCMFSA_2:100;
    end;
    suppose InsCode i = 12;
      then consider da being Int-Location, g being FinSeq-Location such that
A93:  i = g:=<0,...,0>da by SCMFSA_2:65;
      thus Exec(i,s1).IC SCM+FSA = Next IC s1 by A93,SCMFSA_2:101
        .= Exec(i,s2).IC SCM+FSA by A3,A93,SCMFSA_2:101;
    end;
  end;
  hence thesis;
end;

theorem Th38: ::TT11 <> AAAA'01
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA,
  a being Int-Location st I does_not_refer a &
  (for b being Int-Location st a <> b holds s1.b = s2.b) &
  (for f being FinSeq-Location holds s1.f = s2.f) &
  I is_closed_on s1 & I is_halting_on s1 holds
  for k being Element of NAT holds (for b being Int-Location st a <> b holds
   Computation( (s1 +* (I +* Start-At insloc 0)),k).b =
   Computation( (s2 +* (I +* Start-At insloc 0)),k).b) &
  (for f being FinSeq-Location holds
   Computation( (s1 +* (I +* Start-At insloc 0)),k).f =
   Computation( (s2 +* (I +* Start-At insloc 0)),k).f) &
  IC  Computation( (s1 +* (I +* Start-At insloc 0)),k) =
  IC  Computation( (s2 +* (I +* Start-At insloc 0)),k) &
  CurInstr  Computation( (s1 +* (I +* Start-At insloc 0)),k) =
  CurInstr  Computation( (s2 +* (I +* Start-At insloc 0)),k)
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does_not_refer a;
  assume
A2: (for b being Int-Location st a <> b holds s1.b = s2.b) &
  for f being FinSeq-Location holds s1.f = s2.f;
  assume
A3: I is_closed_on s1 & I is_halting_on s1;
  defpred S[State of SCM+FSA,State of SCM+FSA] means
  (for b being Int-Location st a <> b holds $1.b = $2.b) &
  for f being FinSeq-Location holds $1.f = $2.f;
  set S1 = s1 +* (I +* Start-At insloc 0);
  set S2 = s2 +* (I +* Start-At insloc 0);
A4: (I +* Start-At insloc 0) c= S1 by FUNCT_4:26;
A5: (I +* Start-At insloc 0) c= S2 by FUNCT_4:26;
A6: now
    let b be Int-Location;
    assume
A7: a <> b;
A8: b in dom s2 & not b in dom (I +* Start-At insloc 0) & b in dom s1
    by SCMFSA6B:12,SCMFSA_2:66;
    hence S1.b = s1.b by FUNCT_4:12
      .= s2.b by A2,A7
      .= S2.b by A8,FUNCT_4:12;
  end;
A9: now
    let f be FinSeq-Location;
A10: f in dom s2 & not f in dom (I +* Start-At insloc 0) & f in dom s1
    by SCMFSA6B:13,SCMFSA_2:67;
    hence S1.f = s1.f by FUNCT_4:12
      .= s2.f by A2
      .= S2.f by A10,FUNCT_4:12;
  end;
  defpred P[Element of NAT] means S[ Computation(S1,$1), Computation(S2,$1)] &
  IC  Computation(S1,$1) = IC  Computation(S2,$1) &
  CurInstr  Computation(S1,$1) = CurInstr  Computation(S2,$1);
  I c= I +* Start-At insloc 0 by SCMFSA8A:9;
  then
A11: I c= S1 & I c= S2 by A4,A5,XBOOLE_1:1;
A12: P[0]
  proof
A13: IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
A14:  Computation(S1,0) = S1 by AMI_1:13;
     Computation(S2,0) = S2 by AMI_1:13;
    hence S[ Computation(S1,0), Computation(S2,0)] by A6,A9,A14; thus
A15: IC  Computation(S1,0) = S1.IC SCM+FSA by AMI_1:13
      .= ((I +* Start-At insloc 0)).IC SCM+FSA by A13,FUNCT_4:14
      .= S2.IC SCM+FSA by A13,FUNCT_4:14
      .= IC  Computation(S2,0) by AMI_1:13;
A16: IC  Computation(S1,0) in dom I by A3,SCMFSA7B:def 7;
    thus CurInstr  Computation(S1,0) = S1.IC  Computation(S1,0) by AMI_1:13
      .= I.IC  Computation(S1,0) by A11,A16,GRFUNC_1:8
      .= S2.IC  Computation(S2,0) by A11,A15,A16,GRFUNC_1:8
      .= CurInstr  Computation(S2,0) by AMI_1:13;
  end;
A17: for k being Element of NAT holds P[k] implies P[k + 1]
  proof
    let k be Element of NAT;
    assume
A18: P[k];
A19: ProgramPart I = I by AMI_1:105;
    then
A20: I c=  Computation(S1,k) & I c=  Computation(S2,k) by A11,AMI_1:99;
A21: I c=  Computation(S1,k+1) & I c=  Computation(S2,k+1) by A11,A19,AMI_1:99;
A22: IC  Computation(S1,k) in dom I by A3,SCMFSA7B:def 7;
    then
A23: CurInstr  Computation(S1,k) = I.IC  Computation(S1,k) by A20,GRFUNC_1:8;
A24:  Computation(S1,k+1) = Following  Computation(S1,k) by AMI_1:14
      .= Exec(CurInstr  Computation(S1,k), Computation(S1,k));
A25:  Computation(S2,k+1) = Following  Computation(S2,k) by AMI_1:14
      .= Exec(CurInstr  Computation(S2,k), Computation(S2,k));
    CurInstr  Computation(S1,k) in rng I by A22,A23,FUNCT_1:def 5;
    then
A26: CurInstr  Computation(S1,k) does_not_refer a by A1,SCMFSA7B:def 2;
    hence S[ Computation(S1,k+1), Computation(S2,k+1)] by A18,A24,A25,Th37;
    thus
A27: IC  Computation(S1,k+1) = IC  Computation(S2,k+1) by A18,A24,A25,A26,Th37;
A28: IC  Computation(S1,k+1) in dom I by A3,SCMFSA7B:def 7;
    hence CurInstr  Computation(S1,k+1) = I.IC  Computation(S1,k+1)
     by A21,GRFUNC_1:8
      .= CurInstr  Computation(S2,k+1) by A21,A27,A28,GRFUNC_1:8;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A12,A17);
  hence thesis;
end;

theorem Th39: ::TI11'
  for s being State of SCM+FSA, I,J being Program of SCM+FSA,
  l being Instruction-Location of SCM+FSA holds
  I is_closed_on s & I is_halting_on s
  iff I is_closed_on s +* (I +* Start-At l) &
  I is_halting_on s +* (I +* Start-At l)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let l be Instruction-Location of SCM+FSA;
  DataPart s = DataPart(s +* (I +* Start-At l)) by SCMFSA8A:11;
  hence thesis by Th8;
end;

theorem Th40: ::TT10 <> PRE8'79
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA,
  a being Int-Location st I does_not_refer a &
  (for b being Int-Location st a <> b holds s1.b = s2.b) &
  (for f being FinSeq-Location holds s1.f = s2.f) &
  I is_closed_on s1 & I is_halting_on s1 holds
  I is_closed_on s2 & I is_halting_on s2
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does_not_refer a;
  assume
A2: for b being Int-Location st a <> b holds s1.b = s2.b;
  assume
A3: for f being FinSeq-Location holds s1.f = s2.f;
  assume
A4: I is_closed_on s1 & I is_halting_on s1;
  set S1 = s1 +* (I +* Start-At insloc 0);
  set S2 = s2 +* (I +* Start-At insloc 0);
A5: now
    let b be Int-Location;
    assume
A6: a <> b;
A7: b in dom s2 & not b in dom (I +* Start-At insloc 0)
    by SCMFSA6B:12,SCMFSA_2:66;
    b in dom s1 & not b in dom (I +* Start-At insloc 0)
    by SCMFSA6B:12,SCMFSA_2:66;
    hence S1.b = s1.b by FUNCT_4:12
      .= s2.b by A2,A6
      .= S2.b by A7,FUNCT_4:12;
  end;
A8: now
    let f be FinSeq-Location;
A9: f in dom s2 & not f in dom (I +* Start-At insloc 0)
    by SCMFSA6B:13,SCMFSA_2:67;
    f in dom s1 & not f in dom (I +* Start-At insloc 0)
    by SCMFSA6B:13,SCMFSA_2:67;
    hence S1.f = s1.f by FUNCT_4:12
      .= s2.f by A3
      .= S2.f by A9,FUNCT_4:12;
  end;
  (I +* Start-At insloc 0) +* (I +* Start-At insloc 0) =
  (I +* Start-At insloc 0);
  then
A10: S1 +*(I +* Start-At insloc 0) = S1 & S2 +* (I +* Start-At insloc 0) = S2
  by FUNCT_4:15;
A11: I is_closed_on S1 & I is_halting_on S1 by A4,Th39;
  S1 is halting by A4,SCMFSA7B:def 8;
  then consider n being Element of NAT such that
A12: CurInstr  Computation(S1,n) = halt SCM+FSA by AMI_1:def 20;
  CurInstr  Computation(S2,n) = halt SCM+FSA by A1,A5,A8,A10,A11,A12,Th38;
  then
A13: S2 is halting by AMI_1:def 20;
  now
    let k be Element of NAT;
    IC  Computation(S1,k) in dom I by A4,SCMFSA7B:def 7;
    hence IC  Computation(S2,k) in dom I by A1,A5,A8,A10,A11,Th38;
  end;
  hence thesis by A13,SCMFSA7B:def 7,def 8;
end;

theorem Th41: ::TT12 <> AAAA'86
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA,
  a being Int-Location holds
  (for d being read-write Int-Location st a <> d holds s1.d = s2.d) &
  (for f being FinSeq-Location holds s1.f = s2.f) & I does_not_refer a &
  I is_closed_on Initialize s1 & I is_halting_on Initialize s1 implies
  (for d being Int-Location st a <> d holds IExec(I,s1).d = IExec(I,s2).d) &
  (for f being FinSeq-Location holds IExec(I,s1).f = IExec(I,s2).f) &
  IC IExec(I,s1) = IC IExec(I,s2)
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: (for d being read-write Int-Location st a <> d holds s1.d = s2.d) &
  for f being FinSeq-Location holds s1.f = s2.f;
  assume
A2: I does_not_refer a;
  assume
A3: I is_closed_on Initialize s1 & I is_halting_on Initialize s1;
A4: now
    let d be Int-Location;
    assume
A5: a <> d;
    per cases;
    suppose
A6:   d = intloc 0;
      hence (Initialize s1).d = 1 by SCMFSA6C:3
        .= (Initialize s2).d by A6,SCMFSA6C:3;
    end;
    suppose d <> intloc 0;
      then
A7:   d is read-write by SF_MASTR:def 5;
      hence (Initialize s1).d = s1.d by SCMFSA6C:3
        .= s2.d by A1,A5,A7
        .= (Initialize s2).d by A7,SCMFSA6C:3;
    end;
  end;
A8: now
    let f be FinSeq-Location;
    thus (Initialize s1).f = s1.f by SCMFSA6C:3
      .= s2.f by A1
      .= (Initialize s2).f by SCMFSA6C:3;
  end;
  then
A9: I is_closed_on Initialize s2 & I is_halting_on Initialize s2
  by A2,A3,A4,Th40;
  set S1 = s1 +* Initialized I;
  set S2 = s2 +* Initialized I;
A10: S1 = Initialize s1 +* (I +* Start-At insloc 0) by SCMFSA8A:13;
  then
A11: S1 is halting by A3,SCMFSA7B:def 8;
A12: S2 = Initialize s2 +* (I +* Start-At insloc 0) by SCMFSA8A:13;
  then
A13: S2 is halting by A9,SCMFSA7B:def 8;
A14: CurInstr  Computation(S2,LifeSpan S1)
  = CurInstr  Computation(S1,LifeSpan S1) by A2,A3,A4,A8,A10,A12,Th38
    .= halt SCM+FSA by A11,AMI_1:def 46;
  now
    let l be Element of NAT;
    assume l < LifeSpan S1;
    then CurInstr  Computation(S1,l) <> halt SCM+FSA by A11,AMI_1:def 46;
    hence CurInstr  Computation(S2,l) <> halt SCM+FSA
     by A2,A3,A4,A8,A10,A12,Th38;
  end;
  then for l be Element of NAT st CurInstr  Computation(S2,l) = halt SCM+FSA
   holds
  LifeSpan S1 <= l;
  then
A15: LifeSpan S1 = LifeSpan S2 by A13,A14,AMI_1:def 46;
  then
A16: Result S2 =  Computation(S2,LifeSpan S1) by A13,AMI_1:122;
A17: Result S1 =  Computation(S1,LifeSpan S1) by A11,AMI_1:122;
  hereby
    let d be Int-Location;
    assume
A18: a <> d;
    thus IExec(I,s1).d = (Result S1).d by Th36,SCMFSA6A:30
      .= (Result S2).d by A2,A3,A4,A8,A10,A12,A16,A17,A18,Th38
      .= IExec(I,s2).d by Th36,SCMFSA6A:30;
  end;
  hereby
    let f be FinSeq-Location;
    thus IExec(I,s1).f = (Result S1).f by Th36,SCMFSA6A:31
      .= (Result S2).f by A2,A3,A4,A8,A10,A12,A16,A17,Th38
      .= IExec(I,s2).f by Th36,SCMFSA6A:31;
  end;
  thus IC IExec(I,s1) = IC Result S1 by SCMFSA8A:7
    .= IC  Computation(S1,LifeSpan S1) by A11,AMI_1:122
    .= IC  Computation(S2,LifeSpan S2) by A2,A3,A4,A8,A10,A12,A15,Th38
    .= IC Result S2 by A13,AMI_1:122
    .= IC IExec(I,s2) by SCMFSA8A:7;
end;

theorem  ::ThIFab0
  for s being State of SCM+FSA,
  I,J being parahalting Program of SCM+FSA, a,b being read-write Int-Location
  st I does_not_refer a & J does_not_refer a holds
  IC IExec(if=0(a,b,I,J),s) = insloc (card I + card J + 5) &
  (s.a = s.b implies ((for d being Int-Location st a <> d holds
  IExec(if=0(a,b,I,J),s).d = IExec(I,s).d) & for f being FinSeq-Location holds
  IExec(if=0(a,b,I,J),s).f = IExec(I,s).f)) & (s.a <> s.b implies
  ((for d being Int-Location st a <> d holds
  IExec(if=0(a,b,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if=0(a,b,I,J),s).f = IExec(J,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a,b be read-write Int-Location;
  assume
A1: I does_not_refer a & J does_not_refer a;
  set i = SubFrom(a,b);
  reconsider
  II = Macro SubFrom(a,b) as keeping_0 parahalting Program of SCM+FSA;
  reconsider JJ = if=0(a,I,J) as parahalting Program of SCM+FSA;
  IExec(if=0(a,b,I,J),s) = IExec(II ';' JJ,s) by SCMFSA6A:def 6
    .= IExec(JJ,IExec(II,s)) +* Start-At (IC IExec(JJ,IExec(II,s)) + card II)
  by SCMFSA6B:44;
  hence IC IExec(if=0(a,b,I,J),s)
  = IC IExec(JJ,IExec(II,s)) + card II by AMI_1:111
    .= insloc (card I + card J + 3) + card II by Th21
    .= insloc (card I + card J + 3) + 2 by SCMFSA7B:6
    .= insloc (card I + card J + 5);
  set s1 = Exec(i,Initialize s);
  set s2 = s;
A2: now
    let c be read-write Int-Location;
    assume a <> c;
    hence s1.c = (Initialize s).c by SCMFSA_2:91
      .= s2.c by SCMFSA6C:3;
  end;
A3: now
    let f be FinSeq-Location;
    thus s1.f = (Initialize s).f by SCMFSA_2:91
      .= s2.f by SCMFSA6C:3;
  end;
  hereby
    assume
A4: s.a = s.b;
A5: Exec(i,Initialize s).a
    = (Initialize s).a - (Initialize s).b by SCMFSA_2:91
      .= s.a - (Initialize s).b by SCMFSA6C:3
      .= s.a - s.b by SCMFSA6C:3
      .= 0 by A4;
A6: I is_closed_on Initialize s1 & I is_halting_on Initialize s1
    by SCMFSA7B:24,25;
    hereby
      let d be Int-Location;
      assume
A7:   a <> d;
      thus IExec(if=0(a,b,I,J),s).d = IExec(JJ,Exec(i,Initialize s)).d by Th12
        .= IExec(I,Exec(i,Initialize s)).d by A5,Th21
        .= IExec(I,s).d by A1,A2,A3,A6,A7,Th41;
    end;
    let f be FinSeq-Location;
    thus IExec(if=0(a,b,I,J),s).f = IExec(JJ,Exec(i,Initialize s)).f by Th13
      .= IExec(I,Exec(i,Initialize s)).f by A5,Th21
      .= IExec(I,s).f by A1,A2,A3,A6,Th41;
  end;
  assume
A8: s.a <> s.b;
A9: Exec(i,Initialize s).a
  = (Initialize s).a - (Initialize s).b by SCMFSA_2:91
    .= s.a - (Initialize s).b by SCMFSA6C:3
    .= s.a - s.b by SCMFSA6C:3;
A10: s.a + (- s.b) <> s.b + (- s.b) by A8;
A11: J is_closed_on Initialize s1 & J is_halting_on Initialize s1
  by SCMFSA7B:24,25;
  hereby
    let d be Int-Location;
    assume
A12: a <> d;
    thus IExec(if=0(a,b,I,J),s).d = IExec(JJ,Exec(i,Initialize s)).d by Th12
      .= IExec(J,Exec(i,Initialize s)).d by A9,A10,Th21
      .= IExec(J,s).d by A1,A2,A3,A11,A12,Th41;
  end;
  let f be FinSeq-Location;
  thus IExec(if=0(a,b,I,J),s).f = IExec(JJ,Exec(i,Initialize s)).f by Th13
    .= IExec(J,Exec(i,Initialize s)).f by A9,A10,Th21
    .= IExec(J,s).f by A1,A2,A3,A11,Th41;
end;

theorem  ::ThIFabg0
  for s being State of SCM+FSA,
  I,J being parahalting Program of SCM+FSA, a,b being read-write Int-Location
  st I does_not_refer a & J does_not_refer a holds
  IC IExec(if>0(a,b,I,J),s) = insloc (card I + card J + 5) &
  (s.a > s.b implies (for d being Int-Location st a <> d holds
  IExec(if>0(a,b,I,J),s).d = IExec(I,s).d) & for f being FinSeq-Location holds
  IExec(if>0(a,b,I,J),s).f = IExec(I,s).f) & (s.a <= s.b implies
  (for d being Int-Location st a <> d holds
  IExec(if>0(a,b,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if>0(a,b,I,J),s).f = IExec(J,s).f)
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a,b be read-write Int-Location;
  assume
A1: I does_not_refer a & J does_not_refer a;
  set i = SubFrom(a,b);
  reconsider
  II = Macro SubFrom(a,b) as keeping_0 parahalting Program of SCM+FSA;
  reconsider JJ = if>0(a,I,J) as parahalting Program of SCM+FSA;
  IExec(if>0(a,b,I,J),s) = IExec(II ';' JJ,s) by SCMFSA6A:def 6
    .= IExec(JJ,IExec(II,s)) +* Start-At (IC IExec(JJ,IExec(II,s)) + card II)
  by SCMFSA6B:44;
  hence IC IExec(if>0(a,b,I,J),s)
  = IC IExec(JJ,IExec(II,s)) + card II by AMI_1:111
    .= insloc (card I + card J + 3) + card II by Th27
    .= insloc (card I + card J + 3) + 2 by SCMFSA7B:6
    .= insloc (card I + card J + 5);
  set s1 = Exec(i,Initialize s);
  set s2 = s;
A2: now
    let c be read-write Int-Location;
    assume a <> c;
    hence s1.c = (Initialize s).c by SCMFSA_2:91
      .= s2.c by SCMFSA6C:3;
  end;
A3: now
    let f be FinSeq-Location;
    thus s1.f = (Initialize s).f by SCMFSA_2:91
      .= s2.f by SCMFSA6C:3;
  end;
  hereby
    assume
A4: s.a > s.b;
    Exec(i,Initialize s).a
    = (Initialize s).a - (Initialize s).b by SCMFSA_2:91
      .= s.a - (Initialize s).b by SCMFSA6C:3
      .= s.a - s.b by SCMFSA6C:3;
    then
A5: Exec(i,Initialize s).a > 0 by A4,XREAL_1:52;
A6: I is_closed_on Initialize s1 & I is_halting_on Initialize s1
    by SCMFSA7B:24,25;
    hereby
      let d be Int-Location;
      assume
A7:   a <> d;
      thus IExec(if>0(a,b,I,J),s).d = IExec(JJ,Exec(i,Initialize s)).d by Th12
        .= IExec(I,Exec(i,Initialize s)).d by A5,Th27
        .= IExec(I,s).d by A1,A2,A3,A6,A7,Th41;
    end;
    let f be FinSeq-Location;
    thus IExec(if>0(a,b,I,J),s).f = IExec(JJ,Exec(i,Initialize s)).f by Th13
      .= IExec(I,Exec(i,Initialize s)).f by A5,Th27
      .= IExec(I,s).f by A1,A2,A3,A6,Th41;
  end;
  assume
A8: s.a <= s.b;
  Exec(i,Initialize s).a = (Initialize s).a - (Initialize s).b by SCMFSA_2:91
    .= s.a - (Initialize s).b by SCMFSA6C:3
    .= s.a - s.b by SCMFSA6C:3;
  then
A9: Exec(i,Initialize s).a <= 0 by A8,XREAL_1:49;
A10: J is_closed_on Initialize s1 & J is_halting_on Initialize s1
  by SCMFSA7B:24,25;
  hereby
    let d be Int-Location;
    assume
A11: a <> d;
    thus IExec(if>0(a,b,I,J),s).d = IExec(JJ,Exec(i,Initialize s)).d by Th12
      .= IExec(J,Exec(i,Initialize s)).d by A9,Th27
      .= IExec(J,s).d by A1,A2,A3,A10,A11,Th41;
  end;
  let f be FinSeq-Location;
  thus IExec(if>0(a,b,I,J),s).f = IExec(JJ,Exec(i,Initialize s)).f by Th13
    .= IExec(J,Exec(i,Initialize s)).f by A9,Th27
    .= IExec(J,s).f by A1,A2,A3,A10,Th41;
end;

