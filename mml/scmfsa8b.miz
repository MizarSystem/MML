:: Conditional branch macro instructions of SCM+FSA, Part II
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SCMFSA_2, AMI_1, AMISTD_2, CARD_1, TARSKI,
      TURING_1, SCMFSA6A, FUNCT_4, FSM_1, RELAT_1, UNIALG_2, CIRCUIT2, FUNCT_1,
      SF_MASTR, SUBSET_1, ARYTM_3, SCMFSA7B, SCMFSA6B, SCMFSA6C,
      AMI_3, SCMFSA8A, NAT_1, GRAPHSP, XXREAL_0, MSUALG_1, STRUCT_0,
      ARYTM_1, INT_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2, SCMFSA8B,
      ORDINAL1, SCMNORM, RELOC, PBOOLE, FUNCOP_1, XBOOLE_0;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, NAT_1, INT_1,
      RELAT_1, FUNCT_1, PARTFUN1,
      FUNCOP_1, FUNCT_4, PBOOLE, FUNCT_7, FINSEQ_1, FINSEQ_2,
      STRUCT_0, COMPOS_1, EXTPRO_1,
      AMISTD_2, SCMFSA_2, SCMFSA6A,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, INT_2, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, NAT_1, INT_2, SCMFSA6A, SF_MASTR,
      SCMFSA6B, SCMFSA6C, SCMFSA8A, AMISTD_2, RELSET_1, SCMFSA7B,
      PRE_POLY, AMISTD_1, PBOOLE, FUNCOP_1;
 registrations SETFAM_1, FUNCT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1,
      SCMFSA_2, SF_MASTR, SCMFSA6A, SCMFSA6B, SCMFSA6C, ORDINAL1,
      XBOOLE_0, FINSET_1, RELSET_1, SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1,
      PBOOLE, FUNCT_4, FUNCOP_1, AMISTD_1, RELAT_1,STRUCT_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, STRUCT_0, SCMFSA6A;
 theorems TARSKI, NAT_1, FUNCT_1, FUNCT_4, SCMFSA_2,
      SCMFSA6A, GRFUNC_1, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A,
      RELAT_1, XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0,
      PARTFUN1, AFINSQ_1, SCMFSA10, COMPOS_1, EXTPRO_1, AMISTD_2, PBOOLE;
 schemes NAT_1;

begin

set A = NAT;
set D = Data-Locations SCM+FSA;
set SA0 = Start-At(0,SCM+FSA);

reserve P,P1,P2 for (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;

Lm1: for I,J being Program of SCM+FSA
 holds Reloc(J,card I) c= I ';' J by FUNCT_4:26; ::: !!!

canceled 2;

theorem Th3:
  for I being Program of SCM+FSA, s being State of SCM+FSA st I
  is_closed_on s,P holds 0 in dom I
proof
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  assume
A1: I is_closed_on s,P;
B2: IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
  IC Comput(P+*I,Initialize s,0)
     = (Initialize s).IC SCM+FSA by EXTPRO_1:3
    .= IC Start-At(0,SCM+FSA) by B2,FUNCT_4:14
    .=  0 by COMPOS_1:64;
  hence thesis by A1,SCMFSA7B:def 7;
end;

canceled;

theorem
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  DataPart Initialized s = DataPart(s +* Initialize((intloc 0).-->1));

theorem Th6:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
  DataPart s1 = DataPart s2 holds I is_closed_on s1,P1
    implies I is_closed_on s2,P2
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set S1 = Initialize s1, S2 = Initialize s2;
  assume
A2: DataPart s1 = DataPart s2;
A3: Comput(P2+*I,S2,0) = Initialize s2 by EXTPRO_1:3;
A4: Comput(P1+*I,S1,0) = Initialize s1 by EXTPRO_1:3;
  then
A5: DataPart Comput(P1+*I,S1,0) = DataPart s1 by SCMFSA8A:10
    .= DataPart Comput(P2+*I,S2,0) by A2,A3,SCMFSA8A:10;
  assume
A6: I is_closed_on s1,P1;
  then
A7:  0 in dom I by Th3;
  defpred P[Nat] means IC Comput(P1+*I,S1,$1)
      = IC Comput(P2+*I,S2,$1) & CurInstr(P1+*I,Comput(P1+*I
,S1,$1))
   = CurInstr(P2+*I,Comput(P2+*I,S2,$1)) & DataPart
  Comput(P1+*I,S1,$1) = DataPart Comput(P2+*I,S2,$1);
A8: now
    let k be Element of NAT;
A9: Comput(P2+*I,S2,k+1) = Following(P2+*I,Comput(P2+*I,S2,k)) by EXTPRO_1:4
      .= Exec(CurInstr(P2+*I,Comput(P2+*I,S2,k)),
      Comput(P2+*I,S2,k));
    assume
A10: P[k];
    then
A11: for f being FinSeq-Location holds Comput(P1+*I,S1,k).f
 = Comput(P2+*I,S2, k).f by SCMFSA6A:38;
    for a being Int-Location holds Comput(P1+*I,S1,k).a = Comput(
P2+*I,S2,k
    ) .a by A10,SCMFSA6A:38;
    then
A12: NPP Comput(P1+*I,S1,k) = NPP Comput(P2+*I,S2,k)
by A10,A11,SCMFSA10:91;
A13: IC Comput(P1+*I,S1,k+1) in dom I by A6,SCMFSA7B:def 7;
 Comput(P1+*I,S1,k+1) = Following(P1+*I,
Comput(P1+*I,S1,k)) by EXTPRO_1:4
      .= Exec(CurInstr(P1+*I,Comput(P1+*I,S1,k)),
      Comput(P1+*I,S1,k));
    then
A14: NPP Comput(P1+*I,S1,k+1) = NPP Comput(P2+*I,S2,k+1)
       by A10,A12,A9,AMISTD_2:def 20;
A15: IC Comput(P1+*I,S1,k+1) = IC Comput(P2+*I,S2,k+1)
    by A14,COMPOS_1:230;
A16:  (P1+*I)/.IC Comput(P1+*I,S1,
k+1)
 = (P1+*I).IC Comput(P1+*I,S1,k+1) by PBOOLE:158;
A17:  (P2+*I)/.IC Comput(P2+*I,S2,k+1)
 = (P2+*I).IC Comput(P2+*I,S2,k+1) by PBOOLE:158;
A18: I c= P1+*I by FUNCT_4:26;
A19: I c= P2+*I by FUNCT_4:26;
    CurInstr(P1+*I,Comput(P1+*I,S1,k+1))
     = I.IC Comput(P1+*I,S1,k+1) by A13,A16,A18,GRFUNC_1:8
      .= CurInstr(P2+*I,Comput(P2+*I,S2,k+1))
       by A15,A13,A17,A19,GRFUNC_1:8;
    hence P[k+1] by A14,COMPOS_1:138,230;
  end;
A20:  (P1+*I)/.IC Comput(P1+*I,S1,0)
 = (P1+*I).IC Comput(P1+*I,S1,0) by PBOOLE:158;
A21:  (P2+*I)/.IC Comput(P2+*I,S2,0)
 = (P2+*I).IC Comput(P2+*I,S2,0) by PBOOLE:158;
B22: IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
  then
A23: IC Comput(P2+*I,S2,0) = IC Start-At(0,SCM+FSA) by A3,FUNCT_4:14
    .=  0 by COMPOS_1:64;
A24: IC Comput(P1+*I,S1,0) = IC Start-At(0,SCM+FSA) by A4,B22,FUNCT_4:14
    .=  0 by COMPOS_1:64;
  then CurInstr(P1+*I,Comput(P1+*I,S1,0))
     = I. 0 by A7,A20,FUNCT_4:14
    .= CurInstr(P2+*I,Comput(P2+*I,S2,0))
    by A23,A7,A21,FUNCT_4:14;
  then
A25: P[0] by A24,A23,A5;
  now
    let k be Element of NAT;
A26: IC Comput(P1+*I,S1,k) in dom I by A6,SCMFSA7B:def 7;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A25,A8);
    hence IC Comput(P2+*I,S2,k) in dom I by A26;
  end;
  hence thesis by SCMFSA7B:def 7;
end;

theorem Th7:
  for s1,s2 being State of SCM+FSA, I,J being Program of SCM+FSA
holds DataPart s1 = DataPart s2
 implies NPP(Initialize s1)
  = NPP(Initialize s2)
proof
  let s1,s2 be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  assume
A1: DataPart s1 = DataPart s2;
  set S2 = Initialize s2;
  set S1 = Initialize s1;
 IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
  then
A2: IC S1 = IC Start-At(0,SCM+FSA) by FUNCT_4:14
     .=  0 by COMPOS_1:64;
 IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
  then
A3: IC S2 = IC Start-At(0,SCM+FSA) by FUNCT_4:14
      .=  0 by COMPOS_1:64;
  DataPart S1 = DataPart s1 by SCMFSA8A:10
    .= DataPart S2 by A1,SCMFSA8A:10;
  hence thesis by A2,A3,SCMFSA8A:6;
end;

theorem Th8:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA
   st DataPart s1 = DataPart s2
 holds I is_closed_on s1,P1 & I is_halting_on s1,P1
 implies
  I is_closed_on s2,P2 & I is_halting_on s2,P2
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set S1 = Initialize s1, S2 = Initialize s2;
  defpred P[Nat] means
   IC Comput(P1+*I,S1,$1) = IC Comput(P2+*I,S2,$1) &
    CurInstr(P1+*I,Comput(P1+*I,S1,$1))
   = CurInstr(P2+*I,Comput(P2+*I,S2,$1)) &
   DataPart Comput(P1+*I,S1,$1)
    = DataPart Comput(P2+*I,S2,$1);
A4: Comput(P1+*I,S1,0) = Initialize s1 by EXTPRO_1:3;
C5: IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
A6: IC Comput(P1+*I,S1,0)
     = IC Start-At(0,SCM+FSA) by A4,C5,FUNCT_4:14
    .=  0 by FUNCOP_1:87;
A7: Comput(P2+*I,S2,0) = Initialize s2 by EXTPRO_1:3;
  then
A8: IC Comput(P2+*I,S2,0)
     = IC Start-At(0,SCM+FSA) by C5,FUNCT_4:14
    .=  0 by FUNCOP_1:87;
  assume DataPart s1 = DataPart s2;
  then
A9: NPP Comput(P1+*I,S1,0) = NPP Comput(P2+*I,S2,0)
by A4,A7,Th7;
  assume
A10: I is_closed_on s1,P1;
A11: now
    let k be Element of NAT;
A12: Comput(P2+*I,S2,k+1) = Following(P2+*I,
Comput(P2+*I,S2,k)) by EXTPRO_1:4
      .= Exec(CurInstr(P2+*I,Comput(P2+*I,S2,k)),
      Comput(P2+*I,S2,k));
    assume
A13: P[k];
    then
A14: for f being FinSeq-Location holds Comput(P1+*I,S1,k).f = Comput(
P2+*I,
    S2, k).f by SCMFSA6A:38;
    for a being Int-Location holds Comput(P1+*I,S1,k).a = Comput(
P2+*I,S2,k
    ) .a by A13,SCMFSA6A:38;
    then
A15: NPP Comput(P1+*I,S1,k) = NPP Comput(P2+*I,S2,k)
by A13,A14,SCMFSA10:91;
A16: IC Comput(P1+*I,S1,k+1) in dom I by A10,SCMFSA7B:def 7;
 Comput(P1+*I,S1,k+1) = Following(P1+*I,
Comput(P1+*I,S1,k)) by EXTPRO_1:4
      .= Exec(CurInstr(P1+*I,Comput(P1+*I,S1,k)),
      Comput(P1+*I,S1,k));
    then
A17: NPP Comput(P1+*I,S1,k+1) = NPP Comput(P2+*I,S2,k+1)
       by A13,A15,A12,AMISTD_2:def 20;
A18: IC Comput(P1+*I,S1,k+1) = IC Comput(P2+*I,S2,k+1) by A17,COMPOS_1:230;
A19:  (P1+*I)/.IC Comput(P1+*I,S1,k+1)
 = (P1+*I).IC Comput(P1+*I,S1,k+1) by PBOOLE:158;
A20:  (P2+*I)/.IC Comput(P2+*I,S2,k+1)
 = (P2+*I).IC Comput(P2+*I,S2,k+1) by PBOOLE:158;
A21: I c= P1+*I by FUNCT_4:26;
A22: I c= P2+*I by FUNCT_4:26;
     CurInstr(P1+*I,Comput(P1+*I,S1,k+1))
     = I.IC Comput(P1+*I,S1,k+1) by A16,A19,A21,GRFUNC_1:8
      .= CurInstr(P2+*I,Comput(P2+*I,S2,k+1))
       by A18,A16,A20,A22,GRFUNC_1:8;
    hence P[k+1] by A17,COMPOS_1:138,230;
  end;
  assume I is_halting_on s1,P1;
  then P1+*I halts_on Initialize s1 by SCMFSA7B:def 8;
  then consider m being Element of NAT such that
A23: CurInstr(P1+*I,Comput(P1+*I,S1,m))
 = halt SCM+FSA by EXTPRO_1:30;
A24: (P1+*I)/.IC Comput(P1+*I,S1,0)
 = (P1+*I).IC Comput(P1+*I,S1,0) by PBOOLE:158;
A25:  (P2+*I)/.IC Comput(P2+*I,S2,0)
 = (P2+*I).IC Comput(P2+*I,S2,0) by PBOOLE:158;
A26:  0 in dom I by A10,Th3;
  then CurInstr(P1+*I,Comput(P1+*I,S1,0))
     = I. 0 by A6,A24,FUNCT_4:14
    .= CurInstr(P2+*I,Comput(P2+*I,S2,0))
    by A8,A26,A25,FUNCT_4:14;
  then
A27: P[0] by A6,A8,A9,COMPOS_1:138;
  now
    let k be Element of NAT;
A28: IC Comput(P1+*I,S1,k) in dom I by A10,SCMFSA7B:def 7;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A27,A11);
    hence IC Comput(P2+*I,S2,k) in dom I by A28;
  end;
  hence I is_closed_on s2,P2 by SCMFSA7B:def 7;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A27,A11);
  then CurInstr(P2+*I,Comput(P2+*I,S2,m))
   = halt SCM+FSA by A23;
  then P2+*I halts_on Initialize s2 by EXTPRO_1:30;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th9:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA holds
  I is_closed_on Initialized s,P iff
   I is_closed_on s +* Initialize((intloc 0).-->1),P+*J
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  DataPart Initialized s = DataPart(s +* Initialize((intloc 0).-->1));
  hence thesis by Th6;
end;

theorem Th10:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, l
being Element of NAT holds I is_closed_on s,P iff I is_closed_on
  s +* (Start-At(0,SCM+FSA)),P+*I
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let l be Element of NAT;
  DataPart s = DataPart(Initialize s) by SCMFSA8A:10;
  hence thesis by Th6;
end;

theorem Th11:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA
   st Start-At(0,SCM+FSA) c= s1 & I is_closed_on s1,P1
       & I c= P1
 for n being Element of NAT st
   IC s2 =  n & DataPart s1 = DataPart s2
       & Reloc(I,n) c= P2
for i being Element of NAT holds IC Comput(P1, s1,i) + n = IC
Comput(P2, s2,i) &
 IncAddr(CurInstr(P1,Comput( P1,s1,i)),n)
 = CurInstr(P2,Comput(P2,s2,i)) &
  DataPart Comput(P1, s1,i) = DataPart Comput(P2,s2,i)
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: Start-At(0,SCM+FSA) c= s1;
  assume
A2: I is_closed_on s1,P1;
  assume
A4: I c= P1;
  let n be Element of NAT;
B5: IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
  defpred P[Nat] means IC Comput(P1,s1,$1) + n = IC Comput(
P2,s2,$1) &
IncAddr(CurInstr(P1,Comput(P1,s1,$1)),n)
 = CurInstr(P2,Comput(P2,s2,$1)) &
 DataPart Comput(P1,s1,$1) = DataPart Comput(P2,s2,$1);
A6: IC Comput(P1,s1,0) = IC s1 by EXTPRO_1:3
    .= IC Start-At(0,SCM+FSA) by A1,B5,GRFUNC_1:8
    .=  0 by COMPOS_1:64;
  assume
A7: IC s2 =  n;
A8:  0 in dom I by A2,Th3;
  then
A9: 0 + n in dom Reloc(I,n) by COMPOS_1:158;
  IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
  then
A10: P1.IC s1 = P1.IC Start-At(0,SCM+FSA) by A1,GRFUNC_1:8
    .= P1. 0 by COMPOS_1:64
    .= I. 0 by A8,A4,GRFUNC_1:8;
  assume DataPart s1 = DataPart s2;
  then
A11: DataPart Comput(P1,s1,0) = DataPart s2 by EXTPRO_1:3
    .= DataPart Comput(P2,s2,0) by EXTPRO_1:3;
  assume
A12: Reloc(I,n) c= P2;
  let i be Element of NAT;
A13:  (P2)/.IC s2 = P2.IC s2 by PBOOLE:158;
A14: CurInstr(P1,s1) = I.0 by A10,PBOOLE:158;
  IncAddr(CurInstr(P1,Comput(P1,s1,0)),n)
     = IncAddr(CurInstr(P1,s1),n) by EXTPRO_1:3
    .= Reloc(I,n).( 0 + n) by A14,A8,COMPOS_1:122
    .= CurInstr(P2,s2) by A7,A9,A13,A12,GRFUNC_1:8
    .= CurInstr(P2,Comput(P2,s2,0))
     by EXTPRO_1:3;
  then
A15: P[0] by A7,A6,A11,EXTPRO_1:3;
A16: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
A17: Comput(P1,s1,k+1) = Following(P1,Comput(P1,s1,k))
 by EXTPRO_1:4
      .= Exec(CurInstr(P1,Comput(P1,s1,k)),
      Comput(P1,s1,k));
    reconsider l = IC Comput(P1,s1,k+1) as Element of NAT;
    reconsider
     j = CurInstr(P1,Comput(P1,s1,k+1)) as Instruction of SCM+FSA;
A18: Comput(P2,s2,k+1) = Following(P2,Comput(P2,s2,k)) by EXTPRO_1:4
      .= Exec(CurInstr(P2,Comput(P2,s2,k)),Comput(P2,s2,k));
A19: Initialize s1 = s1 by A1,FUNCT_4:104;
A20:    P1 = P1+*I by A4,FUNCT_4:104;
    then
A21: IC Comput(P1,s1,k+1) in dom I by A2,A19,SCMFSA7B:def 7;
    assume
A22: P[k];
    hence
A23: IC Comput(P1,s1,k+1) + n = IC Comput(P2,s2,k+1)
by A17,A18,SCMFSA6A:41;
    then
A24: IC Comput(P2,s2,k+1) in dom Reloc(I,n) by A21,COMPOS_1:158;
A25: l in dom I by A19,A2,A20,SCMFSA7B:def 7;
    j = P1.IC Comput(P1,s1,k+1) by PBOOLE:158
      .= I.l by A21,A4,GRFUNC_1:8;
    hence IncAddr(CurInstr(P1,Comput(P1,s1,k+1)),n)
     = Reloc(I,n).(l + n) by A25,COMPOS_1:122
      .= P2.IC Comput(P2,s2,k+1) by A24,A23,A12,GRFUNC_1:8
      .= CurInstr(P2,Comput(P2,s2,k+1)) by PBOOLE:158;
    thus thesis by A22,A17,A18,SCMFSA6A:41;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A15,A16);
  hence thesis;
end;

LmX:
  for s1,s2 being State of SCM+FSA, J being parahalting Program of SCM+FSA
    st NPP s1 = NPP s2
   holds NPP IExec(J,P,s1) = NPP IExec(J,P,s2)
 proof let s1,s2 be State of SCM+FSA, J be parahalting Program of SCM+FSA;
  assume NPP s1 = NPP s2;
   then
A: NPP(s1+*Initialize((intloc 0).-->1))
    = NPP s2+*NPP Initialize((intloc 0).-->1) by COMPOS_1:221
   .= NPP(s2+*Initialize((intloc 0).-->1)) by COMPOS_1:221;
D: Initialize((intloc 0).-->1) c= s1+*Initialize((intloc 0).-->1)
       by FUNCT_4:26;
   Start-At(0,SCM+FSA) c= Initialize((intloc 0).-->1) by FUNCT_4:26;
   then
C: Start-At(0,SCM+FSA) c= s1+*Initialize((intloc 0).-->1) by D,XBOOLE_1:1;
  J c= P+*J by FUNCT_4:26;
  then
B: P+*J halts_on s1+*Initialize((intloc 0).-->1) by C,SCMFSA6B:def 3;
  thus NPP IExec(J,P,s1)
      = NPP(Result(P+*J,s1+*Initialize((intloc 0).-->1)) +* s1|NAT)
                by SCMFSA6B:def 1
     .= NPP Result(P+*J,s1+*Initialize((intloc 0).-->1)) +* NPP(s1|NAT)
                by COMPOS_1:221
     .= NPP Result(P+*J,s1+*Initialize((intloc 0).-->1)) +* {}
     .= NPP Result(P+*J,s1+*Initialize((intloc 0).-->1)) by FUNCT_4:22
     .= NPP Result(P+*J,s2+*Initialize((intloc 0).-->1)) by A,B,AMISTD_2:71
     .= NPP Result(P+*J,s2+*Initialize((intloc 0).-->1)) +* {} by FUNCT_4:22
     .= NPP Result(P+*J,s2+*Initialize((intloc 0).-->1)) +* NPP(s2|NAT)
     .= NPP(Result(P+*J,s2+*Initialize((intloc 0).-->1)) +* s2|NAT)
                by COMPOS_1:221
     .= NPP IExec(J,P,s2) by SCMFSA6B:def 1;
 end;

theorem Th12:
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being parahalting Program of SCM+FSA, a being
  Int-Location
   holds IExec(i ';' J,P,s).a = IExec(J,P,Exec(i,Initialized s)).a
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be parahalting Program of SCM+FSA;
  let a be Int-Location;
A:  NPP IExec(Macro i,P,s) = NPP Exec(i,Initialized s) by SCMFSA6C:6;
  thus IExec(i ';' J,P,s).a
     = IExec(J,P,IExec(Macro i,P,s)).a by SCMFSA6C:1
    .= (NPP IExec(J,P,IExec(Macro i,P,s))).a by SCMFSA6C:13
    .= (NPP IExec(J,P,Exec(i,Initialized s))).a by A,LmX
    .= IExec(J,P,Exec(i,Initialized s)).a by SCMFSA6C:13;
end;

theorem Th13:
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being parahalting Program of SCM+FSA, f being
  FinSeq-Location holds IExec(i ';' J,P,s).f
   = IExec(J,P,Exec(i,Initialized s)).f
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be parahalting Program of SCM+FSA;
  let f be FinSeq-Location;
A:  NPP IExec(Macro i,P,s) = NPP Exec(i,Initialized s) by SCMFSA6C:6;
  thus IExec(i ';' J,P,s).f
     = IExec(J,P,IExec(Macro i,P,s)).f by SCMFSA6C:2
    .= (NPP IExec(J,P,IExec(Macro i,P,s))).f by SCMFSA6C:14
    .= (NPP IExec(J,P,Exec(i,Initialized s))).f by A,LmX
    .= IExec(J,P,Exec(i,Initialized s)).f by SCMFSA6C:14;
end;

definition
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  func if=0(a,I,J) -> Program of SCM+FSA equals
  a =0_goto  (card J + 3)
  ';' J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
  coherence;
  func if>0(a,I,J) -> Program of SCM+FSA equals
  a >0_goto  (card J + 3)
  ';' J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
  coherence;
end;

definition
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  func if<0(a,I,J) -> Program of SCM+FSA equals
  if=0(a,J,if>0(a,J,I));
  coherence;
end;

Lm2: for a being Int-Location, I,J being Program of SCM+FSA holds  0 in
dom if=0(a,I,J) &  1 in dom if=0(a,I,J) &  0 in dom if>0(a,I,J) &
 1 in dom if>0(a,I,J)

proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  set i = a =0_goto  (card J + 3);

  if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop
  SCM+FSA) by SCMFSA6A:67

    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67

    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71

    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  ));

  then
A1: dom Macro i c= dom if=0(a,I,J) by SCMFSA6A:56;
A2: dom Macro i = { 0,  1} by COMPOS_1:149;
  then
A3:  1 in dom Macro i by TARSKI:def 2;
   0 in dom Macro i by A2,TARSKI:def 2;
  hence  0 in dom if=0(a,I,J) &  1 in dom if=0(a,I,J) by A1,A3;
  set i = a >0_goto  (card J + 3);

  if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop
  SCM+FSA) by SCMFSA6A:67

    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67

    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71

    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  ));

  then
A4: dom Macro i c= dom if>0(a,I,J) by SCMFSA6A:56;
A5: dom Macro i = { 0,  1} by COMPOS_1:149;
  then
A6:  1 in dom Macro i by TARSKI:def 2;
   0 in dom Macro i by A5,TARSKI:def 2;
  hence thesis by A4,A6;
end;

Lm3: for a being Int-Location, I,J being Program of SCM+FSA holds if=0(a,I,J).
 0 = a =0_goto  (card J + 3) & if=0(a,I,J). 1 = goto  2
& if>0(a,I,J). 0 = a >0_goto  (card J + 3) & if>0(a,I,J). 1 =
goto  2

proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  set i = a =0_goto  (card J + 3);

A1: if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop
  SCM+FSA) by SCMFSA6A:67

    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67

    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71

    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  ));

A2: dom Macro i = { 0,  1} by COMPOS_1:149;
  then  0 in dom Macro i by TARSKI:def 2;
  hence if=0(a,I,J). 0 = (Directed Macro i). 0 by A1,SCMFSA8A:28
    .= i by SCMFSA7B:7;
   1 in dom Macro i by A2,TARSKI:def 2;
  hence if=0(a,I,J). 1 = (Directed Macro i). 1 by A1,SCMFSA8A:28
    .= goto  2 by SCMFSA7B:8;
  set i = a >0_goto  (card J + 3);

A3: if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop
  SCM+FSA) by SCMFSA6A:67

    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67

    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71

    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  ));

A4: dom Macro i = { 0,  1} by COMPOS_1:149;
  then  0 in dom Macro i by TARSKI:def 2;
  hence if>0(a,I,J). 0 = (Directed Macro i). 0 by A3,SCMFSA8A:28
    .= i by SCMFSA7B:7;
   1 in dom Macro i by A4,TARSKI:def 2;

  hence if>0(a,I,J). 1 = (Directed Macro i). 1 by A3,SCMFSA8A:28

    .= goto  2 by SCMFSA7B:8;
end;

theorem Th14:
  for I,J being Program of SCM+FSA, a being Int-Location holds
  card if=0(a,I,J) = card I + card J + 4
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
A1: card Stop SCM+FSA = 1 by COMPOS_1:46;
  thus card if=0(a,I,J)
     = card (Macro (a =0_goto  (card J + 3)) ';' J ';' Goto  (
  card I + 1) ';' I) + 1 by A1,SCMFSA6A:61
    .= card (Macro (a =0_goto  (card J + 3)) ';' J ';' Goto  (
  card I + 1)) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a =0_goto  (card J + 3)) ';' J) + card Goto
  (card I + 1) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a =0_goto  (card J + 3)) ';' J) + 1 + card I + 1
  by SCMFSA8A:29
    .= card Macro (a =0_goto  (card J + 3)) + card J + 1 + card I + 1
  by SCMFSA6A:61
    .= 2 + card J + 1 + card I + 1 by COMPOS_1:150
    .= card I + card J + 4;
end;

theorem Th15:
  for I,J being Program of SCM+FSA, a being Int-Location holds
  card if>0(a,I,J) = card I + card J + 4
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
A1: card Stop SCM+FSA = 1 by COMPOS_1:46;
  thus card if>0(a,I,J)
     = card (Macro (a >0_goto  (card J + 3)) ';' J ';' Goto  (
  card I + 1) ';' I) + 1 by A1,SCMFSA6A:61
    .= card (Macro (a >0_goto  (card J + 3)) ';' J ';' Goto  (
  card I + 1)) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a >0_goto  (card J + 3)) ';' J) + card Goto
  (card I + 1) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a >0_goto  (card J + 3)) ';' J) + 1 + card I + 1
  by SCMFSA8A:29
    .= card Macro (a >0_goto  (card J + 3)) + card J + 1 + card I + 1
  by SCMFSA6A:61
    .= 2 + card J + 1 + card I + 1 by COMPOS_1:150
    .= card I + card J + 4;
end;

theorem Th16:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location
    st s.a = 0 & I is_closed_on s,P & I is_halting_on s,P
  holds if=0(a,I,J) is_closed_on s,P & if=0(a,I,J) is_halting_on s,P
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = Initialize s,
      P1 = P +* I1;
  set s3 = Initialize s,
      P3 = P +*  if=0(a,I,J);
  set s4 = Comput(P+*if=0(a,I,J),s3,1);
  set i = a =0_goto  (card J + 3);
   Start-At(0,SCM+FSA) c= Initialize if=0(a,I,J) by FUNCT_4:26;
   then dom Start-At(0,SCM+FSA) c= dom (Initialize if=0(a,I,J))
             by RELAT_1:25;
   then
B3: not a in dom Start-At(0,SCM+FSA) by SCMFSA6B:12;
A4:  0 in dom if=0(a,I,J) by Lm2;
A5: P3.0 = if=0(a,I,J).0 by A4,FUNCT_4:14
    .= i by Lm3;
  IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
  then
A6: IC s3 = IC Start-At(0,SCM+FSA) by FUNCT_4:14
    .=  0 by COMPOS_1:64;
A9: if=0(a,I,J) c= P3 by FUNCT_4:26;
A10: if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67;
  card (i ';' J ';' Goto  (card I + 1))
     = card (Macro i ';' J) + card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by COMPOS_1:150
    .= card J + (2 + 1);
  then
A11:   Reloc(I1,card J + 3) c= if=0(a,I,J) by A10,Lm1;
A13: Reloc(I1,card J+3) c= P3 by A11,A9,XBOOLE_1:1;
A14: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A6,A5,PBOOLE:158;
A16: for f being FinSeq-Location holds s1.f = s4.f by A14,SCMFSA_2:96;
  for a being Int-Location holds s1.a = s4.a by A14,SCMFSA_2:96;
  then
A17: DataPart s1 = DataPart s4 by A16,SCMFSA6A:38;
  assume s.a = 0;
  then s3.a = 0 by B3,FUNCT_4:12;
  then
A18: IC Comput(P3,s3,1) =  (card J + 3) by A14,SCMFSA_2:96;
  assume
A19: I is_closed_on s,P;
  assume
A20: I is_halting_on s,P;
  then
A21: I1 is_closed_on s,P by A19,SCMFSA8A:46;
  I1 is_halting_on s,P by A19,A20,SCMFSA8A:46;
  then
A22: P1 halts_on s1 by SCMFSA7B:def 8;
  DataPart s = DataPart s1 by SCMFSA8A:10;
  then
A23: I1 is_closed_on s1,P1 by A21,Th6;
A24: Start-At(0,SCM+FSA) c= s1 by FUNCT_4:26;
A25: I1 c= P1 by FUNCT_4:26;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A26:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P1, s1,k1) as Element of NAT;
       m in dom I1 by A21,SCMFSA7B:def 7;
      then
A27:  m < card I1 by AFINSQ_1:70;
      card Stop SCM+FSA = 1 by COMPOS_1:46;
      then
A28:  card I1 = card I + 1 by SCMFSA6A:61;
      card if=0(a,I,J) = card I + card J + 4 by Th14
        .= card J + 3 + card I1 by A28;
      then
A29:  m + (card J + 3) < card if=0(a,I,J) by A27,XREAL_1:8;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A26,EXTPRO_1:5
        .=  (m + (card J + 3))
         by A24,A23,A18,A17,Th11,A25,A13;
      hence IC Comput(P3,s3,k) in dom if=0(a,I,J) by A29,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom if=0(a,I,J) by A4,A6,EXTPRO_1:3;
    end;
  end;
  hence if=0(a,I,J) is_closed_on s,P by SCMFSA7B:def 7;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P1,s1)+1))
   = CurInstr(P3,
   Comput(P3,s4,LifeSpan(P1,s1))) by EXTPRO_1:5
    .= IncAddr(CurInstr(P1,
    Comput(P1,s1,LifeSpan(P1,s1))),card J + 3) by A24,A23,A18,A17,Th11,A13,A25
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A22,EXTPRO_1:def 14
    .= halt SCM+FSA by COMPOS_1:93;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th17:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0
   & I is_closed_on Initialized s,P & I is_halting_on Initialized s,P
   holds IExec(if=0(a,I,J),P,s)
     = IExec(I,P,s) +* Start-At((card I + card J + 3),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = s +* Initialize((intloc 0).-->1),
      P1 = P +* I1;
A1: I1 c= P1 by FUNCT_4:26;
  set s3 = s +* Initialize((intloc 0).-->1),
      P3 = P +* if=0(a,I,J);
  set s4 = Comput(P3,s3,1);
  set i = a =0_goto  (card J + 3);
B2: Initialize((intloc 0).-->1) c= s1 by FUNCT_4:26;
  Start-At(0,SCM+FSA) c= Initialize((intloc 0).-->1) by FUNCT_4:26;
  then
A2: Start-At(0,SCM+FSA) c= s1 by B2,XBOOLE_1:1;
A3: if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67;
A4:  0 in dom if=0(a,I,J) by Lm2;
A5: P3. 0 = if=0(a,I,J). 0 by A4,FUNCT_4:14
    .= i by Lm3;
V: Initialize((intloc 0).-->1) c= Initialized if=0(a,I,J) by FUNCT_4:26;
   then dom Initialize((intloc 0).-->1) c= dom Initialized if=0(a,I,J)
        by RELAT_1:25;
   then
C11: not a in dom Initialize((intloc 0).-->1) by SCMFSA6A:48;
X2:IC SCM+FSA in dom Initialize((intloc 0).-->1) by COMPOS_1:225;
  then
A6: IC s3 = IC Initialize((intloc 0).-->1) by FUNCT_4:14
    .= IC Initialized if=0(a,I,J) by V,X2,GRFUNC_1:8
    .=  0 by SCMFSA6A:46;
A7: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A6,A5,PBOOLE:158;
A10: if=0(a,I,J) c= P3 by FUNCT_4:26;
A12: dom ProgramPart s = NAT by COMPOS_1:34;
  assume s.a = 0;
  then s3.a = 0 by C11,FUNCT_4:12;
  then
A13: IC Comput(P3,s3,1) =  (card J + 3) by A7,SCMFSA_2:96;
A15: for f being FinSeq-Location holds s1.f = s4.f by A7,SCMFSA_2:96;
  for a being Int-Location holds s1.a = s4.a by A7,SCMFSA_2:96;
  then
A16: DataPart s1 = DataPart s4 by A15,SCMFSA6A:38;
  card (i ';' J ';' Goto  (card I + 1))
     = card (Macro i ';' J) + card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by COMPOS_1:150
    .= card J + (2 + 1);
  then
A17:  Reloc(I1,card J + 3) c= if=0(a,I,J) by A3,Lm1;
A19: Reloc(I1,card J + 3) c= P3 by A17,A10,XBOOLE_1:1;
  assume
A20: I is_closed_on Initialized s,P;
  assume
A21: I is_halting_on Initialized s,P;
  then
A22: P1 halts_on s1 by A20,SCMFSA8A:55;
  I1 is_closed_on Initialized s,P by A20,A21,SCMFSA8A:46;
  then
A23: I1 is_closed_on s1,P1 by Th9;
A24: CurInstr(P3,Comput(P3,s3,LifeSpan(P1,s1)+1))
     = CurInstr(P3,Comput(P3,s4,LifeSpan(P1,s1))) by EXTPRO_1:5
    .= IncAddr(CurInstr(P1,Comput(P1,s1,LifeSpan(P1,s1))),(card J + 3))
       by A2,A23,A13,A16,Th11,A19,A1
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A22,EXTPRO_1:def 14
    .= halt SCM+FSA by COMPOS_1:93;
  then
A25: P3 halts_on s3 by EXTPRO_1:30;
  now
    let l be Element of NAT;
    assume
A26: l < LifeSpan(P1,s1) + 1;
A27: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      hence CurInstr(P3,Comput(P3,s3,l)) <>
       halt SCM+FSA by A6,A5,A27,PBOOLE:158;
    end;
    suppose
      l <> 0;
      then consider n being Nat such that
A28:  l = n + 1 by NAT_1:6;
      assume
A29:  CurInstr(P3,Comput(P3,s3,l)) = halt SCM+FSA;
      reconsider n as Element of NAT by ORDINAL1:def 13;
      InsCode CurInstr(P1,Comput(P1,s1,n))
       = InsCode IncAddr(CurInstr(P1,
       Comput(P1,s1,n)),(card J + 3))
        by COMPOS_1:def 38
        .= InsCode CurInstr(P3,Comput(P3,s4,n))
         by A2,A23,A13,A16,Th11,A19,A1
        .= 0 by A28,A29,EXTPRO_1:5,SCMFSA_2:124;
      then
A30:  CurInstr(P1,Comput(P1,s1,n))
 = halt SCM+FSA by SCMFSA_2:122;
      n < LifeSpan(P1,s1) by A26,A28,XREAL_1:8;
      hence contradiction by A22,A30,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCM+FSA
  holds LifeSpan(P1,s1) + 1 <= l;
  then
A31: LifeSpan(P3,s3) = LifeSpan(P1,s1) + 1 by A24,A25,EXTPRO_1:def 14;
A32: DataPart Result(P1,s1) = DataPart Comput(P1, s1
,LifeSpan(P1,s1)) by A20,A21,EXTPRO_1:23,SCMFSA8A:55
    .= DataPart Comput(P3, s4,LifeSpan(P1,s1)) by A2,A23,A13,A16,Th11,A1,A19
    .= DataPart Comput(P3, s3,LifeSpan(P1,s1) + 1)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A25,A31,EXTPRO_1:23;
A33: now
    let x be set;
A34: IExec(I1,P,s) = Result(P1,s1) +* s|NAT by SCMFSA6B:def 1;
A35: dom Start-At( (card I + card J + 3),SCM+FSA) = {IC SCM+FSA}
 by FUNCOP_1:19;
A36: IExec(if=0(a,I,J),P,s) = (Result(P3,s3)) +* s|NAT by SCMFSA6B:def 1;
A37: dom ProgramPart s = NAT by COMPOS_1:34;
    assume
A38: x in dom IExec(if=0(a,I,J),P,s);
    per cases by A38,SCMFSA6A:35;
    suppose
A39:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A40:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A35,TARSKI:def 1;
      thus IExec(if=0(a,I,J),P,s).x = (Result(P3,s3)).x
              by A36,A39,A37,FUNCT_4:12,SCMFSA10:3
        .= (Result(P1,s1)).x by A32,A39,SCMFSA6A:38
        .= IExec(I1,P,s).x by A34,A39,A37,FUNCT_4:12,SCMFSA10:3
        .= (IExec(I1,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x by A40,
FUNCT_4:12;
    end;
    suppose
A41:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A42:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A35,TARSKI:def 1;
      thus IExec(if=0(a,I,J),P,s).x
       = (Result(P3,s3)).x by A36,A41,A37,FUNCT_4:12,SCMFSA10:4
        .= (Result(P1,s1)).x by A32,A41,SCMFSA6A:38
        .= IExec(I1,P,s).x by A34,A41,A37,FUNCT_4:12,SCMFSA10:4
        .= (IExec(I1,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x by A42,
FUNCT_4:12;
    end;
    suppose
A43:  x = IC SCM+FSA;
      then
A44:  x in dom Start-At((card I+card J+3),SCM+FSA)by A35,TARSKI:def 1;
A45:    not x in dom(s|NAT) by A43,A37,COMPOS_1:def 12;
A46:  IC Result(P1,s1) = IExec(I1,P,s).IC SCM+FSA by A34,A43,A45,FUNCT_4:12
        .= IC (IExec(I,P,s) +* Start-At( card I,SCM+FSA))
         by A20,A21,SCMFSA8A:57
        .=  card I by FUNCT_4:121;
      thus IExec(if=0(a,I,J),P,s).x = (Result(P3,s3)).x by A36,A45,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P1,s1) + 1).x by A25,A31,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P1,s1)) by A43,EXTPRO_1:5
        .= IC Comput(P1, s1,LifeSpan(P1,s1)) + (card
J + 3) by A2,A23,A13,A16,Th11,A19,A1
        .= IC Result(P1,s1) + (card J + 3)
              by A20,A21,EXTPRO_1:23,SCMFSA8A:55
        .= (Start-At((card I+(card J+3)),SCM+FSA)).IC SCM+FSA by A46,
FUNCOP_1:87
        .= (IExec(I1,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A43,A44,FUNCT_4:14;
    end;
    suppose
A47:  x is Element of NAT;
      then x <> IC SCM+FSA by COMPOS_1:3;
      then
A48:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A35,TARSKI:def 1;
      thus IExec(if=0(a,I,J),P,s).x = (s|NAT).x by A36,A47,A12,FUNCT_4:14
        .= IExec(I1,P,s).x by A34,A47,A12,FUNCT_4:14
        .= (IExec(I1,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x by A48,
FUNCT_4:12;
    end;
  end;
  dom IExec(if=0(a,I,J),P,s) = the carrier of SCM+FSA by PARTFUN1:def 4
    .= dom (IExec(I1,P,s) +* Start-At((card I+card J+3),SCM+FSA))
     by PARTFUN1:def 4;
  hence IExec(if=0(a,I,J),P,s) = IExec(I1,P,s) +* Start-At( (card I + card J
  + 3),SCM+FSA) by A33,FUNCT_1:9
    .= IExec(I,P,s) +* Start-At( card I,SCM+FSA) +*
     Start-At( (card I +
  card J + 3),SCM+FSA) by A20,A21,SCMFSA8A:57
    .= IExec(I,P,s) +* Start-At((card I+card J+3),SCM+FSA)by FUNCT_4:122;
end;

theorem Th18:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a <> 0 & J is_closed_on s,P &
    J is_halting_on s,P
  holds if=0(a,I,J) is_closed_on s,P & if=0(a,I,J) is_halting_on s,P
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = Initialize s,
      P2 = P +* JI2;
A3: JI2 c= P2 by FUNCT_4:26;
  set s3 = Initialize s,
      P3 = P +* if=0(a,I,J);
  set s4 = Comput(P3,s3,1);
  set s5 = Comput(P3,s3,2);
  set i = a =0_goto  (card J + 3);
A4: Start-At(0,SCM+FSA) c= s2 by FUNCT_4:26;
  IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
  then
A5: IC s3 = IC Start-At(0,SCM+FSA) by FUNCT_4:14
    .=  0 by COMPOS_1:64;
A8: if=0(a,I,J) c= P3 by FUNCT_4:26;
A9: if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:67;
  then Reloc(JI2,card Macro i) c= if=0(a,I,J) by Lm1;
  then
A10: Reloc(JI2,2) c= if=0(a,I,J) by COMPOS_1:150;
A12: Reloc(JI2,2) c= P3 by A10,A8,XBOOLE_1:1;
        Start-At(0,SCM+FSA) c= Initialize if=0(a,I,J) by FUNCT_4:26;
   then dom Start-At(0,SCM+FSA) c= dom Initialize if=0(a,I,J)
              by RELAT_1:25;
     then
B13: not a in dom Start-At(0,SCM+FSA) by SCMFSA6B:12;
A14:  0 in dom if=0(a,I,J) by Lm2;
A15: if=0(a,I,J) c= P3 by FUNCT_4:26;
A16: P3. 0 = if=0(a,I,J). 0 by A14,FUNCT_4:14
    .= i by Lm3;
A17:  1 in dom if=0(a,I,J) by Lm2;
A18: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A5,A16,PBOOLE:158;
  assume s.a <> 0;
  then s3.a <> 0 by B13,FUNCT_4:12;
  then
A19: IC Comput(P3,s3,1) = succ  0 by A5,A18,SCMFSA_2:96
    .=  (0 + 1);
A20: P3. 1 = if=0(a,I,J). 1 by A17,A15,GRFUNC_1:8
    .= goto  2 by Lm3;
  assume
A21: J is_closed_on s,P;
A22: Comput(P3, s3,1 + 1) = Following(P3,s4) by EXTPRO_1:4
    .= Exec(goto  2,s4) by A19,A20,PBOOLE:158;
A24: now
    let f be FinSeq-Location;
    thus s2.f = Comput(P3,s3,1).f by A18,SCMFSA_2:96
      .= s5.f by A22,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s2.a = Comput(P3,s3,1).a by A18,SCMFSA_2:96
      .= s5.a by A22,SCMFSA_2:95;
  end;
  then
A25: DataPart s2 = DataPart s5 by A24,SCMFSA6A:38;
  assume
A26: J is_halting_on s,P;
  then
A27: JI2 is_closed_on s,P by A21,SCMFSA8A:58;
  then
A28: JI2 is_closed_on s2,P2 by Th10;
A29: P2 halts_on s2 by A21,A26,SCMFSA8A:59;
A30: IC s5 =  2 by A22,SCMFSA_2:95;
  now
    let k be Element of NAT;
    k = 0 or 0 + 1 < k + 1 by XREAL_1:8;
    then
A31: k = 0 or 1 <= k by NAT_1:13;
    per cases by A31,XXREAL_0:1;
    suppose
A32:  1 < k;
      then consider k1 being Nat such that
A33:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      0 + 1 < k1 + 1 by A32,A33;
      then consider k2 being Nat such that
A34:  k2 + 1 = k1 by NAT_1:6;
      reconsider k2 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P2, s2,k2) as Element of NAT;
A35:  card if=0(a,I,J) = card Macro i + card JI2 by A9,SCMFSA6A:61
        .= 2 + card JI2 by COMPOS_1:150;
       m in dom JI2 by A27,SCMFSA7B:def 7;
      then m < card JI2 by AFINSQ_1:70;
      then
A36:  m + 2 < card if=0(a,I,J) by A35,XREAL_1:8;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A33,EXTPRO_1:5
        .= IC Comput(P3, Comput(P3, s4,1),k2) by A34,EXTPRO_1:5
        .= IC Comput(P3, Comput(P3, s3,1 + 1),k2) by EXTPRO_1:5
        .= m + 2 by A4,A28,A30,A25,Th11,A12,A3;
      hence IC Comput(P3,s3,k) in dom if=0(a,I,J) by A36,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom if=0(a,I,J) by A14,A5,EXTPRO_1:3;
    end;
    suppose
      k = 1;
      hence IC Comput(P3,s3,k) in dom if=0(a,I,J) by A19,Lm2;
    end;
  end;
  hence if=0(a,I,J) is_closed_on s,P by SCMFSA7B:def 7;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+2))
   = CurInstr(P3,Comput(P3,s5,LifeSpan(P2,s2))) by EXTPRO_1:5
    .= IncAddr(CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))),2) by A4,A28,A30,A25,Th11,A12,A3
    .= IncAddr(halt SCM+FSA,2) by A29,EXTPRO_1:def 14
    .= halt SCM+FSA by COMPOS_1:93;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th19:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <> 0 &
    J is_closed_on Initialized s,P & J is_halting_on Initialized s,P
holds IExec(if=0(a,I,J),P,s)
 = IExec(J,P,s) +* Start-At((card I+card J+3),SCM+FSA)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = s +* Initialize((intloc 0).-->1),
      P2 = P +* JI2;
A1: JI2 c= P2 by FUNCT_4:26;
  set s3 = s +* Initialize((intloc 0).-->1),
      P3 = P +* if=0(a,I,J);
  set s4 = Comput(P3, s3,1);
  set s5 = Comput(P3, s3,2);
  set i = a =0_goto  (card J + 3);
B2:  Initialize((intloc 0).-->1) c= s2 by FUNCT_4:26;
  Start-At(0,SCM+FSA) c= Initialize((intloc 0).-->1) by FUNCT_4:26;
   then
A2: Start-At(0,SCM+FSA) c= s2 by B2,XBOOLE_1:1;
  0 in dom if=0(a,I,J) by Lm2;
  then
A3: P3. 0 = if=0(a,I,J). 0 by FUNCT_4:14
    .= i by Lm3;
A5:  1 in dom if=0(a,I,J) by Lm2;
A6: P3. 1 = if=0(a,I,J). 1 by A5,FUNCT_4:14
    .= goto  2 by Lm3;
V: Initialize((intloc 0).-->1) c= Initialized if=0(a,I,J) by FUNCT_4:26;
   then dom Initialize((intloc 0).-->1) c= dom Initialized if=0(a,I,J)
              by RELAT_1:25;
     then
B9: not a in dom Initialize((intloc 0).-->1) by SCMFSA6A:48;
X2: IC SCM+FSA in dom Initialize((intloc 0).-->1) by COMPOS_1:225;
  then
A7: IC s3 = IC Initialize((intloc 0).-->1) by FUNCT_4:14
    .= IC Initialized if=0(a,I,J) by V,X2,GRFUNC_1:8
    .=  0 by SCMFSA6A:46;
  if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:67;
  then Reloc(JI2,card Macro i) c= if=0(a,I,J) by Lm1;
  then
A8: Reloc(JI2,2) c= if=0(a,I,J) by COMPOS_1:150;
A10: dom ProgramPart s = NAT by COMPOS_1:34;
  if=0(a,I,J) c= P3 by FUNCT_4:26;
  then
A12: Reloc(JI2,2) c= P3 by A8,XBOOLE_1:1;
A13: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A7,A3,PBOOLE:158;
  assume s.a <> 0;
  then s3.a <> 0 by B9,FUNCT_4:12;
  then
A14: IC Comput(P3,s3,1) = succ  0 by A7,A13,SCMFSA_2:96
    .=  (0 + 1);
  assume
A15: J is_closed_on Initialized s,P;
A16: Comput(P3, s3,1 + 1) = Following(P3,s4) by EXTPRO_1:4
    .= Exec(goto  2,s4) by A14,A6,PBOOLE:158;
  then
A17: IC s5 =  2 by SCMFSA_2:95;
A19: now
    let f be FinSeq-Location;
    thus s2.f = Comput(P3,s3,1).f by A13,SCMFSA_2:96
      .= s5.f by A16,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s2.a = Comput(P3,s3,1).a by A13,SCMFSA_2:96
      .= s5.a by A16,SCMFSA_2:95;
  end;
  then
A20: DataPart s2 = DataPart s5 by A19,SCMFSA6A:38;
  assume
A21: J is_halting_on Initialized s,P;
  then
A22: P2 halts_on s2 by A15,SCMFSA8A:60;
  JI2 is_closed_on Initialized s,P by A15,A21,SCMFSA8A:58;
  then
A23: JI2 is_closed_on s2,P2 by Th9;
A24: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+2))
 = CurInstr(P3,
 Comput(P3,s5,LifeSpan(P2,s2))) by EXTPRO_1:5
    .= IncAddr(CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))),2) by A2,A23,A12,A17,A20,Th11,A1
    .= IncAddr(halt SCM+FSA,2) by A22,EXTPRO_1:def 14
    .= halt SCM+FSA by COMPOS_1:93;
  then
A25: P3 halts_on s3 by EXTPRO_1:30;
  now
    let l be Element of NAT;
    assume
A26: l < LifeSpan(P2,s2) + 2;
A27: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      hence CurInstr(P3,Comput(P3,s3,l)) <>
       halt SCM+FSA by A7,A3,A27,PBOOLE:158;
    end;
    suppose
      l = 1;
      hence CurInstr(P3,Comput(P3,s3,l)) <>
       halt SCM+FSA by A14,A6,PBOOLE:158;
    end;
    suppose
A28:  l <> 0 & l <> 1;
      assume
A29:  CurInstr(P3,Comput(P3,s3,l)) = halt SCM+FSA;
      consider n being Nat such that
A30:  l = n + 1 by A28,NAT_1:6;
      n <> 0 by A28,A30;
      then consider l2 being Nat such that
A31:  n = l2 + 1 by NAT_1:6;
      reconsider l2 as Element of NAT by ORDINAL1:def 13;
A32: Comput(P3,s3,l2+(1+1))
 = Comput(P3,Comput(P3,s3,1+1),l2) by EXTPRO_1:5;
      InsCode CurInstr(P2,Comput(
P2,s2,l2)) =
       InsCode IncAddr(CurInstr(P2,
       Comput(P2,s2,l2)),2) by COMPOS_1:def 38
        .= 0 by A30,A31,A29,A32,A2,A23,A17,A20,Th11,A12,A1,SCMFSA_2:124;
      then
A33:  CurInstr(P2,Comput(P2
,s2,l2))
 = halt SCM+FSA by SCMFSA_2:122;
      n + 1 < LifeSpan(P2,s2) + 1 + 1 by A26,A30;
      then n < LifeSpan(P2,s2) + 1 by XREAL_1:8;
      then l2 < LifeSpan(P2,s2) by A31,XREAL_1:8;
      hence contradiction by A22,A33,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCM+FSA
  holds LifeSpan(P2,s2) + 2 <= l;
  then
A34: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 2 by A24,A25,EXTPRO_1:def 14;
A35: DataPart Result(P2,s2) = DataPart Comput(P2, s2
,LifeSpan(P2,s2)) by A21,A15,EXTPRO_1:23,SCMFSA8A:60
    .= DataPart Comput(P3, s5,LifeSpan(P2,s2)) by A2,A23,A17,A20,Th11,A12,A1
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 2)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A25,A34,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom Start-At((card I+card J+3),SCM+FSA)= {IC SCM+FSA}
 by FUNCOP_1:19;
A38: IExec(if=0(a,I,J),P,s) = (Result(P3,s3)) +* s|NAT by SCMFSA6B:def 1;
A39: IExec(JI2,P,s) = Result(P2,s2) +* s|NAT by SCMFSA6B:def 1;
    assume
A40: x in dom IExec(if=0(a,I,J),P,s);
    per cases by A40,SCMFSA6A:35;
    suppose
A41:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A42:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A37,TARSKI:def 1;
      thus IExec(if=0(a,I,J),P,s).x = (Result(P3,s3)).x
            by A38,A41,A10,FUNCT_4:12,SCMFSA10:3
        .= (Result(P2,s2)).x by A35,A41,SCMFSA6A:38
        .= IExec(JI2,P,s).x by A39,A41,A10,FUNCT_4:12,SCMFSA10:3
        .= (IExec(JI2,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A42,FUNCT_4:12;
    end;
    suppose
A43:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A44:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A37,TARSKI:def 1;
      thus IExec(if=0(a,I,J),P,s).x = (Result(P3,s3)).x by A38,A43,A10,
FUNCT_4:12,SCMFSA10:4
        .= (Result(P2,s2)).x by A35,A43,SCMFSA6A:38
        .= IExec(JI2,P,s).x by A39,A43,A10,FUNCT_4:12,SCMFSA10:4
        .= (IExec(JI2,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A44,FUNCT_4:12;
    end;
    suppose
A45:  x = IC SCM+FSA;
      then
A46:  x in dom Start-At((card I+card J+3),SCM+FSA)by A37,TARSKI:def 1;
A47:    not x in dom(s|NAT) by A45,A10,COMPOS_1:def 12;
     then
A48:  IC Result(P2,s2) = IC IExec(JI2,P,s)
 by A39,A45,FUNCT_4:12
        .=  (card I + card J + 1) by A15,A21,SCMFSA8A:61;
      thus IExec(if=0(a,I,J),P,s).x = (Result(P3,s3)).x by A38,A47,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P2,s2) + 2).x by A25,A34,EXTPRO_1:23
        .= IC Comput(P3, s5,LifeSpan(P2,s2)) by A45,EXTPRO_1:5
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 2 by A2,A23,A17,A20,Th11,A12,A1
        .= IC Result(P2,s2) + 2 by A21,A15,EXTPRO_1:23,SCMFSA8A:60
        .= (Start-At ( (card I + card J + 1) + 2,SCM+FSA)).IC SCM+FSA
         by A48,FUNCOP_1:87
        .= (IExec(JI2,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A45,A46,FUNCT_4:14;
    end;
    suppose
A49:  x is Element of NAT;
      then x <> IC SCM+FSA by COMPOS_1:3;
      then
A50:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A37,TARSKI:def 1;
      thus IExec(if=0(a,I,J),P,s).x = (s|NAT).x by A38,A49,A10,FUNCT_4:14
        .= IExec(JI2,P,s).x by A39,A49,A10,FUNCT_4:14
        .= (IExec(JI2,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A50,FUNCT_4:12;
    end;
  end;
  dom IExec(if=0(a,I,J),P,s) = the carrier of SCM+FSA by PARTFUN1:def 4
    .= dom (IExec(JI2,P,s) +* Start-At((card I+card J+3),SCM+FSA))
     by PARTFUN1:def 4;
  hence
  IExec(if=0(a,I,J),P,s) = IExec(JI2,P,s) +* Start-At( (card I + card J
  + 3),SCM+FSA) by A36,FUNCT_1:9
    .= IExec(J,P,s) +* Start-At( (card I + card J + 1),SCM+FSA)
     +* Start-At(
   (card I + card J + 3),SCM+FSA) by A15,A21,SCMFSA8A:62
    .= IExec(J,P,s) +* Start-At((card I+card J+3),SCM+FSA)by FUNCT_4:122;
end;

theorem Th20:
 for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA,
  a being read-write Int-Location
 holds if=0(a,I,J) is parahalting &
    (s.a = 0 implies
      IExec(if=0(a,I,J),P,s)
       = IExec(I,P,s) +* Start-At( (card I + card J + 3),SCM+FSA)) &
    (s.a <> 0 implies
      IExec(if=0(a,I,J),P,s)
       = IExec(J,P,s) +* Start-At((card I + card J + 3),SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
A1: I is_halting_on Initialized s,P by SCMFSA7B:25;
  for s being State of SCM+FSA st Start-At(0,SCM+FSA) c= s
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
   st if=0(a,I,J) c= P
  holds P halts_on s
  proof
    let s be State of SCM+FSA;
    assume Start-At(0,SCM+FSA) c= s;
    then
A3: s = Initialize s by FUNCT_4:104;
    let Q be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
    such that
A4:  if=0(a,I,J) c= Q;
A5:  if=0(a,I,J) c= Q by A4;
A6: I is_closed_on s,Q by SCMFSA7B:24;
A7: I is_halting_on s,Q by SCMFSA7B:25;
A8: J is_halting_on s,Q by SCMFSA7B:25;
A9: J is_closed_on s,Q by SCMFSA7B:24;
A10:  Q +* if=0(a,I,J) = Q by A5,FUNCT_4:104;
    per cases;
    suppose
    s.a = 0;
      then if=0(a,I,J) is_halting_on s,Q by A6,A7,Th16;
      hence Q halts_on s by A3,A10,SCMFSA7B:def 8;
    end;
    suppose
      s.a <> 0;
      then if=0(a,I,J) is_halting_on s,Q by A9,A8,Th18;
      hence Q halts_on s by A3,A10,SCMFSA7B:def 8;
    end;
  end;
  hence if=0(a,I,J) is parahalting by SCMFSA6B:def 3;
  thus s.a = 0 implies IExec(if=0(a,I,J),P,s) = IExec(I,P,s) +* Start-At( (
  card I + card J + 3),SCM+FSA) by A1,Th17,SCMFSA7B:24;
 J is_halting_on Initialized s,P by SCMFSA7B:25;
  hence thesis by Th19,SCMFSA7B:24;
end;

theorem Th21:
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds IC IExec(if=0(a,I,J),P,s) =
(card I + card J + 3) & (s.a = 0 implies ((for d being Int-Location
 holds IExec(if=0(a,I,J),P,s).d = IExec(I,P,s).d) &
   for f being FinSeq-Location
    holds IExec(if=0(a,I,J),P,s).f = IExec(I,P,s).f)) &
    (s.a <> 0 implies ((for d being
  Int-Location holds IExec(if=0(a,I,J),P,s).d = IExec(J,P,s).d) & for f being
  FinSeq-Location holds IExec(if=0(a,I,J),P,s).f = IExec(J,P,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby
    per cases;
    suppose
      s.a = 0;
      then
      IExec(if=0(a,I,J),P,s) = IExec(I,P,s) +* Start-At( (card I + card
      J + 3),SCM+FSA) by Th20;
      hence IC IExec(if=0(a,I,J),P,s) =  (card I + card J + 3) by FUNCT_4:121
;
    end;
    suppose
      s.a <> 0;
      then
      IExec(if=0(a,I,J),P,s) = IExec(J,P,s) +* Start-At( (card I + card
      J + 3),SCM+FSA) by Th20;
      hence IC IExec(if=0(a,I,J),P,s) =  (card I + card J + 3) by FUNCT_4:121
;
    end;
  end;
  hereby
    assume s.a = 0;
    then
A1: IExec(if=0(a,I,J),P,s) = IExec(I,P,s) +* Start-At( (card I + card J
    + 3),SCM+FSA) by Th20;
    hereby
      let d be Int-Location;
      not d in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:9;
      hence IExec(if=0(a,I,J),P,s).d = IExec(I,P,s).d by A1,FUNCT_4:12;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:10;
    hence IExec(if=0(a,I,J),P,s).f = IExec(I,P,s).f by A1,FUNCT_4:12;
  end;
  assume s.a <> 0;
  then
A2: IExec(if=0(a,I,J),P,s) = IExec(J,P,s) +* Start-At( (card I + card J +
  3),SCM+FSA) by Th20;
  hereby
    let d be Int-Location;
    not d in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:9;
    hence IExec(if=0(a,I,J),P,s).d = IExec(J,P,s).d by A2,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:10;
  hence thesis by A2,FUNCT_4:12;
end;

theorem Th22:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a > 0 &
     I is_closed_on s,P & I is_halting_on s,P
  holds if>0(a,I,J) is_closed_on s,P & if>0(a,I,J) is_halting_on s,P
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = Initialize s,
      P1 = P +* I1;
  set s3 = Initialize s,
      P3 = P +* if>0(a,I,J);
  set s4 = Comput(P3, s3,1);
  set i = a >0_goto  (card J + 3);
A1: I1 c= P1 by FUNCT_4:26;
        Start-At(0,SCM+FSA) c= Initialize if>0(a,I,J) by FUNCT_4:26;
   then dom Start-At(0,SCM+FSA) c= dom Initialize if>0(a,I,J)
              by RELAT_1:25;
     then
B4: not a in dom Start-At(0,SCM+FSA) by SCMFSA6B:12;
A5:  0 in dom if>0(a,I,J) by Lm2;
A6: P3. 0 = if>0(a,I,J). 0 by A5,FUNCT_4:14
    .= i by Lm3;
  IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
  then
A7: IC s3 = IC Start-At(0,SCM+FSA) by FUNCT_4:14
    .=  0 by COMPOS_1:64;
A10: if>0(a,I,J) c= P3 by FUNCT_4:26;
A11: if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67;
  card (i ';' J ';' Goto  (card I + 1))
     = card (Macro i ';' J) + card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by COMPOS_1:150
    .= card J + (2 + 1);
  then
A12: Reloc(I1,card J + 3) c= if>0(a,I,J) by A11,Lm1;
A14: Reloc(I1,card J + 3) c= P3 by A12,A10,XBOOLE_1:1;
A15: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A7,A6,PBOOLE:158;
A17: for f being FinSeq-Location holds s1.f = s4.f by A15,SCMFSA_2:97;
  for a being Int-Location holds s1.a = s4.a by A15,SCMFSA_2:97;
  then
A18: DataPart s1 = DataPart s4 by A17,SCMFSA6A:38;
  assume s.a > 0;
  then s3.a > 0 by B4,FUNCT_4:12;
  then
A19: IC Comput(P3,s3,1) =  (card J + 3) by A15,SCMFSA_2:97;
  assume
A20: I is_closed_on s,P;
  assume
A21: I is_halting_on s,P;
  then
A22: I1 is_closed_on s,P by A20,SCMFSA8A:46;
  I1 is_halting_on s,P by A20,A21,SCMFSA8A:46;
  then
A23: P1 halts_on s1 by SCMFSA7B:def 8;
  DataPart s = DataPart s1 by SCMFSA8A:10;
  then
A24: I1 is_closed_on s1,P1 by A22,Th6;
A25: Start-At(0,SCM+FSA) c= s1 by FUNCT_4:26;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A26:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P1, s1,k1) as Element of NAT;
       m in dom I1 by A22,SCMFSA7B:def 7;
      then
A27:  m < card I1 by AFINSQ_1:70;
      card Stop SCM+FSA = 1 by COMPOS_1:46;
      then
A28:  card I1 = card I + 1 by SCMFSA6A:61;
      card if>0(a,I,J) = card I + card J + 4 by Th15
        .= card J + 3 + card I1 by A28;
      then
A29:  m + (card J + 3) < card if>0(a,I,J) by A27,XREAL_1:8;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A26,EXTPRO_1:5
        .=  (m + (card J + 3)) by A25,A24,A19,A18,Th11,A14,A1;
      hence IC Comput(P3,s3,k) in dom if>0(a,I,J) by A29,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom if>0(a,I,J) by A5,A7,EXTPRO_1:3;
    end;
  end;
  hence if>0(a,I,J) is_closed_on s,P by SCMFSA7B:def 7;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P1,s1)+1))
   = CurInstr(P3,
   Comput(P3,s4,LifeSpan(P1,s1))) by EXTPRO_1:5
    .= IncAddr(CurInstr(P1,
    Comput(P1,s1,LifeSpan(P1,s1))),(card J + 3)) by A25,A24,A19,A18,Th11,A14,A1
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A23,EXTPRO_1:def 14
    .= halt SCM+FSA by COMPOS_1:93;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th23:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a > 0 &
   I is_closed_on Initialized s,P & I is_halting_on Initialized s,P
holds IExec(if>0(a,I,J),P,s)
 = IExec(I,P,s) +* Start-At((card I+card J+3),SCM+FSA)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = s +* Initialize((intloc 0).-->1),
      P1 = P +* I1;
  set s3 = s +* Initialize((intloc 0).-->1),
      P3 = P +* if>0(a,I,J);
  set s4 = Comput(P3, s3,1);
  set i = a >0_goto  (card J + 3);
B1: Initialize((intloc 0).-->1) c= s1 by FUNCT_4:26;
  Start-At(0,SCM+FSA) c= Initialize((intloc 0).-->1) by FUNCT_4:26;
  then
A1: Start-At(0,SCM+FSA) c= s1 by B1,XBOOLE_1:1;
A2: I1 c= P1 by FUNCT_4:26;
A3: if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67;
A4:  0 in dom if>0(a,I,J) by Lm2;
A5: P3. 0 = if>0(a,I,J). 0 by A4,FUNCT_4:14
    .= i by Lm3;
V: Initialize((intloc 0).-->1) c= Initialized if>0(a,I,J) by FUNCT_4:26;
   then dom Initialize((intloc 0).-->1) c= dom Initialized if>0(a,I,J)
              by RELAT_1:25;
     then
B11: not a in dom Initialize((intloc 0).-->1) by SCMFSA6A:48;
X2:IC SCM+FSA in dom Initialize((intloc 0).-->1) by COMPOS_1:225;
  then
A6: IC s3 = IC Initialize((intloc 0).-->1) by FUNCT_4:14
    .= IC Initialized if>0(a,I,J) by V,X2,GRFUNC_1:8
    .=  0 by SCMFSA6A:46;
A7: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A6,A5,PBOOLE:158;
A10: if>0(a,I,J) c= P3 by FUNCT_4:26;
A12: dom ProgramPart s = A by COMPOS_1:34;
  assume s.a > 0;
  then s3.a > 0 by B11,FUNCT_4:12;
  then
A13: IC Comput(P3,s3,1) =  (card J + 3) by A7,SCMFSA_2:97;
A15: for f being FinSeq-Location holds s1.f = s4.f by A7,SCMFSA_2:97;
  for a being Int-Location holds s1.a = s4.a by A7,SCMFSA_2:97;
  then
A16: DataPart s1 = DataPart s4 by A15,SCMFSA6A:38;
  card (i ';' J ';' Goto  (card I + 1))
     = card (Macro i ';' J) + card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by COMPOS_1:150
    .= card J + (2 + 1);
  then
A17: Reloc(I1,card J + 3) c= if>0(a,I,J) by A3,Lm1;
A19: Reloc(I1,card J + 3) c= P3 by A17,A10,XBOOLE_1:1;
  assume
A20: I is_closed_on Initialized s,P;
  assume
A21: I is_halting_on Initialized s,P;
  then
A22: P1 halts_on s1 by A20,SCMFSA8A:55;
  I1 is_closed_on Initialized s,P by A20,A21,SCMFSA8A:46;
  then
A23: I1 is_closed_on s1,P1 by Th9;
A24: CurInstr(P3,
Comput(P3,s3,LifeSpan(P1,s1)+1))
 = CurInstr(P3,
 Comput(P3,s4,LifeSpan(P1,s1)))
  by EXTPRO_1:5
    .= IncAddr(CurInstr(P1,
    Comput(P1,s1,LifeSpan(P1,s1))),(card J + 3)) by A1,A23,A13,A16,Th11,A19,A2
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A22,EXTPRO_1:def 14
    .= halt SCM+FSA by COMPOS_1:93;
  then
A25: P3 halts_on s3 by EXTPRO_1:30;
  now
    let l be Element of NAT;
    assume
A26: l < LifeSpan(P1,s1) + 1;
A27: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      hence CurInstr(P3,Comput(P3,s3,l)) <>
       halt SCM+FSA by A6,A5,A27,PBOOLE:158;
    end;
    suppose
      l <> 0;
      then consider n being Nat such that
A28:  l = n + 1 by NAT_1:6;
      assume
A29:  CurInstr(P3,Comput(P3,s3,l)) = halt SCM+FSA;
      reconsider n as Element of NAT by ORDINAL1:def 13;
      InsCode CurInstr(P1,Comput(P1,s1,n))
       = InsCode IncAddr(CurInstr(P1,
       Comput(P1,s1,n)),(card J + 3))
        by COMPOS_1:def 38
        .= InsCode CurInstr(P3,Comput(P3,s4,n))
         by A1,A23,A13,A16,Th11,A19,A2
        .= 0 by A28,A29,EXTPRO_1:5,SCMFSA_2:124;
      then
A30:  CurInstr(P1,Comput(P1,s1,n))
 = halt SCM+FSA by SCMFSA_2:122;
      n < LifeSpan(P1,s1) by A26,A28,XREAL_1:8;
      hence contradiction by A22,A30,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCM+FSA
  holds LifeSpan(P1,s1) + 1 <= l;
  then
A31: LifeSpan(P3,s3) = LifeSpan(P1,s1) + 1 by A24,A25,EXTPRO_1:def 14;
A32: DataPart Result(P1,s1) = DataPart Comput(P1, s1
,LifeSpan(P1,s1)) by A20,A21,EXTPRO_1:23,SCMFSA8A:55
    .= DataPart Comput(P3, s4,LifeSpan(P1,s1)) by A1,A23,A13,A16,Th11,A19,A2
    .= DataPart Comput(P3, s3,LifeSpan(P1,s1) + 1)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A25,A31,EXTPRO_1:23;
A33: now
    let x be set;
A34: dom Start-At((card I+card J+3),SCM+FSA)= {IC SCM+FSA}
 by FUNCOP_1:19;
A35: IExec(if>0(a,I,J),P,s) = (Result(P3,s3)) +* s|NAT by SCMFSA6B:def 1;
A36: IExec(I1,P,s) = Result(P1,s1) +* s|NAT by SCMFSA6B:def 1;
A37: dom ProgramPart s = NAT by COMPOS_1:34;
    assume
A38: x in dom IExec(if>0(a,I,J),P,s);
    per cases by A38,SCMFSA6A:35;
    suppose
A39:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A40:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A34,TARSKI:def 1;
      thus IExec(if>0(a,I,J),P,s).x = (Result(P3,s3)).x by A35,A39,A37,
FUNCT_4:12,SCMFSA10:3
        .= (Result(P1,s1)).x by A32,A39,SCMFSA6A:38
        .= IExec(I1,P,s).x by A36,A39,A37,FUNCT_4:12,SCMFSA10:3
        .= (IExec(I1,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x by A40,
FUNCT_4:12;
    end;
    suppose
A41:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A42:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A34,TARSKI:def 1;
      thus IExec(if>0(a,I,J),P,s).x = (Result(P3,s3)).x by A35,A41,A37,
FUNCT_4:12,SCMFSA10:4
        .= (Result(P1,s1)).x by A32,A41,SCMFSA6A:38
        .= IExec(I1,P,s).x by A36,A41,A37,FUNCT_4:12,SCMFSA10:4
        .= (IExec(I1,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x by A42,
FUNCT_4:12;
    end;
    suppose
A43:  x = IC SCM+FSA;
      then
A44:  x in dom Start-At((card I+card J+3),SCM+FSA)by A34,TARSKI:def 1;
    not x in dom(s|NAT) by A43,A37,COMPOS_1:def 12;
      then
A45:  IC Result(P1,s1) = IExec(I1,P,s).IC SCM+FSA by A36,A43,FUNCT_4:12
        .= IC (IExec(I,P,s) +* Start-At( card I,SCM+FSA))
         by A20,A21,SCMFSA8A:57
        .=  card I by FUNCT_4:121;
    not x in dom(s|NAT) by A43,A37,COMPOS_1:def 12;
      hence IExec(if>0(a,I,J),P,s).x = (Result(P3,s3)).x by A35,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P1,s1) + 1).x by A25,A31,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P1,s1)) by A43,EXTPRO_1:5
        .= IC Comput(P1, s1,LifeSpan(P1,s1)) + (card
J + 3) by A1,A23,A13,A16,Th11,A2,A19
        .= IC Result(P1,s1) + (card J + 3)
               by A20,A21,EXTPRO_1:23,SCMFSA8A:55
        .= (Start-At((card I+(card J+3)),SCM+FSA)).IC SCM+FSA by A45,
FUNCOP_1:87
        .= (IExec(I1,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A43,A44,FUNCT_4:14;
    end;
    suppose
A46:  x is Element of NAT;
      then x <> IC SCM+FSA by COMPOS_1:3;
      then
A47:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A34,TARSKI:def 1;
      thus IExec(if>0(a,I,J),P,s).x = (s|NAT).x by A35,A46,A12,FUNCT_4:14
        .= IExec(I1,P,s).x by A36,A46,A12,FUNCT_4:14
        .= (IExec(I1,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x by A47,
FUNCT_4:12;
    end;
  end;
  dom IExec(if>0(a,I,J),P,s) = the carrier of SCM+FSA by PARTFUN1:def 4
    .= dom (IExec(I1,P,s) +* Start-At((card I+card J+3),SCM+FSA))
     by PARTFUN1:def 4;
  hence IExec(if>0(a,I,J),P,s) = IExec(I1,P,s) +* Start-At( (card I + card J
  + 3),SCM+FSA) by A33,FUNCT_1:9
    .= IExec(I,P,s) +* Start-At( card I,SCM+FSA) +*
     Start-At( (card I +
  card J + 3),SCM+FSA) by A20,A21,SCMFSA8A:57
    .= IExec(I,P,s) +* Start-At((card I+card J+3),SCM+FSA)by FUNCT_4:122;
end;

theorem Th24:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a <= 0 & J is_closed_on s,P &
    J is_halting_on s,P
  holds if>0(a,I,J) is_closed_on s,P & if>0(a,I,J) is_halting_on s,P
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = Initialize s,
      P2 = P +* JI2;
A1: JI2 c= P2 by FUNCT_4:26;
  set s3 = Initialize s,
      P3 = P +* if>0(a,I,J);
  set s4 = Comput(P3, s3,1);
  set s5 = Comput(P3,s3,2);
  set i = a >0_goto  (card J + 3);
A2: Start-At(0,SCM+FSA) c= s2 by FUNCT_4:26;
  IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
  then
A5: IC s3 = IC Start-At(0,SCM+FSA) by FUNCT_4:14
    .=  0 by COMPOS_1:64;
A8: if>0(a,I,J) c= P3 by FUNCT_4:26;
A9: if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:67;
  then
A10: Reloc(JI2,card Macro i) c= if>0(a,I,J) by Lm1;
    card Macro i = 2 by COMPOS_1:150;
    then
A12: Reloc(JI2,2) c= P3 by A8,A10,XBOOLE_1:1;
        Start-At(0,SCM+FSA) c= Initialize if>0(a,I,J) by FUNCT_4:26;
   then dom Start-At(0,SCM+FSA) c= dom Initialize if>0(a,I,J)
              by RELAT_1:25;
     then
B13: not a in dom Start-At(0,SCM+FSA) by SCMFSA6B:12;
A14:  0 in dom if>0(a,I,J) by Lm2;
A15: P3. 0 = if>0(a,I,J). 0 by A14,FUNCT_4:14
    .= i by Lm3;
A16:  1 in dom if>0(a,I,J) by Lm2;
A17: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A5,A15,PBOOLE:158;
  assume s.a <= 0;
  then s3.a <= 0 by B13,FUNCT_4:12;
  then
A18: IC Comput(P3,s3,1) = succ  0 by A5,A17,SCMFSA_2:97
    .=  (0 + 1);
A19: P3.1 = if>0(a,I,J). 1 by A16,FUNCT_4:14
    .= goto  2 by Lm3;
  assume
A20: J is_closed_on s,P;
A21: Comput(P3, s3,1 + 1) = Following(P3,s4) by EXTPRO_1:4
    .= Exec(goto  2,s4) by A18,A19,PBOOLE:158;
A23: now
    let f be FinSeq-Location;
    thus s2.f = Comput(P3,s3,1).f by A17,SCMFSA_2:97
      .= s5.f by A21,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s2.a = Comput(P3,s3,1).a by A17,SCMFSA_2:97
      .= s5.a by A21,SCMFSA_2:95;
  end;
  then
A24: DataPart s2 = DataPart s5 by A23,SCMFSA6A:38;
  assume
A25: J is_halting_on s,P;
  then
A26: JI2 is_closed_on s,P by A20,SCMFSA8A:58;
  then
A27: JI2 is_closed_on s2,P2 by Th10;
A28: P2 halts_on s2 by A20,A25,SCMFSA8A:59;
A29: IC s5 =  2 by A21,SCMFSA_2:95;
  now
    let k be Element of NAT;
    k = 0 or 0 + 1 < k + 1 by XREAL_1:8;
    then
A30: k = 0 or 1 <= k by NAT_1:13;
    per cases by A30,XXREAL_0:1;
    suppose
A31:  1 < k;
      then consider k1 being Nat such that
A32:  k1 + 1 = k by NAT_1:6;
      0 + 1 < k1 + 1 by A31,A32;
      then consider k2 being Nat such that
A33:  k2 + 1 = k1 by NAT_1:6;
      reconsider k1,k2 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P2, s2,k2) as Element of NAT;
A34:  card if>0(a,I,J) = card Macro i + card JI2 by A9,SCMFSA6A:61
        .= 2 + card JI2 by COMPOS_1:150;
       m in dom JI2 by A26,SCMFSA7B:def 7;
      then m < card JI2 by AFINSQ_1:70;
      then
A35:  m + 2 < card if>0(a,I,J) by A34,XREAL_1:8;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A32,EXTPRO_1:5
        .= IC Comput(P3, Comput(
P3, s4,1),k2) by A33,EXTPRO_1:5
        .= IC Comput(P3, Comput(
P3, s3,1 + 1),k2) by EXTPRO_1:5
        .=  (m + 2) by A2,A27,A29,A24,Th11,A12,A1;
      hence IC Comput(P3,s3,k) in dom if>0(a,I,J) by A35,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom if>0(a,I,J) by A14,A5,EXTPRO_1:3;
    end;
    suppose
      k = 1;
      hence IC Comput(P3,s3,k) in dom if>0(a,I,J) by A18,Lm2;
    end;
  end;
  hence if>0(a,I,J) is_closed_on s,P by SCMFSA7B:def 7;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+2))
   = CurInstr(P3,
   Comput(P3,s5,LifeSpan(P2,s2))) by EXTPRO_1:5
    .= IncAddr(CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))),2) by A2,A27,A12,A29,A24,Th11,A1
    .= IncAddr(halt SCM+FSA,2) by A28,EXTPRO_1:def 14
    .= halt SCM+FSA by COMPOS_1:93;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th25:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <= 0 &
    J is_closed_on Initialized s,P & J is_halting_on Initialized s,P
holds IExec(if>0(a,I,J),P,s)
 = IExec(J,P,s) +* Start-At((card I+card J+3),SCM+FSA)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = s +* Initialize((intloc 0).-->1),
      P2 = P +* JI2;
A1: JI2 c= P2 by FUNCT_4:26;
  set s3 = s +* Initialize((intloc 0).-->1),
      P3 = P +* if>0(a,I,J);
  set s4 = Comput(P3, s3,1);
  set s5 = Comput(P3,s3,2);
  set i = a >0_goto  (card J + 3);
B1: Initialize((intloc 0).-->1) c= s2 by FUNCT_4:26;
  Start-At(0,SCM+FSA) c= Initialize((intloc 0).-->1) by FUNCT_4:26;
  then
A2: Start-At(0,SCM+FSA) c= s2 by B1,XBOOLE_1:1;
  0 in dom if>0(a,I,J) by Lm2;
  then
A3: P3. 0 = if>0(a,I,J). 0 by FUNCT_4:14
    .= i by Lm3;
A5:  1 in dom if>0(a,I,J) by Lm2;
A6: P3. 1 = if>0(a,I,J). 1 by A5,FUNCT_4:14
    .= goto  2 by Lm3;
V:   Initialize((intloc 0).-->1) c= Initialized if>0(a,I,J) by FUNCT_4:26;
   then dom Initialize((intloc 0).-->1) c= dom Initialized if>0(a,I,J)
              by RELAT_1:25;
     then
B10: not a in dom Initialize((intloc 0).-->1) by SCMFSA6A:48;
X2: IC SCM+FSA in dom Initialize((intloc 0).-->1) by COMPOS_1:225;
  then
A7: IC s3 = IC Initialize((intloc 0).-->1) by FUNCT_4:14
    .= IC Initialized if>0(a,I,J) by V,X2,GRFUNC_1:8
    .=  0 by SCMFSA6A:46;
A8: ProgramPart JI2 = JI2 by RELAT_1:209;
  if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:67;
  then Reloc(ProgramPart JI2,card Macro i) c= if>0(a,I,J) by Lm1,A8;
  then
A9: Reloc(ProgramPart JI2,2) c= if>0(a,I,J) by COMPOS_1:150;
A11: dom ProgramPart s = NAT by COMPOS_1:34;
 if>0(a,I,J) c= P3 by FUNCT_4:26;
   then
A13: Reloc(JI2,2) c= P3 by A9,A8,XBOOLE_1:1;
A14: Comput(P3, s3,0 + 1) =
Following(P3,Comput(P3,s3,0))
 by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A7,A3,PBOOLE:158;
  assume s.a <= 0;
  then s3.a <= 0 by B10,FUNCT_4:12;
  then
A15: IC Comput(P3,s3,1) = succ  0 by A7,A14,SCMFSA_2:97
    .=  (0 + 1);
  assume
A16: J is_closed_on Initialized s,P;
A17: Comput(P3, s3,1 + 1) = Following(P3,s4) by EXTPRO_1:4
    .= Exec(goto  2,s4) by A15,A6,PBOOLE:158;
  then
A18: IC s5 =  2 by SCMFSA_2:95;
A20: now
    let f be FinSeq-Location;
    thus s2.f = Comput(P3,s3,1).f by A14,SCMFSA_2:97
      .= s5.f by A17,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s2.a = Comput(P3,s3,1).a by A14,SCMFSA_2:97
      .= s5.a by A17,SCMFSA_2:95;
  end;
  then
A21: DataPart s2 = DataPart s5 by A20,SCMFSA6A:38;
  assume
A22: J is_halting_on Initialized s,P;
  then
A23: P2 halts_on s2 by A16,SCMFSA8A:60;
  JI2 is_closed_on Initialized s,P by A16,A22,SCMFSA8A:58;
  then
A24: JI2 is_closed_on s2,P2 by Th9;
A25: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+2))
 = CurInstr(P3,
 Comput(P3,s5,LifeSpan(P2,s2))) by EXTPRO_1:5
    .= IncAddr(CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))),2)
     by A2,A24,A18,A21,Th11,A13,A1
    .= IncAddr(halt SCM+FSA,2) by A23,EXTPRO_1:def 14
    .= halt SCM+FSA by COMPOS_1:93;
  then
A26: P3 halts_on s3 by EXTPRO_1:30;
  now
    let l be Element of NAT;
    assume
A27: l < LifeSpan(P2,s2) + 2;
A28: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      hence CurInstr(P3,Comput(P3,s3,l)) <>
       halt SCM+FSA by A7,A3,A28,PBOOLE:158;
    end;
    suppose
      l = 1;
      hence CurInstr(P3,Comput(P3,s3,l)) <>
       halt SCM+FSA by A15,A6,PBOOLE:158;
    end;
    suppose
A29:  l <> 0 & l <> 1;
      assume
A30:  CurInstr(P3,Comput(P3,
s3,l)) = halt SCM+FSA;
      consider n being Nat such that
A31:  l = n + 1 by A29,NAT_1:6;
      n <> 0 by A29,A31;
      then consider l2 being Nat such that
A32:  n = l2 + 1 by NAT_1:6;
      reconsider l2 as Element of NAT by ORDINAL1:def 13;
      InsCode CurInstr(P2,Comput(P2,s2,l2))
       = InsCode IncAddr(CurInstr(P2,
       Comput(P2,s2,l2)),2) by COMPOS_1:def 38
        .= InsCode CurInstr(P3,Comput(P3,s5,l2))
         by A2,A24,A18,A21,Th11,A13,A1
        .= InsCode CurInstr(P3,Comput(P3,s3,l2+(1+1)))
         by EXTPRO_1:5
        .= 0 by A31,A32,A30,SCMFSA_2:124;
      then
A33:  CurInstr(P2,Comput(P2,s2,l2))
 = halt SCM+FSA by SCMFSA_2:122;
      n + 1 < LifeSpan(P2,s2) + 1 + 1 by A27,A31;
      then n < LifeSpan(P2,s2) + 1 by XREAL_1:8;
      then l2 < LifeSpan(P2,s2) by A32,XREAL_1:8;
      hence contradiction by A23,A33,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCM+FSA
  holds LifeSpan(P2,s2) + 2 <= l;
  then
A34: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 2 by A25,A26,EXTPRO_1:def 14;
A35: DataPart Result(P2,s2) = DataPart Comput(P2, s2
,LifeSpan(P2,s2)) by A22,A16,EXTPRO_1:23,SCMFSA8A:60
    .= DataPart Comput(P3, s5,LifeSpan(P2,s2)) by A2,A24,A18,A21,Th11,A13,A1
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 2)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A26,A34,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom Start-At((card I+card J+3),SCM+FSA)= {IC SCM+FSA}
 by FUNCOP_1:19;
A38: IExec(if>0(a,I,J),P,s) = (Result(P3,s3)) +* s|NAT by SCMFSA6B:def 1;
A39: IExec(JI2,P,s) = Result(P2,s2) +* s|NAT by SCMFSA6B:def 1;
A40: dom ProgramPart s = NAT by COMPOS_1:34;
    assume
A41: x in dom IExec(if>0(a,I,J),P,s);
    per cases by A41,SCMFSA6A:35;
    suppose
A42:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A43:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A37,TARSKI:def 1;
      thus IExec(if>0(a,I,J),P,s).x = (Result(P3,s3)).x by A38,A42,A40,
FUNCT_4:12,SCMFSA10:3
        .= (Result(P2,s2)).x by A35,A42,SCMFSA6A:38
        .= IExec(JI2,P,s).x by A39,A42,A40,FUNCT_4:12,SCMFSA10:3
        .= (IExec(JI2,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A43,FUNCT_4:12;
    end;
    suppose
A44:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A45:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A37,TARSKI:def 1;
      thus IExec(if>0(a,I,J),P,s).x = (Result(P3,s3)).x by A38,A44,A40,
FUNCT_4:12,SCMFSA10:4
        .= (Result(P2,s2)).x by A35,A44,SCMFSA6A:38
        .= IExec(JI2,P,s).x by A39,A44,A40,FUNCT_4:12,SCMFSA10:4
        .= (IExec(JI2,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A45,FUNCT_4:12;
    end;
    suppose
A46:  x = IC SCM+FSA;
      then
A47:  x in dom Start-At((card I+card J+3),SCM+FSA)by A37,TARSKI:def 1;
A48:    not x in dom(s|NAT) by A46,A40,COMPOS_1:def 12;
     then
A49:  IC Result(P2,s2) = IC IExec(JI2,P,s)
 by A39,A46,FUNCT_4:12
        .=  (card I + card J + 1) by A16,A22,SCMFSA8A:61;
      thus IExec(if>0(a,I,J),P,s).x = (Result(P3,s3)).x by A38,A48,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P2,s2) + 2).x by A26,A34,EXTPRO_1:23
        .= IC Comput(P3, s5,LifeSpan(P2,s2)) by A46,EXTPRO_1:5
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 2 by A2,A24,A18,A21,Th11,A13,A1
        .= IC Result(P2,s2) + 2 by A22,A16,EXTPRO_1:23,SCMFSA8A:60
        .= (Start-At ( (card I + card J + 1) + 2,SCM+FSA)).IC SCM+FSA
         by A49,FUNCOP_1:87
        .= (IExec(JI2,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A46,A47,FUNCT_4:14;
    end;
    suppose
A50:  x is Element of NAT;
      then x <> IC SCM+FSA by COMPOS_1:3;
      then
A51:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A37,TARSKI:def 1;
      thus IExec(if>0(a,I,J),P,s).x = (s|NAT).x by A38,A50,A11,FUNCT_4:14
        .= IExec(JI2,P,s).x by A39,A50,A11,FUNCT_4:14
        .= (IExec(JI2,P,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A51,FUNCT_4:12;
    end;
  end;
  dom IExec(if>0(a,I,J),P,s) = the carrier of SCM+FSA by PARTFUN1:def 4
    .= dom (IExec(JI2,P,s) +* Start-At((card I+card J+3),SCM+FSA))
     by PARTFUN1:def 4;
  hence
  IExec(if>0(a,I,J),P,s) = IExec(JI2,P,s) +* Start-At( (card I + card J
  + 3),SCM+FSA) by A36,FUNCT_1:9
    .= IExec(J,P,s) +* Start-At( (card I + card J + 1),SCM+FSA)
     +* Start-At(
   (card I + card J + 3),SCM+FSA) by A16,A22,SCMFSA8A:62
    .= IExec(J,P,s) +* Start-At((card I+card J+3),SCM+FSA)by FUNCT_4:122;
end;

theorem Th26:
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds if>0(a,I,J) is parahalting & (s.
  a > 0 implies IExec(if>0(a,I,J),P,s) = IExec(I,P,s) +* Start-At( (card I +
card J + 3),SCM+FSA)) & (s.a <= 0 implies IExec(if>0(a,I,J),P,s) =
 IExec(J,P,s) +* Start-At((card I + card J + 3),SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
A1: I is_halting_on Initialized s,P by SCMFSA7B:25;
  for s being State of SCM+FSA st Start-At(0,SCM+FSA) c= s
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
   st if>0(a,I,J) c= P
  holds P halts_on s
  proof
    let s be State of SCM+FSA;
    assume Start-At(0,SCM+FSA) c= s;
    then
A3: s = Initialize s by FUNCT_4:104;
    let Q be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
    such that
A4:  if>0(a,I,J) c= Q;
A5:  if>0(a,I,J) c= Q by A4;
A6: I is_closed_on s,Q by SCMFSA7B:24;
A7: I is_halting_on s,Q by SCMFSA7B:25;
A8: J is_halting_on s,Q by SCMFSA7B:25;
A9: J is_closed_on s,Q by SCMFSA7B:24;
A10:  Q +* if>0(a,I,J) = Q by A5,FUNCT_4:104;
    per cases;
    suppose
    s.a > 0;
      then if>0(a,I,J) is_halting_on s,Q by A6,A7,Th22;
      hence Q halts_on s by A3,A10,SCMFSA7B:def 8;
    end;
    suppose
      s.a <= 0;
      then if>0(a,I,J) is_halting_on s,Q by A9,A8,Th24;
      hence Q halts_on s by A3,A10,SCMFSA7B:def 8;
    end;
  end;
  hence if>0(a,I,J) is parahalting by SCMFSA6B:def 3;
  thus s.a > 0 implies IExec(if>0(a,I,J),P,s) = IExec(I,P,s) +* Start-At( (
  card I + card J + 3),SCM+FSA) by A1,Th23,SCMFSA7B:24;
 J is_halting_on Initialized s,P by SCMFSA7B:25;
  hence thesis by Th25,SCMFSA7B:24;
end;

theorem Th27:
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds IC IExec(if>0(a,I,J),P,s) =
(card I + card J + 3) & (s.a > 0 implies
 ((for d being Int-Location holds IExec(if>0(a,I,J),P,s).d = IExec(I,P,s).d) &
   for f being FinSeq-Location
    holds IExec(if>0(a,I,J),P,s).f = IExec(I,P,s).f)) &
   (s.a <= 0 implies ((for d being
  Int-Location holds IExec(if>0(a,I,J),P,s).d = IExec(J,P,s).d) & for f being
  FinSeq-Location holds IExec(if>0(a,I,J),P,s).f = IExec(J,P,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby
    per cases;
    suppose
      s.a > 0;
      then
      IExec(if>0(a,I,J),P,s) = IExec(I,P,s) +* Start-At( (card I + card
      J + 3),SCM+FSA) by Th26;
      hence IC IExec(if>0(a,I,J),P,s) =  (card I + card J + 3) by FUNCT_4:121;
    end;
    suppose
      s.a <= 0;
      then
      IExec(if>0(a,I,J),P,s) = IExec(J,P,s) +* Start-At( (card I + card
      J + 3),SCM+FSA) by Th26;
      hence IC IExec(if>0(a,I,J),P,s) =  (card I + card J + 3) by FUNCT_4:121;
    end;
  end;
  hereby
    assume s.a > 0;
    then
A1: IExec(if>0(a,I,J),P,s) = IExec(I,P,s) +* Start-At( (card I + card J
    + 3),SCM+FSA) by Th26;
    hereby
      let d be Int-Location;
      not d in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:9;
      hence IExec(if>0(a,I,J),P,s).d = IExec(I,P,s).d by A1,FUNCT_4:12;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:10;
    hence IExec(if>0(a,I,J),P,s).f = IExec(I,P,s).f by A1,FUNCT_4:12;
  end;
  assume s.a <= 0;
  then
A2: IExec(if>0(a,I,J),P,s) = IExec(J,P,s) +* Start-At( (card I + card J +
  3),SCM+FSA) by Th26;
  hereby
    let d be Int-Location;
    not d in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:9;
    hence IExec(if>0(a,I,J),P,s).d = IExec(J,P,s).d by A2,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:10;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
read-write Int-Location st s.a < 0 & I is_closed_on s,P & I is_halting_on s,P
   holds
  if<0(a,I,J) is_closed_on s,P & if<0(a,I,J) is_halting_on s,P
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a < 0;
  assume that
A2: I is_closed_on s,P and
A3: I is_halting_on s,P;
A4: if>0(a,J,I) is_halting_on s,P by A1,A2,A3,Th24;
  if>0(a,J,I) is_closed_on s,P by A1,A2,A3,Th24;
  hence thesis by A1,A4,Th18;
end;

theorem Th29:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a < 0 & I is_closed_on Initialized s,P & I
is_halting_on Initialized s,P
holds IExec(if<0(a,I,J),P,s) = IExec(I,P,s) +* Start-At(
   (card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a < 0;
  assume that
A2: I is_closed_on Initialized s,P and
A3: I is_halting_on Initialized s,P;
A4: (Initialized s).a <= 0 by A1,SCMFSA6C:3;
  then
A5: if>0(a,J,I) is_halting_on Initialized s,P by A2,A3,Th24;
  if>0(a,J,I) is_closed_on Initialized s,P by A2,A3,A4,Th24;
  hence IExec(if<0(a,I,J),P,s) = IExec(if>0(a,J,I),P,s) +* Start-At( (card
  if>0(a,J,I) + card J + 3),SCM+FSA) by A1,A5,Th19
    .= IExec(if>0(a,J,I),P,s) +* Start-At( (card I + card J + 4 + card J
  + 3),SCM+FSA) by Th15
    .= IExec(I,P,s) +* Start-At((card I+card J+3),SCM+FSA)+* Start-At(
   (card I + card J + 4 + card J + 3),SCM+FSA) by A1,A2,A3,Th25
    .= IExec(I,P,s) +* Start-At( (card I + card J + card J + 7),SCM+FSA) by
FUNCT_4:122;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
read-write Int-Location st s.a = 0 & J is_closed_on s,P & J is_halting_on s,P
   holds
  if<0(a,I,J) is_closed_on s,P & if<0(a,I,J) is_halting_on s,P by Th16;

theorem Th31:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & J is_closed_on Initialized s,P & J
is_halting_on Initialized s,P
holds IExec(if<0(a,I,J),P,s) = IExec(J,P,s) +* Start-At(
   (card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  assume that
A2: J is_closed_on Initialized s,P and
A3: J is_halting_on Initialized s,P;
  thus IExec(if<0(a,I,J),P,s) = IExec(J,P,s) +* Start-At( (card if>0(a,J,I)
  + card J + 3),SCM+FSA) by A1,A2,A3,Th17
    .= IExec(J,P,s) +* Start-At( (card I + card J + 4 +
     card J + 3),SCM+FSA) by Th15
    .= IExec(J,P,s) +* Start-At( (card I + card J + card J + 7),SCM+FSA);
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
read-write Int-Location st s.a > 0 & J is_closed_on s,P & J is_halting_on s,P
 holds
  if<0(a,I,J) is_closed_on s,P & if<0(a,I,J) is_halting_on s,P
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  assume that
A2: J is_closed_on s,P and
A3: J is_halting_on s,P;
A4: if>0(a,J,I) is_halting_on s,P by A1,A2,A3,Th22;
  if>0(a,J,I) is_closed_on s,P by A1,A2,A3,Th22;
  hence thesis by A1,A4,Th18;
end;

theorem Th33:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & J is_closed_on Initialized s,P & J
is_halting_on Initialized s,P
holds IExec(if<0(a,I,J),P,s) = IExec(J,P,s) +* Start-At(
   (card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  assume that
A2: J is_closed_on Initialized s,P and
A3: J is_halting_on Initialized s,P;
A4: (Initialized s).a > 0 by A1,SCMFSA6C:3;
  then
A5: if>0(a,J,I) is_halting_on Initialized s,P by A2,A3,Th22;
  if>0(a,J,I) is_closed_on Initialized s,P by A2,A3,A4,Th22;
  hence IExec(if<0(a,I,J),P,s) = IExec(if>0(a,J,I),P,s) +* Start-At( (card
  if>0(a,J,I) + card J + 3),SCM+FSA) by A1,A5,Th19
    .= IExec(if>0(a,J,I),P,s) +* Start-At( (card I + card J + 4 + card J
  + 3),SCM+FSA) by Th15
    .= IExec(J,P,s) +* Start-At((card I+card J+3),SCM+FSA)+* Start-At(
   (card I + card J + 4 + card J + 3),SCM+FSA) by A1,A2,A3,Th23
    .= IExec(J,P,s) +* Start-At( (card I + card J + card J + 7),SCM+FSA) by
FUNCT_4:122;
end;

theorem
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA
  , a being read-write Int-Location holds if<0(a,I,J) is parahalting & (s.a < 0
implies IExec(if<0(a,I,J),P,s) = IExec(I,P,s) +* Start-At( (card I + card J +
card J + 7),SCM+FSA)) & (s.a >= 0 implies IExec(if<0(a,I,J),P,s) =
 IExec(J,P,s) +* Start-At((card I + card J + card J + 7),SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  if>0(a,J,I) is parahalting by Th26;
  hence if<0(a,I,J) is parahalting by Th20;
  hereby
A1: I is_halting_on Initialized s,P by SCMFSA7B:25;
    assume s.a < 0;
    hence
    IExec(if<0(a,I,J),P,s) = IExec(I,P,s) +* Start-At( (card I + card J
    + card J + 7),SCM+FSA) by A1,Th29,SCMFSA7B:24;
  end;
  hereby
    assume
A2: s.a >= 0;
A3: J is_halting_on Initialized s,P by SCMFSA7B:25;
    per cases;
    suppose
      s.a = 0;
      hence
      IExec(if<0(a,I,J),P,s) = IExec(J,P,s) +* Start-At( (card I + card
      J + card J + 7),SCM+FSA) by A3,Th31,SCMFSA7B:24;
    end;
    suppose
      s.a <> 0;
      hence
      IExec(if<0(a,I,J),P,s) = IExec(J,P,s) +* Start-At( (card I + card
      J + card J + 7),SCM+FSA) by A2,A3,Th33,SCMFSA7B:24;
    end;
  end;
end;

registration
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  cluster if=0(a,I,J) -> parahalting;
  correctness by Th20;
  cluster if>0(a,I,J) -> parahalting;
  correctness by Th26;
end;

definition
  let a,b be Int-Location;
  let I,J be Program of SCM+FSA;
  func if=0(a,b,I,J) -> Program of SCM+FSA equals
  SubFrom(a,b) ';' if=0(a,I,J);
  coherence;
  func if>0(a,b,I,J) -> Program of SCM+FSA equals
  SubFrom(a,b) ';' if>0(a,I,J);
  coherence;
end;

registration
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
 cluster if=0(a,I,J) -> non halt-free;
 coherence;
 cluster  if>0(a,I,J) -> non halt-free;
 coherence;
 cluster if<0(a,I,J) -> non halt-free;
 coherence;
end;

registration
  let a,b be Int-Location;
  let I,J be Program of SCM+FSA;
 cluster if=0(a,b,I,J) -> non halt-free;
 coherence;
 cluster if>0(a,b,I,J) -> non halt-free;
 coherence;
end;

notation
  let a,b be Int-Location;
  let I,J be Program of SCM+FSA;
  synonym if<0(b,a,I,J) for if>0(a,b,I,J);
end;

registration
  let I,J be parahalting Program of SCM+FSA;
  let a,b be read-write Int-Location;
  cluster if=0(a,b,I,J) -> parahalting;
  correctness;
  cluster if>0(a,b,I,J) -> parahalting;
  correctness;
end;

theorem Th35:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  DataPart Result(P+*I,s +* Initialize((intloc 0).-->1))
   = DataPart IExec(I,P,s)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialize((intloc 0).-->1),
      P1 = P +* I;
A1: IExec(I,P,s) = Result(P1,s1) +* s|NAT by SCMFSA6B:def 1;
A2: now
    let f be FinSeq-Location;
     f in dom ProgramPart s implies f is Element of NAT by COMPOS_1:34;
    hence IExec(I,P,s).f = (Result(P1,s1)).f by A1,FUNCT_4:12,SCMFSA_2:85;
  end;
  now
    let b be Int-Location;
     b in dom ProgramPart s implies b is Element of NAT by COMPOS_1:34;
    hence IExec(I,P,s).b = (Result(P1,s1)).b by A1,FUNCT_4:12,SCMFSA_2:84;
  end;
  hence thesis by A2,SCMFSA6A:38;
end;

theorem Th36:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
  being Int-Location
   holds NPP Result(P+*I,s +* Initialize((intloc 0).-->1)) = NPP IExec(I,P,s)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  set s1 = s +* Initialize((intloc 0).-->1),
      P1 = P +* I;
A1: IC Result(P1,s1) = IC IExec(I,P,s) by SCMFSA8A:7;
A2: DataPart Result(P1,s1) = DataPart IExec(I,P,s) by Th35;
  then
A3: for f being FinSeq-Location
 holds (Result(P1,s1)).f = IExec(I,P,s).f by SCMFSA6A:38;
  for a being Int-Location
   holds (Result(P1,s1)).a = IExec(I,P,s).a
by A2,SCMFSA6A:38
;
  hence thesis by A3,A1,SCMFSA10:91;
end;

theorem Th37:
  for s1,s2 being State of SCM+FSA, i being Instruction of SCM+FSA
  , a being Int-Location holds (for b being Int-Location st a <> b holds s1.b =
s2.b) & (for f being FinSeq-Location holds s1.f = s2.f) & i does not refer a &
IC s1 = IC s2 implies (for b being Int-Location st a <> b holds Exec(i,s1).b =
Exec(i,s2).b) & (for f being FinSeq-Location holds Exec(i,s1).f = Exec(i,s2).f)
  & IC Exec(i,s1) = IC Exec(i,s2)
proof
  let s1,s2 be State of SCM+FSA;
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  defpred S[State of SCM+FSA,State of SCM+FSA] means (for b being Int-Location
  st a <> b holds $1.b = $2.b) & for f being FinSeq-Location holds $1.f = $2.f;
  assume
A1: S[s1,s2];
  assume
A4: i does not refer a;
A5: InsCode i <= 13 by SCMFSA_2:35;
A6: now
    let b be Int-Location;
    assume
A7: a <> b;
    per cases by A5,NAT_1:38;
    suppose
      InsCode i = 0;
      then
A8:   i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s1).b = s1.b by EXTPRO_1:def 3
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A8,EXTPRO_1:def 3;
    end;
    suppose
      InsCode i = 1;
      then consider da, db being Int-Location such that
A9:   i = da := db by SCMFSA_2:54;
A10:  a <> db by A4,A9,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A11:      b = da;
          hence Exec(i,s1).b = s1.db by A9,SCMFSA_2:89
            .= s2.db by A1,A10
            .= Exec(i,s2).b by A9,A11,SCMFSA_2:89;
        end;
        suppose
A12:      b <> da;
          hence Exec(i,s1).b = s1.b by A9,SCMFSA_2:89
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A9,A12,SCMFSA_2:89;
        end;
      end;
    end;
    suppose
      InsCode i = 2;
      then consider da, db being Int-Location such that
A13:  i = AddTo(da,db) by SCMFSA_2:55;
A14:  a <> db by A4,A13,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A15:      b = da;
          hence Exec(i,s1).b = s1.b + s1.db by A13,SCMFSA_2:90
            .= s2.b + s1.db by A1,A7
            .= s2.b + s2.db by A1,A14
            .= Exec(i,s2).b by A13,A15,SCMFSA_2:90;
        end;
        suppose
A16:      b <> da;
          hence Exec(i,s1).b = s1.b by A13,SCMFSA_2:90
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A13,A16,SCMFSA_2:90;
        end;
      end;
    end;
    suppose
      InsCode i = 3;
      then consider da, db being Int-Location such that
A17:  i = SubFrom(da, db) by SCMFSA_2:56;
A18:  a <> db by A4,A17,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A19:      b = da;
          hence Exec(i,s1).b = s1.b - s1.db by A17,SCMFSA_2:91
            .= s2.b - s1.db by A1,A7
            .= s2.b - s2.db by A1,A18
            .= Exec(i,s2).b by A17,A19,SCMFSA_2:91;
        end;
        suppose
A20:      b <> da;
          hence Exec(i,s1).b = s1.b by A17,SCMFSA_2:91
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A17,A20,SCMFSA_2:91;
        end;
      end;
    end;
    suppose
      InsCode i = 4;
      then consider da, db being Int-Location such that
A21:  i = MultBy(da,db) by SCMFSA_2:57;
A22:  a <> db by A4,A21,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A23:      b = da;
          hence Exec(i,s1).b = s1.b * s1.db by A21,SCMFSA_2:92
            .= s2.b * s1.db by A1,A7
            .= s2.b * s2.db by A1,A22
            .= Exec(i,s2).b by A21,A23,SCMFSA_2:92;
        end;
        suppose
A24:      b <> da;
          hence Exec(i,s1).b = s1.b by A21,SCMFSA_2:92
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A21,A24,SCMFSA_2:92;
        end;
      end;
    end;
    suppose
      InsCode i = 5;
      then consider da, db being Int-Location such that
A25:  i = Divide(da, db) by SCMFSA_2:58;
A26:  a <> db by A4,A25,SCMFSA7B:def 1;
A27:  a <> da by A4,A25,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A28:      b = db;
          hence Exec(i,s1).b = s1.da mod s1.db by A25,SCMFSA_2:93
            .= s2.da mod s1.db by A1,A27
            .= s2.da mod s2.db by A1,A26
            .= Exec(i,s2).b by A25,A28,SCMFSA_2:93;
        end;
        suppose
A29:      b = da & b <> db;
          hence Exec(i,s1).b = s1.da div s1.db by A25,SCMFSA_2:93
            .= s1.da div s2.db by A1,A26
            .= s2.da div s2.db by A1,A27
            .= Exec(i,s2).b by A25,A29,SCMFSA_2:93;
        end;
        suppose
A30:      b <> da & b <> db;
          hence Exec(i,s1).b = s1.b by A25,SCMFSA_2:93
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A25,A30,SCMFSA_2:93;
        end;
      end;
    end;
    suppose
      InsCode i = 6;
      then
A31:  ex loc being Element of NAT st i = goto loc by SCMFSA_2:59;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:95
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A31,SCMFSA_2:95;
    end;
    suppose
      InsCode i = 7;
      then
A32:  ex loc being Element of NAT, da being Int-Location
      st i = da =0_goto loc by SCMFSA_2:60;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:96
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A32,SCMFSA_2:96;
    end;
    suppose
      InsCode i = 8;
      then
A33:  ex loc being Element of NAT, da being Int-Location
      st i = da >0_goto loc by SCMFSA_2:61;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:97
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A33,SCMFSA_2:97;
    end;
    suppose
      InsCode i = 9;
      then consider
      db, da being Int-Location, g being FinSeq-Location such that
A34:  i = da := (g,db) by SCMFSA_2:62;
A35:  a <> db by A4,A34,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A36:      b = da;
          then consider m2 being Element of NAT such that
A37:      m2 = abs(s2.db) and
A38:      Exec(da:=(g,db), s2).b = (s2.g)/.m2 by SCMFSA_2:98;
          consider m1 being Element of NAT such that
A39:      m1 = abs(s1.db) and
A40:      Exec(da:=(g,db), s1).b = (s1.g)/.m1 by A36,SCMFSA_2:98;
          m1 = m2 by A1,A35,A39,A37;
          hence Exec(i,s1).b = Exec(i,s2).b by A1,A34,A40,A38;
        end;
        suppose
A41:      b <> da;
          hence Exec(i,s1).b = s1.b by A34,SCMFSA_2:98
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A34,A41,SCMFSA_2:98;
        end;
      end;
    end;
    suppose
      InsCode i = 10;
      then
A42:  ex db, da being Int-Location, g being FinSeq-Location st i = (g,db
      ):= da by SCMFSA_2:63;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:99
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A42,SCMFSA_2:99;
    end;
    suppose
      InsCode i = 11;
      then consider da being Int-Location, g being FinSeq-Location such that
A43:  i = da :=len g by SCMFSA_2:64;
      hereby
        per cases;
        suppose
A44:      b = da;
          hence Exec(i,s1).b = len (s1.g) by A43,SCMFSA_2:100
            .= len (s2.g) by A1
            .= Exec(i,s2).b by A43,A44,SCMFSA_2:100;
        end;
        suppose
A45:      b <> da;
          hence Exec(i,s1).b = s1.b by A43,SCMFSA_2:100
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A43,A45,SCMFSA_2:100;
        end;
      end;
    end;
    suppose
      InsCode i = 12;
      then
A46:  ex da being Int-Location, g being FinSeq-Location st i = g
      :=<0,...,0>da by SCMFSA_2:65;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:101
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A46,SCMFSA_2:101;
    end;
    suppose
      InsCode i = 13;
      then consider da being Int-Location such that
A43:  i = da :==1 by SCMFSA_2:134;
      hereby
        per cases;
        suppose
A44:      b = da;
          hence Exec(i,s1).b = 1 by A43,SCMFSA_2:136
            .= Exec(i,s2).b by A43,A44,SCMFSA_2:136;
        end;
        suppose
A45:      b <> da;
          hence Exec(i,s1).b = s1.b by A43,SCMFSA_2:136
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A43,A45,SCMFSA_2:136;
        end;
      end;
    end;
  end;
  assume
A47: IC s1 = IC s2;
  now
    let f be FinSeq-Location;
    per cases by A5,NAT_1:38;
    suppose
      InsCode i = 0;
      then
A48:  i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s1).f = s1.f by EXTPRO_1:def 3
        .= s2.f by A1
        .= Exec(i,s2).f by A48,EXTPRO_1:def 3;
    end;
    suppose
      InsCode i = 1;
      then
A49:  ex da, db being Int-Location st i = da := db by SCMFSA_2:54;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:89
        .= s2.f by A1
        .= Exec(i,s2).f by A49,SCMFSA_2:89;
    end;
    suppose
      InsCode i = 2;
      then
A50:  ex da, db being Int-Location st i = AddTo(da,db) by SCMFSA_2:55;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:90
        .= s2.f by A1
        .= Exec(i,s2).f by A50,SCMFSA_2:90;
    end;
    suppose
      InsCode i = 3;
      then
A51:  ex da, db being Int-Location st i = SubFrom(da, db) by SCMFSA_2:56;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:91
        .= s2.f by A1
        .= Exec(i,s2).f by A51,SCMFSA_2:91;
    end;
    suppose
      InsCode i = 4;
      then
A52:  ex da, db being Int-Location st i = MultBy(da,db) by SCMFSA_2:57;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:92
        .= s2.f by A1
        .= Exec(i,s2).f by A52,SCMFSA_2:92;
    end;
    suppose
      InsCode i = 5;
      then
A53:  ex da, db being Int-Location st i = Divide(da, db) by SCMFSA_2:58;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:93
        .= s2.f by A1
        .= Exec(i,s2).f by A53,SCMFSA_2:93;
    end;
    suppose
      InsCode i = 6;
      then
A54:  ex loc being Element of NAT st i = goto loc by SCMFSA_2:59;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:95
        .= s2.f by A1
        .= Exec(i,s2).f by A54,SCMFSA_2:95;
    end;
    suppose
      InsCode i = 7;
      then
A55:  ex loc being Element of NAT, da being Int-Location
      st i = da=0_goto loc by SCMFSA_2:60;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:96
        .= s2.f by A1
        .= Exec(i,s2).f by A55,SCMFSA_2:96;
    end;
    suppose
      InsCode i = 8;
      then
A56:  ex loc being Element of NAT, da being Int-Location
      st i = da>0_goto loc by SCMFSA_2:61;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:97
        .= s2.f by A1
        .= Exec(i,s2).f by A56,SCMFSA_2:97;
    end;
    suppose
      InsCode i = 9;
      then
A57:  ex db, da being Int-Location, g being FinSeq-Location st i = da :=
      (g,db) by SCMFSA_2:62;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:98
        .= s2.f by A1
        .= Exec(i,s2).f by A57,SCMFSA_2:98;
    end;
    suppose
      InsCode i = 10;
      then consider
      db, da being Int-Location, g being FinSeq-Location such that
A58:  i = (g,db):=da by SCMFSA_2:63;
A59:  a <> db by A4,A58,SCMFSA7B:def 1;
A60:  a <> da by A4,A58,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A61:      f = g;
A62:      s1.da = s2.da by A1,A60;
          consider m2 being Element of NAT such that
A63:      m2 = abs(s2.db) and
A64:      Exec((g,db):=da,s2).g = s2.g+*(m2,s2.da) by SCMFSA_2:99;
          consider m1 being Element of NAT such that
A65:      m1 = abs(s1.db) and
A66:      Exec((g,db):=da,s1).g = s1.g+*(m1,s1.da) by SCMFSA_2:99;
          m1 = m2 by A1,A59,A65,A63;
          hence Exec(i,s1).f = Exec(i,s2).f by A1,A58,A61,A66,A64,A62;
        end;
        suppose
A67:      f <> g;
          hence Exec(i,s1).f = s1.f by A58,SCMFSA_2:99
            .= s2.f by A1
            .= Exec(i,s2).f by A58,A67,SCMFSA_2:99;
        end;
      end;
    end;
    suppose
      InsCode i = 11;
      then
A68:  ex da being Int-Location, g being FinSeq-Location st i = da :=len
      g by SCMFSA_2:64;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:100
        .= s2.f by A1
        .= Exec(i,s2).f by A68,SCMFSA_2:100;
    end;
    suppose
      InsCode i = 12;
      then consider da being Int-Location, g being FinSeq-Location such that
A69:  i = g:=<0,...,0>da by SCMFSA_2:65;
A70:  a <> da by A4,A69,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A71:      f = g;
A72:      ex m2 being Element of NAT st m2 = abs(s2.da) & Exec(g
          :=<0,...,0>da, s2).g = m2 |-> 0 by SCMFSA_2:101;
          ex m1 being Element of NAT st m1 = abs(s1.da) & Exec(g
          :=<0,...,0>da, s1).g = m1 |-> 0 by SCMFSA_2:101;
          hence Exec(i,s1).f = Exec(i,s2).f by A1,A69,A70,A71,A72;
        end;
        suppose
A73:      f <> g;
          hence Exec(i,s1).f = s1.f by A69,SCMFSA_2:101
            .= s2.f by A1
            .= Exec(i,s2).f by A69,A73,SCMFSA_2:101;
        end;
      end;
    end;
    suppose
      InsCode i = 13;
      then
A68:  ex da being Int-Location st i = da :==1 by SCMFSA_2:134;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:136
        .= s2.f by A1
        .= Exec(i,s2).f by A68,SCMFSA_2:136;
    end;
  end;
  hence S[Exec(i,s1),Exec(i,s2)] by A6;
  now
    per cases by A5,NAT_1:38;
    suppose
      InsCode i = 0;
      then
A74:  i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s1).IC SCM+FSA = IC s1 by EXTPRO_1:def 3
        .= Exec(i,s2).IC SCM+FSA by A47,A74,EXTPRO_1:def 3;
    end;
    suppose
      InsCode i = 1;
      then
A75:  ex da, db being Int-Location st i = da := db by SCMFSA_2:54;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:89
        .= Exec(i,s2).IC SCM+FSA by A47,A75,SCMFSA_2:89;
    end;
    suppose
      InsCode i = 2;
      then
A76:  ex da, db being Int-Location st i = AddTo(da,db) by SCMFSA_2:55;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:90
        .= Exec(i,s2).IC SCM+FSA by A47,A76,SCMFSA_2:90;
    end;
    suppose
      InsCode i = 3;
      then
A77:  ex da, db being Int-Location st i = SubFrom(da, db) by SCMFSA_2:56;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:91
        .= Exec(i,s2).IC SCM+FSA by A47,A77,SCMFSA_2:91;
    end;
    suppose
      InsCode i = 4;
      then
A78:  ex da, db being Int-Location st i = MultBy(da,db) by SCMFSA_2:57;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:92
        .= Exec(i,s2).IC SCM+FSA by A47,A78,SCMFSA_2:92;
    end;
    suppose
      InsCode i = 5;
      then
A79:  ex da, db being Int-Location st i = Divide(da, db) by SCMFSA_2:58;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:93
        .= Exec(i,s2).IC SCM+FSA by A47,A79,SCMFSA_2:93;
    end;
    suppose
      InsCode i = 6;
      then consider loc being Element of NAT such that
A80:  i = goto loc by SCMFSA_2:59;
      thus Exec(i,s1).IC SCM+FSA = loc by A80,SCMFSA_2:95
        .= Exec(i,s2).IC SCM+FSA by A80,SCMFSA_2:95;
    end;
    suppose
      InsCode i = 7;
      then consider loc being Element of NAT, da being
      Int-Location such that
A81:  i = da =0_goto loc by SCMFSA_2:60;
      a <> da by A4,A81,SCMFSA7B:def 1;
      then
A82:  s1.da = s2.da by A1;
      hereby
        per cases;
        suppose
A83:      s1.da = 0;
          hence Exec(i,s1).IC SCM+FSA = loc by A81,SCMFSA_2:96
            .= Exec(i,s2).IC SCM+FSA by A81,A82,A83,SCMFSA_2:96;
        end;
        suppose
A84:      s1.da <> 0;
          hence Exec(i,s1).IC SCM+FSA = succ IC s1 by A81,SCMFSA_2:96
            .= Exec(i,s2).IC SCM+FSA by A47,A81,A82,A84,SCMFSA_2:96;
        end;
      end;
    end;
    suppose
      InsCode i = 8;
      then consider loc being Element of NAT, da being
      Int-Location such that
A85:  i = da>0_goto loc by SCMFSA_2:61;
      a <> da by A4,A85,SCMFSA7B:def 1;
      then
A86:  s1.da = s2.da by A1;
      hereby
        per cases;
        suppose
A87:      s1.da > 0;
          hence Exec(i,s1).IC SCM+FSA = loc by A85,SCMFSA_2:97
            .= Exec(i,s2).IC SCM+FSA by A85,A86,A87,SCMFSA_2:97;
        end;
        suppose
A88:      s1.da <= 0;
          hence Exec(i,s1).IC SCM+FSA = succ IC s1 by A85,SCMFSA_2:97
            .= Exec(i,s2).IC SCM+FSA by A47,A85,A86,A88,SCMFSA_2:97;
        end;
      end;
    end;
    suppose
      InsCode i = 9;
      then
A89:  ex db, da being Int-Location, g being FinSeq-Location st i = da
      := (g,db) by SCMFSA_2:62;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:98
        .= Exec(i,s2).IC SCM+FSA by A47,A89,SCMFSA_2:98;
    end;
    suppose
      InsCode i = 10;
      then
A90:  ex db, da being Int-Location, g being FinSeq-Location st i = (g,
      db):=da by SCMFSA_2:63;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:99
        .= Exec(i,s2).IC SCM+FSA by A47,A90,SCMFSA_2:99;
    end;
    suppose
      InsCode i = 11;
      then
A91:  ex da being Int-Location, g being FinSeq-Location st i = da :=len
      g by SCMFSA_2:64;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:100
        .= Exec(i,s2).IC SCM+FSA by A47,A91,SCMFSA_2:100;
    end;
    suppose
      InsCode i = 12;
      then
A92:  ex da being Int-Location, g being FinSeq-Location st i = g
      :=<0,...,0>da by SCMFSA_2:65;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:101
        .= Exec(i,s2).IC SCM+FSA by A47,A92,SCMFSA_2:101;
    end;
    suppose
      InsCode i = 13;
      then
A91:  ex da being Int-Location st i = da :==1 by SCMFSA_2:134;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:136
        .= Exec(i,s2).IC SCM+FSA by A47,A91,SCMFSA_2:136;
    end;
  end;
  hence thesis;
end;

theorem Th38:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA,
      a being Int-Location
   st I does not refer a &
     (for b being Int-Location st a <> b holds s1.b = s2.b) &
     (for f being FinSeq-Location holds s1.f = s2.f) &
     I is_closed_on s1,P1 holds
  for k being Element of NAT holds
   (for b being Int-Location st a <> b
    holds Comput(P1+*I,(Initialize s1),k).b
     = Comput(P2+*I, (Initialize s2),k).b) &
  (for f being FinSeq-Location holds
   Comput(P1+*I,(Initialize s1),k).f
    = Comput(P2+*I, (Initialize s2),k).f) &
 IC Comput(P1+*I, (Initialize s1),k)
  = IC Comput(P2+*I, (Initialize s2),k) &
  CurInstr(P1+*I,Comput(P1+*I, (Initialize s1),k))
   = CurInstr(P2+*I,Comput(P2+*I, (Initialize s2),k))
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A2: I does not refer a;
  set S2 = Initialize s2,
      Q2 = P2 +* I;
  set S1 = Initialize s1,
      Q1 = P1 +* I;
A3: I c= Q1 by FUNCT_4:26;
A4: I c= Q2 by FUNCT_4:26;
  defpred S[State of SCM+FSA,State of SCM+FSA] means (for b being Int-Location
  st a <> b holds $1.b = $2.b) & for f being FinSeq-Location holds $1.f = $2.f;
  assume that
A5: for b being Int-Location st a <> b holds s1.b = s2.b and
A6: for f being FinSeq-Location holds s1.f = s2.f;
B7:  IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
A8: now
    let f be FinSeq-Location;
        Start-At(0,SCM+FSA) c= Initialize I by FUNCT_4:26;
   then dom Start-At(0,SCM+FSA) c= dom Initialize I by RELAT_1:25;
     then
B9:  not f in dom Start-At(0,SCM+FSA) by SCMFSA6B:13;
    hence S1.f = s1.f by FUNCT_4:12
      .= s2.f by A6
      .= S2.f by B9,FUNCT_4:12;
  end;
A10: Comput(Q2,S2,0) = S2 by EXTPRO_1:3;
  defpred P[Nat] means S[ Comput(Q1,S1,$1), Comput(Q2,S2,$1)] &
  IC Comput(Q1,S1,$1) = IC Comput(Q2,S2,$1) &
    CurInstr(Q1,Comput(Q1,S1,$1)) = CurInstr(Q2,Comput(Q2,S2,$1));
A11: IC Comput(Q1,S1,0) = IC S1 by EXTPRO_1:3
    .= IC Start-At(0,SCM+FSA) by B7,FUNCT_4:14
    .= IC S2 by B7,FUNCT_4:14
    .= IC Comput(Q2,S2,0) by EXTPRO_1:3;
A12: now
    let b be Int-Location;
    assume
A13: a <> b;
        Start-At(0,SCM+FSA) c= Initialize I by FUNCT_4:26;
   then dom Start-At(0,SCM+FSA) c= dom Initialize I by RELAT_1:25;
     then
B14:  not b in dom Start-At(0,SCM+FSA) by SCMFSA6B:12;
    hence S1.b = s1.b by FUNCT_4:12
      .= s2.b by A5,A13
      .= S2.b by B14,FUNCT_4:12;
  end;
A15: Comput(Q1,S1,0) = S1 by EXTPRO_1:3;
  assume that
A16: I is_closed_on s1,P1;
A17: IC Comput(Q1,S1,0) in dom I by A16,SCMFSA7B:def 7;
A18: for k being Element of NAT holds P[k] implies P[k + 1]
  proof
    let k be Element of NAT;
A19: Comput(Q1,S1,k+1) = Following(Q1,Comput(Q1,S1,k)) by EXTPRO_1:4
      .= Exec(CurInstr(Q1,Comput(Q1,S1,k)),
      Comput(Q1,S1,k));
A20: IC Comput(Q1,S1,k) in dom I by A16,SCMFSA7B:def 7;
A21: Comput(Q2,S2,k+1) = Following(Q2,Comput(Q2,S2,k)) by EXTPRO_1:4
      .= Exec(CurInstr(Q2,Comput(Q2,S2,k)),
      Comput(Q2,S2,k));
A22:  Q1/.IC Comput(Q1,S1,k)
 = Q1.IC Comput(Q1,S1,k) by PBOOLE:158;
    CurInstr(Q1,Comput(Q1,S1,k))
     = I.IC Comput(Q1,S1,k) by A20,A22,A3,GRFUNC_1:8;
    then CurInstr(Q1,Comput(Q1,S1,k)) in rng I by A20,FUNCT_1:def 5;
    then
A23: CurInstr(Q1,Comput(Q1,S1,k)) does not refer a
 by A2,SCMFSA7B:def 2;
    assume
A24: P[k];
    hence S[ Comput(Q1,S1,k+1), Comput(Q2,S2,k+1)]
by A19,A21,A23,Th37;
    thus
A25: IC Comput(Q1,S1,k+1) = IC Comput(Q2,S2,k+1) by A24,A19,A21,A23,Th37;
A26: IC Comput(Q1,S1,k+1) in dom I by A16,SCMFSA7B:def 7;
A27:  Q1/.IC Comput(Q1,S1,k+1)
 = Q1.IC Comput(Q1,S1,k+1) by PBOOLE:158;
A28:  Q2/.IC Comput(Q2,S2,k+1)
 = Q2.IC Comput(Q2,S2,k+1) by PBOOLE:158;
    thus CurInstr(Q1,Comput(Q1,S1,k+1))
     = I.IC Comput(Q1,S1,k+1) by A26,A27,A3,GRFUNC_1:8
      .= CurInstr(Q2,Comput(Q2,S2,k+1))
       by A25,A26,A28,A4,GRFUNC_1:8;
  end;
  CurInstr(Q1,Comput(Q1,S1,0))
   = Q1.IC Comput(Q1,S1,0) by PBOOLE:158
    .= I.IC Comput(Q1,S1,0) by A17,A3,GRFUNC_1:8
    .= Q2.IC Comput(Q2,S2,0) by A11,A17,A4,GRFUNC_1:8
    .= CurInstr(Q2,Comput(Q2,S2,0)) by PBOOLE:158;
  then
A29: P[0] by A12,A8,A15,A10,A11;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A29,A18);
  hence thesis;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, l
being Element of NAT holds I is_closed_on s,P & I is_halting_on s,P
   iff I is_closed_on s +* Start-At(l,SCM+FSA),P+*I &
     I is_halting_on s +* Start-At(l,SCM+FSA),P+*I
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let l be Element of NAT;
  DataPart s = DataPart(s +* Start-At(l,SCM+FSA)) by SCMFSA8A:10;
  hence thesis by Th8;
end;

theorem Th40:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does not refer a & (for b being Int-Location st a <> b
  holds s1.b = s2.b) & (for f being FinSeq-Location holds s1.f = s2.f) & I
is_closed_on s1,P1 & I is_halting_on s1,P1
 holds I is_closed_on s2,P2 & I is_halting_on s2,P2
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A2: I does not refer a;
  set S2 = Initialize s2,
      Q2 = P2 +* I;
  set S1 = Initialize s1,
      Q1 = P1 +* I;
  assume
A3: for b being Int-Location st a <> b holds s1.b = s2.b;
  assume
A4: for f being FinSeq-Location holds s1.f = s2.f;
  assume that
A5: I is_closed_on s1,P1 and
A6: I is_halting_on s1,P1;
A7: now
    let k be Element of NAT;
    IC Comput(Q1,S1,k) in dom I by A5,SCMFSA7B:def 7;
    hence IC Comput(Q2,S2,k) in dom I by A2,Th38,A5,A4,A3;
  end;
  Q1 halts_on S1 by A6,SCMFSA7B:def 8;
  then consider n being Element of NAT such that
A8: CurInstr(Q1,Comput(Q1,S1,n)) = halt SCM+FSA by EXTPRO_1:30;
  CurInstr(Q2,Comput(Q2,S2,n)) = halt SCM+FSA by A2,A8,Th38,A5,A4,A3;
  then Q2 halts_on S2 by EXTPRO_1:30;
  hence thesis by A7,SCMFSA7B:def 7,def 8;
end;

theorem Th41:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA, a
  being Int-Location holds (for d being read-write Int-Location st a <> d holds
  s1.d = s2.d) & (for f being FinSeq-Location holds s1.f = s2.f) & I
does not refer a & I is_closed_on Initialized s1,P1 &
    I is_halting_on Initialized s1,P1
implies (for d being Int-Location st a <> d
 holds IExec(I,P1,s1).d = IExec(I,P2,s2).d) &
   (for f being FinSeq-Location holds IExec(I,P1,s1).f = IExec(I,P2,s2).f) & IC
  IExec(I,P1,s1) = IC IExec(I,P2,s2)
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume that
A2: for d being read-write Int-Location st a <> d holds s1.d = s2.d and
A3: for f being FinSeq-Location holds s1.f = s2.f;
A4: now
    let d be Int-Location;
    assume
A5: a <> d;
    per cases;
    suppose
A6:   d = intloc 0;
      hence (Initialized s1).d = 1 by SCMFSA6C:3
        .= (Initialized s2).d by A6,SCMFSA6C:3;
    end;
    suppose
      d <> intloc 0;
      then
A7:   d is read-write by SF_MASTR:def 5;
      hence (Initialized s1).d = s1.d by SCMFSA6C:3
        .= s2.d by A2,A5,A7
        .= (Initialized s2).d by A7,SCMFSA6C:3;
    end;
  end;
  set S1 = s1 +* Initialize((intloc 0).-->1),
      Q1 = P1 +* I;
  set S2 = s2 +* Initialize((intloc 0).-->1),
      Q2 = P2 +* I;
  assume
A8: I does not refer a;
A9: S2 = Initialize Initialized s2 by SCMFSA8A:13;
  assume that
A10: I is_closed_on Initialized s1,P1 and
A11: I is_halting_on Initialized s1,P1;
A12: now
    let f be FinSeq-Location;
    thus (Initialized s1).f = s1.f by SCMFSA6C:3
      .= s2.f by A3
      .= (Initialized s2).f by SCMFSA6C:3;
  end;
  then I is_halting_on Initialized s2,P2 by A8,A10,A11,A4,Th40;
  then
A13: Q2 halts_on S2 by A9,SCMFSA7B:def 8;
A14: S1 = Initialize Initialized s1 by SCMFSA8A:13;
  then
A15: Q1 halts_on S1 by A11,SCMFSA7B:def 8;
  now
    let l be Element of NAT;
    assume l < LifeSpan(Q1,S1);
    then CurInstr(Q1,Comput(Q1,S1,l))
     <> halt SCM+FSA by A15,EXTPRO_1:def 14;
    hence CurInstr(Q2,Comput(Q2,S2,l)) <>
     halt SCM+FSA by A8,A10,A4,A12,A14,A9,Th38;
  end;
  then
A16: for l be Element of NAT st CurInstr(Q2,Comput(Q2,S2,l)) = halt SCM+FSA
    holds LifeSpan(Q1,S1) <= l;
  CurInstr (Q2,Comput(Q2,S2,LifeSpan(Q1,S1)))
   = CurInstr(Q1,Comput(Q1,S1,LifeSpan(Q1,S1))) by A8,A10,A4,A12,A14,A9,Th38
    .= halt SCM+FSA by A15,EXTPRO_1:def 14;
  then
A17: LifeSpan(Q1,S1) = LifeSpan(Q2,S2) by A13,A16,EXTPRO_1:def 14;
  then
A18: Result(Q2,S2) = Comput(Q2,S2,LifeSpan(Q1,S1)) by A13,EXTPRO_1:23;
A19: Result(Q1,S1) = Comput(Q1,S1,LifeSpan(Q1,S1)) by A15,EXTPRO_1:23;
X1: NPP Result(P1+*I,s1 +* Initialize((intloc 0).-->1)) = NPP IExec(I,P1,s1)
           by Th36;
X2: NPP Result(P2+*I,s2 +* Initialize((intloc 0).-->1)) = NPP IExec(I,P2,s2)
           by Th36;
  hereby
    let d be Int-Location;
    assume
A20: a <> d;
    thus IExec(I,P1,s1).d = (Result(Q1,S1)).d by X1,SCMFSA10:92
      .= (Result(Q2,S2)).d by A8,A10,A4,A12,A14,A9,A18,A19,A20,Th38
      .= IExec(I,P2,s2).d by X2,SCMFSA10:92;
  end;
  hereby
    let f be FinSeq-Location;
    thus IExec(I,P1,s1).f = (Result(Q1,S1)).f by X1,SCMFSA10:93
      .= (Result(Q2,S2)).f by A8,A10,A4,A12,A14,A9,A18,A19,Th38
      .= IExec(I,P2,s2).f by X2,SCMFSA10:93;
  end;
  thus IC IExec(I,P1,s1) = IC Result(Q1,S1) by SCMFSA8A:7
    .= IC Comput(Q1,S1,LifeSpan(Q1,S1)) by A15,EXTPRO_1:23
    .= IC Comput(Q2,S2,LifeSpan(Q2,S2)) by A8,A10,A4,A12,A14,A9,A17,Th38
    .= IC Result(Q2,S2) by A13,EXTPRO_1:23
    .= IC IExec(I,P2,s2) by SCMFSA8A:7;
end;

theorem
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA
, a,b being read-write Int-Location st I does not refer a & J does not refer a
  holds IC IExec(if=0(a,b,I,J),P,s) =  (card I + card J + 5) & (s.a = s.b
  implies ((for d being Int-Location st a <> d
   holds IExec(if=0(a,b,I,J),P,s).d =
  IExec(I,P,s).d) & for f being FinSeq-Location
   holds IExec(if=0(a,b,I,J),P,s).f =
IExec(I,P,s).f)) & (s.a <> s.b implies
 ((for d being Int-Location st a <> d holds
  IExec(if=0(a,b,I,J),P,s).d = IExec(J,P,s).d) &
  for f being FinSeq-Location holds
  IExec(if=0(a,b,I,J),P,s).f = IExec(J,P,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a,b be read-write Int-Location;
  assume that
A1: I does not refer a and
A2: J does not refer a;
  reconsider JJ = if=0(a,I,J) as parahalting Program of SCM+FSA;
  reconsider II = Macro SubFrom(a,b) as keeping_0 parahalting Program of
  SCM+FSA;
  set i = SubFrom(a,b);
  set s1 = Exec(i,Initialized s);
A3: now
    let c be read-write Int-Location;
    assume a <> c;
    hence s1.c = (Initialized s).c by SCMFSA_2:91
      .= s.c by SCMFSA6C:3;
  end;
  IExec(if=0(a,b,I,J),P,s)
    = IExec(JJ,P,IExec(II,P,s)) +*
     Start-At((IC IExec(JJ,P,IExec(II,P,s)) + card II
  ),SCM+FSA) by SCMFSA6B:44;
  hence IC IExec(if=0(a,b,I,J),P,s) = IC IExec(JJ,P,IExec(II,P,s)) + card II
by FUNCT_4:121
    .=  (card I + card J + 3) + card II by Th21
    .=  (card I + card J + 3) + 2 by COMPOS_1:150
    .=  (card I + card J + 5);
A4: now
    let f be FinSeq-Location;
    thus s1.f = (Initialized s).f by SCMFSA_2:91
      .= s.f by SCMFSA6C:3;
  end;
  hereby
    assume
A5: s.a = s.b;
A6: I is_closed_on Initialized s,P by SCMFSA7B:24;
A7: I is_halting_on Initialized s,P by SCMFSA7B:25;
A8: Exec(i,Initialized s).a = (Initialized s).a - (Initialized s).b
by SCMFSA_2:91
      .= s.a - (Initialized s).b by SCMFSA6C:3
      .= s.a - s.b by SCMFSA6C:3
      .= 0 by A5;
    hereby
      let d be Int-Location;
      assume
A9:   a <> d;
      thus IExec(if=0(a,b,I,J),P,s).d
       = IExec(JJ,P,Exec(i,Initialized s)).d by Th12
        .= IExec(I,P,Exec(i,Initialized s)).d by A8,Th21
        .= IExec(I,P,s).d by A1,A3,A4,A6,A7,A9,Th41;
    end;
    let f be FinSeq-Location;
    thus IExec(if=0(a,b,I,J),P,s).f
     = IExec(JJ,P,Exec(i,Initialized s)).f by Th13
      .= IExec(I,P,Exec(i,Initialized s)).f by A8,Th21
      .= IExec(I,P,s).f by A1,A3,A4,A6,A7,Th41;
  end;
A10: Exec(i,Initialized s).a = (Initialized s).a - (Initialized s).b by
SCMFSA_2:91
    .= s.a - (Initialized s).b by SCMFSA6C:3
    .= s.a - s.b by SCMFSA6C:3;
A11: J is_halting_on Initialized s,P by SCMFSA7B:25;
A12: J is_closed_on Initialized s,P by SCMFSA7B:24;
  assume s.a <> s.b;
  then
A13: s.a + (- s.b) <> s.b + (- s.b);
  hereby
    let d be Int-Location;
    assume
A14: a <> d;
    thus IExec(if=0(a,b,I,J),P,s).d
     = IExec(JJ,P,Exec(i,Initialized s)).d by Th12
      .= IExec(J,P,Exec(i,Initialized s)).d by A10,A13,Th21
      .= IExec(J,P,s).d by A2,A3,A4,A12,A11,A14,Th41;
  end;
  let f be FinSeq-Location;
  thus IExec(if=0(a,b,I,J),P,s).f = IExec(JJ,P,Exec(i,Initialized s)).f by Th13
    .= IExec(J,P,Exec(i,Initialized s)).f by A10,A13,Th21
    .= IExec(J,P,s).f by A2,A3,A4,A12,A11,Th41;
end;

theorem
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA
, a,b being read-write Int-Location st I does not refer a & J does not refer a
  holds IC IExec(if>0(a,b,I,J),P,s) =  (card I + card J + 5) & (s.a > s.b
  implies (for d being Int-Location st a <> d
   holds IExec(if>0(a,b,I,J),P,s).d =
  IExec(I,P,s).d) & for f being FinSeq-Location
   holds IExec(if>0(a,b,I,J),P,s).f =
  IExec(I,P,s).f) & (s.a <= s.b implies
   (for d being Int-Location st a <> d holds
  IExec(if>0(a,b,I,J),P,s).d = IExec(J,P,s).d) &
  for f being FinSeq-Location holds
  IExec(if>0(a,b,I,J),P,s).f = IExec(J,P,s).f)
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a,b be read-write Int-Location;
  assume that
A1: I does not refer a and
A2: J does not refer a;
  reconsider JJ = if>0(a,I,J) as parahalting Program of SCM+FSA;
  reconsider II = Macro SubFrom(a,b) as keeping_0 parahalting Program of
  SCM+FSA;
  set i = SubFrom(a,b);
  set s1 = Exec(i,Initialized s);
A3: now
    let c be read-write Int-Location;
    assume a <> c;
    hence s1.c = (Initialized s).c by SCMFSA_2:91
      .= s.c by SCMFSA6C:3;
  end;
  IExec(if>0(a,b,I,J),P,s)
    = IExec(JJ,P,IExec(II,P,s)) +*
     Start-At (IC IExec(JJ,P,IExec(II,P,s)) + card II
  ,SCM+FSA) by SCMFSA6B:44;
  hence IC IExec(if>0(a,b,I,J),P,s)
   = IC IExec(JJ,P,IExec(II,P,s)) + card II by FUNCT_4:121
    .=  (card I + card J + 3) + card II by Th27
    .=  (card I + card J + 3) + 2 by COMPOS_1:150
    .=  (card I + card J + 5);
A4: now
    let f be FinSeq-Location;
    thus s1.f = (Initialized s).f by SCMFSA_2:91
      .= s.f by SCMFSA6C:3;
  end;
  hereby
A5: Exec(i,Initialized s).a = (Initialized s).a - (Initialized s).b
by SCMFSA_2:91
      .= s.a - (Initialized s).b by SCMFSA6C:3
      .= s.a - s.b by SCMFSA6C:3;
    assume s.a > s.b;
    then
A6: Exec(i,Initialized s).a > 0 by A5,XREAL_1:52;
A7: I is_halting_on Initialized s,P by SCMFSA7B:25;
A8: I is_closed_on Initialized s,P by SCMFSA7B:24;
    hereby
      let d be Int-Location;
      assume
A9:   a <> d;
      thus IExec(if>0(a,b,I,J),P,s).d
       = IExec(JJ,P,Exec(i,Initialized s)).d by Th12
        .= IExec(I,P,Exec(i,Initialized s)).d by A6,Th27
        .= IExec(I,P,s).d by A1,A3,A4,A8,A7,A9,Th41;
    end;
    let f be FinSeq-Location;
    thus IExec(if>0(a,b,I,J),P,s).f
     = IExec(JJ,P,Exec(i,Initialized s)).f by Th13
      .= IExec(I,P,Exec(i,Initialized s)).f by A6,Th27
      .= IExec(I,P,s).f by A1,A3,A4,A8,A7,Th41;
  end;
A10: Exec(i,Initialized s).a = (Initialized s).a - (Initialized s).b by
SCMFSA_2:91
    .= s.a - (Initialized s).b by SCMFSA6C:3
    .= s.a - s.b by SCMFSA6C:3;
A11: J is_closed_on Initialized s,P by SCMFSA7B:24;
A12: J is_halting_on Initialized s,P by SCMFSA7B:25;
  assume s.a <= s.b;
  then
A13: Exec(i,Initialized s).a <= 0 by A10,XREAL_1:49;
  hereby
    let d be Int-Location;
    assume
A14: a <> d;
    thus IExec(if>0(a,b,I,J),P,s).d
     = IExec(JJ,P,Exec(i,Initialized s)).d by Th12
      .= IExec(J,P,Exec(i,Initialized s)).d by A13,Th27
      .= IExec(J,P,s).d by A2,A3,A4,A11,A12,A14,Th41;
  end;
  let f be FinSeq-Location;
  thus IExec(if>0(a,b,I,J),P,s).f
   = IExec(JJ,P,Exec(i,Initialized s)).f by Th13
    .= IExec(J,P,Exec(i,Initialized s)).f by A13,Th27
    .= IExec(J,P,s).f by A2,A3,A4,A11,A12,Th41;
end;

theorem
  for s1,s2 being State of SCM+FSA, J being parahalting Program of SCM+FSA
    st NPP s1 = NPP s2
   holds NPP IExec(J,P,s1) = NPP IExec(J,P,s2) by LmX;

theorem
  for s1,s2 being State of SCM+FSA, J being Program of SCM+FSA
    st NPP s1 = NPP s2 & :::P+*J halts_on Initialized s1
      J is_halting_on Initialized s1,P
 holds NPP IExec(J,P,s1) = NPP IExec(J,P,s2)
proof let s1,s2 be State of SCM+FSA, J be Program of SCM+FSA;
  assume NPP s1 = NPP s2;
   then
A: NPP(s1+*Initialize((intloc 0).-->1))
    = NPP s2+*NPP Initialize((intloc 0).-->1) by COMPOS_1:221
   .= NPP(s2+*Initialize((intloc 0).-->1)) by COMPOS_1:221;
D: Initialize((intloc 0).-->1) c= s1+*Initialize((intloc 0).-->1)
       by FUNCT_4:26;
  assume J is_halting_on Initialized s1,P;
   then P +* J halts_on Initialize Initialized s1 by SCMFSA7B:def 8;
   then
B:  P+*J halts_on Initialized s1 by SCMFSA6A:83;
  thus NPP IExec(J,P,s1)
      = NPP(Result(P+*J,s1+*Initialize((intloc 0).-->1)) +* s1|NAT)
                by SCMFSA6B:def 1
     .= NPP Result(P+*J,s1+*Initialize((intloc 0).-->1)) +* NPP(s1|NAT)
                by COMPOS_1:221
     .= NPP Result(P+*J,s1+*Initialize((intloc 0).-->1)) +* {}
     .= NPP Result(P+*J,s1+*Initialize((intloc 0).-->1)) by FUNCT_4:22
     .= NPP Result(P+*J,s2+*Initialize((intloc 0).-->1)) by A,B,AMISTD_2:71
     .= NPP Result(P+*J,s2+*Initialize((intloc 0).-->1)) +* {} by FUNCT_4:22
     .= NPP Result(P+*J,s2+*Initialize((intloc 0).-->1)) +* NPP(s2|NAT)
     .= NPP(Result(P+*J,s2+*Initialize((intloc 0).-->1)) +* s2|NAT)
                by COMPOS_1:221
     .= NPP IExec(J,P,s2) by SCMFSA6B:def 1;
 end;

