:: Conditional branch macro instructions of SCM+FSA, Part II
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SCMFSA_2, XBOOLE_0, AMI_1, AMISTD_2, CARD_1, TARSKI,
      TURING_1, SCMFSA6A, FUNCT_4, FSM_1, RELAT_1, UNIALG_2, CIRCUIT2, FUNCT_1,
      SF_MASTR, SUBSET_1, ARYTM_3, FUNCT_7, SCMFSA7B, SCMFSA6B,
      AMI_3, SCMFSA8A, NAT_1, GRAPHSP, XXREAL_0, MSUALG_1, STRUCT_0, GLIB_000,
      ARYTM_1, INT_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2, SCMFSA8B,
      ORDINAL1, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, NAT_1, INT_1,
      RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7, FINSEQ_1, FINSEQ_2,
      STRUCT_0, COMPOS_1, EXTPRO_1, AMI_1, AMISTD_2, SCMFSA_2, SCMFSA6A,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, INT_2, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, NAT_1, INT_2, SCMFSA6A, SF_MASTR,
      SCMFSA6B, SCMFSA6C, SCMFSA8A, AMISTD_2, RELSET_1, SCMFSA7B, AMI_1,
      PRE_POLY;
 registrations SETFAM_1, FUNCT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1,
      AMI_1, SCMFSA_2, SF_MASTR, SCMFSA6A, SCMFSA6B, SCMFSA6C, ORDINAL1,
      XBOOLE_0, FINSET_1, RELSET_1, SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_1;
 theorems TARSKI, NAT_1, FUNCT_1, FUNCT_4, AMI_1, SCMFSA_2, SCMFSA_4,
      SCMFSA6A, GRFUNC_1, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A,
      RELAT_1, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0,
      PARTFUN1, AFINSQ_1, SCMFSA10, COMPOS_1, EXTPRO_1;
 schemes NAT_1;

begin
set A = NAT;
set D = Int-Locations \/ FinSeq-Locations;

Lm1: for I,J being Program of SCM+FSA
 holds ProgramPart Relocated(J,card I) c= I ';' J

proof
  let I,J be Program of SCM+FSA;

  I ';' J = Directed I +* ProgramPart Relocated(J,card I) by SCMFSA6A:def 5;

  hence thesis by FUNCT_4:26;
end;

canceled 2;

theorem Th3:
  for I being Program of SCM+FSA, s being State of SCM+FSA st I
  is_closed_on s holds  0 in dom I
proof
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  assume
A1: I is_closed_on s;
A2: IC SCM+FSA in dom (I +* Start-At( 0,SCM+FSA)) by COMPOS_1:141;
  IC Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s +* (I +*
Start-At( 0,SCM+FSA))),0) = (s +* (I +*
  Start-At( 0,SCM+FSA))).IC SCM+FSA by EXTPRO_1:3
    .= IC(I +* Start-At( 0,SCM+FSA)) by A2,FUNCT_4:14
    .=  0 by COMPOS_1:142;
  hence thesis by A1,SCMFSA7B:def 7;
end;

canceled;

theorem Th5:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  DataPart Initialized s = DataPart(s +* Initialized I)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
A1: now
    let a be Int-Location;
    per cases;
    suppose
A2:   intloc 0 = a;
      then a in dom Initialized I by SCMFSA6A:45;
      hence s1.a = (Initialized I).intloc 0 by A2,FUNCT_4:14
        .= 1 by SCMFSA6A:46
        .= (Initialized s).a by A2,SCMFSA6C:3;
    end;
    suppose
A3:   intloc 0 <> a;
      then
A4:   a is read-write by SF_MASTR:def 5;
      not a in dom Initialized I by A3,SCMFSA6A:48;
      hence s1.a = s.a by FUNCT_4:12
        .= (Initialized s).a by A4,SCMFSA6C:3;
    end;
  end;
  now
    let f be FinSeq-Location;
    not f in dom Initialized I by SCMFSA6A:49;
    hence s1.f = s.f by FUNCT_4:12
      .= (Initialized s).f by SCMFSA6C:3;
  end;
  hence thesis by A1,SCMFSA6A:38;
end;

theorem Th6:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
  DataPart s1 = DataPart s2 holds I is_closed_on s1 implies I is_closed_on s2
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set S1 = s1 +* (I +* Start-At( 0,SCM+FSA)), S2 = s2 +*
   (I +* Start-At( 0,SCM+FSA));
  assume
A1: DataPart s1 = DataPart s2;
A2: Comput(ProgramPart(S2),S2,0) = s2 +* (I +* Start-At( 0,SCM+FSA)) by
EXTPRO_1:3;
A3: Comput(ProgramPart(S1),S1,0) = s1 +* (I +* Start-At( 0,SCM+FSA)) by
EXTPRO_1:3;
  then
A4: DataPart Comput(ProgramPart(S1),S1,0) = DataPart s1 by SCMFSA8A:11
    .= DataPart Comput(ProgramPart(S2),S2,0) by A1,A2,SCMFSA8A:11;
  assume
A5: I is_closed_on s1;
  then
A6:  0 in dom I by Th3;
  defpred P[Nat] means IC Comput(ProgramPart(S1),S1,$1) = IC Comput(ProgramPart
(S2),S2,$1
  ) & CurInstr(ProgramPart Comput(ProgramPart(S1),S1,$1),Comput(ProgramPart(S1)
,S1,$1))
   = CurInstr(ProgramPart Comput(ProgramPart(S2),S2,$1),Comput(ProgramPart(S2),
S2,$1)) & DataPart
  Comput(ProgramPart(S1),S1,$1) = DataPart Comput(ProgramPart(S2),S2,$1);
A7: I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A8: dom I c= dom (I +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
A9: now
    let k be Element of NAT;
T: ProgramPart S2 = ProgramPart Comput(ProgramPart(
S2),S2,k)
by AMI_1:123;
A10: Comput(ProgramPart(S2),S2,k+1) = Following(ProgramPart S2,
Comput(ProgramPart(S2),S2,k)) by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(S2),S2,k),Comput(
ProgramPart(S2),S2,k)),
      Comput(ProgramPart(S2),S2,k)) by T;
    assume
A11: P[k];
    then
A12: for f being FinSeq-Location holds Comput(ProgramPart(S1),S1,k).f = Comput(
ProgramPart(
    S2),
    S2, k).f by SCMFSA6A:38;
    for a being Int-Location holds Comput(ProgramPart(S1),S1,k).a = Comput(
ProgramPart(S2),S2,k
    ) .a by A11,SCMFSA6A:38;
    then
A13: Comput(ProgramPart(S1),S1,k), Comput(ProgramPart(S2),S2,k) equal_outside A
by A11,A12,SCMFSA10:91;
    I +* Start-At( 0,SCM+FSA) c= s2 +* (I +* Start-At( 0,SCM+FSA))
     by FUNCT_4:26;
    then I c= s2 +* (I +* Start-At( 0,SCM+FSA)) by A7,XBOOLE_1:1;
    then
A14: I c= Comput(ProgramPart(S2),S2,k+1) by AMI_1:81;
A15: IC Comput(ProgramPart(S1),S1,k+1) in dom I by A5,SCMFSA7B:def 7;
T: ProgramPart S1 = ProgramPart Comput(ProgramPart(
S1),S1,k)
by AMI_1:123;
A16: Comput(ProgramPart(S1),S1,k+1) = Following(ProgramPart S1,
Comput(ProgramPart(S1),S1,k)) by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(S1),S1,k),Comput(
ProgramPart(S1),S1,k)),
      Comput(ProgramPart(S1),S1,k)) by T;
    then
A17: IC Comput(ProgramPart(S1),S1,k+1) = IC Comput(ProgramPart(S2),S2,k+1) by
A11,A13,A10,COMPOS_1:24,SCMFSA6A:32;
Y:  (ProgramPart Comput(ProgramPart(S1),S1,k+1))/.IC Comput(ProgramPart(S1),S1,
k+1)
 = Comput(ProgramPart(S1),S1,k+1).IC Comput(ProgramPart(S1),S1,k+1) by
COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(S2),S2,k+1))/.IC Comput(ProgramPart(S2),S2,
k+1)
 = Comput(ProgramPart(S2),S2,k+1).IC Comput(ProgramPart(S2),S2,k+1) by
COMPOS_1:38;
    I +* Start-At( 0,SCM+FSA) c= s1 +* (I +* Start-At( 0,SCM+FSA))
     by FUNCT_4:26;
    then I c= s1 +* (I +* Start-At( 0,SCM+FSA)) by A7,XBOOLE_1:1;
    then I c= Comput(ProgramPart(S1),S1,k+1) by AMI_1:81;
    then CurInstr(ProgramPart Comput(ProgramPart(S1),S1,k+1),Comput(ProgramPart
(S1),S1,k+1))
     = I.IC Comput(ProgramPart(S1),S1,k+1) by A15,Y,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(S2),S2,k+1),Comput(ProgramPart
(S2),S2,k+1))
       by A14,A17,A15,Z,GRFUNC_1:8;
    hence P[k+1] by A11,A13,A16,A10,A17,SCMFSA6A:32,39;
  end;
Y:  (ProgramPart Comput(ProgramPart(S1),S1,0))/.IC Comput(ProgramPart(S1),S1,0)
 = Comput(ProgramPart(S1),S1,0).IC Comput(ProgramPart(S1),S1,0) by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(S2),S2,0))/.IC Comput(ProgramPart(S2),S2,0)
 = Comput(ProgramPart(S2),S2,0).IC Comput(ProgramPart(S2),S2,0) by COMPOS_1:38;
A18: IC SCM+FSA in dom (I +* Start-At( 0,SCM+FSA)) by COMPOS_1:141;
  then
A19: IC Comput(ProgramPart(S2),S2,0) = IC(I +* Start-At( 0,SCM+FSA))
by A2,FUNCT_4:14
    .=  0 by COMPOS_1:142;
A20: IC Comput(ProgramPart(S1),S1,0) = IC(I +* Start-At( 0,SCM+FSA))
 by A18,A3,FUNCT_4:14
    .=  0 by COMPOS_1:142;
  then CurInstr(ProgramPart Comput(ProgramPart(S1),S1,0),Comput(ProgramPart(S1)
,S1,0)) =
   (I +* Start-At( 0,SCM+FSA)). 0 by A3,A8,A6,Y,FUNCT_4:14
    .= CurInstr(ProgramPart Comput(ProgramPart(S2),S2,0),Comput(ProgramPart(S2)
,S2,0))
    by A2,A19,A8,A6,Z,FUNCT_4:14;
  then
A21: P[0] by A20,A19,A4;
  now
    let k be Element of NAT;
A22: IC Comput(ProgramPart(S1),S1,k) in dom I by A5,SCMFSA7B:def 7;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A21,A9);
    hence IC Comput(ProgramPart(S2),S2,k) in dom I by A22;
  end;
  hence thesis by SCMFSA7B:def 7;
end;

theorem Th7:
  for s1,s2 being State of SCM+FSA, I,J being Program of SCM+FSA
holds DataPart s1 = DataPart s2
 implies s1 +* (I +* Start-At( 0,SCM+FSA)),
   s2 +* (J +* Start-At( 0,SCM+FSA)) equal_outside NAT
proof
  let s1,s2 be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  assume
A1: DataPart s1 = DataPart s2;
  set S2 = s2 +* (J +* Start-At( 0,SCM+FSA));
  set S1 = s1 +* (I +* Start-At( 0,SCM+FSA));
A2: IC S1 =  0 by COMPOS_1:143,FUNCT_4:26;
A3: IC S2 =  0 by COMPOS_1:143,FUNCT_4:26;
  DataPart S1 = DataPart s1 by SCMFSA8A:11
    .= DataPart S2 by A1,SCMFSA8A:11;
  hence thesis by A2,A3,SCMFSA8A:6;
end;

theorem Th8:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
DataPart s1 = DataPart s2 holds I is_closed_on s1 & I is_halting_on s1
 implies
  I is_closed_on s2 & I is_halting_on s2
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set S1 = s1 +* (I +* Start-At( 0,SCM+FSA)), S2 = s2 +*
   (I +* Start-At( 0,SCM+FSA));
  defpred P[Nat] means
   IC Comput(ProgramPart(S1),S1,$1) = IC Comput(ProgramPart(S2),S2,$1) &
    CurInstr(ProgramPart S1,Comput(ProgramPart(S1),S1,$1))
   = CurInstr(ProgramPart S2,Comput(ProgramPart(S2),S2,$1)) &
   DataPart Comput(ProgramPart(S1),S1,$1)
    = DataPart Comput(ProgramPart(S2),S2,$1);
A1: IC SCM+FSA in {IC SCM+FSA} by TARSKI:def 1;
A2: I c= (I +* Start-At( 0,SCM+FSA)) by SCMFSA8A:9;
  then
A3: dom I c= dom (I +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
A4: {IC SCM+FSA} = dom Start-At( 0,SCM+FSA) by FUNCOP_1:19;
A5: Comput(ProgramPart(S1),S1,0) = s1 +* (I +* Start-At( 0,SCM+FSA)) by
EXTPRO_1:3;
  Start-At( 0,SCM+FSA) c= I +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
  then
A6: dom Start-At( 0,SCM+FSA) c= dom (I +* Start-At( 0,SCM+FSA))
 by GRFUNC_1:8;
  then
A7: IC Comput(ProgramPart(S1),S1,0) = (I +* Start-At( 0,SCM+FSA)).IC SCM+FSA
 by A1,A4,A5,FUNCT_4:14
    .= (Start-At( 0,SCM+FSA)).IC SCM+FSA by A1,A4,FUNCT_4:14
    .=  0 by FUNCOP_1:87;
A8: Comput(ProgramPart(S2),S2,0) = s2 +* (I +* Start-At( 0,SCM+FSA)) by
EXTPRO_1:3;
  then
A9: IC Comput(ProgramPart(S2),S2,0) = (I +* Start-At( 0,SCM+FSA)).IC SCM+FSA
 by A1,A4,A6,FUNCT_4:14
    .= (Start-At( 0,SCM+FSA)).IC SCM+FSA by A1,A4,FUNCT_4:14
    .=  0 by FUNCOP_1:87;
  assume DataPart s1 = DataPart s2;
  then
A10: Comput(ProgramPart(S1),S1,0), Comput(ProgramPart(S2),S2,0) equal_outside A
by A5,A8,Th7;
  assume
A11: I is_closed_on s1;
A12: now
    let k be Element of NAT;
A13: Comput(ProgramPart(S2),S2,k+1) = Following(ProgramPart S2,
Comput(ProgramPart(S2),S2,k)) by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart S2,Comput(ProgramPart(S2),S2,k)),
      Comput(ProgramPart(S2),S2,k));
    assume
A14: P[k];
    then
A15: for f being FinSeq-Location holds Comput(ProgramPart(S1),S1,k).f = Comput(
ProgramPart(
    S2),
    S2, k).f by SCMFSA6A:38;
    for a being Int-Location holds Comput(ProgramPart(S1),S1,k).a = Comput(
ProgramPart(S2),S2,k
    ) .a by A14,SCMFSA6A:38;
    then
A16: Comput(ProgramPart(S1),S1,k), Comput(ProgramPart(S2),S2,k) equal_outside A
by A14,A15,SCMFSA10:91;
    (I +* Start-At( 0,SCM+FSA)) c=
     s2 +* (I +* Start-At( 0,SCM+FSA)) by FUNCT_4:26;
    then I c= s2 +* (I +* Start-At( 0,SCM+FSA)) by A2,XBOOLE_1:1;
    then
A17: I c= Comput(ProgramPart(S2),S2,k+1) by AMI_1:81;
A18: IC Comput(ProgramPart(S1),S1,k+1) in dom I by A11,SCMFSA7B:def 7;
A19: Comput(ProgramPart(S1),S1,k+1) = Following(ProgramPart S1,
Comput(ProgramPart(S1),S1,k)) by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart S1,Comput(ProgramPart(S1),S1,k)),
      Comput(ProgramPart(S1),S1,k));
    then
A20: IC Comput(ProgramPart(S1),S1,k+1) = IC Comput(ProgramPart(S2),S2,k+1) by
A14,A16,A13,COMPOS_1:24,SCMFSA6A:32;
Y:  (ProgramPart Comput(ProgramPart(S1),S1,k+1))/.IC Comput(ProgramPart(S1),S1,
k+1)
 = Comput(ProgramPart(S1),S1,k+1).IC Comput(ProgramPart(S1),S1,k+1) by
COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(S2),S2,k+1))/.IC Comput(ProgramPart(S2),S2,
k+1)
 = Comput(ProgramPart(S2),S2,k+1).IC Comput(ProgramPart(S2),S2,k+1) by
COMPOS_1:38;
TX2: ProgramPart S2 = ProgramPart Comput(ProgramPart(S2),S2,k+1)
by AMI_1:123;
TX1: ProgramPart S1 = ProgramPart Comput(ProgramPart(S1),S1,k+1)
by AMI_1:123;
    (I +* Start-At( 0,SCM+FSA)) c= s1 +* (I +*
     Start-At( 0,SCM+FSA)) by FUNCT_4:26;
    then I c= s1 +* (I +* Start-At( 0,SCM+FSA)) by A2,XBOOLE_1:1;
    then I c= Comput(ProgramPart(S1),S1,k+1) by AMI_1:81;
    then
u:     CurInstr(ProgramPart S1,Comput(ProgramPart(S1),S1,k+1))
     = I.IC Comput(ProgramPart(S1),S1,k+1) by A18,Y,TX1,GRFUNC_1:8
      .= CurInstr(ProgramPart S2,Comput(ProgramPart(S2),S2,k+1))
       by A17,A20,A18,Z,TX2,GRFUNC_1:8;
   DataPart Comput(ProgramPart(S1),S1,k+1)
    = DataPart Exec(CurInstr(ProgramPart S1,Comput(ProgramPart(S1),S1,k)),
      Comput(ProgramPart(S1),S1,k)) by A19
   .= DataPart Comput(ProgramPart(S2),S2,k+1)
     by A14,A16,A13,SCMFSA6A:32,39;
    hence P[k+1] by A20,u;
  end;
  assume I is_halting_on s1;
  then ProgramPart(s1 +* (I +* Start-At( 0,SCM+FSA)))
   halts_on s1 +* (I +* Start-At( 0,SCM+FSA)) by SCMFSA7B:def 8;
  then consider m being Element of NAT such that
A21: CurInstr(ProgramPart S1,Comput(ProgramPart(S1),S1,m))
 = halt SCM+FSA by EXTPRO_1:30;
Y:  (ProgramPart Comput(ProgramPart(S1),S1,0))/.IC Comput(ProgramPart(S1),S1,0)
 = Comput(ProgramPart(S1),S1,0).IC Comput(ProgramPart(S1),S1,0) by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(S2),S2,0))/.IC Comput(ProgramPart(S2),S2,0)
 = Comput(ProgramPart(S2),S2,0).IC Comput(ProgramPart(S2),S2,0) by COMPOS_1:38;
A22:  0 in dom I by A11,Th3;
  then CurInstr(ProgramPart S1,Comput(ProgramPart(S1),S1,0)) =
   (I +* Start-At( 0,SCM+FSA)). 0 by A5,A7,A3,Y,FUNCT_4:14
    .= CurInstr(ProgramPart S2,Comput(ProgramPart(S2),S2,0))
    by A8,A9,A3,A22,Z,FUNCT_4:14;
  then
A23: P[0] by A7,A9,A10,SCMFSA6A:39;
  now
    let k be Element of NAT;
A24: IC Comput(ProgramPart(S1),S1,k) in dom I by A11,SCMFSA7B:def 7;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A23,A12);
    hence IC Comput(ProgramPart(S2),S2,k) in dom I by A24;
  end;
  hence I is_closed_on s2 by SCMFSA7B:def 7;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A23,A12);
  then CurInstr(ProgramPart S2,Comput(ProgramPart(S2),S2,m))
   = halt SCM+FSA by A21;
  then ProgramPart(s2 +* (I +* Start-At( 0,SCM+FSA)))
   halts_on s2 +* (I +* Start-At( 0,SCM+FSA)) by EXTPRO_1:30;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th9:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA holds
  I is_closed_on Initialized s iff I is_closed_on s +* Initialized J
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  DataPart Initialized s = DataPart(s +* Initialized J) by Th5;
  hence thesis by Th6;
end;

theorem Th10:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, l
being Element of NAT holds I is_closed_on s iff I is_closed_on
  s +* (I +* Start-At(l,SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let l be Element of NAT;
  DataPart s = DataPart(s +* (I +* Start-At(l,SCM+FSA))) by SCMFSA8A:11;
  hence thesis by Th6;
end;

theorem Th11:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
I +* Start-At( 0,SCM+FSA) c= s1 & I is_closed_on s1
 for n being Element of NAT st
ProgramPart Relocated(I,n) c= s2 & IC s2 =  n & DataPart s1 = DataPart s2
for i being Element of NAT holds IC Comput(ProgramPart( s1), s1,i) + n = IC
Comput(ProgramPart( s2
), s2
,i) & IncAddr(CurInstr(ProgramPart s1,Comput( ProgramPart(s1),s1,i)),n)
 = CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,i)) &
  DataPart Comput(ProgramPart( s1), s1,i) = DataPart Comput(ProgramPart( s2),
s2,i)
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: I +* Start-At( 0,SCM+FSA) c= s1;
  assume
A2: I is_closed_on s1;
  let n be Element of NAT;
A3: IC SCM+FSA in dom (I +* Start-At( 0,SCM+FSA)) by COMPOS_1:141;
A4: I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A5: dom I c= dom (I +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
  defpred P[Nat] means IC Comput(ProgramPart(s1),s1,$1) + n = IC Comput(
ProgramPart(s2),s2,$1) &
IncAddr(CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,$1)),n)
 = CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,$1)) &
 DataPart Comput(ProgramPart(s1),s1,$1) = DataPart Comput(ProgramPart(s2),s2,$1
);
  assume
A6: ProgramPart Relocated(I,n) c= s2;
A7: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:123;
A8: Comput(ProgramPart(s1),s1,k+1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,k)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,k)),
      Comput(ProgramPart(s1),s1,k));
    reconsider l = IC Comput(ProgramPart(s1),s1,k+1) as Element of NAT;
    reconsider
     j = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k+1),Comput(ProgramPart
(s1),s1,k+1))
     as Instruction of SCM+FSA;
A9: Comput(ProgramPart(s2),s2,k+1) =
Following(ProgramPart s2,Comput(ProgramPart(s2),s2,k))
 by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(
ProgramPart(s2),s2,k)),
      Comput(ProgramPart(s2),s2,k)) by T;
    s1 +* (I +* Start-At( 0,SCM+FSA)) = s1 by A1,FUNCT_4:79;
    then
A11: IC Comput(ProgramPart(s1),s1,k+1) in dom I by A2,SCMFSA7B:def 7;
    assume
A12: P[k];
    hence
A13: IC Comput(ProgramPart(s1),s1,k+1) + n = IC Comput(ProgramPart(s2),s2,k+1)
by A8,A9,T,SCMFSA6A:41;
    then IC Comput(ProgramPart(s2),s2,k+1) in dom Relocated(I,n) by A11,
COMPOS_1:118;
    then IC Comput(ProgramPart(s2),s2,k+1) in dom Relocated(I,n) /\ NAT by
XBOOLE_0:def 4;
    then
A14: IC Comput(ProgramPart(s2),s2,k+1) in dom ProgramPart Relocated(I,n) by
RELAT_1:90;
    dom ProgramPart I = dom I /\ NAT by RELAT_1:90;
    then
A15: l in dom ProgramPart I by A11,XBOOLE_0:def 4;
A16: I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
    then
A17: dom I c= dom (I +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,k+1))/.IC Comput(ProgramPart(s1),s1,
k+1)
 = Comput(ProgramPart(s1),s1,k+1).IC Comput(ProgramPart(s1),s1,k+1) by
COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s2),s2,k+1))/.IC Comput(ProgramPart(s2),s2,
k+1)
 = Comput(ProgramPart(s2),s2,k+1).IC Comput(ProgramPart(s2),s2,k+1) by
COMPOS_1:38;
TX1: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k+1)
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k+1)
by AMI_1:123;
    j = s1.IC Comput(ProgramPart(s1),s1,k+1) by Y,AMI_1:54
      .= (I +* Start-At( 0,SCM+FSA)).IC Comput(ProgramPart(s1),s1,k+1)
       by A1,A17,A11,GRFUNC_1:8
      .= I.l by A16,A11,GRFUNC_1:8;
    hence IncAddr(CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,k+1)),n)
     = Relocated(I,n).(l + n) by A15,TX1,COMPOS_1:122
      .= (ProgramPart Relocated(I,n)).(IC Comput(ProgramPart(s2),s2,k+1)) by
A13,FUNCT_1:72
      .= s2.IC Comput(ProgramPart(s2),s2,k+1) by A6,A14,GRFUNC_1:8
      .= CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k+1))
       by Z,TX2,AMI_1:54;
    thus thesis by A12,A8,A9,T,SCMFSA6A:41;
  end;
A18: IC Comput(ProgramPart(s1),s1,0) = s1.IC SCM+FSA by EXTPRO_1:3
    .= IC(I +* Start-At( 0,SCM+FSA)) by A1,A3,GRFUNC_1:8
    .=  0 by COMPOS_1:142;
  assume
A19: IC s2 =  n;
A20:  0 in dom I by A2,Th3;
  then  0 + n in dom Relocated(I,n) by COMPOS_1:118;
  then
A21:  (0 + n) in dom ProgramPart Relocated(I,n) by COMPOS_1:16;
  IC SCM+FSA in dom (I +* Start-At( 0,SCM+FSA)) by COMPOS_1:141;
  then
A22: s1.IC s1 = s1.IC(I +* Start-At( 0,SCM+FSA))
 by A1,GRFUNC_1:8
    .= s1. 0 by COMPOS_1:142
    .= (I +* Start-At( 0,SCM+FSA)). 0 by A1,A5,A20,GRFUNC_1:8
    .= I. 0 by A4,A20,GRFUNC_1:8;
  ProgramPart I = I by RELAT_1:209;
  then
A23:  0 in dom ProgramPart I by A2,Th3;
  assume DataPart s1 = DataPart s2;
  then
A24: DataPart Comput(ProgramPart(s1),s1,0) = DataPart s2 by EXTPRO_1:3
    .= DataPart Comput(ProgramPart(s2),s2,0) by EXTPRO_1:3;
  let i be Element of NAT;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by COMPOS_1:38;
V:  (ProgramPart s2)/.IC s2
 = s2.IC s2 by COMPOS_1:38;
u: Comput(ProgramPart(s1),s1,0) = s1 by EXTPRO_1:3;
v: Comput(ProgramPart(s2),s2,0) = s2 by EXTPRO_1:3;
  IncAddr(CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,0)),n)
      = IncAddr(CurInstr(ProgramPart s1,s1),n) by u
    .= Relocated(I,n).( 0 + n) by A22,A23,Y,COMPOS_1:122
    .= (ProgramPart Relocated(I,n)). n by FUNCT_1:72
    .= CurInstr(ProgramPart s2,s2) by A6,A19,A21,V,GRFUNC_1:8
    .= CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,0))
     by v;
  then
A25: P[0] by A19,A18,A24,EXTPRO_1:3;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A25,A7);
  hence thesis;
end;

theorem Th12:
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being parahalting Program of SCM+FSA, a being
  Int-Location holds IExec(i ';' J,s).a = IExec(J,Exec(i,Initialized s)).a
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be parahalting Program of SCM+FSA;
  let a be Int-Location;
  thus IExec(i ';' J,s).a = IExec(Macro i ';' J,s).a by SCMFSA6A:def 6
    .= IExec(J,IExec(Macro i,s)).a by SCMFSA6C:1
    .= IExec(J,Exec(i,Initialized s)).a by SCMFSA6C:6;
end;

theorem Th13:
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being parahalting Program of SCM+FSA, f being
  FinSeq-Location holds IExec(i ';' J,s).f = IExec(J,Exec(i,Initialized s)).f
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be parahalting Program of SCM+FSA;
  let f be FinSeq-Location;
  thus IExec(i ';' J,s).f = IExec(Macro i ';' J,s).f by SCMFSA6A:def 6
    .= IExec(J,IExec(Macro i,s)).f by SCMFSA6C:2
    .= IExec(J,Exec(i,Initialized s)).f by SCMFSA6C:6;
end;

definition
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  func if=0(a,I,J) -> Program of SCM+FSA equals
  a =0_goto  (card J + 3)
  ';' J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
  coherence;
  func if>0(a,I,J) -> Program of SCM+FSA equals
  a >0_goto  (card J + 3)
  ';' J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
  coherence;
end;

definition
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  func if<0(a,I,J) -> Program of SCM+FSA equals
  if=0(a,J,if>0(a,J,I));
  coherence;
end;

Lm2: for a being Int-Location, I,J being Program of SCM+FSA holds  0 in
dom if=0(a,I,J) &  1 in dom if=0(a,I,J) &  0 in dom if>0(a,I,J) &
 1 in dom if>0(a,I,J)

proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  set i = a =0_goto  (card J + 3);

  if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop
  SCM+FSA) by SCMFSA6A:67

    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67

    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71

    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  )) by SCMFSA6A:def 6;

  then
A1: dom Macro i c= dom if=0(a,I,J) by SCMFSA6A:56;
A2: dom Macro i = { 0,  1} by COMPOS_1:149;
  then
A3:  1 in dom Macro i by TARSKI:def 2;
   0 in dom Macro i by A2,TARSKI:def 2;
  hence  0 in dom if=0(a,I,J) &  1 in dom if=0(a,I,J) by A1,A3;
  set i = a >0_goto  (card J + 3);

  if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop
  SCM+FSA) by SCMFSA6A:67

    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67

    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71

    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  )) by SCMFSA6A:def 6;

  then
A4: dom Macro i c= dom if>0(a,I,J) by SCMFSA6A:56;
A5: dom Macro i = { 0,  1} by COMPOS_1:149;
  then
A6:  1 in dom Macro i by TARSKI:def 2;
   0 in dom Macro i by A5,TARSKI:def 2;
  hence thesis by A4,A6;
end;

Lm3: for a being Int-Location, I,J being Program of SCM+FSA holds if=0(a,I,J).
 0 = a =0_goto  (card J + 3) & if=0(a,I,J). 1 = goto  2
& if>0(a,I,J). 0 = a >0_goto  (card J + 3) & if>0(a,I,J). 1 =
goto  2

proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  set i = a =0_goto  (card J + 3);

A2: if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop
  SCM+FSA) by SCMFSA6A:67

    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67

    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71

    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  )) by SCMFSA6A:def 6;

A3: dom Macro i = { 0,  1} by COMPOS_1:149;
  then  0 in dom Macro i by TARSKI:def 2;
  hence if=0(a,I,J). 0 = (Directed Macro i). 0 by A2,SCMFSA8A:28
    .= i by SCMFSA7B:7;
   1 in dom Macro i by A3,TARSKI:def 2;
  hence if=0(a,I,J). 1 = (Directed Macro i). 1 by A2,SCMFSA8A:28
    .= goto  2 by SCMFSA7B:8;
  set i = a >0_goto  (card J + 3);

A5: if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' (I ';' Stop
  SCM+FSA) by SCMFSA6A:67

    .= i ';' J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)) by SCMFSA6A:67

    .= i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71

    .= Macro i ';' (J ';' (Goto  (card I + 1) ';' (I ';' Stop SCM+FSA)
  )) by SCMFSA6A:def 6;

A6: dom Macro i = { 0,  1} by COMPOS_1:149;
  then  0 in dom Macro i by TARSKI:def 2;
  hence if>0(a,I,J). 0 = (Directed Macro i). 0 by A5,SCMFSA8A:28
    .= i by SCMFSA7B:7;
   1 in dom Macro i by A6,TARSKI:def 2;

  hence if>0(a,I,J). 1 = (Directed Macro i). 1 by A5,SCMFSA8A:28

    .= goto  2 by SCMFSA7B:8;
end;

theorem Th14:
  for I,J being Program of SCM+FSA, a being Int-Location holds
  card if=0(a,I,J) = card I + card J + 4
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
x: card Stop SCM+FSA = 1 by COMPOS_1:46;
  thus card if=0(a,I,J) = card (Macro (a =0_goto  (card J + 3)) ';' J
  ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA) by SCMFSA6A:def 6
    .= card (Macro (a =0_goto  (card J + 3)) ';' J ';' Goto  (
  card I + 1) ';' I) + 1 by x,SCMFSA6A:61
    .= card (Macro (a =0_goto  (card J + 3)) ';' J ';' Goto  (
  card I + 1)) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a =0_goto  (card J + 3)) ';' J) + card Goto
  (card I + 1) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a =0_goto  (card J + 3)) ';' J) + 1 + card I + 1
  by SCMFSA8A:29
    .= card Macro (a =0_goto  (card J + 3)) + card J + 1 + card I + 1
  by SCMFSA6A:61
    .= 2 + card J + 1 + card I + 1 by COMPOS_1:150
    .= card I + card J + 4;
end;

theorem Th15:
  for I,J being Program of SCM+FSA, a being Int-Location holds
  card if>0(a,I,J) = card I + card J + 4
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
x: card Stop SCM+FSA = 1 by COMPOS_1:46;
  thus card if>0(a,I,J) = card (Macro (a >0_goto  (card J + 3)) ';' J
  ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA) by SCMFSA6A:def 6
    .= card (Macro (a >0_goto  (card J + 3)) ';' J ';' Goto  (
  card I + 1) ';' I) + 1 by x,SCMFSA6A:61
    .= card (Macro (a >0_goto  (card J + 3)) ';' J ';' Goto  (
  card I + 1)) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a >0_goto  (card J + 3)) ';' J) + card Goto
  (card I + 1) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a >0_goto  (card J + 3)) ';' J) + 1 + card I + 1
  by SCMFSA8A:29
    .= card Macro (a >0_goto  (card J + 3)) + card J + 1 + card I + 1
  by SCMFSA6A:61
    .= 2 + card J + 1 + card I + 1 by COMPOS_1:150
    .= card I + card J + 4;
end;

theorem Th16:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a = 0 & I is_closed_on s & I is_halting_on s
  holds if=0(a,I,J) is_closed_on s & if=0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = s +* (I1 +* Start-At( 0,SCM+FSA));
  set s3 = s +* (if=0(a,I,J) +* Start-At( 0,SCM+FSA));
  set s4 = Comput(ProgramPart(s3),s3,1);
  set i = a =0_goto  (card J + 3);
A1: not a in dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
A2:  0 in dom if=0(a,I,J) by Lm2;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA))
   by GRFUNC_1:8;
  then
A3: s3. 0 = (if=0(a,I,J) +* Start-At( 0,SCM+FSA)). 0
 by A2,FUNCT_4:14
    .= if=0(a,I,J). 0 by A2,SCMFSA6B:7
    .= i by Lm3;
  IC SCM+FSA in dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA)) by COMPOS_1:141;
  then
A4: IC s3 = IC(if=0(a,I,J) +* Start-At( 0,SCM+FSA))
 by FUNCT_4:14
    .=  0 by COMPOS_1:142;
A5: if=0(a,I,J) c= if=0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  if=0(a,I,J) +* Start-At( 0,SCM+FSA) c= s3 by FUNCT_4:26;
  then
A6: if=0(a,I,J) c= s3 by A5,XBOOLE_1:1;
A7: if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67;
  card (i ';' J ';' Goto  (card I + 1)) = card (Macro i ';' J ';'
  Goto  (card I + 1)) by SCMFSA6A:def 6
    .= card (Macro i ';' J) + card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by COMPOS_1:150
    .= card J + (2 + 1);
  then ProgramPart Relocated(I1,card J + 3) c= if=0(a,I,J) by A7,Lm1;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A6,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:99;
  then
A8: ProgramPart Relocated(I1,card J + 3) c= s4 by RELAT_1:209;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
A9: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A4,A3,Y;
A10: DataPart s1 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A11: now
    let f be FinSeq-Location;
    thus s1.f = s3.f by A10,SCMFSA6A:38
      .= s4.f by A9,SCMFSA_2:96;
  end;
  now
    let a be Int-Location;
    thus s1.a = s3.a by A10,SCMFSA6A:38
      .= s4.a by A9,SCMFSA_2:96;
  end;
  then
A12: DataPart s1 = DataPart s4 by A11,SCMFSA6A:38;
  assume s.a = 0;
  then s3.a = 0 by A1,FUNCT_4:12;
  then
A13: IC Comput(ProgramPart(s3),s3,1) =  (card J + 3) by A9,SCMFSA_2:96;
  assume
A14: I is_closed_on s;
  assume
A15: I is_halting_on s;
  then
A16: I1 is_closed_on s by A14,SCMFSA8A:46;
  I1 is_halting_on s by A14,A15,SCMFSA8A:46;
  then
A17: ProgramPart s1 halts_on s1 by SCMFSA7B:def 8;
  DataPart s = DataPart s1 by SCMFSA8A:11;
  then
A18: I1 is_closed_on s1 by A16,Th6;
A19: I1 +* Start-At( 0,SCM+FSA) c= s1 by FUNCT_4:26;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A20:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s1), s1,k1) as Element of NAT;
       m in dom I1 by A16,SCMFSA7B:def 7;
      then
A21:  m < card I1 by AFINSQ_1:70;
      card Stop SCM+FSA = 1 by COMPOS_1:46;
      then
A22:  card I1 = card I + 1 by SCMFSA6A:61;
      card if=0(a,I,J) = card I + card J + 4 by Th14
        .= card J + 3 + card I1 by A22;
      then
A23:  m + (card J + 3) < card if=0(a,I,J) by A21,XREAL_1:8;
T: ProgramPart s4 = ProgramPart s3
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A20,EXTPRO_1:5
        .=  (m + (card J + 3)) by A19,A18,A8,A13,A12,Th11,T;
      hence IC Comput(ProgramPart(s3),s3,k) in dom if=0(a,I,J) by A23,
AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s3),s3,k) in dom if=0(a,I,J) by A2,A4,
EXTPRO_1:3;
    end;
  end;
  hence if=0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s1)
,s1))
        by EXTPRO_1:5;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1))
   = CurInstr(ProgramPart s4,
   Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1))) by x,T
    .= IncAddr(CurInstr(ProgramPart s1,
    Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))),(card J + 3)) by
A19,A18,A8,A13,A12,Th11
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A17,EXTPRO_1:def 14
    .= halt SCM+FSA by SCMFSA_4:8;
  then ProgramPart s3 halts_on s3 by EXTPRO_1:30;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th17:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & I is_closed_on Initialized s & I
is_halting_on Initialized s holds IExec(if=0(a,I,J),s)
= IExec(I,s) +* Start-At((card I + card J + 3),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = s +* Initialized I1;
  set s3 = s +* Initialized if=0(a,I,J);
  set s4 = Comput(ProgramPart(s3),s3,1);
  set i = a =0_goto  (card J + 3);
A1: I1 +* Start-At( 0,SCM+FSA) c= s1 by FUNCT_4:26,SCMFSA6B:8;
A2: if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67;
A3:  0 in dom if=0(a,I,J) by Lm2;
  if=0(a,I,J) c= Initialized if=0(a,I,J) by SCMFSA6A:26;
  then dom if=0(a,I,J) c= dom Initialized if=0(a,I,J) by GRFUNC_1:8;
  then
A4: s3. 0 = (Initialized if=0(a,I,J)). 0 by A3,FUNCT_4:14
    .= if=0(a,I,J). 0 by A3,SCMFSA6A:50
    .= i by Lm3;
  IC SCM+FSA in dom Initialized if=0(a,I,J) by SCMFSA6A:24;
  then
A5: IC s3 = (Initialized if=0(a,I,J)).IC SCM+FSA by FUNCT_4:14
    .=  0 by SCMFSA6A:46;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
A6: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A5,A4,Y;
A7: if=0(a,I,J) c= Initialized if=0(a,I,J) by SCMFSA6A:26;
  Initialized if=0(a,I,J) c= s3 by FUNCT_4:26;
  then
A8: if=0(a,I,J) c= s3 by A7,XBOOLE_1:1;
A9: not a in dom Initialized if=0(a,I,J) by SCMFSA6A:48;
A10: dom ProgramPart s = A by COMPOS_1:34;
  assume s.a = 0;
  then s3.a = 0 by A9,FUNCT_4:12;
  then
A11: IC Comput(ProgramPart(s3),s3,1) =  (card J + 3) by A6,SCMFSA_2:96;
A12: DataPart s1 = DataPart s3 by SCMFSA6A:39,53;
A13: now
    let f be FinSeq-Location;
    thus s1.f = s3.f by A12,SCMFSA6A:38
      .= s4.f by A6,SCMFSA_2:96;
  end;
  now
    let a be Int-Location;
    thus s1.a = s3.a by A12,SCMFSA6A:38
      .= s4.a by A6,SCMFSA_2:96;
  end;
  then
A14: DataPart s1 = DataPart s4 by A13,SCMFSA6A:38;
  card (i ';' J ';' Goto  (card I + 1)) = card (Macro i ';' J ';'
  Goto  (card I + 1)) by SCMFSA6A:def 6
    .= card (Macro i ';' J) + card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by COMPOS_1:150
    .= card J + (2 + 1);
  then ProgramPart Relocated(I1,card J + 3) c= if=0(a,I,J) by A2,Lm1;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A8,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:99;
  then
A15: ProgramPart Relocated(I1,card J + 3) c= s4 by RELAT_1:209;
  assume
A16: I is_closed_on Initialized s;
  assume
A17: I is_halting_on Initialized s;
  then
A18: ProgramPart s1 halts_on s1 by A16,SCMFSA8A:55;
  I1 is_closed_on Initialized s by A16,A17,SCMFSA8A:46;
  then
A19: I1 is_closed_on s1 by Th9;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s1)
,s1))
 by EXTPRO_1:5;
A20: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1))
 = CurInstr(ProgramPart s4,
 Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1))) by x,T
    .= IncAddr(CurInstr(ProgramPart s1,
    Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))),(card J + 3)) by
A1,A19,A15,A11,A14,Th11
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A18,EXTPRO_1:def 14
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A21: ProgramPart s3 halts_on s3 by EXTPRO_1:30;
  now
    let l be Element of NAT;
    assume
A22: l < LifeSpan(ProgramPart(s1),s1) + 1;
Z:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
u: Comput(ProgramPart(s3),s3,0) = s3 by EXTPRO_1:3;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,l)
by AMI_1:123;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart Comput(ProgramPart(s3),s3,l),Comput(ProgramPart
(s3),s3,l))
       = CurInstr(ProgramPart s3,s3) by u;
      hence CurInstr(ProgramPart s3,Comput(ProgramPart s3,s3,l)) <>
       halt SCM+FSA by A5,A4,Z,TX3;
    end;
    suppose
      l <> 0;
      then consider n being Nat such that
A23:  l = n + 1 by NAT_1:6;
      assume
A24:  CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l)) = halt SCM+FSA;
      reconsider n as Element of NAT by ORDINAL1:def 13;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),
s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,n+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),n) by EXTPRO_1:5;
      InsCode CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,n))
       = InsCode IncAddr(CurInstr(ProgramPart (s1),
       Comput(ProgramPart(s1),s1,n)),(card J + 3))
        by SCMFSA_4:22
        .= InsCode CurInstr(ProgramPart s4,Comput(ProgramPart(s4),s4,n))
         by A1,A19,A15,A11,A14,Th11
        .= 0 by A23,A24,x,T,SCMFSA_2:124;
      then
A25:  CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,n))
 = halt SCM+FSA by SCMFSA_2:122;
      n < LifeSpan(ProgramPart(s1),s1) by A22,A23,XREAL_1:8;
      hence contradiction by A18,A25,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart(s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCM+FSA
  holds LifeSpan(ProgramPart(s1),s1) + 1 <= l;
  then
A26: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s1),s1) + 1 by A20,A21
,EXTPRO_1:def 14;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
  ProgramPart s1 halts_on s1 by A16,A17,SCMFSA8A:55;
  then
A27: DataPart Result(ProgramPart(s1),s1) = DataPart Comput(ProgramPart( s1), s1
,LifeSpan(ProgramPart(s1),s1)) by EXTPRO_1:23
    .= DataPart Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s1),s1)) by A1
,A19,A15,A11,A14,Th11,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s1),s1) + 1)
by EXTPRO_1:5
    .= DataPart Result(ProgramPart(s3),s3) by A21,A26,EXTPRO_1:23;
A28: now
    let x be set;
A29: IExec(I1,s) = Result(ProgramPart(s1),s1) +* s | A by SCMFSA6B:def 1;
A30: x in dom (s | A) implies x is Element of NAT
   by RELAT_1:86;
A31: dom Start-At( (card I + card J + 3),SCM+FSA) = {IC SCM+FSA}
 by FUNCOP_1:19;
A32: IExec(if=0(a,I,J),s) = (Result(ProgramPart(s3),s3)) +* (s | A) by
SCMFSA6B:def 1;
    assume
A33: x in dom IExec(if=0(a,I,J),s);
    per cases by A33,SCMFSA6A:35;
    suppose
A34:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A35:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A31,TARSKI:def 1;
      thus IExec(if=0(a,I,J),s).x = (Result(ProgramPart(s3),s3)).x by A32,A30
,A34,FUNCT_4:12,SCMFSA_2:84
        .= (Result(ProgramPart(s1),s1)).x by A27,A34,SCMFSA6A:38
        .= IExec(I1,s).x by A29,A30,A34,FUNCT_4:12,SCMFSA_2:84
        .= (IExec(I1,s) +* Start-At((card I+card J+3),SCM+FSA)).x by A35,
FUNCT_4:12;
    end;
    suppose
A36:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A37:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A31,TARSKI:def 1;
      thus IExec(if=0(a,I,J),s).x = (Result(ProgramPart(s3),s3)).x by A32,A30
,A36,FUNCT_4:12,SCMFSA_2:85
        .= (Result(ProgramPart(s1),s1)).x by A27,A36,SCMFSA6A:38
        .= IExec(I1,s).x by A29,A30,A36,FUNCT_4:12,SCMFSA_2:85
        .= (IExec(I1,s) +* Start-At((card I+card J+3),SCM+FSA)).x by A37,
FUNCT_4:12;
    end;
    suppose
A38:  x = IC SCM+FSA;
      then
A39:  x in dom Start-At((card I+card J+3),SCM+FSA)by A31,TARSKI:def 1;
A40:  IC Result(ProgramPart(s1),s1) = IExec(I1,s).IC SCM+FSA by A29,A30,A38,
COMPOS_1:3,FUNCT_4:12
        .= IC (IExec(I,s) +* Start-At( card I,SCM+FSA))
         by A16,A17,SCMFSA8A:57
        .=  card I by FUNCT_4:121;
X:    ProgramPart s1 halts_on s1 by A16,A17,SCMFSA8A:55;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      thus IExec(if=0(a,I,J),s).x = (Result(ProgramPart(s3),s3)).x by A32,A30
,A38,COMPOS_1:3,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s1),s1) + 1).x by
A21,A26,EXTPRO_1:23
        .= IC Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s1),s1)) by A38,
EXTPRO_1:5
        .= IC Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) + (card
J + 3) by A1,A19,A15,A11,A14,Th11,T
        .= IC Result(ProgramPart(s1),s1) + (card J + 3) by X,EXTPRO_1:23
        .= (Start-At((card I+(card J+3)),SCM+FSA)).IC SCM+FSA by A40,
FUNCOP_1:87
        .= (IExec(I1,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A38,A39,FUNCT_4:14;
    end;
    suppose
A41:  x is Element of NAT;
      then x <> IC SCM+FSA by COMPOS_1:3;
      then
A42:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A31,TARSKI:def 1;
A43:  x in NAT by A41;
      hence IExec(if=0(a,I,J),s).x = (s | A).x by A10,A32,FUNCT_4:14
        .= IExec(I1,s).x by A10,A29,A43,FUNCT_4:14
        .= (IExec(I1,s) +* Start-At((card I+card J+3),SCM+FSA)).x by A42,
FUNCT_4:12;
    end;
  end;
  dom IExec(if=0(a,I,J),s) = the carrier of SCM+FSA by PARTFUN1:def 4
    .= dom (IExec(I1,s) +* Start-At((card I+card J+3),SCM+FSA))
     by PARTFUN1:def 4;
  hence IExec(if=0(a,I,J),s) = IExec(I1,s) +* Start-At( (card I + card J
  + 3),SCM+FSA) by A28,FUNCT_1:9
    .= IExec(I,s) +* Start-At( card I,SCM+FSA) +*
     Start-At( (card I +
  card J + 3),SCM+FSA) by A16,A17,SCMFSA8A:57
    .= IExec(I,s) +* Start-At((card I+card J+3),SCM+FSA)by FUNCT_4:122;
end;

theorem Th18:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a <> 0 & J is_closed_on s & J is_halting_on
  s holds if=0(a,I,J) is_closed_on s & if=0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = s +* (JI2 +* Start-At( 0,SCM+FSA));
  set s3 = s +* (if=0(a,I,J) +* Start-At( 0,SCM+FSA));
  set s4 = Comput(ProgramPart(s3),s3,1);
  set s5 = Comput(ProgramPart(s3),s3,2);
  set i = a =0_goto  (card J + 3);
A1: JI2 +* Start-At( 0,SCM+FSA) c= s2 by FUNCT_4:26;
  IC SCM+FSA in dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA)) by COMPOS_1:141;
  then
A2: IC s3 = IC(if=0(a,I,J) +* Start-At( 0,SCM+FSA))
 by FUNCT_4:14
    .=  0 by COMPOS_1:142;
A3: if=0(a,I,J) c= if=0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  if=0(a,I,J) +* Start-At( 0,SCM+FSA) c= s3 by FUNCT_4:26;
  then
A4: if=0(a,I,J) c= s3 by A3,XBOOLE_1:1;
A5: if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' JI2 by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:def 6;
  then ProgramPart Relocated(JI2,card Macro i) c= if=0(a,I,J) by Lm1;
  then ProgramPart Relocated(JI2,2) c= if=0(a,I,J) by COMPOS_1:150;
  then ProgramPart Relocated(JI2,2) c= s3 by A4,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(JI2,2) c= s5 by AMI_1:99;
  then
A6: ProgramPart Relocated(JI2,2) c= s5 by RELAT_1:209;
A7: not a in dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
A8:  0 in dom if=0(a,I,J) by Lm2;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A9: dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At( 0,SCM+FSA))
 by GRFUNC_1:8;
  then
A10: s3. 0 = (if=0(a,I,J) +* Start-At( 0,SCM+FSA)). 0
 by A8,FUNCT_4:14
    .= if=0(a,I,J). 0 by A8,SCMFSA6B:7
    .= i by Lm3;
A11:  1 in dom if=0(a,I,J) by Lm2;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
A12: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A2,A10,Y;
  assume s.a <> 0;
  then s3.a <> 0 by A7,FUNCT_4:12;
  then
A13: IC Comput(ProgramPart(s3),s3,1) = succ  0 by A2,A12,SCMFSA_2:96
    .=  (0 + 1);
A14: Comput(ProgramPart(s3),s3,1). 1 = s3. 1 by AMI_1:54
    .= (if=0(a,I,J) +* Start-At( 0,SCM+FSA)). 1
     by A9,A11,FUNCT_4:14
    .= if=0(a,I,J). 1 by A11,SCMFSA6B:7
    .= goto  2 by Lm3;
  assume
A15: J is_closed_on s;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A16: Comput(ProgramPart( s3), s3,1 + 1) = Following(ProgramPart s3,s4) by
EXTPRO_1:4
    .= Exec(goto  2,s4) by A13,A14,Y,T;
A17: DataPart s2 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A18: now
    let f be FinSeq-Location;
    thus s2.f = s3.f by A17,SCMFSA6A:38
      .= Comput(ProgramPart(s3),s3,1).f by A12,SCMFSA_2:96
      .= s5.f by A16,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s2.a = s3.a by A17,SCMFSA6A:38
      .= Comput(ProgramPart(s3),s3,1).a by A12,SCMFSA_2:96
      .= s5.a by A16,SCMFSA_2:95;
  end;
  then
A19: DataPart s2 = DataPart s5 by A18,SCMFSA6A:38;
  assume
A20: J is_halting_on s;
  then
A21: JI2 is_closed_on s by A15,SCMFSA8A:58;
  then
A22: JI2 is_closed_on s2 by Th10;
A23: ProgramPart s2 halts_on s2 by A15,A20,SCMFSA8A:59;
A24: IC s5 =  2 by A16,SCMFSA_2:95;
  now
    let k be Element of NAT;
    k = 0 or 0 + 1 < k + 1 by XREAL_1:8;
    then
A25: k = 0 or 1 <= k by NAT_1:13;
    per cases by A25,XXREAL_0:1;
    suppose
A26:  1 < k;
      then consider k1 being Nat such that
A27:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      0 + 1 < k1 + 1 by A26,A27;
      then consider k2 being Nat such that
A28:  k2 + 1 = k1 by NAT_1:6;
      reconsider k2 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s2), s2,k2) as Element of NAT;
A29:  card if=0(a,I,J) = card Macro i + card JI2 by A5,SCMFSA6A:61
        .= 2 + card JI2 by COMPOS_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
X: Comput(ProgramPart( s3), s4,1) = Comput(ProgramPart( s3), s3,1 + 1)
           by EXTPRO_1:5;
       m in dom JI2 by A21,SCMFSA7B:def 7;
      then m < card JI2 by AFINSQ_1:70;
      then
A30:  m + 2 < card if=0(a,I,J) by A29,XREAL_1:8;
S: ProgramPart s4 = ProgramPart Comput(ProgramPart( s4), s4,1)
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s4), s4,k1) by
A27,T,EXTPRO_1:5
        .= IC Comput(ProgramPart s4, Comput(
ProgramPart( s4), s4,1),k2) by A28,EXTPRO_1:5
        .= IC Comput(ProgramPart( Comput(ProgramPart( s3), s3,1 + 1)), Comput(
ProgramPart( s3), s3,1 + 1),k2) by X,S,T
        .=  (m + 2) by A1,A22,A6,A24,A19,Th11;
      hence IC Comput(ProgramPart(s3),s3,k) in dom if=0(a,I,J) by A30,
AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s3),s3,k) in dom if=0(a,I,J) by A8,A2,
EXTPRO_1:3;
    end;
    suppose
      k = 1;
      hence IC Comput(ProgramPart(s3),s3,k) in dom if=0(a,I,J) by A13,Lm2;
    end;
  end;
  hence if=0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,2)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+2)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,2),LifeSpan(ProgramPart(s2)
,s2))
 by EXTPRO_1:5;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+2))
   = CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+2))
  .= CurInstr(ProgramPart s5,
   Comput(ProgramPart(s5),s5,LifeSpan(ProgramPart(s2),s2))) by x,T
    .= IncAddr(CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))),2) by A1,A22,A6
,A24,A19,Th11
    .= IncAddr(halt SCM+FSA,2) by A23,EXTPRO_1:def 14
    .= halt SCM+FSA by SCMFSA_4:8;
  then ProgramPart s3 halts_on s3 by EXTPRO_1:30;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th19:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <> 0 & J is_closed_on
Initialized s & J is_halting_on Initialized s
holds IExec(if=0(a,I,J),s) = IExec(
  J,s) +* Start-At((card I+card J+3),SCM+FSA)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = s +* Initialized JI2;
  set s3 = s +* Initialized if=0(a,I,J);
  set s4 = Comput(ProgramPart( s3), s3,1);
  set s5 = Comput(ProgramPart( s3), s3,2);
  set i = a =0_goto  (card J + 3);
A1: JI2 +* Start-At( 0,SCM+FSA) c= s2 by FUNCT_4:26,SCMFSA6B:8;
  if=0(a,I,J) c= Initialized if=0(a,I,J) by SCMFSA6A:26;
  then
A2: dom if=0(a,I,J) c= dom Initialized if=0(a,I,J) by GRFUNC_1:8;
A3:  0 in dom if=0(a,I,J) by Lm2;
  then
A4: s3. 0 = (Initialized if=0(a,I,J)). 0 by A2,FUNCT_4:14
    .= if=0(a,I,J). 0 by A3,SCMFSA6A:50
    .= i by Lm3;
A5: if=0(a,I,J) c= Initialized if=0(a,I,J) by SCMFSA6A:26;
A6:  1 in dom if=0(a,I,J) by Lm2;
A7: Comput(ProgramPart(s3),s3,1). 1 = s3. 1 by AMI_1:54
    .= (Initialized if=0(a,I,J)). 1 by A2,A6,FUNCT_4:14
    .= if=0(a,I,J). 1 by A6,SCMFSA6A:50
    .= goto  2 by Lm3;
  IC SCM+FSA in dom Initialized if=0(a,I,J) by SCMFSA6A:24;
  then
A8: IC s3 = (Initialized if=0(a,I,J)).IC SCM+FSA by FUNCT_4:14
    .=  0 by SCMFSA6A:46;
  if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' JI2 by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:def 6;
  then ProgramPart Relocated(JI2,card Macro i) c= if=0(a,I,J) by Lm1;
  then
A9: ProgramPart Relocated(JI2,2) c= if=0(a,I,J) by COMPOS_1:150;
A10: not a in dom Initialized if=0(a,I,J) by SCMFSA6A:48;
A11: dom (s | A) = dom s /\ A by RELAT_1:90
    .= (D \/ {IC SCM+FSA} \/ A) /\ A by SCMFSA6A:34
    .= A by XBOOLE_1:21;
  Initialized if=0(a,I,J) c= s3 by FUNCT_4:26;
  then if=0(a,I,J) c= s3 by A5,XBOOLE_1:1;
  then ProgramPart Relocated(JI2,2) c= s3 by A9,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(JI2,2) c= s5 by AMI_1:99;
  then
A12: ProgramPart Relocated(JI2,2) c= s5 by RELAT_1:209;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
A13: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A8,A4,Y;
  assume s.a <> 0;
  then s3.a <> 0 by A10,FUNCT_4:12;
  then
A14: IC Comput(ProgramPart(s3),s3,1) = succ  0 by A8,A13,SCMFSA_2:96
    .=  (0 + 1);
  assume
A15: J is_closed_on Initialized s;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A16: Comput(ProgramPart( s3), s3,1 + 1) = Following(ProgramPart s3,s4) by
EXTPRO_1:4
    .= Exec(goto  2,s4) by A14,A7,Y,T;
  then
A17: IC s5 =  2 by SCMFSA_2:95;
A18: DataPart s2 = DataPart s3 by SCMFSA6A:39,53;
A19: now
    let f be FinSeq-Location;
    thus s2.f = s3.f by A18,SCMFSA6A:38
      .= Comput(ProgramPart(s3),s3,1).f by A13,SCMFSA_2:96
      .= s5.f by A16,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s2.a = s3.a by A18,SCMFSA6A:38
      .= Comput(ProgramPart(s3),s3,1).a by A13,SCMFSA_2:96
      .= s5.a by A16,SCMFSA_2:95;
  end;
  then
A20: DataPart s2 = DataPart s5 by A19,SCMFSA6A:38;
  assume
A21: J is_halting_on Initialized s;
  then
A22: ProgramPart s2 halts_on s2 by A15,SCMFSA8A:60;
  JI2 is_closed_on Initialized s by A15,A21,SCMFSA8A:58;
  then
A23: JI2 is_closed_on s2 by Th9;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,2)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+2)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,2),LifeSpan(ProgramPart(s2)
,s2))
 by EXTPRO_1:5;
A24: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+2))
 = CurInstr(ProgramPart s5,
 Comput(ProgramPart(s5),s5,LifeSpan(ProgramPart(s2),s2))) by x,T
    .= IncAddr(CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))),2) by A1,A23,A12
,A17,A20,Th11
    .= IncAddr(halt SCM+FSA,2) by A22,EXTPRO_1:def 14
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A25: ProgramPart s3 halts_on s3 by EXTPRO_1:30;
  now
    let l be Element of NAT;
    assume
A26: l < LifeSpan(ProgramPart(s2),s2) + 2;
u: Comput(ProgramPart(s3),s3,0) = s3 by EXTPRO_1:3;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,l))/.IC Comput(ProgramPart(s3),s3,l)
 = Comput(ProgramPart(s3),s3,l).IC Comput(ProgramPart(s3),s3,l) by COMPOS_1:38;
Z:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,l)
by AMI_1:123;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart Comput(ProgramPart(s3),s3,l),Comput(ProgramPart
(s3),s3,l))
       = CurInstr(ProgramPart s3,s3) by u;
      hence CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l)) <>
       halt SCM+FSA by A8,A4,Z,TX3;
    end;
    suppose
      l = 1;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) <>
       halt SCM+FSA by A14,A7,Y,TX3;
    end;
    suppose
A27:  l <> 0 & l <> 1;
      assume
A28:  CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCM+FSA;
      consider n being Nat such that
A29:  l = n + 1 by A27,NAT_1:6;
      n <> 0 by A27,A29;
      then consider l2 being Nat such that
A30:  n = l2 + 1 by NAT_1:6;
      reconsider l2 as Element of NAT by ORDINAL1:def 13;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(
s3),s3,1+1)
by AMI_1:123;
TX5: ProgramPart s5 = ProgramPart Comput(ProgramPart(s5),s5,l2)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,l2+(1+1))
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1+1),l2) by EXTPRO_1:5;
      InsCode CurInstr(ProgramPart (s2),Comput(
ProgramPart(s2),s2,l2)) =
       InsCode IncAddr(CurInstr(ProgramPart s2,
       Comput(ProgramPart(s2),s2,l2)),2) by SCMFSA_4:22
        .= InsCode CurInstr(ProgramPart s5,Comput(
ProgramPart(s5),s5,l2))
         by A1,A23,A12,A17,A20,Th11
        .= InsCode CurInstr(ProgramPart Comput(ProgramPart(s3),s3,l2+(1+1)),
        Comput(ProgramPart(s3),s3,l2+(1+1))) by x,T,TX5
        .= 0 by A29,A30,A28,TX3,SCMFSA_2:124;
      then
A31:  CurInstr(ProgramPart s2,Comput(ProgramPart(s2)
,s2,l2))
 = halt SCM+FSA by SCMFSA_2:122;
      n + 1 < LifeSpan(ProgramPart(s2),s2) + 1 + 1 by A26,A29;
      then n < LifeSpan(ProgramPart(s2),s2) + 1 by XREAL_1:8;
      then l2 < LifeSpan(ProgramPart(s2),s2) by A30,XREAL_1:8;
      hence contradiction by A22,A31,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart(s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCM+FSA
  holds LifeSpan(ProgramPart(s2),s2) + 2 <= l;
  then
A32: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s2),s2) + 2 by A24,A25
,EXTPRO_1:def 14;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:123;
A33: DataPart Result(ProgramPart(s2),s2) = DataPart Comput(ProgramPart( s2), s2
,LifeSpan(ProgramPart(s2),s2)) by A22,EXTPRO_1:23
    .= DataPart Comput(ProgramPart( s3), s5,LifeSpan(ProgramPart(s2),s2)) by A1
,A23,A12,A17,A20,Th11,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 2)
by EXTPRO_1:5
    .= DataPart Result(ProgramPart(s3),s3) by A25,A32,EXTPRO_1:23;
A34: now
    let x be set;
A35: x in dom (s | A) implies x is Element of NAT
by RELAT_1:86;
A36: dom Start-At((card I+card J+3),SCM+FSA)= {IC SCM+FSA}
 by FUNCOP_1:19;
A37: IExec(if=0(a,I,J),s) = (Result(ProgramPart(s3),s3)) +* (s | A) by
SCMFSA6B:def 1;
A38: IExec(JI2,s) = Result(ProgramPart(s2),s2) +* s | A by SCMFSA6B:def 1;
    assume
A39: x in dom IExec(if=0(a,I,J),s);
    per cases by A39,SCMFSA6A:35;
    suppose
A40:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A41:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A36,TARSKI:def 1;
      thus IExec(if=0(a,I,J),s).x = (Result(ProgramPart(s3),s3)).x by A35,A37
,A40,FUNCT_4:12,SCMFSA_2:84
        .= (Result(ProgramPart(s2),s2)).x by A33,A40,SCMFSA6A:38
        .= IExec(JI2,s).x by A35,A38,A40,FUNCT_4:12,SCMFSA_2:84
        .= (IExec(JI2,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A41,FUNCT_4:12;
    end;
    suppose
A42:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A43:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A36,TARSKI:def 1;
      thus IExec(if=0(a,I,J),s).x = (Result(ProgramPart(s3),s3)).x by A35,A37
,A42,FUNCT_4:12,SCMFSA_2:85
        .= (Result(ProgramPart(s2),s2)).x by A33,A42,SCMFSA6A:38
        .= IExec(JI2,s).x by A35,A38,A42,FUNCT_4:12,SCMFSA_2:85
        .= (IExec(JI2,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A43,FUNCT_4:12;
    end;
    suppose
A44:  x = IC SCM+FSA;
      then
A45:  x in dom Start-At((card I+card J+3),SCM+FSA)by A36,TARSKI:def 1;
A46:  IC Result(ProgramPart(s2),s2) = IC IExec(JI2,s) by A35,A38,A44,COMPOS_1:3
,FUNCT_4:12
        .=  (card I + card J + 1) by A15,A21,SCMFSA8A:61;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:123;
      thus IExec(if=0(a,I,J),s).x = (Result(ProgramPart(s3),s3)).x by A35,A37
,A44,COMPOS_1:3,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 2).x by
A25,A32,EXTPRO_1:23
        .= IC Comput(ProgramPart( s3), s5,LifeSpan(ProgramPart(s2),s2)) by A44,
EXTPRO_1:5
        .= IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s2),s2)) + 2 by
A1,A23,A12,A17,A20,Th11,T
        .= IC Result(ProgramPart(s2),s2) + 2 by A22,EXTPRO_1:23
        .= (Start-At ( (card I + card J + 1) + 2,SCM+FSA)).IC SCM+FSA
         by A46,FUNCOP_1:87
        .= (IExec(JI2,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A44,A45,FUNCT_4:14;
    end;
    suppose
A47:  x is Element of NAT;
      then x <> IC SCM+FSA by COMPOS_1:3;
      then
A48:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A36,TARSKI:def 1;
A49:  x in NAT by A47;
      hence IExec(if=0(a,I,J),s).x = (s | A).x by A11,A37,FUNCT_4:14
        .= IExec(JI2,s).x by A11,A38,A49,FUNCT_4:14
        .= (IExec(JI2,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A48,FUNCT_4:12;
    end;
  end;
  dom IExec(if=0(a,I,J),s) = the carrier of SCM+FSA by PARTFUN1:def 4
    .= dom (IExec(JI2,s) +* Start-At((card I+card J+3),SCM+FSA))
     by PARTFUN1:def 4;
  hence
  IExec(if=0(a,I,J),s) = IExec(JI2,s) +* Start-At( (card I + card J
  + 3),SCM+FSA) by A34,FUNCT_1:9
    .= IExec(J,s) +* Start-At( (card I + card J + 1),SCM+FSA)
     +* Start-At(
   (card I + card J + 3),SCM+FSA) by A15,A21,SCMFSA8A:62
    .= IExec(J,s) +* Start-At((card I+card J+3),SCM+FSA)by FUNCT_4:122;
end;

theorem Th20:
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds if=0(a,I,J) is parahalting & (s.
  a = 0 implies IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At( (card I +
card J + 3),SCM+FSA)) & (s.a <> 0 implies IExec(if=0(a,I,J),s) =
 IExec(J,s) +* Start-At(
   (card I + card J + 3),SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
A1: I is_halting_on Initialized s by SCMFSA7B:25;
  now
    let s be State of SCM+FSA;
A2: I is_closed_on s by SCMFSA7B:24;
A3: I is_halting_on s by SCMFSA7B:25;
A4: J is_halting_on s by SCMFSA7B:25;
A5: J is_closed_on s by SCMFSA7B:24;
    assume if=0(a,I,J) +* Start-At( 0,SCM+FSA) c= s;
    then
A6: s = s +* (if=0(a,I,J) +* Start-At( 0,SCM+FSA)) by FUNCT_4:79;
    per cases;
    suppose
      s.a = 0;
      then if=0(a,I,J) is_halting_on s by A2,A3,Th16;
      hence ProgramPart s halts_on s by A6,SCMFSA7B:def 8;
    end;
    suppose
      s.a <> 0;
      then if=0(a,I,J) is_halting_on s by A5,A4,Th18;
      hence ProgramPart s halts_on s by A6,SCMFSA7B:def 8;
    end;
  end;
  then if=0(a,I,J) +* Start-At( 0,SCM+FSA) is halting by EXTPRO_1:def 10;
  hence if=0(a,I,J) is parahalting by SCMFSA6B:def 3;
  I is_closed_on Initialized s by SCMFSA7B:24;
  hence s.a = 0 implies IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At( (
  card I + card J + 3),SCM+FSA) by A1,Th17;
A7: J is_halting_on Initialized s by SCMFSA7B:25;
  J is_closed_on Initialized s by SCMFSA7B:24;
  hence thesis by A7,Th19;
end;

theorem Th21:
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds IC IExec(if=0(a,I,J),s) =
(card I + card J + 3) & (s.a = 0 implies ((for d being Int-Location holds IExec
  (if=0(a,I,J),s).d = IExec(I,s).d) & for f being FinSeq-Location holds IExec(
  if=0(a,I,J),s).f = IExec(I,s).f)) & (s.a <> 0 implies ((for d being
  Int-Location holds IExec(if=0(a,I,J),s).d = IExec(J,s).d) & for f being
  FinSeq-Location holds IExec(if=0(a,I,J),s).f = IExec(J,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby
    per cases;
    suppose
      s.a = 0;
      then
      IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At( (card I + card
      J + 3),SCM+FSA) by Th20;
      hence IC IExec(if=0(a,I,J),s) =  (card I + card J + 3) by FUNCT_4:121
;
    end;
    suppose
      s.a <> 0;
      then
      IExec(if=0(a,I,J),s) = IExec(J,s) +* Start-At( (card I + card
      J + 3),SCM+FSA) by Th20;
      hence IC IExec(if=0(a,I,J),s) =  (card I + card J + 3) by FUNCT_4:121
;
    end;
  end;
  hereby
    assume s.a = 0;
    then
A1: IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At( (card I + card J
    + 3),SCM+FSA) by Th20;
    hereby
      let d be Int-Location;
      not d in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:9;
      hence IExec(if=0(a,I,J),s).d = IExec(I,s).d by A1,FUNCT_4:12;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:10;
    hence IExec(if=0(a,I,J),s).f = IExec(I,s).f by A1,FUNCT_4:12;
  end;
  assume s.a <> 0;
  then
A2: IExec(if=0(a,I,J),s) = IExec(J,s) +* Start-At( (card I + card J +
  3),SCM+FSA) by Th20;
  hereby
    let d be Int-Location;
    not d in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:9;
    hence IExec(if=0(a,I,J),s).d = IExec(J,s).d by A2,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:10;
  hence thesis by A2,FUNCT_4:12;
end;

theorem Th22:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a > 0 & I is_closed_on s & I is_halting_on s
  holds if>0(a,I,J) is_closed_on s & if>0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = s +* (I1 +* Start-At( 0,SCM+FSA));
  set s3 = s +* (if>0(a,I,J) +* Start-At( 0,SCM+FSA));
  set s4 = Comput(ProgramPart( s3), s3,1);
  set i = a >0_goto  (card J + 3);
A1: not a in dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
A2:  0 in dom if>0(a,I,J) by Lm2;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA))
   by GRFUNC_1:8;
  then
A3: s3. 0 = (if>0(a,I,J) +* Start-At( 0,SCM+FSA)). 0
 by A2,FUNCT_4:14
    .= if>0(a,I,J). 0 by A2,SCMFSA6B:7
    .= i by Lm3;
  IC SCM+FSA in dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA)) by COMPOS_1:141;
  then
A4: IC s3 = IC(if>0(a,I,J) +* Start-At( 0,SCM+FSA))
 by FUNCT_4:14
    .=  0 by COMPOS_1:142;
A5: if>0(a,I,J) c= if>0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  if>0(a,I,J) +* Start-At( 0,SCM+FSA) c= s3 by FUNCT_4:26;
  then
A6: if>0(a,I,J) c= s3 by A5,XBOOLE_1:1;
A7: if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67;
  card (i ';' J ';' Goto  (card I + 1)) = card (Macro i ';' J ';'
  Goto  (card I + 1)) by SCMFSA6A:def 6
    .= card (Macro i ';' J) + card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by COMPOS_1:150
    .= card J + (2 + 1);
  then ProgramPart Relocated(I1,card J + 3) c= if>0(a,I,J) by A7,Lm1;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A6,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:99;
  then
A8: ProgramPart Relocated(I1,card J + 3) c= s4 by RELAT_1:209;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
A9: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A4,A3,Y;
A10: DataPart s1 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A11: now
    let f be FinSeq-Location;
    thus s1.f = s3.f by A10,SCMFSA6A:38
      .= s4.f by A9,SCMFSA_2:97;
  end;
  now
    let a be Int-Location;
    thus s1.a = s3.a by A10,SCMFSA6A:38
      .= s4.a by A9,SCMFSA_2:97;
  end;
  then
A12: DataPart s1 = DataPart s4 by A11,SCMFSA6A:38;
  assume s.a > 0;
  then s3.a > 0 by A1,FUNCT_4:12;
  then
A13: IC Comput(ProgramPart(s3),s3,1) =  (card J + 3) by A9,SCMFSA_2:97;
  assume
A14: I is_closed_on s;
  assume
A15: I is_halting_on s;
  then
A16: I1 is_closed_on s by A14,SCMFSA8A:46;
  I1 is_halting_on s by A14,A15,SCMFSA8A:46;
  then
A17: ProgramPart s1 halts_on s1 by SCMFSA7B:def 8;
  DataPart s = DataPart s1 by SCMFSA8A:11;
  then
A18: I1 is_closed_on s1 by A16,Th6;
A19: I1 +* Start-At( 0,SCM+FSA) c= s1 by FUNCT_4:26;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A20:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s1), s1,k1) as Element of NAT;
       m in dom I1 by A16,SCMFSA7B:def 7;
      then
A21:  m < card I1 by AFINSQ_1:70;
      card Stop SCM+FSA = 1 by COMPOS_1:46;
      then
A22:  card I1 = card I + 1 by SCMFSA6A:61;
      card if>0(a,I,J) = card I + card J + 4 by Th15
        .= card J + 3 + card I1 by A22;
      then
A23:  m + (card J + 3) < card if>0(a,I,J) by A21,XREAL_1:8;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A20,EXTPRO_1:5
        .=  (m + (card J + 3)) by A19,A18,A8,A13,A12,Th11,T;
      hence IC Comput(ProgramPart(s3),s3,k) in dom if>0(a,I,J) by A23,
AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s3),s3,k) in dom if>0(a,I,J) by A2,A4,
EXTPRO_1:3;
    end;
  end;
  hence if>0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s1)
,s1))
 by EXTPRO_1:5;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1))
   = CurInstr(ProgramPart s4,
   Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1))) by x,T
    .= IncAddr(CurInstr(ProgramPart s1,
    Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))),(card J + 3)) by
A19,A18,A8,A13,A12,Th11
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A17,EXTPRO_1:def 14
    .= halt SCM+FSA by SCMFSA_4:8;
  then ProgramPart s3 halts_on s3 by EXTPRO_1:30;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th23:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a > 0 & I is_closed_on
Initialized s & I is_halting_on Initialized s
holds IExec(if>0(a,I,J),s) = IExec(
  I,s) +* Start-At((card I+card J+3),SCM+FSA)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = s +* Initialized I1;
  set s3 = s +* Initialized if>0(a,I,J);
  set s4 = Comput(ProgramPart( s3), s3,1);
  set i = a >0_goto  (card J + 3);
A1: I1 +* Start-At( 0,SCM+FSA) c= s1 by FUNCT_4:26,SCMFSA6B:8;
A2: if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67;
A3:  0 in dom if>0(a,I,J) by Lm2;
  if>0(a,I,J) c= Initialized if>0(a,I,J) by SCMFSA6A:26;
  then dom if>0(a,I,J) c= dom Initialized if>0(a,I,J) by GRFUNC_1:8;
  then
A4: s3. 0 = (Initialized if>0(a,I,J)). 0 by A3,FUNCT_4:14
    .= if>0(a,I,J). 0 by A3,SCMFSA6A:50
    .= i by Lm3;
  IC SCM+FSA in dom Initialized if>0(a,I,J) by SCMFSA6A:24;
  then
A5: IC s3 = (Initialized if>0(a,I,J)).IC SCM+FSA by FUNCT_4:14
    .=  0 by SCMFSA6A:46;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
A6: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A5,A4,Y;
A7: if>0(a,I,J) c= Initialized if>0(a,I,J) by SCMFSA6A:26;
  Initialized if>0(a,I,J) c= s3 by FUNCT_4:26;
  then
A8: if>0(a,I,J) c= s3 by A7,XBOOLE_1:1;
A9: not a in dom Initialized if>0(a,I,J) by SCMFSA6A:48;
A10: dom ProgramPart s = A by COMPOS_1:34;
  assume s.a > 0;
  then s3.a > 0 by A9,FUNCT_4:12;
  then
A11: IC Comput(ProgramPart(s3),s3,1) =  (card J + 3) by A6,SCMFSA_2:97;
A12: DataPart s1 = DataPart s3 by SCMFSA6A:39,53;
A13: now
    let f be FinSeq-Location;
    thus s1.f = s3.f by A12,SCMFSA6A:38
      .= s4.f by A6,SCMFSA_2:97;
  end;
  now
    let a be Int-Location;
    thus s1.a = s3.a by A12,SCMFSA6A:38
      .= s4.a by A6,SCMFSA_2:97;
  end;
  then
A14: DataPart s1 = DataPart s4 by A13,SCMFSA6A:38;
  card (i ';' J ';' Goto  (card I + 1)) = card (Macro i ';' J ';'
  Goto  (card I + 1)) by SCMFSA6A:def 6
    .= card (Macro i ';' J) + card Goto  (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by COMPOS_1:150
    .= card J + (2 + 1);
  then ProgramPart Relocated(I1,card J + 3) c= if>0(a,I,J) by A2,Lm1;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A8,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:99;
  then
A15: ProgramPart Relocated(I1,card J + 3) c= s4 by RELAT_1:209;
  assume
A16: I is_closed_on Initialized s;
  assume
A17: I is_halting_on Initialized s;
  then
A18: ProgramPart s1 halts_on s1 by A16,SCMFSA8A:55;
  I1 is_closed_on Initialized s by A16,A17,SCMFSA8A:46;
  then
A19: I1 is_closed_on s1 by Th9;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s1)
,s1))
 by EXTPRO_1:5;
A20: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1))
 = CurInstr(ProgramPart s4,
 Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1)))
  by x,T
    .= IncAddr(CurInstr(ProgramPart s1,
    Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))),(card J + 3)) by
A1,A19,A15,A11,A14,Th11
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A18,EXTPRO_1:def 14
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A21: ProgramPart s3 halts_on s3 by EXTPRO_1:30;
  now
    let l be Element of NAT;
    assume
A22: l < LifeSpan(ProgramPart(s1),s1) + 1;
u: Comput(ProgramPart(s3),s3,0) = s3 by EXTPRO_1:3;
Z:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),
s3,1)
by AMI_1:123;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart(s3),Comput(ProgramPart(s3),s3,l))
       = CurInstr(ProgramPart s3,s3) by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) <>
       halt SCM+FSA by A5,A4,Z;
    end;
    suppose
      l <> 0;
      then consider n being Nat such that
A23:  l = n + 1 by NAT_1:6;
      assume
A24:  CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCM+FSA;
      reconsider n as Element of NAT by ORDINAL1:def 13;
x: Comput(ProgramPart(s3),s3,n+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),n) by EXTPRO_1:5;
      InsCode CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,n))
       = InsCode IncAddr(CurInstr(ProgramPart s1,
       Comput(ProgramPart(s1),s1,n)),(card J + 3))
        by SCMFSA_4:22
        .= InsCode CurInstr(ProgramPart s4,Comput(ProgramPart(s4),s4,n))
         by A1,A19,A15,A11,A14,Th11
        .= 0 by A23,A24,x,T,SCMFSA_2:124;
      then
A25:  CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,n))
 = halt SCM+FSA by SCMFSA_2:122;
      n < LifeSpan(ProgramPart(s1),s1) by A22,A23,XREAL_1:8;
      hence contradiction by A18,A25,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,l)) = halt SCM+FSA
  holds LifeSpan(ProgramPart(s1),s1) + 1 <= l;
  then
A26: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s1),s1) + 1 by A20,A21
,EXTPRO_1:def 14;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
 ProgramPart s1 halts_on s1 by A16,A17,SCMFSA8A:55;
  then
A27: DataPart Result(ProgramPart(s1),s1) = DataPart Comput(ProgramPart( s1), s1
,LifeSpan(ProgramPart(s1),s1)) by EXTPRO_1:23
    .= DataPart Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s1),s1)) by A1
,A19,A15,A11,A14,Th11,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s1),s1) + 1)
by EXTPRO_1:5
    .= DataPart Result(ProgramPart(s3),s3) by A21,A26,EXTPRO_1:23;
A28: now
    let x be set;
A29: x in dom (s | A) implies x is Element of NAT
by RELAT_1:86;
A30: dom Start-At((card I+card J+3),SCM+FSA)= {IC SCM+FSA}
 by FUNCOP_1:19;
A31: IExec(if>0(a,I,J),s) = (Result(ProgramPart(s3),s3)) +* (s | A) by
SCMFSA6B:def 1;
A32: IExec(I1,s) = Result(ProgramPart(s1),s1) +* s | A by SCMFSA6B:def 1;
    assume
A33: x in dom IExec(if>0(a,I,J),s);
    per cases by A33,SCMFSA6A:35;
    suppose
A34:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A35:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A30,TARSKI:def 1;
      thus IExec(if>0(a,I,J),s).x = (Result(ProgramPart(s3),s3)).x by A29,A31
,A34,FUNCT_4:12,SCMFSA_2:84
        .= (Result(ProgramPart(s1),s1)).x by A27,A34,SCMFSA6A:38
        .= IExec(I1,s).x by A29,A32,A34,FUNCT_4:12,SCMFSA_2:84
        .= (IExec(I1,s) +* Start-At((card I+card J+3),SCM+FSA)).x by A35,
FUNCT_4:12;
    end;
    suppose
A36:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A37:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A30,TARSKI:def 1;
      thus IExec(if>0(a,I,J),s).x = (Result(ProgramPart(s3),s3)).x by A29,A31
,A36,FUNCT_4:12,SCMFSA_2:85
        .= (Result(ProgramPart(s1),s1)).x by A27,A36,SCMFSA6A:38
        .= IExec(I1,s).x by A29,A32,A36,FUNCT_4:12,SCMFSA_2:85
        .= (IExec(I1,s) +* Start-At((card I+card J+3),SCM+FSA)).x by A37,
FUNCT_4:12;
    end;
    suppose
A38:  x = IC SCM+FSA;
      then
A39:  x in dom Start-At((card I+card J+3),SCM+FSA)by A30,TARSKI:def 1;
A40:  IC Result(ProgramPart(s1),s1) = IExec(I1,s).IC SCM+FSA by A29,A32,A38,
COMPOS_1:3,FUNCT_4:12
        .= IC (IExec(I,s) +* Start-At( card I,SCM+FSA))
         by A16,A17,SCMFSA8A:57
        .=  card I by FUNCT_4:121;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
X:    ProgramPart s1 halts_on s1 by A16,A17,SCMFSA8A:55;
      thus IExec(if>0(a,I,J),s).x = (Result(ProgramPart(s3),s3)).x by A29,A31
,A38,COMPOS_1:3,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s1),s1) + 1).x by
A21,A26,EXTPRO_1:23
        .= IC Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s1),s1)) by A38,
EXTPRO_1:5
        .= IC Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) + (card
J + 3) by A1,A19,A15,A11,A14,Th11,T
        .= IC Result(ProgramPart(s1),s1) + (card J + 3) by X,EXTPRO_1:23
        .= (Start-At((card I+(card J+3)),SCM+FSA)).IC SCM+FSA by A40,
FUNCOP_1:87
        .= (IExec(I1,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A38,A39,FUNCT_4:14;
    end;
    suppose
A41:  x is Element of NAT;
      then x <> IC SCM+FSA by COMPOS_1:3;
      then
A42:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A30,TARSKI:def 1;
A43:  x in NAT by A41;
      hence IExec(if>0(a,I,J),s).x = (s | A).x by A10,A31,FUNCT_4:14
        .= IExec(I1,s).x by A10,A32,A43,FUNCT_4:14
        .= (IExec(I1,s) +* Start-At((card I+card J+3),SCM+FSA)).x by A42,
FUNCT_4:12;
    end;
  end;
  dom IExec(if>0(a,I,J),s) = the carrier of SCM+FSA by PARTFUN1:def 4
    .= dom (IExec(I1,s) +* Start-At((card I+card J+3),SCM+FSA))
     by PARTFUN1:def 4;
  hence IExec(if>0(a,I,J),s) = IExec(I1,s) +* Start-At( (card I + card J
  + 3),SCM+FSA) by A28,FUNCT_1:9
    .= IExec(I,s) +* Start-At( card I,SCM+FSA) +*
     Start-At( (card I +
  card J + 3),SCM+FSA) by A16,A17,SCMFSA8A:57
    .= IExec(I,s) +* Start-At((card I+card J+3),SCM+FSA)by FUNCT_4:122;
end;

theorem Th24:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a <= 0 & J is_closed_on s & J is_halting_on
  s holds if>0(a,I,J) is_closed_on s & if>0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = s +* (JI2 +* Start-At( 0,SCM+FSA));
  set s3 = s +* (if>0(a,I,J) +* Start-At( 0,SCM+FSA));
  set s4 = Comput(ProgramPart( s3), s3,1);
  set s5 = Comput(ProgramPart(s3),s3,2);
  set i = a >0_goto  (card J + 3);
A1: JI2 +* Start-At( 0,SCM+FSA) c= s2 by FUNCT_4:26;
  IC SCM+FSA in dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA)) by COMPOS_1:141;
  then
A2: IC s3 = IC(if>0(a,I,J) +* Start-At( 0,SCM+FSA)) by FUNCT_4:14
    .=  0 by COMPOS_1:142;
A3: if>0(a,I,J) c= if>0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  if>0(a,I,J) +* Start-At( 0,SCM+FSA) c= s3 by FUNCT_4:26;
  then
A4: if>0(a,I,J) c= s3 by A3,XBOOLE_1:1;
A5: if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' JI2 by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:def 6;
  then ProgramPart Relocated(JI2,card Macro i) c= if>0(a,I,J) by Lm1;
  then ProgramPart Relocated(JI2,2) c= if>0(a,I,J) by COMPOS_1:150;
  then ProgramPart Relocated(JI2,2) c= s3 by A4,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(JI2,2) c= s5 by AMI_1:99;
  then
A6: ProgramPart Relocated(JI2,2) c= s5 by RELAT_1:209;
A7: not a in dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
A8:  0 in dom if>0(a,I,J) by Lm2;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A9: dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At( 0,SCM+FSA))
 by GRFUNC_1:8;
  then
A10: s3. 0 = (if>0(a,I,J) +* Start-At( 0,SCM+FSA)). 0
 by A8,FUNCT_4:14
    .= if>0(a,I,J). 0 by A8,SCMFSA6B:7
    .= i by Lm3;
A11:  1 in dom if>0(a,I,J) by Lm2;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
A12: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A2,A10,Y;
  assume s.a <= 0;
  then s3.a <= 0 by A7,FUNCT_4:12;
  then
A13: IC Comput(ProgramPart(s3),s3,1) = succ  0 by A2,A12,SCMFSA_2:97
    .=  (0 + 1);
A14: Comput(ProgramPart(s3),s3,1). 1 = s3. 1 by AMI_1:54
    .= (if>0(a,I,J) +* Start-At( 0,SCM+FSA)). 1
     by A9,A11,FUNCT_4:14
    .= if>0(a,I,J). 1 by A11,SCMFSA6B:7
    .= goto  2 by Lm3;
  assume
A15: J is_closed_on s;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A16: Comput(ProgramPart( s3), s3,1 + 1) = Following(ProgramPart s3,s4)
 by EXTPRO_1:4
    .= Exec(goto  2,s4) by A13,A14,Y,T;
A17: DataPart s2 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A18: now
    let f be FinSeq-Location;
    thus s2.f = s3.f by A17,SCMFSA6A:38
      .= Comput(ProgramPart(s3),s3,1).f by A12,SCMFSA_2:97
      .= s5.f by A16,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s2.a = s3.a by A17,SCMFSA6A:38
      .= Comput(ProgramPart(s3),s3,1).a by A12,SCMFSA_2:97
      .= s5.a by A16,SCMFSA_2:95;
  end;
  then
A19: DataPart s2 = DataPart s5 by A18,SCMFSA6A:38;
  assume
A20: J is_halting_on s;
  then
A21: JI2 is_closed_on s by A15,SCMFSA8A:58;
  then
A22: JI2 is_closed_on s2 by Th10;
A23: ProgramPart s2 halts_on s2 by A15,A20,SCMFSA8A:59;
A24: IC s5 =  2 by A16,SCMFSA_2:95;
  now
    let k be Element of NAT;
    k = 0 or 0 + 1 < k + 1 by XREAL_1:8;
    then
A25: k = 0 or 1 <= k by NAT_1:13;
    per cases by A25,XXREAL_0:1;
    suppose
A26:  1 < k;
      then consider k1 being Nat such that
A27:  k1 + 1 = k by NAT_1:6;
      0 + 1 < k1 + 1 by A26,A27;
      then consider k2 being Nat such that
A28:  k2 + 1 = k1 by NAT_1:6;
      reconsider k1,k2 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s2), s2,k2) as Element of NAT;
A29:  card if>0(a,I,J) = card Macro i + card JI2 by A5,SCMFSA6A:61
        .= 2 + card JI2 by COMPOS_1:150;
S: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
X: Comput(ProgramPart( s3), s4,1) = Comput(ProgramPart( s3), s3,1 + 1)
           by EXTPRO_1:5;
T: ProgramPart s4= ProgramPart Comput(ProgramPart( s4), s4,1)
by AMI_1:123;
       m in dom JI2 by A21,SCMFSA7B:def 7;
      then m < card JI2 by AFINSQ_1:70;
      then
A30:  m + 2 < card if>0(a,I,J) by A29,XREAL_1:8;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s4), s4,k1) by
A27,S,EXTPRO_1:5
        .= IC Comput(ProgramPart(s4 ), Comput(
ProgramPart( s4), s4,1),k2) by A28,EXTPRO_1:5
        .= IC Comput(ProgramPart( Comput(ProgramPart( s3), s3,1 + 1)), Comput(
ProgramPart( s3), s3,1 + 1),k2) by X,S,T
        .=  (m + 2) by A1,A22,A6,A24,A19,Th11;
      hence IC Comput(ProgramPart(s3),s3,k) in dom if>0(a,I,J) by A30,
AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s3),s3,k) in dom if>0(a,I,J) by A8,A2,
EXTPRO_1:3;
    end;
    suppose
      k = 1;
      hence IC Comput(ProgramPart(s3),s3,k) in dom if>0(a,I,J) by A13,Lm2;
    end;
  end;
  hence if>0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,2)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+2)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,2),LifeSpan(ProgramPart(s2)
,s2))
 by EXTPRO_1:5;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+2))
   = CurInstr(ProgramPart s5,
   Comput(ProgramPart(s5),s5,LifeSpan(ProgramPart(s2),s2))) by x,T
    .= IncAddr(CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))),2) by A1,A22,A6
,A24,A19,Th11
    .= IncAddr(halt SCM+FSA,2) by A23,EXTPRO_1:def 14
    .= halt SCM+FSA by SCMFSA_4:8;
  then ProgramPart s3 halts_on s3 by EXTPRO_1:30;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th25:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <= 0 & J is_closed_on
Initialized s & J is_halting_on Initialized s
holds IExec(if>0(a,I,J),s) = IExec(
  J,s) +* Start-At((card I+card J+3),SCM+FSA)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = s +* Initialized JI2;
  set s3 = s +* Initialized if>0(a,I,J);
  set s4 = Comput(ProgramPart( s3), s3,1);
  set s5 = Comput(ProgramPart(s3),s3,2);
  set i = a >0_goto  (card J + 3);
A1: JI2 +* Start-At( 0,SCM+FSA) c= s2 by FUNCT_4:26,SCMFSA6B:8;
  if>0(a,I,J) c= Initialized if>0(a,I,J) by SCMFSA6A:26;
  then
A2: dom if>0(a,I,J) c= dom Initialized if>0(a,I,J) by GRFUNC_1:8;
A3:  0 in dom if>0(a,I,J) by Lm2;
  then
A4: s3. 0 = (Initialized if>0(a,I,J)). 0 by A2,FUNCT_4:14
    .= if>0(a,I,J). 0 by A3,SCMFSA6A:50
    .= i by Lm3;
A5: if>0(a,I,J) c= Initialized if>0(a,I,J) by SCMFSA6A:26;
A6:  1 in dom if>0(a,I,J) by Lm2;
A7: Comput(ProgramPart(s3),s3,1). 1 = s3. 1 by AMI_1:54
    .= (Initialized if>0(a,I,J)). 1 by A2,A6,FUNCT_4:14
    .= if>0(a,I,J). 1 by A6,SCMFSA6A:50
    .= goto  2 by Lm3;
  IC SCM+FSA in dom Initialized if>0(a,I,J) by SCMFSA6A:24;
  then
A8: IC s3 = (Initialized if>0(a,I,J)).IC SCM+FSA by FUNCT_4:14
    .=  0 by SCMFSA6A:46;
  if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto  (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' JI2 by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:def 6;
  then ProgramPart Relocated(JI2,card Macro i) c= if>0(a,I,J) by Lm1;
  then
A9: ProgramPart Relocated(JI2,2) c= if>0(a,I,J) by COMPOS_1:150;
A10: not a in dom Initialized if>0(a,I,J) by SCMFSA6A:48;
A11: dom (s | A) = dom s /\ A by RELAT_1:90
    .= (D \/ {IC SCM+FSA} \/ A) /\ A by SCMFSA6A:34
    .= A by XBOOLE_1:21;
  Initialized if>0(a,I,J) c= s3 by FUNCT_4:26;
  then if>0(a,I,J) c= s3 by A5,XBOOLE_1:1;
  then ProgramPart Relocated(JI2,2) c= s3 by A9,XBOOLE_1:1;
  then ProgramPart ProgramPart Relocated(JI2,2) c= s5 by AMI_1:99;
  then
A12: ProgramPart Relocated(JI2,2) c= s5 by RELAT_1:209;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
A13: Comput(ProgramPart( s3), s3,0 + 1) =
Following(ProgramPart s3,Comput(ProgramPart(s3),s3,0)
)
 by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A8,A4,Y;
  assume s.a <= 0;
  then s3.a <= 0 by A10,FUNCT_4:12;
  then
A14: IC Comput(ProgramPart(s3),s3,1) = succ  0 by A8,A13,SCMFSA_2:97
    .=  (0 + 1);
  assume
A15: J is_closed_on Initialized s;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A16: Comput(ProgramPart( s3), s3,1 + 1) = Following(ProgramPart s3,s4) by
EXTPRO_1:4
    .= Exec(goto  2,s4) by A14,A7,Y,T;
  then
A17: IC s5 =  2 by SCMFSA_2:95;
A18: DataPart s2 = DataPart s3 by SCMFSA6A:39,53;
A19: now
    let f be FinSeq-Location;
    thus s2.f = s3.f by A18,SCMFSA6A:38
      .= Comput(ProgramPart(s3),s3,1).f by A13,SCMFSA_2:97
      .= s5.f by A16,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s2.a = s3.a by A18,SCMFSA6A:38
      .= Comput(ProgramPart(s3),s3,1).a by A13,SCMFSA_2:97
      .= s5.a by A16,SCMFSA_2:95;
  end;
  then
A20: DataPart s2 = DataPart s5 by A19,SCMFSA6A:38;
  assume
A21: J is_halting_on Initialized s;
  then
A22: ProgramPart s2 halts_on s2 by A15,SCMFSA8A:60;
  JI2 is_closed_on Initialized s by A15,A21,SCMFSA8A:58;
  then
A23: JI2 is_closed_on s2 by Th9;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,2)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+2)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,2),LifeSpan(ProgramPart(s2)
,s2))
 by EXTPRO_1:5;
A24: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+2))
 = CurInstr(ProgramPart s5,
 Comput(ProgramPart(s5),s5,LifeSpan(ProgramPart(s2),s2))) by x,T
    .= IncAddr(CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))),2)
     by A1,A23,A12,A17,A20,Th11
    .= IncAddr(halt SCM+FSA,2) by A22,EXTPRO_1:def 14
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A25: ProgramPart s3 halts_on s3 by EXTPRO_1:30;
  now
    let l be Element of NAT;
    assume
A26: l < LifeSpan(ProgramPart(s2),s2) + 2;
u: Comput(ProgramPart(s3),s3,0) = s3 by EXTPRO_1:3;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s3),s3,l))/.IC Comput(ProgramPart(s3),s3,l)
 = Comput(ProgramPart(s3),s3,l).IC Comput(ProgramPart(s3),s3,l) by COMPOS_1:38;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart s3,s3,1+1)
by AMI_1:123;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,l)
by AMI_1:123;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart s3,Comput(ProgramPart (s3),s3,l))
       = CurInstr(ProgramPart s3,s3) by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) <>
       halt SCM+FSA by A8,A4,Y;
    end;
    suppose
      l = 1;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) <>
       halt SCM+FSA by A14,A7,Z,TX3;
    end;
    suppose
A27:  l <> 0 & l <> 1;
      assume
A28:  CurInstr(ProgramPart s3,Comput(ProgramPart(s3),
s3,l)) = halt SCM+FSA;
      consider n being Nat such that
A29:  l = n + 1 by A27,NAT_1:6;
      n <> 0 by A27,A29;
      then consider l2 being Nat such that
A30:  n = l2 + 1 by NAT_1:6;
      reconsider l2 as Element of NAT by ORDINAL1:def 13;
x: Comput(ProgramPart(s3),s3,l2+(1+1))
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1+1),l2) by EXTPRO_1:5;
      InsCode CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,l2))
       = InsCode IncAddr(CurInstr(ProgramPart s2,
       Comput(ProgramPart(s2),s2,l2)),2) by SCMFSA_4:22
        .= InsCode CurInstr(ProgramPart (s5),Comput(ProgramPart(s5),s5,l2))
         by A1,A23,A12,A17,A20,Th11
        .= InsCode CurInstr(ProgramPart s3,Comput(ProgramPart s3,s3,l2+(1+1)))
         by x,T
        .= 0 by A29,A30,A28,SCMFSA_2:124;
      then
A31:  CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,l2))
 = halt SCM+FSA by SCMFSA_2:122;
      n + 1 < LifeSpan(ProgramPart(s2),s2) + 1 + 1 by A26,A29;
      then n < LifeSpan(ProgramPart(s2),s2) + 1 by XREAL_1:8;
      then l2 < LifeSpan(ProgramPart(s2),s2) by A30,XREAL_1:8;
      hence contradiction by A22,A31,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,l)) = halt SCM+FSA
  holds LifeSpan(ProgramPart(s2),s2) + 2 <= l;
  then
A32: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s2),s2) + 2 by A24,A25
,EXTPRO_1:def 14;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:123;
A33: DataPart Result(ProgramPart(s2),s2) = DataPart Comput(ProgramPart( s2), s2
,LifeSpan(ProgramPart(s2),s2)) by A22,EXTPRO_1:23
    .= DataPart Comput(ProgramPart( s3), s5,LifeSpan(ProgramPart(s2),s2)) by A1
,A23,A12,A17,A20,Th11,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 2)
by EXTPRO_1:5
    .= DataPart Result(ProgramPart(s3),s3) by A25,A32,EXTPRO_1:23;
A34: now
    let x be set;
A35: x in dom (s | A) implies x is Element of NAT
by RELAT_1:86;
A36: dom Start-At((card I+card J+3),SCM+FSA)= {IC SCM+FSA}
 by FUNCOP_1:19;
A37: IExec(if>0(a,I,J),s) = (Result(ProgramPart(s3),s3)) +* (s | A) by
SCMFSA6B:def 1;
A38: IExec(JI2,s) = Result(ProgramPart(s2),s2) +* s | A by SCMFSA6B:def 1;
    assume
A39: x in dom IExec(if>0(a,I,J),s);
    per cases by A39,SCMFSA6A:35;
    suppose
A40:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A41:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A36,TARSKI:def 1;
      thus IExec(if>0(a,I,J),s).x = (Result(ProgramPart(s3),s3)).x by A35,A37
,A40,FUNCT_4:12,SCMFSA_2:84
        .= (Result(ProgramPart(s2),s2)).x by A33,A40,SCMFSA6A:38
        .= IExec(JI2,s).x by A35,A38,A40,FUNCT_4:12,SCMFSA_2:84
        .= (IExec(JI2,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A41,FUNCT_4:12;
    end;
    suppose
A42:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A43:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A36,TARSKI:def 1;
      thus IExec(if>0(a,I,J),s).x = (Result(ProgramPart(s3),s3)).x by A35,A37
,A42,FUNCT_4:12,SCMFSA_2:85
        .= (Result(ProgramPart(s2),s2)).x by A33,A42,SCMFSA6A:38
        .= IExec(JI2,s).x by A35,A38,A42,FUNCT_4:12,SCMFSA_2:85
        .= (IExec(JI2,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A43,FUNCT_4:12;
    end;
    suppose
A44:  x = IC SCM+FSA;
      then
A45:  x in dom Start-At((card I+card J+3),SCM+FSA)by A36,TARSKI:def 1;
T: ProgramPart s3 = ProgramPart s5
by AMI_1:123;
A46:  IC Result(ProgramPart(s2),s2) = IC IExec(JI2,s) by A35,A38,A44,COMPOS_1:3
,FUNCT_4:12
        .=  (card I + card J + 1) by A15,A21,SCMFSA8A:61;
      thus IExec(if>0(a,I,J),s).x = (Result(ProgramPart(s3),s3)).x by A35,A37
,A44,COMPOS_1:3,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 2).x by
A25,A32,EXTPRO_1:23
        .= IC Comput(ProgramPart( s3), s5,LifeSpan(ProgramPart(s2),s2)) by A44,
EXTPRO_1:5
        .= IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s2),s2)) + 2 by
A1,A23,A12,A17,A20,Th11,T
        .= IC Result(ProgramPart(s2),s2) + 2 by A22,EXTPRO_1:23
        .= (Start-At ( (card I + card J + 1) + 2,SCM+FSA)).IC SCM+FSA
         by A46,FUNCOP_1:87
        .= (IExec(JI2,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A44,A45,FUNCT_4:14;
    end;
    suppose
A47:  x is Element of NAT;
      then x <> IC SCM+FSA by COMPOS_1:3;
      then
A48:  not x in dom Start-At((card I+card J+3),SCM+FSA)
by A36,TARSKI:def 1;
A49:  x in NAT by A47;
      hence IExec(if>0(a,I,J),s).x = (s | A).x by A11,A37,FUNCT_4:14
        .= IExec(JI2,s).x by A11,A38,A49,FUNCT_4:14
        .= (IExec(JI2,s) +* Start-At((card I+card J+3),SCM+FSA)).x
         by A48,FUNCT_4:12;
    end;
  end;
  dom IExec(if>0(a,I,J),s) = the carrier of SCM+FSA by PARTFUN1:def 4
    .= dom (IExec(JI2,s) +* Start-At((card I+card J+3),SCM+FSA))
     by PARTFUN1:def 4;
  hence
  IExec(if>0(a,I,J),s) = IExec(JI2,s) +* Start-At( (card I + card J
  + 3),SCM+FSA) by A34,FUNCT_1:9
    .= IExec(J,s) +* Start-At( (card I + card J + 1),SCM+FSA)
     +* Start-At(
   (card I + card J + 3),SCM+FSA) by A15,A21,SCMFSA8A:62
    .= IExec(J,s) +* Start-At((card I+card J+3),SCM+FSA)by FUNCT_4:122;
end;

theorem Th26:
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds if>0(a,I,J) is parahalting & (s.
  a > 0 implies IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At( (card I +
card J + 3),SCM+FSA)) & (s.a <= 0 implies IExec(if>0(a,I,J),s) =
 IExec(J,s) +* Start-At(
   (card I + card J + 3),SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
A1: I is_halting_on Initialized s by SCMFSA7B:25;
  now
    let s be State of SCM+FSA;
A2: I is_closed_on s by SCMFSA7B:24;
A3: I is_halting_on s by SCMFSA7B:25;
A4: J is_halting_on s by SCMFSA7B:25;
A5: J is_closed_on s by SCMFSA7B:24;
    assume if>0(a,I,J) +* Start-At( 0,SCM+FSA) c= s;
    then
A6: s = s +* (if>0(a,I,J) +* Start-At( 0,SCM+FSA)) by FUNCT_4:79;
    per cases;
    suppose
      s.a > 0;
      then if>0(a,I,J) is_halting_on s by A2,A3,Th22;
      hence ProgramPart s halts_on s by A6,SCMFSA7B:def 8;
    end;
    suppose
      s.a <= 0;
      then if>0(a,I,J) is_halting_on s by A5,A4,Th24;
      hence ProgramPart s halts_on s by A6,SCMFSA7B:def 8;
    end;
  end;
  then if>0(a,I,J) +* Start-At( 0,SCM+FSA) is halting by EXTPRO_1:def 10;
  hence if>0(a,I,J) is parahalting by SCMFSA6B:def 3;
  I is_closed_on Initialized s by SCMFSA7B:24;
  hence s.a > 0 implies IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At( (
  card I + card J + 3),SCM+FSA) by A1,Th23;
A7: J is_halting_on Initialized s by SCMFSA7B:25;
  J is_closed_on Initialized s by SCMFSA7B:24;
  hence thesis by A7,Th25;
end;

theorem Th27:
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds IC IExec(if>0(a,I,J),s) =
(card I + card J + 3) & (s.a > 0 implies ((for d being Int-Location holds IExec
  (if>0(a,I,J),s).d = IExec(I,s).d) & for f being FinSeq-Location holds IExec(
  if>0(a,I,J),s).f = IExec(I,s).f)) & (s.a <= 0 implies ((for d being
  Int-Location holds IExec(if>0(a,I,J),s).d = IExec(J,s).d) & for f being
  FinSeq-Location holds IExec(if>0(a,I,J),s).f = IExec(J,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby
    per cases;
    suppose
      s.a > 0;
      then
      IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At( (card I + card
      J + 3),SCM+FSA) by Th26;
      hence IC IExec(if>0(a,I,J),s) =  (card I + card J + 3) by FUNCT_4:121;
    end;
    suppose
      s.a <= 0;
      then
      IExec(if>0(a,I,J),s) = IExec(J,s) +* Start-At( (card I + card
      J + 3),SCM+FSA) by Th26;
      hence IC IExec(if>0(a,I,J),s) =  (card I + card J + 3) by FUNCT_4:121;
    end;
  end;
  hereby
    assume s.a > 0;
    then
A1: IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At( (card I + card J
    + 3),SCM+FSA) by Th26;
    hereby
      let d be Int-Location;
      not d in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:9;
      hence IExec(if>0(a,I,J),s).d = IExec(I,s).d by A1,FUNCT_4:12;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:10;
    hence IExec(if>0(a,I,J),s).f = IExec(I,s).f by A1,FUNCT_4:12;
  end;
  assume s.a <= 0;
  then
A2: IExec(if>0(a,I,J),s) = IExec(J,s) +* Start-At( (card I + card J +
  3),SCM+FSA) by Th26;
  hereby
    let d be Int-Location;
    not d in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:9;
    hence IExec(if>0(a,I,J),s).d = IExec(J,s).d by A2,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At((card I+card J+3),SCM+FSA)by SCMFSA6B:10;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
read-write Int-Location st s.a < 0 & I is_closed_on s & I is_halting_on s holds
  if<0(a,I,J) is_closed_on s & if<0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a < 0;
  assume that
A2: I is_closed_on s and
A3: I is_halting_on s;
A4: if>0(a,J,I) is_halting_on s by A1,A2,A3,Th24;
  if>0(a,J,I) is_closed_on s by A1,A2,A3,Th24;
  hence thesis by A1,A4,Th18;
end;

theorem Th29:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a < 0 & I is_closed_on Initialized s & I
is_halting_on Initialized s
holds IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At(
   (card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a < 0;
  assume that
A2: I is_closed_on Initialized s and
A3: I is_halting_on Initialized s;
A4: (Initialized s).a <= 0 by A1,SCMFSA6C:3;
  then
A5: if>0(a,J,I) is_halting_on Initialized s by A2,A3,Th24;
  if>0(a,J,I) is_closed_on Initialized s by A2,A3,A4,Th24;
  hence IExec(if<0(a,I,J),s) = IExec(if>0(a,J,I),s) +* Start-At( (card
  if>0(a,J,I) + card J + 3),SCM+FSA) by A1,A5,Th19
    .= IExec(if>0(a,J,I),s) +* Start-At( (card I + card J + 4 + card J
  + 3),SCM+FSA) by Th15
    .= IExec(I,s) +* Start-At((card I+card J+3),SCM+FSA)+* Start-At(
   (card I + card J + 4 + card J + 3),SCM+FSA) by A1,A2,A3,Th25
    .= IExec(I,s) +* Start-At( (card I + card J + card J + 7),SCM+FSA) by
FUNCT_4:122;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
read-write Int-Location st s.a = 0 & J is_closed_on s & J is_halting_on s holds
  if<0(a,I,J) is_closed_on s & if<0(a,I,J) is_halting_on s by Th16;

theorem Th31:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & J is_closed_on Initialized s & J
is_halting_on Initialized s
holds IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At(
   (card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  assume that
A2: J is_closed_on Initialized s and
A3: J is_halting_on Initialized s;
  thus IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At( (card if>0(a,J,I)
  + card J + 3),SCM+FSA) by A1,A2,A3,Th17
    .= IExec(J,s) +* Start-At( (card I + card J + 4 +
     card J + 3),SCM+FSA) by Th15
    .= IExec(J,s) +* Start-At( (card I + card J + card J + 7),SCM+FSA);
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
read-write Int-Location st s.a > 0 & J is_closed_on s & J is_halting_on s holds
  if<0(a,I,J) is_closed_on s & if<0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  assume that
A2: J is_closed_on s and
A3: J is_halting_on s;
A4: if>0(a,J,I) is_halting_on s by A1,A2,A3,Th22;
  if>0(a,J,I) is_closed_on s by A1,A2,A3,Th22;
  hence thesis by A1,A4,Th18;
end;

theorem Th33:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & J is_closed_on Initialized s & J
is_halting_on Initialized s
holds IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At(
   (card I + card J + card J + 7),SCM+FSA)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  assume that
A2: J is_closed_on Initialized s and
A3: J is_halting_on Initialized s;
A4: (Initialized s).a > 0 by A1,SCMFSA6C:3;
  then
A5: if>0(a,J,I) is_halting_on Initialized s by A2,A3,Th22;
  if>0(a,J,I) is_closed_on Initialized s by A2,A3,A4,Th22;
  hence IExec(if<0(a,I,J),s) = IExec(if>0(a,J,I),s) +* Start-At( (card
  if>0(a,J,I) + card J + 3),SCM+FSA) by A1,A5,Th19
    .= IExec(if>0(a,J,I),s) +* Start-At( (card I + card J + 4 + card J
  + 3),SCM+FSA) by Th15
    .= IExec(J,s) +* Start-At((card I+card J+3),SCM+FSA)+* Start-At(
   (card I + card J + 4 + card J + 3),SCM+FSA) by A1,A2,A3,Th23
    .= IExec(J,s) +* Start-At( (card I + card J + card J + 7),SCM+FSA) by
FUNCT_4:122;
end;

theorem
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA
  , a being read-write Int-Location holds if<0(a,I,J) is parahalting & (s.a < 0
implies IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At( (card I + card J +
card J + 7),SCM+FSA)) & (s.a >= 0 implies IExec(if<0(a,I,J),s) =
 IExec(J,s) +* Start-At((card I + card J + card J + 7),SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  if>0(a,J,I) is parahalting by Th26;
  hence if<0(a,I,J) is parahalting by Th20;
  hereby
A1: I is_halting_on Initialized s by SCMFSA7B:25;
A2: I is_closed_on Initialized s by SCMFSA7B:24;
    assume s.a < 0;
    hence
    IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At( (card I + card J
    + card J + 7),SCM+FSA) by A2,A1,Th29;
  end;
  hereby
    assume
A3: s.a >= 0;
A4: J is_closed_on Initialized s by SCMFSA7B:24;
A5: J is_halting_on Initialized s by SCMFSA7B:25;
    per cases;
    suppose
      s.a = 0;
      hence
      IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At( (card I + card
      J + card J + 7),SCM+FSA) by A4,A5,Th31;
    end;
    suppose
      s.a <> 0;
      hence
      IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At( (card I + card
      J + card J + 7),SCM+FSA) by A3,A4,A5,Th33;
    end;
  end;
end;

registration
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  cluster if=0(a,I,J) -> parahalting;
  correctness by Th20;
  cluster if>0(a,I,J) -> parahalting;
  correctness by Th26;
end;

definition
  let a,b be Int-Location;
  let I,J be Program of SCM+FSA;
  func if=0(a,b,I,J) -> Program of SCM+FSA equals
  SubFrom(a,b) ';' if=0(a,I,J);
  coherence;
  func if>0(a,b,I,J) -> Program of SCM+FSA equals
  SubFrom(a,b) ';' if>0(a,I,J);
  coherence;
end;

registration
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
 cluster if=0(a,I,J) -> non halt-free;
 coherence;
 cluster  if>0(a,I,J) -> non halt-free;
 coherence;
 cluster if<0(a,I,J) -> non halt-free;
 coherence;
end;

registration
  let a,b be Int-Location;
  let I,J be Program of SCM+FSA;
 cluster if=0(a,b,I,J) -> non halt-free;
 coherence
  proof
    Macro SubFrom(a,b) ';' if=0(a,I,J) is non halt-free;
   hence thesis by SCMFSA6A:def 6;
  end;
 cluster if>0(a,b,I,J) -> non halt-free;
 coherence
  proof
    Macro SubFrom(a,b) ';' if>0(a,I,J) is non halt-free;
   hence thesis by SCMFSA6A:def 6;
  end;
end;

notation
  let a,b be Int-Location;
  let I,J be Program of SCM+FSA;
  synonym if<0(b,a,I,J) for if>0(a,b,I,J);
end;

registration
  let I,J be parahalting Program of SCM+FSA;
  let a,b be read-write Int-Location;
  cluster if=0(a,b,I,J) -> parahalting;
  correctness;
  cluster if>0(a,b,I,J) -> parahalting;
  correctness;
end;

theorem Th35:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  DataPart Result(ProgramPart(s +* Initialized I),s +* Initialized I) =
DataPart IExec(I,s)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
A1: IExec(I,s) = Result(ProgramPart(s1),s1) +* s | A by SCMFSA6B:def 1;
A2: now
    let f be FinSeq-Location;
     f in dom (s | A) implies f is Element of NAT
     by RELAT_1:86;
    hence IExec(I,s).f = (Result(ProgramPart(s1),s1)).f by A1,FUNCT_4:12
,SCMFSA_2:85;
  end;
  now
    let b be Int-Location;
     b in dom (s | A) implies b is Element of NAT
     by RELAT_1:86;
    hence IExec(I,s).b = (Result(ProgramPart(s1),s1)).b by A1,FUNCT_4:12
,SCMFSA_2:84;
  end;
  hence thesis by A2,SCMFSA6A:38;
end;

theorem Th36:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
  being Int-Location holds Result(ProgramPart(s +* Initialized I),s +*
Initialized I),IExec(I,s) equal_outside
  NAT
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  set s1 = s +* Initialized I;
A1: IC Result(ProgramPart(s1),s1) = IC IExec(I,s) by SCMFSA8A:7;
A2: DataPart Result(ProgramPart(s1),s1) = DataPart IExec(I,s) by Th35;
  then
A3: for f being FinSeq-Location holds (Result(ProgramPart(s1),s1)).f = IExec(I,
s).f by SCMFSA6A:38;
  for a being Int-Location holds (Result(ProgramPart(s1),s1)).a = IExec(I,s).a
by A2,SCMFSA6A:38
;
  hence thesis by A3,A1,SCMFSA10:91;
end;

theorem Th37:
  for s1,s2 being State of SCM+FSA, i being Instruction of SCM+FSA
  , a being Int-Location holds (for b being Int-Location st a <> b holds s1.b =
s2.b) & (for f being FinSeq-Location holds s1.f = s2.f) & i does not refer a &
IC s1 = IC s2 implies (for b being Int-Location st a <> b holds Exec(i,s1).b =
Exec(i,s2).b) & (for f being FinSeq-Location holds Exec(i,s1).f = Exec(i,s2).f)
  & IC Exec(i,s1) = IC Exec(i,s2)
proof
  let s1,s2 be State of SCM+FSA;
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  defpred S[State of SCM+FSA,State of SCM+FSA] means (for b being Int-Location
  st a <> b holds $1.b = $2.b) & for f being FinSeq-Location holds $1.f = $2.f;
  assume
A1: S[s1,s2];
A2: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
A3: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
  assume
A4: i does not refer a;
A5: InsCode i <= 11+1 by SCMFSA_2:35;
A6: now
    let b be Int-Location;
    assume
A7: a <> b;
    per cases by A5,A3,A2,NAT_1:8,33;
    suppose
      InsCode i = 0;
      then
A8:   i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s1).b = s1.b by EXTPRO_1:def 3
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A8,EXTPRO_1:def 3;
    end;
    suppose
      InsCode i = 1;
      then consider da, db being Int-Location such that
A9:   i = da := db by SCMFSA_2:54;
A10:  a <> db by A4,A9,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A11:      b = da;
          hence Exec(i,s1).b = s1.db by A9,SCMFSA_2:89
            .= s2.db by A1,A10
            .= Exec(i,s2).b by A9,A11,SCMFSA_2:89;
        end;
        suppose
A12:      b <> da;
          hence Exec(i,s1).b = s1.b by A9,SCMFSA_2:89
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A9,A12,SCMFSA_2:89;
        end;
      end;
    end;
    suppose
      InsCode i = 2;
      then consider da, db being Int-Location such that
A13:  i = AddTo(da,db) by SCMFSA_2:55;
A14:  a <> db by A4,A13,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A15:      b = da;
          hence Exec(i,s1).b = s1.b + s1.db by A13,SCMFSA_2:90
            .= s2.b + s1.db by A1,A7
            .= s2.b + s2.db by A1,A14
            .= Exec(i,s2).b by A13,A15,SCMFSA_2:90;
        end;
        suppose
A16:      b <> da;
          hence Exec(i,s1).b = s1.b by A13,SCMFSA_2:90
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A13,A16,SCMFSA_2:90;
        end;
      end;
    end;
    suppose
      InsCode i = 3;
      then consider da, db being Int-Location such that
A17:  i = SubFrom(da, db) by SCMFSA_2:56;
A18:  a <> db by A4,A17,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A19:      b = da;
          hence Exec(i,s1).b = s1.b - s1.db by A17,SCMFSA_2:91
            .= s2.b - s1.db by A1,A7
            .= s2.b - s2.db by A1,A18
            .= Exec(i,s2).b by A17,A19,SCMFSA_2:91;
        end;
        suppose
A20:      b <> da;
          hence Exec(i,s1).b = s1.b by A17,SCMFSA_2:91
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A17,A20,SCMFSA_2:91;
        end;
      end;
    end;
    suppose
      InsCode i = 4;
      then consider da, db being Int-Location such that
A21:  i = MultBy(da,db) by SCMFSA_2:57;
A22:  a <> db by A4,A21,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A23:      b = da;
          hence Exec(i,s1).b = s1.b * s1.db by A21,SCMFSA_2:92
            .= s2.b * s1.db by A1,A7
            .= s2.b * s2.db by A1,A22
            .= Exec(i,s2).b by A21,A23,SCMFSA_2:92;
        end;
        suppose
A24:      b <> da;
          hence Exec(i,s1).b = s1.b by A21,SCMFSA_2:92
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A21,A24,SCMFSA_2:92;
        end;
      end;
    end;
    suppose
      InsCode i = 5;
      then consider da, db being Int-Location such that
A25:  i = Divide(da, db) by SCMFSA_2:58;
A26:  a <> db by A4,A25,SCMFSA7B:def 1;
A27:  a <> da by A4,A25,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A28:      b = db;
          hence Exec(i,s1).b = s1.da mod s1.db by A25,SCMFSA_2:93
            .= s2.da mod s1.db by A1,A27
            .= s2.da mod s2.db by A1,A26
            .= Exec(i,s2).b by A25,A28,SCMFSA_2:93;
        end;
        suppose
A29:      b = da & b <> db;
          hence Exec(i,s1).b = s1.da div s1.db by A25,SCMFSA_2:93
            .= s1.da div s2.db by A1,A26
            .= s2.da div s2.db by A1,A27
            .= Exec(i,s2).b by A25,A29,SCMFSA_2:93;
        end;
        suppose
A30:      b <> da & b <> db;
          hence Exec(i,s1).b = s1.b by A25,SCMFSA_2:93
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A25,A30,SCMFSA_2:93;
        end;
      end;
    end;
    suppose
      InsCode i = 6;
      then
A31:  ex loc being Element of NAT st i = goto loc by SCMFSA_2:59;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:95
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A31,SCMFSA_2:95;
    end;
    suppose
      InsCode i = 7;
      then
A32:  ex loc being Element of NAT, da being Int-Location
      st i = da =0_goto loc by SCMFSA_2:60;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:96
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A32,SCMFSA_2:96;
    end;
    suppose
      InsCode i = 8;
      then
A33:  ex loc being Element of NAT, da being Int-Location
      st i = da >0_goto loc by SCMFSA_2:61;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:97
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A33,SCMFSA_2:97;
    end;
    suppose
      InsCode i = 9;
      then consider
      db, da being Int-Location, g being FinSeq-Location such that
A34:  i = da := (g,db) by SCMFSA_2:62;
A35:  a <> db by A4,A34,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A36:      b = da;
          then consider m2 being Element of NAT such that
A37:      m2 = abs(s2.db) and
A38:      Exec(da:=(g,db), s2).b = (s2.g)/.m2 by SCMFSA_2:98;
          consider m1 being Element of NAT such that
A39:      m1 = abs(s1.db) and
A40:      Exec(da:=(g,db), s1).b = (s1.g)/.m1 by A36,SCMFSA_2:98;
          m1 = m2 by A1,A35,A39,A37;
          hence Exec(i,s1).b = Exec(i,s2).b by A1,A34,A40,A38;
        end;
        suppose
A41:      b <> da;
          hence Exec(i,s1).b = s1.b by A34,SCMFSA_2:98
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A34,A41,SCMFSA_2:98;
        end;
      end;
    end;
    suppose
      InsCode i = 10;
      then
A42:  ex db, da being Int-Location, g being FinSeq-Location st i = (g,db
      ):= da by SCMFSA_2:63;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:99
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A42,SCMFSA_2:99;
    end;
    suppose
      InsCode i = 11;
      then consider da being Int-Location, g being FinSeq-Location such that
A43:  i = da :=len g by SCMFSA_2:64;
      hereby
        per cases;
        suppose
A44:      b = da;
          hence Exec(i,s1).b = len (s1.g) by A43,SCMFSA_2:100
            .= len (s2.g) by A1
            .= Exec(i,s2).b by A43,A44,SCMFSA_2:100;
        end;
        suppose
A45:      b <> da;
          hence Exec(i,s1).b = s1.b by A43,SCMFSA_2:100
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A43,A45,SCMFSA_2:100;
        end;
      end;
    end;
    suppose
      InsCode i = 12;
      then
A46:  ex da being Int-Location, g being FinSeq-Location st i = g
      :=<0,...,0>da by SCMFSA_2:65;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:101
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A46,SCMFSA_2:101;
    end;
  end;
  assume
A47: IC s1 = IC s2;
  now
    let f be FinSeq-Location;
    per cases by A5,A3,A2,NAT_1:8,33;
    suppose
      InsCode i = 0;
      then
A48:  i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s1).f = s1.f by EXTPRO_1:def 3
        .= s2.f by A1
        .= Exec(i,s2).f by A48,EXTPRO_1:def 3;
    end;
    suppose
      InsCode i = 1;
      then
A49:  ex da, db being Int-Location st i = da := db by SCMFSA_2:54;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:89
        .= s2.f by A1
        .= Exec(i,s2).f by A49,SCMFSA_2:89;
    end;
    suppose
      InsCode i = 2;
      then
A50:  ex da, db being Int-Location st i = AddTo(da,db) by SCMFSA_2:55;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:90
        .= s2.f by A1
        .= Exec(i,s2).f by A50,SCMFSA_2:90;
    end;
    suppose
      InsCode i = 3;
      then
A51:  ex da, db being Int-Location st i = SubFrom(da, db) by SCMFSA_2:56;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:91
        .= s2.f by A1
        .= Exec(i,s2).f by A51,SCMFSA_2:91;
    end;
    suppose
      InsCode i = 4;
      then
A52:  ex da, db being Int-Location st i = MultBy(da,db) by SCMFSA_2:57;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:92
        .= s2.f by A1
        .= Exec(i,s2).f by A52,SCMFSA_2:92;
    end;
    suppose
      InsCode i = 5;
      then
A53:  ex da, db being Int-Location st i = Divide(da, db) by SCMFSA_2:58;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:93
        .= s2.f by A1
        .= Exec(i,s2).f by A53,SCMFSA_2:93;
    end;
    suppose
      InsCode i = 6;
      then
A54:  ex loc being Element of NAT st i = goto loc by SCMFSA_2:59;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:95
        .= s2.f by A1
        .= Exec(i,s2).f by A54,SCMFSA_2:95;
    end;
    suppose
      InsCode i = 7;
      then
A55:  ex loc being Element of NAT, da being Int-Location
      st i = da=0_goto loc by SCMFSA_2:60;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:96
        .= s2.f by A1
        .= Exec(i,s2).f by A55,SCMFSA_2:96;
    end;
    suppose
      InsCode i = 8;
      then
A56:  ex loc being Element of NAT, da being Int-Location
      st i = da>0_goto loc by SCMFSA_2:61;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:97
        .= s2.f by A1
        .= Exec(i,s2).f by A56,SCMFSA_2:97;
    end;
    suppose
      InsCode i = 9;
      then
A57:  ex db, da being Int-Location, g being FinSeq-Location st i = da :=
      (g,db) by SCMFSA_2:62;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:98
        .= s2.f by A1
        .= Exec(i,s2).f by A57,SCMFSA_2:98;
    end;
    suppose
      InsCode i = 10;
      then consider
      db, da being Int-Location, g being FinSeq-Location such that
A58:  i = (g,db):=da by SCMFSA_2:63;
A59:  a <> db by A4,A58,SCMFSA7B:def 1;
A60:  a <> da by A4,A58,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A61:      f = g;
A62:      s1.da = s2.da by A1,A60;
          consider m2 being Element of NAT such that
A63:      m2 = abs(s2.db) and
A64:      Exec((g,db):=da,s2).g = s2.g+*(m2,s2.da) by SCMFSA_2:99;
          consider m1 being Element of NAT such that
A65:      m1 = abs(s1.db) and
A66:      Exec((g,db):=da,s1).g = s1.g+*(m1,s1.da) by SCMFSA_2:99;
          m1 = m2 by A1,A59,A65,A63;
          hence Exec(i,s1).f = Exec(i,s2).f by A1,A58,A61,A66,A64,A62;
        end;
        suppose
A67:      f <> g;
          hence Exec(i,s1).f = s1.f by A58,SCMFSA_2:99
            .= s2.f by A1
            .= Exec(i,s2).f by A58,A67,SCMFSA_2:99;
        end;
      end;
    end;
    suppose
      InsCode i = 11;
      then
A68:  ex da being Int-Location, g being FinSeq-Location st i = da :=len
      g by SCMFSA_2:64;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:100
        .= s2.f by A1
        .= Exec(i,s2).f by A68,SCMFSA_2:100;
    end;
    suppose
      InsCode i = 12;
      then consider da being Int-Location, g being FinSeq-Location such that
A69:  i = g:=<0,...,0>da by SCMFSA_2:65;
A70:  a <> da by A4,A69,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A71:      f = g;
A72:      ex m2 being Element of NAT st m2 = abs(s2.da) & Exec(g
          :=<0,...,0>da, s2).g = m2 |-> 0 by SCMFSA_2:101;
          ex m1 being Element of NAT st m1 = abs(s1.da) & Exec(g
          :=<0,...,0>da, s1).g = m1 |-> 0 by SCMFSA_2:101;
          hence Exec(i,s1).f = Exec(i,s2).f by A1,A69,A70,A71,A72;
        end;
        suppose
A73:      f <> g;
          hence Exec(i,s1).f = s1.f by A69,SCMFSA_2:101
            .= s2.f by A1
            .= Exec(i,s2).f by A69,A73,SCMFSA_2:101;
        end;
      end;
    end;
  end;
  hence S[Exec(i,s1),Exec(i,s2)] by A6;
  now
    per cases by A5,A3,A2,NAT_1:8,33;
    suppose
      InsCode i = 0;
      then
A74:  i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s1).IC SCM+FSA = IC s1 by EXTPRO_1:def 3
        .= Exec(i,s2).IC SCM+FSA by A47,A74,EXTPRO_1:def 3;
    end;
    suppose
      InsCode i = 1;
      then
A75:  ex da, db being Int-Location st i = da := db by SCMFSA_2:54;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:89
        .= Exec(i,s2).IC SCM+FSA by A47,A75,SCMFSA_2:89;
    end;
    suppose
      InsCode i = 2;
      then
A76:  ex da, db being Int-Location st i = AddTo(da,db) by SCMFSA_2:55;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:90
        .= Exec(i,s2).IC SCM+FSA by A47,A76,SCMFSA_2:90;
    end;
    suppose
      InsCode i = 3;
      then
A77:  ex da, db being Int-Location st i = SubFrom(da, db) by SCMFSA_2:56;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:91
        .= Exec(i,s2).IC SCM+FSA by A47,A77,SCMFSA_2:91;
    end;
    suppose
      InsCode i = 4;
      then
A78:  ex da, db being Int-Location st i = MultBy(da,db) by SCMFSA_2:57;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:92
        .= Exec(i,s2).IC SCM+FSA by A47,A78,SCMFSA_2:92;
    end;
    suppose
      InsCode i = 5;
      then
A79:  ex da, db being Int-Location st i = Divide(da, db) by SCMFSA_2:58;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:93
        .= Exec(i,s2).IC SCM+FSA by A47,A79,SCMFSA_2:93;
    end;
    suppose
      InsCode i = 6;
      then consider loc being Element of NAT such that
A80:  i = goto loc by SCMFSA_2:59;
      thus Exec(i,s1).IC SCM+FSA = loc by A80,SCMFSA_2:95
        .= Exec(i,s2).IC SCM+FSA by A80,SCMFSA_2:95;
    end;
    suppose
      InsCode i = 7;
      then consider loc being Element of NAT, da being
      Int-Location such that
A81:  i = da =0_goto loc by SCMFSA_2:60;
      a <> da by A4,A81,SCMFSA7B:def 1;
      then
A82:  s1.da = s2.da by A1;
      hereby
        per cases;
        suppose
A83:      s1.da = 0;
          hence Exec(i,s1).IC SCM+FSA = loc by A81,SCMFSA_2:96
            .= Exec(i,s2).IC SCM+FSA by A81,A82,A83,SCMFSA_2:96;
        end;
        suppose
A84:      s1.da <> 0;
          hence Exec(i,s1).IC SCM+FSA = succ IC s1 by A81,SCMFSA_2:96
            .= Exec(i,s2).IC SCM+FSA by A47,A81,A82,A84,SCMFSA_2:96;
        end;
      end;
    end;
    suppose
      InsCode i = 8;
      then consider loc being Element of NAT, da being
      Int-Location such that
A85:  i = da>0_goto loc by SCMFSA_2:61;
      a <> da by A4,A85,SCMFSA7B:def 1;
      then
A86:  s1.da = s2.da by A1;
      hereby
        per cases;
        suppose
A87:      s1.da > 0;
          hence Exec(i,s1).IC SCM+FSA = loc by A85,SCMFSA_2:97
            .= Exec(i,s2).IC SCM+FSA by A85,A86,A87,SCMFSA_2:97;
        end;
        suppose
A88:      s1.da <= 0;
          hence Exec(i,s1).IC SCM+FSA = succ IC s1 by A85,SCMFSA_2:97
            .= Exec(i,s2).IC SCM+FSA by A47,A85,A86,A88,SCMFSA_2:97;
        end;
      end;
    end;
    suppose
      InsCode i = 9;
      then
A89:  ex db, da being Int-Location, g being FinSeq-Location st i = da
      := (g,db) by SCMFSA_2:62;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:98
        .= Exec(i,s2).IC SCM+FSA by A47,A89,SCMFSA_2:98;
    end;
    suppose
      InsCode i = 10;
      then
A90:  ex db, da being Int-Location, g being FinSeq-Location st i = (g,
      db):=da by SCMFSA_2:63;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:99
        .= Exec(i,s2).IC SCM+FSA by A47,A90,SCMFSA_2:99;
    end;
    suppose
      InsCode i = 11;
      then
A91:  ex da being Int-Location, g being FinSeq-Location st i = da :=len
      g by SCMFSA_2:64;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:100
        .= Exec(i,s2).IC SCM+FSA by A47,A91,SCMFSA_2:100;
    end;
    suppose
      InsCode i = 12;
      then
A92:  ex da being Int-Location, g being FinSeq-Location st i = g
      :=<0,...,0>da by SCMFSA_2:65;
      hence Exec(i,s1).IC SCM+FSA = succ IC s1 by SCMFSA_2:101
        .= Exec(i,s2).IC SCM+FSA by A47,A92,SCMFSA_2:101;
    end;
  end;
  hence thesis;
end;

theorem Th38:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does not refer a & (for b being Int-Location st a <> b
  holds s1.b = s2.b) & (for f being FinSeq-Location holds s1.f = s2.f) & I
  is_closed_on s1 holds for k being Element of NAT holds (for b being
Int-Location st a <> b holds Comput(ProgramPart( (s1 +* (I +*
 Start-At( 0,SCM+FSA)))), (s1 +* (I +*
 Start-At( 0,SCM+FSA))),k).b
  = Comput(ProgramPart( (s2 +* (I +* Start-At( 0,SCM+FSA)))), (s2 +* (I +*
Start-At( 0,SCM+FSA))),k).b) & (for f being
  FinSeq-Location holds Comput(ProgramPart( (s1 +* (I +*
   Start-At( 0,SCM+FSA)))), (s1 +* (I +*
   Start-At( 0,SCM+FSA))),k).f =
Comput(ProgramPart( (s2 +* (I +* Start-At( 0,SCM+FSA)))), (s2 +* (I +* Start-At
( 0,SCM+FSA))),k).f) &
 IC Comput(ProgramPart( (s1 +* (I
+* Start-At( 0,SCM+FSA)))), (s1 +* (I
+* Start-At( 0,SCM+FSA))),k) = IC Comput(ProgramPart( (s2 +* (I +*
 Start-At( 0,SCM+FSA)))), (s2 +* (I +*
 Start-At( 0,SCM+FSA))),k)
  & CurInstr(ProgramPart Comput(ProgramPart( (s1 +* (I +* Start-At( 0,SCM+FSA))
)), (s1 +* (I +* Start-At( 0,SCM+FSA))),k),
     Comput(ProgramPart( (s1 +* (I +* Start-At( 0,SCM+FSA)))), (s1 +* (I +*
Start-At( 0,SCM+FSA))),k))
   = CurInstr(
  ProgramPart Comput(ProgramPart( (s2 +* (I +* Start-At( 0,SCM+FSA)))), (s2 +*
(I +* Start-At( 0,SCM+FSA))),k),
   Comput(ProgramPart( (s2 +* (I +* Start-At( 0,SCM+FSA)))), (s2 +* (I +*
Start-At( 0,SCM+FSA))),k))
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does not refer a;
  set S2 = s2 +* (I +* Start-At( 0,SCM+FSA));
  set S1 = s1 +* (I +* Start-At( 0,SCM+FSA));
  defpred S[State of SCM+FSA,State of SCM+FSA] means (for b being Int-Location
  st a <> b holds $1.b = $2.b) & for f being FinSeq-Location holds $1.f = $2.f;
  assume that
A2: for b being Int-Location st a <> b holds s1.b = s2.b and
A3: for f being FinSeq-Location holds s1.f = s2.f;
A4: IC SCM+FSA in dom (I +* Start-At( 0,SCM+FSA)) by COMPOS_1:141;
A5: now
    let f be FinSeq-Location;
A6: not f in dom (I +* Start-At( 0,SCM+FSA)) by SCMFSA6B:13;
    hence S1.f = s1.f by FUNCT_4:12
      .= s2.f by A3
      .= S2.f by A6,FUNCT_4:12;
  end;
A7: Comput(ProgramPart(S2),S2,0) = S2 by EXTPRO_1:3;
  defpred P[Nat] means S[ Comput(ProgramPart(S1),S1,$1), Comput(ProgramPart(S2)
,S2,$1)] &
  IC Comput(ProgramPart(S1),S1,$1) = IC Comput(ProgramPart(S2),S2,$1) &
    CurInstr(ProgramPart Comput(ProgramPart(S1),S1,$1),Comput(ProgramPart(S1),
S1,$1)) =
  CurInstr(ProgramPart Comput(ProgramPart(S2),S2,$1),Comput(ProgramPart(S2),S2,
$1));
A8: I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
A9: IC Comput(ProgramPart(S1),S1,0) = S1.IC SCM+FSA by EXTPRO_1:3
    .= ((I +* Start-At( 0,SCM+FSA))).IC SCM+FSA by A4,FUNCT_4:14
    .= S2.IC SCM+FSA by A4,FUNCT_4:14
    .= IC Comput(ProgramPart(S2),S2,0) by EXTPRO_1:3;
  (I +* Start-At( 0,SCM+FSA)) c= S1 by FUNCT_4:26;
  then
A10: I c= S1 by A8,XBOOLE_1:1;
A11: now
    let b be Int-Location;
    assume
A12: a <> b;
A13: not b in dom (I +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
    hence S1.b = s1.b by FUNCT_4:12
      .= s2.b by A2,A12
      .= S2.b by A13,FUNCT_4:12;
  end;
A14: Comput(ProgramPart(S1),S1,0) = S1 by EXTPRO_1:3;
  assume that
A15: I is_closed_on s1;
A16: IC Comput(ProgramPart(S1),S1,0) in dom I by A15,SCMFSA7B:def 7;
  (I +* Start-At( 0,SCM+FSA)) c= S2 by FUNCT_4:26;
  then
A17: I c= S2 by A8,XBOOLE_1:1;
A18: for k being Element of NAT holds P[k] implies P[k + 1]
  proof
    let k be Element of NAT;
T: ProgramPart S1 = ProgramPart Comput(ProgramPart(S1),S1,k)
by AMI_1:123;
A19: Comput(ProgramPart(S1),S1,k+1) =
Following(ProgramPart S1,Comput(ProgramPart(S1),S1,k)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(S1),S1,k),Comput(
ProgramPart(S1),S1,k)),
      Comput(ProgramPart(S1),S1,k)) by T;
A20: IC Comput(ProgramPart(S1),S1,k) in dom I by A15,SCMFSA7B:def 7;
A21: ProgramPart I = I by RELAT_1:209;
    then
A22: I c= Comput(ProgramPart(S2),S2,k+1) by A17,AMI_1:99;
T: ProgramPart S2 = ProgramPart Comput(ProgramPart(S2),S2,k)
by AMI_1:123;
A23: Comput(ProgramPart(S2),S2,k+1) =
Following(ProgramPart S2,Comput(ProgramPart(S2),S2,k)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(S2),S2,k),Comput(
ProgramPart(S2),S2,k)),
      Comput(ProgramPart(S2),S2,k)) by T;
Y:  (ProgramPart Comput(ProgramPart(S1),S1,k))/.IC Comput(ProgramPart(S1),S1,k)
 = Comput(ProgramPart(S1),S1,k).IC Comput(ProgramPart(S1),S1,k) by COMPOS_1:38;
    I c= Comput(ProgramPart(S1),S1,k) by A10,A21,AMI_1:99;
    then CurInstr(ProgramPart Comput(ProgramPart(S1),S1,k),Comput(ProgramPart(
S1),S1,k))
     = I.IC Comput(ProgramPart(S1),S1,k) by A20,Y,GRFUNC_1:8;
    then CurInstr(ProgramPart Comput(ProgramPart(S1),S1,k),Comput(ProgramPart(
S1),S1,k)) in rng I
     by A20,FUNCT_1:def 5;
    then
A24: CurInstr(ProgramPart Comput(ProgramPart(S1),S1,k),Comput(ProgramPart(S1),
S1,k)) does not refer a
 by A1,SCMFSA7B:def 2;
    assume
A25: P[k];
    hence S[ Comput(ProgramPart(S1),S1,k+1), Comput(ProgramPart(S2),S2,k+1)]
by A19,A23,A24,Th37;
    thus
A26: IC Comput(ProgramPart(S1),S1,k+1) = IC Comput(ProgramPart(S2),S2,k+1) by
A25,A19,A23,A24,Th37;
A27: IC Comput(ProgramPart(S1),S1,k+1) in dom I by A15,SCMFSA7B:def 7;
Y:  (ProgramPart Comput(ProgramPart(S1),S1,k+1))/.IC Comput(ProgramPart(S1),S1,
k+1)
 = Comput(ProgramPart(S1),S1,k+1).IC Comput(ProgramPart(S1),S1,k+1) by
COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(S2),S2,k+1))/.IC Comput(ProgramPart(S2),S2,
k+1)
 = Comput(ProgramPart(S2),S2,k+1).IC Comput(ProgramPart(S2),S2,k+1) by
COMPOS_1:38;
    I c= Comput(ProgramPart(S1),S1,k+1) by A10,A21,AMI_1:99;
    hence CurInstr(ProgramPart Comput(ProgramPart(S1),S1,k+1),Comput(
ProgramPart(S1),S1,k+1))
     = I.IC Comput(ProgramPart(S1),S1,k+1) by A27,Y,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(S2),S2,k+1),Comput(ProgramPart
(S2),S2,k+1))
       by A22,A26,A27,Z,GRFUNC_1:8;
  end;
V:  (ProgramPart Comput(ProgramPart(S1),S1,0))/.IC Comput(ProgramPart(S1),S1,0)
 = Comput(ProgramPart(S1),S1,0).IC Comput(ProgramPart(S1),S1,0) by COMPOS_1:38;
U:  (ProgramPart Comput(ProgramPart(S2),S2,0))/.IC Comput(ProgramPart(S2),S2,0)
 = Comput(ProgramPart(S2),S2,0).IC Comput(ProgramPart(S2),S2,0) by COMPOS_1:38;
  CurInstr(ProgramPart Comput(ProgramPart(S1),S1,0),Comput(ProgramPart(S1),S1,0
))
   = S1.IC Comput(ProgramPart(S1),S1,0) by V,EXTPRO_1:3
    .= I.IC Comput(ProgramPart(S1),S1,0) by A10,A16,GRFUNC_1:8
    .= S2.IC Comput(ProgramPart(S2),S2,0) by A17,A9,A16,GRFUNC_1:8
    .= CurInstr(ProgramPart Comput(ProgramPart(S2),S2,0),Comput(ProgramPart(S2)
,S2,0))
     by U,EXTPRO_1:3;
  then
A28: P[0] by A11,A5,A14,A7,A9;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A28,A18);
  hence thesis;
end;

theorem Th39:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, l
being Element of NAT holds I is_closed_on s & I is_halting_on
  s iff I is_closed_on s +* (I +* Start-At(l,SCM+FSA)) & I is_halting_on s
   +* (I +*
  Start-At(l,SCM+FSA))
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let l be Element of NAT;
  DataPart s = DataPart(s +* (I +* Start-At(l,SCM+FSA))) by SCMFSA8A:11;
  hence thesis by Th8;
end;

theorem Th40:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does not refer a & (for b being Int-Location st a <> b
  holds s1.b = s2.b) & (for f being FinSeq-Location holds s1.f = s2.f) & I
is_closed_on s1 & I is_halting_on s1 holds I is_closed_on s2 & I is_halting_on
  s2
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does not refer a;
  set S2 = s2 +* (I +* Start-At( 0,SCM+FSA));
  set S1 = s1 +* (I +* Start-At( 0,SCM+FSA));
  assume
A2: for b being Int-Location st a <> b holds s1.b = s2.b;
A3: now
    let b be Int-Location;
    assume
A4: a <> b;
A5: not b in dom (I +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
    not b in dom (I +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
    hence S1.b = s1.b by FUNCT_4:12
      .= s2.b by A2,A4
      .= S2.b by A5,FUNCT_4:12;
  end;
  assume
A6: for f being FinSeq-Location holds s1.f = s2.f;
A7: now
    let f be FinSeq-Location;
A8: not f in dom (I +* Start-At( 0,SCM+FSA)) by SCMFSA6B:13;
    not f in dom (I +* Start-At( 0,SCM+FSA)) by SCMFSA6B:13;
    hence S1.f = s1.f by FUNCT_4:12
      .= s2.f by A6
      .= S2.f by A8,FUNCT_4:12;
  end;
A9: (I +* Start-At( 0,SCM+FSA)) +* (I +* Start-At( 0,SCM+FSA))
 = (I +* Start-At(
   0,SCM+FSA));
  then
A10: S1 +*(I +* Start-At( 0,SCM+FSA)) = S1 by FUNCT_4:15;
A11: S2 +* (I +* Start-At( 0,SCM+FSA)) = S2 by A9,FUNCT_4:15;
  assume that
A12: I is_closed_on s1 and
A13: I is_halting_on s1;
A14: I is_closed_on S1 by A12,A13,Th39;
A15: now
    let k be Element of NAT;
    IC Comput(ProgramPart(S1),S1,k) in dom I by A12,SCMFSA7B:def 7;
    hence IC Comput(ProgramPart(S2),S2,k) in dom I by A1,A3,A7,A10,A11,A14,Th38
;
  end;
  ProgramPart S1 halts_on S1 by A13,SCMFSA7B:def 8;
  then consider n being Element of NAT such that
A16: CurInstr(ProgramPart S1,Comput(ProgramPart(S1),S1,n))
 = halt SCM+FSA by EXTPRO_1:30;
TX1: ProgramPart S1 = ProgramPart Comput(ProgramPart(S1),S1,n)
by AMI_1:123;
TX2: ProgramPart S2 = ProgramPart Comput(ProgramPart(S2),S2,n)
by AMI_1:123;
  CurInstr(ProgramPart S2,Comput(ProgramPart(S2),S2,n))
   = halt SCM+FSA by A1,A3,A7,A10,A11,A14,A16,Th38,TX1,TX2;
  then ProgramPart S2 halts_on S2 by EXTPRO_1:30;
  hence thesis by A15,SCMFSA7B:def 7,def 8;
end;

theorem Th41:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA, a
  being Int-Location holds (for d being read-write Int-Location st a <> d holds
  s1.d = s2.d) & (for f being FinSeq-Location holds s1.f = s2.f) & I
does not refer a & I is_closed_on Initialized s1 &
I is_halting_on Initialized s1
implies (for d being Int-Location st a <> d holds IExec(I,s1).d = IExec(I,s2).d
  ) & (for f being FinSeq-Location holds IExec(I,s1).f = IExec(I,s2).f) & IC
  IExec(I,s1) = IC IExec(I,s2)
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume that
A1: for d being read-write Int-Location st a <> d holds s1.d = s2.d and
A2: for f being FinSeq-Location holds s1.f = s2.f;
A3: now
    let d be Int-Location;
    assume
A4: a <> d;
    per cases;
    suppose
A5:   d = intloc 0;
      hence (Initialized s1).d = 1 by SCMFSA6C:3
        .= (Initialized s2).d by A5,SCMFSA6C:3;
    end;
    suppose
      d <> intloc 0;
      then
A6:   d is read-write by SF_MASTR:def 5;
      hence (Initialized s1).d = s1.d by SCMFSA6C:3
        .= s2.d by A1,A4,A6
        .= (Initialized s2).d by A6,SCMFSA6C:3;
    end;
  end;
  set S1 = s1 +* Initialized I;
  set S2 = s2 +* Initialized I;
  assume
A7: I does not refer a;
A8: S2 = Initialized s2 +* (I +* Start-At( 0,SCM+FSA)) by SCMFSA8A:13;
  assume that
A9: I is_closed_on Initialized s1 and
A10: I is_halting_on Initialized s1;
A11: now
    let f be FinSeq-Location;
    thus (Initialized s1).f = s1.f by SCMFSA6C:3
      .= s2.f by A2
      .= (Initialized s2).f by SCMFSA6C:3;
  end;
  then I is_halting_on Initialized s2 by A7,A9,A10,A3,Th40;
  then
A12: ProgramPart S2 halts_on S2 by A8,SCMFSA7B:def 8;
A13: S1 = Initialized s1 +* (I +* Start-At( 0,SCM+FSA)) by SCMFSA8A:13;
  then
A14: ProgramPart S1 halts_on S1 by A10,SCMFSA7B:def 8;
  now
    let l be Element of NAT;
TX1: ProgramPart S1 = ProgramPart Comput(ProgramPart(S1),S1,l)
by AMI_1:123;
TX2: ProgramPart S2 = ProgramPart Comput(ProgramPart(S2),S2,l)
by AMI_1:123;
    assume l < LifeSpan(ProgramPart(S1),S1);
    then CurInstr(ProgramPart S1,Comput(ProgramPart(S1),S1,l))
     <> halt SCM+FSA by A14,EXTPRO_1:def 14;
    hence CurInstr(ProgramPart S2,Comput(ProgramPart(S2),S2,l)) <>
     halt SCM+FSA by A7,A9,A3,A11,A13,A8,Th38,TX1,TX2;
  end;
  then
A15: for l be Element of NAT
 st CurInstr(ProgramPart S2,Comput(ProgramPart(S2),S2,l))
 = halt SCM+FSA
  holds LifeSpan(ProgramPart(S1),S1) <= l;
TX1: ProgramPart S1 = ProgramPart
Comput(ProgramPart(S1),S1,LifeSpan(ProgramPart(S1),S1
))
by AMI_1:123;
TX2: ProgramPart S2 = ProgramPart
Comput(ProgramPart(S2),S2,LifeSpan(ProgramPart(S1),S1))
by AMI_1:123;
  CurInstr (ProgramPart S2,
  Comput(ProgramPart(S2),S2,LifeSpan(ProgramPart(S1),S1)))
   = CurInstr(ProgramPart S1,
   Comput(ProgramPart(S1),S1,LifeSpan(ProgramPart(S1),S1)))
    by A7,A9,A3,A11,A13,A8,Th38,TX1,TX2
    .= halt SCM+FSA by A14,EXTPRO_1:def 14;
  then
A16: LifeSpan(ProgramPart(S1),S1) = LifeSpan(ProgramPart(S2),S2) by A12,A15,
EXTPRO_1:def 14;
  then
A17: Result(ProgramPart(S2),S2) = Comput(ProgramPart(S2),S2,LifeSpan(
ProgramPart(S1),S1)) by A12,EXTPRO_1:23;
A18: Result(ProgramPart(S1),S1) = Comput(ProgramPart(S1),S1,LifeSpan(
ProgramPart(S1),S1)) by A14,EXTPRO_1:23;
  hereby
    let d be Int-Location;
    assume
A19: a <> d;
    thus IExec(I,s1).d = (Result(ProgramPart(S1),S1)).d by Th36,SCMFSA10:92
      .= (Result(ProgramPart(S2),S2)).d by A7,A9,A3,A11,A13,A8,A17,A18,A19,Th38
      .= IExec(I,s2).d by Th36,SCMFSA10:92;
  end;
  hereby
    let f be FinSeq-Location;
    thus IExec(I,s1).f = (Result(ProgramPart(S1),S1)).f by Th36,SCMFSA10:93
      .= (Result(ProgramPart(S2),S2)).f by A7,A9,A3,A11,A13,A8,A17,A18,Th38
      .= IExec(I,s2).f by Th36,SCMFSA10:93;
  end;
  thus IC IExec(I,s1) = IC Result(ProgramPart(S1),S1) by SCMFSA8A:7
    .= IC Comput(ProgramPart(S1),S1,LifeSpan(ProgramPart(S1),S1)) by A14,
EXTPRO_1:23
    .= IC Comput(ProgramPart(S2),S2,LifeSpan(ProgramPart(S2),S2)) by A7,A9,A3
,A11,A13,A8,A16,Th38
    .= IC Result(ProgramPart(S2),S2) by A12,EXTPRO_1:23
    .= IC IExec(I,s2) by SCMFSA8A:7;
end;

theorem
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA
, a,b being read-write Int-Location st I does not refer a & J does not refer a
  holds IC IExec(if=0(a,b,I,J),s) =  (card I + card J + 5) & (s.a = s.b
  implies ((for d being Int-Location st a <> d holds IExec(if=0(a,b,I,J),s).d =
  IExec(I,s).d) & for f being FinSeq-Location holds IExec(if=0(a,b,I,J),s).f =
IExec(I,s).f)) & (s.a <> s.b implies ((for d being Int-Location st a <> d holds
  IExec(if=0(a,b,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if=0(a,b,I,J),s).f = IExec(J,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a,b be read-write Int-Location;
  assume that
A1: I does not refer a and
A2: J does not refer a;
  set s2 = s;
  reconsider JJ = if=0(a,I,J) as parahalting Program of SCM+FSA;
  reconsider II = Macro SubFrom(a,b) as keeping_0 parahalting Program of
  SCM+FSA;
  set i = SubFrom(a,b);
  set s1 = Exec(i,Initialized s);
A3: now
    let c be read-write Int-Location;
    assume a <> c;
    hence s1.c = (Initialized s).c by SCMFSA_2:91
      .= s2.c by SCMFSA6C:3;
  end;
  IExec(if=0(a,b,I,J),s) = IExec(II ';' JJ,s) by SCMFSA6A:def 6
    .= IExec(JJ,IExec(II,s)) +* Start-At((IC IExec(JJ,IExec(II,s)) + card II
  ),SCM+FSA) by SCMFSA6B:44;
  hence IC IExec(if=0(a,b,I,J),s) = IC IExec(JJ,IExec(II,s)) + card II by
FUNCT_4:121
    .=  (card I + card J + 3) + card II by Th21
    .=  (card I + card J + 3) + 2 by COMPOS_1:150
    .=  (card I + card J + 5);
A4: now
    let f be FinSeq-Location;
    thus s1.f = (Initialized s).f by SCMFSA_2:91
      .= s2.f by SCMFSA6C:3;
  end;
  hereby
    assume
A5: s.a = s.b;
A6: I is_closed_on Initialized s1 by SCMFSA7B:24;
A7: I is_halting_on Initialized s1 by SCMFSA7B:25;
A8: Exec(i,Initialized s).a = (Initialized s).a - (Initialized s).b
by SCMFSA_2:91
      .= s.a - (Initialized s).b by SCMFSA6C:3
      .= s.a - s.b by SCMFSA6C:3
      .= 0 by A5;
    hereby
      let d be Int-Location;
      assume
A9:   a <> d;
      thus IExec(if=0(a,b,I,J),s).d = IExec(JJ,Exec(i,Initialized s)).d by Th12
        .= IExec(I,Exec(i,Initialized s)).d by A8,Th21
        .= IExec(I,s).d by A1,A3,A4,A6,A7,A9,Th41;
    end;
    let f be FinSeq-Location;
    thus IExec(if=0(a,b,I,J),s).f = IExec(JJ,Exec(i,Initialized s)).f by Th13
      .= IExec(I,Exec(i,Initialized s)).f by A8,Th21
      .= IExec(I,s).f by A1,A3,A4,A6,A7,Th41;
  end;
A10: Exec(i,Initialized s).a = (Initialized s).a - (Initialized s).b by
SCMFSA_2:91
    .= s.a - (Initialized s).b by SCMFSA6C:3
    .= s.a - s.b by SCMFSA6C:3;
A11: J is_halting_on Initialized s1 by SCMFSA7B:25;
A12: J is_closed_on Initialized s1 by SCMFSA7B:24;
  assume s.a <> s.b;
  then
A13: s.a + (- s.b) <> s.b + (- s.b);
  hereby
    let d be Int-Location;
    assume
A14: a <> d;
    thus IExec(if=0(a,b,I,J),s).d = IExec(JJ,Exec(i,Initialized s)).d by Th12
      .= IExec(J,Exec(i,Initialized s)).d by A10,A13,Th21
      .= IExec(J,s).d by A2,A3,A4,A12,A11,A14,Th41;
  end;
  let f be FinSeq-Location;
  thus IExec(if=0(a,b,I,J),s).f = IExec(JJ,Exec(i,Initialized s)).f by Th13
    .= IExec(J,Exec(i,Initialized s)).f by A10,A13,Th21
    .= IExec(J,s).f by A2,A3,A4,A12,A11,Th41;
end;

theorem
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA
, a,b being read-write Int-Location st I does not refer a & J does not refer a
  holds IC IExec(if>0(a,b,I,J),s) =  (card I + card J + 5) & (s.a > s.b
  implies (for d being Int-Location st a <> d holds IExec(if>0(a,b,I,J),s).d =
  IExec(I,s).d) & for f being FinSeq-Location holds IExec(if>0(a,b,I,J),s).f =
  IExec(I,s).f) & (s.a <= s.b implies (for d being Int-Location st a <> d holds
  IExec(if>0(a,b,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if>0(a,b,I,J),s).f = IExec(J,s).f)
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a,b be read-write Int-Location;
  assume that
A1: I does not refer a and
A2: J does not refer a;
  set s2 = s;
  reconsider JJ = if>0(a,I,J) as parahalting Program of SCM+FSA;
  reconsider II = Macro SubFrom(a,b) as keeping_0 parahalting Program of
  SCM+FSA;
  set i = SubFrom(a,b);
  set s1 = Exec(i,Initialized s);
A3: now
    let c be read-write Int-Location;
    assume a <> c;
    hence s1.c = (Initialized s).c by SCMFSA_2:91
      .= s2.c by SCMFSA6C:3;
  end;
  IExec(if>0(a,b,I,J),s) = IExec(II ';' JJ,s) by SCMFSA6A:def 6
    .= IExec(JJ,IExec(II,s)) +* Start-At (IC IExec(JJ,IExec(II,s)) + card II
  ,SCM+FSA) by SCMFSA6B:44;
  hence IC IExec(if>0(a,b,I,J),s) = IC IExec(JJ,IExec(II,s)) + card II by
FUNCT_4:121
    .=  (card I + card J + 3) + card II by Th27
    .=  (card I + card J + 3) + 2 by COMPOS_1:150
    .=  (card I + card J + 5);
A4: now
    let f be FinSeq-Location;
    thus s1.f = (Initialized s).f by SCMFSA_2:91
      .= s2.f by SCMFSA6C:3;
  end;
  hereby
A5: Exec(i,Initialized s).a = (Initialized s).a - (Initialized s).b
by SCMFSA_2:91
      .= s.a - (Initialized s).b by SCMFSA6C:3
      .= s.a - s.b by SCMFSA6C:3;
    assume s.a > s.b;
    then
A6: Exec(i,Initialized s).a > 0 by A5,XREAL_1:52;
A7: I is_halting_on Initialized s1 by SCMFSA7B:25;
A8: I is_closed_on Initialized s1 by SCMFSA7B:24;
    hereby
      let d be Int-Location;
      assume
A9:   a <> d;
      thus IExec(if>0(a,b,I,J),s).d = IExec(JJ,Exec(i,Initialized s)).d by Th12
        .= IExec(I,Exec(i,Initialized s)).d by A6,Th27
        .= IExec(I,s).d by A1,A3,A4,A8,A7,A9,Th41;
    end;
    let f be FinSeq-Location;
    thus IExec(if>0(a,b,I,J),s).f = IExec(JJ,Exec(i,Initialized s)).f by Th13
      .= IExec(I,Exec(i,Initialized s)).f by A6,Th27
      .= IExec(I,s).f by A1,A3,A4,A8,A7,Th41;
  end;
A10: Exec(i,Initialized s).a = (Initialized s).a - (Initialized s).b by
SCMFSA_2:91
    .= s.a - (Initialized s).b by SCMFSA6C:3
    .= s.a - s.b by SCMFSA6C:3;
A11: J is_closed_on Initialized s1 by SCMFSA7B:24;
A12: J is_halting_on Initialized s1 by SCMFSA7B:25;
  assume s.a <= s.b;
  then
A13: Exec(i,Initialized s).a <= 0 by A10,XREAL_1:49;
  hereby
    let d be Int-Location;
    assume
A14: a <> d;
    thus IExec(if>0(a,b,I,J),s).d = IExec(JJ,Exec(i,Initialized s)).d by Th12
      .= IExec(J,Exec(i,Initialized s)).d by A13,Th27
      .= IExec(J,s).d by A2,A3,A4,A11,A12,A14,Th41;
  end;
  let f be FinSeq-Location;
  thus IExec(if>0(a,b,I,J),s).f = IExec(JJ,Exec(i,Initialized s)).f by Th13
    .= IExec(J,Exec(i,Initialized s)).f by A13,Th27
    .= IExec(J,s).f by A2,A3,A4,A11,A12,Th41;
end;

