:: Conditional branch macro instructions of SCM+FSA, Part II
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SCMFSA_2, XBOOLE_0, AMI_1, AMISTD_2, CARD_1, TARSKI,
      TURING_1, SCMFSA6A, FUNCT_4, FSM_1, RELAT_1, UNIALG_2, CIRCUIT2, FUNCT_1,
      SCMFSA6C, SF_MASTR, SUBSET_1, ARYTM_3, FUNCT_7, SCMFSA7B, SCMFSA6B,
      AMI_3, SCMFSA8A, NAT_1, GRAPHSP, XXREAL_0, MSUALG_1, STRUCT_0, SCMNORM,
      GLIB_000, ARYTM_1, INT_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2,
      SCMFSA8B;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, NAT_1, INT_1,
      RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7, FINSEQ_1, FINSEQ_2,
      STRUCT_0, AMI_1, SCMNORM, SCMFSA_2, SCMFSA_4, SCMFSA_5, SCMFSA6A,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, INT_2, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, NAT_1, INT_2, SCMFSA_5, PARTFUN1, SCMFSA6A,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMNORM, SCMFSA_4, RELSET_1,
      SCMFSA_1;
 registrations SETFAM_1, RELAT_1, FUNCT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, CARD_3, AMI_1, SCMFSA_2, SF_MASTR, SCMFSA6B, SCMFSA6C, ORDINAL1,
      XBOOLE_0, SCMNORM, FINSEQ_1, FINSET_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, AMI_1, SCMFSA_2, SCMNORM;
 theorems TARSKI, NAT_1, FUNCT_1, FUNCT_4, AMI_1, SCMFSA_2, SCMFSA_4, SCMFSA_5,
      SCMFSA6A, GRFUNC_1, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A,
      RELAT_1, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0;
 schemes NAT_1;

begin
set A = NAT;
set D = Int-Locations \/ FinSeq-Locations;

Lm1: for I,J being Program of SCM+FSA holds ProgramPart Relocated(J,card I) c=
I ';' J

proof
  let I,J be Program of SCM+FSA;

  I ';' J = Directed I +* ProgramPart Relocated(J,card I) by SCMFSA6A:def 5;

  hence thesis by FUNCT_4:26;
end;

theorem
  for s being State of SCM+FSA holds IC SCM+FSA in dom s
proof
  let s be State of SCM+FSA;
  dom s = D \/ {IC SCM+FSA} \/ A by SCMFSA6A:34;
  then
A1: {IC SCM+FSA} c= dom s by XBOOLE_1:7,11;
  IC SCM+FSA in {IC SCM+FSA} by TARSKI:def 1;
  hence thesis by A1;
end;

theorem
  for s being State of SCM+FSA, l being Instruction-Location of SCM+FSA
  holds l in dom s
proof
  let s be State of SCM+FSA;
  let l be Instruction-Location of SCM+FSA;
  dom s = D \/ {IC SCM+FSA} \/ A by SCMFSA6A:34;
  then
A1: A c= dom s by XBOOLE_1:7;
  l in A by AMI_1:def 4;
  hence thesis by A1;
end;

theorem Th3:
  for I being Program of SCM+FSA, s being State of SCM+FSA st I
  is_closed_on s holds insloc 0 in dom I
proof
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  assume
A1: I is_closed_on s;
A2: IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
  IC Computation( (s +* (I +* Start-At insloc 0)),0) = (s +* (I +*
  Start-At insloc 0)).IC SCM+FSA by AMI_1:13
    .= (I +* Start-At insloc 0).IC SCM+FSA by A2,FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
  hence thesis by A1,SCMFSA7B:def 7;
end;

canceled;

theorem Th5:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  DataPart Initialize s = DataPart(s +* Initialized I)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
A1: now
    let a be Int-Location;
    per cases;
    suppose
A2:   intloc 0 = a;
      then a in dom Initialized I by SCMFSA6A:45;
      hence s1.a = (Initialized I).intloc 0 by A2,FUNCT_4:14
        .= 1 by SCMFSA6A:46
        .= (Initialize s).a by A2,SCMFSA6C:3;
    end;
    suppose
A3:   intloc 0 <> a;
      then
A4:   a is read-write by SF_MASTR:def 5;
      not a in dom Initialized I by A3,SCMFSA6A:48;
      hence s1.a = s.a by FUNCT_4:12
        .= (Initialize s).a by A4,SCMFSA6C:3;
    end;
  end;
  now
    let f be FinSeq-Location;
    not f in dom Initialized I by SCMFSA6A:49;
    hence s1.f = s.f by FUNCT_4:12
      .= (Initialize s).f by SCMFSA6C:3;
  end;
  hence thesis by A1,SCMFSA6A:38;
end;

theorem Th6:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
  DataPart s1 = DataPart s2 holds I is_closed_on s1 implies I is_closed_on s2
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set S1 = s1 +* (I +* Start-At insloc 0), S2 = s2 +* (I +* Start-At insloc 0);
  assume
A1: DataPart s1 = DataPart s2;
A2: Computation(S2,0) = s2 +* (I +* Start-At insloc 0) by AMI_1:13;
A3: Computation(S1,0) = s1 +* (I +* Start-At insloc 0) by AMI_1:13;
  then
A4: DataPart Computation(S1,0) = DataPart s1 by SCMFSA8A:11
    .= DataPart Computation(S2,0) by A1,A2,SCMFSA8A:11;
  assume
A5: I is_closed_on s1;
  then
A6: insloc 0 in dom I by Th3;
  defpred P[Element of NAT] means IC Computation(S1,$1) = IC Computation(S2,$1
  ) & CurInstr Computation(S1,$1) = CurInstr Computation(S2,$1) & DataPart
  Computation(S1,$1) = DataPart Computation(S2,$1);
A7: I c= I +* Start-At insloc 0 by SCMFSA8A:9;
  then
A8: dom I c= dom (I +* Start-At insloc 0) by GRFUNC_1:8;
A9: now
    let k be Element of NAT;
A10: Computation(S2,k+1) = Following Computation(S2,k) by AMI_1:14
      .= Exec(CurInstr Computation(S2,k), Computation(S2,k));
    assume
A11: P[k];
    then
A12: for f being FinSeq-Location holds Computation(S1,k).f = Computation(
    S2, k).f by SCMFSA6A:38;
    for a being Int-Location holds Computation(S1,k).a = Computation(S2,k
    ) .a by A11,SCMFSA6A:38;
    then
A13: Computation(S1,k), Computation(S2,k) equal_outside A by A11,A12,
SCMFSA6A:28;
    I +* Start-At insloc 0 c= s2 +* (I +* Start-At insloc 0) by FUNCT_4:26;
    then I c= s2 +* (I +* Start-At insloc 0) by A7,XBOOLE_1:1;
    then
A14: I c= Computation(S2,k+1) by AMI_1:81;
A15: IC Computation(S1,k+1) in dom I by A5,SCMFSA7B:def 7;
A16: Computation(S1,k+1) = Following Computation(S1,k) by AMI_1:14
      .= Exec(CurInstr Computation(S1,k), Computation(S1,k));
    then
A17: IC Computation(S1,k+1) = IC Computation(S2,k+1) by A11,A13,A10,AMI_1:121
,SCMFSA6A:32;
    I +* Start-At insloc 0 c= s1 +* (I +* Start-At insloc 0) by FUNCT_4:26;
    then I c= s1 +* (I +* Start-At insloc 0) by A7,XBOOLE_1:1;
    then I c= Computation(S1,k+1) by AMI_1:81;
    then CurInstr Computation(S1,k+1) = I.IC Computation(S1,k+1) by A15,
GRFUNC_1:8
      .= CurInstr Computation(S2,k+1) by A14,A17,A15,GRFUNC_1:8;
    hence P[k+1] by A11,A13,A16,A10,A17,SCMFSA6A:32,39;
  end;
A18: IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
  then
A19: IC Computation(S2,0) = (I +* Start-At insloc 0).IC SCM+FSA by A2,
FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A20: IC Computation(S1,0) = (I +* Start-At insloc 0).IC SCM+FSA by A18,A3,
FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
  then CurInstr Computation(S1,0) = (I +* Start-At insloc 0).insloc 0 by A3,A8
,A6,FUNCT_4:14
    .= CurInstr Computation(S2,0) by A2,A19,A8,A6,FUNCT_4:14;
  then
A21: P[0] by A20,A19,A4;
  now
    let k be Element of NAT;
A22: IC Computation(S1,k) in dom I by A5,SCMFSA7B:def 7;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A21,A9);
    hence IC Computation(S2,k) in dom I by A22;
  end;
  hence thesis by SCMFSA7B:def 7;
end;

theorem Th7:
  for s1,s2 being State of SCM+FSA, I,J being Program of SCM+FSA
holds DataPart s1 = DataPart s2 implies s1 +* (I +* Start-At insloc 0),s2 +* (J
  +* Start-At insloc 0) equal_outside NAT
proof
  let s1,s2 be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  assume
A1: DataPart s1 = DataPart s2;
  set S2 = s2 +* (J +* Start-At insloc 0);
  set S1 = s1 +* (I +* Start-At insloc 0);
A2: IC S1 = insloc 0 by FUNCT_4:26,SF_MASTR:67;
A3: IC S2 = insloc 0 by FUNCT_4:26,SF_MASTR:67;
  DataPart S1 = DataPart s1 by SCMFSA8A:11
    .= DataPart S2 by A1,SCMFSA8A:11;
  hence thesis by A2,A3,SCMFSA8A:6;
end;

theorem Th8:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
DataPart s1 = DataPart s2 holds I is_closed_on s1 & I is_halting_on s1 implies
  I is_closed_on s2 & I is_halting_on s2
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set S1 = s1 +* (I +* Start-At insloc 0), S2 = s2 +* (I +* Start-At insloc 0);
  defpred P[Element of NAT] means IC Computation(S1,$1) = IC Computation(S2,$1
  ) & CurInstr Computation(S1,$1) = CurInstr Computation(S2,$1) & DataPart
  Computation(S1,$1) = DataPart Computation(S2,$1);
A1: IC SCM+FSA in {IC SCM+FSA} by TARSKI:def 1;
A2: I c= (I +* Start-At insloc 0) by SCMFSA8A:9;
  then
A3: dom I c= dom (I +* Start-At insloc 0) by GRFUNC_1:8;
A4: {IC SCM+FSA} = dom Start-At insloc 0 by FUNCOP_1:19;
A5: Computation(S1,0) = s1 +* (I +* Start-At insloc 0) by AMI_1:13;
  Start-At insloc 0 c= I +* Start-At insloc 0 by FUNCT_4:26;
  then
A6: dom Start-At insloc 0 c= dom (I +* Start-At insloc 0) by GRFUNC_1:8;
  then
A7: IC Computation(S1,0) = (I +* Start-At insloc 0).IC SCM+FSA by A1,A4,A5,
FUNCT_4:14
    .= (Start-At insloc 0).IC SCM+FSA by A1,A4,FUNCT_4:14
    .= insloc 0 by FUNCOP_1:87;
A8: Computation(S2,0) = s2 +* (I +* Start-At insloc 0) by AMI_1:13;
  then
A9: IC Computation(S2,0) = (I +* Start-At insloc 0).IC SCM+FSA by A1,A4,A6,
FUNCT_4:14
    .= (Start-At insloc 0).IC SCM+FSA by A1,A4,FUNCT_4:14
    .= insloc 0 by FUNCOP_1:87;
  assume
  DataPart s1 = DataPart s2;
  then
A10: Computation(S1,0), Computation(S2,0) equal_outside A by A5,A8,Th7;
  assume
A11: I is_closed_on s1;
A12: now
    let k be Element of NAT;
A13: Computation(S2,k+1) = Following Computation(S2,k) by AMI_1:14
      .= Exec(CurInstr Computation(S2,k), Computation(S2,k));
    assume
A14: P[k];
    then
A15: for f being FinSeq-Location holds Computation(S1,k).f = Computation(
    S2, k).f by SCMFSA6A:38;
    for a being Int-Location holds Computation(S1,k).a = Computation(S2,k
    ) .a by A14,SCMFSA6A:38;
    then
A16: Computation(S1,k), Computation(S2,k) equal_outside A by A14,A15,
SCMFSA6A:28;
    (I +* Start-At insloc 0) c= s2 +* (I +* Start-At insloc 0) by FUNCT_4:26;
    then I c= s2 +* (I +* Start-At insloc 0) by A2,XBOOLE_1:1;
    then
A17: I c= Computation(S2,k+1) by AMI_1:81;
A18: IC Computation(S1,k+1) in dom I by A11,SCMFSA7B:def 7;
A19: Computation(S1,k+1) = Following Computation(S1,k) by AMI_1:14
      .= Exec(CurInstr Computation(S1,k), Computation(S1,k));
    then
A20: IC Computation(S1,k+1) = IC Computation(S2,k+1) by A14,A16,A13,AMI_1:121
,SCMFSA6A:32;
    (I +* Start-At insloc 0) c= s1 +* (I +* Start-At insloc 0) by FUNCT_4:26;
    then I c= s1 +* (I +* Start-At insloc 0) by A2,XBOOLE_1:1;
    then I c= Computation(S1,k+1) by AMI_1:81;
    then CurInstr Computation(S1,k+1) = I.IC Computation(S1,k+1) by A18,
GRFUNC_1:8
      .= CurInstr Computation(S2,k+1) by A17,A20,A18,GRFUNC_1:8;
    hence P[k+1] by A14,A16,A19,A13,A20,SCMFSA6A:32,39;
  end;
  assume
  I is_halting_on s1;
  then ProgramPart(s1 +* (I +* Start-At insloc 0))
   halts_on s1 +* (I +* Start-At insloc 0) by SCMFSA7B:def 8;
  then consider m being Element of NAT such that
A21: CurInstr Computation(S1,m) = halt SCM+FSA by AMI_1:146;
A22: insloc 0 in dom I by A11,Th3;
  then CurInstr Computation(S1,0) = (I +* Start-At insloc 0).insloc 0 by A5,A7
,A3,FUNCT_4:14
    .= CurInstr Computation(S2,0) by A8,A9,A3,A22,FUNCT_4:14;
  then
A23: P[0] by A7,A9,A10,SCMFSA6A:39;
  now
    let k be Element of NAT;
A24: IC Computation(S1,k) in dom I by A11,SCMFSA7B:def 7;
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A23,A12);
    hence IC Computation(S2,k) in dom I by A24;
  end;
  hence I is_closed_on s2 by SCMFSA7B:def 7;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A23,A12);
  then CurInstr Computation(S2,m) = halt SCM+FSA by A21;
  then ProgramPart(s2 +* (I +* Start-At insloc 0))
   halts_on s2 +* (I +* Start-At insloc 0) by AMI_1:146;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th9:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA holds
  I is_closed_on Initialize s iff I is_closed_on s +* Initialized J
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  DataPart Initialize s = DataPart(s +* Initialized J) by Th5;
  hence thesis by Th6;
end;

theorem Th10:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, l
being Instruction-Location of SCM+FSA holds I is_closed_on s iff I is_closed_on
  s +* (I +* Start-At l)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let l be Instruction-Location of SCM+FSA;
  DataPart s = DataPart(s +* (I +* Start-At l)) by SCMFSA8A:11;
  hence thesis by Th6;
end;

theorem Th11:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
I +* Start-At insloc 0 c= s1 & I is_closed_on s1 for n being Element of NAT st
ProgramPart Relocated(I,n) c= s2 & IC s2 = insloc n & DataPart s1 = DataPart s2
for i being Element of NAT holds IC Computation( s1,i) + n = IC Computation( s2
,i) & IncAddr(CurInstr ( Computation( s1,i)),n) = CurInstr ( Computation( s2,i)
  ) & DataPart Computation( s1,i) = DataPart Computation( s2,i)
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  assume
A1: I +* Start-At insloc 0 c= s1;
  assume
A2: I is_closed_on s1;
  let n be Element of NAT;
A3: IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
A4: I c= I +* Start-At insloc 0 by SCMFSA8A:9;
  then
A5: dom I c= dom (I +* Start-At insloc 0) by GRFUNC_1:8;
  defpred P[Element of NAT] means IC Computation(s1,$1) + n = IC Computation(
s2,$1) & IncAddr(CurInstr ( Computation(s1,$1)),n) = CurInstr ( Computation(s2,
  $1)) & DataPart Computation(s1,$1) = DataPart Computation(s2,$1);
  assume
A6: ProgramPart Relocated(I,n) c= s2;
A7: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
A8: Computation(s1,k+1) = Following Computation(s1,k) by AMI_1:14
      .= Exec(CurInstr Computation(s1,k), Computation(s1,k));
    reconsider l = IC Computation(s1,k+1) as Element of NAT by ORDINAL1:def 13;
    reconsider j = CurInstr Computation(s1,k+1) as Instruction of SCM+FSA;
A9: Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
      .= Exec(CurInstr Computation(s2,k), Computation(s2,k));
A10: IC Computation(s2,k+1) in NAT by AMI_1:def 4;
    s1 +* (I +* Start-At insloc 0) = s1 by A1,FUNCT_4:79;
    then
A11: IC Computation(s1,k+1) in dom I by A2,SCMFSA7B:def 7;
    assume
A12: P[k];
    hence
A13: IC Computation(s1,k+1) + n = IC Computation(s2,k+1) by A8,A9,SCMFSA6A:41;
    then IC Computation(s2,k+1) in dom Relocated(I,n) by A11,SCMFSA_5:4;
    then IC Computation(s2,k+1) in dom Relocated(I,n) /\ NAT by A10,
XBOOLE_0:def 4;
    then
A14: IC Computation(s2,k+1) in dom ProgramPart Relocated(I,n) by RELAT_1:90;
    dom ProgramPart I = dom I /\ NAT by RELAT_1:90;
    then
A15: l in dom ProgramPart I by A11,XBOOLE_0:def 4;
A16: I c= I +* Start-At insloc 0 by SCMFSA8A:9;
    then
A17: dom I c= dom (I +* Start-At insloc 0) by GRFUNC_1:8;
    j = s1.IC Computation(s1,k+1) by AMI_1:54
      .= (I +* Start-At insloc 0).IC Computation(s1,k+1) by A1,A17,A11,
GRFUNC_1:8
      .= I.l by A16,A11,GRFUNC_1:8;
    hence IncAddr(CurInstr Computation(s1,k+1),n) = Relocated(I,n).(l + n) by
A15,SCMFSA_5:7
      .= (ProgramPart Relocated(I,n)).(IC Computation(s2,k+1)) by A13,
FUNCT_1:72
      .= s2.IC Computation(s2,k+1) by A6,A14,GRFUNC_1:8
      .= CurInstr Computation(s2,k+1) by AMI_1:54;
    thus thesis by A12,A8,A9,SCMFSA6A:41;
  end;
A18: IC Computation(s1,0) = s1.IC SCM+FSA by AMI_1:13
    .= (I +* Start-At insloc 0).IC SCM+FSA by A1,A3,GRFUNC_1:8
    .= insloc 0 by SF_MASTR:66;
  assume
A19: IC s2 = insloc n;
A20: insloc 0 in dom I by A2,Th3;
  then insloc 0 + n in dom Relocated(I,n) by SCMFSA_5:4;
  then
A21: insloc (0 + n) in dom ProgramPart Relocated(I,n) by AMI_1:106;
  IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
  then
A22: s1.IC s1 = s1.((I +* Start-At insloc 0).IC SCM+FSA) by A1,GRFUNC_1:8
    .= s1.insloc 0 by SF_MASTR:66
    .= (I +* Start-At insloc 0).insloc 0 by A1,A5,A20,GRFUNC_1:8
    .= I.insloc 0 by A4,A20,GRFUNC_1:8;
  ProgramPart I = I by AMI_1:105;
  then
A23: insloc 0 in dom ProgramPart I by A2,Th3;
  assume
  DataPart s1 = DataPart s2;
  then
A24: DataPart Computation(s1,0) = DataPart s2 by AMI_1:13
    .= DataPart Computation(s2,0) by AMI_1:13;
  let i be Element of NAT;
  IncAddr(CurInstr ( Computation(s1,0)),n) = IncAddr(CurInstr s1,n) by AMI_1:13
    .= Relocated(I,n).(insloc 0 + n) by A22,A23,SCMFSA_5:7
    .= (ProgramPart Relocated(I,n)).insloc n by FUNCT_1:72
    .= CurInstr s2 by A6,A19,A21,GRFUNC_1:8
    .= CurInstr ( Computation(s2,0)) by AMI_1:13;
  then
A25: P[0] by A19,A18,A24,AMI_1:13;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A25,A7);
  hence thesis;
end;

theorem Th12:
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being parahalting Program of SCM+FSA, a being
  Int-Location holds IExec(i ';' J,s).a = IExec(J,Exec(i,Initialize s)).a
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be parahalting Program of SCM+FSA;
  let a be Int-Location;
  thus IExec(i ';' J,s).a = IExec(Macro i ';' J,s).a by SCMFSA6A:def 6
    .= IExec(J,IExec(Macro i,s)).a by SCMFSA6C:1
    .= IExec(J,Exec(i,Initialize s)).a by SCMFSA6C:6;
end;

theorem Th13:
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being parahalting Program of SCM+FSA, f being
  FinSeq-Location holds IExec(i ';' J,s).f = IExec(J,Exec(i,Initialize s)).f
proof
  let s be State of SCM+FSA;
  let i be keeping_0 parahalting Instruction of SCM+FSA;
  let J be parahalting Program of SCM+FSA;
  let f be FinSeq-Location;
  thus IExec(i ';' J,s).f = IExec(Macro i ';' J,s).f by SCMFSA6A:def 6
    .= IExec(J,IExec(Macro i,s)).f by SCMFSA6C:2
    .= IExec(J,Exec(i,Initialize s)).f by SCMFSA6C:6;
end;

definition
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  func if=0(a,I,J) -> Program of SCM+FSA equals
  a =0_goto insloc (card J + 3)
  ';' J ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA;
  coherence;
  func if>0(a,I,J) -> Program of SCM+FSA equals
  a >0_goto insloc (card J + 3)
  ';' J ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA;
  coherence;
end;

definition
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  func if<0(a,I,J) -> Program of SCM+FSA equals
  if=0(a,J,if>0(a,J,I));
  coherence;
end;

Lm2: for a being Int-Location, I,J being Program of SCM+FSA holds insloc 0 in
dom if=0(a,I,J) & insloc 1 in dom if=0(a,I,J) & insloc 0 in dom if>0(a,I,J) &
insloc 1 in dom if>0(a,I,J)

proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  set i = a =0_goto insloc (card J + 3);

  if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' (I ';' Stop
  SCM+FSA) by SCMFSA6A:67

    .= i ';' J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)) by
SCMFSA6A:67

    .= i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71

    .= Macro i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)
  )) by SCMFSA6A:def 6;

  then
A1: dom Macro i c= dom if=0(a,I,J) by SCMFSA6A:56;
A2: dom Macro i = {insloc 0, insloc 1} by SCMFSA7B:4;
  then
A3: insloc 1 in dom Macro i by TARSKI:def 2;
  insloc 0 in dom Macro i by A2,TARSKI:def 2;
  hence insloc 0 in dom if=0(a,I,J) & insloc 1 in dom if=0(a,I,J) by A1,A3;
  set i = a >0_goto insloc (card J + 3);

  if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' (I ';' Stop
  SCM+FSA) by SCMFSA6A:67

    .= i ';' J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)) by
SCMFSA6A:67

    .= i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71

    .= Macro i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)
  )) by SCMFSA6A:def 6;

  then
A4: dom Macro i c= dom if>0(a,I,J) by SCMFSA6A:56;
A5: dom Macro i = {insloc 0, insloc 1} by SCMFSA7B:4;
  then
A6: insloc 1 in dom Macro i by TARSKI:def 2;
  insloc 0 in dom Macro i by A5,TARSKI:def 2;
  hence thesis by A4,A6;
end;

Lm3: for a being Int-Location, I,J being Program of SCM+FSA holds if=0(a,I,J).
insloc 0 = a =0_goto insloc (card J + 3) & if=0(a,I,J).insloc 1 = goto insloc 2
& if>0(a,I,J).insloc 0 = a >0_goto insloc (card J + 3) & if>0(a,I,J).insloc 1 =
goto insloc 2

proof
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  set i = a =0_goto insloc (card J + 3);
A1: i <> halt SCM+FSA by SCMFSA_2:48,124;

A2: if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' (I ';' Stop
  SCM+FSA) by SCMFSA6A:67

    .= i ';' J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)) by
SCMFSA6A:67

    .= i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71

    .= Macro i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)
  )) by SCMFSA6A:def 6;

A3: dom Macro i = {insloc 0, insloc 1} by SCMFSA7B:4;
  then insloc 0 in dom Macro i by TARSKI:def 2;
  hence if=0(a,I,J).insloc 0 = (Directed Macro i).insloc 0 by A2,SCMFSA8A:28
    .= i by A1,SCMFSA7B:7;
  insloc 1 in dom Macro i by A3,TARSKI:def 2;
  hence if=0(a,I,J).insloc 1 = (Directed Macro i).insloc 1 by A2,SCMFSA8A:28
    .= goto insloc 2 by SCMFSA7B:8;
  set i = a >0_goto insloc (card J + 3);
A4: i <> halt SCM+FSA by SCMFSA_2:49,124;

A5: if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' (I ';' Stop
  SCM+FSA) by SCMFSA6A:67

    .= i ';' J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)) by
SCMFSA6A:67

    .= i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA))) by
SCMFSA6A:71

    .= Macro i ';' (J ';' (Goto insloc (card I + 1) ';' (I ';' Stop SCM+FSA)
  )) by SCMFSA6A:def 6;

A6: dom Macro i = {insloc 0, insloc 1} by SCMFSA7B:4;
  then insloc 0 in dom Macro i by TARSKI:def 2;
  hence if>0(a,I,J).insloc 0 = (Directed Macro i).insloc 0 by A5,SCMFSA8A:28
    .= i by A4,SCMFSA7B:7;
  insloc 1 in dom Macro i by A6,TARSKI:def 2;

  hence if>0(a,I,J).insloc 1 = (Directed Macro i).insloc 1 by A5,SCMFSA8A:28

    .= goto insloc 2 by SCMFSA7B:8;
end;

theorem Th14:
  for I,J being Program of SCM+FSA, a being Int-Location holds
  card if=0(a,I,J) = card I + card J + 4
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  thus card if=0(a,I,J) = card (Macro (a =0_goto insloc (card J + 3)) ';' J
  ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA) by SCMFSA6A:def 6
    .= card (Macro (a =0_goto insloc (card J + 3)) ';' J ';' Goto insloc (
  card I + 1) ';' I) + 1 by SCMFSA6A:61,SCMFSA8A:17
    .= card (Macro (a =0_goto insloc (card J + 3)) ';' J ';' Goto insloc (
  card I + 1)) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a =0_goto insloc (card J + 3)) ';' J) + card Goto insloc
  (card I + 1) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a =0_goto insloc (card J + 3)) ';' J) + 1 + card I + 1
  by SCMFSA8A:29
    .= card Macro (a =0_goto insloc (card J + 3)) + card J + 1 + card I + 1
  by SCMFSA6A:61
    .= 2 + card J + 1 + card I + 1 by SCMFSA7B:6
    .= card I + card J + 4;
end;

theorem Th15:
  for I,J being Program of SCM+FSA, a being Int-Location holds
  card if>0(a,I,J) = card I + card J + 4
proof
  let I,J be Program of SCM+FSA;
  let a be Int-Location;
  thus card if>0(a,I,J) = card (Macro (a >0_goto insloc (card J + 3)) ';' J
  ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA) by SCMFSA6A:def 6
    .= card (Macro (a >0_goto insloc (card J + 3)) ';' J ';' Goto insloc (
  card I + 1) ';' I) + 1 by SCMFSA6A:61,SCMFSA8A:17
    .= card (Macro (a >0_goto insloc (card J + 3)) ';' J ';' Goto insloc (
  card I + 1)) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a >0_goto insloc (card J + 3)) ';' J) + card Goto insloc
  (card I + 1) + card I + 1 by SCMFSA6A:61
    .= card (Macro (a >0_goto insloc (card J + 3)) ';' J) + 1 + card I + 1
  by SCMFSA8A:29
    .= card Macro (a >0_goto insloc (card J + 3)) + card J + 1 + card I + 1
  by SCMFSA6A:61
    .= 2 + card J + 1 + card I + 1 by SCMFSA7B:6
    .= card I + card J + 4;
end;

theorem Th16:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a = 0 & I is_closed_on s & I is_halting_on s
  holds if=0(a,I,J) is_closed_on s & if=0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = s +* (I1 +* Start-At insloc 0);
  set s3 = s +* (if=0(a,I,J) +* Start-At insloc 0);
  set s4 = Computation(s3,1);
  set i = a =0_goto insloc (card J + 3);
A1: not a in dom (if=0(a,I,J) +* Start-At insloc 0) by SCMFSA6B:12;
A2: insloc 0 in dom if=0(a,I,J) by Lm2;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
  then
A3: s3.insloc 0 = (if=0(a,I,J) +* Start-At insloc 0).insloc 0 by A2,FUNCT_4:14
    .= if=0(a,I,J).insloc 0 by A2,SCMFSA6B:7
    .= i by Lm3;
  IC SCM+FSA in dom (if=0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
  then
A4: IC s3 = (if=0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A5: if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  if=0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  then
A6: if=0(a,I,J) c= s3 by A5,XBOOLE_1:1;
A7: if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67;
  card (i ';' J ';' Goto insloc (card I + 1)) = card (Macro i ';' J ';'
  Goto insloc (card I + 1)) by SCMFSA6A:def 6
    .= card (Macro i ';' J) + card Goto insloc (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by SCMFSA7B:6
    .= card J + (2 + 1);
  then ProgramPart Relocated(I1,card J + 3) c= if=0(a,I,J) by A7,Lm1;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A6,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(I1,card J + 3)] c= s4 by AMI_1:99;
  then
A8: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
A9: Computation( s3,0 + 1) = Following Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A4,A3;
A10: DataPart s1 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A11: now
    let f be FinSeq-Location;
    thus s1.f = s3.f by A10,SCMFSA6A:38
      .= s4.f by A9,SCMFSA_2:96;
  end;
  now
    let a be Int-Location;
    thus s1.a = s3.a by A10,SCMFSA6A:38
      .= s4.a by A9,SCMFSA_2:96;
  end;
  then
A12: DataPart s1 = DataPart s4 by A11,SCMFSA6A:38;
  assume
  s.a = 0;
  then s3.a = 0 by A1,FUNCT_4:12;
  then
A13: IC Computation(s3,1) = insloc (card J + 3) by A9,SCMFSA_2:96;
  assume
A14: I is_closed_on s;
  assume
A15: I is_halting_on s;
  then
A16: I1 is_closed_on s by A14,SCMFSA8A:46;
  I1 is_halting_on s by A14,A15,SCMFSA8A:46;
  then
A17: ProgramPart s1 halts_on s1 by SCMFSA7B:def 8;
  DataPart s = DataPart s1 by SCMFSA8A:11;
  then
A18: I1 is_closed_on s1 by A16,Th6;
A19: I1 +* Start-At insloc 0 c= s1 by FUNCT_4:26;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A20:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Computation( s1,k1) as Element of NAT by
ORDINAL1:def 13;
      insloc m in dom I1 by A16,SCMFSA7B:def 7;
      then
A21:  m < card I1 by SCMFSA6A:15;
A22:  card I1 = card I + 1 by SCMFSA6A:61,SCMFSA8A:17;
      card if=0(a,I,J) = card I + card J + 4 by Th14
        .= card J + 3 + card I1 by A22;
      then
A23:  m + (card J + 3) < card if=0(a,I,J) by A21,XREAL_1:8;
      IC Computation(s3,k) = IC Computation( s4,k1) by A20,AMI_1:51
        .= insloc (m + (card J + 3)) by A19,A18,A8,A13,A12,Th11;
      hence IC Computation(s3,k) in dom if=0(a,I,J) by A23,SCMFSA6A:15;
    end;
    suppose
      k = 0;
      hence IC Computation(s3,k) in dom if=0(a,I,J) by A2,A4,AMI_1:13;
    end;
  end;
  hence if=0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
  CurInstr Computation( s3,LifeSpan s1 + 1) = CurInstr Computation( s4,
  LifeSpan s1) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s1,LifeSpan s1)),(card J + 3)) by A19
,A18,A8,A13,A12,Th11
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A17,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th17:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & I is_closed_on Initialize s & I
is_halting_on Initialize s holds IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At
  insloc (card I + card J + 3)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = s +* Initialized I1;
  set s3 = s +* Initialized if=0(a,I,J);
  set s4 = Computation(s3,1);
  set i = a =0_goto insloc (card J + 3);
A1: I1 +* Start-At insloc 0 c= s1 by FUNCT_4:26,SCMFSA6B:8;
A2: if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67;
A3: insloc 0 in dom if=0(a,I,J) by Lm2;
  if=0(a,I,J) c= Initialized if=0(a,I,J) by SCMFSA6A:26;
  then dom if=0(a,I,J) c= dom Initialized if=0(a,I,J) by GRFUNC_1:8;
  then
A4: s3.insloc 0 = (Initialized if=0(a,I,J)).insloc 0 by A3,FUNCT_4:14
    .= if=0(a,I,J).insloc 0 by A3,SCMFSA6A:50
    .= i by Lm3;
  IC SCM+FSA in dom Initialized if=0(a,I,J) by SCMFSA6A:24;
  then
A5: IC s3 = (Initialized if=0(a,I,J)).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SCMFSA6A:46;
A6: Computation( s3,0 + 1) = Following Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A5,A4;
A7: if=0(a,I,J) c= Initialized if=0(a,I,J) by SCMFSA6A:26;
  Initialized if=0(a,I,J) c= s3 by FUNCT_4:26;
  then
A8: if=0(a,I,J) c= s3 by A7,XBOOLE_1:1;
A9: not a in dom Initialized if=0(a,I,J) by SCMFSA6A:48;
A10: dom (s | A) = A by SCMFSA8A:3;
  assume
  s.a = 0;
  then s3.a = 0 by A9,FUNCT_4:12;
  then
A11: IC Computation(s3,1) = insloc (card J + 3) by A6,SCMFSA_2:96;
A12: DataPart s1 = DataPart s3 by SCMFSA6A:39,53;
A13: now
    let f be FinSeq-Location;
    thus s1.f = s3.f by A12,SCMFSA6A:38
      .= s4.f by A6,SCMFSA_2:96;
  end;
  now
    let a be Int-Location;
    thus s1.a = s3.a by A12,SCMFSA6A:38
      .= s4.a by A6,SCMFSA_2:96;
  end;
  then
A14: DataPart s1 = DataPart s4 by A13,SCMFSA6A:38;
  card (i ';' J ';' Goto insloc (card I + 1)) = card (Macro i ';' J ';'
  Goto insloc (card I + 1)) by SCMFSA6A:def 6
    .= card (Macro i ';' J) + card Goto insloc (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by SCMFSA7B:6
    .= card J + (2 + 1);
  then ProgramPart Relocated(I1,card J + 3) c= if=0(a,I,J) by A2,Lm1;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A8,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(I1,card J + 3)] c= s4 by AMI_1:99;
  then
A15: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
  assume
A16: I is_closed_on Initialize s;
  assume
A17: I is_halting_on Initialize s;
  then
A18: ProgramPart s1 halts_on s1 by A16,SCMFSA8A:55;
  I1 is_closed_on Initialize s by A16,A17,SCMFSA8A:46;
  then
A19: I1 is_closed_on s1 by Th9;
A20: CurInstr Computation( s3,LifeSpan s1 + 1) = CurInstr Computation( s4,
  LifeSpan s1) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s1,LifeSpan s1)),(card J + 3)) by A1,A19
,A15,A11,A14,Th11
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A18,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A21: ProgramPart s3 halts_on s3 by AMI_1:146;
  now
    let l be Element of NAT;
    assume
A22: l < LifeSpan s1 + 1;
    per cases;
    suppose
      l = 0;
      then CurInstr Computation( s3,l) = CurInstr s3 by AMI_1:13;
      hence CurInstr Computation( s3,l) <> halt SCM+FSA by A5,A4,SCMFSA_2:48
,124;
    end;
    suppose
      l <> 0;
      then consider n being Nat such that
A23:  l = n + 1 by NAT_1:6;
      assume
A24:  CurInstr Computation( s3,l) = halt SCM+FSA;
      reconsider n as Element of NAT by ORDINAL1:def 13;
      InsCode CurInstr Computation( s1,n) = InsCode IncAddr(CurInstr
      Computation( s1,n),(card J + 3)) by SCMFSA_4:22
        .= InsCode CurInstr Computation( s4,n) by A1,A19,A15,A11,A14,Th11
        .= 0 by A23,A24,AMI_1:51,SCMFSA_2:124;
      then
A25:  CurInstr Computation( s1,n) = halt SCM+FSA by SCMFSA_2:122;
      n < LifeSpan s1 by A22,A23,XREAL_1:8;
      hence contradiction by A18,A25,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr Computation( s3,l) = halt SCM+FSA
  holds LifeSpan s1 + 1 <= l;
  then
A26: LifeSpan s3 = LifeSpan s1 + 1 by A20,A21,AMI_1:def 46;
  ProgramPart s1 halts_on s1 by A16,A17,SCMFSA8A:55;
  then
A27: DataPart Result s1 = DataPart Computation( s1,LifeSpan s1) by AMI_1:122
    .= DataPart Computation( s4,LifeSpan s1) by A1,A19,A15,A11,A14,Th11
    .= DataPart Computation( s3,LifeSpan s1 + 1) by AMI_1:51
    .= DataPart Result s3 by A21,A26,AMI_1:122;
A28: now
    let x be set;
A29: IExec(I1,s) = Result s1 +* s | A by SCMFSA6B:def 1;
A30: now
      assume
      x in dom (s | A);
      then x in A by RELAT_1:86;
      hence x is Instruction-Location of SCM+FSA by AMI_1:def 4;
    end;
A31: dom Start-At insloc (card I + card J + 3) = {IC SCM+FSA} by FUNCOP_1:19;
A32: IExec(if=0(a,I,J),s) = (Result s3) +* (s | A) by SCMFSA6B:def 1;
    assume
A33: x in dom IExec(if=0(a,I,J),s);
    per cases by A33,SCMFSA6A:35;
    suppose
A34:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A35:  not x in dom Start-At insloc (card I + card J + 3) by A31,TARSKI:def 1;
      thus IExec(if=0(a,I,J),s).x = (Result s3).x by A32,A30,A34,FUNCT_4:12
,SCMFSA_2:84
        .= (Result s1).x by A27,A34,SCMFSA6A:38
        .= IExec(I1,s).x by A29,A30,A34,FUNCT_4:12,SCMFSA_2:84
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x by A35,
FUNCT_4:12;
    end;
    suppose
A36:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A37:  not x in dom Start-At insloc (card I + card J + 3) by A31,TARSKI:def 1;
      thus IExec(if=0(a,I,J),s).x = (Result s3).x by A32,A30,A36,FUNCT_4:12
,SCMFSA_2:85
        .= (Result s1).x by A27,A36,SCMFSA6A:38
        .= IExec(I1,s).x by A29,A30,A36,FUNCT_4:12,SCMFSA_2:85
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x by A37,
FUNCT_4:12;
    end;
    suppose
A38:  x = IC SCM+FSA;
      then
A39:  x in dom Start-At insloc (card I + card J + 3) by A31,TARSKI:def 1;
A40:  IC Result s1 = IExec(I1,s).IC SCM+FSA by A29,A30,A38,AMI_1:48,FUNCT_4:12
        .= IC (IExec(I,s) +* Start-At insloc card I) by A16,A17,SCMFSA8A:57
        .= insloc card I by AMI_1:111;
X:    ProgramPart s1 halts_on s1 by A16,A17,SCMFSA8A:55;
      thus IExec(if=0(a,I,J),s).x = (Result s3).x by A32,A30,A38,AMI_1:48
,FUNCT_4:12
        .= Computation( s3,LifeSpan s1 + 1).x by A21,A26,AMI_1:122
        .= IC Computation( s4,LifeSpan s1) by A38,AMI_1:51
        .= IC Computation( s1,LifeSpan s1) + (card J + 3) by A1,A19,A15,A11,A14
,Th11
        .= IC Result s1 + (card J + 3) by AMI_1:122,X
        .= (Start-At (insloc card I + (card J + 3))).IC SCM+FSA by A40,
FUNCOP_1:87
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x by A38,A39,
FUNCT_4:14;
    end;
    suppose
A41:  x is Instruction-Location of SCM+FSA;
      then x <> IC SCM+FSA by AMI_1:48;
      then
A42:  not x in dom Start-At insloc (card I + card J + 3) by A31,TARSKI:def 1;
A43:  x in NAT by A41,AMI_1:def 4;
      hence IExec(if=0(a,I,J),s).x = (s | A).x by A10,A32,FUNCT_4:14
        .= IExec(I1,s).x by A10,A29,A43,FUNCT_4:14
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x by A42,
FUNCT_4:12;
    end;
  end;
  dom IExec(if=0(a,I,J),s) = the carrier of SCM+FSA by AMI_1:79
    .= dom (IExec(I1,s) +* Start-At insloc (card I + card J + 3)) by AMI_1:79;
  hence IExec(if=0(a,I,J),s) = IExec(I1,s) +* Start-At insloc (card I + card J
  + 3) by A28,FUNCT_1:9
    .= IExec(I,s) +* Start-At insloc card I +* Start-At insloc (card I +
  card J + 3) by A16,A17,SCMFSA8A:57
    .= IExec(I,s) +* Start-At insloc (card I + card J + 3) by AMI_1:141;
end;

theorem Th18:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a <> 0 & J is_closed_on s & J is_halting_on
  s holds if=0(a,I,J) is_closed_on s & if=0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = s +* (JI2 +* Start-At insloc 0);
  set s3 = s +* (if=0(a,I,J) +* Start-At insloc 0);
  set s4 = Computation(s3,1);
  set s5 = Computation(s3,2);
  set i = a =0_goto insloc (card J + 3);
A1: JI2 +* Start-At insloc 0 c= s2 by FUNCT_4:26;
  IC SCM+FSA in dom (if=0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
  then
A2: IC s3 = (if=0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A3: if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  if=0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  then
A4: if=0(a,I,J) c= s3 by A3,XBOOLE_1:1;
A5: if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' JI2 by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:def 6;
  then ProgramPart Relocated(JI2,card Macro i) c= if=0(a,I,J) by Lm1;
  then ProgramPart Relocated(JI2,2) c= if=0(a,I,J) by SCMFSA7B:6;
  then ProgramPart Relocated(JI2,2) c= s3 by A4,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(JI2,2)] c= s5 by AMI_1:99;
  then
A6: ProgramPart Relocated(JI2,2) c= s5 by AMI_1:105;
A7: not a in dom (if=0(a,I,J) +* Start-At insloc 0) by SCMFSA6B:12;
A8: insloc 0 in dom if=0(a,I,J) by Lm2;
  if=0(a,I,J) c= if=0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A9: dom if=0(a,I,J) c= dom (if=0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
  then
A10: s3.insloc 0 = (if=0(a,I,J) +* Start-At insloc 0).insloc 0 by A8,FUNCT_4:14
    .= if=0(a,I,J).insloc 0 by A8,SCMFSA6B:7
    .= i by Lm3;
A11: insloc 1 in dom if=0(a,I,J) by Lm2;
A12: Computation( s3,0 + 1) = Following Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A2,A10;
  assume
  s.a <> 0;
  then s3.a <> 0 by A7,FUNCT_4:12;
  then
A13: IC Computation(s3,1) = Next insloc 0 by A2,A12,SCMFSA_2:96
    .= insloc (0 + 1);
A14: Computation(s3,1).insloc 1 = s3.insloc 1 by AMI_1:54
    .= (if=0(a,I,J) +* Start-At insloc 0).insloc 1 by A9,A11,FUNCT_4:14
    .= if=0(a,I,J).insloc 1 by A11,SCMFSA6B:7
    .= goto insloc 2 by Lm3;
  assume
A15: J is_closed_on s;
A16: Computation( s3,1 + 1) = Following s4 by AMI_1:14
    .= Exec(goto insloc 2,s4) by A13,A14;
A17: DataPart s2 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A18: now
    let f be FinSeq-Location;
    thus s2.f = s3.f by A17,SCMFSA6A:38
      .= Computation(s3,1).f by A12,SCMFSA_2:96
      .= s5.f by A16,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s2.a = s3.a by A17,SCMFSA6A:38
      .= Computation(s3,1).a by A12,SCMFSA_2:96
      .= s5.a by A16,SCMFSA_2:95;
  end;
  then
A19: DataPart s2 = DataPart s5 by A18,SCMFSA6A:38;
  assume
A20: J is_halting_on s;
  then
A21: JI2 is_closed_on s by A15,SCMFSA8A:58;
  then
A22: JI2 is_closed_on s2 by Th10;
A23: ProgramPart s2 halts_on s2 by A15,A20,SCMFSA8A:59;
A24: IC s5 = insloc 2 by A16,SCMFSA_2:95;
  now
    let k be Element of NAT;
    k = 0 or 0 + 1 < k + 1 by XREAL_1:8;
    then
A25: k = 0 or 1 <= k by NAT_1:13;
    per cases by A25,XXREAL_0:1;
    suppose
A26:  1 < k;
      then consider k1 being Nat such that
A27:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      0 + 1 < k1 + 1 by A26,A27;
      then consider k2 being Nat such that
A28:  k2 + 1 = k1 by NAT_1:6;
      reconsider k2 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Computation( s2,k2) as Element of NAT by
ORDINAL1:def 13;
A29:  card if=0(a,I,J) = card Macro i + card JI2 by A5,SCMFSA6A:61
        .= 2 + card JI2 by SCMFSA7B:6;
      insloc m in dom JI2 by A21,SCMFSA7B:def 7;
      then m < card JI2 by SCMFSA6A:15;
      then
A30:  m + 2 < card if=0(a,I,J) by A29,XREAL_1:8;
      IC Computation(s3,k) = IC Computation( s4,k1) by A27,AMI_1:51
        .= IC Computation( Computation( s4,1),k2) by A28,AMI_1:51
        .= IC Computation( Computation( s3,1 + 1),k2) by AMI_1:51
        .= insloc (m + 2) by A1,A22,A6,A24,A19,Th11;
      hence IC Computation(s3,k) in dom if=0(a,I,J) by A30,SCMFSA6A:15;
    end;
    suppose
      k = 0;
      hence IC Computation(s3,k) in dom if=0(a,I,J) by A8,A2,AMI_1:13;
    end;
    suppose
      k = 1;
      hence IC Computation(s3,k) in dom if=0(a,I,J) by A13,Lm2;
    end;
  end;
  hence if=0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
  CurInstr Computation( s3,LifeSpan s2 + 2) = CurInstr Computation( s5,
  LifeSpan s2) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s2,LifeSpan s2)),2) by A1,A22,A6,A24,A19
,Th11
    .= IncAddr(halt SCM+FSA,2) by A23,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th19:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <> 0 & J is_closed_on
Initialize s & J is_halting_on Initialize s holds IExec(if=0(a,I,J),s) = IExec(
  J,s) +* Start-At insloc (card I + card J + 3)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = s +* Initialized JI2;
  set s3 = s +* Initialized if=0(a,I,J);
  set s4 = Computation( s3,1);
  set s5 = Computation( s3,2);
  set i = a =0_goto insloc (card J + 3);
A1: JI2 +* Start-At insloc 0 c= s2 by FUNCT_4:26,SCMFSA6B:8;
  if=0(a,I,J) c= Initialized if=0(a,I,J) by SCMFSA6A:26;
  then
A2: dom if=0(a,I,J) c= dom Initialized if=0(a,I,J) by GRFUNC_1:8;
A3: insloc 0 in dom if=0(a,I,J) by Lm2;
  then
A4: s3.insloc 0 = (Initialized if=0(a,I,J)).insloc 0 by A2,FUNCT_4:14
    .= if=0(a,I,J).insloc 0 by A3,SCMFSA6A:50
    .= i by Lm3;
A5: if=0(a,I,J) c= Initialized if=0(a,I,J) by SCMFSA6A:26;
A6: insloc 1 in dom if=0(a,I,J) by Lm2;
A7: Computation(s3,1).insloc 1 = s3.insloc 1 by AMI_1:54
    .= (Initialized if=0(a,I,J)).insloc 1 by A2,A6,FUNCT_4:14
    .= if=0(a,I,J).insloc 1 by A6,SCMFSA6A:50
    .= goto insloc 2 by Lm3;
  IC SCM+FSA in dom Initialized if=0(a,I,J) by SCMFSA6A:24;
  then
A8: IC s3 = (Initialized if=0(a,I,J)).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SCMFSA6A:46;
  if=0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' JI2 by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:def 6;
  then ProgramPart Relocated(JI2,card Macro i) c= if=0(a,I,J) by Lm1;
  then
A9: ProgramPart Relocated(JI2,2) c= if=0(a,I,J) by SCMFSA7B:6;
A10: not a in dom Initialized if=0(a,I,J) by SCMFSA6A:48;
A11: dom (s | A) = dom s /\ A by RELAT_1:90
    .= (D \/ {IC SCM+FSA} \/ A) /\ A by SCMFSA6A:34
    .= A by XBOOLE_1:21;
  Initialized if=0(a,I,J) c= s3 by FUNCT_4:26;
  then if=0(a,I,J) c= s3 by A5,XBOOLE_1:1;
  then ProgramPart Relocated(JI2,2) c= s3 by A9,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(JI2,2)] c= s5 by AMI_1:99;
  then
A12: ProgramPart Relocated(JI2,2) c= s5 by AMI_1:105;
A13: Computation( s3,0 + 1) = Following Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A8,A4;
  assume
  s.a <> 0;
  then s3.a <> 0 by A10,FUNCT_4:12;
  then
A14: IC Computation(s3,1) = Next insloc 0 by A8,A13,SCMFSA_2:96
    .= insloc (0 + 1);
  assume
A15: J is_closed_on Initialize s;
A16: Computation( s3,1 + 1) = Following s4 by AMI_1:14
    .= Exec(goto insloc 2,s4) by A14,A7;
  then
A17: IC s5 = insloc 2 by SCMFSA_2:95;
A18: DataPart s2 = DataPart s3 by SCMFSA6A:39,53;
A19: now
    let f be FinSeq-Location;
    thus s2.f = s3.f by A18,SCMFSA6A:38
      .= Computation(s3,1).f by A13,SCMFSA_2:96
      .= s5.f by A16,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s2.a = s3.a by A18,SCMFSA6A:38
      .= Computation(s3,1).a by A13,SCMFSA_2:96
      .= s5.a by A16,SCMFSA_2:95;
  end;
  then
A20: DataPart s2 = DataPart s5 by A19,SCMFSA6A:38;
  assume
A21: J is_halting_on Initialize s;
  then
A22: ProgramPart s2 halts_on s2 by A15,SCMFSA8A:60;
  JI2 is_closed_on Initialize s by A15,A21,SCMFSA8A:58;
  then
A23: JI2 is_closed_on s2 by Th9;
A24: CurInstr Computation( s3,LifeSpan s2 + 2) = CurInstr Computation( s5,
  LifeSpan s2) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s2,LifeSpan s2)),2) by A1,A23,A12,A17
,A20,Th11
    .= IncAddr(halt SCM+FSA,2) by A22,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A25: ProgramPart s3 halts_on s3 by AMI_1:146;
  now
    let l be Element of NAT;
    assume
A26: l < LifeSpan s2 + 2;
    per cases;
    suppose
      l = 0;
      then CurInstr Computation( s3,l) = CurInstr s3 by AMI_1:13;
      hence CurInstr Computation( s3,l) <> halt SCM+FSA by A8,A4,SCMFSA_2:48
,124;
    end;
    suppose
      l = 1;
      hence CurInstr Computation( s3,l) <> halt SCM+FSA by A14,A7,SCMFSA_2:47
,124;
    end;
    suppose
A27:  l <> 0 & l <> 1;
      assume
A28:  CurInstr Computation( s3,l) = halt SCM+FSA;
      consider n being Nat such that
A29:  l = n + 1 by A27,NAT_1:6;
      n <> 0 by A27,A29;
      then consider l2 being Nat such that
A30:  n = l2 + 1 by NAT_1:6;
      reconsider l2 as Element of NAT by ORDINAL1:def 13;
      InsCode CurInstr Computation( s2,l2) = InsCode IncAddr(CurInstr
      Computation( s2,l2),2) by SCMFSA_4:22
        .= InsCode CurInstr Computation( s5,l2) by A1,A23,A12,A17,A20,Th11
        .= InsCode CurInstr Computation( s3,l2 + (1 + 1)) by AMI_1:51
        .= 0 by A29,A30,A28,SCMFSA_2:124;
      then
A31:  CurInstr Computation( s2,l2) = halt SCM+FSA by SCMFSA_2:122;
      n + 1 < LifeSpan s2 + 1 + 1 by A26,A29;
      then n < LifeSpan s2 + 1 by XREAL_1:8;
      then l2 < LifeSpan s2 by A30,XREAL_1:8;
      hence contradiction by A22,A31,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr Computation( s3,l) = halt SCM+FSA
  holds LifeSpan s2 + 2 <= l;
  then
A32: LifeSpan s3 = LifeSpan s2 + 2 by A24,A25,AMI_1:def 46;
A33: DataPart Result s2 = DataPart Computation( s2,LifeSpan s2) by
AMI_1:122,A22
    .= DataPart Computation( s5,LifeSpan s2) by A1,A23,A12,A17,A20,Th11
    .= DataPart Computation( s3,LifeSpan s2 + 2) by AMI_1:51
    .= DataPart Result s3 by A25,A32,AMI_1:122;
A34: now
    let x be set;
A35: now
      assume
      x in dom (s | A);
      then x in A by RELAT_1:86;
      hence x is Instruction-Location of SCM+FSA by AMI_1:def 4;
    end;
A36: dom Start-At insloc (card I + card J + 3) = {IC SCM+FSA} by FUNCOP_1:19;
A37: IExec(if=0(a,I,J),s) = (Result s3) +* (s | A) by SCMFSA6B:def 1;
A38: IExec(JI2,s) = Result s2 +* s | A by SCMFSA6B:def 1;
    assume
A39: x in dom IExec(if=0(a,I,J),s);
    per cases by A39,SCMFSA6A:35;
    suppose
A40:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A41:  not x in dom Start-At insloc (card I + card J + 3) by A36,TARSKI:def 1;
      thus IExec(if=0(a,I,J),s).x = (Result s3).x by A35,A37,A40,FUNCT_4:12
,SCMFSA_2:84
        .= (Result s2).x by A33,A40,SCMFSA6A:38
        .= IExec(JI2,s).x by A35,A38,A40,FUNCT_4:12,SCMFSA_2:84
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x by A41,
FUNCT_4:12;
    end;
    suppose
A42:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A43:  not x in dom Start-At insloc (card I + card J + 3) by A36,TARSKI:def 1;
      thus IExec(if=0(a,I,J),s).x = (Result s3).x by A35,A37,A42,FUNCT_4:12
,SCMFSA_2:85
        .= (Result s2).x by A33,A42,SCMFSA6A:38
        .= IExec(JI2,s).x by A35,A38,A42,FUNCT_4:12,SCMFSA_2:85
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x by A43,
FUNCT_4:12;
    end;
    suppose
A44:  x = IC SCM+FSA;
      then
A45:  x in dom Start-At insloc (card I + card J + 3) by A36,TARSKI:def 1;
A46:  IC Result s2 = IC IExec(JI2,s) by A35,A38,A44,AMI_1:48,FUNCT_4:12
        .= insloc (card I + card J + 1) by A15,A21,SCMFSA8A:61;
      thus IExec(if=0(a,I,J),s).x = (Result s3).x by A35,A37,A44,AMI_1:48
,FUNCT_4:12
        .= Computation( s3,LifeSpan s2 + 2).x by A25,A32,AMI_1:122
        .= IC Computation( s5,LifeSpan s2) by A44,AMI_1:51
        .= IC Computation( s2,LifeSpan s2) + 2 by A1,A23,A12,A17,A20,Th11
        .= IC Result s2 + 2 by AMI_1:122,A22
        .= (Start-At (insloc (card I + card J + 1) + 2)).IC SCM+FSA by A46,
FUNCOP_1:87
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x by A44,A45
,FUNCT_4:14;
    end;
    suppose
A47:  x is Instruction-Location of SCM+FSA;
      then x <> IC SCM+FSA by AMI_1:48;
      then
A48:  not x in dom Start-At insloc (card I + card J + 3) by A36,TARSKI:def 1;
A49:  x in NAT by A47,AMI_1:def 4;
      hence IExec(if=0(a,I,J),s).x = (s | A).x by A11,A37,FUNCT_4:14
        .= IExec(JI2,s).x by A11,A38,A49,FUNCT_4:14
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x by A48,
FUNCT_4:12;
    end;
  end;
  dom IExec(if=0(a,I,J),s) = the carrier of SCM+FSA by AMI_1:79
    .= dom (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)) by AMI_1:79;
  hence
  IExec(if=0(a,I,J),s) = IExec(JI2,s) +* Start-At insloc (card I + card J
  + 3) by A34,FUNCT_1:9
    .= IExec(J,s) +* Start-At insloc (card I + card J + 1) +* Start-At
  insloc (card I + card J + 3) by A15,A21,SCMFSA8A:62
    .= IExec(J,s) +* Start-At insloc (card I + card J + 3) by AMI_1:141;
end;

theorem Th20:
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds if=0(a,I,J) is parahalting & (s.
  a = 0 implies IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I +
card J + 3)) & (s.a <> 0 implies IExec(if=0(a,I,J),s) = IExec(J,s) +* Start-At
  insloc (card I + card J + 3))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
A1: I is_halting_on Initialize s by SCMFSA7B:25;
  now
    let s be State of SCM+FSA;
A2: I is_closed_on s by SCMFSA7B:24;
A3: I is_halting_on s by SCMFSA7B:25;
A4: J is_halting_on s by SCMFSA7B:25;
A5: J is_closed_on s by SCMFSA7B:24;
    assume
    if=0(a,I,J) +* Start-At insloc 0 c= s;
    then
A6: s = s +* (if=0(a,I,J) +* Start-At insloc 0) by FUNCT_4:79;
    per cases;
    suppose
      s.a = 0;
      then if=0(a,I,J) is_halting_on s by A2,A3,Th16;
      hence ProgramPart s halts_on s by A6,SCMFSA7B:def 8;
    end;
    suppose
      s.a <> 0;
      then if=0(a,I,J) is_halting_on s by A5,A4,Th18;
      hence ProgramPart s halts_on s by A6,SCMFSA7B:def 8;
    end;
  end;
  then if=0(a,I,J) +* Start-At insloc 0 is halting by AMI_1:def 26;
  hence if=0(a,I,J) is parahalting by SCMFSA6B:def 3;
  I is_closed_on Initialize s by SCMFSA7B:24;
  hence s.a = 0 implies IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At insloc (
  card I + card J + 3) by A1,Th17;
A7: J is_halting_on Initialize s by SCMFSA7B:25;
  J is_closed_on Initialize s by SCMFSA7B:24;
  hence thesis by A7,Th19;
end;

theorem Th21:
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds IC IExec(if=0(a,I,J),s) = insloc
(card I + card J + 3) & (s.a = 0 implies ((for d being Int-Location holds IExec
  (if=0(a,I,J),s).d = IExec(I,s).d) & for f being FinSeq-Location holds IExec(
  if=0(a,I,J),s).f = IExec(I,s).f)) & (s.a <> 0 implies ((for d being
  Int-Location holds IExec(if=0(a,I,J),s).d = IExec(J,s).d) & for f being
  FinSeq-Location holds IExec(if=0(a,I,J),s).f = IExec(J,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby
    per cases;
    suppose
      s.a = 0;
      then
      IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I + card
      J + 3) by Th20;
      hence IC IExec(if=0(a,I,J),s) = insloc (card I + card J + 3) by AMI_1:111
;
    end;
    suppose
      s.a <> 0;
      then
      IExec(if=0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card I + card
      J + 3) by Th20;
      hence IC IExec(if=0(a,I,J),s) = insloc (card I + card J + 3) by AMI_1:111
;
    end;
  end;
  hereby
    assume
    s.a = 0;
    then
A1: IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I + card J
    + 3) by Th20;
    hereby
      let d be Int-Location;
      not d in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:9;
      hence IExec(if=0(a,I,J),s).d = IExec(I,s).d by A1,FUNCT_4:12;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:10;
    hence IExec(if=0(a,I,J),s).f = IExec(I,s).f by A1,FUNCT_4:12;
  end;
  assume
  s.a <> 0;
  then
A2: IExec(if=0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card I + card J +
  3) by Th20;
  hereby
    let d be Int-Location;
    not d in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:9;
    hence IExec(if=0(a,I,J),s).d = IExec(J,s).d by A2,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:10;
  hence thesis by A2,FUNCT_4:12;
end;

theorem Th22:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a > 0 & I is_closed_on s & I is_halting_on s
  holds if>0(a,I,J) is_closed_on s & if>0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = s +* (I1 +* Start-At insloc 0);
  set s3 = s +* (if>0(a,I,J) +* Start-At insloc 0);
  set s4 = Computation( s3,1);
  set i = a >0_goto insloc (card J + 3);
A1: not a in dom (if>0(a,I,J) +* Start-At insloc 0) by SCMFSA6B:12;
A2: insloc 0 in dom if>0(a,I,J) by Lm2;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
  then
A3: s3.insloc 0 = (if>0(a,I,J) +* Start-At insloc 0).insloc 0 by A2,FUNCT_4:14
    .= if>0(a,I,J).insloc 0 by A2,SCMFSA6B:7
    .= i by Lm3;
  IC SCM+FSA in dom (if>0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
  then
A4: IC s3 = (if>0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A5: if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  if>0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  then
A6: if>0(a,I,J) c= s3 by A5,XBOOLE_1:1;
A7: if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67;
  card (i ';' J ';' Goto insloc (card I + 1)) = card (Macro i ';' J ';'
  Goto insloc (card I + 1)) by SCMFSA6A:def 6
    .= card (Macro i ';' J) + card Goto insloc (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by SCMFSA7B:6
    .= card J + (2 + 1);
  then ProgramPart Relocated(I1,card J + 3) c= if>0(a,I,J) by A7,Lm1;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A6,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(I1,card J + 3)] c= s4 by AMI_1:99;
  then
A8: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
A9: Computation( s3,0 + 1) = Following Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A4,A3;
A10: DataPart s1 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A11: now
    let f be FinSeq-Location;
    thus s1.f = s3.f by A10,SCMFSA6A:38
      .= s4.f by A9,SCMFSA_2:97;
  end;
  now
    let a be Int-Location;
    thus s1.a = s3.a by A10,SCMFSA6A:38
      .= s4.a by A9,SCMFSA_2:97;
  end;
  then
A12: DataPart s1 = DataPart s4 by A11,SCMFSA6A:38;
  assume
  s.a > 0;
  then s3.a > 0 by A1,FUNCT_4:12;
  then
A13: IC Computation(s3,1) = insloc (card J + 3) by A9,SCMFSA_2:97;
  assume
A14: I is_closed_on s;
  assume
A15: I is_halting_on s;
  then
A16: I1 is_closed_on s by A14,SCMFSA8A:46;
  I1 is_halting_on s by A14,A15,SCMFSA8A:46;
  then
A17: ProgramPart s1 halts_on s1 by SCMFSA7B:def 8;
  DataPart s = DataPart s1 by SCMFSA8A:11;
  then
A18: I1 is_closed_on s1 by A16,Th6;
A19: I1 +* Start-At insloc 0 c= s1 by FUNCT_4:26;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A20:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Computation( s1,k1) as Element of NAT by
ORDINAL1:def 13;
      insloc m in dom I1 by A16,SCMFSA7B:def 7;
      then
A21:  m < card I1 by SCMFSA6A:15;
A22:  card I1 = card I + 1 by SCMFSA6A:61,SCMFSA8A:17;
      card if>0(a,I,J) = card I + card J + 4 by Th15
        .= card J + 3 + card I1 by A22;
      then
A23:  m + (card J + 3) < card if>0(a,I,J) by A21,XREAL_1:8;
      IC Computation(s3,k) = IC Computation( s4,k1) by A20,AMI_1:51
        .= insloc (m + (card J + 3)) by A19,A18,A8,A13,A12,Th11;
      hence IC Computation(s3,k) in dom if>0(a,I,J) by A23,SCMFSA6A:15;
    end;
    suppose
      k = 0;
      hence IC Computation(s3,k) in dom if>0(a,I,J) by A2,A4,AMI_1:13;
    end;
  end;
  hence if>0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
  CurInstr Computation( s3,LifeSpan s1 + 1) = CurInstr Computation( s4,
  LifeSpan s1) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s1,LifeSpan s1)),(card J + 3)) by A19
,A18,A8,A13,A12,Th11
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A17,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th23:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a > 0 & I is_closed_on
Initialize s & I is_halting_on Initialize s holds IExec(if>0(a,I,J),s) = IExec(
  I,s) +* Start-At insloc (card I + card J + 3)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  set I1 = I ';' Stop SCM+FSA;
  set s1 = s +* Initialized I1;
  set s3 = s +* Initialized if>0(a,I,J);
  set s4 = Computation( s3,1);
  set i = a >0_goto insloc (card J + 3);
A1: I1 +* Start-At insloc 0 c= s1 by FUNCT_4:26,SCMFSA6B:8;
A2: if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67;
A3: insloc 0 in dom if>0(a,I,J) by Lm2;
  if>0(a,I,J) c= Initialized if>0(a,I,J) by SCMFSA6A:26;
  then dom if>0(a,I,J) c= dom Initialized if>0(a,I,J) by GRFUNC_1:8;
  then
A4: s3.insloc 0 = (Initialized if>0(a,I,J)).insloc 0 by A3,FUNCT_4:14
    .= if>0(a,I,J).insloc 0 by A3,SCMFSA6A:50
    .= i by Lm3;
  IC SCM+FSA in dom Initialized if>0(a,I,J) by SCMFSA6A:24;
  then
A5: IC s3 = (Initialized if>0(a,I,J)).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SCMFSA6A:46;
A6: Computation( s3,0 + 1) = Following Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A5,A4;
A7: if>0(a,I,J) c= Initialized if>0(a,I,J) by SCMFSA6A:26;
  Initialized if>0(a,I,J) c= s3 by FUNCT_4:26;
  then
A8: if>0(a,I,J) c= s3 by A7,XBOOLE_1:1;
A9: not a in dom Initialized if>0(a,I,J) by SCMFSA6A:48;
A10: dom (s | A) = A by SCMFSA8A:3;
  assume
  s.a > 0;
  then s3.a > 0 by A9,FUNCT_4:12;
  then
A11: IC Computation(s3,1) = insloc (card J + 3) by A6,SCMFSA_2:97;
A12: DataPart s1 = DataPart s3 by SCMFSA6A:39,53;
A13: now
    let f be FinSeq-Location;
    thus s1.f = s3.f by A12,SCMFSA6A:38
      .= s4.f by A6,SCMFSA_2:97;
  end;
  now
    let a be Int-Location;
    thus s1.a = s3.a by A12,SCMFSA6A:38
      .= s4.a by A6,SCMFSA_2:97;
  end;
  then
A14: DataPart s1 = DataPart s4 by A13,SCMFSA6A:38;
  card (i ';' J ';' Goto insloc (card I + 1)) = card (Macro i ';' J ';'
  Goto insloc (card I + 1)) by SCMFSA6A:def 6
    .= card (Macro i ';' J) + card Goto insloc (card I + 1) by SCMFSA6A:61
    .= card (Macro i ';' J) + 1 by SCMFSA8A:29
    .= card Macro i + card J + 1 by SCMFSA6A:61
    .= card J + 2 + 1 by SCMFSA7B:6
    .= card J + (2 + 1);
  then ProgramPart Relocated(I1,card J + 3) c= if>0(a,I,J) by A2,Lm1;
  then ProgramPart Relocated(I1,card J + 3) c= s3 by A8,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(I1,card J + 3)] c= s4 by AMI_1:99;
  then
A15: ProgramPart Relocated(I1,card J + 3) c= s4 by AMI_1:105;
  assume
A16: I is_closed_on Initialize s;
  assume
A17: I is_halting_on Initialize s;
  then
A18: ProgramPart s1 halts_on s1 by A16,SCMFSA8A:55;
  I1 is_closed_on Initialize s by A16,A17,SCMFSA8A:46;
  then
A19: I1 is_closed_on s1 by Th9;
A20: CurInstr Computation( s3,LifeSpan s1 + 1) = CurInstr Computation( s4,
  LifeSpan s1) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s1,LifeSpan s1)),(card J + 3)) by A1,A19
,A15,A11,A14,Th11
    .= IncAddr(halt SCM+FSA,(card J + 3)) by A18,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A21: ProgramPart s3 halts_on s3 by AMI_1:146;
  now
    let l be Element of NAT;
    assume
A22: l < LifeSpan s1 + 1;
    per cases;
    suppose
      l = 0;
      then CurInstr Computation( s3,l) = CurInstr s3 by AMI_1:13;
      hence CurInstr Computation( s3,l) <> halt SCM+FSA by A5,A4,SCMFSA_2:49
,124;
    end;
    suppose
      l <> 0;
      then consider n being Nat such that
A23:  l = n + 1 by NAT_1:6;
      assume
A24:  CurInstr Computation( s3,l) = halt SCM+FSA;
      reconsider n as Element of NAT by ORDINAL1:def 13;
      InsCode CurInstr Computation( s1,n) = InsCode IncAddr(CurInstr
      Computation( s1,n),(card J + 3)) by SCMFSA_4:22
        .= InsCode CurInstr Computation( s4,n) by A1,A19,A15,A11,A14,Th11
        .= 0 by A23,A24,AMI_1:51,SCMFSA_2:124;
      then
A25:  CurInstr Computation( s1,n) = halt SCM+FSA by SCMFSA_2:122;
      n < LifeSpan s1 by A22,A23,XREAL_1:8;
      hence contradiction by A18,A25,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr Computation( s3,l) = halt SCM+FSA
  holds LifeSpan s1 + 1 <= l;
  then
A26: LifeSpan s3 = LifeSpan s1 + 1 by A20,A21,AMI_1:def 46;
 ProgramPart s1 halts_on s1 by A16,A17,SCMFSA8A:55;
  then
A27: DataPart Result s1 = DataPart Computation( s1,LifeSpan s1) by
AMI_1:122
    .= DataPart Computation( s4,LifeSpan s1) by A1,A19,A15,A11,A14,Th11
    .= DataPart Computation( s3,LifeSpan s1 + 1) by AMI_1:51
    .= DataPart Result s3 by A21,A26,AMI_1:122;
A28: now
    let x be set;
A29: now
      assume
      x in dom (s | A);
      then x in A by RELAT_1:86;
      hence x is Instruction-Location of SCM+FSA by AMI_1:def 4;
    end;
A30: dom Start-At insloc (card I + card J + 3) = {IC SCM+FSA} by FUNCOP_1:19;
A31: IExec(if>0(a,I,J),s) = (Result s3) +* (s | A) by SCMFSA6B:def 1;
A32: IExec(I1,s) = Result s1 +* s | A by SCMFSA6B:def 1;
    assume
A33: x in dom IExec(if>0(a,I,J),s);
    per cases by A33,SCMFSA6A:35;
    suppose
A34:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A35:  not x in dom Start-At insloc (card I + card J + 3) by A30,TARSKI:def 1;
      thus IExec(if>0(a,I,J),s).x = (Result s3).x by A29,A31,A34,FUNCT_4:12
,SCMFSA_2:84
        .= (Result s1).x by A27,A34,SCMFSA6A:38
        .= IExec(I1,s).x by A29,A32,A34,FUNCT_4:12,SCMFSA_2:84
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x by A35,
FUNCT_4:12;
    end;
    suppose
A36:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A37:  not x in dom Start-At insloc (card I + card J + 3) by A30,TARSKI:def 1;
      thus IExec(if>0(a,I,J),s).x = (Result s3).x by A29,A31,A36,FUNCT_4:12
,SCMFSA_2:85
        .= (Result s1).x by A27,A36,SCMFSA6A:38
        .= IExec(I1,s).x by A29,A32,A36,FUNCT_4:12,SCMFSA_2:85
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x by A37,
FUNCT_4:12;
    end;
    suppose
A38:  x = IC SCM+FSA;
      then
A39:  x in dom Start-At insloc (card I + card J + 3) by A30,TARSKI:def 1;
A40:  IC Result s1 = IExec(I1,s).IC SCM+FSA by A29,A32,A38,AMI_1:48,FUNCT_4:12
        .= IC (IExec(I,s) +* Start-At insloc card I) by A16,A17,SCMFSA8A:57
        .= insloc card I by AMI_1:111;
X:    ProgramPart s1 halts_on s1 by A16,A17,SCMFSA8A:55;
      thus IExec(if>0(a,I,J),s).x = (Result s3).x by A29,A31,A38,AMI_1:48
,FUNCT_4:12
        .= Computation( s3,LifeSpan s1 + 1).x by A21,A26,AMI_1:122
        .= IC Computation( s4,LifeSpan s1) by A38,AMI_1:51
        .= IC Computation( s1,LifeSpan s1) + (card J + 3) by A1,A19,A15,A11,A14
,Th11
        .= IC Result s1 + (card J + 3) by AMI_1:122,X
        .= (Start-At (insloc card I + (card J + 3))).IC SCM+FSA by A40,
FUNCOP_1:87
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x by A38,A39,
FUNCT_4:14;
    end;
    suppose
A41:  x is Instruction-Location of SCM+FSA;
      then x <> IC SCM+FSA by AMI_1:48;
      then
A42:  not x in dom Start-At insloc (card I + card J + 3) by A30,TARSKI:def 1;
A43:  x in NAT by A41,AMI_1:def 4;
      hence IExec(if>0(a,I,J),s).x = (s | A).x by A10,A31,FUNCT_4:14
        .= IExec(I1,s).x by A10,A32,A43,FUNCT_4:14
        .= (IExec(I1,s) +* Start-At insloc (card I + card J + 3)).x by A42,
FUNCT_4:12;
    end;
  end;
  dom IExec(if>0(a,I,J),s) = the carrier of SCM+FSA by AMI_1:79
    .= dom (IExec(I1,s) +* Start-At insloc (card I + card J + 3)) by AMI_1:79;
  hence IExec(if>0(a,I,J),s) = IExec(I1,s) +* Start-At insloc (card I + card J
  + 3) by A28,FUNCT_1:9
    .= IExec(I,s) +* Start-At insloc card I +* Start-At insloc (card I +
  card J + 3) by A16,A17,SCMFSA8A:57
    .= IExec(I,s) +* Start-At insloc (card I + card J + 3) by AMI_1:141;
end;

theorem Th24:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a <= 0 & J is_closed_on s & J is_halting_on
  s holds if>0(a,I,J) is_closed_on s & if>0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = s +* (JI2 +* Start-At insloc 0);
  set s3 = s +* (if>0(a,I,J) +* Start-At insloc 0);
  set s4 = Computation( s3,1);
  set s5 = Computation(s3,2);
  set i = a >0_goto insloc (card J + 3);
A1: JI2 +* Start-At insloc 0 c= s2 by FUNCT_4:26;
  IC SCM+FSA in dom (if>0(a,I,J) +* Start-At insloc 0) by SF_MASTR:65;
  then
A2: IC s3 = (if>0(a,I,J) +* Start-At insloc 0).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SF_MASTR:66;
A3: if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  if>0(a,I,J) +* Start-At insloc 0 c= s3 by FUNCT_4:26;
  then
A4: if>0(a,I,J) c= s3 by A3,XBOOLE_1:1;
A5: if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' JI2 by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:def 6;
  then ProgramPart Relocated(JI2,card Macro i) c= if>0(a,I,J) by Lm1;
  then ProgramPart Relocated(JI2,2) c= if>0(a,I,J) by SCMFSA7B:6;
  then ProgramPart Relocated(JI2,2) c= s3 by A4,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(JI2,2)] c= s5 by AMI_1:99;
  then
A6: ProgramPart Relocated(JI2,2) c= s5 by AMI_1:105;
A7: not a in dom (if>0(a,I,J) +* Start-At insloc 0) by SCMFSA6B:12;
A8: insloc 0 in dom if>0(a,I,J) by Lm2;
  if>0(a,I,J) c= if>0(a,I,J) +* Start-At insloc 0 by SCMFSA8A:9;
  then
A9: dom if>0(a,I,J) c= dom (if>0(a,I,J) +* Start-At insloc 0) by GRFUNC_1:8;
  then
A10: s3.insloc 0 = (if>0(a,I,J) +* Start-At insloc 0).insloc 0 by A8,FUNCT_4:14
    .= if>0(a,I,J).insloc 0 by A8,SCMFSA6B:7
    .= i by Lm3;
A11: insloc 1 in dom if>0(a,I,J) by Lm2;
A12: Computation( s3,0 + 1) = Following Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A2,A10;
  assume
  s.a <= 0;
  then s3.a <= 0 by A7,FUNCT_4:12;
  then
A13: IC Computation(s3,1) = Next insloc 0 by A2,A12,SCMFSA_2:97
    .= insloc (0 + 1);
A14: Computation(s3,1).insloc 1 = s3.insloc 1 by AMI_1:54
    .= (if>0(a,I,J) +* Start-At insloc 0).insloc 1 by A9,A11,FUNCT_4:14
    .= if>0(a,I,J).insloc 1 by A11,SCMFSA6B:7
    .= goto insloc 2 by Lm3;
  assume
A15: J is_closed_on s;
A16: Computation( s3,1 + 1) = Following s4 by AMI_1:14
    .= Exec(goto insloc 2,s4) by A13,A14;
A17: DataPart s2 = DataPart s3 by SCMFSA6A:39,SCMFSA8A:14;
A18: now
    let f be FinSeq-Location;
    thus s2.f = s3.f by A17,SCMFSA6A:38
      .= Computation(s3,1).f by A12,SCMFSA_2:97
      .= s5.f by A16,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s2.a = s3.a by A17,SCMFSA6A:38
      .= Computation(s3,1).a by A12,SCMFSA_2:97
      .= s5.a by A16,SCMFSA_2:95;
  end;
  then
A19: DataPart s2 = DataPart s5 by A18,SCMFSA6A:38;
  assume
A20: J is_halting_on s;
  then
A21: JI2 is_closed_on s by A15,SCMFSA8A:58;
  then
A22: JI2 is_closed_on s2 by Th10;
A23: ProgramPart s2 halts_on s2 by A15,A20,SCMFSA8A:59;
A24: IC s5 = insloc 2 by A16,SCMFSA_2:95;
  now
    let k be Element of NAT;
    k = 0 or 0 + 1 < k + 1 by XREAL_1:8;
    then
A25: k = 0 or 1 <= k by NAT_1:13;
    per cases by A25,XXREAL_0:1;
    suppose
A26:  1 < k;
      then consider k1 being Nat such that
A27:  k1 + 1 = k by NAT_1:6;
      0 + 1 < k1 + 1 by A26,A27;
      then consider k2 being Nat such that
A28:  k2 + 1 = k1 by NAT_1:6;
      reconsider k1,k2 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Computation( s2,k2) as Element of NAT by
ORDINAL1:def 13;
A29:  card if>0(a,I,J) = card Macro i + card JI2 by A5,SCMFSA6A:61
        .= 2 + card JI2 by SCMFSA7B:6;
      insloc m in dom JI2 by A21,SCMFSA7B:def 7;
      then m < card JI2 by SCMFSA6A:15;
      then
A30:  m + 2 < card if>0(a,I,J) by A29,XREAL_1:8;
      IC Computation(s3,k) = IC Computation( s4,k1) by A27,AMI_1:51
        .= IC Computation( Computation( s4,1),k2) by A28,AMI_1:51
        .= IC Computation( Computation( s3,1 + 1),k2) by AMI_1:51
        .= insloc (m + 2) by A1,A22,A6,A24,A19,Th11;
      hence IC Computation(s3,k) in dom if>0(a,I,J) by A30,SCMFSA6A:15;
    end;
    suppose
      k = 0;
      hence IC Computation(s3,k) in dom if>0(a,I,J) by A8,A2,AMI_1:13;
    end;
    suppose
      k = 1;
      hence IC Computation(s3,k) in dom if>0(a,I,J) by A13,Lm2;
    end;
  end;
  hence if>0(a,I,J) is_closed_on s by SCMFSA7B:def 7;
  CurInstr Computation( s3,LifeSpan s2 + 2) = CurInstr Computation( s5,
  LifeSpan s2) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s2,LifeSpan s2)),2) by A1,A22,A6,A24,A19
,Th11
    .= IncAddr(halt SCM+FSA,2) by A23,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by SCMFSA7B:def 8;
end;

theorem Th25:
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <= 0 & J is_closed_on
Initialize s & J is_halting_on Initialize s holds IExec(if>0(a,I,J),s) = IExec(
  J,s) +* Start-At insloc (card I + card J + 3)
proof
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  let s be State of SCM+FSA;
  set I1 = I ';' Stop SCM+FSA;
  set JI2 = J ';' Goto insloc (card I + 1) ';' I ';' Stop SCM+FSA;
  set s2 = s +* Initialized JI2;
  set s3 = s +* Initialized if>0(a,I,J);
  set s4 = Computation( s3,1);
  set s5 = Computation(s3,2);
  set i = a >0_goto insloc (card J + 3);
A1: JI2 +* Start-At insloc 0 c= s2 by FUNCT_4:26,SCMFSA6B:8;
  if>0(a,I,J) c= Initialized if>0(a,I,J) by SCMFSA6A:26;
  then
A2: dom if>0(a,I,J) c= dom Initialized if>0(a,I,J) by GRFUNC_1:8;
A3: insloc 0 in dom if>0(a,I,J) by Lm2;
  then
A4: s3.insloc 0 = (Initialized if>0(a,I,J)).insloc 0 by A2,FUNCT_4:14
    .= if>0(a,I,J).insloc 0 by A3,SCMFSA6A:50
    .= i by Lm3;
A5: if>0(a,I,J) c= Initialized if>0(a,I,J) by SCMFSA6A:26;
A6: insloc 1 in dom if>0(a,I,J) by Lm2;
A7: Computation(s3,1).insloc 1 = s3.insloc 1 by AMI_1:54
    .= (Initialized if>0(a,I,J)).insloc 1 by A2,A6,FUNCT_4:14
    .= if>0(a,I,J).insloc 1 by A6,SCMFSA6A:50
    .= goto insloc 2 by Lm3;
  IC SCM+FSA in dom Initialized if>0(a,I,J) by SCMFSA6A:24;
  then
A8: IC s3 = (Initialized if>0(a,I,J)).IC SCM+FSA by FUNCT_4:14
    .= insloc 0 by SCMFSA6A:46;
  if>0(a,I,J) = i ';' J ';' Goto insloc (card I + 1) ';' I1 by SCMFSA6A:67
    .= i ';' J ';' (Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' (J ';' (Goto insloc (card I + 1) ';' I1)) by SCMFSA6A:71
    .= i ';' (J ';' Goto insloc (card I + 1) ';' I1) by SCMFSA6A:67
    .= i ';' JI2 by SCMFSA6A:67
    .= Macro i ';' JI2 by SCMFSA6A:def 6;
  then ProgramPart Relocated(JI2,card Macro i) c= if>0(a,I,J) by Lm1;
  then
A9: ProgramPart Relocated(JI2,2) c= if>0(a,I,J) by SCMFSA7B:6;
A10: not a in dom Initialized if>0(a,I,J) by SCMFSA6A:48;
A11: dom (s | A) = dom s /\ A by RELAT_1:90
    .= (D \/ {IC SCM+FSA} \/ A) /\ A by SCMFSA6A:34
    .= A by XBOOLE_1:21;
  Initialized if>0(a,I,J) c= s3 by FUNCT_4:26;
  then if>0(a,I,J) c= s3 by A5,XBOOLE_1:1;
  then ProgramPart Relocated(JI2,2) c= s3 by A9,XBOOLE_1:1;
  then ProgramPart [ProgramPart Relocated(JI2,2)] c= s5 by AMI_1:99;
  then
A12: ProgramPart Relocated(JI2,2) c= s5 by AMI_1:105;
A13: Computation( s3,0 + 1) = Following Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i,s3) by A8,A4;
  assume
  s.a <= 0;
  then s3.a <= 0 by A10,FUNCT_4:12;
  then
A14: IC Computation(s3,1) = Next insloc 0 by A8,A13,SCMFSA_2:97
    .= insloc (0 + 1);
  assume
A15: J is_closed_on Initialize s;
A16: Computation( s3,1 + 1) = Following s4 by AMI_1:14
    .= Exec(goto insloc 2,s4) by A14,A7;
  then
A17: IC s5 = insloc 2 by SCMFSA_2:95;
A18: DataPart s2 = DataPart s3 by SCMFSA6A:39,53;
A19: now
    let f be FinSeq-Location;
    thus s2.f = s3.f by A18,SCMFSA6A:38
      .= Computation(s3,1).f by A13,SCMFSA_2:97
      .= s5.f by A16,SCMFSA_2:95;
  end;
  now
    let a be Int-Location;
    thus s2.a = s3.a by A18,SCMFSA6A:38
      .= Computation(s3,1).a by A13,SCMFSA_2:97
      .= s5.a by A16,SCMFSA_2:95;
  end;
  then
A20: DataPart s2 = DataPart s5 by A19,SCMFSA6A:38;
  assume
A21: J is_halting_on Initialize s;
  then
A22: ProgramPart s2 halts_on s2 by A15,SCMFSA8A:60;
  JI2 is_closed_on Initialize s by A15,A21,SCMFSA8A:58;
  then
A23: JI2 is_closed_on s2 by Th9;
A24: CurInstr Computation( s3,LifeSpan s2 + 2) = CurInstr Computation( s5,
  LifeSpan s2) by AMI_1:51
    .= IncAddr(CurInstr ( Computation( s2,LifeSpan s2)),2) by A1,A23,A12,A17
,A20,Th11
    .= IncAddr(halt SCM+FSA,2) by A22,AMI_1:def 46
    .= halt SCM+FSA by SCMFSA_4:8;
  then
A25: ProgramPart s3 halts_on s3 by AMI_1:146;
  now
    let l be Element of NAT;
    assume
A26: l < LifeSpan s2 + 2;
    per cases;
    suppose
      l = 0;
      then CurInstr Computation( s3,l) = CurInstr s3 by AMI_1:13;
      hence CurInstr Computation( s3,l) <> halt SCM+FSA by A8,A4,SCMFSA_2:49
,124;
    end;
    suppose
      l = 1;
      hence CurInstr Computation( s3,l) <> halt SCM+FSA by A14,A7,SCMFSA_2:47
,124;
    end;
    suppose
A27:  l <> 0 & l <> 1;
      assume
A28:  CurInstr Computation( s3,l) = halt SCM+FSA;
      consider n being Nat such that
A29:  l = n + 1 by A27,NAT_1:6;
      n <> 0 by A27,A29;
      then consider l2 being Nat such that
A30:  n = l2 + 1 by NAT_1:6;
      reconsider l2 as Element of NAT by ORDINAL1:def 13;
      InsCode CurInstr Computation( s2,l2) = InsCode IncAddr(CurInstr
      Computation( s2,l2),2) by SCMFSA_4:22
        .= InsCode CurInstr Computation( s5,l2) by A1,A23,A12,A17,A20,Th11
        .= InsCode CurInstr Computation( s3,l2 + (1 + 1)) by AMI_1:51
        .= 0 by A29,A30,A28,SCMFSA_2:124;
      then
A31:  CurInstr Computation( s2,l2) = halt SCM+FSA by SCMFSA_2:122;
      n + 1 < LifeSpan s2 + 1 + 1 by A26,A29;
      then n < LifeSpan s2 + 1 by XREAL_1:8;
      then l2 < LifeSpan s2 by A30,XREAL_1:8;
      hence contradiction by A22,A31,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr Computation( s3,l) = halt SCM+FSA
  holds LifeSpan s2 + 2 <= l;
  then
A32: LifeSpan s3 = LifeSpan s2 + 2 by A24,A25,AMI_1:def 46;
A33: DataPart Result s2 = DataPart Computation( s2,LifeSpan s2) by
AMI_1:122,A22
    .= DataPart Computation( s5,LifeSpan s2) by A1,A23,A12,A17,A20,Th11
    .= DataPart Computation( s3,LifeSpan s2 + 2) by AMI_1:51
    .= DataPart Result s3 by A25,A32,AMI_1:122;
A34: now
    let x be set;
A35: now
      assume
      x in dom (s | A);
      then x in A by RELAT_1:86;
      hence x is Instruction-Location of SCM+FSA by AMI_1:def 4;
    end;
A36: dom Start-At insloc (card I + card J + 3) = {IC SCM+FSA} by FUNCOP_1:19;
A37: IExec(if>0(a,I,J),s) = (Result s3) +* (s | A) by SCMFSA6B:def 1;
A38: IExec(JI2,s) = Result s2 +* s | A by SCMFSA6B:def 1;
    assume
A39: x in dom IExec(if>0(a,I,J),s);
    per cases by A39,SCMFSA6A:35;
    suppose
A40:  x is Int-Location;
      then x <> IC SCM+FSA by SCMFSA_2:81;
      then
A41:  not x in dom Start-At insloc (card I + card J + 3) by A36,TARSKI:def 1;
      thus IExec(if>0(a,I,J),s).x = (Result s3).x by A35,A37,A40,FUNCT_4:12
,SCMFSA_2:84
        .= (Result s2).x by A33,A40,SCMFSA6A:38
        .= IExec(JI2,s).x by A35,A38,A40,FUNCT_4:12,SCMFSA_2:84
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x by A41,
FUNCT_4:12;
    end;
    suppose
A42:  x is FinSeq-Location;
      then x <> IC SCM+FSA by SCMFSA_2:82;
      then
A43:  not x in dom Start-At insloc (card I + card J + 3) by A36,TARSKI:def 1;
      thus IExec(if>0(a,I,J),s).x = (Result s3).x by A35,A37,A42,FUNCT_4:12
,SCMFSA_2:85
        .= (Result s2).x by A33,A42,SCMFSA6A:38
        .= IExec(JI2,s).x by A35,A38,A42,FUNCT_4:12,SCMFSA_2:85
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x by A43,
FUNCT_4:12;
    end;
    suppose
A44:  x = IC SCM+FSA;
      then
A45:  x in dom Start-At insloc (card I + card J + 3) by A36,TARSKI:def 1;
A46:  IC Result s2 = IC IExec(JI2,s) by A35,A38,A44,AMI_1:48,FUNCT_4:12
        .= insloc (card I + card J + 1) by A15,A21,SCMFSA8A:61;
      thus IExec(if>0(a,I,J),s).x = (Result s3).x by A35,A37,A44,AMI_1:48
,FUNCT_4:12
        .= Computation( s3,LifeSpan s2 + 2).x by A25,A32,AMI_1:122
        .= IC Computation( s5,LifeSpan s2) by A44,AMI_1:51
        .= IC Computation( s2,LifeSpan s2) + 2 by A1,A23,A12,A17,A20,Th11
        .= IC Result s2 + 2 by AMI_1:122,A22
        .= (Start-At (insloc (card I + card J + 1) + 2)).IC SCM+FSA by A46,
FUNCOP_1:87
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x by A44,A45
,FUNCT_4:14;
    end;
    suppose
A47:  x is Instruction-Location of SCM+FSA;
      then x <> IC SCM+FSA by AMI_1:48;
      then
A48:  not x in dom Start-At insloc (card I + card J + 3) by A36,TARSKI:def 1;
A49:  x in NAT by A47,AMI_1:def 4;
      hence IExec(if>0(a,I,J),s).x = (s | A).x by A11,A37,FUNCT_4:14
        .= IExec(JI2,s).x by A11,A38,A49,FUNCT_4:14
        .= (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)).x by A48,
FUNCT_4:12;
    end;
  end;
  dom IExec(if>0(a,I,J),s) = the carrier of SCM+FSA by AMI_1:79
    .= dom (IExec(JI2,s) +* Start-At insloc (card I + card J + 3)) by AMI_1:79;
  hence
  IExec(if>0(a,I,J),s) = IExec(JI2,s) +* Start-At insloc (card I + card J
  + 3) by A34,FUNCT_1:9
    .= IExec(J,s) +* Start-At insloc (card I + card J + 1) +* Start-At
  insloc (card I + card J + 3) by A15,A21,SCMFSA8A:62
    .= IExec(J,s) +* Start-At insloc (card I + card J + 3) by AMI_1:141;
end;

theorem Th26:
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds if>0(a,I,J) is parahalting & (s.
  a > 0 implies IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I +
card J + 3)) & (s.a <= 0 implies IExec(if>0(a,I,J),s) = IExec(J,s) +* Start-At
  insloc (card I + card J + 3))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
A1: I is_halting_on Initialize s by SCMFSA7B:25;
  now
    let s be State of SCM+FSA;
A2: I is_closed_on s by SCMFSA7B:24;
A3: I is_halting_on s by SCMFSA7B:25;
A4: J is_halting_on s by SCMFSA7B:25;
A5: J is_closed_on s by SCMFSA7B:24;
    assume
    if>0(a,I,J) +* Start-At insloc 0 c= s;
    then
A6: s = s +* (if>0(a,I,J) +* Start-At insloc 0) by FUNCT_4:79;
    per cases;
    suppose
      s.a > 0;
      then if>0(a,I,J) is_halting_on s by A2,A3,Th22;
      hence ProgramPart s halts_on s by A6,SCMFSA7B:def 8;
    end;
    suppose
      s.a <= 0;
      then if>0(a,I,J) is_halting_on s by A5,A4,Th24;
      hence ProgramPart s halts_on s by A6,SCMFSA7B:def 8;
    end;
  end;
  then if>0(a,I,J) +* Start-At insloc 0 is halting by AMI_1:def 26;
  hence if>0(a,I,J) is parahalting by SCMFSA6B:def 3;
  I is_closed_on Initialize s by SCMFSA7B:24;
  hence s.a > 0 implies IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At insloc (
  card I + card J + 3) by A1,Th23;
A7: J is_halting_on Initialize s by SCMFSA7B:25;
  J is_closed_on Initialize s by SCMFSA7B:24;
  hence thesis by A7,Th25;
end;

theorem Th27:
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds IC IExec(if>0(a,I,J),s) = insloc
(card I + card J + 3) & (s.a > 0 implies ((for d being Int-Location holds IExec
  (if>0(a,I,J),s).d = IExec(I,s).d) & for f being FinSeq-Location holds IExec(
  if>0(a,I,J),s).f = IExec(I,s).f)) & (s.a <= 0 implies ((for d being
  Int-Location holds IExec(if>0(a,I,J),s).d = IExec(J,s).d) & for f being
  FinSeq-Location holds IExec(if>0(a,I,J),s).f = IExec(J,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  hereby
    per cases;
    suppose
      s.a > 0;
      then
      IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I + card
      J + 3) by Th26;
      hence IC IExec(if>0(a,I,J),s) = insloc (card I + card J + 3) by AMI_1:111
;
    end;
    suppose
      s.a <= 0;
      then
      IExec(if>0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card I + card
      J + 3) by Th26;
      hence IC IExec(if>0(a,I,J),s) = insloc (card I + card J + 3) by AMI_1:111
;
    end;
  end;
  hereby
    assume
    s.a > 0;
    then
A1: IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I + card J
    + 3) by Th26;
    hereby
      let d be Int-Location;
      not d in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:9;
      hence IExec(if>0(a,I,J),s).d = IExec(I,s).d by A1,FUNCT_4:12;
    end;
    let f be FinSeq-Location;
    not f in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:10;
    hence IExec(if>0(a,I,J),s).f = IExec(I,s).f by A1,FUNCT_4:12;
  end;
  assume
  s.a <= 0;
  then
A2: IExec(if>0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card I + card J +
  3) by Th26;
  hereby
    let d be Int-Location;
    not d in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:9;
    hence IExec(if>0(a,I,J),s).d = IExec(J,s).d by A2,FUNCT_4:12;
  end;
  let f be FinSeq-Location;
  not f in dom Start-At insloc (card I + card J + 3) by SCMFSA6B:10;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
read-write Int-Location st s.a < 0 & I is_closed_on s & I is_halting_on s holds
  if<0(a,I,J) is_closed_on s & if<0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a < 0;
  assume that
A2: I is_closed_on s and
A3: I is_halting_on s;
A4: if>0(a,J,I) is_halting_on s by A1,A2,A3,Th24;
  if>0(a,J,I) is_closed_on s by A1,A2,A3,Th24;
  hence thesis by A1,A4,Th18;
end;

theorem Th29:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a < 0 & I is_closed_on Initialize s & I
is_halting_on Initialize s holds IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At
  insloc (card I + card J + card J + 7)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a < 0;
  assume that
A2: I is_closed_on Initialize s and
A3: I is_halting_on Initialize s;
A4: (Initialize s).a <= 0 by A1,SCMFSA6C:3;
  then
A5: if>0(a,J,I) is_halting_on Initialize s by A2,A3,Th24;
  if>0(a,J,I) is_closed_on Initialize s by A2,A3,A4,Th24;
  hence IExec(if<0(a,I,J),s) = IExec(if>0(a,J,I),s) +* Start-At insloc (card
  if>0(a,J,I) + card J + 3) by A1,A5,Th19
    .= IExec(if>0(a,J,I),s) +* Start-At insloc (card I + card J + 4 + card J
  + 3) by Th15
    .= IExec(I,s) +* Start-At insloc (card I + card J + 3) +* Start-At
  insloc (card I + card J + 4 + card J + 3) by A1,A2,A3,Th25
    .= IExec(I,s) +* Start-At insloc (card I + card J + card J + 7) by
AMI_1:141;
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
read-write Int-Location st s.a = 0 & J is_closed_on s & J is_halting_on s holds
  if<0(a,I,J) is_closed_on s & if<0(a,I,J) is_halting_on s by Th16;

theorem Th31:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & J is_closed_on Initialize s & J
is_halting_on Initialize s holds IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At
  insloc (card I + card J + card J + 7)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a = 0;
  assume that
A2: J is_closed_on Initialize s and
A3: J is_halting_on Initialize s;
  thus IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card if>0(a,J,I)
  + card J + 3) by A1,A2,A3,Th17
    .= IExec(J,s) +* Start-At insloc (card I + card J + 4 + card J + 3) by Th15
    .= IExec(J,s) +* Start-At insloc (card I + card J + card J + 7);
end;

theorem
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
read-write Int-Location st s.a > 0 & J is_closed_on s & J is_halting_on s holds
  if<0(a,I,J) is_closed_on s & if<0(a,I,J) is_halting_on s
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  assume that
A2: J is_closed_on s and
A3: J is_halting_on s;
A4: if>0(a,J,I) is_halting_on s by A1,A2,A3,Th22;
  if>0(a,J,I) is_closed_on s by A1,A2,A3,Th22;
  hence thesis by A1,A4,Th18;
end;

theorem Th33:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & J is_closed_on Initialize s & J
is_halting_on Initialize s holds IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At
  insloc (card I + card J + card J + 7)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a > 0;
  assume that
A2: J is_closed_on Initialize s and
A3: J is_halting_on Initialize s;
A4: (Initialize s).a > 0 by A1,SCMFSA6C:3;
  then
A5: if>0(a,J,I) is_halting_on Initialize s by A2,A3,Th22;
  if>0(a,J,I) is_closed_on Initialize s by A2,A3,A4,Th22;
  hence IExec(if<0(a,I,J),s) = IExec(if>0(a,J,I),s) +* Start-At insloc (card
  if>0(a,J,I) + card J + 3) by A1,A5,Th19
    .= IExec(if>0(a,J,I),s) +* Start-At insloc (card I + card J + 4 + card J
  + 3) by Th15
    .= IExec(J,s) +* Start-At insloc (card I + card J + 3) +* Start-At
  insloc (card I + card J + 4 + card J + 3) by A1,A2,A3,Th23
    .= IExec(J,s) +* Start-At insloc (card I + card J + card J + 7) by
AMI_1:141;
end;

theorem
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA
  , a being read-write Int-Location holds if<0(a,I,J) is parahalting & (s.a < 0
implies IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I + card J +
card J + 7)) & (s.a >= 0 implies IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At
  insloc (card I + card J + card J + 7))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  if>0(a,J,I) is parahalting by Th26;
  hence if<0(a,I,J) is parahalting by Th20;
  hereby
A1: I is_halting_on Initialize s by SCMFSA7B:25;
A2: I is_closed_on Initialize s by SCMFSA7B:24;
    assume
    s.a < 0;
    hence
    IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I + card J
    + card J + 7) by A2,A1,Th29;
  end;
  hereby
    assume
A3: s.a >= 0;
A4: J is_closed_on Initialize s by SCMFSA7B:24;
A5: J is_halting_on Initialize s by SCMFSA7B:25;
    per cases;
    suppose
      s.a = 0;
      hence
      IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card I + card
      J + card J + 7) by A4,A5,Th31;
    end;
    suppose
      s.a <> 0;
      hence
      IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At insloc (card I + card
      J + card J + 7) by A3,A4,A5,Th33;
    end;
  end;
end;

registration
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  cluster if=0(a,I,J) -> parahalting;
  correctness by Th20;
  cluster if>0(a,I,J) -> parahalting;
  correctness by Th26;
end;

definition
  let a,b be Int-Location;
  let I,J be Program of SCM+FSA;
  func if=0(a,b,I,J) -> Program of SCM+FSA equals
  SubFrom(a,b) ';' if=0(a,I,J);
  coherence;
  func if>0(a,b,I,J) -> Program of SCM+FSA equals
  SubFrom(a,b) ';' if>0(a,I,J);
  coherence;
end;

notation
  let a,b be Int-Location;
  let I,J be Program of SCM+FSA;
  synonym if<0(b,a,I,J) for if>0(a,b,I,J);
end;

registration
  let I,J be parahalting Program of SCM+FSA;
  let a,b be read-write Int-Location;
  cluster if=0(a,b,I,J) -> parahalting;
  correctness;
  cluster if>0(a,b,I,J) -> parahalting;
  correctness;
end;

theorem Th35:
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  DataPart Result (s +* Initialized I) = DataPart IExec(I,s)
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  set s1 = s +* Initialized I;
A1: IExec(I,s) = Result s1 +* s | A by SCMFSA6B:def 1;
A2: now
    let f be FinSeq-Location;
    now
      assume
      f in dom (s | A);
      then f in A by RELAT_1:86;
      hence f is Instruction-Location of SCM+FSA by AMI_1:def 4;
    end;
    hence IExec(I,s).f = (Result s1).f by A1,FUNCT_4:12,SCMFSA_2:85;
  end;
  now
    let b be Int-Location;
    now
      assume
      b in dom (s | A);
      then b in A by RELAT_1:86;
      hence b is Instruction-Location of SCM+FSA by AMI_1:def 4;
    end;
    hence IExec(I,s).b = (Result s1).b by A1,FUNCT_4:12,SCMFSA_2:84;
  end;
  hence thesis by A2,SCMFSA6A:38;
end;

theorem Th36:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
  being Int-Location holds Result (s +* Initialized I),IExec(I,s) equal_outside
  NAT
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  set s1 = s +* Initialized I;
A1: IC Result s1 = IC IExec(I,s) by SCMFSA8A:7;
A2: DataPart Result s1 = DataPart IExec(I,s) by Th35;
  then
A3: for f being FinSeq-Location holds (Result s1).f = IExec(I,s).f by
SCMFSA6A:38;
  for a being Int-Location holds (Result s1).a = IExec(I,s).a by A2,SCMFSA6A:38
;
  hence thesis by A3,A1,SCMFSA6A:28;
end;

theorem Th37:
  for s1,s2 being State of SCM+FSA, i being Instruction of SCM+FSA
  , a being Int-Location holds (for b being Int-Location st a <> b holds s1.b =
s2.b) & (for f being FinSeq-Location holds s1.f = s2.f) & i does_not_refer a &
IC s1 = IC s2 implies (for b being Int-Location st a <> b holds Exec(i,s1).b =
Exec(i,s2).b) & (for f being FinSeq-Location holds Exec(i,s1).f = Exec(i,s2).f)
  & IC Exec(i,s1) = IC Exec(i,s2)
proof
  let s1,s2 be State of SCM+FSA;
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  defpred S[State of SCM+FSA,State of SCM+FSA] means (for b being Int-Location
  st a <> b holds $1.b = $2.b) & for f being FinSeq-Location holds $1.f = $2.f;
  assume
A1: S[s1,s2];
A2: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
A3: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
  assume
A4: i does_not_refer a;
A5: InsCode i <= 11+1 by SCMFSA_2:35;
A6: now
    let b be Int-Location;
    assume
A7: a <> b;
    per cases by A5,A3,A2,NAT_1:8,33;
    suppose
      InsCode i = 0;
      then
A8:   i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s1).b = s1.b by AMI_1:def 8
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A8,AMI_1:def 8;
    end;
    suppose
      InsCode i = 1;
      then consider da, db being Int-Location such that
A9:   i = da := db by SCMFSA_2:54;
A10:  a <> db by A4,A9,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A11:      b = da;
          hence Exec(i,s1).b = s1.db by A9,SCMFSA_2:89
            .= s2.db by A1,A10
            .= Exec(i,s2).b by A9,A11,SCMFSA_2:89;
        end;
        suppose
A12:      b <> da;
          hence Exec(i,s1).b = s1.b by A9,SCMFSA_2:89
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A9,A12,SCMFSA_2:89;
        end;
      end;
    end;
    suppose
      InsCode i = 2;
      then consider da, db being Int-Location such that
A13:  i = AddTo(da,db) by SCMFSA_2:55;
A14:  a <> db by A4,A13,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A15:      b = da;
          hence Exec(i,s1).b = s1.b + s1.db by A13,SCMFSA_2:90
            .= s2.b + s1.db by A1,A7
            .= s2.b + s2.db by A1,A14
            .= Exec(i,s2).b by A13,A15,SCMFSA_2:90;
        end;
        suppose
A16:      b <> da;
          hence Exec(i,s1).b = s1.b by A13,SCMFSA_2:90
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A13,A16,SCMFSA_2:90;
        end;
      end;
    end;
    suppose
      InsCode i = 3;
      then consider da, db being Int-Location such that
A17:  i = SubFrom(da, db) by SCMFSA_2:56;
A18:  a <> db by A4,A17,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A19:      b = da;
          hence Exec(i,s1).b = s1.b - s1.db by A17,SCMFSA_2:91
            .= s2.b - s1.db by A1,A7
            .= s2.b - s2.db by A1,A18
            .= Exec(i,s2).b by A17,A19,SCMFSA_2:91;
        end;
        suppose
A20:      b <> da;
          hence Exec(i,s1).b = s1.b by A17,SCMFSA_2:91
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A17,A20,SCMFSA_2:91;
        end;
      end;
    end;
    suppose
      InsCode i = 4;
      then consider da, db being Int-Location such that
A21:  i = MultBy(da,db) by SCMFSA_2:57;
A22:  a <> db by A4,A21,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A23:      b = da;
          hence Exec(i,s1).b = s1.b * s1.db by A21,SCMFSA_2:92
            .= s2.b * s1.db by A1,A7
            .= s2.b * s2.db by A1,A22
            .= Exec(i,s2).b by A21,A23,SCMFSA_2:92;
        end;
        suppose
A24:      b <> da;
          hence Exec(i,s1).b = s1.b by A21,SCMFSA_2:92
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A21,A24,SCMFSA_2:92;
        end;
      end;
    end;
    suppose
      InsCode i = 5;
      then consider da, db being Int-Location such that
A25:  i = Divide(da, db) by SCMFSA_2:58;
A26:  a <> db by A4,A25,SCMFSA7B:def 1;
A27:  a <> da by A4,A25,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A28:      b = db;
          hence Exec(i,s1).b = s1.da mod s1.db by A25,SCMFSA_2:93
            .= s2.da mod s1.db by A1,A27
            .= s2.da mod s2.db by A1,A26
            .= Exec(i,s2).b by A25,A28,SCMFSA_2:93;
        end;
        suppose
A29:      b = da & b <> db;
          hence Exec(i,s1).b = s1.da div s1.db by A25,SCMFSA_2:93
            .= s1.da div s2.db by A1,A26
            .= s2.da div s2.db by A1,A27
            .= Exec(i,s2).b by A25,A29,SCMFSA_2:93;
        end;
        suppose
A30:      b <> da & b <> db;
          hence Exec(i,s1).b = s1.b by A25,SCMFSA_2:93
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A25,A30,SCMFSA_2:93;
        end;
      end;
    end;
    suppose
      InsCode i = 6;
      then
A31:  ex loc being Instruction-Location of SCM+FSA st i = goto loc by
SCMFSA_2:59;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:95
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A31,SCMFSA_2:95;
    end;
    suppose
      InsCode i = 7;
      then
A32:  ex loc being Instruction-Location of SCM+FSA, da being Int-Location
      st i = da =0_goto loc by SCMFSA_2:60;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:96
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A32,SCMFSA_2:96;
    end;
    suppose
      InsCode i = 8;
      then
A33:  ex loc being Instruction-Location of SCM+FSA, da being Int-Location
      st i = da >0_goto loc by SCMFSA_2:61;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:97
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A33,SCMFSA_2:97;
    end;
    suppose
      InsCode i = 9;
      then consider
      db, da being Int-Location, g being FinSeq-Location such that
A34:  i = da := (g,db) by SCMFSA_2:62;
A35:  a <> db by A4,A34,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A36:      b = da;
          then consider m2 being Element of NAT such that
A37:      m2 = abs(s2.db) and
A38:      Exec(da:=(g,db), s2).b = (s2.g)/.m2 by SCMFSA_2:98;
          consider m1 being Element of NAT such that
A39:      m1 = abs(s1.db) and
A40:      Exec(da:=(g,db), s1).b = (s1.g)/.m1 by A36,SCMFSA_2:98;
          m1 = m2 by A1,A35,A39,A37;
          hence Exec(i,s1).b = Exec(i,s2).b by A1,A34,A40,A38;
        end;
        suppose
A41:      b <> da;
          hence Exec(i,s1).b = s1.b by A34,SCMFSA_2:98
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A34,A41,SCMFSA_2:98;
        end;
      end;
    end;
    suppose
      InsCode i = 10;
      then
A42:  ex db, da being Int-Location, g being FinSeq-Location st i = (g,db
      ):= da by SCMFSA_2:63;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:99
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A42,SCMFSA_2:99;
    end;
    suppose
      InsCode i = 11;
      then consider da being Int-Location, g being FinSeq-Location such that
A43:  i = da :=len g by SCMFSA_2:64;
      hereby
        per cases;
        suppose
A44:      b = da;
          hence Exec(i,s1).b = len (s1.g) by A43,SCMFSA_2:100
            .= len (s2.g) by A1
            .= Exec(i,s2).b by A43,A44,SCMFSA_2:100;
        end;
        suppose
A45:      b <> da;
          hence Exec(i,s1).b = s1.b by A43,SCMFSA_2:100
            .= s2.b by A1,A7
            .= Exec(i,s2).b by A43,A45,SCMFSA_2:100;
        end;
      end;
    end;
    suppose
      InsCode i = 12;
      then
A46:  ex da being Int-Location, g being FinSeq-Location st i = g
      :=<0,...,0>da by SCMFSA_2:65;
      hence Exec(i,s1).b = s1.b by SCMFSA_2:101
        .= s2.b by A1,A7
        .= Exec(i,s2).b by A46,SCMFSA_2:101;
    end;
  end;
  assume
A47: IC s1 = IC s2;
  now
    let f be FinSeq-Location;
    per cases by A5,A3,A2,NAT_1:8,33;
    suppose
      InsCode i = 0;
      then
A48:  i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s1).f = s1.f by AMI_1:def 8
        .= s2.f by A1
        .= Exec(i,s2).f by A48,AMI_1:def 8;
    end;
    suppose
      InsCode i = 1;
      then
A49:  ex da, db being Int-Location st i = da := db by SCMFSA_2:54;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:89
        .= s2.f by A1
        .= Exec(i,s2).f by A49,SCMFSA_2:89;
    end;
    suppose
      InsCode i = 2;
      then
A50:  ex da, db being Int-Location st i = AddTo(da,db) by SCMFSA_2:55;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:90
        .= s2.f by A1
        .= Exec(i,s2).f by A50,SCMFSA_2:90;
    end;
    suppose
      InsCode i = 3;
      then
A51:  ex da, db being Int-Location st i = SubFrom(da, db) by SCMFSA_2:56;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:91
        .= s2.f by A1
        .= Exec(i,s2).f by A51,SCMFSA_2:91;
    end;
    suppose
      InsCode i = 4;
      then
A52:  ex da, db being Int-Location st i = MultBy(da,db) by SCMFSA_2:57;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:92
        .= s2.f by A1
        .= Exec(i,s2).f by A52,SCMFSA_2:92;
    end;
    suppose
      InsCode i = 5;
      then
A53:  ex da, db being Int-Location st i = Divide(da, db) by SCMFSA_2:58;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:93
        .= s2.f by A1
        .= Exec(i,s2).f by A53,SCMFSA_2:93;
    end;
    suppose
      InsCode i = 6;
      then
A54:  ex loc being Instruction-Location of SCM+FSA st i = goto loc by
SCMFSA_2:59;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:95
        .= s2.f by A1
        .= Exec(i,s2).f by A54,SCMFSA_2:95;
    end;
    suppose
      InsCode i = 7;
      then
A55:  ex loc being Instruction-Location of SCM+FSA, da being Int-Location
      st i = da=0_goto loc by SCMFSA_2:60;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:96
        .= s2.f by A1
        .= Exec(i,s2).f by A55,SCMFSA_2:96;
    end;
    suppose
      InsCode i = 8;
      then
A56:  ex loc being Instruction-Location of SCM+FSA, da being Int-Location
      st i = da>0_goto loc by SCMFSA_2:61;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:97
        .= s2.f by A1
        .= Exec(i,s2).f by A56,SCMFSA_2:97;
    end;
    suppose
      InsCode i = 9;
      then
A57:  ex db, da being Int-Location, g being FinSeq-Location st i = da :=
      (g,db) by SCMFSA_2:62;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:98
        .= s2.f by A1
        .= Exec(i,s2).f by A57,SCMFSA_2:98;
    end;
    suppose
      InsCode i = 10;
      then consider
      db, da being Int-Location, g being FinSeq-Location such that
A58:  i = (g,db):=da by SCMFSA_2:63;
A59:  a <> db by A4,A58,SCMFSA7B:def 1;
A60:  a <> da by A4,A58,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A61:      f = g;
A62:      s1.da = s2.da by A1,A60;
          consider m2 being Element of NAT such that
A63:      m2 = abs(s2.db) and
A64:      Exec((g,db):=da,s2).g = s2.g+*(m2,s2.da) by SCMFSA_2:99;
          consider m1 being Element of NAT such that
A65:      m1 = abs(s1.db) and
A66:      Exec((g,db):=da,s1).g = s1.g+*(m1,s1.da) by SCMFSA_2:99;
          m1 = m2 by A1,A59,A65,A63;
          hence Exec(i,s1).f = Exec(i,s2).f by A1,A58,A61,A66,A64,A62;
        end;
        suppose
A67:      f <> g;
          hence Exec(i,s1).f = s1.f by A58,SCMFSA_2:99
            .= s2.f by A1
            .= Exec(i,s2).f by A58,A67,SCMFSA_2:99;
        end;
      end;
    end;
    suppose
      InsCode i = 11;
      then
A68:  ex da being Int-Location, g being FinSeq-Location st i = da :=len
      g by SCMFSA_2:64;
      hence Exec(i,s1).f = s1.f by SCMFSA_2:100
        .= s2.f by A1
        .= Exec(i,s2).f by A68,SCMFSA_2:100;
    end;
    suppose
      InsCode i = 12;
      then consider da being Int-Location, g being FinSeq-Location such that
A69:  i = g:=<0,...,0>da by SCMFSA_2:65;
A70:  a <> da by A4,A69,SCMFSA7B:def 1;
      hereby
        per cases;
        suppose
A71:      f = g;
A72:      ex m2 being Element of NAT st m2 = abs(s2.da) & Exec(g
          :=<0,...,0>da, s2).g = m2 |-> 0 by SCMFSA_2:101;
          ex m1 being Element of NAT st m1 = abs(s1.da) & Exec(g
          :=<0,...,0>da, s1).g = m1 |-> 0 by SCMFSA_2:101;
          hence Exec(i,s1).f = Exec(i,s2).f by A1,A69,A70,A71,A72;
        end;
        suppose
A73:      f <> g;
          hence Exec(i,s1).f = s1.f by A69,SCMFSA_2:101
            .= s2.f by A1
            .= Exec(i,s2).f by A69,A73,SCMFSA_2:101;
        end;
      end;
    end;
  end;
  hence S[Exec(i,s1),Exec(i,s2)] by A6;
  now
    per cases by A5,A3,A2,NAT_1:8,33;
    suppose
      InsCode i = 0;
      then
A74:  i = halt SCM+FSA by SCMFSA_2:122;
      hence Exec(i,s1).IC SCM+FSA = IC s1 by AMI_1:def 8
        .= Exec(i,s2).IC SCM+FSA by A47,A74,AMI_1:def 8;
    end;
    suppose
      InsCode i = 1;
      then
A75:  ex da, db being Int-Location st i = da := db by SCMFSA_2:54;
      hence Exec(i,s1).IC SCM+FSA = Next IC s1 by SCMFSA_2:89
        .= Exec(i,s2).IC SCM+FSA by A47,A75,SCMFSA_2:89;
    end;
    suppose
      InsCode i = 2;
      then
A76:  ex da, db being Int-Location st i = AddTo(da,db) by SCMFSA_2:55;
      hence Exec(i,s1).IC SCM+FSA = Next IC s1 by SCMFSA_2:90
        .= Exec(i,s2).IC SCM+FSA by A47,A76,SCMFSA_2:90;
    end;
    suppose
      InsCode i = 3;
      then
A77:  ex da, db being Int-Location st i = SubFrom(da, db) by SCMFSA_2:56;
      hence Exec(i,s1).IC SCM+FSA = Next IC s1 by SCMFSA_2:91
        .= Exec(i,s2).IC SCM+FSA by A47,A77,SCMFSA_2:91;
    end;
    suppose
      InsCode i = 4;
      then
A78:  ex da, db being Int-Location st i = MultBy(da,db) by SCMFSA_2:57;
      hence Exec(i,s1).IC SCM+FSA = Next IC s1 by SCMFSA_2:92
        .= Exec(i,s2).IC SCM+FSA by A47,A78,SCMFSA_2:92;
    end;
    suppose
      InsCode i = 5;
      then
A79:  ex da, db being Int-Location st i = Divide(da, db) by SCMFSA_2:58;
      hence Exec(i,s1).IC SCM+FSA = Next IC s1 by SCMFSA_2:93
        .= Exec(i,s2).IC SCM+FSA by A47,A79,SCMFSA_2:93;
    end;
    suppose
      InsCode i = 6;
      then consider loc being Instruction-Location of SCM+FSA such that
A80:  i = goto loc by SCMFSA_2:59;
      thus Exec(i,s1).IC SCM+FSA = loc by A80,SCMFSA_2:95
        .= Exec(i,s2).IC SCM+FSA by A80,SCMFSA_2:95;
    end;
    suppose
      InsCode i = 7;
      then consider loc being Instruction-Location of SCM+FSA, da being
      Int-Location such that
A81:  i = da =0_goto loc by SCMFSA_2:60;
      a <> da by A4,A81,SCMFSA7B:def 1;
      then
A82:  s1.da = s2.da by A1;
      hereby
        per cases;
        suppose
A83:      s1.da = 0;
          hence Exec(i,s1).IC SCM+FSA = loc by A81,SCMFSA_2:96
            .= Exec(i,s2).IC SCM+FSA by A81,A82,A83,SCMFSA_2:96;
        end;
        suppose
A84:      s1.da <> 0;
          hence Exec(i,s1).IC SCM+FSA = Next IC s1 by A81,SCMFSA_2:96
            .= Exec(i,s2).IC SCM+FSA by A47,A81,A82,A84,SCMFSA_2:96;
        end;
      end;
    end;
    suppose
      InsCode i = 8;
      then consider loc being Instruction-Location of SCM+FSA, da being
      Int-Location such that
A85:  i = da>0_goto loc by SCMFSA_2:61;
      a <> da by A4,A85,SCMFSA7B:def 1;
      then
A86:  s1.da = s2.da by A1;
      hereby
        per cases;
        suppose
A87:      s1.da > 0;
          hence Exec(i,s1).IC SCM+FSA = loc by A85,SCMFSA_2:97
            .= Exec(i,s2).IC SCM+FSA by A85,A86,A87,SCMFSA_2:97;
        end;
        suppose
A88:      s1.da <= 0;
          hence Exec(i,s1).IC SCM+FSA = Next IC s1 by A85,SCMFSA_2:97
            .= Exec(i,s2).IC SCM+FSA by A47,A85,A86,A88,SCMFSA_2:97;
        end;
      end;
    end;
    suppose
      InsCode i = 9;
      then
A89:  ex db, da being Int-Location, g being FinSeq-Location st i = da
      := (g,db) by SCMFSA_2:62;
      hence Exec(i,s1).IC SCM+FSA = Next IC s1 by SCMFSA_2:98
        .= Exec(i,s2).IC SCM+FSA by A47,A89,SCMFSA_2:98;
    end;
    suppose
      InsCode i = 10;
      then
A90:  ex db, da being Int-Location, g being FinSeq-Location st i = (g,
      db):=da by SCMFSA_2:63;
      hence Exec(i,s1).IC SCM+FSA = Next IC s1 by SCMFSA_2:99
        .= Exec(i,s2).IC SCM+FSA by A47,A90,SCMFSA_2:99;
    end;
    suppose
      InsCode i = 11;
      then
A91:  ex da being Int-Location, g being FinSeq-Location st i = da :=len
      g by SCMFSA_2:64;
      hence Exec(i,s1).IC SCM+FSA = Next IC s1 by SCMFSA_2:100
        .= Exec(i,s2).IC SCM+FSA by A47,A91,SCMFSA_2:100;
    end;
    suppose
      InsCode i = 12;
      then
A92:  ex da being Int-Location, g being FinSeq-Location st i = g
      :=<0,...,0>da by SCMFSA_2:65;
      hence Exec(i,s1).IC SCM+FSA = Next IC s1 by SCMFSA_2:101
        .= Exec(i,s2).IC SCM+FSA by A47,A92,SCMFSA_2:101;
    end;
  end;
  hence thesis;
end;

theorem Th38:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does_not_refer a & (for b being Int-Location st a <> b
  holds s1.b = s2.b) & (for f being FinSeq-Location holds s1.f = s2.f) & I
  is_closed_on s1 holds for k being Element of NAT holds (for b being
Int-Location st a <> b holds Computation( (s1 +* (I +* Start-At insloc 0)),k).b
  = Computation( (s2 +* (I +* Start-At insloc 0)),k).b) & (for f being
  FinSeq-Location holds Computation( (s1 +* (I +* Start-At insloc 0)),k).f =
Computation( (s2 +* (I +* Start-At insloc 0)),k).f) & IC Computation( (s1 +* (I
+* Start-At insloc 0)),k) = IC Computation( (s2 +* (I +* Start-At insloc 0)),k)
  & CurInstr Computation( (s1 +* (I +* Start-At insloc 0)),k) = CurInstr
  Computation( (s2 +* (I +* Start-At insloc 0)),k)
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does_not_refer a;
  set S2 = s2 +* (I +* Start-At insloc 0);
  set S1 = s1 +* (I +* Start-At insloc 0);
  defpred S[State of SCM+FSA,State of SCM+FSA] means (for b being Int-Location
  st a <> b holds $1.b = $2.b) & for f being FinSeq-Location holds $1.f = $2.f;
  assume that
A2: for b being Int-Location st a <> b holds s1.b = s2.b and
A3: for f being FinSeq-Location holds s1.f = s2.f;
A4: IC SCM+FSA in dom (I +* Start-At insloc 0) by SF_MASTR:65;
A5: now
    let f be FinSeq-Location;
A6: not f in dom (I +* Start-At insloc 0) by SCMFSA6B:13;
    hence S1.f = s1.f by FUNCT_4:12
      .= s2.f by A3
      .= S2.f by A6,FUNCT_4:12;
  end;
A7: Computation(S2,0) = S2 by AMI_1:13;
  defpred P[Element of NAT] means S[ Computation(S1,$1), Computation(S2,$1)] &
  IC Computation(S1,$1) = IC Computation(S2,$1) & CurInstr Computation(S1,$1) =
  CurInstr Computation(S2,$1);
A8: I c= I +* Start-At insloc 0 by SCMFSA8A:9;
A9: IC Computation(S1,0) = S1.IC SCM+FSA by AMI_1:13
    .= ((I +* Start-At insloc 0)).IC SCM+FSA by A4,FUNCT_4:14
    .= S2.IC SCM+FSA by A4,FUNCT_4:14
    .= IC Computation(S2,0) by AMI_1:13;
  (I +* Start-At insloc 0) c= S1 by FUNCT_4:26;
  then
A10: I c= S1 by A8,XBOOLE_1:1;
A11: now
    let b be Int-Location;
    assume
A12: a <> b;
A13: not b in dom (I +* Start-At insloc 0) by SCMFSA6B:12;
    hence S1.b = s1.b by FUNCT_4:12
      .= s2.b by A2,A12
      .= S2.b by A13,FUNCT_4:12;
  end;
A14: Computation(S1,0) = S1 by AMI_1:13;
  assume that
A15: I is_closed_on s1;
A16: IC Computation(S1,0) in dom I by A15,SCMFSA7B:def 7;
  (I +* Start-At insloc 0) c= S2 by FUNCT_4:26;
  then
A17: I c= S2 by A8,XBOOLE_1:1;
A18: for k being Element of NAT holds P[k] implies P[k + 1]
  proof
    let k be Element of NAT;
A19: Computation(S1,k+1) = Following Computation(S1,k) by AMI_1:14
      .= Exec(CurInstr Computation(S1,k), Computation(S1,k));
A20: IC Computation(S1,k) in dom I by A15,SCMFSA7B:def 7;
A21: ProgramPart I = I by AMI_1:105;
    then
A22: I c= Computation(S2,k+1) by A17,AMI_1:99;
A23: Computation(S2,k+1) = Following Computation(S2,k) by AMI_1:14
      .= Exec(CurInstr Computation(S2,k), Computation(S2,k));
    I c= Computation(S1,k) by A10,A21,AMI_1:99;
    then CurInstr Computation(S1,k) = I.IC Computation(S1,k) by A20,GRFUNC_1:8;
    then CurInstr Computation(S1,k) in rng I by A20,FUNCT_1:def 5;
    then
A24: CurInstr Computation(S1,k) does_not_refer a by A1,SCMFSA7B:def 2;
    assume
A25: P[k];
    hence S[ Computation(S1,k+1), Computation(S2,k+1)] by A19,A23,A24,Th37;
    thus
A26: IC Computation(S1,k+1) = IC Computation(S2,k+1) by A25,A19,A23,A24,Th37;
A27: IC Computation(S1,k+1) in dom I by A15,SCMFSA7B:def 7;
    I c= Computation(S1,k+1) by A10,A21,AMI_1:99;
    hence CurInstr Computation(S1,k+1) = I.IC Computation(S1,k+1) by A27,
GRFUNC_1:8
      .= CurInstr Computation(S2,k+1) by A22,A26,A27,GRFUNC_1:8;
  end;
  CurInstr Computation(S1,0) = S1.IC Computation(S1,0) by AMI_1:13
    .= I.IC Computation(S1,0) by A10,A16,GRFUNC_1:8
    .= S2.IC Computation(S2,0) by A17,A9,A16,GRFUNC_1:8
    .= CurInstr Computation(S2,0) by AMI_1:13;
  then
A28: P[0] by A11,A5,A14,A7,A9;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A28,A18);
  hence thesis;
end;

theorem Th39:
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, l
being Instruction-Location of SCM+FSA holds I is_closed_on s & I is_halting_on
  s iff I is_closed_on s +* (I +* Start-At l) & I is_halting_on s +* (I +*
  Start-At l)
proof
  let s be State of SCM+FSA;
  let I,J be Program of SCM+FSA;
  let l be Instruction-Location of SCM+FSA;
  DataPart s = DataPart(s +* (I +* Start-At l)) by SCMFSA8A:11;
  hence thesis by Th8;
end;

theorem Th40:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does_not_refer a & (for b being Int-Location st a <> b
  holds s1.b = s2.b) & (for f being FinSeq-Location holds s1.f = s2.f) & I
is_closed_on s1 & I is_halting_on s1 holds I is_closed_on s2 & I is_halting_on
  s2
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume
A1: I does_not_refer a;
  set S2 = s2 +* (I +* Start-At insloc 0);
  set S1 = s1 +* (I +* Start-At insloc 0);
  assume
A2: for b being Int-Location st a <> b holds s1.b = s2.b;
A3: now
    let b be Int-Location;
    assume
A4: a <> b;
A5: not b in dom (I +* Start-At insloc 0) by SCMFSA6B:12;
    not b in dom (I +* Start-At insloc 0) by SCMFSA6B:12;
    hence S1.b = s1.b by FUNCT_4:12
      .= s2.b by A2,A4
      .= S2.b by A5,FUNCT_4:12;
  end;
  assume
A6: for f being FinSeq-Location holds s1.f = s2.f;
A7: now
    let f be FinSeq-Location;
A8: not f in dom (I +* Start-At insloc 0) by SCMFSA6B:13;
    not f in dom (I +* Start-At insloc 0) by SCMFSA6B:13;
    hence S1.f = s1.f by FUNCT_4:12
      .= s2.f by A6
      .= S2.f by A8,FUNCT_4:12;
  end;
A9: (I +* Start-At insloc 0) +* (I +* Start-At insloc 0) = (I +* Start-At
  insloc 0);
  then
A10: S1 +*(I +* Start-At insloc 0) = S1 by FUNCT_4:15;
A11: S2 +* (I +* Start-At insloc 0) = S2 by A9,FUNCT_4:15;
  assume that
A12: I is_closed_on s1 and
A13: I is_halting_on s1;
A14: I is_closed_on S1 by A12,A13,Th39;
A15: now
    let k be Element of NAT;
    IC Computation(S1,k) in dom I by A12,SCMFSA7B:def 7;
    hence IC Computation(S2,k) in dom I by A1,A3,A7,A10,A11,A14,Th38;
  end;
  ProgramPart S1 halts_on S1 by A13,SCMFSA7B:def 8;
  then consider n being Element of NAT such that
A16: CurInstr Computation(S1,n) = halt SCM+FSA by AMI_1:146;
  CurInstr Computation(S2,n) = halt SCM+FSA by A1,A3,A7,A10,A11,A14,A16,Th38;
  then ProgramPart S2 halts_on S2 by AMI_1:146;
  hence thesis by A15,SCMFSA7B:def 7,def 8;
end;

theorem Th41:
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA, a
  being Int-Location holds (for d being read-write Int-Location st a <> d holds
  s1.d = s2.d) & (for f being FinSeq-Location holds s1.f = s2.f) & I
does_not_refer a & I is_closed_on Initialize s1 & I is_halting_on Initialize s1
implies (for d being Int-Location st a <> d holds IExec(I,s1).d = IExec(I,s2).d
  ) & (for f being FinSeq-Location holds IExec(I,s1).f = IExec(I,s2).f) & IC
  IExec(I,s1) = IC IExec(I,s2)
proof
  let s1,s2 be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be Int-Location;
  assume that
A1: for d being read-write Int-Location st a <> d holds s1.d = s2.d and
A2: for f being FinSeq-Location holds s1.f = s2.f;
A3: now
    let d be Int-Location;
    assume
A4: a <> d;
    per cases;
    suppose
A5:   d = intloc 0;
      hence (Initialize s1).d = 1 by SCMFSA6C:3
        .= (Initialize s2).d by A5,SCMFSA6C:3;
    end;
    suppose
      d <> intloc 0;
      then
A6:   d is read-write by SF_MASTR:def 5;
      hence (Initialize s1).d = s1.d by SCMFSA6C:3
        .= s2.d by A1,A4,A6
        .= (Initialize s2).d by A6,SCMFSA6C:3;
    end;
  end;
  set S1 = s1 +* Initialized I;
  set S2 = s2 +* Initialized I;
  assume
A7: I does_not_refer a;
A8: S2 = Initialize s2 +* (I +* Start-At insloc 0) by SCMFSA8A:13;
  assume that
A9: I is_closed_on Initialize s1 and
A10: I is_halting_on Initialize s1;
A11: now
    let f be FinSeq-Location;
    thus (Initialize s1).f = s1.f by SCMFSA6C:3
      .= s2.f by A2
      .= (Initialize s2).f by SCMFSA6C:3;
  end;
  then I is_halting_on Initialize s2 by A7,A9,A10,A3,Th40;
  then
A12: ProgramPart S2 halts_on S2 by A8,SCMFSA7B:def 8;
A13: S1 = Initialize s1 +* (I +* Start-At insloc 0) by SCMFSA8A:13;
  then
A14: ProgramPart S1 halts_on S1 by A10,SCMFSA7B:def 8;
  now
    let l be Element of NAT;
    assume
    l < LifeSpan S1;
    then CurInstr Computation(S1,l) <> halt SCM+FSA by A14,AMI_1:def 46;
    hence CurInstr Computation(S2,l) <> halt SCM+FSA by A7,A9,A3,A11,A13,A8
,Th38;
  end;
  then
A15: for l be Element of NAT st CurInstr Computation(S2,l) = halt SCM+FSA
  holds LifeSpan S1 <= l;
  CurInstr Computation(S2,LifeSpan S1) = CurInstr Computation(S1,LifeSpan
  S1) by A7,A9,A3,A11,A13,A8,Th38
    .= halt SCM+FSA by A14,AMI_1:def 46;
  then
A16: LifeSpan S1 = LifeSpan S2 by A12,A15,AMI_1:def 46;
  then
A17: Result S2 = Computation(S2,LifeSpan S1) by A12,AMI_1:122;
A18: Result S1 = Computation(S1,LifeSpan S1) by A14,AMI_1:122;
  hereby
    let d be Int-Location;
    assume
A19: a <> d;
    thus IExec(I,s1).d = (Result S1).d by Th36,SCMFSA6A:30
      .= (Result S2).d by A7,A9,A3,A11,A13,A8,A17,A18,A19,Th38
      .= IExec(I,s2).d by Th36,SCMFSA6A:30;
  end;
  hereby
    let f be FinSeq-Location;
    thus IExec(I,s1).f = (Result S1).f by Th36,SCMFSA6A:31
      .= (Result S2).f by A7,A9,A3,A11,A13,A8,A17,A18,Th38
      .= IExec(I,s2).f by Th36,SCMFSA6A:31;
  end;
  thus IC IExec(I,s1) = IC Result S1 by SCMFSA8A:7
    .= IC Computation(S1,LifeSpan S1) by A14,AMI_1:122
    .= IC Computation(S2,LifeSpan S2) by A7,A9,A3,A11,A13,A8,A16,Th38
    .= IC Result S2 by A12,AMI_1:122
    .= IC IExec(I,s2) by SCMFSA8A:7;
end;

theorem
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA
, a,b being read-write Int-Location st I does_not_refer a & J does_not_refer a
  holds IC IExec(if=0(a,b,I,J),s) = insloc (card I + card J + 5) & (s.a = s.b
  implies ((for d being Int-Location st a <> d holds IExec(if=0(a,b,I,J),s).d =
  IExec(I,s).d) & for f being FinSeq-Location holds IExec(if=0(a,b,I,J),s).f =
IExec(I,s).f)) & (s.a <> s.b implies ((for d being Int-Location st a <> d holds
  IExec(if=0(a,b,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if=0(a,b,I,J),s).f = IExec(J,s).f))
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a,b be read-write Int-Location;
  assume that
A1: I does_not_refer a and
A2: J does_not_refer a;
  set s2 = s;
  reconsider JJ = if=0(a,I,J) as parahalting Program of SCM+FSA;
  reconsider II = Macro SubFrom(a,b) as keeping_0 parahalting Program of
  SCM+FSA;
  set i = SubFrom(a,b);
  set s1 = Exec(i,Initialize s);
A3: now
    let c be read-write Int-Location;
    assume
    a <> c;
    hence s1.c = (Initialize s).c by SCMFSA_2:91
      .= s2.c by SCMFSA6C:3;
  end;
  IExec(if=0(a,b,I,J),s) = IExec(II ';' JJ,s) by SCMFSA6A:def 6
    .= IExec(JJ,IExec(II,s)) +* Start-At (IC IExec(JJ,IExec(II,s)) + card II
  ) by SCMFSA6B:44;
  hence IC IExec(if=0(a,b,I,J),s) = IC IExec(JJ,IExec(II,s)) + card II by
AMI_1:111
    .= insloc (card I + card J + 3) + card II by Th21
    .= insloc (card I + card J + 3) + 2 by SCMFSA7B:6
    .= insloc (card I + card J + 5);
A4: now
    let f be FinSeq-Location;
    thus s1.f = (Initialize s).f by SCMFSA_2:91
      .= s2.f by SCMFSA6C:3;
  end;
  hereby
    assume
A5: s.a = s.b;
A6: I is_closed_on Initialize s1 by SCMFSA7B:24;
A7: I is_halting_on Initialize s1 by SCMFSA7B:25;
A8: Exec(i,Initialize s).a = (Initialize s).a - (Initialize s).b by SCMFSA_2:91
      .= s.a - (Initialize s).b by SCMFSA6C:3
      .= s.a - s.b by SCMFSA6C:3
      .= 0 by A5;
    hereby
      let d be Int-Location;
      assume
A9:   a <> d;
      thus IExec(if=0(a,b,I,J),s).d = IExec(JJ,Exec(i,Initialize s)).d by Th12
        .= IExec(I,Exec(i,Initialize s)).d by A8,Th21
        .= IExec(I,s).d by A1,A3,A4,A6,A7,A9,Th41;
    end;
    let f be FinSeq-Location;
    thus IExec(if=0(a,b,I,J),s).f = IExec(JJ,Exec(i,Initialize s)).f by Th13
      .= IExec(I,Exec(i,Initialize s)).f by A8,Th21
      .= IExec(I,s).f by A1,A3,A4,A6,A7,Th41;
  end;
A10: Exec(i,Initialize s).a = (Initialize s).a - (Initialize s).b by
SCMFSA_2:91
    .= s.a - (Initialize s).b by SCMFSA6C:3
    .= s.a - s.b by SCMFSA6C:3;
A11: J is_halting_on Initialize s1 by SCMFSA7B:25;
A12: J is_closed_on Initialize s1 by SCMFSA7B:24;
  assume
  s.a <> s.b;
  then
A13: s.a + (- s.b) <> s.b + (- s.b);
  hereby
    let d be Int-Location;
    assume
A14: a <> d;
    thus IExec(if=0(a,b,I,J),s).d = IExec(JJ,Exec(i,Initialize s)).d by Th12
      .= IExec(J,Exec(i,Initialize s)).d by A10,A13,Th21
      .= IExec(J,s).d by A2,A3,A4,A12,A11,A14,Th41;
  end;
  let f be FinSeq-Location;
  thus IExec(if=0(a,b,I,J),s).f = IExec(JJ,Exec(i,Initialize s)).f by Th13
    .= IExec(J,Exec(i,Initialize s)).f by A10,A13,Th21
    .= IExec(J,s).f by A2,A3,A4,A12,A11,Th41;
end;

theorem
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA
, a,b being read-write Int-Location st I does_not_refer a & J does_not_refer a
  holds IC IExec(if>0(a,b,I,J),s) = insloc (card I + card J + 5) & (s.a > s.b
  implies (for d being Int-Location st a <> d holds IExec(if>0(a,b,I,J),s).d =
  IExec(I,s).d) & for f being FinSeq-Location holds IExec(if>0(a,b,I,J),s).f =
  IExec(I,s).f) & (s.a <= s.b implies (for d being Int-Location st a <> d holds
  IExec(if>0(a,b,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if>0(a,b,I,J),s).f = IExec(J,s).f)
proof
  let s be State of SCM+FSA;
  let I,J be parahalting Program of SCM+FSA;
  let a,b be read-write Int-Location;
  assume that
A1: I does_not_refer a and
A2: J does_not_refer a;
  set s2 = s;
  reconsider JJ = if>0(a,I,J) as parahalting Program of SCM+FSA;
  reconsider II = Macro SubFrom(a,b) as keeping_0 parahalting Program of
  SCM+FSA;
  set i = SubFrom(a,b);
  set s1 = Exec(i,Initialize s);
A3: now
    let c be read-write Int-Location;
    assume
    a <> c;
    hence s1.c = (Initialize s).c by SCMFSA_2:91
      .= s2.c by SCMFSA6C:3;
  end;
  IExec(if>0(a,b,I,J),s) = IExec(II ';' JJ,s) by SCMFSA6A:def 6
    .= IExec(JJ,IExec(II,s)) +* Start-At (IC IExec(JJ,IExec(II,s)) + card II
  ) by SCMFSA6B:44;
  hence IC IExec(if>0(a,b,I,J),s) = IC IExec(JJ,IExec(II,s)) + card II by
AMI_1:111
    .= insloc (card I + card J + 3) + card II by Th27
    .= insloc (card I + card J + 3) + 2 by SCMFSA7B:6
    .= insloc (card I + card J + 5);
A4: now
    let f be FinSeq-Location;
    thus s1.f = (Initialize s).f by SCMFSA_2:91
      .= s2.f by SCMFSA6C:3;
  end;
  hereby
A5: Exec(i,Initialize s).a = (Initialize s).a - (Initialize s).b by SCMFSA_2:91
      .= s.a - (Initialize s).b by SCMFSA6C:3
      .= s.a - s.b by SCMFSA6C:3;
    assume
    s.a > s.b;
    then
A6: Exec(i,Initialize s).a > 0 by A5,XREAL_1:52;
A7: I is_halting_on Initialize s1 by SCMFSA7B:25;
A8: I is_closed_on Initialize s1 by SCMFSA7B:24;
    hereby
      let d be Int-Location;
      assume
A9:   a <> d;
      thus IExec(if>0(a,b,I,J),s).d = IExec(JJ,Exec(i,Initialize s)).d by Th12
        .= IExec(I,Exec(i,Initialize s)).d by A6,Th27
        .= IExec(I,s).d by A1,A3,A4,A8,A7,A9,Th41;
    end;
    let f be FinSeq-Location;
    thus IExec(if>0(a,b,I,J),s).f = IExec(JJ,Exec(i,Initialize s)).f by Th13
      .= IExec(I,Exec(i,Initialize s)).f by A6,Th27
      .= IExec(I,s).f by A1,A3,A4,A8,A7,Th41;
  end;
A10: Exec(i,Initialize s).a = (Initialize s).a - (Initialize s).b by
SCMFSA_2:91
    .= s.a - (Initialize s).b by SCMFSA6C:3
    .= s.a - s.b by SCMFSA6C:3;
A11: J is_closed_on Initialize s1 by SCMFSA7B:24;
A12: J is_halting_on Initialize s1 by SCMFSA7B:25;
  assume
  s.a <= s.b;
  then
A13: Exec(i,Initialize s).a <= 0 by A10,XREAL_1:49;
  hereby
    let d be Int-Location;
    assume
A14: a <> d;
    thus IExec(if>0(a,b,I,J),s).d = IExec(JJ,Exec(i,Initialize s)).d by Th12
      .= IExec(J,Exec(i,Initialize s)).d by A13,Th27
      .= IExec(J,s).d by A2,A3,A4,A11,A12,A14,Th41;
  end;
  let f be FinSeq-Location;
  thus IExec(if>0(a,b,I,J),s).f = IExec(JJ,Exec(i,Initialize s)).f by Th13
    .= IExec(J,Exec(i,Initialize s)).f by A13,Th27
    .= IExec(J,s).f by A2,A3,A4,A11,A12,Th41;
end;

