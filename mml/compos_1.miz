:: Composition of Machines, Instructions and Programs
::  by Andrzej Trybulec
::
:: Received May 20, 2010
:: Copyright (c) 2010-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies STRUCT_0, SUBSET_1, XBOOLE_0, FUNCT_1, NUMBERS, CARD_3, ORDINAL1,
      CARD_1, FUNCOP_1, FUNCT_4, RELAT_1, TARSKI, CAT_1, FSM_1, SETFAM_1,
      FINSET_1, NAT_1, AFINSQ_1, AMISTD_1, AMISTD_2, ARYTM_1, VALUED_1,
      PARTFUN1, ZFMISC_1, AMI_1, ARYTM_3, SCMNORM,
      PBOOLE, GROUP_9, RECDEF_2, COMPOS_1, SCMFSA6C, FINSEQ_1, UNIALG_1,
      CARD_5, RELOC, TURING_1, XXREAL_0, VALUED_0, SCMFSA_7, INT_1,
      SCMPDS_4, ORDINAL4, SCMFSA6A, SUPINF_2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, MCART_1, SUBSET_1, SETFAM_1, ORDINAL1,
      PBOOLE, FUNCT_7, CARD_1, CARD_3, XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1,
      FINSET_1, NUMBERS, INT_1, NAT_1, NAT_D, FUNCOP_1, FUNCT_4, AFINSQ_1,
      FINSEQ_1, FUNCT_2, DOMAIN_1, VALUED_0, VALUED_1, RECDEF_2, STRUCT_0,
      XXREAL_0;
 constructors SETFAM_1, DOMAIN_1, FUNCT_4, XXREAL_0, FUNCT_7, GRAPH_2,
      RELSET_1, PRE_POLY, PBOOLE, RECDEF_2, AFINSQ_1, NAT_D, WELLORD2;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCT_2,
      FUNCOP_1, FUNCT_4, FINSET_1, XREAL_0, FINSEQ_1, CARD_3, STRUCT_0, INT_1,
      RELSET_1, GRFUNC_1, PRE_POLY, PBOOLE, AFINSQ_1, VALUED_1, XCMPLX_0;
 registrations PARTFUN1, NUMBERS, NAT_1, MEMBERED,
      REALSET1, FUNCT_7, JORDAN1J, CARD_1, XXREAL_2,
      ZFMISC_1, SUBSET_1, VALUED_0;
 registrations
      XXREAL_0, ORDINAL4, ORDINAL5;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM, REAL;
 definitions RELAT_1, FUNCOP_1, ORDINAL1, PBOOLE,
      PARTFUN1, MCART_1, ZFMISC_1, TARSKI, STRUCT_0, FUNCT_1;
 definitions YELLOW_8, XBOOLE_0, NAT_1,
      FUNCT_4, NAT_D, AFINSQ_1, VALUED_1, CARD_3;
 theorems ZFMISC_1, FUNCT_2, TARSKI, CQC_LANG, CARD_3, FINSEQ_1,
      FUNCT_4, FUNCOP_1, FINSET_1, FUNCT_1, GRFUNC_1, RELAT_1, RELSET_1,
      XBOOLE_0, XBOOLE_1, ORDINAL1, MCART_1, ENUMSET1, SUBSET_1,
      FUNCT_7, PARTFUN1, PBOOLE, RECDEF_2, CARD_1, AFINSQ_1,
      XREAL_1, YELLOW_8, REALSET1, VALUED_1, CARD_2, PRE_CIRC, XREAL_0,
      NAT_1, XXREAL_0, NAT_D, INT_1, WELLORD2, NAT_2;
 schemes FRAENKEL, CLASSES1, FUNCT_7, DOMAIN_1;

begin :: General concepts

reserve N for non empty with_non-empty_elements set;
reserve x,A for set,
  i,j,k,m,n, l, l1, l2 for Element of NAT;
reserve D for non empty set,
  z for natural number;

definition
  let N be set;
  struct (ZeroStr) COM-Struct over N (# carrier -> set,
    ZeroF -> Element of the carrier,
    Instructions -> non empty set,
    haltF -> Element of the Instructions,
    Object-Kind -> Function of the carrier, N \/ { the Instructions, NAT }
     #);
end;

definition
  let N be set;
  func Trivial-COM N -> strict COM-Struct over N means
:Def1:
  the carrier of it = succ NAT & the ZeroF of it = NAT &
  the Instructions of it = {[0,{},{}]} &
  the haltF of it = [0,{},{}] &
  the Object-Kind of it = (NAT --> {[0,{},{}]}) +* (NAT .--> NAT);
  existence
  proof
    reconsider I = {[0,{},{}]} as non empty set;
    reconsider i = [0,{},{}] as Element of I by TARSKI:def 1;
    set f = (NAT --> I) +* (NAT .--> NAT);
A1: dom f = dom(NAT --> I) \/ dom(NAT .--> NAT) by FUNCT_4:def 1
      .= NAT \/ dom(NAT .--> NAT) by FUNCOP_1:19
      .= succ NAT by FUNCOP_1:19;
    rng(NAT --> I) c= {I} & rng(NAT .--> NAT) c= {NAT} by FUNCOP_1:19;
    then rng(NAT --> I) \/ rng(NAT .--> NAT) c= {I} \/ {NAT} by XBOOLE_1:13;
    then rng f c= rng(NAT --> I) \/ rng(NAT .--> NAT) &
     rng(NAT --> I) \/ rng(NAT .--> NAT) c= { I,NAT} by ENUMSET1:41,FUNCT_4:18;
    then
A2: rng f c= { I,NAT} by XBOOLE_1:1;
    { I,NAT } c= N \/ {I, NAT} by XBOOLE_1:7;
    then rng f c= N \/ {I, NAT} by A2,XBOOLE_1:1;
    then reconsider f as Function of succ NAT, N \/ {I, NAT} by A1,
FUNCT_2:def 1,RELSET_1:11;
    reconsider y = NAT as Element of succ NAT by ORDINAL1:10;
    reconsider E = I --> id product f as Action of I, product f
       by FUNCOP_1:57,FUNCT_2:12;
    take S=COM-Struct(#succ NAT,y,I,i,f #);
    thus thesis;
  end;
  uniqueness;
end;

definition
  let N be set;
  let S be COM-Struct over N;
  attr S is stored-program means
:Def2: NAT c= the carrier of S;
end;

registration
  let N be set;
  cluster Trivial-COM N-> non empty stored-program;
  coherence
  proof
    set S = Trivial-COM N;
A1: the carrier of S = succ NAT by Def1;
    thus the carrier of S is non empty by Def1;
    thus NAT c= the carrier of S by A1,XBOOLE_1:7;
  end;
end;

registration
  let N be set;
  cluster non empty stored-program COM-Struct over N;
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

definition
  let N be set;
  let S be non empty COM-Struct over N;
  mode Object of S is Element of S;
end;

definition
  let N be set;
  let S be COM-Struct over N;
  mode Instruction of S is Element of the Instructions of S;
end;

notation
  let N be set;
  let S be non empty COM-Struct over N;
  synonym IC S for 0.S;
end;

definition
 canceled;
  let N be set;
  let S be non empty COM-Struct over N;
  let o be Object of S;
  func ObjectKind o -> Element of N \/ { the Instructions of S, NAT } equals
  (the Object-Kind of S).o;
  correctness;
end;

definition
  let N be set;
  let S be COM-Struct over N;
  mode PartState of S is (the carrier of S)-defined
           (the Object-Kind of S)-compatible Function;
end;

definition
  let N be set;
  let S be COM-Struct over N;
  mode FinPartState of S is finite PartState of S;
end;

definition
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  mode State of S is total PartState of S;
end;

definition
  let N be set;
  let S be COM-Struct over N;
  func halt S -> Instruction of S equals
   the haltF of S;
  coherence;
end;

definition
  let N be set;
  let IT be non empty COM-Struct over N;
  attr IT is IC-Ins-separated means
  :Def6:
  ObjectKind IC IT = NAT;
end;

definition
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  let I be (the Object-Kind of S)-compatible Function;
  attr I is halt-free means
:Def7:  not halt S in rng I;
end;

definition
  let N be set;
  let IT be non empty stored-program COM-Struct over N;
  attr IT is definite means
:Def8:
  for l being Element of NAT
  holds (the Object-Kind of IT).l = the Instructions of IT;
end;

registration
  let E be set;
  cluster Trivial-COM E -> IC-Ins-separated definite;
  coherence
   proof
  thus Trivial-COM E is IC-Ins-separated
   proof
    dom(NAT .--> NAT) = {NAT} by FUNCOP_1:19;
    then
A1:  NAT in dom(NAT .--> NAT) by TARSKI:def 1;
    IC Trivial-COM E = NAT by Def1;
    hence ObjectKind IC Trivial-COM E
     = ((NAT --> {[0,{},{}]}) +* (NAT .--> NAT)).NAT by Def1
    .= (NAT .--> NAT).NAT by A1,FUNCT_4:14
    .= NAT by FUNCOP_1:87;
   end;
  let l be Element of NAT;
  not l in {NAT} by TARSKI:def 1;
  then
A2: not l in dom(NAT .--> NAT) by FUNCOP_1:19;
  thus (the Object-Kind of Trivial-COM E).l
     = ((NAT --> {[0,{},{}]}) +* (NAT .--> NAT)).l by Def1
    .= (NAT --> {[0,{},{}]}).l by A2,FUNCT_4:12
    .= {[0,{},{}]} by FUNCOP_1:13
    .= the Instructions of Trivial-COM E by Def1;
   end;
end;

registration
  let M be set;
  cluster IC-Ins-separated definite strict (non empty stored-program
    COM-Struct over M);
  existence
  proof
    take Trivial-COM M;
    thus thesis;
  end;
end;

registration
  let N;
  cluster IC-Ins-separated definite strict (non
    empty stored-program COM-Struct over N);
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

definition
  let N be with_non-empty_elements set;
  let S be IC-Ins-separated (non empty COM-Struct over N);
  let p be PartState of S;
  func IC p -> Element of NAT equals
  p.IC S;
  coherence
  proof
   per cases;
   suppose
A1: IC S in dom p;
    consider s being State of S such that
A2: p c= s by PBOOLE:156;
   reconsider ss=s as Element of product the Object-Kind of S by PBOOLE:155;
    dom the Object-Kind of S = the carrier of S by FUNCT_2:def 1;
    then pi(product the Object-Kind of S,IC S) = ObjectKind IC S by CARD_3:22
      .= NAT by Def6;
    then ss.IC S in NAT by CARD_3:def 6;
    hence thesis by A1,A2,GRFUNC_1:8;
   end;
   suppose not IC S in dom p;
    then p.IC S = 0 by FUNCT_1:def 4;
   hence thesis;
   end;
  end;
end;

theorem
  for s1, s2 being State of Trivial-COM N st IC s1 = IC s2 holds s1= s2
proof
  set T = Trivial-COM N;
  let s1,s2 be State of Trivial-COM N such that
A1: IC s1 = IC s2;
A2: dom s1 = the carrier of T by PARTFUN1:def 4;
A3: now
    let x be set;
    assume
A4: x in dom s1;
    dom s1 = the carrier of T by PARTFUN1:def 4
      .= succ NAT by Def1;
    then
A5: x in NAT or x in {NAT} by A4,XBOOLE_0:def 3;
    per cases by A5,TARSKI:def 1;
    suppose
A6:   x in NAT;
      then not x in {NAT} by TARSKI:def 1;
      then
A7:   not x in dom(NAT .--> NAT) by FUNCOP_1:19;
A8:   (the Object-Kind of T).x = ((NAT --> {[0,{},{}]}) +* (NAT .--> NAT)).x
by Def1
        .= (NAT --> {[0,{},{}]}).x by A7,FUNCT_4:12
        .= {[0,{},{}]} by A6,FUNCOP_1:13;
      x in dom s2 by A2,A4,PARTFUN1:def 4;
      then
A9:   s2.x in {[0,{},{}]} by A8,FUNCT_1:def 20;
      s1.x in {[0,{},{}]} by A4,A8,FUNCT_1:def 20;
      hence s1.x = [0,{},{}] by TARSKI:def 1
        .= s2.x by A9,TARSKI:def 1;
    end;
    suppose
A10:  x = NAT;
      hence s1.x = IC s1 by Def1
        .= s2.x by A1,A10,Def1;
    end;
  end;
  dom s1 =dom s2 by A2,PARTFUN1:def 4;
  hence thesis by A3,FUNCT_1:9;
end;

begin :: General theory

definition
  let N;
  let S be IC-Ins-separated (non empty COM-Struct over N);
  let p be (the Instructions of S)-valued Function;
  let s be State of S;
  func CurInstr(p,s) -> Instruction of S equals
  p/.IC s;
  coherence;
end;

definition
  let N be set;
  let S be COM-Struct over N;
  let s be PartState of S;
  func ProgramPart s -> PartState of S equals
  s | NAT;
  coherence;
end;

registration
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  let s be PartState of S;
  cluster ProgramPart s -> NAT-defined;
  coherence;
end;

reserve S for IC-Ins-separated definite
  (non empty stored-program COM-Struct over N),
  s,s1,s2 for State of S;
reserve
  ins for Element of the Instructions of S;
reserve ss for Element of product the Object-Kind of S;
reserve p for FinPartState of S;


Lm1:
 for i being natural number holds
 (ProgramPart s).i = s.i
 proof
  let i being natural number;
A1:   i in NAT by ORDINAL1:def 13;
A2: dom s = the carrier of S by PARTFUN1:def 4;
   NAT c= the carrier of S by Def2;
   then i in dom ProgramPart s by A1,A2,RELAT_1:86;
  hence (ProgramPart s).i = s.i by FUNCT_1:70;
 end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated definite
   (non empty stored-program COM-Struct over N);
  let s be PartState of S;
  cluster ProgramPart s -> (the Instructions of S)-valued;
  coherence
   proof let e be set;
    assume e in rng ProgramPart s;
     then consider u being set such that
A1:   u in dom ProgramPart s and
A2:   e = (ProgramPart s).u by FUNCT_1:def 5;
   dom ProgramPart s = NAT /\ dom s by RELAT_1:90;
     then
    u in NAT by A1,XBOOLE_0:def 4;
     then
A3:    (the Object-Kind of S).u = the Instructions of S by Def8;
     reconsider u as Nat by A1;
    thus e in the Instructions of S
     by A2,A1,A3,FUNCT_1:def 20;
   end;
end;

Lm2: for N being with_non-empty_elements set for S being
  (non empty stored-program COM-Struct over N)
   for s being State of S
   holds dom ProgramPart s = NAT
proof
  let N be with_non-empty_elements set;
  let S be (non empty stored-program COM-Struct over N);
  let s be State of S;
A1:   NAT c= the carrier of S by Def2;
   dom s = the carrier of S by PARTFUN1:def 4;
  hence thesis by A1,RELAT_1:91;
end;

Lm3:
 for N being with_non-empty_elements non empty set
 for S being
  IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)
   for s being State of S
 for i being natural number holds
 (ProgramPart s)/.i = s.i
 proof
 let N being with_non-empty_elements non empty set;
 let S being IC-Ins-separated definite
  (non empty stored-program COM-Struct over N);
   let s being State of S;
  let i be natural number;
   dom ProgramPart s = NAT by Lm2;
   then i in dom ProgramPart s by ORDINAL1:def 13;
  hence (ProgramPart s)/.i = (ProgramPart s).i by PARTFUN1:def 8
        .= s.i by Lm1;
 end;

definition
  let N be set;
  let IT be COM-Struct over N;
  attr IT is realistic means
  :Def12:
  not the ZeroF of IT in NAT;
end;

theorem
 for i being natural number holds
 (ProgramPart s).i = s.i by Lm1;

theorem
  for S being IC-Ins-separated (non empty COM-Struct over A) st
  S is realistic holds not ex l being Element of NAT st IC S = l
      by Def12;

definition
  let N;
  let S be definite (non empty stored-program COM-Struct over N);
  let s be State of S, l be Element of NAT;
  redefine func s.l -> Instruction of S;
  coherence
  proof
A1:  dom the Object-Kind of S = the carrier of S by FUNCT_2:def 1;
A2:  l in NAT;
    NAT c= the carrier of S by Def2;
    then
A3:   pi(product the Object-Kind of S,l)
       = (the Object-Kind of S).l by A1,A2,CARD_3:22
      .= the Instructions of S by Def8;
     s in product the Object-Kind of S by PBOOLE:155;
    hence thesis by A3,CARD_3:def 6;
  end;
end;

registration
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  let p be FinPartState of S;
  cluster ProgramPart p -> finite;
  coherence;
end;

registration
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  let p be PartState of S;
  cluster ProgramPart p -> NAT-defined;
  coherence;
end;

Lm4:
  for N being with_non-empty_elements set, S
being stored-program COM-Struct over N, s being State of S holds NAT c= dom s
proof
  let N be with_non-empty_elements set, S be
  stored-program COM-Struct over N;
  let s be State of S;
  dom s = the carrier of S by PARTFUN1:def 4;
  hence thesis by Def2;
end;

registration
  let N be with_non-empty_elements set;
  let S be stored-program COM-Struct over N;
  let s be State of S;
  cluster ProgramPart s -> total;
  coherence
   proof
     NAT c= dom s by Lm4;
    hence dom ProgramPart s = NAT by RELAT_1:91;
   end;
end;

definition let N;
 let S be IC-Ins-separated definite
  (non empty stored-program COM-Struct over N);
 let P be (the Instructions of S)-valued ManySortedSet of NAT,
     k be Nat;
 redefine func P.k -> Instruction of S;
 coherence
  proof
A1:  k in NAT by ORDINAL1:def 13;
    dom P = NAT by PARTFUN1:def 4;
    then
A2:  P.k in rng P by A1,FUNCT_1:12;
    rng P c= the Instructions of S by RELAT_1:def 19;
   hence P.k is Instruction of S by A2;
  end;
end;

registration
  let N;
  let S be non empty COM-Struct over N, o be Object of S;
  cluster ObjectKind o -> non empty;
  coherence;
end;

begin :: Finite substates

definition
  let N be set;
  let S be COM-Struct over N;
  func FinPartSt S -> Subset of sproduct the Object-Kind of S equals
  { p where
  p is Element of sproduct the Object-Kind of S: p is finite };
  coherence
  proof
    defpred P[set] means $1 is finite;
    { p where p is Element of sproduct the Object-Kind of S: P[p] } c=
    sproduct the Object-Kind of S from FRAENKEL:sch 10;
    hence thesis;
  end;
end;

definition
  let N be set;
  let S be non empty COM-Struct over N;
  func Data-Locations S equals
  (the carrier of S) \ ({IC S} \/ NAT);
  coherence;
end;

definition
  let N be set;
  let S be non empty COM-Struct over N;
  redefine func Data-Locations S -> Subset of S;
  coherence;
end;

theorem Th4:
  for S being non empty COM-Struct over N for A,B being set, la
  ,lb being Object of S st ObjectKind la = A & ObjectKind lb = B for a being
Element of A, b being Element of B holds (la,lb) --> (a,b) is FinPartState of S
proof
  let S be non empty COM-Struct over N;
  let A,B be set, la,lb be Object of S such that
A1: ObjectKind la = A and
A2: ObjectKind lb = B;
  let a be Element of A, b be Element of B;
  set p = (la,lb) --> (a,b);
A3: dom p = {la,lb} by FUNCT_4:65;
A4: now
    let x be set such that
A5: x in dom p;
    now
      per cases by A3,A5,TARSKI:def 2;
      suppose
A6:     la <> lb & x = la;
        then p.x = a by FUNCT_4:66;
        hence p.x in (the Object-Kind of S).x by A1,A6;
      end;
      suppose
A7:     la <> lb & x = lb;
        then p.x = b by FUNCT_4:66;
        hence p.x in (the Object-Kind of S).x by A2,A7;
      end;
      suppose
A8:     la = lb & x = la;
        then p = la .--> b by CQC_LANG:44;
        then p.x = b by A8,FUNCOP_1:87;
        hence p.x in (the Object-Kind of S).x by A2,A8;
      end;
    end;
    hence p.x in (the Object-Kind of S).x;
  end;
  reconsider p as PartState of S by A4,FUNCT_1:def 20;
  dom p = {la,lb} by FUNCT_4:65;
  hence thesis;
end;

theorem Th5:
  for S being non empty COM-Struct over N for A being set, la
being Object of S st (the Object-Kind of S).la = A
 for a being Element of A holds la .--> a is FinPartState of S
proof
  let S be non empty COM-Struct over N;
  let A be set, la be Object of S such that
A1: (the Object-Kind of S).la = A;
  let a be Element of A;
  set p = la .--> a;
A2: dom p = {la} by FUNCOP_1:19;
A3: now
    let x be set;
    assume
    x in dom p;
    then
A4: x = la by A2,TARSKI:def 1;
    then p.x = a by FUNCOP_1:87;
    hence p.x in (the Object-Kind of S).x by A1,A4;
  end;
  reconsider p as PartState of S by A3,FUNCT_1:def 20;
  p is PartState of S;
  hence thesis;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program COM-Struct over
  N);
  let la be Object of S;
  let a be Element of ObjectKind la;
  redefine func la .--> a -> FinPartState of S;
  coherence by Th5;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program COM-Struct over
  N);
  let la,lb be Object of S;
  let a be Element of ObjectKind la, b be Element of ObjectKind lb;
  redefine func (la,lb) --> (a,b) -> FinPartState of S;
  coherence by Th4;
end;

registration
  let A;
  cluster Trivial-COM A -> realistic;
  coherence
proof
  assume the ZeroF of Trivial-COM A in NAT;
  hence thesis by Def1;
end;
end;

registration
  let A;
  cluster realistic strict COM-Struct over A;
  existence
  proof
    take Trivial-COM A;
    thus thesis;
  end;
end;

registration
  let N;
  cluster realistic strict
   (IC-Ins-separated definite (non empty stored-program COM-Struct over N));
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

reserve S for IC-Ins-separated definite realistic
  (non empty stored-program COM-Struct over N),
  s,s1,s2 for State of S;
reserve
  ins for Element of the Instructions of S;
reserve ss for Element of product the Object-Kind of S;
reserve p for FinPartState of S;

registration
  let N be set;
  let S be COM-Struct over N;
  let f,g be PartState of S;
  cluster f +* g -> (the carrier of S)-defined
           (the Object-Kind of S)-compatible Function;
  coherence;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty COM-Struct over N);
  let l be Nat;
  func Start-At(l,S) -> FinPartState of S equals
  IC S .--> l;
  correctness
  proof
    reconsider l as Element of NAT by ORDINAL1:def 13;
    ObjectKind IC S = NAT by Def6;
    then IC S .--> l is PartState of S by Th5;
    hence thesis;
  end;
end;

begin :: Preprograms

theorem
  for S being realistic IC-Ins-separated definite
   (non empty stored-program COM-Struct over N)
  for l being Element of NAT, I being Instruction of S
  for P being NAT-defined (the Instructions of S)-valued Function
   st l .--> I c= P
  for s being State of S st IC S .--> l c= s
   holds CurInstr(P,s) = I
proof
  let S be realistic IC-Ins-separated definite
   (non empty stored-program COM-Struct over N);
  let l be Element of NAT, I be Instruction of S;
  let P be NAT-defined (the Instructions of S)-valued Function such that
A1: l .--> I c= P;
  let s be State of S such that
A2: IC S .--> l c= s;
  dom(IC S .--> l) = {IC S} by FUNCOP_1:19;
  then IC S in dom(IC S .--> l) by TARSKI:def 1;
  then
A3: IC s = (IC S .--> l).IC S by A2,GRFUNC_1:8
     .= l by FUNCOP_1:87;
  dom(l.--> I) = {l} by FUNCOP_1:19;
  then
A4: IC s in dom(l.--> I) by A3,TARSKI:def 1;
  dom(l.--> I) c= dom P by A1,RELAT_1:25;
 hence CurInstr(P,s) = P.IC s by A4,PARTFUN1:def 8
   .= (l .--> I).IC s by A4,A1,GRFUNC_1:8
   .= I by A3,FUNCOP_1:87;
end;

definition
  let N be with_non-empty_elements set;
  let S be IC-Ins-separated (non empty COM-Struct over N),
      l be Nat;
  let p be PartState of S;
  attr p is l-started means
:Def16: IC S in dom p & IC p = l;
end;

begin :: InsType & InsCode

notation
  let x;
  synonym InsCode x for x`1_3;
  synonym JumpPart x for x`2_3;
  synonym AddressPart x for x`3_3;
end;

definition
  let N be set, S be COM-Struct over N;
  attr S is standard-ins means
:Def17:
   ex X being non empty set
    st the Instructions of S c= [: NAT,NAT*,X*:];
end;

registration
  let N be set;
  cluster Trivial-COM N -> standard-ins;
  coherence
  proof
    {} in ((union N) \/ the carrier of Trivial-COM N)* by FINSEQ_1:66;
    then
A1: {{}} c= ((union N) \/ the carrier of Trivial-COM N)* by ZFMISC_1:37;
    take X = (union N) \/ the carrier of Trivial-COM N;
    {} in NAT* by FINSEQ_1:66;
    then
A2:  {{}} c= NAT* by ZFMISC_1:37;
    the Instructions of Trivial-COM N = {[0,{},{}]} by Def1
      .= [:{0},{{}},{{}}:] by MCART_1:39;
    hence the Instructions of Trivial-COM N c= [: NAT,NAT*,X*:]
     by A1,A2,MCART_1:77;
  end;
end;

registration
  let N be set;
  cluster standard-ins non empty stored-program COM-Struct over N;
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

registration
  let N be set, S be standard-ins COM-Struct over N;
  cluster the Instructions of S -> Relation-like;
  coherence
   proof
    ex X being non empty set
     st the Instructions of S c= [: NAT,NAT*,X*:] by Def17;
    hence thesis;
   end;
end;

registration let N be set;
 let S be standard-ins non empty COM-Struct over N;
 let x be Instruction of S;
 cluster InsCode x -> natural;
 coherence
  proof
    consider X being non empty set such that
A1:   the Instructions of S c= [:NAT,NAT*,X*:] by Def17;
   x in the Instructions of S;
   then x`1_3 in NAT by A1,RECDEF_2:2;
   hence thesis;
  end;
end;

registration
  let N;
  cluster IC-Ins-separated definite standard-ins (non empty stored-program
    COM-Struct over N);
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

registration
  let N be set, S be standard-ins COM-Struct over N;
  cluster the Instructions of S -> Relation-like;
  coherence;
end;

definition
  let N be set, S be standard-ins COM-Struct over N;
  func InsCodes S equals
  proj1 proj1 the Instructions of S;
  correctness;
end;

registration
  let N be set, S be standard-ins COM-Struct over N;
  cluster InsCodes S ->non empty;
  coherence
   proof
    ex X being non empty set st the Instructions of S c= [: NAT,NAT*,X*:]
     by Def17;
    then reconsider II = dom the Instructions of S as Relation;
    assume InsCodes S is empty;
     then II = {};
    hence contradiction;
   end;
end;

definition
  let N be set, S be standard-ins COM-Struct over N;
  mode InsType of S is Element of InsCodes S;
end;

definition
  let N be set, S be standard-ins COM-Struct over N;
  let I be Element of the Instructions of S;
  redefine func InsCode I -> InsType of S;
  coherence
   proof
     consider X being non empty set such that
A1:    the Instructions of S c= [:NAT,NAT*,X*:] by Def17;
     I in the Instructions of S;
     then I = [ I`1_3, I`2_3, I`3_3 ] by A1,RECDEF_2:3;
     then [ I`1_3, I`2_3 ] in proj1 the Instructions of S by RELAT_1:def 4;
    hence thesis by RELAT_1:def 4;
   end;
end;

begin :: Some Remarks on COM-Struct

Lm5:
 for N being with_non-empty_elements set,
     S be COM-Struct over N
 for p being FinPartState of S holds p in FinPartSt S
 proof
  let N be with_non-empty_elements set,
     S be COM-Struct over N;
  let p be FinPartState of S;
   p in sproduct the Object-Kind of S by CARD_3:153;
  hence thesis;
 end;

registration
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  cluster FinPartSt S -> non empty;
  coherence by Lm5;
end;

registration
  let N be set;
  let S be COM-Struct over N;
  cluster NAT-defined (the Instructions of S)-valued FinPartState of S;
  existence
  proof
    reconsider Z = {} as FinPartState of S by FUNCT_1:174,RELAT_1:206;
    take Z;
    thus dom Z c= NAT by RELAT_1:60,XBOOLE_1:2;
    thus rng Z c= the Instructions of S by RELAT_1:60,XBOOLE_1:2;
  end;
end;

registration
  let N be set;
  let S be definite (non empty stored-program COM-Struct over N);
 cluster NAT-defined (the Instructions of S)-valued
      -> (the Object-Kind of S)-compatible Function;
 coherence
  proof let F be Function;
   assume
A1: F is NAT-defined (the Instructions of S)-valued;
   let x;
   assume
A2:   x in dom F;
A3: dom F c= NAT by A1,RELAT_1:def 18;
A4:  rng F c= the Instructions of S by A1,RELAT_1:def 19;
    F.x in rng F by A2,FUNCT_1:12;
    then
  F.x in the Instructions of S by A4;
   hence F.x in (the Object-Kind of S).x by A3,A2,Def8;
  end;
end;

theorem Th7:
 for N be set, S be standard-ins COM-Struct over N
 for I,J being Instruction of S
  st InsCode I = InsCode J & JumpPart I = JumpPart J &
   AddressPart I = AddressPart J
 holds I = J
proof
 let N be set, S be standard-ins COM-Struct over N;
 let I,J be Instruction of S;
  consider X being non empty set such that
A1:   the Instructions of S c= [:NAT,NAT*,X*:] by Def17;
A2: I in the Instructions of S;
  J in the Instructions of S;
 hence thesis by A2,A1,RECDEF_2:10;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty COM-Struct over N),
      l be Nat;
  cluster Start-At(l,S) -> l-started;
  coherence
   proof
     dom Start-At(l,S) = {IC S} by FUNCOP_1:19;
    hence IC S in dom Start-At(l,S) by TARSKI:def 1;
    thus IC Start-At(l,S) = l by FUNCOP_1:87;
   end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty COM-Struct over N),
      l be Nat;
  cluster l-started FinPartState of S;
  existence
   proof
    take Start-At(l,S);
    thus thesis;
   end;
end;

registration
  let N;
  let S be COM-Struct over N;
  let s be State of S;
  let p be PartState of S;
  cluster s +* p -> total PartState of S;
  coherence;
  cluster p +* s -> total PartState of S;
  coherence;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty COM-Struct over N),
      l be Nat,
      p being PartState of S, q be l-started PartState of S;
  cluster p +* q -> l-started;
  coherence
   proof
A1:   IC S in dom q by Def16;
     dom q c= dom(p+*q) by FUNCT_4:11;
    hence IC S in dom(p+*q) by A1;
     IC q = l by Def16;
    hence IC(p+*q) = l by A1,FUNCT_4:14;
   end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty COM-Struct over N),
      l be Nat;
  cluster l-started State of S;
  existence
   proof
    take t = (the State of S) +* Start-At(l,S);
    thus thesis;
   end;
end;

definition
  let N be with_non-empty_elements set;
  let S be (COM-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function, l be set;
  pred p halts_at l means
:Def19: l in dom p & p.l = halt S;
end;

Lm6:
  for N being with_non-empty_elements set,
      S being non empty COM-Struct over N
  for s being State of S holds IC S in dom s
proof
  let N be with_non-empty_elements set,
      S be non empty COM-Struct over N;
  let s be State of S;
  dom s = the carrier of S by PARTFUN1:def 4;
  hence thesis;
end;

definition
  let N;
  let S be IC-Ins-separated (non empty COM-Struct over N),
      l be Nat;
  let s be State of S;
  redefine attr s is l-started means
  IC s = l;
  compatibility
   proof
    thus s is l-started implies IC s = l by Def16;
    assume
A1:    IC s = l;
    thus IC S in dom s by Lm6;
    thus IC s = l by A1;
   end;
end;

definition
  let N be with_non-empty_elements set;
  let S be (non empty COM-Struct over N);
  let s be (the Instructions of S)-valued ManySortedSet of NAT,
      l be Nat;
  redefine pred s halts_at l means

  s.l = halt S;
  compatibility
   proof
    thus s halts_at l implies s.l = halt S by Def19;
    assume
A1:    s.l = halt S;
   l in NAT by ORDINAL1:def 13;
    hence l in dom s by PARTFUN1:def 4;
    thus s.l = halt S by A1;
   end;
end;

theorem
  for S being definite IC-Ins-separated
   (non empty stored-program COM-Struct over N),
      l being Nat,
      p being l-started PartState of S
  for s being PartState of S st p c= s holds s is l-started
proof
  let S be definite IC-Ins-separated
   (non empty stored-program COM-Struct over N),
      l be Nat,
      p be l-started PartState of S;
A1: IC S in dom p by Def16;
A2: IC p = l by Def16;
  let s be PartState of S;
  assume
A3:  p c= s;
   then dom p c= dom s by RELAT_1:25;
  hence IC S in dom s by A1;
  thus IC s = l by A3,A2,A1,GRFUNC_1:8;
end;

definition
  let N;
  let S be definite IC-Ins-separated (non empty stored-program COM-Struct over
  N);
  let l be Element of NAT, I be Element of the Instructions of S;
  redefine func l .--> I -> NAT-defined FinPartState of S;
  coherence;
end;

theorem
  for N being with_non-empty_elements set,
      S being non empty COM-Struct over N
  for s being State of S holds IC S in dom s by Lm6;

theorem Th10:
  for s being State of S holds Start-At(IC s,S) = s | {IC S}
proof
  let s be State of S;
A1: IC S in dom s by Lm6;
  thus Start-At(IC s,S) = {[IC S,s.IC S]} by FUNCT_4:87
    .= s | {IC S} by A1,GRFUNC_1:89;
end;

definition
  let N be set;
  let S be non empty COM-Struct over N;
  let p be PartState of S;
  func DataPart p -> PartState of S equals
  p | Data-Locations S;
  coherence;
  projectivity by RELAT_1:101;
end;

registration
  let N be set;
  let S be non empty COM-Struct over N;
  let p be FinPartState of S;
  cluster DataPart p -> finite;
  coherence;
end;

definition
  let N be set, S be non empty COM-Struct over N;
  let IT be PartState of S;
  attr IT is data-only means
:Def23:
  dom IT misses {IC S} \/ NAT;
end;

registration
  let N be set, S be non empty COM-Struct over N;
  cluster data-only FinPartState of S;
  existence
  proof
    set p =the  PartState of S;
    {} c= p by XBOOLE_1:2;
    then reconsider p = {} as FinPartState of S;
    take p;
    thus dom p misses {IC S} \/ NAT by RELAT_1:60,XBOOLE_1:65;
  end;
end;

theorem Th11:
  for N being set, S being non empty COM-Struct over N for
  p being PartState of S holds not IC S in dom DataPart p
proof
  let N be set, S be non empty COM-Struct over N;
  let p be PartState of S;
  assume
A1: IC S in dom (DataPart p);
  dom(DataPart p) c= ((the carrier of S) \ ({IC S} \/ NAT)) by RELAT_1:87;
  then not IC S in {IC S} \/ NAT by A1,XBOOLE_0:def 5;
  then not IC S in {IC S} by XBOOLE_0:def 3;
  hence contradiction by TARSKI:def 1;
end;

theorem Th12:
  for S being IC-Ins-separated definite realistic (non empty
stored-program COM-Struct over N) for p being PartState of S holds not IC
  S in dom (ProgramPart p)
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  COM-Struct over N);
  let p be PartState of S;
  assume
A1: IC S in dom (ProgramPart p);
  dom(ProgramPart p) c= NAT by RELAT_1:87;
  then reconsider l = IC S as Element of NAT by A1;
  not l in dom ProgramPart p by Def12;
  hence contradiction by Def12;
end;

theorem
  for N being set, S being non empty COM-Struct over N for p being
  PartState of S holds {IC S} misses dom DataPart p by Th11,ZFMISC_1:56;

theorem
  for S being IC-Ins-separated definite realistic (non empty
stored-program COM-Struct over N) for p being PartState of S holds {IC S}
  misses dom (ProgramPart p) by Th12,ZFMISC_1:56;

theorem Th15:
  for p,q being PartState of S holds dom DataPart p misses dom
  ProgramPart q
proof
  let p,q be PartState of S;
  ((the carrier of S) \ ({IC S} \/ NAT)) c= (the carrier of S) \ NAT & dom(
DataPart p) c= ((the carrier of S) \ ({IC S} \/ NAT))
 by RELAT_1:87,XBOOLE_1:7,34;
  then
A1: dom(DataPart p) c= (the carrier of S) \ NAT by XBOOLE_1:1;
  dom ProgramPart q c= NAT by RELAT_1:87;
  hence thesis by A1,XBOOLE_1:64,79;
end;

theorem Th16:
  for p being PartState of S, l being Element of NAT st l
  in dom p holds l in dom ProgramPart p
proof
  let p be PartState of S, l be Element of NAT;
A1: dom ProgramPart p = dom p /\ NAT by RELAT_1:90;
  assume
  l in dom p;
  hence thesis by A1,XBOOLE_0:def 4;
end;

theorem
  for p being data-only PartState of S, q being PartState of S
  holds p c= q iff p c= DataPart(q)
proof
  let p be data-only PartState of S, q be PartState of S;
  set X = (the carrier of S) \ ({IC S} \/ NAT);
A1: q|X c= q by RELAT_1:88;
  hereby
A2:  X \/ ({IC S} \/ NAT) = (the carrier of S) \/ ({IC S} \/ NAT)
     by XBOOLE_1:39;
    dom p c= the carrier of S by RELAT_1:def 18;
    then
A3: dom p c= X \/ ({IC S} \/ NAT) by A2,XBOOLE_1:10;
    assume
    p c= q;
    then
A4: p|X c= DataPart q by RELAT_1:105;
    dom p misses {IC S} \/ NAT by Def23;
    hence p c= DataPart q by A4,A3,RELAT_1:97,XBOOLE_1:73;
  end;
  assume
  p c= DataPart q;
  hence thesis by A1,XBOOLE_1:1;
end;

theorem Th18:
  for S being IC-Ins-separated definite realistic (non empty
  stored-program COM-Struct over N)
  for p being PartState of S st IC S in
  dom p holds p = Start-At(IC p,S) +* ProgramPart p +* DataPart p
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  COM-Struct over N);
  let p be PartState of S;
  assume IC S in dom p;
  then
A1: {IC S} is Subset of dom p by SUBSET_1:63;
A2: NAT c= the carrier of S by Def2;
A3: ({IC S} \/ (NAT) \/ ((the carrier of S) \ ({IC S} \/ NAT))) = ((the
  carrier of S) \/ ({IC S} \/ NAT)) by XBOOLE_1:39
    .= the carrier of S by A2,XBOOLE_1:8,12;
A4: dom p c= the carrier of S by RELAT_1:def 18;
A5: now
    let x be set;
    assume
A6: x in dom p;
    then
A7: x in {IC S} \/ (NAT) or x in (the carrier of S) \ ({IC S} \/ NAT) by A4,A3,
XBOOLE_0:def 3;
    per cases by A7,XBOOLE_0:def 3;
    suppose
A8:   x in {IC S};
      {IC S} = dom Start-At(IC p,S) by FUNCOP_1:19;
      then IC S in dom Start-At(IC p,S) by TARSKI:def 1;
      then
A9:  IC S in dom Start-At(IC p,S) \/ dom ProgramPart p by XBOOLE_0:def 3;
      then IC S in dom (Start-At(IC p,S) +* ProgramPart p) by FUNCT_4:def 1;
      then
A10:  IC S in dom (Start-At(IC p,S) +* ProgramPart p) \/ dom DataPart p by
XBOOLE_0:def 3;
A11:  not IC S in dom (ProgramPart p) by Th12;
A12:  x = IC S by A8,TARSKI:def 1;
      not IC S in dom (DataPart p) by Th11;
      then
      (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x = (Start-At(IC p,S)
      +* ProgramPart p).x by A12,A10,FUNCT_4:def 1
        .= (Start-At(IC p,S)).x by A12,A9,A11,FUNCT_4:def 1
        .= IC p by A12,FUNCOP_1:87
        .= p.IC S;
      hence p.x = (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x by A8,
TARSKI:def 1;
    end;
    suppose
      x in (the carrier of S) \ ({IC S} \/ NAT);
      then x in dom p /\ ((the carrier of S) \ ({IC S} \/ NAT)) by A6,
XBOOLE_0:def 4;
      then
A13:  x in dom (p | ((the carrier of S) \ ({IC S} \/ NAT))) by RELAT_1:90;
      then x in dom (Start-At(IC p,S) +* ProgramPart p) \/ dom (p | ((the
      carrier of S) \ ({IC S} \/ NAT))) by XBOOLE_0:def 3;
      then (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x = (p | ((the
      carrier of S) \ ({IC S} \/ NAT))).x by A13,FUNCT_4:def 1
        .= p.x by A13,FUNCT_1:70;
      hence p.x = (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x;
    end;
    suppose
      x in NAT;
      then x in dom p /\ NAT by A6,XBOOLE_0:def 4;
      then
A14:  x in dom (p | NAT) by RELAT_1:90;
      dom (DataPart p) misses dom (ProgramPart p) by Th15;
      then
A15:  not x in dom (DataPart p) by A14,XBOOLE_0:3;
A16:  x in dom (Start-At(IC p,S)) \/ dom (ProgramPart p) by A14,XBOOLE_0:def 3;
      then x in dom (Start-At(IC p,S) +* ProgramPart p) by FUNCT_4:def 1;
      then x in dom (Start-At(IC p,S) +* ProgramPart p) \/ dom (DataPart p) by
XBOOLE_0:def 3;
      then
      (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x = (Start-At(IC p,S)
      +* ProgramPart p).x by A15,FUNCT_4:def 1
        .= (p | NAT ).x by A14,A16,FUNCT_4:def 1
        .= p.x by A14,FUNCT_1:70;
      hence p.x = (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x;
    end;
  end;
A17: dom p c= the carrier of S by RELAT_1:def 18;
  dom(Start-At(IC p,S) +* ProgramPart p +* DataPart p) = dom (Start-At(IC p
  ,S) +* ProgramPart p) \/ dom (DataPart p) by FUNCT_4:def 1
    .= dom (Start-At(IC p,S)) \/ dom (ProgramPart p) \/ dom (DataPart p) by
FUNCT_4:def 1
    .= {IC S} \/ dom (p | NAT) \/ dom(DataPart p) by FUNCOP_1:19
    .= dom p /\ {IC S} \/ dom (p|NAT) \/ dom(p|((the carrier of S) \ ({IC S}
  \/ NAT))) by A1,XBOOLE_1:28
    .= dom p /\ {IC S} \/ dom p /\ (NAT) \/ dom(p|((the carrier of S) \ ({IC
  S} \/ NAT))) by RELAT_1:90
    .= dom p /\ {IC S} \/ dom p /\ (NAT) \/ dom p /\ ((the carrier of S) \ ({
  IC S} \/ NAT)) by RELAT_1:90
    .= dom p /\ ({IC S} \/ (NAT)) \/ dom p /\ ((the carrier of S) \ ({IC S}
  \/ NAT)) by XBOOLE_1:23
    .= dom p /\ the carrier of S by A3,XBOOLE_1:23
    .= dom p by A17,XBOOLE_1:28;
  hence thesis by A5,FUNCT_1:9;
end;

definition
  let N,S;
  let IT be PartFunc of FinPartSt S,FinPartSt S;
  attr IT is data-only means
  for p being PartState of S st p in dom IT
  holds p is data-only & for q being PartState of S st q = IT.p holds q is
  data-only;
end;

theorem
  for S being IC-Ins-separated definite realistic (non empty
  stored-program COM-Struct over N) for p being PartState of S st IC S in
  dom p holds p is not NAT-defined
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  COM-Struct over N);
  let p be PartState of S;
  assume
A1: IC S in dom p;
  assume
  p is NAT-defined;
  then dom p = dom ProgramPart p by RELAT_1:209;
  hence contradiction by A1,Th12;
end;

theorem
  for S being IC-Ins-separated definite realistic (non empty
  stored-program COM-Struct over N) for s being State of S, iloc being
Element of NAT, a being Element of NAT holds s.a = (s +*
  Start-At(iloc,S)).a
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  COM-Struct over N);
  let s be State of S, iloc be Element of NAT, a be
  Element of NAT;
A1: a in NAT;
  NAT c= the carrier of S by Def2;
  then a in the carrier of S by A1;
  then a in dom s by PARTFUN1:def 4;
  then
A2: dom (Start-At(iloc,S)) = {IC S} & a in dom s \/ dom (Start-At(iloc,S)) by
FUNCOP_1:19,XBOOLE_0:def 3;
  a <> IC S by Def12;
  then not a in {IC S} by TARSKI:def 1;
  hence thesis by A2,FUNCT_4:def 1;
end;

theorem
  for N being with_non-empty_elements set, S
being stored-program COM-Struct over N, s being State of S holds NAT c= dom s
                by Lm4;

theorem
  for N being with_non-empty_elements set, S being IC-Ins-separated (non
  empty stored-program COM-Struct over N), s being State of S holds IC s in
  dom s
proof
  let N be with_non-empty_elements set, S be IC-Ins-separated (non empty
  stored-program COM-Struct over N);
  let s be State of S;
A1:      IC s in NAT;
        NAT c= the carrier of S by Def2;
        then IC s in the carrier of S by A1;
  hence thesis by PARTFUN1:def 4;
end;

theorem Th23:
  for N being with_non-empty_elements set, S being non empty
  stored-program COM-Struct over N, s being State of S, l being
  Element of NAT holds l in dom s
proof
  let N be with_non-empty_elements set, S be non empty stored-program
  COM-Struct over N;
  let s be State of S, l be Element of NAT;
A1:      l in NAT;
        NAT c= the carrier of S by Def2;
        then l in the carrier of S by A1;
  hence thesis by PARTFUN1:def 4;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be definite (non empty stored-program COM-Struct over N);
  let s be NAT-defined PartState of S;
  let f be Function of the Instructions of S, the Instructions of S;
  redefine func f*s -> NAT-defined PartState of S;
  coherence;
end;

canceled;

definition
  let N be with_non-empty_elements set;
  let S be IC-Ins-separated definite (non empty stored-program COM-Struct over
  N);
  let s be State of S, l be Element of NAT, i be Instruction of S;
  redefine func s+*(l,i) -> State of S;
  coherence
  proof
    now
      let x be set;
      assume
A1:   x in dom(s+*(l,i));
A2:   x in dom s by A1,FUNCT_7:32;
      per cases;
      suppose
A3:     x = l;
        then
A4:     (the Object-Kind of S).x = the Instructions of S by Def8;
A5:      l in NAT;
        NAT c= the carrier of S by Def2;
        then l in the carrier of S by A5;
        then l in dom s by PARTFUN1:def 4;
        then (s+*(l,i)).x = i by A3,FUNCT_7:33;
        hence (s+*(l,i)).x in (the Object-Kind of S).x by A4;
      end;
      suppose
        x <> l;
        then (s+*(l,i)).x = s.x by FUNCT_7:34;
        hence (s+*(l,i)).x in (the Object-Kind of S).x by A2,FUNCT_1:def 20;
      end;
    end;
    hence thesis by FUNCT_1:def 20;
  end;
end;

theorem
  for S being COM-Struct over N, p being Element of FinPartSt S holds
  p is FinPartState of S
proof
  let S be COM-Struct over N;
  let p be Element of FinPartSt S;
  p in FinPartSt S;
  then ex q being Element of sproduct the Object-Kind of S st q = p & q is
  finite;
  hence thesis;
end;

theorem Th26:
  for N being with_non-empty_elements non empty set,
      S being IC-Ins-separated realistic (non empty COM-Struct over N),
      l being Element of NAT holds dom Start-At(l,S) misses NAT
proof

  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated realistic (non empty COM-Struct over N);
  let l be Element of NAT;
  dom Start-At(l,S) = {IC S} & not IC S in NAT by Def12,FUNCOP_1:19;
  hence thesis by ZFMISC_1:56;
end;

theorem Th27:
  for N being with_non-empty_elements non empty set, S
  being IC-Ins-separated realistic (non empty COM-Struct over N), l being
  Element of NAT holds ProgramPart Start-At(l,S) = {}
proof
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated realistic (non empty COM-Struct over N);
  let l be Element of NAT;
  dom Start-At(l,S) misses NAT by Th26;
  hence thesis by RELAT_1:187;
end;

registration
  let N be set;
  let S be non empty COM-Struct over N;
  let p be PartState of S;
  cluster DataPart p -> data-only;
  coherence
  proof
    ((the carrier of S) \ ({IC S} \/ NAT)) c= (the carrier of S) \ NAT & dom
( DataPart p) c= ((the carrier of S) \ ({IC S} \/ NAT))
 by RELAT_1:87,XBOOLE_1:7,34;
    then dom(DataPart p) c= (the carrier of S) \ NAT by XBOOLE_1:1;
    then
A1: dom DataPart p misses NAT by XBOOLE_1:64,79;
    dom DataPart p misses {IC S} by Th11,ZFMISC_1:56;
    hence dom DataPart p misses {IC S} \/ NAT by A1,XBOOLE_1:70;
  end;
end;

theorem
  for N being with_non-empty_elements set,
      S being non empty COM-Struct over N, p be
  data-only PartState of S holds ProgramPart p = {}
proof
  let N be with_non-empty_elements set, S be non empty COM-Struct over N,
      p be data-only
  PartState of S;
  dom p misses {IC S} \/ NAT by Def23;
  then dom p misses NAT by XBOOLE_1:70;
  hence thesis by RELAT_1:187;
end;

theorem
  for N being with_non-empty_elements non empty set, S
  being IC-Ins-separated realistic (non empty COM-Struct over N), l,l1 being
  Element of NAT holds not l in dom Start-At(l1,S)
proof
  let N be with_non-empty_elements non empty set, S be
  IC-Ins-separated realistic (non empty COM-Struct over N), l,l1 be
  Element of NAT;
  assume
  l in dom Start-At(l1,S);
  then NAT meets dom Start-At(l1,S) by XBOOLE_0:3;
  hence thesis by Th26;
end;

theorem Th30:
  for N being with_non-empty_elements non empty set, S
  being IC-Ins-separated (non empty COM-Struct over N), l being
  Element of NAT holds DataPart Start-At(l,S) = {}
proof
  let N be with_non-empty_elements non empty set, S be
IC-Ins-separated (non empty COM-Struct over N), l be Element of NAT;
  Data-Locations S misses {IC S} \/ NAT by XBOOLE_1:79;
  then Data-Locations S misses {IC S} by XBOOLE_1:70;
  then Data-Locations S misses dom Start-At(l,S) by FUNCOP_1:19;
  hence thesis by RELAT_1:95;
end;

theorem Th31:
  for S being non empty COM-Struct over N, p being PartState
  of S holds p is data-only iff dom p c= Data-Locations S
proof
  let S be non empty COM-Struct over N, p be PartState of S;
  thus p is data-only implies dom p c= Data-Locations S
  proof
A1: dom p c= the carrier of S by RELAT_1:def 18;
    assume dom p misses {IC S} \/ NAT;
    hence thesis by A1,XBOOLE_1:86;
  end;
  assume
  dom p c= Data-Locations S;
  hence dom p misses {IC S} \/ NAT by XBOOLE_1:106;
end;

theorem
  for S being IC-Ins-separated definite realistic (non empty
  stored-program COM-Struct over N), s be State of S for X being set st X c=
  NAT holds rng(s|X) c= the Instructions of S
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  COM-Struct over N);
  let s be State of S;
  let X be set such that
A1: X c= NAT;
  let x be set;
  assume
  x in rng(s|X);
  then consider y being set such that
A2: y in dom(s|X) and
A3: (s|X).y = x by FUNCT_1:def 5;
A4: dom(s|X) c= X by RELAT_1:87;
  then dom(s|X) c= NAT by A1,XBOOLE_1:1;
  then reconsider y as Element of NAT by A2;
  x = s.y by A2,A3,A4,FUNCT_1:72;
  hence thesis;
end;

theorem
  for S being non empty COM-Struct over N, p being PartState of S
  holds p is data-only iff DataPart p = p
proof
  let S be non empty COM-Struct over N, p be PartState of S;
  thus p is data-only implies DataPart p = p
  proof
    assume
    p is data-only;
    then dom p c= Data-Locations S by Th31;
    hence thesis by RELAT_1:97;
  end;
  assume
  DataPart p = p;
  hence thesis;
end;

theorem
 for N being with_non-empty_elements set for S being
  (non empty stored-program COM-Struct over N)
   for s being State of S
   holds dom ProgramPart s = NAT by Lm2;

theorem
 for N being with_non-empty_elements set,
     S be COM-Struct over N
 for p being FinPartState of S holds p in FinPartSt S by Lm5;

canceled 2;

theorem
 for N being with_non-empty_elements non empty set
 for S being
  IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)
   for s being State of S
 for i being natural number holds
 (ProgramPart s)/.i = s.i by Lm3;

canceled;

theorem Th40:
  for N be set, S be non empty COM-Struct over N
  for d be data-only PartState of S
  holds dom d misses NAT
 proof
  let N be set, S be non empty COM-Struct over N;
  let d be data-only PartState of S;
   dom d misses {IC S} \/ NAT by Def23;
  hence dom d misses NAT by XBOOLE_1:70;
 end;

registration
  let N be set, S be COM-Struct over N;
  cluster empty -> (the Instructions of S)-valued
   NAT-defined FinPartState of S;
  coherence
  proof
    let F be FinPartState of S;
    assume
A1:   F is empty;
    then rng F = {};
    hence rng F c= the Instructions of S by XBOOLE_1:2;
     dom F = {} by A1;
    hence dom F c= NAT by XBOOLE_1:2;
  end;
end;

registration
  let N be set, S be COM-Struct over N;
  cluster empty FinPartState of S;
  existence
  proof
    reconsider a = {} as FinPartState of S by FUNCT_1:174,RELAT_1:206;
    take a;
    thus thesis;
  end;
end;

registration

  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite (non
  empty stored-program COM-Struct over N);
  cluster non empty trivial NAT-defined
    (the Instructions of S)-valued FinPartState of S;
  existence
  proof
    set l =the  Element of NAT,I =the  Instruction of S;
    take l .--> I;
    thus thesis;
  end;
end;

begin :: Closedness of finite partial states

notation
  let N be set, S be COM-Struct over N;
  let i be Instruction of S;
  synonym Load i for <%i%>;
end;

registration
  let N be set;
  let S be definite (non empty stored-program COM-Struct over N);
 let ins be Element of the Instructions of S;
 cluster Load ins -> (the carrier of S)-defined;
 coherence;
end;

registration
  let N,S;
  cluster initial non empty trivial NAT-defined
     (the Instructions of S)-valued FinPartState of S;
  existence
  proof
    reconsider p = <%the Instruction of S%> as FinPartState of S;
   take p;
   thus thesis;
  end;
end;

Lm7: now
  let N;
  let S be   (IC-Ins-separated definite (non empty
  stored-program COM-Struct over N));
  set F = <%halt S%>;
A1: dom F = {0} by FUNCOP_1:19;
  then
A2: card dom F = 1 by CARD_1:50;
A3: LastLoc F = card F -' 1 by AFINSQ_1:74
    .= 0 by A2,XREAL_1:234;
  hence F.(LastLoc F) = halt S by FUNCOP_1:87;
  let l be Element of NAT such that
  F.l = halt S;
  assume l in dom F;
  hence l = LastLoc F by A1,A3,TARSKI:def 1;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite (non empty stored-program COM-Struct over N),
  F be non empty NAT-defined FinPartState of S;
  attr F is halt-ending means
  :Def25:
  F.(LastLoc F) = halt S;
  attr F is unique-halt means
  :Def26:
  for f being Element of NAT st
  F.f = halt S & f in dom F holds f = LastLoc F;
end;

registration let N,S;
  cluster halt-ending unique-halt trivial (initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S);
  existence
  proof
    reconsider F = <%halt S%> as initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S;
    take F;
    thus F.(LastLoc F) = halt S by Lm7;
    thus for f being Element of NAT st F.f = halt S & f in dom F
    holds f = LastLoc F by Lm7;
    thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be   realistic (IC-Ins-separated definite
    (non empty
  stored-program COM-Struct over N));
  cluster trivial initial non empty
  (NAT-defined (the Instructions of S)-valued FinPartState of S);
  existence
  proof
    reconsider F = <%halt S%> as initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S;
    take F;
    thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be realistic (IC-Ins-separated definite
    (non empty
  stored-program COM-Struct over N));
  cluster halt-ending unique-halt trivial (initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S);
  existence
  proof
    reconsider F = <%halt S%> as initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S;
    take F;
    thus F.(LastLoc F) = halt S by Lm7;
    thus for f being Element of NAT st F.f = halt S & f in dom F
    holds f = LastLoc F by Lm7;
    thus thesis;
  end;
end;

definition let N,S;
  mode pre-Macro of S is halt-ending unique-halt (initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S);
end;

canceled;

theorem
  for ins being Element of the Instructions of Trivial-COM N holds
  InsCode ins = 0
proof
  let ins be Element of the Instructions of Trivial-COM(N);
  the Instructions of Trivial-COM(N) = {[0,{},{}]} by Def1;
  then ins = [0,{},{}] by TARSKI:def 1;
  hence thesis by RECDEF_2:def 1;
end;

begin :: Addenda

reserve i, j, k for natural number,
  f for FinPartState of S;

theorem
  for l1, l2 being Element of NAT holds Start-At(l1+k,S) =
  Start-At(l2+k,S) iff Start-At(l1,S) = Start-At(l2,S)
proof
  let l1,l2 be Element of NAT;
  hereby
    assume Start-At(l1+k,S) = Start-At(l2+k,S);
    then {[IC S, l1+k]} = IC S .--> (l2+k) by FUNCT_4:87;
    then {[IC S, l1+k]} = {[IC S, l2+k]} by FUNCT_4:87;
    then [IC S, l1+k] = [IC S, l2+k] by ZFMISC_1:6;
    then l1+k = l2+k by ZFMISC_1:33;
    hence Start-At(l1,S) = Start-At(l2,S);
  end;
  assume Start-At(l1,S) = Start-At(l2,S);
  then {[IC S, l1]} = Start-At(l2,S) by FUNCT_4:87;
  then {[IC S, l1]} = {[IC S, l2]} by FUNCT_4:87;
  then [IC S, l1] = [IC S, l2] by ZFMISC_1:6;
  hence thesis by ZFMISC_1:33;
end;

theorem
  for l1, l2 being Element of NAT st Start-At(l1,S) = Start-At(
  l2,S) holds Start-At(l1 -' k,S) = Start-At(l2 -' k,S)
proof
  let l1, l2 be Element of NAT;
  assume Start-At(l1,S) = Start-At(l2,S);
  then {[IC S, l1]} = Start-At(l2,S) by FUNCT_4:87
    .= {[IC S, l2]} by FUNCT_4:87;
  then [IC S, l1] = [IC S, l2] by ZFMISC_1:6;
  hence thesis by ZFMISC_1:33;
end;

begin :: SCMNORM

definition
  let l be Element of NAT;
  redefine func succ l -> Element of NAT;
  coherence;
end;

registration
  let N be set;
  let S be COM-Struct over N;
  let p be NAT-defined (the Instructions of S)-valued Function,
      k be Element of NAT;
  cluster Shift(p,k) -> (the Instructions of S)-valued;
  coherence;
end;

definition
  let N be set;
  let S be COM-Struct over N;
  mode preProgram of S is
   NAT-defined (the Instructions of S)-valued FinPartState of S;
end;

registration
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  cluster empty FinPartState of S;
  existence
  proof
    {} is FinPartState of S by FUNCT_1:174,RELAT_1:206;
    hence thesis;
  end;
end;

registration
  let N be set;
  let S be COM-Struct over N;
  cluster empty -> NAT-defined FinPartState of S;
  coherence;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be  definite (non empty stored-program COM-Struct over N);
  func Stop S -> preProgram of S equals
  <% halt S %>;
  coherence;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be  definite (non empty stored-program COM-Struct over N);
  cluster Stop S -> initial non empty;
  coherence;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be  definite (non empty stored-program COM-Struct over N);
  cluster initial non empty preProgram of S;
  existence
  proof
    take Stop S;
    thus thesis;
  end;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be  definite (non empty stored-program COM-Struct over N);
  mode Program of S is initial non empty preProgram of S;
end;

theorem
  0 in dom Stop S
proof dom Stop S = 1 by AFINSQ_1:36;
  hence thesis by CARD_1:87,TARSKI:def 1;
end;

theorem Th46:
  card Stop S = 1 by AFINSQ_1:36;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated definite realistic
  (non empty stored-program COM-Struct over N);
  let I be initial FinPartState of S;
  cluster ProgramPart I -> initial Function;
  coherence
  proof
    ProgramPart I is initial
    proof
      let m,n be Nat such that
A1:   n in dom ProgramPart I and
A2:   m < n;
A3:   m is Element of NAT by ORDINAL1:def 13;
      ProgramPart I c= I by RELAT_1:88;
      then dom ProgramPart I c= dom I by RELAT_1:25;
      then m in dom I by A1,A2,AFINSQ_1:def 13;
      hence thesis by A3,Th16;
    end;
    hence thesis;
  end;
end;

definition
  let N,S;
  let p be PartState of S, k be Nat;
  func IncIC(p,k) -> PartState of S equals
  p +* Start-At(IC p+k,S);
  correctness;
end;

registration
  let N,S;
  let p be FinPartState of S, k be Nat;
  cluster IncIC(p,k) -> finite;
  coherence;
end;

theorem
  for S being realistic IC-Ins-separated (non empty COM-Struct over N)
  for k being Element of NAT
  holds Start-At(k,S)|NAT = {}
  proof let S be realistic IC-Ins-separated (non empty COM-Struct over N);
   let k be Element of NAT;
A1:  dom Start-At(k,S) = {IC S} by FUNCOP_1:19;
    not IC S in NAT by Def12;
    then dom Start-At(k,S) misses NAT by A1,ZFMISC_1:56;
   hence thesis by RELAT_1:95;
  end;

theorem Th48:
  for p being FinPartState of S, k being Element of NAT
  holds DataPart IncIC(p,k) = DataPart p
proof
  let p be FinPartState of S, k be Element of NAT;
  thus DataPart IncIC(p,k)
  = DataPart p +* DataPart Start-At(IC p+k,S) by FUNCT_4:75
    .= DataPart p +* {} by Th30
    .= DataPart p by FUNCT_4:22;
end;

theorem Th49:
  Data-Locations S c= dom s
proof
  dom s = the carrier of S by PARTFUN1:def 4;
  hence thesis;
end;

theorem Th50:
  dom DataPart s = Data-Locations S
proof
  Data-Locations S c= dom s by Th49;
  hence thesis by RELAT_1:91;
end;

theorem Th51:
 for S being non empty COM-Struct over N
  holds NAT misses Data-Locations S
proof
 let S be non empty COM-Struct over N;
  Data-Locations S misses {IC S} \/ NAT by XBOOLE_1:79;
  hence thesis by XBOOLE_1:70;
end;

theorem Th52:
 for l being Nat
 holds IC S in dom Start-At(l,S)
proof
 let l be Nat;
  dom Start-At(l,S) = {IC S} by FUNCOP_1:19;
  hence thesis by TARSKI:def 1;
end;

theorem Th53:
 for p being PartState of S
  holds IC S in dom IncIC(p,k)
proof let p be PartState of S;
A1: dom IncIC(p,k) = dom p \/ dom Start-At(IC p+k,S) by FUNCT_4:def 1;
  IC S in dom Start-At(IC p+k,S) by Th52;
  hence thesis by A1,XBOOLE_0:def 3;
end;

theorem Th54:
  for p being PartState of S, k being Nat
   holds IC IncIC (p,k) = IC p + k
proof
  let p be PartState of S, k be Nat;
   dom Start-At(IC p+k,S) = {IC S} by FUNCOP_1:19;
   then IC S in dom Start-At(IC p+k,S) by TARSKI:def 1;
  hence IC IncIC (p,k) = (Start-At((IC p)+k,S)).IC S by FUNCT_4:14
    .= IC p +k by FUNCOP_1:87;
end;

canceled;

theorem Th56:
  not IC S in Data-Locations S
proof
  assume IC S in Data-Locations S;
  then not IC S in {IC S} \/ NAT by XBOOLE_0:def 5;
  then not IC S in {IC S} by XBOOLE_0:def 3;
  hence contradiction by TARSKI:def 1;
end;

theorem Th57:
  for d being data-only PartState of S
  holds not IC S in dom d
proof
  let d be data-only PartState of S;
  dom d c= Data-Locations S by Th31;
  hence thesis by Th56;
end;

theorem Th58:
  for p being PartState of S, d being data-only FinPartState of S
  holds IC (p+*d) = IC p
proof
  let p be PartState of S, d be data-only FinPartState of S;
A1: not IC S in dom d by Th57;
  thus IC(p+*d) = (p+*d).IC S
    .= p.IC S by A1,FUNCT_4:12
    .= IC p;
end;

theorem Th59:
  for d being data-only FinPartState of S
  holds d tolerates Start-At(l,S)
proof
  let d be data-only FinPartState of S;
  dom Start-At(l,S) = {IC S} by FUNCOP_1:19;
  then dom d misses dom Start-At(l,S) by Th57,ZFMISC_1:56;
  hence thesis by PARTFUN1:138;
end;

theorem Th60:
  for d being data-only FinPartState of S
  holds IncIC(p+*d,k) = IncIC(p,k) +* d
proof
  let d be data-only FinPartState of S;
A1: d tolerates Start-At(IC p+k,S) by Th59;
  thus IncIC(p+*d,k) = p +* d +* Start-At(IC p+k,S) by Th58
    .= p +* (d +* Start-At(IC p+k,S)) by FUNCT_4:15
    .= p +* (Start-At(IC p+k,S) +* d) by A1,FUNCT_4:35
    .= IncIC(p,k) +* d by FUNCT_4:15;
end;

theorem
  for d being data-only FinPartState of S,
  f being finite NAT-defined (the Instructions of S)-valued Function
  holds d tolerates f
proof
  let d be data-only FinPartState of S,
  f be finite NAT-defined (the Instructions of S)-valued Function;
A1: dom f c= NAT by RELAT_1:def 18;
  dom d c= Data-Locations S by Th31;
  then dom d misses dom f by A1,Th51,XBOOLE_1:64;
  hence thesis by PARTFUN1:138;
end;

theorem
  for d being data-only PartState of S
  holds ProgramPart IncIC(d,k) = {}
proof
  let d be data-only PartState of S;
A1: dom IncIC(d,k) = dom d \/ dom Start-At(IC d+k,S) by FUNCT_4:def 1;
A2: dom d c= Data-Locations S by Th31;
  NAT misses Data-Locations S by Th51;
  then
A3: dom d misses NAT by A2,XBOOLE_1:63;
  dom Start-At(IC d+k,S) misses NAT by Th26;
  then dom IncIC(d,k) misses NAT by A1,A3,XBOOLE_1:70;
  hence thesis by RELAT_1:95;
end;

theorem
  for p being FinPartState of S,k being Element of NAT holds
  Start-At(IC p+k,S) c= IncIC (p,k)
proof
  let p be FinPartState of S, k be Element of NAT;
A1: IC IncIC(p,k) = IC p + k by Th54;
A2: IC S in dom (IncIC(p,k)) by Th53;
A3: Start-At(IC p+k,S) = {[IC S,IC p + k]} & [IC S,IC p + k] in
  IncIC(p,k) by A2,A1,FUNCT_1:def 4,FUNCT_4:87;
  for x being set st x in Start-At(IC p+k,S)
    holds x in IncIC (p,k) by A3,TARSKI:def 1;
 hence thesis by TARSKI:def 3;
end;

theorem
 IC Start-At(l,S) = l by FUNCOP_1:87;

:: pomocnicze pojecia na czas rewizji:

definition
 let N be set, S be COM-Struct over N;
 let p be PartState of S;
 attr p is program-free means
:Def29: p|NAT = {};
 func NPP p -> PartState of S equals
  p \ ProgramPart p;
 coherence;
end;

theorem Th65:
 for S being COM-Struct over N
 for p being PartState of S
  holds NPP p = p|((the carrier of S)\NAT)
proof
 let S be COM-Struct over N;
 let p be PartState of S;
    dom p c= the carrier of S by RELAT_1:def 18;
 hence NPP p = p|((the carrier of S)\NAT) by RELAT_1:211;
end;

registration let N; let S be non empty COM-Struct over N;
 let p be FinPartState of S;
 cluster NPP p -> finite;
 coherence;
end;

registration let N; let S be non empty COM-Struct over N;
 cluster data-only -> program-free PartState of S;
 coherence
  proof let p be PartState of S;
   assume dom p misses {IC S} \/ NAT;
    then dom p misses NAT by XBOOLE_1:70;
   hence p|NAT = {} by RELAT_1:95;
  end;
end;

registration let N; let S be non empty COM-Struct over N;
 cluster program-free FinPartState of S;
 existence
  proof
   take the data-only FinPartState of S;
   thus thesis;
  end;
end;

theorem Th66:
 for p being PartState of S, d being program-free PartState of S
  holds ProgramPart(p+*d) = ProgramPart p
 proof
  let p be PartState of S, d being program-free PartState of S;
  thus ProgramPart(p+*d) = ProgramPart p +* d|NAT by FUNCT_4:75
      .= ProgramPart p +* {} by Def29
      .= ProgramPart p by FUNCT_4:22;
 end;

Lm40:
  for N for S be non empty COM-Struct over N
  for p be program-free PartState of S
  holds dom p misses NAT
 proof
  let N; let S be non empty COM-Struct over N;
  let p be program-free PartState of S;
    p|NAT = {} by Def29;
  hence dom p misses NAT by RELAT_1:95;
 end;

theorem Th67:
 for p being PartState of S, d being program-free PartState of S
  holds NPP(p+*d) = NPP p +* d
 proof
  let p be PartState of S, d be program-free PartState of S;
  A1:  dom d misses NAT by Lm40;
A2:  dom d c= the carrier of S by RELAT_1:def 18;
    dom p c= the carrier of S by RELAT_1:def 18;
    then
A3: NPP p = p|((the carrier of S)\NAT) by RELAT_1:211;
    dom(p+*d) c= the carrier of S by RELAT_1:def 18;
    then
A4: NPP(p+*d) = (p+*d)|((the carrier of S)\NAT) by RELAT_1:211;
   d|((the carrier of S)\NAT) = d|(the carrier of S)\ d | NAT by RELAT_1:109
      .= d|(the carrier of S)\ {} by A1,RELAT_1:95
      .= d|(the carrier of S)
      .= d by A2,RELAT_1:97;
  hence NPP(p+*d)= NPP p +* d by A3,A4,FUNCT_4:75;
 end;

theorem Th68:
 for s being State of S
  holds s = NPP s \/ ProgramPart s by RELAT_1:88,XBOOLE_1:45;

theorem
 for s being State of S
  holds the carrier of S = dom NPP s \/ dom ProgramPart s
proof let s be State of S;
 thus the carrier of S = dom s by PARTFUN1:def 4
    .= dom(NPP s \/ ProgramPart s) by RELAT_1:88,XBOOLE_1:45
    .= dom NPP s \/ dom ProgramPart s by RELAT_1:13;
end;

theorem Th70:
 for S being IC-Ins-separated definite realistic (non empty
 stored-program COM-Struct over N)
 for p being PartState of S st IC S in dom p
  holds dom NPP p = {IC S} \/ dom DataPart p
proof
 let S be IC-Ins-separated definite realistic (non empty
 stored-program COM-Struct over N);
 let p be PartState of S;
A1: dom Start-At(IC p,S) = {IC S} by FUNCOP_1:19;
 assume IC S in dom p;
  then p = Start-At(IC p,S) +* ProgramPart p +* DataPart p by Th18;
  then
A2: dom p = dom(Start-At(IC p,S) +* ProgramPart p) \/ dom DataPart p
                      by FUNCT_4:def 1
     .= {IC S} \/ dom(ProgramPart p) \/ dom DataPart p by A1,FUNCT_4:def 1
     .= dom ProgramPart p \/ ({IC S} \/ dom DataPart p) by XBOOLE_1:4;
A3:  {IC S} misses dom ProgramPart p by Th12,ZFMISC_1:56;
   dom DataPart p misses dom ProgramPart p by Th15;
  then {IC S} \/ dom DataPart p misses dom ProgramPart p by A3,XBOOLE_1:70;
  then dom p \ dom ProgramPart p = {IC S} \/ dom DataPart p by A2,XBOOLE_1:88;
 hence thesis by RELAT_1:213;
end;

theorem Th71:
 for S being IC-Ins-separated definite realistic
  (stored-program non empty COM-Struct over N)
 for s being State of S
  holds dom NPP s = {IC S} \/ dom DataPart s
proof let S be IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N);
 let s be State of S;
  IC S in dom s by Lm6;
 hence thesis by Th70;
end;

theorem Th72:
 for S being IC-Ins-separated definite realistic (non empty
 stored-program COM-Struct over N)
 for p being PartState of S st IC S in dom p
  holds IC NPP p = IC p
 proof
 let S be IC-Ins-separated definite realistic (non empty
 stored-program COM-Struct over N);
  let p be PartState of S;
    dom p c= the carrier of S by RELAT_1:def 18;
   then
A1: NPP p = p|((the carrier of S) \ NAT) by RELAT_1:211;
  assume IC S in dom p;
   then
A2:  dom NPP p = {IC S} \/ dom DataPart p by Th70;
   IC S in {IC S} by TARSKI:def 1;
   then IC S in dom NPP p by A2,XBOOLE_0:def 3;
  hence IC NPP p = IC p by A1,FUNCT_1:70;
 end;

theorem Th73:
 for p being PartState of S
  holds DataPart p = DataPart NPP p
 proof let p be PartState of S;
A1:  Data-Locations S = (the carrier of S) \ {IC S} \ NAT by XBOOLE_1:41;
   ((the carrier of S)\NAT) /\ Data-Locations S
       = ((the carrier of S) /\ Data-Locations S)\NAT by XBOOLE_1:49
      .= (Data-Locations S)\NAT by XBOOLE_1:28
      .= ((the carrier of S) \ {IC S})\(NAT \/ NAT) by A1,XBOOLE_1:41
      .= Data-Locations S by XBOOLE_1:41;
  hence DataPart p = p|(((the carrier of S)\NAT) /\ Data-Locations S)
    .= p|((the carrier of S)\NAT)|Data-Locations S by RELAT_1:100
    .= (NPP p)|Data-Locations S by Th65
    .= DataPart NPP p;
 end;

registration
  let N,S;
  let p be program-free PartState of S, k be Element of NAT;
  cluster IncIC(p,k) -> program-free;
  coherence
   proof
A1:  p|NAT = {} by Def29;
    thus IncIC(p,k)|NAT = (p +* Start-At(IC p+k,S))|NAT
      .= p|NAT +* ProgramPart Start-At(IC p+k,S) by FUNCT_4:75
      .= {} +* {} by A1,Th27
      .= {};
   end;
end;

theorem Th74:
 for p being PartState of S st IC S in dom p
  holds NPP p = DataPart p +* Start-At (IC p,S)
proof
 let p be PartState of S;
A1: dom Start-At(IC p,S) = {IC S} by FUNCOP_1:19;
  then
A2: dom DataPart p misses dom Start-At (IC p,S) by Th11,ZFMISC_1:56;
A3: dom Start-At(IC p,S) misses dom ProgramPart p by A1,Th12,ZFMISC_1:56;
A4: dom DataPart p misses  dom ProgramPart p by Th15;
    dom((Start-At(IC p,S) +* ProgramPart p)) =
        dom Start-At(IC p,S) \/ dom ProgramPart p by FUNCT_4:def 1;
    then
A5: dom((Start-At(IC p,S) +* ProgramPart p)) misses dom DataPart p
                  by A2,A4,XBOOLE_1:70;
A6: DataPart p +* Start-At (IC p,S) = DataPart p \/ Start-At (IC p,S)
                     by A2,FUNCT_4:32;
 assume IC S in dom p;
  then p = Start-At(IC p,S) +* ProgramPart p +* DataPart p by Th18;
  then
A7:  p = (Start-At(IC p,S) +* ProgramPart p) \/  DataPart p by A5,FUNCT_4:32
     .= Start-At(IC p,S) \/ (ProgramPart p) \/  DataPart p by A3,FUNCT_4:32
     .=  ProgramPart p \/ (Start-At(IC p,S) \/  DataPart p) by XBOOLE_1:4;
A8:  Start-At(IC p,S) misses  ProgramPart p by A3,RELAT_1:214;
A9: dom DataPart p misses  dom ProgramPart p by Th15;
   DataPart p misses  ProgramPart p by A9,RELAT_1:214;
  then Start-At(IC p,S) \/  DataPart p misses  ProgramPart p by A8,XBOOLE_1:70;
 hence thesis by A6,A7,XBOOLE_1:88;
end;

theorem
 for p being PartState of S st IC S in dom p
  holds IncIC(NPP p,k) = DataPart p +* Start-At ((IC p) +k,S)
 proof let p be PartState of S;
A1: dom Start-At ((IC p) +k,S) = {IC S} by FUNCOP_1:19
     .= dom Start-At (IC p,S) by FUNCOP_1:19;
  assume
A2: IC S in dom p;
  hence IncIC(NPP p,k) = NPP p +* Start-At(IC p+k,S) by Th72
    .= DataPart p +* Start-At (IC p,S) +* Start-At ((IC p) +k,S) by A2,Th74
    .= DataPart p +* Start-At ((IC p) +k,S) by A1,FUNCT_4:78;
 end;

registration
  let N,S;
  let p be PartState of S;
  cluster NPP p -> program-free;
  coherence
   proof
     (p \ ProgramPart p)|NAT = (p \ p|NAT)|NAT
     .= {} by RELAT_1:216;
    hence (NPP p)|NAT = {};
   end;
end;

registration
  let N,S;
  let s be State of S, k be Nat;
  cluster IncIC(s,k) -> total;
  coherence;
end;

begin :: inicjalizacja licznika rozkazow, 2010.05.14, A.T.

definition let N;
  let S be IC-Ins-separated definite
  (non empty stored-program COM-Struct over N);
  let p be PartState of S;
  func Initialize p -> PartState of S equals
  p +* Start-At(0,S);
  coherence;
  projectivity by FUNCT_4:99;
end;

registration let N,S;
  let p be PartState of S;
 cluster Initialize p -> 0-started;
 coherence;
end;

registration let N,S;
  let p be FinPartState of S;
  cluster Initialize p -> finite;
  coherence;
end;

theorem Th76:
  for S being IC-Ins-separated definite
   (non empty stored-program COM-Struct over N),
      p being PartState of S
  holds dom Initialize p = dom p \/ {IC S}
proof let S be IC-Ins-separated definite
    (non empty  stored-program COM-Struct over N);
  let p being PartState of S;
  thus dom Initialize p
     = dom p \/ dom Start-At(0,S) by FUNCT_4:def 1
    .= dom p \/ {IC S} by FUNCOP_1:19;
end;

theorem
  for x being set st x in dom Initialize p holds x in dom p or x = IC S
proof
  let x be set;
  assume
A1: x in dom Initialize p;
  dom Initialize p = dom p \/ {IC S} by Th76;
  then x in dom p or x in {IC S} by A1,XBOOLE_0:def 3;
  hence thesis by TARSKI:def 1;
end;

theorem
 for p being 0-started PartState of S
  holds Initialize p = p
 proof let p be 0-started PartState of S;
   IC S in dom p & IC p = 0 by Def16;
   then Start-At(0,S) c= p by FUNCT_4:90;
  hence Initialize p = p by FUNCT_4:103,104;
 end;

registration let N,S,k;
 let p be k-started PartState of S,
     I be NAT-defined Function;
 cluster p +* I -> k-started PartState of S;
 coherence
  proof let q be PartState of S;
A1:  IC S in dom p by Def16;
   assume
A2:  q = p +* I;
    then dom q = dom p \/ dom I by FUNCT_4:def 1;
   hence IC S in dom q by A1,XBOOLE_0:def 3;
    dom I c= NAT by RELAT_1:def 18;
    then not IC S in dom I by Def12;
   hence IC q = IC p by A2,FUNCT_4:12
      .= k by Def16;
  end;
end;

definition let N,S;
 let p be PartState of S,
     f be NAT-defined (the Instructions of S)-valued Function;
 redefine func p +* f -> PartState of S;
 coherence;
end;

canceled;

theorem Th80:
 for p being PartState of S
  holds DataPart Initialize p = DataPart p
 proof let p be PartState of S;
  thus DataPart Initialize p
        = DataPart p +* DataPart Start-At(0,S) by FUNCT_4:75
       .= DataPart p +* {} by Th30
       .= DataPart p by FUNCT_4:22;
 end;

Lm221: for p,q being PartState of S
 holds NPP(p +* q) = NPP p +* NPP q
 proof let p,q be PartState of S;
  thus NPP(p +* q) = (p +* q)|((the carrier of S)\NAT) by Th65
     .= p|((the carrier of S)\NAT) +* q|((the carrier of S)\NAT) by FUNCT_4:75
     .= NPP p +* q|((the carrier of S)\NAT) by Th65
     .= NPP p +* NPP q by Th65;
 end;

theorem
 for s1,s2 being State of S st NPP s1  = NPP s2
  holds NPP Initialize s1 = NPP Initialize s2
proof let s1,s2 be State of S such that
Z: NPP s1  = NPP s2;
 thus NPP Initialize s1 = NPP s1 +* NPP Start-At(0,S) by Lm221
    .= NPP Initialize s2 by Z,Lm221;
end;

theorem
 for p being PartState of S,
    f being NAT-defined (the Instructions of S)-valued Function
  holds DataPart(p +* f) = DataPart p
 proof let p being PartState of S;
  let f being NAT-defined (the Instructions of S)-valued Function;
   dom f c= NAT by RELAT_1:def 18;
   then
A1: dom f misses Data-Locations S by Th51,XBOOLE_1:63;
  thus DataPart(p +* f)
         = DataPart p +* f|Data-Locations S by FUNCT_4:75
        .= DataPart p +* {} by A1,RELAT_1:95
        .= DataPart p by FUNCT_4:22;
 end;

registration let N be with_non-empty_elements set;
 let S be IC-Ins-separated definite
  (non empty stored-program COM-Struct over N);
 let p be PartState of S;
 cluster p|NAT -> (the Instructions of S)-valued;
 coherence
   proof let e be set;
    assume e in rng(p|NAT);
     then consider u being set such that
A1:   u in dom(p|NAT) and
A2:   e = (p|NAT).u by FUNCT_1:def 5;
A3:   dom(p|NAT) = NAT /\ dom p by RELAT_1:90;
     then
A4:    u in NAT by A1,XBOOLE_0:def 4;
     then
A5:    (the Object-Kind of S).u = the Instructions of S by Def8;
     reconsider u as Nat by A1;
A6:   u in dom p by A3,A1,XBOOLE_0:def 4;
   (p|NAT).u = p.u by A4,FUNCT_1:72;
    hence e in the Instructions of S by A2,A6,A5,FUNCT_1:def 20;
   end;
end;

theorem
 for p being PartState of S,
    f being NAT-defined (the Instructions of S)-valued Function
  holds Initialize (p +* f) = Initialize p +* f
proof
 set S0 = Start-At(0,S);
 let p be PartState of S,
     f be NAT-defined (the Instructions of S)-valued Function;
A1: NAT misses dom S0 by Th26;
A2: dom f c= NAT by RELAT_1:def 18;
 thus Initialize (p +* f) = p +* (f +* S0) by FUNCT_4:15
     .= p +* (S0 +* f) by A2,A1,FUNCT_4:36,XBOOLE_1:63
     .= Initialize p +* f by FUNCT_4:15;
end;

theorem
 for s being State of S st IC s =  0
  holds Initialize s = s
proof let s be State of S;
  assume
A1: IC s =  0;
A2: IC S in dom s by Lm6;
  thus Initialize s = s +* (IC S .-->  0)
    .= s by A1,A2,FUNCT_7:111;
end;

begin :: AMISTD_3, 2010.06.02, A.T

reserve k, m for natural number,
  x, x1, x2, x3, y, y1, y2, y3, X,Y,Z for set;

Lm8: -1 < k;

Lm9: for a, b, c being Element of NAT st 1 <= a & 2 <= b holds
k < a - 1 or a <= k & k <= a + b - 3 or k = a + b - 2 or
a + b - 2 < k or k = a - 1
proof
  let a, b, c be Element of NAT such that
A1: 1 <= a and
A2: 2 <= b and
A3: a - 1 <= k and
A4: a > k or k > a + b - 3 and
A5: k <> a + b - 2 and
A6: k <= a + b - 2;
A7: a - 1 is Element of NAT by A1,INT_1:18;
  now per cases by A4;
    case k < a;
      then k < a - 1 + 1;
      hence k <= a - 1 by A7,NAT_1:13;
    end;
    case
A8:   a + b - 3 < k;
      1 + 2 <= a + b by A1,A2,XREAL_1:9;
      then
A9:   a + b - 3 is Element of NAT by INT_1:18;
      k < a + b - 3 + 1 by A5,A6,XXREAL_0:1;
      hence k <= a - 1 by A8,A9,NAT_1:13;
    end;
  end;
  hence thesis by A3,XXREAL_0:1;
end;

begin  :: Properties of AMI-Struct

definition
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite
  (non empty stored-program COM-Struct over N),
  i1, i2 be Element of NAT,
  I1, I2 be Element of the Instructions of S;
  redefine func (i1,i2) --> (I1,I2) -> FinPartState of S;
  coherence;
end;

definition
  let N be set;
  let S be standard-ins COM-Struct over N;
  let T be InsType of S;
  func JumpParts T equals
  { JumpPart I where I is Instruction of S: InsCode I = T };
  coherence;
end;

registration
  let N be set;
  let S be standard-ins COM-Struct over N;
  let I be Element of the Instructions of S;
  cluster AddressPart I -> Function-like Relation-like;
  coherence
  proof
   consider X being non empty set such that
A1:  the Instructions of S c= [:NAT,NAT*,X*:] by Def17;
    I in the Instructions of S;
    then AddressPart I in X* by A1,RECDEF_2:2;
    hence thesis;
  end;
  cluster JumpPart I -> Function-like Relation-like;
  coherence
  proof
   consider X being non empty set such that
A2:  the Instructions of S c= [:NAT,NAT*,X*:] by Def17;
    I in the Instructions of S;
    then JumpPart I in NAT* by A2,RECDEF_2:2;
    hence thesis;
  end;
end;

registration
  let N be set;
  let S be standard-ins COM-Struct over N;
  let I be Element of the Instructions of S;
  cluster AddressPart I -> FinSequence-like;
  coherence
  proof
   consider X being non empty set such that
A1:  the Instructions of S c= [:NAT,NAT*,X*:] by Def17;
    I in the Instructions of S;
    then AddressPart I in X* by A1,RECDEF_2:2;
    hence thesis;
  end;
  cluster JumpPart I -> FinSequence-like;
  coherence
  proof
   consider X being non empty set such that
A2:  the Instructions of S c= [:NAT,NAT*,X*:] by Def17;
    I in the Instructions of S;
    then JumpPart I in NAT* by A2,RECDEF_2:2;
    hence thesis;
  end;
end;

definition
  let N be set;
  let S be standard-ins COM-Struct over N;
  attr S is homogeneous means
:Def33:
  for I, J being Instruction of S st InsCode I = InsCode J holds
  dom JumpPart I = dom JumpPart J;
end;

theorem Th85:
  for I being Instruction of Trivial-COM N holds JumpPart I = 0
proof
  let I be Instruction of Trivial-COM N;
  the Instructions of Trivial-COM N = {[0,0,0]} by Def1;
  then I = [0,0,0] by TARSKI:def 1;
  hence thesis by RECDEF_2:def 2;
end;

definition
  let N be set;
  let S be standard-ins COM-Struct over N;
  let T be InsType of S;
  func AddressParts T equals
  { AddressPart I where I is Instruction of S: InsCode I = T };
  coherence;
end;

registration
  let N be set;
  let S be standard-ins COM-Struct over N;
  let T be InsType of S;
  cluster AddressParts T -> functional;
  coherence
  proof
    let f be set;
    assume f in AddressParts T;
    then ex I being Instruction of S st f = AddressPart I & InsCode I = T;
    hence thesis;
  end;
  cluster JumpParts T -> non empty functional;
  coherence
  proof
    consider y being set such that
A1:  [T,y] in proj1 the Instructions of S by RELAT_1:def 4;
    consider x being set such that
A2:  [[T,y],x] in the Instructions of S by A1,RELAT_1:def 4;
    reconsider I = [T,y,x] as Instruction of S by A2;
    InsCode I = T by RECDEF_2:def 1;
    then JumpPart I in JumpParts T;
   hence JumpParts T is non empty;
    let f be set;
    assume f in JumpParts T;
    then ex I being Instruction of S st f = JumpPart I & InsCode I = T;
    hence thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster  -> (IC-Ins-separated definite
    (non empty stored-program COM-Struct over N));
  coherence;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster  standard-ins (IC-Ins-separated definite
    (non empty stored-program COM-Struct over N));
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

definition
  let N be set;
  let S be standard-ins COM-Struct over N;
  attr S is regular means
  :Def35:
  for I being Instruction of S, k being set st k in dom JumpPart I
   holds (product" JumpParts InsCode I).k = NAT;
  attr S is J/A-independent means
:Def36: for T being InsType of S, f1,f2 being Function,
     p being set
    st f1 in JumpParts T & f2 in product product" JumpParts T &
    [T,f1,p] in the Instructions of S
    holds [T,f2,p] in the Instructions of S;
end;

theorem Th86:
  for T being InsType of Trivial-COM N holds JumpParts T = {0}
proof
  let T be InsType of Trivial-COM N;
  set A = { JumpPart I where I is Instruction of Trivial-COM N:
   InsCode I = T };
  {0} = A
  proof
    hereby
      let a be set;
      assume a in {0};
      then
A1:   a = 0 by TARSKI:def 1;
   the Instructions of Trivial-COM N = {[0,0,0]} by Def1;
      then
A2:   InsCodes Trivial-COM N = {0} by MCART_1:97;
A3:     T = 0 by A2,TARSKI:def 1;
        reconsider I = [0,0,0] as Instruction of Trivial-COM N
        by Def1;
A4:     JumpPart I = 0 by Th85;
        InsCode I = 0 by RECDEF_2:def 1;
        hence a in A by A1,A3,A4;
    end;
    let a be set;
    assume a in A;
    then ex I being Instruction of Trivial-COM N st a = JumpPart I &
     InsCode I = T;
    then a = 0 by Th85;
    hence thesis by TARSKI:def 1;
  end;
  hence thesis;
end;

Lm10: for I being Instruction of Trivial-COM N holds JumpPart I = 0
proof
  let I be Instruction of Trivial-COM N;
  the Instructions of Trivial-COM N = {[0,0,{}]} by Def1;
  then I = [0,0,0] by TARSKI:def 1;
  hence thesis by RECDEF_2:def 2;
end;

Lm11: for T being InsType of Trivial-COM N holds JumpParts T = {0}
proof
  let T be InsType of Trivial-COM N;
  set A = { JumpPart I
   where I is Instruction of Trivial-COM N: InsCode I = T };
  {0} = A
  proof
    hereby
      let a be set;
      assume a in {0};
      then
A1:   a = 0 by TARSKI:def 1;
   the Instructions of Trivial-COM N = {[0,0,{}]} by Def1;
      then InsCodes Trivial-COM N = {0} by MCART_1:97;
      then
A2:   T = 0 by TARSKI:def 1;
      reconsider I = [0,0,0] as Instruction of Trivial-COM N
      by Def1;
A3:   JumpPart I = 0 by Lm10;
      InsCode I = 0 by RECDEF_2:def 1;
      hence a in A by A1,A2,A3;
    end;
    let a be set;
    assume a in A;
    then ex I being Instruction of Trivial-COM N
    st a = JumpPart I & InsCode I = T;
    then a = 0 by Lm10;
    hence thesis by TARSKI:def 1;
  end;
  hence thesis;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster Trivial-COM N -> homogeneous regular J/A-independent;
  coherence
  proof
    thus Trivial-COM N is homogeneous
     proof let I, J be Instruction of Trivial-COM N;
       JumpPart I = {} & JumpPart J = {} by Th85;
      hence thesis;
     end;
    thus Trivial-COM N is regular
     proof let I be Instruction of Trivial-COM N;
       JumpPart I = {} by Th85;
      hence thesis;
     end;
    let T be InsType of Trivial-COM N;
    let f1,f2 be Function, p be set;
    assume f1 in JumpParts T;
     then
A1:    f1 in {0} by Th86;
     assume
A2:    f2 in product product" JumpParts T;
     product" JumpParts T = {} by Th86,CARD_3:156;
     then f1 = 0 & f2 = 0 by A1,A2,CARD_3:19,TARSKI:def 1;
    hence thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster  regular J/A-independent homogeneous
    realistic
    (IC-Ins-separated definite standard-ins
    (non empty stored-program COM-Struct over N));
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

registration
 let N be with_non-empty_elements non empty set;
 let S be regular homogeneous (standard-ins COM-Struct over N);
 let T being InsType of S;
 cluster JumpParts T ->  with_common_domain;
 coherence
  proof let f,g be Function;
   assume f in JumpParts T;
    then
A1: ex I being Instruction of S st f = JumpPart I & InsCode I = T;
   assume g in JumpParts T;
    then ex J being Instruction of S st g = JumpPart J & InsCode J = T;
   hence dom f = dom g by Def33,A1;
  end;
end;

registration
 let N be with_non-empty_elements non empty set;
 let S be regular homogeneous (standard-ins COM-Struct over N);
 let I be Instruction of S;
 cluster JumpPart I -> NAT-valued Function;
 coherence
proof
 JumpPart I is NAT-valued
 proof let x;
 assume x in rng JumpPart I;
  then consider k being set such that
A1: k in dom JumpPart I and
A2: (JumpPart I).k = x by FUNCT_1:def 5;
  set X = JumpParts InsCode I;
A3:  JumpPart I in X;
  then k in dom product" X by A1,CARD_3:150;
  then (JumpPart I).k in (product" X).k by A3,CARD_3:151;
 hence x in NAT by A1,A2,Def35;
 end;
 hence thesis;
end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be regular J/A-independent homogeneous
   (standard-ins COM-Struct over N);
  let T be InsType of S;
  cluster JumpParts T -> product-like;
  coherence
proof
  consider y being set such that
A1: [T,y] in proj1 the Instructions of S by RELAT_1:def 4;
  consider z being set such that
A2: [[T,y],z] in the Instructions of S by A1,RELAT_1:def 4;
  reconsider I = [T,y,z] as Instruction of S by A2;
A3: InsCode I = T by RECDEF_2:def 1;
A4: JumpPart I = y by RECDEF_2:def 2;
  set f = (dom JumpPart I) --> NAT;
A5:   dom f = dom JumpPart I by FUNCOP_1:19;
  for x being set holds x in JumpParts T iff
   ex g being Function st x = g & dom g = dom f &
     for y st y in dom f holds g.y in f.y
   proof let x be set;
    thus x in JumpParts T implies
      ex g being Function st x = g & dom g = dom f &
     for y st y in dom f holds g.y in f.y
    proof assume x in JumpParts T;
      then consider K being Instruction of S such that
A6:    x = JumpPart K and
A7:    InsCode K = T;
     take g = JumpPart K;
     thus x = g by A6;
     thus
A8:    dom g = dom f by A7,A3,Def33,A5;
     let y;
     assume
A9:    y in dom f;
      then f.y = NAT by A5,FUNCOP_1:13;
     hence g.y in f.y by A8,A9,FUNCT_1:172;
    end;
     given g being Function such that
A10:   x = g and
A11:   dom g = dom f and
A12:   for y st y in dom f holds g.y in f.y;
A13:   dom g = dom JumpPart I by A11,FUNCOP_1:19;
   set J = [T,g,z];
A14: y in JumpParts T by A4,A3;
   then
A15: dom g = dom product" JumpParts T by A13,A4,CARD_3:150;
    for x st x in dom(product" JumpParts T)
     holds g.x in (product" JumpParts T).x
    proof let x;
     assume
A16:    x in dom(product" JumpParts T);
      f.x = NAT by A15,A13,A16,FUNCOP_1:13;
      then g.x in NAT by A12,A15,A16,A11;
     hence g.x in (product" JumpParts T).x by A16,A15,A3,A13,Def35;
    end;
   then
A17: g in product product" JumpParts T by A15,CARD_3:18;
    reconsider J as Instruction of S by A14,Def36,A4,A17;
A18: InsCode J = T by RECDEF_2:def 1;
     g = JumpPart J by RECDEF_2:def 2;
    hence x in JumpParts T by A18,A10;
   end;
  then JumpParts T = product f by CARD_3:def 5;
 hence JumpParts T is product-like;
end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster Trivial-COM N -> regular J/A-independent;
  coherence;
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster regular J/A-independent (standard-ins COM-Struct over N);
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

registration

  let N be with_non-empty_elements non empty set;
  let S be homogeneous (standard-ins COM-Struct over N);
  let T be InsType of S;
  cluster JumpParts T -> with_common_domain;
  coherence
  proof
    let f, g be Function;
    assume that
A1: f in JumpParts T and
A2: g in JumpParts T;
A3: ex I being Instruction of S st f = JumpPart I & InsCode I = T by A1;
    ex J being Instruction of S st g = JumpPart J & InsCode J = T by A2;
    hence thesis by A3,Def33;
  end;
end;

registration
  let N;
  cluster regular J/A-independent
    (non empty stored-program standard-ins COM-Struct over N);
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

theorem
  for S being homogeneous regular
  (non empty stored-program standard-ins COM-Struct over N),
  I being Instruction of S, x being set st x in dom JumpPart I holds
  (JumpPart I).x is Element of NAT
proof
  let S be homogeneous regular
  (non empty stored-program standard-ins COM-Struct over N),
  I be Instruction of S, x be set such that
A1: x in dom JumpPart I;
A2: JumpPart I in JumpParts InsCode I;
A3: (product" JumpParts InsCode I).x = NAT by A1,Def35;
  for f being Function st f in JumpParts InsCode I holds x in dom f
  proof
    let f be Function;
    assume f in JumpParts InsCode I;
    then ex J being Instruction of S st f = JumpPart J & InsCode I =
    InsCode J;
    hence thesis by A1,Def33;
  end;
  then x in dom product" JumpParts InsCode I by CARD_3:def 13;
  then (product" JumpParts InsCode I).x = pi(JumpParts InsCode I,x)
  by CARD_3:def 13;
  hence thesis by A2,A3,CARD_3:def 6;
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster
  realistic
    (standard-ins IC-Ins-separated definite
    (non empty stored-program COM-Struct over N));
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

registration

  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite
  (non empty stored-program COM-Struct over N);
  cluster non trivial NAT-defined FinPartState of S;
  existence
  proof
    consider l1, l2 being Element of NAT such that
A1: l1 <> l2 by YELLOW_8:def 1;
    reconsider l1,l2 as Element of NAT;
    set I =the  Instruction of S;
    take f = (l1,l2) --> (I,I);
    thus f is non trivial
    proof
      f = { [l1,I], [l2,I] } by A1,FUNCT_4:71;
      then reconsider x = [l1,I], y = [l2,I] as Element of f by TARSKI:def 2;
      take x, y;
      thus thesis by A1,ZFMISC_1:33;
    end;
    let a be set;
    assume a in dom f;
    then a in {l1,l2} by FUNCT_4:65;
    hence thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be   (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  cluster trivial -> unique-halt (non empty NAT-defined FinPartState of S);
  coherence
  proof
    let F be non empty NAT-defined FinPartState of S;
    assume
A1: F is trivial;
    let f be Element of NAT such that F.f = halt S and
A2: f in dom F;
    consider x being set such that
A3: F = {x} by A1,REALSET1:def 4;
    x in F by A3,TARSKI:def 1;
    then consider a, b being set such that
A4: [a,b] = x by RELAT_1:def 1;
A5: LastLoc F in dom F by VALUED_1:31;
A6: dom F = {a} by A3,A4,RELAT_1:23;
    hence f = a by A2,TARSKI:def 1
      .= LastLoc F by A5,A6,TARSKI:def 1;
  end;
end;

definition
  let N be set;
  let S be standard-ins COM-Struct over N;
  let I be Instruction of S;
  attr I is ins-loc-free means
:Def37: JumpPart I is empty;
end;

Lm12: now
  let N be with_non-empty_elements non empty set,
  S be   (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  thus dom Stop S = {0} by FUNCOP_1:19;
  hence 0 in dom Stop S by TARSKI:def 1;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be
  (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  cluster Stop S ->
   initial non empty NAT-defined (the Instructions of S)-valued trivial;
  coherence;
end;

theorem Th88:
  for S being   (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)) holds card Stop S = 1
proof
  let S be   (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  thus card Stop S = card {[0,halt S]} by FUNCT_4:87
    .= 1 by CARD_1:50;
end;

theorem Th89:
  for F being pre-Macro of S st card F = 1 holds F = Stop S
proof let F be pre-Macro of S;
  assume
A1: card F = 1;
  then consider x being set such that
A2: F = {x} by CARD_2:60;
  x in F by A2,TARSKI:def 1;
  then consider a, b being set such that
A3: [a,b] = x by RELAT_1:def 1;
A4: dom F = {a} by A2,A3,RELAT_1:23;
A5: 0 in dom F by AFINSQ_1:69;
  then
A6: a = 0 by A4;
  card F -' 1 = card F - 1 by PRE_CIRC:25
    .= 0 by A1;
  then LastLoc F = 0 by AFINSQ_1:74;
  then F.0 = halt S by Def25;
  then halt S in rng F by A5,FUNCT_1:def 5;
  then halt S in {b} by A2,A3,RELAT_1:23;
  then F = {[0,halt S]} by A2,A3,A6,TARSKI:def 1
    .= 0 .--> halt S by FUNCT_4:87;
  hence thesis;
end;

Lm13: for S being   (IC-Ins-separated definite
(non empty stored-program COM-Struct over N)) holds card Stop S -' 1 = 0
proof
  let S be   (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  thus card Stop S -' 1 = card Stop S - 1 by PRE_CIRC:25
    .= 1 - 1 by Th88
    .= 0;
end;

theorem Th90:
  for S being   (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  holds LastLoc Stop S = 0
proof
  let S be   (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  card Stop S -' 1 = 0 by Lm13;
  hence thesis by AFINSQ_1:74;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  cluster Stop S -> halt-ending unique-halt;
  coherence
  proof
    thus (Stop S).(LastLoc Stop S) = (0 .--> halt S).0 by Th90
      .= halt S by FUNCOP_1:87;
    let l be Element of NAT such that (Stop S).l = halt S;
    assume l in dom Stop S;
    then l in {0} by Lm12;
    then l = 0 by TARSKI:def 1;
    hence thesis by Th90;
  end;
end;

begin  :: On the composition of macro instructions

registration
  let N be with_non-empty_elements non empty set;
  let S be regular J/A-independent homogeneous
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let I be Element of the Instructions of S;
 cluster JumpPart I -> natural-valued Function;
 coherence;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be regular J/A-independent homogeneous
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let I be Element of the Instructions of S;
  let k be natural number;
  func IncAddr(I,k) -> Instruction of S means
:Def38:
  InsCode it = InsCode I &
  AddressPart it = AddressPart I &
  JumpPart it = k + JumpPart I;
  existence
  proof
    consider D0 being non empty set such that
A1:   the Instructions of S c= [:NAT,NAT*,D0*:] by Def17;
    set p = k + JumpPart I;
    set f = product" JumpParts InsCode I;
A2: JumpPart I in JumpParts InsCode I;
A3: JumpParts InsCode I = product f by CARD_3:95;
A4: dom p = dom JumpPart I by VALUED_1:def 2;
     then
A5: dom p  = DOM JumpParts InsCode I by A2,CARD_3:def 12
      .= dom f by CARD_3:92;
    for z being set st z in dom p holds p.z in f.z
    proof
      let z be set;
      assume
A6:  z in dom p;
      reconsider z as Element of NAT by A6;
A7:    f.z = NAT by A6,A4,Def35;
        reconsider il = (JumpPart I).z as Element of NAT by ORDINAL1:def 13;
        p.z = k + il by A6,VALUED_1:def 2;
        hence thesis by A7;
    end;
    then p in JumpParts InsCode I by A3,A5,CARD_3:18;
    then consider II being Instruction of S such that
A8: p = JumpPart II and
A9: InsCode I = InsCode II;
A10:  JumpPart I in JumpParts InsCode I;
     product product" JumpParts InsCode I = JumpParts InsCode I by CARD_3:95;
     then
A11:  JumpPart II in product product" JumpParts InsCode I by A9;
     I in the Instructions of S;
     then [InsCode I, JumpPart I, AddressPart I] = I by A1,RECDEF_2:3;
     then reconsider IT = [InsCode I, JumpPart II, AddressPart I]
                       as Instruction of S by A10,A11,Def36;
    take IT;
    thus InsCode IT = InsCode I by RECDEF_2:def 1;
    thus AddressPart IT = AddressPart I by RECDEF_2:def 3;
    thus JumpPart IT = k + JumpPart I by A8,RECDEF_2:def 2;
  end;
  uniqueness by Th7;
end;

theorem Th91:
  for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  I being Element of the Instructions of S holds IncAddr(I, 0) = I
proof
  let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  I be Element of the Instructions of S;
A1: InsCode IncAddr(I, 0) = InsCode I by Def38;
A2: AddressPart IncAddr(I, 0) = AddressPart I by Def38;
A3:  JumpPart IncAddr(I, 0) = (0 qua Nat) + JumpPart I by Def38;
   then
A4: dom JumpPart I = dom JumpPart IncAddr(I, 0) by VALUED_1:def 2;
  for k being Nat st k in dom JumpPart I holds
  (JumpPart IncAddr(I, 0)).k = (JumpPart I).k
  proof
    let k be Nat;
    assume k in dom JumpPart I;
    hence (JumpPart IncAddr(I, 0)).k
        = (0 qua Nat) + (JumpPart I).k by A4,A3,VALUED_1:def 2
       .= (JumpPart I).k;
  end;
   then JumpPart IncAddr(I, 0) = JumpPart I by A4,FINSEQ_1:17;
  hence thesis by A1,A2,Th7;
end;

theorem Th92:
  for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  I being Instruction of S st I is ins-loc-free holds IncAddr(I, k) = I
proof
  let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  I be Instruction of S such that
A1: JumpPart I is empty;
  set f = IncAddr(I, k);
A2: InsCode f = InsCode I by Def38;
A3: AddressPart f = AddressPart I by Def38;
    JumpPart f = k + JumpPart I by Def38;
    then
A4: dom JumpPart f = dom JumpPart I by VALUED_1:def 2;
   JumpPart f = JumpPart I by A1,A4;
  hence thesis by A2,A3,Th7;
end;

definition let N be set;
  let S be standard-ins COM-Struct over N;
  attr S is proper-halt means
:Def39:  halt S is ins-loc-free;
end;

registration
  let N be set;
  cluster Trivial-COM N -> proper-halt;
  coherence
  proof set S = Trivial-COM N;
    halt S = [0,{},{}] by Def1;
   hence JumpPart halt S is empty by RECDEF_2:def 2;
  end;
end;

registration let N;
 cluster proper-halt regular homogeneous J/A-independent realistic
  IC-Ins-separated definite
  (standard-ins non empty stored-program COM-Struct over N);
 existence
  proof
   take Trivial-COM N;
   thus thesis;
  end;
end;

registration let N;
  let S be proper-halt (standard-ins COM-Struct over N);
 cluster halt S -> ins-loc-free;
 coherence by Def39;
end;

registration let N;
  let S be proper-halt (standard-ins COM-Struct over N);
 cluster ins-loc-free Instruction of S;
 existence
  proof
   take halt S;
   thus thesis;
  end;
end;

registration
  let N;
  let S be proper-halt (standard-ins COM-Struct over N);
  let I be ins-loc-free Instruction of S;
  cluster JumpPart I -> empty;
  coherence by Def37;
end;

theorem
  for S being
  regular homogeneous J/A-independent proper-halt
  (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  holds IncAddr(halt S, k) = halt S by Th92;

theorem
  for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), I being Instruction of S
  holds JumpParts InsCode I = JumpParts InsCode IncAddr(I,k)
proof
  let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), I be Instruction of S;
  set A = { JumpPart J where J is Instruction of S:
  InsCode I = InsCode J }, B = { JumpPart J where J is Instruction of S:
  InsCode IncAddr(I,k) = InsCode J };
  A = B
  proof
    hereby
      let a be set;
      assume a in A;
      then consider J being Instruction of S such that
A1:   a = JumpPart J and
A2:   InsCode J = InsCode I;
      InsCode J = InsCode IncAddr(I,k) by A2,Def38;
      hence a in B by A1;
    end;
    let a be set;
    assume a in B;
    then consider J being Instruction of S such that
A3: a = JumpPart J and
A4: InsCode J = InsCode IncAddr(I,k);
    InsCode J = InsCode I by A4,Def38;
    hence thesis by A3;
  end;
  hence thesis;
end;

theorem Th95:
  for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  I, J being Instruction of S st
  ex k being natural number st IncAddr(I,k) = IncAddr(J,k) holds I = J
proof
  let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), I, J be Instruction of S;
  given k being natural number such that
A1: IncAddr(I,k) = IncAddr(J,k);
A2: InsCode I = InsCode IncAddr(I,k) by Def38
    .= InsCode J by A1,Def38;
A3: AddressPart I = AddressPart IncAddr(I,k) by Def38
       .= AddressPart J by A1,Def38;
A4: JumpPart IncAddr(I,k) = k + JumpPart I by Def38;
    then
A5: dom JumpPart I = dom  JumpPart IncAddr(I,k) by VALUED_1:def 2;
A6: JumpPart IncAddr(J,k) = k + JumpPart J by Def38;
    then
A7: dom JumpPart J = dom  JumpPart IncAddr(J,k) by VALUED_1:def 2;
A8: dom JumpPart I = dom JumpPart J by A2,Def33;
  for x being set st x in dom JumpPart I holds
  (JumpPart I).x = (JumpPart J).x
  proof
    let x be set;
    assume
A9: x in dom JumpPart I;
A10:   (JumpPart IncAddr(I,k)).x = k + (JumpPart I).x
             by A4,A5,A9,VALUED_1:def 2;
A11:   (JumpPart IncAddr(J,k)).x = k + (JumpPart J).x
             by A6,A8,A9,A7,VALUED_1:def 2;
      thus thesis by A1,A10,A11;
  end;
   then JumpPart I = JumpPart J by A8,FUNCT_1:9;
  hence thesis by A2,A3,Th7;
end;

theorem Th96:
  for S being regular homogeneous J/A-independent proper-halt
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  I being Instruction of S st IncAddr(I,k) = halt S holds I = halt S
proof
  let S be regular homogeneous J/A-independent proper-halt
  (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), I be Instruction of S;
  assume IncAddr(I,k) = halt S;
  then IncAddr(I,k) = IncAddr(halt S,k) by Th92;
  hence thesis by Th95;
end;

theorem Th97:
  for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), I being Instruction of S
  holds IncAddr(IncAddr(I,k),m) = IncAddr(I,k+m)
proof
  let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), I be Instruction of S;
A1: InsCode IncAddr(IncAddr(I,k),m) = InsCode IncAddr(I,k) by Def38
    .= InsCode I by Def38
    .= InsCode IncAddr(I,k+m) by Def38;
A2: AddressPart IncAddr(IncAddr(I,k),m) = AddressPart IncAddr(I,k) by Def38
    .= AddressPart I by Def38
    .= AddressPart IncAddr(I,k+m) by Def38;
A3: JumpPart IncAddr(IncAddr(I,k),m) = m + JumpPart IncAddr(I,k) by Def38;
A4: JumpPart IncAddr(I,k) = k + JumpPart I by Def38;
A5: JumpPart IncAddr(I,k+m) = k+m + JumpPart I by Def38;
    then
A6: dom JumpPart IncAddr(I,k+m) = dom JumpPart I by VALUED_1:def 2
    .= dom JumpPart IncAddr(I,k) by A4,VALUED_1:def 2
    .= dom JumpPart IncAddr(IncAddr(I,k),m) by A3,VALUED_1:def 2;
  for n being set st n in dom JumpPart IncAddr(IncAddr(I,k),m) holds
  (JumpPart IncAddr(IncAddr(I,k),m)).n = (JumpPart IncAddr(I,k+m)).n
  proof
    let n be set;
    assume
A7:   n in dom JumpPart IncAddr(IncAddr(I,k),m);
    then
A8: n in dom JumpPart IncAddr(I,k) by A3,VALUED_1:def 2;
    then
A9: n in dom JumpPart I by A4,VALUED_1:def 2;
A10:   (JumpPart IncAddr(I,k)).n = k + (JumpPart I).n
            by A4,A8,VALUED_1:def 2;
A11:   (JumpPart IncAddr(IncAddr(I,k),m)).n = m + (JumpPart IncAddr(I,k)).n
      by A7,A3,VALUED_1:def 2;
      n in dom JumpPart IncAddr(I,k+m) by A5,A9,VALUED_1:def 2;
      then (JumpPart IncAddr(I,k+m)).n = k + m + (JumpPart I).n
       by A5,VALUED_1:def 2;
      hence thesis by A11,A10;
  end;
   then JumpPart IncAddr(IncAddr(I,k),m) = JumpPart IncAddr(I,k+m)
                   by A6,FUNCT_1:9;
  hence thesis by A1,A2,Th7;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  p be NAT-defined (the Instructions of S)-valued finite Function,
  k be natural number;
A1: dom p c= NAT by RELAT_1:def 18;
  func IncAddr(p,k) -> FinPartState of S means
:Def40:
  dom it = dom p &
  for m being natural number st m in dom p holds it.m = IncAddr(p/.m,k);
  existence
  proof
    defpred P[set,set] means ex m being Element of NAT st $1 = m &
    $2 = IncAddr(p/.m,k);
A2: for e being set st e in dom p ex u being set st P[e,u]
    proof
      let e be set;
      assume e in dom p;
      then reconsider l=e as Element of NAT by A1;
      consider m being natural number such that
A3:   l = m;
      take IncAddr(p/.m,k);
      thus thesis by A3;
    end;
    consider f being Function such that
A4: dom f = dom p and
A5: for e being set st e in dom p holds P[e,f.e] from CLASSES1:sch 1(A2);
     for x being set st x in dom f holds f.x in (the Object-Kind of S).x
    proof
      let x be set;
      assume
A6:   x in dom f;
      then
A7:   ex m being Element of NAT st x = m & f.x =
       IncAddr(p/.m,k) by A4,A5;
      reconsider y = x as Element of NAT by A1,A4,A6;
      (the Object-Kind of S).y = the Instructions of S by Def8;
      hence thesis by A7;
    end;
    then
A8:  f is (the Object-Kind of S)-compatible by FUNCT_1:def 20;
    reconsider f as finite Element of sproduct the Object-Kind of S
    by A4,A8,CARD_3:153,FINSET_1:29;
    reconsider f as FinPartState of S;
    take f;
    thus dom f = dom p by A4;
    let m be natural number;
    assume m in dom p;
    then ex j being Element of NAT st m = j &
    f.m = IncAddr(p/.j,k) by A5;
    hence thesis;
  end;
  uniqueness
  proof
    let IT1,IT2 be FinPartState of S such that
A9: dom IT1 = dom p and
A10: for m being natural number st m in dom p holds
    IT1.m = IncAddr(p/.m,k) and
A11: dom IT2 = dom p and
A12: for m being natural number st m in dom p holds
    IT2.m = IncAddr(p/.m,k);
    for x being set st x in dom p holds IT1.x = IT2.x
    proof
      let x be set;
      assume
A13:  x in dom p;
      then reconsider l=x as Element of NAT by A1;
      consider m being natural number such that
A14:  l = m;
      reconsider m as Element of NAT by ORDINAL1:def 13;
      thus IT1.x = IncAddr(p/.m,k) by A10,A13,A14
        .= IT2.x by A12,A13,A14;
    end;
    hence thesis by A9,A11,FUNCT_1:9;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be NAT-defined (the Instructions of S)-valued finite Function,
  k be natural number;
  cluster IncAddr(F,k) -> NAT-defined (the Instructions of S)-valued;
  coherence
  proof
A1:   dom IncAddr(F,k) = dom F by Def40;
    hence dom IncAddr(F,k) c= NAT by RELAT_1:def 18;
   let x be set;
   assume x in rng IncAddr(F,k);
    then consider y being set such that
A2:  y in dom F and
A3:  x = IncAddr(F,k).y by A1,FUNCT_1:def 5;
    x = IncAddr(F/.y,k) by A2,A3,Def40;
   hence x in the Instructions of S;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  cluster empty NAT-defined FinPartState of S;
  existence
  proof
   take the empty FinPartState of S;
   thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be empty (the Instructions of S)-valued NAT-defined FinPartState of S,
  k be natural number;
  cluster IncAddr(F,k) -> empty;
  coherence
  proof
    assume not thesis;
    then reconsider f = IncAddr(F,k) as non empty Function;
A1: dom f <> {};
    dom IncAddr(F,k) = dom F by Def40;
    hence thesis by A1;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be non empty (the Instructions of S)-valued NAT-defined FinPartState of S,
  k be natural number;
  cluster IncAddr(F,k) -> non empty;
  coherence
  proof
    dom IncAddr(F,k) = dom F by Def40;
    hence thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be initial NAT-defined (the Instructions of S)-valued FinPartState of S,
  k be natural number;
  cluster IncAddr(F,k) -> initial;
  coherence
  proof
    dom IncAddr(F,k) = dom F by Def40;
    hence thesis by AFINSQ_1:71;
  end;
end;

theorem Th98:
  for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F being NAT-defined (the Instructions of S)-valued FinPartState of S
   holds IncAddr(F,0) = F
proof
  let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be NAT-defined (the Instructions of S)-valued FinPartState of S;
  for m being natural number st m in dom F holds
  F.m = IncAddr(F/.m,0)
  proof
    let m be natural number;
    assume m in dom F;
    then F/.m = F.m by PARTFUN1:def 8;
    hence thesis by Th91;
  end;
  hence thesis by Def40;
end;

theorem Th99:
  for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F being NAT-defined (the Instructions of S)-valued finite Function
  holds IncAddr(IncAddr(F,k),m) = IncAddr(F,k+m)
proof
  let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be NAT-defined (the Instructions of S)-valued finite Function;
A1: dom IncAddr(IncAddr(F,k),m) = dom IncAddr(F,k) by Def40
    .= dom F by Def40;
A2: dom IncAddr(F,k+m) = dom F by Def40;
  for x being set st x in dom F holds
  IncAddr(IncAddr(F,k),m).x = IncAddr(F,k+m).x
  proof
    let x be set such that
A3: x in dom F;
    reconsider x as Element of NAT by A3,ORDINAL1:def 13;
A4: x in dom IncAddr(F,k) by A3,Def40;
A5: IncAddr(F/.x,k) = IncAddr(F,k).x
    by A3,Def40
      .= IncAddr(F,k)/.x by A4,PARTFUN1:def 8;
    IncAddr(IncAddr(F,k),m).x
    = IncAddr(IncAddr(F,k)/.x,m) by A4,Def40
      .= IncAddr(F/.x,k+m) by A5,Th97
      .= IncAddr(F,k+m).x by A3,Def40;
    hence thesis;
  end;
  hence thesis by A1,A2,FUNCT_1:9;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
 let p be finite NAT-defined (the Instructions of S)-valued Function,
     k be Element of NAT;
 func Reloc(p,k) ->
   finite NAT-defined (the Instructions of S)-valued Function
   equals IncAddr(Shift(p,k),k);
 coherence;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster homogeneous realistic
    (regular J/A-independent  (standard-ins IC-Ins-separated definite
    (non empty stored-program COM-Struct over N)));
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

theorem Th100:
  for S being regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F being initial non empty NAT-defined FinPartState of S,
  G being non empty
   NAT-defined (the Instructions of S)-valued FinPartState of S
  holds dom CutLastLoc F misses dom Shift(IncAddr(G,card F -' 1),card F -' 1)
proof
  let S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be initial non empty NAT-defined FinPartState of S,
  G be non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S;
  set k = card F -' 1;
  assume not thesis;
  then consider il being set such that
A1: il in dom CutLastLoc F /\ dom Shift(IncAddr(G,k),k) by XBOOLE_0:4;
A2: il in dom CutLastLoc F by A1,XBOOLE_0:def 4;
A3: il in dom Shift(IncAddr(G,k),k) by A1,XBOOLE_0:def 4;
  dom Shift(IncAddr(G,k),k) = { (m+k) where m is Element of NAT:
  m in dom IncAddr(G,k) } by VALUED_1:def 12;
  then consider m being Element of NAT such that
A4: il = (m+k) and m in dom IncAddr(G,k) by A3;
  reconsider f = CutLastLoc F as non empty NAT-defined FinPartState of S
  by A1,RELAT_1:60;
  m+k <= LastLoc f by A2,A4,VALUED_1:33;
  then
A5: m+k <= card f -' 1 by AFINSQ_1:74;
A6: card f = card F - 1 by VALUED_1:39
    .= card F -' 1 by PRE_CIRC:25;
  per cases;
  suppose k - 1 >= 0;
    then m + k <= k - 1 by A5,A6,XREAL_0:def 2;
    then m + k - k <= k - 1 - k by XREAL_1:11;
    hence thesis by Lm8;
  end;
  suppose k - 1 < 0;
    then m + k = 0 or m + k < 0 by A5,A6,XREAL_0:def 2;
    hence thesis by A6;
  end;
end;

theorem Th101:
  for F being unique-halt (initial non empty NAT-defined FinPartState of S),
  I being Element of NAT st I in dom CutLastLoc F
  holds (CutLastLoc F).I <> halt S
proof
  let F be unique-halt (initial non empty NAT-defined FinPartState of S),
  I be Element of NAT such that
A1: I in dom CutLastLoc F and
A2: (CutLastLoc F).I = halt S;
A3: dom CutLastLoc F c= dom F by GRFUNC_1:8;
  F.I = halt S by A1,A2,GRFUNC_1:8;
  then
A4: I = LastLoc F by A1,A3,Def26;
  dom CutLastLoc F = (dom F) \ {LastLoc F} by VALUED_1:37;
  then not I in {LastLoc F} by A1,XBOOLE_0:def 5;
  hence thesis by A4,TARSKI:def 1;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let F, G be non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S;
  func F ';' G -> (the Instructions of S)-valued NAT-defined FinPartState of S
   equals
  CutLastLoc F +* Shift(IncAddr(G,card F -' 1),card F -' 1);
  coherence;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G be non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S;
  cluster F ';' G -> non empty
  (the Instructions of S)-valued NAT-defined;
  coherence;
end;

theorem Th102:
  for S being regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S,
  G being non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S
  holds card (F ';' G) = card F + card G - 1 &
  card (F ';' G) = card F + card G -' 1
proof
  let S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S,
  G be non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S;
  set k = card F -' 1;
  dom IncAddr(G,k),dom Shift(IncAddr(G,k),k) are_equipotent by VALUED_1:28;
  then
A1: IncAddr(G,k),Shift(IncAddr(G,k),k) are_equipotent by PRE_CIRC:26;
  dom CutLastLoc F misses dom Shift(IncAddr(G,k),k) by Th100;
  hence card (F ';' G)
  = card CutLastLoc F + card Shift(IncAddr(G,k),k) by PRE_CIRC:27
    .= card CutLastLoc F + card IncAddr(G,k) by A1,CARD_1:21
    .= card CutLastLoc F + card dom IncAddr(G,k) by CARD_1:104
    .= card CutLastLoc F + card dom G by Def40
    .= card CutLastLoc F + card G by CARD_1:104
    .= card F - 1 + card G by VALUED_1:39
    .= card F + card G - 1;
  hence thesis by XREAL_0:def 2;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let F, G be initial non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S;
  cluster F ';' G -> initial;
  coherence
  proof
    set P = F ';' G;
    let f,n be Nat such that
A1: n in dom P and
A2: f < n;
    set k = card F -' 1;
A3: dom P = dom CutLastLoc F \/ dom Shift(IncAddr(G,k),k) by FUNCT_4:def 1;
    per cases by A1,A3,XBOOLE_0:def 3;
    suppose n in dom CutLastLoc F;
      then f in dom CutLastLoc F by A2,AFINSQ_1:def 13;
      hence thesis by A3,XBOOLE_0:def 3;
    end;
    suppose n in dom Shift(IncAddr(G,k),k);
      then n in { w+k where w is Element of NAT:
      w in dom IncAddr(G,k) } by VALUED_1:def 12;
      then consider m being Element of NAT such that
A4:   n = (m+k) and
A5:   m in dom IncAddr(G,k);
A6:   m in dom G by A5,Def40;
      now per cases;
        case
A7:       f < k;
          then f < card F - 1 by PRE_CIRC:25;
          then 1+f < 1 + (card F - 1) by XREAL_1:8;
          then
A8:       1+f in dom F by AFINSQ_1:70;
          f < 1+f by NAT_1:19;
          then
A9:      f in dom F by A8,AFINSQ_1:def 13;
          f <> LastLoc F by A7,AFINSQ_1:74;
          then not f in {LastLoc F} by TARSKI:def 1;
          then f in (dom F) \ {LastLoc F} by A9,XBOOLE_0:def 5;
          hence f in dom CutLastLoc F by VALUED_1:37;
        end;
        case f >= k;
          then consider l1 being Nat such that
A10:      f = k + l1 by NAT_1:10;
          reconsider l1 as Element of NAT by ORDINAL1:def 13;
A11:      dom Shift(IncAddr(G,k),k) =
{ w+k where w is Element of NAT: w in dom IncAddr(G,k) }
          by VALUED_1:def 12;
          l1 < m or l1 = m by A10,A4,A2,XREAL_1:8;
          then l1 in dom G by A6,AFINSQ_1:def 13;
          then l1 in dom IncAddr(G,k) by Def40;
          hence f in dom Shift(IncAddr(G,k),k) by A11,A10;
        end;
      end;
      hence thesis by A3,XBOOLE_0:def 3;
    end;
  end;
end;

theorem
  for S being regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S
  holds dom F c= dom (F ';' G)
proof
  let S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S;
  set P = F ';' G;
A1: dom P = dom CutLastLoc F \/ dom Shift(IncAddr(G,card F -' 1),card F -' 1)
  by FUNCT_4:def 1;
A2: dom F = dom CutLastLoc F \/ {LastLoc F} by VALUED_1:38;
  let x be set;
  assume
A3: x in dom F;
  per cases by A2,A3,XBOOLE_0:def 3;
  suppose x in dom CutLastLoc F;
    hence thesis by A1,XBOOLE_0:def 3;
  end;
  suppose
A4: x in {LastLoc F};
    then
A5: x = LastLoc F by TARSKI:def 1;
    reconsider f = x as Element of NAT by A4;
A6: f = card F -' 1 by A5,AFINSQ_1:74
      .= card F - 1 + (0 qua Nat) by PRE_CIRC:25;
    card P = card F + card G - 1 by Th102
      .= card F - 1 + card G;
    then f < card P by A6,XREAL_1:8;
    hence thesis by AFINSQ_1:70;
  end;
end;

theorem Th104:
  for S being regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S
  holds CutLastLoc F c= CutLastLoc (F ';' G)
proof
  let S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S;
  set k = card F -' 1;
  set P = F ';' G;
A1: dom P = dom CutLastLoc F \/ dom Shift(IncAddr(G,k),k) by FUNCT_4:def 1;
A2: dom CutLastLoc F =
  { m where m is Element of NAT: m < card CutLastLoc F } by AFINSQ_1:72;
A3: card CutLastLoc P = card P - 1 by VALUED_1:39
    .= card F + card G - 1 - 1 by Th102
    .= card F - 1 + (card G - 1);
A4: for m being Element of NAT
  st m < card CutLastLoc F holds m < card CutLastLoc P
  proof
    let m be Element of NAT such that
A5: m < card CutLastLoc F;
A6: card CutLastLoc F = card F - 1 by VALUED_1:39;
    1 <= card G by NAT_1:14;
    then 1 - 1 <= card G - 1 by XREAL_1:11;
    then card F - 1 + (0 qua Nat) <= card F - 1 + (card G - 1) by XREAL_1:8;
    hence thesis by A3,A5,A6,XXREAL_0:2;
  end;
A7: dom CutLastLoc F c= dom CutLastLoc P
  proof
    let x be set;
    assume x in dom CutLastLoc F;
    then consider m being Element of NAT such that
A8: x = m and
A9: m < card CutLastLoc F by A2;
    m < card CutLastLoc P by A4,A9;
    hence thesis by A8,AFINSQ_1:70;
  end;
  for x being set st x in dom CutLastLoc F holds
  (CutLastLoc F).x = (CutLastLoc P).x
  proof
    let x be set;
    assume
A10: x in dom CutLastLoc F;
    then consider m being Element of NAT such that
A11: x = m and
A12: m < card CutLastLoc F by A2;
A13: dom Shift(IncAddr(G,k),k) = { w+k where w is Element of NAT:
    w in dom IncAddr(G,k) } by VALUED_1:def 12;
A14: now
      assume x in dom Shift(IncAddr(G,k),k);
      then consider w being Element of NAT such that
A15:  x = w+k and w in dom IncAddr(G,k) by A13;
      m < card F - 1 by A12,VALUED_1:39;
      then
      m < k by PRE_CIRC:25;
      hence contradiction by A11,A15,NAT_1:11;
    end;
A16: x in dom P by A1,A10,XBOOLE_0:def 3;
    now
      assume x = LastLoc P;
      then
A17:  m = card P -' 1 by A11,AFINSQ_1:74
        .= card P - 1 by PRE_CIRC:25;
      card CutLastLoc P = card P - 1 by VALUED_1:39;
      hence contradiction by A4,A12,A17;
    end;
    then not x in {LastLoc P} by TARSKI:def 1;
    then not x in dom ( LastLoc P .--> P.LastLoc P ) by FUNCOP_1:19;
    then x in dom P \ dom ( LastLoc P .--> P.LastLoc P ) by A16,XBOOLE_0:def 5;
    hence (CutLastLoc P).x = (CutLastLoc F +* Shift(IncAddr(G,k),k)).x
    by GRFUNC_1:93
      .= (CutLastLoc F).x by A14,FUNCT_4:12;
  end;
  hence thesis by A7,GRFUNC_1:8;
end;

theorem Th105:
  for S being regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S
  holds (F ';' G).LastLoc F = IncAddr(G,card F -' 1).0
proof
  let S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S;
  set k = card F -' 1;
A1: LastLoc F = (0 qua Nat)+k by AFINSQ_1:74;
A2: 0 in dom IncAddr(G,k) by AFINSQ_1:69;
  dom Shift(IncAddr(G,k),k) =
  {(m+k) where m is Element of NAT: m in dom IncAddr(G,k)}
  by VALUED_1:def 12;
  then LastLoc F in dom Shift(IncAddr(G,k),k) by A1,A2;
  hence (F ';' G).LastLoc F = (Shift(IncAddr(G,k),k)).LastLoc F by FUNCT_4:14
    .= IncAddr(G,k).0 by A1,A2,VALUED_1:def 12;
end;

theorem
  for S being regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S,
  f being Element of NAT st f < card F - 1
  holds IncAddr(F,card F -' 1).f = IncAddr(F ';' G, card F -' 1).f
proof
  let S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S,
  f be Element of NAT;
  set k = card F -' 1, P = F ';' G;
  assume f < card F - 1;
  then f < card CutLastLoc F by VALUED_1:39;
  then
A1: f in dom CutLastLoc F by AFINSQ_1:70;
A2: dom CutLastLoc F c= dom F by GRFUNC_1:8;
  CutLastLoc F c= CutLastLoc P by Th104;
  then CutLastLoc F c= P by XBOOLE_1:1;
  then
A3: dom CutLastLoc F c= dom P by GRFUNC_1:8;
A4: F.f = F/.f by A1,A2,PARTFUN1:def 8;
  dom CutLastLoc F misses dom Shift(IncAddr(G,k),k) by Th100;
  then dom CutLastLoc F /\ dom Shift(IncAddr(G,k),k) = {} by XBOOLE_0:def 7;
  then not f in dom Shift(IncAddr(G,k),k)
  by A1,XBOOLE_0:def 4;
  then
A5: P.f = (CutLastLoc F).f by FUNCT_4:12
    .= F.f by A1,GRFUNC_1:8;
  thus IncAddr(F,k).f = IncAddr(F/.f,k) by A1,A2,Def40
    .= IncAddr(P/.f,k) by A1,A3,A4,A5,PARTFUN1:def 8
    .= IncAddr(P,k).f by A1,A3,Def40;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be regular  homogeneous J/A-independent  realistic proper-halt

   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let F be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S;
  let G be halt-ending (initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S);
  cluster F ';' G -> halt-ending;
  coherence
  proof
    set P = F ';' G, k = card F -' 1;
A1: dom Shift(IncAddr(G,k),k) = { (m+k) where m is Element of NAT:
    m in dom IncAddr(G,k) } by VALUED_1:def 12;
A2: card G -' 1 = LastLoc G by AFINSQ_1:74;
    then
A3: card G -' 1 in dom G by VALUED_1:31;
    then
A4: card G -' 1 in dom IncAddr(G,k) by Def40;
    then
A5: k + (card G -' 1) in dom Shift(IncAddr(G,k),k) by A1;
A6: G/.(card G -' 1) = G.(card G -' 1) by A2,PARTFUN1:def 8,VALUED_1:31
      .= halt S by A2,Def25;
A7: card G - 1 >= 0 by NAT_1:14,XREAL_1:50;
    then k + (card G - 1) >= k+(0 qua Nat) by XREAL_1:8;
    then
A8: k + card G -' 1 = k + card G - 1 by XREAL_0:def 2
      .= k + (card G - 1)
      .= k + (card G -' 1) by A7,XREAL_0:def 2;
    thus P.(LastLoc P) = P.(card P -' 1) by AFINSQ_1:74
      .= P.(card F + card G -' 1 -' 1) by Th102
      .= P.(k + card G -' 1) by NAT_1:14,NAT_D:38
      .= Shift(IncAddr(G,k),k).(k + (card G -' 1)) by A5,A8,FUNCT_4:14
      .= IncAddr(G,k).(card G -' 1) by A4,VALUED_1:def 12
      .= IncAddr(G/.(card G -' 1),k) by A3,Def40
      .= halt S by A6,Th92;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be regular  homogeneous J/A-independent  realistic proper-halt

   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let F, G be halt-ending unique-halt
  (initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S);
  cluster F ';' G -> unique-halt;
  coherence
  proof
    set P = F ';' G, k = card F -' 1;
A1: dom P = dom CutLastLoc F \/ dom Shift(IncAddr(G,k),k) by FUNCT_4:def 1;
A2: dom Shift(IncAddr(G,k),k) = { (m+k) where m is Element of NAT:
    m in dom IncAddr(G,k) } by VALUED_1:def 12;
A3: card G - 1 >= 0 by NAT_1:14,XREAL_1:50;
    then k + (card G - 1) >= k+(0 qua Nat) by XREAL_1:8;
    then
A4: k + card G -' 1 = k + card G - 1 by XREAL_0:def 2
      .= k + (card G - 1)
      .= k + (card G -' 1) by A3,XREAL_0:def 2;
    let f be Element of NAT such that
A5: P.f = halt S and
A6: f in dom P;
    per cases by A1,A6,XBOOLE_0:def 3;
    suppose
A7:   f in dom CutLastLoc F;
      then
A8:   (CutLastLoc F).f <> halt S by Th101;
      dom CutLastLoc F misses dom Shift(IncAddr(G,k),k) by Th100;
      then CutLastLoc F c= P by FUNCT_4:33;
      hence thesis by A5,A7,A8,GRFUNC_1:8;
    end;
    suppose
A9:   f in dom Shift(IncAddr(G,k),k);
      then consider m being Element of NAT such that
A10:  f = (m+k) and
A11:  m in dom IncAddr(G,k) by A2;
A12:  m in dom G by A11,Def40;
      then
A13:  G/.m = G.m by PARTFUN1:def 8;
      IncAddr(G/.m,k) = IncAddr(G,k).m by A12,Def40
        .= Shift(IncAddr(G,k),k).(m+k) by A11,VALUED_1:def 12
        .= halt S by A5,A9,A10,FUNCT_4:14;
      then m = LastLoc G by A12,A13,Th96,Def26
        .= (card G -' 1) by AFINSQ_1:74;
      then m+k = card F + card G -' 1 -' 1 by A4,NAT_1:14,NAT_D:38
        .= card P -' 1 by Th102;
      hence thesis by A10,AFINSQ_1:74;
    end;
  end;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be regular homogeneous J/A-independent  realistic proper-halt

   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let F, G be pre-Macro of S;
  redefine func F ';' G -> pre-Macro of S;
  coherence;
end;

theorem Th107:
  for S being regular homogeneous J/A-independent proper-halt
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  holds IncAddr(Stop S, k) = Stop S
proof
  let S be regular homogeneous J/A-independent proper-halt
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
A1: dom IncAddr(Stop S, k) = dom Stop S by Def40
    .= {0} by Lm12;
A2: dom Stop S = {0} by Lm12;
  for x being set st x in {0} holds IncAddr(Stop S, k).x = (Stop S). x
  proof
    let x be set;
    assume
A3: x in {0};
    then
A4: x = 0 by TARSKI:def 1;
    then
A5: (Stop S)/.0 = (Stop S).0 by A2,A3,PARTFUN1:def 8
      .= halt S by FUNCOP_1:87;
    thus IncAddr(Stop S, k).x
    = IncAddr((Stop S)/.0,k) by A2,A3,A4,Def40
      .= halt S by A5,Th92
      .= (Stop S).x by A4,FUNCOP_1:87;
  end;
  hence thesis by A1,A2,FUNCT_1:9;
end;

theorem Th108:
  for k being Element of NAT
  for S being   (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  holds Shift(Stop S, k) = k .--> halt S
proof
  let k be Element of NAT;
  let S be   (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
A1: dom Shift(Stop S,k) =
  {(m+k) where m is Element of NAT: m in dom Stop S} by VALUED_1:def 12;
A2: 0 in dom Stop S by Lm12;
A3: dom Shift(Stop S,k) = {k}
  proof
    hereby
      let x be set;
      assume x in dom Shift(Stop S,k);
      then consider m being Element of NAT such that
A4:   x = (m+k) and
A5:   m in dom Stop S by A1;
      m in {0} by A5,Lm12;
      then m = 0 by TARSKI:def 1;
      hence x in {k} by A4,TARSKI:def 1;
    end;
    let x be set;
    assume x in {k};
    then x = (0 qua Nat)+k by TARSKI:def 1;
    hence thesis by A1,A2;
  end;
A6: dom (k .--> halt S) = {k} by FUNCOP_1:19;
  for x being set st x in {k} holds
  (Shift(Stop S, k)).x = (k .--> halt S).x
  proof
    let x be set;
    assume x in {k};
    then
A7: x = (0 qua Nat)+k by TARSKI:def 1;
    0 in dom Stop S by Lm12;
    hence (Shift(Stop S, k)).x = (Stop S).0 by A7,VALUED_1:def 12
      .= halt S by FUNCOP_1:87
      .= (k .--> halt S).x by A7,FUNCOP_1:87;
  end;
  hence thesis by A3,A6,FUNCT_1:9;
end;

theorem Th109:
  for S being regular homogeneous J/A-independent proper-halt
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), F being pre-Macro of S
  holds F ';' Stop S = F
proof
  let S be regular homogeneous J/A-independent proper-halt
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), F be pre-Macro of S;
  set k = card F -' 1;
A1: F ';' Stop S = CutLastLoc F +* Shift(Stop S,k) by Th107;
A2: dom F = dom CutLastLoc F \/ {LastLoc F} by VALUED_1:38;
  dom Shift(Stop S,k) = dom (k .--> halt S) by Th108
    .= {k} by FUNCOP_1:19
    .= {LastLoc F} by AFINSQ_1:74;
  then
A3: dom (F ';' Stop S) = dom F by A1,A2,FUNCT_4:def 1;
  for x being set st x in dom F holds (F ';' Stop S).x = F.x
  proof
    let x be set such that
A4: x in dom F;
    dom CutLastLoc F misses dom Shift(IncAddr(Stop S,k),k) by Th100;
    then
A5: {} = dom CutLastLoc F /\ dom Shift(IncAddr(Stop S,k),k) by XBOOLE_0:def 7;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A6:   x in dom CutLastLoc F;
      then not x in dom Shift(IncAddr(Stop S,k),k) by A5,XBOOLE_0:def 4;
      hence (F ';' Stop S).x = (CutLastLoc F).x by FUNCT_4:12
        .= F.x by A6,GRFUNC_1:8;
    end;
    suppose x in {LastLoc F};
      then
A7:   x = LastLoc F by TARSKI:def 1;
      then
A8:   x = k by AFINSQ_1:74;
A9:   0 in dom Stop S by Lm12;
      dom Shift(Stop S,k)
      = { (m+k) where m is Element of NAT: m in dom Stop S }
      by VALUED_1:def 12;
      then (0 qua Nat)+k in dom Shift(Stop S,k) by A9;
      hence (F ';' Stop S).x = Shift(Stop S,(0 qua Nat)+k).x
       by A1,A8,FUNCT_4:14
        .= (Stop S).0 by A8,A9,VALUED_1:def 12
        .= halt S by FUNCOP_1:87
        .= F.x by A7,Def25;
    end;
  end;
  hence thesis by A3,FUNCT_1:9;
end;

theorem Th110:
  for S being regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), F being pre-Macro of S
  holds Stop S ';' F = F
proof
  let S be regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), F be pre-Macro of S;
  set k = card Stop S -' 1;
A1: k = 0 by Lm13;
  hence Stop S ';' F = CutLastLoc Stop S +* Shift(F,k) by Th98
    .= CutLastLoc Stop S +* F by A1,VALUED_1:29
    .= F by FUNCT_4:21;
end;

theorem
  for S being regular homogeneous J/A-independent realistic proper-halt

   (standard-ins IC-Ins-separated
  definite (non empty stored-program COM-Struct over N)),
  F, G, H being pre-Macro of S holds F ';' G ';' H = F ';' (G ';' H)
proof
  let S be regular homogeneous J/A-independent realistic proper-halt

   (standard-ins IC-Ins-separated
  definite (non empty stored-program COM-Struct over N)),
  F, G, H be pre-Macro of S;
  per cases;
  suppose
A1: F = Stop S;
    hence F ';' G ';' H = G ';' H by Th110
      .= F ';' (G ';' H) by A1,Th110;
  end;
  suppose
A2: G = Stop S;
    hence F ';' G ';' H = F ';' H by Th109
      .= F ';' (G ';' H) by A2,Th110;
  end;
  suppose that
A3: F <> Stop S and
A4: G <> Stop S;
    set X = {k where k is Element of NAT:
    k < card F + card G + card H - 1 - 1};
A5: card (F ';' G ';' H) = card (F ';' G) + card H - 1 by Th102
      .= card F + card G - 1 + card H - 1 by Th102
      .= card F + card G + card H - 1 - 1;
A6: card (F ';' (G ';' H)) = card F + card (G ';' H) - 1 by Th102
      .= card F + (card G + card H - 1) - 1 by Th102
      .= card F + card G + card H - 1 - 1;
A7: dom (F ';' G ';' H) = X by A5,AFINSQ_1:72;
A8: dom (F ';' (G ';' H)) = X by A6,AFINSQ_1:72;
    for x being set st x in X holds (F ';' G ';' H).x = (F ';' (G ';' H)) . x
    proof
      let x be set;
      assume x in X;
      then consider k being Element of NAT such that
A9:   x = k and
A10:  k < card F + card G + card H - 1 - 1;
A11:  dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) =
      { m+(card F -' 1) where m is Element of NAT:
      m in dom IncAddr(G ';' H,card F -' 1) } by VALUED_1:def 12;
A12:  dom Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1) =
      { m+(card (F ';' G) -' 1) where m is Element of NAT:
      m in dom IncAddr(H,card (F ';' G) -' 1) } by VALUED_1:def 12;
A13:  dom Shift(IncAddr(H,card G -' 1),card G -' 1) =
      { m+(card G -' 1) where m is Element of NAT:
      m in dom IncAddr(H,card G -' 1) } by VALUED_1:def 12;
A14:  card (F ';' G) -' 1 = card (F ';' G) - 1 by PRE_CIRC:25
        .= card F + card G - 1 - 1 by Th102;
      then card (F ';' G) -' 1 = card F - 1 + (card G - 1);
      then
A15:  card (F ';' G) -' 1 = (card G -' 1) + (card F - 1) by PRE_CIRC:25
        .= (card G -' 1) + (card F -' 1) by PRE_CIRC:25;
A16:  dom Shift(IncAddr(G,card F -' 1),card F -' 1) =
      { m+(card F -' 1) where m is Element of NAT:
      m in dom IncAddr(G,card F -' 1) } by VALUED_1:def 12;
A17:  card F -' 1 = card F - 1 by PRE_CIRC:25;
A18:  card G -' 1 = card G - 1 by PRE_CIRC:25;
A19:  for W being pre-Macro of S st W <> Stop S holds 2 <= card W
      proof
        let W be pre-Macro of S;
        assume
A20:    W <> Stop S;
        assume 2 > card W;
        then 1 + 1 > card W;
        then card W <= 1 by NAT_1:13;
        hence contradiction by A20,Th89,NAT_1:26;
      end;
      then 2 <= card F by A3;
      then
A21:  1 <= card F by XXREAL_0:2;
A22:  2 <= card G by A4,A19;
      per cases by A21,A22,Lm9;
      suppose
A23:    k < card F - 1;
A24:    CutLastLoc F c= CutLastLoc (F ';' G) by Th104;
A25:    now
          assume x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1);
          then consider m being Element of NAT such that
A26:      x = m+(card F -' 1) and
          m in dom IncAddr(G ';' H,card F -' 1) by A11;
          k = m + (card F - 1) by A9,A26,PRE_CIRC:25;
          then m + (card F - 1) < card F -' 1 by A23,PRE_CIRC:25;
          then m + (card F -' 1) < card F -' 1 by PRE_CIRC:25;
          hence contradiction by NAT_1:11;
        end;
A27:    now
          assume x in dom
          Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1);
          then consider m being Element of NAT such that
A28:      x = m+(card (F ';' G) -' 1) and
          m in dom IncAddr(H,card (F ';' G) -' 1) by A12;
          m + (card G -' 1) + (card F -' 1) < card F -' 1
          by A23,A9,A15,A28,PRE_CIRC:25;
          hence contradiction by NAT_1:11;
        end;
        k < card CutLastLoc F by A23,VALUED_1:39;
        then
A29:    x in dom CutLastLoc F by A9,AFINSQ_1:70;
        thus (F ';' G ';' H).x = (CutLastLoc (F ';' G)).x by A27,FUNCT_4:12
          .= (CutLastLoc F).x by A24,A29,GRFUNC_1:8
          .= (F ';' (G ';' H)).x by A25,FUNCT_4:12;
      end;
      suppose
A30:    k = card F - 1;
A31:    now
          assume x in dom
          Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1);
          then consider m being Element of NAT such that
A32:      x = m+(card (F ';' G) -' 1) and
          m in dom IncAddr(H,card (F ';' G) -' 1) by A12;
          m + (card G -' 1) + (card F -' 1) = card F -' 1 by A30,A15,A32,A9,
PRE_CIRC:25;
          then card G -' 1 = 0;
          then card G - 1 = 0 by PRE_CIRC:25;
          hence contradiction by A4,Th89;
        end;
A33:    0 in dom IncAddr(G ';' H,card F -' 1) by AFINSQ_1:69;
A34:    0 in dom IncAddr(G,card F -' 1) by AFINSQ_1:69;
A35:    0 in dom G by AFINSQ_1:69;
A36:    0 in dom (G ';' H) by AFINSQ_1:69;
        k = (0 qua Nat) + (card F -' 1) by A30,PRE_CIRC:25;
        then
A37:    x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) by A9,A11,A33;
A38:    k = card F -' 1 by A30,PRE_CIRC:25;
A39:    x = (0 qua Nat)+k by A9;
        0 in dom IncAddr(G,card F -' 1) by AFINSQ_1:69;
        then
A40:    x in dom Shift(IncAddr(G,card F -' 1),card F -' 1) by A16,A38,A39;
then x in dom CutLastLoc F \/ dom Shift(IncAddr(G,card F -' 1),card F -' 1)
        by XBOOLE_0:def 3;
        then
A41:    x in dom (F ';' G) by FUNCT_4:def 1;
        now
A42:      dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G ))
          = {LastLoc (F ';' G)} by FUNCOP_1:19
            .= {card (F ';' G) -' 1} by AFINSQ_1:74;
assume x in dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G ));
          then x = card (F ';' G) -' 1 by A42,TARSKI:def 1;
          then card G - 1 = 0 by A38,A9,A15,PRE_CIRC:25;
          hence contradiction by A4,Th89;
        end;
        then
A43:    x in dom (F ';' G) \
        dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G ))
        by A41,XBOOLE_0:def 5;
        1 <= card G by NAT_1:14;
        then card G > 1 by A4,Th89,XXREAL_0:1;
        then
A44:    card G - 1 > 1 - 1 by XREAL_1:11;
        then card G -' 1 > 1 - 1 by PRE_CIRC:25;
        then
A45:    not 0 in dom Shift(IncAddr(H,card G -' 1), card G -' 1) by VALUED_1:30;
        card CutLastLoc G <> {} by A44,VALUED_1:39;
        then
A46:    0 in dom CutLastLoc G by AFINSQ_1:69,CARD_1:47;
A47:    G/.0 = G.0 by A35,PARTFUN1:def 8
          .= (CutLastLoc G).0 by A46,GRFUNC_1:8
          .= (G ';' H).0 by A45,FUNCT_4:12
          .= (G ';' H)/.0 by A36,PARTFUN1:def 8;
        thus (F ';' G ';' H).x = ((F ';' G) \
        ( LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G ))).x by A31,
FUNCT_4:12
.= (CutLastLoc F +* Shift(IncAddr(G,card F -' 1),card F -' 1)).x by A43,
GRFUNC_1:93
          .= Shift(IncAddr(G,card F -' 1),card F -' 1).x by A40,FUNCT_4:14
          .= IncAddr(G,card F -' 1).0 by A34,A38,A39,VALUED_1:def 12
          .= IncAddr((G ';' H)/.0,card F -' 1) by A35,A47,Def40
          .= IncAddr(G ';' H,card F -' 1).0 by A36,Def40
          .= Shift(IncAddr(G ';' H,card F -' 1),card F -' 1).x
        by A33,A38,A39,VALUED_1:def 12
          .= (F ';' (G ';' H)).x by A37,FUNCT_4:14;
      end;
      suppose that
A48:    card F <= k and
A49:    k <= card F + card G - 3;
A50:    now
          assume
          x in dom Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1);
          then consider m being Element of NAT such that
A51:      x = m+(card (F ';' G) -' 1) and
          m in dom IncAddr(H,card (F ';' G) -' 1) by A12;
          m + ((card G -' 1) + (card F -' 1))
          <= - 1 + ((card G -' 1) + (card F -' 1)) by A9,A15,A17,A18,A49,A51;
          hence contradiction by XREAL_1:8;
        end;
        card F -' 1 <= card F by NAT_D:35;
        then
A52:    x = k -' (card F -' 1) + (card F -' 1)
        by A9,A48,XREAL_1:237,XXREAL_0:2;
A53:    card F - card F <= k - card F by A48,XREAL_1:11;
        card F - 1 < card F - 0 by XREAL_1:17;
        then k - (card F - 1) >= 0 by A53,XREAL_1:17;
        then
A54:    k - (card F -' 1) >= 0 by PRE_CIRC:25;
A55:    card F + card G - 3 < card F + card G - 3 + 1 by XREAL_1:31;
        then
A56:    k < (card G - 1) + (card F - 1) by A49,XXREAL_0:2;
        k - (card F - 1) + (card F - 1) < (card G - 1) + (card F - 1)
        by A49,A55,XXREAL_0:2;
        then k - (card F - 1) < card G - 1 by XREAL_1:9;
        then k - (card F -' 1) < card G - 1 by PRE_CIRC:25;
        then k -' (card F -' 1) < card G - 1 by A54,XREAL_0:def 2;
        then k -' (card F -' 1) < card CutLastLoc G by VALUED_1:39;
        then
A57:    k -' (card F -' 1) in dom CutLastLoc G by AFINSQ_1:70;
        then k -' (card F -' 1) in
        dom CutLastLoc G \/ dom Shift(IncAddr(H,card G -' 1),card G -' 1)
        by XBOOLE_0:def 3;
        then
A58:    k -' (card F -' 1) in dom (G ';' H) by FUNCT_4:def 1;
        then
A59:    k -' (card F -' 1) in dom IncAddr(G ';' H,card F -' 1)
        by Def40;
        then
A60:    x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) by A11,A52;
        card G + card F - 2 < card F + card G - 1 by XREAL_1:17;
        then k < card F + card G - 1 by A56,XXREAL_0:2;
        then k < card (F ';' G) by Th102;
        then
A61:    x in dom (F ';' G) by A9,AFINSQ_1:70;
        now
          assume x in dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G));
          then x in {LastLoc (F ';' G)} by FUNCOP_1:19;
          then x = LastLoc (F ';' G) by TARSKI:def 1
            .= card (F ';' G) -' 1 by AFINSQ_1:74;
          then k = (card G - 1) + (card F - 1) by A9,A15,A18,PRE_CIRC:25;
          hence contradiction by A49,A55;
        end;
        then
A62:    x in dom (F ';' G) \
        dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G))
        by A61,XBOOLE_0:def 5;
A63:    dom CutLastLoc G c= dom G by GRFUNC_1:8;
        then k -' (card F -' 1) in dom G by A57;
        then
A64:    k -' (card F -' 1) in dom IncAddr(G,card F -' 1) by Def40;
        then
A65:    x in dom Shift(IncAddr(G,card F -' 1),card F -' 1) by A16,A52;
A66:    now
          assume k -' (card F -' 1) in
          dom Shift(IncAddr(H,card G -' 1),card G -' 1);
          then consider m being Element of NAT such that
A67:      k -' (card F -' 1) = m+(card G -' 1) and
          m in dom IncAddr(H,card G -' 1) by A13;
A68:      m = k -' (card F -' 1) - (card G -' 1) by A67
            .= k - (card F -' 1) - (card G -' 1) by A54,XREAL_0:def 2
            .= k - (card F - 1) - (card G -' 1) by PRE_CIRC:25
            .= k - (card F - 1) - (card G - 1) by PRE_CIRC:25
            .= k - (card F + card G - 2);
          k - (card F + card G - 2)
          <= card F + card G - 3 - (card F + card G - 2) by A49,XREAL_1:11;
          hence contradiction by A68,Lm8;
        end;
A69:    (G ';' H)/.(k -' (card F -' 1))
        = (CutLastLoc G +* Shift(IncAddr(H,card G -' 1),card G -' 1))
        .(k -' (card F -' 1)) by A58,PARTFUN1:def 8
          .= (CutLastLoc G).(k -' (card F -' 1)) by A66,FUNCT_4:12
          .= G.(k -' (card F -' 1)) by A57,GRFUNC_1:8;
        thus (F ';' G ';' H).x
        = ((F ';' G) \ (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G))).x
        by A50,FUNCT_4:12
.= (CutLastLoc F +* Shift(IncAddr(G,card F -' 1),card F -' 1)).x by A62,
GRFUNC_1:93
          .= Shift(IncAddr(G,card F -' 1),card F -' 1).x by A65,FUNCT_4:14
          .= IncAddr(G,card F -' 1).(k -' (card F -' 1))
           by A52,A64,VALUED_1:def 12
          .= IncAddr(G/.(k -' (card F -' 1)),card F -' 1)
        by A57,A63,Def40
          .= IncAddr((G ';' H)/.(k -' (card F -' 1)),card F -' 1)
        by A57,A63,A69,PARTFUN1:def 8
          .= IncAddr(G ';' H,card F -' 1).(k -' (card F -' 1))
        by A58,Def40
          .= Shift(IncAddr(G ';' H,card F -' 1),card F -' 1).x
           by A52,A59,VALUED_1:def 12
          .= (F ';' (G ';' H)).x by A60,FUNCT_4:14;
      end;
      suppose
A70:    k = card F + card G - 2;
        then
A71:    x = (k -' (card (F ';' G) -' 1) + (card (F ';' G) -' 1))
        by A9,A14,XREAL_1:237;
        k - (card (F ';' G) -' 1) = 0 by A14,A70;
        then
A72:    k -' (card (F ';' G) -' 1) = 0 by XREAL_0:def 2;
        then
A73:    k -' (card (F ';' G) -' 1) in dom IncAddr(H,card (F ';' G)
        -' 1) by AFINSQ_1:69;
        then
A74:    x in dom Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1)
        by A12,A71;
A75:    x = (card G -' 1) + (card F -' 1) by A9,A17,A18,A70;
        card G - 1 + (0 qua Nat) < card G - 1 + card H by XREAL_1:8;
        then card G -' 1 < card G + card H - 1 by PRE_CIRC:25;
        then card G -' 1 < card (G ';' H) by Th102;
        then
A76:    (card G -' 1) in dom (G ';' H) by AFINSQ_1:70;
        then
A77:    (card G -' 1) in dom IncAddr(G ';' H,card F -' 1) by Def40;
        then
A78:    x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) by A11,A75;
A79:    0 in dom H by AFINSQ_1:69;
A80:    (G ';' H)/.(card G -' 1) = (G ';' H).(card G -' 1)
        by A76,PARTFUN1:def 8;
A81:    0 in dom IncAddr(H,card G -' 1) by AFINSQ_1:69;
        then
A82:    IncAddr(H,card G -' 1)/.0
        = IncAddr(H,card G -' 1).0 by PARTFUN1:def 8
          .= IncAddr(H/.0,(card G -' 1)) by A79,Def40;
        (G ';' H)/.(card G -' 1)
        = (G ';' H).LastLoc G by A80,AFINSQ_1:74
          .= IncAddr(H,card G -' 1).0 by Th105
          .= IncAddr(H,card G -' 1)/.0 by A81,PARTFUN1:def 8;
        then
A83:    IncAddr((G ';' H)/.(card G -' 1),card F -' 1)
        = IncAddr(H/.0,card (F ';' G) -' 1) by A15,A82,Th97;
        thus (F ';' G ';' H).x
        = Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1).x
        by A74,FUNCT_4:14
          .= IncAddr(H,card (F ';' G) -' 1).(k -' (card (F ';' G) -' 1))
        by A71,A73,VALUED_1:def 12
          .= IncAddr(H/.0,card (F ';' G) -' 1) by A72,A79,Def40
          .= IncAddr(G ';' H,card F -' 1).(card G -' 1) by A76,A83,Def40
          .= Shift(IncAddr(G ';' H,card F -' 1),card F -' 1).x
           by A75,A77,VALUED_1:def 12
          .= (F ';' (G ';' H)).x by A78,FUNCT_4:14;
      end;
      suppose
A84:    card F + card G - 2 < k;
        then
A85:    x = (k -' (card (F ';' G) -' 1) + (card (F ';' G) -' 1))
        by A9,A14,XREAL_1:237;
        k + (0 qua Nat) < card F + card G - (1 + 1) + card H by A10;
        then k - (card F + card G - (1 + 1)) < card H - 0 by XREAL_1:23;
        then k -' (card (F ';' G) -' 1) < card H by A14,XREAL_0:def 2;
        then
A86:    k -' (card (F ';' G) -' 1) in dom H by AFINSQ_1:70;
        then
A87:    k -' (card (F ';' G) -' 1) in dom IncAddr(H,card (F ';' G)
        -' 1) by Def40;
        then
A88:    x in dom Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1)
        by A12,A85;
A89:    card F -' 1 <= (card G -' 1) + (card F -' 1) by NAT_1:11;
        then
A90:    k >= card F -' 1 by A14,A15,A84,XXREAL_0:2;
A91:    x = k -' (card F -' 1) + (card F -' 1) by A9,A14,A15,A84,A89,
XREAL_1:237,XXREAL_0:2;
A92:    k - (card F -' 1) >= 0 by A90,XREAL_1:50;
A93:    k - (card F -' 1) < card F + card G + card H - 1 - 1 - (card F -' 1)
        by A10,XREAL_1:11;
        then
A94:    k -' (card F -' 1) < card F + card G + card H - card F - 1
        by A17,A92,XREAL_0:def 2;
        k -' (card F -' 1) < card F - card F + card G + card H - 1
        by A17,A92,A93,XREAL_0:def 2;
        then k -' (card F -' 1) < card (G ';' H) by Th102;
        then
A95:    k -' (card F -' 1) in dom (G ';' H) by AFINSQ_1:70;
        then k -' (card F -' 1) in dom IncAddr(G ';' H,card F -' 1)
        by Def40;
        then
A96:    x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) by A11,A91;
A97:    k -' (card F -' 1) in dom IncAddr(G ';' H,card F -' 1)
        by A95,Def40;
A98:    k - (card F -' 1) >= card (F ';' G) -' 1 - (card F -' 1)
        by A14,A84,XREAL_1:11;
        then
A99:    k -' (card F -' 1) >= (card F -' 1) + (card G -' 1) - ( card F -' 1)
        by A14,A15,A84,A89,XREAL_1:235,XXREAL_0:2;
A100:   k -' (card F -' 1) >= card G -' 1 by A14,A15,A84,A89,A98,XREAL_1:235
,XXREAL_0:2;
A101:   k -' (card F -' 1) =
        k -' (card F -' 1) -' (card G -' 1) + (card G -' 1) by A99,XREAL_1:237;
        k -' (card F -' 1) - (card G -' 1) < card G + card H - 1 - (card G -
        1) by A18,A94,XREAL_1:11;
        then k -' (card F -' 1) -' (card G -' 1) <
        card H + (card G - 1) - (card G - 1) by A100,XREAL_1:235;
then k -' (card F -' 1) -' (card G -' 1) in dom H by AFINSQ_1:70;
        then
A102:   k -' (card F -' 1) -' (card G -' 1) in
        dom IncAddr(H,card G -' 1) by Def40;
        then
A103:   k -' (card F -' 1) in
        dom Shift(IncAddr(H,card G -' 1),card G -' 1) by A13,A101;
A104:   k -' (card F -' 1) -' (card G -' 1)
        = k -' (card F -' 1) - (card G -' 1) by A99,XREAL_1:235
       .= k - (card F -' 1) - (card G -' 1) by A14,A15,A84,A89,XREAL_1:235
,XXREAL_0:2
          .= k - ((card F -' 1) + (card G -' 1))
          .= k -' (card (F ';' G) -' 1) by A14,A15,A84,XREAL_1:235;
A105:   (G ';' H)/.(k -' (card F -' 1))
        = ((CutLastLoc G) +* Shift(IncAddr(H,card G -' 1),card G -' 1)).
        (k -' (card F -' 1)) by A95,PARTFUN1:def 8
.= Shift(IncAddr(H,card G -' 1),card G -' 1).(k -' (card F -' 1))
        by A103,FUNCT_4:14
.= IncAddr(H,card G -' 1).(k -' (card (F ';' G) -' 1)) by A101,A102,A104,
VALUED_1:def 12
          .= IncAddr(H/.(k -' (card (F ';' G) -' 1)),card G -' 1)
        by A86,Def40;
        thus (F ';' G ';' H).x
        = Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1).x
        by A88,FUNCT_4:14
          .= IncAddr(H,card (F ';' G) -' 1).(k -' (card (F ';' G) -' 1))
        by A85,A87,VALUED_1:def 12
.= IncAddr(H/.(k -' (card (F ';' G) -' 1)),card (F ';' G) -' 1)
        by A86,Def40
          .= IncAddr((G ';' H)/.(k -' (card F -' 1)),card F -' 1)
        by A15,A105,Th97
          .= IncAddr(G ';' H,card F -' 1).(k -' (card F -' 1))
        by A95,Def40
          .= Shift(IncAddr(G ';' H,card F -' 1),card F -' 1).x
           by A91,A97,VALUED_1:def 12
          .= (F ';' (G ';' H)).x by A96,FUNCT_4:14;
      end;
    end;
    hence thesis by A7,A8,FUNCT_1:9;
  end;
end;

theorem
  for S being regular homogeneous
  (standard-ins non empty stored-program COM-Struct over N),
  I being Instruction of S, x being set st x in dom JumpPart I holds
  (JumpPart I).x in (product" JumpParts InsCode I).x
proof
  let S be regular homogeneous
  (standard-ins non empty stored-program COM-Struct over N),
  I be Instruction of S, x be set such that
A1: x in dom JumpPart I;
A2: JumpPart I in JumpParts InsCode I;
A3: dom product" JumpParts InsCode I = DOM JumpParts InsCode I
  by CARD_3:92
    .= dom JumpPart I by A2,CARD_3:def 12;
  (JumpPart I).x in pi(JumpParts InsCode I,x) by A2,CARD_3:def 6;
  hence thesis
  by A1,A3,CARD_3:93;
end;

theorem
  for I being Instruction of Trivial-COM N holds JumpPart I = 0 by Lm10;

theorem
  for T being InsType of Trivial-COM N holds JumpParts T = {0} by Lm11;

begin :: Addenda

:: from SCMRING4, 2008.03.13, A.T.

reserve i, j, k for natural number,
  n for Element of NAT,
  l for Element of NAT,
  f for FinPartState of S;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent  (IC-Ins-separated definite
   realistic
  (standard-ins non empty stored-program COM-Struct over N)),
  k be Element of NAT, p be FinPartState of S;
  func Relocated (p,k) -> FinPartState of S equals
   IncIC(NPP p,k) +* Reloc(ProgramPart p,k);
  coherence;
end;

reserve S for regular homogeneous J/A-independent
(IC-Ins-separated
definite  realistic
  (standard-ins non empty stored-program COM-Struct over N)),
  g for FinPartState of S,
  s for State of S,
  il for Element of NAT;

theorem Th115:
 for k being Element of NAT holds DataPart Relocated(g,k) = DataPart g
proof
  let k be Element of NAT;
   dom Reloc(ProgramPart(g),k) c= NAT by RELAT_1:def 18;
   then dom Reloc(ProgramPart(g),k) misses Data-Locations S
        by Th51,XBOOLE_1:63;
  hence DataPart Relocated(g,k)
     = DataPart IncIC(NPP g,k) by FUNCT_4:76
    .= DataPart NPP g by Th48
    .= DataPart g by Th73;
end;

theorem Th116:
  for k being Element of NAT holds
  ProgramPart Relocated(g,k) = Reloc(ProgramPart(g),k)
proof
  let k be Element of NAT;
  thus ProgramPart Relocated(g,k) =
     IncIC(NPP g,k)|NAT +* Reloc(ProgramPart(g),k)|NAT by FUNCT_4:75
    .= {} +* Reloc(ProgramPart(g),k)|NAT by Def29
    .= Reloc(ProgramPart(g),k)|NAT by FUNCT_4:21
    .= Reloc(ProgramPart g,k) by RELAT_1:209;
end;

theorem Th117:
  for k being Element of NAT holds
  for p being finite NAT-defined (the Instructions of S)-valued Function
   holds dom Reloc(p,k) =
    { j+k where j is Element of NAT:j in dom p }
proof
  let k be Element of NAT;
  let p be finite NAT-defined (the Instructions of S)-valued Function;
  thus dom Reloc(p,k) = dom Shift(p,k) by Def40
    .= { j+k where j is Element of NAT:j in dom p } by VALUED_1:def 12;
end;

canceled;

theorem Th119:
  for k being Element of NAT holds
  IC S in dom Relocated (g,k)
proof
  let k be Element of NAT;
  Relocated (g,k) = IncIC(NPP g,k) +* Reloc(ProgramPart(g),k) &
  IC S in dom IncIC(NPP g,k) by Th53;
  hence thesis by FUNCT_4:13;
end;

theorem Th120:
  for k being Element of NAT st IC S in dom g
   holds IC Relocated (g,k) = IC g + k
proof
  let k be Element of NAT such that
A1: IC S in dom g;
    ProgramPart Relocated(g,k) = Reloc(ProgramPart g,k) by Th116;
  then
A2: not IC S in dom Reloc(ProgramPart g,k) by Th12;
  thus IC Relocated (g,k) = Relocated (g,k).IC S
    .= IC IncIC(NPP g,k) by A2,FUNCT_4:12
    .= (IC NPP g) +k by Th54
    .= (IC g) +k by A1,Th72;
end;

theorem Th121:
  for i,j being Element of NAT holds
  for p being NAT-defined (the Instructions of S)-valued finite Function
  holds Shift(IncAddr(p,i),j) = IncAddr(Shift(p,j),i)
proof
  let i,j be Element of NAT;
  let p be NAT-defined (the Instructions of S)-valued finite Function;
  set f = Shift(IncAddr(p,i),j);
  set g = IncAddr(Shift(p,j),i);
  dom(IncAddr(p,i)) = dom p by Def40;
  then dom(Shift(p,j)) = { m+j where m is Element of NAT:
  m in dom (IncAddr(p,i)) } by VALUED_1:def 12
    .= dom f by VALUED_1:def 12;
  then
A1: dom f = dom g by Def40;
  now
    let x be set;
A2: dom f c= NAT by RELAT_1:def 18;
    assume
A3: x in dom f;
    then reconsider x9=x as Element of NAT by A2;
    reconsider xx=x9 as Element of NAT;
    x in { m+j where m is Element of NAT:
    m in dom IncAddr(p,i) } by A3,VALUED_1:def 12;
    then consider m being Element of NAT such that
A4: x = m+j and
A5: m in dom IncAddr(p,i);
A6: m in dom p by A5,Def40;
    dom Shift(p,j) = { mm+j where mm is Element of NAT :
    mm in dom p} by VALUED_1:def 12;
    then
A7: x9 in dom Shift(p,j) by A4,A6;
    reconsider mm=m as Element of NAT;
A8: p/.mm = p.m by A6,PARTFUN1:def 8
      .= Shift(p,j).(m + j) by A6,VALUED_1:def 12
      .= Shift(p,j)/.xx by A4,A7,PARTFUN1:def 8;
    thus f.x = IncAddr(p,i).(m) by A5,A4,VALUED_1:def 12
      .= IncAddr(Shift(p,j)/.xx,i) by A6,A8,Def40
      .= g.x by A7,Def40;
  end;
  hence thesis by A1,FUNCT_1:9;
end;

theorem
  for g being NAT-defined (the Instructions of S)-valued finite Function
  for k being Element of NAT holds
  for I being Instruction of S holds
  il in dom g & I = g.il implies
  IncAddr(I, k) = Reloc(g, k).(il + k)
proof
  let g be NAT-defined (the Instructions of S)-valued finite Function;
  let k be Element of NAT;
  let I be Instruction of S;
  assume that
A1: il in dom g and
A2: I = g.il;

  reconsider ii = il as Element of NAT;
A3: il in dom IncAddr(g,k) by A1,Def40;
  thus (Reloc(g, k)).(il + k)
     = (IncAddr(Shift(g,k),k)).(il + k)
    .= (Shift(IncAddr(g,k),k)).(il + k) by Th121
    .= (IncAddr(g,k)).il by A3,VALUED_1:def 12
    .= IncAddr((g)/.ii,k) by A1,Def40
    .= IncAddr(I,k) by A1,A2,PARTFUN1:def 8;
end;

theorem
  for k being Element of NAT st IC S in dom g
  holds Start-At (IC g + k,S) c= Relocated (g,k)
proof
  let k be Element of NAT such that
A1: IC S in dom g;
A2: Start-At(IC g +k,S) = {[IC S,IC g + k]} by FUNCT_4:87;
A3: IC Relocated(g,k) = IC g + k by A1,Th120;
A4: IC S in dom (Relocated(g,k)) by Th119;
A5: [IC S,IC g + k] in Relocated(g,k) by A4,A3,FUNCT_1:def 4;
  thus Start-At(IC g +k,S) c= Relocated(g,k)
  proof
    let x be set;
    assume x in Start-At(IC g +k,S);
    hence thesis by A2,A5,TARSKI:def 1;
  end;
end;

theorem
  for k being Element of NAT holds
  for q being data-only FinPartState of S
   holds Relocated((g +* q), k) = Relocated (g,k) +* q
proof
  let k be Element of NAT,
      s be data-only FinPartState of S;
A1: NAT misses Data-Locations S by Th51;
  dom s c= Data-Locations S by Th31;
  then
A2:  dom s misses NAT by A1,XBOOLE_1:63;
A3: dom Reloc(ProgramPart g,k) c= NAT by RELAT_1:def 18;
  thus Relocated((g +* s), k)
     = IncIC(NPP(g +* s),k) +* Reloc(ProgramPart(g +* s),k)
    .= IncIC(NPP(g +* s),k) +* Reloc(ProgramPart g,k) by Th66
    .= IncIC(NPP g +* s,k) +* Reloc(ProgramPart g,k) by Th67
    .= IncIC(NPP g,k) +* s +* Reloc(ProgramPart g,k) by Th60
    .= IncIC(NPP g,k) +* (s +* Reloc(ProgramPart g,k)) by FUNCT_4:15
    .= IncIC(NPP g,k) +* (Reloc(ProgramPart g,k) +* s)
     by A3,A2,FUNCT_4:36,XBOOLE_1:63
    .= IncIC(NPP g,k) +* Reloc(ProgramPart g,k) +* s by FUNCT_4:15
    .= Relocated (g,k) +* s;
end;

begin :: SCMPDS_4

reserve S for IC-Ins-separated definite realistic
  (non empty stored-program COM-Struct over N),
  s,s1,s2 for State of S;

reserve
  i,j,k for Instruction of S,
  I,J,K for Program of S,
  p,q,r for PartState of S;

definition
  let N be set;
  let S be definite (non empty stored-program COM-Struct over N);
  let i be Instruction of S;
  redefine func Load i -> preProgram of S;
  coherence;
end;

reserve k1,k2 for Integer;

canceled 2;

theorem
  for s1,s2 being State of S holds (for l being
  Element of NAT holds s1.l = s2.l) iff s1 | NAT = s2 | NAT
proof
  let s1,s2 be State of S;
A1: (for l being Element of NAT holds s1.l = s2.l) implies
  for l being set st l in NAT holds s1.l = s2.l;
  NAT c= dom s1 & NAT c= dom s2 by Lm4;
  hence thesis by A1,FUNCT_1:165;
end;

canceled 2;

theorem Th130:
 for I being NAT-defined Function holds dom I misses dom Start-At(n,S)
proof let I be NAT-defined Function;
A1: dom Start-At(n,S) misses NAT by Th26;
  dom I c= NAT by RELAT_1:def 18;
 hence thesis by A1,XBOOLE_1:63;
end;

reserve l,l1,loc for Element of NAT;

definition let N;
  let S be  definite (non empty stored-program COM-Struct over N);
  let I be Program of S;
  func stop I -> Program of S equals
  I ^ Stop S;
  coherence;
end;

registration let N,S;
  let s be State of S;
  cluster Initialize s -> total;
  coherence;
end;

reserve i1,i2 for Instruction of S;

canceled 4;

theorem
   0 in dom stop  I
proof
  card stop I = card I + card Stop S by AFINSQ_1:20
    .= card I + 1 by Th46;
  hence thesis by AFINSQ_1:70;
end;

begin :: SCMFSA6A

reserve
  i,j,k for Instruction of S,
  I,J,K for Program of S;

definition
  let N be non empty with_non-empty_elements set;
  let S be definite (non empty stored-program COM-Struct over N);
  let i be Instruction of S;
  func Macro i -> Program of S equals
  ( 0, 1) --> (i,halt S);
  coherence
  proof
    set I = ( 0, 1) --> (i,halt S);
A1: dom I = { 0, 1} by FUNCT_4:65;
A2: I is initial
    proof
      let m,n be Nat such that
A3:   n in dom I and
A4:   m < n;
       n = 0 or n =  1 by A1,A3,TARSKI:def 2;
      then n = (0 qua Nat)+1 by A4;
      then m <= 0 by A4,NAT_1:13;
      then m = 0;
      hence thesis by A1,TARSKI:def 2;
    end;
    thus thesis by A2;
  end;
  correctness;
end;

registration let N,S;
  let i;
  cluster Macro i -> non empty;
  coherence;
end;

canceled;

theorem Th137:
 dom DataPart p misses NAT
proof
  dom DataPart p misses {IC S} \/ NAT by Def23;
 hence thesis by XBOOLE_1:70;
end;

theorem
  for s1,s2 being State of S st NPP s1 = NPP s2 holds
  DataPart s1 = DataPart s2
proof
  let s1,s2 be State of S;
  assume NPP s1 = NPP s2;
  hence DataPart s1 = DataPart NPP s2 by Th73
    .= DataPart s2 by Th73;
end;

theorem Th139:
  for I being NAT-defined Function
  holds not IC S in dom I
  proof let I be NAT-defined Function;
  dom I c= NAT by RELAT_1:def 18;
   hence thesis by Def12;
  end;

begin ::SF_MASTR

theorem Th140:
  dom I misses dom Start-At( n,S)
proof
A1: dom Start-At( n,S) = {IC S} by FUNCOP_1:19;
  assume dom I /\ dom (Start-At( n,S)) <> {};
  then consider x being set such that
A2: x in dom I /\ dom (Start-At( n,S)) by XBOOLE_0:def 1;
  x in dom I & x in dom (Start-At( n,S)) by A2,XBOOLE_0:def 4;
  then dom I c= NAT & IC S in dom I by A1,TARSKI:def 1;
  then reconsider l = IC S as Element of NAT;
  l = IC S;
  hence contradiction by Def12;
end;

theorem Th141:
  IC S in dom (p +* Start-At( n,S))
proof
  dom Start-At( n,S) = {IC S} by FUNCOP_1:19;
  then IC S in dom Start-At( n,S) by TARSKI:def 1;
  hence thesis by FUNCT_4:13;
end;

theorem Th142:
 for n being Nat
 holds IC(p +* Start-At( n,S)) =  n
proof
 let n be Nat;
A1: IC S in dom Start-At( n,S) by Th52;
  (Start-At( n,S)).IC S =  n by FUNCOP_1:87;
  hence thesis by A1,FUNCT_4:14;
end;

theorem
  p +* Start-At( n,S) c= s implies IC s =  n
proof
  assume
A1: p +* Start-At( n,S) c= s;
  IC S in dom (p +* Start-At( n,S)) by Th141;
  hence IC s = IC(p +* Start-At( n,S)) by A1,GRFUNC_1:8
    .=  n by Th142;
end;

begin :: SCMFSA6B

theorem
  (I +* Start-At( n,S))|NAT = I
proof
A1: not IC S in NAT by Def12;
  NAT misses dom Start-At( n,S)
  proof
    assume not thesis;
    then
A2: ex x being set st x in NAT & x in dom Start-At( n,S)
 by XBOOLE_0:3;
    dom Start-At( n,S) = {IC S} by FUNCOP_1:19;
    hence contradiction by A2,A1,TARSKI:def 1;
  end;
  then dom I c= NAT & (I +* Start-At( n,S))|NAT = I | NAT
   by FUNCT_4:76;
  hence thesis by RELAT_1:97;
end;

theorem
  x in dom I implies I.x = (I +* Start-At( n,S)).x
proof
  assume x in dom I;
  then dom Start-At( n,S) = {IC S} & x <> IC S
   by Th139,FUNCOP_1:19;
  then not x in dom Start-At( n,S) by TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

canceled;

theorem Th147:
  x in dom Macro i iff x =  0 or x =  1
proof
  dom Macro i = { 0,  1} by FUNCT_4:65;
  hence thesis by TARSKI:def 2;
end;

theorem
  (Macro i).( 0) = i & (Macro i).( 1) = halt S &
  (Initialize (Macro i)). 0 = i
proof
  thus
A1: (Macro i).( 0) = i by FUNCT_4:66;
  thus
 (Macro i).( 1) = halt S by FUNCT_4:66;
A2:  0 in dom Macro i by Th147;
  dom (Macro i) misses dom (Start-At(0,S)) by Th140;
  then Macro i c= Initialize (Macro i) by FUNCT_4:33;
  hence thesis by A1,A2,GRFUNC_1:8;
end;

begin :: SCMFSA7B

reserve m for Element of NAT;

theorem
  for i being Instruction of S holds dom Macro i = {  0,  1 }
proof
  let i be Instruction of S;
  for x be set holds x in dom Macro i iff x =  0 or x =  1 by Th147;
  hence thesis by TARSKI:def 2;
end;

theorem
  for i being Instruction of S holds card Macro i = 2
proof
  let i be Instruction of S;
  thus card Macro i
    = len <% i,halt S %> by AFINSQ_1:80
    .= 2 by AFINSQ_1:42;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be  definite (non empty stored-program COM-Struct over N);
  cluster Stop S -> non halt-free;
  coherence
   proof
     rng Stop S = {halt S} by AFINSQ_1:36;
    hence halt S in rng Stop S by TARSKI:def 1;
   end;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be definite (non empty stored-program COM-Struct over N);
  cluster non halt-free finite Program of S;
  existence
   proof
    take Stop S;
    thus thesis;
   end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be definite (non empty stored-program COM-Struct over N);
 cluster NAT-defined (the Instructions of S)-valued
     -> (the Object-Kind of S)-compatible Function;
 coherence;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be  definite (non empty stored-program COM-Struct over N);
  let p be PartState of S,
      q be non halt-free
       (NAT-defined (the Instructions of S)-valued Function);
  cluster ProgramPart(p +* q) -> non halt-free;
  coherence
   proof
A1:   halt S in rng q by Def7;
     ProgramPart(p +* q) =  ProgramPart p +* q|NAT by FUNCT_4:75
       .= ProgramPart p +* q by RELAT_1:209;
     then rng q c= rng ProgramPart(p +* q) by FUNCT_4:19;
    hence halt S in rng ProgramPart(p +* q) by A1;
   end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be  definite (non empty stored-program COM-Struct over N);
  let p be (NAT-defined (the Instructions of S)-valued Function),
      q be non halt-free
       (NAT-defined (the Instructions of S)-valued Function);
  cluster p +* q -> non halt-free;
  coherence
   proof
A1:   halt S in rng q by Def7;
     rng q c= rng(p +* q) by FUNCT_4:19;

    hence halt S in rng(p +* q) by A1;
   end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent proper-halt
    (IC-Ins-separated definite  realistic
    (standard-ins non empty stored-program COM-Struct over N));
  let p be finite non halt-free
    (NAT-defined (the Instructions of S)-valued Function),
     k be Element of NAT;
 cluster Reloc(p,k) -> non halt-free;
 coherence
  proof
A1:  dom p c= NAT by RELAT_1:def 18;
    halt S in rng p by Def7;
    then consider x being set such that
A2:  x in dom p and
A3:  p.x = halt S by FUNCT_1:def 5;
A4:  x in dom IncAddr(p,k) by A2,Def40;
A5:  Shift(IncAddr(p,k),k) = IncAddr(Shift(p,k),k) by Th121;
A6:  dom IncAddr(p,k) c= NAT by RELAT_1:def 18;
     reconsider m =x as Element of NAT by A1,A2;
    IncAddr(p,k).m = IncAddr(p/.m,k) by A2,Def40
       .= IncAddr(halt S,k) by A3,A2,PARTFUN1:def 8
       .= halt S by Th92;
    then halt S in rng IncAddr(p,k) by A4,FUNCT_1:12;
   hence halt S in rng Reloc(p,k) by A5,A6,VALUED_1:27;
  end;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be  definite (non empty stored-program COM-Struct over N);
  cluster non halt-free Program of S;
  existence
   proof
    take Stop S;
    thus thesis;
   end;
end;

theorem Th151:
  for N be with_non-empty_elements non empty set
  for S be IC-Ins-separated (non empty COM-Struct over N), l be Nat
  for p be PartState of S
  holds p is l-started iff Start-At(l,S) c= p
proof
 let N be with_non-empty_elements non empty set;
 let S be IC-Ins-separated (non empty COM-Struct over N), l be Nat;
 let p be PartState of S;
A1: dom Start-At(l,S) = {IC S} by FUNCOP_1:19;
 thus p is l-started implies Start-At(l,S) c= p
  proof assume
A2:  p is l-started;
    IC S in dom p by A2,Def16;
    then
A3:  dom Start-At(l,S) c= dom p by A1,ZFMISC_1:37;
    for x st x in dom Start-At(l,S) holds Start-At(l,S).x = p.x
     proof let x;
      assume x in dom Start-At(l,S);
       then
A4:      x = IC S by A1,TARSKI:def 1;
      hence Start-At(l,S).x = IC Start-At(l,S)
         .= l by FUNCOP_1:87
         .= IC p by A2,Def16
         .= p.x by A4;
     end;
   hence Start-At(l,S) c= p by A3,GRFUNC_1:8;
  end;
 assume
A5: Start-At(l,S) c= p;
  then
A6:  dom Start-At(l,S) c= dom p by RELAT_1:25;
A7: IC S in dom Start-At(l,S) by A1,TARSKI:def 1;
 hence IC S in dom p by A6;
 thus IC p = IC Start-At(l,S) by A5,A7,GRFUNC_1:8
     .= l by FUNCOP_1:87;
end;

registration let N,S;
 cluster non program-free FinPartState of S;
 existence
  proof
   take Stop S;
    dom Stop S c= NAT;
    then (Stop S)|NAT = Stop S by RELAT_1:97;
   hence (Stop S)|NAT <> {};
  end;
end;

registration let N,S;
 let p be non program-free PartState of S;
 let f be Function;
  cluster p +* f -> non program-free PartState of S;
  coherence
   proof let P be PartState of S;
    assume P = p +* f;
     then
A1:   P|NAT = p|NAT +* f|NAT by FUNCT_4:75;
     p|NAT <> {} by Def29;
    hence P|NAT <> {} by A1;
   end;
  cluster f +* p -> non program-free PartState of S;
  coherence
   proof let P be PartState of S;
    assume P = f +* p;
     then
A2:   P|NAT = f|NAT +* p|NAT by FUNCT_4:75;
     p|NAT <> {} by Def29;
    hence P|NAT <> {} by A2;
   end;
end;

theorem Th152:
  for p being program-free PartState of S, k being Element of NAT
  holds ProgramPart IncIC(p,k) = {} by Def29;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent  (IC-Ins-separated definite
   realistic
  (standard-ins non empty stored-program COM-Struct over N));
 let p be non program-free FinPartState of S, k be Element of NAT;
 cluster Relocated(p,k) -> non program-free;
 coherence
  proof
    ProgramPart p <> {} by Def29;
    then Reloc(ProgramPart p,k) <> {};
    then
A1:  Reloc(ProgramPart p,k)|NAT <> {} by RELAT_1:209;
    Relocated(p,k)|NAT
     = ProgramPart IncIC(NPP p,k) +* Reloc(ProgramPart p,k)|NAT by FUNCT_4:75
    .= {} +* Reloc(ProgramPart p,k)|NAT by Th152
    .= Reloc(ProgramPart p,k)|NAT by FUNCT_4:21;
   hence Relocated(p,k)|NAT <> {} by A1;
  end;
end;

registration let N,S; let k be Element of NAT;
 let p be k-started PartState of S, d be data-only PartState of S;
 cluster p +* d -> k-started;
 coherence
  proof
A1:    IC S in dom p by Def16;
    dom(p +* d) = dom p \/ dom d by FUNCT_4:def 1;
   hence IC S in dom(p +* d) by A1,XBOOLE_0:def 3;
    not IC S in dom d by Th57;
   hence IC(p +* d) =IC p by FUNCT_4:12
     .= k by Def16;
  end;
end;

theorem Th153:
 for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  for p,q being
   finite NAT-defined (the Instructions of S)-valued Function
    holds IncAddr(p +* q, n) = IncAddr(p,n) +* IncAddr(q,n)
proof
 let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let p,q be
   finite NAT-defined (the Instructions of S)-valued Function;
A1: dom IncAddr(q,n) = dom q by Def40;
A2: now
    let m be Nat such that
A3:  m in dom(p +* q);
    per cases;
    suppose
A4:    m in dom q;
A5:   (p+*q)/.m = (p +* q). m by A3,PARTFUN1:def 8
        .= q. m by A4,FUNCT_4:14
        .= q/.m by A4,PARTFUN1:def 8;
      thus (IncAddr(p,n) +* IncAddr(q,n)). m = IncAddr(q,n). m by A1,A4,
FUNCT_4:14
        .= IncAddr((p+*q)/.m,n) by A4,A5,Def40;
    end;
    suppose
A6:   not  m in dom q;
       m in dom p \/ dom q by A3,FUNCT_4:def 1;
      then
A7:    m in dom p by A6,XBOOLE_0:def 3;
A8:   (p+*q)/.m = (p +* q). m by A3,PARTFUN1:def 8
        .= p. m by A6,FUNCT_4:12
        .= p/.m by A7,PARTFUN1:def 8;
      thus (IncAddr(p,n) +* IncAddr(q,n)). m = IncAddr(p,n). m by A1,A6,
FUNCT_4:12
        .= IncAddr((p+*q)/.m,n) by A7,A8,Def40;
    end;
  end;
  dom IncAddr(p,n) = dom p by Def40;
  then dom(IncAddr(p,n) +* IncAddr(q,n)) = dom p \/ dom q by A1,FUNCT_4:def 1
    .= dom(p +* q) by FUNCT_4:def 1;
  hence IncAddr(p +* q, n) = IncAddr(p,n) +* IncAddr(q,n)
   by A2,Def40;
end;

theorem
 for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
 for p,q being finite NAT-defined (the Instructions of S)-valued Function,
     k be Element of NAT
  holds Reloc(p+*q,k) = Reloc(p,k)+*Reloc(q,k)
proof
 let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
 let p,q be finite NAT-defined (the Instructions of S)-valued Function,
     k be Element of NAT;
 thus Reloc(p+*q,k)
      = IncAddr(Shift(p,k) +* Shift(q,k),k) by VALUED_1:24
     .= Reloc(p,k)+*Reloc(q,k) by Th153;
end;

theorem
 for S being regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
 for p being finite NAT-defined (the Instructions of S)-valued Function,
     m,n be Element of NAT
 holds Reloc(Reloc(p,m), n) = Reloc(p, m + n)
proof
 let S being regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
 let p being finite NAT-defined (the Instructions of S)-valued Function,
     m,n be Element of NAT;
  thus Reloc(Reloc(p,m), n) = Reloc(Reloc(p,m),n)
    .= Reloc(Reloc(p,m),n)
    .= IncAddr(Shift(IncAddr(Shift(p,m),m),n),n)
    .= IncAddr(IncAddr(Shift(Shift(p,m),n),m),n) by Th121
    .= IncAddr(IncAddr(Shift(p,m+n),m),n) by VALUED_1:22
    .= Reloc(p,m+n) by Th99
    .= Reloc(p, m + n);
end;

theorem
 for S being regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  for P,Q being NAT-defined (the Instructions of S)-valued finite Function,
   k being Element of NAT st
  P c= Q holds Reloc(P,k) c= Reloc(Q,k)
proof
 let S be regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let P,Q be NAT-defined (the Instructions of S)-valued finite Function;
  let k be Element of NAT;
  set rP = Reloc(P,k);
  set rQ = Reloc(Q,k);
A1: dom Reloc(P,k) = {m + k: m in dom P} by Th117;
A2: dom Shift(P,k) = {m + k: m in dom P} by VALUED_1:def 12;
A3: dom Shift(Q,k) = {m + k: m in dom Q} by VALUED_1:def 12;
  assume P c= Q;
  then
A4: P c= Q;
  then
A5: Shift(P,k) c= Shift(Q,k) by VALUED_1:21;
A6: dom P c= dom Q by A4,GRFUNC_1:8;
A7: now
    let x be set;
    assume x in dom Reloc(P,k);
    then consider m1 being Element of NAT such that
A8: x = m1 + k and
A9: m1 in dom P by A1;
A10:  (m1 + k) in dom Shift(Q,k) by A6,A3,A9;
A11:  (m1 + k) in dom Shift(P,k) by A2,A9;
    then
A12: Shift(P,k)/.(m1+k) = Shift(P,k). (
    m1 + k) by PARTFUN1:def 8
      .= Shift(Q,k). (m1 + k) by A5,A11,GRFUNC_1:8
      .= Shift(Q,k)/.(m1+k) by A10,PARTFUN1:def 8;
    thus (rP).x = Reloc(P,k). (m1 + k) by A8
      .= IncAddr(Shift(Q,k)/.(m1+k),k) by A11,A12,Def40
      .= Reloc(Q,k).(m1 + k) by A10,Def40
      .= (rQ).x by A8;
  end;
A13: dom Shift(P,k) c= dom Shift(Q,k) by A5,GRFUNC_1:8;
  now
    let x be set;
    assume x in dom rP;
    then x in dom Shift(P,k) by Def40;
    then x in dom Shift(Q,k) by A13;
    hence x in dom rQ by Def40;
  end;
  then dom rP c= dom rQ by TARSKI:def 3;
  hence thesis by A7,GRFUNC_1:8;
end;

theorem
 for S being regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  for P being preProgram of S holds Reloc(P,0) = P
proof
 let S be regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let P be preProgram of S;
  now
    let x be set;
    hereby
      assume
A1:   x in dom P;
      dom P c= NAT by RELAT_1:def 18;
      then reconsider l = x as Element of NAT by A1;
      reconsider n = l as Element of NAT;
      l =  n;
      hence x in {m: m in dom P} by A1;
    end;
    assume x in {m: m in dom P};
    then ex m being Element of NAT st x = m & m in dom P;
    hence x in dom P;
  end;
  then
A2: dom P = {m: m in dom P} by TARSKI:2;
  now
    let x be set;
A3: dom Reloc(P,0) = {m + (0 qua Nat): m in dom P} by Th117;
    hereby
      assume x in dom Reloc(P,0);
      then ex n be Element of NAT st x = n + (0 qua Nat) & n in dom P by A3;
      hence x in { m: m in dom P};
    end;
    assume x in {m: m in dom P};
    then consider m being Element of NAT such that
A4: x = m and
A5: m in dom P;
    x = m + (0 qua Nat) by A4;
    hence x in dom Reloc(P,0) by A3,A5;
  end;
  then
A6: dom Reloc(P,0) = {m:m in dom P} by TARSKI:2;
  now
    let x be set;
    assume x in {m:m in dom P};
    then consider n being Element of NAT such that
A7: x = n and
A8: n in dom P;
A9:  n in dom P by A8;
    dom Shift(P,0) = {m + (0 qua Nat): m in dom P} by VALUED_1:def 12;
    then
A10:  n + (0 qua Nat) in dom Shift(P,0) by A8;
    then
A11: Shift(P,0)/.(n+(0 qua Nat)) = Shift(P,0). (n + (0 qua Nat))
          by PARTFUN1:def 8
      .= (P). n by A9,VALUED_1:def 12
      .= P. n;
    then consider i being Instruction of S such that
A12: i = P. n;
    thus (Reloc(P,0)).x = Reloc(P,0).(n + (0 qua Nat)) by A7
      .= IncAddr(i,0) by A10,A11,A12,Def40
      .= P.x by A7,A12,Th91;
  end;
  hence thesis by A2,A6,FUNCT_1:9;
end;

theorem
 for S being regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  for k being Element of NAT holds
    for P being preProgram of S holds
    il in dom P iff il + k in dom Reloc(P,k)
proof
 let S be regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let k be Element of NAT;
  let P be preProgram of S;
  A1: dom Reloc(P,k) = { j+k where j is Element of NAT: j in dom P } by Th117;
  hence il in dom P implies il + k in dom Reloc(P,k);
  assume il + k in dom Reloc(P,k);
  then ex j being Element of NAT st il + k = j+k & j in dom P by A1;
  hence thesis;
end;

theorem
 for S being regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  for i being Element of NAT,
      p being finite NAT-defined (the Instructions of S)-valued Function
    holds Shift(IncAddr(p,i),i) = Reloc(p,i) by Th121;

theorem Th160:
 for N being set, S being non empty stored-program COM-Struct over N
 holds the carrier of S = {IC S} \/ Data-Locations S \/ NAT
proof
 let N be set, S be non empty stored-program COM-Struct over N;
  NAT c= the carrier of S by Def2;
  then {IC S} \/ NAT c= the carrier of S by XBOOLE_1:8;
 hence the carrier of S
    = Data-Locations S \/ ({IC S} \/ NAT) by XBOOLE_1:45
   .= {IC S} \/ Data-Locations S \/ NAT by XBOOLE_1:4;
end;

Lm168:
  for p,q being PartState of S holds DataPart p misses ProgramPart q
proof
 let p,q be PartState of S;
  dom DataPart p misses dom ProgramPart q by Th15;
 hence thesis by RELAT_1:214;
end;

Lm169:
  for p being PartState of S holds DataPart p c= NPP p
proof let p be PartState of S;
A1: DataPart p c= p by RELAT_1:88;
  DataPart p misses ProgramPart p by Lm168;
 hence thesis by A1,XBOOLE_1:86;
end;

LmXX:
  for S being regular homogeneous J/A-independent
   (IC-Ins-separated definite realistic
  (standard-ins non empty stored-program COM-Struct over N))
 for k being Element of NAT, p being FinPartState of S
  st IC S in dom p
 holds NPP Relocated(p,k) = IncIC(NPP p,k)
proof
  let S being regular homogeneous J/A-independent
   (IC-Ins-separated definite realistic
  (standard-ins non empty stored-program COM-Struct over N));
 let k being Element of NAT, p being FinPartState of S such that
Z: IC S in dom p;
A: dom Start-At (IC p,S) = {IC S} by FUNCOP_1:19
    .= dom Start-At(IC p +k,S) by FUNCOP_1:19;
  IC S in dom Relocated(p,k) by Th119;
 hence NPP Relocated(p,k)
    = DataPart Relocated(p,k) +* Start-At (IC Relocated(p,k),S) by Th74
   .= DataPart p +* Start-At (IC Relocated(p,k),S) by Th115
   .= DataPart p +* Start-At (IC p +k,S) by Z,Th120
   .= DataPart p +* Start-At (IC p,S) +* Start-At(IC p +k,S) by A,FUNCT_4:78
   .= NPP p +* Start-At(IC p +k,S) by Z,Th74
   .= NPP p +* Start-At(IC NPP p +k,S) by Z,Th72
   .= IncIC(NPP p,k);
 end;

Lm179:
 for S being IC-Ins-separated definite realistic (non empty
 stored-program COM-Struct over N)
 for p being PartState of S st IC S in dom p
 holds IC S in dom NPP p
proof
 let S be IC-Ins-separated definite realistic (non empty
 stored-program COM-Struct over N);
 let p be PartState of S;
 assume IC S in dom p;
  then
A1: dom NPP p = {IC S} \/ dom DataPart p by Th70;
  IC S in {IC S} by TARSKI:def 1;
 hence IC S in dom NPP p by A1,XBOOLE_0:def 3;
end;

theorem
 for S being regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  for k being Element of NAT, p being FinPartState of S ,
      s1, s2 being State of S st p c= s1 & Relocated (p,k) c= s2
   holds p c= s1 +* DataPart s2
proof
 let S be regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let k be Element of NAT, p be  FinPartState of S , s1, s2 be
  State of S such that
A1: p c= s1 and
A2: Relocated (p,k) c= s2;
  set s3 = DataPart s2;
  reconsider s = s1 +* DataPart s2 as State of S;
A3:  dom p c= the carrier of S by RELAT_1:def 18;
  then
A4: dom p c= {IC S} \/ Data-Locations S \/ NAT by Th160;
A5: now
    Data-Locations S = dom s2 /\ Data-Locations S
       by Th49,XBOOLE_1:28;
    then
A6: dom s3 = Data-Locations S by RELAT_1:90;
    let x be set such that
A7: x in dom p;
A8: x in {IC S} \/ Data-Locations S or x in NAT by A4,A7,XBOOLE_0:def 3;
    per cases by A8,XBOOLE_0:def 3;
    suppose
A9:   x in {IC S};
A10:   not IC S in Data-Locations S by Th56;
      x = IC S by A9,TARSKI:def 1;
      then s1.x = s.x by A6,A10,FUNCT_4:12;
      hence p.x = s.x by A1,A7,GRFUNC_1:8;
    end;
    suppose
A11:  x in Data-Locations S;
      set DPp = DataPart p;
      x in dom p /\ Data-Locations S by A7,A11,XBOOLE_0:def 4;
      then
A12:  x in dom DPp by RELAT_1:90;
      DPp = DataPart Relocated (p, k) by Th115;
      then DPp c= Relocated (p, k) by RELAT_1:88;
      then
A13:  DPp c= s2 by A2,XBOOLE_1:1;
      then dom DPp c= dom s2 by GRFUNC_1:8;
      then x in dom s2 /\ Data-Locations S by A11,A12,XBOOLE_0:def 4;
      then
A14:  x in dom s3 by RELAT_1:90;
      DPp c= p by RELAT_1:88;
      then
A15:  DPp.x = p.x by A12,GRFUNC_1:8;
A16:  s2.x = s3.x by A11,FUNCT_1:72;
      DPp.x = s2.x by A12,A13,GRFUNC_1:8;
      hence p.x = s.x by A15,A16,A14,FUNCT_4:14;
    end;
    suppose
A17:  x in NAT;
      dom DataPart s2 misses NAT by Th137;
      then not x in dom s3 by A17,XBOOLE_0:3;
      then s1.x = s.x by FUNCT_4:12;
      hence p.x = s.x by A1,A7,GRFUNC_1:8;
    end;
  end;
  dom p c= dom s by A3,PARTFUN1:def 4;
  hence thesis by A5,GRFUNC_1:8;
end;

theorem
 for p being PartState of S, i,j being Nat
 holds IncIC(IncIC(p,i),j) = IncIC(p,i+j)
 proof let p be PartState of S, i,j being Nat;
  thus IncIC(IncIC(p,i),j)
        = p +* Start-At(IC p+i,S) +* Start-At(IC p + i +j,S) by Th54
       .= IncIC(p,i+j) by FUNCT_4:122;
 end;

theorem
 for p being PartState of S, j,k being Nat
 holds IncIC(p +* Start-At(j,S),k) = p +* Start-At(j+k,S)
proof
 let p be PartState of S, j,k be Nat;
 thus IncIC(p +* Start-At(j,S),k)
   = p +* Start-At(j,S) +* Start-At(IC( p +* Start-At(j,S))+k,S)
  .= p +* Start-At(IC(p +* Start-At(j,S))+k,S) by FUNCT_4:122
  .= p +* Start-At(j+k,S) by Th142;
end;

theorem Th164:
  Start-At(IC s,S) c= s
 proof
   Start-At(IC s,S) = s | {IC S} by Th10;
  hence thesis by RELAT_1:88;
 end;

theorem
 for s being State of S
  holds s +* Start-At(IC s,S) = s
proof
 let s be State of S;
  Start-At(IC s,S) c= s by Th164;
 hence s +* Start-At(IC s,S) = s by FUNCT_4:103,104;
end;

theorem
 for k being Nat
 holds IC IncIC(s,k) -' k = IC s
proof
 let k be Nat;
 thus IC IncIC(s,k) -' k = IC s + k -' k by Th54
    .= IC s by NAT_D:34;
end;

theorem
  for N be with_non-empty_elements non empty set
  for S be regular J/A-independent homogeneous proper-halt
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  for i being Instruction of S
  for f being Function of the Instructions of S, the Instructions of S
   st f = (id the Instructions of S) +* (halt S .--> i)
  for s being finite NAT-defined (the Instructions of S)-valued Function
  holds IncAddr(f*s,n)
   = ((id the Instructions of S) +* (halt S .--> IncAddr(i,n)))* IncAddr(s,n)
proof
  let N be with_non-empty_elements non empty set;
  let S be regular J/A-independent homogeneous proper-halt
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
A1: dom(id the Instructions of S) = the Instructions of S by RELAT_1:71;
  let i be Instruction of S;
  let f be Function of the Instructions of S, the Instructions of
  S such that
A2: f = (id the Instructions of S) +* (halt S .--> i);
  let s be finite NAT-defined (the Instructions of S)-valued Function;
  rng(halt S .--> IncAddr(i,n)) = {IncAddr(i,n)} by FUNCOP_1:14;
  then
A3: rng((id the Instructions of S) +* (halt S .--> IncAddr(i,n))
  ) c= rng(id the Instructions of S) \/ {IncAddr(i,n)} by FUNCT_4:18;
  rng(id the Instructions of S) = the Instructions of S by RELAT_1:71;
  then
A4: rng(id the Instructions of S) \/ {IncAddr(i,n)} = the Instructions
  of S by ZFMISC_1:46;
A5: dom(halt S .--> IncAddr(i,n)) = {halt S} by FUNCOP_1:19;
  then
  dom((id the Instructions of S) +* (halt S .--> IncAddr(i,n))
  ) = dom(id the Instructions of S) \/ {halt S} by FUNCT_4:def 1
    .= the Instructions of S by A1,ZFMISC_1:46;
  then reconsider g = (id the Instructions of S) +* (halt S .-->
  IncAddr(i,n)) as Function of the Instructions of S,the Instructions of
  S by A3,A4,RELSET_1:11;
A6: dom IncAddr(s,n) = dom s by Def40
    .= dom(f*s) by FUNCT_2:200;
A7: dom(halt S .--> i) = {halt S} by FUNCOP_1:19;
A8: now
    let m be Nat;
    assume
A9:  m in dom(f*s);
    then
A10:  m in dom s by FUNCT_2:200;
    per cases;
    suppose
A11:  s. m = halt S;
     reconsider mm = m as Element of NAT by ORDINAL1:def 13;
A12:  IncAddr(s,n). m = IncAddr(s/.mm,n) by A10,Def40
        .= IncAddr(halt S,n) by A10,A11,PARTFUN1:def 8
        .= halt S by Th92;
A13:  halt S in {halt S} by TARSKI:def 1;
A14:  (f*s)/.m = (f*s). m by A9,PARTFUN1:def 8
        .= f.halt S by A10,A11,FUNCT_1:23
        .= (halt S .--> i).halt S by A2,A7,A13,FUNCT_4:14
        .= i by FUNCOP_1:87;
      thus (g*IncAddr(s,n)). m = g.(IncAddr(s,n). m) by A6,A9,FUNCT_1:23
        .= (halt S .--> IncAddr(i,n)).(IncAddr(s,n). m) by A5,A12,A13,
FUNCT_4:14
        .= IncAddr((f*s)/.m,n) by A12,A14,FUNCOP_1:87;
    end;
    suppose
A15:  s. m <> halt S;
A16:  s/.m = s. m by A10,PARTFUN1:def 8;
A17:    now assume IncAddr(s/.m,n) = halt S;
        then s/.m = halt S by Th96;
       hence contradiction by A15,A16;
      end;
A18:  not s/.m in {halt S} by A15,A16,TARSKI:def 1;
A19:  not IncAddr(s/.m,n) in {halt S} by A17,TARSKI:def 1;
A20:  (f*s)/.m = (f*s). m by A9,PARTFUN1:def 8
        .= f.(s. m) by A10,FUNCT_1:23
        .= (id the Instructions of S).(s/.m) by A2,A7,A16,A18,FUNCT_4:12
        .= s/.m by FUNCT_1:35;
      thus (g*IncAddr(s,n)). m = g.(IncAddr(s,n). m) by A6,A9,FUNCT_1:23
        .= g.IncAddr(s/.m,n) by A10,Def40
        .= (id the Instructions of S).IncAddr(s/.m,n) by A5,A19,FUNCT_4:12
        .= IncAddr((f*s)/.m,n) by A20,FUNCT_1:35;
    end;
  end;
  dom(g*IncAddr(s,n)) = dom IncAddr(s,n) by FUNCT_2:200;
  hence thesis by A6,A8,Def40;
end;

theorem Th168:
  for p,q being PartState of S holds DataPart p misses ProgramPart q
proof
 let p,q be PartState of S;
  dom DataPart p misses dom ProgramPart q by Th15;
 hence thesis by RELAT_1:214;
end;

theorem Th169:
  for p being PartState of S holds DataPart p c= NPP p
proof let p be PartState of S;
A1: DataPart p c= p by RELAT_1:88;
  DataPart p misses ProgramPart p by Th168;
 hence thesis by A1,XBOOLE_1:86;
end;

theorem Th170:
 p c= q implies NPP p c= NPP q
proof
  NPP p = p|((the carrier of S)\NAT) &  NPP q = q|((the carrier of S)\NAT)
   by Th65;
 hence thesis by RELAT_1:105;
end;

theorem Th171:
 dom NPP p c= {IC S} \/ dom DataPart p
proof
 set S0 = Start-At(0,S);
 per cases;
 suppose IC S in dom p;
  hence thesis by Th70;
 end;
 suppose
A1: not IC S in dom p;
A2: dom S0 = {IC S} by FUNCOP_1:19;
   IC S in dom(p +* S0) by Th141;
   then
A3:  dom NPP(p +* S0)
     = {IC S} \/ dom DataPart(p +* S0) by Th70
    .= {IC S} \/ dom(DataPart p +* DataPart S0) by FUNCT_4:75
    .= {IC S} \/ dom(DataPart p +* {}) by Th30
    .= {IC S} \/ dom DataPart p by FUNCT_4:22;
  now assume dom p meets dom S0;
   then consider x such that
A4: x in dom p and
A5: x in dom S0 by XBOOLE_0:3;
    x = IC S by A2,A5,TARSKI:def 1;
   hence contradiction by A4,A1;
  end;
  then p c= p +* S0 by FUNCT_4:33;
  then NPP p c= NPP(p +* S0) by Th170;
  then dom NPP p c= dom NPP(p +* S0) by RELAT_1:25;
 hence dom NPP p c= {IC S} \/ dom DataPart p by A3;
 end;
end;

theorem
 dom s = {IC S} \/ Data-Locations S \/ NAT
proof
 dom s = the carrier of S by PARTFUN1:def 4;
 hence thesis by Th160;
end;

reserve S for regular J/A-independent homogeneous
   (standard-ins IC-Ins-separated definite realistic
  (non empty stored-program COM-Struct over N));
reserve I,J for Program of S,
  p for PartState of S;

theorem
  dom I misses dom Reloc(ProgramPart J, card I)
proof
  assume
A1: dom I meets dom Reloc(ProgramPart J, card I);
  dom Reloc(ProgramPart J, card I)
     = dom Reloc(J,card I) by RELAT_1:209
    .= dom Shift(J,card I) by Def40
    .= { l+card I: l in dom J } by VALUED_1:def 12;
  then consider x being set such that
A2: x in dom I and
A3: x in { l+card I: l in dom J } by A1,XBOOLE_0:3;
  consider l such that
A4: x = l+card I and
  l in dom J by A3;
  l+card I < card I by A2,A4,AFINSQ_1:70;
  hence contradiction by NAT_1:11;
end;

theorem
 for I being preProgram of S
  holds card Reloc(ProgramPart I, m) = card I
proof let I be preProgram of S;
  deffunc U(Element of NAT) = $1;
  set B = { l : U(l) in dom I};
A1: for x being set st x in dom I ex d being Element of NAT st x = U(d)
  proof
    let x be set;
    assume
A2: x in dom I;
    dom I c= NAT by RELAT_1:def 18;
    then reconsider l = x as Element of NAT by A2;
    reconsider d = l as Element of NAT;
    l = U(d);
    hence thesis;
  end;
A3: for d1,d2 being Element of NAT st U(d1) = U(d2) holds d1 = d2;
A4: dom I,B are_equipotent from FUNCT_7:sch 3(A1,A3);
  defpred Z[Element of NAT] means $1 in dom I;
  deffunc V(Element of NAT) = $1+m;
  defpred X[Element of NAT] means U($1) in dom I;
  set D = { l : X[l]};
  set C = { V(l): l in B };
  defpred X[set] means not contradiction;
  D is Subset of NAT from DOMAIN_1:sch 7;
  then
A5: B c= NAT;
A6: for d1,d2 be Element of NAT st V(d1) = V(d2) holds d1 = d2;
A7: B,C are_equipotent from FUNCT_7:sch 4(A5,A6);
  set C = { V(l): l in { n : Z[n]} & X[l] }, A = { V(l): Z[l] & X[l] };
A8: C = { l+m: l in B }
  proof
    thus C c= { l+m: l in B }
    proof
      let e be set;
      assume e in C;
      then ex l st e = V(l) & l in B;
      hence thesis;
    end;
    let e be set;
    assume e in { l+m: l in B };
    then ex l st e = l+m & l in B;
    hence thesis;
  end;
  A = { l+m: l in dom I }
  proof
    thus A c= { l+m: l in dom I }
    proof
      let e be set;
      assume e in A;
      then ex l st e = V(l) & l in dom I;
      hence thesis;
    end;
    let e be set;
    assume e in { l+m: l in dom I };
    then ex l st e = l+m & l in dom I;
    hence thesis;
  end;
  then
A9: dom Shift(I,m) = A by VALUED_1:def 12;
  C = A from FRAENKEL:sch 14;
  then
A10: dom Shift(I,m),dom I are_equipotent by A4,A7,A8,A9,WELLORD2:22;
  thus card Reloc(ProgramPart I, m)
     = card Reloc(I,m) by RELAT_1:209
    .= card dom Reloc(I,m) by CARD_1:104
    .= card dom Shift(I,m) by Def40
    .= card dom I by A10,CARD_1:21
    .= card I by CARD_1:104;
end;

LmAA:
 for S being IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N)
 for s be State of S holds
  NPP s = s|(Data-Locations S \/ {IC S})
proof
 let S be IC-Ins-separated definite realistic
  (stored-program non empty COM-Struct over N);
 let s be State of S;
 thus NPP s = s|dom NPP s by GRFUNC_1:64
     .= s|({IC S} \/ dom DataPart s) by Th71
     .= s|(Data-Locations S \/ {IC S}) by Th50;
end;

theorem
 for S being IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N)
 for s1,s2 be State of S holds
  NPP s1 = NPP s2 iff
   s1|(Data-Locations S \/ {IC S}) = s2|(Data-Locations S \/ {IC S})
proof
 let S be IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N);
 let s1,s2 be State of S;
A: NPP s1 = s1|(Data-Locations S \/ {IC S}) by LmAA;
  NPP s2 = s2|(Data-Locations S \/ {IC S}) by LmAA;
 hence thesis by A;
end;

theorem
 for S being non empty COM-Struct over N,
  p being data-only PartState of S
  holds NPP p = p
proof
 let S be non empty COM-Struct over N,
  p be data-only PartState of S;
A1: dom p misses NAT by Th40;
  dom p c= the carrier of S by RELAT_1:def 18;
  then
A2: dom p c= (the carrier of S)\NAT by A1,XBOOLE_1:86;
 thus NPP p = p|((the carrier of S)\NAT) by Th65
   .= p by A2,RELAT_1:97;
end;

canceled 2;

theorem Th179:
 for S being IC-Ins-separated definite realistic (non empty
 stored-program COM-Struct over N)
 for p being PartState of S st IC S in dom p
 holds IC S in dom NPP p
proof
 let S be IC-Ins-separated definite realistic (non empty
 stored-program COM-Struct over N);
 let p be PartState of S;
 assume IC S in dom p;
  then
A1: dom NPP p = {IC S} \/ dom DataPart p by Th70;
  IC S in {IC S} by TARSKI:def 1;
 hence IC S in dom NPP p by A1,XBOOLE_0:def 3;
end;

theorem
 for S being regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
 for p being FinPartState of S
  for k being Element of NAT holds
  NPP(Relocated(p,k)) = IncIC(NPP p,k)
proof
 let S be regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let p be FinPartState of S;
  let k be Element of NAT;
A1: NAT misses ((the carrier of S)\NAT) by XBOOLE_1:79;
A2:  Reloc(ProgramPart p,k)|((the carrier of S)\NAT)
     = Reloc(ProgramPart p,k)|NAT|((the carrier of S)\NAT) by RELAT_1:209
    .= {} by A1,RELAT_1:207;
A3: dom IncIC(NPP p,k) c= the carrier of S by RELAT_1:def 18;
A4: (the carrier of S)\NAT misses NAT by XBOOLE_1:79;
  dom NPP p = dom(p|((the carrier of S)\NAT)) by Th65
      .= dom p /\ ((the carrier of S)\NAT) by RELAT_1:90;
  then
A5: dom NPP p misses NAT by A4,XBOOLE_1:74;
A6: dom Start-At(IC NPP p+k,S) misses NAT by Th26;
   dom IncIC(NPP p,k) = dom NPP p \/ dom Start-At(IC NPP p+k,S)
        by FUNCT_4:def 1;
   then dom IncIC(NPP p,k) misses NAT by A5,A6,XBOOLE_1:70;
   then
A7: dom IncIC(NPP p,k) c= ((the carrier of S)\NAT) by A3,XBOOLE_1:86;
  thus NPP(Relocated(p,k))
       = NPP(IncIC(NPP p,k) +* Reloc(ProgramPart p,k))
      .= (IncIC(NPP p,k) +* Reloc(ProgramPart p,k))|
           ((the carrier of S)\NAT) by Th65
      .= IncIC(NPP p,k)|((the carrier of S)\NAT) +*
         {} by A2,FUNCT_4:75
      .= IncIC(NPP p,k)|((the carrier of S)\NAT) by FUNCT_4:22
      .= IncIC(NPP p,k) by A7,RELAT_1:97;
end;

theorem
 IC S in dom p implies NPP p = Start-At(IC p,S) +* DataPart p
proof assume
A1: IC S in dom p;
A2: dom DataPart p misses dom ProgramPart p by Th15;
A3: dom Start-At(IC p,S) misses dom ProgramPart p by Th130;
   dom(Start-At(IC p,S) +* DataPart p)
     = dom Start-At(IC p,S) \/ dom DataPart p by FUNCT_4:def 1;
   then
A4: dom(Start-At(IC p,S) +* DataPart p) misses dom ProgramPart p
    by A2,A3,XBOOLE_1:70;
  p = Start-At(IC p,S) +* ProgramPart p +* DataPart p by A1,Th18
   .=  Start-At(IC p,S) +* DataPart p +* ProgramPart p
           by A2,FUNCT_4:126;
 hence NPP p
   = (Start-At(IC p,S) +* DataPart p +* ProgramPart p) \ ProgramPart p
  .= Start-At(IC p,S) +* DataPart p by A4,FUNCT_4:127;
end;

theorem
 dom NPP p /\ Data-Locations S = dom DataPart p
proof
A1:  dom NPP p c= {IC S} \/ dom DataPart p by Th171;
   not IC S in Data-Locations S by Th56;
   then
A2: {IC S} misses Data-Locations S by ZFMISC_1:56;
A3: ({IC S} \/ dom DataPart p) /\ Data-Locations S
   = {IC S} /\ Data-Locations S \/
    dom DataPart p /\ Data-Locations S by XBOOLE_1:23
  .= {} \/
    dom DataPart p /\ Data-Locations S by A2,XBOOLE_0:def 7
  .= dom DataPart p /\ Data-Locations S
  .= dom((DataPart p)| Data-Locations S) by RELAT_1:90
  .= dom DataPart p by RELAT_1:101;
   DataPart p c= NPP p by Th169;
   then
A4: dom DataPart p c= dom NPP p by RELAT_1:25;
 thus dom NPP p /\ Data-Locations S
   = dom NPP p /\ ({IC S} \/ dom DataPart p) /\ Data-Locations S
           by A1,XBOOLE_1:28
  .= dom NPP p /\ (({IC S} \/ dom DataPart p) /\ Data-Locations S)
                  by XBOOLE_1:16
  .= dom NPP p /\ dom DataPart p by A3
  .= dom DataPart p by A4,XBOOLE_1:28;
end;

canceled;

theorem Th184:
 for S being IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N)
 for p being PartState of S
  holds p = ProgramPart p +* NPP p
proof
 let S being IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N);
 let p being PartState of S;
A1: dom NPP p c= {IC S} \/ dom DataPart p by Th171;
A2: not IC S in NAT by Def12;
 dom ProgramPart p c= NAT by RELAT_1:def 18;
 then not IC S in dom ProgramPart p by A2;
 then
A3: dom ProgramPart p misses {IC S} by ZFMISC_1:56;
 dom ProgramPart p misses dom DataPart p by Th15;
 then dom ProgramPart p misses {IC S} \/ dom DataPart p by A3,XBOOLE_1:70;
 then
A4: dom ProgramPart p misses dom NPP p by A1,XBOOLE_1:63;
  ProgramPart p c= p by RELAT_1:88;
 hence p = p \/ ProgramPart p by XBOOLE_1:12
    .= ProgramPart p \/ NPP p by XBOOLE_1:39
   .= ProgramPart p +* NPP p by A4,FUNCT_4:32;
end;

theorem
for s being State of S
 holds Data-Locations S c= dom NPP s
proof let s be State of S;
A1: Data-Locations S = dom DataPart s by Th50;
  DataPart s c= NPP s by Th169;
  then dom DataPart s c= dom NPP s by RELAT_1:25;
 hence Data-Locations S c= dom NPP s by A1;
end;

reserve S for IC-Ins-separated definite realistic
  (non empty stored-program COM-Struct over N),
  s for State of S,
  p for PartState of S;

definition
  let N,S;
  let p be PartState of S, k be Nat;
  func DecIC(p,k) -> PartState of S equals

  p +* Start-At(IC p-'k,S);
  correctness;
end;

registration
  let N,S;
  let p be FinPartState of S, k be Nat;
  cluster DecIC(p,k) -> finite;
  coherence;
end;

theorem
  for p being FinPartState of S, k being Element of NAT
  holds DataPart DecIC(p,k) = DataPart p
proof
  let p be FinPartState of S, k be Element of NAT;
  thus DataPart DecIC(p,k)
  = DataPart p +* DataPart Start-At(IC p-'k,S) by FUNCT_4:75
    .= DataPart p +* {} by Th30
    .= DataPart p by FUNCT_4:22;
end;

theorem Th187:
 for k being Nat holds IC S in dom DecIC(p,k)
proof let k be Nat;
A1: dom DecIC(p,k) = dom p \/ dom Start-At(IC p-'k,S) by FUNCT_4:def 1;
  IC S in dom Start-At(IC p-'k,S) by Th52;
  hence thesis by A1,XBOOLE_0:def 3;
end;

theorem Th188:
  for p being PartState of S, k being Nat
   holds IC DecIC (p,k) = IC p -' k
proof
  let p be PartState of S, k be Nat;
   dom Start-At(IC p-'k,S) = {IC S} by FUNCOP_1:19;
   then IC S in dom Start-At(IC p-'k,S) by TARSKI:def 1;
  hence IC DecIC (p,k) = (Start-At((IC p)-'k,S)).IC S by FUNCT_4:14
    .= IC p -' k by FUNCOP_1:87;
end;

theorem
  for p being PartState of S,
   d being data-only FinPartState of S, k being Nat
  holds DecIC(p+*d,k) = DecIC(p,k) +* d
proof let p be PartState of S;
  let d be data-only FinPartState of S, k being Nat;
A1: d tolerates Start-At(IC p-'k,S) by Th59;
  thus DecIC(p+*d,k) = p +* d +* Start-At((IC(p+*d))-'k,S)
    .= p +* d +* Start-At((IC p)-'k,S) by Th58
    .= p +* (d +* Start-At(IC p-'k,S)) by FUNCT_4:15
    .= p +* (Start-At(IC p-'k,S) +* d) by A1,FUNCT_4:35
    .= DecIC(p,k) +* d by FUNCT_4:15;
end;

theorem
  for d being data-only PartState of S, k being Nat
  holds ProgramPart DecIC(d,k) = {}
proof
  let d be data-only PartState of S, k being Nat;
A1: dom DecIC(d,k) = dom d \/ dom Start-At(IC d-'k,S) by FUNCT_4:def 1;
A2: dom d c= Data-Locations S by Th31;
  NAT misses Data-Locations S by Th51;
  then
A3: dom d misses NAT by A2,XBOOLE_1:63;
  dom Start-At(IC d-'k,S) misses NAT by Th26;
  then dom DecIC(d,k) misses NAT by A1,A3,XBOOLE_1:70;
  hence thesis by RELAT_1:95;
end;

theorem
  for p being FinPartState of S,k being Element of NAT holds
  Start-At(IC p-'k,S) c= DecIC (p,k)
proof
  let p be FinPartState of S, k be Element of NAT;
A1: IC DecIC(p,k) = IC p -' k by Th188;
A2: IC S in dom (DecIC(p,k)) by Th187;
A3: Start-At(IC p-'k,S) = {[IC S,IC p -' k]} & [IC S,IC p -' k] in
  DecIC(p,k) by A2,A1,FUNCT_1:def 4,FUNCT_4:87;
  for x being set st x in Start-At(IC p-'k,S)
    holds x in DecIC (p,k) by A3,TARSKI:def 1;
 hence thesis by TARSKI:def 3;
end;

registration
  let N,S;
  let p be program-free PartState of S, k be Element of NAT;
  cluster DecIC(p,k) -> program-free;
  coherence
   proof
A1:  p|NAT = {} by Def29;
    thus DecIC(p,k)|NAT = (p +* Start-At(IC p-'k,S))|NAT
      .= p|NAT +* ProgramPart Start-At(IC p-'k,S) by FUNCT_4:75
      .= {} +* {} by A1,Th27
      .= {};
   end;
end;

theorem
 for p being PartState of S, k being Nat st IC S in dom p
  holds DecIC(NPP p,k) = DataPart p +* Start-At ((IC p) -'k,S)
 proof let p be PartState of S, k being Nat;
A1: dom Start-At ((IC p) -'k,S) = {IC S} by FUNCOP_1:19
     .= dom Start-At (IC p,S) by FUNCOP_1:19;
  assume
A2: IC S in dom p;
  hence DecIC(NPP p,k) = NPP p +* Start-At(IC p-'k,S) by Th72
    .= DataPart p +* Start-At (IC p,S) +* Start-At ((IC p) -'k,S) by A2,Th74
    .= DataPart p +* Start-At ((IC p) -'k,S) by A1,FUNCT_4:78;
 end;

registration
  let N,S;
  let s be State of S, k be Nat;
  cluster DecIC(s,k) -> total;
  coherence;
end;

theorem
  for p being program-free PartState of S, k being Element of NAT
  holds ProgramPart DecIC(p,k) = {} by Def29;

theorem
 for p being PartState of S, i,j being Nat
 holds DecIC(DecIC(p,i),j) = DecIC(p,i+j)
 proof let p be PartState of S, i,j being Nat;
  thus DecIC(DecIC(p,i),j)
        = p +* Start-At(IC p-'i,S) +* Start-At(IC p -' i -' j,S) by Th188
       .= p +* Start-At(IC p-'i,S) +* Start-At(IC p -' (i + j),S) by NAT_2:32
       .= DecIC(p,i+j) by FUNCT_4:122;
 end;

theorem
 for p being PartState of S, j,k being Nat
 holds DecIC(p +* Start-At(j,S),k) = p +* Start-At(j-'k,S)
proof
 let p be PartState of S, j,k be Nat;
 thus DecIC(p +* Start-At(j,S),k)
   = p +* Start-At(j,S) +* Start-At(IC( p +* Start-At(j,S))-'k,S)
  .= p +* Start-At(IC(p +* Start-At(j,S))-'k,S) by FUNCT_4:122
  .= p +* Start-At(j-'k,S) by Th142;
end;

theorem
 for s being State of S, k being Nat st k <= IC s
 holds IC DecIC(s,k) + k = IC s
proof
 let s be State of S, k be Nat such that
Z: k <= IC s;
 thus IC DecIC(s,k) + k = IC s -' k + k by Th188
    .= IC s by Z,XREAL_1:237;
end;

theorem
 for p,q being PartState of S, k being Nat st IC S in dom q
  holds IncIC(p+*q,k) = p +* IncIC(q,k)
proof let p,q be PartState of S, k be Nat;
  assume IC S in dom q;
   then IC(p+*q) = IC q by FUNCT_4:14;
 hence IncIC(p+*q,k) = p +* IncIC(q,k) by FUNCT_4:15;
end;

theorem Th198:
 for p,q being PartState of S, k being Nat st IC S in dom q
  holds DecIC(p+*q,k) = p +* DecIC(q,k)
proof let p,q be PartState of S, k be Nat;
  assume IC S in dom q;
   then IC(p+*q) = IC q by FUNCT_4:14;
 hence DecIC(p+*q,k) = p +* DecIC(q,k) by FUNCT_4:15;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated definite realistic
   (non empty stored-program COM-Struct over N),
         l be Nat;
 let p be l-started PartState of S;
 cluster NPP p -> l-started;
 coherence
  proof
    IC S in dom p by Def16;
   hence
K:   IC S in dom NPP p by Th179;
    IC p = l by Def16;
   hence IC NPP p = l by K,GRFUNC_1:8;
  end;
end;

theorem Th199:
 for p being PartState of S, k,l being Nat
  holds p +* Start-At(k,S) +* Start-At(l,S)  = p +* Start-At(l,S)
proof let p be PartState of S, k,l be Nat;
  dom Start-At(k,S) = {IC S} by FUNCOP_1:19
    .= dom Start-At(l,S) by FUNCOP_1:19;
 hence p +* Start-At(k,S) +* Start-At(l,S)  = p +* Start-At(l,S) by FUNCT_4:78;
end;

theorem Th200:
 for p being PartState of S st IC S in dom p
  holds p +* Start-At(IC p,S) = p
proof
 let p be PartState of S;
  assume IC S in dom p;
  then Start-At(IC p,S) c= p by FUNCT_4:8;
 hence p +* Start-At(IC p,S) = p by FUNCT_4:103,104;
end;


theorem Th201:
 for p being PartState of S, k being Nat
   st IC S in dom p
  holds DecIC(IncIC(p,k),k) = p
proof let p be PartState of S, k be Nat such that
Z: IC S in dom p;
 thus DecIC(IncIC(p,k),k)
     = IncIC(p,k) +* Start-At(IC p + k -'k,S) by Th54
    .= IncIC(p,k) +* Start-At(IC p, S) by NAT_D:34
    .= IncIC(p,k) +* Start-At(IC p, S)
    .= p +* Start-At(IC p, S) by Th199
    .= p by Z,Th200;
end;

theorem
 for p,q being PartState of S, k being Nat st IC S in dom q
  holds DecIC(p+*IncIC(q,k),k) = p +* q
proof let p,q be PartState of S, k being Nat such that
Z: IC S in dom q;
  IC S in dom IncIC(q,k) by Th53;
 hence DecIC(p+*IncIC(q,k),k) = p +* DecIC(IncIC(q,k),k) by Th198
      .= p +* q by Z,Th201;
end;

theorem
 for S being
  regular homogeneous J/A-independent  (IC-Ins-separated definite
   realistic
  (standard-ins non empty stored-program COM-Struct over N))
  for k being Element of NAT, p being FinPartState of S ,
      s1, s2 being State of S st NPP p c= s1 & NPP Relocated (p,k) c= s2
   holds NPP p c= s1 +* DataPart s2
proof
 let S be
  regular homogeneous J/A-independent  (IC-Ins-separated definite
   realistic
  (standard-ins non empty stored-program COM-Struct over N));
  let k be Element of NAT, p be FinPartState of S , s1, s2 be
  State of S such that
A1: NPP p c= s1 and
A2: NPP Relocated (p,k) c= s2;
z: dom NPP p c= dom p by RELAT_1:25;
  set s3 = DataPart s2;
  reconsider s = s1 +* DataPart s2 as State of S;
A3:  dom p c= the carrier of S by RELAT_1:def 18;
  then
A4: dom p c= {IC S} \/ Data-Locations S \/ NAT by Th160;
A5: now
    Data-Locations S = dom s2 /\ Data-Locations S
       by Th49,XBOOLE_1:28;
    then
A6: dom s3 = Data-Locations S by RELAT_1:90;
    let x be set such that
A7: x in dom NPP p;
B7: x in dom p by z,A7;
A8: x in {IC S} \/ Data-Locations S or x in NAT by A4,B7,XBOOLE_0:def 3;
    per cases by A8,XBOOLE_0:def 3;
    suppose
A9:   x in {IC S};
A10:   not IC S in Data-Locations S by Th56;
      x = IC S by A9,TARSKI:def 1;
      then s1.x = s.x by A6,A10,FUNCT_4:12;
      hence (NPP p).x = s.x by A1,A7,GRFUNC_1:8;
    end;
    suppose
A11:  x in Data-Locations S;
      set DPp = DataPart p;
      x in dom p /\ Data-Locations S by A11,B7,XBOOLE_0:def 4;
      then
A12:  x in dom DPp by RELAT_1:90;
YY:   DPp = DataPart Relocated (p, k) by Th115;
      DPp c= NPP Relocated (p, k) by YY,Th169;
      then
A13:  DPp c= s2 by A2,XBOOLE_1:1;
      then dom DPp c= dom s2 by GRFUNC_1:8;
      then x in dom s2 /\ Data-Locations S by A11,A12,XBOOLE_0:def 4;
      then
A14:  x in dom s3 by RELAT_1:90;
      DPp c= NPP p by Th169;
      then
A15:  DPp.x = (NPP p).x by A12,GRFUNC_1:8;
A16:  s2.x = s3.x by A11,FUNCT_1:72;
      DPp.x = s2.x by A12,A13,GRFUNC_1:8;
      hence (NPP p).x = s.x by A15,A16,A14,FUNCT_4:14;
    end;
    suppose
A17:  x in NAT;
      dom DataPart s2 misses NAT by Th137;
      then not x in dom s3 by A17,XBOOLE_0:3;
      then s1.x = s.x by FUNCT_4:12;
      hence (NPP p).x = s.x by A1,A7,GRFUNC_1:8;
    end;
  end;
  dom p c= dom s by A3,PARTFUN1:def 4;
  then dom NPP p c= dom s by z,XBOOLE_1:1;
  hence thesis by A5,GRFUNC_1:8;
end;

theorem
 for k being Nat
 holds Start-At(k,S) c= p iff Start-At(k,S) c= NPP p
proof let k be Nat;
 thus Start-At(k,S) c= p implies Start-At(k,S) c= NPP p
  proof assume Start-At(k,S) c= p;
   then p is k-started by Th151;
   then IC p = k & IC S in dom p by Def16;
    then NPP p = DataPart p +* Start-At (k,S) by Th74;

   hence Start-At(k,S) c= NPP p by FUNCT_4:26;
  end;
 thus thesis by XBOOLE_1:1;
end;

theorem
  for S being regular homogeneous J/A-independent
   (IC-Ins-separated definite realistic
  (standard-ins non empty stored-program COM-Struct over N))
 for k being Element of NAT, p being FinPartState of S
  st IC S in dom p
 holds NPP Relocated(p,k) = IncIC(NPP p,k)
 proof
  let S being regular homogeneous J/A-independent
   (IC-Ins-separated definite realistic
  (standard-ins non empty stored-program COM-Struct over N));
 let k being Element of NAT, p being FinPartState of S such that
Z: IC S in dom p;
A: dom Start-At (IC p,S) = {IC S} by FUNCOP_1:19
    .= dom Start-At(IC p +k,S) by FUNCOP_1:19;
  IC S in dom Relocated(p,k) by Th119;
 hence NPP Relocated(p,k)
    = DataPart Relocated(p,k) +* Start-At (IC Relocated(p,k),S) by Th74
   .= DataPart p +* Start-At (IC Relocated(p,k),S) by Th115
   .= DataPart p +* Start-At (IC p +k,S) by Z,Th120
   .= DataPart p +* Start-At (IC p,S) +* Start-At(IC p +k,S) by A,FUNCT_4:78
   .= NPP p +* Start-At(IC p +k,S) by Z,Th74
   .= NPP p +* Start-At(IC NPP p +k,S) by Z,Th72
   .= IncIC(NPP p,k);
 end;

theorem Th206:
   for S being (IC-Ins-separated definite realistic
  (non empty stored-program COM-Struct over N))
 for p being PartState of S
 holds ProgramPart Initialize p = ProgramPart p
proof
 let S be (IC-Ins-separated definite realistic
  (non empty stored-program COM-Struct over N));
 let p be PartState of S;
 thus ProgramPart Initialize p
     = ProgramPart p +* ProgramPart Start-At(0,S) by FUNCT_4:75
    .= ProgramPart p +* {} by Th27
    .= ProgramPart p by FUNCT_4:22;
end;

theorem
  for S being regular homogeneous J/A-independent
   (IC-Ins-separated definite realistic
  (standard-ins non empty stored-program COM-Struct over N))
 for p being FinPartState of S
 holds NPP Initialize p = Initialize NPP p
proof
 let S be regular homogeneous J/A-independent
   (IC-Ins-separated definite realistic
  (standard-ins non empty stored-program COM-Struct over N));
 let p be FinPartState of S;
A: dom Start-At(0,S) misses dom ProgramPart p by Th130;
   ProgramPart Initialize p = ProgramPart p by Th206;
 hence NPP Initialize p = Initialize p \ ProgramPart p
    .= (p \ ProgramPart p) +* Start-At(0,S) by A,FUNCT_4:129
    .= Initialize NPP p;
end;

theorem Th208:
 for I being NAT-defined PartState of S
 holds NPP I = {}
proof let I be NAT-defined PartState of S;
  ProgramPart I = I by RELAT_1:209;
 hence NPP I = {} by XBOOLE_1:37;
end;

registration let N,S; let I be NAT-defined PartState of S;
 cluster NPP I -> empty;
 coherence by Th208;
end;

theorem Th209:
  for I being NAT-defined PartState of S
 holds DataPart I = 0
 proof
  let I being NAT-defined PartState of S;
   dom I c= NAT by RELAT_1:def 18;
   then
A1: dom I misses Data-Locations S by Th51,XBOOLE_1:63;
  thus DataPart I
         = I|Data-Locations S
        .= {} by A1,RELAT_1:95;
 end;

theorem Th210:
  for I being NAT-defined PartState of S
 holds NPP Initialize I = Start-At(0,S)
proof let I be NAT-defined PartState of S;
  IC S in dom Initialize I by Th141;
 hence NPP Initialize I
      = DataPart Initialize I +* Start-At (IC Initialize I,S) by Th74
     .= DataPart I +* Start-At (IC Initialize I,S) by Th80
     .= {} +* Start-At (IC Initialize I,S) by Th209
     .= Start-At (IC Initialize I,S) by FUNCT_4:21
     .= Start-At(0,S) by Th142;
end;

registration let N,S;
 let p be program-free PartState of S;
 cluster Initialize p -> program-free;
 coherence
  proof
A:  dom Start-At(0,S) misses NAT by Th26;
B:  dom p misses NAT by Lm40;
    dom Initialize p = dom Start-At(0,S) \/ dom p by FUNCT_4:def 1;
    then dom Initialize p misses NAT by A,B,XBOOLE_1:70;
   hence (Initialize p)|NAT = {} by RELAT_1:95;
  end;
end;

theorem
  for N for S be non empty COM-Struct over N
  for d be program-free PartState of S
  holds dom d misses NAT by Lm40;

theorem Th212:
 for p being program-free PartState of S
  holds NPP p = p
proof
 let p be program-free PartState of S;
  p|NAT = {} by Def29;
  then ProgramPart p = {};
 hence thesis;
end;

theorem
 for S being regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  for k being Element of NAT, p being FinPartState of S
    st IC S in dom p
  for s1, s2 being State of S st NPP p c= s1 & NPP Relocated (p,k) c= s2
   holds NPP p c= s1 +* DataPart s2
proof
 let S be regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let k be Element of NAT, p be  FinPartState of S such that
ZD:  IC S in dom p;
  let s1, s2 be
  State of S such that
A1: NPP p c= s1 and
A2: NPP Relocated (p,k) c= s2;
  set s3 = DataPart s2;
  reconsider s = s1 +* DataPart s2 as State of S;
A3:  dom NPP p c= the carrier of S by RELAT_1:def 18;
  then
A4: dom NPP p c= {IC S} \/ Data-Locations S \/ NAT by Th160;
A5: now
    Data-Locations S = dom s2 /\ Data-Locations S
       by Th49,XBOOLE_1:28;
    then
A6: dom s3 = Data-Locations S by RELAT_1:90;
    let x be set such that
A7: x in dom NPP p;
A8: x in {IC S} \/ Data-Locations S or x in NAT by A4,A7,XBOOLE_0:def 3;
    per cases by A8,XBOOLE_0:def 3;
    suppose
A9:   x in {IC S};
A10:   not IC S in Data-Locations S by Th56;
      x = IC S by A9,TARSKI:def 1;
      then s1.x = s.x by A6,A10,FUNCT_4:12;
      hence (NPP p).x = s.x by A1,A7,GRFUNC_1:8;
    end;
    suppose
A11:  x in Data-Locations S;
      set DPp = DataPart NPP p;
  ProgramPart NPP p = ProgramPart(p \ ProgramPart p)
           .= {} by RELAT_1:216;
      then
YY:   NPP p = NPP p \ ProgramPart NPP p
         .= NPP NPP p;
       IC S in dom NPP p by ZD,Lm179;
      then
XX:   NPP Relocated (NPP p, k) = IncIC(NPP NPP p,k) by LmXX
          .= IncIC(NPP p,k) by YY
          .= NPP Relocated (p, k) by LmXX,ZD;
      x in dom NPP p /\ Data-Locations S by A7,A11,XBOOLE_0:def 4;
      then
A12:  x in dom DPp by RELAT_1:90;
      DPp = DataPart Relocated (NPP p, k) by Th115;
      then DPp c= NPP Relocated (p, k) by Lm169,XX;
      then
A13:  DPp c= s2 by A2,XBOOLE_1:1;
      then dom DPp c= dom s2 by GRFUNC_1:8;
      then x in dom s2 /\ Data-Locations S by A11,A12,XBOOLE_0:def 4;
      then
A14:  x in dom s3 by RELAT_1:90;
      DPp c= NPP p by RELAT_1:88;
      then
A15:  DPp.x = (NPP p).x by A12,GRFUNC_1:8;
A16:  s2.x = s3.x by A11,FUNCT_1:72;
      DPp.x = s2.x by A12,A13,GRFUNC_1:8;
      hence (NPP p).x = s.x by A15,A16,A14,FUNCT_4:14;
    end;
    suppose
A17:  x in NAT;
      dom DataPart s2 misses NAT by Th137;
      then not x in dom s3 by A17,XBOOLE_0:3;
      then s1.x = s.x by FUNCT_4:12;
      hence (NPP p).x = s.x by A1,A7,GRFUNC_1:8;
    end;
  end;
  dom NPP p c= dom s by A3,PARTFUN1:def 4;
  hence thesis by A5,GRFUNC_1:8;
end;

theorem
 for p being non halt-free
   (NAT-defined (the Instructions of S)-valued Function)
 for d being program-free FinPartState of S
 holds ProgramPart(d +* p) = p
proof
  let p be non halt-free
   (NAT-defined (the Instructions of S)-valued Function);
  let d be program-free FinPartState of S;
 thus ProgramPart(d +* p) = ProgramPart d +* p|NAT by FUNCT_4:75
    .= {} +* p|NAT by Def29
    .= p|NAT by FUNCT_4:21
    .= p by RELAT_1:209;
end;

theorem
 for P being NAT-defined (the Instructions of S)-valued Function,
     p being PartState of S
  holds NPP(p +* P) = NPP p
proof
 let P be NAT-defined (the Instructions of S)-valued Function,
     p being PartState of S;
A: P|NAT = P by RELAT_1:209;
C: NAT misses (the carrier of S)\NAT by XBOOLE_1:79;
B: NPP p = p|((the carrier of S)\NAT) by Th65;
 NPP(p +* P) =  (p +* P)|((the carrier of S)\NAT) by Th65;
 hence NPP(p +* P) = NPP p +* P|((the carrier of S)\NAT) by B,FUNCT_4:75
        .= NPP p +* {} by A,C,RELAT_1:207
        .= NPP p by FUNCT_4:22;
end;

theorem
 for p being PartState of S st Start-At(l,S) c= p
  holds Start-At(l,S) c= NPP p
 proof let p be PartState of S;
  assume Start-At(l,S) c= p;
   then p is l-started by Th151;
   then NPP p is l-started;
  hence Start-At(l,S) c= NPP p by Th151;
 end;

theorem
  for p,q being PartState of S st DataPart p c= q
   holds DataPart p c= NPP q
  proof let p,q be PartState of S;
   assume DataPart p c= q;
    then
A:   DataPart DataPart p c= DataPart q by RELAT_1:105;
    DataPart q c= NPP q by Th169;
   hence DataPart p c= NPP q by A,XBOOLE_1:1;
  end;

theorem
  x in Data-Locations S implies
   for p being PartState of S
     holds p.x = (NPP p).x
proof assume
Z:  x in Data-Locations S;
 let p be PartState of S;
  DataPart p c= NPP p by Lm169;
  then
B: dom DataPart p c= dom NPP p by RELAT_1:25;
  Data-Locations S /\ dom p = dom DataPart p by RELAT_1:90;
  then Data-Locations S /\ dom p c= dom NPP p by B;
 hence p.x = (NPP p).x by Z,GRFUNC_1:97;
end;

theorem
  x in Data-Locations S implies
   for p being PartState of S st x in dom p
     holds x in dom NPP p
proof assume
Z1: x in Data-Locations S;
 let p be PartState of S such that
Z2: x in dom p;
  DataPart p c= NPP p by Lm169;
  then
B: dom DataPart p c= dom NPP p by RELAT_1:25;
  x in Data-Locations S /\ dom p by Z1,Z2,XBOOLE_0:def 4;
  then x in dom DataPart p by RELAT_1:90;
 hence x in dom NPP p by B;
end;

theorem
  NPP(p +* Start-At( n,S)) c= s implies IC s =  n
proof
  assume
A1: NPP(p +* Start-At( n,S)) c= s;
A2:  IC S in dom (p +* Start-At( n,S)) by Th141;
   then IC S in dom NPP(p +* Start-At( n,S)) by Th179;
  hence IC s = IC NPP(p +* Start-At( n,S)) by A1,GRFUNC_1:8
    .= IC (p +* Start-At( n,S)) by Th72,A2
    .=  n by Th142;
end;

registration let N;
  let S be IC-Ins-separated realistic (non empty COM-Struct over N);
  let k be Element of NAT;
 cluster Start-At(k,S) -> program-free;
 coherence
  proof
    dom Start-At(k,S) misses NAT by Th26;
   hence Start-At(k,S)|NAT = {} by RELAT_1:95;
  end;
end;

theorem Th221:
 for p,q being PartState of S
 holds NPP(p +* q) = NPP p +* NPP q by Lm221;

theorem
 for p being PartState of S
 holds Start-At(0,S) c= p implies IC p =  0
proof let p be PartState of S;
A1: IC Start-At(0,S) = 0 by Def16;
A2: IC S in dom Start-At(0,S) by Def16;
  assume Start-At(0,S) c= p;
  hence thesis by A1,A2,GRFUNC_1:8;
end;

theorem
 for p being PartState of S
 holds Initialize p c= s implies IC s =  0
proof let p be PartState of S;
A1: IC Initialize p =  0 by Def16;
A2: IC S in dom Initialize p by Def16;
  assume Initialize p c= s;
  hence thesis by A1,A2,GRFUNC_1:8;
end;

theorem
 for P being NAT-defined (the Instructions of S)-valued Function,
     p being PartState of S
  holds NPP(P +* p) = NPP p
proof
 let P be NAT-defined (the Instructions of S)-valued Function,
     p being PartState of S;
A: P|NAT = P by RELAT_1:209;
C: NAT misses (the carrier of S)\NAT by XBOOLE_1:79;
B: NPP p = p|((the carrier of S)\NAT) by Th65;
 NPP(P +* p) =  (P +* p)|((the carrier of S)\NAT) by Th65;
 hence NPP(P +* p) = P|((the carrier of S)\NAT) +* NPP p by B,FUNCT_4:75
        .= {} +*NPP p  by A,C,RELAT_1:207
        .= NPP p by FUNCT_4:21;
end;

theorem Th225:
 for p being PartState of S
 holds IC S in dom Initialize p
proof let p be PartState of S;
A: dom Initialize p = dom p \/ {IC S} by Th76;
  IC S in {IC S} by TARSKI:def 1;
 hence IC S in dom Initialize p by A,XBOOLE_0:def 3;
end;

theorem
 for p,q being PartState of S
 holds IC S in dom(p +* Initialize q)
proof let p,q be PartState of S;
A: dom(p +* Initialize q) =  dom p \/ dom Initialize q by FUNCT_4:def 1;
  IC S in dom Initialize q by Th225;
 hence IC S in dom(p +* Initialize q) by A,XBOOLE_0:def 3;
end;

theorem
 for p being PartState of S
 for I being NAT-defined PartState of S
  holds NPP Initialize I c= Initialize p
proof
 let p be PartState of S;
 let I be NAT-defined PartState of S;
  NPP Initialize I = Start-At(0,S) by Th210;
 hence NPP Initialize I c= Initialize p by FUNCT_4:26;
end;

theorem
 for p being PartState of S st Start-At(l,S) c= p
   holds IC p = l
proof
 let p be PartState of S;
 assume Start-At(l,S) c= p;
  then p is l-started by Th151;
 hence IC p = l by Def16;
end;

theorem
 for s being State of S
  holds NPP DecIC(s,l) = DecIC(NPP s,l)
 proof let s be State of S;
A: IC S in dom s by Lm6;
  thus NPP DecIC(s,l) = NPP s +* NPP Start-At(IC s-'l,S) by Th221
     .= NPP s +* Start-At(IC s-'l,S) by Th212
     .= NPP s +* Start-At(IC NPP s-'l,S) by A,Th72
     .= DecIC(NPP s,l);
 end;

theorem
  for N being with_non-empty_elements non empty set, S being realistic
  IC-Ins-separated (non empty COM-Struct over N), s1, s2 being State of S
  holds NPP s1 = NPP s2 implies IC s1 = IC s2
proof
  let N be with_non-empty_elements non empty set,
      S be realistic IC-Ins-separated (non
  empty COM-Struct over N), s1, s2 be State of S;
  assume
A1: NPP s1 = NPP s2;
A2: not IC S in NAT by Def12;
X1: dom s1 = the carrier of S by PARTFUN1:def 4;
X2: dom s2 = the carrier of S by PARTFUN1:def 4;
  IC S in dom s2 by Lm6;
  then IC S in dom s2 \ NAT by A2,XBOOLE_0:def 5;
  then
A3: IC S in dom s2 /\ (dom s2 \ NAT) by XBOOLE_0:def 4;
  IC S in dom s1 by Lm6;
  then IC S in dom s1 \ NAT by A2,XBOOLE_0:def 5;
  then IC S in dom s1 /\ (dom s1 \ NAT) by XBOOLE_0:def 4;
  hence IC s1 = IC(s1|(dom s1 \ NAT)) by FUNCT_1:71
    .= IC NPP s1 by Th65,X1
    .= IC(s2|(dom s2 \ NAT)) by A1,Th65,X2
    .= IC s2 by A3,FUNCT_1:71;
end;

theorem
 for S being IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N)
 for s be State of S holds
  NPP s = s|(Data-Locations S \/ {IC S}) by LmAA;

theorem Th232:
 for S being IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N)
 for s be State of S holds
  NPP s = s|(dom s \ NAT)
proof
 let S be IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N);
 let s be State of S;
 thus NPP s = s|((the carrier of S)\NAT) by Th65
    .= s|(dom s \ NAT) by PARTFUN1:def 4;
end;

theorem
 for S being IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N)
 for s1,s2 be State of S holds
  NPP s1 = NPP s2 iff
   s1|(dom s1 \ NAT) = s2|(dom s2 \ NAT)
proof
 let S be IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N);
 let s1,s2 be State of S;
A: NPP s1 = s1|(dom s1 \ NAT) by Th232;
  NPP s2 = s2|(dom s2 \ NAT) by Th232;
 hence thesis by A;
end;

theorem
 for k being Element of NAT, x being Instruction of S
  holds NPP(s +* (k,x)) = NPP s
proof let k be Element of NAT, x be Instruction of S;
  k in dom s by Th23;
 hence NPP(s +* (k,x)) = NPP(s +* (k.-->x)) by FUNCT_7:def 3
    .= NPP s +* NPP (k.-->x) by Th221
    .= NPP s +* {}
    .= NPP s by FUNCT_4:22;
end;

theorem
 for S being IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N)
 for p being PartState of S
 for s1,s2 be State of S st NPP s1 = NPP s2
  holds NPP(s1 +* p) = NPP(s2 +* p)
proof
 let S being IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N);
 let p being PartState of S;
 let s1,s2 be State of S;
 assume NPP s1 = NPP s2;
 hence NPP(s1 +* p) = NPP s2 +* NPP p by Th221
 .= NPP(s2 +* p) by Th221;
end;

theorem
 for S being IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N)
 for s be State of S, p being NAT-defined PartState of S
  holds NPP s = NPP(s +* p)
 proof let S be IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N);
  let s be State of S, p being NAT-defined PartState of S;
  thus NPP s = NPP s +* {} by FUNCT_4:22
    .= NPP s +* NPP p
    .= NPP(s +* p) by Th221;
 end;

canceled;

theorem
 for S being IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N)
 for s1,s2 be State of S, p being PartState of S
  st NPP s1 = NPP s2 & dom p = NAT
 holds s1 +* p = s2 +* p
 proof
  let S being IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N);
  let s1,s2 be State of S, p being PartState of S such that
Z1: NPP s1 = NPP s2 and
Z2: dom p = NAT;
D: dom ProgramPart s2 = NAT by Lm2;
C: dom ProgramPart s1 = NAT by Lm2;
   not IC S in NAT by Def12;
   then
A1: {IC S} misses NAT by ZFMISC_1:56;
A2: dom DataPart s1 misses NAT by Th137;
A3: dom DataPart s2 misses NAT by Th137;
   dom NPP s1 = {IC S} \/ dom DataPart s1 by Th71;
   then
A: dom ProgramPart s1 misses dom NPP s1 by C,A1,A2,XBOOLE_1:70;
   dom NPP s2 = {IC S} \/ dom DataPart s2 by Th71;
   then
B: dom ProgramPart s2 misses dom NPP s2 by D,A1,A3,XBOOLE_1:70;
  thus s1 +* p = ProgramPart s1 +* NPP s1 +* p by Th184
     .= NPP s1 +* ProgramPart s1 +* p by A,FUNCT_4:36
     .= NPP s1 +* p by C,Z2,FUNCT_4:78
     .= NPP s2 +* p by Z1
     .= NPP s2 +* ProgramPart s2 +* p by D,Z2,FUNCT_4:78
     .= ProgramPart s2 +* NPP s2 +* p by B,FUNCT_4:36
     .= s2 +* p by Th184;
 end;

theorem
 for S being IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N)
 for s1,s2 being State of S st
  ProgramPart s1 = ProgramPart s2 & NPP s1 = NPP s2
  holds s1 = s2
 proof
 let S being IC-Ins-separated definite realistic
   (stored-program non empty COM-Struct over N);
 let s1,s2 being State of S such that
Z:  ProgramPart s1 = ProgramPart s2 & NPP s1 = NPP s2;
   s1 = NPP s1 \/ ProgramPart s1 & s2 = NPP s2 \/ ProgramPart s2
          by Th68;
  hence s1 = s2 by Z;
 end;

registration let N;
  let S be realistic IC-Ins-separated definite
     (non empty stored-program COM-Struct over N),
      l be Element of NAT, s be State of S;
  cluster s+*(IC S,l) -> (the Object-Kind of S)-compatible;
 coherence
  proof let x;
   assume x in dom(s+*(IC S,l));
    then
A:   x in dom s by FUNCT_7:32;
   per cases;
   suppose
S:   x = IC S;
    then
B:   (s+*(IC S,l)).x = l by A,FUNCT_7:33;
    ObjectKind IC S = NAT by Def6;
   hence (s+*(IC S,l)).x in (the Object-Kind of S).x by S,B;
   end;
   suppose x <> IC S;
    then (s+*(IC S,l)).x = s.x by FUNCT_7:34;
   hence (s+*(IC S,l)).x in (the Object-Kind of S).x by A,FUNCT_1:def 20;
   end;
  end;
end;

theorem
 for S being IC-Ins-separated definite realistic (non empty
 stored-program COM-Struct over N)
 for s being State of S
  holds IC NPP s = IC s
proof
 let S be IC-Ins-separated definite realistic (non empty
 stored-program COM-Struct over N);
 let s being State of S;
  IC S in dom s by Lm6;
 hence thesis by Th72;
end;

theorem
 for S being IC-Ins-separated definite realistic (non empty
 stored-program COM-Struct over N)
 for s being State of S, p being PartState of S
  holds (NPP s)|dom DataPart p = s|dom DataPart p
proof
 let S be IC-Ins-separated definite realistic (non empty
 stored-program COM-Struct over N);
 let s be State of S, p being PartState of S;
   dom DataPart p c= Data-Locations S by RELAT_1:87;
   then
A: dom DataPart p c= Data-Locations S \/ {IC S} by XBOOLE_1:10;
 thus (NPP s)|dom DataPart p
         = (s|(Data-Locations S \/ {IC S}))|dom DataPart p by LmAA
        .= s|dom DataPart p by A,RELAT_1:103;
end;

theorem
 for S being IC-Ins-separated definite realistic (non empty
 stored-program COM-Struct over N)
 for s being State of S
  holds (NPP s)|{IC S} = s|{IC S}
proof
 let S be IC-Ins-separated definite realistic (non empty
 stored-program COM-Struct over N);
 let s be State of S;
A: {IC S} c= Data-Locations S \/ {IC S} by XBOOLE_1:7;
 thus (NPP s)|{IC S}
         = (s|(Data-Locations S \/ {IC S}))|{IC S} by LmAA
        .= s|{IC S} by A,RELAT_1:103;
end;
