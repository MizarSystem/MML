:: Composition of Machines, Instructions and Programs
::  by Andrzej Trybulec
::
:: Received May 20, 2010
:: Copyright (c) 2010 Association of Mizar Users

environ

 vocabularies STRUCT_0, SUBSET_1, XBOOLE_0, FUNCT_1, NUMBERS, CARD_3, ORDINAL1,
      CARD_1, FUNCOP_1, FUNCT_4, RELAT_1, TARSKI, CAT_1, FSM_1, SETFAM_1,
      FINSET_1, NAT_1, AFINSQ_1, AMISTD_1, AMISTD_2, ARYTM_1, VALUED_1,
      PARTFUN1, MCART_1, ZFMISC_1, FUNCT_7, AMI_1, ARYTM_3, SCMNORM,
      PBOOLE, GROUP_9, RECDEF_2, COMPOS_1, SCMFSA6C, FINSEQ_1, UNIALG_1,
      CARD_5, RELOC, TURING_1, XXREAL_0, VALUED_0, SCMFSA_7, INT_1,
      SCMPDS_4, ORDINAL4, SCMFSA6A;
 notations TARSKI, XBOOLE_0, ZFMISC_1, MCART_1, SUBSET_1, SETFAM_1, ORDINAL1,
      PBOOLE, FUNCT_7, CARD_1,
      CARD_3, XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1,
      FINSET_1, NUMBERS, INT_1, NAT_1, NAT_D, FUNCOP_1, FUNCT_4, AFINSQ_1,
      FINSEQ_1, FUNCT_2, DOMAIN_1, VALUED_0, VALUED_1,
      RECDEF_2, STRUCT_0, GROUP_9, XXREAL_0;
 constructors SETFAM_1, DOMAIN_1, FUNCT_4, XXREAL_0, FUNCT_7, GRAPH_2,
      RELSET_1, PRE_POLY, PBOOLE, RECDEF_2, AFINSQ_1, NAT_D, WELLORD2;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCT_2,
      FUNCOP_1, FUNCT_4, FINSET_1, XREAL_0, FINSEQ_1, CARD_3, STRUCT_0, INT_1,
      RELSET_1, GRFUNC_1, PRE_POLY, PBOOLE, AFINSQ_1, VALUED_1, XCMPLX_0;
 registrations PARTFUN1, NUMBERS, NAT_1, MEMBERED,
      REALSET1, FUNCT_7, JORDAN1J, CARD_1, XXREAL_2,
      ZFMISC_1, SUBSET_1, VALUED_0;
 registrations
      XXREAL_0, ORDINAL4, ORDINAL5;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM, REAL;
 definitions RELAT_1, FUNCOP_1, ORDINAL1, PBOOLE,
      PARTFUN1, MCART_1, ZFMISC_1, TARSKI, STRUCT_0, FUNCT_1;
 definitions YELLOW_8, XBOOLE_0, NAT_1,
      FUNCT_4, NAT_D, AFINSQ_1, VALUED_1, CARD_3;
 theorems ZFMISC_1, FUNCT_2, TARSKI, CQC_LANG, CARD_3, FINSEQ_1,
      FUNCT_4, FUNCOP_1, FINSET_1, FUNCT_1, GRFUNC_1, RELAT_1, RELSET_1,
      XBOOLE_0, XBOOLE_1, ORDINAL1, MCART_1, ENUMSET1, SUBSET_1,
      FUNCT_7, PARTFUN1, PBOOLE, RECDEF_2, FUNCT_5, CARD_1, AFINSQ_1,
      XREAL_1, YELLOW_8, REALSET1, VALUED_1, CARD_2, PRE_CIRC, XREAL_0,
      NAT_1, XXREAL_0, NAT_D, INT_1;
 schemes FRAENKEL, CLASSES1;

begin :: General concepts

reserve N for non empty with_non-empty_elements set;
reserve x,A for set,
  i,j,k,m,n, l, l1, l2, l3 for Element of NAT;
reserve D for non empty set,
  z for natural number;

definition
  let N be set;
  struct (1-sorted) COM-Struct over N (# carrier -> set,
    Instruction-Counter -> Element of the carrier,
    Instructions -> non empty set,
    haltF -> Element of the Instructions,
    Object-Kind -> Function of the carrier, N \/ { the Instructions, NAT }
     #);
end;

definition
  let N be set;
  func Trivial-COM N -> strict COM-Struct over N means
:Def2:
  the carrier of it = succ NAT & the Instruction-Counter of it = NAT &
  the Instructions of it = {[0,{},{}]} &
  the haltF of it = [0,{},{}] &
  the Object-Kind of it = (NAT --> {[0,{},{}]}) +* (NAT .--> NAT);
  existence
  proof
    reconsider I = {[0,{},{}]} as non empty set;
    reconsider i = [0,{},{}] as Element of I by TARSKI:def 1;
    set f = (NAT --> I) +* (NAT .--> NAT);
A1: dom f = dom(NAT --> I) \/ dom(NAT .--> NAT) by FUNCT_4:def 1
      .= NAT \/ dom(NAT .--> NAT) by FUNCOP_1:19
      .= succ NAT by FUNCOP_1:19;
    rng(NAT --> I) c= {I} & rng(NAT .--> NAT) c= {NAT} by FUNCOP_1:19;
    then rng(NAT --> I) \/ rng(NAT .--> NAT) c= {I} \/ {NAT} by XBOOLE_1:13;
    then rng f c= rng(NAT --> I) \/ rng(NAT .--> NAT) &
     rng(NAT --> I) \/ rng(NAT .--> NAT) c= { I,NAT} by ENUMSET1:41,FUNCT_4:18;
    then
A2: rng f c= { I,NAT} by XBOOLE_1:1;
    { I,NAT } c= N \/ {I, NAT} by XBOOLE_1:7;
    then rng f c= N \/ {I, NAT} by A2,XBOOLE_1:1;
    then reconsider f as Function of succ NAT, N \/ {I, NAT} by A1,
FUNCT_2:def 1,RELSET_1:11;
    reconsider y = NAT as Element of succ NAT by ORDINAL1:10;
    take COM-Struct(#succ NAT,y,I,i,f #);
    thus thesis;
  end;
  uniqueness;
end;

definition
  let N be set;
  let S be COM-Struct over N;
  attr S is stored-program means
:Def3: NAT c= the carrier of S;
end;

registration
  let N be set;
  cluster Trivial-COM N-> non empty stored-program;
  coherence
  proof
    set S = Trivial-COM N;
A1: the carrier of S = succ NAT by Def2;
    thus the carrier of S is non empty by Def2;
    thus NAT c= the carrier of S by A1,XBOOLE_1:7;
  end;
end;

registration
  let N be set;
  cluster non empty stored-program COM-Struct over N;
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

definition
  let N be set;
  let S be non empty COM-Struct over N;
  mode Object of S is Element of S;
end;

definition
  let N be set;
  let S be COM-Struct over N;
  mode Instruction of S is Element of the Instructions of S;
end;

definition
  let N be set;
  let S be non empty COM-Struct over N;
  func IC S -> Object of S equals
  the Instruction-Counter of S;
  correctness;
end;

definition
  let N be set;
  let S be non empty COM-Struct over N;
  let o be Object of S;
  func ObjectKind o -> Element of N \/ { the Instructions of S, NAT } equals
  (the Object-Kind of S).o;
  correctness;
end;

definition
  let N be set;
  let S be COM-Struct over N;
  mode PartState of S is (the carrier of S)-defined
           (the Object-Kind of S)-compatible Function;
end;

definition
  let N be set;
  let S be COM-Struct over N;
  mode FinPartState of S is finite PartState of S;
end;

definition
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  mode State of S is total PartState of S;
end;

definition
  let N be set;
  let S be COM-Struct over N;
  func halt S -> Instruction of S equals
   the haltF of S;
  coherence;
end;

definition
  let N be set;
  let IT be non empty COM-Struct over N;
  attr IT is IC-Ins-separated means
  :Def11:
  ObjectKind IC IT = NAT;
end;

definition
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  let I be (the Object-Kind of S)-compatible Function;
  attr I is halt-free means
:Def7:  not halt S in rng I;
end;

definition
  let N be set;
  let IT be non empty stored-program COM-Struct over N;
  attr IT is definite means
:Def8:
  for l being Element of NAT
  holds (the Object-Kind of IT).l = the Instructions of IT;
end;

registration
  let E be set;
  cluster Trivial-COM E -> IC-Ins-separated definite;
  coherence
   proof
  thus Trivial-COM E is IC-Ins-separated
   proof
    dom(NAT .--> NAT) = {NAT} by FUNCOP_1:19;
    then
A1:  NAT in dom(NAT .--> NAT) by TARSKI:def 1;
    IC Trivial-COM E = NAT by Def2;
    hence ObjectKind IC Trivial-COM E
     = ((NAT --> {[0,{},{}]}) +* (NAT .--> NAT)).NAT by Def2
    .= (NAT .--> NAT).NAT by A1,FUNCT_4:14
    .= NAT by FUNCOP_1:87;
   end;
  let l be Element of NAT;
  not l in {NAT} by TARSKI:def 1;
  then
A2: not l in dom(NAT .--> NAT) by FUNCOP_1:19;
  thus (the Object-Kind of Trivial-COM E).l
     = ((NAT --> {[0,{},{}]}) +* (NAT .--> NAT)).l by Def2
    .= (NAT --> {[0,{},{}]}).l by A2,FUNCT_4:12
    .= {[0,{},{}]} by FUNCOP_1:13
    .= the Instructions of Trivial-COM E by Def2;
   end;
end;

registration
  let M be set;
  cluster IC-Ins-separated definite strict (non empty stored-program
    COM-Struct over M);
  existence
  proof
    take Trivial-COM M;
    thus thesis;
  end;
end;

registration
  let N;
  cluster IC-Ins-separated definite strict (non
    empty stored-program COM-Struct over N);
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

definition
  let N be with_non-empty_elements set;
  let S be IC-Ins-separated (non empty COM-Struct over N);
  let p be PartState of S;
  func IC p -> Element of NAT equals
  p.IC S;
  coherence
  proof
   per cases;
   suppose
A1: IC S in dom p;
    consider s being State of S such that
A2: p c= s by PBOOLE:156;
   reconsider ss=s as Element of product the Object-Kind of S by PBOOLE:155;
    dom the Object-Kind of S = the carrier of S by FUNCT_2:def 1;
    then pi(product the Object-Kind of S,IC S) = ObjectKind IC S by CARD_3:22
      .= NAT by Def11;
    then ss.IC S in NAT by CARD_3:def 6;
    hence thesis by A1,A2,GRFUNC_1:8;
   end;
   suppose not IC S in dom p;
   hence thesis by FUNCT_1:def 4;
   end;
  end;
end;

theorem
  for s1, s2 being State of Trivial-COM N st IC s1 = IC s2 holds s1= s2
proof
  set T = Trivial-COM N;
  let s1,s2 be State of Trivial-COM N such that
A1: IC s1 = IC s2;
A2: dom s1 = the carrier of T by PARTFUN1:def 4;
A3: now
    let x be set;
    assume
A4: x in dom s1;
    dom s1 = the carrier of T by PARTFUN1:def 4
      .= succ NAT by Def2;
    then
A5: x in NAT or x in {NAT} by A4,XBOOLE_0:def 3;
    per cases by A5,TARSKI:def 1;
    suppose
A6:   x in NAT;
      then x <> NAT;
      then not x in {NAT} by TARSKI:def 1;
      then
A7:   not x in dom(NAT .--> NAT) by FUNCOP_1:19;
A8:   (the Object-Kind of T).x = ((NAT --> {[0,{},{}]}) +* (NAT .--> NAT)).x
by Def2
        .= (NAT --> {[0,{},{}]}).x by A7,FUNCT_4:12
        .= {[0,{},{}]} by A6,FUNCOP_1:13;
      x in dom s2 by A2,A4,PARTFUN1:def 4;
      then
A9:   s2.x in {[0,{},{}]} by A8,FUNCT_1:def 20;
      s1.x in {[0,{},{}]} by A4,A8,FUNCT_1:def 20;
      hence s1.x = [0,{},{}] by TARSKI:def 1
        .= s2.x by A9,TARSKI:def 1;
    end;
    suppose
A10:  x = NAT;
      hence s1.x = IC s1 by Def2
        .= s2.x by A1,A10,Def2;
    end;
  end;
  dom s1 =dom s2 by A2,PARTFUN1:def 4;
  hence thesis by A3,FUNCT_1:9;
end;

begin :: General theory

definition
  let N;
  let S be IC-Ins-separated (non empty COM-Struct over N);
  let p be (the Instructions of S)-valued Function;
  let s be State of S;
  func CurInstr(p,s) -> Instruction of S equals
  p/.IC s;
  coherence;
end;

definition
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  let s be PartState of S;
  func ProgramPart s -> PartState of S equals
  s | NAT;
  coherence;
end;

registration
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  let s be PartState of S;
  cluster ProgramPart s -> NAT-defined;
  coherence;
end;

reserve S for IC-Ins-separated definite
  (non empty stored-program COM-Struct over N),
  s,s1,s2 for State of S;
reserve ins for Element of the Instructions of S;
reserve ss for Element of product the Object-Kind of S;
reserve p for FinPartState of S;

BWL:
 for i being natural number holds
 (ProgramPart s).i = s.i
 proof
  let i being natural number;
X:   i in NAT by ORDINAL1:def 13;
Y: dom s = the carrier of S by PARTFUN1:def 4;
   NAT c= the carrier of S by Def3;
   then i in the carrier of S by X;
   then i in dom s by Y;
   then i in dom ProgramPart s by X,RELAT_1:86;
  hence (ProgramPart s).i = s.i by FUNCT_1:70;
 end;

BWL2:
 for s being PartState of S
 for i being natural number st i in dom s
  holds (ProgramPart s).i = s.i
 proof let s be PartState of S;
  let i being natural number such that
Z: i in dom s;
X:   i in NAT by ORDINAL1:def 13;
   i in dom ProgramPart s by X,Z,RELAT_1:86;
  hence (ProgramPart s).i = s.i by FUNCT_1:70;
 end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated definite
   (non empty stored-program COM-Struct over N);
  let s be PartState of S;
  cluster ProgramPart s -> (the Instructions of S)-valued;
  coherence
   proof let e be set;
    assume e in rng ProgramPart s;
     then consider u being set such that
W1:   u in dom ProgramPart s and
W2:   e = (ProgramPart s).u by FUNCT_1:def 5;
B:   dom ProgramPart s = NAT /\ dom s by RELAT_1:90;
     then
D:    u in NAT by W1,XBOOLE_0:def 4;
     then
A:    (the Object-Kind of S).u = the Instructions of S by Def8;
     reconsider u as Nat by D;
E:   u in dom s by B,W1,XBOOLE_0:def 4;
     then
C:   (ProgramPart s).u = s.u by BWL2;
     s.u in (the Object-Kind of S).u by E,FUNCT_1:def 20;
    hence e in the Instructions of S by W2,C,A;
   end;
end;

LmU: for N being with_non-empty_elements set for S being
  (non empty stored-program COM-Struct over N)
   for s being State of S
   holds dom ProgramPart s = NAT
proof
  let N be with_non-empty_elements set;
  let S be (non empty stored-program COM-Struct over N);
  let s be State of S;
A1:   NAT c= the carrier of S by Def3;
   dom s = the carrier of S by PARTFUN1:def 4;
  hence thesis by A1,RELAT_1:91;
end;

BWL1:
 for N being with_non-empty_elements non empty set
 for S being
  IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)
   for s being State of S
 for i being natural number holds
 (ProgramPart s)/.i = s.i
 proof
 let N being with_non-empty_elements non empty set;
 let S being IC-Ins-separated definite
  (non empty stored-program COM-Struct over N);
   let s being State of S;
  let i be natural number;
   dom ProgramPart s = NAT by LmU;
   then i in dom ProgramPart s by ORDINAL1:def 13;
  hence (ProgramPart s)/.i = (ProgramPart s).i by PARTFUN1:def 8
        .= s.i by BWL;
 end;

definition
  let N be set;
  let IT be COM-Struct over N;
  attr IT is realistic means
  :Def21:
  not the Instruction-Counter of IT in NAT;
end;

theorem
 for i being natural number holds
 (ProgramPart s).i = s.i by BWL;

theorem Th3:
  for S being IC-Ins-separated (non empty COM-Struct over A) st
  S is realistic holds not ex l being Element of NAT st IC S = l
      by Def21;

definition
  let N;
  let S be definite (non empty stored-program COM-Struct over N);
  let s be State of S, l be Element of NAT;
  redefine func s.l -> Instruction of S;
  coherence
  proof
Y:  dom the Object-Kind of S = the carrier of S by FUNCT_2:def 1;
U:  l in NAT;
    NAT c= the carrier of S by Def3;
    then
X:   pi(product the Object-Kind of S,l)
       = (the Object-Kind of S).l by Y,U,CARD_3:22
      .= the Instructions of S by Def8;
     s in product the Object-Kind of S by PBOOLE:155;
    hence thesis by X,CARD_3:def 6;
  end;
end;

registration
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  let p be FinPartState of S;
  cluster ProgramPart p -> finite;
  coherence;
end;

registration
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  let p be PartState of S;
  cluster ProgramPart p -> NAT-defined;
  coherence;
end;

LmL:
  for N being with_non-empty_elements set, S
being stored-program COM-Struct over N, s being State of S holds NAT c= dom s
proof
  let N be with_non-empty_elements set, S be
  stored-program COM-Struct over N;
  let s be State of S;
  dom s = the carrier of S by PARTFUN1:def 4;
  hence thesis by Def3;
end;

registration
  let N be with_non-empty_elements set;
  let S be stored-program COM-Struct over N;
  let s be State of S;
  cluster ProgramPart s -> total;
  coherence
   proof
     NAT c= dom s by LmL;
    hence dom ProgramPart s = NAT by RELAT_1:91;
   end;
end;

definition let N;
 let S be IC-Ins-separated definite
  (non empty stored-program COM-Struct over N);
 let P be (the Instructions of S)-valued ManySortedSet of NAT,
     k be Nat;
 redefine func P.k -> Instruction of S;
 coherence
  proof
B:  k in NAT by ORDINAL1:def 13;
    dom P = NAT by PARTFUN1:def 4;
    then k in dom P by B;
    then
A:  P.k in rng P by FUNCT_1:12;
    rng P c= the Instructions of S by RELAT_1:def 19;
    then P.k in the Instructions of S by A;
   hence P.k is Instruction of S;
  end;
end;

L94:
  for N being with_non-empty_elements set,
      S being non empty COM-Struct over N
  for s being State of S holds IC S in dom s
proof
  let N be with_non-empty_elements set,
      S be non empty COM-Struct over N;
  let s be State of S;
  dom s = the carrier of S by PARTFUN1:def 4;
  hence thesis;
end;

registration
  let N;
  let S be non empty COM-Struct over N, o be Object of S;
  cluster ObjectKind o -> non empty;
  coherence;
end;

begin :: Finite substates

definition
  let N be set;
  let S be COM-Struct over N;
  func FinPartSt S -> Subset of sproduct the Object-Kind of S equals
  { p where
  p is Element of sproduct the Object-Kind of S: p is finite };
  coherence
  proof
    defpred P[set] means $1 is finite;
    { p where p is Element of sproduct the Object-Kind of S: P[p] } c=
    sproduct the Object-Kind of S from FRAENKEL:sch 10;
    hence thesis;
  end;
end;

definition
  let N be set;
  let S be non empty COM-Struct over N;
  func Data-Locations S equals
  (the carrier of S) \ ({IC S} \/ NAT);
  coherence;
end;

definition
  let N be set;
  let S be non empty COM-Struct over N;
  redefine func Data-Locations S -> Subset of S;
  coherence;
end;

theorem Th4:
  for S being non empty COM-Struct over N for A,B being set, la
  ,lb being Object of S st ObjectKind la = A & ObjectKind lb = B for a being
Element of A, b being Element of B holds (la,lb) --> (a,b) is FinPartState of S
proof
  let S be non empty COM-Struct over N;
  let A,B be set, la,lb be Object of S such that
A1: ObjectKind la = A and
A2: ObjectKind lb = B;
  let a be Element of A, b be Element of B;
  set p = (la,lb) --> (a,b);
A3: dom p = {la,lb} by FUNCT_4:65;
A4: now
    let x be set such that
A5: x in dom p;
    now
      per cases by A3,A5,TARSKI:def 2;
      suppose
A6:     la <> lb & x = la;
        then p.x = a by FUNCT_4:66;
        hence p.x in (the Object-Kind of S).x by A1,A6;
      end;
      suppose
A7:     la <> lb & x = lb;
        then p.x = b by FUNCT_4:66;
        hence p.x in (the Object-Kind of S).x by A2,A7;
      end;
      suppose
A8:     la = lb & x = la;
        then p = la .--> b by CQC_LANG:44;
        then p.x = b by A8,FUNCOP_1:87;
        hence p.x in (the Object-Kind of S).x by A2,A8;
      end;
    end;
    hence p.x in (the Object-Kind of S).x;
  end;
  reconsider p as PartState of S by A4,FUNCT_1:def 20;
  dom p = {la,lb} by FUNCT_4:65;
  hence thesis;
end;

theorem Th5:
  for S being non empty COM-Struct over N for A being set, la
being Object of S st (the Object-Kind of S).la = A
 for a being Element of A holds la .--> a is FinPartState of S
proof
  let S be non empty COM-Struct over N;
  let A be set, la be Object of S such that
A1: (the Object-Kind of S).la = A;
  let a be Element of A;
  set p = la .--> a;
A2: dom p = {la} by FUNCOP_1:19;
A3: now
    let x be set;
    assume
    x in dom p;
    then
A4: x = la by A2,TARSKI:def 1;
    then p.x = a by FUNCOP_1:87;
    hence p.x in (the Object-Kind of S).x by A1,A4;
  end;
  reconsider p as PartState of S by A3,FUNCT_1:def 20;
  p is PartState of S;
  hence thesis;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program COM-Struct over
  N);
  let la be Object of S;
  let a be Element of ObjectKind la;
  redefine func la .--> a -> FinPartState of S;
  coherence by Th5;
end;

definition
  let N;
  let S be IC-Ins-separated definite (non empty stored-program COM-Struct over
  N);
  let la,lb be Object of S;
  let a be Element of ObjectKind la, b be Element of ObjectKind lb;
  redefine func (la,lb) --> (a,b) -> FinPartState of S;
  coherence by Th4;
end;

registration
  let A;
  cluster Trivial-COM A -> realistic;
  coherence
proof
  assume
A1: the Instruction-Counter of Trivial-COM A in NAT;
  the Instruction-Counter of Trivial-COM A = NAT by Def2;
  hence thesis by A1;
end;
end;

registration
  let A;
  cluster realistic strict COM-Struct over A;
  existence
  proof
    take Trivial-COM A;
    thus thesis;
  end;
end;

registration
  let N;
  cluster realistic strict
   (IC-Ins-separated definite (non empty stored-program COM-Struct over N));
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

reserve S for IC-Ins-separated definite realistic
  (non empty stored-program COM-Struct over N),
  s,s1,s2 for State of S;
reserve
  ins for Element of the Instructions of S;
reserve ss for Element of product the Object-Kind of S;
reserve p for FinPartState of S;

registration
  let N be set;
  let S be COM-Struct over N;
  let f,g be PartState of S;
  cluster f +* g -> (the carrier of S)-defined
           (the Object-Kind of S)-compatible Function;
  coherence;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty COM-Struct over N);
  let l be Nat;
  func Start-At(l,S) -> FinPartState of S equals
  IC S .--> l;
  correctness
  proof
    reconsider l as Element of NAT by ORDINAL1:def 13;
    ObjectKind IC S = NAT by Def11;
    then IC S .--> l is PartState of S by Th5;
    hence thesis;
  end;
end;

begin :: Preprograms

theorem
  for S being realistic IC-Ins-separated definite
   (non empty stored-program COM-Struct over N)
  for l being Element of NAT, I being Instruction of S
  for P being NAT-defined (the Instructions of S)-valued Function
   st l .--> I c= P
  for s being State of S st IC S .--> l c= s
   holds CurInstr(P,s) = I
proof
  let S be realistic IC-Ins-separated definite
   (non empty stored-program COM-Struct over N);
  let l be Element of NAT, I be Instruction of S;
  let P be NAT-defined (the Instructions of S)-valued Function such that
ZZ: l .--> I c= P;
  let s be State of S such that
Z: IC S .--> l c= s;
  dom(IC S .--> l) = {IC S} by FUNCOP_1:19;
  then IC S in dom(IC S .--> l) by TARSKI:def 1;
  then
A: IC s = (IC S .--> l).IC S by Z,GRFUNC_1:8
     .= l by FUNCOP_1:87;
  dom(l.--> I) = {l} by FUNCOP_1:19;
  then
B: IC s in dom(l.--> I) by A,TARSKI:def 1;
  dom(l.--> I) c= dom P by ZZ,RELAT_1:25;
  then IC s in dom P by B;
 hence CurInstr(P,s) = P.IC s by PARTFUN1:def 8
   .= (l .--> I).IC s by B,ZZ,GRFUNC_1:8
   .= I by A,FUNCOP_1:87;
end;

definition
  let N be with_non-empty_elements set;
  let S be IC-Ins-separated (non empty COM-Struct over N),
      l be Nat;
  let p be PartState of S;
  attr p is l-started means
:Def41: IC S in dom p & IC p = l;
end;

begin :: InsType & InsCode

notation
  let x;
  synonym InsCode x for x`1_3;
  synonym JumpPart x for x`2_3;
  synonym AddressPart x for x`3_3;
end;

definition
  let N be set, S be COM-Struct over N;
  attr S is standard-ins means
:Def17:
   ex X being non empty set
    st the Instructions of S c= [: NAT,NAT*,X*:];
end;

registration
  let N be set;
  cluster Trivial-COM N -> standard-ins;
  coherence
  proof
    {} in ((union N) \/ the carrier of Trivial-COM N)* by FINSEQ_1:66;
    then
A1: {{}} c= ((union N) \/ the carrier of Trivial-COM N)* by ZFMISC_1:37;
    take X = (union N) \/ the carrier of Trivial-COM N;
    {} in NAT* by FINSEQ_1:66;
    then
X:  {{}} c= NAT* by ZFMISC_1:37;
    the Instructions of Trivial-COM N = {[0,{},{}]} by Def2
      .= [:{0},{{}},{{}}:] by MCART_1:39;
    hence the Instructions of Trivial-COM N c= [: NAT,NAT*,X*:]
     by A1,X,MCART_1:77;
  end;
end;

registration
  let N be set;
  cluster standard-ins non empty stored-program COM-Struct over N;
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

registration
  let N be set, S be standard-ins COM-Struct over N;
  cluster the Instructions of S -> Relation-like;
  coherence
   proof
    ex X being non empty set
     st the Instructions of S c= [: NAT,NAT*,X*:] by Def17;
    hence thesis;
   end;
end;

registration let N be set;
 let S be standard-ins non empty COM-Struct over N;
 let x be Instruction of S;
 cluster InsCode x -> natural;
 coherence
  proof
    consider X being non empty set such that
W:   the Instructions of S c= [:NAT,NAT*,X*:] by Def17;
   x in the Instructions of S;
   then x`1_3 in NAT by W,RECDEF_2:2;
   hence thesis;
  end;
end;

registration
  let N;
  cluster IC-Ins-separated definite standard-ins (non empty stored-program
    COM-Struct over N);
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

registration
  let N be set, S be standard-ins COM-Struct over N;
  cluster the Instructions of S -> Relation-like;
  coherence;
end;

definition
  let N be set, S be standard-ins COM-Struct over N;
  func InsCodes S equals
  proj1 proj1 the Instructions of S;
  correctness;
end;

registration
  let N be set, S be standard-ins COM-Struct over N;
  cluster InsCodes S ->non empty;
  coherence
   proof
    ex X being non empty set st the Instructions of S c= [: NAT,NAT*,X*:]
     by Def17;
    then dom the Instructions of S c= [:NAT,NAT*:] by FUNCT_5:13;
    then reconsider II = dom the Instructions of S as Relation;
    assume InsCodes S is empty;
     then II = {};
    hence contradiction;
   end;
end;

definition
  let N be set, S be standard-ins COM-Struct over N;
  mode InsType of S is Element of InsCodes S;
end;

definition
  let N be set, S be standard-ins COM-Struct over N;
  let I be Element of the Instructions of S;
  redefine func InsCode I -> InsType of S;
  coherence
   proof
     consider X being non empty set such that
W:    the Instructions of S c= [:NAT,NAT*,X*:] by Def17;
     I in the Instructions of S;
     then I in [:NAT,NAT*,X*:] by W;
     then I = [ I`1_3, I`2_3, I`3_3 ] by RECDEF_2:3;
     then [ I`1_3, I`2_3 ] in proj1 the Instructions of S by RELAT_1:def 4;
     then InsCode I in InsCodes S by RELAT_1:def 4;
    hence thesis;
   end;
end;

begin :: Some Remarks on COM-Struct

LMT:
 for N being with_non-empty_elements set,
     S be COM-Struct over N
 for p being FinPartState of S holds p in FinPartSt S
 proof
  let N be with_non-empty_elements set,
     S be COM-Struct over N;
  let p be FinPartState of S;
   p in sproduct the Object-Kind of S by CARD_3:153;
  hence thesis;
 end;

registration
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  cluster FinPartSt S -> non empty;
  coherence by LMT;
end;

registration
  let N be set;
  let S be COM-Struct over N;
  cluster NAT-defined (the Instructions of S)-valued FinPartState of S;
  existence
  proof
    reconsider Z = {} as FinPartState of S by FUNCT_1:174,RELAT_1:206;
    take Z;
    thus dom Z c= NAT by RELAT_1:60,XBOOLE_1:2;
    thus rng Z c= the Instructions of S by RELAT_1:60,XBOOLE_1:2;
  end;
end;

registration
  let N be set;
  let S be definite (non empty stored-program COM-Struct over N);
 cluster NAT-defined (the Instructions of S)-valued
      -> (the Object-Kind of S)-compatible Function;
 coherence
  proof let F be Function;
   assume
Z0: F is NAT-defined (the Instructions of S)-valued;
   let x;
   assume
Z:   x in dom F;
    dom F c= NAT by Z0,RELAT_1:def 18;
    then
A:   x in NAT by Z;
C:  rng F c= the Instructions of S by Z0,RELAT_1:def 19;
    F.x in rng F by Z,FUNCT_1:12;
    then
B:  F.x in the Instructions of S by C;
    (the Object-Kind of S).x = the Instructions of S by A,Def8;
   hence F.x in (the Object-Kind of S).x by B;
  end;
end;

theorem Th7:
 for N be set, S be standard-ins COM-Struct over N
 for I,J being Instruction of S
  st InsCode I = InsCode J & JumpPart I = JumpPart J &
   AddressPart I = AddressPart J
 holds I = J
proof
 let N be set, S be standard-ins COM-Struct over N;
 let I,J be Instruction of S;
  consider X being non empty set such that
W:   the Instructions of S c= [:NAT,NAT*,X*:] by Def17;
  I in the Instructions of S;
  then
Y: I in [:NAT,NAT*,X*:] by W;
  J in the Instructions of S;
  then J in [:NAT,NAT*,X*:] by W;
 hence thesis by Y,RECDEF_2:10;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty COM-Struct over N),
      l be Nat;
  cluster Start-At(l,S) -> l-started;
  coherence
   proof
     dom Start-At(l,S) = {IC S} by FUNCOP_1:19;
    hence IC S in dom Start-At(l,S) by TARSKI:def 1;
    thus IC Start-At(l,S) = l by FUNCOP_1:87;
   end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty COM-Struct over N),
      l be Nat;
  cluster l-started FinPartState of S;
  existence
   proof
    take Start-At(l,S);
    thus thesis;
   end;
end;

registration
  let N;
  let S be COM-Struct over N;
  let s be State of S;
  let p be PartState of S;
  cluster s +* p -> total PartState of S;
  coherence;
  cluster p +* s -> total PartState of S;
  coherence;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty COM-Struct over N),
      l be Nat,
      p being PartState of S, q be l-started PartState of S;
  cluster p +* q -> l-started;
  coherence
   proof
A:   IC S in dom q by Def41;
     dom q c= dom(p+*q) by FUNCT_4:11;
    hence IC S in dom(p+*q) by A;
     IC q = l by Def41;
    hence IC(p+*q) = l by A,FUNCT_4:14;
   end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated (non empty COM-Struct over N),
      l be Nat;
  cluster l-started State of S;
  existence
   proof
    take (the State of S) +* Start-At(l,S);
    thus thesis;
   end;
end;

definition
  let N be with_non-empty_elements set;
  let S be (COM-Struct over N);
  let p be NAT-defined (the Instructions of S)-valued Function, l be set;
  pred p halts_at l means
:Def42: l in dom p & p.l = halt S;
end;

definition
  let N;
  let S be IC-Ins-separated (non empty COM-Struct over N),
      l be Nat;
  let s be State of S;
  redefine attr s is l-started means
  IC s = l;
  compatibility
   proof
    thus s is l-started implies IC s = l by Def41;
    assume
Z:    IC s = l;
    thus IC S in dom s by L94;
    thus IC s = l by Z;
   end;
end;

definition
  let N be with_non-empty_elements set;
  let S be (non empty COM-Struct over N);
  let s be (the Instructions of S)-valued ManySortedSet of NAT,
      l be Nat;
  redefine pred s halts_at l means

  s.l = halt S;
  compatibility
   proof
    thus s halts_at l implies s.l = halt S by Def42;
    assume
Z:    s.l = halt S;
A:   l in NAT by ORDINAL1:def 13;
     NAT = dom s by PARTFUN1:def 4;
    hence l in dom s by A;
    thus s.l = halt S by Z;
   end;
end;

theorem
  for S being definite IC-Ins-separated
   (non empty stored-program COM-Struct over N),
      l being Nat,
      p being l-started PartState of S
  for s being PartState of S st p c= s holds s is l-started
proof
  let S be definite IC-Ins-separated
   (non empty stored-program COM-Struct over N),
      l be Nat,
      p be l-started PartState of S;
A1: IC S in dom p by Def41;
A2: IC p = l by Def41;
  let s be PartState of S;
  assume
Z:  p c= s;
   then dom p c= dom s by RELAT_1:25;
  hence IC S in dom s by A1;
  thus IC s = l by Z,A2,A1,GRFUNC_1:8;
end;

definition
  let N;
  let S be definite IC-Ins-separated (non empty stored-program COM-Struct over
  N);
  let l be Element of NAT, I be Element of the Instructions of S;
  redefine func l .--> I -> NAT-defined FinPartState of S;
  coherence;
end;

theorem Th9:
  for N being with_non-empty_elements set,
      S being non empty COM-Struct over N
  for s being State of S holds IC S in dom s by L94;

theorem
  for s being State of S holds Start-At(IC s,S) = s | {IC S}
proof
  let s be State of S;
A1: IC S in dom s by Th9;
  thus Start-At(IC s,S) = {[IC S,s.IC S]} by FUNCT_4:87
    .= s | {IC S} by A1,GRFUNC_1:89;
end;

definition
  let N be set;
  let S be non empty COM-Struct over N;
  let p be PartState of S;
  func DataPart p -> PartState of S equals
  p | Data-Locations S;
  coherence;
  projectivity by RELAT_1:101;
end;

registration
  let N be set;
  let S be non empty COM-Struct over N;
  let p be FinPartState of S;
  cluster DataPart p -> finite;
  coherence;
end;

definition
  let N be set, S be non empty COM-Struct over N;
  let IT be PartState of S;
  attr IT is data-only means
:Def50:
  dom IT misses {IC S} \/ NAT;
end;

registration
  let N be set, S be non empty COM-Struct over N;
  cluster data-only FinPartState of S;
  existence
  proof
    consider p being PartState of S;
    {} c= p by XBOOLE_1:2;
    then reconsider p = {} as FinPartState of S;
    take p;
    thus dom p misses {IC S} \/ NAT by RELAT_1:60,XBOOLE_1:65;
  end;
end;

theorem Th11:
  for N being set, S being non empty COM-Struct over N for
  p being PartState of S holds not IC S in dom DataPart p
proof
  let N be set, S be non empty COM-Struct over N;
  let p be PartState of S;
  assume
A1: IC S in dom (DataPart p);
  dom(DataPart p) c= ((the carrier of S) \ ({IC S} \/ NAT)) by RELAT_1:87;
  then not IC S in {IC S} \/ NAT by A1,XBOOLE_0:def 5;
  then not IC S in {IC S} by XBOOLE_0:def 3;
  hence contradiction by TARSKI:def 1;
end;

theorem Th12:
  for S being IC-Ins-separated definite realistic (non empty
stored-program COM-Struct over N) for p being PartState of S holds not IC
  S in dom (ProgramPart p)
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  COM-Struct over N);
  let p be PartState of S;
  assume
A1: IC S in dom (ProgramPart p);
  dom(ProgramPart p) c= NAT by RELAT_1:87;
  then reconsider l = IC S as Element of NAT by A1;
  not l in dom ProgramPart p by Def21;
  hence contradiction by Def21;
end;

theorem Th13:
  for N being set, S being non empty COM-Struct over N for p being
  PartState of S holds {IC S} misses dom DataPart p by Th11,ZFMISC_1:56;

theorem Th14:
  for S being IC-Ins-separated definite realistic (non empty
stored-program COM-Struct over N) for p being PartState of S holds {IC S}
  misses dom (ProgramPart p) by Th12,ZFMISC_1:56;

theorem Th15:
  for p,q being PartState of S holds dom DataPart p misses dom
  ProgramPart q
proof
  let p,q be PartState of S;
  ((the carrier of S) \ ({IC S} \/ NAT)) c= (the carrier of S) \ NAT & dom(
DataPart p) c= ((the carrier of S) \ ({IC S} \/ NAT))
 by RELAT_1:87,XBOOLE_1:7,34;
  then
A1: dom(DataPart p) c= (the carrier of S) \ NAT by XBOOLE_1:1;
  dom ProgramPart q c= NAT by RELAT_1:87;
  hence thesis by A1,XBOOLE_1:64,79;
end;

theorem Th16:
  for p being PartState of S, l being Element of NAT st l
  in dom p holds l in dom ProgramPart p
proof
  let p be PartState of S, l be Element of NAT;
A1: dom ProgramPart p = dom p /\ NAT by RELAT_1:90;
  assume
  l in dom p;
  hence thesis by A1,XBOOLE_0:def 4;
end;

theorem
  for p being data-only PartState of S, q being PartState of S
  holds p c= q iff p c= DataPart(q)
proof
  let p be data-only PartState of S, q be PartState of S;
  set X = (the carrier of S) \ ({IC S} \/ NAT);
A1: q|X c= q by RELAT_1:88;
  hereby
X:  X \/ ({IC S} \/ NAT) = (the carrier of S) \/ ({IC S} \/ NAT)
     by XBOOLE_1:39;
    dom p c= the carrier of S by RELAT_1:def 18;
    then
A2: dom p c= X \/ ({IC S} \/ NAT) by X,XBOOLE_1:10;
    assume
    p c= q;
    then
A3: p|X c= DataPart q by RELAT_1:105;
    dom p misses {IC S} \/ NAT by Def50;
    hence p c= DataPart q by A3,A2,RELAT_1:97,XBOOLE_1:73;
  end;
  assume p c= DataPart q;
  hence thesis by A1,XBOOLE_1:1;
end;

theorem Th18:
  for S being IC-Ins-separated definite realistic (non empty
  stored-program COM-Struct over N) for p being PartState of S st IC S in
  dom p holds p = Start-At(IC p,S) +* ProgramPart p +* DataPart p
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  COM-Struct over N);
  let p be PartState of S;
  assume IC S in dom p;
  then
A2: {IC S} is Subset of dom p by SUBSET_1:63;
A3: NAT c= the carrier of S by Def3;
A4: ({IC S} \/ (NAT) \/ ((the carrier of S) \ ({IC S} \/ NAT))) = ((the
  carrier of S) \/ ({IC S} \/ NAT)) by XBOOLE_1:39
    .= the carrier of S by A3,XBOOLE_1:8,12;
A5: dom p c= the carrier of S by RELAT_1:def 18;
A6: now
    let x be set;
    assume
A7: x in dom p;
    then
A8: x in {IC S} \/ (NAT) or x in (the carrier of S) \ ({IC S} \/ NAT) by A5,A4,
XBOOLE_0:def 3;
    per cases by A8,XBOOLE_0:def 3;
    suppose
A9:   x in {IC S};
      {IC S} = dom Start-At(IC p,S) by FUNCOP_1:19;
      then IC S in dom Start-At(IC p,S) by TARSKI:def 1;
      then
A10:  IC S in dom Start-At(IC p,S) \/ dom ProgramPart p by XBOOLE_0:def 3;
      then IC S in dom (Start-At(IC p,S) +* ProgramPart p) by FUNCT_4:def 1;
      then
A11:  IC S in dom (Start-At(IC p,S) +* ProgramPart p) \/ dom DataPart p by
XBOOLE_0:def 3;
A12:  not IC S in dom (ProgramPart p) by Th12;
A13:  x = IC S by A9,TARSKI:def 1;
      not IC S in dom (DataPart p) by Th11;
      then
      (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x = (Start-At(IC p,S)
      +* ProgramPart p).x by A13,A11,FUNCT_4:def 1
        .= (Start-At(IC p,S)).x by A13,A10,A12,FUNCT_4:def 1
        .= IC p by A13,FUNCOP_1:87
        .= p.IC S;
      hence p.x = (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x by A9,
TARSKI:def 1;
    end;
    suppose
      x in (the carrier of S) \ ({IC S} \/ NAT);
      then x in dom p /\ ((the carrier of S) \ ({IC S} \/ NAT)) by A7,
XBOOLE_0:def 4;
      then
A14:  x in dom (p | ((the carrier of S) \ ({IC S} \/ NAT))) by RELAT_1:90;
      then x in dom (Start-At(IC p,S) +* ProgramPart p) \/ dom (p | ((the
      carrier of S) \ ({IC S} \/ NAT))) by XBOOLE_0:def 3;
      then (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x = (p | ((the
      carrier of S) \ ({IC S} \/ NAT))).x by A14,FUNCT_4:def 1
        .= p.x by A14,FUNCT_1:70;
      hence p.x = (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x;
    end;
    suppose
      x in NAT;
      then x in dom p /\ NAT by A7,XBOOLE_0:def 4;
      then
A15:  x in dom (p | NAT) by RELAT_1:90;
      dom (DataPart p) misses dom (ProgramPart p) by Th15;
      then
A16:  not x in dom (DataPart p) by A15,XBOOLE_0:3;
A17:  x in dom (Start-At(IC p,S)) \/ dom (ProgramPart p) by A15,XBOOLE_0:def 3;
      then x in dom (Start-At(IC p,S) +* ProgramPart p) by FUNCT_4:def 1;
      then x in dom (Start-At(IC p,S) +* ProgramPart p) \/ dom (DataPart p) by
XBOOLE_0:def 3;
      then
      (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x = (Start-At(IC p,S)
      +* ProgramPart p).x by A16,FUNCT_4:def 1
        .= (p | NAT ).x by A15,A17,FUNCT_4:def 1
        .= p.x by A15,FUNCT_1:70;
      hence p.x = (Start-At(IC p,S) +* ProgramPart p +* DataPart p).x;
    end;
  end;
X: dom p c= the carrier of S by RELAT_1:def 18;
  dom(Start-At(IC p,S) +* ProgramPart p +* DataPart p) = dom (Start-At(IC p
  ,S) +* ProgramPart p) \/ dom (DataPart p) by FUNCT_4:def 1
    .= dom (Start-At(IC p,S)) \/ dom (ProgramPart p) \/ dom (DataPart p) by
FUNCT_4:def 1
    .= {IC S} \/ dom (p | NAT) \/ dom(DataPart p) by FUNCOP_1:19
    .= dom p /\ {IC S} \/ dom (p|NAT) \/ dom(p|((the carrier of S) \ ({IC S}
  \/ NAT))) by A2,XBOOLE_1:28
    .= dom p /\ {IC S} \/ dom p /\ (NAT) \/ dom(p|((the carrier of S) \ ({IC
  S} \/ NAT))) by RELAT_1:90
    .= dom p /\ {IC S} \/ dom p /\ (NAT) \/ dom p /\ ((the carrier of S) \ ({
  IC S} \/ NAT)) by RELAT_1:90
    .= dom p /\ ({IC S} \/ (NAT)) \/ dom p /\ ((the carrier of S) \ ({IC S}
  \/ NAT)) by XBOOLE_1:23
    .= dom p /\ the carrier of S by A4,XBOOLE_1:23
    .= dom p by X,XBOOLE_1:28;
  hence thesis by A6,FUNCT_1:9;
end;

definition
  let N,S;
  let IT be PartFunc of FinPartSt S,FinPartSt S;
  attr IT is data-only means
  for p being PartState of S st p in dom IT
  holds p is data-only & for q being PartState of S st q = IT.p holds q is
  data-only;
end;

theorem
  for S being IC-Ins-separated definite realistic (non empty
  stored-program COM-Struct over N) for p being PartState of S st IC S in
  dom p holds p is not NAT-defined
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  COM-Struct over N);
  let p be PartState of S;
  assume
A1: IC S in dom p;
  assume p is NAT-defined;
  then dom p = dom ProgramPart p by RELAT_1:209;
  hence contradiction by A1,Th12;
end;

theorem
  for S being IC-Ins-separated definite realistic (non empty
  stored-program COM-Struct over N) for s being State of S, iloc being
Element of NAT, a being Element of NAT holds s.a = (s +*
  Start-At(iloc,S)).a
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  COM-Struct over N);
  let s be State of S, iloc be Element of NAT, a be
  Element of NAT;
X: a in NAT;
  NAT c= the carrier of S by Def3;
  then a in the carrier of S by X;
  then a in dom s by PARTFUN1:def 4;
  then
A1: dom (Start-At(iloc,S)) = {IC S} & a in dom s \/ dom (Start-At(iloc,S)) by
FUNCOP_1:19,XBOOLE_0:def 3;
  a <> IC S by Def21;
  then not a in {IC S} by TARSKI:def 1;
  hence thesis by A1,FUNCT_4:def 1;
end;

theorem
  for N being with_non-empty_elements set, S
being stored-program COM-Struct over N, s being State of S holds NAT c= dom s
                by LmL;

theorem
  for N being with_non-empty_elements set, S being IC-Ins-separated (non
  empty stored-program COM-Struct over N), s being State of S holds IC s in
  dom s
proof
  let N be with_non-empty_elements set, S be IC-Ins-separated (non empty
  stored-program COM-Struct over N);
  let s be State of S;
X:      IC s in NAT;
        NAT c= the carrier of S by Def3;
        then IC s in the carrier of S by X;
  hence thesis by PARTFUN1:def 4;
end;

theorem Th23:
  for N being with_non-empty_elements set, S being non empty
  stored-program COM-Struct over N, s being State of S, l being
  Element of NAT holds l in dom s
proof
  let N be with_non-empty_elements set, S be non empty stored-program
  COM-Struct over N;
  let s be State of S, l be Element of NAT;
X:      l in NAT;
        NAT c= the carrier of S by Def3;
        then l in the carrier of S by X;
  hence thesis by PARTFUN1:def 4;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be definite (non empty stored-program COM-Struct over N);
  let s be NAT-defined PartState of S;
  let f be Function of the Instructions of S, the Instructions of S;
  redefine func f*s -> NAT-defined PartState of S;
  coherence;
end;

theorem
  for N being with_non-empty_elements non empty set, S being realistic
  IC-Ins-separated (non empty COM-Struct over N), s1, s2 being State of S
  holds s1,s2 equal_outside NAT implies IC s1 = IC s2
proof
  let N be with_non-empty_elements non empty set,
      S be realistic IC-Ins-separated (non
  empty COM-Struct over N), s1, s2 be State of S;
  assume
A1: s1,s2 equal_outside NAT;
A2: not IC S in NAT by Def21;
  IC S in dom s2 by Th9;
  then IC S in dom s2 \ NAT by A2,XBOOLE_0:def 5;
  then
A3: IC S in dom s2 /\ (dom s2 \ NAT) by XBOOLE_0:def 4;
  IC S in dom s1 by Th9;
  then IC S in dom s1 \ NAT by A2,XBOOLE_0:def 5;
  then IC S in dom s1 /\ (dom s1 \ NAT) by XBOOLE_0:def 4;
  hence IC s1 = (s1|(dom s1 \ NAT)).IC S by FUNCT_1:71
    .= (s2|(dom s2 \ NAT)).IC S by A1,FUNCT_7:def 2
    .= IC s2 by A3,FUNCT_1:71;
end;

definition
  let N be with_non-empty_elements set;
  let S be IC-Ins-separated definite (non empty stored-program COM-Struct over
  N);
  let s be State of S, l be Element of NAT, i be Instruction of S;
  redefine func s+*(l,i) -> State of S;
  coherence
  proof
    now
      let x be set;
      assume
A3:   x in dom(s+*(l,i));
B3:   x in dom s by A3,FUNCT_7:32;
      per cases;
      suppose
A4:     x = l;
        then
A5:     (the Object-Kind of S).x = the Instructions of S by Def8;
X:      l in NAT;
        NAT c= the carrier of S by Def3;
        then l in the carrier of S by X;
        then l in dom s by PARTFUN1:def 4;
        then (s+*(l,i)).x = i by A4,FUNCT_7:33;
        hence (s+*(l,i)).x in (the Object-Kind of S).x by A5;
      end;
      suppose
        x <> l;
        then (s+*(l,i)).x = s.x by FUNCT_7:34;
        hence (s+*(l,i)).x in (the Object-Kind of S).x by B3,FUNCT_1:def 20;
      end;
    end;
    hence thesis by FUNCT_1:def 20;
  end;
end;

theorem
  for S being COM-Struct over N, p being Element of FinPartSt S holds
  p is FinPartState of S
proof
  let S be COM-Struct over N;
  let p be Element of FinPartSt S;
  p in FinPartSt S;
  then ex q being Element of sproduct the Object-Kind of S st q = p & q is
  finite;
  hence thesis;
end;

theorem Th26:
  for N being with_non-empty_elements non empty set,
      S being IC-Ins-separated realistic (non empty COM-Struct over N),
      l being Element of NAT holds dom Start-At(l,S) misses NAT
proof
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated realistic (non empty COM-Struct over N);
  let l be Element of NAT;
  dom Start-At(l,S) = {IC S} & not IC S in NAT by Def21,FUNCOP_1:19;
  hence thesis by ZFMISC_1:56;
end;

theorem Th135:
  for N being with_non-empty_elements non empty set, S
  being IC-Ins-separated realistic (non empty COM-Struct over N), l being
  Element of NAT holds ProgramPart Start-At(l,S) = {}
proof
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated realistic (non empty COM-Struct over N);
  let l be Element of NAT;
  dom Start-At(l,S) misses NAT by Th26;
  hence thesis by RELAT_1:187;
end;

registration
  let N be set;
  let S be non empty COM-Struct over N;
  let p be PartState of S;
  cluster DataPart p -> data-only;
  coherence
  proof
    ((the carrier of S) \ ({IC S} \/ NAT)) c= (the carrier of S) \ NAT & dom
( DataPart p) c= ((the carrier of S) \ ({IC S} \/ NAT))
 by RELAT_1:87,XBOOLE_1:7,34;
    then dom(DataPart p) c= (the carrier of S) \ NAT by XBOOLE_1:1;
    then
A1: dom DataPart p misses NAT by XBOOLE_1:64,79;
    dom DataPart p misses {IC S} by Th11,ZFMISC_1:56;
    hence dom DataPart p misses {IC S} \/ NAT by A1,XBOOLE_1:70;
  end;
end;

theorem
  for N being with_non-empty_elements set,
      S being non empty COM-Struct over N, p be
  data-only PartState of S holds ProgramPart p = {}
proof
  let N be with_non-empty_elements set, S be non empty COM-Struct over N,
      p be data-only
  PartState of S;
  dom p misses {IC S} \/ NAT by Def50;
  then dom p misses NAT by XBOOLE_1:70;
  hence thesis by RELAT_1:187;
end;

theorem
  for N being with_non-empty_elements non empty set, S
  being IC-Ins-separated realistic (non empty COM-Struct over N), l,l1 being
  Element of NAT holds not l in dom Start-At(l1,S)
proof
  let N be with_non-empty_elements non empty set, S be
  IC-Ins-separated realistic (non empty COM-Struct over N), l,l1 be
  Element of NAT;
  assume
  l in dom Start-At(l1,S);
  then NAT meets dom Start-At(l1,S) by XBOOLE_0:3;
  hence thesis by Th26;
end;

theorem Th30:
  for N being with_non-empty_elements non empty set, S
  being IC-Ins-separated (non empty COM-Struct over N), l being
  Element of NAT holds DataPart Start-At(l,S) = {}
proof
  let N be with_non-empty_elements non empty set, S be
IC-Ins-separated (non empty COM-Struct over N), l be Element of NAT;
  Data-Locations S misses {IC S} \/ NAT by XBOOLE_1:79;
  then Data-Locations S misses {IC S} by XBOOLE_1:70;
  then Data-Locations S misses dom Start-At(l,S) by FUNCOP_1:19;
  hence thesis by RELAT_1:95;
end;

theorem Th31:
  for S being non empty COM-Struct over N, p being PartState
  of S holds p is data-only iff dom p c= Data-Locations S
proof
  let S be non empty COM-Struct over N, p be PartState of S;
  thus p is data-only implies dom p c= Data-Locations S
  proof
X: dom p c= the carrier of S by RELAT_1:def 18;
    assume dom p misses {IC S} \/ NAT;
    hence thesis by X,XBOOLE_1:86;
  end;
  assume
  dom p c= Data-Locations S;
  hence dom p misses {IC S} \/ NAT by XBOOLE_1:106;
end;

theorem
  for S being IC-Ins-separated definite realistic (non empty
  stored-program COM-Struct over N), s be State of S for X being set st X c=
  NAT holds rng(s|X) c= the Instructions of S
proof
  let S be IC-Ins-separated definite realistic (non empty stored-program
  COM-Struct over N);
  let s be State of S;
  let X be set such that
A1: X c= NAT;
  let x be set;
  assume
  x in rng(s|X);
  then consider y being set such that
A2: y in dom(s|X) and
A3: (s|X).y = x by FUNCT_1:def 5;
A4: dom(s|X) c= X by RELAT_1:87;
  then dom(s|X) c= NAT by A1,XBOOLE_1:1;
  then reconsider y as Element of NAT by A2;
  x = s.y by A2,A3,A4,FUNCT_1:72;
  hence thesis;
end;

theorem
  for S being non empty COM-Struct over N, p being PartState of S
  holds p is data-only iff DataPart p = p
proof
  let S be non empty COM-Struct over N, p be PartState of S;
  thus p is data-only implies DataPart p = p
  proof
    assume
    p is data-only;
    then dom p c= Data-Locations S by Th31;
    hence thesis by RELAT_1:97;
  end;
  assume
  DataPart p = p;
  then dom p c= Data-Locations S by RELAT_1:87;
  hence thesis by Th31;
end;

theorem
 for N being with_non-empty_elements set for S being
  (non empty stored-program COM-Struct over N)
   for s being State of S
   holds dom ProgramPart s = NAT by LmU;

theorem
 for N being with_non-empty_elements set,
     S be COM-Struct over N
 for p being FinPartState of S holds p in FinPartSt S by LMT;

theorem   :: temporary
 for N being with_non-empty_elements set,
     S be definite (non empty stored-program COM-Struct over N),
     f being NAT-defined (the Instructions of S)-valued Function
     holds f is PartState of S;

theorem :: to be removed
 for S be definite IC-Ins-separated realistic
      (non empty stored-program COM-Struct over N),
     n be Nat, i be Instruction of S
 holds (IC S,n) --> (n,i) is PartState of S
 proof
  let S be definite IC-Ins-separated realistic
      (non empty stored-program COM-Struct over N),
     n be Nat, i be Instruction of S;
  set p = (IC S,n) --> (n,i);
y: n in NAT by ORDINAL1:def 13;
U: dom p = {IC S,n} by FUNCT_4:65;
V: IC S <> n by y,Def21;
  p is (the Object-Kind of S)-compatible
   proof let x be set;
    assume
Z:   x in dom p;
    per cases by Z,U,TARSKI:def 2;
    suppose
S:   x = IC S;
     then
I:   p.x = n by V,FUNCT_4:66;
     ObjectKind IC S = NAT by Def11;
    hence p.x in (the Object-Kind of S).x by I,S,ORDINAL1:def 13;
    end;
    suppose
S:   x = n;
     then
I:    p.x = i by FUNCT_4:66;
     (the Object-Kind of S).x = the Instructions of S by Def8,S,y;
    hence p.x in (the Object-Kind of S).x by I;
    end;
   end;
 hence (IC S,n) --> (n,i) is PartState of S;
 end;

theorem
 for N being with_non-empty_elements non empty set
 for S being
  IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)
   for s being State of S
 for i being natural number holds
 (ProgramPart s)/.i = s.i by BWL1;

theorem
 for N being with_non-empty_elements non empty set
 for S being
  IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)
   for s1,s2 being State of S
 holds ProgramPart(s1+*DataPart s2) = ProgramPart s1
proof
 let N be with_non-empty_elements non empty set;
 let S be IC-Ins-separated definite
     (non empty stored-program COM-Struct over N);
 let s1,s2 be State of S;
   NAT c= {IC S} \/ NAT by XBOOLE_1:7;
   then
   Data-Locations S misses NAT by XBOOLE_1:85;
   then
X: ProgramPart(DataPart s2) = {} by RELAT_1:207;
 thus ProgramPart(s1+*DataPart s2)
       = ProgramPart s1+*ProgramPart(DataPart s2) by FUNCT_4:75
      .= ProgramPart s1 by X,FUNCT_4:22;
end;

theorem Th155:
  for N be set, S be non empty COM-Struct over N
  for d be data-only PartState of S
  holds dom d misses NAT
 proof
  let N be set, S be non empty COM-Struct over N;
  let d be data-only PartState of S;
   dom d misses {IC S} \/ NAT by Def50;
  hence dom d misses NAT by XBOOLE_1:70;
 end;

begin :: AMISTD_2

theorem
  for S being definite (non empty stored-program COM-Struct over
N), I being Element of the Instructions of S, s being State of S holds s +*
  ((NAT) --> I) is State of S;

registration
  let N be set, S be COM-Struct over N;
  cluster empty -> (the Instructions of S)-valued
   NAT-defined FinPartState of S;
  coherence
  proof
    let F be FinPartState of S;
    assume
Z:   F is empty;
    then rng F = {};
    hence rng F c= the Instructions of S by XBOOLE_1:2;
     dom F = {} by Z;
    hence dom F c= NAT by XBOOLE_1:2;
  end;
end;

registration
  let N be set, S be COM-Struct over N;
  cluster empty FinPartState of S;
  existence
  proof
    reconsider a = {} as FinPartState of S by FUNCT_1:174,RELAT_1:206;
    take a;
    thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite (non
  empty stored-program COM-Struct over N);
  cluster non empty trivial NAT-defined
    (the Instructions of S)-valued FinPartState of S;
  existence
  proof
    consider l being Element of NAT, I being Instruction of S;
    take l .--> I;
    thus thesis;
  end;
end;

begin :: Closedness of finite partial states

notation
  let N be set, S be COM-Struct over N;
  let i be Instruction of S;
  synonym Load i for <%i%>;
end;

registration
  let N be set;
  let S be definite (non empty stored-program COM-Struct over N);
 let ins be Element of the Instructions of S;
 cluster Load ins -> (the carrier of S)-defined;
 coherence;
end;

registration
  let N,S;
  cluster initial non empty trivial NAT-defined
     (the Instructions of S)-valued FinPartState of S;
  existence
  proof
    reconsider p = <%the Instruction of S%> as FinPartState of S;
   take p;
   thus thesis;
  end;
end;

Lm7: now
  let N;
  let S be (IC-Ins-separated definite (non empty
  stored-program COM-Struct over N));
  set F = <%halt S%>;
A1: dom F = {0} by FUNCOP_1:19;
  then
A2: card dom F = 1 by CARD_1:50;
A3: LastLoc F = card F -' 1 by AFINSQ_1:74
    .= card dom F -' 1
    .= 0 by A2,XREAL_1:234;
  hence F.(LastLoc F) = halt S by FUNCOP_1:87;
  let l be Element of NAT such that
  F.l = halt S;
  assume l in dom F;
  hence l = LastLoc F by A1,A3,TARSKI:def 1;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite (non empty stored-program COM-Struct over N),
  F be non empty NAT-defined FinPartState of S;
  attr F is halt-ending means
  :Def25:
  F.(LastLoc F) = halt S;
  attr F is unique-halt means
  :Def26:
  for f being Element of NAT st
  F.f = halt S & f in dom F holds f = LastLoc F;
end;

registration let N,S;
  cluster halt-ending unique-halt trivial (initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S);
  existence
  proof
    reconsider F = <%halt S%> as initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S;
    take F;
    thus F.(LastLoc F) = halt S by Lm7;
    thus for f being Element of NAT st F.f = halt S & f in dom F
    holds f = LastLoc F by Lm7;
    thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be realistic (IC-Ins-separated definite
    (non empty
  stored-program COM-Struct over N));
  cluster trivial initial non empty
  (NAT-defined (the Instructions of S)-valued FinPartState of S);
  existence
  proof
    reconsider F = <%halt S%> as initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S;
    take F;
    thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be realistic (IC-Ins-separated definite
    (non empty
  stored-program COM-Struct over N));
  cluster halt-ending unique-halt trivial (initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S);
  existence
  proof
    reconsider F = <%halt S%> as initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S;
    take F;
    thus F.(LastLoc F) = halt S by Lm7;
    thus for f being Element of NAT st F.f = halt S & f in dom F
    holds f = LastLoc F by Lm7;
    thus thesis;
  end;
end;

definition let N,S;
  mode pre-Macro of S is halt-ending unique-halt (initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S);
end;

theorem
  for ins being Element of the Instructions of Trivial-COM(N) holds
  InsCode ins = 0
proof
  let ins be Element of the Instructions of Trivial-COM(N);
  the Instructions of Trivial-COM(N) = {[0,{},{}]} by Def2;
  then ins = [0,{},{}] by TARSKI:def 1;
  hence thesis by RECDEF_2:def 1;
end;

begin :: Addenda

reserve i, j, k for natural number,
  f for FinPartState of S;

theorem
  for l1, l2 being Element of NAT holds Start-At(l1+k,S) =
  Start-At(l2+k,S) iff Start-At(l1,S) = Start-At(l2,S)
proof
  let l1,l2 be Element of NAT;
  hereby
    assume Start-At(l1+k,S) = Start-At(l2+k,S);
    then {[IC S, l1+k]} = IC S .--> (l2+k) by FUNCT_4:87;
    then {[IC S, l1+k]} = {[IC S, l2+k]} by FUNCT_4:87;
    then [IC S, l1+k] = [IC S, l2+k] by ZFMISC_1:6;
    then l1+k = l2+k by ZFMISC_1:33;
    hence Start-At(l1,S) = Start-At(l2,S);
  end;
  assume Start-At(l1,S) = Start-At(l2,S);
  then {[IC S, l1]} = Start-At(l2,S) by FUNCT_4:87;
  then {[IC S, l1]} = {[IC S, l2]} by FUNCT_4:87;
  then [IC S, l1] = [IC S, l2] by ZFMISC_1:6;
  hence thesis by ZFMISC_1:33;
end;

theorem
  for l1, l2 being Element of NAT st Start-At(l1,S) = Start-At(
  l2,S) holds Start-At(l1 -' k,S) = Start-At(l2 -' k,S)
proof
  let l1, l2 be Element of NAT;
  assume Start-At(l1,S) = Start-At(l2,S);
  then {[IC S, l1]} = Start-At(l2,S) by FUNCT_4:87
    .= {[IC S, l2]} by FUNCT_4:87;
  then [IC S, l1] = [IC S, l2] by ZFMISC_1:6;
  hence thesis by ZFMISC_1:33;
end;

begin :: SCMNORM

definition
  let l be Element of NAT;
  redefine func succ l -> Element of NAT;
  coherence;
end;

reserve m,j for Element of NAT;

registration
  let N be set;
  let S be COM-Struct over N;
  let p be NAT-defined (the Instructions of S)-valued Function,
      k be Element of NAT;
  cluster Shift(p,k) -> (the Instructions of S)-valued;
  coherence;
end;

definition
  let N be set;
  let S be COM-Struct over N;
  mode preProgram of S is
   NAT-defined (the Instructions of S)-valued FinPartState of S;
end;

registration
  let N be with_non-empty_elements set;
  let S be COM-Struct over N;
  cluster empty FinPartState of S;
  existence
  proof
    {} is FinPartState of S by FUNCT_1:174,RELAT_1:206;
    hence thesis;
  end;
end;

registration
  let N be set;
  let S be COM-Struct over N;
  cluster empty -> NAT-defined FinPartState of S;
  coherence;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be definite (non empty stored-program COM-Struct over N);
  func Stop S -> preProgram of S equals
  <% halt S %>;
  coherence;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be definite (non empty stored-program COM-Struct over N);
  cluster Stop S -> initial non empty;
  coherence;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be definite (non empty stored-program COM-Struct over N);
  cluster initial non empty preProgram of S;
  existence
  proof
    take Stop S;
    thus thesis;
  end;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be definite (non empty stored-program COM-Struct over N);
  mode Program of S is initial non empty preProgram of S;
end;

theorem
  0 in dom Stop S
proof dom Stop S = 1 by AFINSQ_1:36;
  hence thesis by CARD_1:87,TARSKI:def 1;
end;

theorem Th46:
  card Stop S = 1 by AFINSQ_1:36;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated definite realistic
  (non empty stored-program COM-Struct over N);
  let I be initial FinPartState of S;
  cluster ProgramPart I -> initial Function;
  coherence
  proof
    ProgramPart I is initial
    proof
      let m,n be Nat such that
A1:   n in dom ProgramPart I and
A2:   m < n;
      m in NAT by ORDINAL1:def 13;
      then
A3:   m is Element of NAT;
      ProgramPart I c= I by RELAT_1:88;
      then dom ProgramPart I c= dom I by RELAT_1:25;
      then m in dom I by A1,A2,AFINSQ_1:def 13;
      hence thesis by A3,Th16;
    end;
    hence thesis;
  end;
end;

reserve i,j,k for Element of NAT;

definition
  let N,S;
  let p be PartState of S, k be Nat;
  func IncrIC(p,k) -> PartState of S equals
  p +* Start-At(IC p+k,S);
  correctness;
end;

registration
  let N,S;
  let p be FinPartState of S, k be Nat;
  cluster IncrIC(p,k) -> finite;
  coherence;
end;

theorem
  for S being realistic IC-Ins-separated (non empty COM-Struct over N)
  for k being Element of NAT
  holds Start-At(k,S)|NAT = {}
  proof let S be realistic IC-Ins-separated (non empty COM-Struct over N);
   let k be Element of NAT;
A:  dom Start-At(k,S) = {IC S} by FUNCOP_1:19;
    not IC S in NAT by Def21;
    then dom Start-At(k,S) misses NAT by A,ZFMISC_1:56;
   hence thesis by RELAT_1:95;
  end;

theorem Th48:
  for p being FinPartState of S, k being Element of NAT
  holds DataPart IncrIC(p,k) = DataPart p
proof
  let p be FinPartState of S, k be Element of NAT;
  thus DataPart IncrIC(p,k)
  = DataPart p +* DataPart Start-At(IC p+k,S) by FUNCT_4:75
    .= DataPart p +* {} by Th30
    .= DataPart p by FUNCT_4:22;
end;

theorem Th49:
  Data-Locations S c= dom s
proof
  dom s = the carrier of S by PARTFUN1:def 4;
  hence thesis;
end;

theorem Th50:
  dom DataPart s = Data-Locations S
proof
  Data-Locations S c= dom s by Th49;
  hence thesis by RELAT_1:91;
end;

theorem Th51:
  NAT misses Data-Locations S
proof
  Data-Locations S misses {IC S} \/ NAT by XBOOLE_1:79;
  hence thesis by XBOOLE_1:70;
end;

theorem Th52:
  IC S in dom Start-At(l,S)
proof
  dom Start-At(l,S) = {IC S} by FUNCOP_1:19;
  hence thesis by TARSKI:def 1;
end;

theorem Th53:
  IC S in dom IncrIC(p,k)
proof
A1: dom IncrIC(p,k) = dom p \/ dom Start-At(IC p+k,S) by FUNCT_4:def 1;
  IC S in dom Start-At(IC p+k,S) by Th52;
  hence thesis by A1,XBOOLE_0:def 3;
end;

theorem Th54:
  for p being FinPartState of S, k being Element of NAT
   holds IC IncrIC (p,k) = IC p + k
proof
  let p be FinPartState of S, k be Element of NAT;
    dom Start-At(IC p+k,S) = {IC S} by FUNCOP_1:19;
    then
A1: IC S in dom Start-At(IC p+k,S) by TARSKI:def 1;
  thus IC IncrIC (p,k) = IncrIC (p,k).IC S
    .= (Start-At((IC p)+k,S)).IC S by A1,FUNCT_4:14
    .= IC p +k by FUNCOP_1:87;
end;

theorem
  IncrIC(p,k).IC S = IC p + k
proof
 IC S in dom Start-At(IC p+k,S) by Th52;
  hence IncrIC(p,k).IC S = (Start-At(IC p+k,S)).IC S by FUNCT_4:14
    .= IC Start-At(IC p + k,S)
    .= IC p + k by FUNCOP_1:87;
end;

theorem Th56:
  not IC S in Data-Locations S
proof
  assume IC S in Data-Locations S;
  then not IC S in {IC S} \/ NAT by XBOOLE_0:def 5;
  then not IC S in {IC S} by XBOOLE_0:def 3;
  hence contradiction by TARSKI:def 1;
end;

theorem Th22:
  for d being data-only PartState of S
  holds not IC S in dom d
proof
  let d be data-only PartState of S;
  dom d c= Data-Locations S by Th31;
  hence thesis by Th56;
end;

theorem Th58:
  for d being data-only FinPartState of S
  holds IC (p+*d) = IC p
proof
  let d be data-only FinPartState of S;
A2: not IC S in dom d by Th22;
  thus IC(p+*d) = (p+*d).IC S
    .= p.IC S by A2,FUNCT_4:12
    .= IC p;
end;

theorem Th24:
  for d being data-only FinPartState of S
  holds d tolerates Start-At(l,S)
proof
  let d be data-only FinPartState of S;
  dom Start-At(l,S) = {IC S} by FUNCOP_1:19;
  then dom d misses dom Start-At(l,S) by Th22,ZFMISC_1:56;
  hence thesis by PARTFUN1:138;
end;

theorem Th60:
  for d being data-only FinPartState of S
  holds IncrIC(p+*d,k) = IncrIC(p,k) +* d
proof
  let d be data-only FinPartState of S;
A1: d tolerates Start-At(IC p+k,S) by Th24;
  thus IncrIC(p+*d,k) = p +* d +* Start-At(IC p+k,S) by Th58
    .= p +* (d +* Start-At(IC p+k,S)) by FUNCT_4:15
    .= p +* (Start-At(IC p+k,S) +* d) by A1,FUNCT_4:35
    .= IncrIC(p,k) +* d by FUNCT_4:15;
end;

theorem
  for d being data-only FinPartState of S,
  f being finite NAT-defined (the Instructions of S)-valued Function
  holds d tolerates f
proof
  let d be data-only FinPartState of S,
  f be finite NAT-defined (the Instructions of S)-valued Function;
A1: dom f c= NAT by RELAT_1:def 18;
  dom d c= Data-Locations S by Th31;
  then dom d misses dom f by A1,Th51,XBOOLE_1:64;
  hence thesis by PARTFUN1:138;
end;

theorem
  for d being data-only PartState of S
  holds ProgramPart IncrIC(d,k) = {}
proof
  let d be data-only PartState of S;
A1: dom IncrIC(d,k) = dom d \/ dom Start-At(IC d+k,S) by FUNCT_4:def 1;
A2: dom d c= Data-Locations S by Th31;
  NAT misses Data-Locations S by Th51;
  then
A3: dom d misses NAT by A2,XBOOLE_1:63;
  dom Start-At(IC d+k,S) misses NAT by Th26;
  then dom IncrIC(d,k) misses NAT by A1,A3,XBOOLE_1:70;
  hence thesis by RELAT_1:95;
end;

theorem
  for p being FinPartState of S,k being Element of NAT holds
  Start-At(IC p+k,S) c= IncrIC (p,k)
proof
  let p be FinPartState of S, k be Element of NAT;
A1: IC IncrIC(p,k) = IC p + k by Th54;
A2: IC S in dom (IncrIC(p,k)) by Th53;
A3: Start-At(IC p+k,S) = {[IC S,IC p + k]} & [IC S,IC p + k] in
  IncrIC(p,k) by A2,A1,FUNCT_1:def 4,FUNCT_4:87;
  for x being set st x in Start-At(IC p+k,S)
    holds x in IncrIC (p,k) by A3,TARSKI:def 1;
 hence thesis by TARSKI:def 3;
end;

theorem
 IC Start-At(l,S) = l by FUNCOP_1:87;

:: pomocnicze pojecia na czas rewizji:

definition let N,S; let p be PartState of S;
 attr p is program-free means
:Def29: p|NAT = {};
 func NPP p -> PartState of S equals
  p \ ProgramPart p;
 coherence;
end;

theorem Th65:
 for p being PartState of S
  holds NPP p = p|((the carrier of S)\NAT)
proof let p be PartState of S;
    dom p c= the carrier of S by RELAT_1:def 18;
 hence NPP p = p|((the carrier of S)\NAT) by RELAT_1:211;
end;

registration let N,S; let p be FinPartState of S;
 cluster NPP p -> finite;
 coherence;
end;

registration let N,S;
 cluster data-only -> program-free PartState of S;
 coherence
  proof let p be PartState of S;
   assume dom p misses {IC S} \/ NAT;
    then dom p misses NAT by XBOOLE_1:70;
   hence p|NAT = {} by RELAT_1:95;
  end;
end;

registration let N,S;
 cluster program-free FinPartState of S;
 existence
  proof
   take the data-only FinPartState of S;
   thus thesis;
  end;
end;

theorem Th66:
 for p being PartState of S, d being program-free PartState of S
  holds ProgramPart(p+*d) = ProgramPart p
 proof
  let p be PartState of S, d being program-free PartState of S;
  thus ProgramPart(p+*d) = ProgramPart p +* d|NAT by FUNCT_4:75
      .= ProgramPart p +* {} by Def29
      .= ProgramPart p by FUNCT_4:22;
 end;

theorem Th67:
 for p being PartState of S, d being data-only PartState of S
  holds NPP(p+*d) = NPP p +* d
 proof
  let p be PartState of S, d be data-only PartState of S;
  X:  dom d misses NAT by Th155;
Y:  dom d c= the carrier of S by RELAT_1:def 18;
    dom p c= the carrier of S by RELAT_1:def 18;
    then
X1: NPP p = p|((the carrier of S)\NAT) by RELAT_1:211;
    dom(p+*d) c= the carrier of S by RELAT_1:def 18;
    then
X2: NPP(p+*d) = (p+*d)|((the carrier of S)\NAT) by RELAT_1:211;
   d|((the carrier of S)\NAT) = d|(the carrier of S)\ d | NAT by RELAT_1:109
      .= d|(the carrier of S)\ {} by X,RELAT_1:95
      .= d|(the carrier of S)
      .= d by Y,RELAT_1:97;
  hence NPP(p+*d)= NPP p +* d by X1,X2,FUNCT_4:75;
 end;

theorem Th43:
 for s being State of S
  holds s = NPP s \/ ProgramPart s by RELAT_1:88,XBOOLE_1:45;

theorem
 for s being State of S
  holds the carrier of S = dom NPP s \/ dom ProgramPart s
proof let s be State of S;
 thus the carrier of S = dom s by PARTFUN1:def 4
    .= dom(NPP s \/ ProgramPart s) by Th43
    .= dom NPP s \/ dom ProgramPart s by RELAT_1:13;
end;

theorem Th45:
 for p being PartState of S st IC S in dom p
  holds dom NPP p = {IC S} \/ dom DataPart p
proof
 let p be PartState of S;
A: dom Start-At(IC p,S) = {IC S} by FUNCOP_1:19;
 assume IC S in dom p;
  then p = Start-At(IC p,S) +* ProgramPart p +* DataPart p by Th18;
  then
B: dom p = dom(Start-At(IC p,S) +* ProgramPart p) \/ dom DataPart p
                      by FUNCT_4:def 1
     .= {IC S} \/ dom(ProgramPart p) \/ dom DataPart p by A,FUNCT_4:def 1
     .= dom ProgramPart p \/ ({IC S} \/ dom DataPart p) by XBOOLE_1:4;
C:  {IC S} misses dom ProgramPart p by Th14;
   dom DataPart p misses dom ProgramPart p by Th15;
  then {IC S} \/ dom DataPart p misses dom ProgramPart p by C,XBOOLE_1:70;
  then dom p \ dom ProgramPart p = {IC S} \/ dom DataPart p by B,XBOOLE_1:88;
 hence thesis by RELAT_1:213;
end;

theorem
 for s being State of S
  holds dom NPP s = {IC S} \/ dom DataPart s
proof let s be State of S;
  IC S in dom s by Th9;
 hence thesis by Th45;
end;

theorem Th72:
 for p being PartState of S st IC S in dom p
  holds IC NPP p = IC p
 proof
  let p be PartState of S;
    dom p c= the carrier of S by RELAT_1:def 18;
   then
F: NPP p = p|((the carrier of S) \ NAT) by RELAT_1:211;
  assume IC S in dom p;
   then
X:  dom NPP p = {IC S} \/ dom DataPart p by Th45;
   IC S in {IC S} by TARSKI:def 1;
   then IC S in dom NPP p by X,XBOOLE_0:def 3;
  hence IC NPP p = IC p by F,FUNCT_1:70;
 end;

theorem Th73:
 for p being PartState of S
  holds DataPart p = DataPart NPP p
 proof let p be PartState of S;
X:  Data-Locations S = (the carrier of S) \ {IC S} \ NAT by XBOOLE_1:41;
   ((the carrier of S)\NAT) /\ Data-Locations S
       = ((the carrier of S) /\ Data-Locations S)\NAT by XBOOLE_1:49
      .= (Data-Locations S)\NAT by XBOOLE_1:28
      .= ((the carrier of S) \ {IC S})\(NAT \/ NAT) by X,XBOOLE_1:41
      .= Data-Locations S by X;
  hence DataPart p = p|(((the carrier of S)\NAT) /\ Data-Locations S)
    .= p|((the carrier of S)\NAT)|Data-Locations S by RELAT_1:100
    .= (NPP p)|Data-Locations S by Th65
    .= DataPart NPP p;
 end;

registration
  let N,S;
  let p be program-free PartState of S, k be Element of NAT;
  cluster IncrIC(p,k) -> program-free;
  coherence
   proof
A:  p|NAT = {} by Def29;
    thus IncrIC(p,k)|NAT = (p +* Start-At(IC p+k,S))|NAT
      .= p|NAT +* ProgramPart Start-At(IC p+k,S) by FUNCT_4:75
      .= {} +* {} by A,Th135
      .= {};
   end;
end;

theorem Th74:
 for p being PartState of S st IC S in dom p
  holds NPP p = DataPart p +* Start-At (IC p,S)
proof
 let p be PartState of S;
A: dom Start-At(IC p,S) = {IC S} by FUNCOP_1:19;
  then
M1: dom DataPart p misses dom Start-At (IC p,S) by Th13;
M2: dom Start-At(IC p,S) misses dom ProgramPart p by A,Th14;
M5: dom DataPart p misses  dom ProgramPart p by Th15;
    dom((Start-At(IC p,S) +* ProgramPart p)) =
        dom Start-At(IC p,S) \/ dom ProgramPart p by FUNCT_4:def 1;
    then
M3: dom((Start-At(IC p,S) +* ProgramPart p)) misses dom DataPart p
                  by M1,M5,XBOOLE_1:70;
X1: DataPart p +* Start-At (IC p,S) = DataPart p \/ Start-At (IC p,S)
                     by M1,FUNCT_4:32;
 assume IC S in dom p;
  then p = Start-At(IC p,S) +* ProgramPart p +* DataPart p by Th18;
  then
B:  p = (Start-At(IC p,S) +* ProgramPart p) \/  DataPart p by M3,FUNCT_4:32
     .= Start-At(IC p,S) \/ (ProgramPart p) \/  DataPart p by M2,FUNCT_4:32
     .=  ProgramPart p \/ (Start-At(IC p,S) \/  DataPart p) by XBOOLE_1:4;
C:  Start-At(IC p,S) misses  ProgramPart p by M2,RELAT_1:214;
M5: dom DataPart p misses  dom ProgramPart p by Th15;
   DataPart p misses  ProgramPart p by M5,RELAT_1:214;
  then Start-At(IC p,S) \/  DataPart p misses  ProgramPart p by C,XBOOLE_1:70;
  then  p \  ProgramPart p = Start-At(IC p,S) \/  DataPart p by B,XBOOLE_1:88;
 hence thesis by X1;
end;

theorem
 for p being PartState of S st IC S in dom p
  holds IncrIC(NPP p,k) = DataPart p +* Start-At ((IC p) +k,S)
 proof let p be PartState of S;
A: dom Start-At ((IC p) +k,S) = {IC S} by FUNCOP_1:19
     .= dom Start-At (IC p,S) by FUNCOP_1:19;
  assume
Z: IC S in dom p;
  hence IncrIC(NPP p,k) = NPP p +* Start-At(IC p+k,S) by Th72
    .= DataPart p +* Start-At (IC p,S) +* Start-At ((IC p) +k,S) by Z,Th74
    .= DataPart p +* Start-At ((IC p) +k,S) by A,FUNCT_4:78;
 end;

registration
  let N,S;
  let p be PartState of S;
  cluster NPP p -> program-free;
  coherence
   proof
     (p \ ProgramPart p)|NAT = (p \ p|NAT)|NAT
     .= {} by RELAT_1:216;
    hence (NPP p)|NAT = {};
   end;
end;

registration
  let N,S;
  let s be State of S, k be Nat;
  cluster IncrIC(s,k) -> total;
  coherence;
end;

begin :: inicjalizacja licznika rozkazow, 2010.05.14, A.T.

definition let N;
  let S be IC-Ins-separated definite
  (non empty stored-program COM-Struct over N);
  let p be PartState of S;
  func Initialize p -> PartState of S equals
  p +* Start-At( 0,S);
  coherence;
  projectivity by FUNCT_4:99;
end;

registration let N,S;
  let p be PartState of S;
 cluster Initialize p -> 0-started;
 coherence;
end;

registration let N,S;
  let p be FinPartState of S;
  cluster Initialize p -> finite;
  coherence;
end;

reserve p for PartState of S;

theorem Th27:
  dom Initialize p = dom p \/ {IC S}
proof
  thus dom Initialize p = dom p \/ dom Start-At( 0,S) by FUNCT_4:def 1
    .= dom p \/ {IC S} by FUNCOP_1:19;
end;

theorem
  for x being set st x in dom Initialize p holds x in dom p or x = IC S
proof
  let x be set;
  assume
A1: x in dom Initialize p;
  dom Initialize p = dom p \/ {IC S} by Th27;
  then x in dom p or x in {IC S} by A1,XBOOLE_0:def 3;
  hence thesis by TARSKI:def 1;
end;

theorem Th78:
 for p being 0-started PartState of S
  holds Initialize p = p
 proof let p be 0-started PartState of S;
   IC S in dom p & IC p = 0 by Def41;
   then Start-At( 0,S) c= p by FUNCT_4:90;
  hence Initialize p = p by FUNCT_4:79;
 end;

registration let N,S,k;
 let p be k-started PartState of S,
     I be NAT-defined Function;
 cluster p +* I -> k-started PartState of S;
 coherence
  proof let q be PartState of S;
F:  IC S in dom p by Def41;
   assume
Z:  q = p +* I;
    then dom q = dom p \/ dom I by FUNCT_4:def 1;
   hence IC S in dom q by F,XBOOLE_0:def 3;
    dom I c= NAT by RELAT_1:def 18;
    then not IC S in dom I by Def21;
   hence IC q = IC p by Z,FUNCT_4:12
      .= k by Def41;
  end;
end;

definition let N,S;
 let p be PartState of S,
     f be NAT-defined (the Instructions of S)-valued Function;
 redefine func p +* f -> PartState of S;
 coherence;
end;

theorem
 for p being 0-started PartState of S,
    f being NAT-defined (the Instructions of S)-valued Function
  holds Initialize (p +* f) = p +* f
   by Th78;

theorem
 for p being PartState of S
  holds DataPart Initialize p = DataPart p
 proof let p be PartState of S;
  thus DataPart Initialize p
        = DataPart p +* DataPart Start-At(0,S) by FUNCT_4:75
       .= DataPart p +* {} by Th30
       .= DataPart p by FUNCT_4:22;
 end;

theorem
 for s1,s2 being State of S st s1,s2 equal_outside NAT
  holds Initialize s1,Initialize s2 equal_outside NAT by FUNCT_7:106;

theorem
 for p being PartState of S,
    f being NAT-defined (the Instructions of S)-valued Function
  holds DataPart(p +* f) = DataPart p
 proof let p being PartState of S;
  let f being NAT-defined (the Instructions of S)-valued Function;
B: NAT misses Data-Locations S by Th51;
   dom f c= NAT by RELAT_1:def 18;
   then
A: dom f misses Data-Locations S by B,XBOOLE_1:63;
  thus DataPart(p +* f)
         = DataPart p +* f|Data-Locations S by FUNCT_4:75
        .= DataPart p +* {} by A,RELAT_1:95
        .= DataPart p by FUNCT_4:22;
 end;

registration let N be with_non-empty_elements set;
 let S be IC-Ins-separated definite
  (non empty stored-program COM-Struct over N);
 let p be PartState of S;
 cluster p|NAT -> (the Instructions of S)-valued;
 coherence
   proof let e be set;
    assume e in rng(p|NAT);
     then consider u being set such that
W1:   u in dom(p|NAT) and
W2:   e = (p|NAT).u by FUNCT_1:def 5;
B:   dom(p|NAT) = NAT /\ dom p by RELAT_1:90;
     then
D:    u in NAT by W1,XBOOLE_0:def 4;
     then
A:    (the Object-Kind of S).u = the Instructions of S by Def8;
     reconsider u as Nat by D;
E:   u in dom p by B,W1,XBOOLE_0:def 4;
C:   (p|NAT).u = p.u by D,FUNCT_1:72;
     p.u in (the Object-Kind of S).u by E,FUNCT_1:def 20;
    hence e in the Instructions of S by W2,C,A;
   end;
end;

theorem
 for p being PartState of S,
    f being NAT-defined (the Instructions of S)-valued Function
  holds Initialize (p +* f) = Initialize p +* f
proof
 let p be PartState of S,
     f be NAT-defined (the Instructions of S)-valued Function;
B: NAT misses dom Start-At(0,S) by Th26;
   dom f c= NAT by RELAT_1:def 18;
   then
A:  dom f misses dom Start-At(0,S) by B,XBOOLE_1:63;
 thus Initialize (p +* f) = p +* (f +* Start-At(0,S)) by FUNCT_4:15
     .= p +* (Start-At(0,S) +* f) by A,FUNCT_4:36
     .= Initialize p +* f by FUNCT_4:15;
end;

theorem
 for s being State of S st IC s =  0
  holds Initialize s = s
proof let s be State of S;
  assume
A1: IC s =  0;
A2: IC S in dom s by Th9;
  thus Initialize s = s +* (IC S .-->  0)
    .= s by A1,A2,FUNCT_7:111;
end;

begin :: AMISTD_3, 2010.06.02, A.T

reserve k, m for natural number,
  x, x1, x2, x3, y, y1, y2, y3, X,Y,Z for set;

Lm1: -1 < k;

Lm2: for a, b, c being Element of NAT st 1 <= a & 2 <= b holds
k < a - 1 or a <= k & k <= a + b - 3 or k = a + b - 2 or
a + b - 2 < k or k = a - 1
proof
  let a, b, c be Element of NAT such that
A1: 1 <= a and
A2: 2 <= b and
A3: a - 1 <= k and
A4: a > k or k > a + b - 3 and
A5: k <> a + b - 2 and
A6: k <= a + b - 2;
A7: a - 1 is Element of NAT by A1,INT_1:18;
  now per cases by A4;
    case k < a;
      then k < a - 1 + 1;
      hence k <= a - 1 by A7,NAT_1:13;
    end;
    case
A8:   a + b - 3 < k;
      1 + 2 <= a + b by A1,A2,XREAL_1:9;
      then
A9:   a + b - 3 is Element of NAT by INT_1:18;
      k < a + b - 3 + 1 by A5,A6,XXREAL_0:1;
      hence k <= a - 1 by A8,A9,NAT_1:13;
    end;
  end;
  hence thesis by A3,XXREAL_0:1;
end;

begin  :: Properties of AMI-Struct

definition
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite
  (non empty stored-program COM-Struct over N),
  i1, i2 be Element of NAT,
  I1, I2 be Element of the Instructions of S;
  redefine func (i1,i2) --> (I1,I2) -> FinPartState of S;
  coherence;
end;

definition
  let N be set;
  let S be standard-ins COM-Struct over N;
  let T be InsType of S;
  func JumpParts T equals
  { JumpPart I where I is Instruction of S: InsCode I = T };
  coherence;
end;

registration
  let N be set;
  let S be standard-ins COM-Struct over N;
  let I be Element of the Instructions of S;
  cluster AddressPart I -> Function-like Relation-like;
  coherence
  proof
   consider X being non empty set such that
A1:  the Instructions of S c= [:NAT,NAT*,X*:] by Def17;
    I in the Instructions of S;
    then AddressPart I in X* by A1,RECDEF_2:2;
    hence thesis;
  end;
  cluster JumpPart I -> Function-like Relation-like;
  coherence
  proof
   consider X being non empty set such that
A1:  the Instructions of S c= [:NAT,NAT*,X*:] by Def17;
    I in the Instructions of S;
    then JumpPart I in NAT* by A1,RECDEF_2:2;
    hence thesis;
  end;
end;

registration
  let N be set;
  let S be standard-ins COM-Struct over N;
  let I be Element of the Instructions of S;
  cluster AddressPart I -> FinSequence-like;
  coherence
  proof
   consider X being non empty set such that
A1:  the Instructions of S c= [:NAT,NAT*,X*:] by Def17;
    I in the Instructions of S;
    then AddressPart I in X* by A1,RECDEF_2:2;
    hence thesis;
  end;
  cluster JumpPart I -> FinSequence-like;
  coherence
  proof
   consider X being non empty set such that
A1:  the Instructions of S c= [:NAT,NAT*,X*:] by Def17;
    I in the Instructions of S;
    then JumpPart I in NAT* by A1,RECDEF_2:2;
    hence thesis;
  end;
end;

definition
  let N be set;
  let S be standard-ins COM-Struct over N;
  attr S is homogeneous means
:Def4:
  for I, J being Instruction of S st InsCode I = InsCode J holds
  dom JumpPart I = dom JumpPart J;
end;

theorem Th85:
  for I being Instruction of Trivial-COM N holds JumpPart I = 0
proof
  let I be Instruction of Trivial-COM N;
  the Instructions of Trivial-COM N = {[0,0,0]} by Def2;
  then I = [0,0,0] by TARSKI:def 1;
  hence thesis by RECDEF_2:def 2;
end;

definition
  let N be set;
  let S be standard-ins COM-Struct over N;
  let T be InsType of S;
  func AddressParts T equals
  { AddressPart I where I is Instruction of S: InsCode I = T };
  coherence;
end;

registration
  let N be set;
  let S be standard-ins COM-Struct over N;
  let T be InsType of S;
  cluster AddressParts T -> functional;
  coherence
  proof
    let f be set;
    assume f in AddressParts T;
    then ex I being Instruction of S st f = AddressPart I & InsCode I = T;
    hence thesis;
  end;
  cluster JumpParts T -> non empty functional;
  coherence
  proof
    consider y being set such that
B1:  [T,y] in proj1 the Instructions of S by RELAT_1:def 4;
    consider x being set such that
A1:  [[T,y],x] in the Instructions of S by B1,RELAT_1:def 4;
    reconsider I = [T,y,x] as Instruction of S by A1;
    InsCode I = T by RECDEF_2:def 1;
    then JumpPart I in JumpParts T;
   hence JumpParts T is non empty;
    let f be set;
    assume f in JumpParts T;
    then ex I being Instruction of S st f = JumpPart I & InsCode I = T;
    hence thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster  -> (IC-Ins-separated definite
    (non empty stored-program COM-Struct over N));
  coherence;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster  standard-ins (IC-Ins-separated definite
    (non empty stored-program COM-Struct over N));
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

definition
  let N be set;
  let S be standard-ins COM-Struct over N;
  attr S is regular means
  :Def11:
  for I being Instruction of S, k being set st k in dom JumpPart I
   holds (product" JumpParts InsCode I).k = NAT;
  attr S is J/A-independent means
:Dfs: for T being InsType of S, f1,f2 being Function,
     p being set
    st f1 in JumpParts T & f2 in product product" JumpParts T &
    [T,f1,p] in the Instructions of S
    holds [T,f2,p] in the Instructions of S;
end;

theorem Th86:
  for T being InsType of Trivial-COM N holds JumpParts T = {0}
proof
  let T be InsType of Trivial-COM N;
  set A = { JumpPart I where I is Instruction of Trivial-COM N:
   InsCode I = T };
  {0} = A
  proof
    hereby
      let a be set;
      assume a in {0};
      then
A1:   a = 0 by TARSKI:def 1;
A2:   the Instructions of Trivial-COM N = {[0,0,0]} by Def2;
      then
A3:   InsCodes Trivial-COM N = {0} by MCART_1:97;
A4:     T = 0 by A3,TARSKI:def 1;
        reconsider I = [0,0,0] as Instruction of Trivial-COM N
        by A2,TARSKI:def 1;
A5:     JumpPart I = 0 by Th85;
        InsCode I = 0 by RECDEF_2:def 1;
        hence a in A by A1,A4,A5;
    end;
    let a be set;
    assume a in A;
    then ex I being Instruction of Trivial-COM N st a = JumpPart I &
     InsCode I = T;
    then a = 0 by Th85;
    hence thesis by TARSKI:def 1;
  end;
  hence thesis;
end;

Lm3: for I being Instruction of Trivial-COM N holds JumpPart I = 0
proof
  let I be Instruction of Trivial-COM N;
  the Instructions of Trivial-COM N = {[0,0,{}]} by Def2;
  then I = [0,0,0] by TARSKI:def 1;
  hence thesis by RECDEF_2:def 2;
end;

Lm4: for T being InsType of Trivial-COM N holds JumpParts T = {0}
proof
  let T be InsType of Trivial-COM N;
  set A = { JumpPart I
   where I is Instruction of Trivial-COM N: InsCode I = T };
  {0} = A
  proof
    hereby
      let a be set;
      assume a in {0};
      then
A1:   a = 0 by TARSKI:def 1;
A2:   the Instructions of Trivial-COM N = {[0,0,{}]} by Def2;
      then InsCodes Trivial-COM N = {0} by MCART_1:97;
      then
A3:   T = 0 by TARSKI:def 1;
      reconsider I = [0,0,0] as Instruction of Trivial-COM N
      by A2,TARSKI:def 1;
A4:   JumpPart I = 0 by Lm3;
      InsCode I = 0 by RECDEF_2:def 1;
      hence a in A by A1,A3,A4;
    end;
    let a be set;
    assume a in A;
    then ex I being Instruction of Trivial-COM N
    st a = JumpPart I & InsCode I = T;
    then a = 0 by Lm3;
    hence thesis by TARSKI:def 1;
  end;
  hence thesis;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster Trivial-COM N -> homogeneous regular J/A-independent;
  coherence
  proof
    thus Trivial-COM N is homogeneous
     proof let I, J be Instruction of Trivial-COM N;
       JumpPart I = {} & JumpPart J = {} by Th85;
      hence thesis;
     end;
    thus Trivial-COM N is regular
     proof let I be Instruction of Trivial-COM N;
       JumpPart I = {} by Th85;
      hence thesis;
     end;
    let T be InsType of Trivial-COM N;
    let f1,f2 be Function, p be set;
    assume f1 in JumpParts T;
     then
A:    f1 in {0} by Th86;
     assume
Z:    f2 in product product" JumpParts T;
     product" JumpParts T = {} by Th86,CARD_3:156;
     then f1 = 0 & f2 = 0 by A,Z,CARD_3:19,TARSKI:def 1;
    hence thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster  regular J/A-independent homogeneous
    realistic
    (IC-Ins-separated definite standard-ins
    (non empty stored-program COM-Struct over N));
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

registration
 let N be with_non-empty_elements non empty set;
 let S be regular homogeneous (standard-ins COM-Struct over N);
 let T being InsType of S;
 cluster JumpParts T ->  with_common_domain;
 coherence
  proof let f,g be Function;
   assume f in JumpParts T;
    then
A: ex I being Instruction of S st f = JumpPart I & InsCode I = T;
   assume g in JumpParts T;
    then ex J being Instruction of S st g = JumpPart J & InsCode J = T;
   hence dom f = dom g by Def4,A;
  end;
end;

registration
 let N be with_non-empty_elements non empty set;
 let S be regular homogeneous (standard-ins COM-Struct over N);
 let I be Instruction of S;
 cluster JumpPart I -> NAT-valued Function;
 coherence
proof
 JumpPart I is NAT-valued
 proof let x;
 assume x in rng JumpPart I;
  then consider k being set such that
W1: k in dom JumpPart I and
W2: (JumpPart I).k = x by FUNCT_1:def 5;
  set X = JumpParts InsCode I;
A:  JumpPart I in X;
  then k in dom product" X by W1,CARD_3:150;
  then (JumpPart I).k in (product" X).k by A,CARD_3:151;
 hence x in NAT by W1,W2,Def11;
 end;
 hence thesis;
end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be regular J/A-independent homogeneous
   (standard-ins COM-Struct over N);
  let T be InsType of S;
  cluster JumpParts T -> product-like;
  coherence
proof
  consider y being set such that
B1: [T,y] in proj1 the Instructions of S by RELAT_1:def 4;
  consider z being set such that
A1: [[T,y],z] in the Instructions of S by B1,RELAT_1:def 4;
  reconsider I = [T,y,z] as Instruction of S by A1;
X1: InsCode I = T by RECDEF_2:def 1;
X4: JumpPart I = y by RECDEF_2:def 2;
  set f = (dom JumpPart I) --> NAT;
D1:   dom f = dom JumpPart I by FUNCOP_1:19;
  for x being set holds x in JumpParts T iff
   ex g being Function st x = g & dom g = dom f &
     for y st y in dom f holds g.y in f.y
   proof let x be set;
    thus x in JumpParts T implies
      ex g being Function st x = g & dom g = dom f &
     for y st y in dom f holds g.y in f.y
    proof assume x in JumpParts T;
      then consider K being Instruction of S such that
W1:    x = JumpPart K and
W2:    InsCode K = T;
     take g = JumpPart K;
     thus x = g by W1;
     thus
K:    dom g = dom f by W2,X1,Def4,D1;
     let y;
     assume
Z:    y in dom f;
      then f.y = NAT by D1,FUNCOP_1:13;
     hence g.y in f.y by K,Z,FUNCT_1:172;
    end;
     given g being Function such that
G1:   x = g and
G2:   dom g = dom f and
G3:   for y st y in dom f holds g.y in f.y;
X3:   dom g = dom JumpPart I by G2,FUNCOP_1:19;
   set J = [T,g,z];
Y1: y in JumpParts T by X4,X1;
   then
X6: dom g = dom product" JumpParts T by X3,X4,CARD_3:150;
    for x st x in dom(product" JumpParts T)
     holds g.x in (product" JumpParts T).x
    proof let x;
     assume
Z:    x in dom(product" JumpParts T);
      f.x = NAT by X6,X3,Z,FUNCOP_1:13;
      then g.x in NAT by G3,X6,Z,G2;
     hence g.x in (product" JumpParts T).x by Z,X6,X1,X3,Def11;
    end;
   then
X5: g in product product" JumpParts T by X6,CARD_3:18;
    reconsider J as Instruction of S by Y1,Dfs,X4,X5;
X2: InsCode J = T by RECDEF_2:def 1;
     g = JumpPart J by RECDEF_2:def 2;
    hence x in JumpParts T by X2,G1;
   end;
  then JumpParts T = product f by CARD_3:def 5;
 hence JumpParts T is product-like;
end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster Trivial-COM N -> regular J/A-independent;
  coherence;
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster regular J/A-independent (standard-ins COM-Struct over N);
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

registration

  let N be with_non-empty_elements non empty set;
  let S be homogeneous (standard-ins COM-Struct over N);
  let T be InsType of S;
  cluster JumpParts T -> with_common_domain;
  coherence
  proof
    let f, g be Function;
    assume that
A1: f in JumpParts T and
A2: g in JumpParts T;
A3: ex I being Instruction of S st f = JumpPart I & InsCode I = T by A1;
    ex J being Instruction of S st g = JumpPart J & InsCode J = T by A2;
    hence thesis by A3,Def4;
  end;
end;

registration
  let N;
  cluster regular J/A-independent
    (non empty stored-program standard-ins COM-Struct over N);
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

theorem
  for S being homogeneous regular
  (non empty stored-program standard-ins COM-Struct over N),
  I being Instruction of S, x being set st x in dom JumpPart I holds
  (JumpPart I).x is Element of NAT
proof
  let S be homogeneous regular
  (non empty stored-program standard-ins COM-Struct over N),
  I be Instruction of S, x be set such that
A1: x in dom JumpPart I;
A2: JumpPart I in JumpParts InsCode I;
A3: (product" JumpParts InsCode I).x = NAT by A1,Def11;
  for f being Function st f in JumpParts InsCode I holds x in dom f
  proof
    let f be Function;
    assume f in JumpParts InsCode I;
    then ex J being Instruction of S st f = JumpPart J & InsCode I =
    InsCode J;
    hence thesis by A1,Def4;
  end;
  then x in dom product" JumpParts InsCode I by CARD_3:def 13;
  then (product" JumpParts InsCode I).x = pi(JumpParts InsCode I,x)
  by CARD_3:def 13;
  hence thesis by A2,A3,CARD_3:def 6;
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster
  realistic
    (standard-ins IC-Ins-separated definite
    (non empty stored-program COM-Struct over N));
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

registration

  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite
  (non empty stored-program COM-Struct over N);
  cluster non trivial NAT-defined FinPartState of S;
  existence
  proof
    consider l1, l2 being Element of NAT such that
A1: l1 <> l2 by YELLOW_8:def 1;
    reconsider l1,l2 as Element of NAT;
    consider I being Instruction of S;
    take f = (l1,l2) --> (I,I);
    thus f is non trivial
    proof
      f = { [l1,I], [l2,I] } by A1,FUNCT_4:71;
      then reconsider x = [l1,I], y = [l2,I] as Element of f by TARSKI:def 2;
      take x, y;
      thus thesis by A1,ZFMISC_1:33;
    end;
    let a be set;
    assume a in dom f;
    then a in {l1,l2} by FUNCT_4:65;
    then a = l1 or a = l2 by TARSKI:def 2;
    hence thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  cluster trivial -> unique-halt (non empty NAT-defined FinPartState of S);
  coherence
  proof
    let F be non empty NAT-defined FinPartState of S;
    assume
A1: F is trivial;
    let f be Element of NAT such that F.f = halt S and
A2: f in dom F;
    consider x being set such that
A3: F = {x} by A1,REALSET1:def 4;
    x in F by A3,TARSKI:def 1;
    then consider a, b being set such that
A4: [a,b] = x by RELAT_1:def 1;
A5: LastLoc F in dom F by VALUED_1:31;
A6: dom F = {a} by A3,A4,RELAT_1:23;
    hence f = a by A2,TARSKI:def 1
      .= LastLoc F by A5,A6,TARSKI:def 1;
  end;
end;

definition
  let N be set;
  let S be standard-ins COM-Struct over N;
  let I be Instruction of S;
  attr I is ins-loc-free means
:Def37: JumpPart I is empty;
end;

Lm5: now
  let N be with_non-empty_elements non empty set,
  S be (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  thus dom Stop S = {0} by FUNCOP_1:19;
  hence 0 in dom Stop S by TARSKI:def 1;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be
  (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  cluster Stop S ->
   initial non empty NAT-defined (the Instructions of S)-valued trivial;
  coherence;
end;

theorem Th25:
  for S being (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)) holds card Stop S = 1
proof
  let S be (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  thus card Stop S = card {[0,halt S]} by FUNCT_4:87
    .= 1 by CARD_1:50;
end;

theorem Th89:
  for F being pre-Macro of S st card F = 1 holds F = Stop S
proof let F be pre-Macro of S;
  assume
A1: card F = 1;
  then consider x being set such that
A2: F = {x} by CARD_2:60;
  x in F by A2,TARSKI:def 1;
  then consider a, b being set such that
A3: [a,b] = x by RELAT_1:def 1;
A4: dom F = {a} by A2,A3,RELAT_1:23;
A5: 0 in dom F by AFINSQ_1:69;
  then
A6: a = 0 by A4;
  card F -' 1 = card F - 1 by PRE_CIRC:25
    .= 0 by A1;
  then LastLoc F = 0 by AFINSQ_1:74;
  then F.0 = halt S by Def25;
  then halt S in rng F by A5,FUNCT_1:def 5;
  then halt S in {b} by A2,A3,RELAT_1:23;
  then F = {[0,halt S]} by A2,A3,A6,TARSKI:def 1
    .= 0 .--> halt S by FUNCT_4:87;
  hence thesis;
end;

Lm6: for S being (IC-Ins-separated definite
(non empty stored-program COM-Struct over N)) holds card Stop S -' 1 = 0
proof
  let S be (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  thus card Stop S -' 1 = card Stop S - 1 by PRE_CIRC:25
    .= 1 - 1 by Th25
    .= 0;
end;

theorem Th27:
  for S being (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  holds LastLoc Stop S = 0
proof
  let S be (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  card Stop S -' 1 = 0 by Lm6;
  hence thesis by AFINSQ_1:74;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  cluster Stop S -> halt-ending unique-halt;
  coherence
  proof
    thus (Stop S).(LastLoc Stop S) = (0 .--> halt S).0 by Th27
      .= halt S by FUNCOP_1:87;
    let l be Element of NAT such that (Stop S).l = halt S;
    assume l in dom Stop S;
    then l in {0} by Lm5;
    then l = 0 by TARSKI:def 1;
    hence thesis by Th27;
  end;
end;

begin  :: On the composition of macro instructions

registration
  let N be with_non-empty_elements non empty set;
  let S be regular J/A-independent homogeneous
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let I be Element of the Instructions of S;
 cluster JumpPart I -> natural-valued Function;
 coherence;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be regular J/A-independent homogeneous
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let I be Element of the Instructions of S;
  let k be natural number;
  func IncAddr(I,k) -> Instruction of S means
:Def38:
  InsCode it = InsCode I &
  AddressPart it = AddressPart I &
  JumpPart it = k + JumpPart I;
  existence
  proof
    consider D0 being non empty set such that
W:   the Instructions of S c= [:NAT,NAT*,D0*:] by Def17;
    set p = k + JumpPart I;
    set f = product" JumpParts InsCode I;
A8: JumpPart I in JumpParts InsCode I;
A9: JumpParts InsCode I = product f by CARD_3:95;
A10: dom p = dom JumpPart I by VALUED_1:def 2;
     then
B10: dom p  = DOM JumpParts InsCode I by A8,CARD_3:def 12
      .= dom f by CARD_3:92;
    for z being set st z in dom p holds p.z in f.z
    proof
      let z be set;
      assume
A11:  z in dom p;
      reconsider z as Element of NAT by A11;
A13:    f.z = NAT by A11,A10,Def11;
        reconsider il = (JumpPart I).z as Element of NAT by ORDINAL1:def 13;
        p.z = k + il by A11,VALUED_1:def 2;
        hence thesis by A13;
    end;
    then p in JumpParts InsCode I by A9,B10,CARD_3:18;
    then consider II being Instruction of S such that
A14: p = JumpPart II and
A15: InsCode I = InsCode II;
X1:  JumpPart I in JumpParts InsCode I;
     product product" JumpParts InsCode I = JumpParts InsCode I by CARD_3:95;
     then
X2:  JumpPart II in product product" JumpParts InsCode I by A15;
     I in the Instructions of S;
     then [InsCode I, JumpPart I, AddressPart I] = I by W,RECDEF_2:3;
     then reconsider IT = [InsCode I, JumpPart II, AddressPart I]
                       as Instruction of S by X1,X2,Dfs;
    take IT;
    thus InsCode IT = InsCode I by RECDEF_2:def 1;
    thus AddressPart IT = AddressPart I by RECDEF_2:def 3;
    thus JumpPart IT = k + JumpPart I by A14,RECDEF_2:def 2;
  end;
  uniqueness by Th7;
end;

theorem Th28:
  for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  I being Element of the Instructions of S holds IncAddr(I, 0) = I
proof
  let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  I be Element of the Instructions of S;
A1: InsCode IncAddr(I, 0) = InsCode I by Def38;
XX: AddressPart IncAddr(I, 0) = AddressPart I by Def38;
YY:  JumpPart IncAddr(I, 0) = (0 qua Nat) + JumpPart I by Def38;
   then
A2: dom JumpPart I = dom JumpPart IncAddr(I, 0) by VALUED_1:def 2;
  for k being Nat st k in dom JumpPart I holds
  (JumpPart IncAddr(I, 0)).k = (JumpPart I).k
  proof
    let k be Nat;
    assume k in dom JumpPart I;
    hence (JumpPart IncAddr(I, 0)).k
        = (0 qua Nat) + (JumpPart I).k by A2,YY,VALUED_1:def 2
       .= (JumpPart I).k;
  end;
   then JumpPart IncAddr(I, 0) = JumpPart I by A2,FINSEQ_1:17;
  hence thesis by A1,XX,Th7;
end;

theorem Th29:
  for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  I being Instruction of S st I is ins-loc-free holds IncAddr(I, k) = I
proof
  let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  I be Instruction of S such that
A1: JumpPart I is empty;
  set f = IncAddr(I, k);
A2: InsCode f = InsCode I by Def38;
XX: AddressPart f = AddressPart I by Def38;
    JumpPart f = k + JumpPart I by Def38;
    then
A3: dom JumpPart f = dom JumpPart I by VALUED_1:def 2;
   JumpPart f = JumpPart I by A1,A3;
  hence thesis by A2,XX,Th7;
end;

definition let N be set;
  let S be standard-ins COM-Struct over N;
  attr S is proper-halt means
:Def39:  halt S is ins-loc-free;
end;

registration
  let N be set;
  cluster Trivial-COM N -> proper-halt;
  coherence
  proof set S = Trivial-COM N;
    halt S = [0,{},{}] by Def2;
   hence JumpPart halt S is empty by RECDEF_2:def 2;
  end;
end;

registration let N;
 cluster proper-halt regular homogeneous J/A-independent realistic
  IC-Ins-separated definite
  (standard-ins non empty stored-program COM-Struct over N);
 existence
  proof
   take Trivial-COM N;
   thus thesis;
  end;
end;

registration let N;
  let S be proper-halt (standard-ins COM-Struct over N);
 cluster halt S -> ins-loc-free;
 coherence by Def39;
end;

registration let N;
  let S be proper-halt (standard-ins COM-Struct over N);
 cluster ins-loc-free Instruction of S;
 existence
  proof
   take halt S;
   thus thesis;
  end;
end;

registration
  let N;
  let S be proper-halt (standard-ins COM-Struct over N);
  let I be ins-loc-free Instruction of S;
  cluster JumpPart I -> empty;
  coherence by Def37;
end;

theorem
  for S being
  regular homogeneous J/A-independent proper-halt
  (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  holds IncAddr(halt S, k) = halt S by Th29;

theorem
  for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), I being Instruction of S
  holds JumpParts InsCode I = JumpParts InsCode IncAddr(I,k)
proof
  let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), I be Instruction of S;
  set A = { JumpPart J where J is Instruction of S:
  InsCode I = InsCode J }, B = { JumpPart J where J is Instruction of S:
  InsCode IncAddr(I,k) = InsCode J };
  A = B
  proof
    hereby
      let a be set;
      assume a in A;
      then consider J being Instruction of S such that
A1:   a = JumpPart J and
A2:   InsCode J = InsCode I;
      InsCode J = InsCode IncAddr(I,k) by A2,Def38;
      hence a in B by A1;
    end;
    let a be set;
    assume a in B;
    then consider J being Instruction of S such that
A3: a = JumpPart J and
A4: InsCode J = InsCode IncAddr(I,k);
    InsCode J = InsCode I by A4,Def38;
    hence thesis by A3;
  end;
  hence thesis;
end;

theorem Th34:
  for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  I, J being Instruction of S st
  ex k being natural number st IncAddr(I,k) = IncAddr(J,k) holds I = J
proof
  let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), I, J be Instruction of S;
  given k being natural number such that
A1: IncAddr(I,k) = IncAddr(J,k);
A2: InsCode I = InsCode IncAddr(I,k) by Def38
    .= InsCode J by A1,Def38;
XX: AddressPart I = AddressPart IncAddr(I,k) by Def38
       .= AddressPart J by A1,Def38;
X1: JumpPart IncAddr(I,k) = k + JumpPart I by Def38;
    then
Y1: dom JumpPart I = dom  JumpPart IncAddr(I,k) by VALUED_1:def 2;
X2: JumpPart IncAddr(J,k) = k + JumpPart J by Def38;
    then
Y2: dom JumpPart J = dom  JumpPart IncAddr(J,k) by VALUED_1:def 2;
A3: dom JumpPart I = dom JumpPart J by A2,Def4;
  for x being set st x in dom JumpPart I holds
  (JumpPart I).x = (JumpPart J).x
  proof
    let x be set;
    assume
A4: x in dom JumpPart I;
A7:   (JumpPart IncAddr(I,k)).x = k + (JumpPart I).x
             by X1,Y1,A4,VALUED_1:def 2;
A9:   (JumpPart IncAddr(J,k)).x = k + (JumpPart J).x
             by X2,A3,A4,Y2,VALUED_1:def 2;
      thus thesis by A1,A7,A9;
  end;
   then JumpPart I = JumpPart J by A3,FUNCT_1:9;
  hence thesis by A2,XX,Th7;
end;

theorem Th35:
  for S being regular homogeneous J/A-independent proper-halt
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  I being Instruction of S st IncAddr(I,k) = halt S holds I = halt S
proof
  let S be regular homogeneous J/A-independent proper-halt
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), I be Instruction of S;
  assume IncAddr(I,k) = halt S;
  then IncAddr(I,k) = IncAddr(halt S,k) by Th29;
  hence thesis by Th34;
end;

theorem Th37:
  for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), I being Instruction of S
  holds IncAddr(IncAddr(I,k),m) = IncAddr(I,k+m)
proof
  let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), I be Instruction of S;
A1: InsCode IncAddr(IncAddr(I,k),m) = InsCode IncAddr(I,k) by Def38
    .= InsCode I by Def38
    .= InsCode IncAddr(I,k+m) by Def38;
XX: AddressPart IncAddr(IncAddr(I,k),m) = AddressPart IncAddr(I,k) by Def38
    .= AddressPart I by Def38
    .= AddressPart IncAddr(I,k+m) by Def38;
Y3: JumpPart IncAddr(IncAddr(I,k),m) = m + JumpPart IncAddr(I,k) by Def38;
Y2: JumpPart IncAddr(I,k) = k + JumpPart I by Def38;
Y1: JumpPart IncAddr(I,k+m) = k+m + JumpPart I by Def38;
    then
A2: dom JumpPart IncAddr(I,k+m) = dom JumpPart I by VALUED_1:def 2
    .= dom JumpPart IncAddr(I,k) by Y2,VALUED_1:def 2
    .= dom JumpPart IncAddr(IncAddr(I,k),m) by Y3,VALUED_1:def 2;
  for n being set st n in dom JumpPart IncAddr(IncAddr(I,k),m) holds
  (JumpPart IncAddr(IncAddr(I,k),m)).n = (JumpPart IncAddr(I,k+m)).n
  proof
    let n be set;
    assume
Z:   n in dom JumpPart IncAddr(IncAddr(I,k),m);
    then
A3: n in dom JumpPart IncAddr(I,k) by Y3,VALUED_1:def 2;
    then
A4: n in dom JumpPart I by Y2,VALUED_1:def 2;
A7:   (JumpPart IncAddr(I,k)).n = k + (JumpPart I).n
            by Y2,A3,VALUED_1:def 2;
A9:   (JumpPart IncAddr(IncAddr(I,k),m)).n = m + (JumpPart IncAddr(I,k)).n
      by Z,Y3,VALUED_1:def 2;
      n in dom JumpPart IncAddr(I,k+m) by Y1,A4,VALUED_1:def 2;
      then (JumpPart IncAddr(I,k+m)).n = k + m + (JumpPart I).n
       by Y1,VALUED_1:def 2;
      hence thesis by A9,A7;
  end;
   then JumpPart IncAddr(IncAddr(I,k),m) = JumpPart IncAddr(I,k+m)
                   by A2,FUNCT_1:9;
  hence thesis by A1,XX,Th7;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  p be NAT-defined (the Instructions of S)-valued finite Function,
  k be natural number;
A1: dom p c= NAT by RELAT_1:def 18;
  func IncAddr(p,k) -> FinPartState of S means
  :Def15:
  dom it = dom p &
  for m being natural number st m in dom p holds it.m = IncAddr(p/.m,k);
  existence
  proof
    defpred P[set,set] means ex m being Element of NAT st $1 = m &
    $2 = IncAddr(p/.m,k);
A2: for e being set st e in dom p ex u being set st P[e,u]
    proof
      let e be set;
      assume e in dom p;
      then reconsider l=e as Element of NAT by A1;
      consider m being natural number such that
A3:   l = m;
      take IncAddr(p/.m,k);
      thus thesis by A3;
    end;
    consider f being Function such that
A4: dom f = dom p and
A5: for e being set st e in dom p holds P[e,f.e] from CLASSES1:sch 1(A2);
     for x being set st x in dom f holds f.x in (the Object-Kind of S).x
    proof
      let x be set;
      assume
A7:   x in dom f;
      then
A8:   ex m being Element of NAT st x = m & f.x =
       IncAddr(p/.m,k) by A4,A5;
      reconsider y = x as Element of NAT by A1,A4,A7;
      (the Object-Kind of S).y = the Instructions of S by Def8;
      hence thesis by A8;
    end;
    then
UU:  f is (the Object-Kind of S)-compatible by FUNCT_1:def 20;
    reconsider f as finite Element of sproduct the Object-Kind of S
    by A4,UU,CARD_3:153,FINSET_1:29;
    reconsider f as FinPartState of S;
    take f;
    thus dom f = dom p by A4;
    let m be natural number;
    assume m in dom p;
    then ex j being Element of NAT st m = j &
    f.m = IncAddr(p/.j,k) by A5;
    hence thesis;
  end;
  uniqueness
  proof
    let IT1,IT2 be FinPartState of S such that
A9: dom IT1 = dom p and
A10: for m being natural number st m in dom p holds
    IT1.m = IncAddr(p/.m,k) and
A11: dom IT2 = dom p and
A12: for m being natural number st m in dom p holds
    IT2.m = IncAddr(p/.m,k);
    for x being set st x in dom p holds IT1.x = IT2.x
    proof
      let x be set;
      assume
A13:  x in dom p;
      then reconsider l=x as Element of NAT by A1;
      consider m being natural number such that
A14:  l = m;
      reconsider m as Element of NAT by ORDINAL1:def 13;
      thus IT1.x = IncAddr(p/.m,k) by A10,A13,A14
        .= IT2.x by A12,A13,A14;
    end;
    hence thesis by A9,A11,FUNCT_1:9;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be NAT-defined (the Instructions of S)-valued finite Function,
  k be natural number;
  cluster IncAddr(F,k) -> NAT-defined (the Instructions of S)-valued;
  coherence
  proof
E:   dom IncAddr(F,k) = dom F by Def15;
    hence dom IncAddr(F,k) c= NAT by RELAT_1:def 18;
   let x be set;
   assume x in rng IncAddr(F,k);
    then consider y being set such that
W1:  y in dom F and
W2:  x = IncAddr(F,k).y by E,FUNCT_1:def 5;
    x = IncAddr(F/.y,k) by W1,W2,Def15;
   hence x in the Instructions of S;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  cluster empty NAT-defined FinPartState of S;
  existence
  proof
   take the empty FinPartState of S;
   thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be empty (the Instructions of S)-valued NAT-defined FinPartState of S,
  k be natural number;
  cluster IncAddr(F,k) -> empty;
  coherence
  proof
    assume not thesis;
    then reconsider f = IncAddr(F,k) as non empty Function;
A1: dom f <> {};
    dom IncAddr(F,k) = dom F by Def15;
    hence thesis by A1;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be non empty (the Instructions of S)-valued NAT-defined FinPartState of S,
  k be natural number;
  cluster IncAddr(F,k) -> non empty;
  coherence
  proof
    dom IncAddr(F,k) = dom F by Def15;
    hence thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be initial NAT-defined (the Instructions of S)-valued FinPartState of S,
  k be natural number;
  cluster IncAddr(F,k) -> initial;
  coherence
  proof
    dom IncAddr(F,k) = dom F by Def15;
    hence thesis by AFINSQ_1:71;
  end;
end;

theorem Th38:
  for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F being NAT-defined (the Instructions of S)-valued FinPartState of S
   holds IncAddr(F,0) = F
proof
  let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be NAT-defined (the Instructions of S)-valued FinPartState of S;
  for m being natural number st m in dom F holds
  F.m = IncAddr(F/.m,0)
  proof
    let m be natural number;
    assume m in dom F;
    then F/.m = F.m by PARTFUN1:def 8;
    hence thesis by Th28;
  end;
  hence thesis by Def15;
end;

theorem
  for S being regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F being NAT-defined (the Instructions of S)-valued finite Function
  holds IncAddr(IncAddr(F,k),m) = IncAddr(F,k+m)
proof
  let S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be NAT-defined (the Instructions of S)-valued finite Function;
A1: dom IncAddr(IncAddr(F,k),m) = dom IncAddr(F,k) by Def15
    .= dom F by Def15;
A2: dom IncAddr(F,k+m) = dom F by Def15;
  for x being set st x in dom F holds
  IncAddr(IncAddr(F,k),m).x = IncAddr(F,k+m).x
  proof
    let x be set such that
A3: x in dom F;
    reconsider x as Element of NAT by A3,ORDINAL1:def 13;
A5: x in dom IncAddr(F,k) by A3,Def15;
A6: IncAddr(F/.x,k) = IncAddr(F,k).x
    by A3,Def15
      .= IncAddr(F,k)/.x by A5,PARTFUN1:def 8;
    IncAddr(IncAddr(F,k),m).x
    = IncAddr(IncAddr(F,k)/.x,m) by A5,Def15
      .= IncAddr(F/.x,k+m) by A6,Th37
      .= IncAddr(F,k+m).x by A3,Def15;
    hence thesis;
  end;
  hence thesis by A1,A2,FUNCT_1:9;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
 let p be finite NAT-defined (the Instructions of S)-valued Function,
     k be Element of NAT;
 func Reloc(p,k) ->
   finite NAT-defined (the Instructions of S)-valued Function
   equals IncAddr(Shift(p,k),k);
 coherence;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster homogeneous realistic
    (regular J/A-independent  (standard-ins IC-Ins-separated definite
    (non empty stored-program COM-Struct over N)));
  existence
  proof
    take Trivial-COM N;
    thus thesis;
  end;
end;

theorem Th100:
  for S being regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F being initial non empty NAT-defined FinPartState of S,
  G being non empty
   NAT-defined (the Instructions of S)-valued FinPartState of S
  holds dom CutLastLoc F misses dom Shift(IncAddr(G,card F -' 1),card F -' 1)
proof
  let S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be initial non empty NAT-defined FinPartState of S,
  G be non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S;
  set k = card F -' 1;
  assume not thesis;
  then consider il being set such that
A1: il in dom CutLastLoc F /\ dom Shift(IncAddr(G,k),k) by XBOOLE_0:4;
A2: il in dom CutLastLoc F by A1,XBOOLE_0:def 4;
A3: il in dom Shift(IncAddr(G,k),k) by A1,XBOOLE_0:def 4;
  dom Shift(IncAddr(G,k),k) = { (m+k) where m is Element of NAT:
  m in dom IncAddr(G,k) } by VALUED_1:def 12;
  then consider m being Element of NAT such that
A4: il = (m+k) and m in dom IncAddr(G,k) by A3;
  reconsider f = CutLastLoc F as non empty NAT-defined FinPartState of S
  by A1,RELAT_1:60;
  m+k <= LastLoc f by A2,A4,VALUED_1:33;
  then
A5: m+k <= card f -' 1 by AFINSQ_1:74;
A6: card f = card F - 1 by VALUED_1:39
    .= card F -' 1 by PRE_CIRC:25;
  per cases;
  suppose k - 1 >= 0;
    then m + k <= k - 1 by A5,A6,XREAL_0:def 2;
    then m + k - k <= k - 1 - k by XREAL_1:11;
    hence thesis by Lm1;
  end;
  suppose k - 1 < 0;
    then m + k = 0 or m + k < 0 by A5,A6,XREAL_0:def 2;
    hence thesis by A6;
  end;
end;

theorem Th101:
  for F being unique-halt (initial non empty NAT-defined FinPartState of S),
  I being Element of NAT st I in dom CutLastLoc F
  holds (CutLastLoc F).I <> halt S
proof
  let F be unique-halt (initial non empty NAT-defined FinPartState of S),
  I be Element of NAT such that
A1: I in dom CutLastLoc F and
A2: (CutLastLoc F).I = halt S;
A3: dom CutLastLoc F c= dom F by GRFUNC_1:8;
  F.I = halt S by A1,A2,GRFUNC_1:8;
  then
A4: I = LastLoc F by A1,A3,Def26;
  dom CutLastLoc F = (dom F) \ {LastLoc F} by VALUED_1:37;
  then not I in {LastLoc F} by A1,XBOOLE_0:def 5;
  hence thesis by A4,TARSKI:def 1;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let F, G be non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S;
  func F ';' G -> (the Instructions of S)-valued NAT-defined FinPartState of S
   equals
  CutLastLoc F +* Shift(IncAddr(G,card F -' 1),card F -' 1);
  coherence;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G be non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S;
  cluster F ';' G -> non empty
  (the Instructions of S)-valued NAT-defined;
  coherence;
end;

theorem Th102:
  for S being regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S,
  G being non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S
  holds card (F ';' G) = card F + card G - 1 &
  card (F ';' G) = card F + card G -' 1
proof
  let S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S,
  G be non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S;
  set k = card F -' 1;
  dom IncAddr(G,k),dom Shift(IncAddr(G,k),k) are_equipotent by VALUED_1:28;
  then
A1: IncAddr(G,k),Shift(IncAddr(G,k),k) are_equipotent by PRE_CIRC:26;
  dom CutLastLoc F misses dom Shift(IncAddr(G,k),k) by Th100;
  hence card (F ';' G)
  = card CutLastLoc F + card Shift(IncAddr(G,k),k) by PRE_CIRC:27
    .= card CutLastLoc F + card IncAddr(G,k) by A1,CARD_1:21
    .= card CutLastLoc F + card dom IncAddr(G,k) by CARD_1:104
    .= card CutLastLoc F + card dom G by Def15
    .= card CutLastLoc F + card G by CARD_1:104
    .= card F - 1 + card G by VALUED_1:39
    .= card F + card G - 1;
  hence thesis by XREAL_0:def 2;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let F, G be initial non empty
  (the Instructions of S)-valued NAT-defined FinPartState of S;
  cluster F ';' G -> initial;
  coherence
  proof
    set P = F ';' G;
    let f,n be Nat such that
A1: n in dom P and
A2: f < n;
    set k = card F -' 1;
A3: dom P = dom CutLastLoc F \/ dom Shift(IncAddr(G,k),k) by FUNCT_4:def 1;
    per cases by A1,A3,XBOOLE_0:def 3;
    suppose n in dom CutLastLoc F;
      then f in dom CutLastLoc F by A2,AFINSQ_1:def 13;
      hence thesis by A3,XBOOLE_0:def 3;
    end;
    suppose n in dom Shift(IncAddr(G,k),k);
      then n in { w+k where w is Element of NAT:
      w in dom IncAddr(G,k) } by VALUED_1:def 12;
      then consider m being Element of NAT such that
A4:   n = (m+k) and
A5:   m in dom IncAddr(G,k);
A7:   m in dom G by A5,Def15;
      now per cases;
        case
A8:       f < k;
          then f < card F - 1 by PRE_CIRC:25;
          then 1+f < 1 + (card F - 1) by XREAL_1:8;
          then
A9:       1+f in dom F by AFINSQ_1:70;
          f < 1+f by NAT_1:19;
          then
A10:      f in dom F by A9,AFINSQ_1:def 13;
          f <> LastLoc F by A8,AFINSQ_1:74;
          then not f in {LastLoc F} by TARSKI:def 1;
          then f in (dom F) \ {LastLoc F} by A10,XBOOLE_0:def 5;
          hence f in dom CutLastLoc F by VALUED_1:37;
        end;
        case f >= k;
          then consider l1 being Nat such that
A11:      f = k + l1 by NAT_1:10;
          reconsider l1 as Element of NAT by ORDINAL1:def 13;
A12:      dom Shift(IncAddr(G,k),k) =
{ w+k where w is Element of NAT: w in dom IncAddr(G,k) }
          by VALUED_1:def 12;
          l1 < m or l1 = m by A11,A4,A2,XREAL_1:8;
          then l1 in dom G by A7,AFINSQ_1:def 13;
          then l1 in dom IncAddr(G,k) by Def15;
          hence f in dom Shift(IncAddr(G,k),k) by A12,A11;
        end;
      end;
      hence thesis by A3,XBOOLE_0:def 3;
    end;
  end;
end;

theorem
  for S being regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S
  holds dom F c= dom (F ';' G)
proof
  let S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S;
  set P = F ';' G;
A1: dom P = dom CutLastLoc F \/ dom Shift(IncAddr(G,card F -' 1),card F -' 1)
  by FUNCT_4:def 1;
A2: dom F = dom CutLastLoc F \/ {LastLoc F} by VALUED_1:38;
  let x be set;
  assume
A3: x in dom F;
  per cases by A2,A3,XBOOLE_0:def 3;
  suppose x in dom CutLastLoc F;
    hence thesis by A1,XBOOLE_0:def 3;
  end;
  suppose
A4: x in {LastLoc F};
    then
A5: x = LastLoc F by TARSKI:def 1;
    reconsider f = x as Element of NAT by A4;
A6: f = card F -' 1 by A5,AFINSQ_1:74
      .= card F - 1 + (0 qua Nat) by PRE_CIRC:25;
    card P = card F + card G - 1 by Th102
      .= card F - 1 + card G;
    then f < card P by A6,XREAL_1:8;
    hence thesis by AFINSQ_1:70;
  end;
end;

theorem Th104:
  for S being regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S
  holds CutLastLoc F c= CutLastLoc (F ';' G)
proof
  let S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S;
  set k = card F -' 1;
  set P = F ';' G;
A1: dom P = dom CutLastLoc F \/ dom Shift(IncAddr(G,k),k) by FUNCT_4:def 1;
A2: dom CutLastLoc F =
  { m where m is Element of NAT: m < card CutLastLoc F } by AFINSQ_1:72;
A3: card CutLastLoc P = card P - 1 by VALUED_1:39
    .= card F + card G - 1 - 1 by Th102
    .= card F - 1 + (card G - 1);
A4: for m being Element of NAT
  st m < card CutLastLoc F holds m < card CutLastLoc P
  proof
    let m be Element of NAT such that
A5: m < card CutLastLoc F;
A6: card CutLastLoc F = card F - 1 by VALUED_1:39;
    1 <= card G by NAT_1:14;
    then 1 - 1 <= card G - 1 by XREAL_1:11;
    then card F - 1 + (0 qua Nat) <= card F - 1 + (card G - 1) by XREAL_1:8;
    hence thesis by A3,A5,A6,XXREAL_0:2;
  end;
A7: dom CutLastLoc F c= dom CutLastLoc P
  proof
    let x be set;
    assume x in dom CutLastLoc F;
    then consider m being Element of NAT such that
A8: x = m and
A9: m < card CutLastLoc F by A2;
    m < card CutLastLoc P by A4,A9;
    hence thesis by A8,AFINSQ_1:70;
  end;
  for x being set st x in dom CutLastLoc F holds
  (CutLastLoc F).x = (CutLastLoc P).x
  proof
    let x be set;
    assume
A10: x in dom CutLastLoc F;
    then consider m being Element of NAT such that
A11: x = m and
A12: m < card CutLastLoc F by A2;
A13: dom Shift(IncAddr(G,k),k) = { w+k where w is Element of NAT:
    w in dom IncAddr(G,k) } by VALUED_1:def 12;
A14: now
      assume x in dom Shift(IncAddr(G,k),k);
      then consider w being Element of NAT such that
A15:  x = w+k and w in dom IncAddr(G,k) by A13;
      m < card F - 1 by A12,VALUED_1:39;
      then
      m < k by PRE_CIRC:25;
      hence contradiction by A11,A15,NAT_1:11;
    end;
A17: x in dom P by A1,A10,XBOOLE_0:def 3;
    now
      assume x = LastLoc P;
      then
A18:  m = card P -' 1 by A11,AFINSQ_1:74
        .= card P - 1 by PRE_CIRC:25;
      card CutLastLoc P = card P - 1 by VALUED_1:39;
      hence contradiction by A4,A12,A18;
    end;
    then not x in {LastLoc P} by TARSKI:def 1;
    then not x in dom ( LastLoc P .--> P.LastLoc P ) by FUNCOP_1:19;
    then x in dom P \ dom ( LastLoc P .--> P.LastLoc P ) by A17,XBOOLE_0:def 5;
    hence (CutLastLoc P).x = (CutLastLoc F +* Shift(IncAddr(G,k),k)).x
    by GRFUNC_1:93
      .= (CutLastLoc F).x by A14,FUNCT_4:12;
  end;
  hence thesis by A7,GRFUNC_1:8;
end;

theorem Th55:
  for S being regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S
  holds (F ';' G).LastLoc F = IncAddr(G,card F -' 1).0
proof
  let S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S;
  set k = card F -' 1;
A1: LastLoc F = (0 qua Nat)+k by AFINSQ_1:74;
A2: 0 in dom IncAddr(G,k) by AFINSQ_1:69;
  dom Shift(IncAddr(G,k),k) =
  {(m+k) where m is Element of NAT: m in dom IncAddr(G,k)}
  by VALUED_1:def 12;
  then LastLoc F in dom Shift(IncAddr(G,k),k) by A1,A2;
  hence (F ';' G).LastLoc F = (Shift(IncAddr(G,k),k)).LastLoc F by FUNCT_4:14
    .= IncAddr(G,k).0 by A1,A2,VALUED_1:def 12;
end;

theorem
  for S being regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G being initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S,
  f being Element of NAT st f < card F - 1
  holds IncAddr(F,card F -' 1).f = IncAddr(F ';' G, card F -' 1).f
proof
  let S be regular  homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)),
  F, G be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S,
  f be Element of NAT;
  set k = card F -' 1, P = F ';' G;
  assume f < card F - 1;
  then f < card CutLastLoc F by VALUED_1:39;
  then
A1: f in dom CutLastLoc F by AFINSQ_1:70;
A3: dom CutLastLoc F c= dom F by GRFUNC_1:8;
  CutLastLoc F c= CutLastLoc P by Th104;
  then CutLastLoc F c= P by XBOOLE_1:1;
  then
A4: dom CutLastLoc F c= dom P by GRFUNC_1:8;
A5: F.f = F/.f by A1,A3,PARTFUN1:def 8;
  dom CutLastLoc F misses dom Shift(IncAddr(G,k),k) by Th100;
  then dom CutLastLoc F /\ dom Shift(IncAddr(G,k),k) = {} by XBOOLE_0:def 7;
  then not f in dom Shift(IncAddr(G,k),k)
  by A1,XBOOLE_0:def 4;
  then
A6: P.f = (CutLastLoc F).f by FUNCT_4:12
    .= F.f by A1,GRFUNC_1:8;
  thus IncAddr(F,k).f = IncAddr(F/.f,k) by A1,A3,Def15
    .= IncAddr(P/.f,k) by A1,A4,A5,A6,PARTFUN1:def 8
    .= IncAddr(P,k).f by A1,A4,Def15;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be regular  homogeneous J/A-independent  realistic proper-halt

   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let F be initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S;
  let G be halt-ending (initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S);
  cluster F ';' G -> halt-ending;
  coherence
  proof
    set P = F ';' G, k = card F -' 1;
A1: dom Shift(IncAddr(G,k),k) = { (m+k) where m is Element of NAT:
    m in dom IncAddr(G,k) } by VALUED_1:def 12;
A2: card G -' 1 = LastLoc G by AFINSQ_1:74;
    then
A3: card G -' 1 in dom G by VALUED_1:31;
    then
A4: card G -' 1 in dom IncAddr(G,k) by Def15;
    then
A5: k + (card G -' 1) in dom Shift(IncAddr(G,k),k) by A1;
A6: G/.(card G -' 1) = G.(card G -' 1) by A2,PARTFUN1:def 8,VALUED_1:31
      .= halt S by A2,Def25;
A7: card G - 1 >= 0 by NAT_1:14,XREAL_1:50;
    then k + (card G - 1) >= k+(0 qua Nat) by XREAL_1:8;
    then
A8: k + card G -' 1 = k + card G - 1 by XREAL_0:def 2
      .= k + (card G - 1)
      .= k + (card G -' 1) by A7,XREAL_0:def 2;
    thus P.(LastLoc P) = P.(card P -' 1) by AFINSQ_1:74
      .= P.(card F + card G -' 1 -' 1) by Th102
      .= P.(k + card G -' 1) by NAT_1:14,NAT_D:38
      .= Shift(IncAddr(G,k),k).(k + (card G -' 1)) by A5,A8,FUNCT_4:14
      .= IncAddr(G,k).(card G -' 1) by A4,VALUED_1:def 12
      .= IncAddr(G/.(card G -' 1),k) by A3,Def15
      .= halt S by A6,Th29;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be regular  homogeneous J/A-independent  realistic proper-halt

   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let F, G be halt-ending unique-halt
  (initial non empty NAT-defined
  (the Instructions of S)-valued FinPartState of S);
  cluster F ';' G -> unique-halt;
  coherence
  proof
    set P = F ';' G, k = card F -' 1;
A1: dom P = dom CutLastLoc F \/ dom Shift(IncAddr(G,k),k) by FUNCT_4:def 1;
A2: dom Shift(IncAddr(G,k),k) = { (m+k) where m is Element of NAT:
    m in dom IncAddr(G,k) } by VALUED_1:def 12;
A3: card G - 1 >= 0 by NAT_1:14,XREAL_1:50;
    then k + (card G - 1) >= k+(0 qua Nat) by XREAL_1:8;
    then
A4: k + card G -' 1 = k + card G - 1 by XREAL_0:def 2
      .= k + (card G - 1)
      .= k + (card G -' 1) by A3,XREAL_0:def 2;
    let f be Element of NAT such that
A5: P.f = halt S and
A6: f in dom P;
    per cases by A1,A6,XBOOLE_0:def 3;
    suppose
A7:   f in dom CutLastLoc F;
      then
A8:   (CutLastLoc F).f <> halt S by Th101;
      dom CutLastLoc F misses dom Shift(IncAddr(G,k),k) by Th100;
      then CutLastLoc F c= P by FUNCT_4:33;
      hence thesis by A5,A7,A8,GRFUNC_1:8;
    end;
    suppose
A9:   f in dom Shift(IncAddr(G,k),k);
      then consider m being Element of NAT such that
A10:  f = (m+k) and
A11:  m in dom IncAddr(G,k) by A2;
A12:  m in dom G by A11,Def15;
      then
A13:  G/.m = G.m by PARTFUN1:def 8;
      IncAddr(G/.m,k) = IncAddr(G,k).m by A12,Def15
        .= Shift(IncAddr(G,k),k).(m+k) by A11,VALUED_1:def 12
        .= halt S by A5,A9,A10,FUNCT_4:14;
      then m = LastLoc G by A12,A13,Th35,Def26
        .= (card G -' 1) by AFINSQ_1:74;
      then m+k = card F + card G -' 1 -' 1 by A4,NAT_1:14,NAT_D:38
        .= card P -' 1 by Th102;
      hence thesis by A10,AFINSQ_1:74;
    end;
  end;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be regular homogeneous J/A-independent  realistic proper-halt

   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
  let F, G be pre-Macro of S;
  redefine func F ';' G -> pre-Macro of S;
  coherence;
end;

theorem Th57:
  for S being regular homogeneous J/A-independent proper-halt
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  holds IncAddr(Stop S, k) = Stop S
proof
  let S be regular homogeneous J/A-independent proper-halt
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
A1: dom IncAddr(Stop S, k) = dom Stop S by Def15
    .= {0} by Lm5;
A2: dom Stop S = {0} by Lm5;
  for x being set st x in {0} holds IncAddr(Stop S, k).x = (Stop S). x
  proof
    let x be set;
    assume
A3: x in {0};
    then
A4: x = 0 by TARSKI:def 1;
    then
A5: (Stop S)/.0 = (Stop S).0 by A2,A3,PARTFUN1:def 8
      .= halt S by FUNCOP_1:87;
    thus IncAddr(Stop S, k).x
    = IncAddr((Stop S)/.0,k) by A2,A3,A4,Def15
      .= halt S by A5,Th29
      .= (Stop S).x by A4,FUNCOP_1:87;
  end;
  hence thesis by A1,A2,FUNCT_1:9;
end;

theorem Th108:
  for k being Element of NAT
  for S being (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N))
  holds Shift(Stop S, k) = k .--> halt S
proof
  let k be Element of NAT;
  let S be (IC-Ins-separated definite
  (non empty stored-program COM-Struct over N));
A1: dom Shift(Stop S,k) =
  {(m+k) where m is Element of NAT: m in dom Stop S} by VALUED_1:def 12;
A2: 0 in dom Stop S by Lm5;
A3: dom Shift(Stop S,k) = {k}
  proof
    hereby
      let x be set;
      assume x in dom Shift(Stop S,k);
      then consider m being Element of NAT such that
A4:   x = (m+k) and
A5:   m in dom Stop S by A1;
      m in {0} by A5,Lm5;
      then m = 0 by TARSKI:def 1;
      hence x in {k} by A4,TARSKI:def 1;
    end;
    let x be set;
    assume x in {k};
    then x = (0 qua Nat)+k by TARSKI:def 1;
    hence thesis by A1,A2;
  end;
A6: dom (k .--> halt S) = {k} by FUNCOP_1:19;
  for x being set st x in {k} holds
  (Shift(Stop S, k)).x = (k .--> halt S).x
  proof
    let x be set;
    assume x in {k};
    then
A7: x = (0 qua Nat)+k by TARSKI:def 1;
    0 in dom Stop S by Lm5;
    hence (Shift(Stop S, k)).x = (Stop S).0 by A7,VALUED_1:def 12
      .= halt S by FUNCOP_1:87
      .= (k .--> halt S).x by A7,FUNCOP_1:87;
  end;
  hence thesis by A3,A6,FUNCT_1:9;
end;

theorem Th5:
  for S being regular homogeneous J/A-independent proper-halt
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), F being pre-Macro of S
  holds F ';' Stop S = F
proof
  let S be regular homogeneous J/A-independent proper-halt
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), F be pre-Macro of S;
  set k = card F -' 1;
A1: F ';' Stop S = CutLastLoc F +* Shift(Stop S,k) by Th57;
A2: dom F = dom CutLastLoc F \/ {LastLoc F} by VALUED_1:38;
  dom Shift(Stop S,k) = dom (k .--> halt S) by Th108
    .= {k} by FUNCOP_1:19
    .= {LastLoc F} by AFINSQ_1:74;
  then
A3: dom (F ';' Stop S) = dom F by A1,A2,FUNCT_4:def 1;
  for x being set st x in dom F holds (F ';' Stop S).x = F.x
  proof
    let x be set such that
A4: x in dom F;
    dom CutLastLoc F misses dom Shift(IncAddr(Stop S,k),k) by Th100;
    then
A5: {} = dom CutLastLoc F /\ dom Shift(IncAddr(Stop S,k),k) by XBOOLE_0:def 7;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A6:   x in dom CutLastLoc F;
      then not x in dom Shift(IncAddr(Stop S,k),k) by A5,XBOOLE_0:def 4;
      hence (F ';' Stop S).x = (CutLastLoc F).x by FUNCT_4:12
        .= F.x by A6,GRFUNC_1:8;
    end;
    suppose x in {LastLoc F};
      then
A7:   x = LastLoc F by TARSKI:def 1;
      then
A8:   x = k by AFINSQ_1:74;
A9:   0 in dom Stop S by Lm5;
      dom Shift(Stop S,k)
      = { (m+k) where m is Element of NAT: m in dom Stop S }
      by VALUED_1:def 12;
      then (0 qua Nat)+k in dom Shift(Stop S,k) by A9;
      hence (F ';' Stop S).x = Shift(Stop S,(0 qua Nat)+k).x
       by A1,A8,FUNCT_4:14
        .= (Stop S).0 by A8,A9,VALUED_1:def 12
        .= halt S by FUNCOP_1:87
        .= F.x by A7,Def25;
    end;
  end;
  hence thesis by A3,FUNCT_1:9;
end;

theorem Th110:
  for S being regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), F being pre-Macro of S
  holds Stop S ';' F = F
proof
  let S be regular homogeneous J/A-independent realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program COM-Struct over N)), F be pre-Macro of S;
  set k = card Stop S -' 1;
A1: k = 0 by Lm6;
  hence Stop S ';' F = CutLastLoc Stop S +* Shift(F,k) by Th38
    .= CutLastLoc Stop S +* F by A1,VALUED_1:29
    .= F by FUNCT_4:21;
end;

theorem
  for S being regular homogeneous J/A-independent realistic proper-halt

   (standard-ins IC-Ins-separated
  definite (non empty stored-program COM-Struct over N)),
  F, G, H being pre-Macro of S holds F ';' G ';' H = F ';' (G ';' H)
proof
  let S be regular homogeneous J/A-independent realistic proper-halt

   (standard-ins IC-Ins-separated
  definite (non empty stored-program COM-Struct over N)),
  F, G, H be pre-Macro of S;
  per cases;
  suppose
A1: F = Stop S;
    hence F ';' G ';' H = G ';' H by Th110
      .= F ';' (G ';' H) by A1,Th110;
  end;
  suppose
A2: G = Stop S;
    hence F ';' G ';' H = F ';' H by Th5
      .= F ';' (G ';' H) by A2,Th110;
  end;
  suppose that
A3: F <> Stop S and
A4: G <> Stop S;
    set X = {k where k is Element of NAT:
    k < card F + card G + card H - 1 - 1};
A5: card (F ';' G ';' H) = card (F ';' G) + card H - 1 by Th102
      .= card F + card G - 1 + card H - 1 by Th102
      .= card F + card G + card H - 1 - 1;
A6: card (F ';' (G ';' H)) = card F + card (G ';' H) - 1 by Th102
      .= card F + (card G + card H - 1) - 1 by Th102
      .= card F + card G + card H - 1 - 1;
A7: dom (F ';' G ';' H) = X by A5,AFINSQ_1:72;
A8: dom (F ';' (G ';' H)) = X by A6,AFINSQ_1:72;
    for x being set st x in X holds (F ';' G ';' H).x = (F ';' (G ';' H)) . x
    proof
      let x be set;
      assume x in X;
      then consider k being Element of NAT such that
A9:   x = k and
A10:  k < card F + card G + card H - 1 - 1;
A11:  dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) =
      { m+(card F -' 1) where m is Element of NAT:
      m in dom IncAddr(G ';' H,card F -' 1) } by VALUED_1:def 12;
A12:  dom Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1) =
      { m+(card (F ';' G) -' 1) where m is Element of NAT:
      m in dom IncAddr(H,card (F ';' G) -' 1) } by VALUED_1:def 12;
A13:  dom Shift(IncAddr(H,card G -' 1),card G -' 1) =
      { m+(card G -' 1) where m is Element of NAT:
      m in dom IncAddr(H,card G -' 1) } by VALUED_1:def 12;
A14:  card (F ';' G) -' 1 = card (F ';' G) - 1 by PRE_CIRC:25
        .= card F + card G - 1 - 1 by Th102;
      then card (F ';' G) -' 1 = card F - 1 + (card G - 1);
      then
A15:  card (F ';' G) -' 1 = (card G -' 1) + (card F - 1) by PRE_CIRC:25
        .= (card G -' 1) + (card F -' 1) by PRE_CIRC:25;
A16:  dom Shift(IncAddr(G,card F -' 1),card F -' 1) =
      { m+(card F -' 1) where m is Element of NAT:
      m in dom IncAddr(G,card F -' 1) } by VALUED_1:def 12;
A17:  card F -' 1 = card F - 1 by PRE_CIRC:25;
A18:  card G -' 1 = card G - 1 by PRE_CIRC:25;
A19:  for W being pre-Macro of S st W <> Stop S holds 2 <= card W
      proof
        let W be pre-Macro of S;
        assume
A20:    W <> Stop S;
        assume 2 > card W;
        then 1 + 1 > card W;
        then card W <= 1 by NAT_1:13;
        hence contradiction by A20,Th89,NAT_1:26;
      end;
      then 2 <= card F by A3;
      then
A21:  1 <= card F by XXREAL_0:2;
A22:  2 <= card G by A4,A19;
      per cases by A21,A22,Lm2;
      suppose
A23:    k < card F - 1;
A24:    CutLastLoc F c= CutLastLoc (F ';' G) by Th104;
A25:    now
          assume x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1);
          then consider m being Element of NAT such that
A26:      x = m+(card F -' 1) and
          m in dom IncAddr(G ';' H,card F -' 1) by A11;
          k = m + (card F - 1) by A9,A26,PRE_CIRC:25;
          then m + (card F - 1) < card F -' 1 by A23,PRE_CIRC:25;
          then m + (card F -' 1) < card F -' 1 by PRE_CIRC:25;
          hence contradiction by NAT_1:11;
        end;
A27:    now
          assume x in dom
          Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1);
          then consider m being Element of NAT such that
A28:      x = m+(card (F ';' G) -' 1) and
          m in dom IncAddr(H,card (F ';' G) -' 1) by A12;
          m + (card G -' 1) + (card F -' 1) < card F -' 1
          by A23,A9,A15,A28,PRE_CIRC:25;
          hence contradiction by NAT_1:11;
        end;
        k < card CutLastLoc F by A23,VALUED_1:39;
        then
A29:    x in dom CutLastLoc F by A9,AFINSQ_1:70;
        thus (F ';' G ';' H).x = (CutLastLoc (F ';' G)).x by A27,FUNCT_4:12
          .= (CutLastLoc F).x by A24,A29,GRFUNC_1:8
          .= (F ';' (G ';' H)).x by A25,FUNCT_4:12;
      end;
      suppose
A30:    k = card F - 1;
A31:    now
          assume x in dom
          Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1);
          then consider m being Element of NAT such that
A32:      x = m+(card (F ';' G) -' 1) and
          m in dom IncAddr(H,card (F ';' G) -' 1) by A12;
          m + (card G -' 1) + (card F -' 1) = card F -' 1 by A30,A15,A32,A9,
PRE_CIRC:25;
          then card G -' 1 = 0;
          then card G - 1 = 0 by PRE_CIRC:25;
          hence contradiction by A4,Th89;
        end;
A33:    0 in dom IncAddr(G ';' H,card F -' 1) by AFINSQ_1:69;
A34:    0 in dom IncAddr(G,card F -' 1) by AFINSQ_1:69;
A35:    0 in dom G by AFINSQ_1:69;
A36:    0 in dom (G ';' H) by AFINSQ_1:69;
        k = (0 qua Nat) + (card F -' 1) by A30,PRE_CIRC:25;
        then
A37:    x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) by A9,A11,A33;
A38:    k = card F -' 1 by A30,PRE_CIRC:25;
A39:    x = (0 qua Nat)+k by A9;
        0 in dom IncAddr(G,card F -' 1) by AFINSQ_1:69;
        then
A40:    x in dom Shift(IncAddr(G,card F -' 1),card F -' 1) by A16,A38,A39;
then x in dom CutLastLoc F \/ dom Shift(IncAddr(G,card F -' 1),card F -' 1)
        by XBOOLE_0:def 3;
        then
A41:    x in dom (F ';' G) by FUNCT_4:def 1;
        now
A42:      dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G ))
          = {LastLoc (F ';' G)} by FUNCOP_1:19
            .= {card (F ';' G) -' 1} by AFINSQ_1:74;
assume x in dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G ));
          then x = card (F ';' G) -' 1 by A42,TARSKI:def 1;
          then card G - 1 = 0 by A38,A9,A15,PRE_CIRC:25;
          hence contradiction by A4,Th89;
        end;
        then
A43:    x in dom (F ';' G) \
        dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G ))
        by A41,XBOOLE_0:def 5;
        1 <= card G by NAT_1:14;
        then card G > 1 by A4,Th89,XXREAL_0:1;
        then
A44:    card G - 1 > 1 - 1 by XREAL_1:11;
        then card G -' 1 > 1 - 1 by PRE_CIRC:25;
        then
A45:    not 0 in dom Shift(IncAddr(H,card G -' 1), card G -' 1) by VALUED_1:30;
        card CutLastLoc G <> {} by A44,VALUED_1:39;
        then
A46:    0 in dom CutLastLoc G by AFINSQ_1:69,CARD_1:47;
A47:    G/.0 = G.0 by A35,PARTFUN1:def 8
          .= (CutLastLoc G).0 by A46,GRFUNC_1:8
          .= (G ';' H).0 by A45,FUNCT_4:12
          .= (G ';' H)/.0 by A36,PARTFUN1:def 8;
        thus (F ';' G ';' H).x = ((F ';' G) \
        ( LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G ))).x by A31,
FUNCT_4:12
.= (CutLastLoc F +* Shift(IncAddr(G,card F -' 1),card F -' 1)).x by A43,
GRFUNC_1:93
          .= Shift(IncAddr(G,card F -' 1),card F -' 1).x by A40,FUNCT_4:14
          .= IncAddr(G,card F -' 1).0 by A34,A38,A39,VALUED_1:def 12
          .= IncAddr((G ';' H)/.0,card F -' 1) by A35,A47,Def15
          .= IncAddr(G ';' H,card F -' 1).0 by A36,Def15
          .= Shift(IncAddr(G ';' H,card F -' 1),card F -' 1).x
        by A33,A38,A39,VALUED_1:def 12
          .= (F ';' (G ';' H)).x by A37,FUNCT_4:14;
      end;
      suppose that
A48:    card F <= k and
A49:    k <= card F + card G - 3;
A50:    now
          assume
          x in dom Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1);
          then consider m being Element of NAT such that
A51:      x = m+(card (F ';' G) -' 1) and
          m in dom IncAddr(H,card (F ';' G) -' 1) by A12;
          m + ((card G -' 1) + (card F -' 1))
          <= - 1 + ((card G -' 1) + (card F -' 1)) by A9,A15,A17,A18,A49,A51;
          then m <= -1 by XREAL_1:8;
          hence contradiction;
        end;
        card F -' 1 <= card F by NAT_D:35;
        then
A52:    x = k -' (card F -' 1) + (card F -' 1)
        by A9,A48,XREAL_1:237,XXREAL_0:2;
A53:    card F - card F <= k - card F by A48,XREAL_1:11;
        card F - 1 < card F - 0 by XREAL_1:17;
        then k - (card F - 1) >= 0 by A53,XREAL_1:17;
        then
A54:    k - (card F -' 1) >= 0 by PRE_CIRC:25;
A55:    card F + card G - 3 < card F + card G - 3 + 1 by XREAL_1:31;
        then
A56:    k < (card G - 1) + (card F - 1) by A49,XXREAL_0:2;
        k - (card F - 1) + (card F - 1) < (card G - 1) + (card F - 1)
        by A49,A55,XXREAL_0:2;
        then k - (card F - 1) < card G - 1 by XREAL_1:9;
        then k - (card F -' 1) < card G - 1 by PRE_CIRC:25;
        then k -' (card F -' 1) < card G - 1 by A54,XREAL_0:def 2;
        then k -' (card F -' 1) < card CutLastLoc G by VALUED_1:39;
        then
A57:    k -' (card F -' 1) in dom CutLastLoc G by AFINSQ_1:70;
        then k -' (card F -' 1) in
        dom CutLastLoc G \/ dom Shift(IncAddr(H,card G -' 1),card G -' 1)
        by XBOOLE_0:def 3;
        then
A58:    k -' (card F -' 1) in dom (G ';' H) by FUNCT_4:def 1;
        then
A59:    k -' (card F -' 1) in dom IncAddr(G ';' H,card F -' 1)
        by Def15;
        then
A60:    x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) by A11,A52;
        card G + card F - 2 < card F + card G - 1 by XREAL_1:17;
        then k < card F + card G - 1 by A56,XXREAL_0:2;
        then k < card (F ';' G) by Th102;
        then
A61:    x in dom (F ';' G) by A9,AFINSQ_1:70;
        now
          assume x in dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G));
          then x in {LastLoc (F ';' G)} by FUNCOP_1:19;
          then x = LastLoc (F ';' G) by TARSKI:def 1
            .= card (F ';' G) -' 1 by AFINSQ_1:74;
          then k = (card G - 1) + (card F - 1) by A9,A15,A18,PRE_CIRC:25;
          hence contradiction by A49,A55;
        end;
        then
A62:    x in dom (F ';' G) \
        dom (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G))
        by A61,XBOOLE_0:def 5;
A63:    dom CutLastLoc G c= dom G by GRFUNC_1:8;
        then k -' (card F -' 1) in dom G by A57;
        then
A64:    k -' (card F -' 1) in dom IncAddr(G,card F -' 1) by Def15;
        then
A65:    x in dom Shift(IncAddr(G,card F -' 1),card F -' 1) by A16,A52;
A66:    now
          assume k -' (card F -' 1) in
          dom Shift(IncAddr(H,card G -' 1),card G -' 1);
          then consider m being Element of NAT such that
A67:      k -' (card F -' 1) = m+(card G -' 1) and
          m in dom IncAddr(H,card G -' 1) by A13;
A68:      m = k -' (card F -' 1) - (card G -' 1) by A67
            .= k - (card F -' 1) - (card G -' 1) by A54,XREAL_0:def 2
            .= k - (card F - 1) - (card G -' 1) by PRE_CIRC:25
            .= k - (card F - 1) - (card G - 1) by PRE_CIRC:25
            .= k - (card F + card G - 2);
          k - (card F + card G - 2)
          <= card F + card G - 3 - (card F + card G - 2) by A49,XREAL_1:11;
          hence contradiction by A68,Lm1;
        end;
A69:    (G ';' H)/.(k -' (card F -' 1))
        = (CutLastLoc G +* Shift(IncAddr(H,card G -' 1),card G -' 1))
        .(k -' (card F -' 1)) by A58,PARTFUN1:def 8
          .= (CutLastLoc G).(k -' (card F -' 1)) by A66,FUNCT_4:12
          .= G.(k -' (card F -' 1)) by A57,GRFUNC_1:8;
        thus (F ';' G ';' H).x
        = ((F ';' G) \ (LastLoc (F ';' G) .--> (F ';' G).LastLoc (F ';' G))).x
        by A50,FUNCT_4:12
.= (CutLastLoc F +* Shift(IncAddr(G,card F -' 1),card F -' 1)).x by A62,
GRFUNC_1:93
          .= Shift(IncAddr(G,card F -' 1),card F -' 1).x by A65,FUNCT_4:14
          .= IncAddr(G,card F -' 1).(k -' (card F -' 1))
           by A52,A64,VALUED_1:def 12
          .= IncAddr(G/.(k -' (card F -' 1)),card F -' 1)
        by A57,A63,Def15
          .= IncAddr((G ';' H)/.(k -' (card F -' 1)),card F -' 1)
        by A57,A63,A69,PARTFUN1:def 8
          .= IncAddr(G ';' H,card F -' 1).(k -' (card F -' 1))
        by A58,Def15
          .= Shift(IncAddr(G ';' H,card F -' 1),card F -' 1).x
           by A52,A59,VALUED_1:def 12
          .= (F ';' (G ';' H)).x by A60,FUNCT_4:14;
      end;
      suppose
A70:    k = card F + card G - 2;
        then
A71:    x = (k -' (card (F ';' G) -' 1) + (card (F ';' G) -' 1))
        by A9,A14,XREAL_1:237;
        k - (card (F ';' G) -' 1) = 0 by A14,A70;
        then
A72:    k -' (card (F ';' G) -' 1) = 0 by XREAL_0:def 2;
        then
A73:    k -' (card (F ';' G) -' 1) in dom IncAddr(H,card (F ';' G)
        -' 1) by AFINSQ_1:69;
        then
A74:    x in dom Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1)
        by A12,A71;
A75:    x = (card G -' 1) + (card F -' 1) by A9,A17,A18,A70;
        card G - 1 + (0 qua Nat) < card G - 1 + card H by XREAL_1:8;
        then card G -' 1 < card G + card H - 1 by PRE_CIRC:25;
        then card G -' 1 < card (G ';' H) by Th102;
        then
A76:    (card G -' 1) in dom (G ';' H) by AFINSQ_1:70;
        then
A77:    (card G -' 1) in dom IncAddr(G ';' H,card F -' 1) by Def15;
        then
A78:    x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) by A11,A75;
A79:    0 in dom H by AFINSQ_1:69;
A80:    (G ';' H)/.(card G -' 1) = (G ';' H).(card G -' 1)
        by A76,PARTFUN1:def 8;
A81:    0 in dom IncAddr(H,card G -' 1) by AFINSQ_1:69;
        then
A82:    IncAddr(H,card G -' 1)/.0
        = IncAddr(H,card G -' 1).0 by PARTFUN1:def 8
          .= IncAddr(H/.0,(card G -' 1)) by A79,Def15;
        (G ';' H)/.(card G -' 1)
        = (G ';' H).LastLoc G by A80,AFINSQ_1:74
          .= IncAddr(H,card G -' 1).0 by Th55
          .= IncAddr(H,card G -' 1)/.0 by A81,PARTFUN1:def 8;
        then
A83:    IncAddr((G ';' H)/.(card G -' 1),card F -' 1)
        = IncAddr(H/.0,card (F ';' G) -' 1) by A15,A82,Th37;
        thus (F ';' G ';' H).x
        = Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1).x
        by A74,FUNCT_4:14
          .= IncAddr(H,card (F ';' G) -' 1).(k -' (card (F ';' G) -' 1))
        by A71,A73,VALUED_1:def 12
          .= IncAddr(H/.0,card (F ';' G) -' 1) by A72,A79,Def15
          .= IncAddr(G ';' H,card F -' 1).(card G -' 1) by A76,A83,Def15
          .= Shift(IncAddr(G ';' H,card F -' 1),card F -' 1).x
           by A75,A77,VALUED_1:def 12
          .= (F ';' (G ';' H)).x by A78,FUNCT_4:14;
      end;
      suppose
A84:    card F + card G - 2 < k;
        then
A85:    x = (k -' (card (F ';' G) -' 1) + (card (F ';' G) -' 1))
        by A9,A14,XREAL_1:237;
        k + (0 qua Nat) < card F + card G - (1 + 1) + card H by A10;
        then k - (card F + card G - (1 + 1)) < card H - 0 by XREAL_1:23;
        then k -' (card (F ';' G) -' 1) < card H by A14,XREAL_0:def 2;
        then
A86:    k -' (card (F ';' G) -' 1) in dom H by AFINSQ_1:70;
        then
A87:    k -' (card (F ';' G) -' 1) in dom IncAddr(H,card (F ';' G)
        -' 1) by Def15;
        then
A88:    x in dom Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1)
        by A12,A85;
A89:    card F -' 1 <= (card G -' 1) + (card F -' 1) by NAT_1:11;
        then
A90:    k >= card F -' 1 by A14,A15,A84,XXREAL_0:2;
A91:    x = k -' (card F -' 1) + (card F -' 1) by A9,A14,A15,A84,A89,
XREAL_1:237,XXREAL_0:2;
A92:    k - (card F -' 1) >= 0 by A90,XREAL_1:50;
A93:    k - (card F -' 1) < card F + card G + card H - 1 - 1 - (card F -' 1)
        by A10,XREAL_1:11;
        then
A94:    k -' (card F -' 1) < card F + card G + card H - card F - 1
        by A17,A92,XREAL_0:def 2;
        k -' (card F -' 1) < card F - card F + card G + card H - 1
        by A17,A92,A93,XREAL_0:def 2;
        then k -' (card F -' 1) < card (G ';' H) by Th102;
        then
A95:    k -' (card F -' 1) in dom (G ';' H) by AFINSQ_1:70;
        then k -' (card F -' 1) in dom IncAddr(G ';' H,card F -' 1)
        by Def15;
        then
A96:    x in dom Shift(IncAddr(G ';' H,card F -' 1),card F -' 1) by A11,A91;
A97:    k -' (card F -' 1) in dom IncAddr(G ';' H,card F -' 1)
        by A95,Def15;
A98:    k - (card F -' 1) >= card (F ';' G) -' 1 - (card F -' 1)
        by A14,A84,XREAL_1:11;
        then
A99:    k -' (card F -' 1) >= (card F -' 1) + (card G -' 1) - ( card F -' 1)
        by A14,A15,A84,A89,XREAL_1:235,XXREAL_0:2;
A100:   k -' (card F -' 1) >= card G -' 1 by A14,A15,A84,A89,A98,XREAL_1:235
,XXREAL_0:2;
A101:   k -' (card F -' 1) =
        k -' (card F -' 1) -' (card G -' 1) + (card G -' 1) by A99,XREAL_1:237;
        k -' (card F -' 1) - (card G -' 1) < card G + card H - 1 - (card G -
        1) by A18,A94,XREAL_1:11;
        then k -' (card F -' 1) -' (card G -' 1) <
        card H + (card G - 1) - (card G - 1) by A100,XREAL_1:235;
then k -' (card F -' 1) -' (card G -' 1) in dom H by AFINSQ_1:70;
        then
A102:   k -' (card F -' 1) -' (card G -' 1) in
        dom IncAddr(H,card G -' 1) by Def15;
        then
A103:   k -' (card F -' 1) in
        dom Shift(IncAddr(H,card G -' 1),card G -' 1) by A13,A101;
A104:   k -' (card F -' 1) -' (card G -' 1)
        = k -' (card F -' 1) - (card G -' 1) by A99,XREAL_1:235
       .= k - (card F -' 1) - (card G -' 1) by A14,A15,A84,A89,XREAL_1:235
,XXREAL_0:2
          .= k - ((card F -' 1) + (card G -' 1))
          .= k -' (card (F ';' G) -' 1) by A14,A15,A84,XREAL_1:235;
A105:   (G ';' H)/.(k -' (card F -' 1))
        = ((CutLastLoc G) +* Shift(IncAddr(H,card G -' 1),card G -' 1)).
        (k -' (card F -' 1)) by A95,PARTFUN1:def 8
.= Shift(IncAddr(H,card G -' 1),card G -' 1).(k -' (card F -' 1))
        by A103,FUNCT_4:14
.= IncAddr(H,card G -' 1).(k -' (card (F ';' G) -' 1)) by A101,A102,A104,
VALUED_1:def 12
          .= IncAddr(H/.(k -' (card (F ';' G) -' 1)),card G -' 1)
        by A86,Def15;
        thus (F ';' G ';' H).x
        = Shift(IncAddr(H,card (F ';' G) -' 1),card (F ';' G) -' 1).x
        by A88,FUNCT_4:14
          .= IncAddr(H,card (F ';' G) -' 1).(k -' (card (F ';' G) -' 1))
        by A85,A87,VALUED_1:def 12
.= IncAddr(H/.(k -' (card (F ';' G) -' 1)),card (F ';' G) -' 1)
        by A86,Def15
          .= IncAddr((G ';' H)/.(k -' (card F -' 1)),card F -' 1)
        by A15,A105,Th37
          .= IncAddr(G ';' H,card F -' 1).(k -' (card F -' 1))
        by A95,Def15
          .= Shift(IncAddr(G ';' H,card F -' 1),card F -' 1).x
           by A91,A97,VALUED_1:def 12
          .= (F ';' (G ';' H)).x by A96,FUNCT_4:14;
      end;
    end;
    hence thesis by A7,A8,FUNCT_1:9;
  end;
end;

theorem
  for S being regular homogeneous
  (standard-ins non empty stored-program COM-Struct over N),
  I being Instruction of S, x being set st x in dom JumpPart I holds
  (JumpPart I).x in (product" JumpParts InsCode I).x
proof
  let S be regular homogeneous
  (standard-ins non empty stored-program COM-Struct over N),
  I be Instruction of S, x be set such that
A1: x in dom JumpPart I;
A2: JumpPart I in JumpParts InsCode I;
A3: dom product" JumpParts InsCode I = DOM JumpParts InsCode I
  by CARD_3:92
    .= dom JumpPart I by A2,CARD_3:def 12;
  (JumpPart I).x in pi(JumpParts InsCode I,x) by A2,CARD_3:def 6;
  hence thesis
  by A1,A3,CARD_3:93;
end;

theorem
  for I being Instruction of Trivial-COM N holds JumpPart I = 0 by Lm3;

theorem
  for T being InsType of Trivial-COM N holds JumpParts T = {0} by Lm4;

begin :: Addenda

:: from SCMRING4, 2008.03.13, A.T.

reserve i, j, k for natural number,
  n for Element of NAT,
  l for Element of NAT,
  f for FinPartState of S;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent  (IC-Ins-separated definite
   realistic
  (standard-ins non empty stored-program COM-Struct over N)),
  k be Element of NAT, p be FinPartState of S;
  func Relocated (p,k) -> FinPartState of S equals
   IncrIC(NPP p,k) +* Reloc(ProgramPart p,k);
  coherence;
end;

reserve S for regular homogeneous J/A-independent
(IC-Ins-separated
definite  realistic
  (standard-ins non empty stored-program COM-Struct over N)),
  g for FinPartState of S,
  s for State of S,
  il for Element of NAT;

theorem
 for k being Element of NAT holds DataPart Relocated(g,k) = DataPart g
proof
  let k be Element of NAT;
   dom Reloc(ProgramPart(g),k) c= NAT by RELAT_1:def 18;
   then dom Reloc(ProgramPart(g),k) misses Data-Locations S
        by Th51,XBOOLE_1:63;
  hence DataPart Relocated(g,k)
     = DataPart IncrIC(NPP g,k) by FUNCT_4:76
    .= DataPart NPP g by Th48
    .= DataPart g by Th73;
end;

theorem Th69:
  for k being Element of NAT holds
  ProgramPart(Relocated(g,k)) = Reloc(ProgramPart(g),k)
proof
  let k be Element of NAT;
  thus ProgramPart(Relocated(g,k)) =
     IncrIC(NPP g,k)|NAT +* Reloc(ProgramPart(g),k)|NAT by FUNCT_4:75
    .= {} +* Reloc(ProgramPart(g),k)|NAT by Def29
    .= Reloc(ProgramPart(g),k)|NAT by FUNCT_4:21
    .= Reloc(ProgramPart g,k) by RELAT_1:209;
end;

theorem Th70:
  for k being Element of NAT holds
  for p being finite NAT-defined (the Instructions of S)-valued Function
   holds dom Reloc(p,k) =
    { j+k where j is Element of NAT:j in dom p }
proof
  let k be Element of NAT;
  let p be finite NAT-defined (the Instructions of S)-valued Function;
  thus dom Reloc(p,k) = dom Shift(p,k) by Def15
    .= { j+k where j is Element of NAT:j in dom p } by VALUED_1:def 12;
end;

theorem
  for k being Element of NAT holds
  il in dom g iff il + k in dom Relocated(g,k)
proof
  let k be Element of NAT;
  consider m being natural number such that
A2: il = m;
  A4: dom ProgramPart(Relocated(g,k)) = dom Reloc(ProgramPart g,k) by Th69
   .= { j+k where j is Element of NAT:
  j in dom ProgramPart(g) } by Th70;
  ProgramPart(Relocated(g,k)) c= Relocated(g,k) by RELAT_1:88;
  then
A5: dom ProgramPart(Relocated(g,k)) c= dom Relocated(g,k) by GRFUNC_1:8;
  hereby
    assume il in dom g;
    then m in dom ProgramPart g by A2,Th16;
    then il + k in dom ProgramPart(Relocated(g,k)) by A2,A4;
    hence il + k in dom Relocated(g,k) by A5;
  end;
  assume il + k in dom Relocated(g,k);
  then il + k in dom ProgramPart(Relocated(g,k)) by Th16;
  then consider j being Element of NAT such that
A7: il + k = j+k and
A8: j in dom ProgramPart g by A4;
  ProgramPart g c= g by RELAT_1:88;
  then dom ProgramPart g c= dom g by GRFUNC_1:8;
  hence thesis by A8,A7;
end;

theorem Th119:
  for k being Element of NAT holds
  IC S in dom Relocated (g,k)
proof
  let k be Element of NAT;
  Relocated (g,k) = IncrIC(NPP g,k) +* Reloc(ProgramPart(g),k) &
  IC S in dom IncrIC(NPP g,k) by Th53;
  hence thesis by FUNCT_4:13;
end;

theorem Th73:
  for k being Element of NAT st IC S in dom g
   holds IC Relocated (g,k) = IC g + k
proof
  let k be Element of NAT such that
A3: IC S in dom g;
    ProgramPart(Relocated(g,k)) = Reloc(ProgramPart g,k) by Th69;
  then
A1: not IC S in dom Reloc(ProgramPart g,k) by Th12;
  thus IC Relocated (g,k) = Relocated (g,k).IC S
    .= IC IncrIC(NPP g,k) by A1,FUNCT_4:12
    .= (IC NPP g) +k by Th54
    .= (IC g) +k by A3,Th72;
end;

theorem Th75:
  for i,j being Element of NAT holds
  for p being NAT-defined (the Instructions of S)-valued FinPartState of S
  holds Shift(IncAddr(p,i),j) = IncAddr(Shift(p,j),i)
proof
  let i,j be Element of NAT;
  let p be NAT-defined (the Instructions of S)-valued FinPartState of S;
  set f = Shift(IncAddr(p,i),j);
  set g = IncAddr(Shift(p,j),i);
  dom(IncAddr(p,i)) = dom p by Def15;
  then dom(Shift(p,j)) = { m+j where m is Element of NAT:
  m in dom (IncAddr(p,i)) } by VALUED_1:def 12
    .= dom f by VALUED_1:def 12;
  then
A1: dom f = dom g by Def15;
  now
    let x be set;
A2: dom f c= NAT by RELAT_1:def 18;
    assume
A3: x in dom f;
    then reconsider x9=x as Element of NAT by A2;
    reconsider xx=x9 as Element of NAT;
    x in { m+j where m is Element of NAT:
    m in dom IncAddr(p,i) } by A3,VALUED_1:def 12;
    then consider m being Element of NAT such that
A4: x = m+j and
A5: m in dom IncAddr(p,i);
A7: m in dom p by A5,Def15;
    dom Shift(p,j) = { mm+j where mm is Element of NAT :
    mm in dom p} by VALUED_1:def 12;
    then
A8: x9 in dom Shift(p,j) by A4,A7;
    reconsider mm=m as Element of NAT;
A9: p/.mm = p.m by A7,PARTFUN1:def 8
      .= Shift(p,j).(m + j) by A7,VALUED_1:def 12
      .= Shift(p,j)/.xx by A4,A8,PARTFUN1:def 8;
    thus f.x = IncAddr(p,i).(m) by A5,A4,VALUED_1:def 12
      .= IncAddr(Shift(p,j)/.xx,i) by A7,A9,Def15
      .= g.x by A8,Def15;
  end;
  hence thesis by A1,FUNCT_1:9;
end;

theorem
  for k being Element of NAT holds
  for I being Instruction of S holds
  il in dom ProgramPart g & I = g.il implies
  IncAddr(I, k) = (Relocated (g, k)).(il + k)
proof
  let k be Element of NAT;
  let I be Instruction of S;
  assume that
A2: il in dom ProgramPart g and
A3: I = g.il;
A4: ProgramPart g c= g by RELAT_1:88;
  consider i being natural number such that
A5: il = i;
  reconsider ii = il as Element of NAT;
  i+k in { j+k where j is Element of NAT:
  j in dom ProgramPart(g) } by A2,A5;
  then il + k in dom Reloc(ProgramPart g,k) by A5,Th70;
  then
A6: il + k in dom ProgramPart(Relocated(g,k)) by Th69;
A7: il in dom IncAddr(ProgramPart(g),k) by A2,Def15;
A8: I = (ProgramPart g).il by A2,A3,A4,GRFUNC_1:8;
  ProgramPart (Relocated(g, k)) c= (Relocated(g, k)) by RELAT_1:88;
  hence (Relocated(g, k)).(il + k)
  = (ProgramPart(Relocated(g, k))).(il + k) by A6,GRFUNC_1:8
    .= (IncAddr(Shift(ProgramPart(g),k),k)).(il + k) by Th69
    .= (Shift(IncAddr(ProgramPart(g),k),k)).(il + k) by Th75
    .= (IncAddr(ProgramPart(g),k)).il by A7,VALUED_1:def 12
    .= IncAddr((ProgramPart g)/.ii,k) by A2,Def15
    .= IncAddr(I,k) by A2,A8,PARTFUN1:def 8;
end;

theorem
  for k being Element of NAT st IC S in dom g
  holds Start-At (IC g + k,S) c= Relocated (g,k)
proof
  let k be Element of NAT such that
Z: IC S in dom g;
A1: Start-At(IC g +k,S) = {[IC S,IC g + k]} by FUNCT_4:87;
A2: IC Relocated(g,k) = IC g + k by Z,Th73;
A3: IC S in dom (Relocated(g,k)) by Th119;
A4: [IC S,IC g + k] in Relocated(g,k) by A3,A2,FUNCT_1:def 4;
  thus Start-At(IC g +k,S) c= Relocated(g,k)
  proof
    let x be set;
    assume x in Start-At(IC g +k,S);
    hence thesis by A1,A4,TARSKI:def 1;
  end;
end;

theorem
  for k being Element of NAT holds
  for q being data-only FinPartState of S
   holds Relocated((g +* q), k) = Relocated (g,k) +* q
proof
  let k be Element of NAT,
      s be data-only FinPartState of S;
A: NAT misses Data-Locations S by Th51;
  dom s c= Data-Locations S by Th31;
  then
Y:  dom s misses NAT by A,XBOOLE_1:63;
XX: dom Reloc(ProgramPart g,k) c= NAT by RELAT_1:def 18;
  thus Relocated((g +* s), k)
     = IncrIC(NPP(g +* s),k) +* Reloc(ProgramPart(g +* s),k)
    .= IncrIC(NPP(g +* s),k) +* Reloc(ProgramPart g,k) by Th66
    .= IncrIC(NPP g +* s,k) +* Reloc(ProgramPart g,k) by Th67
    .= IncrIC(NPP g,k) +* s +* Reloc(ProgramPart g,k) by Th60
    .= IncrIC(NPP g,k) +* (s +* Reloc(ProgramPart g,k)) by FUNCT_4:15
    .= IncrIC(NPP g,k) +* (Reloc(ProgramPart g,k) +* s)
     by XX,Y,FUNCT_4:36,XBOOLE_1:63
    .= IncrIC(NPP g,k) +* Reloc(ProgramPart g,k) +* s by FUNCT_4:15
    .= Relocated (g,k) +* s;
end;

begin :: SCMPDS_4

reserve S for IC-Ins-separated definite realistic
  (non empty stored-program COM-Struct over N),
  s,s1,s2 for State of S;

reserve
  i,j,k for Instruction of S,
  I,J,K for Program of S,
  p,q,r for PartState of S;

definition
  let N be set;
  let S be definite (non empty stored-program COM-Struct over N);
  let i be Instruction of S;
  redefine func Load i -> preProgram of S;
  coherence;
end;

reserve k1,k2 for Integer;

theorem
  for s being State of S, I being Program of S holds
  Initialize s +* I = s +* Initialize I
proof
  set SA0=Start-At( 0,S);
  let s be State of S,I be Program of S;
A2: not IC S in dom I by Th3;
B1: dom Start-At( 0,S) = { IC S } by FUNCOP_1:19;
  thus Initialize s +* I = s +* (SA0 +* I) by FUNCT_4:15
    .= s +* Initialize I by B1,A2,FUNCT_4:36,ZFMISC_1:56;
end;

theorem
  I c= Initialize I
proof
A2: not IC S in dom I by Th3;
  dom Start-At( 0,S) = { IC S } by FUNCOP_1:19;
  then dom I misses dom (Start-At( 0,S)) by A2,ZFMISC_1:56;
  hence thesis by FUNCT_4:33;
end;

theorem
  for s1,s2 being State of S holds (for l being
  Element of NAT holds s1.l = s2.l) iff s1 | NAT = s2 | NAT
proof
  let s1,s2 be State of S;
A1: (for l being Element of NAT holds s1.l = s2.l) implies
  for l being set st l in NAT holds s1.l = s2.l;
  NAT c= dom s1 & NAT c= dom s2 by LmL;
  hence thesis by A1,FUNCT_1:165;
end;

theorem Th32:
  x in dom I implies I.x = (I +* Start-At(n,S)).x
proof
  assume
  x in dom I;
  then reconsider l=x as Element of NAT;
  dom Start-At(n,S) = {IC S} & l <> IC S
  by Th3,FUNCOP_1:19;
  then not x in dom Start-At(n,S) by TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem
  for I being Program of S, x being set st x in dom I holds I.x = (
  Initialize I).x by Th32;

theorem Th54:
 for I being NAT-defined Function holds dom I misses dom Start-At(n,S)
proof let I be NAT-defined Function;
A: dom Start-At(n,S) misses NAT by Th26;
  dom I c= NAT by RELAT_1:def 18;
 hence thesis by A,XBOOLE_1:63;
end;

theorem Th56:
  I +* Start-At(n,S) c= s implies I c= s
proof
  dom I misses dom Start-At(n,S) by Th54;
  then
A1: I +* Start-At(n,S) = I \/ Start-At(n,S) by FUNCT_4:32;
  assume
  I +* Start-At(n,S) c= s;
  hence thesis by A1,XBOOLE_1:11;
end;

theorem
  Initialize I c= s implies I c= s by Th56;

theorem
  (I +* Start-At(n,S))|NAT = I
proof
  NAT misses dom Start-At(n,S)
  proof
    assume
    not thesis;
    then consider x being set such that
A1: x in NAT and
A2: x in dom Start-At(n,S) by XBOOLE_0:3;
    dom Start-At(n,S) = {IC S} by FUNCOP_1:19;
    then x = IC S by A2,TARSKI:def 1;
    hence contradiction by A1,Th3;
  end;
  then dom I c= NAT & (I +* Start-At(n,S))|NAT = I | NAT by FUNCT_4:76;
  hence thesis by RELAT_1:97;
end;

reserve l,l1,loc for Element of NAT;

definition let N;
  let S be definite (non empty stored-program COM-Struct over N);
  let I be Program of S;
  func stop I -> Program of S equals
  I ^ Stop S;
  coherence;
end;

registration let N,S;
  let s be State of S;
  cluster Initialize s -> total;
  coherence;
end;

definition let N,S;
  let la,lb be Element of NAT;
  let a, b be Instruction of S;
  redefine func (la,lb) --> (a,b) -> FinPartState of S;
  coherence;
end;

reserve l1,l2 for Element of NAT,
  i1,i2 for Instruction of S;

theorem
  s +*((l1,l2) --> (i1, i2)) = s +* (l1,i1) +* (l2,i2)
proof
A1: l1 in dom s by Th23;
A2: l2 in dom (s +* (l1,i1)) by Th23;
  thus s +*((l1,l2) --> (i1, i2)) =s +* ((l1 .--> i1) +* (l2 .--> i2))
    .=s +* (l1 .--> i1) +* (l2 .--> i2) by FUNCT_4:15
    .=s +* (l1,i1) +* (l2 .--> i2) by A1,FUNCT_7:def 3
    .=s +* (l1,i1) +* (l2,i2) by A2,FUNCT_7:def 3;
end;

theorem
   0 in dom stop  I
proof
  card stop I = card I + card Stop S by AFINSQ_1:20
    .= card I + 1 by Th46;
  hence thesis by AFINSQ_1:70;
end;

begin :: SCMFSA6A

reserve
  i,j,k for Instruction of S,
  I,J,K for Program of S;

definition
  let N be non empty with_non-empty_elements set;
  let S be definite (non empty stored-program COM-Struct over N);
  let i be Instruction of S;
  func Macro i -> Program of S equals
  ( 0, 1) --> (i,halt S);
  coherence
  proof
    set I = ( 0, 1) --> (i,halt S);
A1: dom I = { 0, 1} by FUNCT_4:65;
A6: I is initial
    proof
      let m,n be Nat such that
A7:   n in dom I and
A8:   m < n;
       n = 0 or n =  1 by A1,A7,TARSKI:def 2;
      then n = (0 qua Nat)+1 by A8;
      then m <= 0 by A8,NAT_1:13;
      then m = 0;
      hence thesis by A1,TARSKI:def 2;
    end;
    thus thesis by A6;
  end;
  correctness;
end;

registration let N,S;
  let i;
  cluster Macro i -> non empty;
  coherence;
end;

theorem
  for s1,s2 being State of S holds (for l being
  Element of NAT holds s1.l = s2.l) iff s1 | NAT = s2 | NAT
proof
  let s1,s2 be State of S;
A1: (for l being Element of NAT holds s1.l = s2.l) implies
  for l being set st l in NAT holds s1.l = s2.l;
  NAT c= dom s1 & NAT c= dom s2 by LmL;
  hence thesis by A1,FUNCT_1:165;
end;

theorem Th137:
 dom DataPart p misses NAT
proof
  dom DataPart p misses {IC S} \/ NAT by Def50;
 hence thesis by XBOOLE_1:70;
end;

theorem
  for s1,s2 being State of S st s1,s2 equal_outside NAT holds
  DataPart s1 = DataPart s2
proof
  let s1,s2 be State of S;
  assume
Z1: s1,s2 equal_outside NAT;
A:  dom DataPart s1 = Data-Locations S by Th50
    .= dom DataPart s2 by Th50;
  for x st x in dom DataPart s1 holds
   (DataPart s1).x = (DataPart s2).x
  proof let x;
   assume
Z:  x in dom DataPart s1;
    dom DataPart s1 c= dom s1 by RELAT_1:89;
    then
C:   x in dom s1 by Z;
    dom DataPart s1 misses NAT by Th137;
    then not x in NAT by Z,XBOOLE_0:3;
    then
B1: x in dom s1 \ NAT by C,XBOOLE_0:def 5;
B2: dom s1 = the carrier of S by PARTFUN1:def 4
     .= dom s2 by PARTFUN1:def 4;
   thus (DataPart s1).x = s1.x by Z,FUNCT_1:70
    .= (s1|(dom s1 \ NAT)).x by B1,FUNCT_1:72
    .= (s2|(dom s2 \ NAT)).x by Z1,FUNCT_7:def 2
    .= s2.x by B1,B2,FUNCT_1:72
    .= (DataPart s2).x by Z,A,FUNCT_1:70;
  end;
 hence thesis by A,FUNCT_1:def 17;
   :: dlaczego nie dzizala rozwiniecie definicyjne?
end;

theorem Th47:
  for I being Program of S holds not IC S in dom I by Th3;

begin ::SF_MASTR

theorem Th64:
  dom I misses dom Start-At( n,S)
proof
A1: dom Start-At( n,S) = {IC S} by FUNCOP_1:19;
  assume dom I /\ dom (Start-At( n,S)) <> {};
  then consider x being set such that
A2: x in dom I /\ dom (Start-At( n,S)) by XBOOLE_0:def 1;
  x in dom I & x in dom (Start-At( n,S)) by A2,XBOOLE_0:def 4;
  then dom I c= NAT & IC S in dom I by A1,TARSKI:def 1;
  then reconsider l = IC S as Element of NAT;
  l = IC S;
  hence contradiction by Th3;
end;

theorem Th65:
  IC S in dom (p +* Start-At( n,S))
proof
  dom Start-At( n,S) = {IC S} by FUNCOP_1:19;
  then IC S in dom Start-At( n,S) by TARSKI:def 1;
  hence thesis by FUNCT_4:13;
end;

theorem Th66:
  IC(p +* Start-At( n,S)) =  n
proof
A1: IC S in dom Start-At( n,S) by Th52;
  (Start-At( n,S)).IC S =  n by FUNCOP_1:87;
  hence thesis by A1,FUNCT_4:14;
end;

theorem
  I +* Start-At( n,S) c= s implies IC s =  n
proof
  assume
A1: I +* Start-At( n,S) c= s;
  IC S in dom (I +* Start-At( n,S)) by Th65;
  hence IC s = IC(I +* Start-At( n,S)) by A1,GRFUNC_1:8
    .=  n by Th66;
end;

begin :: SCMFSA6B

theorem
  (I +* Start-At( n,S))|NAT = I
proof
Lm1: not IC S in NAT by Th3;
  NAT misses dom Start-At( n,S)
  proof
    assume not thesis;
    then
A1: ex x being set st x in NAT & x in dom Start-At( n,S)
 by XBOOLE_0:3;
    dom Start-At( n,S) = {IC S} by FUNCOP_1:19;
    hence contradiction by A1,Lm1,TARSKI:def 1;
  end;
  then dom I c= NAT & (I +* Start-At( n,S))|NAT = I | NAT
   by FUNCT_4:76;
  hence thesis by RELAT_1:97;
end;

theorem
  x in dom I implies I.x = (I +* Start-At( n,S)).x
proof
  assume x in dom I;
  then dom Start-At( n,S) = {IC S} & x <> IC S
   by Th47,FUNCOP_1:19;
  then not x in dom Start-At( n,S) by TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem
    0 in dom (I +* Start-At( 0,S))
proof
A2:  0 in dom I by AFINSQ_1:69;
  dom (I +* Start-At( 0,S)) =
   dom I \/ dom Start-At( 0,S) by FUNCT_4:def 1;
  hence thesis by A2,XBOOLE_0:def 3;
end;

theorem Th147:
  x in dom Macro i iff x =  0 or x =  1
proof
  dom Macro i = { 0,  1} by FUNCT_4:65;
  hence thesis by TARSKI:def 2;
end;

theorem
  (Macro i).( 0) = i & (Macro i).( 1) = halt S &
  ((Macro i) +* Start-At( 0,S)). 0 = i
proof
  thus
A1: (Macro i).( 0) = i by FUNCT_4:66;
  thus
 (Macro i).( 1) = halt S by FUNCT_4:66;
A4:  0 in dom Macro i by Th147;
  dom (Macro i) misses dom (Start-At( 0,S)) by Th64;
  then Macro i c= (Macro i) +* Start-At( 0,S) by FUNCT_4:33;
  hence thesis by A1,A4,GRFUNC_1:8;
end;

begin :: SCMFSA7B

reserve m for Element of NAT;

theorem
  for i being Instruction of S holds dom Macro i = {  0,  1 }
proof
  let i be Instruction of S;
  for x be set holds x in dom Macro i iff x =  0 or x =  1 by Th147;
  hence thesis by TARSKI:def 2;
end;

theorem
  for i being Instruction of S holds card Macro i = 2
proof
  let i be Instruction of S;
  thus card Macro i
    = len <% i,halt S %> by AFINSQ_1:80
    .= 2 by AFINSQ_1:42;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be definite (non empty stored-program COM-Struct over N);
  cluster Stop S -> non halt-free;
  coherence
   proof
     rng Stop S = {halt S} by AFINSQ_1:36;
    hence halt S in rng Stop S by TARSKI:def 1;
   end;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be definite (non empty stored-program COM-Struct over N);
  cluster non halt-free finite Program of S;
  existence
   proof
    take Stop S;
    thus thesis;
   end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be definite (non empty stored-program COM-Struct over N);
 cluster NAT-defined (the Instructions of S)-valued
     -> (the Object-Kind of S)-compatible Function;
 coherence;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be definite (non empty stored-program COM-Struct over N);
  let p be PartState of S,
      q be non halt-free
       (NAT-defined (the Instructions of S)-valued Function);
  cluster ProgramPart(p +* q) -> non halt-free;
  coherence
   proof
A:   halt S in rng q by Def7;
     ProgramPart(p +* q) =  ProgramPart p +* q|NAT by FUNCT_4:75
       .= ProgramPart p +* q by RELAT_1:209;
     then rng q c= rng ProgramPart(p +* q) by FUNCT_4:19;
    hence halt S in rng ProgramPart(p +* q) by A;
   end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be definite (non empty stored-program COM-Struct over N);
  let p be (NAT-defined (the Instructions of S)-valued Function),
      q be non halt-free
       (NAT-defined (the Instructions of S)-valued Function);
  cluster p +* q -> non halt-free;
  coherence
   proof
A:   halt S in rng q by Def7;
     rng q c= rng(p +* q) by FUNCT_4:19;

    hence halt S in rng(p +* q) by A;
   end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent proper-halt
    (IC-Ins-separated definite  realistic
    (standard-ins non empty stored-program COM-Struct over N));
  let p be finite non halt-free
    (NAT-defined (the Instructions of S)-valued Function),
     k be Element of NAT;
 cluster Reloc(p,k) -> non halt-free;
 coherence
  proof
F:  dom p c= NAT by RELAT_1:def 18;
    halt S in rng p by Def7;
    then consider x being set such that
W1:  x in dom p and
W2:  p.x = halt S by FUNCT_1:def 5;
F1:  x in dom IncAddr(p,k) by W1,Def15;
F2:  Shift(IncAddr(p,k),k) = IncAddr(Shift(p,k),k) by Th75;
F3:  dom IncAddr(p,k) c= NAT by RELAT_1:def 18;
     reconsider m =x as Element of NAT by F,W1;
    IncAddr(p,k).m = IncAddr(p/.m,k) by W1,Def15
       .= IncAddr(halt S,k) by W2,W1,PARTFUN1:def 8
       .= halt S by Th29;
    then halt S in rng IncAddr(p,k) by F1,FUNCT_1:12;
   hence halt S in rng Reloc(p,k) by F2,F3,VALUED_1:27;
  end;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be definite (non empty stored-program COM-Struct over N);
  cluster non halt-free Program of S;
  existence
   proof
    take Stop S;
    thus thesis;
   end;
end;

theorem
  for N be with_non-empty_elements non empty set
  for S be IC-Ins-separated (non empty COM-Struct over N), l be Nat
  for p be PartState of S
  holds p is l-started iff Start-At(l,S) c= p
proof
 let N be with_non-empty_elements non empty set;
 let S be IC-Ins-separated (non empty COM-Struct over N), l be Nat;
 let p be PartState of S;
B: dom Start-At(l,S) = {IC S} by FUNCOP_1:19;
 thus p is l-started implies Start-At(l,S) c= p
  proof assume
Z:  p is l-started;
    IC S in dom p by Z, Def41;
    then
A:  dom Start-At(l,S) c= dom p by B,ZFMISC_1:37;
    for x st x in dom Start-At(l,S) holds Start-At(l,S).x = p.x
     proof let x;
      assume x in dom Start-At(l,S);
       then
C:      x = IC S by B,TARSKI:def 1;
      hence Start-At(l,S).x = IC Start-At(l,S)
         .= l by FUNCOP_1:87
         .= IC p by Z,Def41
         .= p.x by C;
     end;
   hence Start-At(l,S) c= p by A,GRFUNC_1:8;
  end;
 assume
Z: Start-At(l,S) c= p;
  then
A:  dom Start-At(l,S) c= dom p by RELAT_1:25;
C: IC S in dom Start-At(l,S) by B,TARSKI:def 1;
 hence IC S in dom p by A;
 thus IC p = IC Start-At(l,S) by Z,C,GRFUNC_1:8
     .= l by FUNCOP_1:87;
end;

registration let N,S;
 cluster non program-free FinPartState of S;
 existence
  proof
   take Stop S;
    dom Stop S = {0} by FUNCOP_1:19;
    then dom Stop S c= NAT;
    then (Stop S)|NAT = Stop S by RELAT_1:97;
   hence (Stop S)|NAT <> {};
  end;
end;

registration let N,S;
 let p be non program-free PartState of S;
 let f be Function;
  cluster p +* f -> non program-free PartState of S;
  coherence
   proof let P be PartState of S;
    assume P = p +* f;
     then
A:   P|NAT = p|NAT +* f|NAT by FUNCT_4:75;
     p|NAT <> {} by Def29;
    hence P|NAT <> {} by A;
   end;
  cluster f +* p -> non program-free PartState of S;
  coherence
   proof let P be PartState of S;
    assume P = f +* p;
     then
A:   P|NAT = f|NAT +* p|NAT by FUNCT_4:75;
     p|NAT <> {} by Def29;
    hence P|NAT <> {} by A;
   end;
end;

theorem Th152:
  for p being program-free PartState of S, k being Element of NAT
  holds ProgramPart IncrIC(p,k) = {}
 proof let p be program-free PartState of S, k be Element of NAT;
  thus ProgramPart IncrIC(p,k)
     = ProgramPart p +* ProgramPart Start-At(IC p+k,S) by FUNCT_4:75
    .= ProgramPart p +* {} by Th135
    .= ProgramPart p by FUNCT_4:22
    .= {} by Def29;
 end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent  (IC-Ins-separated definite
   realistic
  (standard-ins non empty stored-program COM-Struct over N));
 let p be non program-free FinPartState of S, k be Element of NAT;
 cluster Relocated(p,k) -> non program-free;
 coherence
  proof
    ProgramPart p <> {} by Def29;
    then Reloc(ProgramPart p,k) <> {};
    then
A:  Reloc(ProgramPart p,k)|NAT <> {} by RELAT_1:209;
    Relocated(p,k)|NAT
     = ProgramPart IncrIC(NPP p,k) +* Reloc(ProgramPart p,k)|NAT by FUNCT_4:75
    .= {} +* Reloc(ProgramPart p,k)|NAT by Th152
    .= Reloc(ProgramPart p,k)|NAT by FUNCT_4:21;
   hence Relocated(p,k)|NAT <> {} by A;
  end;
end;

registration let N,S; let k be Element of NAT;
 let p be k-started PartState of S, d be data-only PartState of S;
 cluster p +* d -> k-started;
 coherence
  proof
A:    IC S in dom p by Def41;
    dom(p +* d) = dom p \/ dom d by FUNCT_4:def 1;
   hence IC S in dom(p +* d) by A,XBOOLE_0:def 3;
    not IC S in dom d by Th22;
   hence IC(p +* d) =IC p by FUNCT_4:12
     .= k by Def41;
  end;
end;
