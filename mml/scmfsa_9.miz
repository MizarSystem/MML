:: While Macro Instructions of SCM+FSA
::  by Jing-Chao Chen
::
:: Received December 10, 1997
:: Copyright (c) 1997 Association of Mizar Users

environ

 vocabularies NUMBERS, AMI_1, SCMFSA_2, CARD_1, SCMFSA8B, TURING_1, SCMFSA8A,
      AMISTD_2, ARYTM_3, SUBSET_1, FUNCT_4, FUNCOP_1, AMI_3, RELAT_1, TARSKI,
      XBOOLE_0, CAT_1, NAT_1, SCMFSA6A, FUNCT_1, XXREAL_0, VALUED_1, CARD_3,
      ARYTM_1, FSM_1, SF_MASTR, SCMFSA7B, UNIALG_2, CIRCUIT2, GRAPHSP,
      SCMFSA6B, SCMFSA_9, PBOOLE, ORDINAL1, PARTFUN1, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, RELAT_1,
      FUNCT_1, FUNCT_2, PARTFUN1,
      FUNCT_4, CARD_3, AMI_1, VALUED_1, NAT_1, PBOOLE,
      SCMNORM, SCMFSA_2, SCMFSA_4, SCMFSA_5, SCMFSA6A, SF_MASTR, SCMFSA6B,
      SCMFSA7B, SCMFSA8A, SCMFSA8B, XXREAL_0;
 constructors XXREAL_0, NAT_1, SEQ_1, SCMFSA_5, SCMFSA6A, SF_MASTR, SCMFSA6B,
      SCMFSA8A, SCMFSA8B, SCMNORM, SCMFSA_4, RELSET_1, PRE_POLY, SCMFSA_7,
      COMPLEX1, PBOOLE, AFINSQ_1;
 registrations SETFAM_1, FUNCT_1, RELSET_1, NUMBERS, XREAL_0, NAT_1, INT_1,
      CARD_3, SCMFSA_2, SF_MASTR, SCMFSA6B, SCMFSA7B, SCMFSA8A, ORDINAL1,
      XBOOLE_0, SCMNORM, FINSET_1, VALUED_1, AMI_1, FUNCT_4, RELAT_1, GRFUNC_1,
      PBOOLE, FRAENKEL, FUNCT_2, XXREAL_0, VALUED_0, AFINSQ_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions SCMFSA_2, SCMNORM, SCMFSA6A, FUNCOP_1, PBOOLE;
 theorems TARSKI, NAT_1, FUNCT_1, FUNCT_4, AMI_1, SCMFSA_2, SCMFSA_4, SCMFSA_5,
      SCMFSA6A, GRFUNC_1, SF_MASTR, SCMFSA6B, SCMFSA7B, SCMFSA8A, SCMFSA8B,
      ZFMISC_1, CARD_1, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0,
      VALUED_1, SCMNORM, FUNCOP_1, PBOOLE, AFINSQ_1;
 schemes NAT_1;

begin

LL: card Stop SCM+FSA = 1 by SCMNORM:3;
KK: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
JJ: 0 in dom Stop SCM+FSA by SCMNORM:2;

theorem Th1:
  for I being Program of SCM+FSA, a being Int-Location holds card
  if=0(a, I ';' Goto  0, Stop SCM+FSA) = card I + 6
proof
  let I be Program of SCM+FSA, a be Int-Location;
  thus card if=0(a, I ';' Goto  0, Stop SCM+FSA) = card (I ';' Goto
   0) + 1 +4 by SCMFSA8B:14,LL
    .= card I + card Goto  0 + 1+4 by SCMFSA6A:61
    .= card I + 1+1+4 by SCMFSA8A:29
    .= card I + 6;
end;

theorem Th2:
  for I being Program of SCM+FSA, a being Int-Location holds card
  if>0(a, I ';' Goto  0, Stop SCM+FSA) = card I + 6
proof
  let I be Program of SCM+FSA, a be Int-Location;
  thus card if>0(a, I ';' Goto  0, Stop SCM+FSA) = card (I ';' Goto
   0) + 1 +4 by SCMFSA8B:15,LL
    .= card I + card Goto  0 + 1+4 by SCMFSA6A:61
    .= card I + 1+1+4 by SCMFSA8A:29
    .= card I + 6;
end;

:: WHILE  Statement

reserve m, n for Element of NAT;

definition
  let a be Int-Location;
  let I be Program of SCM+FSA;
  func while=0(a,I) -> Program of SCM+FSA equals
  if=0(a, I ';' Goto  0,
  Stop SCM+FSA) +* (  (card I +4) .--> goto  0 );
  correctness
  proof
    set C = if=0(a, I ';' Goto  0, Stop SCM+FSA);
    set i =  (card I +4) .--> goto  0;
    set P = C +* i;
    card C = card I + 6 & card I + 4 < card I + 6 by Th1,XREAL_1:8;
    then  (card I + 4) in dom C by SCMFSA6A:15;
    then
A1: { (card I + 4)} c= dom C by ZFMISC_1:37;
A2: dom(P) = dom C \/ dom i by FUNCT_4:def 1
      .= dom C \/ { (card I + 4)} by FUNCOP_1:19
      .= dom C by A1,XBOOLE_1:12;
    P is initial
    proof
      let m,n be Nat;
      thus thesis by A2,SCMNORM:def 1;
    end;
    hence thesis;
  end;
  func while>0(a,I) -> Program of SCM+FSA equals
  if>0(a, I ';' Goto  0,
  Stop SCM+FSA) +* (  (card I +4) .--> goto  0 );
  correctness
  proof
    set C = if>0(a, I ';' Goto  0, Stop SCM+FSA);
    set i =  (card I +4) .--> goto  0;
    set P = C +* i;
    card C = card I + 6 & card I + 4 < card I + 6 by Th2,XREAL_1:8;
    then  (card I + 4) in dom C by SCMFSA6A:15;
    then
A3: { (card I + 4)} c= dom C by ZFMISC_1:37;
A4: dom(P) = dom C \/ dom i by FUNCT_4:def 1
      .= dom C \/ { (card I + 4)} by FUNCOP_1:19
      .= dom C by A3,XBOOLE_1:12;
    P is initial
    proof
      let m,n be Nat;
      thus thesis by A4,SCMNORM:def 1;
    end;
    hence thesis;
  end;
end;

theorem Th3:
  for I being Program of SCM+FSA, a being Int-Location holds card
  if=0(a,Stop SCM+FSA,if>0(a,Stop SCM+FSA,I ';' Goto  0)) = card I + 11
proof
  let I be Program of SCM+FSA, a be Int-Location;
  thus card if=0(a,Stop SCM+FSA,if>0(a,Stop SCM+FSA,I ';' Goto  0)) = 1
+ card if>0(a,Stop SCM+FSA,I ';' Goto  0) +4 by SCMFSA8B:14,LL
    .= card (I ';' Goto  0) + 1+ 4 + 1+4 by SCMFSA8B:15,LL
    .= card I + card Goto  0 +1+ 4 + 1+4 by SCMFSA6A:61
    .= card I + 1 + 1 +4 + 1 + 4 by SCMFSA8A:29
    .= card I + 11;
end;

definition
  let a be Int-Location;
  let I be Program of SCM+FSA;
  func while<0(a,I) -> Program of SCM+FSA equals
  if=0(a,Stop SCM+FSA,if>0(a,
Stop SCM+FSA,I ';' Goto  0)) +* (  (card I +4) .--> goto  0 )
  ;
  correctness
  proof
    set C = if=0(a,Stop SCM+FSA,if>0(a,Stop SCM+FSA,I ';' Goto  0));
    set i =  (card I +4) .--> goto  0;
    set P = C +* i;
    card C = card I + 11 & card I + 4 < card I + 11 by Th3,XREAL_1:8;
    then  (card I + 4) in dom C by SCMFSA6A:15;
    then
A1: { (card I + 4)} c= dom C by ZFMISC_1:37;
A2: dom(P) = dom C \/ dom i by FUNCT_4:def 1
      .= dom C \/ { (card I + 4)} by FUNCOP_1:19
      .= dom C by A1,XBOOLE_1:12;
    P is initial
    proof
      let m,n be Nat;
      thus thesis by A2,SCMNORM:def 1;
    end;
    hence thesis;
  end;
end;

theorem Th4:
  for I being Program of SCM+FSA, a being Int-Location holds card
  while=0(a,I) = card I + 6
proof
  let I be Program of SCM+FSA, a be Int-Location;
  set i =  (card I +4) .--> goto  0;
  set C = if=0(a, I ';' Goto  0, Stop SCM+FSA);
  set P = C +* i;
A1: card C = card I + 6 by Th1;
  card I + 4 < card I + 6 by XREAL_1:8;
  then  (card I + 4) in dom C by A1,SCMFSA6A:15;
  then
A2: { (card I + 4)} c= dom C by ZFMISC_1:37;
  dom(P) = dom C \/ dom i by FUNCT_4:def 1
    .= dom C \/ { (card I + 4)} by FUNCOP_1:19
    .= dom C by A2,XBOOLE_1:12;
  hence card while=0(a,I) = card dom C by CARD_1:104
    .= card I + 6 by A1,CARD_1:104;
end;

theorem Th5:
  for I being Program of SCM+FSA, a being Int-Location holds card
  while>0(a,I) = card I + 6
proof
  let I be Program of SCM+FSA, a be Int-Location;
  set i =  (card I +4) .--> goto  0;
  set C = if>0(a, I ';' Goto  0, Stop SCM+FSA);
  set P = C +* i;
A1: card C = card I + 6 by Th2;
  card I + 4 < card I + 6 by XREAL_1:8;
  then  (card I + 4) in dom C by A1,SCMFSA6A:15;
  then
A2: { (card I + 4)} c= dom C by ZFMISC_1:37;
  dom(P) = dom C \/ dom i by FUNCT_4:def 1
    .= dom C \/ { (card I + 4)} by FUNCOP_1:19
    .= dom C by A2,XBOOLE_1:12;
  hence card while>0(a,I) = card dom C by CARD_1:104
    .= card I + 6 by A1,CARD_1:104;
end;

theorem
  for I being Program of SCM+FSA, a being Int-Location holds card
  while<0(a,I) = card I + 11
proof
  let I be Program of SCM+FSA, a be Int-Location;
  set i =  (card I +4) .--> goto  0;
  set C = if=0(a,Stop SCM+FSA,if>0(a,Stop SCM+FSA,I ';' Goto  0));
  set P = C +* i;
A1: card C = card I + 11 by Th3;
  card I + 4 < card I + 11 by XREAL_1:8;
  then  (card I + 4) in dom C by A1,SCMFSA6A:15;
  then
A2: { (card I + 4)} c= dom C by ZFMISC_1:37;
  dom(P) = dom C \/ dom i by FUNCT_4:def 1
    .= dom C \/ { (card I + 4)} by FUNCOP_1:19
    .= dom C by A2,XBOOLE_1:12;
  hence card while<0(a,I) = card dom C by CARD_1:104
    .= card I + 11 by A1,CARD_1:104;
end;

theorem
  for a being Int-Location, l being Element of NAT
  holds a =0_goto l <> halt SCM+FSA by SCMFSA_2:48,124;

theorem
  for a being Int-Location, l being Element of NAT
  holds a >0_goto l <> halt SCM+FSA by SCMFSA_2:49,124;

theorem
  for l being Element of NAT holds goto l <> halt
  SCM+FSA by SCMFSA_2:47,124;

theorem Th10:
  for a being Int-Location, I being Program of SCM+FSA holds
   0 in dom while=0(a,I) &  1 in dom while=0(a,I) &  0 in dom
  while>0(a,I) &  1 in dom while>0(a,I)
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
  if=0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)) by
SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop
  SCM+FSA)));
  then
A1: dom Macro i c= dom if=0(a,I1,J) by SCMFSA6A:56;
  dom Macro i = { 0,  1} by SCMFSA7B:4;
  then
A2:  0 in dom Macro i &  1 in dom Macro i by TARSKI:def 2;
  dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then dom if=0(a,I1,J) c= dom while=0(a,I) by XBOOLE_1:7;
  then dom Macro i c= dom while=0(a,I) by A1,XBOOLE_1:1;
  hence  0 in dom while=0(a,I) &  1 in dom while=0(a,I) by A2;
  set i = a >0_goto  (card J + 3);
  if>0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)) by
SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop
  SCM+FSA)));
  then
A3: dom Macro i c= dom if>0(a,I1,J) by SCMFSA6A:56;
  dom Macro i = { 0,  1} by SCMFSA7B:4;
  then
A4:  0 in dom Macro i &  1 in dom Macro i by TARSKI:def 2;
  dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then dom if>0(a,I1,J) c= dom while>0(a,I) by XBOOLE_1:7;
  then dom Macro i c= dom while>0(a,I) by A3,XBOOLE_1:1;
  hence thesis by A4;
end;

theorem Th11:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I). 0 = a =0_goto  4 & while=0(a,I). 1 = goto
 2 & while>0(a,I). 0 = a >0_goto  4 & while>0(a,I). 1 =
  goto  2
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
A1: i <> halt SCM+FSA by SCMFSA_2:48,124;
A2: dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f by FUNCT_4:def 1;
A3: dom f = { (card I + 4)} by FUNCOP_1:19;
  then
A4: not  0 in dom f;
A5: dom Macro i = { 0,  1} by SCMFSA7B:4;
  then
A6:  0 in dom Macro i by TARSKI:def 2;
A7:  1 in dom Macro i by A5,TARSKI:def 2;
A8: if=0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)) by
SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop
  SCM+FSA)));
  1 <> card I + 4 by NAT_1:11;
  then
A9: not  1 in dom f by A3,TARSKI:def 1;
   0 in dom while=0(a,I) by Th10;
  hence while=0(a,I). 0 =if=0(a,I1,J). 0 by A4,A2,FUNCT_4:def 1
    .= (Directed Macro i). 0 by A8,A6,SCMFSA8A:28
    .= a =0_goto  4 by A1,SCMFSA7B:7,LL;
A10: dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f by FUNCT_4:def 1;
   1 in dom while=0(a,I) by Th10;
  hence while=0(a,I). 1 =if=0(a,I1,J). 1 by A2,A9,FUNCT_4:def 1
    .= (Directed Macro i). 1 by A8,A7,SCMFSA8A:28
    .= goto  2 by SCMFSA7B:8;
  set i = a >0_goto  (card J + 3);
A11: i <> halt SCM+FSA by SCMFSA_2:49,124;
A12: if>0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)) by
SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop
  SCM+FSA)));
A13: dom Macro i = { 0,  1} by SCMFSA7B:4;
  then
A14:  0 in dom Macro i by TARSKI:def 2;
A15:  1 in dom Macro i by A13,TARSKI:def 2;
   0 in dom while>0(a,I) by Th10;
  hence while>0(a,I). 0 = if>0(a,I1,J). 0 by A4,A10,FUNCT_4:def 1
    .= (Directed Macro i). 0 by A12,A14,SCMFSA8A:28
    .= a >0_goto  4 by A11,SCMFSA7B:7,LL;
   1 in dom while>0(a,I) by Th10;
  hence while>0(a,I). 1 = if>0(a,I1,J). 1 by A9,A10,FUNCT_4:def 1
    .= (Directed Macro i). 1 by A12,A15,SCMFSA8A:28
    .= goto  2 by SCMFSA7B:8;
end;

theorem Th12:
  for a being Int-Location, I being Program of SCM+FSA, k being
  Element of NAT st k < 6 holds  k in dom while=0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
A1: 6 <= card I + 6 by NAT_1:11;
A2: card while=0(a,I) = card I + 6 by Th4;
  assume
  k < 6;
  then k < card I + 6 by A1,XXREAL_0:2;
  hence thesis by A2,SCMFSA6A:15;
end;

theorem Th13:
  for a being Int-Location, I being Program of SCM+FSA, k being
  Element of NAT st k < 6 holds card I +k in dom while=0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
  assume
  k < 6;
  then
A1: card I + k < card I + 6 by XREAL_1:8;
  card while=0(a,I) = card I + 6 by Th4;
  hence thesis by A1,SCMFSA6A:15;
end;

theorem Th14:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I).(card I +5) = halt SCM+FSA
proof
  set J1= Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
  set c5 = card I + 5;
  set Lc5=c5;
  set Mi= Macro i ';' J ';' Goto  (card I1 + 1) ';' I1;
  dom f = { (card I + 4)} & Lc5 <>  (card I + 4) by FUNCOP_1:19;
  then
A1: not Lc5 in dom f by TARSKI:def 1;
   0 + c5 in { il+c5 where il is Element of NAT: il in dom J1} by JJ;
  then
A2:  c5 in dom Shift(J1,c5) by VALUED_1:def 12;
  then
A3: pi(Shift(J1,c5),Lc5) = Shift(J1,c5).(0 +c5) by AMI_1:def 47
    .= halt SCM+FSA by KK,JJ,VALUED_1:def 12;
A4: Lc5 in dom while=0(a,I) & dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f
  by Th13,FUNCT_4:def 1;
  then
A5: Lc5 in dom if=0(a,I1,J) by A1,XBOOLE_0:def 3;
A6: if=0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 1
    .= Mi ';' J1;
  then card if=0(a, I1,J) = card Mi + card J1 by SCMFSA6A:61;
  then
A7: card Mi = card if=0(a,I1,J)-card J1
    .= card I + 6 - 1 by Th1,LL
    .= c5;
  then
A8: not Lc5 in dom Mi by SCMFSA6A:15;
A9: dom if=0(a,I1,J) = dom Directed Mi \/ dom ProgramPart Relocated(J1, c5)
  by A6,A7,FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom ProgramPart Relocated(J1, c5) by
FUNCT_4:105;
  then
A10: Lc5 in dom ProgramPart Relocated(J1, c5) by A5,A8,XBOOLE_0:def 3;
  thus while=0(a,I).Lc5 = (Directed Mi +* ProgramPart Relocated(J1, c5)).Lc5
  by A1,A4,A6,A7,FUNCT_4:def 1
    .= (ProgramPart Relocated(J1,c5)).Lc5 by A5,A9,A10,FUNCT_4:def 1
    .= IncAddr(Shift(ProgramPart(J1),c5),c5).Lc5 by SCMFSA_5:2
    .= IncAddr(Shift(J1,c5),c5).Lc5 by AMI_1:105
    .= IncAddr( halt SCM+FSA, c5 ) by A2,A3,SCMFSA_4:24
    .= halt SCM+FSA by SCMFSA_4:8;
end;

theorem Th15:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I). 3 = goto  (card I +5)
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
  set Mi=Macro i ';' J;
  set G=Goto  (card I1 + 1);
  set J2= (I1 ';' Stop SCM+FSA);
  set J1=G ';' J2;
A1:  0 in dom G by SCMFSA8A:47;
A2: G. 0 = goto  (card I1 + 1) by SCMFSA8A:47
    .= goto  (card I + card Goto  0 + 1) by SCMFSA6A:61
    .= goto  (card I + 1 + 1) by SCMFSA8A:29
    .= goto  (card I +(1+1));
  then
A3: G. 0 <> halt SCM+FSA by SCMFSA_2:47,124;
  dom J1 = dom Directed G \/ dom ProgramPart Relocated(J2, card G) by
FUNCT_4:def 1
    .= dom G \/ dom ProgramPart Relocated(J2, card G) by FUNCT_4:105;
  then
A4:  0 in dom J1 by A1,XBOOLE_0:def 3;
  then  0 + 3 in { il+3 where il is Element of NAT: il in dom J1};
  then
A5:  3 in dom Shift(J1,3) by VALUED_1:def 12;
  then
A6: pi(Shift(J1,3),3) =Shift(J1,3).( 0 +3) by AMI_1:def 47
    .=J1. 0 by A4,VALUED_1:def 12
    .=(Directed G). 0 by A1,SCMFSA8A:28
    .=goto  (card I + 2) by A1,A2,A3,SCMFSA8A:30;
  dom f = { (card I + 4)} & 3 <> card I + 4 by FUNCOP_1:19,NAT_1:11;
  then
A7: not  3 in dom f by TARSKI:def 1;
A8: card Mi = card Macro i + card J by SCMFSA6A:61
    .= 2 + 1 by SCMFSA7B:6,LL;
  then
A9: not  3 in dom Mi by SCMFSA6A:15;
A10:  3 in dom while=0(a,I) & dom while=0(a,I) = dom if=0(a,I1,J) \/
  dom f by Th12,FUNCT_4:def 1;
  then
A11:  3 in dom if=0(a,I1,J) by A7,XBOOLE_0:def 3;
A12: if=0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= Mi ';' J1 by SCMFSA6A:67
    .= Directed Mi +* ProgramPart Relocated(J1, 3) by A8;
  then
A13: dom if=0(a,I1,J) = dom Directed Mi \/ dom ProgramPart Relocated(J1, 3)
  by FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom ProgramPart Relocated(J1, 3) by
FUNCT_4:105;
  then
A14:  3 in dom ProgramPart Relocated(J1, 3) by A11,A9,XBOOLE_0:def 3;
  thus while=0(a,I). 3 = (Directed Mi +* ProgramPart Relocated(J1, 3)).
   3 by A7,A10,A12,FUNCT_4:def 1
    .= (ProgramPart Relocated(J1,3)). 3 by A11,A13,A14,FUNCT_4:def 1
    .= IncAddr(Shift(ProgramPart(J1),3),3). 3 by SCMFSA_5:2
    .= IncAddr(Shift(J1,3),3). 3 by AMI_1:105
    .= IncAddr(goto  (card I +2),3) by A5,A6,SCMFSA_4:24
    .= goto ( (card I +2) + 3) by SCMFSA_4:14
    .= goto  (card I+ 5);
end;

theorem Th16:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I). 2 = goto  3
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
  set Mi=Macro i;
  set J2=Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA);
  set J1=J ';' J2;
  dom f = { (card I + 4)} & 2 <> card I + 4 by FUNCOP_1:19,NAT_1:11;
  then
A1: not  2 in dom f by TARSKI:def 1;
  dom J1 = dom Directed J \/ dom ProgramPart Relocated(J2, card J) by
FUNCT_4:def 1
    .= dom J \/ dom ProgramPart Relocated(J2, card J) by FUNCT_4:105;
  then
A2:  0 in dom J1 by JJ,XBOOLE_0:def 3;
  then  0 + 2 in { il+2 where il is Element of NAT: il in dom J1};
  then
A3:  2 in dom Shift(J1,2) by VALUED_1:def 12;
  then
A4: pi(Shift(J1,2),2) =Shift(J1,2).( 0 +2) by AMI_1:def 47
    .=J1. 0 by A2,VALUED_1:def 12
    .=(Directed J). 0 by SCMFSA8A:28,JJ
    .=goto  card J by KK,SCMFSA8A:30,JJ;
  card Mi = 2 by SCMFSA7B:6;
  then
A5: not  2 in dom Mi by SCMFSA6A:15;
A6:  2 in dom while=0(a,I) & dom while=0(a,I) = dom if=0(a,I1,J) \/
  dom f by Th12,FUNCT_4:def 1;
  then
A7:  2 in dom if=0(a,I1,J) by A1,XBOOLE_0:def 3;
A8: if=0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)) by
SCMFSA6A:67
    .= i ';' J1 by SCMFSA6A:71
    .= Directed Mi +* ProgramPart Relocated(J1, 2) by SCMFSA7B:6;
  then
A9: dom if=0(a,I1,J) = dom Directed Mi \/ dom ProgramPart Relocated(J1, 2)
  by FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom ProgramPart Relocated(J1, 2) by
FUNCT_4:105;
  then
A10:  2 in dom ProgramPart Relocated(J1, 2) by A7,A5,XBOOLE_0:def 3;
  thus while=0(a,I). 2 = (Directed Mi +* ProgramPart Relocated(J1, 2)).
   2 by A1,A6,A8,FUNCT_4:def 1
    .= (ProgramPart Relocated(J1,2)). 2 by A7,A9,A10,FUNCT_4:def 1
    .= IncAddr(Shift(ProgramPart(J1),2),2). 2 by SCMFSA_5:2
    .= IncAddr(Shift(J1,2),2). 2 by AMI_1:105
    .= IncAddr(goto  card J,2) by A3,A4,SCMFSA_4:24
    .= goto ( 1 + 2) by SCMFSA_4:14,LL
    .= goto  3;
end;

theorem
  for a being Int-Location, I being Program of SCM+FSA,k being Element
  of NAT st k < card I +6 holds  k in dom while=0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
  assume
A1: k < card I +6;
  card while=0(a,I) = card I + 6 by Th4;
  hence thesis by A1,SCMFSA6A:15;
end;

theorem Th18:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location st s.a <> 0 holds while=0(a,I) is_halting_on s &
  while=0(a,I) is_closed_on s
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a <> 0;
  set i = a =0_goto  4;
  set s1 = s +* (while=0(a,I) +* Start-At( 0,SCM+FSA));
A2: IC SCM+FSA in dom (while=0(a,I) +* Start-At( 0,SCM+FSA))
by SF_MASTR:65;
A3: IC s1 = s1.IC SCM+FSA by AMI_1:def 15
    .= (while=0(a,I) +* Start-At( 0,SCM+FSA)).IC SCM+FSA by A2,FUNCT_4:14
    .=  0 by SF_MASTR:66;
  set loc5=  (card I +5);
  set s5 = Comput(ProgramPart(s1),s1,4);
  set s4 = Comput(ProgramPart(s1),s1,3);
  set s3 = Comput(ProgramPart(s1),s1,2);
  set s2 = Comput(ProgramPart(s1),s1,1);
A4:  1 in dom while=0(a,I) by Th10;
A5:  2 in dom while=0(a,I) by Th12;
  not a in dom (while=0(a,I) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  then
A6: s1.a = s.a by FUNCT_4:12;
  while=0(a,I) c= while=0(a,I) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A7: dom while=0(a,I) c= dom (while=0(a,I) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by AMI_1:150;
A8:  0 in dom while=0(a,I) by Th10;
  then s1. 0 = (while=0(a,I) +* Start-At( 0,SCM+FSA)). 0
  by A7,FUNCT_4:14
    .= while=0(a,I). 0 by A8,SCMFSA6B:7
    .= i by Th11;
  then
A9: CurInstr(ProgramPart s1,s1) = i by A3,Y,AMI_1:def 16;
A10: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by AMI_1:14
    .= Following(ProgramPart s1,s1) by AMI_1:13
    .= Exec(i,s1) by A9,AMI_1:def 18;
A11: IC Comput(ProgramPart(s1),s1,1) = Comput(ProgramPart(s1),s1,1).IC SCM+FSA
by AMI_1:def 15
    .= succ  0 by A1,A3,A10,A6,SCMFSA_2:96
    .=  (0 + 1);
Y:  (ProgramPart Comput(ProgramPart(s1),s1,1))/.IC Comput(ProgramPart(s1),s1,1)
 = Comput(ProgramPart(s1),s1,1).IC Comput(ProgramPart(s1),s1,1) by AMI_1:150;
  Comput(ProgramPart(s1),s1,1). 1 = s1. 1 by AMI_1:54
    .= (while=0(a,I) +* Start-At( 0,SCM+FSA)). 1
    by A7,A4,FUNCT_4:14
    .= while=0(a,I). 1 by A4,SCMFSA6B:7
    .= goto  2 by Th11;
  then
A12: CurInstr(ProgramPart Comput(ProgramPart(s1),s1,1),Comput(ProgramPart(s1),
s1,1))
 = goto  2 by A11,Y,AMI_1:def 16;
T: ProgramPart s1 = ProgramPart s2
by AMI_1:144;
A13: Comput(ProgramPart(s1),s1,1+1) = Following(ProgramPart s1,s2) by AMI_1:14
    .= Exec(goto  2,s2) by A12,T,AMI_1:def 18;
A14: IC s3 = s3.IC SCM+FSA by AMI_1:def 15
    .=  2 by A13,SCMFSA_2:95;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
  s3. 2 = s1. 2 by AMI_1:54
    .= (while=0(a,I) +* Start-At( 0,SCM+FSA)). 2
    by A7,A5,FUNCT_4:14
    .= while=0(a,I). 2 by A5,SCMFSA6B:7
    .= goto  3 by Th16;
  then
A15: CurInstr(ProgramPart s3,s3) = goto  3 by A14,Y,AMI_1:def 16;
T: ProgramPart s1 = ProgramPart s3
by AMI_1:144;
A16: Comput(ProgramPart(s1),s1,2+1) = Following(ProgramPart s1,s3) by AMI_1:14
    .= Exec(goto  3,s3) by A15,T,AMI_1:def 18;
A17: IC s4 = s4.IC SCM+FSA by AMI_1:def 15
    .=  3 by A16,SCMFSA_2:95;
A18:  3 in dom while=0(a,I) by Th12;
A19: loc5 in dom while=0(a,I) by Th13;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
  s4. 3 = s1. 3 by AMI_1:54
    .= (while=0(a,I) +* Start-At( 0,SCM+FSA)). 3
    by A7,A18,FUNCT_4:14
    .= while=0(a,I). 3 by A18,SCMFSA6B:7
    .= goto loc5 by Th15;
  then
A20: CurInstr(ProgramPart s4,s4) = goto loc5 by A17,Y,AMI_1:def 16;
T: ProgramPart s1 = ProgramPart s4
by AMI_1:144;
A21: Comput(ProgramPart(s1),s1,3+1) = Following(ProgramPart s1,s4) by AMI_1:14
    .= Exec(goto loc5,s4) by A20,T,AMI_1:def 18;
A22: IC s5 = s5.IC SCM+FSA by AMI_1:def 15
    .= loc5 by A21,SCMFSA_2:95;
Y:  (ProgramPart s5)/.IC s5
 = s5.IC s5 by AMI_1:150;
  s5.loc5 = s1.loc5 by AMI_1:54
    .= (while=0(a,I) +* Start-At( 0,SCM+FSA)).loc5 by A7,A19,FUNCT_4:14
    .= while=0(a,I).loc5 by A19,SCMFSA6B:7
    .= halt SCM+FSA by Th14;
  then
A23: CurInstr(ProgramPart s5,s5) = halt SCM+FSA by A22,Y,AMI_1:def 16;
  then ProgramPart s1 halts_on s1 by AMI_1:146;
  hence while=0(a,I) is_halting_on s by SCMFSA7B:def 8;
TX: ProgramPart s1 = ProgramPart s5
by AMI_1:144;
  now
    let k be Element of NAT;
A24: k<=3 or k >= 3+1 by NAT_1:13;
    per cases by A24,NAT_1:28;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while=0(a,I) by A8,A3,
AMI_1:13;
    end;
    suppose
      k = 1;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while=0(a,I) by A11,Th10;
    end;
    suppose
      k = 2;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while=0(a,I) by A14,Th12;
    end;
    suppose
      k = 3;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while=0(a,I) by A17,Th12;
    end;
    suppose
      k >= 4;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while=0(a,I) by A19,A22,A23
,TX,AMI_1:52;
    end;
  end;
  hence thesis by SCMFSA7B:def 7;
end;

theorem Th19:
  for a being Int-Location, I being Program of SCM+FSA, s being
State of SCM+FSA,k being Element of NAT st I is_closed_on s & I is_halting_on s
& k < LifeSpan (s +* (I +* Start-At( 0,SCM+FSA))) &
IC Comput(ProgramPart( (s +* (while=0
  (a,I) +* Start-At( 0,SCM+FSA)))), (s +* (while=0
  (a,I) +* Start-At( 0,SCM+FSA))),1+k) = IC Comput(ProgramPart( (s +* (
  I +* Start-At(
   0,SCM+FSA)))), (s +* (
  I +* Start-At(
   0,SCM+FSA))),k) + 4 & DataPart Comput(ProgramPart( (s +* (while=0(a,I) +*
  Start-At(
   0,SCM+FSA)))), (s +* (while=0(a,I) +*
  Start-At(
   0,SCM+FSA))),1+k) = DataPart Comput(ProgramPart( (s +* ( I +*
  Start-At( 0,SCM+FSA)))), (s +* ( I +*
  Start-At( 0,SCM+FSA))),k)
  holds IC Comput(ProgramPart( (s +* (while=0(a,I) +*
  Start-At( 0,SCM+FSA)))), (s +* (while=0(a,I) +*
  Start-At( 0,SCM+FSA))),1+k+1) = IC
Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s +* (I +* Start-At(
0,SCM+FSA))),k+1) + 4 &
DataPart Comput(ProgramPart( (
s +* (while=0(a,I) +* Start-At( 0,SCM+FSA)))), (
s +* (while=0(a,I) +* Start-At( 0,SCM+FSA))),1+k+1) =
DataPart Comput(ProgramPart( (s +*
  (I +* Start-At( 0,SCM+FSA)))), (s +*
  (I +* Start-At( 0,SCM+FSA))),k+1)
proof
  set J3= Goto  0 ';' Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  let k be Element of NAT;
  set s1 = s +* (while=0(a,I) +* Start-At( 0,SCM+FSA));
  set sI = s +* ( I +* Start-At( 0,SCM+FSA));
  set sK1= Comput(ProgramPart( s1), s1,1+k);
  set sK2= Comput(ProgramPart( sI), sI,k);
  set l3=IC Comput(ProgramPart( sI), sI,k);
  set I1= I ';' Goto  0;
  set i = a =0_goto  (card J + 3);
  reconsider n = l3 as Element of NAT;
  set Mi= i ';' J ';' Goto  (card I1 + 1);
  set J2= I1 ';' Stop SCM+FSA;
A1: rng I c= the Instructions of SCM+FSA by AMI_1:118;
  assume
  I is_closed_on s;
  then
A2:  n in dom I by SCMFSA7B:def 7;
  then n < card I by SCMFSA6A:15;
  then
A3: n+4 < card I+ 6 by XREAL_1:10;
Y:  (ProgramPart sK2)/.IC sK2
 = sK2.IC sK2 by AMI_1:150;
  I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A4: dom I c= dom (I +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
A5: CurInstr(ProgramPart sK2,sK2) =sK2. n by Y,AMI_1:def 16
    .=sI. n by AMI_1:54
    .=(I +* Start-At( 0,SCM+FSA)). n by A2,A4,FUNCT_4:14
    .= I. n by A2,SCMFSA6B:7;
  assume
  I is_halting_on s;
  then
A6: ProgramPart sI halts_on sI by SCMFSA7B:def 8;
  assume
  k < LifeSpan sI;
  then
A7: I. n <> halt SCM+FSA by A5,A6,AMI_1:def 46;
A8: J2= I ';' J3 by SCMFSA6A:67;
  then dom J2 = dom Directed I \/ dom ProgramPart Relocated(J3, card I) by
FUNCT_4:def 1
    .= dom I \/ dom ProgramPart Relocated(J3, card I) by FUNCT_4:105;
  then
A9:  n in dom J2 by A2,XBOOLE_0:def 3;
  then  n + 4 in { il+4 where il is Element of NAT: il in dom J2};
  then
A10:  (n+4) in dom Shift(J2,4) by VALUED_1:def 12;
  then
A11: pi(Shift(J2,4),n+4) =Shift(J2,4).( n +4) by AMI_1:def 47
    .=J2. n by A9,VALUED_1:def 12
    .=(Directed I). n by A2,A8,SCMFSA8A:28
    .=I. n by A2,A7,SCMFSA8A:30;
  card while=0(a,I) = card I + 6 by Th4;
  then
A12:  (n+4) in dom while=0(a,I) by A3,SCMFSA6A:15;
  I. n in rng I by A2,FUNCT_1:def 5;
  then reconsider j = I. n as Instruction of SCM+FSA by A1;
  while=0(a,I) c= while=0(a,I) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A13: dom while=0(a,I) c= dom (while=0(a,I) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
A14: card Mi = card (i ';' J )+ card Goto  (card I1 + 1) by SCMFSA6A:61
    .= card (i ';' J ) + 1 by SCMFSA8A:29
    .= card (Macro i) + card J + 1 by SCMFSA6A:61
    .= 2 + 1 +1 by SCMFSA7B:6,LL
    .= 3+ 1;
  then n+4 >= card Mi by NAT_1:11;
  then
A15: not  (n+4) in dom Mi by SCMFSA6A:15;
T: ProgramPart sI = ProgramPart sK2
by AMI_1:144;
A16: Comput(ProgramPart( sI), sI,k+1) = Following(ProgramPart sI,sK2) by
AMI_1:14
    .= Exec(j,sK2) by A5,T,AMI_1:def 18;
  set f =  (card I +4) .--> goto  0;
  assume
A17: IC Comput(ProgramPart( s1), s1,1+k)=l3 + 4;
  dom f = { (card I + 4)} & n + 4 <> card I + 4 by A2,FUNCOP_1:19,SCMFSA6A:15;
  then
A18: not  (n+4) in dom f by TARSKI:def 1;
A19: dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then
A20:  (n+4) in dom if=0(a,I1,J) by A18,A12,XBOOLE_0:def 3;
A21: if=0(a, I1, J) = Mi ';' I1 ';' Stop SCM+FSA by SCMFSA8B:def 1
    .= Mi ';' J2 by SCMFSA6A:67
    .= Directed Mi +* ProgramPart Relocated(J2, 4) by A14;
  then
A22: dom if=0(a,I1,J) = dom Directed Mi \/ dom ProgramPart Relocated(J2, 4 )
  by FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom ProgramPart Relocated(J2, 4) by
FUNCT_4:105;
  then
A23:  (n+4) in dom ProgramPart Relocated(J2, 4) by A20,A15,XBOOLE_0:def 3
;
Y:  (ProgramPart sK1)/.IC sK1
 = sK1.IC sK1 by AMI_1:150;
  sK1. (n+4) = s1.(n+4) by AMI_1:54
    .= (while=0(a,I) +* Start-At( 0,SCM+FSA)). (n+4)
    by A12,A13,FUNCT_4:14
    .= (if=0(a, I1, J) +* f). (n+4) by A12,SCMFSA6B:7
    .= (Directed Mi +* ProgramPart Relocated(J2, 4)). (n+4) by A18,A12,A19,A21,
FUNCT_4:def 1
    .= (ProgramPart Relocated(J2,4)). (n+4) by A20,A22,A23,FUNCT_4:def 1
    .= IncAddr(Shift(ProgramPart(J2),4),4). (n+4) by SCMFSA_5:2
    .= IncAddr(Shift(J2,4),4). (n+4) by AMI_1:105
    .= IncAddr(j,4) by A10,A11,SCMFSA_4:24;
  then
A24: CurInstr(ProgramPart sK1,sK1) =IncAddr(j,4) by A17,Y,AMI_1:def 16;
  assume
A25: DataPart sK1 = DataPart sK2;
T: ProgramPart s1 = ProgramPart sK1
by AMI_1:144;
  Comput(ProgramPart( s1), s1,1+k+1) = Following(ProgramPart s1,sK1) by
AMI_1:14
    .= Exec(IncAddr(j,4),sK1) by A24,T,AMI_1:def 18;
  hence thesis by A17,A25,A16,SCMFSA6A:41;
end;

theorem Th20:
  for a being Int-Location, I being Program of SCM+FSA, s being
  State of SCM+FSA st I is_closed_on s & I is_halting_on s & IC Comput(
ProgramPart( (s
  +* (while=0(a,I) +* Start-At( 0,SCM+FSA)))), (s
  +* (while=0(a,I) +* Start-At( 0,SCM+FSA))),(1 + LifeSpan (s +*
  (I +* Start-At(
 0,SCM+FSA))) ) ) =
IC Comput(ProgramPart( (s +* ( I +* Start-At( 0,SCM+FSA)))), (s +* ( I +*
Start-At( 0,SCM+FSA))),
LifeSpan (s
+* (I +* Start-At( 0,SCM+FSA) )) ) + 4
holds CurInstr(ProgramPart Comput(ProgramPart( (s +* (while=0(
  a,I) +* Start-At( 0,SCM+FSA)))), (s +* (while=0(
  a,I) +* Start-At( 0,SCM+FSA))),(1 + LifeSpan (s +* (I +*
  Start-At( 0,SCM+FSA))))),
   Comput(ProgramPart( (s +* (while=0(
  a,I) +* Start-At( 0,SCM+FSA)))), (s +* (while=0(
  a,I) +* Start-At( 0,SCM+FSA))),(1 + LifeSpan (s +* (I +*
  Start-At( 0,SCM+FSA)))))) =
  goto  (card I +4)
proof
  set J3= Goto  0 ';' Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s1 = s +* (while=0(a,I) +* Start-At( 0,SCM+FSA));
  set sI = s +* ( I +* Start-At( 0,SCM+FSA));
  set life=LifeSpan (s +* (I +* Start-At( 0,SCM+FSA)));
  set sK1= Comput(ProgramPart( s1), s1,1+life);
  set sK2= Comput(ProgramPart( sI), sI,life);
  set I1= I ';' Goto  0;
  set i = a =0_goto  (card J + 3);
  reconsider n = IC sK2 as Element of NAT;
  set Mi= i ';' J ';' Goto  (card I1 + 1);
  set J2= I1 ';' Stop SCM+FSA;
  while=0(a,I) c= while=0(a,I) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A1: dom while=0(a,I) c= dom (while=0(a,I) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
  I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A2: dom I c= dom (I +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
  assume
  I is_closed_on s;
  then
A3:  n in dom I by SCMFSA7B:def 7;
  then n < card I by SCMFSA6A:15;
  then
A4: n+4 < card I+ 6 by XREAL_1:10;
  assume
  I is_halting_on s;
  then
A5: ProgramPart sI halts_on sI by SCMFSA7B:def 8;
Y:  (ProgramPart sK2)/.IC sK2
 = sK2.IC sK2 by AMI_1:150;
Z:  (ProgramPart sK1)/.IC sK1
 = sK1.IC sK1 by AMI_1:150;
  CurInstr(ProgramPart sK2,sK2) =sK2. n by Y,AMI_1:def 16
    .=sI. n by AMI_1:54
    .=(I +* Start-At( 0,SCM+FSA)). n by A3,A2,FUNCT_4:14
    .= I. n by A3,SCMFSA6B:7;
  then
A6: I. n = halt SCM+FSA by A5,AMI_1:def 46;
A7: J2= I ';' J3 by SCMFSA6A:67;
  then dom J2 = dom Directed I \/ dom ProgramPart Relocated(J3, card I) by
FUNCT_4:def 1
    .= dom I \/ dom ProgramPart Relocated(J3, card I) by FUNCT_4:105;
  then
A8:  n in dom J2 by A3,XBOOLE_0:def 3;
  then  n + 4 in { il+4 where il is Element of NAT: il in dom J2};
  then
A9:  (n+4) in dom Shift(J2,4) by VALUED_1:def 12;
  then
A10: pi(Shift(J2,4),n+4) =Shift(J2,4).( n +4) by AMI_1:def 47
    .=J2. n by A8,VALUED_1:def 12
    .=(Directed I). n by A3,A7,SCMFSA8A:28
    .=goto  card I by A3,A6,SCMFSA8A:30;
  set f =  (card I +4) .--> goto  0;
  assume
A11: IC sK1 = IC sK2 + 4;
  dom f = { (card I + 4)} & n + 4 <> card I + 4 by A3,FUNCOP_1:19,SCMFSA6A:15;
  then
A12: not  (n+4) in dom f by TARSKI:def 1;
A13: card Mi = card (i ';' J )+ card Goto  (card I1 + 1) by SCMFSA6A:61
    .= card (i ';' J ) + 1 by SCMFSA8A:29
    .= card (Macro i) + card J + 1 by SCMFSA6A:61
    .= 2 + 1 +1 by SCMFSA7B:6,LL
    .= 3+ 1;
  then n+4 >= card Mi by NAT_1:11;
  then
A14: not  (n+4) in dom Mi by SCMFSA6A:15;
  card while=0(a,I) = card I + 6 by Th4;
  then
A15:  (n+4) in dom while=0(a,I) by A4,SCMFSA6A:15;
A16: dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then
A17:  (n+4) in dom if=0(a,I1,J) by A12,A15,XBOOLE_0:def 3;
A18: if=0(a, I1, J) = Mi ';' I1 ';' Stop SCM+FSA by SCMFSA8B:def 1
    .= Mi ';' J2 by SCMFSA6A:67
    .= Directed Mi +* ProgramPart Relocated(J2, 4) by A13;
  then
A19: dom if=0(a,I1,J) = dom Directed Mi \/ dom ProgramPart Relocated(J2, 4 )
  by FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom ProgramPart Relocated(J2, 4) by
FUNCT_4:105;
  then
A20:  (n+4) in dom ProgramPart Relocated(J2, 4) by A17,A14,XBOOLE_0:def 3
;
  sK1. (n+4) = s1.(n+4) by AMI_1:54
    .= (while=0(a,I) +* Start-At( 0,SCM+FSA)). (n+4)
    by A15,A1,FUNCT_4:14
    .= (if=0(a, I1, J) +* f). (n+4) by A15,SCMFSA6B:7
    .= (Directed Mi +* ProgramPart Relocated(J2, 4)). (n+4) by A12,A15,A16,A18,
FUNCT_4:def 1
    .= (ProgramPart Relocated(J2,4)). (n+4) by A17,A19,A20,FUNCT_4:def 1
    .= IncAddr(Shift(ProgramPart(J2),4),4). (n+4) by SCMFSA_5:2
    .= IncAddr(Shift(J2,4),4). (n+4) by AMI_1:105
    .= IncAddr(goto  card I,4) by A9,A10,SCMFSA_4:24
    .= goto  (card I+4) by SCMFSA_4:14;
  hence thesis by A11,Z,AMI_1:def 16;
end;

theorem Th21:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I). (card I +4) = goto  0
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set Lc4= (card I + 4 );
  dom f = {Lc4} by FUNCOP_1:19;
  then
A1: Lc4 in dom f by TARSKI:def 1;
  Lc4 in dom while=0(a,I) & dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f
  by Th13,FUNCT_4:def 1;
  hence while=0(a,I).Lc4 = f.Lc4 by A1,FUNCT_4:def 1
    .=goto  0 by FUNCOP_1:87;
end;

reserve f for FinSeq-Location,
  c for Int-Location;

theorem Th22:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location st I is_closed_on s & I is_halting_on s & s.a =0
holds IC Comput(ProgramPart( (s +* (while=0(a,I) +* Start-At( 0,SCM+FSA)))), (s
+* (while=0(a,I) +* Start-At( 0,SCM+FSA))),
(LifeSpan (s
+* (I +* Start-At( 0,SCM+FSA))) + 3)) =  0 &
for k being Element of NAT st k
  <= LifeSpan (s +* (I +* Start-At( 0,SCM+FSA))) + 3
  holds IC Comput(ProgramPart( (s +* (
  while=0(a,I) +* Start-At( 0,SCM+FSA)))), (s +* (
  while=0(a,I) +* Start-At( 0,SCM+FSA))),k) in dom while=0(a,I)
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I is_closed_on s;
  set sI = s +* (I +* Start-At( 0,SCM+FSA));
  set s1 = s +* (while=0(a,I) +* Start-At( 0,SCM+FSA));
  defpred P[Nat] means $1 <= LifeSpan sI implies IC Comput(ProgramPart( s1
), s1
,1+$1) = IC Comput(ProgramPart( sI), sI,$1)+ 4 & DataPart Comput(ProgramPart(
s1), s1,1+$1) = DataPart
  Comput(ProgramPart( sI), sI,$1);
  assume
A2: I is_halting_on s;
A3: now
    let k be Element of NAT;
    assume
A4: P[k];
    now
A5:   k + 0 < k + 1 by XREAL_1:8;
      assume
      k + 1 <= LifeSpan sI;
      then k < LifeSpan sI by A5,XXREAL_0:2;
      hence IC Comput(ProgramPart( s1), s1,1+k+1) = IC Comput(ProgramPart( sI),
sI,k+1) + 4 & DataPart
      Comput(ProgramPart( s1), s1,1+k+1) = DataPart Comput(ProgramPart( sI), sI
,k+1) by A1,A2,A4,Th19;
    end;
    hence P[k + 1];
  end;
  reconsider l=LifeSpan sI as Element of NAT;
  set loc4= (card I + 4);
  set i = a =0_goto  4;
  set s2 = Comput(ProgramPart(s1),s1,1);
A6: IC SCM+FSA in dom (while=0(a,I) +* Start-At( 0,SCM+FSA))
by SF_MASTR:65;
A7: IC s1 = s1.IC SCM+FSA by AMI_1:def 15
    .= (while=0(a,I) +* Start-At( 0,SCM+FSA)).IC SCM+FSA by A6,FUNCT_4:14
    .=  0 by SF_MASTR:66;
  not a in dom (while=0(a,I) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  then
A8: s1.a = s.a by FUNCT_4:12;
  assume
A9: s.a = 0;
A10:  0 in dom while=0(a,I) by Th10;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by AMI_1:150;
  while=0(a,I) c= while=0(a,I) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A11: dom while=0(a,I) c= dom (while=0(a,I) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
  then s1. 0 = (while=0(a,I) +* Start-At( 0,SCM+FSA)). 0
  by A10,FUNCT_4:14
    .= while=0(a,I). 0 by A10,SCMFSA6B:7
    .= i by Th11;
  then
A12: CurInstr(ProgramPart s1,s1) = i by A7,Y,AMI_1:def 16;
A13: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by AMI_1:14
    .= Following(ProgramPart s1,s1) by AMI_1:13
    .= Exec(i,s1) by A12,AMI_1:def 18;
  then ( for c holds s2.c = s1.c)& for f holds s2.f = s1.f by SCMFSA_2:96;
  then
A14: DataPart s2 = DataPart s1 by SCMFSA6A:38
    .= DataPart s by SCMFSA8A:11
    .= DataPart sI by SCMFSA8A:11;
A15: IC s2 = s2.IC SCM+FSA by AMI_1:def 15
    .=  4 by A9,A13,A8,SCMFSA_2:96;
A16: P[ 0]
  proof
    assume
    0 <= LifeSpan sI;
A17: IC SCM+FSA in dom (I +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
    IC Comput(ProgramPart( sI), sI,0) = IC sI by AMI_1:13
      .= sI.IC SCM+FSA by AMI_1:def 15
      .= (I +* Start-At( 0,SCM+FSA)).IC SCM+FSA by A17,FUNCT_4:14
      .=  0 by SF_MASTR:66;
    hence thesis by A15,A14,AMI_1:13;
  end;
A18: for k being Element of NAT holds P[k] from NAT_1:sch 1(A16,A3);
  set s4= Comput(ProgramPart( s1), s1,1+LifeSpan sI+1+1);
  set s3= Comput(ProgramPart( s1), s1,1+LifeSpan sI+1);
A19: loc4 in dom while=0(a,I) by Th13;
  set s2= Comput(ProgramPart( s1), s1,1+LifeSpan sI);
  P[l] by A18;
  then
A20: CurInstr(ProgramPart s2,s2) = goto loc4 by A1,A2,Th20;
T: ProgramPart s1 = ProgramPart s2
by AMI_1:144;
A21: s3 = Following(ProgramPart s1,s2) by AMI_1:14
    .= Exec(goto loc4,s2) by A20,T,AMI_1:def 18;
A22: IC s3 = s3.IC SCM+FSA by AMI_1:def 15
    .= loc4 by A21,SCMFSA_2:95;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
  s3.loc4 = s1.loc4 by AMI_1:54
    .= (while=0(a,I) +* Start-At( 0,SCM+FSA)).loc4 by A11,A19,FUNCT_4:14
    .= while=0(a,I).loc4 by A19,SCMFSA6B:7
    .= goto  0 by Th21;
  then
A23: CurInstr(ProgramPart s3,s3) = goto  0 by A22,Y,AMI_1:def 16;
T: ProgramPart s1 = ProgramPart s3
by AMI_1:144;
A24: s4 = Following(ProgramPart s1,s3) by AMI_1:14
    .= Exec(goto  0,s3) by A23,T,AMI_1:def 18;
A25: IC s4 = s4.IC SCM+FSA by AMI_1:def 15
    .=  0 by A24,SCMFSA_2:95;
  hence IC Comput(ProgramPart( s1), s1,LifeSpan sI+3) =  0;
A26: LifeSpan sI+1+1+1 =LifeSpan sI+(2+1);
A27: now
    let k be Element of NAT;
    assume
A28: k <= LifeSpan sI+3;
    assume
    k<>0;
    then consider n being Nat such that
A29: k = n+ 1 by NAT_1:6;
    k<=LifeSpan sI+1 or k >= LifeSpan sI+1+1 by NAT_1:13;
    then
A30: k
<=LifeSpan sI+1 or k = LifeSpan sI+1+1 or k > LifeSpan sI+1+1 by XXREAL_0:1;
    reconsider n as Element of NAT by ORDINAL1:def 13;
    per cases by A26,A30,NAT_1:13;
    suppose
      k<=LifeSpan sI+1;
      then n <= LifeSpan sI by A29,XREAL_1:8;
      then
A31:  IC Comput(ProgramPart(s1),s1,1+n) = IC Comput(ProgramPart( sI), sI,n) + 4
by A18;
      reconsider m = IC Comput(ProgramPart( sI), sI,n) as Element of NAT;
       m in dom I by A1,SCMFSA7B:def 7;
      then m < card I by SCMFSA6A:15;
      then
A32:  m+4 < card I+ 6 by XREAL_1:10;
      card while=0(a,I) = card I + 6 by Th4;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while=0(a,I) by A29,A31,A32,
SCMFSA6A:15
;
    end;
    suppose
      k=LifeSpan sI+1+1;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while=0(a,I) by A22,Th13;
    end;
    suppose
      k >= LifeSpan sI+3;
      then k = LifeSpan sI+3 by A28,XXREAL_0:1;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while=0(a,I) by A25,Th10;
    end;
  end;
  now
    let k be Element of NAT;
    assume
A33: k <= LifeSpan sI+3;
    per cases;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while=0(a,I) by A10,A7,
AMI_1:13;
    end;
    suppose
      k <>0;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while=0(a,I) by A27,A33;
    end;
  end;
  hence thesis;
end;
set sl0= Start-At( 0,SCM+FSA);

reserve s for State of SCM+FSA,
  I for Program of SCM+FSA,
  a for read-write
  Int-Location;

definition
  let s,I,a;
  deffunc U(Nat,State of SCM+FSA) = Comput(ProgramPart(
  ($2 +* (while=0(a,I) +* sl0))),
  ($2 +* (while=0(a,I) +* sl0)), (LifeSpan ($2 +* (I +* sl0)) + 3));
  deffunc V(Nat,State of SCM+FSA) =
  down Comput(ProgramPart(
  ($2 +* (while=0(a,I) +* sl0))),
  ($2 +* (while=0(a,I) +* sl0)), (LifeSpan ($2 +* (I +* sl0)) + 3));
  func StepWhile=0(a,I,s) -> Function of NAT,product the Object-Kind of
  SCM+FSA means
  :Def4:
  it.0 = s & for i being Nat holds it.(i+1)= Comput(ProgramPart( (
  it.i +* (while=0(a,I) +* (Start-At( 0,SCM+FSA))))), (
  it.i +* (while=0(a,I) +* (Start-At( 0,SCM+FSA)))),
  (LifeSpan (it.i +* (I +* (
  Start-At( 0,SCM+FSA)))) + 3));
  existence
  proof
   reconsider ss=s as
    Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
    consider f being Function of NAT,product the Object-Kind of SCM+FSA
     such that
W1:   f.0 = ss and
W2:   for i being Nat holds f.(i+1)= V(i,f.i) from NAT_1:sch 12;
   take f;
   thus f.0 = s by W1;
   let i be Nat;
    f.(i+1)= V(i,f.i) by W2;
   hence thesis;
  end;
  uniqueness
  proof
    let F1,F2 be Function of NAT,product the Object-Kind of SCM+FSA such that
B1: F1.0 = s and
B2: for i being Nat holds F1.(i+1)= U(i,F1.i) and
B3: F2.0 = s and
B4: for i being Nat holds F2.(i+1)= U(i,F2.i);
   reconsider s as Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
A1: F1.0 = s by B1;
A2: for i being Nat holds F1.(i+1)= V(i,F1.i) by B2;
A3: F2.0 = s by B3;
A4: for i being Nat holds F2.(i+1)= V(i,F2.i) by B4;
    thus F1 = F2 from NAT_1:sch 16(A1,A2,A3,A4);
  end;
end;

reserve i,k,m,n for Element of NAT;

canceled 2;

theorem Th25:
  StepWhile=0(a,I,s).(k+1)=StepWhile=0(a,I,StepWhile=0(a,I,s).k).1
proof
  set sk=StepWhile=0(a,I,s).k;
  set sk0=StepWhile=0(a,I,sk).0;
  sk0=sk by Def4;
  hence
  StepWhile=0(a,I,s).(k+1) = Comput(ProgramPart( (sk0 +*(while=0(a,I) +* sl0))
), (sk0 +*(while=0(a,I) +* sl0)) ,
  (LifeSpan (sk0 +* (I +* sl0)) + 3)) by Def4
    .=StepWhile=0(a,I,sk).(0+1) by Def4
    .=StepWhile=0(a,I,sk).1;
end;

canceled 3;

theorem Th29:
  for s1,s2 being State of SCM+FSA st IC s1 = IC s2 & DataPart s1
  = DataPart s2 & s1 | NAT = s2 | NAT holds s1 = s2
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s1,s2 be State of SCM+FSA;
  assume
A1: IC s1 = IC s2;
  assume
  DataPart s1 = DataPart s2;
  then
A2: ( for a being Int-Location holds s1.a = s2.a)& for f being
  FinSeq-Location holds s1.f = s2.f by SCMFSA6A:38;
  assume
  s1 | NAT = s2 | NAT;
  then for l being Element of NAT holds s1.l = s2.l by SCMFSA6A:36;
  hence thesis by A1,A2,SCMFSA_2:86;
end;

theorem Th30:
  for I being Program of SCM+FSA,a being read-write Int-Location,
  s being State of SCM+FSA holds StepWhile=0(a,I,s).(0+1)= Comput(ProgramPart(
(s +* (
while=0(a,I) +* (Start-At( 0,SCM+FSA)) ))), (s +* (
while=0(a,I) +* (Start-At( 0,SCM+FSA)) )),(LifeSpan (s+* (I +*
(Start-At( 0,SCM+FSA))
  )) + 3))
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA;
X: StepWhile=0(a,I,s).0 = s by Def4;
  thus StepWhile=0(a,I,s).(0+1)= Comput(ProgramPart( (StepWhile=0(a,I,s).0 +* (
  while=0(a,I) +* sl0))), (StepWhile=0(a,I,s).0 +* (
  while=0(a,I) +* sl0)),LifeSpan (StepWhile=0(a,I,s).0 +* (I +* sl0)) + 3) by
Def4
    .= Comput(ProgramPart( (s +* (while=0(a,I) +* sl0))), (s +* (while=0(a,I)
+* sl0)), (LifeSpan (StepWhile=0(a,I
  ,s).0+* (I +* sl0)) + 3)) by X
    .= Comput(ProgramPart( (s +* (while=0(a,I) +* sl0))), (s +* (while=0(a,I)
+* sl0)), (LifeSpan (s+* (I +* sl0))
  + 3)) by Def4;
end;

theorem Th31:
  for I being Program of SCM+FSA,a being read-write Int-Location,
s being State of SCM+FSA,k,n being Element of NAT st IC StepWhile=0(a,I,s).k =
   0 & StepWhile=0(a,I,s).k= Comput(ProgramPart( (s +* (while=0(a,I) +*
  Start-At(
 0,SCM+FSA)))), (s +* (while=0(a,I) +*
  Start-At(
 0,SCM+FSA))),n) holds StepWhile=0(a,I,s).k =
StepWhile=0(a,I,s).k +* (while=0(a,I
)+* Start-At( 0,SCM+FSA)) & StepWhile=0(a,I,s).(k+1)=
Comput(ProgramPart( (s +* (while=0(
  a,I) +* Start-At( 0,SCM+FSA)))), (s +* (while=0(
  a,I) +* Start-At( 0,SCM+FSA))), (n +(LifeSpan (StepWhile=0(a,I,s).k
   +* (I +*
  Start-At( 0,SCM+FSA))) + 3)))
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA,k,n be Element of NAT;
  set s1 = s +* (while=0(a,I) +* Start-At( 0,SCM+FSA));
  set sk=StepWhile=0(a,I,s).k;
  set s2=sk +* (while=0(a,I)+* sl0);
  assume
A1: IC sk = 0;
A2: IC SCM+FSA in dom (while=0(a,I) +* sl0 ) by SF_MASTR:65;
  assume
A3: sk = Comput(ProgramPart( s1), s1,n);
  then sk | NAT =s1 | NAT by AMI_1:123;
  then
A4: DataPart s2 = DataPart sk & s2 | NAT = sk | NAT by FUNCT_4:100,SCMFSA8A:11;
T: ProgramPart s1 = ProgramPart sk
by A3,AMI_1:144;
  IC s2 = s2.IC SCM+FSA by AMI_1:def 15
    .= (while=0(a,I) +* sl0).IC SCM+FSA by A2,FUNCT_4:14
    .= IC sk by A1,SF_MASTR:66;
  hence s2=sk by A4,Th29;
  hence
  StepWhile=0(a,I,s).(k+1)= Comput(ProgramPart( s1), sk,LifeSpan (sk +* (I +*
sl0)) +
  3) by Def4,T
    .= Comput(ProgramPart( s1), s1,n +(LifeSpan (sk +* (I +* sl0)) + 3)) by A3,
AMI_1:51;
end;

theorem Th32:
  for I being Program of SCM+FSA,a being read-write Int-Location,
s being State of SCM+FSA st (for k being Nat holds I is_closed_on StepWhile=0(a
  ,I,s).k & I is_halting_on StepWhile=0(a,I,s).k) & ex f being Function of
  product the Object-Kind of SCM+FSA,NAT st (for k being Nat holds (f.(
StepWhile=0(a,I,s).(k+1)) < f.(StepWhile=0(a,I,s).k) or f.(StepWhile=0(a,I,s).k
  ) = 0) & ( f.(StepWhile=0(a,I,s).k)=0 iff (StepWhile=0(a,I,s).k).a <> 0 ) )
  holds while=0(a,I) is_halting_on s & while=0(a,I) is_closed_on s
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA;
  assume
A1: for k being Nat holds I is_closed_on StepWhile=0(a,I,s).k & I
  is_halting_on StepWhile=0(a,I,s).k;
A2: IC SCM+FSA in dom (while=0(a,I) +* sl0 ) by SF_MASTR:65;
  set s1 = s +* (while=0(a,I) +* Start-At( 0,SCM+FSA));
  given f being Function of product the Object-Kind of SCM+FSA,NAT such that
A3: for k being Nat holds (f.(StepWhile=0(a,I,s).(k+1)) < f.(StepWhile=0
(a,I,s).k) or f.(StepWhile=0(a,I,s).k) = 0) & ( f.(StepWhile=0(a,I,s).k)=0 iff
  (StepWhile=0(a,I,s).k).a <> 0 );
  deffunc F(Nat) = f.(StepWhile=0(a,I,s).$1);
A4: for k being Nat holds ( F(k+1) < F(k) or F(k) = 0 ) by A3;
  consider m being Nat such that
A5: F(m)=0 and
A6: for n being Nat st F(n) =0 holds m <= n from NAT_1:sch 17(A4);
  defpred P[Nat] means $1+1 <= m implies ex k st StepWhile=0(a,I,s)
  .($1+1)= Comput(ProgramPart( s1), s1,k);
A7: now
    let k be Element of NAT;
    assume
A8: P[k];
    now
      set sk1=StepWhile=0(a,I,s).(k+1);
      set sk=StepWhile=0(a,I,s).k;
      assume
A9:   (k+1)+ 1 <= m;
      k + 0 < k+ (1+ 1) by XREAL_1:8;
      then k < m by A9,XXREAL_0:2;
      then F(k) <> 0 by A6;
      then
A10:  sk.a = 0 by A3;
A11:  I is_halting_on sk by A1;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
      then consider n being Element of NAT such that
A12:  sk1 = Comput(ProgramPart( s1), s1,n) by A8,A9,XXREAL_0:2;
      take m=n +(LifeSpan (sk1 +* (I +* sl0)) + 3);
      sk1= Comput(ProgramPart( (sk +* (while=0(a,I)+* sl0))), (sk +* (while=0(a
,I)+* sl0)), (LifeSpan (sk +* (I
      +* sl0)) + 3)) & I is_closed_on sk by A1,Def4;
      then IC sk1 = 0 by A11,A10,Th22;
      hence StepWhile=0(a,I,s).((k+1)+1)= Comput(ProgramPart( s1), s1,m) by A12
,Th31;
    end;
    hence P[k+1];
  end;
A13: P[ 0]
  proof
    assume
    0+1 <= m;
    take n=(LifeSpan (s+* (I +* sl0)) + 3);
    thus thesis by Th30;
  end;
A14: for k being Element of NAT holds P[k] from NAT_1:sch 1(A13,A7);
  now
    per cases;
    suppose
      m=0;
      then (StepWhile=0(a,I,s).0).a <> 0 by A3,A5;
      then s.a <> 0 by Def4;
      hence thesis by Th18;
    end;
    suppose
A15:  m<>0;
      then consider i being Nat such that
A16:  m=i+1 by NAT_1:6;
      reconsider m,i as Element of NAT by ORDINAL1:def 13;
      set sm=StepWhile=0(a,I,s).m;
      set si=StepWhile=0(a,I,s).i;
      i < m by A16,NAT_1:13;
      then F(i) <> 0 by A6;
      then
A17:  si.a = 0 by A3;
A18:  I is_closed_on si & I is_halting_on si by A1;
      sm= Comput(ProgramPart( (si +* (while=0(a,I)+* sl0))), (si +* (while=0(a,
I)+* sl0)), (LifeSpan (si +* (I
      +* sl0)) + 3)) by A16,Def4;
      then
A19:  IC sm = 0 by A18,A17,Th22;
      set p=(LifeSpan (s+* (I +* sl0)) + 3);
      set sm1=sm +* (while=0(a,I)+* sl0);
      m=i+1 by A16;
      then consider n being Element of NAT such that
A20:  sm = Comput(ProgramPart( s1), s1,n) by A14;
      reconsider n as Element of NAT;
      sm | NAT =s1 | NAT by A20,AMI_1:123;
      then
A21:  DataPart sm1 = DataPart sm & sm1 | NAT = sm | NAT by FUNCT_4:100
,SCMFSA8A:11;
      IC sm1 = sm1.IC SCM+FSA by AMI_1:def 15
        .= (while=0(a,I) +* sl0).IC SCM+FSA by A2,FUNCT_4:14
        .= IC sm by A19,SF_MASTR:66;
      then
A22:  sm1=sm by A21,Th29;
A23:  sm.a <> 0 by A3,A5;
      then while=0(a,I) is_halting_on sm by Th18;
      then ProgramPart sm1 halts_on sm1 by SCMFSA7B:def 8;
      then consider j being Element of NAT such that
A24:  CurInstr(ProgramPart Comput(ProgramPart(sm),sm,j),Comput(ProgramPart(sm),
sm,j))
 = halt SCM+FSA by A22,AMI_1:146;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),
s1,n)
by AMI_1:144;
x: Comput(ProgramPart(s1),s1,n+j)
 = Comput(ProgramPart(s1),Comput(ProgramPart(s1),s1,n),j) by AMI_1:51;
      CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n+j),Comput(ProgramPart(s1
),s1,n+j))
       = halt SCM+FSA by A20,A24,x,T;
      then ProgramPart s1 halts_on s1 by AMI_1:146;
      hence while=0(a,I) is_halting_on s by SCMFSA7B:def 8;
      now
        let q be Element of NAT;
A25:    0<m by A15;
        per cases;
        suppose
A26:      q <= p;
A27:      StepWhile=0(a,I,s).0=s by Def4;
          then
A28:      I is_closed_on s & I is_halting_on s by A1;
          F(0) <> 0 by A6,A25;
          then s.a = 0 by A3,A27;
          hence IC Comput(ProgramPart(s1),s1,q) in dom while=0(a,I) by A26,A28
,Th22;
        end;
        suppose
A29:      q > p;
A30:      now
            take k=p;
            thus StepWhile=0(a,I,s).1= Comput(ProgramPart( s1), s1,k) & k <= q
by A29,Th30;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 & (ex k st StepWhile=0(a,I,s).$1
          = Comput(ProgramPart( s1), s1,k) & k <= q);
A31:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A25,XREAL_1:8;
          then 1 <= m by NAT_1:13;
          then
A32:      ex t be Nat st P2[t] by A30;
          consider t be Nat such that
A33:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A31,A32);
          reconsider t as Element of NAT by ORDINAL1:def 13;
          now
            per cases;
            suppose
              t=m;
              then consider r being Element of NAT such that
A34:          sm= Comput(ProgramPart( s1), s1,r) and
A35:          r <= q by A33;
              consider x being Nat such that
A36:          q = r+x by A35,NAT_1:10;
A37:          while=0(a,I) is_closed_on sm by A23,Th18;
              reconsider x as Element of NAT by ORDINAL1:def 13;
T: ProgramPart s1 = ProgramPart sm1
by A22,A34,AMI_1:144;
              Comput(ProgramPart(s1),s1,q) = Comput(ProgramPart( s1), sm1,x)
by A22,A34,A36,AMI_1:51;
              hence IC Comput(ProgramPart(s1),s1,q) in dom while=0(a,I) by A37
,T,SCMFSA7B:def 7;
            end;
            suppose
A38:          t<>m;
              set Dt=StepWhile=0(a,I,s).t;
A39:          t < m by A33,A38,XXREAL_0:1;
              then F(t) <> 0 by A6;
              then
A40:          Dt.a = 0 by A3;
              consider z being Element of NAT such that
A41:          StepWhile=0(a,I,s).t= Comput(ProgramPart( s1), s1,z) and
A42:          z <= q by A33;
              set z2=z +(LifeSpan (Dt +* (I +* sl0)) + 3);
              consider w being Nat such that
A43:          q = z+w by A42,NAT_1:10;
A44:          I is_closed_on Dt & I is_halting_on Dt by A1;
              consider y being Nat such that
A45:          t=y+1 by A33,NAT_1:6;
              reconsider y as Element of NAT by ORDINAL1:def 13;
              set Dy=StepWhile=0(a,I,s).y;
              y+ 0 < t by A45,XREAL_1:8;
              then y < m by A33,XXREAL_0:2;
              then F(y) <> 0 by A6;
              then
A46:          Dy.a = 0 by A3;
A47:          I is_closed_on Dy & I is_halting_on Dy by A1;
              reconsider w as Element of NAT by ORDINAL1:def 13;
              Dt= Comput(ProgramPart( (Dy +* (while=0(a,I)+* sl0))), (Dy +* (
while=0(a,I)+* sl0)), (LifeSpan (
              Dy +* (I +* sl0)) + 3)) by A45,Def4;
              then
A48:          IC Dt = 0 by A47,A46,Th22;
              now
                assume
A49:            z2 <= q;
A50:            now
                  take k=z2;
                  thus StepWhile=0(a,I,s).(t+1)= Comput(ProgramPart( s1), s1,k)
& k <= q
by A41,A48,A49,Th31;
                end;
                t+1 <= m by A39,NAT_1:13;
                hence contradiction by A33,A50,XREAL_1:31;
              end;
              then
A51:          w < LifeSpan (Dt +* (I +* sl0)) + 3 by A43,XREAL_1:8;
X: Dt = Dt +* (while=0(a,I)+* sl0) by A41,A48,Th31;
T: ProgramPart s1 = ProgramPart Dt
by A41,A43,AMI_1:144;
              Comput(ProgramPart(s1),s1,q) = Comput(ProgramPart( s1), Dt,w) by
A41,A43,AMI_1:51
                .= Comput(ProgramPart( (Dt +* (while=0(a,I)+* sl0))), (Dt +* (
while=0(a,I)+* sl0)),w) by X,T
;
              hence IC Comput(ProgramPart(s1),s1,q) in dom while=0(a,I) by A51
,A44,A40,Th22;
            end;
          end;
          hence IC Comput(ProgramPart(s1),s1,q) in dom while=0(a,I);
        end;
      end;
      hence while=0(a,I) is_closed_on s by SCMFSA7B:def 7;
      set D = Int-Locations \/ FinSeq-Locations;
    end;
  end;
  hence thesis;
end;

theorem Th33:
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location, s being State of SCM+FSA st ex f being Function of product the
Object-Kind of SCM+FSA,NAT st (for k being Nat holds (f.(StepWhile=0(a,I,s).(k+
  1)) < f.(StepWhile=0(a,I,s).k) or f.(StepWhile=0(a,I,s).k) = 0) & ( f.(
StepWhile=0(a,I,s).k)=0 iff (StepWhile=0(a,I,s).k).a <> 0 ) ) holds while=0(a,I
  ) is_halting_on s & while=0(a,I) is_closed_on s
proof
  let I be parahalting Program of SCM+FSA,a be read-write Int-Location,s be
  State of SCM+FSA;
A1: ( for k being Nat holds I is_closed_on StepWhile=0(a,I,s).k)& for k
  being Nat holds I is_halting_on StepWhile=0(a,I,s).k by SCMFSA7B:24,25;
  assume
  ex f being Function of product the Object-Kind of SCM+FSA,NAT st for
k being Nat holds (f.(StepWhile=0(a,I,s).(k+1)) < f.(StepWhile=0(a,I,s).k) or f
.(StepWhile=0(a,I,s).k) = 0) & ( f.(StepWhile=0(a,I,s).k)=0 iff (StepWhile=0(a,
  I,s).k).a <> 0 );
  hence thesis by A1,Th32;
end;

theorem
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location st ex f being Function of product the Object-Kind of SCM+FSA,NAT
st (for s being State of SCM+FSA holds (f.(StepWhile=0(a,I,s).1) < f.s or f.s =
  0) & ( f.s =0 iff s.a <> 0 )) holds while=0(a,I) is parahalting
proof
  let I be parahalting Program of SCM+FSA,a be read-write Int-Location;
  given f being Function of product the Object-Kind of SCM+FSA,NAT such that
A1: for s being State of SCM+FSA holds (f.(StepWhile=0(a,I,s).1) < f.s
  or f.s = 0) & ( f.s =0 iff s.a <> 0 );
  now
    let t be State of SCM+FSA;
    now
      let k be Nat;
A2:   k in NAT by ORDINAL1:def 13;
      f.(StepWhile=0(a,I,StepWhile=0(a,I,t).k).1) < f.(StepWhile=0(a,I,t).
      k) or f.(StepWhile=0(a,I,t).k) = 0 by A1;
      hence (f.(StepWhile=0(a,I,t).(k+1)) < f.(StepWhile=0(a,I,t).k) or f.(
StepWhile=0(a,I,t).k) = 0) & ( f.(StepWhile=0(a,I,t).k)=0 iff (StepWhile=0(a,I,
      t).k).a <> 0 ) by A1,A2,Th25;
    end;
    hence while=0(a,I) is_halting_on t by Th33;
  end;
  hence thesis by SCMFSA7B:25;
end;

theorem Th35:
  for l1,l2 being Element of NAT,a being
  Int-Location holds (l1 .--> goto l2) does_not_destroy a
proof
  let l1,l2 be Element of NAT,a be Int-Location;
  set I=l1 .--> goto l2;
A1: rng I={goto l2 } by FUNCOP_1:14;
  now
    let i be Instruction of SCM+FSA;
    assume
    i in rng I;
    then i=goto l2 by A1,TARSKI:def 1;
    hence i does_not_destroy a by SCMFSA7B:17;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th36:
  for i being Instruction of SCM+FSA st i does_not_destroy intloc
  0 holds Macro i is good
proof
  let i be Instruction of SCM+FSA;
  set I=Macro i;
A1: rng I c={i,halt SCM+FSA} by FUNCT_4:65;
  assume
A2: i does_not_destroy intloc 0;
  now
    let x be Instruction of SCM+FSA;
    assume
A3: x in rng I;
    per cases by A1,A3,TARSKI:def 2;
    suppose
      x = i;
      hence x does_not_destroy intloc 0 by A2;
    end;
    suppose
      x = halt SCM+FSA;
      hence x does_not_destroy intloc 0 by SCMFSA7B:11;
    end;
  end;
  then I does_not_destroy intloc 0 by SCMFSA7B:def 4;
  hence thesis by SCMFSA7B:def 5;
end;

registration
  let I,J be good Program of SCM+FSA,a be Int-Location;
  cluster if=0(a,I,J) -> good;
  correctness
  proof
    set i = a =0_goto  (card J + 3);
    reconsider Mi=Macro i as good Program of SCM+FSA by Th36,SCMFSA7B:18;
    if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I ';' Stop
    SCM+FSA by SCMFSA8B:def 1
      .= Mi ';' J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
    hence thesis;
  end;
end;

registration
  let I be good Program of SCM+FSA,a be Int-Location;
  cluster while=0(a,I) -> good;
  correctness
  proof
    set F=if=0(a, I ';' Goto  0, Stop SCM+FSA);
    set J= (card I +4) .--> goto  0;
    J does_not_destroy intloc 0 & F does_not_destroy intloc 0 by Th35,
SCMFSA7B:def 5;
    then while=0(a,I) does_not_destroy intloc 0 by SCMFSA8A:25;
    hence thesis by SCMFSA7B:def 5;
  end;
end;

:: -----------------------------------------------------------
:: WHILE>0  Statement

theorem Th37:
  for a being Int-Location, I being Program of SCM+FSA, k being
  Element of NAT st k < 6 holds  k in dom while>0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
A1: 6 <= card I + 6 by NAT_1:11;
A2: card while>0(a,I) = card I + 6 by Th5;
  assume
  k < 6;
  then k < card I + 6 by A1,XXREAL_0:2;
  hence thesis by A2,SCMFSA6A:15;
end;

theorem Th38:
  for a being Int-Location, I being Program of SCM+FSA, k being
  Element of NAT st k < 6 holds card I +k in dom while>0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
  assume
  k < 6;
  then
A1: card I + k < card I + 6 by XREAL_1:8;
  card while>0(a,I) = card I + 6 by Th5;
  hence thesis by A1,SCMFSA6A:15;
end;

theorem Th39:
  for a being Int-Location, I being Program of SCM+FSA holds
  while>0(a,I).(card I+5) = halt SCM+FSA
proof
  set J1= Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a >0_goto  (card J + 3);
  set c5 = card I + 5;
  set Lc5= c5;
  set Mi= Macro i ';' J ';' Goto  (card I1 + 1) ';' I1;
  dom f = { (card I + 4)} & Lc5 <>  (card I + 4) by FUNCOP_1:19;
  then
A1: not Lc5 in dom f by TARSKI:def 1;
   0 + c5 in { il+c5 where il is Element of NAT: il in dom J1} by JJ;
  then
A2:  c5 in dom Shift(J1,c5) by VALUED_1:def 12;
  then
A3: pi(Shift(J1,c5),Lc5) = Shift(J1,c5).( 0 +c5) by AMI_1:def 47
    .= halt SCM+FSA by KK,JJ,VALUED_1:def 12;
A4: Lc5 in dom while>0(a,I) & dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f
  by Th38,FUNCT_4:def 1;
  then
A5: Lc5 in dom if>0(a,I1,J) by A1,XBOOLE_0:def 3;
A6: if>0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 2
    .= Mi ';' J1;
  then card if>0(a, I1,J) = card Mi + card J1 by SCMFSA6A:61;
  then
A7: card Mi = card if>0(a,I1,J)-card J1
    .= card I + 6 - 1 by Th2,LL
    .= c5;
  then
A8: not Lc5 in dom Mi by SCMFSA6A:15;
A9: dom if>0(a,I1,J) = dom Directed Mi \/ dom ProgramPart Relocated(J1, c5)
  by A6,A7,FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom ProgramPart Relocated(J1, c5) by
FUNCT_4:105;
  then
A10: Lc5 in dom ProgramPart Relocated(J1, c5) by A5,A8,XBOOLE_0:def 3;
  thus while>0(a,I).Lc5 = (Directed Mi +* ProgramPart Relocated(J1, c5)).Lc5
  by A1,A4,A6,A7,FUNCT_4:def 1
    .= (ProgramPart Relocated(J1,c5)).Lc5 by A5,A9,A10,FUNCT_4:def 1
    .= IncAddr(Shift(ProgramPart(J1),c5),c5).Lc5 by SCMFSA_5:2
    .= IncAddr(Shift(J1,c5),c5).Lc5 by AMI_1:105
    .= IncAddr( halt SCM+FSA, c5 ) by A2,A3,SCMFSA_4:24
    .= halt SCM+FSA by SCMFSA_4:8;
end;

theorem Th40:
  for a being Int-Location, I being Program of SCM+FSA holds
  while>0(a,I). 3 = goto  (card I +5)
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a >0_goto  (card J + 3);
  set Mi=Macro i ';' J;
  set G=Goto  (card I1 + 1);
  set J2= (I1 ';' Stop SCM+FSA);
  set J1=G ';' J2;
A1:  0 in dom G by SCMFSA8A:47;
A2: G. 0 = goto  (card I1 + 1) by SCMFSA8A:47
    .= goto  (card I + card Goto  0 + 1) by SCMFSA6A:61
    .= goto  (card I + 1 + 1) by SCMFSA8A:29
    .= goto  (card I +(1+1));
  then
A3: G. 0 <> halt SCM+FSA by SCMFSA_2:47,124;
  dom J1 = dom Directed G \/ dom ProgramPart Relocated(J2, card G) by
FUNCT_4:def 1
    .= dom G \/ dom ProgramPart Relocated(J2, card G) by FUNCT_4:105;
  then
A4:  0 in dom J1 by A1,XBOOLE_0:def 3;
  then  0 + 3 in { il+3 where il is Element of NAT: il in dom J1};
  then
A5:  3 in dom Shift(J1,3) by VALUED_1:def 12;
  then
A6: pi(Shift(J1,3),3) =Shift(J1,3).( 0 +3) by AMI_1:def 47
    .=J1. 0 by A4,VALUED_1:def 12
    .=(Directed G). 0 by A1,SCMFSA8A:28
    .=goto  (card I + 2) by A1,A2,A3,SCMFSA8A:30;
  dom f = { (card I + 4)} & 3 <> card I + 4 by FUNCOP_1:19,NAT_1:11;
  then
A7: not  3 in dom f by TARSKI:def 1;
A8: card Mi = card Macro i + card J by SCMFSA6A:61
    .= 2 + 1 by SCMFSA7B:6,LL;
  then
A9: not  3 in dom Mi by SCMFSA6A:15;
A10:  3 in dom while>0(a,I) & dom while>0(a,I) = dom if>0(a,I1,J) \/
  dom f by Th37,FUNCT_4:def 1;
  then
A11:  3 in dom if>0(a,I1,J) by A7,XBOOLE_0:def 3;
A12: if>0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= Mi ';' J1 by SCMFSA6A:67
    .= Directed Mi +* ProgramPart Relocated(J1, 3) by A8;
  then
A13: dom if>0(a,I1,J) = dom Directed Mi \/ dom ProgramPart Relocated(J1, 3)
  by FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom ProgramPart Relocated(J1, 3) by
FUNCT_4:105;
  then
A14:  3 in dom ProgramPart Relocated(J1, 3) by A11,A9,XBOOLE_0:def 3;
  thus while>0(a,I). 3 = (Directed Mi +* ProgramPart Relocated(J1, 3)).
   3 by A7,A10,A12,FUNCT_4:def 1
    .= (ProgramPart Relocated(J1,3)). 3 by A11,A13,A14,FUNCT_4:def 1
    .= IncAddr(Shift(ProgramPart(J1),3),3). 3 by SCMFSA_5:2
    .= IncAddr(Shift(J1,3),3). 3 by AMI_1:105
    .= IncAddr(goto  (card I +2),3) by A5,A6,SCMFSA_4:24
    .= goto  (card I+ 2 +3) by SCMFSA_4:14
    .= goto  (card I+ 5);
end;

theorem Th41:
  for a being Int-Location, I being Program of SCM+FSA holds
  while>0(a,I). 2 = goto  3
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a >0_goto  (card J + 3);
  set Mi=Macro i;
  set J2=Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA);
  set J1=J ';' J2;
  dom f = { (card I + 4)} & 2 <> card I + 4 by FUNCOP_1:19,NAT_1:11;
  then
A1: not  2 in dom f by TARSKI:def 1;
  dom J1 = dom Directed J \/ dom ProgramPart Relocated(J2, card J) by
FUNCT_4:def 1
    .= dom J \/ dom ProgramPart Relocated(J2, card J) by FUNCT_4:105;
  then
A2:  0 in dom J1 by JJ,XBOOLE_0:def 3;
  then  0 + 2 in { il+2 where il is Element of NAT: il in dom J1};
  then
A3:  2 in dom Shift(J1,2) by VALUED_1:def 12;
  then
A4: pi(Shift(J1,2),2) =Shift(J1,2).( 0 +2) by AMI_1:def 47
    .=J1. 0 by A2,VALUED_1:def 12
    .=(Directed J). 0 by SCMFSA8A:28,JJ
    .=goto  card J by KK,SCMFSA8A:30,JJ;
  card Mi = 2 by SCMFSA7B:6;
  then
A5: not  2 in dom Mi by SCMFSA6A:15;
A6:  2 in dom while>0(a,I) & dom while>0(a,I) = dom if>0(a,I1,J) \/
  dom f by Th37,FUNCT_4:def 1;
  then
A7:  2 in dom if>0(a,I1,J) by A1,XBOOLE_0:def 3;
A8: if>0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)) by
SCMFSA6A:67
    .= i ';' J1 by SCMFSA6A:71
    .= Directed Mi +* ProgramPart Relocated(J1, 2) by SCMFSA7B:6;
  then
A9: dom if>0(a,I1,J) = dom Directed Mi \/ dom ProgramPart Relocated(J1, 2)
  by FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom ProgramPart Relocated(J1, 2) by
FUNCT_4:105;
  then
A10:  2 in dom ProgramPart Relocated(J1, 2) by A7,A5,XBOOLE_0:def 3;
  thus while>0(a,I). 2 = (Directed Mi +* ProgramPart Relocated(J1, 2)).
   2 by A1,A6,A8,FUNCT_4:def 1
    .= (ProgramPart Relocated(J1,2)). 2 by A7,A9,A10,FUNCT_4:def 1
    .= IncAddr(Shift(ProgramPart(J1),2),2). 2 by SCMFSA_5:2
    .= IncAddr(Shift(J1,2),2). 2 by AMI_1:105
    .= IncAddr(goto  card J,2) by A3,A4,SCMFSA_4:24
    .= goto ( 1 + 2) by SCMFSA_4:14,LL
    .= goto  3;
end;

theorem
  for a being Int-Location, I being Program of SCM+FSA, k being Element
  of NAT st k < card I +6 holds  k in dom while>0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
  assume
A1: k < card I +6;
  card while>0(a,I) = card I + 6 by Th5;
  hence thesis by A1,SCMFSA6A:15;
end;

theorem Th43:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location st s.a <= 0 holds while>0(a,I) is_halting_on s &
  while>0(a,I) is_closed_on s
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a <= 0;
  set i = a >0_goto  4;
  set s1 = s +* (while>0(a,I) +* Start-At( 0,SCM+FSA));
A2: IC SCM+FSA in dom (while>0(a,I) +* Start-At( 0,SCM+FSA))
by SF_MASTR:65;
A3: IC s1 = s1.IC SCM+FSA by AMI_1:def 15
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)).IC SCM+FSA by A2,FUNCT_4:14
    .=  0 by SF_MASTR:66;
  set loc5=  (card I +5);
  set s5 = Comput(ProgramPart(s1),s1,4);
  set s4 = Comput(ProgramPart(s1),s1,3);
  set s3 = Comput(ProgramPart(s1),s1,2);
  set s2 = Comput(ProgramPart(s1),s1,1);
A4:  1 in dom while>0(a,I) by Th10;
A5:  2 in dom while>0(a,I) by Th37;
  not a in dom (while>0(a,I) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  then
A6: s1.a = s.a by FUNCT_4:12;
  while>0(a,I) c= while>0(a,I) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A7: dom while>0(a,I) c= dom (while>0(a,I) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by AMI_1:150;
A8:  0 in dom while>0(a,I) by Th10;
  then s1. 0 = (while>0(a,I) +* Start-At( 0,SCM+FSA)). 0
  by A7,FUNCT_4:14
    .= while>0(a,I). 0 by A8,SCMFSA6B:7
    .= i by Th11;
  then
A9: CurInstr(ProgramPart s1,s1) = i by A3,Y,AMI_1:def 16;
A10: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by AMI_1:14
    .= Following(ProgramPart s1,s1) by AMI_1:13
    .= Exec(i,s1) by A9,AMI_1:def 18;
A11: IC Comput(ProgramPart(s1),s1,1) = Comput(ProgramPart(s1),s1,1).IC SCM+FSA
by AMI_1:def 15
    .= succ  0 by A1,A3,A10,A6,SCMFSA_2:97
    .=  (0 + 1);
Y:  (ProgramPart Comput(ProgramPart(s1),s1,1))/.IC Comput(ProgramPart(s1),s1,1)
 = Comput(ProgramPart(s1),s1,1).IC Comput(ProgramPart(s1),s1,1) by AMI_1:150;
  Comput(ProgramPart(s1),s1,1). 1 = s1. 1 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)). 1
    by A7,A4,FUNCT_4:14
    .= while>0(a,I). 1 by A4,SCMFSA6B:7
    .= goto  2 by Th11;
  then
A12: CurInstr(ProgramPart Comput(ProgramPart(s1),s1,1),Comput(ProgramPart(s1),
s1,1))
 = goto  2 by A11,Y,AMI_1:def 16;
T: ProgramPart s1 = ProgramPart s2
by AMI_1:144;
A13: Comput(ProgramPart(s1),s1,1+1) = Following(ProgramPart s1,s2) by AMI_1:14
    .= Exec(goto  2,s2) by A12,T,AMI_1:def 18;
A14: IC s3 = s3.IC SCM+FSA by AMI_1:def 15
    .=  2 by A13,SCMFSA_2:95;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
  s3. 2 = s1. 2 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)). 2
    by A7,A5,FUNCT_4:14
    .= while>0(a,I). 2 by A5,SCMFSA6B:7
    .= goto  3 by Th41;
  then
A15: CurInstr(ProgramPart s3,s3) = goto  3 by A14,Y,AMI_1:def 16;
T: ProgramPart s1 = ProgramPart s3
by AMI_1:144;
A16: Comput(ProgramPart(s1),s1,2+1) = Following(ProgramPart s1,s3) by AMI_1:14
    .= Exec(goto  3,s3) by A15,T,AMI_1:def 18;
A17: IC s4 = s4.IC SCM+FSA by AMI_1:def 15
    .=  3 by A16,SCMFSA_2:95;
A18:  3 in dom while>0(a,I) by Th37;
A19: loc5 in dom while>0(a,I) by Th38;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
  s4. 3 = s1. 3 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)). 3
    by A7,A18,FUNCT_4:14
    .= while>0(a,I). 3 by A18,SCMFSA6B:7
    .= goto loc5 by Th40;
  then
A20: CurInstr(ProgramPart s4,s4) = goto loc5 by A17,Y,AMI_1:def 16;
T: ProgramPart s1 = ProgramPart s4
by AMI_1:144;
A21: Comput(ProgramPart(s1),s1,3+1) = Following(ProgramPart s1,s4) by AMI_1:14
    .= Exec(goto loc5,s4) by A20,T,AMI_1:def 18;
A22: IC s5 = s5.IC SCM+FSA by AMI_1:def 15
    .= loc5 by A21,SCMFSA_2:95;
Y:  (ProgramPart s5)/.IC s5
 = s5.IC s5 by AMI_1:150;
  s5.loc5 = s1.loc5 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)).loc5 by A7,A19,FUNCT_4:14
    .= while>0(a,I).loc5 by A19,SCMFSA6B:7
    .= halt SCM+FSA by Th39;
  then
A23: CurInstr(ProgramPart s5,s5) = halt SCM+FSA by A22,Y,AMI_1:def 16;
  then ProgramPart s1 halts_on s1 by AMI_1:146;
  hence while>0(a,I) is_halting_on s by SCMFSA7B:def 8;
TX: ProgramPart s1 = ProgramPart s5
by AMI_1:144;
  now
    let k be Element of NAT;
A24: k<=3 or k >= 3+1 by NAT_1:13;
    per cases by A24,NAT_1:28;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while>0(a,I) by A8,A3,
AMI_1:13;
    end;
    suppose
      k = 1;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while>0(a,I) by A11,Th10;
    end;
    suppose
      k = 2;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while>0(a,I) by A14,Th37;
    end;
    suppose
      k = 3;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while>0(a,I) by A17,Th37;
    end;
    suppose
      k >= 4;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while>0(a,I) by A19,A22,A23
,TX,AMI_1:52;
    end;
  end;
  hence thesis by SCMFSA7B:def 7;
end;

theorem Th44:
  for a being Int-Location, I being Program of SCM+FSA, s being
State of SCM+FSA,k being Element of NAT st I is_closed_on s & I is_halting_on s
& k < LifeSpan (s +* (I +* Start-At( 0,SCM+FSA))) &
IC Comput(ProgramPart( (s +* (while>0
  (a,I) +* Start-At( 0,SCM+FSA)))), (s +* (while>0
  (a,I) +* Start-At( 0,SCM+FSA))),1+k) = IC Comput(ProgramPart( (s +* ( I +*
  Start-At(
   0,SCM+FSA)))), (s +* ( I +*
  Start-At(
   0,SCM+FSA))),k) + 4 & DataPart Comput(ProgramPart( (s +* (while>0(a,I) +*
  Start-At(
   0,SCM+FSA)))), (s +* (while>0(a,I) +*
  Start-At(
   0,SCM+FSA))),1+k) = DataPart Comput(ProgramPart( (s +* ( I +*
  Start-At( 0,SCM+FSA)))), (s +* ( I +*
  Start-At( 0,SCM+FSA))),k)
  holds IC Comput(ProgramPart( (s +* (while>0(a,I) +*
  Start-At( 0,SCM+FSA)))), (s +* (while>0(a,I) +*
  Start-At( 0,SCM+FSA))),1+k+1) = IC
Comput(ProgramPart( (s +* (I +* Start-At( 0,SCM+FSA)))), (s +* (I +* Start-At(
0,SCM+FSA))),k+1) + 4 &
DataPart Comput(ProgramPart( (
s +* (while>0(a,I) +* Start-At( 0,SCM+FSA)))), (
s +* (while>0(a,I) +* Start-At( 0,SCM+FSA))),1+k+1) =
DataPart Comput(ProgramPart( (s +*
  (I +* Start-At( 0,SCM+FSA)))), (s +*
  (I +* Start-At( 0,SCM+FSA))),k+1)
proof
  set J3= Goto  0 ';' Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  let k be Element of NAT;
  set s1 = s +* (while>0(a,I) +* Start-At( 0,SCM+FSA));
  set sI = s +* ( I +* Start-At( 0,SCM+FSA));
  set sK1= Comput(ProgramPart( s1), s1,1+k);
  set sK2= Comput(ProgramPart( sI), sI,k);
  set l3=IC Comput(ProgramPart( sI), sI,k);
  set I1= I ';' Goto  0;
  set i = a >0_goto  (card J + 3);
  reconsider n = l3 as Element of NAT;
  set Mi= i ';' J ';' Goto  (card I1 + 1);
  set J2= I1 ';' Stop SCM+FSA;
A1: rng I c= the Instructions of SCM+FSA by AMI_1:118;
  assume
  I is_closed_on s;
  then
A2:  n in dom I by SCMFSA7B:def 7;
  then n < card I by SCMFSA6A:15;
  then
A3: n+4 < card I+ 6 by XREAL_1:10;
Y:  (ProgramPart sK2)/.IC sK2
 = sK2.IC sK2 by AMI_1:150;
  I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A4: dom I c= dom (I +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
A5: CurInstr(ProgramPart sK2,sK2) =sK2. n by Y,AMI_1:def 16
    .=sI. n by AMI_1:54
    .=(I +* Start-At( 0,SCM+FSA)). n by A2,A4,FUNCT_4:14
    .= I. n by A2,SCMFSA6B:7;
  assume
  I is_halting_on s;
  then
A6: ProgramPart sI halts_on sI by SCMFSA7B:def 8;
  assume
  k < LifeSpan sI;
  then
A7: I. n <> halt SCM+FSA by A5,A6,AMI_1:def 46;
A8: J2= I ';' J3 by SCMFSA6A:67;
  then dom J2 = dom Directed I \/ dom ProgramPart Relocated(J3, card I) by
FUNCT_4:def 1
    .= dom I \/ dom ProgramPart Relocated(J3, card I) by FUNCT_4:105;
  then
A9:  n in dom J2 by A2,XBOOLE_0:def 3;
  then  n + 4 in { il+4 where il is Element of NAT: il in dom J2};
  then
A10:  (n+4) in dom Shift(J2,4) by VALUED_1:def 12;
  then
A11: pi(Shift(J2,4),n+4) =Shift(J2,4).( n +4) by AMI_1:def 47
    .=J2. n by A9,VALUED_1:def 12
    .=(Directed I). n by A2,A8,SCMFSA8A:28
    .=I. n by A2,A7,SCMFSA8A:30;
  card while>0(a,I) = card I + 6 by Th5;
  then
A12:  (n+4) in dom while>0(a,I) by A3,SCMFSA6A:15;
  I. n in rng I by A2,FUNCT_1:def 5;
  then reconsider j = I. n as Instruction of SCM+FSA by A1;
  while>0(a,I) c= while>0(a,I) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A13: dom while>0(a,I) c= dom (while>0(a,I) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
A14: card Mi = card (i ';' J )+ card Goto  (card I1 + 1) by SCMFSA6A:61
    .= card (i ';' J ) + 1 by SCMFSA8A:29
    .= card (Macro i) + card J + 1 by SCMFSA6A:61
    .= 2 + 1 +1 by SCMFSA7B:6,LL
    .= 3+ 1;
  then n+4 >= card Mi by NAT_1:11;
  then
A15: not  (n+4) in dom Mi by SCMFSA6A:15;
T: ProgramPart sI = ProgramPart sK2
by AMI_1:144;
A16: Comput(ProgramPart( sI), sI,k+1) = Following(ProgramPart sI,sK2) by
AMI_1:14
    .= Exec(j,sK2) by A5,T,AMI_1:def 18;
  set f =  (card I +4) .--> goto  0;
  assume
A17: IC Comput(ProgramPart( s1), s1,1+k)=l3 + 4;
  dom f = { (card I + 4)} & n + 4 <> card I + 4 by A2,FUNCOP_1:19,SCMFSA6A:15;
  then
A18: not  (n+4) in dom f by TARSKI:def 1;
A19: dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then
A20:  (n+4) in dom if>0(a,I1,J) by A18,A12,XBOOLE_0:def 3;
A21: if>0(a, I1, J) = Mi ';' I1 ';' Stop SCM+FSA by SCMFSA8B:def 2
    .= Mi ';' J2 by SCMFSA6A:67
    .= Directed Mi +* ProgramPart Relocated(J2, 4) by A14;
  then
A22: dom if>0(a,I1,J) = dom Directed Mi \/ dom ProgramPart Relocated(J2, 4 )
  by FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom ProgramPart Relocated(J2, 4) by
FUNCT_4:105;
  then
A23:  (n+4) in dom ProgramPart Relocated(J2, 4) by A20,A15,XBOOLE_0:def 3
;
Z:  (ProgramPart sK1)/.IC sK1
 = sK1.IC sK1 by AMI_1:150;
  sK1. (n+4) = s1.(n+4) by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)). (n+4)
    by A12,A13,FUNCT_4:14
    .= (if>0(a, I1, J) +* f). (n+4) by A12,SCMFSA6B:7
    .= (Directed Mi +* ProgramPart Relocated(J2, 4)). (n+4) by A18,A12,A19,A21,
FUNCT_4:def 1
    .= (ProgramPart Relocated(J2,4)). (n+4) by A20,A22,A23,FUNCT_4:def 1
    .= IncAddr(Shift(ProgramPart(J2),4),4). (n+4) by SCMFSA_5:2
    .= IncAddr(Shift(J2,4),4). (n+4) by AMI_1:105
    .= IncAddr(j,4) by A10,A11,SCMFSA_4:24;
  then
A24: CurInstr(ProgramPart sK1,sK1) =IncAddr(j,4) by A17,Z,AMI_1:def 16;
  assume
A25: DataPart sK1 = DataPart sK2;
T: ProgramPart s1 = ProgramPart sK1
by AMI_1:144;
  Comput(ProgramPart( s1), s1,1+k+1) = Following(ProgramPart s1,sK1) by
AMI_1:14
    .= Exec(IncAddr(j,4),sK1) by A24,T,AMI_1:def 18;
  hence thesis by A17,A25,A16,SCMFSA6A:41;
end;

theorem Th45:
  for a being Int-Location, I being Program of SCM+FSA, s being
  State of SCM+FSA st I is_closed_on s & I is_halting_on s & IC Comput(
ProgramPart( (s
  +* (while>0(a,I) +* Start-At( 0,SCM+FSA)))), (s
  +* (while>0(a,I) +* Start-At( 0,SCM+FSA))),1 + LifeSpan (s +*
  (I +* Start-At(
 0,SCM+FSA)) ) ) =
IC Comput(ProgramPart( (s +* ( I +* Start-At( 0,SCM+FSA)))), (s +* ( I +*
Start-At( 0,SCM+FSA))),
LifeSpan (s
+* (I +* Start-At( 0,SCM+FSA) ))) + 4
holds CurInstr(ProgramPart Comput(ProgramPart( (s +* (while>0(a
  ,I) +* Start-At( 0,SCM+FSA)))), (s +* (while>0(a
  ,I) +* Start-At( 0,SCM+FSA))),1 + LifeSpan (s +* (I +*
  Start-At( 0,SCM+FSA))) ),
   Comput(ProgramPart( (s +* (while>0(a
  ,I) +* Start-At( 0,SCM+FSA)))), (s +* (while>0(a
  ,I) +* Start-At( 0,SCM+FSA))),1 + LifeSpan (s +* (I +*
  Start-At( 0,SCM+FSA))) )) =
  goto  (card I +4)
proof
  set J3= Goto  0 ';' Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s1 = s +* (while>0(a,I) +* Start-At( 0,SCM+FSA));
  set sI = s +* ( I +* Start-At( 0,SCM+FSA));
  set life=LifeSpan (s +* (I +* Start-At( 0,SCM+FSA)));
  set sK1= Comput(ProgramPart( s1), s1,1+life);
  set sK2= Comput(ProgramPart( sI), sI,life);
  set I1= I ';' Goto  0;
  set i = a >0_goto  (card J + 3);
  reconsider n = IC sK2 as Element of NAT;
  set Mi= i ';' J ';' Goto  (card I1 + 1);
  set J2= I1 ';' Stop SCM+FSA;
  while>0(a,I) c= while>0(a,I) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A1: dom while>0(a,I) c= dom (while>0(a,I) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
  I c= I +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A2: dom I c= dom (I +* Start-At( 0,SCM+FSA)) by GRFUNC_1:8;
  assume
  I is_closed_on s;
  then
A3:  n in dom I by SCMFSA7B:def 7;
  then n < card I by SCMFSA6A:15;
  then
A4: n+4 < card I+ 6 by XREAL_1:10;
Y:  (ProgramPart sK2)/.IC sK2
 = sK2.IC sK2 by AMI_1:150;
  assume
  I is_halting_on s;
  then
A5: ProgramPart sI halts_on sI by SCMFSA7B:def 8;
  CurInstr(ProgramPart sK2,sK2) =sK2. n by Y,AMI_1:def 16
    .=sI. n by AMI_1:54
    .=(I +* Start-At( 0,SCM+FSA)). n by A3,A2,FUNCT_4:14
    .= I. n by A3,SCMFSA6B:7;
  then
A6: I. n = halt SCM+FSA by A5,AMI_1:def 46;
A7: J2= I ';' J3 by SCMFSA6A:67;
  then dom J2 = dom Directed I \/ dom ProgramPart Relocated(J3, card I) by
FUNCT_4:def 1
    .= dom I \/ dom ProgramPart Relocated(J3, card I) by FUNCT_4:105;
  then
A8:  n in dom J2 by A3,XBOOLE_0:def 3;
  then  n + 4 in { il+4 where il is Element of NAT: il in dom J2};
  then
A9:  (n+4) in dom Shift(J2,4) by VALUED_1:def 12;
  then
A10: pi(Shift(J2,4),n+4) =Shift(J2,4).( n +4) by AMI_1:def 47
    .=J2. n by A8,VALUED_1:def 12
    .=(Directed I). n by A3,A7,SCMFSA8A:28
    .=goto  card I by A3,A6,SCMFSA8A:30;
  set f =  (card I +4) .--> goto  0;
  assume
A11: IC sK1 = IC sK2 + 4;
  dom f = { (card I + 4)} & n + 4 <> card I + 4 by A3,FUNCOP_1:19,SCMFSA6A:15;
  then
A12: not  (n+4) in dom f by TARSKI:def 1;
A13: card Mi = card (i ';' J )+ card Goto  (card I1 + 1) by SCMFSA6A:61
    .= card (i ';' J ) + 1 by SCMFSA8A:29
    .= card (Macro i) + card J + 1 by SCMFSA6A:61
    .= 2 + 1 +1 by SCMFSA7B:6,LL
    .= 3+ 1;
  then n+4 >= card Mi by NAT_1:11;
  then
A14: not  (n+4) in dom Mi by SCMFSA6A:15;
  card while>0(a,I) = card I + 6 by Th5;
  then
A15:  (n+4) in dom while>0(a,I) by A4,SCMFSA6A:15;
A16: dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then
A17:  (n+4) in dom if>0(a,I1,J) by A12,A15,XBOOLE_0:def 3;
A18: if>0(a, I1, J) = Mi ';' I1 ';' Stop SCM+FSA by SCMFSA8B:def 2
    .= Mi ';' J2 by SCMFSA6A:67
    .= Directed Mi +* ProgramPart Relocated(J2, 4) by A13;
  then
A19: dom if>0(a,I1,J) = dom Directed Mi \/ dom ProgramPart Relocated(J2, 4 )
  by FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom ProgramPart Relocated(J2, 4) by
FUNCT_4:105;
  then
A20:  (n+4) in dom ProgramPart Relocated(J2, 4) by A17,A14,XBOOLE_0:def 3
;
Z:  (ProgramPart sK1)/.IC sK1
 = sK1.IC sK1 by AMI_1:150;
  sK1. (n+4) = s1.(n+4) by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)). (n+4)
    by A15,A1,FUNCT_4:14
    .= (if>0(a, I1, J) +* f). (n+4) by A15,SCMFSA6B:7
    .= (Directed Mi +* ProgramPart Relocated(J2, 4)). (n+4) by A12,A15,A16,A18,
FUNCT_4:def 1
    .= (ProgramPart Relocated(J2,4)). (n+4) by A17,A19,A20,FUNCT_4:def 1
    .= IncAddr(Shift(ProgramPart(J2),4),4). (n+4) by SCMFSA_5:2
    .= IncAddr(Shift(J2,4),4). (n+4) by AMI_1:105
    .= IncAddr(goto  card I,4) by A9,A10,SCMFSA_4:24
    .= goto  (card I+4) by SCMFSA_4:14;
  hence thesis by A11,Z,AMI_1:def 16;
end;

theorem Th46:
  for a being Int-Location, I being Program of SCM+FSA holds
  while>0(a,I). (card I +4) = goto  0
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set Lc4= (card I + 4 );
  dom f = {Lc4} by FUNCOP_1:19;
  then
A1: Lc4 in dom f by TARSKI:def 1;
  Lc4 in dom while>0(a,I) & dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f
  by Th38,FUNCT_4:def 1;
  hence while>0(a,I).Lc4 = f.Lc4 by A1,FUNCT_4:def 1
    .=goto  0 by FUNCOP_1:87;
end;

theorem Th47:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location st I is_closed_on s & I is_halting_on s & s.a >0
holds IC Comput(ProgramPart( (s +* (while>0(a,I) +* Start-At( 0,SCM+FSA)))), (s
+* (while>0(a,I) +* Start-At( 0,SCM+FSA))),
(LifeSpan (s
+* (I +* Start-At( 0,SCM+FSA))) + 3)) =  0 &
for k being Element of NAT st k
  <= LifeSpan (s +* (I +* Start-At( 0,SCM+FSA))) + 3
  holds IC Comput(ProgramPart( (s +* (
  while>0(a,I) +* Start-At( 0,SCM+FSA)))), (s +* (
  while>0(a,I) +* Start-At( 0,SCM+FSA))),k) in dom while>0(a,I)
proof
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I is_closed_on s;
  set sI = s +* (I +* Start-At( 0,SCM+FSA));
  set s1 = s +* (while>0(a,I) +* Start-At( 0,SCM+FSA));
  defpred P[Nat] means $1 <= LifeSpan sI implies IC Comput(ProgramPart( s1
), s1
,1+$1) = IC Comput(ProgramPart( sI), sI,$1)+ 4 & DataPart Comput(ProgramPart(
s1), s1,1+$1) = DataPart
  Comput(ProgramPart( sI), sI,$1);
  assume
A2: I is_halting_on s;
A3: now
    let k be Element of NAT;
    assume
A4: P[k];
    now
A5:   k + 0 < k + 1 by XREAL_1:8;
      assume
      k + 1 <= LifeSpan sI;
      then k < LifeSpan sI by A5,XXREAL_0:2;
      hence IC Comput(ProgramPart( s1), s1,1+k+1) = IC Comput(ProgramPart( sI),
sI,k+1) + 4 & DataPart
      Comput(ProgramPart( s1), s1,1+k+1) = DataPart Comput(ProgramPart( sI), sI
,k+1) by A1,A2,A4,Th44;
    end;
    hence P[k + 1];
  end;
  reconsider l=LifeSpan sI as Element of NAT;
  set loc4= (card I + 4);
  set i = a >0_goto  4;
  set s2 = Comput(ProgramPart(s1),s1,1);
A6: IC SCM+FSA in dom (while>0(a,I) +* Start-At( 0,SCM+FSA))
by SF_MASTR:65;
A7: IC s1 = s1.IC SCM+FSA by AMI_1:def 15
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)).IC SCM+FSA by A6,FUNCT_4:14
    .=  0 by SF_MASTR:66;
  not a in dom (while>0(a,I) +* Start-At( 0,SCM+FSA)) by SCMFSA6B:12;
  then
A8: s1.a = s.a by FUNCT_4:12;
  assume
A9: s.a > 0;
A10:  0 in dom while>0(a,I) by Th10;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by AMI_1:150;
  while>0(a,I) c= while>0(a,I) +* Start-At( 0,SCM+FSA) by SCMFSA8A:9;
  then
A11: dom while>0(a,I) c= dom (while>0(a,I) +* Start-At( 0,SCM+FSA))
by GRFUNC_1:8;
  then s1. 0 = (while>0(a,I) +* Start-At( 0,SCM+FSA)). 0
  by A10,FUNCT_4:14
    .= while>0(a,I). 0 by A10,SCMFSA6B:7
    .= i by Th11;
  then
A12: CurInstr(ProgramPart s1,s1) = i by A7,Y,AMI_1:def 16;
A13: Comput(ProgramPart(s1),s1,0+1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,0)
)
 by AMI_1:14
    .= Following(ProgramPart s1,s1) by AMI_1:13
    .= Exec(i,s1) by A12,AMI_1:def 18;
  then ( for c holds s2.c = s1.c)& for f holds s2.f = s1.f by SCMFSA_2:97;
  then
A14: DataPart s2 = DataPart s1 by SCMFSA6A:38
    .= DataPart s by SCMFSA8A:11
    .= DataPart sI by SCMFSA8A:11;
A15: IC s2 = s2.IC SCM+FSA by AMI_1:def 15
    .=  4 by A9,A13,A8,SCMFSA_2:97;
A16: P[ 0]
  proof
    assume
    0 <= LifeSpan sI;
A17: IC SCM+FSA in dom (I +* Start-At( 0,SCM+FSA)) by SF_MASTR:65;
    IC Comput(ProgramPart( sI), sI,0) = IC sI by AMI_1:13
      .= sI.IC SCM+FSA by AMI_1:def 15
      .= (I +* Start-At( 0,SCM+FSA)).IC SCM+FSA by A17,FUNCT_4:14
      .=  0 by SF_MASTR:66;
    hence thesis by A15,A14,AMI_1:13;
  end;
A18: for k being Element of NAT holds P[k] from NAT_1:sch 1(A16,A3);
  set s4= Comput(ProgramPart( s1), s1,1+LifeSpan sI+1+1);
  set s3= Comput(ProgramPart( s1), s1,1+LifeSpan sI+1);
A19: loc4 in dom while>0(a,I) by Th38;
  set s2= Comput(ProgramPart( s1), s1,1+LifeSpan sI);
  P[l] by A18;
  then
A20: CurInstr(ProgramPart s2,s2) = goto loc4 by A1,A2,Th45;
T: ProgramPart s1 = ProgramPart s2
by AMI_1:144;
A21: s3 = Following(ProgramPart s1,s2) by AMI_1:14
    .= Exec(goto loc4,s2) by A20,T,AMI_1:def 18;
A22: IC s3 = s3.IC SCM+FSA by AMI_1:def 15
    .= loc4 by A21,SCMFSA_2:95;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
  s3.loc4 = s1.loc4 by AMI_1:54
    .= (while>0(a,I) +* Start-At( 0,SCM+FSA)).loc4 by A11,A19,FUNCT_4:14
    .= while>0(a,I).loc4 by A19,SCMFSA6B:7
    .= goto  0 by Th46;
  then
A23: CurInstr(ProgramPart s3,s3) = goto  0 by A22,Y,AMI_1:def 16;
T: ProgramPart s1 = ProgramPart s3
by AMI_1:144;
A24: s4 = Following(ProgramPart s1,s3) by AMI_1:14
    .= Exec(goto  0,s3) by A23,T,AMI_1:def 18;
A25: IC s4 = s4.IC SCM+FSA by AMI_1:def 15
    .=  0 by A24,SCMFSA_2:95;
  hence IC Comput(ProgramPart( s1), s1,LifeSpan sI+3) =  0;
A26: LifeSpan sI+1+1+1 =LifeSpan sI+(2+1);
A27: now
    let k be Element of NAT;
    assume
A28: k <= LifeSpan sI+3;
    assume
    k<>0;
    then consider n being Nat such that
A29: k = n+ 1 by NAT_1:6;
    k<=LifeSpan sI+1 or k >= LifeSpan sI+1+1 by NAT_1:13;
    then
A30: k
<=LifeSpan sI+1 or k = LifeSpan sI+1+1 or k > LifeSpan sI+1+1 by XXREAL_0:1;
    reconsider n as Element of NAT by ORDINAL1:def 13;
    per cases by A26,A30,NAT_1:13;
    suppose
      k<=LifeSpan sI+1;
      then n <= LifeSpan sI by A29,XREAL_1:8;
      then
A31:  IC Comput(ProgramPart(s1),s1,1+n) = IC Comput(ProgramPart( sI), sI,n) + 4
by A18;
      reconsider m = IC Comput(ProgramPart( sI), sI,n) as Element of NAT;
       m in dom I by A1,SCMFSA7B:def 7;
      then m < card I by SCMFSA6A:15;
      then
A32:  m+4 < card I+ 6 by XREAL_1:10;
      card while>0(a,I) = card I + 6 by Th5;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while>0(a,I) by A29,A31,A32,
SCMFSA6A:15
;
    end;
    suppose
      k=LifeSpan sI+1+1;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while>0(a,I) by A22,Th38;
    end;
    suppose
      k >= LifeSpan sI+3;
      then k = LifeSpan sI+3 by A28,XXREAL_0:1;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while>0(a,I) by A25,Th10;
    end;
  end;
  now
    let k be Element of NAT;
    assume
A33: k <= LifeSpan sI+3;
    per cases;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while>0(a,I) by A10,A7,
AMI_1:13;
    end;
    suppose
      k <>0;
      hence IC Comput(ProgramPart(s1),s1,k) in dom while>0(a,I) by A27,A33;
    end;
  end;
  hence thesis;
end;
set sl0= Start-At( 0,SCM+FSA);

reserve s for State of SCM+FSA,
  I for Program of SCM+FSA,
  a for read-write
  Int-Location;

definition
  let s,I,a;
  deffunc U(Nat,Element of product the Object-Kind of SCM+FSA) = Comput(
ProgramPart(
  ($2 +* (while>0(a,I) +* sl0))),
  ($2 +* (while>0(a,I) +* sl0)), (LifeSpan ($2 +* (I +* sl0)) + 3));
  deffunc V(Nat,Element of product the Object-Kind of SCM+FSA) =
  down Comput(ProgramPart(
  ($2 +* (while>0(a,I) +* sl0))),
  ($2 +* (while>0(a,I) +* sl0)), (LifeSpan ($2 +* (I +* sl0)) + 3));
  func StepWhile>0(a,I,s) -> Function of NAT,product the Object-Kind of
  SCM+FSA means
  :Def5:
  it.0 = s & for i being Nat holds it.(i+1)= Comput(ProgramPart( (
  it.i +* (while>0(a,I) +*(Start-At( 0,SCM+FSA))))), (
  it.i +* (while>0(a,I) +*(Start-At( 0,SCM+FSA)))),
  (LifeSpan (it.i +* (I +* (
  Start-At( 0,SCM+FSA)))) + 3));
  existence
  proof
   reconsider ss=s as
    Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
    consider f being Function of NAT,product the Object-Kind of SCM+FSA
    such that
W1:  f.0 = ss and
W2:  for i being Nat holds f.(i+1)= V(i,f.i) from NAT_1:sch 12;
   take f;
   thus f.0 = s by W1;
   let i be Nat;
    f.(i+1)= V(i,f.i) by W2;
   hence thesis;
  end;
  uniqueness
  proof
    let F1,F2 be Function of NAT,product the Object-Kind of SCM+FSA such that
B1: F1.0 = s and
B2: for i being Nat holds F1.(i+1)= U(i,F1.i) and
B3: F2.0 = s and
B4: for i being Nat holds F2.(i+1)= U(i,F2.i);
   reconsider s as Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
A1: F1.0 = s by B1;
A2: for i being Nat holds F1.(i+1)= V(i,F1.i) by B2;
A3: F2.0 = s by B3;
A4: for i being Nat holds F2.(i+1)= V(i,F2.i) by B4;
   F1 = F2 from NAT_1:sch 16(A1,A2,A3,A4);
  hence thesis;
  end;
end;

canceled 2;

theorem Th50:
  StepWhile>0(a,I,s).(k+1)=StepWhile>0(a,I,StepWhile>0(a,I,s).k).1
proof
  set sk=StepWhile>0(a,I,s).k;
  set sk0=StepWhile>0(a,I,sk).0;
  sk0=sk by Def5;
  hence
  StepWhile>0(a,I,s).(k+1) = Comput(ProgramPart( (sk0 +*(while>0(a,I) +* sl0))
), (sk0 +*(while>0(a,I) +* sl0)) ,
  (LifeSpan (sk0 +* (I +* sl0)) + 3)) by Def5
    .=StepWhile>0(a,I,sk).(0+1) by Def5
    .=StepWhile>0(a,I,sk).1;
end;

theorem Th51:
  for I being Program of SCM+FSA,a being read-write Int-Location,
  s being State of SCM+FSA holds StepWhile>0(a,I,s).(0+1)= Comput(ProgramPart(
(s +* (
while>0(a,I) +* (Start-At( 0,SCM+FSA))))), (s +* (
while>0(a,I) +* (Start-At( 0,SCM+FSA)))), (LifeSpan (s+* (I +*
(Start-At( 0,SCM+FSA))
  )) + 3))
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA;
X: StepWhile>0(a,I,s).0 = s by Def5;
  thus StepWhile>0(a,I,s).(0+1)= Comput(ProgramPart( (StepWhile>0(a,I,s).0 +* (
  while>0(a,I) +* sl0))), (StepWhile>0(a,I,s).0 +* (
  while>0(a,I) +* sl0)),LifeSpan (StepWhile>0(a,I,s).0 +* (I +* sl0)) + 3) by
Def5
    .= Comput(ProgramPart( (s +* (while>0(a,I) +* sl0))), (s +* (while>0(a,I)
+* sl0)), (LifeSpan (StepWhile>0(a,I
  ,s).0+* (I +* sl0)) + 3)) by X
    .= Comput(ProgramPart( (s +* (while>0(a,I) +* sl0))), (s +* (while>0(a,I)
+* sl0)), (LifeSpan (s+* (I +* sl0))
  + 3)) by Def5;
end;

theorem Th52:
  for I being Program of SCM+FSA,a being read-write Int-Location,
s being State of SCM+FSA,k,n being Element of NAT st IC StepWhile>0(a,I,s).k =
   0 & StepWhile>0(a,I,s).k= Comput(ProgramPart( (s +* (while>0(a,I) +*
  Start-At(
 0,SCM+FSA)))), (s +* (while>0(a,I) +*
  Start-At(
 0,SCM+FSA))),n)
 holds StepWhile>0(a,I,s).k = StepWhile>0(a,I,s).k +* (while>0(a,I
)+* Start-At( 0,SCM+FSA)) & StepWhile>0(a,I,s).(k+1)=
Comput(ProgramPart( (s +* (while>0(
  a,I) +* Start-At( 0,SCM+FSA)))), (s +* (while>0(
  a,I) +* Start-At( 0,SCM+FSA))), (n +(LifeSpan (StepWhile>0(a,I,s).k
   +* (I +*
  Start-At( 0,SCM+FSA))) + 3)))
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA,k,n be Element of NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  set s1 = s +* (while>0(a,I) +* Start-At( 0,SCM+FSA));
  set sk=StepWhile>0(a,I,s).k;
  set s2=sk +* (while>0(a,I)+* sl0);
  assume
A1: IC sk = 0;
A2: IC SCM+FSA in dom (while>0(a,I) +* sl0 ) by SF_MASTR:65;
  assume
A3: sk = Comput(ProgramPart( s1), s1,n);
  then sk | NAT =s1 | NAT by AMI_1:123;
  then
A4: DataPart s2 = DataPart sk & s2 | NAT = sk | NAT by FUNCT_4:100,SCMFSA8A:11;
T: ProgramPart s1 = ProgramPart sk
by A3,AMI_1:144;
  IC s2 = s2.IC SCM+FSA by AMI_1:def 15
    .= (while>0(a,I) +* sl0).IC SCM+FSA by A2,FUNCT_4:14
    .= IC sk by A1,SF_MASTR:66;
  hence s2=sk by A4,Th29;
  hence
  StepWhile>0(a,I,s).(k+1)= Comput(ProgramPart( s1), sk,LifeSpan (sk +* (I +*
sl0)) +
  3) by Def5,T
    .= Comput(ProgramPart( s1), s1,n +(LifeSpan (sk +* (I +* sl0)) + 3)) by A3,
AMI_1:51;
end;

theorem Th53:
  for I being Program of SCM+FSA,a being read-write Int-Location,
s being State of SCM+FSA st (for k being Nat holds I is_closed_on StepWhile>0(a
  ,I,s).k & I is_halting_on StepWhile>0(a,I,s).k) & ex f being Function of
  product the Object-Kind of SCM+FSA,NAT st (for k being Nat holds (f.(
StepWhile>0(a,I,s).(k+1)) < f.(StepWhile>0(a,I,s).k) or f.(StepWhile>0(a,I,s).k
  ) = 0) & ( f.(StepWhile>0(a,I,s).k)=0 iff (StepWhile>0(a,I,s).k).a <= 0 ) )
  holds while>0(a,I) is_halting_on s & while>0(a,I) is_closed_on s
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  assume
A1: for k being Nat holds I is_closed_on StepWhile>0(a,I,s).k & I
  is_halting_on StepWhile>0(a,I,s).k;
A2: IC SCM+FSA in dom (while>0(a,I) +* sl0 ) by SF_MASTR:65;
  set s1 = s +* (while>0(a,I) +* Start-At( 0,SCM+FSA));
  given f being Function of product the Object-Kind of SCM+FSA,NAT such that
A3: for k being Nat holds (f.(StepWhile>0(a,I,s).(k+1)) < f.(StepWhile>0
(a,I,s).k) or f.(StepWhile>0(a,I,s).k) = 0) & ( f.(StepWhile>0(a,I,s).k)=0 iff
  (StepWhile>0(a,I,s).k).a <= 0 );
  deffunc F(Nat) = f.(StepWhile>0(a,I,s).$1);
A4: for k being Nat holds F(k+1) < F(k) or F(k) = 0 by A3;
  consider m being Nat such that
A5: F(m)=0 and
A6: for n being Nat st F(n) =0 holds m <= n from NAT_1:sch 17(A4);
  defpred P[Nat] means $1+1 <= m implies ex k st StepWhile>0(a,I,s)
  .($1+1)= Comput(ProgramPart( s1), s1,k);
A7: now
    let k be Element of NAT;
    assume
A8: P[k];
    now
      set sk1=StepWhile>0(a,I,s).(k+1);
      set sk=StepWhile>0(a,I,s).k;
      assume
A9:   (k+1)+ 1 <= m;
      k + 0 < k+ (1+ 1) by XREAL_1:8;
      then k < m by A9,XXREAL_0:2;
      then F(k) <> 0 by A6;
      then
A10:  sk.a > 0 by A3;
A11:  I is_halting_on sk by A1;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
      then consider n being Element of NAT such that
A12:  sk1 = Comput(ProgramPart( s1), s1,n) by A8,A9,XXREAL_0:2;
      take m=n +(LifeSpan (sk1 +* (I +* sl0)) + 3);
      sk1= Comput(ProgramPart( (sk +* (while>0(a,I)+* sl0))), (sk +* (while>0(a
,I)+* sl0)), (LifeSpan (sk +* (I
      +* sl0)) + 3)) & I is_closed_on sk by A1,Def5;
      then IC sk1 = 0 by A11,A10,Th47;
      hence StepWhile>0(a,I,s).((k+1)+1)= Comput(ProgramPart( s1), s1,m) by A12
,Th52;
    end;
    hence P[k+1];
  end;
A13: P[ 0]
  proof
    assume
    0+1 <= m;
    take n=(LifeSpan (s+* (I +* sl0)) + 3);
    thus thesis by Th51;
  end;
A14: for k being Element of NAT holds P[k] from NAT_1:sch 1(A13,A7);
  now
    per cases;
    suppose
      m=0;
      then (StepWhile>0(a,I,s).0).a <= 0 by A3,A5;
      then s.a <= 0 by Def5;
      hence thesis by Th43;
    end;
    suppose
A15:  m<>0;
      set p=(LifeSpan (s+* (I +* sl0)) + 3);
      set sm=StepWhile>0(a,I,s).m;
      set sm1=sm +* (while>0(a,I)+* sl0);
      consider i being Nat such that
A16:  m=i+1 by A15,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      m=i+1 by A16;
      then consider n being Element of NAT such that
A17:  sm = Comput(ProgramPart( s1), s1,n) by A14;
      set si=StepWhile>0(a,I,s).i;
      i < m by A16,NAT_1:13;
      then F(i) <> 0 by A6;
      then
A18:  si.a > 0 by A3;
A19:  I is_closed_on si & I is_halting_on si by A1;
      sm | NAT =s1 | NAT by A17,AMI_1:123;
      then
A20:  DataPart sm1 = DataPart sm & sm1 | NAT = sm | NAT by FUNCT_4:100
,SCMFSA8A:11;
      sm= Comput(ProgramPart( (si +* (while>0(a,I)+* sl0))), (si +* (while>0(a,
I)+* sl0)), (LifeSpan (si +* (I
      +* sl0)) + 3)) by A16,Def5;
      then
A21:  IC sm = 0 by A19,A18,Th47;
      IC sm1 = sm1.IC SCM+FSA by AMI_1:def 15
        .= (while>0(a,I) +* sl0).IC SCM+FSA by A2,FUNCT_4:14
        .= IC sm by A21,SF_MASTR:66;
      then
A22:  sm1=sm by A20,Th29;
A23:  sm.a <= 0 by A3,A5;
      then while>0(a,I) is_halting_on sm by Th43;
      then ProgramPart sm1 halts_on sm1 by SCMFSA7B:def 8;
      then consider j being Element of NAT such that
A24:  CurInstr(ProgramPart Comput(ProgramPart(sm),sm,j),Comput(ProgramPart(sm),
sm,j))
 = halt SCM+FSA by A22,AMI_1:146;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),
s1,n)
by AMI_1:144;
x: Comput(ProgramPart(s1),s1,n+j)
 = Comput(ProgramPart(s1),Comput(ProgramPart(s1),s1,n),j) by AMI_1:51;
      CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n+j),Comput(ProgramPart(s1
),s1,n+j))
       = halt SCM+FSA by A17,A24,x,T;
      then ProgramPart s1 halts_on s1 by AMI_1:146;
      hence while>0(a,I) is_halting_on s by SCMFSA7B:def 8;
      now
        let q be Element of NAT;
A25:    0<m by A15;
        per cases;
        suppose
A26:      q <= p;
A27:      StepWhile>0(a,I,s).0=s by Def5;
          then
A28:      I is_closed_on s & I is_halting_on s by A1;
          F(0) <> 0 by A6,A25;
          then s.a > 0 by A3,A27;
          hence IC Comput(ProgramPart(s1),s1,q) in dom while>0(a,I) by A26,A28
,Th47;
        end;
        suppose
A29:      q > p;
A30:      now
            take k=p;
            thus StepWhile>0(a,I,s).1= Comput(ProgramPart( s1), s1,k) & k <= q
by A29,Th51;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 & (ex k st StepWhile>0(a,I,s).$1
          = Comput(ProgramPart( s1), s1,k) & k <= q);
A31:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A25,XREAL_1:8;
          then 1 <= m by NAT_1:13;
          then
A32:      ex t be Nat st P2[t] by A30;
          consider t be Nat such that
A33:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A31,A32);
          reconsider t as Element of NAT by ORDINAL1:def 13;
          now
            per cases;
            suppose
              t=m;
              then consider r being Element of NAT such that
A34:          sm= Comput(ProgramPart( s1), s1,r) and
A35:          r <= q by A33;
              consider x being Nat such that
A36:          q = r+x by A35,NAT_1:10;
A37:          while>0(a,I) is_closed_on sm by A23,Th43;
              reconsider x as Element of NAT by ORDINAL1:def 13;
T: ProgramPart s1 = ProgramPart sm1
by A22,A34,AMI_1:144;
              Comput(ProgramPart(s1),s1,q) = Comput(ProgramPart( s1), sm1,x)
by A22,A34,A36,AMI_1:51;
              hence IC Comput(ProgramPart(s1),s1,q) in dom while>0(a,I) by A37
,T,SCMFSA7B:def 7;
            end;
            suppose
A38:          t<>m;
              set Dt=StepWhile>0(a,I,s).t;
A39:          t < m by A33,A38,XXREAL_0:1;
              then F(t) <> 0 by A6;
              then
A40:          Dt.a > 0 by A3;
              consider z being Element of NAT such that
A41:          StepWhile>0(a,I,s).t= Comput(ProgramPart( s1), s1,z) and
A42:          z <= q by A33;
              set z2=z +(LifeSpan (Dt +* (I +* sl0)) + 3);
              consider w being Nat such that
A43:          q = z+w by A42,NAT_1:10;
A44:          I is_closed_on Dt & I is_halting_on Dt by A1;
              consider y being Nat such that
A45:          t=y+1 by A33,NAT_1:6;
              reconsider y as Element of NAT by ORDINAL1:def 13;
              set Dy=StepWhile>0(a,I,s).y;
              y+ 0 < t by A45,XREAL_1:8;
              then y < m by A33,XXREAL_0:2;
              then F(y) <> 0 by A6;
              then
A46:          Dy.a > 0 by A3;
A47:          I is_closed_on Dy & I is_halting_on Dy by A1;
              reconsider w as Element of NAT by ORDINAL1:def 13;
              Dt= Comput(ProgramPart( (Dy +* (while>0(a,I)+* sl0))), (Dy +* (
while>0(a,I)+* sl0)), (LifeSpan (
              Dy +* (I +* sl0)) + 3)) by A45,Def5;
              then
A48:          IC Dt = 0 by A47,A46,Th47;
              now
                assume
A49:            z2 <= q;
A50:            now
                  take k=z2;
                  thus StepWhile>0(a,I,s).(t+1)= Comput(ProgramPart( s1), s1,k)
& k <= q
by A41,A48,A49,Th52;
                end;
                t+1 <= m by A39,NAT_1:13;
                hence contradiction by A33,A50,XREAL_1:31;
              end;
              then
A51:          w < LifeSpan (Dt +* (I +* sl0)) + 3 by A43,XREAL_1:8;
X: Dt +* (while>0(a,I)+* sl0) = Dt by A41,A48,Th52;
T: ProgramPart s1 = ProgramPart Dt
by A41,A43,AMI_1:144;
              Comput(ProgramPart(s1),s1,q) = Comput(ProgramPart(s1), Dt,w) by
A41,A43,AMI_1:51
                .= Comput(ProgramPart( (Dt +* (while>0(a,I)+* sl0))), (Dt +* (
while>0(a,I)+* sl0)),w) by X,T
;
              hence IC Comput(ProgramPart(s1),s1,q) in dom while>0(a,I) by A51
,A44,A40,Th47;
            end;
          end;
          hence IC Comput(ProgramPart(s1),s1,q) in dom while>0(a,I);
        end;
      end;
      hence while>0(a,I) is_closed_on s by SCMFSA7B:def 7;
    end;
  end;
  hence thesis;
end;

theorem Th54:
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location, s being State of SCM+FSA st ex f being Function of product the
Object-Kind of SCM+FSA,NAT st (for k being Nat holds (f.(StepWhile>0(a,I,s).(k+
  1)) < f.(StepWhile>0(a,I,s).k) or f.(StepWhile>0(a,I,s).k) = 0) & ( f.(
StepWhile>0(a,I,s).k)=0 iff (StepWhile>0(a,I,s).k).a <= 0 ) ) holds while>0(a,I
  ) is_halting_on s & while>0(a,I) is_closed_on s
proof
  let I be parahalting Program of SCM+FSA,a be read-write Int-Location,s be
  State of SCM+FSA;
A1: ( for k being Nat holds I is_closed_on StepWhile>0(a,I,s).k)& for k
  being Nat holds I is_halting_on StepWhile>0(a,I,s).k by SCMFSA7B:24,25;
  assume
  ex f being Function of product the Object-Kind of SCM+FSA,NAT st for
k being Nat holds (f.(StepWhile>0(a,I,s).(k+1)) < f.(StepWhile>0(a,I,s).k) or f
.(StepWhile>0(a,I,s).k) = 0) & ( f.(StepWhile>0(a,I,s).k)=0 iff (StepWhile>0(a,
  I,s).k).a <= 0 );
  hence thesis by A1,Th53;
end;

theorem
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location st ex f being Function of product the Object-Kind of SCM+FSA,NAT
st (for s being State of SCM+FSA holds (f.(StepWhile>0(a,I,s).1) < f.s or f.s =
  0) & ( f.s =0 iff s.a <= 0 )) holds while>0(a,I) is parahalting
proof
  let I be parahalting Program of SCM+FSA,a be read-write Int-Location;
  given f being Function of product the Object-Kind of SCM+FSA,NAT such that
A1: for s being State of SCM+FSA holds (f.(StepWhile>0(a,I,s).1) < f.s
  or f.s = 0) & ( f.s =0 iff s.a <= 0 );
  now
    let t be State of SCM+FSA;
    now
      let k be Nat;
A2:   k in NAT by ORDINAL1:def 13;
      f.(StepWhile>0(a,I,StepWhile>0(a,I,t).k).1) < f.(StepWhile>0(a,I,t).
      k) or f.(StepWhile>0(a,I,t).k) = 0 by A1;
      hence (f.(StepWhile>0(a,I,t).(k+1)) < f.(StepWhile>0(a,I,t).k) or f.(
StepWhile>0(a,I,t).k) = 0) & ( f.(StepWhile>0(a,I,t).k)=0 iff (StepWhile>0(a,I,
      t).k).a <= 0 ) by A1,A2,Th50;
    end;
    hence while>0(a,I) is_halting_on t by Th54;
  end;
  hence thesis by SCMFSA7B:25;
end;

registration
  let I,J be good Program of SCM+FSA,a be Int-Location;
  cluster if>0(a,I,J) -> good;
  coherence
  proof
    set i = a >0_goto  (card J + 3);
    reconsider Mi=Macro i as good Program of SCM+FSA by Th36,SCMFSA7B:19;
    if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I ';' Stop
    SCM+FSA by SCMFSA8B:def 2
      .= Mi ';' J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
    hence thesis;
  end;
end;

registration
  let I be good Program of SCM+FSA,a be Int-Location;
  cluster while>0(a,I) -> good;
  correctness
  proof
    set F=if>0(a, I ';' Goto  0, Stop SCM+FSA);
    set J= (card I +4) .--> goto  0;
    J does_not_destroy intloc 0 & F does_not_destroy intloc 0 by Th35,
SCMFSA7B:def 5;
    then while>0(a,I) does_not_destroy intloc 0 by SCMFSA8A:25;
    hence thesis by SCMFSA7B:def 5;
  end;
end;

