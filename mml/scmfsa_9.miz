:: While Macro Instructions of SCM+FSA
::  by Jing-Chao Chen
::
:: Received December 10, 1997
:: Copyright (c) 1997-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, AMI_1, SCMFSA_2, CARD_1, SCMFSA8B, TURING_1, SCMFSA8A,
      AMISTD_2, ARYTM_3, SUBSET_1, FUNCT_4, FUNCOP_1, AMI_3, RELAT_1, TARSKI,
      XBOOLE_0, CAT_1, NAT_1, SCMFSA6A, FUNCT_1, XXREAL_0, VALUED_1, CARD_3,
      ARYTM_1, FSM_1, SF_MASTR, SCMFSA7B, UNIALG_2, CIRCUIT2, GRAPHSP,
      SCMFSA6B, SCMFSA_9, PBOOLE, ORDINAL1, PARTFUN1, EXTPRO_1, RELOC,
      SCMFSA6C, COMPOS_1, MEMSTR_0, SCMPDS_4;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, RELAT_1,
      FUNCT_1, FUNCT_2, PARTFUN1, AFINSQ_1, FUNCOP_1, FUNCT_4, CARD_3,
      MEMSTR_0, COMPOS_0,
      COMPOS_1, EXTPRO_1, VALUED_1, PBOOLE, ORDINAL1, NAT_1,
      AMISTD_1, AMISTD_2, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA7B,
      SCMFSA8A, SCMFSA8B, XXREAL_0, SCMFSA_M;
 constructors XXREAL_0, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA8A, FUNCT_4,
      SCMFSA8B, AMISTD_2, RELSET_1, PRE_POLY, PBOOLE, SCMFSA7B, DOMAIN_1,
      AMISTD_1, MEMSTR_0, SCMFSA_M;
 registrations SETFAM_1, FUNCT_1, RELSET_1, NUMBERS, XREAL_0, NAT_1, INT_1,
      CARD_3, SCMFSA_2, SF_MASTR, SCMFSA6B, SCMFSA7B, SCMFSA8A, ORDINAL1,
      XBOOLE_0, FINSET_1, VALUED_1, FUNCT_4, FUNCT_2, XXREAL_0, VALUED_0,
      AFINSQ_1, FUNCOP_1, SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1, PBOOLE,
      RELAT_1, MEMSTR_0, FINSEQ_1, AMI_3, COMPOS_0, SCMFSA_M;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions SCMFSA6A, FUNCOP_1, PBOOLE, AFINSQ_1, COMPOS_1, EXTPRO_1,
      AMISTD_2, MEMSTR_0, CARD_3, COMPOS_0, SCMFSA_M;
 theorems TARSKI, NAT_1, FUNCT_1, FUNCT_4, SCMFSA_2, SCMFSA_4, SCMFSA6A,
      GRFUNC_1, SCMFSA6B, SCMFSA7B, SCMFSA8A, SCMFSA8B, ZFMISC_1, XBOOLE_0,
      XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0, VALUED_1, FUNCOP_1, PBOOLE,
      AFINSQ_1, PARTFUN1, RELAT_1, COMPOS_1, EXTPRO_1, MEMSTR_0, CARD_3,
      COMPOS_0, SCMFSA_M;
 schemes NAT_1;

begin

reserve P,Q for Instruction-Sequence of SCM+FSA;

Lm1: card Stop SCM+FSA = 1 by AFINSQ_1:33;
Lm2: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:34;
Lm3: 0 in dom Stop SCM+FSA by COMPOS_1:3;

set SA0= Start-At(0,SCM+FSA);

theorem Th1:
  for I being Program of SCM+FSA, a being Int-Location holds card
  if=0(a, I ";" Goto  0, Stop SCM+FSA) = card I + 6
proof
  let I be Program of SCM+FSA, a be Int-Location;
  thus card if=0(a, I ";" Goto  0, Stop SCM+FSA) = card (I ";" Goto
   0) + 1 +4 by Lm1,SCMFSA8B:11
    .= card I + card Goto  0 + 1+4 by SCMFSA6A:21
    .= card I + 1+1+4 by SCMFSA8A:15
    .= card I + 6;
end;

theorem Th2:
  for I being Program of SCM+FSA, a being Int-Location holds card
  if>0(a, I ";" Goto  0, Stop SCM+FSA) = card I + 6
proof
  let I be Program of SCM+FSA, a be Int-Location;
  thus card if>0(a, I ";" Goto  0, Stop SCM+FSA) = card (I ";" Goto
   0) + 1 +4 by Lm1,SCMFSA8B:12
    .= card I + card Goto  0 + 1+4 by SCMFSA6A:21
    .= card I + 1+1+4 by SCMFSA8A:15
    .= card I + 6;
end;

:: WHILE  Statement

reserve m, n for Element of NAT;

definition
  let a be Int-Location;
  let I be Program of SCM+FSA;
  func while=0(a,I) -> Program of SCM+FSA equals
  if=0(a, I ";" Goto  0,
  Stop SCM+FSA) +* (  (card I +4) .--> goto  0 );
  correctness
  proof
    set C = if=0(a, I ";" Goto  0, Stop SCM+FSA);
    set i =  (card I +4) .--> goto  0;
    set P = C +* i;
    card C = card I + 6 & card I + 4 < card I + 6 by Th1,XREAL_1:6;
    then  (card I + 4) in dom C by AFINSQ_1:66;
    then
A1: { (card I + 4)} c= dom C by ZFMISC_1:31;
A2: dom(P) = dom C \/ dom i by FUNCT_4:def 1
      .= dom C \/ { (card I + 4)} by FUNCOP_1:13
      .= dom C by A1,XBOOLE_1:12;
    P is initial
    proof
      let m,n be Nat;
      thus thesis by A2,AFINSQ_1:def 12;
    end;
    hence thesis;
  end;
  func while>0(a,I) -> Program of SCM+FSA equals
  if>0(a, I ";" Goto  0,
  Stop SCM+FSA) +* (  (card I +4) .--> goto  0 );
  correctness
  proof
    set C = if>0(a, I ";" Goto  0, Stop SCM+FSA);
    set i =  (card I +4) .--> goto  0;
    set P = C +* i;
    card C = card I + 6 & card I + 4 < card I + 6 by Th2,XREAL_1:6;
    then  (card I + 4) in dom C by AFINSQ_1:66;
    then
A3: { (card I + 4)} c= dom C by ZFMISC_1:31;
A4: dom(P) = dom C \/ dom i by FUNCT_4:def 1
      .= dom C \/ { (card I + 4)} by FUNCOP_1:13
      .= dom C by A3,XBOOLE_1:12;
    P is initial
    proof
      let m,n be Nat;
      thus thesis by A4,AFINSQ_1:def 12;
    end;
    hence thesis;
  end;
end;

theorem Th3:
  for I being Program of SCM+FSA, a being Int-Location holds card
  if=0(a,Stop SCM+FSA,if>0(a,Stop SCM+FSA,I ";" Goto  0)) = card I + 11
proof
  let I be Program of SCM+FSA, a be Int-Location;
  thus card if=0(a,Stop SCM+FSA,if>0(a,Stop SCM+FSA,I ";" Goto  0)) = 1
+ card if>0(a,Stop SCM+FSA,I ";" Goto  0) +4 by Lm1,SCMFSA8B:11
    .= card (I ";" Goto  0) + 1+ 4 + 1+4 by Lm1,SCMFSA8B:12
    .= card I + card Goto  0 +1+ 4 + 1+4 by SCMFSA6A:21
    .= card I + 1 + 1 +4 + 1 + 4 by SCMFSA8A:15
    .= card I + 11;
end;

definition
  let a be Int-Location;
  let I be Program of SCM+FSA;
  func while<0(a,I) -> Program of SCM+FSA equals
  if=0(a,Stop SCM+FSA,if>0(a,
Stop SCM+FSA,I ";" Goto  0)) +* (  (card I +4) .--> goto  0 )
  ;
  correctness
  proof
    set C = if=0(a,Stop SCM+FSA,if>0(a,Stop SCM+FSA,I ";" Goto  0));
    set i =  (card I +4) .--> goto  0;
    set P = C +* i;
    card C = card I + 11 & card I + 4 < card I + 11 by Th3,XREAL_1:6;
    then  (card I + 4) in dom C by AFINSQ_1:66;
    then
A1: { (card I + 4)} c= dom C by ZFMISC_1:31;
A2: dom(P) = dom C \/ dom i by FUNCT_4:def 1
      .= dom C \/ { (card I + 4)} by FUNCOP_1:13
      .= dom C by A1,XBOOLE_1:12;
    P is initial
    proof
      let m,n be Nat;
      thus thesis by A2,AFINSQ_1:def 12;
    end;
    hence thesis;
  end;
end;

theorem Th4:
  for I being Program of SCM+FSA, a being Int-Location holds card
  while=0(a,I) = card I + 6
proof
  let I be Program of SCM+FSA, a be Int-Location;
  set i =  (card I +4) .--> goto  0;
  set C = if=0(a, I ";" Goto  0, Stop SCM+FSA);
  set P = C +* i;
A1: card C = card I + 6 by Th1;
  card I + 4 < card I + 6 by XREAL_1:6;
  then  (card I + 4) in dom C by A1,AFINSQ_1:66;
  then
A2: { (card I + 4)} c= dom C by ZFMISC_1:31;
  dom(P) = dom C \/ dom i by FUNCT_4:def 1
    .= dom C \/ { (card I + 4)} by FUNCOP_1:13
    .= dom C by A2,XBOOLE_1:12;
  hence card while=0(a,I) = card I + 6 by A1;
end;

theorem Th5:
  for I being Program of SCM+FSA, a being Int-Location holds card
  while>0(a,I) = card I + 6
proof
  let I be Program of SCM+FSA, a be Int-Location;
  set i =  (card I +4) .--> goto  0;
  set C = if>0(a, I ";" Goto  0, Stop SCM+FSA);
  set P = C +* i;
A1: card C = card I + 6 by Th2;
  card I + 4 < card I + 6 by XREAL_1:6;
  then  (card I + 4) in dom C by A1,AFINSQ_1:66;
  then
A2: { (card I + 4)} c= dom C by ZFMISC_1:31;
  dom(P) = dom C \/ dom i by FUNCT_4:def 1
    .= dom C \/ { (card I + 4)} by FUNCOP_1:13
    .= dom C by A2,XBOOLE_1:12;
  hence card while>0(a,I) = card I + 6 by A1;
end;

theorem
  for I being Program of SCM+FSA, a being Int-Location holds card
  while<0(a,I) = card I + 11
proof
  let I be Program of SCM+FSA, a be Int-Location;
  set i =  (card I +4) .--> goto  0;
  set C = if=0(a,Stop SCM+FSA,if>0(a,Stop SCM+FSA,I ";" Goto  0));
  set P = C +* i;
A1: card C = card I + 11 by Th3;
  card I + 4 < card I + 11 by XREAL_1:6;
  then  (card I + 4) in dom C by A1,AFINSQ_1:66;
  then
A2: { (card I + 4)} c= dom C by ZFMISC_1:31;
  dom(P) = dom C \/ dom i by FUNCT_4:def 1
    .= dom C \/ { (card I + 4)} by FUNCOP_1:13
    .= dom C by A2,XBOOLE_1:12;
  hence card while<0(a,I) = card I + 11 by A1;
end;

canceled 3;

theorem Th10:
  for a being Int-Location, I being Program of SCM+FSA holds
   0 in dom while=0(a,I) &  1 in dom while=0(a,I) &  0 in dom
  while>0(a,I) &  1 in dom while>0(a,I)
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ";" Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
  if=0(a, I1, J) = i ";" J ";" Goto  (card I1 + 1) ";" I1 ";" Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ";" J ";" Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA) by SCMFSA6A:25
    .= i ";" J ";" (Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA)) by
SCMFSA6A:25
    .= i ";" (J ";" (Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA)))
  by SCMFSA6A:29
    .= Macro i ";" (J ";" (Goto  (card I1 + 1) ";" (I1 ";" Stop
  SCM+FSA)));
  then
A1: dom Macro i c= dom if=0(a,I1,J) by SCMFSA6A:17;
  dom Macro i = { 0,  1} by COMPOS_1:61;
  then
A2:  0 in dom Macro i &  1 in dom Macro i by TARSKI:def 2;
  dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then dom if=0(a,I1,J) c= dom while=0(a,I) by XBOOLE_1:7;
  then dom Macro i c= dom while=0(a,I) by A1,XBOOLE_1:1;
  hence  0 in dom while=0(a,I) &  1 in dom while=0(a,I) by A2;
  set i = a >0_goto  (card J + 3);
  if>0(a, I1, J) = i ";" J ";" Goto  (card I1 + 1) ";" I1 ";" Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ";" J ";" Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA) by SCMFSA6A:25
    .= i ";" J ";" (Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA)) by
SCMFSA6A:25
    .= i ";" (J ";" (Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA)))
  by SCMFSA6A:29
    .= Macro i ";" (J ";" (Goto  (card I1 + 1) ";" (I1 ";" Stop
  SCM+FSA)));
  then
A3: dom Macro i c= dom if>0(a,I1,J) by SCMFSA6A:17;
  dom Macro i = { 0,  1} by COMPOS_1:61;
  then
A4:  0 in dom Macro i &  1 in dom Macro i by TARSKI:def 2;
  dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then dom if>0(a,I1,J) c= dom while>0(a,I) by XBOOLE_1:7;
  then dom Macro i c= dom while>0(a,I) by A3,XBOOLE_1:1;
  hence thesis by A4;
end;

theorem Th11:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I). 0 = a =0_goto  4 & while=0(a,I). 1 = goto
 2 & while>0(a,I). 0 = a >0_goto  4 & while>0(a,I). 1 =
  goto  2
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ";" Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
A1: dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f by FUNCT_4:def 1;
A2: dom f = { (card I + 4)} by FUNCOP_1:13;
  then
A3: not  0 in dom f;
A4: dom Macro i = { 0,  1} by COMPOS_1:61;
  then
A5:  0 in dom Macro i by TARSKI:def 2;
A6:  1 in dom Macro i by A4,TARSKI:def 2;
A7: if=0(a, I1, J) = i ";" J ";" Goto  (card I1 + 1) ";" I1 ";" Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ";" J ";" Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA) by SCMFSA6A:25
    .= i ";" J ";" (Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA)) by
SCMFSA6A:25
    .= i ";" (J ";" (Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA)))
  by SCMFSA6A:29
    .= Macro i ";" (J ";" (Goto  (card I1 + 1) ";" (I1 ";" Stop
  SCM+FSA)));
  1 <> card I + 4 by NAT_1:11;
  then
A8: not  1 in dom f by A2,TARSKI:def 1;
   0 in dom while=0(a,I) by Th10;
  hence while=0(a,I). 0 =if=0(a,I1,J). 0 by A3,A1,FUNCT_4:def 1
    .= (Directed Macro i). 0 by A7,A5,SCMFSA8A:14
    .= a =0_goto  4 by Lm1,SCMFSA7B:1;
A9: dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f by FUNCT_4:def 1;
   1 in dom while=0(a,I) by Th10;
  hence while=0(a,I). 1 =if=0(a,I1,J). 1 by A1,A8,FUNCT_4:def 1
    .= (Directed Macro i). 1 by A7,A6,SCMFSA8A:14
    .= goto  2 by SCMFSA7B:2;
  set i = a >0_goto  (card J + 3);
A10: if>0(a, I1, J) = i ";" J ";" Goto  (card I1 + 1) ";" I1 ";" Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ";" J ";" Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA) by SCMFSA6A:25
    .= i ";" J ";" (Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA)) by
SCMFSA6A:25
    .= i ";" (J ";" (Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA)))
  by SCMFSA6A:29
    .= Macro i ";" (J ";" (Goto  (card I1 + 1) ";" (I1 ";" Stop
  SCM+FSA)));
A11: dom Macro i = { 0,  1} by COMPOS_1:61;
  then
A12:  0 in dom Macro i by TARSKI:def 2;
A13:  1 in dom Macro i by A11,TARSKI:def 2;
   0 in dom while>0(a,I) by Th10;
  hence while>0(a,I). 0 = if>0(a,I1,J). 0 by A3,A9,FUNCT_4:def 1
    .= (Directed Macro i). 0 by A10,A12,SCMFSA8A:14
    .= a >0_goto  4 by Lm1,SCMFSA7B:1;
   1 in dom while>0(a,I) by Th10;
  hence while>0(a,I). 1 = if>0(a,I1,J). 1 by A8,A9,FUNCT_4:def 1
    .= (Directed Macro i). 1 by A10,A13,SCMFSA8A:14
    .= goto  2 by SCMFSA7B:2;
end;

theorem Th12:
  for a being Int-Location, I being Program of SCM+FSA, k being
  Element of NAT st k < 6 holds  k in dom while=0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
A1: 6 <= card I + 6 by NAT_1:11;
A2: card while=0(a,I) = card I + 6 by Th4;
  assume k < 6;
  then k < card I + 6 by A1,XXREAL_0:2;
  hence thesis by A2,AFINSQ_1:66;
end;

theorem Th13:
  for a being Int-Location, I being Program of SCM+FSA, k being
  Element of NAT st k < 6 holds card I +k in dom while=0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
  assume k < 6;
  then
A1: card I + k < card I + 6 by XREAL_1:6;
  card while=0(a,I) = card I + 6 by Th4;
  hence thesis by A1,AFINSQ_1:66;
end;

theorem Th14:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I).(card I +5) = halt SCM+FSA
proof
  set J1= Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ";" Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
  set c5 = card I + 5;
  set Lc5=c5;
  set Mi= Macro i ";" J ";" Goto  (card I1 + 1) ";" I1;
  dom f = { (card I + 4)} & Lc5 <>  (card I + 4) by FUNCOP_1:13;
  then
A1: not Lc5 in dom f by TARSKI:def 1;
   0 + c5 in { il+c5 where il is Element of NAT: il in dom J1} by Lm3;
  then
A2:  c5 in dom Shift(J1,c5) by VALUED_1:def 12;
  then
A3: Shift(J1,c5)/.Lc5 = Shift(J1,c5).(0 +c5) by PARTFUN1:def 6
    .= halt SCM+FSA by Lm2,Lm3,VALUED_1:def 12;
A4: Lc5 in dom while=0(a,I) & dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f
  by Th13,FUNCT_4:def 1;
  then
A5: Lc5 in dom if=0(a,I1,J) by A1,XBOOLE_0:def 3;
A6: if=0(a, I1, J) = i ";" J ";" Goto  (card I1 + 1) ";" I1 ";" Stop
  SCM+FSA by SCMFSA8B:def 1
    .= Mi ";" J1;
  then card if=0(a, I1,J) = card Mi + card J1 by SCMFSA6A:21;
  then
A7: card Mi = card if=0(a,I1,J)-card J1
    .= card I + 6 - 1 by Th1,Lm1
    .= c5;
  then
A8: not Lc5 in dom Mi;
A9: dom if=0(a,I1,J) = dom Directed Mi \/ dom Reloc(J, c5)
  by A6,A7,FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom Reloc(J, c5) by FUNCT_4:99;
  then
A10: Lc5 in dom Reloc(J, c5) by A5,A8,XBOOLE_0:def 3;
A11: Reloc(J,c5) = IncAddr(Shift(J,c5),c5) by COMPOS_1:34;
  thus while=0(a,I).Lc5 = (Directed Mi +* Reloc(J, c5)).Lc5
  by A1,A4,A6,A7,FUNCT_4:def 1
    .= (Reloc(J,c5)).Lc5 by A5,A9,A10,FUNCT_4:def 1
    .= IncAddr( halt SCM+FSA, c5 ) by A2,A3,A11,COMPOS_1:def 21
    .= halt SCM+FSA by COMPOS_0:4;
end;

theorem Th15:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I). 3 = goto  (card I +5)
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ";" Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
  set Mi=Macro i ";" J;
  set G=Goto  (card I1 + 1);
  set J2= (I1 ";" Stop SCM+FSA);
  set J1=G ";" J2;
A1:  0 in dom G by SCMFSA8A:31;
A2: G. 0 = goto  (card I1 + 1) by SCMFSA8A:31
    .= goto  (card I + card Goto  0 + 1) by SCMFSA6A:21
    .= goto  (card I + 1 + 1) by SCMFSA8A:15
    .= goto  (card I +(1+1));
  dom J1 = dom Directed G \/ dom Reloc(J2, card G) by FUNCT_4:def 1
    .= dom G \/ dom Reloc(J2, card G) by FUNCT_4:99;
  then
A3:  0 in dom J1 by A1,XBOOLE_0:def 3;
  then  0 + 3 in { il+3 where il is Element of NAT: il in dom J1};
  then
A4:  3 in dom Shift(J1,3) by VALUED_1:def 12;
  then
A5: Shift(J1,3)/.3 =Shift(J1,3).( 0 +3) by PARTFUN1:def 6
    .=J1. 0 by A3,VALUED_1:def 12
    .=(Directed G). 0 by A1,SCMFSA8A:14
    .=goto  (card I + 2) by A1,A2,SCMFSA8A:16;
  dom f = { (card I + 4)} & 3 <> card I + 4 by FUNCOP_1:13,NAT_1:11;
  then
A6: not  3 in dom f by TARSKI:def 1;
A7: card Mi = card Macro i + card J by SCMFSA6A:21
    .= 2 + 1 by Lm1,COMPOS_1:56;
  then
A8: not  3 in dom Mi;
A9:  3 in dom while=0(a,I) & dom while=0(a,I) = dom if=0(a,I1,J) \/
  dom f by Th12,FUNCT_4:def 1;
  then
A10:  3 in dom if=0(a,I1,J) by A6,XBOOLE_0:def 3;
A11: CutLastLoc stop Mi = Mi;
A12: if=0(a, I1, J) = i ";" J ";" Goto  (card I1 + 1) ";" I1 ";" Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ";" J ";" Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA) by SCMFSA6A:25
    .= Mi ";" J1 by SCMFSA6A:25
    .= Directed Mi +* Reloc(J1, 3) by A7,A11;
  then
A13: dom if=0(a,I1,J) = dom Directed Mi \/ dom Reloc(J1, 3)
  by FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom Reloc(J1, 3) by FUNCT_4:99;
  then
A14:  3 in dom Reloc(J1, 3) by A10,A8,XBOOLE_0:def 3;
A15: Reloc(J1,3) = IncAddr(Shift(J1,3),3) by COMPOS_1:34;
  thus while=0(a,I). 3 = (Directed Mi +* Reloc(J1, 3)).
   3 by A6,A9,A12,FUNCT_4:def 1
    .= (Reloc(J1,3)). 3 by A10,A13,A14,FUNCT_4:def 1
    .= IncAddr(goto  (card I +2),3) by A4,A5,A15,COMPOS_1:def 21
    .= goto (card I +2 + 3) by SCMFSA_4:1
    .= goto (card I+ 5);
end;

theorem Th16:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I). 2 = goto  3
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ";" Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
  set Mi=Macro i;
  set J2=Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA);
  set J1=J ";" J2;
  dom f = { (card I + 4)} & 2 <> card I + 4 by FUNCOP_1:13,NAT_1:11;
  then
A1: not  2 in dom f by TARSKI:def 1;
  dom J1 = dom Directed J \/ dom Reloc(J2, card J) by FUNCT_4:def 1
    .= dom J \/ dom Reloc(J2, card J) by FUNCT_4:99;
  then
A2:  0 in dom J1 by Lm3,XBOOLE_0:def 3;
  then  0 + 2 in { il+2 where il is Element of NAT: il in dom J1};
  then
A3:  2 in dom Shift(J1,2) by VALUED_1:def 12;
  then
A4: Shift(J1,2)/.2 =Shift(J1,2).( 0 +2) by PARTFUN1:def 6
    .=J1. 0 by A2,VALUED_1:def 12
    .=(Directed J). 0 by Lm3,SCMFSA8A:14
    .=goto  card J by Lm2,Lm3,SCMFSA8A:16;
  card Mi = 2 by COMPOS_1:56;
  then
A5: not  2 in dom Mi;
A6:  2 in dom while=0(a,I) & dom while=0(a,I) = dom if=0(a,I1,J) \/
  dom f by Th12,FUNCT_4:def 1;
  then
A7:  2 in dom if=0(a,I1,J) by A1,XBOOLE_0:def 3;
A8: if=0(a, I1, J) = i ";" J ";" Goto  (card I1 + 1) ";" I1 ";" Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ";" J ";" Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA) by SCMFSA6A:25
    .= i ";" J ";" (Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA)) by
SCMFSA6A:25
    .= i ";" J1 by SCMFSA6A:29
    .= Directed Mi +* Reloc(J1, 2) by COMPOS_1:56;
  then
A9: dom if=0(a,I1,J) = dom Directed Mi \/ dom Reloc(J1, 2)
  by FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom Reloc(J1, 2) by FUNCT_4:99;
  then
A10:  2 in dom Reloc(J1, 2) by A7,A5,XBOOLE_0:def 3;
A11: Reloc(J1,2) = IncAddr(Shift(J1,2),2) by COMPOS_1:34;
  thus while=0(a,I). 2 = (Directed Mi +* Reloc(J1, 2)).
   2 by A1,A6,A8,FUNCT_4:def 1
    .= (Reloc(J1,2)). 2 by A7,A9,A10,FUNCT_4:def 1
    .= IncAddr(goto  card J,2) by A3,A4,A11,COMPOS_1:def 21
    .= goto ( 1 + 2) by Lm1,SCMFSA_4:1
    .= goto  3;
end;

theorem
  for a being Int-Location, I being Program of SCM+FSA,k being Element
  of NAT st k < card I +6 holds  k in dom while=0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
  assume
A1: k < card I +6;
  card while=0(a,I) = card I + 6 by Th4;
  hence thesis by A1,AFINSQ_1:66;
end;

theorem Th18:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location st s.a <> 0
 holds while=0(a,I) is_halting_on s,P &
  while=0(a,I) is_closed_on s,P
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a <> 0;
  set i = a =0_goto  4;
  set s1 = Initialize s,
      P1 = P +* while=0(a,I);
A2: IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
A3: IC s1 = IC Start-At(0,SCM+FSA) by A2,FUNCT_4:13
    .=  0 by FUNCOP_1:72;
  set loc5=  (card I +5);
  set s5 = Comput(P1,s1,4);
  set s4 = Comput(P1,s1,3);
  set s3 = Comput(P1,s1,2);
  set s2 = Comput(P1,s1,1);
A4:  1 in dom while=0(a,I) by Th10;
A5:  2 in dom while=0(a,I) by Th12;
  not a in dom Start-At(0,SCM+FSA) by SCMFSA_2:102;
  then
A6: s1.a = s.a by FUNCT_4:11;
A7:  P1/.IC s1 = P1.IC s1 by PBOOLE:143;
A8:  0 in dom while=0(a,I) by Th10;
  then P1. 0 = (while=0(a,I)). 0 by FUNCT_4:13
    .= i by Th11;
  then
A9: CurInstr(P1,s1) = i by A3,A7;
A10: Comput(P1,s1,0+1) = Following(P1,Comput(P1,s1,0)) by EXTPRO_1:3
    .= Following(P1,s1)
    .= Exec(i,s1) by A9;
A11: IC Comput(P1,s1,1) = succ  0 by A1,A3,A10,A6,SCMFSA_2:70
    .=  (0 + 1);
A12:  (P1)/.IC Comput(P1,s1,1) = P1.IC Comput(P1,s1,1) by PBOOLE:143;
    P1. 1 = (while=0(a,I)). 1 by A4,FUNCT_4:13
    .= goto  2 by Th11;
  then
A13: CurInstr(P1,Comput(P1,s1,1)) = goto  2 by A11,A12;
A14: Comput(P1,s1,1+1) = Following(P1,s2) by EXTPRO_1:3
    .= Exec(goto  2,s2) by A13;
A15: IC s3 =  2 by A14,SCMFSA_2:69;
A16:  P1/.IC s3 = P1.IC s3 by PBOOLE:143;
  P1. 2 = (while=0(a,I)). 2 by A5,FUNCT_4:13
    .= goto  3 by Th16;
  then
A17: CurInstr(P1,s3) = goto  3 by A15,A16;
A18: Comput(P1,s1,2+1) = Following(P1,s3) by EXTPRO_1:3
    .= Exec(goto  3,s3) by A17;
A19: IC s4 =  3 by A18,SCMFSA_2:69;
A20:  3 in dom while=0(a,I) by Th12;
A21: loc5 in dom while=0(a,I) by Th13;
A22:  P1/.IC s4 = P1.IC s4 by PBOOLE:143;
  P1. 3 = (while=0(a,I)). 3 by A20,FUNCT_4:13
    .= goto loc5 by Th15;
  then
A23: CurInstr(P1,s4) = goto loc5 by A19,A22;
A24: Comput(P1,s1,3+1) = Following(P1,s4) by EXTPRO_1:3
    .= Exec(goto loc5,s4) by A23;
A25: IC s5 = loc5 by A24,SCMFSA_2:69;
A26:  P1/.IC s5 = P1.IC s5 by PBOOLE:143;
  P1.loc5 = (while=0(a,I)).loc5 by A21,FUNCT_4:13
    .= halt SCM+FSA by Th14;
  then
A27: CurInstr(P1,s5) = halt SCM+FSA by A25,A26;
  then P1 halts_on s1 by EXTPRO_1:29;
  hence while=0(a,I) is_halting_on s,P by SCMFSA7B:def 7;
  now
    let k be Element of NAT;
A28: k<=3 or k >= 3+1 by NAT_1:13;
    per cases by A28,NAT_1:27;
    suppose
      k = 0;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A8,A3,EXTPRO_1:2;
    end;
    suppose
      k = 1;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A11,Th10;
    end;
    suppose
      k = 2;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A15,Th12;
    end;
    suppose
      k = 3;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A19,Th12;
    end;
    suppose
      k >= 4;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A21,A25,A27,EXTPRO_1:5;
    end;
  end;
  hence thesis by SCMFSA7B:def 6;
end;

theorem Th19:
  for a being Int-Location, I being Program of SCM+FSA, s being
State of SCM+FSA,k being Element of NAT
 st I is_closed_on s,P & I is_halting_on s,P
& k < LifeSpan(P +* I,Initialize s) &
  IC Comput(P +* while=0(a,I),(Initialize s),1+k)
   = IC Comput(P +* I, (Initialize s),k) + 4 &
   DataPart Comput(P +* while=0(a,I),(Initialize s),1+k)
    = DataPart Comput(P +* I,(Initialize s),k)
  holds IC Comput(P +* while=0(a,I),(Initialize s),1+k+1) = IC
Comput(P +* I, (Initialize s),k+1) + 4 &
  DataPart Comput(P +* while=0(a,I),(Initialize s),1+k+1) =
  DataPart Comput(P +* I, (Initialize s),k+1)
proof
  set J3= Goto  0 ";" Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  let k be Element of NAT;
  set s1 = Initialize s,
      P1 = P +* while=0(a,I);
  set sI = Initialize s,
      PI = P +* I;
A1: I c= PI by FUNCT_4:25;
  set sK1= Comput(P1, s1,1+k);
  set sK2= Comput(PI, sI,k);
  set l3=IC Comput(PI, sI,k);
  set I1= I ";" Goto  0;
  set i = a =0_goto  (card J + 3);
  reconsider n = l3 as Element of NAT;
  set Mi= i ";" J ";" Goto  (card I1 + 1);
  set J2= I1 ";" Stop SCM+FSA;
A2: rng I c= the InstructionsF of SCM+FSA by RELAT_1:def 19;
  assume I is_closed_on s,P;
  then
A3:  n in dom I by SCMFSA7B:def 6;
  then n < card I by AFINSQ_1:66;
  then
A4: n+4 < card I+ 6 by XREAL_1:8;
A5:  PI/.IC sK2 = PI.IC sK2 by PBOOLE:143;
A6: CurInstr(PI,sK2) =PI. n by A5
    .= I. n by A3,A1,GRFUNC_1:2;
  assume I is_halting_on s,P;
  then
A7: PI halts_on sI by SCMFSA7B:def 7;
  assume k < LifeSpan(PI,sI);
  then
A8: I. n <> halt SCM+FSA by A6,A7,EXTPRO_1:def 15;
A9: J2= I ";" J3 by SCMFSA6A:25;
  then dom J2 = dom Directed I \/ dom Reloc(J3, card I) by FUNCT_4:def 1
    .= dom I \/ dom Reloc(J3, card I) by FUNCT_4:99;
  then
A10:  n in dom J2 by A3,XBOOLE_0:def 3;
  then  n + 4 in { il+4 where il is Element of NAT: il in dom J2};
  then
A11:  (n+4) in dom Shift(J2,4) by VALUED_1:def 12;
  then
A12: Shift(J2,4)/.(n+4) =Shift(J2,4).( n +4) by PARTFUN1:def 6
    .=J2. n by A10,VALUED_1:def 12
    .=(Directed I). n by A3,A9,SCMFSA8A:14
    .=I. n by A3,A8,SCMFSA8A:16;
  card while=0(a,I) = card I + 6 by Th4;
  then
A13:  (n+4) in dom while=0(a,I) by A4,AFINSQ_1:66;
  I. n in rng I by A3,FUNCT_1:def 3;
  then reconsider j = I. n as Instruction of SCM+FSA by A2;
A14: card Mi = card (i ";" J )+ card Goto  (card I1 + 1) by SCMFSA6A:21
    .= card (i ";" J ) + 1 by SCMFSA8A:15
    .= card (Macro i) + card J + 1 by SCMFSA6A:21
    .= 2 + 1 +1 by Lm1,COMPOS_1:56
    .= 3+ 1;
  then n+4 >= card Mi by NAT_1:11;
  then
A15: not  (n+4) in dom Mi by AFINSQ_1:66;
A16: Comput(PI, sI,k+1) = Following(PI,sK2) by EXTPRO_1:3
    .= Exec(j,sK2) by A6;
  set f =  (card I +4) .--> goto  0;
  assume
A17: IC Comput(P1, s1,1+k)=l3 + 4;
  dom f = { (card I + 4)} & n + 4 <> card I + 4 by A3,FUNCOP_1:13;
  then
A18: not  (n+4) in dom f by TARSKI:def 1;
A19: dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then
A20:  (n+4) in dom if=0(a,I1,J) by A18,A13,XBOOLE_0:def 3;
A21: CutLastLoc stop Mi = Mi;
A22: if=0(a, I1, J) = Mi ";" I1 ";" Stop SCM+FSA by SCMFSA8B:def 1
    .= Mi ";" J2 by SCMFSA6A:25
    .= Directed Mi +* Reloc(J2, 4) by A14,A21;
  then
A23: dom if=0(a,I1,J) = dom Directed Mi \/ dom Reloc(J2, 4 )
  by FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom Reloc(J2, 4) by FUNCT_4:99;
  then
A24:  (n+4) in dom Reloc(J2, 4) by A20,A15,XBOOLE_0:def 3
;
A25:  (P1)/.IC sK1 = P1.IC sK1 by PBOOLE:143;
A26: Reloc(J2,4) = IncAddr(Shift(J2,4),4) by COMPOS_1:34;
  P1. (n+4) = (while=0(a,I)). (n+4) by A13,FUNCT_4:13
    .= (Directed Mi +* Reloc(J2, 4)). (n+4) by A18,A13,A19,A22,FUNCT_4:def 1
    .= (Reloc(J2,4)). (n+4) by A20,A23,A24,FUNCT_4:def 1
    .= IncAddr(j,4) by A11,A12,A26,COMPOS_1:def 21;
  then
A27: CurInstr(P1,sK1) =IncAddr(j,4) by A17,A25;
  assume
A28: DataPart sK1 = DataPart sK2;
  Comput(P1, s1,1+k+1) = Following(P1,sK1) by EXTPRO_1:3
    .= Exec(IncAddr(j,4),sK1) by A27;
  hence thesis by A17,A28,A16,SCMFSA6A:8;
end;

theorem Th20:
  for a being Int-Location, I being Program of SCM+FSA, s being
  State of SCM+FSA st I is_closed_on s,P & I is_halting_on s,P &
  IC Comput(P +* while=0(a,I), Initialize s,
   1 + LifeSpan(P +* I,Initialize s) ) = IC Comput(P +* I,Initialize s,
       LifeSpan(P +* I,Initialize s) ) + 4
 holds CurInstr(P +* while=0(a,I),
   Comput(P +* while=0(a,I),Initialize s,
  (1 + LifeSpan(P +* I,Initialize s)))) = goto  (card I +4)
proof
  set J3= Goto  0 ";" Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s1 = Initialize s,
      P1 = P +* while=0(a,I);
  set sI = Initialize s,
      PI = P +* I;
A1: I c= PI by FUNCT_4:25;
  set life=LifeSpan(P +* I,Initialize s);
  set sK1= Comput(P1, s1,1+life);
  set sK2= Comput(PI, sI,life);
  set I1= I ";" Goto  0;
  set i = a =0_goto  (card J + 3);
  reconsider n = IC sK2 as Element of NAT;
  set Mi= i ";" J ";" Goto  (card I1 + 1);
  set J2= I1 ";" Stop SCM+FSA;
  assume I is_closed_on s,P;
  then
A2:  n in dom I by SCMFSA7B:def 6;
  then n < card I by AFINSQ_1:66;
  then
A3: n+4 < card I+ 6 by XREAL_1:8;
  assume I is_halting_on s,P;
  then
A4: PI halts_on sI by SCMFSA7B:def 7;
A5:  (PI)/.IC sK2 = PI.IC sK2 by PBOOLE:143;
A6:  (P1)/.IC sK1 = P1.IC sK1 by PBOOLE:143;
  CurInstr(PI,sK2) =PI. n by A5
    .= I. n by A2,A1,GRFUNC_1:2;
  then
A7: I. n = halt SCM+FSA by A4,EXTPRO_1:def 15;
A8: J2= I ";" J3 by SCMFSA6A:25;
  then dom J2 = dom Directed I \/ dom Reloc(J3, card I) by FUNCT_4:def 1
    .= dom I \/ dom Reloc(J3, card I) by FUNCT_4:99;
  then
A9:  n in dom J2 by A2,XBOOLE_0:def 3;
  then  n + 4 in { il+4 where il is Element of NAT: il in dom J2};
  then
A10:  (n+4) in dom Shift(J2,4) by VALUED_1:def 12;
  then
A11: Shift(J2,4)/.(n+4) =Shift(J2,4).( n +4) by PARTFUN1:def 6
    .=J2. n by A9,VALUED_1:def 12
    .=(Directed I). n by A2,A8,SCMFSA8A:14
    .=goto  card I by A2,A7,SCMFSA8A:16;
  set f =  (card I +4) .--> goto  0;
  assume
A12: IC sK1 = IC sK2 + 4;
  dom f = { (card I + 4)} & n + 4 <> card I + 4 by A2,FUNCOP_1:13;
  then
A13: not  (n+4) in dom f by TARSKI:def 1;
A14: card Mi = card (i ";" J )+ card Goto  (card I1 + 1) by SCMFSA6A:21
    .= card (i ";" J ) + 1 by SCMFSA8A:15
    .= card (Macro i) + card J + 1 by SCMFSA6A:21
    .= 2 + 1 +1 by Lm1,COMPOS_1:56
    .= 3+ 1;
  then n+4 >= card Mi by NAT_1:11;
  then
A15: not  (n+4) in dom Mi by AFINSQ_1:66;
  card while=0(a,I) = card I + 6 by Th4;
  then
A16:  (n+4) in dom while=0(a,I) by A3,AFINSQ_1:66;
A17: dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then
A18:  (n+4) in dom if=0(a,I1,J) by A13,A16,XBOOLE_0:def 3;
A19: CutLastLoc stop Mi = Mi;
A20: if=0(a, I1, J) = Mi ";" I1 ";" Stop SCM+FSA by SCMFSA8B:def 1
    .= Mi ";" J2 by SCMFSA6A:25
    .= Directed Mi +* Reloc(J2, 4) by A14,A19;
  then
A21: dom if=0(a,I1,J) = dom Directed Mi \/ dom Reloc(J2, 4 )
  by FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom Reloc(J2, 4) by FUNCT_4:99;
  then
A22:  (n+4) in dom Reloc(J2, 4) by A18,A15,XBOOLE_0:def 3
;
A23: Reloc(J2,4) = IncAddr(Shift(J2,4),4) by COMPOS_1:34;
  P1. (n+4) = (while=0(a,I)). (n+4) by A16,FUNCT_4:13
    .= (Directed Mi +* Reloc(J2, 4)). (n+4) by A13,A16,A17,A20,FUNCT_4:def 1
    .= (Reloc(J2,4)). (n+4) by A18,A21,A22,FUNCT_4:def 1
    .= IncAddr(goto  card I,4) by A10,A11,A23,COMPOS_1:def 21
    .= goto  (card I+4) by SCMFSA_4:1;
  hence thesis by A12,A6;
end;

theorem Th21:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I). (card I +4) = goto  0
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ";" Goto  0;
  set f =  (card I +4) .--> goto  0;
  set Lc4= (card I + 4 );
  dom f = {Lc4} by FUNCOP_1:13;
  then
A1: Lc4 in dom f by TARSKI:def 1;
  Lc4 in dom while=0(a,I) & dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f
  by Th13,FUNCT_4:def 1;
  hence while=0(a,I).Lc4 = f.Lc4 by A1,FUNCT_4:def 1
    .=goto  0 by FUNCOP_1:72;
end;

reserve f for FinSeq-Location,
  c for Int-Location;

theorem Th22:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location
 st I is_closed_on s,P & I is_halting_on s,P & s.a =0
holds IC Comput(P +* while=0(a,I), (Initialize s),
(LifeSpan(P +* I,Initialize s) + 3)) =  0 &
for k being Element of NAT st k
  <= LifeSpan(P +* I,Initialize s) + 3
  holds IC Comput(P +* while=0(a,I),
   (Initialize s),k) in dom while=0(a,I)
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I is_closed_on s,P;
  set sI = Initialize s,
      PI = P +* I;
  set s1 = Initialize s,
      P1 = P +* while=0(a,I);
  defpred P[Nat] means $1 <= LifeSpan(PI,sI) implies IC Comput(
   P1, s1
,1+$1) = IC Comput(PI, sI,$1)+ 4 & DataPart Comput(P1, s1,1+$1) = DataPart
  Comput(PI, sI,$1);
  assume
A2: I is_halting_on s,P;
A3: now
    let k be Element of NAT;
    assume
A4: P[k];
    now
A5:   k + 0 < k + 1 by XREAL_1:6;
      assume k + 1 <= LifeSpan(PI,sI);
      then k < LifeSpan(PI,sI) by A5,XXREAL_0:2;
      hence IC Comput(P1, s1,1+k+1) = IC Comput(PI,sI,k+1) + 4 &
      DataPart Comput(P1, s1,1+k+1) = DataPart Comput(PI, sI,k+1)
        by A1,A2,A4,Th19;
    end;
    hence P[k + 1];
  end;
  reconsider l=LifeSpan(PI,sI) as Element of NAT;
  set loc4= (card I + 4);
  set i = a =0_goto  4;
  set s2 = Comput(P1,s1,1);
 IC SCM+FSA in dom (Start-At(0,SCM+FSA)) by MEMSTR_0:15;
   then
A6: IC s1 = IC(Start-At(0,SCM+FSA)) by FUNCT_4:13
    .=  0 by FUNCOP_1:72;
  not a in dom (Start-At(0,SCM+FSA)) by SCMFSA_2:102;
  then
A7: s1.a = s.a by FUNCT_4:11;
  assume
A8: s.a = 0;
A9:  0 in dom while=0(a,I) by Th10;
A10:  (P1)/.IC s1 = P1.IC s1 by PBOOLE:143;
  P1. 0 = while=0(a,I). 0 by A9,FUNCT_4:13
    .= i by Th11;
  then
A11: CurInstr(P1,s1) = i by A6,A10;
A12: Comput(P1,s1,0+1) = Following(P1,
Comput(P1,s1,0)) by EXTPRO_1:3
    .= Following(P1,s1)
    .= Exec(i,s1) by A11;
  then ( for c holds s2.c = s1.c)& for f holds s2.f = s1.f by SCMFSA_2:70;
  then
A13: DataPart s2 = DataPart s1 by SCMFSA_M:2
    .= DataPart sI;
A14: IC s2 =  4 by A8,A12,A7,SCMFSA_2:70;
A15: P[ 0]
  proof
    assume 0 <= LifeSpan(PI,sI);
A16: IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
    IC Comput(PI, sI,0) = IC sI
      .= IC Start-At(0,SCM+FSA) by A16,FUNCT_4:13
      .=  0 by FUNCOP_1:72;
    hence thesis by A14,A13;
  end;
A17: for k being Element of NAT holds P[k] from NAT_1:sch 1(A15,A3);
  set s4= Comput(P1, s1,1+LifeSpan(PI,sI)+1+1);
  set s3= Comput(P1, s1,1+LifeSpan(PI,sI)+1);
A18: loc4 in dom while=0(a,I) by Th13;
  set s2= Comput(P1, s1,1+LifeSpan(PI,sI));
  P[l] by A17;
  then
A19: CurInstr(P1,s2) = goto loc4 by A1,A2,Th20;
A20: s3 = Following(P1,s2) by EXTPRO_1:3
    .= Exec(goto loc4,s2) by A19;
A21: IC s3 = loc4 by A20,SCMFSA_2:69;
A22:  (P1)/.IC s3 = P1.IC s3 by PBOOLE:143;
  P1.loc4 = (while=0(a,I)).loc4 by A18,FUNCT_4:13
    .= goto  0 by Th21;
  then
A23: CurInstr(P1,s3) = goto  0 by A21,A22;
A24: s4 = Following(P1,s3) by EXTPRO_1:3
    .= Exec(goto  0,s3) by A23;
A25: IC s4 =  0 by A24,SCMFSA_2:69;
  hence IC Comput(P1, s1,LifeSpan(PI,sI)+3) =  0;
A26: LifeSpan(PI,sI)+1+1+1 =LifeSpan(PI,sI)+(2+1);
A27: now
    let k be Element of NAT;
    assume
A28: k <= LifeSpan(PI,sI)+3;
    assume k<>0;
    then consider n being Nat such that
A29: k = n+ 1 by NAT_1:6;
    k<=LifeSpan(PI,sI)+1 or k >= LifeSpan(PI,sI)+1+1
by NAT_1:13;
    then
A30: k
<=LifeSpan(PI,sI)+1 or k = LifeSpan(PI,sI)+1+1 or k >
LifeSpan(PI,sI)+1+1 by XXREAL_0:1;
    reconsider n as Element of NAT by ORDINAL1:def 12;
    per cases by A26,A30,NAT_1:13;
    suppose
      k<=LifeSpan(PI,sI)+1;
      then n <= LifeSpan(PI,sI) by A29,XREAL_1:6;
      then
A31:  IC Comput(P1,s1,1+n) = IC Comput(PI, sI,n) + 4
by A17;
      reconsider m = IC Comput(PI, sI,n) as Element of NAT;
       m in dom I by A1,SCMFSA7B:def 6;
      then m < card I by AFINSQ_1:66;
      then
A32:  m+4 < card I+ 6 by XREAL_1:8;
      card while=0(a,I) = card I + 6 by Th4;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A29,A31,A32,AFINSQ_1:66
;
    end;
    suppose
      k=LifeSpan(PI,sI)+1+1;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A21,Th13;
    end;
    suppose
      k >= LifeSpan(PI,sI)+3;
      then k = LifeSpan(PI,sI)+3 by A28,XXREAL_0:1;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A25,Th10;
    end;
  end;
  now
    let k be Element of NAT;
    assume
A33: k <= LifeSpan(PI,sI)+3;
    per cases;
    suppose
      k = 0;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A9,A6,EXTPRO_1:2;
    end;
    suppose
      k <>0;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A27,A33;
    end;
  end;
  hence thesis;
end;

reserve s for State of SCM+FSA,
  I for Program of SCM+FSA,
  a for read-write
  Int-Location;

definition
  let s,I,a,P;
  deffunc U(Nat,State of SCM+FSA) =
   Comput(P +* while=0(a,I), $2 +* Start-At(0,SCM+FSA),
        LifeSpan(P +* while=0(a,I) +* I,$2 +* Start-At(0,SCM+FSA)) + 3);
  deffunc V(Nat,State of SCM+FSA) = down U($1,$2);
  func StepWhile=0(a,I,P,s) ->
    Function of NAT,product the_Values_of SCM+FSA means
  :Def4:
  it.0 = s &
  for i being Nat holds
   it.(i+1)= Comput(P +* while=0(a,I),
       it.i +* Start-At(0,SCM+FSA),
       LifeSpan(P +* while=0(a,I) +* I,
        it.i +* Start-At(0,SCM+FSA)) + 3);
  existence
  proof
   reconsider ss=s as
    Element of product the_Values_of SCM+FSA by CARD_3:107;
    consider f being Function of NAT,product the_Values_of SCM+FSA
     such that
A1:   f.0 = ss and
A2:   for i being Nat holds f.(i+1)= V(i,f.i) from NAT_1:sch 12;
   take f;
   thus f.0 = s by A1;
   let i be Nat;
    f.(i+1)= V(i,f.i) by A2;
   hence thesis;
  end;
  uniqueness
  proof
    let F1,F2 be Function of NAT,product the_Values_of SCM+FSA such that
A3: F1.0 = s and
A4: for i being Nat holds F1.(i+1)= U(i,F1.i) and
A5: F2.0 = s and
A6: for i being Nat holds F2.(i+1)= U(i,F2.i);
   reconsider s as Element of product the_Values_of SCM+FSA by CARD_3:107;
A7: F1.0 = s by A3;
A8: for i being Nat holds F1.(i+1)= V(i,F1.i) by A4;
A9: F2.0 = s by A5;
A10: for i being Nat holds F2.(i+1)= V(i,F2.i) by A6;
    thus F1 = F2 from NAT_1:sch 16(A7,A8,A9,A10);
  end;
end;

reserve i,k,m,n for Element of NAT;

theorem Th23:
  StepWhile=0(a,I,P,s).(k+1)=StepWhile=0(a,I,P,StepWhile=0(a,I,P,s).k).1
proof
  set sk=StepWhile=0(a,I,P,s).k;
  set sk0=StepWhile=0(a,I,P,sk).0;
  sk0=sk by Def4;
  hence
  StepWhile=0(a,I,P,s).(k+1) = Comput(P +*while=0(a,I),
      (sk0 +*(Start-At(0,SCM+FSA))) ,
  (LifeSpan(P +*while=0(a,I) +* I,sk0 +* Start-At(0,SCM+FSA)) + 3)) by Def4
    .=StepWhile=0(a,I,P,sk).(0+1) by Def4
    .=StepWhile=0(a,I,P,sk).1;
end;

canceled;

theorem Th25:
  for I being Program of SCM+FSA,a being read-write Int-Location,
  s being State of SCM+FSA holds StepWhile=0(a,I,P,s).(0+1)
   = Comput(P +* while=0(a,I),Initialize s,
        LifeSpan(P +* while=0(a,I)+* I,Initialize s) + 3)
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA;
A1: StepWhile=0(a,I,P,s).0 = s by Def4;
  thus StepWhile=0(a,I,P,s).(0+1)
    = Comput(P +* while=0(a,I), Initialize s,
       LifeSpan(P +* while=0(a,I)+* I,Initialize s) + 3) by A1,Def4;
end;

theorem Th26:
  for I being Program of SCM+FSA,a being read-write Int-Location,
s being State of SCM+FSA,k,n being Element of NAT
st IC StepWhile=0(a,I,P,s).k = 0 &
   StepWhile=0(a,I,P,s).k= Comput(P +* while=0(a,I),
       (Initialize s),n)
   holds StepWhile=0(a,I,P,s).k = Initialize(StepWhile=0(a,I,P,s).k) &
   StepWhile=0(a,I,P,s).(k+1)=Comput(P +* while=0(a,I), Initialize s,
     (n +(LifeSpan(P +* while=0(a,I) +* I,
       Initialize(StepWhile=0(a,I,P,s).k)) + 3)))
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA,k,n be Element of NAT;
  set s1 = Initialize s,
      P1 = P +* while=0(a,I);
  set sk=StepWhile=0(a,I,P,s).k;
  set s2=Initialize sk;
  assume
A1: IC sk = 0;
  assume
A2: sk = Comput(P1, s1,n);
   sk is 0-started by A1,MEMSTR_0:def 12;
   then Start-At(0,SCM+FSA) c= sk by MEMSTR_0:29;
  hence s2=sk by FUNCT_4:98;
  hence
  StepWhile=0(a,I,P,s).(k+1)
    = Comput(P1, sk,LifeSpan(P +* while=0(a,I) +* I,
    Initialize sk) + 3)
        by Def4
   .= Comput(P1, s1,n +(LifeSpan(P +* while=0(a,I) +* I,
   Initialize sk) + 3))
     by A2,EXTPRO_1:4;
end;

theorem Th27:
  for I being Program of SCM+FSA,a being read-write Int-Location,
s being State of SCM+FSA st
 (for k being Nat holds
  I is_closed_on StepWhile=0(a,I,P,s).k,P+*while=0(a,I) &
  I is_halting_on StepWhile=0(a,I,P,s).k,P+*while=0(a,I)) &
   ex f being Function of
  product the_Values_of SCM+FSA,NAT st
   for k being Nat holds
    ((f.(StepWhile=0(a,I,P,s).(k+1)) < f.(StepWhile=0(a,I,P,s).k) or
     f.(StepWhile=0(a,I,P,s).k) = 0) &
    (f.(StepWhile=0(a,I,P,s).k)=0 iff (StepWhile=0(a,I,P,s).k).a <> 0))
  holds while=0(a,I) is_halting_on s,P & while=0(a,I) is_closed_on s,P
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA;
  assume
A1: for k being Nat holds
   I is_closed_on StepWhile=0(a,I,P,s).k,P+*while=0(a,I) &
   I is_halting_on StepWhile=0(a,I,P,s).k,P+*while=0(a,I);
  set s1 = Initialize s,
      P1 = P +* while=0(a,I);
A2:  P1 +* while=0(a,I) = P1;
  given f being Function of product the_Values_of SCM+FSA,NAT such that
A3: for k being Nat
 holds (f.(StepWhile=0(a,I,P,s).(k+1)) < f.(StepWhile=0(a,I,P,s).k) or
  f.(StepWhile=0(a,I,P,s).k) = 0) &
( f.(StepWhile=0(a,I,P,s).k)=0 iff
  (StepWhile=0(a,I,P,s).k).a <> 0 );
  deffunc F(Nat) = f.(StepWhile=0(a,I,P,s).$1);
A4: for k being Nat holds ( F(k+1) < F(k) or F(k) = 0 ) by A3;
  consider m being Nat such that
A5: F(m)=0 and
A6: for n being Nat st F(n) =0 holds m <= n from NAT_1:sch 17(A4);
  defpred P[Nat] means $1+1 <= m implies ex k st StepWhile=0(a,I,P,s)
  .($1+1)= Comput(P1, s1,k);
A7: now
    let k be Element of NAT;
    assume
A8: P[k];
    now
      set sk1=StepWhile=0(a,I,P,s).(k+1);
      set sk=StepWhile=0(a,I,P,s).k;
      assume
A9:   (k+1)+ 1 <= m;
      k + 0 < k+ (1+ 1) by XREAL_1:6;
      then k < m by A9,XXREAL_0:2;
      then F(k) <> 0 by A6;
      then
A10:  sk.a = 0 by A3;
A11:  I is_halting_on sk,P+*while=0(a,I) by A1;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:6;
      then consider n being Element of NAT such that
A12:  sk1 = Comput(P1, s1,n) by A8,A9,XXREAL_0:2;
      take m=n +(LifeSpan(P +* while=0(a,I) +* I,
          Initialize sk1) + 3);
A13:  P+*while=0(a,I) +* while=0(a,I) = P+*while=0(a,I);
      sk1= Comput(P +* while=0(a,I), Initialize sk,
       (LifeSpan(P +* while=0(a,I) +* I,Initialize sk) + 3)) &
       I is_closed_on sk,P+*while=0(a,I) by A1,Def4;
      then IC sk1 = 0 by A11,A10,Th22,A13;
      hence StepWhile=0(a,I,P,s).((k+1)+1)= Comput(P1, s1,m) by A12,Th26;
    end;
    hence P[k+1];
  end;
A14: P[ 0]
  proof
    assume 0+1 <= m;
    take n=(LifeSpan(P +* while=0(a,I)+* I,Initialize s) + 3);
    thus thesis by Th25;
  end;
A15: for k being Element of NAT holds P[k] from NAT_1:sch 1(A14,A7);
  now
    per cases;
    suppose
      m=0;
      then (StepWhile=0(a,I,P,s).0).a <> 0 by A3,A5;
      then s.a <> 0 by Def4;
      hence thesis by Th18;
    end;
    suppose
A16:  m<>0;
      then consider i being Nat such that
A17:  m=i+1 by NAT_1:6;
      reconsider m,i as Element of NAT by ORDINAL1:def 12;
      set sm=StepWhile=0(a,I,P,s).m;
      set si=StepWhile=0(a,I,P,s).i;
      i < m by A17,NAT_1:13;
      then F(i) <> 0 by A6;
      then
A18:  si.a = 0 by A3;
A19:  I is_closed_on si,P+*while=0(a,I) &
      I is_halting_on si,P+*while=0(a,I) by A1;
A20:   IC SCM+FSA in dom sm by MEMSTR_0:2;
      sm= Comput(P +* while=0(a,I), (Initialize si),
      (LifeSpan(P +* while=0(a,I) +* I,Initialize si) + 3))
       by A17,Def4;
      then IC sm = 0 by A19,A18,Th22,A2;
      then sm is 0-started by A20,MEMSTR_0:def 11;
      then
A21:  Start-At(0,SCM+FSA) c= sm by MEMSTR_0:29;
      set p=(LifeSpan(P+*while=0(a,I)+* I,Initialize s) + 3);
      set sm1=Initialize sm;
      m=i+1 by A17;
      then consider n being Element of NAT such that
A22:  sm = Comput(P1, s1,n) by A15;
      reconsider n as Element of NAT;
A23:  sm1=sm by A21,FUNCT_4:98;
A24:  sm.a <> 0 by A3,A5;
      then while=0(a,I) is_halting_on sm,P by Th18;
      then P +* while=0(a,I) halts_on Initialize sm by SCMFSA7B:def 7;
      then P +* while=0(a,I) halts_on Initialize sm;
      then P1 halts_on sm1;
      then consider j being Element of NAT such that
A25:  CurInstr(P1,Comput(P1,sm,j))
        = halt SCM+FSA by A23,EXTPRO_1:29;
A26: Comput(P1,s1,n+j)
 = Comput(P1,Comput(P1,s1,n),j) by EXTPRO_1:4;
      CurInstr(P1,Comput(P1,s1,n+j))
       = halt SCM+FSA by A22,A25,A26;
      then P1 halts_on s1 by EXTPRO_1:29;
      hence while=0(a,I) is_halting_on s,P by SCMFSA7B:def 7;
      now
        let q be Element of NAT;
A27:    0<m by A16;
        per cases;
        suppose
A28:      q <= p;
A29:      StepWhile=0(a,I,P,s).0=s by Def4;
          then
A30:      I is_closed_on s,P+*while=0(a,I) &
          I is_halting_on s,P+*while=0(a,I) by A1;
          F(0) <> 0 by A6,A27;
          then s.a = 0 by A3,A29;
          hence IC Comput(P1,s1,q) in dom while=0(a,I) by A28,A30,Th22,A2;
        end;
        suppose
A31:      q > p;
A32:      now
            take k=p;
            thus StepWhile=0(a,I,P,s).1= Comput(P1, s1,k) & k <= q
by A31,Th25;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 &
          (ex k st StepWhile=0(a,I,P,s).$1
          = Comput(P1, s1,k) & k <= q);
A33:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A27,XREAL_1:6;
          then 1 <= m by NAT_1:13;
          then
A34:      ex t be Nat st P2[t] by A32;
          consider t be Nat such that
A35:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A33,A34);
          reconsider t as Element of NAT by ORDINAL1:def 12;
          now
            per cases;
            suppose
              t=m;
              then consider r being Element of NAT such that
A36:          sm= Comput(P1, s1,r) and
A37:          r <= q by A35;
              consider x being Nat such that
A38:          q = r+x by A37,NAT_1:10;
A39:          while=0(a,I) is_closed_on sm,P by A24,Th18;
              reconsider x as Element of NAT by ORDINAL1:def 12;
              Comput(P1,s1,q) = Comput(P1, sm1,x)
by A23,A36,A38,EXTPRO_1:4;
              hence IC Comput(P1,s1,q) in dom while=0(a,I) by A39,
SCMFSA7B:def 6;
            end;
            suppose
A40:          t<>m;
              set Dt=StepWhile=0(a,I,P,s).t;
A41:          t < m by A35,A40,XXREAL_0:1;
              then F(t) <> 0 by A6;
              then
A42:          Dt.a = 0 by A3;
              consider z being Element of NAT such that
A43:          StepWhile=0(a,I,P,s).t= Comput(P1, s1,z) and
A44:          z <= q by A35;
              set z2=z +(LifeSpan(P +* while=0(a,I) +* I,
                   Initialize Dt) + 3);
              consider w being Nat such that
A45:          q = z+w by A44,NAT_1:10;
A46:          I is_closed_on Dt,P+*while=0(a,I) &
              I is_halting_on Dt,P+*while=0(a,I) by A1;
              consider y being Nat such that
A47:          t=y+1 by A35,NAT_1:6;
              reconsider y as Element of NAT by ORDINAL1:def 12;
              set Dy=StepWhile=0(a,I,P,s).y;
              y+ 0 < t by A47,XREAL_1:6;
              then y < m by A35,XXREAL_0:2;
              then F(y) <> 0 by A6;
              then
A48:          Dy.a = 0 by A3;
A49:          I is_closed_on Dy,P+*while=0(a,I) &
              I is_halting_on Dy,P+*while=0(a,I) by A1;
              reconsider w as Element of NAT by ORDINAL1:def 12;
              Dt= Comput(P +* while=0(a,I),
                Initialize Dy,
                LifeSpan(P +* while=0(a,I) +* I,Initialize Dy) + 3)
                  by A47,Def4;
              then
A50:          IC Dt = 0 by A49,A48,Th22,A2;
              now
                assume
A51:            z2 <= q;
A52:            now
                  take k=z2;
                  thus StepWhile=0(a,I,P,s).(t+1)= Comput(P1, s1,k)
& k <= q
by A43,A50,A51,Th26;
                end;
                t+1 <= m by A41,NAT_1:13;
                hence contradiction by A35,A52,XREAL_1:29;
              end;
              then
A53:          w < LifeSpan(P +* while=0(a,I) +* I,
Initialize Dt) + 3
by A45,XREAL_1:6;
A54: Dt = Initialize Dt by A43,A50,Th26;
              Comput(P1,s1,q)
                = Comput(P +* while=0(a,I), (Dt +* (
Start-At(0,SCM+FSA))),w) by A54,A43,A45,EXTPRO_1:4;
              hence IC Comput(P1,s1,q) in dom while=0(a,I) by A53,A46,A42,Th22
,A2;
            end;
          end;
          hence IC Comput(P1,s1,q) in dom while=0(a,I);
        end;
      end;
      hence while=0(a,I) is_closed_on s,P by SCMFSA7B:def 6;
    end;
  end;
  hence thesis;
end;

theorem Th28:
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location, s being State of SCM+FSA st
   ex f being Function of product the_Values_of SCM+FSA,NAT st
  for k being Nat
   holds (f.(StepWhile=0(a,I,P,s).(k+1)) < f.(StepWhile=0(a,I,P,s).k)
    or f.(StepWhile=0(a,I,P,s).k) = 0) &
     (f.(StepWhile=0(a,I,P,s).k)=0 iff (StepWhile=0(a,I,P,s).k).a <> 0 )
 holds while=0(a,I) is_halting_on s,P & while=0(a,I) is_closed_on s,P
proof
  let I be parahalting Program of SCM+FSA,a be read-write Int-Location,s be
  State of SCM+FSA;
A1: for k being Nat holds
      I is_closed_on StepWhile=0(a,I,P,s).k,P+*while=0(a,I) &
      I is_halting_on StepWhile=0(a,I,P,s).k,P+*while=0(a,I)
       by SCMFSA7B:18,19;
  assume ex f being Function of product the_Values_of SCM+FSA,NAT st for
k being Nat holds (f.(StepWhile=0(a,I,P,s).(k+1)) < f.(StepWhile=0(a,I,P,s).k)
 or f
.(StepWhile=0(a,I,P,s).k) = 0) & ( f.(StepWhile=0(a,I,P,s).k)=0
 iff (StepWhile=0(a,I,P,s).k).a <> 0 );
  hence thesis by A1,Th27;
end;

theorem
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location st ex f being Function of product the_Values_of SCM+FSA,NAT
st (for s being State of SCM+FSA,P
 holds (f.(StepWhile=0(a,I,P,s).1) < f.s
 or f.s =
  0) & ( f.s =0 iff s.a <> 0 )) holds while=0(a,I) is parahalting
proof
  let I be parahalting Program of SCM+FSA,a be read-write Int-Location;
  given f being Function of product the_Values_of SCM+FSA,NAT such that
A1: for s being State of SCM+FSA,P holds (f.(StepWhile=0(a,I,P,s).1) < f.s
  or f.s = 0) & ( f.s =0 iff s.a <> 0 );
  now let t be State of SCM+FSA;
   let Q;
    now
      let k be Nat;
A2:   k in NAT by ORDINAL1:def 12;
      f.(StepWhile=0(a,I,Q,StepWhile=0(a,I,Q,t).k).1)
       < f.(StepWhile=0(a,I,Q,t).
      k) or f.(StepWhile=0(a,I,Q,t).k) = 0 by A1;
      hence (f.(StepWhile=0(a,I,Q,t).(k+1)) < f.(StepWhile=0(a,I,Q,t).k)
        or f.(StepWhile=0(a,I,Q,t).k) = 0) &
       (f.(StepWhile=0(a,I,Q,t).k)=0 iff (StepWhile=0(a,I,Q,t).k).a <> 0 )
        by A1,A2,Th23;
    end;
    hence while=0(a,I) is_halting_on t,Q by Th28;
  end;
  hence thesis by SCMFSA7B:19;
end;

theorem Th30:
  for l1,l2 being Element of NAT,a being
  Int-Location holds (l1 .--> goto l2) does not destroy a
proof
  let l1,l2 be Element of NAT,a be Int-Location;
  set I=l1 .--> goto l2;
A1: rng I={goto l2 } by FUNCOP_1:8;
  now
    let i be Instruction of SCM+FSA;
    assume i in rng I;
    then i=goto l2 by A1,TARSKI:def 1;
    hence i does not destroy a by SCMFSA7B:11;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th31:
  for i being Instruction of SCM+FSA st i does not destroy intloc
  0 holds Macro i is good
proof
  let i be Instruction of SCM+FSA;
  set I=Macro i;
A1: rng I = {i,halt SCM+FSA} by COMPOS_1:67;
  assume
A2: i does not destroy intloc 0;
  now
    let x be Instruction of SCM+FSA;
    assume
A3: x in rng I;
    per cases by A1,A3,TARSKI:def 2;
    suppose
      x = i;
      hence x does not destroy intloc 0 by A2;
    end;
    suppose
      x = halt SCM+FSA;
      hence x does not destroy intloc 0 by SCMFSA7B:5;
    end;
  end;
  then I does not destroy intloc 0 by SCMFSA7B:def 4;
  hence thesis by SCMFSA7B:def 5;
end;

registration
  let I,J be good Program of SCM+FSA,a be Int-Location;
  cluster if=0(a,I,J) -> good;
  correctness
  proof
    set i = a =0_goto  (card J + 3);
    reconsider Mi=Macro i as good Program of SCM+FSA by Th31,SCMFSA7B:12;
    if=0(a,I,J) = i ";" J ";" Goto  (card I + 1) ";" I ";" Stop
    SCM+FSA by SCMFSA8B:def 1
      .= Mi ";" J ";" Goto  (card I + 1) ";" I ";" Stop SCM+FSA;
    hence thesis;
  end;
end;

registration
  let I be good Program of SCM+FSA,a be Int-Location;
  cluster while=0(a,I) -> good;
  correctness
  proof
    set F=if=0(a, I ";" Goto  0, Stop SCM+FSA);
    set J= (card I +4) .--> goto  0;
    J does not destroy intloc 0 & F does not destroy intloc 0 by Th30,
SCMFSA7B:def 5;
    then while=0(a,I) does not destroy intloc 0 by SCMFSA8A:11;
    hence thesis by SCMFSA7B:def 5;
  end;
end;

:: -----------------------------------------------------------
:: WHILE>0  Statement

theorem Th32:
  for a being Int-Location, I being Program of SCM+FSA, k being
  Element of NAT st k < 6 holds  k in dom while>0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
A1: 6 <= card I + 6 by NAT_1:11;
A2: card while>0(a,I) = card I + 6 by Th5;
  assume k < 6;
  then k < card I + 6 by A1,XXREAL_0:2;
  hence thesis by A2,AFINSQ_1:66;
end;

theorem Th33:
  for a being Int-Location, I being Program of SCM+FSA, k being
  Element of NAT st k < 6 holds card I +k in dom while>0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
  assume k < 6;
  then
A1: card I + k < card I + 6 by XREAL_1:6;
  card while>0(a,I) = card I + 6 by Th5;
  hence thesis by A1,AFINSQ_1:66;
end;

theorem Th34:
  for a being Int-Location, I being Program of SCM+FSA holds
  while>0(a,I).(card I+5) = halt SCM+FSA
proof
  set J1= Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ";" Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a >0_goto  (card J + 3);
  set c5 = card I + 5;
  set Lc5= c5;
  set Mi= Macro i ";" J ";" Goto  (card I1 + 1) ";" I1;
  dom f = { (card I + 4)} & Lc5 <>  (card I + 4) by FUNCOP_1:13;
  then
A1: not Lc5 in dom f by TARSKI:def 1;
   0 + c5 in { il+c5 where il is Element of NAT: il in dom J1} by Lm3;
  then
A2:  c5 in dom Shift(J1,c5) by VALUED_1:def 12;
  then
A3: Shift(J1,c5)/.Lc5 = Shift(J1,c5).( 0 +c5) by PARTFUN1:def 6
    .= halt SCM+FSA by Lm2,Lm3,VALUED_1:def 12;
A4: Lc5 in dom while>0(a,I) & dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f
  by Th33,FUNCT_4:def 1;
  then
A5: Lc5 in dom if>0(a,I1,J) by A1,XBOOLE_0:def 3;
A6: if>0(a, I1, J) = i ";" J ";" Goto  (card I1 + 1) ";" I1 ";" Stop
  SCM+FSA by SCMFSA8B:def 2
    .= Mi ";" J1;
  then card if>0(a, I1,J) = card Mi + card J1 by SCMFSA6A:21;
  then
A7: card Mi = card if>0(a,I1,J)-card J1
    .= card I + 6 - 1 by Th2,Lm1
    .= c5;
  then
A8: not Lc5 in dom Mi;
A9: dom if>0(a,I1,J) = dom Directed Mi \/ dom Reloc(J1, c5)
  by A6,A7,FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom Reloc(J1, c5) by FUNCT_4:99;
  then
A10: Lc5 in dom Reloc(J1, c5) by A5,A8,XBOOLE_0:def 3;
A11: Reloc(J1,c5) = IncAddr(Shift(J1,c5),c5) by COMPOS_1:34;
  thus while>0(a,I).Lc5 = (Directed Mi +* Reloc(J1, c5)).Lc5
  by A1,A4,A6,A7,FUNCT_4:def 1
    .= (Reloc(J1,c5)).Lc5 by A5,A9,A10,FUNCT_4:def 1
    .= IncAddr( halt SCM+FSA, c5 ) by A2,A3,A11,COMPOS_1:def 21
    .= halt SCM+FSA by COMPOS_0:4;
end;

theorem Th35:
  for a being Int-Location, I being Program of SCM+FSA holds
  while>0(a,I). 3 = goto  (card I +5)
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ";" Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a >0_goto  (card J + 3);
  set Mi=Macro i ";" J;
  set G=Goto  (card I1 + 1);
  set J2= (I1 ";" Stop SCM+FSA);
  set J1=G ";" J2;
A1:  0 in dom G by SCMFSA8A:31;
A2: G. 0 = goto  (card I1 + 1) by SCMFSA8A:31
    .= goto  (card I + card Goto  0 + 1) by SCMFSA6A:21
    .= goto  (card I + 1 + 1) by SCMFSA8A:15
    .= goto  (card I +(1+1));
  dom J1 = dom Directed G \/ dom Reloc(J2, card G) by FUNCT_4:def 1
    .= dom G \/ dom Reloc(J2, card G) by FUNCT_4:99;
  then
A3:  0 in dom J1 by A1,XBOOLE_0:def 3;
  then  0 + 3 in { il+3 where il is Element of NAT: il in dom J1};
  then
A4:  3 in dom Shift(J1,3) by VALUED_1:def 12;
  then
A5: Shift(J1,3)/.3 =Shift(J1,3).( 0 +3) by PARTFUN1:def 6
    .=J1. 0 by A3,VALUED_1:def 12
    .=(Directed G). 0 by A1,SCMFSA8A:14
    .=goto  (card I + 2) by A1,A2,SCMFSA8A:16;
  dom f = { (card I + 4)} & 3 <> card I + 4 by FUNCOP_1:13,NAT_1:11;
  then
A6: not  3 in dom f by TARSKI:def 1;
A7: card Mi = card Macro i + card J by SCMFSA6A:21
    .= 2 + 1 by Lm1,COMPOS_1:56;
  then
A8: not  3 in dom Mi;
A9:  3 in dom while>0(a,I) & dom while>0(a,I) = dom if>0(a,I1,J) \/
  dom f by Th32,FUNCT_4:def 1;
  then
A10:  3 in dom if>0(a,I1,J) by A6,XBOOLE_0:def 3;
A11: CutLastLoc stop Mi = Mi;
A12: if>0(a, I1, J) = i ";" J ";" Goto  (card I1 + 1) ";" I1 ";" Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ";" J ";" Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA) by SCMFSA6A:25
    .= Mi ";" J1 by SCMFSA6A:25
    .= Directed Mi +* Reloc(J1, 3) by A7,A11;
  then
A13: dom if>0(a,I1,J) = dom Directed Mi \/ dom Reloc(J1, 3)
  by FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom Reloc(J1, 3) by FUNCT_4:99;
  then
A14:  3 in dom Reloc(J1, 3) by A10,A8,XBOOLE_0:def 3;
A15: Reloc(J1,3) = IncAddr(Shift(J1,3),3) by COMPOS_1:34;
  thus while>0(a,I). 3 = (Directed Mi +* Reloc(J1, 3)).
   3 by A6,A9,A12,FUNCT_4:def 1
    .= (Reloc(J1,3)). 3 by A10,A13,A14,FUNCT_4:def 1
    .= IncAddr(goto  (card I +2),3) by A4,A5,A15,COMPOS_1:def 21
    .= goto  (card I+ 2 +3) by SCMFSA_4:1
    .= goto  (card I+ 5);
end;

theorem Th36:
  for a being Int-Location, I being Program of SCM+FSA holds
  while>0(a,I). 2 = goto  3
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ";" Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a >0_goto  (card J + 3);
  set Mi=Macro i;
  set J2=Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA);
  set J1=J ";" J2;
  dom f = { (card I + 4)} & 2 <> card I + 4 by FUNCOP_1:13,NAT_1:11;
  then
A1: not  2 in dom f by TARSKI:def 1;
  dom J1 = dom Directed J \/ dom Reloc(J2, card J) by FUNCT_4:def 1
    .= dom J \/ dom Reloc(J2, card J) by FUNCT_4:99;
  then
A2:  0 in dom J1 by Lm3,XBOOLE_0:def 3;
  then  0 + 2 in { il+2 where il is Element of NAT: il in dom J1};
  then
A3:  2 in dom Shift(J1,2) by VALUED_1:def 12;
  then
A4: Shift(J1,2)/.2 =Shift(J1,2).( 0 +2) by PARTFUN1:def 6
    .=J1. 0 by A2,VALUED_1:def 12
    .=(Directed J). 0 by Lm3,SCMFSA8A:14
    .=goto  card J by Lm2,Lm3,SCMFSA8A:16;
  card Mi = 2 by COMPOS_1:56;
  then
A5: not  2 in dom Mi;
A6:  2 in dom while>0(a,I) & dom while>0(a,I) = dom if>0(a,I1,J) \/
  dom f by Th32,FUNCT_4:def 1;
  then
A7:  2 in dom if>0(a,I1,J) by A1,XBOOLE_0:def 3;
A8: if>0(a, I1, J) = i ";" J ";" Goto  (card I1 + 1) ";" I1 ";" Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ";" J ";" Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA) by SCMFSA6A:25
    .= i ";" J ";" (Goto  (card I1 + 1) ";" (I1 ";" Stop SCM+FSA)) by
SCMFSA6A:25
    .= i ";" J1 by SCMFSA6A:29
    .= Directed Mi +* Reloc(J1, 2) by COMPOS_1:56;
  then
A9: dom if>0(a,I1,J) = dom Directed Mi \/ dom Reloc(J1, 2)
  by FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom Reloc(J1, 2) by FUNCT_4:99;
  then
A10:  2 in dom Reloc(J1, 2) by A7,A5,XBOOLE_0:def 3;
A11: Reloc(J1,2) = IncAddr(Shift(J1,2),2) by COMPOS_1:34;
  thus while>0(a,I). 2 = (Directed Mi +* Reloc(J1, 2)).
   2 by A1,A6,A8,FUNCT_4:def 1
    .= (Reloc(J1,2)). 2 by A7,A9,A10,FUNCT_4:def 1
    .= IncAddr(goto  card J,2) by A3,A4,A11,COMPOS_1:def 21
    .= goto ( 1 + 2) by Lm1,SCMFSA_4:1
    .= goto  3;
end;

theorem
  for a being Int-Location, I being Program of SCM+FSA, k being Element
  of NAT st k < card I +6 holds  k in dom while>0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
  assume
A1: k < card I +6;
  card while>0(a,I) = card I + 6 by Th5;
  hence thesis by A1,AFINSQ_1:66;
end;

theorem Th38:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location
 st s.a <= 0 holds while>0(a,I) is_halting_on s,P &
  while>0(a,I) is_closed_on s,P
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a <= 0;
  set i = a >0_goto  4;
  set s1 = Initialize s,
      P1 = P +* while>0(a,I);
 IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
  then
A2: IC SCM+FSA in dom Start-At(0,SCM+FSA);
A3: IC s1 = IC Start-At(0,SCM+FSA) by A2,FUNCT_4:13
    .=  0 by FUNCOP_1:72;
  set loc5=  (card I +5);
  set s5 = Comput(P1,s1,4);
  set s4 = Comput(P1,s1,3);
  set s3 = Comput(P1,s1,2);
  set s2 = Comput(P1,s1,1);
A4:  1 in dom while>0(a,I) by Th10;
A5:  2 in dom while>0(a,I) by Th32;
  not a in dom Start-At(0,SCM+FSA) by SCMFSA_2:102;
  then
A6: s1.a = s.a by FUNCT_4:11;
A7:  (P1)/.IC s1 = P1.IC s1 by PBOOLE:143;
A8:  0 in dom while>0(a,I) by Th10;
  then P1. 0 = while>0(a,I). 0 by FUNCT_4:13
    .= i by Th11;
  then
A9: CurInstr(P1,s1) = i by A3,A7;
A10: Comput(P1,s1,0+1) = Following(P1,
Comput(P1,s1,0)) by EXTPRO_1:3
    .= Following(P1,s1)
    .= Exec(i,s1) by A9;
A11: IC Comput(P1,s1,1) = succ  0 by A1,A3,A10,A6,SCMFSA_2:71
    .=  (0 + 1);
A12:  (P1)/.IC Comput(P1,s1,1) = P1.IC Comput(P1,s1,1) by PBOOLE:143;
    P1. 1 = (while>0(a,I)). 1 by A4,FUNCT_4:13
    .= goto  2 by Th11;
  then
A13: CurInstr(P1,Comput(P1,s1,1))
 = goto  2 by A11,A12;
A14: Comput(P1,s1,1+1) = Following(P1,s2) by EXTPRO_1:3
    .= Exec(goto  2,s2) by A13;
A15: IC s3 =  2 by A14,SCMFSA_2:69;
A16:  (P1)/.IC s3 = P1.IC s3 by PBOOLE:143;
  P1. 2 = (while>0(a,I)). 2 by A5,FUNCT_4:13
    .= goto  3 by Th36;
  then
A17: CurInstr(P1,s3) = goto  3 by A15,A16;
A18: Comput(P1,s1,2+1) = Following(P1,s3) by EXTPRO_1:3
    .= Exec(goto  3,s3) by A17;
A19: IC s4 =  3 by A18,SCMFSA_2:69;
A20:  3 in dom while>0(a,I) by Th32;
A21: loc5 in dom while>0(a,I) by Th33;
A22:  (P1)/.IC s4 = P1.IC s4 by PBOOLE:143;
  P1. 3 = (while>0(a,I)). 3 by A20,FUNCT_4:13
    .= goto loc5 by Th35;
  then
A23: CurInstr(P1,s4) = goto loc5 by A19,A22;
A24: Comput(P1,s1,3+1) = Following(P1,s4) by EXTPRO_1:3
    .= Exec(goto loc5,s4) by A23;
A25: IC s5 = loc5 by A24,SCMFSA_2:69;
A26:  (P1)/.IC s5 = P1.IC s5 by PBOOLE:143;
  P1.loc5 = while>0(a,I).loc5 by A21,FUNCT_4:13
    .= halt SCM+FSA by Th34;
  then
A27: CurInstr(P1,s5) = halt SCM+FSA by A25,A26;
  then P1 halts_on s1 by EXTPRO_1:29;
  hence while>0(a,I) is_halting_on s,P by SCMFSA7B:def 7;
  now
    let k be Element of NAT;
A28: k<=3 or k >= 3+1 by NAT_1:13;
    per cases by A28,NAT_1:27;
    suppose
      k = 0;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A8,A3,EXTPRO_1:2;
    end;
    suppose
      k = 1;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A11,Th10;
    end;
    suppose
      k = 2;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A15,Th32;
    end;
    suppose
      k = 3;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A19,Th32;
    end;
    suppose
      k >= 4;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A21,A25,A27,EXTPRO_1:5;
    end;
  end;
  hence thesis by SCMFSA7B:def 6;
end;

theorem Th39:
  for a being Int-Location, I being Program of SCM+FSA, s being
State of SCM+FSA,k being Element of NAT
 st I is_closed_on s,P & I is_halting_on s,P
& k < LifeSpan(P +* I,Initialize s) &
IC Comput(P +* while>0(a,I), (Initialize s),1+k)
   = IC Comput(P +* I, (Initialize s),k) + 4 &
   DataPart Comput(P +* while>0(a,I),
    (Initialize s),1+k) =
   DataPart Comput(P +* I, (Initialize s),k)
  holds IC Comput(P +* while>0(a,I),
    (Initialize s),1+k+1)
  = IC
Comput(P +* I, (Initialize s),k+1) + 4 &
DataPart Comput(P +* while>0(a,I), (
Initialize s),1+k+1) =
DataPart Comput(P +* I, (s +*
  Start-At(0,SCM+FSA)),k+1)
proof
  set J3= Goto  0 ";" Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  let k be Element of NAT;
  set s1 = Initialize s,
      P1 = P +* while>0(a,I);
  set sI = Initialize s,
      PI = P +* I;
A1: I c= PI by FUNCT_4:25;
  set sK1= Comput(P1, s1,1+k);
  set sK2= Comput(PI, sI,k);
  set l3=IC Comput(PI, sI,k);
  set I1= I ";" Goto  0;
  set i = a >0_goto  (card J + 3);
  reconsider n = l3 as Element of NAT;
  set Mi= i ";" J ";" Goto  (card I1 + 1);
  set J2= I1 ";" Stop SCM+FSA;
A2: rng I c= the InstructionsF of SCM+FSA by RELAT_1:def 19;
  assume I is_closed_on s,P;
  then
A3:  n in dom I by SCMFSA7B:def 6;
  then n < card I by AFINSQ_1:66;
  then
A4: n+4 < card I+ 6 by XREAL_1:8;
A5:  (PI)/.IC sK2 = PI.IC sK2 by PBOOLE:143;
A6: CurInstr(PI,sK2) =PI. n by A5
    .= I. n by A3,A1,GRFUNC_1:2;
  assume I is_halting_on s,P;
  then
A7: PI halts_on sI by SCMFSA7B:def 7;
  assume k < LifeSpan(PI,sI);
  then
A8: I. n <> halt SCM+FSA by A6,A7,EXTPRO_1:def 15;
A9: J2= I ";" J3 by SCMFSA6A:25;
  then dom J2 = dom Directed I \/ dom Reloc(J3, card I) by FUNCT_4:def 1
    .= dom I \/ dom Reloc(J3, card I) by FUNCT_4:99;
  then
A10:  n in dom J2 by A3,XBOOLE_0:def 3;
  then  n + 4 in { il+4 where il is Element of NAT: il in dom J2};
  then
A11:  (n+4) in dom Shift(J2,4) by VALUED_1:def 12;
  then
A12: Shift(J2,4)/.(n+4) =Shift(J2,4).( n +4) by PARTFUN1:def 6
    .=J2. n by A10,VALUED_1:def 12
    .=(Directed I). n by A3,A9,SCMFSA8A:14
    .=I. n by A3,A8,SCMFSA8A:16;
  card while>0(a,I) = card I + 6 by Th5;
  then
A13:  (n+4) in dom while>0(a,I) by A4,AFINSQ_1:66;
  I. n in rng I by A3,FUNCT_1:def 3;
  then reconsider j = I. n as Instruction of SCM+FSA by A2;
A14: card Mi = card (i ";" J )+ card Goto  (card I1 + 1) by SCMFSA6A:21
    .= card (i ";" J ) + 1 by SCMFSA8A:15
    .= card (Macro i) + card J + 1 by SCMFSA6A:21
    .= 2 + 1 +1 by Lm1,COMPOS_1:56
    .= 3+ 1;
  then n+4 >= card Mi by NAT_1:11;
  then
A15: not  (n+4) in dom Mi by AFINSQ_1:66;
A16: Comput(PI, sI,k+1) = Following(PI,sK2) by EXTPRO_1:3
    .= Exec(j,sK2) by A6;
  set f =  (card I +4) .--> goto  0;
  assume
A17: IC Comput(P1, s1,1+k)=l3 + 4;
  dom f = { (card I + 4)} & n + 4 <> card I + 4 by A3,FUNCOP_1:13;
  then
A18: not  (n+4) in dom f by TARSKI:def 1;
A19: dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then
A20:  (n+4) in dom if>0(a,I1,J) by A18,A13,XBOOLE_0:def 3;
A21: CutLastLoc stop Mi = Mi;
A22: if>0(a, I1, J) = Mi ";" I1 ";" Stop SCM+FSA by SCMFSA8B:def 2
    .= Mi ";" J2 by SCMFSA6A:25
    .= Directed Mi +* Reloc(J2, 4) by A14,A21;
  then
A23: dom if>0(a,I1,J) = dom Directed Mi \/ dom Reloc(J2, 4 )
  by FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom Reloc(J2, 4) by FUNCT_4:99;
  then
A24:  (n+4) in dom Reloc(J2, 4) by A20,A15,XBOOLE_0:def 3
;
A25:  (P1)/.IC sK1 = P1.IC sK1 by PBOOLE:143;
A26: Reloc(J2,4) = IncAddr(Shift(J2,4),4) by COMPOS_1:34;
  P1. (n+4) = (while>0(a,I)). (n+4)
    by A13,FUNCT_4:13
    .= (Directed Mi +* Reloc(J2, 4)). (n+4) by A18,A13,A19,A22,FUNCT_4:def 1
    .= (Reloc(J2,4)). (n+4) by A20,A23,A24,FUNCT_4:def 1
    .= IncAddr(j,4) by A11,A12,A26,COMPOS_1:def 21;
  then
A27: CurInstr(P1,sK1) =IncAddr(j,4) by A17,A25;
  assume
A28: DataPart sK1 = DataPart sK2;
  Comput(P1, s1,1+k+1) = Following(P1,sK1) by EXTPRO_1:3
    .= Exec(IncAddr(j,4),sK1) by A27;
  hence thesis by A17,A28,A16,SCMFSA6A:8;
end;

theorem Th40:
  for a being Int-Location, I being Program of SCM+FSA, s being
  State of SCM+FSA st I is_closed_on s,P & I is_halting_on s,P & IC Comput(
        P +* while>0(a,I), (Initialize s),
  1 + LifeSpan(P +* I,Initialize s ) ) =
IC Comput(P +* I, (Initialize s),
LifeSpan(P +* I,Initialize s)) + 4
holds CurInstr(P +* while>0(a,I),
   Comput(P +* while>0(a,I), (Initialize s),
  1 + LifeSpan(P +* I,Initialize s) )) =
  goto  (card I +4)
proof
  set J3= Goto  0 ";" Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s1 = Initialize s,
      P1 = P +* while>0(a,I);
A1: while>0(a,I) c= P1 by FUNCT_4:25;
  set sI = Initialize s,
      PI = P +* I;
A2: I c= PI by FUNCT_4:25;
  set life=LifeSpan(P +* I,Initialize s);
  set sK1= Comput(P1, s1,1+life);
  set sK2= Comput(PI, sI,life);
  set I1= I ";" Goto  0;
  set i = a >0_goto  (card J + 3);
  reconsider n = IC sK2 as Element of NAT;
  set Mi= i ";" J ";" Goto  (card I1 + 1);
  set J2= I1 ";" Stop SCM+FSA;
  assume I is_closed_on s,P;
  then
A3:  n in dom I by SCMFSA7B:def 6;
  then n < card I by AFINSQ_1:66;
  then
A4: n+4 < card I+ 6 by XREAL_1:8;
A5:  (PI)/.IC sK2 = PI.IC sK2 by PBOOLE:143;
  assume I is_halting_on s,P;
  then
A6: PI halts_on sI by SCMFSA7B:def 7;
  CurInstr(PI,sK2)
    = I. n by A3,A2,A5,GRFUNC_1:2;
  then
A7: I. n = halt SCM+FSA by A6,EXTPRO_1:def 15;
A8: J2= I ";" J3 by SCMFSA6A:25;
  then dom J2 = dom Directed I \/ dom Reloc(J3, card I) by FUNCT_4:def 1
    .= dom I \/ dom Reloc(J3, card I) by FUNCT_4:99;
  then
A9:  n in dom J2 by A3,XBOOLE_0:def 3;
  then  n + 4 in { il+4 where il is Element of NAT: il in dom J2};
  then
A10:  (n+4) in dom Shift(J2,4) by VALUED_1:def 12;
  then
A11: Shift(J2,4)/.(n+4) =Shift(J2,4).( n +4) by PARTFUN1:def 6
    .=J2. n by A9,VALUED_1:def 12
    .=(Directed I). n by A3,A8,SCMFSA8A:14
    .=goto  card I by A3,A7,SCMFSA8A:16;
  set f =  (card I +4) .--> goto  0;
  assume
A12: IC sK1 = IC sK2 + 4;
  dom f = { (card I + 4)} & n + 4 <> card I + 4 by A3,FUNCOP_1:13;
  then
A13: not  (n+4) in dom f by TARSKI:def 1;
A14: card Mi = card (i ";" J )+ card Goto  (card I1 + 1) by SCMFSA6A:21
    .= card (i ";" J ) + 1 by SCMFSA8A:15
    .= card (Macro i) + card J + 1 by SCMFSA6A:21
    .= 2 + 1 +1 by Lm1,COMPOS_1:56
    .= 3+ 1;
  then n+4 >= card Mi by NAT_1:11;
  then
A15: not  (n+4) in dom Mi by AFINSQ_1:66;
  card while>0(a,I) = card I + 6 by Th5;
  then
A16:  (n+4) in dom while>0(a,I) by A4,AFINSQ_1:66;
A17: dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then
A18:  (n+4) in dom if>0(a,I1,J) by A13,A16,XBOOLE_0:def 3;
A19: CutLastLoc stop Mi = Mi;
A20: if>0(a, I1, J) = Mi ";" I1 ";" Stop SCM+FSA by SCMFSA8B:def 2
    .= Mi ";" J2 by SCMFSA6A:25
    .= Directed Mi +* Reloc(J2, 4) by A14,A19;
  then
A21: dom if>0(a,I1,J) = dom Directed Mi \/ dom Reloc(J2, 4 )
  by FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom Reloc(J2, 4) by FUNCT_4:99;
  then
A22: n+4 in dom Reloc(J2, 4) by A18,A15,XBOOLE_0:def 3
;
A23:  (P1)/.IC sK1 = P1.IC sK1 by PBOOLE:143;
A24: Reloc(J2,4) = IncAddr(Shift(J2,4),4) by COMPOS_1:34;
  P1. (n+4)
    = (if>0(a, I1, J) +* f). (n+4) by A16,A1,GRFUNC_1:2
    .= (Directed Mi +* Reloc(J2, 4)). (n+4) by A13,A16,A17,A20,FUNCT_4:def 1
    .= (Reloc(J2,4)). (n+4) by A18,A21,A22,FUNCT_4:def 1
    .= IncAddr(goto  card I,4) by A10,A11,A24,COMPOS_1:def 21
    .= goto  (card I+4) by SCMFSA_4:1;
  hence thesis by A12,A23;
end;

theorem Th41:
  for a being Int-Location, I being Program of SCM+FSA holds
  while>0(a,I). (card I +4) = goto  0
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ";" Goto  0;
  set f =  (card I +4) .--> goto  0;
  set Lc4= (card I + 4 );
  dom f = {Lc4} by FUNCOP_1:13;
  then
A1: Lc4 in dom f by TARSKI:def 1;
  Lc4 in dom while>0(a,I) & dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f
  by Th33,FUNCT_4:def 1;
  hence while>0(a,I).Lc4 = f.Lc4 by A1,FUNCT_4:def 1
    .=goto  0 by FUNCOP_1:72;
end;

theorem Th42:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location
 st I is_closed_on s,P & I is_halting_on s,P & s.a >0
holds IC Comput(P +* while>0(a,I), (Initialize s),
(LifeSpan(P +* I,Initialize s) + 3)) =  0 &
for k being Element of NAT st k <= LifeSpan(P +* I,Initialize s) + 3
  holds IC Comput(P +* while>0(a,I), Initialize s,k) in dom while>0(a,I)
proof
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I is_closed_on s,P;
  set sI = Initialize s,
      PI = P +* I;
  set s1 = Initialize s,
      P1 = P +* while>0(a,I);
A2: while>0(a,I) c= P1 by FUNCT_4:25;
  defpred P[Nat] means $1 <= LifeSpan(PI,sI) implies IC Comput(
   P1, s1
,1+$1) = IC Comput(PI, sI,$1)+ 4 & DataPart Comput(P1, s1,1+$1) = DataPart
  Comput(PI, sI,$1);
  assume
A3: I is_halting_on s,P;
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    now
A6:   k + 0 < k + 1 by XREAL_1:6;
      assume k + 1 <= LifeSpan(PI,sI);
      then k < LifeSpan(PI,sI) by A6,XXREAL_0:2;
      hence IC Comput(P1, s1,1+k+1) = IC Comput(PI,
sI,k+1) + 4 & DataPart
      Comput(P1, s1,1+k+1) = DataPart Comput(PI, sI
,k+1) by A1,A3,A5,Th39;
    end;
    hence P[k + 1];
  end;
  reconsider l=LifeSpan(PI,sI) as Element of NAT;
  set loc4= (card I + 4);
  set i = a >0_goto  4;
  set s2 = Comput(P1,s1,1);
 IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
   then
A7: IC SCM+FSA in dom Start-At(0,SCM+FSA);
A8: IC s1 = IC(Start-At(0,SCM+FSA)) by A7,FUNCT_4:13
    .=  0 by FUNCOP_1:72;
  not a in dom Start-At(0,SCM+FSA) by SCMFSA_2:102;
  then
A9: s1.a = s.a by FUNCT_4:11;
  assume
A10: s.a > 0;
A11:  0 in dom while>0(a,I) by Th10;
A12:  (P1)/.IC s1 = P1.IC s1 by PBOOLE:143;
  P1. 0 = while>0(a,I). 0 by A11,FUNCT_4:13
    .= i by Th11;
  then
A13: CurInstr(P1,s1) = i by A8,A12;
A14: Comput(P1,s1,0+1) =
Following(P1,Comput(P1,s1,0)
)
 by EXTPRO_1:3
    .= Following(P1,s1)
    .= Exec(i,s1) by A13;
  then ( for c holds s2.c = s1.c)& for f holds s2.f = s1.f by SCMFSA_2:71;
  then
A15: DataPart s2 = DataPart s1 by SCMFSA_M:2
    .= DataPart sI;
A16: IC s2 =  4 by A10,A14,A9,SCMFSA_2:71;
A17: P[ 0]
  proof
    assume 0 <= LifeSpan(PI,sI);
 IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
    then
A18: IC SCM+FSA in dom Start-At(0,SCM+FSA);
    IC Comput(PI, sI,0) = IC sI
      .= IC SA0 by A18,FUNCT_4:13
      .=  0 by FUNCOP_1:72;
    hence thesis by A16,A15;
  end;
A19: for k being Element of NAT holds P[k] from NAT_1:sch 1(A17,A4);
  set s4= Comput(P1, s1,1+LifeSpan(PI,sI)+1+1);
  set s3= Comput(P1, s1,1+LifeSpan(PI,sI)+1);
A20: loc4 in dom while>0(a,I) by Th33;
  set s2= Comput(P1, s1,1+LifeSpan(PI,sI));
  P[l] by A19;
  then
A21: CurInstr(P1,s2) = goto loc4 by A1,A3,Th40;
A22: s3 = Following(P1,s2) by EXTPRO_1:3
    .= Exec(goto loc4,s2) by A21;
A23: IC s3 = loc4 by A22,SCMFSA_2:69;
A24:  (P1)/.IC s3 = P1.IC s3 by PBOOLE:143;
  P1.loc4 = while>0(a,I).loc4 by A20,A2,GRFUNC_1:2
    .= goto  0 by Th41;
  then
A25: CurInstr(P1,s3) = goto  0 by A23,A24;
A26: s4 = Following(P1,s3) by EXTPRO_1:3
    .= Exec(goto  0,s3) by A25;
A27: IC s4 =  0 by A26,SCMFSA_2:69;
  hence IC Comput(P1, s1,LifeSpan(PI,sI)+3) =  0;
A28: LifeSpan(PI,sI)+1+1+1 =LifeSpan(PI,sI)+(2+1);
A29: now
    let k be Element of NAT;
    assume
A30: k <= LifeSpan(PI,sI)+3;
    assume k<>0;
    then consider n being Nat such that
A31: k = n+ 1 by NAT_1:6;
    k<=LifeSpan(PI,sI)+1 or k >= LifeSpan(PI,sI)+1+1
by NAT_1:13;
    then
A32: k
<=LifeSpan(PI,sI)+1 or k = LifeSpan(PI,sI)+1+1 or k >
LifeSpan(PI,sI)+1+1 by XXREAL_0:1;
    reconsider n as Element of NAT by ORDINAL1:def 12;
    per cases by A28,A32,NAT_1:13;
    suppose
      k<=LifeSpan(PI,sI)+1;
      then n <= LifeSpan(PI,sI) by A31,XREAL_1:6;
      then
A33:  IC Comput(P1,s1,1+n) = IC Comput(PI, sI,n) + 4
by A19;
      reconsider m = IC Comput(PI, sI,n) as Element of NAT;
       m in dom I by A1,SCMFSA7B:def 6;
      then m < card I by AFINSQ_1:66;
      then
A34:  m+4 < card I+ 6 by XREAL_1:8;
      card while>0(a,I) = card I + 6 by Th5;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A31,A33,A34,AFINSQ_1:66
;
    end;
    suppose
      k=LifeSpan(PI,sI)+1+1;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A23,Th33;
    end;
    suppose
      k >= LifeSpan(PI,sI)+3;
      then k = LifeSpan(PI,sI)+3 by A30,XXREAL_0:1;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A27,Th10;
    end;
  end;
  now
    let k be Element of NAT;
    assume
A35: k <= LifeSpan(PI,sI)+3;
    per cases;
    suppose
      k = 0;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A11,A8,EXTPRO_1:2;
    end;
    suppose
      k <>0;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A29,A35;
    end;
  end;
  hence thesis;
end;

reserve s for State of SCM+FSA,
  I for Program of SCM+FSA,
  a for read-write
  Int-Location;

definition
  let s,I,a,P;
  deffunc U(Nat,State of SCM+FSA)
   = Comput(P +* while>0(a,I), $2 +* Start-At(0,SCM+FSA),
      LifeSpan(P +* while>0(a,I) +* I,$2 +* Start-At(0,SCM+FSA)) + 3);
  deffunc V(Nat,State of SCM+FSA) = down U($1,$2);
  func StepWhile>0(a,I,P,s) -> Function of NAT,product the_Values_of
  SCM+FSA means
  :Def5:
  it.0 = s & for i being Nat
   holds it.(i+1)= Comput(P +* while>0(a,I),
    it.i +* Start-At(0,SCM+FSA),
    LifeSpan(P +* while>0(a,I) +* I,
       it.i +* Start-At(0,SCM+FSA)) + 3);
  existence
  proof
   reconsider ss=s as
    Element of product the_Values_of SCM+FSA by CARD_3:107;
    consider f being Function of NAT,product the_Values_of SCM+FSA
    such that
A1:  f.0 = ss and
A2:  for i being Nat holds f.(i+1)= V(i,f.i) from NAT_1:sch 12;
   take f;
   thus f.0 = s by A1;
   let i be Nat;
    f.(i+1)= V(i,f.i) by A2;
   hence thesis;
  end;
  uniqueness
  proof
    let F1,F2 be Function of NAT,product the_Values_of SCM+FSA such that
A3: F1.0 = s and
A4: for i being Nat holds F1.(i+1)= U(i,F1.i) and
A5: F2.0 = s and
A6: for i being Nat holds F2.(i+1)= U(i,F2.i);
   reconsider s as Element of product the_Values_of SCM+FSA by CARD_3:107;
A7: F1.0 = s by A3;
A8: for i being Nat holds F1.(i+1)= V(i,F1.i) by A4;
A9: F2.0 = s by A5;
A10: for i being Nat holds F2.(i+1)= V(i,F2.i) by A6;
   F1 = F2 from NAT_1:sch 16(A7,A8,A9,A10);
  hence thesis;
  end;
end;

theorem Th43:
  StepWhile>0(a,I,P,s).(k+1)=StepWhile>0(a,I,P,StepWhile>0(a,I,P,s).k).1
proof
  set sk=StepWhile>0(a,I,P,s).k;
  set sk0=StepWhile>0(a,I,P,sk).0;
  sk0=sk by Def5;
  hence
  StepWhile>0(a,I,P,s).(k+1) = Comput(P +* while>0(a,I),
    sk0 +*Start-At(0,SCM+FSA) ,
     LifeSpan(P +* while>0(a,I) +* I,sk0 +* Start-At(0,SCM+FSA)) + 3) by Def5
    .=StepWhile>0(a,I,P,sk).(0+1) by Def5
    .=StepWhile>0(a,I,P,sk).1;
end;

theorem Th44:
  for I being Program of SCM+FSA,a being read-write Int-Location,
  s being State of SCM+FSA holds StepWhile>0(a,I,P,s).(0+1)
  = Comput(P +* while>0(a,I),
       Initialize s,
       LifeSpan(P +* while>0(a,I)+* I,Initialize s) + 3)
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA;
A1: StepWhile>0(a,I,P,s).0 = s by Def5;
  thus StepWhile>0(a,I,P,s).(0+1)
    = Comput(P +* while>0(a,I), (Initialize s),
    (LifeSpan(P +* while>0(a,I)+* I,Initialize s)
  + 3)) by A1,Def5;
end;

theorem Th45:
  for I being Program of SCM+FSA,a being read-write Int-Location,
s being State of SCM+FSA,k,n being Element of NAT
 st IC StepWhile>0(a,I,P,s).k =
   0 & StepWhile>0(a,I,P,s).k= Comput(P +* while>0(a,I),
   (Initialize s),n)
 holds StepWhile>0(a,I,P,s).k = Initialize(StepWhile>0(a,I,P,s).k)
  & StepWhile>0(a,I,P,s).(k+1)=
Comput(P +* while>0(a,I), Initialize s,
   n +(LifeSpan(P +* while>0(a,I) +* I,Initialize(StepWhile>0(a,I,P,s).k)
  ) + 3))
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA,k,n be Element of NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  set s1 = Initialize s,
      P1 = P +* while>0(a,I);
  set sk=StepWhile>0(a,I,P,s).k;
  set s2=Initialize sk;
  assume
A1: IC sk = 0;
  assume
A2: sk = Comput(P1, s1,n);
   sk is 0-started by A1,MEMSTR_0:def 12;
   then Start-At(0,SCM+FSA) c= sk by MEMSTR_0:29;
  hence s2=sk by FUNCT_4:98;
  hence
  StepWhile>0(a,I,P,s).(k+1)=
   Comput(P1, sk,LifeSpan(P +* while>0(a,I) +* I,
   Initialize sk) +3)
   by Def5
   .= Comput(P1, s1,n +(LifeSpan(P +* while>0(a,I) +* I,
   Initialize sk) + 3))
        by A2,EXTPRO_1:4;
end;

theorem Th46:
  for I being Program of SCM+FSA,a being read-write Int-Location,
s being State of SCM+FSA st (for k being Nat
 holds I is_closed_on StepWhile>0(a,I,P,s).k,P+*while>0(a,I) &
  I is_halting_on StepWhile>0(a,I,P,s).k,P+*while>0(a,I)) &
  ex f being Function of
  product the_Values_of SCM+FSA,NAT st (for k being Nat holds (f.(
StepWhile>0(a,I,P,s).(k+1)) < f.(StepWhile>0(a,I,P,s).k) or
 f.(StepWhile>0(a,I,P,s).k
  ) = 0) & ( f.(StepWhile>0(a,I,P,s).k)=0 iff
   (StepWhile>0(a,I,P,s).k).a <= 0 ))
  holds while>0(a,I) is_halting_on s,P & while>0(a,I) is_closed_on s,P
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  assume
A1: for k being Nat holds
     I is_closed_on StepWhile>0(a,I,P,s).k,P+*while>0(a,I) &
     I is_halting_on StepWhile>0(a,I,P,s).k,P+*while>0(a,I);
  set s1 = Initialize s,
      P1 = P +* while>0(a,I);
A2:  P1 +* while>0(a,I) = P1;
A3:  P1 +* while>0(a,I) = P1;
  given f being Function of product the_Values_of SCM+FSA,NAT such that
A4: for k being Nat
 holds (f.(StepWhile>0(a,I,P,s).(k+1)) < f.(StepWhile>0
(a,I,P,s).k) or f.(StepWhile>0(a,I,P,s).k) = 0) &
 ( f.(StepWhile>0(a,I,P,s).k)=0
 iff
  (StepWhile>0(a,I,P,s).k).a <= 0 );
  deffunc F(Nat) = f.(StepWhile>0(a,I,P,s).$1);
A5: for k being Nat holds F(k+1) < F(k) or F(k) = 0 by A4;
  consider m being Nat such that
A6: F(m)=0 and
A7: for n being Nat st F(n) =0 holds m <= n from NAT_1:sch 17(A5);
  defpred P[Nat] means $1+1 <= m implies ex k st StepWhile>0(a,I,P,s)
  .($1+1)= Comput(P1, s1,k);
A8: now
    let k be Element of NAT;
    assume
A9: P[k];
    now
      set sk1=StepWhile>0(a,I,P,s).(k+1);
      set sk=StepWhile>0(a,I,P,s).k;
      assume
A10:   (k+1)+ 1 <= m;
      k + 0 < k+ (1+ 1) by XREAL_1:6;
      then k < m by A10,XXREAL_0:2;
      then F(k) <> 0 by A7;
      then
A11:  sk.a > 0 by A4;
A12:  I is_halting_on sk,P+*while>0(a,I) by A1;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:6;
      then consider n being Element of NAT such that
A13:  sk1 = Comput(P1, s1,n) by A9,A10,XXREAL_0:2;
      take m=n +(LifeSpan(P +* while>0(a,I) +* I,
      Initialize sk1) + 3
);
      sk1= Comput(P +* while>0(a,I), (Initialize sk),
      (LifeSpan(P +* while>0(a,I) +* I,Initialize sk) + 3)) &
      I is_closed_on sk,P+*while>0(a,I) by A1,Def5;
      then IC sk1 = 0 by A12,A11,Th42,A2;
      hence StepWhile>0(a,I,P,s).((k+1)+1)= Comput(P1, s1,m) by A13,Th45;
    end;
    hence P[k+1];
  end;
A14: P[ 0]
  proof
    assume 0+1 <= m;
    take n=(LifeSpan(P+*while>0(a,I)+* I,Initialize s) + 3);
    thus thesis by Th44;
  end;
A15: for k being Element of NAT holds P[k] from NAT_1:sch 1(A14,A8);
  now
    per cases;
    suppose
      m=0;
      then (StepWhile>0(a,I,P,s).0).a <= 0 by A4,A6;
      then s.a <= 0 by Def5;
      hence thesis by Th38;
    end;
    suppose
A16:  m<>0;
      set p=(LifeSpan(P+*while>0(a,I)+* I,Initialize s) + 3);
      set sm=StepWhile>0(a,I,P,s).m;
      set sm1=Initialize sm;
      consider i being Nat such that
A17:  m=i+1 by A16,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 12;
      m=i+1 by A17;
      then consider n being Element of NAT such that
A18:  sm = Comput(P1, s1,n) by A15;
      set si=StepWhile>0(a,I,P,s).i;
      i < m by A17,NAT_1:13;
      then F(i) <> 0 by A7;
      then
A19:  si.a > 0 by A4;
A20:  I is_closed_on si,P+*while>0(a,I) &
      I is_halting_on si,P+*while>0(a,I) by A1;
      sm= Comput(P +* while>0(a,I), (Initialize si),
      (LifeSpan(P +* while>0(a,I) +* I,Initialize si) + 3))
       by A17,Def5;
      then
A21:  IC sm = 0 by A20,A19,Th42,A2;
   sm is 0-started by A21,MEMSTR_0:def 12;
   then Start-At(0,SCM+FSA) c= sm by MEMSTR_0:29;
   then
A22:  sm1=sm by FUNCT_4:98;
A23:  sm.a <= 0 by A4,A6;
      then while>0(a,I) is_halting_on sm,P1 by Th38;
      then P1 +* while>0(a,I) halts_on Initialize sm by SCMFSA7B:def 7;
      then P1 halts_on sm1;
      then consider j being Element of NAT such that
A24:  CurInstr(P1,Comput(P1,sm,j))
        = halt SCM+FSA by A22,EXTPRO_1:29;
A25: Comput(P1,s1,n+j)
 = Comput(P1,Comput(P1,s1,n),j) by EXTPRO_1:4;
      CurInstr(P1,Comput(P1,s1,n+j))
       = halt SCM+FSA by A18,A24,A25;
      then P1 halts_on s1 by EXTPRO_1:29;
      hence while>0(a,I) is_halting_on s,P by SCMFSA7B:def 7;
      now
        let q be Element of NAT;
A26:    0<m by A16;
        per cases;
        suppose
A27:      q <= p;
A28:      StepWhile>0(a,I,P,s).0=s by Def5;
          then
A29:      I is_closed_on s,P+*while>0(a,I) &
          I is_halting_on s,P+*while>0(a,I) by A1;
          F(0) <> 0 by A7,A26;
          then s.a > 0 by A4,A28;
          hence IC Comput(P1,s1,q) in dom while>0(a,I) by A27,A29,Th42,A2;
        end;
        suppose
A30:      q > p;
A31:      now
            take k=p;
            thus StepWhile>0(a,I,P,s).1= Comput(P1, s1,k) & k <= q
by A30,Th44;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 &
           (ex k st StepWhile>0(a,I,P,s).$1
          = Comput(P1, s1,k) & k <= q);
A32:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A26,XREAL_1:6;
          then 1 <= m by NAT_1:13;
          then
A33:      ex t be Nat st P2[t] by A31;
          consider t be Nat such that
A34:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A32,A33);
          reconsider t as Element of NAT by ORDINAL1:def 12;
          now
            per cases;
            suppose
              t=m;
              then consider r being Element of NAT such that
A35:          sm= Comput(P1, s1,r) and
A36:          r <= q by A34;
              consider x being Nat such that
A37:          q = r+x by A36,NAT_1:10;
A38:          while>0(a,I) is_closed_on sm,P1 by A23,Th38;
              reconsider x as Element of NAT by ORDINAL1:def 12;
A39:          Comput(P1,s1,q) = Comput(P1, sm1,x) by A22,A35,A37,EXTPRO_1:4;
              thus IC Comput(P1,s1,q) in dom while>0(a,I) by A38,A39,A3,
SCMFSA7B:def 6;
            end;
            suppose
A40:          t<>m;
              set Dt=StepWhile>0(a,I,P,s).t;
A41:          t < m by A34,A40,XXREAL_0:1;
              then F(t) <> 0 by A7;
              then
A42:          Dt.a > 0 by A4;
              consider z being Element of NAT such that
A43:          StepWhile>0(a,I,P,s).t= Comput(P1, s1,z) and
A44:          z <= q by A34;
              set z2=z +(LifeSpan(P+*while>0(a,I) +* I,
                 Initialize Dt) + 3);
              consider w being Nat such that
A45:          q = z+w by A44,NAT_1:10;
A46:          I is_closed_on Dt,P+*while>0(a,I) &
              I is_halting_on Dt,P+*while>0(a,I) by A1;
              consider y being Nat such that
A47:          t=y+1 by A34,NAT_1:6;
              reconsider y as Element of NAT by ORDINAL1:def 12;
              set Dy=StepWhile>0(a,I,P,s).y;
              y+ 0 < t by A47,XREAL_1:6;
              then y < m by A34,XXREAL_0:2;
              then F(y) <> 0 by A7;
              then
A48:          Dy.a > 0 by A4;
A49:          I is_closed_on Dy,P+*while>0(a,I) &
              I is_halting_on Dy,P+*while>0(a,I) by A1;
              reconsider w as Element of NAT by ORDINAL1:def 12;
              Dt= Comput(P +* while>0(a,I),
                   (Initialize Dy),
              (LifeSpan(P +* while>0(a,I) +* I,
              Initialize Dy) + 3)) by A47,Def5;
              then
A50:          IC Dt = 0 by A49,A48,Th42,A2;
              now
                assume
A51:            z2 <= q;
A52:            now
                  take k=z2;
                  thus StepWhile>0(a,I,P,s).(t+1)= Comput(P1, s1,k)
& k <= q
by A43,A50,A51,Th45;
                end;
                t+1 <= m by A41,NAT_1:13;
                hence contradiction by A34,A52,XREAL_1:29;
              end;
              then
A53:          w < LifeSpan(P +* while>0(a,I) +* I,Initialize Dt) + 3
by A45,XREAL_1:6;
A54: Initialize Dt = Dt by A43,A50,Th45;
              Comput(P1,s1,q)
                = Comput(P +* while>0(a,I),
                (Initialize Dt),w) by A54,A43,A45,EXTPRO_1:4;
              hence IC Comput(P1,s1,q) in dom while>0(a,I) by A53,A46,A42,Th42
,A2;
            end;
          end;
          hence IC Comput(P1,s1,q) in dom while>0(a,I);
        end;
      end;
      hence while>0(a,I) is_closed_on s,P by SCMFSA7B:def 6;
    end;
  end;
  hence thesis;
end;

theorem Th47:
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location, s being State of SCM+FSA st
  ex f being Function of product the_Values_of SCM+FSA,NAT st (for k being Nat
 holds (f.(StepWhile>0(a,I,P,s).(k+
  1)) < f.(StepWhile>0(a,I,P,s).k) or f.(StepWhile>0(a,I,P,s).k) = 0) & ( f.(
StepWhile>0(a,I,P,s).k)=0 iff (StepWhile>0(a,I,P,s).k).a <= 0 ) )
 holds while>0(a,I
  ) is_halting_on s,P & while>0(a,I) is_closed_on s,P
proof
  let I be parahalting Program of SCM+FSA,a be read-write Int-Location,s be
  State of SCM+FSA;
A1: for k being Nat holds
    I is_closed_on StepWhile>0(a,I,P,s).k,P+*while>0(a,I) &
    I is_halting_on StepWhile>0(a,I,P,s).k,P+*while>0(a,I) by SCMFSA7B:18,19;
  assume ex f being Function of product the_Values_of SCM+FSA,NAT st for
k being Nat holds (f.(StepWhile>0(a,I,P,s).(k+1)) < f.(StepWhile>0(a,I,P,s).k)
 or f
.(StepWhile>0(a,I,P,s).k) = 0) & ( f.(StepWhile>0(a,I,P,s).k)=0
 iff (StepWhile>0(a,I,P,s).k).a <= 0 );
  hence thesis by A1,Th46;
end;

theorem
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location st ex f being Function of product the_Values_of SCM+FSA,NAT
st (for s being State of SCM+FSA,P holds (f.(StepWhile>0(a,I,P,s).1) < f.s
 or f.s =
  0) & ( f.s =0 iff s.a <= 0 )) holds while>0(a,I) is parahalting
proof
  let I be parahalting Program of SCM+FSA,a be read-write Int-Location;
  given f being Function of product the_Values_of SCM+FSA,NAT such that
A1: for s being State of SCM+FSA,P holds (f.(StepWhile>0(a,I,P,s).1) < f.s
  or f.s = 0) & ( f.s =0 iff s.a <= 0 );
  now
    let t be State of SCM+FSA;
    let Q;
    now
      let k be Nat;
A2:   k in NAT by ORDINAL1:def 12;
      f.(StepWhile>0(a,I,Q,StepWhile>0(a,I,Q,t).k).1)
       < f.(StepWhile>0(a,I,Q,t).
      k) or f.(StepWhile>0(a,I,Q,t).k) = 0 by A1;
      hence (f.(StepWhile>0(a,I,Q,t).(k+1)) < f.(StepWhile>0(a,I,Q,t).k) or f.(
StepWhile>0(a,I,Q,t).k) = 0) & ( f.(StepWhile>0(a,I,Q,t).k)=0
 iff (StepWhile>0(a,I,Q,
      t).k).a <= 0 ) by A1,A2,Th43;
    end;
    hence while>0(a,I) is_halting_on t,Q by Th47;
  end;
  hence thesis by SCMFSA7B:19;
end;

registration
  let I,J be good Program of SCM+FSA,a be Int-Location;
  cluster if>0(a,I,J) -> good;
  coherence
  proof
    set i = a >0_goto  (card J + 3);
    reconsider Mi=Macro i as good Program of SCM+FSA by Th31,SCMFSA7B:13;
    if>0(a,I,J) = i ";" J ";" Goto  (card I + 1) ";" I ";" Stop
    SCM+FSA by SCMFSA8B:def 2
      .= Mi ";" J ";" Goto  (card I + 1) ";" I ";" Stop SCM+FSA;
    hence thesis;
  end;
end;

registration
  let I be good Program of SCM+FSA,a be Int-Location;
  cluster while>0(a,I) -> good;
  correctness
  proof
    set F=if>0(a, I ";" Goto  0, Stop SCM+FSA);
    set J= (card I +4) .--> goto  0;
    J does not destroy intloc 0 & F does not destroy intloc 0 by Th30,
SCMFSA7B:def 5;
    then while>0(a,I) does not destroy intloc 0 by SCMFSA8A:11;
    hence thesis by SCMFSA7B:def 5;
  end;
end;

