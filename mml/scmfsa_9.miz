:: While Macro Instructions of SCM+FSA
::  by Jing-Chao Chen
::
:: Received December 10, 1997
:: Copyright (c) 1997-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, AMI_1, SCMFSA_2, CARD_1, SCMFSA8B, TURING_1, SCMFSA8A,
      AMISTD_2, ARYTM_3, SUBSET_1, FUNCT_4, FUNCOP_1, AMI_3, RELAT_1, TARSKI,
      XBOOLE_0, CAT_1, NAT_1, SCMFSA6A, FUNCT_1, XXREAL_0, VALUED_1, CARD_3,
      ARYTM_1, FSM_1, SF_MASTR, SCMFSA7B, UNIALG_2, CIRCUIT2, GRAPHSP,
      SCMFSA6B, SCMFSA_9, PBOOLE, ORDINAL1, PARTFUN1, SCMNORM, RELOC, SCMFSA6C;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, RELAT_1,
      FUNCT_1, FUNCT_2, PARTFUN1, AFINSQ_1, FUNCT_4, CARD_3, COMPOS_1,
      EXTPRO_1, VALUED_1, PBOOLE,
      NAT_1, AMISTD_2, SCMFSA_2, SCMFSA6A, SF_MASTR,
      SCMFSA6B, SCMFSA7B, SCMFSA8A, SCMFSA8B, XXREAL_0;
 constructors XXREAL_0, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA8A,
      SCMFSA8B, AMISTD_2, RELSET_1, PRE_POLY, PBOOLE, SCMFSA7B, DOMAIN_1,
      AMISTD_1;
 registrations SETFAM_1, FUNCT_1, RELSET_1, NUMBERS, XREAL_0, NAT_1, INT_1,
      CARD_3, SCMFSA_2, SF_MASTR, SCMFSA6B, SCMFSA7B, SCMFSA8A, ORDINAL1,
      XBOOLE_0, FINSET_1, VALUED_1, FUNCT_4, FUNCT_2, XXREAL_0,
      VALUED_0, AFINSQ_1, FUNCOP_1, SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1,
      PBOOLE, RELAT_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions SCMFSA6A, FUNCOP_1, PBOOLE, AFINSQ_1, COMPOS_1, EXTPRO_1,
      AMISTD_2;
 theorems TARSKI, NAT_1, FUNCT_1, FUNCT_4, SCMFSA_2, SCMFSA_4, SCMFSA6A,
      GRFUNC_1, SCMFSA6B, SCMFSA7B, SCMFSA8A, SCMFSA8B, ZFMISC_1, XBOOLE_0,
      XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0, VALUED_1, FUNCOP_1, PBOOLE,
      AFINSQ_1, PARTFUN1, RELAT_1, COMPOS_1, EXTPRO_1;
 schemes NAT_1;

begin

reserve P,Q for (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;

Lm1: card Stop SCM+FSA = 1 by COMPOS_1:46;
Lm2: (Stop SCM+FSA).0 = halt SCM+FSA by AFINSQ_1:38;
Lm3: 0 in dom Stop SCM+FSA by COMPOS_1:45;

set SA0= Start-At(0,SCM+FSA);

theorem Th1:
  for I being Program of SCM+FSA, a being Int-Location holds card
  if=0(a, I ';' Goto  0, Stop SCM+FSA) = card I + 6
proof
  let I be Program of SCM+FSA, a be Int-Location;
  thus card if=0(a, I ';' Goto  0, Stop SCM+FSA) = card (I ';' Goto
   0) + 1 +4 by Lm1,SCMFSA8B:14
    .= card I + card Goto  0 + 1+4 by SCMFSA6A:61
    .= card I + 1+1+4 by SCMFSA8A:29
    .= card I + 6;
end;

theorem Th2:
  for I being Program of SCM+FSA, a being Int-Location holds card
  if>0(a, I ';' Goto  0, Stop SCM+FSA) = card I + 6
proof
  let I be Program of SCM+FSA, a be Int-Location;
  thus card if>0(a, I ';' Goto  0, Stop SCM+FSA) = card (I ';' Goto
   0) + 1 +4 by Lm1,SCMFSA8B:15
    .= card I + card Goto  0 + 1+4 by SCMFSA6A:61
    .= card I + 1+1+4 by SCMFSA8A:29
    .= card I + 6;
end;

:: WHILE  Statement

reserve m, n for Element of NAT;

definition
  let a be Int-Location;
  let I be Program of SCM+FSA;
  func while=0(a,I) -> Program of SCM+FSA equals
  if=0(a, I ';' Goto  0,
  Stop SCM+FSA) +* (  (card I +4) .--> goto  0 );
  correctness
  proof
    set C = if=0(a, I ';' Goto  0, Stop SCM+FSA);
    set i =  (card I +4) .--> goto  0;
    set P = C +* i;
    card C = card I + 6 & card I + 4 < card I + 6 by Th1,XREAL_1:8;
    then  (card I + 4) in dom C by AFINSQ_1:70;
    then
A1: { (card I + 4)} c= dom C by ZFMISC_1:37;
A2: dom(P) = dom C \/ dom i by FUNCT_4:def 1
      .= dom C \/ { (card I + 4)} by FUNCOP_1:19
      .= dom C by A1,XBOOLE_1:12;
    P is initial
    proof
      let m,n be Nat;
      thus thesis by A2,AFINSQ_1:def 13;
    end;
    hence thesis;
  end;
  func while>0(a,I) -> Program of SCM+FSA equals
  if>0(a, I ';' Goto  0,
  Stop SCM+FSA) +* (  (card I +4) .--> goto  0 );
  correctness
  proof
    set C = if>0(a, I ';' Goto  0, Stop SCM+FSA);
    set i =  (card I +4) .--> goto  0;
    set P = C +* i;
    card C = card I + 6 & card I + 4 < card I + 6 by Th2,XREAL_1:8;
    then  (card I + 4) in dom C by AFINSQ_1:70;
    then
A3: { (card I + 4)} c= dom C by ZFMISC_1:37;
A4: dom(P) = dom C \/ dom i by FUNCT_4:def 1
      .= dom C \/ { (card I + 4)} by FUNCOP_1:19
      .= dom C by A3,XBOOLE_1:12;
    P is initial
    proof
      let m,n be Nat;
      thus thesis by A4,AFINSQ_1:def 13;
    end;
    hence thesis;
  end;
end;

theorem Th3:
  for I being Program of SCM+FSA, a being Int-Location holds card
  if=0(a,Stop SCM+FSA,if>0(a,Stop SCM+FSA,I ';' Goto  0)) = card I + 11
proof
  let I be Program of SCM+FSA, a be Int-Location;
  thus card if=0(a,Stop SCM+FSA,if>0(a,Stop SCM+FSA,I ';' Goto  0)) = 1
+ card if>0(a,Stop SCM+FSA,I ';' Goto  0) +4 by Lm1,SCMFSA8B:14
    .= card (I ';' Goto  0) + 1+ 4 + 1+4 by Lm1,SCMFSA8B:15
    .= card I + card Goto  0 +1+ 4 + 1+4 by SCMFSA6A:61
    .= card I + 1 + 1 +4 + 1 + 4 by SCMFSA8A:29
    .= card I + 11;
end;

definition
  let a be Int-Location;
  let I be Program of SCM+FSA;
  func while<0(a,I) -> Program of SCM+FSA equals
  if=0(a,Stop SCM+FSA,if>0(a,
Stop SCM+FSA,I ';' Goto  0)) +* (  (card I +4) .--> goto  0 )
  ;
  correctness
  proof
    set C = if=0(a,Stop SCM+FSA,if>0(a,Stop SCM+FSA,I ';' Goto  0));
    set i =  (card I +4) .--> goto  0;
    set P = C +* i;
    card C = card I + 11 & card I + 4 < card I + 11 by Th3,XREAL_1:8;
    then  (card I + 4) in dom C by AFINSQ_1:70;
    then
A1: { (card I + 4)} c= dom C by ZFMISC_1:37;
A2: dom(P) = dom C \/ dom i by FUNCT_4:def 1
      .= dom C \/ { (card I + 4)} by FUNCOP_1:19
      .= dom C by A1,XBOOLE_1:12;
    P is initial
    proof
      let m,n be Nat;
      thus thesis by A2,AFINSQ_1:def 13;
    end;
    hence thesis;
  end;
end;

theorem Th4:
  for I being Program of SCM+FSA, a being Int-Location holds card
  while=0(a,I) = card I + 6
proof
  let I be Program of SCM+FSA, a be Int-Location;
  set i =  (card I +4) .--> goto  0;
  set C = if=0(a, I ';' Goto  0, Stop SCM+FSA);
  set P = C +* i;
A1: card C = card I + 6 by Th1;
  card I + 4 < card I + 6 by XREAL_1:8;
  then  (card I + 4) in dom C by A1,AFINSQ_1:70;
  then
A2: { (card I + 4)} c= dom C by ZFMISC_1:37;
  dom(P) = dom C \/ dom i by FUNCT_4:def 1
    .= dom C \/ { (card I + 4)} by FUNCOP_1:19
    .= dom C by A2,XBOOLE_1:12;
  hence card while=0(a,I) = card I + 6 by A1;
end;

theorem Th5:
  for I being Program of SCM+FSA, a being Int-Location holds card
  while>0(a,I) = card I + 6
proof
  let I be Program of SCM+FSA, a be Int-Location;
  set i =  (card I +4) .--> goto  0;
  set C = if>0(a, I ';' Goto  0, Stop SCM+FSA);
  set P = C +* i;
A1: card C = card I + 6 by Th2;
  card I + 4 < card I + 6 by XREAL_1:8;
  then  (card I + 4) in dom C by A1,AFINSQ_1:70;
  then
A2: { (card I + 4)} c= dom C by ZFMISC_1:37;
  dom(P) = dom C \/ dom i by FUNCT_4:def 1
    .= dom C \/ { (card I + 4)} by FUNCOP_1:19
    .= dom C by A2,XBOOLE_1:12;
  hence card while>0(a,I) = card I + 6 by A1;
end;

theorem
  for I being Program of SCM+FSA, a being Int-Location holds card
  while<0(a,I) = card I + 11
proof
  let I be Program of SCM+FSA, a be Int-Location;
  set i =  (card I +4) .--> goto  0;
  set C = if=0(a,Stop SCM+FSA,if>0(a,Stop SCM+FSA,I ';' Goto  0));
  set P = C +* i;
A1: card C = card I + 11 by Th3;
  card I + 4 < card I + 11 by XREAL_1:8;
  then  (card I + 4) in dom C by A1,AFINSQ_1:70;
  then
A2: { (card I + 4)} c= dom C by ZFMISC_1:37;
  dom(P) = dom C \/ dom i by FUNCT_4:def 1
    .= dom C \/ { (card I + 4)} by FUNCOP_1:19
    .= dom C by A2,XBOOLE_1:12;
  hence card while<0(a,I) = card I + 11 by A1;
end;

theorem
  for a being Int-Location, l being Element of NAT
  holds a =0_goto l <> halt SCM+FSA;

theorem
  for a being Int-Location, l being Element of NAT
  holds a >0_goto l <> halt SCM+FSA;

theorem
  for l being Element of NAT holds goto l <> halt
  SCM+FSA;

theorem Th10:
  for a being Int-Location, I being Program of SCM+FSA holds
   0 in dom while=0(a,I) &  1 in dom while=0(a,I) &  0 in dom
  while>0(a,I) &  1 in dom while>0(a,I)
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
  if=0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)) by
SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop
  SCM+FSA)));
  then
A1: dom Macro i c= dom if=0(a,I1,J) by SCMFSA6A:56;
  dom Macro i = { 0,  1} by COMPOS_1:149;
  then
A2:  0 in dom Macro i &  1 in dom Macro i by TARSKI:def 2;
  dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then dom if=0(a,I1,J) c= dom while=0(a,I) by XBOOLE_1:7;
  then dom Macro i c= dom while=0(a,I) by A1,XBOOLE_1:1;
  hence  0 in dom while=0(a,I) &  1 in dom while=0(a,I) by A2;
  set i = a >0_goto  (card J + 3);
  if>0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)) by
SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop
  SCM+FSA)));
  then
A3: dom Macro i c= dom if>0(a,I1,J) by SCMFSA6A:56;
  dom Macro i = { 0,  1} by COMPOS_1:149;
  then
A4:  0 in dom Macro i &  1 in dom Macro i by TARSKI:def 2;
  dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then dom if>0(a,I1,J) c= dom while>0(a,I) by XBOOLE_1:7;
  then dom Macro i c= dom while>0(a,I) by A3,XBOOLE_1:1;
  hence thesis by A4;
end;

theorem Th11:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I). 0 = a =0_goto  4 & while=0(a,I). 1 = goto
 2 & while>0(a,I). 0 = a >0_goto  4 & while>0(a,I). 1 =
  goto  2
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
A1: dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f by FUNCT_4:def 1;
A2: dom f = { (card I + 4)} by FUNCOP_1:19;
  then
A3: not  0 in dom f;
A4: dom Macro i = { 0,  1} by COMPOS_1:149;
  then
A5:  0 in dom Macro i by TARSKI:def 2;
A6:  1 in dom Macro i by A4,TARSKI:def 2;
A7: if=0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)) by
SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop
  SCM+FSA)));
  1 <> card I + 4 by NAT_1:11;
  then
A8: not  1 in dom f by A2,TARSKI:def 1;
   0 in dom while=0(a,I) by Th10;
  hence while=0(a,I). 0 =if=0(a,I1,J). 0 by A3,A1,FUNCT_4:def 1
    .= (Directed Macro i). 0 by A7,A5,SCMFSA8A:28
    .= a =0_goto  4 by Lm1,SCMFSA7B:7;
A9: dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f by FUNCT_4:def 1;
   1 in dom while=0(a,I) by Th10;
  hence while=0(a,I). 1 =if=0(a,I1,J). 1 by A1,A8,FUNCT_4:def 1
    .= (Directed Macro i). 1 by A7,A6,SCMFSA8A:28
    .= goto  2 by SCMFSA7B:8;
  set i = a >0_goto  (card J + 3);
A10: if>0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)) by
SCMFSA6A:67
    .= i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)))
  by SCMFSA6A:71
    .= Macro i ';' (J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop
  SCM+FSA)));
A11: dom Macro i = { 0,  1} by COMPOS_1:149;
  then
A12:  0 in dom Macro i by TARSKI:def 2;
A13:  1 in dom Macro i by A11,TARSKI:def 2;
   0 in dom while>0(a,I) by Th10;
  hence while>0(a,I). 0 = if>0(a,I1,J). 0 by A3,A9,FUNCT_4:def 1
    .= (Directed Macro i). 0 by A10,A12,SCMFSA8A:28
    .= a >0_goto  4 by Lm1,SCMFSA7B:7;
   1 in dom while>0(a,I) by Th10;
  hence while>0(a,I). 1 = if>0(a,I1,J). 1 by A8,A9,FUNCT_4:def 1
    .= (Directed Macro i). 1 by A10,A13,SCMFSA8A:28
    .= goto  2 by SCMFSA7B:8;
end;

theorem Th12:
  for a being Int-Location, I being Program of SCM+FSA, k being
  Element of NAT st k < 6 holds  k in dom while=0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
A1: 6 <= card I + 6 by NAT_1:11;
A2: card while=0(a,I) = card I + 6 by Th4;
  assume k < 6;
  then k < card I + 6 by A1,XXREAL_0:2;
  hence thesis by A2,AFINSQ_1:70;
end;

theorem Th13:
  for a being Int-Location, I being Program of SCM+FSA, k being
  Element of NAT st k < 6 holds card I +k in dom while=0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
  assume k < 6;
  then
A1: card I + k < card I + 6 by XREAL_1:8;
  card while=0(a,I) = card I + 6 by Th4;
  hence thesis by A1,AFINSQ_1:70;
end;

theorem Th14:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I).(card I +5) = halt SCM+FSA
proof
  set J1= Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
  set c5 = card I + 5;
  set Lc5=c5;
  set Mi= Macro i ';' J ';' Goto  (card I1 + 1) ';' I1;
  dom f = { (card I + 4)} & Lc5 <>  (card I + 4) by FUNCOP_1:19;
  then
A1: not Lc5 in dom f by TARSKI:def 1;
   0 + c5 in { il+c5 where il is Element of NAT: il in dom J1} by Lm3;
  then
A2:  c5 in dom Shift(J1,c5) by VALUED_1:def 12;
  then
A3: Shift(J1,c5)/.Lc5 = Shift(J1,c5).(0 +c5) by PARTFUN1:def 8
    .= halt SCM+FSA by Lm2,Lm3,VALUED_1:def 12;
A4: Lc5 in dom while=0(a,I) & dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f
  by Th13,FUNCT_4:def 1;
  then
A5: Lc5 in dom if=0(a,I1,J) by A1,XBOOLE_0:def 3;
A6: if=0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 1
    .= Mi ';' J1;
  then card if=0(a, I1,J) = card Mi + card J1 by SCMFSA6A:61;
  then
A7: card Mi = card if=0(a,I1,J)-card J1
    .= card I + 6 - 1 by Th1,Lm1
    .= c5;
  then
A8: not Lc5 in dom Mi;
A9: dom if=0(a,I1,J) = dom Directed Mi \/ dom Reloc(J, c5)
  by A6,A7,FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom Reloc(J, c5) by
FUNCT_4:105;
  then
A10: Lc5 in dom Reloc(J, c5) by A5,A8,XBOOLE_0:def 3;
  thus while=0(a,I).Lc5 = (Directed Mi +* Reloc(J, c5)).Lc5
  by A1,A4,A6,A7,FUNCT_4:def 1
    .= (Reloc(J,c5)).Lc5 by A5,A9,A10,FUNCT_4:def 1
    .= IncAddr( halt SCM+FSA, c5 ) by A2,A3,COMPOS_1:def 40
    .= halt SCM+FSA by COMPOS_1:93;
end;

theorem Th15:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I). 3 = goto  (card I +5)
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
  set Mi=Macro i ';' J;
  set G=Goto  (card I1 + 1);
  set J2= (I1 ';' Stop SCM+FSA);
  set J1=G ';' J2;
A1:  0 in dom G by SCMFSA8A:47;
A2: G. 0 = goto  (card I1 + 1) by SCMFSA8A:47
    .= goto  (card I + card Goto  0 + 1) by SCMFSA6A:61
    .= goto  (card I + 1 + 1) by SCMFSA8A:29
    .= goto  (card I +(1+1));
  dom J1 = dom Directed G \/ dom Reloc(J2, card G) by
FUNCT_4:def 1
    .= dom G \/ dom Reloc(J2, card G) by FUNCT_4:105;
  then
A3:  0 in dom J1 by A1,XBOOLE_0:def 3;
  then  0 + 3 in { il+3 where il is Element of NAT: il in dom J1};
  then
A4:  3 in dom Shift(J1,3) by VALUED_1:def 12;
  then
A5: Shift(J1,3)/.3 =Shift(J1,3).( 0 +3) by PARTFUN1:def 8
    .=J1. 0 by A3,VALUED_1:def 12
    .=(Directed G). 0 by A1,SCMFSA8A:28
    .=goto  (card I + 2) by A1,A2,SCMFSA8A:30;
  dom f = { (card I + 4)} & 3 <> card I + 4 by FUNCOP_1:19,NAT_1:11;
  then
A6: not  3 in dom f by TARSKI:def 1;
A7: card Mi = card Macro i + card J by SCMFSA6A:61
    .= 2 + 1 by Lm1,COMPOS_1:150;
  then
A8: not  3 in dom Mi;
A9:  3 in dom while=0(a,I) & dom while=0(a,I) = dom if=0(a,I1,J) \/
  dom f by Th12,FUNCT_4:def 1;
  then
A10:  3 in dom if=0(a,I1,J) by A6,XBOOLE_0:def 3;
A11: if=0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= Mi ';' J1 by SCMFSA6A:67
    .= Directed Mi +* Reloc(J1, 3) by A7;
  then
A12: dom if=0(a,I1,J) = dom Directed Mi \/ dom Reloc(J1, 3)
  by FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom Reloc(J1, 3) by
FUNCT_4:105;
  then
A13:  3 in dom Reloc(J1, 3) by A10,A8,XBOOLE_0:def 3;
  thus while=0(a,I). 3 = (Directed Mi +* Reloc(J1, 3)).
   3 by A6,A9,A11,FUNCT_4:def 1
    .= (Reloc(J1,3)). 3 by A10,A12,A13,FUNCT_4:def 1
    .= IncAddr(goto  (card I +2),3) by A4,A5,COMPOS_1:def 40
    .= goto (card I +2 + 3) by SCMFSA_4:14
    .= goto (card I+ 5);
end;

theorem Th16:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I). 2 = goto  3
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a =0_goto  (card J + 3);
  set Mi=Macro i;
  set J2=Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA);
  set J1=J ';' J2;
  dom f = { (card I + 4)} & 2 <> card I + 4 by FUNCOP_1:19,NAT_1:11;
  then
A1: not  2 in dom f by TARSKI:def 1;
  dom J1 = dom Directed J \/ dom Reloc(J2, card J) by
FUNCT_4:def 1
    .= dom J \/ dom Reloc(J2, card J) by FUNCT_4:105;
  then
A2:  0 in dom J1 by Lm3,XBOOLE_0:def 3;
  then  0 + 2 in { il+2 where il is Element of NAT: il in dom J1};
  then
A3:  2 in dom Shift(J1,2) by VALUED_1:def 12;
  then
A4: Shift(J1,2)/.2 =Shift(J1,2).( 0 +2) by PARTFUN1:def 8
    .=J1. 0 by A2,VALUED_1:def 12
    .=(Directed J). 0 by Lm3,SCMFSA8A:28
    .=goto  card J by Lm2,Lm3,SCMFSA8A:30;
  card Mi = 2 by COMPOS_1:150;
  then
A5: not  2 in dom Mi;
A6:  2 in dom while=0(a,I) & dom while=0(a,I) = dom if=0(a,I1,J) \/
  dom f by Th12,FUNCT_4:def 1;
  then
A7:  2 in dom if=0(a,I1,J) by A1,XBOOLE_0:def 3;
A8: if=0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 1
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)) by
SCMFSA6A:67
    .= i ';' J1 by SCMFSA6A:71
    .= Directed Mi +* Reloc(J1, 2) by COMPOS_1:150;
  then
A9: dom if=0(a,I1,J) = dom Directed Mi \/ dom Reloc(J1, 2)
  by FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom Reloc(J1, 2) by
FUNCT_4:105;
  then
A10:  2 in dom Reloc(J1, 2) by A7,A5,XBOOLE_0:def 3;
  thus while=0(a,I). 2 = (Directed Mi +* Reloc(J1, 2)).
   2 by A1,A6,A8,FUNCT_4:def 1
    .= (Reloc(J1,2)). 2 by A7,A9,A10,FUNCT_4:def 1
    .= IncAddr(goto  card J,2) by A3,A4,COMPOS_1:def 40
    .= goto ( 1 + 2) by Lm1,SCMFSA_4:14
    .= goto  3;
end;

theorem
  for a being Int-Location, I being Program of SCM+FSA,k being Element
  of NAT st k < card I +6 holds  k in dom while=0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
  assume
A1: k < card I +6;
  card while=0(a,I) = card I + 6 by Th4;
  hence thesis by A1,AFINSQ_1:70;
end;

theorem Th18:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location st s.a <> 0
 holds while=0(a,I) is_halting_on s,P &
  while=0(a,I) is_closed_on s,P
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a <> 0;
  set i = a =0_goto  4;
  set s1 = Initialize s,
      P1 = P +* while=0(a,I);
A3: IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
A4: IC s1 = IC Start-At(0,SCM+FSA) by A3,FUNCT_4:14
    .=  0 by COMPOS_1:64;
  set loc5=  (card I +5);
  set s5 = Comput(P1,s1,4);
  set s4 = Comput(P1,s1,3);
  set s3 = Comput(P1,s1,2);
  set s2 = Comput(P1,s1,1);
A5:  1 in dom while=0(a,I) by Th10;
A6:  2 in dom while=0(a,I) by Th12;
    Start-At(0,SCM+FSA) c= Initialize while=0(a,I) by FUNCT_4:26;
    then
X1: dom Start-At(0,SCM+FSA) c= dom Initialize while=0(a,I)
          by RELAT_1:25;
  not a in dom Initialize while=0(a,I) by SCMFSA6B:12;
  then not a in dom Start-At(0,SCM+FSA) by X1;
  then
A7: s1.a = s.a by FUNCT_4:12;
A8:  P1/.IC s1 = P1.IC s1 by PBOOLE:158;
A9:  0 in dom while=0(a,I) by Th10;
  then P1. 0 = (while=0(a,I)). 0 by FUNCT_4:14
    .= i by Th11;
  then
A10: CurInstr(P1,s1) = i by A4,A8;
A11: Comput(P1,s1,0+1) = Following(P1,Comput(P1,s1,0)) by EXTPRO_1:4
    .= Following(P1,s1) by EXTPRO_1:3
    .= Exec(i,s1) by A10;
A12: IC Comput(P1,s1,1) = succ  0 by A1,A4,A11,A7,SCMFSA_2:96
    .=  (0 + 1);
A13:  (P1)/.IC Comput(P1,s1,1) = P1.IC Comput(P1,s1,1) by PBOOLE:158;
    P1. 1 = (while=0(a,I)). 1 by A5,FUNCT_4:14
    .= goto  2 by Th11;
  then
A14: CurInstr(P1,Comput(P1,s1,1)) = goto  2 by A12,A13;
A15: Comput(P1,s1,1+1) = Following(P1,s2) by EXTPRO_1:4
    .= Exec(goto  2,s2) by A14;
A16: IC s3 =  2 by A15,SCMFSA_2:95;
A17:  P1/.IC s3 = P1.IC s3 by PBOOLE:158;
  P1. 2 = (while=0(a,I)). 2 by A6,FUNCT_4:14
    .= goto  3 by Th16;
  then
A18: CurInstr(P1,s3) = goto  3 by A16,A17;
A19: Comput(P1,s1,2+1) = Following(P1,s3) by
EXTPRO_1:4
    .= Exec(goto  3,s3) by A18;
A20: IC s4 =  3 by A19,SCMFSA_2:95;
A21:  3 in dom while=0(a,I) by Th12;
A22: loc5 in dom while=0(a,I) by Th13;
A23:  P1/.IC s4 = P1.IC s4 by PBOOLE:158;
  P1. 3 = (while=0(a,I)). 3 by A21,FUNCT_4:14
    .= goto loc5 by Th15;
  then
A24: CurInstr(P1,s4) = goto loc5 by A20,A23;
A25: Comput(P1,s1,3+1) = Following(P1,s4) by
EXTPRO_1:4
    .= Exec(goto loc5,s4) by A24;
A26: IC s5 = loc5 by A25,SCMFSA_2:95;
A27:  P1/.IC s5 = P1.IC s5 by PBOOLE:158;
  P1.loc5 = (while=0(a,I)).loc5 by A22,FUNCT_4:14
    .= halt SCM+FSA by Th14;
  then
A28: CurInstr(P1,s5) = halt SCM+FSA by A26,A27;
  then P1 halts_on s1 by EXTPRO_1:30;
  hence while=0(a,I) is_halting_on s,P by SCMFSA7B:def 8;
  now
    let k be Element of NAT;
A29: k<=3 or k >= 3+1 by NAT_1:13;
    per cases by A29,NAT_1:28;
    suppose
      k = 0;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A9,A4,
EXTPRO_1:3;
    end;
    suppose
      k = 1;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A12,Th10;
    end;
    suppose
      k = 2;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A16,Th12;
    end;
    suppose
      k = 3;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A20,Th12;
    end;
    suppose
      k >= 4;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A22,A26,A28
,EXTPRO_1:6;
    end;
  end;
  hence thesis by SCMFSA7B:def 7;
end;

theorem Th19:
  for a being Int-Location, I being Program of SCM+FSA, s being
State of SCM+FSA,k being Element of NAT
 st I is_closed_on s,P & I is_halting_on s,P
& k < LifeSpan(P +* I,Initialize s) &
IC Comput(P +* while=0(a,I),
 (Initialize s),1+k)
   = IC Comput(P +* I, (Initialize s),k) + 4 &
    DataPart Comput(P +* while=0(a,I),
     (Initialize s),1+k)
    = DataPart Comput(P +* I,
     (Initialize s),k)
  holds IC Comput(P +* while=0(a,I),
   (Initialize s),1+k+1) = IC
Comput(P +* I, (Initialize s),k+1) + 4 &
DataPart Comput(P +* while=0(a,I),
   (Initialize s),1+k+1) =
DataPart Comput(P +* I, (Initialize s),k+1)
proof
  set J3= Goto  0 ';' Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  let k be Element of NAT;
  set s1 = Initialize s,
      P1 = P +* while=0(a,I);
  set sI = Initialize s,
      PI = P +* I;
A1: I c= PI by FUNCT_4:26;
  set sK1= Comput(P1, s1,1+k);
  set sK2= Comput(PI, sI,k);
  set l3=IC Comput(PI, sI,k);
  set I1= I ';' Goto  0;
  set i = a =0_goto  (card J + 3);
  reconsider n = l3 as Element of NAT;
  set Mi= i ';' J ';' Goto  (card I1 + 1);
  set J2= I1 ';' Stop SCM+FSA;
A3: rng I c= the Instructions of SCM+FSA by RELAT_1:def 19;
  assume I is_closed_on s,P;
  then
A4:  n in dom I by SCMFSA7B:def 7;
  then n < card I by AFINSQ_1:70;
  then
A5: n+4 < card I+ 6 by XREAL_1:10;
A6:  PI/.IC sK2 = PI.IC sK2 by PBOOLE:158;
A7: CurInstr(PI,sK2) =PI. n by A6
    .= I. n by A4,A1,GRFUNC_1:8;
  assume I is_halting_on s,P;
  then
A8: PI halts_on sI by SCMFSA7B:def 8;
  assume k < LifeSpan(PI,sI);
  then
A9: I. n <> halt SCM+FSA by A7,A8,EXTPRO_1:def 14;
A10: J2= I ';' J3 by SCMFSA6A:67;
  then dom J2 = dom Directed I \/ dom Reloc(J3, card I) by
FUNCT_4:def 1
    .= dom I \/ dom Reloc(J3, card I) by FUNCT_4:105;
  then
A11:  n in dom J2 by A4,XBOOLE_0:def 3;
  then  n + 4 in { il+4 where il is Element of NAT: il in dom J2};
  then
A12:  (n+4) in dom Shift(J2,4) by VALUED_1:def 12;
  then
A13: Shift(J2,4)/.(n+4) =Shift(J2,4).( n +4) by PARTFUN1:def 8
    .=J2. n by A11,VALUED_1:def 12
    .=(Directed I). n by A4,A10,SCMFSA8A:28
    .=I. n by A4,A9,SCMFSA8A:30;
  card while=0(a,I) = card I + 6 by Th4;
  then
A14:  (n+4) in dom while=0(a,I) by A5,AFINSQ_1:70;
  I. n in rng I by A4,FUNCT_1:def 5;
  then reconsider j = I. n as Instruction of SCM+FSA by A3;
A15: card Mi = card (i ';' J )+ card Goto  (card I1 + 1) by SCMFSA6A:61
    .= card (i ';' J ) + 1 by SCMFSA8A:29
    .= card (Macro i) + card J + 1 by SCMFSA6A:61
    .= 2 + 1 +1 by Lm1,COMPOS_1:150
    .= 3+ 1;
  then n+4 >= card Mi by NAT_1:11;
  then
A16: not  (n+4) in dom Mi by AFINSQ_1:70;
A17: Comput(PI, sI,k+1) = Following(PI,sK2) by
EXTPRO_1:4
    .= Exec(j,sK2) by A7;
  set f =  (card I +4) .--> goto  0;
  assume
A18: IC Comput(P1, s1,1+k)=l3 + 4;
  dom f = { (card I + 4)} & n + 4 <> card I + 4 by A4,FUNCOP_1:19;
  then
A19: not  (n+4) in dom f by TARSKI:def 1;
A20: dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then
A21:  (n+4) in dom if=0(a,I1,J) by A19,A14,XBOOLE_0:def 3;
A22: if=0(a, I1, J) = Mi ';' I1 ';' Stop SCM+FSA by SCMFSA8B:def 1
    .= Mi ';' J2 by SCMFSA6A:67
    .= Directed Mi +* Reloc(J2, 4) by A15;
  then
A23: dom if=0(a,I1,J) = dom Directed Mi \/ dom Reloc(J2, 4 )
  by FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom Reloc(J2, 4) by
FUNCT_4:105;
  then
A24:  (n+4) in dom Reloc(J2, 4) by A21,A16,XBOOLE_0:def 3
;
A25:  (P1)/.IC sK1 = P1.IC sK1 by PBOOLE:158;
  P1. (n+4) = (while=0(a,I)). (n+4) by A14,FUNCT_4:14
    .= (Directed Mi +* Reloc(J2, 4)). (n+4) by A19,A14,A20,A22,
FUNCT_4:def 1
    .= (Reloc(J2,4)). (n+4) by A21,A23,A24,FUNCT_4:def 1
    .= IncAddr(j,4) by A12,A13,COMPOS_1:def 40;
  then
A26: CurInstr(P1,sK1) =IncAddr(j,4) by A18,A25;
  assume
A27: DataPart sK1 = DataPart sK2;
  Comput(P1, s1,1+k+1) = Following(P1,sK1) by
EXTPRO_1:4
    .= Exec(IncAddr(j,4),sK1) by A26;
  hence thesis by A18,A27,A17,SCMFSA6A:41;
end;

theorem Th20:
  for a being Int-Location, I being Program of SCM+FSA, s being
  State of SCM+FSA st I is_closed_on s,P & I is_halting_on s,P &
  IC Comput(P +* while=0(a,I), Initialize s,
   1 + LifeSpan(P +* I,Initialize s) ) =
IC Comput(P +* I, (Initialize s),
       LifeSpan(P +* I,Initialize s) ) + 4
 holds CurInstr(P +* while=0(a,I),
   Comput(P +* while=0(a,I), (Initialize s),
  (1 + LifeSpan(P +* I,Initialize s)))) =
  goto  (card I +4)
proof
  set J3= Goto  0 ';' Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s1 = Initialize s,
      P1 = P +* while=0(a,I);
  set sI = Initialize s,
      PI = P +* I;
A1: I c= PI by FUNCT_4:26;
  set life=LifeSpan(P +* I,Initialize s);
  set sK1= Comput(P1, s1,1+life);
  set sK2= Comput(PI, sI,life);
  set I1= I ';' Goto  0;
  set i = a =0_goto  (card J + 3);
  reconsider n = IC sK2 as Element of NAT;
  set Mi= i ';' J ';' Goto  (card I1 + 1);
  set J2= I1 ';' Stop SCM+FSA;
  assume I is_closed_on s,P;
  then
A3:  n in dom I by SCMFSA7B:def 7;
  then n < card I by AFINSQ_1:70;
  then
A4: n+4 < card I+ 6 by XREAL_1:10;
  assume I is_halting_on s,P;
  then
A5: PI halts_on sI by SCMFSA7B:def 8;
A6:  (PI)/.IC sK2 = PI.IC sK2 by PBOOLE:158;
A7:  (P1)/.IC sK1 = P1.IC sK1 by PBOOLE:158;
  CurInstr(PI,sK2) =PI. n by A6
    .= I. n by A3,A1,GRFUNC_1:8;
  then
A8: I. n = halt SCM+FSA by A5,EXTPRO_1:def 14;
A9: J2= I ';' J3 by SCMFSA6A:67;
  then dom J2 = dom Directed I \/ dom Reloc(J3, card I) by
FUNCT_4:def 1
    .= dom I \/ dom Reloc(J3, card I) by FUNCT_4:105;
  then
A10:  n in dom J2 by A3,XBOOLE_0:def 3;
  then  n + 4 in { il+4 where il is Element of NAT: il in dom J2};
  then
A11:  (n+4) in dom Shift(J2,4) by VALUED_1:def 12;
  then
A12: Shift(J2,4)/.(n+4) =Shift(J2,4).( n +4) by PARTFUN1:def 8
    .=J2. n by A10,VALUED_1:def 12
    .=(Directed I). n by A3,A9,SCMFSA8A:28
    .=goto  card I by A3,A8,SCMFSA8A:30;
  set f =  (card I +4) .--> goto  0;
  assume
A13: IC sK1 = IC sK2 + 4;
  dom f = { (card I + 4)} & n + 4 <> card I + 4 by A3,FUNCOP_1:19;
  then
A14: not  (n+4) in dom f by TARSKI:def 1;
A15: card Mi = card (i ';' J )+ card Goto  (card I1 + 1) by SCMFSA6A:61
    .= card (i ';' J ) + 1 by SCMFSA8A:29
    .= card (Macro i) + card J + 1 by SCMFSA6A:61
    .= 2 + 1 +1 by Lm1,COMPOS_1:150
    .= 3+ 1;
  then n+4 >= card Mi by NAT_1:11;
  then
A16: not  (n+4) in dom Mi by AFINSQ_1:70;
  card while=0(a,I) = card I + 6 by Th4;
  then
A17:  (n+4) in dom while=0(a,I) by A4,AFINSQ_1:70;
A18: dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then
A19:  (n+4) in dom if=0(a,I1,J) by A14,A17,XBOOLE_0:def 3;
A20: if=0(a, I1, J) = Mi ';' I1 ';' Stop SCM+FSA by SCMFSA8B:def 1
    .= Mi ';' J2 by SCMFSA6A:67
    .= Directed Mi +* Reloc(J2, 4) by A15;
  then
A21: dom if=0(a,I1,J) = dom Directed Mi \/ dom Reloc(J2, 4 )
  by FUNCT_4:def 1;
  then dom if=0(a,I1,J) = dom Mi \/ dom Reloc(J2, 4) by
FUNCT_4:105;
  then
A22:  (n+4) in dom Reloc(J2, 4) by A19,A16,XBOOLE_0:def 3
;
  P1. (n+4) = (while=0(a,I)). (n+4) by A17,FUNCT_4:14
    .= (Directed Mi +* Reloc(J2, 4)). (n+4) by A14,A17,A18,A20,
FUNCT_4:def 1
    .= (Reloc(J2,4)). (n+4) by A19,A21,A22,FUNCT_4:def 1
    .= IncAddr(goto  card I,4) by A11,A12,COMPOS_1:def 40
    .= goto  (card I+4) by SCMFSA_4:14;
  hence thesis by A13,A7;
end;

theorem Th21:
  for a being Int-Location, I being Program of SCM+FSA holds
  while=0(a,I). (card I +4) = goto  0
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set Lc4= (card I + 4 );
  dom f = {Lc4} by FUNCOP_1:19;
  then
A1: Lc4 in dom f by TARSKI:def 1;
  Lc4 in dom while=0(a,I) & dom while=0(a,I) = dom if=0(a,I1,J) \/ dom f
  by Th13,FUNCT_4:def 1;
  hence while=0(a,I).Lc4 = f.Lc4 by A1,FUNCT_4:def 1
    .=goto  0 by FUNCOP_1:87;
end;

reserve f for FinSeq-Location,
  c for Int-Location;

theorem Th22:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location
 st I is_closed_on s,P & I is_halting_on s,P & s.a =0
holds IC Comput(P +* while=0(a,I), (Initialize s),
(LifeSpan(P +* I,Initialize s) + 3)) =  0 &
for k being Element of NAT st k
  <= LifeSpan(P +* I,Initialize s) + 3
  holds IC Comput(P +* while=0(a,I),
   (Initialize s),k) in dom while=0(a,I)
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I is_closed_on s,P;
  set sI = Initialize s,
      PI = P +* I;
  set s1 = Initialize s,
      P1 = P +* while=0(a,I);
  defpred P[Nat] means $1 <= LifeSpan(PI,sI) implies IC Comput(
   P1, s1
,1+$1) = IC Comput(PI, sI,$1)+ 4 & DataPart Comput(P1, s1,1+$1) = DataPart
  Comput(PI, sI,$1);
  assume
A3: I is_halting_on s,P;
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    now
A6:   k + 0 < k + 1 by XREAL_1:8;
      assume k + 1 <= LifeSpan(PI,sI);
      then k < LifeSpan(PI,sI) by A6,XXREAL_0:2;
      hence IC Comput(P1, s1,1+k+1) = IC Comput(PI,sI,k+1) + 4 &
      DataPart Comput(P1, s1,1+k+1) = DataPart Comput(PI, sI,k+1)
        by A1,A3,A5,Th19;
    end;
    hence P[k + 1];
  end;
  reconsider l=LifeSpan(PI,sI) as Element of NAT;
  set loc4= (card I + 4);
  set i = a =0_goto  4;
  set s2 = Comput(P1,s1,1);
 IC SCM+FSA in dom (Start-At(0,SCM+FSA)) by COMPOS_1:52;
   then
A8: IC s1 = IC(Start-At(0,SCM+FSA)) by FUNCT_4:14
    .=  0 by COMPOS_1:64;
    Start-At(0,SCM+FSA) c= Initialize while=0(a,I) by FUNCT_4:26;
    then
X1: dom Start-At(0,SCM+FSA) c= dom Initialize while=0(a,I)
          by RELAT_1:25;
  not a in dom (Initialize while=0(a,I)) by SCMFSA6B:12;
  then not a in dom (Start-At(0,SCM+FSA)) by X1;
  then
A9: s1.a = s.a by FUNCT_4:12;
  assume
A10: s.a = 0;
A11:  0 in dom while=0(a,I) by Th10;
A12:  (P1)/.IC s1 = P1.IC s1 by PBOOLE:158;
  P1. 0 = while=0(a,I). 0 by A11,FUNCT_4:14
    .= i by Th11;
  then
A13: CurInstr(P1,s1) = i by A8,A12;
A14: Comput(P1,s1,0+1) = Following(P1,
Comput(P1,s1,0)) by EXTPRO_1:4
    .= Following(P1,s1) by EXTPRO_1:3
    .= Exec(i,s1) by A13;
  then ( for c holds s2.c = s1.c)& for f holds s2.f = s1.f by SCMFSA_2:96;
  then
A15: DataPart s2 = DataPart s1 by SCMFSA6A:38
    .= DataPart sI;
A16: IC s2 =  4 by A10,A14,A9,SCMFSA_2:96;
A17: P[ 0]
  proof
    assume 0 <= LifeSpan(PI,sI);
A18: IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
    IC Comput(PI, sI,0) = IC sI by EXTPRO_1:3
      .= IC Start-At(0,SCM+FSA) by A18,FUNCT_4:14
      .=  0 by COMPOS_1:64;
    hence thesis by A16,A15,EXTPRO_1:3;
  end;
A19: for k being Element of NAT holds P[k] from NAT_1:sch 1(A17,A4);
  set s4= Comput(P1, s1,1+LifeSpan(PI,sI)+1+1);
  set s3= Comput(P1, s1,1+LifeSpan(PI,sI)+1);
A20: loc4 in dom while=0(a,I) by Th13;
  set s2= Comput(P1, s1,1+LifeSpan(PI,sI));
  P[l] by A19;
  then
A21: CurInstr(P1,s2) = goto loc4 by A1,A3,Th20;
A22: s3 = Following(P1,s2) by EXTPRO_1:4
    .= Exec(goto loc4,s2) by A21;
A23: IC s3 = loc4 by A22,SCMFSA_2:95;
A24:  (P1)/.IC s3 = P1.IC s3 by PBOOLE:158;
  P1.loc4 = (while=0(a,I)).loc4 by A20,FUNCT_4:14
    .= goto  0 by Th21;
  then
A25: CurInstr(P1,s3) = goto  0 by A23,A24;
A26: s4 = Following(P1,s3) by EXTPRO_1:4
    .= Exec(goto  0,s3) by A25;
A27: IC s4 =  0 by A26,SCMFSA_2:95;
  hence IC Comput(P1, s1,LifeSpan(PI,sI)+3) =  0;
A28: LifeSpan(PI,sI)+1+1+1 =LifeSpan(PI,sI)+(2+1);
A29: now
    let k be Element of NAT;
    assume
A30: k <= LifeSpan(PI,sI)+3;
    assume k<>0;
    then consider n being Nat such that
A31: k = n+ 1 by NAT_1:6;
    k<=LifeSpan(PI,sI)+1 or k >= LifeSpan(PI,sI)+1+1
by NAT_1:13;
    then
A32: k
<=LifeSpan(PI,sI)+1 or k = LifeSpan(PI,sI)+1+1 or k >
LifeSpan(PI,sI)+1+1 by XXREAL_0:1;
    reconsider n as Element of NAT by ORDINAL1:def 13;
    per cases by A28,A32,NAT_1:13;
    suppose
      k<=LifeSpan(PI,sI)+1;
      then n <= LifeSpan(PI,sI) by A31,XREAL_1:8;
      then
A33:  IC Comput(P1,s1,1+n) = IC Comput(PI, sI,n) + 4
by A19;
      reconsider m = IC Comput(PI, sI,n) as Element of NAT;
       m in dom I by A1,SCMFSA7B:def 7;
      then m < card I by AFINSQ_1:70;
      then
A34:  m+4 < card I+ 6 by XREAL_1:10;
      card while=0(a,I) = card I + 6 by Th4;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A31,A33,A34,
AFINSQ_1:70
;
    end;
    suppose
      k=LifeSpan(PI,sI)+1+1;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A23,Th13;
    end;
    suppose
      k >= LifeSpan(PI,sI)+3;
      then k = LifeSpan(PI,sI)+3 by A30,XXREAL_0:1;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A27,Th10;
    end;
  end;
  now
    let k be Element of NAT;
    assume
A35: k <= LifeSpan(PI,sI)+3;
    per cases;
    suppose
      k = 0;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A11,A8,
EXTPRO_1:3;
    end;
    suppose
      k <>0;
      hence IC Comput(P1,s1,k) in dom while=0(a,I) by A29,A35;
    end;
  end;
  hence thesis;
end;

reserve s for State of SCM+FSA,
  I for Program of SCM+FSA,
  a for read-write
  Int-Location;

definition
  let s,I,a,P;
  deffunc U(Nat,State of SCM+FSA) =
   Comput(P +* while=0(a,I), $2 +* Start-At(0,SCM+FSA),
        LifeSpan(P +* while=0(a,I) +* I,$2 +* Start-At(0,SCM+FSA)) + 3);
  deffunc V(Nat,State of SCM+FSA) = down U($1,$2);
  func StepWhile=0(a,I,P,s) ->
    Function of NAT,product the Object-Kind of SCM+FSA means
  :Def4:
  it.0 = s &
  for i being Nat holds
   it.(i+1)= Comput(P +* while=0(a,I),
       it.i +* Start-At(0,SCM+FSA),
       LifeSpan(P +* while=0(a,I) +* I,
        it.i +* Start-At(0,SCM+FSA)) + 3);
  existence
  proof
   reconsider ss=s as
    Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
    consider f being Function of NAT,product the Object-Kind of SCM+FSA
     such that
A1:   f.0 = ss and
A2:   for i being Nat holds f.(i+1)= V(i,f.i) from NAT_1:sch 12;
   take f;
   thus f.0 = s by A1;
   let i be Nat;
    f.(i+1)= V(i,f.i) by A2;
   hence thesis;
  end;
  uniqueness
  proof
    let F1,F2 be Function of NAT,product the Object-Kind of SCM+FSA such that
A3: F1.0 = s and
A4: for i being Nat holds F1.(i+1)= U(i,F1.i) and
A5: F2.0 = s and
A6: for i being Nat holds F2.(i+1)= U(i,F2.i);
   reconsider s as Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
A7: F1.0 = s by A3;
A8: for i being Nat holds F1.(i+1)= V(i,F1.i) by A4;
A9: F2.0 = s by A5;
A10: for i being Nat holds F2.(i+1)= V(i,F2.i) by A6;
    thus F1 = F2 from NAT_1:sch 16(A7,A8,A9,A10);
  end;
end;

reserve i,k,m,n for Element of NAT;

canceled 2;

theorem Th25:
  StepWhile=0(a,I,P,s).(k+1)=StepWhile=0(a,I,P,StepWhile=0(a,I,P,s).k).1
proof
  set sk=StepWhile=0(a,I,P,s).k;
  set sk0=StepWhile=0(a,I,P,sk).0;
  sk0=sk by Def4;
  hence
  StepWhile=0(a,I,P,s).(k+1) = Comput(P +*while=0(a,I),
      (sk0 +*(Start-At(0,SCM+FSA))) ,
  (LifeSpan(P +*while=0(a,I) +* I,sk0 +* Start-At(0,SCM+FSA)) + 3)) by Def4
    .=StepWhile=0(a,I,P,sk).(0+1) by Def4
    .=StepWhile=0(a,I,P,sk).1;
end;

canceled 3;

theorem
  for s1,s2 being State of SCM+FSA st IC s1 = IC s2 & DataPart s1
  = DataPart s2 & s1 | NAT = s2 | NAT holds s1 = s2
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let s1,s2 be State of SCM+FSA;
  assume
A1: IC s1 = IC s2;
  assume DataPart s1 = DataPart s2;
  then
A2: ( for a being Int-Location holds s1.a = s2.a)& for f being
  FinSeq-Location holds s1.f = s2.f by SCMFSA6A:38;
  assume s1 | NAT = s2 | NAT;
  then for l being Element of NAT holds s1.l = s2.l by COMPOS_1:127;
  hence thesis by A1,A2,SCMFSA_2:86;
end;

theorem Th30:
  for I being Program of SCM+FSA,a being read-write Int-Location,
  s being State of SCM+FSA holds StepWhile=0(a,I,P,s).(0+1)
   = Comput(P +* while=0(a,I),
        Initialize s,
        LifeSpan(P +* while=0(a,I)+* I,Initialize s) + 3)
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA;
A1: StepWhile=0(a,I,P,s).0 = s by Def4;
  thus StepWhile=0(a,I,P,s).(0+1)
    = Comput(P +* while=0(a,I), Initialize s,
       LifeSpan(P +* while=0(a,I)+* I,Initialize s) + 3) by A1,Def4;
end;

theorem Th31:
  for I being Program of SCM+FSA,a being read-write Int-Location,
s being State of SCM+FSA,k,n being Element of NAT
st IC StepWhile=0(a,I,P,s).k = 0 &
   StepWhile=0(a,I,P,s).k= Comput(P +* while=0(a,I),
       (Initialize s),n)
   holds StepWhile=0(a,I,P,s).k = Initialize(StepWhile=0(a,I,P,s).k) &
   StepWhile=0(a,I,P,s).(k+1)=Comput(P +* while=0(a,I), Initialize s,
     (n +(LifeSpan(P +* while=0(a,I) +* I,
       Initialize(StepWhile=0(a,I,P,s).k)) + 3)))
proof
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA,k,n be Element of NAT;
  set s1 = Initialize s,
      P1 = P +* while=0(a,I);
  set sk=StepWhile=0(a,I,P,s).k;
  set s2=Initialize sk;
  assume
A1: IC sk = 0;
  assume
A3: sk = Comput(P1, s1,n);
   sk is 0-started by A1,COMPOS_1:def 20;
   then Start-At(0,SCM+FSA) c= sk by COMPOS_1:151;
  hence s2=sk by FUNCT_4:104;
  hence
  StepWhile=0(a,I,P,s).(k+1)
    = Comput(P1, sk,LifeSpan(P +* while=0(a,I) +* I,
    Initialize sk) + 3)
        by Def4
   .= Comput(P1, s1,n +(LifeSpan(P +* while=0(a,I) +* I,
   Initialize sk) + 3))
     by A3,EXTPRO_1:5;
end;

theorem Th32:
  for I being Program of SCM+FSA,a being read-write Int-Location,
s being State of SCM+FSA st
 (for k being Nat holds
  I is_closed_on StepWhile=0(a,I,P,s).k,P+*while=0(a,I) &
  I is_halting_on StepWhile=0(a,I,P,s).k,P+*while=0(a,I)) &
   ex f being Function of
  product the Object-Kind of SCM+FSA,NAT st
   for k being Nat holds
    ((f.(StepWhile=0(a,I,P,s).(k+1)) < f.(StepWhile=0(a,I,P,s).k) or
     f.(StepWhile=0(a,I,P,s).k) = 0) &
    (f.(StepWhile=0(a,I,P,s).k)=0 iff (StepWhile=0(a,I,P,s).k).a <> 0))
  holds while=0(a,I) is_halting_on s,P & while=0(a,I) is_closed_on s,P
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA;
  assume
A1: for k being Nat holds
   I is_closed_on StepWhile=0(a,I,P,s).k,P+*while=0(a,I) &
   I is_halting_on StepWhile=0(a,I,P,s).k,P+*while=0(a,I);
  set s1 = Initialize s,
      P1 = P +* while=0(a,I);
A3:  P1 +* while=0(a,I) = P1 by FUNCT_4:99;
  given f being Function of product the Object-Kind of SCM+FSA,NAT such that
A5: for k being Nat
 holds (f.(StepWhile=0(a,I,P,s).(k+1)) < f.(StepWhile=0(a,I,P,s).k) or
  f.(StepWhile=0(a,I,P,s).k) = 0) &
( f.(StepWhile=0(a,I,P,s).k)=0 iff
  (StepWhile=0(a,I,P,s).k).a <> 0 );
  deffunc F(Nat) = f.(StepWhile=0(a,I,P,s).$1);
A6: for k being Nat holds ( F(k+1) < F(k) or F(k) = 0 ) by A5;
  consider m being Nat such that
A7: F(m)=0 and
A8: for n being Nat st F(n) =0 holds m <= n from NAT_1:sch 17(A6);
  defpred P[Nat] means $1+1 <= m implies ex k st StepWhile=0(a,I,P,s)
  .($1+1)= Comput(P1, s1,k);
A9: now
    let k be Element of NAT;
    assume
A10: P[k];
    now
      set sk1=StepWhile=0(a,I,P,s).(k+1);
      set sk=StepWhile=0(a,I,P,s).k;
      assume
A11:   (k+1)+ 1 <= m;
      k + 0 < k+ (1+ 1) by XREAL_1:8;
      then k < m by A11,XXREAL_0:2;
      then F(k) <> 0 by A8;
      then
A12:  sk.a = 0 by A5;
A13:  I is_halting_on sk,P+*while=0(a,I) by A1;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
      then consider n being Element of NAT such that
A14:  sk1 = Comput(P1, s1,n) by A10,A11,XXREAL_0:2;
      take m=n +(LifeSpan(P +* while=0(a,I) +* I,
          Initialize sk1) + 3);
A15:  P+*while=0(a,I) +* while=0(a,I) = P+*while=0(a,I) by FUNCT_4:99;
      sk1= Comput(P +* while=0(a,I), Initialize sk,
       (LifeSpan(P +* while=0(a,I) +* I,Initialize sk) + 3)) &
       I is_closed_on sk,P+*while=0(a,I) by A1,Def4;
      then IC sk1 = 0 by A13,A12,Th22,A15;
      hence StepWhile=0(a,I,P,s).((k+1)+1)= Comput(P1, s1,m) by A14,Th31;
    end;
    hence P[k+1];
  end;
A16: P[ 0]
  proof
    assume 0+1 <= m;
    take n=(LifeSpan(P +* while=0(a,I)+* I,Initialize s) + 3);
    thus thesis by Th30;
  end;
A17: for k being Element of NAT holds P[k] from NAT_1:sch 1(A16,A9);
  now
    per cases;
    suppose
      m=0;
      then (StepWhile=0(a,I,P,s).0).a <> 0 by A5,A7;
      then s.a <> 0 by Def4;
      hence thesis by Th18;
    end;
    suppose
A18:  m<>0;
      then consider i being Nat such that
A19:  m=i+1 by NAT_1:6;
      reconsider m,i as Element of NAT by ORDINAL1:def 13;
      set sm=StepWhile=0(a,I,P,s).m;
      set si=StepWhile=0(a,I,P,s).i;
      i < m by A19,NAT_1:13;
      then F(i) <> 0 by A8;
      then
A20:  si.a = 0 by A5;
A21:  I is_closed_on si,P+*while=0(a,I) &
      I is_halting_on si,P+*while=0(a,I) by A1;
XX:   IC SCM+FSA in dom sm by COMPOS_1:9;
      sm= Comput(P +* while=0(a,I), (Initialize si),
      (LifeSpan(P +* while=0(a,I) +* I,Initialize si) + 3))
       by A19,Def4;
      then IC sm = 0 by A21,A20,Th22,A3;
      then sm is 0-started by XX,COMPOS_1:def 16;
      then
B22:  Start-At(0,SCM+FSA) c= sm by COMPOS_1:151;
      set p=(LifeSpan(P+*while=0(a,I)+* I,Initialize s) + 3);
      set sm1=Initialize sm;
      m=i+1 by A19;
      then consider n being Element of NAT such that
A23:  sm = Comput(P1, s1,n) by A17;
      reconsider n as Element of NAT;
A27:  sm1=sm by B22,FUNCT_4:104;
A28:  sm.a <> 0 by A5,A7;
      then while=0(a,I) is_halting_on sm,P by Th18;
      then P +* while=0(a,I) halts_on Initialize sm by SCMFSA7B:def 8;
      then P +* while=0(a,I) halts_on Initialize sm;
      then P1 halts_on sm1;
      then consider j being Element of NAT such that
A29:  CurInstr(P1,Comput(P1,sm,j))
        = halt SCM+FSA by A27,EXTPRO_1:30;
A30: Comput(P1,s1,n+j)
 = Comput(P1,Comput(P1,s1,n),j) by EXTPRO_1:5;
      CurInstr(P1,Comput(P1,s1,n+j))
       = halt SCM+FSA by A23,A29,A30;
      then P1 halts_on s1 by EXTPRO_1:30;
      hence while=0(a,I) is_halting_on s,P by SCMFSA7B:def 8;
      now
        let q be Element of NAT;
A31:    0<m by A18;
        per cases;
        suppose
A32:      q <= p;
A33:      StepWhile=0(a,I,P,s).0=s by Def4;
          then
A34:      I is_closed_on s,P+*while=0(a,I) &
          I is_halting_on s,P+*while=0(a,I) by A1;
          F(0) <> 0 by A8,A31;
          then s.a = 0 by A5,A33;
          hence IC Comput(P1,s1,q) in dom while=0(a,I) by A32,A34,Th22,A3;
        end;
        suppose
A35:      q > p;
A36:      now
            take k=p;
            thus StepWhile=0(a,I,P,s).1= Comput(P1, s1,k) & k <= q
by A35,Th30;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 &
          (ex k st StepWhile=0(a,I,P,s).$1
          = Comput(P1, s1,k) & k <= q);
A37:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A31,XREAL_1:8;
          then 1 <= m by NAT_1:13;
          then
A38:      ex t be Nat st P2[t] by A36;
          consider t be Nat such that
A39:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A37,A38);
          reconsider t as Element of NAT by ORDINAL1:def 13;
          now
            per cases;
            suppose
              t=m;
              then consider r being Element of NAT such that
A40:          sm= Comput(P1, s1,r) and
A41:          r <= q by A39;
              consider x being Nat such that
A42:          q = r+x by A41,NAT_1:10;
A43:          while=0(a,I) is_closed_on sm,P by A28,Th18;
              reconsider x as Element of NAT by ORDINAL1:def 13;
              Comput(P1,s1,q) = Comput(P1, sm1,x)
by A27,A40,A42,EXTPRO_1:5;
              hence IC Comput(P1,s1,q) in dom while=0(a,I) by A43
,SCMFSA7B:def 7;
            end;
            suppose
A44:          t<>m;
              set Dt=StepWhile=0(a,I,P,s).t;
A45:          t < m by A39,A44,XXREAL_0:1;
              then F(t) <> 0 by A8;
              then
A46:          Dt.a = 0 by A5;
              consider z being Element of NAT such that
A47:          StepWhile=0(a,I,P,s).t= Comput(P1, s1,z) and
A48:          z <= q by A39;
              set z2=z +(LifeSpan(P +* while=0(a,I) +* I,
                   Initialize Dt) + 3);
              consider w being Nat such that
A49:          q = z+w by A48,NAT_1:10;
A50:          I is_closed_on Dt,P+*while=0(a,I) &
              I is_halting_on Dt,P+*while=0(a,I) by A1;
              consider y being Nat such that
A51:          t=y+1 by A39,NAT_1:6;
              reconsider y as Element of NAT by ORDINAL1:def 13;
              set Dy=StepWhile=0(a,I,P,s).y;
              y+ 0 < t by A51,XREAL_1:8;
              then y < m by A39,XXREAL_0:2;
              then F(y) <> 0 by A8;
              then
A52:          Dy.a = 0 by A5;
A53:          I is_closed_on Dy,P+*while=0(a,I) &
              I is_halting_on Dy,P+*while=0(a,I) by A1;
              reconsider w as Element of NAT by ORDINAL1:def 13;
              Dt= Comput(P +* while=0(a,I),
                Initialize Dy,
                LifeSpan(P +* while=0(a,I) +* I,Initialize Dy) + 3)
                  by A51,Def4;
              then
A54:          IC Dt = 0 by A53,A52,Th22,A3;
              now
                assume
A55:            z2 <= q;
A56:            now
                  take k=z2;
                  thus StepWhile=0(a,I,P,s).(t+1)= Comput(P1, s1,k)
& k <= q
by A47,A54,A55,Th31;
                end;
                t+1 <= m by A45,NAT_1:13;
                hence contradiction by A39,A56,XREAL_1:31;
              end;
              then
A57:          w < LifeSpan(P +* while=0(a,I) +* I,
Initialize Dt) + 3
by A49,XREAL_1:8;
A58: Dt = Initialize Dt by A47,A54,Th31;
              Comput(P1,s1,q)
                = Comput(P +* while=0(a,I), (Dt +* (
Start-At(0,SCM+FSA))),w) by A58,A47,A49,EXTPRO_1:5;
              hence IC Comput(P1,s1,q) in dom while=0(a,I) by A57
,A50,A46,Th22,A3;
            end;
          end;
          hence IC Comput(P1,s1,q) in dom while=0(a,I);
        end;
      end;
      hence while=0(a,I) is_closed_on s,P by SCMFSA7B:def 7;
    end;
  end;
  hence thesis;
end;

theorem Th33:
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location, s being State of SCM+FSA st ex f being Function of product the
Object-Kind of SCM+FSA,NAT st
  for k being Nat
   holds (f.(StepWhile=0(a,I,P,s).(k+1)) < f.(StepWhile=0(a,I,P,s).k)
    or f.(StepWhile=0(a,I,P,s).k) = 0) &
     (f.(StepWhile=0(a,I,P,s).k)=0 iff (StepWhile=0(a,I,P,s).k).a <> 0 )
 holds while=0(a,I) is_halting_on s,P & while=0(a,I) is_closed_on s,P
proof
  let I be parahalting Program of SCM+FSA,a be read-write Int-Location,s be
  State of SCM+FSA;
A1: for k being Nat holds
      I is_closed_on StepWhile=0(a,I,P,s).k,P+*while=0(a,I) &
      I is_halting_on StepWhile=0(a,I,P,s).k,P+*while=0(a,I)
       by SCMFSA7B:24,25;
  assume ex f being Function of product the Object-Kind of SCM+FSA,NAT st for
k being Nat holds (f.(StepWhile=0(a,I,P,s).(k+1)) < f.(StepWhile=0(a,I,P,s).k)
 or f
.(StepWhile=0(a,I,P,s).k) = 0) & ( f.(StepWhile=0(a,I,P,s).k)=0
 iff (StepWhile=0(a,I,P,s).k).a <> 0 );
  hence thesis by A1,Th32;
end;

theorem
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location st ex f being Function of product the Object-Kind of SCM+FSA,NAT
st (for s being State of SCM+FSA,P
 holds (f.(StepWhile=0(a,I,P,s).1) < f.s
 or f.s =
  0) & ( f.s =0 iff s.a <> 0 )) holds while=0(a,I) is parahalting
proof
  let I be parahalting Program of SCM+FSA,a be read-write Int-Location;
  given f being Function of product the Object-Kind of SCM+FSA,NAT such that
A1: for s being State of SCM+FSA,P holds (f.(StepWhile=0(a,I,P,s).1) < f.s
  or f.s = 0) & ( f.s =0 iff s.a <> 0 );
  now let t be State of SCM+FSA;
   let Q;
    now
      let k be Nat;
A2:   k in NAT by ORDINAL1:def 13;
      f.(StepWhile=0(a,I,Q,StepWhile=0(a,I,Q,t).k).1)
       < f.(StepWhile=0(a,I,Q,t).
      k) or f.(StepWhile=0(a,I,Q,t).k) = 0 by A1;
      hence (f.(StepWhile=0(a,I,Q,t).(k+1)) < f.(StepWhile=0(a,I,Q,t).k)
        or f.(StepWhile=0(a,I,Q,t).k) = 0) &
       (f.(StepWhile=0(a,I,Q,t).k)=0 iff (StepWhile=0(a,I,Q,t).k).a <> 0 )
        by A1,A2,Th25;
    end;
    hence while=0(a,I) is_halting_on t,Q by Th33;
  end;
  hence thesis by SCMFSA7B:25;
end;

theorem Th35:
  for l1,l2 being Element of NAT,a being
  Int-Location holds (l1 .--> goto l2) does not destroy a
proof
  let l1,l2 be Element of NAT,a be Int-Location;
  set I=l1 .--> goto l2;
A1: rng I={goto l2 } by FUNCOP_1:14;
  now
    let i be Instruction of SCM+FSA;
    assume i in rng I;
    then i=goto l2 by A1,TARSKI:def 1;
    hence i does not destroy a by SCMFSA7B:17;
  end;
  hence thesis by SCMFSA7B:def 4;
end;

theorem Th36:
  for i being Instruction of SCM+FSA st i does not destroy intloc
  0 holds Macro i is good
proof
  let i be Instruction of SCM+FSA;
  set I=Macro i;
A1: rng I c={i,halt SCM+FSA} by FUNCT_4:65;
  assume
A2: i does not destroy intloc 0;
  now
    let x be Instruction of SCM+FSA;
    assume
A3: x in rng I;
    per cases by A1,A3,TARSKI:def 2;
    suppose
      x = i;
      hence x does not destroy intloc 0 by A2;
    end;
    suppose
      x = halt SCM+FSA;
      hence x does not destroy intloc 0 by SCMFSA7B:11;
    end;
  end;
  then I does not destroy intloc 0 by SCMFSA7B:def 4;
  hence thesis by SCMFSA7B:def 5;
end;

registration
  let I,J be good Program of SCM+FSA,a be Int-Location;
  cluster if=0(a,I,J) -> good;
  correctness
  proof
    set i = a =0_goto  (card J + 3);
    reconsider Mi=Macro i as good Program of SCM+FSA by Th36,SCMFSA7B:18;
    if=0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I ';' Stop
    SCM+FSA by SCMFSA8B:def 1
      .= Mi ';' J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
    hence thesis;
  end;
end;

registration
  let I be good Program of SCM+FSA,a be Int-Location;
  cluster while=0(a,I) -> good;
  correctness
  proof
    set F=if=0(a, I ';' Goto  0, Stop SCM+FSA);
    set J= (card I +4) .--> goto  0;
    J does not destroy intloc 0 & F does not destroy intloc 0 by Th35,
SCMFSA7B:def 5;
    then while=0(a,I) does not destroy intloc 0 by SCMFSA8A:25;
    hence thesis by SCMFSA7B:def 5;
  end;
end;

:: -----------------------------------------------------------
:: WHILE>0  Statement

theorem Th37:
  for a being Int-Location, I being Program of SCM+FSA, k being
  Element of NAT st k < 6 holds  k in dom while>0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
A1: 6 <= card I + 6 by NAT_1:11;
A2: card while>0(a,I) = card I + 6 by Th5;
  assume k < 6;
  then k < card I + 6 by A1,XXREAL_0:2;
  hence thesis by A2,AFINSQ_1:70;
end;

theorem Th38:
  for a being Int-Location, I being Program of SCM+FSA, k being
  Element of NAT st k < 6 holds card I +k in dom while>0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
  assume k < 6;
  then
A1: card I + k < card I + 6 by XREAL_1:8;
  card while>0(a,I) = card I + 6 by Th5;
  hence thesis by A1,AFINSQ_1:70;
end;

theorem Th39:
  for a being Int-Location, I being Program of SCM+FSA holds
  while>0(a,I).(card I+5) = halt SCM+FSA
proof
  set J1= Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a >0_goto  (card J + 3);
  set c5 = card I + 5;
  set Lc5= c5;
  set Mi= Macro i ';' J ';' Goto  (card I1 + 1) ';' I1;
  dom f = { (card I + 4)} & Lc5 <>  (card I + 4) by FUNCOP_1:19;
  then
A1: not Lc5 in dom f by TARSKI:def 1;
   0 + c5 in { il+c5 where il is Element of NAT: il in dom J1} by Lm3;
  then
A2:  c5 in dom Shift(J1,c5) by VALUED_1:def 12;
  then
A3: Shift(J1,c5)/.Lc5 = Shift(J1,c5).( 0 +c5) by PARTFUN1:def 8
    .= halt SCM+FSA by Lm2,Lm3,VALUED_1:def 12;
A4: Lc5 in dom while>0(a,I) & dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f
  by Th38,FUNCT_4:def 1;
  then
A5: Lc5 in dom if>0(a,I1,J) by A1,XBOOLE_0:def 3;
A6: if>0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 2
    .= Mi ';' J1;
  then card if>0(a, I1,J) = card Mi + card J1 by SCMFSA6A:61;
  then
A7: card Mi = card if>0(a,I1,J)-card J1
    .= card I + 6 - 1 by Th2,Lm1
    .= c5;
  then
A8: not Lc5 in dom Mi;
A9: dom if>0(a,I1,J) = dom Directed Mi \/ dom Reloc(J1, c5)
  by A6,A7,FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom Reloc(J1, c5) by
FUNCT_4:105;
  then
A10: Lc5 in dom Reloc(J1, c5) by A5,A8,XBOOLE_0:def 3;
  thus while>0(a,I).Lc5 = (Directed Mi +* Reloc(J1, c5)).Lc5
  by A1,A4,A6,A7,FUNCT_4:def 1
    .= (Reloc(J1,c5)).Lc5 by A5,A9,A10,FUNCT_4:def 1
    .= IncAddr( halt SCM+FSA, c5 ) by A2,A3,COMPOS_1:def 40
    .= halt SCM+FSA by COMPOS_1:93;
end;

theorem Th40:
  for a being Int-Location, I being Program of SCM+FSA holds
  while>0(a,I). 3 = goto  (card I +5)
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a >0_goto  (card J + 3);
  set Mi=Macro i ';' J;
  set G=Goto  (card I1 + 1);
  set J2= (I1 ';' Stop SCM+FSA);
  set J1=G ';' J2;
A1:  0 in dom G by SCMFSA8A:47;
A2: G. 0 = goto  (card I1 + 1) by SCMFSA8A:47
    .= goto  (card I + card Goto  0 + 1) by SCMFSA6A:61
    .= goto  (card I + 1 + 1) by SCMFSA8A:29
    .= goto  (card I +(1+1));
  dom J1 = dom Directed G \/ dom Reloc(J2, card G) by
FUNCT_4:def 1
    .= dom G \/ dom Reloc(J2, card G) by FUNCT_4:105;
  then
A3:  0 in dom J1 by A1,XBOOLE_0:def 3;
  then  0 + 3 in { il+3 where il is Element of NAT: il in dom J1};
  then
A4:  3 in dom Shift(J1,3) by VALUED_1:def 12;
  then
A5: Shift(J1,3)/.3 =Shift(J1,3).( 0 +3) by PARTFUN1:def 8
    .=J1. 0 by A3,VALUED_1:def 12
    .=(Directed G). 0 by A1,SCMFSA8A:28
    .=goto  (card I + 2) by A1,A2,SCMFSA8A:30;
  dom f = { (card I + 4)} & 3 <> card I + 4 by FUNCOP_1:19,NAT_1:11;
  then
A6: not  3 in dom f by TARSKI:def 1;
A7: card Mi = card Macro i + card J by SCMFSA6A:61
    .= 2 + 1 by Lm1,COMPOS_1:150;
  then
A8: not  3 in dom Mi;
A9:  3 in dom while>0(a,I) & dom while>0(a,I) = dom if>0(a,I1,J) \/
  dom f by Th37,FUNCT_4:def 1;
  then
A10:  3 in dom if>0(a,I1,J) by A6,XBOOLE_0:def 3;
A11: if>0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= Mi ';' J1 by SCMFSA6A:67
    .= Directed Mi +* Reloc(J1, 3) by A7;
  then
A12: dom if>0(a,I1,J) = dom Directed Mi \/ dom Reloc(J1, 3)
  by FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom Reloc(J1, 3) by
FUNCT_4:105;
  then
A13:  3 in dom Reloc(J1, 3) by A10,A8,XBOOLE_0:def 3;
  thus while>0(a,I). 3 = (Directed Mi +* Reloc(J1, 3)).
   3 by A6,A9,A11,FUNCT_4:def 1
    .= (Reloc(J1,3)). 3 by A10,A12,A13,FUNCT_4:def 1
    .= IncAddr(goto  (card I +2),3) by A4,A5,COMPOS_1:def 40
    .= goto  (card I+ 2 +3) by SCMFSA_4:14
    .= goto  (card I+ 5);
end;

theorem Th41:
  for a being Int-Location, I being Program of SCM+FSA holds
  while>0(a,I). 2 = goto  3
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set i = a >0_goto  (card J + 3);
  set Mi=Macro i;
  set J2=Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA);
  set J1=J ';' J2;
  dom f = { (card I + 4)} & 2 <> card I + 4 by FUNCOP_1:19,NAT_1:11;
  then
A1: not  2 in dom f by TARSKI:def 1;
  dom J1 = dom Directed J \/ dom Reloc(J2, card J) by
FUNCT_4:def 1
    .= dom J \/ dom Reloc(J2, card J) by FUNCT_4:105;
  then
A2:  0 in dom J1 by Lm3,XBOOLE_0:def 3;
  then  0 + 2 in { il+2 where il is Element of NAT: il in dom J1};
  then
A3:  2 in dom Shift(J1,2) by VALUED_1:def 12;
  then
A4: Shift(J1,2)/.2 =Shift(J1,2).( 0 +2) by PARTFUN1:def 8
    .=J1. 0 by A2,VALUED_1:def 12
    .=(Directed J). 0 by Lm3,SCMFSA8A:28
    .=goto  card J by Lm2,Lm3,SCMFSA8A:30;
  card Mi = 2 by COMPOS_1:150;
  then
A5: not  2 in dom Mi;
A6:  2 in dom while>0(a,I) & dom while>0(a,I) = dom if>0(a,I1,J) \/
  dom f by Th37,FUNCT_4:def 1;
  then
A7:  2 in dom if>0(a,I1,J) by A1,XBOOLE_0:def 3;
A8: if>0(a, I1, J) = i ';' J ';' Goto  (card I1 + 1) ';' I1 ';' Stop
  SCM+FSA by SCMFSA8B:def 2
    .= i ';' J ';' Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA) by SCMFSA6A:67
    .= i ';' J ';' (Goto  (card I1 + 1) ';' (I1 ';' Stop SCM+FSA)) by
SCMFSA6A:67
    .= i ';' J1 by SCMFSA6A:71
    .= Directed Mi +* Reloc(J1, 2) by COMPOS_1:150;
  then
A9: dom if>0(a,I1,J) = dom Directed Mi \/ dom Reloc(J1, 2)
  by FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom Reloc(J1, 2) by
FUNCT_4:105;
  then
A10:  2 in dom Reloc(J1, 2) by A7,A5,XBOOLE_0:def 3;
  thus while>0(a,I). 2 = (Directed Mi +* Reloc(J1, 2)).
   2 by A1,A6,A8,FUNCT_4:def 1
    .= (Reloc(J1,2)). 2 by A7,A9,A10,FUNCT_4:def 1
    .= IncAddr(goto  card J,2) by A3,A4,COMPOS_1:def 40
    .= goto ( 1 + 2) by Lm1,SCMFSA_4:14
    .= goto  3;
end;

theorem
  for a being Int-Location, I being Program of SCM+FSA, k being Element
  of NAT st k < card I +6 holds  k in dom while>0(a,I)
proof
  let a be Int-Location, I be Program of SCM+FSA,k be Element of NAT;
  assume
A1: k < card I +6;
  card while>0(a,I) = card I + 6 by Th5;
  hence thesis by A1,AFINSQ_1:70;
end;

theorem Th43:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location
 st s.a <= 0 holds while>0(a,I) is_halting_on s,P &
  while>0(a,I) is_closed_on s,P
proof
  let s be State of SCM+FSA;
  let I be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: s.a <= 0;
  set i = a >0_goto  4;
  set s1 = Initialize s,
      P1 = P +* while>0(a,I);
 IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
  then
A3: IC SCM+FSA in dom Start-At(0,SCM+FSA);
A4: IC s1 = IC Start-At(0,SCM+FSA) by A3,FUNCT_4:14
    .=  0 by COMPOS_1:64;
  set loc5=  (card I +5);
  set s5 = Comput(P1,s1,4);
  set s4 = Comput(P1,s1,3);
  set s3 = Comput(P1,s1,2);
  set s2 = Comput(P1,s1,1);
A5:  1 in dom while>0(a,I) by Th10;
A6:  2 in dom while>0(a,I) by Th37;
    Start-At(0,SCM+FSA) c= Initialize while>0(a,I) by FUNCT_4:26;
    then
X: dom Start-At(0,SCM+FSA) c= dom Initialize while>0(a,I)
            by RELAT_1:25;
  not a in dom (Initialize while>0(a,I)) by SCMFSA6B:12;
  then not a in dom Start-At(0,SCM+FSA) by X;
  then
A7: s1.a = s.a by FUNCT_4:12;
A8:  (P1)/.IC s1 = P1.IC s1 by PBOOLE:158;
A9:  0 in dom while>0(a,I) by Th10;
  then P1. 0 = while>0(a,I). 0 by FUNCT_4:14
    .= i by Th11;
  then
A10: CurInstr(P1,s1) = i by A4,A8;
A11: Comput(P1,s1,0+1) = Following(P1,
Comput(P1,s1,0)) by EXTPRO_1:4
    .= Following(P1,s1) by EXTPRO_1:3
    .= Exec(i,s1) by A10;
A12: IC Comput(P1,s1,1) = succ  0 by A1,A4,A11,A7,SCMFSA_2:97
    .=  (0 + 1);
A13:  (P1)/.IC Comput(P1,s1,1) = P1.IC Comput(P1,s1,1) by PBOOLE:158;
    P1. 1 = (while>0(a,I)). 1 by A5,FUNCT_4:14
    .= goto  2 by Th11;
  then
A14: CurInstr(P1,Comput(P1,s1,1))
 = goto  2 by A12,A13;
A15: Comput(P1,s1,1+1) = Following(P1,s2) by
EXTPRO_1:4
    .= Exec(goto  2,s2) by A14;
A16: IC s3 =  2 by A15,SCMFSA_2:95;
A17:  (P1)/.IC s3 = P1.IC s3 by PBOOLE:158;
  P1. 2 = (while>0(a,I)). 2 by A6,FUNCT_4:14
    .= goto  3 by Th41;
  then
A18: CurInstr(P1,s3) = goto  3 by A16,A17;
A19: Comput(P1,s1,2+1) = Following(P1,s3) by
EXTPRO_1:4
    .= Exec(goto  3,s3) by A18;
A20: IC s4 =  3 by A19,SCMFSA_2:95;
A21:  3 in dom while>0(a,I) by Th37;
A22: loc5 in dom while>0(a,I) by Th38;
A23:  (P1)/.IC s4 = P1.IC s4 by PBOOLE:158;
  P1. 3 = (while>0(a,I)). 3 by A21,FUNCT_4:14
    .= goto loc5 by Th40;
  then
A24: CurInstr(P1,s4) = goto loc5 by A20,A23;
A25: Comput(P1,s1,3+1) = Following(P1,s4) by
EXTPRO_1:4
    .= Exec(goto loc5,s4) by A24;
A26: IC s5 = loc5 by A25,SCMFSA_2:95;
A27:  (P1)/.IC s5 = P1.IC s5 by PBOOLE:158;
  P1.loc5 = while>0(a,I).loc5 by A22,FUNCT_4:14
    .= halt SCM+FSA by Th39;
  then
A28: CurInstr(P1,s5) = halt SCM+FSA by A26,A27;
  then P1 halts_on s1 by EXTPRO_1:30;
  hence while>0(a,I) is_halting_on s,P by SCMFSA7B:def 8;
  now
    let k be Element of NAT;
A29: k<=3 or k >= 3+1 by NAT_1:13;
    per cases by A29,NAT_1:28;
    suppose
      k = 0;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A9,A4,
EXTPRO_1:3;
    end;
    suppose
      k = 1;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A12,Th10;
    end;
    suppose
      k = 2;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A16,Th37;
    end;
    suppose
      k = 3;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A20,Th37;
    end;
    suppose
      k >= 4;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A22,A26,A28
,EXTPRO_1:6;
    end;
  end;
  hence thesis by SCMFSA7B:def 7;
end;

theorem Th44:
  for a being Int-Location, I being Program of SCM+FSA, s being
State of SCM+FSA,k being Element of NAT
 st I is_closed_on s,P & I is_halting_on s,P
& k < LifeSpan(P +* I,Initialize s) &
IC Comput(P +* while>0(a,I), (Initialize s),1+k)
   = IC Comput(P +* I, (Initialize s),k) + 4 &
   DataPart Comput(P +* while>0(a,I),
    (Initialize s),1+k) =
   DataPart Comput(P +* I, (Initialize s),k)
  holds IC Comput(P +* while>0(a,I),
    (Initialize s),1+k+1)
  = IC
Comput(P +* I, (Initialize s),k+1) + 4 &
DataPart Comput(P +* while>0(a,I), (
Initialize s),1+k+1) =
DataPart Comput(P +* I, (s +*
  Start-At(0,SCM+FSA)),k+1)
proof
  set J3= Goto  0 ';' Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  let k be Element of NAT;
  set s1 = Initialize s,
      P1 = P +* while>0(a,I);
  set sI = Initialize s,
      PI = P +* I;
A2: I c= PI by FUNCT_4:26;
  set sK1= Comput(P1, s1,1+k);
  set sK2= Comput(PI, sI,k);
  set l3=IC Comput(PI, sI,k);
  set I1= I ';' Goto  0;
  set i = a >0_goto  (card J + 3);
  reconsider n = l3 as Element of NAT;
  set Mi= i ';' J ';' Goto  (card I1 + 1);
  set J2= I1 ';' Stop SCM+FSA;
A3: rng I c= the Instructions of SCM+FSA by RELAT_1:def 19;
  assume I is_closed_on s,P;
  then
A4:  n in dom I by SCMFSA7B:def 7;
  then n < card I by AFINSQ_1:70;
  then
A5: n+4 < card I+ 6 by XREAL_1:10;
A6:  (PI)/.IC sK2 = PI.IC sK2 by PBOOLE:158;
A7: CurInstr(PI,sK2) =PI. n by A6
    .= I. n by A4,A2,GRFUNC_1:8;
  assume I is_halting_on s,P;
  then
A8: PI halts_on sI by SCMFSA7B:def 8;
  assume k < LifeSpan(PI,sI);
  then
A9: I. n <> halt SCM+FSA by A7,A8,EXTPRO_1:def 14;
A10: J2= I ';' J3 by SCMFSA6A:67;
  then dom J2 = dom Directed I \/ dom Reloc(J3, card I) by
FUNCT_4:def 1
    .= dom I \/ dom Reloc(J3, card I) by FUNCT_4:105;
  then
A11:  n in dom J2 by A4,XBOOLE_0:def 3;
  then  n + 4 in { il+4 where il is Element of NAT: il in dom J2};
  then
A12:  (n+4) in dom Shift(J2,4) by VALUED_1:def 12;
  then
A13: Shift(J2,4)/.(n+4) =Shift(J2,4).( n +4) by PARTFUN1:def 8
    .=J2. n by A11,VALUED_1:def 12
    .=(Directed I). n by A4,A10,SCMFSA8A:28
    .=I. n by A4,A9,SCMFSA8A:30;
  card while>0(a,I) = card I + 6 by Th5;
  then
A14:  (n+4) in dom while>0(a,I) by A5,AFINSQ_1:70;
  I. n in rng I by A4,FUNCT_1:def 5;
  then reconsider j = I. n as Instruction of SCM+FSA by A3;
A15: card Mi = card (i ';' J )+ card Goto  (card I1 + 1) by SCMFSA6A:61
    .= card (i ';' J ) + 1 by SCMFSA8A:29
    .= card (Macro i) + card J + 1 by SCMFSA6A:61
    .= 2 + 1 +1 by Lm1,COMPOS_1:150
    .= 3+ 1;
  then n+4 >= card Mi by NAT_1:11;
  then
A16: not  (n+4) in dom Mi by AFINSQ_1:70;
A17: Comput(PI, sI,k+1) = Following(PI,sK2) by
EXTPRO_1:4
    .= Exec(j,sK2) by A7;
  set f =  (card I +4) .--> goto  0;
  assume
A18: IC Comput(P1, s1,1+k)=l3 + 4;
  dom f = { (card I + 4)} & n + 4 <> card I + 4 by A4,FUNCOP_1:19;
  then
A19: not  (n+4) in dom f by TARSKI:def 1;
A20: dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then
A21:  (n+4) in dom if>0(a,I1,J) by A19,A14,XBOOLE_0:def 3;
A22: if>0(a, I1, J) = Mi ';' I1 ';' Stop SCM+FSA by SCMFSA8B:def 2
    .= Mi ';' J2 by SCMFSA6A:67
    .= Directed Mi +* Reloc(J2, 4) by A15;
  then
A23: dom if>0(a,I1,J) = dom Directed Mi \/ dom Reloc(J2, 4 )
  by FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom Reloc(J2, 4) by
FUNCT_4:105;
  then
A24:  (n+4) in dom Reloc(J2, 4) by A21,A16,XBOOLE_0:def 3
;
A25:  (P1)/.IC sK1 = P1.IC sK1 by PBOOLE:158;
  P1. (n+4) = (while>0(a,I)). (n+4)
    by A14,FUNCT_4:14
    .= (Directed Mi +* Reloc(J2, 4)). (n+4) by A19,A14,A20,A22,
FUNCT_4:def 1
    .= (Reloc(J2,4)). (n+4) by A21,A23,A24,FUNCT_4:def 1
    .= IncAddr(j,4) by A12,A13,COMPOS_1:def 40;
  then
A26: CurInstr(P1,sK1) =IncAddr(j,4) by A18,A25;
  assume
A27: DataPart sK1 = DataPart sK2;
  Comput(P1, s1,1+k+1) = Following(P1,sK1) by
EXTPRO_1:4
    .= Exec(IncAddr(j,4),sK1) by A26;
  hence thesis by A18,A27,A17,SCMFSA6A:41;
end;

theorem Th45:
  for a being Int-Location, I being Program of SCM+FSA, s being
  State of SCM+FSA st I is_closed_on s,P & I is_halting_on s,P & IC Comput(
        P +* while>0(a,I), (Initialize s),
  1 + LifeSpan(P +* I,Initialize s ) ) =
IC Comput(P +* I, (Initialize s),
LifeSpan(P +* I,Initialize s)) + 4
holds CurInstr(P +* while>0(a,I),
   Comput(P +* while>0(a,I), (Initialize s),
  1 + LifeSpan(P +* I,Initialize s) )) =
  goto  (card I +4)
proof
  set J3= Goto  0 ';' Stop SCM+FSA;
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  set s1 = Initialize s,
      P1 = P +* while>0(a,I);
A1: while>0(a,I) c= P1 by FUNCT_4:26;
  set sI = Initialize s,
      PI = P +* I;
A2: I c= PI by FUNCT_4:26;
  set life=LifeSpan(P +* I,Initialize s);
  set sK1= Comput(P1, s1,1+life);
  set sK2= Comput(PI, sI,life);
  set I1= I ';' Goto  0;
  set i = a >0_goto  (card J + 3);
  reconsider n = IC sK2 as Element of NAT;
  set Mi= i ';' J ';' Goto  (card I1 + 1);
  set J2= I1 ';' Stop SCM+FSA;
  assume I is_closed_on s,P;
  then
A4:  n in dom I by SCMFSA7B:def 7;
  then n < card I by AFINSQ_1:70;
  then
A5: n+4 < card I+ 6 by XREAL_1:10;
A6:  (PI)/.IC sK2 = PI.IC sK2 by PBOOLE:158;
  assume I is_halting_on s,P;
  then
A7: PI halts_on sI by SCMFSA7B:def 8;
  CurInstr(PI,sK2)
    = I. n by A4,A2,GRFUNC_1:8,A6;
  then
A8: I. n = halt SCM+FSA by A7,EXTPRO_1:def 14;
A9: J2= I ';' J3 by SCMFSA6A:67;
  then dom J2 = dom Directed I \/ dom Reloc(J3, card I) by
FUNCT_4:def 1
    .= dom I \/ dom Reloc(J3, card I) by FUNCT_4:105;
  then
A10:  n in dom J2 by A4,XBOOLE_0:def 3;
  then  n + 4 in { il+4 where il is Element of NAT: il in dom J2};
  then
A11:  (n+4) in dom Shift(J2,4) by VALUED_1:def 12;
  then
A12: Shift(J2,4)/.(n+4) =Shift(J2,4).( n +4) by PARTFUN1:def 8
    .=J2. n by A10,VALUED_1:def 12
    .=(Directed I). n by A4,A9,SCMFSA8A:28
    .=goto  card I by A4,A8,SCMFSA8A:30;
  set f =  (card I +4) .--> goto  0;
  assume
A13: IC sK1 = IC sK2 + 4;
  dom f = { (card I + 4)} & n + 4 <> card I + 4 by A4,FUNCOP_1:19;
  then
A14: not  (n+4) in dom f by TARSKI:def 1;
A15: card Mi = card (i ';' J )+ card Goto  (card I1 + 1) by SCMFSA6A:61
    .= card (i ';' J ) + 1 by SCMFSA8A:29
    .= card (Macro i) + card J + 1 by SCMFSA6A:61
    .= 2 + 1 +1 by Lm1,COMPOS_1:150
    .= 3+ 1;
  then n+4 >= card Mi by NAT_1:11;
  then
A16: not  (n+4) in dom Mi by AFINSQ_1:70;
  card while>0(a,I) = card I + 6 by Th5;
  then
A17:  (n+4) in dom while>0(a,I) by A5,AFINSQ_1:70;
A18: dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f by FUNCT_4:def 1;
  then
A19:  (n+4) in dom if>0(a,I1,J) by A14,A17,XBOOLE_0:def 3;
A20: if>0(a, I1, J) = Mi ';' I1 ';' Stop SCM+FSA by SCMFSA8B:def 2
    .= Mi ';' J2 by SCMFSA6A:67
    .= Directed Mi +* Reloc(J2, 4) by A15;
  then
A21: dom if>0(a,I1,J) = dom Directed Mi \/ dom Reloc(J2, 4 )
  by FUNCT_4:def 1;
  then dom if>0(a,I1,J) = dom Mi \/ dom Reloc(J2, 4) by
FUNCT_4:105;
  then
A22: n+4 in dom Reloc(J2, 4) by A19,A16,XBOOLE_0:def 3
;
A23:  (P1)/.IC sK1 = P1.IC sK1 by PBOOLE:158;
  P1. (n+4)
    = (if>0(a, I1, J) +* f). (n+4) by A17,A1,GRFUNC_1:8
    .= (Directed Mi +* Reloc(J2, 4)). (n+4) by A14,A17,A18,A20,
FUNCT_4:def 1
    .= (Reloc(J2,4)). (n+4) by A19,A21,A22,FUNCT_4:def 1
    .= IncAddr(goto  card I,4) by A11,A12,COMPOS_1:def 40
    .= goto  (card I+4) by SCMFSA_4:14;
  hence thesis by A13,A23;
end;

theorem Th46:
  for a being Int-Location, I being Program of SCM+FSA holds
  while>0(a,I). (card I +4) = goto  0
proof
  set J = Stop SCM+FSA;
  let a be Int-Location;
  let I be Program of SCM+FSA;
  set I1= I ';' Goto  0;
  set f =  (card I +4) .--> goto  0;
  set Lc4= (card I + 4 );
  dom f = {Lc4} by FUNCOP_1:19;
  then
A1: Lc4 in dom f by TARSKI:def 1;
  Lc4 in dom while>0(a,I) & dom while>0(a,I) = dom if>0(a,I1,J) \/ dom f
  by Th38,FUNCT_4:def 1;
  hence while>0(a,I).Lc4 = f.Lc4 by A1,FUNCT_4:def 1
    .=goto  0 by FUNCOP_1:87;
end;

theorem Th47:
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being read-write Int-Location
 st I is_closed_on s,P & I is_halting_on s,P & s.a >0
holds IC Comput(P +* while>0(a,I), (Initialize s),
(LifeSpan(P +* I,Initialize s) + 3)) =  0 &
for k being Element of NAT st k <= LifeSpan(P +* I,Initialize s) + 3
  holds IC Comput(P +* while>0(a,I), Initialize s,k) in dom while>0(a,I)
proof
  let s be State of SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  let I be Program of SCM+FSA;
  let a be read-write Int-Location;
  assume
A1: I is_closed_on s,P;
  set sI = Initialize s,
      PI = P +* I;
  set s1 = Initialize s,
      P1 = P +* while>0(a,I);
A2: while>0(a,I) c= P1 by FUNCT_4:26;
  defpred P[Nat] means $1 <= LifeSpan(PI,sI) implies IC Comput(
   P1, s1
,1+$1) = IC Comput(PI, sI,$1)+ 4 & DataPart Comput(P1, s1,1+$1) = DataPart
  Comput(PI, sI,$1);
  assume
A4: I is_halting_on s,P;
A5: now
    let k be Element of NAT;
    assume
A6: P[k];
    now
A7:   k + 0 < k + 1 by XREAL_1:8;
      assume k + 1 <= LifeSpan(PI,sI);
      then k < LifeSpan(PI,sI) by A7,XXREAL_0:2;
      hence IC Comput(P1, s1,1+k+1) = IC Comput(PI,
sI,k+1) + 4 & DataPart
      Comput(P1, s1,1+k+1) = DataPart Comput(PI, sI
,k+1) by A1,A4,A6,Th44;
    end;
    hence P[k + 1];
  end;
  reconsider l=LifeSpan(PI,sI) as Element of NAT;
  set loc4= (card I + 4);
  set i = a >0_goto  4;
  set s2 = Comput(P1,s1,1);
 IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
   then
A8: IC SCM+FSA in dom Start-At(0,SCM+FSA);
A9: IC s1 = IC(Start-At(0,SCM+FSA)) by A8,FUNCT_4:14
    .=  0 by COMPOS_1:64;
    Start-At(0,SCM+FSA) c= Initialize while>0(a,I) by FUNCT_4:26;
    then
X: dom Start-At(0,SCM+FSA) c= dom Initialize while>0(a,I)
        by RELAT_1:25;
  not a in dom (Initialize while>0(a,I)) by SCMFSA6B:12;
  then not a in dom Start-At(0,SCM+FSA) by X;
  then
A10: s1.a = s.a by FUNCT_4:12;
  assume
A11: s.a > 0;
A12:  0 in dom while>0(a,I) by Th10;
A13:  (P1)/.IC s1 = P1.IC s1 by PBOOLE:158;
  P1. 0 = while>0(a,I). 0 by A12,FUNCT_4:14
    .= i by Th11;
  then
A14: CurInstr(P1,s1) = i by A9,A13;
A15: Comput(P1,s1,0+1) =
Following(P1,Comput(P1,s1,0)
)
 by EXTPRO_1:4
    .= Following(P1,s1) by EXTPRO_1:3
    .= Exec(i,s1) by A14;
  then ( for c holds s2.c = s1.c)& for f holds s2.f = s1.f by SCMFSA_2:97;
  then
A16: DataPart s2 = DataPart s1 by SCMFSA6A:38
    .= DataPart sI;
A17: IC s2 =  4 by A11,A15,A10,SCMFSA_2:97;
A18: P[ 0]
  proof
    assume 0 <= LifeSpan(PI,sI);
 IC SCM+FSA in dom Start-At(0,SCM+FSA) by COMPOS_1:52;
    then
A19: IC SCM+FSA in dom Start-At(0,SCM+FSA);
    IC Comput(PI, sI,0) = IC sI by EXTPRO_1:3
      .= IC SA0 by A19,FUNCT_4:14
      .=  0 by COMPOS_1:64;
    hence thesis by A17,A16,EXTPRO_1:3;
  end;
A20: for k being Element of NAT holds P[k] from NAT_1:sch 1(A18,A5);
  set s4= Comput(P1, s1,1+LifeSpan(PI,sI)+1+1);
  set s3= Comput(P1, s1,1+LifeSpan(PI,sI)+1);
A21: loc4 in dom while>0(a,I) by Th38;
  set s2= Comput(P1, s1,1+LifeSpan(PI,sI));
  P[l] by A20;
  then
A22: CurInstr(P1,s2) = goto loc4 by A1,A4,Th45;
A23: s3 = Following(P1,s2) by EXTPRO_1:4
    .= Exec(goto loc4,s2) by A22;
A24: IC s3 = loc4 by A23,SCMFSA_2:95;
A25:  (P1)/.IC s3 = P1.IC s3 by PBOOLE:158;
  P1.loc4 = while>0(a,I).loc4 by A21,A2,GRFUNC_1:8
    .= goto  0 by Th46;
  then
A26: CurInstr(P1,s3) = goto  0 by A24,A25;
A27: s4 = Following(P1,s3) by EXTPRO_1:4
    .= Exec(goto  0,s3) by A26;
A28: IC s4 =  0 by A27,SCMFSA_2:95;
  hence IC Comput(P1, s1,LifeSpan(PI,sI)+3) =  0;
A29: LifeSpan(PI,sI)+1+1+1 =LifeSpan(PI,sI)+(2+1);
A30: now
    let k be Element of NAT;
    assume
A31: k <= LifeSpan(PI,sI)+3;
    assume k<>0;
    then consider n being Nat such that
A32: k = n+ 1 by NAT_1:6;
    k<=LifeSpan(PI,sI)+1 or k >= LifeSpan(PI,sI)+1+1
by NAT_1:13;
    then
A33: k
<=LifeSpan(PI,sI)+1 or k = LifeSpan(PI,sI)+1+1 or k >
LifeSpan(PI,sI)+1+1 by XXREAL_0:1;
    reconsider n as Element of NAT by ORDINAL1:def 13;
    per cases by A29,A33,NAT_1:13;
    suppose
      k<=LifeSpan(PI,sI)+1;
      then n <= LifeSpan(PI,sI) by A32,XREAL_1:8;
      then
A34:  IC Comput(P1,s1,1+n) = IC Comput(PI, sI,n) + 4
by A20;
      reconsider m = IC Comput(PI, sI,n) as Element of NAT;
       m in dom I by A1,SCMFSA7B:def 7;
      then m < card I by AFINSQ_1:70;
      then
A35:  m+4 < card I+ 6 by XREAL_1:10;
      card while>0(a,I) = card I + 6 by Th5;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A32,A34,A35,
AFINSQ_1:70
;
    end;
    suppose
      k=LifeSpan(PI,sI)+1+1;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A24,Th38;
    end;
    suppose
      k >= LifeSpan(PI,sI)+3;
      then k = LifeSpan(PI,sI)+3 by A31,XXREAL_0:1;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A28,Th10;
    end;
  end;
  now
    let k be Element of NAT;
    assume
A36: k <= LifeSpan(PI,sI)+3;
    per cases;
    suppose
      k = 0;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A12,A9,
EXTPRO_1:3;
    end;
    suppose
      k <>0;
      hence IC Comput(P1,s1,k) in dom while>0(a,I) by A30,A36;
    end;
  end;
  hence thesis;
end;

reserve s for State of SCM+FSA,
  I for Program of SCM+FSA,
  a for read-write
  Int-Location;

definition
  let s,I,a,P;
  deffunc U(Nat,State of SCM+FSA)
   = Comput(P +* while>0(a,I), $2 +* Start-At(0,SCM+FSA),
      LifeSpan(P +* while>0(a,I) +* I,$2 +* Start-At(0,SCM+FSA)) + 3);
  deffunc V(Nat,State of SCM+FSA) = down U($1,$2);
  func StepWhile>0(a,I,P,s) -> Function of NAT,product the Object-Kind of
  SCM+FSA means
  :Def5:
  it.0 = s & for i being Nat
   holds it.(i+1)= Comput(P +* while>0(a,I),
    it.i +* Start-At(0,SCM+FSA),
    LifeSpan(P +* while>0(a,I) +* I,
       it.i +* Start-At(0,SCM+FSA)) + 3);
  existence
  proof
   reconsider ss=s as
    Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
    consider f being Function of NAT,product the Object-Kind of SCM+FSA
    such that
A1:  f.0 = ss and
A2:  for i being Nat holds f.(i+1)= V(i,f.i) from NAT_1:sch 12;
   take f;
   thus f.0 = s by A1;
   let i be Nat;
    f.(i+1)= V(i,f.i) by A2;
   hence thesis;
  end;
  uniqueness
  proof
    let F1,F2 be Function of NAT,product the Object-Kind of SCM+FSA such that
A3: F1.0 = s and
A4: for i being Nat holds F1.(i+1)= U(i,F1.i) and
A5: F2.0 = s and
A6: for i being Nat holds F2.(i+1)= U(i,F2.i);
   reconsider s as Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
A7: F1.0 = s by A3;
A8: for i being Nat holds F1.(i+1)= V(i,F1.i) by A4;
A9: F2.0 = s by A5;
A10: for i being Nat holds F2.(i+1)= V(i,F2.i) by A6;
   F1 = F2 from NAT_1:sch 16(A7,A8,A9,A10);
  hence thesis;
  end;
end;

canceled 2;

theorem Th50:
  StepWhile>0(a,I,P,s).(k+1)=StepWhile>0(a,I,P,StepWhile>0(a,I,P,s).k).1
proof
  set sk=StepWhile>0(a,I,P,s).k;
  set sk0=StepWhile>0(a,I,P,sk).0;
  sk0=sk by Def5;
  hence
  StepWhile>0(a,I,P,s).(k+1) = Comput(P +* while>0(a,I),
    sk0 +*Start-At(0,SCM+FSA) ,
     LifeSpan(P +* while>0(a,I) +* I,sk0 +* Start-At(0,SCM+FSA)) + 3) by Def5
    .=StepWhile>0(a,I,P,sk).(0+1) by Def5
    .=StepWhile>0(a,I,P,sk).1;
end;

theorem Th51:
  for I being Program of SCM+FSA,a being read-write Int-Location,
  s being State of SCM+FSA holds StepWhile>0(a,I,P,s).(0+1)
  = Comput(P +* while>0(a,I),
       Initialize s,
       LifeSpan(P +* while>0(a,I)+* I,Initialize s) + 3)
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA;
A1: StepWhile>0(a,I,P,s).0 = s by Def5;
  thus StepWhile>0(a,I,P,s).(0+1)
    = Comput(P +* while>0(a,I), (Initialize s),
    (LifeSpan(P +* while>0(a,I)+* I,Initialize s)
  + 3)) by A1,Def5;
end;

theorem Th52:
  for I being Program of SCM+FSA,a being read-write Int-Location,
s being State of SCM+FSA,k,n being Element of NAT
 st IC StepWhile>0(a,I,P,s).k =
   0 & StepWhile>0(a,I,P,s).k= Comput(P +* while>0(a,I),
   (Initialize s),n)
 holds StepWhile>0(a,I,P,s).k = Initialize(StepWhile>0(a,I,P,s).k)
  & StepWhile>0(a,I,P,s).(k+1)=
Comput(P +* while>0(a,I), Initialize s,
   n +(LifeSpan(P +* while>0(a,I) +* I,Initialize(StepWhile>0(a,I,P,s).k)
  ) + 3))
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA,k,n be Element of NAT;
  set D = Int-Locations \/ FinSeq-Locations;
  set s1 = Initialize s,
      P1 = P +* while>0(a,I);
  set sk=StepWhile>0(a,I,P,s).k;
  set s2=Initialize sk;
  assume
A1: IC sk = 0;
  assume
A3: sk = Comput(P1, s1,n);
   sk is 0-started by A1,COMPOS_1:def 20;
   then Start-At(0,SCM+FSA) c= sk by COMPOS_1:151;
  hence s2=sk by FUNCT_4:104;
  hence
  StepWhile>0(a,I,P,s).(k+1)=
   Comput(P1, sk,LifeSpan(P +* while>0(a,I) +* I,
   Initialize sk) +3)
   by Def5
   .= Comput(P1, s1,n +(LifeSpan(P +* while>0(a,I) +* I,
   Initialize sk) + 3))
        by A3,EXTPRO_1:5;
end;

theorem Th53:
  for I being Program of SCM+FSA,a being read-write Int-Location,
s being State of SCM+FSA st (for k being Nat
 holds I is_closed_on StepWhile>0(a,I,P,s).k,P+*while>0(a,I) &
  I is_halting_on StepWhile>0(a,I,P,s).k,P+*while>0(a,I)) &
  ex f being Function of
  product the Object-Kind of SCM+FSA,NAT st (for k being Nat holds (f.(
StepWhile>0(a,I,P,s).(k+1)) < f.(StepWhile>0(a,I,P,s).k) or
 f.(StepWhile>0(a,I,P,s).k
  ) = 0) & ( f.(StepWhile>0(a,I,P,s).k)=0 iff
   (StepWhile>0(a,I,P,s).k).a <= 0 ))
  holds while>0(a,I) is_halting_on s,P & while>0(a,I) is_closed_on s,P
proof
  let I be Program of SCM+FSA,a be read-write Int-Location, s be State of
  SCM+FSA;
  set D = Int-Locations \/ FinSeq-Locations;
  assume
A1: for k being Nat holds
     I is_closed_on StepWhile>0(a,I,P,s).k,P+*while>0(a,I) &
     I is_halting_on StepWhile>0(a,I,P,s).k,P+*while>0(a,I);
  set s1 = Initialize s,
      P1 = P +* while>0(a,I);
A4:  P1 +* while>0(a,I) = P1 by FUNCT_4:99;
A5:  P1 +* while>0(a,I) = P1 by FUNCT_4:99;
  given f being Function of product the Object-Kind of SCM+FSA,NAT such that
A6: for k being Nat
 holds (f.(StepWhile>0(a,I,P,s).(k+1)) < f.(StepWhile>0
(a,I,P,s).k) or f.(StepWhile>0(a,I,P,s).k) = 0) &
 ( f.(StepWhile>0(a,I,P,s).k)=0
 iff
  (StepWhile>0(a,I,P,s).k).a <= 0 );
  deffunc F(Nat) = f.(StepWhile>0(a,I,P,s).$1);
A7: for k being Nat holds F(k+1) < F(k) or F(k) = 0 by A6;
  consider m being Nat such that
A8: F(m)=0 and
A9: for n being Nat st F(n) =0 holds m <= n from NAT_1:sch 17(A7);
  defpred P[Nat] means $1+1 <= m implies ex k st StepWhile>0(a,I,P,s)
  .($1+1)= Comput(P1, s1,k);
A10: now
    let k be Element of NAT;
    assume
A11: P[k];
    now
      set sk1=StepWhile>0(a,I,P,s).(k+1);
      set sk=StepWhile>0(a,I,P,s).k;
      assume
A12:   (k+1)+ 1 <= m;
      k + 0 < k+ (1+ 1) by XREAL_1:8;
      then k < m by A12,XXREAL_0:2;
      then F(k) <> 0 by A9;
      then
A13:  sk.a > 0 by A6;
A14:  I is_halting_on sk,P+*while>0(a,I) by A1;
      (k+1)+ 0 < (k+ 1)+ 1 by XREAL_1:8;
      then consider n being Element of NAT such that
A15:  sk1 = Comput(P1, s1,n) by A11,A12,XXREAL_0:2;
      take m=n +(LifeSpan(P +* while>0(a,I) +* I,
      Initialize sk1) + 3
);
      sk1= Comput(P +* while>0(a,I), (Initialize sk),
      (LifeSpan(P +* while>0(a,I) +* I,Initialize sk) + 3)) &
      I is_closed_on sk,P+*while>0(a,I) by A1,Def5;
      then IC sk1 = 0 by A14,A13,Th47,A4;
      hence StepWhile>0(a,I,P,s).((k+1)+1)= Comput(P1, s1,m) by A15
,Th52;
    end;
    hence P[k+1];
  end;
A16: P[ 0]
  proof
    assume 0+1 <= m;
    take n=(LifeSpan(P+*while>0(a,I)+* I,Initialize s) + 3);
    thus thesis by Th51;
  end;
A17: for k being Element of NAT holds P[k] from NAT_1:sch 1(A16,A10);
  now
    per cases;
    suppose
      m=0;
      then (StepWhile>0(a,I,P,s).0).a <= 0 by A6,A8;
      then s.a <= 0 by Def5;
      hence thesis by Th43;
    end;
    suppose
A18:  m<>0;
      set p=(LifeSpan(P+*while>0(a,I)+* I,Initialize s) + 3);
      set sm=StepWhile>0(a,I,P,s).m;
      set sm1=Initialize sm;
      consider i being Nat such that
A19:  m=i+1 by A18,NAT_1:6;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      m=i+1 by A19;
      then consider n being Element of NAT such that
A20:  sm = Comput(P1, s1,n) by A17;
      set si=StepWhile>0(a,I,P,s).i;
      i < m by A19,NAT_1:13;
      then F(i) <> 0 by A9;
      then
A21:  si.a > 0 by A6;
A22:  I is_closed_on si,P+*while>0(a,I) &
      I is_halting_on si,P+*while>0(a,I) by A1;
      sm= Comput(P +* while>0(a,I), (Initialize si),
      (LifeSpan(P +* while>0(a,I) +* I,Initialize si) + 3))
       by A19,Def5;
      then
A24:  IC sm = 0 by A22,A21,Th47,A4;
   sm is 0-started by A24,COMPOS_1:def 20;
   then Start-At(0,SCM+FSA) c= sm by COMPOS_1:151;
   then
A27:  sm1=sm by FUNCT_4:104;
A28:  sm.a <= 0 by A6,A8;
      then while>0(a,I) is_halting_on sm,P1 by Th43;
      then P1 +* while>0(a,I) halts_on Initialize sm by SCMFSA7B:def 8;
      then P1 halts_on sm1 by A5;
      then consider j being Element of NAT such that
A29:  CurInstr(P1,Comput(P1,sm,j))
        = halt SCM+FSA by A27,EXTPRO_1:30;
A30: Comput(P1,s1,n+j)
 = Comput(P1,Comput(P1,s1,n),j) by EXTPRO_1:5;
      CurInstr(P1,Comput(P1,s1,n+j))
       = halt SCM+FSA by A20,A29,A30;
      then P1 halts_on s1 by EXTPRO_1:30;
      hence while>0(a,I) is_halting_on s,P by SCMFSA7B:def 8;
      now
        let q be Element of NAT;
A31:    0<m by A18;
        per cases;
        suppose
A32:      q <= p;
A33:      StepWhile>0(a,I,P,s).0=s by Def5;
          then
A34:      I is_closed_on s,P+*while>0(a,I) &
          I is_halting_on s,P+*while>0(a,I) by A1;
          F(0) <> 0 by A9,A31;
          then s.a > 0 by A6,A33;
          hence IC Comput(P1,s1,q) in dom while>0(a,I) by A32,A34
,Th47,A4;
        end;
        suppose
A35:      q > p;
A36:      now
            take k=p;
            thus StepWhile>0(a,I,P,s).1= Comput(P1, s1,k) & k <= q
by A35,Th51;
          end;
          defpred P2[Nat] means $1<=m & $1<>0 &
           (ex k st StepWhile>0(a,I,P,s).$1
          = Comput(P1, s1,k) & k <= q);
A37:      for i be Nat st P2[i] holds i <= m;
          0+1 < m +1 by A31,XREAL_1:8;
          then 1 <= m by NAT_1:13;
          then
A38:      ex t be Nat st P2[t] by A36;
          consider t be Nat such that
A39:      P2[t] & for i be Nat st P2[i] holds i <= t from NAT_1:sch 6
          (A37,A38);
          reconsider t as Element of NAT by ORDINAL1:def 13;
          now
            per cases;
            suppose
              t=m;
              then consider r being Element of NAT such that
A40:          sm= Comput(P1, s1,r) and
A41:          r <= q by A39;
              consider x being Nat such that
A42:          q = r+x by A41,NAT_1:10;
A43:          while>0(a,I) is_closed_on sm,P1 by A28,Th43;
              reconsider x as Element of NAT by ORDINAL1:def 13;
A44:          Comput(P1,s1,q) = Comput(P1, sm1,x) by A27,A40,A42,EXTPRO_1:5;
              thus IC Comput(P1,s1,q) in dom while>0(a,I) by A43
,SCMFSA7B:def 7,A44,A5;
            end;
            suppose
A45:          t<>m;
              set Dt=StepWhile>0(a,I,P,s).t;
A46:          t < m by A39,A45,XXREAL_0:1;
              then F(t) <> 0 by A9;
              then
A47:          Dt.a > 0 by A6;
              consider z being Element of NAT such that
A48:          StepWhile>0(a,I,P,s).t= Comput(P1, s1,z) and
A49:          z <= q by A39;
              set z2=z +(LifeSpan(P+*while>0(a,I) +* I,
                 Initialize Dt) + 3);
              consider w being Nat such that
A50:          q = z+w by A49,NAT_1:10;
A51:          I is_closed_on Dt,P+*while>0(a,I) &
              I is_halting_on Dt,P+*while>0(a,I) by A1;
              consider y being Nat such that
A52:          t=y+1 by A39,NAT_1:6;
              reconsider y as Element of NAT by ORDINAL1:def 13;
              set Dy=StepWhile>0(a,I,P,s).y;
              y+ 0 < t by A52,XREAL_1:8;
              then y < m by A39,XXREAL_0:2;
              then F(y) <> 0 by A9;
              then
A53:          Dy.a > 0 by A6;
A54:          I is_closed_on Dy,P+*while>0(a,I) &
              I is_halting_on Dy,P+*while>0(a,I) by A1;
              reconsider w as Element of NAT by ORDINAL1:def 13;
              Dt= Comput(P +* while>0(a,I),
                   (Initialize Dy),
              (LifeSpan(P +* while>0(a,I) +* I,
              Initialize Dy) + 3)) by A52,Def5;
              then
A55:          IC Dt = 0 by A54,A53,Th47,A4;
              now
                assume
A56:            z2 <= q;
A57:            now
                  take k=z2;
                  thus StepWhile>0(a,I,P,s).(t+1)= Comput(P1, s1,k)
& k <= q
by A48,A55,A56,Th52;
                end;
                t+1 <= m by A46,NAT_1:13;
                hence contradiction by A39,A57,XREAL_1:31;
              end;
              then
A58:          w < LifeSpan(P +* while>0(a,I) +* I,Initialize Dt) + 3
by A50,XREAL_1:8;
A59: Initialize Dt = Dt by A48,A55,Th52;
              Comput(P1,s1,q)
                = Comput(P +* while>0(a,I),
                (Initialize Dt),w) by A59,A48,A50,EXTPRO_1:5;
              hence IC Comput(P1,s1,q) in dom while>0(a,I) by A58
,A51,A47,Th47,A4;
            end;
          end;
          hence IC Comput(P1,s1,q) in dom while>0(a,I);
        end;
      end;
      hence while>0(a,I) is_closed_on s,P by SCMFSA7B:def 7;
    end;
  end;
  hence thesis;
end;

theorem Th54:
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location, s being State of SCM+FSA st ex f being Function of product the
Object-Kind of SCM+FSA,NAT st (for k being Nat
 holds (f.(StepWhile>0(a,I,P,s).(k+
  1)) < f.(StepWhile>0(a,I,P,s).k) or f.(StepWhile>0(a,I,P,s).k) = 0) & ( f.(
StepWhile>0(a,I,P,s).k)=0 iff (StepWhile>0(a,I,P,s).k).a <= 0 ) )
 holds while>0(a,I
  ) is_halting_on s,P & while>0(a,I) is_closed_on s,P
proof
  let I be parahalting Program of SCM+FSA,a be read-write Int-Location,s be
  State of SCM+FSA;
A1: for k being Nat holds
    I is_closed_on StepWhile>0(a,I,P,s).k,P+*while>0(a,I) &
    I is_halting_on StepWhile>0(a,I,P,s).k,P+*while>0(a,I) by SCMFSA7B:24,25;
  assume ex f being Function of product the Object-Kind of SCM+FSA,NAT st for
k being Nat holds (f.(StepWhile>0(a,I,P,s).(k+1)) < f.(StepWhile>0(a,I,P,s).k)
 or f
.(StepWhile>0(a,I,P,s).k) = 0) & ( f.(StepWhile>0(a,I,P,s).k)=0
 iff (StepWhile>0(a,I,P,s).k).a <= 0 );
  hence thesis by A1,Th53;
end;

theorem
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location st ex f being Function of product the Object-Kind of SCM+FSA,NAT
st (for s being State of SCM+FSA,P holds (f.(StepWhile>0(a,I,P,s).1) < f.s
 or f.s =
  0) & ( f.s =0 iff s.a <= 0 )) holds while>0(a,I) is parahalting
proof
  let I be parahalting Program of SCM+FSA,a be read-write Int-Location;
  given f being Function of product the Object-Kind of SCM+FSA,NAT such that
A1: for s being State of SCM+FSA,P holds (f.(StepWhile>0(a,I,P,s).1) < f.s
  or f.s = 0) & ( f.s =0 iff s.a <= 0 );
  now
    let t be State of SCM+FSA;
    let Q;
    now
      let k be Nat;
A2:   k in NAT by ORDINAL1:def 13;
      f.(StepWhile>0(a,I,Q,StepWhile>0(a,I,Q,t).k).1)
       < f.(StepWhile>0(a,I,Q,t).
      k) or f.(StepWhile>0(a,I,Q,t).k) = 0 by A1;
      hence (f.(StepWhile>0(a,I,Q,t).(k+1)) < f.(StepWhile>0(a,I,Q,t).k) or f.(
StepWhile>0(a,I,Q,t).k) = 0) & ( f.(StepWhile>0(a,I,Q,t).k)=0
 iff (StepWhile>0(a,I,Q,
      t).k).a <= 0 ) by A1,A2,Th50;
    end;
    hence while>0(a,I) is_halting_on t,Q by Th54;
  end;
  hence thesis by SCMFSA7B:25;
end;

registration
  let I,J be good Program of SCM+FSA,a be Int-Location;
  cluster if>0(a,I,J) -> good;
  coherence
  proof
    set i = a >0_goto  (card J + 3);
    reconsider Mi=Macro i as good Program of SCM+FSA by Th36,SCMFSA7B:19;
    if>0(a,I,J) = i ';' J ';' Goto  (card I + 1) ';' I ';' Stop
    SCM+FSA by SCMFSA8B:def 2
      .= Mi ';' J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
    hence thesis;
  end;
end;

registration
  let I be good Program of SCM+FSA,a be Int-Location;
  cluster while>0(a,I) -> good;
  correctness
  proof
    set F=if>0(a, I ';' Goto  0, Stop SCM+FSA);
    set J= (card I +4) .--> goto  0;
    J does not destroy intloc 0 & F does not destroy intloc 0 by Th35,
SCMFSA7B:def 5;
    then while>0(a,I) does not destroy intloc 0 by SCMFSA8A:25;
    hence thesis by SCMFSA7B:def 5;
  end;
end;

