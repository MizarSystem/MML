:: Relocatability
::  by Yasushi Tanaka
::
:: Received June 16, 1994
:: Copyright (c) 1994 Association of Mizar Users

environ

 vocabularies SUBSET_1, NUMBERS, AMI_1, AMI_3, AMISTD_2,
      ARYTM_3, GRAPHSP, CARD_1, RELAT_1, FUNCT_1, PARTFUN1, TARSKI,
      FUNCT_4, XBOOLE_0, FSM_1, CIRCUIT2, SCMNORM, ARYTM_1, INT_1,
      XXREAL_0, GLIB_000, STRUCT_0, TURING_1, ORDINAL1, RELOC,
      FINSEQ_1, NAT_1, AMISTD_5, PBOOLE, COMPOS_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, INT_1, NAT_1,
      VALUED_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, PBOOLE, FINSEQ_1,
      NAT_D, STRUCT_0, COMPOS_1, EXTPRO_1, AMI_3, XXREAL_0, AMISTD_2,
      AMISTD_5;
 constructors DOMAIN_1, XXREAL_0, AMI_3, NAT_D, PRE_POLY, RECDEF_2,
      AMISTD_2, VALUED_1, AMI_2, AMI_1, AMISTD_1, AMISTD_5, PBOOLE;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, NUMBERS,
      XREAL_0, INT_1, CARD_3, AMI_1, AMI_3, RELAT_1,
      GRFUNC_1, FUNCT_2, AMI_6, VALUED_0, AMISTD_2, COMPOS_1, EXTPRO_1, NAT_1,
      FINSEQ_1, AMISTD_5, AMI_5, PBOOLE;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, RELAT_1, TARSKI, AMI_3,
      AMISTD_2, FUNCT_1, AMISTD_5;
 theorems AMI_1, AMI_3, GRFUNC_1, NAT_1, TARSKI, FUNCT_4, FUNCT_1, AMI_5,
      RELAT_1, XBOOLE_1, PARTFUN1, VALUED_1, RECDEF_2, FINSEQ_1, COMPOS_1,
      EXTPRO_1, ORDINAL1, AMISTD_2, AMISTD_5;
 schemes NAT_1;

begin  :: Relocatability

reserve j, k, m for Element of NAT;

registration
 let a,b be Data-Location;
 cluster a:=b -> ins-loc-free;
 coherence
  proof
   thus JumpPart(a:=b) is empty;
  end;
 cluster AddTo(a,b) -> ins-loc-free;
 coherence
  proof
   thus JumpPart AddTo(a,b) is empty;
  end;
 cluster SubFrom(a,b) -> ins-loc-free;
 coherence
  proof
   thus JumpPart SubFrom(a,b) is empty;
  end;
 cluster MultBy(a,b) -> ins-loc-free;
 coherence
  proof
   thus JumpPart MultBy(a,b) is empty;
  end;
 cluster Divide(a,b) -> ins-loc-free;
 coherence
  proof
   thus JumpPart Divide(a,b) is empty;
  end;
end;

theorem Th1:
  for k,loc being Nat
  holds IncAddr(SCM-goto loc,k) = SCM-goto (loc + k)
proof
  let k,loc be Nat;
A1: InsCode IncAddr(SCM-goto loc,k) = InsCode SCM-goto loc by COMPOS_1:def 38
     .= 6 by RECDEF_2:def 1
     .= InsCode SCM-goto (loc + k) by RECDEF_2:def 1;
A2: AddressPart IncAddr(SCM-goto loc,k) = AddressPart SCM-goto loc
           by COMPOS_1:def 38
     .= {} by RECDEF_2:def 3
     .= AddressPart SCM-goto (loc + k)by RECDEF_2:def 3;
A3: JumpPart IncAddr(SCM-goto loc,k) = k + JumpPart SCM-goto loc
                   by COMPOS_1:def 38;
  JumpPart IncAddr(SCM-goto loc,k) = JumpPart SCM-goto (loc + k)
   proof
    thus
A4:   dom JumpPart IncAddr(SCM-goto loc,k)
     = dom JumpPart SCM-goto (loc + k) by A1,COMPOS_1:def 33;
A5: JumpPart SCM-goto loc = <*loc*> by RECDEF_2:def 2;
A6: JumpPart SCM-goto(loc+k) = <*loc+k*> by RECDEF_2:def 2;
    let x be set;
    assume
A7:   x in dom JumpPart IncAddr(SCM-goto loc,k);
     dom <*loc+k*> = {1} by FINSEQ_1:4,55;
     then
A8:   x = 1 by A7,A4,A6,TARSKI:def 1;
    thus (JumpPart IncAddr(SCM-goto loc,k)).x
      = k + (JumpPart SCM-goto loc).x by A3,A7,VALUED_1:def 2
     .= loc + k by A5,A8,FINSEQ_1:57
     .= (JumpPart SCM-goto(loc + k)).x by A6,A8,FINSEQ_1:57;
   end;
 hence thesis by A1,A2,COMPOS_1:7;
end;

theorem Th2:
  for k,loc being Nat, a being Data-Location
   holds IncAddr(a=0_goto loc,k) = a=0_goto (loc + k)
proof
  let k,loc be Nat, a be Data-Location;
A1: InsCode IncAddr(a=0_goto loc,k) = InsCode(a=0_goto loc) by COMPOS_1:def 38
     .= 7 by RECDEF_2:def 1
     .= InsCode(a=0_goto(loc + k)) by RECDEF_2:def 1;
A2: AddressPart IncAddr(a=0_goto loc,k) = AddressPart(a=0_goto loc)
           by COMPOS_1:def 38
     .= <*a*> by RECDEF_2:def 3
     .= AddressPart(a=0_goto (loc + k)) by RECDEF_2:def 3;
A3: JumpPart IncAddr(a=0_goto loc,k) = k + JumpPart(a=0_goto loc)
                   by COMPOS_1:def 38;
  JumpPart IncAddr(a=0_goto loc,k) = JumpPart(a=0_goto (loc + k))
   proof
    thus
A4:   dom JumpPart IncAddr(a=0_goto loc,k)
     = dom JumpPart(a=0_goto (loc + k)) by A1,COMPOS_1:def 33;
A5: JumpPart(a=0_goto loc) = <*loc*> by RECDEF_2:def 2;
A6: JumpPart(a=0_goto (loc+k)) = <*loc+k*> by RECDEF_2:def 2;
    let x be set;
    assume
A7:   x in dom JumpPart IncAddr(a=0_goto loc,k);
     dom <*loc+k*> = {1} by FINSEQ_1:4,55;
     then
A8:   x = 1 by A7,A4,A6,TARSKI:def 1;
    thus (JumpPart IncAddr(a=0_goto loc,k)).x
      = k + (JumpPart(a=0_goto loc)).x by A3,A7,VALUED_1:def 2
     .= loc + k by A5,A8,FINSEQ_1:57
     .= (JumpPart(a=0_goto(loc + k))).x by A6,A8,FINSEQ_1:57;
   end;
 hence thesis by A1,A2,COMPOS_1:7;
end;

theorem Th3:
  for k,loc being Nat, a being Data-Location
   holds IncAddr(a>0_goto loc,k) = a>0_goto (loc + k)
proof
  let k,loc be Nat, a be Data-Location;
A1: InsCode IncAddr(a>0_goto loc,k) = InsCode(a>0_goto loc) by COMPOS_1:def 38
     .= 8 by RECDEF_2:def 1
     .= InsCode(a>0_goto(loc + k)) by RECDEF_2:def 1;
A2: AddressPart IncAddr(a>0_goto loc,k) = AddressPart(a>0_goto loc)
           by COMPOS_1:def 38
     .= <*a*> by RECDEF_2:def 3
     .= AddressPart(a>0_goto (loc + k)) by RECDEF_2:def 3;
A3: JumpPart IncAddr(a>0_goto loc,k) = k + JumpPart(a>0_goto loc)
                   by COMPOS_1:def 38;
  JumpPart IncAddr(a>0_goto loc,k) = JumpPart(a>0_goto (loc + k))
   proof
    thus
A4:   dom JumpPart IncAddr(a>0_goto loc,k)
     = dom JumpPart(a>0_goto (loc + k)) by A1,COMPOS_1:def 33;
A5: JumpPart(a>0_goto loc) = <*loc*> by RECDEF_2:def 2;
A6: JumpPart(a>0_goto (loc+k)) = <*loc+k*> by RECDEF_2:def 2;
    let x be set;
    assume
A7:   x in dom JumpPart IncAddr(a>0_goto loc,k);
     dom <*loc+k*> = {1} by FINSEQ_1:4,55;
     then
A8:   x = 1 by A7,A4,A6,TARSKI:def 1;
    thus (JumpPart IncAddr(a>0_goto loc,k)).x
      = k + (JumpPart(a>0_goto loc)).x by A3,A7,VALUED_1:def 2
     .= loc + k by A5,A8,FINSEQ_1:57
     .= (JumpPart(a>0_goto(loc + k))).x by A6,A8,FINSEQ_1:57;
   end;
 hence thesis by A1,A2,COMPOS_1:7;
end;

theorem Th4:
  for I being Instruction of SCM, k being Element of NAT st
InsCode I = 0 or InsCode I = 1 or InsCode I = 2 or InsCode I = 3 or InsCode I =
  4 or InsCode I = 5 holds IncAddr (I, k) = I
proof
  let I be Instruction of SCM, k be Element of NAT;
  assume that
A1: InsCode I = 0 or InsCode I = 1 or InsCode I = 2 or InsCode I = 3 or
  InsCode I = 4 or InsCode I = 5;
  per cases by A1;
  suppose InsCode I = 0;
   then I = halt SCM by AMI_5:46;
  hence thesis by COMPOS_1:93;
  end;
  suppose InsCode I = 1;
   then ex da,db being Data-Location st I = da:=db by AMI_5:47;
  hence IncAddr(I,k) = I by COMPOS_1:92;
  end;
  suppose InsCode I = 2;
   then ex da,db being Data-Location st I = AddTo(da,db) by AMI_5:48;
   hence IncAddr(I,k) = I by COMPOS_1:92;
  end;
  suppose InsCode I = 3;
   then ex da,db being Data-Location st I = SubFrom(da,db) by AMI_5:49;
  hence IncAddr(I,k) = I by COMPOS_1:92;
  end;
  suppose InsCode I = 4;
   then ex da,db being Data-Location st I = MultBy(da,db) by AMI_5:50;
   hence IncAddr(I,k) = I by COMPOS_1:92;
  end;
  suppose InsCode I = 5;
   then ex da,db being Data-Location st I = Divide(da,db) by AMI_5:51;
   hence IncAddr(I,k) = I by COMPOS_1:92;
  end;
end;

theorem
  for II, I being Instruction of SCM, k being Element of NAT st (
InsCode I = 0 or InsCode I = 1 or InsCode I = 2 or InsCode I = 3 or InsCode I =
  4 or InsCode I = 5) & IncAddr (II, k) = I holds II = I
proof
  let II, I be Instruction of SCM, k be Element of NAT;
  assume that
A1: InsCode I = 0 or InsCode I = 1 or InsCode I = 2 or InsCode I = 3 or
  InsCode I = 4 or InsCode I = 5 and
A2: IncAddr (II, k) = I;
   IncAddr(I,k) = I by A1,Th4;
  hence thesis by A2,COMPOS_1:95;
end;

registration
 cluster SCM -> relocable;
 coherence
 proof let INS be Instruction of SCM, j,k be Nat;
   reconsider k as Element of NAT by ORDINAL1:def 13;
  let s be State of SCM;
A1: IC IncIC(Exec(IncAddr(INS,j),s),k)
       = IC Exec(IncAddr(INS,j),s) + k by COMPOS_1:54
      .= IC Exec(IncAddr(INS,j+k),IncIC(s,k)) by AMISTD_2:def 18;
         :: steady programmed
A2: now
    let l be Element of NAT;
    thus Exec(IncAddr(INS,j+k),IncIC(s,k)).l
       = IncIC(s,k).l by AMI_1:def 13
      .= s.l by COMPOS_1:20
      .= Exec(IncAddr(INS,j),s).l by AMI_1:def 13
      .= IncIC(Exec(IncAddr(INS,j),s),k).l by COMPOS_1:20;
  end;
  per cases by AMI_5:36,NAT_1:33;
  suppose InsCode INS = 0;
    then
A3: INS = halt SCM by AMI_5:46;
    Exec(IncAddr(INS,j+k),IncIC(s,k))
       = Exec(INS,IncIC(s,k)) by A3,COMPOS_1:93
      .= IncIC(s,k) by EXTPRO_1:def 3,A3
      .= IncIC(Exec(IncAddr(INS,j),s),k) by A3,EXTPRO_1:def 3;
   hence thesis;
  end;
  suppose InsCode INS = 1;
    then consider da,db being Data-Location such that
A4: INS = da := db by AMI_5:47;
    now
      let d be Data-Location;
      per cases;
      suppose
A5:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A4,COMPOS_1:92
          .= IncIC(s,k).db by A4,A5,AMI_3:8
          .= s.db by AMI_5:80
          .= Exec(INS, s).d by A4,A5,AMI_3:8
          .= Exec(IncAddr(INS,j), s).d by A4,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
      end;
      suppose
A6:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A4,COMPOS_1:92
          .= IncIC(s,k).d by A4,A6,AMI_3:8
          .= s.d by AMI_5:80
          .= Exec(INS, s).d by A4,A6,AMI_3:8
          .= Exec(IncAddr(INS,j), s).d by A4,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
      end;
    end;
   hence thesis by A2,AMI_5:26,A1;
  end;
  suppose InsCode INS = 2;
    then consider da,db being Data-Location such that
A7: INS = AddTo(da, db) by AMI_5:48;
    now let d be Data-Location;
      per cases;
      suppose
A8:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A7,COMPOS_1:92
          .= IncIC(s,k).da + IncIC(s,k).db by A8,A7,AMI_3:9
          .= s.da + IncIC(s,k).db by AMI_5:80
          .= s.da + s.db by AMI_5:80
          .= Exec(INS, s).d by A7,A8,AMI_3:9
          .= Exec(IncAddr(INS,j), s).d by A7,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
      end;
      suppose
A9:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A7,COMPOS_1:92
          .= IncIC(s,k).d by A7,A9,AMI_3:9
          .= s.d by AMI_5:80
          .= Exec(INS, s).d by A7,A9,AMI_3:9
          .= Exec(IncAddr(INS,j), s).d by A7,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
      end;
    end;
   hence thesis by A2,AMI_5:26,A1;
  end;
  suppose InsCode INS = 3;
    then consider da,db being Data-Location such that
A10: INS = SubFrom(da, db) by AMI_5:49;
    now let d be Data-Location;
      per cases;
      suppose
A11:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A10,COMPOS_1:92
          .= IncIC(s,k).da - IncIC(s,k).db by A11,A10,AMI_3:10
          .= s.da - IncIC(s,k).db by AMI_5:80
          .= s.da - s.db by AMI_5:80
          .= Exec(INS, s).d by A10,A11,AMI_3:10
          .= Exec(IncAddr(INS,j), s).d by A10,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
      end;
      suppose
A12:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A10,COMPOS_1:92
          .= IncIC(s,k).d by A10,A12,AMI_3:10
          .= s.d by AMI_5:80
          .= Exec(INS, s).d by A10,A12,AMI_3:10
          .= Exec(IncAddr(INS,j), s).d by A10,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
      end;
    end;
    hence thesis by A2,AMI_5:26,A1;
  end;
  suppose InsCode INS = 4;
    then consider da,db being Data-Location such that
A13: INS = MultBy(da, db) by AMI_5:50;
    now let d be Data-Location;
      per cases;
      suppose
A14:     da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A13,COMPOS_1:92
          .= IncIC(s,k).da * IncIC(s,k).db by A14,A13,AMI_3:11
          .= s.da * IncIC(s,k).db by AMI_5:80
          .= s.da * s.db by AMI_5:80
          .= Exec(INS, s).d by A13,A14,AMI_3:11
          .= Exec(IncAddr(INS,j), s).d by A13,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
      end;
      suppose
A15:     da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A13,COMPOS_1:92
          .= IncIC(s,k).d by A13,A15,AMI_3:11
          .= s.d by AMI_5:80
          .= Exec(INS, s).d by A13,A15,AMI_3:11
          .= Exec(IncAddr(INS,j), s).d by A13,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
      end;
    end;
    hence thesis by A2,AMI_5:26,A1;
  end;
  suppose InsCode INS = 5;
    then consider da,db being Data-Location such that
A16: INS = Divide(da, db) by AMI_5:51;
     now
      let d be Data-Location;
      per cases;
      suppose
A17:    da <> db;
        hereby
          per cases;
          suppose
A18:        da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A16,COMPOS_1:92
          .= IncIC(s,k).da div IncIC(s,k).db by A17,A18,A16,AMI_3:12
          .= s.da div IncIC(s,k).db by AMI_5:80
          .= s.da div s.db by AMI_5:80
          .= Exec(INS, s).d by A16,A17,A18,AMI_3:12
          .= Exec(IncAddr(INS,j), s).d by A16,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
          end;
          suppose
A19:        db = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A16,COMPOS_1:92
          .= IncIC(s,k).da mod IncIC(s,k).db by A19,A16,AMI_3:12
          .= s.da mod IncIC(s,k).db by AMI_5:80
          .= s.da mod s.db by AMI_5:80
          .= Exec(INS, s).d by A16,A19,AMI_3:12
          .= Exec(IncAddr(INS,j), s).d by A16,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
          end;
          suppose
A20:        da <> d & db <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A16,COMPOS_1:92
          .= IncIC(s,k).d by A16,A20,AMI_3:12
          .= s.d by AMI_5:80
          .= Exec(INS, s).d by A16,A20,AMI_3:12
          .= Exec(IncAddr(INS,j), s).d by A16,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
          end;
        end;
      end;
      suppose
A21:    da = db;
          per cases;
          suppose
A22:        da = d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A16,COMPOS_1:92
          .= IncIC(s,k).da mod IncIC(s,k).db by A21,A22,A16,AMI_3:12
          .= s.da mod IncIC(s,k).db by AMI_5:80
          .= s.da mod s.db by AMI_5:80
          .= Exec(INS, s).d by A16,A21,A22,AMI_3:12
          .= Exec(IncAddr(INS,j), s).d by A16,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
          end;
       suppose
A23:        da <> d;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = Exec(INS,IncIC(s,k)).d by A16,COMPOS_1:92
          .= IncIC(s,k).d by A16,A21,A23,AMI_3:12
          .= s.d by AMI_5:80
          .= Exec(INS, s).d by A16,A21,A23,AMI_3:12
          .= Exec(IncAddr(INS,j), s).d by A16,COMPOS_1:92
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
        end;
      end;
    end;
    hence thesis by A2,AMI_5:26,A1;
  end;
  suppose InsCode INS = 6;
    then consider loc being Element of NAT such that
A24: INS = SCM-goto loc by AMI_5:52;
A25: IncAddr(INS, j+k) = SCM-goto (loc + (j+k)) by A24,Th1;
A26: IncAddr(INS, j) = SCM-goto (loc + j) by A24,Th1;
    now let d be Data-Location;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = IncIC(s,k).d by A25,AMI_3:13
          .= s.d by AMI_5:80
          .= Exec(IncAddr(INS,j), s).d by A26,AMI_3:13
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
    end;
    hence thesis by A2,AMI_5:26,A1;
  end;
  suppose InsCode INS = 7;
    then consider loc being Element of NAT, da being Data-Location such that
A27: INS = da=0_goto loc by AMI_5:53;
A28: IncAddr(INS, j+k) = da=0_goto (loc + (j+k)) by A27,Th2;
A29: IncAddr(INS, j) = da=0_goto (loc + j) by A27,Th2;
    now let d be Data-Location;
     thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = IncIC(s,k).d by A28,AMI_3:14
          .= s.d by AMI_5:80
          .= Exec(IncAddr(INS,j), s).d by A29,AMI_3:14
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
    end;
   hence thesis by A2,A1,AMI_5:26;
  end;
  suppose InsCode INS = 8;
    then consider loc being Element of NAT, da being Data-Location such that
A30: INS = da>0_goto loc by AMI_5:54;
A31: IncAddr(INS, j+k) = da>0_goto (loc + (j+k)) by A30,Th3;
A32: IncAddr(INS, j) = da>0_goto (loc + j) by A30,Th3;
    now let d be Data-Location;
       thus Exec(IncAddr(INS,j+k),IncIC(s,k)).d
           = IncIC(s,k).d by A31,AMI_3:15
          .= s.d by AMI_5:80
          .= Exec(IncAddr(INS,j), s).d by A32,AMI_3:15
          .= IncIC(Exec(IncAddr(INS,j),s),k).d by AMI_5:80;
     end;
   hence thesis by A2,AMI_5:26,A1;
  end;
 end;
end;

begin :: Main theorems of Relocatability

Lm1: for k being Element of NAT, p being autonomic FinPartState of SCM , s1,
s2 being State of SCM st IC SCM in dom p & p c= s1 & Relocated (p,k) c= s2
for P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
  st ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2
for i being Element of NAT holds
 IC Comput(P1,s1,i) + k = IC Comput(P2,s2,i) &
IncAddr(CurInstr(P1,Comput(P1,s1,i)), k)
 = CurInstr(P2,Comput(P2,s2,i)) &
Comput(P1,s1,i)|dom (DataPart p) = Comput(P2,s2,i)|
dom (DataPart (Relocated(p,k))) &
DataPart Comput(P1,s1 +* DataPart s2,i) =
DataPart Comput(P2,s2,i)
proof
  let k be Element of NAT, p be autonomic FinPartState of SCM, s1,s2 be State
  of SCM such that
A1: IC SCM in dom p and
A2: p c= s1 and
A3: Relocated (p,k) c= s2;
  let P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
  such that
A4: ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2;
A5: Reloc(ProgramPart p,k) c= P2 by A4,COMPOS_1:116;
A6: Reloc(ProgramPart p,k) = ProgramPart Relocated(p,k) by COMPOS_1:116;
 Reloc(ProgramPart p,k) c= Relocated (p,k) by RELAT_1:88,A6;
  then
A7: Reloc(ProgramPart p,k) c= s2 by A3,XBOOLE_1:1;
A8: ProgramPart p c= P1 by A4;
  set s3 = s1 +* DataPart s2;
  defpred Z[Element of NAT] means
   IC Comput(P1,s1,$1) + k = IC Comput(P2,s2,$1) &
 IncAddr(CurInstr(P1,Comput(P1,s1,$1)), k)
 = CurInstr(P2,Comput(P2,s2,$1)) &
  Comput(P1,s1,$1)|dom (DataPart p) = Comput(P2,s2,$1
)|dom (DataPart (

Relocated (p,k))) & DataPart Comput(P1,s3,$1) = DataPart Comput(
P2,s2,$1);

A9: p is non NAT-defined by A1,COMPOS_1:19;
A10: p c= s3 by A2,A3,COMPOS_1:161;
  now
    set DPp = DataPart p;
    let i be Element of NAT such that
A11: IC Comput(P1,s1,i) + k = IC Comput(P2,s2,i) and

A12: IncAddr (CurInstr(P1,Comput(P1,s1,i)), k)
 = CurInstr(P2,Comput(P2,s2,i)) and

A13: Comput(P1,s1,i)|dom (DataPart p) = Comput(P2,s2,i
)|dom (
    DataPart (Relocated (p,k))) and
A14: DataPart Comput(P1,s3,i) = DataPart Comput(P2,s2,
i);
    set Cs2i1 = Comput(P2,s2,i+1);
    set Cs3i = Comput(P1,s3,i);
    set Cs2i = Comput(P2,s2,i);
    dom Cs2i1 = the carrier of SCM by PARTFUN1:def 4;
    then
A15: dom Cs2i1 = {IC SCM} \/ Data-Locations SCM \/ NAT by COMPOS_1:160;
    set Cs3i1 = Comput(P1,s3,i+1);
A16: dom DataPart Cs2i = Data-Locations SCM by COMPOS_1:50;
A17: dom DataPart Cs3i1 = Data-Locations SCM by COMPOS_1:50;
A18: dom DataPart Cs2i1 = Data-Locations SCM by COMPOS_1:50;
A19: now
      let x be set;
      assume that
A20:  x in dom DataPart Cs3i1 and
A21:  Cs3i1.x = Cs2i1.x;
      thus (DataPart Cs3i1).x = Cs2i1.x by A20,A21,FUNCT_1:70
        .= (DataPart Cs2i1).x by A17,A18,A20,FUNCT_1:70;
    end;
A22: dom DataPart Cs3i = Data-Locations SCM by COMPOS_1:50;
A23: now
      let x be set;
      assume that
A24:  x in dom DataPart Cs3i1 and
A25:  Cs3i1.x = Cs3i.x & Cs2i1.x = Cs2i.x;
      (DataPart Cs3i).x = Cs3i.x by A22,A17,A24,FUNCT_1:70;

      hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A14,A16,A17,A19,A24,A25,
FUNCT_1:70;

    end;
A26: now
      let s be State of SCM, d be Data-Location;
      d in Data-Locations SCM by AMI_3:72,def 2;
      hence d in dom DataPart s by COMPOS_1:50;
    end;
A27: now
      let d be Data-Location;
A28:  d in dom DataPart Cs3i by A26;
      hence Cs3i.d = (DataPart Cs3i).d by FUNCT_1:70
        .= Cs2i.d by A14,A28,FUNCT_1:70;
    end;
    set Cs1i1 = Comput(P1,s1,i+1);
    set Cs1i = Comput(P1,s1,i);
    dom Cs1i1 = the carrier of SCM by PARTFUN1:def 4;
    then
A29: dom Cs1i1 = {IC SCM} \/ Data-Locations SCM \/ NAT by COMPOS_1:160;
    dom DPp = dom p /\ Data-Locations SCM by RELAT_1:90;
    then
A30: dom DPp c= {IC SCM} \/ Data-Locations SCM by XBOOLE_1:10,17;
A31: dom (Cs1i1|dom DPp) = dom Cs1i1 /\ dom DPp by RELAT_1:90
      .= dom DPp by A29,A30,XBOOLE_1:10,28;
A32: now
      reconsider loc = IC Cs1i1 as Element of NAT;
      assume
A33:  IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,i+1);
      reconsider kk = loc as Element of NAT;
A34:  loc in dom ProgramPart p by A2,A9,AMISTD_5:def 4,A8;
A35:  loc + k in dom Reloc(ProgramPart p, k) by A34,COMPOS_1:158;
A36:   dom P2 = NAT by PARTFUN1:def 4;
      dom P1 = NAT by PARTFUN1:def 4;
      then CurInstr(P1, Cs1i1) = P1.loc by PARTFUN1:def 8
        .= (ProgramPart p).loc by A34,GRFUNC_1:8,A4
        .= (ProgramPart p).loc;
      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = Reloc(ProgramPart p,k).(loc+k) by A34,COMPOS_1:122
      .= P2.IC Comput(P2,s2,i+1) by A33,A35,A5,GRFUNC_1:8
      .= CurInstr(P2,Comput(P2,s2,i+1)) by A36,PARTFUN1:def 8;

    end;
    set I = CurInstr(P1, Cs1i);
A37: Cs2i1 = Following(P2,Cs2i) by EXTPRO_1:4
      .= Exec (CurInstr(P2, Cs2i), Cs2i);
    dom Cs2i = the carrier of SCM by PARTFUN1:def 4;
    then
A38: dom Cs2i = {IC SCM} \/ Data-Locations SCM \/ NAT by COMPOS_1:160;
    dom Cs1i = the carrier of SCM by PARTFUN1:def 4;
    then
A39: dom Cs1i = {IC SCM} \/ Data-Locations SCM \/ NAT by COMPOS_1:160;
A40: dom (Cs1i|dom DPp) = dom Cs1i /\ dom DPp by RELAT_1:90
      .= dom DPp by A39,A30,XBOOLE_1:10,28;
A41: Cs3i1 = Following(P1,Cs3i) by EXTPRO_1:4
      .= Exec (CurInstr(P1, Cs1i), Cs3i)
      by A2,A9,A10,AMISTD_5:7,A4;
A42: dom DataPart p = dom DataPart(Relocated (p, k)) by COMPOS_1:115;

    then
A43: dom (Cs2i1|dom DataPart(Relocated(p, k))) = dom Cs2i1 /\ dom DPp by
RELAT_1:90

      .= dom DPp by A15,A30,XBOOLE_1:10,28;
A44: now
      let x be set, d be Data-Location such that
A45:  d = x & d in dom DPp and
A46:  Cs1i1.d = Cs2i1.d;
      thus (Cs1i1|dom DPp).x = Cs2i1.d by A31,A45,A46,FUNCT_1:70
        .= (Cs2i1|dom DPp).x by A42,A43,A45,FUNCT_1:70;
    end;

A47: dom (Cs2i|dom DataPart(Relocated(p, k))) = dom Cs2i /\ dom DPp by A42,
RELAT_1:90

      .= dom DPp by A38,A30,XBOOLE_1:10,28;
A48: now
      let x be set, d be Data-Location such that
A49:  d = x and
A50:  d in dom DPp and
A51:  Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d;

      (Cs1i|dom DPp).d = Cs1i.d & (Cs2i|dom DPp).d = Cs2i.d by A42,A40,A47,A50,
FUNCT_1:70;

      hence (Cs1i1|dom DPp).x = Cs2i1.d by A13,A42,A31,A49,A50,A51,FUNCT_1:70

        .= (Cs2i1|dom DPp).x by A42,A43,A49,A50,FUNCT_1:70;
    end;
    reconsider j = IC Cs1i as Element of NAT;
A52: Cs1i1 = Following(P1,Cs1i) by EXTPRO_1:4
      .= Exec (CurInstr(P1, Cs1i), Cs1i);
A53: succ (IC Cs1i +k) = (j+k+1) by NAT_1:39
      .= (j+1) + k
      .= ((succ IC Cs1i) qua Element of NAT) + k by NAT_1:39;
    per cases by AMI_5:36,NAT_1:33;
    suppose
      InsCode I = 0;
      then
A54:  I = halt SCM by AMI_5:46;

      thus IC Comput(P1,s1,i+1) + k = IC Cs1i + k by A52,A54,
EXTPRO_1:def 3

        .= IC Comput(P2,s2,i+1)
         by A11,A37,A54,A12,EXTPRO_1:def 3;

      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1)) by A32;

A55:  Cs2i1 = Cs2i by A37,A54,A12,EXTPRO_1:def 3;

      hence Comput(P1,s1,i+1)|dom (DataPart p) = Comput(
P2,s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A13,A52,A54,EXTPRO_1:def 3;

      thus DataPart Cs3i1 = DataPart Cs2i1 by A14,A41,A54,A55,EXTPRO_1:def 3;
    end;
    suppose
      InsCode I = 1;
      then consider da, db being Data-Location such that
A56:  I = da := db by AMI_5:47;
A57:  IncAddr(I, k) = da := db by A56,COMPOS_1:92;
A58:  Exec(I, Cs1i).IC SCM = succ IC Cs1i by A56,AMI_3:8;

      hence
      IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,i+1)
by A11,A12,A52,A37,A53,A57,AMI_3:8;

      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1))
        by A11,A12,A32,A52,A37,A53,A57,A58,AMI_3:8;

A59:  Cs3i.db = Cs2i.db by A27;
      now
        DPp c= p by RELAT_1:88;
        then
A60:    dom DPp c= dom p by GRFUNC_1:8;
        let x be set;
        assume
A61:    x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM by RELAT_1:87;
        then x in Data-Locations SCM by A31,A61;
        then reconsider d = x as Data-Location by AMI_3:72,def 2;
        per cases;
        suppose
A62:      da = d;
          then Cs1i1.d = Cs1i.db & Cs2i1.d = Cs2i.db by A12,A52,A37,A56,A57,
AMI_3:8;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A9,A10,A31,A44,A56
,A59,A61,A60,A62,AMI_5:88,A4;
        end;
        suppose
          da <> d;
          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A52,A37,A56,A57,
AMI_3:8;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A31,A48,A61;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A42,A31,A43,GRFUNC_1:8;

      hence Comput(P1,s1,i+1)|dom (DataPart p) = Comput(
P2,s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A42,A31,A43,GRFUNC_1:9;

      now
        let x be set;
        assume
A63:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location by A17,AMI_3:72,def 2;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = Cs2i.db & Cs3i1.d=Cs3i.db by A12,A37,A41,A56,A57,
AMI_3:8;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A27,A19,A63;
        end;
        suppose
          da <> d;

          then
          Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A37,A41,A56,A57,AMI_3:8;

          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A23,A63;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A17,A18,GRFUNC_1:8;
      hence DataPart Cs3i1 = DataPart Comput(P2,s2,i+1)
          by A17,A18,GRFUNC_1:9;
    end;
    suppose
      InsCode I = 2;
      then consider da, db being Data-Location such that
A64:  I = AddTo(da, db) by AMI_5:48;
A65:  IncAddr(I, k) = AddTo(da, db) by A64,COMPOS_1:92;
A66:  Exec(I, Cs1i).IC SCM = succ IC Cs1i by A64,AMI_3:9;

      hence
      IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,i+1)
by A11,A12,A52,A37,A53,A65,AMI_3:9;

      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1))
        by A11,A12,A32,A52,A37,A53,A65,A66,AMI_3:9;

A67:  Cs3i.da = Cs2i.da & Cs3i.db = Cs2i.db by A27;
      now
        DPp c= p by RELAT_1:88;
        then
A68:    dom DPp c= dom p by GRFUNC_1:8;
        let x be set such that
A69:    x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM by RELAT_1:87;
        then x in Data-Locations SCM by A31,A69;
        then reconsider d = x as Data-Location by AMI_3:72,def 2;
        per cases;
        suppose
A70:      da = d;
          then Cs1i1.d = Cs1i.da + Cs1i.db & Cs2i1.d = Cs2i.da + Cs2i.db by A12
,A52,A37,A64,A65,AMI_3:9;

          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A9,A10,A31,A44,A64,A67,
A69
,A68,A70,AMI_5:89,A4;

        end;
        suppose
          da <> d;
          then Cs1i1.d=Cs1i.d & Cs2i1.d = Cs2i.d by A12,A52,A37,A64,A65
,AMI_3:9;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A31,A48,A69;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A42,A31,A43,GRFUNC_1:8;
      hence Comput(P1,s1,i+1)|dom (DataPart p) = Comput(
P2,s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A42,A31,A43,GRFUNC_1:9;
      now
        let x be set;
        assume
A71:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location by A17,AMI_3:72,def 2;
        per cases;
        suppose
          da = d;
          then Cs2i1.d = Cs2i.da + Cs2i.db & Cs3i1.d = Cs3i.da + Cs3i.db by A12
,A37,A41,A64,A65,AMI_3:9;

          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A19,A67,A71;
        end;
        suppose
          da <> d;

          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A37,A41,A64,A65,
AMI_3:9;

          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A23,A71;
        end;
      end;

      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A17,A18
,GRFUNC_1:8
;

      hence DataPart Cs3i1 = DataPart Comput(P2,s2,i+1) by A17,A18
,GRFUNC_1:9
;

    end;
    suppose
      InsCode I = 3;
      then consider da, db being Data-Location such that
A72:  I = SubFrom(da, db) by AMI_5:49;
A73:  IncAddr(I, k) = SubFrom(da, db) by A72,COMPOS_1:92;
A74:  Exec(I, Cs1i).IC SCM = succ IC Cs1i by A72,AMI_3:10;

      hence
      IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,i+1)
by A11,A12,A52,A37,A53,A73,AMI_3:10;

      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1))
        by A11,A12,A32,A52,A37,A53,A73,A74,AMI_3:10;

A75:  Cs3i.da = Cs2i.da & Cs3i.db = Cs2i.db by A27;
      now
        DPp c= p by RELAT_1:88;
        then
A76:    dom DPp c= dom p by GRFUNC_1:8;
        let x be set such that
A77:    x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM by RELAT_1:87;
        then x in Data-Locations SCM by A31,A77;
        then reconsider d = x as Data-Location by AMI_3:72,def 2;
        per cases;
        suppose
A78:      da = d;

          then Cs1i1.d = Cs1i.da - Cs1i.db & Cs2i1.d = Cs2i.da - Cs2i.db by A12
,A52,A37,A72,A73,AMI_3:10;

          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A9,A10,A31,A44,A72,A75,
A77
,A76,A78,AMI_5:90,A4;

        end;
        suppose
          da <> d;

          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A52,A37,A72,A73,
AMI_3:10;

          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A31,A48,A77;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A42,A31,A43,GRFUNC_1:8;

      hence Comput(P1,s1,i+1)|dom (DataPart p) = Comput(
P2,s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A42,A31,A43,GRFUNC_1:9;

      now
        let x be set;
        assume
A79:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location by A17,AMI_3:72,def 2;
        per cases;
        suppose
          da = d;

          then Cs2i1.d = Cs2i.da - Cs2i.db & Cs3i1.d = Cs3i.da - Cs3i.db by A12
,A37,A41,A72,A73,AMI_3:10;

          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A19,A75,A79;
        end;
        suppose
          da <> d;

          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A37,A41,A72,A73,
AMI_3:10;

          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A23,A79;
        end;
      end;

      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A17,A18
,GRFUNC_1:8
;

      hence DataPart Cs3i1 = DataPart Comput(P2,s2,i+1) by A17,A18
,GRFUNC_1:9
;

    end;
    suppose
      InsCode I = 4;
      then consider da, db being Data-Location such that
A80:  I = MultBy(da, db) by AMI_5:50;
A81:  IncAddr(I, k) = MultBy(da, db) by A80,COMPOS_1:92;
A82:  Exec(I, Cs1i).IC SCM = succ IC Cs1i by A80,AMI_3:11;

      hence
      IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,i+1)
by A11,A12,A52,A37,A53,A81,AMI_3:11;

      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1))
        by A11,A12,A32,A52,A37,A53,A81,A82,AMI_3:11;

A83:  Cs3i.da = Cs2i.da & Cs3i.db = Cs2i.db by A27;
      now
        DPp c= p by RELAT_1:88;
        then
A84:    dom DPp c= dom p by GRFUNC_1:8;
        let x be set such that
A85:    x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM by RELAT_1:87;
        then x in Data-Locations SCM by A31,A85;
        then reconsider d = x as Data-Location by AMI_3:72,def 2;
        per cases;
        suppose
A86:      da = d;

          then Cs1i1.d = Cs1i.da * Cs1i.db & Cs2i1.d = Cs2i.da * Cs2i.db by A12
,A52,A37,A80,A81,AMI_3:11;

          hence
          (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A9,A10,A31,A44,A80,A83,
A85
,A84,A86,AMI_5:91,A4;
        end;
        suppose
          da <> d;

          then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A52,A37,A80,A81,
AMI_3:11;

          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A31,A48,A85;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A42,A31,A43,GRFUNC_1:8;

      hence Comput(P1,s1,i+1)|dom (DataPart p) = Comput(
P2,s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A42,A31,A43,GRFUNC_1:9;

      now
        let x be set;
        assume
A87:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location by A17,AMI_3:72,def 2;
        per cases;
        suppose
          da = d;

          then Cs2i1.d = Cs2i.da * Cs2i.db & Cs3i1.d = Cs3i.da * Cs3i.db by A12
,A37,A41,A80,A81,AMI_3:11;

          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A19,A83,A87;
        end;
        suppose
          da <> d;

          then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A37,A41,A80,A81,
AMI_3:11;

          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A23,A87;
        end;
      end;

      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A17,A18
,GRFUNC_1:8
;

      hence DataPart Cs3i1 = DataPart Comput(P2,s2,i+1) by A17,A18
,GRFUNC_1:9
;

    end;
    suppose
      InsCode I = 5;
      then consider da, db being Data-Location such that
A88:  I = Divide(da, db) by AMI_5:51;
A89:  IncAddr(I, k) = Divide(da, db) by A88,COMPOS_1:92;
A90:  Cs3i.da = Cs2i.da & Cs3i.db = Cs2i.db by A27;
      now
        per cases;
        suppose
A91:      da <> db;
A92:      Exec(I, Cs1i).IC SCM = succ IC Cs1i by A88,AMI_3:12;

          hence
          IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,
i+1) by A11,A12,A52,A37,A53,A89,AMI_3:12;

        thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)),k)
           = CurInstr(P2,Comput(P2,s2,i+1))
            by A11,A12,A32,A52,A37,A53,A89,A92,AMI_3:12;

          now
            DPp c= p by RELAT_1:88;
            then
A93:        dom DPp c= dom p by GRFUNC_1:8;
            let x be set such that
A94:        x in dom (Cs1i1|dom DPp);
            dom DPp c= Data-Locations SCM by RELAT_1:87;
            then x in Data-Locations SCM by A31,A94;
            then reconsider d = x as Data-Location by AMI_3:72,def 2;
            per cases;
            suppose
A95:          da = d;

              then
A96:          Cs1i1.d = Cs1i.da div Cs1i.db & Cs2i1.d = Cs2i.da div Cs2i
              .db by A12,A52,A37,A88,A89,A91,AMI_3:12;

              Cs3i.da div Cs3i.db = Cs1i.da div Cs1i.db by A2,A9,A10,A31,A88,
A91
,A94,A93,A95,AMI_5:92,A4;

              hence (Cs1i1|dom DPp).x = Cs2i1.d by A90,A94,A96,FUNCT_1:70

                .= (Cs2i1|dom DPp).x by A42,A31,A43,A94,FUNCT_1:70;
            end;
            suppose
A97:          db = d;

              then Cs1i1.d = Cs1i.da mod Cs1i.db & Cs2i1.d = Cs2i.da mod Cs2i
              .db by A12,A52,A37,A88,A89,AMI_3:12;

              hence
              (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A9,A10,A31,A44,A88,
A90
,A94,A93,A97,AMI_5:93,A4;

            end;
            suppose
              da <> d & db <> d;

              then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A52,A37,A88,A89,
AMI_3:12;

              hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A31,A48,A94;
            end;
          end;

          then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A42,A31,A43,GRFUNC_1:8;

          hence Comput(P1,s1,i+1)|dom (DataPart p) = Comput(
P2,s2,i+1)|dom
          (DataPart (Relocated (p,k))) by A42,A31,A43,GRFUNC_1:9;

          now
            let x be set;
            assume
A98:        x in dom DataPart Cs3i1;
            then reconsider d = x as Data-Location by A17,AMI_3:72,def 2;
            per cases;
            suppose
              da = d;

              then Cs2i1.d = Cs2i.da div Cs2i.db & Cs3i1.d = Cs3i.da div Cs3i
              .db by A12,A37,A41,A88,A89,A91,AMI_3:12;

              hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A19,A90,A98;

            end;
            suppose
              db = d;

              then Cs2i1.d = Cs2i.da mod Cs2i.db & Cs3i1.d = Cs3i.da mod Cs3i
              .db by A12,A37,A41,A88,A89,AMI_3:12;

              hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A19,A90,A98;

            end;
            suppose
              da <> d & db <> d;

              then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A37,A41,A88,A89,
AMI_3:12;

              hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A23,A98;
            end;
          end;

          then
          DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A17,A18,
GRFUNC_1:8;

          hence DataPart Cs3i1 = DataPart Comput(P2,s2,i+1) by A17
,A18,GRFUNC_1:9;

        end;
        suppose
A99:      da = db;
A100:      Exec(I, Cs1i).IC SCM = succ IC Cs1i by A88,AMI_3:12;

          hence
          IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,
i+1) by A11,A12,A52,A37,A53,A89,AMI_3:12;

          thus IncAddr(CurInstr(P1,
          Comput(P1,s1,i+1)), k)
           = CurInstr(P2,Comput(P2,s2,i+1))
            by A11,A12,A32,A52,A37,A53,A89,A100,AMI_3:12;

          now
            let x be set such that
A101:        x in dom (Cs1i1|dom DPp);
            dom DPp c= Data-Locations SCM by RELAT_1:87;
            then x in Data-Locations SCM by A31,A101;
            then reconsider d = x as Data-Location by AMI_3:72,def 2;
            per cases;
            suppose
A102:          da = d;

A103:          (Cs1i|dom DPp).d = Cs1i.d & (Cs2i|dom DPp).d = Cs2i.d by A42,A31
,A40,A47,A101,FUNCT_1:70;

A104:         (Cs1i1|dom DPp).d = Cs1i1.d & (Cs2i1|dom DPp).d = Cs2i1.d
              by A42,A31,A43,A101,FUNCT_1:70;

              Cs2i1.d = Cs2i.da mod Cs2i.db by A12,A37,A89,A99,A102,AMI_3:12;

              hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A13,A42,A52,A88,
A99
,A102,A103,A104,AMI_3:12;

            end;
            suppose
              da <> d;

              then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A12,A52,A37,A88,A89
,A99,AMI_3:12;

              hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A31,A48,A101;
            end;
          end;

          then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A42,A31,A43,GRFUNC_1:8;

          hence Comput(P1,s1,i+1)|dom (DataPart p) = Comput(
P2,s2,i+1)|dom
          (DataPart (Relocated (p,k))) by A42,A31,A43,GRFUNC_1:9;

          now
            let x be set;
            assume
A105:       x in dom DataPart Cs3i1;
            then reconsider d = x as Data-Location by A17,AMI_3:72,def 2;
            per cases;
            suppose
              da = d;

              then Cs2i1.d = Cs2i.da mod Cs2i.db & Cs3i1.d = Cs3i.da mod Cs3i
              .db by A12,A37,A41,A88,A89,A99,AMI_3:12;

              hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A19,A90,A105;

            end;
            suppose
              da <> d;

              then Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A12,A37,A41,A88,A89
,A99,AMI_3:12;

              hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A23,A105;
            end;
          end;

          then
          DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A17,A18,
GRFUNC_1:8;

          hence DataPart Cs3i1 = DataPart Comput(P2,s2,i+1) by A17
,A18,GRFUNC_1:9;

        end;
      end;

      hence IC Comput(P1,s1,i+1) + k = IC Comput(P2,
s2,i+1) & IncAddr(
      CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1)) &

Comput(P1,s1,i+1)|dom (DataPart p) = Comput(P2,s2,i+1
)|dom (DataPart (
      Relocated (p,k))) & DataPart Cs3i1 = DataPart Comput(P2,s2,i
+1);

    end;
    suppose
      InsCode I = 6;
      then consider loc being Element of NAT such that
A106: I = SCM-goto loc by AMI_5:52;
A107: CurInstr(P2, Cs2i) = SCM-goto (loc+k) by A12,A106,Th1;
      thus IC Comput(P1,s1,i+1) + k = loc + k by A52,A106,AMI_3:13
        .= IC Comput(P2,s2,i+1) by A37,A107,AMI_3:13;

      hence
      IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       =
       CurInstr(P2,Comput(P2,s2,i+1)) by A32;

      now
        let x be set such that
A108:   x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM by RELAT_1:87;
        then x in Data-Locations SCM by A31,A108;
        then reconsider d = x as Data-Location by AMI_3:72,def 2;

        Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A52,A37,A106,A107,AMI_3:13;

        hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A31,A48,A108;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A42,A31,A43,GRFUNC_1:8;

      hence Comput(P1,s1,i+1)|dom (DataPart p) = Comput(
P2,s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A42,A31,A43,GRFUNC_1:9;

      now
        let x be set;
        assume
A109:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location by A17,AMI_3:72,def 2;

        Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A37,A41,A106,A107,AMI_3:13;

        hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A23,A109;
      end;

      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A17,A18
,GRFUNC_1:8
;

      hence DataPart Cs3i1 = DataPart Comput(P2,s2,i+1) by A17,A18
,GRFUNC_1:9
;

    end;
    suppose
      InsCode I = 7;

      then consider
      loc being Element of NAT, da being Data-Location
      such that

A110: I = da=0_goto loc by AMI_5:53;
A111: now
        per cases;
        case
          Cs1i.da = 0;
          hence IC Comput(P1,s1,i+1) + k = loc + k by A52,A110,
AMI_3:14;
        end;
        case
          Cs1i.da <> 0;

          hence
          IC Comput(P1,s1,i+1) + k = succ (IC Cs2i) by A11,A52,A53
,A110,AMI_3:14;

        end;
      end;
A112: CurInstr(P2, Cs2i) = da=0_goto (loc+k) by A12,A110,Th2;
A113: now
        per cases;
        case
          Cs2i.da = 0;
          hence IC Comput(P2,s2,i+1) = loc + k by A37,A112,
AMI_3:14;
        end;
        case
          Cs2i.da <> 0;

          hence IC Comput(P2,s2,i+1) = succ IC Cs2i by A37,A112,
AMI_3:14;

        end;
      end;
A114: Cs3i.da = Cs2i.da by A27;
A115: now
        per cases;
        suppose
          loc <> succ IC Cs1i;

          hence
          IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,
i+1) by A2,A9,A10,A110,A114,A111,A113,AMI_5:94,A4;

        end;
        suppose
          loc = succ IC Cs1i;

          hence
          IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,
i+1) by A11,A53,A111,A113;

        end;
      end;
      hence IC Comput(P1,s1,i+1) + k = IC Comput(P2,
s2,i+1);

      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1))
        by A32,A115;

      now
        let x be set such that
A116:   x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM by RELAT_1:87;
        then x in Data-Locations SCM by A31,A116;
        then reconsider d = x as Data-Location by AMI_3:72,def 2;

        Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A52,A37,A110,A112,AMI_3:14;

        hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A31,A48,A116;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A42,A31,A43,GRFUNC_1:8;

      hence Comput(P1,s1,i+1)|dom (DataPart p) = Comput(
P2,s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A42,A31,A43,GRFUNC_1:9;

      now
        let x be set;
        assume
A117:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location by A17,AMI_3:72,def 2;

        Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A37,A41,A110,A112,AMI_3:14;

        hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A23,A117;
      end;

      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A17,A18
,GRFUNC_1:8
;

      hence DataPart Cs3i1 = DataPart Comput(P2,s2,i+1) by A17,A18
,GRFUNC_1:9
;

    end;
    suppose
      InsCode I = 8;

      then consider
      loc being Element of NAT, da being Data-Location
      such that

A118: I = da>0_goto loc by AMI_5:54;
A119: now
        per cases;
        case
          Cs1i.da > 0;
          hence IC Comput(P1,s1,i+1) + k = loc + k by A52,A118,
AMI_3:15;
        end;
        case
          Cs1i.da <= 0;

          hence
          IC Comput(P1,s1,i+1) + k = succ (IC Cs2i) by A11,A52,A53
,A118,AMI_3:15;

        end;
      end;
A120: CurInstr(P2, Cs2i) = da>0_goto (loc+k) by A12,A118,Th3;
A121: now
        per cases;
        case
          Cs2i.da > 0;
          hence IC Comput(P2,s2,i+1) = loc + k by A37,A120,
AMI_3:15;
        end;
        case
          Cs2i.da <= 0;

          hence IC Comput(P2,s2,i+1) = succ IC Cs2i by A37,A120,
AMI_3:15;

        end;
      end;
A122: Cs3i.da = Cs2i.da by A27;
A123: now
        per cases;
        suppose
          loc <> succ IC Cs1i;

          hence
          IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,
i+1) by A2,A9,A10,A118,A122,A119,A121,AMI_5:95,A4;

        end;
        suppose
          loc = succ IC Cs1i;

          hence
          IC Comput(P1,s1,i+1) + k = IC Comput(P2,s2,
i+1) by A11,A53,A119,A121;

        end;
      end;
      hence IC Comput(P1,s1,i+1) + k = IC Comput(P2,
s2,i+1);

      thus IncAddr(CurInstr(P1,Comput(P1,s1,i+1)), k)
       = CurInstr(P2,Comput(P2,s2,i+1))
        by A32,A123;

      now
        let x be set such that
A124:   x in dom (Cs1i1|dom DPp);
        dom DPp c= Data-Locations SCM by RELAT_1:87;
        then x in Data-Locations SCM by A31,A124;
        then reconsider d = x as Data-Location by AMI_3:72,def 2;

        Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A52,A37,A118,A120,AMI_3:15;

        hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A31,A48,A124;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A42,A31,A43,GRFUNC_1:8;

      hence Comput(P1,s1,i+1)|dom (DataPart p) = Comput(
P2,s2,i+1)|dom (
      DataPart (Relocated (p,k))) by A42,A31,A43,GRFUNC_1:9;

      now
        let x be set;
        assume
A125:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location by A17,AMI_3:72,def 2;

        Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A37,A41,A118,A120,AMI_3:15;

        hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A23,A125;
      end;

      then DataPart Cs3i1 c= DataPart Comput(P2,s2,i+1) by A17,A18
,GRFUNC_1:8
;

      hence DataPart Cs3i1 = DataPart Comput(P2,s2,i+1) by A17,A18
,GRFUNC_1:9
;

    end;
  end;
  then
A126: for i be Element of NAT st Z[i] holds Z[i+1];
A127: DataPart p c= p by RELAT_1:88;
A128: DataPart (Relocated(p,k)) c= Relocated(p,k) by RELAT_1:88;
A129: DataPart p = DataPart (Relocated (p,k)) by COMPOS_1:115;
A130: IC SCM in dom Relocated(p,k) by COMPOS_1:119;
  now
    thus IC Comput(P1,s1,0) + k = IC s1 + k by EXTPRO_1:3
      .= IC p + k by A1,A2,GRFUNC_1:8
      .= IC Relocated(p,k) by A1,COMPOS_1:120
      .= IC s2 by A3,A130,GRFUNC_1:8
      .= IC Comput(P2,s2,0) by EXTPRO_1:3;
    reconsider loc = IC p as Element of NAT;
A131: IC p = IC s1 by A1,A2,GRFUNC_1:8;
    then IC p = IC Comput(P1,s1,0) by EXTPRO_1:3;
    then
A132: loc in dom ProgramPart p by A2,A9,AMISTD_5:def 4,A8;
A133: (IC p) + k in dom Reloc(ProgramPart p,k) by A132,COMPOS_1:158;
A134: IC SCM in dom Relocated (p, k) by COMPOS_1:119;
A135: (ProgramPart p).IC p = P1.IC s1 by A131,A132,GRFUNC_1:8,A4;
    dom P2 = NAT by PARTFUN1:def 4;
    then
A136:  CurInstr(P2,Comput(P2,s2,0))
      = P2.IC Comput(P2,s2,0) by PARTFUN1:def 8
     .= P2.IC s2 by EXTPRO_1:3
     .= P2.(IC Relocated (p, k)) by A3,A134,GRFUNC_1:8
      .= P2.((IC p) +k) by A1,COMPOS_1:120
      .= (Reloc(ProgramPart p, k)).((IC p) +k) by A133,GRFUNC_1:8,A4,A6;
A137:  dom P1 = NAT by PARTFUN1:def 4;
     CurInstr(P1,Comput(P1,s1,0))
       = CurInstr(P1,s1) by EXTPRO_1:3
      .= P1.IC s1 by A137,PARTFUN1:def 8;
    hence
    IncAddr(CurInstr(P1,Comput(P1,s1,0)), k)
     = CurInstr(P2,Comput(P2,s2,0)) by A132,A135,A136,COMPOS_1:122;

A138: dom DataPart s2 = Data-Locations SCM by COMPOS_1:50;

    thus Comput(P1,s1,0)|dom (DataPart p) = s1 | dom (DataPart p)
by EXTPRO_1:3

      .= DataPart p by A2,A127,GRFUNC_1:64,XBOOLE_1:1
      .= s2 | dom (DataPart p) by A3,A129,A128,GRFUNC_1:64,XBOOLE_1:1
      .= Comput(P2,s2,0)|dom (DataPart (Relocated (p,k))) by A129,
EXTPRO_1:3;
    thus DataPart Comput(P1,s3,0) = DataPart(s1 +* DataPart s2) by
EXTPRO_1:3
      .= DataPart s2 by A138,FUNCT_4:24
      .= DataPart Comput(P2,s2,0) by EXTPRO_1:3;
  end;
  then
A139: Z[0];
  thus for i being Element of NAT holds Z[i] from NAT_1:sch 1(A139,A126);
end;

theorem
  for k being Element of NAT, p being autonomic FinPartState of SCM , s1
  , s2 being State of SCM st IC SCM in dom p & p c= s1 & Relocated (p,k) c= s2
for P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
  st ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2
for i being Element of NAT holds IC Comput(P1,s1,i) + k = IC
Comput(P2,s2,i) by Lm1;

registration
 cluster SCM -> relocable1 relocable2;
 coherence
  proof
   thus SCM is relocable1
   proof
   thus
    for k being Element of NAT, p being autonomic FinPartState of
SCM , s1, s2 being State of SCM st IC SCM in dom p & p c= s1 & Relocated (p,k)
c= s2
  for P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
   st ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2
for i being Element of NAT
 holds IncAddr(CurInstr(P1,Comput(P1,s1,i)), k)
  = CurInstr(P2,Comput(P2,s2,i)) by Lm1;
  end;
  let k be Element of NAT, p be autonomic FinPartState of SCM,
      s1, s2 be State of SCM;
  assume
A1:  IC SCM in dom p & p c= s1 & Relocated(p,k) c= s2;
  let P1,P2 be (the Instructions of SCM)-valued ManySortedSet of NAT such that
A2: ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2;
  thus for i being Element of NAT holds
   Comput(P1,s1,i)|dom DataPart p =
     Comput(P2,s2,i)|dom DataPart Relocated(p,k) by A1,Lm1,A2;
  end;
end;

theorem
  for k being Element of NAT, p being autonomic FinPartState of SCM , s1
  , s2, s3 being State of SCM st IC SCM in dom p & p c= s1 & Relocated (p,k) c=
  s2 & s3 = s1 +* DataPart s2 holds
  for P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
  st ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2
  for i being Element of NAT holds DataPart
  Comput(P1,s3,i) = DataPart Comput(P2,s2,i) by Lm1;
