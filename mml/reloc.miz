:: Relocatability
::  by Yasushi Tanaka
::
:: Received June 16, 1994
:: Copyright (c) 1994 Association of Mizar Users

environ

 vocabularies AMI_1, AMI_3, ARYTM_1, QC_LANG1, AMI_2, AMI_5, RELAT_1,
      FUNCT_1, NAT_1, FINSET_1, FUNCT_4, BOOLE, PARTFUN1, RELOC, ARYTM,
      SCMNORM, FINSEQ_4;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, CARD_3, INT_1, NAT_1,
      RELAT_1, FUNCT_1, FUNCT_2, PARTFUN1, FUNCT_4, FUNCOP_1, FINSET_1,
      NAT_D, STRUCT_0, AMI_1, SCMNORM, AMI_2, AMI_3, AMI_5, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, NAT_1, AMI_5, SCMNORM, PARTFUN1, NAT_D;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FRAENKEL,
      NUMBERS, XREAL_0, INT_1, CARD_3, AMI_1, AMI_3, AMI_5, SCMNORM, FINSEQ_1,
      FUNCT_4, FINSET_1;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, AMI_1, TARSKI, AMI_3, AMI_5, SCMNORM;
 theorems AMI_1, AMI_3, GRFUNC_1, NAT_1, FUNCOP_1, TARSKI, FUNCT_4, FUNCT_1,
      FUNCT_2, BINARITH, ZFMISC_1, AMI_5, RELAT_1, RELSET_1, XBOOLE_0,
      XBOOLE_1, PARTFUN1, FINSET_1, MCART_1, CARD_3, AMI_2, ORDINAL1, VALUED_1,
      SCMNORM, NAT_D;
 schemes NAT_1, CLASSES1;

begin  :: Relocatability

reserve j, k, m for Element of NAT;

definition
  canceled 2;
  let I be Instruction of SCM , k be Element of NAT;
  func IncAddr (I,k) -> Instruction of SCM equals
  :Def3:
  goto (((@I) jump_address )@ +k) if InsCode I = 6,
  ((@I) cond_address) @ =0_goto (((@I) cjump_address)@ +k) if InsCode I = 7,
  ((@I) cond_address) @ >0_goto (((@I) cjump_address)@ +k) if InsCode I = 8
  otherwise I;
  correctness;
end;

canceled 3;

theorem
  for k being Element of NAT holds IncAddr(halt SCM,k) = halt SCM
  by Def3,AMI_5:37;

theorem Th5:
  for k being Element of NAT, a,b being Data-Location
  holds IncAddr(a:=b,k) = a:=b
proof
  let k be Element of NAT, a,b be Data-Location;
  InsCode (a := b) = 1 by MCART_1:7;
  hence IncAddr(a:=b,k) = a:=b by Def3;
end;

theorem Th6:
  for k being Element of NAT, a,b being Data-Location
  holds IncAddr(AddTo(a,b),k) = AddTo(a,b)
proof
  let k be Element of NAT, a,b be Data-Location;
  InsCode (AddTo(a,b)) = 2 by MCART_1:7;
  hence IncAddr(AddTo(a,b),k) = AddTo(a,b) by Def3;
end;

theorem Th7:
  for k being Element of NAT, a,b being Data-Location
  holds IncAddr(SubFrom(a,b),k) = SubFrom(a,b)
proof
  let k be Element of NAT, a,b be Data-Location;
  InsCode (SubFrom(a,b)) = 3 by MCART_1:7;
  hence IncAddr(SubFrom(a,b),k) = SubFrom(a,b) by Def3;
end;

theorem Th8:
  for k being Element of NAT, a,b being Data-Location
  holds IncAddr(MultBy(a,b),k) = MultBy(a,b)
proof
  let k be Element of NAT, a,b be Data-Location;
  InsCode (MultBy(a,b)) = 4 by MCART_1:7;
  hence IncAddr(MultBy(a,b),k) = MultBy(a,b) by Def3;
end;

theorem Th9:
  for k being Element of NAT, a,b being Data-Location
  holds IncAddr(Divide(a,b),k) = Divide(a,b)
proof
  let k be Element of NAT, a,b be Data-Location;
  InsCode (Divide(a,b)) = 5 by MCART_1:7;
  hence IncAddr(Divide(a,b),k) = Divide(a,b) by Def3;
end;

theorem Th10:
  for k being Element of NAT,loc being Instruction-Location of SCM
  holds IncAddr(goto loc,k) = goto (loc + k)
proof
  let k be Element of NAT, loc be Instruction-Location of SCM;
A1: InsCode (goto loc) = 6 by MCART_1:7;
  ((@(goto loc)) jump_address )@ = loc by AMI_5:55;
  hence IncAddr(goto loc,k) = goto (loc + k) by A1,Def3;
end;

theorem Th11:
  for k being Element of NAT,loc being Instruction-Location of SCM,
  a being Data-Location holds IncAddr(a=0_goto loc,k) = a=0_goto (loc + k)
proof
  let k be Element of NAT, loc be Instruction-Location of SCM,
  a be Data-Location;
A1: InsCode (a=0_goto loc) = 7 by MCART_1:7;
A2: ((@(a=0_goto loc)) cond_address)@ = a by AMI_5:56;
  ((@(a=0_goto loc)) cjump_address)@ = loc by AMI_5:56;
  hence IncAddr(a=0_goto loc,k) = a=0_goto (loc + k) by A1,A2,Def3;
end;

theorem Th12:
  for k being Element of NAT,loc being Instruction-Location of SCM,
  a being Data-Location holds IncAddr(a>0_goto loc,k) = a>0_goto (loc + k)
proof
  let k be Element of NAT, loc be Instruction-Location of SCM,
  a be Data-Location;
A1: InsCode (a>0_goto loc) = 8 by MCART_1:7;
A2: ((@(a>0_goto loc)) cond_address)@ = a by AMI_5:57;
  ((@(a>0_goto loc)) cjump_address)@ = loc by AMI_5:57;
  hence IncAddr(a>0_goto loc,k) = a>0_goto (loc + k) by A1,A2,Def3;
end;

theorem Th13:
  for I being Instruction of SCM, k being Element of NAT
  holds InsCode (IncAddr (I, k)) = InsCode I
proof
  let I be Instruction of SCM, k be Element of NAT;
  per cases by AMI_5:36,NAT_1:33;
  suppose InsCode I = 0;
    hence InsCode (IncAddr (I, k)) = InsCode I by Def3;
  end;
  suppose InsCode I = 1;
    hence InsCode (IncAddr (I, k)) = InsCode I by Def3;
  end;
  suppose InsCode I = 2;
    hence InsCode (IncAddr (I, k)) = InsCode I by Def3;
  end;
  suppose InsCode I = 3;
    hence InsCode (IncAddr (I, k)) = InsCode I by Def3;
  end;
  suppose InsCode I = 4;
    hence InsCode (IncAddr (I, k)) = InsCode I by Def3;
  end;
  suppose InsCode I = 5;
    hence InsCode (IncAddr (I, k)) = InsCode I by Def3;
  end;
  suppose
A1: InsCode I = 6;
    then consider loc being Instruction-Location of SCM such that
A2: I = goto loc by AMI_5:52;
    IncAddr (goto loc, k) = goto (loc+k) by Th10;
    hence InsCode (IncAddr (I, k)) = InsCode I by A1,A2,MCART_1:7;
  end;
  suppose
A3: InsCode I = 7;
    then consider loc being Instruction-Location of SCM,
    da being Data-Location such that
A4: I = da=0_goto loc by AMI_5:53;
    IncAddr (da=0_goto loc, k) = da=0_goto (loc+k) by Th11;
    hence InsCode (IncAddr (I, k)) = InsCode I by A3,A4,MCART_1:7;
  end;
  suppose
A5: InsCode I = 8;
    then consider loc being Instruction-Location of SCM,
    da being Data-Location such that
A6: I = da>0_goto loc by AMI_5:54;
    IncAddr (da>0_goto loc, k) = da>0_goto (loc+k) by Th12;
    hence InsCode (IncAddr (I, k)) = InsCode I by A5,A6,MCART_1:7;
  end;
end;

theorem Th14:
  for II, I being Instruction of SCM, k being Element of NAT st
  (InsCode I = 0 or InsCode I = 1 or InsCode I = 2 or InsCode I = 3 or
  InsCode I = 4 or InsCode I = 5) & IncAddr (II, k) = I holds II = I
proof
  let II, I be Instruction of SCM, k be Element of NAT;
  assume
A1: (InsCode I = 0 or InsCode I = 1 or InsCode I = 2 or InsCode I = 3 or
  InsCode I = 4 or InsCode I = 5) & IncAddr (II, k) = I;
  then InsCode II = InsCode I by Th13;
  hence II = I by A1,Def3;
end;

canceled 3;

definition
 canceled;
  let p be finite PartFunc of NAT, the Instructions of SCM,
      k be Element of NAT;
  func IncAddr(p,k) -> finite PartFunc of NAT, the Instructions of SCM means
  :Def5:
  dom it = dom p &
  for m st m in dom p holds it.m = IncAddr(p/.m,k);
  existence
  proof
    defpred P [set,set] means ex m st $1 = m & $2 = IncAddr(p/.m,k);
A1: for e being set st e in dom p ex u being set st P[e,u]
    proof
      let e be set;
      assume
A2:   e in dom p;
      dom p c= NAT by RELSET_1:12;
      then reconsider e as Instruction-Location of SCM by A2,AMI_1:def 4;
      reconsider m=e as Element of NAT by ORDINAL1:def 13;
      take IncAddr(p/.m,k);
      thus thesis;
    end;
    consider f being Function such that
A4: dom f = dom p and
A5: for e being set st e in dom p holds P[e,f.e] from CLASSES1:sch 1(A1);
A6: dom p c= NAT by RELSET_1:12;
Y:  rng f c= the Instructions of SCM
    proof
      let x be set;
      assume x in rng f;
      then consider y being set such that
W1:   y in dom f and
W2:   f.y = x by FUNCT_1:def 5;
      consider m such that y = m and
A9:   f.y = IncAddr(p/.m,k) by A4,A5,W1;
      thus x in the Instructions of SCM by W2,A9;
    end;
    reconsider IT = f as finite PartFunc of NAT, the Instructions of SCM
                            by Y,RELSET_1:11,FINSET_1:29,A4,A6;
    take IT;
    thus dom IT = dom p by A4;
    let m;
    assume m in dom p;
    then consider j such that
A10: m = j and
A11: f.m = IncAddr(p/.j,k) by A5;
    thus IT.m = IncAddr(p/.m ,k) by A10,A11;
  end;
  uniqueness
  proof
    let IT1,IT2 be finite PartFunc of NAT, the Instructions of SCM such that
A12: dom IT1 = dom p and
A13: for m st m in dom p holds IT1.m = IncAddr(p/.m ,k) and
A14: dom IT2 = dom p and
A15: for m st m in dom p holds IT2.m = IncAddr(p/.m ,k);
    for x being set st x in dom p holds IT1.x = IT2.x
    proof
      let x be set;
      assume
A16:  x in dom p;
      dom p c= NAT by RELSET_1:12;
      then reconsider l = x as Instruction-Location of SCM by A16,AMI_1:def 4;
      reconsider m = l as Element of NAT by ORDINAL1:def 13;
      thus IT1.x = IncAddr(p/.m,k) by A13,A16
        .= IT2.x by A15,A16;
    end;
    hence IT1=IT2 by A12,A14,FUNCT_1:9;
  end;
end;

theorem
  for p being finite PartFunc of NAT, the Instructions of SCM,
      k being Element of NAT
  for l being Element of NAT st l in dom p
  holds IncAddr (p,k).l = IncAddr(p/.l,k) by Def5;

theorem Th19:
  for i being Element of NAT,
      p being finite PartFunc of NAT, the Instructions of SCM holds
  Shift(IncAddr(p,i),i) = IncAddr(Shift(p,i),i)
proof
  let i be Element of NAT,
      p be finite PartFunc of NAT, the Instructions of SCM;
A1: dom(IncAddr(Shift(p,i),i)) = dom (Shift(p,i)) by Def5;
  dom(IncAddr(p,i)) = dom p by Def5;
  then
A2: dom(Shift(p,i)) = { m+i:m in dom (IncAddr(p,i)) } by VALUED_1:def 12
    .= dom (Shift(IncAddr(p,i),i)) by VALUED_1:def 12;
  now
    let x be set;
A3: dom (Shift(IncAddr(p,i),i)) c= NAT by RELSET_1:12;
    assume
A4: x in dom (Shift(IncAddr(p,i),i));
    then reconsider x'=x as Element of NAT by A3;
    x in { m+i where m is Element of NAT:m in dom IncAddr(p,i) }
    by A4,VALUED_1:def 12;
    then consider m being Element of NAT such that
A5: x = m+i & m in dom IncAddr(p,i);
A7: il.m in dom p by A5,Def5;
    dom Shift(p,i) = { mm+i where mm is Element of NAT : mm in dom p}
    by VALUED_1:def 12;
    then
A8: x' in dom Shift(p,i) by A5,A7;
A9: p/.m = p.m by A7,PARTFUN1:def 8
      .= Shift(p,i).(m+i) by A7,VALUED_1:def 12
      .= Shift(p,i)/.x' by A5,A8,PARTFUN1:def 8;
    thus (Shift(IncAddr(p,i),i)).x = IncAddr(p,i).m by A5,VALUED_1:def 12
      .= IncAddr(Shift(p,i)/.x',i) by A7,A9,Def5
      .= (IncAddr(Shift(p,i),i)).x by A8,Def5;
  end;
  hence Shift(IncAddr(p,i),i) = IncAddr(Shift(p,i),i) by A1,A2,FUNCT_1:9;
end;

definition
  let p be FinPartState of SCM , k be Element of NAT;
  func Relocated ( p, k ) -> FinPartState of SCM equals
  Start-At ((IC p)+k)+* [IncAddr(Shift(ProgramPart(p),k),k)]+*DataPart p;
  correctness;
end;

canceled;

theorem Th21:
  for p being FinPartState of SCM,k being Element of NAT
  holds DataPart(Relocated(p,k)) = DataPart(p)
proof
  let p be FinPartState of SCM,k be Element of NAT;
A2: DataPart Start-At ((IC p)+k) = {} by AMI_1:138;
  reconsider SA = DataPart Start-At ((IC p)+k) as Function;
  reconsider SC = IncAddr(Shift(ProgramPart p,k),k) as Function;
  reconsider SB = (SC+*DataPart p)|SCM-Data-Loc as Function;
A3: dom IncAddr(Shift(ProgramPart p,k),k) c= NAT by RELSET_1:12;
A4: dom DataPart p c= SCM-Data-Loc by RELAT_1:87,AMI_3:72;
  thus DataPart(Relocated(p,k))
    =DataPart (Start-At ((IC p)+k)+*
       ([IncAddr(Shift(ProgramPart p,k),k)]+*DataPart p))
   by FUNCT_4:15
    .= SA +* SB by FUNCT_4:75,AMI_3:72
    .= DataPart ([IncAddr(Shift(ProgramPart p,k),k)]+*DataPart p)
   by A2,FUNCT_4:21,AMI_3:72
    .= DataPart p by A3,A4,AMI_2:29,FUNCT_4:81,AMI_3:72;
end;

theorem Th22:
  for p being FinPartState of SCM,k being Element of NAT
  holds ProgramPart(Relocated(p,k)) = IncAddr(Shift(ProgramPart p,k),k)
proof
  let p be FinPartState of SCM,k be Element of NAT;
  set X = (Start-At ((IC p)+k)) | NAT;
  consider x being Element of dom X;
  now
    assume dom X <> {};
    then x in dom X;
    then
A1: x in dom (Start-At ((IC p)+k)) /\ NAT by RELAT_1:90;
    then x in NAT by XBOOLE_0:def 3;
    then reconsider x as Instruction-Location of SCM by AMI_1:def 4;
    x in dom (Start-At ((IC p)+k)) by A1,XBOOLE_0:def 3;
    then x in {IC SCM} by FUNCOP_1:19;
    then x = IC SCM by TARSKI:def 1;
    hence contradiction by AMI_1:48;
  end;
  then
A2: (Start-At ((IC p)+k)) | NAT = {} by FUNCT_2:55;
A3: dom IncAddr(Shift(ProgramPart p,k),k) c= NAT by RELSET_1:12;
A4: dom DataPart p c= SCM-Data-Loc by RELAT_1:87,AMI_3:72;
  reconsider SA = (Start-At ((IC p)+k)) | NAT as Function;
  reconsider SC = IncAddr(Shift(ProgramPart p,k),k) as Function;
  reconsider SB = ((SC+*DataPart p))| NAT as Function;
  thus ProgramPart(Relocated(p,k))
  =(Start-At ((IC p)+k)+* (IncAddr(Shift(ProgramPart p,k),k)+*DataPart p))
  | NAT by FUNCT_4:15
    .= SA +* SB by FUNCT_4:75
    .= (IncAddr(Shift(ProgramPart p,k),k)+*DataPart p) | NAT by A2,FUNCT_4:21
    .= IncAddr(Shift(ProgramPart p,k),k) by A3,A4,AMI_2:29,FUNCT_4:81;
end;

theorem Th23:
  for p being FinPartState of SCM holds dom ProgramPart(Relocated(p,k))
  = { j+k:j in dom ProgramPart(p) }
proof
  let p be FinPartState of SCM;
  thus dom ProgramPart(Relocated(p,k))
  = dom IncAddr(Shift(ProgramPart p,k),k) by Th22
    .= dom [Shift(ProgramPart p,k)] by Def5
    .= { j+k:j in dom ProgramPart p } by VALUED_1:def 12;
end;

theorem Th24:
  for p being FinPartState of SCM, k being Element of NAT,
  l being Instruction-Location of SCM
  holds l in dom p iff l+k in dom Relocated(p,k)
proof
  let p be FinPartState of SCM,k be Element of NAT,
  l be Instruction-Location of SCM;
  reconsider m = l as Element of NAT by ORDINAL1:def 13;
A3: dom ProgramPart(Relocated(p,k))
  = { j+k:j in dom ProgramPart(p) } by Th23;
  ProgramPart(Relocated(p,k)) c= Relocated(p,k) by RELAT_1:88;
  then
A4: dom ProgramPart(Relocated(p,k)) c= dom Relocated(p,k) by GRFUNC_1:8;
  hereby
    assume l in dom p;
    then il.m in dom ProgramPart p by AMI_1:106;
    then l + k in dom ProgramPart(Relocated(p,k)) by A3;
    hence l + k in dom Relocated(p,k) by A4;
  end;
  assume l + k in dom Relocated(p,k);
  then l + k in dom ProgramPart(Relocated(p,k)) by AMI_1:106;
  then consider j such that
A5: l + k = j+k and
A6: j in dom ProgramPart p by A3;
  ProgramPart p c= p by RELAT_1:88;
  then dom ProgramPart p c= dom p by GRFUNC_1:8;
  hence l in dom p by A5,A6;
end;

theorem Th25:
  for p being FinPartState of SCM , k being Element of NAT
  holds IC SCM in dom Relocated (p,k)
proof
  let p be FinPartState of SCM, k be Element of NAT;
A1: Relocated (p,k)
  = Start-At ((IC p)+k) +* (IncAddr(Shift(ProgramPart p,k),k)+*DataPart p)
  by FUNCT_4:15;
  dom(Start-At((IC p)+k)) = {IC SCM} by FUNCOP_1:19;
  then IC SCM in dom (Start-At((IC p)+k)) by TARSKI:def 1;
  hence IC SCM in dom Relocated (p,k) by A1,FUNCT_4:13;
end;

theorem Th26:
  for p being FinPartState of SCM, k being Element of NAT
  holds IC Relocated (p,k) = (IC p) + k
proof
  let p be FinPartState of SCM, k be Element of NAT;
A1: Relocated (p,k) = Start-At ((IC p)+k)
  +* (IncAddr(Shift(ProgramPart p,k),k)+*DataPart p) by FUNCT_4:15;
  ProgramPart(Relocated(p,k)) = IncAddr(Shift(ProgramPart p,k),k) by Th22;
  then not IC SCM in dom(IncAddr(Shift(ProgramPart p,k),k)) &
  not IC SCM in dom(DataPart p) by AMI_1:100,101;
  then
A2: not IC SCM in dom(IncAddr(Shift(ProgramPart p,k),k)+*DataPart p)
  by FUNCT_4:13;
  IC SCM in dom Relocated (p,k) by Th25;
  hence IC Relocated (p,k) = Relocated (p,k).IC SCM by AMI_1:def 43
    .= (Start-At ((IC p)+k)).IC SCM by A1,A2,FUNCT_4:12
    .= (IC p) +k by FUNCOP_1:87;
end;

theorem Th27:
  for p being FinPartState of SCM, k being Element of NAT,
  loc being Element of NAT, I being Instruction of SCM
  st loc in dom ProgramPart p & I = p.loc
  holds IncAddr(I, k) = (Relocated (p, k)).(loc + k)
proof
  let p be FinPartState of SCM, k be Element of NAT,
  loc be Element of NAT, I be Instruction of SCM such that
A1: loc in dom ProgramPart p & I = p.loc;
A2: ProgramPart p c= p by RELAT_1:88;
  reconsider i =loc as Element of NAT;
  i+k in { j+k : j in dom ProgramPart(p) } by A1;
  then
A4: loc + k in dom ProgramPart(Relocated(p, k)) by Th23;
A5: loc in dom IncAddr(ProgramPart p,k) by A1,Def5;
A6: I = (ProgramPart p).loc by A1,A2,GRFUNC_1:8;
  ProgramPart (Relocated(p, k)) c= (Relocated(p, k)) by RELAT_1:88;
  then (Relocated(p, k)).(loc+k)
  = (ProgramPart(Relocated(p, k))).(loc+k) by A4,GRFUNC_1:8
    .= (IncAddr(Shift(ProgramPart p,k),k)).(loc+k) by Th22
    .= (Shift(IncAddr(ProgramPart p,k),k)).(loc+k) by Th19
    .= (IncAddr(ProgramPart p,k)).loc by A5,VALUED_1:def 12
    .= IncAddr((ProgramPart p)/.loc,k) by A1,Def5
    .= IncAddr(I,k) by A1,A6,PARTFUN1:def 8;
  hence thesis;
end;

theorem Th28:
  for p being FinPartState of SCM,k being Element of NAT
  holds Start-At (IC p + k) c= Relocated (p,k)
proof
  let p be FinPartState of SCM, k be Element of NAT;
A1: Start-At (IC p + k) = {[IC SCM,IC p + k]} by FUNCT_4:87;
A2: IC SCM in dom (Relocated(p,k)) by Th25;
A3: IC Relocated(p,k) = IC p + k by Th26;
  IC Relocated(p,k) = Relocated(p,k).IC SCM by A2,AMI_1:def 43;
  then
A4: [IC SCM,IC p + k] in Relocated(p,k) by A2,A3,FUNCT_1:def 4;
  thus Start-At (IC p + k) c= Relocated (p,k)
  proof
    let x be set;
    assume x in Start-At (IC p + k);
    hence x in Relocated(p,k) by A1,A4,TARSKI:def 1;
  end;
end;

theorem Th29:
  for s being data-only FinPartState of SCM, p being FinPartState of SCM,
  k being Element of NAT st IC SCM in dom p holds
  Relocated((p +* s), k) = Relocated (p,k) +* s
proof
  let s be data-only FinPartState of SCM, p be FinPartState of SCM,
  k be Element of NAT;
  assume
A1: IC SCM in dom p;
  then
A2: IC SCM in dom p \/ dom s by XBOOLE_0:def 2;
A3: not IC SCM in SCM-Data-Loc
  proof
    assume not thesis;
    then IC SCM is Data-Location by AMI_3:def 2;
    hence contradiction by AMI_5:20;
  end;
A4: dom s c= SCM-Data-Loc by AMI_1:139,AMI_3:72;
  then
A5: not IC SCM in dom s by A3;
  IC SCM in dom (p +* s) by A2,FUNCT_4:def 1;
  then
A6: IC (p +* s) = (p +* s).IC SCM by AMI_1:def 43
    .= p.IC SCM by A2,A5,FUNCT_4:def 1
    .= IC p by A1,AMI_1:def 43;
  dom s misses NAT by A4,AMI_2:29,XBOOLE_1:63;
  then
A7: ProgramPart (p +* s) = ProgramPart p by FUNCT_4:76;
A8: DataPart (p +* s) = DataPart p +* DataPart s by FUNCT_4:75
    .= DataPart p +* s by A4,RELAT_1:97,AMI_3:72;
  thus Relocated((p +* s), k) = Relocated(p,k) +*s by A6,A7,A8,FUNCT_4:15;
end;

theorem Th30:
  for k being Element of NAT, p being autonomic FinPartState of SCM ,
  s1, s2 being State of SCM st p c= s1 & Relocated (p,k) c= s2
  holds p c= s1 +* DataPart s2
proof
  let k be Element of NAT, p be autonomic FinPartState of SCM ,
  s1, s2 be State of SCM such that
A1: p c= s1 & Relocated (p,k) c= s2;
  reconsider s = s1 +* DataPart s2 as State of SCM;
  set s3 = DataPart s2;
A2: dom p c= {IC SCM} \/ SCM-Data-Loc \/ NAT by AMI_1:80,AMI_5:23;
  then
A3: dom p c= dom s by AMI_1:79,AMI_5:23;
  now
    let x be set such that
A4: x in dom p;
    SCM-Data-Loc = dom s2 /\ SCM-Data-Loc by AMI_5:27,XBOOLE_1:28;
    then
A5: dom s3 = SCM-Data-Loc by RELAT_1:90,AMI_3:72;
A6: x in {IC SCM} \/ SCM-Data-Loc or x in
    NAT by A2,A4,XBOOLE_0:def 2;
    per cases by A6,XBOOLE_0:def 2;
    suppose x in {IC SCM};
      then
A7:   x = IC SCM by TARSKI:def 1;
      not IC SCM in SCM-Data-Loc
      proof
        assume not thesis;
        then IC SCM is Data-Location by AMI_3:def 2;
        hence contradiction by AMI_5:20;
      end;
      then s1.x = s.x by A5,A7,FUNCT_4:12;
      hence p.x = s.x by A1,A4,GRFUNC_1:8;
    end;
    suppose
A8:   x in SCM-Data-Loc;
      set DPp = DataPart p;
      x in dom p /\ SCM-Data-Loc by A4,A8,XBOOLE_0:def 3;
      then
A10:  x in dom DPp by RELAT_1:90,AMI_3:72;
      DPp c= p by RELAT_1:88;
      then
A11:  DPp.x = p.x by A10,GRFUNC_1:8;
      DPp = DataPart Relocated (p, k) by Th21;
      then DPp c= Relocated (p, k) by RELAT_1:88;
      then
A12:  DPp c= s2 by A1,XBOOLE_1:1;
      then
A13:  DPp.x = s2.x by A10,GRFUNC_1:8;
A14:  dom DPp c= dom s2 by A12,GRFUNC_1:8;
A15:  s2.x = s3.x by A8,FUNCT_1:72,AMI_3:72;
      x in dom s2 /\ SCM-Data-Loc by A8,A10,A14,XBOOLE_0:def 3;
      then x in dom s3 by RELAT_1:90,AMI_3:72;
      hence p.x = s.x by A11,A13,A15,FUNCT_4:14;
    end;
    suppose
A16:  x in NAT;
      now
        assume x in dom s3;
        then x in dom s2 /\ SCM-Data-Loc by RELAT_1:90,AMI_3:72;
        then x in SCM-Data-Loc by XBOOLE_0:def 3;
        hence contradiction by A16,AMI_2:29,XBOOLE_0:3;
      end;
      then s1.x = s.x by FUNCT_4:12;
      hence p.x = s.x by A1,A4,GRFUNC_1:8;
    end;
  end;
  hence p c= s1 +* DataPart s2 by A3,GRFUNC_1:8;
end;

theorem Th31:
  for s being State of SCM
  holds Exec(IncAddr(CurInstr s,k),s +* Start-At (IC s + k))
  = Following(s) +* Start-At (IC Following(s) + k)
proof
  let s be State of SCM;
  set INS = CurInstr s;
  reconsider m = IC s as Element of NAT by ORDINAL1:def 13;
A3: Next IC (s +* Start-At (IC s + k)) = Next (il.(m + k)) by AMI_1:111
    .= il.((m + k) + 1) by NAT_1:39
    .= il.(m + 1) + k
    .= ((Next IC s) qua Instruction-Location of SCM) + k by NAT_1:39
    .= IC (Exec(INS, s) +*
  Start-At (((Next IC s) qua Instruction-Location of SCM) + k)) by AMI_1:111;
A4: now
    let d be Instruction-Location of SCM;
    thus Exec(INS, s +* Start-At (IC s + k)).d
    = (s +* Start-At (IC s + k)).d by AMI_1:def 13
      .= s.d by AMI_1:112
      .= Exec(INS, s).d by AMI_1:def 13
      .= (Exec(INS, s) +*
    Start-At (((Next IC s) qua Instruction-Location of SCM) + k)).d
    by AMI_1:112;
  end;
  per cases by AMI_5:36,NAT_1:33;
  suppose InsCode (INS) = 0;
    then
A5: INS = halt SCM by AMI_5:46;
    then
A6: Following(s) = s by AMI_1:def 8;
    thus Exec(IncAddr(CurInstr s,k),s +* Start-At (IC s + k))
    = Exec(halt SCM, s +* Start-At (IC s + k )) by A5,Def3,AMI_5:37
      .= Following(s) +* Start-At (IC Following(s) + k) by A6,AMI_1:def 8;
  end;
  suppose InsCode (INS) = 1;
    then consider da,db being Data-Location such that
A7: INS = da := db by AMI_5:47;
A8: IncAddr(INS,k) = INS by A7,Th5;
A9: IC Exec(INS, s) = Next IC s by A7,AMI_3:8;
A10: IC Exec(INS, s +* Start-At (IC s + k)) = IC (Exec(INS, s) +*
    Start-At (((Next IC s) qua Instruction-Location of SCM) + k)) by A3,A7
    ,AMI_3:8;
    now
      let d be Data-Location;
      per cases;
      suppose
A11:    da = d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).db by A7,AMI_3:8
          .= s.db by AMI_5:80
          .= Exec(INS, s).d by A7,A11,AMI_3:8
          .= (Exec(INS, s) +*
        Start-At (((Next IC s) qua Instruction-Location of SCM) + k)).d
        by AMI_5:80;
      end;
      suppose
A12:    da <> d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).d by A7,AMI_3:8
          .= s.d by AMI_5:80
          .= Exec(INS, s).d by A7,A12,AMI_3:8
          .= (Exec(INS, s) +*
        Start-At (((Next IC s) qua Instruction-Location of SCM) + k)).d
        by AMI_5:80;
      end;
    end;
    hence thesis by A4,A8,A9,A10,AMI_5:26;
  end;
  suppose InsCode (INS) = 2;
    then consider da,db being Data-Location such that
A13: INS = AddTo(da, db) by AMI_5:48;
A14: IncAddr(INS, k) = INS by A13,Th6;
A15: IC Exec(INS, s) = Next IC s by A13,AMI_3:9;
A16: IC Exec(INS, s +* Start-At (IC s + k)) = IC (Exec(INS, s) +*
    Start-At (((Next IC s) qua Instruction-Location of SCM) + k)) by A3
    ,A13,AMI_3:9;
    now
      let d be Data-Location;
      per cases;
      suppose
A17:    da = d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).da + (s +* Start-At (IC s + k)).db
        by A13,AMI_3:9
          .= s.da + (s +* Start-At (IC s + k)).db by AMI_5:80
          .= s.da + s.db by AMI_5:80
          .= Exec(INS, s).d by A13,A17,AMI_3:9
          .= (Exec(INS, s) +*
        Start-At (((Next IC s) qua Instruction-Location of SCM) + k)).d
        by AMI_5:80;
      end;
      suppose
A18:    da <> d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).d by A13,AMI_3:9
          .= s.d by AMI_5:80
          .= Exec(INS, s).d by A13,A18,AMI_3:9
          .= (Exec(INS, s) +*
        Start-At (((Next IC s) qua Instruction-Location of SCM) + k)).d
        by AMI_5:80;
      end;
    end;
    hence thesis by A4,A14,A15,A16,AMI_5:26;
  end;
  suppose InsCode (INS) = 3;
    then consider da,db being Data-Location such that
A19: INS = SubFrom(da, db) by AMI_5:49;
A20: IncAddr(INS, k) = INS by A19,Th7;
A21: IC Exec(INS, s) = Next IC s by A19,AMI_3:10;
A22: IC Exec(INS, s +* Start-At (IC s + k)) = IC (Exec(INS, s) +*
    Start-At (((Next IC s) qua Instruction-Location of SCM) + k)) by A3
    ,A19,AMI_3:10;
    now
      let d be Data-Location;
      per cases;
      suppose
A23:    da = d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).da - (s +* Start-At (IC s + k)).db
        by A19,AMI_3:10
          .= s.da - (s +* Start-At (IC s + k)).db by AMI_5:80
          .= s.da - s.db by AMI_5:80
          .= Exec(INS, s).d by A19,A23,AMI_3:10
          .= (Exec(INS, s) +*
        Start-At (((Next IC s) qua Instruction-Location of SCM) + k)).d
        by AMI_5:80;
      end;
      suppose
A24:    da <> d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).d by A19,AMI_3:10
          .= s.d by AMI_5:80
          .= Exec(INS, s).d by A19,A24,AMI_3:10
          .= (Exec(INS, s) +*
        Start-At (((Next IC s) qua Instruction-Location of SCM) + k)).d
        by AMI_5:80;
      end;
    end;
    hence thesis by A4,A20,A21,A22,AMI_5:26;
  end;
  suppose InsCode (INS) = 4;
    then consider da,db being Data-Location such that
A25: INS = MultBy(da, db) by AMI_5:50;
A26: IncAddr(INS, k) = INS by A25,Th8;
A27: IC Exec(INS, s) = Next IC s by A25,AMI_3:11;
A28: IC Exec(INS, s +* Start-At (IC s + k)) = IC (Exec(INS, s) +*
    Start-At (((Next IC s) qua Instruction-Location of SCM) + k)) by A3
    ,A25,AMI_3:11;
    now
      let d be Data-Location;
      per cases;
      suppose
A29:    da = d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).da * (s +* Start-At (IC s + k)).db
        by A25,AMI_3:11
          .= s.da * (s +* Start-At (IC s + k)).db by AMI_5:80
          .= s.da * s.db by AMI_5:80
          .= Exec(INS, s).d by A25,A29,AMI_3:11
          .= (Exec(INS, s) +*
        Start-At (((Next IC s) qua Instruction-Location of SCM) + k)).d
        by AMI_5:80;
      end;
      suppose
A30:    da <> d;
        hence Exec(INS, s +* Start-At (IC s + k)).d
        = (s +* Start-At (IC s + k)).d by A25,AMI_3:11
          .= s.d by AMI_5:80
          .= Exec(INS, s).d by A25,A30,AMI_3:11
          .= (Exec(INS, s) +*
        Start-At (((Next IC s) qua Instruction-Location of SCM) + k)).d
        by AMI_5:80;
      end;
    end;
    hence thesis by A4,A26,A27,A28,AMI_5:26;
  end;
  suppose InsCode (INS) = 5;
    then consider da,db being Data-Location such that
A31: INS = Divide(da, db) by AMI_5:51;
A32: IncAddr(INS,k) = INS by A31,Th9;
A33: IC Exec(INS, s) = Next IC s by A31,AMI_3:12;
A34: IC Exec(INS, s +* Start-At (IC s + k)) = IC (Exec(INS, s) +*
    Start-At (((Next IC s) qua Instruction-Location of SCM) + k))
    by A3,A31,AMI_3:12;
    now
      let d be Data-Location;
      per cases;
      suppose
A35:    da <> db;
        hereby per cases;
          suppose
A36:        da = d;
            hence Exec(INS, s +* Start-At (IC s + k)).d
            = (s +* Start-At (IC s + k)).da div (s +* Start-At (IC s + k)).db
            by A31,A35,AMI_3:12
              .= s.da div (s +* Start-At (IC s + k)).db by AMI_5:80
              .= s.da div s.db by AMI_5:80
              .= Exec(INS, s).d by A31,A35,A36,AMI_3:12
              .= (Exec(INS, s) +*
            Start-At (((Next IC s) qua Instruction-Location of SCM) + k)).d
            by AMI_5:80;
          end;
          suppose
A37:        db = d;
            hence Exec(INS, s +* Start-At (IC s + k)).d
            = (s +* Start-At (IC s + k)).da mod (s +* Start-At (IC s + k)).db
            by A31,AMI_3:12
              .= s.da mod (s +* Start-At (IC s + k)).db by AMI_5:80
              .= s.da mod s.db by AMI_5:80
              .= Exec(INS, s).d by A31,A37,AMI_3:12
              .= (Exec(INS, s) +*
            Start-At (((Next IC s) qua Instruction-Location of SCM) + k)).d
            by AMI_5:80;
          end;
          suppose
A38:        (da <> d) & (db <> d);
            hence Exec(INS, s +* Start-At (IC s + k)).d
            = (s +* Start-At (IC s + k)).d by A31,AMI_3:12
              .= s.d by AMI_5:80
              .= Exec(INS, s).d by A31,A38,AMI_3:12
              .= (Exec(INS, s) +*
            Start-At (((Next IC s) qua Instruction-Location of SCM) + k)).d
            by AMI_5:80;
          end;
        end;
      end;
      suppose
A39:    da = db;
        hereby per cases;
          suppose
A40:        da = d;
            hence Exec(INS, s +* Start-At (IC s + k)).d
            = (s +* Start-At (IC s + k)).da mod (s +* Start-At (IC s + k)).da
            by A31,A39,AMI_3:12
              .= s.da mod (s +* Start-At (IC s + k)).da by AMI_5:80
              .= s.da mod s.da by AMI_5:80
              .= Exec(INS, s).d by A31,A39,A40,AMI_3:12
              .= (Exec(INS, s) +*
            Start-At (((Next IC s) qua Instruction-Location of SCM) + k)).d
            by AMI_5:80;
          end;
          suppose
A41:        da <> d;
            hence Exec(INS, s +* Start-At (IC s + k)).d
            = (s +* Start-At (IC s + k)).d by A31,A39,AMI_3:12
              .= s.d by AMI_5:80
              .= Exec(INS, s).d by A31,A39,A41,AMI_3:12
              .= (Exec(INS, s) +*
            Start-At (((Next IC s) qua Instruction-Location of SCM) + k)).d
            by AMI_5:80;
          end;
        end;
      end;
    end;
    hence thesis by A4,A32,A33,A34,AMI_5:26;
  end;
  suppose InsCode (INS) = 6;
    then consider loc being Instruction-Location of SCM such that
A42: INS = goto loc by AMI_5:52;
A43: IncAddr(INS, k) = goto (loc + k) by A42,Th10;
A44: IC Exec(INS, s) = loc by A42,AMI_3:13;
A45: IC Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
    = loc + k by A43,AMI_3:13
      .= IC (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)) by A44,AMI_1:111;
A46: now
      let d be Data-Location;
      thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
      = (s +* Start-At (IC s + k)).d by A43,AMI_3:13
        .= s.d by AMI_5:80
        .= Exec(INS, s).d by A42,AMI_3:13
        .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_5:80;
    end;
    now
      let d be Instruction-Location of SCM;
      thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
      = (s +* Start-At (IC s + k)).d by AMI_1:def 13
        .= s.d by AMI_1:112
        .= Exec(INS, s).d by AMI_1:def 13
        .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_1:112;
    end;
    hence thesis by A45,A46,AMI_5:26;
  end;
  suppose InsCode (INS) = 7;
    then consider loc being Instruction-Location of SCM,
    da being Data-Location such that
A47: INS = da=0_goto loc by AMI_5:53;
A48: IncAddr(INS, k) = da=0_goto (loc + k) by A47,Th11;
    now per cases;
      suppose
A49:    s.da=0;
        then
A50:    (s +* Start-At(IC s + k)).da=0 by AMI_5:80;
A51:    IC Exec(INS, s) = loc by A47,A49,AMI_3:14;
A52:    IC Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
        = loc + k by A48,A50,AMI_3:14

.= IC (Exec(INS,s) +* Start-At (IC Exec(INS, s) + k)) by A51,AMI_1:111;
A53:    now
          let d be Data-Location;
          thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by A48,AMI_3:14
            .= s.d by AMI_5:80
            .= Exec(INS, s).d by A47,AMI_3:14
            .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_5:80;
        end;
        now
          let d be Instruction-Location of SCM;
          thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by AMI_1:def 13
            .= s.d by AMI_1:112
            .= Exec(INS, s).d by AMI_1:def 13
            .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_1:112;
        end;
        hence Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
        = Exec(INS, s) +* Start-At (IC Exec(INS, s) + k) by A52,A53,AMI_5:26;
      end;
      suppose
A54:    s.da<>0;
        then
A55:    (s +* Start-At(IC s + k)).da<>0 by AMI_5:80;
        IC Exec(INS, s) = Next IC s by A47,A54,AMI_3:14;
        then
A56:    IC Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
        = IC (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)) by A3,A48,A55,
        AMI_3:14;
A57:    now
          let d be Data-Location;
          thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by A48,AMI_3:14
            .= s.d by AMI_5:80
            .= Exec(INS, s).d by A47,AMI_3:14
            .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_5:80;
        end;
        now
          let d be Instruction-Location of SCM;
          thus Exec(IncAddr(INS, k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by AMI_1:def 13
            .= s.d by AMI_1:112
            .= Exec(INS, s).d by AMI_1:def 13
            .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_1:112;
        end;
        hence Exec(IncAddr(INS, k), s +* Start-At (IC s + k))
        = (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k))
        by A56,A57,AMI_5:26;
      end;
    end;
    hence thesis;
  end;
  suppose InsCode (INS) = 8;
    then consider loc being Instruction-Location of SCM,
    da being Data-Location such that
A58: INS = da>0_goto loc by AMI_5:54;
    now per cases;
      suppose
A59:    s.da > 0;
        then
A60:    (s +* Start-At(IC s + k)).da > 0 by AMI_5:80;
A61:    IC Exec(INS, s) = loc by A58,A59,AMI_3:15;
A62:    IC Exec(da>0_goto (loc + k), s +* Start-At (IC s + k))
        = loc + k by A60,AMI_3:15

.= IC (Exec(INS,s) +* Start-At (IC Exec(INS, s) + k)) by A61,AMI_1:111;
A63:    now
          let d be Data-Location;
          thus Exec(da>0_goto (loc + k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by AMI_3:15
            .= s.d by AMI_5:80
            .= Exec(INS, s).d by A58,AMI_3:15
            .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_5:80;
        end;
        now
          let d be Instruction-Location of SCM;
          thus Exec(da>0_goto (loc + k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by AMI_1:def 13
            .= s.d by AMI_1:112
            .= Exec(INS, s).d by AMI_1:def 13
            .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_1:112;
        end;
        hence Exec(da>0_goto (loc + k), s +* Start-At (IC s + k))
        = Exec(INS,s) +* Start-At (IC Exec(INS, s) + k) by A62,A63,AMI_5:26;
      end;
      suppose
A64:    s.da <= 0;
        then
A65:    (s +* Start-At(IC s + k)).da <= 0 by AMI_5:80;
        IC Exec(INS, s) = Next IC s by A58,A64,AMI_3:15;
        then
A66:    IC Exec(da>0_goto (loc + k), s +* Start-At (IC s + k))

= IC (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)) by A3,A65,AMI_3:15;
A67:    now
          let d be Data-Location;
          thus Exec(da>0_goto (loc + k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by AMI_3:15
            .= s.d by AMI_5:80
            .= Exec(INS, s).d by A58,AMI_3:15
            .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_5:80;
        end;
        now
          let d be Instruction-Location of SCM;
          thus Exec(da>0_goto (loc + k), s +* Start-At (IC s + k)).d
          = (s +* Start-At (IC s + k)).d by AMI_1:def 13
            .= s.d by AMI_1:112
            .= Exec(INS, s).d by AMI_1:def 13
            .= (Exec(INS, s) +* Start-At (IC Exec(INS, s) + k)).d by AMI_1:112;
        end;
        hence Exec(da>0_goto (loc + k), s +* Start-At (IC s + k))
        = Exec(INS, s) +* Start-At (IC Exec(INS, s) + k) by A66,A67,AMI_5:26;
      end;
    end;
    hence thesis by A58,Th12;
  end;
end;

theorem Th32:
  for INS being Instruction of SCM, s being State of SCM,
  j, k being Element of NAT st IC s = j+k
  holds Exec(INS, s +* Start-At (IC s -' k))
  = Exec(IncAddr(INS, k), s) +* Start-At (IC Exec(IncAddr(INS,k), s) -' k)
proof
  let INS be Instruction of SCM, s be State of SCM, j, k be Element of NAT;
  assume
A1: IC s = j+k;
  then
A2: Next (IC s -' k) = Next (il.j) by NAT_D:34
    .= il.(j+1) by NAT_1:39
    .= il.(j+1+k) -' k by NAT_D:34
    .= il.(j+k+1) -' k
    .= ((Next IC s) qua Instruction-Location of SCM) -' k by A1,NAT_1:39;
A3: now
    let d be Instruction-Location of SCM;
    thus Exec(INS, s +* Start-At (IC s -' k)).d
    = (s +* Start-At (IC s -' k)).d by AMI_1:def 13
      .= s.d by AMI_1:112
      .= Exec(IncAddr(INS, k), s).d by AMI_1:def 13
      .= (Exec(IncAddr(INS, k), s)
    +* Start-At (IC Exec(IncAddr(INS,k), s) -' k)).d by AMI_1:112;
  end;
  per cases by AMI_5:36,NAT_1:33;
  suppose InsCode (INS) = 0;
    then
A4: INS = halt SCM by AMI_5:46;
A5: IncAddr (halt SCM, k) = halt SCM by Def3,AMI_5:37;
    thus Exec(INS, s +* Start-At (IC s -' k))
    = s +* Start-At (IC s -' k) by A4,AMI_1:def 8
      .= s +* Start-At (IC Exec(IncAddr(INS,k), s) -' k) by A4,A5,AMI_1:def 8
      .= Exec(IncAddr(INS, k), s) +* Start-At (IC Exec(IncAddr(INS,k), s) -' k)
    by A4,A5,AMI_1:def 8;
  end;
  suppose InsCode (INS) = 1;
    then consider da,db being Data-Location such that
A6: INS = da := db by AMI_5:47;
A7: IncAddr(INS, k) = da := db by A6,Th5;
    then
A8: Exec(IncAddr(INS,k), s).IC SCM = Next IC s by AMI_3:8;
A9: IC Exec(INS, s +* Start-At (IC s -' k))
    = Next IC (s +* Start-At (IC s -' k)) by A6,AMI_3:8
      .= IC Exec(IncAddr(INS,k), s) -' k by A2,A8,AMI_1:111

.= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s) -' k))
    by AMI_1:111;
    now
      let d be Data-Location;
      per cases;
      suppose
A10:    da = d;
        hence Exec(INS, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).db by A6,AMI_3:8
          .= s.db by AMI_5:80
          .= Exec(IncAddr(INS,k), s).d by A7,A10,AMI_3:8
          .= (Exec(IncAddr(INS,k), s) +*
        Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
      end;
      suppose
A11:    da <> d;
        hence Exec(INS, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).d by A6,AMI_3:8
          .= s.d by AMI_5:80
          .= Exec(IncAddr(INS, k), s).d by A7,A11,AMI_3:8
          .= (Exec(IncAddr(INS,k), s) +*
        Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
      end;
    end;
    hence thesis by A3,A9,AMI_5:26;
  end;
  suppose InsCode (INS) = 2;
    then consider da,db being Data-Location such that
A12: INS = AddTo(da, db) by AMI_5:48;
A13: IncAddr(INS, k) = AddTo(da, db) by A12,Th6;
    then
A14: Exec(IncAddr(INS,k), s).IC SCM = Next IC s by AMI_3:9;
A15: IC Exec(INS, s +* Start-At (IC s -' k))
    = Next IC (s +* Start-At (IC s -' k)) by A12,AMI_3:9
      .= IC Exec(IncAddr(INS,k), s) -' k by A2,A14,AMI_1:111

.= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s) -' k))
    by AMI_1:111;
    now
      let d be Data-Location;
      per cases;
      suppose
A16:    da = d;
        hence Exec(INS, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).da
        + (s +* Start-At (IC s -' k)).db by A12,AMI_3:9
          .= s.da + (s +* Start-At (IC s -' k)).db by AMI_5:80
          .= s.da + s.db by AMI_5:80
          .= Exec(IncAddr(INS,k), s).d by A13,A16,AMI_3:9
          .= (Exec(IncAddr(INS,k), s) +*
        Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
      end;
      suppose
A17:    da <> d;
        hence Exec(INS, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).d by A12,AMI_3:9
          .= s.d by AMI_5:80
          .= Exec(IncAddr(INS, k), s).d by A13,A17,AMI_3:9
          .= (Exec(IncAddr(INS,k), s) +*
        Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
      end;
    end;
    hence thesis by A3,A15,AMI_5:26;
  end;
  suppose InsCode (INS) = 3;
    then consider da,db being Data-Location such that
A18: INS = SubFrom(da, db) by AMI_5:49;
A19: IncAddr(INS, k) = SubFrom(da, db) by A18,Th7;
    then
A20: Exec(IncAddr(INS,k), s).IC SCM = Next IC s by AMI_3:10;
A21: IC Exec(INS, s +* Start-At (IC s -' k))
    = Next IC (s +* Start-At (IC s -' k)) by A18,AMI_3:10
      .= IC Exec(IncAddr(INS,k), s) -' k by A2,A20,AMI_1:111

.= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s) -' k))
    by AMI_1:111;
    now
      let d be Data-Location;
      per cases;
      suppose
A22:    da = d;
        hence Exec(INS, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).da
        - (s +* Start-At (IC s -' k)).db by A18,AMI_3:10
          .= s.da - (s +* Start-At (IC s -' k)).db by AMI_5:80
          .= s.da - s.db by AMI_5:80
          .= Exec(IncAddr(INS,k), s).d by A19,A22,AMI_3:10
          .= (Exec(IncAddr(INS,k), s) +*
        Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
      end;
      suppose
A23:    da <> d;
        hence Exec(INS, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).d by A18,AMI_3:10
          .= s.d by AMI_5:80
          .= Exec(IncAddr(INS, k), s).d by A19,A23,AMI_3:10
          .= (Exec(IncAddr(INS,k), s) +*
        Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
      end;
    end;
    hence thesis by A3,A21,AMI_5:26;
  end;
  suppose InsCode (INS) = 4;
    then consider da,db being Data-Location such that
A24: INS = MultBy(da, db) by AMI_5:50;
A25: IncAddr(INS, k) = MultBy(da, db) by A24,Th8;
    then
A26: Exec(IncAddr(INS,k), s).IC SCM = Next IC s by AMI_3:11;
A27: IC Exec(INS, s +* Start-At (IC s -' k))
    = Next IC (s +* Start-At (IC s -' k)) by A24,AMI_3:11
      .= IC Exec(IncAddr(INS,k), s) -' k by A2,A26,AMI_1:111

.= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s) -' k))
    by AMI_1:111;
    now
      let d be Data-Location;
      per cases;
      suppose
A28:    da = d;
        hence Exec(INS, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).da
        * (s +* Start-At (IC s -' k)).db by A24,AMI_3:11
          .= s.da * (s +* Start-At (IC s -' k)).db by AMI_5:80
          .= s.da * s.db by AMI_5:80
          .= Exec(IncAddr(INS,k), s).d by A25,A28,AMI_3:11
          .= (Exec(IncAddr(INS,k), s) +*
        Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
      end;
      suppose
A29:    da <> d;
        hence Exec(INS, s +* Start-At (IC s -' k)).d
        = (s +* Start-At (IC s -' k)).d by A24,AMI_3:11
          .= s.d by AMI_5:80
          .= Exec(IncAddr(INS, k), s).d by A25,A29,AMI_3:11
          .= (Exec(IncAddr(INS,k), s) +*
        Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
      end;
    end;
    hence thesis by A3,A27,AMI_5:26;
  end;
  suppose InsCode (INS) = 5;
    then consider da,db being Data-Location such that
A30: INS = Divide(da, db) by AMI_5:51;
A31: IncAddr(INS, k) = Divide(da, db) by A30,Th9;
    now per cases;
      suppose
A32:    da <> db;
A33:    Exec(IncAddr(INS,k), s).IC SCM = Next IC s by A31,AMI_3:12;
A34:    IC Exec(INS, s +* Start-At (IC s -' k))
        = Next IC (s +* Start-At (IC s -' k)) by A30,AMI_3:12
          .= IC Exec(IncAddr(INS,k), s) -' k by A2,A33,AMI_1:111

.= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s) -' k))
        by AMI_1:111;
        now
          let d be Data-Location;
          per cases;
          suppose
A35:        da = d;
            hence Exec(INS, s +* Start-At (IC s -' k)).d
            = (s +* Start-At(IC s -' k)).da div (s +* Start-At(IC s -' k)).db
            by A30,A32,AMI_3:12
              .= s.da div (s +* Start-At (IC s -' k)).db by AMI_5:80
              .= s.da div s.db by AMI_5:80
              .= Exec(IncAddr(INS,k), s).d by A31,A32,A35,AMI_3:12
              .= (Exec(IncAddr(INS,k), s) +*
            Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
          end;
          suppose
A36:        db = d;
            hence Exec(INS, s +* Start-At (IC s -' k)).d
            = (s +* Start-At (IC s -' k)).da mod (s +* Start-At (IC s -' k)).db
            by A30,AMI_3:12
              .= s.da mod (s +* Start-At (IC s -' k)).db by AMI_5:80
              .= s.da mod s.db by AMI_5:80
              .= Exec(IncAddr(INS,k), s).d by A31,A36,AMI_3:12
              .= (Exec(IncAddr(INS,k), s) +*
            Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
          end;
          suppose
A37:        (da <> d) & (db <> d);
            hence Exec(INS, s +* Start-At (IC s -' k)).d
            = (s +* Start-At (IC s -' k)).d by A30,AMI_3:12
              .= s.d by AMI_5:80
              .= Exec(IncAddr(INS,k), s).d by A31,A37,AMI_3:12
              .= (Exec(IncAddr(INS,k), s) +*
            Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
          end;
        end;
        hence Exec(INS, s +* Start-At (IC s -' k))
        = Exec(IncAddr(INS,k), s) +* Start-At(IC Exec(IncAddr(INS,k),s)-'k)
        by A3,A34,AMI_5:26;
      end;
      suppose
A38:    da = db;
A39:    Exec(IncAddr(INS,k), s).IC SCM = Next IC s by A31,AMI_3:12;
A40:    IC Exec(INS, s +* Start-At (IC s -' k))
        = Next IC (s +* Start-At (IC s -' k)) by A30,AMI_3:12
          .= IC Exec(IncAddr(INS,k), s) -' k by A2,A39,AMI_1:111

.= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s) -' k))
        by AMI_1:111;
        now
          let d be Data-Location;
          per cases;
          suppose
A41:        da = d;
            hence Exec(INS, s +* Start-At (IC s -' k)).d
            = (s +* Start-At(IC s -' k)).da mod (s +* Start-At(IC s -' k)).db
            by A30,A38,AMI_3:12
              .= s.da mod (s +* Start-At (IC s -' k)).db by AMI_5:80
              .= s.da mod s.db by AMI_5:80
              .= Exec(IncAddr(INS,k), s).d by A31,A38,A41,AMI_3:12
              .= (Exec(IncAddr(INS,k), s) +*
            Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
          end;
          suppose
A42:        da <> d;
            hence Exec(INS, s +* Start-At (IC s -' k)).d
            = (s +* Start-At (IC s -' k)).d by A30,A38,AMI_3:12
              .= s.d by AMI_5:80
              .= Exec(IncAddr(INS,k), s).d by A31,A38,A42,AMI_3:12
              .= (Exec(IncAddr(INS,k), s) +*
            Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
          end;
        end;
        hence Exec(INS, s +* Start-At (IC s -' k))
        = Exec(IncAddr(INS,k), s) +* Start-At(IC Exec(IncAddr(INS,k),s)-'k)
        by A3,A40,AMI_5:26;
      end;
    end;
    hence thesis;
  end;
  suppose InsCode (INS) = 6;
    then consider loc being Instruction-Location of SCM such that
A43: INS = goto loc by AMI_5:52;
A44: IncAddr(INS, k) = goto (loc + k) by A43,Th10;
    then
A45: IC Exec(IncAddr(INS,k), s)= loc + k by AMI_3:13;
A46: IC Exec(INS, s +* Start-At (IC s -' k)) = loc by A43,AMI_3:13
      .= IC Exec(IncAddr(INS,k), s) -' k by A45,NAT_D:34

.= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s) -' k))
    by AMI_1:111;
    now
      let d be Data-Location;
      thus Exec(INS, s +* Start-At (IC s -' k)).d
      = (s +* Start-At (IC s -' k)).d by A43,AMI_3:13
        .= s.d by AMI_5:80
        .= Exec(IncAddr(INS,k), s).d by A44,AMI_3:13
        .= (Exec(IncAddr(INS,k), s) +*
      Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
    end;
    hence thesis by A3,A46,AMI_5:26;
  end;
  suppose InsCode (INS) = 7;
    then consider loc being Instruction-Location of SCM,
    da being Data-Location such that
A47: INS = da=0_goto loc by AMI_5:53;
A48: IncAddr(INS, k) = da=0_goto (loc + k) by A47,Th11;
A49: now per cases;
      suppose
A50:    s.da = 0;
        then
A51:    (s +* Start-At (IC s -' k)).da = 0 by AMI_5:80;
A52:    IC Exec(IncAddr(INS,k), s)= loc + k by A48,A50,AMI_3:14;
        IC Exec(INS, s +* Start-At (IC s -' k)) = loc by A47,A51,AMI_3:14
          .= IC Exec(IncAddr(INS,k), s) -' k by A52,NAT_D:34

.= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s) -' k))
        by AMI_1:111;
        hence IC Exec(INS, s +* Start-At (IC s -' k))
        = IC(Exec(IncAddr(INS,k),s) +* Start-At(IC Exec(IncAddr(INS,k),s)-'k));
      end;
      suppose
A53:    s.da <> 0;
        then
A54:    (s +* Start-At (IC s -' k)).da <> 0 by AMI_5:80;
A55:    Exec(IncAddr(INS,k), s).IC SCM = Next IC s by A48,A53,AMI_3:14;
        IC Exec(INS, s +* Start-At (IC s -' k))
        = Next IC (s +* Start-At (IC s -' k)) by A47,A54,AMI_3:14
          .= IC Exec(IncAddr(INS,k), s) -' k by A2,A55,AMI_1:111

.= IC(Exec(IncAddr(INS,k),s) +* Start-At(IC Exec(IncAddr(INS,k),s) -' k))
        by AMI_1:111;
        hence IC Exec(INS, s +* Start-At (IC s -' k))
        = IC(Exec(IncAddr(INS,k),s) +* Start-At(IC Exec(IncAddr(INS,k),s)-'k));
      end;
    end;
    now
      let d be Data-Location;
      thus Exec(INS, s +* Start-At (IC s -' k)).d
      = (s +* Start-At (IC s -' k)).d by A47,AMI_3:14
        .= s.d by AMI_5:80
        .= Exec(IncAddr(INS,k), s).d by A48,AMI_3:14
        .= (Exec(IncAddr(INS,k), s) +*
      Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
    end;
    hence thesis by A3,A49,AMI_5:26;
  end;
  suppose InsCode (INS) = 8;
    then consider loc being Instruction-Location of SCM,
    da being Data-Location such that
A56: INS = da>0_goto loc by AMI_5:54;
A57: IncAddr(INS, k) = da>0_goto (loc + k) by A56,Th12;
A58: now per cases;
      suppose
A59:    s.da > 0;
        then
A60:    (s +* Start-At (IC s -' k)).da > 0 by AMI_5:80;
A61:    IC Exec(IncAddr(INS,k), s)= loc + k by A57,A59,AMI_3:15;
        IC Exec(INS, s +* Start-At (IC s -' k)) = loc by A56,A60,AMI_3:15
          .= IC Exec(IncAddr(INS,k), s) -' k by A61,NAT_D:34

.= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s) -' k))
        by AMI_1:111;
        hence IC Exec(INS, s +* Start-At (IC s -' k))

= IC (Exec(IncAddr(INS,k),s) +* Start-At(IC Exec(IncAddr(INS,k),s)-'k));
      end;
      suppose
A62:    s.da <= 0;
        then
A63:    (s +* Start-At (IC s -' k)).da <= 0 by AMI_5:80;
A64:    Exec(IncAddr(INS,k), s).IC SCM = Next IC s by A57,A62,AMI_3:15;
        IC Exec(INS, s +* Start-At (IC s -' k))
        = Next IC (s +* Start-At (IC s -' k)) by A56,A63,AMI_3:15
          .= IC Exec(IncAddr(INS,k), s) -' k by A2,A64,AMI_1:111

.= IC (Exec(IncAddr(INS,k),s) +* Start-At (IC Exec(IncAddr(INS,k),s) -' k))
        by AMI_1:111;
        hence IC Exec(INS, s +* Start-At (IC s -' k))

= IC (Exec(IncAddr(INS,k),s) +* Start-At(IC Exec(IncAddr(INS,k),s)-'k));
      end;
    end;
    now
      let d be Data-Location;
      thus Exec(INS, s +* Start-At (IC s -' k)).d
      = (s +* Start-At (IC s -' k)).d by A56,AMI_3:15
        .= s.d by AMI_5:80
        .= Exec(IncAddr(INS,k), s).d by A57,AMI_3:15
        .= (Exec(IncAddr(INS,k), s) +*
      Start-At (IC Exec(IncAddr(INS,k),s) -' k)).d by AMI_5:80;
    end;
    hence thesis by A3,A58,AMI_5:26;
  end;
end;

begin :: Main theorems of Relocatability

theorem
  for k being Element of NAT
  for p being autonomic FinPartState of SCM st IC SCM in dom p
  for s being State of SCM st p c= s for i being Element of NAT
  holds Computation(s +* Relocated (p,k),i)
  =  Computation(s,i) +* Start-At (IC  Computation(s,i) + k)
  +* ProgramPart (Relocated (p,k))
proof
  let k be Element of NAT;
  let p be autonomic FinPartState of SCM such that
A1: IC SCM in dom p;
  let s be State of SCM such that
A2: p c= s;
  dom DataPart p misses {IC SCM} by AMI_1:100,ZFMISC_1:56;
  then dom DataPart p /\ {IC SCM} = {} by XBOOLE_0:def 7;
  then
A3: dom DataPart p /\ dom (Start-At ((IC p) + k)) = {} by FUNCOP_1:19;
  NAT misses dom DataPart p by AMI_2:29,RELAT_1:87,AMI_3:72,XBOOLE_1:63;
  then dom DataPart p misses dom (ProgramPart (Relocated (p,k))) by RELAT_1:87
  , XBOOLE_1:63;
  then dom DataPart p /\ dom (Start-At ((IC p) + k))
  \/ dom DataPart p /\ dom (ProgramPart (Relocated (p,k))) = {} by A3,
  XBOOLE_0:def 7;
  then dom DataPart p /\ (dom (Start-At ((IC p) + k))
  \/ dom (ProgramPart (Relocated (p,k)))) = {} by XBOOLE_1:23;
  then dom DataPart p /\ dom (Start-At ((IC p) + k)
  +* ProgramPart (Relocated (p,k))) = {} by FUNCT_4:def 1;
  then dom DataPart p misses dom (Start-At ((IC p) + k)
  +* ProgramPart (Relocated (p,k))) by XBOOLE_0:def 7;
  then
A4: (Start-At ((IC p) + k) +* ProgramPart (Relocated (p,k))) +* DataPart p
  = DataPart p +* (Start-At ((IC p) + k) +*
  ProgramPart (Relocated (p,k))) by FUNCT_4:36;
A5: IC p = p.IC SCM by A1,AMI_1:def 43
    .= IC s by A1,A2,GRFUNC_1:8;
  DataPart p c= p by RELAT_1:88;
  then
A6: DataPart p c= s by A2,XBOOLE_1:1;
A7:  Computation(s,0) = s by AMI_1:13;
  defpred P[Element of NAT] means  Computation(s+*Relocated(p,k),$1)
  =  Computation(s,$1)+* Start-At (IC  Computation(s,$1) + k)
  +* ProgramPart (Relocated (p,k));
   Computation(s+*Relocated(p,k),0) = s +* (Start-At ((IC p)+k) +*
  IncAddr(Shift(ProgramPart p,k),k)+*DataPart p) by AMI_1:13
    .= s +* ((Start-At ((IC p) + k) +*
  ProgramPart (Relocated (p,k))) +* DataPart p) by Th22
    .= s +* DataPart p +* (Start-At ((IC p) + k) +*
  ProgramPart (Relocated (p,k))) by A4,FUNCT_4:15
    .= s +* DataPart p +* Start-At ((IC p) + k) +*
  ProgramPart (Relocated (p,k)) by FUNCT_4:15
    .=  Computation(s,0) +* Start-At (IC  Computation(s,0) + k)
  +* ProgramPart (Relocated (p,k)) by A5,A6,A7,FUNCT_4:79;
  then
A8: P[0];
A9: for i being Element of NAT st P[i] holds P[i+1]
  proof
    let i be Element of NAT such that
A10:  Computation(s+*Relocated(p,k),i)
    =  Computation(s,i) +* Start-At (IC  Computation(s,i) + k)
    +* ProgramPart (Relocated (p,k));
A11:  Computation(s,i+1) = Following( Computation(s,i)) by AMI_1:14;
    dom (Start-At (IC  Computation(s,i) + k)) = {IC SCM} by FUNCOP_1:19;
    then
A12: IC SCM in dom (Start-At (IC  Computation(s,i) + k)) by TARSKI: def 1;
    not IC SCM in dom ProgramPart(Relocated (p,k)) by AMI_1:101;
    then
A13: IC ( Computation(s,i) +* Start-At (IC  Computation(s,i) + k)
    +* [ProgramPart (Relocated (p,k))]) = ( Computation(s,i)
    +* Start-At (IC  Computation(s,i) + k)).IC SCM by FUNCT_4:12
      .= (Start-At (IC  Computation(s,i) + k)).IC SCM by A12,FUNCT_4:14
      .= IC  Computation(s,i) + k by FUNCOP_1:87;
    reconsider kk = IC  Computation(s,i) as Element of NAT
     by ORDINAL1:def 13;
    p is not programmed by A1,AMI_1:109;
    then
A14: IC  Computation(s,i) in dom ProgramPart p by A2,AMI_5:86;
    then
A15: IC  Computation(s,i) in dom IncAddr(ProgramPart p,k) by Def5;
A16: ProgramPart(p) c=  Computation(s,i) by A2,AMI_1:99;
A17: (ProgramPart p)/.kk
    = (ProgramPart(p)).IC  Computation(s,i) by A14,PARTFUN1:def 8
      .= ( Computation(s,i)).IC  Computation(s,i) by A14,A16,GRFUNC_1:8;
    reconsider kk = IC  Computation(s,i) as Element of NAT
     by ORDINAL1:def 13;
    ProgramPart p c= p by RELAT_1:88;
    then dom ProgramPart p c= dom p by GRFUNC_1:8;
    then (IC  Computation(s,i) + k) in dom (Relocated (p,k)) by A14,Th24;
    then (IC  Computation(s,i) + k) in dom (ProgramPart (Relocated (p,k)))
    by AMI_1:106;
    then
A18: CurInstr ( Computation(s+*Relocated(p,k),i))
    = (ProgramPart (Relocated (p,k))).(IC  Computation(s,i) + k)
    by A10,A13,FUNCT_4:14
      .= IncAddr(Shift(ProgramPart p,k),k).(IC  Computation(s,i) + k)
    by Th22
      .= Shift(IncAddr(ProgramPart p,k),k).(IC  Computation(s,i) + k)
    by Th19
      .= IncAddr(ProgramPart p,k).kk by A15,VALUED_1:def 12
      .= IncAddr (CurInstr  Computation(s,i),k) by A14,A17,Def5;
A19: Exec(IncAddr(CurInstr  Computation(s,i),k),  Computation(s,i)
    +* Start-At (IC  Computation(s,i) + k)) = Following( Computation(s,i))
    +* Start-At ((IC Following Computation(s,i)) + k) by Th31;
    thus  Computation(s+*Relocated(p,k),i+1)
    = Following( Computation(s+*Relocated(p,k),i)) by AMI_1:14
      .=  Computation(s,i+1) +* Start-At (IC  Computation(s,i+1) + k)
    +* [ProgramPart (Relocated (p,k))] by A10,A11,A18,A19,AMI_5:77
      .=  Computation(s,i+1) +* Start-At (IC  Computation(s,i+1) + k)
    +* ProgramPart (Relocated (p,k));
  end;
  thus for i being Element of NAT holds P[i] from NAT_1:sch 1(A8,A9);
end;

Th34:
  for k being Element of NAT, p being autonomic FinPartState of SCM ,
  s1, s2 being State of SCM
  st IC SCM in dom p & p c= s1 & Relocated (p,k) c= s2
  for i being Element of NAT holds
  IC  Computation(s1,i) + k = IC  Computation(s2,i) &
  IncAddr(CurInstr( Computation(s1,i)), k) = CurInstr( Computation(s2,i)) &
   Computation(s1,i)|dom (DataPart p)
  =  Computation(s2,i)|dom (DataPart (Relocated (p,k))) &
   DataPart Computation(s1 +* DataPart s2,i) =  DataPart Computation(s2,i)
proof
  let k be Element of NAT, p be autonomic FinPartState of SCM,
  s1,s2 be State of SCM such that
A1: IC SCM in dom p and
A2: p c= s1 and
A3: Relocated (p,k) c= s2;
 set s3 = s1 +* DataPart s2;
A5: IC SCM in dom Relocated(p,k) by Th25;
A6: DataPart p = DataPart (Relocated (p,k)) by Th21;
A7: DataPart p c= p by RELAT_1:88;
A8: DataPart (Relocated(p,k)) c= Relocated(p,k) by RELAT_1:88;
A9: p is non programmed by A1,AMI_1:109;
A10: p c= s3 by A2,A3,Th30;
  defpred Z[Element of NAT] means
  IC  Computation(s1,$1) + k = IC  Computation(s2,$1) &
  IncAddr(CurInstr( Computation(s1,$1)), k) = CurInstr( Computation(s2,$1)) &
   Computation(s1,$1)|dom (DataPart p)
  =  Computation(s2,$1)|dom (DataPart (Relocated (p,k))) &
   DataPart Computation(s3,$1) =  DataPart Computation(s2,$1);
  now
    thus IC  Computation(s1,0) + k = IC s1 + k by AMI_1:13
      .= IC p + k by A1,A2,AMI_1:97
      .= IC Relocated(p,k) by Th26
      .= IC s2 by A3,A5,AMI_1:97
      .= IC  Computation(s2,0) by AMI_1:13;
    reconsider loc = IC p as Element of NAT;
A11: IC p = IC s1 by A1,A2,AMI_1:97;
    then IC p = IC  Computation(s1,0) by AMI_1:13;
    then
A12: loc in dom ProgramPart p by A2,A9,AMI_5:86;
    ProgramPart p c= p by RELAT_1:88;
    then
A13: dom ProgramPart p c= dom p by GRFUNC_1:8;
    then
A14: p.IC p = s1.IC s1 by A2,A11,A12,GRFUNC_1:8;
A15: IncAddr(CurInstr( Computation(s1,0)), k)
    = IncAddr(CurInstr(s1), k) by AMI_1:13
      .= IncAddr(s1.IC s1, k);
A16: IC SCM in dom Relocated (p, k) by Th25;
A17: (IC p) + k in dom Relocated(p,k) by A12,A13,Th24;
    CurInstr( Computation(s2,0)) = CurInstr(s2) by AMI_1:13
      .= s2.(IC Relocated (p, k)) by A3,A16,AMI_1:97
      .= s2.((IC p) + k) by Th26
      .= (Relocated(p,k)).((IC p) + k) by A3,A17,GRFUNC_1:8;
    hence IncAddr(CurInstr( Computation(s1,0)), k)
    = CurInstr( Computation(s2,0)) by A12,A14,A15,Th27;
    thus  Computation(s1,0)|dom (DataPart p)
    = s1 | dom (DataPart p) by AMI_1:13
      .= DataPart p by A2,A7,GRFUNC_1:64,XBOOLE_1:1
      .= s2 | dom (DataPart p) by A3,A6,A8,GRFUNC_1:64,XBOOLE_1:1
      .=  Computation(s2,0)|dom (DataPart (Relocated (p,k))) by A6,
    AMI_1:13;
A18: dom DataPart s2 = SCM-Data-Loc by SCMNORM:14,AMI_3:72;
    thus  DataPart Computation(s3,0)
    = DataPart(s1 +* DataPart s2) by AMI_1:13
      .= DataPart s2 by A18,FUNCT_4:24,AMI_3:72
      .=  DataPart Computation(s2,0) by AMI_1:13;
  end;
  then
A19: Z[0];
  now
    let i be Element of NAT such that
A20: IC  Computation(s1,i) + k = IC  Computation(s2,i) and
A21: IncAddr
    (CurInstr( Computation(s1,i)), k) = CurInstr( Computation(s2,i)) and
A22:  Computation(s1,i)|dom (DataPart p)
    =  Computation(s2,i)|dom (DataPart (Relocated (p,k))) and
A23:  DataPart Computation(s3,i) = DataPart Computation(s2,i);
    set Cs1i =  Computation(s1,i);
    set Cs2i =  Computation(s2,i);
    set Cs3i =  Computation(s3,i);
    set Cs1i1 =  Computation(s1,i+1);
    set Cs2i1 =  Computation(s2,i+1);
    set Cs3i1 =  Computation(s3,i+1);
    set DPp = DataPart p;
A24: dom DataPart p = dom DataPart(Relocated (p, k)) by Th21;
A25: dom Cs1i1 = {IC SCM} \/ SCM-Data-Loc \/ NAT
    by AMI_1:79,AMI_5:23;
A26: dom Cs2i1 = {IC SCM} \/ SCM-Data-Loc \/ NAT
    by AMI_1:79,AMI_5:23;
A27: dom Cs1i = {IC SCM} \/ SCM-Data-Loc \/ NAT
    by AMI_1:79,AMI_5:23;
A28: dom Cs2i = {IC SCM} \/ SCM-Data-Loc \/ NAT
    by AMI_1:79,AMI_5:23;
    dom DPp = dom p /\ SCM-Data-Loc by FUNCT_1:68,AMI_3:72;
    then
A29: dom DPp c= {IC SCM} \/ SCM-Data-Loc by XBOOLE_1:10,17;
A30: dom (Cs1i1|dom DPp) = dom Cs1i1 /\ dom DPp by FUNCT_1:68
      .= dom DPp by A25,A29,XBOOLE_1:10,28;
A31: dom (Cs2i1|dom DataPart(Relocated(p, k)))
    = dom Cs2i1 /\ dom DPp by A24,FUNCT_1:68
      .= dom DPp by A26,A29,XBOOLE_1:10,28;
A32: dom (Cs1i|dom DPp) = dom Cs1i /\ dom DPp by FUNCT_1:68
      .= dom DPp by A27,A29,XBOOLE_1:10,28;
A33: dom (Cs2i|dom DataPart(Relocated(p, k)))
    = dom Cs2i /\ dom DPp by A24,FUNCT_1:68
      .= dom DPp by A28,A29,XBOOLE_1:10,28;
A34: dom DataPart Cs3i = SCM-Data-Loc by SCMNORM:14,AMI_3:72;
A35: dom DataPart Cs2i = SCM-Data-Loc by SCMNORM:14,AMI_3:72;
A36: dom DataPart Cs3i1 = SCM-Data-Loc by SCMNORM:14,AMI_3:72;
A37: dom DataPart Cs2i1 = SCM-Data-Loc by SCMNORM:14,AMI_3:72;
A38: now
      let s be State of SCM, d be Data-Location;
      d in SCM-Data-Loc by AMI_3:def 2;
      hence d in dom DataPart s by SCMNORM:14,AMI_3:72;
    end;
A39: now
      let d be Data-Location;
A40:  d in dom DataPart Cs3i & d in dom DataPart Cs3i by A38;
      hence Cs3i.d = (DataPart Cs3i).d by FUNCT_1:70
        .= Cs2i.d by A23,A40,FUNCT_1:70;
    end;
A41: now
      let x be set, d be Data-Location such that
A42:  d = x & d in dom DPp and
A43:  Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d;
      (Cs1i|dom DPp).d = Cs1i.d & (Cs2i|dom DPp).d = Cs2i.d
      by A24,A32,A33,A42,FUNCT_1:70;
      hence (Cs1i1|dom DPp).x = Cs2i1.d by A22,A24,A30,A42,A43,FUNCT_1:70
        .= (Cs2i1|dom DPp).x by A24,A31,A42,FUNCT_1:70;
    end;
A44: now
      let x be set, d be Data-Location such that
A45:  d = x & d in dom DPp and
A46:  Cs1i1.d = Cs2i1.d;
      thus (Cs1i1|dom DPp).x = Cs2i1.d by A30,A45,A46,FUNCT_1:70
        .= (Cs2i1|dom DPp).x by A24,A31,A45,FUNCT_1:70;
    end;
A47: now
      let x be set;
      assume
A48:  x in dom DataPart Cs3i1 & Cs3i1.x = Cs2i1.x;
      hence (DataPart Cs3i1).x = Cs2i1.x by FUNCT_1:70
        .= (DataPart Cs2i1).x by A36,A37,A48,FUNCT_1:70;
    end;
A49: now
      let x be set;
      assume
A50:  x in dom DataPart Cs3i1 & Cs3i1.x = Cs3i.x & Cs2i1.x = Cs2i.x;
      then (DataPart Cs3i).x = Cs3i.x & (DataPart Cs2i).x = Cs2i.x
      by A34,A35,A36,FUNCT_1:70;
      hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A23,A47,A50;
    end;
A51: now
      assume
A52:  IC  Computation(s1,i+1) + k = IC  Computation(s2,i+1);
      reconsider loc = IC Cs1i1 as Instruction-Location of SCM;
      reconsider kk = loc as Element of NAT by ORDINAL1:def 13;
A53:  loc in dom ProgramPart p by A2,A9,AMI_5:86;
      ProgramPart p c= p by RELAT_1:88;
      then
A54:  dom ProgramPart p c= dom p by GRFUNC_1:8;
A55:  CurInstr(Cs1i1) = s1.loc by AMI_1:54
        .= p.loc by A2,A53,A54,GRFUNC_1:8;
      loc + k in dom Relocated(p, k) by A53,A54,Th24;
      then Relocated(p, k).(loc + k) = s2.(loc+k) by A3,GRFUNC_1:8
        .= Cs2i1.(kk + k) by AMI_1:54;
      hence IncAddr(CurInstr( Computation(s1,i+1)), k)
      = CurInstr( Computation(s2,i+1)) by A52,A53,A55,Th27;
    end;
A56: Cs1i1 = Following Cs1i by AMI_1:14
      .= Exec (CurInstr Cs1i, Cs1i);
A57: Cs2i1 = Following Cs2i by AMI_1:14
      .= Exec (CurInstr Cs2i, Cs2i);
A58: Cs3i1 = Following Cs3i by AMI_1:14
      .= Exec (CurInstr Cs1i, Cs3i) by A2,A9,A10,AMI_5:87;
    reconsider j = IC Cs1i as Element of NAT by ORDINAL1:def 13;
A60: Next (IC Cs1i + k) = il.(j+k+1) by NAT_1:39
      .= il.(j+1) + k
      .= ((Next IC Cs1i) qua Instruction-Location of SCM) + k by NAT_1:39;
    set I = CurInstr(Cs1i);
    per cases by AMI_5:36,NAT_1:33;
    suppose InsCode I = 0;
      then
A61:  I = halt SCM by AMI_5:46;
      then
A62:  CurInstr(Cs2i) = halt SCM by A21,Def3,AMI_5:37;
      thus IC  Computation(s1,i+1) + k = IC Cs1i + k by A56,A61,AMI_1:def 8
        .= IC  Computation(s2,i+1) by A20,A57,A62,AMI_1:def 8;
      hence IncAddr(CurInstr( Computation(s1,i+1)), k)
      = CurInstr( Computation(s2,i+1)) by A51;
A63:  Cs2i1 = Cs2i & Cs1i1 = Cs1i by A56,A57,A61,A62,AMI_1:def 8;
      hence  Computation(s1,i+1)|dom (DataPart p)
      =  Computation(s2,i+1)|dom (DataPart (Relocated (p,k))) by A22;
      thus DataPart Cs3i1 = DataPart Cs2i1 by A23,A58,A61,A63,
      AMI_1:def 8;
    end;
    suppose InsCode I = 1;
      then consider da, db being Data-Location such that
A64:  I = da := db by AMI_5:47;
A65:  IncAddr(I, k) = da := db by A64,Th5;
A66:  Exec(I, Cs1i).IC SCM = Next IC Cs1i by A64,AMI_3:8;
A67:  Cs3i.db = Cs2i.db by A39; thus
      IC  Computation(s1,i+1) + k
      = IC  Computation(s2,i+1) by A20,A21,A56,A57,A60,A65,A66,AMI_3:8;
      thus IncAddr(CurInstr( Computation(s1,i+1)), k)
      = CurInstr( Computation(s2,i+1)) by A20,A21,A51,A56,A57,A60,A65,A66,
      AMI_3:8;
      now
        let x be set;
        assume
A68:    x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by RELAT_1:87,AMI_3:72;
        then x in SCM-Data-Loc by A30,A68;
        then reconsider d = x as Data-Location by AMI_3:def 2;
        DPp c= p by RELAT_1:88;
        then
A69:    dom DPp c= dom p by GRFUNC_1:8;
        per cases;
        suppose
A70:      da = d;
          then
A71:      Cs1i1.d = Cs1i.db by A56,A64,AMI_3:8;
          Cs2i1.d = Cs2i.db by A21,A57,A65,A70,AMI_3:8;

hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A9,A10,A30,A44,A64,A67,
          A68,A69,A70,A71,AMI_5:88;
        end;
        suppose da <> d;

then Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A21,A56,A57,A64,A65,AMI_3:8;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A30,A41,A68;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A24,A30,A31,GRFUNC_1:8;
      hence  Computation(s1,i+1)|dom (DataPart p)
      =  Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
      by A24,A30,A31,GRFUNC_1:9;
      now
        let x be set;
        assume
A72:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location by A36,AMI_3:def 2;
        per cases;
        suppose da = d;

then Cs2i1.d = Cs2i.db & Cs3i1.d=Cs3i.db by A21,A57,A58,A64,A65,AMI_3:8;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A39,A47,A72;
        end;
        suppose
A73:      da <> d;
          then
A74:      Cs3i1.d = Cs3i.d by A58,A64,AMI_3:8;
          Cs2i1.d = Cs2i.d by A21,A57,A65,A73,AMI_3:8;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A49,A72,A74;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A36,A37,
      GRFUNC_1:8;
      hence DataPart Cs3i1 =  DataPart Computation(s2,i+1)
      by A36,A37,GRFUNC_1:9;
    end;
    suppose InsCode I = 2;
      then consider da, db being Data-Location such that
A75:  I = AddTo(da, db) by AMI_5:48;
A76:  IncAddr(I, k) = AddTo(da, db) by A75,Th6;
A77:  Exec(I, Cs1i).IC SCM = Next IC Cs1i by A75,AMI_3:9;
A78:  Cs3i.da = Cs2i.da by A39;
A79:  Cs3i.db = Cs2i.db by A39; thus
      IC  Computation(s1,i+1) + k
      = IC  Computation(s2,i+1) by A20,A21,A56,A57,A60,A76,A77,AMI_3:9;
      thus IncAddr(CurInstr( Computation(s1,i+1)), k)
      = CurInstr( Computation(s2,i+1)) by A20,A21,A51,A56,A57,A60,A76,A77,
      AMI_3:9;
      now
        let x be set such that
A80:    x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by RELAT_1:87,AMI_3:72;
        then x in SCM-Data-Loc by A30,A80;
        then reconsider d = x as Data-Location by AMI_3:def 2;
        DPp c= p by RELAT_1:88;
        then
A81:    dom DPp c= dom p by GRFUNC_1:8;
        per cases;
        suppose
A82:      da = d;
          then
A83:      Cs1i1.d = Cs1i.da + Cs1i.db by A56,A75,AMI_3:9;
          Cs2i1.d = Cs2i.da + Cs2i.db by A21,A57,A76,A82,AMI_3:9;

hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A9,A10,A30,A44,A75,A78,
          A79,A80,A81,A82,A83,AMI_5:89;
        end;
        suppose da <> d;

then Cs1i1.d=Cs1i.d & Cs2i1.d = Cs2i.d by A21,A56,A57,A75,A76,AMI_3:9;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A30,A41,A80;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A24,A30,A31,GRFUNC_1:8;
      hence  Computation(s1,i+1)|dom (DataPart p)
      =  Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
      by A24,A30,A31,GRFUNC_1:9;
      now
        let x be set;
        assume
A84:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location by A36,AMI_3:def 2;
        per cases;
        suppose
A85:      da = d;
          then
A86:      Cs2i1.d = Cs2i.da + Cs2i.db by A21,A57,A76,AMI_3:9;
          Cs3i1.d = Cs3i.da + Cs3i.db by A58,A75,A85,AMI_3:9;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x
          by A47,A78,A79,A84,A86;
        end;
        suppose
A87:      da <> d;
          then
A88:      Cs3i1.d = Cs3i.d by A58,A75,AMI_3:9;
          Cs2i1.d = Cs2i.d by A21,A57,A76,A87,AMI_3:9;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A49,A84,A88;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A36,A37,
      GRFUNC_1:8;
      hence DataPart Cs3i1 =  DataPart Computation(s2,i+1)
      by A36,A37,GRFUNC_1:9;
    end;
    suppose InsCode I = 3;
      then consider da, db being Data-Location such that
A89:  I = SubFrom(da, db) by AMI_5:49;
A90:  IncAddr(I, k) = SubFrom(da, db) by A89,Th7;
A91:  Exec(I, Cs1i).IC SCM = Next IC Cs1i by A89,AMI_3:10;
A92:  Cs3i.da = Cs2i.da by A39;
A93:  Cs3i.db = Cs2i.db by A39; thus
      IC  Computation(s1,i+1) + k
      = IC  Computation(s2,i+1) by A20,A21,A56,A57,A60,A90,A91,AMI_3:10;
      thus IncAddr(CurInstr( Computation(s1,i+1)), k)
      = CurInstr( Computation(s2,i+1)) by A20,A21,A51,A56,A57,A60,A90,A91,
      AMI_3:10;
      now
        let x be set such that
A94:    x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by RELAT_1:87,AMI_3:72;
        then x in SCM-Data-Loc by A30,A94;
        then reconsider d = x as Data-Location by AMI_3:def 2;
        DPp c= p by RELAT_1:88;
        then
A95:    dom DPp c= dom p by GRFUNC_1:8;
        per cases;
        suppose
A96:      da = d;
          then
A97:      Cs1i1.d = Cs1i.da - Cs1i.db by A56,A89,AMI_3:10;
          Cs2i1.d = Cs2i.da - Cs2i.db by A21,A57,A90,A96,AMI_3:10;

hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A9,A10,A30,A44,A89,A92,
          A93,A94,A95,A96,A97,AMI_5:90;
        end;
        suppose da <> d;
          then Cs1i1.d = Cs1i.d &
          Cs2i1.d = Cs2i.d by A21,A56,A57,A89,A90,AMI_3:10;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A30,A41,A94;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A24,A30,A31,GRFUNC_1:8;
      hence  Computation(s1,i+1)|dom (DataPart p)
      =  Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
      by A24,A30,A31,GRFUNC_1:9;
      now
        let x be set;
        assume
A98:    x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location by A36,AMI_3:def 2;
        per cases;
        suppose
A99:      da = d;
          then
A100:     Cs2i1.d = Cs2i.da - Cs2i.db by A21,A57,A90,AMI_3:10;
          Cs3i1.d = Cs3i.da - Cs3i.db by A58,A89,A99,AMI_3:10;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x
          by A47,A92,A93,A98,A100;
        end;
        suppose
A101:     da <> d;
          then
A102:     Cs3i1.d = Cs3i.d by A58,A89,AMI_3:10;
          Cs2i1.d = Cs2i.d by A21,A57,A90,A101,AMI_3:10;

hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A49,A98,A102;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A36,A37,
      GRFUNC_1:8;
      hence DataPart Cs3i1 =  DataPart Computation(s2,i+1)
      by A36,A37,GRFUNC_1:9;
    end;
    suppose InsCode I = 4;
      then consider da, db being Data-Location such that
A103: I = MultBy(da, db) by AMI_5:50;
A104: IncAddr(I, k) = MultBy(da, db) by A103,Th8;
A105: Exec(I, Cs1i).IC SCM = Next IC Cs1i by A103,AMI_3:11;
A106: Cs3i.da = Cs2i.da by A39;
A107: Cs3i.db = Cs2i.db by A39; thus
      IC  Computation(s1,i+1) + k
      = IC  Computation(s2,i+1) by A20,A21,A56,A57,A60,A104,A105,AMI_3:11;
      thus IncAddr(CurInstr( Computation(s1,i+1)), k)
      = CurInstr( Computation(s2,i+1)) by A20,A21,A51,A56,A57,A60,A104,A105
      ,AMI_3:11;
      now
        let x be set such that
A108:   x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by RELAT_1:87,AMI_3:72;
        then x in SCM-Data-Loc by A30,A108;
        then reconsider d = x as Data-Location by AMI_3:def 2;
        DPp c= p by RELAT_1:88;
        then
A109:   dom DPp c= dom p by GRFUNC_1:8;
        per cases;
        suppose
A110:     da = d;
          then
A111:     Cs1i1.d = Cs1i.da * Cs1i.db by A56,A103,AMI_3:11;
          Cs2i1.d = Cs2i.da * Cs2i.db by A21,A57,A104,A110,AMI_3:11;

hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A2,A9,A10,A30,A44,A103,A106,
          A107,A108,A109,A110,A111,AMI_5:91;
        end;
        suppose da <> d;
          then Cs1i1.d = Cs1i.d &
          Cs2i1.d = Cs2i.d by A21,A56,A57,A103,A104,AMI_3:11;
          hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A30,A41,A108;
        end;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A24,A30,A31,GRFUNC_1:8;
      hence  Computation(s1,i+1)|dom (DataPart p)
      =  Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
      by A24,A30,A31,GRFUNC_1:9;
      now
        let x be set;
        assume
A112:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location by A36,AMI_3:def 2;
        per cases;
        suppose
A113:     da = d;
          then
A114:     Cs2i1.d = Cs2i.da * Cs2i.db by A21,A57,A104,AMI_3:11;
          Cs3i1.d = Cs3i.da * Cs3i.db by A58,A103,A113,AMI_3:11;
          hence (DataPart Cs3i1).x = (DataPart Cs2i1).x
          by A47,A106,A107,A112,A114;
        end;
        suppose
A115:     da <> d;
          then
A116:     Cs3i1.d = Cs3i.d by A58,A103,AMI_3:11;
          Cs2i1.d = Cs2i.d by A21,A57,A104,A115,AMI_3:11;

hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A49,A112,A116;
        end;
      end;
      then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A36,A37,
      GRFUNC_1:8;
      hence DataPart Cs3i1 =  DataPart Computation(s2,i+1)
      by A36,A37,GRFUNC_1:9;
    end;
    suppose InsCode I = 5;
      then consider da, db being Data-Location such that
A117: I = Divide(da, db) by AMI_5:51;
A118: IncAddr(I, k) = Divide(da, db) by A117,Th9;
A119: Cs3i.da = Cs2i.da by A39;
A120: Cs3i.db = Cs2i.db by A39;
      now per cases;
        suppose
A121:     da <> db;
A122:     Exec(I, Cs1i).IC SCM = Next IC Cs1i by A117,AMI_3:12;
          hence IC  Computation(s1,i+1) + k
          = IC  Computation(s2,i+1) by A20,A21,A56,A57,A60,A118,AMI_3:12;
          thus IncAddr(CurInstr( Computation(s1,i+1)), k)

= CurInstr( Computation(s2,i+1)) by A20,A21,A51,A56,A57,A60,A118,A122
          ,AMI_3:12;
          now
            let x be set such that
A123:       x in dom (Cs1i1|dom DPp);
            dom DPp c= SCM-Data-Loc by RELAT_1:87,AMI_3:72;
            then x in SCM-Data-Loc by A30,A123;
            then reconsider d = x as Data-Location by AMI_3:def 2;
            DPp c= p by RELAT_1:88;
            then
A124:       dom DPp c= dom p by GRFUNC_1:8;
            per cases;
            suppose
A125:         da = d;
              then
A126:         Cs1i1.d = Cs1i.da div Cs1i.db by A56,A117,A121,AMI_3:12;
A127:         Cs2i1.d = Cs2i.da div Cs2i.db by A21,A57,A118,A121,A125,AMI_3:12;
              Cs3i.da div Cs3i.db = Cs1i.da div Cs1i.db
              by A2,A9,A10,A30,A117,A121,A123,A124,A125,AMI_5:92;
              hence (Cs1i1|dom DPp).x
              = Cs2i1.d by A119,A120,A123,A126,A127,FUNCT_1:70
                .= (Cs2i1|dom DPp).x by A24,A30,A31,A123,FUNCT_1:70;
            end;
            suppose
A128:         db = d;
              then
A129:         Cs1i1.d = Cs1i.da mod Cs1i.db by A56,A117, AMI_3:12;
              Cs2i1.d = Cs2i.da mod Cs2i.db by A21,A57,A118,A128,AMI_3:12;

then Cs1i1.d = Cs2i1.d by A2,A9,A10,A30,A117,A119,A120,A121,A123,A124,A128,
              A129,AMI_5:93;
              hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A30,A44,A123;
            end;
            suppose da <> d & db <> d;
              then Cs1i1.d = Cs1i.d &
              Cs2i1.d = Cs2i.d by A21,A56,A57,A117,A118,AMI_3:12;
              hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A30,A41,A123;
            end;
          end;
          then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A24,A30,A31,GRFUNC_1:8;
          hence  Computation(s1,i+1)|dom (DataPart p)
          =  Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
          by A24,A30,A31,GRFUNC_1:9;
          now
            let x be set;
            assume
A130:       x in dom DataPart Cs3i1;
            then reconsider d = x as Data-Location by A36,AMI_3:def 2;
            per cases;
            suppose
A131:         da = d;
              then
A132:         Cs2i1.d = Cs2i.da div Cs2i.db by A21,A57,A118, A121,AMI_3:12;
              Cs3i1.d = Cs3i.da div Cs3i.db by A58,A117,A121,A131,AMI_3:12;
              hence (DataPart Cs3i1).x = (DataPart Cs2i1).x
              by A47,A119,A120,A130,A132;
            end;
            suppose
A133:         db = d;
              then
A134:         Cs2i1.d = Cs2i.da mod Cs2i.db by A21,A57,A118, AMI_3:12;
              Cs3i1.d = Cs3i.da mod Cs3i.db by A58,A117,A133,AMI_3:12;
              hence (DataPart Cs3i1).x = (DataPart Cs2i1).x
              by A47,A119,A120,A130,A134;
            end;
            suppose
A135:         da <> d & db <> d;
              then
A136:         Cs3i1.d = Cs3i.d by A58,A117,AMI_3:12;
              Cs2i1.d = Cs2i.d by A21,A57,A118,A135,AMI_3:12;

hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A49,A130,A136;
            end;
          end;

then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A36,A37,
          GRFUNC_1:8;
          hence DataPart Cs3i1 =  DataPart Computation(s2,i+1)
          by A36,A37,GRFUNC_1:9;
        end;
        suppose
A137:     da = db;
A138:     Exec(I, Cs1i).IC SCM = Next IC Cs1i by A117,AMI_3:12;
          hence IC  Computation(s1,i+1) + k
          = IC  Computation(s2,i+1) by A20,A21,A56,A57,A60,A118,AMI_3:12;
          thus IncAddr(CurInstr( Computation(s1,i+1)), k)

= CurInstr( Computation(s2,i+1)) by A20,A21,A51,A56,A57,A60,A118,A138
          ,AMI_3:12;
          now
            let x be set such that
A139:       x in dom (Cs1i1|dom DPp);
            dom DPp c= SCM-Data-Loc by RELAT_1:87,AMI_3:72;
            then x in SCM-Data-Loc by A30,A139;
            then reconsider d = x as Data-Location by AMI_3:def 2;
            per cases;
            suppose
A140:         da = d;
              then
A141:         Cs2i1.d = Cs2i.da mod Cs2i.db by A21,A57,A118, A137,AMI_3:12;
A142:         (Cs1i|dom DPp).d = Cs1i.d & (Cs2i|dom DPp).d = Cs2i.d
              by A24,A30,A32,A33,A139,FUNCT_1:70;
              (Cs1i1|dom DPp).d = Cs1i1.d & (Cs2i1|dom DPp).d = Cs2i1.d
              by A24,A30,A31,A139,FUNCT_1:70;
              hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x
              by A22,A24,A56,A117,A137,A140,A141,A142,AMI_3:12;
            end;
            suppose da <> d;
              then Cs1i1.d = Cs1i.d &
              Cs2i1.d = Cs2i.d by A21,A56,A57,A117,A118,A137,AMI_3:12;
              hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A30,A41,A139;
            end;
          end;
          then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A24,A30,A31,GRFUNC_1:8;
          hence  Computation(s1,i+1)|dom (DataPart p)
          =  Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
          by A24,A30,A31,GRFUNC_1:9;
          now
            let x be set;
            assume
A143:       x in dom DataPart Cs3i1;
            then reconsider d = x as Data-Location by A36,AMI_3:def 2;
            per cases;
            suppose
A144:         da = d;
              then
A145:         Cs2i1.d = Cs2i.da mod Cs2i.db by A21,A57,A118, A137,AMI_3:12;
              Cs3i1.d = Cs3i.da mod Cs3i.db by A58,A117,A137,A144,AMI_3:12;
              hence (DataPart Cs3i1).x = (DataPart Cs2i1).x
              by A47,A119,A120,A143,A145;
            end;
            suppose
A146:         da <> d;
              then
A147:         Cs3i1.d = Cs3i.d by A58,A117,A137,AMI_3:12;
              Cs2i1.d = Cs2i.d by A21,A57,A118,A137,A146,AMI_3:12;

hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A49,A143,A147;
            end;
          end;

then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A36,A37,
          GRFUNC_1:8;
          hence DataPart Cs3i1 =  DataPart Computation(s2,i+1)
          by A36,A37,GRFUNC_1:9;
        end;
      end;
      hence IC  Computation(s1,i+1) + k = IC  Computation(s2,i+1) &
      IncAddr(CurInstr( Computation(s1,i+1)), k)
      = CurInstr( Computation(s2,i+1)) &
       Computation(s1,i+1)|dom (DataPart p)
      =  Computation(s2,i+1)|dom (DataPart (Relocated (p,k))) &
      DataPart Cs3i1 =  DataPart Computation(s2,i+1);
    end;
    suppose InsCode I = 6;
      then consider loc being Instruction-Location of SCM such that
A148: I = goto loc by AMI_5:52;
A149: CurInstr(Cs2i) = goto (loc+k) by A21,A148,Th10; thus
      IC  Computation(s1,i+1) + k = loc + k by A56,A148,AMI_3:13
        .= IC  Computation(s2,i+1) by A57,A149,AMI_3:13;
      hence IncAddr(CurInstr( Computation(s1,i+1)), k)
      = CurInstr( Computation(s2,i+1)) by A51;
      now
        let x be set such that
A150:   x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by RELAT_1:87,AMI_3:72;
        then x in SCM-Data-Loc by A30,A150;
        then reconsider d = x as Data-Location by AMI_3:def 2;
        Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A56,A57,A148,A149,AMI_3:13;
        hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A30,A41,A150;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A24,A30,A31,GRFUNC_1:8;
      hence  Computation(s1,i+1)|dom (DataPart p)
      =  Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
      by A24,A30,A31,GRFUNC_1:9;
      now
        let x be set;
        assume
A151:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location by A36,AMI_3:def 2;
        Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A57,A58,A148,A149,AMI_3:13;
        hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A49,A151;
      end;
      then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A36,A37,
      GRFUNC_1:8;
      hence DataPart Cs3i1 =  DataPart Computation(s2,i+1)
      by A36,A37,GRFUNC_1:9;
    end;
    suppose InsCode I = 7;
      then consider loc being Instruction-Location of SCM,
      da being Data-Location such that
A152: I = da=0_goto loc by AMI_5:53;
A153: CurInstr(Cs2i) = da=0_goto (loc+k) by A21,A152,Th11;
A154: Cs3i.da = Cs2i.da by A39;
A155: now per cases;
        case Cs1i.da = 0;
          hence IC  Computation(s1,i+1) + k = loc + k by A56,A152,AMI_3:14;
        end;
        case Cs1i.da <> 0;
          hence IC  Computation(s1,i+1) + k
          = Next (IC Cs2i) by A20,A56,A60,A152,AMI_3:14;
        end;
      end;
A156: now per cases;
        case Cs2i.da = 0;
          hence IC  Computation(s2,i+1) = loc + k by A57,A153,AMI_3:14;
        end;
        case Cs2i.da <> 0;
          hence IC  Computation(s2,i+1) = Next IC Cs2i by A57,A153,AMI_3:14;
        end;
      end;
A157: now per cases;
        suppose loc <> Next IC Cs1i;
          hence IC  Computation(s1,i+1) + k

= IC  Computation(s2,i+1) by A2,A9,A10,A152,A154,A155,A156,AMI_5:94;
        end;
        suppose loc = Next IC Cs1i;
          hence IC  Computation(s1,i+1) + k
          = IC  Computation(s2,i+1) by A20,A60,A155,A156;
        end;
      end;
      hence IC  Computation(s1,i+1) + k = IC  Computation(s2,i+1);
      thus IncAddr(CurInstr( Computation(s1,i+1)), k)
      = CurInstr( Computation(s2,i+1)) by A51,A157;
      now
        let x be set such that
A158:   x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by RELAT_1:87,AMI_3:72;
        then x in SCM-Data-Loc by A30,A158;
        then reconsider d = x as Data-Location by AMI_3:def 2;
        Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A56,A57,A152,A153,AMI_3:14;
        hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A30,A41,A158;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A24,A30,A31,GRFUNC_1:8;
      hence  Computation(s1,i+1)|dom (DataPart p)
      =  Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
      by A24,A30,A31,GRFUNC_1:9;
      now
        let x be set;
        assume
A159:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location by A36,AMI_3:def 2;
        Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A57,A58,A152,A153,AMI_3:14;
        hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A49,A159;
      end;
      then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A36,A37,
      GRFUNC_1:8;
      hence DataPart Cs3i1 =  DataPart Computation(s2,i+1)
      by A36,A37,GRFUNC_1:9;
    end;
    suppose InsCode I = 8;
      then consider loc being Instruction-Location of SCM,
      da being Data-Location such that
A160: I = da>0_goto loc by AMI_5:54;
A161: CurInstr(Cs2i) = da>0_goto (loc+k) by A21,A160,Th12;
A162: Cs3i.da = Cs2i.da by A39;
A163: now per cases;
        case Cs1i.da > 0;
          hence IC  Computation(s1,i+1) + k = loc + k by A56,A160,AMI_3:15;
        end;
        case Cs1i.da <= 0;
          hence IC  Computation(s1,i+1) + k
          = Next (IC Cs2i) by A20,A56,A60,A160,AMI_3:15;
        end;
      end;
A164: now per cases;
        case Cs2i.da > 0;
          hence IC  Computation(s2,i+1) = loc + k by A57,A161,AMI_3:15;
        end;
        case Cs2i.da <= 0;
          hence IC  Computation(s2,i+1) = Next IC Cs2i by A57,A161,AMI_3:15;
        end;
      end;
A165: now per cases;
        suppose loc <> Next IC Cs1i;
          hence IC  Computation(s1,i+1) + k

= IC  Computation(s2,i+1) by A2,A9,A10,A160,A162,A163,A164,AMI_5:95;
        end;
        suppose loc = Next IC Cs1i;
          hence IC  Computation(s1,i+1) + k
          = IC  Computation(s2,i+1) by A20,A60,A163,A164;
        end;
      end;
      hence IC  Computation(s1,i+1) + k = IC  Computation(s2,i+1);
      thus IncAddr(CurInstr( Computation(s1,i+1)), k)
      = CurInstr( Computation(s2,i+1)) by A51,A165;
      now
        let x be set such that
A166:   x in dom (Cs1i1|dom DPp);
        dom DPp c= SCM-Data-Loc by RELAT_1:87,AMI_3:72;
        then x in SCM-Data-Loc by A30,A166;
        then reconsider d = x as Data-Location by AMI_3:def 2;
        Cs1i1.d = Cs1i.d & Cs2i1.d = Cs2i.d by A56,A57,A160,A161,AMI_3:15;
        hence (Cs1i1|dom DPp).x = (Cs2i1|dom DPp).x by A30,A41,A166;
      end;
      then (Cs1i1|dom DPp) c= (Cs2i1|dom DPp) by A24,A30,A31,GRFUNC_1:8;
      hence  Computation(s1,i+1)|dom (DataPart p)
      =  Computation(s2,i+1)|dom (DataPart (Relocated (p,k)))
      by A24,A30,A31,GRFUNC_1:9;
      now
        let x be set;
        assume
A167:   x in dom DataPart Cs3i1;
        then reconsider d = x as Data-Location by A36,AMI_3:def 2;
        Cs3i1.d = Cs3i.d & Cs2i1.d = Cs2i.d by A57,A58,A160,A161,AMI_3:15;
        hence (DataPart Cs3i1).x = (DataPart Cs2i1).x by A49,A167;
      end;
      then DataPart Cs3i1 c= DataPart Computation(s2,i+1) by A36,A37,
      GRFUNC_1:8;
      hence DataPart Cs3i1 = DataPart Computation(s2,i+1)
      by A36,A37,GRFUNC_1:9;
    end;
  end;
  then
A168: for i be Element of NAT st Z[i] holds Z[i+1]; thus
  for i being Element of NAT holds Z[i] from NAT_1:sch 1(A19,A168);
end;

theorem
  for k being Element of NAT, p being autonomic FinPartState of SCM ,
  s1, s2 being State of SCM
  st IC SCM in dom p & p c= s1 & Relocated (p,k) c= s2
  for i being Element of NAT
   holds IC Computation(s1,i) + k = IC  Computation(s2,i) by Th34;

theorem Th34B:
  for k being Element of NAT, p being autonomic FinPartState of SCM ,
  s1, s2 being State of SCM
  st IC SCM in dom p & p c= s1 & Relocated (p,k) c= s2
  for i being Element of NAT holds
  IncAddr(CurInstr( Computation(s1,i)), k) = CurInstr( Computation(s2,i))
   by Th34;

theorem Th34C:
  for k being Element of NAT, p being autonomic FinPartState of SCM ,
  s1, s2 being State of SCM
  st IC SCM in dom p & p c= s1 & Relocated (p,k) c= s2
  for i being Element of NAT holds
   Computation(s1,i)|dom (DataPart p)
  =  Computation(s2,i)|dom (DataPart (Relocated (p,k))) by Th34;

theorem
  for k being Element of NAT, p being autonomic FinPartState of SCM ,
  s1, s2, s3 being State of SCM
  st IC SCM in dom p & p c= s1 & Relocated (p,k) c= s2 &
  s3 = s1 +* DataPart s2 holds for i being Element of NAT holds
   DataPart Computation(s3,i) =  DataPart Computation(s2,i) by Th34;

theorem Th35:
  for p being autonomic FinPartState of SCM , k being Element of NAT
  st IC SCM in dom p holds p is halting iff Relocated (p,k) is halting
proof
  let p be autonomic FinPartState of SCM , k be Element of NAT;
  assume
A1: IC SCM in dom p;
  hereby
    assume
A2: p is halting;
    thus Relocated (p,k) is halting
    proof
      let t be State of SCM;
      assume
A3:   Relocated(p,k) c= t;
      reconsider s = t +* p as State of SCM;
      p c= t +* p by FUNCT_4:26;
      then s is halting by A2,AMI_1:def 26;
      then consider u being Element of NAT such that
A5:   CurInstr( Computation(s,u)) = halt SCM by AMI_1:def 20;
A6:   CurInstr( Computation(t,u)) = IncAddr(halt SCM, k)
              by A1,A3,FUNCT_4:26,A5,Th34B
        .= halt SCM by Def3,AMI_5:37;
      take u;
      thus thesis by A6;
    end;
  end;
  assume
A7: Relocated (p,k) is halting;
  let t be State of SCM;
  assume
A8: p c= t;
  reconsider s = t +* Relocated(p, k) as State of SCM;
    Relocated (p,k) c= t +* Relocated (p,k) by FUNCT_4:26;
  then s is halting by A7,AMI_1:def 26;
  then consider u being Element of NAT such that
A10: CurInstr( Computation(s,u)) = halt SCM by AMI_1:def 20;
A11: IncAddr(CurInstr( Computation(t,u)), k) = halt SCM
 by A1,A8,FUNCT_4:26,A10,Th34B;
  take u;
  thus CurInstr( Computation(t,u)) = halt SCM by A11,Th14,AMI_5:37;
end;

theorem Th36:
  for k being Element of NAT
  for p being autonomic FinPartState of SCM st IC SCM in dom p
  for s being State of SCM st Relocated(p,k) c= s holds
  for i being Element of NAT holds  Computation(s,i)
  =  Computation(s+*p,i) +* Start-At (IC Computation(s+*p,i) + k)
  +* s|dom ProgramPart p +* ProgramPart (Relocated (p,k))
proof
  let k be Element of NAT;
  let p be autonomic FinPartState of SCM such that
A1: IC SCM in dom p;
  let s be State of SCM such that
A2: Relocated (p,k) c= s;
A3: dom Start-At (IC Computation(s+*p,0) + k) = {IC SCM} by FUNCOP_1:19;
A4: dom Start-At(IC p) = {IC SCM} by FUNCOP_1:19;
  ProgramPart (Relocated (p,k)) c= Relocated (p,k) by RELAT_1:88;
  then
A5: ProgramPart (Relocated (p,k)) c= s by A2,XBOOLE_1:1;
A6: s|dom ProgramPart p c= s by RELAT_1:88;
  dom [ProgramPart p] c= the carrier of SCM by AMI_1:80;
  then dom ProgramPart p c= dom s by AMI_1:79;
  then
A7: dom ProgramPart p = dom (s|dom ProgramPart p) by RELAT_1:91;
A8: IC Computation(s+*p,0) = (s +* p).IC SCM by AMI_1:13
    .= p.IC SCM by A1,FUNCT_4:14
    .= IC p by A1,AMI_1:def 43;
  Start-At (IC p + k ) c= Relocated (p,k) by Th28;
  then
A9: Start-At (IC Computation(s+*p,0) + k) c= s by A2,A8,XBOOLE_1:1;
  DataPart (Relocated (p,k)) c= Relocated (p,k) by RELAT_1:88;
  then DataPart (Relocated (p,k)) c= s by A2,XBOOLE_1:1;
  then
A10: DataPart p c= s by Th21;
A11: dom DataPart p misses dom ProgramPart p by AMI_1:104;
A12: {IC SCM} misses dom DataPart p by AMI_1:102;
  set IS = Start-At (IC Computation(s+*p,0) + k);
  set IP = Start-At (IC p);
  set SD = s|dom ProgramPart p;
  set PP = ProgramPart p;
  set DP = DataPart p;
  set PR = ProgramPart (Relocated (p,k));
  defpred Z[Element of NAT] means  Computation(s,$1)
  =  Computation(s+*p,$1) +* Start-At (IC Computation(s+*p,$1) + k)
  +* s|dom ProgramPart p +* ProgramPart (Relocated (p,k));
   Computation(s,0) = s by AMI_1:13
    .= s +* PR by A5,FUNCT_4:79
    .= s +* SD +* PR by A6,FUNCT_4:79
    .= s +* PP +* SD +* PR by A7,FUNCT_4:78
    .= s +* IS +* PP +* SD +* PR by A9,FUNCT_4:79
    .= s +*(IS +* PP) +* SD +* PR by FUNCT_4:15
    .= s +*(PP +* IS) +* SD +* PR by A3,AMI_1:103,FUNCT_4:36
    .= (s +* PP)+* IS +* SD +* PR by FUNCT_4:15
    .= (s +* DP)+* PP +* IS +* SD +* PR by A10,FUNCT_4:79
    .= (s +*(DP +* PP))+* IS +* SD +* PR by FUNCT_4:15
    .= (s +*(PP +* DP))+* IS +* SD +* PR by A11,FUNCT_4:36
    .= (s +* PP)+* DP +* IS +* SD +* PR by FUNCT_4:15
    .=((s +* PP)+* DP) +* IP +* IS +* SD +* PR by A3,A4,FUNCT_4:78
    .= (s +*(PP +* DP))+* IP +* IS +* SD +* PR by FUNCT_4:15
    .= s +*(PP +* DP +* IP) +* IS +* SD +* PR by FUNCT_4:15
    .= s +*(PP +*(DP +* IP))+* IS +* SD +* PR by FUNCT_4:15
    .= s +*(PP +*(IP +* DP))+* IS +* SD +* PR by A4,A12,FUNCT_4:36
    .= s +*(PP +* IP +* DP) +* IS +* SD +* PR by FUNCT_4:15
    .= s +*(IP +* PP +* DP) +* IS +* SD +* PR by A4,AMI_1:103,FUNCT_4:36
    .= s +* p +* IS +* SD +* PR by A1,AMI_1:108
    .=  Computation(s+*p,0) +* Start-At (IC Computation(s+*p,0) + k)
  +* s|dom ProgramPart p +* ProgramPart (Relocated (p,k)) by AMI_1:13;
  then
A13: Z[0];
A14: for i being Element of NAT st Z[i] holds Z[i+1]
  proof
    let i be Element of NAT such that
A15:  Computation(s,i)
    =  Computation(s+*p,i) +* Start-At (IC  Computation(s+*p,i) + k)
    +* s|dom ProgramPart p+* ProgramPart (Relocated (p,k));
    set sdom = s|dom ProgramPart p;
    dom [ProgramPart p] c= the carrier of SCM by AMI_1:80;
    then dom ProgramPart p c= dom s by AMI_1:79;
    then
A16: dom ProgramPart p = dom (s|dom ProgramPart p) by RELAT_1:91;
    then
B16: dom sdom is finite;
X:  rng sdom c= the Instructions of SCM by AMI_1:140,RELAT_1:87;
    dom (s|dom ProgramPart p) c= NAT by A16,RELAT_1:87;
    then reconsider sdom as finite PartFunc of NAT, the Instructions of SCM
     by RELSET_1:11,B16,FINSET_1:29,X;
A17:  Computation(s+*p,i+1) = Following( Computation(s+*p,i))
    by AMI_1:14;
    dom (Start-At (IC  Computation(s+*p,i) + k)) = {IC SCM}
    by FUNCOP_1:19;
    then
A18: IC SCM in dom (Start-At (IC  Computation(s+*p,i) + k)) by
    TARSKI:def 1;
A19: not IC SCM in dom ProgramPart(Relocated (p,k)) by AMI_1:101;
A20: dom (sdom) = dom s /\ dom ProgramPart p by RELAT_1:90;
    not IC SCM in dom ProgramPart p by AMI_1:101;
    then
A21: not IC SCM in dom sdom by A20,XBOOLE_0:def 3;
A22: IC ( Computation(s+*p,i)
    +* Start-At (IC  Computation(s+*p,i) + k) +* [sdom]
    +* [ProgramPart (Relocated (p,k))]) = ( Computation(s+*p,i)
    +* Start-At (IC  Computation(s+*p,i) + k)
    +* sdom).IC SCM by A19,FUNCT_4:12
      .= ( Computation(s+*p,i)
    +* Start-At (IC  Computation(s+*p,i) + k)).IC SCM by A21,FUNCT_4:12
      .= (Start-At (IC  Computation(s+*p,i) + k)).IC SCM by A18,FUNCT_4:14
      .= IC  Computation(s+*p,i) + k by FUNCOP_1:87;
    p is not programmed by A1,AMI_1:109;
    then
A23: IC  Computation(s+*p,i) in dom ProgramPart(p) by AMI_5:86,
    FUNCT_4:26;
    then
A24: IC  Computation(s+*p,i) in dom IncAddr(ProgramPart p,k) by Def5;
    reconsider kk = IC  Computation(s+*p,i) as Element of NAT
     by ORDINAL1:def 13;
A25: ProgramPart(p) c=  Computation(s+*p,i) by AMI_1:99,FUNCT_4:26;
A26: (ProgramPart p)/.kk
    = (ProgramPart p).kk by A23,PARTFUN1:def 8
      .= ( Computation(s+*p,i)).IC  Computation(s+*p,i)
    by A23,A25,GRFUNC_1:8;
    reconsider kk = (IC  Computation(s+*p,i)) as Element of NAT
    by ORDINAL1:def 13;
    ProgramPart p c= p by RELAT_1:88;
    then dom ProgramPart p c= dom p by GRFUNC_1:8;
    then (IC  Computation(s+*p,i) + k) in dom (Relocated (p,k))
    by A23,Th24;
    then (IC  Computation(s+*p,i) + k) in dom (ProgramPart (Relocated (p,k
    ))) by AMI_1:106;
    then
A27: CurInstr  Computation(s,i)
    = (ProgramPart (Relocated (p,k))).(IC  Computation(s+*p,i) + k)
    by A15,A22,FUNCT_4:14
      .= IncAddr(Shift(ProgramPart p,k),k).(IC  Computation(s+*p,i) + k)
    by Th22
      .= Shift(IncAddr(ProgramPart p,k),k).(IC  Computation(s+*p,i) + k)
    by Th19
      .= IncAddr(ProgramPart p,k).kk by A24,VALUED_1:def 12
      .= IncAddr(CurInstr ( Computation(s+*p,i)),k) by A23,A26,Def5;
    thus  Computation(s,i+1) = Following( Computation(s,i)) by AMI_1:14
      .= Exec(IncAddr(CurInstr ( Computation(s+*p,i)),k),
    ( Computation(s+*p,i)) +* Start-At (IC ( Computation(s+*p,i)) + k)
    +* [sdom] ) +* [ProgramPart (Relocated (p,k))] by A15,A27,AMI_5:77
      .= Exec(IncAddr(CurInstr ( Computation(s+*p,i)),k),
    ( Computation(s+*p,i))
    +* Start-At (IC ( Computation(s+*p,i)) + k))
    +* sdom +* ProgramPart (Relocated (p,k)) by AMI_5:77
      .=  Computation(s+*p,i+1)
    +* Start-At (IC  Computation(s+*p,i+1) + k)
    +* s|dom ProgramPart p +* ProgramPart (Relocated (p,k)) by A17,Th31;
  end;
  thus for i being Element of NAT holds Z[i] from NAT_1:sch 1 (A13,A14);
end;

theorem Th37:
  for k being Element of NAT
  for p being FinPartState of SCM st IC SCM in dom p
  for s being State of SCM st p c= s & Relocated(p,k) is autonomic holds
  for i being Element of NAT holds  Computation(s,i)
  =  Computation(s+*Relocated(p,k),i)
  +* Start-At (IC Computation(s+*Relocated(p,k),i) -' k)
  +* s|dom ProgramPart Relocated(p,k) +* ProgramPart (p)
proof
  let k be Element of NAT;
  let p be FinPartState of SCM such that
A1: IC SCM in dom p;
  let s be State of SCM such that
A2: p c= s and
A3: Relocated (p,k) is autonomic;
A4: dom Start-At (IC Computation(s+*Relocated(p,k),0) -' k) = {IC SCM}
  by FUNCOP_1:19;
A5: dom Start-At((IC p)+k) = {IC SCM} by FUNCOP_1:19;
  ProgramPart p c= p by RELAT_1:88;
  then
A6: ProgramPart p c= s by A2,XBOOLE_1:1;
  Start-At (IC p) c= p by A1,AMI_1:110;
  then
A7: Start-At (IC p) c= s by A2,XBOOLE_1:1;
  dom [ProgramPart Relocated(p,k)] c= the carrier of SCM by AMI_1:80;
  then
A8: dom ProgramPart Relocated(p,k) c= dom s by AMI_1:79;
A9: IC SCM in dom Relocated(p,k) by Th25;
A10: IC Computation(s+*Relocated(p,k),0)
  = (s +* Relocated(p,k)).IC SCM by AMI_1:13
    .= Relocated(p,k).IC SCM by A9,FUNCT_4:14
    .= IC Relocated(p,k) by A9,AMI_1:def 43;
  DataPart p c= p by RELAT_1:88;
  then
A11: DataPart p c= s by A2,XBOOLE_1:1;
A12: dom DataPart p misses dom ProgramPart Relocated(p,k) by AMI_1:104;
A13: {IC SCM} misses dom DataPart p by AMI_1:102;
  {IC SCM} misses dom ProgramPart Relocated(p,k) by AMI_1:103;
  then
A14: {IC SCM} /\ dom ProgramPart Relocated(p,k) = {} by XBOOLE_0:def 7;
  dom(Start-At (IC Computation(s+*Relocated(p,k),0) -' k))
  /\ dom (s|(dom ProgramPart Relocated(p,k)))
  = {IC SCM} /\ (dom s /\ dom ProgramPart Relocated(p,k)) by A4,RELAT_1:90
    .= ({IC SCM} /\ dom ProgramPart Relocated(p,k)) /\ dom s by XBOOLE_1:16
    .= {} by A14;
  then
A15: dom(Start-At (IC Computation(s+*Relocated(p,k),0) -' k)) misses
  dom (s|(dom ProgramPart Relocated(p,k))) by XBOOLE_0:def 7;
A16: dom ProgramPart Relocated(p,k) =
  dom(s|(dom ProgramPart Relocated(p,k))) by A8,RELAT_1:91;
  set IS = Start-At (IC Computation(s+*Relocated(p,k),0) -' k);
  set IP = Start-At((IC p)+k);
  set SD = s|(dom ProgramPart Relocated(p,k));
  set PP = ProgramPart p;
  set DP = DataPart p;
  set PR = ProgramPart Relocated (p,k);
  defpred Z[Element of NAT] means  Computation(s,$1)
  =  Computation(s+*Relocated(p,k),$1)
  +* Start-At (IC Computation(s+*Relocated(p,k),$1) -' k)
  +* s|(dom ProgramPart Relocated(p,k)) +* ProgramPart p;
   Computation(s,0) = s by AMI_1:13
    .= s +* PP by A6,FUNCT_4:79
    .= s +* Start-At (IC p) +* PP by A7,FUNCT_4:79
    .= s +* Start-At (IC p + k -' k) +* PP by NAT_D:34
    .= s +* IS +* PP by A10,Th26
    .= s +* SD +* IS +* PP by FUNCT_4:80
    .= s +* PR +* SD +* IS +* PP by A16,FUNCT_4:78
    .= s +* PR +* (SD +* IS) +* PP by FUNCT_4:15
    .= s +* PR +* (IS +* SD) +* PP by A15,FUNCT_4:36
    .= s +* PR +* IS +* SD +* PP by FUNCT_4:15
    .= (s +* DP) +* PR +* IS +* SD +* PP by A11,FUNCT_4:79
    .= (s +*(DP +* PR))+* IS +* SD +* PP by FUNCT_4:15
    .= (s +*(PR +* DP))+* IS +* SD +* PP by A12,FUNCT_4:36
    .= (s +* PR) +* DP +* IS +* SD +* PP by FUNCT_4:15
    .=((s +* PR) +* DP) +* IP +* IS +* SD +* PP by A4,A5,FUNCT_4:78
    .= (s +*(PR +* DP))+* IP +* IS +* SD +* PP by FUNCT_4:15
    .= s +*(PR +* DP +* IP) +* IS +* SD +* PP by FUNCT_4:15
    .= s +*(PR +* (DP +* IP))+* IS +* SD +* PP by FUNCT_4:15
    .= s +*(PR +* (IP +* DP))+* IS +* SD +* PP by A5,A13,FUNCT_4:36
    .= s +*(PR +* IP +* DP) +* IS +* SD +* PP by FUNCT_4:15
    .= s +*(IP +* PR +* DP) +* IS +* SD +* PP by A5,AMI_1:103,FUNCT_4:36
    .= s +* Relocated(p,k) +* IS +* SD +* PP by Th22
    .=  Computation(s+*Relocated(p,k),0)
  +* Start-At (IC Computation(s+*Relocated(p,k),0) -' k)
  +* s|(dom ProgramPart Relocated(p,k)) +* ProgramPart p by AMI_1:13;
  then
A17: Z[0];
A18: for i being Element of NAT st Z[i] holds Z[i+1]
  proof
    let i be Element of NAT such that
A19:  Computation(s,i) =  Computation(s+*Relocated(p,k),i)
    +* Start-At (IC  Computation(s+*Relocated(p,k),i) -' k)
    +* s|dom ProgramPart Relocated(p,k) +* ProgramPart p;
    set sdom = s|dom ProgramPart Relocated(p,k);
    dom [ProgramPart Relocated(p,k)] c= the carrier of SCM by AMI_1:80;
    then dom ProgramPart Relocated(p,k) c= dom s by AMI_1:79;
    then
A20: dom ProgramPart Relocated(p,k) =
    dom (s|(dom ProgramPart Relocated(p,k))) by RELAT_1:91;
    then
B20: dom sdom is finite;
X:  rng sdom c= the Instructions of SCM by AMI_1:140,RELAT_1:87;
    dom (s|(dom ProgramPart Relocated(p,k))) c= NAT by A20,RELAT_1:87;
    then reconsider sdom as finite PartFunc of NAT, the Instructions of SCM
    by RELSET_1:11,B20,FINSET_1:29,X;
A21:  Computation(s+*Relocated(p,k),i+1)
    = Following( Computation(s+*Relocated(p,k),i)) by AMI_1:14;
    dom (Start-At (IC  Computation(s+*Relocated(p,k),i) -' k)) = {IC SCM }
    by FUNCOP_1:19;
    then
A22: IC SCM in dom (Start-At (IC  Computation(s+*Relocated(p,k),i) -' k))
    by TARSKI:def 1;
A23: not IC SCM in dom ProgramPart p by AMI_1:101;
A24: dom sdom = dom s /\ dom ProgramPart Relocated(p,k) by RELAT_1:90;
    not IC SCM in dom ProgramPart Relocated(p,k) by AMI_1:101;
    then
A25: not IC SCM in dom (sdom) by A24,XBOOLE_0:def 3;
A26: IC ( Computation(s+*Relocated(p,k),i)
    +* Start-At (IC  Computation(s+*Relocated(p,k),i) -' k) +* [sdom]
    +* [ProgramPart p]) = ( Computation(s+*Relocated(p,k),i)
    +* Start-At (IC  Computation(s+*Relocated(p,k),i) -' k)
    +* sdom).IC SCM by A23,FUNCT_4:12
      .= ( Computation(s+*Relocated(p,k),i)
    +* Start-At (IC  Computation(s+*Relocated(p,k),i) -' k)).IC SCM
    by A25,FUNCT_4:12
      .= (Start-At (IC  Computation(s+*Relocated(p,k),i) -' k)).IC SCM
    by A22,FUNCT_4:14
      .= IC  Computation(s+*Relocated(p,k),i) -' k by FUNCOP_1:87;
    IC SCM in dom Relocated(p,k) by Th25;
    then Relocated(p,k) is not programmed by AMI_1:109;
    then
A27: IC  Computation(s+*Relocated(p,k),i)
    in dom ProgramPart(Relocated(p,k)) by A3,AMI_5:86,FUNCT_4:26;
A28: ProgramPart(Relocated(p,k)) c=  Computation(s+*Relocated(p,k),i)
    by AMI_1:99,FUNCT_4:26;
    reconsider jk = IC  Computation(s+*Relocated(p,k),i)
     as  Element of NAT by ORDINAL1:def 13;
    jk in { j+k : j in dom ProgramPart(p) } by A27,Th23;
    then consider j being Element of NAT such that
A30: jk = j+k & j in dom ProgramPart(p);
A32: j+k -' k = j by NAT_D:34;
    reconsider pp = [ProgramPart p] as preProgram of SCM;
    dom Shift(pp, k) = { m+k : m in dom pp} by VALUED_1:def 12;
    then
A33: il.(j+k) in dom Shift(ProgramPart(p), k) by A30;
    reconsider kk = IC  Computation(s+*Relocated(p,k),i) as Element of NAT
     by ORDINAL1:def 13;
A34: CurInstr  Computation(s,i) = (ProgramPart p).
    (IC  Computation(s+*Relocated(p,k),i) -' k) by A19,A26,A30,A32,
    FUNCT_4:14
      .= Shift(ProgramPart p, k).
    (IC  Computation(s+*Relocated(p,k),i)) by A30,A32,VALUED_1:def 12
      .= Shift(ProgramPart p, k)/.kk
    by A30,A33,PARTFUN1:def 8;
    IncAddr(Shift(ProgramPart p, k)/.kk,k)
    = IncAddr(Shift(ProgramPart p,k),k).
    (IC  Computation(s+*Relocated(p,k),i)) by A30,A33,Def5

.= (ProgramPart Relocated(p,k)).(IC  Computation(s+*Relocated(p,k),i))
    by Th22

.= CurInstr ( Computation(s+*Relocated(p,k),i)) by A27,A28,GRFUNC_1:8;
    then
A35: Exec(CurInstr  Computation(s,i),  Computation(s+*Relocated(p,k),i)
    +* Start-At (IC  Computation(s+*Relocated(p,k),i) -' k))
    = Following( Computation(s+*Relocated(p,k),i))

+* Start-At ((IC Following Computation(s+*Relocated(p,k),i)) -' k) by
    A30,A34,Th32;
    thus  Computation(s,i+1) = Following( Computation(s,i)) by AMI_1:14
      .= Exec(CurInstr  Computation(s,i),
     Computation(s+*Relocated(p,k),i)
    +* Start-At (IC  Computation(s+*Relocated(p,k),i) -' k)
    +* [sdom] ) +* [ProgramPart p] by A19,AMI_5:77
      .=  Computation(s+*Relocated(p,k),i+1)
    +* Start-At (IC  Computation(s+*Relocated(p,k),i+1) -' k)
    +* s|dom ProgramPart Relocated(p,k) +* ProgramPart p by A21,A35,AMI_5:77;
  end;
  thus for i being Element of NAT holds Z[i] from NAT_1:sch 1 (A17,A18);
end;

theorem Th38:
  for p being FinPartState of SCM st IC SCM in dom p
  for k being Element of NAT holds
  p is autonomic iff Relocated (p,k) is autonomic
proof
  let p be FinPartState of SCM such that
A1: IC SCM in dom p;
  let k be Element of NAT;
  hereby
    assume
A2: p is autonomic;
    thus Relocated (p,k) is autonomic
    proof
      let s1,s2 be State of SCM such that
A3:   Relocated (p,k) c= s1 & Relocated (p,k) c= s2;
      let i be Element of NAT;
A4:    Computation(s1,i)
      =  Computation(s1+*p,i) +* Start-At (IC Computation(s1+*p,i) + k)
      +* s1|dom ProgramPart p +* ProgramPart (Relocated (p,k))
      by A1,A2,A3,Th36;
A5:    Computation(s2,i)
      =  Computation(s2+*p,i) +* Start-At (IC Computation(s2+*p,i) + k)
      +* s2|dom ProgramPart p +* ProgramPart (Relocated (p,k))
      by A1,A2,A3,Th36;
      p c= s1 +* p & p c= s2 +* p by FUNCT_4:26;
      then
A6:    Computation(s1+*p,i)|dom (p ) =  Computation(s2+*p,i) |dom (p )
      by A2,AMI_1:def 25;
A7:   dom (Start-At ((IC p)+k)) = {IC SCM} by FUNCOP_1:19;
A8:   dom
      (Start-At ((IC  Computation(s1+*p,i))+k)) = {IC SCM} by FUNCOP_1:19;
A9:   dom
      (Start-At ((IC  Computation(s2+*p,i))+k)) = {IC SCM} by FUNCOP_1:19;
A10:  {IC SCM} c= dom p by A1,ZFMISC_1:37;
A11:  Start-At (IC Computation(s1+*p,i))
      =  Computation(s1+*p,i)|{IC SCM} by AMI_1:95
        .=  Computation(s2+*p,i)|{IC SCM} by A6,A10,RELAT_1:188
        .= Start-At (IC Computation(s2+*p,i)) by AMI_1:95;
A12:  dom (Start-At ((IC p) + k))
      misses dom ProgramPart (Relocated (p,k)) by A7,AMI_1:103;
      dom [ProgramPart p] c= the carrier of SCM by AMI_1:80;
      then dom ProgramPart p c= dom s1 by AMI_1:79;
      then
A13:  dom(s1|dom ProgramPart p) = dom ProgramPart p by RELAT_1:91;
      dom [ProgramPart p] c= the carrier of SCM by AMI_1:80;
      then dom ProgramPart p c= dom s2 by AMI_1:79;
      then
A14:  dom(s2|dom ProgramPart p) = dom ProgramPart p by RELAT_1:91;
A15:   Computation(s1,i)|dom (Start-At ((IC p)+k))
      = ( Computation(s1+*p,i) +* Start-At (IC Computation(s1+*p,i) + k)
      +* s1|dom ProgramPart p) |dom (Start-At ((IC p)+k)) by A4,A12,FUNCT_4:76

.= ( Computation(s1+*p,i) +* Start-At (IC Computation(s1+*p,i) + k))
      |dom (Start-At ((IC p)+k)) by A7,A13,AMI_1:103,FUNCT_4:76
        .= Start-At (IC Computation(s1+*p,i) + k) by A7,A8,FUNCT_4:24
        .= Start-At (IC Computation(s2+*p,i) + k) by A11,SCMNORM:9

.= ( Computation(s2+*p,i) +* Start-At (IC Computation(s2+*p,i) + k))
      |dom (Start-At ((IC p)+k)) by A7,A9,FUNCT_4:24

.= ( Computation(s2+*p,i) +* Start-At (IC Computation(s2+*p,i) + k)
      +* s2|dom ProgramPart p)
      |dom (Start-At ((IC p)+k)) by A7,A14,AMI_1:103,FUNCT_4:76
        .=  Computation(s2,i)|dom (Start-At ((IC p)+k)) by A5,A12,FUNCT_4:76;
A16:   Computation(s1,i)|dom (IncAddr(Shift(ProgramPart p,k),k))
      =  Computation(s1,i)|dom (ProgramPart (Relocated (p,k))) by Th22
        .= ProgramPart (Relocated (p,k)) by A4,FUNCT_4:24
        .=  Computation(s2,i)|dom (ProgramPart (Relocated (p,k)))
      by A5,FUNCT_4:24
        .=  Computation(s2,i)|dom (IncAddr(Shift(ProgramPart p,k),k))
      by Th22;
      DataPart p c= p by RELAT_1:88;
      then
A17:  dom DataPart p c= dom p by GRFUNC_1:8;
A18:  dom(DataPart p) misses dom(ProgramPart(Relocated (p,k)))by AMI_1:104;
A19:  dom(DataPart p) misses dom (Start-At (IC Computation(s1+*p,i) + k))
      by A8,AMI_1:102;
A20:  dom(DataPart p) misses dom (Start-At (IC Computation(s2+*p,i) + k))
      by A9,AMI_1:102;
A21:   Computation(s1,i)|dom (DataPart p)
      = ( Computation(s1+*p,i) +* Start-At (IC Computation(s1+*p,i) + k)
      +* s1|dom ProgramPart p) | dom(DataPart p) by A4,A18,FUNCT_4:76

.= ( Computation(s1+*p,i) +* Start-At (IC Computation(s1+*p,i) + k))
      | dom(DataPart p) by A13,AMI_1:104,FUNCT_4:76
        .= ( Computation(s1+*p,i)) | dom (DataPart p) by A19,FUNCT_4:76
        .= ( Computation(s2+*p,i)) | dom (DataPart p) by A6,A17,RELAT_1:188

.= ( Computation(s2+*p,i) +* Start-At (IC Computation(s2+*p,i) + k))
      | dom(DataPart p) by A20,FUNCT_4:76

.= ( Computation(s2+*p,i) +* Start-At (IC Computation(s2+*p,i) + k)
      +* s2|dom ProgramPart p) | dom(DataPart p) by A14,AMI_1:104,FUNCT_4:76
        .=  Computation(s2,i)|dom (DataPart p) by A5,A18,FUNCT_4:76;
A22:   Computation(s1,i)|dom (Start-At ((IC p)+k) +*
      IncAddr(Shift(ProgramPart p,k),k))
      =  Computation(s1,i)|(dom (Start-At ((IC p)+k)) \/
      dom (IncAddr(Shift(ProgramPart p,k),k))) by FUNCT_4:def 1
        .=  Computation(s2,i)|dom (Start-At ((IC p)+k)) \/
       Computation(s2,i)|dom (IncAddr(Shift(ProgramPart p,k),k)) by A15,A16,
      RELAT_1:107
        .=  Computation(s2,i)|(dom (Start-At ((IC p)+k)) \/
      dom (IncAddr(Shift(ProgramPart p,k),k))) by RELAT_1:107
        .=  Computation(s2,i)|dom (Start-At ((IC p)+k) +*
      IncAddr(Shift(ProgramPart p,k),k)) by FUNCT_4:def 1;
      thus  Computation(s1,i)|dom Relocated (p,k)
      =  Computation(s1,i)|(dom (Start-At ((IC p)+k) +*
      IncAddr(Shift(ProgramPart p,k),k)) \/
      dom (DataPart p)) by FUNCT_4:def 1
        .=  Computation(s2,i)|dom (Start-At ((IC p)+k) +*
      IncAddr(Shift(ProgramPart p,k),k)) \/
       Computation(s2,i)|dom (DataPart p) by A21,A22,RELAT_1:107
        .=  Computation(s2,i)|(dom (Start-At ((IC p)+k) +*
      IncAddr(Shift(ProgramPart p,k),k)) \/ dom (DataPart p)) by RELAT_1:107
        .=  Computation(s2,i)|dom Relocated (p,k) by FUNCT_4:def 1;
    end;
  end;
  assume
A23: Relocated (p,k) is autonomic;
  thus p is autonomic
  proof
    let s1,s2 be State of SCM such that
A24: p c= s1 & p c= s2;
    let i be Element of NAT;
A25:  Computation(s1,i) =  Computation(s1+*Relocated(p,k),i)
    +* Start-At (IC Computation(s1+*Relocated(p,k),i) -' k)
    +* s1|dom ProgramPart Relocated(p,k) +* ProgramPart (p)
    by A1,A23,A24,Th37;
A26:  Computation(s2,i) =  Computation(s2+*Relocated(p,k),i)
    +* Start-At (IC Computation(s2+*Relocated(p,k),i) -' k)
    +* s2|dom ProgramPart Relocated(p,k) +* ProgramPart (p)
    by A1,A23,A24,Th37;
    Relocated (p,k) c= s1 +* Relocated (p,k) &
    Relocated (p,k) c= s2 +* Relocated (p,k) by FUNCT_4:26;
    then
A27:  Computation(s1+*Relocated(p,k),i)|dom (Relocated (p,k))
    =  Computation(s2+*Relocated(p,k),i)|dom (Relocated (p,k)) by A23,
    AMI_1:def 25;
A28: dom (Start-At (IC p)) = {IC SCM} by FUNCOP_1:19;
A29: dom (Start-At ((IC  Computation(s1+*Relocated(p,k),i)) -' k))
    = {IC SCM} by FUNCOP_1:19;
A30: dom (Start-At ((IC  Computation(s2+*Relocated(p,k),i)) -' k))
    = {IC SCM} by FUNCOP_1:19;
    IC SCM in dom Relocated (p,k) by Th25;
    then
A31: {IC SCM} c= dom Relocated (p,k) by ZFMISC_1:37;
A32: Start-At (IC Computation(s1+*Relocated(p,k),i))
    =  Computation(s1+*Relocated(p,k),i)|{IC SCM} by AMI_1:95
      .=  Computation(s2+*Relocated(p,k),i)|{IC SCM} by A27,A31,RELAT_1:188
      .= Start-At (IC Computation(s2+*Relocated(p,k),i)) by AMI_1:95;
A33: dom (Start-At (IC p)) misses dom (ProgramPart p) by A28,AMI_1:103;
    dom [ProgramPart Relocated(p,k)] c= the carrier of SCM by AMI_1:80;
    then dom ProgramPart Relocated(p,k) c= dom s1 by AMI_1:79;
    then
A34: dom(s1|dom ProgramPart Relocated(p,k))
    = dom ProgramPart Relocated(p,k) by RELAT_1:91;
    dom [ProgramPart Relocated(p,k)] c= the carrier of SCM by AMI_1:80;
    then dom ProgramPart Relocated(p,k) c= dom s2 by AMI_1:79;
    then
A35: dom(s2|dom ProgramPart Relocated(p,k))
    = dom ProgramPart Relocated(p,k) by RELAT_1:91;
A36:  Computation(s1,i)|dom (Start-At (IC p))
    = ( Computation(s1+*Relocated(p,k),i)
    +* Start-At (IC Computation(s1+*Relocated(p,k),i) -' k)
    +* s1|dom ProgramPart Relocated(p,k))
    |dom (Start-At (IC p)) by A25,A33,FUNCT_4:76
      .= ( Computation(s1+*Relocated(p,k),i)
    +* Start-At (IC Computation(s1+*Relocated(p,k),i) -' k))
    |dom (Start-At (IC p)) by A28,A34,AMI_1:103,FUNCT_4:76
      .= Start-At (IC Computation(s1+*Relocated(p,k),i) -' k)
    by A28,A29,FUNCT_4:24
      .= Start-At (IC Computation(s2+*Relocated(p,k),i) -' k) by A32,SCMNORM:10
      .= ( Computation(s2+*Relocated(p,k),i)
    +* Start-At (IC Computation(s2+*Relocated(p,k),i) -' k))
    |dom (Start-At (IC p)) by A28,A30,FUNCT_4:24
      .= ( Computation(s2+*Relocated(p,k),i)
    +* Start-At (IC Computation(s2+*Relocated(p,k),i) -' k)
    +* s2|dom ProgramPart Relocated(p,k))
    |dom (Start-At (IC p)) by A28,A35,AMI_1:103,FUNCT_4:76
      .=  Computation(s2,i)|dom (Start-At (IC p)) by A26,A33,FUNCT_4:76;
A37:  Computation(s1,i)|dom (ProgramPart p)
    = ProgramPart (p) by A25,FUNCT_4:24
      .=  Computation(s2,i)|dom (ProgramPart p) by A26,FUNCT_4:24;
    DataPart (Relocated(p,k)) c= Relocated(p,k) by RELAT_1:88;
    then DataPart p c= Relocated(p,k) by Th21;
    then
A38: dom (DataPart p) c= dom (Relocated(p,k)) by GRFUNC_1:8;
A39: dom (DataPart p) misses dom (ProgramPart p) by AMI_1:104;
A40: dom(DataPart p) misses
    dom(Start-At (IC Computation(s1+*Relocated(p,k),i) -' k))
    by A29,AMI_1:102;
A41: dom(DataPart p) misses
    dom(Start-At (IC Computation(s2+*Relocated(p,k),i) -' k))
    by A30,AMI_1:102;
A42:  Computation(s1,i)|dom (DataPart p)
    = ( Computation(s1+*Relocated(p,k),i)
    +* Start-At (IC Computation(s1+*Relocated(p,k),i) -' k)
    +* s1|dom ProgramPart Relocated(p,k))
    | dom(DataPart p) by A25,A39,FUNCT_4:76
      .= ( Computation(s1+*Relocated(p,k),i) +*
    Start-At (IC Computation(s1+*Relocated(p,k),i) -' k))
    | dom(DataPart p) by A34,AMI_1:104,FUNCT_4:76
      .= ( Computation(s1+*Relocated(p,k),i)) | dom (DataPart p)
    by A40,FUNCT_4:76
      .= ( Computation(s2+*Relocated(p,k),i)) | dom (DataPart p)
    by A27,A38,RELAT_1:188
      .= ( Computation(s2+*Relocated(p,k),i) +*
    Start-At (IC Computation(s2+*Relocated(p,k),i) -' k))
    | dom(DataPart p) by A41,FUNCT_4:76
      .= ( Computation(s2+*Relocated(p,k),i)
    +* Start-At (IC Computation(s2+*Relocated(p,k),i) -' k)
    +* s2|dom ProgramPart Relocated(p,k))
    | dom(DataPart p) by A35,AMI_1:104,FUNCT_4:76
      .=  Computation(s2,i)|dom (DataPart p) by A26,A39,FUNCT_4:76;
A43:  Computation(s1,i)|dom (Start-At (IC p) +* ProgramPart p)
    =  Computation(s1,i)|(dom (Start-At (IC p)) \/ dom (ProgramPart p))
    by FUNCT_4:def 1
      .=  Computation(s2,i)|dom (Start-At (IC p)) \/
     Computation(s2,i)|dom (ProgramPart p) by A36,A37,RELAT_1:107
      .=  Computation(s2,i)|(dom (Start-At (IC p)) \/ dom (ProgramPart p))
    by RELAT_1:107
      .=  Computation(s2,i)|dom (Start-At (IC p) +* ProgramPart p)
    by FUNCT_4:def 1;
    thus  Computation(s1,i)|dom p
    =  Computation(s1,i)|dom (Start-At (IC p) +* ProgramPart p +*
    DataPart p ) by A1,AMI_1:108
      .=  Computation(s1,i)|(dom (Start-At (IC p) +* ProgramPart p) \/
    dom (DataPart p)) by FUNCT_4:def 1
      .=  Computation(s2,i)|dom (Start-At (IC p) +* ProgramPart p ) \/
     Computation(s2,i)|dom (DataPart p) by A42,A43,RELAT_1:107
      .=  Computation(s2,i)|(dom (Start-At (IC p) +* ProgramPart p) \/
    dom (DataPart p)) by RELAT_1:107
      .=  Computation(s2,i)|dom (Start-At (IC p) +*
    ProgramPart p +* DataPart p) by FUNCT_4:def 1
      .=  Computation(s2,i)|dom p by A1,AMI_1:108;
  end;
end;

theorem Th39:
  for p being halting autonomic FinPartState of SCM st IC SCM in dom p
  for k being Element of NAT holds
  DataPart(Result(p)) = DataPart(Result(Relocated(p,k)))
proof
  let p be halting autonomic FinPartState of SCM such that
A1: IC SCM in dom p;
  let k be Element of NAT;
  consider s being State of SCM such that
A2: p c= s by CARD_3:97;
  s is halting by A2,AMI_1:def 26;
  then consider j1 being Element of NAT such that
A3: Result(s) =  Computation(s,j1) and
A4: CurInstr(Result(s)) = halt SCM by AMI_1:def 22;
  consider t being State of SCM such that
A5: Relocated(p,k) c= t by CARD_3:97;
  t.(IC  Computation(t,j1)) = CurInstr Computation(t,j1) by AMI_1:54
    .= IncAddr(CurInstr( Computation(s,j1)), k) by A1,A2,A5,Th34B
    .= halt SCM by A3,A4,Def3,AMI_5:37;
  then
A7: Result t =  Computation(t,j1) by AMI_1:56;
A8:  Computation(t,j1) | dom (DataPart Relocated(p,k))
  =  Computation(s,j1) | dom (DataPart p) by A1,A2,A5,Th34C;
A9: Relocated(p,k) is halting & Relocated(p,k) is autonomic by A1,Th35,Th38;
  thus DataPart(Result(p))
    = (Result s) | dom p | SCM-Data-Loc by A2,AMI_1:def 28,AMI_3:72
    .= (Result s) | (dom p /\ SCM-Data-Loc) by RELAT_1:100
    .= (Result s) | dom (DataPart p) by RELAT_1:90,AMI_3:72
    .= (Result t) | (dom Relocated(p,k) /\ SCM-Data-Loc)
                       by RELAT_1:90,AMI_3:72,A3,A7,A8
    .= ((Result t) | dom Relocated(p,k))|SCM-Data-Loc by RELAT_1:100
    .= DataPart (Result(Relocated(p,k))) by A5,A9,AMI_1:def 28,AMI_3:72;
end;

:: Relocatability

theorem
  for F being PartFunc of FinPartSt SCM, FinPartSt SCM,
  p being FinPartState of SCM st IC SCM in dom p & F is data-only
  for k being Element of NAT holds
  p computes F iff Relocated ( p,k) computes F
proof
  let F be PartFunc of FinPartSt SCM ,FinPartSt SCM ,
  p be FinPartState of SCM such that
A1: IC SCM in dom p and
A2: F is data-only;
  let k be Element of NAT;
  hereby
    assume
A3: p computes F;
    thus Relocated ( p,k) computes F
    proof
      let x be set;
      assume
A4:   x in dom F;
      dom F c= FinPartSt SCM by RELSET_1:12;
      then reconsider s = x as FinPartState of SCM by A4,AMI_1:125;
      reconsider s as data-only FinPartState of SCM by A2,A4,AMI_1:def 51;
      take s;
      thus x=s;
      consider s1 being FinPartState of SCM such that
A5:   x = s1 & p +* s1 is pre-program of SCM &
      F.s1 c= Result(p +* s1) by A3,A4,AMI_1:def 29;
      reconsider Fs1 = F.s1 as FinPartState of SCM by A5,CARD_3:80;
A6:   Fs1 is data-only by A2,A4,A5,AMI_1:def 51;
      then
A7:   F.s1 c= DataPart(Result(p +* s1)) by A5,AMI_1:107;
A8:   Relocated(p,k) +* s = Relocated((p +* s) ,k) by A1,Th29;
      dom(p +* s) = dom p \/ dom s by FUNCT_4:def 1;
      then
A9:   IC SCM in dom(p +* s) by A1,XBOOLE_0:def 2;
      hence Relocated(p,k) +* s is pre-program of SCM by A5,A8,Th35,Th38;
      DataPart(Result(p +* s1))
      = DataPart(Result(Relocated(p +* s,k))) by A5,A9,Th39
        .= DataPart(Result(Relocated(p,k) +* s)) by A1,Th29;
      hence F.s c= Result(Relocated(p,k) +* s) by A5,A6,A7,AMI_1:107;
    end;
  end;
  assume
A10: Relocated (p,k) computes F;
  let x be set;
  assume
A11: x in dom F;
  dom F c= FinPartSt SCM by RELSET_1:12;
  then reconsider s = x as FinPartState of SCM by A11,AMI_1:125;
  reconsider s as data-only FinPartState of SCM by A2,A11,AMI_1:def 51;
  take s;
  thus x=s;
  consider s1 being FinPartState of SCM such that
A12: x = s1 & Relocated (p,k) +* s1 is pre-program of SCM &
  F.s1 c= Result (Relocated (p,k) +* s1) by A10,A11,AMI_1:def 29;
  reconsider Fs1 = F.s1 as FinPartState of SCM by A12,CARD_3:80;
A13: Fs1 is data-only by A2,A11,A12,AMI_1:def 51;
  then
A14: F.s1 c= DataPart(Result(Relocated(p,k) +* s1)) by A12,AMI_1:107;
A15: Relocated(p,k) +* s = Relocated((p +* s),k) by A1,Th29;
  dom(p +* s) = dom p \/ dom s by FUNCT_4:def 1;
  then
A16: IC SCM in dom(p +* s) by A1,XBOOLE_0:def 2;
  then
A17: p +* s is autonomic by A12,A15,Th38;
  then
A18: p +* s is halting by A12,A15,A16,Th35;
  thus p +* s is pre-program of SCM by A12,A15,A16,A17,Th35;
  DataPart(Result(Relocated(p,k) +* s1))
  = DataPart(Result(Relocated(p +* s,k))) by A1,A12,Th29
    .= DataPart(Result(p +* s)) by A16,A17,A18,Th39;
  hence F.s c= Result(p +* s) by A12,A13,A14,AMI_1:107;
end;

