:: The Construction and shiftability of Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMPDS_2, SCMFSA_7, CARD_1, FUNCOP_1,
      RELAT_1, FUNCT_1, CAT_1, NAT_1, ARYTM_3, XBOOLE_0, TARSKI, VALUED_1,
      SCMNORM, FSM_1, INT_1, FUNCT_4, GRAPHSP, AMI_3, FUNCT_7, AMI_2,
      STRUCT_0, SCMPDS_1, COMPLEX1, XXREAL_0, ARYTM_1, TURING_1, AMISTD_2,
      SCMFSA6B, MSUALG_1, CIRCUIT2, SCMPDS_4, ORDINAL1, PARTFUN1,
      AFINSQ_1, SCMFSA6C, ORDINAL4, CARD_5, UNIALG_1, COMPOS_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      RELAT_1, FUNCT_1, PARTFUN1, AFINSQ_1, VALUED_1, FUNCT_4, FUNCT_7, INT_1,
      NAT_1, INT_2, XXREAL_0, STRUCT_0, COMPOS_1, EXTPRO_1, AMI_1, AMI_2,
      SCMPDS_1, SCMPDS_2;
 constructors WELLORD2, XXREAL_0, INT_2, AMI_5, SCMPDS_1, SCMPDS_3, DOMAIN_1,
      RELSET_1, PRE_POLY, ORDINAL5, AMI_1;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, AMI_1, SCMPDS_2, AMI_2, FINSET_1, CARD_1,
      VALUED_1, FUNCT_4, RELAT_1, PRE_POLY, AFINSQ_1, COMPOS_1, ORDINAL5,
      EXTPRO_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, COMPOS_1, EXTPRO_1, AMI_1, FUNCT_7, XBOOLE_0, SCMPDS_2,
 FUNCOP_1,
      NAT_1, AFINSQ_1;
 theorems AMI_1, NAT_1, TARSKI, FUNCT_4, FUNCT_1, ZFMISC_1, INT_1, RELAT_1,
      SCMPDS_2, AMI_2, FUNCT_2, FUNCT_7, SCMPDS_3, CARD_1, ENUMSET1,
      ABSVALUE, GRFUNC_1, CARD_2, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1,
      FUNCOP_1, VALUED_1, AFINSQ_1, PARTFUN1, COMPOS_1, EXTPRO_1;
 schemes NAT_1, CLASSES1;

begin :: Definition of a program block and its basic properties

reserve l, m, n for Element of NAT,
  i,j,k for Instruction of SCMPDS,
  I,J,K for Program of SCMPDS,
  p,q,r for PartState of SCMPDS;

reserve a,b,c for Int_position,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer;

canceled 5;

theorem Th6:
  InsCode i in {0,1,4,5,6} or Exec(i,s).IC SCMPDS = succ IC s
proof
  assume
A1: not InsCode i in {0,1,4,5,6};
  then
A2: InsCode i <> 0 & InsCode i <> 1 by ENUMSET1:def 3;
A3: InsCode i <> 6 by A1,ENUMSET1:def 3;
A4: InsCode i <> 4 & InsCode i <> 5 by A1,ENUMSET1:def 3;
  per cases by A2,A4,A3,NAT_1:38,SCMPDS_2:15;
  suppose
    InsCode i = 2;
    then ex a,k1 st i = a:=k1 by SCMPDS_2:37;
    hence thesis by SCMPDS_2:57;
  end;
  suppose
    InsCode i = 3;
    then ex a,k1 st i = saveIC(a,k1) by SCMPDS_2:38;
    hence thesis by SCMPDS_2:71;
  end;
  suppose
    InsCode i = 7;
    then ex a,k1,k2 st i = (a,k1) := k2 by SCMPDS_2:42;
    hence thesis by SCMPDS_2:58;
  end;
  suppose
    InsCode i = 8;
    then ex a,k1,k2 st i = AddTo(a,k1,k2) by SCMPDS_2:43;
    hence thesis by SCMPDS_2:60;
  end;
  suppose
    InsCode i = 9;
    then ex a,b,k1,k2 st i = AddTo(a,k1,b,k2) by SCMPDS_2:44;
    hence thesis by SCMPDS_2:61;
  end;
  suppose
    InsCode i = 10;
    then ex a,b,k1,k2 st i = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
    hence thesis by SCMPDS_2:62;
  end;
  suppose
    InsCode i = 11;
    then ex a,b,k1,k2 st i = MultBy(a,k1,b,k2) by SCMPDS_2:46;
    hence thesis by SCMPDS_2:63;
  end;
  suppose
    InsCode i = 12;
    then ex a,b,k1,k2 st i = Divide(a,k1,b,k2) by SCMPDS_2:47;
    hence thesis by SCMPDS_2:64;
  end;
  suppose
    InsCode i = 13;
    then ex a,b,k1,k2 st i = (a,k1):=(b,k2) by SCMPDS_2:48;
    hence thesis by SCMPDS_2:59;
  end;
end;

canceled 4;

theorem Th11:
  for s1,s2 being State of SCMPDS st IC s1 = IC s2 & for a being
  Int_position holds s1.a = s2.a holds s1,s2 equal_outside NAT
proof
  set A = NAT;
  let s1,s2 be State of SCMPDS such that
A1: IC s1 = IC s2 and
A2: for a being Int_position holds s1.a = s2.a;
  not IC SCMPDS in A by COMPOS_1:3;
  then {IC SCMPDS} misses A by ZFMISC_1:56;
  then
A3: {IC SCMPDS } \/ SCM-Data-Loc misses A by AMI_2:29,XBOOLE_1:70;
A4: (the carrier of SCMPDS) \ A = {IC SCMPDS } \/ SCM-Data-Loc \ A by
SCMPDS_3:5,XBOOLE_1:40
    .= {IC SCMPDS } \/ SCM-Data-Loc by A3,XBOOLE_1:83;
A5: dom(s2|(dom s2 \ A)) = dom s2 /\ (dom s2 \ A) by RELAT_1:90
    .= dom s2 \ A by XBOOLE_1:28
    .= {IC SCMPDS } \/ SCM-Data-Loc by A4,PARTFUN1:def 4;
A6: dom(s1|(dom s1 \ A)) = dom s1 /\ (dom s1 \ A) by RELAT_1:90
    .= dom s1 \ A by XBOOLE_1:28
    .= {IC SCMPDS } \/ SCM-Data-Loc by A4,PARTFUN1:def 4;
  now
    let x be set;
    assume
A7: x in {IC SCMPDS } \/ SCM-Data-Loc;
    per cases by A7,XBOOLE_0:def 3;
    suppose
      x in {IC SCMPDS};
      then
A8:   x = IC SCMPDS by TARSKI:def 1;
      hence (s1|(dom s1 \ A)).x = IC s1 by A6,A7,FUNCT_1:70
        .= (s2|(dom s2 \ A)).x by A1,A5,A7,A8,FUNCT_1:70;
    end;
    suppose
      x in SCM-Data-Loc;
      then
A9:   x is Int_position by SCMPDS_2:9;
      thus (s1|(dom s1 \ A)).x = s1.x by A6,A7,FUNCT_1:70
        .= s2.x by A2,A9
        .= (s2|(dom s2 \ A)).x by A5,A7,FUNCT_1:70;
    end;
  end;
  hence s1|(dom s1 \ A) = s2|(dom s2 \ A) by A6,A5,FUNCT_1:9;
end;

canceled;

theorem Th13:
  s1,s2 equal_outside NAT implies for a being Int_position holds
  s1.a = s2.a
proof
  assume
A1: s1,s2 equal_outside NAT;
  let a be Int_position;
  a in SCM-Data-Loc by SCMPDS_2:def 2;
  then
A2: not a in NAT by AMI_2:29,XBOOLE_0:3;
  a in dom s2 by SCMPDS_2:49;
  then a in dom s2 \ NAT by A2,XBOOLE_0:def 5;
  then
A3: a in dom s2 /\ (dom s2 \ NAT) by XBOOLE_0:def 4;
  a in dom s1 by SCMPDS_2:49;
  then a in dom s1 \ NAT by A2,XBOOLE_0:def 5;
  then a in dom s1 /\ (dom s1 \ NAT) by XBOOLE_0:def 4;
  hence s1.a = (s1|(dom s1 \ NAT)).a by FUNCT_1:71
    .= (s2|(dom s2 \ NAT)).a by A1,FUNCT_7:def 2
    .= s2.a by A3,FUNCT_1:71;
end;

theorem Th14:
  s1,s2 equal_outside NAT implies s1.DataLoc(s1.a,k1)=s2.DataLoc(
  s2.a,k1)
proof
  assume
A1: s1,s2 equal_outside NAT;
  hence s1.DataLoc(s1.a,k1)=s1.DataLoc(s2.a,k1) by Th13
    .=s2.DataLoc(s2.a,k1) by A1,Th13;
end;

theorem Th15:
  s1,s2 equal_outside NAT implies Exec(i,s1),Exec(i,s2)
  equal_outside NAT
proof
  assume
A1: s1,s2 equal_outside NAT;
  then
A2: IC s1 = IC s2 by COMPOS_1:24;
  per cases by NAT_1:38,SCMPDS_2:15;
  suppose
    InsCode i = 0;
    then consider k1 such that
A3: i = goto k1 by SCMPDS_2:35;
A4: now
      let a;
      thus Exec(i, s1).a = s1.a by A3,SCMPDS_2:66
        .=s2.a by A1,Th13
        .=Exec(i, s2).a by A3,SCMPDS_2:66;
    end;
    IC Exec(i,s1) = ICplusConst(s1,k1) by A3,SCMPDS_2:66
      .= ICplusConst(s2,k1) by A2,SCMPDS_3:2
      .= IC Exec(i,s2) by A3,SCMPDS_2:66;
    hence thesis by A4,Th11;
  end;
  suppose
    InsCode i = 1;
    then consider a such that
A5: i = return a by SCMPDS_2:36;
A6: now
      let b;
      per cases;
      suppose
A7:     a=b;
        hence Exec(i, s1).b= s1.DataLoc(s1.a,RetSP) by A5,SCMPDS_2:70
          .=s2.DataLoc(s2.a,RetSP) by A1,Th14
          .=Exec(i,s2).b by A5,A7,SCMPDS_2:70;
      end;
      suppose
A8:     a<>b;
        hence Exec(i, s1).b = s1.b by A5,SCMPDS_2:70
          .=s2.b by A1,Th13
          .=Exec(i,s2).b by A5,A8,SCMPDS_2:70;
      end;
    end;
    IC Exec(i,s1) = (abs(s1.DataLoc(s1.a,RetIC)))+2 by A5,SCMPDS_2:70
      .= (abs(s1.DataLoc(s2.a,RetIC)))+2 by A1,Th13
      .= (abs(s2.DataLoc(s2.a,RetIC)))+2 by A1,Th13
      .= IC Exec(i,s2) by A5,SCMPDS_2:70;
    hence thesis by A6,Th11;
  end;
  suppose
    InsCode i = 2;
    then consider a,k1 such that
A9: i = a := k1 by SCMPDS_2:37;
A10: now
      let b;
      per cases;
      suppose
A11:    a=b;
        hence Exec(i, s1).b= k1 by A9,SCMPDS_2:57
          .=Exec(i,s2).b by A9,A11,SCMPDS_2:57;
      end;
      suppose
A12:    a<>b;
        hence Exec(i,s1).b = s1.b by A9,SCMPDS_2:57
          .=s2.b by A1,Th13
          .=Exec(i,s2).b by A9,A12,SCMPDS_2:57;
      end;
    end;
    IC Exec(i,s1) = succ IC s2 by A2,A9,SCMPDS_2:57
      .= IC Exec(i,s2) by A9,SCMPDS_2:57;
    hence thesis by A10,Th11;
  end;
  suppose
    InsCode i = 3;
    then consider a,k1 such that
A13: i = saveIC(a,k1) by SCMPDS_2:38;
A14: now
      let b;
      per cases;
      suppose
A15:    b=DataLoc(s1.a,k1);
        then
A16:    b=DataLoc(s2.a,k1) by A1,Th13;
        thus Exec(i, s1).b=IC s2 by A2,A13,A15,SCMPDS_2:71
          .=Exec(i,s2).b by A13,A16,SCMPDS_2:71;
      end;
      suppose
A17:    b<>DataLoc(s1.a,k1);
        then
A18:    b<>DataLoc(s2.a,k1) by A1,Th13;
        thus Exec(i,s1).b = s1.b by A13,A17,SCMPDS_2:71
          .=s2.b by A1,Th13
          .=Exec(i,s2).b by A13,A18,SCMPDS_2:71;
      end;
    end;
    IC Exec(i,s1) = succ IC s2 by A2,A13,SCMPDS_2:71
      .= IC Exec(i,s2) by A13,SCMPDS_2:71;
    hence thesis by A14,Th11;
  end;
  suppose
    InsCode i = 4;
    then consider a,k1,k2 such that
A19: i = (a,k1)<>0_goto k2 by SCMPDS_2:39;
A20: now
      per cases;
      suppose
A21:    s1.DataLoc(s1.a,k1) <> 0;
        then
A22:    s2.DataLoc(s2.a,k1) <> 0 by A1,Th14;
        thus IC Exec(i,s1) = ICplusConst(s1,k2) by A19,A21,SCMPDS_2:67
          .= ICplusConst(s2,k2) by A2,SCMPDS_3:2
          .= IC Exec(i,s2) by A19,A22,SCMPDS_2:67;
      end;
      suppose
A23:    s1.DataLoc(s1.a,k1) = 0;
        then
A24:    s2.DataLoc(s2.a,k1) = 0 by A1,Th14;
        thus IC Exec(i,s1) = succ IC s2 by A2,A19,A23,SCMPDS_2:67
          .= IC Exec(i,s2) by A19,A24,SCMPDS_2:67;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A19,SCMPDS_2:67
        .=s2.a by A1,Th13
        .=Exec(i, s2).a by A19,SCMPDS_2:67;
    end;
    hence thesis by A20,Th11;
  end;
  suppose
    InsCode i = 5;
    then consider a,k1,k2 such that
A25: i = (a,k1)<=0_goto k2 by SCMPDS_2:40;
A26: now
      per cases;
      suppose
A27:    s1.DataLoc(s1.a,k1) <= 0;
        then
A28:    s2.DataLoc(s2.a,k1) <= 0 by A1,Th14;
        thus IC Exec(i,s1) = ICplusConst(s1,k2) by A25,A27,SCMPDS_2:68
          .= ICplusConst(s2,k2) by A2,SCMPDS_3:2
          .= IC Exec(i,s2) by A25,A28,SCMPDS_2:68;
      end;
      suppose
A29:    s1.DataLoc(s1.a,k1) > 0;
        then
A30:    s2.DataLoc(s2.a,k1) > 0 by A1,Th14;
        thus IC Exec(i,s1) = succ IC s2 by A2,A25,A29,SCMPDS_2:68
          .= IC Exec(i,s2) by A25,A30,SCMPDS_2:68;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A25,SCMPDS_2:68
        .=s2.a by A1,Th13
        .=Exec(i, s2).a by A25,SCMPDS_2:68;
    end;
    hence thesis by A26,Th11;
  end;
  suppose
    InsCode i = 6;
    then consider a,k1,k2 such that
A31: i = (a,k1)>=0_goto k2 by SCMPDS_2:41;
A32: now
      per cases;
      suppose
A33:    s1.DataLoc(s1.a,k1) >= 0;
        then
A34:    s2.DataLoc(s2.a,k1) >= 0 by A1,Th14;
        thus IC Exec(i,s1) = ICplusConst(s1,k2) by A31,A33,SCMPDS_2:69
          .= ICplusConst(s2,k2) by A2,SCMPDS_3:2
          .= IC Exec(i,s2) by A31,A34,SCMPDS_2:69;
      end;
      suppose
A35:    s1.DataLoc(s1.a,k1) < 0;
        then
A36:    s2.DataLoc(s2.a,k1) < 0 by A1,Th14;
        thus IC Exec(i,s1) = succ IC s2 by A2,A31,A35,SCMPDS_2:69
          .= IC Exec(i,s2) by A31,A36,SCMPDS_2:69;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A31,SCMPDS_2:69
        .=s2.a by A1,Th13
        .=Exec(i, s2).a by A31,SCMPDS_2:69;
    end;
    hence thesis by A32,Th11;
  end;
  suppose
    InsCode i = 7;
    then consider a,k1,k2 such that
A37: i = (a,k1) := k2 by SCMPDS_2:42;
A38: now
      let b;
      per cases;
      suppose
A39:    DataLoc(s1.a,k1)=b;
        then
A40:    DataLoc(s2.a,k1)=b by A1,Th13;
        thus Exec(i, s1).b= k2 by A37,A39,SCMPDS_2:58
          .=Exec(i,s2).b by A37,A40,SCMPDS_2:58;
      end;
      suppose
A41:    DataLoc(s1.a,k1)<>b;
        then
A42:    DataLoc(s2.a,k1)<>b by A1,Th13;
        thus Exec(i,s1).b = s1.b by A37,A41,SCMPDS_2:58
          .=s2.b by A1,Th13
          .=Exec(i,s2).b by A37,A42,SCMPDS_2:58;
      end;
    end;
    IC Exec(i,s1) = succ IC s2 by A2,A37,SCMPDS_2:58
      .= IC Exec(i,s2) by A37,SCMPDS_2:58;
    hence thesis by A38,Th11;
  end;
  suppose
    InsCode i = 8;
    then consider a,k1,k2 such that
A43: i = AddTo(a,k1,k2) by SCMPDS_2:43;
A44: now
      let b;
      per cases;
      suppose
A45:    DataLoc(s1.a,k1)=b;
        then
A46:    DataLoc(s2.a,k1)=b by A1,Th13;
        thus Exec(i, s1).b= s1.DataLoc(s1.a,k1)+k2 by A43,A45,SCMPDS_2:60
          .= s2.DataLoc(s2.a,k1)+k2 by A1,Th14
          .=Exec(i,s2).b by A43,A46,SCMPDS_2:60;
      end;
      suppose
A47:    DataLoc(s1.a,k1)<>b;
        then
A48:    DataLoc(s2.a,k1)<>b by A1,Th13;
        thus Exec(i,s1).b = s1.b by A43,A47,SCMPDS_2:60
          .=s2.b by A1,Th13
          .=Exec(i,s2).b by A43,A48,SCMPDS_2:60;
      end;
    end;
    IC Exec(i,s1) = succ IC s2 by A2,A43,SCMPDS_2:60
      .= IC Exec(i,s2) by A43,SCMPDS_2:60;
    hence thesis by A44,Th11;
  end;
  suppose
    InsCode i = 9;
    then consider a,b,k1,k2 such that
A49: i = AddTo(a,k1,b,k2) by SCMPDS_2:44;
A50: now
      let c;
      per cases;
      suppose
A51:    DataLoc(s1.a,k1)=c;
        then
A52:    DataLoc(s2.a,k1)=c by A1,Th13;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)+s1.DataLoc(s1.b,k2) by A49,A51
,SCMPDS_2:61
          .= s2.DataLoc(s2.a,k1)+s1.DataLoc(s1.b,k2) by A1,Th14
          .= s2.DataLoc(s2.a,k1)+s2.DataLoc(s2.b,k2) by A1,Th14
          .=Exec(i,s2).c by A49,A52,SCMPDS_2:61;
      end;
      suppose
A53:    DataLoc(s1.a,k1)<>c;
        then
A54:    DataLoc(s2.a,k1)<>c by A1,Th13;
        thus Exec(i,s1).c = s1.c by A49,A53,SCMPDS_2:61
          .=s2.c by A1,Th13
          .=Exec(i,s2).c by A49,A54,SCMPDS_2:61;
      end;
    end;
    IC Exec(i,s1) = succ IC s2 by A2,A49,SCMPDS_2:61
      .= IC Exec(i,s2) by A49,SCMPDS_2:61;
    hence thesis by A50,Th11;
  end;
  suppose
    InsCode i = 10;
    then consider a,b,k1,k2 such that
A55: i = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
A56: now
      let c;
      per cases;
      suppose
A57:    DataLoc(s1.a,k1)=c;
        then
A58:    DataLoc(s2.a,k1)=c by A1,Th13;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)-s1.DataLoc(s1.b,k2) by A55,A57
,SCMPDS_2:62
          .= s2.DataLoc(s2.a,k1)-s1.DataLoc(s1.b,k2) by A1,Th14
          .= s2.DataLoc(s2.a,k1)-s2.DataLoc(s2.b,k2) by A1,Th14
          .=Exec(i,s2).c by A55,A58,SCMPDS_2:62;
      end;
      suppose
A59:    DataLoc(s1.a,k1)<>c;
        then
A60:    DataLoc(s2.a,k1)<>c by A1,Th13;
        thus Exec(i,s1).c = s1.c by A55,A59,SCMPDS_2:62
          .=s2.c by A1,Th13
          .=Exec(i,s2).c by A55,A60,SCMPDS_2:62;
      end;
    end;
    IC Exec(i,s1) = succ IC s2 by A2,A55,SCMPDS_2:62
      .= IC Exec(i,s2) by A55,SCMPDS_2:62;
    hence thesis by A56,Th11;
  end;
  suppose
    InsCode i = 11;
    then consider a,b,k1,k2 such that
A61: i = MultBy(a,k1,b,k2) by SCMPDS_2:46;
A62: now
      let c;
      per cases;
      suppose
A63:    DataLoc(s1.a,k1)=c;
        then
A64:    DataLoc(s2.a,k1)=c by A1,Th13;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)*s1.DataLoc(s1.b,k2) by A61,A63
,SCMPDS_2:63
          .= s2.DataLoc(s2.a,k1)*s1.DataLoc(s1.b,k2) by A1,Th14
          .= s2.DataLoc(s2.a,k1)*s2.DataLoc(s2.b,k2) by A1,Th14
          .=Exec(i,s2).c by A61,A64,SCMPDS_2:63;
      end;
      suppose
A65:    DataLoc(s1.a,k1)<>c;
        then
A66:    DataLoc(s2.a,k1)<>c by A1,Th13;
        thus Exec(i,s1).c = s1.c by A61,A65,SCMPDS_2:63
          .=s2.c by A1,Th13
          .=Exec(i,s2).c by A61,A66,SCMPDS_2:63;
      end;
    end;
    IC Exec(i,s1) = succ IC s2 by A2,A61,SCMPDS_2:63
      .= IC Exec(i,s2) by A61,SCMPDS_2:63;
    hence thesis by A62,Th11;
  end;
  suppose
    InsCode i = 12;
    then consider a,b,k1,k2 such that
A67: i = Divide(a,k1,b,k2) by SCMPDS_2:47;
A68: now
      let c;
      per cases;
      suppose
A69:    DataLoc(s1.b,k2)=c;
        then
A70:    DataLoc(s2.b,k2)=c by A1,Th13;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) mod s1.DataLoc(s1.b,k2) by A67
,A69,SCMPDS_2:64
          .= s2.DataLoc(s2.a,k1) mod s1.DataLoc(s1.b,k2) by A1,Th14
          .= s2.DataLoc(s2.a,k1) mod s2.DataLoc(s2.b,k2) by A1,Th14
          .= Exec(i,s2).c by A67,A70,SCMPDS_2:64;
      end;
      suppose
A71:    DataLoc(s1.b,k2)<>c;
        then
A72:    DataLoc(s2.b,k2)<>c by A1,Th13;
        hereby
          per cases;
          suppose
A73:        DataLoc(s1.a,k1)<>c;
            then
A74:        DataLoc(s2.a,k1)<>c by A1,Th13;
            thus Exec(i, s1).c = s1.c by A67,A71,A73,SCMPDS_2:64
              .=s2.c by A1,Th13
              .=Exec(i,s2).c by A67,A72,A74,SCMPDS_2:64;
          end;
          suppose
A75:        DataLoc(s1.a,k1)=c;
            then
A76:        DataLoc(s2.a,k1)=c by A1,Th13;
            thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) div s1.DataLoc(s1.b,k2)
            by A67,A71,A75,SCMPDS_2:64
              .= s2.DataLoc(s2.a,k1) div s1.DataLoc(s1.b,k2) by A1,Th14
              .= s2.DataLoc(s2.a,k1) div s2.DataLoc(s2.b,k2) by A1,Th14
              .= Exec(i,s2).c by A67,A72,A76,SCMPDS_2:64;
          end;
        end;
      end;
    end;
    IC Exec(i,s1) = succ IC s2 by A2,A67,SCMPDS_2:64
      .= IC Exec(i,s2) by A67,SCMPDS_2:64;
    hence thesis by A68,Th11;
  end;
  suppose
    InsCode i = 13;
    then consider a,b,k1,k2 such that
A77: i = (a,k1):=(b,k2) by SCMPDS_2:48;
A78: now
      let c;
      per cases;
      suppose
A79:    DataLoc(s1.a,k1)=c;
        then
A80:    DataLoc(s2.a,k1)=c by A1,Th13;
        thus Exec(i, s1).c = s1.DataLoc(s1.b,k2) by A77,A79,SCMPDS_2:59
          .= s2.DataLoc(s2.b,k2) by A1,Th14
          .=Exec(i,s2).c by A77,A80,SCMPDS_2:59;
      end;
      suppose
A81:    DataLoc(s1.a,k1)<>c;
        then
A82:    DataLoc(s2.a,k1)<>c by A1,Th13;
        thus Exec(i,s1).c = s1.c by A77,A81,SCMPDS_2:59
          .=s2.c by A1,Th13
          .=Exec(i,s2).c by A77,A82,SCMPDS_2:59;
      end;
    end;
    IC Exec(i,s1) = succ IC s2 by A2,A77,SCMPDS_2:59
      .= IC Exec(i,s2) by A77,SCMPDS_2:59;
    hence thesis by A78,Th11;
  end;
end;

canceled;

theorem Th17:
  for k1,k2 be Element of NAT st k1 <> k2 holds DataLoc(k1,0) <>
  DataLoc(k2,0)
proof
  let k1,k2 be Element of NAT;
  assume
A1: k1<>k2;
  assume
  DataLoc(k1,0) = DataLoc(k2,0);
  then abs(k1+0) =abs(k2+0) by ZFMISC_1:33;
  then k1=abs(k2) by ABSVALUE:def 1;
  hence contradiction by A1,ABSVALUE:def 1;
end;

theorem Th18:
  for dl being Int_position ex i being Element of NAT st dl =
  DataLoc(i,0)
proof
  let dl be Int_position;
  dl in SCM-Data-Loc by SCMPDS_2:def 2;
  then consider i being Element of NAT such that
A1: dl = [1,i] by AMI_2:32;
  take i;
  thus thesis by A1,ABSVALUE:def 1;
end;

scheme
  SCMPDSEx{ F(set) -> Instruction of SCMPDS, G(set) -> Integer, I() ->
  Element of NAT }: ex S being State of SCMPDS st IC S = I() &
  for i being Element of NAT holds S. i = F(i) & S.DataLoc(i,0) = G(i)
proof
  set S1={IC SCMPDS }, S2=SCM-Data-Loc, S3=NAT;
  defpred P[set,set] means ex m st $1 = IC SCMPDS & $2 = I() or $1 =  m
  & $2 = F(m) or $1 = DataLoc(m,0) & $2 = G(m);
A1: for e being set st e in the carrier of SCMPDS ex u being set st P[e,u]
  proof
    let e be set;
    assume
    e in the carrier of SCMPDS;
    then
A2: e in S1 \/ S2 or e in S3 by SCMPDS_3:5,XBOOLE_0:def 3;
    now
      per cases by A2,XBOOLE_0:def 3;
      case
        e in S1;
        hence e = IC SCMPDS by TARSKI:def 1;
      end;
      case
        e in S2;
        then e is Int_position by SCMPDS_2:9;
        hence ex m st e = DataLoc(m,0) by Th18;
      end;
      case
        e in S3;
        then reconsider l=e as Element of NAT;
        reconsider m = l as Element of NAT;
        e =  m;
        hence ex m st e =  m;
      end;
    end;
    then consider m such that
A3: e = IC SCMPDS or e =  m or e = DataLoc(m,0);
    per cases by A3;
    suppose
A4:   e = IC SCMPDS;
      take u = I();
      thus thesis by A4;
    end;
    suppose
A5:   e =  m;
      take u = F(m);
      thus thesis by A5;
    end;
    suppose
A6:   e = DataLoc(m,0);
      take u = G(m);
      thus thesis by A6;
    end;
  end;
  consider f being Function such that
A7: dom f = the carrier of SCMPDS and
A8: for e being set st e in the carrier of SCMPDS holds P[e,f.e] from
  CLASSES1:sch 1(A1);
A9: dom the Object-Kind of SCMPDS = the carrier of SCMPDS by FUNCT_2:def 1;
  now
    let x be set;
    assume
A10: x in dom the Object-Kind of SCMPDS;
    then
A11: x in S1 \/ S2 or x in S3 by A9,SCMPDS_3:5,XBOOLE_0:def 3;
    consider m such that
A12: x = IC SCMPDS & f.x = I() or x =  m & f.x = F(m) or x =
    DataLoc(m,0) & f.x = G(m) by A8,A9,A10;
    per cases by A11,XBOOLE_0:def 3;
    suppose
      x in S2;
      then
A13:  x is Int_position by SCMPDS_2:9;
      then (the Object-Kind of SCMPDS).x = ObjectKind DataLoc(m,0) by A12,
SCMPDS_2:52,53
        .= INT by SCMPDS_2:13;
      hence f.x in (the Object-Kind of SCMPDS).x by A12,A13,INT_1:def 2
,SCMPDS_2:53;
    end;
    suppose
A14:  x in S1;
      then (the Object-Kind of SCMPDS).x = ObjectKind IC SCMPDS by TARSKI:def 1
        .= NAT by COMPOS_1:def 6;
      hence f.x in (the Object-Kind of SCMPDS).x by A12,A14,SCMPDS_2:6
,TARSKI:def 1;
    end;
    suppose
      x in NAT;
      then reconsider l=x as Element of NAT;
      (the Object-Kind of SCMPDS).l
        = the Instructions of SCMPDS
        by COMPOS_1:def 8;
      hence f.x in (the Object-Kind of SCMPDS).x by A12,COMPOS_1:3,SCMPDS_2:53;
    end;
  end;
  then reconsider f as State of SCMPDS by A7,A9,FUNCT_1:def 20,PARTFUN1:def 4
,RELAT_1:def 18;
  consider m such that
A15: IC SCMPDS = IC SCMPDS & f.IC SCMPDS = I() or IC SCMPDS =  m &
  f.IC SCMPDS = F(m) or IC SCMPDS = DataLoc(m,0) & f.IC SCMPDS = G(m) by A8;
  take f;
  thus IC f = I() by A15,SCMPDS_2:52,98;
  let i be Element of NAT;
  ex m st (  i = IC SCMPDS & f. i = I() or  i =  m
  & f. i = F(m) or  i = DataLoc(m,0) & f. i = G(m) ) by A8;
  hence f. i = F(i) by SCMPDS_2:53,98;
  ex m st ( DataLoc(i,0) = IC SCMPDS & f.DataLoc(i,0) = I() or DataLoc(i,0
) =  m & f.DataLoc(i,0) = F(m) or DataLoc(i,0) = DataLoc(m,0) & f.DataLoc
  (i,0) = G(m)) by A8;
  hence thesis by Th17,SCMPDS_2:52,53;
end;

theorem
  for s being State of SCMPDS holds dom s = {IC SCMPDS} \/ SCM-Data-Loc
  \/ NAT by PARTFUN1:def 4,SCMPDS_3:5;

theorem
  for s being State of SCMPDS, x being set st x in dom s holds x is
  Int_position or x = IC SCMPDS or x is Element of NAT
proof
  set S1={IC SCMPDS}, S2=SCM-Data-Loc, S3=NAT;
  let s be State of SCMPDS;
  let x be set;
  assume
A1: x in dom s;
  dom s = S1 \/ S2 \/ S3 by PARTFUN1:def 4,SCMPDS_3:5;
  then x in S1 \/ S2 or x in S3 by A1,XBOOLE_0:def 3;
  then x in S1 or x in S2 or x in S3 by XBOOLE_0:def 3;
  hence thesis by SCMPDS_2:9,TARSKI:def 1;
end;

canceled;

theorem
  for i being Element of NAT holds not i in SCM-Data-Loc
    by AMI_2:29,XBOOLE_0:3;

theorem Th23:
  for s1,s2 being State of SCMPDS holds (for a being Int_position
  holds s1.a = s2.a) iff DataPart s1 = DataPart s2
proof
  set T1={IC SCMPDS}, T2=SCM-Data-Loc, T3=NAT;
  let s1,s2 be State of SCMPDS;
A1: T1 \/ T2 \/ T3=T2 \/ (T1 \/ T3) by XBOOLE_1:4;
A2: now
    assume
A3: for a being Int_position holds s1.a = s2.a;
    hereby
      let x be set;
      assume
      x in SCM-Data-Loc;
      then x is Int_position by SCMPDS_2:9;
      hence s1.x=s2.x by A3;
    end;
  end;
A4: now
    assume
A5: for x be set st x in SCM-Data-Loc holds s1.x = s2.x;
    hereby
      let a be Int_position;
      a in SCM-Data-Loc by SCMPDS_2:def 2;
      hence s1.a=s2.a by A5;
    end;
  end;
  dom s2 = T1 \/ T2 \/ T3 by PARTFUN1:def 4,SCMPDS_3:5;
  then
A6: T2 c= dom s2 by A1,XBOOLE_1:7;
  dom s1 = T1 \/ T2 \/ T3 by PARTFUN1:def 4,SCMPDS_3:5;
  then T2 c= dom s1 by A1,XBOOLE_1:7;
  hence thesis by A6,A2,A4,FUNCT_1:165,SCMPDS_2:100;
end;

canceled 7;

theorem
  for I being Program of SCMPDS, a being Int_position holds not a
  in dom Initialize I
proof
  let I be Program of SCMPDS;
  let a be Int_position;
  assume
  a in dom Initialize I;
  then
A1: a in dom I \/ {IC SCMPDS} by COMPOS_1:76;
  per cases by A1,XBOOLE_0:def 3;
  suppose
A2: a in dom I;
    reconsider l=a as Element of NAT by A2;
    l=a;
    hence contradiction by SCMPDS_2:53;
  end;
  suppose
    a in {IC SCMPDS};
    then a = IC SCMPDS by TARSKI:def 1;
    hence contradiction by SCMPDS_2:52;
  end;
end;

reserve x for set;

begin :: Combining two consecutive blocks into one program block

notation
  let I,J be Program of SCMPDS;
  synonym I ';' J for I ^ J;
end;

definition
 canceled 2;
  let I,J be Program of SCMPDS;
  redefine func I ';' J -> Program of SCMPDS equals
  I +* Shift(J, card I);
  compatibility by AFINSQ_1:81;
  coherence;
end;

begin :: Combining a block and a instruction into one program block

definition
  let i, J;
  func i ';' J -> Program of SCMPDS equals
  Load i ';' J;
  correctness;
end;

definition
  let I, j;
  func I ';' j -> Program of SCMPDS equals
  I ';' Load j;
  correctness;
end;

definition
  let i,j;
  func i ';' j -> Program of SCMPDS equals
  Load i ';' Load j;
  correctness;
end;

canceled 11;

theorem
  i ';' j = Load i ';' j;

theorem
  i ';' j = i ';' Load j;

canceled 2;

theorem
  I ';' J ';' k = I ';' (J ';' k) by AFINSQ_1:30;

theorem
  I ';' j ';' K = I ';' (j ';' K) by AFINSQ_1:30;

theorem
  I ';' j ';' k = I ';' (j ';' k) by AFINSQ_1:30;

theorem
  i ';' J ';' K = i ';' (J ';' K) by AFINSQ_1:30;

theorem
  i ';' J ';' k = i ';' (J ';' k) by AFINSQ_1:30;

theorem
  i ';' j ';' K = i ';' (j ';' K) by AFINSQ_1:30;

theorem
  i ';' j ';' k = i ';' (j ';' k) by AFINSQ_1:30;

canceled 5;

reserve l,l1,loc for Element of NAT;

theorem Th59:
  not a in dom Start-At(l,SCMPDS)
proof
A1: dom Start-At(l,SCMPDS) = {IC SCMPDS} by FUNCOP_1:19;
  assume
  a in dom Start-At(l,SCMPDS);
  then a = IC SCMPDS by A1,TARSKI:def 1;
  hence contradiction by SCMPDS_2:52;
end;

canceled;

theorem
  not a in dom (I+*Start-At(l,SCMPDS))
proof
  assume
  a in dom (I+*Start-At(l,SCMPDS));
  then a in dom I \/ dom Start-At(l,SCMPDS) by FUNCT_4:def 1;
  then
A1: a in dom I or a in dom Start-At(l,SCMPDS) by XBOOLE_0:def 3;
  dom I c= NAT & a in SCM-Data-Loc by SCMPDS_2:def 2;
  hence contradiction by A1,Th59,AMI_2:29,XBOOLE_0:3;
end;

definition
  let s be State of SCMPDS, li be Int_position, k be Integer;
  redefine func s+*(li,k) -> PartState of SCMPDS;
  coherence
  proof
A1: dom s = the carrier of SCMPDS by PARTFUN1:def 4;
    now
      let x be set;
      assume x in dom(s+*(li,k));
      then
X:    x in dom s by A1,PARTFUN1:def 4;
      per cases;
      suppose
A4:     x = li;
        then
A5:     (the Object-Kind of SCMPDS).x = ObjectKind li
          .= INT by SCMPDS_2:13;
        (s+*(li,k)).x = k by A1,A4,FUNCT_7:33;
        hence (s+*(li,k)).x in (the Object-Kind of SCMPDS).x by A5,INT_1:def 2;
      end;
      suppose
        x <> li;
        then (s+*(li,k)).x = s.x by FUNCT_7:34;
        hence (s+*(li,k)).x in (the Object-Kind of SCMPDS).x
         by X,FUNCT_1:def 20;
      end;
    end;
    hence thesis by FUNCT_1:def 20;
  end;
end;

begin :: The notions of paraclosed,parahalting and their basic properties

registration
  let s be State of SCMPDS;
  cluster Initialize s -> total;
  coherence;
end;

definition
 canceled;
  let I be Program of SCMPDS, s be State of SCMPDS;
  func IExec(I,s) -> State of SCMPDS equals
  Result(ProgramPart(Initialize s+*stop(I)),Initialize s+*stop(I)) +*
  s|NAT;
  coherence;
end;

definition
  let I be Program of SCMPDS;
  attr I is paraclosed means
  :Def9:
  for s being 0-started State of SCMPDS, n being Element of NAT
   st stop(I) c= s
   holds IC Comput(ProgramPart(s),s,n) in dom stop(I);
  attr I is parahalting means
  :Def10:
  for s being 0-started State of SCMPDS st stop(I) c= s
    holds ProgramPart s halts_on s;
end;

Lm1: Load halt SCMPDS is parahalting
proof
  let s be 0-started State of SCMPDS;
  set m = Load halt SCMPDS, m0= stop (m);
  assume
A1: m0 c= s;
A4: IC s = 0 by COMPOS_1:def 16;
  take 0;
     IC Comput(ProgramPart(s),s,0) in NAT;
    hence IC Comput(ProgramPart(s),s,0) in dom ProgramPart s by COMPOS_1:34;
A5: m. 0 = halt SCMPDS by FUNCOP_1:87;
  dom m={ 0} by FUNCOP_1:19;
  then
A7:  0 in dom m by TARSKI:def 1;
  then
A8:  0 in dom m0 by FUNCT_4:13;
u: Comput(ProgramPart(s),s,0) = s by EXTPRO_1:3;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
   CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,0))
     = m0. 0 by A1,A8,A4,Y,u,GRFUNC_1:8
    .= halt SCMPDS by A5,A7,AFINSQ_1:def 4;
  hence thesis;
end;

registration
  cluster parahalting Program of SCMPDS;
  existence by Lm1;
end;

definition
  let la,lb be Element of NAT;
  let a, b be Instruction of SCMPDS;
  redefine func (la,lb) --> (a,b) -> FinPartState of SCMPDS;
  coherence
  proof
     (la,lb) --> (a,b) = (la .--> a) +* (lb .--> b) by FUNCT_4:def 4;
    hence thesis;
  end;
end;

canceled 4;

theorem Th66:
  not ProgramPart(s2 +*((IC s2,succ IC s2) --> (goto 1, goto -1)))
    halts_on s2 +*((IC s2,succ IC s2) --> (goto 1, goto -1))
proof
  set m=(IC s2,succ IC s2) --> (goto 1, goto -1), s1 = s2 +* m;
A1: m.(succ IC s2)=goto -1 by FUNCT_4:66;
  IC s2<>succ IC s2;
  then
A2: m.(IC s2) = goto 1 by FUNCT_4:66;
  defpred X[Nat] means IC(Comput(ProgramPart(s1),s1,$1)) = IC s1 or IC(Comput(
ProgramPart(s1),s1,$1)
  ) = succ IC s1;
A3: dom m = {IC s2,succ IC s2} by FUNCT_4:65;
  then
A4: succ IC s2 in dom m by TARSKI:def 2;
  IC SCMPDS <> IC s2 & IC SCMPDS <> succ IC s2 by COMPOS_1:3;
  then not IC SCMPDS in dom m by A3,TARSKI:def 2;
  then
A5: IC s1 = IC s2 by FUNCT_4:12;
A6: IC s2 in dom m by A3,TARSKI:def 2;
  now
    let n;
    set Cn=Comput(ProgramPart(s1),s1,n);
    assume
A7: IC Cn = IC s1 or IC Cn = succ IC s1;
Y:  (ProgramPart Cn)/.IC Cn
 = Cn.IC Cn by COMPOS_1:38;
    per cases by A7;
    case
A8:   IC Cn = IC s1;
      then
A9:   CurInstr(ProgramPart Cn,Cn) = s1.IC s1 by Y,AMI_1:54
        .= goto 1 by A6,A2,A5,FUNCT_4:14;
T: ProgramPart s1 = ProgramPart Cn
by AMI_1:123;
      thus IC (Comput(ProgramPart(s1),s1,n+1)) = IC Following(ProgramPart s1,Cn
)
      by EXTPRO_1:4
        .= ICplusConst(Cn,1) by A9,T,SCMPDS_2:66
        .= succ IC s1 by A8,SCMPDS_3:20;
    end;
    case
A10:  IC Cn = succ IC s1;
      reconsider i = IC s1 as Element of NAT;
A11:  ex j be Element of NAT st j = IC Cn & ICplusConst(Cn,-1) =abs(j+(-1)
      ) by SCMPDS_2:def 20;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,n))/.IC Comput(ProgramPart(s1),s1,n)
 = Comput(ProgramPart(s1),s1,n).IC Comput(ProgramPart(s1),s1,n) by COMPOS_1:38;
A12:  CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(s1),
s1,n))
 = s1.(succ IC s1) by A10,Y,AMI_1:54
        .= goto -1 by A4,A1,A5,FUNCT_4:14;
T: ProgramPart s1 = ProgramPart Cn
by AMI_1:123;
      thus IC(Comput(ProgramPart(s1),s1,n+1)) = IC Following(ProgramPart s1,Cn)
       by EXTPRO_1:4
        .=abs(i+4 + -4 ) by A10,A12,A11,T,SCMPDS_2:66
        .=IC s1 by ABSVALUE:def 1;
    end;
  end;
  then
A13: for n st X[n] holds X[n+1];
  let nn be Nat;
   reconsider n=nn as Element of NAT by ORDINAL1:def 13;
  assume IC Comput(ProgramPart(s1),s1,nn) in dom ProgramPart s1;
A14: X[0] by EXTPRO_1:3;
A15: for n holds X[n] from NAT_1:sch 1(A14,A13);
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,n)
by AMI_1:123;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,n))/.IC Comput(ProgramPart(s1),s1,n)
 = Comput(ProgramPart(s1),s1,n).IC Comput(ProgramPart(s1),s1,n) by COMPOS_1:38;
  per cases by A15;
  suppose
    IC(Comput(ProgramPart(s1),s1,n)) = IC s1;
    then CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(
s1),s1,n))
     = s1.IC s1 by Y,AMI_1:54
      .= goto 1 by A6,A2,A5,FUNCT_4:14;
   hence thesis by T,SCMPDS_2:85;
  end;
  suppose
    IC(Comput(ProgramPart(s1),s1,n)) = succ IC s1;
    then CurInstr(ProgramPart Comput(ProgramPart(s1),s1,n),Comput(ProgramPart(
s1),s1,n))
     = s1.succ IC s1 by Y,AMI_1:54
      .= goto -1 by A4,A1,A5,FUNCT_4:14;
    hence thesis by T,SCMPDS_2:85;
  end;
end;

theorem Th67:
  s1,s2 equal_outside NAT & I c= s1 & I c= s2 & (for m st m < n
  holds IC (Comput(ProgramPart(s2),s2,m)) in dom I) implies for m st m <= n
holds
  Comput(ProgramPart(s1),s1,m), Comput(ProgramPart(s2),s2,m) equal_outside NAT
proof
  assume that
A1: s1,s2 equal_outside NAT and
A2: I c= s1 and
A3: I c= s2 and
A4: for m st m < n holds IC(Comput(ProgramPart(s2),s2,m)) in dom I;
  defpred X[Nat] means $1 <= n implies Comput(ProgramPart(s1),s1,$1), Comput(
ProgramPart(s2),s2,$1)
  equal_outside NAT;
A5: for m st X[m] holds X[m+1]
  proof
    let m such that
A6: m <= n implies Comput(ProgramPart(s1),s1,m), Comput(ProgramPart(s2),s2,m)
equal_outside
    NAT;
A7: Comput(ProgramPart(s2),s2,m+1) =
Following(ProgramPart s2,Comput(ProgramPart(s2),s2,m)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,m),Comput(
ProgramPart(s2),s2,m)),
      Comput(ProgramPart(s2),s2,m)) by AMI_1:123;
A8: Comput(ProgramPart(s1),s1,m+1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,m)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(
ProgramPart(s1),s1,m)),
      Comput(ProgramPart(s1),s1,m)) by AMI_1:123;
    assume
A9: m+1 <= n;
    then
A10: IC (Comput(ProgramPart(s1),s1,m)) = IC (Comput(ProgramPart(s2),s2,m)) by
A6,COMPOS_1:24,NAT_1:13;
    m < n by A9,NAT_1:13;
    then
A11: IC(Comput(ProgramPart(s2),s2,m)) in dom I by A4;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,m))/.IC Comput(ProgramPart(s1),s1,m)
 = Comput(ProgramPart(s1),s1,m).IC Comput(ProgramPart(s1),s1,m) by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s2),s2,m))/.IC Comput(ProgramPart(s2),s2,m)
 = Comput(ProgramPart(s2),s2,m).IC Comput(ProgramPart(s2),s2,m) by COMPOS_1:38;
    CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(ProgramPart(s1),s1
,m))
     = s1.IC(Comput(ProgramPart(s1),s1,m)) by Y,AMI_1:54
      .= I.IC(Comput(ProgramPart(s1),s1,m)) by A2,A11,A10,GRFUNC_1:8
      .= s2.IC(Comput(ProgramPart(s2),s2,m)) by A3,A11,A10,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,m),Comput(ProgramPart(
s2),s2,m))
       by Z,AMI_1:54;
    hence thesis by A6,A8,A7,A9,Th15,NAT_1:13;
  end;
  Comput(ProgramPart(s1),s1,0) = s1 by EXTPRO_1:3;
  then
A12: X[0] by A1,EXTPRO_1:3;
  thus for m holds X[m] from NAT_1:sch 1(A12,A5);
end;

reserve l1,l2 for Element of NAT,
  i1,i2 for Instruction of
  SCMPDS;

registration
  cluster parahalting -> paraclosed Program of SCMPDS;
  coherence
  proof
    let I be Program of SCMPDS;
    assume
A1: I is parahalting;
    set IAt = stop(I) +* Start-At( 0,SCMPDS);
    let s be 0-started State of SCMPDS, n be Element of NAT;
    defpred X[Nat] means not IC Comput(ProgramPart(s),s,$1) in dom stop(I);
    assume
A3: stop(I) c= s;
    assume
    not IC Comput(ProgramPart(s),s,n) in dom stop(I);
    then
A5: ex n be Nat st X[n];
    consider n be Nat such that
A6: X[n] and
A7: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A5);
    reconsider n as Element of NAT by ORDINAL1:def 13;
A8: for m st m < n holds IC(Comput(ProgramPart(s),s,m)) in dom stop I by A7;
    set s2 = Comput(ProgramPart(s),s,n),
        Ig = ((IC s2,succ IC s2) --> (goto 1,goto -1)),
        s0 = s +* Ig, s1 = s2 +* Ig, t1= s +* (IC s2,goto 1),
    t2= t1 +* (succ IC s2,goto -1),
    t3= s2 +* (IC s2,goto 1), t4= t3 +* (succ IC s2,goto -1);
    ProgramPart s = ProgramPart s2 by AMI_1:123;
    then ProgramPart t1 = ProgramPart t3 by FUNCT_7:95;
    then ProgramPart t2 = ProgramPart t4 by FUNCT_7:95;
    then ProgramPart s0 = ProgramPart t4 by COMPOS_1:134;
    then ProgramPart s0 = ProgramPart s1 by COMPOS_1:134;
    then
A10: ProgramPart Comput(ProgramPart(s0),s0,n) = ProgramPart s1 by AMI_1:123;
A11: t1,t2 equal_outside NAT by FUNCT_7:93;
A12: not succ IC s2 in dom stop I by A6,AFINSQ_1:77;
A13: t3,t4 equal_outside NAT by FUNCT_7:93;
    s2,t3 equal_outside NAT by FUNCT_7:93;
    then s2,t4 equal_outside NAT by A13,FUNCT_7:29;
    then
A15: s2,s1 equal_outside NAT by COMPOS_1:134;
    s,t1 equal_outside NAT by FUNCT_7:93;
    then s,t2 equal_outside NAT by A11,FUNCT_7:29;
    then s,s0 equal_outside NAT by COMPOS_1:134;
    then
A16: s0,s equal_outside NAT by FUNCT_7:28;
    stop I c= t1 by A3,A6,FUNCT_7:91;
    then stop I c= t2 by A12,FUNCT_7:91;
    then
A17:    stop I c= s0 by COMPOS_1:134;
    then Comput(ProgramPart(s0),s0,n),s2 equal_outside NAT by A16,A3,A8,Th67;
    then Comput(ProgramPart(s0),s0,n),s1 equal_outside NAT by A15,FUNCT_7:29;
    then
A18: Comput(ProgramPart(s0),s0,n) = s1 by A10,FUNCT_7:92;
A19: not ProgramPart s1 halts_on s1 by Th66;
    ProgramPart s0 halts_on s0 by A1,A17,Def10;
    then ProgramPart s0 halts_on Comput(ProgramPart(s0),s0,n) by EXTPRO_1:22;
    hence contradiction by A18,A19,AMI_1:123;
  end;
end;

begin :: Shiftability of program blocks and instructions

definition
  let i be Instruction of SCMPDS;
  let n be Element of NAT;
  pred i valid_at n means
  :Def11:
  (InsCode i= 0 implies ex k1 st i = goto k1 &
  n+k1 >= 0) & (InsCode i= 4 implies ex a,k1,k2 st i = (a,k1)<>0_goto k2 & n+k2
>= 0 ) & (InsCode i= 5 implies ex a,k1,k2 st i = (a,k1)<=0_goto k2 & n+k2 >= 0
  ) & (InsCode i= 6 implies ex a,k1,k2 st i = (a,k1)>=0_goto k2 & n+k2 >= 0);
end;

reserve l for Element of NAT;

definition
  let IT be FinPartState of SCMPDS;
  attr IT is shiftable means
  :Def12:
  for n,i st  n in dom IT & i=IT.(n)
   holds InsCode i <> 1 & InsCode i <> 3 & i valid_at n;
end;

Lm2: Load halt SCMPDS is shiftable
proof
  set m = Load halt SCMPDS;
A1: m. 0 = halt SCMPDS by FUNCOP_1:87;
A2: dom m={ 0} by FUNCOP_1:19;
  now
    let n,i;
    assume that
A3:  n in dom m and
A4: i=m.( n);
A5:  n=  0 by A2,A3,TARSKI:def 1;
    hence InsCode i <> 1 by A1,A4,SCMPDS_2:21,93;
A6: ex k1 st i = goto k1 & n+k1 >= 0
    proof
      take 0;
      thus i=goto 0 by A4,A5,FUNCOP_1:87,SCMPDS_2:93;
      thus n+0>=0;
    end;
    thus InsCode i <> 3 by A1,A4,A5,SCMPDS_2:21,93;
    InsCode i =0 by A1,A4,A5,SCMPDS_2:21,93;
    hence i valid_at n by A6,Def11;
  end;
  hence thesis by Def12;
end;

canceled 9;

theorem Th77:
  for i be Instruction of SCMPDS,m,n be Element of NAT st i
  valid_at m & m <= n holds i valid_at n
proof
  let i be Instruction of SCMPDS,m,n be Element of NAT;
  assume that
A1: i valid_at m and
A2: m <= n;
A3: now
    assume
    InsCode i= 4;
    then consider a,k1,k2 such that
A4: i = (a,k1)<>0_goto k2 and
A5: m+k2 >= 0 by A1,Def11;
    take a,k1,k2;
    thus i = (a,k1)<>0_goto k2 by A4;
    thus n+k2 >= 0 by A2,A5,XREAL_1:8;
  end;
A6: now
    assume
    InsCode i= 6;
    then consider a,k1,k2 such that
A7: i = (a,k1)>=0_goto k2 and
A8: m+k2 >= 0 by A1,Def11;
    take a,k1,k2;
    thus i = (a,k1)>=0_goto k2 by A7;
    thus n+k2 >= 0 by A2,A8,XREAL_1:8;
  end;
A9: now
    assume
    InsCode i= 5;
    then consider a,k1,k2 such that
A10: i = (a,k1)<=0_goto k2 and
A11: m+k2 >= 0 by A1,Def11;
    take a,k1,k2;
    thus i = (a,k1)<=0_goto k2 by A10;
    thus n+k2 >= 0 by A2,A11,XREAL_1:8;
  end;
  now
    assume
    InsCode i= 0;
    then consider k1 such that
A12: i=goto k1 and
A13: m+k1 >= 0 by A1,Def11;
    take k1;
    thus i=goto k1 by A12;
    thus n+k1 >= 0 by A2,A13,XREAL_1:8;
  end;
  hence thesis by A3,A9,A6,Def11;
end;

registration
  cluster parahalting shiftable Program of SCMPDS;
  existence by Lm1,Lm2;
end;

definition
  let i be Instruction of SCMPDS;
  attr i is shiftable means
  :Def13:
  InsCode i = 2 or InsCode i > 6;
end;

registration
  cluster shiftable Instruction of SCMPDS;
  existence
  proof
    take i=DataLoc(0,0):=1;
    InsCode i=2 by SCMPDS_2:23;
    hence thesis by Def13;
  end;
end;

registration
  let a,k1;
  cluster a := k1 -> shiftable;
  coherence
  proof
    InsCode (a:=k1)=2 by SCMPDS_2:23;
    hence thesis by Def13;
  end;
end;

registration
  let a,k1,k2;
  cluster (a,k1) := k2 -> shiftable;
  coherence
  proof
    InsCode ((a,k1) := k2)=7 by SCMPDS_2:28;
    hence thesis by Def13;
  end;
end;

registration
  let a,k1,k2;
  cluster AddTo(a,k1,k2) -> shiftable;
  coherence
  proof
    InsCode AddTo(a,k1,k2)=8 by SCMPDS_2:29;
    hence thesis by Def13;
  end;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> shiftable;
  coherence
  proof
    InsCode AddTo(a,k1,b,k2)=9 by SCMPDS_2:30;
    hence thesis by Def13;
  end;
  cluster SubFrom(a,k1,b,k2) -> shiftable;
  coherence
  proof
    InsCode SubFrom(a,k1,b,k2)=10 by SCMPDS_2:31;
    hence thesis by Def13;
  end;
  cluster MultBy(a,k1,b,k2) -> shiftable;
  coherence
  proof
    InsCode MultBy(a,k1,b,k2)=11 by SCMPDS_2:32;
    hence thesis by Def13;
  end;
  cluster Divide(a,k1,b,k2) -> shiftable;
  coherence
  proof
    InsCode Divide(a,k1,b,k2)=12 by SCMPDS_2:33;
    hence thesis by Def13;
  end;
  cluster (a,k1) := (b,k2) -> shiftable;
  coherence
  proof
    InsCode (a,k1) := (b,k2)=13 by SCMPDS_2:34;
    hence thesis by Def13;
  end;
end;

registration
  let I,J be shiftable Program of SCMPDS;
  cluster I ';' J -> shiftable Program of SCMPDS;
  coherence
  proof
    set IJ=I ';' J;
    now
      set D = {l+card I: l in dom J };
      let n,i such that
A1:    n in dom IJ and
A2:   i=IJ.( n);
      dom Shift(J,card I) = D by VALUED_1:def 12;
      then
A3:   dom IJ = dom I \/ D by FUNCT_4:def 1;
      per cases by A1,A3,XBOOLE_0:def 3;
      suppose
A4:      n in dom I;
        then I. n=i by A2,AFINSQ_1:def 4;
        hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A4,Def12;
      end;
      suppose
         n in D;
        then consider l such that
A5:     n = l+card I and
A6:     l in dom J;
A7:     J. l =i by A2,A5,A6,AFINSQ_1:def 4;
        hence InsCode i <> 1 & InsCode i <> 3 by A6,Def12;
        i valid_at l by A6,A7,Def12;
        hence i valid_at n by A5,Th77,NAT_1:11;
      end;
    end;
    hence thesis by Def12;
  end;
end;

registration
  let i be shiftable Instruction of SCMPDS;
  cluster Load i -> shiftable Program of SCMPDS;
  coherence
  proof
    set p=Load i;
    now
      let n,j such that
A1:    n in dom p and
A2:   j=p. n;
      dom p = {  0 } by FUNCOP_1:19;
      then  n =  0 by A1,TARSKI:def 1;
      then
A3:   j=i by A2,FUNCOP_1:87;
      hence InsCode j <> 1 by Def13;
      thus InsCode j <> 3 by A3,Def13;
A4:   InsCode j <> 4 & InsCode j <> 5 by A3,Def13;
      InsCode j=2 or InsCode j > 6 by A3,Def13;
      hence j valid_at n by A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

registration
  let i be shiftable Instruction of SCMPDS, J be shiftable Program of SCMPDS;
  cluster i ';' J -> shiftable;
  coherence;
end;

registration
  let I be shiftable Program of SCMPDS, j be shiftable Instruction of SCMPDS;
  cluster I ';' j -> shiftable;
  coherence;
end;

registration
  let i,j be shiftable Instruction of SCMPDS;
  cluster i ';' j -> shiftable;
  coherence;
end;

registration
  cluster Stop SCMPDS -> parahalting shiftable;
  coherence by Lm1,Lm2;
end;

registration
  let I be shiftable Program of SCMPDS;
  cluster stop I -> shiftable;
  coherence;
end;

theorem
  for I being shiftable Program of SCMPDS,k1 be Integer st card I + k1
  >= 0 holds I ';' goto k1 is shiftable
proof
  let I be shiftable Program of SCMPDS,k1 be Integer;
  set J= Load goto k1;
  set Ig=I ';' goto k1;
  assume
A1: card I + k1 >= 0;
  now
    set D = {l+card I: l in dom J };
    let n,i such that
A2:  n in dom Ig and
A3: i=Ig.( n);
    dom Shift(J,card I) = D by VALUED_1:def 12;
    then
A4: dom Ig = dom I \/ D by FUNCT_4:def 1;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A5:    n in dom I;
      then I. n=i by A3,AFINSQ_1:def 4;
      hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A5,Def12;
    end;
    suppose
       n in D;
      then consider l such that
A6:   n = l+card I and
A7:   l in dom J;
      dom J = {  0 } by FUNCOP_1:19;
      then
A8:    l =  0 by A7,TARSKI:def 1;
      then
A9:   goto k1 =J. l by FUNCOP_1:87
        .=i by A3,A6,A7,AFINSQ_1:def 4;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:21;
A10:  InsCode i <> 6 by A9,SCMPDS_2:21;
      InsCode i <> 4 & InsCode i <> 5 by A9,SCMPDS_2:21;
      hence i valid_at n by A1,A6,A8,A9,A10,Def11;
    end;
  end;
  hence thesis by Def12;
end;

registration
  let n be Element of NAT;
  cluster Load goto n -> shiftable Program of SCMPDS;
  coherence
  proof
    set k1=n;
    set J= Load goto k1;
    now
      let n,i such that
A1:    n in dom J and
A2:   i=J. n;
      dom J = {  0 } by FUNCOP_1:19;
      then  n =  0 by A1,TARSKI:def 1;
      then
A3:   goto k1 =i by A2,FUNCOP_1:87;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:21;
A4:   n+k1 >=0 & InsCode i <> 6 by A3,SCMPDS_2:21;
      InsCode i <> 4 & InsCode i <> 5 by A3,SCMPDS_2:21;
      hence i valid_at n by A3,A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

theorem
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)<>0_goto k2 is shiftable
proof
  let I be shiftable Program of SCMPDS,k1,k2 be Integer,a be Int_position;
  set ii= (a,k1)<>0_goto k2, J= Load ii;
  set Ig=I ';' ii;
  assume
A1: card I + k2 >= 0;
  now
    set D = {l+card I: l in dom J };
    let n,i such that
A2:  n in dom Ig and
A3: i=Ig.( n);
    dom Shift(J,card I) = D by VALUED_1:def 12;
    then
A4: dom Ig = dom I \/ D by FUNCT_4:def 1;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A5:    n in dom I;
      then I. n=i by A3,AFINSQ_1:def 4;
      hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A5,Def12;
    end;
    suppose
       n in D;
      then consider l such that
A6:   n = l+card I and
A7:   l in dom J;
      dom J = {  0 } by FUNCOP_1:19;
      then
A8:    l =  0 by A7,TARSKI:def 1;
      then
A9:   ii=J. l by FUNCOP_1:87
        .=i by A3,A6,A7,AFINSQ_1:def 4;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:25;
A10:  InsCode i <> 6 by A9,SCMPDS_2:25;
      InsCode i <> 0 & InsCode i <> 5 by A9,SCMPDS_2:25;
      hence i valid_at n by A1,A6,A8,A9,A10,Def11;
    end;
  end;
  hence thesis by Def12;
end;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)<>0_goto n -> shiftable Program of SCMPDS;
  coherence
  proof
    set k2=n;
    set ii= (a,k1)<>0_goto k2, J= Load ii;
    now
      let n,i such that
A1:    n in dom J and
A2:   i=J. n;
      dom J = {  0 } by FUNCOP_1:19;
      then  n =  0 by A1,TARSKI:def 1;
      then
A3:   ii =i by A2,FUNCOP_1:87;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:25;
A4:   n+k2 >=0 & InsCode i <> 6 by A3,SCMPDS_2:25;
      InsCode i <> 0 & InsCode i <> 5 by A3,SCMPDS_2:25;
      hence i valid_at n by A3,A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

theorem
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)<=0_goto k2 is shiftable
proof
  let I be shiftable Program of SCMPDS,k1,k2 be Integer,a be Int_position;
  set ii= (a,k1)<=0_goto k2, J= Load ii;
  set Ig=I ';' ii;
  assume
A1: card I + k2 >= 0;
  now
    set D = {l+card I: l in dom J };
    let n,i such that
A2:  n in dom Ig and
A3: i=Ig.( n);
    dom Shift(J,card I) = D by VALUED_1:def 12;
    then
A4: dom Ig = dom I \/ D by FUNCT_4:def 1;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A5:    n in dom I;
      then I. n=i by A3,AFINSQ_1:def 4;
      hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A5,Def12;
    end;
    suppose
       n in D;
      then consider l such that
A6:   n = l+card I and
A7:   l in dom J;
      dom J = {  0 } by FUNCOP_1:19;
      then
A8:    l =  0 by A7,TARSKI:def 1;
      then
A9:   ii =J. l by FUNCOP_1:87
        .=i by A3,A6,A7,AFINSQ_1:def 4;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:26;
A10:  InsCode i <> 6 by A9,SCMPDS_2:26;
      InsCode i <> 0 & InsCode i <> 4 by A9,SCMPDS_2:26;
      hence i valid_at n by A1,A6,A8,A9,A10,Def11;
    end;
  end;
  hence thesis by Def12;
end;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)<=0_goto n -> shiftable Program of SCMPDS;
  coherence
  proof
    set k2=n;
    set ii= (a,k1)<=0_goto k2, J= Load ii;
    now
      let n,i such that
A1:    n in dom J and
A2:   i=J. n;
      dom J = {  0 } by FUNCOP_1:19;
      then  n =  0 by A1,TARSKI:def 1;
      then
A3:   ii =i by A2,FUNCOP_1:87;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:26;
A4:   n+k2 >=0 & InsCode i <> 6 by A3,SCMPDS_2:26;
      InsCode i <> 0 & InsCode i <> 4 by A3,SCMPDS_2:26;
      hence i valid_at n by A3,A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

theorem
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)>=0_goto k2 is shiftable
proof
  let I be shiftable Program of SCMPDS,k1,k2 be Integer,a be Int_position;
  set ii= (a,k1)>=0_goto k2, J= Load ii;
  set Ig=I ';' ii;
  assume
A1: card I + k2 >= 0;
  now
    set D = {l+card I: l in dom J };
    let n,i such that
A2:  n in dom Ig and
A3: i=Ig.( n);
    dom Shift(J,card I) = D by VALUED_1:def 12;
    then
A4: dom Ig = dom I \/ D by FUNCT_4:def 1;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A5:    n in dom I;
      then I. n=i by A3,AFINSQ_1:def 4;
      hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A5,Def12;
    end;
    suppose
       n in D;
      then consider l such that
A6:   n = l+card I and
A7:   l in dom J;
      dom J = {  0 } by FUNCOP_1:19;
      then
A8:    l =  0 by A7,TARSKI:def 1;
      then
A9:   ii =J. l by FUNCOP_1:87
        .=i by A3,A6,A7,AFINSQ_1:def 4;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:27;
A10:  InsCode i <> 5 by A9,SCMPDS_2:27;
      InsCode i <> 0 & InsCode i <> 4 by A9,SCMPDS_2:27;
      hence i valid_at n by A1,A6,A8,A9,A10,Def11;
    end;
  end;
  hence thesis by Def12;
end;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)>=0_goto n -> shiftable Program of SCMPDS;
  coherence
  proof
    set k2=n;
    set ii= (a,k1)>=0_goto k2, J= Load ii;
    now
      let n,i such that
A1:    n in dom J and
A2:   i=J. n;
      dom J = {  0 } by FUNCOP_1:19;
      then  n =  0 by A1,TARSKI:def 1;
      then
A3:   ii =i by A2,FUNCOP_1:87;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:27;
A4:   n+k2 >=0 & InsCode i <> 5 by A3,SCMPDS_2:27;
      InsCode i <> 0 & InsCode i <> 4 by A3,SCMPDS_2:27;
      hence i valid_at n by A3,A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

theorem Th82:
  for s1,s2 being State of SCMPDS, n,m being Element of NAT,k1 be
Integer st IC s1= m & m+k1>=0 & IC s1 + n = IC s2
 holds ICplusConst(s1,k1) +n = ICplusConst(s2,k1)
proof
  let s1,s2 be State of SCMPDS, n,m be Element of NAT,k1 be Integer;
  assume that
A1: IC s1= m and
A2: m+k1>=0 and
A3: IC s1 + n = IC s2;
  reconsider nk = ICplusConst(s1,k1) as Element of NAT;
  reconsider mk=m+k1 as Element of NAT by A2,INT_1:16;
  ex n1 be Element of NAT st n1 = IC s1 & ICplusConst(s1, k1) = abs(n1+k1)
  by SCMPDS_2:def 20;
  then
  (ex n2 be Element of NAT st n2 = IC s2 & ICplusConst(s2, k1) = abs(n2+k1
  ) )& nk=mk by A1,ABSVALUE:def 1,SCMPDS_2:def 20;
  hence thesis by A1,A3,ABSVALUE:def 1;
end;

theorem Th83:
  for s1,s2 being State of SCMPDS, n,m being Element of NAT, i
being Instruction of SCMPDS holds IC s1= m & i valid_at m & InsCode i <>
  1 & InsCode i <> 3 & IC s1 + n = IC s2 & DataPart s1 = DataPart s2 implies IC
  Exec(i,s1) + n = IC Exec(i,s2) & DataPart Exec(i,s1) = DataPart Exec(i,s2)
proof
  let s1,s2 be State of SCMPDS, n,m be Element of NAT;
  let i be Instruction of SCMPDS;
  assume that
A1: IC s1= m and
A2: i valid_at m and
A3: InsCode i <> 1 & InsCode i <> 3 and
A4: IC s1 + n = IC s2 and
A5: DataPart s1 = DataPart s2;
A6: now
    let a,k1;
    thus s1.DataLoc(s1.a,k1) =s1.DataLoc(s2.a,k1) by A5,Th23
      .=s2.DataLoc(s2.a,k1) by A5,Th23;
  end;
  reconsider k1 = IC s1 as Element of NAT;
  set Ci=InsCode i;
A7: succ IC s1 + n = succ IC s2 by A4;
A8: now
    assume
    Ci <> 0 & Ci<>1 & Ci<>4 & Ci<>5 & Ci<> 6;
    then
A9: not Ci in {0,1,4,5,6} by ENUMSET1:def 3;
    then IC Exec(i,s1) = succ IC s1 by Th6;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A7,A9,Th6;
  end;
  per cases by A3,NAT_1:38,SCMPDS_2:15;
  suppose
    Ci = 0;
    then consider k1 such that
A10: i = goto k1 and
A11: m+k1 >= 0 by A2,Def11;
    IC Exec(i,s1) = ICplusConst(s1,k1) by A10,SCMPDS_2:66;
    hence IC Exec(i,s1) + n = ICplusConst(s2,k1) by A1,A4,A11,Th82
      .= IC Exec(i,s2) by A10,SCMPDS_2:66;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A10,SCMPDS_2:66
        .=s2.a by A5,Th23
        .=Exec(i, s2).a by A10,SCMPDS_2:66;
    end;
    hence thesis by Th23;
  end;
  suppose
A12: Ci = 2;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,k1 such that
A13: i = a := k1 by A12,SCMPDS_2:37;
    now
      let b;
      per cases;
      suppose
A14:    a=b;
        hence Exec(i, s1).b= k1 by A13,SCMPDS_2:57
          .=Exec(i,s2).b by A13,A14,SCMPDS_2:57;
      end;
      suppose
A15:    a<>b;
        hence Exec(i,s1).b = s1.b by A13,SCMPDS_2:57
          .=s2.b by A5,Th23
          .=Exec(i,s2).b by A13,A15,SCMPDS_2:57;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
    Ci = 4;
    then consider a,k1,k2 such that
A16: i = (a,k1)<>0_goto k2 and
A17: m+k2 >= 0 by A2,Def11;
    hereby
      per cases;
      suppose
A18:    s1.DataLoc(s1.a,k1) <> 0;
        then
A19:    s2.DataLoc(s2.a,k1) <> 0 by A6;
        IC Exec(i,s1) = ICplusConst(s1,k2) by A16,A18,SCMPDS_2:67;
        hence IC Exec(i,s1) + n = ICplusConst(s2,k2) by A1,A4,A17,Th82
          .= IC Exec(i,s2) by A16,A19,SCMPDS_2:67;
      end;
      suppose
        s1.DataLoc(s1.a,k1) = 0;
        then s2.DataLoc(s2.a,k1) = 0 & IC Exec(i,s1) = succ IC s1 by A6,A16,
SCMPDS_2:67;
        hence IC Exec(i,s1) + n = IC Exec(i,s2) by A7,A16,SCMPDS_2:67;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A16,SCMPDS_2:67
        .=s2.a by A5,Th23
        .=Exec(i, s2).a by A16,SCMPDS_2:67;
    end;
    hence thesis by Th23;
  end;
  suppose
    Ci = 5;
    then consider a,k1,k2 such that
A20: i = (a,k1)<=0_goto k2 and
A21: m+k2 >= 0 by A2,Def11;
    hereby
      per cases;
      suppose
A22:    s1.DataLoc(s1.a,k1) <= 0;
        then
A23:    s2.DataLoc(s2.a,k1) <= 0 by A6;
        IC Exec(i,s1) = ICplusConst(s1,k2) by A20,A22,SCMPDS_2:68;
        hence IC Exec(i,s1) + n = ICplusConst(s2,k2) by A1,A4,A21,Th82
          .= IC Exec(i,s2) by A20,A23,SCMPDS_2:68;
      end;
      suppose
        s1.DataLoc(s1.a,k1) > 0;
        then s2.DataLoc(s2.a,k1) > 0 & IC Exec(i,s1) = succ IC s1 by A6,A20,
SCMPDS_2:68;
        hence IC Exec(i,s1) + n = IC Exec(i,s2) by A7,A20,SCMPDS_2:68;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A20,SCMPDS_2:68
        .=s2.a by A5,Th23
        .=Exec(i, s2).a by A20,SCMPDS_2:68;
    end;
    hence thesis by Th23;
  end;
  suppose
    Ci = 6;
    then consider a,k1,k2 such that
A24: i = (a,k1)>=0_goto k2 and
A25: m+k2 >= 0 by A2,Def11;
    hereby
      per cases;
      suppose
A26:    s1.DataLoc(s1.a,k1) >= 0;
        then
A27:    s2.DataLoc(s2.a,k1) >= 0 by A6;
        IC Exec(i,s1) = ICplusConst(s1,k2) by A24,A26,SCMPDS_2:69;
        hence IC Exec(i,s1) + n = ICplusConst(s2,k2) by A1,A4,A25,Th82
          .= IC Exec(i,s2) by A24,A27,SCMPDS_2:69;
      end;
      suppose
        s1.DataLoc(s1.a,k1) < 0;
        then s2.DataLoc(s2.a,k1) < 0 & IC Exec(i,s1) = succ IC s1 by A6,A24,
SCMPDS_2:69;
        hence IC Exec(i,s1) + n = IC Exec(i,s2) by A7,A24,SCMPDS_2:69;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A24,SCMPDS_2:69
        .=s2.a by A5,Th23
        .=Exec(i, s2).a by A24,SCMPDS_2:69;
    end;
    hence thesis by Th23;
  end;
  suppose
A28: Ci = 7;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,k1,k2 such that
A29: i = (a,k1) := k2 by A28,SCMPDS_2:42;
    now
      let b;
      per cases;
      suppose
A30:    DataLoc(s1.a,k1)=b;
        then
A31:    DataLoc(s2.a,k1)=b by A5,Th23;
        thus Exec(i, s1).b= k2 by A29,A30,SCMPDS_2:58
          .=Exec(i,s2).b by A29,A31,SCMPDS_2:58;
      end;
      suppose
A32:    DataLoc(s1.a,k1)<>b;
        then
A33:    DataLoc(s2.a,k1)<>b by A5,Th23;
        thus Exec(i,s1).b = s1.b by A29,A32,SCMPDS_2:58
          .=s2.b by A5,Th23
          .=Exec(i,s2).b by A29,A33,SCMPDS_2:58;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A34: Ci = 8;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,k1,k2 such that
A35: i = AddTo(a,k1,k2) by A34,SCMPDS_2:43;
    now
      let b;
      per cases;
      suppose
A36:    DataLoc(s1.a,k1)=b;
        then
A37:    DataLoc(s2.a,k1)=b by A5,Th23;
        thus Exec(i, s1).b= s1.DataLoc(s1.a,k1)+k2 by A35,A36,SCMPDS_2:60
          .= s2.DataLoc(s2.a,k1)+k2 by A6
          .=Exec(i,s2).b by A35,A37,SCMPDS_2:60;
      end;
      suppose
A38:    DataLoc(s1.a,k1)<>b;
        then
A39:    DataLoc(s2.a,k1)<>b by A5,Th23;
        thus Exec(i,s1).b = s1.b by A35,A38,SCMPDS_2:60
          .=s2.b by A5,Th23
          .=Exec(i,s2).b by A35,A39,SCMPDS_2:60;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A40: Ci = 9;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A41: i = AddTo(a,k1,b,k2) by A40,SCMPDS_2:44;
    now
      let c;
      per cases;
      suppose
A42:    DataLoc(s1.a,k1)=c;
        then
A43:    DataLoc(s2.a,k1)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)+s1.DataLoc(s1.b,k2) by A41,A42
,SCMPDS_2:61
          .= s2.DataLoc(s2.a,k1)+s1.DataLoc(s1.b,k2) by A6
          .= s2.DataLoc(s2.a,k1)+s2.DataLoc(s2.b,k2) by A6
          .=Exec(i,s2).c by A41,A43,SCMPDS_2:61;
      end;
      suppose
A44:    DataLoc(s1.a,k1)<>c;
        then
A45:    DataLoc(s2.a,k1)<>c by A5,Th23;
        thus Exec(i,s1).c = s1.c by A41,A44,SCMPDS_2:61
          .=s2.c by A5,Th23
          .=Exec(i,s2).c by A41,A45,SCMPDS_2:61;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A46: Ci = 10;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A47: i = SubFrom(a,k1,b,k2) by A46,SCMPDS_2:45;
    now
      let c;
      per cases;
      suppose
A48:    DataLoc(s1.a,k1)=c;
        then
A49:    DataLoc(s2.a,k1)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)-s1.DataLoc(s1.b,k2) by A47,A48
,SCMPDS_2:62
          .= s2.DataLoc(s2.a,k1)-s1.DataLoc(s1.b,k2) by A6
          .= s2.DataLoc(s2.a,k1)-s2.DataLoc(s2.b,k2) by A6
          .=Exec(i,s2).c by A47,A49,SCMPDS_2:62;
      end;
      suppose
A50:    DataLoc(s1.a,k1)<>c;
        then
A51:    DataLoc(s2.a,k1)<>c by A5,Th23;
        thus Exec(i,s1).c = s1.c by A47,A50,SCMPDS_2:62
          .=s2.c by A5,Th23
          .=Exec(i,s2).c by A47,A51,SCMPDS_2:62;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A52: Ci = 11;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A53: i = MultBy(a,k1,b,k2) by A52,SCMPDS_2:46;
    now
      let c;
      per cases;
      suppose
A54:    DataLoc(s1.a,k1)=c;
        then
A55:    DataLoc(s2.a,k1)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)*s1.DataLoc(s1.b,k2) by A53,A54
,SCMPDS_2:63
          .= s2.DataLoc(s2.a,k1)*s1.DataLoc(s1.b,k2) by A6
          .= s2.DataLoc(s2.a,k1)*s2.DataLoc(s2.b,k2) by A6
          .=Exec(i,s2).c by A53,A55,SCMPDS_2:63;
      end;
      suppose
A56:    DataLoc(s1.a,k1)<>c;
        then
A57:    DataLoc(s2.a,k1)<>c by A5,Th23;
        thus Exec(i,s1).c = s1.c by A53,A56,SCMPDS_2:63
          .=s2.c by A5,Th23
          .=Exec(i,s2).c by A53,A57,SCMPDS_2:63;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A58: Ci = 12;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A59: i = Divide(a,k1,b,k2) by A58,SCMPDS_2:47;
    now
      let c;
      per cases;
      suppose
A60:    DataLoc(s1.b,k2)=c;
        then
A61:    DataLoc(s2.b,k2)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) mod s1.DataLoc(s1.b,k2) by A59
,A60,SCMPDS_2:64
          .= s2.DataLoc(s2.a,k1) mod s1.DataLoc(s1.b,k2) by A6
          .= s2.DataLoc(s2.a,k1) mod s2.DataLoc(s2.b,k2) by A6
          .= Exec(i,s2).c by A59,A61,SCMPDS_2:64;
      end;
      suppose
A62:    DataLoc(s1.b,k2)<>c;
        then
A63:    DataLoc(s2.b,k2)<>c by A5,Th23;
        hereby
          per cases;
          suppose
A64:        DataLoc(s1.a,k1)<>c;
            then
A65:        DataLoc(s2.a,k1)<>c by A5,Th23;
            thus Exec(i, s1).c = s1.c by A59,A62,A64,SCMPDS_2:64
              .=s2.c by A5,Th23
              .=Exec(i,s2).c by A59,A63,A65,SCMPDS_2:64;
          end;
          suppose
A66:        DataLoc(s1.a,k1)=c;
            then
A67:        DataLoc(s2.a,k1)=c by A5,Th23;
            thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) div s1.DataLoc(s1.b,k2)
            by A59,A62,A66,SCMPDS_2:64
              .= s2.DataLoc(s2.a,k1) div s1.DataLoc(s1.b,k2) by A6
              .= s2.DataLoc(s2.a,k1) div s2.DataLoc(s2.b,k2) by A6
              .= Exec(i,s2).c by A59,A63,A67,SCMPDS_2:64;
          end;
        end;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A68: Ci = 13;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A69: i = (a,k1):=(b,k2) by A68,SCMPDS_2:48;
    now
      let c;
      per cases;
      suppose
A70:    DataLoc(s1.a,k1)=c;
        then
A71:    DataLoc(s2.a,k1)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.b,k2) by A69,A70,SCMPDS_2:59
          .= s2.DataLoc(s2.b,k2) by A6
          .=Exec(i,s2).c by A69,A71,SCMPDS_2:59;
      end;
      suppose
A72:    DataLoc(s1.a,k1)<>c;
        then
A73:    DataLoc(s2.a,k1)<>c by A5,Th23;
        thus Exec(i,s1).c = s1.c by A69,A72,SCMPDS_2:59
          .=s2.c by A5,Th23
          .=Exec(i,s2).c by A69,A73,SCMPDS_2:59;
      end;
    end;
    hence thesis by Th23;
  end;
end;

theorem
  for s1 being 0-started State of SCMPDS
  for J being parahalting shiftable Program of SCMPDS st stop J c= s1
  for n being Element of NAT st Shift(stop J,n) c= s2 &
    IC s2 = n & DataPart s1 = DataPart s2
  for i being Element of NAT holds
   IC Comput(ProgramPart(s1),s1,i) + n = IC Comput(ProgramPart(s2),s2,i) &
    CurInstr(ProgramPart(s1),Comput(ProgramPart(s1),s1,i)) =
     CurInstr(ProgramPart(s2),Comput(ProgramPart(s2),s2,i)) &
    DataPart Comput(ProgramPart(s1),s1,i) = DataPart
       Comput(ProgramPart(s2),s2,i)
proof
  let s1 be 0-started State of SCMPDS;
  let I be parahalting shiftable Program of SCMPDS;
  set SI=stop I, II = Initialize SI;
  assume
A1: SI c= s1;
  let n be Element of NAT;
  assume that
A2: Shift(SI,n) c= s2 and
A3: IC s2 =  n and
A4: DataPart s1 = DataPart s2;
A5:  0 in dom SI by COMPOS_1:135;
  then
A6: 0 + n in dom Shift(SI,n) by VALUED_1:25;
  defpred P[Nat] means IC Comput(ProgramPart(s1),s1,$1) + n = IC Comput(
ProgramPart(s2),s2,$1) &
  CurInstr(ProgramPart(s1),Comput(ProgramPart(s1),s1,$1))
   = CurInstr(ProgramPart(s2),Comput(ProgramPart(s2),s2,$1)) & DataPart
  Comput(ProgramPart(s1),s1,$1) = DataPart Comput(ProgramPart(s2),s2,$1);
A9: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A10: P[k];
    reconsider m = IC Comput(ProgramPart(s1),s1,k) as Element of NAT;
    set i = CurInstr(ProgramPart(s1),Comput(ProgramPart(s1),s1,k));
A11: Comput(ProgramPart(s1),s1,k+1) =
   Following(ProgramPart s1,Comput(ProgramPart(s1),s1,k))
 by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart(s1),Comput(ProgramPart(s1),s1,k)),
      Comput(ProgramPart(s1),s1,k));
    reconsider l = IC Comput(ProgramPart(s1),s1,k+1) as Element of NAT;
A13: IC Comput(ProgramPart(s1),s1,k+1) in dom SI by A1,Def9;
    then
A14: l+n in dom Shift(SI,n) by VALUED_1:25;
A15: Comput(ProgramPart(s2),s2,k+1) =
   Following(ProgramPart s2,Comput(ProgramPart(s2),s2,k))
 by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart(s2),Comput(ProgramPart(s2),s2,k)),
      Comput(ProgramPart(s2),s2,k));
A16: IC Comput(ProgramPart(s1),s1,k)
 in dom SI by A1,Def9;
A17: i = s1.IC Comput(ProgramPart(s1),s1,k) by COMPOS_1:38
      .= SI.IC Comput(ProgramPart(s1),s1,k) by A1,A16,GRFUNC_1:8;
    then
A18: InsCode i <> 1 & InsCode i <> 3 by A16,Def12;
A19: i valid_at m by A16,A17,Def12;
    hence
A20: IC Comput(ProgramPart(s1),s1,k+1) + n = IC Comput(ProgramPart(s2),s2,k+1)
       by A10,A11,A15,A18,Th83;
    CurInstr(ProgramPart(s1),Comput(ProgramPart(s1),s1,k+1)) = s1.l
     by COMPOS_1:38
      .= SI.l by A1,A13,GRFUNC_1:8;
    hence CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,k+1))
     = Shift(SI,n).(IC Comput(ProgramPart(s2),s2,k+1))
    by A20,A13,VALUED_1:def 12
      .= s2.IC Comput(ProgramPart(s2),s2,k+1) by A2,A20,A14,GRFUNC_1:8
      .= CurInstr(ProgramPart(s2),Comput(ProgramPart(s2),s2,k+1))
       by COMPOS_1:38;
    thus thesis by A10,A11,A15,A18,A19,Th83;
  end;
A22: s1.IC s1 = s1. 0 by COMPOS_1:def 16
    .= SI. 0 by A1,A5,GRFUNC_1:8;
  let i be Element of NAT;
A23: DataPart Comput(ProgramPart(s1),s1,0) = DataPart s2 by A4,EXTPRO_1:3
    .= DataPart Comput(ProgramPart(s2),s2,0) by EXTPRO_1:3;
A24: IC Comput(ProgramPart(s1),s1,0)
     = IC s1 by EXTPRO_1:3
    .=  0 by COMPOS_1:def 16;
u: Comput(ProgramPart(s1),s1,0) = s1 by EXTPRO_1:3;
v: Comput(ProgramPart(s2),s2,0) = s2 by EXTPRO_1:3;
Y:  (ProgramPart s2)/.IC s2
 = s2.IC s2 by COMPOS_1:38;
Z:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by COMPOS_1:38;
  CurInstr(ProgramPart(s1),Comput(ProgramPart(s1),s1,0))
     = Shift(SI,n).( 0 + n) by A5,A22,Z,u,VALUED_1:def 12
    .= CurInstr(ProgramPart(s2),Comput(ProgramPart(s2),s2,0))
     by v,A2,A3,A6,Y,GRFUNC_1:8;
  then
A25: P[0] by A3,A24,A23,EXTPRO_1:3;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A25,A9);
  hence thesis;
end;

