:: The Construction and shiftability of Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMPDS_2, SCMFSA_7, SCMPDS_3, CARD_1,
      FUNCOP_1, RELAT_1, FINSET_1, FUNCT_1, CAT_1, NAT_1, ARYTM_3, XBOOLE_0,
      TARSKI, VALUED_1, SCMNORM, FSM_1, INT_1, SCMFSA6A, FUNCT_4, GRAPHSP,
      AMI_3, FUNCT_7, AMI_2, STRUCT_0, SCMPDS_1, COMPLEX1, XXREAL_0, ARYTM_1,
      AMISTD_1, TURING_1, AMISTD_2, SCMFSA6B, MSUALG_1, CIRCUIT2, GLIB_000,
      SCMPDS_4;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      RELAT_1, FUNCT_1, FUNCT_4, FUNCT_7, INT_1, NAT_1, FINSET_1, INT_2,
      XXREAL_0, STRUCT_0, AMI_1, SCMNORM, AMI_2, AMI_3, SCMPDS_1, SCMPDS_2,
      SCMPDS_3;
 constructors WELLORD2, XXREAL_0, NAT_1, INT_2, AMI_5, SCMPDS_1, SCMPDS_3,
      DOMAIN_1, SCMNORM, AFINSQ_1, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1,
      NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, AMI_1, SCMPDS_2, AMI_2,
      SCMNORM, FINSET_1, CARD_1, VALUED_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, AMI_1, AMI_3, SCMPDS_3, FUNCT_7, XBOOLE_0, SCMPDS_2,
      FUNCOP_1, NAT_1, SCMNORM, AFINSQ_1, RELAT_1;
 theorems AMI_1, NAT_1, TARSKI, FUNCT_4, FUNCT_1, ZFMISC_1, INT_1, RELAT_1,
      SCMPDS_2, AMI_2, FUNCT_2, FUNCT_7, SCMPDS_3, CARD_1, WELLORD2, ENUMSET1,
      CARD_3, ABSVALUE, GRFUNC_1, CARD_2, XBOOLE_0, XBOOLE_1, XREAL_1,
      ORDINAL1, FUNCOP_1, XXREAL_0, VALUED_1, SCMNORM, AFINSQ_1;
 schemes NAT_1, DOMAIN_1, FUNCT_7, CLASSES1;

begin :: Definition of a program block and its basic properties

reserve l, m, n for Element of NAT,
  i,j,k for Instruction of SCMPDS,
  I,J,K for
  Program of SCMPDS;

definition
  let i;
  func Load i -> Program of SCMPDS equals
  (inspos 0).--> i;
  coherence
  proof
    set I = (inspos 0).--> i;
A1: dom I = {inspos 0} by FUNCOP_1:19;
    reconsider I as finite Function;
    reconsider I as FinPartState of SCMPDS;
    I is initial
    proof
      let m,n be Nat;
      assume
      n in dom I & m < n;
      hence thesis by A1,TARSKI:def 1;
    end;
    hence thesis;
  end;
  correctness;
end;

registration
  let i;
  cluster Load i -> non empty;
  coherence;
end;

theorem Th1:
  for P being Program of SCMPDS, n being Nat holds n < card P iff n
  in dom P
proof
  deffunc U(Element of NAT) = $1;
  let P be Program of SCMPDS, n be Nat;
  set A = { m : U(m) in dom P};
A1: now
    let x be set;
A2: dom P c= NAT by RELAT_1:def 18;
    assume
    x in dom P;
    then reconsider l=x as Instruction-Location of SCMPDS by A2,AMI_1:def 4;
    reconsider n = l as Element of NAT by ORDINAL1:def 13;
    take n;
    thus x = U(n);
  end;
A3: for n,m st U(n) = U(m) holds n = m;
A4: dom P,A are_equipotent from FUNCT_7:sch 3(A1,A3);
  defpred X[Element of NAT] means U($1) in dom P;
A5: card n = n by CARD_1:def 5;
  set A = { m : X[m] };
A6: A is Subset of NAT from DOMAIN_1:sch 7;
  now
    let n,m such that
A7: n in A and
A8: m < n;
    ex l being Element of NAT st l = n & l in dom P by A7;
    then m in dom P by A8,SCMNORM:def 1;
    hence m in A;
  end;
  then reconsider A as Cardinal by A6,FUNCT_7:22;
A9: card A = A by CARD_1:def 5;
  hereby
    assume
    n < card P;
    then card n in card card P by NAT_1:42;
    then n in card dom P by A5,CARD_1:104;
    then n in card A by A4,CARD_1:21;
    then ex m st m = n & m in dom P by A9;
    hence n in dom P;
  end;
A10: n in NAT by ORDINAL1:def 13;
  assume
  n in dom P;
  then n in card A by A9,A10;
  then n in card dom P by A4,CARD_1:21;
  then card n in card card P by A5,CARD_1:104;
  hence thesis by NAT_1:42;
end;

theorem Th2:
  dom I misses dom Shift(J,card I)
proof
  assume
A1: dom I meets dom Shift(J,card I);
  dom Shift(J,card I) = { l+card I: l in dom J } by VALUED_1:def 12;
  then consider x being set such that
A2: x in dom I and
A3: x in { l+card I: l in dom J } by A1,XBOOLE_0:3;
  consider l such that
A4: x = l+card I and
  l in dom J by A3;
  l+card I < card I by A2,A4,Th1;
  hence contradiction by NAT_1:11;
end;

theorem Th3:
  for I being preProgram of SCMPDS holds card Shift(I,m) = card I
proof
  defpred NC[set] means not contradiction;
  deffunc U(Element of NAT) = $1;
  let I be preProgram of SCMPDS;
A1: for x being set st x in dom I ex d being Element of NAT st x = U(d)
  proof
    let x be set;
    assume
A2: x in dom I;
    dom I c= NAT by RELAT_1:def 18;
    then reconsider l=x as Instruction-Location of SCMPDS by A2,AMI_1:def 4;
    reconsider l as Element of NAT by ORDINAL1:def 13;
    take l;
    thus thesis;
  end;
  defpred X[Element of NAT] means $1 in dom I;
  deffunc V(Element of NAT) = $1+m;
  set B = { l: U(l) in dom I }, C = { V(l): l in { n: X[n] } & NC[l] }, D = {
  V(l): l in B }, E = { l+m: l in dom I };
A3: for d1,d2 being Element of NAT st U(d1) = U(d2) holds d1=d2;
A4: dom I,B are_equipotent from FUNCT_7:sch 3(A1,A3);
A5: C c= E
  proof
    let e be set;
    assume
    e in C;
    then consider l such that
A6: e =V(l) and
A7: l in { n: X[n] } & NC[l];
    ex n st n=l & X[n] by A7;
    hence thesis by A6;
  end;
  set B = { l: X[l] };
  B is Subset of NAT from DOMAIN_1:sch 7;
  then
A8: B c= NAT;
  set B = { l: l in dom I };
A9: for d1,d2 be Element of NAT st V(d1) = V(d2) holds d1 = d2;
A10: B,D are_equipotent from FUNCT_7:sch 4(A8,A9);
A11: E c= D
  proof
    let e be set;
    assume
    e in E;
    then consider l such that
A12: e = l+m and
A13: l in dom I;
    l in B by A13;
    hence thesis by A12;
  end;
A14: dom Shift(I,m) = E by VALUED_1:def 12;
A15: D c= C
  proof
    let e be set;
    assume
    e in D;
    then ex l st e = V(l) & l in B;
    hence thesis;
  end;
  then E c= C by A11,XBOOLE_1:1;
  then
A16: C = E by A5,XBOOLE_0:def 10;
  then C = D by A11,A15,XBOOLE_0:def 10;
  then
A17: dom Shift(I,m),dom I are_equipotent by A4,A16,A10,A14,WELLORD2:22;
  thus card Shift(I,m) = card dom Shift(I,m) by CARD_1:104
    .= card dom I by A17,CARD_1:21
    .= card I by CARD_1:104;
end;

reserve a,b,c for Int_position,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer;

definition
  let I;
  func Initialized I -> FinPartState of SCMPDS equals
  I +* Start-At(inspos 0);
  coherence;
  correctness;
end;

canceled 2;

theorem Th6:
  InsCode i in {0,1,4,5,6} or Exec(i,s).IC SCMPDS = Next IC s
proof
  assume
A1: not InsCode i in {0,1,4,5,6};
  then
A2: InsCode i <> 0 & InsCode i <> 1 by ENUMSET1:def 3;
A3: InsCode i <> 6 by A1,ENUMSET1:def 3;
A4: InsCode i <> 4 & InsCode i <> 5 by A1,ENUMSET1:def 3;
  per cases by A2,A4,A3,NAT_1:38,SCMPDS_2:15;
  suppose
    InsCode i = 2;
    then ex a,k1 st i = a:=k1 by SCMPDS_2:37;
    hence thesis by SCMPDS_2:57;
  end;
  suppose
    InsCode i = 3;
    then ex a,k1 st i = saveIC(a,k1) by SCMPDS_2:38;
    hence thesis by SCMPDS_2:71;
  end;
  suppose
    InsCode i = 7;
    then ex a,k1,k2 st i = (a,k1) := k2 by SCMPDS_2:42;
    hence thesis by SCMPDS_2:58;
  end;
  suppose
    InsCode i = 8;
    then ex a,k1,k2 st i = AddTo(a,k1,k2) by SCMPDS_2:43;
    hence thesis by SCMPDS_2:60;
  end;
  suppose
    InsCode i = 9;
    then ex a,b,k1,k2 st i = AddTo(a,k1,b,k2) by SCMPDS_2:44;
    hence thesis by SCMPDS_2:61;
  end;
  suppose
    InsCode i = 10;
    then ex a,b,k1,k2 st i = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
    hence thesis by SCMPDS_2:62;
  end;
  suppose
    InsCode i = 11;
    then ex a,b,k1,k2 st i = MultBy(a,k1,b,k2) by SCMPDS_2:46;
    hence thesis by SCMPDS_2:63;
  end;
  suppose
    InsCode i = 12;
    then ex a,b,k1,k2 st i = Divide(a,k1,b,k2) by SCMPDS_2:47;
    hence thesis by SCMPDS_2:64;
  end;
  suppose
    InsCode i = 13;
    then ex a,b,k1,k2 st i = (a,k1):=(b,k2) by SCMPDS_2:48;
    hence thesis by SCMPDS_2:59;
  end;
end;

theorem Th7:
  IC SCMPDS in dom Initialized I
proof
  dom Start-At(inspos 0) = { IC SCMPDS } by FUNCOP_1:19;
  then dom Initialized I = dom I \/ dom Start-At(inspos 0) & IC SCMPDS in dom
  Start-At(inspos 0) by FUNCT_4:def 1,TARSKI:def 1;
  hence thesis by XBOOLE_0:def 3;
end;

theorem
  IC Initialized I = inspos 0
proof
  dom Start-At(inspos 0) = { IC SCMPDS } by FUNCOP_1:19;
  then
A1: IC SCMPDS in dom Start-At(inspos 0) by TARSKI:def 1;
  IC SCMPDS in dom Initialized I by Th7;
  hence IC Initialized I = (I +* Start-At(inspos 0)).IC SCMPDS by AMI_1:def 43
    .= (Start-At inspos 0).IC SCMPDS by A1,FUNCT_4:14
    .= inspos 0 by FUNCOP_1:87;
end;

theorem Th9:
  I c= Initialized I
proof
  set A = NAT;
A1: dom I c= A by RELAT_1:def 18;
A2: now
    assume
    IC SCMPDS in dom I;
    then reconsider l=IC SCMPDS as Instruction-Location of SCMPDS by A1,
AMI_1:def 4;
    l=IC SCMPDS;
    hence contradiction by AMI_1:48;
  end;
  dom Start-At(inspos 0) = { IC SCMPDS } by FUNCOP_1:19;
  then dom I misses dom (Start-At (inspos 0)) by A2,ZFMISC_1:56;
  hence thesis by FUNCT_4:33;
end;

canceled;

theorem Th11:
  for s1,s2 being State of SCMPDS st IC s1 = IC s2 & for a being
  Int_position holds s1.a = s2.a holds s1,s2 equal_outside NAT
proof
  set A = NAT;
  let s1,s2 be State of SCMPDS such that
A1: IC s1 = IC s2 and
A2: for a being Int_position holds s1.a = s2.a;
  now
    assume
    IC SCMPDS in A;
    then reconsider l=IC SCMPDS as Instruction-Location of SCMPDS by
AMI_1:def 4;
    l=IC SCMPDS;
    hence contradiction by AMI_1:48;
  end;
  then {IC SCMPDS} misses A by ZFMISC_1:56;
  then
A3: {IC SCMPDS } \/ SCM-Data-Loc misses A by AMI_2:29,XBOOLE_1:70;
A4: (the carrier of SCMPDS) \ A = {IC SCMPDS } \/ SCM-Data-Loc \ A by
SCMPDS_3:5,XBOOLE_1:40
    .= {IC SCMPDS } \/ SCM-Data-Loc by A3,XBOOLE_1:83;
A5: dom(s2|(dom s2 \ A)) = dom s2 /\ (dom s2 \ A) by RELAT_1:90
    .= dom s2 \ A by XBOOLE_1:28
    .= {IC SCMPDS } \/ SCM-Data-Loc by A4,AMI_1:79;
A6: dom(s1|(dom s1 \ A)) = dom s1 /\ (dom s1 \ A) by RELAT_1:90
    .= dom s1 \ A by XBOOLE_1:28
    .= {IC SCMPDS } \/ SCM-Data-Loc by A4,AMI_1:79;
  now
    let x be set;
    assume
A7: x in {IC SCMPDS } \/ SCM-Data-Loc;
    per cases by A7,XBOOLE_0:def 3;
    suppose
      x in {IC SCMPDS};
      then
A8:   x = IC SCMPDS by TARSKI:def 1;
      hence (s1|(dom s1 \ A)).x = IC s1 by A6,A7,FUNCT_1:70
        .= (s2|(dom s2 \ A)).x by A1,A5,A7,A8,FUNCT_1:70;
    end;
    suppose
      x in SCM-Data-Loc;
      then
A9:   x is Int_position by SCMPDS_2:9;
      thus (s1|(dom s1 \ A)).x = s1.x by A6,A7,FUNCT_1:70
        .= s2.x by A2,A9
        .= (s2|(dom s2 \ A)).x by A5,A7,FUNCT_1:70;
    end;
  end;
  hence s1|(dom s1 \ A) = s2|(dom s2 \ A) by A6,A5,FUNCT_1:9;
end;

canceled;

theorem Th13:
  s1,s2 equal_outside NAT implies for a being Int_position holds
  s1.a = s2.a
proof
  assume
A1: s1,s2 equal_outside NAT;
  let a be Int_position;
  a in SCM-Data-Loc by SCMPDS_2:def 2;
  then
A2: not a in NAT by AMI_2:29,XBOOLE_0:3;
  a in dom s2 by SCMPDS_2:49;
  then a in dom s2 \ NAT by A2,XBOOLE_0:def 5;
  then
A3: a in dom s2 /\ (dom s2 \ NAT) by XBOOLE_0:def 4;
  a in dom s1 by SCMPDS_2:49;
  then a in dom s1 \ NAT by A2,XBOOLE_0:def 5;
  then a in dom s1 /\ (dom s1 \ NAT) by XBOOLE_0:def 4;
  hence s1.a = (s1|(dom s1 \ NAT)).a by FUNCT_1:71
    .= (s2|(dom s2 \ NAT)).a by A1,FUNCT_7:def 2
    .= s2.a by A3,FUNCT_1:71;
end;

theorem Th14:
  s1,s2 equal_outside NAT implies s1.DataLoc(s1.a,k1)=s2.DataLoc(
  s2.a,k1)
proof
  assume
A1: s1,s2 equal_outside NAT;
  hence s1.DataLoc(s1.a,k1)=s1.DataLoc(s2.a,k1) by Th13
    .=s2.DataLoc(s2.a,k1) by A1,Th13;
end;

theorem Th15:
  s1,s2 equal_outside NAT implies Exec(i,s1),Exec(i,s2)
  equal_outside NAT
proof
  assume
A1: s1,s2 equal_outside NAT;
  then
A2: IC s1 = IC s2 by AMI_1:121;
  per cases by NAT_1:38,SCMPDS_2:15;
  suppose
    InsCode i = 0;
    then consider k1 such that
A3: i = goto k1 by SCMPDS_2:35;
A4: now
      let a;
      thus Exec(i, s1).a = s1.a by A3,SCMPDS_2:66
        .=s2.a by A1,Th13
        .=Exec(i, s2).a by A3,SCMPDS_2:66;
    end;
    IC Exec(i,s1) = ICplusConst(s1,k1) by A3,SCMPDS_2:66
      .= ICplusConst(s2,k1) by A2,SCMPDS_3:2
      .= IC Exec(i,s2) by A3,SCMPDS_2:66;
    hence thesis by A4,Th11;
  end;
  suppose
    InsCode i = 1;
    then consider a such that
A5: i = return a by SCMPDS_2:36;
A6: now
      let b;
      per cases;
      suppose
A7:     a=b;
        hence Exec(i, s1).b= s1.DataLoc(s1.a,RetSP) by A5,SCMPDS_2:70
          .=s2.DataLoc(s2.a,RetSP) by A1,Th14
          .=Exec(i,s2).b by A5,A7,SCMPDS_2:70;
      end;
      suppose
A8:     a<>b;
        hence Exec(i, s1).b = s1.b by A5,SCMPDS_2:70
          .=s2.b by A1,Th13
          .=Exec(i,s2).b by A5,A8,SCMPDS_2:70;
      end;
    end;
    IC Exec(i,s1) = (abs(s1.DataLoc(s1.a,RetIC)))+2 by A5,SCMPDS_2:70
      .= (abs(s1.DataLoc(s2.a,RetIC)))+2 by A1,Th13
      .= (abs(s2.DataLoc(s2.a,RetIC)))+2 by A1,Th13
      .= IC Exec(i,s2) by A5,SCMPDS_2:70;
    hence thesis by A6,Th11;
  end;
  suppose
    InsCode i = 2;
    then consider a,k1 such that
A9: i = a := k1 by SCMPDS_2:37;
A10: now
      let b;
      per cases;
      suppose
A11:    a=b;
        hence Exec(i, s1).b= k1 by A9,SCMPDS_2:57
          .=Exec(i,s2).b by A9,A11,SCMPDS_2:57;
      end;
      suppose
A12:    a<>b;
        hence Exec(i,s1).b = s1.b by A9,SCMPDS_2:57
          .=s2.b by A1,Th13
          .=Exec(i,s2).b by A9,A12,SCMPDS_2:57;
      end;
    end;
    IC Exec(i,s1) = Next IC s2 by A2,A9,SCMPDS_2:57
      .= IC Exec(i,s2) by A9,SCMPDS_2:57;
    hence thesis by A10,Th11;
  end;
  suppose
    InsCode i = 3;
    then consider a,k1 such that
A13: i = saveIC(a,k1) by SCMPDS_2:38;
A14: now
      let b;
      per cases;
      suppose
A15:    b=DataLoc(s1.a,k1);
        then
A16:    b=DataLoc(s2.a,k1) by A1,Th13;
        thus Exec(i, s1).b=IC s2 by A2,A13,A15,SCMPDS_2:71
          .=Exec(i,s2).b by A13,A16,SCMPDS_2:71;
      end;
      suppose
A17:    b<>DataLoc(s1.a,k1);
        then
A18:    b<>DataLoc(s2.a,k1) by A1,Th13;
        thus Exec(i,s1).b = s1.b by A13,A17,SCMPDS_2:71
          .=s2.b by A1,Th13
          .=Exec(i,s2).b by A13,A18,SCMPDS_2:71;
      end;
    end;
    IC Exec(i,s1) = Next IC s2 by A2,A13,SCMPDS_2:71
      .= IC Exec(i,s2) by A13,SCMPDS_2:71;
    hence thesis by A14,Th11;
  end;
  suppose
    InsCode i = 4;
    then consider a,k1,k2 such that
A19: i = (a,k1)<>0_goto k2 by SCMPDS_2:39;
A20: now
      per cases;
      suppose
A21:    s1.DataLoc(s1.a,k1) <> 0;
        then
A22:    s2.DataLoc(s2.a,k1) <> 0 by A1,Th14;
        thus IC Exec(i,s1) = ICplusConst(s1,k2) by A19,A21,SCMPDS_2:67
          .= ICplusConst(s2,k2) by A2,SCMPDS_3:2
          .= IC Exec(i,s2) by A19,A22,SCMPDS_2:67;
      end;
      suppose
A23:    s1.DataLoc(s1.a,k1) = 0;
        then
A24:    s2.DataLoc(s2.a,k1) = 0 by A1,Th14;
        thus IC Exec(i,s1) = Next IC s2 by A2,A19,A23,SCMPDS_2:67
          .= IC Exec(i,s2) by A19,A24,SCMPDS_2:67;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A19,SCMPDS_2:67
        .=s2.a by A1,Th13
        .=Exec(i, s2).a by A19,SCMPDS_2:67;
    end;
    hence thesis by A20,Th11;
  end;
  suppose
    InsCode i = 5;
    then consider a,k1,k2 such that
A25: i = (a,k1)<=0_goto k2 by SCMPDS_2:40;
A26: now
      per cases;
      suppose
A27:    s1.DataLoc(s1.a,k1) <= 0;
        then
A28:    s2.DataLoc(s2.a,k1) <= 0 by A1,Th14;
        thus IC Exec(i,s1) = ICplusConst(s1,k2) by A25,A27,SCMPDS_2:68
          .= ICplusConst(s2,k2) by A2,SCMPDS_3:2
          .= IC Exec(i,s2) by A25,A28,SCMPDS_2:68;
      end;
      suppose
A29:    s1.DataLoc(s1.a,k1) > 0;
        then
A30:    s2.DataLoc(s2.a,k1) > 0 by A1,Th14;
        thus IC Exec(i,s1) = Next IC s2 by A2,A25,A29,SCMPDS_2:68
          .= IC Exec(i,s2) by A25,A30,SCMPDS_2:68;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A25,SCMPDS_2:68
        .=s2.a by A1,Th13
        .=Exec(i, s2).a by A25,SCMPDS_2:68;
    end;
    hence thesis by A26,Th11;
  end;
  suppose
    InsCode i = 6;
    then consider a,k1,k2 such that
A31: i = (a,k1)>=0_goto k2 by SCMPDS_2:41;
A32: now
      per cases;
      suppose
A33:    s1.DataLoc(s1.a,k1) >= 0;
        then
A34:    s2.DataLoc(s2.a,k1) >= 0 by A1,Th14;
        thus IC Exec(i,s1) = ICplusConst(s1,k2) by A31,A33,SCMPDS_2:69
          .= ICplusConst(s2,k2) by A2,SCMPDS_3:2
          .= IC Exec(i,s2) by A31,A34,SCMPDS_2:69;
      end;
      suppose
A35:    s1.DataLoc(s1.a,k1) < 0;
        then
A36:    s2.DataLoc(s2.a,k1) < 0 by A1,Th14;
        thus IC Exec(i,s1) = Next IC s2 by A2,A31,A35,SCMPDS_2:69
          .= IC Exec(i,s2) by A31,A36,SCMPDS_2:69;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A31,SCMPDS_2:69
        .=s2.a by A1,Th13
        .=Exec(i, s2).a by A31,SCMPDS_2:69;
    end;
    hence thesis by A32,Th11;
  end;
  suppose
    InsCode i = 7;
    then consider a,k1,k2 such that
A37: i = (a,k1) := k2 by SCMPDS_2:42;
A38: now
      let b;
      per cases;
      suppose
A39:    DataLoc(s1.a,k1)=b;
        then
A40:    DataLoc(s2.a,k1)=b by A1,Th13;
        thus Exec(i, s1).b= k2 by A37,A39,SCMPDS_2:58
          .=Exec(i,s2).b by A37,A40,SCMPDS_2:58;
      end;
      suppose
A41:    DataLoc(s1.a,k1)<>b;
        then
A42:    DataLoc(s2.a,k1)<>b by A1,Th13;
        thus Exec(i,s1).b = s1.b by A37,A41,SCMPDS_2:58
          .=s2.b by A1,Th13
          .=Exec(i,s2).b by A37,A42,SCMPDS_2:58;
      end;
    end;
    IC Exec(i,s1) = Next IC s2 by A2,A37,SCMPDS_2:58
      .= IC Exec(i,s2) by A37,SCMPDS_2:58;
    hence thesis by A38,Th11;
  end;
  suppose
    InsCode i = 8;
    then consider a,k1,k2 such that
A43: i = AddTo(a,k1,k2) by SCMPDS_2:43;
A44: now
      let b;
      per cases;
      suppose
A45:    DataLoc(s1.a,k1)=b;
        then
A46:    DataLoc(s2.a,k1)=b by A1,Th13;
        thus Exec(i, s1).b= s1.DataLoc(s1.a,k1)+k2 by A43,A45,SCMPDS_2:60
          .= s2.DataLoc(s2.a,k1)+k2 by A1,Th14
          .=Exec(i,s2).b by A43,A46,SCMPDS_2:60;
      end;
      suppose
A47:    DataLoc(s1.a,k1)<>b;
        then
A48:    DataLoc(s2.a,k1)<>b by A1,Th13;
        thus Exec(i,s1).b = s1.b by A43,A47,SCMPDS_2:60
          .=s2.b by A1,Th13
          .=Exec(i,s2).b by A43,A48,SCMPDS_2:60;
      end;
    end;
    IC Exec(i,s1) = Next IC s2 by A2,A43,SCMPDS_2:60
      .= IC Exec(i,s2) by A43,SCMPDS_2:60;
    hence thesis by A44,Th11;
  end;
  suppose
    InsCode i = 9;
    then consider a,b,k1,k2 such that
A49: i = AddTo(a,k1,b,k2) by SCMPDS_2:44;
A50: now
      let c;
      per cases;
      suppose
A51:    DataLoc(s1.a,k1)=c;
        then
A52:    DataLoc(s2.a,k1)=c by A1,Th13;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)+s1.DataLoc(s1.b,k2) by A49,A51
,SCMPDS_2:61
          .= s2.DataLoc(s2.a,k1)+s1.DataLoc(s1.b,k2) by A1,Th14
          .= s2.DataLoc(s2.a,k1)+s2.DataLoc(s2.b,k2) by A1,Th14
          .=Exec(i,s2).c by A49,A52,SCMPDS_2:61;
      end;
      suppose
A53:    DataLoc(s1.a,k1)<>c;
        then
A54:    DataLoc(s2.a,k1)<>c by A1,Th13;
        thus Exec(i,s1).c = s1.c by A49,A53,SCMPDS_2:61
          .=s2.c by A1,Th13
          .=Exec(i,s2).c by A49,A54,SCMPDS_2:61;
      end;
    end;
    IC Exec(i,s1) = Next IC s2 by A2,A49,SCMPDS_2:61
      .= IC Exec(i,s2) by A49,SCMPDS_2:61;
    hence thesis by A50,Th11;
  end;
  suppose
    InsCode i = 10;
    then consider a,b,k1,k2 such that
A55: i = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
A56: now
      let c;
      per cases;
      suppose
A57:    DataLoc(s1.a,k1)=c;
        then
A58:    DataLoc(s2.a,k1)=c by A1,Th13;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)-s1.DataLoc(s1.b,k2) by A55,A57
,SCMPDS_2:62
          .= s2.DataLoc(s2.a,k1)-s1.DataLoc(s1.b,k2) by A1,Th14
          .= s2.DataLoc(s2.a,k1)-s2.DataLoc(s2.b,k2) by A1,Th14
          .=Exec(i,s2).c by A55,A58,SCMPDS_2:62;
      end;
      suppose
A59:    DataLoc(s1.a,k1)<>c;
        then
A60:    DataLoc(s2.a,k1)<>c by A1,Th13;
        thus Exec(i,s1).c = s1.c by A55,A59,SCMPDS_2:62
          .=s2.c by A1,Th13
          .=Exec(i,s2).c by A55,A60,SCMPDS_2:62;
      end;
    end;
    IC Exec(i,s1) = Next IC s2 by A2,A55,SCMPDS_2:62
      .= IC Exec(i,s2) by A55,SCMPDS_2:62;
    hence thesis by A56,Th11;
  end;
  suppose
    InsCode i = 11;
    then consider a,b,k1,k2 such that
A61: i = MultBy(a,k1,b,k2) by SCMPDS_2:46;
A62: now
      let c;
      per cases;
      suppose
A63:    DataLoc(s1.a,k1)=c;
        then
A64:    DataLoc(s2.a,k1)=c by A1,Th13;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)*s1.DataLoc(s1.b,k2) by A61,A63
,SCMPDS_2:63
          .= s2.DataLoc(s2.a,k1)*s1.DataLoc(s1.b,k2) by A1,Th14
          .= s2.DataLoc(s2.a,k1)*s2.DataLoc(s2.b,k2) by A1,Th14
          .=Exec(i,s2).c by A61,A64,SCMPDS_2:63;
      end;
      suppose
A65:    DataLoc(s1.a,k1)<>c;
        then
A66:    DataLoc(s2.a,k1)<>c by A1,Th13;
        thus Exec(i,s1).c = s1.c by A61,A65,SCMPDS_2:63
          .=s2.c by A1,Th13
          .=Exec(i,s2).c by A61,A66,SCMPDS_2:63;
      end;
    end;
    IC Exec(i,s1) = Next IC s2 by A2,A61,SCMPDS_2:63
      .= IC Exec(i,s2) by A61,SCMPDS_2:63;
    hence thesis by A62,Th11;
  end;
  suppose
    InsCode i = 12;
    then consider a,b,k1,k2 such that
A67: i = Divide(a,k1,b,k2) by SCMPDS_2:47;
A68: now
      let c;
      per cases;
      suppose
A69:    DataLoc(s1.b,k2)=c;
        then
A70:    DataLoc(s2.b,k2)=c by A1,Th13;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) mod s1.DataLoc(s1.b,k2) by A67
,A69,SCMPDS_2:64
          .= s2.DataLoc(s2.a,k1) mod s1.DataLoc(s1.b,k2) by A1,Th14
          .= s2.DataLoc(s2.a,k1) mod s2.DataLoc(s2.b,k2) by A1,Th14
          .= Exec(i,s2).c by A67,A70,SCMPDS_2:64;
      end;
      suppose
A71:    DataLoc(s1.b,k2)<>c;
        then
A72:    DataLoc(s2.b,k2)<>c by A1,Th13;
        hereby
          per cases;
          suppose
A73:        DataLoc(s1.a,k1)<>c;
            then
A74:        DataLoc(s2.a,k1)<>c by A1,Th13;
            thus Exec(i, s1).c = s1.c by A67,A71,A73,SCMPDS_2:64
              .=s2.c by A1,Th13
              .=Exec(i,s2).c by A67,A72,A74,SCMPDS_2:64;
          end;
          suppose
A75:        DataLoc(s1.a,k1)=c;
            then
A76:        DataLoc(s2.a,k1)=c by A1,Th13;
            thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) div s1.DataLoc(s1.b,k2)
            by A67,A71,A75,SCMPDS_2:64
              .= s2.DataLoc(s2.a,k1) div s1.DataLoc(s1.b,k2) by A1,Th14
              .= s2.DataLoc(s2.a,k1) div s2.DataLoc(s2.b,k2) by A1,Th14
              .= Exec(i,s2).c by A67,A72,A76,SCMPDS_2:64;
          end;
        end;
      end;
    end;
    IC Exec(i,s1) = Next IC s2 by A2,A67,SCMPDS_2:64
      .= IC Exec(i,s2) by A67,SCMPDS_2:64;
    hence thesis by A68,Th11;
  end;
  suppose
    InsCode i = 13;
    then consider a,b,k1,k2 such that
A77: i = (a,k1):=(b,k2) by SCMPDS_2:48;
A78: now
      let c;
      per cases;
      suppose
A79:    DataLoc(s1.a,k1)=c;
        then
A80:    DataLoc(s2.a,k1)=c by A1,Th13;
        thus Exec(i, s1).c = s1.DataLoc(s1.b,k2) by A77,A79,SCMPDS_2:59
          .= s2.DataLoc(s2.b,k2) by A1,Th14
          .=Exec(i,s2).c by A77,A80,SCMPDS_2:59;
      end;
      suppose
A81:    DataLoc(s1.a,k1)<>c;
        then
A82:    DataLoc(s2.a,k1)<>c by A1,Th13;
        thus Exec(i,s1).c = s1.c by A77,A81,SCMPDS_2:59
          .=s2.c by A1,Th13
          .=Exec(i,s2).c by A77,A82,SCMPDS_2:59;
      end;
    end;
    IC Exec(i,s1) = Next IC s2 by A2,A77,SCMPDS_2:59
      .= IC Exec(i,s2) by A77,SCMPDS_2:59;
    hence thesis by A78,Th11;
  end;
end;

theorem
  (Initialized I)|NAT = I
proof
A1: now
    assume
    IC SCMPDS in NAT;
    then reconsider l=IC SCMPDS as Instruction-Location of SCMPDS by
AMI_1:def 4;
    l=IC SCMPDS;
    hence contradiction by AMI_1:48;
  end;
  dom I c= NAT & dom Start-At(inspos 0) = { IC SCMPDS } by FUNCOP_1:19
,RELAT_1:def 18;
  hence thesis by A1,FUNCT_4:82,ZFMISC_1:56;
end;

theorem Th17:
  for k1,k2 be Element of NAT st k1 <> k2 holds DataLoc(k1,0) <>
  DataLoc(k2,0)
proof
  let k1,k2 be Element of NAT;
  assume
A1: k1<>k2;
  assume
  DataLoc(k1,0) = DataLoc(k2,0);
  then abs(k1+0) =abs(k2+0) by ZFMISC_1:33;
  then k1=abs(k2) by ABSVALUE:def 1;
  hence contradiction by A1,ABSVALUE:def 1;
end;

theorem Th18:
  for dl being Int_position ex i being Element of NAT st dl =
  DataLoc(i,0)
proof
  let dl be Int_position;
  dl in SCM-Data-Loc by SCMPDS_2:def 2;
  then consider i being Element of NAT such that
A1: dl = [1,i] by AMI_2:32;
  take i;
  thus thesis by A1,ABSVALUE:def 1;
end;

scheme
  SCMPDSEx{ F(set) -> Instruction of SCMPDS, G(set) -> Integer, I() ->
  Instruction-Location of SCMPDS }: ex S being State of SCMPDS st IC S = I() &
  for i being Element of NAT holds S.inspos i = F(i) & S.DataLoc(i,0) = G(i)
proof
  set S1={IC SCMPDS }, S2=SCM-Data-Loc, S3=NAT;
  defpred P[set,set] means ex m st $1 = IC SCMPDS & $2 = I() or $1 = inspos m
  & $2 = F(m) or $1 = DataLoc(m,0) & $2 = G(m);
A1: for e being set st e in the carrier of SCMPDS ex u being set st P[e,u]
  proof
    let e be set;
    assume
    e in the carrier of SCMPDS;
    then
A2: e in S1 \/ S2 or e in S3 by SCMPDS_3:5,XBOOLE_0:def 3;
    now
      per cases by A2,XBOOLE_0:def 3;
      case
        e in S1;
        hence e = IC SCMPDS by TARSKI:def 1;
      end;
      case
        e in S2;
        then e is Int_position by SCMPDS_2:9;
        hence ex m st e = DataLoc(m,0) by Th18;
      end;
      case
        e in S3;
        then reconsider l=e as Instruction-Location of SCMPDS by AMI_1:def 4;
        reconsider m = l as Element of NAT by ORDINAL1:def 13;
        e = inspos m;
        hence ex m st e = inspos m;
      end;
    end;
    then consider m such that
A3: e = IC SCMPDS or e = inspos m or e = DataLoc(m,0);
    per cases by A3;
    suppose
A4:   e = IC SCMPDS;
      take u = I();
      thus thesis by A4;
    end;
    suppose
A5:   e = inspos m;
      take u = F(m);
      thus thesis by A5;
    end;
    suppose
A6:   e = DataLoc(m,0);
      take u = G(m);
      thus thesis by A6;
    end;
  end;
  consider f being Function such that
A7: dom f = the carrier of SCMPDS and
A8: for e being set st e in the carrier of SCMPDS holds P[e,f.e] from
  CLASSES1:sch 1(A1);
A9: dom the Object-Kind of SCMPDS = the carrier of SCMPDS by FUNCT_2:def 1;
  now
    let x be set;
    assume
A10: x in dom the Object-Kind of SCMPDS;
    then
A11: x in S1 \/ S2 or x in S3 by A9,SCMPDS_3:5,XBOOLE_0:def 3;
    consider m such that
A12: x = IC SCMPDS & f.x = I() or x = inspos m & f.x = F(m) or x =
    DataLoc(m,0) & f.x = G(m) by A8,A9,A10;
    per cases by A11,XBOOLE_0:def 3;
    suppose
      x in S2;
      then
A13:  x is Int_position by SCMPDS_2:9;
      then (the Object-Kind of SCMPDS).x = ObjectKind DataLoc(m,0) by A12,
SCMPDS_2:52,53
        .= INT by SCMPDS_2:13;
      hence f.x in (the Object-Kind of SCMPDS).x by A12,A13,INT_1:def 2
,SCMPDS_2:53;
    end;
    suppose
A14:  x in S1;
      then (the Object-Kind of SCMPDS).x = ObjectKind IC SCMPDS by TARSKI:def 1
        .= NAT by AMI_1:def 11;
      hence f.x in (the Object-Kind of SCMPDS).x by A12,A14,AMI_1:def 4
,SCMPDS_2:6,TARSKI:def 1;
    end;
    suppose
      x in NAT;
      then reconsider l=x as Instruction-Location of SCMPDS by AMI_1:def 4;
      (the Object-Kind of SCMPDS).l = ObjectKind inspos m by A12,AMI_1:48
,SCMPDS_2:53
        .= the Instructions of SCMPDS by AMI_1:def 14;
      hence f.x in (the Object-Kind of SCMPDS).x by A12,AMI_1:48,SCMPDS_2:53;
    end;
  end;
  then reconsider f as State of SCMPDS by A7,A9,CARD_3:18;
  consider m such that
A15: IC SCMPDS = IC SCMPDS & f.IC SCMPDS = I() or IC SCMPDS = inspos m &
  f.IC SCMPDS = F(m) or IC SCMPDS = DataLoc(m,0) & f.IC SCMPDS = G(m) by A8;
  take f;
  il.m <> IC SCMPDS by SCMPDS_2:98;
  hence IC f = I() by A15,SCMPDS_2:52;
  let i be Element of NAT;
A16: il.i <> IC SCMPDS by SCMPDS_2:98;
  ex m st ( inspos i = IC SCMPDS & f.inspos i = I() or inspos i = inspos m
  & f.inspos i = F(m) or inspos i = DataLoc(m,0) & f.inspos i = G(m) ) by A8;
  hence f.inspos i = F(i) by A16,SCMPDS_2:53;
  ex m st ( DataLoc(i,0) = IC SCMPDS & f.DataLoc(i,0) = I() or DataLoc(i,0
) = inspos m & f.DataLoc(i,0) = F(m) or DataLoc(i,0) = DataLoc(m,0) & f.DataLoc
  (i,0) = G(m)) by A8;
  hence thesis by Th17,SCMPDS_2:52,53;
end;

theorem
  for s being State of SCMPDS holds dom s = {IC SCMPDS} \/ SCM-Data-Loc
  \/ NAT by AMI_1:79,SCMPDS_3:5;

theorem
  for s being State of SCMPDS, x being set st x in dom s holds x is
  Int_position or x = IC SCMPDS or x is Instruction-Location of SCMPDS
proof
  set S1={IC SCMPDS}, S2=SCM-Data-Loc, S3=NAT;
  let s be State of SCMPDS;
  let x be set;
  assume
A1: x in dom s;
  dom s = S1 \/ S2 \/ S3 by AMI_1:79,SCMPDS_3:5;
  then x in S1 \/ S2 or x in S3 by A1,XBOOLE_0:def 3;
  then x in S1 or x in S2 or x in S3 by XBOOLE_0:def 3;
  hence thesis by AMI_1:def 4,SCMPDS_2:9,TARSKI:def 1;
end;

theorem
  for s1,s2 being State of SCMPDS holds (for l being
  Instruction-Location of SCMPDS holds s1.l = s2.l) iff s1 | NAT = s2 | NAT
proof
  let s1,s2 be State of SCMPDS;
A1: (for l being Instruction-Location of SCMPDS holds s1.l = s2.l) implies
  for l being set st l in NAT holds s1.l = s2.l
  proof
    assume
A2: for l being Instruction-Location of SCMPDS holds s1.l = s2.l;
    let x be set;
    assume
    x in NAT;
    then reconsider l=x as Instruction-Location of SCMPDS by AMI_1:def 4;
    s1.l = s2.l by A2;
    hence thesis;
  end;
A3: (for l being set st l in NAT holds s1.l = s2.l) implies for l being
  Instruction-Location of SCMPDS holds s1.l = s2.l
  proof
    assume
A4: for l being set st l in NAT holds s1.l = s2.l;
    let l be Instruction-Location of SCMPDS;
    l in NAT by AMI_1:def 4;
    hence thesis by A4;
  end;
  NAT c= dom s1 & NAT c= dom s2 by AMI_1:114;
  hence thesis by A1,A3,FUNCT_1:165;
end;

theorem
  for i being Instruction-Location of SCMPDS holds not i in SCM-Data-Loc
proof
  let i be Instruction-Location of SCMPDS;
  i in NAT by AMI_1:def 4;
  hence thesis by AMI_2:29,XBOOLE_0:3;
end;

theorem Th23:
  for s1,s2 being State of SCMPDS holds (for a being Int_position
  holds s1.a = s2.a) iff DataPart s1 = DataPart s2
proof
  set T1={IC SCMPDS}, T2=SCM-Data-Loc, T3=NAT;
  let s1,s2 be State of SCMPDS;
A1: T1 \/ T2 \/ T3=T2 \/ (T1 \/ T3) by XBOOLE_1:4;
A2: now
    assume
A3: for a being Int_position holds s1.a = s2.a;
    hereby
      let x be set;
      assume
      x in SCM-Data-Loc;
      then x is Int_position by SCMPDS_2:9;
      hence s1.x=s2.x by A3;
    end;
  end;
A4: now
    assume
A5: for x be set st x in SCM-Data-Loc holds s1.x = s2.x;
    hereby
      let a be Int_position;
      a in SCM-Data-Loc by SCMPDS_2:def 2;
      hence s1.a=s2.a by A5;
    end;
  end;
  dom s2 = T1 \/ T2 \/ T3 by AMI_1:79,SCMPDS_3:5;
  then
A6: T2 c= dom s2 by A1,XBOOLE_1:7;
  dom s1 = T1 \/ T2 \/ T3 by AMI_1:79,SCMPDS_3:5;
  then T2 c= dom s1 by A1,XBOOLE_1:7;
  hence thesis by A6,A2,A4,FUNCT_1:165,SCMPDS_2:100;
end;

theorem
  for s1,s2 being State of SCMPDS st s1,s2 equal_outside NAT holds
  DataPart s1 = DataPart s2
proof
  let s1,s2 be State of SCMPDS;
  assume
  s1,s2 equal_outside NAT;
  then for a being Int_position holds s1.a = s2.a by Th13;
  hence thesis by Th23;
end;

canceled;

theorem
  for I,J being Program of SCMPDS holds I,J equal_outside NAT
proof
  let I,J be Program of SCMPDS;
  dom I c= NAT by RELAT_1:def 18;
  then dom I \ NAT = {} by XBOOLE_1:37;
  then
A1: dom (I | (dom I \ NAT)) = {} by RELAT_1:191;
  dom J c= NAT by RELAT_1:def 18;
  then dom J \ NAT = {} by XBOOLE_1:37;
  then
A2: dom (J | (dom J \ NAT)) = {} by RELAT_1:191;
  for x be set st x in {} holds (I | (dom I \ NAT)).x = (J | (dom J \ NAT)
  ).x;
  then I | (dom I \ NAT) = J | (dom J \ NAT) by A1,A2,FUNCT_1:9;
  hence thesis by FUNCT_7:def 2;
end;

theorem Th27:
  for I being Program of SCMPDS holds dom Initialized I = dom I \/
  {IC SCMPDS}
proof
  let I be Program of SCMPDS;
  thus dom Initialized I = dom I \/ dom Start-At(inspos 0) by FUNCT_4:def 1
    .= dom I \/ {IC SCMPDS} by FUNCOP_1:19;
end;

theorem Th28:
  for I being Program of SCMPDS, x being set st x in dom
  Initialized I holds x in dom I or x = IC SCMPDS
proof
  let I be Program of SCMPDS;
  let x be set;
  assume
A1: x in dom Initialized I;
  dom Initialized I = dom I \/ {IC SCMPDS} by Th27;
  then x in dom I or x in {IC SCMPDS} by A1,XBOOLE_0:def 3;
  hence thesis by TARSKI:def 1;
end;

theorem Th29:
  for I being Program of SCMPDS holds (Initialized I).IC SCMPDS =
  inspos 0
proof
  let I be Program of SCMPDS;
  IC SCMPDS in {IC SCMPDS} by TARSKI:def 1;
  then IC SCMPDS in dom Start-At inspos 0 by FUNCOP_1:19;
  hence (Initialized I).IC SCMPDS = (Start-At (inspos 0)).IC SCMPDS by
FUNCT_4:14
    .= inspos 0 by FUNCOP_1:87;
end;

theorem Th30:
  for I being Program of SCMPDS holds not IC SCMPDS in dom I
proof
  let I be Program of SCMPDS;
  assume
A1: IC SCMPDS in dom I;
  dom I c= NAT by RELAT_1:def 18;
  then reconsider l=IC SCMPDS as Instruction-Location of SCMPDS by A1,
AMI_1:def 4;
  l = IC SCMPDS;
  hence contradiction by AMI_1:48;
end;

theorem Th31:
  for I being Program of SCMPDS, a being Int_position holds not a
  in dom Initialized I
proof
  let I be Program of SCMPDS;
  let a be Int_position;
  assume
  a in dom Initialized I;
  then
A1: a in dom I \/ {IC SCMPDS} by Th27;
  per cases by A1,XBOOLE_0:def 3;
  suppose
A2: a in dom I;
    dom I c= NAT by RELAT_1:def 18;
    then reconsider l=a as Instruction-Location of SCMPDS by A2,AMI_1:def 4;
    l=a;
    hence contradiction by SCMPDS_2:53;
  end;
  suppose
    a in {IC SCMPDS};
    then a = IC SCMPDS by TARSKI:def 1;
    hence contradiction by SCMPDS_2:52;
  end;
end;

reserve x for set;

theorem Th32:
  x in dom I implies I.x = (I +* Start-At inspos n).x
proof
A1: dom I c= NAT by RELAT_1:def 18;
  assume
  x in dom I;
  then reconsider l=x as Instruction-Location of SCMPDS by A1,AMI_1:def 4;
  dom Start-At inspos n = {IC SCMPDS} & l <> IC SCMPDS by AMI_1:48,FUNCOP_1:19;
  then not x in dom Start-At inspos n by TARSKI:def 1;
  hence thesis by FUNCT_4:12;
end;

theorem
  for I being Program of SCMPDS, x being set st x in dom I holds I.x = (
  Initialized I).x by Th32;

theorem Th34:
  for I,J being Program of SCMPDS for s being State of SCMPDS st
  Initialized J c= s holds s +* Initialized I = s +* I
proof
  let I,J be Program of SCMPDS;
  let s be State of SCMPDS;
  set s1 = s +* I;
A1: dom (s +* I) = dom s \/ dom I by FUNCT_4:def 1;
  assume
A2: Initialized J c= s;
  then
A3: dom Initialized J c= dom s by GRFUNC_1:8;
A4: dom (s +* Initialized I) = dom s \/ dom Initialized I by FUNCT_4:def 1;
  dom J \/ dom Initialized I = dom J \/ (dom I \/ {IC SCMPDS}) by Th27
    .= dom J \/ {IC SCMPDS} \/ dom I by XBOOLE_1:4
    .= dom Initialized J \/ dom I by Th27;
  then dom J \/ dom Initialized I c= dom s \/ dom I by A3,XBOOLE_1:13;
  then dom J \/ dom Initialized I c= dom s1 by FUNCT_4:def 1;
  then dom Initialized I c= dom s1 by XBOOLE_1:11;
  then dom (s +* Initialized I) c= dom s \/ (dom s \/ dom I) by A1,A4,
XBOOLE_1:9;
  then
A5: dom (s +* Initialized I) c= dom s \/ dom s \/ dom I by XBOOLE_1:4;
  I c= Initialized I by Th9;
  then
A6: dom I c= dom Initialized I by GRFUNC_1:8;
A7: now
    let x be set;
    assume
A8: x in dom Initialized I;
    per cases by A8,Th28;
    suppose
A9:   x in dom I;
      hence (Initialized I).x = I.x by Th32
        .= s1.x by A9,FUNCT_4:14;
    end;
    suppose
A10:  x = IC SCMPDS;
      then
A11:  x in dom Initialized J by Th7;
A12:  not x in dom I by A10,Th30;
      thus (Initialized I).x = inspos 0 by A10,Th29
        .= (Initialized J).x by A10,Th29
        .= s.x by A2,A11,GRFUNC_1:8
        .= s1.x by A12,FUNCT_4:12;
    end;
  end;
A13: now
    let x be set;
    assume
    x in dom (s +* Initialized I);
    per cases;
    suppose
A14:  x in dom Initialized I;
      hence (s +* Initialized I).x = (Initialized I).x by FUNCT_4:14
        .= (s +* I).x by A7,A14;
    end;
    suppose
A15:  not x in dom Initialized I;
      then
A16:  not x in dom I by A6;
      thus (s +* Initialized I).x = s.x by A15,FUNCT_4:12
        .= (s +* I).x by A16,FUNCT_4:12;
    end;
  end;
  dom (s +* I) c= dom (s +* Initialized I) by A1,A4,A6,XBOOLE_1:9;
  then dom (s +* Initialized I) = dom (s +* I) by A1,A5,XBOOLE_0:def 10;
  hence thesis by A13,FUNCT_1:9;
end;

theorem
  for I,J being Program of SCMPDS for s being State of SCMPDS st
  Initialized J c= s holds Initialized I c= s +* I
proof
  let I,J be Program of SCMPDS;
  let s be State of SCMPDS;
  assume
  Initialized J c= s;
  then s +* Initialized I = s +* I by Th34;
  hence thesis by FUNCT_4:26;
end;

theorem
  for I,J being Program of SCMPDS for s being State of SCMPDS holds s +*
  Initialized I, s +* Initialized J equal_outside NAT
proof
  let I,J be Program of SCMPDS;
  let s be State of SCMPDS;
A1: IC SCMPDS in dom Initialized I by Th7;
A2: now
    let a be Int_position;
A3: not a in dom Initialized I by Th31;
    not a in dom Initialized J by Th31;
    hence (s +* Initialized J).a = s.a by FUNCT_4:12
      .= (s +* Initialized I).a by A3,FUNCT_4:12;
  end;
  IC SCMPDS in dom Initialized J by Th7;
  then IC (s +* Initialized J) = (Initialized J).IC SCMPDS by FUNCT_4:14
    .= inspos 0 by Th29
    .= (Initialized I).IC SCMPDS by Th29
    .= IC (s +* Initialized I) by A1,FUNCT_4:14;
  hence thesis by A2,Th11;
end;

begin :: Combining two consecutive blocks into one program block

definition
  let I,J be Program of SCMPDS;
  func I ';' J -> Program of SCMPDS equals
  I +* Shift(J, card I);
  coherence
  proof
    set P = I +* Shift(J,card I);
    P is initial
    proof
      set D = {l+card I: l in dom J };
      let m,n be Nat such that
A1:   n in dom P and
A2:   m < n;
      dom Shift(J,card I) = D by VALUED_1:def 12;
      then
A3:   dom P = dom I \/ D by FUNCT_4:def 1;
      per cases by A1,A3,XBOOLE_0:def 3;
      suppose
        n in dom I;
        then m in dom I by A2,SCMNORM:def 1;
        hence thesis by A3,XBOOLE_0:def 3;
      end;
      suppose
        n in D;
        then consider l such that
A4:     n = l+card I and
A5:     l in dom J;
        now
          per cases;
          case
            m < card I;
            then m in dom I by Th1;
            hence thesis by A3,XBOOLE_0:def 3;
          end;
          case
            m >= card I;
            then consider l1 being Nat such that
A6:         m = card I + l1 by NAT_1:10;
            reconsider l1 as Element of NAT by ORDINAL1:def 13;
            l1 < l by A2,A4,A6,XREAL_1:8;
            then l1 in dom J by A5,SCMNORM:def 1;
            hence m in D by A6;
          end;
        end;
        hence thesis by A3,XBOOLE_0:def 3;
      end;
    end;
    hence thesis;
  end;
  correctness;
end;

theorem Th37:
  for I,J being Program of SCMPDS, l being Instruction-Location of
  SCMPDS st l in dom I holds (I ';' J).l = I.l
proof
  let I,J be Program of SCMPDS, l be Instruction-Location of SCMPDS such that
A1: l in dom I;
  now
    assume
    l in dom Shift(J,card I);
    then l in { m+card I: m in dom J } by VALUED_1:def 12;
    then consider m such that
A2: l = m+card I and
    m in dom J;
    m + card I < card I by A1,A2,Th1;
    hence contradiction by NAT_1:11;
  end;
  hence thesis by FUNCT_4:12;
end;

theorem Th38:
  for I,J being Program of SCMPDS, l being Instruction-Location of
  SCMPDS st l in dom J holds (I ';' J).(l+card I)= J.l
proof
  let I,J be Program of SCMPDS, l be Instruction-Location of SCMPDS such that
A1: l in dom J;
  reconsider n = l as Element of NAT by ORDINAL1:def 13;
  inspos(n+card I) in { m+card I: m in dom J } by A1;
  then l+card I in dom Shift(J,card I) by VALUED_1:def 12;
  hence (I ';' J).(l+card I) = Shift(J, card I).(n+card I) by FUNCT_4:14
    .=J.l by A1,VALUED_1:def 12;
end;

theorem Th39:
  for I,J being Program of SCMPDS holds dom I c= dom (I ';' J)
proof
  let I,J be Program of SCMPDS;
  dom (I ';' J) = dom I \/ dom Shift(J,card I) by FUNCT_4:def 1;
  hence thesis by XBOOLE_1:7;
end;

theorem
  for I,J being Program of SCMPDS holds I c= I ';' J
proof
  let I,J be Program of SCMPDS;
A1: now
    let x be set;
    assume
A2: x in dom I;
    dom I misses dom Shift(J,card I) by Th2;
    then not x in dom Shift(J,card I) by A2,XBOOLE_0:3;
    hence I.x = (I ';' J).x by FUNCT_4:12;
  end;
  dom I c= dom (I ';' J) by Th39;
  hence thesis by A1,GRFUNC_1:8;
end;

theorem
  for I,J being Program of SCMPDS holds I +* (I ';' J) = (I ';' J)
proof
  let I,J be Program of SCMPDS;
A1: for x be set st x in dom (I ';' J) holds (I +* (I ';' J)).x = (I ';' J).
  x by FUNCT_4:14;
  dom (I +* (I ';' J)) = dom I \/ dom (I ';' J) by FUNCT_4:def 1
    .= dom (I ';' J) by Th39,XBOOLE_1:12;
  hence thesis by A1,FUNCT_1:9;
end;

theorem
  for I,J being Program of SCMPDS holds Initialized I +* (I ';' J) =
  Initialized (I ';' J)
proof
  let I,J be Program of SCMPDS;
A1: dom I \/ dom (I ';' J) = dom (I ';' J) by Th39,XBOOLE_1:12;
A2: now
    let x be set;
    assume
A3: x in dom Initialized (I ';' J);
    per cases by A3,Th28;
    suppose
A4:   x in dom (I ';' J);
      then x <> IC SCMPDS by Th30;
      then not x in {IC SCMPDS} by TARSKI:def 1;
      then
A5:   not x in dom Start-At inspos 0 by FUNCOP_1:19;
      thus (Initialized I+*(I ';' J)).x = (I ';' J).x by A4,FUNCT_4:14
        .= (Initialized (I ';' J)).x by A5,FUNCT_4:12;
    end;
    suppose
A6:   x = IC SCMPDS;
      then not x in dom (I ';' J) by Th30;
      hence (Initialized I+*(I ';' J)).x = (Initialized I).x by FUNCT_4:12
        .= inspos 0 by A6,Th29
        .= (Initialized (I ';' J)).x by A6,Th29;
    end;
  end;
  dom (Initialized I+*(I ';' J)) = dom Initialized I \/ dom (I ';' J) by
FUNCT_4:def 1
    .= dom I \/ {IC SCMPDS} \/ dom (I ';' J) by Th27
    .= dom I \/ dom (I ';' J) \/ {IC SCMPDS} by XBOOLE_1:4
    .= dom Initialized (I ';' J) by A1,Th27;
  hence thesis by A2,FUNCT_1:9;
end;

begin :: Combining a block and a instruction into one program block

definition
  let i, J;
  func i ';' J -> Program of SCMPDS equals
  Load i ';' J;
  correctness;
end;

definition
  let I, j;
  func I ';' j -> Program of SCMPDS equals
  I ';' Load j;
  correctness;
end;

definition
  let i,j;
  func i ';' j -> Program of SCMPDS equals
  Load i ';' Load j;
  correctness;
end;

theorem
  i ';' j = Load i ';' j;

theorem
  i ';' j = i ';' Load j;

theorem Th45:
  card(I ';' J) = card I + card J
proof
A1: card dom(I ';' J) = card(I ';' J) & card dom I = card I by CARD_1:104;
A2: card dom J = card J & dom(I ';' J) = dom I \/ dom Shift(J, card I) by
CARD_1:104,FUNCT_4:def 1;
  card dom Shift(J, card I) = card Shift(J, card I) by CARD_1:104
    .= card J by Th3
    .= card dom J by CARD_1:104;
  hence thesis by A1,A2,Th2,CARD_2:53;
end;

theorem Th46:
  I ';' J ';' K = I ';' (J ';' K)
proof
  Shift(J ';' K, card I) = Shift(J,card I) +* Shift(Shift(K, card J), card
  I) by VALUED_1:24
    .= Shift(J,card I) +* Shift(K, card J+card I) by VALUED_1:22
    .= Shift(J,card I) +* Shift(K, card ( I ';'J)) by Th45;
  hence thesis by FUNCT_4:15;
end;

theorem
  I ';' J ';' k = I ';' (J ';' k) by Th46;

theorem
  I ';' j ';' K = I ';' (j ';' K) by Th46;

theorem
  I ';' j ';' k = I ';' (j ';' k) by Th46;

theorem
  i ';' J ';' K = i ';' (J ';' K) by Th46;

theorem
  i ';' J ';' k = i ';' (J ';' k) by Th46;

theorem
  i ';' j ';' K = i ';' (j ';' K) by Th46;

theorem
  i ';' j ';' k = i ';' (j ';' k) by Th46;

theorem Th54:
  dom I misses dom Start-At inspos n
proof
A1: dom Start-At inspos n = {IC SCMPDS} by FUNCOP_1:19;
  assume
  dom I /\ dom (Start-At inspos n) <> {};
  then consider x being set such that
A2: x in dom I /\ dom (Start-At inspos n) by XBOOLE_0:def 1;
  x in dom I & x in dom (Start-At inspos n) by A2,XBOOLE_0:def 4;
  then dom I c= NAT & IC SCMPDS in dom I by A1,RELAT_1:def 18,TARSKI:def 1;
  then reconsider l=IC SCMPDS as Instruction-Location of SCMPDS by AMI_1:def 4;
  l=IC SCMPDS;
  hence contradiction by AMI_1:48;
end;

canceled;

theorem Th56:
  I +* Start-At inspos n c= s implies I c= s
proof
  dom I misses dom Start-At inspos n by Th54;
  then
A1: I +* Start-At inspos n = I \/ Start-At inspos n by FUNCT_4:32;
  assume
  I +* Start-At inspos n c= s;
  hence thesis by A1,XBOOLE_1:11;
end;

theorem
  Initialized I c= s implies I c= s by Th56;

theorem Th58:
  (I +* Start-At inspos n)|NAT = I
proof
  NAT misses dom Start-At inspos n
  proof
    assume
    not thesis;
    then consider x being set such that
A1: x in NAT and
A2: x in dom Start-At inspos n by XBOOLE_0:3;
A3: x is Instruction-Location of SCMPDS by A1,AMI_1:def 4;
    dom Start-At inspos n = {IC SCMPDS} by FUNCOP_1:19;
    then x = IC SCMPDS by A2,TARSKI:def 1;
    hence contradiction by A3,AMI_1:48;
  end;
  then dom I c= NAT & (I +* Start-At inspos n)|NAT = I | NAT by FUNCT_4:76
,RELAT_1:def 18;
  hence thesis by RELAT_1:97;
end;

reserve l,l1,loc for Instruction-Location of SCMPDS;

theorem Th59:
  not a in dom Start-At l
proof
A1: dom Start-At l = {IC SCMPDS} by FUNCOP_1:19;
  assume
  a in dom Start-At l;
  then a = IC SCMPDS by A1,TARSKI:def 1;
  hence contradiction by SCMPDS_2:52;
end;

canceled;

theorem
  not a in dom (I+*Start-At l)
proof
  assume
  a in dom (I+*Start-At l);
  then a in dom I \/ dom Start-At l by FUNCT_4:def 1;
  then
A1: a in dom I or a in dom Start-At l by XBOOLE_0:def 3;
  dom I c= NAT & a in SCM-Data-Loc by RELAT_1:def 18,SCMPDS_2:def 2;
  hence contradiction by A1,Th59,AMI_2:29,XBOOLE_0:3;
end;

theorem
  s+*I+*Start-At inspos 0 = s+*Start-At inspos 0+*I
proof
A1: dom I misses dom Start-At inspos 0 by Th54;
  then I+*Start-At inspos 0 = I \/ Start-At inspos 0 by FUNCT_4:32
    .= Start-At inspos 0 +* I by A1,FUNCT_4:32;
  hence s+*I+*Start-At inspos 0 = s+*(Start-At inspos 0+*I) by FUNCT_4:15
    .= s+*Start-At inspos 0+*I by FUNCT_4:15;
end;

definition
  let s be State of SCMPDS, li be Int_position, k be Integer;
  redefine func s+*(li,k) -> State of SCMPDS;
  coherence
  proof
A1: dom s = dom the Object-Kind of SCMPDS by CARD_3:18;
A2: now
      let x be set;
      assume
A3:   x in dom the Object-Kind of SCMPDS;
      per cases;
      suppose
A4:     x = li;
        then
A5:     (the Object-Kind of SCMPDS).x = ObjectKind li
          .= INT by SCMPDS_2:13;
        (s+*(li,k)).x = k by A1,A3,A4,FUNCT_7:33;
        hence (s+*(li,k)).x in (the Object-Kind of SCMPDS).x by A5,INT_1:def 2;
      end;
      suppose
        x <> li;
        then (s+*(li,k)).x = s.x by FUNCT_7:34;
        hence (s+*(li,k)).x in (the Object-Kind of SCMPDS).x by A3,CARD_3:18;
      end;
    end;
    dom(s+*(li,k)) = dom s by FUNCT_7:32;
    hence thesis by A1,A2,CARD_3:18;
  end;
end;

begin :: The notions of paraclosed,parahalting and their basic properties

definition
  let I be Program of SCMPDS;
  func stop(I) -> Program of SCMPDS equals
  I ';' Stop SCMPDS;
  coherence;
end;

definition
  let I be Program of SCMPDS, s be State of SCMPDS;
  func IExec(I,s) -> State of SCMPDS equals
  Result(s+*Initialized stop(I)) +*
  s|NAT;
  coherence by CARD_3:96;
end;

definition
  let I be Program of SCMPDS;
  attr I is paraclosed means
  :Def9:
  for s being State of SCMPDS, n being
  Element of NAT st Initialized stop(I) c= s holds IC Computation(s,n) in dom
  stop(I);
  attr I is parahalting means
  :Def10:
  Initialized stop(I) is halting;
end;

Lm1: Load halt SCMPDS is parahalting
proof
  let s;
  set m = Load halt SCMPDS, m0= stop (m), m1 = Initialized m0;
  assume
A1: m1 c= s;
  dom(Start-At inspos 0) = {IC SCMPDS} by FUNCOP_1:19;
  then
A2: IC SCMPDS in dom (Start-At inspos 0) by TARSKI:def 1;
  then
A3: IC SCMPDS in dom m1 by FUNCT_4:13;
  then
A4: IC m1 = m1.IC SCMPDS by AMI_1:def 43
    .= (Start-At inspos 0).IC SCMPDS by A2,FUNCT_4:14
    .= inspos 0 by FUNCOP_1:87;
  take 0;
     IC Computation(s,0) in NAT by AMI_1:def 4;
    hence IC Computation(s,0) in dom ProgramPart s by AMI_1:143;
A5: m.inspos 0 = halt SCMPDS by FUNCOP_1:87;
  dom m0 misses dom (Start-At inspos 0) by Th54;
  then
A6: m0 c= m1 by FUNCT_4:33;
  dom m={inspos 0} by FUNCOP_1:19;
  then
A7: inspos 0 in dom m by TARSKI:def 1;
  then
A8: inspos 0 in dom m0 by FUNCT_4:13;
  then
A9: inspos 0 in dom m1 by FUNCT_4:13;
   CurInstr(Computation(s,0)) = CurInstr s by AMI_1:13
    .= s.IC m1 by A1,A3,AMI_1:97
    .= m1.inspos 0 by A1,A9,A4,GRFUNC_1:8
    .= m0.inspos 0 by A6,A8,GRFUNC_1:8
    .= halt SCMPDS by A5,A7,Th37;
  hence thesis by AMI_1:145;
end;

registration
  cluster parahalting Program of SCMPDS;
  existence by Lm1;
end;

theorem Th63:
  for I being parahalting Program of SCMPDS st Initialized stop I
  c= s holds ProgramPart s halts_on s
proof
  let I be parahalting Program of SCMPDS;
  assume
A1: Initialized stop I c= s;
  Initialized stop I is halting by Def10;
  hence thesis by A1,AMI_1:def 26;
end;

registration
  let I be parahalting Program of SCMPDS;
  cluster Initialized stop(I) -> halting;
  coherence
  proof
    let s be State of SCMPDS;
    assume
    Initialized stop I c= s;
    hence thesis by Th63;
  end;
end;

definition
  let la,lb be Instruction-Location of SCMPDS;
  let a, b be Instruction of SCMPDS;
  redefine func (la,lb) --> (a,b) -> FinPartState of SCMPDS;
  coherence
  proof
    ObjectKind la = the Instructions of SCMPDS & ObjectKind lb = the
    Instructions of SCMPDS by AMI_1:def 14;
    hence thesis by AMI_1:58;
  end;
end;

canceled 2;

theorem Th66:
  not ProgramPart(s2 +*((IC s2,Next IC s2) --> (goto 1, goto -1)))
    halts_on s2 +*((IC s2,Next IC s2) --> (goto 1, goto -1))
proof
  set m=(IC s2,Next IC s2) --> (goto 1, goto -1), s1 = s2 +* m;
A1: m.(Next IC s2)=goto -1 by FUNCT_4:66;
  IC s2<>Next IC s2;
  then
A2: m.(IC s2) = goto 1 by FUNCT_4:66;
  defpred X[Nat] means IC(Computation(s1,$1)) = IC s1 or IC(Computation(s1,$1)
  ) = Next IC s1;
A3: dom m = {IC s2,Next IC s2} by FUNCT_4:65;
  then
A4: Next IC s2 in dom m by TARSKI:def 2;
  IC SCMPDS <> IC s2 & IC SCMPDS <> Next IC s2 by AMI_1:48;
  then not IC SCMPDS in dom m by A3,TARSKI:def 2;
  then
A5: IC s1 = IC s2 by FUNCT_4:12;
A6: IC s2 in dom m by A3,TARSKI:def 2;
  now
    let n;
    set Cn=Computation(s1,n);
    assume
A7: IC Cn = IC s1 or IC Cn = Next IC s1;
    per cases by A7;
    case
A8:   IC Cn = IC s1;
      then
A9:   CurInstr( Cn ) = s1.IC s1 by AMI_1:54
        .= goto 1 by A6,A2,A5,FUNCT_4:14;
      thus IC (Computation(s1,n+1)) = IC Following Cn by AMI_1:14
        .= ICplusConst(Cn,1) by A9,SCMPDS_2:66
        .= Next IC s1 by A8,SCMPDS_3:20;
    end;
    case
A10:  IC Cn = Next IC s1;
      reconsider i = IC s1 as Element of NAT by AMI_1:def 4;
A11:  ex j be Element of NAT st j = IC Cn & ICplusConst(Cn,-1) =abs(j+(-1)
      ) by SCMPDS_2:def 20;
A12:  CurInstr(Computation(s1,n)) = s1.(Next IC s1) by A10,AMI_1:54
        .= goto -1 by A4,A1,A5,FUNCT_4:14;
      thus IC(Computation(s1,n+1)) = IC Following Cn by AMI_1:14
        .=abs(i+4 + -4 ) by A10,A12,A11,SCMPDS_2:66
        .=IC s1 by ABSVALUE:def 1;
    end;
  end;
  then
A13: for n st X[n] holds X[n+1];
  let n;
  assume IC Computation(s1,n) in dom ProgramPart s1;
A14: X[0] by AMI_1:13;
A15: for n holds X[n] from NAT_1:sch 1(A14,A13);
  per cases by A15;
  suppose
    IC(Computation(s1,n)) = IC s1;
    then CurInstr(Computation(s1,n)) = s1.IC s1 by AMI_1:54
      .= goto 1 by A6,A2,A5,FUNCT_4:14;
   then CurInstr Computation(s1,n) <> halt SCMPDS by SCMPDS_2:85;
   hence thesis by AMI_1:145;
  end;
  suppose
    IC(Computation(s1,n)) = Next IC s1;
    then CurInstr(Computation(s1,n)) = s1.Next IC s1 by AMI_1:54
      .= goto -1 by A4,A1,A5,FUNCT_4:14;
   then CurInstr Computation(s1,n) <> halt SCMPDS by SCMPDS_2:85;
    hence thesis by AMI_1:145;
  end;
end;

theorem Th67:
  s1,s2 equal_outside NAT & I c= s1 & I c= s2 & (for m st m < n
  holds IC (Computation(s2,m)) in dom I) implies for m st m <= n holds
  Computation(s1,m), Computation(s2,m) equal_outside NAT
proof
  assume that
A1: s1,s2 equal_outside NAT and
A2: I c= s1 and
A3: I c= s2 and
A4: for m st m < n holds IC(Computation(s2,m)) in dom I;
  defpred X[Nat] means $1 <= n implies Computation(s1,$1), Computation(s2,$1)
  equal_outside NAT;
A5: for m st X[m] holds X[m+1]
  proof
    let m such that
A6: m <= n implies Computation(s1,m), Computation(s2,m) equal_outside
    NAT;
A7: Computation(s2,m+1) = Following(Computation(s2,m)) by AMI_1:14
      .= Exec(CurInstr(Computation(s2,m)),Computation(s2,m));
A8: Computation(s1,m+1) = Following(Computation(s1,m)) by AMI_1:14
      .= Exec(CurInstr(Computation(s1,m)),Computation(s1,m));
    assume
A9: m+1 <= n;
    then
A10: IC (Computation(s1,m)) = IC (Computation(s2,m)) by A6,AMI_1:121,NAT_1:13;
    m < n by A9,NAT_1:13;
    then
A11: IC(Computation(s2,m)) in dom I by A4;
    CurInstr(Computation(s1,m)) = s1.IC(Computation(s1,m)) by AMI_1:54
      .= I.IC(Computation(s1,m)) by A2,A11,A10,GRFUNC_1:8
      .= s2.IC(Computation(s2,m)) by A3,A11,A10,GRFUNC_1:8
      .= CurInstr(Computation(s2,m)) by AMI_1:54;
    hence thesis by A6,A8,A7,A9,Th15,NAT_1:13;
  end;
  Computation(s1,0) = s1 by AMI_1:13;
  then
A12: X[0] by A1,AMI_1:13;
  thus for m holds X[m] from NAT_1:sch 1(A12,A5);
end;

theorem Th68:
  for s being State of SCMPDS,l being Instruction-Location of
  SCMPDS holds l in dom s
proof
  let s be State of SCMPDS,l be Instruction-Location of SCMPDS;
  l in NAT by AMI_1:def 4;
  then l in {IC SCMPDS} \/ SCM-Data-Loc \/ NAT by XBOOLE_0:def 3;
  hence thesis by AMI_1:79,SCMPDS_3:5;
end;

reserve l1,l2 for Instruction-Location of SCMPDS,
  i1,i2 for Instruction of
  SCMPDS;

theorem Th69:
  s +*((l1,l2) --> (i1, i2)) = s +* (l1,i1) +* (l2,i2)
proof
A1: l1 in dom s by Th68;
A2: l2 in dom (s +* (l1,i1)) by Th68;
  thus s +*((l1,l2) --> (i1, i2)) =s +* ((l1 .--> i1) +* (l2 .--> i2)) by
FUNCT_4:def 4
    .=s +* (l1 .--> i1) +* (l2 .--> i2) by FUNCT_4:15
    .=s +* (l1,i1) +* (l2 .--> i2) by A1,FUNCT_7:def 3
    .=s +* (l1,i1) +* (l2,i2) by A2,FUNCT_7:def 3;
end;

canceled;

theorem Th71:
  not IC s in dom I implies not Next IC s in dom I
proof
  reconsider m = IC s as Element of NAT by ORDINAL1:def 13;
  assume
  not IC s in dom I;
  then
A1: m >= card I by Th1;
  m+1 >= m by NAT_1:11;
  then m+1 >= card I by A1,XXREAL_0:2;
  hence thesis by Th1;
end;

registration
  cluster parahalting -> paraclosed Program of SCMPDS;
  coherence
  proof
    let I be Program of SCMPDS;
    assume
A1: I is parahalting;
    set IAt = stop(I) +* Start-At inspos 0;
    let s be State of SCMPDS, n be Element of NAT;
    defpred X[Nat] means not IC Computation(s,$1) in dom stop(I);
    dom stop(I) misses dom Start-At inspos 0 by Th54;
    then
A2: stop I c= IAt by FUNCT_4:33;
    assume
A3: Initialized stop(I) c= s;
    then
A4: stop I c= s by A2,XBOOLE_1:1;
    assume
    not IC Computation(s,n) in dom stop(I);
    then
A5: ex n be Nat st X[n];
    consider n be Nat such that
A6: X[n] and
A7: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A5);
    reconsider n as Element of NAT by ORDINAL1:def 13;
A8: for m st m < n holds IC(Computation(s,m)) in dom stop I by A7;
    set s2 = Computation(s,n), Ig = ((IC s2,Next IC s2) --> (goto 1, goto -1))
, s0 = s +* Ig, s1 = s2 +* Ig, t1= s +* (IC s2,goto 1), t2= t1 +* (Next IC s2,
    goto -1), t3= s2 +* (IC s2,goto 1), t4= t3 +* (Next IC s2,goto -1);
    (IAt) | NAT = stop I by Th58;
    then
A9: dom stop (I) = dom(IAt) /\ NAT by RELAT_1:90;
    s| NAT = s2 | NAT by AMI_1:123;
    then t1 | NAT = t3 | NAT by FUNCT_7:95;
    then t2 | NAT = t4 | NAT by FUNCT_7:95;
    then s0 | NAT = t4 | NAT by Th69;
    then s0 | NAT = s1 | NAT by Th69;
    then
A10: Computation(s0,n) | NAT = s1 | NAT by AMI_1:123;
A11: t1,t2 equal_outside NAT by FUNCT_7:93;
    not Next IC Computation(s,n) in dom stop(I) by A6,Th71;
    then
A12: not Next IC s2 in dom IAt by A9,XBOOLE_0:def 4;
A13: t3,t4 equal_outside NAT by FUNCT_7:93;
A14: IC s2 in NAT by AMI_1:def 4;
    then s2,t3 equal_outside NAT by FUNCT_7:93;
    then s2,t4 equal_outside NAT by A13,FUNCT_7:29;
    then
A15: s2,s1 equal_outside NAT by Th69;
    s,t1 equal_outside NAT by A14,FUNCT_7:93;
    then s,t2 equal_outside NAT by A11,FUNCT_7:29;
    then s,s0 equal_outside NAT by Th69;
    then
A16: s0,s equal_outside NAT by FUNCT_7:28;
    not IC s2 in dom IAt by A6,A14,A9,XBOOLE_0:def 4;
    then IAt c= t1 by A3,FUNCT_7:91;
    then IAt c= t2 by A12,FUNCT_7:91;
    then
A17: IAt c= s0 by Th69;
    then stop I c= s0 by A2,XBOOLE_1:1;
    then Computation(s0,n),s2 equal_outside NAT by A16,A4,A8,Th67;
    then
A18: Computation(s0,n) = s1 by A15,A10,FUNCT_7:29,92;
A19: not ProgramPart s1 halts_on s1 by Th66;
    Initialized stop(I) = IAt;
    then ProgramPart s0 halts_on s0 by A1,A17,AMI_1:def 26;
    then ProgramPart s0 halts_on Computation(s0,n) by A18,A19,AMI_1:93;
    hence contradiction by A18,A19,AMI_1:93,144;
  end;
end;

canceled;

theorem
  inspos 0 in dom Stop SCMPDS & (Stop SCMPDS).inspos 0 = halt SCMPDS by
AFINSQ_1:38,SCMNORM:2;

theorem Th74:
  card Stop SCMPDS = 1 by SCMNORM:3;

theorem Th75:
  inspos 0 in dom stop (I)
proof
  card stop I =card I + 1 by Th45,Th74;
  hence thesis by Th1;
end;

begin :: Shiftability of program blocks and instructions

definition
  let i be Instruction of SCMPDS;
  let n be Element of NAT;
  pred i valid_at n means
  :Def11:
  (InsCode i= 0 implies ex k1 st i = goto k1 &
  n+k1 >= 0) & (InsCode i= 4 implies ex a,k1,k2 st i = (a,k1)<>0_goto k2 & n+k2
>= 0 ) & (InsCode i= 5 implies ex a,k1,k2 st i = (a,k1)<=0_goto k2 & n+k2 >= 0
  ) & (InsCode i= 6 implies ex a,k1,k2 st i = (a,k1)>=0_goto k2 & n+k2 >= 0);
end;

reserve l for Element of NAT;

canceled;

theorem Th77:
  for i be Instruction of SCMPDS,m,n be Element of NAT st i
  valid_at m & m <= n holds i valid_at n
proof
  let i be Instruction of SCMPDS,m,n be Element of NAT;
  assume that
A1: i valid_at m and
A2: m <= n;
A3: now
    assume
    InsCode i= 4;
    then consider a,k1,k2 such that
A4: i = (a,k1)<>0_goto k2 and
A5: m+k2 >= 0 by A1,Def11;
    take a,k1,k2;
    thus i = (a,k1)<>0_goto k2 by A4;
    thus n+k2 >= 0 by A2,A5,XREAL_1:8;
  end;
A6: now
    assume
    InsCode i= 6;
    then consider a,k1,k2 such that
A7: i = (a,k1)>=0_goto k2 and
A8: m+k2 >= 0 by A1,Def11;
    take a,k1,k2;
    thus i = (a,k1)>=0_goto k2 by A7;
    thus n+k2 >= 0 by A2,A8,XREAL_1:8;
  end;
A9: now
    assume
    InsCode i= 5;
    then consider a,k1,k2 such that
A10: i = (a,k1)<=0_goto k2 and
A11: m+k2 >= 0 by A1,Def11;
    take a,k1,k2;
    thus i = (a,k1)<=0_goto k2 by A10;
    thus n+k2 >= 0 by A2,A11,XREAL_1:8;
  end;
  now
    assume
    InsCode i= 0;
    then consider k1 such that
A12: i=goto k1 and
A13: m+k1 >= 0 by A1,Def11;
    take k1;
    thus i=goto k1 by A12;
    thus n+k1 >= 0 by A2,A13,XREAL_1:8;
  end;
  hence thesis by A3,A9,A6,Def11;
end;

definition
  let IT be FinPartState of SCMPDS;
  attr IT is shiftable means
  :Def12:
  for n,i st inspos n in dom IT & i=IT.(
  inspos n) holds InsCode i <> 1 & InsCode i <> 3 & i valid_at n;
end;

Lm2: Load halt SCMPDS is shiftable
proof
  set m = Load halt SCMPDS;
A1: m.inspos 0 = halt SCMPDS by FUNCOP_1:87;
A2: dom m={inspos 0} by FUNCOP_1:19;
  now
    let n,i;
    assume that
A3: inspos n in dom m and
A4: i=m.(inspos n);
A5: inspos n= inspos 0 by A2,A3,TARSKI:def 1;
    hence InsCode i <> 1 by A1,A4,SCMPDS_2:21,93;
A6: ex k1 st i = goto k1 & n+k1 >= 0
    proof
      take 0;
      thus i=goto 0 by A4,A5,FUNCOP_1:87,SCMPDS_2:93;
      thus n+0>=0;
    end;
    thus InsCode i <> 3 by A1,A4,A5,SCMPDS_2:21,93;
    InsCode i =0 by A1,A4,A5,SCMPDS_2:21,93;
    hence i valid_at n by A6,Def11;
  end;
  hence thesis by Def12;
end;

registration
  cluster parahalting shiftable Program of SCMPDS;
  existence by Lm1,Lm2;
end;

definition
  let i be Instruction of SCMPDS;
  attr i is shiftable means
  :Def13:
  InsCode i = 2 or InsCode i > 6;
end;

registration
  cluster shiftable Instruction of SCMPDS;
  existence
  proof
    take i=DataLoc(0,0):=1;
    InsCode i=2 by SCMPDS_2:23;
    hence thesis by Def13;
  end;
end;

registration
  let a,k1;
  cluster a := k1 -> shiftable;
  coherence
  proof
    InsCode (a:=k1)=2 by SCMPDS_2:23;
    hence thesis by Def13;
  end;
end;

registration
  let a,k1,k2;
  cluster (a,k1) := k2 -> shiftable;
  coherence
  proof
    InsCode ((a,k1) := k2)=7 by SCMPDS_2:28;
    hence thesis by Def13;
  end;
end;

registration
  let a,k1,k2;
  cluster AddTo(a,k1,k2) -> shiftable;
  coherence
  proof
    InsCode AddTo(a,k1,k2)=8 by SCMPDS_2:29;
    hence thesis by Def13;
  end;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> shiftable;
  coherence
  proof
    InsCode AddTo(a,k1,b,k2)=9 by SCMPDS_2:30;
    hence thesis by Def13;
  end;
  cluster SubFrom(a,k1,b,k2) -> shiftable;
  coherence
  proof
    InsCode SubFrom(a,k1,b,k2)=10 by SCMPDS_2:31;
    hence thesis by Def13;
  end;
  cluster MultBy(a,k1,b,k2) -> shiftable;
  coherence
  proof
    InsCode MultBy(a,k1,b,k2)=11 by SCMPDS_2:32;
    hence thesis by Def13;
  end;
  cluster Divide(a,k1,b,k2) -> shiftable;
  coherence
  proof
    InsCode Divide(a,k1,b,k2)=12 by SCMPDS_2:33;
    hence thesis by Def13;
  end;
  cluster (a,k1) := (b,k2) -> shiftable;
  coherence
  proof
    InsCode (a,k1) := (b,k2)=13 by SCMPDS_2:34;
    hence thesis by Def13;
  end;
end;

registration
  let I,J be shiftable Program of SCMPDS;
  cluster I ';' J -> shiftable;
  coherence
  proof
    set IJ=I ';' J;
    now
      set D = {l+card I: l in dom J };
      let n,i such that
A1:   inspos n in dom IJ and
A2:   i=IJ.(inspos n);
      dom Shift(J,card I) = D by VALUED_1:def 12;
      then
A3:   dom IJ = dom I \/ D by FUNCT_4:def 1;
      per cases by A1,A3,XBOOLE_0:def 3;
      suppose
A4:     inspos n in dom I;
        then I.inspos n=i by A2,Th37;
        hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A4,Def12;
      end;
      suppose
        inspos n in D;
        then consider l such that
A5:     n = l+card I and
A6:     l in dom J;
A7:     J.inspos l =i by A2,A5,A6,Th38;
        hence InsCode i <> 1 & InsCode i <> 3 by A6,Def12;
        i valid_at l by A6,A7,Def12;
        hence i valid_at n by A5,Th77,NAT_1:11;
      end;
    end;
    hence thesis by Def12;
  end;
end;

registration
  let i be shiftable Instruction of SCMPDS;
  cluster Load i -> shiftable;
  coherence
  proof
    set p=Load i;
    now
      let n,j such that
A1:   inspos n in dom p and
A2:   j=p.inspos n;
      dom p = { inspos 0 } by FUNCOP_1:19;
      then inspos n = inspos 0 by A1,TARSKI:def 1;
      then
A3:   j=i by A2,FUNCOP_1:87;
      hence InsCode j <> 1 by Def13;
      thus InsCode j <> 3 by A3,Def13;
A4:   InsCode j <> 4 & InsCode j <> 5 by A3,Def13;
      InsCode j=2 or InsCode j > 6 by A3,Def13;
      hence j valid_at n by A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

registration
  let i be shiftable Instruction of SCMPDS, J be shiftable Program of SCMPDS;
  cluster i ';' J -> shiftable;
  coherence;
end;

registration
  let I be shiftable Program of SCMPDS, j be shiftable Instruction of SCMPDS;
  cluster I ';' j -> shiftable;
  coherence;
end;

registration
  let i,j be shiftable Instruction of SCMPDS;
  cluster i ';' j -> shiftable;
  coherence;
end;

registration
  cluster Stop SCMPDS -> parahalting shiftable;
  coherence by Lm1,Lm2;
end;

registration
  let I be shiftable Program of SCMPDS;
  cluster stop I -> shiftable;
  coherence;
end;

theorem
  for I being shiftable Program of SCMPDS,k1 be Integer st card I + k1
  >= 0 holds I ';' goto k1 is shiftable
proof
  let I be shiftable Program of SCMPDS,k1 be Integer;
  set J= Load goto k1;
  set Ig=I ';' goto k1;
  assume
A1: card I + k1 >= 0;
  now
    set D = {l+card I: l in dom J };
    let n,i such that
A2: inspos n in dom Ig and
A3: i=Ig.(inspos n);
    dom Shift(J,card I) = D by VALUED_1:def 12;
    then
A4: dom Ig = dom I \/ D by FUNCT_4:def 1;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A5:   inspos n in dom I;
      then I.inspos n=i by A3,Th37;
      hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A5,Def12;
    end;
    suppose
      inspos n in D;
      then consider l such that
A6:   n = l+card I and
A7:   l in dom J;
      dom J = { inspos 0 } by FUNCOP_1:19;
      then
A8:   inspos l = inspos 0 by A7,TARSKI:def 1;
      then
A9:   goto k1 =J.inspos l by FUNCOP_1:87
        .=i by A3,A6,A7,Th38;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:21;
A10:  InsCode i <> 6 by A9,SCMPDS_2:21;
      InsCode i <> 4 & InsCode i <> 5 by A9,SCMPDS_2:21;
      hence i valid_at n by A1,A6,A8,A9,A10,Def11;
    end;
  end;
  hence thesis by Def12;
end;

registration
  let n be Element of NAT;
  cluster Load goto n -> shiftable;
  coherence
  proof
    set k1=n;
    set J= Load goto k1;
    now
      let n,i such that
A1:   inspos n in dom J and
A2:   i=J.inspos n;
      dom J = { inspos 0 } by FUNCOP_1:19;
      then inspos n = inspos 0 by A1,TARSKI:def 1;
      then
A3:   goto k1 =i by A2,FUNCOP_1:87;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:21;
A4:   n+k1 >=0 & InsCode i <> 6 by A3,SCMPDS_2:21;
      InsCode i <> 4 & InsCode i <> 5 by A3,SCMPDS_2:21;
      hence i valid_at n by A3,A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

theorem
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)<>0_goto k2 is shiftable
proof
  let I be shiftable Program of SCMPDS,k1,k2 be Integer,a be Int_position;
  set ii= (a,k1)<>0_goto k2, J= Load ii;
  set Ig=I ';' ii;
  assume
A1: card I + k2 >= 0;
  now
    set D = {l+card I: l in dom J };
    let n,i such that
A2: inspos n in dom Ig and
A3: i=Ig.(inspos n);
    dom Shift(J,card I) = D by VALUED_1:def 12;
    then
A4: dom Ig = dom I \/ D by FUNCT_4:def 1;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A5:   inspos n in dom I;
      then I.inspos n=i by A3,Th37;
      hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A5,Def12;
    end;
    suppose
      inspos n in D;
      then consider l such that
A6:   n = l+card I and
A7:   l in dom J;
      dom J = { inspos 0 } by FUNCOP_1:19;
      then
A8:   inspos l = inspos 0 by A7,TARSKI:def 1;
      then
A9:   ii=J.inspos l by FUNCOP_1:87
        .=i by A3,A6,A7,Th38;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:25;
A10:  InsCode i <> 6 by A9,SCMPDS_2:25;
      InsCode i <> 0 & InsCode i <> 5 by A9,SCMPDS_2:25;
      hence i valid_at n by A1,A6,A8,A9,A10,Def11;
    end;
  end;
  hence thesis by Def12;
end;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)<>0_goto n -> shiftable;
  coherence
  proof
    set k2=n;
    set ii= (a,k1)<>0_goto k2, J= Load ii;
    now
      let n,i such that
A1:   inspos n in dom J and
A2:   i=J.inspos n;
      dom J = { inspos 0 } by FUNCOP_1:19;
      then inspos n = inspos 0 by A1,TARSKI:def 1;
      then
A3:   ii =i by A2,FUNCOP_1:87;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:25;
A4:   n+k2 >=0 & InsCode i <> 6 by A3,SCMPDS_2:25;
      InsCode i <> 0 & InsCode i <> 5 by A3,SCMPDS_2:25;
      hence i valid_at n by A3,A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

theorem
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)<=0_goto k2 is shiftable
proof
  let I be shiftable Program of SCMPDS,k1,k2 be Integer,a be Int_position;
  set ii= (a,k1)<=0_goto k2, J= Load ii;
  set Ig=I ';' ii;
  assume
A1: card I + k2 >= 0;
  now
    set D = {l+card I: l in dom J };
    let n,i such that
A2: inspos n in dom Ig and
A3: i=Ig.(inspos n);
    dom Shift(J,card I) = D by VALUED_1:def 12;
    then
A4: dom Ig = dom I \/ D by FUNCT_4:def 1;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A5:   inspos n in dom I;
      then I.inspos n=i by A3,Th37;
      hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A5,Def12;
    end;
    suppose
      inspos n in D;
      then consider l such that
A6:   n = l+card I and
A7:   l in dom J;
      dom J = { inspos 0 } by FUNCOP_1:19;
      then
A8:   inspos l = inspos 0 by A7,TARSKI:def 1;
      then
A9:   ii =J.inspos l by FUNCOP_1:87
        .=i by A3,A6,A7,Th38;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:26;
A10:  InsCode i <> 6 by A9,SCMPDS_2:26;
      InsCode i <> 0 & InsCode i <> 4 by A9,SCMPDS_2:26;
      hence i valid_at n by A1,A6,A8,A9,A10,Def11;
    end;
  end;
  hence thesis by Def12;
end;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)<=0_goto n -> shiftable;
  coherence
  proof
    set k2=n;
    set ii= (a,k1)<=0_goto k2, J= Load ii;
    now
      let n,i such that
A1:   inspos n in dom J and
A2:   i=J.inspos n;
      dom J = { inspos 0 } by FUNCOP_1:19;
      then inspos n = inspos 0 by A1,TARSKI:def 1;
      then
A3:   ii =i by A2,FUNCOP_1:87;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:26;
A4:   n+k2 >=0 & InsCode i <> 6 by A3,SCMPDS_2:26;
      InsCode i <> 0 & InsCode i <> 4 by A3,SCMPDS_2:26;
      hence i valid_at n by A3,A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

theorem
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)>=0_goto k2 is shiftable
proof
  let I be shiftable Program of SCMPDS,k1,k2 be Integer,a be Int_position;
  set ii= (a,k1)>=0_goto k2, J= Load ii;
  set Ig=I ';' ii;
  assume
A1: card I + k2 >= 0;
  now
    set D = {l+card I: l in dom J };
    let n,i such that
A2: inspos n in dom Ig and
A3: i=Ig.(inspos n);
    dom Shift(J,card I) = D by VALUED_1:def 12;
    then
A4: dom Ig = dom I \/ D by FUNCT_4:def 1;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A5:   inspos n in dom I;
      then I.inspos n=i by A3,Th37;
      hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A5,Def12;
    end;
    suppose
      inspos n in D;
      then consider l such that
A6:   n = l+card I and
A7:   l in dom J;
      dom J = { inspos 0 } by FUNCOP_1:19;
      then
A8:   inspos l = inspos 0 by A7,TARSKI:def 1;
      then
A9:   ii =J.inspos l by FUNCOP_1:87
        .=i by A3,A6,A7,Th38;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:27;
A10:  InsCode i <> 5 by A9,SCMPDS_2:27;
      InsCode i <> 0 & InsCode i <> 4 by A9,SCMPDS_2:27;
      hence i valid_at n by A1,A6,A8,A9,A10,Def11;
    end;
  end;
  hence thesis by Def12;
end;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)>=0_goto n -> shiftable;
  coherence
  proof
    set k2=n;
    set ii= (a,k1)>=0_goto k2, J= Load ii;
    now
      let n,i such that
A1:   inspos n in dom J and
A2:   i=J.inspos n;
      dom J = { inspos 0 } by FUNCOP_1:19;
      then inspos n = inspos 0 by A1,TARSKI:def 1;
      then
A3:   ii =i by A2,FUNCOP_1:87;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:27;
A4:   n+k2 >=0 & InsCode i <> 5 by A3,SCMPDS_2:27;
      InsCode i <> 0 & InsCode i <> 4 by A3,SCMPDS_2:27;
      hence i valid_at n by A3,A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

theorem Th82:
  for s1,s2 being State of SCMPDS, n,m being Element of NAT,k1 be
Integer st IC s1=inspos m & m+k1>=0 & IC s1 + n = IC s2 holds ICplusConst(s1,k1
  ) +n = ICplusConst(s2,k1)
proof
  let s1,s2 be State of SCMPDS, n,m be Element of NAT,k1 be Integer;
  assume that
A1: IC s1=inspos m and
A2: m+k1>=0 and
A3: IC s1 + n = IC s2;
  reconsider nk = ICplusConst(s1,k1) as Element of NAT by ORDINAL1:def 13;
  reconsider mk=m+k1 as Element of NAT by A2,INT_1:16;
  ex n1 be Element of NAT st n1 = IC s1 & ICplusConst(s1, k1) = abs(n1+k1)
  by SCMPDS_2:def 20;
  then
  (ex n2 be Element of NAT st n2 = IC s2 & ICplusConst(s2, k1) = abs(n2+k1
  ) )& nk=mk by A1,ABSVALUE:def 1,SCMPDS_2:def 20;
  hence thesis by A1,A3,ABSVALUE:def 1;
end;

theorem Th83:
  for s1,s2 being State of SCMPDS, n,m being Element of NAT, i
being Instruction of SCMPDS holds IC s1=inspos m & i valid_at m & InsCode i <>
  1 & InsCode i <> 3 & IC s1 + n = IC s2 & DataPart s1 = DataPart s2 implies IC
  Exec(i,s1) + n = IC Exec(i,s2) & DataPart Exec(i,s1) = DataPart Exec(i,s2)
proof
  let s1,s2 be State of SCMPDS, n,m be Element of NAT;
  let i be Instruction of SCMPDS;
  assume that
A1: IC s1=inspos m and
A2: i valid_at m and
A3: InsCode i <> 1 & InsCode i <> 3 and
A4: IC s1 + n = IC s2 and
A5: DataPart s1 = DataPart s2;
A6: now
    let a,k1;
    thus s1.DataLoc(s1.a,k1) =s1.DataLoc(s2.a,k1) by A5,Th23
      .=s2.DataLoc(s2.a,k1) by A5,Th23;
  end;
  reconsider k1 = IC s1 as Element of NAT by ORDINAL1:def 13;
  set Ci=InsCode i;
A7: Next IC s1 + n = Next IC s2 by A4;
A8: now
    assume
    Ci <> 0 & Ci<>1 & Ci<>4 & Ci<>5 & Ci<> 6;
    then
A9: not Ci in {0,1,4,5,6} by ENUMSET1:def 3;
    then IC Exec(i,s1) = Next IC s1 by Th6;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A7,A9,Th6;
  end;
  per cases by A3,NAT_1:38,SCMPDS_2:15;
  suppose
    Ci = 0;
    then consider k1 such that
A10: i = goto k1 and
A11: m+k1 >= 0 by A2,Def11;
    IC Exec(i,s1) = ICplusConst(s1,k1) by A10,SCMPDS_2:66;
    hence IC Exec(i,s1) + n = ICplusConst(s2,k1) by A1,A4,A11,Th82
      .= IC Exec(i,s2) by A10,SCMPDS_2:66;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A10,SCMPDS_2:66
        .=s2.a by A5,Th23
        .=Exec(i, s2).a by A10,SCMPDS_2:66;
    end;
    hence thesis by Th23;
  end;
  suppose
A12: Ci = 2;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,k1 such that
A13: i = a := k1 by A12,SCMPDS_2:37;
    now
      let b;
      per cases;
      suppose
A14:    a=b;
        hence Exec(i, s1).b= k1 by A13,SCMPDS_2:57
          .=Exec(i,s2).b by A13,A14,SCMPDS_2:57;
      end;
      suppose
A15:    a<>b;
        hence Exec(i,s1).b = s1.b by A13,SCMPDS_2:57
          .=s2.b by A5,Th23
          .=Exec(i,s2).b by A13,A15,SCMPDS_2:57;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
    Ci = 4;
    then consider a,k1,k2 such that
A16: i = (a,k1)<>0_goto k2 and
A17: m+k2 >= 0 by A2,Def11;
    hereby
      per cases;
      suppose
A18:    s1.DataLoc(s1.a,k1) <> 0;
        then
A19:    s2.DataLoc(s2.a,k1) <> 0 by A6;
        IC Exec(i,s1) = ICplusConst(s1,k2) by A16,A18,SCMPDS_2:67;
        hence IC Exec(i,s1) + n = ICplusConst(s2,k2) by A1,A4,A17,Th82
          .= IC Exec(i,s2) by A16,A19,SCMPDS_2:67;
      end;
      suppose
        s1.DataLoc(s1.a,k1) = 0;
        then s2.DataLoc(s2.a,k1) = 0 & IC Exec(i,s1) = Next IC s1 by A6,A16,
SCMPDS_2:67;
        hence IC Exec(i,s1) + n = IC Exec(i,s2) by A7,A16,SCMPDS_2:67;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A16,SCMPDS_2:67
        .=s2.a by A5,Th23
        .=Exec(i, s2).a by A16,SCMPDS_2:67;
    end;
    hence thesis by Th23;
  end;
  suppose
    Ci = 5;
    then consider a,k1,k2 such that
A20: i = (a,k1)<=0_goto k2 and
A21: m+k2 >= 0 by A2,Def11;
    hereby
      per cases;
      suppose
A22:    s1.DataLoc(s1.a,k1) <= 0;
        then
A23:    s2.DataLoc(s2.a,k1) <= 0 by A6;
        IC Exec(i,s1) = ICplusConst(s1,k2) by A20,A22,SCMPDS_2:68;
        hence IC Exec(i,s1) + n = ICplusConst(s2,k2) by A1,A4,A21,Th82
          .= IC Exec(i,s2) by A20,A23,SCMPDS_2:68;
      end;
      suppose
        s1.DataLoc(s1.a,k1) > 0;
        then s2.DataLoc(s2.a,k1) > 0 & IC Exec(i,s1) = Next IC s1 by A6,A20,
SCMPDS_2:68;
        hence IC Exec(i,s1) + n = IC Exec(i,s2) by A7,A20,SCMPDS_2:68;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A20,SCMPDS_2:68
        .=s2.a by A5,Th23
        .=Exec(i, s2).a by A20,SCMPDS_2:68;
    end;
    hence thesis by Th23;
  end;
  suppose
    Ci = 6;
    then consider a,k1,k2 such that
A24: i = (a,k1)>=0_goto k2 and
A25: m+k2 >= 0 by A2,Def11;
    hereby
      per cases;
      suppose
A26:    s1.DataLoc(s1.a,k1) >= 0;
        then
A27:    s2.DataLoc(s2.a,k1) >= 0 by A6;
        IC Exec(i,s1) = ICplusConst(s1,k2) by A24,A26,SCMPDS_2:69;
        hence IC Exec(i,s1) + n = ICplusConst(s2,k2) by A1,A4,A25,Th82
          .= IC Exec(i,s2) by A24,A27,SCMPDS_2:69;
      end;
      suppose
        s1.DataLoc(s1.a,k1) < 0;
        then s2.DataLoc(s2.a,k1) < 0 & IC Exec(i,s1) = Next IC s1 by A6,A24,
SCMPDS_2:69;
        hence IC Exec(i,s1) + n = IC Exec(i,s2) by A7,A24,SCMPDS_2:69;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A24,SCMPDS_2:69
        .=s2.a by A5,Th23
        .=Exec(i, s2).a by A24,SCMPDS_2:69;
    end;
    hence thesis by Th23;
  end;
  suppose
A28: Ci = 7;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,k1,k2 such that
A29: i = (a,k1) := k2 by A28,SCMPDS_2:42;
    now
      let b;
      per cases;
      suppose
A30:    DataLoc(s1.a,k1)=b;
        then
A31:    DataLoc(s2.a,k1)=b by A5,Th23;
        thus Exec(i, s1).b= k2 by A29,A30,SCMPDS_2:58
          .=Exec(i,s2).b by A29,A31,SCMPDS_2:58;
      end;
      suppose
A32:    DataLoc(s1.a,k1)<>b;
        then
A33:    DataLoc(s2.a,k1)<>b by A5,Th23;
        thus Exec(i,s1).b = s1.b by A29,A32,SCMPDS_2:58
          .=s2.b by A5,Th23
          .=Exec(i,s2).b by A29,A33,SCMPDS_2:58;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A34: Ci = 8;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,k1,k2 such that
A35: i = AddTo(a,k1,k2) by A34,SCMPDS_2:43;
    now
      let b;
      per cases;
      suppose
A36:    DataLoc(s1.a,k1)=b;
        then
A37:    DataLoc(s2.a,k1)=b by A5,Th23;
        thus Exec(i, s1).b= s1.DataLoc(s1.a,k1)+k2 by A35,A36,SCMPDS_2:60
          .= s2.DataLoc(s2.a,k1)+k2 by A6
          .=Exec(i,s2).b by A35,A37,SCMPDS_2:60;
      end;
      suppose
A38:    DataLoc(s1.a,k1)<>b;
        then
A39:    DataLoc(s2.a,k1)<>b by A5,Th23;
        thus Exec(i,s1).b = s1.b by A35,A38,SCMPDS_2:60
          .=s2.b by A5,Th23
          .=Exec(i,s2).b by A35,A39,SCMPDS_2:60;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A40: Ci = 9;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A41: i = AddTo(a,k1,b,k2) by A40,SCMPDS_2:44;
    now
      let c;
      per cases;
      suppose
A42:    DataLoc(s1.a,k1)=c;
        then
A43:    DataLoc(s2.a,k1)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)+s1.DataLoc(s1.b,k2) by A41,A42
,SCMPDS_2:61
          .= s2.DataLoc(s2.a,k1)+s1.DataLoc(s1.b,k2) by A6
          .= s2.DataLoc(s2.a,k1)+s2.DataLoc(s2.b,k2) by A6
          .=Exec(i,s2).c by A41,A43,SCMPDS_2:61;
      end;
      suppose
A44:    DataLoc(s1.a,k1)<>c;
        then
A45:    DataLoc(s2.a,k1)<>c by A5,Th23;
        thus Exec(i,s1).c = s1.c by A41,A44,SCMPDS_2:61
          .=s2.c by A5,Th23
          .=Exec(i,s2).c by A41,A45,SCMPDS_2:61;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A46: Ci = 10;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A47: i = SubFrom(a,k1,b,k2) by A46,SCMPDS_2:45;
    now
      let c;
      per cases;
      suppose
A48:    DataLoc(s1.a,k1)=c;
        then
A49:    DataLoc(s2.a,k1)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)-s1.DataLoc(s1.b,k2) by A47,A48
,SCMPDS_2:62
          .= s2.DataLoc(s2.a,k1)-s1.DataLoc(s1.b,k2) by A6
          .= s2.DataLoc(s2.a,k1)-s2.DataLoc(s2.b,k2) by A6
          .=Exec(i,s2).c by A47,A49,SCMPDS_2:62;
      end;
      suppose
A50:    DataLoc(s1.a,k1)<>c;
        then
A51:    DataLoc(s2.a,k1)<>c by A5,Th23;
        thus Exec(i,s1).c = s1.c by A47,A50,SCMPDS_2:62
          .=s2.c by A5,Th23
          .=Exec(i,s2).c by A47,A51,SCMPDS_2:62;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A52: Ci = 11;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A53: i = MultBy(a,k1,b,k2) by A52,SCMPDS_2:46;
    now
      let c;
      per cases;
      suppose
A54:    DataLoc(s1.a,k1)=c;
        then
A55:    DataLoc(s2.a,k1)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)*s1.DataLoc(s1.b,k2) by A53,A54
,SCMPDS_2:63
          .= s2.DataLoc(s2.a,k1)*s1.DataLoc(s1.b,k2) by A6
          .= s2.DataLoc(s2.a,k1)*s2.DataLoc(s2.b,k2) by A6
          .=Exec(i,s2).c by A53,A55,SCMPDS_2:63;
      end;
      suppose
A56:    DataLoc(s1.a,k1)<>c;
        then
A57:    DataLoc(s2.a,k1)<>c by A5,Th23;
        thus Exec(i,s1).c = s1.c by A53,A56,SCMPDS_2:63
          .=s2.c by A5,Th23
          .=Exec(i,s2).c by A53,A57,SCMPDS_2:63;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A58: Ci = 12;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A59: i = Divide(a,k1,b,k2) by A58,SCMPDS_2:47;
    now
      let c;
      per cases;
      suppose
A60:    DataLoc(s1.b,k2)=c;
        then
A61:    DataLoc(s2.b,k2)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) mod s1.DataLoc(s1.b,k2) by A59
,A60,SCMPDS_2:64
          .= s2.DataLoc(s2.a,k1) mod s1.DataLoc(s1.b,k2) by A6
          .= s2.DataLoc(s2.a,k1) mod s2.DataLoc(s2.b,k2) by A6
          .= Exec(i,s2).c by A59,A61,SCMPDS_2:64;
      end;
      suppose
A62:    DataLoc(s1.b,k2)<>c;
        then
A63:    DataLoc(s2.b,k2)<>c by A5,Th23;
        hereby
          per cases;
          suppose
A64:        DataLoc(s1.a,k1)<>c;
            then
A65:        DataLoc(s2.a,k1)<>c by A5,Th23;
            thus Exec(i, s1).c = s1.c by A59,A62,A64,SCMPDS_2:64
              .=s2.c by A5,Th23
              .=Exec(i,s2).c by A59,A63,A65,SCMPDS_2:64;
          end;
          suppose
A66:        DataLoc(s1.a,k1)=c;
            then
A67:        DataLoc(s2.a,k1)=c by A5,Th23;
            thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) div s1.DataLoc(s1.b,k2)
            by A59,A62,A66,SCMPDS_2:64
              .= s2.DataLoc(s2.a,k1) div s1.DataLoc(s1.b,k2) by A6
              .= s2.DataLoc(s2.a,k1) div s2.DataLoc(s2.b,k2) by A6
              .= Exec(i,s2).c by A59,A63,A67,SCMPDS_2:64;
          end;
        end;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A68: Ci = 13;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A69: i = (a,k1):=(b,k2) by A68,SCMPDS_2:48;
    now
      let c;
      per cases;
      suppose
A70:    DataLoc(s1.a,k1)=c;
        then
A71:    DataLoc(s2.a,k1)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.b,k2) by A69,A70,SCMPDS_2:59
          .= s2.DataLoc(s2.b,k2) by A6
          .=Exec(i,s2).c by A69,A71,SCMPDS_2:59;
      end;
      suppose
A72:    DataLoc(s1.a,k1)<>c;
        then
A73:    DataLoc(s2.a,k1)<>c by A5,Th23;
        thus Exec(i,s1).c = s1.c by A69,A72,SCMPDS_2:59
          .=s2.c by A5,Th23
          .=Exec(i,s2).c by A69,A73,SCMPDS_2:59;
      end;
    end;
    hence thesis by Th23;
  end;
end;

theorem
  for J being parahalting shiftable Program of SCMPDS st Initialized
  stop J c= s1 for n being Element of NAT st Shift(stop J,n) c= s2 & IC s2 =
  inspos n & DataPart s1 = DataPart s2 for i being Element of NAT holds IC
  Computation(s1,i) + n = IC Computation(s2,i) & CurInstr (Computation(s1,i)) =
  CurInstr (Computation(s2,i)) & DataPart Computation(s1,i) = DataPart
  Computation(s2,i)
proof
  let I be parahalting shiftable Program of SCMPDS;
  set SI=stop I, II = Initialized SI;
  assume
A1: II c= s1;
  let n be Element of NAT;
  assume that
A2: Shift(SI,n) c= s2 and
A3: IC s2 = inspos n and
A4: DataPart s1 = DataPart s2;
A5: inspos 0 in dom SI by Th75;
  then
A6: inspos (0 + n) in dom Shift(SI,n) by VALUED_1:25;
  defpred P[Nat] means IC Computation(s1,$1) + n = IC Computation(s2,$1) &
  CurInstr (Computation(s1,$1)) = CurInstr (Computation(s2,$1)) & DataPart
  Computation(s1,$1) = DataPart Computation(s2,$1);
  dom SI misses dom Start-At inspos 0 by Th54;
  then
A7: SI c= II by FUNCT_4:33;
  then
A8: dom SI c= dom II by GRFUNC_1:8;
A9: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A10: P[k];
    reconsider m = IC Computation(s1,k) as Element of NAT by ORDINAL1:def 13;
    set i = CurInstr Computation(s1,k);
A11: Computation(s1,k+1) = Following Computation(s1,k) by AMI_1:14
      .= Exec(CurInstr Computation(s1,k),Computation(s1,k));
A12: IC Computation(s1,k) =inspos m;
    reconsider l = IC Computation(s1,k+1) as Element of NAT by ORDINAL1:def 13;
A13: IC Computation(s1,k+1) in dom SI by A1,Def9;
    then
A14: l+n in dom Shift(SI,n) by VALUED_1:25;
A15: Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
      .= Exec(CurInstr Computation(s2,k),Computation(s2,k));
A16: IC Computation(s1,k) in dom SI by A1,Def9;
A17: i = s1.IC Computation(s1,k) by AMI_1:54
      .= II.IC Computation(s1,k) by A1,A8,A16,GRFUNC_1:8
      .= SI.IC Computation(s1,k) by A7,A16,GRFUNC_1:8;
    then
A18: InsCode i <> 1 & InsCode i <> 3 by A16,A12,Def12;
A19: i valid_at m by A16,A17,A12,Def12;
    hence
A20: IC Computation(s1,k+1) + n = IC Computation(s2,k+1) by A10,A11,A15,A12,A18
,Th83;
    CurInstr Computation(s1,k+1) = s1.l by AMI_1:54
      .= II.l by A1,A8,A13,GRFUNC_1:8
      .= SI.l by A7,A13,GRFUNC_1:8;
    hence CurInstr Computation(s1,k+1) = Shift(SI,n).(IC Computation(s2,k+1))
    by A20,A13,VALUED_1:def 12
      .= s2.IC Computation(s2,k+1) by A2,A20,A14,GRFUNC_1:8
      .= CurInstr Computation(s2,k+1) by AMI_1:54;
    thus thesis by A10,A11,A15,A12,A18,A19,Th83;
  end;
A21: IC SCMPDS in dom II by Th7;
  then
A22: s1.IC s1 = s1.((II).IC SCMPDS) by A1,GRFUNC_1:8
    .= s1.inspos 0 by Th29
    .= II.inspos 0 by A1,A8,A5,GRFUNC_1:8
    .= SI.inspos 0 by A7,A5,GRFUNC_1:8;
  let i be Element of NAT;
A23: DataPart Computation(s1,0) = DataPart s2 by A4,AMI_1:13
    .= DataPart Computation(s2,0) by AMI_1:13;
A24: IC Computation(s1,0) = s1.IC SCMPDS by AMI_1:13
    .= II.IC SCMPDS by A1,A21,GRFUNC_1:8
    .= inspos 0 by Th29;
  CurInstr (Computation(s1,0)) = CurInstr s1 by AMI_1:13
    .= Shift(SI,n).(inspos 0 + n) by A5,A22,VALUED_1:def 12
    .= CurInstr s2 by A2,A3,A6,GRFUNC_1:8
    .= CurInstr (Computation(s2,0)) by AMI_1:13;
  then
A25: P[0] by A3,A24,A23,AMI_1:13;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A25,A9);
  hence thesis;
end;

