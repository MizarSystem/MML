:: The Construction and shiftability of Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMPDS_2, SCMFSA_7, CARD_1, FUNCOP_1,
      RELAT_1, FUNCT_1, NAT_1, ARYTM_3, XBOOLE_0, TARSKI, VALUED_1, SCMNORM,
      FSM_1, INT_1, FUNCT_4, GRAPHSP, AMI_3, AMI_2, STRUCT_0, SCMPDS_1,
      COMPLEX1, XXREAL_0, ARYTM_1, TURING_1, AMISTD_2, SCMFSA6B, MSUALG_1,
      CIRCUIT2, SCMPDS_4, ORDINAL1, PARTFUN1, SCMFSA6C, ORDINAL4, PBOOLE,
      FINSET_1, COMPOS_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, FINSET_1, NUMBERS,
      XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1, AFINSQ_1, VALUED_1, FUNCT_4,
      FUNCT_7, INT_1, NAT_1, INT_2, XXREAL_0, PBOOLE, STRUCT_0, MEMSTR_0,
      COMPOS_1, EXTPRO_1, AMI_2, AMISTD_2, SCMPDS_1, SCMPDS_2;
 constructors WELLORD2, XXREAL_0, INT_2, SCMPDS_1, SCMPDS_3, DOMAIN_1,
      RELSET_1, PRE_POLY, ORDINAL5, AMI_3, AMISTD_2, AMISTD_1, FUNCT_7,
      MEMSTR_0;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, SCMPDS_2, AMI_2, FINSET_1, CARD_1, VALUED_1,
      FUNCT_4, RELAT_1, PRE_POLY, AFINSQ_1, COMPOS_1, ORDINAL5, EXTPRO_1,
      FUNCOP_1, FUNCT_7, SCMPDS_3, AMISTD_2, PBOOLE, MEMSTR_0;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, COMPOS_1, EXTPRO_1, FUNCT_7, XBOOLE_0, SCMPDS_2, FUNCOP_1,
      NAT_1, AFINSQ_1, FUNCT_4, AMISTD_2, MEMSTR_0;
 theorems NAT_1, TARSKI, FUNCT_4, FUNCT_1, ZFMISC_1, INT_1, RELAT_1, SCMPDS_2,
      AMI_2, FUNCT_2, FUNCT_7, SCMPDS_3, ENUMSET1, ABSVALUE, GRFUNC_1,
      XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, VALUED_1, AFINSQ_1,
      PARTFUN1, COMPOS_1, EXTPRO_1, AMISTD_2, PBOOLE, STRUCT_0, MEMSTR_0;
 schemes NAT_1, CLASSES1;

begin :: Definition of a program block and its basic properties

reserve l, m, n for Element of NAT,
  i,j,k for Instruction of SCMPDS,
  I,J,K for Program of SCMPDS,
  p,q,r for PartState of SCMPDS;

reserve a,b,c for Int_position,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer;



theorem Th6:
  InsCode i in {0,1,4,5,6} or Exec(i,s).IC SCMPDS = succ IC s
proof
  assume
A1: not InsCode i in {0,1,4,5,6};
  then
A2: InsCode i <> 0 & InsCode i <> 1 by ENUMSET1:def 3;
A3: InsCode i <> 6 by A1,ENUMSET1:def 3;
A4: InsCode i <> 4 & InsCode i <> 5 by A1,ENUMSET1:def 3;
  per cases by A2,A4,A3,NAT_1:37,SCMPDS_2:6;
  suppose
    InsCode i = 2;
    then ex a,k1 st i = a:=k1 by SCMPDS_2:28;
    hence thesis by SCMPDS_2:45;
  end;
  suppose
    InsCode i = 3;
    then ex a,k1 st i = saveIC(a,k1) by SCMPDS_2:29;
    hence thesis by SCMPDS_2:59;
  end;
  suppose
    InsCode i = 7;
    then ex a,k1,k2 st i = (a,k1) := k2 by SCMPDS_2:33;
    hence thesis by SCMPDS_2:46;
  end;
  suppose
    InsCode i = 8;
    then ex a,k1,k2 st i = AddTo(a,k1,k2) by SCMPDS_2:34;
    hence thesis by SCMPDS_2:48;
  end;
  suppose
    InsCode i = 9;
    then ex a,b,k1,k2 st i = AddTo(a,k1,b,k2) by SCMPDS_2:35;
    hence thesis by SCMPDS_2:49;
  end;
  suppose
    InsCode i = 10;
    then ex a,b,k1,k2 st i = SubFrom(a,k1,b,k2) by SCMPDS_2:36;
    hence thesis by SCMPDS_2:50;
  end;
  suppose
    InsCode i = 11;
    then ex a,b,k1,k2 st i = MultBy(a,k1,b,k2) by SCMPDS_2:37;
    hence thesis by SCMPDS_2:51;
  end;
  suppose
    InsCode i = 12;
    then ex a,b,k1,k2 st i = Divide(a,k1,b,k2) by SCMPDS_2:38;
    hence thesis by SCMPDS_2:52;
  end;
  suppose
    InsCode i = 13;
    then ex a,b,k1,k2 st i = (a,k1):=(b,k2) by SCMPDS_2:39;
    hence thesis by SCMPDS_2:47;
  end;
end;



theorem
  for s1,s2 being State of SCMPDS st IC s1 = IC s2 & for a being
  Int_position holds s1.a = s2.a holds  s1 =  s2
proof
  let s1,s2 be State of SCMPDS such that
A1: IC s1 = IC s2 and
A2: for a being Int_position holds s1.a = s2.a;
   the carrier of SCMPDS = {IC SCMPDS } \/ SCM-Data-Loc
      by SCMPDS_2:84,STRUCT_0:4;
   then
A4: (the carrier of SCMPDS) = {IC SCMPDS } \/ SCM-Data-Loc
    .= {IC SCMPDS } \/ SCM-Data-Loc;
A5: dom(s2|(dom s2)) = dom s2 /\ (dom s2) by RELAT_1:61
    .= dom s2
    .= {IC SCMPDS } \/ SCM-Data-Loc by A4,PARTFUN1:def 2;
A6: dom(s1|(dom s1)) = dom s1 /\ (dom s1) by RELAT_1:61
    .= dom s1
    .= {IC SCMPDS } \/ SCM-Data-Loc by A4,PARTFUN1:def 2;
X1: s1|(dom s1) =  s1 & s2|(dom s2) =  s2 by RELAT_1:69;
  now
    let x be set;
    assume
A7: x in {IC SCMPDS } \/ SCM-Data-Loc;
    per cases by A7,XBOOLE_0:def 3;
    suppose
      x in {IC SCMPDS};
      then
A8:   x = IC SCMPDS by TARSKI:def 1;
      hence (s1|(dom s1)).x = IC s1 by A6,A7,FUNCT_1:47
        .= (s2|(dom s2)).x by A1,A5,A7,A8,FUNCT_1:47;
    end;
    suppose
      x in SCM-Data-Loc;
      then
A9:   x is Int_position by SCMPDS_2:3;
      thus (s1|(dom s1)).x = s1.x by A6,A7,FUNCT_1:47
        .= s2.x by A2,A9
        .= (s2|(dom s2)).x by A5,A7,FUNCT_1:47;
    end;
  end;
   then s1|(dom s1) = s2|(dom s2) by A6,A5,FUNCT_1:2;
  hence  s1 =  s2 by X1;
end;



theorem Th17:
  for k1,k2 be Element of NAT st k1 <> k2 holds DataLoc(k1,0) <>
  DataLoc(k2,0)
proof
  let k1,k2 be Element of NAT;
  assume
A1: k1<>k2;
  assume
  DataLoc(k1,0) = DataLoc(k2,0);
  then abs(k1+0) =abs(k2+0) by ZFMISC_1:27;
  then k1=abs(k2) by ABSVALUE:def 1;
  hence contradiction by A1,ABSVALUE:def 1;
end;

theorem Th18:
  for dl being Int_position ex i being Element of NAT st dl =
  DataLoc(i,0)
proof
  let dl be Int_position;
  dl in SCM-Data-Loc by SCMPDS_2:def 2;
  then consider i being Element of NAT such that
A1: dl = [1,i] by AMI_2:23;
  take i;
  thus thesis by A1,ABSVALUE:def 1;
end;

scheme
  SCMPDSEx{ G(set) -> Integer, I() ->
  Element of NAT }: ex S being State of SCMPDS st IC S = I() &
  for i being Element of NAT holds S.DataLoc(i,0) = G(i)
proof
  set S1={IC SCMPDS }, S2=SCM-Data-Loc, S3=NAT;
  defpred P[set,set] means ex m st $1 = IC SCMPDS & $2 = I()
   or $1 = DataLoc(m,0) & $2 = G(m);
A1: for e being set st e in the carrier of SCMPDS ex u being set st P[e,u]
  proof
    let e be set;
    assume
    e in the carrier of SCMPDS;
    then e in S1 \/ S2 by SCMPDS_2:84,STRUCT_0:4;
    then
A2: e in S1 \/ S2;
    now
      per cases by A2,XBOOLE_0:def 3;
      case
        e in S1;
        hence e = IC SCMPDS by TARSKI:def 1;
      end;
      case
        e in S2;
        then e is Int_position by SCMPDS_2:3;
        hence ex m st e = DataLoc(m,0) by Th18;
      end;
    end;
    then consider m such that
A3: e = IC SCMPDS or e = DataLoc(m,0);
    per cases by A3;
    suppose
A4:   e = IC SCMPDS;
      take u = I();
      thus thesis by A4;
    end;
    suppose
A6:   e = DataLoc(m,0);
      take u = G(m);
      thus thesis by A6;
    end;
  end;
  consider f being Function such that
A7: dom f = the carrier of SCMPDS and
A8: for e being set st e in the carrier of SCMPDS holds P[e,f.e] from
  CLASSES1:sch 1(A1);
A9: dom the Object-Kind of SCMPDS = the carrier of SCMPDS by FUNCT_2:def 1;
  now
    let x be set;
    assume
A10: x in dom the Object-Kind of SCMPDS;
    then x in S1 \/ S2 by A9,SCMPDS_2:84,STRUCT_0:4;
    then
A11: x in S1 \/ S2;
    consider m such that
A12: x = IC SCMPDS & f.x = I() or x = DataLoc(m,0) & f.x = G(m) by A8,A9,A10;
    per cases by A11,XBOOLE_0:def 3;
    suppose
      x in S2;
      then
  x is Int_position by SCMPDS_2:3;
      then (the Object-Kind of SCMPDS).x = ObjectKind DataLoc(m,0) by A12,
SCMPDS_2:43
        .= INT by SCMPDS_2:5;
      hence f.x in (the Object-Kind of SCMPDS).x by A12,INT_1:def 2;
    end;
    suppose
A14:  x in S1;
      then (the Object-Kind of SCMPDS).x = ObjectKind IC SCMPDS by TARSKI:def 1
        .= NAT by MEMSTR_0:def 3;
      hence f.x in (the Object-Kind of SCMPDS).x by A12,A14,SCMPDS_2:2
,TARSKI:def 1;
    end;
  end;
  then reconsider f as State of SCMPDS by A7,A9,FUNCT_1:def 14,PARTFUN1:def 2
,RELAT_1:def 18;
  consider m such that
A15: IC SCMPDS = IC SCMPDS & f.IC SCMPDS = I() or
  IC SCMPDS = DataLoc(m,0) & f.IC SCMPDS = G(m) by A8;
  take f;
  thus IC f = I() by A15,SCMPDS_2:43;
  let i be Element of NAT;
  ex m st ( DataLoc(i,0) = IC SCMPDS & f.DataLoc(i,0) = I() or
         DataLoc(i,0) = DataLoc(m,0) & f.DataLoc
  (i,0) = G(m)) by A8;
  hence thesis by Th17,SCMPDS_2:43;
end;

theorem
  for s being State of SCMPDS holds dom s = {IC SCMPDS} \/ SCM-Data-Loc
 proof
  let s be State of SCMPDS;
   dom s = the carrier of SCMPDS by PARTFUN1:def 2;
   hence thesis by SCMPDS_2:84,STRUCT_0:4;
 end;

theorem
  for s being State of SCMPDS, x being set st x in dom s holds x is
  Int_position or x = IC SCMPDS
proof
  set S1={IC SCMPDS}, S2=SCM-Data-Loc, S3=NAT;
  let s be State of SCMPDS;
  let x be set;
  assume
A1: x in dom s;
  dom s = the carrier of SCMPDS by PARTFUN1:def 2;
  then dom s = S1 \/ S2 by SCMPDS_2:84,STRUCT_0:4;
  then x in S1 \/ S2 by A1;
  then x in S1 or x in S2 by XBOOLE_0:def 3;
  hence thesis by SCMPDS_2:3,TARSKI:def 1;
end;



theorem
  for i being Element of NAT holds not i in SCM-Data-Loc
    by AMI_2:21,XBOOLE_0:3;

theorem Th23:
  for s1,s2 being State of SCMPDS holds (for a being Int_position
  holds s1.a = s2.a) iff DataPart s1 = DataPart s2
proof
  set T1={IC SCMPDS}, T2=SCM-Data-Loc, T3=NAT;
  let s1,s2 be State of SCMPDS;
A2: now
    assume
A3: for a being Int_position holds s1.a = s2.a;
    hereby
      let x be set;
      assume
      x in SCM-Data-Loc;
      then x is Int_position by SCMPDS_2:3;
      hence s1.x=s2.x by A3;
    end;
  end;
A4: now
    assume
A5: for x be set st x in SCM-Data-Loc holds s1.x = s2.x;
    hereby
      let a be Int_position;
      a in SCM-Data-Loc by SCMPDS_2:def 2;
      hence s1.a=s2.a by A5;
    end;
  end;
  dom s2 = the carrier of SCMPDS by PARTFUN1:def 2;
  then dom s2 = T1 \/ T2 by SCMPDS_2:84,STRUCT_0:4;
  then
A6: T2 c= dom s2 by XBOOLE_1:7;
  dom s1 = the carrier of SCMPDS by PARTFUN1:def 2;
  then dom s1 = T1 \/ T2 by SCMPDS_2:84,STRUCT_0:4;
  then T2 c= dom s1 by XBOOLE_1:7;
  hence thesis by A6,A2,A4,FUNCT_1:95,SCMPDS_2:84;
end;



reserve x for set;

begin :: Combining two consecutive blocks into one program block

notation
  let I,J be Program of SCMPDS;
  synonym I ';' J for I ^ J;
end;

definition

  let I,J be Program of SCMPDS;
  redefine func I ';' J -> Program of SCMPDS equals
  I +* Shift(J, card I);
  compatibility by AFINSQ_1:77;
  coherence;
end;

begin :: Combining a block and a instruction into one program block

definition
  let i, J;
  func i ';' J -> Program of SCMPDS equals
  Load i ';' J;
  correctness;
end;

definition
  let I, j;
  func I ';' j -> Program of SCMPDS equals
  I ';' Load j;
  correctness;
end;

definition
  let i,j;
  func i ';' j -> Program of SCMPDS equals
  Load i ';' Load j;
  correctness;
end;



theorem
  i ';' j = Load i ';' j;

theorem
  i ';' j = i ';' Load j;



theorem
  I ';' J ';' k = I ';' (J ';' k) by AFINSQ_1:27;

theorem
  I ';' j ';' K = I ';' (j ';' K) by AFINSQ_1:27;

theorem
  I ';' j ';' k = I ';' (j ';' k) by AFINSQ_1:27;

theorem
  i ';' J ';' K = i ';' (J ';' K) by AFINSQ_1:27;

theorem
  i ';' J ';' k = i ';' (J ';' k) by AFINSQ_1:27;

theorem
  i ';' j ';' K = i ';' (j ';' K) by AFINSQ_1:27;

theorem
  i ';' j ';' k = i ';' (j ';' k) by AFINSQ_1:27;



reserve l,l1,loc for Element of NAT;

theorem Th59:
  not a in dom Start-At(l,SCMPDS)
proof
A1: dom Start-At(l,SCMPDS) = {IC SCMPDS} by FUNCOP_1:13;
  assume
  a in dom Start-At(l,SCMPDS);
  then a = IC SCMPDS by A1,TARSKI:def 1;
  hence contradiction by SCMPDS_2:43;
end;



theorem
  not a in dom (I+*Start-At(l,SCMPDS))
proof
  assume
  a in dom (I+*Start-At(l,SCMPDS));
  then a in dom I \/ dom Start-At(l,SCMPDS) by FUNCT_4:def 1;
  then
A1: a in dom I or a in dom Start-At(l,SCMPDS) by XBOOLE_0:def 3;
  dom I c= NAT & a in SCM-Data-Loc by SCMPDS_2:def 2;
  hence contradiction by A1,Th59,AMI_2:21,XBOOLE_0:3;
end;

definition
  let s be State of SCMPDS, li be Int_position, k be Integer;
  redefine func s+*(li,k) -> PartState of SCMPDS;
  coherence
  proof
A1: dom s = the carrier of SCMPDS by PARTFUN1:def 2;
    now
      let x be set;
      assume x in dom(s+*(li,k));
      then
A2:    x in dom s by A1,PARTFUN1:def 2;
      per cases;
      suppose
A3:     x = li;
        then
A4:     (the Object-Kind of SCMPDS).x = ObjectKind li
          .= INT by SCMPDS_2:5;
        (s+*(li,k)).x = k by A1,A3,FUNCT_7:31;
        hence (s+*(li,k)).x in (the Object-Kind of SCMPDS).x by A4,INT_1:def 2;
      end;
      suppose
        x <> li;
        then (s+*(li,k)).x = s.x by FUNCT_7:32;
        hence (s+*(li,k)).x in (the Object-Kind of SCMPDS).x
         by A2,FUNCT_1:def 14;
      end;
    end;
    hence thesis by FUNCT_1:def 14;
  end;
end;

begin :: The notions of paraclosed,parahalting and their basic properties

definition

  let I be Program of SCMPDS, s be State of SCMPDS;
  let P be Instruction-Sequence of SCMPDS;
  func IExec(I,P,s) -> State of SCMPDS equals
  Result(P+*stop I,s);
  coherence;
end;

definition
  let I be Program of SCMPDS;
  attr I is paraclosed means
  :Def9:
  for s being 0-started State of SCMPDS, n being Element of NAT,
      P being Instruction-Sequence of SCMPDS
    st stop I c= P
   holds IC Comput(P,s,n) in dom stop(I);
  attr I is parahalting means
  :Def10:
  for s being 0-started State of SCMPDS,
      P being Instruction-Sequence of SCMPDS
    st stop I c= P
    holds P halts_on s;
end;

Lm1: Load halt SCMPDS is parahalting
proof
  let s be 0-started State of SCMPDS,
      P being Instruction-Sequence of SCMPDS;
  set m = Load halt SCMPDS, m0= stop (m);
  assume
A1: m0 c= P;
A2: IC s = 0 by MEMSTR_0:def 8;
  take 0;
     IC Comput(P,s,0) in NAT;
    hence IC Comput(P,s,0) in dom P by PARTFUN1:def 2;
A3: m. 0 = halt SCMPDS by FUNCOP_1:72;
  dom m={ 0} by FUNCOP_1:13;
  then
A4:  0 in dom m by TARSKI:def 1;
  then
A5:  0 in dom m0 by FUNCT_4:12;
A6: Comput(P,s,0) = s by EXTPRO_1:2;
A7:  P/.IC s = P.IC s by PBOOLE:143;
   CurInstr(P,Comput(P,s,0))
     = m0. 0 by A1,A5,A2,A7,A6,GRFUNC_1:2
    .= halt SCMPDS by A3,A4,AFINSQ_1:def 3;
  hence thesis;
end;

registration
  cluster parahalting for Program of SCMPDS;
  existence by Lm1;
end;

theorem Th66:
 for P,Q being Instruction-Sequence of SCMPDS
  st Q = P +*((IC s,succ IC s) --> (goto 1, goto -1))
 holds
  not Q halts_on s
proof
 let P,Q be Instruction-Sequence of SCMPDS such that
Z: Q = P +*((IC s,succ IC s) --> (goto 1, goto -1));
  set m=(IC s,succ IC s) --> (goto 1, goto -1);
A1: m.(succ IC s)=goto -1 by FUNCT_4:63;
  IC s<>succ IC s;
  then
A2: m.(IC s) = goto 1 by FUNCT_4:63;
  defpred X[Nat] means
   IC(Comput(Q,s,$1)) = IC s or IC(Comput(Q,s,$1)) = succ IC s;
A3: dom m = {IC s,succ IC s} by FUNCT_4:62;
  then
A4: succ IC s in dom m by TARSKI:def 2;
A6: IC s in dom m by A3,TARSKI:def 2;
  now
    let n;
    set Cn=Comput(Q,s,n);
    assume
A7: IC Cn = IC s or IC Cn = succ IC s;
A8:  Q/.IC Cn = Q.IC Cn by PBOOLE:143;
    per cases by A7;
    case
A9:   IC Cn = IC s;
      then
A10:   CurInstr(Q,Cn) = Q.IC s by A8
        .= goto 1 by A6,A2,Z,FUNCT_4:13;
      thus IC (Comput(Q,s,n+1)) = IC Following(Q,Cn)
      by EXTPRO_1:3
        .= ICplusConst(Cn,1) by A10,SCMPDS_2:54
        .= succ IC s by A9,SCMPDS_3:10;
    end;
    case
A12:  IC Cn = succ IC s;
      reconsider i = IC s as Element of NAT;
A13:  ex j be Element of NAT st j = IC Cn & ICplusConst(Cn,-1) =abs(j+(-1)
      ) by SCMPDS_2:def 18;
A14:  Q/.IC Comput(Q,s,n) = Q.IC Comput(Q,s,n) by PBOOLE:143;
A15:  CurInstr(Q,Comput(Q,s,n))
        = Q.(succ IC s) by A12,A14
        .= goto -1 by A4,A1,Z,FUNCT_4:13;
      thus IC(Comput(Q,s,n+1)) = IC Following(Q,Cn)
       by EXTPRO_1:3
        .=abs(i+4 + -4 ) by A12,A15,A13,SCMPDS_2:54
        .=IC s by ABSVALUE:def 1;
    end;
  end;
  then
A17: for n st X[n] holds X[n+1];
  let nn be Nat;
   reconsider n=nn as Element of NAT by ORDINAL1:def 12;
  assume IC Comput(Q,s,nn) in dom Q;
A18: X[0] by EXTPRO_1:2;
A19: for n holds X[n] from NAT_1:sch 1(A18,A17);
A21: Q/.IC Comput(Q,s,n) = Q.IC Comput(Q,s,n) by PBOOLE:143;
  per cases by A19;
  suppose
    IC(Comput(Q,s,n)) = IC s;
    then CurInstr(Q,Comput(Q,s,n))
     = Q.IC s by A21
    .= goto 1 by A6,A2,Z,FUNCT_4:13;
   hence thesis by SCMPDS_2:73;
  end;
  suppose
    IC(Comput(Q,s,n)) = succ IC s;
    then CurInstr(Q,Comput(Q,s,n))
     = Q.succ IC s by A21
    .= goto -1 by A4,A1,Z,FUNCT_4:13;
    hence thesis by SCMPDS_2:73;
  end;
end;

theorem Th67:
 for P1,P2 being Instruction-Sequence of SCMPDS
  st  s1 =  s2 & I c= P1 & I c= P2 & (for m st m < n
  holds IC (Comput(P2,s2,m)) in dom I)
 for m st m <= n
holds
   Comput(P1,s1,m) =  Comput(P2,s2,m)
proof
 let P1,P2 be Instruction-Sequence of SCMPDS;
  assume that
A1:  s1 =  s2 and
A2: I c= P1 and
A3: I c= P2 and
A4: for m st m < n holds IC(Comput(P2,s2,m)) in dom I;
  defpred X[Nat] means $1 <= n implies
    Comput(P1,s1,$1) =  Comput(P2,s2,$1);
A5: for m st X[m] holds X[m+1]
  proof
    let m such that
A6: m <= n implies
     Comput(P1,s1,m) =  Comput(P2,s2,m);
A7: Comput(P2,s2,m+1) = Following(P2,Comput(P2,s2,m)) by EXTPRO_1:3
      .= Exec(CurInstr(P2,Comput(P2,s2,m)),Comput(P2,s2,m));
A8: Comput(P1,s1,m+1) = Following(P1,Comput(P1,s1,m)) by EXTPRO_1:3
      .= Exec(CurInstr(P1,Comput(P1,s1,m)),Comput(P1,s1,m));
    assume
A9: m+1 <= n;
    then
A10: IC (Comput(P1,s1,m)) = IC (Comput(P2,s2,m)) by A6,NAT_1:13;
    m < n by A9,NAT_1:13;
    then
A11: IC(Comput(P2,s2,m)) in dom I by A4;
A12:  P1/.IC Comput(P1,s1,m) = P1.IC Comput(P1,s1,m) by PBOOLE:143;
A13:  P2/.IC Comput(P2,s2,m) = P2.IC Comput(P2,s2,m) by PBOOLE:143;
    CurInstr(P1,Comput(P1,s1,m))
     = P1.IC(Comput(P1,s1,m)) by A12
      .= I.IC(Comput(P1,s1,m)) by A2,A11,A10,GRFUNC_1:2
      .= P2.IC(Comput(P2,s2,m)) by A3,A11,A10,GRFUNC_1:2
      .= CurInstr(P2,Comput(P2,s2,m)) by A13;
    hence thesis by A6,A8,A7,A9,NAT_1:13;
  end;
  Comput(P1,s1,0) = s1 by EXTPRO_1:2;
  then
A14: X[0] by A1,EXTPRO_1:2;
  thus for m holds X[m] from NAT_1:sch 1(A14,A5);
end;

reserve l1,l2 for Element of NAT,
  i1,i2 for Instruction of SCMPDS;

registration
  cluster parahalting -> paraclosed for Program of SCMPDS;
  coherence
  proof
    let I be Program of SCMPDS;
    assume
A1: I is parahalting;
    let s be 0-started State of SCMPDS, n be Element of NAT,
        P being Instruction-Sequence of SCMPDS;
    defpred X[Nat] means not IC Comput(P,s,$1) in dom stop(I);
    assume
A2: stop(I) c= P;
    assume
    not IC Comput(P,s,n) in dom stop(I);
    then
A3: ex n be Nat st X[n];
    consider n be Nat such that
A4: X[n] and
A5: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A3);
    reconsider n as Element of NAT by ORDINAL1:def 12;
A6: for m st m < n holds IC(Comput(P,s,m)) in dom stop I by A5;
    set s2 = Comput(P,s,n),
        Ig = ((IC s2,succ IC s2) --> (goto 1,goto -1));
    reconsider P0 = P +* Ig
      as Instruction-Sequence of SCMPDS;
    reconsider P3 = P +* (IC s2,goto 1)
      as Instruction-Sequence of SCMPDS;
    reconsider P2 = P3 +* (succ IC s2,goto -1)
      as Instruction-Sequence of SCMPDS;
    reconsider P4 = P3 +* (succ IC s2,goto -1)
      as Instruction-Sequence of SCMPDS;
U:   P0 = P4 by FUNCT_7:139;
A9: not succ IC s2 in dom stop I by A4,AFINSQ_1:73;
    stop I c= P3 by A2,A4,FUNCT_7:89;
    then stop I c= P4 by A9,FUNCT_7:89;
    then
A13:    stop I c= P0 by U;
    then  Comput(P0,s,n) =  s2 by A2,A6,Th67;
    then
XX:   Comput(P0,s,n) =  s2;
A15: not P0 halts_on s2 by Th66;
    P0 halts_on s by A1,A13,Def10;
    then P0 halts_on Comput(P0,s,n) by EXTPRO_1:22;
    then P0 halts_on s2 by XX;
    hence contradiction by A15;
  end;
end;

begin :: Shiftability of program blocks and instructions

definition
  let i be Instruction of SCMPDS;
  let n be Element of NAT;
  pred i valid_at n means
  :Def11:
  (InsCode i= 0 implies ex k1 st i = goto k1 &
  n+k1 >= 0) & (InsCode i= 4 implies ex a,k1,k2 st i = (a,k1)<>0_goto k2 & n+k2
>= 0 ) & (InsCode i= 5 implies ex a,k1,k2 st i = (a,k1)<=0_goto k2 & n+k2 >= 0
  ) & (InsCode i= 6 implies ex a,k1,k2 st i = (a,k1)>=0_goto k2 & n+k2 >= 0);
end;

reserve l for Element of NAT;

definition
  let IT be finite (the Instructions of SCMPDS)-valued NAT-defined Function;
  attr IT is shiftable means
  :Def12:
  for n,i st  n in dom IT & i=IT.(n)
   holds InsCode i <> 1 & InsCode i <> 3 & i valid_at n;
end;

Lm2: Load halt SCMPDS is shiftable
proof
  set m = Load halt SCMPDS;
A1: m. 0 = halt SCMPDS by FUNCOP_1:72;
A2: dom m={ 0} by FUNCOP_1:13;
  now
    let n,i;
    assume that
A3:  n in dom m and
A4: i=m.( n);
A5:  n=  0 by A2,A3,TARSKI:def 1;
    hence InsCode i <> 1 by A1,A4,SCMPDS_2:12,81;
A6: ex k1 st i = goto k1 & n+k1 >= 0
    proof
      take 0;
      thus i=goto 0 by A4,A5,FUNCOP_1:72,SCMPDS_2:81;
      thus n+0>=0;
    end;
    thus InsCode i <> 3 by A1,A4,A5,SCMPDS_2:12,81;
    InsCode i =0 by A1,A4,A5,SCMPDS_2:12,81;
    hence i valid_at n by A6,Def11;
  end;
  hence thesis by Def12;
end;



theorem Th77:
  for i be Instruction of SCMPDS,m,n be Element of NAT st i
  valid_at m & m <= n holds i valid_at n
proof
  let i be Instruction of SCMPDS,m,n be Element of NAT;
  assume that
A1: i valid_at m and
A2: m <= n;
A3: now
    assume
    InsCode i= 4;
    then consider a,k1,k2 such that
A4: i = (a,k1)<>0_goto k2 and
A5: m+k2 >= 0 by A1,Def11;
    take a,k1,k2;
    thus i = (a,k1)<>0_goto k2 by A4;
    thus n+k2 >= 0 by A2,A5,XREAL_1:6;
  end;
A6: now
    assume
    InsCode i= 6;
    then consider a,k1,k2 such that
A7: i = (a,k1)>=0_goto k2 and
A8: m+k2 >= 0 by A1,Def11;
    take a,k1,k2;
    thus i = (a,k1)>=0_goto k2 by A7;
    thus n+k2 >= 0 by A2,A8,XREAL_1:6;
  end;
A9: now
    assume
    InsCode i= 5;
    then consider a,k1,k2 such that
A10: i = (a,k1)<=0_goto k2 and
A11: m+k2 >= 0 by A1,Def11;
    take a,k1,k2;
    thus i = (a,k1)<=0_goto k2 by A10;
    thus n+k2 >= 0 by A2,A11,XREAL_1:6;
  end;
  now
    assume
    InsCode i= 0;
    then consider k1 such that
A12: i=goto k1 and
A13: m+k1 >= 0 by A1,Def11;
    take k1;
    thus i=goto k1 by A12;
    thus n+k1 >= 0 by A2,A13,XREAL_1:6;
  end;
  hence thesis by A3,A9,A6,Def11;
end;

registration
  cluster parahalting shiftable for Program of SCMPDS;
  existence by Lm1,Lm2;
end;

definition
  let i be Instruction of SCMPDS;
  attr i is shiftable means
  :Def13:
  InsCode i = 2 or InsCode i > 6;
end;

registration
  cluster shiftable for Instruction of SCMPDS;
  existence
  proof
    take i=DataLoc(0,0):=1;
    InsCode i=2 by SCMPDS_2:14;
    hence thesis by Def13;
  end;
end;

registration
  let a,k1;
  cluster a := k1 -> shiftable;
  coherence
  proof
    InsCode (a:=k1)=2 by SCMPDS_2:14;
    hence thesis by Def13;
  end;
end;

registration
  let a,k1,k2;
  cluster (a,k1) := k2 -> shiftable;
  coherence
  proof
    InsCode ((a,k1) := k2)=7 by SCMPDS_2:19;
    hence thesis by Def13;
  end;
end;

registration
  let a,k1,k2;
  cluster AddTo(a,k1,k2) -> shiftable;
  coherence
  proof
    InsCode AddTo(a,k1,k2)=8 by SCMPDS_2:20;
    hence thesis by Def13;
  end;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> shiftable;
  coherence
  proof
    InsCode AddTo(a,k1,b,k2)=9 by SCMPDS_2:21;
    hence thesis by Def13;
  end;
  cluster SubFrom(a,k1,b,k2) -> shiftable;
  coherence
  proof
    InsCode SubFrom(a,k1,b,k2)=10 by SCMPDS_2:22;
    hence thesis by Def13;
  end;
  cluster MultBy(a,k1,b,k2) -> shiftable;
  coherence
  proof
    InsCode MultBy(a,k1,b,k2)=11 by SCMPDS_2:23;
    hence thesis by Def13;
  end;
  cluster Divide(a,k1,b,k2) -> shiftable;
  coherence
  proof
    InsCode Divide(a,k1,b,k2)=12 by SCMPDS_2:24;
    hence thesis by Def13;
  end;
  cluster (a,k1) := (b,k2) -> shiftable;
  coherence
  proof
    InsCode (a,k1) := (b,k2)=13 by SCMPDS_2:25;
    hence thesis by Def13;
  end;
end;

registration
  let I,J be shiftable Program of SCMPDS;
  cluster I ';' J -> shiftable for Program of SCMPDS;
  coherence
  proof
    set IJ=I ';' J;
    now
      set D = {l+card I: l in dom J };
      let n,i such that
A1:    n in dom IJ and
A2:   i=IJ.( n);
      dom Shift(J,card I) = D by VALUED_1:def 12;
      then
A3:   dom IJ = dom I \/ D by FUNCT_4:def 1;
      per cases by A1,A3,XBOOLE_0:def 3;
      suppose
A4:      n in dom I;
        then I. n=i by A2,AFINSQ_1:def 3;
        hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A4,Def12;
      end;
      suppose
         n in D;
        then consider l such that
A5:     n = l+card I and
A6:     l in dom J;
A7:     J. l =i by A2,A5,A6,AFINSQ_1:def 3;
        hence InsCode i <> 1 & InsCode i <> 3 by A6,Def12;
        i valid_at l by A6,A7,Def12;
        hence i valid_at n by A5,Th77,NAT_1:11;
      end;
    end;
    hence thesis by Def12;
  end;
end;

registration
  let i be shiftable Instruction of SCMPDS;
  cluster Load i -> shiftable for Program of SCMPDS;
  coherence
  proof
    set p=Load i;
    now
      let n,j such that
A1:    n in dom p and
A2:   j=p. n;
      dom p = {  0 } by FUNCOP_1:13;
      then  n =  0 by A1,TARSKI:def 1;
      then
A3:   j=i by A2,FUNCOP_1:72;
      hence InsCode j <> 1 by Def13;
      thus InsCode j <> 3 by A3,Def13;
A4:   InsCode j <> 4 & InsCode j <> 5 by A3,Def13;
      InsCode j=2 or InsCode j > 6 by A3,Def13;
      hence j valid_at n by A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

registration
  let i be shiftable Instruction of SCMPDS, J be shiftable Program of SCMPDS;
  cluster i ';' J -> shiftable;
  coherence;
end;

registration
  let I be shiftable Program of SCMPDS, j be shiftable Instruction of SCMPDS;
  cluster I ';' j -> shiftable;
  coherence;
end;

registration
  let i,j be shiftable Instruction of SCMPDS;
  cluster i ';' j -> shiftable;
  coherence;
end;

registration
  cluster Stop SCMPDS -> parahalting shiftable;
  coherence by Lm1,Lm2;
end;

registration
  let I be shiftable Program of SCMPDS;
  cluster stop I -> shiftable;
  coherence;
end;

theorem
  for I being shiftable Program of SCMPDS,k1 be Integer st card I + k1
  >= 0 holds I ';' goto k1 is shiftable
proof
  let I be shiftable Program of SCMPDS,k1 be Integer;
  set J= Load goto k1;
  set Ig=I ';' goto k1;
  assume
A1: card I + k1 >= 0;
  now
    set D = {l+card I: l in dom J };
    let n,i such that
A2:  n in dom Ig and
A3: i=Ig.( n);
    dom Shift(J,card I) = D by VALUED_1:def 12;
    then
A4: dom Ig = dom I \/ D by FUNCT_4:def 1;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A5:    n in dom I;
      then I. n=i by A3,AFINSQ_1:def 3;
      hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A5,Def12;
    end;
    suppose
       n in D;
      then consider l such that
A6:   n = l+card I and
A7:   l in dom J;
      dom J = {  0 } by FUNCOP_1:13;
      then
A8:    l =  0 by A7,TARSKI:def 1;
      then
A9:   goto k1 =J. l by FUNCOP_1:72
        .=i by A3,A6,A7,AFINSQ_1:def 3;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:12;
A10:  InsCode i <> 6 by A9,SCMPDS_2:12;
      InsCode i <> 4 & InsCode i <> 5 by A9,SCMPDS_2:12;
      hence i valid_at n by A1,A6,A8,A9,A10,Def11;
    end;
  end;
  hence thesis by Def12;
end;

registration
  let n be Element of NAT;
  cluster Load goto n -> shiftable for Program of SCMPDS;
  coherence
  proof
    set k1=n;
    set J= Load goto k1;
    now
      let n,i such that
A1:    n in dom J and
A2:   i=J. n;
      dom J = {  0 } by FUNCOP_1:13;
      then  n =  0 by A1,TARSKI:def 1;
      then
A3:   goto k1 =i by A2,FUNCOP_1:72;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:12;
A4:   n+k1 >=0 & InsCode i <> 6 by A3,SCMPDS_2:12;
      InsCode i <> 4 & InsCode i <> 5 by A3,SCMPDS_2:12;
      hence i valid_at n by A3,A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

theorem
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)<>0_goto k2 is shiftable
proof
  let I be shiftable Program of SCMPDS,k1,k2 be Integer,a be Int_position;
  set ii= (a,k1)<>0_goto k2, J= Load ii;
  set Ig=I ';' ii;
  assume
A1: card I + k2 >= 0;
  now
    set D = {l+card I: l in dom J };
    let n,i such that
A2:  n in dom Ig and
A3: i=Ig.( n);
    dom Shift(J,card I) = D by VALUED_1:def 12;
    then
A4: dom Ig = dom I \/ D by FUNCT_4:def 1;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A5:    n in dom I;
      then I. n=i by A3,AFINSQ_1:def 3;
      hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A5,Def12;
    end;
    suppose
       n in D;
      then consider l such that
A6:   n = l+card I and
A7:   l in dom J;
      dom J = {  0 } by FUNCOP_1:13;
      then
A8:    l =  0 by A7,TARSKI:def 1;
      then
A9:   ii=J. l by FUNCOP_1:72
        .=i by A3,A6,A7,AFINSQ_1:def 3;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:16;
A10:  InsCode i <> 6 by A9,SCMPDS_2:16;
      InsCode i <> 0 & InsCode i <> 5 by A9,SCMPDS_2:16;
      hence i valid_at n by A1,A6,A8,A9,A10,Def11;
    end;
  end;
  hence thesis by Def12;
end;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)<>0_goto n -> shiftable for Program of SCMPDS;
  coherence
  proof
    set k2=n;
    set ii= (a,k1)<>0_goto k2, J= Load ii;
    now
      let n,i such that
A1:    n in dom J and
A2:   i=J. n;
      dom J = {  0 } by FUNCOP_1:13;
      then  n =  0 by A1,TARSKI:def 1;
      then
A3:   ii =i by A2,FUNCOP_1:72;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:16;
A4:   n+k2 >=0 & InsCode i <> 6 by A3,SCMPDS_2:16;
      InsCode i <> 0 & InsCode i <> 5 by A3,SCMPDS_2:16;
      hence i valid_at n by A3,A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

theorem
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)<=0_goto k2 is shiftable
proof
  let I be shiftable Program of SCMPDS,k1,k2 be Integer,a be Int_position;
  set ii= (a,k1)<=0_goto k2, J= Load ii;
  set Ig=I ';' ii;
  assume
A1: card I + k2 >= 0;
  now
    set D = {l+card I: l in dom J };
    let n,i such that
A2:  n in dom Ig and
A3: i=Ig.( n);
    dom Shift(J,card I) = D by VALUED_1:def 12;
    then
A4: dom Ig = dom I \/ D by FUNCT_4:def 1;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A5:    n in dom I;
      then I. n=i by A3,AFINSQ_1:def 3;
      hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A5,Def12;
    end;
    suppose
       n in D;
      then consider l such that
A6:   n = l+card I and
A7:   l in dom J;
      dom J = {  0 } by FUNCOP_1:13;
      then
A8:    l =  0 by A7,TARSKI:def 1;
      then
A9:   ii =J. l by FUNCOP_1:72
        .=i by A3,A6,A7,AFINSQ_1:def 3;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:17;
A10:  InsCode i <> 6 by A9,SCMPDS_2:17;
      InsCode i <> 0 & InsCode i <> 4 by A9,SCMPDS_2:17;
      hence i valid_at n by A1,A6,A8,A9,A10,Def11;
    end;
  end;
  hence thesis by Def12;
end;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)<=0_goto n -> shiftable for Program of SCMPDS;
  coherence
  proof
    set k2=n;
    set ii= (a,k1)<=0_goto k2, J= Load ii;
    now
      let n,i such that
A1:    n in dom J and
A2:   i=J. n;
      dom J = {  0 } by FUNCOP_1:13;
      then  n =  0 by A1,TARSKI:def 1;
      then
A3:   ii =i by A2,FUNCOP_1:72;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:17;
A4:   n+k2 >=0 & InsCode i <> 6 by A3,SCMPDS_2:17;
      InsCode i <> 0 & InsCode i <> 4 by A3,SCMPDS_2:17;
      hence i valid_at n by A3,A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

theorem
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)>=0_goto k2 is shiftable
proof
  let I be shiftable Program of SCMPDS,k1,k2 be Integer,a be Int_position;
  set ii= (a,k1)>=0_goto k2, J= Load ii;
  set Ig=I ';' ii;
  assume
A1: card I + k2 >= 0;
  now
    set D = {l+card I: l in dom J };
    let n,i such that
A2:  n in dom Ig and
A3: i=Ig.( n);
    dom Shift(J,card I) = D by VALUED_1:def 12;
    then
A4: dom Ig = dom I \/ D by FUNCT_4:def 1;
    per cases by A2,A4,XBOOLE_0:def 3;
    suppose
A5:    n in dom I;
      then I. n=i by A3,AFINSQ_1:def 3;
      hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A5,Def12;
    end;
    suppose
       n in D;
      then consider l such that
A6:   n = l+card I and
A7:   l in dom J;
      dom J = {  0 } by FUNCOP_1:13;
      then
A8:    l =  0 by A7,TARSKI:def 1;
      then
A9:   ii =J. l by FUNCOP_1:72
        .=i by A3,A6,A7,AFINSQ_1:def 3;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:18;
A10:  InsCode i <> 5 by A9,SCMPDS_2:18;
      InsCode i <> 0 & InsCode i <> 4 by A9,SCMPDS_2:18;
      hence i valid_at n by A1,A6,A8,A9,A10,Def11;
    end;
  end;
  hence thesis by Def12;
end;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)>=0_goto n -> shiftable for Program of SCMPDS;
  coherence
  proof
    set k2=n;
    set ii= (a,k1)>=0_goto k2, J= Load ii;
    now
      let n,i such that
A1:    n in dom J and
A2:   i=J. n;
      dom J = {  0 } by FUNCOP_1:13;
      then  n =  0 by A1,TARSKI:def 1;
      then
A3:   ii =i by A2,FUNCOP_1:72;
      hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:18;
A4:   n+k2 >=0 & InsCode i <> 5 by A3,SCMPDS_2:18;
      InsCode i <> 0 & InsCode i <> 4 by A3,SCMPDS_2:18;
      hence i valid_at n by A3,A4,Def11;
    end;
    hence thesis by Def12;
  end;
end;

theorem Th82:
  for s1,s2 being State of SCMPDS, n,m being Element of NAT,k1 be
Integer st IC s1= m & m+k1>=0 & IC s1 + n = IC s2
 holds ICplusConst(s1,k1) +n = ICplusConst(s2,k1)
proof
  let s1,s2 be State of SCMPDS, n,m be Element of NAT,k1 be Integer;
  assume that
A1: IC s1= m and
A2: m+k1>=0 and
A3: IC s1 + n = IC s2;
  reconsider nk = ICplusConst(s1,k1) as Element of NAT;
  reconsider mk=m+k1 as Element of NAT by A2,INT_1:3;
  ex n1 be Element of NAT st n1 = IC s1 & ICplusConst(s1, k1) = abs(n1+k1)
  by SCMPDS_2:def 18;
  then
  (ex n2 be Element of NAT st n2 = IC s2 & ICplusConst(s2, k1) = abs(n2+k1
  ) )& nk=mk by A1,ABSVALUE:def 1,SCMPDS_2:def 18;
  hence thesis by A1,A3,ABSVALUE:def 1;
end;

theorem Th83:
  for s1,s2 being State of SCMPDS, n,m being Element of NAT, i
being Instruction of SCMPDS holds IC s1= m & i valid_at m & InsCode i <>
  1 & InsCode i <> 3 & IC s1 + n = IC s2 & DataPart s1 = DataPart s2 implies IC
  Exec(i,s1) + n = IC Exec(i,s2) & DataPart Exec(i,s1) = DataPart Exec(i,s2)
proof
  let s1,s2 be State of SCMPDS, n,m be Element of NAT;
  let i be Instruction of SCMPDS;
  assume that
A1: IC s1= m and
A2: i valid_at m and
A3: InsCode i <> 1 & InsCode i <> 3 and
A4: IC s1 + n = IC s2 and
A5: DataPart s1 = DataPart s2;
A6: now
    let a,k1;
    thus s1.DataLoc(s1.a,k1) =s1.DataLoc(s2.a,k1) by A5,Th23
      .=s2.DataLoc(s2.a,k1) by A5,Th23;
  end;
  reconsider k1 = IC s1 as Element of NAT;
  set Ci=InsCode i;
A7: succ IC s1 + n = succ IC s2 by A4;
A8: now
    assume
    Ci <> 0 & Ci<>1 & Ci<>4 & Ci<>5 & Ci<> 6;
    then
A9: not Ci in {0,1,4,5,6} by ENUMSET1:def 3;
    then IC Exec(i,s1) = succ IC s1 by Th6;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A7,A9,Th6;
  end;
  per cases by A3,NAT_1:37,SCMPDS_2:6;
  suppose
    Ci = 0;
    then consider k1 such that
A10: i = goto k1 and
A11: m+k1 >= 0 by A2,Def11;
    IC Exec(i,s1) = ICplusConst(s1,k1) by A10,SCMPDS_2:54;
    hence IC Exec(i,s1) + n = ICplusConst(s2,k1) by A1,A4,A11,Th82
      .= IC Exec(i,s2) by A10,SCMPDS_2:54;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A10,SCMPDS_2:54
        .=s2.a by A5,Th23
        .=Exec(i, s2).a by A10,SCMPDS_2:54;
    end;
    hence thesis by Th23;
  end;
  suppose
A12: Ci = 2;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,k1 such that
A13: i = a := k1 by A12,SCMPDS_2:28;
    now
      let b;
      per cases;
      suppose
A14:    a=b;
        hence Exec(i, s1).b= k1 by A13,SCMPDS_2:45
          .=Exec(i,s2).b by A13,A14,SCMPDS_2:45;
      end;
      suppose
A15:    a<>b;
        hence Exec(i,s1).b = s1.b by A13,SCMPDS_2:45
          .=s2.b by A5,Th23
          .=Exec(i,s2).b by A13,A15,SCMPDS_2:45;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
    Ci = 4;
    then consider a,k1,k2 such that
A16: i = (a,k1)<>0_goto k2 and
A17: m+k2 >= 0 by A2,Def11;
    hereby
      per cases;
      suppose
A18:    s1.DataLoc(s1.a,k1) <> 0;
        then
A19:    s2.DataLoc(s2.a,k1) <> 0 by A6;
        IC Exec(i,s1) = ICplusConst(s1,k2) by A16,A18,SCMPDS_2:55;
        hence IC Exec(i,s1) + n = ICplusConst(s2,k2) by A1,A4,A17,Th82
          .= IC Exec(i,s2) by A16,A19,SCMPDS_2:55;
      end;
      suppose
        s1.DataLoc(s1.a,k1) = 0;
        then s2.DataLoc(s2.a,k1) = 0 & IC Exec(i,s1) = succ IC s1 by A6,A16,
SCMPDS_2:55;
        hence IC Exec(i,s1) + n = IC Exec(i,s2) by A7,A16,SCMPDS_2:55;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A16,SCMPDS_2:55
        .=s2.a by A5,Th23
        .=Exec(i, s2).a by A16,SCMPDS_2:55;
    end;
    hence thesis by Th23;
  end;
  suppose
    Ci = 5;
    then consider a,k1,k2 such that
A20: i = (a,k1)<=0_goto k2 and
A21: m+k2 >= 0 by A2,Def11;
    hereby
      per cases;
      suppose
A22:    s1.DataLoc(s1.a,k1) <= 0;
        then
A23:    s2.DataLoc(s2.a,k1) <= 0 by A6;
        IC Exec(i,s1) = ICplusConst(s1,k2) by A20,A22,SCMPDS_2:56;
        hence IC Exec(i,s1) + n = ICplusConst(s2,k2) by A1,A4,A21,Th82
          .= IC Exec(i,s2) by A20,A23,SCMPDS_2:56;
      end;
      suppose
        s1.DataLoc(s1.a,k1) > 0;
        then s2.DataLoc(s2.a,k1) > 0 & IC Exec(i,s1) = succ IC s1 by A6,A20,
SCMPDS_2:56;
        hence IC Exec(i,s1) + n = IC Exec(i,s2) by A7,A20,SCMPDS_2:56;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A20,SCMPDS_2:56
        .=s2.a by A5,Th23
        .=Exec(i, s2).a by A20,SCMPDS_2:56;
    end;
    hence thesis by Th23;
  end;
  suppose
    Ci = 6;
    then consider a,k1,k2 such that
A24: i = (a,k1)>=0_goto k2 and
A25: m+k2 >= 0 by A2,Def11;
    hereby
      per cases;
      suppose
A26:    s1.DataLoc(s1.a,k1) >= 0;
        then
A27:    s2.DataLoc(s2.a,k1) >= 0 by A6;
        IC Exec(i,s1) = ICplusConst(s1,k2) by A24,A26,SCMPDS_2:57;
        hence IC Exec(i,s1) + n = ICplusConst(s2,k2) by A1,A4,A25,Th82
          .= IC Exec(i,s2) by A24,A27,SCMPDS_2:57;
      end;
      suppose
        s1.DataLoc(s1.a,k1) < 0;
        then s2.DataLoc(s2.a,k1) < 0 & IC Exec(i,s1) = succ IC s1 by A6,A24,
SCMPDS_2:57;
        hence IC Exec(i,s1) + n = IC Exec(i,s2) by A7,A24,SCMPDS_2:57;
      end;
    end;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A24,SCMPDS_2:57
        .=s2.a by A5,Th23
        .=Exec(i, s2).a by A24,SCMPDS_2:57;
    end;
    hence thesis by Th23;
  end;
  suppose
A28: Ci = 7;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,k1,k2 such that
A29: i = (a,k1) := k2 by A28,SCMPDS_2:33;
    now
      let b;
      per cases;
      suppose
A30:    DataLoc(s1.a,k1)=b;
        then
A31:    DataLoc(s2.a,k1)=b by A5,Th23;
        thus Exec(i, s1).b= k2 by A29,A30,SCMPDS_2:46
          .=Exec(i,s2).b by A29,A31,SCMPDS_2:46;
      end;
      suppose
A32:    DataLoc(s1.a,k1)<>b;
        then
A33:    DataLoc(s2.a,k1)<>b by A5,Th23;
        thus Exec(i,s1).b = s1.b by A29,A32,SCMPDS_2:46
          .=s2.b by A5,Th23
          .=Exec(i,s2).b by A29,A33,SCMPDS_2:46;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A34: Ci = 8;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,k1,k2 such that
A35: i = AddTo(a,k1,k2) by A34,SCMPDS_2:34;
    now
      let b;
      per cases;
      suppose
A36:    DataLoc(s1.a,k1)=b;
        then
A37:    DataLoc(s2.a,k1)=b by A5,Th23;
        thus Exec(i, s1).b= s1.DataLoc(s1.a,k1)+k2 by A35,A36,SCMPDS_2:48
          .= s2.DataLoc(s2.a,k1)+k2 by A6
          .=Exec(i,s2).b by A35,A37,SCMPDS_2:48;
      end;
      suppose
A38:    DataLoc(s1.a,k1)<>b;
        then
A39:    DataLoc(s2.a,k1)<>b by A5,Th23;
        thus Exec(i,s1).b = s1.b by A35,A38,SCMPDS_2:48
          .=s2.b by A5,Th23
          .=Exec(i,s2).b by A35,A39,SCMPDS_2:48;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A40: Ci = 9;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A41: i = AddTo(a,k1,b,k2) by A40,SCMPDS_2:35;
    now
      let c;
      per cases;
      suppose
A42:    DataLoc(s1.a,k1)=c;
        then
A43:    DataLoc(s2.a,k1)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)+s1.DataLoc(s1.b,k2) by A41,A42
,SCMPDS_2:49
          .= s2.DataLoc(s2.a,k1)+s1.DataLoc(s1.b,k2) by A6
          .= s2.DataLoc(s2.a,k1)+s2.DataLoc(s2.b,k2) by A6
          .=Exec(i,s2).c by A41,A43,SCMPDS_2:49;
      end;
      suppose
A44:    DataLoc(s1.a,k1)<>c;
        then
A45:    DataLoc(s2.a,k1)<>c by A5,Th23;
        thus Exec(i,s1).c = s1.c by A41,A44,SCMPDS_2:49
          .=s2.c by A5,Th23
          .=Exec(i,s2).c by A41,A45,SCMPDS_2:49;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A46: Ci = 10;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A47: i = SubFrom(a,k1,b,k2) by A46,SCMPDS_2:36;
    now
      let c;
      per cases;
      suppose
A48:    DataLoc(s1.a,k1)=c;
        then
A49:    DataLoc(s2.a,k1)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)-s1.DataLoc(s1.b,k2) by A47,A48
,SCMPDS_2:50
          .= s2.DataLoc(s2.a,k1)-s1.DataLoc(s1.b,k2) by A6
          .= s2.DataLoc(s2.a,k1)-s2.DataLoc(s2.b,k2) by A6
          .=Exec(i,s2).c by A47,A49,SCMPDS_2:50;
      end;
      suppose
A50:    DataLoc(s1.a,k1)<>c;
        then
A51:    DataLoc(s2.a,k1)<>c by A5,Th23;
        thus Exec(i,s1).c = s1.c by A47,A50,SCMPDS_2:50
          .=s2.c by A5,Th23
          .=Exec(i,s2).c by A47,A51,SCMPDS_2:50;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A52: Ci = 11;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A53: i = MultBy(a,k1,b,k2) by A52,SCMPDS_2:37;
    now
      let c;
      per cases;
      suppose
A54:    DataLoc(s1.a,k1)=c;
        then
A55:    DataLoc(s2.a,k1)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)*s1.DataLoc(s1.b,k2) by A53,A54
,SCMPDS_2:51
          .= s2.DataLoc(s2.a,k1)*s1.DataLoc(s1.b,k2) by A6
          .= s2.DataLoc(s2.a,k1)*s2.DataLoc(s2.b,k2) by A6
          .=Exec(i,s2).c by A53,A55,SCMPDS_2:51;
      end;
      suppose
A56:    DataLoc(s1.a,k1)<>c;
        then
A57:    DataLoc(s2.a,k1)<>c by A5,Th23;
        thus Exec(i,s1).c = s1.c by A53,A56,SCMPDS_2:51
          .=s2.c by A5,Th23
          .=Exec(i,s2).c by A53,A57,SCMPDS_2:51;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A58: Ci = 12;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A59: i = Divide(a,k1,b,k2) by A58,SCMPDS_2:38;
    now
      let c;
      per cases;
      suppose
A60:    DataLoc(s1.b,k2)=c;
        then
A61:    DataLoc(s2.b,k2)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) mod s1.DataLoc(s1.b,k2) by A59
,A60,SCMPDS_2:52
          .= s2.DataLoc(s2.a,k1) mod s1.DataLoc(s1.b,k2) by A6
          .= s2.DataLoc(s2.a,k1) mod s2.DataLoc(s2.b,k2) by A6
          .= Exec(i,s2).c by A59,A61,SCMPDS_2:52;
      end;
      suppose
A62:    DataLoc(s1.b,k2)<>c;
        then
A63:    DataLoc(s2.b,k2)<>c by A5,Th23;
        hereby
          per cases;
          suppose
A64:        DataLoc(s1.a,k1)<>c;
            then
A65:        DataLoc(s2.a,k1)<>c by A5,Th23;
            thus Exec(i, s1).c = s1.c by A59,A62,A64,SCMPDS_2:52
              .=s2.c by A5,Th23
              .=Exec(i,s2).c by A59,A63,A65,SCMPDS_2:52;
          end;
          suppose
A66:        DataLoc(s1.a,k1)=c;
            then
A67:        DataLoc(s2.a,k1)=c by A5,Th23;
            thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) div s1.DataLoc(s1.b,k2)
            by A59,A62,A66,SCMPDS_2:52
              .= s2.DataLoc(s2.a,k1) div s1.DataLoc(s1.b,k2) by A6
              .= s2.DataLoc(s2.a,k1) div s2.DataLoc(s2.b,k2) by A6
              .= Exec(i,s2).c by A59,A63,A67,SCMPDS_2:52;
          end;
        end;
      end;
    end;
    hence thesis by Th23;
  end;
  suppose
A68: Ci = 13;
    hence IC Exec(i,s1) + n = IC Exec(i,s2) by A8;
    consider a,b,k1,k2 such that
A69: i = (a,k1):=(b,k2) by A68,SCMPDS_2:39;
    now
      let c;
      per cases;
      suppose
A70:    DataLoc(s1.a,k1)=c;
        then
A71:    DataLoc(s2.a,k1)=c by A5,Th23;
        thus Exec(i, s1).c = s1.DataLoc(s1.b,k2) by A69,A70,SCMPDS_2:47
          .= s2.DataLoc(s2.b,k2) by A6
          .=Exec(i,s2).c by A69,A71,SCMPDS_2:47;
      end;
      suppose
A72:    DataLoc(s1.a,k1)<>c;
        then
A73:    DataLoc(s2.a,k1)<>c by A5,Th23;
        thus Exec(i,s1).c = s1.c by A69,A72,SCMPDS_2:47
          .=s2.c by A5,Th23
          .=Exec(i,s2).c by A69,A73,SCMPDS_2:47;
      end;
    end;
    hence thesis by Th23;
  end;
end;

theorem
  for P1,P2 being Instruction-Sequence of SCMPDS
  for s1 being 0-started State of SCMPDS
  for J being parahalting shiftable Program of SCMPDS st stop J c= P1
  for n being Element of NAT st Shift(stop J,n) c= P2 &
    IC s2 = n & DataPart s1 = DataPart s2
  for i being Element of NAT holds
   IC Comput(P1,s1,i) + n = IC Comput(P2,s2,i) &
    CurInstr(P1,Comput(P1,s1,i)) =
     CurInstr(P2,Comput(P2,s2,i)) &
    DataPart Comput(P1,s1,i) = DataPart
       Comput(P2,s2,i)
proof
  let P1,P2 be Instruction-Sequence of SCMPDS;
  let s1 be 0-started State of SCMPDS;
  let I be parahalting shiftable Program of SCMPDS;
  set SI=stop I;
  assume
A1: SI c= P1;
  let n be Element of NAT;
  assume that
A2: Shift(SI,n) c= P2 and
A3: IC s2 =  n and
A4: DataPart s1 = DataPart s2;
A5:  0 in dom SI by COMPOS_1:36;
  then
A6: 0 + n in dom Shift(SI,n) by VALUED_1:24;
  defpred P[Nat] means IC Comput(P1,s1,$1) + n = IC Comput(
P2,s2,$1) &
  CurInstr(P1,Comput(P1,s1,$1))
   = CurInstr(P2,Comput(P2,s2,$1)) & DataPart
  Comput(P1,s1,$1) = DataPart Comput(P2,s2,$1);
A7: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A8: P[k];
    reconsider m = IC Comput(P1,s1,k) as Element of NAT;
    set i = CurInstr(P1,Comput(P1,s1,k));
A9: Comput(P1,s1,k+1) =
   Following(P1,Comput(P1,s1,k))
 by EXTPRO_1:3
      .= Exec(CurInstr(P1,Comput(P1,s1,k)),
      Comput(P1,s1,k));
    reconsider l = IC Comput(P1,s1,k+1) as Element of NAT;
A10: IC Comput(P1,s1,k+1) in dom SI by A1,Def9;
    then
A11: l+n in dom Shift(SI,n) by VALUED_1:24;
A12: Comput(P2,s2,k+1) =
   Following(P2,Comput(P2,s2,k))
 by EXTPRO_1:3
      .= Exec(CurInstr(P2,Comput(P2,s2,k)),
      Comput(P2,s2,k));
A13: IC Comput(P1,s1,k)
 in dom SI by A1,Def9;
A14: i = P1.IC Comput(P1,s1,k) by PBOOLE:143
      .= SI.IC Comput(P1,s1,k) by A1,A13,GRFUNC_1:2;
    then
A15: InsCode i <> 1 & InsCode i <> 3 by A13,Def12;
A16: i valid_at m by A13,A14,Def12;
    hence
A17: IC Comput(P1,s1,k+1) + n = IC Comput(P2,s2,k+1)
       by A8,A9,A12,A15,Th83;
    CurInstr(P1,Comput(P1,s1,k+1)) = P1.l by PBOOLE:143
      .= SI.l by A1,A10,GRFUNC_1:2;
    hence CurInstr(P1,Comput(P1,s1,k+1))
     = Shift(SI,n).(IC Comput(P2,s2,k+1)) by A17,A10,VALUED_1:def 12
      .= P2.IC Comput(P2,s2,k+1) by A2,A17,A11,GRFUNC_1:2
      .= CurInstr(P2,Comput(P2,s2,k+1)) by PBOOLE:143;
    thus thesis by A8,A9,A12,A15,A16,Th83;
  end;
A18: P1.IC s1 = P1. 0 by MEMSTR_0:def 8
    .= SI. 0 by A1,A5,GRFUNC_1:2;
  let i be Element of NAT;
A19: DataPart Comput(P1,s1,0) = DataPart s2 by A4,EXTPRO_1:2
    .= DataPart Comput(P2,s2,0) by EXTPRO_1:2;
A20: IC Comput(P1,s1,0)
     = IC s1 by EXTPRO_1:2
    .=  0 by MEMSTR_0:def 8;
A21: Comput(P1,s1,0) = s1 by EXTPRO_1:2;
A22: Comput(P2,s2,0) = s2 by EXTPRO_1:2;
A23:  P2/.IC s2 = P2.IC s2 by PBOOLE:143;
A24:  P1/.IC s1 = P1.IC s1 by PBOOLE:143;
  CurInstr(P1,Comput(P1,s1,0))
     = Shift(SI,n).( 0 + n) by A5,A18,A24,A21,VALUED_1:def 12
    .= CurInstr(P2,Comput(P2,s2,0))
     by A22,A2,A3,A6,A23,GRFUNC_1:2;
  then
A25: P[0] by A3,A20,A19,EXTPRO_1:2;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A25,A7);
  hence thesis;
end;

