:: On the Many Sorted Closure Operator and the Many Sorted Closure
:: System
::  by Artur Korni{\l}owicz
::
:: Received February 7, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies PBOOLE, FUNCT_1, PRALG_1, ZF_REFLE, RELAT_1, FUNCT_4, CAT_1,
      FINSEQ_4, BOOLE, FUNCT_6, MSUALG_3, MATRIX_1, PRE_CIRC, CAT_4, RELAT_2,
      MSAFREE2, BINOP_1, FUNCOP_1, FINSET_1, MSUALG_1, MSSUBFAM, GRCAT_1,
      COHSP_1, MSUALG_2, SETFAM_1, CANTOR_1, CLOSURE1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, STRUCT_0, SETFAM_1, RELAT_1,
      FUNCT_1, FUNCT_2, FUNCOP_1, FINSET_1, FUNCT_4, PBOOLE, MSUALG_1,
      MSUALG_3, PRALG_1, PRE_CIRC, MSSUBFAM;
 constructors SETFAM_1, PRE_CIRC, PZFMISC1, MSSUBFAM, PRALG_1, MSUALG_3;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, RELSET_1, FUNCOP_1, FINSET_1,
      PBOOLE, MSSUBFAM, MSUALG_1;
 requirements SUBSET, BOOLE;
 definitions XBOOLE_0, FUNCT_1, MSSUBFAM, MSUALG_1, MSUALG_3, PBOOLE, PRE_CIRC,
      TARSKI, FUNCOP_1;
 theorems FUNCOP_1, FUNCT_1, FUNCT_2, FUNCT_4, MBOOLEAN, MSSUBFAM, MSUALG_1,
      MSUALG_3, PBOOLE, PZFMISC1, TARSKI, ZFMISC_1, PRALG_1, XBOOLE_0,
      XBOOLE_1, PARTFUN1;
 schemes MSSUBFAM, PBOOLE, XBOOLE_0;

begin  :: Preliminaries

reserve i, x, I for set,
  A, M for ManySortedSet of I,
  f for Function,
  F for ManySortedFunction of I;

scheme MSSUBSET { I() -> set, A() -> non-empty ManySortedSet of I(),
  B() -> ManySortedSet of I(), P[set] } :
  (for X being ManySortedSet of I() holds X in A() iff X in B() & P[X])
  implies A() c= B()
proof
  assume
A1: for X being ManySortedSet of I() holds X in A() iff X in B() & P[X];
  consider K being ManySortedSet of I() such that
A2: K in A() by PBOOLE:146;
  let i such that
A3: i in I();
  let x such that
A4: x in A().i;
  dom (K +* (i .--> x)) = I() by A3,PZFMISC1:1;
  then reconsider X = K +* (i .--> x) as ManySortedSet of I() by PBOOLE:def 3;
A5: dom (i .--> x) = {i} by FUNCOP_1:19;
  i in {i} by TARSKI:def 1;
  then
A6: X.i = (i .--> x).i by A5,FUNCT_4:14
    .= x by FUNCOP_1:87;
  X in A()
  proof
    let s be set such that
A7: s in I();
    per cases;
    suppose s = i;
      hence X.s in A().s by A4,A6;
    end;
    suppose s <> i;
      then not s in dom (i .--> x) by A5,TARSKI:def 1;
      then X.s = K.s by FUNCT_4:12;
      hence X.s in A().s by A2,A7,PBOOLE:def 4;
    end;
  end;
  then X in B() by A1;
  hence x in B().i by A3,A6,PBOOLE:def 4;
end;

theorem Th1:
  for X being non empty set for x, y being set st x c= y holds
  { t where t is Element of X : y c= t } c=
  { z where z is Element of X : x c= z }
proof
  let X be non empty set, x, y be set such that
A1: x c= y;
  let a be set;
  assume a in { t where t is Element of X : y c= t };
  then consider b be Element of X such that
A2: b = a & y c= b;
  x c= a by A1,A2,XBOOLE_1:1;
  hence a in { z where z is Element of X : x c= z } by A2;
end;

theorem
  (ex A st A in M) implies M is non-empty
proof
  given A such that
A1: A in M;
  let i;
  assume i in I;
  hence thesis by A1,PBOOLE:def 4;
end;

definition
  let I, F, A;
  redefine func F..A -> ManySortedSet of I;
  coherence
  proof
    dom (F..A) = I by PBOOLE:def 3;
    hence thesis;
  end;
end;

Lm1: now
  let I;
  let A, B be non-empty ManySortedSet of I;
  let F be ManySortedFunction of A, B;
  let X be Element of A;
  thus F..X is Element of B
  proof
    let i such that
A1: i in I;
A2: dom F = I by PBOOLE:def 3;
    reconsider g = F.i as Function;
A3: g is Function of A.i, B.i by A1,PBOOLE:def 18;
A4: A.i <> {} by A1;
A5: B.i <> {} by A1;
    X.i is Element of A.i by A1,PBOOLE:def 17;
    then g.(X.i) in B.i by A3,A4,A5,FUNCT_2:7;
    hence (F..X).i is Element of B.i by A1,A2,PRALG_1:def 17;
  end;
end;

definition
  let I;
  let A, B be non-empty ManySortedSet of I;
  let F be ManySortedFunction of A, B;
  let X be Element of A;
  redefine func F..X -> Element of B;
  coherence by Lm1;
end;

theorem
  for A, X being ManySortedSet of I for B being non-empty ManySortedSet of I
  for F being ManySortedFunction of A, B st X in A holds F..X in B
proof
  let A, X be ManySortedSet of I;
  let B be non-empty ManySortedSet of I;
  let F be ManySortedFunction of A, B such that
A1: X in A;
  let i be set such that
A2: i in I;
A3: dom F = I by PBOOLE:def 3;
  reconsider g = F.i as Function;
A4: g is Function of A.i, B.i by A2,PBOOLE:def 18;
A5: B.i <> {} by A2;
  X.i in A.i by A1,A2,PBOOLE:def 4;
  then g.(X.i) in B.i by A4,A5,FUNCT_2:7;
  hence (F..X).i in B.i by A2,A3,PRALG_1:def 17;
end;

theorem Th4:
  for F, G being ManySortedFunction of I
  for A being ManySortedSet of I st A in doms G holds F..(G..A) = (F ** G)..A
proof
  let F, G be ManySortedFunction of I;
  let A be ManySortedSet of I such that
A1: A in doms G;
A2: dom F = I by PBOOLE:def 3;
A3: dom G = I by PBOOLE:def 3;
  reconsider FG = F ** G as ManySortedFunction of I by MSSUBFAM:15;
A4: dom FG = I by PBOOLE:def 3;
A5: FG..A is ManySortedSet of I;
  now
    let i;
    assume
A6: i in I;
    reconsider f = F.i as Function;
    reconsider g = G.i as Function;
    reconsider fg = (F**G).i as Function;
    dom g = (doms G).i by A6,MSSUBFAM:14;
    then
A7: A.i in dom g by A1,A6,PBOOLE:def 4;
    (G..A).i = g.(A.i) by A3,A6,PRALG_1:def 17;
    hence (F..(G..A)).i = f.(g.(A.i)) by A2,A6,PRALG_1:def 17
      .= (f*g).(A.i) by A7,FUNCT_1:23
      .= fg.(A.i) by A4,A6,PBOOLE:def 24
      .= ((F ** G)..A).i by A4,A6,PRALG_1:def 17;
  end;
  hence thesis by A5,PBOOLE:3;
end;

theorem
  F is "1-1" implies
  for A, B being ManySortedSet of I st A in doms F & B in doms F &
  F..A = F..B holds A = B
proof
  assume
A1: F is "1-1";
  let A, B be ManySortedSet of I such that
A2: A in doms F & B in doms F and
A3: F..A = F..B;
  now
    let i such that
A4: i in I;
A5: dom F = I by PBOOLE:def 3;
    reconsider f = F.i as Function;
A6: f is one-to-one by A1,A4,MSUALG_3:1;
    dom f = (doms F).i by A4,MSSUBFAM:14;
    then
A7: A.i in dom f & B.i in dom f by A2,A4,PBOOLE:def 4;
    f.(A.i) = (F..A).i by A4,A5,PRALG_1:def 17
      .= f.(B.i) by A3,A4,A5,PRALG_1:def 17;
    hence A.i = B.i by A6,A7,FUNCT_1:def 8;
  end;
  hence thesis by PBOOLE:3;
end;

theorem
  doms F is non-empty &
  (for A, B being ManySortedSet of I st A in doms F & B in doms F &
  F..A = F..B holds A = B) implies F is "1-1"
proof
  assume that
A1: doms F is non-empty and
A2: for A, B being ManySortedSet of I st A in doms F & B in doms F &
  F..A = F..B holds A = B;
  consider K being ManySortedSet of I such that
A3: K in doms F by A1,PBOOLE:146;
  let i be set, f be Function such that
A4: i in dom F and
A5: F.i = f;
  let x1, x2 be set such that
A6: x1 in dom f & x2 in dom f and
A7: f.x1 = f.x2;
A8: dom F = I by PBOOLE:def 3;
  then dom (K +* (i .--> x1)) = I by A4,PZFMISC1:1;
  then reconsider X1 = K +* (i .--> x1) as ManySortedSet of I by PBOOLE:def 3;
A9: dom (i .--> x1) = {i} by FUNCOP_1:19;
  i in {i} by TARSKI:def 1;
  then
A10: X1.i = (i .--> x1).i by A9,FUNCT_4:14
    .= x1 by FUNCOP_1:87;
  dom (K +* (i .--> x2)) = I by A4,A8,PZFMISC1:1;
  then reconsider X2 = K +* (i .--> x2) as ManySortedSet of I by PBOOLE:def 3;
A11: dom (i .--> x2) = {i} by FUNCOP_1:19;
  i in {i} by TARSKI:def 1;
  then
A12: X2.i = (i .--> x2).i by A11,FUNCT_4:14
    .= x2 by FUNCOP_1:87;
A13: X1 in doms F
  proof
    let s be set such that
A14: s in I;
    per cases;
    suppose s = i;
      hence X1.s in (doms F).s by A5,A6,A10,A14,MSSUBFAM:14;
    end;
    suppose s <> i;
      then not s in dom (i .--> x1) by A9,TARSKI:def 1;
      then X1.s = K.s by FUNCT_4:12;
      hence X1.s in (doms F).s by A3,A14,PBOOLE:def 4;
    end;
  end;
A15: X2 in doms F
  proof
    let s be set such that
A16: s in I;
    per cases;
    suppose s = i;
      hence X2.s in (doms F).s by A5,A6,A12,A16,MSSUBFAM:14;
    end;
    suppose s <> i;
      then not s in dom (i .--> x2) by A11,TARSKI:def 1;
      then X2.s = K.s by FUNCT_4:12;
      hence X2.s in (doms F).s by A3,A16,PBOOLE:def 4;
    end;
  end;
  now
    let s be set such that
A17: s in I;
    per cases;
    suppose
A18:  s = i;
      hence (F..X1).s = f.(X2.s) by A4,A5,A7,A10,A12,PRALG_1:def 17
        .= (F..X2).s by A4,A5,A18,PRALG_1:def 17;
    end;
    suppose
A19:  s <> i;
      then
A20:  not s in dom (i .--> x1) by A9,TARSKI:def 1;
      not s in dom (i .--> x2) by A11,A19,TARSKI:def 1;
      then
A21:  X2.s = K.s by FUNCT_4:12;
      reconsider f1 = F.s as Function;
      thus (F..X1).s = f1.(X1.s) by A8,A17,PRALG_1:def 17
        .= f1.(X2.s) by A20,A21,FUNCT_4:12
        .= (F..X2).s by A8,A17,PRALG_1:def 17;
    end;
  end;
  then F..X1 = F..X2 by PBOOLE:3;
  hence x1 = x2 by A2,A10,A12,A13,A15;
end;

theorem Th7:     :: FUNCT_2:18
  for A, B being non-empty ManySortedSet of I

for F, G being ManySortedFunction of A, B st for M st M in A holds F..M = G..M
  holds F = G
proof
  let A, B be non-empty ManySortedSet of I,
  F, G be ManySortedFunction of A, B such that
A1: for M st M in A holds F..M = G..M;
  now
    let i;
    assume
A2: i in I;
    then reconsider f = F.i as Function of A.i, B.i by PBOOLE:def 18;
    reconsider g = G.i as Function of A.i, B.i by A2,PBOOLE:def 18;
    now
      let x such that
A3:   x in A.i;
      consider K being ManySortedSet of I such that
A4:   K in A by PBOOLE:146;
      dom (K +* (i .--> x)) = I by A2,PZFMISC1:1;

then reconsider X = K +* (i .--> x) as ManySortedSet of I by PBOOLE:def 3;
A5:   dom (i .--> x) = {i} by FUNCOP_1:19;
      i in {i} by TARSKI:def 1;
      then
A6:   X.i = (i .--> x).i by A5,FUNCT_4:14
        .= x by FUNCOP_1:87;
      X in A
      proof
        let s be set such that
A7:     s in I;
        per cases;
        suppose s = i;
          hence X.s in A.s by A3,A6;
        end;
        suppose s <> i;
          then not s in dom (i .--> x) by A5,TARSKI:def 1;
          then X.s = K.s by FUNCT_4:12;
          hence X.s in A.s by A4,A7,PBOOLE:def 4;
        end;
      end;
      then
A8:   F..X = G..X by A1;
A9:   dom F = I by PBOOLE:def 3;
A10:  dom G = I by PBOOLE:def 3;
      thus f.x = (F..X).i by A2,A6,A9,PRALG_1:def 17
        .= g.x by A2,A6,A8,A10,PRALG_1:def 17;
    end;
    hence F.i = G.i by FUNCT_2:18;
  end;
  hence thesis by PBOOLE:3;
end;

registration
  let I, M;
  cluster empty-yielding locally-finite Element of bool M;
  existence
  proof
    [0]I c= M by MBOOLEAN:5;
    then [0]I in bool M by MBOOLEAN:1;
    then reconsider a = [0]I as Element of bool M by MSSUBFAM:11;
    take a;
    thus thesis;
  end;
end;

begin  :: Properties of Many Sorted Closure Operators

definition
  let I, M;
  mode MSSetOp of M is ManySortedFunction of bool M, bool M;
end;

definition
  let I, M;
  let O be MSSetOp of M;
  let X be Element of bool M;
  redefine func O..X -> Element of bool M;
  coherence by Lm1;
end;

definition
  let I, M;
  let IT be MSSetOp of M;
  canceled;
  attr IT is reflexive means
  :Def2:
  for X being Element of bool M holds X c= IT..X;
  attr IT is monotonic means
  :Def3:
  for X, Y being Element of bool M st X c= Y holds IT..X c= IT..Y;
  attr IT is idempotent means
  :Def4:
  for X being Element of bool M holds IT..X = IT..(IT..X);
  attr IT is topological means
  :Def5:
  for X, Y being Element of bool M holds IT..(X \/ Y) = (IT..X) \/ (IT..Y);
end;

theorem Th8:
  for M being non-empty ManySortedSet of I
  for X being Element of M holds X = (id M)..X
proof
  let M be non-empty ManySortedSet of I;
  let X be Element of M;
  set F = id M;
A1: dom F = I by PBOOLE:def 3;
  now
    let i;
    assume
A2: i in I;
    then
A3: M.i <> {};
A4: X.i is Element of M.i by A2,PBOOLE:def 17;
    reconsider g = F.i as Function;
    F.i = id (M.i) by A2,MSUALG_3:def 1;
    then g.(X.i) = X.i by A3,A4,FUNCT_1:35;
    hence X.i = (F..X).i by A1,A2,PRALG_1:def 17;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th9:
  for M being non-empty ManySortedSet of I
  for X, Y being Element of M st X c= Y holds (id M)..X c= (id M)..Y
proof
  let M be non-empty ManySortedSet of I;
  let X, Y be Element of M such that
A1: X c= Y;
  (id M)..X = X & (id M)..Y = Y by Th8;
  hence thesis by A1;
end;

theorem Th10:
  for M being non-empty ManySortedSet of I
  for X, Y being Element of M st X \/ Y is Element of M
  holds (id M)..(X \/ Y) = ((id M)..X) \/ ((id M)..Y)
proof
  let M be non-empty ManySortedSet of I;
  let X, Y be Element of M;
  set F = id M;
  assume X \/ Y is Element of M;
  hence F..(X \/ Y) = X \/ Y by Th8
    .= (F..X) \/ Y by Th8
    .= (F..X) \/ (F..Y) by Th8;
end;

theorem
  for X being Element of bool M
  for i, x being set st i in I & x in ((id (bool M))..X).i
  ex Y being locally-finite Element of bool M st
  Y c= X & x in ((id (bool M))..Y).i
proof
  let X be Element of bool M, i, x be set such that
A1: i in I and
A2: x in ((id (bool M))..X).i;
A3: x in X.i by A2,Th8;
  X in bool M by MSSUBFAM:12;
  then X c= M by MBOOLEAN:19;
  then
A4: X.i c= M.i by A1,PBOOLE:def 5;
A5: dom (i .--> {x}) = {i} by FUNCOP_1:19;
  set Y = (I --> {}) +* (i.-->{x});
  dom Y = I by A1,PZFMISC1:1;
  then reconsider Y as ManySortedSet of I by PBOOLE:def 3;
  i in {i} by TARSKI:def 1;
  then
A6: Y.i = (i .--> {x}).i by A5,FUNCT_4:14
    .= {x} by FUNCOP_1:87;
  Y is Element of bool M
  proof
    let j be set such that
A7: j in I;
    now per cases;
      case
A8:     j = i;
        then {x} c= M.j by A3,A4,ZFMISC_1:37;
        hence Y.j is Element of (bool M).j by A6,A7,A8,MBOOLEAN:def 1;
      end;
      case j <> i;
        then not j in dom (i .--> {x}) by A5,TARSKI:def 1;
        then Y.j = (I --> {}).j by FUNCT_4:12;
        then Y.j = {} by A7,FUNCOP_1:13;
        then Y.j c= M.j by XBOOLE_1:2;
        hence Y.j is Element of (bool M).j by A7,MBOOLEAN:def 1;
      end;
    end;
    hence Y.j is Element of (bool M).j;
  end;
  then reconsider Y as Element of bool M;
  Y is locally-finite
  proof
    let j be set such that
A9: j in I;
    now per cases;
      case j = i;
        hence Y.j is finite by A6;
      end;
      case j <> i;
        then not j in dom (i .--> {x}) by A5,TARSKI:def 1;
        then Y.j = (I --> {}).j by FUNCT_4:12;
        hence Y.j is finite by A9,FUNCOP_1:13;
      end;
    end;
    hence Y.j is finite;
  end;
  then reconsider Y as locally-finite Element of bool M;
  take Y;
  thus Y c= X
  proof
    let j be set such that
A10: j in I;
    now per cases;
      case j = i;
        hence Y.j c= X.j by A3,A6,ZFMISC_1:37;
      end;
      case j <> i;
        then not j in dom (i .--> {x}) by A5,TARSKI:def 1;
        then Y.j = (I --> {}).j by FUNCT_4:12;
        then Y.j = {} by A10,FUNCOP_1:13;
        hence Y.j c= X.j by XBOOLE_1:2;
      end;
    end;
    hence Y.j c= X.j;
  end;
  x in Y.i by A6,TARSKI:def 1;
  hence x in ((id (bool M))..Y).i by Th8;
end;

registration
  let I, M;
  cluster reflexive monotonic idempotent topological MSSetOp of M;
  existence
  proof
    reconsider F = id (bool M) as MSSetOp of M;
    take F;
    thus F is reflexive
    proof
      let X be Element of bool M;
      thus thesis by Th8;
    end;
    thus F is monotonic
    proof
      let X, Y be Element of bool M;
      assume X c= Y;
      hence thesis by Th9;
    end;
    thus F is idempotent
    proof
      let X be Element of bool M;
      thus thesis by Th8;
    end;
    thus F is topological
    proof
      let X, Y be Element of bool M;
      X in bool M & Y in bool M by MSSUBFAM:12;
      then X c= M & Y c= M by MBOOLEAN:1;
      then X \/ Y c= M by PBOOLE:18;
      then X \/ Y in bool M by MBOOLEAN:1;
      then X \/ Y is Element of bool M by MSSUBFAM:11;
      hence thesis by Th10;
    end;
  end;
end;

theorem
  id (bool A) is reflexive MSSetOp of A
proof
  reconsider a = id (bool A) as MSSetOp of A;
  a is reflexive
  proof
    let b be Element of bool A;
    thus thesis by Th8;
  end;
  hence thesis;
end;

theorem
  id (bool A) is monotonic MSSetOp of A
proof
  reconsider a = id (bool A) as MSSetOp of A;
  a is monotonic
  proof
    let X, Y be Element of bool A;
    assume X c= Y;
    hence thesis by Th9;
  end;
  hence thesis;
end;

theorem
  id (bool A) is idempotent MSSetOp of A
proof
  reconsider a = id (bool A) as MSSetOp of A;
  a is idempotent
  proof
    let X be Element of bool A;
    thus thesis by Th8;
  end;
  hence thesis;
end;

theorem
  id (bool A) is topological MSSetOp of A
proof
  reconsider a = id (bool A) as MSSetOp of A;
  a is topological
  proof
    let X, Y be Element of bool A;
    X in bool A & Y in bool A by MSSUBFAM:12;
    then X c= A & Y c= A by MBOOLEAN:1;
    then X \/ Y c= A by PBOOLE:18;
    then X \/ Y in bool A by MBOOLEAN:1;
    then X \/ Y is Element of bool A by MSSUBFAM:11;
    hence thesis by Th10;
  end;
  hence thesis;
end;

reserve P, R for MSSetOp of M,
  E, T for Element of bool M;

theorem
  E = M & P is reflexive implies E = P..E
proof
  assume
A1: E = M;
  assume P is reflexive;
  hence E c= P..E by Def2;
  P..E in bool E by A1,MSSUBFAM:12;
  hence P..E c= E by MBOOLEAN:19;
end;

theorem
  (P is reflexive & for X being Element of bool M holds P..X c= X)
  implies P is idempotent
proof
  assume that
A1: P is reflexive and
A2: for X being Element of bool M holds P..X c= X;
  let X be Element of bool M;
  thus P..X c= P..(P..X) by A1,Def2;
  thus P..(P..X) c= P..X by A2;
end;

theorem
  P is monotonic implies P..(E /\ T) c= P..E /\ P..T
proof
  assume
A1: P is monotonic;
  E in bool M by MSSUBFAM:12;
  then E c= M by MBOOLEAN:1;
  then E /\ T c= M by MBOOLEAN:15;
  then E /\ T in bool M by MBOOLEAN:1;
  then
A2: E /\ T is Element of bool M by MSSUBFAM:11;
  E /\ T c= E by PBOOLE:17;
  then
A3: P..(E /\ T) c= P..E by A1,A2,Def3;
  E /\ T c= T by PBOOLE:17;
  then P..(E /\ T) c= P..T by A1,A2,Def3;
  hence P..(E /\ T) c= P..E /\ P..T by A3,PBOOLE:19;
end;

registration
  let I, M;
  cluster topological -> monotonic MSSetOp of M;
  coherence
  proof
    let P be MSSetOp of M such that
A1: P is topological;
    let X, Y be Element of bool M such that
A2: X c= Y;
    P..X \/ P..Y = P..(X \/ Y) by A1,Def5
      .= P..Y by A2,PBOOLE:24;
    hence P..X c= P..Y by PBOOLE:28;
  end;
end;

theorem
  P is topological implies P..E \ P..T c= P..(E \ T)
proof
  E in bool M by MSSUBFAM:12;
  then E c= M by MBOOLEAN:1;
  then E\T c= M by MBOOLEAN:16;
  then E\T in bool M by MBOOLEAN:1;
  then
A1: E\T is Element of bool M by MSSUBFAM:11;
  assume
A2: P is topological;
  then P..E \/ P..T = P..(E \/ T) by Def5
    .= P..((E\T) \/ T) by PBOOLE:73
    .= (P..(E\T)) \/ (P..T) by A1,A2,Def5;
  then P..E c= P..(E\T) \/ P..T by PBOOLE:16;
  then P..E \ P..T c= (P..(E\T) \/ P..T) \ P..T by PBOOLE:59;
  then
A3: P..E \ P..T c= P..(E\T) \ P..T by PBOOLE:81;
  P..(E\T) \ P..T c= P..(E\T) by PBOOLE:62;
  hence thesis by A3,PBOOLE:15;
end;

definition
  let I, M, R, P;
  redefine func P ** R -> MSSetOp of M;
  coherence
  proof
    P ** R is ManySortedFunction of bool M, bool M;
    hence thesis;
  end;
end;

theorem
  P is reflexive & R is reflexive implies P ** R is reflexive
proof
  assume that
A1: P is reflexive and
A2: R is reflexive;
  let X be Element of bool M;
A3: doms R = bool M by MSSUBFAM:17;
A4: X c= R..X by A2,Def2;
  R..X c= P..(R..X) by A1,Def2;
  then X c= P..(R..X) by A4,PBOOLE:15;
  hence X c= (P**R)..X by A3,Th4,MSSUBFAM:12;
end;

theorem
  P is monotonic & R is monotonic implies P ** R is monotonic
proof
  assume that
A1: P is monotonic and
A2: R is monotonic;
  let X, Y be Element of bool M such that
A3: X c= Y;
A4: doms R = bool M by MSSUBFAM:17;
  R..X c= R..Y by A2,A3,Def3;
  then P..(R..X) c= P..(R..Y) by A1,Def3;
  then P..(R..X) c= (P**R)..Y by A4,Th4,MSSUBFAM:12;
  hence (P**R)..X c= (P**R)..Y by A4,Th4,MSSUBFAM:12;
end;

theorem
  P is idempotent & R is idempotent & P**R = R**P implies P ** R is idempotent
proof
  assume that
A1: P is idempotent and
A2: R is idempotent and
A3: P**R = R**P;
  let X be Element of bool M;
A4: doms R = bool M by MSSUBFAM:17;
A5: doms P = bool M by MSSUBFAM:17;
  thus (P**R)..X = P..(R..X) by A4,Th4,MSSUBFAM:12
    .= P..(R..(R..X)) by A2,Def4
    .= P..(P..(R..(R..X))) by A1,Def4
    .= P..((R**P)..(R..X)) by A3,A4,Th4,MSSUBFAM:12
    .= P..(R..(P..(R..X))) by A5,Th4,MSSUBFAM:12
    .= P..(R..((P**R)..X)) by A4,Th4,MSSUBFAM:12
    .= (P**R)..((P**R)..X) by A4,Th4,MSSUBFAM:12;
end;

theorem
  P is topological & R is topological implies P ** R is topological
proof
  assume that
A1: P is topological and
A2: R is topological;
  let X, Y be Element of bool M;
A3: doms R = bool M by MSSUBFAM:17;
  X in bool M & Y in bool M by MSSUBFAM:12;
  then X c= M & Y c= M by MBOOLEAN:1;
  then X \/ Y c= M by PBOOLE:18;
  then X \/ Y in doms R by A3,MBOOLEAN:1;
  hence (P**R)..(X \/ Y) = P..(R..(X \/ Y)) by Th4
    .= P..(R..X \/ R..Y) by A2,Def5
    .= P..(R..X) \/ P..(R..Y) by A1,Def5
    .= (P**R)..X \/ P..(R..Y) by A3,Th4,MSSUBFAM:12
    .= (P**R)..X \/ (P**R)..Y by A3,Th4,MSSUBFAM:12;
end;

Lm2: now
  let I, M, i;
  let a be ManySortedSet of I, b be Element of bool (M.i) such that i in I and
A1: a = [0]I +* (i .--> b);
  [0]I c= M by MBOOLEAN:5;
  then
A2: [0]I in bool M by MBOOLEAN:1;
A3: dom (i .--> b) = {i} by FUNCOP_1:19;
  thus a in bool M
  proof
    let j be set such that
A4: j in I;
    i in {i} by TARSKI:def 1;
    then
A5: a.i = (i .--> b).i by A1,A3,FUNCT_4:14
      .= b by FUNCOP_1:87;
    now per cases;
      case
A6:     j = i;
        then b in bool (M.j);
        hence a.j in (bool M).j by A4,A5,A6,MBOOLEAN:def 1;
      end;
      case j <> i;
        then not j in dom (i .--> b) by A3,TARSKI:def 1;
        then a.j = [0]I.j by A1,FUNCT_4:12;
        hence a.j in (bool M).j by A2,A4,PBOOLE:def 4;
      end;
    end;
    hence a.j in (bool M).j;
  end;
end;

theorem Th24:
  P is reflexive & i in I & f = P.i implies
  for x being Element of bool (M.i) holds x c= f.x
proof
  assume that
A1: P is reflexive and
A2: i in I and
A3: f = P.i;
  let x be Element of bool (M.i);
  dom ([0]I +* (i .--> x)) = I by A2,PZFMISC1:1;
  then reconsider X = [0]I +* (i .--> x) as ManySortedSet of I by PBOOLE:def 3;
A4: dom (i .--> x) = {i} by FUNCOP_1:19;
  i in {i} by TARSKI:def 1;
  then
A5: X.i = (i .--> x).i by A4,FUNCT_4:14
    .= x by FUNCOP_1:87;
A6: X is Element of bool M by A2,Lm2,MSSUBFAM:11;
A7: i in dom P by A2,PBOOLE:def 3;
  X c= P..X by A1,A6,Def2;
  then X.i c= (P..X).i by A2,PBOOLE:def 5;
  hence x c= f.x by A3,A5,A7,PRALG_1:def 17;
end;

theorem Th25:
  P is monotonic & i in I & f = P.i implies
  for x, y being Element of bool (M.i) st x c= y holds f.x c= f.y
proof
  assume that
A1: P is monotonic and
A2: i in I and
A3: f = P.i;
  let x, y be Element of bool (M.i) such that
A4: x c= y;
  dom ([0]I +* (i .--> x)) = I by A2,PZFMISC1:1;
  then reconsider X = [0]I +* (i .--> x) as ManySortedSet of I by PBOOLE:def 3;
  dom ([0]I +* (i .--> y)) = I by A2,PZFMISC1:1;
  then reconsider Y = [0]I +* (i .--> y) as ManySortedSet of I by PBOOLE:def 3;
A5: dom (i .--> x) = {i} by FUNCOP_1:19;
A6: i in {i} by TARSKI:def 1;
  then
A7: X.i = (i .--> x).i by A5,FUNCT_4:14
    .= x by FUNCOP_1:87;
A8: dom (i .--> y) = {i} by FUNCOP_1:19;
  then
A9: Y.i = (i .--> y).i by A6,FUNCT_4:14
    .= y by FUNCOP_1:87;
A10: X is Element of bool M & Y is Element of bool M by A2,Lm2,MSSUBFAM:11;
A11: i in dom P by A2,PBOOLE:def 3;
  X c= Y
  proof
    let s be set such that s in I;
    per cases;
    suppose s = i;
      hence X.s c= Y.s by A4,A7,A9;
    end;
    suppose
A12:  s <> i;
      then not s in dom (i .--> x) by A5,TARSKI:def 1;
      then
A13:  X.s = [0]I.s by FUNCT_4:12;
      not s in dom (i .--> y) by A8,A12,TARSKI:def 1;
      hence X.s c= Y.s by A13,FUNCT_4:12;
    end;
  end;
  then P..X c= P..Y by A1,A10,Def3;
  then (P..X).i c= (P..Y).i by A2,PBOOLE:def 5;
  then f.(X.i) c= (P..Y).i by A3,A11,PRALG_1:def 17;
  hence f.x c= f.y by A3,A7,A9,A11,PRALG_1:def 17;
end;

theorem Th26:
  P is idempotent & i in I & f = P.i implies
  for x being Element of bool (M.i) holds f.x = f.(f.x)
proof
  assume that
A1: P is idempotent and
A2: i in I and
A3: f = P.i;
  let x be Element of bool (M.i);
  dom ([0]I +* (i .--> x)) = I by A2,PZFMISC1:1;
  then reconsider X = [0]I +* (i .--> x) as ManySortedSet of I by PBOOLE:def 3;
A4: dom (i .--> x) = {i} by FUNCOP_1:19;
  i in {i} by TARSKI:def 1;
  then
A5: X.i = (i .--> x).i by A4,FUNCT_4:14
    .= x by FUNCOP_1:87;
A6: X is Element of bool M by A2,Lm2,MSSUBFAM:11;
A7: i in dom P by A2,PBOOLE:def 3;
  hence f.x = (P..X).i by A3,A5,PRALG_1:def 17
    .= (P..(P..X)).i by A1,A6,Def4
    .= f.((P..X).i) by A3,A7,PRALG_1:def 17
    .= f.(f.x) by A3,A5,A7,PRALG_1:def 17;
end;

theorem
  P is topological & i in I & f = P.i implies
  for x, y being Element of bool (M.i) holds f.(x \/ y) = (f.x) \/ (f.y)
proof
  assume that
A1: P is topological and
A2: i in I and
A3: f = P.i;
  let x, y be Element of bool (M.i);
  dom ([0]I +* (i .--> x)) = I by A2,PZFMISC1:1;
  then reconsider X = [0]I +* (i .--> x) as ManySortedSet of I by PBOOLE:def 3;
  dom ([0]I +* (i .--> y)) = I by A2,PZFMISC1:1;
  then reconsider Y = [0]I +* (i .--> y) as ManySortedSet of I by PBOOLE:def 3;
A4: dom (i .--> x) = {i} by FUNCOP_1:19;
A5: i in {i} by TARSKI:def 1;
  then
A6: X.i = (i .--> x).i by A4,FUNCT_4:14
    .= x by FUNCOP_1:87;
  dom (i .--> y) = {i} by FUNCOP_1:19;
  then
A7: Y.i = (i .--> y).i by A5,FUNCT_4:14
    .= y by FUNCOP_1:87;
A8: X is Element of bool M & Y is Element of bool M by A2,Lm2,MSSUBFAM:11;
A9: i in dom P by A2,PBOOLE:def 3;
  thus f.(x \/ y) = f.((X \/ Y).i) by A2,A6,A7,PBOOLE:def 7
    .= (P..(X \/ Y)).i by A3,A9,PRALG_1:def 17
    .= ((P..X) \/ (P..Y)).i by A1,A8,Def5
    .= (P..X).i \/ (P..Y).i by A2,PBOOLE:def 7
    .= f.(X.i) \/ (P..Y).i by A3,A9,PRALG_1:def 17
    .= (f.x) \/ (f.y) by A3,A6,A7,A9,PRALG_1:def 17;
end;

begin  :: On the Many Sorted Closure Operator

::  and the Many Sorted Closure System

reserve S for 1-sorted;

definition
  let S;
  struct(many-sorted over S) MSClosureStr over S (#
    Sorts -> ManySortedSet of the carrier of S,
    Family -> MSSubsetFamily of the Sorts #);
end;

reserve MS for many-sorted over S;

definition
  let S;
  let IT be MSClosureStr over S;
  attr IT is additive means
  :Def6:
  the Family of IT is additive;
  attr IT is absolutely-additive means
  :Def7:
  the Family of IT is absolutely-additive;
  attr IT is multiplicative means
  :Def8:
  the Family of IT is multiplicative;
  attr IT is absolutely-multiplicative means
  :Def9:
  the Family of IT is absolutely-multiplicative;
  attr IT is properly-upper-bound means
  :Def10:
  the Family of IT is properly-upper-bound;
  attr IT is properly-lower-bound means
  :Def11:
  the Family of IT is properly-lower-bound;
end;

definition
  let S, MS;
  func MSFull MS -> MSClosureStr over S equals
  MSClosureStr (#the Sorts of MS, bool the Sorts of MS#);
  correctness;
end;

registration
  let S, MS;
  cluster MSFull MS -> strict additive absolutely-additive
    multiplicative absolutely-multiplicative
    properly-upper-bound properly-lower-bound;
  coherence
  proof
    thus MSFull MS is strict;
    thus the Family of MSFull MS is additive absolutely-additive
    multiplicative absolutely-multiplicative properly-upper-bound
    properly-lower-bound;
  end;
end;

registration
  let S;
  let MS be non-empty many-sorted over S;
  cluster MSFull MS -> non-empty;
  coherence by MSUALG_1:def 8;
end;

registration
  let S;
  cluster strict non-empty additive absolutely-additive
    multiplicative absolutely-multiplicative
    properly-upper-bound properly-lower-bound MSClosureStr over S;
  existence
  proof
    consider a being non-empty many-sorted over S;
    take MSFull a;
    thus thesis;
  end;
end;

registration
  let S;
  let CS be additive MSClosureStr over S;
  cluster the Family of CS -> additive;
  coherence by Def6;
end;

registration
  let S;
  let CS be absolutely-additive MSClosureStr over S;
  cluster the Family of CS -> absolutely-additive;
  coherence by Def7;
end;

registration
  let S;
  let CS be multiplicative MSClosureStr over S;
  cluster the Family of CS -> multiplicative;
  coherence by Def8;
end;

registration
  let S;
  let CS be absolutely-multiplicative MSClosureStr over S;
  cluster the Family of CS -> absolutely-multiplicative;
  coherence by Def9;
end;

registration
  let S;
  let CS be properly-upper-bound MSClosureStr over S;
  cluster the Family of CS -> properly-upper-bound;
  coherence by Def10;
end;

registration
  let S;
  let CS be properly-lower-bound MSClosureStr over S;
  cluster the Family of CS -> properly-lower-bound;
  coherence by Def11;
end;

registration
  let S;
  let M be non-empty ManySortedSet of the carrier of S;
  let F be MSSubsetFamily of M;
  cluster MSClosureStr (#M, F#) -> non-empty;
  coherence
  proof
    thus the Sorts of MSClosureStr (#M, F#) is non-empty;
  end;
end;

registration
  let S, MS;
  let F be additive MSSubsetFamily of the Sorts of MS;
  cluster MSClosureStr (#the Sorts of MS, F#) -> additive;
  coherence by Def6;
end;

registration
  let S, MS;
  let F be absolutely-additive MSSubsetFamily of the Sorts of MS;
  cluster MSClosureStr (#the Sorts of MS, F#) -> absolutely-additive;
  coherence by Def7;
end;

registration
  let S, MS;
  let F be multiplicative MSSubsetFamily of the Sorts of MS;
  cluster MSClosureStr (#the Sorts of MS, F#) -> multiplicative;
  coherence by Def8;
end;

registration
  let S, MS;
  let F be absolutely-multiplicative MSSubsetFamily of the Sorts of MS;
  cluster MSClosureStr (#the Sorts of MS, F#) -> absolutely-multiplicative;
  coherence by Def9;
end;

registration
  let S, MS;
  let F be properly-upper-bound MSSubsetFamily of the Sorts of MS;
  cluster MSClosureStr (#the Sorts of MS, F#) -> properly-upper-bound;
  coherence by Def10;
end;

registration
  let S, MS;
  let F be properly-lower-bound MSSubsetFamily of the Sorts of MS;
  cluster MSClosureStr (#the Sorts of MS, F#) -> properly-lower-bound;
  coherence by Def11;
end;

registration
  let S;
  cluster absolutely-additive -> additive MSClosureStr over S;
  coherence
  proof
    let CS be MSClosureStr over S;
    assume CS is absolutely-additive;
    then
A1: the Family of CS is absolutely-additive;
    thus the Family of CS is additive by A1;
  end;
end;

registration
  let S;
  cluster absolutely-multiplicative -> multiplicative MSClosureStr over S;
  coherence
  proof
    let CS be MSClosureStr over S;
    assume CS is absolutely-multiplicative;
    then
A1: the Family of CS is absolutely-multiplicative;
    thus the Family of CS is multiplicative by A1;
  end;
end;

registration
  let S;

cluster absolutely-multiplicative -> properly-upper-bound MSClosureStr over S;
  coherence
  proof
    let CS be MSClosureStr over S;
    assume CS is absolutely-multiplicative;
    then
A1: the Family of CS is absolutely-multiplicative;
    thus the Family of CS is properly-upper-bound by A1;
  end;
end;

registration
  let S;
  cluster absolutely-additive -> properly-lower-bound MSClosureStr over S;
  coherence
  proof
    let CS be MSClosureStr over S;
    assume CS is absolutely-additive;
    then
A1: the Family of CS is absolutely-additive;
    thus the Family of CS is properly-lower-bound by A1;
  end;
end;

definition
  let S;
  mode MSClosureSystem of S is absolutely-multiplicative MSClosureStr over S;
end;

definition
  let I, M;
  mode MSClosureOperator of M is reflexive monotonic idempotent MSSetOp of M;
end;

definition
  let I, M;
  let F be ManySortedFunction of M, M;
  func MSFixPoints F -> ManySortedSubset of M means
  :Def13:
  for i st i in I holds
  x in it.i iff ex f being Function st f = F.i & x in dom f & f.x = x;
  existence
  proof
    defpred P[set,set] means for x holds x in $2 iff x in M.$1 &
    ex f being Function st f = F.$1 & x in dom f & f.x = x;
A1: now
      let i such that i in I;
      defpred R[set] means ex f being Function st f = F.i &
      $1 in dom f & f.$1 = $1;
      consider j being set such that
A2:   for x holds x in j iff x in M.i & R[ x ] from XBOOLE_0:sch 1;
      take j;
      thus P[i,j] by A2;
    end;
    consider A being ManySortedSet of I such that
A3: for i st i in I holds P[i,A.i] from PBOOLE:sch 3(A1);
    A is ManySortedSubset of M
    proof
      let i such that
A4:   i in I;
      let x;
      assume x in A.i;
      hence x in M.i by A3,A4;
    end;
    then reconsider A as ManySortedSubset of M;
    take A;
    thus for i st i in I holds
    x in A.i iff ex f being Function st f = F.i & x in dom f & f.x = x
    proof
      let i;
      assume
A5:   i in I;
      hence x in A.i implies ex f being Function st f = F.i & x in dom f & f.x
      = x by A3;
      given f being Function such that
A6:   f = F.i & x in dom f & f.x = x;
      doms F = M by MSSUBFAM:17;
      then dom f = M.i by A5,A6,MSSUBFAM:14;
      hence x in A.i by A3,A5,A6;
    end;
  end;
  uniqueness
  proof
    let A, B be ManySortedSubset of M such that
A7: for i st i in I holds
    x in A.i iff ex f being Function st f = F.i & x in dom f & f.x = x and
A8: for i st i in I holds
    x in B.i iff ex f being Function st f = F.i & x in dom f & f.x = x;
    now
      let i such that
A9:   i in I;
      thus A.i = B.i
      proof
        thus A.i c= B.i
        proof
          let x;
          assume x in A.i;
          then ex f being Function st f = F.i & x in dom f & f.x = x by A7,A9;
          hence x in B.i by A8,A9;
        end;
        let x;
        assume x in B.i;
        then ex f being Function st f = F.i & x in dom f & f.x = x by A8,A9;
        hence x in A.i by A7,A9;
      end;
    end;
    hence A = B by PBOOLE:3;
  end;
end;

registration
  let I;
  let M be empty-yielding ManySortedSet of I;
  let F be ManySortedFunction of M, M;
  cluster MSFixPoints F -> empty-yielding;
  coherence
  proof
    let i such that
A1: i in I;
    assume (MSFixPoints F).i is non empty;
    then consider x being set such that
A2: x in (MSFixPoints F).i by XBOOLE_0:def 1;
    consider f being Function such that
A3: f = F.i & x in dom f & f.x = x by A1,A2,Def13;
    M.i = {} by A1,PBOOLE:def 15;
    then f is Function of {}, {} by A1,A3,PBOOLE:def 18;
    hence contradiction by A3,PARTFUN1:54;
  end;
end;

theorem Th28:
  for F being ManySortedFunction of M, M holds
  A in M & F..A = A iff A in MSFixPoints F
proof
  let F be ManySortedFunction of M, M;
  thus A in M & F..A = A implies A in MSFixPoints F
  proof
    assume that
A1: A in M and
A2: F..A = A;
    let i;
    assume
A3: i in I;
    then reconsider f = F.i as Function of M.i, M.i by PBOOLE:def 18;
    M = doms F by MSSUBFAM:17;
    then M.i = dom f by A3,MSSUBFAM:14;
    then
A4: A.i in dom f by A1,A3,PBOOLE:def 4;
    i in dom F by A3,PBOOLE:def 3;
    then f.(A.i) = A.i by A2,PRALG_1:def 17;
    hence A.i in (MSFixPoints F).i by A3,A4,Def13;
  end;
  assume
A5: A in MSFixPoints F;
  thus A in M
  proof
    let i;
    assume
A6: i in I;
    then A.i in (MSFixPoints F).i by A5,PBOOLE:def 4;
    then consider f being Function such that
A7: f = F.i & A.i in dom f & f.(A.i) = A.i by A6,Def13;
    M = doms F by MSSUBFAM:17;
    hence A.i in M.i by A6,A7,MSSUBFAM:14;
  end;
  now
    let i;
    assume
A8: i in I;
    then A.i in (MSFixPoints F).i by A5,PBOOLE:def 4;
    then consider f being Function such that
A9: f = F.i & A.i in dom f & f.(A.i) = A.i by A8,Def13;
    i in dom F by A8,PBOOLE:def 3;
    hence (F..A).i = A.i by A9,PRALG_1:def 17;
  end;
  hence thesis by PBOOLE:3;
end;

theorem
  MSFixPoints id A = A
proof
  now
    let i such that
A1: i in I;
    thus (MSFixPoints id A).i = A.i
    proof
      thus (MSFixPoints id A).i c= A.i
      proof
        let x be set;
        assume x in (MSFixPoints id A).i;
        then consider f being Function such that
A2:     f = (id A).i & x in dom f & f.x = x by A1,Def13;
        f is Function of A.i, A.i by A1,A2,PBOOLE:def 18;
        hence x in A.i by A2,FUNCT_2:67;
      end;
      let x be set such that
A3:   x in A.i;
      reconsider f = (id A).i as Function of A.i, A.i by A1,PBOOLE:def 18;
A4:   f = id (A.i) by A1,MSUALG_3:def 1;
A5:   x in dom f by A3,FUNCT_2:67;
      f.x = x by A3,A4,FUNCT_1:35;
      hence thesis by A1,A5,Def13;
    end;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th30:
  for A being ManySortedSet of the carrier of S
  for J being reflexive monotonic MSSetOp of A
  for D being MSSubsetFamily of A st D = MSFixPoints J holds
  MSClosureStr (#A, D#) is MSClosureSystem of S
proof
  let A be ManySortedSet of the carrier of S,
  J be reflexive monotonic MSSetOp of A, D be MSSubsetFamily of A such that
A1: D = MSFixPoints J;
  reconsider CS = MSClosureStr (#A, D#) as MSClosureStr over S;
  CS is absolutely-multiplicative
  proof
    D is absolutely-multiplicative
    proof
      let F be MSSubsetFamily of A such that
A2:   F c= D;
      meet F c= A by PBOOLE:def 23;
      then
A3:   meet F in bool A by MBOOLEAN:19;
      J..(meet F) = meet F
      proof
        thus J..(meet F) c= meet F
        proof
          let i;
          assume
A4:       i in the carrier of S;
          then reconsider j = J.i as Function of (bool A).i, (bool A).i
          by PBOOLE:def 18;
          consider Q being Subset-Family of A.i such that
A5:       Q = F.i & (meet F).i = Intersect Q by A4,MSSUBFAM:def 2;
A6:       i in dom J by A4,PBOOLE:def 3;
          (bool A).i = bool (A.i) by A4,MBOOLEAN:def 1;
          then
A7:       j.(Intersect Q) in bool (A.i) by FUNCT_2:7;
          now
            let x such that
A8:         x in Q;
            Q c= D.i by A2,A4,A5,PBOOLE:def 5;
            then consider jj being Function such that
A9:         jj = J.i & x in dom jj & jj.x = x by A1,A4,A8,Def13;
            thus j.(Intersect Q) c= x by A4,A8,A9,Th25,MSSUBFAM:2;
          end;
          then j.(Intersect Q) c= Intersect Q by A7,MSSUBFAM:4;
          hence (J..(meet F)).i c= (meet F).i by A5,A6,PRALG_1:def 17;
        end;
        meet F is Element of bool A by A3,MSSUBFAM:11;
        hence meet F c= J..(meet F) by Def2;
      end;
      hence meet F in D by A1,A3,Th28;
    end;
    hence the Family of CS is absolutely-multiplicative;
  end;
  hence thesis;
end;

theorem Th31:
  for D being properly-upper-bound MSSubsetFamily of M
  for X being Element of bool M ex SF being non-empty MSSubsetFamily of M st
  for Y being ManySortedSet of I holds Y in SF iff Y in D & X c= Y
proof
  let D be properly-upper-bound MSSubsetFamily of M, X be Element of bool M;
A1: D c= bool M by PBOOLE:def 23;
  defpred P[set,set] means X.$1 c= $2;
  consider SF being ManySortedSet of I such that
A2: for i being set st i in I
  for e being set holds e in SF.i iff e in D.i & P[i,e] from PBOOLE:sch 2;
  SF is ManySortedSubset of bool M
  proof
    let i;
    assume
A3: i in I;
    then D.i c= (bool M).i by A1,PBOOLE:def 5;
    then
A4: D.i c= bool (M.i) by A3,MBOOLEAN:def 1;
    thus SF.i c= (bool M).i
    proof
      SF.i c= bool (M.i)
      proof
        let x;
        assume x in SF.i;
        then x in D.i by A2,A3;
        hence x in bool (M.i) by A4;
      end;
      hence thesis by A3,MBOOLEAN:def 1;
    end;
  end;
  then reconsider SF as ManySortedSubset of bool M;
  reconsider SF as MSSubsetFamily of M;
  SF is non-empty
  proof
    let i such that
A5: i in I;
    X in bool M by MSSUBFAM:12;
    then X c= M by MBOOLEAN:19;
    then
A6: X.i c= M.i by A5,PBOOLE:def 5;
    M in D by MSSUBFAM:def 7;
    then M.i in D.i by A5,PBOOLE:def 4;
    hence SF.i is non empty by A2,A5,A6;
  end;
  then reconsider SF as non-empty MSSubsetFamily of M;
  take SF;
  let Y be ManySortedSet of I;
  thus Y in SF implies Y in D & X c= Y
  proof
    assume
A7: Y in SF;
    thus Y in D
    proof
      let i;
      assume
A8:   i in I;
      then Y.i in SF.i by A7,PBOOLE:def 4;
      hence thesis by A2,A8;
    end;
    thus X c= Y
    proof
      let i;
      assume
A9:   i in I;
      then Y.i in SF.i by A7,PBOOLE:def 4;
      hence thesis by A2,A9;
    end;
  end;
  assume
A10: Y in D & X c= Y;
  let i;
  assume
A11: i in I;
  then Y.i in D.i & X.i c= Y.i by A10,PBOOLE:def 4,def 5;
  hence thesis by A2,A11;
end;

theorem Th32:
  for D being properly-upper-bound MSSubsetFamily of M
  for X being Element of bool M for SF being non-empty MSSubsetFamily of M st
  (for Y being ManySortedSet of I holds Y in SF iff Y in D & X c= Y) holds
  for i being set, Di being non empty set st i in I & Di = D.i
  holds SF.i = { z where z is Element of Di : X.i c= z }
proof
  let D be properly-upper-bound MSSubsetFamily of M, X be Element of bool M,
  SF be non-empty MSSubsetFamily of M such that
A1: (for Y being ManySortedSet of I holds Y in SF iff Y in D & X c= Y);
  let i be set, Di be non empty set such that
A2: i in I and
A3: Di = D.i;
  thus SF.i c= { z where z is Element of Di : X.i c= z }
  proof
    let x such that
A4: x in SF.i;
    consider K be ManySortedSet of I such that
A5: K in SF by PBOOLE:146;
    dom (K +* (i .--> x)) = I by A2,PZFMISC1:1;
    then reconsider L = K +* (i .--> x) as ManySortedSet of I by PBOOLE:def 3;
A6: dom (i .--> x) = {i} by FUNCOP_1:19;
    i in {i} by TARSKI:def 1;
    then
A7: L.i = (i .--> x).i by A6,FUNCT_4:14
      .= x by FUNCOP_1:87;
    L in SF
    proof
      let s be set such that
A8:   s in I;
      per cases;
      suppose s = i;
        hence L.s in SF.s by A4,A7;
      end;
      suppose s <> i;
        then not s in dom (i .--> x) by A6,TARSKI:def 1;
        then L.s = K.s by FUNCT_4:12;
        hence L.s in SF.s by A5,A8,PBOOLE:def 4;
      end;
    end;
    then L in D & X c= L by A1;
    then L.i in D.i & X.i c= L.i by A2,PBOOLE:def 4,def 5;
    hence thesis by A3,A7;
  end;
  let x;
  assume x in { z where z is Element of Di : X.i c= z };
  then consider g be Element of Di such that
A9: g = x & X.i c= g;
A10: M in D by MSSUBFAM:def 7;
  dom (M +* (i .--> g)) = I by A2,PZFMISC1:1;
  then reconsider L1 = M +* (i .--> g) as ManySortedSet of I by PBOOLE:def 3;
A11: dom (i .--> g) = {i} by FUNCOP_1:19;
  i in {i} by TARSKI:def 1;
  then
A12: L1.i = (i .--> g).i by A11,FUNCT_4:14
    .= g by FUNCOP_1:87;
A13: L1 in D
  proof
    let s be set such that
A14: s in I;
    per cases;
    suppose s = i;
      hence L1.s in D.s by A3,A12;
    end;
    suppose s <> i;
      then not s in dom (i .--> g) by A11,TARSKI:def 1;
      then L1.s = M.s by FUNCT_4:12;
      hence L1.s in D.s by A10,A14,PBOOLE:def 4;
    end;
  end;
  X c= L1
  proof
    let s be set such that
A15: s in I;
    per cases;
    suppose s = i;
      hence X.s c= L1.s by A9,A12;
    end;
    suppose s <> i;
      then not s in dom (i .--> g) by A11,TARSKI:def 1;
      then
A16:  L1.s = M.s by FUNCT_4:12;
      X in bool M by MSSUBFAM:12;
      then X c= M by MBOOLEAN:19;
      hence X.s c= L1.s by A15,A16,PBOOLE:def 5;
    end;
  end;
  then L1 in SF by A1,A13;
  hence x in SF.i by A2,A9,A12,PBOOLE:def 4;
end;

theorem Th33:
  for D being properly-upper-bound MSSubsetFamily of M
  ex J being MSSetOp of M st for X being Element of bool M
  for SF being non-empty MSSubsetFamily of M st
  (for Y being ManySortedSet of I holds
  Y in SF iff Y in D & X c= Y) holds J..X = meet SF
proof
  let D be properly-upper-bound MSSubsetFamily of M;
  set G = bool M;
  defpred P[set,set,set] means for sf being Subset-Family of M.$3
  for Fi being non empty set st Fi = D.$3 &
  sf = { z where z is Element of Fi : $2 c= z } holds $1 = Intersect sf;
A1: now
    let i be set such that
A2: i in I;
    let x be set such that
A3: x in G.i;
    consider K being ManySortedSet of I such that
A4: K in G by PBOOLE:146;
    dom (K +* (i .--> x)) = I by A2,PZFMISC1:1;
    then reconsider X = K +* (i .--> x) as ManySortedSet of I by PBOOLE:def 3;
A5: dom (i .--> x) = {i} by FUNCOP_1:19;
    i in {i} by TARSKI:def 1;
    then
A6: X.i = (i .--> x).i by A5,FUNCT_4:14
      .= x by FUNCOP_1:87;
A7: X is Element of bool M
    proof
      let s be set such that
A8:   s in I;
      per cases;
      suppose s = i;
        hence X.s is Element of (bool M).s by A3,A6;
      end;
      suppose s <> i;
        then not s in dom (i .--> x) by A5,TARSKI:def 1;
        then X.s = K.s by FUNCT_4:12;
        hence X.s is Element of (bool M).s by A4,A8,PBOOLE:def 4;
      end;
    end;
    then consider SF being non-empty MSSubsetFamily of M such that
A9: for Y being ManySortedSet of I holds Y in SF iff Y in D & X c= Y by Th31;
    reconsider sf = SF.i as Subset-Family of M.i by A2,MSSUBFAM:32;
    reconsider b = (bool M).i as non empty set by A2;
    reconsider q = Intersect sf as Element of b by A2,MBOOLEAN:def 1;
    reconsider s = b --> q as Function of b, b by FUNCOP_1:57;
    take y = s.x;
    Intersect sf in bool (M.i);
    then Intersect sf in b by A2,MBOOLEAN:def 1;
    hence y in G.i by A3,FUNCOP_1:13;
    thus P[y,x,i]
    proof
      let sf1 be Subset-Family of M.i, Fi be non empty set such that
A10:  Fi = D.i & sf1 = { z where z is Element of Fi : x c= z };
      reconsider Di = D.i as non empty set by A2;
      SF.i = { z where z is Element of Di : X.i c= z } by A2,A7,A9,Th32;
      hence y = Intersect sf1 by A3,A6,A10,FUNCOP_1:13;
    end;
  end;
  consider J being ManySortedFunction of G, G such that
A11: for i be set st i in I holds ex f be Function of G.i, G.i st f = J.i &
  for x be set st x in G.i holds P[f.x,x,i] from MSSUBFAM:sch 1(A1);
  reconsider J as MSSetOp of M;
  take J;
  let X be Element of bool M, SF be non-empty MSSubsetFamily of M such that
A12: (for Y being ManySortedSet of I holds Y in SF iff Y in D & X c= Y);
  now
    let i;
    assume
A13: i in I;
    then consider f being Function of G.i, G.i such that
A14: f = J.i and
A15: for x st x in G.i holds P[f.x,x,i] by A11;
    consider Q being Subset-Family of (M.i) such that
A16: Q = SF.i and
A17: (meet SF).i = Intersect Q by A13,MSSUBFAM:def 2;
    reconsider Fi = D.i as non empty set by A13;
A18: Q = { z where z is Element of Fi : X.i c= z } by A12,A13,A16,Th32;
    X in G by MSSUBFAM:12;
    then
A19: X.i in G.i by A13,PBOOLE:def 4;
    dom J = I by PBOOLE:def 3;
    hence (J..X).i = f.(X.i) by A13,A14,PRALG_1:def 17
      .= (meet SF).i by A15,A17,A18,A19;
  end;
  hence J..X = meet SF by PBOOLE:3;
end;

theorem Th34:
  for D being properly-upper-bound MSSubsetFamily of M
  for A being Element of bool M for J being MSSetOp of M st A in D &
  for X being Element of bool M for SF being non-empty MSSubsetFamily of M st
  (for Y being ManySortedSet of I holds
  Y in SF iff Y in D & X c= Y) holds J..X = meet SF holds J..A = A
proof
  let D be properly-upper-bound MSSubsetFamily of M, A be Element of bool M,
  J be MSSetOp of M such that
A1: A in D and
A2: for X being Element of bool M
  for SF being non-empty MSSubsetFamily of M st
  (for Y being ManySortedSet of I holds
  Y in SF iff Y in D & X c= Y) holds J..X = meet SF;
  consider SF being non-empty MSSubsetFamily of M such that
A3: for Y being ManySortedSet of I holds Y in SF iff Y in D & A c= Y by Th31;
  thus J..A = A
  proof
    A in SF by A1,A3;
    then meet SF c= A by MSSUBFAM:43;
    hence J..A c= A by A2,A3;
A4: J..A = meet SF by A2,A3;
    for Z1 being ManySortedSet of I st Z1 in SF holds A c= Z1 by A3;
    hence A c= J..A by A4,MSSUBFAM:45;
  end;
end;

theorem
  for D being absolutely-multiplicative MSSubsetFamily of M
  for A being Element of bool M for J being MSSetOp of M st J..A = A &
  for X being Element of bool M for SF being non-empty MSSubsetFamily of M st
  (for Y being ManySortedSet of I holds
  Y in SF iff Y in D & X c= Y) holds J..X = meet SF holds A in D
proof
  let D be absolutely-multiplicative MSSubsetFamily of M,
  A be Element of bool M, J be MSSetOp of M such that
A1: J..A = A and
A2: for X being Element of bool M
  for SF being non-empty MSSubsetFamily of M st
  (for Y being ManySortedSet of I holds
  Y in SF iff Y in D & X c= Y) holds J..X = meet SF;
  consider SF being non-empty MSSubsetFamily of M such that
A3: (for Y being ManySortedSet of I holds
  Y in SF iff Y in D & A c= Y) by Th31;
A4: J..A = meet SF by A2,A3;
  defpred P[ManySortedSet of I] means A c= $1;
  (for Y being ManySortedSet of I holds Y in SF iff Y in D & P[Y])
  implies SF c= D from MSSUBSET;
  hence thesis by A1,A3,A4,MSSUBFAM:def 6;
end;

theorem Th36:
  for D being properly-upper-bound MSSubsetFamily of M
  for J being MSSetOp of M st for X being Element of bool M
  for SF being non-empty MSSubsetFamily of M st
  (for Y being ManySortedSet of I holds
  Y in SF iff Y in D & X c= Y) holds J..X = meet SF
  holds J is reflexive monotonic
proof
  let D be properly-upper-bound MSSubsetFamily of M,
  J be MSSetOp of M such that
A1: for X being Element of bool M
  for SF being non-empty MSSubsetFamily of M st
  (for Y being ManySortedSet of I holds
  Y in SF iff Y in D & X c= Y) holds J..X = meet SF;
  thus J is reflexive
  proof
    let X be Element of bool M;
    consider SF being non-empty MSSubsetFamily of M such that
A2: for Y being ManySortedSet of I holds Y in SF iff Y in D & X c= Y by Th31;
A3: J..X = meet SF by A1,A2;
    for Z1 being ManySortedSet of I st Z1 in SF holds X c= Z1 by A2;
    hence X c= J..X by A3,MSSUBFAM:45;
  end;
  thus J is monotonic
  proof
    let x, y be Element of bool M such that
A4: x c= y;
    consider SFx being non-empty MSSubsetFamily of M such that
A5: for Y being ManySortedSet of I holds Y in SFx iff Y in D & x c= Y by Th31;
A6: J..x = meet SFx by A1,A5;
    consider SFy being non-empty MSSubsetFamily of M such that
A7: for Y being ManySortedSet of I holds Y in SFy iff Y in D & y c= Y by Th31;
    SFy c= SFx
    proof
      let i;
      assume
A8:   i in I;
      then
A9:   x.i c= y.i by A4,PBOOLE:def 5;
      D.i is non empty by A8;
      then consider Fi be non empty set such that
A10:  Fi = D.i;
A11:  SFx.i = { t where t is Element of Fi : x.i c= t } by A5,A8,A10,Th32;
      SFy.i = { z where z is Element of Fi : y.i c= z } by A7,A8,A10,Th32;
      hence SFy.i c= SFx.i by A9,A11,Th1;
    end;
    then meet SFx c= meet SFy by MSSUBFAM:46;
    hence J..x c= J..y by A1,A6,A7;
  end;
end;

theorem Th37:
  for D being absolutely-multiplicative MSSubsetFamily of M
  for J being MSSetOp of M st for X being Element of bool M
  for SF being non-empty MSSubsetFamily of M st
  (for Y being ManySortedSet of I holds
  Y in SF iff Y in D & X c= Y) holds J..X = meet SF holds J is idempotent
proof
  let D be absolutely-multiplicative MSSubsetFamily of M,
  J be MSSetOp of M such that
A1: for X being Element of bool M
  for SF being non-empty MSSubsetFamily of M st
  (for Y being ManySortedSet of I holds
  Y in SF iff Y in D & X c= Y) holds J..X = meet SF;
  let X be Element of bool M;
  consider SF being non-empty MSSubsetFamily of M such that
A2: for Y being ManySortedSet of I holds Y in SF iff Y in D & X c= Y by Th31;
A3: D c= bool M by PBOOLE:def 23;
  defpred P[ManySortedSet of I] means X c= $1;
  (for Y being ManySortedSet of I holds Y in SF iff Y in D & P[Y])
  implies SF c= D from MSSUBSET;
  then
A4: meet SF in D by A2,MSSUBFAM:def 6;
  then
A5: meet SF is Element of bool M by A3,MSSUBFAM:11,PBOOLE:9;
  thus J..X = meet SF by A1,A2
    .= J..(meet SF) by A1,A4,A5,Th34
    .= J..(J..X) by A1,A2;
end;

theorem
  for D being MSClosureSystem of S for J being MSSetOp of the Sorts of D st
  for X being Element of bool the Sorts of D
  for SF being non-empty MSSubsetFamily of the Sorts of D st
  (for Y being ManySortedSet of the carrier of S holds
  Y in SF iff Y in the Family of D & X c= Y) holds J..X = meet SF
  holds J is MSClosureOperator of the Sorts of D by Th36,Th37;

definition
  let S;
  let A be ManySortedSet of the carrier of S;
  let C be MSClosureOperator of A;
  func ClOp->ClSys C -> MSClosureSystem of S means
  :Def14:
  ex D being MSSubsetFamily of A st D = MSFixPoints C &
  it = MSClosureStr (#A, D#);
  existence
  proof
    reconsider D = MSFixPoints C as MSSubsetFamily of A;
    reconsider a = MSClosureStr (#A, D#) as MSClosureSystem of S by Th30;
    take a;
    thus thesis;
  end;
  uniqueness;
end;

registration
  let S;
  let A be ManySortedSet of the carrier of S;
  let C be MSClosureOperator of A;
  cluster ClOp->ClSys C -> strict;
  coherence
  proof
    consider D being MSSubsetFamily of A such that
A1: D = MSFixPoints C & ClOp->ClSys C = MSClosureStr (#A, D#) by Def14;
    thus thesis by A1;
  end;
end;

registration
  let S;
  let A be non-empty ManySortedSet of the carrier of S;
  let C be MSClosureOperator of A;
  cluster ClOp->ClSys C -> non-empty;
  coherence
  proof
    consider D being MSSubsetFamily of A such that
A1: D = MSFixPoints C & ClOp->ClSys C = MSClosureStr (#A, D#) by Def14;
    thus thesis by A1;
  end;
end;

definition
  let S;
  let D be MSClosureSystem of S;
  func ClSys->ClOp D -> MSClosureOperator of the Sorts of D means
  :Def15:
  for X being Element of bool the Sorts of D
  for SF being non-empty MSSubsetFamily of the Sorts of D st
  (for Y being ManySortedSet of the carrier of S holds
  Y in SF iff Y in the Family of D & X c= Y) holds it..X = meet SF;
  existence
  proof
    consider J being MSSetOp of the Sorts of D such that
A1: for X being Element of bool the Sorts of D
    for SF being non-empty MSSubsetFamily of the Sorts of D st
    (for Y being ManySortedSet of the carrier of S holds Y in SF iff Y in
    the Family of D & X c= Y) holds J..X = meet SF by Th33;
    reconsider J as MSClosureOperator of the Sorts of D by A1,Th36,Th37;
    take J;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let Q1, Q2 be MSClosureOperator of the Sorts of D such that
A2: for X being Element of bool the Sorts of D
    for SF being non-empty MSSubsetFamily of the Sorts of D st
    (for Y being ManySortedSet of the carrier of S holds
    Y in SF iff Y in the Family of D & X c= Y) holds Q1..X = meet SF and
A3: for X being Element of bool the Sorts of D
    for SF being non-empty MSSubsetFamily of the Sorts of D st
    (for Y being ManySortedSet of the carrier of S holds
    Y in SF iff Y in the Family of D & X c= Y) holds Q2..X = meet SF;
    set M = the Sorts of D;
    now
      let x be ManySortedSet of the carrier of S;
      assume x in bool M;
      then
A4:   x is Element of bool M by MSSUBFAM:11;
      then consider SF being non-empty MSSubsetFamily of the Sorts of D such
      that
A5:   (for Y being ManySortedSet of the carrier of S holds
      Y in SF iff Y in the Family of D & x c= Y) by Th31;
      thus Q1..x = meet SF by A2,A4,A5
        .= Q2..x by A3,A4,A5;
    end;
    hence Q1 = Q2 by Th7;
  end;
end;

theorem
  for A being ManySortedSet of the carrier of S
  for J being MSClosureOperator of A holds ClSys->ClOp (ClOp->ClSys J) = J
proof
  let A be ManySortedSet of the carrier of S, J be MSClosureOperator of A;
  set I = the carrier of S, M = the Sorts of ClOp->ClSys J,
  j = ClSys->ClOp (ClOp->ClSys J);
  consider D being MSSubsetFamily of A such that
A1: D = MSFixPoints J and
A2: ClOp->ClSys J = MSClosureStr (#A, D#) by Def14;
A3: the Family of ClOp->ClSys J = D by A2;
  for X being ManySortedSet of I st X in bool A holds j..X = J..X
  proof
    let X be ManySortedSet of I;
    assume X in bool A;
    then
A4: X is Element of bool M by A2,MSSUBFAM:11;
    then consider SF being non-empty MSSubsetFamily of M such that
A5: for Y being ManySortedSet of I holds
    Y in SF iff Y in MSFixPoints J & X c= Y by A1,A3,Th31;
    now
      let i such that
A6:   i in I;
A7:   dom J = I by PBOOLE:def 3;
      reconsider f = J.i as Function of (bool A).i, (bool A).i
      by A6,PBOOLE:def 18;
      (bool A).i = bool (A.i) by A6,MBOOLEAN:def 1;
      then reconsider f as Function of bool (A.i), bool (A.i);
      consider Q being Subset-Family of (M.i) such that
A8:   Q = SF.i and
A9:   (meet SF).i = Intersect Q by A6,MSSUBFAM:def 2;
      reconsider Di = (MSFixPoints J).i as non empty set
      by A1,A3,A6;
      Intersect Q = f.(X.i)
      proof
A10:    SF.i = { z where z is Element of Di : X.i c= z }
        by A1,A3,A4,A5,A6,Th32;
        X.i is Element of (bool A).i by A2,A4,A6,PBOOLE:def 17;
        then
A11:    X.i is Element of bool (A.i) by A6,MBOOLEAN:def 1;
A12:    dom f = bool (A.i) by FUNCT_2:def 1;
A13:    f.(X.i) in bool (A.i) by A11,FUNCT_2:7;
        f.(f.(X.i)) = f.(X.i) by A6,A11,Th26;
        then
A14:    f.(X.i) is Element of Di by A6,A12,A13,Def13;
        X.i c= f.(X.i) by A6,A11,Th24;
        then f.(X.i) in { z where z is Element of Di : X.i c= z } by A14;
        hence Intersect Q c= f.(X.i) by A8,A10,MSSUBFAM:2;
A15:    Q <> {} by A6,A8;
        now
          let x;
          assume x in Q;
          then consider x1 being Element of Di such that
A16:      x1 = x & X.i c= x1 by A8,A10;
          MSFixPoints J c= bool A by PBOOLE:def 23;
          then Di c= (bool A).i by A6,PBOOLE:def 5;
          then Di c= bool (A.i) by A6,MBOOLEAN:def 1;
          then
A17:      x1 is Element of bool (A.i) by TARSKI:def 3;
          consider g being Function such that
A18:      g = J.i & x1 in dom g & g.x1 = x1 by A6,Def13;
          thus f.(X.i) c= x by A6,A11,A16,A17,A18,Th25;
        end;
        hence f.(X.i) c= Intersect Q by A15,MSSUBFAM:5;
      end;
      hence (j..X).i = f.(X.i) by A1,A2,A4,A5,A9,Def15
        .= (J..X).i by A6,A7,PRALG_1:def 17;
    end;
    hence thesis by PBOOLE:3;
  end;
  hence ClSys->ClOp (ClOp->ClSys J) = J by A2,Th7;
end;

theorem
  for D being MSClosureSystem of S holds
  ClOp->ClSys (ClSys->ClOp D) = the MSClosureStr of D
proof
  let D be MSClosureSystem of S;
  set M = the Sorts of D, F = the Family of D, I = the carrier of S;
  consider MS being MSSubsetFamily of M such that
A1: MS = MSFixPoints (ClSys->ClOp D) and
A2: ClOp->ClSys (ClSys->ClOp D) = MSClosureStr (#M, MS#) by Def14;
  consider X1 being ManySortedSet of I such that
A3: X1 in bool M by PBOOLE:146;
  F = MSFixPoints (ClSys->ClOp D)
  proof
    thus F c= MSFixPoints (ClSys->ClOp D)
    proof
      let i such that
A4:   i in I;
      let x such that
A5:   x in F.i;
      dom (X1 +* (i .--> x)) = I by A4,PZFMISC1:1;
      then reconsider X = X1 +* (i .--> x) as ManySortedSet of I by
      PBOOLE:def 3;
A6:   dom (i .--> x) = {i} by FUNCOP_1:19;
      i in {i} by TARSKI:def 1;
      then
A7:   X.i = (i .--> x).i by A6,FUNCT_4:14
        .= x by FUNCOP_1:87;
      F c= bool M by PBOOLE:def 23;
      then
A8:   F.i c= (bool M).i by A4,PBOOLE:def 5;
      then
A9:   x in (bool M).i by A5;
      X is Element of bool M
      proof
        let s be set such that
A10:    s in I;
        per cases;
        suppose s = i;
          hence X.s is Element of (bool M).s by A5,A7,A8;
        end;
        suppose s <> i;
          then not s in dom (i .--> x) by A6,TARSKI:def 1;
          then X.s = X1.s by FUNCT_4:12;
          hence X.s is Element of (bool M).s by A3,A10,PBOOLE:def 4;
        end;
      end;
      then reconsider X as Element of bool M;
      reconsider Fi = F.i as non empty set by A4;
      reconsider f = (ClSys->ClOp D).i as Function of (bool M).i, (bool M).i
      by A4,PBOOLE:def 18;
      consider SF being non-empty MSSubsetFamily of M such that
A11:  for Y being ManySortedSet of I holds
      Y in SF iff Y in F & X c= Y by Th31;
      consider Q being Subset-Family of (M.i) such that
A12:  Q = SF.i and
A13:  (meet SF).i = Intersect Q by A4,MSSUBFAM:def 2;
A14:  x in dom f by A9,FUNCT_2:def 1;
A15:  SF.i = { z where z is Element of Fi : X.i c= z } by A4,A11,Th32;
A16:  Intersect Q = x
      proof
        x in { B where B is Element of Fi : x c= B } by A5;
        hence Intersect Q c= x by A7,A12,A15,MSSUBFAM:2;
A17:    Q <> {} by A4,A12;
        now
          let Z1 be set;
          assume Z1 in Q;
          then consider q being Element of Fi such that
A18:      q = Z1 & X.i c= q by A12,A15;
          thus x c= Z1 by A7,A18;
        end;
        hence thesis by A17,MSSUBFAM:5;
      end;
A19:  (ClSys->ClOp D)..X = meet SF by A11,Def15;
      dom ClSys->ClOp D = I by PBOOLE:def 3;
      then f.x = x by A4,A7,A13,A16,A19,PRALG_1:def 17;
      hence x in (MSFixPoints (ClSys->ClOp D)).i by A4,A14,Def13;
    end;
    let i such that
A20: i in I;
    let x;
    assume
A21: x in (MSFixPoints (ClSys->ClOp D)).i;
    then consider f being Function such that
A22: f = (ClSys->ClOp D).i & x in dom f & f.x = x by A20,Def13;
    dom (X1 +* (i .--> x)) = I by A20,PZFMISC1:1;
    then reconsider X = X1 +* (i .--> x) as ManySortedSet of I by PBOOLE:def 3;
A23: dom (i .--> x) = {i} by FUNCOP_1:19;
    i in {i} by TARSKI:def 1;
    then
A24: X.i = (i .--> x).i by A23,FUNCT_4:14
      .= x by FUNCOP_1:87;
    MSFixPoints (ClSys->ClOp D) c= bool M by PBOOLE:def 23;
    then
A25: (MSFixPoints (ClSys->ClOp D)).i c= (bool M).i by A20,PBOOLE:def 5;
    X is Element of bool M
    proof
      let s be set such that
A26:  s in I;
      per cases;
      suppose s = i;
        hence X.s is Element of (bool M).s by A21,A24,A25;
      end;
      suppose s <> i;
        then not s in dom (i .--> x) by A23,TARSKI:def 1;
        then X.s = X1.s by FUNCT_4:12;
        hence X.s is Element of (bool M).s by A3,A26,PBOOLE:def 4;
      end;
    end;
    then reconsider X as Element of bool M;
    consider SF being non-empty MSSubsetFamily of M such that
A27: for Y being ManySortedSet of I holds Y in SF iff Y in F & X c= Y by Th31;
A28: dom ClSys->ClOp D = I by PBOOLE:def 3;
A29: (meet SF).i = ((ClSys->ClOp D)..X).i by A27,Def15
      .= x by A20,A22,A24,A28,PRALG_1:def 17;
    defpred P[ManySortedSet of I] means X c= $1;
    (for Y being ManySortedSet of I holds Y in SF iff Y in F & P[Y])
    implies SF c= F from MSSUBSET;
    then meet SF in F by A27,MSSUBFAM:def 6;
    hence x in F.i by A20,A29,PBOOLE:def 4;
  end;
  hence thesis by A1,A2;
end;

